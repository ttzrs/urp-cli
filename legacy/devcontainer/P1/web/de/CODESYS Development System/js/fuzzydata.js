$(document).ready(function () {indexDict['de'] = [{ "title" : "CODESYS Development System ", 
"url" : "_cds_start_page.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS Development System ", 
"snippet" : "Das CODESYS Development System ist das IEC 61131-3 Programmiertool für die industrielle Steuerungs- und Automatisierungstechnik. Das Programmiersystem ist in einer 32-Bit und einer 64-Bit-Version verfügbar. Sie können das CODESYS Development System im CODESYS Store International oder im CODESYS Stor...", 
"body" : "Das CODESYS Development System ist das IEC 61131-3 Programmiertool für die industrielle Steuerungs- und Automatisierungstechnik. Das Programmiersystem ist in einer 32-Bit und einer 64-Bit-Version verfügbar. Sie können das CODESYS Development System im CODESYS Store International oder im CODESYS Store North America herunterladen. Dort finden Sie auch das Datenblatt zum Produkt. " }, 
{ "title" : "Überblick ", 
"url" : "_cds_development_system.html", 
"breadcrumbs" : "CODESYS Essentials \/ Überblick ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS -Hilfe verwenden ", 
"url" : "_cds_development_system.html#UUID-0b219bde-e54a-015d-5b0c-50827cb3788f_section-idm4562692390587232647961086548", 
"breadcrumbs" : "CODESYS Essentials \/ Überblick \/ CODESYS -Hilfe verwenden ", 
"snippet" : "Die CODESYS -Hilfe soll Ihnen helfen, das CODESYS Development System problemlos und erfolgreich zu verwenden. Hier finden Sie schnell Antworten zu Fragen und Lösungen für Probleme. Jede Hilfekomponente besteht aus einem Konzept- und einem Referenzteil. Im Konzeptteil erklären wir detailliert alle Th...", 
"body" : "Die CODESYS -Hilfe soll Ihnen helfen, das CODESYS Development System problemlos und erfolgreich zu verwenden. Hier finden Sie schnell Antworten zu Fragen und Lösungen für Probleme. Jede Hilfekomponente besteht aus einem Konzept- und einem Referenzteil. Im Konzeptteil erklären wir detailliert alle Themen, die beim Erstellen eines CODESYS -Projekts relevant sind. Ergänzt werden die Konzepte durch Handlungsanweisungen, wo Sie Schritt-für-Schritt zum gewünschten Ergebnis geführt werden. Die Referenzteile sind vollständige Nachschlagewerke für die Benutzeroberfläche und die Programmierung von CODESYS . In den CODESYS -Optionen legen Sie fest, ob Sie die CODESYS -Offlinehilfe oder die CODESYS -Onlinehilfe verwenden möchten. Sie können die Hilfe kontextsensitiv direkt aus der Oberfläche des CODESYS Development System aufrufen. Wenn Sie in CODESYS den Cursor auf einem Objekt, Menübefehl oder Programmierelement positionieren und die Taste F1 drücken, erscheint die jeweilige Hilfeseite. Alternativ können Sie die Befehle im Menü Hilfe verwenden. Bei der Suche handelt es sich um eine Volltextsuche. Die Indexsuche ist nur in der CODESYS -Offlinehilfe möglich. Suchoperatoren für die Offlinehilfe AND Wird automatisch verwendet, zum Beispiel führt die Eingabe der Suchbegriffe Device Diagnosis zum gleichen Suchergebnis wie die Eingabe von Device AND Diagnosis Der Platzhalter * wird automatisch verwendet. Das Zeichen * darf jedoch nicht als Wildcard eingegeben werden, da in diesem Fall direkt nach dem Zeichen * gesucht wird. " }, 
{ "title" : "CODESYS Systemüberblick ", 
"url" : "_cds_development_system.html#UUID-0b219bde-e54a-015d-5b0c-50827cb3788f_section-idm4564593995971232647965283006", 
"breadcrumbs" : "CODESYS Essentials \/ Überblick \/ CODESYS Systemüberblick ", 
"snippet" : "Das IEC 61131-3 Programmierwerkzeug CODESYS Development System bildet den Kern der CODESYS -Softwareplattform für Aufgabenstellungen in der industriellen Automatisierungstechnik. Mit zusätzlichen, integrierten Lösungen für beispielsweise Bewegungssteuerungen, Visualisierungen und Feldbusanbindungen ...", 
"body" : "Das IEC 61131-3 Programmierwerkzeug CODESYS Development System bildet den Kern der CODESYS -Softwareplattform für Aufgabenstellungen in der industriellen Automatisierungstechnik. Mit zusätzlichen, integrierten Lösungen für beispielsweise Bewegungssteuerungen, Visualisierungen und Feldbusanbindungen werden die üblichen praktischen Anforderungen mit einem System abgedeckt. " }, 
{ "title" : "Funktionalitäten ", 
"url" : "_cds_development_system.html#UUID-0b219bde-e54a-015d-5b0c-50827cb3788f_section-idm4564593977048032647968557534", 
"breadcrumbs" : "CODESYS Essentials \/ Überblick \/ Funktionalitäten ", 
"snippet" : "Das kostenfreie CODESYS Development System ist eine IEC 61131-3 Programmierplattform für Automatisierungsgeräte mit Steuerungsaufgaben. Sie stellt Ihnen vielfältige und komfortable Engineering-Funktionen für Ihre Entwicklungsarbeit zur Verfügung: Siehe hierzu in dieser Onlinehilfe: Projektkonfigurat...", 
"body" : "Das kostenfreie CODESYS Development System ist eine IEC 61131-3 Programmierplattform für Automatisierungsgeräte mit Steuerungsaufgaben. Sie stellt Ihnen vielfältige und komfortable Engineering-Funktionen für Ihre Entwicklungsarbeit zur Verfügung: Siehe hierzu in dieser Onlinehilfe: Projektkonfiguration durch Assistenten (Wizards) Projekt anlegen und konfigurierenAnpassungsmöglichkeit der Oberfläche Oberfläche anpassenErzeugung von professionellen Steuerungsapplikationen nach IEC 61131-3 mit vielen Standardfunktionen Applikation programmierenKomfortable Programmierung mit Maus und Tastatur in allen Sprachen der IEC 61131-3 Entsprechende Editoren für FUP, KOP, AWL, ST, AS, dazu die Varianten CFC und Erweiterter CFC Programmiersprachen und ihre EditorenEingabeunterstützung für die Eingabe und Konfiguration unterschiedlichster Daten Eingabeunterstützung nutzenUnterstützung objektorientierter Programmierung Echte objektorientierte Programmierung nach 61131-3 3rd Edition in allen Sprachen der IEC 61131-3 ohne zusätzliche Tools möglich Vererbung von Programmbausteinen auf ähnliche Applikationsteile zur Reduktion von Entwicklungszeit und Fehlern Objektorientierte Programmierung ist kein Muss: Funktionale oder objektorientierte Programmierung sind beliebig einsetzbar und mischbar. Objektorientiert programmierenUmfassender Projektvergleich, auch für grafische Editoren Projekt vergleichenBibliothekskonzept zur einfachen Wiederverwendung von Applikationscode Bibliotheken verwendenDebugging- und Online-Eigenschaften zur Optimierung des Applikationscodes und zur Beschleunigung von Test und Inbetriebnahme Testen und Fehler behebenIntegrierte Compiler für viele CPU-Plattformen zur Optimierung der Performance der Steuerung CompilerversionCompile-OptionenSecurity-Eigenschaften zur Absicherung des Quellcodes und des Betriebs der Steuerung Projekt schützen und speichernApplikation schützenGerätebenutzerverwaltung handhabenPackages und Lizenzen verwaltenFeldbusunterstützung und Programmierung von Geräten unterschiedlichster Hersteller E\/A-Anbindung konfigurierenErweiterbarkeit und Anpassbarkeit, ohne den Produktrahmen zu verlassen Packages und Lizenzen verwaltenAußerdem: Nahtlos integrierte Tools für weitere Automatisierungsaufgaben, beispielsweise CODESYS Visualization , CODESYS SoftMotion und CODESYS Application Composer Beachten Sie jederzeit auch die Möglichkeit, die Funktionalität mit Hilfe von Addon-Packages zu erweitern, die über den CODESYS Store International bereitstehen. " }, 
{ "title" : "Einstellung der Sprache der Benutzeroberfläche ", 
"url" : "_cds_development_system.html#UUID-0b219bde-e54a-015d-5b0c-50827cb3788f_section-idm4562692385747232647971307357", 
"breadcrumbs" : "CODESYS Essentials \/ Überblick \/ Einstellung der Sprache der Benutzeroberfläche ", 
"snippet" : "Im Dialog Optionen → Internationale Einstellungen können Sie die Landessprache einstellen, in der die Oberfläche des Entwicklungssystems beim nächsten Start erscheinen soll. Die Landessprache der Hilfe können Sie separat davon festlegen. Wenn Sie CODESYS über die Kommandozeile aufrufen, können Sie ü...", 
"body" : "Im Dialog Optionen → Internationale Einstellungen können Sie die Landessprache einstellen, in der die Oberfläche des Entwicklungssystems beim nächsten Start erscheinen soll. Die Landessprache der Hilfe können Sie separat davon festlegen. Wenn Sie CODESYS über die Kommandozeile aufrufen, können Sie über einen Parameter die Sprache der Oberfläche festlegen. " }, 
{ "title" : "Urheberrechte und Warenzeichen ", 
"url" : "_cds_development_system.html#UUID-0b219bde-e54a-015d-5b0c-50827cb3788f_section-idm456459407124003264797233218", 
"breadcrumbs" : "CODESYS Essentials \/ Überblick \/ Urheberrechte und Warenzeichen ", 
"snippet" : "Die Rechte aller in dieser CODESYS -Hilfe genannten Firmen und Firmennamen sowie Waren und Warennamen liegen bei den jeweiligen Firmen. Technische Änderungen vorbehalten. Diese Hilfe oder Teile daraus dürfen nur in Absprache mit CODESYS GmbH kopiert oder weiterverwendet werden....", 
"body" : "Die Rechte aller in dieser CODESYS -Hilfe genannten Firmen und Firmennamen sowie Waren und Warennamen liegen bei den jeweiligen Firmen. Technische Änderungen vorbehalten. Diese Hilfe oder Teile daraus dürfen nur in Absprache mit CODESYS GmbH kopiert oder weiterverwendet werden. " }, 
{ "title" : "Whitepaper: Modularisierung aus Sicht des Anwenders ", 
"url" : "_cds_codesys_modularization.html", 
"breadcrumbs" : "CODESYS Essentials \/ Whitepaper: Modularisierung aus Sicht des Anwenders ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Einleitung ", 
"url" : "_cds_codesys_modularization.html#UUID-5c384bff-d9da-6867-04ee-1ecd44a1c396_id_f94aeb495b85ce36c0a86463409947a4_id_66e987b85bec06a3c0a864633232042b", 
"breadcrumbs" : "CODESYS Essentials \/ Whitepaper: Modularisierung aus Sicht des Anwenders \/ Einleitung ", 
"snippet" : "In CODESYS 3.5 SP17 haben wir einen großen architekturellen Umbau vollzogen. Früher war der größte Teil der Programmiersystemfunktionalität in einem einzigen zusammenhängenden Setup gebündelt. Lediglich CODESYS SoftMotion sowie die kostenpflichtigen Add-ons der CODESYS Professional Developer Edition...", 
"body" : "In CODESYS 3.5 SP17 haben wir einen großen architekturellen Umbau vollzogen. Früher war der größte Teil der Programmiersystemfunktionalität in einem einzigen zusammenhängenden Setup gebündelt. Lediglich CODESYS SoftMotion sowie die kostenpflichtigen Add-ons der CODESYS Professional Developer Edition waren separat. Im Zuge des Umbaus haben wir nun diese Modularisierung bis weit in die Kernfunktionalität hinein fortgeführt. So sind die meisten Programmierspracheneditoren, Feldbuskonfiguratoren und Codegeneratoren nun in eigene Add-ons ausgelagert. Dasselbe gilt für große Features wie die Visualisierung oder die Symbolkonfiguration, um zwei Beispiele zu nennen. Im Kern verbleiben noch wichtige Infrastruktur-Features wie das Oberflächengerüst (Menüsystem, Navigator, Meldungsfenster, etc.), das Compiler-Frontend sowie Komponenten zum Projekt-Handling und zur Kommunikation mit Steuerungen. Es sollte erwähnt werden, dass zukünftig noch weitere Teile vom Kern in separate Add-ons verschoben werden können. Wir werden diese Modularisierung in erster Linie dazu nutzen, die Versionszyklen der einzelnen Bestandteile zu entzerren. In der Vergangenheit war es notwendig, die gesamte CODESYS -Entwicklung bezüglich neuer Features und Improvements auf einen einzigen Termin pro Jahr - nämlich dem Release-Datum eines Service Packs - zu konvergieren. Features, die knapp nicht fertig wurden, haben meist zu einer Verschiebung des Service Packs geführt. Features, die vom Zeitplan deutlich unpassend waren, haben sich um ein ganzes Jahr in die Zukunft verschoben. Diese Verzahnung möchten wir sowohl aus eigenem Interesse als auch im Interesse aller CODESYS -Anwender auflösen und zukünftig jedes Add-on unabhängig versionieren und freigeben. Für CODESYS -Anwender ergeben sich eine Reihe naheliegender und gewichtiger Vorteile. Features werden zeitnah nach Fertigstellung freigegeben und stehen so schnell wie möglich zur Verfügung. Beta-Versionen von Add-ons können an interessierte Anwender ausgeliefert werden, um eine rechtzeitige Feedback-Möglichkeit zu haben. Dabei kann eine solche Beta-Version in einer ansonsten stabilen Umgebung betrieben werden. Nicht benötige Add-ons können entfernt werden, was sowohl dem Platzbedarf als auch der Gesamt-Performance zuträglich ist. Natürlich steht dieser Flexibilität eine gesteigerte Komplexität gegenüber. In diesem Whitepaper möchten wir beschreiben, welche Einschränkungen bestehen welche Maßnahmen wir ergriffen haben, um die Komplexität beherrschbar zu machen welches Vorgehen wir für typische Anwendungsfälle empfehlen " }, 
{ "title" : "Das Setup ", 
"url" : "_cds_codesys_modularization.html#UUID-5c384bff-d9da-6867-04ee-1ecd44a1c396_id_f94aeb495b85ce36c0a86463409947a4_id_3ce1a2b05bec06a3c0a8646354ca4853", 
"breadcrumbs" : "CODESYS Essentials \/ Whitepaper: Modularisierung aus Sicht des Anwenders \/ Das Setup ", 
"snippet" : "Das Setup, welches nach wie vor aus dem CODESYS Store International heruntergeladen werden kann, ist vollständig. Alle Bestandteile, die schon Teil von CODESYS 3.5 SP16 und früher waren, sind auch im aktuellen Setup enthalten, d.h. Anwender erhalten nach der Installation ein gewohntes Gesamtsystem o...", 
"body" : "Das Setup, welches nach wie vor aus dem CODESYS Store International heruntergeladen werden kann, ist vollständig. Alle Bestandteile, die schon Teil von CODESYS 3.5 SP16 und früher waren, sind auch im aktuellen Setup enthalten, d.h. Anwender erhalten nach der Installation ein gewohntes Gesamtsystem ohne funktionale Abstriche. Wir finden, dass sich Anwender die individuelle Zusammenstellung von Kernsystem und Add-on-Versionen in Ruhe erarbeiten sollen und sich nicht schon von Anfang an zwangsweise damit beschäftigen müssen. Wir sind uns auch dessen bewusst, dass viele Anwender gar nicht unglücklich über das Gesamtpaket sind und vielleicht niemals eine individuelle Zusammenstellung machen möchten - ein vollkommen legitimer Ansatz, dem das Tool nicht im Weg stehen soll. " }, 
{ "title" : "Der Installer ", 
"url" : "_cds_codesys_modularization.html#UUID-5c384bff-d9da-6867-04ee-1ecd44a1c396_id_f94aeb495b85ce36c0a86463409947a4_id_ac5f82f95bec06a3c0a86463303421a1", 
"breadcrumbs" : "CODESYS Essentials \/ Whitepaper: Modularisierung aus Sicht des Anwenders \/ Der Installer ", 
"snippet" : "Das Setup installiert automatisch ein neues globales Tool, das sich CODESYS Installer nennt. Damit können alle CODESYS -Installationen sowie die damit in Verbindung stehenden Add-ons verwaltet werden. Es ist Dreh- und Angelpunkt für die Anwender, die von den Vorteilen der Modularisierung aktiv profi...", 
"body" : "Das Setup installiert automatisch ein neues globales Tool, das sich CODESYS Installer nennt. Damit können alle CODESYS -Installationen sowie die damit in Verbindung stehenden Add-ons verwaltet werden. Es ist Dreh- und Angelpunkt für die Anwender, die von den Vorteilen der Modularisierung aktiv profitieren möchten. Mit dem CODESYS Installer kann eine beliebige Anzahl unabhängiger Installationen verwaltet werden. Innerhalb jeder einzelnen Installation kann genau festgelegt werden, welche Add-ons Bestandteil sein sollen. Zur besseren Übersichtlichkeit kann jeder Installation ein sprechender Name gegeben werden. Bei jeder Installation kann eingestellt werden, welche Updates gemeldet werden sollen; standardmäßig ist dies auf „nur freigegebene Versionen“ eingestellt, es lässt sich aber auch auf Prerelease-Versionen umstellen oder auch abschalten, um den Stand einer Installation zu fixieren. Weitere Hinweise auf nützliche Funktionen des CODESYS Installer finden sich weiter unten bei den Empfehlungen. Innerhalb von CODESYS haben wir das Notification Center an den CODESYS Installer angebunden. Hier werden Nachrichten zu passenden Updates eingeblendet. Man muss also nicht ständig den CODESYS Installer ausführen, um über Updates benachrichtigt zu werden. " }, 
{ "title" : "Kompatibilität ", 
"url" : "_cds_codesys_modularization.html#UUID-5c384bff-d9da-6867-04ee-1ecd44a1c396_id_f94aeb495b85ce36c0a86463409947a4_id_0259f7295bec06a3c0a86463648ba988", 
"breadcrumbs" : "CODESYS Essentials \/ Whitepaper: Modularisierung aus Sicht des Anwenders \/ Kompatibilität ", 
"snippet" : "Hinter dem Stichwort Kompatibilität verbirgt sich der größte Komplexitätszuwachs, der sich aufgrund der Modularisierung ergibt. Während es traditionell eine lineare Weiterentwicklung gab und die Kompatibilitätsfrage daher einfach war („neues CODESYS kann altes Projekt lesen“), ist die Angelegenheit ...", 
"body" : "Hinter dem Stichwort Kompatibilität verbirgt sich der größte Komplexitätszuwachs, der sich aufgrund der Modularisierung ergibt. Während es traditionell eine lineare Weiterentwicklung gab und die Kompatibilitätsfrage daher einfach war („neues CODESYS kann altes Projekt lesen“), ist die Angelegenheit in einer hochmodularen Umgebung ungleich schwieriger. Die Entscheidungen, die wir getroffen haben und die in den nachfolgenden Abschnitten näher erläutert werden, sind bewusst nicht anhand des technisch Machbaren, sondern des sinnvoll Beherrschbaren getroffen worden. Projekt-Kompatibilität Hierbei geht es um die Frage, inwieweit eine CODESYS -Installation ein Projekt oder eine Bibliothek öffnen kann, die mit einer anderen CODESYS -Installation erstellt wurde. Diesen Mechanismus haben wir nicht geändert. Das Verhalten ist identisch wie in den CODESYS -Versionen vor der Modularisierung. Falls es im Projekt Daten gibt, die mit der aktuellen Version nicht gelesen oder interpretiert werden können, weil sie aus einer neueren Umgebung erzeugt wurden, so werden die betroffenen Objekte mit einem roten Kreuz im Navigator markiert und entweder mit [incomplete] (→ Editor kann noch geöffnet werden) oder [unknown] (→ Editor kann nicht mehr geöffnet werden) gekennzeichnet. In beiden Fällen lässt sich das Projekt nicht auf die Steuerung laden (weil sich ein undefiniertes Programmverhalten ergeben könnte), und es steht auch nur Speichern unter zur Verfügung (um ein versehentliches Überschreiben des Originalprojekts und damit einen Datenverlust zu verhindern). Dieses Verhalten hat sich seit Jahren bewährt. Code-Kompatibilität Hierbei geht es um die Frage, ob man mit einer CODESYS -Installation zu einem Projekt immer binärgleichen Steuerungscode generieren kann wie eine andere CODESYS -Installation. Vereinfacht ausgedrückt: Kann man ein beliebiges Projekt mit einer CODESYS -Installation öffnen und sich ohne Online-Change bzw. Download auf die Steuerung einloggen? Zu diesem Zweck gab es bis einschließlich CODESYS 3.5 SP17 das Konzept der Compilerversion. Die Compilerversion werden wir ab CODESYS 3.5 SP18 entfernen. Wenn man darauf angewiesen ist, sich mit einem Projekt ohne Online-Change bzw. Download auf eine Steuerung einloggen zu können, dann muss man das Projekt mit einer genau passenden CODESYS -Installation öffnen. Für die Entscheidung, das Konzept der Compilerversion aufzugeben, gibt es eine Reihe gewichtiger Argumente: Für den generierten Code sind nicht nur der Compiler, sondern auch die beteiligten Programmierspracheneditoren und Feldbuskonfiguratoren verantwortlich. Da diese nun in unabhängig versionierte Add-ons ausgelagert wurden, kann es prinzipiell keine einheitliche allumfassende Compilerversion mehr geben. Den Versuch, eine Kombination aus verschiedenen Add-on-spezifischen Compilerversionen zu einer Art Compilerversionsprofil zusammenzufassen, finden wir aus Anwendersicht übermäßig komplex. Bei CODESYS UML (Teil der CODESYS Professional Developer Edition ) gibt es schon seit Jahren eine separate Sprachmodellgenerierungsversion, aber schon bei diesem einen Add-on hat sich dieses Konzept in der Praxis nicht bewährt, geschweige denn bei der jetzigen Vielzahl an Add-ons. Die Compilerversion hat bereits in der einfachen Form genaue Kenntnis des Anwenders erfordert. Spätestens die Korrektur einer versehentlich falsch eingestellten Version war oft problematisch. Anwender, die damit schlechte Erfahrungen gemacht haben, oder die von diesem Konzept grundsätzlich nicht überzeugt waren, haben schon in der Vergangenheit mehrere Maintenance-Installationen mit sich geführt, um sich im Wartungsfall auf laufende Steuerungen sicher einloggen zu können. Wie wir weiter unten sehen werden, bieten wir für diesen Fall nun eine robuste interaktive Unterstützung an. Jede neue Compilerversion bläht unsere interne Codebasis auf. Einerseits wirkt sich das negativ auf die Performance und auf die Installationsgröße aus. Andererseits können wir längst nicht alle Kombinationen in dieser Codebasis testen. Da die Pflege der Compilerversionen darüber hinaus auch in gewisser Weise fehleranfällig ist, steht dies in direktem Widerspruch zu unserem stetig steigenden Qualitätsanspruch. Mit anderen Worten: Wir können nicht garantieren, dass das bisherige Compilerversionskonzept in allen Fällen zuverlässig funktioniert, und wir könnten es erst recht nicht mehr, wenn wir dieses Konzept aufgrund der Modularisierung noch komplexer ausgestalten müssten. Die beiden vorhergehenden Argumente können so zusammengefasst werden: Es ist aus Anwendersicht attraktiv, für den Maintenance-Fall durch unsere Tool-Unterstützung eine sicher passende Version herstellen zu können, ohne sich überhaupt mit einer Compilerversion beschäftigen zu müssen. Laufzeitsystem-Kompatibilität Hierbei geht es um die Frage, inwieweit eine CODESYS -Installation zu einer Laufzeitsystem-Version kompatibel ist. Mit anderen Worten: Kann man sich mit einer neuen CODESYS -Installation auf eine alte Steuerung einloggen und die verfügbaren Online-Funktionen nutzen? Die damit verbundenen Mechanismen haben wir nicht geändert. Grundsätzlich sind Programmiersystem- und Laufzeitsystemversionen beliebig kombinierbar, mit folgenden Einschränkungen: Eine neue Programmiersystemversion bietet möglicherweise Funktionen an, die eine ältere Laufzeitsystemversion noch nicht unterstützt. In diesem Fall steht die Funktion nicht zur Verfügung. Eine ältere Programmiersystemversion kann möglicherweise nicht mit einer neueren Laufzeitsystemversion arbeiten, wenn Security-Erweiterungen dies verbieten (beispielsweise eine erzwungene Benutzerverwaltung oder ein neuartiger Verschlüsselungsalgorithmus). " }, 
{ "title" : "Empfehlungen für Anwender ", 
"url" : "_cds_codesys_modularization.html#UUID-5c384bff-d9da-6867-04ee-1ecd44a1c396_id_f94aeb495b85ce36c0a86463409947a4_id_6e10313e5bec06a3c0a86463310bf8d6", 
"breadcrumbs" : "CODESYS Essentials \/ Whitepaper: Modularisierung aus Sicht des Anwenders \/ Empfehlungen für Anwender ", 
"snippet" : "Die in diesem Abschnitt beschriebenen Szenarien können selbstverständlich auch in Kombination zur Anwendung kommen. Wir glauben, dass hiermit die allermeisten praxisrelevanten Fälle abgedeckt sind und möchten diese bestmöglich durch unsere Tools unterstützen. Auch in Zukunft wollen wir unsere Softwa...", 
"body" : "Die in diesem Abschnitt beschriebenen Szenarien können selbstverständlich auch in Kombination zur Anwendung kommen. Wir glauben, dass hiermit die allermeisten praxisrelevanten Fälle abgedeckt sind und möchten diese bestmöglich durch unsere Tools unterstützen. Auch in Zukunft wollen wir unsere Software entlang dieser Anwendungsfälle weiter optimieren. Szenario Empfehlung Tool-Unterstützung Alltägliche Entwicklung an einem laufenden Projekt Die CODESYS -Version sowie die dazugehörigen Add-ons sollen stets up-to-date gehalten werden. Wir arbeiten stetig an großen und kleinen Verbesserungen, Fehlerbehebungen und Security-Updates, so dass die neueste Version immer die beste Version aller Zeiten ist. Es gibt kaum Gründe, an alten Versionen festzuhalten. Der CODESYS Installer zeigt alle zu einer Installation gehörigen verfügbaren Updates an. Diese Updates können mit wenigen Mausklicks heruntergeladen und installiert werden. Darüber hinaus werden über das Notification Center, das in CODESYS als andockbares Fenster integriert ist, ebenfalls verfügbare Updates (genau passend zur aktuell ausgeführten Installation) angezeigt. Von hier kann direkt in den CODESYS Installer gesprungen werden, so dass dieser nicht ständig aktiv sein muss. Alle von uns bereitgestellten Setups und Add-ons sind signiert, daher ist das Herunterladen über das Internet sicher. Wir haben den PackageManager um entsprechende (teilweise interaktive) Prüfmethoden erweitert. Alltägliche Entwicklung an einem laufenden Projekt unter der Randbedingung, dass mehrere Personen in einem Team eine einheitliche Installation einsetzen müssen Wie oben. Eine Person im Team installiert verfügbare Updates bei sich und testet aus. Bei erfolgreicher Freigabe wird die neue Referenzinstallation im Team verteilt. Im CODESYS Installer können bestehende Installationen als Beschreibungsdatei exportiert werden. Mit Hilfe dieser Datei kann an auf einer anderen Maschine eine identische Installation hergestellt werden. Dieser Mechanismus steht auch über Kommandozeile zur Verfügung, eignet sich also insbesondere auch für automatisierte Umgebungen. Ausprobieren neuester Add-on-Features in einer geschützten Umgebung Eine bestehende produktiv eingesetzte CODESYS -Installation wird dupliziert. In dieser werden beliebige Beta-Versionen von AddOns installiert und bedarfsweise upgedatet. Die produktiv eingesetzten CODESYS -Installationen bleiben davon vollkommen unberührt. Die normale Arbeit an Projekten wird nicht beeinträchtigt. Der CODESYS Installer erlaubt es, auf einfache Weise eine Kopie einer Bestandsinstallation anzulegen. Pro Installation kann gewählt werden, ob nur freigegebene Updates oder auch experimentelle Beta-Updates angeboten und installiert werden sollen. Bisher konnte ein bestimmtes Service Pack oder Patch immer nur einmal pro Maschine installiert werden. Seit Einführung des Installers ist diese Einschränkung aufgehoben. Wartung an einer bestehenden Steuerung, ohne das dazugehörige Bestandsprojekt zu ändern. Es muss gewährleistet sein, sich ohne Online-Change oder Download auf die Steuerung einloggen zu können, Es wird eine genau zum Projekt passende CODESYS -Installation erstellt. Ohne sich mit Compilerversionen beschäftigen zu müssen, ist die Generierung eines binärgleichen Steuerungscodes garantiert. Werden beim Laden eines Projekts Unterschiede zwischen der aktuellen CODESYS -Installation und der Erstellungsversion festgestellt, bekommt man die Möglichkeit, sich eine genau zum Projekt passende Installation herunterladen und installieren zu können. Das Projekt wird dann automatisch in dieser neu angelegten Version geöffnet. Darüber hinaus können beim Laden natürlich auch passende Installationen ausgewählt werden, die bereits auf der Maschine existieren. Installationen bekommen im CODESYS Installer einen benutzerdefinierten Namen. Damit verliert man auch nicht die Übersicht, falls man eine größere Anzahl an Installationen verwalten muss. Um nicht laufend Update-Vorschläge für eine solche spezielle Kompatibilitätsinstallation zu bekommen, werden diese per Default vom Update-Kanal getrennt. Weiterentwicklung an einem älteren Bestandsprojekt Das Projekt wird in einer aktuellen CODESYS -Installation weiterentwickelt. Da ohnehin Änderungen am Code gemacht werden, spielt der fällige Online-Change oder Download keine Rolle. CODESYS kann nach wie vor ältere Projekte verlustfrei laden. Sollte ein notwendiges Add-on fehlen, besteht die Möglichkeit, dieses direkt aus dem Projektladevorgang heraus herunterladen und installieren zu können. Ansonsten ist durch Schreib- und Downloadschutz sowohl das Projekt selbst als auch die Steuerung geschützt. " }, 
{ "title" : "Kompatibilität ", 
"url" : "_rtsl_compatibility.html", 
"breadcrumbs" : "CODESYS Essentials \/ Kompatibilität ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Kompatibilität von CODESYS -Projekten ", 
"url" : "_rtsl_compatibility.html#UUID-cc9ab11e-6c8d-25ef-88ec-9f65124bdb95_section-idm43404583559002", 
"breadcrumbs" : "CODESYS Essentials \/ Kompatibilität \/ Kompatibilität von CODESYS -Projekten ", 
"snippet" : "Speicherformat Anwendungsfall Unterstützung Laden von Projekten in neuer CODESYS -Version ohne Datenverlust ✓ Speichern von Projekten für ältere CODESYS -Versionen ✓ Öffnen neuer Projekte in alten CODESYS -Versionen -- Bestehende Projekte, die mit einer neueren CODESYS -Version geöffnet werden, werd...", 
"body" : "Speicherformat Anwendungsfall Unterstützung Laden von Projekten in neuer CODESYS -Version ohne Datenverlust ✓ Speichern von Projekten für ältere CODESYS -Versionen ✓ Öffnen neuer Projekte in alten CODESYS -Versionen -- Bestehende Projekte, die mit einer neueren CODESYS -Version geöffnet werden, werden so lange wie möglich in einem \"Kompatibilitätsmodus\" gehalten. Solange Sie nur Änderungen am Projekt vornehmen, die keine neue Funktionalität erfordern, bleibt das Speicherformat auf demselben Stand. Deshalb kann die ursprüngliche CODESYS -Version das Projekt weiterhin ohne Datenverlust öffnen und bearbeiten. Wenn Sie Änderungen vornehmen, die die Speicherung neuer Daten im Projekt erfordern, werden Sie interaktiv über diese Situation informiert. Dabei haben Sie die Möglichkeit, die letzten Änderungen rückgängig zu machen, wenn ein Kompatibilitätsbruch nicht akzeptabel wäre. Sie können Projekte mit neueren Speicherversionen oftmals in älteren CODESYS -Versionen öffnen, es wird jedoch dringend davon abgeraten. Ob Sie Projekte öffnen können, hängt von der Verfügbarkeit von Plug-in-Typen in der alten Version ab. Eine entsprechende Meldung wird beim Laden eines solchen Projekts angezeigt. Sie haben auch die Möglichkeit, ein Projekt für eine ältere Version von CODESYS zu speichern, indem Sie den Befehl Datei → Speichern unter... ausführen. In diesem Fall werden in der Ansicht Meldungen Informationen darüber ausgegeben, welche Objekte vom Datenverlust betroffen sind. Das Speichern von Projekten für eine alte Version betrifft allerdings explizit nur das Speicherformat. Es findet keine vollständige Konvertierung des Projekts statt, bei der die Compilerversion oder ähnliche Einstellungen angepasst werden, damit sie zur alten Version passen. Online-Verhalten Anwendungsfall Unterstützung Übersetzen eines Projekts, das mit einer alten CODESYS -Version erzeugt wurde, in einer neuen CODESYS -Version. ✓ Einloggen ohne Online-Change in einer neuen Version. -- Neue CODESYS -Versionen können für bestehende Projekte nicht den gleichen Code erzeugen wie die ältere Version, mit der das Projekt erstellt wurde. Wenn Sie sich an einer laufenden Anwendung ohne Online-Change oder Download einloggen müssen, ist es erforderlich, dass Sie das Projekt mit der Version öffnen, mit der es zuletzt auf die Steuerung geladen wurde. Der CODESYS Installer und die Projektanalyse helfen Ihnen, die ursprüngliche Version wiederherzustellen, sofern diese nicht bereits vorhanden ist. Dies bedeutet folglich, dass das Öffnen des Projekts mit einer neueren oder unterschiedlichen Version eine Aktualisierung des Projekts erfordert. Dabei ist höchstwahrscheinlich ein neuer Download der Laufzeitumgebung notwendig. Außerdem müssen Sie die Anwendung auf mögliche Verhaltensänderungen testen, die sich aus neuen Funktionen oder Fehlerbehebungen im Compiler oder den grafischen Editoren ergeben. Im Allgemeinen wird versucht, neue Compilerfehler oder Verhaltensänderungen für bestehende Projekte zu minimieren, um den Aufwand für die Aktualisierung auf neue Versionen so gering wie möglich zu halten. Für die Kompatibilität zu bestehenden Laufzeiten sind die folgende Punkte zu beachten: Neue Funktionen in CODESYS werden typischerweise in der Gerätebeschreibung aktiviert. Sie sind also für ältere Laufzeitsysteme oder ältere Gerätebeschreibungen deaktiviert. Die Versionen aller externen Bibliotheken werden über die Gerätebeschreibung aufgelöst. Sie sind also auf das entsprechende Laufzeitsystem abgestimmt. Interne Bibliotheken werden durch die CODESYS -Version aufgelöst, unabhängig von der Version des Laufzeitsystems. Die Kommunikationsdienste werden nach einem gemeinsamen Format mit Tags aufgebaut. Unbekannte Tags werden vom Laufzeitsystem ignoriert. Eine Änderung des Kommunikationsdienstes ist daher möglich, aber das Programmiersystem wird nicht erwarten, dass das Laufzeitsystem die neuen Informationen interpretiert. " }, 
{ "title" : "Kompatibilität CODESYS -Bibliotheken ", 
"url" : "_rtsl_compatibility.html#UUID-cc9ab11e-6c8d-25ef-88ec-9f65124bdb95_section-idm43404583586258", 
"breadcrumbs" : "CODESYS Essentials \/ Kompatibilität \/ Kompatibilität CODESYS -Bibliotheken ", 
"snippet" : "Anwendungsfall Unterstützung Verwenden einer übersetzten Bibliothek, die in einer älteren CODESYS -Version erzeugt wurde, in einer neuen CODESYS -Version. ✓ Verwenden einer übersetzten Bibliothek, die in einer neuen CODESYS -Version erzeugt wurde, in einer älteren CODESYS -Version. -- Kompilierte Bi...", 
"body" : "Anwendungsfall Unterstützung Verwenden einer übersetzten Bibliothek, die in einer älteren CODESYS -Version erzeugt wurde, in einer neuen CODESYS -Version. ✓ Verwenden einer übersetzten Bibliothek, die in einer neuen CODESYS -Version erzeugt wurde, in einer älteren CODESYS -Version. -- Kompilierte Bibliotheken sollten immer mit der niedrigsten CODESYS -Version erstellt werden, mit der sie kompatibel sein sollen. Alte CODESYS -Versionen erkennen Bibliotheken, die mit neueren Versionen erstellt wurden, und lehnen deren Verwendung in einem Projekt ab. Die Prüfung basiert auf der in der Bibliothek eingestellten Compilerversion. Je nach Inhalt der Bibliothek kann auch das Speicherformat eine Rolle spielen. Für Quellbibliotheken gelten die gleichen Regeln wie für CODESYS -Projekte. " }, 
{ "title" : "Kompatibilität CODESYS -Laufzeitsystem ", 
"url" : "_rtsl_compatibility.html#UUID-cc9ab11e-6c8d-25ef-88ec-9f65124bdb95_section-idm4591711893675234040560644037", 
"breadcrumbs" : "CODESYS Essentials \/ Kompatibilität \/ Kompatibilität CODESYS -Laufzeitsystem ", 
"snippet" : "Es wird jedoch davon abgeraten, eine ältere Version von CODESYS und eine neuere Version des Laufzeitsystems zu verwenden. Diese Kompatibilität nicht explizit getestet. Aufgrund von Sicherheitskorrekturen in neueren Laufzeitsystemen kann es zu Inkompatibilitäten mit älteren CODESYS -Versionen kommen....", 
"body" : "Es wird jedoch davon abgeraten, eine ältere Version von CODESYS und eine neuere Version des Laufzeitsystems zu verwenden. Diese Kompatibilität nicht explizit getestet. Aufgrund von Sicherheitskorrekturen in neueren Laufzeitsystemen kann es zu Inkompatibilitäten mit älteren CODESYS -Versionen kommen. Für die Kompatibilität mit bestehenden Laufzeit-Versionen sind folgende Punkte zu beachten: Neue Funktionen in CODESYS werden typischerweise in der Gerätebeschreibung aktiviert. Somit sind diese Versionen für ältere Laufzeitsysteme oder ältere Gerätebeschreibungen deaktiviert. Die Versionen aller externen Bibliotheken werden über die Gerätebeschreibung aufgelöst. Sie sind also auf das entsprechende Laufzeitsystem abgestimmt. Interne Bibliotheken werden durch die CODESYS -Version aufgelöst, unabhängig von der Version des Laufzeitsystems. Die Kommunikationsdienste werden nach einem gemeinsamen Format mit Tags aufgebaut. Unbekannte Tags werden vom Laufzeitsystem ignoriert. Eine Änderung des Kommunikationsdienstes ist daher möglich, aber das Programmiersystem wird nicht erwarten, dass das Laufzeitsystem die neuen Informationen interpretiert. " }, 
{ "title" : "Kompatibilität Gerätebeschreibungen - Laufzeitsystem ", 
"url" : "_rtsl_compatibility.html#UUID-cc9ab11e-6c8d-25ef-88ec-9f65124bdb95_section-idm4622937043899234045846685577", 
"breadcrumbs" : "CODESYS Essentials \/ Kompatibilität \/ Kompatibilität Gerätebeschreibungen - Laufzeitsystem ", 
"snippet" : "Anwendungsfall Unterstützung Eine ältere Version der Gerätebeschreibung und ein neueres Laufzeitsystem werden bei der Anmeldung akzeptiert. ✓ Eine neuere Version der Gerätebeschreibung und ein älteres Laufzeitsystem werden nicht akzeptiert, so dass die Anmeldung verweigert wird. -- Bestehende Projek...", 
"body" : "Anwendungsfall Unterstützung Eine ältere Version der Gerätebeschreibung und ein neueres Laufzeitsystem werden bei der Anmeldung akzeptiert. ✓ Eine neuere Version der Gerätebeschreibung und ein älteres Laufzeitsystem werden nicht akzeptiert, so dass die Anmeldung verweigert wird. -- Bestehende Projekte müssen auf bestehenden Laufzeitsystemen laufen, auch mit neueren CODESYS -Versionen. Dies kann dadurch erfüllt werden, indem die Gerätebeschreibung im Projekt nicht verändert wird und die bestehende Version hat, die mit der Version des Laufzeitsystems übereinstimmt. Zusätzlich ist eine Anmeldung am Laufzeitsystem möglich, wenn die Version der Gerätebeschreibung und des Laufzeitsystems nicht zu unterschiedlich oder inkompatibel sind: Die Gerätebeschreibung enthält eine Liste von externen Bibliotheken, deren externe Funktionen im Laufzeitsystem implementiert sind. Die entsprechende Version der Bibliothek wird in der so genannten Bibliotheksplatzhalterliste angegeben. Diese Liste wird vom Gerätehersteller definiert. Die Platzhalterliste sollte nur die Bibliotheken enthalten, deren entsprechende Laufzeitkomponenten im Laufzeitsystem verfügbar sind. Es besteht die Möglichkeit, den Kompatibilitätsbereich zwischen der Gerätebeschreibung und dem Laufzeitsystem zu konfigurieren. Das bedeutet, dass Sie sich nicht auf die Steuerung einloggen können, wenn die Versionen nicht übereinstimmen. Dieser Bereich kann vom Gerätehersteller mit den folgenden Einstellungen im Laufzeitsystem ausgewählt werden (siehe SysTargetItf.h des Laufzeitsystems): SYSTARGETKEY_INT_TARGET_VERSION_MASK \"TargetVersionMask\": Einstellung zur Angabe einer Maske zur Überprüfung der Zielversion auf Kompatibilität mit der Gerätebeschreibung. In der Maske werden nur die signifikanten Ziffern geprüft. SYSTARGETKEY_INT_TARGET_VERSION_COMPATIBILITY_MASK \"TargetVersionCompatibilityMask\": Einstellung zur Angabe einer Kompatibilitätsmaske zur Überprüfung der Zielversion auf Kompatibilität mit der Gerätebeschreibung. Eine Gerätebeschreibung, die niedriger oder gleich der Zielversion ist, wird akzeptiert. Eine höhere Version der Gerätebeschreibung wird abgelehnt. Beispiel aktuelles CODESYS Version CODESYS Version CODESYS -Control Version Gerätebeschreibung Empfohlen Einschränkungen Kommentar 3.5.19.0 3.5.19.0 3.5.19.0 ja, optimal -- Dies ist die optimale Kombination 3.5.19.0 3.5.12.0 3.5.12.0 ja -- Dies ist ein typischer Kompatibilitätsfall 3.5.19.0 3.5.12.0 3.5.10.0 nein, aber möglich Warnung beim Login in die Steuerung, dass die DevDesc nicht übereinstimmt Dies ist möglich, weil die DevDesc älter ist als die Version der Steuerung 3.5.19.0 3.5.12.0 3.5.19.0 nein Kein Zugriff auf die Steuerung Dies wird standardmäßig verweigert, da DevDesc und das Laufzeitsystem nicht miteinander kompatibel sind 3.5.19.0 3.5.10.0 3.5.10.30 nein Kein Zugriff auf die Steuerung Dies ist möglich, weil die DevDesc im kompatiblen Bereich von 3.5.10.x liegt. Beispiel älteres  CODESYS Version CODESYS Version CODESYS -Control Version Gerätebeschreibung Empfohlen Einschränkungen Kommentar 3.5.17.0 3.5.19.0 3.5.19.0 nein Inkompatibilitäten aufgrund von Sicherheitskorrekturen im Laufzeitsystem möglich In CODESYS muss der Satz aller externen Bibliotheken vorhanden sein. Möglicherweise werden in den externen Bibliotheken neuere IEC-Sprachressourcen verwendet, die zu Kompilierfehlern führen. 3.5.17.0 3.5.19.0 3.5.17.0 nein, aber möglich Inkompatibilitäten aufgrund von Sicherheitskorrekturen im Laufzeitsystem möglich " }, 
{ "title" : "Kompatibilität Bootprojekt + Retains - Laufzeitsystem ", 
"url" : "_rtsl_compatibility.html#UUID-cc9ab11e-6c8d-25ef-88ec-9f65124bdb95_section-idm4482671035296034045851594374", 
"breadcrumbs" : "CODESYS Essentials \/ Kompatibilität \/ Kompatibilität Bootprojekt + Retains - Laufzeitsystem ", 
"snippet" : "Anwendungsfall Unterstützung Neueres Laufzeitsystem lädt ältere Bootprojekte ✓ Älteres Laufzeitsystem lädt neuere Bootprojekte -- Vorhandene Bootprojekte müssen innerhalb einer Hauptversion vom Laufzeitsystem geladen werden können. Ein vorhandenes Bootprojekt wird vor dem Laden gegen die Typbezeichn...", 
"body" : "Anwendungsfall Unterstützung Neueres Laufzeitsystem lädt ältere Bootprojekte ✓ Älteres Laufzeitsystem lädt neuere Bootprojekte -- Vorhandene Bootprojekte müssen innerhalb einer Hauptversion vom Laufzeitsystem geladen werden können. Ein vorhandenes Bootprojekt wird vor dem Laden gegen die Typbezeichnung eines Targets ( VendorID , DeviceID und seit V3.5.8.0 die DeviceVersion ) geprüft. Retain-Variablen aus einer gespeicherten Retain-Datei ( <Application>.ret ) oder aus dem SRAM müssen immer kompatibel sein. Pro Retain-Bereich wird eine Prüfsumme in einer separaten Datei gespeichert, die gleiche Prüfsumme wird im Bootprojekt gespeichert. Diese Prüfsumme wird vom Compiler aus den Retain-Daten generiert und ist eine Identifikation aller Variablen im Retain-Bereich mit ihren jeweiligen Typen. Wenn die Prüfsumme der Retain-Daten und die Prüfsumme im Bootprojekt nicht übereinstimmen, haben Sie im Laufzeitsystem mehrere Optionen, um das Verhalten auszuwählen. Diese Optionen können Sie in der cfg -Datei im Abschnitt [CmpApp] angegeben: Bootproject.RetainMismatch.Init = 1 : Das Bootprojekt wird geladen und Retains werden initialisiert. Bootproject.RetainMismatch.Exception = 1 : Das Bootprojekt wird geladen, aber die Anwendung bleibt im Stoppzustand und wird in einen Ausnahmezustand versetzt. Durch einen manuellen Reset kann dieser Zustand behoben werden. Keine Einstellung [DEFAULT] : Das Bootprojekt wird nicht geladen und eine Fehlermeldung wird dem Logger hinzugefügt. Vor Laufzeitsystem Version 3.5.7.0 wurde die Prüfsumme aus den gesamten Daten der Anwendung berechnet, bei neueren Versionen wird die Prüfsumme nur aus den Daten im Retain-Bereich berechnet. Somit können mit neueren Versionen die Retain-Daten in ein Bootprojekt geladen werden, auch wenn sich das Projekt geändert hat, solange diese Änderungen keine Änderungen in den Retain-Daten beinhalten. " }, 
{ "title" : "CODESYS konfigurieren ", 
"url" : "_cds_struct_configuring_development_system.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren ", 
"snippet" : "Sie können das Verhalten, das Aussehen, die Menüzusammensetzung und die Fensteranordnung von CODESYS Development System individuell konfigurieren. Im Menü Tools finden Sie Dialoge zum Anpassen der Oberfläche und für das Einstellen der CODESYS -Optionen. Für weitere Informationen siehe: Anpassen und ...", 
"body" : "Sie können das Verhalten, das Aussehen, die Menüzusammensetzung und die Fensteranordnung von CODESYS Development System individuell konfigurieren. Im Menü Tools finden Sie Dialoge zum Anpassen der Oberfläche und für das Einstellen der CODESYS -Optionen. Für weitere Informationen siehe: Anpassen und Optionen" }, 
{ "title" : "CODESYS -Optionen einstellen ", 
"url" : "_cds_configuring_dev_sys_options.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ CODESYS -Optionen einstellen ", 
"snippet" : "Sie können das Verhalten und Aussehen des CODESYS Development System in den verschiedenen Registerkarten des Dialogs Optionen konfigurieren. Der Dialog öffnet nach Auswahl des Befehls Tools → Optionen . Sie können hier Standardeinstellungen für verschiedene Editoren und Funktionalitäten vornehmen. D...", 
"body" : "Sie können das Verhalten und Aussehen des CODESYS Development System in den verschiedenen Registerkarten des Dialogs Optionen konfigurieren. Der Dialog öffnet nach Auswahl des Befehls Tools → Optionen . Sie können hier Standardeinstellungen für verschiedene Editoren und Funktionalitäten vornehmen. Diese Einstellungen sind CODESYS -weit gültig. Die Einstellungen werden in Ihrem aktuellen Benutzerprofil auf Ihrem lokalen System gespeichert. Für eine Weitergabe auf andere Systeme können benutzer- oder maschinen(Computer)-bezogene Optionseinstellungen in eine xml-Datei exportiert werden. Ab V3.5 SP13 prüft CODESYS beim ersten Start des Entwicklungssystems, ob bereits eine ältere Version installiert ist. Wenn dies der Fall ist, erhalten Sie den Dialog Importassistent zum Übernehmen der mit der älteren Version gesetzten CODESYS -Optionen. " }, 
{ "title" : "Oberfläche anpassen ", 
"url" : "_cds_struct_userinterface_usage.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ Oberfläche anpassen ", 
"snippet" : "CODESYS bietet Ihnen die Möglichkeit, die Benutzeroberfläche individuell an Ihre Bedürfnisse anzupassen. Dabei können Sie die Anordnung der Fenster sowie die Sichtbarkeit von Menüs und Befehlen frei gestalten....", 
"body" : "CODESYS bietet Ihnen die Möglichkeit, die Benutzeroberfläche individuell an Ihre Bedürfnisse anzupassen. Dabei können Sie die Anordnung der Fenster sowie die Sichtbarkeit von Menüs und Befehlen frei gestalten. " }, 
{ "title" : "Menüs anpassen ", 
"url" : "_cds_customizing_menu.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ Oberfläche anpassen \/ Menüs anpassen ", 
"snippet" : "Sie können die Menübefehle in der CODESYS Benutzeroberfläche an Ihre Bedürfnisse anpassen. Über einen Konfigurationsdialog können Sie Menüs ausblenden oder hinzufügen. Hinzufügen eines Befehls Wählen Sie den Befehl Tools → Anpassen . Es öffnet sich der Dialog Anpassen . Die Registerkarte Menü ist si...", 
"body" : "Sie können die Menübefehle in der CODESYS Benutzeroberfläche an Ihre Bedürfnisse anpassen. Über einen Konfigurationsdialog können Sie Menüs ausblenden oder hinzufügen. Hinzufügen eines Befehls Wählen Sie den Befehl Tools → Anpassen . Es öffnet sich der Dialog Anpassen . Die Registerkarte Menü ist sichtbar. Öffnen Sie den Menübaum des Menüs, zu dem der neue Befehl hinzugefügt werden soll. Selektieren Sie das leere Icon . Klicken Sie auf die Schaltfläche Befehl hinzufügen . Der Dialog Befehl hinzufügen öffnet. In dem Dialog sind alle Befehle in Kategorien gruppiert aufgelistet. Selektieren Sie den Befehl, den Sie hinzufügen wollen. Klicken Sie auf OK . Der neue Befehl wird zum Menübaum hinzugefügt. Verändern Sie die Position in der Reihenfolge der Menüs mit den Schaltflächen Nach oben und Nach unten . Klicken Sie auf Trennstrich hinzufügen , wenn Sie einzelne Befehle mit einem Trennstrich abgrenzen wollen. Klicken Sie auf OK um den Dialog Anpassen zu schließen. Der neue Befehl ist nun im Menü verfügbar. " }, 
{ "title" : "Entfernen eines Menüs\/Befehls ", 
"url" : "_cds_customizing_menu.html#UUID-656ba63d-6853-57f4-0629-dca5d51e2842_id_a7314d76c3527bdc0a8640e005fa62d_id_0da504cb13c911e4a98d91f1d473d70d", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ Oberfläche anpassen \/ Menüs anpassen \/ Entfernen eines Menüs\/Befehls ", 
"snippet" : "Wählen Sie den Befehl Tools → Anpassen . Es öffnet sich der Dialog Anpassen . Die Registerkarte Menü ist sichtbar. Selektieren Sie ein Menü im Menübaum oder einen Befehl unterhalb eines Menüs. Klicken Sie auf Entfernen . Das Menü bzw. der Befehl ist aus dem Menübaum gelöscht. Klicken Sie auf die Sch...", 
"body" : "Wählen Sie den Befehl Tools → Anpassen . Es öffnet sich der Dialog Anpassen . Die Registerkarte Menü ist sichtbar. Selektieren Sie ein Menü im Menübaum oder einen Befehl unterhalb eines Menüs. Klicken Sie auf Entfernen . Das Menü bzw. der Befehl ist aus dem Menübaum gelöscht. Klicken Sie auf die Schaltfläche OK . Der Dialog schließt und das Menü ist angepasst. " }, 
{ "title" : "Hinzufügen eines Menüs ", 
"url" : "_cds_customizing_menu.html#UUID-656ba63d-6853-57f4-0629-dca5d51e2842_id_a7314d76c3527bdc0a8640e005fa62d_id_4406632d13cd11e4a98d91f1d473d70d", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ Oberfläche anpassen \/ Menüs anpassen \/ Hinzufügen eines Menüs ", 
"snippet" : "Wählen Sie den Befehl Tools → Anpassen . Es öffnet sich der Dialog Anpassen . Die Registerkarte Menü ist sichtbar. Scrollen Sie an das Ende des Menübaums. Selektieren Sie das leere Icon . Klicken Sie auf Popup-Menü hinzufügen . Der Dialog Popup-Menü hinzufügen öffnet sich. Geben Sie im Feld Standard...", 
"body" : "Wählen Sie den Befehl Tools → Anpassen . Es öffnet sich der Dialog Anpassen . Die Registerkarte Menü ist sichtbar. Scrollen Sie an das Ende des Menübaums. Selektieren Sie das leere Icon . Klicken Sie auf Popup-Menü hinzufügen . Der Dialog Popup-Menü hinzufügen öffnet sich. Geben Sie im Feld Standardtext einen Namen für das neue Menü ein. Falls Sie keine Lokalisierung benötigen, machen Sie mit Schritt 9 weiter. Klicken Sie auf Sprache hinzufügen . Es öffnet sich eine Auswahl aller verfügbaren Sprachen. Wählen Sie die gewünschte Sprache aus. Die Sprache wird zur Liste der Sprachen hinzugefügt. Klicken Sie in das Feld Text und geben Sie dort den sprachabhängigen Text ein. Klicken Sie auf OK . Das neue Menü wird am Ende des Menübaums hinzugefügt. Verändern Sie die Position in der Reihenfolge der Menüs mit den Schaltflächen Nach oben und Nach unten . Klicken Sie auf die Schaltfläche OK um den Dialog Anpassen zu schließen. Das neue Menü wird erst angezeigt, wenn innerhalb des Menüs ein Befehl verfügbar ist. " }, 
{ "title" : "Symbolleisten anpassen ", 
"url" : "_cds_customizing_toolbar.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ Oberfläche anpassen \/ Symbolleisten anpassen ", 
"snippet" : "Sie können die Symbolleisten der CODESYS Benutzeroberfläche an Ihre Bedürfnisse anpassen. Über einen Konfigurationsdialog können Sie Symbolleisten ausblenden oder hinzufügen. Hinzufügen eines Befehls Wählen Sie den Befehl Tools → Anpassen . Es öffnet sich der Dialog Anpassen . Wählen Sie die Registe...", 
"body" : "Sie können die Symbolleisten der CODESYS Benutzeroberfläche an Ihre Bedürfnisse anpassen. Über einen Konfigurationsdialog können Sie Symbolleisten ausblenden oder hinzufügen. Hinzufügen eines Befehls Wählen Sie den Befehl Tools → Anpassen . Es öffnet sich der Dialog Anpassen . Wählen Sie die Registerkarte Symbolleisten . Öffnen Sie die Symbolleiste, zu der der neue Befehl hinzugefügt werden soll. Selektieren Sie das leere Icon . Klicken Sie auf die Schalfläche Befehl hinzufügen . Der Dialog Befehl hinzufügen öffnet sich. In dem Dialog sind alle Befehle in Kategorien gruppiert aufgelistet. Selektieren Sie den Befehl, den Sie hinzufügen wollen. Klicken Sie auf OK . Der neue Befehl wird unterhalb der Symbolleiste hinzugefügt. Verändern Sie die Position innerhalb der Symbolleiste mit den Schaltflächen Nach oben und Nach unten . Klicken Sie auf die Schaltfläche Trennstrich hinzufügen , wenn Sie einzelne Befehle mit einem Trennstrich abgrenzen wollen. Klicken Sie auf die Schaltfläche OK um den Dialog Anpassen zu schließen. Der neue Befehl ist in der Symbolleiste verfügbar. " }, 
{ "title" : "Entfernen einer Symbolleiste \/ eines Befehls ", 
"url" : "_cds_customizing_toolbar.html#UUID-91e60a2c-10a6-5255-018c-837339d7f7f0_id_e1e156c804c48c0a8640e01354a59_id_0da504cb13c911e4a98d91f1d473d70d", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ Oberfläche anpassen \/ Symbolleisten anpassen \/ Entfernen einer Symbolleiste \/ eines Befehls ", 
"snippet" : "Wählen Sie den Befehl Tools → Anpassen . Es öffnet sich der Dialog Anpassen . Wählen Sie die Registerkarte Symbolleisten . Selektieren Sie eine Symbolleiste oder einen Befehl unterhalb einer Symbolleiste. Klicken Sie auf die Schaltfläche Entfernen . Die Symbolleiste oder der Befehl ist gelöscht. Kli...", 
"body" : "Wählen Sie den Befehl Tools → Anpassen . Es öffnet sich der Dialog Anpassen . Wählen Sie die Registerkarte Symbolleisten . Selektieren Sie eine Symbolleiste oder einen Befehl unterhalb einer Symbolleiste. Klicken Sie auf die Schaltfläche Entfernen . Die Symbolleiste oder der Befehl ist gelöscht. Klicken Sie auf die Schaltfläche OK . Der Dialog schließt sich und die Symbolleiste oder der Befehl ist entfernt. " }, 
{ "title" : "Hinzufügen einer Symbolleiste ", 
"url" : "_cds_customizing_toolbar.html#UUID-91e60a2c-10a6-5255-018c-837339d7f7f0_id_e1e156c804c48c0a8640e01354a59_id_4406632d13cd11e4a98d91f1d473d70d", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ Oberfläche anpassen \/ Symbolleisten anpassen \/ Hinzufügen einer Symbolleiste ", 
"snippet" : "Wählen Sie den Befehl Tools → Anpassen . Es öffnet sich der Dialog Anpassen . Wählen Sie die Registerkarte Symbolleisten . Selektieren Sie die letzte (leere) Symbolleiste. Klicken Sie auf die Schaltfläche Symbolleiste hinzufügen . Der Cursor blinkt in der leeren Symbolleiste. Geben Sie einen Namen e...", 
"body" : "Wählen Sie den Befehl Tools → Anpassen . Es öffnet sich der Dialog Anpassen . Wählen Sie die Registerkarte Symbolleisten . Selektieren Sie die letzte (leere) Symbolleiste. Klicken Sie auf die Schaltfläche Symbolleiste hinzufügen . Der Cursor blinkt in der leeren Symbolleiste. Geben Sie einen Namen ein. Verändern Sie die Position in der Reihenfolge der Symbolleisten mit den Schaltflächen Nach oben und Nach unten . Klicken Sie auf die Schaltfläche OK um den Dialog Anpassen zu schließen. CODESYS zeigt die neue Symbolleiste erst an, wenn innerhalb der Symbolleiste ein Befehl verfügbar ist. " }, 
{ "title" : "Befehls-Icon anpassen ", 
"url" : "_cds_customizing_command_icons.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ Oberfläche anpassen \/ Befehls-Icon anpassen ", 
"snippet" : "CODESYS bietet Ihnen die Möglichkeit, den Befehlen benutzerdefinierte Icons zuzuweisen. Wählen Sie den Befehl Tools → Anpassen . Es öffnet sich der Dialog Anpassen . Wählen Sie die Registerkarte Befehl-Icons . Selektieren Sie in der linken Übersicht die Kategorie Hilfe . In der rechten Hälfte ersche...", 
"body" : "CODESYS bietet Ihnen die Möglichkeit, den Befehlen benutzerdefinierte Icons zuzuweisen. Wählen Sie den Befehl Tools → Anpassen . Es öffnet sich der Dialog Anpassen . Wählen Sie die Registerkarte Befehl-Icons . Selektieren Sie in der linken Übersicht die Kategorie Hilfe . In der rechten Hälfte erscheinen alle Befehle dieser Kategorie. Selektieren Sie den Befehl Information . Klicken Sie auf die Schaltfläche Zuweisen . Es öffnet sich ein Dialog zur Auswahl der Icon-Datei (*.ico). Wählen Sie eine Icon-Datei aus. Klicken Sie auf die Schaltfläche Öffnen . Das Icon ist dem ausgewählten Befehl zugewiesen. Klicken Sie auf OK . " }, 
{ "title" : "Tastaturkürzel anpassen ", 
"url" : "_cds_customizing_keyboard_shortcuts.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ Oberfläche anpassen \/ Tastaturkürzel anpassen ", 
"snippet" : "CODESYS bietet Ihnen die Möglichkeit, Befehle direkt über ein Tastaturkürzel aufzurufen. Sie können die vordefinierten Tastaturkürzel anpassen oder erweitern. Tastaturkürzel anpassen Wählen Sie den Befehl Tools → Anpassen . Es öffnet sich der Dialog Anpassen . Wählen Sie die Registerkarte Tastatur ....", 
"body" : "CODESYS bietet Ihnen die Möglichkeit, Befehle direkt über ein Tastaturkürzel aufzurufen. Sie können die vordefinierten Tastaturkürzel anpassen oder erweitern. Tastaturkürzel anpassen Wählen Sie den Befehl Tools → Anpassen . Es öffnet sich der Dialog Anpassen . Wählen Sie die Registerkarte Tastatur . Selektieren Sie in der linken Übersicht die Kategorie Hilfe . In der rechten Hälfte erscheinen alle Befehle dieser Kategorie. Selektieren Sie den Befehl Suchen . Klicken Sie in das Feld Taste für Tastaturkürzel drücken . Betätigen Sie Strg + Umschalt + S . CODESYS fügt die Tastenkombination in das Feld ein. Klicken Sie auf die Schaltfläche Zuweisen . Das Tastaturkürzel wird dem Befehl zugewiesen. Klicken Sie auf OK . Sie können den Befehl Suchen nun über das Tastaturkürzel Strg + Umschalt + S aufrufen. Für weitere Hilfe siehe: Tastaturkürzel, Windows™ Tastaturkürzel" }, 
{ "title" : "Fensteranordnung ändern ", 
"url" : "_cds_changing_window_layout.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ Oberfläche anpassen \/ Fensteranordnung ändern ", 
"snippet" : "Sie können die Anordnung der verschiedenen Fenster in CODESYS einfach an Ihre individuellen Bedürfnisse anpassen. Ziehen Sie das Fenster an der Titelleiste oder an der Registerkarte. Pfeilsymbole werden eingeblendet, die die möglichen Positionen kennzeichnen. Beispiel: Ziehen Sie das Fenster mit der...", 
"body" : "Sie können die Anordnung der verschiedenen Fenster in CODESYS einfach an Ihre individuellen Bedürfnisse anpassen. Ziehen Sie das Fenster an der Titelleiste oder an der Registerkarte. Pfeilsymbole werden eingeblendet, die die möglichen Positionen kennzeichnen. Beispiel: Ziehen Sie das Fenster mit der Maus auf eines der Pfeilsymbole. Die Zielposition wird als blauschattierter Bereich angezeigt. Lassen Sie die linke Maustaste los. Das Fenster wird im gewählten Zielbereich eingefügt. Sie können das Fenster auch außerhalb der CODESYS -Programmieroberfläche platzieren. Für weitere Informationen siehe: Fenstergröße ändern" }, 
{ "title" : "Fenstergröße ändern ", 
"url" : "_cds_changing_window_size.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ Oberfläche anpassen \/ Fenstergröße ändern ", 
"snippet" : "Bewegen Sie die Maus über die Trennlinie zwischen zwei Fenstern oder Ansichten. Der Cursor wird zu einem zweiendigen Pfeil. Ziehen Sie die Trennlinie mit der Maus in die gewünschte Position. Sie können losgelöste Fenster durch Verschieben der Rahmenlinien in der Größe verändern. Für weitere Informat...", 
"body" : "Bewegen Sie die Maus über die Trennlinie zwischen zwei Fenstern oder Ansichten. Der Cursor wird zu einem zweiendigen Pfeil. Ziehen Sie die Trennlinie mit der Maus in die gewünschte Position. Sie können losgelöste Fenster durch Verschieben der Rahmenlinien in der Größe verändern. Für weitere Informationen siehe: Fensteranordnung ändern" }, 
{ "title" : "Fenster aus- \/einblenden ", 
"url" : "_cds_autohiding_windows.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ Oberfläche anpassen \/ Fenster aus- \/einblenden ", 
"snippet" : "Einblenden von Fenstern Klicken Sie auf den Reiter des ausgeblendeten Fensters. Deaktivieren Sie die Option Fenster → Ausblenden . Oder klicken Sie dazu auf die Schaltfläche in der oberen rechten Ecke der Ansicht. Das Fenster wird dauerhaft eingeblendet....", 
"body" : "Einblenden von Fenstern Klicken Sie auf den Reiter des ausgeblendeten Fensters. Deaktivieren Sie die Option Fenster → Ausblenden . Oder klicken Sie dazu auf die Schaltfläche in der oberen rechten Ecke der Ansicht. Das Fenster wird dauerhaft eingeblendet. " }, 
{ "title" : "Ausblenden von Fenstern ", 
"url" : "_cds_autohiding_windows.html#UUID-71d9107d-d831-5182-3e56-78ee9398c5e6_id_c1fb11d67be31b3fc0a8640e016f13ae_id_1657629d7c432017c0a8640e00b2156d", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ Oberfläche anpassen \/ Fenster aus- \/einblenden \/ Ausblenden von Fenstern ", 
"snippet" : "Wenn Sie ein Fenster ausblenden, ist dieses nur noch als ein Reiter im Rahmen der Benutzeroberfläche vertreten. Wenn Sie die Maus über diesen Reiter bewegen, wird das Fenster automatisch eingeblendet. Klicken Sie in das Fenster, das Sie ausblenden wollen. Aktivieren Sie die Option Fenster → Ausblend...", 
"body" : "Wenn Sie ein Fenster ausblenden, ist dieses nur noch als ein Reiter im Rahmen der Benutzeroberfläche vertreten. Wenn Sie die Maus über diesen Reiter bewegen, wird das Fenster automatisch eingeblendet. Klicken Sie in das Fenster, das Sie ausblenden wollen. Aktivieren Sie die Option Fenster → Ausblenden . Oder klicken Sie dazu auf die Schaltfläche in der oberen rechten Ecke der Ansicht. Das Fenster wird ausgeblendet und nur durch einen kleinen Reiter sichtbar, am seitlichen Rand des Hauptfensters dargestellt. Bewegen Sie den Mauszeiger über den Reiter. Das Fenster wird eingeblendet solange der Mauszeiger über dem Reiter bleibt. " }, 
{ "title" : "Zwischen Fenstern umschalten ", 
"url" : "_cds_switching_windows.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ Oberfläche anpassen \/ Zwischen Fenstern umschalten ", 
"snippet" : "Sie können direkt zwischen den gerade geöffneten Ansichten und Editorfenstern wechseln. Drücken Sie gleichzeitig die Tasten Strg und Tab . Halten Sie die Strg -Taste gedrückt. Es öffnet sich eine Übersicht aller aktiven Ansichten und Editoren. Halten Sie die Strg -Taste gedrückt während Sie mit den ...", 
"body" : "Sie können direkt zwischen den gerade geöffneten Ansichten und Editorfenstern wechseln. Drücken Sie gleichzeitig die Tasten Strg und Tab . Halten Sie die Strg -Taste gedrückt. Es öffnet sich eine Übersicht aller aktiven Ansichten und Editoren. Halten Sie die Strg -Taste gedrückt während Sie mit den Pfeiltasten das Fenster auswählen. Lassen Sie die Strg -Taste los. Die gewählte Ansicht oder der gewählte Editor wird aktiv geschaltet. " }, 
{ "title" : "CODESYS-Offlinehilfe installieren ", 
"url" : "_cds_installing_offlinehelp.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ CODESYS-Offlinehilfe installieren ", 
"snippet" : "Die CODESYS Development System -Onlinehilfe kann als Offlinehilfe installiert werden. Die Offlinehilfe umfasst alle Hilfeinhalte der Onlinehilfe mit Ausnahme folgender Publikationen: Alle Bibliotheksdokumentationen Diese können offline im Bibliotheksverwalter gelesen werden LibDevSummary CODESYS Dev...", 
"body" : "Die CODESYS Development System -Onlinehilfe kann als Offlinehilfe installiert werden. Die Offlinehilfe umfasst alle Hilfeinhalte der Onlinehilfe mit Ausnahme folgender Publikationen: Alle Bibliotheksdokumentationen Diese können offline im Bibliotheksverwalter gelesen werden LibDevSummary CODESYS Development System Scripting API Sie können die Offlinehilfe über die Startseite des Hilfeportals oder direkt über den CODESYS Installer installieren. Sie aktivieren die Offlinehilfe über die Option Offlinehilfe anstelle von Onlinehilfe verwenden im Menü Tools → Optionen → Hilfe . Für weitere Informationen siehe CODESYS-Offlinehilfe mit eigenen Inhalten erweitern. " }, 
{ "title" : "CODESYS-Offlinehilfe mit eigenen Inhalten erweitern ", 
"url" : "_cds_extending_offlinehelp.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ CODESYS-Offlinehilfe installieren \/ CODESYS-Offlinehilfe mit eigenen Inhalten erweitern ", 
"snippet" : "Das CODESYS Development System bietet die Möglichkeit, die Offlinehilfe mit eigenen Hilfeseiten zu erweitern. Die neuen Hilfeseiten können in einer beliebigen Struktur und an einer beliebigen Stelle im Inhaltsverzeichnis hinzugefügt werden. Es ist weiterhin möglich, das gesamte Inhaltsverzeichnis au...", 
"body" : "Das CODESYS Development System bietet die Möglichkeit, die Offlinehilfe mit eigenen Hilfeseiten zu erweitern. Die neuen Hilfeseiten können in einer beliebigen Struktur und an einer beliebigen Stelle im Inhaltsverzeichnis hinzugefügt werden. Es ist weiterhin möglich, das gesamte Inhaltsverzeichnis auf den hinzugefügten Hilfeseiten anzuzeigen. Eine Sprachumschaltung sowie eine Suche nach Inhalten wird ebenfalls unterstützt. Voraussetzung für das Einbinden von HTML-Seiten ist die Installation der CODESYS -Offlinehilfe. Die CODESYS -Offlinehilfe kann über das Hilfeportal oder den CODESYS Installer installiert werden. Folgende Dateien sind für die Erweiterung notwendig Hilfeseiten im HTML-Format Die Hilfeseiten werden im Verzeichnis C:\\ProgramData\\CODESYS\\Offline Help\\<language> abgelegt. Konfigurationsdatei <name>-productinfo.json für die Übersicht der Produkthilfen Die Konfigurationsdatei wird im Verzeichnis C:\\ProgramData\\CODESYS\\Offline Help\\de\\js abgelegt. Konfigurationsdatei <name>-toc.json für die Einfügeposition der neuen Seiten Die Konfigurationsdatei wird im Verzeichnis C:\\ProgramData\\CODESYS\\Offline Help\\de\\js abgelegt. Konfigurationsdatei <name>-search.json für das Einbinden der neuen Inhalte in die Suche Die Konfigurationsdatei wird im Verzeichnis C:\\ProgramData\\CODESYS\\Offline Help\\de\\js abgelegt. Diese Datei ist optional. Das Präfix <name> der drei Konfigurationsdateien muss identisch sein. Die Dateien fuzzydata.js , productsinfo.js und toc.js sind die Standard-Konfigurationsdateien der Offlinehilfe. Nach dem Starten von CODESYS werden die Inhalte aus den json-Dateien in die Standard-Konfigurationsdateien (*.js) integriert. Die originalen Konfigurationsdateien werden in das Verzeichnis backup gesichert. " }, 
{ "title" : "Erstellen der Konfigurationsdateien ", 
"url" : "_cds_extending_offlinehelp.html#UUID-6d26fb44-e1b7-57a4-fd2b-a0110ae412ec_section-idm43473870969756", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ CODESYS-Offlinehilfe installieren \/ CODESYS-Offlinehilfe mit eigenen Inhalten erweitern \/ Erstellen der Konfigurationsdateien ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Konfigurationsdatei für die Übersicht der Produkthilfen <name>-productinfo.json ", 
"url" : "_cds_extending_offlinehelp.html#UUID-6d26fb44-e1b7-57a4-fd2b-a0110ae412ec_section-idm450371129061464", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ CODESYS-Offlinehilfe installieren \/ CODESYS-Offlinehilfe mit eigenen Inhalten erweitern \/ Erstellen der Konfigurationsdateien \/ Konfigurationsdatei für die Übersicht der Produkthilfen <name>-productinfo.json ", 
"snippet" : "Diese Datei erzeugt Einträge auf der Übersichtsseite der Produkthilfen title Angezeigter Name des Produkts mit Version url Verlinkte Seite children Keine Bedeutung, wird nicht ausgewertet Beispiel [ { \"title\": \"3rd Party, V1.2.3.4\", \"url\": \"3rd_new_pub.html\", \"children\": [] } ]...", 
"body" : "Diese Datei erzeugt Einträge auf der Übersichtsseite der Produkthilfen title Angezeigter Name des Produkts mit Version url Verlinkte Seite children Keine Bedeutung, wird nicht ausgewertet Beispiel [\n {\n \"title\": \"3rd Party, V1.2.3.4\",\n \"url\": \"3rd_new_pub.html\",\n \"children\": []\n }\n] " }, 
{ "title" : "Konfigurationsdatei für die Einfügeposition der neuen Hilfeseiten <name>-toc.json ", 
"url" : "_cds_extending_offlinehelp.html#UUID-6d26fb44-e1b7-57a4-fd2b-a0110ae412ec_section-idm471214354880041", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ CODESYS-Offlinehilfe installieren \/ CODESYS-Offlinehilfe mit eigenen Inhalten erweitern \/ Erstellen der Konfigurationsdateien \/ Konfigurationsdatei für die Einfügeposition der neuen Hilfeseiten <name>-toc.json ", 
"snippet" : "In dieser Datei wird definiert, an welcher Position die neuen Seiten in die Hilfe eingebunden werden. url HTML-Name der Seite, die eingefügt wird text Name der Seite, die eingefügt wird. Dieser Name wird im Inhaltsverzeichnis angezeigt insert_after Fügt eine neues Seite auf der gleichen Ebene wie di...", 
"body" : "In dieser Datei wird definiert, an welcher Position die neuen Seiten in die Hilfe eingebunden werden. url HTML-Name der Seite, die eingefügt wird text Name der Seite, die eingefügt wird. Dieser Name wird im Inhaltsverzeichnis angezeigt insert_after Fügt eine neues Seite auf der gleichen Ebene wie die angegebene Hilfeseite ein append_below Fügt eine neue Seite als letzte Kindseite unterhalb der angegebenen Hilfeseite ein. Wenn anstelle des HTML-Namens das Zeichen \/ zugewiesen wird, dann wird die neue Seite toplevel am Ende des Inhaltverzeichnisses hinzugefügt. children Fügt zusätzlich Kinderseiten ein Platzhalter * Die Startseiten der Produkte haben in ihrem HTML-Namen eine interne ID, die sich ändern kann. Damit diese Seiten auch nach einer Änderung gefunden werden, sollte in diesen Fällen für die ID der Platzhalter * eingesetzt werden. Beispiel 1 Die Hilfeseite 3rd_new_pub.html wird als Geschwisterseite nach der Hilfeseite 1064796-311627-codesys-redundancy.html eingefügt. [\n { \"url\": \"3rd_new_pub.html\",\n \"text\": \"New Publication\",\n \"insert_after\": \"1064796-311627-codesys-redundancy.html\"\n }\n] Beispiel 2 Zusätzlich zu Beispiel 1 werden zwei Kindseiten unterhalb der Seite New Publication eingefügt. [\n { \"url\": \"3rd_new_pub.html\",\n \"text\": \"New Publication\",\n \"children\": [\n {\n \"url\": \"3rd_new_pub_topic1.html\",\n \"text\": \"New Publication - Chapter 1\"\n },\n {\n \"url\": \"3rd_new_pub_topic2.html\",\n \"text\": \"New Publication - Chapter 2\"\n }\n ],\n \"insert_after\": \"1064796-311627-codesys-redundancy.html\"\n }\n] Beispiel 3 Die Startseiten der Produkte haben in ihrem HTML-Namen eine interne ID, die sich ändern kann. Damit diese Seiten auch nach einer Änderung gefunden werden, sollte in diesen Fällen für die ID der Platzhalter * eingesetzt werden. Analog zu Beispiel 2, jedoch wird für die Seite Insert_after ein Platzhalter eingesetzt. [\n { \"url\": \"3rd_new_pub.html\",\n \"text\": \"New Publication\",\n \"children\": [\n {\n \"url\": \"3rd_new_pub_topic1.html\",\n \"text\": \"New Publication - Chapter 1\"\n },\n {\n \"url\": \"3rd_new_pub_topic2.html\",\n \"text\": \"New Publication - Chapter 2\"\n }\n ],\n \"insert_after\": \"*-codesys-redundancy.html\"\n }\n] Beispiel 4 Die Hilfeseite 3rd_new_pub.html mit zwei Unterseiten wird als letzte Kindseite unterhalb der Hilfeseite *-codesys-softmotion.html eingefügt. [\n { \"url\": \"3rd_new_pub.html\",\n \"text\": \"New Publication\",\n \"children\": [\n {\n \"url\": \"3rd_new_pub_topic1.html\",\n \"text\": \"New Publication - Chapter 1\"\n },\n {\n \"url\": \"3rd_new_pub_topic2.html\",\n \"text\": \"New Publication - Chapter 2\"\n }\n ],\n \"append_below\": \"*-codesys-softmotion.html\"\n }\n] Beispiel 5 Diese Konfiguration fügt die Hilfeseite 3rd_toplevel.html toplevel am Ende des Inhaltverzeichnisses hinzu. [\n {\n \"url\": \"3rd_toplevel.html\",\n \"text\": \"Kapitel Toplevel\",\n \"append_below\": \"\/\"\n }\n] Beispiel 6 Dieses Beispiel zeigt eine Konfiguration mit verschiedenen Einfügepositionen [\n {\n \"url\": \"3rd_new_pub.html\"\n, \"text\": \"New Publication\",\n \"children\": [\n {\n \"url\": \"3rd_new_pub_topic1.html\",\n \"text\": \"New Publication - Chapter 1\"\n },\n {\n \"url\": \"3rd_new_pub_topic2.html\",\n \"text\": \"New Publication - Chapter 2\"\n }\n ],\n \"insert_after\": \"*-codesys-git.html\"\n },\n {\n \"url\": \"3rd_add_child.html\",\n \"text\": \"Kapitel Geschwister\",\n \"insert_after\": \"_pbdp_cmd_scan_devices.html\"\n },\n {\n \"url\": \"3rd_toplevel.html\",\n \"text\": \"Chapter Toplevel\",\n \"append_below\": \"\/\"\n }\n] " }, 
{ "title" : "Konfigurationsdatei für die Suche <name>-search.json ", 
"url" : "_cds_extending_offlinehelp.html#UUID-6d26fb44-e1b7-57a4-fd2b-a0110ae412ec_section-idm4251855645307457", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ CODESYS-Offlinehilfe installieren \/ CODESYS-Offlinehilfe mit eigenen Inhalten erweitern \/ Erstellen der Konfigurationsdateien \/ Konfigurationsdatei für die Suche <name>-search.json ", 
"snippet" : "Diese Konfiguration beinhaltet den vollständigen Hilfetext einer Seite. title Titel des Kapitels, wird als Suchtreffer angezeigt url HTML-Name der gefundenen Seite breadcrumbs Breadcrumb der gefundenen Seite. Wird im Suchtreffer angezeigt snippet Kurzer Inhaltstext der gefundenen Seite. Wird im Such...", 
"body" : "Diese Konfiguration beinhaltet den vollständigen Hilfetext einer Seite. title Titel des Kapitels, wird als Suchtreffer angezeigt url HTML-Name der gefundenen Seite breadcrumbs Breadcrumb der gefundenen Seite. Wird im Suchtreffer angezeigt snippet Kurzer Inhaltstext der gefundenen Seite. Wird im Suchtreffer angezeigt body Vollständiger Text der Hilfeseite inklusive der Überschrift [\n {\n \"title\": \"Chapter 1,\n \"url\": \"3rd_chapter1.html\",\n \"breadcrumbs\": \"3rdParty - Offline help \/ Chapter 1\",\n \"snippet\": \"Lorem ipsum dolor sit amet...\",\n \"body\": \"Chapter 1. Lorem ipsum dolor sit amet, consetetur sadipscing elitr,\n sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam \n erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. \n Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor \n sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam \n nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam \n voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita \n kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet\"\n },\n {\n \"title\": \"Chapter 2\",\n \"url\": \"3rd_chapter2.html\",\n \"breadcrumbs\": \"3rdParty - Offline help \/ Chapter 2\",\n \"snippet\": \"Lorem ipsum dolor sit amet...\",\n \"body\": \"Chapter 2. Lorem ipsum dolor sit amet, consetetur sadipscing elitr,\n sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam \n erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. \n Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor \n sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam \n nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam \n voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita \n kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet\"\n }\n] " }, 
{ "title" : "Anpassen der HTML-Seiten ", 
"url" : "_cds_extending_offlinehelp.html#UUID-6d26fb44-e1b7-57a4-fd2b-a0110ae412ec_section-idm234730211407826", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ CODESYS-Offlinehilfe installieren \/ CODESYS-Offlinehilfe mit eigenen Inhalten erweitern \/ Anpassen der HTML-Seiten ", 
"snippet" : "Die zusätzlichen Hilfeseiten müssen das Format HTML haben. Damit das Inhaltsverzeichnis, die Sprachumschaltung und das Suchfeld auch auf den neu hinzugefügten Seiten angezeigt wird, müssen die neuen Seiten in einen \"HTML-Rahmen\" eingebettet werden. Die Vorlagedatei TemplateOfflineHelp_Simple.html is...", 
"body" : "Die zusätzlichen Hilfeseiten müssen das Format HTML haben. Damit das Inhaltsverzeichnis, die Sprachumschaltung und das Suchfeld auch auf den neu hinzugefügten Seiten angezeigt wird, müssen die neuen Seiten in einen \"HTML-Rahmen\" eingebettet werden. Die Vorlagedatei TemplateOfflineHelp_Simple.html ist nach der Installation der Offlinehilfe im Unterverzeichnis C:\\ProgramData\\CODESYS\\Offline Help\\Templates zu finden. Diese Vorlage dient als Rahmen für zusätzliche HTML-Seiten. Folgende Anpassungen sind notwendig: Einfügen des Namens der Registerkarte im Browser im Platzhalter {{TITLE}} . Dies ist üblicherweise die Überschrift der Hilfeseite <title>{{TITLE}}<\/title> \n Einfügen des gesamten Inhalts der zusätzlichen Hilfeseite im Platzhalter {{CONTENT}} . <!-- Place main content here -->\n{{CONTENT}} \n Wenn die neuen Seiten das Design der CODESYS -Hilfe erhalten sollen, müssen die Stylesheet-Klassen der bestehenden CODESYS -Offlinehilfe verwendet werden. Die Vorlage TemplateOfflineHelp_Full.html zeigt exemplarisch diese Anpassungen. " }, 
{ "title" : "Installation der Hilfeseiten über ein Package ", 
"url" : "_cds_extending_offlinehelp.html#UUID-6d26fb44-e1b7-57a4-fd2b-a0110ae412ec_section-idm234730226436619", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS konfigurieren \/ CODESYS-Offlinehilfe installieren \/ CODESYS-Offlinehilfe mit eigenen Inhalten erweitern \/ Installation der Hilfeseiten über ein Package ", 
"snippet" : "Üblicherweise wird eine Erweiterung der Offlinehilfe über ein Package durchgeführt. Beispiel: Ablage der Daten im Package Beispieleintrag in der Datei package.manifest <Component> <General> <Id>1<\/Id> <Name>Offline Help Files<\/Name> <Description>Offline help files for 3rd party product<\/Description>...", 
"body" : "Üblicherweise wird eine Erweiterung der Offlinehilfe über ein Package durchgeführt. Beispiel: Ablage der Daten im Package Beispieleintrag in der Datei package.manifest <Component>\n <General>\n <Id>1<\/Id>\n <Name>Offline Help Files<\/Name>\n <Description>Offline help files for 3rd party product<\/Description>\n <Selectable>false<\/Selectable>\n <SelectedByDefault>true<\/SelectedByDefault>\n <\/General>\n <Items>\n <Folder>\n <TargetFolder>%REPOSITORY_LOCATION%<\/TargetFolder>\n <Path>Offline Help<\/Path>\n <\/Folder>\n <\/Items>\n<\/Component>\n " }, 
{ "title" : "Ihr erstes CODESYS-Programm ", 
"url" : "_cds_tutorial_refrigerator_control.html", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Vorbereitung ", 
"url" : "_cds_tutorial_refrigerator_control-1852840.html", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Vorbereitung ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Bevor Sie loslegen ", 
"url" : "_cds_tutorial_refrigerator_control-1852840.html#UUID-37040273-01ac-3f6e-080f-c300763700a5_id_ad860c2982c38315c0a8640e0192efdf_id_1acf960483fd46f8c0a8640e01c47574", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Vorbereitung \/ Bevor Sie loslegen ", 
"snippet" : "Datensicherheit: Um das Risiko von Datensicherheitsverletzungen zu minimieren, empfehlen wir die folgenden organisatorischen und technischen Maßnahmen: Vermeiden Sie, dass auf die SPS und die Steuerungsnetzwerke aus offenen Netzwerken oder dem Internet zugegriffen werden kann. Verwenden Sie ein VPN ...", 
"body" : "Datensicherheit: Um das Risiko von Datensicherheitsverletzungen zu minimieren, empfehlen wir die folgenden organisatorischen und technischen Maßnahmen: Vermeiden Sie, dass auf die SPS und die Steuerungsnetzwerke aus offenen Netzwerken oder dem Internet zugegriffen werden kann. Verwenden Sie ein VPN für Remote-Zugriff. Installieren Sie eine Firewall. Wenn Sie Ihre Visualisierung im Web veröffentlichen möchten, setzen Sie ein Passwort zum Schutz vor unberechtigten Zugriffen. Verwenden Sie die neuesten Versionen von Gatewayserver und Web-Server. CODESYS installieren Die Installation umfasst das Entwicklungssystem sowie das CODESYS -Gateway und CODESYS Control Win , deren Dienste über die Windows-Taskleiste zugänglich sind. Diese drei Programme sind notwendig, um eine Steuerung auf Ihrem Computer zu simulieren. " }, 
{ "title" : "Zum Inhalt Ihres ersten Projekts ", 
"url" : "_cds_tutorial_refrigerator_control-1852840.html#UUID-37040273-01ac-3f6e-080f-c300763700a5_id_ad860c2982c38315c0a8640e0192efdf_id_95ee254f8863349ec0a8640e00ddaa4f", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Vorbereitung \/ Zum Inhalt Ihres ersten Projekts ", 
"snippet" : "In diesem Tutorial werden Sie eine einfache Kühlschranksteuerung programmieren. Zusätzlich zu dem Beispielprojekt, das Sie hier Schritt für Schritt erstellen werden, enthält das fertige Projekt eine komplette Visualisierung mit Bedienung und Diagnose. Das fertige Projekt RefrigeratorControl.projecta...", 
"body" : "In diesem Tutorial werden Sie eine einfache Kühlschranksteuerung programmieren. Zusätzlich zu dem Beispielprojekt, das Sie hier Schritt für Schritt erstellen werden, enthält das fertige Projekt eine komplette Visualisierung mit Bedienung und Diagnose. Das fertige Projekt RefrigeratorControl.projectarchive finden Sie im Installationsverzeichnis von CODESYS im Verzeichnis Projects . Wie bei einem handelsüblichen Kühlschrank wird die Solltemperatur über einen Drehregler vom Benutzer vorgegeben. Über einen Sensor ermittelt der Kühlschrank die Isttemperatur. Wenn diese zu hoch ist, startet der Kühlschrank mit einer einstellbaren Verzögerung den Kompressor. Der Kompressor kühlt, bis die eingestellte Solltemperatur abzüglich einer Hysterese von 1 Grad erreicht ist. Die Hysterese soll verhindern, dass die Isttemperatur zu sehr um die Solltemperatur schwingt und sich der Kompressor ständig aus- und einschaltet. Wenn die Tür offen steht, leuchtet im Inneren des Kühlschranks eine Lampe. Steht die Tür zu lange offen, ertönt ein getaktetes akkustisches Signal. Wenn der Kompressor die Solltemperatur trotz Aktivität des Motors über längere Zeit nicht erreicht, gibt der Pieper ein durchgehendes, akkustisches Signal. Projektierung: Die Steuerung der Kühltätigkeit erfolgt im Hauptprogramm der Applikation, die Signalverwaltung in einem weiteren Programmbaustein. Die benötigten Standardfunktionsbausteine sind in der Bibliothek Standard verfügbar. Da in diesem Beispielprojekt keine echten Temperatursensoren und keine echten Aktoren angeschlossen werden, schreiben Sie zusätzlich ein Programm zur Simulation von Temperaturanstieg und Temperatursenkung. Damit können Sie nachher das Arbeiten der Kühlschranksteuerung im Onlinebetrieb beobachten. Variablen, die von allen Bausteinen verwendet werden sollen, definieren Sie in einer globalen Variablenliste. " }, 
{ "title" : "Starten von CODESYS Development System ", 
"url" : "_cds_tutorial_refrigerator_control-1852840.html#UUID-37040273-01ac-3f6e-080f-c300763700a5_id_ad860c2982c38315c0a8640e0192efdf_id_17e8e10183fd46f9c0a8640e017b2032", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Vorbereitung \/ Starten von CODESYS Development System ", 
"snippet" : "Sie haben das CODESYS Development System installiert und mit dem Standardprofil „ CODESYS <aktuelle Version>“ gestartet. Das Rahmenfenster des Entwicklungssystems erscheint mit der Standardmenüleiste, es ist noch kein Projekt geöffnet....", 
"body" : "Sie haben das CODESYS Development System installiert und mit dem Standardprofil „ CODESYS <aktuelle Version>“ gestartet. Das Rahmenfenster des Entwicklungssystems erscheint mit der Standardmenüleiste, es ist noch kein Projekt geöffnet. " }, 
{ "title" : "Anlegen des Projekts und Auswählen des SPS-Geräts ", 
"url" : "_cds_tutorial_refrigerator_create.html", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Anlegen des Projekts und Auswählen des SPS-Geräts ", 
"snippet" : "Wählen Sie den Befehl Datei → Neues Projekt . Selektieren Sie im Fenster Vorlagen die Vorlage Standardprojekt . Geben Sie einen Namen und einen Speicherort für das Projekt ein und klicken dann auf die Schaltfläche OK . Der Dialog Standardprojekt erscheint zur Eingabe des Gerätetyps und der Implement...", 
"body" : "Wählen Sie den Befehl Datei → Neues Projekt . Selektieren Sie im Fenster Vorlagen die Vorlage Standardprojekt . Geben Sie einen Namen und einen Speicherort für das Projekt ein und klicken dann auf die Schaltfläche OK . Der Dialog Standardprojekt erscheint zur Eingabe des Gerätetyps und der Implementierungssprache des Hauptprogramms. Wählen Sie in der Liste Gerät den Eintrag CODESYS Control Win . Wählen Sie in der Liste PLC_PRG in den Eintrag Continuos Function Chart (CFC) und klicken Sie auf die Schaltfläche OK . Das Projekt wird im CODESYS -Rahmenfenster geöffnet. Auf der linken Seite des Rahmenfensters, in der Ansicht Geräte , sehen Sie den „Gerätebaum“, eine Ansicht, betitelt mit Geräte . Das vorher ausgewählte SPS-Gerät ist mit dem Standardnamen Device eingehängt. Unter dem Objekt SPS-Logik hängt bereits das Objekt Application für die von Ihnen zu programmierende Applikation. Application enthält bereits ein Objekt für das Hauptprogramm PLC_PRG und den Bibliotheksverwalter . Der Bibliotheksverwalter enthält bereits die Bibliotheken IoStandard und Standard . IoStandard wird für E\/A-Konfigurationen benötigt. Die Bibliothek Standard enthält alle Funktionen und Funktionsbausteine, die von der Norm IEC 61131-3 beschrieben werden. Am Ende des Gerätebaums hängt das Objekt Taskkonfiguration mit der MainTask , die die Abarbeitung von PLC_PRG steuert. Unterhalb von Taskkonfiguration können Sie später beispielsweise noch die Objekte für eine Visualisierung einfügen. Zusätzlich zu den Bibliotheken IoStandard und Standard benötigen Sie für das vorliegende Beispielprojekt die Bibliothek Util : Doppelklicken Sie das Objekt Bibliotheksverwalter im Gerätebaum. Der Bibliotheksverwalter öffnet sich in seinem Editor. Klicken Sie in der Kopfleiste des Editors auf Bibliothek hinzufügen und tippen Sie \"Util\" in das Feld für die Volltextsuche ein. Wählen Sie aus den Suchergebnissen die Bibliothek Util aus und bestätigen Sie die Auswahl mit OK . Die Bibliothek Util wird im Bibliotheksverwalter hinzugefügt und die Bausteine der Bibliothek stehen Ihnen für das Projekt zur Verfügung. " }, 
{ "title" : "Im Projekt die Steuerungsapplikation programmieren ", 
"url" : "_cds_tutorial_refrigerator_program.html", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Im Projekt die Steuerungsapplikation programmieren ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Deklarieren der globalen Variablen ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_a9dca56f886334a3c0a8640e00c68270", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Im Projekt die Steuerungsapplikation programmieren \/ Deklarieren der globalen Variablen ", 
"snippet" : "Deklarieren Sie zunächst die Variablen, die Sie in der gesamten Applikation verwenden wollen. Dazu legen Sie unter Application eine Globale Variablenliste an: Selektieren Sie den Eintrag Application und wählen im Kontextmenü den Befehl Objekt hinzufügen → Globale Variablenliste . Ändern Sie den auto...", 
"body" : "Deklarieren Sie zunächst die Variablen, die Sie in der gesamten Applikation verwenden wollen. Dazu legen Sie unter Application eine Globale Variablenliste an: Selektieren Sie den Eintrag Application und wählen im Kontextmenü den Befehl Objekt hinzufügen → Globale Variablenliste . Ändern Sie den automatisch eingetragenen Namen GVL zu Glob_Var und bestätigen Sie mit Hinzufügen . Unter Application erscheint das Objekt Glob_Var . Der GVL-Editor öffnet rechts vom Gerätebaum. Wenn die textuelle Ansicht erscheint, sind die Schlüsselwörter VAR_GLOBAL und END_VAR bereits enthalten. Aktivieren Sie für unser Beispiel mit einem Klick auf die Schaltfläche in der rechten Randleiste des Editors die tabellarische Ansicht. Eine leere Zeile erscheint. Der Cursor ist in der Spalte Name . Wählen Sie im Kontextmenü den Befehl Einfügen . Ein Eingabefeld öffnet sich. Gleichzeitig werden in der Zeile automatisch der Gültigkeitsbereich VAR_GLOBAL und der Datentyp BOOL eingetragen. Tippen Sie rTempActual im Feld Name ein. Doppelklicken Sie in das Feld in der Spalte Datentyp . Das Feld ist jetzt editierbar und die Schaltfläche erscheint. Klicken Sie auf die Schaltfläche und wählen Sie Eingabehilfe . Der Dialog Eingabehilfe öffnet sich. Wählen Sie den Datentyp REAL aus und klicken Sie auf die Schaltfläche OK . Geben Sie einen numerischen Wert in der Spalte Initialisierung ein, beispielsweise 8.0 . Deklarieren Sie die folgenden Variablen auf gleiche Weise: Name Datentyp Initialisierung Kommentar rTempActual REAL 8.0 Isttemperatur rTempSet REAL 8.0 Solltemperatur xDoorOpen BOOL FALSE Status Tür timAlarmThreshold TIME T#30S Kompressorlaufzeit, nach der ein Signal ertönt timDoorOpenThreshold TIME T#10S Zeit ab Türöffnung, nach der ein Signal ertönt xCompressor BOOL FALSE Steuersignal xSignal BOOL FALSE Steuersignal xLamp BOOL FALSE Statusmeldung " }, 
{ "title" : "Hauptprogramm zur Kühlungssteuerung im CFC-Editor erstellen ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_d0ec117487fb0b44c0a8640e01a8d70a", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Im Projekt die Steuerungsapplikation programmieren \/ Hauptprogramm zur Kühlungssteuerung im CFC-Editor erstellen ", 
"snippet" : "Im standardmäßig angelegten Hauptprogrammbaustein PLC_PRG beschreiben Sie nun die Hauptfunktion des Applikationsprogramms: Der Kompressor wird aktiv und kühlt, wenn die Isttemperatur höher ist als die Solltemperatur zuzüglich einer Hysterese. Der Kompressor wird ausgeschaltet, sobald die Isttemperat...", 
"body" : "Im standardmäßig angelegten Hauptprogrammbaustein PLC_PRG beschreiben Sie nun die Hauptfunktion des Applikationsprogramms: Der Kompressor wird aktiv und kühlt, wenn die Isttemperatur höher ist als die Solltemperatur zuzüglich einer Hysterese. Der Kompressor wird ausgeschaltet, sobald die Isttemperatur niedriger ist als die Solltemperatur abzüglich der Hysterese. Um diese Funktionalität in der Implementierungssprache CFC zu beschreiben, führen Sie folgende Schritte aus: Doppelklicken Sie auf PLC_PRG im Gerätebaum. Der CFC-Editor öffnet sich mit der Registerkarte PLC_PRG . Oberhalb des grafischen Editorbereichs erscheint der Deklarationseditor in textueller oder tabellarischer Darstellung. Rechts ist das Fenster Werkzeuge . Klicken Sie im Fenster Werkzeuge auf das Element Eingang und ziehen Sie es mit der Maus in den CFC-Editor unter die Registerkarte PLC_PRG . Der namenlose Eingang ??? wurde eingefügt. Klicken Sie im CFC-Editor bei dem Eingang auf ??? und öffnen Sie dann mit einem Klick auf die Eingabehilfe. Wählen Sie aus der Kategorie Variablen unter Application → Glob_Var die Variable rTempActual aus. So referenzieren Sie hier die globale Variable rTempActual . Der Eingangsname ist Glob_Var.rTempActual . Legen Sie wie bei 3. einen weiteren Eingang mit dem Namen der globalen Variable Glob_Var.rTempSet an. Legen Sie einen weiteren Eingang an, klicken Sie auf die drei Fragezeichen ??? und ersetzen Sie diese mit dem Namen rHysteresis . Weil dies nicht der Name einer bereits bekannten Variablen ist, erscheint der Dialog Variable deklarieren . Der Name ist bereits in den Dialog übernommen. Füllen Sie die Felder im Dialog Variable deklarieren mit dem Datentyp REAL und dem Initialisierungswert 1 aus. Klicken Sie auf die Schaltfläche OK . Die Variable rHysteresis erscheint im Deklarationseditor. Nun fügen Sie einen Additionsbaustein ein: Klicken Sie im Fenster Werkzeuge auf das Element Baustein und ziehen Sie es mit der Maus unterhalb der Registerkarte PLC_PRG in den CFC-Editor. Der Baustein erscheint im CFC-Editor. Ersetzen Sie ??? mit ADD . Der Baustein addiert alle Eingänge, die mit ihm verbunden sind. Verbinden Sie den Eingang Glob_Var.rTempSet mit dem Baustein ADD . Klicken Sie dazu auf den Ausgangspin des Eingangs und ziehen Sie Ihn bis zum oberen Eingangspin des Bausteins ADD . Verbinden Sie auf die gleiche Weise den Eingang rHysteresis mit dem unteren Eingang des Bausteins ADD . Die beiden Eingänge rHysteresis und Glob_Var.rTempSet werden nun von ADD addiert. Wenn Sie ein Element im Editor verschieben möchten, klicken Sie auf eine freie Stelle im Element oder auf den Rahmen, so dass das Element selektiert ist (roter Rahmen, rot schattiert). Lassen Sie die Maustaste gedrückt und ziehen Sie das Element an die gewünschte Position. Legen Sie einen weiteren Baustein rechts vom Baustein ADD an. Er soll Glob_Var.rTempActual mit der Summe aus Glob_Var.rTempSet + rHysteresis vergleichen. Geben Sie dem Baustein die Funktion GT (Greater Than). Der GT -Baustein arbeitet folgendermaßen: IF (oberer Eingang > unterer Eingang) THEN Ausgang := TRUE; Verbinden Sie den Eingang Glob_Var.rTempActual mit dem oberen Eingang des Bausteins GT . Verbinden Sie den Ausgang des Bausteins ADD mit dem unteren Eingang des Bausteins GT . Erzeugen Sie nun mit dem Bausteinelement einen Funktionsbaustein rechts vom Baustein GT an, der den Kühlkompressor je nach Eingangsbedingung startet oder stoppt (Set - Reset). Tippen Sie im Feld ??? den Namen SR ein. Schließen Sie das geöffnete Eingabefeld oberhalb des Bausteins ( SR_0 ) mit der Eingabetaste. Der Dialog Variable deklarieren erscheint. Deklarieren Sie die Variable mit dem Namen SR_0 und dem Datentyp SR . Klicken Sie auf die Schaltfläche OK . Der Baustein SR aus der Bibliothek Standard ist instanziert. SR dient der Definition des THEN am Ausgang des GT-Bausteins. Die Eingänge SET1 und RESET erscheinen. Verbinden Sie die Ausgangsverbindung rechts am Baustein GT mit dem Eingang SET1 des Bausteins SR_0 . SR kann eine boolesche Variable von FALSE auf TRUE und wieder zurück setzen. Wenn die Bedingung am Eingang SET1 zutrifft, wird die boolesche Variable auf TRUE gesetzt. Trifft die Bedingung an RESET zu , wird die Variable wieder zurückgesetzt. Die boolesche (globale) Variable ist in unserem Beispiel Glob_Var.xCompressor . Legen Sie ein Element Ausgang an und weisen Sie ihm die globale Variable Glob_Var.xCompressor zu. Ziehen Sie eine Verbindungslinie zwischen Glob_Var.xCompressor und Ausgangsverbindung Q1 von SR . Jetzt geben Sie an, unter welcher Bedingung sich der Kompressor wieder abschalten soll, also der RESET -Eingang des SR-Bausteins ein TRUE -Signal erhält. Dazu formulieren Sie die gegenteilige Bedingung wie oben. Verwenden Sie dazu die Bausteine SUB (Subtract) und LT (Less Than). Letztendlich entsteht folgender CFC-Plan: " }, 
{ "title" : "Erstellen eines Programmbausteins zur Signalverwaltung im Kontaktplan-Editor ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_43984f578f71eb8bc0a8640e0046480b", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Im Projekt die Steuerungsapplikation programmieren \/ Erstellen eines Programmbausteins zur Signalverwaltung im Kontaktplan-Editor ", 
"snippet" : "Sie implementieren nun in einem weiteren Programmbaustein die Signalverwaltung für den Alarmtongeber und für das Ein- und Ausschalten der Lampe. Dafür eignet sich die Implementierungssprache Kontaktplan (KOP). Behandeln Sie die folgenden Signale jeweils in einem eigenen Netzwerk: Wenn der Kompressor...", 
"body" : "Sie implementieren nun in einem weiteren Programmbaustein die Signalverwaltung für den Alarmtongeber und für das Ein- und Ausschalten der Lampe. Dafür eignet sich die Implementierungssprache Kontaktplan (KOP). Behandeln Sie die folgenden Signale jeweils in einem eigenen Netzwerk: Wenn der Kompressor zu lange läuft, weil die Temperatur zu hoch ist, macht ein durchgehendes akustisches Signal darauf aufmerksam. Wenn die Türe zu lange geöffnet ist, macht ein getaktetes Signal darauf aufmerksam. Solange die Türe geöffnet ist, brennt das Licht. Rechtsklicken Sie im Gerätebaum auf das Objekts Application und fügen Sie ein POU-Objekt des Typs Programm mit der Implementierungssprache Kontaktplan (KOP2) ein. Benennen Sie das Programm Signals . Das Programm Signals erscheint im Gerätebaum neben PLC_PRG . Der Kontaktplan-Editor öffnet mit der Registerkarte Signals . Im oberen Teil erscheint der Deklarationseditor, rechts das Fenster Werkzeuge . Der Kontaktplan enthält ein leeres Netzwerk. Im Netzwerk programmieren Sie, dass ein akustisches Signal ertönt, wenn der Kühlkompressor zu lange läuft, ohne die Solltemperatur zu erreichen. Hierzu fügen Sie in den nächsten Schritten einen Timer-Baustein TON ein. Er schaltet ein boolesches Signal nach einer vorgegebenen Zeit auf TRUE . Wählen Sie in der Ansicht Werkzeuge das Element Baustein aus und ziehen Sie es mit der Maus ins leere Netzwerk auf eine angebotene Einfügeposition und lassen Sie die Maustaste los. Der Baustein erscheint als Rechteck mit Ein- und Ausgängen. Doppelklicken Sie die 3 Fragezeichen ??? in dem Baustein und klicken Sie im Zeileneditor auf das Symbol . Der Dialog Eingabehilfe öffnet sich. Wählen Sie im Dialog Eingabehilfe aus der Kategorie Standard-Funktionsbausteine aus der Bibliothek Standard den Timer TON aus und klicken Sie auf OK . Drücken Sie nun im Zeileneditor des Bausteins, der jetzt den Funktionsbausteinnamen TON anzeigt, die Eingabetaste. Der Baustein TON wird mit seinen Ein- und Ausgängen angezeigt. Um den Eingang EN und den Ausgang ENO zu entfernen, selektieren Sie den Baustein und wählen Sie im Kontextemenü die Befehle EN\/ENO → EN . Der Baustein hat jetzt nur noch die Eingänge IN und PT und die Ausgänge Q und ET . Doppelklicken Sie auf die drei Fragezeichen [???] direkt über dem Baustein, geben Sie als Instanzname TON_0 ein und drücken Sie die Eingabetaste. Sie haben den Instanznamen bestätigt und der Dialog Variable deklarieren öffnet sich. Bestätigen Sie den Dialog mit OK . Der eingefügte Baustein TON ist nun mit dem Namen TON_0 instanziert. Programmieren Sie, dass der Baustein aktiviert wird, sobald der Kühlkompressor zu laufen beginnt: Ziehen Sie zunächst aus der Ansicht Werkzeuge das Kontaktplan-Element Kontakt vor den Eingang IN des Bausteins. Doppelklicken Sie die drei Fragezeichen und klicken Sie im Zeileneditor auf das Symbol . In der Eingabehilfe wählen Sie nun die bereits deklarierte globale Variable xCompressor aus und klicken Sie auf OK . Über dem Kontakt wird der Variablenname Glob_Var.xCompressor angezeigt. Wenn Sie beginnen, an der Eingabeposition einen Variablennamen einzugeben, erhalten Sie immer automatisch eine Liste aller Variablen, deren Namen mit den eingetippten Zeichen beginnen und die an dieser Stelle verwendbar sind. Diese Unterstützung ist eine Standardeinstellung in den CODESYS -Optionen für Intelligentes Codieren. Fügen Sie das Signal ein, das aktiviert werden soll. Ziehen Sie dazu aus der Ansicht Werkzeuge , Kategorie Kontaktplan eine Spule an den Ausgang Q des TON -Bausteins. Benennen Sie die Spule mit Glob_Var.xSignal . Definieren Sie die Zeit ab Aktivierung des TON_0 -Bausteins, nach der das Signal ertönen soll: Diese Definition erfolgt über die Variable Glob_Var.timAlarmThreshold , die Sie zu diesem Zweck am Eingang PT von TON_0 einfügen. Dazu bewegen Sie den Mauszeiger an das linke Ende der Eingangsverbindung des Eingangs PT . Klicken Sie auf das fein umrandete Rechteck, das nun links der Eingangsverbindung angezeigt wird und geben Sie den Variablennamen ein. Drücken Sie die Eingabetaste. Der Dialog Variable deklarieren öffnet sich. Bestätigen Sie den Dialog mit OK . Die neu deklarierte Variable wid im Deklarationsteil angezeigt. Rechtsklicken Sie auf den TON -Baustein und wählen Sie im Kontextmenü den Befehl Nicht verwendete Pins entfernen . Der nicht verwendete Ausgang ET ist entfernt. Im zweiten Netzwerk des KOP programmieren Sie, dass das Signal getaktet ertönen soll, wenn die Türe zu lange geöffnet ist. Ziehen Sie mit der Maus aus der Ansicht Werkzeuge ein Element Netzwerk an die Einfügestelle unterhalb von Netzwerk 1. Ein leeres Netzwerk mit Nummer 2 erscheint. Implementieren Sie wie im ersten Netzwerk einen TON -Baustein zur zeitgesteuerten Aktivierung des Signals, diesmal getriggert durch die globale Variable Glob_Var.xDoorOpen am Eingang IN . Am Eingang PT fügen Sie die globale Variable Glob_Var.timDoorOpenThreshold hinzu. Fügen Sie in diesem Netzwerk an Ausgang Q des TON -Bausteins einen BLINK -Baustein aus der Bibliothek Util ein und instanzieren Sie ihn mit dem Namen Blink_0 . Der Baustein BLINK_0 taktet die Signalweiterleitung Q und damit Glob_Var.xSignal . Ziehen Sie hierfür zunächst 2 Elemente Kontakt aus der Ansicht Werkzeuge an den Ausgang OUT des Bausteins. Weisen Sie dem Kontakt direkt hinter dem Ausgang Q die Variable TON_1.Q und dem zweiten Kontakt die globale Variable Glob_Var.xDoorOpen zu. Hinter die beiden Kontakte fügen Sie ein Element Spule ein und weisen Sie ihr die globale Variable Glob_Var.xSignal zu. Deklarieren Sie die lokale Variable timSignalTime : TIME := T#1S; und fügen Sie diese Variable an den Eingängen TIMELOW und TIMEHIGH ein; die Taktdauer ist somit jeweils 1 Sekunde für TRUE und 1 Sekunde für FALSE . Rechtsklicken Sie auf den TON -Baustein und wählen Sie im Kontextmenü den Befehl Nicht verwendete Pins entfernen. Der nicht verwendete Ausgang ET ist entfernt. Im dritten Netzwerk programmieren Sie, dass die Lampe leuchtet, solange die Tür geöffnet ist. Fügen Sie dazu ein weiteres Netzwerk und einen Kontakt ein. Weisen Sie dem Kontakt die Variable GlobVar.xDoorOpen zu. Der eingefügte Kontakt leitet direkt auf eine Spule. Fügen Sie hierzu rechts vom Kontakt eine Spule hinzu und und weisen Sie der Spule die globale Variable Glob_Var.xLamp zu. CODESYS arbeitet die Netzwerke eines KOP nacheinander ab. Um zu erreichen, dass nur Netzwerk 1 oder nur Netzwerk 2 ausgeführt werden, bauen Sie jetzt am Ende von Netzwerk 1 noch einen Sprung zu Netzwerk 3 ein: Wenn Sie im Netzwerk 3 den Mauszeiger auf die 3. Zeile im linken oberen Rand des Netzwerks halten, wird die Information <Sprungmarke hier einfügen> angezeigt. Doppelklicken Sie diese Position und geben Sie im Zeileneditor als Sprungmarke DoorIsOpen: ein. Selektieren Sie das Netzwerk 1. Ziehen Sie aus der Ansicht Werkzeuge , Kategorie Kontaktplan das Element Sprung an die mit einem Dreieck gekennzeichnete Einfügeposition vor der Spule Glob_Var.xSignal . Das Sprungelement erscheint. Das Sprungziel ist noch mit ??? angegeben. Doppelklicken Sie die drei Fragezeichen [???] und klicken Sie im Zeileneditor auf das Symbol . Wählen Sie im Dialog Eingabehilfe aus den möglichen Bezeichnern von Sprungmarken DoorIsOpen aus und bestätigen Sie mit OK . Die Sprungmarke zu Netzwerk 3 ist implementiert. Das KOP-Programm sieht nun folgendermaßen aus: " }, 
{ "title" : "Aufrufen des Programms \"Signals\" im Hauptprogramm ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_8af1792b87fb0b44c0a8640e0066c163", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Im Projekt die Steuerungsapplikation programmieren \/ Aufrufen des Programms \"Signals\" im Hauptprogramm ", 
"snippet" : "In unserem Programmbeispiel soll das Hauptprogramm PLC_PRG das Programm Signals zur Signalverarbeitung aufrufen. Doppelklicken Sie im Gerätebaum auf PLC_PRG . Das Programm PLC_PRG öffnet sich im Editor. Ziehen Sie ein Element Baustein aus Ansicht Werkzeuge in den Editor von PLC_PRG . Doppelklicken S...", 
"body" : "In unserem Programmbeispiel soll das Hauptprogramm PLC_PRG das Programm Signals zur Signalverarbeitung aufrufen. Doppelklicken Sie im Gerätebaum auf PLC_PRG . Das Programm PLC_PRG öffnet sich im Editor. Ziehen Sie ein Element Baustein aus Ansicht Werkzeuge in den Editor von PLC_PRG . Doppelklicken Sie die drei Fragezeichen [???] und klicken Sie im Zeileneditor auf das Symbol . Wählen Sie im Dialog Eingabehilfe aus in der Kategorie POU- \/Programm- und Funktionsaufrufe das Programm Signals aus und bestätigen Sie mit OK . " }, 
{ "title" : "Erstellen eines ST-Programmbausteins für eine Simulation ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_9629e45ee440acc7c0a8640e0130c013", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Im Projekt die Steuerungsapplikation programmieren \/ Erstellen eines ST-Programmbausteins für eine Simulation ", 
"snippet" : "Da die Applikation dieses Beispielprojekts nicht mit realen Sensoren und Aktoren verknüpft ist, schreiben Sie nun noch ein Programm zur Simulation von Temperaturanstieg und Temperatursenkung. Damit können Sie nachher das Arbeiten der Kühlschranksteuerung im Onlinebetrieb beobachten. Sie erstellen da...", 
"body" : "Da die Applikation dieses Beispielprojekts nicht mit realen Sensoren und Aktoren verknüpft ist, schreiben Sie nun noch ein Programm zur Simulation von Temperaturanstieg und Temperatursenkung. Damit können Sie nachher das Arbeiten der Kühlschranksteuerung im Onlinebetrieb beobachten. Sie erstellen das Simulationsprogramm in Strukturiertem Text. Das Programm erhöht die Temperatur solange, bis das Hauptprogramm PLC_PRG feststellt, dass die Solltemperatur überschritten ist und den Kühlkompressor aktiviert. Daraufhin senkt das Simulationsprogramm die Temperatur wieder, bis das Hauptprogramm den Kompressor wieder deaktiviert. Rechtsklicken Sie im Gerätebau auf Applikation und fügen Sie einen POU-Baustein des Typs Programm und der Implementierungssprache ST ein. Benennen Sie den Baustein Simulation . Implementieren Sie Folgendes im ST-Editor : Deklarationsteil: PROGRAM Simulation\nVAR\n TON_1: TON; \/\/The temperature is decreased on a time delay, when the comepressor has been activated\n P_Cooling: TIME:=T#500MS;\n xReduceTemp: BOOL; \/\/Signal for dereasing the temperature\n TON_2: TON; \/\/The temperature is increased on a time delay\n P_Environment: TIME:=T#2S; \/\/Delay time when the door is closed\n P_EnvironmentDoorOpen: TIME:=T#1S; \/\/Delay time when the door is open\n xRaiseTemp: BOOL; \/\/Signal for increasing the temperature\n timTemp: TIME; \/\/Delay time\n iCounter: INT;\nEND_VAR\n\n Implementierungsteil: iCounter := iCounter + 1; \/\/ No function, just for demonstration purposes.\n\n\/\/ After the compressor has been activated due to TempActual being too high, the temperature decreases.\n\/\/ The temperature is decremented by 0.1°C per cycle after a delay of P_Cooling\nIF Glob_VAR.xCompressor THEN\n TON_1(IN:= Glob_Var.xCompressor, PT:= P_Cooling, Q=>xReduceTemp);\n IF xReduceTemp THEN\n Glob_Var.rTempActual := Glob_Var.rTempActual-0.1;\n TON_1(IN:=FALSE);\n END_IF\nEND_IF\n\n\/\/If the door is open, the warming occurs faster; SEL selects P_EnvironmentDoorOpen\ntimTemp:=SEL(Glob_Var.xDoorOpen, P_Environment, P_EnvironmentDoorOpen);\n\n\/\/If the compressor is not in operation, then the cooling chamber becomes warmer.\n\/\/The temperature is incremented by 0.1°C per cycle after a delay of tTemp\nTON_2(IN:= TRUE, PT:= timTemp, Q=>xRaiseTemp);\nIF xRaiseTemp THEN\n Glob_Var.rTempActual := Glob_Var.rTempActual + 0.1;\n TON_2(IN:=FALSE);\nEND_IF Für ein komfortables Bedienen und Beobachten des gesamten Steuerungsprogramms empfiehlt sich der Einsatz einer Visualisierung. Im fertigen Beispielprojekt zum vorliegenden Tutorial, das mit der CODESYS -Standardinstallation (Verzeichnis Projekte ) bereitgestellt wird, ist eine mit CODESYS Visualization erstellte Visualisierung eingebaut. Sie können dieses Projekt auf die Steuerung laden und starten, um es zusammen mit der Visualisierung in Funktion zu sehen. Beim Start wird die Live_Visu mit einer Darstellung des Kühlschranks gestartet, die das Arbeiten des Simulationsprogramms wiedergibt, ohne dass Sie eine Eingabe vornehmen müssen. Sie können allerdings über einen Mausklick auf den Ein\/Aus-Schalter das Tür-Öffnen und Tür-Schließen herbeiführen, und auch ein Verstellen der Temperaturvorwahl über die Nadel des Drehreglers ist möglich. Wir gehen im Rahmen dieses Tutorials hier nicht auf die Erstellung der Visualisierung ein. Ein entsprechendes Tutorial im Rahmen der Hilfe zu CODESYS Visualization ist geplant. " }, 
{ "title" : "Festlegen der auszuführenden Programme in der Taskkonfiguration ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_d442fec087abb4e8c0a8640e01bf3087", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Im Projekt die Steuerungsapplikation programmieren \/ Festlegen der auszuführenden Programme in der Taskkonfiguration ", 
"snippet" : "Die voreingestellte Taskkonfiguration enthält den Aufruf für das Hauptprogramm PLC_PRG . Für unser Beispielprojekt müssen Sie noch den Aufruf für das Programm Simulation hinzufügen. Ziehen Sie im Gerätebaum den Eintrag Simulation mit der Maus auf MainTask unter der Taskkonfiguration . Das Programm S...", 
"body" : "Die voreingestellte Taskkonfiguration enthält den Aufruf für das Hauptprogramm PLC_PRG . Für unser Beispielprojekt müssen Sie noch den Aufruf für das Programm Simulation hinzufügen. Ziehen Sie im Gerätebaum den Eintrag Simulation mit der Maus auf MainTask unter der Taskkonfiguration . Das Programm Simulation ist in der Taskkonfiguration eingefügt. Wenn Sie sich die Taskkonfiguration ansehen möchten, doppelklicken Sie auf den Eintrag MainTask , um den Editor zu öffnen. Sie sehen in der Tabelle im unteren Teil des Editors die POUs, die von der Task aufgerufen werden: PLC_PRG (standardmäßig eingetragen) und Simulation . Der Aufruftyp der Task ist Zyklisch im Intervall von 20 Millisekunden. Im Onlinebetrieb wird die Task pro Zyklus 1x die beiden Bausteine abarbeiten. " }, 
{ "title" : "Definieren der „Aktiven Applikation“ für die Kommunikation mit der SPS ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_6e4db14b8d0ab976c0a8640e01f0c733", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Im Projekt die Steuerungsapplikation programmieren \/ Definieren der „Aktiven Applikation“ für die Kommunikation mit der SPS ", 
"snippet" : "Der Name der Applikation Application ist im Fenster Geräte fett dargestellt. Das bedeutet, dass diese Applikation als „aktive Applikation“ gesetzt wurde. Die Kommunikation mit der Steuerung bezieht sich dann auf diese Applikation. Wenn es in einem Projekt nur eine Applikation gibt, wird sie automati...", 
"body" : "Der Name der Applikation Application ist im Fenster Geräte fett dargestellt. Das bedeutet, dass diese Applikation als „aktive Applikation“ gesetzt wurde. Die Kommunikation mit der Steuerung bezieht sich dann auf diese Applikation. Wenn es in einem Projekt nur eine Applikation gibt, wird sie automatisch zur aktiven Applikation. Wenn Ihre Applikation noch nicht aktiv ist, aktivieren Sie sie folgendermaßen: Klicken Sie mit der rechten Maustaste auf Application und wählen Sie im Kontextmenü den Befehl Aktive Applikation setzen . Die Applikation Application wird in der Ansicht Geräte jetzt fett dargestellt. " }, 
{ "title" : "Überprüfen des Applikationsprogramms auf Fehler ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_section-idm43264932442274", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Im Projekt die Steuerungsapplikation programmieren \/ Überprüfen des Applikationsprogramms auf Fehler ", 
"snippet" : "Während der Eingabe von Code weist CODESYS Sie sofort durch rote Unterkringelung auf Syntaxfehler hin. Die Ergebnisse der Prüfung sehen Sie auch im Meldungsfenster. Wenn nötig, öffnen Sie das Meldungsfenster mit dem Befehl Ansicht → Meldungen . Die Meldungen werden der Meldungskategorie Vorkompilier...", 
"body" : "Während der Eingabe von Code weist CODESYS Sie sofort durch rote Unterkringelung auf Syntaxfehler hin. Die Ergebnisse der Prüfung sehen Sie auch im Meldungsfenster. Wenn nötig, öffnen Sie das Meldungsfenster mit dem Befehl Ansicht → Meldungen . Die Meldungen werden der Meldungskategorie Vorkompilierung angezeigt. Sie können eine Meldung selektieren und mit Taste F4 zur entsprechenden Codestelle springen. Weitere Prüfungen des Applikationsprogramms werden dann durchgeführt, wenn die Applikation auf die Steuerung geladen wird. Nur eine fehlerfreie Applikation können Sie nachher auf die Steuerung laden. " }, 
{ "title" : "Herstellen der Verbindung zur SPS ", 
"url" : "_cds_tutorial_refrigerator_connect.html", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Herstellen der Verbindung zur SPS ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Starten von Gatewayserver und SPS ", 
"url" : "_cds_tutorial_refrigerator_connect.html#UUID-959c9499-66d7-f48b-def1-3422e79004c0_id_ad860c2982c38315c0a8640e0192efdf_id_98135acc87abb4e9c0a8640e0103f1cb", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Herstellen der Verbindung zur SPS \/ Starten von Gatewayserver und SPS ", 
"snippet" : "Zugriffsmöglichkeiten auf Steuerung prüfen Steuerungen dürfen unter keinen Umständen vom Internet oder nicht vertrauenswürdigen Netzen aus zugreifbar sein! Im Speziellen dürfen die Programmier-Ports der Steuerung unter keinen Umständen ungeschützt aus dem Internet zugreifbar sein (meist UDP-Ports 17...", 
"body" : "Zugriffsmöglichkeiten auf Steuerung prüfen Steuerungen dürfen unter keinen Umständen vom Internet oder nicht vertrauenswürdigen Netzen aus zugreifbar sein! Im Speziellen dürfen die Programmier-Ports der Steuerung unter keinen Umständen ungeschützt aus dem Internet zugreifbar sein (meist UDP-Ports 1740..1743 und TCP-Ports 1217 + 11740 oder die steuerungsspezifischen Ports)! Wenn ein Zugriff aus dem Internet dennoch ermöglicht werden muss, dann muss zwingend ein sicheres Verfahren gewählt werden, um sich mit der Steuerung zu verbinden (z.B. VPN). Für weitere Informationen siehe auch: Gerätebenutzerverwaltung handhabenGatewayserver starten: Standardmäßig wird mit CODESYS auch das Programm GatewaySysTray installiert. Über dieses Programm können Sie mit dem Gatewayserver kommunizieren. Der Gatewayserver wird beim Systemstart automatisch als Dienst gestartet. Überprüfen Sie, ob die Windows-Taskleiste das Programmsymbol enthält. Wenn der Gatewayserver nicht läuft, erscheint das Symbol so: . In diesem Fall können Sie durch einen Mausklick auf das Symbol das Gatewaymenü öffnen und den Befehl Start Gateway wählen. SPS starten: Standardmäßig wird mit CODESYS auch das Programm CODESYS ControlSysTray installiert. Über dieses Programm können Sie mit dem CODESYS Control Service kommunizieren. Als Schutz gegen unautorisierten Zugriff wird ab CODESYS V3.5 SP2 der Steuerungsdienst nicht mehr automatisch beim Systemstart mit gestartet. Starten Sie die SPS folgendermaßen: Öffnen Sie mit einem Mausklick auf das in der Windows-Taskleiste das SPS-Menü und wählen Sie den Befehl Start PLC . Wenn die SPS läuft, ändert sich das Symbol zu . Ein beim Starten erscheinender Dialog weist Sie darauf hin, dass die gestartete SPS einen Programmierzugriff ermöglicht. Beachten Sie dazu unbedingt die oben angegebenen Sicherheitshinweise! " }, 
{ "title" : "Bei der allerersten Kommunikationskonfiguration: Hinzufügen des Gateway ", 
"url" : "_cds_tutorial_refrigerator_connect.html#UUID-959c9499-66d7-f48b-def1-3422e79004c0_id_ad860c2982c38315c0a8640e0192efdf_id_0617e29387abb4ebc0a8640e01437431", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Herstellen der Verbindung zur SPS \/ Bei der allerersten Kommunikationskonfiguration: Hinzufügen des Gateway ", 
"snippet" : "Doppelklicken Sie auf den Eintrag Device ( CODESYS Control Win ) in der Ansicht Geräte . Im Editor Device erscheint die Registerkarte Kommunikation . Wenn dies Ihre erste Kommunikationskonfiguration mit CODESYS V3 ist, müssen Sie nun den lokalen Gatewayserver definieren. Wenn Sie den Gatewayserver s...", 
"body" : "Doppelklicken Sie auf den Eintrag Device ( CODESYS Control Win ) in der Ansicht Geräte . Im Editor Device erscheint die Registerkarte Kommunikation . Wenn dies Ihre erste Kommunikationskonfiguration mit CODESYS V3 ist, müssen Sie nun den lokalen Gatewayserver definieren. Wenn Sie den Gatewayserver schon einmal definiert haben, wird er auf der Registerkarte Kommunikation angezeigt. In diesem Fall können Sie jetzt mit Schritt Festlegen des Kommunikationskanals weitermachen. Der Gatewayserver wird mit der CODESYS -Installation bereitgestellt. Wählen Sie den Befehl Gateway → Neues Gateway hinzufügen . Der Dialog Gateway erscheint. Geben Sie im Eingabefeld Name einen symbolischen Namen für das Gateway ein. Wählen Sie in der Liste Treiber den Eintrag TCP\/IP aus. Doppelklicken Sie auf die rechte Spalte der Zeile IP-Adresse und geben Sie im Eingabefeld localhost ein. Klicken Sie auf die Schaltfläche OK . Das Gateway wird in der Registerkarte Kommunikation (1) des Geräteeditors eingetragen. Wenn das Gateway korrekt läuft, wird ein grün gefüllter Kreis an der Grafik des Gateway angezeigt: " }, 
{ "title" : "Festlegen des Kommunikationskanals ", 
"url" : "_cds_tutorial_refrigerator_connect.html#UUID-959c9499-66d7-f48b-def1-3422e79004c0_id_ad860c2982c38315c0a8640e0192efdf_id_50186f59d1ccca7dc0a8640e0152059e", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Herstellen der Verbindung zur SPS \/ Festlegen des Kommunikationskanals ", 
"snippet" : "Nun definieren Sie den Kommunikationskanal zum Gerät, der dann über das gesetzte Gateway verwendet wird. Öffnen Sie dazu die Registerkarte Kommunikation des Geräteeditors mit einem Doppelklick auf den Eintrag Device im Gerätebaum. Klicken Sie auf die Schaltfläche Netzwerk durchsuchen , um das lokale...", 
"body" : "Nun definieren Sie den Kommunikationskanal zum Gerät, der dann über das gesetzte Gateway verwendet wird. Öffnen Sie dazu die Registerkarte Kommunikation des Geräteeditors mit einem Doppelklick auf den Eintrag Device im Gerätebaum. Klicken Sie auf die Schaltfläche Netzwerk durchsuchen , um das lokale Netzwerk nach allen verfügbaren Geräten zu durchsuchen. Der Dialog Gerät auswählen (1) erscheint mit einer Liste aller Geräte, mit denen Sie eine Verbindung einrichten können. Wählen Sie im Baum den Eintrag mit dem Namen Ihres Computers aus. Klicken Sie OK . Der Kanal ist jetzt aktiv und auf der Registerkarte Kommunikation erscheint die zugehörige Information unterhalb der Gerätegrafik. Selektieren Sie das gewünschte Gerät und klicken Sie auf OK . Sie erhalten eine Meldungsbox mit dem Hinweis, dass für das Gerät eine Benutzerverwaltung obligatorisch, aber noch nicht aktiviert ist. Sie werden gefragt, ob Sie die Benutzerverwaltung jetzt aktivieren wollen. Sie erhalten den Hinweis, dass Sie in diesem Fall einen neuen Administrator-Benutzer anlegen und sich dann als dieser Benutzer einloggen müssen. Schließen Sie die Abfrage mit Ja . Der Dialog Gerätebenutzer hinzufügen öffnet sich zum Anlegen eines initialen Geräteadministrators. Definieren Sie die Zugangsdaten für den Geräteadministrator: Name und Passwort . Aktivieren Sie die Option Passwort kann vom Benutzer geändert werden . Schließen Sie mit OK ab. Der Dialog Gerätebenutzeranmeldung öffnet sich. Geben Sie die im vorigen Schritt definierten Zugangsdaten für den Geräteadministrator ein. Der Verbindungspfad zur Steuerung ist eingestellt. Alle Kommunikationsaktionen beziehen sich jetzt genau auf diesen Kanal. Beachten Sie dies später, wenn Sie mehrere Kommunikationskanäle im Projekt haben. " }, 
{ "title" : "Applikation auf der SPS ", 
"url" : "_cds_tutorial_refrigerator_app.html", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Applikation auf der SPS ", 
"snippet" : "Ausführen eines Einzelzyklus zur Laufzeit Voraussetzung: Die Applikation ist auf die Steuerung geladen und läuft. Beobachten Sie wie oben bei der schrittweisen Ausführung wieder die Zeile iCounter := iCounter + 1; im Programm Simulation . Drücken Sie Strg + F5 oder wählen Sie den Befehl Debug → Einz...", 
"body" : "Ausführen eines Einzelzyklus zur Laufzeit Voraussetzung: Die Applikation ist auf die Steuerung geladen und läuft. Beobachten Sie wie oben bei der schrittweisen Ausführung wieder die Zeile iCounter := iCounter + 1; im Programm Simulation . Drücken Sie Strg + F5 oder wählen Sie den Befehl Debug → Einzelzyklus , um einen Einzelzyklus auszuführen. Die Abarbeitung durchläuft 1 Zyklus und bleibt wieder auf dem Haltepunkt stehen. iCounter wurde um 1 hochgezählt. Drücken Sie weitere Male Strg + F5 , um Einzelzyklen zu sehen. Drücken Sie dann wieder F5 . Das Programm läuft wieder ohne Halt und ohne geforcte Werte. Die Variable temp hat wieder den Wert 1s . In der Statusleiste erscheint wieder . " }, 
{ "title" : "Laden der Applikation auf die SPS ", 
"url" : "_cds_tutorial_refrigerator_app.html#UUID-2ce2cf20-ee9b-44c0-e254-1b4cf5ee6953_id_ad860c2982c38315c0a8640e0192efdf_id_ac03476587abb4eec0a8640e0119358c", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Applikation auf der SPS \/ Laden der Applikation auf die SPS ", 
"snippet" : "Voraussetzung: Die Applikation wurde fehlerfrei übersetzt. Für weitere Informationen siehe: Überprüfen des Applikationsprogramms auf Fehler Wählen Sie den Befehl Online → Einloggen . Eine Dialogbox erscheint mit der Abfrage, ob die Applikation auf die Steuerung geladen werden soll. Klicken Sie auf J...", 
"body" : "Voraussetzung: Die Applikation wurde fehlerfrei übersetzt. Für weitere Informationen siehe: Überprüfen des Applikationsprogramms auf Fehler Wählen Sie den Befehl Online → Einloggen . Eine Dialogbox erscheint mit der Abfrage, ob die Applikation auf die Steuerung geladen werden soll. Klicken Sie auf Ja . Die Applikation wird auf die Steuerung geladen. Die Einträge für die Steuerung und die Applikation im Fenster Geräte werden grün hinterlegt. Hinter dem Objekt Application steht Stop . In der Taskleiste erscheint der aktuelle Status der Steuerung: . " }, 
{ "title" : "Starten der Applikation ", 
"url" : "_cds_tutorial_refrigerator_app.html#UUID-2ce2cf20-ee9b-44c0-e254-1b4cf5ee6953_id_ad860c2982c38315c0a8640e0192efdf_id_9709c503975dfa4dc0a8640e0120e452", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Applikation auf der SPS \/ Starten der Applikation ", 
"snippet" : "Wenn Sie das Tutorial bis zu diesem Punkt vollständig befolgt haben, können Sie nun die Applikation Application auf der SPS Device ( CODESYS Control Win ) verwenden. Rechtsklicken Sie im Fenster Geräte auf das Objekt Application und wählen Sie im Kontextmenü den Befehl Starten aus. Das Programm läuf...", 
"body" : "Wenn Sie das Tutorial bis zu diesem Punkt vollständig befolgt haben, können Sie nun die Applikation Application auf der SPS Device ( CODESYS Control Win ) verwenden. Rechtsklicken Sie im Fenster Geräte auf das Objekt Application und wählen Sie im Kontextmenü den Befehl Starten aus. Das Programm läuft. Die Einträge für die Steuerung und die Applikation im Fenster Geräte werden grün hinterlegt. Hinter dem Objekt Application steht run . In der Taskleiste erscheint der aktuelle Status der Steuerung: . " }, 
{ "title" : "Monitoring und einmaliges Schreiben von Variablenwerten zur Laufzeit ", 
"url" : "_cds_tutorial_refrigerator_app.html#UUID-2ce2cf20-ee9b-44c0-e254-1b4cf5ee6953_id_ad860c2982c38315c0a8640e0192efdf_id_2af116343d0211e59bd5bc6c9609cd9d", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Applikation auf der SPS \/ Monitoring und einmaliges Schreiben von Variablenwerten zur Laufzeit ", 
"snippet" : "Im Folgenden sehen Sie sich das „Monitoring“ der Variablenwerte in den verschiedenen Programmbausteinen an und setzen aus CODESYS heraus einmalig einen bestimmten Variablenwert auf der Steuerung. Die Istwerte der Applikationsvariablen sehen Sie in den Online-Ansichten der Bausteineditoren oder in Üb...", 
"body" : "Im Folgenden sehen Sie sich das „Monitoring“ der Variablenwerte in den verschiedenen Programmbausteinen an und setzen aus CODESYS heraus einmalig einen bestimmten Variablenwert auf der Steuerung. Die Istwerte der Applikationsvariablen sehen Sie in den Online-Ansichten der Bausteineditoren oder in Überwachungslisten. Im Beispiel hier beschränken wir uns auf das Monitoring im Bausteineditor. Voraussetzung: Die Applikation läuft auf der Steuerung. Öffnen Sie mit Doppelklicks auf die Objekte PLC_PRG , Signals , Simulation und Glob_Var im Gerätebaum die Onlineansichten der Editoren. Im Deklarationsteil jeder Ansicht erscheint in der Tabelle der Ausdrücke in der Spalte Wert (3) der Istwert der Variablen (1) auf der Steuerung (siehe Abbildung). Das Monitoring im Implementierungsteil hängt von der Implementierungssprache ab: Bei nicht-booleschen Variablen steht der Wert immer in einem rechteckigen Feld rechts des Bezeichners. Im ST-Editor gilt dies auch für boolesche Variablen. Diese Anzeige nennen wir „Inlinemonitoring“. In den grafischen Editoren wird der Wert einer booleschen Variablen durch die Farbe der Ausgangsverbindungslinie angezeigt: schwarz für FALSE , blau für TRUE : Betrachten Sie das Verändern der Variablenwerte in den verschiedenen Bausteinen. Beispielsweise sehen Sie in der GVL Glob_Var , wie sich durch die Abarbeitung des Simulationsprogramms die Werte von rTempActual und xCompressor ändern. Einmaliges Setzen von Variablenwerten auf der Steuerung: Setzen Sie den Fokus in die Onlineansicht der GVL Glob_Var . Um einen neuen Sollwert vorzugeben, doppelklicken Sie bei dem Ausdruck rTempSet in die Spalte Vorbereiteter Wert (2). Ein Eingabefeld öffnet sich. Tragen Sie den Wert 9 ein und verlassen Sie das Eingabefeld. Um ein Offenstehen der Tür vorzugeben, klicken Sie bei Ausdruck xDoorOpen 1x in das Feld Vorbereiteter Wert . Der Wert TRUE wird eingetragen. Klicken Sie weitere 3 Male, um zu sehen, dass Sie damit den vorbereiteten Wert auf FALSE , dann wieder auf leer und dann wieder auf TRUE schalten können. Um den vorbereiteten Wert TRUE einmalig auf die Variable zu schreiben, drücken Sie Strg + F7 . Die beiden Werte werden jeweils in die Spalte Wert (3) übertragen. Die Variable xDoorOpen verändert ihren Wert jetzt nicht mehr und die Solltemperatur ist jetzt 9 Grad. Die Variable timTemp wechselt auf den Wert 1s , da nun die Kühlschranktür „geöffnet“ ist und dadurch das Erwärmen durch Simulation schneller als vorher ( 2s ) erfolgen soll. " }, 
{ "title" : "Setzen von Haltepunkten und schrittweise Ausführung zur Laufzeit ", 
"url" : "_cds_tutorial_refrigerator_app.html#UUID-2ce2cf20-ee9b-44c0-e254-1b4cf5ee6953_id_ad860c2982c38315c0a8640e0192efdf_id_79bd3dd53f6511e58d96f7ece25b7bb8", 
"breadcrumbs" : "CODESYS Essentials \/ Ihr erstes CODESYS-Programm \/ Applikation auf der SPS \/ Setzen von Haltepunkten und schrittweise Ausführung zur Laufzeit ", 
"snippet" : "„Debuggen“: Für die Fehlersuche wollen Sie die Variablenwerte an bestimmten Codestellen überprüfen. Dazu können Sie Haltepunkte für die Abarbeitung definieren und eine schrittweise Ausführung der Anweisungen veranlassen. Voraussetzung: Die Applikation ist auf die Steuerung geladen und läuft. Öffnen ...", 
"body" : "„Debuggen“: Für die Fehlersuche wollen Sie die Variablenwerte an bestimmten Codestellen überprüfen. Dazu können Sie Haltepunkte für die Abarbeitung definieren und eine schrittweise Ausführung der Anweisungen veranlassen. Voraussetzung: Die Applikation ist auf die Steuerung geladen und läuft. Öffnen Sie mit einem Doppelklick auf Simulation das Programm im Editor. Setzen Sie den Cursor in die Codezeile iCounter := iCoutner + 1; und drücken Sie F9 Vor der Codezeile erscheint das Symbol . Es zeigt an, dass an dieser Zeile ein Haltepunkt gesetzt ist. Das Symbol wechselt sofort zu . Der gelbe Pfeil zeigt immer auf die nächste abzuarbeitende Anweisung. In der Taskleiste erscheint anstelle von . Betrachten Sie den Wert der Variablen iCounter im Inlinemonitoring oder im Deklarationsteil des Programms Simulation . Der Variablenwert verändert sich nicht mehr. Die Abarbeitung wurde am Haltepunkt gestoppt. Drücken Sie F5 , was die Abarbeitung wieder startet. Das Programm stoppt nach 1 Zyklus erneut am Haltepunkt. iCounter wurde um 1 hochgezählt. Drücken Sie F8 , um den nächsten Abarbeitungsschritt auszuführen. RETURN am Ende der Zeile iCounter := iCounter + 1; Anweisung wird gelb markiert. Drücken Sie erneut F8 , um den nächsten Abarbeitungsschritt auszuführen. Die Abarbeitung springt in den Editor von PLC_PRG . Wiederholtes Drücken von F8 zeigt, wie das Programm Schritt für Schritt ausgeführt wird. Die auszuführende Anweisung wird wieder jeweils mit einem gelben Pfeil gekennzeichnet. Um den Haltepunkt zu deaktivieren und zur normalen Abarbeitung zurückzukehren, setzen Sie den Cursor erneut in die Codezeile und drücken F9 . Drücken Sie dann F5 , um die Applikation wieder in den Modus zu bringen. " }, 
{ "title" : "Projekt anlegen und konfigurieren ", 
"url" : "_cds_struct_project_creation.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Was ist ein Projekt? ", 
"url" : "_cds_struct_project_creation.html#UUID-642975ca-6900-fd18-91a2-987103ac341d_section-idm4534107013289632649624131016", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ Was ist ein Projekt? ", 
"snippet" : "Was ist ein Projekt? Ein Projekt enthält die Objekte, die zur Erstellung eines Steuerungsprogramms („Applikation“) nötig sind: Reine Programmierbausteine Beispiele: Programme, Funktionsbausteine, Funktionen und GVLs Objekte, die zusätzlich benötigt werden, um die Applikation auf einer SPS ausführen ...", 
"body" : "Was ist ein Projekt? Ein Projekt enthält die Objekte, die zur Erstellung eines Steuerungsprogramms („Applikation“) nötig sind: Reine Programmierbausteine Beispiele: Programme, Funktionsbausteine, Funktionen und GVLs Objekte, die zusätzlich benötigt werden, um die Applikation auf einer SPS ausführen zu können Beispiele: Taskkonfiguration, Bibliotheksverwalter, Symbolkonfiguration, Gerätekonfiguration, Visualisierungen und externe Dateien In einem Projekt können Sie mehrere Applikationen programmieren und mehrere Steuerungsgeräte anbinden. Gerätespezifische und applikationsspezifische Bausteine verwaltet CODESYS in der Ansicht Geräte („ Gerätebaum “), projektweit verfügbare Bausteine in der Ansicht POUs . Für das Erstellen von Projekten gibt es Vorlagen, die bereits bestimmte Objekte enthalten. In den Projekteinstellungen und Projektinformationen sind Grundkonfigurationen und Informationen zum Projekt definiert. Beispielsweise: Compiler-Einstellungen Benutzerverwaltung Autor Daten zur Projektdatei In den Konfigurationsdialogen zur Projektumgebung gibt es Einstellungen zur Versionskompatibilität des Projekts. Sie legen ein Projekt als Datei im Dateisystem ab. Optional können Sie es zusammen mit projektrelevanten Dateien und Informationen in einem Projektarchiv verpacken. Möglich ist auch die Ablage in einem Quellcodeverwaltungssystem wie SVN. Jedes Projekt enthält die Information, mit welcher CODESYS Version es erstellt wurde. Wenn Sie es in einer anderen Version öffnen, weist CODESYS auf mögliche oder nötige Aktualisierungen bezüglich Speicherformat, Bibliotheksversionen etc. hin. Sie können Projekte vergleichen, exportieren, importieren und eine Dokumentation dazu erzeugen lassen. Sie können ein Projekt gegen Veränderung und komplett, auch gegen Lesen schützen. Durch das Verwenden einer Benutzerverwaltung können Sie den Zugriff auf das Projekt und sogar auf einzelne Objekte im Projekt gezielt steuern. Für weitere Informationen siehe: Projekt schützen und speichern" }, 
{ "title" : "Standardprojekt anlegen ", 
"url" : "_cds_creating_standard_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ Standardprojekt anlegen ", 
"snippet" : "Wählen Sie den Befehl Datei → Neues Projekt und dann die Vorlage Projekte → Standardprojekt . Geben Sie einen Namen, beispielsweise myProject , und einen Ablageort im Dateisystem ein. Der Dialog Standardprojekt erscheint. Wählen Sie aus der Liste bei Geräte eines der Standardgeräte CODESYS Control W...", 
"body" : "Wählen Sie den Befehl Datei → Neues Projekt und dann die Vorlage Projekte → Standardprojekt . Geben Sie einen Namen, beispielsweise myProject , und einen Ablageort im Dateisystem ein. Der Dialog Standardprojekt erscheint. Wählen Sie aus der Liste bei Geräte eines der Standardgeräte CODESYS Control Win und bei PLC_PRG in die Option Strukturierter Text (ST) . Klicken Sie dann OK . In der Titelleiste des Programmiersystem-Hauptfensters erscheint der Projektname myProject . Im Gerätebaum ( Devices ) ist folgende Struktur angelegt: Je nach ausgewählter SPS können auch noch zusätzliche Geräteknoten erscheinen. Die SPS erscheint immer automatisch mit einem Unterknoten SPS-Logik ( PLC Logic ). Die Basisobjekte darunter sind: eine Applikation mit einem Bibliotheksverwalter ( Library Manager ) und einer Taskkonfiguration ( Task Configuration ). Die Taskkonfiguration definiert die Haupttask ( MainTask ) für die Abarbeitung des Standardprogrammbausteins PLC_PRG . Der Bibliotheksverwalter enthält bereits die Standard.library mit Basisbausteinen wie Zählern, Timern, Stringfunktionen, die nachher zur Programmierung verwendet werden können. Wenn Sie nun PLC_PRG mit fehlerfreiem Code füllen, können Sie diesen, ohne weitere Programmierobjekte zu benötigen, auf die Steuerung laden und zur Ausführung bringen. Ab SP13 ist für ein neu angelegtes Standardprojekt automatisch die Projekteinstellung Integritätsprüfung in Projekt → Projekteinstellungen → Sicherheit aktiviert. Ausführliche Informationen, wie Sie Ihr Projekt schützen können, finden Sie im Kapitel „Projekt schützen und speichern“. Für weitere Informationen siehe: Ihr erstes CODESYS-Programm " }, 
{ "title" : "Objekte hinzufügen ", 
"url" : "_cds_adding_objects.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ Objekte hinzufügen ", 
"snippet" : "Voraussetzung: Ein Projekt ist geöffnet. Mindestens der oberste Knoten <Projektname> in der Ansicht Geräte („Gerätebaum“) und in der Ansicht POUs existiert. Die folgende Anleitung zeigt einige Möglichkeiten beim Anlegen von Objekten im Projekt. Selektieren Sie einen Eintrag im Gerätebaum oder im POU...", 
"body" : "Voraussetzung: Ein Projekt ist geöffnet. Mindestens der oberste Knoten <Projektname> in der Ansicht Geräte („Gerätebaum“) und in der Ansicht POUs existiert. Die folgende Anleitung zeigt einige Möglichkeiten beim Anlegen von Objekten im Projekt. Selektieren Sie einen Eintrag im Gerätebaum oder im POUs-Baum, beispielsweise das Objekt Application . Wählen Sie Befehl Projekt → Objekt hinzufügen . Abhängig vom ausgewählten Eintrag im Baum bietet CODESYS die passenden Objekte zur Auswahl an. Wählen Sie beispielsweise das Objekt POU und im daraufhin erscheinenden Dialog POU hinzufügen den Typ Programm mit Implementierungssprache Strukturierter Text (ST) und Namen „ prog \". Nach Klicken auf Hinzufügen fügt CODESYS ein Programm-Objekt prog im Gerätebaum unterhalb von Application ein. Selektieren Sie ein Objekt im Baum und wählen im Kontextmenü den Befehl Eigenschaften . Der Dialog Eigenschaften erscheint mit den objektrelevanten Kategorien. Wenn Sie eine Benutzerverwaltung verwenden, könnten Sie hier beispielsweise den Zugriff auf das Objekt einschränken. Selektieren Sie einen Eintrag im Baum, unterhalb dessen Sie einen Ordner anlegen möchten, um in ihm bestimmte Objekte zu sammeln. Hinweis: Die Anordnung der Geräteknoten und Geräteobjekte können Sie nicht durch selbst angelegte Ordner strukturieren. Wählen Sie im Kontextmenü den Befehl Ordner hinzufügen und definieren im erscheinenden Dialog einen Namen für den neuen Ordner. Klicken Sie OK . Der Ordner erscheint im Baum. Selektieren Sie ein Objekt im Baum und verschieben Sie es durch Ziehen mit der Maus innerhalb des Baums an eine andere Position, beispielsweise in den Ordner. Selektieren Sie kein Objekt im Gerätebaum, sondern setzen Sie den Fokus an eine beliebige freie Position in der CODESYS Oberfläche. Wählen Sie Befehl Projekt → Objekt hinzufügen und dann beispielsweise das Objekt Textliste . Das Objekt Textliste wird in der Ansicht POUs eingefügt. " }, 
{ "title" : "Compilerversion ändern ", 
"url" : "_cds_changing_compiler_version.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ Compilerversion ändern ", 
"snippet" : "Die Version des Compilers, mit der im aktuellen Projekt Code für die Verwendung auf dem Zielgerät erzeugt wird, ist in den Projekteinstellungen definiert. Die Compileversion ist unabhängig von der CODESYS -Version. Also wird bei gleicher eingestellter Compilerversion aus dem Quellcode konstanter App...", 
"body" : "Die Version des Compilers, mit der im aktuellen Projekt Code für die Verwendung auf dem Zielgerät erzeugt wird, ist in den Projekteinstellungen definiert. Die Compileversion ist unabhängig von der CODESYS -Version. Also wird bei gleicher eingestellter Compilerversion aus dem Quellcode konstanter Applikationscode erzeugt, auch wenn dies aus unterschiedlichen CODESYS -Versionen heraus erfolgt. Achten Sie auf die Einstellung Nicht aktualisieren in der Registerkarte Compilerversion des Dialogs Projektumgebung : Wenn diese aktiviert ist und Sie ein älteres Projekt öffnen, für das noch die Compilerversion Neueste eingestellt ist, dann verwendet CODESYS weiterhin die zuletzt im alten Projekt eingesetzte Compilerversion. Dies gilt auch, wenn in der neuen Umgebung eine andere „aktuelle“ Version definiert ist! Wenn Sie ein Projekt öffnen, in dem nicht die neueste Compilerversion eingestellt ist, erscheint der Dialog Projektumgebung mit einem entsprechenden Hinweis und der Möglichkeit, direkt zu aktualisieren. Voraussetzung: Ein Projekt ist geöffnet. Wählen Sie Befehl Projekt → Projekteinstellungen und dann Registerkarte Compiler-Optionen . Wählen Sie die gewünschte Feste Version und klicken OK . Die Änderung ist sofort wirksam. Für weitere Informationen siehe: Applikationscode erzeugen" }, 
{ "title" : "V3 -Projekt öffnen ", 
"url" : "_cds_opening_project_v3.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ V3 -Projekt öffnen ", 
"snippet" : "Sie können Projekte, Bibliotheksprojekte oder Projektarchive in CODESYS öffnen, die mit unterschiedlichen Installationen erstellt wurden. Beim Öffnen eines Projekts wird automatisch geprüft, ob die aktive Installation geeignet ist (Versionen, installierte Add-ons), um das Projekt zu laden. Sie werde...", 
"body" : "Sie können Projekte, Bibliotheksprojekte oder Projektarchive in CODESYS öffnen, die mit unterschiedlichen Installationen erstellt wurden. Beim Öffnen eines Projekts wird automatisch geprüft, ob die aktive Installation geeignet ist (Versionen, installierte Add-ons), um das Projekt zu laden. Sie werden von einem Assistenten durch die Projektprüfung und die möglichen Maßnahmen im Fall einer nicht passender Installation geleitet. Grundsätzlich sind folgende Aktionen möglich: Aktualisierung von vorhandenen Add-ons und Installation von fehlenden Add-ons Starten einer anderen Installation, die für das Projekt geeignet ist Installieren einer weiteren CODESYS -Version mit geeignetem Stand " }, 
{ "title" : "Projekt laden, das zuletzt mit einer passenden Installation (Versionen, Add-ons) gespeichert wurde ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_a6d2d494801711eba011b160aaf68d97", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ V3 -Projekt öffnen \/ Projekt laden, das zuletzt mit einer passenden Installation (Versionen, Add-ons) gespeichert wurde ", 
"snippet" : "Voraussetzung: Auf Ihrem Entwicklungssystem befinden sich CODESYS -Projekte, die mit gleicher oder ähnlicher Installation gesichert wurden. Wählen Sie den Befehl Datei → Projekt öffnen . Der Dialog Projekt öffnen öffnet sich zur Auswahl einer Datei aus dem Dateisystem Ihres Entwicklungssystems. Setz...", 
"body" : "Voraussetzung: Auf Ihrem Entwicklungssystem befinden sich CODESYS -Projekte, die mit gleicher oder ähnlicher Installation gesichert wurden. Wählen Sie den Befehl Datei → Projekt öffnen . Der Dialog Projekt öffnen öffnet sich zur Auswahl einer Datei aus dem Dateisystem Ihres Entwicklungssystems. Setzen Sie den Dateifilter und wählen Sie im Dialog Projekt öffnen das gewünschte Projekt, Projektarchiv oder Bibliotheksprojekt aus. Bestätigen Sie den Dialog mit OK . Das Projekt wird geladen und in der Ansicht Gerätebaum dargestellt. " }, 
{ "title" : "Projekt laden, das zuletzt mit einer nicht passenden Installation (Versionen, Add-ons) gespeichert wurde ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_8aa0891b801411eba011b160aaf68d97", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ V3 -Projekt öffnen \/ Projekt laden, das zuletzt mit einer nicht passenden Installation (Versionen, Add-ons) gespeichert wurde ", 
"snippet" : "In diesem Fall leitet der Assistent Projektprüfung durch die möglichen Behandlungen. Öffnen Sie in Ihrer aktuellen CODESYS -Installation ein Projekt, das zuletzt mit einer anderen Installation (andere Version und\/oder mehr Add-ons) gespeichert wurde. CODESYS unterbricht den Ladevorgang und bietet Ih...", 
"body" : "In diesem Fall leitet der Assistent Projektprüfung durch die möglichen Behandlungen. Öffnen Sie in Ihrer aktuellen CODESYS -Installation ein Projekt, das zuletzt mit einer anderen Installation (andere Version und\/oder mehr Add-ons) gespeichert wurde. CODESYS unterbricht den Ladevorgang und bietet Ihnen im Assistenten der Projektprüfung (Dialog Projektprüfung - Überblick ) Informationen und passende Optionen an, um ein Laden zu ermöglichen. Wenn das Projekt mit CODESYS Version 3.5.19.0 oder neuer gespeichert wurde, erhalten Sie die Schaltfläche Details zum Öffnen des Dialogs Unterschiede . Hier sehen Sie, welche Add-ons beim Speichern des Projekts installiert waren und ob und wie diese in der aktuellen Installation verfügbar sind. Wählen Sie eine der beiden grundlegenden Optionen: Option 1: Dieses Projekt befindet sich noch in einer Entwicklungsphase. Ich möchte es in dieser Version öffnen und habe nichts dagegen, dass ein anderer Code generiert wird. Sie laden das Projekt mit der nicht passenden Version und nehmen geänderten Code oder Verluste wegen fehlender Komponenten in Kauf. Dies kann bei Projekten, die noch in der Entwicklungsphase sind, eine akzeptable Option sein. Option 2: Dieses Projekt wurde bereits auf einer Maschine\/Anlage eingesetzt. Ich möchte genau denselben Code generieren und benötige daher die Möglichkeit, mich ohne Änderungen anzumelden. Diese Option ist nötig, wenn sich der Code des Projekts auf keinen Fall ändern darf. Der Assistent soll für eine passende Installation sorgen. Der Assistent sucht deshalb zunächst auf dem Computer nach bereits vorhandenen passenden anderen Installationen. Wenn er passende Installationen findet, können Sie eine davon auswählen und anstelle der gerade geöffneten Installation starten. Wenn der Assistent keine passende Installation findet, bietet er an, den Download und die Ausführung eines passenden Setups zu veranlassen. Die erforderlichen und optionalen Add-ons werden aufgelistet. Sie können den Download entsprechend konfigurieren und dann durch den CODESYS Installer ausführen lassen. Wenn Sie Option 1 wählen: Nach Weiter erhalten Sie noch die Möglichkeit, fehlende Add-ons für die Bearbeitung aller Objekte des Projekts nachinstallieren zu lassen. In diesem Fall prüft der Assistent, ob die nötigen Add-on-Setups verfügbar sind und startet im nächsten Schritt den CODESYS Installer . Wenn Sie das Projekt ohne diese Nachinstallation öffnen, können die durch fehlende Add-ons betroffenen Objekte nicht bearbeitet werden. In der Statuszeile des Projekts wird die Anzahl der fehlenden Add-ons angezeigt. Wenn Sie Option 2 wählen: Nach Weiter erhalten Sie den Dialog Projektprüfung - Auswahl . Der Assistent zeigt unter Andere Installation verwenden verfügbare andere Installationen auf dem Computer, die für die Weiterverwendung des Projekts geeignet sind. Wenn keine geeigneten Installationen gefunden werden, gibt es die Alternative Download und Setup einer neuen Installation . Für beide Möglichkeiten können Sie im weiteren Schritt den CODESYS Installer die nötigen Installationen ausführen lassen. Für weitere Informationen siehe: Projekt öffnen" }, 
{ "title" : "Schreibgeschütztes Projekt laden ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_d7efcbbf801411eba011b160aaf68d97", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ V3 -Projekt öffnen \/ Schreibgeschütztes Projekt laden ", 
"snippet" : "Sie können außerdem schreibgeschützte Projekte laden und lesen. Erst beim Speichern müssen Sie einen geeigneten Speicherort angeben, an dem Sie über die nötigen Schreibrechte verfügen....", 
"body" : "Sie können außerdem schreibgeschützte Projekte laden und lesen. Erst beim Speichern müssen Sie einen geeigneten Speicherort angeben, an dem Sie über die nötigen Schreibrechte verfügen. " }, 
{ "title" : "Projekt mit Zugangsbeschränkung laden ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_43f091b9801511eba011b160aaf68d97", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ V3 -Projekt öffnen \/ Projekt mit Zugangsbeschränkung laden ", 
"snippet" : "Sie können zugangsbeschränkte Projekte nur laden, wenn Sie über die Zugangsdaten wie Benutzer und Passwort verfügen....", 
"body" : "Sie können zugangsbeschränkte Projekte nur laden, wenn Sie über die Zugangsdaten wie Benutzer und Passwort verfügen. " }, 
{ "title" : "Projekt mit Dongle laden ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_364abf3a125f0850c0a864632cca4d5c", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ V3 -Projekt öffnen \/ Projekt mit Dongle laden ", 
"snippet" : "Sie haben ein Projekt ausgewählt, das mit einem Dongle geschützt ist. Wenn der Dongle nicht am Computer steckt, erhalten Sie die Aufforderung, ihn aufzustecken, ansonsten öffnet CODESYS das Projekt ohne Hinweise auf den Schutz....", 
"body" : "Sie haben ein Projekt ausgewählt, das mit einem Dongle geschützt ist. Wenn der Dongle nicht am Computer steckt, erhalten Sie die Aufforderung, ihn aufzustecken, ansonsten öffnet CODESYS das Projekt ohne Hinweise auf den Schutz. " }, 
{ "title" : "Sicherungskopie eine Projekts laden ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_8a9d06a8801411eba011b160aaf68d97", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ V3 -Projekt öffnen \/ Sicherungskopie eine Projekts laden ", 
"snippet" : "Sicherungskopien werden erstellt, wenn die Projektoption Automatisch Speichern aktiviert ist. Wenn nach einer Änderung sich CODESYS nicht regulär beendet wird das Projekt als Sicherungskopie gesichert. Wenn Sie ein Projekt ausgewählt haben, öffnet sich beim Laden zunächst der Dialog Auto Save Backup...", 
"body" : "Sicherungskopien werden erstellt, wenn die Projektoption Automatisch Speichern aktiviert ist. Wenn nach einer Änderung sich CODESYS nicht regulär beendet wird das Projekt als Sicherungskopie gesichert. Wenn Sie ein Projekt ausgewählt haben, öffnet sich beim Laden zunächst der Dialog Auto Save Backup . Dort können Sie die Sicherungskopie handhaben. " }, 
{ "title" : "Projektumgebung aktualisieren ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_8a9a6e94801411eba011b160aaf68d97", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ V3 -Projekt öffnen \/ Projektumgebung aktualisieren ", 
"snippet" : "Der Dialog Projektumgebung öffnet sich, wenn eine neuere Compilerversion, Visualisierungsprofil und SoftMotion-Version zur Verfügung steht. Der Dialog informiert Sie über den aktuellen Stand und bietet Optionen zur Aktualisierung an. Beispielsweise erhalten Sie bei Projekten, die mit sehr alten V3 -...", 
"body" : "Der Dialog Projektumgebung öffnet sich, wenn eine neuere Compilerversion, Visualisierungsprofil und SoftMotion-Version zur Verfügung steht. Der Dialog informiert Sie über den aktuellen Stand und bietet Optionen zur Aktualisierung an. Beispielsweise erhalten Sie bei Projekten, die mit sehr alten V3 -Versionen erstellt wurden, erhalten Sie Hinweise, wie Sie bestimmte Objekte ersetzen müssen, um das Projekt weiter verwenden zu können. Je nachdem, ob Sie das Projekt belassen wollen, wie es ist, oder ob sie es unter möglichst aktuellen Bedingungen weiterentwickeln wollen, führen Sie die Aktualisierungen durch oder nicht. Eine Aktualisierung der Projektumgebung bewirkt, dass ein Einloggen nur mit Download oder mit Online-Change ausgeführt werden kann. Für weitere Informationen siehe: Laden und speichern und Projekt öffnen" }, 
{ "title" : "V2.3-Projekt öffnen ", 
"url" : "_cds_opening_project_v23.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ V2.3-Projekt öffnen ", 
"snippet" : "Ein CoDeSys V2.3 -Projekt kann nur mit einer 32-Bit-Version von CODESYS V3 - konvertiert werden. Dazu muss in CODESYS V3 das Package CODESYS V2.3 Converter installiert sein. Das Package ist im CODESYS Store International erhältlich. Sollten Sie mit einer 64-Bit-Version von CODESYS V3 arbeiten, müsse...", 
"body" : "Ein CoDeSys V2.3 -Projekt kann nur mit einer 32-Bit-Version von CODESYS V3 - konvertiert werden. Dazu muss in CODESYS V3 das Package CODESYS V2.3 Converter installiert sein. Das Package ist im CODESYS Store International erhältlich. Sollten Sie mit einer 64-Bit-Version von CODESYS V3 arbeiten, müssen sie für die Konvertierung zusätzlich die 32-Bit-Version installieren. Nach der Konvertierung können Sie das Projekt in CODESYS 64-Bit öffnen. Voraussetzung: Sie haben CODESYS V3 installiert und gestartet. Das Add-On CODESYS V2.3 Converter ist installiert. Wählen Sie Befehl Datei → Projekt öffnen . Wählen Sie im Dialog Projekt öffnen das gewünschte CoDeSys V2.3 -Projekt oder Projektarchiv aus dem Dateisystem. Zur Suche können Sie den Dateifilter in der rechten unteren Ecke des Dialogs setzen. Falls noch ein anderes Projekt geöffnet ist, leitet CODESYS Sie entsprechend zum Schließen an. Danach startet automatisch der CoDeSys V2.3 -Konverter. Der V2.3-Konverter prüft, ob das Projekt fehlerfrei kompilierbar ist. Wenn ja, bearbeitet er das Projekt automatisch. HINWEIS: Wenn das Projekt Visualisierungsobjekte mit Platzhaltervariablen enthält, die der Konverter nicht auflösen kann, erfolgt ein direktes Einbinden der jeweiligen Visualisierungen als Gruppierung an Stelle der Visualisierungsreferenzen. Gerätekonvertierung: Wenn im zu öffnenden Projekt ein Gerät (Zielsystem) referenziert ist, für das noch keine Konvertierungsregel definiert ist, erscheint der Dialog Gerätekonvertierung . Legen Sie hier fest, ob und wie der Konverter die bisherige Geräte-Referenz durch eine aktuelle ersetzen soll. Bei Ersetzung fügt der Konverter das neue Gerät anstelle des alten im Gerätebaum des konvertierten Projekts ein. Bibliothekskonvertierung: Wenn im zu öffnenden Projekt eine Bibliothek referenziert ist, für die noch keine Konvertierungsregel definiert ist, erscheint der Dialog Konvertierung einer Bibliotheksreferenz . Legen Sie hier fest, ob und wie der Konverter die bisherige Bibliotheksreferenz durch eine aktuelle ersetzen soll. Falls Sie dabei eine Bibliothek auswählen, für die Projektinformationen fehlen, erscheint der Dialog Projektinformationen eingeben , den Sie ausfüllen müssen. Der Konverter lädt das angepasste Projekt. Hinweis: Die neu definierten Bibliotheksreferenzen finden sich im globalen Bibliotheksverwalter in der POUs-Ansicht. " }, 
{ "title" : "Einschränkungen beim Weiterverwenden eines CoDeSys V2.3 -Projekts in CODESYS ", 
"url" : "_cds_opening_project_v23.html#UUID-4e701e8c-8cef-c597-c237-6d5f8cdd2ba8_id_cd2852f2ff014e88c0a8640e006c37ac_id_1347abe6017bb94ac0a8640e0130ddc2", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ V2.3-Projekt öffnen \/ Einschränkungen beim Weiterverwenden eines CoDeSys V2.3 -Projekts in CODESYS ", 
"snippet" : "Kompilierung Das Projekt muss ohne Übersetzungsfehler in CoDeSys V2.3 kompilierbar sein. Hinweis: Dennoch gibt CODESYS bei der Übersetzung in V3 Warnungen aus. Diese werden durch implizite Konvertierungen hervorgerufen, die zu Informationsverlust führen können (beispielsweise durch Vorzeichenwechsel...", 
"body" : "Kompilierung Das Projekt muss ohne Übersetzungsfehler in CoDeSys V2.3 kompilierbar sein. Hinweis: Dennoch gibt CODESYS bei der Übersetzung in V3 Warnungen aus. Diese werden durch implizite Konvertierungen hervorgerufen, die zu Informationsverlust führen können (beispielsweise durch Vorzeichenwechsel). CODESYS V3 prüft „case“-Anweisungen gegen die Switch-Variable: CASE USINT OF INT wird in CoDeSys V2.3 nicht überprüft, es gibt jedoch eine Fehlermeldung beim Import in V3 . Steuerungskonfiguration Die Steuerungskonfiguration eines CoDeSys V2.3 -Projekts ist nicht in V3 importierbar. Sie müssen die Gerätekonfiguration neu erstellen und die in der Steuerungskonfiguration verwendeten Variablen erneut deklarieren. Netzwerkvariablen Für Netzwerkvariablen erzeugt CODESYS V3 GVL-Objekte und importiert die Variablendeklarationen. Die Netzwerkeigenschaften werden jedoch nicht importiert! Sehen Sie hierzu die Beschreibung zum Netzwerkvariablen-Austausch. Bibliotheken Alle Variablen und Konstanten, die in einer Bibliothek verwendet werden, müssen auch in dieser Bibliothek deklariert sein. Die Bibliothek muss in CoDeSys V2.3 fehlerfrei übersetzbar sein. Syntaktische und semantische Einschränkungen seit CoDeSys V2.3 FUNCTIONBLOCK ist nicht länger ein gültiges Schlüsselwort anstelle von FUNCTION_BLOCK . Nach TYPE (Deklaration einer Struktur) muss ein “:” folgen. ARRAY -Initialisierung muss mit runden Klammern versehen sein. INI wird nicht mehr unterstützt (Sie müssen dies im Code durch die Init-Methode ersetzen). In Funktionsaufrufen ist es nicht länger möglich, explizite Parameterzuweisungen mit impliziten zu mischen. Deshalb kann die Reihenfolge der Parametereingangs-Zuweisungen verändert werden: fun(formal1 := actual1, actual2); \/\/ -> Fehlermeldung fun(formal2 := actual2, formal1 := actual1); \/\/ gleiche Semantik wie folgende Zeile: fun(formal1 := actual1, formal2 := actual2); CoDeSys V2.3 -Pragmas werden nicht konvertiert. Sie erzeugen in V3 eine Warnung. Der TRUNC -Operator konvertiert nun in den Datentyp DINT , anstelle von INT ; bei einem CoDeSys V2.3 -Import fügt CODESYS automatisch eine entsprechende Typkonvertierung hinzu. Visualisierung Platzhalter und deren Ersetzung Platzhalter: PLC_PRG.$LocalVar$.aArr[0] VAR_INPUT: localVar: MyStruct; Verwendung: localVar.aArr[0] Ersetzung: localVar := PLC_PRG.myStructVar Platzhalter: $Var$.aArr[0] VAR_INPUT: Var : MyStruct; Verwendung: Var.aArr[0] Ersetzung: Var := PLC_PRG.myStructVar Platzhalter: PLC_PRG.myStructVar.aArr[$Index$] VAR_INPUT: Index : INT; Verwendung: PLC_PRG.myStructVar.aArr[Index] Ersetzung: Index := 0 Problematische Platzhalter Platzhalter innerhalb eines Textes Text: $axle$-Axis Behebung: localVar : STRING; Text: %s-Axis TextVariable: localVar Platzhalter beschreibt nur einen Teil eines Variablennamens axis$axis$spur$spur$.fActPosition Behebung: Definieren Sie für den Platzhalter axis$axis$spur$spur$ nur einen Platzhalter. axis_spur : MyFunctionBlock; Übergeben Sie dann direkt die entsprechende Instanz des Funktionsbausteins. axis_spur := PLC_PRG.axis1spur2; Platzhalter wird durch einen Ausdruck ersetzt $Expression$ -> PLC_PRG.var1 + PLC_PRG.var2 Behebung: Sie müssen den Ausdruck an eine Hilfsvariable übergeben und diese Hilfsvariable dann als Instanz übergeben. Platzhalter beschreibt einen Programmnamen: $Program$.bToggle -> PLC_PRG.bToggle D Diese Form der Platzhalterersetzung kann der Konverter nicht in V3 übertragen. Sie werden sie in der Praxis aber selten verwenden. Platzhalter wird durch verschiedene Typen ersetzt: $Var$ -> Ersetzung 1 : PLC_PRG.n (INT) -> Ersetzung 2 : PLC_PRG.st (STRING) Behebung: Definieren Sie hierfür zwei verschiedene Platzhalter in der Schnittstelle. Die Visualisierung liegt in einer Bibliothek. Sie ersetzen die Platzhalter erst später aus einem beliebigen Projekt, wenn Sie die Visualisierung dort verwenden. Behebung: Hier müssen Sie die TYPE_NONE -Datentypen manuell ersetzen. Es gibt aber auch die Möglichkeit, dass Sie die Bibliothek in ein Projekt einbinden und der Platzhalter richtig ersetzt wird. Wenn Sie nun dieses Projekt importieren, dann wird der Datentyp auch in der Bibliothek richtig ermittelt. Nicht importierbare Elemente Trend, ActiveX - Der Import ist nicht möglich, weil die Implementierung sehr unterschiedlich ist. In V3 wird eine entsprechende Warnung ausgegeben und ein entsprechender manueller Nachbau ist nötig. Programmiersprachen ST, AWL, FUP Keine Einschränkungen Programmiersprache KOP CODESYS importiert Funktionsbausteine mit Parallelverzweigungen so, dass der Teil vor der Verzweigung für jeden Zweig wiederholt wird. Das entspricht dem generierten Code, den CoDeSys V2.3 für Parallelverzweigungen erzeugt. Programmiersprachen AS Explizit vom Anwender deklarierte Schrittvariablen müssen lokal im AS-Editor deklariert werden. Sie dürfen sie nicht als VAR_INPUT, VAR_OUTPUT oder VAR_INOUT deklarieren, da CODESYS die Aufrufe nicht automatisch angepassen kann. Erklärung: Schritte verwenden zur Verwaltung der internen Zustände in V3 keine booleschen Variablen mehr, sondern auch Strukturen vom Typ SFCStepType . Kennzeichner: Nicht mit einem Unterstrich beginnen dürfen folgende Kennzeichner: Namen von IEC-Aktionen im Baum Variablen, die in einer IEC-Assoziationsliste aufgerufen werden Namen von ausprogrammierten Transitionen Erklärung: In V3 erhalten die impliziten Variablen, welche CODESYS für Aktionen anlegt, einen Unterstrich als Präfix. Es würde ein ungültiger Kennzeichner mit doppeltem Unterstrich entstehen. Programmiersprachen CFC Große Bausteine: Das Layout großer Bausteine kann durch den Import an Qualität verlieren; Die Baustein-Boxen überlappen sich möglicherweise stark. (Behebung geplant.) Makros: Makros können nicht importiert werden. (Behebung geplant.) " }, 
{ "title" : "Projekt konfigurieren ", 
"url" : "_cds_struct_configuring_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ Projekt konfigurieren ", 
"snippet" : "Sie können Ihr CODESYS -Projekt in den folgenden Dialogen konfigurieren: Projekteinstellungen : Allgemeine Einstellungen zum Verhalten von Editoren, zum Compiler, zur Benutzerverwaltung usw. Projektinformationen : Ausstatten des Projekts mit individuellen kennzeichnenden Informationen Projektumgebun...", 
"body" : "Sie können Ihr CODESYS -Projekt in den folgenden Dialogen konfigurieren: Projekteinstellungen : Allgemeine Einstellungen zum Verhalten von Editoren, zum Compiler, zur Benutzerverwaltung usw. Projektinformationen : Ausstatten des Projekts mit individuellen kennzeichnenden Informationen Projektumgebung : Definieren, welche Versionen der externen und internen Module verwendet werden sollen, mit dem Ziel, dass sie aktuell und zueinander kompatibel sind " }, 
{ "title" : "Projektinformation abfragen und bearbeiten ", 
"url" : "_cds_querying_and_editing_project_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ Projekt konfigurieren \/ Projektinformation abfragen und bearbeiten ", 
"snippet" : "Sie können Informationen, die Ihr Projekt und die dazugehörige Datei betreffen, mit Hilfe des Objekts Projektinformationen abfragen und bestimmte Informationen bearbeiten. Das Objekt enthält Informationen über Dateiattribute Metainformationen wie Anbieterfirma, Titel oder Autor Eigenschaften mit Sch...", 
"body" : "Sie können Informationen, die Ihr Projekt und die dazugehörige Datei betreffen, mit Hilfe des Objekts Projektinformationen abfragen und bestimmte Informationen bearbeiten. Das Objekt enthält Informationen über Dateiattribute Metainformationen wie Anbieterfirma, Titel oder Autor Eigenschaften mit Schlüssel Statistik Lizenzierung Signieren: Diese Möglichkeit des Signierens von übersetzten Bibliotheken ist veraltet und sollte aus Sicherheitsgründen nur verwendet werden, wenn eine Kompatibilität mit älteren Versionen erforderlich ist. Wenn diese Methode verwendet wird, kann später mit Hilfe eines öffentlichen Public-Key-Token überprüft werden, ob die Bibliothek zuletzt vom Bibliotheksanbieter signiert wurde. Stellen Sie als Bibliotheksanbieter deshalb dem Kunden den verwendeten öffentlichen Schlüssel unbedingt zur Verfügung, beispielsweise in der Dokumentation. CODESYS speichert die Projektinformationen als Objekt direkt im Projekt. Wenn Sie dann ein Projekt auf ein anderes System übertragen, wird auch das Objekt Projektinformation mit übertragen, ohne dass dafür ein Projektarchiv benötigt wird. Sie können mit Hilfe von Eigenschaftenschlüsseln über Funktionsbausteine von extern auf die Projektinformationen zugreifen. Wenn es sich um ein Bibliotheksprojekt handelt, können Sie zusätzlich Informationen zur Lizenzierung abfragen. " }, 
{ "title" : "Metainformation bearbeiten ", 
"url" : "_cds_querying_and_editing_project_information.html#UUID-597f8ad3-4a38-643c-f948-f1540f9dff94_id_c567cbe2bd6ab5ac0a8640e00176406_id_a57d0cffe98711e48c1bfcee0714ea73", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ Projekt konfigurieren \/ Projektinformation abfragen und bearbeiten \/ Metainformation bearbeiten ", 
"snippet" : "Wählen Sie Projekt → Projektinformation . Der Dialog Projektinformationen öffnet sich. Wählen Sie Registerkarte Zusammenfassung . Geben Sie in den Eingabefelder Ihre Daten ein, zum Beispiel 0.0.0.1 im Eingabefeld Version . CODESYS erstellt für jeden eingegebenen Wert eine Eigenschaft mit Schlüssel u...", 
"body" : "Wählen Sie Projekt → Projektinformation . Der Dialog Projektinformationen öffnet sich. Wählen Sie Registerkarte Zusammenfassung . Geben Sie in den Eingabefelder Ihre Daten ein, zum Beispiel 0.0.0.1 im Eingabefeld Version . CODESYS erstellt für jeden eingegebenen Wert eine Eigenschaft mit Schlüssel und verwaltet sie unter der Registerkarte Eigenschaft . Wenn es sich um ein Bibliotheksprojekt handelt, verwendet CODESYS die Eigenschaften weiter und sortiert im Bibliotheksrepository danach. Wenn Sie aktivieren, dass CODESYS für diese Eigenschaften jeweils einen Funktionsbaustein erstellt, können Sie auf die Eigenschaften programmatisch zugreifen. " }, 
{ "title" : "Funktionen für Eigenschaftenzugriff erstellen ", 
"url" : "_cds_querying_and_editing_project_information.html#UUID-597f8ad3-4a38-643c-f948-f1540f9dff94_id_c567cbe2bd6ab5ac0a8640e00176406_id_036ad17de80511e4ab86a4571214df94", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ Projekt konfigurieren \/ Projektinformation abfragen und bearbeiten \/ Funktionen für Eigenschaftenzugriff erstellen ", 
"snippet" : "Wählen Sie Projekt → Projektinformation . Der Dialog Projektinformationen öffnet sich. Aktivieren Sie die Option Automatisch ‚Projektinformationen‘-POUs erzeugen . Beispiel Voraussetzung: Die folgende Eigenschaft ist definiert. Schlüssel = nProp1 Typ= Zahl Wert= 333 Aktivieren Sie die Option Automat...", 
"body" : "Wählen Sie Projekt → Projektinformation . Der Dialog Projektinformationen öffnet sich. Aktivieren Sie die Option Automatisch ‚Projektinformationen‘-POUs erzeugen . Beispiel Voraussetzung: Die folgende Eigenschaft ist definiert. Schlüssel = nProp1\nTyp= Zahl\nWert= 333 Aktivieren Sie die Option Automatisch ‚Projektinformationen‘-POUs erzeugen . Deklarieren Sie eine Variable des Typs DINT . Beispiel: showprop : DINT; Rufen Sie die Funktion GetNumberProperty auf: showprop := GetNumberProperty(\"nProp1\"); Sie erhalten Zugriff auf den Wert in der Applikation. Hinweis: Die mit der Option Automatisch ‚Projektinformationen‘-POUs erzeugen erzeugten Funktionen können nur verwendet werden, wenn das Laufzeitsystem den Datentyp WSTRING unterstützt! Wenn dies nicht der Fall ist, können Sie alternativ die Option Automatisch ‚Bibliotheksinformationen‘-POUs erzeugen verwenden: Die damit erzeugten Funktionen können Sie zumindest in der Applikation für den Eigenschaftenzugriff verwenden. Im Laufzeitsystem sind diese Funktionen nicht registriert! " }, 
{ "title" : "Bibliotheksprojekt lizenzieren ", 
"url" : "_cds_querying_and_editing_project_information.html#UUID-597f8ad3-4a38-643c-f948-f1540f9dff94_id_c567cbe2bd6ab5ac0a8640e00176406_id_cded5ad3e81111e4ab86a4571214df94", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ Projekt konfigurieren \/ Projektinformation abfragen und bearbeiten \/ Bibliotheksprojekt lizenzieren ", 
"snippet" : "Wenn Ihr Projekt ein Bibliotheksprojekt ist, können Sie hier die Lizenzierung der Bibliothek bei Verwendung aktivieren. Als Dongle kommt ein „ CODESYS Security Key“ zum Einsatz. Voraussetzung: Das Projekt ist ein Bibliotheksprojekt. Wählen Sie Projekt → Projektinformationen . Der Dialog Projektinfor...", 
"body" : "Wenn Ihr Projekt ein Bibliotheksprojekt ist, können Sie hier die Lizenzierung der Bibliothek bei Verwendung aktivieren. Als Dongle kommt ein „ CODESYS Security Key“ zum Einsatz. Voraussetzung: Das Projekt ist ein Bibliotheksprojekt. Wählen Sie Projekt → Projektinformationen . Der Dialog Projektinformationen öffnet sich. Wählen Sie Registerkarte Lizenzierung . Aktivieren Sie die Option Dongle-Lizenzierung aktivieren . Geben Sie die Daten des Dongles in Firmcode , Produktcode , Aktivierungs-URL und Aktivierungs-Mail an. Die Bibliothek ist lizenziert. " }, 
{ "title" : "Veraltet: Bibliotheksprojekt signieren - Nur noch für Versionskompatibilität mit CODESYS < 3.5 SP15 - Ab Version CODESYS V3 SP17 nur für bestehende Bibliotheken mit der veralteten Signierung, die im Dialog Projektinformationen - Signieren erstellt wurde ", 
"url" : "_cds_querying_and_editing_project_information.html#UUID-597f8ad3-4a38-643c-f948-f1540f9dff94_id_c567cbe2bd6ab5ac0a8640e00176406_id_4f7ee481fe1211e49fce83667d100c0a", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ Projekt konfigurieren \/ Projektinformation abfragen und bearbeiten \/ Veraltet: Bibliotheksprojekt signieren - Nur noch für Versionskompatibilität mit CODESYS < 3.5 SP15 - Ab Version CODESYS V3 SP17 nur für bestehende Bibliotheken mit der veralteten Signierung, die im Dialog Projektinformationen - Signieren erstellt wurde ", 
"snippet" : "Ab CODESYS V3 SP15 erfolgt eine Bibliothekssignierung immer zertifikatsbasiert. Sehen Sie zur Durchführung einer solchen Signierung die Hilfeseite zum Befehl Projekt als übersetzte Bibliothek speichern . Im Unterschied zur veralteten Signierung über die Einstellungen im Dialog Projektinformationen -...", 
"body" : "Ab CODESYS V3 SP15 erfolgt eine Bibliothekssignierung immer zertifikatsbasiert. Sehen Sie zur Durchführung einer solchen Signierung die Hilfeseite zum Befehl Projekt als übersetzte Bibliothek speichern . Im Unterschied zur veralteten Signierung über die Einstellungen im Dialog Projektinformationen - Signieren wird mit dem Zertifikat die gesamte Bibliothek signiert. Falls Sie aus Kompatibilitätsgründen ein Bibliotheksprojekt noch für eine CODESYS -Version < V3 SP15 signieren müssen, gehen Sie wie folgt vor: Voraussetzung: Ihnen steht eine private Schlüsseldatei mit einem zugehörigen Token zur Verfügung. In den Projektinformationen des Bibliotheksprojekts ist auf der Registerkarte Zusammenfassung eine Bibliothekskompatibilität mit einer CODESYS -Version < V3 SP15 eingestellt. Wählen Sie Projekt → Projektinformationen . Der Dialog Projektinformationen öffnet sich. Wählen Sie Registerkarte Signieren . Aktivieren Sie die Option Signieren aktivieren . Geben Sie den Speicherort Ihrer privaten Schlüsseldatei an. CODESYS trägt den Token automatisch in Token des öffentlichen Schlüssels ein. Beispiel: 427A5701DA3CF3CF Wählen Sie Datei → Projekt als übersetzte Bibliothek speichern . Das Bibliotheksprojekt wird als Datei mit der Erweiterung *.compiled-library abgelegt. Sie sehen das Token im Bibliotheksrepository oder Bibliotheksverwalter in den Details zur Bibliothek und können es mit dem veröffentlichten Token des Bibliothekanbeiters vergleichen. Sie überprüfen somit, ob die Bibliothek tatsächlich vom gewünschten Anbieter stammt. " }, 
{ "title" : "Private Schlüsseldatei erstellen ", 
"url" : "_cds_querying_and_editing_project_information.html#UUID-597f8ad3-4a38-643c-f948-f1540f9dff94_id_c567cbe2bd6ab5ac0a8640e00176406_id_62a1c2fde5fb82e1c0a8640e0154acb5", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ Projekt konfigurieren \/ Projektinformation abfragen und bearbeiten \/ Private Schlüsseldatei erstellen ", 
"snippet" : "Wählen Sie Projekt → Projektinformationen . Wählen Sie die Registerkarte Signieren . Wählen Sie die Schaltfläche Private Schlüsseldatei erzeugen . Der Dialog Private Schlüsseldatei erstellen erscheint. Wählen Sie einen sicheren Ablageort, zum Beispiel D:\\for lib developers only\\mycomp_libkey.libpk u...", 
"body" : "Wählen Sie Projekt → Projektinformationen . Wählen Sie die Registerkarte Signieren . Wählen Sie die Schaltfläche Private Schlüsseldatei erzeugen . Der Dialog Private Schlüsseldatei erstellen erscheint. Wählen Sie einen sicheren Ablageort, zum Beispiel D:\\for lib developers only\\mycomp_libkey.libpk und beenden Sie den Dialog mit Speichern . " }, 
{ "title" : "Projekteinstellungen vornehmen ", 
"url" : "_cds_struct_setting_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt anlegen und konfigurieren \/ Projekt konfigurieren \/ Projekteinstellungen vornehmen ", 
"snippet" : "Sie können Einstellungen, die das Verhalten von CODESYS und das bestimmter Editoren betreffen, im Objekt Projekteinstellungen konfigurieren. Die Einstellungen gelten projektweit und werden für aktive Editoren sofort angewendet. Sie erreichen die Dialoge des Objekts auch mit dem Befehl Projekt → Proj...", 
"body" : "Sie können Einstellungen, die das Verhalten von CODESYS und das bestimmter Editoren betreffen, im Objekt Projekteinstellungen konfigurieren. Die Einstellungen gelten projektweit und werden für aktive Editoren sofort angewendet. Sie erreichen die Dialoge des Objekts auch mit dem Befehl Projekt → Projekteinstellungen . CODESYS speichert die Projekteinstellungen als Objekt direkt im Projekt. Wenn Sie dann ein Projekt auf ein anderes System übertragen, wird auch das Objekt Projekteinstellungen mit übertragen, ohne dass dafür ein Projektarchiv benötigt wird. " }, 
{ "title" : "Projekt exportieren und transferieren ", 
"url" : "_cds_struct_project_export_transfer.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt exportieren und transferieren ", 
"snippet" : "Für den Austausch der Daten von CODESYS -Projekten mit anderen Programmen stehen Ihnen Export- und Importfunktionen zur Verfügung. Ein Austausch von CODESYS -Projekten zwischen CODESYS -Entwicklungssystemen erfolgt durch eine Kopie der Projektdatei (*.project) oder des Projektarchivs (*.projectarchi...", 
"body" : "Für den Austausch der Daten von CODESYS -Projekten mit anderen Programmen stehen Ihnen Export- und Importfunktionen zur Verfügung. Ein Austausch von CODESYS -Projekten zwischen CODESYS -Entwicklungssystemen erfolgt durch eine Kopie der Projektdatei (*.project) oder des Projektarchivs (*.projectarchive). " }, 
{ "title" : "Projekt exportieren und importieren ", 
"url" : "_cds_project_export_import.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt exportieren und transferieren \/ Projekt exportieren und importieren ", 
"snippet" : "CODESYS bietet Befehle zum Exportieren und Importieren von Objekten in eine oder aus einer Datei. Hier stehen Ihnen zwei Möglichkeiten zur Verfügung: Export in oder Import aus eine(r) CODESYS -XML-Datei (*.export) Dieses Format ist vollständig kompatibel zum CODESYS -Projektformat. Die Objekte werde...", 
"body" : "CODESYS bietet Befehle zum Exportieren und Importieren von Objekten in eine oder aus einer Datei. Hier stehen Ihnen zwei Möglichkeiten zur Verfügung: Export in oder Import aus eine(r) CODESYS -XML-Datei (*.export) Dieses Format ist vollständig kompatibel zum CODESYS -Projektformat. Die Objekte werden in einem maschinenlesbaren XML-Format abgelegt. Export in oder Import aus eine(r) XML-Datei im PLCopen-Format (*.xml) Sie können dieses Format verwenden, um Informationen mit anderen Programmen (zum Beispiel Programmeditoren oder Dokumentationstool) auszutauschen. PLCopen XML definiert eine Untermenge der in CODESYS bekannten Elemente. Eine 100% Kompatibilität ist somit nicht sichergestellt. " }, 
{ "title" : "Exportieren eines Projekts ", 
"url" : "_cds_project_export_import.html#UUID-4276a4a2-07e1-df8e-2521-15e4d85eb49f_id_a282cbda3e76d3c0a8640e001b04d0_id_6b64e742dada2534c0a8640e0069c11e", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt exportieren und transferieren \/ Projekt exportieren und importieren \/ Exportieren eines Projekts ", 
"snippet" : "Voraussetzung: Ein Projekt ist in CODESYS geöffnet. Wählen Sie den Befehl Projekt -> Exportieren oder Projekt -> PLCopenXML exportieren . Wählen Sie im Dialog Exportieren oder PLCopenXML exportieren die Objekte aus, die sie exportieren wollen. Klicken Sie OK . Geben Sie den Dateinamen und den Speich...", 
"body" : "Voraussetzung: Ein Projekt ist in CODESYS geöffnet. Wählen Sie den Befehl Projekt -> Exportieren oder Projekt -> PLCopenXML exportieren . Wählen Sie im Dialog Exportieren oder PLCopenXML exportieren die Objekte aus, die sie exportieren wollen. Klicken Sie OK . Geben Sie den Dateinamen und den Speicherort an und klicken Sie Speichern . " }, 
{ "title" : "Importieren eines Projekts ", 
"url" : "_cds_project_export_import.html#UUID-4276a4a2-07e1-df8e-2521-15e4d85eb49f_id_a282cbda3e76d3c0a8640e001b04d0_id_243afeac184815f7c0a8640e00616fed", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt exportieren und transferieren \/ Projekt exportieren und importieren \/ Importieren eines Projekts ", 
"snippet" : "Voraussetzung: Ein Projekt ist in CODESYS geöffnet. Wählen Sie den Befehl Projekt -> Importieren oder Projekt -> PLCopenXML importieren . Wählen Sie im Dialog Importieren oder PLCopenXML importieren die Exportdatei aus, die Sie importieren wollen. Ein Dialog öffnet sich und zeigt die Objekte in eine...", 
"body" : "Voraussetzung: Ein Projekt ist in CODESYS geöffnet. Wählen Sie den Befehl Projekt -> Importieren oder Projekt -> PLCopenXML importieren . Wählen Sie im Dialog Importieren oder PLCopenXML importieren die Exportdatei aus, die Sie importieren wollen. Ein Dialog öffnet sich und zeigt die Objekte in einer Baumstruktur an, die an dieser Stelle eingefügt werden können. Selektieren Sie das Objekt im Objektbaum, unter dem die zu importierenden Objekte eingefügt werden sollen. Wählen Sie die Objekte aus und klicken Sie auf OK . Die Objekte werden zum bestehenden Objektbaum hinzugefügt. Für weitere Informationen siehe: PLCopenXML" }, 
{ "title" : "Projekt transferieren ", 
"url" : "_cds_project_transfer.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt exportieren und transferieren \/ Projekt transferieren ", 
"snippet" : "Wenn Sie ein Projekt auf einen anderen Rechner übertragen und von dort zur selben SPS verbinden wollen, ohne dass ein Online-Change oder Download erforderlich ist, beachten Sie folgende Punkte. Stellen Sie sicher, dass das Projekt nur feste Versionen von Bibliotheken (Ausnahme: Interface-Bibliotheke...", 
"body" : "Wenn Sie ein Projekt auf einen anderen Rechner übertragen und von dort zur selben SPS verbinden wollen, ohne dass ein Online-Change oder Download erforderlich ist, beachten Sie folgende Punkte. Stellen Sie sicher, dass das Projekt nur feste Versionen von Bibliotheken (Ausnahme: Interface-Bibliotheken), Visualisierungsprofil und Compiler verlangt. Stellen Sie sicher, dass die Bootapplikation aktuell ist. Erzeugen Sie dann ein Projektarchiv, das Sie auf dem anderen Rechner entpacken. " }, 
{ "title" : "Übertragen eines Projekts auf anderes System ", 
"url" : "_cds_project_transfer.html#UUID-ed2bc292-0880-13a7-2fde-3d254ec1acb6_id_a747b06714334ffc0a8640e011c1820_id_3621759901828743c0a8640e00ee49c5", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt exportieren und transferieren \/ Projekt transferieren \/ Übertragen eines Projekts auf anderes System ", 
"snippet" : "Voraussetzung: Auf Rechner „PC1“ ist ein Projekt geöffnet, das Sie auf einen anderen Rechner „PC2“ transferieren und von dort wieder mit der selben Steuerung verbinden. Stellen Sie sicher, dass nur Bibliotheken mit festen Versionen im Projekt eingebunden sind, mit Ausnahme reiner Schnittstellenbibli...", 
"body" : "Voraussetzung: Auf Rechner „PC1“ ist ein Projekt geöffnet, das Sie auf einen anderen Rechner „PC2“ transferieren und von dort wieder mit der selben Steuerung verbinden. Stellen Sie sicher, dass nur Bibliotheken mit festen Versionen im Projekt eingebunden sind, mit Ausnahme reiner Schnittstellenbibliotheken. Öffnen Sie dazu den Bibliotheksverwalter und prüfen Sie alle Einträge, die ein „*“ anstelle einer festen Versionsangabe haben. Ab Compilerversion 3.5.18.0 wird das Bibliotheksprofil für die Auflösung von Platzhaltern ignoriert. Die im Profil enthaltenen Bibliotheken werden automatisch zu freien Platzhaltern. Die Option, das Bibliotheksprofil mit ins Projektarchiv aufzunehmen, ist nicht mehr verfügbar. Stellen Sie sicher, dass eine feste Compilerversion in den Projekteinstellungen gesetzt ist. Zur Prüfung wählen Sie Projekt → Projekteinstellungen und Kategorie Compileroption . Stellen Sie sicher, dass ein festes Visualisierungsprofil in den Projekteinstellungen definiert ist. Zur Prüfung wählen Sie Projekt → Projekteinstellungen und Kategorie Visualisierungsprofil . Stellen Sie sicher, dass die Applikation, die gerade geöffnet ist, die gleiche ist wie die, die gerade auf der SPS verwendet wird. Das heißt, die „Bootapplikation“ muss identisch sein mit dem Projekt im Programmiersystem. Prüfen Sie dazu den Projektnamen in der Titelleiste des Programmiersystemfensters: Wenn ein Sternchen hinter dem Namen angezeigt wird, wurde das Projekt geändert, aber noch nicht gespeichert. Dann stimmen möglicherweise Applikation und Bootapplikation nicht überein! Erzeugen Sie in diesem Fall zuerst eine (neue) Bootapplikation. Es hängt von der SPS und den Applikationseigenschaften ab, ob dies automatisch beim Laden (Download) der Applikation geschieht. Zum expliziten Erzeugen wählen Sie Befehl Online → Bootapplikation erzeugen . Führen Sie dann einen Download mit Hilfe der Befehle Online → Einloggen und Online → Laden durch. Starten Sie danach mit Befehl Debug → Start die Applikation auf der Steuerung. Nun läuft die gewünschte Applikation auf der SPS, zu der Sie sich später auf PC2 vom selben Projekt aus wieder verbinden möchten. Erzeugen Sie ein Projektarchiv: Wählen Sie Datei → Projektarchiv → Archiv speichern\/versenden . Im Dialog Projektarchiv wählen Sie auch die folgenden Informationen mit aus: Download-Informationsdateien Bibliotheksprofil (nicht mehr ab Compilerversion 3.5.18.0) Referenzierte Geräte Referenzierte Bibliotheken Visualisierungsprofil Speichern Sie das Projektarchiv an einem von PC2 zugänglichen Ort. Loggen Sie aus der Steuerung aus: Wählen Sie dazu Online → Ausloggen . Sie können die SPS ohne Bedenken stoppen und neu starten, bevor Sie von PC2 erneut verbinden. Extrahieren Sie das Projektarchiv auf PC2: Wählen Sie Datei → Projektarchiv → Archiv extrahieren , und öffnen Sie das oben gespeicherte Archiv. Aktivieren Sie im Dialog Projektarchiv extrahieren die gleichen Informationen wie oben beim Erzeugen des Archivs beschrieben. Öffnen Sie das Projekt und loggen Sie sich wieder auf SPS „xy“ ein. CODESYS fordert keinen Online-Change oder Download, das Projekt läuft. " }, 
{ "title" : "Projekt vergleichen ", 
"url" : "_cds_struct_project_comparison.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt vergleichen ", 
"snippet" : "Sie können das geöffnete aktuelle Projekt mit einem anderen, so genannten Referenzprojekt vergleichen. Unterschiede bezüglich Inhalten, Eigenschaften oder Zugriffsrechten werden ermittelt und in einer Vergleichsansicht dargestellt. Mit dem Befehl Projekt → Vergleichen öffnet sich der Dialog Projektv...", 
"body" : "Sie können das geöffnete aktuelle Projekt mit einem anderen, so genannten Referenzprojekt vergleichen. Unterschiede bezüglich Inhalten, Eigenschaften oder Zugriffsrechten werden ermittelt und in einer Vergleichsansicht dargestellt. Mit dem Befehl Projekt → Vergleichen öffnet sich der Dialog Projektvergleich , in dem Sie den Vergleich konfigurieren und anstoßen können. Daraufhin wird das Ergebnis in der Vergleichsansicht Projektvergleich - Unterschiede dargestellt, in der sich die Objekte in einer Baumstruktur gegenüberstehen. Objekte, die Unterschiede zum jeweiligen Referenzobjekt aufweisen, sind farblich und mit Symbolen gekennzeichnet. Daran erkennen Sie, ob Inhalte, Eigenschaften oder Zugriffsrechte unterschiedlich sind. Bei inhaltlichen Unterschieden können Sie zusätzlich die Detailvergleichsansicht Projektvergleich - <Objektname> Unterschiede öffnen, um in das Objekt zu zoomen. In der Detailvergleichsansicht wird der Quellcode des Objekts dem des Referenzobjekts gegenübergestellt. Ermittelte Unterschiede werden gekennzeichnet. Zuvor geöffnete Ansichten werden nicht geschlossen. So können Sie, neben der Projektvergleichsansicht, beliebig viele Vergleichsansichten auf Objektebene geöffnet haben und sie lesen. Zur Auflösung der ermittelten Unterschiede können Sie entscheiden, ob der Stand aus dem Referenzprojekt ins aktuelle Projekt übernommen werden soll. Eine Übernahme vom aktuellen Projekt ins Referenzprojekt ist nicht möglich. Die Übernahme aktivieren Sie in der aktiven Vergleichsansicht beispielsweise unterschiedliche Codezeilen oder -blöcke mit den Befehlen , oder . Diese Stellen werden dann gelb hinterlegt. Beachten Sie, dass damit alle anderen eventuell geöffneten Vergleichsansichten inaktiv (schreibgeschützt, nur noch lesbar) werden. Sie können also nur in genau einer Vergleichsansicht Unterschiede für eine Übernahme aktivieren. Wenn es vom Editor unterstützt wird, können Sie eine dritte Vergleichsansicht dazuschalten. In dieser dritten Ansicht wird das Ergebnis der Auflösungsaktionen für die Unterschiede dargestellt. Wenn Sie beim Verlassen der aktiven Vergleichsansicht bestätigen, dass die für eine Übernahme aktivierten Unterschiede ins aktuelle Projekt übernommen werden, wird das aktuelle Projekt geändert. Um den Projektvergleich insgesamt zu beenden, schließen Sie die Projektvergleichsansicht. " }, 
{ "title" : "Vergleichsansicht erstellen ", 
"url" : "_cds_creating_project_differences.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt vergleichen \/ Vergleichsansicht erstellen ", 
"snippet" : "Voraussetzung: Sie haben in Ihrem aktuellen Projekt Änderungen vorgenommen und möchten es beispielsweise mit der zuletzt gespeicherten Version vergleichen. Sie haben mittlerweile beispielsweise weitere Programmierbausteine eingefügt, eine POU entfernt, in Bausteinen einige Codezeilen oder die Objekt...", 
"body" : "Voraussetzung: Sie haben in Ihrem aktuellen Projekt Änderungen vorgenommen und möchten es beispielsweise mit der zuletzt gespeicherten Version vergleichen. Sie haben mittlerweile beispielsweise weitere Programmierbausteine eingefügt, eine POU entfernt, in Bausteinen einige Codezeilen oder die Objekteigenschaften geändert. Wählen Sie Befehl Projekt → Vergleichen Der Dialog Projektvergleich erscheint. Geben Sie den Pfad des Referenzprojekts an, beispielsweise den Pfad der zuletzt gespeicherten Version Ihres aktuellen Projekts. Belassen Sie die Aktivierung der Vergleichsoption Leerzeichen ignorieren . Klicken Sie OK . CODESYS öffnet die Vergleichsansicht. Titel: Projektvergleich - Unterschiede Die Gerätebäume des aktuellen Projekts und des Referenzprojekts sind einander gegenübergestellt und die veränderten Objekte farblich markiert. Selektieren Sie im Baum des Referenzprojekts (rechts) ein blau markiertes Objekt. Dieses Objekt ist im aktuellen Projekt nicht mehr enthalten. Klicken Sie auf Einzeln übernehmen . CODESYS fügt das Objekt im Baum des aktuellen Projekts (links) hinzu. Die Zeile ist gelb hinterlegt. In der Mittelspalte erscheint . Selektieren Sie im Baum des aktuellen Projekts (links) ein grün markiertes Objekt. Dieses Objekt ist im Referenzprojekt nicht enthalten. Klicken Sie auf Einzeln übernehmen . CODESYS entfernt das Objekt wieder aus dem Baum des aktuellen Projekts (links). Die Zeile ist gelb hinterlegt. In der Mittelspalte erscheint . Wenn CODESYS für ein Objekt, das im aktuellen Projekt und im Referenzprojekt enthalten ist, inhaltliche Änderungen festgestellt hat, wird dies durch rote Schrift angezeigt. Sie können dann durch Doppelklick auf das Objekt in die Detailvergleichsansicht des Objekts wechseln. Schließen Sie die Vergleichsansicht und beantworten Sie die Frage, ob die vorgenommenen Änderungen gespeichert werden sollen, mit Ja . Die Änderungen werden im Projekt wirksam. Für weitere Informationen siehe: Detailvergleichsansicht öffnen" }, 
{ "title" : "Detailvergleichsansicht öffnen ", 
"url" : "_cds_creating_editing_detail_differences.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt vergleichen \/ Detailvergleichsansicht öffnen ", 
"snippet" : "Voraussetzung: Beispielsweise wurde von einem Anwender der Code in einer POU des aktuellen Projekts geändert. Sie haben nun den Projektvergleich über Befehl Projekt → Vergleichen durchgeführt. Die Projektvergleichsansicht zeigt diese POU in den gegenübergestellten Projektbäumen von aktuellem Projekt...", 
"body" : "Voraussetzung: Beispielsweise wurde von einem Anwender der Code in einer POU des aktuellen Projekts geändert. Sie haben nun den Projektvergleich über Befehl Projekt → Vergleichen durchgeführt. Die Projektvergleichsansicht zeigt diese POU in den gegenübergestellten Projektbäumen von aktuellem Projekt und Referenzprojekt rot markiert. Doppelklicken Sie auf die Zeile der gegenübergestellten POU-Versionen. Die Vergleichsansicht wechselt zur Detailvergleichsansicht der POU. Die geänderten Codezeilen sind grau hinterlegt und rot geschrieben. Klicken Sie auf . Codezeilen mit Änderung (rot) werden erweitert auf 2 Zeilen dargestellt: eine Zeile mit Einfügung (links, grün) und eine zweite Zeile mit Löschung (rechts, blau). Klicken Sie erneut auf . Die Codezeile ist wieder als geändert gekennzeichnet. Stellen Sie den Mauszeiger in die als geändert gekennzeichnete Codezeile und klicken Sie auf Einzeln übernehmen . Die Codezeile aus dem Referenzprojekt wird für die Übernahme ins aktuelle Projekt aktiviert. Klicken Sie, wenn verfügbar, auf , um ein drittes Teilfenster hinzuzufügen. Unterhalb der zwei Teilfenster, die den Code des aktuellen Objekts und des Referenzobjekts einander gegenüberstellen, erscheint ein drittes Teilfenster. In diesem wird das Ergebnis der Aktionen dargestellt, die Sie zur Auflösung der Unterschiede zwischen aktuellem und Referenzobjekt vornehmen. Für diese Aktionen stehen weitere Schaltflächen in der Taskleiste der Detailvergleichsansicht zur Verfügung. Für weitere Informationen siehe: Ansicht: Projektvergleich - <Objektname> Unterschiede. Klicken Sie auf . Die Projektvergleichsansicht des gesamten Projekts erscheint. Sie ist nun schreibgeschützt (lesbar), so dass Sie dort nicht Unterschiede für eine Übernahme aktivieren können. Darauf weist auch der gelb markierte Link oberhalb der Baumansicht hin. Klicken Sie auf den Link Die Projektvergleichsansicht ist schreibgeschützt, weil es unbestätigte Änderungen in einer anderen Ansicht gibt. Klicken Sie hier, um zur geänderten Ansicht umzuschalten. . Die Detailsvergleichsansicht erscheint wieder. Die nicht bestätigten Änderungen sind gelb unterlegt. Klicken Sie im Reiter der Ansicht auf und bestätigen Sie, dass die Änderungen zu speichern sind. Die Detailprojektansicht ist geschlossen und die POU überschrieben. Sie entspricht nun der POU des Referenzprojekts. Die Projektansicht ist wieder aktiv, so dass Sie weiter im Projektvergleich arbeiten können. Wenn Sie nicht auf den Link (Schritt 7) klicken und statt dessen mit Klick auf den Editor der Projektvergleichsansicht schließen, können Sie ebenfalls die Übernahme der Änderungen ins aktuelle Projekt bestätigen. Die Detailänderungen werden übernommen und dann der Projektvergleich insgesamt geschlossen. Für weitere Informationen siehe: Vergleichsansicht erstellen" }, 
{ "title" : "Projekt schützen und speichern ", 
"url" : "_cds_struct_project_protection_storage.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt schützen und speichern ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Projektschutz ", 
"url" : "_cds_struct_project_protection_storage.html#UUID-d82983fe-0a1b-1735-b6e6-87e3d8fe682b_section-idm234759364725429", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt schützen und speichern \/ Projektschutz ", 
"snippet" : "Zum Projektschutz sehen Sie bitte die Hilfeseiten unter: Quellcode schützen...", 
"body" : "Zum Projektschutz sehen Sie bitte die Hilfeseiten unter: Quellcode schützen " }, 
{ "title" : "Ablage, Speichern ", 
"url" : "_cds_struct_project_protection_storage.html#UUID-d82983fe-0a1b-1735-b6e6-87e3d8fe682b_section-idm4654689522251232654637501867", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt schützen und speichern \/ Ablage, Speichern ", 
"snippet" : "Versehen Sie die Projektdatei vor dem Speichern im Dateisystem mit dem gewünschten Schutz, siehe oben. Für eine schreibgeschützte Projektdatei erhalten Sie je nach Art des Schreibschutzes verschiedene Optionen, die Datei dennoch zu speichern. Wenn das Projekt später in einer älteren CODESYS -Version...", 
"body" : "Versehen Sie die Projektdatei vor dem Speichern im Dateisystem mit dem gewünschten Schutz, siehe oben. Für eine schreibgeschützte Projektdatei erhalten Sie je nach Art des Schreibschutzes verschiedene Optionen, die Datei dennoch zu speichern. Wenn das Projekt später in einer älteren CODESYS -Version geöffnet werden soll, ist es sinnvoll, das Projekt genau für diese Version (Dateityp) zu speichern, da CODESYS Sie im Zuge dieser Speicherung auch sofort über eventuelle Datenverluste informiert. Wenn Sie Bibliotheksprojekte speichern möchten, beachten Sie die Regeln zur Erstellung von Bibliotheken . Erwägen Sie auch die Möglichkeit, eine Bibliothek direkt in ein Bibliotheksrepository zu installieren. Wenn Sie ein Projekt auf einem anderen Computer weiter verwenden möchten, ist es sinnvoll, nicht nur die Projektdatei zu speichern, sondern ein Projektarchiv aus allen relevanten Zusatzdateien zu erstellen. Sie können einstellen, dass bei jedem Speichern des Projekts zusätzlich eine Sicherungskopie dieses Projekts angelegt wird. Außerdem können Sie konfigurieren, dass Projekte generell in bestimmten Zeitintervallen automatisch gespeichert werden. Für weitere Informationen siehe: Laden und speichernWenn Sie Projekte in einer Quellcodeverwaltung halten möchten, beachten Sie die entsprechenden Add-Ons für CODESYS . Beispielsweise wird die Anbindung an SVN unterstützt. " }, 
{ "title" : "Projekt speichern ", 
"url" : "_cds_saving_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt schützen und speichern \/ Projekt speichern ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Projekt unter gleichem Namen speichern ", 
"url" : "_cds_saving_project.html#UUID-1bc9d9ae-6670-3dc0-ea69-bcf82769aa81_id_dcaaa6487a164c0a8640e003a1189_id_1d675998b906498cc0a8640e01be26b4", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt schützen und speichern \/ Projekt speichern \/ Projekt unter gleichem Namen speichern ", 
"snippet" : "Voraussetzung: Das Projekt ist geöffnet. Es besteht kein Schreibschutz für die Projektdatei. Wählen Sie Datei → Projekt speichern . CODESYS speichert die Projektdatei mit dem aktuellen Projektnamen, der in der Titelleiste des Hauptfensters steht. Falls das Projekt seit dem letzten Speichern geändert...", 
"body" : "Voraussetzung: Das Projekt ist geöffnet. Es besteht kein Schreibschutz für die Projektdatei. Wählen Sie Datei → Projekt speichern . CODESYS speichert die Projektdatei mit dem aktuellen Projektnamen, der in der Titelleiste des Hauptfensters steht. Falls das Projekt seit dem letzten Speichern geändert wurde, ist der Projektname mit einem Sternchen versehen. Wenn es in den CODESYS -Optionen in Kategorie Laden und Speichern so eingestellt ist, wird auch eine Sicherungskopie erstellt. Speicherformat Das Speicherformat eines Projekts ist das Profil des CODESYS Development System , mit dem das Projekt nach dem Erstellen oder einer späteren Änderung gespeichert wird. Dieses Profil enthält die Versionsinformation aller Plug-ins dieser CODESYS -Installation und damit auch aller Add-Ons die in genau dieser CODESYS -Installation enthalten sind. Wenn ein Projekt mit dem Befehl Projekt speichern gespeichert wird, wird das Speicherformat nicht automatisch aktualisiert. Das Speicherformat wird nur in folgenden Fällen aktualisiert: Sie speichern ein Projekt mit dem Befehl Projekt speichern unter und Sie wählen dabei als Dateityp ein anderes Speicherformat aus. Ein Projekt ist in einer CODESYS -Installation geöffnet, die ein anderes Speicherformat hat als das Projekt: Wenn dann beim Bearbeiten dieses Projekts der Dialog erscheint Möchten Sie das Speicherformat des Projekts auf <Speicherformat> aktualisieren , Sie diesen Dialog mit Ja beantworten und das Projekt anschließend mit dem Befehl Projekt speichern abspeichern. Das Speicherformat eines Projekt wird angezeigt in Projekt → Projektinformationen , Registerkarte Datei . " }, 
{ "title" : "Projekt unter anderem Namen oder Speicherformat speichern ", 
"url" : "_cds_saving_project.html#UUID-1bc9d9ae-6670-3dc0-ea69-bcf82769aa81_id_dcaaa6487a164c0a8640e003a1189_id_e0e08580b906498dc0a8640e00285d64", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt schützen und speichern \/ Projekt speichern \/ Projekt unter anderem Namen oder Speicherformat speichern ", 
"snippet" : "Voraussetzung: Das Projekt ist geöffnet. Wählen Sie Datei → Projekt speichern unter . Der Dialog Projekt speichern erscheint. Wählen Sie einen Ablageort im Dateisystem und den gewünschten Dateityp (Projektdatei oder Bibliotheksdatei) und die gewünschte Speicherversion. Wenn Sie das Projekt später in...", 
"body" : "Voraussetzung: Das Projekt ist geöffnet. Wählen Sie Datei → Projekt speichern unter . Der Dialog Projekt speichern erscheint. Wählen Sie einen Ablageort im Dateisystem und den gewünschten Dateityp (Projektdatei oder Bibliotheksdatei) und die gewünschte Speicherversion. Wenn Sie das Projekt später in einer älteren Version öffnen möchten, ist es sinnvoll genau für diese Version zu speichern, da dann im Meldungsfenster sofort über eventuelle Datenverluste informiert wird. Wenn die Projektdatei keinem Schreibschutz unterliegt, speichert CODESYS sie im ausgewählten Pfad. Andernfalls erhalten Sie Hinweise, wie weiter zu verfahren ist. Wenn das aktuelle Projekt Add-ons enthält, die in dem gewünschten Speicherformat nicht enthalten sind, öffnet sich der Dialog Profil erweitern . Wählen Sie die Add-ons aus, um die Sie das Speicherformat erweitern wollen, damit die Daten des Add-ons auch gespeichert werden. Wenn Sie das Speicherformat dauerhaft speichern möchten, klicken Sie auf Profil speichern und geben Sie im Dialog Profilname eingeben den gewünschten Namen ein. Wählen Sie im Dialog Profil erweitern die Option Gespeichertes Profil verwenden und bestätigen Sie den Dialog mit Ja . CODESYS speichert das Projekt mit dem gespeicherten Profil und damit auch dem neuen Speicherformat. Das neue Speicherformat wird in Projekt → Projektinformationen , Registerkarte Datei angezeigt. " }, 
{ "title" : "Schreibgeschütztes Projekt speichern ", 
"url" : "_cds_saving_project.html#UUID-1bc9d9ae-6670-3dc0-ea69-bcf82769aa81_id_dcaaa6487a164c0a8640e003a1189_id_00663280b906498fc0a8640e01c6ebb3", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt schützen und speichern \/ Projekt speichern \/ Schreibgeschütztes Projekt speichern ", 
"snippet" : "Voraussetzung: Ein schreibgeschütztes Projekt ist geöffnet. Wählen Sie Datei → Projekt speichern . Wenn der Schreibschutz in CODESYS vergeben wurde, wird er durch eine Zeile in der oberen rechten Ecke des Hauptfensters angezeigt. Abhängig von der aktuellen Situation erhalten Sie eine oder mehrere de...", 
"body" : "Voraussetzung: Ein schreibgeschütztes Projekt ist geöffnet. Wählen Sie Datei → Projekt speichern . Wenn der Schreibschutz in CODESYS vergeben wurde, wird er durch eine Zeile in der oberen rechten Ecke des Hauptfensters angezeigt. Abhängig von der aktuellen Situation erhalten Sie eine oder mehrere der folgenden Aktionen zur Auswahl, um das Projekt dennoch speichern zu können: Projekt unter einem anderen Dateinamen auf die Platte speichern : Erscheint immer und führt zum Dialog Projekt speichern wie bei Befehl Projekt speichern unter Schreibschutz-Modus verlassen : Erscheint, wenn beim Öffnen des Projekts die Option Schreibgeschützt öffnen gewählt wurde Schreibschutz-Attribut vom Projekt auf der Platte entfernen : Erscheint, wenn die Projektdatei zum Zeitpunkt des Öffnens im lokalen Dateisystem mit der Eigenschaft „Schreibgeschützt“ versehen war Kennzeichnung „Freigegeben“ in den Projektinformationen entfernen : Erscheint nur, wenn dieses Attribut gerade gesetzt ist Wenn der Schreibschutz außerhalb von CODESYS in den Eigenschaften der Projektdatei im Dateisystem vergeben wurde, erhalten Sie beim Versuch, unter gleichem Namen und Pfad zu speichern folgende Optionen angeboten: Speichern als… : Sie können wie mit Befehl Projekt speichern unter unter anderem Namen speichern. Überschreiben : Der Schreibschutz wird von der Projektdatei entfernt und diese unter dem bestehenden Namen gespeichert. Klicken Sie auf die Zeile in der rechten oberen Ecke des Hauptfensters, die den Schreibschutz anzeigt. Die aktuellen Möglichkeiten, das Projekt dennoch zu speichern, erscheinen in einem Auswahlmenü. Wählen Sie eine der angebotenen Möglichkeiten und führen eventuell nötige Aktionen aus. Wählen Sie den Befehl Datei → Projekt speichern bzw. Datei → Projekt speichern unter . Das Projekt kann gespeichert werden. " }, 
{ "title" : "Projekt automatisch speichern, Sicherungskopie erzeugen lassen ", 
"url" : "_cds_saving_project.html#UUID-1bc9d9ae-6670-3dc0-ea69-bcf82769aa81_id_dcaaa6487a164c0a8640e003a1189_id_87e64193d38533efc0a8640e01f1fc6f", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt schützen und speichern \/ Projekt speichern \/ Projekt automatisch speichern, Sicherungskopie erzeugen lassen ", 
"snippet" : "Voraussetzung: Das Projekt ist geöffnet. Wählen Sie Tools → Optionen , Kategorie Laden und Speichern . Der Dialog Laden und Speichern erscheint. Aktivieren Sie die Option Sicherungskopie erzeugen . Aktivieren die Option Automatisch alle … Minute(e)n speichern und wählen Sie ein Zeitintervall. Schlie...", 
"body" : "Voraussetzung: Das Projekt ist geöffnet. Wählen Sie Tools → Optionen , Kategorie Laden und Speichern . Der Dialog Laden und Speichern erscheint. Aktivieren Sie die Option Sicherungskopie erzeugen . Aktivieren die Option Automatisch alle … Minute(e)n speichern und wählen Sie ein Zeitintervall. Schließen Sie den Dialog Optionen mit OK . Bei jedem Speichern des Projekts erstellt CODESYS zusätzlich eine Sicherungskopie <Projektname>.backup . CODESYS speichert das Projekt automatisch im angegebenen Zeitintervall in eine Datei <Projektname>.autosave im Projektverzeichnis. Wenn Sie das Projekt nach einem nicht-regulären Schließen des Entwicklungssystems erneut öffnen, wird Ihnen diese Datei alternativ zur zuletzt vom Benutzer gespeicherten angeboten. Für weitere Informationen siehe: Dialog 'Optionen - Laden und Speichern' und Projekt schützen und speichern" }, 
{ "title" : "Projektarchiv speichern\/versenden ", 
"url" : "_cds_saving_project_archive.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt schützen und speichern \/ Projektarchiv speichern\/versenden ", 
"snippet" : "Sie können ein Projektarchiv konfigurieren und dann im Dateisystem speichern oder direkt in einer E-Mail versenden. Zum Versenden befolgen Sie die nachstehende Anleitung bis Punkt 9. Dort klicken Sie auf die Schaltfläche Senden statt Speichern , um direkt das Standard-E-Mail-Programm zu öffnen. Auto...", 
"body" : "Sie können ein Projektarchiv konfigurieren und dann im Dateisystem speichern oder direkt in einer E-Mail versenden. Zum Versenden befolgen Sie die nachstehende Anleitung bis Punkt 9. Dort klicken Sie auf die Schaltfläche Senden statt Speichern , um direkt das Standard-E-Mail-Programm zu öffnen. Automatisch wird darin eine neue E-Mail mit dem Projektarchiv-Datei im Anhang angelegt. Voraussetzung: Es ist ein Projekt geöffnet. Wählen Sie Datei → Projektarchiv → Archiv speichern\/versenden . Der Dialog Projektarchiv erscheint. Setzen Sie einen Haken in die Checkbox jeden Objekts, das in das Archiv gespeichert werden soll. Bibliotheken, die ungeschützt, also nicht als „compiled-library“ vorliegen, nimmt CODESYS aus Gründen des Know-how-Schutzes nicht automatisch mit ins Projektarchiv auf. Wenn Sie eine solche Bibliothek in der Liste der aufzunehmenden Informationen dennoch explizit auswählen, erhalten Sie eine entsprechende Warnung. Wenn Sie weitere Dateien ins Archiv packen wollen, klicken Sie auf Zusätzliche Dateien . Es öffnet der Dialog Zusätzliche Dateien . Klicken Sie auf Hinzufügen . Wählen Sie die Dateien aus und klicken Sie auf Öffnen . Die Dateien werden zur Liste der zusätzlichen Dateien hinzugefügt. Klicken Sie OK . Klicken Sie auf Kommentar . Der Dialog Kommentar erscheint. Geben Sie einen Kommentar ein und klicken Sie OK . Klicken Sie auf die Schaltfläche Speichern . Wählen Sie einen Speicherort und einen Dateinamen und klicken Sie auf Speichern . Das Projektarchiv wird im Dateiverzeichnis gespeichert. Für weitere Informationen siehe: Befehl Projekt speichern unter und Projekt speichern" }, 
{ "title" : "Projekt an Quellcode-Verwaltung anbinden ", 
"url" : "_cds_keeping_project_in_sourcecode_management.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt schützen und speichern \/ Projekt an Quellcode-Verwaltung anbinden ", 
"snippet" : "Wenn Sie ihre CODESYS -Projekte mit einem Quellcode-Verwaltungssystem verknüpfen möchten, beachten Sie die folgende Möglichkeit: Das Add-on CODESYS SVN bietet die Möglichkeit der direkten Anbindung an eine SVN-Datenbank. Das Package kann über den CODESYS Store International bezogen und mit Hilfe des...", 
"body" : "Wenn Sie ihre CODESYS -Projekte mit einem Quellcode-Verwaltungssystem verknüpfen möchten, beachten Sie die folgende Möglichkeit: Das Add-on CODESYS SVN bietet die Möglichkeit der direkten Anbindung an eine SVN-Datenbank. Das Package kann über den CODESYS Store International bezogen und mit Hilfe des Package Managers installiert werden. Zur Verwendung von CODESYS SVN beachten Sie bitte die zugehörige Hilfe. " }, 
{ "title" : "Projekt lokalisieren ", 
"url" : "_cds_struct_project_localization.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt lokalisieren ", 
"snippet" : "Sie können Ihr Projekt in unterschiedlichen Landessprachen darstellen, wenn Sie entsprechende Lokalisierungsdateien erstellen und einbinden. Die Lokalisierungsdateien entsprechen denen des GNU gettext -Systems. Die Lokalisierungsvorlagendateien sind also .pot-Dateien (Portable Object Template), aus ...", 
"body" : "Sie können Ihr Projekt in unterschiedlichen Landessprachen darstellen, wenn Sie entsprechende Lokalisierungsdateien erstellen und einbinden. Die Lokalisierungsdateien entsprechen denen des GNU gettext -Systems. Die Lokalisierungsvorlagendateien sind also .pot-Dateien (Portable Object Template), aus denen nach der Übersetzung Lokalisierungsdateien im *.po -Dateien (Portable Object) erzeugt werden. Das Projekt kann in verschiedenen Landessprachen dargestellt werden. Editieren ist jedoch nur in der Originalversion möglich. Sie konfigurieren, welche Kategorien von Textinformationen im Projekt Sie lokalisieren möchten. Dann exportieren Sie diese Texte in eine Übersetzungsvorlage. Diese Vorlage ist eine Datei des Formats pot (beispielsweise project_1.pot ). Mit einem entsprechenden externen Übersetzungstool oder auch händisch mit Hilfe eines einfachen Texteditors erzeugen Sie daraus Lokalisierungsdateien des Formats po (beispielsweise de.po, en.po, es.po ). Die po-Dateien können Sie dann wieder in CODESYS importieren und zur Lokalisierung verwenden. Die Befehle zum Handhaben der Projektlokalisierung finden Sie im Menü Projekt → Projektlokalisierung . Lokalisierung wechseln, Lokalisierungsdateien hinzufügen und entfernen Voraussetzung: Alle gewünschten Landessprachen sind durch Importieren der entsprechenden po -Dateien im Projekt hinterlegt. Das Projekt ist geöffnet. Wählen Sie den Befehl Projekt → Projektlokalisierung → Lokalisierung verwalten . Der Dialog Lokalisierung verwalten öffnet sich. Unter Dateien erscheinen alle hinterlegten Lokalisierungsdateien *-<Sprache>.po , sowie der Eintrag <Originalversion> . Wählen Sie die gewünschte Sprache und klicken auf die Schaltfläche Lokalisierung wechseln . Das Projekt erscheint in der gewählten Sprache. Wenn Sie <Originalversion> gewählt haben, erscheint das Projekt in der nicht-lokalisierten ursprünglichen Fassung und kann wieder editiert werden. Optional eine Standardlokalisierung festlegen, Lokalisierung umschalten Selektieren Sie eine der verfügbaren Lokalisierungen und aktivieren Sie die Option Standardlokalisierung . Mit dem Befehl Projekt → Projektlokalisierng → Lokalisierung umschalten wechseln Sie nun die Lokalisierung immer zwischen der Standardlokalisierung und der Originalversion. Der Befehl ist standardmäßig auch über die Schaltfläche in der Werkzeugleiste verfügbar. Für weitere Informationen siehe: Befehl: Lokalisierung umschalten und Befehl: Lokalisierungen verwalten " }, 
{ "title" : "Lokalisierungsvorlage erzeugen ", 
"url" : "_cds_struct_project_localization.html#UUID-994c8b2e-49d4-9de2-c694-8c1b4b85461a_id_b853c50bc4d5ff73c0a8640e009b2d8a_id_4fc598d1c536a795c0a8640e00012b41", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt lokalisieren \/ Lokalisierungsvorlage erzeugen ", 
"snippet" : "Voraussetzung: Ein Projekt ist geöffnet. Wählen Sie Befehl Projekt → Projektlokalisierung → Lokalisierungsvorlage erstellen . Der Dialog Lokalisierungsvorlage erstellen öffnet sich. Aktivieren Sie die Kategorien von Textinformationen, die Sie in die Lokalisierungsvorlage aufnehmen möchten. Auch Posi...", 
"body" : "Voraussetzung: Ein Projekt ist geöffnet. Wählen Sie Befehl Projekt → Projektlokalisierung → Lokalisierungsvorlage erstellen . Der Dialog Lokalisierungsvorlage erstellen öffnet sich. Aktivieren Sie die Kategorien von Textinformationen, die Sie in die Lokalisierungsvorlage aufnehmen möchten. Auch Positionsinformationen können in die Vorlage mit aufgenommen werden. Sie geben für jeden zu übersetzenden Text an, wo er im Projekt vorliegt. Wählen Sie hier aus, ob nur die erste gefundene Position des Texts, alle gefundenen Positionen oder gar keine in der Übersetzungsvorlage angezeigt werden sollen. Klicken Sie auf die Schaltfläche Erzeugen . Der Dialog zum Speichern einer Datei des Formats pot im Dateisystem öffnet sich. Speichern Sie die Lokalisierungsvorlage. Danach können Sie die Datei in einem entsprechenden Übersetzungstool bearbeiten und Lokalisierungsdateien <Sprache>.po in den gewünschten Sprachen erzeugen. " }, 
{ "title" : "Format der Lokalisierungsvorlage, Datei *.pot ", 
"url" : "_cds_struct_project_localization.html#UUID-994c8b2e-49d4-9de2-c694-8c1b4b85461a_id_b853c50bc4d5ff73c0a8640e009b2d8a_id_653b77f4c56ecbd9c0a8640e01a43f78", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt lokalisieren \/ Format der Lokalisierungsvorlage, Datei *.pot ", 
"snippet" : "In der ersten Zeile ist angegeben, welche Textkategorien beim Erzeugen der Vorlage für die Übersetzung ausgewählt wurden: Beispiel: Alle 4 Kategorien wurden ausgewählt: #: Content:Comments|Identifiers|Names|Strings Danach folgt für jeden zu übersetzenden Text ein Abschnitt in der Form wie im folgend...", 
"body" : "In der ersten Zeile ist angegeben, welche Textkategorien beim Erzeugen der Vorlage für die Übersetzung ausgewählt wurden: Beispiel: Alle 4 Kategorien wurden ausgewählt: #: Content:Comments|Identifiers|Names|Strings Danach folgt für jeden zu übersetzenden Text ein Abschnitt in der Form wie im folgenden Beispiel zu sehen: Beispiel #: D:\\Projects\\p1.project\\Project_Settings:1\nmsgid \"Project Settings\"\nmsgstr \"\" Zeile 1: Positionsinformation als Quellcode-Referenz: Wird nur angezeigt, wenn dies beim Erzeugen der Übersetzungsdatei so konfiguriert wurde. Zeile 2: Unübersetzter Text als Eintrag msgid ; Beispiel: msgid \"Projekteinstellungen\" . Zeile 3: Platzhalter für die Übersetzung: msgstr \"\" . Zwischen den Hochkommas muss dann in der po -Datei die Übersetzung in der jeweiligen Sprache eingefügt werden. " }, 
{ "title" : "Format der Lokalisierungsdatei, Datei *-<Sprache>.po ", 
"url" : "_cds_struct_project_localization.html#UUID-994c8b2e-49d4-9de2-c694-8c1b4b85461a_id_b853c50bc4d5ff73c0a8640e009b2d8a_id_659fed17c536a796c0a8640e017333a5", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt lokalisieren \/ Format der Lokalisierungsdatei, Datei *-<Sprache>.po ", 
"snippet" : "Eine po -Datei können Sie mit Hilfe eines Übersetzungstools oder händisch mit Hilfe eines neutralen Texteditors auf Basis der pot -Datei erzeugen. Sie könnten also die pot -Datei in eine po -Datei umbenennen und entsprechend des po -Standardformats bearbeiten. Geben Sie unbedingt der Landessprache i...", 
"body" : "Eine po -Datei können Sie mit Hilfe eines Übersetzungstools oder händisch mit Hilfe eines neutralen Texteditors auf Basis der pot -Datei erzeugen. Sie könnten also die pot -Datei in eine po -Datei umbenennen und entsprechend des po -Standardformats bearbeiten. Geben Sie unbedingt der Landessprache in Form der üblichen Kulturkürzel in den Metadaten der Datei an, Beispiel: \"Language: de\" für Deutsch. Die Übersetzungen der einzelnen Texte fügen Sie jeweils bei den msgstr \"\" -Einträgen zwischen den Hochkommas ein. Beispiel \"Language: de\\n\"\n#: Content:Names\n#: D:\\projects\\p1.project\\Project_Settings:1\nmsgid \"Project Settings\"\nmsgstr \"Projekteinstellungen\" " }, 
{ "title" : "Importieren der Lokalisierungsdateien, Lokalisieren des Projekts ", 
"url" : "_cds_struct_project_localization.html#UUID-994c8b2e-49d4-9de2-c694-8c1b4b85461a_id_b853c50bc4d5ff73c0a8640e009b2d8a_id_aa02f6d3c536a798c0a8640e01fb3258", 
"breadcrumbs" : "CODESYS Essentials \/ Projekt lokalisieren \/ Importieren der Lokalisierungsdateien, Lokalisieren des Projekts ", 
"snippet" : "Voraussetzung: Für Ihr Projekt wurden auf Basis der Übersetzungsvorlage *.pot Lokalisierungsdateien <Sprache>.po erzeugt. Das Projekt ist geöffnet. Wählen Sie den Befehl Projekt → Projektlokalisierung → Lokalisierungen verwalten . Klicken Sie auf die Schaltfläche Hinzufügen . Der Dialog Lokalisierun...", 
"body" : "Voraussetzung: Für Ihr Projekt wurden auf Basis der Übersetzungsvorlage *.pot Lokalisierungsdateien <Sprache>.po erzeugt. Das Projekt ist geöffnet. Wählen Sie den Befehl Projekt → Projektlokalisierung → Lokalisierungen verwalten . Klicken Sie auf die Schaltfläche Hinzufügen . Der Dialog Lokalisierungsdatei öffnen zum Auswählen einer Datei des Formats po aus dem Dateisystem erscheint. Wählen Sie eine der Lokalisierungsdateien, beispielsweise <Projektname>-de.po . Der Dialog schließt sich und im Projekt erscheinen nun die betroffenen Texte in der entsprechenden Landessprache. Wenn Sie beispielsweise für den Bausteinnamen „PLC_PRG“ in der deutschen Lokalisierungsdatei die Übersetzung msgstr \"Hauptprogramm\" eingetragen haben, erscheint nun im Gerätebaum der Objektname „Hauptprogramm“. Importieren Sie auf gleiche Weise die Lokalisierungsdateien für die anderen Sprachen, in die übersetzt wurde. " }, 
{ "title" : "Projektvorlage erstellen ", 
"url" : "_cds_create_project_template.html", 
"breadcrumbs" : "CODESYS Essentials \/ Projektvorlage erstellen ", 
"snippet" : "Sie können eigene Projektvorlagen erstellen, die beim Erstellen eines neuen Projekts ( *.project oder *.library ) im Dialog Neues Projekt im Bereich Vorlagen ausgewählt werden können. Darüberhinaus können Sie definieren, ob die Projektvorlage in einem der standardmäßig in dem Dialog angezeigten Ordn...", 
"body" : "Sie können eigene Projektvorlagen erstellen, die beim Erstellen eines neuen Projekts ( *.project oder *.library ) im Dialog Neues Projekt im Bereich Vorlagen ausgewählt werden können. Darüberhinaus können Sie definieren, ob die Projektvorlage in einem der standardmäßig in dem Dialog angezeigten Ordner Projekte und Bibliotheken oder in einem selbst erstellten Ordner enthalten sein soll. Diese Ordner werden im Dialog Neues Projekt im Bereich Kategorien angezeigt. Erstellen Sie im CODESYS Development System ein Projekt, das als Vorlage für andere Projekte dienen soll. Speichern Sie das Projekt im Installationsverzeichnis von CODESYS im Ordner Templates . Erstellen Sie in einem Texteditor eine neue Template-Datei <template name>.template . Editieren Sie diese Datei gemäß folgender Beispieldatei: <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<ProjectTemplate>\t\n <Name>\t\n <DefaultString>Test_Project_Template<\/DefaultString>\t\n <LocalizedString Culture=\"de\">Test_Projekttemplate<\/LocalizedString>\t\n <\/Name>\t\n\n <Folder>\t\t\n <DefaultString>Projects<\/DefaultString>\t\t\n <LocalizedString Culture=\"de\">Projekte<\/LocalizedString>\t\n <\/Folder>\t\n\n <Description>\n\t<DefaultString>A project with a GVL<\/DefaultString>\t\n\t<LocalizedString Culture=\"de\">Ein Projekt mit einer GVL<\/LocalizedString>\t\n <\/Description>\t\n\n <DefaultFileName>\t\t\n <DefaultString>Test Project<\/DefaultString>\t\t\n <LocalizedString Culture=\"de\">Testprojekt<\/LocalizedString>\t\n <\/DefaultFileName>\t\n\n <Extension>.project<\/Extension>\t\n <TemplatePath>TemplateTest.project<\/TemplatePath>\n<\/ProjectTemplate> Inhalte der verschiedenen Tags: Name : Name der Projektvorlage, wie er im Dialog Neues Projekt im Bereich Vorlagen angezeigt wird. Folder : Name des Ordners, wo die Projektvorlage abgelegt wird. Wird im Dialog Neues Projekt im Bereich Kategorien angezeigt. Wenn Sie den Namen eines Ordners eingeben, der nicht existiert, wird ein neuer Ordner mit diesem Namen erstellt. Description : Beschreibung der Projektvorlage Die Beschreibung wird im Dialog Neues Projekt angezeigt, wenn eine Vorlage selektiert ist. DefaultFileName : Standardname für das neue Projekt. Der Name wird im Dialog Neues Projekt im Feld Name angezeigt und kann dort geändert werden. Extension : .project : Mit dieser Vorlage wird ein CODESYS -Projekt .project erzeugt .library : Mit dieser Vorlage wird ein Bibliotheksprojekt .library erzeugt TemplatePath : Dateipfad des Vorlagenprojekts im Installationsverzeichnis von CODESYS in ..\/Templates Beispiele: TemplateTest.project : Das Vorlagenprojekt TemplateTest.project liegt im Verzeichnis ..\/Templates Library_Template\/CODESYS_Template.library : Das Vorlagenprojekt CODESYS_Template.library liegt im Verzeichnis Wenn die Texte in CODESYS in der Sprache der CODESYS -Oberfläche angezeigt werden sollen, fügen Sie die Übersetzungen zu den Tags LocalizedString gemäß obigem Beispiel hinzu. Speichern Sie die erstellte Vorlagendatei .template und legen Sie diese im Installationsverzeichnis in ..\/Templates ab. Wenn Sie nun CODESYS öffnen und den Befehl Datei → Neues Projekt wählen, steht Ihnen im Dialog Neues Projekt die soeben erstellte Projektvorlage für Ihr neues Projekt zur Verfügung. " }, 
{ "title" : "E\/A-Anbindung konfigurieren ", 
"url" : "_cds_struct_io_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren ", 
"snippet" : "Sie können in Ihrem CODESYS -Projekt die zu steuernde Hardware mit Hilfe von Geräteobjekten in einer Baumstruktur abbilden. Dadurch lässt sich die Verknüpfung von Hardware und Applikation leicht handhaben. In den Konfigurationseditoren der Geräteobjekte können Sie Einstellungen für die Kommunikation...", 
"body" : "Sie können in Ihrem CODESYS -Projekt die zu steuernde Hardware mit Hilfe von Geräteobjekten in einer Baumstruktur abbilden. Dadurch lässt sich die Verknüpfung von Hardware und Applikation leicht handhaben. In den Konfigurationseditoren der Geräteobjekte können Sie Einstellungen für die Kommunikation zwischen CODESYS und der Steuerung, und vor allem die E\/A-Zuordnung vornehmen. Die E\/A-Zuordnung, auch E\/A-Abbild genannt, ist die Verknüpfung der Eingänge und Ausgänge der Steuerung mit den Variablen Ihrer Applikation. Der Zugriff auf Steuerungsobjekte zur Laufzeit kann geräteabhängig über eine „Online Benutzerverwaltung“ geregelt sein, die Sie, ebenfalls abhängig vom Gerät, im CODESYS Development System bearbeiten können. Außerdem hängt die mögliche Kommunikation mit dem Steuerungsgerät von den aktuell gültigen „Security-Einstellungen“ ab. " }, 
{ "title" : "Gerätebaum und Geräteeditor ", 
"url" : "_cds_device_tree_device_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Gerätebaum und Geräteeditor ", 
"snippet" : "Geräteeditor In den Registerkarten des Geräteeditors können Sie Einstellungen zur Kommunikation zwischen CODESYS und dem Zielgerät vornehmen. Sie öffnen den Editor mit einem Doppelklick auf das Geräteobjekt im Gerätebaum. Der Editor enthält generische und gerätespezifische Registerkarten. Er ist bet...", 
"body" : "Geräteeditor In den Registerkarten des Geräteeditors können Sie Einstellungen zur Kommunikation zwischen CODESYS und dem Zielgerät vornehmen. Sie öffnen den Editor mit einem Doppelklick auf das Geräteobjekt im Gerätebaum. Der Editor enthält generische und gerätespezifische Registerkarten. Er ist betitelt mit dem Namen des Geräts. Für weitere Informationen siehe: Geräte konfigurieren und E\/A-Abbild konfigurieren" }, 
{ "title" : "Gerätebaum ", 
"url" : "_cds_device_tree_device_editor.html#UUID-7bc193e4-b97a-a4e3-f11d-5776c956d246_id_e039ebc3920863bc0a8640e01ade420_id_855d3ce2ce443b2fc0a8640e00ffb1ef", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Gerätebaum und Geräteeditor \/ Gerätebaum ", 
"snippet" : "In der Ansicht Geräte , auch „Gerätebaum“ genannt, stellen Sie Applikationen zielgerätbezogen zusammen. Sie können hier die Hardware eines oder mehrerer Steuerungsgeräte oder Feldbussysteme abbilden, die Kommunikation mit ihr konfigurieren und ihr jeweils mehrere Applikationen zuweisen. Der Wurzelkn...", 
"body" : "In der Ansicht Geräte , auch „Gerätebaum“ genannt, stellen Sie Applikationen zielgerätbezogen zusammen. Sie können hier die Hardware eines oder mehrerer Steuerungsgeräte oder Feldbussysteme abbilden, die Kommunikation mit ihr konfigurieren und ihr jeweils mehrere Applikationen zuweisen. Der Wurzelknoten des Gerätebaums ist ein symbolischer Knoteneintrag <project name> . Darunter hängen Sie die Geräteobjekte für ein oder mehrere Steuerungsgeräte, auch „Zielsysteme“ genannt, ein. Jedes Geräteobjekt repräsentiert eine bestimmte Hardware wie beispielsweise ein Steuerungsgerät, Feldbus, Buskoppler, Antrieb, E\/A-Modul oder Monitor. Beim Einfügen des Objekts unterstützt Sie ein Einfügeassistent, der immer die passenden Geräte aus Ihrem lokalen Geräte-Repository anbietet. Wenn Sie bereits mit einem Steuerungsnetzwerk verbunden sind, können Sie die Hardware auf vorhandene Geräte durchsuchen und in die aktuelle Konfiguration in den Gerätebaum übernehmen. Für das Anlegen der Geräteobjekte im Gerätebaum, also das Abbilden der zu steuernden Hardwareumgebung, gelten bestimmte Regeln (siehe unten). Die hierarchische Anordnung von Applikationsobjekten und Geräteobjekten definiert die Gültigkeitsbereiche anderer Objekte wie Bibliotheken und GVLs. Es gibt programmierbare Geräte und rein parametrierbare Geräte. Der Gerätetyp definiert die mögliche Einfügeposition im Gerätebaum und die Auswahl der Objekte, die Sie unterhalb des Geräts einfügen können. Programmierbare Geräte erhalten automatisch einen zusätzlichen rein organisatorischen Knoten SPS-Logik unterhalb des Geräteobjekts. Unter diesem Knoten fügen Sie die Objekte ein, die für das Programmieren des Geräts benötigt werden, also die Applikation(en) und beispielsweise GVLs oder Textlisten. Jedes Gerät ist durch seine Gerätebeschreibung definiert und muss auf dem lokalen System installiert sein, um für das Einfügen im Gerätebaum verfügbar zu sein. Die Gerätebeschreibungsdatei definiert die Eigenschaften eines Geräts hinsichtlich Konfigurierbarkeit, Programmierbarkeit und möglichen Verbindungen zu anderen Geräten. Die Ansicht POUs enthält Objekte, die Sie projektweit verwenden können. Programmierobjekte, die nur für eine bestimmte Applikation bestimmt sind, müssen Sie unterhalb des Applikationsobjekts in der Ansicht Geräte (Gerätebaum) einfügen. Beachten Sie die Möglichkeit, die aktive Applikation auf einem „Simulationsgerät“ laufen zu lassen, das standardmäßig innerhalb des Programmiersystems automatisch zur Verfügung steht. Derzeit gibt es diese Simulationsmöglichkeit für das Zielsystem CODESYS Control Win . Im Simulationsbetrieb können Sie auch ohne Hardware das Onlineverhalten der Applikation testen. Sie aktivieren die Simulation mit dem Befehl Online → Simulation . Beachten Sie weiterhin die Möglichkeit, mit Hilfe des Befehls Online-Konfigurationsbetrieb für eine Applikation eine Verbindung zum Gerät herzustellen, ohne vorher diese Applikation dorthin laden zu müssen. Dies ist nützlich für die Erstinbetriebnahme eines E\/A-Systems, weil Sie damit die E\/As in der Steuerungskonfiguration schon ansprechen und testen können, bevor Sie die tatsächliche Applikation programmiert und geladen haben. Beispiel eines Gerätebaums: (1) Programmierbares Gerät (mit Applikation) (2) Symbolischer Gerätenname (3) Gerätetyp, definiert in der Gerätebeschreibung (4) Rein parametrierbares Gerät Ein Geräteeintrag im Gerätebaum besteht jeweils aus einem Symbol, aus dem im Baum editierbaren symbolischen Gerätenamen und aus dem Gerätetyp (= Gerätename definiert in der Gerätebeschreibung) dahinter. Alle Geräte mit Buszyklus-Einstellungen und Tasks, die für beliebige Buszyklustasks verwendet werden, werden zusätzlich mit dem Symbol gekennzeichnet. Bei Tasks und Geräten mit diesem Symbol wird zusätzlich ein Tooltip angezeigt. In dem Tooltip werden bei den Tasks die verwendeten Geräte und bei den Geräten die Tasks angezeigt. Die Konfiguration eines Geräts bezüglich Kommunikation, Parameter, E\/A-Abbild führen Sie in den Dialogen des Geräteeditors durch. Dieser Editor öffnen Sie mit einem Doppelklick auf das Geräteobjekt. " }, 
{ "title" : "Regeln und Vorgehensweisen für das Anordnen und Konfigurieren von Objekten im Gerätebaum ", 
"url" : "_cds_device_tree_device_editor.html#UUID-7bc193e4-b97a-a4e3-f11d-5776c956d246_id_e039ebc3920863bc0a8640e01ade420_id_67d7c878777219b2c0a8640e01e97928", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Gerätebaum und Geräteeditor \/ Regeln und Vorgehensweisen für das Anordnen und Konfigurieren von Objekten im Gerätebaum ", 
"snippet" : "Regeln und Vorgehensweisen für das Anordnen und Konfigurieren von Objekten im Gerätebaum Objekte einfügen Um ein Geräteobjekt einzufügen, verwenden Sie direkt den Befehl Gerät einfügen oder Gerät anhängen im Kontextmenü des Gerätebaums. Für andere Objekte verwenden Sie den Befehl Objekt hinzufügen ....", 
"body" : "Regeln und Vorgehensweisen für das Anordnen und Konfigurieren von Objekten im Gerätebaum Objekte einfügen Um ein Geräteobjekt einzufügen, verwenden Sie direkt den Befehl Gerät einfügen oder Gerät anhängen im Kontextmenü des Gerätebaums. Für andere Objekte verwenden Sie den Befehl Objekt hinzufügen . CODESYS bietet immer die an der gerade selektierten Position im Baum passenden Objekte zur Auswahl an. Beispiel: Module für einen PROFIBUS DP-Slave können nur unterhalb eines entsprechende Slave-Objekts eingehängt werden, Applikationen nur unterhalb von programmierbaren Geräten. Die Auswahl an Geräteobjekten hängt zusätzlich davon ab, welche Geräte im Geräte-Repository installiert sind. Für die Namen der Objekte gelten folgende Empfehlung und Regeln: Die Größe von 80 Zeichen sollte nicht überschritten werden. Bei mehr als 80 Zeichen wird eine Compilewarnung erzeugt. Erlaubt sind nur alphanumerische Zeichen und der Unterstrich Das erste Zeichen muss ein Buchstabe oder ein Unterstrich sein Auf der Ebene direkt unterhalb des Wurzelknotens <project name> können Sie nur Geräteobjekte einhängen . Wenn Sie einen anderen Objekttyp auswählen wie beispielsweise eine Textliste, fügt CODESYS diese automatisch in der Ansicht POUs , also im projektglobalen Pool ein! Applikationen einfügen Ein Objekt Applikation können Sie nur unterhalb des Knotens SPS-Logik einfügen, also unterhalb eines programmierbaren Geräts. Pro Gerät müssen alle Applikationen eindeutig benannt sein. Unterhalb jeder Applikation können Sie weitere, für die Programmierung benötigte Objekte einhängen wie beispielsweise POUs, DUTs, GVLs oder Visualisierungen. Unterhalb jeder Applikation müssen Sie eine Taskkonfiguration einfügen und darin die entsprechenden Programmaufrufe von applikationsspezifischen POUs oder POU-„Instanzen“ (aus der Ansicht POUs ) konfigurieren. Wenn sich mehrere Applikationen direkt unter einem Gerät befinden, müssen Sie Einstellungen für die E\/A-Verarbeitung des Geräts definieren. Dazu gehören die Variablen der Applikation, die CODESYS für die Kommunikation mit dem Zielsystem verwendet. Die Einstellung erfolgt im Geräteeditor in der Registerkarte SPS-Einstellungen . Hierarchische Anordnung von Applikationen, Gültigkeitsbereiche: Sie können eine Applikation unterhalb einer anderen Applikation einhängen. Nennen wir das entstehende Konstrukt „Vaterapplikation“ - „Kindapplikation“. In diesem Fall gilt Folgendes: Die Kindapplikation kann auf die Objekte der Vaterapplikation zugreifen, nicht aber umgekehrt! Hintergrund: Eine Kindapplikation soll immer entfernt oder ausgetauscht werden können, ohne die Vaterapplikation zu beeinträchtigen. HINWEIS Eine Kindapplikation wird von der Steuerung entfernt, wenn ein Online-Change durchgeführt wird, nachdem die Vaterapplikation geändert wurde. Geräte einfügen CODESYS fügt ein Geräteobjekt als Knoten im Baum ein. Wenn in der Gerätebeschreibung Unterknoten definiert sind, werden diese automatisch mit eingefügt. Ein Unterknoten kann auch ein programmierbares Gerät repräsentieren. Zur Reihenfolge der Geräteobjekte innerhalb des Baums von oben nach unten: Pro Ebene werden immer zuerst die programmierbaren Geräte (SPS-Logik) angeordnet, dann die restlichen Typen, jeweils alphabetisch sortiert. Geräte aktualisieren Ein bereits im Gerätebaum eingefügtes Gerät können Sie durch eine andere Version desselben Geräts oder durch ein Gerät anderen Typs ersetzen ( Geräte aktualisieren ). Ein unterhalb des Geräts vorhandener Konfigurationsbaum wird dabei soweit als möglich erhalten. Objekte anders platzieren oder löschen Sie können die Objekte mit den Standardbefehlen Ausschneiden , Kopieren , Einfügen , Löschen behandeln, oder durch Ziehen eines ausgewählten Objekts mit der Maus auf eine andere Position. Wenn Sie Objekte kopieren, erhält das neue Objekt den gleichen Namen, erweitert um eine fortlaufende Nummer. Netzwerk-Scan der aktuellen Hardware Das Anlegen der Steuerungskonfiguration im Gerätebaum wird standardmäßig von den Geräteeditoren mit einer Scan-Funktionalität unterstützt: Die aktuelle Hardwareumgebung wird durchsucht und die gefundenen Module in einem Dialog dargestellt. Von dort können Sie die gewünschten Geräte direkt in den Gerätebaum übernehmen. Sehen Sie dazu den Befehl Geräte suchen . Für weitere Informationen siehe: Hardwarestruktur im Gerätebaum abbilden" }, 
{ "title" : "Gerätebaum im Onlinebetrieb ", 
"url" : "_cds_device_tree_device_editor.html#UUID-7bc193e4-b97a-a4e3-f11d-5776c956d246_id_e039ebc3920863bc0a8640e01ade420_id_1bf1cadc777219b4c0a8640e00127639", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Gerätebaum und Geräteeditor \/ Gerätebaum im Onlinebetrieb ", 
"snippet" : "Im Onlinebetrieb zeigt ein Symbol vor einem Geräteeintrag den Status des Geräts an. : SPS ist verbunden, Applikation läuft, Gerät ist in Betrieb, Daten werden ausgetauscht. Die Option E\/As aktualisieren im Stop in Registerkarte SPS-Einstellungen kann aktiviert oder deaktiviert sein. : SPS ist verbun...", 
"body" : "Im Onlinebetrieb zeigt ein Symbol vor einem Geräteeintrag den Status des Geräts an. : SPS ist verbunden, Applikation läuft, Gerät ist in Betrieb, Daten werden ausgetauscht. Die Option E\/As aktualisieren im Stop in Registerkarte SPS-Einstellungen kann aktiviert oder deaktiviert sein. : SPS ist verbunden und im Stop ( STOP ), und die Option E\/As aktualisieren im Stop im Registerkarte SPS-Einstellungen ist deaktiviert. : Gerät tauscht keine Daten aus; Busfehler, keine Konfiguration, oder Simulationsbetrieb. : Gerät läuft im Demo-Betrieb für 30 Minuten. Nach dieser Zeit läuft der Demo-Betrieb aus und der Feldbus beendet den Datenaustausch. : Gerät ist konfiguriert, aber nicht voll betriebsbereit. Es werden keine Daten ausgetauscht. Beispielsituation: CANopen-Geräte während des Hochstartens und im präoperativen Zustand. : Redundanzbetrieb ist aktiv. Der Feldbus-Master sendet gerade keine Daten, weil ein anderer Master aktiv ist. : Die Gerätebeschreibung konnte im Geräte-Repository nicht gefunden werden. : Das Gerät selbst läuft zwar, aber ein untergeordnetes Gerät läuft nicht oder hat eine Diagnosemeldung. Das untergeordnete Gerät ist wegen eines zugeklappten Gerätebaums nicht sichtbar. : Ausrufezeichen grau: Es stand eine Diagnose an. Die Fehlerursache ist jedoch nicht mehr vorhanden oder wurde gelöst. Dieses Symbol kann in Verbindung mit diversen anderen Symbolen dieser Liste auftreten. : Ausrufezeichen rot: Das Gerät läuft nicht oder es steht eine Diagnose an. Die Fehlerursache ist noch vorhanden. Dieses Symbol kann in Verbindung mit diversen anderen Symbolen dieser Liste auftreten. Die Namen aller gerade verbundenen Geräte und Applikationen werden grün hinterlegt: Die Namen von Geräten, die im Simulationsbetrieb laufen, werden in Kursivschrift dargestellt. Zusätzliche Diagnoseinformation gibt das Registerkarte Status des jeweiligen Geräteeditors. Wenn Sie einloggen, während die Gerätebeschreibung auf dem Zielgerät neuer ist als die im Projekt, erhalten Sie eine Warnung und die Möglichkeit den Vorgang abzubrechen. Für weitere Informationen siehe: Befehl 'Diagnose bestätigen', 'Diagnose für Unterbaum bestätigen' und Applikation auf die SPS übertragen" }, 
{ "title" : "Bedeutung der Farben der Programmierbausteine ", 
"url" : "_cds_device_tree_device_editor.html#UUID-7bc193e4-b97a-a4e3-f11d-5776c956d246_section-idm234735523635194", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Gerätebaum und Geräteeditor \/ Bedeutung der Farben der Programmierbausteine ", 
"snippet" : "Die Namen der Programmierbausteine im Gerätebaum werden teilweise in unterschiedlichen Farben angezeigt. Die Farben haben folgende Bedeutung: Schwarz: Standardfarbe, keine bestimmte Bedeutung Grau: Wird nach einer Codeerzeugung angezeigt und zeigt an, dass der Baustein im Projekt nicht verwendet wir...", 
"body" : "Die Namen der Programmierbausteine im Gerätebaum werden teilweise in unterschiedlichen Farben angezeigt. Die Farben haben folgende Bedeutung: Schwarz: Standardfarbe, keine bestimmte Bedeutung Grau: Wird nach einer Codeerzeugung angezeigt und zeigt an, dass der Baustein im Projekt nicht verwendet wird Blau: Wird nach einer Codeerzeugung angezeigt und wenn das Projekt schon einmal heruntergeladen wurde. Der Baustein hat sich im Vergleich zu dem Baustein auf der Steuerung verändert und wird beim nächsten Download heruntergeladen Blaugrün: Der Baustein hat die Eigenschaft Vom Build ausschließen gesetzt " }, 
{ "title" : "Hardwarestruktur im Gerätebaum abbilden ", 
"url" : "_cds_mapping_hardware_in_device_tree.html", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Hardwarestruktur im Gerätebaum abbilden ", 
"snippet" : "In der Ansicht Geräte (Gerätebaum) bilden Sie die Hardware ab, die Sie mit Ihrer Applikation steuern. Dazu fügen Sie in dieser Baumstruktur Geräteobjekte ein, die reelle Geräte im Netzwerk vertreten, bis die Hierarchie das Steuerungsnetzwerk wiedergibt. Geräteobjekte sind beispielsweise ein SPS-Obje...", 
"body" : "In der Ansicht Geräte (Gerätebaum) bilden Sie die Hardware ab, die Sie mit Ihrer Applikation steuern. Dazu fügen Sie in dieser Baumstruktur Geräteobjekte ein, die reelle Geräte im Netzwerk vertreten, bis die Hierarchie das Steuerungsnetzwerk wiedergibt. Geräteobjekte sind beispielsweise ein SPS-Objekt, ein Feldbusobjekt oder ein logisches Gerät. " }, 
{ "title" : "Standardsteuerung mit Feldbus im Gerätebaum abbilden ", 
"url" : "_cds_mapping_hardware_in_device_tree.html#UUID-ae97416f-7f9b-10e7-4389-bfe2604cc6e5_id_f9c9ce5177757233c0a8640e003c07f9_id_b09bd7f45a802de8c0a8640e0116665b", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Hardwarestruktur im Gerätebaum abbilden \/ Standardsteuerung mit Feldbus im Gerätebaum abbilden ", 
"snippet" : "Im Folgenden bilden Sie eine Hardware ab, die eine Standard-SPS und einen Standardfeldbus enthält. Wählen Sie Befehl Datei → Neues Projekt . Wählen Sie im Dialog Neues Projekt die Vorlage Standardprojekt . Wählen Sie im Dialog Standardprojekt das Gerät CODESYS Control Win . CODESYS fügt das Objekt D...", 
"body" : "Im Folgenden bilden Sie eine Hardware ab, die eine Standard-SPS und einen Standardfeldbus enthält. Wählen Sie Befehl Datei → Neues Projekt . Wählen Sie im Dialog Neues Projekt die Vorlage Standardprojekt . Wählen Sie im Dialog Standardprojekt das Gerät CODESYS Control Win . CODESYS fügt das Objekt Device ( CODESYS Control Win ) im Gerätebaum unter dem Wurzelknoten ein, darunter den Knoten SPS-Logik , den ein programmierbares Geräteobjekt immer mitbringt. Darunter hängt ein Objekt Applikation und wiederum darunter die Objekte Bibliotheksverwalter , PLC_PRG und Taskkonfiguration . Selektieren Sie den Eintrag Device und wählen Sie im Kontextmenü den Befehl Gerät anhängen . Der Dialog Gerät anhängen bietet eine Auswahl der auf Ihrem System installierten Geräte. Auf dem System installiert bedeutet, dass CODESYS für die jeweilige Hardware eine Gerätebeschreibung erhalten hat. Somit können Sie das Geräteobjekt und den zugehörigen Konfigurationseditor im Projekt verwenden. Wählen Sie eines der angebotenen Steuerungsgeräte aus, beispielsweise CAN-Bus , und klicken auf die Schaltfläche Gerät anhängen . Eingerückt unter Device ( CODESYS ) erscheint das Objekt CAN-Bus im Gerätebaum. Der Dialog Gerät anhängen bleibt geöffnet. Wenn Sie jetzt den neuen CAN-Bus -Eintrag selektieren, bietet er automatisch die darunter einfügbaren Objekte an. Wählen Sie beispielsweise aus der Kategorie Lokales Gerät das Gerät CANopen Device aus. CANopen_Device wird eingerückt unter CAN-Bus im Gerätebaum eingefügt. Sie wollen doch ein anderes Gerät einhängen als Sie vorher getan haben? Selektieren Sie den Geräteeintrag und wählen Sie im Kontextmenü den Befehl Gerät aktualisieren . Der Dialog Gerät aktualisieren erscheint. Er entspricht dem vorher verwendeten Dialog Gerät anhängen . Sie können ein anderes Gerät auswählen, das dann anstelle des bisherigen im Baum eingefügt wird. " }, 
{ "title" : "Scannen der aktuellen Hardware und Übernehmen von Geräten ins Projekt ", 
"url" : "_cds_mapping_hardware_in_device_tree.html#UUID-ae97416f-7f9b-10e7-4389-bfe2604cc6e5_id_f9c9ce5177757233c0a8640e003c07f9_id_00318a175a802de8c0a8640e017d9869", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Hardwarestruktur im Gerätebaum abbilden \/ Scannen der aktuellen Hardware und Übernehmen von Geräten ins Projekt ", 
"snippet" : "Sie können die Geräte im Netzwerk der Hardwareumgebung ermitteln (Scan) und die gefundenen Geräte in den Gerätebaum Ihres Projekts übernehmen. Wenn die Scan-Funktionalität fest in der SPS implementiert ist, können Sie das Scannen ohne weitere Vorbereitungen durchführen. CODESYS baut zu diesem Zweck ...", 
"body" : "Sie können die Geräte im Netzwerk der Hardwareumgebung ermitteln (Scan) und die gefundenen Geräte in den Gerätebaum Ihres Projekts übernehmen. Wenn die Scan-Funktionalität fest in der SPS implementiert ist, können Sie das Scannen ohne weitere Vorbereitungen durchführen. CODESYS baut zu diesem Zweck automatisch kurzzeitig eine Verbindung zur Steuerung auf. Wenn die Scan-Funktionalität in einer Bibliothek bereitgestellt wird, muss das Gerät, das diese Bibliothek mitbringt, im Gerätebaum eingehängt sein und dann ein Login auf die Steuerung durchgeführt werden. Erst dadurch gelangt die Bibliothek auch auf die Steuerung und Scannen ist möglich. Das Scannen wird mit dem Befehl Geräte suchen gestartet. Es bezieht sich auf die gerade im Gerätebaum selektierte, zum Projekt verbundene Steuerung. Beispielsweise können Sie einen eingefügten PROFINET IO Controller auswählen und mit dem Befehl die ihm zugeordneten E\/A-Geräte und E\/A-Module ermitteln. Voraussetzung: Sie haben ein Projekt mit einer Gerätekonfiguration. Die Kommunikationseinstellungen sind korrekt. Gateways und Hardware laufen. Selektieren Sie ein Steuerungsgeräteobjekt im Gerätebaum. Wählen Sie im Kontextmenü den Befehl Geräte suchen . CODESYS stellt die Verbindung zur Hardware her. Der Dialog Geräte suchen erscheint. Je nach Gerätetyp bietet er unterschiedliche Funktionen. Immer jedoch erscheint eine Tabelle mit den in der Hardware ermittelten Geräten: Gerätename, Gerätetyp, Stationsname usw. Sehen Sie hierzu bitte die Hilfe zum jeweiligen Geräteeditor. Damit die Liste nur gefundene Geräte anzeigt, die Sie noch nicht in der Gerätekonfiguration Ihres Projekts haben, aktivieren Sie die Option Unterschiede zum Projekt anzeigen. Um ein Gerät in den Gerätebaum des Projekts zu übernehmen, selektieren Sie den Eintrag in der Tabelle und klicken Sie auf Schaltfläche Ins Projekt kopieren . Wenn Sie keinen Eintrag selektieren, werden alle gefundenen Geräte übernommen. Die entsprechenden Einträge werden im Gerätebaum eingefügt. " }, 
{ "title" : "Überprüfen der Steuerungskonfiguration mit Hilfe des Befehls Online-Konfigurationsbetrieb ", 
"url" : "_cds_mapping_hardware_in_device_tree.html#UUID-ae97416f-7f9b-10e7-4389-bfe2604cc6e5_section-idm53263079816560", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Hardwarestruktur im Gerätebaum abbilden \/ Überprüfen der Steuerungskonfiguration mit Hilfe des Befehls Online-Konfigurationsbetrieb ", 
"snippet" : "Sie können mit CODESYS die korrekte Verdrahtung der E\/As und des Feldbusses Ihres Zielsystems testen, ohne vorher eine reelle Applikation für die Steuerung entwickelt und auf die Steuerung geladen haben zu müssen. Dies ist interessant für die Phase der Erstinbetriebnahme. Verwenden Sie dazu den „ein...", 
"body" : "Sie können mit CODESYS die korrekte Verdrahtung der E\/As und des Feldbusses Ihres Zielsystems testen, ohne vorher eine reelle Applikation für die Steuerung entwickelt und auf die Steuerung geladen haben zu müssen. Dies ist interessant für die Phase der Erstinbetriebnahme. Verwenden Sie dazu den „einfachen Online-Konfigurationsbetrieb“. Wenn bereits eine Applikation auf der Steuerung liegt, können Sie optional auch den „erweiterten Online-Konfigurationsbetrieb“ nützen, falls das Gerät dies unterstützt. Damit können Sie Geräteparameter lesen, ohne mit der betroffenen Applikation aus CODESYS heraus einloggen zu müssen. Einfacher Online-Konfigurationsbetrieb Mit dem Befehl Online-Konfigurationsbetrieb im Kontextmenü des SPS-Objekts im Gerätebaum erzeugen Sie eine implizite Applikation. CODESYS lädt die Applikation automatisch auf die SPS und initialisiert über sie automatisch einmalig alle E\/As. Die Applikation heißt HiddenOnlineConfigModeApp . Sie wird im Geräteeditor der SPS in der Registerkarte Applikationen angezeigt. Sie können damit die E\/As wie im normalen Onlinebetrieb mit folgenden Funktionen bedienen: E\/As lesen Ausgänge schreiben Diagnose (im Baum und auf der Statusseite) Scan (der aktuellen Hardware) Interaktive Online-Funktionen, wenn unterstützt (beispielsweise Schreiben asynchroner Meldungen) Schreiben und Forcen im E\/A-Abbild Im Online-Konfigurationsbetrieb funktioniert das Schreiben und Forcen von Werten im Dialog E\/A-Abbild anders als im reellen Onlinebetrieb. CODESYS schreibt die Ausgänge sofort nach dem Einfügen in die E\/A-Abbild-Tabelle. Es gibt keine Spalte Vorbereiteter Wert , sondern Sie verändern die Ausgangswerte direkt nach einem Doppelklick auf die Spalte Aktueller Wert . Testen des E\/A-Zugriffs mit Hilfe des einfachen Online-Konfigurationsbetriebs Voraussetzung: Sie haben ein Standardprojekt mit einer Gerätekonfiguration angelegt, in der Sie ein E\/A-Abbild konfiguriert haben. In einem Programmbaustein greifen Sie lesend oder schreibend auf Eingänge oder Ausgänge der Hardware zu, um deren Verdrahtung zu überprüfen. Die Verbindung zur SPS der Hardware ist in den Kommunikationseinstellungen konfiguriert. Die SPS läuft. Selektieren Sie das SPS-Objekt im Gerätebaum. Im Gerätebaum ist beispielsweise das Gerät CODESYS Control Win selektiert. Wählen Sie im Kontextmenü den Befehl Online-Konfigurationsbetrieb . CODESYS verbindet zur Steuerung, das SPS-Objekt im Baum wird grün hinterlegt. Doppelklicken Sie auf das SPS-Objekt im Gerätebaum, um den Geräteeditor zu öffnen. Wählen Sie die Registerkarte Applikationen . Klicken Sie auf die Schaltfläche Liste aktualisieren . Im Fenster Applikationen auf der Steuerung erscheint die Applikation HiddenOnlineConfigModeApp . Starten Sie Ihr Programm und prüfen das Verhalten der Eingänge und Ausgänge. Erweiterter Online-Konfigurationsbetrieb (Parameterbetrieb) Wenn bereits eine „reelle“ Applikation auf der Steuerung liegt und das Gerät den „erweiterten Online-Konfigurationsbetrieb“ unterstützt, können Sie nach dem Befehl Online-Konfigurationsbetrieb optional auch den „Parameterbetrieb“ wählen. Dann können Sie die Parameter der reellen Applikation auf der Steuerung lesen, ohne dass ein Standardeinloggen und - bei fehlender Übersetzungsinformation - ein erneuter Download dieser Applikation nötig ist. Sie sehen die Parameter in der Registerkarte Konfiguration des Geräteeditors. Der Parameterbetrieb verhindert ein versehentliches Ändern der Daten auf der Steuerung, die Applikationen bleiben unangetastet. Ein Schreiben der Parameter ist nur möglich, wenn der Treiber es unterstützt. Parameterbetrieb für Lesen der Geräteparameter einrichten Voraussetzung: Auf dem Zielgerät liegen bereits eine oder mehrere Applikationen. Das Zielgerät unterstützt den erweiterten Online-Konfigurationsbetrieb. Sie haben das Projekt geöffnet, das diese Applikationen enthält. Sie möchten die Geräteparameter ansehen, ohne sich auf die Steuerung einloggen zu müssen. Die Verbindung zur SPS der Hardware ist in den Kommunikationseinstellungen konfiguriert. Die SPS läuft. Selektieren Sie das SPS-Objekt im Gerätebaum. Wählen Sie im Kontextmenü den Befehl Online-Konfigurationsbetrieb . CODESYS verbindet zur Steuerung, das SPS-Objekt im Baum wird grün hinterlegt. Der Dialog Konfigurationsbetrieb wählen erscheint mit Anzeige der Applikation(en) auf der SPS. Selektieren Sie die gewünschte Applikation und klicken auf die Schaltfläche Parameterbetrieb . CODESYS prüft, ob die Applikation im Projekt mit der Applikation auf der SPS übereinstimmt. Wenn CODESYS bezüglich der Übereinstimmung der Applikationen keinen Fehler meldet, öffnen Sie die Registerkarte Konfiguration des SPS-Geräteeditors. Sie können die Geräteparameter lesen. " }, 
{ "title" : "Geräte konfigurieren und E\/A-Abbild konfigurieren ", 
"url" : "_cds_configuring_devices_mapping_ios.html", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Geräte konfigurieren und E\/A-Abbild konfigurieren ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Geräte konfigurieren ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_UUID-d1d98d5b-c218-8b08-a4d5-9eb8af6cbbe3", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Geräte konfigurieren und E\/A-Abbild konfigurieren \/ Geräte konfigurieren ", 
"snippet" : "Die im Gerätebaum eingehängten Geräteobjekte können Sie im zugehörigen Geräteeditor konfigurieren. Die Möglichkeiten hängen von der Gerätebeschreibung ab. Der „ generische Geräteeditor “ stellt Registerkarten bereit, die gegebenenfalls durch gerätespezifische Registerkarten ergänzt sind. Voraussetzu...", 
"body" : "Die im Gerätebaum eingehängten Geräteobjekte können Sie im zugehörigen Geräteeditor konfigurieren. Die Möglichkeiten hängen von der Gerätebeschreibung ab. Der „ generische Geräteeditor “ stellt Registerkarten bereit, die gegebenenfalls durch gerätespezifische Registerkarten ergänzt sind. Voraussetzung: Sie haben ein Standardprojekt geöffnet, in dessen Gerätebaum eine Standard-SPS und darunter ein Feldbus-Geräteobjekt eingefügt sind. Führen Sie einen Doppelklick auf das Geräteobjekt der Standard-SPS im Gerätebaum Ihres Projekts aus. Der Editor <Gerätename> erscheint im CODESYS -Hauptfenster. Die Registerkarte Kommunikationsstellungen ist im Vordergrund. Wechseln Sie auf die anderen Registerkarten, um Konfigurationseinstellungen für die Steuerung vorzunehmen. Sehen Sie dazu bitte die Hilfeseiten zum generischen Geräteeditor. Führen Sie einen Doppelklick auf das Feldbus-Geräteobjekt m Gerätebaum Ihres Projekts aus. Der Editor <Feldbus-Gerätename> erscheint im CODESYS -Hauptfenster. Je nach Gerät sind spezifische Registerkarten verfügbar. Sehen Sie zu den Konfigurationsmöglichkeiten bitte die Hilfeseiten zum jeweiligen Geräteeditor. Wenn die Option Generische Konfigurationseditoren anzeigen in Tools → Optionen , Kategorie Geräteeditor aktiviert ist, sehen Sie auch die vom generischen Geräteeditor beigesteuerten Registerkarten. " }, 
{ "title" : "SPS-Parameterdatei in Konfiguration einlesen ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_6d2a082e744f3da1c0a8640e00aa0acb", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Geräte konfigurieren und E\/A-Abbild konfigurieren \/ SPS-Parameterdatei in Konfiguration einlesen ", 
"snippet" : "Wenn die Konfigurationsparameter der SPS durch ein anderes Gerät, beispielsweise über eine Visualisierung, verändert wurden, wird auf der Steuerung eine Konfigurationsdatei IoConfig.par angelegt. Im Parameter-Dialog des Geräteeditors gibt es geräteabhängig im Onlinebetrieb auch eine Schaltfläche zum...", 
"body" : "Wenn die Konfigurationsparameter der SPS durch ein anderes Gerät, beispielsweise über eine Visualisierung, verändert wurden, wird auf der Steuerung eine Konfigurationsdatei IoConfig.par angelegt. Im Parameter-Dialog des Geräteeditors gibt es geräteabhängig im Onlinebetrieb auch eine Schaltfläche zum Schreiben der aktuellen Parameter in eine solche Datei. Um die veränderten Parameter auch innerhalb Ihres Projekts zu aktualisieren, können Sie die Parameterdatei im Onlinebetrieb einlesen. Voraussetzung: Sie haben ein Standardprojekt, in dessen Gerätebaum die Hardwareumgebung mit einer SPS und einem parametrierbaren Gerät abgebildet sind. Auf der Steuerung gibt es eine Datei IoConfig.par , in die zuvor die Geräteparameter mit den aktuellen Werten gespeichert wurden. Fügen Sie im Dialog Tools → Anpassen aus Kategorie Geräte den Befehl SPS-Parameterdatei in Konfiguration einlesen einem Menü der Oberfläche hinzu. Selektieren Sie das SPS-Geräteobjekt im Gerätebaum und öffnen Sie das Kontextmenü. Wählen Sie den Befehl SPS-Parameterdatei in Konfiguration einlesen . Automatisch baut CODESYS eine Verbindung zur Steuerung auf und liest die Parameter aus der par-Datei ein. In der Registerkarte mit den Geräteparametern werden diese entsprechend aktualisiert. " }, 
{ "title" : "Allgemeines zum E\/A-Abbild („Mapping“) ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_UUID-38bf2ccb-2c3b-2bd8-ca28-36065308260f", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Geräte konfigurieren und E\/A-Abbild konfigurieren \/ Allgemeines zum E\/A-Abbild („Mapping“) ", 
"snippet" : "Es hängt vom Gerätetyp ab, ob Sie ein E\/A-Abbild auf Projektvariablen oder sogar auf ganze Funktionsbausteine konfigurieren können oder nicht. Ein E\/A-Abbild zu konfigurieren heißt Eingangs- und Ausgangskanäle des Geräts mit Variablen des Projekts zu verknüpfen. Wir verwenden dafür auch den Begriff ...", 
"body" : "Es hängt vom Gerätetyp ab, ob Sie ein E\/A-Abbild auf Projektvariablen oder sogar auf ganze Funktionsbausteine konfigurieren können oder nicht. Ein E\/A-Abbild zu konfigurieren heißt Eingangs- und Ausgangskanäle des Geräts mit Variablen des Projekts zu verknüpfen. Wir verwenden dafür auch den Begriff „ Mapping „. Beachten Sie generell das Folgende für das Abbilden von Eingängen und Ausgängen eines Geräts auf Variablen in CODESYS : Sie können auf Variablen, die auf einen Eingang abgebildet sind, nicht schreibend zugreifen. Sie können eine bereits bestehende Variable nur auf 1 Eingang abbilden. Sie können im E\/A-Abbild direkt neue globale implizite Variablen erzeugen und auf einen Gerätekanal abbilden. Das Speicher-Layout von Strukturen wird vom Gerät vorgegeben. Sie können im E\/A-Abbild Adressen ändern und Werte fixieren. Für jede Variable, die einem E\/A-Kanal in der Registerkarte: <Gerätename> E\/A-Abbild zugewiesen ist, können Sie während des Übersetzens der Applikation „Force-Variablen“ erzeugen lassen (siehe weiter unten). Über diese Variablen können Sie beispielsweise bei der Inbetriebnahme einer Anlage über eine Visualisierung\/HMI einen Wert auf dem Eingang oder Ausgang forcen. Änderungen im E\/A-Abbild können Sie mit einem Online-Change zur Steuerung übertragen. Wenn ein Pointer auf einen Geräteeingang verwendet wird, gilt der Zugriff als schreibender Zugriff, beispielsweise pTest := ADR(input); . Dies führt bei der Codeerzeugung zu einer Compilerwarnung „ ...kein gültiges Zuordnungsziel „. Wenn Sie ein Konstrukt dieser Art benötigen, müssen Sie den Eingangswert input zuerst auf eine Variable mit Schreibzugriff kopieren. Eine E\/A-Adresse kann auch über die „AT-Deklaration“ im IEC-Code mit einer Variablen verknüpft werden. Da sich eine Gerätekonfiguration oftmals noch ändert, empfehlen wir allerdings, die Zuweisungen nur im Geräteeditor vorzunehmen. Falls Sie die AT-Deklaration verwenden, beachten Sie Folgendes: Eine AT-Deklaration ist nur bei lokalen oder globalen Variablen zulässig, nicht bei Eingangs- oder Ausgangsvariablen von Bausteinen. Implizite „Force-Variablen“ für E\/As (siehe unten) können für AT-Deklarationen nicht erzeugt werden. Wenn Sie eine AT-Deklaration bei Struktur- oder Funktionsbaustein-Variablen verwenden, werden alle Instanzen auf die gleiche Speicherstelle zugreifen. Dies entspricht dann der Verwendung von „statischen Variablen“ in klassischen Programmiersprachen wie beispielsweise „C“. Wenn ein Pointer auf einen Geräteeingang verwendet wird, gilt der Zugriff (beispielsweise pTest := ADR(input); ) als schreibender Zugriff. Dies führt bei der Codeerzeugung zu einer Compilerwarnung „ ...kein gültiges Zuordnungsziel „. Wenn Sie ein Konstrukt dieser Art benötigen, müssen Sie den Eingangswert ( input ) zuerst auf eine Variable mit Schreibzugriff kopieren. Alternativ können Sie im Programmiercode über die AT-Deklaration eine Variable einer Adresse zuweisen. In Anbetracht möglicher Änderungen der Gerätekonfiguration empfehlen wir jedoch, die Zuweisungen nur im Geräteeditor vorzunehmen. Sie können die E\/A-Abbildkonfiguration eines Geräts in eine csv -Datei exportieren von einer solchen importieren. Für weitere Informationen siehe: E\/A-Abbild in CSV exportierenFür weitere Informationen siehe: Erzeugen impliziter Variablen zum Forcen von E\/As" }, 
{ "title" : "Verknüpfen eines Geräteeingangs mit einer bestehenden Projektvariable („Mapping“) ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_999010aa744f3da6c0a8640e0038614a", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Geräte konfigurieren und E\/A-Abbild konfigurieren \/ Verknüpfen eines Geräteeingangs mit einer bestehenden Projektvariable („Mapping“) ", 
"snippet" : "Voraussetzung: Im Gerätebaum Ihres Projekts ist ein Gerät eingehängt, das eine E\/A-Abbildkonfiguration in CODESYS unterstützt. Somit erhalten Sie im Geräteeditor auf Registerkarte E\/A-Abbild eine tabellenförmige Darstellung der Eingangskanäle und Ausgangskanäle des Geräts mit Angabe der Adressen und...", 
"body" : "Voraussetzung: Im Gerätebaum Ihres Projekts ist ein Gerät eingehängt, das eine E\/A-Abbildkonfiguration in CODESYS unterstützt. Somit erhalten Sie im Geräteeditor auf Registerkarte E\/A-Abbild eine tabellenförmige Darstellung der Eingangskanäle und Ausgangskanäle des Geräts mit Angabe der Adressen und Datentypen. Abbilden „zu großer“ Datentypen Wenn Sie eine Variable eines Datentyps, der größer ist als ein Byte, auf eine Byteadresse abbilden, wird dort der Wert der Variablen auf Byte-Größe abgeschnitten! Für das Monitoring des Variablenwerts im Dialog E\/A-Abbild bedeutet dies: Im „Root“-Element der Adresse wird der Wert angezeigt, den die Variable im Projekt aktuell hat. In den Bit-Elementen darunter werden nacheinander die einzelnen aktuellen Bit-Werte des Bytes dargestellt, was aber gegebenenfalls nicht für den gesamten Variablenwert ausreicht. Wenn eine UNION durch E\/A-Kanäle im Abbild-Dialog vertreten ist, hängt es vom Gerät ab, ob auch ein Abbilden auf das „Root“-Element möglich ist. Deklarieren Sie in einem Programmbaustein beispielsweise eine Variable xBool4 vom Typ BOOL , mit der Sie aus der Applikation auf einen Eingang des Zielgeräts zugreifen wollen. Öffnen Sie mit einem Doppelklick auf das Geräteobjekt im Gerätebaum den Geräteeditor, dann Registerkarte <Gerätename> E\/A-Abbild . Betrachten Sie die Spalte Variable mit der Anzeige der Geräteeingangskanäle und Geräteausgangskanäle , die je nach Gerät noch durch organisatorische Knoten sortiert sein können. Wir nehmen an, es gibt einen Geräteeingang vom Typ BYTE . Er wird mit seinen einzelnen Bit-Adressen (Bit-Kanälen) unterhalb des BYTE -Knotens dargestellt. Hinweis: Beim Abbilden strukturierter Variablen verhindert der Editor, dass Sie sowohl die Strukturvariable (beispielsweise auf %QB0 ) als auch einzelne Strukturelemente (beispielsweise auf %QB0.1 und QB0.2 ) eintragen. Das bedeutet: Wenn es einen Haupteintrag mit einem Unterbaum von Bit-Kanal-Einträgen in der Abbild-Tabelle gibt, dann können Sie entweder in der Zeile des Haupteintrags eine Variable eintragen, oder in den Zeilen der Unterelemente (Bit-Kanäle), aber nicht in beiden. Sie können nun entweder den gesamten Kanal mit einer vom Typ her passenden Variable belegen, ODER einzelne seiner Bit-Kanaladressen mit passenden Variablen vom Typ BOOL oder BIT . Doppelklicken Sie zunächst auf einen Bit-Eingangskanal in Spalte Variablen . Ein Eingabefeld öffnet. Um eine bestehende Variable auf den Kanal zu legen, müssen Sie die gewünschte Projektvariable mit komplettem Pfad eintragen. Öffnen Sie über die Eingabehilfe. Wählen Sie beispielsweise die in PLC_PRG deklarierte Variable Application.PLC_PRG.xBool4 . Die Variable wird eingefügt. In der Spalte Mapping erscheint das Symbol . Die Adresse ist nun durchgestrichen. Das bedeutet nicht, dass die Adresse nicht mehr verfügbar ist, denn Werte von bestehenden Variablen werden auf einem anderen Speicherplatz verwaltet. Aber: Sie sollten die Adresse dennoch - speziell bei Ausgängen - nicht mit einer weiteren Variablen belegen, um Uneindeutigkeiten beim Schreiben der Werte zu vermeiden. Hinweis: Ab Compilerversion V3.5 SP11 wird für ein Mapping auf eine bestehende Variable automatisch der Initialisierungswert der Variablen als Standardwert verwendet. Das Feld Standardwert können Sie nur noch bearbeiten, wenn Sie ein Mapping auf eine neu erzeugte Variable vornehmen, oder wenn kein Mapping eingetragen ist. In älteren Versionen musste der Anwender explizit dafür sorgen, dass Standardwert und Initialisierungswert identisch sind. Löschen Sie die Variablenzuweisung wieder. Klicken Sie auf die Wurzel des Kanals, den BYTE -Knoten. Wählen Sie wieder über die Eingabehilfe die Variable Application.PLC_PRG.byte_gotodevice . Die Variable wird eingefügt, alle Bit-Adressen des Hauptkanals werden durchgestrichen und Sie sollten sie nicht zusätzlich belegen. " }, 
{ "title" : "Abbilden eines Geräteeingangs auf eine neu erzeugte Projektvariable ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_4032bba9628111e8accba0875c639f65", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Geräte konfigurieren und E\/A-Abbild konfigurieren \/ Abbilden eines Geräteeingangs auf eine neu erzeugte Projektvariable ", 
"snippet" : "Im Folgenden bilden Sie einen Geräteausgang auf eine globale implizite Variable ab, die Sie zu diesem Zweck direkt im Dialog E\/A-Abbild neu erzeugen. Somit ist der Dialog E\/A-Abbild ein weiterer Ort für das Deklarieren einer globalen Variable. Voraussetzung: Im Gerätebaum Ihres Projekts ist ein Gerä...", 
"body" : "Im Folgenden bilden Sie einen Geräteausgang auf eine globale implizite Variable ab, die Sie zu diesem Zweck direkt im Dialog E\/A-Abbild neu erzeugen. Somit ist der Dialog E\/A-Abbild ein weiterer Ort für das Deklarieren einer globalen Variable. Voraussetzung: Im Gerätebaum Ihres Projekts ist ein Gerät eingehängt, das eine E\/A-Abbildkonfiguration in CODESYS unterstützt. Somit sehen Sie im Geräteeditor auf Registerkarte E\/A-Abbild eine tabellenförmige Darstellung der Eingangs- und Ausgangskanäle des Geräts mit Angabe der Adressen und Datentypen. Öffnen Sie mit einem Doppelklick auf das Geräteobjekt im Gerätebaum den Geräteeditor, Registerkarte <Gerätename> E\/A-Abbild . Klicken Sie in der Mapping-Tabelle auf einen Kanaleintrag in Spalte Variable , um ein Eingabefeld zu öffnen. Geben Sie einen einfachen Namen (ohne „ . „) für eine neue Variable ein, Beispiel: myBool . CODESYS legt die Variable als implizite globale Variable im Projekt an weist sie der Kanaladresse direkt zu. Deshalb erscheint in diesem Fall die Adresse nicht durchgestrichen wie bei Mappings auf bestehende Variablen . " }, 
{ "title" : "Verknüpfen eines Gerätekanals mit einer Funktionsbaustein-Instanz ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_4bb85fcf744f3da7c0a8640e01facbb6", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Geräte konfigurieren und E\/A-Abbild konfigurieren \/ Verknüpfen eines Gerätekanals mit einer Funktionsbaustein-Instanz ", 
"snippet" : "Wenn es vom Gerät unterstützt wird, können Sie ganze Funktionsbausteine auf einen Eingangs- oder Ausgangskanal abbilden. Damit können Sie zu Wartungszwecken beispielsweise die Häufigkeit der Signaländerungen zählen oder einen Kanalwert skalieren. Im Folgenden bilden Sie einen Geräteausgangskanal auf...", 
"body" : "Wenn es vom Gerät unterstützt wird, können Sie ganze Funktionsbausteine auf einen Eingangs- oder Ausgangskanal abbilden. Damit können Sie zu Wartungszwecken beispielsweise die Häufigkeit der Signaländerungen zählen oder einen Kanalwert skalieren. Im Folgenden bilden Sie einen Geräteausgangskanal auf einen Funktionsbaustein ab. In diesem Beispiel skaliert der Baustein den Kanalausgangswert. Voraussetzung: Im Projekt ist ein Gerät mit digitalem Ausgang angebunden, das FB-Mapping unterstützt. Es gibt einen Funktionsbaustein Scale_Output_Int mit nachstehender Implementierung. Wichtig sind die Attribute am Baustein selbst und vor dem Ausgangsparameter, mit dem der Kanalausgang bearbeitet werden soll. {attribute 'io_function_block'}\nFUNCTION_BLOCK Scale_Output_Int\nVAR_INPUT\n iInput : INT;\n iNumerator : INT;\n iDenominator : INT :=1;\n iOffset : INT := 0;\nEND_VAR\nVAR_OUTPUT\n {attribute 'io_function_block_mapping'}\n iOutput : INT;\nEND_VAR\nVAR\nEND_VAR\nIF iDenominator <> 0 THEN\n iOutput := TO_INT(TO_DINT(iInput) * TO_DINT(iNumerator) \/ TO_DINT(iDenominator)) + iOffset; Öffnen Sie die Registerkarte E\/A-Abbild des Gerätemoduls. Doppelklicken Sie auf den Ausgang, der mit dem Funktionsbaustein verbunden werden soll. Klicken Sie auf die Schaltfläche FB für E\/A-Kanal hinzufügen . Der Dialog Funktionsbaustein auswählen öffnet sich. Im linken Teil sehen Sie unter dem Knoten Applikation mindestens den Baustein Scale_Output_int . Wenn Bibliotheken im Projekt eingebunden sind, die entsprechende Bausteine enthalten, erscheinen auch diese zur Auswahl. Wählen Sie den Baustein myScaleOutputInt . Nach Bestätigen mit OK wird der Pfad des Funktionsbausteinparameters iOutput in der Spalte Variable im Mapping-Dialog eingetragen. Der Pfad setzt sich aus dem Applikationsnamen, dem Gerätekanalnamen und dem gewählten FB-Ausgang zusammen: Beispiel App1.Out_4_Int_myScale_Output_Int_1.iOutput . Selektieren Sie den Kanaleintrag und wählen Sie die Schaltfläche Gehe zu Instanz . Der Fokus wechselt zur Registerkarte <Gerätename> IEC-Objekte zum dort angelegten Eintrag für das neue IEC-Objekt Out_4_Int_myScale_Output_Int_1 . Im Onlinebetrieb sehen Sie in dieser Ansicht den aktuellen, durch den FB skalierten Wert des Parameters iOutput für den Kanal Out_4_Int . Sie können den Wert wie in anderen Monitoringansichten auch schreiben und forcen. Für weitere Informationen siehe: Registerkarte: <Gerätename> IEC-Objekte und io_function_block, io_function_block_mapping" }, 
{ "title" : "Ändern und Fixieren eines Adresswerts im E\/A-Abbild ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_0f670058744f3da8c0a8640e01f6b4b2", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Geräte konfigurieren und E\/A-Abbild konfigurieren \/ Ändern und Fixieren eines Adresswerts im E\/A-Abbild ", 
"snippet" : "Sie können den Adresswert eines gesamten Kanals (nicht den eines einzelnen Unterelements des Kanals!) in der Mapping-Tabelle auf der Registerkarte <Gerätename> E\/A-Abbild ändern und fixieren. Das erlaubt, die Adressierung an eine vorgegebene Maschinenkonfiguration anzupassen und den Adresswert auch ...", 
"body" : "Sie können den Adresswert eines gesamten Kanals (nicht den eines einzelnen Unterelements des Kanals!) in der Mapping-Tabelle auf der Registerkarte <Gerätename> E\/A-Abbild ändern und fixieren. Das erlaubt, die Adressierung an eine vorgegebene Maschinenkonfiguration anzupassen und den Adresswert auch dann beizubehalten, wenn sich die Anordnung der Module ändert. Standardmäßig führt eine Änderung der Anordnung nämlich zu einer automatischen Anpassung der Adresswerte. Voraussetzung: Sie haben ein Projekt mit E\/A-Abbild. Sehen Sie die entsprechenden obenstehenden Abschnitte der Hilfeseite. Öffnen Sie mit einem Doppelklick auf das Geräteobjekt im Gerätebaum den Geräteeditor, Registerkarte <Gerätename> E\/A-Abbild . Klicken Sie in der Mapping-Tabelle auf einen Kanaleintrag in Spalte Adresse , um ein Eingabefeld zu öffnen. Dies ist nur für die „Root“-Adresse eines Kanals möglich, nicht für eine einzelne seiner Unterelemente! Ändern Sie deshalb den obersten Adresseintrag eines Kanals in der Tabelle, beispielsweise von QB0 auf QB1 . Verlassen Sie das Eingabefeld. Der Adresswert ist verändert. Vor der Adresse erscheint das Symbol . Es zeigt an, dass die Adresse fixiert ist. Auch die Adressen der Unterelemente des Kanals werden entsprechend geändert. Wenn Sie nun im Gerätebaum die Position des Geräteobjekts innerhalb anderer Geräteobjekte mit Eingangs-\/Ausgangskanälen ändern, passt CODESYS diese Adressen nicht der neuen Reihenfolge an, wie es ohne Fixierung der Fall wäre. Um die manuelle Änderung bzw. Fixierung rückgängig zu machen, öffnen Sie erneut das Eingabefeld des Adresswerts, löschen den Adresseintrag und drücken die Eingabetaste. CODESYS setzt die Adresse und die betroffenen nachfolgenden Adressen auf die Werte zurück, die sie vor der Änderung hatten und entfernt das Symbol . Für weitere Informationen siehe: Adressen" }, 
{ "title" : "Konfigurieren der E\/A-Variablenaktualisierung ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_1bb5439b6f5b4e88c0a8640e00b2518b", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Geräte konfigurieren und E\/A-Abbild konfigurieren \/ Konfigurieren der E\/A-Variablenaktualisierung ", 
"snippet" : "Abhängig vom Gerät, das Sie im Projekt anbinden, aktualisiert in CODESYS die an dessen Eingängen und Ausgängen anliegenden Variablen in unterschiedlicher Art. Sie können die Einstellungen dazu im Dialog E\/A-Abbild explizit umstellen....", 
"body" : "Abhängig vom Gerät, das Sie im Projekt anbinden, aktualisiert in CODESYS die an dessen Eingängen und Ausgängen anliegenden Variablen in unterschiedlicher Art. Sie können die Einstellungen dazu im Dialog E\/A-Abbild explizit umstellen. " }, 
{ "title" : "Monitoring von Variablen im E\/A-Abbild im Onlinebetrieb ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_e1f8bef86f5b4e89c0a8640e00daea27", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Geräte konfigurieren und E\/A-Abbild konfigurieren \/ Monitoring von Variablen im E\/A-Abbild im Onlinebetrieb ", 
"snippet" : "Voraussetzung: Sie haben eine Applikation mit einer Gerätekonfiguration, die E\/A-Abbilder enthält, fehlerfrei übersetzt. Die zugehörige Hardware und das Bussystem laufen. Sie haben sich mit dem Befehl Online → Einloggen auf die Steuerung verbunden, die Applikation geladen und gestartet. Öffnen Sie d...", 
"body" : "Voraussetzung: Sie haben eine Applikation mit einer Gerätekonfiguration, die E\/A-Abbilder enthält, fehlerfrei übersetzt. Die zugehörige Hardware und das Bussystem laufen. Sie haben sich mit dem Befehl Online → Einloggen auf die Steuerung verbunden, die Applikation geladen und gestartet. Öffnen Sie die Registerkarte E\/A-Abbild des Steuerungsgeräts im Geräteeditor. Zum Öffnen des Editors doppelklicken Sie auf das Geräteobjekt im Gerätebaum. Die Mapping-Tabelle enthält nun zusätzlich die Spalten Aktueller Wert und Neuer Wert . Wenn eine Strukturvariable auf das „Root“-Element einer Adresse 1 abgebildet ist, zeigt CODESYS im Onlinebetrieb in dieser Zeile keinen Wert an. Wenn jedoch beispielsweise eine DWORD -Variable auf die Adresse abgebildet ist, werden sowohl in der „Root“-Zeile als auch in den darunter eingerückten Bit-Kanal-Zeilen die jeweiligen Werte gemonitort. Grundsätzlich bleibt das Feld in der „Root“-Zeile immer dann leer, wenn sich der Wert aus mehreren Unterelementen zusammensetzen würde. 1 „Root“ = oberstes Element dieser Adresse im Mapping-Dialog Tragen Sie für einen Eintrag in der Spalte Neuer Wert einen bestimmten Variablenwert ein und drücken F7 für ein Forcen oder Strg + F7 für ein Schreiben des Werts. In der Spalte Aktueller Wert wird - wie beim Monitoring im Deklarationseditor oder in Überwachungslisten - der geforcte Variablenwert mit vorangestelltem roten F-Symbol oder der geschriebene Wert angezeigt. Im Onlinebetrieb werden Ein- und Ausgänge, welche der SPS-Code NICHT verwendet, von der SPS nicht gelesen, wodurch der angezeigte Wert falsch sein könnte. Der Aktuelle Wert der betroffenen Variablen erscheint mit einem grauen Hintergrund. " }, 
{ "title" : "Erzeugen impliziter Variablen zum Forcen von E\/As ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_3a1310c2796cb504c0a8640e01d0e08f", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Geräte konfigurieren und E\/A-Abbild konfigurieren \/ Erzeugen impliziter Variablen zum Forcen von E\/As ", 
"snippet" : "Während der Inbetriebnahme einer Anlage oder Maschine kann es erforderlich sein, die auf Eingängen und Ausgängen anliegenden Werte zu „forcen“. Wenn ein Gerät dies unterstützt, können Sie zu diesem Zweck spezielle „Force-Variablen“ erzeugen lassen und diese beispielsweise in einer HMI-Visualisierung...", 
"body" : "Während der Inbetriebnahme einer Anlage oder Maschine kann es erforderlich sein, die auf Eingängen und Ausgängen anliegenden Werte zu „forcen“. Wenn ein Gerät dies unterstützt, können Sie zu diesem Zweck spezielle „Force-Variablen“ erzeugen lassen und diese beispielsweise in einer HMI-Visualisierung verwenden. Voraussetzung: Das Gerät unterstützt die Funktionalität. Sie haben ein Projekt, in dem ein E\/A-Abbild für das Gerät konfiguriert ist und ein Programmobjekt PLC_PRG enthalten ist. Öffnen Sie mit einem Doppelklick auf das Geräteobjekt im Gerätebaum den Geräteeditor, Registerkarte SPS-Einstellungen . Aktivieren Sie die Option Force-Variablen für das E\/A-Abbild erzeugen . Drücken Sie F11 , um die Applikation zu übersetzen. Für jeden E\/A-Kanal werden zwei Variablen angelegt. gemäß der folgenden Syntax, wobei Leerzeichen im Kanalnamen mit Unterstrichen ersetzt werden: <Gerätename>_<Kanalname>_<IECAdresse>_Force vom Typ BOOL für das Aktivieren und Deaktivieren des Forcens <Gerätename>_<Kanalname>_<IECAdresse>_Value vom Datentyp des Kanals für das Definieren des Wertes, den Sie am Kanal forcen wollen Diese Variablen sind in der Eingabehilfe in Kategorie Variablen \/ IoConfig_Globals_Force_Variables verfügbar. Sie können sie in Programmierobjekten, in Visualisierungen, in der Symbolkonfiguration etc. in CODESYS verwenden. Öffnen Sie den Baustein PLC_PRG , setzen Sie den Fokus in den Implementierungsteil und drücken F2 . Die Eingabehilfe öffnet. In Kategorie Variablen \/ IoConfig_Globals_Force_Variables stehen die Variablen wie oben beschrieben bereit. Eine steigende Flanke an der „Force-Variable“ aktiviert das Forcen des jeweiligen Eingangs oder Ausgangs mit dem Wert, der durch die „Value-Variable“ gegeben ist. Eine fallende Flanke deaktiviert das Forcen. Das Deaktivieren durch Rücksetzen der „Force“-Variable auf FALSE ist Voraussetzung dafür, dass ein neuer Wert geforcet werden kann! Beachten Sie die folgenden Einschränkungen! Das Forcen über die impliziten Force-Variablen ist nur möglich für Kanäle, die im E\/A-Abbild des Geräts auf eine bestehende oder neu angelegte Variable abgebildet sind. Das Forcen über die impliziten Force-Variablen ist nicht möglich für nicht verwendete Eingänge und Ausgänge, sowie solche, die über eine AT-Deklaration in einem Applikationsprogramm auf eine Variable abgebildet sind. E\/A-Kanäle, die Sie über den Mechanismus forcen wollen, muss CODESYS in mindestens einer Task verwenden. CODESYS kennzeichnet geforcte Eingänge im Monitoring mit dem roten Force-Symbol, nicht jedoch geforcte EinAusgänge! Der geforcte Wert wird nur implizit vom E\/A-Treiber für das Schreiben auf das Gerät verwendet. Für weitere Informationen siehe: Forcen und Schreiben von Variablen" }, 
{ "title" : "E\/A-Abbild in 1 Dialog für mehrere Geräte ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_index_21", 
"breadcrumbs" : "CODESYS Essentials \/ E\/A-Anbindung konfigurieren \/ Geräte konfigurieren und E\/A-Abbild konfigurieren \/ E\/A-Abbild in 1 Dialog für mehrere Geräte ", 
"snippet" : "Es gibt eine Tabelle, die das E\/A-Abbild eines Geräts plus die E\/A-Abbilder aller unter ihm im Gerätebaum eingehängten Subelemente darstellt. Sie können dort die E\/A-Abbilder genauso bearbeiten wie in den einzelnen Mapping-Tabellen der jeweiligen Geräteeditoren. Voraussetzung: Im Gerätebaum Ihres Pr...", 
"body" : "Es gibt eine Tabelle, die das E\/A-Abbild eines Geräts plus die E\/A-Abbilder aller unter ihm im Gerätebaum eingehängten Subelemente darstellt. Sie können dort die E\/A-Abbilder genauso bearbeiten wie in den einzelnen Mapping-Tabellen der jeweiligen Geräteeditoren. Voraussetzung: Im Gerätebaum Ihres Projekts sind mehrere Steuerungsgeräte eingehängt, die jeweils eine E\/A-Abbildkonfiguration ermöglichen. Selektieren Sie den Wurzelknoten des Gerätebaums und wählen Sie im Kontextmenü den Befehl E\/A-Abbild bearbeiten . Der Dialog E\/A-Abbild bearbeiten erscheint, in dem die E\/A-Abbildkonfiguration aller im Projekt eingehängten Geräte in einer Tabelle erscheinen. Sie können die Einträge bearbeiten wie im Dialog E\/A-Abbild des zugehörigen Geräteeditors. Selektieren Sie nun im Gerätebaum eines der Steuerungsobjekte und wählen Sie erneut im Kontextmenü den Befehl E\/A-Abbild bearbeiten . Der Dialog E\/A-Abbild bearbeiten zeigt nun nur noch die E\/A-Tabelle für die im und unter dem selektierten Objekt gefundenen E\/A-Abbildkonfigurationen. Setzen Sie in der Leiste oberhalb der Tabelle einen gewünschten Filter oder geben Sie im Feld Suche Variable einen Variablennamen ein, um die Verwendung dieser Variable im Mapping zu sehen. Das Arbeiten im Fenster funktioniert wie für die Registerkarte <Gerätename> E\/A-Abbild beschrieben. " }, 
{ "title" : "Applikation programmieren ", 
"url" : "_cds_struct_application_programming.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren ", 
"snippet" : "Um ein auf der Steuerung lauffähiges Applikationsprogramm, zu erstellen, füllen Sie POUs mit Deklarationen und Implementierungscode (Quellcode), stellen die Verknüpfung der E\/As der Steuerung mit Applikationsvariablen her und konfigurieren eine Taskzuordnung. Nach Prüfung und Fehlerbeseitigung erste...", 
"body" : "Um ein auf der Steuerung lauffähiges Applikationsprogramm, zu erstellen, füllen Sie POUs mit Deklarationen und Implementierungscode (Quellcode), stellen die Verknüpfung der E\/As der Steuerung mit Applikationsvariablen her und konfigurieren eine Taskzuordnung. Nach Prüfung und Fehlerbeseitigung erstellt der CODESYS -Compiler dann den Applikationscode, der auf die Steuerung geladen werden kann. Die Programmierung der Applikationsbausteine (POUs) wird unterstützt durch die Programmierspracheneditoren und einigen weiteren Funktionalitäten wie beispielsweise Textlisten , Bildersammlungen , Alarmkonfiguration , Pragmas , Refactoring und Verwendung von fertigen Bausteinen aus CODESYS Development System oder Bibliotheken. Es gibt Mittel zur Syntaxprüfung und Codeanalyse, zum Herstellen von Datenpersistenz und zur Verschlüsselung des Applikationscodes, der auf die Steuerung geladen wird. " }, 
{ "title" : "Bezeichner vergeben ", 
"url" : "_cds_naming_identifiers.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Bezeichner vergeben ", 
"snippet" : "Bezeichner sind die Namen von Variablen und Programmierobjekten, zum Beispiel Programme, Funktionsbausteine, Methode etc. und Namen anderer Objekte der Applikation und des Projekts. Es gibt Regeln, die Sie bei der Vergabe von Bezeichner einhalten müssen. Darüber hinaus gibt es Empfehlungen, die dazu...", 
"body" : "Bezeichner sind die Namen von Variablen und Programmierobjekten, zum Beispiel Programme, Funktionsbausteine, Methode etc. und Namen anderer Objekte der Applikation und des Projekts. Es gibt Regeln, die Sie bei der Vergabe von Bezeichner einhalten müssen. Darüber hinaus gibt es Empfehlungen, die dazu dienen, die Bezeichner einheitlich und aussagekräftig zu gestalten. Die Bezeichner von Variablen vergeben Sie bei der Variablendeklaration. Sie können diese Bezeichner im Deklarationsteil des Programmierobjekts ändern. Die Bezeichner für Programmierobjekte und andere Objekte vergeben Sie im Dialog beim Hinzufügen des jeweiligen Objekts. Sie können den Bezeichner eines bestehenden Objekts der Applikation oder des Projekts im Eigenschaftendialog des Objekts ändern. Allerdings können Sie die Bezeichner von Objekten, die nur einmal pro Applikation oder nur einmal pro Projekt vorhanden sein können, nicht ändern, zum Beispiel die Bezeichner Bibliotheksverwalter und ImagePool . Für weitere Informationen siehe: Bezeichnervergabe" }, 
{ "title" : "UTF-8-Kodierung ", 
"url" : "_cds_utf8_encoding.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ UTF-8-Kodierung ", 
"snippet" : "Grundlegendes Applikationen in CODESYS können unterschiedlichste Zeichen verarbeiten, um beispielsweise eine Fehlermeldung in einer Vielzahl von Sprachen auszugeben. Oder um Visualisierungen in einer vom Benutzer auswählbaren Sprache anzuzeigen, die Benutzereingaben in den unterschiedlichsten Sprach...", 
"body" : "Grundlegendes Applikationen in CODESYS können unterschiedlichste Zeichen verarbeiten, um beispielsweise eine Fehlermeldung in einer Vielzahl von Sprachen auszugeben. Oder um Visualisierungen in einer vom Benutzer auswählbaren Sprache anzuzeigen, die Benutzereingaben in den unterschiedlichsten Sprachen, Zeichen oder Symbolen akzeptiert. Wenn ein umfassender Zeichensatz nicht nötig ist, oder wenn ein Projekt nicht geändert werden soll, kann weiterhin im Latin-1-Format kodierte Strings verwendet werden. Zeichensatztabellen Zeichensatz Codepage-Nummer Beschreibung Zeichenkodierung ASCII 20127 128 Zeichen Geeignet für englische Texte 7-Bit kodiertes Zeichen DOS-Latin-1 819, 850 Entspricht ISO 8859 Geeignet für westeuropäische Sprachen im Windows-Kommandozeilenfenster 8-Bit kodiertes Zeichen Latin-1 28591 Entspricht ISO-8859-1 Häufig verwendet für HTML-Seiten mit äöüß, aber ohne € oder beispielsweise ohne französische Sonderzeichen 8-Bit kodiertes Zeichen Windows 1252 Kodierung 1252 Windows-Standardzeichensatz für westeuropäische Länder Intern verwendet Windows das UTF-16-Format Enthält alle Zeichen aus ISO 8859-1 und ISO 8859-15, allerdings teilweise mit anderer Kodierung 8-Bit kodiertes Zeichen Unicode Universeller Zeichensatz für alle möglichen Sprachen, auch historische Sprachen, Blindenschrift, Musik oder Emojis Mehr als 100 000 Schriftzeichen darstellbar Jedes Zeichen hat einen numerischen Code Trennt im Unterschied zu ASCII zwischen der Zuordnung von Codepoints zu Zeichen und der Codierung der Zeichen Numerische Code < 128 sind ASCII kompatibel Numerische Codes < 256 sind ISO 8859-1 kompatibel Für weitere Informationen siehe: https:\/\/home.unicode.org\/ Unicode 14.0 144697 Zeichen UTF-16 1200 Spezielles Unicode Wird in einigen Betriebssystemen (Windows, OS X) und Programmiersprachen (Java, .NET) für die interne Zeichendarstellung verwendet Zu beachten ist, dass unterschiedliche Rechnerarchitekturen die 4-Byte-Zeichen unterschiedlich kodieren Little-endian-Byte-Reihenfolge bei UTF-16LE 16 -Bit kodiertes Zeichen Die Zeichen werden entweder in 2 Bytes oder in 4 Bytes kodiert UTF-8 65001 Byte orientiertes Kodierungsformat von Unicode-Zeichen Am weitesten verbreitet Wird in den Betriebssystemen GNU\/Linux und Unix, und in verschiedenen Internetdiensten (E-Mail, Web, Browser) verwendet Ist in den ersten 128 Zeichen von 0..127 kompatibel zu ASCII-Zeichen Tupel von 8-Bit Worten pro Zeichen Die Zeichen werden in verschiedener Länge von 1 bis 4 Bytes kodiert " }, 
{ "title" : "UTF-8 in CODESYS ", 
"url" : "_cds_utf8_encoding.html#UUID-7e4361ae-d07f-2866-46cf-cabba3de11bf_section-idm4579545478443232896837520979", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ UTF-8-Kodierung \/ UTF-8 in CODESYS ", 
"snippet" : "Die UTF-8-Kodierung ist die Kodierung mit dem umfassendsten Zeichensatz. Daher ist es empfehlenswert für neue Projekte sowie für bestehende Projekte, die in einem neuen Kontext eingesetzt werden sollen, die UTF-8-Kodierung zu aktivieren. Projektweite Kodierungen in CODESYS Datentyp Compile-Option: U...", 
"body" : "Die UTF-8-Kodierung ist die Kodierung mit dem umfassendsten Zeichensatz. Daher ist es empfehlenswert für neue Projekte sowie für bestehende Projekte, die in einem neuen Kontext eingesetzt werden sollen, die UTF-8-Kodierung zu aktivieren. Projektweite Kodierungen in CODESYS Datentyp Compile-Option: UTF8-Kodierung für STRING Welcher Kodierung wird projektweit verwendet? STRING Aktiviert UTF-8 Deaktiviert Windows 1252 Kodierung (Default Windows Encoding) Latin-1 WRTRING Aktiviert UTF-16 Deaktiviert UTF-16 In CODESYS kann der Datentyp STRING in den Formaten Latin-1 oder UTF-8, codiert werden. Der WSTRING -Datentyp codiert seine Zeichen immer als Unicode in UTF-16. " }, 
{ "title" : "Einzelnes Stringliteral im UTF-8-Format kodieren ", 
"url" : "_cds_utf8_encoding.html#UUID-7e4361ae-d07f-2866-46cf-cabba3de11bf_section-idm4663754559772832898653408592", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ UTF-8-Kodierung \/ UTF-8 in CODESYS \/ Einzelnes Stringliteral im UTF-8-Format kodieren ", 
"snippet" : "Auch wenn das projektweite Kodierungsformat auf Latin-1 eingestellt ist, können Sie eine einzelne Literale im UTF-8-Format kodieren. Stellen Sie dafür dem Literal das Typpräfix UTF8# vor. {attribute 'monitoring_encoding' := 'UTF-8'} strVarUtf8: STRING := UTF8#'你好,世界!ÜüÄäÖö'; Für weitere Informatione...", 
"body" : "Auch wenn das projektweite Kodierungsformat auf Latin-1 eingestellt ist, können Sie eine einzelne Literale im UTF-8-Format kodieren. Stellen Sie dafür dem Literal das Typpräfix UTF8# vor. {attribute 'monitoring_encoding' := 'UTF-8'}\nstrVarUtf8: STRING := UTF8#'你好,世界!ÜüÄäÖö'; Für weitere Informationen siehe: Konstante: UTF8#-String, Pragmaattribut: monitoring_encoding" }, 
{ "title" : "Stringkonvertierung bei UTF-8-Kodierung ", 
"url" : "_cds_utf8_encoding.html#UUID-7e4361ae-d07f-2866-46cf-cabba3de11bf_section-idm4525865800604832898698002139", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ UTF-8-Kodierung \/ UTF-8 in CODESYS \/ Stringkonvertierung bei UTF-8-Kodierung ", 
"snippet" : "Wenn Sie die UTF-8-Kodierung projektweit aktiviert haben, können Sie die Stringkonvertierungsfunktionen wie üblich verwenden....", 
"body" : "Wenn Sie die UTF-8-Kodierung projektweit aktiviert haben, können Sie die Stringkonvertierungsfunktionen wie üblich verwenden. " }, 
{ "title" : "Stringmanipulation ", 
"url" : "_cds_utf8_encoding.html#UUID-7e4361ae-d07f-2866-46cf-cabba3de11bf_section-idm4524271435323232898709825848", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ UTF-8-Kodierung \/ UTF-8 in CODESYS \/ Stringmanipulation ", 
"snippet" : "Verwenden Sie Bibliotheksfunktionen, um Ihre Strings zu manipulieren Wenn STRING -Variable manipuliert werden sollen, führt ein Indexzugriff auf eine Variable im ASCII-Format oft zu dem gewünschten Resultat. Verwenden Sie dieses Konstrukt besser nicht. Es ist nicht nur ein schlechter Programmierstil...", 
"body" : "Verwenden Sie Bibliotheksfunktionen, um Ihre Strings zu manipulieren Wenn STRING -Variable manipuliert werden sollen, führt ein Indexzugriff auf eine Variable im ASCII-Format oft zu dem gewünschten Resultat. Verwenden Sie dieses Konstrukt besser nicht. Es ist nicht nur ein schlechter Programmierstil. Erschwerend kommt hinzu, dass bei UTF-8-Kodierung der Indexzugriff zu unerwünschten Stringmanipulationen führt. UTF-8-Kodierung nur bei projektweiter Konfigurierung Eine UTF-8-Kodierung wird verwendet, wenn die projektweit gültige Compile-Option UTF8-Kodierung für STRING aktiviert ist. Bibliotheksfunktionen und Add-ons orientieren sich dann auch gemäß diesem Setting. Wenn Sie einzelne UTF-8 kodierte Strings verwenden, dann müssen Sie dafür Sorge tragen, dass diese überall dort, wo sie verwendet werden, auch richtig interpretiert werden. Eine String-Variable im OPC-Server wird zum Beispiel vor der Übertragung zu einem Client nach UTF-8 konvertiert, wenn das Setting nicht angewählt ist. Werte wie beispielsweise UTF8#'äöü' würden dann falsch interpretiert werden. Ähnliche Probleme können bei der Ausgabe von Strings in der Visualisierung entstehen. " }, 
{ "title" : "Variablendeklaration ", 
"url" : "_cds_f_declaring_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration ", 
"snippet" : "Variablendeklaration wo und wie Sie können Variablen an folgenden Stellen deklarieren: Deklarationsteil eines Programmierobjekts Der Dialog Variable deklarieren unterstützt Sie dabei. Variablenlisten (GVL-Editor, NVL-Editor) E\/A-Abbildkonfiguration eines E\/A-Geräteobjekts Für weitere Informationen s...", 
"body" : "Variablendeklaration wo und wie Sie können Variablen an folgenden Stellen deklarieren: Deklarationsteil eines Programmierobjekts Der Dialog Variable deklarieren unterstützt Sie dabei. Variablenlisten (GVL-Editor, NVL-Editor) E\/A-Abbildkonfiguration eines E\/A-Geräteobjekts Für weitere Informationen siehe: Geräte konfigurieren und E\/A-Abbild konfigurierenFür weitere Informationen siehe: Tastaturkürzel bei der Variablendeklaration" }, 
{ "title" : "Syntax ", 
"url" : "_cds_f_declaring_variables.html#UUID-ef4aa32b-23c7-a688-0472-86ee8eb95613_section-idm2347730964863", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration \/ Syntax ", 
"snippet" : "<pragma> <scope> <type qualifier>     <identifier> AT <address> : <data type> := <initial value> ; END_VAR <pragma> Wiederholt optional (nie, einmal oder mehrmals) Pragma Ein Pragma ist eine Compiler-Anweisung, um beispielsweise Optimierungen wie Speicherplatzbedarf oder Laufzeitverbesserungen zu er...", 
"body" : "<pragma> <scope> <type qualifier>     <identifier> AT <address> : <data type> := <initial value> ; END_VAR <pragma> Wiederholt optional (nie, einmal oder mehrmals) Pragma Ein Pragma ist eine Compiler-Anweisung, um beispielsweise Optimierungen wie Speicherplatzbedarf oder Laufzeitverbesserungen zu erreichen. Pragmas verwendenPragmas<scope> Obligatorisch Gültigkeitsbereich VAR VAR_CONFIG Hinweis: Wenn in Funktionsbausteinen Variablen mit unvollständigen Adressangaben (beispielsweise AT %I* ) deklariert sind, müssen die Variablen in der Variablenkonfiguration VAR_CONFIG fertig deklariert werden. Erst dann können Sie auf eine solche Variable in einer lokalen Instanz zugreifen. VAR_EXTERNAL VAR_GLOBAL VAR_INPUT VAR_INST VAR_IN_OUT VAR_OUTPUT VAR_STAT VAR_TEMP VARVAR_CONFIGVAR_EXTERNALVAR_GLOBALGVLVAR_INPUTVAR_INSTVAR_IN_OUTVAR_OUTPUTVAR_STATVAR_TEMP<type qualifier> Optional Typqualifizierer CONSTANT RETAIN PERSISTENT CONSTANTRETAINPERSISTENT<identifier> Obligatorisch Bezeichner, Variablenname Hinweis: Die im Kapitel „Bezeichnervergabe“ aufgeführten Regeln müssen Sie bei der Vergabe eines Bezeichners zwingend beachten. Zusätzlich finden Sie dort Empfehlungen zur Vereinheitlichung bei der Namensvergabe. BezeichnervergabeAT %<address> Optional Die Adresse setzt sich zusammen aus: <Speicherbereich> <optionales Größenpräfix> <Speicherposition> Der Speicherbereich ist aufgeteilt in Eingangs-, Ausgangs- oder Merkerspeicherbereich ( I , Q oder M ) Beispiel AT %I* \/\/ Incomplete address AT %I7.5 AT %IW0 AT %QX7.5 AT %MD48 Geräte konfigurieren und E\/A-Abbild konfigurierenAT-DeklarationAdressen<data type> Obligatorisch Datentyp Elementarer Datentyp Benutzerdefinierter Datentyp Funktionsbaustein DatentypenDUTFunktionsbaustein<initial value> Optional Initialwert, Initialisierung als Literal, Variable oder Ausdruck Konstanten und Literale ST-AusdrückeBeispiel Globale Variablenliste GVL {attribute 'qualified_only'}\n{attribute 'linkalways'}\nVAR_GLOBAL CONSTANT\n g_ciMAX_A : INT := 100;\n g_ciSPECIAL : INT := g_ciMAX_A - 10;\nEND_VAR Konfigurationsvariablen GVL_CONFIG {attribute 'qualified_only'}\nVAR_CONFIG\n \/\/ Generated instance path of variable at incomplete address\n PLC_PRG.fbDoItNow.XLOCINPUT AT %I*: BOOL := TRUE;\nEND_VAR Funktionsbaustein FB_DoIt METHOD METH_Last : INT\nVAR_INPUT\n iVar : INT;\nEND_VAR\nVAR_INST\n iLast : INT := 0;\nEND_VAR\n\nMETH_Last := iLast;\niLast := iVar;\n\nFUNCTION_BLOCK FB_DoIt\nVAR_INPUT\n wInput AT %IW0 : WORD; (* Input variable *)\nEND_VAR\nVAR_OUTPUT\n wOutput AT %QW0 : WORD; (* Output variable *)\nEND_VAR\nVAR_IN_OUT\n aData_A : ARRAY[0..1] OF DATA_A; \/\/ Formal variable\nEND_VAR\nVAR_EXTERNAL\n GVL.g_ciMAX_A : INT; \/\/ Declared in object GVL\nEND_VAR\nVAR_STAT\n iNumberFBCalls : INT;\nEND_VAR\nVAR\n iCounter: INT;\n xLocInput AT %I* : BOOL := TRUE; \/\/ VAR_CONFIG\nEND_VAR\n\niNumberFBCalls := iNumberFBCalls + 1; IEC-Programm PLC_PRG PROGRAM PLC_PRG\nVAR\n iLoop: INT;\n iTest: INT;\n fbDoItNow : FB_DoIt;\n iTest_200: INT;\n aData_Now : ARRAY[0..1] OF DATA_A := [(iA_1 := 1, iA_2 := 10, dwA_3 := 16#00FF),(iA_1 := 2, iA_2 := 20, dwA_3 := 16#FF00)];\nEND_VAR\n\niTest := GVL.g_ciMAX_A;\niTest_200 := 2 * GVL.g_ciMAX_A;\nfbDoItNow(aData_A := aData_Now);\nFOR iLoop := 0 TO GVL.g_ciSPECIAL DO\n ;\nEND_FOR " }, 
{ "title" : "Variableninitialisierung ", 
"url" : "_cds_variables_initialization.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration \/ Variableninitialisierung ", 
"snippet" : "Der Standard-Initialisierungswert für alle Deklarationen ist 0 . Im Deklarationsteil können Sie für jede Variable und jeden Datentyp auch benutzerdefinierte Initialisierungswerte angeben. Die benutzerdefinierte Initialisierung beginnt mit dem Zuweisungsoperator := und besteht aus einem beliebigen, g...", 
"body" : "Der Standard-Initialisierungswert für alle Deklarationen ist 0 . Im Deklarationsteil können Sie für jede Variable und jeden Datentyp auch benutzerdefinierte Initialisierungswerte angeben. Die benutzerdefinierte Initialisierung beginnt mit dem Zuweisungsoperator := und besteht aus einem beliebigen, gültigen Ausdruck der Programmiersprache ST (strukturierter Text). Somit definieren Sie den Initialisierungswert mit Hilfe von Konstanten, anderen Variablen oder Funktionen. Wenn Sie eine Variable verwenden, müssen Sie diese ebenfalls initialisieren. Standard-Initialisierungswerte Datentyp Initialisierungswert beliebiger Zahlendatentyp 0 jeder Pointer 0 BOOL FALSE ARRAY OF Der Standard-Initialisierungswert von jedem Element Struktur Wenn für die einzelnen Elemente kein expliziter Wert in der Deklaration festgelegt wurde, ist der Standardwert des Datentyps der Initialisierungswert. Beispiele VAR\n var1:INT := 12; \/\/initialization value 12\n x : INT := 13 + 8; \/\/initalization value defined by an expression of constants\n y : INT := x + fun(4); \/\/initialization value defined by an expression,\n \/\/that contains a function call; notice the order!\n z : POINTER TO INT := ADR(y); \/\/not described in the standard IEC61131-3:\n \/\/ initialization value defined by an adress function;\n \/\/ Notice: In this case the pointer will not be initialized\n \/\/ during an Online Change *)\nEND_VAR Hinweise zur Initialisierungsreihenfolge Als erstes die Konstanten Ab Compiler-Version 3.5.3.40 werden Variablen in einem Funktionsbaustein in folgender Reihenfolge initialisiert: Zuerst alle Konstanten gemäß der Reihenfolge ihrer Deklarationen, danach alle anderen Variablen gemäß der Reihenfolge ihrer Deklarationen. Globale Variablen vor lokalen Variablen Ab Compiler-Version 3.3.2.0 werden Variablen aus globalen Variablenlisten immer vor den lokalen Variablen einer POU initialisiert. Für weitere Informationen siehe Deklaration und Initialisierung von Strukturvariablen und Pragma ' global_init_slot'. " }, 
{ "title" : "Deklarationseditor verwenden ", 
"url" : "_cds_declaration_editor_basics.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration \/ Deklarationseditor verwenden ", 
"snippet" : "Der Deklarationseditor dient der Deklaration von Variablen in Variablenlisten und POUs. Im Deklarationseditor werden zwei Ansichten bereitgestellt tabellarische Ansicht textuelle Ansicht Im Dialog Tools → Optionen → Deklarationseditor können Sie einstellen, ob nur die Textansicht oder nur die Tabell...", 
"body" : "Der Deklarationseditor dient der Deklaration von Variablen in Variablenlisten und POUs. Im Deklarationseditor werden zwei Ansichten bereitgestellt tabellarische Ansicht textuelle Ansicht Im Dialog Tools → Optionen → Deklarationseditor können Sie einstellen, ob nur die Textansicht oder nur die Tabellenansicht verfügbar sein soll. Oder ob Sie mit den Schaltflächen am rechten Rand des Editorfensters zwischen den beiden Ansichten wechseln können. Wenn der Deklarationseditor in Verbindung mit einem Programmiersprachen-Editor verwendet wird, erscheint er als Deklarationsteil im oberen Teil des Fensters einer POU. " }, 
{ "title" : "Deklarieren im tabellarischen Deklarationseditor ", 
"url" : "_cds_declaration_editor_basics.html#UUID-c2687aff-7cd6-bd33-2c3c-16ea3266af11_id_c44c3e624d92f81c0a8640e01901bfe_id_5e92db7bc6203aeec0a8640e00c25a63", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration \/ Deklarationseditor verwenden \/ Deklarieren im tabellarischen Deklarationseditor ", 
"snippet" : "Im tabellarischen Deklarationseditor fügen Sie Variablendeklarationen in einer Tabelle mit den folgenden Spalten ein: Gültigkeitsbereich , Name , Adresse , Datentyp , Initialisierung , Kommentar und Attribute (Pragmas). Die Tabellenansicht erfordert keine detaillierten Kenntnisse der Syntax. Vorauss...", 
"body" : "Im tabellarischen Deklarationseditor fügen Sie Variablendeklarationen in einer Tabelle mit den folgenden Spalten ein: Gültigkeitsbereich , Name , Adresse , Datentyp , Initialisierung , Kommentar und Attribute (Pragmas). Die Tabellenansicht erfordert keine detaillierten Kenntnisse der Syntax. Voraussetzung: Sie haben ein Programmierobjekt (POU oder GVL) eines Projekts geöffnet. Der Fokus liegt auf dem tabellarischen Deklarationseditor. Klicken Sie auf Schaltfläche im Deklarationskopf oder wählen Sie den Befehl Einfügen im Kontextmenü. Eine neue Zeile für eine Variablendeklaration wird eingefügt und das Eingabefeld für den Variablennamen wird geöffnet. Geben Sie einen gültigen Variablennamen ein. Öffnen Sie nach Bedarf die anderen Felder der Deklarationszeile mit einem Doppelklick und wählen Sie die gewünschten Angaben aus den Auswahllisten oder mit Hilfe der erscheinenden Dialoge. Für weitere Informationen siehe: Variable deklarieren" }, 
{ "title" : "Deklarieren im textuellen Deklarationseditor ", 
"url" : "_cds_declaration_editor_basics.html#UUID-c2687aff-7cd6-bd33-2c3c-16ea3266af11_id_c44c3e624d92f81c0a8640e01901bfe_id_e87b1f3952a211e4ac52fce4405945f5", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration \/ Deklarationseditor verwenden \/ Deklarieren im textuellen Deklarationseditor ", 
"snippet" : "Das Verhalten und das Aussehen des textuellen Editors konfigurieren Sie mit den Einstellungen im Dialog Tools → Optionen → Texteditor . Die Einstellungen betreffen Farben, Zeilennummern, Tabulaturbreiten, Einrückungen usw. Es stehen die üblichen Windows-Funktionen zur Verfügung, gegebenenfalls auch ...", 
"body" : "Das Verhalten und das Aussehen des textuellen Editors konfigurieren Sie mit den Einstellungen im Dialog Tools → Optionen → Texteditor . Die Einstellungen betreffen Farben, Zeilennummern, Tabulaturbreiten, Einrückungen usw. Es stehen die üblichen Windows-Funktionen zur Verfügung, gegebenenfalls auch die IntelliMouse-Funktionen. Wenn Sie ein Programmierobjekt (POU, GVL oder NVL) geöffnet haben und den Fokus auf den Textdeklarationseditor gesetzt haben, geben Sie die Variablendeklarationen ein. Achten Sie dabei auf die Syntax. Mit F2 erhalten Sie Unterstützung und können über die Eingabehilfe einen Datentyp oder ein Schlüsselwort auswählen. Sie können sich Tipparbeit sparen und Tastaturkürzel für den Gültigkeitsbereich oder den Variablentyp nutze. Für weitere Informationen siehe: Tastaturkürzel bei der Variablendeklaration" }, 
{ "title" : "Unterstützung mit dem Befehl Variable deklarieren ", 
"url" : "_cds_declaring_variable.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration \/ Unterstützung mit dem Befehl Variable deklarieren ", 
"snippet" : "Voraussetzung: Ein Programmierobjekt (POU oder GVL) eines Projekts ist geöffnet. Wählen Sie den Befehl Bearbeiten → Variable deklarieren . Der Dialog öffnet sich. Wählen Sie aus der Auswahlliste Gültigkeitsbereich den gewünschten Gültigkeitsbereich für die Variable aus. Geben Sie einen Variablenname...", 
"body" : "Voraussetzung: Ein Programmierobjekt (POU oder GVL) eines Projekts ist geöffnet. Wählen Sie den Befehl Bearbeiten → Variable deklarieren . Der Dialog öffnet sich. Wählen Sie aus der Auswahlliste Gültigkeitsbereich den gewünschten Gültigkeitsbereich für die Variable aus. Geben Sie einen Variablennamen in das Eingabefeld Name ein. Wählen Sie aus der Auswahlliste Datentyp den gewünschten Datentyp aus. Wenn der Initialisierungswert vom Standard-Initialisierungswert abweichen soll, geben Sie einen Initialisierungswert für die Variable ein. Schließen Sie Ihre Eingaben mit einem Klick auf OK ab. Die neu deklarierte Variable wird im Deklarationsteil Ihres Programmierobjekts aufgelistet. Mithilfe von Pragmas im Deklarationsteil können Sie die Verarbeitung der Deklaration durch den Compiler beeinflussen. Für weitere Informationen siehe: Attributpragmas, Befehl Variable deklarieren" }, 
{ "title" : "Array deklarieren ", 
"url" : "_cds_declaring_array.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration \/ Array deklarieren ", 
"snippet" : "Voraussetzung: Ein Programmierobjekt (POU oder GVL) eines Projekts ist geöffnet. Wählen Sie den Befehl Bearbeiten → Variable deklarieren . Der Dialog Variable deklarieren öffnet sich. Wählen Sie aus der Auswahlliste Gültigkeitsbereich den gewünschten Gültigkeitsbereich für das Array aus. Geben Sie e...", 
"body" : "Voraussetzung: Ein Programmierobjekt (POU oder GVL) eines Projekts ist geöffnet. Wählen Sie den Befehl Bearbeiten → Variable deklarieren . Der Dialog Variable deklarieren öffnet sich. Wählen Sie aus der Auswahlliste Gültigkeitsbereich den gewünschten Gültigkeitsbereich für das Array aus. Geben Sie einen Bezeichner für das Array in das Eingabefeld Name ein. Klicken Sie auf die Schaltfläche neben dem Eingabefeld Datentyp und wählen Sie im Auswahlmenü den Eintrag Arrayassistent aus. Geben Sie in die Eingabefelder Dimension 1 die untere und die obere Indexgrenze der 1. Dimension des Arrays ein, zum Beispiel: 1 und 3 . Das Feld Ergebnis zeigt die 1. Dimension des Arrays an, zum Beispiel: ARRAY [1..3] OF ? . Geben Sie im Eingabefeld Basistyp den Datentyp des Arrays direkt oder mit Hilfe der Eingabehilfe oder des Arrayassistent ein, zum Beispiel: DINT . Das Feld Ergebnis zeigt jetzt auch den Datentyp des Arrays an, zum Beispiel: ARRAY [1..3] OF DINT . Definieren Sie entsprechend der Schritte 5 und 6 die Dimensionen 2 und 3 des Arrays, zum Beispiel: Dimension 2: 1 und 4 , Dimension 3: 1 und 2 . Das Feld Ergebnis zeigt das Array mit den definierten Dimensionen an: ARRAY [1..3, 1..4, 1..2] OF DINT . Das Array besteht aus 3 * 4 * 2 = 24 Elementen. In einem Array variabler Länge deklarieren Sie die Dimensionsgrenzen mit dem Sternchen-Platzhalter * . Arrays variabler Länge sind nur in VAR_IN_OUT-Deklarationen von Funktionsbausteinen, Methoden oder Funktionen erlaubt. Beispiel für ein 2-dimensionales Array variabler Länge: aiUnknownLengthData : ARRAY [*,*] OF INT; Klicken Sie auf OK . Im Dialog Variable deklarieren zeigt das Feld Datentyp das Array an. Wenn Sie die Initialisierungswerte des Arrays ändern wollen, klicken Sie auf die Schaltfläche neben dem Eingabefeld Initialisierungswert . Der Dialog Initialisierungswert öffnet sich. Selektieren Sie die Zeile des Arrayelements, dessen Initialisierungswert Sie ändern wollen. Beispiel: Arrayelement [1, 1, 1] auswählen. Geben Sie im Eingabefeld unterhalb der Auflistung den gewünschten Initialisierungswert ein und klicken Sie auf die Schaltfläche Wert auf ausgewählte Zeilen anwenden , zum Beispiel: Wert 4 . CODESYS zeigt den geänderten Initialisierungswert der selektierten Zeile an. Klicken Sie auf OK . Im Feld Initialisierungswert des Dialogs Variable deklarieren zeigt CODESYS die Initialisierungswerte des Arrays an, zum Beispiel: [4, 23(0)] . Optional geben Sie einen Kommentar in das Eingabefeld ein. Klicken Sie auf OK , um die Deklaration des Arrays abzuschließen. CODESYS fügt die Deklaration des Arrays im Deklarationsteil des Programmierobjekts hinzu. Für weitere Informationen siehe Datentyp ARRAY OF" }, 
{ "title" : "Globale Variablen deklarieren ", 
"url" : "_cds_defining_global_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration \/ Globale Variablen deklarieren ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Globale Variablen definieren, die innerhalb der Applikation verfügbar sind ", 
"url" : "_cds_defining_global_variables.html#UUID-73312950-d699-07b8-bbc0-46660b31cccc_id_a1822005ba31dc0a8640e004a22fb_id_e022761b24c9bb1bc0a8640e00b1b070", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration \/ Globale Variablen deklarieren \/ Globale Variablen definieren, die innerhalb der Applikation verfügbar sind ", 
"snippet" : "Voraussetzung: Ein Projekt ist geöffnet. Selektieren Sie im Gerätebaum Ihres Projekts die Applikation, in der die globalen Variablen gültig sein sollen. Wählen Sie den Kontextmenübefehl Objekt hinzufügen → Globale Variablenliste . CODESYS fügt die GVL im Gerätebaum unter der Applikation ein und öffn...", 
"body" : "Voraussetzung: Ein Projekt ist geöffnet. Selektieren Sie im Gerätebaum Ihres Projekts die Applikation, in der die globalen Variablen gültig sein sollen. Wählen Sie den Kontextmenübefehl Objekt hinzufügen → Globale Variablenliste . CODESYS fügt die GVL im Gerätebaum unter der Applikation ein und öffnet sie im Editor. Wählen Sie den Menübefehl Bearbeiten → Variable deklarieren . Der Dialog Variable deklarieren öffnet sich. Wählen Sie in der Auswahlliste Gültigkeitsbereich den Eintrag VAR_GLOBAL . Geben Sie im Feld Name einen Namen für die globale Variable ein. Wählen Sie in der Auswahlliste Datentyp einen Datentyp aus. Wenn Ihre Variable einen anderen Initialisierungswert als den Standard-Initialisierungswert haben soll, klicken Sie auf neben dem Feld Initialisierungswert . Der Dialog Initialisierungswert öffnet sich. Doppelklicken Sie auf die Zelle Initialisierungswert Ihrer Variable und geben Sie den gewünschten gültigen Wert ein. Klicken Sie auf OK . Der Initialisierungswert wird im Dialog Variable deklarieren angezeigt. Aktivieren Sie bei Bedarf eines der Flags . Bestätigen Sie Ihre Eingaben mit einem Klick auf die Schaltfläche OK . CODESYS fügt die deklarierte Variable in der GVL ein. Die globale Variable ist in der gesamten Applikation Ihres Projekts verfügbar. " }, 
{ "title" : "Globale Variablen definieren, die im ganzen Projekt verfügbar sind ", 
"url" : "_cds_defining_global_variables.html#UUID-73312950-d699-07b8-bbc0-46660b31cccc_id_a1822005ba31dc0a8640e004a22fb_id_b297ff7624c9bb1cc0a8640e01b4eaa9", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration \/ Globale Variablen deklarieren \/ Globale Variablen definieren, die im ganzen Projekt verfügbar sind ", 
"snippet" : "Wählen Sie den Menübefehl Ansicht → POUs . Die Ansicht POUs öffnet sich. Selektieren Sie in der Ansicht POUs den obersten Knoten mit dem Projektnamen und wählen Sie den Kontextmenübefehl Objekt hinzufügen → Globale Variablenliste . CODESYS fügt die GVL in der Ansicht POUs ein und öffnet sie im Edito...", 
"body" : "Wählen Sie den Menübefehl Ansicht → POUs . Die Ansicht POUs öffnet sich. Selektieren Sie in der Ansicht POUs den obersten Knoten mit dem Projektnamen und wählen Sie den Kontextmenübefehl Objekt hinzufügen → Globale Variablenliste . CODESYS fügt die GVL in der Ansicht POUs ein und öffnet sie im Editor. Wählen Sie den Menübefehl Bearbeiten → Variable deklarieren . Der Dialog Variable deklarieren öffnet sich. Wählen Sie in der Auswahlliste Gültigkeitsbereich den Eintrag VAR_GLOBAL . Geben Sie im Feld Name einen Namen für die globale Variable ein. Wählen Sie in der Auswahlliste Datentyp einen Datentyp aus. Wenn Ihre Variable einen anderen Initialisierungswert als der Standard-Initialisierungswert haben soll, geben Sie diesen in der Spalte Initialisierung ein. Aktivieren Sie bei Bedarf eines der Flags . Bestätigen Sie Ihre Eingaben mit einem Klick auf die Schaltfläche OK . CODESYS fügt die deklarierte Variable in der GVL ein. Die globale Variable ist nun im gesamten Projekt verfügbar. " }, 
{ "title" : "Tasklokale Variablen verwenden ", 
"url" : "_cds_define_task_local_global_variable_list.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration \/ Tasklokale Variablen verwenden ", 
"snippet" : "Tasklokale Variablen sind zykluskonsistent. Sie werden in einem Taskzyklus nur von einer definierten Task geschrieben, während alle anderen Tasks nur lesend darauf zugreifen können. Berücksichtigt wird dabei, dass Tasks durch andere Tasks unterbrochen werden können oder gleichzeitig laufen können. D...", 
"body" : "Tasklokale Variablen sind zykluskonsistent. Sie werden in einem Taskzyklus nur von einer definierten Task geschrieben, während alle anderen Tasks nur lesend darauf zugreifen können. Berücksichtigt wird dabei, dass Tasks durch andere Tasks unterbrochen werden können oder gleichzeitig laufen können. Die Zykluskonsistenz gilt vor allem auch, wenn die Applikation auf einem System mit Mehrkernprozessor läuft. Das Verwenden tasklokaler globaler Variablenlisten ist somit eine Möglichkeit, automatisch eine Synchronisation zu erhalten (durch den Compiler), wenn mehrere Tasks dieselben Variablen bearbeiten. Dies ist bei der Verwendung normaler GVLs nicht der Fall. Auf normale GVL-Variablen können während eines Zyklus gleichzeitig mehrere Tasks schreiben. Beachten Sie allerdings unbedingt: Die Synchronisierung tasklokaler Variablen ist relativ zeit- und speicheraufwändig und nicht in jedem Anwendungsfall das geeignete Mittel. Sehen Sie deshalb zur Entscheidungsfindung weiter unten detailliertere technische Informationen und Hinweise zur „Best Practice“. Im CODESYS -Projekt steht das Objekt Globale Variablenliste (tasklokal) für das Definieren tasklokaler Variablen zur Verfügung. Syntaktisch entspricht es einer normalen GVL, enthält aber zusätzlich die Angabe der Task, die die Schreibrechte auf die Variablen hat. Alle Variablen in einer solchen GVL werden dann während eines Zyklus einer Task nicht durch eine andere Task verändert. Bei tasklokalen Variablen handelt es sich um komplexe Variablen, deren Wert im Onlinebetrieb durch den Befehl Werte schreiben nicht verändert werden kann. Im nächsten Abschnitt finden Sie ein einfaches Beispiel, das das Prinzip und die Funktionalität tasklokaler Variablen zeigt: Es gibt ein schreibendes und ein lesendes Programm. Die Programme laufen in verschiedenen Tasks, greifen aber auf dieselben Daten zu, die in einer tasklokalen globalen Variablenliste liegen, damit sie zykluskonsistent bearbeitet werden. " }, 
{ "title" : "Funktionalität in einem Beispiel dargestellt ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_1bdc324663bd9d69c0a8646318878847", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration \/ Tasklokale Variablen verwenden \/ Funktionalität in einem Beispiel dargestellt ", 
"snippet" : "Eine Anleitung zum Nachprogrammieren dieser Beispielapplikation finden Sie weiter unten. Beispielapplikation (* task-local GVL, object name: \"Tasklocals\" *) VAR_GLOBAL g_diaData : ARRAY [0..99] OF DINT; END_VAR PROGRAM ReadData VAR diIndex : DINT; bTest : BOOL; diValue : DINT; END_VAR bTest := TRUE;...", 
"body" : "Eine Anleitung zum Nachprogrammieren dieser Beispielapplikation finden Sie weiter unten. Beispielapplikation (* task-local GVL, object name: \"Tasklocals\" *)\nVAR_GLOBAL\n g_diaData : ARRAY [0..99] OF DINT;\nEND_VAR\n\nPROGRAM ReadData\nVAR\n diIndex : DINT;\n bTest : BOOL;\n diValue : DINT;\nEND_VAR\nbTest := TRUE;\ndiValue := TaskLocals.g_diaData[0];\nFOR diIndex := 0 TO 99 DO\n bTest := bTest AND (diValue = Tasklocals.g_diaData[diIndex]);\nEND_FOR\n\nPROGRAM WriteData\nVAR\n diIndex : DINT;\n diCounter : DINT;\nEND_VAR\ndiCounter := diCounter + 1;\nFOR diIndex := 0 TO 99 DO\n Tasklocals.g_diaData[diIndex] := diCounter;\nEND_FOR Die Programme WriteData und ReadData werden von verschiedenen Tasks aufgerufen. Im Programm WriteData wird das Array g_diaData mit Werten gefüllt. Das Programm ReadData testet, ob die Werte des Arrays so sind wie erwartet. Wenn dies der Fall ist, liefert die Variable bTest als Ergebnis TRUE . Die Arraydaten, die getestet werden, sind über die Variable g_diaData im Objekt Tasklocals vom Typ Globale Variablenliste (tasklokal) deklariert. Dadurch werden die Datenzugriffe im Compiler synchronisiert und die Daten sind garantiert zykluskonsistent, auch wenn die zugreifenden Programme aus verschiedenen Tasks heraus aufgerufen werden. Im Beispielprogramm heißt das konkret, dass die Variable test im Programm ReadData immer TRUE ist. Wenn die Variable g_diaData in diesem Beispiel nur als globale Variablenliste deklariert wäre, würde der Test , also die Variable test im Programm ReadData , häufiger FALSE liefern. Denn in diesem Fall könnte eine der beiden Tasks in der FOR -Schleife durch die andere Task unterbrochen werden, oder es könnten beide Tasks gleichzeitig laufen (Multicore-Steuerungen). Und somit könnten die Werte vom Schreiber verändert werden, während der Leser die Liste ausliest. " }, 
{ "title" : "Einschränkungen bei der Deklaration ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_61f1e5de6a954123c0a86463531788fb", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration \/ Tasklokale Variablen verwenden \/ Einschränkungen bei der Deklaration ", 
"snippet" : "Nach Änderungen in Deklarationen in der Liste der tasklokalen Variablen bearbeiten ist kein Online-Change der Applikation möglich. Beachten Sie Folgendes beim Deklarieren einer gobalen tasklokalen Variablenliste: Weisen Sie keine direkten Adressen über eine AT-Deklaration zu. Mappen Sie in der Steue...", 
"body" : "Nach Änderungen in Deklarationen in der Liste der tasklokalen Variablen bearbeiten ist kein Online-Change der Applikation möglich. Beachten Sie Folgendes beim Deklarieren einer gobalen tasklokalen Variablenliste: Weisen Sie keine direkten Adressen über eine AT-Deklaration zu. Mappen Sie in der Steuerungskonfiguration nicht auf tasklokale Variablen. Deklarieren Sie keine Pointer. Deklarieren Sie keine Referenzen. Instanziieren Sie keine Funktionsbausteine. Deklarieren Sie tasklokale Variablen nicht gleichzeitig als PERSISTENT und RETAIN . Ein schreibender Zugriff in einer Task ohne Schreibrecht wird vom Compiler als Fehler gemeldet. Allerdings können nicht alle Stellen ermittelt werden, an denen gegen das Schreibrecht verstoßen wird. Der Compiler kann nämlich nur statische Aufrufe einer Task zuordnen. Der Aufruf eines Funktionsbausteins über einen Pointer oder ein Interface wird aber beispielsweise nicht einer Task zugeordnet. Somit werden dort eventuelle Schreibzugriffe auch nicht erfasst. Außerdem können Pointer auf tasklokale Variablen zeigen. So können in einer lesenden Task Daten manipuliert werden. In diesem Fall wird ebenfalls kein Laufzeitfehler ausgegeben. Allerdings werden bei Zugriff über Pointer geänderte Werte nicht in die gemeinsame Referenz der Variablen zurückkopiert. " }, 
{ "title" : "Eigenschaften der tasklokalen globalen Variablen und mögliches Verhalten ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_6eb169fa44f608dfc0a864631eeb1091", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration \/ Tasklokale Variablen verwenden \/ Eigenschaften der tasklokalen globalen Variablen und mögliches Verhalten ", 
"snippet" : "Die Variablen liegen in der Liste für jede Task auf einer anderen Adresse. Das heißt für Lesezugriffe: ADR(variable name) liefert in jeder Task eine andere Adresse. Der Synchronisationsmechanismus garantiert Folgendes: Zykluskonsistenz Freiheit von Lockzuständen: Zu keinem Zeitpunkt wartet eine Task...", 
"body" : "Die Variablen liegen in der Liste für jede Task auf einer anderen Adresse. Das heißt für Lesezugriffe: ADR(variable name) liefert in jeder Task eine andere Adresse. Der Synchronisationsmechanismus garantiert Folgendes: Zykluskonsistenz Freiheit von Lockzuständen: Zu keinem Zeitpunkt wartet eine Task auf eine Aktion einer anderen Task. Mit dieser Methode kann allerdings kein Zeitpunkt bestimmt werden, zu dem eine lesende Task eine Kopie der schreibenden Task sicher erhält. Grundsätzlich können die Kopien auseinanderlaufen. Im Beispiel oben kann man nicht davon ausgehen, dass jede geschriebene Kopie einmal vom Leser bearbeitet wird. Die lesende Task kann beispielsweise mehrere Zyklen lang das gleiche Array bearbeiten, oder der Inhalt des Arrays kann zwischen zwei Zyklen ein oder mehrere Werte „überspringen“. Beides kann vorkommen und muss berücksichtigt werden. Die Schreibtask kann zwischen zwei Zugriffen auf die gemeinsame Referenz durch jede lesende Task für einen Zyklus aufgehalten werden. Das heisst, wenn n lesende Tasks existieren, kann die Schreibtask n Zyklen Verzug haben bis zur nächsten Aktualisierung der gemeinsamen Referenz. Eine lesende Task kann in jedem Zyklus durch die schreibende Task davon abgehalten werden, eine Lesekopie zu bekommen. Man kann daher keine maximale Zahl an Zyklen angeben, nach der eine lesende Task sicher eine Kopie erhält. Insbesondere kann dies problematisch werden, wenn sehr langsam laufende Tasks beteiligt sind. Angenommen eine Task läuft nur jede Stunde und kann dann nicht auf die tasklokalen Variablen zugreifen, dann arbeitet die Task mit einer sehr alten Kopie der Liste. Deshalb kann es sinnvoll sein, einen Zeitstempel in die tasklokalen Variablen einzufügen, über den die lesenden Tasks zumindest feststellen können, ob die Liste aktuell ist. Einen Zeitstempel können Sie folgendermaßen anbringen: Fügen in die Liste der tasklokalen Variablen eine Variable vom Typ LTIME ein und in die schreibende Task beispielsweise den folgenden Code: tasklocal.g_timestamp := LTIME(); . " }, 
{ "title" : "Best Practice ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_201eb4c744f608dfc0a86463690c31a3", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration \/ Tasklokale Variablen verwenden \/ Best Practice ", 
"snippet" : "Tasklokale Variablen sind für den Anwendungsfall „Einzelner Schreiber - mehrere Leser“ ausgelegt. Wenn Sie einen Code implementieren, der von verschiedenen Tasks aufgerufen wird, ist die Verwendung tasklokaler Variablen von großem Vorteil. Beispielsweise ist das bei der oben beschriebenen Beispielap...", 
"body" : "Tasklokale Variablen sind für den Anwendungsfall „Einzelner Schreiber - mehrere Leser“ ausgelegt. Wenn Sie einen Code implementieren, der von verschiedenen Tasks aufgerufen wird, ist die Verwendung tasklokaler Variablen von großem Vorteil. Beispielsweise ist das bei der oben beschriebenen Beispielapplikation appTasklocal der Fall, wenn diese um mehrere Lesetasks erweitert ist, die alle auf das gleiche Array zugreifen und die gleichen Funktionen verwenden. Tasklokale Variablen sind insbesondere auf Systemen mit Mehrkernprozessor hilfreich. Auf diesen Systemen können Sie Tasks nicht über die Priorität synchronisieren. Dann entsteht die Notwendigkeit für andere Synchronisierungsmechanismen. Verwenden Sie keine tasklokale Variablen, wenn eine lesende Task immer auf der neuesten Kopie der Variablen arbeiten muss. Dafür sind tasklokale Variablen nicht geeignet. Ein ähnliches Problem ist die „Producer - Consumer“-Problematik. Diese ist gegeben, wenn eine Task Daten produziert und eine zweite Task diese verarbeitet. Bevorzugen Sie bei dieser Konstellation eine andere Art der Synchronisation. Der Producer könnte beispielsweise über ein Flag mitteilen, dass ein neues Datum vorhanden ist. Der Consumer kann über ein zweites Flag mitteilen, dass er seine Daten verarbeitet hat und nun auf neuen Input wartet. Beide können so auf den gleichen Daten arbeiten. Es entfällt der Overhead für das zyklische Kopieren der Daten und der Consumer verliert keine Daten, die der Producer erzeugt hat. " }, 
{ "title" : "Monitoring ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_ce0845ad44f608dfc0a8646329c0a4d8", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration \/ Tasklokale Variablen verwenden \/ Monitoring ", 
"snippet" : "Zur Laufzeit existieren von der tasklokalen Variablenliste mehrere unter Umständen verschiedene Kopien im Speicher. Beim Monitoring einer Position können aber nicht alle Werte angezeigt werden. Deshalb werden beim Inline-Monitoring, in der Überwachungsliste und in der Visualisierung für eine tasklok...", 
"body" : "Zur Laufzeit existieren von der tasklokalen Variablenliste mehrere unter Umständen verschiedene Kopien im Speicher. Beim Monitoring einer Position können aber nicht alle Werte angezeigt werden. Deshalb werden beim Inline-Monitoring, in der Überwachungsliste und in der Visualisierung für eine tasklokale Variable die Werte aus der gemeinsamen Referenz angezeigt. Wenn Sie einen Haltepunkt setzen, werden die Daten derjenigen Task angezeigt, die auf den Haltepunkt gelaufen ist und folglich angehalten wurde. Währenddessen laufen aber die anderen Tasks weiter. Dabei kann unter Umständen die gemeinsame Kopie geändert werden. Im Kontext der angehaltenen Task bleiben die Werte aber unverändert und werden so angezeigt. Dessen müssen Sie sich bewusst sein. " }, 
{ "title" : "Hintergrund: Technische Umsetzung ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_0d2b15ad44f608dfc0a864634268e60b", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration \/ Tasklokale Variablen verwenden \/ Hintergrund: Technische Umsetzung ", 
"snippet" : "Der Compiler legt für eine Liste von tasklokalen Variablen eine Kopie für jede Task, sowie eine gemeinsame Referenzkopie für alle Tasks an. Dabei wird eine Struktur erzeugt, die die gleichen Variablen beinhaltet wie die Liste der tasklokalen Variablen. Außerdem wird ein Array mit dieser Struktur ang...", 
"body" : "Der Compiler legt für eine Liste von tasklokalen Variablen eine Kopie für jede Task, sowie eine gemeinsame Referenzkopie für alle Tasks an. Dabei wird eine Struktur erzeugt, die die gleichen Variablen beinhaltet wie die Liste der tasklokalen Variablen. Außerdem wird ein Array mit dieser Struktur angelegt, wobei für jede Task eine Arraydimension erzeugt wird. Somit wird für jede Task ein Arrayelement indiziert. Wenn nun im Code auf eine Variable der Liste zugegriffen wird, wird tatsächlich auf die tasklokale Kopie der Liste zugegriffen. Außerdem wird ermittelt, in welcher Task der Baustein gerade läuft und der Zugriff entsprechend indiziert. Beispielsweise wird die Codezeile diValue := TaskLocals.g_diaData[0]; aus dem obigen Beispiel ersetzt: diValue := __TaskLocalVarsArray[__CURRENTTASK.TaskIndex].__g_diarr[0]; __CURRENTTASK ist ein Operator, der ab CODESYS V3.5 SP13 zur Verfügung steht, um den aktuellen Taskindex schnell zu ermitteln. Zur Laufzeit wird am Ende der schreibenden Task der Inhalt der tasklokalen Liste in die gemeinsame Referenz kopiert. Bei einer lesenden Task wird zu Beginn der Inhalt der gemeinsamen Referenz in die tasklokale Kopie kopiert. Deshalb gibt es für n Tasks n+1 Kopien der Liste: Eine Liste dient als gemeinsame Referenz und zusätzlich hat jede Task eine eigene Kopie der Liste. Ein Scheduler steuert die zeitliche Ausführung mehrerer Tasks und damit die Taskumschaltung. Die Strategie, die vom Scheduler verfolgt wird, um die Zuteilung der Ausführungszeit zu steuern, zielt darauf ab, das Blockieren einer Task zu vermeiden. Der Synchronisationsmechanismus ist also auf die Eigenschaften tasklokaler Variablen hin optimiert, dass blockierende Zustände (Lockzustände) vermieden werden und zu keinem Zeitpunkt eine Task auf die Aktion einer anderen Task wartet. Synchronisationsstrategie: Solange die schreibende Task eine Kopie auf die gemeinsam Referenz zurückschreibt, holt sich keine der lesenden Tasks eine Kopie. Solange eine lesende Task eine Kopie von der gemeinsamen Referenz holt, schreibt die schreibende Task keine Kopie zurück. " }, 
{ "title" : "Anleitung zum Erstellen der oben beschriebenen Beispielapplikation ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_b297ff7624c9bb1cc0a8640e01b4eaa9", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Variablendeklaration \/ Tasklokale Variablen verwenden \/ Anleitung zum Erstellen der oben beschriebenen Beispielapplikation ", 
"snippet" : "Ziel: Sie wollen mit einem Programm ReadData auf diesselben Daten zugreifen, die von einem Programm WriteData geschrieben werden. Die beiden Programme sollen in unterschiedlichen Tasks laufen. Die Daten stellen Sie in einer tasklokalen Variablenliste bereit, damit sie automatisch zykluskonsistent be...", 
"body" : "Ziel: Sie wollen mit einem Programm ReadData auf diesselben Daten zugreifen, die von einem Programm WriteData geschrieben werden. Die beiden Programme sollen in unterschiedlichen Tasks laufen. Die Daten stellen Sie in einer tasklokalen Variablenliste bereit, damit sie automatisch zykluskonsistent bearbeitet werden. Voraussetzung: Ein Standardprojekt ist frisch angelegt und im Editor geöffnet. Benennen Sie die Applikation von Application in appTasklocal um. Fügen Sie unter appTasklocal ein Programm in ST mit Namen ReadData hinzu. Fügen Sie unter appTasklocal ein weiteres Programm in ST mit Namen WriteData hinzu. Benennen Sie die Standardtask MainTask unter dem Objekt Taskkonfiguration in Read um. Fügen Sie im Dialog Konfiguration der Task Read über die Schaltfläche Aufruf hinzufügen den Aufruf des Programms ReadData hinzu. Fügen Sie unter dem Objekt Taskkonfiguration eine weitere Task hinzu, benannt mit Write und fügen dieser Task den Aufruf des Programms Write hinzu. In der Taskkonfiguration gibt es nun zwei Tasks Write und Read , die die Programme WriteData beziehungsweise ReadData aufrufen. Selektieren Sie die Applikation appTasklocal und fügen Sie ein Objekt des Typs Globale Variablenliste (tasklokal) hinzu. Der Dialog Globale Variablenliste (tasklokal) hinzufügen öffnet sich. Geben Sie als Namen Tasklocals ein. Wählen Sie aus der Auswahlliste Task mit Schreibzugriff die Task Write . Die Objektstruktur für die Verwendung von tasklokalen Variablen innerhalb einer Applikation ist vollständig. Sie können die Objekte nun codieren, wie oben in der Beschreibung des Beispiels gezeigt. " }, 
{ "title" : "Quellcode in IEC erstellen ", 
"url" : "_cds_f_programming_pous.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Quellcode in IEC erstellen ", 
"snippet" : "Quellcode: Mit „Quellcode“ bezeichnen wir den Implementierungscode, den Sie mit Hilfe der entsprechenden Programmiersprachen-Editoren in den Programmierbausteinen einfügen. Folgende Bausteintypen stehen dazu zur Verfügung: POU (Programm, Funktion, Funktionsbaustein), Aktion, Methode, Eigenschaft, Sc...", 
"body" : "Quellcode: Mit „Quellcode“ bezeichnen wir den Implementierungscode, den Sie mit Hilfe der entsprechenden Programmiersprachen-Editoren in den Programmierbausteinen einfügen. Folgende Bausteintypen stehen dazu zur Verfügung: POU (Programm, Funktion, Funktionsbaustein), Aktion, Methode, Eigenschaft, Schnittstelle. Programmiersprache: Beim Anlegen eines Programmierbausteins entscheiden Sie, in welcher Implementierungssprache Sie programmieren wollen. Neben den IEC-Sprachen steht auch CFC zur Verfügung. Programmiersprachen-Editoren: Ein Programmierbaustein wird durch Doppelklick auf das Objekt im Geräte- oder POU-Baum zur Bearbeitung im jeweiligen Programmierspracheneditor geöffnet. Danach wird der Programmierbaustein entweder im textuellen ST-Editor oder in einem der grafischen Editoren für FUP\/KOP, SFC oder CFC angezeigt. Jeder Editor besteht aus zwei Fenstern: Im oberen Fenster machen Sie die Deklarationen je nach Einstellung in textueller oder tabellarischer Form. Im unteren Fenster fügen Sie den Implementierungscode ein. Das Aussehen und Verhalten jedes Editors können Sie projektweit in der entsprechenden Registerkarte der CODESYS -Optionen konfigurieren. Für weitere Informationen siehe: CODESYS LD FBD CODESYS SFC CODESYS CFC " }, 
{ "title" : "Strukturierter Text (ST), Erweiterter Strukturierter Text (ExST) ", 
"url" : "_cds_f_programming_language_st.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Quellcode in IEC erstellen \/ Strukturierter Text (ST), Erweiterter Strukturierter Text (ExST) ", 
"snippet" : "Der ST-Editor dient dem Programmieren von POUs in der IEC-61131-3 Programmiersprache Strukturierter Text (ST) und Erweiterter Strukturierter Text. Der Erweitertete Strukturierte Text bietet bezüglich der Norm IEC-61131-3 einige zusätzliche Funktionen. Der Strukturierte Text ist eine Programmiersprac...", 
"body" : "Der ST-Editor dient dem Programmieren von POUs in der IEC-61131-3 Programmiersprache Strukturierter Text (ST) und Erweiterter Strukturierter Text. Der Erweitertete Strukturierte Text bietet bezüglich der Norm IEC-61131-3 einige zusätzliche Funktionen. Der Strukturierte Text ist eine Programmiersprache, vergleichbar mit anderen Hochsprachen wie C oder PASCAL, die die Entwicklung komplexer Algorithmen erlaubt. Der Programmcode besteht aus einer Kombination von Ausdrücken und Anweisungen , die auch bedingt (IF…THEN…ELSE) oder in Schleifen (WHILE…DO) ausgeführt werden können. Ein Ausdruck ist ein Konstrukt, das nach seiner Auswertung einen Wert zurück liefert. Ausdrücke sind auch Operatoren und Operanden zusammen. Auch Zuweisungen können Sie als Ausdruck verwenden. Ein Operand kann eine Konstante, eine Variable, ein Funktionsaufruf oder ein weiterer Ausdruck sein. Anweisungen steuern, wie die Ausdrücke verarbeitet werden sollen. Für diesen Texteditor können Sie in den Dialogen Optionen und Anpassen des Menüs Tools verschiedene Einstellungen bezüglich Verhalten, Aussehen und Menüs vornehmen. Für diesen Editor stehen auch die bekannten Windows-Funktionen zur Verfügung (zum Beispiel IntelliMouse). Für weitere Informationen siehe: Programmieren in Strukturiertem Text (ST)" }, 
{ "title" : "ExST - Erweiterter Strukturierter Text ", 
"url" : "_cds_f_programming_language_st.html#UUID-c0b48aaa-9e6c-d5d3-e0a2-ddaf98d1688a_section-idm4538086976966432654794828895", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Quellcode in IEC erstellen \/ Strukturierter Text (ST), Erweiterter Strukturierter Text (ExST) \/ ExST - Erweiterter Strukturierter Text ", 
"snippet" : "Erweiterter Strukturierter Text (ExST) ist eine CODESYS -spezifische Erweiterung bezüglich des IEC 61131-3 Standards für Strukturierten Text (ST). Für weitere Informationen siehe: Zuweisungen...", 
"body" : "Erweiterter Strukturierter Text (ExST) ist eine CODESYS -spezifische Erweiterung bezüglich des IEC 61131-3 Standards für Strukturierten Text (ST). Für weitere Informationen siehe: Zuweisungen" }, 
{ "title" : "Programmieren in Strukturiertem Text (ST) ", 
"url" : "_cds_programming_in_st.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Quellcode in IEC erstellen \/ Strukturierter Text (ST), Erweiterter Strukturierter Text (ExST) \/ Programmieren in Strukturiertem Text (ST) ", 
"snippet" : "Anlegen einer POU in der Implementierungssprache Strukturierter Text (ST) Selektieren Sie eine Applikation im Gerätebaum. Wählen Sie den Befehl Projekt → Objekt hinzufügen → POU . Der Dialog POU hinzufügen öffnet sich. Geben Sie einen Namen ein und wählen Sie die Implementierungssprache Strukturiert...", 
"body" : "Anlegen einer POU in der Implementierungssprache Strukturierter Text (ST) Selektieren Sie eine Applikation im Gerätebaum. Wählen Sie den Befehl Projekt → Objekt hinzufügen → POU . Der Dialog POU hinzufügen öffnet sich. Geben Sie einen Namen ein und wählen Sie die Implementierungssprache Strukturierter Text (ST) . Klicken Sie auf Hinzufügen . Die POU wird im Gerätebaum hinzugefügt und im Editor geöffnet. Im oberen Teil der POU fügen Sie nun die Variablendeklarationen ein, im unteren Teil der POU geben Sie den ST-Programmcode ein. " }, 
{ "title" : "Prinzip ", 
"url" : "_cds_programming_in_st.html#UUID-2076ef08-fb89-b7e5-586c-5a99b07f8d18_id_a941afccf6c2c2c0a8640e010636b9_id_dc652380fd1509c7c0a8640e015d35d3", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Quellcode in IEC erstellen \/ Strukturierter Text (ST), Erweiterter Strukturierter Text (ExST) \/ Programmieren in Strukturiertem Text (ST) \/ Prinzip ", 
"snippet" : "Sie programmieren die Programmiersprachen „Strukturierter Text“ und „Erweiterter Strukturierter Text“ im ST-Editor. Der Programmcode besteht aus einer Kombination von Ausdrücken und Anweisungen, die auch bedingt oder in Schleifen ausgeführt werden können. Jede Anweisung müssen Sie mit einem ; abschl...", 
"body" : "Sie programmieren die Programmiersprachen „Strukturierter Text“ und „Erweiterter Strukturierter Text“ im ST-Editor. Der Programmcode besteht aus einer Kombination von Ausdrücken und Anweisungen, die auch bedingt oder in Schleifen ausgeführt werden können. Jede Anweisung müssen Sie mit einem ; abschließen. Die Deklaration der Variablen erfolgt im Deklarationseditor. " }, 
{ "title" : "Speicherreserve für Online-Change konfigurieren ", 
"url" : "_cds_configuring_memory_reserve.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Speicherreserve für Online-Change konfigurieren ", 
"snippet" : "Sie können einen Funktionsbaustein mit Speicherreserve konfigurieren, um zu vermeiden, dass während eines Online-Changes dessen Funktionsbaustein-Instanzen an neue Speicherplätze kopiert werden müssen. Das kann passieren, wenn Sie Deklarationsänderungen wie beispielsweise das Hinzufügen von Variable...", 
"body" : "Sie können einen Funktionsbaustein mit Speicherreserve konfigurieren, um zu vermeiden, dass während eines Online-Changes dessen Funktionsbaustein-Instanzen an neue Speicherplätze kopiert werden müssen. Das kann passieren, wenn Sie Deklarationsänderungen wie beispielsweise das Hinzufügen von Variablen am Funktionsbaustein vornehmen. Mit Speicherreserve verläuft ein solcher Online-Change schneller und es treten weniger Probleme auf. Wenn die Speicherreserve aufgebraucht ist, erscheint vor der Durchführung des Online-Changes eine Meldung. Sie konfigurieren die Speicherreserve für einen Funktionsbaustein am besten vor dem ersten Download der Applikation auf die Steuerung. Wenn Sie die Speicherreserve erst dann konfigurieren, wenn sich die Applikation bereits auf der Steuerung befindet, ist ein aufwendiger Online-Change notwendig. " }, 
{ "title" : "Für einen Funktionsbaustein eine Speicherreserve für den Online-Change konfigurieren ", 
"url" : "_cds_configuring_memory_reserve.html#UUID-37b7c569-d1f3-f5d0-0328-3e84514c76a6_id_e907096bc90bbc0a8646334d3dfea_id_6b7a234396c8490fc0a86463751c1541", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Speicherreserve für Online-Change konfigurieren \/ Für einen Funktionsbaustein eine Speicherreserve für den Online-Change konfigurieren ", 
"snippet" : "An einem Funktionsbaustein des Projekts werden zukünftig größere Änderungen vorgenommen, die bewirken könnten, dass beim Online-Change Funktionsbaustein-Instanzen an andere Speicherorte kopiert werden. Voraussetzung: Das geöffnete Projekt befindet sich idealerweise noch nicht auf der Steuerung. Wähl...", 
"body" : "An einem Funktionsbaustein des Projekts werden zukünftig größere Änderungen vorgenommen, die bewirken könnten, dass beim Online-Change Funktionsbaustein-Instanzen an andere Speicherorte kopiert werden. Voraussetzung: Das geöffnete Projekt befindet sich idealerweise noch nicht auf der Steuerung. Wählen Sie den Befehl Ansicht → Einstellungen Speicherreserve für Online-Change . Die Ansicht Speicherreserve für Online-Change öffnet sich. Wählen Sie aus der Auswahlliste die Applikation des Projekts. Wählen Sie den Befehl Erstellen → Übersetzen . Klicken Sie auf die Schaltfläche Applikation durchsuchen . Wählen Sie im Bereich Funktionsbausteine den Eintrag Alle . In der Ansicht werden alle Funktionsbausteine der Applikation angezeigt. Wählen Sie den entsprechenden Funktionsbaustein aus, für die Sie eine Speicherreserve konfigurieren wollen. Wenn sich die Applikation noch nicht auf der Steuerung befindet, ist das Eingabefeld Speicherreserve (in Bytes) editierbar. Wenn sich die Applikation bereits auf der Steuerung befindet, klicken Sie auf die Schaltfläche Bearbeiten im Bereich Bearbeitung erlauben . Beachten Sie, wenn Sie die Speicherreserve einer Applikation ändern, die sich bereits auf der Steuerung befindet, müssen die Instanzen aller betroffener Funktionsbausteine im Speicher kopiert werden. Geben Sie die Größe der Speicherreserve in Bytes ein und klicken Sie auf Für Auswahl anwenden . Die eingegebene Anzahl Bytes wird in der Tabelle im Feld Speicherreserve angezeigt. Wählen Sie den Befehl Erstellen → Übersetzen und klicken Sie anschließend die Schaltfläche Applikation durchsuchen . In der Funktionsbausteinliste für den konfigurierten Funktionsbaustein werden die Informationen Größe , Instanzanzahl , Zusätzlicher Speicher für alle Instanzen und Verbleibende Größe der Speicherreserve aktualisiert. Wenn Sie nun die Applikation auf die Steuerung laden, belegen die Funktionsbaustein-Instanzen den benötigten Speicher und zusätzlich die Speicherreserve. Zukünftige größere Änderungen des Funktionsbausteins können somit über den Online-Change auf die Steuerung geladen werden, ohne dass alle Instanzen des Funktionsbausteins im Speicher umkopiert werden müssen. " }, 
{ "title" : "Funktionsbaustein, Funktion oder Methode mit externer Implementierung aufrufen ", 
"url" : "_cds_calling_fb_function_method_with_external_implementation.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Funktionsbaustein, Funktion oder Methode mit externer Implementierung aufrufen ", 
"snippet" : "Ein Laufzeitsystem kann die Implementierung eines Funktionsbausteins, einer Funktion oder einer Methode enthalten, zum Beispiel aus einer Bibliothek. Wenn Sie dafür in Ihrer Applikation eine gleichnamige POU mit der Eigenschaft Externe Implementierung ohne Implementierung erstellen, können Sie die b...", 
"body" : "Ein Laufzeitsystem kann die Implementierung eines Funktionsbausteins, einer Funktion oder einer Methode enthalten, zum Beispiel aus einer Bibliothek. Wenn Sie dafür in Ihrer Applikation eine gleichnamige POU mit der Eigenschaft Externe Implementierung ohne Implementierung erstellen, können Sie die bereits bestehende Implementierung ausführen. Dabei sollten Sie beachten, dass Sie lokale Variablen nur in einem externen Funktionsbaustein deklarieren. Eine externe Funktion oder Methode darf keine lokale Variable enthalten. Beim Applikationsdownload sucht CODESYS für jede externe POU die zugehörige Implementierung im Laufzeitsystem und verlinkt sie. Objekte mit der Eigenschaft Externe Implementierung sind in der Ansicht Geräte oder POUs durch den Zusatz (EXT) hinter dem Objektnamen gekennzeichnet. Für weitere Informationen siehe: BuildMethode mit externer Implementierung erstellen Selektieren Sie einen Funktionsbaustein im Gerätebaum oder in der POUs-Ansicht. Wählen Sie Objekt hinzufügen → Methode und geben Sie als Name den Namen der zugehörigen Implementierung des Laufzeitsystems an. Beenden Sie den Dialog mit Hinzufügen . Die Methode ist erstellt. Selektieren Sie die Methode und aktivieren Sie im Kontextmenü Eigenschaften . Der Dialog öffnet sich. Wählen Sie die Registerkarte Übersetzen . Aktivieren Sie die Option Externe Implementierung (Spätes Verlinken im Laufzeitsystem) . Die Methode ist deklariert und Sie können einen Aufruf der Methode implementieren. Der Methodenname in der Ansicht Geräte oder in der Ansicht POUs ist mit dem Zusatz (EXT) versehen. " }, 
{ "title" : "POU mit externer Implementierung erstellen ", 
"url" : "_cds_calling_fb_function_method_with_external_implementation.html#UUID-fff6ac80-1b8a-7912-4b20-ed87a85fdbb5_id_c98ff0280307e532c0a8640e0065769d_id_3b8dd10723c74a66c0a8640e01935197", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Funktionsbaustein, Funktion oder Methode mit externer Implementierung aufrufen \/ POU mit externer Implementierung erstellen ", 
"snippet" : "Wählen Sie Projekt → Objekt hinzufügen → POU . Aktivieren Sie Funktionsbaustein , Methode oder Funktion und geben Sie als Name den Namen der zugehörigen Implementierung des Laufzeitsystems Beenden Sie den Dialog mit Hinzufügen . Die POU mit dem Namen der Laufzeitsystem-POU ist in der Ansicht POUs er...", 
"body" : "Wählen Sie Projekt → Objekt hinzufügen → POU . Aktivieren Sie Funktionsbaustein , Methode oder Funktion und geben Sie als Name den Namen der zugehörigen Implementierung des Laufzeitsystems Beenden Sie den Dialog mit Hinzufügen . Die POU mit dem Namen der Laufzeitsystem-POU ist in der Ansicht POUs erstellt. Der Name ist mit dem Zusatz (EXT) versehen. Selektieren Sie die POU und aktivieren Sie im Kontextmenü Eigenschaften . Der Dialog öffnet sich. Wählen Sie die Registerkarte Übersetzen . Aktivieren Sie die Option Externe Implementierung (Spätes Verlinken im Laufzeitsystem) . Die POU ist deklariert und Sie können einen Aufruf der POU implementieren. " }, 
{ "title" : "Eingabeunterstützung nutzen ", 
"url" : "_cds_using_input_assistants.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Eingabeunterstützung nutzen ", 
"snippet" : "CODESYS bietet Funktionalitäten und Assistenten, die Ihnen beim Programmieren die Codeeingabe erleichtern. Smart-Tag-Funktionen Smart Tags erleichtern das Erstellen von Programmcode, in dem sie direkt beim Programmierelement geeignete Befehle zur Auswahl bereitstellen. Wenn Sie den Cursor auf ein Pr...", 
"body" : "CODESYS bietet Funktionalitäten und Assistenten, die Ihnen beim Programmieren die Codeeingabe erleichtern. Smart-Tag-Funktionen Smart Tags erleichtern das Erstellen von Programmcode, in dem sie direkt beim Programmierelement geeignete Befehle zur Auswahl bereitstellen. Wenn Sie den Cursor auf ein Programmierelement setzen, für das eine Smart-Tag-Funktion zur Verfügung steht, erscheint das Symbol . Bei einem Klick auf werden die Befehle angezeigt, die Sie auswählen können. Verfügbare Smart Tags: Bei nicht deklarierten Variablen im Implementierungsteil im ST-Editor stellt die Smart-Tag-Funktion den Befehl Variable deklarieren zur Verfügung. " }, 
{ "title" : "Eingabehilfe ", 
"url" : "_cds_using_input_assistants.html#UUID-c64e3633-b2dc-8e9f-0533-6676df90609a_id_fbe6a158721888c0a8640e00a479cd_id_10730b9a8290a9e9c0a8640e006261df", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Eingabeunterstützung nutzen \/ Eingabehilfe ", 
"snippet" : "Der Dialog bietet Ihnen alle Programmierelemente an, die Sie an der aktuellen Cursorposition einfügen können. Sie öffnen den Dialog Eingabehilfe durch Auswählen des Befehls Bearbeiten → Eingabehilfe oder durch das Tastaturkürzel F2 ....", 
"body" : "Der Dialog bietet Ihnen alle Programmierelemente an, die Sie an der aktuellen Cursorposition einfügen können. Sie öffnen den Dialog Eingabehilfe durch Auswählen des Befehls Bearbeiten → Eingabehilfe oder durch das Tastaturkürzel F2 . " }, 
{ "title" : "Dialog: Variable deklarieren ", 
"url" : "_cds_using_input_assistants.html#UUID-c64e3633-b2dc-8e9f-0533-6676df90609a_id_fbe6a158721888c0a8640e00a479cd_id_3879e6752bd7ab84c0a8640e015b3239", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Eingabeunterstützung nutzen \/ Dialog: Variable deklarieren ", 
"snippet" : "Ein Dialog unterstützt Sie bei der Deklaration von Variablen. Für weitere Informationen siehe: Variable deklarieren...", 
"body" : "Ein Dialog unterstützt Sie bei der Deklaration von Variablen. Für weitere Informationen siehe: Variable deklarieren" }, 
{ "title" : "Komponenten auflisten ", 
"url" : "_cds_using_input_assistants.html#UUID-c64e3633-b2dc-8e9f-0533-6676df90609a_id_fbe6a158721888c0a8640e00a479cd_id_028146f939ae1e35c0a8640e013e8fd8", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Eingabeunterstützung nutzen \/ Komponenten auflisten ", 
"snippet" : "Die Funktion „Komponenten auflisten“ ist eine Eingabeunterstützung im Texteditor und erleichtert die Eingabe von gültigen Bezeichnern. Sie aktivieren die Funktion folgendermaßen: Wählen Sie den Befehl Tools → Optionen , und anschließend die Kategorie Intelligentes Kodieren . Aktivieren Sie die Optio...", 
"body" : "Die Funktion „Komponenten auflisten“ ist eine Eingabeunterstützung im Texteditor und erleichtert die Eingabe von gültigen Bezeichnern. Sie aktivieren die Funktion folgendermaßen: Wählen Sie den Befehl Tools → Optionen , und anschließend die Kategorie Intelligentes Kodieren . Aktivieren Sie die Option Komponenten auflisten, nachdem ein Punkt (.) eingegeben wurde . Wenn Sie anstelle einer globalen Variablen nur einen Punkt . eingeben, erscheint eine Auswahlliste mit allen verfügbaren globalen Variablen. Durch Doppelklicken auf eine Variable der Auswahlliste oder Drücken der Taste Eingabe fügen Sie die ausgewählte Variable hinter dem Punkt ein. Wenn Sie anstelle einer globalen Variablen oder hinter einer Funktionsbaustein-Instanzvariablen oder einer Strukturvariablen einen Punkt eingeben, bietet CODESYS in einer Auswahlliste entsprechend alle globalen Variablen, alle Ein- und Ausgabevariablen des Funktionsbausteins oder alle Strukturkomponenten an. Durch Doppelklicken auf eine Variable der Auswahlliste oder Drücken der Taste Eingabe fügen Sie die ausgewählte Variable hinter dem Punkt ein. Hinweis: Wenn Sie zusätzlich die lokalen Variablen von Funktionsbaustein-Instanzen erhalten wollen, aktivieren Sie in den CODESYS -Optionen für Intelligentes Kodieren auch die Option Alle Variablen einer Instanz in der Eingabehilfe anzeigen . Wenn bereits ein Komponentenzugriff (mit Punkt) für eine Auswahlliste erfolgt ist, wird beim nächsten Komponentenzugriff der zuletzt selektierte Eintrag vorausgewählt. Wenn Sie eine beliebige Zeichenfolge eingeben und anschließend Strg + Leertaste drücken, erscheint eine Auswahlliste mit allen verfügbaren POUs und globalen Variablen. Das erste Element dieser Liste, das mit der vorher eingegebenen Zeichenfolge beginnt, wird automatisch ausgewählt und Sie können es über einen Doppelklick oder über die Taste Eingabe im Editor einfügen. Übereinstimmungen mit der eingegeben Zeichenfolge werden in der Auswahlliste gelb hervorgehoben. Wenn die eingegebene Zeichenfolge geändert wird, wird die angezeigte Auswahlliste aktualisiert. Im ST-Editor können Sie die angezeigte Auswahlliste nach Gültigkeitsbereiche filtern: Abhängig von der jeweils angezeigten Auswahlliste können Sie mit Hilfe der Tasten Pfeil nach rechst und Pfeil nach links zwischen folgenden Auswahllisten wechseln: Alle Einträge Schlüsselwörter Globale Deklarationen Lokale Deklarationen Wenn Sie einen Funktionsbaustein, eine Methode oder eine Funktion aufrufen und dazu die öffnende runde Klammer für das Eintragen der POU-Parameter eingeben, zeigt CODESYS einen Tooltip an. Dieser Tooltip enthält Informationen zu den Parametern, so wie sie innerhalb der POU deklariert sind. Der Tooltip bleibt solange sichtbar, bis Sie ihn mit einem Mausklick oder durch Setzen des Fokus außerhalb der aktuellen Ansicht schließen. Wenn Sie den Tooltip versehentlich schließen, können Sie ihn mit Strg + Umschalt + Leertaste wieder öffnen. Mit dem Pragmaattribut hide können Sie Variablen aus der Funktion „Komponenten auflisten“ ausschließen. Beispiele Eingabe einer Strukturvariablen: Aufruf eines Funktionsbausteins: Für weitere Informationen siehe: Intelligentes Kodieren" }, 
{ "title" : "Kurzformmodus ", 
"url" : "_cds_using_input_assistants.html#UUID-c64e3633-b2dc-8e9f-0533-6676df90609a_id_fbe6a158721888c0a8640e00a479cd_id_cebde498c37bd547c0a864634120c4e4", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Eingabeunterstützung nutzen \/ Kurzformmodus ", 
"snippet" : "Der Kurzformmodus ermöglicht die Eingabe von Kurzformen für die Variablendeklaration im Deklarationseditor und in den Texteditoren, in denen Variablendeklarationen möglich sind. Sie aktivieren diesen Modus, indem Sie eine Deklarationszeile mit der Tastenkombination Strg + Eingabe beenden. Für weiter...", 
"body" : "Der Kurzformmodus ermöglicht die Eingabe von Kurzformen für die Variablendeklaration im Deklarationseditor und in den Texteditoren, in denen Variablendeklarationen möglich sind. Sie aktivieren diesen Modus, indem Sie eine Deklarationszeile mit der Tastenkombination Strg + Eingabe beenden. Für weitere Informationen siehe: Tastaturkürzel bei der VariablendeklarationCODESYS unterstützt folgende Kurzformen: Alle Bezeichner bis auf den letzten Bezeichner einer Zeile werden zu Variablenbezeichnern einer Deklaration. Der Datentyp der Deklaration wird durch den letzten Bezeichner der Zeile bestimmt. Hierbei gilt: b wird zu : BOOL d wird zu : DINT i wird zu : INT l wird zu : LINT r wird zu : REAL s wird zu  : STRING s 8 wird zu : STRING(8) mit Stringlänge t wird zu : TIME u wird zu : UINT w wird zu : WORD Wenn durch diese Regeln kein Datentyp festgelegt wird, ist der Datentyp automatisch BOOL und der letzte Bezeichner wird nicht als Datentyp benutzt (siehe Beispiel 1). Jede eingegebene Konstante wird, je nach Typ der Deklaration, zu einer Initialisierung oder einer Stringlängenangabe (siehe Beispiele 2 und 3). Eine Adresse (wie in %MD12 ) wird automatisch um das AT-Attribut erweitert (siehe Beispiel 4). Ein Text nach einem Strichpunkt ; wird zu einem Kommentar (siehe Beispiel 3). Alle anderen Zeichen in der Zeile werden ignoriert (siehe Ausrufezeichen in Beispiel 5). Beispiele Kurzform resultierende Deklaration 1 A A: BOOL; 2 A B I 2 A, B: INT := 2; 3 ST S 2; A string ST:STRING(2); (* A string *) 4 X %MD12 R 5 Real Number X AT %MD12: REAL := 5.0;(* Real Number *) 5 B ! B: BOOL; " }, 
{ "title" : "Pragmas verwenden ", 
"url" : "_cds_using_pragmas.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Pragmas verwenden ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Pragma in CODESYS ", 
"url" : "_cds_using_pragmas.html#UUID-7a6cff73-fd46-0ee8-105d-673d8223ef56_id_f9a5d357efac0a8640e0137aceb_id_83e9bccc5e33ab49c0a8640e01f6b4a9", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Pragmas verwenden \/ Pragma in CODESYS ", 
"snippet" : "Als Pragma gilt ein Text im Quellcode der Applikation, der in geschweiften Klammern steht. Pragmas werden verwendet, um spezielle Anweisungen im Code einzufügen, die der Compiler auswerten kann. Damit kann ein Pragma die Eigenschaften einer oder mehrerer Variablen bezüglich der Vorkompilierung oder ...", 
"body" : "Als Pragma gilt ein Text im Quellcode der Applikation, der in geschweiften Klammern steht. Pragmas werden verwendet, um spezielle Anweisungen im Code einzufügen, die der Compiler auswerten kann. Damit kann ein Pragma die Eigenschaften einer oder mehrerer Variablen bezüglich der Vorkompilierung oder der Kompilierung (Codegenerierung) beeinflussen. Pragmas, die der Compiler nicht kennt, überliest er wie einen Kommentar. Der Anweisungsstring eines Pragmas kann auch mehrzeilig sein. Zur Syntax im Detail sehen Sie bitte die Beschreibungen der einzelnen CODESYS -Pragmas. Es gibt verschiedene Pragmas für unterschiedliche Zweicke (Beispiel: Initialisierung einer Variablen, Monitoring einer Variablen, Hinzufügen einer Variablen zur Symbolkonfiguration, Erzwingen von Meldungsausgaben während des Übersetzungsvorgangs, Verhalten einer Variablen unter bestimmten Bedingungen). Die Groß-\/Kleinschreibung muss eingehalten werden. " }, 
{ "title" : "Pragma-Kategorien ", 
"url" : "_cds_using_pragmas.html#UUID-7a6cff73-fd46-0ee8-105d-673d8223ef56_id_f9a5d357efac0a8640e0137aceb_id_3296509035ae4c0cc0a8640e000e65d2", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Pragmas verwenden \/ Pragma-Kategorien ", 
"snippet" : "Die CODESYS -Pragmas sind in folgende Kategorien aufgeteilt: Meldungspragmas Während des Übersetzungsvorgangs können benutzerdefinierte Meldungen ausgegeben werden. Attributpragmas Die Kompilierung und Vorkompilierung können beeinflusst werden. Dafür stehen Pragmas für unterschiedliche Zwecke zur Ve...", 
"body" : "Die CODESYS -Pragmas sind in folgende Kategorien aufgeteilt: Meldungspragmas Während des Übersetzungsvorgangs können benutzerdefinierte Meldungen ausgegeben werden. Attributpragmas Die Kompilierung und Vorkompilierung können beeinflusst werden. Dafür stehen Pragmas für unterschiedliche Zwecke zur Verfügung, beispielsweise zur Initialisierung, zum Monitoring oder zum Hinzufügen einer Variablen zur Symbolkonfiguration. Bedingte PragmasDie Codegenerierung kann durch bedingte Anweisungen gesteuert werden. So kann beispielsweise das Verhalten einer Variablen unter bestimmten Bedingungen unterschiedlich sein. Region-Pragma Pragmas in Testbausteinen Benutzerdefinierte Pragmas Im Dialog Eigenschaften (Kategorie Übersetzen ) können Sie \"Compiler-Defines\" deklarieren, die in Pragmas abgefragt werden können. " }, 
{ "title" : "Mögliche Einfügepositionen ", 
"url" : "_cds_using_pragmas.html#UUID-7a6cff73-fd46-0ee8-105d-673d8223ef56_id_f9a5d357efac0a8640e0137aceb_id_ed58008b2a97bd5ec0a8640e002167c3", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Pragmas verwenden \/ Mögliche Einfügepositionen ", 
"snippet" : "Pragmas in CODESYS sind keine Eins-zu Eins-Implementierungen der C-Präprozessor-Direktiven. Sie müssen ein Pragma wie eine normale Anweisung positionieren. Sie dürfen ein Pragma nicht innerhalb eines Ausdrucks verwenden. Sie können ein Pragma, das der Compiler auswerten soll, an verschiedenen Positi...", 
"body" : "Pragmas in CODESYS sind keine Eins-zu Eins-Implementierungen der C-Präprozessor-Direktiven. Sie müssen ein Pragma wie eine normale Anweisung positionieren. Sie dürfen ein Pragma nicht innerhalb eines Ausdrucks verwenden. Sie können ein Pragma, das der Compiler auswerten soll, an verschiedenen Positionen einfügen. In der Deklaration Im Deklarationskopf eines Programmierbaustein Sie können das gewünschte Pragma im textuellen Editor direkt als eigene Zeile eingeben, entweder als erste Zeile des Bausteins oder vor einer Variablendeklaration. In der tabellarischen Ansicht werden Sie bei der Eingabe unterstützt. Wählen sie den Befehl Deklarationskopf editieren . Klicken Sie im Dialog auf die Schaltfläche Attribute und geben Sie im Eingabefeld das gewünschte Pragma an. In einer globalen Variablenliste Einschränkung bei bedingten Pragmas Verwenden Sie Pragmas für bedingte Kompilierung nur in Implementierungen von Programmierbausteinen. In Deklarationen werden diese Pragmas nicht ausgewertet sondern ignoriert. Beachten Sie bitte die folgende Ausnahme: Das IF-Pragma mit dem Operator project_defined kann in Deklarationen eingefügt werden. Für weitere Informationen siehe: IF-Pragma mit project_defined (<global define>)In der Implementierung eines Programmierbausteins Strukturierter Text (ST) Bei der Implementierungssprache ST gehört ein Pragma an eine „Anweisungsposition“. Eine gültige Position ist am Anfang der Implementierung in einer separaten Zeile. Eine weitere gültige Position ist nach einer Anweisung, deren Ende durch einen Strichpunkt „ ; ” oder durch Schlüsselwörter wie END_VAR , END_IF oder END_WHILE gekennzeichnet ist. Funktionsbausteinsprache (FUP) oder Kontaktplan (KOP) Bei den Implementierungssprachen des FUP\/KOP\/AWL-Editors gehört ein Pragma an eine Position, die auch für eine Sprungmarke geeignet ist. Sie können das Pragma genauso wie eine Sprungmarke eingeben. Wählen Sie dazu den Befehl FUP\/KOP\/AWL → Sprungmarke einfügen . Ersetzen Sie dann den Standardtext Label: im Textfeld der Marke durch das gewünschte Pragma. Wenn Sie ein Pragma zusätzlich zu einer Sprungmarke verwenden wollen, tragen Sie zunächst das Pragma und dann die Sprungmarke ein. Beispiel Für falsche und richtige Positionierung eines bedingten Pragmas PROGRAM PRG_ConditionalPragma\nVAR\n strTest : STRING := 'b';\n iResult : INT := 0;\nEND_VAR\n Falsch {IF defined(DEFINE_A)}\nIF strTest = 'a' THEN\n{ELSE}\nIF strTest = 'b' THEN\n{END_IF}\n iResult := {IF defined(DEFINE_B)} 12; {ELSE} 13; {END_IF}\nEND_IF\n Richtig {IF defined(DEFINE_A)}\nIF strTest = 'a' THEN\n {IF defined(DEFINE_B)}\n iResult := 16#A;\n {ELSE}\n iResult := 16#AA;\n {END_IF}\nEND_IF\n{ELSE}\nIF strTest = 'b' THEN\n {IF defined(DEFINE_B)}\n iResult := 16#B;\n {ELSE}\n iResult := 16#BB;\n {END_IF}\nEND_IF\n{END_IF} " }, 
{ "title" : "Wirkungsbereich ", 
"url" : "_cds_using_pragmas.html#UUID-7a6cff73-fd46-0ee8-105d-673d8223ef56_section-id235127926588889", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Pragmas verwenden \/ Wirkungsbereich ", 
"snippet" : "Abhängig vom Typ und Inhalt eines Pragmas wirkt ein Pragma auf Folgendes: Nachfolgenden Deklarationen Genau die nachfolgende Anweisung Alle nachfolgenden Anweisungen, bis es durch ein entsprechenden Pragma wieder aufgehoben werden Alle nachfolgenden Anweisungen, bis dasselbe Pragma mit anderen Param...", 
"body" : "Abhängig vom Typ und Inhalt eines Pragmas wirkt ein Pragma auf Folgendes: Nachfolgenden Deklarationen Genau die nachfolgende Anweisung Alle nachfolgenden Anweisungen, bis es durch ein entsprechenden Pragma wieder aufgehoben werden Alle nachfolgenden Anweisungen, bis dasselbe Pragma mit anderen Parametern ausgeführt, oder das Ende des Codes erreicht ist. In diesem Kontext bezeichnet \"Code\" den Deklarationsteil, Implementierungsteil, die globale Variablenliste und die Typdeklaration. Somit wirkt ein Pragma, das alleine in der ersten Zeile des Deklarationsteils steht und nicht durch ein weiteres abgelöst oder aufgehoben wird, auf das gesamte Objekt. " }, 
{ "title" : "Bibliotheksbausteine verwenden ", 
"url" : "_cds_using_libraries.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Bibliotheksbausteine verwenden ", 
"snippet" : "Bibliotheken sind Sammlungen von Objekten, die Sie in Ihre Applikation einbinden können. Die in Bibliotheken enthaltenen Objekte können Sie im Projekt genau so verwenden wie Objekte, die Sie direkt im Projekt definiert haben. Bibliotheken können folgende Objekte enthalten: POUs wie beispielsweise Fu...", 
"body" : "Bibliotheken sind Sammlungen von Objekten, die Sie in Ihre Applikation einbinden können. Die in Bibliotheken enthaltenen Objekte können Sie im Projekt genau so verwenden wie Objekte, die Sie direkt im Projekt definiert haben. Bibliotheken können folgende Objekte enthalten: POUs wie beispielsweise Funktionsbausteine oder Funktionen Schnittstellen und ihre Methoden und Eigenschaften Datentypen wie beispielsweise Enumerationen, Strukturen, Aliases, Unions Globale Variablen, Konstanten, Parameterlisten Textlisten, Bildersammlungen, Visualisierungen, Visualisierungselemente Externe Dateien (beispielsweise Dokumentationen) Kurvenscheibentabellen Die Verwaltung der Bibliotheken in einem Projekt erfolgt im Bibliotheksverwalter. Die vorherige Installation der Bibliothek auf dem System führen Sie über den Dialog des Bibliotheks-Repositorys durch. Für weitere Informationen zur „Sichtbarkeit“ von Bibliotheksbausteinen und Namensräumen von Bibliotheken siehe: Hilfeseite zu den Bibliothekseigenschaften Verwenden eines Bibliotheksbausteins Die nachfolgende Anweisung beschreibt als Beispiel, wie Sie den Zählerbaustein CTUD aus der Bibliothek Standard in Ihr Programm einfügen. Öffnen Sie eine POU im Editor und setzen Sie den Cursor in den Deklarationsteil. Geben Sie einen Namen für die Funktionsbausteininstanz gefolgt von einem Doppelpunkt ein (zum Beispiel iCounter1: ). Öffnen Sie mit F2 die Eingabehilfe. Selektieren Sie in der Kategorie Strukturierte Typen den Funktionsbaustein CTUD aus der Bibliothek Standard (Unterordner Counter). Aktivieren Sie die Option Mit Namensraum-Präfix einfügen . Schließen Sie den Dialog mit OK . Der Funktionsbaustein wird mit Namensraum-Präfix in den Deklarationsteil eingefügt: iCounter1:Standard.CTUD . Für weitere Informationen siehe: Bibliotheken verwenden" }, 
{ "title" : "C-Module integrieren ", 
"url" : "_cds_integrating_c_code.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ C-Module integrieren ", 
"snippet" : "Mit der CODESYS C-Code-Integration können in C entwickelte Module in ein CODESYS -Projekt als Bibliothek eingebunden werden. Das Modul wird als dynamisches Runtime-Modul zusammen mit der darin implementierten IEC-Schnittstelle in einer Bibliothek gespeichert. Dabei dürfen in einer Bibliothek mehrere...", 
"body" : "Mit der CODESYS C-Code-Integration können in C entwickelte Module in ein CODESYS -Projekt als Bibliothek eingebunden werden. Das Modul wird als dynamisches Runtime-Modul zusammen mit der darin implementierten IEC-Schnittstelle in einer Bibliothek gespeichert. Dabei dürfen in einer Bibliothek mehrere Varianten eines Moduls für unterschiedliche Zielsysteme hinterlegt werden. Die Bibliothek stellt sich für den Anwender wie jede andere IEC 61131-3 Bibliothek dar. Wenn die Bibliothek in einer Applikation verwendet wird, dann wird von CODESYS automatisch das passende Modul aus der Bibliothek auf die Steuerung geladen und vom CODESYS Control Laufzeitsystem ausgeführt. Anwendungsbeispiele: Wiederverwendung von verfügbarem C-Code Einbindung von durch Modellierungstools generiertem Code, wie zum Beispiel Matlab®\/Simulink® Dynamische Einbindung von gerätespezifischen Funktionen, die mit C-Code realisiert wurden Alle dynamischen Module einer Applikation werden beim Download auf das Laufzeitsystem übertragen und geladen. Hierfür muss das Laufzeitsystem dynamisches Linken unterstützen. Lizenz für das Laufzeitsystem Das Laufzeitsystem benötigt eine Lizenz, die das Laden von C-Modulen erlaubt. Ohne diese Lizenz können dynamische Module beim Download nicht gelinkt werden und der Download wird abgebrochen. Die dynamischen Module sind Bestandteil der Bootapplikation und werden beim Neustart der Steuerung wieder geladen und aktiviert. Der Befehl Rest Ursprung entlädt alle C-Code-Module der Applikation. Die Befehle Reset kalt und Reset warm führen nicht zu einer erneuten Initialisierung der C-Code-Module. CODESYS unterstützt nicht das Monitoring von Variablen in C-Code-Dateien und nicht das Setzen von Haltepunkten in C-Quellcode. Vorkompiliertes Laufzeitmodul einem Gerät zuweisen und in einer Bibliothek speichern Voraussetzung: Ein Bibliothek ( *.library ) ist in CODESYS geöffnet. Wählen Sie den Befehl Ansicht → POUs . Die Ansicht POUs öffnet sich und zeigt das Bibliotheksprojekt und seine Objekte an. Selektieren Sie das Bibliotheksprojekt und wählen Sie den Befehl Projekt → Objekt hinzufügen → C-implementierte Bibliothek . Klicken Sie im Dialog C-implementierte Bibliothek hinzufügen auf Hinzufügen . CODESYS fügt das Objekt C-implementierte Bibliothek in der Ansicht POUs ein. Doppelklicken Sie das Objekt C-implementierte Bibliothek . Das Objekt öffnet sich in seinem Editor Klicken Sie in diesem Editor auf Hinzufügen . Der Dialog Gerät auswählen öffnet sich. Geben Sie im Eingabefeld Objektdatei den Namen eines dynamisch ladbaren Moduls des Formats: *.dll oder *.so ein. Die Datei *.dll muss im Namen den Titel des Bibliotheksprojekts enthalten. Beispiel: Wenn das Bibliotheksprojekt den Namen XYlib hat, dann muss die Objektdatei heißen: <Name>_XYlib.dll Wählen Sie im Fenster Gerät ein Gerät, dem Sie die Objektdatei zuweisen wollen. Klicken Sie auf Gerät auswählen . CODESYS zeigt die erstellte Zuweisung Gerät-Datei im Editor in der Registerkarte Kompilierte Komponenten an. Speichern Sie das Bibliotheksprojekt. Für weitere Informationen siehe: C-implementierte Bibliothek" }, 
{ "title" : "Programmatischer Zugriff auf E\/As ", 
"url" : "_cds_f_assigning_ios.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Programmatischer Zugriff auf E\/As ", 
"snippet" : "CODESYS stellt zur Abbildung von Projektvariablen auf Eingangs-, Ausgangs- und Speicheradressen folgende Funktionalitäten zur Verfügung: Zuweisung von Projektvariablen auf Eingangs-, Ausgangs- und Speicheradressen in der Registerkarte E\/A-Abbild des Editors der Geräte Programmatischer Zugriff auf E\/...", 
"body" : "CODESYS stellt zur Abbildung von Projektvariablen auf Eingangs-, Ausgangs- und Speicheradressen folgende Funktionalitäten zur Verfügung: Zuweisung von Projektvariablen auf Eingangs-, Ausgangs- und Speicheradressen in der Registerkarte E\/A-Abbild des Editors der Geräte Programmatischer Zugriff auf E\/As Variablenkonfiguration AT-Deklaration Wir empfehlen Ihnen, die Abbildung von Projektvariablen auf Eingangs-, Ausgangs- und Speicheradressen in der Registerkarte E\/A-Abbild des Editors des jeweiligen Geräts vorzunehmen. " }, 
{ "title" : "Variablenkonfiguration - VAR_CONFIG ", 
"url" : "_cds_variables_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Programmatischer Zugriff auf E\/As \/ Variablenkonfiguration - VAR_CONFIG ", 
"snippet" : "Sie verwenden die „Variablenkonfiguration“, um Variablen von Funktionsbausteinen auf das Prozessabbild zu mappen. Bei der Deklaration im Funktionsbaustein weisen Sie die Variablen den Ein-\/Ausgängen von Geräten zu, ohne die vollständige Adresse anzugeben. Die Angabe der exakten Adressen erfolgt spät...", 
"body" : "Sie verwenden die „Variablenkonfiguration“, um Variablen von Funktionsbausteinen auf das Prozessabbild zu mappen. Bei der Deklaration im Funktionsbaustein weisen Sie die Variablen den Ein-\/Ausgängen von Geräten zu, ohne die vollständige Adresse anzugeben. Die Angabe der exakten Adressen erfolgt später zentral für alle Funktionsbaustein-Instanzen der Applikation in einer globalen Variablenliste mit VAR_CONFIG -Deklarationen. Diese globale Variablenliste mit den VAR_CONFIG -Deklarationen wird Variablenkonfiguration genannt. Änderungen von Variablen, die direkt den E\/A-Adressen zugewiesen sind, zeigt CODESYS unmittelbar im Prozessabbild an. Änderungen von Variablen, die über eine Variablenkonfiguration abgebildet sind, zeigt CODESYS erst am Ende der zuständigen Task an. Deklaration der Variablen im Funktionsbaustein Bei der Deklaration der Variablen im Funktionsbaustein deklarieren Sie die Variablen zwischen den Schlüsselwörtern VAR und END_VAR . Dabei ordnen Sie den Variablen unvollständige Adressen zu. Diese unvollständigen Adressen kennzeichnen Sie mit einem * . Syntax: <Bezeichner> AT %<I\\|Q>*:<Datentyp>; Beispiel Es werden 2 lokale E\/A-Variablen definiert: die Eingangsvariable xLocIn und die Ausgangsvariable xLocOut . FUNCTION_BLOCK locio\nVAR\n xLocIn AT %I*: BOOL := TRUE;\n xLocOut AT %Q*: BOOL;\nEND_VAR Die endgültige Definition der Adressen erfolgt in der Variablenkonfiguration in einer globalen Variablenliste. In der globalen Variablenliste, die Sie als Variablenkonfiguration verwenden, geben Sie die Deklarationen der Variablen mit den exakten Adressen zwischen den Schlüsselwörtern VAR_CONFIG und END_VAR ein. Die VAR_CONFIG -Variablen müssen Sie mit dem vollständigen Instanzpfad angeben, wobei die einzelnen POU- und Instanznamen durch jeweils einen Punkt getrennt sind. Die Deklaration muss eine Adresse enthalten, deren Klasse (Eingang\/Ausgang) mit der Klasse der unvollständig angegebenen Adresse (%I*, %Q*) im Funktionsbaustein übereinstimmt. Der Datentyp muss ebenfalls übereinstimmen. Syntax: <instance variable path> AT %<I\\|Q><location>: <data type>; Wenn die Instanz des Pfads nicht existiert, erfolgt eine Fehlermeldung. CODESYS gibt auch einen Fehler aus, wenn keine Adresskonfiguration für eine Variable vorliegt, die Sie mit einer unvollständigen Adresse deklariert haben. Beispiel Folgende Verwendung des Funktionsbausteins locio des obigen Beispiels liegt in einem Programm vor: PROGRAM PLC_PRG\nVAR\n locioVar1: locio;\n locioVar2: locio;\nEND_VAR Dann würde eine korrekte Variablenkonfiguration in einer globalen Variablenliste beispielsweise folgendermaßen aussehen: VAR_CONFIG\n PLC_PRG.locioVar1.xLocIn AT %IX1.0 : BOOL;\n PLC_PRG.locioVar1.xLocOut AT %QX0.0 : BOOL;\n PLC_PRG.locioVar2.xLocIn AT %IX1.0 : BOOL;\n PLC_PRG.locioVar2.xLocOut AT %QX0.3 : BOOL;\nEND_VAR " }, 
{ "title" : "Anlegen einer Variablenkonfiguration ", 
"url" : "_cds_variables_configuration.html#UUID-6adb8712-3824-d906-67c2-beabb384488e_section-idm4501210518364832656274674828", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Programmatischer Zugriff auf E\/As \/ Variablenkonfiguration - VAR_CONFIG \/ Anlegen einer Variablenkonfiguration ", 
"snippet" : "Voraussetzungen: Sie haben ein Projekt geöffnet, das eine Steuerungskonfiguration mit einem Feldgerät besitzt. Das Projekt enthält ein Programm, zum Beispiel PLC_PRG , und einen Funktionsbaustein, zum Beipsiel func1 . Das Feldgerät besitzt Ein- und Ausgänge. In den Optionen für den Deklarationsedito...", 
"body" : "Voraussetzungen: Sie haben ein Projekt geöffnet, das eine Steuerungskonfiguration mit einem Feldgerät besitzt. Das Projekt enthält ein Programm, zum Beispiel PLC_PRG , und einen Funktionsbaustein, zum Beipsiel func1 . Das Feldgerät besitzt Ein- und Ausgänge. In den Optionen für den Deklarationseditor ist die textuelle Ansicht ausgewählt. Im Funktionsbaustein Variablen auf Geräte-E\/As mit unvollständigen Adressen zuweisen und anschließend eine Variablenkonfigurgation erstellen. Doppelklicken Sie im Gerätebaum auf den Funktionsbaustein, zum Beispiel func1 . Der Editor des Bausteins öffnet sich. Geben Sie im Deklarationsteil zwischen den Schlüsselwörtern VAR und END_VAR ein: xLocIn AT %I*: BOOL := TRUE; und in die nächste Zeile XLocOut AT %Q*:BOOL; Sie haben eine Eingangsvariable xLocIn deklariert und diese der unvollständigen Eingangsadresse %I* eines Feldgeräts zugewiesen. Die deklarierte Ausgangsvariable haben Sie der unvollständigen Ausgangsadresse %Q* zugewiesen. Klicken Sie auf das Objekt PLC_PRG im Gerätebaum und fügen Sie im Deklarationsteil des Programms zwischen VAR und END_VAR zum Beispiel folgende Deklarationen ein: locioVar1: func; locioVar2: func; Selektieren Sie das Objekt Application im Gerätebaum, wählen Sie den Kontextmenü-Befehl Objekt hinzufügen → Globale Variablenliste und klicken Sie im Dialog Globale Variablenliste hinzufügen auf die Schaltfläche Hinzufügen . Die globale Variablenliste wird im Gerätebaum hinzugefügt und ihr Editor öffnet sich. Ändern Sie das Schlüsselwort VAR_GLOBAL in VAR_CONFIG um. Wählen Sie den Befehl Deklarationen → Alle Instanzpfade hinzufügen . Die folgende Instanzpfade werden hinzugefügt: PLC_PRG.logioVar1.xLocIn AT %I*;\nPLC_PRG.logioVar2.xLocIN AT %I*;\nPLC_PRG.logioVar1.xLocOut AT %Q*;\nPLC_PRG.logioVar2.xLocOut AT %Q*; Jetzt ersetzen Sie die unvollständigen Adressangaben %I* und %Q* mit den exakten vollständigen Adressen. " }, 
{ "title" : "AT-Deklaration ", 
"url" : "_cds_at_declaration.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Programmatischer Zugriff auf E\/As \/ AT-Deklaration ", 
"snippet" : "Übersichtlichen Konfigurationseditor für E\/A-Abbild nutzen Von der hier beschriebenen Zuweisung von Speicheradressen ist abzuraten, da dies zu einem Verlust der Übersichtlichdiet führen kann. Es wird empfohlen, die Zuordnung von Speicheradressen zu Variablen im Konfigurationseditor E\/A-Abbild bearbe...", 
"body" : "Übersichtlichen Konfigurationseditor für E\/A-Abbild nutzen Von der hier beschriebenen Zuweisung von Speicheradressen ist abzuraten, da dies zu einem Verlust der Übersichtlichdiet führen kann. Es wird empfohlen, die Zuordnung von Speicheradressen zu Variablen im Konfigurationseditor E\/A-Abbild bearbeiten der Geräts vorzunehmen. Das Schlüsselwort AT in der Variablendeklaration ordnet einer Projektvariable eine bestimmten Eingabe-, Ausgabe- oder Speicheradresse der im Gerätebaum konfigurierten Steuerung zu. Die AT-Deklaration ermöglicht, einer Adresse einen aussagekräftigen Namen zu geben. Eventuell nötige Änderungen bezüglich des ein- oder ausgehenden Signals dürfen Sie nur an einer Stelle durchführen, zum Beispiel in der Deklaration. Für weitere Informationen siehe: AdressenVariablendeklarationVariablenkonfiguration - VAR_CONFIGAlle Instanzpfade hinzufügenADR, REFERENCE TO, VAR_IN_OUT" }, 
{ "title" : "Syntax ", 
"url" : "_cds_at_declaration.html#UUID-bb5c2ea2-9f57-c62c-fc21-e0a94e35bcb0_section-idm234773736203646", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Programmatischer Zugriff auf E\/As \/ AT-Deklaration \/ Syntax ", 
"snippet" : "<Variablenname> AT % <Adresse> : <Datentyp> ; <Variablenname> Obligatorisch % <Adresse> Obligatorisch Adresse im Speicherbereich % <Speicherbereichspräfix> <Größenpräfix> <Speicherposition> <Speicherbereichspräfix> Obligatorisch I : Eingangsspeicherbereich Speicherbereich für Eingangssignale, Eingän...", 
"body" : "<Variablenname> AT % <Adresse> : <Datentyp> ; <Variablenname> Obligatorisch % <Adresse> Obligatorisch Adresse im Speicherbereich % <Speicherbereichspräfix> <Größenpräfix> <Speicherposition> <Speicherbereichspräfix> Obligatorisch I : Eingangsspeicherbereich Speicherbereich für Eingangssignale, Eingänge (Inputs) Für physikalische Eingänge über Eingangstreiber und Sensoren Q : Ausgangsspeicherbereich Speicherbereich für Ausgangssignale, Ausgänge (Outputs) Für physikalische Ausgänge über Ausgangstreiber und Aktoren M : Merkerspeicherbereich <Größenpräfix> Optional kein Größenpräfix: Bit Einzelnes Bit X : Bit Einzelnes Bit B : Byte 8 Bit Datenbreite W : Word 16 Bit Datenbreite D : Dword 32 Bit Datenbreite <Speicherposition> <Positionsnummer> .  <Bitpositionsnummer> Beispiel: %IB2.4 steht für das 5. Bit des 3. Bytes <Positionsnummer> Obligatorisch Die Nummerierung ist zielsystemabhängig und bei 0 beginnend. . <Bitpositionsnummer> Optional 0..7 bei einem Byte <Datentyp> Optional Der Datentyp soll zum Größenpräfix passen. Beispiele VAR \n wInput AT %IW0 : WORD; \nEND_VAR Variablendeklaration mit Adressangabe eines Eingangsworts VAR \n xActuator AT %QW0 : BOOL; \nEND_VAR Boolesche Variablendeklaration Hinweis: Für boolesche Variable wird intern ein Byte alloziert, wenn keine Einzelbitadresse angegeben ist. Eine Wertänderung von xActuator betrifft folglich den Bereich von QX0.0 bis QX0.7 . VAR\n xSensor AT %IX7.5 : BOOL; \nEND_VAR Boolesche Variablendeklaration mit expliziter Angabe einer Einzelbitadresse Beim Zugriff wird nur das Eingangsbit 7.5 gelesen. VAR \n xSensor AT %IX* : BOOL; \nEND_VAR Bei der Adressangabe ist statt der Speicherposition der Platzhalter * angegeben. Die endgültige Adressangabe wir in der Variablenkonfiguration vorgenommen. Hinweis: Das ist in Funktionsbausteinen möglich. " }, 
{ "title" : "Wissenswertes ", 
"url" : "_cds_at_declaration.html#UUID-bb5c2ea2-9f57-c62c-fc21-e0a94e35bcb0_section-idm234773751522904", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Programmatischer Zugriff auf E\/As \/ AT-Deklaration \/ Wissenswertes ", 
"snippet" : "Wenn Sie nicht explizit eine Einzelbitadresse angeben, werden boolesche Variablen byteweise alloziert. Einzelne Bit-Adressen, die auf boolesche Variablen abgebildet werden, haben Einschränkungen. Es ist nicht möglich, diese Variablen mit VAR_IN_OUT , REFERENCE TO oder dem ADR -Operator zu verwenden....", 
"body" : "Wenn Sie nicht explizit eine Einzelbitadresse angeben, werden boolesche Variablen byteweise alloziert. Einzelne Bit-Adressen, die auf boolesche Variablen abgebildet werden, haben Einschränkungen. Es ist nicht möglich, diese Variablen mit VAR_IN_OUT , REFERENCE TO oder dem ADR -Operator zu verwenden. Wenn Sie eine Variable einer Adresse zuweisen, müssen Sie Folgendes beachten: Auf Variablen, die auf einen Eingang gelegt sind, können Sie nicht schreibend zugreifen. Dies führt zu einem Compilerfehler. AT -Deklarationen können Sie nur für lokale und globale Variablen durchführen, nicht aber für Ein- und Ausgabevariablen von Bausteinen. AT -Deklarationen dürfen Sie nicht in persistenten Variablenlisten verwenden! Wenn Sie AT -Deklarationen bei Strukturkomponenten oder Funktionsbausteinvariablen anwenden, verwenden alle Instanzen denselben Speicher. Dies entspricht der Verwendung von „statischen Variablen“ in klassischen Programmiersprachen wie zum Beispiel „C“. Das Speicherlayout von Strukturen ist ebenfalls abhängig vom Zielsystem. " }, 
{ "title" : "Beispiel ", 
"url" : "_cds_at_declaration.html#UUID-bb5c2ea2-9f57-c62c-fc21-e0a94e35bcb0_section-idm234773752144233", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Programmatischer Zugriff auf E\/As \/ AT-Deklaration \/ Beispiel ", 
"snippet" : "PROGRAM PLC_PRG VAR xVar AT %QW0 : BOOL; END_VAR xVar := TRUE; Beim Schreiben der Variablen xVar ist der Ausgangsspeicherbereich von QX0.0 bis QX0.7 betroffen....", 
"body" : "PROGRAM PLC_PRG\nVAR\n xVar AT %QW0 : BOOL;\nEND_VAR\nxVar := TRUE; Beim Schreiben der Variablen xVar ist der Ausgangsspeicherbereich von QX0.0 bis QX0.7 betroffen. " }, 
{ "title" : "Syntax prüfen und Code analysieren ", 
"url" : "_cds_f_checking_syntax_and_code.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Syntax prüfen und Code analysieren ", 
"snippet" : "CODESYS bietet Ihnen nützliche Funktionen, um Sie bei der Programmerstellung zu unterstützen und Fehler festzustellen. Durch die Syntax-Prüfung werden bereits während der Programmeingabe Fehler markiert und entsprechende Meldungen ausgegeben. Die statische Codeanalyse in CODESYS hilft Ihnen zusätzli...", 
"body" : "CODESYS bietet Ihnen nützliche Funktionen, um Sie bei der Programmerstellung zu unterstützen und Fehler festzustellen. Durch die Syntax-Prüfung werden bereits während der Programmeingabe Fehler markiert und entsprechende Meldungen ausgegeben. Die statische Codeanalyse in CODESYS hilft Ihnen zusätzlich festgelegte Kodierrichtlinien einzuhalten sowie fehleranfällige Konstrukte zu erkennen. " }, 
{ "title" : "Syntax prüfen ", 
"url" : "_cds_checking_syntax.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Syntax prüfen und Code analysieren \/ Syntax prüfen ", 
"snippet" : "Während Sie den Code eingeben, führt die Vorkompilierung in CODESYS bereits einige grundlegenden Prüfungen durch. Dabei werden fehlerhafte Stellen im Editor rot unterkringelt und eine Fehlermeldung in der Meldungsansicht ausgegeben. CODESYS erzeugt den Applikationscode aus dem im Entwicklungssystem ...", 
"body" : "Während Sie den Code eingeben, führt die Vorkompilierung in CODESYS bereits einige grundlegenden Prüfungen durch. Dabei werden fehlerhafte Stellen im Editor rot unterkringelt und eine Fehlermeldung in der Meldungsansicht ausgegeben. CODESYS erzeugt den Applikationscode aus dem im Entwicklungssystem geschriebenen Quellcode automatisch vor dem Download der Applikation auf die Steuerung. Dabei wird vor dem Erzeugen des Applikationscodes eine Prüfung der Zuweisungen, der Datentypen und der Verfügbarkeit von Bibliotheken durchgeführt. Weiterhin werden beim Erzeugen des Applikationscodes die Speicheradressen vergeben. Sie können diesen Vorgang auch explizit über den Befehl Erstellen → Code erzeugen oder mit der Taste F11 ausführen. Damit können Sie mögliche Fehler in Ihrem Quellcode finden, auch wenn die Steuerung noch nicht verbunden ist. CODESYS gibt alle Fehler und Warnungen in der Meldungsansicht in der Kategorie Übersetzen aus. Durch einen Doppelklick auf die Fehlermeldung öffnen Sie die betroffene POU im Editor; dabei wird die fehlerhafte Stelle markiert. Alternativ können Sie auch über das Kontextmenü der Fehlermeldung zu den fehlerhaften Stellen springen. Beachten Sie hierzu auch die Einstellungen in den CODESYS -Optionen. " }, 
{ "title" : "Code statisch analysieren ", 
"url" : "_cds_using_static_analysis.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Syntax prüfen und Code analysieren \/ Code statisch analysieren ", 
"snippet" : "Sie können Ihren Quellcode während einer Codegenerierung zusätzlich statisch analysieren („linten“) lassen. Dabei wird ermittelt, ob Ihr Quellcode den von Ihnen festgelegten Codierrichtlinien folgt - gemäß der Idee des „Lint“-Analysewerkzeugs. Im Dialog Projekteinstellungen unter der Kategorie Stati...", 
"body" : "Sie können Ihren Quellcode während einer Codegenerierung zusätzlich statisch analysieren („linten“) lassen. Dabei wird ermittelt, ob Ihr Quellcode den von Ihnen festgelegten Codierrichtlinien folgt - gemäß der Idee des „Lint“-Analysewerkzeugs. Im Dialog Projekteinstellungen unter der Kategorie Static Analysis Light aktivieren Sie die Regeln, die geprüft werden. Die Prüfung selbst erfolgt dann automatisch bei jeder Codegenerierung, beispielsweise wenn Sie den Befehl Erstellen → Code erzeugen wählen. Wenn Abweichungen von den Regeln ermittelt werden, werden diese als Fehlermeldungen der Kategorie Übersetzen im Meldungsfenster ausgegeben. Die dabei gemeldeten Fehler haben einen Präfix: SA<Zahl> . Bei der statischen Codeanalyse mit Static Analysis Light wird nur den Applikationscode des Projekts geprüft. Bibliotheken sind von der Prüfung ausgeschlossen. Variablen einer GVL in der Ansicht POUs werden nicht zwingend geprüft: Wenn Sie ein Projekt mit mehreren Applikationen haben, werden nur die Objekte unter der gerade aktiven Applikation geprüft. Wenn Sie nur eine einzige Applikation haben, werden auch die Objekte im allgemeinen POUs-Pool geprüft. Static Analysis Light ist nur mit einem reduzierten Satz an Regeln im Standard-Entwicklungssystem enthalten. Ein erweiterter Umfang an Regeln, zusätzliche Namenskonventionen und Metriken stehen Ihnen zur Verfügung, wenn Sie das Add-on CODESYS Static Analysis installieren. " }, 
{ "title" : "Codezeilen in Implementierungen mit Pragma von der statischen Analyse ausschließen ", 
"url" : "_cds_using_static_analysis.html#UUID-588186d4-486d-aeee-8a39-77c869f6f9a5_id_fc5b65969af34c0a8640e00fb3e7b_id_07681190e3f611e7be4ba1d6d93507bc", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Syntax prüfen und Code analysieren \/ Code statisch analysieren \/ Codezeilen in Implementierungen mit Pragma von der statischen Analyse ausschließen ", 
"snippet" : "Sie können mit Hilfe des Pragmas {analysis ...} Code so kennzeichnen, dass die dabei angegebenen Regeln nicht geprüft werden. Folglich werden die so gekennzeichneten Codezeilen nicht statische analysiert. Während der Prüfung wird der gekennzeichnete Code ignoriert. Syntax: {analysis <Vorzeichen><Reg...", 
"body" : "Sie können mit Hilfe des Pragmas {analysis ...} Code so kennzeichnen, dass die dabei angegebenen Regeln nicht geprüft werden. Folglich werden die so gekennzeichneten Codezeilen nicht statische analysiert. Während der Prüfung wird der gekennzeichnete Code ignoriert. Syntax: {analysis <Vorzeichen><Regelnummer>|,<weitere Kombinationen von Vorzeichen und Regelnummern, kommasepariert>} -<Regelnummer> : Prüfung der Regel SA<Regelnummer> ausschalten. +<Regelnummer> : Prüfung der Regel SA<Regelnummer> einschalten. Implementierungscode ausschließen Voraussetzung: Sie haben im Dialog Projekteinstellungen Regeln aktiviert. Fügen Sie das Pragma {analysis -<number>} oberhalb der Codezeile ein, die erstmals nicht zu prüfenden Code enthält. Beispielsweise für die Regel SA0024 Die Codezeile ist die erste Zeile des Codeschnipsels, der nicht gegen die Regel 24 geprüft wird. Fügen Sie das Pragma {analysis +<number>} unterhalb der Codezeile ein, die erstmals nicht zu prüfenden Code enthält. Beispiel: Für die Regel SA0024 Die Codezeile oberhalb ist die letzte Zeile des Codeschnipsels, der nicht gegen die Regel 24 geprüft wird. Beispiel: Nicht getyptes Literal ignorieren {analysis -24}\nnTest := 99;\niVar := INT#2;\n{analysis +24} Die Regel SA0024: Nicht getypte Literale ist für 2 Zeilen deaktiviert. Es wird kein Fehler ausgegeben, obwohl der Code nicht korrigiert zu: nTest := DINT#99; Beispiel: Mehrerer Regeln ignorieren {analysis -10, -24, -18}\n...\n{analysis +10, +24, +18} SA0010: Arrays mit nur einer Komponente SA0018: Unübliche Bitzugriffe SA0024: Nicht getypte Literale Allerdings können Sie die Regel SA0004 : Mehrfacher Schreibzugriff auf Ausgang nicht über Pragma deaktivieren. " }, 
{ "title" : "Programmierobjekte mit Pragma von der statischen Analyse ausschließen ", 
"url" : "_cds_using_static_analysis.html#UUID-588186d4-486d-aeee-8a39-77c869f6f9a5_id_fc5b65969af34c0a8640e00fb3e7b_id_0765044be3f611e7be4ba1d6d93507bc", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Syntax prüfen und Code analysieren \/ Code statisch analysieren \/ Programmierobjekte mit Pragma von der statischen Analyse ausschließen ", 
"snippet" : "Syntax: {attribute 'analysis' := '-<rule number>[,<other negative rule numbers, comma-separated>]'} Wenn Sie das Attributpragma im Deklarationsteil eines Programmierobjekts einfügen, werden die angegebenen Regeln für das ganze Programmierobjekt ausgeschlossen. Wenn mehrere Regeln ausgeschlossen werd...", 
"body" : "Syntax: {attribute 'analysis' := '-<rule number>[,<other negative rule numbers, comma-separated>]'} Wenn Sie das Attributpragma im Deklarationsteil eines Programmierobjekts einfügen, werden die angegebenen Regeln für das ganze Programmierobjekt ausgeschlossen. Wenn mehrere Regeln ausgeschlossen werden, sind die Regeln jeweils kommasepariert mit Minus und Nummer anzugeben. Eine Pragmaanweisung für ein Einschalten wird nicht benötigt. Beispiel {attribute 'analysis' := '-33, -31'}\nTYPE LocalData :\nSTRUCT\n iLocal : INT;\n uiLocal : UINT;\n udiLocal : UDINT;\nEND_STRUCT\nEND_TYPE Die Regeln SA0033 und SA0031 werden bei der Struktur LocalData ignoriert. {attribute 'analysis' := '-100'}\nbig: ARRAY[1..10000] OF DWORD; Die Regel SA0100 wird beim Array big ignoriert. " }, 
{ "title" : "Orientieren und Navigieren ", 
"url" : "_cds_f_orientating_navigating.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Orientieren und Navigieren ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Verwendungsstellen mit der Querverweisliste finden ", 
"url" : "_cds_working_with_the_cross_reference_list.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Orientieren und Navigieren \/ Verwendungsstellen mit der Querverweisliste finden ", 
"snippet" : "Sie können sich die Verwendungsstellen von Symbolen, das heißt einer Variablen, einer POU (Programm, Funktionsbaustein, Funktion) oder eines DUT, in einer so genannten „Querverweisliste“ ausgeben lassen. Aus der Liste können Sie dann direkt an die jeweiligen Stellen im Projekt springen. Es gibt zwei...", 
"body" : "Sie können sich die Verwendungsstellen von Symbolen, das heißt einer Variablen, einer POU (Programm, Funktionsbaustein, Funktion) oder eines DUT, in einer so genannten „Querverweisliste“ ausgeben lassen. Aus der Liste können Sie dann direkt an die jeweiligen Stellen im Projekt springen. Es gibt zwei Typen der Suche nach den Verwendungsstellen für ein Symbol: Reine Textsuche: Sie geben dazu in der Ansicht Querverweisliste händisch einen Text (Symbolname, Platzhalter) ein. Suche nach einer konkreten Deklaration: Sie befinden sich in der Ansicht Querverweisliste und wählen die Deklaration aus der Eingabehilfe aus. Der Fokus ist im Editor eines Bausteins in einem Symbolnamen und Sie starten die Querverweissuche über einen Kontextmenübefehl. Der Fokus ist im Editor eines Bausteins in einem Symbolnamen, die Ansicht Querverweisliste ist geöffnet, und die Querverweissuche erfolgt automatisch. Sie befinden sich in der Ansicht Querverweisliste , die bereits Verwendungsstellen für mehrere Deklarationen auflistet, und Sie schränken diese Ergebnisse auf eine bestimmte Deklaration ein. Querverweise für eine konkrete Symboldeklaration Voraussetzung: Ein Baustein ist im Editor geöffnet. Aus dem Bausteineditor, mit Menübefehl Setzen Sie den Cursor auf den Bezeichner des Symbols (Variable, Bausteinname) in der Deklaration oder in der Implementierung. Wählen Sie den Befehl Symbol suchen → Querverweise ausgeben im Kontextmenü oder im Menü Bearbeiten . Die Ansicht Querverweisliste öffnet sich und zeigt die Verwendungsstellen der Variablen oder der POU. Wenn die Ansicht Querverweisliste bereits geöffnet ist, können Sie außerdem auch folgendermaßen nach den Verwendungsstellen für eine bestimmt: Aus dem Bausteineditor, automatisch Aktivieren Sie die Option Querverweise automatisch bei Selektionsänderung aktualisieren in Tools → Optionen in Kategorie Intelligentes Codieren . Selektieren Sie dann den Namen des Symbols im Editorfenster des Bausteins, oder setzen Sie den Cursor in den Namen. Die Querverweisliste zeigt je nach Position der Auswahl\/des Cursors automatisch die Verwendungsstellen für das jeweilige Symbol. In der Ansicht Querverweisliste, mit Eingabehilfe Geben Sie in der Ansicht Querverweisliste über die Eingabehilfe einen Symbolnamen ins Feld neben nach Deklaration ein. Die Querverweisliste zeigt die Verwendungsstellen für das Symbol. In der Ansicht Querverweisliste, Einschränken auf bestimmte Deklaration Wenn in der Ansicht Querverweisliste mehrere Deklarationen für ein Symbol aufgelistet sind, beispielsweise nach einer Textsuche, können Sie die Anzeige auf eine davon reduzieren: Selektieren Sie die Zeile mit der gewünschten Deklaration und klicken auf die Schaltfläche oder wählen Sie den Kontextmenübefehl Ergebnisse auf aktuelle Deklaration beschränken . Die Querverweisliste enthält nur noch die Verwendungsstellen für die selektierte Deklaration. " }, 
{ "title" : "Querverweise über Textsuche nach dem Symbolnamen ", 
"url" : "_cds_working_with_the_cross_reference_list.html#UUID-dc873ea4-cf05-2187-4fed-044a9516d887_id_a4b8449208f4c0a8640e01b561a2_id_23a4d649623b8717c0a86463442f97c6", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Orientieren und Navigieren \/ Verwendungsstellen mit der Querverweisliste finden \/ Querverweise über Textsuche nach dem Symbolnamen ", 
"snippet" : "Voraussetzung: Die Ansicht Querverweisliste ist geöffnet. Geben Sie im Feld neben nach Namen eine Zeichenfolge ein, beispielsweise den Bezeichner der Variablen, für die Sie die Verwendungsstellen im Projekt finden wollen. Beispiel: „ iCounter „ Sie können für die Textsuche die Platzhalter „ * “ (bel...", 
"body" : "Voraussetzung: Die Ansicht Querverweisliste ist geöffnet. Geben Sie im Feld neben nach Namen eine Zeichenfolge ein, beispielsweise den Bezeichner der Variablen, für die Sie die Verwendungsstellen im Projekt finden wollen. Beispiel: „ iCounter „ Sie können für die Textsuche die Platzhalter „ * “ (beliebig viele Zeichen) oder „ ? “ (genau ein beliebiges Zeichen) in Kombination mit einer Teilzeichenkette eines Variablenbezeichners verwenden. Verwenden Sie „ % “ wenn Sie nach IEC-Adressen suchen wollen. Beispiele: „ %MW8 „, „ %M *“ Klicken Sie auf die Schaltfläche , um eine Textsuche im Projekt zu starten. Die Ansicht Querverweisliste öffnet sich und zeigt die Verwendungsstellen für die Variable iCounter . Immer werden dabei die Deklarationsstelle und darunter eingerückt die Verwendungsstellen im Projekt dargestellt. Doppelklicken Sie in der Querverweisliste auf eine Verwendungsstelle. Das entsprechende Objekt wird im Editor geöffnet und die Verwendungsstelle wird markiert. " }, 
{ "title" : "Deklaration finden ", 
"url" : "_cds_goto_definition.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Orientieren und Navigieren \/ Deklaration finden ", 
"snippet" : "CODESYS bietet die Möglichkeit, das gesamte Projekt nach der Definitionsstelle einer Variablen oder Funktion zu durchsuchen. Dabei wird der Baustein, der die Definition enthält, im Editor geöffnet und die Deklaration markiert. Finden der Deklaration einer Variablen Voraussetzung: Es ist eine POU im ...", 
"body" : "CODESYS bietet die Möglichkeit, das gesamte Projekt nach der Definitionsstelle einer Variablen oder Funktion zu durchsuchen. Dabei wird der Baustein, der die Definition enthält, im Editor geöffnet und die Deklaration markiert. Finden der Deklaration einer Variablen Voraussetzung: Es ist eine POU im Editor geöffnet. Setzen Sie den Cursor auf einen Bezeichner in der Implementierung. Wählen Sie den Befehl Bearbeiten → Symbol suchen → Gehe zu Definition . Die POU mit der Deklaration wird im Editor geöffnet und die Definition der Variablen wird markiert. Wenn die Definition in einer „übersetzten“ Bibliothek liegt, wird der entsprechende Baustein im Bibliotheksverwalter geöffnet. Sie können den Befehl im Offline- und Online-Modus verwenden. Beispiele Der folgende Baustein enthält eine Funktionsbaustein-Definition ( fbinst ), einen Programmaufruf ( prog_y() ) und einen Funktionsbaustein-Aufruf ( fbinst.out ): VAR\n fbinst:fb1;\n ivar:INT;\nEND_VAR\n\nprog_y();\nivar:=prog_y.y;\nres1:=fbinst.out; Wenn Sie den Cursor auf prog_y stellen, öffnet der Befehl das Programm prog_y  in seinem Editor. Wenn Sie den Cursor auf fbinst stellen, setzt der Befehl den Fokus ins Deklarationsfenster in Zeile fbinst:fb1; Wenn Sie den Cursor auf out stellen, öffnet der Befehl den Funktionsbaustein fb1 in seinem Editor. " }, 
{ "title" : "Lesezeichen setzen und verwenden ", 
"url" : "_cds_navigating_with_bookmarks.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Orientieren und Navigieren \/ Lesezeichen setzen und verwenden ", 
"snippet" : "Sie können Lesezeichen verwenden, um das Navigieren in langen Programmen zu erleichtern. Lesezeichen können in allen Editoren der Programmiersprachen außer AS (Ablaufsprache) verwendet werden. Über Befehle können Sie direkt zu den markierten Programmstellen navigieren. Springen zu Lesezeichen versch...", 
"body" : "Sie können Lesezeichen verwenden, um das Navigieren in langen Programmen zu erleichtern. Lesezeichen können in allen Editoren der Programmiersprachen außer AS (Ablaufsprache) verwendet werden. Über Befehle können Sie direkt zu den markierten Programmstellen navigieren. Springen zu Lesezeichen verschiedener POUs eines Projekts Ein Projekt mit mehreren POUs ist geöffnet. Mehrere Lesezeichen sind in verschiedenen POUs gesetzt. Wählen Sie den Befehl Ansicht → Lesezeichen . Die Ansicht Lesezeichen öffnet sich. Alle Lesezeichen des Projekts werden in der Ansicht tabellarisch aufgelistet. Klicken Sie auf die Schaltfläche Nächstes Lesezeichen . In der Ansicht Lesezeichen wird das Lesezeichen in der Zeile unterhalb des aktuell selektierten Lesezeichens selektiert. Die POU mit dem neu selektierten Lesezeichen der Tabelle öffnet sich im Editor und die Zeile mit dem Lesezeichen ist in der POU selektiert. Schritt 2 entsprechend können Sie über die Schaltfläche Vorheriges Lesezeichen zu dem Lesezeichen des Projekts springen, das in der Ansicht Lesezeichen in der Zeile darüber angezeigt wird. " }, 
{ "title" : "Setzen\/Löschen von Lesezeichen ", 
"url" : "_cds_navigating_with_bookmarks.html#UUID-0202ce58-db18-3a3e-3f81-14fcd1a390a5_id_d6f70c1e435e81b4c0a8640e0052ef4f_id_8490bbe5442daf0ac0a8640e00d30cae", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Orientieren und Navigieren \/ Lesezeichen setzen und verwenden \/ Setzen\/Löschen von Lesezeichen ", 
"snippet" : "Voraussetzung: Die POU ist im Editor geöffnet. Setzen Sie den Cursor an eine beliebige Programmzeile. Wählen Sie den Befehl Bearbeiten → Lesezeichen → Lesezeichen ein-\/ausschalten . An dieser Programmstelle wird ein Lesezeichen gesetzt. Dies wird durch das Lesezeichensymbol gekennzeichnet. Setzen Si...", 
"body" : "Voraussetzung: Die POU ist im Editor geöffnet. Setzen Sie den Cursor an eine beliebige Programmzeile. Wählen Sie den Befehl Bearbeiten → Lesezeichen → Lesezeichen ein-\/ausschalten . An dieser Programmstelle wird ein Lesezeichen gesetzt. Dies wird durch das Lesezeichensymbol gekennzeichnet. Setzen Sie mehrere Lesezeichen an verschiedenen Programmstellen. Setzen Sie den Cursor an eine Programmzeile mit Lesezeichen. Wählen Sie den Befehl Bearbeiten → Lesezeichen → Lesezeichen ein-\/ausschalten . Das Lesezeichen wird wieder entfernt. Das Lesezeichensymbol wird gelöscht. Alternativ dazu können Sie in der Ansicht Lesezeichen ein oder mehrere Lesezeichen über die Schaltfläche löschen. Hierfür müssen die entsprechenden Lesezeichen in der Ansicht Lesezeichen selektiert sein. Wählen Sie den Befehl Bearbeiten → Lesezeichen → Alle Lesezeichen löschen (aktiver Editor) , um alle Lesezeichen der aktiven POU zu entfernen. Um alle Lesezeichen eines Projekts zu löschen, wählen Sie den Befehl Alle Lesezeichen löschen . Diesen Befehl müssen Sie jedoch zunächst über den Befehl Tools → Anpassen in ein Menü einfügen, damit er zur Verfügung steht. " }, 
{ "title" : "Springen zu Lesezeichen innerhalb einer POU ", 
"url" : "_cds_navigating_with_bookmarks.html#UUID-0202ce58-db18-3a3e-3f81-14fcd1a390a5_id_d6f70c1e435e81b4c0a8640e0052ef4f_id_d7337afc868e9a56c0a8646360d42081", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Orientieren und Navigieren \/ Lesezeichen setzen und verwenden \/ Springen zu Lesezeichen innerhalb einer POU ", 
"snippet" : "Voraussetzung: Die POU ist im Editor geöffnet. Mehrere Lesezeichen sind gesetzt. Wählen Sie den Befehl Bearbeiten → Lesezeichen → Nächstes Lesezeichen (aktiver Editor) . Abhängig von der aktuellen Cursorposition springt der Cursor zum nächsten Lesezeichen (nach unten). Wählen Sie den Befehl Bearbeit...", 
"body" : "Voraussetzung: Die POU ist im Editor geöffnet. Mehrere Lesezeichen sind gesetzt. Wählen Sie den Befehl Bearbeiten → Lesezeichen → Nächstes Lesezeichen (aktiver Editor) . Abhängig von der aktuellen Cursorposition springt der Cursor zum nächsten Lesezeichen (nach unten). Wählen Sie den Befehl Bearbeiten → Lesezeichen → Vorheriges Lesezeichen (aktiver Editor) . Abhängig von der aktuellen Cursorposition springt der Cursor zum vorherigen Lesezeichen (nach oben). " }, 
{ "title" : "Projektweites Suchen und Ersetzen ", 
"url" : "_cds_searching_for_strings.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Projektweites Suchen und Ersetzen ", 
"snippet" : "In Basic Level können Sie Zeichenketten in einzelnen Objekten oder im ganzen Projekt suchen und wenn gewünscht durch eine andere Zeichenkette ersetzen. Aktivieren Sie im Menü Bearbeiten → Suchen Ersetzen den Befehl Suchen . Es öffnet der Dialog Suchen . Geben Sie im Feld Suchen nach die Zeichenkette...", 
"body" : "In Basic Level können Sie Zeichenketten in einzelnen Objekten oder im ganzen Projekt suchen und wenn gewünscht durch eine andere Zeichenkette ersetzen. Aktivieren Sie im Menü Bearbeiten → Suchen Ersetzen den Befehl Suchen . Es öffnet der Dialog Suchen . Geben Sie im Feld Suchen nach die Zeichenkette ein, nach der Sie suchen wollen. Wählen Sie die Suchoptionen aus. Legen Sie in der Auswahlliste Suchen in fest, in welchen Objekten gesucht werden soll. Klicken Sie auf die Schaltfläche Weitersuchen . Der erste Treffer wird angezeigt. Klicken Sie auf die Schaltfläche Ersetzen , wenn Sie den gesuchten Begriff durch einen anderen ersetzen möchten. Klicken Sie auf Alle suchen , wenn Sie einen Übersicht über alle Treffer erhalten wollen. " }, 
{ "title" : "Refactoring ", 
"url" : "_cds_refactoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Refactoring ", 
"snippet" : "Im Allgemeinen ist Refactoring eine Methode, bereits geschriebene Software im Design zu verbessern, ohne ihr Verhalten zu ändern. Refactoring in CODESYS bietet Funktionalitäten zum Umbenennen von Objekt- und Variablennamen und zum Aktualisieren von Bausteinanschlüssen. Sie können alle Verwendungsste...", 
"body" : "Im Allgemeinen ist Refactoring eine Methode, bereits geschriebene Software im Design zu verbessern, ohne ihr Verhalten zu ändern. Refactoring in CODESYS bietet Funktionalitäten zum Umbenennen von Objekt- und Variablennamen und zum Aktualisieren von Bausteinanschlüssen. Sie können alle Verwendungsstellen umbenannter Objekte und Variablen anzeigen lassen und diese dann gesamt oder einzeln ausgewählt umbenennen. Zusätzlich können Sie in Tools → Optionen konfigurieren, ob und an welchen Stellen CODESYS Sie automatisch zum Refactoring auffordert. " }, 
{ "title" : "Globale Variablen umbenennen ", 
"url" : "_cds_refactoring.html#UUID-3adbd988-b291-6a98-0f3c-4708bc43fe33_id_adee5e3a92356c0a8640e0027b4e2_id_9f3bc4e7ebcfe0c6c0a8640e00160c38", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Refactoring \/ Globale Variablen umbenennen ", 
"snippet" : "Voraussetzung: Sie haben ein Projekt geöffnet, das mindestens einen Funktionsbaustein FB und eine globale Variablenliste beinhaltet. Die globale Variablenliste GVL ist in ihrem Editor geöffnet und enthält die Deklaration einer Variablen, beispielsweise iGlobal . FB verwendet iGlobal . Globale Variab...", 
"body" : "Voraussetzung: Sie haben ein Projekt geöffnet, das mindestens einen Funktionsbaustein FB und eine globale Variablenliste beinhaltet. Die globale Variablenliste GVL ist in ihrem Editor geöffnet und enthält die Deklaration einer Variablen, beispielsweise iGlobal . FB verwendet iGlobal . Globale Variablen projektweit umbenennen Selektieren Sie den Namen einer globalen Variablen, zum Beispiel iGlobal . Wählen Sie im Kontextmenü den Befehl Refactoring → iGlobal umbenenen . Geben Sie im Dialog Umbennen in das Eingabefeld Neuer Name einen neuen Namen ein, zum Beispiel iGlobalOK und klicken Sie auf OK . Der Dialog Refactoring öffnet sich. Im linken Fenster, im Gerätebaum, sind die Objekte GVL und FB farblich rot gekennzeichnet und gelb hinterlegt. Im rechten Fenster ist FB in seinem Editor geöffnet und iGlobal ist bereits in iGlobalOK umbenannt. Klicken Sie auf OK . In Ihrem Projekt ist keine globale Variable iGlobal . Überall ist nun iGlobalOK . Globale Variablen projektweit umbenennen (mit Ausnahme einer POU) Selektieren Sie den Namen einer globalen Variablen, zum Beispiel iGlobal . Wählen Sie im Kontextmenü den Befehl Refactoring → iGlobal umbenenen . Geben Sie im Dialog Umbennen in das Eingabefeld Neuer Name einen neuen Namen ein, zum Beispiel iGlobalTest und klicken Sie auf OK . Der Dialog Refactoring öffnet sich. Im linken Fenster, im Gerätebaum, sind die Objekte GVL und FB farblich rot gekennzeichnet und gelb hinterlegt. Im rechten Fenster ist der Funktionsbaustein FB in seinem Editor geöffnet. Statt iGlobal ist iGlobalTest aufgelistet. Positionieren Sie den Cursor in das rechte Fenster und öffnen Sie das Kontextmenü. Wählen Sie den Befehl Dieses Objekt verwerfen und klicken Sie auf OK . In Ihrem Projekt ist die globale Variable iGlobal in FB vorhanden. In den Objekten, in denen die Variable sonst vorkam, ist nun die Variable iGlobalTest angegeben. Im Meldungsfenster erscheint die Fehlermeldung, dass der Bezeichner iGlobal nicht definiert ist. " }, 
{ "title" : "Eingangsvariablen hinzufügen und entfernen ", 
"url" : "_cds_refactoring.html#UUID-3adbd988-b291-6a98-0f3c-4708bc43fe33_id_adee5e3a92356c0a8640e0027b4e2_id_f328830b85d9e6dcc0a8640e0146b3c8", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Refactoring \/ Eingangsvariablen hinzufügen und entfernen ", 
"snippet" : "Sie können im Deklarationsteil von Bausteinen über Refactoringbefehle Eingangs- oder Ausgangsvariablen hinzufügen oder entfernen. An den Verwendungsstellen\/Aufrufstellen der Bausteine aktualisiert CODESYS entsprechend, wobei Sie dies pro Verwendungsstelle akzeptieren oder verwerfen können. Sie erhal...", 
"body" : "Sie können im Deklarationsteil von Bausteinen über Refactoringbefehle Eingangs- oder Ausgangsvariablen hinzufügen oder entfernen. An den Verwendungsstellen\/Aufrufstellen der Bausteine aktualisiert CODESYS entsprechend, wobei Sie dies pro Verwendungsstelle akzeptieren oder verwerfen können. Sie erhalten dazu den Dialog Refactoring . Voraussetzung: Sie haben die POU FCT des Typs Funktion im Editor geöffnet. Die Funktion besitzt bereits Eingangsvariablen input1 und input2 und inputx . Sie wird in den Programmen PLC_PRG und POU aufgerufen. Setzen Sie den Fokus in den Deklarationsteil der Funktion FCT. Wählen Sie Befehl Refactoring → Variable hinzufügen . Der Standarddialog zum Deklarieren einer Variablen erscheint. Deklarieren Sie Variable input_3 mit Gültigkeitsbereich VAR_INPUT und Datentyp INT . Schließen Sie den Dialog mit OK . Der Dialog Refactoring erscheint (siehe Abbildung unten). Die betroffenen Stellen sind gelb markiert. (1)+(2) Wählen Sie rechts oben die Option Eingänge mit Platzhaltertext hinzufügen . (3) Setzen Sie im linken Fenster den Cursor auf einen der gelb hinterlegten Objekte, beispielsweise PLC_PRG . Wählen Sie im Kontextmenü den Befehl Das gesamte Projekt annehmen , um die neue Variable an den Verwendungsstellen von FCT im gesamten Projekt hinzuzufügen. Im rechten Fenster sehen Sie die Änderung im Implementierungsteil von PLC_PRG : Platzhalter _REFACTOR_ erscheint an der Stelle, an der die neue Variable eingefügt wurde. Schließen Sie den Dialog Refactoring mit OK . Wählen Sie Befehl Bearbeiten → Suchen . Suchen Sie im Projekt nach „_REFACTOR_“, um die betroffenen Stellen zu überprüfen und entsprechend zu bearbeiten. Hinweis: Alternativ können Sie die neue Variable direkt mit einem gewünschten Initialisierungswert einfügen, ohne zuerst mit einem Platzhalter zu arbeiten. In diesem Fall wählen Sie bei Schritt 4 die Option „:.mit folgendem Wert hinzufügen“ und tragen den Wert rechts davon ein. Beispiel für neue Variable mit Platzhaltertext in einem CFC-Baustein Beachten Sie auch die Möglichkeit, Variablen über Refactoring zu entfernen. " }, 
{ "title" : "Variablen in der Deklaration neu anordnen ", 
"url" : "_cds_refactoring.html#UUID-3adbd988-b291-6a98-0f3c-4708bc43fe33_id_adee5e3a92356c0a8640e0027b4e2_id_ad60738bbfd811e7ad23a43badec1aad", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Refactoring \/ Variablen in der Deklaration neu anordnen ", 
"snippet" : "Im Deklarationsteil von Bausteinen können Sie über Refactoring die Reihenfolge von Deklarationen verändern. Dies ist möglich bei Deklarationen der Gültigkeitsbereiche VAR_INPUT , VAR_OUTPUT oder VAR_IN_OUT . Voraussetzung: Sie haben den Deklarationsteil einer POU geöffnet, der beispielsweise folgend...", 
"body" : "Im Deklarationsteil von Bausteinen können Sie über Refactoring die Reihenfolge von Deklarationen verändern. Dies ist möglich bei Deklarationen der Gültigkeitsbereiche VAR_INPUT , VAR_OUTPUT oder VAR_IN_OUT . Voraussetzung: Sie haben den Deklarationsteil einer POU geöffnet, der beispielsweise folgende Deklarationen enthält: VAR_INPUT\n invar2 : INT;\n invar1 : INT;\n in : DUT;\n bvar : BOOL;\n invar3 : INT;\nEND_VAR Setzen Sie den Cursor in diesen Deklarationsblock und drücken die rechte Maustaste, um das Kontextmenü zu öffnen. Wählen Sie den Befehl Refactoring → Variablen neu ordnen . Der Dialog Neu ordnen erscheint mit einer Liste der VAR_INPUT -Variablen. Selektieren Sie beispielsweise den Eintrag invar1 : INT; und ziehen ihn mit der Maus vor den Eintrag invar2. . Die Deklaration von invar1 steht jetzt an oberster Stelle. Schließen Sie den Dialog mit OK . Der Dialog Refactoring erscheint. Die betroffenen Stellen sind gelb markiert. (Siehe Abbildung oben) Bestätigen Sie mit OK , um die neue Reihenfolge in den Baustein zu übernehmen. " }, 
{ "title" : "Variablendeklaration ändern und Refactoring automatisch anwenden ", 
"url" : "_cds_refactoring.html#UUID-3adbd988-b291-6a98-0f3c-4708bc43fe33_id_adee5e3a92356c0a8640e0027b4e2_id_86f1778c7d5106b7c0a8646345d4e9bf", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Refactoring \/ Variablendeklaration ändern und Refactoring automatisch anwenden ", 
"snippet" : "Sie werden in der Deklaration beim Umbenennen von Variablen (mit Hilfe der Autodeklaration) von Refactoring unterstützt. Voraussetzung: Funktionsbaustein fb_A . Wählen Sie den Befehl Tools → Optionen . Dialog Optionen öffnet sich. Wählen Sie die Kategorie Refactoring . Aktivieren Sie unter Autodekla...", 
"body" : "Sie werden in der Deklaration beim Umbenennen von Variablen (mit Hilfe der Autodeklaration) von Refactoring unterstützt. Voraussetzung: Funktionsbaustein fb_A . Wählen Sie den Befehl Tools → Optionen . Dialog Optionen öffnet sich. Wählen Sie die Kategorie Refactoring . Aktivieren Sie unter Autodeklaration die Optionen Beim Umbenennen von Variablen und Für das Hinzufügen oder Entfernen von Variablen, oder für das Ändern des Namensraums . Doppelklicken Sie den Funktionsbaustein fb_A . Selektieren Sie in der Deklaration von fb_A eine Variable beispielsweise iA . Alternativ können Sie den Cursor vor oder in die Variable setzen. Geben Sie Bearbeiten → Variable deklarieren ein ( Umschalt + F2 ). Der Dialog Variable deklarieren öffnet sich. Der Dialog enthält die Einstellungen von iA . Ändern Sie den Namen von iA nach iCounter_A . Die Option Änderungen mit Hilfe von Refactoring erscheint und ist aktiviert. Klicken Sie OK . Der Dialog Refactoring Umbenennen von iA in iCounterA öffnet sich. Dort sind alle von der Variablenumbenennung betroffenen Stellen markiert. Beenden Sie den Dialog mit OK . Die Änderungen werden übernommen. " }, 
{ "title" : "Taskkonfiguration ", 
"url" : "_cds_f_task_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Taskkonfiguration ", 
"snippet" : "In der Taskkonfiguration definieren Sie eine oder mehrere Tasks, um den Ablauf von Programmen (POU-Objekte mit Programm -Typ) und den daraus aufgerufenen Programmierobjekten auf Ihrem Gerät zu steuern. Für jede Applikation wird ein Taskkonfiguration -Objekt benötigt. Darin legen Sie die zeitliche Ab...", 
"body" : "In der Taskkonfiguration definieren Sie eine oder mehrere Tasks, um den Ablauf von Programmen (POU-Objekte mit Programm -Typ) und den daraus aufgerufenen Programmierobjekten auf Ihrem Gerät zu steuern. Für jede Applikation wird ein Taskkonfiguration -Objekt benötigt. Darin legen Sie die zeitliche Abfolge für den Programmaufruf fest. Eine Task ist die zeitliche Ablaufeinheit für Ihr IEC-Programm. Die Task legt die Aufrufkette Ihrer Programmierbausteine fest (Aufrufhierarchie). Jede Task benötigt einen eindeutigen Namen. Im Taskkonfigurationseditor tragen Sie in einer Liste ein, welche Programme aufgerufen werden. Die Programme können applikationsspezifisch sein, dann befindet sich das Programm unter der Ansicht Geräte . Oder ein Programm kann projektweit gültig sein, dann befindet es sich unter der Ansicht POUs . Solche Programmierbausteine werden projektweit instantiiert. Sie haben die Möglichkeit eine Task zu priorisieren. Die Priorisierung wirkt in Kombination mit dem Tasktyp. Sie konfigurieren einen Tasktyp: Zyklisch, für einen zeitgesteuerten Ablauf mittels Zyklusintervall. Innerhalb des Zyklusintervalls (Taskzykluszeit) werden die Programmaufrufe durchlaufen. Freilaufend, für eine Task ohne eigene Taskzykluszeit Ereignisgesteuert (intern oder extern) mittels Bedingung für den Ereignisstart (flankengesteuert). Ein Ereignis ist zum Beispiel die steigende Flanke einer globalen Projektvariablen oder ein Interrupt. Statusgesteuert mittels Bedingung Sie haben die Möglichkeit, beispielsweise Start, Stop und Reset direkt mit der Ausführung eines Projektbausteins zu koppeln. Außerdem können Sie für die Zeitüberwachung einen Watchdog aktivieren. Aufgrund dieser Einstellungen in der Taskkonfiguration wird der Aufrufbaum erstellt und ausgeführt. Auf Basis der verschiedenen möglichen Aufrufbäume wird ermittelt, welcher davon der längste mit dem höchsten Speicherbedarf ist (maximale Aufrufbaum). In der Registerkarte Stackverbrauch erhalten Sie detaillierte Informationen dazu. " }, 
{ "title" : "Abarbeitungsreihenfolge ", 
"url" : "_cds_f_task_configuration.html#UUID-36274da0-33e1-95eb-0678-9986502699b8_section-idm234764921910388", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Taskkonfiguration \/ Abarbeitungsreihenfolge ", 
"snippet" : "Regeln für die Abarbeitungsreihenfolge der konfigurierten Tasks Wenn die Bedingung der Task erfüllt ist, wird die Task gestartet und abgearbeitet. Wenn mehrere Tasks gleichzeitig die Bedingung zur Abarbeitung erfüllen, wird zuerst diejenige mit der höchsten Priorität abgearbeitet. Wenn mehrere Tasks...", 
"body" : "Regeln für die Abarbeitungsreihenfolge der konfigurierten Tasks Wenn die Bedingung der Task erfüllt ist, wird die Task gestartet und abgearbeitet. Wenn mehrere Tasks gleichzeitig die Bedingung zur Abarbeitung erfüllen, wird zuerst diejenige mit der höchsten Priorität abgearbeitet. Wenn mehrere Tasks gleichzeitig die Bedingung zur Abarbeitung erfüllen und gleiche Prioritätsstufe haben, wird zuerst diejenige abgearbeitet, die bereits am längsten wartet. Die Abarbeitung der Programmaufrufe erfolgt jeweils in der Reihenfolge, in der die Programme im Konfigurationsdialog der Task angeordnet sind. Wenn ein Programmaufruf nicht eindeutig ist, weil Programme mit gleichem Namen im Gerätebaum der Applikation, in einer Bibliothek oder projektweit im POUs-Fenster vorhanden sind, wird das Programm, das unter dem Applikationsobjekt ist, verwendet. Für weitere Informationen siehe: Buszyklus-Task" }, 
{ "title" : "Wissenswertes ", 
"url" : "_cds_interesting_facts_task_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Taskkonfiguration \/ Wissenswertes ", 
"snippet" : "Alle Tasks teilen sich ein Prozessabbild. Der Grund dafür ist, dass ein eigenes Prozessabbild pro Task zu Lasten der Performance gehen würde. Außerdem kann ein Prozessabbild immer nur für eine Task konsistent sein. So werden Inkonsistenzen vermieden, wenn alle Tasks sich ein Prozessabbild teilen. We...", 
"body" : "Alle Tasks teilen sich ein Prozessabbild. Der Grund dafür ist, dass ein eigenes Prozessabbild pro Task zu Lasten der Performance gehen würde. Außerdem kann ein Prozessabbild immer nur für eine Task konsistent sein. So werden Inkonsistenzen vermieden, wenn alle Tasks sich ein Prozessabbild teilen. Wenn Sie ein Projekt entwickeln, müssen Sie dafür sorgen, dass die Eingangsdaten ( VAR_INPUT ) im Fall eines Konflikts in einen sicheren Bereich kopiert werden. Bei Ausgangsdaten ( VAR_OUTPUT ) gilt dies auch. Möglichkeiten, wie Konsistenz- und Synchronisierungsprobleme zu lösen sind, bieten beispielsweise die Bausteine der Bibliothek SysSem . Konsistenzprobleme können auch beim Zugriff auf andere globale Objekte (globale Variablen oder Bausteine) auftreten. Konsistenzprobleme treten immer dann auf, wenn mehrere Tasks eine Variable lesend und schreibend verwenden. Zur Lösung solcher Konflikte können die Bausteine der SysSem -Bibliothek ebenfalls beitragen. Für weitere Informationen siehe: Bibliotheksdokumentation für SysSem " }, 
{ "title" : "Task konfigurieren ", 
"url" : "_cds_creating_task_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Taskkonfiguration \/ Task konfigurieren ", 
"snippet" : "Unter dem Objekt Taskkonfiguration im Editor des Taskobjekts in der Registerkarte Konfiguration können Sie die Einstellungen einer Task ändern. Wenn ein neues Projekt mit der Vorlage Standardprojekt erstellt wird, ist eine einfacheTaskkonfiguration vorbereitet und die Task MainTask ist bereits vorha...", 
"body" : "Unter dem Objekt Taskkonfiguration im Editor des Taskobjekts in der Registerkarte Konfiguration können Sie die Einstellungen einer Task ändern. Wenn ein neues Projekt mit der Vorlage Standardprojekt erstellt wird, ist eine einfacheTaskkonfiguration vorbereitet und die Task MainTask ist bereits vorhanden. Task ändern Voraussetzung: Das geöffnete Projekt enthält eine POU vom Typ PROGRAM und im Gerätebaum ist unter der Applikation eine Taskkonfiguration mit einer Task eingefügt. Doppelklicken Sie im Gerätebaum auf das Taskobjekt unter der Taskkonfiguration . Es öffnet sich der Taskeditor mit der Registerkarte Konfiguration . Wählen Sie in der Auswahlliste Typ den Eintrag Zyklisch aus. Das Eingabefeld Intervall (z. B. t#200ms) ist sichtbar. Geben Sie in das Feld Intervall (z. B. t#200ms) den Wert t#300ms ein. Klicken Sie auf die Schaltfläche Aufruf hinzufügen . Die Eingabehilfe erscheint. Wählen Sie im Dialog Eingabehilfe aus der Kategorie Programme die gewünschte POU aus und beenden Sie den Dialog mit OK . Die ausgewählte POU erscheint in der Aufrufliste der Registerkarte Konfiguration und im Gerätebaum unterhalb des Taskobjekts. Bei Ausführung der Applikation auf der Steuerung wird die im Taskobjekt ausgewählte POU zyklisch im Intervall von 300 ms ausgeführt. " }, 
{ "title" : "Freilaufende IEC-Task ", 
"url" : "_cds_freewheeling_iec_task.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Taskkonfiguration \/ Freilaufende IEC-Task ", 
"snippet" : "Eine freilaufende Task ist eine Task, die zyklisch, aber ohne festen Taskzyklus ausgeführt wird. Es handelt sich um eine wiederkehrende Task im klassischen Sinn der SPS. Die Ausführung erfolgt so oft wie möglich. Die Abarbeitung erfolgt aber nicht in einem festen Zyklus. Sie können für eine solche T...", 
"body" : "Eine freilaufende Task ist eine Task, die zyklisch, aber ohne festen Taskzyklus ausgeführt wird. Es handelt sich um eine wiederkehrende Task im klassischen Sinn der SPS. Die Ausführung erfolgt so oft wie möglich. Die Abarbeitung erfolgt aber nicht in einem festen Zyklus. Sie können für eine solche Task keine Taskzykluszeit definieren. Das Zeitverhalten wird automatisch gewählt und erfolgt so, dass möglichst keine Belastung für das Gesamtsystem entsteht. Außerdem wird nach Beenden eines Durchlaufs eine bestimmte Zeit gewartet, bis die Task erneut ausgeführt wird. Die Dauer ist ein Prozentsatz der letzten Zyklusdauer. Für die frei laufende Task wird keine feste Taskzykluszeit und kein festes Zeitverhalten garantiert. Für eine freilaufende Task können Sie einen Watchdog konfigurieren. " }, 
{ "title" : "Logik ", 
"url" : "_cds_freewheeling_iec_task.html#UUID-93812248-fffe-e248-6e0b-fbebee0f762c_section-idm234752771243877", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Taskkonfiguration \/ Freilaufende IEC-Task \/ Logik ", 
"snippet" : "Die Last aller freialufender IEC Tasks wird so vom Laufzeitsystem ausgelegt, dass diese Last die Hälfte der eingestellten maximalen Prozessorlast nicht übersteigt. MaxCpuLoadFreewheeling = ((MIN( 100, MaxProcessorload) \/ 2) \/ NumOfFreeWheelingTasks); SleeptimeAfterCycle = CycleTimeFreewheelingTask *...", 
"body" : "Die Last aller freialufender IEC Tasks wird so vom Laufzeitsystem ausgelegt, dass diese Last die Hälfte der eingestellten maximalen Prozessorlast nicht übersteigt. MaxCpuLoadFreewheeling = ((MIN( 100, MaxProcessorload) \/ 2) \/ NumOfFreeWheelingTasks);\nSleeptimeAfterCycle = CycleTimeFreewheelingTask * ((100 - MaxCpuLoadFreewheeling) \/ 100)\nif (SleeptimeAfterCycle < 1000) \/\/ Minimum sleeptime of 1ms is mandatory!   \nSleeptimeAfterCycle = 1000; Beispiel Das Laufzeitsystem einer Applikation läuft wie folgt: MaxProcessorload = 80 CycleTime = 20 ms 1 freilaufende Task Auswirkung MaxCpuLoadFreewheeling = 40 % SleeptimeAfterCycle = 30 ms Gesamte Zykluszeit der freilaufenden Task = 50 ms ⇒ Insgesamt wird eine CPU-Auslastung von 60 % für das restliche System erreicht. " }, 
{ "title" : "Definition von Jitter und Latenz ", 
"url" : "_cds_task_configuration_jitter_definitions.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Taskkonfiguration \/ Definition von Jitter und Latenz ", 
"snippet" : "Im Objekt Taskkonfiguration in der Registerkarte Überwachung können Sie die periodischen Jitterwerte der einzelnen Tasks zur Laufzeit beobachten. Der periodische Jitter ist vom latenzbasierten Release-Jitter zu unterscheiden. Sehen Sie dazu die folgenden Definitionen....", 
"body" : "Im Objekt Taskkonfiguration in der Registerkarte Überwachung können Sie die periodischen Jitterwerte der einzelnen Tasks zur Laufzeit beobachten. Der periodische Jitter ist vom latenzbasierten Release-Jitter zu unterscheiden. Sehen Sie dazu die folgenden Definitionen. " }, 
{ "title" : "Periodischer Jitter ", 
"url" : "_cds_task_configuration_jitter_definitions.html#UUID-9d6853f6-7ed8-8e80-75a4-2a1962e8fe38_id_f981b089a35bd38cc0a864636d261073_id_af58c92ba43a965cc0a8646374364889", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Taskkonfiguration \/ Definition von Jitter und Latenz \/ Periodischer Jitter ", 
"snippet" : "Der periodische Jitter J per ist die Abweichung der Taskzykluszeit T per von der gewünschten Taskzykluszeit T 0 . J p e r = T p e r − T 0 J_{per}=T_{per}−T_0 Die gewünschte (ideale) Zykluszeit T 0 wird in der Konfiguration der Task als Intervall angegeben. Im Taskkonfiguration -Editor in der Registe...", 
"body" : "Der periodische Jitter J per ist die Abweichung der Taskzykluszeit T per von der gewünschten Taskzykluszeit T 0 . J p e r = T p e r − T 0 J_{per}=T_{per}−T_0 Die gewünschte (ideale) Zykluszeit T 0 wird in der Konfiguration der Task als Intervall angegeben. Im Taskkonfiguration -Editor in der Registerkarte Überwachung können Sie den aktuellen Wert sowie die Maximal- und Minimalwerte des periodischen Jitters zur Laufzeit beobachten. Wenn die Summe aller negativen Wert J per nicht gleich der Summe aller positiven Werte J per ist, entsteht eine Drift. " }, 
{ "title" : "Latenz ", 
"url" : "_cds_task_configuration_jitter_definitions.html#UUID-9d6853f6-7ed8-8e80-75a4-2a1962e8fe38_id_f981b089a35bd38cc0a864636d261073_id_fb5ffa33a43a965cc0a8646345523b0d", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Taskkonfiguration \/ Definition von Jitter und Latenz \/ Latenz ", 
"snippet" : "Latenz ist die Verzögerung zwischen dem Aufruf ( Invocation ) einer Task und dem tatsächlichen Ausführungsstart ( Release )....", 
"body" : "Latenz ist die Verzögerung zwischen dem Aufruf ( Invocation ) einer Task und dem tatsächlichen Ausführungsstart ( Release ). " }, 
{ "title" : "Release-Jitter ", 
"url" : "_cds_task_configuration_jitter_definitions.html#UUID-9d6853f6-7ed8-8e80-75a4-2a1962e8fe38_id_f981b089a35bd38cc0a864636d261073_id_533c636ea43a965cc0a864633ee70d81", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Taskkonfiguration \/ Definition von Jitter und Latenz \/ Release-Jitter ", 
"snippet" : "Der Release-Jitter (J r ) ist die Differenz zwischen der maximalen und der minimalen jemals aufgetretenen Latenz (L). J r = L max - L min J_r=L_{\\max}-L_{\\min} Bei L max = L min ergibt sich ein Release-Jitter J r von 0. Dies entspricht einer reinen Offsetverschiebung....", 
"body" : "Der Release-Jitter (J r ) ist die Differenz zwischen der maximalen und der minimalen jemals aufgetretenen Latenz (L). J r = L max - L min J_r=L_{\\max}-L_{\\min} Bei L max = L min ergibt sich ein Release-Jitter J r von 0. Dies entspricht einer reinen Offsetverschiebung. " }, 
{ "title" : "Berechnung des Stackverbrauchs ", 
"url" : "_cds_calculate_stack_usage.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Taskkonfiguration \/ Berechnung des Stackverbrauchs ", 
"snippet" : "Im Objekt  Taskkonfiguration  in der Registerkarte  Stackverbrauch wird der Stackverbrauch pro POU angezeigt. Die Stacknutzung wird von CODESYS statisch über den statischen Aufrufbaum berechnet. Folgendes wird in die Berechnung miteinbezogen: Die Berechnung beginnt bei der impliziten POU für den Tas...", 
"body" : "Im Objekt  Taskkonfiguration  in der Registerkarte  Stackverbrauch wird der Stackverbrauch pro POU angezeigt. Die Stacknutzung wird von CODESYS statisch über den statischen Aufrufbaum berechnet. Folgendes wird in die Berechnung miteinbezogen: Die Berechnung beginnt bei der impliziten POU für den Taskeintritt. Für jeden IEC-Programmaufruf (z. B. PLC_PRG ) wird rekursiv der Stackverbrauch jedes aufgerufenen IEC-Bausteins berechnet. Der größte mögliche Stackverbrauch eines Bausteins wird zu seinem eigenen lokalen Stackverbrauch addiert, um den maximalen Stackverbrauch des Bausteins zu ermitteln. Für dynamische Aufrufe wird der Stackverbrauch wie folgt berechnet: Es wird der Stackverbrauch aller möglichen Implementierungen ermittelt und der größte Stackverbrauch angenommen. Das bedeutet, dass bei Schnittstellen-Methoden alle möglichen Implementierungen und für Funktionsbaustein-Methoden alle möglichen Überschreibungen berücksichtigt werden. Für externe Aufrufe wird der vom Zielgerät spezifizierte Wert angenommen. Wenn das Gerät keinen Wert spezifiziert hat, wird 0 angenommen. Bei Rekursion wird die Berechnung abgebrochen. Für den rekursiv aufgerufenen Code wird der Wert des Arttributpragmas  estimated-stack-usage übernommen. Wenn kein Wert angegeben ist, wird 0 angenommen. Der Stackverbrauch ist daher nur eine Schätzung. Er kann zu hoch sein, weil der angenommene tiefste Aufrufpfad zur Laufzeit nie durchlaufen wird. Er kann aber auch zu niedrig sein, weil Rekursionen oder externe Aufrufe ungünstig abgeschätzt werden. Beispiel " }, 
{ "title" : "Anzeigen des Stackverbrauchs ", 
"url" : "_cds_calculate_stack_usage.html#UUID-565541ba-1a57-4d6d-52b6-33ca85bebcdf", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Taskkonfiguration \/ Berechnung des Stackverbrauchs \/ Anzeigen des Stackverbrauchs ", 
"snippet" : "Doppelklicken Sie auf das Taskkonfiguration s-Objekt. Der Taskkonfigurationseditor öffnet sich. Wählen Sie den Befehl Erstellen → Code erzeugen . Wählen Sie die Registerkarte Stackverbrauch. Die Informationen der Registerkarte werden aktualisiert. Unter Task\/Maximaler Aufrufbaum erscheinen die nache...", 
"body" : "Doppelklicken Sie auf das Taskkonfiguration s-Objekt. Der Taskkonfigurationseditor öffnet sich. Wählen Sie den Befehl Erstellen → Code erzeugen . Wählen Sie die Registerkarte Stackverbrauch. Die Informationen der Registerkarte werden aktualisiert. Unter Task\/Maximaler Aufrufbaum erscheinen die nacheinander aufgerufenen Programmierbausteine, so wie im maximalen Anrufbaum angenommen. In der Spalte Stackgröße wird die berechnete Stackgröße für die POU angezeigt. Beispiel Wenn die Stackgröße rot angezeigt wird, kann es in dem zugehörigen Baustein zu einem Stack-Überlauf kommen. Sie können erkennen, in welchem Programmierbaustein Sie Änderungen vornehmen sollten. Dies ist der erste rot markierte Baustein im Aufrufbaum. " }, 
{ "title" : "Multicore ", 
"url" : "_cds_multi_core.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Taskkonfiguration \/ Multicore ", 
"snippet" : "Im Objekt  Taskkonfiguration  in der Registerkarte  Registerkarte: Taskgruppen wird die Zuordnung von Task und CPU-Kern angezeigt. Heutzutage besitzen immer mehr Steuerungen Prozessoren mit mehreren CPU-Kernen. Wenn CODESYS auf einer Mehrkernsteuerung ausgeführt wird, ohne das Multicore-Feature zu v...", 
"body" : "Im Objekt  Taskkonfiguration  in der Registerkarte  Registerkarte: Taskgruppen wird die Zuordnung von Task und CPU-Kern angezeigt. Heutzutage besitzen immer mehr Steuerungen Prozessoren mit mehreren CPU-Kernen. Wenn CODESYS auf einer Mehrkernsteuerung ausgeführt wird, ohne das Multicore-Feature zu verwenden, wird das Verteilen der Tasks vom Scheduler des Betriebssystems übernommen. Vorausgesetzt, dass eine Applikation mit mehrere Tasks ausgeführt wird. In diesem Fall hat man keinen direkten Einfluss auf die Verteilung der Tasks. Je nach Lastverteilung können die Tasks dann auch auf unterschiedlichen CPU-Kernen laufen. Mit dem CODESYS -Feature Multicore können, unter Berücksichtigung der erworbenen Anzahl von CPU-Kernen, die IEC-Tasks selbst dedizierten CPU-Kernen zugewiesen werden. Dies kann zu einer Verbesserung der Performance führen. Das IEC-Programm sollte hierfür auf mehrere Tasks aufgeteilt werden. Bei der Verteilung der IEC-Tasks auf CPU-Kerne gibt es in CODESYS zwei grundlegend unterschiedliche Strategien: IEC-Task, die fest an einen CPU-Kern gebunden ist: Die Task wird immer auf diesem bestimmten CPU-Kern ausgeführt. Mehrere Tasks können durch Gruppierung an einen CPU-Kern gebunden werden. Dies ist beispielsweise dann sinnvoll, wenn das IEC-Programm noch nicht in der Lage ist, auf mehreren CPU-Kernen gleichzeitig zu laufen. IEC-Task wird auf allen CPU-Kernen ausgeführt: Die Verteilung einer oder mehrerer Tasks einer Gruppe auf die CPU-Kerne übernimmt das Betriebssystem der Steuerung. Bei der Verteilung der IEC-Tasks auf CPU-Kerne ergeben sich einige Änderungen im Verhalten im IEC-Programm, die berücksichtigt werden müssen. Die Abarbeitung von IEC-Tasks nach Priorität ist nicht mehr gegeben! Nur wenn die Tasks gemeinsam auf einen CPU-Kern gebunden sind, werden sie nach ihrer Priorität abgearbeitet. Die Zykluskonsistenz der Daten in der IEC-Task mit höchster Priorität ist nicht mehr gegeben. Daher müssen Daten am Beginn des IEC-Taskzyklus lokal kopiert werden, wenn sich die Werte innerhalb des Zyklus nicht verändern sollen. Für alle Tasks gibt es ein gemeinsames Prozessabbild, aus dem sich die Tasks bedienen. Am Anfang jeder Task wird die Funktion ReadInputs() und am Ende die Funktion WriteOutputs() aufgerufen. Somit ist das EVA-Prinzip für jede Task einzeln betrachtet gültig. Diese Funktionen lesen und schreiben in das gemeinsam genutzte Prozessabbild. Erst wenn die Buszyklustask aufgerufen wird, wird das Prozessabbild auch physikalisch geschrieben und die Pakete übertragen. Die Buszyklustask wartet jedoch auf jeden Aufruf von WriteOutputs und ReadInputs der Tasks. Somit wird die Datenkonsistenz innerhalb der Buszyklustask sichergestellt. Ausgänge können nur einer Task zugeordnet werden. Eingänge können mehreren Tasks zugeordnet werden, ein direkter Zugriff ist jedoch zu vermeiden. Es müssen die Eingänge mittels atomarer Operationen in lokale Variablen der Task geschrieben werden. Eine zweite Task, die parallel zur ersten Task das Prozessabbild mit ReadInputs() aktualisiert, aktualisiert ebenfalls die Eingänge der ersten Task während diese läuft. Die Datenkonsistenz einer Task ist dadurch nur auf Singlekernen für die höchstpriore Task sichergestellt. Sie können die Buszyklustask auf der Registerkarte SPS-Einstellungen einstellen. Sie können die EA-Zugriffe auf der Registerkarte Registerkarte: Taskaufstellung anzeigen. Für weitere Informationen siehe Buszyklus-TaskFür konsistente Zähler (Inkrementer, Dekrementer) sollte immer die atomare externe Bibliotheksfunktion SysCpuAtomicAdd() verwendet werden (Details siehe: SysCpuHandling.library ) Datenkonsistenz von Daten Bitzugriffe (Datentyp BIT ) werden nicht konsistent (atomar) im IEC-Programm auf Mehrkern-CPUs verarbeitet. Hierzu empfehlen wir die Verwendung der externen Bibliotheksfunktion SysCpuTestAndSetBit() . (Details siehe SysCpuHandling.library ) Einfache Datentypen bis 32 Bit Breite ( BOOL , BYTE , WORD \/ INT , DWORD \/ DINT , …) werden konsistent (atomar) im IEC-Programm auch auf Mehrkern-CPUs verarbeitet. 64-Bit Datentypen ( LINT , LWORD , LREAL ) werden im IEC-Programm nur auf 64-Bit Systemen und Mehrkernsystemen konsistent (atomar) verarbeitet. Hier müssen Sie keine Vorkehrungen treffen. Für den Zugriff auf komplexe Datentypen ( STRING s, FB s, STRUCT s, ARRAY s) müssen Sie selbst Vorkehrungen für die Synchronisierung\/Konsistenz treffen. Sie können in der Taskkonfiguration in der Registerkarte Variablenverwendung ermitteln, ob auf eine Variable in einer IEC-Task schreibend oder lesend zugegriffen wird. Auf Mehrkernsystemen kann es zu einem so genannten Memory Reordering Effekt kommen. Näheres dazu siehe IEC-Operator __MemoryBarrier() . Prozessorauslastung pro Prozessorkern im Trace anzeigen Sie können in CODESYS die Prozessorauslastung in einem Objekt DeviceTrace visualisieren. Für weitere Informationen zur Darstellung von Geräte-Traces im Projekt siehe: Zugriff auf alle Traces der Steuerung " }, 
{ "title" : "Tasks auf mehrere Prozessorkerne verteilen ", 
"url" : "_cds_multi_core.html#UUID-3fe3ae5a-9846-6716-c62e-acb89f2bb794_id_bd03ce9b9d30cbc0a864631d9f12af_id_7f76aece9c289dffc0a86463409eb0c2", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Taskkonfiguration \/ Multicore \/ Tasks auf mehrere Prozessorkerne verteilen ", 
"snippet" : "Voraussetzung: Sie haben in Ihrer Applikation mindestens zwei Tasks definiert, beispielsweise MainTask (IEC-Task) und LowTask (IEC-Task). Öffnen Sie das Objekt Taskkonfiguration im Editor. Wechseln Sie zur Registerkarte Taskgruppen . Die Übersicht zeigt die Standard-Taskgruppe IEC-Tasks . Fügen Sie ...", 
"body" : "Voraussetzung: Sie haben in Ihrer Applikation mindestens zwei Tasks definiert, beispielsweise MainTask (IEC-Task) und LowTask (IEC-Task). Öffnen Sie das Objekt Taskkonfiguration im Editor. Wechseln Sie zur Registerkarte Taskgruppen . Die Übersicht zeigt die Standard-Taskgruppe IEC-Tasks . Fügen Sie mit der Schaltfläche Gruppe hinzufügen eine neue Taskgruppe hinzu. Die Gruppe NewGroup wird hinzugefügt. Doppelklicken Sie auf den Gruppennamen NewGroup und ändern sie ihn in LowGroup . Wählen Sie unter Core eine Zuordnung aus, beispielsweise 1 . Öffnen Sie die Task LowTask (IEC-Task) im Editor. Wählen Sie unter Taskgruppe die neu erstelle Gruppe LowGroup aus. Die Task LowTask wird nun durch ihre Gruppenzugehörigkeit LowGroup zu vom Prozessorkern 1 abgearbeitet. " }, 
{ "title" : "Applikation schützen ", 
"url" : "_cds_encrypting_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Applikation schützen ", 
"snippet" : "Know-how-Schutz und Kopierschutz einer Bootapplikation erreichen Sie mit Hilfe einer steuerungsspezifischen Lizenzverwaltung und einer entsprechenden Einstellung in den Objekteigenschaften der Applikation. Der Download-Code und die Bootapplikation können verschlüsselt und signiert werden. Für weiter...", 
"body" : "Know-how-Schutz und Kopierschutz einer Bootapplikation erreichen Sie mit Hilfe einer steuerungsspezifischen Lizenzverwaltung und einer entsprechenden Einstellung in den Objekteigenschaften der Applikation. Der Download-Code und die Bootapplikation können verschlüsselt und signiert werden. Für weitere Informationen siehe: Bootapplikation verschlüsseln und\/oder signieren . " }, 
{ "title" : "Datenpersistenz ", 
"url" : "_cds_f_setting_data_persistence.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz ", 
"snippet" : "Die Lebensdauer von Variablen und deren Daten reicht vom Zeitpunkt, an dem eine Variable erzeugt wird, bis zu dem Zeitpunkt, zu dem sie gelöscht und ihr Speicherplatz wieder freigegeben wird. Der Zeitpunkt der Variablenerzeugung, Initialisierung oder Instanzierung hängt vom deklarierten Gültigkeitsb...", 
"body" : "Die Lebensdauer von Variablen und deren Daten reicht vom Zeitpunkt, an dem eine Variable erzeugt wird, bis zu dem Zeitpunkt, zu dem sie gelöscht und ihr Speicherplatz wieder freigegeben wird. Der Zeitpunkt der Variablenerzeugung, Initialisierung oder Instanzierung hängt vom deklarierten Gültigkeitsbereich ab. Der Zeitpunkt der Speicherfreigabe üblicherweise auch. Beispielsweise wird der Speicher von globalen Variablen mit Beenden der Applikation freigegeben. Sie können Daten länger als üblich erhalten. Dafür stehen Ihnen in CODESYS folgende Mechanismen zur Verfügung. Mechanismen zur Datenerhaltung (A): Persistente Globale Variablenliste mit dem Schlüsselwort PERSISTENT RETAIN Die persistenten Variablen behalten bei einem erneuten Laden der Applikation ihren Wert. Auch nach einem Download, Warmstart, oder Kaltstart werden die Werte wiederhergestellt. (B): Retain-Variablen mit dem Schlüsselwort RETAIN Die Retain-Variablen behalten ihren Wert nach einem Warmstart, nicht aber bei einem erneuten Laden der Applikation, einem Download oder Kaltstart. (C): Variablen des Persistence Managers des CODESYS Application Composer Die Variablen des Persistence Managers werden in einer externen Datei gesichert. (D): Rezepturvariablen Rezepturvariablen und ihre Werten werden in der Rezepturdatei gesichert. " }, 
{ "title" : "Mechanismen im Vergleich ", 
"url" : "_cds_f_setting_data_persistence.html#UUID-b0f99df2-e083-4576-131a-474b581d2136_section-idm4538086982022432656530449314", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Mechanismen im Vergleich ", 
"snippet" : "Welcher Mechanismus ist bei welchem Anwendungsfall geeignet? In der Tabelle werden einige übliche Anwendungsfälle betrachtet. Die konkreten Beispiele beziehen sich auf eine Haussteuerung. Gegenüberstellung von Mechanismen und Anwendungsfällen Anwendungsfall (A) Persistente Variablen (B) Retain-Varia...", 
"body" : "Welcher Mechanismus ist bei welchem Anwendungsfall geeignet? In der Tabelle werden einige übliche Anwendungsfälle betrachtet. Die konkreten Beispiele beziehen sich auf eine Haussteuerung. Gegenüberstellung von Mechanismen und Anwendungsfällen Anwendungsfall (A) Persistente Variablen (B) Retain-Variablen (c) Variablen des Persistence Managers (D) Rezepturvariablen 1 Die Applikation muss Geräteeinstellungen erhalten. Beispiel: Die Haussteuerung muss nach einem Stromausfall die Information, wie lange eine Jalousie für ihr Hochfahren benötigt, zur Verfügung haben. Geeignet 1 Bevorzugter Anwendungsfall Sie können in diesem Fall statt persistenter Variablen auch Retain-Variablen verwenden. Das ist bei Variablen vorteilhaft, deren Deklaration oft geändert wird. Geeignet Bevorzugter Anwendungsfall Retain-Variablen sind vorteilhaft, wenn deren Deklarationen oft geändert werden. Geeignet 2 Vorteilhaft bei Steuerungen, die über keine Hardwareunterstützung verfügen Spezielle Funktionalitäten wie Double File Buffering ermöglichen dies. Möglich, aber sehr umständlich und deshalb nicht empfehlenswert 2 Die Applikation muss Werte auch nach Programmänderungen oder -erweiterungen erhalten. 2a: Seltene Erweiterungen Beispiel: Ein Applikationsprogrammierer erweitert das Programm um einen neuen Schalter und baut ein neues Licht ein. Die Haussteuerung muss bis dahin gesicherte Werte danach noch zur Verfügung haben. Geeignet 1 Bevorzugter Anwendungsfall Geeignet Geeignet 2 Möglich, aber umständlich 2b: Freiere Änderungen, auch Löschen oder Ändern des Datentyps von Variablen Die Haussteuerung läuft und ist persistiert. Wenn ein Applikationsprogrammierer die Steuerung um eine neue Funktionalität und deswegen in einem Funktionsbaustein um eine weitere persistente Variable erweitert, müssen die bis dahin gesicherten Werte erhalten bleiben. Beispielsweise wird das Programm in einem FB um eine Variable, die das automatische Ausschalten einer bisher ungesteuerten Lampe nach einer bestimmten Zeit steuert, erweitert. Die Haussteuerung muss nach der Erweiterung die Zeiten aller gesteuerten Lampen zur Verfügung haben. Nicht geeignet Geeignet Daten von Retain-Variablen bleiben nach einem Online-Change möglichst erhalten. Geeignet , soweit möglich 2 Bevorzugter Anwendungsfall Möglich, wenn textuell, aber umständlich 2c: Die Applikation muss Werte nach einem Download erhalten. Geeignet Nicht geeignet Geeignet Geeignet 3 Die Applikation muss unterschiedliche Wertesätze verwenden können. Beispiel: Die Betriebseinstellungen für Sommer, Winter und Urlaub müssen gespeichert und nach Bedarf wieder eingespielt werden können. Nicht geeignet Nicht geeignet Nicht geeignet Geeignet Bevorzugter Anwendungsfall 4 Die Applikation muss Einstellungen von einem anderen System verwenden können. Das Übertragen von Einstellungen auf eine andere Anlage, die ähnliche Variablen verwendet, muss möglich sein. Nicht geeignet Nicht geeignet Geeignet 2 Geeignet 3 5 Die Applikation muss menschenlesbare Daten zur Verfügung stellen. Der Benutzer muss die Daten lesen, vergleichen und editieren können. Nicht geeignet Nicht geeignet Geeignet 2 Geeignet 3 1 Nachteil: Nur möglich, wenn das Laufzeitsystem diesen Mechanismus unterstützt und ein NVRam-Speicher oder USV vorhanden ist. Vorteil: Schnelligkeit; empfohlener Anwendungsfall: 1 und 2a 2 Nachteil: Im Fall einer großen Variablenmenge (> 10000) ist mit langen Wartezeiten bei einer Initialisierung und einem Shutdown zu rechnen. Vorteil: Keine spezielle Speicherausstattung ist nötig; Werteerhalt besteht auch bei Änderungen, Erweiterungen oder Löschungen. 3 Vorteil: Extern bearbeitbar, Übertragbarkeit. Nachteil: Umständlich " }, 
{ "title" : "Lebensdauer von Variablen bei Aufruf von Onlinebefehlen ", 
"url" : "_cds_f_setting_data_persistence.html#UUID-b0f99df2-e083-4576-131a-474b581d2136_section-idm4654689529028832656531875814", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Lebensdauer von Variablen bei Aufruf von Onlinebefehlen ", 
"snippet" : "Benutzereingaben im Menü Online Variable mit üblicher Lebensdauer Weder RETAIN noch PERSISTENT RETAIN PERSISTENT RETAIN PERSISTENT PERSISTENT RETAIN Befehl Online-Change x x x Befehl Reset warm i x x Befehl Reset kalt i i x Befehl Laden i i x 1 Befehl Reset Ursprung i i i x : Die Variable behält ihr...", 
"body" : "Benutzereingaben im Menü Online Variable mit üblicher Lebensdauer Weder RETAIN noch PERSISTENT RETAIN PERSISTENT RETAIN PERSISTENT PERSISTENT RETAIN Befehl Online-Change x x x Befehl Reset warm i x x Befehl Reset kalt i i x Befehl Laden i i x 1 Befehl Reset Ursprung i i i x : Die Variable behält ihren Wert. i : Die Variable wird initialisiert. 1 Hinweis: Zur Struktur von persistenten Daten beachten Sie bitte die Informationen unter „Mechanismus beim Download“. " }, 
{ "title" : "Lebensdauer von Variablen beim Laden einer Bootapplikation ", 
"url" : "_cds_f_setting_data_persistence.html#UUID-b0f99df2-e083-4576-131a-474b581d2136_section-idm4501210508424032656532565093", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Lebensdauer von Variablen beim Laden einer Bootapplikation ", 
"snippet" : "Die Werte von normalen Variablen verlieren ihren Wert und werden neu initialisiert. Die Werte von persistenten Variablen bleiben erhalten, wenn die Struktur der persistenten Variablen im Speicher zur Struktur in der persistenten Datenliste passt. wenn die persistenten Daten nur erweitert wurden. In ...", 
"body" : "Die Werte von normalen Variablen verlieren ihren Wert und werden neu initialisiert. Die Werte von persistenten Variablen bleiben erhalten, wenn die Struktur der persistenten Variablen im Speicher zur Struktur in der persistenten Datenliste passt. wenn die persistenten Daten nur erweitert wurden. In diesem Fall werden nur die neu hinzugekommenen Variablen mit ihren Standardwerten gesetzt. Die Werte von Retain-Variablen bleiben erhalten, wenn die Struktur der Retain-Variablen im Speicher zur Struktur in der persistenten Datenliste passt. wenn die Retain-Variablen zur Applikation passen (GUID muss übereinstimmen). Wenn beim Booten der Applikation die Voraussetzungen für das Wiederherstellen der Werte von Retain-Variablen und persistenten Variablen nicht erfüllt sind, erfolgt ein „Retain mismatch“. Die Reaktion auf diese Unstimmigkeit ist in der Dokumentation des Hardwareherstellers beschrieben. Für weitere Informationen siehe: Daten mit persistenten Variablen erhalten" }, 
{ "title" : "Daten mit persistenten Variablen erhalten ", 
"url" : "_cds_preserve_data_with_persistent_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit persistenten Variablen erhalten ", 
"snippet" : "Persistente Variablen behalten ihren Wert bei einem erneuten Laden der Applikation, nach einem Download, Warmstart oder Kaltstart. Für die Verlängerung der Lebensdauer ist ein spezieller nichtflüchtiger Speicherbereich auf der Steuerung nötig, beispielsweise als NVRAM oder USV. Das Sichern der Daten...", 
"body" : "Persistente Variablen behalten ihren Wert bei einem erneuten Laden der Applikation, nach einem Download, Warmstart oder Kaltstart. Für die Verlängerung der Lebensdauer ist ein spezieller nichtflüchtiger Speicherbereich auf der Steuerung nötig, beispielsweise als NVRAM oder USV. Das Sichern der Daten in einem solchen Speicher erfordert keinen zusätzlichen Zeitbedarf, was ein Vorteil gegenüber dem Datenerhalt mit Persistence Manager ist. Wenn die Steuerung keine Hardware-Unterstützung bietet, werden die Daten üblicherweise in einer Datei gespeichert. Dann bleiben die Daten zwar erhalten, wenn Sie die Steuerung korrekt herunterfahren. Bei einem Stromausfall oder einem „Stecker ziehen“ kommt es aber zum Datenverlust. " }, 
{ "title" : "Verhalten ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_id_cfd8277ed14d9477c0a86463695b061a_id_e6bc7e4a5dd83963c0a8652d0077df17", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit persistenten Variablen erhalten \/ Verhalten ", 
"snippet" : "Werterhalt bei Unkontrolliertem Beenden Warmstart durch Aufruf des Befehls Reset warm Kaltstart durch Aufruf des Befehls Reset kalt Erneutem Download der Applikation Laden der Bootapplikation Neuinitialisierung bei Aufruf des Befehls Reset Ursprung Persistente Variablen werden also nur dann neu init...", 
"body" : "Werterhalt bei Unkontrolliertem Beenden Warmstart durch Aufruf des Befehls Reset warm Kaltstart durch Aufruf des Befehls Reset kalt Erneutem Download der Applikation Laden der Bootapplikation Neuinitialisierung bei Aufruf des Befehls Reset Ursprung Persistente Variablen werden also nur dann neu initialisiert, wenn Sie die Steuerung in den Auslieferungszustand zurücksetzen, beispielsweise wenn Sie den Befehl Online → Reset Ursprung wählen. Wenn Sie dagegen ein erneutes Laden der Applikation ausführen, bleiben die persistierten Daten nach Möglichkeit erhalten. Das hängt davon ab, wie tiefgreifend die Änderungen waren. Eine Änderung des Applikationsnamens führt immer zu einer vollständigen Neuinitialisierung. Änderungen der Implementierungen führen nie zu einer Neuinitialisierung: Die Datenpersistenz bleibt vollständig erhalten. Änderungen der Deklarationen führen zu einer Initialisierung nur der neuen Variablen bei Persistenz der bestehenden Variablen, wenn Folgendes beachtet wird: Sie ändern die Deklarationen so, dass die persistente Variablenliste konsistent bleibt. Das ist der Fall, wenn Sie eine neue Variable hinzufügen oder eine bestehende löschen. Inkonsistenzen können entstehen, wenn Sie die Bezeichner oder die Datentypen der vorher deklarierten, persistenten Variablen bearbeiten und ändern. " }, 
{ "title" : "Mechanismus beim Download der Applikation oder Laden einer Bootapplikation ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_id_cfd8277ed14d9477c0a86463695b061a_id_026b80bfdb38eee2c0a8646329d5dfb6", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit persistenten Variablen erhalten \/ Mechanismus beim Download der Applikation oder Laden einer Bootapplikation ", 
"snippet" : "Wenn Sie im Persistenzeditor die Variablenliste bearbeiten, bewirken Sie, dass die Variablenliste nicht so wie im Editor dargestellt gespeichert wird, sondern automatisch nachbearbeitet wird, bevor sie gespeichert wird. Bei der Nachbearbeitung wird eine Variable, die Sie entfernt haben, durch eine P...", 
"body" : "Wenn Sie im Persistenzeditor die Variablenliste bearbeiten, bewirken Sie, dass die Variablenliste nicht so wie im Editor dargestellt gespeichert wird, sondern automatisch nachbearbeitet wird, bevor sie gespeichert wird. Bei der Nachbearbeitung wird eine Variable, die Sie entfernt haben, durch eine Platzhaltervariable mit dem gleichen Speicherbedarf ersetzt. Das führt dazu, dass im Prozessabbild die nachfolgenden Variablen ihre Adressen beibehalten. Außerdem wird eine Variable, die Sie hinzufügen, ans Ende der Liste verschoben. Durch die Nachbearbeitung können Änderungen, die zu Persistenzverlust führen würden, neutralisiert werden. Aber Sie erzeugen Lücken, die zusätzlichen Speicher belegen. Beim Laden der Applikation wird auf der Steuerung der CRC-Wert der Variablenliste und die Länge der Liste (Anzahl der Variablen) hinterlegt. Beim erneuten Laden der Applikation wird der neue Prüfwert mit dem aktuell auf der Steuerung befindlichen Prüfwert verglichen. Dann wird die Variablenliste sukzessive bis zu der angegebenen Länge verglichen. Wenn Sie eine Deklaration, also den Namen oder den Datentyp, bearbeitet haben, wird die Variable neu initialisiert. Ansonsten bleibt ihr Wert erhalten. Beim erneutem Laden der Applikation überprüft also CODESYS , ob die im Persistenzeditor deklarierte Variablenliste noch konsistent zur bereits auf der Steuerung liegenden Variablenliste ist. Der Mechanismus funktioniert dann gut, wenn die Variablen selbst nicht gravierend geändert werden. Zu weitreichende Änderungen bei den Bezeichnern und den Datentypen führen auch weiterhin zu einer Neuinitialisierung und dem Verlust der Persistenz. Wenn Sie aufgrund Ihrer Anwendungsanforderungen häufige Änderungen voraussehen, ist eine solche Liste deshalb grundsätzlich nicht empfehlenswert. Außerdem ist bei einem Online-Change nach einer Datentypänderung eine persistente Variable weniger robust als eine Variable mit üblicher Lebensdauer. Grundsätzlich sollten Sie nach einiger Zeit die Variablenliste von Lücken bereinigen und den Befehl Liste neu ordnen und Lücken bereinigen ausführen. Nach dem Bereinigen passt die Liste aber nicht mehr zu der Liste auf der Steuerung und Sie haben eine Initialisierung aller persistenten Variablen provoziert. Die Persistenz aller Variablen geht verloren. Bei Versionen vor V3.5 SP1 führen Änderungen im Persistenzeditor immer zu einer Neuinitialisierung. " }, 
{ "title" : "Daten retten über den Rezepturverwalter ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_section-idm454453384126563278957291646", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit persistenten Variablen erhalten \/ Daten retten über den Rezepturverwalter ", 
"snippet" : "Um die globale persistente Variablenliste zu bereinigen ohne die Persistenz zu verlieren, können Sie die Daten mit Hilfe des Rezepturverwalters in einer Rezeptur sichern. Dabei wird im Rezepturverwalter eine Liste für alle Variablen der persistenten Variablenliste erzeugt und gleichzeitig werden der...", 
"body" : "Um die globale persistente Variablenliste zu bereinigen ohne die Persistenz zu verlieren, können Sie die Daten mit Hilfe des Rezepturverwalters in einer Rezeptur sichern. Dabei wird im Rezepturverwalter eine Liste für alle Variablen der persistenten Variablenliste erzeugt und gleichzeitig werden deren aktuellen Werte von der Steuerung als Rezeptur abgespeichert. Wählen Sie anschließend den Befehl Liste neu ordnen und Lücken bereinigen und führen Sie danach einen erneuten Download aus. Wenn Sie nun den Befehl Werte aus Rezeptur wiederherstellen auswählen, werden die in der Rezeptur gespeicherten Werte wiederhergestellt. " }, 
{ "title" : "Änderung einer bestehenden Deklaration in der Persistenten Variablenliste ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_id_cfd8277ed14d9477c0a86463695b061a_id_adb14f80ef92a200c0a8646350a7e5b5", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit persistenten Variablen erhalten \/ Änderung einer bestehenden Deklaration in der Persistenten Variablenliste ", 
"snippet" : "Wenn Sie Namen oder Datentyp einer Variablen ändern, gilt das als neue Deklaration und bewirkt beim nächsten Online-Change oder Laden der Applikation eine Initialisierung der Variablen. Bei komplexen Datentypen liegt eine Änderung bereits dann vor, wenn eine neue Komponente hinzugefügt wurde, oder w...", 
"body" : "Wenn Sie Namen oder Datentyp einer Variablen ändern, gilt das als neue Deklaration und bewirkt beim nächsten Online-Change oder Laden der Applikation eine Initialisierung der Variablen. Bei komplexen Datentypen liegt eine Änderung bereits dann vor, wenn eine neue Komponente hinzugefügt wurde, oder wenn Sie in der Tiefe einer verwendeten Struktur beispielsweise den Typ einer Variablen von INT nach UINT ändern. Grundsätzlich sind komplexe benutzerdefinierte Datentypen für die Verwaltung in einer persistenten Variablenliste nicht geeignet, da selbst kleine Änderungen bewirken, dass die Variable mit allen Komponenten initialisiert wird. " }, 
{ "title" : "Doppelallokation von Speicher bei Instanzpfaden ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_id_cfd8277ed14d9477c0a86463695b061a_id_91675dcb1796868bc0a864635066dcfe", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit persistenten Variablen erhalten \/ Doppelallokation von Speicher bei Instanzpfaden ", 
"snippet" : "Sie können globale Variablen oder lokal in einem Funktionsbaustein oder einem Programms deklarierte Variablen persistieren. Dafür ergänzen Sie die Deklaration mit dem Schlüsselwort PERSISTENT . Zusätzlich fügen Sei in der persistenten globalen Variablenliste den Instanzpfad auf diese Variable ein. W...", 
"body" : "Sie können globale Variablen oder lokal in einem Funktionsbaustein oder einem Programms deklarierte Variablen persistieren. Dafür ergänzen Sie die Deklaration mit dem Schlüsselwort PERSISTENT . Zusätzlich fügen Sei in der persistenten globalen Variablenliste den Instanzpfad auf diese Variable ein. Wählen Sie dafür im Persistenzeditor den Befehl Alle Instanzpfade hinzufügen . Die Persistenz wird über folgenden Mechanismus garantiert: Es wird ermittelt, in welchen zyklischen Tasks ein Zugriff auf die Variable erfolgt. Am Ende der ersten zyklischen Task (in jedem Zyklus) wird die Variable in die persistente globale Variablenliste kopiert. Nach dem Neustart der Steuerung wird der Wert von der persistenten Variable in die normale Variable kopiert. Nachteil dieses Mechanismus ist, dass sowohl an der Deklarationsstelle als auch an der Stelle des Instanzpfades Speicher allokiert wird. Diese persistente Variable belegt doppelten Speicherplatz. Außerdem werden die Daten in jedem Zyklus an beide Stellen kopiert. Insbesondere wenn es sich um große, strukturierte Werte handelt, kann das zeitintensiv sein. " }, 
{ "title" : "Speicherlokation bei persistenten Funktionsbaustein-Instanzen ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_id_cfd8277ed14d9477c0a86463695b061a_id_cccc8c251cf2cccdc0a8646315994b40", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit persistenten Variablen erhalten \/ Speicherlokation bei persistenten Funktionsbaustein-Instanzen ", 
"snippet" : "Eine Funktionsbaustein-Instanz liegt immer vollständig im Speicher. Das ist notwendig, damit der gleiche Code auf verschiedenen Instanzen arbeiten kann. Wenn nun nur eine Variable in einem Funktionsbaustein mit PERSISTENT gekennzeichnet wird, wird die Funktionsbaustein-Instanz vollständig mit allen ...", 
"body" : "Eine Funktionsbaustein-Instanz liegt immer vollständig im Speicher. Das ist notwendig, damit der gleiche Code auf verschiedenen Instanzen arbeiten kann. Wenn nun nur eine Variable in einem Funktionsbaustein mit PERSISTENT gekennzeichnet wird, wird die Funktionsbaustein-Instanz vollständig mit allen Variablen im remanenten Speicher abgelegt, obwohl nur die eine Variable als persistent behandelt wird. Nichtflüchtiger Speicher steht aber nicht in gleichem Umfang zur Verfügung wie Arbeitsspeicher. Ein Funktionsbaustein, der als Variable einen Pointer auf eine Instanz im SRAM hat, wird nicht im gesicherten Speicher abgelegt. " }, 
{ "title" : "Import von CoDeSys V2.3 -Projekten ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_id_cfd8277ed14d9477c0a86463695b061a_id_574bae341796868bc0a86463467e40bc", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit persistenten Variablen erhalten \/ Import von CoDeSys V2.3 -Projekten ", 
"snippet" : "Wenn Sie ein CoDeSys V2.3 -Projekt öffnen, um es in CODESYS V3 zu importieren, bleiben die Deklarationen von persistenten Variablen nicht erhalten. Sie müssen die Deklarationen überarbeiten und in einer eigenen persistenten globalen Variablenliste neu erstellen....", 
"body" : "Wenn Sie ein CoDeSys V2.3 -Projekt öffnen, um es in CODESYS V3 zu importieren, bleiben die Deklarationen von persistenten Variablen nicht erhalten. Sie müssen die Deklarationen überarbeiten und in einer eigenen persistenten globalen Variablenliste neu erstellen. " }, 
{ "title" : "Daten mit Retain-Variablen erhalten ", 
"url" : "_cds_preserve_data_with_retain_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit Retain-Variablen erhalten ", 
"snippet" : "Retain-Variablen behalten ihren Wert nach einen Warmstart. Der Grad der Werteerhaltung ist bei persistenten Variablen aber höher. Für die Verlängerung der Lebensdauer ist ein spezieller nichtflüchtiger Speicherbereich auf der Steuerung nötig, beispielsweise als NVRAM oder USV. Das Sichern der Retain...", 
"body" : "Retain-Variablen behalten ihren Wert nach einen Warmstart. Der Grad der Werteerhaltung ist bei persistenten Variablen aber höher. Für die Verlängerung der Lebensdauer ist ein spezieller nichtflüchtiger Speicherbereich auf der Steuerung nötig, beispielsweise als NVRAM oder USV. Das Sichern der Retain-Variablen in einem solchen Speicher erfordert keinen zusätzlichen Zeitbedarf, was ein Vorteil gegenüber dem Datenerhalt mit Persistence Manager ist. Wenn die Steuerung keine Hardware-Unterstützung bietet, werden die Daten üblicherweise in einer Datei gespeichert. Dann bleiben die Daten zwar erhalten, wenn Sie die Steuerung korrekt herunterfahren. Bei einem Stromausfall oder einem „Stecker ziehen“ kommt es aber zum Datenverlust. " }, 
{ "title" : "Deklaration ", 
"url" : "_cds_preserve_data_with_retain_variables.html#UUID-2a4bd8c7-3a50-60c2-6dd4-d05d5cf2d578_id_f24d7503d14dee35c0a8646344406010_id_803fd478db437037c0a8646355c3075d", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit Retain-Variablen erhalten \/ Deklaration ", 
"snippet" : "Um eine Retain-Variable zu deklarieren, fügen Sie einer Variablendeklaration das Schlüsselwort RETAIN hinzu....", 
"body" : "Um eine Retain-Variable zu deklarieren, fügen Sie einer Variablendeklaration das Schlüsselwort RETAIN hinzu. " }, 
{ "title" : "Verhalten ", 
"url" : "_cds_preserve_data_with_retain_variables.html#UUID-2a4bd8c7-3a50-60c2-6dd4-d05d5cf2d578_id_f24d7503d14dee35c0a8646344406010_id_91675dcb1796868bc0a864635066dcfe", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit Retain-Variablen erhalten \/ Verhalten ", 
"snippet" : "Werterhalt bei Neustart der Steuerung Unkontrolliertem Beenden (nur verfügbar bei Hardwareunterstützung wie einem NvRAM) Aufruf des Befehls Reset warm Neuinitialisierung bei Erneutem Download der Applikation Aufruf des Befehls Reset kalt (im Gegensatz zu persistenten Variablen) Aufruf des Befehls Re...", 
"body" : "Werterhalt bei Neustart der Steuerung Unkontrolliertem Beenden (nur verfügbar bei Hardwareunterstützung wie einem NvRAM) Aufruf des Befehls Reset warm Neuinitialisierung bei Erneutem Download der Applikation Aufruf des Befehls Reset kalt (im Gegensatz zu persistenten Variablen) Aufruf des Befehls Reset Ursprung Wenn Sie eine Applikation neu starten, werden deren Variablen üblicherweise mit einem explizit vorgegebenen Initialwerten oder mit einem Standardwert initialisiert. Variablen, die mit dem Schlüsselwort RETAIN gekennzeichnet sind, werden zielsystemabhängig in einem eigenen Speicherbereich verwaltet und behalten ihren Wert. Die Variablen sind so beispielsweise gegen Stromausfall geschützt. Sie können Retain-Variablen also bei einem Stückzähler in einer Fertigungsanlage anwenden, um auch nach einem Stromausfall weiterzählen zu können. " }, 
{ "title" : "Speicherlokation von Retain-Funktionsbaustein-Instanzen ", 
"url" : "_cds_preserve_data_with_retain_variables.html#UUID-2a4bd8c7-3a50-60c2-6dd4-d05d5cf2d578_id_f24d7503d14dee35c0a8646344406010_id_cccc8c251cf2cccdc0a8646315994b40", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit Retain-Variablen erhalten \/ Speicherlokation von Retain-Funktionsbaustein-Instanzen ", 
"snippet" : "Funktionsbaustein-Instanzen liegen am Stück im Speicher. Das ist notwendig, damit der gleiche Code auf verschiedenen Instanzen arbeiten kann. Wenn nun eine Variable in einem Funktionsbaustein mit RETAIN gekennzeichnet ist, dann wird jede Instanz des Funktionsbausteins mit allen Variablen gesichert. ...", 
"body" : "Funktionsbaustein-Instanzen liegen am Stück im Speicher. Das ist notwendig, damit der gleiche Code auf verschiedenen Instanzen arbeiten kann. Wenn nun eine Variable in einem Funktionsbaustein mit RETAIN gekennzeichnet ist, dann wird jede Instanz des Funktionsbausteins mit allen Variablen gesichert. Auch die Variablen des Funktionsbausteins, die nicht so gekennzeichnet sind. Nichtflüchtiger Speicher steht aber nicht in gleichem Maß zur Verfügung wie Arbeitsspeicher. Ein Funktionsbaustein, der als Variable einen Pointer auf eine Instanz im SRAM hat, wird nicht im gesicherten Speicher abgelegt. " }, 
{ "title" : "Import von CoDeSys V2.3 -Projekten ", 
"url" : "_cds_preserve_data_with_retain_variables.html#UUID-2a4bd8c7-3a50-60c2-6dd4-d05d5cf2d578_id_f24d7503d14dee35c0a8646344406010_id_574bae341796868bc0a86463467e40bc", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit Retain-Variablen erhalten \/ Import von CoDeSys V2.3 -Projekten ", 
"snippet" : "Wenn Sie ein CoDeSys V2.3 -Projekt öffnen, um es in CODESYS V3 zu importieren, bleiben die Deklarationen von Retain-Variablen erhalten und sind unverändert wirksam. Für weitere Informationen siehe RETAIN und V2.3-Projekt öffnen...", 
"body" : "Wenn Sie ein CoDeSys V2.3 -Projekt öffnen, um es in CODESYS V3 zu importieren, bleiben die Deklarationen von Retain-Variablen erhalten und sind unverändert wirksam. Für weitere Informationen siehe RETAIN und V2.3-Projekt öffnen" }, 
{ "title" : "Daten mit Variablen des Persistence Managers erhalten ", 
"url" : "_cds_preserve_data_ac.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit Variablen des Persistence Managers erhalten ", 
"snippet" : "Im Persistence Manager des Application Composers werden Variablen persistent verwaltet. Die Funktionalität des Persistence Manager benötigt auf der Steuerung keinen speziellen Speicher, um Werte und Daten zu erhalten....", 
"body" : "Im Persistence Manager des Application Composers werden Variablen persistent verwaltet. Die Funktionalität des Persistence Manager benötigt auf der Steuerung keinen speziellen Speicher, um Werte und Daten zu erhalten. " }, 
{ "title" : "Deklaration ", 
"url" : "_cds_preserve_data_ac.html#UUID-bbc6d774-55f9-b4d3-e6de-af462b9c94be_id_a536c64d14eb304c0a864635f20c358_id_4041284cefc6aceec0a864630792390d", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit Variablen des Persistence Managers erhalten \/ Deklaration ", 
"snippet" : "In den Deklarationen sind die im Persistence Manager verwalteten Variablen mit dem Pragma {attribute 'ac_persist'} gekennzeichnet. Das Pragma bewirkt, dass die so attributierte Variable im Persistence Manager des Application Composer verwaltet wird. Der Variablenwert bleibt erhalten, auch wenn Sie d...", 
"body" : "In den Deklarationen sind die im Persistence Manager verwalteten Variablen mit dem Pragma {attribute 'ac_persist'} gekennzeichnet. Das Pragma bewirkt, dass die so attributierte Variable im Persistence Manager des Application Composer verwaltet wird. Der Variablenwert bleibt erhalten, auch wenn Sie die Deklaration der Variablen ändern und beispielsweise eine Variable aus der Applikation löschen oder eine neue hinzufügen. Der Wert bleibt auch dann erhalten, wenn Sie den Datentyp ändern und dabei die passenden Konvertierungen verwenden. " }, 
{ "title" : "Mechanismus ", 
"url" : "_cds_preserve_data_ac.html#UUID-bbc6d774-55f9-b4d3-e6de-af462b9c94be_id_a536c64d14eb304c0a864635f20c358_id_c56775d6efc6aceec0a86463532fbcfd", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit Variablen des Persistence Managers erhalten \/ Mechanismus ", 
"snippet" : "Die Variablen des Persistence Manager werden zusammen mit ihren Werten in einer externen Archivdatei im TXT-Format gespeichert. Der Applikationscode wird dabei um den Code des Persistence Managers erweitert, was zu einem größeren Speicherbedarf führt. Das geht auf Kosten der Performanz. Außerdem kan...", 
"body" : "Die Variablen des Persistence Manager werden zusammen mit ihren Werten in einer externen Archivdatei im TXT-Format gespeichert. Der Applikationscode wird dabei um den Code des Persistence Managers erweitert, was zu einem größeren Speicherbedarf führt. Das geht auf Kosten der Performanz. Außerdem kann das Lesen und insbesondere das Schreiben einer großen Menge persistenter Variablen sehr lange dauern. Infolgedessen blockiert die ausführende Task entsprechend lange die Ausführung. " }, 
{ "title" : "Funktionalität ", 
"url" : "_cds_preserve_data_ac.html#UUID-bbc6d774-55f9-b4d3-e6de-af462b9c94be_id_a536c64d14eb304c0a864635f20c358_id_3a850974d202a5e6c0a8646366306c87", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit Variablen des Persistence Managers erhalten \/ Funktionalität ", 
"snippet" : "Sie können die TXT-Datei in einen externen Editor wie beispielsweise Notepad++ laden und bearbeiten. Sie können die persistenten Variablen der Datei in einer anderen Applikation verwenden. Sie können das Verhalten der persistenten Variablen konfigurieren, indem Sie Persistenzgruppen festlegen, diese...", 
"body" : "Sie können die TXT-Datei in einen externen Editor wie beispielsweise Notepad++ laden und bearbeiten. Sie können die persistenten Variablen der Datei in einer anderen Applikation verwenden. Sie können das Verhalten der persistenten Variablen konfigurieren, indem Sie Persistenzgruppen festlegen, diesen Variablen zuordnen und die Gruppen mit einem eigenen Speicher- und Einleseverhalten konfigurieren. " }, 
{ "title" : "Daten mit Rezepturen erhalten ", 
"url" : "_cds_preserve_data_with_recipes.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit Rezepturen erhalten ", 
"snippet" : "Im Rezepturverwalter werden Variablen persistent verwaltet. Der Rezepturverwalter benötigt auf der Steuerung keinen speziellen Speicher, um Werte und Daten zu erhalten....", 
"body" : "Im Rezepturverwalter werden Variablen persistent verwaltet. Der Rezepturverwalter benötigt auf der Steuerung keinen speziellen Speicher, um Werte und Daten zu erhalten. " }, 
{ "title" : "Deklaration ", 
"url" : "_cds_preserve_data_with_recipes.html#UUID-1dbefc8c-9b39-17e5-c1e5-8a6df87d0498_id_b66a4132d14f2b7fc0a864630fe45862_id_c56775d6efc6aceec0a86463532fbcfd", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit Rezepturen erhalten \/ Deklaration ", 
"snippet" : "Eine Rezepturdefinition besteht aus einen Satz an Variablen mit Werten und wird im Objekt Rezepturverwalter erstellt und bearbeitet und als Datei gesichert....", 
"body" : "Eine Rezepturdefinition besteht aus einen Satz an Variablen mit Werten und wird im Objekt Rezepturverwalter erstellt und bearbeitet und als Datei gesichert. " }, 
{ "title" : "Funktionalität ", 
"url" : "_cds_preserve_data_with_recipes.html#UUID-1dbefc8c-9b39-17e5-c1e5-8a6df87d0498_id_b66a4132d14f2b7fc0a864630fe45862_id_53bd4e7cd202a692c0a8646369dae647", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Daten mit Rezepturen erhalten \/ Funktionalität ", 
"snippet" : "Sie können eine Variable in mehreren Rezepturen mit jeweils unterschiedlichen Werten einbinden. Sie können im Onlinebetrieb aus der Steuerung die Istwerte der Variablen einlesen und als Rezepturwert (Sollwert) speichern. Sie können mit Hilfe der Bibliothek Recipe Management die Erstellung und Verarb...", 
"body" : "Sie können eine Variable in mehreren Rezepturen mit jeweils unterschiedlichen Werten einbinden. Sie können im Onlinebetrieb aus der Steuerung die Istwerte der Variablen einlesen und als Rezepturwert (Sollwert) speichern. Sie können mit Hilfe der Bibliothek Recipe Management die Erstellung und Verarbeitung einer Rezeptur programmatisch implementieren. Sie können eine Rezeptur als Rezepturdatei speichern und sichern. " }, 
{ "title" : "VAR PERSISTENT-Variablen deklarieren ", 
"url" : "_cds_setting_up_persistence.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ VAR PERSISTENT-Variablen deklarieren ", 
"snippet" : "Im Folgenden deklarieren Sie persistente Variablen in einer persistenten Variablenliste und in einer POU. Voraussetzung: Ein Projekt ist geöffnet und enthält eine Programm-POU. In den Optionen (Menübefehl Tools → Optionen ) haben Sie in der Kategorie Deklarationseditor die Option für die textuelle A...", 
"body" : "Im Folgenden deklarieren Sie persistente Variablen in einer persistenten Variablenliste und in einer POU. Voraussetzung: Ein Projekt ist geöffnet und enthält eine Programm-POU. In den Optionen (Menübefehl Tools → Optionen ) haben Sie in der Kategorie Deklarationseditor die Option für die textuelle Ansicht aktiviert. Fügen Sie dem Applikationsobjekt mit dem Menübefehl Projekt → Objekt hinzufügen das Objekt Persistente Variablen hinzu. CODESYS fügt die persistente Variablenliste PersistentVars unter dem Applikationsobjekt im Gerätebaum ein und der Editor öffnet sich. Geben Sie im Editor zwischen VAR_GLOBAL PERSISTENT RETAIN und END_VAR eine Variablendeklaration ein, zum Beispiel ivarpersist1 : INT; . Doppelklicken Sie auf die POU im Gerätebaum. Der Editor der POU öffnet sich. Geben Sie im Deklarationsteil die folgende Deklaration ein: VAR PERSISTENT RETAIN ivarpersist2 : INT; END_VAR Wählen Sie den Menübefehl Erstellen → Übersetzen . Das Meldungsfenster öffnet sich. Wenn CODESYS die Applikation fehlerfrei übersetzt hat, schließen Sie das Meldungsfenster und fahren Sie mit dem nächsten Schritt fort. Ansonsten beheben Sie den\/die Fehler und wählen erneut den Menübefehl Erstellen → Übersetzen . Setzen Sie den Fokus in den Editor PersistentVars . Wählen Sie den Menübefehl Deklarationen → Alle Instanzpfade hinzufügen . CODESYS fügt die persistente Variable der persistenten Variablenliste PersistentVars der POU hinzu: \/\/ Instanzpfad der persistenten Variablen erzeugt POU.IVARPERSIST2 : INT " }, 
{ "title" : "Speichern der Werte einer persistenten Variablenliste in einer Rezeptur ", 
"url" : "_cds_saving_persistent_list.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Datenpersistenz \/ Speichern der Werte einer persistenten Variablenliste in einer Rezeptur ", 
"snippet" : "Voraussetzung: Ein Projekt ist geöffnet und unter einem Applikationsobjekt existiert eine persistente Variablenliste mit Deklarationen persistenter Variablen. Doppelklicken Sie auf die Steuerung im Gerätebaum und wählen Sie die Registerkarte Kommunikation . Selektieren Sie Ihr Gateway und klicken Si...", 
"body" : "Voraussetzung: Ein Projekt ist geöffnet und unter einem Applikationsobjekt existiert eine persistente Variablenliste mit Deklarationen persistenter Variablen. Doppelklicken Sie auf die Steuerung im Gerätebaum und wählen Sie die Registerkarte Kommunikation . Selektieren Sie Ihr Gateway und klicken Sie auf die Schaltfläche Netzwerk durchsuchen . Ihr Gerät ist in der Baumansicht des Gateways fett dargestellt. Selektieren Sie Ihr Gerät und klicken Sie auf die Schaltfläche Aktiven Pfad setzen . Selektieren Sie Ihr Applikationsobjekt im Gerätebaum und wählen Sie den Kontextmenü-Befehl Aktive Applikation setzen . Das Applikationsobjekt ist fett dargestellt. Wählen Sie den Menübefehl Online → Einloggen . Ihre Applikation ist auf der Steuerung eingeloggt und die Steuerung und das Applikationsobjekt im Gerätebaum sind grün hinterlegt. Doppelklicken Sie auf die persistente Variablenliste und wählen Sie den Befehl Deklarationen → Aktuelle Werte in Rezeptur speichern . CODESYS erzeugt unter dem Applikationsobjekt die Objekte Rezepturverwalter und PersistentVariables . Wählen Sie den Menübefehl Online → Ausloggen . Die Applikation ist aus der Steuerung ausgeloggt. " }, 
{ "title" : "Bausteine für implizite Prüfungen verwenden ", 
"url" : "_cds_using_pous_for_implicit_check.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Bausteine für implizite Prüfungen verwenden ", 
"snippet" : "CODESYS stellt spezielle POUs zur Verfügung, die implizite Überwachungsfunktionen implementieren. Diese Funktionen überprüfen während der Laufzeit die Grenzen von Arrays oder Unterbereichstypen, die Gültigkeit von Pointeradressen oder eine Division durch Null. Selektieren Sie das Objekt Applikation ...", 
"body" : "CODESYS stellt spezielle POUs zur Verfügung, die implizite Überwachungsfunktionen implementieren. Diese Funktionen überprüfen während der Laufzeit die Grenzen von Arrays oder Unterbereichstypen, die Gültigkeit von Pointeradressen oder eine Division durch Null. Selektieren Sie das Objekt Applikation im Gerätebaum. Wählen Sie den Befehl Projekt → Objekt hinzufügen → POU für implizite Prüfungen . Es erscheint der Dialog POU für implizite Prüfungen hinzufügen . Aktivieren Sie die gewünschten Funktionen. Klicken Sie auf die Schaltfläche Hinzufügen . Die ausgewählten POUs werden unterhalb der Applikation im Gerätebaum eingefügt. Öffnen Sie die POUs im Editor. Passen Sie den Implementierungsvorschlag Ihren Anforderungen an. Um die Funktionalität der Überwachungsfunktionen zu erhalten, dürfen Sie den Deklarationsteil nicht verändern. Als einzige Ausnahme dürfen Sie lokale Variablen hinzufügen. " }, 
{ "title" : "Objektorientiert programmieren ", 
"url" : "_cds_f_object_oriented_programming.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Objektorientiert programmieren ", 
"snippet" : "CODESYS unterstützt die objektorientierte Programmierung mit Funktionsbausteinen und stellt dafür folgende Funktionalitäten und Objekte zur Verfügung: Methoden Schnittstellen Eigenschaften Vererbung Methodenaufruf, virtueller Funktionsaufruf Definition von Funktionsbausteinen als Erweiterungen ander...", 
"body" : "CODESYS unterstützt die objektorientierte Programmierung mit Funktionsbausteinen und stellt dafür folgende Funktionalitäten und Objekte zur Verfügung: Methoden Schnittstellen Eigenschaften Vererbung Methodenaufruf, virtueller Funktionsaufruf Definition von Funktionsbausteinen als Erweiterungen anderer Funktionsbausteine " }, 
{ "title" : "Erweitern eines Funktionsbausteins ", 
"url" : "_cds_extending_function_block.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Objektorientiert programmieren \/ Erweitern eines Funktionsbausteins ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Allgemein ", 
"url" : "_cds_extending_function_block.html#UUID-9227be4c-31f9-73e0-19cf-95ca7326aa82_section-idm4538086976649632656586029339", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Objektorientiert programmieren \/ Erweitern eines Funktionsbausteins \/ Allgemein ", 
"snippet" : "Die Erweiterung eines Funktionsbausteins basiert auf dem Konzept der Vererbung in der objektorientierten Programmierung. Ein abgeleiteter Funktionsbaustein „erweitert“ zu diesem Zweck einen Basis-Funktionsbaustein und erhält dadurch die Eigenschaften des Basis-Funktionsbausteins zusätzlich zu seinen...", 
"body" : "Die Erweiterung eines Funktionsbausteins basiert auf dem Konzept der Vererbung in der objektorientierten Programmierung. Ein abgeleiteter Funktionsbaustein „erweitert“ zu diesem Zweck einen Basis-Funktionsbaustein und erhält dadurch die Eigenschaften des Basis-Funktionsbausteins zusätzlich zu seinen eigenen Eigenschaften. Die Erweiterung eines Funktionsbausteins bedeutet: Der abgeleitete Funktionsbaustein enthält alle Daten und Methoden, die vom Basis-Funktionsbaustein definiert sind. Eine Instanz des Basis-Funktionsbausteins können Sie in jedem Kontext verwenden, in dem CODESYS einen Funktionsbaustein vom Typ des Basis-Funktionsbausteins erwartet. Der abgeleitete Funktionsbaustein darf die Methoden überschreiben, die Sie im Basis-Funktionsbaustein definiert haben. Das bedeutet: Der abgeleitete Funktionsbaustein kann eine Methode mit demselben Namen, denselben Eingängen und demselben Ausgang definieren, wie vom Basis-Funktionsbaustein definiert ist. Tipp: Für dieses Überschreiben der vom Basisbaustein geerbten Methoden, Aktionen, Eigenschaften, Transitionen erhalten Sie folgendermaßen Unterstützung. Wenn Sie eine Methode, Aktion etc. unterhalb des abgeleiteten Bausteins einfügen, erhalten Sie im Dialog Objekt hinzufügen eine Combobox mit einer Auswahl der im Basisbaustein verwendeten Methoden, Aktionen etc. und können diese übernehmen, um sie dann nur noch entsprechend anzupassen. Der abgeleitete Funktionsbaustein darf keine Funktionsbaustein-Variable mit denselben Namen enthalten, wie Sie der Basis-Funktionsbaustein verwendet. Dies meldet der Compiler als Fehler. Einzige Ausnahme: Wenn Sie eine Variable im Basis-Funktionsbaustein als VAR_TEMP deklariert haben, dann darf der abgeleitete Funktionsbaustein eine Variable mit demselben Namen definieren. In diesem Fall kann der abgeleitete Funktionsbaustein auf die Variable des Basis-Funktionsbausteins nicht mehr zugreifen. Sie können die Variablen und Methoden des Basis-Funktionsbausteins innerhalb des Gültigkeitsbereichs des abgeleiteten Funktionsbausteins durch die Verwendung des SUPER -Pointers direkt ansprechen. Mehrfache Vererbung ist nicht erlaubt. Ausnahme: Ein Funktionsbaustein kann mehrere Schnittstellen implementieren und eine Schnittestelle kann andere Schnittstellen erweitern. " }, 
{ "title" : "Erweitern eines Basis-Funktionsbausteins durch einen neuen Funktionsbaustein ", 
"url" : "_cds_extending_function_block.html#UUID-9227be4c-31f9-73e0-19cf-95ca7326aa82_id_bc846ea1a9450c0a8640e0123a187_id_a8817c8cf42e9706c0a8640e013e9a51", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Objektorientiert programmieren \/ Erweitern eines Funktionsbausteins \/ Erweitern eines Basis-Funktionsbausteins durch einen neuen Funktionsbaustein ", 
"snippet" : "Voraussetzung: Das aktuell geöffnete Projekt besitzt einen Basis-Funktionsbaustein, zum Beispiel POU_1(FB) , der durch einen neuen Funktionsbaustein erweitert werden soll. Selektieren Sie das Objekt Application im Gerätebaum und wählen Sie den Menübefehl Projekt → Objekt hinzufügen → POU . Der Dialo...", 
"body" : "Voraussetzung: Das aktuell geöffnete Projekt besitzt einen Basis-Funktionsbaustein, zum Beispiel POU_1(FB) , der durch einen neuen Funktionsbaustein erweitert werden soll. Selektieren Sie das Objekt Application im Gerätebaum und wählen Sie den Menübefehl Projekt → Objekt hinzufügen → POU . Der Dialog POU hinzufügen öffnet sich. Geben Sie einen Namen für den neuen Funktionsbaustein in das Eingabefeld Name ein, beispielsweise POU_Ex . Wählen Sie Funktionsbaustein . Wählen Sie Erweitert und klicken Sie auf die Schaltfläche . Wählen Sie in der Eingabehilfe aus der Kategorie Funktionsbausteine unter Application die POU(FB) aus, die als Basis-Funktionsbaustein dienen soll, zum Beispiel POU_1 und klicken Sie auf OK . Optional können Sie einen Zugriffsmodifizierer für den neuen Funktionsbaustein aus der Combobox auswählen. Wählen Sie aus der Combobox Implementierungsprache zum Beispiel Strukturierter Text(ST) aus. Klicken Sie auf Hinzufügen . CODESYS fügt den Funktionsbaustein POU_Ex in den Gerätebaum ein und der Editor öffnet sich. In der ersten Zeile steht: FUNCTION_BLOCK POU_Ex EXTENDS POU_1 Der Funktionsbaustein POU_Ex erweitert den Basis-Funktionsbaustein POU_1 . " }, 
{ "title" : "Erweitern eines Basis-Funktionsbausteins durch einen bestehenden Funktionsbaustein ", 
"url" : "_cds_extending_function_block.html#UUID-9227be4c-31f9-73e0-19cf-95ca7326aa82_id_bc846ea1a9450c0a8640e0123a187_id_630b9b97941a86bac0a864632a5ce350", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Objektorientiert programmieren \/ Erweitern eines Funktionsbausteins \/ Erweitern eines Basis-Funktionsbausteins durch einen bestehenden Funktionsbaustein ", 
"snippet" : "Voraussetzung: Das aktuell geöffnete Projekt besitzt einen Basis-Funktionsbaustein, beispielsweise POU_1(FB) , und einen weiteren Funktionsbaustein, beispielsweise POU_Ex(FB) . Der Funktionsbaustein POU_Ex(FB) soll auch die Eigenschaften des Basis-Funktionsbausteins erhalten. Das bedeutet: POU_Ex(FB...", 
"body" : "Voraussetzung: Das aktuell geöffnete Projekt besitzt einen Basis-Funktionsbaustein, beispielsweise POU_1(FB) , und einen weiteren Funktionsbaustein, beispielsweise POU_Ex(FB) . Der Funktionsbaustein POU_Ex(FB) soll auch die Eigenschaften des Basis-Funktionsbausteins erhalten. Das bedeutet: POU_Ex(FB) soll POU_1(FB) erweitern. Doppelklicken Sie im Gerätebaum auf den Funktionsbaustein POU_Ex(FB) . Der Editor des Funktionsbausteins öffnet sich. Erweitern Sie den bestehenden Eintrag der obersten Zeile FUNCTION_BLOCK POU_Ex mit EXTENDS POU_1 . Der Funktionsbaustein POU_Ex erweitert den Basis-Funktionsbaustein POU_1 . Für weitere Informationen siehe: Implementieren einer Schnittstelle und Erweitern einer Schnittstelle" }, 
{ "title" : "Eingabeunterstützung beim Erzeugen von erbenden Bausteinen ", 
"url" : "_cds_extending_function_block.html#UUID-1d94a1a9-161e-c24e-9497-750a39f396c9", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Objektorientiert programmieren \/ Erweitern eines Funktionsbausteins \/ Eingabeunterstützung beim Erzeugen von erbenden Bausteinen ", 
"snippet" : "Wenn Sie objektorientiert programmieren und die Vererbung (Schlüsselwort EXTENDS ) von Bausteinen nutzen, können Sie folgendermaßen Unterstützung erhalten: Wenn Sie unterhalb eines von einem Basisbaustein abgeleiteten Bausteins eine Aktion, Eigenschaft, Methode oder Transition einfügen, öffnet sich ...", 
"body" : "Wenn Sie objektorientiert programmieren und die Vererbung (Schlüsselwort EXTENDS ) von Bausteinen nutzen, können Sie folgendermaßen Unterstützung erhalten: Wenn Sie unterhalb eines von einem Basisbaustein abgeleiteten Bausteins eine Aktion, Eigenschaft, Methode oder Transition einfügen, öffnet sich der Dialog … hinzufügen . Dort ist das Eingabefeld für den Namen erweitert zu einer Combobox. Die Auswahlliste der Combobox enthält eine gültige Auswahl aus den im Basisbaustein vorhandenen Aktionen, Eigenschaften, Methoden oder Transitionen. Nun können Sie beispielsweise eine Methode des Basisbausteins auf einfache Weise zunächst übernehmen, um sie dann entsprechend für die abgeleitete Funktion des Bausteins anzupassen. Methoden und Eigenschaften mit dem Zugriffsmodifizierer PRIVATE erscheinen in dieser Auswahl nicht, da sie auch nicht vererbt werden. Methoden und Eigenschaften mit dem Zugriffsmodifizierer PUBLIC erhalten beim Übernehmen in den abgeleiteten Baustein automatisch ein leeres Zugriffsmodifiziererfeld, was funktional das Gleiche bedeutet. Für weitere Informationen siehe: Eigenschaft, Methode, Transition, Aktion, Beispiel " }, 
{ "title" : "Implementieren einer Schnittstelle ", 
"url" : "_cds_implementing_interface.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Objektorientiert programmieren \/ Implementieren einer Schnittstelle ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Implementieren einer Schnittstelle ", 
"url" : "_cds_implementing_interface.html#UUID-4357ee1b-de95-b6cf-0c34-d4c867466ac7_section-idm4538086982283232656593653643", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Objektorientiert programmieren \/ Implementieren einer Schnittstelle \/ Implementieren einer Schnittstelle ", 
"snippet" : "Die Implementierung von Schnittstellen basiert auf dem Konzept der objektorientierten Programmierung. Über gemeinsame Schnittstellen können Sie verschiedene aber gleichartige Funktionsbausteine auch gleichartig verwenden. Ein Funktionsbaustein, der eine Schnittstelle implementiert, muss alle Methode...", 
"body" : "Die Implementierung von Schnittstellen basiert auf dem Konzept der objektorientierten Programmierung. Über gemeinsame Schnittstellen können Sie verschiedene aber gleichartige Funktionsbausteine auch gleichartig verwenden. Ein Funktionsbaustein, der eine Schnittstelle implementiert, muss alle Methoden und Eigenschaften enthalten, die in dieser Schnittstelle definiert sind (Schnittstellen-Methoden und Schnittstellen-Eigenschaften). Das bedeutet: Name, Eingänge und Ausgang der jeweiligen Methode oder Eigenschaft müssen exakt gleich sein. Wenn Sie einen neuen Funktionsbausteins anlegen, der eine Schnittstelle implementiert, fügt CODESYS automatisch alle Methoden und Eigenschaften dieser Schnittstelle unterhalb des neuen Funktionsbausteins im Baum ein. Wenn Sie danach weitere Methoden der Schnittstelle hinzufügen, fügt CODESYS diese Methoden nicht automatisch auch in den betreffenden Funktionsbausteinen hinzu. Für die Aktualisierung müssen Sie explizit den Befehl Schnittstellen implementieren auswählen. Bei abgeleiteten Funktionsbausteinen müssen Sie darauf achten, dass Methoden oder Eigenschaften, die durch „Vererbung“ einer Schnittstelle übernommen wurden, die gewünschte Implementierung erhalten oder gelöscht werden, falls die in der Basis vorliegende Implementierung verwendet werden soll. Sie erhalten entsprechende Übersetzungsfehlermeldungen oder Warnungen, provoziert durch automatisch eingefügte Pragmaattribute. Sehen Sie bitte die Hilfeseite zum Befehl Schnittstellen implementieren . Einer Variablen vom Typ einer Schnittstelle müssen Sie die Schnittstelle eines Funktionsbausteins zuweisen, bevor eine Methode über die Variable aufgerufen werden kann. Eine Variable vom Typ einer Schnittstelle ist immer eine Referenz der zugewiesenen Funktionsbausteininstanz. Eine Variable vom Typ einer Schnittstelle ist eine Referenz auf Instanzen von Funktionsbausteinen. Eine solche Variable kann auf jeden Funktionsbaustein verweisen, der die Schnittstelle implementiert. Wenn keine Zuweisung auf die Variable erfolgt ist, dann enthält die Variable im Onlinebetrieb den Wert 0 . Beispiele Die Schnittstelle I1 enthält die Methode GetName . METHOD GetName : STRING Die Funktionsbausteine A und B implementieren jeweils die Schnittstelle I1 : FUNCTION_BLOCK A IMPLEMENTS I1\nFUNCTION_BLOCK B IMPLEMENTS I1 Beide Funktionsbausteine müssen deswegen eine Methode mit dem Namen GetName und dem Rückgabetyp STRING enthalten. Ansonsten meldet der Compiler einen Fehler. Eine Funktion enthält die Deklaration einer Variablen vom Typ der Schnittstelle I1 . FUNCTION DeliverName : STRING\nVAR_INPUT\n l_i : I1;\nEND_VAR Funktionsbausteine, die die Schnittstelle I1 implementieren, können dieser Eingangsvariablen zugewiesen werden. Beispiele für Funktionsaufrufe: DeliverName(l_i := A_instance); \/\/ call with instance of type A\nDeliverName(l_i := B_instance); \/\/ call with instance of type B Aufruf der Schnittstellen-Methode: In diesem Falle hängt es vom tatsächlichen Typ von l_i ab, ob die Applikation A.GetName oder B.GetName aufruft. DeliverName := l_i.GetName(); " }, 
{ "title" : "Implementieren einer Schnittstelle in einen neuen Funktionsbaustein ", 
"url" : "_cds_implementing_interface.html#UUID-4357ee1b-de95-b6cf-0c34-d4c867466ac7_id_de36840f50d462dc0a8640e016628e4_id_c92d2957f9591e5dc0a8640e00619caf", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Objektorientiert programmieren \/ Implementieren einer Schnittstelle \/ Implementieren einer Schnittstelle in einen neuen Funktionsbaustein ", 
"snippet" : "Voraussetzung: Das aktuell geöffnete Projekt besitzt mindestens ein Schnittstellen-Objekt. Selektieren Sie Application im Gerätebaum und wählen Sie den Menübefehl Projekt → Objekt hinzufügen → POU . Der Dialog POU hinzufügen öffnet sich. Geben Sie einen Namen für den neuen Funktionsbaustein in das E...", 
"body" : "Voraussetzung: Das aktuell geöffnete Projekt besitzt mindestens ein Schnittstellen-Objekt. Selektieren Sie Application im Gerätebaum und wählen Sie den Menübefehl Projekt → Objekt hinzufügen → POU . Der Dialog POU hinzufügen öffnet sich. Geben Sie einen Namen für den neuen Funktionsbaustein in das Eingabefeld Name ein, zum Beispiel POU_Im . Wählen Sie Funktionsbaustein . Wählen Sie Implementiert und klicken Sie auf die Schaltfläche . Wählen Sie in der Eingabehilfe aus der Kategorie Schnittstellen die Schnittstelle zum Beispiel ITF1 und klicken Sie auf OK . Um eine weitere Schnittstellen einzufügen, klicken Sie erneut auf und wählen Sie eine weitere Schnittstelle aus. Optional können Sie einen Zugriffsmodifizierer für den neuen Funktionsbaustein aus der Auswahlliste auswählen. Wählen Sie aus der Auswahlliste Implementierungsprache zum Beispiel Strukturierter Text(ST) aus. Klicken Sie auf Hinzufügen . CODESYS fügt den Funktionsbaustein POU_Ex in den Gerätebaum ein und der Editor öffnet sich. In der ersten Zeile steht: FUNCTION_BLOCK POU_Im IMPLEMENTS ITF1 Die Schnittstelle und ihre Methoden und Eigenschaften sind jetzt im Gerätebaum unter dem Funktionsbaustein eingefügt und Sie können nun Programmcode im Implementierungsteil der Schnittstelle und ihrer Methoden eingeben. " }, 
{ "title" : "Implementieren einer Schnittstelle in einen bestehenden Funktionsbaustein ", 
"url" : "_cds_implementing_interface.html#UUID-4357ee1b-de95-b6cf-0c34-d4c867466ac7_id_de36840f50d462dc0a8640e016628e4_id_dce21526b91b0bfbc0a8640e001af42d", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Objektorientiert programmieren \/ Implementieren einer Schnittstelle \/ Implementieren einer Schnittstelle in einen bestehenden Funktionsbaustein ", 
"snippet" : "Voraussetzung: Das aktuell geöffnete Projekt besitzt einen Funktionsbaustein, zum Beispiel POU_Im und mindestens ein Schnittstellen-Objekt, zum Beispiel ITF1 . Doppelklicken Sie im Gerätebaum auf die POU POU_Ex(FB) . Der Editor der POU öffnet sich. Erweitern Sie den bestehenden Eintrag der obersten ...", 
"body" : "Voraussetzung: Das aktuell geöffnete Projekt besitzt einen Funktionsbaustein, zum Beispiel POU_Im und mindestens ein Schnittstellen-Objekt, zum Beispiel ITF1 . Doppelklicken Sie im Gerätebaum auf die POU POU_Ex(FB) . Der Editor der POU öffnet sich. Erweitern Sie den bestehenden Eintrag der obersten Zeile FUNCTION_BLOCK POU_Im mit IMPLEMENTS ITF1 . Der Funktionsbaustein POU_Im implementiert die Schnittstelle ITF1 . " }, 
{ "title" : "Erweitern einer Schnittstelle ", 
"url" : "_cds_extending_interface.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Objektorientiert programmieren \/ Erweitern einer Schnittstelle ", 
"snippet" : "Sie können Schnittstellen ebenso wie Funktionsbausteine erweitern. Die Schnittstelle erhält dann auch die Schnittstellen-Methoden und Schnittstellen-Eigenschaften der Basis-Schnittstelle, zusätzlich zu ihren eigenen. Erzeugen einer Schnittstelle, die eine andere Schnittstelle erweitert. Selektieren ...", 
"body" : "Sie können Schnittstellen ebenso wie Funktionsbausteine erweitern. Die Schnittstelle erhält dann auch die Schnittstellen-Methoden und Schnittstellen-Eigenschaften der Basis-Schnittstelle, zusätzlich zu ihren eigenen. Erzeugen einer Schnittstelle, die eine andere Schnittstelle erweitert. Selektieren Sie das Objekt Application im Gerätebaum. Wählen Sie den Befehl Projekt → Objekt hinzufügen → Schnittstelle . Der Dialog Schnittstelle hinzufügen öffnet sich. Geben Sie eine Namen für die neue Schnittstelle ein. Aktivieren Sie die Option Erweitert und klicken Sie auf die Schaltfläche . Die Eingabehilfe öffnet sich. Wählen Sie aus der Kategorie Schnittstellen die Schnittstelle aus, die durch die neue Schnittstelle erweitert werden soll. " }, 
{ "title" : "Methodenaufruf ", 
"url" : "_cds_method_call.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Objektorientiert programmieren \/ Methodenaufruf ", 
"snippet" : "Um einen Methodenaufruf zu implementieren, werden den Schnittstellenvariablen die tatsächlichen Parameter (Argumente) übergeben. Dabei kann alternativ auf die Parameternamen verzichtet werden. Je nach deklariertem Zugriffsmodifizierer kann eine Methode nur innerhalb des eigenen Namensraums ( INTERNA...", 
"body" : "Um einen Methodenaufruf zu implementieren, werden den Schnittstellenvariablen die tatsächlichen Parameter (Argumente) übergeben. Dabei kann alternativ auf die Parameternamen verzichtet werden. Je nach deklariertem Zugriffsmodifizierer kann eine Methode nur innerhalb des eigenen Namensraums ( INTERNAL ) , nur innerhalb des eigenen Programmierbausteins und seinen Ableitungen ( PROTECTED ) oder nur innerhalb des eigenen Programmierbausteins ( PRIVATE ) aufgerufen werden. Bei PUBLIC kann die Methode überall aufgerufen werden. Innerhalb der Implementierung kann eine Methode sich selbst rekursiv aufrufen: entweder direkt mit Hilfe des THIS -Pointers, oder mit Hilfe einer lokalen Variablen für den zugeordneten Funktionsbaustein. " }, 
{ "title" : "Methodenaufruf als virtueller Funktionsaufruf ", 
"url" : "_cds_method_call.html#UUID-1140c736-2d89-bf68-7fec-9630a34558d8_id_d5035cf9d32eddc0a8640e0188f0bb_id_933ec828942a17e2c0a86463080c36ba", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Objektorientiert programmieren \/ Methodenaufruf \/ Methodenaufruf als virtueller Funktionsaufruf ", 
"snippet" : "Durch Vererbung kann es zu virtuellen Funktionsaufrufen kommen. Virtuelle Funktionsaufrufe ermöglichen, dass derselbe Aufruf in einem Programm-Quellcode während der Laufzeit verschiedene Methoden aufruft. In folgenden Fällen wird der Methodenaufruf dynamisch gebunden: Sie rufen eine Methode über ein...", 
"body" : "Durch Vererbung kann es zu virtuellen Funktionsaufrufen kommen. Virtuelle Funktionsaufrufe ermöglichen, dass derselbe Aufruf in einem Programm-Quellcode während der Laufzeit verschiedene Methoden aufruft. In folgenden Fällen wird der Methodenaufruf dynamisch gebunden: Sie rufen eine Methode über einen Pointer auf einen Funktionsbaustein auf. Beispiel: pfub^.method Der Pointer kann in dieser Situation auf Instanzen vom Typ des Funktionsbausteins und auf Instanzen von allen abgeleiteten Funktionsbausteinen zeigen. Sie rufen die Methode einer Schnittstellen-Variablen auf. Beispiel: interface1.method Die Schnittstelle kann auf alle Instanzen von Funktionsbausteinen verweisen, die diese Schnittstelle implementieren. Eine Methode ruft eine andere Methode desselben Funktionsbausteins auf. Die Methode kann in dem Fall auch die Methode eines abgeleiteten Funktionsbausteins mit gleichem Namen aufrufen. Der Aufruf einer Methode erfolgt über eine Referenz auf einen Funktionsbaustein. Die Referenz kann in dieser Situation auf Instanzen vom Typ des Funktionsbausteins und auf Instanzen von allen abgeleiteten Funktionsbausteinen zeigen. Sie weisen VAR_IN_OUT -Variablen eines Basis-Funktionsbaustein-Typen einer Instanz eines abgeleiteten FB-Typen zu. Die Variable kann in dieser Situation auf Instanzen vom Typ des Funktionsbausteins und auf Instanzen von allen abgeleiteten Funktionsbausteinen zeigen. " }, 
{ "title" : "Beispiel ", 
"url" : "_cds_method_call.html#UUID-1140c736-2d89-bf68-7fec-9630a34558d8_id_d5035cf9d32eddc0a8640e0188f0bb_id_e72629c73f4956dbc0a864635fb6e156", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Objektorientiert programmieren \/ Methodenaufruf \/ Beispiel ", 
"snippet" : "Methoden überladen Die Funktionsbausteine fub1 und fub2 erweitern den Funktionsbaustein fubbase und implementieren die Schnittstelle interface1 . Es gibt die Methoden method1 und method2 . PROGRAM PLC_PRG VAR_INPUT b : BOOL; END_VAR VAR pInst : POINTER TO fubbase; instBase : fubbase; inst1 : fub1; i...", 
"body" : "Methoden überladen Die Funktionsbausteine fub1 und fub2 erweitern den Funktionsbaustein fubbase und implementieren die Schnittstelle interface1 . Es gibt die Methoden method1 und method2 . PROGRAM PLC_PRG\nVAR_INPUT\n b : BOOL;\nEND_VAR\n\nVAR pInst : POINTER TO fubbase;\n instBase : fubbase;\n inst1 : fub1;\n inst2 : fub2;\n instRef : REFERENCE to fubbase;\nEND_VAR\n\nIF b THEN\n instRef REF= inst1; (* reference to fub1 *)\n pInst := ADR(instBase);\nELSE\n instRef REF= inst2; (* reference to fub2 *)\n pInst := ADR(inst1);\nEND_IF\npInst^.method1(); (* If b is TRUE, fubbase.method1 will be called, otherwise fub1.method1 is called *)\ninstRef.method1(); (* If b ist TRUE, fub1.method1 will be called, otherwise fub2.method1 is called*) Unter der Annahme, dass fubbase des oberen Beispiels zwei Methoden method1 und method2 enthält, überschreibt fub1 method2 , aber nicht method1 . Der Aufruf von method1 erfolgt folgendermaßen: pInst^.method1(); Wenn b TRUE ist, ruft CODESYS fubbase.method1 auf, ansonsten fub1.method1 . " }, 
{ "title" : "Zusätzliche Ausgänge ", 
"url" : "_cds_method_call.html#UUID-1140c736-2d89-bf68-7fec-9630a34558d8_id_d5035cf9d32eddc0a8640e0188f0bb_id_72802afb093e52c0c0a8640e0111714b", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Objektorientiert programmieren \/ Methodenaufruf \/ Zusätzliche Ausgänge ", 
"snippet" : "Gemäß der Norm IEC 61131-3 können Methoden so wie normale Funktionen zusätzliche Ausgänge deklariert haben. Beim Methodenaufruf weisen Sie den zusätzlichen Ausgängen Variablen zu. Genaue Informationen hierzu finden Sie beim Thema „Funktion“. Syntax beim Aufruf <function block name>.<method name>(<fi...", 
"body" : "Gemäß der Norm IEC 61131-3 können Methoden so wie normale Funktionen zusätzliche Ausgänge deklariert haben. Beim Methodenaufruf weisen Sie den zusätzlichen Ausgängen Variablen zu. Genaue Informationen hierzu finden Sie beim Thema „Funktion“. Syntax beim Aufruf <function block name>.<method name>(<first input name> := <value> (, <further input assignments>)+ , <first output name> => <first output variable name> (,<further output assignments>)+ ); Beispiel Deklaration METHOD PUBLIC DoIt : BOOL\nVAR_INPUT\n iInput_1 : DWORD;\n iInput_2 : DWORD;\nEND_VAR\nVAR_OUTPUT\n iOutput_1 : INT;\n sOutput_2 : STRING;\nENDVAR Autruf fbInstance.DoIt(iInput_1 := 1, iInput_2 := 2, iOutput_1 => iLocal_1, sOUtput_2 => sLocal_2); Bei Aufruf der Methode werden die Werte der Methodenausgänge auf die lokal deklarierte Ausgabevariablen geschrieben. " }, 
{ "title" : "Aufruf einer Methode, auch wenn die Applikation im STOP-Status ist ", 
"url" : "_cds_method_call.html#UUID-1140c736-2d89-bf68-7fec-9630a34558d8_id_d5035cf9d32eddc0a8640e0188f0bb_id_7f4f002a7a7c22c7c0a864630de7909a", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Objektorientiert programmieren \/ Methodenaufruf \/ Aufruf einer Methode, auch wenn die Applikation im STOP-Status ist ", 
"snippet" : "In der Gerätebeschreibung kann definiert sein, dass eine bestimmte Funktionsbaustein-Instanz (eines Bibliotheksbausteins) eine bestimmte Methode immer taskzyklisch aufruft. Wenn die Methode die Eingabeparameter des folgenden Beispiels enthält, arbeitet CODESYS die Methode auch dann ab, wenn die akti...", 
"body" : "In der Gerätebeschreibung kann definiert sein, dass eine bestimmte Funktionsbaustein-Instanz (eines Bibliotheksbausteins) eine bestimmte Methode immer taskzyklisch aufruft. Wenn die Methode die Eingabeparameter des folgenden Beispiels enthält, arbeitet CODESYS die Methode auch dann ab, wenn die aktive Applikation gerade im STOP-Status ist: Beispiel VAR_INPUT\n pTaskInfo : POINTER TO DWORD;\n pApplicationInfo: POINTER TO _IMPLICIT_APPLICATION_INFO;\nEND_VAR\n\n(*Now the status of the application can be queried via pApplicationInfo and the instructions can be implemented: *)\n\nIF pApplicationInfo^.udState = 1 THEN <instructions> END_IF; " }, 
{ "title" : "Methode rekursiv aufrufen ", 
"url" : "_cds_method_call.html#UUID-1140c736-2d89-bf68-7fec-9630a34558d8_id_d5035cf9d32eddc0a8640e0188f0bb_id_18143ba7942a17e2c0a8646355ab3f2a", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation programmieren \/ Objektorientiert programmieren \/ Methodenaufruf \/ Methode rekursiv aufrufen ", 
"snippet" : "Verwenden Sie Rekursionen vorwiegend zur Bearbeitung von rekursiven Datentypen wie beispielsweise verketteten Listen. Allgemein ist es ratsam bei der Verwendung von Rekursion vorsichtig zu sein. Bei einer unerwartet tiefen Rekursion kann es zu einem Stacküberlauf und damit zu einem Maschinenstillsta...", 
"body" : "Verwenden Sie Rekursionen vorwiegend zur Bearbeitung von rekursiven Datentypen wie beispielsweise verketteten Listen. Allgemein ist es ratsam bei der Verwendung von Rekursion vorsichtig zu sein. Bei einer unerwartet tiefen Rekursion kann es zu einem Stacküberlauf und damit zu einem Maschinenstillstand kommen. Innerhalb ihrer Implementierung kann eine Methode sich selbst aufrufen: direkt mit Hilfe des THIS -Pointers indirekt mit Hilfe einer lokalen Funktionsbaustein-Instanz des Basisfunktionsbausteins Üblicherweise wird bei einem solchen rekursiven Aufruf eine Compilerwarnung ausgegeben. Wenn die Methode mit dem Pragma {attribute 'estimated-stack-usage' := '<estimated stack size in bytes>'} versehen ist, wird die Compilerwarnung unterdrückt. Im Kapitel Attribut ‚estimated-stack-usage finden Sie ein Implementierungsbeispiel. " }, 
{ "title" : "Arbeiten mit Steuerungsnetzwerken ", 
"url" : "_cds_struct_dataexchange.html", 
"breadcrumbs" : "CODESYS Essentials \/ Arbeiten mit Steuerungsnetzwerken ", 
"snippet" : "CODESYS unterstützt die Kommunikation zwischen Steuerungsgeräten (SPS) und das Unterordnen einer Sicherheitssteuerung unter ein Steuerungsgerät durch folgende Funktionalitäten: Symbolkonfiguration : Für die Variablen in einer Applikation erzeugt CODESYS Symbole mit bestimmten Zugriffsrechten. Über d...", 
"body" : "CODESYS unterstützt die Kommunikation zwischen Steuerungsgeräten (SPS) und das Unterordnen einer Sicherheitssteuerung unter ein Steuerungsgerät durch folgende Funktionalitäten: Symbolkonfiguration : Für die Variablen in einer Applikation erzeugt CODESYS Symbole mit bestimmten Zugriffsrechten. Über diese Symbole können Sie von extern auf die Variablen zugreifen, beispielsweise von einem OPC-Server aus. Datenquellenverwalter : Verwaltet die Verbindungseinstellung und die Datenübertragung zu entfernten Geräten (Datenquellen) Die übertragenen Daten werden in Datenquellenvariablen abgebildet, auf die dann in der Visualisierung oder der lokalen Applikation zugegriffen wird. Ein Beispiel dafür ist ein Controlpanel, das entfernte Geräte steuert und den Zustand der Geräte als HMI-Applikation visualisiert. Netzwerkvariablen : Netzwerkvariablen sind Variablen, deren Werte verschiedenen Steuerungsgeräten im Netzwerk zugänglich sind. Die Variablen müssen dazu in starren, identischen Listen sowohl im Sendergerät als auch im Empfängergerät definiert sein. Diese Listen sind Applikationen zugeordnet, können aber in verschiedenen Projekten liegen. Im Gerätebaum kann eine Sicherheitssteuerung unter die Steuerung eingefügt werden. Die Kommunikationsverbindungen der Sicherheitssteuerung zu den Feldgeräten, Steuerungsnetzwerken und zum Programmiersystem werden dann über diese Steuerung geroutet. Für weitere Informationen siehe: Untergeordnete SicherheitssteuerungDas Objekt DataServer ist veraltet. Die Datenanbindung mit CODESYS DataServer wurde bereits mit SP10 abgelöst von einer Datenanbindung mit Datenquellen. Mit CODESYS 3.5 SP17 wurde die Funktionalität nun vollständig entfernt. Falls Sie ein bestehendes Projekt mit einem DataServer -Objekt anpassen wollen, können Sie Folgendes tun: Öffnen Sie das bestehende Projekt mit CODESYS V3.5 SP16, selektieren Sie das Datenserver-Objekt und rufen Sie den Kontextmenübefehl Datenserver in Datenquellen-Manager umwandeln auf. Nach der Konvertierung der Datenanbindung in eine Datenquellen-Verbindung können Sie das Projekt mit einer aktuellen CODESYS -Version öffnen. Für weitere Informationen siehe: Adressstrukturen und Adressierung und Routing" }, 
{ "title" : "Netzwerk und Adressierung ", 
"url" : "_cds_f_networktopology_addressing.html", 
"breadcrumbs" : "CODESYS Essentials \/ Arbeiten mit Steuerungsnetzwerken \/ Netzwerk und Adressierung ", 
"snippet" : "Bauen Sie ein Steuerungsnetzwerk hierarchisch auf, damit weitgehende Selbstkonfiguration möglich ist. In CODESYS wird die Netzwerk-Topologie auf eindeutige Adressen abgebildet und der Routing-Algorithmus wird durch strukturierte Adressen einfach gehalten. Es gibt direkte und relative Adressierung un...", 
"body" : "Bauen Sie ein Steuerungsnetzwerk hierarchisch auf, damit weitgehende Selbstkonfiguration möglich ist. In CODESYS wird die Netzwerk-Topologie auf eindeutige Adressen abgebildet und der Routing-Algorithmus wird durch strukturierte Adressen einfach gehalten. Es gibt direkte und relative Adressierung und automatische Adressbestimmung während des Hochfahrens des Systems. " }, 
{ "title" : "Netzwerktopologie ", 
"url" : "_cds_networktopology.html", 
"breadcrumbs" : "CODESYS Essentials \/ Arbeiten mit Steuerungsnetzwerken \/ Netzwerk und Adressierung \/ Netzwerktopologie ", 
"snippet" : "Informationen und Empfehlungen zur Topologie eines Steuerungsnetzwerks Empfohlen wird, ein Netzwerksystem so einzurichten, dass Folgendes möglich wird: Weitreichende Selbstkonfiguration (Adresszuweisung) Transparente Unterstützung jedes Kommunikationsmediums Beförderung von Datenpaketen zwischen ver...", 
"body" : "Informationen und Empfehlungen zur Topologie eines Steuerungsnetzwerks Empfohlen wird, ein Netzwerksystem so einzurichten, dass Folgendes möglich wird: Weitreichende Selbstkonfiguration (Adresszuweisung) Transparente Unterstützung jedes Kommunikationsmediums Beförderung von Datenpaketen zwischen verschiedenen Netzwerken Dabei sollte der Routing-Mechanismus so einfach sein, dass jeder Netzwerkknoten Datenpakete umleiten kann, auch wenn er geringe Speicherkapazität hat. Vermeiden Sie deshalb umfangreiche Routing-Tabellen, komplexe Berechnungen oder Anfragen während der Laufzeit. Bauen Sie das Steuerungsnetzwerk hierarchisch auf. Jeder Knoten darf einen Vaterknoten und eine beliebige Anzahl an Kindknoten besitzen. Ein Knoten ohne Vater ist ein „Top-Level“-Knoten. Zyklen sind nicht erlaubt, das heißt jedes Steuerungsnetzwerk hat die Struktur eines Baums. Vater-Kind-Beziehungen entstehen durch die Spezifikation bestimmter Netzwerkbereiche. Ein Netzwerkbereich kann beispielsweise ein lokales Ethernet oder eine serielle Punkt-zu-Punkt-Verbindung sein. Wir unterscheiden das Hauptnetzwerk (mainnet) von den Subnetzwerken (subnet). Jeder Knoten gehört höchstens einem Hauptnetzwerk an, zu welchem auch sein Vaterknoten gehört, sofern ein solcher existiert. Für jeden Knoten kann eine beliebige Anzahl an Sub-Netzen konfiguriert werden, für die der Knoten jeweils als Vater fungiert. Ein Netzwerkbereich darf nur einen einzigen Vaterknoten haben. Deshalb ist eine Konfiguration, in der ein Netzwerkbereich gleichzeitig als Subnetz von mehreren Knoten definiert wird, ungültig. " }, 
{ "title" : "Adressierung und Routing ", 
"url" : "_cds_addressing_routing.html", 
"breadcrumbs" : "CODESYS Essentials \/ Arbeiten mit Steuerungsnetzwerken \/ Netzwerk und Adressierung \/ Adressierung und Routing ", 
"snippet" : "Adressierung heißt: Die Topologie des Steurungsnetzwerks wird auf eindeutige Adressen abgebildet. Eine Knotenadresse ist hierarchisch zusammengesetzt: Für jede Netzwerkverbindung bestimmt der zugehörige Blocktreiber eine lokale Adresse, welche den Knoten innerhalb des lokalen Netzwerks eindeutig ide...", 
"body" : "Adressierung heißt: Die Topologie des Steurungsnetzwerks wird auf eindeutige Adressen abgebildet. Eine Knotenadresse ist hierarchisch zusammengesetzt: Für jede Netzwerkverbindung bestimmt der zugehörige Blocktreiber eine lokale Adresse, welche den Knoten innerhalb des lokalen Netzwerks eindeutig identifiziert. Die gesamte Knotenadresse wird folgendermaßen gebildet: Der lokalen Adresse wird der vom Vater vergebene Subnetz-Index des lokalen Netzwerks vorangestellt. Dem Subnetz-Index wiederum wird die Knotenadresse des Vaters vorangestellt. Dabei wird die Länge des Subnetz-Index (in Bit) durch das Gerät bestimmt. Die Länge der lokalen Adresse wird dagegen durch den Netzwerktyp festgelegt. Ein Knoten ohne Hauptnetzwerk ist ein Top-Level-Knoten mit Adresse 0. Ein Knoten mit Hauptnetzwerk, welches keinen Vater enthält, ist ebenfalls ein Top-Level-Knoten. Er erhält die lokale Adresse des Hauptnetzwerks. Sehen Sie hier ein Beispiel für ein Steuerungsnetzwerk: Im Beispiel sind die Adressen der Knoten in hexadezimaler Schreibweise dargestellt. Die ersten 4 Ziffern repräsentieren die Adresse des jeweiligen Vaters im Hauptnetz, beispielsweise 0x007A=122 für PLC1 . Das nächste Byte (in blauer Schrift) ist für den Subnetz-Index reserviert und auf diesen folgt die lokale Adresse, beispielsweise C=12 für Knoten-Id 12 . Die Strukturierung der Adressen ermöglicht einen schlanken Routing-Algorithmus. So sind beispielsweise Routing-Tabellen unnötig. Information wird nur lokal abgefragt: über die eigene Adresse und über die Adresse des Vaterknotens. Darauf basierend kann ein Knoten die Datenpakete korrekt bearbeiten: Falls die Zieladresse mit der Adresse des aktuellen Knoten übereinstimmt, so ist dieser als Empfänger bestimmt. Falls die Zieladresse mit der Adresse des aktuellen Knotens beginnt, so ist das Datenpaket entweder direkt für ein Kind oder für einen Nachkömmling des Knoten bestimmt und muss weitergeleitet werden. In allen anderen Fällen ist der Empfänger kein Nachkömmling des aktuellen Knotens und das Datenpaket muss an seinen eigenen Vater weitergeleitet werden. Relative Adressierung ist eine Besonderheit: Relative Adressen enthalten nicht die Knotennummer des Empfängers, sondern beschreiben direkt den Pfad vom Sender zum Empfänger. Das Prinzip ist ähnlich zum relativen Pfad im Dateisystem: Die Adresse besteht aus der Anzahl der Schritte, über die das Datenpaket nach oben transportiert werden muss. Dies sind die Schritte zum entsprechenden Vater, und aus dem anschließenden Pfad hinab zum Zielknoten. Der Vorteil der relativen Adressierung liegt darin, dass zwei Knoten desselben Teilbaums die Kommunikation fortsetzen können, wenn der gesamte Teilbaum an eine andere Stelle im Gesamtnetzwerk verschoben wird. Während die absolute Knotenadressierung aufgrund dieser Verschiebung geändert werden muss, ist die relative Adressierung noch immer gültig. Adressbestimmung Die Kenntnis der eigenen Adresse erfordert von einem Knoten entweder die Kenntnis über die Adresse des Vaterknotens oder über die Tatsache ein Top-Level-Knoten zu sein. Zu diesem Zweck versendet der Knoten während des Hochfahrens an alle Netzwerkteilnehmer eine Nachricht zur Adressbestimmung. Solange er keine Antwort auf diese Nachricht erhält, sieht sich der Knoten als Top-Level-Knoten, versucht jedoch weiterhin einen möglichen Vater zu entdecken. Ein Vaterknoten antwortet durch Bekanntgabe seiner Adresse. Damit wird der Knoten selbstständig seine Adresse vervollständigen und sie den Subnetzen bekannt geben. Eine Adressbestimmung kann während des Hochfahrens durchgeführt werden oder auf Anfrage des zur Programmierung benutzen PCs. " }, 
{ "title" : "Adressstrukturen ", 
"url" : "_cds_address_structures.html", 
"breadcrumbs" : "CODESYS Essentials \/ Arbeiten mit Steuerungsnetzwerken \/ Netzwerk und Adressierung \/ Adressstrukturen ", 
"snippet" : "Broadcast-Adressen Es gibt zwei Arten von Broadcast - global und lokal. Ein globaler Broadcast wird an alle Knoten eines Netzwerks gesandt. Für diesen Zweck ist die leere Knotenadresse mit Länge 0 reserviert. Lokale Broadcasts werden an alle Geräte eines Netzwerkbereichs geschickt. Zu diesem Zweck w...", 
"body" : "Broadcast-Adressen Es gibt zwei Arten von Broadcast - global und lokal. Ein globaler Broadcast wird an alle Knoten eines Netzwerks gesandt. Für diesen Zweck ist die leere Knotenadresse mit Länge 0 reserviert. Lokale Broadcasts werden an alle Geräte eines Netzwerkbereichs geschickt. Zu diesem Zweck werden alle Bits der Netzwerkadresse auf 1 gesetzt. Das ist sowohl in relativen wie auch in absoluten Adressen zulässig. Ein Blocktreiber muss beide Arten von Broadcast-Adressen bearbeiten können. Das bedeutet: Leere Netzwerkadressen wie auch die Netzwerkadressen, deren Bits sämtlich auf 1 gesetzt wurden, müssen interpretiert und an alle betroffenen Teilnehmer versandt werden. " }, 
{ "title" : "Netzwerkadressen ", 
"url" : "_cds_address_structures.html#UUID-1f5ea387-c992-0bd7-9dee-0f8dc5aae773_id_ea3da72c61131dc0a8640e000e39f6_id_da141d38484f787cc0a8640e00d982a5", 
"breadcrumbs" : "CODESYS Essentials \/ Arbeiten mit Steuerungsnetzwerken \/ Netzwerk und Adressierung \/ Adressstrukturen \/ Netzwerkadressen ", 
"snippet" : "Netzwerkadressen repräsentieren eine Abbildung von Adressen des Netzwerktyps (beispielsweise IP) auf logische Adressen innerhalb eines Steuerungsnetzwerks. Diese Abbildung wird vom entsprechenden Blocktreiber vorgenommen. Innerhalb eines Ethernet-Netzwerks mit „Class C“ IP-Adressen sind die ersten d...", 
"body" : "Netzwerkadressen repräsentieren eine Abbildung von Adressen des Netzwerktyps (beispielsweise IP) auf logische Adressen innerhalb eines Steuerungsnetzwerks. Diese Abbildung wird vom entsprechenden Blocktreiber vorgenommen. Innerhalb eines Ethernet-Netzwerks mit „Class C“ IP-Adressen sind die ersten drei Bytes der IP-Adresse für alle Netzwerkgeräte gleich. Folglich genügen die letzten 8 Bit der IP-Adresse als Netzwerkadresse, zumal sie eine eindeutige Abbildung zwischen den beiden Adressen am Blocktreiber erlauben. Ein Knoten hat für jede Netzwerkverbindung eine andere Netzwerkadresse. Unterschiedliche Netzwerkverbindungen können dieselbe Netzwerkadresse haben, da jede Adresse nur lokal eindeutig sein muss. Terminologie: Als Netzwerkadresse eines Knotens ohne Angabe der Netzwerkverbindung wird in der Regel die Netzwerkadresse im Hauptnetzwerk bezeichnet. Die Länge einer Netzwerkadresse wird in Bit angegeben und kann vom Blocktreiber je nach Bedarf gewählt werden. Innerhalb eines Netzwerkbereichs muss für alle Knoten dieselbe Länge verwendet werden. Eine Netzwerkadresse wird von einem Array von Bytes dargestellt gemäß der nachfolgenden Kodierung: Länge der Netzwerkadresse: n Bits Erforderliche Bytes: b = (n + 7) DIV 8 Die (n MOD 8) Bits von niederstem Rang des ersten Bytes und alle übrigen (n DIV 8) werden für die Netzwerkadresse benutzt. Beispiel für das Codieren einer Netzwerkadresse Länge: 11 Bit Adresse: 111 1000 1100 " }, 
{ "title" : "Knotenadressen ", 
"url" : "_cds_address_structures.html#UUID-1f5ea387-c992-0bd7-9dee-0f8dc5aae773_id_ea3da72c61131dc0a8640e000e39f6_id_b9feccb2484f787fc0a8640e00b13107", 
"breadcrumbs" : "CODESYS Essentials \/ Arbeiten mit Steuerungsnetzwerken \/ Netzwerk und Adressierung \/ Adressstrukturen \/ Knotenadressen ", 
"snippet" : "Die Knotenadresse gibt die absolute Adresse eines Knotens innerhalb des Steuerungsnetzwerkes an und ist daher eindeutig innerhalb des gesamten „Netzwerkbaums“. Die Adresse setzt sich aus bis zu 15 Adresskomponenten zusammen, von denen jede jeweils 2 Bytes belegt. Je niedriger ein Knoten in der Netzw...", 
"body" : "Die Knotenadresse gibt die absolute Adresse eines Knotens innerhalb des Steuerungsnetzwerkes an und ist daher eindeutig innerhalb des gesamten „Netzwerkbaums“. Die Adresse setzt sich aus bis zu 15 Adresskomponenten zusammen, von denen jede jeweils 2 Bytes belegt. Je niedriger ein Knoten in der Netzwerkhierarchie angesiedelt ist, desto länger ist seine Adresse. Die gesamte Knotenadresse besteht aus den Teiladressen aller vorangehenden Knoten und der Teiladresse des Knotens selbst. Jede Teiladresse besteht aus einer oder mehreren Adresskomponenten. Die Länge ist daher immer ein Vielfaches von 2 Bytes. Die Teiladresse eines Knotens besteht aus der Netzwerkadresse des Knotens in seinem Hauptnetzwerk und dem Subnetzindex des Hauptnetzwerkes beim Vater. Die für den Subindex erforderlichen Bits werden vom Router des Vaterknotens festgelegt. Zwischen dem Subnetzindex und der Netzwerkadresse können Füll-Bits eingefügt werden, um zu erreichen, dass die Länge der Teiladresse ein Vielfaches von 2 Bytes ist. Spezialfälle: Ein Knoten ohne Hauptnetzwerk: Das bedeutet, dass es weder einen Subnetz-Index noch eine Netzwerkadresse im Hauptnetzwerk gibt. In diesem Fall wird die Adresse auf 0x0000 gesetzt. Ein Knoten im Hauptnetzwerk ohne Vater: In diesem Fall wird ein Subnetz-Index der Länge 0 angenommen. Die Teiladresse entspricht der Netzwerkadresse, bei Bedarf erweitert um Füll-Bits. Beispiel für Knotenadressen Die Knotenadresse wird immer hexadezimal angegeben. Die einzelnen Adresskomponenten (jeweils von 2 Bytes) werden durch einen Doppelpunkt “:” getrennt. Da dies ein Array von Bytes darstellt und keinen 16-bit Wert, werden die Komponenten nicht im Intel-Format angezeigt. Für händisch eingegebene Adressen werden fehlende Stellen in einer Adresskomponente durch führende Nullen ergänzt: “ 274 ” = “ 0274 ”. Um die Lesbarkeit zu verbessern sollte die Ausgabe auch immer die führenden Nullen enthalten. Absolute und relative Adressen Die Kommunikation zwischen zwei Knoten kann auf relativen oder absoluten Adressen basieren. Absolute Adressen sind identisch mit Knotenadressen. Relative Adressen geben den Pfad vom Sender zum Empfänger an. Sie bestehen aus einem Adressen-Offset und dem absteigenden Pfad hin zum Empfänger. Der (negative) Adress-Offset beschreibt die Anzahl an Adresskomponenten, um die ein Datenpaket im Baum nach oben durchgereicht werden muss, bevor es vom gemeinsamen Vater wieder nach unten gereicht werden kann. Da Knoten Teiladressen benutzen können, die aus mehr als einer Komponente bestehen, ist die Anzahl der zu passierenden Vaterkomponenten immer gleich dem Adress-Offset. Das bedeutet, dass die Abgrenzung zwischen den Vaterknoten nicht länger eindeutig ist. Deshalb wird der gemeinsame Anfang der Adressen der Kommunikationspartner als Vateradresse verwendet wird. Jede Adresskomponente wird als Aufwärtsschritt gezählt, unabhängig vom aktuellen Vaterknoten. Jeder der durch diese Annahme entstehenden Fehler kann vom entsprechenden Vaterknoten entdeckt werden und muss von ihm entsprechend behandelt werden. Nach Erreichen des gemeinsamen Vaters wird wie gewohnt der relative Pfad, als Array von Adresskomponenten, nach unten verfolgt. Formal: Die Knotenadresse des Empfängers wird gebildet durch Entfernen der letzten Adressen-Offset-Komponenten aus der Knotenadresse des Senders und durch Anhängen des relativen Pfads an die verbleibende Adresse. Beispiel für die Bildung von Knotenadressen Im folgenden Beispiel ist jede Adresskomponente durch einen Buchstaben repräsentiert, ein Punkt trennt jeweils Knoten voneinander. Da ein Knoten mehrere Adresskomponenten tragen kann, gibt es im Beispiel solche, die mit mehrerer Buchstaben vertreten sind. Knoten A: a.bc.d.ef.g Knoten B: a.bc.i.j.kl.m Adresse des niedrigsten gemeinsamen Vaters: a.bc Relative Adresse von A nach B: -4\/i.j.kl.m Die Zahl 4 resultiert aus den 4 Komponenten d , e , f und g , die das Datenpaket nach oben durchgereicht werden muss. Um ein korrektes Arbeiten des Routings zu garantieren, muss die relative Adresse bei jedem Passieren eine Zwischenknotens angepasst werden. Es ist ausreichend, den Adress-Offset anzupassen. Dies wird immer vom Vaterknoten durchgeführt: Wenn ein Knoten ein Datenpaket von einem seiner Subnetze erhält, so wird der Adress-Offset um die Länge der Adresskomponenten dieses Subnetzes erhöht. Wenn der neue Adress-Offset < 0 ist, dann muss das Datenpaket weiter nach oben gereicht werden. Wenn der Adress-Offset >= 0 ist, dann muss das Datenpaket an den Kindknoten gereicht werden, dessen lokale Adresse vom Adress-Offset ausgehend dem relativen Pfad entspricht. Zunächst muss jedoch der Adress-Offset um die Länge der lokalen Adresse des Kindes erhöht werden, damit der Kindknoten die korrekte Adresse sieht. Eine spezielle Situation entsteht, wenn der oben erwähnte Fehler beim Bestimmen des gemeinsamen Vaters eintritt. In diesem Fall ist der Adress-Offset des wirklichen Vaterknotens negativ, aber dieser Wert ist größer als die Länge der Teiladressen des Subnetzes, von denen das Paket stammt. Damit in diesem Fall der nächste Knoten eine korrekte relative Adresse sieht, muss der betroffene Knoten Folgendes tun: Er muss den Fehler aufdecken, auf Basis der Adresse des Vorgängerknotens und der Längendifferenz die lokale Adresse des Kindknoten berechnen und den Adress-Offset entsprechend anpassen. Auch in diesem Fall bleiben die Adresskomponenten an sich unverändert, nur der Offset wird geändert. " }, 
{ "title" : "Netzwerkvariablen ", 
"url" : "_cds_f_networkvariables.html", 
"breadcrumbs" : "CODESYS Essentials \/ Arbeiten mit Steuerungsnetzwerken \/ Netzwerkvariablen ", 
"snippet" : "Netzwerkvariablen sind Variablen, deren Werte zwischen verschiedenen Steuerungsgeräten im Netzwerk ausgetauscht werden können. Die Variablen müssen dazu in starren, identischen Listen sowohl im Sendergerät als auch im Empfängergerät definiert sein, wobei nur 1 Applikation eines Geräts Netzwerkvariab...", 
"body" : "Netzwerkvariablen sind Variablen, deren Werte zwischen verschiedenen Steuerungsgeräten im Netzwerk ausgetauscht werden können. Die Variablen müssen dazu in starren, identischen Listen sowohl im Sendergerät als auch im Empfängergerät definiert sein, wobei nur 1 Applikation eines Geräts Netzwerkvariablen definieren darf. Die Listen können innerhalb eines Projekts oder in verschiedenen Projekten liegen. Die Netzwerkvariablenliste im Sender ist eine globale Variablenliste, in deren Objekteigenschaften bestimmte Protokoll- und Übertragungsparameter definiert sind. Durch Hinzufügen dieser Eigenschaften erzeugen Sie aus einer „normalen“ GVL eine „Netzwerkvariablenliste (Sender)“. Sie können aber auch direkt ein Objekt Netzwerkvariablenliste (Sender) im Gerätebaum einfügen, für das diese Parameter bereits gesetzt sind. Die Netzwerkvariablenliste im Empfänger ist vom Typ Netzwerkvariablenliste (Empfänger) . Beim Anlegen wählen Sie die zugehörige Netzwerkvariablenliste des Senders aus. Alternativ können Sie diese Variablenliste aus einer Exportdatei einlesen, die zuvor aus der Senderliste erzeugt wurde. Eine Exportdatei ist auf jeden Fall nötig, wenn die Senderliste in einem anderen Projekt definiert ist. Die Übertragung von Netzwerkvariablen erfolgt als Broadcasting immer nur in eine Richtung, vom Sender zum Empfänger. Es ist allerdings möglich, dass ein Gerät sowohl Sender- als auch Empfängerlisten enthält. Ab Version 3.5.7.0 der Bibliothek NetVarUdp wird kein Empfangskanal mehr belegt, wenn kein bestätigter Transfer gewählt wird. Dadurch ist auch Netzwerkvariablenaustausch zwischen 2 Steuerungen auf 1 Hardwaregerät möglich. Wenn die austauschenden Geräte als Sender und Empfänger dienen, müssen die Variablenlistenkennungen der Variablenlisten eindeutig sein, um fehlerhaftes Verhalten zu vermeiden! Die Variablenlistenkennungen sind im Dialog Eigenschaften eines Objekts GVL definiert. Datenaustausch über Netzwerkvariablen ist in folgenden Fällen nicht möglich: Wenn es nicht vom Gerät (Zielsystem) unterstützt wird Wenn eine Firewall die Kommunikation blockiert Wenn ein anderer Client oder eine andere Applikation den UDP-Port benutzt, der in den Eigenschaften der Netzwerkvariablenliste eingestellt ist Wenn mehr als 1 Applikation pro Sender- und Empfängergerät Netzwerkvariablenlisten verwenden Nur Arrays, deren Grenzen mit einem Literal oder einer Konstante definiert sind, werden zur Empfänger-Applikation übertragen! Konstante Ausdrücke sind für diesen Zweck nicht erlaubt! Beispiel: „ arrVar : ARRAY[0..g_iArraySize-1] OF INT ; “ wird nicht übertragen: „ arrVar : ARRAY[0..10] OF INT ; “ wird übertragen. Die maximal erlaubte Größe einer Netzwerkvariable ist 255 Bytes. Die mögliche Anzahl von Netzwerkvariablen ist unbegrenzt. Wenn die Größe der GVL die maximale Länge des Netzwerktelegramms übersteigt, werden die Daten auf mehrere Telegramme aufgeteilt. Abhängig von der Konfiguration kann dies zu Dateninkonsistenzen führen. Bei der Datenübertragung über UDP vom Sender zum Empfänger können in jedem Zyklus Daten bei folgenden Positionen bzw. Ereignissen verloren gehen: Sender (Netzwerktreiber, - Stack) Router Switch Netzwerkkollisionen Empfänger (Netzwerktreiber, - Stack) Das bedeutet, dass die Daten, die der Empfänger in einem Zyklus empfängt, gegebenenfalls nicht aktuell sind, sondern veraltet. Eine Kommunikation mit Hilfe von Netzwerkvariablen ist auch möglich, wenn die teilnehmenden Steuerungen mit Applikationen aus verschiedenen Versionen des Programmiersystems arbeiten (V2.3, V3 ). In diesem Fall können Sie jedoch für das Anlegen der genau übereinstimmenden Variablenlisten im Sender- und Empfängerprojekt nicht den Export\/Importmechanismus verwenden. Grund: Eine aus V2.3 erzeugbare Variablenexportdatei ( *.exp ) enthält nicht den erforderlichen Umfang an Informationen, der nötig ist, um in V3 eine empfangende NVL anzulegen. Es fehlt die entsprechende Konfiguration der Netzwerkparameter in Form einer GVL-Datei, die Sie zuvor aus dem Sender exportiert haben. Um diese zu erhalten, müssen Sie die V2.3-NVL zuerst in V3 nachbauen. Daraus können Sie eine Exportdatei erzeugen und auf ihrer Basis eine empfangende NVL in V3 anlegen. Eine Alternative zum Datenaustausch zwischen Steuerungen ist die Verwendung von Datenquellen. Im Unterschied zur Broadcasting-Methode beim Netzwerkvariablenaustausch werden dabei definierte Punkt-zu-Punkt-Verbindungen zwischen einer Applikation und einer entfernten Datenquelle angelegt. Für weitere Informationen siehe: Netzwerkvariablen" }, 
{ "title" : "Konfigurieren eines Netzwerkvariablen-Austauschs ", 
"url" : "_cds_configuring_network_variables_exchange.html", 
"breadcrumbs" : "CODESYS Essentials \/ Arbeiten mit Steuerungsnetzwerken \/ Netzwerkvariablen \/ Konfigurieren eines Netzwerkvariablen-Austauschs ", 
"snippet" : "Folgende Schritte sind nötig, um Netzwerkvariablen zwischen Sender-Gerät und Empfänger-Gerät austauschen zu können:...", 
"body" : "Folgende Schritte sind nötig, um Netzwerkvariablen zwischen Sender-Gerät und Empfänger-Gerät austauschen zu können: " }, 
{ "title" : "1. Anlegen einer Netzwerkvariablenliste im Sender-Gerät und Erzeugen einer Exportdatei ", 
"url" : "_cds_configuring_network_variables_exchange.html#UUID-4b2d41ce-8a83-dfc2-9447-e0ddcf072e25_id_e2da966febc27c7c0a8640e00b3ea15_id_31c0f718b4d8cb98c0a8640e01ec7ade", 
"breadcrumbs" : "CODESYS Essentials \/ Arbeiten mit Steuerungsnetzwerken \/ Netzwerkvariablen \/ Konfigurieren eines Netzwerkvariablen-Austauschs \/ 1. Anlegen einer Netzwerkvariablenliste im Sender-Gerät und Erzeugen einer Exportdatei ", 
"snippet" : "Voraussetzungen: Im Gerätebaum des als Sender eingesetzten Steuerungsgeräts (Sender-Gerät) ist eine Applikation eingefügt. Selektieren Sie die Applikation und fügen Sie ein Objekt Netzwerkvariablenliste (Sender) ein. Stellen Sie im Dialog Netzwerkvariablenliste (Sender) hinzufügen Folgendes ein: Net...", 
"body" : "Voraussetzungen: Im Gerätebaum des als Sender eingesetzten Steuerungsgeräts (Sender-Gerät) ist eine Applikation eingefügt. Selektieren Sie die Applikation und fügen Sie ein Objekt Netzwerkvariablenliste (Sender) ein. Stellen Sie im Dialog Netzwerkvariablenliste (Sender) hinzufügen Folgendes ein: Netzwerktyp: UDP , Beispiel: „ NVL_Sender „. Öffnen Sie mit Doppelklick auf das NVL-Objekt den zugehörigen Editor und tragen die Deklarationen der Netzwerkvariablen ein. Beispiel: VAR_GLOBAL iglobvar:INT; bglobvar:BOOL; strglobvar:STRING; END_VAR Selektieren Sie das NVL-Objekt im Baum und wählen Sie im Kontextmenü Eigenschaften . Öffnen Sie im Dialog Eigenschaften die Registerkarte Netzwerkvariablen . Sie zeigt folgende Einstellungen: Netzwerktyp UDP, Variablenlistenkennung 1, Variablen packen, Zyklische Übertragung alle 50 ms. Hinweis: Sie können auch eine bestehende GVL zur Netzwerkvariablenliste machen, indem Sie ihre Netzwerkvariablen-Eigenschaften entsprechend konfigurieren. Wechseln Sie im Dialog Eigenschaften des NVL_Sender zur Registerkarte Verknüpfung mit Datei . Definieren Sie einen Dateinamen <export>.gvl und einen Ablageort für die Exportdatei der GVL im Dateisystem. Aktivieren Sie die Option Export vor Übersetzen . Übersetzen Sie die Applikation mit dem Befehl Erstellen → Übersetzen . Die Exportdatei für die Netzwerkvariablenliste liegt nun im definierten Ordner. " }, 
{ "title" : "2. Anlegen einer zugehörige Netzwerkvariablenliste im Empfänger-Gerät ", 
"url" : "_cds_configuring_network_variables_exchange.html#UUID-4b2d41ce-8a83-dfc2-9447-e0ddcf072e25_id_e2da966febc27c7c0a8640e00b3ea15_id_47ffe3b7829f11e3b1f793b077791a22", 
"breadcrumbs" : "CODESYS Essentials \/ Arbeiten mit Steuerungsnetzwerken \/ Netzwerkvariablen \/ Konfigurieren eines Netzwerkvariablen-Austauschs \/ 2. Anlegen einer zugehörige Netzwerkvariablenliste im Empfänger-Gerät ", 
"snippet" : "Voraussetzungen: Zusätzlich zum Sender-Gerät gibt es ein Empfänger-Gerät im Gerätebaum. Unter dem Gerät ist eine Applikation mit einer Taskkonfiguration eingefügt. Unter dem Sender-Gerät ist eine NVL oder GVL als zu sendende Netzwerkvariablenliste angelegt. Selektieren Sie die Applikation des Empfän...", 
"body" : "Voraussetzungen: Zusätzlich zum Sender-Gerät gibt es ein Empfänger-Gerät im Gerätebaum. Unter dem Gerät ist eine Applikation mit einer Taskkonfiguration eingefügt. Unter dem Sender-Gerät ist eine NVL oder GVL als zu sendende Netzwerkvariablenliste angelegt. Selektieren Sie die Applikation des Empfänger-Geräts im Baum und wählen Sie Objekt hinzufügen → Netzwerkvariablenliste (Empfänger) . Der Dialog Netzwerkvariablenliste (Empfänger) hinzufügen erscheint. Wählen Sie im Dialog die vorher angelegte NVL des Sendergeräts aus und tragen einen Namen ein: Beispiel: „NVL_Receiver“. CODESYS füllt diese Empfängerliste automatisch mit den Variablendeklarationen der Senderliste. Hinweis: Alternativ können Sie im Dialog die Option Import aus Datei wählen und die zuvor aus der Sender-Liste erzeugte Exportdatei laden. " }, 
{ "title" : "3. Testen des Netzwerkvariablen-Austauschs ", 
"url" : "_cds_configuring_network_variables_exchange.html#UUID-4b2d41ce-8a83-dfc2-9447-e0ddcf072e25_id_e2da966febc27c7c0a8640e00b3ea15_id_2f77f1a6b4d8cb98c0a8640e01956f55", 
"breadcrumbs" : "CODESYS Essentials \/ Arbeiten mit Steuerungsnetzwerken \/ Netzwerkvariablen \/ Konfigurieren eines Netzwerkvariablen-Austauschs \/ 3. Testen des Netzwerkvariablen-Austauschs ", 
"snippet" : "Voraussetzungen: Es gibt eine Netzwerkvariablenliste (Sender) im Sender-Gerät und eine Netzwerkvariablenliste (Empfänger) mit identischen Variablendeklarationen im Empfänger-Gerät. Erstellen Sie unter der Applikation im Sender-Gerät ein Programm, das eine Netzwerkvariable hochzählt. Beispiel: iglobv...", 
"body" : "Voraussetzungen: Es gibt eine Netzwerkvariablenliste (Sender) im Sender-Gerät und eine Netzwerkvariablenliste (Empfänger) mit identischen Variablendeklarationen im Empfänger-Gerät. Erstellen Sie unter der Applikation im Sender-Gerät ein Programm, das eine Netzwerkvariable hochzählt. Beispiel: iglobvar:=iglobvar+1; Konfigurieren Sie die Task der Applikation so, dass sie dieses Programm aufruft. Erstellen Sie ein Programm unter der Applikation im Empfänger-Gerät, welches den Wert dieser Netzwerkvariablen auf eine lokale Variable schreibt. Beispiel: ilocalvar:=iglobvar; Konfigurieren Sie die Task der Applikation so, dass sie dieses Programm aufruft. Laden Sie beide Applikationen auf die Steuerungen und starten Sie diese. (Applikation aktiv setzen, Einloggen, Laden, Starten) Prüfen Sie in den Online-Ansichten des Editors beider Programme, ob die Werte von iglobvar im Empfänger mit denen im Sender übereinstimmen. " }, 
{ "title" : "Konfigurieren einer Netzwerkvariablen-Kommunikation zwischen V2.3- und V3-Steuerungen ", 
"url" : "_cds_configuring_network_variables_exchange.html#UUID-4b2d41ce-8a83-dfc2-9447-e0ddcf072e25_id_e2da966febc27c7c0a8640e00b3ea15_id_ccea919a24784530c0a8640e014650de", 
"breadcrumbs" : "CODESYS Essentials \/ Arbeiten mit Steuerungsnetzwerken \/ Netzwerkvariablen \/ Konfigurieren eines Netzwerkvariablen-Austauschs \/ Konfigurieren einer Netzwerkvariablen-Kommunikation zwischen V2.3- und V3-Steuerungen ", 
"snippet" : "Voraussetzungen: In einem V2.3-Projekt liegt eine Globale Variablenliste mit Netzwerkvariablen, die Sie in Ihrem V3 -Projekt lesen möchten. Im V3 -Projekt gibt es im Gerätebaum unter der Steuerung eine Applikation mit einem Programm, das die Variablen verwendet. Öffnen Sie den Dialog Eigenschaften d...", 
"body" : "Voraussetzungen: In einem V2.3-Projekt liegt eine Globale Variablenliste mit Netzwerkvariablen, die Sie in Ihrem V3 -Projekt lesen möchten. Im V3 -Projekt gibt es im Gerätebaum unter der Steuerung eine Applikation mit einem Programm, das die Variablen verwendet. Öffnen Sie den Dialog Eigenschaften der GVL im V2.3-Projekt (Sender). Fügen Sie im Projekt eine weitere Steuerung als Dummy ein, mit einer Applikation und einer Task. Darunter wird jetzt die V2.3-GVL nachgebaut: Fügen Sie unter der Dummy-Applikation ein Objekt Netzwerkvariablenliste (Sender) mit Namen „dummy23“ ein. Öffnen Sie über das Kontextmenü von dummy23 den Dialog Eigenschaften und wählen die Registerkarte Netzwerkeigenschaften . Tragen Sie dort die gleichen Netzwerkeigenschaften ein, wie sie die GVL im V2.3-Projekt hat. Füllen Sie dummy23 mit den gleichen Variablendeklarationen wie sie in der V2.3-GVL vorliegen. Definieren Sie in den Eigenschaften von dummy23 in der Registerkarte Mit Datei verknüpfen einen Ablageort für eine Exportdatei „dummy23.gvl“. Setzen Sie die Applikation der Dummy-Steuerung aktiv und wählen Sie den Befehl Übersetzen → Code erzeugen ( F11 ). Wenn die Applikation erfolgreich übersetzt wird, legt CODESYS automatisch die Exportdatei dummy23.gvl an. Setzen Sie die Applikation der realen Steuerung aktiv und wählen Sie im Kontextmenü Objekt hinzufügen . Wählen Sie Netzwerkvariablenliste (Empfänger) und vergeben Sie einen Namen, z.B. „NVL_from_23“. Aktivieren Sie die Option Aus Datei öffnen und wählen dann die vorher erzeugte dummy23.gvl aus. Prüfen Sie die neu angelegte NVL_from_23 . Sie muss die gleichen Variablendeklarationen enthalten wie die im V2.3-Projekt liegende Sender-GVL. Für weitere Informationen siehe: Netzwerkvariablen-Liste (Sender) und Netzwerkvariablen-Liste (Empfänger)" }, 
{ "title" : "Untergeordnete Sicherheitssteuerung ", 
"url" : "_cds_safety_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ Arbeiten mit Steuerungsnetzwerken \/ Untergeordnete Sicherheitssteuerung ", 
"snippet" : "Wenn unter der Standardsteuerung eine Sicherheitssteuerung hängt, laufen die Kommunikation mit dem Programmiersystem und der Datenaustausch über die Standardsteuerung. Die Ausführung von Befehlen, die die Standardsteuerung betreffen, können die Kommunikationsverbindungen der Sicherheitssteuerung unt...", 
"body" : "Wenn unter der Standardsteuerung eine Sicherheitssteuerung hängt, laufen die Kommunikation mit dem Programmiersystem und der Datenaustausch über die Standardsteuerung. Die Ausführung von Befehlen, die die Standardsteuerung betreffen, können die Kommunikationsverbindungen der Sicherheitssteuerung unterbrechen. Hierzu finden Sie bei den jeweiligen Befehlen einen entsprechenden Hinweis. Mögliche Unterbrechungen Temporäre Unterbrechung: Während der Ausführung des Befehls (zum Beispiel Download) werden die Verbindungen mit der Sicherheitssteuerung zuerst unterbrochen, stehen danach aber automatisch wieder zur Verfügung. Wenn die Unterbrechungszeit zu lang ist, kann es zu sicherheitsgerichteten Reaktionen in den Ausgangsgeräten und verbundenen Netzwerkvariablen-Empfänger-Sicherheitssteuerungen kommen. Es müssen dann in der Sicherheitssteuerung die entsprechenden Kommunikationsfehler quittiert werden (falls dies nicht automatisch passiert), um die sicherheitsgerichteten Reaktionen zu beenden. Dies betrifft die Verbindung zu ihren Feldgeräten und Netzwerkvariablen-Empfänger-Verbindungen zu anderen Sender-Sicherheitssteuerungen. Im Fall einer angeschlossenen Sicherheitssteuerung mit Netzwerkvariablen-Sendern müssen die Kommunikationsfehler in den anderen Sicherheitssteuerungen quittiert werden. Dauerhafte Unterbrechung: Die Ausführung des Befehls (zum Beispiel Löschen) führt zu einer Unterbrechung, die erst durch eine weitere Aktion (zum Beispiel Download) wieder beendet wird. Durch die Unterbrechung kann es zu sicherheitsgerichteten Reaktionen in den Ausgangsgeräten und verbundenen Netzwerkvariablen-Empfänger-Sicherheitssteuerungen kommen. Nach Beendigung der Unterbrechung müssen die entsprechenden Kommunikationsfehler in der Sicherheitssteuerung quittiert werden (falls dies nicht automatisch passiert), um die sicherheitsgerichteten Reaktionen zu beenden. Für weitere Informationen siehe: Arbeiten mit Steuerungsnetzwerken" }, 
{ "title" : "Applikation auf die SPS übertragen ", 
"url" : "_cds_struct_application_transfer_to_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf die SPS übertragen ", 
"snippet" : "Um Ihre Applikation auf die Steuerung zu übertragen, muss das Programm fehlerfrei übersetzt und die Verbindungseinstellungen für die Steuerung konfiguriert sein. Wenn die Kommunikation mit der Steuerung verschlüsselt, und\/oder auf bestimmte Benutzer eingeschränkt ist, benötigen Sie die entsprechende...", 
"body" : "Um Ihre Applikation auf die Steuerung zu übertragen, muss das Programm fehlerfrei übersetzt und die Verbindungseinstellungen für die Steuerung konfiguriert sein. Wenn die Kommunikation mit der Steuerung verschlüsselt, und\/oder auf bestimmte Benutzer eingeschränkt ist, benötigen Sie die entsprechenden Zertifikate und Rechte. Sehen Sie hierzu Gerätebenutzerverwaltung handhabenApplikation schützenDie grundlegende Security-Strategie für die Kommunikation mit dem Gerät können Sie in einem Dialog auf der Registerkarte Kommunikation des Geräteeditors verändern. Sehen Sie hierzu: Kommunikation verschlüsseln, Security-Einstellungen verändernWenn diese Voraussetzungen erfüllt sind, wird die Applikation beim Einloggen auf die Steuerung geladen. " }, 
{ "title" : "Verbindung zur SPS konfigurieren ", 
"url" : "_cds_configuring_connection_to_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf die SPS übertragen \/ Verbindung zur SPS konfigurieren ", 
"snippet" : "Die Verbindung zur Steuerung erfolgt über ein so genanntes Gateway. Dieses Gateway kann Ihr Entwicklungsrechner oder ein anderer mit der Steuerung verbundener Rechner im Netzwerk sein. Für die Konfiguration des Verbindungspfads steht Ihnen der Dialog Kommunikation zur Verfügung. Dieser Dialog öffnet...", 
"body" : "Die Verbindung zur Steuerung erfolgt über ein so genanntes Gateway. Dieses Gateway kann Ihr Entwicklungsrechner oder ein anderer mit der Steuerung verbundener Rechner im Netzwerk sein. Für die Konfiguration des Verbindungspfads steht Ihnen der Dialog Kommunikation zur Verfügung. Dieser Dialog öffnet sich automatisch, wenn Sie sich einloggen wollen, die Kommunkationseinstellungen jedoch noch nicht konfiguriert sind. Wenn die Kommunikation mit der Steuerung verschlüsselt und über eine Benutzerverwaltung abgesichert ist, benötigen Sie für das Einrichten der Verbindung zur Steuerung ein entsprechendes Zertifikat und Zugangsdaten. Sehen Sie in diesem Fall die entsprechende Anleitung auf der Hilfeseite „Kommunikation verschlüsseln, Security-Einstellungen ändern“. Voraussetzung: Das Projekt lässt sich fehlerfrei übersetzen. Im Gerätebaum ist eine programmierbare Steuerung (SPS) eingefügt. Die Verwendung einer Benutzerverwaltung ist für das Gerät obligatorisch, aber noch nicht aktiviert. Selektieren Sie die Steuerung im Gerätebaum und wählen Sie den Befehl Projekt → Objekt bearbeiten . Die Steuerung wird im Editor geöffnet. Wählen Sie die Registerkarte Kommunikation . Klicken Sie in der Kopfzeile auf die Schalfläche Netzwerk durchsuchen . Der Dialog Gerät auswählen öffnet sich. Im Fenster links werden alle verfügbaren Geräte im Netzwerk angezeigt. Selektieren Sie das gewünschte Gerät und klicken Sie auf OK . Sie erhalten eine Meldungsbox mit dem Hinweis, dass für das Gerät eine Benutzerverwaltung obligatorisch ist, diese aber noch nicht aktiviert ist. Sie werden gefragt, ob Sie die Benutzerverwaltung jetzt aktivieren wollen. Sie erhalten den Hinweis, dass Sie in diesem Fall einen neuen Administrator-Benutzer anlegen müssen und sich dann als dieser Benutzer einloggen müssen. Schließen Sie die Abfrage mit Ja . Der Dialog Gerätebenutzer hinzufügen öffnet sich zum Anlegen eines initialen Geräteadministrators. Definieren Sie die Zugangsdaten für den Geräteadministrator: Name und Passwort . Aktivieren Sie die Option Passwort kann vom Benutzer geändert werden . Beachten Sie unbedingt den Ernst des Passworts: Innerhalb des Entwicklungssystems gibt es keinen Weg, bei vergessenem Passwort wieder auf die Steuerung zu kommen. Schließen Sie mit OK ab. Der Dialog Gerätebenutzeranmeldung öffnet sich. Geben Sie die im vorigen Schritt definierten Zugangsdaten für den Geräteadministrator ein. Der Verbindungspfad zur Steuerung ist eingestellt. Die Ansicht der Kommunikationseinstellungen können Sie in den CODESYS - Optionen des Geräteeditors auf die klassische Ansicht umstellen. Für weitere Informationen siehe: Kommunikation verschlüsseln, Security-Einstellungen verändern" }, 
{ "title" : "Kommunikation verschlüsseln, Security-Einstellungen verändern ", 
"url" : "_cds_encrypting_communication_changing_security_policy.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf die SPS übertragen \/ Kommunikation verschlüsseln, Security-Einstellungen verändern ", 
"snippet" : "Empfehlungen zur Datensicherheit Um das Risiko von Datensicherheitsverletzungen zu minimieren, empfehlen wir die folgenden organisatorischen und technischen Maßnahmen für das System, auf dem Ihre Applikationen laufen: Vermeiden Sie soweit als möglich, die SPS und die Steuerungsnetzwerke offenen Netz...", 
"body" : "Empfehlungen zur Datensicherheit Um das Risiko von Datensicherheitsverletzungen zu minimieren, empfehlen wir die folgenden organisatorischen und technischen Maßnahmen für das System, auf dem Ihre Applikationen laufen: Vermeiden Sie soweit als möglich, die SPS und die Steuerungsnetzwerke offenen Netzwerken und dem Internet auszusetzen. Verwenden Sie zum Schutz zusätzliche Sicherungsschichten, wie ein VPN für Remote-Zugriffe. Installieren Sie Firewall-Mechanismen. Beschränken Sie den Zugriff auf autorisierte Personen. Verwenden Sie Passwörter mit hoher Stärke. Ändern Sie eventuell vorhandene Standardpasswörter bei der ersten Inbetriebnahme und ändern Sie diese weiterhin regelmäßig. Verwenden Sie die von CODESYS und dem betreffenden Steuerungsgerät unterstützten Security-Funktionalitäten, wie Verschlüsselung der Kommunikation mit dem Steuerungsgerät und gezielt eingeschränkten Benutzerzugriff. Die Kommunikation mit dem Gerät kann über Verschlüsselung und über eine Benutzerverwaltung auf dem Gerät geschützt werden. Wenn Sie die aktuelle Security-Voreinstellung ändern wollen, können Sie dies auf der Registerkarte Kommunikation des Geräteeditors tun. Für weitere Informationen und Anleitungen siehe: Kommunikation mit Zertifikat verschlüsseln, Sicherheitsrichtlinie ändern Benutzerverwaltung SPS " }, 
{ "title" : "Gerätebenutzerverwaltung handhaben ", 
"url" : "_cds_handling_user_management_on_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf die SPS übertragen \/ Gerätebenutzerverwaltung handhaben ", 
"snippet" : "Für Informationen hierzu siehe: CODESYS Security - Benutzerverwaltung \/ Zugriffsrechte für das Gerät handhaben Passwort, Passwortrichtlinie, Login-Sperre verwenden...", 
"body" : "Für Informationen hierzu siehe: CODESYS Security - Benutzerverwaltung \/ Zugriffsrechte für das Gerät handhaben Passwort, Passwortrichtlinie, Login-Sperre verwenden " }, 
{ "title" : "Applikationscode erzeugen ", 
"url" : "_cds_creating_application_code_for_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf die SPS übertragen \/ Applikationscode erzeugen ", 
"snippet" : "Der Applikationscode bezeichnet den Maschinencode, den eine Steuerung ausführt, wenn Sie eine Applikation starten. CODESYS erzeugt den Applikationscode aus dem im Entwicklungssystem geschriebenen Quellcode automatisch vor dem Download der Applikation auf die Steuerung. Dabei wird vor dem Erzeugen de...", 
"body" : "Der Applikationscode bezeichnet den Maschinencode, den eine Steuerung ausführt, wenn Sie eine Applikation starten. CODESYS erzeugt den Applikationscode aus dem im Entwicklungssystem geschriebenen Quellcode automatisch vor dem Download der Applikation auf die Steuerung. Dabei wird vor dem Erzeugen des Applikationscodes eine Prüfung der Zuweisungen, der Datentypen und der Verfügbarkeit von Bibliotheken durchgeführt. Weiterhin werden beim Erzeugen des Applikationscodes die Speicheradressen vergeben. Sie können diesen Vorgang auch explizit über den Befehl Erstellen → Code erzeugen ausführen. Damit können Sie mögliche Fehler in Ihrem Quellcode finden, auch wenn die Steuerung noch nicht verbunden ist. Die Fehler werden im Meldungsfenster in Kategorie „Übersetzen“ ausgegeben. Wenn Sie die Applikation verschlüsselt haben, ist Folgendes zu beachten: Wird nach einem Online-Change auf Anfrage eine (neue) Bootapplikation erzeugt, dann wird diese mit dem aktuellen Code im RAM gebildet. dieser Code ist nicht verschlüsselt! Verschlüsselung des Applikationscodes Für weitere Informationen siehe: Applikation schützen" }, 
{ "title" : "Explizites Erzeugen von Applikationscode ", 
"url" : "_cds_creating_application_code_for_plc.html#UUID-5c7fdea2-b927-dd81-e489-7c93454d6804_id_c4ec88dacce7d11bc0a8640e01d44e7d_id_0b4f2b8f2cd5acc8c0a8640e009372af", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf die SPS übertragen \/ Applikationscode erzeugen \/ Explizites Erzeugen von Applikationscode ", 
"snippet" : "Voraussetzung: Die Applikation lässt sich fehlerfrei übersetzen. Wählen Sie den Befehl Erstellen → Code erzeugen . Der Applikationscode wird erzeugt. In dem Meldungsfenster werden Detailinformationen zur Speicherbelegung ausgegeben. Für weitere Informationen siehe: Erzeugen einer Bootapplikation...", 
"body" : "Voraussetzung: Die Applikation lässt sich fehlerfrei übersetzen. Wählen Sie den Befehl Erstellen → Code erzeugen . Der Applikationscode wird erzeugt. In dem Meldungsfenster werden Detailinformationen zur Speicherbelegung ausgegeben. Für weitere Informationen siehe: Erzeugen einer Bootapplikation" }, 
{ "title" : "Meldungen beim Erzeugen des Applikationscodes ", 
"url" : "_cds_creating_application_code_for_plc.html#UUID-5c7fdea2-b927-dd81-e489-7c93454d6804_id_c4ec88dacce7d11bc0a8640e01d44e7d_id_624175cd2d47e684c0a8640e00e57d65", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf die SPS übertragen \/ Applikationscode erzeugen \/ Meldungen beim Erzeugen des Applikationscodes ", 
"snippet" : "Wenn Sie den Applikationscode erzeugen, gibt CODESYS Informationen zur Speicherbelegung im Meldungsfenster aus. Da aufgrund der inkrementellen Kompilierung der Speicher nur für geänderte und neue Bausteine und Variablen neu vergeben wird, entstehen Lücken im Speicher. Denselben Effekt haben Online-C...", 
"body" : "Wenn Sie den Applikationscode erzeugen, gibt CODESYS Informationen zur Speicherbelegung im Meldungsfenster aus. Da aufgrund der inkrementellen Kompilierung der Speicher nur für geänderte und neue Bausteine und Variablen neu vergeben wird, entstehen Lücken im Speicher. Denselben Effekt haben Online-Changes. Diese Fragmentierung verringert den verfügbaren freien Speicher. Sie können in diesem Fall den Speicher mit Hilfe des Befehls Bereinigen komplett neu vergeben und somit den freien Speicher wieder vergrößern. Syntaxfehler und Fehler, die CODESYS während der Codegenerierung und Speichervergabe feststellt, erscheinen ebenfalls im Meldungsfenster, in Kategorie Übersetzen . Ausgegebene Informationen zur Speicherbelegung: Größe des erzeugten Codes (in Bytes): Summe aller Codestücke Größe der globalen Daten (in Bytes): Gesamter von den globalen Variablen belegten Speicher. Ein- und Ausgaben werden dabei nicht berücksichtigt, es sei denn, es werden Ein- oder Ausgaben im Bereich der globalen Variablen abgebildet. Gesamter allozierter Speicherumfang für Code und Daten (in Bytes): Der gesamte allozierte Speicher umfaßt die bereits belegten Speicherbereiche plus den reservierten, noch nicht belegten Speicherplatz für inkrementelles Übersetzen und Online-Change. Nach dem ersten Übersetzen entspricht der bereits belegte Speicher in etwa der höchsten verwendeten Adresse (siehe unten). Die größte zusammenhängende Speicherlücke (siehe unten) entspricht noch in etwa der Differenz zum gesamten allozierten Speicherumfang. Mit ansteigender Zahl von inkrementellen Übersetzungsläufen und Online-Changes steigt jedoch auch die Anzahl von Speicherlücken und die größte zusammenhängende Speicherlücke wird kleiner. Speicherbereich <n> : Inhalt der einzelnen belegten Speicherbereiche: Hintergrund: Es hängt von der SPS ab, in welchen Speicherbereichen welche Daten und der Code untergebracht werden. Beispielsweise liegen auf CODESYS Control Win Code und Daten im gleichen Bereich. Für die Adressen %I , %M , %Q wird immer Speicher reserviert, auch wenn keine Variable einer Adresse zugewiesen ist. Nach einem „Bereinigen“ der Applikation wird der Speicher komplett neu vergeben. In diesem Fall kommt es durch das vorgegebene „Alignment“ (in der Regel 8) eventuell zu kleinen Lücken. Größere Lücken entstehen bei der Änderung eines Datums ohne „Bereinigen“, beispielsweise durch Vergrößern eines Arraybereichs. In diesem Fall werden nur die betroffenen Bausteine neu übersetzt. Und auch im Fall eines Online-Changes wird der Speicher nur für neue Variablen und neuen Code verwendet. Speicher, der zuvor durch gelöschte Variablen und Code belegt war, wird wieder freigegeben. So kann es nach vielen inkrementellen Übersetzungsläufen und Online-Changes zu einer Fragmentierung des Speichers kommen. Es entstehen viele kleine Lücken, die unter Umständen gar nicht mehr genutzt werden können. Damit klar ist, wieviel Speicher sicher zur Verfügung steht, wird bei der Codegenerierung die „größte zusammenhängende Speicherlücke“ des Speicherbereichs ausgegeben. Höchste verwendete Adresse (Byte) : Dies ist die höchste belegte Adresse im gesamten allozierten Speicherbereich. Beim ersten Kompilieren nach einem „Bereinigen“ werden die Speicheradressen unter Berücksichtigung der Ausrichtung (in der Regel 8 Byte) in aufsteigender Reihenfolge an Variablen ausgegeben. Somit entspricht zu diesem Zeitpunkt die höchste verwendete Adresse in etwa dem belegten Speicherumfang. Der Rest des allozierten Speicherbereichs steht noch komplett für inkrementelles Übersetzen und Online-Change zur Verfügung. Größte zusammenhängende Speicherlücke (in Bytes): Dies ist der Speicherumfang, der gesichert zur Verfügung steht. Entstehende Lücken im allozierten Speicher werden soweit möglich bei weiteren Änderungen wieder verwendet. Wenn beispielsweise eine globale Variable vom Typ Byte hinzugefügt wird, wird sie im ersten freien Byte des Speichers platziert. Dafür genügt also eine kleine Lücke. Aber: Eine FB-Instanz, eine Variable vom Typ Struktur oder Array, oder der Code für einen Baustein müssen zusammenhängend gespeichert werden und belegen daher entsprechend mehr Speicher. Sie können somit nur dem größten zusammenhängenden Speicherbereich zugeordnet werden. Und deshalb wird bei der Codegenerierung die als sicher zur Verfügung stehende „größte zusammenhängende Speicherlücke“ ausgegeben (in Bytes), außerdem ihr prozentualer Anteil am Gesamtspeicher. Beachten Sie hierzu auch: Optionen zur Applikationserzeugung " }, 
{ "title" : "Applikationscode laden, einloggen und SPS starten ", 
"url" : "_cds_loading_application_login_starting.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf die SPS übertragen \/ Applikationscode laden, einloggen und SPS starten ", 
"snippet" : "Um den Quellcode Ihrer Applikation auf die Steuerung zu laden, müssen Sie sich mit der Applikation auf der Steuerung einloggen. Falls Sie mehrere Applikationen in Ihrem Projekt haben, müssen Sie die gewünschte Applikation zuerst aktiv schalten. Wenn Sie eine Applikation in die Steuerung laden, führt...", 
"body" : "Um den Quellcode Ihrer Applikation auf die Steuerung zu laden, müssen Sie sich mit der Applikation auf der Steuerung einloggen. Falls Sie mehrere Applikationen in Ihrem Projekt haben, müssen Sie die gewünschte Applikation zuerst aktiv schalten. Wenn Sie eine Applikation in die Steuerung laden, führt CODESYS folgende Prüfungen durch: Die Liste der Applikationen auf der Steuerung wird mit den im Projekt verfügbaren verglichen. Bei Nicht-Übereinstimmung werden Sie gefragt, ob Sie die noch nicht auf der Steuerung vorhandenen Applikation laden oder bereits vorhandene Applikationen löschen wollen. Für „extern implementierte“ Bausteine in der zu ladenden Applikation prüft CODESYS , ob diese auf der Steuerung verfügbar sind. Wenn dies nicht der Fall ist, erscheint eine Meldung („unaufgelöste Referenz(en)“) in einer Meldungsbox und im Meldungsfenster. Anschließend vergleicht CODESYS die Parameter (Variablen) der Bausteine in der zu ladenden Applikation mit denen der gleichnamigen Bausteine in der bereits auf der Steuerung vorliegenden Applikation (Signaturen-Prüfung). Bei Unstimmigkeiten wird eine entsprechende Meldung („ungültige Signatur(en)“) in einer Meldungsbox und im Meldungsfenster ausgegeben. Wenn in den Applikationseigenschaften die Option „Download der Applikationsinfo“ aktiviert ist, werden zusätzlich Informationen über den Inhalt der Applikation auf die SPS geladen. Wenn für dasselbe Gerät mehrere Applikationen bereitstehen, beachten Sie, dass für das E\/A-Abbild des Geräts im Dialog E\/A-Abbild definiert wird, welche der Applikationen beim Abbild berücksichtigt wird. Zu beachten: Wenn von CODESYS aus eine Verbindung zu einer Steuerung aufgebaut wird, mit der der CODESYS Automation Server über ein Edge-Gateway verbunden ist, kann es passieren, dass lokale Änderungen auf der Steuerung durch den CODESYS Automation Server überschrieben werden. Hierzu erscheint in CODESYS eine Meldung im Meldungsfenster, wenn nach dem Öffnen des Projekts in CODESYS das erste Mal die Verbindung zur Steuerung hergestellt wird. Für weitere Informationen siehe: ApplikationÜbertragen der Applikation und Starten des Programms Voraussetzung: Die Applikation ist fehlerfrei und die Kommunikationseinstellungen der Steuerung sind korrekt. Die Applikation befindet sich noch nicht auf der Steuerung. Die Applikation und die Kommunikation mit der Steuerung sind nicht verschlüsselt. Selektieren Sie die gewünschte Applikation im Gerätebaum. Falls Sie nur eine Applikation haben, machen Sie mit Schritt 3 weiter. Wählen Sie den Befehl Aktive Applikation setzen . Die Applikation wird fett dargestellt. Wählen Sie den Befehl Online → Einloggen . Es erscheint ein Dialog mit der Abfrage, ob Sie die Applikation auf der Steuerung anlegen wollen. Bestätigen Sie den Dialog mit Ja . Die Applikation wird auf die Steuerung geladen. Wählen Sie den Befehl Debug → Start oder Drücken Sie F5 . Die Applikation läuft auf der Steuerung. " }, 
{ "title" : "Erzeugen einer Bootapplikation ", 
"url" : "_cds_creating_a_boot_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf die SPS übertragen \/ Erzeugen einer Bootapplikation ", 
"snippet" : "Eine Bootapplikation ist die Applikation, die automatisch gestartet wird, wenn die Steuerung eingeschaltet oder gestartet wird. Dazu muss die Applikation auf der Steuerung in einer Datei <Applikationsname>.app vorhanden sein. Für jede auf der Steuerung laufende Applikation kann dort auch eine Bootap...", 
"body" : "Eine Bootapplikation ist die Applikation, die automatisch gestartet wird, wenn die Steuerung eingeschaltet oder gestartet wird. Dazu muss die Applikation auf der Steuerung in einer Datei <Applikationsname>.app vorhanden sein. Für jede auf der Steuerung laufende Applikation kann dort auch eine Bootapplikation abgelegt sein. Standardmäßig erzeugt CODESYS die Bootapplikation automatisch beim Download einer Applikation und überträgt sie mit auf die SPS. Die Voreinstellungen zur automatischen Erzeugung liegen in den Eigenschaften des Applikationsobjekts in Kategorie Bootapplikation . Beim Einloggen mit einer geänderten Applikation erhalten Sie aber immer nochmals die Möglichkeit, zu entscheiden, ob nun eine neue Bootapplikation erzeugt werden soll, oder nicht. Außerdem können Sie im Onlinebetrieb jederzeit explizit eine (neue) Bootapplikation anlegen, über den Befehl Online → Bootapplikation erzeugen . Auch im Offlinebetrieb können Sie eine Bootapplikation erzeugen und lokal speichern. Diese Applikation können Sie dann mit externen Tools auf die Steuerung kopieren. Somit können Sie eine Applikation auf eine Steuerung übertragen, auch wenn keine Verbindung zu CODESYS besteht. Hinweis für Verwendung mit CODESYS Control Win Bei Verwendung einer CODESYS Control Win muss zusätzlich der Name der Applikation in der Konfigurationsdatei ( *.cfg ) des Geräts enthalten sein. [CmpApp]\nApplication.1=MyApplication " }, 
{ "title" : "Bootapplikation auf der Steuerung automatisch und explizit erzeugen ", 
"url" : "_cds_creating_a_boot_application.html#UUID-c54f0d29-44ff-6993-adb8-9af7e6d0bdf6_id_a0805999879591e6c0a8640e017feaf9_id_8d4ef86a2876f271c0a8640e01324013", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf die SPS übertragen \/ Erzeugen einer Bootapplikation \/ Bootapplikation auf der Steuerung automatisch und explizit erzeugen ", 
"snippet" : "Voraussetzung: Offlinebetrieb und Ihre Applikation ist fehlerfrei übersetzt. Die Verbindung zur Steuerung ist konfiguriert, die Steuerung läuft. Die Applikation ist die aktive. Folgende Schritte demonstrieren die Möglichkeiten: Wählen Sie den Befehl Online → Einloggen . Auf der Steuerung wird die Bo...", 
"body" : "Voraussetzung: Offlinebetrieb und Ihre Applikation ist fehlerfrei übersetzt. Die Verbindung zur Steuerung ist konfiguriert, die Steuerung läuft. Die Applikation ist die aktive. Folgende Schritte demonstrieren die Möglichkeiten: Wählen Sie den Befehl Online → Einloggen . Auf der Steuerung wird die Bootapplikationsdatei <Applikationsname>.app angelegt, daneben die Prüfsumme der Bootapplikation <Applikationsname>.crc . Wählen Sie nun explizit den Befehl Online → Bootapplikation erzeugen . Die Dateien auf der Steuerung werden durch neue ersetzt. Loggen Sie sich aus. Verändern Sie die Applikation. Loggen Sie erneut auf die Steuerung ein. Sie werden gefragt, ob ein Online-Change durchgeführt werden soll. Im gleichen Dialog sehen Sie die Option Bootapplikation aktualisieren . Standardmäßig ist sie deaktivert. Die Voreinstellung kann in den Eigenschaften des Applikationsobjekts in Kategorie Bootapplikation verändert werden. Lassen Sie die Option deaktivert und setzen Sie das Einloggen fort. Keine neuen Bootapplikationsdateien werden angelegt. Loggen Sie wieder aus. Schließen Sie das Projekt. Stoppen Sie die Steuerung. Starten Sie die Steuerung erneut. Auf der Steuerung läuft die oben angelegte Bootapplikation. Sie können die Bootapplikation verschlüsselt auf der Steuerung ablegen. Die Einstellungen hierzu sind in den Eigenschaften des Applikationsobjekts, Kategorie Optionen Applikationserzeugung definiert. Für weitere Informationen siehe: Online-Change ausführen" }, 
{ "title" : "Bootapplikation im Offlinebetrieb anlegen ", 
"url" : "_cds_creating_a_boot_application.html#UUID-c54f0d29-44ff-6993-adb8-9af7e6d0bdf6_id_a0805999879591e6c0a8640e017feaf9_id_ed59e5272876f272c0a8640e0179f8b8", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf die SPS übertragen \/ Erzeugen einer Bootapplikation \/ Bootapplikation im Offlinebetrieb anlegen ", 
"snippet" : "Voraussetzung: Offlinebetrieb und Ihre Applikation ist fehlerfrei übersetzt. Sie möchten für eine Applikation eine Bootapplikation erzeugen und im Dateiverzeichnis ablegen, um sie später mit Hilfe externer Tools auf die Steuerung zu bringen, ohne CODESYS zu benötigen. Wählen Sie den Befehl Online → ...", 
"body" : "Voraussetzung: Offlinebetrieb und Ihre Applikation ist fehlerfrei übersetzt. Sie möchten für eine Applikation eine Bootapplikation erzeugen und im Dateiverzeichnis ablegen, um sie später mit Hilfe externer Tools auf die Steuerung zu bringen, ohne CODESYS zu benötigen. Wählen Sie den Befehl Online → Bootapplikation erzeugen . Ein Dialog zum Angeben eines Speicherorts im lokalen Dateisystem erscheint. Wählen Sie einen Ablagepfad und klicken Sie Speichern . Wenn sich die Applikation seit dem letzten Erzeugen der Bootapplikation geändert hat, erscheint eine Abfrage, ob Sie einen neuen Code für die Bootapplikation verwenden möchten. Klicken Sie in diesem Fall auf Ja . Der Dialog Speichern unter erscheint. Wählen Sie ein Verzeichnis aus und klicken Sie auf Speichern . Im angegebenen Pfad wird die Bootapplikationsdatei <Applikationsname>.app angelegt. Sie werden gefragt, ob die Übersetzungsinformation für die Bootapplikation gespeichert werden soll. Klicken Sie Ja . Die Übersetzungsinformation wird als Datei <Applikationsname>.compileinfo im Projektverzeichnis gespeichert. Sie ist beim nächsten Aktualisieren der Applikation Voraussetzung für einen möglichen Online-Change. Hinweis: Der Befehl Erstellen → Bereinigen löscht diese Datei. " }, 
{ "title" : "Laden des Quellcodes auf\/von der SPS ", 
"url" : "_cds_loading_sourcecode_to_from_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf die SPS übertragen \/ Laden des Quellcodes auf\/von der SPS ", 
"snippet" : "CODESYS bietet Ihnen die Möglichkeit, den Quellcode eines Projektes als Projektarchiv auf die SPS zu laden. Dieses Projektarchiv können Sie bei Bedarf wieder von der SPS zurück auf das Programmiersystem übertragen. Voraussetzung: Die Verbindungseinstellung zu der betroffenen Steuerung ist konfigurie...", 
"body" : "CODESYS bietet Ihnen die Möglichkeit, den Quellcode eines Projektes als Projektarchiv auf die SPS zu laden. Dieses Projektarchiv können Sie bei Bedarf wieder von der SPS zurück auf das Programmiersystem übertragen. Voraussetzung: Die Verbindungseinstellung zu der betroffenen Steuerung ist konfiguriert. Laden des Quellcodes von der SPS Wählen Sie den Befehl Datei → Quellcode von Steuerung laden . Es öffnet sich der Dialog Gerät auswählen . Selektieren Sie die Steuerung, von der Sie den Quellcode laden wollen. Klicken Sie auf OK . Es öffnet sich der Dialog Projekt extrahieren . Wählen Sie das Verzeichnis, in das Sie das Projektarchiv extrahieren wollen. Klicken Sie auf Extrahieren . CODESYS extrahiert das Projektarchiv in das angegebene Verzeichnis. Anschließend werden Sie gefragt, ob Sie das Projektarchiv öffnen wollen. Klicken Sie auf Ja . Das Projekt wird geöffnet. " }, 
{ "title" : "Laden des Quellcodes auf die SPS ", 
"url" : "_cds_loading_sourcecode_to_from_plc.html#UUID-0ad360c5-6f3b-72f6-1bf4-e13ee462c493_id_b468660460c0a8640e01de1e14_id_07ca0313689602ffc0a8640e010017e8", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf die SPS übertragen \/ Laden des Quellcodes auf\/von der SPS \/ Laden des Quellcodes auf die SPS ", 
"snippet" : "Wählen Sie den Befehl Datei → Quellcode auf Steuerung laden . Es öffnet sich der Dialog Gerät auswählen . Selektieren Sie die Steuerung, auf der Sie den Quellcode laden wollen. Klicken Sie auf OK . CODESYS schreibt die Archivdatei Archiv.prj auf die Steuerung. Mit dem Befehl Online → Quellcode auf v...", 
"body" : "Wählen Sie den Befehl Datei → Quellcode auf Steuerung laden . Es öffnet sich der Dialog Gerät auswählen . Selektieren Sie die Steuerung, auf der Sie den Quellcode laden wollen. Klicken Sie auf OK . CODESYS schreibt die Archivdatei Archiv.prj auf die Steuerung. Mit dem Befehl Online → Quellcode auf verbundene Steuerung schreiben können Sie den Quellcode direkt auf die verbundene Steuerung laden. Für weitere Informationen siehe: Download Quellcode" }, 
{ "title" : "Applikationscode auf verschiedene Speicherbereiche verteilen ", 
"url" : "_cds_mapping_code_in_different_areas.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf die SPS übertragen \/ Applikationscode auf verschiedene Speicherbereiche verteilen ", 
"snippet" : "CODESYS bietet die Möglichkeit den Code einer Applikation in unterschiedlichen Speicherbereichen auf der Steuerung zu speichern. Voraussetzung dafür ist, dass Sie eine Steuerung verwenden, die diese Funktionalität unterstützt. Bei diesen speziellen Steuerungen enthält Ihre Applikation automatisch da...", 
"body" : "CODESYS bietet die Möglichkeit den Code einer Applikation in unterschiedlichen Speicherbereichen auf der Steuerung zu speichern. Voraussetzung dafür ist, dass Sie eine Steuerung verwenden, die diese Funktionalität unterstützt. Bei diesen speziellen Steuerungen enthält Ihre Applikation automatisch das Objekt POU Locations , mit dem Sie Ihren einzelnen Programmbausteinen unterschiedliche Speicherbereiche zuordnen. Bitte beachten Sie auch hersteller- oder steuerungsspezifische Vorgaben oder Informationen zu dieser Funktionalität. Voraussetzung: Die Applikation enthält keine Übersetzungsfehler. Doppelklicken Sie auf das Objekt POU Locations in der Ansicht Geräte . Klicken Sie im geöffneten Objekt auf die Schaltfläche Code erzeugen . Alle Programmbausteine der Applikation werden mit ihrem Objekttyp, ihrer aktuellen Position im Speicher und ihrer Codegröße angezeigt. Doppelklicken Sie bei den Programmbausteinen, die Sie in einem anderen Speicherbereich speichern wollen, auf den Eintrag in der Spalte Konfigurierte Position . Ein Auswahlliste öffnet sich. Wählen Sie in der Auswahlliste den gewünschten Speicherbereich aus. Klicken auf Bereinigen und anschließend auf Code erzeugen . Die Programmbausteine werden an den neu konfigurierten Speicherorten abgelegt. " }, 
{ "title" : "Testen und Fehler beheben ", 
"url" : "_cds_struct_test_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben ", 
"snippet" : "CODESYS bietet Ihnen verschiedene Möglichkeiten, Ihre Applikation zu testen und Fehler zu finden. So können Sie im Simulationsbetrieb Ihre Applikation auch ohne angeschlossene Hardware starten. Mit Haltepunkten und Befehlen zum schrittweisen Abarbeiten des Programms können Sie ganz gezielt bestimmte...", 
"body" : "CODESYS bietet Ihnen verschiedene Möglichkeiten, Ihre Applikation zu testen und Fehler zu finden. So können Sie im Simulationsbetrieb Ihre Applikation auch ohne angeschlossene Hardware starten. Mit Haltepunkten und Befehlen zum schrittweisen Abarbeiten des Programms können Sie ganz gezielt bestimmte Programmstellen untersuchen. Durch das Schreiben von Variablenwerten können Sie das laufende Programm beeinflussen. Es stehen Ihnen Befehle zur Verfügung, die Ihre Applikation unterschiedlich stark zurücksetzen. Dies reicht vom Rücksetzen der nur nichtpersistenten Variablen bis zum kompletten Zurücksetzen der Steuerung in den Auslieferungszustand. " }, 
{ "title" : "Testen im Simulationsbetrieb ", 
"url" : "_cds_testing_in_simulation_mode.html", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Testen im Simulationsbetrieb ", 
"snippet" : "Verwenden Sie den Simulationsbetrieb zum Testen und Debuggen Ihres Programms, wenn Sie kein reales Zielgerät zur Verfügung haben. In diesem Modus wird die Applikation auf einem simulierten Zielgerät gestartet. Der Befehl ist nur im ausgeloggten Zustand verfügbar. Voraussetzung: Sie haben ein fehlerf...", 
"body" : "Verwenden Sie den Simulationsbetrieb zum Testen und Debuggen Ihres Programms, wenn Sie kein reales Zielgerät zur Verfügung haben. In diesem Modus wird die Applikation auf einem simulierten Zielgerät gestartet. Der Befehl ist nur im ausgeloggten Zustand verfügbar. Voraussetzung: Sie haben ein fehlerfreies Programm (Compiler-Fehlermeldungen oder Übersetzungsfehler) und sind nicht eingeloggt. Aktivieren Sie den Simulationsbetrieb. Wählen Sie den Menübefehl Online → Simulation oder Selektieren Sie die Steuerung im Gerätebaum und wählen Sie aus dem Kontextmenü den Befehl Simulation . Der Name der Steuerung im Gerätebaum wird kursiv dargestellt. In der Statuszeile erscheint „Simulation“ mit rotem Hintergrund. Der Menübefehl Simulation ist angehakt. Wählen Sie den Befehl Online → Einloggen . Beim ersten Einloggen mit der aktiven Applikation erfolgt die Abfrage, ob die Applikation „Sim.<devicename>.<applicationname>“ angelegt und geladen werden soll. Bestätigen Sie mit Ja . Die Applikation ist auf der Steuerung eingeloggt. Dies wird im Gerätebaum durch das Icon vor der Steuerung signalisiert. Sie können nun den Programmablauf prüfen und korrigieren. Dazu stehen Ihnen entsprechende Befehle im Menü Debug zur Verfügung. Loggen Sie sich aus der Steuerung aus und beenden Sie den Simulationsbetrieb. " }, 
{ "title" : "Verwenden von Haltepunkten ", 
"url" : "_cds_using_breakpoints.html", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Verwenden von Haltepunkten ", 
"snippet" : "Haltepunkte (Breakpoints) werden üblicherweise zur Fehlersuche im Programm genutzt. CODESYS unterstützt Haltepunkte in allen IEC-Editoren. Sie können Haltepunkte an bestimmten Positionen im Programm setzen, um dort einen Ausführungsstopp zu erzwingen und die Variablenwerte zu beobachten. Sie können ...", 
"body" : "Haltepunkte (Breakpoints) werden üblicherweise zur Fehlersuche im Programm genutzt. CODESYS unterstützt Haltepunkte in allen IEC-Editoren. Sie können Haltepunkte an bestimmten Positionen im Programm setzen, um dort einen Ausführungsstopp zu erzwingen und die Variablenwerte zu beobachten. Sie können spezielle „Datenhaltepunkte“ setzen, um die Programmausführung anzuhalten, wenn sich der Wert einer bestimmten Variablen ändert. Der Stopp am Haltepunkt oder Datenhaltepunkt kann an zusätzliche Bedingungen geknüpft werden. Sie können Haltepunkte und Datenhaltepunkte auch zu „Ausführungspunkten“ umdefinieren, an denen das Programm nicht stoppt, sondern bestimmter Code abgearbeitet wird. Die Ansicht Haltepunkte gibt eine Übersicht über alle definierten Haltepunkte. Darin stehen Ihnen zusätzliche Befehle zum gleichzeitigen Ändern mehrerer Haltepunkte zur Verfügung. Im Editor wird der Status von Haltepunkten und Ausführungspunkten mit folgenden Symbolen markiert: : Der Haltepunkt ist aktiviert. : Der Haltepunkt ist deaktiviert. : Der Haltepunkt ist in einer anderen Instanz des gerade im Editor geöffneten Bausteins gesetzt. : Das Programm hält am Haltepunkt an. : Der Haltepunkt mit Bedingung ist aktiviert. : Der Haltepunkt mit Bedingung ist deaktiviert. : Der Ausführungspunkt ist aktiviert. : Der Ausführungspunkt ist deaktiviert. : Der Ausführungspunkt mit Bedingung ist aktiviert. : Der Ausführungspunkt mit Bedingung ist deaktiviert. : Der Datenhaltepunkt ist aktiviert. : Der Datenhaltepunkt ist deaktiviert. : Das Programm hält am Datenhaltepunkt an. : Der Datenausführungspunkt ist aktiviert. : Der Datenausführungspunkt ist deaktiviert. : Das Programm hält am Datenausführungspunkt an. : Der Datenausführungspunkt mit Bedingung ist aktiviert. : Der Datenhaltepunkt mit Bedingung ist aktiviert. Für weitere Informationen siehe: HaltepunkteSetzen eines Datenhaltepunkts Voraussetzung: Die Applikation ist im Onlinebetrieb und läuft. Wählen Sie den Befehl Ansicht → Haltepunkte . Wählen Sie den Befehl Debug → Neuer Datenhaltepunkt . Klicken Sie im Dialog Neuer Haltepunkt in der Registerkarte Daten auf die Schaltfläche . Wählen Sie im Dialog Eingabehilfe in der Registerkarte Watch-Variablen die Variable aus, bei deren Wertänderung das Programm anhalten soll. Alternativ geben Sie in der Registerkarte Daten in die Eingabezeile direkt den qualifizierten Namen der Variablen ein. Beispiel: PLC_PRG.iNumber . Die genaue Anzahl der zu überwachenden Bytes wird als Größe angegeben. Automatisch ist hier ein dem Datentyp entsprechender Wert vorgegeben, Sie können aber auch weniger Bytes überwachen lassen. Selektieren Sie in der Ansicht Haltepunkte die Zeile mit dem Datenhaltepunkt und klicken Sie auf die Schaltfläche . Die Zeile wird markiert und mit dem Icon (Datenhaltepunkt aktiviert) gekennzeichnet. Wenn das Programm den Datenhaltepunkt erreicht, das heißt, wenn sich der Wert der ausgewählten Variablen ändert, stoppt die Abarbeitung des Programms. Im Implementierungsteil des Bausteins wird die Folgezeile mit einem Pfeil gekennzeichnet. Dies wird in der Statuszeile mit dem rot hinterlegten Status HALT AUF BP signalisiert. Wählen Sie den Befehl Debug → Start oder drücken Sie die Taste F5 . Das Programm läuft weiter und bleibt dann wieder stehen, wenn sich der Wert der Variablen erneut ändert. " }, 
{ "title" : "Datenhaltepunkte ", 
"url" : "_cds_using_breakpoints.html#UUID-eb91dc52-07a4-5e25-16b5-ccbb7bda59cd_id_a29163617e8e0b7c0a8640e01803c00_id_2d628f59bea511e09bc3d16902ba108f", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Verwenden von Haltepunkten \/ Datenhaltepunkte ", 
"snippet" : "Die Funktion der Datenhaltepunkte ist vom Zielsystem abhängig. Aktuell sind Datenhaltepunkte nur mit der CODESYS Control Win möglich. An einem Datenhaltepunkt hält die Programmabarbeitung an, wenn sich der Wert einer bestimmten Variablen oder Speicheradresse ändert. Wie bei „normalen“ Haltepunkten k...", 
"body" : "Die Funktion der Datenhaltepunkte ist vom Zielsystem abhängig. Aktuell sind Datenhaltepunkte nur mit der CODESYS Control Win möglich. An einem Datenhaltepunkt hält die Programmabarbeitung an, wenn sich der Wert einer bestimmten Variablen oder Speicheradresse ändert. Wie bei „normalen“ Haltepunkten kann der Stopp an eine zusätzliche Bedingung geknüpft werden, oder kann statt des Stopps bestimmter Code abgearbeitet werden (Umwandlung in einen Datenausführungspunkt). Sie setzen einen Datenhaltepunkt mit dem Befehl Neuer Datenhaltepunkt entweder aus dem Menü Debug , oder in der Ansicht Haltepunkte über die Schaltfläche Neu . Sie geben dabei einen qualifizierten Variablennamen oder direkt eine Speicheradresse an, die auf Änderung ihres Werts überwacht werden soll. Beispiel Im folgenden Beispielcode wird der Speicherplatz von Variable iNumber ungewollt überschrieben. Mit einem Datenhaltepunkt auf der Variablen iNumber wird jedoch bemerkt, wenn sich ihr Wert ändert. Die Abarbeitung bleibt dann mit einer entsprechenden Meldung bei dem Arrayzugriff stehen, welcher den Variablenwert überschreibt: Idx = 7 . Sehen Sie dazu auch weiter unten: „Setzen eines Datenhaltepunkts“ PROGRAM PLC_PRG\nVAR\n Idx : INT;\n Ary : ARRAY[0..3] OF BYTE;\n iNumber : INT := 55;\nEND_VAR\nFOR idx := 0 TO 6 DO\n Ary[idx] := 0;\nEND_FOR " }, 
{ "title" : "Haltepunkte in Applikationen mit mehreren Tasks ", 
"url" : "_cds_using_breakpoints.html#UUID-eb91dc52-07a4-5e25-16b5-ccbb7bda59cd_id_a29163617e8e0b7c0a8640e01803c00_id_fc3cb2351b73b0bcc0a8640e006f44cc", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Verwenden von Haltepunkten \/ Haltepunkte in Applikationen mit mehreren Tasks ", 
"snippet" : "Grundsätzlich gilt: Debugging ist nicht auf mehreren Tasks gleichzeitig möglich. Solange Sie auf einer Task mit Haltepunkten oder schrittweiser Abarbeitung arbeiten, werden Haltepunkte in anderen Tasks ignoriert. Wenn ein Baustein, in dem ein Haltepunkt gesetzt ist, von mehreren Tasks verwendet wird...", 
"body" : "Grundsätzlich gilt: Debugging ist nicht auf mehreren Tasks gleichzeitig möglich. Solange Sie auf einer Task mit Haltepunkten oder schrittweiser Abarbeitung arbeiten, werden Haltepunkte in anderen Tasks ignoriert. Wenn ein Baustein, in dem ein Haltepunkt gesetzt ist, von mehreren Tasks verwendet wird, dann wird nur die Task („Debug-Task“) angehalten, die zuerst auf den Haltepunkt trifft. Alle anderen Tasks laufen weiter. Im Dialog Aufrufliste sehen Sie, welche Task gerade angehalten wird. Wenn Sie wollen, dass nur eine bestimmte Task von einem Haltepunkt betroffen sein soll, können Sie dies in den Haltepunkteigenschaften festlegen. Haltepunkte funktionieren für jede Applikation separat, so dass ein „Halt auf BP“ keine andere Applikation betrifft. Dies gilt auch für Vater\/Kind-Applikationen, sogar wenn der Haltepunkt in einem Baustein gesetzt ist, der von mehreren Applikationen verwendet wird und dessen Code nur einmal auf der SPS liegt. Die E\/As, die von der „Debug-Task“ bedient werden, werden bei einem Stop im Haltepunkt nicht aktualisiert, auch wenn Sie die Option E\/As aktualisieren im Stop in den SPS-Einstellungen aktiviert haben. Wenn die Applikation auf der SPS an einem Haltepunkt steht, erzeugt ein Online Change oder Download ein Stoppen aller Tasks, was ein Stop der SPS bedeutet! In diesem Fall zeigt CODESYS eine entsprechende Meldung an und Sie können entscheiden, ob Sie mit dem Login fortfahren wollen oder nicht. " }, 
{ "title" : "Setzen eines einfachen Haltepunkts (Beispiel ST-Editor) ", 
"url" : "_cds_using_breakpoints.html#UUID-eb91dc52-07a4-5e25-16b5-ccbb7bda59cd_id_a29163617e8e0b7c0a8640e01803c00_id_976c066b2e8311e482de899d4a6249d6", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Verwenden von Haltepunkten \/ Setzen eines einfachen Haltepunkts (Beispiel ST-Editor) ", 
"snippet" : "Voraussetzung: Die Applikation ist im Onlinebetrieb und läuft. Der Operating Mode ist Debug . Öffnen Sie eine POU in der Sprache ST im Editor. Setzen Sie den Cursor in die Zeile, in der ein Haltepunkt gesetzt werden soll. Wählen Sie den Befehl Debug → Haltepunkt umschalten oder drücken Sie die Taste...", 
"body" : "Voraussetzung: Die Applikation ist im Onlinebetrieb und läuft. Der Operating Mode ist Debug . Öffnen Sie eine POU in der Sprache ST im Editor. Setzen Sie den Cursor in die Zeile, in der ein Haltepunkt gesetzt werden soll. Wählen Sie den Befehl Debug → Haltepunkt umschalten oder drücken Sie die Taste F9 . Die Zeile wird rot markiert und mit dem Icon (Haltepunkt aktiviert) gekennzeichnet. Wenn das Programm an dem Haltepunkt steht, wird die Zeile mit dem Icon (Stop an Haltepunkt) gekennzeichnet. Die Abarbeitung des Programms stoppt. Dies wird in der Statuszeile mit dem rot hinterlegten Status HALT AUF BP signalisiert. Wählen Sie den Befehl Debug → Start oder drücken Sie die Taste F5 . Das Programm läuft weiter. Setzen Sie weitere Haltepunkte und überprüfen Sie an den Haltepositionen die Werte von Variablen. Setzen Sie den Cursor in eine Zeile, in der ein Haltepunkt gelöscht werden soll. Wählen Sie den Befehl Debug → Haltepunkt umschalten oder drücken Sie die Taste F9 . Die Markierung verschwindet. Der Haltepunkt ist gelöscht. " }, 
{ "title" : "Festlegen einer Haltepunkt-Bedingung (Beispiel ST-Editor) ", 
"url" : "_cds_using_breakpoints.html#UUID-eb91dc52-07a4-5e25-16b5-ccbb7bda59cd_id_a29163617e8e0b7c0a8640e01803c00_id_aae846be2e8311e482de899d4a6249d6", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Verwenden von Haltepunkten \/ Festlegen einer Haltepunkt-Bedingung (Beispiel ST-Editor) ", 
"snippet" : "Öffnen Sie eine POU in der Sprache ST im Editor. Setzen Sie den Cursor in die Zeile, in der ein Haltepunkt gesetzt werden soll. Wählen Sie den Befehl Debug → Neuer Haltepunkt . Es öffnet sich der Dialog Neuer Haltepunkt . Wählen Sie die Registerkarte Bedingung . Wählen Sie im Abschnitt Trefferzahl d...", 
"body" : "Öffnen Sie eine POU in der Sprache ST im Editor. Setzen Sie den Cursor in die Zeile, in der ein Haltepunkt gesetzt werden soll. Wählen Sie den Befehl Debug → Neuer Haltepunkt . Es öffnet sich der Dialog Neuer Haltepunkt . Wählen Sie die Registerkarte Bedingung . Wählen Sie im Abschnitt Trefferzahl die Option Anhalten, wenn die Trefferzahl ein Vielfaches ist von . Geben Sie im Feld rechts daneben den Wert 5 ein. Definieren Sie zusätzlich noch eine boolesche Bedingung, wann der Haltepunkt aktiv sein soll. Aktivieren Sie dazu die Option Halt, wenn True . Geben Sie im Feld rechts daneben eine boolesche Variable ein. Aktivieren Sie die Option Haltepunkt sofort aktivieren . Schließen Sie den Dialog. Die Zeile wird rot markiert und mit dem Icon gekennzeichnet. Beobachten Sie nun das laufende Programm. Solange die boolesche Variable für die Bedingung FALSE ist, ist die Bedingung für den Haltepunkt nicht erfüllt und das Programm läuft. Wenn Sie die Variable auf TRUE setzen, ist die Bedingung erfüllt und das Programm bleibt bei jedem 5. Durchlauf an diesem Haltepunkte stehen. " }, 
{ "title" : "Festlegen eines Ausführungspunkts (Beispiel ST-Editor) ", 
"url" : "_cds_using_breakpoints.html#UUID-eb91dc52-07a4-5e25-16b5-ccbb7bda59cd_id_a29163617e8e0b7c0a8640e01803c00_id_fb223006da6101d6c0a864630d894b56", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Verwenden von Haltepunkten \/ Festlegen eines Ausführungspunkts (Beispiel ST-Editor) ", 
"snippet" : "Öffnen Sie eine POU in der Sprache ST im Editor. Setzen Sie den Cursor in die Zeile, in der ein Ausführungspunkt gesetzt werden soll. Wählen Sie den Befehl Debug → Neuer Haltepunkt . Es öffnet sich der Dialog Neuer Haltepunkt . Wählen Sie die Registerkarte Ausführungspunkt Einstellungen . Aktivieren...", 
"body" : "Öffnen Sie eine POU in der Sprache ST im Editor. Setzen Sie den Cursor in die Zeile, in der ein Ausführungspunkt gesetzt werden soll. Wählen Sie den Befehl Debug → Neuer Haltepunkt . Es öffnet sich der Dialog Neuer Haltepunkt . Wählen Sie die Registerkarte Ausführungspunkt Einstellungen . Aktivieren Sie die Option Ausführungspunkt . Geben Sie im Feld Folgenden Code ausführen folgende Anweisung ein: iCounter := iCounter + 1; Geben Sie im Feld Meldung im Geräte-Log ausgeben folgenden Text ein: Ausführungspunkt erreicht {iCounter} Schließen Sie den Dialog. Wenn das Programm den Ausführungspunkt erreicht, bleibt es nicht stehen, sondern es wird der oben definierte Code ausgeführt. Zusätzlich wird eine Meldung im Geräte-Log ausgegeben. " }, 
{ "title" : "Schrittweises Abarbeiten eines Programms (Stepping) ", 
"url" : "_cds_stepping.html", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Schrittweises Abarbeiten eines Programms (Stepping) ", 
"snippet" : "Sie können eine Applikation Schritt für Schritt ausführen und dabei durch den Code navigieren. Das ist hilfreich, um den Status Ihres Codes zur Laufzeit zu ermitteln. Sie können dabei den Aufrufablauf untersuchen, Variablenwerte verfolgen oder Fehler ermitteln. Dafür stehen Ihnen im Menü Debug Schri...", 
"body" : "Sie können eine Applikation Schritt für Schritt ausführen und dabei durch den Code navigieren. Das ist hilfreich, um den Status Ihres Codes zur Laufzeit zu ermitteln. Sie können dabei den Aufrufablauf untersuchen, Variablenwerte verfolgen oder Fehler ermitteln. Dafür stehen Ihnen im Menü Debug Schrittbefehle zur Verfügung. Die Befehle werden verfügbar, wenn Sie während des Onlinebetriebs Haltepunkte setzen und dann die Ausführung an einem Haltepunkt anhält: Die Applikation ist im Zustand HALT AUF BP (Debugbetrieb). Während des Debugbetriebs wird die aktuelle Halteposition gelb hinterlegt und in den Texteditoren mit dem Symbol gekennzeichnet. In Debugbetrieb wechseln Laden Sie Ihre Applikation auf eine Steuerung. Die Applikation ist grün gekennzeichnet. CODESYS und die Editoren der Programmierbausteine sind im Onlinebetrieb. Setzen Sie in den Programmierbausteinen Haltepunkte an den Stellen im Code, die Sie untersuchen wollen. In der Ansicht Haltepunkte sind alle aufgelistet. Starten Sie die Applikation. Die Applikation startet, der Code wird abgearbeitet bis zum ersten Haltepunkt. Die Applikation ist nun im Debugbetrieb. Im Gerätebaum ist die Applikation mit [Stop an Haltepunkt] gekennzeichnet. Die Statuszeile informiert über den Betriebszustand: Der Editor mit der aktuelle Halteposition wurde geöffnet. Die Codezeile mit aktivem Haltepunkt, an der die Programmausführung angehalten wurde, ist gelb hinterlegt und mit dem Symbol gekennzeichnet. Diese gelb gekennzeichnete Anweisung wurde noch nicht ausgeführt. Nun können Sie die verschiedenen Schrittbefehle wählen oder sich den Aufrufbaum anzeigen lassen. Alternativ können Sie erst die Applikation starten und dann einen Haltepunkt setzen. " }, 
{ "title" : "Verhalten der Schrittbefehle des Menüs Debug ", 
"url" : "_cds_stepping.html#UUID-a130cd52-c46f-0c6f-6bf8-905f62d6add1_id_b4ea395b460596ffc0a8640e000aa41c_id_228de625e3b1eca0c0a864630c398ee9", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Schrittweises Abarbeiten eines Programms (Stepping) \/ Verhalten der Schrittbefehle des Menüs Debug ", 
"snippet" : "Verhalten der Schrittbefehle des Menüs Debug Befehl Prozedurschritt („Step Over“) Die Anweisung an der Halteposition wird ausgeführt. Vor der nächsten Anweisung im Programmierbaustein wird angehalten. Wenn in der Anweisung ein Aufruf ist (von einem Programm, einer Funktionsbaustein-Instanz, einer Fu...", 
"body" : "Verhalten der Schrittbefehle des Menüs Debug Befehl Prozedurschritt („Step Over“) Die Anweisung an der Halteposition wird ausgeführt. Vor der nächsten Anweisung im Programmierbaustein wird angehalten. Wenn in der Anweisung ein Aufruf ist (von einem Programm, einer Funktionsbaustein-Instanz, einer Funktion, einer Methode oder einer Aktion), wird der untergeordnete Programmierbaustein in einem Schritt vollständig durchlaufen. Befehl Einzelschritt („Step Into“) Die Anweisung an der Halteposition wird ausgeführt. Vor der nächsten Anweisung wird angehalten. Wenn in der Anweisung ein Aufruf ist (von einem Programm, einer Funktionsbaustein-Instanz, einer Funktion, einer Methode oder einer Aktion), wird in diesen untergeordneten Programmierbaustein gesprungen. Die erste Anweisung dort wird ausgeführt und vor der nächsten Anweisung wird angehalten. Die neue aktuelle Halteposition ist dann im aufgerufenen Programmierbaustein. Befehl Ausführen bis Rücksprung („Step Out“) Der Befehl führt den Programmierbaustein von der aktuellen Halteposition bis zum Bausteinende aus und springt dann zurück in den aufrufenden Programmierbaustein. An der Aufrufstelle (in der Zeile mit dem Aufruf) wird angehalten. Wenn die aktuelle Halteposition im Hauptprogramm ist, wird der Programmierbaustein bis zum Ende durchlaufen. Dann wird zurück an den Anfang (an den Programmstart an die erste Codezeile im Programmierbaustein) gesprungen und dort angehalten. Befehl Ausführen bis Cursor („Run to Cursor“) Setzen Sie zunächst den Cursor an eine beliebige Codezeile und wählen Sie dann den Befehl. Das Programm wird ab der aktuellen Halteposition ausgeführt und hält an der aktuellen Cursorposition an, ohne den Code dieser Zeile auszuführen. Befehl Nächste Anweisung festlegen („Set Next Statement“) Setzen Sie zunächst den Cursor an eine beliebige Codezeile (auch vor der aktuellen Halteposition) und wählen Sie dann den Befehl. Die mit dem Cursor gekennzeichnete Anweisung wird als nächstes ausgeführt. Alle Anweisungen dazwischen werden ignoriert und übersprungen. Befehl Nächste Anweisung anzeigen („Show Next Statement“) Wenn Sie die aktuelle Halteposition nicht sehen, wählen Sie den Befehl. Dann wird das Fenster mit der aktuellen Halteposition aktiv und die Halteposition sichtbar. Wählen Sie den Befehl Ansicht → Aufrufliste , um für die aktuell in der Programmabarbeitung erreichte Halteposition der bisherige Aufrufbaum vollständig anzuzeigen. Die Ansicht Aufrufliste zeigt jederzeit, also schon vor dem Kompilieren (Übersetzen) der Applikation, wo sich der Baustein in der Aufrufstruktur des Programms befindet. " }, 
{ "title" : "Forcen und Schreiben von Variablen ", 
"url" : "_cds_forcing_values.html", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Forcen und Schreiben von Variablen ", 
"snippet" : "Das außerordentliche Ändern von Variablenwerten in einer auf der Steuerung laufenden Applikation kann zu unerwünschtem Verhalten der gesteuerten Anlage führen. Evaluieren Sie mögliche Gefahren vor einem Forcen von Variablenwerten und treffen Sie entsprechende Sicherheitsvorkehrungen. Abhängig von de...", 
"body" : "Das außerordentliche Ändern von Variablenwerten in einer auf der Steuerung laufenden Applikation kann zu unerwünschtem Verhalten der gesteuerten Anlage führen. Evaluieren Sie mögliche Gefahren vor einem Forcen von Variablenwerten und treffen Sie entsprechende Sicherheitsvorkehrungen. Abhängig von der gesteuerten Anlage könnten Schäden an der Anlage und Werkstücken entstehen oder Gesundheit und Leben von Personen gefährdet sein. Sie können in CODESYS den Wert von Variablen auf der Steuerung im Onlinebetrieb verändern. Dabei wird unterschieden zwischen Forcen und Schreiben eines vorher vorbereiteten Werts. Das Schreiben erfolgt mit dem Befehl Werte schreiben , Strg + F7 und setzt die Variable einmalig auf den vorbereiteten Wert. Der Wert kann somit jederzeit durch das Programm wieder überschrieben werden. Das Forcen erfolgt mit dem Befehl Werte forcen , F7 und setzt den vorbereiteten Wert dauerhaft. Sehen Sie weiter unten für genauere Informationen. Das Vorbereiten eines Wertes für das Forcen oder Schreiben ist an verschiedenen Stellen möglich: Deklarationsteil: Feld Vorbereiteter Wert Implementierungsteil des FUP\/KOP\/AWL-Editors: Inline-Monitoring-Feld Monitoring-Fenster: Feld Vorbereiteter Wert Anleitungen dazu finden Sie weiter unten. Falls Sie einen Wert für eine bereits geforcte Variable neu vorbereiten wollen, öffnet sich dazu den Dialog Wert vorbereiten mit Optionen zum Umgang mit dem aktuellen Force-Wert. " }, 
{ "title" : "Funktionsweise des Forcens ", 
"url" : "_cds_forcing_values.html#UUID-59ed096f-57a2-aabb-ce2b-c94426aecfad_id_f9bd4aae088931a8c0a8640e00cc2de4_id_0e7fdcf008c517edc0a8652001320ebf", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Forcen und Schreiben von Variablen \/ Funktionsweise des Forcens ", 
"snippet" : "Das Setzen des vorbereiteten Werts auf die betreffende Variable erfolgt jeweils am Beginn und Ende eines Taskzyklus (beziehungsweise einer Abarbeitungsschleife im Falle anderer Tasktypen). Die Abarbeitungsfolge in jedem Zyklus einer Task ist wie folgt: Einlesen der Eingänge Forcen: Vor dem ersten Pr...", 
"body" : "Das Setzen des vorbereiteten Werts auf die betreffende Variable erfolgt jeweils am Beginn und Ende eines Taskzyklus (beziehungsweise einer Abarbeitungsschleife im Falle anderer Tasktypen). Die Abarbeitungsfolge in jedem Zyklus einer Task ist wie folgt: Einlesen der Eingänge Forcen: Vor dem ersten Programmaufruf werden alle vorbereiteten Werte vom Laufzeitsystem auf die Variablen geschrieben, egal ob diese von der Task verwendet werden oder nicht. Abarbeitung des IEC-Codes Forcen: Nach dem letzten Programmaufruf werden alle vorbereiteten Werte vom Laufzeitsystem auf die Variablen geschrieben, egal ob diese von der Task verwendet werden oder nicht. Schreiben der Ausgänge Beachten Sie dabei: Es ist möglich, dass eine geforcte Variable während der Codeabarbeitung im Zyklus vorübergehend einen anderen Wert bekommt, weil der IEC-Code eine Zuweisung durchführt. Die Variable erhält dann erst wieder am Ende des Zyklusses den geforcten Wert. Auch durch den Schreibzugriff eines Clients auf Symbole der Applikation kann der Variablenwert mitten im Zyklus überschrieben werden. Sehen Sie für diesen Fall die Option Variablenzugriff synchron zur IEC-Task in den Eigenschaften des Geräteobjekts, beziehungsweise die Einstellung Synchronisierung mit IEC-Tasks konfigurieren in der Symbolkonfiguration. Damit kann eine durch den PLCHandler unterstützte Synchronisierung der Schreibzugriffe durch Clients mit dem Taskzyklus aktiviert werden. Geforcte Werte sind mit dem Symbol gekennzeichnet. CODESYS führt das Forcen durch, bis es explizit durch den Anwender durch eiine der folgenden Aktionen aufgehoben wird: Ausführen des Befehls Forcen für alle Werte aufheben Aufheben des Forces über den Dialog Wert vorbereiten Ausloggen aus der Applikation Wenn beim Ausloggen noch geforcte Variablen vorhanden sind, öffnet sich ein Dialog mit der Abfrage, ob das Forcen für alle Variablen aufgehoben werden soll. Wenn Sie dies mit Nein beantworten, gelten die geforcten Werte beim nächsten Einloggen wieder. " }, 
{ "title" : "Forcen im Deklarationsteil ", 
"url" : "_cds_forcing_values.html#UUID-59ed096f-57a2-aabb-ce2b-c94426aecfad_id_f9bd4aae088931a8c0a8640e00cc2de4_id_bf7e22b408c5163cc0a865200081e4a1", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Forcen und Schreiben von Variablen \/ Forcen im Deklarationsteil ", 
"snippet" : "Voraussetzung: Ihre Applikation enthält einen Baustein mit Deklarationen. Die Applikation befindet sich im Onlinebetrieb. Öffnen Sie den Baustein im Editor mit dem Befehl Projekt → Objekt bearbeiten . Führen Sie im Deklarationsteil des Editors einen Doppelklick in der Spalte (1) Vorbereiteter Wert e...", 
"body" : "Voraussetzung: Ihre Applikation enthält einen Baustein mit Deklarationen. Die Applikation befindet sich im Onlinebetrieb. Öffnen Sie den Baustein im Editor mit dem Befehl Projekt → Objekt bearbeiten . Führen Sie im Deklarationsteil des Editors einen Doppelklick in der Spalte (1) Vorbereiteter Wert einer Variablen aus. Das Feld wird editierbar und Sie können einen Wert eingeben. Wenn es sich um eine boolsche Variable handelt, ändern Sie den Wert mit einem Klick auf das Feld. Führen Sie den Schritt 2 für weitere Variablen aus. Wählen Sie den Befehl Debug → Werte forcen . Die Werte der Variablen werden mit den vorbereiteten Werten überschrieben. Die Werte sind mit dem Symbol gekennzeichnet. Sie können Werte von Variablen auch in der Ansicht Überwachen forcen. " }, 
{ "title" : "Forcen im Implementierungsteil ", 
"url" : "_cds_forcing_values.html#UUID-59ed096f-57a2-aabb-ce2b-c94426aecfad_id_f9bd4aae088931a8c0a8640e00cc2de4_id_2f736e9005a0d09ec0a8640e0030151c", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Forcen und Schreiben von Variablen \/ Forcen im Implementierungsteil ", 
"snippet" : "Voraussetzung: Die Applikation befindet sich im Onlinebetrieb. Öffnen Sie den Baustein im Editor mit dem Befehl Projekt → Objekt bearbeiten . Führen Sie im Implementierungsteil des Editors einen Doppelklick auf ein Inline-Monitoring-Feld (1). Es öffnet sich der Dialog Werte vorbereiten . Geben Sie i...", 
"body" : "Voraussetzung: Die Applikation befindet sich im Onlinebetrieb. Öffnen Sie den Baustein im Editor mit dem Befehl Projekt → Objekt bearbeiten . Führen Sie im Implementierungsteil des Editors einen Doppelklick auf ein Inline-Monitoring-Feld (1). Es öffnet sich der Dialog Werte vorbereiten . Geben Sie im Feld Einen neuen Wert für die nächste Schreib- oder Force-Operation vorbereiten den neuen Wert ein. Der vorbereitete Wert erscheint im Inline-Monitoring-Feld. Wählen Sie den Befehl Debug → Werte forcen . Der Wert der Variablen wird mit den vorbereiteten Werten überschrieben. Die Werte sind mit dem Symbol gekennzeichnet. " }, 
{ "title" : "Alle geforcten Variablen in einer Liste sehen und bearbeiten ", 
"url" : "_cds_forcing_values.html#UUID-59ed096f-57a2-aabb-ce2b-c94426aecfad_id_f9bd4aae088931a8c0a8640e00cc2de4_id_0cd4e3c8f807c8cbc0a8646346df5261", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Forcen und Schreiben von Variablen \/ Alle geforcten Variablen in einer Liste sehen und bearbeiten ", 
"snippet" : "Voraussetzung: Die Applikation befindet sich im Onlinebetrieb. Mehrere Variablen sind im geforcten Zustand. Wählen Sie Befehl Ansicht → Überwachen → Alle Forces anzeigen . Die Ansicht Alle Forces anzeigen erscheint. Sie enthält in der Form einer Überwachen-Liste alle aktuell geforcten Variablen der ...", 
"body" : "Voraussetzung: Die Applikation befindet sich im Onlinebetrieb. Mehrere Variablen sind im geforcten Zustand. Wählen Sie Befehl Ansicht → Überwachen → Alle Forces anzeigen . Die Ansicht Alle Forces anzeigen erscheint. Sie enthält in der Form einer Überwachen-Liste alle aktuell geforcten Variablen der Applikation. Selektieren Sie alle Zeilen der Liste und wählen Sie in der Auswahlliste links oben in der Ansicht Force aufheben → Forcen aufheben und alle ausgewählten Werte beibehalten . Das Forcen für die Variablen wird aufgehoben, sie erhalten die Werte, die sie vor dem Forcen hatten. " }, 
{ "title" : "Forcen eines Funktionsbausteineingangs im CFC ", 
"url" : "_cds_forcing_values.html#UUID-59ed096f-57a2-aabb-ce2b-c94426aecfad_id_f9bd4aae088931a8c0a8640e00cc2de4_id_94214d0432e61124c0a8640e01320552", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Forcen und Schreiben von Variablen \/ Forcen eines Funktionsbausteineingangs im CFC ", 
"snippet" : "Voraussetzung: Eine Applikation mit einem CFC-Programmbaustein, der wiederum einen Funktionsbaustein enthält, befindet sich im Offlinebetrieb. Diese Art des Forcens verwendet intern einen Datenhaltepunkt und ist damit vom Forcen über den Befehl Werte forcen bzw. F7 zu unterscheiden! Werte, die über ...", 
"body" : "Voraussetzung: Eine Applikation mit einem CFC-Programmbaustein, der wiederum einen Funktionsbaustein enthält, befindet sich im Offlinebetrieb. Diese Art des Forcens verwendet intern einen Datenhaltepunkt und ist damit vom Forcen über den Befehl Werte forcen bzw. F7 zu unterscheiden! Werte, die über den Befehl FB-Eingang forcen geforct wurden, reagieren nicht auf die Befehle Alle Forces anzeigen oder Forcen für alle Werte aufheben . Öffnen Sie den Editor des CFC-Programmbausteins mit einem Doppelklick auf das Objekt im Baum. Loggen Sie mit der Applikation auf dem Zielgerät ein. Wenn Sie Compilerversion 3.5.11.x oder 3.5.12.x verwenden: Aktivieren Sie für den gewünschten Funktionsbaustein die „Forcebarkeit“. Dazu selektieren Sie das Bausteinelement im CFC und wählen den Befehl CFC → Bausteinelement für Forcen vorbereiten . Selektieren Sie im CFC den Eingang des Funktionsbausteins und wählen Sie im Kontextmenü den Befehl FB-Eingang forcen . Der Dialog Wert forcen erscheint. Setzen Sie einen neuen Wert für den Eingang. Beispiel im Fall eines TON -Bausteins: FALSE für den boolschen Eingang IN , oder t#4s für den Eingang PT (TIME). Bestätigen Sie mit OK . Der gesetzte Wert wird sofort geforct. Das Bausteinelement erhält oben links einen grünen Kreis und der Name des Eingangs innerhalb des Elements wird grün hinterlegt. Bei einem boolschen Wert erscheint am Eingang außerdem ein kleines Monitoringfenster mit der Angabe des Werts. In Monitoringansichten wie beispielsweise im Deklarationsteil erscheint der geforcte Wert in Spalte Wert . Um den geforcten Wert wieder zu entfernen, wählen Sie erneut den Befehl FB-Eingang forcen . Im Dialog Wert forcen wählen Sie nun die Option Wert entfernen . Das Forcen wird zurückgenommen. Der Eingang erhält wieder den aktuellen Wert von der Steuerung. Für weitere Informationen siehe: Werte forcen und Werte schreiben" }, 
{ "title" : "Reset der Applikation durchführen ", 
"url" : "_cds_reset_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Reset der Applikation durchführen ", 
"snippet" : "Ein Reset der Applikation stoppt das Programm und setzt die Variablen auf ihren Initialisierungswert zurück. Abhängig von der Art des Resets werden auch Retain-Variablen und Persistent-Variablen zurückgesetzt. Reset warm: Alle Variablen außer RETAIN - und PERSISTENT -Variablen werden zurückgesetzt. ...", 
"body" : "Ein Reset der Applikation stoppt das Programm und setzt die Variablen auf ihren Initialisierungswert zurück. Abhängig von der Art des Resets werden auch Retain-Variablen und Persistent-Variablen zurückgesetzt. Reset warm: Alle Variablen außer RETAIN - und PERSISTENT -Variablen werden zurückgesetzt. Reset kalt: Alle Variablen außer PERSISTENT -Variablen werden zurückgesetzt. Reset Ursprung: Alle Variablen werden zurückgesetzt. Reset Ursprung Gerät: Alle Variablen werden zurückgesetzt, alle Applikationen werden gelöscht. Das kleine Beispielprogramm und die nachfolgende Handlungsanweisungen verdeutlichen Ihnen das Verhalten der verschiedenen Resets. Beispielprogramm Deklaration VAR\n iVar: INT := 0;\nEND_VAR\nVAR RETAIN\n iVarRetain: INT :=0;\nEND_VAR\nVAR PERSISTENT\n iVarPersistent : INT:= 0;\nEND_VAR Implementierung iVar := 100;\niVarRetain := 200;\niVarPersistent :=300; Fügen Sie das Objekt Persistente Variablen unterhalb der Applikation ein und öffnen Sie es im Editor. Führen Sie den Befehl Erstellen → Übersetzen aus. Führen Sie den Befehl Deklaration → Alle Instanzpfade hinzufügen aus. Der Instanzpfad der persistenten Variablen wird hinzugefügt. Laden Sie die Applikation auf die Steuerung. Ausführen eines Reset warm, Reset kalt und Reset Ursprung Voraussetzung: Das Beispielprogramm läuft auf der Steuerung. Wählen Sie den Befehl Online → Einloggen , um in den Onlinebetrieb zu wechseln. Beobachten Sie die Variablen iVar , iVarRetain und iVarPersistent . Wählen Sie den Befehl Reset warm des Menüs Online . Es erscheint eine Abfrage, ob Sie den Befehl wirklich durchführen wollen. Bestätigen Sie den Dialog mit Ja . Die Applikation ist zurückgesetzt. Die Variable iVar wird auf den Initialisierungswert 0 gesetzt. Die beiden anderen Variablen behalten ihren Wert. Wählen Sie den Befehl Reset Kalt des Menüs Online . Es erscheint eine Abfrage, ob Sie den Befehl wirklich durchführen wollen. Bestätigen Sie den Dialog mit Ja . Die Applikation ist zurückgesetzt. Die Variable iVar und iVarRetain werden auf den Initialisierungswert 0 gesetzt. Die Variablen iVarPersistent behält ihren Wert. Wählen Sie den Befehl Reset Ursprung des Menüs Online . Es erscheint eine Abfrage, ob Sie den Befehl wirklich durchführen wollen. Bestätigen Sie den Dialog mit Ja . Die Applikation ist zurückgesetzt. Alle Variablen werden auf ihren Initialisierungswert gesetzt. " }, 
{ "title" : "Ablaufkontrolle ", 
"url" : "_cds_flowcontrol.html", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Ablaufkontrolle ", 
"snippet" : "Mit der Ablaufkontrolle können Sie die Abarbeitung des Applikationsprogramms verfolgen. Die Ablaufkontrolle ist für die Spracheditoren ST, FUP, KOP und CFC verfügbar. Mit aktivierter Ablaufkontrolle stellt CODESYS die Werte von Variablen die Ergebnisse von Funktionsaufrufen und Operationen an der je...", 
"body" : "Mit der Ablaufkontrolle können Sie die Abarbeitung des Applikationsprogramms verfolgen. Die Ablaufkontrolle ist für die Spracheditoren ST, FUP, KOP und CFC verfügbar. Mit aktivierter Ablaufkontrolle stellt CODESYS die Werte von Variablen die Ergebnisse von Funktionsaufrufen und Operationen an der jeweiligen Abarbeitungsposition und zum jeweiligen Abarbeitungszeitpunkt dar. Dabei werden exakt diejenigen Codezeilen bzw. Netzwerke farblich markiert, die im aktuellen Zyklus durchlaufen werden. Zum Vergleich: Beim Standard-Monitioring liefert CODESYS nur den Wert, den eine Variable zwischen zwei Abarbeitungszyklen hat. Die Ablaufkontrolle arbeitet in allen gerade sichtbaren Teilen der gerade geöffneten Edtiorfenster. Dabei wird Ablaufkontrolle aktiviert in der Statuszeile angezeigt, solange die Funktion aktiv ist und in einem Editorfenster Ablaufkontrollpositionen (durchlaufene Teile des Codes) sichtbar sind. Sie können Werte im Deklarationsteil und im Implementierungsteil schreiben, ein Forcen ist nicht möglich. Das Schreiben der Werte erfolgt am Ende des aktuellen Zyklus. Wenn Sie die Ablaufkontrolle aktivieren, verlängert sich die Laufzeit der Applikation! Wenn Sie die Option Bestätigter Onlinebetrieb in den Kommunikationseinstellungen aktivieren, erscheint beim Einschalten der Ablaufkontrolle eine Meldungsbox, über die Sie den Vorgang noch abbrechen können. Das Verwenden von Haltepunkten und die schrittweise Abarbeitung des Programms sind bei aktivierter Ablaufkontrolle nicht möglich. Darstellung der Ablaufkontrolle in den verschiedenen Spracheditoren: Standardmäßig stellt CODESYS die Ablaufkontrollposition der durchlaufenen Codeteile als grüne Felder dar. Nichtdurchlaufene Codeteile werden weiß dargestellt. Beachten Sie, dass der angezeigte Wert einer nicht-durchlaufenen Codeposition ein „normaler“ Monitoringwert ist. Dies ist der Wert, der zwischen zwei Task-Zyklen vorliegt. In Netzwerkeditoren markiert CODESYS die durchlaufenen Netzwerke am linken Rand durch Balken in der ‚Ablaufkontrollfarbe‘. Im KOP stellt CODESYS die aktuell durchlaufenen Verbindungslinien in grün dar, die anderen in grau. Der Istwert der Verbindung wird ebenfalls dargestellt: TRUE durch fette blaue, FALSE durch fette schwarze Linien, unbekannte oder analoge Werte durch dünne schwarze Linien. Das kann durch Kombination der jeweiligen Informationen zu gestrichelten Linien führen. In AWL verwendet CODESYS für jede Anweisung zwei Felder für die Anzeige der Istwerte. Eins links des Operators mit dem aktuellen Akkumulator-Wert, eins rechts des Operanden mit dem Operandenwert. " }, 
{ "title" : "Aktuelle Abarbeitungsposition mit der Aufrufliste bestimmen ", 
"url" : "_cds_call_stack.html", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Aktuelle Abarbeitungsposition mit der Aufrufliste bestimmen ", 
"snippet" : "Mit Hilfe der Aufrufliste können Sie die aktuelle Position der Programmabarbeitung bestimmen. Diese Funktion ist bei der schrittweisen Abarbeitung des Programms sehr nützlich. Voraussetzung: Die Applikation ist im Onlinebetrieb. Das Programm steht an einem Haltepunkt oder Sie führen es schrittweise ...", 
"body" : "Mit Hilfe der Aufrufliste können Sie die aktuelle Position der Programmabarbeitung bestimmen. Diese Funktion ist bei der schrittweisen Abarbeitung des Programms sehr nützlich. Voraussetzung: Die Applikation ist im Onlinebetrieb. Das Programm steht an einem Haltepunkt oder Sie führen es schrittweise aus. Öffnen Sie die Aufrufliste mit dem Befehl Ansicht → Aufrufliste . Die Aufrufliste wird geöffnet. Die Liste zeigt die aktuell erreichte Position mit vollständigem Aufrufpfad. Die Aufrufliste ist auch im Offlinebetrieb verfügbar oder im normalen Onlinebetrieb (ohne gerade die Debugging-Funktionen zu benützen). In diesem Fall enthält sie die zuletzt während einer schrittweisen Ausführung angezeigte Position, allerdings in „gegrauter“ Schrift. " }, 
{ "title" : "Taskaufstellung überprüfen ", 
"url" : "_cds_check_task_deployment.html", 
"breadcrumbs" : "CODESYS Essentials \/ Testen und Fehler beheben \/ Taskaufstellung überprüfen ", 
"snippet" : "Die Registerkarte Taskaufstellung des Geräteeditors zeigt in einer Übersicht, welche Tasks mit welcher Priorität die einzelnen Eingänge und Ausgänge des E\/A-Abbilds Ihrer Applikation bearbeiten. Sie können hier überprüfen, ob nicht ein unbeabsichtigtes Überschreiben von Werten entsteht, was zu undef...", 
"body" : "Die Registerkarte Taskaufstellung des Geräteeditors zeigt in einer Übersicht, welche Tasks mit welcher Priorität die einzelnen Eingänge und Ausgänge des E\/A-Abbilds Ihrer Applikation bearbeiten. Sie können hier überprüfen, ob nicht ein unbeabsichtigtes Überschreiben von Werten entsteht, was zu undefinierten Werten führen kann. Erzeugen Sie für die Applikation Code: Wählen Sie dazu beispielsweise den Befehl Erstellen → Code erzeugen . Öffnen Sie mit einem Doppelklick auf das Geräteobjekt im Gerätebaum den Geräteeditor. Wählen sie die Registerkarte Taskaufstellung . Sie erhalten eine Darstellung der Eingänge und Ausgänge Ihrer Applikation und die Zuordnung der Tasks und deren Prioritäten. Sehen Sie für Details die Beschreibung der Registerkarte Taskaufstellung . " }, 
{ "title" : "Applikation zur Laufzeit ", 
"url" : "_cds_struct_application_in_operation.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit ", 
"snippet" : "Wenn die Applikation auf der SPS läuft, gibt es im CODESYS -Entwicklungssystem Funktionalitäten zum Überwachen und Ändern der Variablenwerte, sowie zum Aufzeichnen und Speichern ihres Verlaufs. Auch gibt es Möglichkeiten, gewisse Informationen aus der SPS abzurufen, das SPS-Logbuch einzusehen, einen...", 
"body" : "Wenn die Applikation auf der SPS läuft, gibt es im CODESYS -Entwicklungssystem Funktionalitäten zum Überwachen und Ändern der Variablenwerte, sowie zum Aufzeichnen und Speichern ihres Verlaufs. Auch gibt es Möglichkeiten, gewisse Informationen aus der SPS abzurufen, das SPS-Logbuch einzusehen, einen Coredump anzuzeigen, und das Zeitverhalten der Tasks zu beobachten. Beachten Sie auch die Möglichkeit, den Zugriff auf die laufende Applikation über Online-Befehle aus dem Entwicklungssystem in kritischen Zuständen der Maschine einzuschränken. Dazu stehen über einen Baustein der Bibliothek ComponentManager bestimmte Systemvariablen zur Verfügung. " }, 
{ "title" : "Monitoring von Werten ", 
"url" : "_cds_f_monitoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Monitoring von Werten ", 
"snippet" : "Sie können zur Laufzeit die aktuellen Werte von Variablen eines Programmierobjekts an verschiedenen Stellen im Projekt beobachten. Wir nennen dies „Monitoring“. Online-Ansicht des Programmiereditor eines Objekts: „Inline-Monitoring“ Online-Ansicht des Deklarationseditors eines Objekts Objektunabhäng...", 
"body" : "Sie können zur Laufzeit die aktuellen Werte von Variablen eines Programmierobjekts an verschiedenen Stellen im Projekt beobachten. Wir nennen dies „Monitoring“. Online-Ansicht des Programmiereditor eines Objekts: „Inline-Monitoring“ Online-Ansicht des Deklarationseditors eines Objekts Objektunabhängige, konfigurierbare Überwachungslisten Sie können die Ergebnisse von Funktionsaufrufen und die aktuellen Werte von Variablen in Objekten des Typs Eigenschaft (Property) monitoren, wenn Sie das Pragma {attribute 'monitoring'…} einsetzen. Zusätzliche Möglichkeiten, die aktuellen Variablenwerte zu erfassen: Lesen und Speichern von Rezepturen Aufzeichnen der Werte über eine Zeitachse, um unmittelbar oder später den Verlauf darzustellen: Trace- und Trend " }, 
{ "title" : "Monitoring in Programmierobjekten aufrufen ", 
"url" : "_cds_using_monitoring_in_pous.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Monitoring von Werten \/ Monitoring in Programmierobjekten aufrufen ", 
"snippet" : "Wenn auf der Steuerung eine Applikation läuft, werden in den Editoren der Programmierbausteine bei Variablen die Istwerte angezeigt. Somit können Sie die Variablenwerte überwachen. Voraussetzung: In Tools → Optionen unter der Kategorie Texteditor in der Registerkarte Monitoring ist die Option Inline...", 
"body" : "Wenn auf der Steuerung eine Applikation läuft, werden in den Editoren der Programmierbausteine bei Variablen die Istwerte angezeigt. Somit können Sie die Variablenwerte überwachen. Voraussetzung: In Tools → Optionen unter der Kategorie Texteditor in der Registerkarte Monitoring ist die Option Inline-Monitoring aktivieren aktiviert. Laden Sie eine Applikation auf die Steuerung und starten Sie die Applikation. Wählen Sie den Befehl Debug → Darstellung → Dezimal . Das Darstellungsformat der Istwerte ist eingestellt. Klicken Sie auf ein Programmierobjekt der Ansicht Geräte oder POUs . Der zugehörige Editor öffnet sich. Sowohl in der Deklaration als auch in der Implementierung werden Istwerte der Variablen ständig aktualisiert. Rückgabewert eines Funktionsaufrufs monitoren Im ST-Editor einer POU wird an der Stelle, an der eine Funktion aufgerufen wird, der aktuelle Rückgabewert als Inline-Monitoring angezeigt. Dafür muss Folgendes erfüllt sein: Es handelt sich um einen Wert, der als 4-Byte-numerischer Wert interpretiert werden kann. Beispielsweise INT , SINT oder LINT . In der Funktion ist das Pragma {attribute 'monitoring' := 'call'} eingefügt. " }, 
{ "title" : "Im Deklarationseditor monitoren ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_da1e73000e6d11e49893a65c94288ced", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Monitoring von Werten \/ Monitoring in Programmierobjekten aufrufen \/ Im Deklarationseditor monitoren ", 
"snippet" : "Der Istwert eines Ausdrucks (1) wird in der Spalte Wert (3) angezeigt. In der Spalte Kommentar (6) werden die Kommentare zu einer Variablen an. Für weitere Informationen zu Logik und Priorisierung der angezeigten Kommentare siehe: ST-KommentareSie können einen in der Spalte Vorbereiteter Wert (4) ei...", 
"body" : "Der Istwert eines Ausdrucks (1) wird in der Spalte Wert (3) angezeigt. In der Spalte Kommentar (6) werden die Kommentare zu einer Variablen an. Für weitere Informationen zu Logik und Priorisierung der angezeigten Kommentare siehe: ST-KommentareSie können einen in der Spalte Vorbereiteter Wert (4) eingetragenen Wert schreiben und forcen. Während des Forcen wird der Istwert mit dem roten Symbol dekoriert. Der Ausdruck einer Schnittstellenreferenz ist aufklappbar. Wenn die Schnittstelle auf eine globale Instanz zeigt, wird diese globale Instanz als erster Eintrag unter der Referenz angezeigt. Wenn sich danach die Schnittstellenreferenz ändert, klappt die angezeigte Referenz zu. " }, 
{ "title" : "In der Implementierung monitoren (Inline-Monitoring) ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_cf62c2c62f969db9c0a8646339d800c9", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Monitoring von Werten \/ Monitoring in Programmierobjekten aufrufen \/ In der Implementierung monitoren (Inline-Monitoring) ", 
"snippet" : "Die Darstellung des aktuellen Variablenwerts in der Implementierung wird als Inline-Monitoring bezeichnet. Abhängig von der Programmiersprache gibt es folgende Darstellungen im Implementierungsteil: Variablen haben hinter ihrem Namen ein Fenster mit dem aktuellen Wert eingeblendet. Wenn Sie für Vari...", 
"body" : "Die Darstellung des aktuellen Variablenwerts in der Implementierung wird als Inline-Monitoring bezeichnet. Abhängig von der Programmiersprache gibt es folgende Darstellungen im Implementierungsteil: Variablen haben hinter ihrem Namen ein Fenster mit dem aktuellen Wert eingeblendet. Wenn Sie für Variablen Werte zum Forcen oder Schreiben vorbereitet haben, werden diese innerhalb des Inline-Monitoring-Fensters hinter dem aktuellen Wert in spitzen Klammern dargestellt. Nach dem Forcen werden die betroffenen Werte mit dem Symbol gekennzeichnet. Netzwerkeditoren und im CFC-Editor Verbindungslinien (Signalleitungen) sind entsprechend ihrem booleschen Istwert farblich gekennzeichnet: blau bedeutet TRUE , schwarz bedeutet FALSE . KOP-Editor Zusätzlich sind die Kontakt- und Spulenelemente gekennzeichnet. Bei Kontakten oder Spulen wird ein vorbereiteter Wert ( TRUE oder FALSE ) in einem kleinen Fenster neben dem Element angezeigt. AS-Editor Transitionen mit Wert TRUE sind entsprechend ihrem booleschen Istwert farblich gekennzeichnet: blau bedeutet TRUE , schwarz bedeutet FALSE . Aktive Schritte sind blau gekennzeichnet. In der Implementierung sind geforcte Transitionswerte rot gekennzeichnet. AWL-Tabelleneditor Aktuelle Werte werden in einer eigener Spalte dargestellt. Monitoring im ST-Editor Monitoring im KOP-Editor Monitoring im AS-Editor Sie können die Inline-Monitoring-Funktion hier deaktivieren: Tools → Optionen , Kategorie Texteditor , Registerkarte Monitoring . " }, 
{ "title" : "Array teilweise monitoren ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_17c4ba57134411e497a3a811bc4d899a", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Monitoring von Werten \/ Monitoring in Programmierobjekten aufrufen \/ Array teilweise monitoren ", 
"snippet" : "Ein Array, das aufgeklappt ist, zeigt bei bis zu 1000 Elementen die Istwerte an. Das kann allerdings unübersichtlich sein. Außerdem kann ein Array mehr als 1000 Elemente umfassen. Dann ist es hilfreich, den Bereich der angezeigten Elemente zu begrenzen. Das können Sie während des Onlinebetriebs auf ...", 
"body" : "Ein Array, das aufgeklappt ist, zeigt bei bis zu 1000 Elementen die Istwerte an. Das kann allerdings unübersichtlich sein. Außerdem kann ein Array mehr als 1000 Elemente umfassen. Dann ist es hilfreich, den Bereich der angezeigten Elemente zu begrenzen. Das können Sie während des Onlinebetriebs auf folgende Weise tun. Monitoringbereich begrenzen Voraussetzung: Eine Applikation läuft. Darin ist eine mehrdimensionale Arrayvariable mit mehr als 1000 Elementen deklariert. Beispiel: arrBig : ARRAY [0..100, -9..10, -19..20] OF INT; Klicken Sie bei der Variablen arrBig in das Feld der Spalte Datentyp . Der Dialog Monitoringbereich öffnet sich. Geben Sie bei Start den Wert [1, -9, -19] ein. Geben Sie bei Ende den Wert [1, 10, 20] ein. Die Istwerte von 800 Arrayelemente werden im Deklarationseditor angezeigt. Der Bereich ist begrenzt auf Elemente des Index [1, <i>, <j>] mit i von -9 bis 10 und j von -19 bis 20. " }, 
{ "title" : "Funktionsbaustein monitoren ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_cc4f35463a9211e9a9a6d1f408c21742", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Monitoring von Werten \/ Monitoring in Programmierobjekten aufrufen \/ Funktionsbaustein monitoren ", 
"snippet" : "Wenn Sie während des Onlinebetriebs die Editoransicht eines Funktionsbausteins doppelklicken, erscheint ein Dialog, in dem Sie zwischen der Ansicht der Basisimplementierung oder einer bestimmten Instanz wählen können. Wenn Sie die Basisimplementierung wählen, dann erscheint im Editor der Code, ohne ...", 
"body" : "Wenn Sie während des Onlinebetriebs die Editoransicht eines Funktionsbausteins doppelklicken, erscheint ein Dialog, in dem Sie zwischen der Ansicht der Basisimplementierung oder einer bestimmten Instanz wählen können. Wenn Sie die Basisimplementierung wählen, dann erscheint im Editor der Code, ohne dass aktuelle Werte angezeigt werden. Setzen Sie nun in der Basisimplementierung einen Haltepunkt. Wenn die Ausführung dort anhält, werden die aktuellen Werte derjenigen Instanz angezeigt, die im Programmablauf zuerst abgearbeitet wird. Sie können nun sukzessive durch alle Instanzen steppen. Wenn Sie eine der Instanzen wahlen, dann öffnet der Editor mit dem Code der Funktionsbaustein-Instanz. Die aktuellen Werte werden in der Deklaration und gegebenenfalls in der Implementierung angezeigt und ständig aktualisiert. " }, 
{ "title" : "Eigenschaft monitoren ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_089ce320132311e497a3a811bc4d899a", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Monitoring von Werten \/ Monitoring in Programmierobjekten aufrufen \/ Eigenschaft monitoren ", 
"snippet" : "Sie können in einem Eigenschaftenobjekt Variablen monitoren, wenn Sie während des Onlinebetriebs einen Haltepunkt in der Funktion setzen. Wenn dort angehalten wird, werden die aktuellen Werte angezeigt. Zusätzlich zu den eigenen Werten werden automatisch die Werte der Variablen der übergeordneten In...", 
"body" : "Sie können in einem Eigenschaftenobjekt Variablen monitoren, wenn Sie während des Onlinebetriebs einen Haltepunkt in der Funktion setzen. Wenn dort angehalten wird, werden die aktuellen Werte angezeigt. Zusätzlich zu den eigenen Werten werden automatisch die Werte der Variablen der übergeordneten Instanz angezeigt. Im Deklarationsteil der Eigenschaft erscheint nämlich in der ersten Zeile der Pointer THIS , der auf die übergeordnete Instanz zeigt, mit den aktuellen Datentypangaben und Werten. Beispiel Code FUNCTION_BLOCK FB_BaseAlfa\nVAR\n iBaseLocal : INT;\n sBaseLocal : STRING;\nEND_VAR\niBaseLocal := iBaseLocal + 1;\nsBaseLocal := 'Testing Text';\n\nFB_BaseAlfa.PorpBeta.Get\niBaseLocal := iBaseLocal + 1;\nIF iBaseLocal > 0 THEN\n PropBeta := TRUE;\nEND_IF\n\nFB_BaseAlfa.PorpBeta.Set\nIF PropBeta = TRUE THEN\n iBaseLocal := 0;\n sBaseLocal := 'Tested IF';\nEND_IF\n\n\nPROGRAM PLC_PRG\nVAR\n fb_BaseAlfa : FB_BaseAlfa;\nEND_VAR\n\nfb_BaseAlfa();\n\nIF fb_BaseAlfa.PropBeta = TRUE THEN\n xResult := TRUE;\nEND_IF\nIF xReset THEN\n fb_BaseAlfa.PropBeta := TRUE;\n xReset := FALSE;\nEND_IF " }, 
{ "title" : "Eigenschaftenzugriff im übergeordneten Programmierobjekt monitoren ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_4c0f3a123aa211e9a9a6d1f408c21742", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Monitoring von Werten \/ Monitoring in Programmierobjekten aufrufen \/ Eigenschaftenzugriff im übergeordneten Programmierobjekt monitoren ", 
"snippet" : "Sie können in einem Funktionsbaustein oder Programm zusätzlich zu den Variablenwerten die Werte von untergeordneten Eigenschaften monitoren. Fügen Sie dafür in dem untergeordneten Eigenschaftenobjekt in der Deklaration entweder das Pragma {attribute 'monitoring' = 'variable'} oder das Pragma {attrib...", 
"body" : "Sie können in einem Funktionsbaustein oder Programm zusätzlich zu den Variablenwerten die Werte von untergeordneten Eigenschaften monitoren. Fügen Sie dafür in dem untergeordneten Eigenschaftenobjekt in der Deklaration entweder das Pragma {attribute 'monitoring' = 'variable'} oder das Pragma {attribute 'monitoring' = 'call'} ein. Wenn Sie zur Laufzeit die übergeordnete Programminstanz oder übergeordnete Funktionsbaustein-Instanz öffnen, dann werden im Editor zusätzlich zu den aktuellen Variablenwerte die aktuellen Eigenschaftenwerte angezeigt. " }, 
{ "title" : "Methode monitoren ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_86a261815e598a34c0a8640e0001140c", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Monitoring von Werten \/ Monitoring in Programmierobjekten aufrufen \/ Methode monitoren ", 
"snippet" : "Sie können in einem Methodenobjekt Variablen monitoren, wenn Sie während des Onlinebetriebs einen Haltepunkt in der Methode setzen. Wenn dort angehalten wird, werden die aktuellen Werte angezeigt. Zusätzlich zu den eigenen Werten werden automatisch die Werte der Variablen der übergeordneten Instanz ...", 
"body" : "Sie können in einem Methodenobjekt Variablen monitoren, wenn Sie während des Onlinebetriebs einen Haltepunkt in der Methode setzen. Wenn dort angehalten wird, werden die aktuellen Werte angezeigt. Zusätzlich zu den eigenen Werten werden automatisch die Werte der Variablen der übergeordneten Instanz angezeigt. Im Deklarationsteil der Methode erscheint nämlich in der ersten Zeile der Pointer THIS , der auf die übergeordnete Instanz zeigt, mit den aktuellen Datentypangaben und Werten. Beispiel Code FUNCTION_BLOCK FB_BaseAlfa\nVAR\n iBaseLocal : INT;\n sBaseLocal : STRING;\nEND_VAR\niBaseLocal := iBaseLocal + 1;\nsBaseLocal := 'Testing Text';\n\nMETHOD MethBaseAlfa : BOOL \/\/ Method of FB_BaseAlfa\nVAR_INPUT\nEND_VAR\nVAR\n iMethLocal : INT;\nEND_VAR\niMethLocal := iMethLocal + 1;\n\n\nPROGRAM PLC_PRG\nVAR\n fb_BaseAlfa : FB_BaseAlfa;\nEND_VAR\nfb_BaseAlfa();\nfb_BaseAlfa.MethBaseAlfa(); " }, 
{ "title" : "Funktion monitoren ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_ae89ec4d3f3d11e9beb58b29d367590b", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Monitoring von Werten \/ Monitoring in Programmierobjekten aufrufen \/ Funktion monitoren ", 
"snippet" : "Sie können in einem Funktionsobjekt Variablen monitoren, wenn Sie während des Onlinebetriebs einen Haltepunkt in der Funktion setzen. Wenn dort angehalten wird, werden die aktuellen Werte angezeigt....", 
"body" : "Sie können in einem Funktionsobjekt Variablen monitoren, wenn Sie während des Onlinebetriebs einen Haltepunkt in der Funktion setzen. Wenn dort angehalten wird, werden die aktuellen Werte angezeigt. " }, 
{ "title" : "Überwachungslisten verwenden ", 
"url" : "_cds_using_watchlists.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Monitoring von Werten \/ Überwachungslisten verwenden ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Was ist eine Überwachungsliste? ", 
"url" : "_cds_using_watchlists.html#UUID-aa48d044-1dcc-85b4-3abf-5972dd8036a1_id_a81a96006e9d8726c0a8640e01e78912_id_952107db6cf010acc0a8640e01262d4f", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Monitoring von Werten \/ Überwachungslisten verwenden \/ Was ist eine Überwachungsliste? ", 
"snippet" : "Eine Überwachungsliste ist eine benutzerdefinierte Liste von Projektvariablen, die zum Zweck des Monitorings ihrer Werte in einer Ansicht zusammengefasst werden. Im Onlinebetrieb können Sie in einer Überwachungsliste Variablenwerte schreiben und forcen. Monitoring, Schreiben und Forcen sind wie im O...", 
"body" : "Eine Überwachungsliste ist eine benutzerdefinierte Liste von Projektvariablen, die zum Zweck des Monitorings ihrer Werte in einer Ansicht zusammengefasst werden. Im Onlinebetrieb können Sie in einer Überwachungsliste Variablenwerte schreiben und forcen. Monitoring, Schreiben und Forcen sind wie im Onlinebetrieb des Deklarationseditors zu handhaben. Sie können das Format der Darstellung von Gleitpunktwerten in den Optionen für Monitoring anpassen. In einem Projekt stehen vier Überwachungslisten Überwachen <n> im Menü Ansicht → Überwachen zur Befüllung bereit. Wenn der Ausdruck eine Schnittstellenreferenz ist, ist sie aufklappbar. In dem Fall, dass die Schnittstelle auf eine globale Instanz zeigt, wird als erster Eintrag unter der Referenz diese globale Instanz angezeigt. Wenn sich die Schnittstellenreferenz ändert, wird die angezeigte Referenz zugeklappt. " }, 
{ "title" : "Anlegen und Bearbeiten einer Überwachungsliste (Offline- oder Onlinebetrieb) ", 
"url" : "_cds_using_watchlists.html#UUID-aa48d044-1dcc-85b4-3abf-5972dd8036a1_id_a81a96006e9d8726c0a8640e01e78912_id_706184106cf010aec0a8640e01576f72", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Monitoring von Werten \/ Überwachungslisten verwenden \/ Anlegen und Bearbeiten einer Überwachungsliste (Offline- oder Onlinebetrieb) ", 
"snippet" : "Voraussetzung: Ein Projekt ist im Offline- oder Onlinebetrieb geöffnet. Es enthält eine Applikation, in der Variablen deklariert sind, die Sie in einer der vier möglichen Überwachungslisten haben möchten. Wählen sie den Befehl Ansicht → Überwachen → Überwachen <n> . Die Ansicht Überwachen <n> ersche...", 
"body" : "Voraussetzung: Ein Projekt ist im Offline- oder Onlinebetrieb geöffnet. Es enthält eine Applikation, in der Variablen deklariert sind, die Sie in einer der vier möglichen Überwachungslisten haben möchten. Wählen sie den Befehl Ansicht → Überwachen → Überwachen <n> . Die Ansicht Überwachen <n> erscheint. Sie enthält eine leere Tabellenzeile. Geben Sie nach einem Doppelklick auf das Feld in Spalte Ausdruck eine zu überwachende Variable ein, händisch oder über die Eingabehilfe. Syntax: <Gerätename>.<Applikationsname>.<Objektname>.<Variablenname> Beispiel: „ Dev1.App1.PLC_PRG.ivar \" Wenn Sie den Namen einer strukturierten Variablen eintragen, werden im Onlinebetrieb die einzelnen Komponenten automatisch in weiteren Zeilen angezeigt. Definieren Sie nacheinander alle mit dieser Liste zu überwachenden Variablen. Die Reihenfolge können Sie mit Drag&Drop verändern. Die Felder Ausführungszeitpunkt , Datentyp , Adresse , Kommentar werden automatisch gemäß der Variablendeklaration gefüllt. Das Symbol vor dem Ausdruck zeigt an, ob es sich um eine Eingabevariable, Ausgabevariable oder „normale“ Variable handelt. Im Onlinebetrieb können Sie eine Überwachungsliste auch mit Hilfe des Kontextmenü-Befehls Zur Überwachungsliste hinzufügen neu anlegen oder eine bestehende bearbeiten. " }, 
{ "title" : "Hinzufügen von Variablen mit Hilfe des Befehls 'Zur Überwachungsliste hinzufügen' (Onlinebetrieb) ", 
"url" : "_cds_using_watchlists.html#UUID-aa48d044-1dcc-85b4-3abf-5972dd8036a1_id_a81a96006e9d8726c0a8640e01e78912_id_efc074136cf010afc0a8640e01cc70f3", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Monitoring von Werten \/ Überwachungslisten verwenden \/ Hinzufügen von Variablen mit Hilfe des Befehls 'Zur Überwachungsliste hinzufügen' (Onlinebetrieb) ", 
"snippet" : "Voraussetzung: Ein Projekt ist im Betrieb geöffnet. Es enthält eine Applikation, in der bereits Variablen deklariert sind, die Sie in eine Überwachungsliste aufnehmen möchten. Öffnen Sie die gewünschte Überwachungsliste mit Befehl Ansicht → Überwachen <n> . Stellen Sie den Cursor im Deklarations- od...", 
"body" : "Voraussetzung: Ein Projekt ist im Betrieb geöffnet. Es enthält eine Applikation, in der bereits Variablen deklariert sind, die Sie in eine Überwachungsliste aufnehmen möchten. Öffnen Sie die gewünschte Überwachungsliste mit Befehl Ansicht → Überwachen <n> . Stellen Sie den Cursor im Deklarations- oder Implementierungsteil einer POU auf die Variable und wählen Sie aus dem Kontextmenü den Befehl Zur Überwachungsliste hinzufügen . Der Liste wird ein Eintrag für die gewählte Variable hinzugefügt. Sie können weitere Variablen auf diese Weise hinzufügen, oder durch Eintragen in der Liste im Feld Ausdruck , wie oben beschrieben („Anlegen und Bearbeiten…“). Die Überwachungslisten werden unmittelbar aktualisiert. Wenn keine Überwachungsliste geöffnet ist, während Sie den Befehl Zur Überwachungsliste hinzufügen auf eine Variable anwenden, wird diese automatisch der Liste Überwachen 1 hinzugefügt. Schreiben und Forcen der Variablenwerte ist auch in den Überwachungslisten möglich. Im Onlinebetrieb erscheint dazu die Spalte Vorbereiteter Wert . " }, 
{ "title" : "Datenerfassung mit Trace ", 
"url" : "_cds_f_data_acquiring_with_trace.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Datenerfassung mit Trace ", 
"snippet" : "Voraussetzung: Das Package CODESYS Trace ist installiert. Mit einem Trace können Sie den Werteverlauf von Variablen auf der Steuerung verfolgen, ähnlich einem digitalen Abtast-Oszilloskop. Die Daten und deren Verlauf können im Traceeditor dargestellt werden. Für weitere Informationen siehe: CODESYS ...", 
"body" : "Voraussetzung: Das Package CODESYS Trace ist installiert. Mit einem Trace können Sie den Werteverlauf von Variablen auf der Steuerung verfolgen, ähnlich einem digitalen Abtast-Oszilloskop. Die Daten und deren Verlauf können im Traceeditor dargestellt werden. Für weitere Informationen siehe: CODESYS Trace " }, 
{ "title" : "Tasks überwachen ", 
"url" : "_cds_monitoring_running_tasks.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Tasks überwachen ", 
"snippet" : "Im Onlinebetrieb können Sie einige statistische Werte der Tasks im Laufzeitsystem anzeigen. Diese Informationen können bei Taktzeituntersuchungen oder Problemen im Zeitverhalten sehr hilfreich sein. Wechseln Sie in den Onlinebetrieb. Selektieren Sie die Task-Konfiguration im Gerätebaum. Wählen Sie d...", 
"body" : "Im Onlinebetrieb können Sie einige statistische Werte der Tasks im Laufzeitsystem anzeigen. Diese Informationen können bei Taktzeituntersuchungen oder Problemen im Zeitverhalten sehr hilfreich sein. Wechseln Sie in den Onlinebetrieb. Selektieren Sie die Task-Konfiguration im Gerätebaum. Wählen Sie den Befehl Projekt → Objekt bearbeiten . Die Task-Konfiguration wird im Editor geöffnet. Wählen Sie die Registerkarte Überwachung . " }, 
{ "title" : "Logbuch der SPS lesen ", 
"url" : "_cds_reading_plc_log.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Logbuch der SPS lesen ", 
"snippet" : "CODESYS bietet Ihnen die Möglichkeit, die in der Steuerung geloggten Ereignisse und Fehlermeldungen anzuzeigen. Logbuch lesen Voraussetzung: Die Steuerung läuft. Selektieren Sie im Gerätebaum die Steuerung. Wählen Sie den Befehl Projekt → Objekt bearbeiten . Der Geräteeditor öffnet sich. Wählen Sie ...", 
"body" : "CODESYS bietet Ihnen die Möglichkeit, die in der Steuerung geloggten Ereignisse und Fehlermeldungen anzuzeigen. Logbuch lesen Voraussetzung: Die Steuerung läuft. Selektieren Sie im Gerätebaum die Steuerung. Wählen Sie den Befehl Projekt → Objekt bearbeiten . Der Geräteeditor öffnet sich. Wählen Sie die Registerkarte Log . Klicken Sie auf die Schaltfläche zum Aktualisieren der Ansicht. Es wird eine Verbindung zur Steuerung aufgebaut. Die Steuerung wird im Gerätebaum grün hinterlegt. Alle Log-Ereignisse der Steuerung werden angezeigt. Das vorangestellte Icon zeigt die Gewichtung des Log-Ereignisses an: : Warnung : Fehler : Ausnahme : Information : Debug Wenn Sie die Ereignisse einer bestimmten Gewichtung nicht angezeigt bekommen möchten, klicken Sie auf das entsprechende Icon in der Menüleiste. Wenn Sie erneut auf dieses Icon klicken, werden diese Log-Ereignisse wieder angezeigt. Beispielsweise klicken Sie auf das Icon in der Menüleiste, wenn Sie keine Log-Ereignisse mit der Gewichtung \"Fehler\" angezeigt bekommen möchten. Im Eingabefeld Suche in Meldungen geben Sie einen Suchbegriff eingeben, um in der Liste ein bestimmtes Ereignis zu finden. Anschließend können Sie mit den Schaltflächen und zu den farblich gekennzeichneten Suchergebnissen springen. Um die Ereignisse nach Gewichtung , Zeitstempel , Beschreibung oder Komponente zu filtern, klicken Sie auf den jeweiligen Titel der Spalte. Klicken Sie auf die Schaltfläche , um die angezeigten Log-Ereignisse in einer Datei zu speichern. " }, 
{ "title" : "SPS-Shell zur Abfrage von Informationen verwenden ", 
"url" : "_cds_querying_information_via_plc_shell.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ SPS-Shell zur Abfrage von Informationen verwenden ", 
"snippet" : "Die „SPS-Shell“ in CODESYS ist ein textbasierter Steuerungsmonitor auf einer Registerkarte des Geräteeditors. Dort können Sie Kommandos zur Abfrage bestimmter Informationen eingeben sowie Aktionen ausführen wie Starten, Stoppen oder Laden von Applikationen. Auch eine Beschreibung zur Bedeutung und S...", 
"body" : "Die „SPS-Shell“ in CODESYS ist ein textbasierter Steuerungsmonitor auf einer Registerkarte des Geräteeditors. Dort können Sie Kommandos zur Abfrage bestimmter Informationen eingeben sowie Aktionen ausführen wie Starten, Stoppen oder Laden von Applikationen. Auch eine Beschreibung zur Bedeutung und Syntax der möglichen Kommandos können Sie direkt aus der SPS-Shell abrufen. Die möglichen Kommandos sind herstellerabhängig. Der Umfang an Kommandos ist über den sogenannten SPS Shell Command Handler entweder in einer C-Komponente im Laufzeitsystem, oder als Funktionsbaustein in einer IEC-Bibliothek oder einem Projekt erweiterbar. Die Antwort aus der SPS erscheint auf der Registerkarte als Zeichenfolge in einem Ergebnisfenster. Abfrage von Information zur Applikation auf der Steuerung Voraussetzung: Ihr Projekt ist mit einer Steuerung verbunden; Beispiel CODESYS Control Win , auf der eine Applikation App1 läuft. Öffnen Sie den Geräteeditor mit einem Doppelklick auf das Objekt CODESYS Control Win im Gerätebaum und wählen die Registerkarte SPS-Shell . Die Registerkarte erscheint mit einem leeren Anzeigefenster. Darunter finden Sie eine Eingabezeile für ein Kommando. Klicken Sie auf die Schaltfläche . Der Dialog Standardkommando eingeben erscheint mit einer Liste mit Kommandos. Wählen Sie das Kommando ? und klicken auf die Schaltfläche Ausführen . Der Dialog schließt und im Ausgabefenster erscheint eine Liste der verfügbaren Kommandos mit den möglichen Parametern. Sie zeigt jeweils die Syntax der Kommandoeingabe. Klicken Sie erneut auf und wählen Sie das Kommando pid . Ergänzen Sie in der Eingabezeile folgendermaßen: pid App1 . Drücken Sie die Eingabetaste. Im Ausgabefenster erscheint Folgendes (GUIDs nur als Beispiele): pid App1 Project Identification Applikation: App1 Code GUID:0x08a893c0 Data GUID:0x762d0e90 Drücken Sie die Schaltfläche in der Kommandoeingabezeile. Das Kommando pid App1 ist in der Historie der eingegebenen Kommandos aufgenommen. " }, 
{ "title" : "SPS-Operationssteuerung über Systemvariablen ", 
"url" : "_cds_operation_control_via_system_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ SPS-Operationssteuerung über Systemvariablen ", 
"snippet" : "Es liegt in Ihrer Verantwortung, dass Laufzeitsystemdienste in sicheren Applikationszuständen aktiviert und nur in kritischen deaktiviert sind. Eine Anlage oder Applikation kann zur Laufzeit in einen sensiblen Zustand kommen, in dem störende Aktionen die gesamte Maschine oder Anlage gefährden können...", 
"body" : "Es liegt in Ihrer Verantwortung, dass Laufzeitsystemdienste in sicheren Applikationszuständen aktiviert und nur in kritischen deaktiviert sind. Eine Anlage oder Applikation kann zur Laufzeit in einen sensiblen Zustand kommen, in dem störende Aktionen die gesamte Maschine oder Anlage gefährden können. Sie können aber in diesem Zustand bestimmte Befehle unterdrücken und gefährliche Aktionen verhindern. Hierfür steht Ihnen der Funktionsbaustein PlcOperationControl der Bibliothek Component Manager zur Verfügung. Beispiele von CODESYS -Befehlen, deren Ausführung unterdrückt werden kann: Online-Change , Download Haltepunkt aktivieren Applikation Reset , Applikation Stop Dateien übertragen Werte forcen , Werte schreiben Der Befehl Reset Ursprung Gerät kann nicht deaktiviert werden, so dass Sie sich nicht komplett aus dem Laufzeitsystem aussperren können. Dieser Befehl ist die letzte Möglichkeit, ein komplett gesperrtes Laufzeitsystem zu öffnen, wo alle kritischen Operationen deaktiviert sind. Dies ist in der der Regel akzeptabel, da dieser Befehl erweiterte Zugriffsrechte in der Gerätebenutzerverwaltung erfordert. Wenn zur Laufzeit der Applikation ein Laufzeitsystemdienst angefordert wird, der aber gerade deaktiviert ist, erhalten Sie in CODESYS eine Meldung darüber. Sie können dann mit einer passenden Gegenmaßnahmen darauf reagieren. " }, 
{ "title" : "Funktionsbaustein PlcOperationControl zur Operationssteuerung ", 
"url" : "_cds_operation_control_via_system_variables.html#UUID-b0a8d090-cd03-6673-0ff7-b90ce6118e6a_id_cf02989893c0a8640e0164e374_id_0f29fd87c71811e4be8af5413b027a7b", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ SPS-Operationssteuerung über Systemvariablen \/ Funktionsbaustein PlcOperationControl zur Operationssteuerung ", 
"snippet" : "Der Funktionsbaustein dient der Aktivierung und Deaktivierung von Operationen. Eigenschaft (PROPERTY) Name Datentyp Initialwert Beschreibung xDisableApplicationOnlineChange BOOL FALSE TRUE : Online-Change wird unterdrückt xDisableApplicationDownload BOOL FALSE TRUE : Download wird unterdrückt xDisab...", 
"body" : "Der Funktionsbaustein dient der Aktivierung und Deaktivierung von Operationen. Eigenschaft (PROPERTY) Name Datentyp Initialwert Beschreibung xDisableApplicationOnlineChange BOOL FALSE TRUE : Online-Change wird unterdrückt xDisableApplicationDownload BOOL FALSE TRUE : Download wird unterdrückt xDisableApplicationStop BOOL FALSE TRUE : Applikationsstopp wird unterdrückt xDisableApplicationBP BOOL FALSE TRUE : Setzen eines Haltepunkts wird unterdrückt xDisableApplicationWrite BOOL FALSE TRUE : Schreiben von Variablen wird unterdrückt Kann auch über PLCHandler\/IecVarAccess unterbunden werden. xDisableApplicationForce BOOL FALSE TRUE : Forcen von Variablen wird unterdrückt xDisableApplicationReset BOOL FALSE TRUE : Reset der Applikation (nicht „Reset Ursprung“!) wird unterdrückt xDisableAll BOOL FALSE TRUE : Alle Operationen werden unterdrückt " }, 
{ "title" : "Operationssteuerung implementieren ", 
"url" : "_cds_operation_control_via_system_variables.html#UUID-b0a8d090-cd03-6673-0ff7-b90ce6118e6a_id_cf02989893c0a8640e0164e374_id_695396c9235ca019c0a8640e003317ec", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ SPS-Operationssteuerung über Systemvariablen \/ Operationssteuerung implementieren ", 
"snippet" : "Voraussetzung Compilerversion ab 3.4.3.0 In der Gerätebeschreibung ist die SPS-Operationssteuerung über Systemvariablen aktiviert. Deklarieren Sie eine Instanz des Funktionsbausteins PlcOperationControl , zum Beisplel PlcOpCtrl_Inst . PlcOpCtrl_Inst : PlcOperationControl; Unterdrücken Sie einen Befe...", 
"body" : "Voraussetzung Compilerversion ab 3.4.3.0 In der Gerätebeschreibung ist die SPS-Operationssteuerung über Systemvariablen aktiviert. Deklarieren Sie eine Instanz des Funktionsbausteins PlcOperationControl , zum Beisplel PlcOpCtrl_Inst . PlcOpCtrl_Inst : PlcOperationControl; Unterdrücken Sie einen Befehl, indem Sie der zugehörigen Eigenschaft TRUE zuweisen, zum Beispiel „Applikation stoppen“. PlcOpCtrl_Inst.xDIsableApplicationStop := TRUE; " }, 
{ "title" : "Sichern und Wiederherstellen ", 
"url" : "_cds_restoring_applications_and_rts.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Sichern und Wiederherstellen ", 
"snippet" : "CODESYS und die CODESYS -Standardlaufzeitsysteme ab Version 3.5.8.0.unterstützen ein „Backup“ für die applikationsspezifischen Dateien auf der SPS. Die nötigen Aktionen können Sie über die Registerkarte Sichern und Wiederherstellen des generischen Geräteeditors vornehmen. Das Sichern besteht aus dem...", 
"body" : "CODESYS und die CODESYS -Standardlaufzeitsysteme ab Version 3.5.8.0.unterstützen ein „Backup“ für die applikationsspezifischen Dateien auf der SPS. Die nötigen Aktionen können Sie über die Registerkarte Sichern und Wiederherstellen des generischen Geräteeditors vornehmen. Das Sichern besteht aus dem Erstellen und Ablegen einer Datei im ZIP-Format, die die applikationsrelevanten Dateien sowie eine Informationsdatei meta.info enthält. Diese Sicherungsdatei trägt die Erweiterung TBF (=“Target Backup File“) und kann im lokalen Dateisystem oder auf der SPS gespeichert werden. Beim Wiederherstellen des Softwarestandes aus der Sicherungsdatei gilt Folgendes: Sie erhalten eine Liste der betroffenen Dateien auf der SPS und können optionale Komponenten deaktivieren. Falls Sie die Applikation für das Sichern oder Wiederherstellen in Zustand STOP versetzen müssen, werden Sie darauf hingewiesen. Ebenso erscheinen Meldungen im Falle von Inkompatibilitäten. Während des Wiederherstellens auf der SPS ist die Benutzeroberfläche gesperrt. Vorhandene Dateien werden ohne Bestätigung überschrieben. Vorhandene Boot-Applikation werden deaktiviert, sobald mindestens eine neue Boot-Applikation Teil der Wiederherstellung ist. Wiederherstellen aus einer Sicherungsdatei Voraussetzung: Sie haben ein Projekt mit einer Applikation geöffnet, die auf dem verwendeten Gerät läuft. Sie haben wie oben beschrieben eine Sicherungsdatei im lokalen Dateisystem gespeichert. Öffnen Sie den Geräteeditor mit Doppelklick auf den Geräteeintrag im Gerätebaum. Wählen Sie die Registerkarte Speichern und Wiederherstellen . Wählen Sie den Befehl Wiederherstellen → Sicherungsdatei von der Platte laden . Der Standard-Browser zum Auswählen einer tbf -Sicherungsdatei im lokalen Dateisystem erscheint. Wählen Sie die Sicherungsdatei aus und bestätigen Sie mit Öffnen . Die Dateien werden aus der Sicherungsdatei gelesen und in der Tabelle unten im Dialog dargestellt. Es fehlt jetzt die beim Sichern ausgeschlossene Datei $PlcLogic$\/Application\/myExternalFile.txt . Wählen Sie den Befehl Wiederherstellen → Wiederherstellen auf Gerät . Sie erhalten eine Eingabeaufforderung mit Informationen zu den Aktionen beim Wiederherstellen. Bestätigen Sie mit OK , um das Wiederherstellen der Dateien im SPS-Dateisystem zu starten. Nach Abschluss des Wiederherstellens erhalten Sie die Aufforderung, die SPS neu zu starten, um die neu eingespielte Applikation zu aktivieren. " }, 
{ "title" : "Eine Sicherungsdatei erstellen ", 
"url" : "_cds_restoring_applications_and_rts.html#UUID-a5724295-15a5-2a21-ffa4-030d2000b46b_id_adae4542f3ceafacc0a8640e00a417a9_id_6dc6a99862ca11e5ba2e95faa584c1c4", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation zur Laufzeit \/ Sichern und Wiederherstellen \/ Eine Sicherungsdatei erstellen ", 
"snippet" : "Voraussetzung: Sie haben ein Projekt mit einer Applikation geöffnet, die auf dem verwendeten Gerät läuft. Für dieses Beispiel haben Sie außerdem unterhalb der Applikation eine externe Datei myExternalFile.txt als Objekt hinzugefügt, die implizit beim Applikationsdownload mit auf die SPS geladen wird...", 
"body" : "Voraussetzung: Sie haben ein Projekt mit einer Applikation geöffnet, die auf dem verwendeten Gerät läuft. Für dieses Beispiel haben Sie außerdem unterhalb der Applikation eine externe Datei myExternalFile.txt als Objekt hinzugefügt, die implizit beim Applikationsdownload mit auf die SPS geladen wird. Öffnen Sie den Geräteeditor mit Doppelklick auf den Geräteeintrag im Gerätebaum. Wählen Sie die Registerkarte Speichern und Wiederherstellen . Die Registerkarte erscheint. Sie enthält eine Menüleiste mit den Menüs Sichern und Wiederherstellen . Wählen Sie im Menü Sichern den Befehl Sicherungsinformation vom Gerät lesen . Falls Sie gerade nicht mit der SPS verbunden sind, öffnet CODESYS kurzzeitig eine Verbindung zum Gerät und liest die relevanten Dateien aus dem $PlcLogic$ -Verzeichnis der SPS in die Tabelle im unteren Teil der Registerkarte. Mindestens werden Sie in diesem Beispiel hier die Dateien $PlcLogic$\/Application\/Application.app , $PlcLogic$\/Application\/Application.crc und $PlcLogic$\/Application\/myExternalFile.txt erhalten. Zusätzlich sehen Sie projektabhängig weitere externe Dateien, die im Gerätebaum unter der Applikation eingehängt wurden. Außerdem die Quellcode-Archivdatei $PlcLogic$\/Archive.prj , falls sie für diese die Projekteinstellung Implizit beim Programm-Download und Online-Change als Ladezeitpunkt gesetzt haben. Deaktivieren Sie in der Tabelle über die Checkbox in Spalte Aktiv die Datei $PlcLogic$\/Application\/\/myExternalFile.txt . Wählen Sie im Menü Sichern den Befehl Sicherungsdatei erzeugen und auf Platte speichern . Der Dialog Speichern unter erscheint. Der Dateityp ist mit Sicherungsdateien (*.tbf) vorgegeben. Wählen Sie einen Speicherort für die Sicherungsdatei und schließen Sie mit Schaltfläche Speichern ab. " }, 
{ "title" : "Applikation auf der SPS aktualisieren ", 
"url" : "_cds_struct_update_application_on_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf der SPS aktualisieren ", 
"snippet" : "CODESYS bietet Ihnen grundsätzlich zwei Möglichkeiten, eine geänderte Applikation auf die Steuerung zu übertragen: Download und Online-Change. Ein Download führt zu einem erneuten Übersetzen der Applikation. Dabei wird neben einer Syntaxprüfung auch Applikationscode erzeugt und auf die Steuerung gel...", 
"body" : "CODESYS bietet Ihnen grundsätzlich zwei Möglichkeiten, eine geänderte Applikation auf die Steuerung zu übertragen: Download und Online-Change. Ein Download führt zu einem erneuten Übersetzen der Applikation. Dabei wird neben einer Syntaxprüfung auch Applikationscode erzeugt und auf die Steuerung geladen. Dies führt zu einem Stopp des laufenden Programms. Ein Download ist die empfohlene Art der Datenübertragung, da aufgrund des Programmstopps und der Neuinitialisierung immer ein definierter Ausgangszustand geschaffen wird. Bei einem Online-Change werden nur die geänderten Teile neu in die Steuerung geladen. Dabei wird ein laufendes Programm nicht angehalten. Führen Sie einen Online-Change nur bei kleinen Änderungen der Applikation aus. Bei umfangreichen Änderungen kann das Verhalten eines Programms nicht sicher vorhergesagt werden. Lesen Sie dazu bitte die Hinweise in der Beschreibung des Befehls Online-Change . Beim Einloggen auf eine Steuerung oder beim Offline-Editieren von Objekten überprüft CODESYS die Änderung gegenüber dem auf der Steuerung vorhandenen Projekt und gibt das Ergebnis in der Statuszeile aus: Programm geändert (Voller Download) : Die Projektänderung kann nur mit einem Download übertragen werden Programm geändert (Online-Change) : Die Projektänderung auch mit einem Online-Change übertragen werden " }, 
{ "title" : "Online-Change ausführen ", 
"url" : "_cds_performing_an_online_change.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf der SPS aktualisieren \/ Online-Change ausführen ", 
"snippet" : "CODESYS bietet Ihnen automatisch einen Online-Change an, wenn Sie mit einer Applikation einloggen, die bereits auf der Steuerung vorhanden ist, aber seit dem letzten Download im Programmiersystem verändert wurde. Bei diesem Vorgang werden nur die geänderten Teile neu in die Steuerung geladen. Ein la...", 
"body" : "CODESYS bietet Ihnen automatisch einen Online-Change an, wenn Sie mit einer Applikation einloggen, die bereits auf der Steuerung vorhanden ist, aber seit dem letzten Download im Programmiersystem verändert wurde. Bei diesem Vorgang werden nur die geänderten Teile neu in die Steuerung geladen. Ein laufendes Programm auf der Steuerung wird beim Online-Change nicht angehalten. In der Ansicht Speicherreserve für Online-Change können Sie für Funktionsbausteine eines Projekts Speicherreserven für den Online-Change konfigurieren. Dadurch müssen nach Änderungen eines Funktionsbausteins beim Online-Change Instanzvariablen im Speicher nicht verschoben werden. Beachten Sie beim Online-Change die Hinweise in der Beschreibung des Befehls Online-Change . Online-Change im eingeloggten Zustand (Onlinebetrieb) ausführen Voraussetzung: Die Verbindungseinstellungen der Steuerung sind korrekt eingestellt. Die Applikationen im Projekt und auf der Steuerung sind identisch. Das Programm auf der Steuerung läuft. Die Applikation ist eingeloggt. Selektieren Sie ein Objekt im Gerätebaum. Hier wählen Sie am besten eine POU oder GVL. Wählen Sie den Befehl Projekt → Objekt (offline) bearbeiten . Das Objekt öffnet im Editor. Verändern Sie das Objekt. Hier können Sie beispielsweise eine neue Variable deklarieren oder eine Wertzuweisung ändern. Wählen Sie den Befehl Online → Online-Change . Sie erhalten eine Abfrage, ob Sie den Online-Change wirklich ausführen wollen. Bestätigen Sie den Dialog mit Ja . Die Änderung wird auf die Steuerung geladen. " }, 
{ "title" : "Online-Change beim Einloggen ausführen ", 
"url" : "_cds_performing_an_online_change.html#UUID-217fb929-5892-40cb-4dbf-ec7a5f6cf6bd_id_bfc346a7689da61c0a8640e01ee8549_id_89839d86b2bb11e4a177fe5cc7c27ae9", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf der SPS aktualisieren \/ Online-Change ausführen \/ Online-Change beim Einloggen ausführen ", 
"snippet" : "Voraussetzung: Die Verbindungseinstellungen der Steuerung sind korrekt eingestellt. Die Applikationen im Projekt und auf der Steuerung sind identisch. Das Programm auf der Steuerung läuft. Die Applikation ist ausgeloggt. Verändern Sie Ihre Applikation. Wählen Sie den Befehl Online → Einloggen . Es e...", 
"body" : "Voraussetzung: Die Verbindungseinstellungen der Steuerung sind korrekt eingestellt. Die Applikationen im Projekt und auf der Steuerung sind identisch. Das Programm auf der Steuerung läuft. Die Applikation ist ausgeloggt. Verändern Sie Ihre Applikation. Wählen Sie den Befehl Online → Einloggen . Es erscheint ein Dialog mit dem Hinweis, dass die Applikation seit dem letzten Download geändert wurde. Klicken Sie auf die Schaltfläche Details . Prüfen Sie die Angaben in der Registerkarte Applikationsinformationen . Wenn Sie seit der letzten Änderung keinen Code erzeugt haben, ist der Befehl Applikation nicht aktuell. Code jetzt erzeugen? am unteren Rand des Dialogs sichtbar. Klicken Sie in diesem Fall auf diesen Befehl. Sie erhalten eine Vergleichsansicht der Objekte - rot markierte Objekte sind unterschiedlich. Schließen Sie den Dialog. Wählen Sie die Option Mit Online-Change einloggen und Klicken Sie auf OK . Die Änderung wird auf die Steuerung geladen. Das laufende Programm auf der Steuerung wird dabei nicht angehalten. Die Applikation ist eingeloggt. " }, 
{ "title" : "Ausführen eines Downloads ", 
"url" : "_cds_performing_a_download.html", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf der SPS aktualisieren \/ Ausführen eines Downloads ", 
"snippet" : "Ein Download der Applikation bewirkt ein Übersetzen der aktiven Applikation. Dabei wird neben einer Syntax-Prüfung auch Applikations-Code erzeugt und auf die Steuerung geladen. Ein laufendes Programm auf der Steuerung wird beim Download angehalten. Beachten Sie beim Download die Hinweise in der Besc...", 
"body" : "Ein Download der Applikation bewirkt ein Übersetzen der aktiven Applikation. Dabei wird neben einer Syntax-Prüfung auch Applikations-Code erzeugt und auf die Steuerung geladen. Ein laufendes Programm auf der Steuerung wird beim Download angehalten. Beachten Sie beim Download die Hinweise in der Beschreibung des Befehls Download . Download im eingeloggten Zustand (Onlinebetrieb) Voraussetzung: Die Verbindungseinstellungen der Steuerung sind korrekt eingestellt. Die Applikationen im Projekt und auf der Steuerung sind identisch. Das Programm auf der Steuerung läuft. Die Applikation ist eingeloggt. Selektieren Sie eine Objekt im Gerätebaum. Hier wählen Sie am besten eine POU oder GVL. Wählen Sie den Befehl Projekt → Objekt (offline) bearbeiten . Das Objekt öffnet im Editor. Verändern Sie das Objekt. Hier können Sie beispielsweise eine neue Variable deklarieren oder eine Wertzuweisung ändern. Wählen Sie den Befehl Online → Download . Sie erhalten eine Abfrage, ob Sie den Download wirklich ausführen wollen. Bestätigen Sie den Dialog mit Ja . Das laufende Programm auf der Steuerung wird angehalten und die Änderung auf die Steuerung geladen. " }, 
{ "title" : "Download beim Einloggen ", 
"url" : "_cds_performing_a_download.html#UUID-60110cce-40f4-7c41-696d-4ce2dcaf51dd_id_c7d078ef768b6539c0a8640e006bdc72_id_89839d86b2bb11e4a177fe5cc7c27ae9", 
"breadcrumbs" : "CODESYS Essentials \/ Applikation auf der SPS aktualisieren \/ Ausführen eines Downloads \/ Download beim Einloggen ", 
"snippet" : "Voraussetzung: Die Verbindungseinstellungen der Steuerung sind korrekt eingestellt. Die Applikationen im Projekt und auf der Steuerung sind identisch. Das Programm auf der Steuerung läuft. Die Applikation ist ausgeloggt. Verändern Sie Ihre Applikation. Wählen Sie den Befehl Online → Einloggen . Es e...", 
"body" : "Voraussetzung: Die Verbindungseinstellungen der Steuerung sind korrekt eingestellt. Die Applikationen im Projekt und auf der Steuerung sind identisch. Das Programm auf der Steuerung läuft. Die Applikation ist ausgeloggt. Verändern Sie Ihre Applikation. Wählen Sie den Befehl Online → Einloggen . Es erscheint ein Dialog mit dem Hinweis, dass die Applikation seit dem letzten Download geändert wurde. Wählen Sie die Option Mit Download einloggen und Klicken Sie auf OK . Das laufende Programm auf der Steuerung wird angehalten und die Änderung auf die Steuerung geladen. Die Applikation ist eingeloggt. " }, 
{ "title" : "Dateien von\/zur SPS kopieren ", 
"url" : "_cds_copy_files_from_to_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ Dateien von\/zur SPS kopieren ", 
"snippet" : "In der generischen Registerkarte Dateien des Geräteeditors können Sie Dateien zwischen Ihrem lokalen Dateisystem und der Steuerung in beiden Richtungen kopieren. Voraussetzung: Die Registerkarte ist vom Hersteller freigeschaltet. Im Gerätebaum Ihres Projekts ist die Verbindung mit dem Steuerungsgerä...", 
"body" : "In der generischen Registerkarte Dateien des Geräteeditors können Sie Dateien zwischen Ihrem lokalen Dateisystem und der Steuerung in beiden Richtungen kopieren. Voraussetzung: Die Registerkarte ist vom Hersteller freigeschaltet. Im Gerätebaum Ihres Projekts ist die Verbindung mit dem Steuerungsgerät konfiguriert. Das Gerät läuft. Öffnen Sie mit einem Doppelklick auf das SPS-Geräteobjekt im Gerätebaum den Geräteeditor. Wählen Sie die Registerkarte Registerkarte: Dateien . Stellen Sie in der linken Dialoghälfte ( Host ) bei Ort den Pfad in Ihrem lokalen Dateisystem ein, aus dem oder in das Dateien kopiert werden sollen. Beispiel: D:\\FileTransferWithPLC Wenn nötig, legen Sie über die Schaltfläche direkt ein neues Verzeichnis an. Wie aus dem Datei-Manager bekannt, werden die Verzeichnisse und Dateien dargestellt. Mit der Schaltfläche können Sie die Darstellung aktualisieren. Stellen Sie auf gleiche Weise in der rechten Dialoghälfte ( Laufzeit ) das gewünschte Verzeichnis für den Dateitransfer ein. CODESYS zeigt die auf der Steuerung vorliegenden Dateien an. Wählen Sie nun für einen Dateitransfer im jeweiligen Dateisystembaum die gewünschten Dateien aus. Mehrfachauswahl ist möglich. Sie können auch ein Verzeichnis auswählen, wenn alle enthaltenen Dateien übertragen werden sollen. Betätigen Sie die Schaltfläche beziehungsweise zwischen den Dialoghälften. CODESYS kopiert die ausgewählten Dateien unmittelbar ins andere Dateisystem. Wenn eine Datei im Zielverzeichnis noch nicht vorhanden ist, wird sie dort neu angelegt. Wenn sie bereits vorliegt, wird sie überschrieben, außer sie ist schreibgeschützt. Dann erscheint eine entsprechende Meldung. " }, 
{ "title" : "Kommandozeilen-Schnittstelle verwenden ", 
"url" : "_cds_commandline.html", 
"breadcrumbs" : "CODESYS Essentials \/ Kommandozeilen-Schnittstelle verwenden ", 
"snippet" : "Sie können CODESYS .exe über die Kommandozeile starten und dabei die im Folgenden beschriebenen Optionen und Argumente angeben. Syntax: <installation folder>CODESYS.exe --<Option> Wenn Sie mit dem CODESYS Installer mehrere CODESYS -Instanzen auf Ihrem Computer installiert haben, müssen Sie die Insta...", 
"body" : "Sie können CODESYS .exe über die Kommandozeile starten und dabei die im Folgenden beschriebenen Optionen und Argumente angeben. Syntax: <installation folder>CODESYS.exe --<Option> Wenn Sie mit dem CODESYS Installer mehrere CODESYS -Instanzen auf Ihrem Computer installiert haben, müssen Sie die Instanz, die gestartet werden soll, mit der Option --additionalfolder angeben. Pfade oder Optionenparameter, die Leerzeichen, Minuszeichen oder Schrägstriche enthalten, müssen Sie in einfache Anführungszeichen fassen. " }, 
{ "title" : "Option --additionalfolder ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-11c2da71-d4f5-749d-04bf-eeab75652c7e", 
"breadcrumbs" : "CODESYS Essentials \/ Kommandozeilen-Schnittstelle verwenden \/ Option --additionalfolder ", 
"snippet" : "Gilt nur für Installationen, die mit dem CODESYS Installer erfolgt sind: Wenn Sie mehrere Instanzen einer CODESYS -Version installiert haben und gezielt eine der Instanzen über Kommandozeile starten wollen, gilt: Sie müssen mit der Option --additionalfolder zusätzlich zum Profil auch den absoluten (...", 
"body" : "Gilt nur für Installationen, die mit dem CODESYS Installer erfolgt sind: Wenn Sie mehrere Instanzen einer CODESYS -Version installiert haben und gezielt eine der Instanzen über Kommandozeile starten wollen, gilt: Sie müssen mit der Option --additionalfolder zusätzlich zum Profil auch den absoluten (!) Pfad des AddionalFolders\/<instance name> angeben. Hintergrund: Der CODESYS Installer erzeugt bei einer Installation im Installationsverzeichnis im Ordner CODESYS einen Unterordner AdditionalFolders . In diesem Ordner wiederum liegt für jede CODESYS -Instanz ein separater Unterordner mit den individuellen Dateien zu Profil, PlugIns, PackageDB. Für die erste installierte Instanz heißt der Unterordner Default , weitere erhalten jeweils den bei der Installation vergebenen Installationsnamen. Sie sehen den für --additionalfolder anzugebenden absoluten Pfad im CODESYS Installer , wenn Sie in der Kachel der betreffenden Instanz die Schaltfläche Ändern betätigen. Er ist als Ablageort eingetragen. Syntax: --additionalfolder=<AdditionalFolders\\<instance installation name>> Beispiel Von CODESYS 3.5.18.20 wurden mit dem CODESYS Installer auf Ihrem Computer zwei Instanzen installiert, eine für Service Techniker, eine für Entwickler. Sie möchten die Instanz Service über ein Skript StartServiceScript.py über Kommandozeile starten. Dazu geben Sie in der Kommandozeile hinter der Option --profile die Option --additionalfolder folgendermaßen an: \"C:\\Program Files (x86)\\CODESYS3.5.18.20\\CODESYS\\Common\\CODESYS.exe\" --profile=\"CODESYS V3.5 SP18 --additionalfolder=\"C:\\Program Files\\CODESYS 3.5.18.20\\CODESYS\\AdditionalFolders\\Service\" --runscript=\"D:\\Dokumente\\Scripting\\StartServiceScript.py\"--scriptargs:'username password 3.14 \"path=\\\"C:\\temp\\\\\\\"\"'–noUI " }, 
{ "title" : "Option: --culture (Landessprache der Benutzeroberfläche) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_6bc8917312a6e013c0a8640e003e6f2f", 
"breadcrumbs" : "CODESYS Essentials \/ Kommandozeilen-Schnittstelle verwenden \/ Option: --culture (Landessprache der Benutzeroberfläche) ", 
"snippet" : "CODESYS wird in der angegebenen Landessprache gestartet. Syntax: --culture=<Culture> <Culture> : Übliches Sprachkürzel für die gewünschte Landessprache, beispielsweise de, en, fr, it, es, zh-CHS. Beispiel Starten von CODESYS mit englischer Benutzeroberfläche: CODESYS.exe --culture=en...", 
"body" : "CODESYS wird in der angegebenen Landessprache gestartet. Syntax: --culture=<Culture> <Culture> : Übliches Sprachkürzel für die gewünschte Landessprache, beispielsweise de, en, fr, it, es, zh-CHS. Beispiel Starten von CODESYS mit englischer Benutzeroberfläche: CODESYS.exe --culture=en " }, 
{ "title" : "Option: --profile ( CODESYS -Profil) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_30cad0c546e2dc0cc0a8640e00a03b89", 
"breadcrumbs" : "CODESYS Essentials \/ Kommandozeilen-Schnittstelle verwenden \/ Option: --profile ( CODESYS -Profil) ", 
"snippet" : "CODESYS wird direkt mit dem angegebenen Profil gestartet. Wenn Sie CODESYS ohne diese Angabe starten, erhalten Sie den Dialog Profil auswählen . Syntax: --profile=\"<profile name>\" <profile name> : Sie müssen den Profilnamen exakt so angeben, wie er im Dialog Hilfe → Informationen des Entwicklungssys...", 
"body" : "CODESYS wird direkt mit dem angegebenen Profil gestartet. Wenn Sie CODESYS ohne diese Angabe starten, erhalten Sie den Dialog Profil auswählen . Syntax: --profile=\"<profile name>\" <profile name> : Sie müssen den Profilnamen exakt so angeben, wie er im Dialog Hilfe → Informationen des Entwicklungssystems oder im Startmenü Ihres Computers angezeigt wird. Beispiel CODESYS.exe --culture=de --profile=\"CODESYS V3.6\" " }, 
{ "title" : "Option: --compare (Projektvergleich anstossen) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_2d8f4b0c12a6e014c0a8640e00f5a2e5", 
"breadcrumbs" : "CODESYS Essentials \/ Kommandozeilen-Schnittstelle verwenden \/ Option: --compare (Projektvergleich anstossen) ", 
"snippet" : "Nach dem Starten von CODESYS wird unmittelbar der Vergleich zweier CODESYS -Projekte herbeigeführt. Geben Sie hinter der Option als Argumente zunächst das „aktuelle Projekt“ und dann das „Vergleichsprojekt“ an. CODESYS startet und öffnet die Ansicht Projektvergleich - Unterschiede . Syntax: --compar...", 
"body" : "Nach dem Starten von CODESYS wird unmittelbar der Vergleich zweier CODESYS -Projekte herbeigeführt. Geben Sie hinter der Option als Argumente zunächst das „aktuelle Projekt“ und dann das „Vergleichsprojekt“ an. CODESYS startet und öffnet die Ansicht Projektvergleich - Unterschiede . Syntax: --compare=\"<path of project file>\" \"<path of reference project file>\" Beispiel CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.project\" " }, 
{ "title" : "Option: --project ( CODESYS -Projekt öffnen) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_440832e712a6e015c0a8640e0099773d", 
"breadcrumbs" : "CODESYS Essentials \/ Kommandozeilen-Schnittstelle verwenden \/ Option: --project ( CODESYS -Projekt öffnen) ", 
"snippet" : "CODESYS wird gestartet und das angegebene Projekt wird geöffnet. Syntax: --project=\"<path of project file>\" <path of project file> : Dateipfad des Projekts Beispiel Öffnen des Projekts test : CODESYS.exe --culture=de --project=\"D:\\projects\\test.project\"...", 
"body" : "CODESYS wird gestartet und das angegebene Projekt wird geöffnet. Syntax: --project=\"<path of project file>\" <path of project file> : Dateipfad des Projekts Beispiel Öffnen des Projekts test : CODESYS.exe --culture=de --project=\"D:\\projects\\test.project\" " }, 
{ "title" : "Option: --projectarchive ( CODESYS -Projektarchiv öffnen) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_33a5dfa012a6e016c0a8640e016367f3", 
"breadcrumbs" : "CODESYS Essentials \/ Kommandozeilen-Schnittstelle verwenden \/ Option: --projectarchive ( CODESYS -Projektarchiv öffnen) ", 
"snippet" : "CODESYS wird gestartet, das angegebene Projektarchiv wird extrahiert und das Projekt wird geöffnet. Syntax: --projectarchive=\"<path of projectarchive file>\" <path of project archive file> : Dateipfad des Projektarchivs Beispiel Extrahieren des Projektarchivs test.projectarchive und Öffnen des Projek...", 
"body" : "CODESYS wird gestartet, das angegebene Projektarchiv wird extrahiert und das Projekt wird geöffnet. Syntax: --projectarchive=\"<path of projectarchive file>\" <path of project archive file> : Dateipfad des Projektarchivs Beispiel Extrahieren des Projektarchivs test.projectarchive und Öffnen des Projekts im Programmiersystem: CODESYS.exe --projectarchive=\"D:\\projects\\test.projectarchive\" " }, 
{ "title" : "Option: --runscript (Skript ausführen) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_878d053246e2dc13c0a8640e0077c63b", 
"breadcrumbs" : "CODESYS Essentials \/ Kommandozeilen-Schnittstelle verwenden \/ Option: --runscript (Skript ausführen) ", 
"snippet" : "Die angegebene Skriptdatei wird von CODESYS ausgeführt. Kommandozeilen-Optionen für --runscript --runscript=\"<scriptfile>.py\" CODESYS führt die Skriptdatei <scriptfile>.py beim Start aus. Sie müssen den gesamten Pfad der Skript-Datei angeben. --scriptargs:'<arg1> <arg2> ... <argn>' Verwenden Sie die...", 
"body" : "Die angegebene Skriptdatei wird von CODESYS ausgeführt. Kommandozeilen-Optionen für --runscript --runscript=\"<scriptfile>.py\" CODESYS führt die Skriptdatei <scriptfile>.py beim Start aus. Sie müssen den gesamten Pfad der Skript-Datei angeben. --scriptargs:'<arg1> <arg2> ... <argn>' Verwenden Sie die Option zusammen mit der Option --runscript . Sie bewirkt die Übergabe der Argumente <arg1> … <argn> an das Skript. Die Argumente werden an die Python-Variable sys.argv weitergereicht. --noUI Verwenden Sie die Option zusammen mit der Option --runscript . Die CODESYS Benutzeroberfläche wird nicht geöffnet. CODESYS gibt alle Fehler, Warnungen, Compiler-Meldungen und Meldungen, die das Skript erzeugt, in der Kommandozeile aus. Die Skript-Meldungen (1: Severity Text) können von den anderen Meldungen (2: Severity FatalError, Error, Warning, Information) mit dem Operator > getrennt werden. --enablescripttracing Verwenden Sie die Option zusammen mit der Option --runscript . Sie bewirkt, dass jeder Befehl der Skriptdatei in der Ausgabe angezeigt wird. --textPrompts Verwenden Sie die Option zusammen mit der Option --noUI . Sie bewirkt, dass Message-Service-Methoden und Standarddialoge in der Kommandozeile ausgegeben werden, so dass Benutzereingaben erfolgen können. Wenn Sie --textPrompts nicht angeben, werden alle Message-Service-Prompts automatisch mit dem Standardwert beantwortet. Beispiele für Verwendung von Übergabeparametern in Skriptdateien mittels sys.argv start \/b \/wait CODESYS.exe\n--runscript=\"D:\\Script\\ArgvAnd__main__Test.py\"\n--scriptargs:'username password 3.14 \"path=\\\"C:\\temp\\\\\"' Skript-Datei ArgvAnd__main__Test.py from __future__ import print_function\nimport sys\nprint(\"sys.argv: \", len(sys.argv), \" elements:\")\n\nfor arg in sys.argv:\n print(\" - \", arg)\nprint()\nprint(\"__name__: \", __name__) Ausgabeergebnis stdout : sys.argv: 6 elements:\n- D:\\TestScripts\\ArgvAnd__main__Test.py\n- username\n- password\n- 3.14\n- path= \"C:temp\"\n__name__: __main__ Weitere Informationen zur globalen Variable __name__ finden Sie in der Python-Dokumentation. Beispiele zur Meldungsausgabe start \/b \/wait CODESYS.exe --runscript=\"D:\\Script\\AmpelTest.py\" --noUI 1>ScriptMessages.txt Alle Meldungen, die das Skript erzeugt, leitet CODESYS in die Datei ScriptMessages.txt um. Die anderen Meldungen werden in der Kommandozeile ausgegeben. start \/b \/wait CODESYS.exe --runscript=\"D:\\Script\\AmpelTest.py\" --noUI 2>NUL CODESYS unterdrückt alle Meldungen mit Ausnahme der Skriptmeldungen. Die Skriptmeldungen werden in der Kommandozeile ausgegeben. Beispiel für Verwendung der Option –scriptdebugger Das folgende Skript initdebug.py wurde erfolgreich mit pydevd -basierten Debuggern wie PyDev \/ LiClipse oder PyCharm getestet. Um dieses Skript zu verwenden, starten Sie CODESYS mit der folgenden Kommandozeile: --profile=\"Fanta Development Build\" --scriptdebugger=\"D:\\test\\charmdebug\\initdebug.py\" Datei initdebug.py : from _future_ import print_function\nfrom _future_ import unicode_literals\nimport sys\nsys.path.append(r\"D:\\test\\Env2\\Lib\\site-packages\\pycharm-debug.egg\")\nimport pydevd\ndef scriptdebuggersetup():\npydevd.settrace('localhost', port=51234, stdoutToServer=True, stderrToServer=True)\ndef scriptdebuggershutdown():\npydevd.stoptrace() Für weitere Informationen siehe: Skripte verwenden und http:\/\/docs.python.org\/tutorial\/modules.html " }, 
{ "title" : "Option: --ignorewhitespace (Leerzeichen beim Projektvergleich ignorieren) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_6bfa2ec346e2dc14c0a8640e0164e212", 
"breadcrumbs" : "CODESYS Essentials \/ Kommandozeilen-Schnittstelle verwenden \/ Option: --ignorewhitespace (Leerzeichen beim Projektvergleich ignorieren) ", 
"snippet" : "Wenn Sie diese Option hinter der Option --compare <project1> <project2> hinzufügen, werden Leerzeichen im Projektvergleich nicht berücksichtigt. Hinweis: Semantisch relevante Leerzeichen, wie beispielsweise in STRING -Literalen, werden dennoch in jedem Fall berücksichtigt. Syntax --compare=\"<path of...", 
"body" : "Wenn Sie diese Option hinter der Option --compare <project1> <project2> hinzufügen, werden Leerzeichen im Projektvergleich nicht berücksichtigt. Hinweis: Semantisch relevante Leerzeichen, wie beispielsweise in STRING -Literalen, werden dennoch in jedem Fall berücksichtigt. Syntax --compare=\"<path of project file>\" \"<path of reference project file>\" --ignorewhitespace=\"true\"|\"false\" Beispiel CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.project\" --ignorewhitespace=\"true\" " }, 
{ "title" : "Option: --ignorecomments (Kommentare beim Projektvergleich ignorieren) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_38d685e446e2dc15c0a8640e00aa5b6e", 
"breadcrumbs" : "CODESYS Essentials \/ Kommandozeilen-Schnittstelle verwenden \/ Option: --ignorecomments (Kommentare beim Projektvergleich ignorieren) ", 
"snippet" : "Wenn Sie diese Option hinter der Option --compare <project1> <project2> hinzufügen, werden Kommentare im Projektvergleich nicht berücksichtigt. Syntax: --compare=\"<path of project file>\" \"<path of reference project file>\" --ignorecomments=\"true\"|\"false\" Beispiel CODESYS.exe --compare \"D:\\proj\\projec...", 
"body" : "Wenn Sie diese Option hinter der Option --compare <project1> <project2> hinzufügen, werden Kommentare im Projektvergleich nicht berücksichtigt. Syntax: --compare=\"<path of project file>\" \"<path of reference project file>\" --ignorecomments=\"true\"|\"false\" Beispiel CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.project\" --ignorecomments=\"true\" " }, 
{ "title" : "Option: --ignoreproperties (Objekteigenschaften beim Projektvergleich ignorieren) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-ca064d81-741b-2021-8cb8-470e0cb751f2", 
"breadcrumbs" : "CODESYS Essentials \/ Kommandozeilen-Schnittstelle verwenden \/ Option: --ignoreproperties (Objekteigenschaften beim Projektvergleich ignorieren) ", 
"snippet" : "Wenn Sie diese Option hinter der Option --compare <project1> <project2> hinzufügen, werden Objekteigenschaften (Zugriffsrechte, Übersetzungseinstellungen, Verzeichnisse, Bitmaps etc.) im Projektvergleich nicht berücksichtigt. Syntax: --compare=\"<path of project file>\" \"<path of reference project fil...", 
"body" : "Wenn Sie diese Option hinter der Option --compare <project1> <project2> hinzufügen, werden Objekteigenschaften (Zugriffsrechte, Übersetzungseinstellungen, Verzeichnisse, Bitmaps etc.) im Projektvergleich nicht berücksichtigt. Syntax: --compare=\"<path of project file>\" \"<path of reference project file>\" --ignoreproperties=\"true\"|\"false\" Beispiel CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.project\" --ignoreproperties=\"true\" " }, 
{ "title" : "Option: --skipunlicensedplugins (Komponenten ohne Lizenz nicht laden) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_dcd35d41076c4576c0a86463067eecc3", 
"breadcrumbs" : "CODESYS Essentials \/ Kommandozeilen-Schnittstelle verwenden \/ Option: --skipunlicensedplugins (Komponenten ohne Lizenz nicht laden) ", 
"snippet" : "CODESYS wird gestartet. Dabei wird die Abfrage, ob nichtlizenzierte Komponenten dennoch geladen werden sollen, übersprungen. In diesem Fall lädt CODESYS diese Komponenten stillschweigend nicht . Beispiel CODESYS.exe –skipunlicensedplugins...", 
"body" : "CODESYS wird gestartet. Dabei wird die Abfrage, ob nichtlizenzierte Komponenten dennoch geladen werden sollen, übersprungen. In diesem Fall lädt CODESYS diese Komponenten stillschweigend nicht . Beispiel CODESYS.exe –skipunlicensedplugins " }, 
{ "title" : "Option: --signaturethumbprint (Fingerabdruck des Zertifikats, das für das Signieren von übersetzten Bibliotheken verwendet wird) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-caedc225-0247-831c-1ac2-1bc63dca068c", 
"breadcrumbs" : "CODESYS Essentials \/ Kommandozeilen-Schnittstelle verwenden \/ Option: --signaturethumbprint (Fingerabdruck des Zertifikats, das für das Signieren von übersetzten Bibliotheken verwendet wird) ", 
"snippet" : "Wenn Sie diese Option hinter der Option --project=\"<path of project file>\" hinzufügen, wird das Projekt geöffnet und dabei der Fingerabdruck des Zertifikats für das Signieren von übersetzten Bibliotheken übergeben. Syntax: --signaturethumbprint=\"<thumbprint of digital signature>\" Beispiel CODESYS.ex...", 
"body" : "Wenn Sie diese Option hinter der Option --project=\"<path of project file>\" hinzufügen, wird das Projekt geöffnet und dabei der Fingerabdruck des Zertifikats für das Signieren von übersetzten Bibliotheken übergeben. Syntax: --signaturethumbprint=\"<thumbprint of digital signature>\" Beispiel CODESYS.exe --project=\"D:\\projects\\test.project\" signaturethumbprint=\"3E96C9B61010CBDC3186021A1CAA64946DDCAAF3\" " }, 
{ "title" : "Option: --enforcesignedcompiledlibraries (Signieren von übersetzten Bibliotheken erzwingen) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-347f5ad2-49b1-cd80-5021-7561cc675234", 
"breadcrumbs" : "CODESYS Essentials \/ Kommandozeilen-Schnittstelle verwenden \/ Option: --enforcesignedcompiledlibraries (Signieren von übersetzten Bibliotheken erzwingen) ", 
"snippet" : "Wenn Sie diese Option hinter der Option --project=\"<path of project file>\" hinzufügen, wird im Projekt im Security-Screen auf der Registerkarte Benutzer die Option Signieren von übersetzten Bibliotheken erzwingen aktiviert. Wenn der Security-Screen geöffnet und wieder geschlossen wird, werden die ak...", 
"body" : "Wenn Sie diese Option hinter der Option --project=\"<path of project file>\" hinzufügen, wird im Projekt im Security-Screen auf der Registerkarte Benutzer die Option Signieren von übersetzten Bibliotheken erzwingen aktiviert. Wenn der Security-Screen geöffnet und wieder geschlossen wird, werden die aktuellen Einstellungen in die Benutzeroptionen übernommen, auch wenn keine aktiven Änderungen vorgenommen wurden. Syntax: --enforcesignedcompiledlibraries Beispiel CODESYS.exe --project=\"D:\\projects\\test.library\" --enforcesignedcompiledlibraries " }, 
{ "title" : "Option: --timestampingserverurl (Zeitstempel-Server-Adresse setzen) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-2fb9f8ee-c520-7f05-fecd-b242c30821ee", 
"breadcrumbs" : "CODESYS Essentials \/ Kommandozeilen-Schnittstelle verwenden \/ Option: --timestampingserverurl (Zeitstempel-Server-Adresse setzen) ", 
"snippet" : "Wenn Sie diese Option hinter der Option --project=\"<path of project file>\" hinzufügen, wird im Projekt im Security-Screen auf Registerkarte Benutzer die Internet-Adresse des RFC-3161 Zeitstempel-Servers ( Zeitstempel-Server ) gesetzt. Wenn der Seurity-Screen geöffnet und wieder geschlossen wird, wer...", 
"body" : "Wenn Sie diese Option hinter der Option --project=\"<path of project file>\" hinzufügen, wird im Projekt im Security-Screen auf Registerkarte Benutzer die Internet-Adresse des RFC-3161 Zeitstempel-Servers ( Zeitstempel-Server ) gesetzt. Wenn der Seurity-Screen geöffnet und wieder geschlossen wird, werden die aktuellen Einstellungen in die Benutzeroptionen übernommen, auch wenn keine aktiven Änderungen vorgenommen wurden. Syntax: --timestampingserverurl=\"<URL of RFC-3161 timestamping server>\" Beispiel CODESYS.exe --timestampingserverurl=\"http:\/\/timestamp.comodoca.com\/rfc3161\" " }, 
{ "title" : "Option: --enableEventLog ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-6910bbcd-f37f-036c-b800-832c97c5578e", 
"breadcrumbs" : "CODESYS Essentials \/ Kommandozeilen-Schnittstelle verwenden \/ Option: --enableEventLog ", 
"snippet" : "CODESYS wird gestartet und alle Befehlsausführungen werden im Windows Ereignisprotokoll aufgezeichnet. Die Aufzeichnungen befinden sich in der Windows Ereignisanzeige unter Anwendungs-und Dienstprotokolle → AP . Bei der erstmaligen Verwendung dieser Option muss CODESYS mit Administratorrechten gesta...", 
"body" : "CODESYS wird gestartet und alle Befehlsausführungen werden im Windows Ereignisprotokoll aufgezeichnet. Die Aufzeichnungen befinden sich in der Windows Ereignisanzeige unter Anwendungs-und Dienstprotokolle → AP . Bei der erstmaligen Verwendung dieser Option muss CODESYS mit Administratorrechten gestartet werden. Syntax: --enableEventLog=\"CommandManager\" " }, 
{ "title" : "Option --ForceDisconnectAfterInactivity ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-6f3de5bf-ac76-9e2f-50b4-e5265686a252", 
"breadcrumbs" : "CODESYS Essentials \/ Kommandozeilen-Schnittstelle verwenden \/ Option --ForceDisconnectAfterInactivity ", 
"snippet" : "Für diese CODESYS -Sitzung wird die Zeit der Inaktivität, nach der die Verbindung zur Steuerung automatisch abgebrochen wird, auf die angegebene Zeit (Angabe in Sekunden) gesetzt. Der in dieser Option angegebene Wert überschreibt für diese CODESYS -Sitzung den Wert, der in den CODESYS -Optionen in d...", 
"body" : "Für diese CODESYS -Sitzung wird die Zeit der Inaktivität, nach der die Verbindung zur Steuerung automatisch abgebrochen wird, auf die angegebene Zeit (Angabe in Sekunden) gesetzt. Der in dieser Option angegebene Wert überschreibt für diese CODESYS -Sitzung den Wert, der in den CODESYS -Optionen in der Kategorie Online eingestellt ist. Wenn der Wert auf 0 gesetzt wird, wird nicht nach einer bestimmten Zeit der Inaktivität die Verbindung zur Steuerung automatisch abgebrochen. Für diese CODESYS -Sitzung ist damit die Option für den Verbindungsabbruch in den CODESYS -Optionen deaktiviert. Syntax: --ForceDisconnectAfterInactivity=\"<value in seconds>\" \n <value in seconds> : [10, 10800] | 0 Beispiel Nach 300 Sekunden der Inaktiviät wird die Verbindung zur Steuerung automatisch abgebrochen --ForceDisconnectAfterInactivity=\"300\" " }, 
{ "title" : "Bibliotheken verwenden ", 
"url" : "_cds_struct_installing_libraries.html", 
"breadcrumbs" : "CODESYS Essentials \/ Bibliotheken verwenden ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Bibliotheksrepository ", 
"url" : "_cds_struct_installing_libraries.html#UUID-9b7dfd17-ac20-bbba-303e-1ac0ef3a80c0_section-idm4531453287164832668319668401", 
"breadcrumbs" : "CODESYS Essentials \/ Bibliotheken verwenden \/ Bibliotheksrepository ", 
"snippet" : "Das Bibliotheksrepository ist der Ablageort für Bibliotheken und den zugehörigen Metadaten auf dem Entwicklungssystem. Sie können die dort installierten Bibliotheken in Ihr Projekt in einen Bibliotheksverwalter einbinden. Außerdem werden die Bibliotheken versioniert installiert, um ein Aktualisieren...", 
"body" : "Das Bibliotheksrepository ist der Ablageort für Bibliotheken und den zugehörigen Metadaten auf dem Entwicklungssystem. Sie können die dort installierten Bibliotheken in Ihr Projekt in einen Bibliotheksverwalter einbinden. Außerdem werden die Bibliotheken versioniert installiert, um ein Aktualisieren der Bibliotheken zu ermöglichen. Sie können neben dem vorinstallierten Repository System weitere Repositorys anlegen und bearbeiten. " }, 
{ "title" : "Bibliotheksverwalter ", 
"url" : "_cds_struct_installing_libraries.html#UUID-9b7dfd17-ac20-bbba-303e-1ac0ef3a80c0_section-idm4531453400737632668320099362", 
"breadcrumbs" : "CODESYS Essentials \/ Bibliotheken verwenden \/ Bibliotheksverwalter ", 
"snippet" : "Um Programmierbausteine, die in einer Bausteinbibliothek bereitgestellt werden, in der Applikation verwenden zu können, muss die Bibliothek im Bibliotheksverwalter im Projekt eingebunden werden. Voraussetzung dafür ist die Installation der Bibliothek im Bibliotheksrepository. Der Bibliotheksverwalte...", 
"body" : "Um Programmierbausteine, die in einer Bausteinbibliothek bereitgestellt werden, in der Applikation verwenden zu können, muss die Bibliothek im Bibliotheksverwalter im Projekt eingebunden werden. Voraussetzung dafür ist die Installation der Bibliothek im Bibliotheksrepository. Der Bibliotheksverwalter stellt alle eingebundenen Bibliotheken entsprechend ihrem Bibliothekstyp und den zugehörigen Eigenschaften dar. Im Bibliotheksverwalter können Sie weitere Bibliotheken aus dem Bibliotheksrepository hinzufügen, Bibliotheken entfernen und Bibliothekseigenschaften bearbeiten. Der Bibliotheksverwalter kann sowohl in der Ansicht POUs als auch in der Ansicht Geräte platziert sein. Somit kann ein Projekt pro Applikation einen Bibliotheksverwalter haben und zusätzlich einen applikationsübergreifenden in der Ansicht POUs . Die Bibliotheksbausteine der eingebundenen Bibliotheken unter der Ansicht POUs können applikationsunabhängig aufgerufen werden. Die Bibliotheksbausteine der eingebundenen Bibliotheken der Ansicht Geräte können nur im zugehörigen Applikationscode aufgerufen werden. Außerdem verhalten sich Platzhalterbibliotheken beim Laden einer Applikation abhängig von Ihrer Platzierung unterschiedlich. Bibliotheken, die mit einer bestimmte Version in das Projekt eingebunden sind, haben zusätzlich einen Platzhalter auf diese Version (Platzhalterbibliothek). Sie können spezielle Platzhalterauflösungen definieren. Sie können aber auch die Platzhalterauflösung verwenden, die für ein Gerät in der Gerätebeschreibung definiert ist oder die bei einer Bibliothek im Bibliotheksrepository abgelegt ist. Der Bibliotheksverwalter informiert über die tatsächliche Platzhalterauflösung und zeigt die Version, die beim Laden einer Applikation geladen werden wird, an (effektive Version). Wenn ein Bibliotheksverwalter in der Ansicht POUs applikationsübergreifend eingebunden ist, können Sie auf dessen Inhalt global zugreifen. Wenn dabei Platzhalterbibliotheken eingebunden sind, werden nur die Platzhalterauflösungen in der Gerätebeschreibung oder aus dem Bibliotheksrepository geprüft. Üblicherweise ist ein Bibliotheksverwalter in der Ansicht Geräte eingebunden. Dann ruft nur der darunter liegende Applikationscode Bibliotheksbausteine daraus auf. Außerdem werden bei Platzhalterbibliotheken zuerst die speziellen Platzhalterauflösungen geprüft. Erst danach werden die Platzhalterauflösungen, die in der Gerätebeschreibung sind oder aus dem Bibliotheksrepository stammen, geprüft. " }, 
{ "title" : "Informationen für Bibliotheksentwickler ", 
"url" : "_cds_library_development_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ Bibliotheken verwenden \/ Informationen für Bibliotheksentwickler ", 
"snippet" : "Für das Erstellen, das Referenzieren, das Verschlüsseln und Schützen von Bibliotheken wie auch das Dokumentieren sollten Sie unbedingt bestimmte Regeln einhalten, um Konsistenzprobleme zu vermeiden und den Anwender ausreichend zu unterstützen. Die nachfolgende Beschreibung gibt nur einen Überblick ü...", 
"body" : "Für das Erstellen, das Referenzieren, das Verschlüsseln und Schützen von Bibliotheken wie auch das Dokumentieren sollten Sie unbedingt bestimmte Regeln einhalten, um Konsistenzprobleme zu vermeiden und den Anwender ausreichend zu unterstützen. Die nachfolgende Beschreibung gibt nur einen Überblick über die Möglichkeiten der Bibliotheksentwicklung. Eine weiterführende detaillierte Beschreibung zu diesen Themen finden Sie in den Richtlinien für die Bibliotheksentwicklung „LibDevSummary“. Für weitere Informationen siehe: Bibliotheken verwendenAllgemeines Sie können für Bibliotheken Kategorien definieren. Die Bibliotheken werden dann im Bibliotheksrepository unterhalb dieser Kategorien dargestellt. Für weitere Informationen zum Anlegen von Bibliothekskategorien siehe: Library Categories Sie können für eine Bibliothek einen Namensraum definieren, um einen eindeutigen Zugriff auf die eingebundenen Objekte zu ermöglichen. Durch das Hinzufügen des Namensraums vor dem Bausteinnamen wird ein Zugriff eindeutig: <namespace>.<variable name> Beispiel: AC.Module Sie können die POUs nicht verschlüsselter Bibliotheken ( *.library ) durch einen Doppelklick auf den jeweiligen Eintrag im Bibliotheksverwalter öffnen. Sie können folgende Bibliothekstypen erzeugen: *.library : Implementierungsbibliothek (Quellcode der Bibliothek) *.compiled-library , *.compiled-library-v3 : Geschützte Bibliothek Der Quellcode ist nicht mehr zugänglich. *_Itfs.library : Interfacebibliothek Enthält nur Objekte, die der Schnittstellendefinition einer Komponente dienen (beispielsweise Konstanten, Strukturen, Schnittstellen) und keinen Code generieren *_Cnt.library : Containerbibliothek Enthält keine Programmierbausteine, sondern ausschließlich andere Bibliotheken Dient somit zur bequemen Einbindung eines ganzen Sets von Bibliotheken, deren Bausteine auf oberster Ebene der Containerbibliothek veröffentlicht werden Sie können externe Bibliotheken in die Applikation einbinden. Externe Bibliotheken werden außerhalb von CODESYS in einer anderen Programmiersprache wie beispielsweise C programmiert. Schutz von Bibliotheken Quellcode-Schutz Durch das Bereitstellen einer Bibliothek im „compiled-library“-Format ist der Quellcode der Bibliotheksbausteine nach Einbinden der Bibliothek in ein Projekt nicht mehr sichtbar. Signierung Ab CODESYS V3 SP15 wird für die Signierung von Bibliotheksprojekten ( *.compiled-library-v3 ) immer ein Zertifikat verwendet. Über eine Einstellung im Security-Screen kann die Signierung erzwungen werden. Dann benötigen Sie zum Erzeugen einer übersetzten Bibliothek ein für Codesignierung geeignetes Zertifikat in Ihrem Benutzerprofil. Für Bibliotheksprojekte, die mit CODESYS < V3 SP15 kompatibel sein müssen ( *.compiled-library ), ist nur die weniger sichere Signierung mit einem privaten Schlüssel und einem zugehörigen Token möglich. Diese veraltete Methode sollte nur nur noch aus Kompatibilitätsgründen verwendet werden und erfolgt über die Registerkarte Signieren der Projektinformationen . Hinweis: Für das Signieren von Bibliotheken sollten Sie die Compilerversion 3.5.15.0 oder höher verwenden, da dadurch ein besseres Speicherformat genutzt wird. Lizenzierung Sie können Bibliotheken durch eine Lizenz (Dongle oder Soft Container) schützen. Lizenzgeschütze Bibliotheken können in das Bibliotheksrepository installiert werden, für die Verwendung im Projekt muss jedoch die gültige Lizenz auf dem Rechner vorliegen. Die Lizenzverwaltung erfolgt im Lizenz-Manager. Bibliotheksversionen Sie können gleichzeitig mehrere Versionen einer Bibliothek auf dem System installieren. Sie können gleichzeitig mehrere Versionen einer Bibliothek in Ihr Projekt einbinden. Es ist nicht ratsam, das zu tun. In diesem Fall muss unbedingt jeder der Bibliotheken ein eindeutiger Namensraum zugeordnet sein und der Zugriff auf die Symbole muss qualifiziert erfolgen. Beispiele: V1.SendBlob , V2.SendBlob Referenzierte Bibliotheken Sie können eine Bibliothek in andere Bibliotheken einbinden (referenzierte Bibliotheken). Dabei kann die Verschachtelung beliebig tief sein. Sie können festlegen, ob referenzierte Bibliotheken im Bibliotheksverwalter sichtbar sein sollen. Sie können referenzierte Bibliotheken über Bibliotheksplatzhalter einbinden. Damit vermeiden Sie Probleme, die aufgrund von Versionsabhängigkeiten oder der Notwendigkeit, herstellerspezifische Bibliotheken zu verwenden, entstehen können. " }, 
{ "title" : "Hinzufügen einer Bibliothek zur Applikation ", 
"url" : "_cds_adding_libraries_to_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ Bibliotheken verwenden \/ Hinzufügen einer Bibliothek zur Applikation ", 
"snippet" : "Die nachfolgende Anweisung beschreibt, wie Sie beispielsweise die Bibliothek Util in Ihre Applikation einbinden, um die Bibliotheksbausteine dort verwenden zu können. Selektieren Sie den Bibliotheksverwalter und öffnen Sie ihn im Editor mit dem Befehl Projekt → Objekt bearbeiten . Der Bibliotheksver...", 
"body" : "Die nachfolgende Anweisung beschreibt, wie Sie beispielsweise die Bibliothek Util in Ihre Applikation einbinden, um die Bibliotheksbausteine dort verwenden zu können. Selektieren Sie den Bibliotheksverwalter und öffnen Sie ihn im Editor mit dem Befehl Projekt → Objekt bearbeiten . Der Bibliotheksverwalter öffnet im Editor. Führen Sie den Befehl Bibliothek → Bibliothek hinzufügen aus. Es öffnet sich der Dialog Bibliothek hinzufügen . Suchen Sie die Bibliothek, indem Sie die Zeichenfolge „util“ in das Eingabefeld oben eingeben. Es erscheint die Bibliothek Util in der Bibliotheksansicht. Wählen Sie die Bibliothek Util aus und schließen Sie den Dialog mit OK . Die Bibliothek Util ist im Bibliotheksverwalter hinzugefügt. Für weitere Informationen siehe: Bibliotheksbausteine verwenden" }, 
{ "title" : "Hinzufügen einer Bibliothek zum Repository ", 
"url" : "_cds_adding_libraries_to_repository.html", 
"breadcrumbs" : "CODESYS Essentials \/ Bibliotheken verwenden \/ Hinzufügen einer Bibliothek zum Repository ", 
"snippet" : "Die nachfolgende Anweisung beschreibt, wie Sie eine Bibliothek in das Bibliotheksrepository installieren. Wählen Sie den Befehl Tools → Bibliotheksrepository . Es öffnet der Dialog Bibliotheksrepository . Klicken Sie auf die Schaltfläche Installieren . Wählen Sie die Bibliothek aus, die Sie installi...", 
"body" : "Die nachfolgende Anweisung beschreibt, wie Sie eine Bibliothek in das Bibliotheksrepository installieren. Wählen Sie den Befehl Tools → Bibliotheksrepository . Es öffnet der Dialog Bibliotheksrepository . Klicken Sie auf die Schaltfläche Installieren . Wählen Sie die Bibliothek aus, die Sie installieren wollen. Dabei können Sie einen Dateifilter setzen. Klicken Sie auf Öffnen . Die Bibliothek wird im Repository hinzugefügt. Die Bibliothek kann nun im Bibliotheksverwalter hinzugefügt werden. " }, 
{ "title" : "Bibliotheksdatei exportieren ", 
"url" : "_cds_exporting_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ Bibliotheken verwenden \/ Bibliotheksdatei exportieren ", 
"snippet" : "Sie können eine Bibliothek aus dem Bibliotheksverwalter eines Projekts oder aus dem Bibliotheksrepository exportieren und als Datei auf der Festplatte ablegen. Export aus dem Bibliotheksverwalter Öffnen Sie in einem Projekt einen Bibliotheksverwalter einer Applikation. Selektieren Sie im Bibliotheks...", 
"body" : "Sie können eine Bibliothek aus dem Bibliotheksverwalter eines Projekts oder aus dem Bibliotheksrepository exportieren und als Datei auf der Festplatte ablegen. Export aus dem Bibliotheksverwalter Öffnen Sie in einem Projekt einen Bibliotheksverwalter einer Applikation. Selektieren Sie im Bibliotheksverwalter eine Bibliothek. Wählen Sie aus dem Kontextmenü den Befehl Exportieren. Der Dialog Bibliothek exportieren öffnet sich. Wenn die ausgewählte Bibliothek nicht nur als übersetzte Bibliothek, sondern auch im „Source“-Format im Projekt eingebunden ist, sind beide Dateitypen in der Auswahlliste bei Dateityp , ansonsten zeigt der Filter automatisch den vorliegenden Typ an: Bibliotheken (*.library) oder Übersetzte Bibliotheken (*.compiled-library) . Wählen Sie den Dateityp und Ablageort und klicken Sie auf die Schaltfläche Speichern . Export aus dem Bibliotheksrepository Öffnen Sie das CODESYS - Bibliotheksrepository (Menü Tools ). Selektieren Sie im Fenster der installierten Bibliotheken eine Bibliotheksversion. Klicken Sie auf die Schaltfläche Exportieren . Der Dialog Bibliothek exportieren öffnet sich. wie Schritt 4 und 5 bei „Export aus dem Bibliotheksverwalter“ " }, 
{ "title" : "Bibliotheksplatzhalter aktualisieren ", 
"url" : "_cds_update_library_placeholders.html", 
"breadcrumbs" : "CODESYS Essentials \/ Bibliotheken verwenden \/ Bibliotheksplatzhalter aktualisieren ", 
"snippet" : "Wenn ein Projekt Platzhalterbibliotheken verwendet, dann kann es passieren, dass bei einem späteren Laden die Platzhalter nicht mehr automatisch aufgelöst werden können. Dann wird der Ladeprozess mit Fehler beendet. Im Meldungsfenster werden Sie darüber detailliert informiert. Dort ist aufgelistet, ...", 
"body" : "Wenn ein Projekt Platzhalterbibliotheken verwendet, dann kann es passieren, dass bei einem späteren Laden die Platzhalter nicht mehr automatisch aufgelöst werden können. Dann wird der Ladeprozess mit Fehler beendet. Im Meldungsfenster werden Sie darüber detailliert informiert. Dort ist aufgelistet, um welche Bibliothek es sich handelt und welche Applikationen betroffen sind. Außerdem stellt die Meldung eine Quickfix-Schaltfläche mit hilfreichen Befehlen bereit. Befehl Platzhalter <Bibliotheksname> auf neueste Version aktualisieren : Aktualisiert die feste Version der Bibliothek auf die neueste Version Befehl Dialog \"Platzhalter\" des Bibliotheksverwalters öffnen : In diesem Dialog können Sie die Auflösung des Platzhalters bearbeiten. Für weitere Informationen siehe: PlatzhalterBeispiel Projekt mit nicht aufgelösten Bibliotheksplatzhaltern " }, 
{ "title" : "Geräte verwalten ", 
"url" : "_cds_struct_managing_devices.html", 
"breadcrumbs" : "CODESYS Essentials \/ Geräte verwalten ", 
"snippet" : "CODESYS verwaltet die installierten Geräte im sogenannten Geräte-Repository . Ein Geräte-Repository ist ein definierter Platz im Dateisystem, der bei der CODESYS -Installation standardmäßig als „System-Repository“ mit einem bestimmten Pfad vorgegeben ist. Über den Dialog Geräte-Repository installier...", 
"body" : "CODESYS verwaltet die installierten Geräte im sogenannten Geräte-Repository . Ein Geräte-Repository ist ein definierter Platz im Dateisystem, der bei der CODESYS -Installation standardmäßig als „System-Repository“ mit einem bestimmten Pfad vorgegeben ist. Über den Dialog Geräte-Repository installieren Sie zusätzliche Geräte oder löschen vorhandene. Die Installation eines Geräts erfolgt durch das Einlesen der Gerätebeschreibungsdateien. In diesen Dateien sind die Eigenschaften eines Geräts hinsichtlich Konfigurierbarkeit, Programmierbarkeit und möglichen Verbindungen zu anderen Geräten festgelegt. Sie können die im Geräte-Repository vorhandenen Geräte in Ihrem Projekt verwenden und in den Gerätebaum einfügen. " }, 
{ "title" : "Geräte installieren ", 
"url" : "_cds_installing_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ Geräte verwalten \/ Geräte installieren ", 
"snippet" : "Installieren Sie ein Gerät in das Geräte-Repository , um es anschließend in Ihrem Projekt einbinden zu können. Wählen Sie den Menübefehl Tools → Geräte-Repository . Der Dialog Geräte-Repository öffnet sich. Selektieren Sie den Speicherort, in den Sie installieren wollen. Standardmäßig ist System Rep...", 
"body" : "Installieren Sie ein Gerät in das Geräte-Repository , um es anschließend in Ihrem Projekt einbinden zu können. Wählen Sie den Menübefehl Tools → Geräte-Repository . Der Dialog Geräte-Repository öffnet sich. Selektieren Sie den Speicherort, in den Sie installieren wollen. Standardmäßig ist System Repository eingestellt. Klicken Sie auf die Schaltfläche Installieren . Der Dialog Installiere Gerätebeschreibung öffnet sich. Wählen Sie den Dateipfad der Gerätebeschreibung. Wählen Sie den Dateityp-Filter der gewünschten Gerätebeschreibung. Alle Gerätebeschreibungen des ausgewählten Dateityps werden aufgelistet. Selektieren Sie die gewünschte Gerätebeschreibung und klicken Sie auf Öffnen . CODESYS fügt die Gerätebeschreibung in Ihr Geräte-Repository in die passende Kategorie ein. Wenn während der Installation Fehler auftreten (zum Beispiel fehlende Dateien, die von der Gerätebeschreibung referenziert werden), zeigt CODESYS die Fehlermeldungen im unteren Teil des Geräte-Repository-Dialogs an. " }, 
{ "title" : "Packages und Lizenzen verwalten ", 
"url" : "_cds_struct_managing_packages_and_licenses.html", 
"breadcrumbs" : "CODESYS Essentials \/ Packages und Lizenzen verwalten ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Lizenzierung in CODESYS ", 
"url" : "_cds_struct_managing_packages_and_licenses.html#UUID-68845ac9-5153-8336-6398-73964f8ffc47_section-idm4593467822192032668684730962", 
"breadcrumbs" : "CODESYS Essentials \/ Packages und Lizenzen verwalten \/ Lizenzierung in CODESYS ", 
"snippet" : "Zusätzlich zu der Standardinstallation von CODESYS gibt es kosten- und lizenzpflichtige Zusatzprodukte. Die Lizenzen für solche Produkte erhalten Sie von CODESYS GmbH in Form von Ticket-Nummern und können sie über den CODESYS Lizenz-Manager installieren. Der Lizenz-Manager speichert die Lizenzinform...", 
"body" : "Zusätzlich zu der Standardinstallation von CODESYS gibt es kosten- und lizenzpflichtige Zusatzprodukte. Die Lizenzen für solche Produkte erhalten Sie von CODESYS GmbH in Form von Ticket-Nummern und können sie über den CODESYS Lizenz-Manager installieren. Der Lizenz-Manager speichert die Lizenzinformationen auf einem USB-Hardware-Dongle ( CODESYS Dongle) oder in einem Softcontainer, der im lokalen CodeMeter Kontrollzentrum registriert ist. Der Dongle muss an Ihrem lokalen PC aufgesteckt sein. Im Lizenz-Repository können Sie zu jeder Ticket-Nummer die aktuellen Informationen vom zentralen Lizenz-Server abrufen. Hier erhalten Sie beispielsweise Auskunft darüber, ob eine Lizenz noch aktivierbar ist oder zurückgegeben werden kann. Es gibt lizenzpflichtige Plug-ins, die jedoch mit eingeschränkter Funktionalität auch ohne Lizenz verwendet werden können. In solchen Fällen erscheinen an plug-in-spezifischen Stellen Meldungen zur fehlenden Lizenz. Beispiele für solche Plug-ins (Add-ons): CODESYS Git , CODESYS SVN , CODESYS UML aus der Professional Developer Edition. Netzwerklizenzen : Eine im lokalen CodeMeter Kontrollzentrum eingetragene Lizenz kann als Netzwerklizenz bereitgestellt werden. Dazu wird der lokale Rechner als Netzwerkserver konfiguriert, auf den berechtigte Nutzer zugreifen und die Lizenz verwenden können. Falls Sie diese Konfiguration vornehmen müssen, öffnen Sie zunächst das CodeMeter Kontrollzentrum und dort über Datei - WebAdmin den CodeMeter WebAdmin-Browser. Im Browser sehen Sie unter Container die aktuell installierten Dongles\/Softcontainer. Über Einstellungen - Basis können Sie ihren lokalen Rechner als Basisserver bereitstellen. Sehen Sie dazu bitte auch die aktuelle Hilfe zu WIBU CodeMeter: Beispiel: Setting up CodeMeter for Network Server access to licenses . Weitere detaillierte Informationen zu CodeMeter finden Sie auf der Homepage von Wibu-Systems . Lizenzprüfung beim Starten von CODESYS Während des Startens überprüft CODESYS nach der Profilauswahl, ob im gewählten Profil lizenzpflichtige Plug-ins enthalten sind. Wenn keine lizenzpflichtigen Plug-ins im Profil enthalten sind, startet CODESYS wie gewohnt ohne Meldung. Wenn lizenzpflichtige Plug-ins im Profil enthalten sind, startet CODESYS ebenfalls ohne Meldung, wenn ein Dongle mit den benötigten Lizenzen an der USB-Schnittstelle des Computers angesteckt ist, oder ein Softcontainer mit den Lizenzen registriert ist. Wenn lizenzpflichtige Plug-ins im Profil enthalten sind, aber kein Dongle\/Softcontainer vorhanden ist, oder eine nötige Lizenz nicht gefunden wird, dann erscheint beim Start von CODESYS der Dialog Fehlende Lizenz . Sie können entscheiden, ob CODESYS ohne die betroffenen Plug-ins gestartet werden soll. Hinweis: Beim Start über die Kommandozeile wird dieser Dialog übersprungen, wenn Sie in der Kommandozeile die Option --skipunlicensedplugins angeben. In diesem Fall werden Plug-ins ohne erforderliche Lizenz automatisch nicht geladen. Lizenzprüfung im laufenden Betrieb Während CODESYS läuft, wird alle fünf Minuten geprüft, ob die nötigen Lizenzen vorhanden sind. Wenn eine Lizenz fehlt, weil beispielsweise zwischenzeitlich der Dongle abgezogen wurde, erscheint der Dialog Fehlende Lizenz . Bei Add-ons, die auch ohne Lizenz verwendet werden können, wird je nach vorhandener oder fehlender Lizenz der Funktionsumfang angepasst. Im Fall eines abgezogenen Dongles haben Sie folgende Möglichkeiten: Stecken Sie den Dongle wieder auf und drücken Sie Wiederholen : Wenn der Dongle die fehlenden Lizenzen trägt, können Sie nun normal weiterarbeiten. Aktuelles Projekt speichern und beenden : CODESYS speichert das Projekt und schließt sich. Beenden : CODESYS schließt sich ohne das Projekt zu speichern. Wenn Sie den Lizenz-Dongle entfernen, nachdem das CODESYS Plug-in geladen wurde, erscheint eine Fehlermeldung. Um das Problem zu beheben, stecken Sie den Donlge wieder auf und betätigen Sie die Schaltfläche Wiederholen . Wenn der Dongle eine gültige Lizenz enthält, schließt sich der Dialog und Sie können normal weiterarbeiten. Mit der Schaltfläche Abbrechen beenden Sie CODESYS . " }, 
{ "title" : "Lizenz-Manager ", 
"url" : "_cds_struct_managing_packages_and_licenses.html#UUID-68845ac9-5153-8336-6398-73964f8ffc47_section-idm459346742314563266868591645", 
"breadcrumbs" : "CODESYS Essentials \/ Packages und Lizenzen verwalten \/ Lizenz-Manager ", 
"snippet" : "Mit dem Lizenz-Manager in CODESYS können Sie die Lizenzen für Zusatzprodukte auf einem CODESYS -Dongle oder in einem Soft-Container verwalten. Ein Soft-Container bezeichnet das Software-Pendant zu einem Dongle. Damit können Hardware-Lizenzen, auch ohne Dongle, an einen einzelnen PC gebunden werden. ...", 
"body" : "Mit dem Lizenz-Manager in CODESYS können Sie die Lizenzen für Zusatzprodukte auf einem CODESYS -Dongle oder in einem Soft-Container verwalten. Ein Soft-Container bezeichnet das Software-Pendant zu einem Dongle. Damit können Hardware-Lizenzen, auch ohne Dongle, an einen einzelnen PC gebunden werden. Wählen Sie im Lizenzmanager Workstation für die Lizenzierung Ihres Arbeitsplatzes und wählen Sie Gerät , wenn Sie die Lizenz auf Ihrem Gerät aktivieren möchten. " }, 
{ "title" : "Package Manager ", 
"url" : "_cds_struct_managing_packages_and_licenses.html#UUID-68845ac9-5153-8336-6398-73964f8ffc47_section-idm4531453328910432668687302335", 
"breadcrumbs" : "CODESYS Essentials \/ Packages und Lizenzen verwalten \/ Package Manager ", 
"snippet" : "CODESYS bietet mit dem Package Manager eine Funktionalität zum Erweitern der Standardinstallation von CODESYS mit zusätzlichen Features und Konfigurationseinstellungen. Das Konzept des Package Managers ähnelt dem Konzept typischer Windows-Installationsmechanismen. Ein Package ist eine ZIP-Datei mit ...", 
"body" : "CODESYS bietet mit dem Package Manager eine Funktionalität zum Erweitern der Standardinstallation von CODESYS mit zusätzlichen Features und Konfigurationseinstellungen. Das Konzept des Package Managers ähnelt dem Konzept typischer Windows-Installationsmechanismen. Ein Package ist eine ZIP-Datei mit der Erweiterung *.package. Mögliche Package-Bestandteile Plug-ins Bibliotheken Gerätebeschreibungen Lieferantenbeschreibungen Profile Informationsprofile Profiländerungen Dateien Erweiterungen zur Konfiguration des Menüs, der Werkzeugleiste, der Tastenkürzel, der Ansichten Module zur Hilfe Komplette Menükonfigurationen für spezielle Profile Komplette Werkzeugleisten-Konfigurationen für spezielle Profile Komplette Tastatur-Konfigurationen für spezielle Profile Optionen Bibliotheksprofile Sie können die Prüfsumme , die CODESYS im Dialog Details des Packages Managers und im Dialog Installation - Lizenzvereinbarung des Installationsassistenten anzeigt, mit der Package-Prüfsumme des Package-Anbieters vergleichen. Damit stellen Sie sicher, dass Sie ein Original-Package installiert haben. Ab V3.5 SP13 prüft CODESYS bei der Installation des Entwicklungssystems, ob bereits eine ältere Version installiert ist. Wenn dies der Fall ist, erhalten Sie beim ersten Starten des Entwicklungssystems den Dialog Importassistent zum Übernehmen der in der älteren Version vorliegenden Package-Installationen. " }, 
{ "title" : "Package installieren\/deinstallieren ", 
"url" : "_cds_installing_package.html", 
"breadcrumbs" : "CODESYS Essentials \/ Packages und Lizenzen verwalten \/ Package installieren\/deinstallieren ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS Installer verwenden (Standard) ", 
"url" : "_cds_installing_package.html#UUID-98af030d-c9df-9805-ad81-f774bb1247ba_section-idm4675118379435233494746701215", 
"breadcrumbs" : "CODESYS Essentials \/ Packages und Lizenzen verwalten \/ Package installieren\/deinstallieren \/ CODESYS Installer verwenden (Standard) ", 
"snippet" : "Wenn der CODESYS Installer auf Ihrem Rechner installiert ist, wird er für die Installation\/Deinstallation von Packages\/Add-ons verwendet. Beispielsweise wird er in diesem Fall bei Bedarf auch vom Projektprüfungsassistenten gestartet. Für weitere Informationen zum Installer siehe: CODESYS Installer W...", 
"body" : "Wenn der CODESYS Installer auf Ihrem Rechner installiert ist, wird er für die Installation\/Deinstallation von Packages\/Add-ons verwendet. Beispielsweise wird er in diesem Fall bei Bedarf auch vom Projektprüfungsassistenten gestartet. Für weitere Informationen zum Installer siehe: CODESYS Installer Wenn im Projekt Objekte hinzugefügt werden, die weitere Add-on-Installationen verlangen, reagiert CODESYS folgendermaßen: Im Meldungsfenster erscheint in der Meldungskategorie Erforderliche Add-ons eine entsprechende Meldung in der Statusleiste erscheint ein gelb hinterlegtes Feld mit dem Text <Anzahl> fehlende Add-ons . Ein Doppelklick auf dieses Feld öffnet den Dialog Erforderliche Add-ons , in dem die fehlenden Add-ons aufgelistet sind. Sie können Packages zur Nachinstallation auswählen und mit der Schaltfläche Installieren den CODESYS Installer starten. " }, 
{ "title" : "Package Manager verwenden, falls der CODESYS Installer nicht verfügbar ist ", 
"url" : "_cds_installing_package.html#UUID-98af030d-c9df-9805-ad81-f774bb1247ba_section-idm467511829340963349474202387", 
"breadcrumbs" : "CODESYS Essentials \/ Packages und Lizenzen verwalten \/ Package installieren\/deinstallieren \/ Package Manager verwenden, falls der CODESYS Installer nicht verfügbar ist ", 
"snippet" : "Wenn der CODESYS Installer nicht auf Ihrem Rechner installiert ist, steht direkt der Package Manager zur Verfügung. Sehen Sie dazu folgende Anleitung: Voraussetzung: Sie haben den Befehl Tools → Package Manager ausgewählt. Der Dialog Package Manager ist geöffnet. Installieren eines Packages Klicken ...", 
"body" : "Wenn der CODESYS Installer nicht auf Ihrem Rechner installiert ist, steht direkt der Package Manager zur Verfügung. Sehen Sie dazu folgende Anleitung: Voraussetzung: Sie haben den Befehl Tools → Package Manager ausgewählt. Der Dialog Package Manager ist geöffnet. Installieren eines Packages Klicken Sie auf Installieren . Wählen Sie im Dialog Öffnen ein Package aus dem Dateiverzeichnis aus und klicken Sie auf Öffnen . Der Dialog Package-Signaturen überprüfen öffnet sich. Der Dialog und zeigt Informationen dazu an, ob und wie das gewählte Package signiert ist. Weitere Informationen zur Signierung des Packages finden Sie im Tooltip. Wenn Sie ein Package doppelklicken, werden in einem Dialog noch weitere ausführliche Informationen zur Signierung des Packages angezeigt. Wenn es sich um ein selbstsigniertes oder unsigniertes Package handelt, müssen Sie die Installation dieses Packages durch Aktivierung der Option Unsignierte und selbstsignierte Packages erlauben explizit erlauben. Wenn Sie mit der angezeigten Signierung einverstanden sind, klicken Sie auf OK . Der Installationsassistent öffnet sich. Im Dialog Installation - Lizenzvereinbarung zeigt CODESYS auch die Prüfsumme des Packages an. Wenn Sie im letzten Dialog des Installationsassistenten auf Fertigstellen klicken, erscheint unten im Package Manager die Anzeige 1 anstehende Installation(en) . Das Package wird mit dem Symbol gekennzeichnet. Das Package liegt jetzt entpackt auf dem Rechner und ist bereit für die Installation. Schließen Sie alle CODESYS -Instanzen. Der Package Manager führt die Installation des Packages in CODESYS durch. Wenn Sie vor Beenden der Installation eine Zusammenfassung der Installation angezeigt haben möchten, klicken Sie im Dialog Installation - Setup abgeschlossen auf Weiter . Um anschließend die Installation abzuschließen, klicken Sie in Installation - Zusammenfassung auf Fertigstellen . Wenn Sie die Installation abschließen möchten, ohne vorher die Zusammenfassung angezeigt zu bekommen, klicken Sie im Dialog Installation - Installation abgeschlossen auf Fertigstellen . Wenn das Package CODESYS Package Designer installiert ist, und das Package, das Sie installieren möchten, eine neuere Version des Package Manager benötigt, meldet dies der Installationsassistent. Die benötigte Version des Package Manager können Sie im CODESYS Store International laden. Deinstallieren eines Packages Selektieren Sie das Package. Klicken Sie auf Deinstallieren . Der Assistent öffnet sich und führt Sie durch die Deinstallation des Packages. Wenn Sie im letzten Dialog des Installationsassistenten auf Fertigstellen geklickt haben, erscheint unten im Package Manager die Anzeige 1 anstehende Installation(en) . Das Package wird mit dem Symbol gekennzeichnet. Schließen Sie alle CODESYS -Instanzen. Der Package Manager führt die Deinstallation des Packages CODESYS durch. Klicken Sie im Dialog Deinstallation auf Fertigstellen , um die Deinstallation abzuschließen. Voraussetzung: Sie haben den Befehl Tools → Package Manager ausgewählt und der Dialog Package Manager ist geöffnet. " }, 
{ "title" : "Produkte lizenzieren ", 
"url" : "_cds_installing_license.html", 
"breadcrumbs" : "CODESYS Essentials \/ Packages und Lizenzen verwalten \/ Produkte lizenzieren ", 
"snippet" : "Die Nutzung von vielen CODESYS -Produkten ist lizenzgeschützt, so dass Sie ein Produkt erst aktivieren müssen, bevor Sie es starten. Ein Add-on-Produkt, das den Leistungsumfang des CODESYS Development System erweitert, wird üblicherweise mit einer Arbeitsplatzlizenz aktiviert. Die Lizenzierung erfol...", 
"body" : "Die Nutzung von vielen CODESYS -Produkten ist lizenzgeschützt, so dass Sie ein Produkt erst aktivieren müssen, bevor Sie es starten. Ein Add-on-Produkt, das den Leistungsumfang des CODESYS Development System erweitert, wird üblicherweise mit einer Arbeitsplatzlizenz aktiviert. Die Lizenzierung erfolgt über den CODESYS Development System Security Key, ein Dongle, der alle Lizenzen ihres Arbeitsplatzes verwaltet. Alternativ wird für Produkte die Lizensierung auf einem Soft-Container unterstützt. Daneben gibt es die SL-Produkte, die den Leistungsumfang der CODESYS Control-Systeme erweitern. Diese Systeme werden mit einer Einzelgerätelizenz aktiviert. Dabei wird ein Aktivierungscode, der als Lizenzaktivierungsdatei zur Verfügung gestellt wird, direkt auf dem Zielgerät installiert. Auch die Lizenzverwaltung auf einem Gerät erfolgt auf einem Softcontainer im Gerät, oder wenn das Gerät dies unterstützt, auf einem Dongle am Gerät. Seit CODESYS V3.5 SP13 können sowohl Lizenzen von Add-on-Produkten auf dem lokalen Computer, wie auch Einzelgerätelizenzen einheitlich über den CODESYS Lizenz-Manager verwaltet werden. Für Geräte mit einer eindeutigen Seriennummer kann der Lizenz-Manager, im Fall des Verlusts der Lizenzinformationen auf dem Gerät, die Lizenz aus einer automatisch abgelegten Lizenzsicherungsdatei reaktivieren. Lizenzieren Sie Ihre Produkte wenn möglich über eine Onlineaktivierung anstelle einer Offlineaktivierung. Die Lizenzaktualisierung für Produkt-Abonnements erfolgt automatisch. Sie sehen den aktuellen Lizenzstatus im Lizenz-Manager . " }, 
{ "title" : "Onlineaktivierung ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_52e8998a938fd111c0a8646342ceb317", 
"breadcrumbs" : "CODESYS Essentials \/ Packages und Lizenzen verwalten \/ Produkte lizenzieren \/ Onlineaktivierung ", 
"snippet" : "Eine Aktivierung ist im CODESYS Development System im Dialog Lizenz-Manager möglich. Voraussetzung dafür ist, dass Ihr Entwicklungssystem einen Internetzugang hat. Das Zielsystem selbst benötigt keinen Internetzugang. Alternativ können Sie Ihre Lizenz in unserem Webdepot unter https:\/\/license.codesy...", 
"body" : "Eine Aktivierung ist im CODESYS Development System im Dialog Lizenz-Manager möglich. Voraussetzung dafür ist, dass Ihr Entwicklungssystem einen Internetzugang hat. Das Zielsystem selbst benötigt keinen Internetzugang. Alternativ können Sie Ihre Lizenz in unserem Webdepot unter https:\/\/license.codesys.com\/index.php aktivieren. Onlineaktivierung im WebDepot " }, 
{ "title" : "Auswahl des Containers ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_section-idm4533120839552033964699368144", 
"breadcrumbs" : "CODESYS Essentials \/ Packages und Lizenzen verwalten \/ Produkte lizenzieren \/ Auswahl des Containers ", 
"snippet" : "Die Firm Codes ab 100.000 wurden bisher für die hardwarebasierte Aktivierung (CmDongles) und die Firm Codes ab 5.000.000 für die softwarebasierte Aktivierung (CmActLicenses und CmSoftLicenses) verwendet. Es gibt mittlerweile neue, universell verwendbare \"Universal Firm Codes\", die im Bereich ab 6.00...", 
"body" : "Die Firm Codes ab 100.000 wurden bisher für die hardwarebasierte Aktivierung (CmDongles) und die Firm Codes ab 5.000.000 für die softwarebasierte Aktivierung (CmActLicenses und CmSoftLicenses) verwendet. Es gibt mittlerweile neue, universell verwendbare \"Universal Firm Codes\", die im Bereich ab 6.000.000 liegen. Die \"Universal Firm Codes\" können sowohl in hardwarebasierten als auch softwarebasierten Containern programmiert werden. Firm Codes für die verschiedenen Container-Typen: Container-Typ 128-xxx 1xx.xxx = CmDongle Firm Code, nur in CmDongles einspielbar (Hardware) 5.xxx.xxx = CmActLicense Firm Code, nur als CmActLicenses möglich (Software) Container-Typ 130-xxx 6.xxx.xxx = Universal Firm Code für CmDongle, CmActLiceneses und CmSoftLicenses Wir empfehlen, wenn möglich, den neuen \"Universal Firm Code\" zu verwenden, da dieser Firm Code neue Funktionen unterstützt. " }, 
{ "title" : "Offlineaktivierung ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_8604f60bf98a3916c0a8652d01741064", 
"breadcrumbs" : "CODESYS Essentials \/ Packages und Lizenzen verwalten \/ Produkte lizenzieren \/ Offlineaktivierung ", 
"snippet" : "Wenn Ihr Arbeitsplatzcomputer keinen Internetzugang hat, können Sie mit Hilfe einer Lizenzaktivierungsdatei Produkte aktivieren. Sie erhalten die Datei vom CODESYS -Lizenzserver. Dazu verbinden Sie sich von einem beliebigen internetfähigen Computer aus mit dem Server und fordern die Datei an. Dann ü...", 
"body" : "Wenn Ihr Arbeitsplatzcomputer keinen Internetzugang hat, können Sie mit Hilfe einer Lizenzaktivierungsdatei Produkte aktivieren. Sie erhalten die Datei vom CODESYS -Lizenzserver. Dazu verbinden Sie sich von einem beliebigen internetfähigen Computer aus mit dem Server und fordern die Datei an. Dann übertragen Sie die Datei mit einem beliebigen Speichermedium auf ihren Arbeitsplatzcomputer. Dort erfolgt die Produktaktivierung wie üblich im CODESYS Development System , sowohl für Arbeitsplatzlizenzen als auch für Einzelgerätelizenzen. Wenn Sie Zugang zu einem internetfähigen Computer haben, auf dem aber das CODESYS Development System nicht installiert ist, können Sie alternativ das CodeMeter Kontrollzentrum von Wibu-Systems aufrufen, um die Lizenz zu aktivieren. Außerdem können Sie bei Zielsystemen, die wie CODESYS Control Win oder CODESYS Control RTE auf Windows basieren, direkt auf einem Zielgerät eine Einzelgerätelizenz aktivieren. Das kann hilfreich sein, wenn Ihnen kein Entwicklungssystem mit CODESYS Development System zur Verfügung steht. Sie können dann die Lizenzierung über das CodeMeter Kontrollzentrum durchführen, oder Sie können die Lizenz über einen Browser aktivieren. Denn CodeMeter ist bei Windows basierten Zielsystemen auf dem Zielsystem installiert. Das CodeMeter Kontrollzentrum steuert den CodeMeter-Dienst und ist im Lieferumfang des CODESYS -Setups enthalten. " }, 
{ "title" : "Onlineaktivieren einer Add-on-Lizenz auf dem lokalen Computer ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_a896b93ef98a374cc0a8652d00afc374", 
"breadcrumbs" : "CODESYS Essentials \/ Packages und Lizenzen verwalten \/ Produkte lizenzieren \/ Onlineaktivieren einer Add-on-Lizenz auf dem lokalen Computer ", 
"snippet" : "Nachfolgende Anweisung beschreibt die Lizenzierung durch einen Dongle. Die Lizenzierung über einen Softcontainer erfolgt analog. Voraussetzung: Sie haben auf dem Computer, auf dem Sie die Lizenz installieren wollen, einen Internetzugang und das CODESYS Development System ist auf dem Rechner installi...", 
"body" : "Nachfolgende Anweisung beschreibt die Lizenzierung durch einen Dongle. Die Lizenzierung über einen Softcontainer erfolgt analog. Voraussetzung: Sie haben auf dem Computer, auf dem Sie die Lizenz installieren wollen, einen Internetzugang und das CODESYS Development System ist auf dem Rechner installiert. Am Computer steckt ein Dongle. Wählen Sie den Befehl Tools → Lizenz-Manager . Der Wizard startet mit dem Dialog Lizenz-Manager - Zielgerät auswählen . Wählen Sie Workstation als Zielgerät, klicken Sie Weiter , wählen dann im Dialog Lizenz-Manager - Container auswählen die Option Dongle , und klicken Sie wieder auf Weiter . Der Dialog Lizenz-Manager öffnet sich und zeigt das zu lizenzierende Produkt im Fenster Produkte als nicht lizensiert an. Selektieren Sie das Produkt und klicken Sie die Schaltfläche Lizenzen installieren . Der Assistent Lizenzen auf Workstation Dongle <Dongle-ID> installieren - Operation wählen erscheint. Wählen Sie Lizenz aktivieren und klicken Sie auf Weiter . Der Dialog Lizenzen auf Workstation Dongle <Dongle-ID> installieren - Lizenzen aktivieren erscheint. Geben Sie die Ticket-ID ein, die Sie vom Softwareanbieter bekommen haben. Die ID besteht aus 5 Blöcken mit jeweils 5 alphanumerischen Zeichen. Wählen Sie den Lizenz-Server aus, der die Lizenz zum Aktivieren des Produkts bereitstellt. Die URL des Servers erhalten Sie vom Softwareanbieter. Klicken Sie auf die Schaltfläche Weiter . Die Verbindung zum Lizenz-Server ( http:\/\/license.codesys.com ) wird aufgebaut. Wenn das angegebene Ticket nur 1 Lizenz enthält, erscheint nach erfolgreichem Abschluss der Serveraktion ein Dialog mit der Bestätigung der Aktivierung. Wenn das angegebene Ticket mehrere Lizenzen enthält, erscheint zunächst der Dialog Lizenzen installieren - Lizenzen auswählen mit der Liste der im Ticket verwalteten Lizenzen. Wählen Sie im Falle von mehreren Lizenzen diejenigen aus, die aktiviert werden sollen, und klicken Sie auf Weiter . Nach erfolgreichem Abschluss der Serveraktion erscheint ein Dialog mit der Bestätigung der Aktivierung. Alternativ Öffnen Sie einen Browser und wählen Sie die Internetseite License Central . Der Dialog Lizenz-Manager öffnet sich. Geben Sie Ihre Lizenznummer ein. Wählen Sie Suchen . Wählen Sie die Schaltfläche Weiter . Die Verbindung zum Lizenz-Server ( http:\/\/license.codesys.com ) wird aufgebaut. " }, 
{ "title" : "Offlineaktivieren einer Add-on-Lizenz auf dem lokalen Computer ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_9c3355c9d43311e7a0b8a97e058b4068", 
"breadcrumbs" : "CODESYS Essentials \/ Packages und Lizenzen verwalten \/ Produkte lizenzieren \/ Offlineaktivieren einer Add-on-Lizenz auf dem lokalen Computer ", 
"snippet" : "Voraussetzung: Sie wollen die Lizenz für ein Add-on Package installieren. Auf dem Computer, auf dem Sie die Lizenz installieren wollen, ist das CODESYS Development System installiert. Der Computer verfügt über keinen Internetzugang. Bei diesem Verfahren erzeugen Sie zunächst in CODESYS auf Ihrem Zie...", 
"body" : "Voraussetzung: Sie wollen die Lizenz für ein Add-on Package installieren. Auf dem Computer, auf dem Sie die Lizenz installieren wollen, ist das CODESYS Development System installiert. Der Computer verfügt über keinen Internetzugang. Bei diesem Verfahren erzeugen Sie zunächst in CODESYS auf Ihrem Ziel-Computer eine Lizenzanforderungsdatei. Diese Datei kopieren Sie anschließend auf einen Computer mit Internetzugang. Auf diesem Computer muss das CodeMeter Kontrollzentrum installiert sein. Über den CODESYS -Lizenzserver erzeugen Sie eine Lizenzaktivierungsdatei, um sie dann auf dem Ziel-Computer zu aktivieren. Nachfolgende Anweisung beschreibt die Lizenzierung durch einen Dongle. Die Lizenzierung über einen Softcontainer erfolgt analog. Wählen Sie den Befehl Tools → Lizenz-Manager . Der Wizard Lizenz-Manager startet. Wählen Sie Workstation als Zielgerät. Klicken Sie auf Weiter und wählen dann Dongle als Container. Klicken Sie wieder auf Weiter . Der Dialog zur Auswahl von Produkt und Container erscheint. Wählen Sie bei Container den Dongle aus, auf dem Sie die Lizenz installieren wollen. Beispiel: Lokal:CmStick [2-2404696] Klicken Sie auf die Schaltfläche Lizenzen installieren . Der Assistent Lizenzen auf Workstation Dongle <Dongle-ID> installieren - Operation wählen erscheint. Wählen Sie die Option Lizenz anfordern und wählen Sie Weiter . Der Assistent Lizenzen auf <Computer> installieren - Lizenz anfordern erscheint. Geben Sie im Eingabefeld Softwareanbieter den Firmcode des Softwareanbieters ein, der die Lizenz zur Aktivierung des Produkts bereitstellt. Alternativ wählen Sie den Namen des Softwareanbieters aus der Combobox aus. Geben Sie den Ort und den Namen der Kontextdatei: ein, beispielsweise CmStick [2-2404696].WibuCmRaC . Klicken Sie auf Fertigstellen . Die Kontextdatei ( *.WibuCmRaC ) wird erzeugt. Kopieren Sie diese Lizenzanforderungsdatei auf einen Computer mit Internetzugang. Öffnen Sie auf diesem Computer den CODESYS -Lizenzserver im Browser ( http:\/\/license.codesys.com ). CODESYS -Lizenzserver: Geben Sie die Nummer des Lizenztickets ein und wählen Sie Suchen . Wählen Sie im Folgedialog Lizenzen aktivieren . Wählen Sie im nächsten Dialog die Bindung für die Lizenz aus. Klicken Sie auf die Grafik mit dem CODESYS Runtime Key (Dongle). Folgender Dialog erscheint: Wählen Sie in dem Dialog den Lizenz-Container aus, beispielsweise 2-2404696 . Wählen Sie Offline-Lizenzübertragung . Folgender Dialog erscheint: Wählen Sie im nächsten Schritt die Lizenzanforderungsdatei aus, die Sie auf dem anderen Computer erzeugt haben und klicken Sie auf Anforderung jetzt hochladen und weiter . Folgender Dialog erscheint: Laden Sie im nächsten Schritt die Lizenzaktualisierungsdatei auf Ihren Computer. Wählen Sie Lizenzaktualisierungsdatei herunterladen . Kopieren Sie die Lizenzaktualisierungsdatei auf den Ziel-Computer. Klicken Sie im Dialog Lizenz-Manager auf die Schaltfläche Lizenzen installieren und wählen Sie die Option Lizenz installieren . Der Dialog Lizenzen auf Workstation Dongle <Dongle-ID> installieren - Lizenz installieren erscheint. Geben Sie den Pfad der Lizenzaktualisierungsdatei im Eingabefeld ein. Beispiel: D:\\Lic\\CmStick [2-2404696].WibuCmRaU Klicken Sie auf Fertigstellen . Die Lizenzaktualisierungsdatei ist auf dem ausgewählten Dongle installiert. " }, 
{ "title" : "Offlineaktivieren eines windowsbasierten Laufzeitsystems ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_bbe1a04a10ae11e897c3e7cd79b8a53c", 
"breadcrumbs" : "CODESYS Essentials \/ Packages und Lizenzen verwalten \/ Produkte lizenzieren \/ Offlineaktivieren eines windowsbasierten Laufzeitsystems ", 
"snippet" : "Sie wollen die Lizenz für ein Laufzeitsystem installieren, das auf Windows basiert. Bei diesem Verfahren erzeugen Sie zunächst über CodeMeter Kontrollzentrum auf Ihrem Ziel-Computer eine Lizenzanforderungsdatei. Diese Datei kopieren Sie anschließend auf einen Rechner mit Internetzugang. Darauf muss ...", 
"body" : "Sie wollen die Lizenz für ein Laufzeitsystem installieren, das auf Windows basiert. Bei diesem Verfahren erzeugen Sie zunächst über CodeMeter Kontrollzentrum auf Ihrem Ziel-Computer eine Lizenzanforderungsdatei. Diese Datei kopieren Sie anschließend auf einen Rechner mit Internetzugang. Darauf muss das CodeMeter Kontrollzentrum installiert sein. Über den CODESYS -Lizenzserver erzeugen Sie eine Lizenzaktivierungsdatei, die Sie auf dem Zielcomputer aktivieren. Ausgangssituation: Auf dem Rechner, auf dem Sie die Lizenz installieren wollen, ist das CODESYS Development System nicht installiert. Der Rechner verfügt über keinen Internetzugang. Öffnen Sie das CodeMeter Kontrollzentrum . Doppelklicken Sie dazu auf das Icon in der Taskleiste (Infobereich). Wählen Sie in der Lizenzübersicht den Lizenzspeicher 3S-Smart Software Solutions Softlicenses . Klicken Sie auf die Schaltfläche Lizenz aktivieren . Der Assistent CmFAS öffnet sich. Klicken Sie auf Weiter . Eine Liste der möglichen Aktionen erscheint. Wählen Sie Lizenzanforderung erzeugen und klicken Sie auf Weiter . Wählen Sie einen Namen für die Lizenzanforderungsdatei und speichern Sie sie mit Anwenden . Schließen Sie den Dialog. Die Lizenzanforderungsdatei wird erzeugt. Beispiel: 32767-4241603201.WibuCmRaC Kopieren Sie diese Lizenzanforderungsdatei auf einen Computer mit Internetzugang. Öffnen Sie auf diesem Computer den CODESYS -Lizenzserver im Browser. CODESYS -Lizenzserver: Geben Sie die Nummer des Lizenztickets ein und klicken Sie auf Next . Klicken Sie im Folgedialog auf Lizenzen aktivieren . Wählen Sie im nächsten Dialog die Bildung für die Lizenz aus. Klicken Sie auf die Grafik mit dem CODESYS Software Key (Soft-Container). Folgender Dialog erscheint: Wählen Sie in dem Dialog den Lizenz-Container aus. Beispiel: 32767-4241603201 (3S-Smart Software Solutions Softlicenses Klicken Sie auf Offline-Lizenzübertragung . Folgender Dialog erscheint: Wählen Sie im nächsten Schritt die Lizenzanforderungsdatei aus, die Sie auf dem anderen Computer erzeugt haben, und klicken Sie auf Anforderung jetzt hochladen und weiter . Folgender Dialog erscheint: Laden Sie im nächsten Schritt die Lizenzaktualisierungsdatei auf Ihren Computer. Klicken Sie auf Lizenzaktualisierungsdatei herunterladen . Der Dialog zum Speichern der Datei öffnet sich. Speichern Sie die Lizenzaktualisierungsdatei und kopieren Sie sie auf den Zielcomputer. Öffnen Sie das CodeMeter Kontrollzentrum . Wählen Sie in der Lizenzübersicht den Lizenzspeicher 3S-Smart Software Solutions Softlicenses . Klicken Sie auf die Schaltfläche Lizenz aktivieren . Der Assistent CmFAS öffnet sich. Klicken Sie auf Weiter . Eine Liste der möglichen Aktionen erscheint. Wählen Sie Lizenzaktualisierung einspielen und klicken Sie auf Weiter . Wählen Sie die Lizenzaktualisierungsdatei aus, beispielsweise 128-9754375.WibuCmRaU und klicken Sie auf Anwenden . Die Lizenzaktualisierungsdatei ist auf dem ausgewählten Dongle installiert. " }, 
{ "title" : "Offlineaktivieren eines linuxbasierten Systems ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_e15f5a8067cfa551c0a864632160e725", 
"breadcrumbs" : "CODESYS Essentials \/ Packages und Lizenzen verwalten \/ Produkte lizenzieren \/ Offlineaktivieren eines linuxbasierten Systems ", 
"snippet" : "Sie wollen eine Single-Lizenz für Laufzeitsystem installieren, das auf Linux basiert. Voraussetzungen: Ihr Entwicklungssystem mit CODESYS Development System verfügt über keinen Internetzugang, ist aber mit dem Gerät verbunden. Öffnen Sie CODESYS . Erstellen Sie ein Standardprojekt. Aktualisieren Sie...", 
"body" : "Sie wollen eine Single-Lizenz für Laufzeitsystem installieren, das auf Linux basiert. Voraussetzungen: Ihr Entwicklungssystem mit CODESYS Development System verfügt über keinen Internetzugang, ist aber mit dem Gerät verbunden. Öffnen Sie CODESYS . Erstellen Sie ein Standardprojekt. Aktualisieren Sie das Gerät. Wählen Sie in CODESYS den Befehl Tools → Lizenz-Manager . Der Wizard startet mit dem Dialog Lizenz-Manager - Zielgerät auswählen . Wählen Sie Gerät als Zielgerät, klicken Sie Weiter , wählen dann im Dialog Lizenz-Manager - Container auswählen die Option Softcontainer oder Dongle , und klicken Sie wieder auf Weiter . Der Dialog Lizenz-Manager öffnet sich. Im Fenster Produkte wird das zu lizenzierende Produkt angezeigt. Klicken Sie die Schaltfläche Lizenzen installieren und wählen Sie im Dialog Lizenzen auf <Gerät> installieren - Operation auswählen die Option Lizenz anfordern und klicken Sie auf Weiter . Der Dialog Lizenzen auf <Gerät> installieren - Lizenz anfordern erscheint. Geben Sie im Eingabefeld Softwareanbieter den Firmcode des Softwareanbieters ein, der die Lizenz zur Aktivierung des Produkts bereitstellt. Alternativ wählen Sie den Namen des Softwareanbieters aus der Combobox aus. Geben Sie den Speicherort und den Namen der Kontextdatei ein. Beispiel: CmStick [2-2404696].WibuCmRaC Klicken Sie auf Fertigstellen . Die Kontextdatei ( *.WibuCmRaC ) wurde erzeugt. Generieren Sie im Browser die Aktualisierungsdatei ( *.WibuCmRaU ). Kopieren Sie diese Lizenzanforderungsdatei auf einen Computer mit Internetzugang. Darauf muss das CodeMeter Kontrollzentrum installiert sein. Öffnen Sie auf diesem Computer den CODESYS -Lizenzserver im Browser ( http:\/\/license.codesys.com ). CODESYS -Lizenzserver: Geben Sie die Nummer des Lizenztickets ein und klicken Sie auf Weiter . Klicken Sie im Folgedialog auf Lizenzen aktivieren . Wählen Sie im nächsten Dialog die Bindung für die Lizenz aus. Klicken Sie auf die Grafik mit dem CODESYS Runtime Key (Dongle). Folgender Dialog erscheint: Wählen Sie im nächsten Dialog den Lizenz-Container aus. Beispiel: 2-2404696 Klicken Sie auf Offline-Lizenzübertragung . Folgender Dialog erscheint: Wählen Sie im nächsten Schritt die Lizenzanforderungsdatei aus, die Sie auf dem anderen Computer erzeugt haben und klicken Sie auf Anforderung jetzt hochladen und weiter . Folgender Dialog erscheint: Laden Sie im nächsten Schritt die Lizenzaktualisierungsdatei auf Ihren Computer. Klicken Sie auf Lizenzaktualisierungsdatei herunterladen . Kopieren Sie die Lizenzaktualisierungsdatei auf den Zielcomputer. Klicken Sie im Dialog Lizenz-Manager auf die Schaltfläche Lizenzen installieren . Der Assistent Lizenzen auf <Gerät> installieren - Operation wählen erscheint. Wählen Sie die Option Lizenz installieren , klicken Sie Weiter . Geben Sie im Eingabefeld den Dateipfad der Lizenzaktivierungsdatei an. Mit Fertigstellen übertragen Sie die Lizenz in den Software Key (Soft-Container). Die Lizenz ist aktiv. " }, 
{ "title" : "Wiederherstellen von Lizenzen ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_7f6761c2468b3986c0a8646345ba6917", 
"breadcrumbs" : "CODESYS Essentials \/ Packages und Lizenzen verwalten \/ Produkte lizenzieren \/ Wiederherstellen von Lizenzen ", 
"snippet" : "Ab CODESYS V3.5 SP13 wird beim Aktivieren von Einzelplatzlizenzen für Geräte mit einer eindeutigen Seriennummer automatisch eine Lizenzsicherungsdatei *.WibuCmRau erzeugt. Die Datei wird auf Ihrem Rechner und auf dem Lizenz-Server abgelegt. Im Falle des Verlusts der Lizenzierungsdateien auf dem Gerä...", 
"body" : "Ab CODESYS V3.5 SP13 wird beim Aktivieren von Einzelplatzlizenzen für Geräte mit einer eindeutigen Seriennummer automatisch eine Lizenzsicherungsdatei *.WibuCmRau erzeugt. Die Datei wird auf Ihrem Rechner und auf dem Lizenz-Server abgelegt. Im Falle des Verlusts der Lizenzierungsdateien auf dem Gerät kann mit Hilfe des Lizenz-Managers die Lizenz aus dieser Datei wiederhergestellt werden. Sie hatten eine Gerätelizenz aktiviert. Wählen Sie in CODESYS den Befehl Tools → Lizenz-Manager . Folgen Sie dem Wizard mit den entsprechenden Eingaben für Zielgerät: Gerät und Container (Softcontainer oder Dongle), sowie der Auswahl des betreffenden Geräts. Klicken Sie im Dialog Lizenz-Manager auf die Schaltfläche Zusätzliche Funktionen und wählen Sie den Befehl Lizenz wiederherstellen . Der Dialog Lizenzen wiederherstellen öffnet sich. Geben Sie die Ticket-ID für die Gerätelizenz ein und klicken auf Wiederherstellen . CODESYS sucht nach der abgelegten Lizenzsicherungsdatei, zunächst auf dem lokalen Computer, danach im License Central Server. Wenn die zum Gerät passende Datei gefunden wurde, wird die Lizenz wieder hergestellt und aktiviert. " }, 
{ "title" : "Lizenzinformationen für Produkte und Gerätefeatures einer Steuerung auflisten ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_0de8d32402b86f11c0a8646319093e62", 
"breadcrumbs" : "CODESYS Essentials \/ Packages und Lizenzen verwalten \/ Produkte lizenzieren \/ Lizenzinformationen für Produkte und Gerätefeatures einer Steuerung auflisten ", 
"snippet" : "Voraussetzungen: CODESYS Development System (ab Version V3.5 SP15) ist geöffnet. Das Gateway und die Steuerung, deren Informationen ausgelesen werden sollen, laufen. Auf der Steuerung befindet sich keine Applikation. Wählen Sie den Befehl Tools → Device License Reader . Der Dialog Gerät auswählen öf...", 
"body" : "Voraussetzungen: CODESYS Development System (ab Version V3.5 SP15) ist geöffnet. Das Gateway und die Steuerung, deren Informationen ausgelesen werden sollen, laufen. Auf der Steuerung befindet sich keine Applikation. Wählen Sie den Befehl Tools → Device License Reader . Der Dialog Gerät auswählen öffnet sich. Doppelklicken Sie das gewünschte Gateway, um das Netzwerk zu durchsuchen. Wenn kein Gateway angezeigt wird, klicken Sie zunächst auf Neues Gateway und wählen Sie in dem Dialog Gateway das gewünschte Gateway aus. Selektieren Sie die gewünschte Steuerung. Bestätigen Sie Ihre Auswahl mit einem Klick auf die Schaltfläche OK . Hinweis: Wenn sich eine Applikation auf der Steuerung befindet, erscheint ein Dialog mit der Abfrage, ob alle Applikationen von der Steuerung entfernt werden sollen. Wenn Sie bei diesem Dialog auf Nein klicken, können die Lizenzinformationen der Steuerung nicht ausgelesen werden. Der Befehl Device Reader wird abgebrochen. CODESYS erstellt die Liste mit den Lizenzinformationen für die Produkte und Gerätefeatures der ausgewählten Steuerung und zeigt die Informationen im Dialog Device Reader an. " }, 
{ "title" : "Skripte verwenden ", 
"url" : "_cds_struct_using_scripts.html", 
"breadcrumbs" : "CODESYS Essentials \/ Skripte verwenden ", 
"snippet" : "Mit Hilfe der Skript-Funktionalität in CODESYS können Sie Befehle oder komplexe Programmabläufe automatisieren, für die ansonsten in der CODESYS -Benutzeroberfläche manuelle Mausklicks und Texteingaben nötig sind. Dazu können auf (Iron)Python basierende Skripte erstellt und aus der CODESYS -Benutzer...", 
"body" : "Mit Hilfe der Skript-Funktionalität in CODESYS können Sie Befehle oder komplexe Programmabläufe automatisieren, für die ansonsten in der CODESYS -Benutzeroberfläche manuelle Mausklicks und Texteingaben nötig sind. Dazu können auf (Iron)Python basierende Skripte erstellt und aus der CODESYS -Benutzeroberfläche (Befehl oder konfigurierte Symbolleiste) oder aus der Windows-Kommandozeile gestartet werden. Sehen Sie dazu die Hilfe zu CODESYS Scripting . " }, 
{ "title" : "Security ", 
"url" : "_cds_struct_security.html", 
"breadcrumbs" : "CODESYS Essentials \/ Security ", 
"snippet" : "Durch die zunehmende Vernetzung von Steuerungen und Anlagen wächst auch das Bedrohungspotential rasant! Befassen Sie sich deshalb eingehend mit den möglichen Sicherheitsmaßnahmen! Sicherheitsmaßnahmen sind unbedingt erforderlich, um Daten und Kommunikationswege vor unberechtigtem Zugriff zu schützen...", 
"body" : "Durch die zunehmende Vernetzung von Steuerungen und Anlagen wächst auch das Bedrohungspotential rasant! Befassen Sie sich deshalb eingehend mit den möglichen Sicherheitsmaßnahmen! Sicherheitsmaßnahmen sind unbedingt erforderlich, um Daten und Kommunikationswege vor unberechtigtem Zugriff zu schützen. Siehe für Informationen und Anleitungen zu den Sicherheitsfunktionen in der CODESYS -Entwicklungsumgebung und auf der Steuerung: Security " }, 
{ "title" : "Referenz: Programmierung ", 
"url" : "_cds_f_reference_programming.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Konvertierung BOOL ", 
"url" : "_cds_operator_bool_to.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Konvertierung BOOL ", 
"snippet" : "BOOL Die Operatoren BOOL_TO_<Typ> konvertieren einen booleschen Wert in den angegebenen Datentypen und geben einen typkonvertierten Wert zurück. Aufrufsyntax : < BOOL_TO_<Typ> ( <Operand> ) Operand Datentyp Beschreibung Variable, Literal BOOL Operatoren BOOL_TO_<Typ> Operator Beispiel Rückgabewert B...", 
"body" : "BOOL Die Operatoren BOOL_TO_<Typ> konvertieren einen booleschen Wert in den angegebenen Datentypen und geben einen typkonvertierten Wert zurück. Aufrufsyntax : < BOOL_TO_<Typ> ( <Operand> ) Operand Datentyp Beschreibung Variable, Literal BOOL Operatoren BOOL_TO_<Typ> Operator Beispiel Rückgabewert Beschreibung BOOL_TO___UXINT BOOL_TO___UXINT(TRUE) 1 __UXINT, __XINT, __XWORDBOOL_TO___XINT BOOL_TO___XINT(TRUE) 1 __UXINT, __XINT, __XWORDBOOL_TO___XWORD BOOL_TO___XWINT(TRUE) 1 __UXINT, __XINT, __XWORDBOOL_TO_BIT BOOL_TO___BIT(TRUE) TRUE BITBOOL_TO_BYTE BOOL_TO_BYTE(TRUE) 1 IntegerBOOL_TO_DATE BOOL_TO_DATE(TRUE) D#1970-1-1 Das nullte Bit ist gesetzt, hat aber keine Auswirkungen auf die Anzeige. Datentyp: DATEBOOL_TO_DINT BOOL_TO_DINT(TRUE) 1 IntegerBOOL_TO_DT BOOL_TO_DT(TRUE) DT#1970-01-01-0:0:1 Datentyp: DATEBOOL_TO_DWORD BOOL_TO_DWORD(TRUE) 1 IntegerBOOL_TO_INT BOOL_TO_INT(TRUE) 1 IntegerBOOL_TO_LDATE BOOL_TO_LDATE(TRUE) LD#1970-01-01 Das nullte Bit ist gesetzt, hat aber keine Auswirkungen auf die Anzeige. Datentyp: DATEBOOL_TO_LDT BOOL_TO_LD(TRUE) DT#1970-01-01-0:0:1 Datentyp: DATEBOOL_TO_LINT BOOL_TO_LINT(TRUE) 1 IntegerBOOL_TO_LREAL BOOL_TO_LREAL(TRUE) 1 REAL, LREALBOOL_TO_LTIME BOOL_TO_LTIME(TRUE) LTIME#1NS Datentyp: DATEBOOL_TO_LTOD BOOL_TO_LTOD(TRUE) LTOD#0:0:0.000000001 Datentyp: DATEBOOL_TO_LWORD BOOL_TO_LWORD(TRUE) 1 IntegerBOOL_TO_REAL BOOL_TO_REAL(TRUE) 1 REAL, LREALBOOL_TO_SINT BOOL_TO_SINT(TRUE) 1 IntegerBOOL_TO_STRING BOOL_TO_STRING(TRUE) 'TRUE' STRINGBOOL_TO_TIME BOOL_TO_TIME(TRUE) T#1ms Datentyp: DATEBOOL_TO_TOD BOOL_TO_TOD(TRUE) TOD#0:0:0.001 Datentyp: DATEBOOL_TO_UDINT BOOL_TO_UDINT(TRUE) 1 IntegerBOOL_TO_UINT BOOL_TO_UINT(TRUE) 1 IntegerBOOL_TO_ULINT BOOL_TO_ULINT(TRUE) 1 IntegerBOOL_TO_USINT BOOL_TO_ULSINT(TRUE) 1 IntegerBOOL_TO_WORD BOOL_TO_WORD(TRUE) 1 IntegerBOOL_TO_WSTRING BOOL_TO_WSTRING(TRUE) \"TRUE\" WSTRING" }, 
{ "title" : "Beispiel ", 
"url" : "_cds_operator_bool_to.html#UUID-2a346bdb-4e90-93fe-7336-6fbb8a8d690a_UUID-7cb488ce-e3ad-80d5-81d9-c44c2ef838fa_id_a353abc1de5f9c0a8640e006e95fc_id_a764924bfc35ef1cc0a8646370e2d8a1", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Konvertierung BOOL \/ Beispiel ", 
"snippet" : "FB_ConvertFromBool Deklaration in ST FUNCTION_BLOCK FB_ConvertFromBool VAR uxiReturn_1: __UXINT; uxiReturn_10: __UXINT; iReturn_2: __XINT; iReturn_20: __XINT; xwReturn_3: __XWORD; xwReturn_30: __XWORD; bitReturn_4: BOOL; bitReturn_40: BOOL; bReturn_6: BYTE; bReturn_60: BYTE; dateReturn_7: DATE; date...", 
"body" : "FB_ConvertFromBool Deklaration in ST FUNCTION_BLOCK FB_ConvertFromBool\nVAR\n uxiReturn_1: __UXINT;\n uxiReturn_10: __UXINT;\n iReturn_2: __XINT;\n iReturn_20: __XINT;\n xwReturn_3: __XWORD;\n xwReturn_30: __XWORD;\n bitReturn_4: BOOL;\n bitReturn_40: BOOL;\n bReturn_6: BYTE;\n bReturn_60: BYTE;\n dateReturn_7: DATE;\n dateReturn_70: DATE;\n dtReturn_8: DATE_AND_TIME;\n dtReturn_80: DATE_AND_TIME;\n diReturn_9: DINT;\n diReturn_90: DINT;\n dtReturn_10: DATE_AND_TIME;\n dtReturn_100: DATE_AND_TIME;\n dwReturn_11: DWORD;\n dwReturn_110: DWORD;\n iReturn_12: INT;\n iReturn_120: INT;\n liReturn_13: LINT;\n liReturn_130: LINT;\n lrReturn_14: LREAL;\n lrReturn_140: LREAL;\n lwReturn_15: LWORD;\n lwReturn_150: LWORD;\n rReturn_16: REAL;\n rReturn_160: REAL;\n siReturn_17: SINT;\n siReturn_170: SINT;\n sReturn_18: STRING;\n sReturn_180: STRING;\n todReturn_19: TIME_OF_DAY;\n todReturn_190: TIME_OF_DAY;\n timReturn_20: TIME;\n timReturn_200: TIME;\n todReturn_21: TIME_OF_DAY;\n todReturn_210: TIME_OF_DAY;\n udiReturn_22: UDINT;\n udiReturn_220: UDINT;\n uiReturn_23: UINT;\n uiReturn_230: UINT;\n uliReturn_24: ULINT;\n uliReturn_240: ULINT;\n usiReturn_25: USINT;\n usiReturn_250: USINT;\n wReturn_26: WORD;\n wReturn_260: WORD;\n wsReturn_27: WSTRING;\n wsReturn_270: WSTRING;\nEND_VAR\n Implementierung in ST FUNCTION_BLOCK FB_ConvertFromBool\nVAR\nVAR\n uxiReturn_1: __UXINT;\n uxiReturn_10: __UXINT;\n iReturn_2: __XINT;\n iReturn_20: __XINT;\n xwReturn_3: __XWORD;\n xwReturn_30: __XWORD;\n bitReturn_4: BOOL;\n bitReturn_40: BOOL;\n bReturn_6: BYTE;\n bReturn_60: BYTE;\n dateReturn_7: DATE;\n dateReturn_70: DATE;\n dtReturn_8: DATE_AND_TIME;\n dtReturn_80: DATE_AND_TIME;\n diReturn_9: DINT;\n diReturn_90: DINT;\n dtReturn_10: DATE_AND_TIME;\n dtReturn_100: DATE_AND_TIME;\n dwReturn_11: DWORD;\n dwReturn_110: DWORD;\n iReturn_12: INT;\n iReturn_120: INT;\n liReturn_13: LINT;\n liReturn_130: LINT;\n lrReturn_14: LREAL;\n lrReturn_140: LREAL;\n lwReturn_15: LWORD;\n lwReturn_150: LWORD;\n rReturn_16: REAL;\n rReturn_160: REAL;\n siReturn_17: SINT;\n siReturn_170: SINT;\n sReturn_18: STRING;\n sReturn_180: STRING;\n todReturn_19: TIME_OF_DAY;\n todReturn_190: TIME_OF_DAY;\n timReturn_20: TIME;\n timReturn_200: TIME;\n todReturn_21: TIME_OF_DAY;\n todReturn_210: TIME_OF_DAY;\n udiReturn_22: UDINT;\n udiReturn_220: UDINT;\n uiReturn_23: UINT;\n uiReturn_230: UINT;\n uliReturn_24: ULINT;\n uliReturn_240: ULINT;\n usiReturn_25: USINT;\n usiReturn_250: USINT;\n wReturn_26: WORD;\n wReturn_260: WORD;\n wsReturn_27: WSTRING;\n wsReturn_270: WSTRING;\nEND_VAR\n\n\/\/ Return value of operand = TRUE or FALSE\nuxiReturn_1 := BOOL_TO___UXINT(TRUE);\nuxiReturn_10 := BOOL_TO___UXINT(FALSE);\n\niReturn_2 := BOOL_TO___XINT(TRUE);\niReturn_20 := BOOL_TO___XINT(FALSE);\n\nxwReturn_3 := BOOL_TO___XWORD(TRUE);\nxwReturn_30 := BOOL_TO___XWORD(FALSE);\n\nbitReturn_4 := BOOL_TO_BIT(TRUE);\nbitReturn_40 := BOOL_TO_BIT(FALSE);\n\nbReturn_6 := BOOL_TO_BYTE(TRUE);\nbReturn_60 := BOOL_TO_BYTE(FALSE);\n\ndateReturn_7 := BOOL_TO_DATE(TRUE);\ndateReturn_70 := BOOL_TO_DATE(FALSE);\n\ndtReturn_8 := BOOL_TO_DT(TRUE);\ndtReturn_80 := BOOL_TO_DT(FALSE);\n\ndiReturn_9 := BOOL_TO_DINT(TRUE);\ndiReturn_90 := BOOL_TO_DINT(FALSE);\n\ndwReturn_11 := BOOL_TO_DWORD(TRUE);\ndwReturn_110 := BOOL_TO_DWORD(FALSE);\n\niReturn_12 := BOOL_TO_INT(TRUE);\niReturn_120 := BOOL_TO_INT(FALSE);\n\nliReturn_13 := BOOL_TO_LINT(TRUE);\nliReturn_130 := BOOL_TO_LINT(FALSE);\n\nlrReturn_14 := BOOL_TO_LREAL(TRUE);\nlrReturn_140 := BOOL_TO_LREAL(FALSE);\n\nlwReturn_15 := BOOL_TO_LWORD(TRUE);\nlwReturn_150 := BOOL_TO_LWORD(FALSE);\n\nrReturn_16 := BOOL_TO_REAL(TRUE);\nrReturn_160 := BOOL_TO_REAL(FALSE);\n\nsiReturn_17 := BOOL_TO_SINT(TRUE);\nsiReturn_170 := BOOL_TO_SINT(FALSE);\n\nsReturn_18 := BOOL_TO_STRING(TRUE);\nsReturn_180 := BOOL_TO_STRING(FALSE);\n\ntimReturn_20 := BOOL_TO_TIME(TRUE);\ntimReturn_200 := BOOL_TO_TIME(FALSE);\n\ntodReturn_21 := BOOL_TO_TOD(TRUE);\ntodReturn_210 := BOOL_TO_TOD(FALSE);\n\nudiReturn_22 := BOOL_TO_UDINT(TRUE);\nudiReturn_220 := BOOL_TO_UDINT(FALSE);\n\nuiReturn_23 := BOOL_TO_UINT(TRUE);\nuiReturn_230 := BOOL_TO_UINT(FALSE);\n\nuliReturn_24 := BOOL_TO_ULINT(TRUE);\nuliReturn_240 := BOOL_TO_ULINT(FALSE);\n\nusiReturn_25 := BOOL_TO_USINT(TRUE);\nusiReturn_250 := BOOL_TO_USINT(FALSE);\n\nwReturn_26 := BOOL_TO_WORD(TRUE);\nwReturn_260 := BOOL_TO_WORD(FALSE);\n\nwsReturn_27 := BOOL_TO_WSTRING(TRUE);\nwsReturn_270 := BOOL_TO_WSTRING(FALSE); FB_FbdConvertBool Implementierungssprache FUP " }, 
{ "title" : "Programmiersprachen und ihre Editoren ", 
"url" : "_cds_struct_reference_programming_languages_and_editors.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren ", 
"snippet" : "Sie programmieren eine POU jeweils im Editor für die Implementierungssprache, die Sie beim Anlegen der POU ausgewählt haben. CODESYS bietet einen Texteditor für ST und grafische Editoren für AS, FUP\/KOP\/AWL und CFC. Der Editor öffnet sich beim Doppelklick auf die POU im Gerätebaum oder in der Ansich...", 
"body" : "Sie programmieren eine POU jeweils im Editor für die Implementierungssprache, die Sie beim Anlegen der POU ausgewählt haben. CODESYS bietet einen Texteditor für ST und grafische Editoren für AS, FUP\/KOP\/AWL und CFC. Der Editor öffnet sich beim Doppelklick auf die POU im Gerätebaum oder in der Ansicht POUs . Jeder der Programmiersprachen-Editoren besteht aus zwei Teilfenstern: Im oberen Teil nehmen Sie im \"Deklarationseditor\" die Deklarationen vor, je nach Einstellung in textueller oder tabellarischer Form. Im unteren Teil fügen Sie den Implementierungscode in der jeweiligen Sprache ein. Die Darstellung und das Verhalten jedes Editors können Sie projektweit in der zugehörigen Registerkarte der CODESYS -Optionen konfigurieren. " }, 
{ "title" : "Deklarationseditor ", 
"url" : "_cds_edt_declaration_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Deklarationseditor ", 
"snippet" : "Im Deklarationseditor deklarieren Sie Variablen in Variablenlisten und Bausteinen. Wenn der Deklarationseditor in Verbindung mit einem Programmierspracheneditor verwendet wird, öffnet er sich in einem Fenster oberhalb des Programmierspracheneditors. Der Deklarationseditor bietet zwei mögliche Ansich...", 
"body" : "Im Deklarationseditor deklarieren Sie Variablen in Variablenlisten und Bausteinen. Wenn der Deklarationseditor in Verbindung mit einem Programmierspracheneditor verwendet wird, öffnet er sich in einem Fenster oberhalb des Programmierspracheneditors. Der Deklarationseditor bietet zwei mögliche Ansichten: textuell, tabellarisch. Im Deklarationseditor definieren Sie, ob entweder nur die textuelle oder nur die tabellarische Ansicht verfügbar ist, oder ob Sie über die Schaltflächen am rechten Rand des Editorfensters zwischen den beiden Ansichten wechseln können. Wenn das Editorfenster wegen langer Textzeilen einen Scrollbalken erhält, können Sie scrollen, indem Sie bei gedrückter Taste Umschalt das Mausrad drehen. Zoomen im Editorfenster ist durch Drehen des Mausrads bei gedrückter Taste Strg möglich. Deklarationseditor im Onlinebetrieb Im Onlinebetrieb sehen Sie die tabellarische Ansicht des Editors. Die Kopfzeile enthält immer den aktuellen Objektpfad: <Gerätename>.<Applikationsname>.<Objektname>. Die Tabelle enthält im Unterschied zum Offlinebetrieb auch die Spalten Wert und Vorbereiteter Wert . Die Spalte Wert zeigt den Istwert auf der Steuerung, bietet also Monitoring-Funktionalität. Wenn der Ausdruck ein Array mit mehr als 1000 Elementen ist, können Sie den Bereich der zu monitorenden Arrayindizes festlegen. Dazu öffnen Sie mit einem Doppelklick in die Spalte Datentyp den Dialog Monitoring-Bereich : In diesem Dialog ist der deklarierte Arraybereich als Gültiger Bereich für das Monitoring eingetragen. Pro Array können maximal 20000 Elemente gemonitort werden. Den Bereich der zu monitorenden Arrayindizes definieren Sie durch Angabe von Start - und Ende -Index. Um diesen Bereich einfacher bei gleichbleibendem Umfang zu verschieben, können die dafür vorhandenen Scrollbalken gekoppelt verwendet werden. Zum Umschalten zwischen gekoppelt und nicht gekoppelt klicken Sie auf das Symbol rechts der Balken. Im nicht gekoppelten Zustand können Sie den Umfang des zu monitorenden Bereichs beliebig vergrößern oder verkleinern. Die Spalte Vorbereiteter Wert enthält den Wert, den Sie gegebenfalls zum Forcen oder Schreiben vorbereitet haben. Wenn Sie auf ein Feld in der Spalte Vorbereiteter Wert doppelklicken, können Sie direkt einen Wert für das Schreiben oder Forcen eingeben. Bei Enumerationen öffnet sich eine Combobox, aus der Sie einen Wert auswählen können. Bei einer booleschen Variable können Sie den vorbereiteten Wert mit Hilfe der Tasten Eingabe oder Leerzeichen toggeln. Wenn ein Ausdruck (Variable) von einem strukturierten Datentyp ist, beispielsweise die Instanz eines Funktionsbausteins oder eine Arrayvariable, dann ist ein Plus- oder Minuszeichen vorangestellt. Sie können das Format der Darstellung von Gleitpunktwerten in den Optionen für Monitoring anpassen. " }, 
{ "title" : "Generelle Funktionalitäten in allen grafischen Editoren ", 
"url" : "_cds_common_functionalities_in_grafic_editors.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Generelle Funktionalitäten in allen grafischen Editoren ", 
"snippet" : "Der Implementierungsteil der grafischen Editoren für FUP, KOP, CFC und AS enthält in der rechten unteren Ecke eine Symbolleiste: Zurück in den normalen Editiermodus Der Mauszeiger bekommt die standardmäßige Pfeilform. Sie können wieder Elemente im Editorfenster auswählen und bearbeiten. Schwenkwerkz...", 
"body" : "Der Implementierungsteil der grafischen Editoren für FUP, KOP, CFC und AS enthält in der rechten unteren Ecke eine Symbolleiste: Zurück in den normalen Editiermodus Der Mauszeiger bekommt die standardmäßige Pfeilform. Sie können wieder Elemente im Editorfenster auswählen und bearbeiten. Schwenkwerkzeug Der Mauszeiger bekommt die Form zweier gekreuzter Pfeile. Sie können nun an beliebiger Stelle ins Editorfenster klicken, die Maustaste gedrückt halten und dann mit der Maus den sichtbaren Bereich des FUP\/KOP\/AWL-Editors oder des CFC-Diagramms innerhalb des Fensters schwenken\/verschieben. Lupenwerkzeug Es öffnet sich ein zusätzliches Lupenfenster in der unteren rechten Ecke des Editorfensters und der Mauszeiger bekommt die Form zweier gekreuzter Pfeile. Solange Sie nun den Mauszeiger über Ihr Diagramm bewegen, zeigt die Lupe jeweils den Bereich des Diagramms um den Zeiger 100% Größe. Hinweis: Wenn Sie nun ins Fenster klicken, wird die Lupe geschlossen und der Teil des Diagramms, der in ihr zu sehen gewesen war, in 100% Größe angezeigt. Wenn Sie den vorher eingestellten Zoomfaktor beibehalten wollen, sollten Sie deshalb verwenden , um zurück in den normalen Editiermodus zu gelangen. Vergrößerungs-\/Verkleinerungswerkzeug Die Schaltfläche öffnet ein Untermenü zur Auswahl eines Zoomfaktors. Die Auswahl der drei Punkte ... öffnet den Dialog Zoom , in dem Sie einen anderen Wert angeben können. Der aktuelle Zoomfaktor wird immer links von der Schaltfläche angezeigt. Vergrößern\/Verkleinern mit dem Mausrad: Wenn Sie die Taste Strg drücken, während Sie das Mausrad bewegen, wird der Zoomfaktor stufenweise um 10% verändert. Jeder grafische Editor bringt eine Toolbox (Ansicht Werkzeuge ) mit, standardmäßig rechts vom Editorfenster. Die Toolbox enthält die verfügbaren Elemente, die Sie mit der Maus auf die jeweiligen Einfügepositionen ins Editorfenster ziehen können. Die jeweiligen Einfügepositionen hebt CODESYS mit grauen rauten-, dreieck- oder pfeilförmigen Positionsmarken hervor. Sobald der Mauszeiger über einer dieser Marken steht, wird diese Marke grün. Wenn Sie nun die Maustaste loslassen, fügt CODESYS das Element an der aktuellen Position ein. Das Verschieben von Elementen im Editor ist ebenfalls mit der Maus möglich. Sie können in den grafischen Editoren FUP, KOP und CFC Deklarationen von Funktionsbausteinen in das Editorfenster ziehen. Selektieren Sie dazu die vollständige Deklaration (Variablenname + Datentyp) und ziehen Sie diese auf eine geeignete Stelle im Editorfenster. Beim Kontaktplan können Sie zusätzlich boolesche Deklarationen in den Editor ziehen und als Kontakt einfügen. " }, 
{ "title" : "Strukturierter Text und Erweiterter Strukturierter Text (ExST) ", 
"url" : "_cds_st_f_language.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "ST-Editor ", 
"url" : "_cds_edt_st_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ ST-Editor ", 
"snippet" : "Der ST-Editor ist ein Texteditor und dient der Implementierung von Code in Strukturiertem Text (ST) und Erweitertem Strukturiertem Text (ExST). Am linken Rand des Editors befindet sich die Zeilennummerierung. Bei der Eingabe der Programmierelemente helfen die Funktionalität „Komponenten auflisten“ (...", 
"body" : "Der ST-Editor ist ein Texteditor und dient der Implementierung von Code in Strukturiertem Text (ST) und Erweitertem Strukturiertem Text (ExST). Am linken Rand des Editors befindet sich die Zeilennummerierung. Bei der Eingabe der Programmierelemente helfen die Funktionalität „Komponenten auflisten“ (zu aktivieren in den CODESYS -Optionen, Kategorie Intelligentes Kodieren ), und die Eingabehilfe ( F2 ). Wenn der Cursor auf einer Variablen steht, zeigt CODESYS im Tooltip Informationen zur Deklaration der Variablen an. Eine Rechteckselektion kann mit folgenden Tastenkombinationen ausgeführt werden: Umschalt + Alt + Pfeil nach rechts : Der selektierte Bereich wird um eine Stelle nach rechts erweitert. Umschalt + Alt + Pfeil nach links : Der selektierte Bereich wird um eine Stelle nach links erweitert. Umschalt + Alt + Pfeil nach oben : Der selektierte Bereich wird um eine Zeile nach oben erweitert. Umschalt + Alt + Pfeil nach unten : Der selektierte Bereich wird um eine Stelle nach unten erweitert. Wenn das Editorfenster wegen langer Textzeilen einen Scrollbalken erhält, können Sie scrollen, indem Sie bei gedrückter Taste Umschalt das Mausrad drehen. Zoomen im Editorfenster ist durch Drehen des Mausrads bei gedrückter Taste Strg möglich. Das Verhalten (wie zum Beispiel Klammerung, Mausaktionen, Tabulatoren) und Aussehen des Editors konfigurieren Sie in den CODESYS -Optionen in der Kategorie Texteditor . Für eine inkrementelle Suche nach Zeichenfolgen innerhalb des Editors öffnen Sie mit der Tastenkombination Strg + Umschalt + i ein Eingabefeld am unteren Rand des Editors. Sobald Sie beginnen, eine Zeichenfolge einzutippen, werden im Editor die entsprechenden Fundstellen farbig markiert. Rechts des Eingabefelds steht die Anzahl der gefundenen Übereinstimmungen. Mit Hilfe der Pfeilschaltflächen oder den Tastenkombinationen Alt + Bild auf oder Alt + Bild ab können Sie den Cursor auf eine Fundstelle setzen. Wenn Sie den Cursor auf einen Symbolnamen setzen, werden alle Verwendungsstellen des Symbols innerhalb des Editors farblich hervorgehoben. Die Fundstellen entsprechen den Treffern der Querverweisliste . Bei sehr großen Projekten kann dies zu Verzögerungen bei der Eingabe führen. In diesem Fall können Sie die Funktion in den Optionen des Texteditors abschalten. CODESYS erkennt Syntaxfehler bereits während der Eingabe im Editor und gibt die entsprechenden Meldungen im Meldungsfenster in der Kategorie Vorkompilierung aus. Wenn die entsprechende Option in den CODESYS -Optionen, Kategorie Intelligentes Kodieren aktiviert ist, werden außerdem die Fehlerstellen im Text rot unterkringelt. " }, 
{ "title" : "ST-Editor im Onlinebetrieb ", 
"url" : "_cds_st_editor_in_online_mode.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ ST-Editor im Onlinebetrieb ", 
"snippet" : "Im Onlinebetrieb zeigt CODESYS im ST-Editor die verwendeten Variablen und Ausdrücke an ( Monitoring von Werten). Das Schreiben und Forcen der Variablen und Ausdrücke und Debugging -Funktionen (Haltepunkte, Einzelschrittabarbeitung) und Ablaufkontrolle sind ebenfalls möglich. Wenn Sie in der ST-Progr...", 
"body" : "Im Onlinebetrieb zeigt CODESYS im ST-Editor die verwendeten Variablen und Ausdrücke an ( Monitoring von Werten). Das Schreiben und Forcen der Variablen und Ausdrücke und Debugging -Funktionen (Haltepunkte, Einzelschrittabarbeitung) und Ablaufkontrolle sind ebenfalls möglich. Wenn Sie in der ST-Programmierung Zuweisungen als Ausdrücke verwenden, entstehen keine weiteren Haltepunkt-Positionen innerhalb einer Zeile. " }, 
{ "title" : "ST-Ausdrücke ", 
"url" : "_cds_st_expressions.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ ST-Ausdrücke ", 
"snippet" : "Ein Ausdruck ist ein Konstrukt, das nach seiner Auswertung einen Wert zurückliefert. Ausdrücke sind zusammengesetzt aus Operatoren und Operanden. Im Erweiterten Strukturierten Text (ExST) können Sie auch Zuweisungen als Ausdruck verwenden. Ein Operand kann eine Konstante, eine Variable, ein Funktion...", 
"body" : "Ein Ausdruck ist ein Konstrukt, das nach seiner Auswertung einen Wert zurückliefert. Ausdrücke sind zusammengesetzt aus Operatoren und Operanden. Im Erweiterten Strukturierten Text (ExST) können Sie auch Zuweisungen als Ausdruck verwenden. Ein Operand kann eine Konstante, eine Variable, ein Funktionsaufruf oder ein weiterer Ausdruck sein. Spezielle ST-Ausdrücke sind darüber hinaus: Zugriffe auf Elemente von Arrayvariablen Komponenten einer Strukturvariablen Variablen einer Funktionsbausteininstanz oder eines Programms Methodenaufruf Beispiele 2014 Konstante, Literal ivar Variable fct(a,b) Funktionsaufruf (x*y)\/z Ausdruck real_var2 := int.var; In ExST: Zuweisung " }, 
{ "title" : "Auswertung von Ausdrücken ", 
"url" : "_cds_st_expressions.html#UUID-60e5105f-e6ee-c431-74b7-012ca1a132d4_id_d5c8c87f0b362c0a8640e007534c3_id_e52a54881e8f8d57c0a8640e01163600", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ ST-Ausdrücke \/ Auswertung von Ausdrücken ", 
"snippet" : "Die Auswertung eines Ausdrucks erfolgt durch Abarbeitung der Operatoren nach bestimmten Bindungsregeln. CODESYS arbeitet den Operator mit der stärksten Bindung zuerst ab. Operatoren mit gleicher Bindungsstärke werden von links nach rechts abgearbeitet. Operation Symbol Bindungsstärke Einklammern ( <...", 
"body" : "Die Auswertung eines Ausdrucks erfolgt durch Abarbeitung der Operatoren nach bestimmten Bindungsregeln. CODESYS arbeitet den Operator mit der stärksten Bindung zuerst ab. Operatoren mit gleicher Bindungsstärke werden von links nach rechts abgearbeitet. Operation Symbol Bindungsstärke Einklammern ( <Ausdruck> ) Stärkste Bindung Funktionsaufruf <Funktionsname> ( <Parameterliste> ) alle Operatoren mit Syntax: <0perator> () Potenzieren EXPT Negieren Komplementbildung - NOT Multiplizieren Dividieren Modulo * \/ MOD Addieren Subtrahieren + - Vergleichen < , > , <= , >= Gleichheit Ungleichheit = <> Boolesches AND AND , AND_THEN Boolesches XOR Boolesches OR XOR OR , OR_ELSE Schwächste Bindung " }, 
{ "title" : "Zuweisungen ", 
"url" : "_cds_st_f_assignments.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Zuweisungen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "ST-Zuweisungsoperator ", 
"url" : "_cds_st_operator_assignment.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Zuweisungen \/ ST-Zuweisungsoperator ", 
"snippet" : "Syntax: <operand> := <expression> Dieser Zuweisungsoperator führt die gleiche Funktion aus wie der MOVE -Operator....", 
"body" : "Syntax: <operand> := <expression> Dieser Zuweisungsoperator führt die gleiche Funktion aus wie der MOVE -Operator. " }, 
{ "title" : "ST-Zuweisungsoperator für Ausgänge ", 
"url" : "_cds_st_operator_output_assignment.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Zuweisungen \/ ST-Zuweisungsoperator für Ausgänge ", 
"snippet" : "Der Zuweisungsoperator => weist den Ausgang einer Funktion, eines Funktionsbausteins oder einer Methode einer Variablen zu. Der Platz rechts vom Operator kann auch leer sein. Syntax <output> => <variable> Beispiel FBcomp_Output1 => bVar1; FBcomp_Output2 => ; FBcom_Output1 und FB_Output2 sind Ausgäng...", 
"body" : "Der Zuweisungsoperator => weist den Ausgang einer Funktion, eines Funktionsbausteins oder einer Methode einer Variablen zu. Der Platz rechts vom Operator kann auch leer sein. Syntax <output> => <variable> Beispiel FBcomp_Output1 => bVar1;\nFBcomp_Output2 => ; FBcom_Output1 und FB_Output2 sind Ausgänge eines Funktionsbausteins. Der Wert von FBcom_Output1 wird der Variablen bVar1 zugewiesen. " }, 
{ "title" : "ExST-Zuweisung: S= ", 
"url" : "_cds_exst_operator_s.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Zuweisungen \/ ExST-Zuweisung: S= ", 
"snippet" : "Wenn der Operand der Set-Zuweisung auf TRUE schaltet, bewirkt die Zuweisung, dass der Variablen links des Operators ein TRUE zugewiesen wird. Die Variable wird gesetzt. <variable name> S= <operand name> ; Die Variablen und der Operand haben den Datentyp BOOL . Beispiel PROGRAM PLC_PRG VAR xOperand: ...", 
"body" : "Wenn der Operand der Set-Zuweisung auf TRUE schaltet, bewirkt die Zuweisung, dass der Variablen links des Operators ein TRUE zugewiesen wird. Die Variable wird gesetzt. <variable name> S= <operand name> ; Die Variablen und der Operand haben den Datentyp BOOL . Beispiel PROGRAM PLC_PRG\nVAR\n xOperand: BOOL := FALSE;\n xSetVariable: BOOL := FALSE;\nEND_VAR\n\nxSetVariable S= xOperand; Wenn der Operand xOperand von FALSE auf TRUE schaltet, wird auch der Variable xSetVariable ein TRUE zugewiesen. Dann aber behält die Variable diesen Zustand, auch wenn der Operand weiterhin seinen Zustand wechselt. " }, 
{ "title" : "Mehrfachzuweisungen ", 
"url" : "_cds_exst_operator_s.html#UUID-3e454082-8249-f217-17c5-ea427ca5ffa0_id_c050b3abf83e2bc0a8640e009a32a5_id_3abde2ab930da820c0a8646307965b6a", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Zuweisungen \/ ExST-Zuweisung: S= \/ Mehrfachzuweisungen ", 
"snippet" : "Bei Mehrfachzuweisungen innerhalb einer Codezeile werden die einzelnen Zuweisungen nicht von rechts nach links abgearbeitet, sondern alle Zuweisungen beziehen sich auf den Operanden am Codezeilenende. Beispiel FUNCTION funCompute : BOOL VAR_INPUT xIn : BOOL; END_VAR IF xIn = TRUE THEN funCompute := ...", 
"body" : "Bei Mehrfachzuweisungen innerhalb einer Codezeile werden die einzelnen Zuweisungen nicht von rechts nach links abgearbeitet, sondern alle Zuweisungen beziehen sich auf den Operanden am Codezeilenende. Beispiel FUNCTION funCompute : BOOL\nVAR_INPUT\n xIn : BOOL;\nEND_VAR\nIF xIn = TRUE THEN\n funCompute := TRUE;\n RETURN;\nEND_IF\n\nPROGRAM PLC_PRG\nVAR\n xSetVariable: BOOL;\n xResetVariable: BOOL := TRUE;\n xVar: BOOL;\nEND_VAR\nxSetVariable S= xResetVariable R= funCompute(xIn := xVar); xResetVariable erhält die R= -Zuweisung des Rückgabewerts von funCompute . xSetVariable erhält die S= -Zuweisung des Rückgabewerts von funCompute , aber nicht von xResetVariable . " }, 
{ "title" : "ExST-Zuweisung: R= ", 
"url" : "_cds_exst_operator_r.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Zuweisungen \/ ExST-Zuweisung: R= ", 
"snippet" : "Wenn der Operand der Reset-Zuweisung auf TRUE schaltet, bewirkt die Zuweisung, dass der Variablen links des Operators ein FALSE zugewiesen wird. Die Variable wird zurückgesetzt. <variable name> R= <operand name> ; Die Variablen und der Operand haben den Datentyp BOOL . Beispiel VAR xOperand: BOOL :=...", 
"body" : "Wenn der Operand der Reset-Zuweisung auf TRUE schaltet, bewirkt die Zuweisung, dass der Variablen links des Operators ein FALSE zugewiesen wird. Die Variable wird zurückgesetzt. <variable name> R= <operand name> ; Die Variablen und der Operand haben den Datentyp BOOL . Beispiel VAR\n xOperand: BOOL := FALSE;\n xResetVariable: BOOL := TRUE;\nEND_VAR\n\nxResetVariable R= xOperand; Wenn der Operand xOperand von FALSE auf TRUE schaltet, wird auch der Variablen xResetVariable ein FALSE zugewiesen. Dann aber behält die Variable ihren Zustand, auch wenn der Operand weiterhin seinen Zustand wechselt. " }, 
{ "title" : "Mehrfachzuweisungen ", 
"url" : "_cds_exst_operator_r.html#UUID-1891bf0f-9a33-b0eb-d3ff-5838f6d073d1_id_d90635bdac550e0ac0a8640e010769d8_id_e67e66ad930a59e8c0a86463664c9b5c", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Zuweisungen \/ ExST-Zuweisung: R= \/ Mehrfachzuweisungen ", 
"snippet" : "Bei Mehrfachzuweisungen innerhalb einer Codezeile werden die einzelnen Zuweisungen nicht von rechts nach links abgearbeitet, sondern alle Zuweisungen beziehen sich auf den Operanden am Codezeilenende. Beispiel FUNCTION funCompute : BOOL VAR_INPUT xIn : BOOL; END_VAR IF xIn = TRUE THEN funCompute := ...", 
"body" : "Bei Mehrfachzuweisungen innerhalb einer Codezeile werden die einzelnen Zuweisungen nicht von rechts nach links abgearbeitet, sondern alle Zuweisungen beziehen sich auf den Operanden am Codezeilenende. Beispiel FUNCTION funCompute : BOOL\nVAR_INPUT\n xIn : BOOL;\nEND_VAR\nIF xIn = TRUE THEN\n funCompute := TRUE;\n RETURN;\nEND_IF\n\nPROGRAM PLC_PRG\nVAR\n xSetVariable: BOOL;\n xResetVariable: BOOL := TRUE;\n xVar: BOOL;\nEND_VAR\nxSetVariable S= xResetVariable R= funCompute(xIn := xVar); xResetVariable erhält die R= -Zuweisung des Rückgabewerts von funCompute . xSetVariable erhält die S= -Zuweisung des Rückgabewerts von funCompute , aber nicht von xResetVariable . " }, 
{ "title" : "ExST-Zuweisung als Ausdruck ", 
"url" : "_cds_exst_operator_expression.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Zuweisungen \/ ExST-Zuweisung als Ausdruck ", 
"snippet" : "Im ExST erlaubt CODESYS in Erweiterung zur Norm IEC 61131-3 die Verwendung von Zuweisungen als Ausdrücke. Beispiele int_var1 := int_var2 := int_var3 + 9; (* int_var1 und int_var2 erhalten Wert von int_var3 + 9 *) real_var1 := real_var2 := int_var; (* real_var1 und real_var2 erhalten den Wert von int...", 
"body" : "Im ExST erlaubt CODESYS in Erweiterung zur Norm IEC 61131-3 die Verwendung von Zuweisungen als Ausdrücke. Beispiele int_var1 := int_var2 := int_var3 + 9; (* int_var1 und int_var2 erhalten Wert von int_var3 + 9 *) real_var1 := real_var2 := int_var; (* real_var1 und real_var2 erhalten den Wert von int_var *) int_var := real_var1 := int_var; (* fehlerhafte Zuweisung, die Datentypen stimmen nicht überein! *) IF b := (i = 1) THEN i := i + 1; END_IF " }, 
{ "title" : "Zuweisungsoperator: REF= ", 
"url" : "_cds_ref_assignment.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Zuweisungen \/ Zuweisungsoperator: REF= ", 
"snippet" : "Der Operator erzeugt eine Referenz (Pointer) auf einen Wert. Syntax: <variable name> REF= <variable name> ; Beispiel refA : REFERENCE TO DUT; B : DUT; C : DUT; A REF= B; \/\/ corresponds to A := ADR(B); A := C; \/\/ corresponds to A^ := C;...", 
"body" : "Der Operator erzeugt eine Referenz (Pointer) auf einen Wert. Syntax: <variable name> REF= <variable name> ; Beispiel refA : REFERENCE TO DUT;\nB : DUT;\nC : DUT;\n\nA REF= B; \/\/ corresponds to A := ADR(B);\nA := C; \/\/ corresponds to A^ := C; " }, 
{ "title" : "Anweisungen ", 
"url" : "_cds_st_f_instructions.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Anweisungen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "ST-Anweisung: IF ", 
"url" : "_cds_st_instruction_if.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Anweisungen \/ ST-Anweisung: IF ", 
"snippet" : "IF Die IF -Anweisung verwenden Sie, um eine Bedingung zu prüfen und bei erfüllter Bedingung die nachfolgenden Anweisungen auszuführen. Eine Bedingung wird als Ausdruck codiert, der einen booleschen Wert zurückliefert. Wenn der Ausdruck TRUE liefert, ist die Bedingung erfüllt und die zugehörigen Anwe...", 
"body" : "IF Die IF -Anweisung verwenden Sie, um eine Bedingung zu prüfen und bei erfüllter Bedingung die nachfolgenden Anweisungen auszuführen. Eine Bedingung wird als Ausdruck codiert, der einen booleschen Wert zurückliefert. Wenn der Ausdruck TRUE liefert, ist die Bedingung erfüllt und die zugehörigen Anweisungen nach THEN werden ausgeführt. Wenn der Ausdruck FALSE liefert, werden die folgenden Bedingungen, die mit ELSIF gekennzeichnet sind, ausgewertet. Wenn eine ELSIF -Bedingungen TRUE liefert, werden die Anweisungen nach dem zugehörigen THEN ausgeführt. Wenn alle Bedingungen FALSE sind, werden die Anweisungen nach ELSE ausgeführt. Es wird also höchstens ein Zweig der IF -Anweisung ausgeführt. Die ELSIF -Zweige und der ELSE -Zweig sind optional. Syntax IF <condition> THEN\n <statements>\n( ELSIF <condition> THEN\n <statements> )*\n( ELSE\n <statements> )?\nEND_IF;\n\/\/ ( ... )* None, once or several times\n\/\/ ( ... )? Optional Beispiel PROGRAM PLC_PRG\nVAR\n iTemp: INT;\n xHeatingOn: BOOL;\n xOpenWindow: BOOL;\nEND_VAR\n\nIF iTemp < 17 THEN\n xHeatingOn := TRUE;\nELSIF iTemp > 25 THEN\n xOpenWindow := TRUE;\nELSE xHeatingOn := FALSE;\nEND_IF; Zur Laufzeit wird das Programm folgendermaßen durchlaufen: Wenn die Auswertung des Ausdrucks iTemp < 17 = TRUE ergibt, wird die nachfolgende Anweisung ausgeführt und die Heizung eingeschaltet. Wenn die Auswertung des Ausdrucks iTemp < 17 = FALSE ergibt, wird die nachfolgenden ELSIF -Bedingungen iTemp > 25 ausgewertet. Wenn diese wahr ist, wird die Anweisungen unter ELSIF ausgeführt und das Fenster geöffnet. Wenn alle Bedingungen FALSE sind, wird die Anweisung unter ELSE ausgeführt und die Heizung wird ausgeschaltet. " }, 
{ "title" : "ST-Anweisung: FOR ", 
"url" : "_cds_st_instruction_for.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Anweisungen \/ ST-Anweisung: FOR ", 
"snippet" : "FOR Die FOR -Schleife verwenden Sie, um Anweisungen mit einer bestimmten Anzahl von Wiederholungen auszuführen. Syntax: FOR <counter> := <start value> TO <end value> {BY <increment> } DO <instructions> END_FOR; Der Abschnitt innerhalb der geschweiften Klammern {} ist optional. CODESYS führt die <ins...", 
"body" : "FOR Die FOR -Schleife verwenden Sie, um Anweisungen mit einer bestimmten Anzahl von Wiederholungen auszuführen. Syntax: FOR <counter> := <start value> TO <end value> {BY <increment> } DO\n <instructions>\nEND_FOR; Der Abschnitt innerhalb der geschweiften Klammern {} ist optional. CODESYS führt die <instructions> solange aus, wie der <counter> nicht größer, oder - bei negativer Schrittgröße increment - kleiner als der <end value> ist. Dies wird vor der Ausführung der <instructions> geprüft. Immer wenn die Anweisungen <instructions> ausgeführt worden sind, wird der Zähler <counter> automatisch um die Schrittgröße <increment> erhöht. Die Schrittgröße <increment> kann jeden ganzzahligen Wert haben. Wenn Sie keine Schrittgröße angeben, ist die Standard-Schrittgröße 1 . Beispiel FOR iCounter := 1 TO 5 BY 1 DO\n iVar1 := iVar1*2;\nEND_FOR;\nErg := iVar1; Wenn Sie iVar1 mit 1 vorbelegt haben, hat iVar1 nach der FOR-Schleife den Wert 32 . Der Endwert <end value> darf nicht den gleichen Wert erhalten wie die Obergrenze des Datentyps des Zählers. Wenn der Endwert des Zählers gleich der Obergrenze des Datentyps des Zählers ist, entsteht eine Endlosschleife. Beispielsweise entsteht im obigen Beispiel eine Endlosschleife, wenn iCounter vom Datentyp SINT ist und der <end value> gleich 127 ist, da der Datentyp SINT die Obergrenze 127 hat. In Erweiterung zum Standard IEC 61131-3 können Sie innerhalb der FOR -Schleife die CONTINUE -Anweisung verwenden. " }, 
{ "title" : "ST-Anweisung: CASE ", 
"url" : "_cds_st_instruction_case.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Anweisungen \/ ST-Anweisung: CASE ", 
"snippet" : "CASE Die CASE-Anweisung ist eine bedingte Kontrollstruktur, die bewirkt, dass eine Anweisung oder ein Anweisungsabschnitt nur unter einer bestimmten Bedingung ausgeführt wird. Welcher Abschnitt ausgeführt wird, wird durch einen Vergleich von Bedingung und Label bestimmt. Syntax: CASE <condition> OF ...", 
"body" : "CASE Die CASE-Anweisung ist eine bedingte Kontrollstruktur, die bewirkt, dass eine Anweisung oder ein Anweisungsabschnitt nur unter einer bestimmten Bedingung ausgeführt wird. Welcher Abschnitt ausgeführt wird, wird durch einen Vergleich von Bedingung und Label bestimmt. Syntax: CASE <condition> OF\n <label-1> : \n <instruction-1>\n <label-2> : \n <instruction-2>\n <label-3, label-4, label-5> : \n <instruction-3>\n <label-6 .. labe-10> : \n <instruction-4>\n <label-n> : \n <instruction-n>\n ELSE <ELSE-instruction>\nEND_CASE condition Ganzzahlige Variable für die Bedingung Beispiel: iCondition Der Wert der Variablen wird mit den im Konstrukt deklarierten Labels verglichen. Innerhalb einer CASE-Anweisung sind beliebig viele mindestens jedoch 2 Labels zu verwenden. Ansonsten kann das Konstrukt übersichtlicher mit einem IF-THEN-ELSE-Konstrukt dargestellt werden. Alle Labels müssen unterschiedliche Werte haben. label-n Konstante, Literal oder konstanter Ausdruck mit gleichem Datentyp wie die Bedingung Fungiert als Label (Sprungziel) innerhalb des CASE-Konstrukts. Beispiel: 1 , 5 , c_ONE , c_TWO Wenn dieser Wert gleich condition ist, wird die nachfolgende Anweisungen durchlaufen. Wenn dieser Wert ungleich condition ist, wird die zugehörige Anweisung ignoriert und es wird zum nächsten Label gesprungen. < label-n >, < label-n1 > Komma-separierte Liste mit mehreren Labels, die als Sprungziel fungieren Beispiel: 1, 5 Wenn eines der Labels mit der Bedingung condition übereinstimmt, wird der nachfolgende Abschnitt durchlaufen. < label-n1 >..< label-n2 > Bereich mit unterem und oberem Grenzlabel 10..20 Wenn die Bedingung condition einen Wert aus dem Bereich von label-n1 bis label-n2 annimmt, wird der folgende Abschnitt durchlaufen. ELSE Optional, maximal einmal Default-Sprungziel, das angesprungen wird, wenn alle vorherigen Labels nicht mit der Bedingung übereinstimmen. instruction-n ELSE-instruction Anweisung oder Anweisungsabschnitt bestehend aus mehrere Anweisungen Eine Anweisung ist immer abgeschlossen mit einem ; Beispiel CASE iCondition OF\n 1, 5, c_ONE, C_TWO: \n bVar1 := TRUE;\n bVar3 := FALSE;\n 2: \n bVar2 := FALSE;\n bVar3 := TRUE;\n 10..20: \n bVar1 := TRUE;\n bVar3 := TRUE;\n ELSE\n bVar1 := NOT bVar1;\n bVar2 := bVar1 OR bVar2;\nEND_CASE " }, 
{ "title" : "ST-Anweisung: WHILE ", 
"url" : "_cds_st_instruction_while.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Anweisungen \/ ST-Anweisung: WHILE ", 
"snippet" : "WHILE Die WHILE -Schleife verwenden Sie wie die FOR -Schleife, um Anweisungen mehrfach auszuführen, bis die Abbruchbedingung zutrifft. Die Abbruchbedingung einer WHILE -Schleife ist ein boolescher Ausdruck. Syntax: WHILE <boolean expression> DO <instructions> END_WHILE; CODESYS führt die Anweisungen...", 
"body" : "WHILE Die WHILE -Schleife verwenden Sie wie die FOR -Schleife, um Anweisungen mehrfach auszuführen, bis die Abbruchbedingung zutrifft. Die Abbruchbedingung einer WHILE -Schleife ist ein boolescher Ausdruck. Syntax: WHILE <boolean expression> DO\n <instructions>\nEND_WHILE; CODESYS führt die Anweisungen <instructions> solange wiederholt aus, wie der boolesche Ausdruck <boolean expression> TRUE ergibt. Wenn der boolesche Ausdruck bereits bei der ersten Auswertung FALSE ist, dann führt CODESYS die Anweisungen niemals aus. Wenn der boolesche Ausdruck niemals den Wert FALSE annimmt, werden die Anweisungen endlos wiederholt, wodurch ein Laufzeitfehler entsteht. Beispiel WHILE iCounter <> 0 DO\n Var1 := Var1*2\n iCounter := iCounter-1;\nEND_WHILE; Sie müssen programmatisch sicherstellen, dass keine Endlos-Schleife verursacht wird. Die WHILE - und die REPEAT -Schleifen sind in gewissem Sinne mächtiger als die FOR-Schleife, da man nicht bereits vor der Ausführung der Schleife die Anzahl der Schleifendurchläufe wissen muss. In manchen Fällen ist es somit nur möglich, mit diesen beiden Schleifenarten zu arbeiten. Wenn jedoch die Anzahl der Schleifendurchläufe klar ist, dann ist eine FOR -Schleife zu bevorzugen, um Endlosschleifen zu vermeiden. In Erweiterung zum Standard IEC 61131-3 können Sie innerhalb der WHILE-Schleife die CONTINUE -Anweisung verwenden. " }, 
{ "title" : "ST-Anweisung: REPEAT ", 
"url" : "_cds_st_instruction_repeat.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Anweisungen \/ ST-Anweisung: REPEAT ", 
"snippet" : "REPEAT Die REPEAT -Schleife verwenden Sie wie die WHILE -Schleife, jedoch mit dem Unterschied, dass CODESYS die Abbruchbedingung erst nach dem Ausführen der Schleife überprüft. Dieses Verhalten hat zur Folge, dass die REPEAT -Schleife mindestens einmal durchlaufen wird, egal wie die Abbruchbedingung...", 
"body" : "REPEAT Die REPEAT -Schleife verwenden Sie wie die WHILE -Schleife, jedoch mit dem Unterschied, dass CODESYS die Abbruchbedingung erst nach dem Ausführen der Schleife überprüft. Dieses Verhalten hat zur Folge, dass die REPEAT -Schleife mindestens einmal durchlaufen wird, egal wie die Abbruchbedingung lautet. Syntax: REPEAT\n <instructions>\nUNTIL <boolean expression>\nEND_REPEAT; CODESYS führt die Anweisungen <instructions> solange aus, bis der boolesche Ausdruck <boolean expression> TRUE ergibt. Wenn der boolesche Ausdruck bereits bei der ersten Auswertung TRUE ergibt, dann führt CODESYS die Anweisungen genau einmal aus. Wenn der boolesche Ausdruck niemals den Wert TRUE annimmt, werden die Anweisungen endlos wiederholt, wodurch das Programm einen Laufzeitfehler verursacht. Beispiel REPEAT\n Var1 := Var1*2;\n iCounter := iCounter-1;\nUNTIL\n iCounter = 0\nEND_REPEAT; Die WHILE - und die REPEAT -Schleifen sind in gewissem Sinne mächtiger als die FOR -Schleife, da die Anzahl der Schleifendurchläufe nicht bereits vor Ausführung der Schleife bekannt sein muss. In manchen Fällen können Sie nur mit diesen beiden Schleifenarten arbeiten. Wenn jedoch die Anzahl der Schleifendurchläufe klar ist, dann ist eine FOR -Schleife zu bevorzugen, um Endlosschleifen zu vermeiden. In Erweiterung zum Standard IEC 61131-3 können Sie innerhalb der WHILE -Schleife die CONTINUE -Anweisung verwenden. " }, 
{ "title" : "ST-Anweisung: RETURN ", 
"url" : "_cds_st_instruction_return.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Anweisungen \/ ST-Anweisung: RETURN ", 
"snippet" : "RETURN Die RETURN -Anweisung verwenden Sie, um einen Funktionsbaustein zu verlassen. Dies können Sie beispielsweise von einer Bedingung abhängig machen. Beispiel IF xIsDone THEN RETURN; END_IF; iCounter := iCounter + 1; Wenn der Wert von xIsDone gleich TRUE ist, wird der Funktionsbaustein sofort ver...", 
"body" : "RETURN Die RETURN -Anweisung verwenden Sie, um einen Funktionsbaustein zu verlassen. Dies können Sie beispielsweise von einer Bedingung abhängig machen. Beispiel IF xIsDone THEN\n RETURN;\nEND_IF;\n\niCounter := iCounter + 1; Wenn der Wert von xIsDone gleich TRUE ist, wird der Funktionsbaustein sofort verlassen und die Anweisung iCounter := iCounter + 1; wird nicht ausgeführt. Da die RETURN -Anweisung auch bedingte Returns unterstützt, kann das obige Beispiel auch folgendermaßen geschrieben werden. RETURN (xIsDone);\niCounter := iCounter + 1; " }, 
{ "title" : "ST-Anweisung: JMP ", 
"url" : "_cds_st_instruction_jmp.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Anweisungen \/ ST-Anweisung: JMP ", 
"snippet" : "JMP Die JMP -Anweisung wird verwendet, um einen unbedingten Sprung zu einer Programmzeile auszuführen, die durch eine Sprungmarke gekennzeichnet ist. Syntax: <label>: <instructions> JMP <label>; Die Sprungmarke <label> ist ein beliebiger, eindeutiger Bezeichner, den Sie an den Anfang einer Programmz...", 
"body" : "JMP Die JMP -Anweisung wird verwendet, um einen unbedingten Sprung zu einer Programmzeile auszuführen, die durch eine Sprungmarke gekennzeichnet ist. Syntax: <label>: <instructions>\n\nJMP <label>; Die Sprungmarke <label> ist ein beliebiger, eindeutiger Bezeichner, den Sie an den Anfang einer Programmzeile stellen. Bei Erreichen der JMP -Anweisung erfolgt ein Rücksprung zu der Programmzeile mit der <Sprungmarke> . Beispiel iVar1 := 0;\n\n_label1: iVar1 := iVar1+1;\n\n(*instructions*)\n\nIF (iVar1 < 10) THEN\n JMP _label1;\nEND_IF; Sie müssen programmatisch sicherstellen, dass keine Endlosschleife verursacht wird. Beispielsweise können Sie den Sprung an eine Bedingung knüpfen. " }, 
{ "title" : "ST-Anweisung: EXIT ", 
"url" : "_cds_st_instruction_exit.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Anweisungen \/ ST-Anweisung: EXIT ", 
"snippet" : "EXIT Die EXIT -Anweisung verwenden Sie in einer FOR -, WHILE - oder REPEAT -Schleife, um die Schleife zu beenden, ungeachtet anderer Abbruchbedingungen....", 
"body" : "EXIT Die EXIT -Anweisung verwenden Sie in einer FOR -, WHILE - oder REPEAT -Schleife, um die Schleife zu beenden, ungeachtet anderer Abbruchbedingungen. " }, 
{ "title" : "EXST-Anweisung: CONTINUE ", 
"url" : "_cds_exst_instruction_continue.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Anweisungen \/ EXST-Anweisung: CONTINUE ", 
"snippet" : "CONTINUE CONTINUE ist eine Anweisung des Erweiterten Strukturierten Texts (ExST). Die Anweisung verwenden Sie innerhalb einer FOR -, WHILE - oder REPEAT -Schleife, damit die Ausführung zum Anfang des nächsten Schleifendurchlaufs springt. Beispiel FOR Counter:=1 TO 5 BY 1 DO INT1:=INT1\/2; IF INT1=0 T...", 
"body" : "CONTINUE CONTINUE ist eine Anweisung des Erweiterten Strukturierten Texts (ExST). Die Anweisung verwenden Sie innerhalb einer FOR -, WHILE - oder REPEAT -Schleife, damit die Ausführung zum Anfang des nächsten Schleifendurchlaufs springt. Beispiel FOR Counter:=1 TO 5 BY 1 DO\n\nINT1:=INT1\/2;\n\nIF INT1=0 THEN\n\n CONTINUE; (* to avoid a division by zero *)\n\nEND_IF\n\nVar1:=Var1\/INT1; (* executed, if INT1 is not 0 *)\n\nEND_FOR;\n\nErg:=Var1; " }, 
{ "title" : "ST-Aufruf Funktionsbaustein ", 
"url" : "_cds_st_fb_call.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Anweisungen \/ ST-Aufruf Funktionsbaustein ", 
"snippet" : "Aufruf eines Funktionsbausteins in ST Syntax <FB-instance>(<FB input variable>:=<value or address>\\|, <other FB input variables>); Beispiel TMR:TON; TMR (IN:=%OX5, PT:=T#300ms); varA:=TMR.Q; Der Timer-Funktionsbaustein TON wird in TMR:TON; instanziert und mit Zuweisungen für die Parameter IN und PT ...", 
"body" : "Aufruf eines Funktionsbausteins in ST Syntax <FB-instance>(<FB input variable>:=<value or address>\\|, <other FB input variables>); Beispiel TMR:TON;\n\nTMR (IN:=%OX5, PT:=T#300ms);\nvarA:=TMR.Q; Der Timer-Funktionsbaustein TON wird in TMR:TON; instanziert und mit Zuweisungen für die Parameter IN und PT aufgerufen. Der Ausgang Q wird mit TMR.Q angesprochen und der Variablen varA zugewiesen. " }, 
{ "title" : "ST-Kommentare ", 
"url" : "_cds_st_comment.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Programmiersprachen und ihre Editoren \/ Strukturierter Text und Erweiterter Strukturierter Text (ExST) \/ Anweisungen \/ ST-Kommentare ", 
"snippet" : "Kommentar Beschreibung Beispiel Einzeilig Es gibt zwei Möglichkeiten der Kennzeichnung: Beginnt mit \/\/ und endet am Ende der Zeile Beginnt mit \/\/\/ und endet am Ende der Zeile In CODESYS werden diese Kommentare gleich behandelt. Wenn allerdings mit Hilfe der LibDoc Scripting Collection Bibliotheksdok...", 
"body" : "Kommentar Beschreibung Beispiel Einzeilig Es gibt zwei Möglichkeiten der Kennzeichnung: Beginnt mit \/\/ und endet am Ende der Zeile Beginnt mit \/\/\/ und endet am Ende der Zeile In CODESYS werden diese Kommentare gleich behandelt. Wenn allerdings mit Hilfe der LibDoc Scripting Collection Bibliotheksdokumentation erzeugt wird, gilt Folgendes: Wenn in den Projektinformationen das Property LibDocContent = DocsOnly eingetragen ist, werden nur mit \/\/\/ gekennzeichnete Kommentare zu Bibliotheksdokumentation verarbeitet. Siehe dazu das Beispiel unterhalb der Tabelle. Wenn LibDocContent = CommentsAndDocs (Standardeinstellung) definiert ist, werden alle Kommentare zu Bibliotheksdokumentation verarbeitet. \/\/\/ This is a comment \/\/\/ This is a comment Mehrzeilig Beginnt mit (* und endet mit *) . (* This is a multiline comment *) Verschachtelt Beginnt mit (* und endet mit *) . Innerhalb dieses Kommentars können weitere (*....*)  Kommentare enthalten sein. ( * a:=inst.out; (* comment 1 *) b:=b+1; (* comment 2 *) *) Die Kommentare werden als Information zu einer Variablen in der Kommentarspalte der Variablendeklaration im Onlinebetrieb und im Tooltip angezeigt, wenn der Mauszeiger über einer Variablen steht. Dabei gelten folgende Logik und Priorisierung: Wenn ein Kommentar, der mit \/\/\/ beginnt, vor der Variablen steht, dann wird dieser Kommentar angezeigt Wenn ein Kommentar, der mit \/\/ beginnt oder innerhalb von (**) steht, nach der Variablendeklaration in der gleichen Zeile steht, dann wird dieser Kommentar angezeigt Wenn ein Kommentar, der mit \/\/ beginnt oder innerhalb von (**) steht, vor der Variablendeklaration in der gleichen Zeile steht, dann wird dieser Kommentar angezeigt Wenn im Onlinebetrieb ein Kommentar aufgrund seiner Länge nicht vollständig angezeigt werden kann, wird in diesem Kommentarfeld das Symbol angezeigt. Wenn dann der Cursor auf diesem Symbol positioniert wird, wird im Tooltip der vollständige Kommentar angezeigt. Kommentare für Tooltip und Bausteindokumentation A tooltip in the header of a POU is defined by the following comment:\n \/\/ tooltip text – line 1\n \/\/ tooltip text – line 2\n \/\/ tooltip text – line 3\n\n Afterwards the documentation is defined as follows:\n \/\/\/ reStructuredText Hinweis: Durch die verschiedenen Kommentartypen kann gesteuert werden, welche Kommentare in der Dokumentation einer Bibliothek angezeigt werden sollen, und welche Kommentare nur für Bibliotheksentwickler gedacht sind. " }, 
{ "title" : "Variablen ", 
"url" : "_cds_struct_reference_variable_types.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen ", 
"snippet" : "Der Gültigkeitsbereich einer Variablen definiert, wie und wo Sie die Variable verwenden können. Sie legen den Gültigkeitsbereich bei der Variablendeklaration fest....", 
"body" : "Der Gültigkeitsbereich einer Variablen definiert, wie und wo Sie die Variable verwenden können. Sie legen den Gültigkeitsbereich bei der Variablendeklaration fest. " }, 
{ "title" : "Variable: VAR ", 
"url" : "_cds_vartypes_var.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: VAR ", 
"snippet" : "VAR Die Deklaration lokaler Variablen erfolgt im Deklarationsteil von Programmierobjekten zwischen den Schlüsselwörtern VAR und END_VAR . Sie können auf lokale Variablen (von außerhalb über den Instanzpfad) lesend zugreifen. Die Variable kann mit einem Attribut-Schlüsselwort ( CONSTANT , RETAIN oder...", 
"body" : "VAR searchresult_toplevel Die Deklaration lokaler Variablen erfolgt im Deklarationsteil von Programmierobjekten zwischen den Schlüsselwörtern VAR und END_VAR . Sie können auf lokale Variablen (von außerhalb über den Instanzpfad) lesend zugreifen. Die Variable kann mit einem Attribut-Schlüsselwort ( CONSTANT , RETAIN oder PERSISTENT ) erweitert werden. Beispiel VAR\n iVar1 : INT;\nEND_VAR " }, 
{ "title" : "Variable: VAR_INPUT ", 
"url" : "_cds_vartypes_var_input.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: VAR_INPUT ", 
"snippet" : "VAR_INPUT Eingabevariablen sind Eingangsvariablen für einen Baustein. Sie deklarieren VAR_INPUT -Variablen im Deklarationsteil von Programmierobjekten zwischen den Schlüsselwörtern VAR_INPUT und END_VAR . Beim Aufruf wird nur der Wert übergeben (pass-by-value). Die Variable kann mit einem Attribut-S...", 
"body" : "VAR_INPUT Eingabevariablen sind Eingangsvariablen für einen Baustein. Sie deklarieren VAR_INPUT -Variablen im Deklarationsteil von Programmierobjekten zwischen den Schlüsselwörtern VAR_INPUT und END_VAR . Beim Aufruf wird nur der Wert übergeben (pass-by-value). Die Variable kann mit einem Attribut-Schlüsselwort ( CONSTANT , RETAIN oder PERSISTENT ) erweitert werden. Beispiel VAR_INPUT\n iIn1 : INT; (* 1st input variable *)\nEND_VAR " }, 
{ "title" : "Variable: VAR_OUTPUT ", 
"url" : "_cds_vartypes_var_output.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: VAR_OUTPUT ", 
"snippet" : "VAR_OUTPUT Ausgabevariablen sind Ausgangsvariablen eines Bausteins. Sie deklarieren VAR_OUTPUT -Variablen im Deklarationsteil von Programmierobjekten zwischen den Schlüsselwörtern VAR_OUTPUT und END_VAR . Die Werte dieser Variablen werden an den aufrufenden Baustein zurückgeliefert. Dort können Sie ...", 
"body" : "VAR_OUTPUT Ausgabevariablen sind Ausgangsvariablen eines Bausteins. Sie deklarieren VAR_OUTPUT -Variablen im Deklarationsteil von Programmierobjekten zwischen den Schlüsselwörtern VAR_OUTPUT und END_VAR . Die Werte dieser Variablen werden an den aufrufenden Baustein zurückgeliefert. Dort können Sie die Werte abfragen und weiter verwenden. Die Variable kann mit einem Attribut-Schlüsselwort ( CONSTANT , RETAIN oder PERSISTENT ) erweitert werden. Beispiel VAR_OUPUT\n iOut1 : INT; (*1st output variable *)\nEND_VAR Ausgabevariablen in Funktionen und Methoden Gemäß der Norm IEC 61131-3 können Funktionen (und Methoden) zusätzliche Ausgänge haben. Die zusätzlichen Ausgänge müssen Sie beim Aufruf der Funktion wie im folgenden Beispiel zuweisen. Beispiel fun(iIn1 := 1, iIn2 := 2, iOut1 => iLoc1, iOut2 => iLoc2); " }, 
{ "title" : "Variable: VAR_IN_OUT ", 
"url" : "_cds_vartypes_var_in_out.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: VAR_IN_OUT ", 
"snippet" : "VAR_IN_OUT Eine VAR_IN_OUT -Variable ist eine Ein- und Ausgabevariable, die Teil einer Bausteinschnittstelle ist und als formaler Durchgangsparameter dient. Syntax <keyword> <POU name> VAR_IN_OUT <variable name> : <data type>; END_VAR <keyword> : FUNCTION | FUNCTION_BLOCK | METHOD | PRG Sie können e...", 
"body" : "VAR_IN_OUT Eine VAR_IN_OUT -Variable ist eine Ein- und Ausgabevariable, die Teil einer Bausteinschnittstelle ist und als formaler Durchgangsparameter dient. Syntax <keyword> <POU name>\nVAR_IN_OUT\n <variable name> : <data type>;\nEND_VAR\n\n<keyword> : FUNCTION | FUNCTION_BLOCK | METHOD | PRG Sie können eine Ein- und Ausgabevariable in den Programmierbausteinen PRG , FUNCTION_BLOCK , METHOD oder FUNCTION im Deklarationsabschnitt VAR_IN_OUT deklarieren. Die VAR_IN_OUT -Variable kann gelesen und beschrieben werden. Verwendung Aufruf : Bei Aufruf des Programmierbausteins erhält die formale VAR_IN_OUT -Variable als Argument die tatsächliche Variable, die so genannte „Durchgangsvariable“. Zur Laufzeit bei der Parameterübergabe wird dann keine Kopie erzeugt, sondern die formale Variable erhält eine Referenz auf die von außen übergebene tatsächliche Variable. Die referenziellen Variablen enthalten intern als Wert eine Speicheradresse auf den eigentlichen Wert ( Übergabe als Pointer , Call-by-Reference ). Es ist nicht möglich als Argument direkt eine Konstante (Literal) oder eine Bitvariable anzugeben. Schreib-\/Lesezugriff innerhalb des Programmierbausteins : Wenn innerhalb des Programmierbausteins auf die Variable geschrieben wird, wirkt dies auf die übergebene Variable durch. Wenn der Programmierbaustein verlassen wird, bleiben vorgenommene Änderungen somit erhalten. Das bedeutet, dass ein Programmierbaustein seine VAR_IN_OUT -Variablen so verwendet, wie der aufrufende Programmierbaustein seine Variablen verwendet. Ein Lesezugriff ist immer erlaubt. Schreib-\/Lesezugriff von außen : VAR_IN_OUT -Variablen können nicht via <function block instance name>.<variable name> direkt von außen gelesen oder beschrieben werden. Dies funktioniert nur bei VAR_INPUT und VAR_OUTPUT -Variablen. Übergabe von Stringvariablen : Wenn als Argument eine Stringvariable übergeben wird, sollten die tatsächliche Variable und die formale Variable die gleiche Länge haben. Andernfalls kann der übergebene String unbeabsichtigt manipuliert werden. Bei VAR_OUTPUT CONSTANT -Parametern tritt dieses Problem nicht auf. Übergabe von Bitvariablen : Eine Bitvariable kann nicht direkt an eine VAR_IN_OUT -Variable übergeben werden, sondern benötigt eine Zwischenvariable. Übergabe von Propertys : Nicht erlaubt Wenn eine Zeichenkette als Variable oder auch als Konstante an eine formale VAR_IN_OUT CONSTANT -Variable übergeben wird, dann wird sie automatisch vollständig übergeben. Sie müssen nicht auf die Stringlänge achten. Für weitere Informatioen siehe: Übergabevariable VAR_IN_OUT CONSTANT Beispiel Übergabe eines Arrays TYPE DUT_A :\nSTRUCT\n xA: BOOL;\n iB: INT;\nEND_STRUCT\nEND_TYPE\n\nFUNCTION_BLOCK FB_SetArray\nVAR_IN_OUT\n aData_A : ARRAY[0..1] OF DUT_A; \/\/ Formal variable\nEND_VAR\naData_A[0].xA := TRUE;\naData_A[0].iB := 100;\n\nPROGRAM PLC_PRG\nVAR\n fbSetA : FB_SetArray;\n aSpecialData : ARRAY[0..1] OF DUT_A; \/\/ Actual variable\nEND_VAR\nfbSetA(aData_A := aSpecialData); Stringübergabe {attribute 'qualified_only'}\nVAR_GLOBAL\n g_sDEV_STATUS : STRING(25) := 'Device_A';\nEND_VAR\n\nFUNCTION_BLOCK FB_SetStatus\nVAR_IN_OUT\n sDeviceStatus : STRING(25); \/\/ Formal parameter\nEND_VAR\nsDeviceStatus := CONCAT(sDeviceStatus, ' Activ');\n\nPROGRAM PLC_PRG\nVAR\n fbDoB : FB_SetStatus;\nEND_VAR\nfbDoB(sDeviceStatus := GVL.g_sDEV_STATUS); \/\/Call with actual parameter Die Variable sDeviceStatus ist Teil der Bausteinschnittstelle von FB_B . Bei Aufruf von fbDoB wird dem String zunächst ein Gerätenamen zugewiesen, dann wird der String manipuliert. Übergabe einer Bitvariablen VAR_GLOBAL\n xBit0 AT %MX0.1 : BOOL;\n xTemp : BOOL;\nEND_VAR\n\nFUNCTION_BLOCK FB_DoSomething\nVAR_INPUT\n xIn : BOOL;\nEND_VAR\nVAR_IN_OUT\n xInOut : BOOL;\nEND_VAR\nIF xIn THEN\n xInOut := TRUE;\nEND_IF\n\nPROGRAM PLC_PRG\nVAR\n xIn : BOOL;\n DoSomething_1 : FB_DoSomething;\n DoSomething_2 : FB_DoSomething;\nEND_VAR\n\n\/\/ The following line of code causes a compiler error:\n\/\/ C0201: Typ 'BIT' is not equal to type 'BOOL' of VAR_IN_OUT 'xInOut'\nDoSomething_1(xIn := xIn, xInOut := xBit0);\n\n\/\/ Workaround\nxTemp := xBit0;\nDoSomething_2(xIn := xIn, xInOut := xTemp);\nxBit0 := xTemp; Das Programm ruft die Funktionsbaustein-Instanzen DoSomething_1 und DoSomething_2 auf. Wegen der direkten Zuweisung der Bitvariablen xBit0 an den VAR_IN_OUT -Eingang wird beim Aufruf der Instanz DoSomething_1 ein Compilerfehler erzeugt. Der Aufruf der Instanz DoSomething_2 mit Zuweisen einer Zwischenvariablen ist dagegen ein korrekter Code. " }, 
{ "title" : "Übergabevariable VAR_IN_OUT CONSTANT ", 
"url" : "_cds_vartypes_var_in_out.html#UUID-32134341-4b6c-acd3-aa57-48bb400d17e2_id_e5c8916dc25ffdfc0a8640e01bbaaae_id_dfbe41aa0aeae611c0a864633d68e93e", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: VAR_IN_OUT \/ Übergabevariable VAR_IN_OUT CONSTANT ", 
"snippet" : "Eine VAR_IN_OUT CONSTANT -Variable dient als konstanter Durchgangsparameter, an den eine Variable aber auch eine Konstante (Literal) vom Typ STRING oder WSTRING übergeben werden kann. Der Parameter kann gelesen, aber nicht beschrieben werden. Die Übergabe von Propertys Ist nicht erlaubt. Syntax Dekl...", 
"body" : "Eine VAR_IN_OUT CONSTANT -Variable dient als konstanter Durchgangsparameter, an den eine Variable aber auch eine Konstante (Literal) vom Typ STRING oder WSTRING übergeben werden kann. Der Parameter kann gelesen, aber nicht beschrieben werden. Die Übergabe von Propertys Ist nicht erlaubt. Syntax Deklaration <keyword> <POU name>\nVAR_IN_OUT CONSTANT\n <variable name> : <data type>; \/\/ formal parameter\nEND_VAR\n<keyword> : FUNCTION | FUNCTION_BLOCK | METHOD | PRG VAR_IN_OUT CONSTANT -Variablen werden deklariert, ohne einen Initialisierungswert zuzuweisen. Verwendung Bei Aufruf des Programmierbausteins kann eine konstante Variable oder ein Literal vom Typ STRING oder WSTRING übergeben werden. Folglich sind Schreibzugriffe nicht erlaubt. Bei Parameterübergabe einer Stringkonstanten: Die Stringlänge der Konstanten kann beliebig sein und hängt nicht von der Stringlänge der VAR_IN_OUT CONSTANT -Variablen ab. Wenn in Projekt → Projekteinstellungen in Kategorie Compile-Optionen die Option Konstanten ersetzen aktiviert ist, dann erzeugt die Parameterübergabe einer Konstanten mit Basisdatentyp oder einer konstanten Variablen mit Basisdatentyp einen Compilerfehler. Die Variable wird ab Compilerversion >= 3.5.2.0 unterstützt. Beispiel Parameterübergabe von Stringkonstanten und Stringvariablen FUNCTION funManipulate : BOOL\nVAR_IN_OUT\n sReadWrite : STRING(16); (* Can be read or written here in POU *)\n dwVarReadWrite : DWORD; (* Can be read or written here in POU *)\nEND_VAR\nVAR_IN_OUT CONSTANT\n c_sReadOnly : STRING(16); (* Constant string variable can only be read here in POU *)\nEND_VAR\n\nsReadWrite := 'String_from_POU';\ndwVarReadWrite := STRING_TO_DWORD(c_sReadOnly);\n\nPROGRAM PRG_A\nVAR\n sVarFits : STRING(16);\n sValFits : STRING(16) := '1234567890123456';\n dwVar: DWORD;\nEND_VAR\n\n\/\/ The following line of code causes the compiler error C0417:\n\/\/ C0417: VAR_IN_OUT parameter 'sReadWrite' needs a variable with write access as input.\nfunManipulate(sReadWrite:='1234567890123456', c_sReadOnly:='1234567890123456', dwVarReadWrite := dwVar);\n\n\/\/ Correct code\nfunManipulate(sReadWrite := sValFits, c_sReadOnly := '23', dwVarReadWrite := dwVar);\nfunManipulate(sReadWrite := sVarFits, c_sReadOnly := sValFits, dwVarReadWrite := dwVar); Im Code werden Strings über verschiedene VAR_IN_OUT -Variablen an die Funktion funManipulate übergeben. Bei Übergabe eines Stringliterals an eine VAR_IN_OUT -Variable wird ein Compilerfehler ausgegeben. Bei Übergabe einer konstanten Variablen an eine VAR_IN_OUT CONSTANT -Variable wird korrekter Code erzeugt, ebenso bei der Übergabe von Stringvariablen. " }, 
{ "title" : "Variable: VAR_GLOBAL ", 
"url" : "_cds_vartypes_var_global.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: VAR_GLOBAL ", 
"snippet" : "VAR_GLOBAL Eine lokal in einem Baustein deklarierte Variable, die denselben Namen hat wie eine globale Variable, hat innerhalb des Bausteins Vorrang. Ab Compilerversion 3.2.0.0 initialisiert CODESYS globale Variablen immer vor den lokalen Variablen von POUs. Globale Variablen sind Variablen, Konstan...", 
"body" : "VAR_GLOBAL Eine lokal in einem Baustein deklarierte Variable, die denselben Namen hat wie eine globale Variable, hat innerhalb des Bausteins Vorrang. Ab Compilerversion 3.2.0.0 initialisiert CODESYS globale Variablen immer vor den lokalen Variablen von POUs. Globale Variablen sind Variablen, Konstanten, externe oder remanente Variablen, die im gesamten Projekt bekannt sind. Sie deklarieren globale Variablen in globalen Variablenlisten oder im Deklarationsteil von Programmierobjekten zwischen den Schlüsselwörtern VAR_GLOBAL und END_VAR . Beispiel VAR_GLOBAL\n g_iVar1 : INT;\nEND_VAR Das System erkennt eine globale Variable, wenn Sie dem Variablennamen ein Punkt voranstellen, beispielsweise .g_iVar1 . " }, 
{ "title" : "Variable: VAR_TEMP ", 
"url" : "_cds_vartypes_var_temp.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: VAR_TEMP ", 
"snippet" : "VAR_TEMP Diese Funktionalität ist eine Erweiterung bezüglich der Norm IEC 61131-3. Sie deklarieren temporäre Variablen lokal zwischen den Schlüsselwörtern VAR_TEMP und END_VAR . VAR_TEMP -Deklarationen sind nur in Programmen und Funktionsbausteinen möglich. CODESYS initialisiert temporäre Variablen ...", 
"body" : "VAR_TEMP Diese Funktionalität ist eine Erweiterung bezüglich der Norm IEC 61131-3. Sie deklarieren temporäre Variablen lokal zwischen den Schlüsselwörtern VAR_TEMP und END_VAR . VAR_TEMP -Deklarationen sind nur in Programmen und Funktionsbausteinen möglich. CODESYS initialisiert temporäre Variablen bei jedem Aufruf des Bausteins neu. Auf die temporären Variablen kann die Applikation nur im Implementierungsteil eines Programms oder eines Funktionsbausteins zugreifen. VAR_TEMP\n iVarTmp1 : INT; (*1st temporary variable *)\nEND_VAR " }, 
{ "title" : "Variable: VAR_STAT ", 
"url" : "_cds_vartypes_var_stat.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: VAR_STAT ", 
"snippet" : "VAR_STAT Diese Funktionalität ist eine Erweiterung bezüglich der Norm IEC 61131-3. Statische Variablen deklarieren Sie lokal zwischen den Schlüsselwörtern VAR_STAT und END_VAR . Die statischen Variablen werden beim Download initialisiert. Auf statische Variablen können Sie nur innerhalb des Namensra...", 
"body" : "VAR_STAT Diese Funktionalität ist eine Erweiterung bezüglich der Norm IEC 61131-3. Statische Variablen deklarieren Sie lokal zwischen den Schlüsselwörtern VAR_STAT und END_VAR . Die statischen Variablen werden beim Download initialisiert. Auf statische Variablen können Sie nur innerhalb des Namensraums, in dem die Variablen deklariert sind, zugreifen (wie bei statischen Variablen in C). Jedoch behalten statische Variablen ihren Wert, wenn die Applikation den Baustein verlassen hat. Sie können statische Variablen beispielsweise als Zähler für Funktionsaufrufe verwenden. Die Variable kann mit einem Attribut-Schlüsselwort ( CONSTANT , RETAIN oder PERSISTENT ) erweitert werden. Beispiel VAR_STAT\n iVarStat1 : INT;\nEND_VAR " }, 
{ "title" : "Variable: VAR_EXTERNAL ", 
"url" : "_cds_vartypes_var_external.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: VAR_EXTERNAL ", 
"snippet" : "VAR_EXTERNAL Externe Variablen sind globale Variablen, die in einen Baustein „importiert“ werden. Die Variablen deklarieren Sie zwischen den Schlüsselwörtern VAR_EXTERNAL und END_VAR . Wenn die globale Variable nicht existiert, wird eine Fehlermeldung ausgegeben. In CODESYS ist es nicht notwendig ei...", 
"body" : "VAR_EXTERNAL Externe Variablen sind globale Variablen, die in einen Baustein „importiert“ werden. Die Variablen deklarieren Sie zwischen den Schlüsselwörtern VAR_EXTERNAL und END_VAR . Wenn die globale Variable nicht existiert, wird eine Fehlermeldung ausgegeben. In CODESYS ist es nicht notwendig eine globale Variablen als extern zu deklarieren, um sie in einer POU zu verwenden. Das Schlüsselwort existiert nur, um die Kompatibilität zu IEC 61131-3 zu wahren. Syntax <POU keyword> <POU name>\nVAR_EXTERNAL\n <variable name> : <data type>;\nEND_VAR Eine Initialisierung ist nicht erlaubt. Beispiel FUNCTION_BLOCK FB_DoSomething\nVAR_EXTERNAL\n iVarExt1 : INT; (* 1st external variable *)\nEND_VAR " }, 
{ "title" : "Variable: VAR_INST ", 
"url" : "_cds_vartypes_var_inst.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: VAR_INST ", 
"snippet" : "VAR_INST Die Instanzvariablen VAR_INST sind nur in Methoden erlaubt. Nur innerhalb der Methode kann auf eine solche Variable zugegriffen werden. Sie können die Variablenwerte von Instanzvariablen im Deklarationsteil der Methode monitoren. CODESYS legt eine VAR_INST -Variable einer Methode nicht auf ...", 
"body" : "VAR_INST Die Instanzvariablen VAR_INST sind nur in Methoden erlaubt. Nur innerhalb der Methode kann auf eine solche Variable zugegriffen werden. Sie können die Variablenwerte von Instanzvariablen im Deklarationsteil der Methode monitoren. CODESYS legt eine VAR_INST -Variable einer Methode nicht auf dem Methodenstack, sondern auf dem Stack der Funktionsbaustein-Instanz ab. Dies bedeutet, dass sich die VAR_INST -Variable wie andere Variablen der Funktionsbaustein-Instanz verhält und nicht bei jedem Aufruf der Methode neu initialisiert wird. Die Variable kann mit einem Attribut-Schlüsselwort ( CONSTANT , RETAIN oder PERSISTENT ) erweitert werden. Beispiel METHOD meth_last : INT\nVAR_INPUT\n iVar : INT;\nEND_VAR\nVAR_INST\n iLast : INT := 0;\nEND_VAR\nmeth_last := iLast;\niLast := iVar; " }, 
{ "title" : "Variable: VAR_CONFIG ", 
"url" : "_cds_vartypes_var_config.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: VAR_CONFIG ", 
"snippet" : "VAR_CONFIG Konfigurationsvariablen weisen Variablen, die in Funktionsbausteinen mit unvollständigen Adressangaben deklariert sind und auf Geräte-E\/As abgebildet werden sollen, vollständige Adresse zu. Die Deklaration erfolgt in einer globalen Variablenliste zwischen den Schlüsselwörtern VAR_CONFIG u...", 
"body" : "VAR_CONFIG Konfigurationsvariablen weisen Variablen, die in Funktionsbausteinen mit unvollständigen Adressangaben deklariert sind und auf Geräte-E\/As abgebildet werden sollen, vollständige Adresse zu. Die Deklaration erfolgt in einer globalen Variablenliste zwischen den Schlüsselwörtern VAR_CONFIG und END_VAR mit vollständigem Instanzpfad und mit der korrekten Adresse. Eine solche globale Variablenliste wird „Variablenkonfiguration“ genannt. Beispiel Deklaration der Variablen xLocIn mit unvollständiger Adresse %I* in einem Funktionsbaustein. FUNCTION_BLOCK locio\n\nVAR\n xLocIn AT %I* : BOOL := TRUE;\nEND_VAR Der Funktionsbaustein locio wird im Programm PLC_PRG verwendet. PROGRAM PLC_PRG\n\nVAR\n locioVar1 : locio;\nEND_VAR Die korrekte Variablenkonfiguration in der globalen Variablenliste lautet: VAR_CONFIG\n PLC_PRG.locioVar1.xLocIn AT %IX1.0 : BOOL;\nEND_VAR " }, 
{ "title" : "Variable: CONSTANT ", 
"url" : "_cds_vartypes_constant.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: CONSTANT ", 
"snippet" : "CONSTANT Die Deklaration konstanter Variablen erfolgt in den globalen Variablenlisten oder im Deklarationsteil von Programmierobjekten. In Implementierungen kann auf konstante Variablen über den Instanzpfad lesend zugegriffen werden, aber nicht schreibend. Syntax <scope> CONSTANT <identifier> : <dat...", 
"body" : "CONSTANT Die Deklaration konstanter Variablen erfolgt in den globalen Variablenlisten oder im Deklarationsteil von Programmierobjekten. In Implementierungen kann auf konstante Variablen über den Instanzpfad lesend zugegriffen werden, aber nicht schreibend. Syntax <scope> CONSTANT\n <identifier> : <data type> := <initial value> ;\nEND_VAR\n\n<scope> : VAR | VAR_INPUT | VAR_STAT | VAR_GLOBAL\n<data type>: <elementary data type> | <user defined data type> | <function block>\n<initial value> : <literal value> | <identifier> | <expression> Weisen Sie bei der Deklaration einer konstanten Variable immer einen Initialisierungswert zu. Danach kann die Konstante nicht mehr beschrieben werden. Beispiel Deklaration VAR CONSTANT\n c_rTAXFACTOR : REAL := 1.19;\nEND_VAR Aufruf rPrice := rValue * c_rTAXFACTOR; Sie können in einer Implementierung nur lesend auf konstante Variablen zugreifen. Konstante Variablen stehen rechts vom Zuweisungsoperator. Für weitere Informationen siehe: Operanden" }, 
{ "title" : "Variable: VAR_GENERIC CONSTANT ", 
"url" : "_cds_vartypes_var_generic_constant.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: VAR_GENERIC CONSTANT ", 
"snippet" : "VAR_GENERIC CONSTANT Konstante generische Variable Eine generische Konstante ist eine Variable im Gültigkeitsbereich VAR_GENERIC CONSTANT eines Funktionsbausteins. Die Variable wird erst bei der Deklaration der Funktionsbaustein-Instanz definiert. Es ist erlaubt in Methoden generische Konstanten zu ...", 
"body" : "VAR_GENERIC CONSTANT Konstante generische Variable Eine generische Konstante ist eine Variable im Gültigkeitsbereich VAR_GENERIC CONSTANT eines Funktionsbausteins. Die Variable wird erst bei der Deklaration der Funktionsbaustein-Instanz definiert. Es ist erlaubt in Methoden generische Konstanten zu verwenden. Insbesondere in VAR_IN_OUT oder VAR_IN_OUT CONSTANT -Bereichen kann das hilfreich sein. " }, 
{ "title" : "Syntax der Typdeklaration ", 
"url" : "_cds_vartypes_var_generic_constant.html#UUID-423cfb9f-ca4e-13fd-6267-abdbf0cb4cff_section-idm234820160791049", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: VAR_GENERIC CONSTANT \/ Syntax der Typdeklaration ", 
"snippet" : "Syntax der Typdeklaration eines Funktionsbausteins mit generischen Konstanten FUNCTION_BLOCK <function block name> VAR_GENERIC CONSTANT <generic constant name> : <integer data type> := <initial value> ; \/\/Initial value will be overwritten END_VAR <function block name> Name des Funktionsbausteins VAR...", 
"body" : "Syntax der Typdeklaration eines Funktionsbausteins mit generischen Konstanten FUNCTION_BLOCK <function block name>\nVAR_GENERIC CONSTANT\n <generic constant name> : <integer data type> := <initial value> ; \/\/Initial value will be overwritten\nEND_VAR\n\n <function block name> Name des Funktionsbausteins VAR_GENERIC CONSTANT END_VAR Gültigkeitsbereich für generische Konstanten Sie können im VAR_GENERIC CONSTANT -Bereich beliebig viele generische Konstanten deklarieren. <generic constant name> Variablenname der generischen Konstanten : <integer data type> Konstrukt, das die generische Konstante typisiert. Erlaubt ist ein ganzzahliger Datentyp oder der Teilbereich eines ganzzahligen Datentyps. Beispiel: maxlen1 : INT := 4; maxlen2 : INT(5..10) := 5; := <initial value> Optional Initialisierung Der Initialwert wird nur für Compile-Prüfungen benötigt. Zur Laufzeit wird der Wert überschrieben. Die generische Konstante kann in der Implementierung des Funktionsbausteins wie üblich verwendet werden. Solche Konstanten können beispielsweise für die Indizes von Arrays oder die Länge von Strings verwendet werden. " }, 
{ "title" : "Syntax der Variablendeklaration ", 
"url" : "_cds_vartypes_var_generic_constant.html#UUID-423cfb9f-ca4e-13fd-6267-abdbf0cb4cff_section-idm234820159794331", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: VAR_GENERIC CONSTANT \/ Syntax der Variablendeklaration ", 
"snippet" : "Syntax der Variablendeklaration (Instanziierung des Funktionsbausteins) mit spezifizierter Konstante Es sind folgende Optionen möglich: PROGRAM <program name> VAR <fb instance name> : <function block name> < <literal> > ; <fb instance name> : <function block name> <( <expression> )> ; <fb instance n...", 
"body" : "Syntax der Variablendeklaration (Instanziierung des Funktionsbausteins) mit spezifizierter Konstante Es sind folgende Optionen möglich: PROGRAM <program name>\nVAR\n <fb instance name> : <function block name> < <literal> > ;\n <fb instance name> : <function block name> <( <expression> )> ;\n <fb instance name> : ARRAY [ <index start > .. <index end> ] OF <function block name> < <array length> > ;\nEND_VAR\n Variablendeklaration <scope> END_... Gültigkeitsbereich <fb instance name> Variable, Name der Funktionsbaustein-Instanz : <function block name> Typisiert die Variable mit dem Funktionsbaustein Es handelt sich um einen Funktionsbaustein mit generischen Konstanten. < <literal> > Optional Weist dem Datentyp einen spezifischen Wert zu, der nur für diese Funktionsbaustein-Instanz gültig ist. Der Wert wird formal als Anhängsel des Datentyps in spitzen Klammern eingefügt. Beispiel: fbMyString1 : FB_MyString<100&>; Wenn beim typgebenden Funktionsbaustein mehrere generische Konstanten deklariert wurden, wird eine mit Komma separierte Liste an Werten in spitzen Klammern übergeben. Ein Wert für jede Konstante. Beispiel: fbPou : FB_Pou<100, 1000>; <( <expression> )> Optional Weist dem Datentyp einen spezifischen Ausdruck zu, der nur für diese Funktionsbaustein-Instanz gültig ist. Der Ausdruck wird als Anhängsel des Datentyps in spitzen Klammern eingefügt. Der Ausdruck selbst muss in runde Klammern gesetzt werden. Die runde Klammer ist nötig, da es bei einem Ausdruck erlaubt ist, Symbole wie < oder > zu verwenden. Sonst ist die Eindeutigkeit des Codes nicht mehr gewährleistet. Beispiel: fbMyString2 : FB_MyString<(2 * cconst)>; ARRAY [ <start index start> .. <end index> ] OF <function block name> Optional Typisiert die Variable mit einem Array von Funktionsbausteinen. Die Länge des Arrays ist: <end index> - <start index> + 1 Es handelt sich um einen Funktionsbaustein mit generischen Konstanten. Die Konstanten werden als Arrayindizes verwendet. Beispiel: arrMyString < <array length> > Weist dem Datentyp eine spezifische Arraylänge zu, die speziell für diese Funktionsbaustein-Instanz gültig ist. Die spezifische Arraylänge wird formal als Anhängsel des Datentyps in spitzen Klammern eingefügt. Der spezifizierte Wert muss mit der Arraylänge übereinstimmen, die durch Startindex und Endindex definiert ist. Beispiel: arrMyString : ARRAY[0..5] OF FB_MyStrin<6>; " }, 
{ "title" : "Beispiele ", 
"url" : "_cds_vartypes_var_generic_constant.html#UUID-423cfb9f-ca4e-13fd-6267-abdbf0cb4cff_section-idm234820152486478", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: VAR_GENERIC CONSTANT \/ Beispiele ", 
"snippet" : "Beispiel für die Verwendung mehrerer generischer Konstanten FUNCTION_BLOCK FB_Pou VAR_GENERIC CONSTANT lnstring : DINT := 10; numstring : DINT := 100; END_VAR VAR arraystring : ARRAY[0..numstring-1] OF STRING(lnstring); END_VAR ; PROGRAM PLC_PRG VAR fbPou : FB_Pou<100, 1000>; END_VAR Beispiel: Gener...", 
"body" : "Beispiel für die Verwendung mehrerer generischer Konstanten FUNCTION_BLOCK FB_Pou\nVAR_GENERIC CONSTANT\n lnstring : DINT := 10;\n numstring : DINT := 100;\nEND_VAR\nVAR\n arraystring : ARRAY[0..numstring-1] OF STRING(lnstring);\nEND_VAR\n; PROGRAM PLC_PRG\nVAR\n fbPou : FB_Pou<100, 1000>;\nEND_VAR Beispiel: Generische Konstante eines Teilbereich-Typs FUNCTION_BLOCK FB_SrString \nVAR_GENERIC CONSTANT\n maxlen2 : INT(5..10) := 5; \/\/subrange data type\nEND_VAR\nVAR\n arrTest : ARRAY[0..maxlen-1] OF BYTE;\nEND_VAR\n; PROGRAM SrMain\nVAR CONSTANT\n cconst: INT(5..10) := 5;\nEND_VAR\nVAR \n fbMyString1 : FB_SrString<5>;\n fbMyString2 : FB_SrString<(2 * cconst)>;\n arrMyString : ARRAY [0..5] OF FB_SrString<6>;\nEND_VAR Beispiel: Generischer Funktionsbaustein mit parametrierbarer Arrayvariable Der folgende Code zeigt, wie ein Funktionsbaustein zu definieren ist, der Arrays beliebiger Länge verarbeiten kann. Der Funktionsbaustein verfügt über ein Array mit einer generischen, aber konstanten Länge. Mit \"konstant\" ist gemeint, dass, obwohl jede Funktionsbaustein-Instanz in ihrer Arraylänge variiert, diese während der Lebensdauer des Objekts konstant ist. Ein solches Konstrukt ist beispielsweise für einen Bibliotheksprogrammierer von Vorteil, der einen generischen Bibliotheksbaustein implementieren möchte. FUNCTION_BLOCK FB_MyString \nVAR_GENERIC CONSTANT\n maxlen : UDINT := 1;\nEND_VAR\nVAR\n test : ARRAY[0..maxlen-1] OF BYTE;\nEND_VAR\n; PROGRAM PLC_PRG\nVAR CONSTANT\n cconst: DINT := 1000;\nEND_VAR\nVAR \n fbMyString1 : FB_MyString<100>;\n fbMyString2 : FB_MyString<(2 * cconst)>; \n arrMyString : ARRAY[0..5] OF FB_MyString<6>; \nEND_VAR\n; " }, 
{ "title" : "Vererbung ", 
"url" : "_cds_vartypes_var_generic_constant.html#UUID-423cfb9f-ca4e-13fd-6267-abdbf0cb4cff_section-idm4622913801579232886674449065", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: VAR_GENERIC CONSTANT \/ Vererbung ", 
"snippet" : "Ein Funktionsbaustein kann von einem Basis-Funktionsbaustein mit generischer Konstante ( EXTENDS ) erben. Der erbende Funktionsbaustein benötigt eine eigene generische Konstante. Von außen kann dann ein spezifischer Wert übergeben werden. Syntax: FUNCTION_BLOCK <function block name> VAR_GENERIC CONS...", 
"body" : "Ein Funktionsbaustein kann von einem Basis-Funktionsbaustein mit generischer Konstante ( EXTENDS ) erben. Der erbende Funktionsbaustein benötigt eine eigene generische Konstante. Von außen kann dann ein spezifischer Wert übergeben werden. Syntax: FUNCTION_BLOCK <function block name> \nVAR_GENERIC CONSTANT \n <generic constant name> : <integer data type> ; \nEND_VAR \nEXTENDS <function block base> < <generic constant name> >\n Ein Funktionsbaustein mit generischer Konstante kann eine Schnittstelle implementieren ( IMPLEMENTS . Die Schnittstelle deklariert eine Eigenschaft ( PROPERTY ) mit der von außen auf den spezifizierten Wert zugegriffen werden kann. Die Schnittstelle selbst darf keine generischen Konstanten oder lokale Variablen deklarieren. Schnittstellen haben keine Implementierung. Syntax: FUNCTION_BLOCK <function block name>\nVAR_GENERIC CONSTANT\n <generic constant name> : <integer data type> ;\nEND_VAR\nIMPLEMENTS <interface name>\n Achten Sie beim Kodieren darauf, dass erst die Deklaration der generischen Konstanten eingefügt wird und dann EXTENDS und IMPLEMENTS nachfolgen. Das ist gewöhnungsbedürftig, hat aber den Grund, dass generische Konstanten auch bei Basisklassen verwendet werden können. Beispiel Definition der Schnittstelle IString für einen generischen Funktionsbaustein. Es wird dringend empfohlen für generische Funktionsbausteine eine Schnittstelle zu definieren. Die Schnittstelle soll die Verwendung der generischen Funktionsbaustein-Instanz ohne Kenntnis der generischen Konstanten ermöglichen. Die Eigenschaft Length ermöglicht den Zugriff auf die generische Konstante. INTERFACE IString \nMETHOD Append : BOOL \nVAR_INPUT \n strAppend : IString; \nEND_VAR \n\nMETHOD Assign : BOOL\nVAR_INPUT \n stringIn : STRING; \nEND_VAR \n\nMETHOD ToString : STRING\nVAR_INPUT \nEND_VAR \n\nPROPERTY Length : DINT Deklaration des Funktionsbausteins FB_MyString mit der generischen Konstanten maxlen FUNCTION_BLOCK FB_MyString \nVAR_GENERIC CONSTANT \n maxlen : UDINT; \nEND_VAR \nIMPLEMENTS IString \n Der Funktionsbaustein FB_LongString ist eine Erweiterung des spezifizierten Funktionsbausteins FB_MyString . FUNCTION_BLOCK FB_LongString EXTENDS FB_MyString<1000> Deklaration des Funktionsbausteins FB_MySpecialString mit der generischen Konstanten maxlen2 als Erweiterung des spezifizierten Funktionsbausteins FB_MyString . Der Funktionsbaustein ist erweitert um die Methode METH_ToLatin . FUNCTION_BLOCK FB_MySpecialString \nVAR_GENERIC CONSTANT \n maxlen2 : UDINT:= 1; \nEND_VAR \nEXTENDS FB_MyString<maxlen2>\n METHOD METH_ToLatin : STRING\nVAR_INPUT\nEND_VAR Instanziierung der Funktionsbausteine mit spezifischen Konstanten PROGRAM PLC_PRG \nVAR CONSTANT \n cconst: DINT := 1000; \nEND_VAR\nVAR \n string1 : FB_MyString<100>;\n string2 : FB_MyString<(2 * cconst)>;\n derived1 : FB_LongString;\n derived2 : FB_MySpecialString<100>;\nEND_VAR \n Aufrufe string1.METH_Assign ('Welt'); \nstring2.METH_Assign ('Hallo '); \nstring2.METH_Append(string1); \nderived2.METH_ToLatin('Hello World'); " }, 
{ "title" : "Variable: PERSISTENT ", 
"url" : "_cds_var_persistent.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: PERSISTENT ", 
"snippet" : "PERSISTENT Persistente Variablen werden in der persistenten globalen Variablenliste im Deklarationsabschnitt VAR_GLOBAL RETAIN PERSISTENT deklariert. Für Variablen, die außerhalb des Persistenzeditors mit dem Schlüsselwort PERSISTENT gekennzeichnet sind, werden dort Instanzpfade hinzugefügt. Ab CODE...", 
"body" : "PERSISTENT Persistente Variablen werden in der persistenten globalen Variablenliste im Deklarationsabschnitt VAR_GLOBAL RETAIN PERSISTENT deklariert. Für Variablen, die außerhalb des Persistenzeditors mit dem Schlüsselwort PERSISTENT gekennzeichnet sind, werden dort Instanzpfade hinzugefügt. Ab CODESYS -Version 3.3.0.1 bewirkt eine Variablendeklaration mit PERSISTENT RETAIN dasselbe wie mit RETAIN PERSISTENT oder PERSISTENT . Syntax der Deklaration in der globalen persistenten Variablenliste PersistentVars VAR_GLOBAL PERSISTENT RETAIN\n <identifier> : <data type> (:= <initialization>)?;\n <instance path to POU variable>\nEND_VAR Syntax der Deklaration in POUs <scope> PERSISTENT RETAIN\n <identifier> : <data type> ( := <initialization> )?; \/\/ ( ... )? : Optional\nEND_VAR\n<scope> : VAR | VAR_INPUT | VAR_OUTPUT | VAR_IN_OUT | VAR_STAT | VAR_GLOBAL Eine Zuweisung von Ein-, Ausgabe- oder Speicheradressen mit dem Schlüsselwort AT ist nicht erlaubt. Verwenden Sie in persistenten Variablenlisten nie den Datentyp POINTER TO . Bei erneutem Download der Applikation können sich nämlich deren Adressen verändern. Im Meldungsfenster werden entsprechende Compilerwarnungen ausgegeben. Wenn Sie die Namen oder die Datentypen einer remanenten Variablen häufig ändern, ist es besser, diese als Retain-Variablen nur mit dem Schlüsselwort RETAIN zu deklarieren. Vermeiden Sie das Einfügen von Instanzpfaden, da in diesem Fall doppelt so viel Speicher verbraucht wird und eine erhöhte Zykluszeit auftreten kann. Deklarieren Sie stattdessen Variablen direkt in der Liste der persistenten Variablen. Beispiel Deklaration in der persistenten Variablenliste PersistentVars {attribute 'qualified_only'}\nVAR_GLOBAL PERSISTENT RETAIN\n g_iCounter : INT;\n \/\/ Generated instance path of persistent variable\n PLC_PRG.fb_A.iPersistentCounter_A: INT;\nEND_VAR Deklaration im Funktionsbaustein FB_A FUNCTION_BLOCK FB_A\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR PERSISTENT\n iPersistentCounter_A : INT;\nEND_VAR Deklaration im Programm PLC_PRG VAR\n fb_A1 : FB_A;\nEND_VAR Mögliche Deklarationsstellen Beschreibung Direkt in der persistenten globalen Variablenliste Die Variable ist persistent und liegt im geschützten Speicherbereich. Lokal in einem Programm mit Instanzpfad in der persistenten Variablenliste Lokal in einem Funktionsbaustein mit Instanzpfad in der persistenten Variablenliste Die Variable ist persistent und liegt im geschützten Speicherbereich und im Speicher (Doppelbelegung). Nur lokal in einem Programm Nur lokal in einem Funktionsbaustein Die Variable ist nicht persistent. Im Meldungsfenster wird eine Warnung ausgegeben. Wählen Sie den Befehl Deklarationen → Alle Instanzpfade hinzufügen , um die Variablen in die persistente Variablenliste aufzunehmen. Lokal in einer Funktion Eine solche Deklaration hat keine Auswirkung. Die Variable ist nicht persistent. Wählen Sie im Persistenzeditor den Befehl Deklarationen → Alle Instanzpfade hinzufügen , wenn lokale Variablen mit PERSISTENT gekennzeichnet sind. Vermeiden Sie möglichst, Variablen, die lokal in einem Funktionsbaustein deklariert sind, mit PERSISTENT zu kennzeichnen. Denn dabei wird die Funktionsbaustein-Instanz vollständig im remanenten Speicher abgelegt und nicht nur die gekennzeichnete Variable. " }, 
{ "title" : "Variable: RETAIN ", 
"url" : "_cds_var_retain.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: RETAIN ", 
"snippet" : "RETAIN Retain-Variablen werden deklariert, indem in Programmierobjekten im Gültigkeitsbereich VAR , VAR_INPUT , VAR_OUTPUT , VAR_IN_OUT , VAR_STAT oder VAR_GLOBAL das Schlüsselwort RETAIN hinzugefügt wird. Syntax bei der Deklaration <scope> RETAIN <identifier>: <data type> ( := <initialization> )? \/...", 
"body" : "RETAIN Retain-Variablen werden deklariert, indem in Programmierobjekten im Gültigkeitsbereich VAR , VAR_INPUT , VAR_OUTPUT , VAR_IN_OUT , VAR_STAT oder VAR_GLOBAL das Schlüsselwort RETAIN hinzugefügt wird. Syntax bei der Deklaration <scope> RETAIN\n <identifier>: <data type> ( := <initialization> )? \/\/ ( ... )? : Optional\nEND_VAR\n<scope> : VAR | VAR_INPUT | VAR_OUTPUT | VAR_IN_OUT | VAR_STAT | VAR_GLOBAL Eine Zuweisung von Ein-, Ausgabe- oder Speicheradressen mit dem Schlüsselwort AT ist nicht erlaubt. Beispiel In einer POU VAR RETAIN\n iVarRetain: INT;\nEND_VAR In einer GVL VAR_GLOBAL RETAIN\n g_iVarRetain: INT;\nEND_VAR " }, 
{ "title" : "Mögliche Deklarationsstellen ", 
"url" : "_cds_var_retain.html#UUID-157672b4-f73c-a812-8a3b-bbf486c1ca31_id_d0d24fb1c0a864631c4fb86c_id_574bae341796868bc0a86463467e40bc", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Variable: RETAIN \/ Mögliche Deklarationsstellen ", 
"snippet" : "Lokal in einem Programm Nur die Variable liegt im Retain-Speicherbereich. Bei der Verwendung von Redundanz liegt das gesamte Programm mit all seinen Daten im Retain-Speicherbereich. Global in einer globalen Variablenliste Nur die Variable liegt im Retain-Speicherbereich. Bei der Verwendung von Redun...", 
"body" : "Lokal in einem Programm Nur die Variable liegt im Retain-Speicherbereich. Bei der Verwendung von Redundanz liegt das gesamte Programm mit all seinen Daten im Retain-Speicherbereich. Global in einer globalen Variablenliste Nur die Variable liegt im Retain-Speicherbereich. Bei der Verwendung von Redundanz liegt die gesamte globale Variablenliste mit all ihren Daten im Retain-Speicherbereich. Lokal in einem Funktionsbaustein Die komplette Instanz des Funktionsbausteins mit all seinen Daten liegt im Retain-Speicherbereich. Nur die deklarierte Retain-Variable wird geschützt. Lokal in einer Funktion Die Variable liegt nicht im Retain-Speicherbereich. Diese Deklaration hat keine Auswirkung. Lokal und persistent in einer Funktion Die Variable liegt nicht im Retain-Speicherbereich. Diese Deklaration hat keine Auswirkung. Vermeiden Sie möglichst, Variablen eines Funktionsbausteins mit RETAIN zu kennzeichnen. " }, 
{ "title" : "Pointer: SUPER ", 
"url" : "_cds_pointer_super.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Pointer: SUPER ", 
"snippet" : "SUPER Der Pointer SUPER ist eine spezielle Variable für die objektorientierten Programmierung. SUPER ist der Pointer eines Funktionsbausteins auf die Basisfunktionsbaustein-Instanz, aus die der Funktionsbaustein erzeugt wurde. Der SUPER -Pointer erlaubt somit auch den Zugriff auf die Implementierung...", 
"body" : "SUPER Der Pointer SUPER ist eine spezielle Variable für die objektorientierten Programmierung. SUPER ist der Pointer eines Funktionsbausteins auf die Basisfunktionsbaustein-Instanz, aus die der Funktionsbaustein erzeugt wurde. Der SUPER -Pointer erlaubt somit auch den Zugriff auf die Implementierung der Methoden des Basis-Funktionsbausteins (Basisklasse). Für jeden Funktionsbaustein steht automatisch ein SUPER -Pointer zur Verfügung. Sie können SUPER nur in Methoden- und in den zugehörigen Funktionsbaustein-Implementierungen verwenden. Dereferenzierung des Pointers: SUPER^ Verwendung des SUPER -Pointers: Mit Hilfe des Schlüsselworts SUPER rufen Sie eine Methode auf, die in der Instanz der Basisklasse oder Elternklasse gültig ist. Beispiel ST SUPER^.METH_DoIt(); FUP\/CFC\/LD Beispiel Verwendung von SUPER - und THIS -Pointer FUNCTION_BLOCK FB_Base\nVAR_OUTPUT\n iCnt : INT;\nEND_VAR\n\nMETHOD METH_DoIt : BOOL\niCnt := -1;\n\nMETHOD METH_DoAlso : BOOL\nMETH_DoAlso := TRUE;\n\nFUNCTION_BLOCK FB_1 EXTENDS FB_Base\nVAR_OUTPUT\n iBase : INT;\nEND_VAR\n\nTHIS^.METH_DoIt(); \/\/Call of the methods of FB_1\nTHIS^.METH_DoAlso();\n\nSUPER^.METH_DoIt(); \/\/Call of the methods of FB_Base\nSUPER^.METH_DoAlso();\niBase := SUPER^.iCnt;\n\nMETHOD METH_DoIt : BOOL\niCnt := 1111;\nMETH_DoIt := TRUE;\n\nPROGRAM PLC_PRG\nVAR\n myBase : FB_Base;\n myFB_1 : FB_1;\n iTHIS : INT;\n iBase : INT;\nEND_VAR\nmyBase();\niBase := myBase.iCnt;\nmyFB_1();\niTHIS := myFB_1.iCnt; THIS ist für die Anweisungsliste (AWL) noch nicht implementiert. " }, 
{ "title" : "Pointer: THIS ", 
"url" : "_cds_pointer_this.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Pointer: THIS ", 
"snippet" : "THIS Der Pointer THIS ist eine spezielle Variable für die objektorientierten Programmierung. THIS ist der Pointer eines Funktionsbausteins auf seine eigene Funktionsbaustein-Instanz. Für jeden Funktionsbaustein steht automatisch ein THIS -Pointer zur Verfügung. Sie können THIS nur in Methoden und in...", 
"body" : "THIS Der Pointer THIS ist eine spezielle Variable für die objektorientierten Programmierung. THIS ist der Pointer eines Funktionsbausteins auf seine eigene Funktionsbaustein-Instanz. Für jeden Funktionsbaustein steht automatisch ein THIS -Pointer zur Verfügung. Sie können THIS nur in Methoden und in Funktionsbausteinen verwenden. THIS steht für die Implementierung in der Eingabehilfe in der Kategorie Schlüsselwörter zur Verfügung. Dereferenzierung des Pointers: THIS^ Verwendung des THIS -Pointers Wenn in einer Methode eine lokale Variable eine Funktionsbaustein-Variable verschattet, können Sie die Funktionsbaustein-Variable mit dem THIS -Pointer setzen. Siehe unten Beispiel (1) Wenn der Pointer auf die eigene Funktionsbaustein-Instanz zur Verwendung in einer Funktion referenziert wird. (Siehe unten Beispiel (2)) Beispiele ST THIS^.METH_DoIt(); FUP\/CFC\/LD Beispiel Die lokale Variable iVarB verschattet die Funktionsbaustein-Variable iVarB . FUNCTION_BLOCK fbA\nVAR_INPUT\n iVarA: INT;\nEND_VAR\niVarA := 1;\n\nFUNCTION_BLOCK fbB EXTENDS fbA\nVAR_INPUT\n iVarB: INT := 0;\nEND_VAR\niVarA := 11;\niVarB := 2;\n\n METHOD DoIt : BOOL\n VAR_INPUT\n END_VAR\n VAR\n iVarB: INT;\n END_VAR\n iVarB := 22; \/\/ The local variable iVarB is set.\n THIS^.iVarB := 222; \/\/ The function block variable iVarB is set even though iVarB is obscured.\n\nPROGRAM PLC_PRG\nVAR\n MyfbB: fbB;\nEND_VAR\n\nMyfbB(iVarA:=0, iVarB:= 0);\nMyfbB.DoIt(); Beispiel Ein Funktionsaufruf benötigt die Referenz auf die eigene Instanz. FUNCTION funA\nVAR_INPUT\n pFB: fbA;\nEND_VAR\n...;\n\nFUNCTION_BLOCK fbA\nVAR_INPUT\n iVarA: INT;\nEND_VAR\n...;\n\nFUNCTION_BLOCK fbB EXTENDS fbA\nVAR_INPUT\n iVarB: INT := 0;\nEND_VAR\niVarA := 11;\niVarB := 2;\n\n METHOD DoIt : BOOL\n VAR_INPUT\n END_VAR\n VAR\n iVarB: INT;\n END_VAR\n iVarB := 22; \/\/The local variable iVarB is set.\n funA(pFB := THIS^); \/\/funA is called via THIS^.\n\nPROGRAM PLC_PRG\nVAR\n MyfbB: fbB;\nEND_VAR\nMyfbB(iVarA:=0 , iVarB:= 0);\nMyfbB.DoIt(); THIS ist für die Anweisungsliste (AWL) noch nicht implementiert. " }, 
{ "title" : "Datentyp: Implizite Enumeration ", 
"url" : "_cds_datatype_implicit_enumeration.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Datentyp: Implizite Enumeration ", 
"snippet" : "Implizite Enumeration Die implizite Enumeration ermöglicht auf einfache Weise die Deklaration einer neuen Enumerationsvariablen, die nur innerhalb der lokalen POU gültig ist. Eine Variable diesen Typs kann eine begrenzte Anzahl von ganzzahligen Werten annehmen, die in der Komponentenliste deklariert...", 
"body" : "Implizite Enumeration Die implizite Enumeration ermöglicht auf einfache Weise die Deklaration einer neuen Enumerationsvariablen, die nur innerhalb der lokalen POU gültig ist. Eine Variable diesen Typs kann eine begrenzte Anzahl von ganzzahligen Werten annehmen, die in der Komponentenliste deklariert werden. Die implizite Enumeration hat keinen Datentyp-Namen oder Bezeichner. Deklaration : <variable name> : ( <list of component names> ) := <initialization>; <list of component names> Komma separierte Liste von Komponentennamen mit der gewünschten Anzahl von Komponenten Jede Komponente steht für einen ganzzahligen Wert, beginnend bei 0. Der Wert der nachfolgende Komponente erhöht sich jeweils um 1. Beispiel: Alfa, Bravo, Charlie, Delta, Echo Den Komponenten kann auch ein fester Wert zugewiesen werden. Beispiel: Zero, Alfa:=10, Bravo:=20, Charlie:=30, Delta:=40, Echo <initialization> Optional Initialisierungswert, üblicherweise eine Komponente Aufruf : Beispiel PROGRAM PLC_PRG\nVAR\n iAlphabet : (Alfa, Bravo, Charlie, Delta, Echo) := Echo;\n strText : STRING;\n iNumber : INT;\nEND_VAR CASE iAlphabet OF\n\tAlfa:\n\tstrText := 'A';\n\t\n\tBravo: \n\tstrText := 'B';\n\t\n\tCharlie:\n\tstrText := 'C';\n\t\n\tDelta:\n\tstrText := 'D';\n\t\n\tEcho:\n\tstrText := 'E';\nEND_CASE\niNumber := iAlphabet; " }, 
{ "title" : "Interner Datentyp ", 
"url" : "_cds_datatype_implicit_enumeration.html#UUID-839e1fb0-3d1c-7e8f-1286-1f54053bb20b_section-idm4597855524900833552049065596", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Variablen \/ Datentyp: Implizite Enumeration \/ Interner Datentyp ", 
"snippet" : "Bei einer impliziten Enumeration wird intern ein Datentyp erzeugt, dessen Namen folgendem Schema folgt: IMPLICIT_ENUM_ <POU name> _ <variable name> Sie sollten diesen internen Bezeichner jedoch nicht verwenden, da es immer möglich ist, dass der interne Bezeichner anders lautet....", 
"body" : "Bei einer impliziten Enumeration wird intern ein Datentyp erzeugt, dessen Namen folgendem Schema folgt: IMPLICIT_ENUM_ <POU name> _ <variable name> Sie sollten diesen internen Bezeichner jedoch nicht verwenden, da es immer möglich ist, dass der interne Bezeichner anders lautet. " }, 
{ "title" : "Operatoren ", 
"url" : "_cds_struct_reference_operators.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren ", 
"snippet" : "CODESYS V3 unterstützt alle Operatoren der Norm IEC-61131-3. Diese Operatoren sind implizit überall im Projekt bekannt. Neben den IEC-Operatoren unterstützt CODESYS auch einige Operatoren, die nicht in der Norm IEC 61131-3 beschrieben sind. Operatoren werden in einem Baustein wie Funktionen benutzt....", 
"body" : "CODESYS V3 unterstützt alle Operatoren der Norm IEC-61131-3. Diese Operatoren sind implizit überall im Projekt bekannt. Neben den IEC-Operatoren unterstützt CODESYS auch einige Operatoren, die nicht in der Norm IEC 61131-3 beschrieben sind. Operatoren werden in einem Baustein wie Funktionen benutzt. Informationen zur Abarbeitungsreihenfolge (Bindungsstärke) der ST-Operatoren finden Sie im Kapitel „ST-Ausdrücke“. Bei Operationen mit Gleitkommatypen ist das Rechenergebnis abhängig von der verwendeten Zielsystemhardware. Bei Operationen mit Überlauf oder Unterlauf im Datentyp ist das Rechenergebnis abhängig von der verwendeten Zielsystemhardware. " }, 
{ "title" : "Überlauf\/Unterlauf im Datentyp ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4547044759401632680609081132", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Überlauf\/Unterlauf im Datentyp ", 
"snippet" : "Der CODESYS -Compiler generiert Code für das jeweilige Zielgerät und berechnet dabei Zwischenergebnisse immer mit der nativen Größe, die durch das Zielsystem vorgegeben ist. Beispielsweise wird auf den Systemen x86 und ARM mindestens mit 32 Bit Zwischenwerten gerechnet und auf x64-Systemen immer mit...", 
"body" : "Der CODESYS -Compiler generiert Code für das jeweilige Zielgerät und berechnet dabei Zwischenergebnisse immer mit der nativen Größe, die durch das Zielsystem vorgegeben ist. Beispielsweise wird auf den Systemen x86 und ARM mindestens mit 32 Bit Zwischenwerten gerechnet und auf x64-Systemen immer mit 64 Bit Zwischenwerten. Dies bietet deutliche Vorteile bei der Rechengeschwindigkeit und produziert häufig auch das erwartete Ergebnis. Dies bedeutet aber auch, dass ein Überlauf oder ein Unterlauf im Datentyp unter Umständen nicht abgeschnitten wird. Beispiele Beispiel 1 Das Ergebnis dieser Addition wird nicht abgeschnitten und das Ergebnis in dwVar ist 65536 . VAR\nwVar : WORD;\ndwVar: DWORD;\nEND_VAR\n\nwVar := 65535;\ndwVar := wVar + 1; Beispiel 2 Der Überlauf und Unterlauf im Datentyp wird nicht abgeschnitten und die Ergebnisse ( bVar1, bVar2 ) beider Vergleiche sind auf einer 32 Bit und auf einer 64 Bit Hardware FALSE . VAR\nwVar1 : WORD;\nwVar2 : WORD;\nbVar1 : BOOL;\nbVar2 : BOOL;\nEND_VAR\n\nwVar1 := 65535;\nwVar2 := 0;\nbVar1 := (wVar1 + 1) = wVar2;\nbVar2 := (wVar2 - 1) = wVar1; Beispiel 3 Durch die Zuweisung auf wVar3 wird der Wert auf den Zieldatentyp WORD abgeschnitten und das Ergebnis bvar1 ist TRUE . VAR\nwVar1 : WORD;\nwVar2 : WORD;\nwVar3 : WORD;\nbVar1 : BOOL;\nEND_VAR\n\nwVar1 := 65535;\nwVar2 := 0;\nwVar3 := (wVar1 + 1);\nbVar1 := wVar3 = wVar2; Beispiel 4 Um den Compiler zu einem Abschneiden des Zwischenergebnisses zu zwingen, kann eine Konvertierung eingefügt werden. Durch die Typkonvertierung wird sichergestellt, dass beide Vergleiche nur 16 Bit vergleichen und die Ergebnisse ( bVar1, bVar2 ) beider Vergleiche jeweils TRUE sind. VAR\nwVar1 : WORD;\nwVar2 : WORD;\nbVar1 : BOOL;\nbVar2 : BOOL;\nEND_VAR\n\nwVar1 := 65535;\nwVar2 := 0;\nbVar1 := TO_WORD(wVar1 + 1) = wVar2;\nbVar2 := TO_WORD(wVar2 - 1) = wVar1; " }, 
{ "title" : "Arithmetische Operatoren ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4547044771580832680618577688", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Arithmetische Operatoren ", 
"snippet" : "ADDSUBMULDIVMODMOVEINDEXOFSIZEOFXSIZEOF...", 
"body" : "ADDSUBMULDIVMODMOVEINDEXOFSIZEOFXSIZEOF" }, 
{ "title" : "Bitstring-Operatoren ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4613160039052832680627943345", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Bitstring-Operatoren ", 
"snippet" : "ANDORXORNOTAND_THENOR_ELSE...", 
"body" : "ANDORXORNOTAND_THENOR_ELSE" }, 
{ "title" : "Bitshift-Operatoren ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4614490322289632680632942766", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Bitshift-Operatoren ", 
"snippet" : "SHLSHRROLROR...", 
"body" : "SHLSHRROLROR" }, 
{ "title" : "Auswahloperatoren ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4613159872158432680635250845", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Auswahloperatoren ", 
"snippet" : "SELMAXMINLIMITMUX...", 
"body" : "SELMAXMINLIMITMUX" }, 
{ "title" : "Vergleichsoperatoren ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4547044751392032680639121857", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Vergleichsoperatoren ", 
"snippet" : "Die Vergleichsoperatoren sind boolesche Operatoren, die jeweils zwei Eingänge (erster und zweiter Operand) miteinander vergleichen. GTLTLEGEEQNE...", 
"body" : "Die Vergleichsoperatoren sind boolesche Operatoren, die jeweils zwei Eingänge (erster und zweiter Operand) miteinander vergleichen. GTLTLEGEEQNE" }, 
{ "title" : "Adressoperatoren ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4547044729646432680646324029", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Adressoperatoren ", 
"snippet" : "ADRInhaltsoperatorBITADR...", 
"body" : "ADRInhaltsoperatorBITADR" }, 
{ "title" : "Aufrufoperatoren ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4613160098891232680647867881", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Aufrufoperatoren ", 
"snippet" : "CAL...", 
"body" : "CAL" }, 
{ "title" : "Typkonvertierungsoperatoren ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4613160045062432680609282328", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Typkonvertierungsoperatoren ", 
"snippet" : "Sie können explizit Typkonvertierungsoperatoren aufrufen. Für getypte Konvertierungen von einem elementaren Typ in einen anderen elementaren Typ und auch für Überladungen stehen die unten beschriebenen Typkonvertierungsoperatoren zur Verfügung. Konvertierungen von einem „größeren“ Typ auf einen „kle...", 
"body" : "Sie können explizit Typkonvertierungsoperatoren aufrufen. Für getypte Konvertierungen von einem elementaren Typ in einen anderen elementaren Typ und auch für Überladungen stehen die unten beschriebenen Typkonvertierungsoperatoren zur Verfügung. Konvertierungen von einem „größeren“ Typ auf einen „kleineren“ Typ, wie beispielsweise von INT nach BYTE oder von DINT nach WORD , sind aber auch implizit möglich. Getypte Konvertierung: <elementary data type> _TO_ <another elementary data type> Überladene Konvertierung: TO_ <elementary data type> Elementare Datentypen <elementary data type> =\n__UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT | TIME | TOD | UDINT | UINT | ULINT | USINT | WORD Die Schlüsselwörter T , TIME_OF_DAY und DATE_AND_TIME sind alternative Schreibweisen für die Datentypen TIME , TOD und DT . T , TIME_OF_DAY und DATE_AND_TIME werden nicht als Typkonvertierungsbefehl abgebildet. Wenn bei einem Typkonvertierungsoperator der Operandenwert außerhalb des Wertebereichs des Zieldatentyps liegt, ist die Ergebnisausgabe vom Prozessortyp abhängig und damit undefiniert. Dies ist beispielsweise der Fall, wenn ein negativer Operandenwert von LREAL in den Zieldatentyp UINT konvertiert wird. Bei der Typkonvertierung von größeren auf kleinere Typen können Informationen verloren gehen. Stringmanipulation bei Konvertierung nach STRING oder WSTRING Bei einer Typkonvertierung nach STRING oder WSTRING wird der getypte Wert als Zeichenfolge linksbündig abgelegt und bei Überlänge abgeschnitten. Deklarieren Sie deshalb die Rückgabevariablen für die Typkonvertierungsoperatoren <>_TO_STRING und <>_TO_WSTRING ausreichend lang, so dass die Zeichenfolge ohne Manipulation Platz findet. REAL, LREALTIME, LTIMEDATE, DT, TOD, LDATE, LDT, LTODSTRING, WSTRINGTRUNCTRUNC_INT" }, 
{ "title" : "Numerische Operatoren ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_UUID-078cb7af-b708-bb5b-645f-7aa04bb4e566", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Numerische Operatoren ", 
"snippet" : "ABSSQRTLNLOGEXPEXPTSINASINCOSACOSTANATAN...", 
"body" : "ABSSQRTLNLOGEXPEXPTSINASINCOSACOSTANATAN" }, 
{ "title" : "Namensraum-Operatoren ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_UUID-eaf6bdfd-66b9-ab9a-08fc-829c9410631e", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Namensraum-Operatoren ", 
"snippet" : "Die Namensraum-Operatoren sind eine Erweiterung der IEC 61131-3 Operatoren. Sie bieten Ihnen Möglichkeiten, den Zugriff auf Variablen oder Module eindeutig zu gestalten, auch wenn Sie den gleichen Variablen- oder Modulnamen im Projekt mehrmals verwenden. Globaler NamensraumNamensraum für Globale Var...", 
"body" : "Die Namensraum-Operatoren sind eine Erweiterung der IEC 61131-3 Operatoren. Sie bieten Ihnen Möglichkeiten, den Zugriff auf Variablen oder Module eindeutig zu gestalten, auch wenn Sie den gleichen Variablen- oder Modulnamen im Projekt mehrmals verwenden. Globaler NamensraumNamensraum für Globale VariablenlistenEnumerations-NamensraumBibliotheksnamensraum__POOL" }, 
{ "title" : "Multicore-Operatoren ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_UUID-2fa16f56-92bc-e076-7c16-e327a025cba1", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Multicore-Operatoren ", 
"snippet" : "Das Arbeiten mit verschiedenen Tasks erfordert die Synchronisation dieser Tasks. Dies gilt in verstärktem Maße, wenn auf Mehrkernplattformen gearbeitet wird. Zur Unterstützung dieser Synchronisation bietet CODESYS einige spezielle Operatoren an. Diese Operatoren sind Erweiterungen zur IEC-61131-3. D...", 
"body" : "Das Arbeiten mit verschiedenen Tasks erfordert die Synchronisation dieser Tasks. Dies gilt in verstärktem Maße, wenn auf Mehrkernplattformen gearbeitet wird. Zur Unterstützung dieser Synchronisation bietet CODESYS einige spezielle Operatoren an. Diese Operatoren sind Erweiterungen zur IEC-61131-3. Die Operatoren TEST_AND_SET und __COMPARE_AND_SWAP werden für ähnliche Aufgaben verwendet. TEST_AND_SET__COMPARE_AND_SWAP__XADD" }, 
{ "title" : "Weitere Operatoren ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_UUID-953f3232-5824-b4c4-ff29-e4248bf72edd", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Weitere Operatoren ", 
"snippet" : "__DELETE__ISVALIDREF__NEW__QUERYINTERFACE__QUERYPOINTERINI__TRY, __CATCH, __FINALLY, __ENDTRY__POSITION__POUNAME...", 
"body" : "__DELETE__ISVALIDREF__NEW__QUERYINTERFACE__QUERYPOINTERINI__TRY, __CATCH, __FINALLY, __ENDTRY__POSITION__POUNAME" }, 
{ "title" : "Operator: ADD ", 
"url" : "_cds_operator_add.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: ADD ", 
"snippet" : "ADD Der IEC-Operator addiert Variablen. Erlaubte Datentypen: __UXINT | __XINT | __XWORD | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT | TIME | TIME_OF_DAY | TOD | UDINT | UINT | ULINT | USINT | WORD Mögliche...", 
"body" : "ADD searchresult_toplevel Der IEC-Operator addiert Variablen. Erlaubte Datentypen: __UXINT | __XINT | __XWORD | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT | TIME | TIME_OF_DAY | TOD | UDINT | UINT | ULINT | USINT | WORD Mögliche Kombinationen für Zeitdatentypen TIME + TIME = TIME TIME + LTIME = LTIME LTIME + LTIME = LTIME Mögliche Kombinationen für Datums- und Uhrzeitdatetypen TOD + TIME = TOD DT + TIME = DT TOD + LTIME = LTOD DT + LTIME = LDT LTOD + TIME = LTOD LDT + LTIME = LDT LTOD +LTIME = LTOD LDT + LTIME = LDT Besonderheit im FUP\/KOP-Editor: Sie können den ADD -Operator um Bausteineingänge erweitern. Die Anzahl der zusätzlichen Bausteineingänge ist begrenzt. Beispiele ST var1 := 7+2+4+7; FUP " }, 
{ "title" : "Operator: MUL ", 
"url" : "_cds_operator_mul.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: MUL ", 
"snippet" : "MUL Der IEC-Operator dient der Multiplikation von Variablen. Erlaubte Datentypen: BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT , REAL , LREAL , TIME Besonderheit im FUP\/KOP-Editor: Sie können den MUL -Operator um zusätzliche Bausteineingänge erweitern. Die An...", 
"body" : "MUL Der IEC-Operator dient der Multiplikation von Variablen. Erlaubte Datentypen: BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT , REAL , LREAL , TIME Besonderheit im FUP\/KOP-Editor: Sie können den MUL -Operator um zusätzliche Bausteineingänge erweitern. Die Anzahl der zusätzlichen Bausteineingänge ist begrenzt. Beispiele ST var1 := 7*2*4*7; FUP " }, 
{ "title" : "Operator: SUB ", 
"url" : "_cds_operator_sub.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: SUB ", 
"snippet" : "SUB Der IEC-Operator subtrahiert Variablen. Erlaubte Datentypen: BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT , REAL , LREAL , TIME , LTIME , TIME_OF_DAY (TOD) , LTIME_OF_DAY (LTOD) , DATE , LDATE , DATE_AND_TIME (DT) LDATE_AND_TIME (DT) Mögliche Kombinatione...", 
"body" : "SUB Der IEC-Operator subtrahiert Variablen. Erlaubte Datentypen: BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT , REAL , LREAL , TIME , LTIME , TIME_OF_DAY (TOD) , LTIME_OF_DAY (LTOD) , DATE , LDATE , DATE_AND_TIME (DT) LDATE_AND_TIME (DT) Mögliche Kombinationen für Zeitdatentypen TIME - TIME = TIME LTIME - LTIME = LTIME Mögliche Kombinationen für Datums- und Uhrzeitdatentypen DATE - DATE = TIME LDATE - LDATE = LTIME TOD - TIME = TOD LTOD - LTIME = LTOD TOD - TOD = TIME LTOD - LTOD = LTIME DT - TIME = DT LDT - LTIME = LDT DT - DT = TIME LDT - LDT = LTIME Negative TIME\/LTIME -Werte sind undefiniert. Beispiele ST var1 := 7-2; FUP " }, 
{ "title" : "Operator: DIV ", 
"url" : "_cds_operator_div.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: DIV ", 
"snippet" : "DIV Der IEC-Operator dient der Division von Variablen. Erlaubte Datentypen: BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT , REAL , LREAL , TIME Das Verhalten bei einer Division durch Null kann zielsystemabhängig unterschiedlich sein! Beispiele ST var1 := 8\/2; ...", 
"body" : "DIV Der IEC-Operator dient der Division von Variablen. Erlaubte Datentypen: BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT , REAL , LREAL , TIME Das Verhalten bei einer Division durch Null kann zielsystemabhängig unterschiedlich sein! Beispiele ST var1 := 8\/2; FUP 1. Reihe von DIV-Bausteinen, 2. Einzelner DIV-Baustein, 3. DIV-Baustein mit EN\/ENO-Parametern Beachten Sie die Möglichkeit, eine Division durch 0 während der Laufzeit durch die impliziten Überwachungsfunktionen CheckDivInt , CheckDivLint , CheckDivReal und CheckDivLReal zu überwachen. " }, 
{ "title" : "Operator: MOD ", 
"url" : "_cds_operator_mod.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: MOD ", 
"snippet" : "MOD Der IEC-Operator dient der Modulo-Division. Das Ergebnis der Funktion ist der ganzzahlige Rest der Division. Erlaubte Datentypen: BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT Das Verhalten bei einer Division durch Null kann zielsystemabhängig unterschiedl...", 
"body" : "MOD Der IEC-Operator dient der Modulo-Division. Das Ergebnis der Funktion ist der ganzzahlige Rest der Division. Erlaubte Datentypen: BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT Das Verhalten bei einer Division durch Null kann zielsystemabhängig unterschiedlich sein! Beispiele Ergebnis in Var1 ist 1 ST var1 := 9 MOD 2; FUP " }, 
{ "title" : "Operator: MOVE ", 
"url" : "_cds_operator_move.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: MOVE ", 
"snippet" : "MOVE Der IEC-Operator dient der Zuweisung einer Variablen auf eine andere Variable eines entsprechenden Typs. Da MOVE in den CFC-, FUP- und KOP-Editoren als Baustein verfügbar ist, können Sie dort die EN\/EN0-Funktionalität auch auf eine Variablenzuweisung anwenden. CFC: in Verbindung mit der EN\/EN0 ...", 
"body" : "MOVE Der IEC-Operator dient der Zuweisung einer Variablen auf eine andere Variable eines entsprechenden Typs. Da MOVE in den CFC-, FUP- und KOP-Editoren als Baustein verfügbar ist, können Sie dort die EN\/EN0-Funktionalität auch auf eine Variablenzuweisung anwenden. CFC: in Verbindung mit der EN\/EN0 Funktion Nur wenn en_i TRUE ist, weist CODESYS den Wert der Variablen var1 Variable var2 zu. ST ivar2 := MOVE(ivar1); Dies entspricht: ivar2 := ivar1; " }, 
{ "title" : "Operator: INDEXOF ", 
"url" : "_cds_operator_indexof.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: INDEXOF ", 
"snippet" : "INDEXOF Der Operator ist eine Erweiterung der Norm IEC 61131-3. Anstelle des Operators INDEXOF steht in CODESYS V3 der ADR -Operator zur Verfügung, um einen Pointer auf den Index eines Bausteins zu erhalten....", 
"body" : "INDEXOF Der Operator ist eine Erweiterung der Norm IEC 61131-3. Anstelle des Operators INDEXOF steht in CODESYS V3 der ADR -Operator zur Verfügung, um einen Pointer auf den Index eines Bausteins zu erhalten. " }, 
{ "title" : "Operator: SIZEOF ", 
"url" : "_cds_operator_sizeof.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: SIZEOF ", 
"snippet" : "SIZEOF Ab Compilerversion 3.5.16.0 sollte anstelle dieses Operators der Operator XSIZEOF verwendet werden. Der Operator ist eine Erweiterung der Norm IEC 61131-3. Syntax : <return value> := SIZEOF( <variable name> | <date type name> ); Der Operator bestimmt die Anzahl an Bytes, die in der übergebene...", 
"body" : "SIZEOF Ab Compilerversion 3.5.16.0 sollte anstelle dieses Operators der Operator XSIZEOF verwendet werden. Der Operator ist eine Erweiterung der Norm IEC 61131-3. Syntax : <return value> := SIZEOF( <variable name> | <date type name> ); Der Operator bestimmt die Anzahl an Bytes, die in der übergebenen Variable oder dem übergebenen Datentyp benötigt werden. Es wird immer ein vorzeichenloser Wert zurückgegeben. Der Typ des Rückgabewerts wird dabei dem des übergebenen Operanden (Variable oder Datentyp) angepasst. Rückgabewert <return value> Datentyp des Rückgabewerts, der implizit verwendet wird 0 <= <return value> <256 USINT 256 <= <return value> < 65536 UINT 65536 <= <return value> < 4294967296 UDINT 4294967296 <= <return value> ULINT Beispiel in ST PROGRAM PLC_PRG\nVAR\n\taData_1 : ARRAY[0..4] OF INT;\n\tiReturnValue : INT;\nEND_VAR iReturnValue := SIZEOF(aData_1); (* iReturnValue := USINT#10; *) Ergebnis in iReturnValue ist 10 . " }, 
{ "title" : "Operator: XSIZEOF ", 
"url" : "_cds_operator_xsizeof.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: XSIZEOF ", 
"snippet" : "XSIZEOF Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator XSIZEOF bestimmt die Anzahl an Bytes, die in der übergebenen Variable oder dem übergebenen Datentyp benötigt werden. Dabei wird immer ein vorzeichenloser Wert zurückgegeben. Der Datentyp des Rückgabewerts <return value> ist...", 
"body" : "XSIZEOF Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator XSIZEOF bestimmt die Anzahl an Bytes, die in der übergebenen Variable oder dem übergebenen Datentyp benötigt werden. Dabei wird immer ein vorzeichenloser Wert zurückgegeben. Der Datentyp des Rückgabewerts <return value> ist folgendermaßen festgelegt: bei 64-bit-Plattformen ist der Typ ULINT , auf allen anderen Plattformen UDINT . Um Code zu erzeugen, der auf allen Plattformen läuft, kann der Rückgabewert mit dem Datentyp __UXINT deklariert werden. Syntax : <return value> := XSIZEOF( <variable> ); Beispiel in ST PROGRAM PLC_PRG\nVAR\n uxiReturnValue : __UXINT; (* Datentyp bei 64-bit-Plattformen: ULINT *)\n aData_1 : ARRAY[0..4] OF INT; \nEND_VAR uxiReturnValue := XSIZEOF(aData_1); Ergebnis: uxiReturnValue = 10 Bei der Zuweisung an eine Variable vom Typ __UXINT ist es ratsam, den Operator XSIZEOF anstelle des Operators SIZEOF zu verwenden. Denn bei XSIZEOF hängt der Datentyp des Rückgabewerts von der jeweiligen Plattform ab. Infolgedessen treten Probleme, die bei der Verwendung des Operators SIZEOF auftreten, nicht auf. " }, 
{ "title" : "Operator: NOT ", 
"url" : "_cds_operator_not.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: NOT ", 
"snippet" : "NOT Der IEC-Operator dient dem bitweisen NOT eines Bit-Operanden. Wenn das entsprechende Eingangsbit 0 ist, ist das Ausgangsbit 1, und umgekehrt. Erlaubte Datentypen: BOOL , BYTE , WORD , DWORD , LWORD Beispiele Ergebnis in Var1 : 2#0110_1100 ST Var1 := NOT 2#1001_0011; FUP...", 
"body" : "NOT Der IEC-Operator dient dem bitweisen NOT eines Bit-Operanden. Wenn das entsprechende Eingangsbit 0 ist, ist das Ausgangsbit 1, und umgekehrt. Erlaubte Datentypen: BOOL , BYTE , WORD , DWORD , LWORD Beispiele Ergebnis in Var1 : 2#0110_1100 ST Var1 := NOT 2#1001_0011; FUP " }, 
{ "title" : "Operator: AND ", 
"url" : "_cds_operator_and.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: AND ", 
"snippet" : "AND Der IEC-Operator dient dem bitweisen AND von Bit-Operanden. Wenn die Eingangsbits jeweils 1 sind, ist das Ausgangsbit 1, ansonsten 0. Erlaubte Datentypen: BOOL , BYTE , WORD , DWORD , LWORD Beispiele Ergebnis in var1: 2#1000_0010 ST var1 := 2#1001_0011 AND 2#1000_1010; FUP...", 
"body" : "AND searchresult_toplevel Der IEC-Operator dient dem bitweisen AND von Bit-Operanden. Wenn die Eingangsbits jeweils 1 sind, ist das Ausgangsbit 1, ansonsten 0. Erlaubte Datentypen: BOOL , BYTE , WORD , DWORD , LWORD Beispiele Ergebnis in var1: 2#1000_0010 ST var1 := 2#1001_0011 AND 2#1000_1010; FUP " }, 
{ "title" : "Operator: OR ", 
"url" : "_cds_operator_or.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: OR ", 
"snippet" : "OR Der IEC-Operator dient dem bitweisen OR von Bit-Operanden. Wenn mindestens eines der Eingangs-Bits 1 ist, ist das Ausgangs-Bit 1, ansonsten 0. Erlaubte Datentypen: BOOL , BYTE , WORD , DWORD , LWORD Beispiele Ergebnis in Var1 : 2#1001_1011 ST Var1 := 2#1001_0011 OR 2#1000_1010; FUP...", 
"body" : "OR Der IEC-Operator dient dem bitweisen OR von Bit-Operanden. Wenn mindestens eines der Eingangs-Bits 1 ist, ist das Ausgangs-Bit 1, ansonsten 0. Erlaubte Datentypen: BOOL , BYTE , WORD , DWORD , LWORD Beispiele Ergebnis in Var1 : 2#1001_1011 ST Var1 := 2#1001_0011 OR 2#1000_1010; FUP " }, 
{ "title" : "Operator: XOR ", 
"url" : "_cds_operator_xor.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: XOR ", 
"snippet" : "XOR Der IEC-Operator dient der bitweisen XOR -Operation von Bit-Operanden. Wenn nur einer der beiden Eingangs-Bits den Wert 1 liefert, wird das Ausgangs-Bit 1; wenn beide Eingänge 1 oder beide 0 sind, wird der Ausgang 0. Erlaubte Datentypen: BOOL , BYTE , WORD , DWORD , LWORD Beachten Sie folgendes ...", 
"body" : "XOR Der IEC-Operator dient der bitweisen XOR -Operation von Bit-Operanden. Wenn nur einer der beiden Eingangs-Bits den Wert 1 liefert, wird das Ausgangs-Bit 1; wenn beide Eingänge 1 oder beide 0 sind, wird der Ausgang 0. Erlaubte Datentypen: BOOL , BYTE , WORD , DWORD , LWORD Beachten Sie folgendes Verhalten des XOR -Bausteins in erweiterter Form, also bei mehr als 2 Eingängen: vergleicht die Eingänge paarweise und die jeweiligen Ergebnisse dann wiederum gegeneinander (entspricht der Norm, jedoch nicht unbedingt der Erwartung). Beispiele Ergebnis in var1 : 2#0001_1001 ST var1 := 2#1001_0011 XOR 2#1000_1010; FUP " }, 
{ "title" : "Operator: AND_THEN ", 
"url" : "_cds_operator_and_then.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: AND_THEN ", 
"snippet" : "AND_THEN Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator AND_THEN ist nur für die Programmierung im Strukturiertem Text bei folgender Operation erlaubt: AND -Operation von Operanden des Typs BOOL und BIT mit Kurzschluss-Auswertung. Das bedeutet: Wenn alle Operanden TRUE sind, is...", 
"body" : "AND_THEN Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator AND_THEN ist nur für die Programmierung im Strukturiertem Text bei folgender Operation erlaubt: AND -Operation von Operanden des Typs BOOL und BIT mit Kurzschluss-Auswertung. Das bedeutet: Wenn alle Operanden TRUE sind, ist das Ergebnis der Operation ebenfalls TRUE , ansonsten FALSE . Aber: Nur wenn der erste Operand des AND_THEN Operators TRUE ist, führt CODESYS die Ausdrücke an weiteren Operanden ebenfalls aus. Dies kann beispielsweise in Bedingungen wie IF (ptr <> 0 AND_THEN ptr^ = 99) THEN... Probleme mit Null-Pointern vermeiden. Im Unterschied dazu wertet CODESYS bei Verwendung des IEC-Operators AND immer alle Operanden aus. " }, 
{ "title" : "Operator: OR_ELSE ", 
"url" : "_cds_operator_or_else.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: OR_ELSE ", 
"snippet" : "OR_ELSE Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator OR_ELSE ist nur für die Programmierung im Strukturiertem Text erlaubt: OR -Operation von Operanden des Typs BOOL und BIT , mit Kurzschluss-Auswertung. Das bedeutet: Wenn mindestens einer der Operanden TRUE ist, ist das Erge...", 
"body" : "OR_ELSE Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator OR_ELSE ist nur für die Programmierung im Strukturiertem Text erlaubt: OR -Operation von Operanden des Typs BOOL und BIT , mit Kurzschluss-Auswertung. Das bedeutet: Wenn mindestens einer der Operanden TRUE ist, ist das Ergebnis der Operation ebenfalls TRUE , ansonsten FALSE . Im Unterschied zur Verwendung des IEC-Operators OR , werden bei OR_ELSE , sobald einer der Operanden mit TRUE ausgewertet wurde, die Ausdrücke an allen weiteren Operanden nicht mehr ausgeführt. Beispiel VAR\n bEver: BOOL;\n bX: BOOL;\n dw: DWORD := 16#000000FF;\nEND_VAR\n\nbEver := FALSE;\nbX := dw.8 OR_ELSE dw.1 OR_ELSE (bEver := TRUE); dw.8 ist FALSE und dw.1 ist TRUE . Somit ist das Ergebnis bX der Operation TRUE . Der Ausdruck am dritten Eingang wird jedoch nicht ausgeführt, bEver bleibt FALSE . Wenn stattdessen die Standard-OR-Operation verwendet würde, wäre bEver auf TRUE gesetzt worden. " }, 
{ "title" : "Operator: SHL ", 
"url" : "_cds_operator_shl.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: SHL ", 
"snippet" : "SHL Der IEC-Operator dient dem bitweisen Verschieben eines Operanden nach links. erg := SHL (in, n) in : Operand, der nach links verschoben wird n : Anzahl der Bits, um die in nach links verschoben wird Wenn n die Datentyp-Breite überschreitet, hängt es vom Zielsystem ab, wie BYTE , WORD , DWORD und...", 
"body" : "SHL Der IEC-Operator dient dem bitweisen Verschieben eines Operanden nach links. erg := SHL (in, n) in : Operand, der nach links verschoben wird n : Anzahl der Bits, um die in nach links verschoben wird Wenn n die Datentyp-Breite überschreitet, hängt es vom Zielsystem ab, wie BYTE , WORD , DWORD und LWORD Operanden aufgefüllt werden. Die Zielsysteme bewirken Auffüllen mit Nullen oder mit n MOD <Registerbreite> . Beachten Sie, dass Sie die Anzahl der Bits, die CODESYS für die Rechenoperation berücksichtigt, durch den Datentyp der Eingangsvariablen in vorgeben. Beispiele Die Ergebnisse für erg_byte und erg_word sind unterschiedlich, obwohl die Werte der Eingangsvariablen in_byte und in_word gleich, die Datentypen der Eingangsvariablen jedoch unterschiedlich sind. ST PROGRAM shl_st\nVAR\n in_byte : BYTE := 16#45; (* 2#01000101 )\n in_word : WORD := 16#0045; (* 2#0000000001000101 )\n erg_byte : BYTE;\n erg_word : WORD;\n n: BYTE := 2;\nEND_VAR\n\nerg_byte := SHL(in_byte,n); (* Result is 16#14, 2#00010100 *)\nerg_word := SHL(in_word,n); (* Result is 16#0114, 2#0000000100010100 *) FUP " }, 
{ "title" : "Operator: SHR ", 
"url" : "_cds_operator_shr.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: SHR ", 
"snippet" : "SHR Der IEC-Operator dient dem bitweisen Verschieben eines Operanden nach rechts. erg := SHR (in, n) in : Operand, der nach rechts verschoben wird n : Anzahl der Bits, um die in nach rechts verschoben wird Wenn n die Datentyp-Breite überschreitet, hängt es vom Zielsystem ab, wie BYTE -, WORD -, DWOR...", 
"body" : "SHR Der IEC-Operator dient dem bitweisen Verschieben eines Operanden nach rechts. erg := SHR (in, n) in : Operand, der nach rechts verschoben wird n : Anzahl der Bits, um die in nach rechts verschoben wird Wenn n die Datentyp-Breite überschreitet, hängt es vom Zielsystem ab, wie BYTE -, WORD -, DWORD - und LWORD -Operanden aufgefüllt werden. Die Zielsysteme bewirken Auffüllen mit Nullen oder mit n MOD <register width> . Beispiele ST PROGRAM shr_st\nVAR\n in_byte : BYTE := 16#45; (* 2#01000101 )\n in_word : WORD := 16#0045; (* 2#0000000001000101 )\n erg_byte : BYTE;\n erg_word : WORD;\n n: BYTE := 2;\nEND_VAR\n\nerg_byte := SHR(in_byte,n); (* Result is 16#11, 2#00010001 *)\nerg_word := SHR(in_word,n); (* Result is 16#0011, 2#0000000000010001 *) FUP " }, 
{ "title" : "Operator: ROL ", 
"url" : "_cds_operator_rol.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: ROL ", 
"snippet" : "ROL Der IEC-Operator dient der bitweisen Rotation eines Operanden nach links. Erlaubte Datentypen: BYTE , WORD , DWORD , LWORD erg := ROL (in, n) CODESYS verschiebt in n-mal um 1 Bit nach links und fügt gleichzeitig das Bit mit der äußersten linken Position von rechts wieder ein. Die Anzahl der Bits...", 
"body" : "ROL Der IEC-Operator dient der bitweisen Rotation eines Operanden nach links. Erlaubte Datentypen: BYTE , WORD , DWORD , LWORD erg := ROL (in, n) CODESYS verschiebt in n-mal um 1 Bit nach links und fügt gleichzeitig das Bit mit der äußersten linken Position von rechts wieder ein. Die Anzahl der Bits, die CODESYS für die Rechenoperation berücksichtigt, geben Sie durch den Datentyp der Eingangsvariable in vor. Wenn es sich hierbei um eine Konstante handelt, berücksichtigt CODESYS den kleinstmöglichen Datentyp. Der Datentyp der Ausgangsvariablen bleibt ohne Auswirkung auf die Rechenoperation. Beispiele Die Ergebnisse für erg_byte und erg_word sind unterschiedlich, abhängig vom Datentyp der Eingangsvariablen, obwohl die Werte der Eingangsvariablen in_byte und in_word gleich sind. ST PROGRAM rol_st\n\nVAR\n in_byte : BYTE := 16#45;\n in_word : WORD := 6#45;\n erg_byte : BYTE;\n erg_word : WORD;\n n: BYTE := 2;\nEND_VAR\n\nerg_byte := ROL(in_byte,n); (* Result: 16#15 *)\n\nerg_word := ROL(in_word,n); (* Result: 16#0114 *) FUP AWL " }, 
{ "title" : "Operator: ROR ", 
"url" : "_cds_operator_ror.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: ROR ", 
"snippet" : "ROR Der IEC-Operator dient der bitweisen Rotation eines Operanden nach rechts. Erlaubte Datentypen: BYTE , WORD , DWORD , LWORD erg := ROR(in,n) CODESYS verschiebt in n-mal um 1 Bit nach rechts und fügt gleichzeitig das Bit mit der äußersten rechten Position von links wieder ein. Die Anzahl der Bits...", 
"body" : "ROR Der IEC-Operator dient der bitweisen Rotation eines Operanden nach rechts. Erlaubte Datentypen: BYTE , WORD , DWORD , LWORD erg := ROR(in,n) CODESYS verschiebt in n-mal um 1 Bit nach rechts und fügt gleichzeitig das Bit mit der äußersten rechten Position von links wieder ein. Die Anzahl der Bits, die CODESYS für die Rechenoperation berücksichtigt, wird durch den Datentyp der Eingangsvariablen in vorgegeben. Handelt es sich hierbei um eine Konstante, berücksichtigt CODESYS den kleinstmöglichen Datentyp . Der Datentyp der Ausgangsvariable bleibt ohne Auswirkung auf die Rechenoperation. Beispiele Die Ergebnisse für erg_byte und erg_word sind unterschiedlich, abhängig vom Datentyp der Eingangsvariablen, obwohl die Werte der Eingangsvariablen in_byte und in_word gleich sind. ST PROGRAM ror_st\n\nVAR\n in_byte : BYTE := 16#45;\n in_word : WORD := 16#45;\n erg_byte : BYTE;\n erg_word : WORD;\n n: BYTE := 2;\nEND_VAR\n\nerg_byte := ROR(in_byte,n); (* Result: 16#51 *)\nerg_word := ROR(in_word,n); (* Result: 16#4011 *) FUP " }, 
{ "title" : "Operator: SEL ", 
"url" : "_cds_operator_sel.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: SEL ", 
"snippet" : "SEL Der IEC-Operator dient der bitweisen Auswahl. OUT := SEL(G, IN0, IN1) bedeutet: OUT := IN0; wenn G = FALSE OUT := IN1; wenn G = TRUE Erlaubte Datentypen IN0 , …, INn und OUT : Beliebiger, identischer Datentyp Achten Sie speziell bei der Verwendung von benutzerdefinierten Datentypen darauf, dass ...", 
"body" : "SEL Der IEC-Operator dient der bitweisen Auswahl. OUT := SEL(G, IN0, IN1) bedeutet: OUT := IN0; wenn G = FALSE OUT := IN1; wenn G = TRUE Erlaubte Datentypen IN0 , …, INn und OUT : Beliebiger, identischer Datentyp Achten Sie speziell bei der Verwendung von benutzerdefinierten Datentypen darauf, dass an allen drei Positionen Variablen mit identischem Typ verwendet werden. Der Compiler prüft die Typgleichheit und gibt Übersetzungsfehler aus. Insbesondere die Zuweisung von Instanzen eines Funktionsbausteins an Schnittstellen(variablen) wird nicht unterstützt. G : BOOL CODESYS berechnet einen Ausdruck, der IN0 vorgeschaltet ist, nicht, wenn G TRUE ist. CODESYS berechnet einen Ausdruck, der IN1 vorgeschaltet ist, nicht, wenn G FALSE ist. Achtung: Bei grafischen Programmiersprachen werden unabhängig vom Eingang G die Ausdrücke an IN0 und IN1 berechnet, wenn ein Baustein , ein Sprung , ein Return , eine Leitungsverzweigung oder eine Flankenerkennung vorgeschaltet ist. Beispiele ST Var1 := SEL(TRUE,3,4); (* Result: 4 *) FUP " }, 
{ "title" : "Operator: MAX ", 
"url" : "_cds_operator_max.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: MAX ", 
"snippet" : "MAX Der IEC-Operator dient der Maximumsfunktion. Er liefert den größten Wert aller Eingänge. OUT := MAX(IN0,IN1,IN2,...) Erlaubte Datentypen: alle Beispiele Ergebnis: 90 ST Var1 := MAX(30,90,40); Var1 := MAX(40,MAX(90,30)); FUP...", 
"body" : "MAX Der IEC-Operator dient der Maximumsfunktion. Er liefert den größten Wert aller Eingänge. OUT := MAX(IN0,IN1,IN2,...) Erlaubte Datentypen: alle Beispiele Ergebnis: 90 ST Var1 := MAX(30,90,40);\n\nVar1 := MAX(40,MAX(90,30)); FUP " }, 
{ "title" : "Operator: MIN ", 
"url" : "_cds_operator_min.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: MIN ", 
"snippet" : "MIN Der IEC-Operator dient der Minimumsfunktion. Er liefert den kleinsten Wert aller Eingänge. OUT := MIN(IN0,IN1,IN2,...) Erlaubte Datentypen: alle Beispiele Ergebnis: 30 ST Var1 := MIN(90,30,40); Var1 := MIN(MIN(90,30),40); FUP...", 
"body" : "MIN Der IEC-Operator dient der Minimumsfunktion. Er liefert den kleinsten Wert aller Eingänge. OUT := MIN(IN0,IN1,IN2,...) Erlaubte Datentypen: alle Beispiele Ergebnis: 30 ST Var1 := MIN(90,30,40);\n\nVar1 := MIN(MIN(90,30),40); FUP " }, 
{ "title" : "Operator: LIMIT ", 
"url" : "_cds_operator_limit.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: LIMIT ", 
"snippet" : "LIMIT Der IEC-Auswahloperator dient der Limitierung. OUT := LIMIT(Min, IN, Max) Das bedeutet: OUT := MIN (MAX (IN, Min), Max) Max ist die obere, Min ist die untere Schranke für das Ergebnis. Wenn der Wert IN die obere Grenze Max überschreitet, dann liefert LIMIT Max . Wenn IN Min unterschreitet, dan...", 
"body" : "LIMIT Der IEC-Auswahloperator dient der Limitierung. OUT := LIMIT(Min, IN, Max) Das bedeutet: OUT := MIN (MAX (IN, Min), Max) Max ist die obere, Min ist die untere Schranke für das Ergebnis. Wenn der Wert IN die obere Grenze Max überschreitet, dann liefert LIMIT Max . Wenn IN Min unterschreitet, dann ist das Ergebnis Min . Erlaubte Datentypen für IN und OUT : alle Beispiele Ergebnis in Var1 : 80 ST Var1 := LIMIT(30,90,80); " }, 
{ "title" : "Operator: MUX ", 
"url" : "_cds_operator_mux.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: MUX ", 
"snippet" : "MUX Der IEC-Operator dient als Multiplexer. OUT := MUX(K, IN0,...,INn) Das bedeutet: OUT = IN_K Erlaubte Datentypen für K : BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , LINT , ULINT UDINT IN0 , …, INn und OUT : Beliebiger, identischer Datentyp Achten Sie speziell bei der Verwendu...", 
"body" : "MUX Der IEC-Operator dient als Multiplexer. OUT := MUX(K, IN0,...,INn) Das bedeutet: OUT = IN_K Erlaubte Datentypen für K : BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , LINT , ULINT UDINT IN0 , …, INn und OUT : Beliebiger, identischer Datentyp Achten Sie speziell bei der Verwendung von benutzerdefinierten Datentypen darauf, dass an allen drei Positionen Variablen mit identischem Typ verwendet werden. Der Compiler prüft die Typgleichheit und gibt Übersetzungsfehler aus. Insbesondere die Zuweisung von Instanzen eines Funktionsbausteins an Schnittstellen(variablen) wird nicht unterstützt. MUX wählt aus einer Menge von Werten den K-ten aus. Der erste Wert entspricht K=0. Wenn K größer als die Anzahl der weiteren Eingänge (n) ist, so gibt CODESYS den letzten Wert weiter ( INn ). Zum Zweck der Laufzeitoptimierung berechnet CODESYS nur den Ausdruck, den Sie IN_K vorgeschaltet haben. In der Simulation dagegen berechnet CODESYS alle Zweige. Beispiele Ergebnis in Var1 : 30 ST Var1 := MUX(0,30,40,50,60,70,80); " }, 
{ "title" : "Operator: GT ", 
"url" : "_cds_operator_gt.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: GT ", 
"snippet" : "GT Der IEC-Operator dient der Funktion „Größer als“. Erlaubte Datentypen der Operanden: beliebiger Basisdatentyp Wenn der erste Operand größer als der zweite Operand ist, liefert der Operator das Ergebnis TRUE , ansonsten FALSE . Beispiele Ergebnis: FALSE ST VAR1 := 20 > 30; FUP...", 
"body" : "GT Der IEC-Operator dient der Funktion „Größer als“. Erlaubte Datentypen der Operanden: beliebiger Basisdatentyp Wenn der erste Operand größer als der zweite Operand ist, liefert der Operator das Ergebnis TRUE , ansonsten FALSE . Beispiele Ergebnis: FALSE ST VAR1 := 20 > 30; FUP " }, 
{ "title" : "Operator: LT ", 
"url" : "_cds_operator_lt.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: LT ", 
"snippet" : "LT Der IEC-Operator dient der Funktion „Kleiner als“. Erlaubte Datentypen der Operanden: beliebiger Basisdatentyp Wenn der erste Operand kleiner als der zweite ist, liefert der Operator das Ergebnis TRUE , ansonsten FALSE . Beispiele Ergebnis: TRUE ST Var1 := 20 < 30;...", 
"body" : "LT Der IEC-Operator dient der Funktion „Kleiner als“. Erlaubte Datentypen der Operanden: beliebiger Basisdatentyp Wenn der erste Operand kleiner als der zweite ist, liefert der Operator das Ergebnis TRUE , ansonsten FALSE . Beispiele Ergebnis: TRUE ST Var1 := 20 < 30; " }, 
{ "title" : "Operator: LE ", 
"url" : "_cds_operator_le.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: LE ", 
"snippet" : "LE Der IEC-Operator dient der Funktion „Kleiner oder gleich“. Erlaubte Datentypen der Operanden: beliebiger Basisdatentyp Wenn der erste Operand kleiner als der zweite Operand oder gleich groß wie der zweite Operand ist, liefert der Operator das Ergebnis TRUE , ansonsten FALSE . Beispiele Ergebnis i...", 
"body" : "LE Der IEC-Operator dient der Funktion „Kleiner oder gleich“. Erlaubte Datentypen der Operanden: beliebiger Basisdatentyp Wenn der erste Operand kleiner als der zweite Operand oder gleich groß wie der zweite Operand ist, liefert der Operator das Ergebnis TRUE , ansonsten FALSE . Beispiele Ergebnis in Var1 : TRUE ST Var1 := 20 <= 30; " }, 
{ "title" : "Operator: GE ", 
"url" : "_cds_operator_ge.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: GE ", 
"snippet" : "GE Der IEC-Operator dient der Funktion „größer oder gleich“. Erlaubte Datentypen der Operanden: beliebiger Basisdatentyp Wenn der erste Operand größer als der zweite Operand oder gleich groß wie der zweite Operand ist, liefert der Operator das Ergebnis TRUE , ansonsten FALSE . Beispiele Ergebnis: TR...", 
"body" : "GE Der IEC-Operator dient der Funktion „größer oder gleich“. Erlaubte Datentypen der Operanden: beliebiger Basisdatentyp Wenn der erste Operand größer als der zweite Operand oder gleich groß wie der zweite Operand ist, liefert der Operator das Ergebnis TRUE , ansonsten FALSE . Beispiele Ergebnis: TRUE ST VAR1 := 60 >= 40; FUP " }, 
{ "title" : "Operator: EQ ", 
"url" : "_cds_operator_eq.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: EQ ", 
"snippet" : "EQ Der IEC-Operator vergleicht zwei Operanden auf Gleichheit. Als Datentypen für die Operanden sind alle elementaren Datentypen zulässig. Wenn die Operanden gleich sind, liefert der Operator als Ergebnis TRUE zurück, ansonsten FALSE . Beispiel Ergebnis: VAR1 = TRUE ST: \/\/Implementierung VAR1 := 20 =...", 
"body" : "EQ Der IEC-Operator vergleicht zwei Operanden auf Gleichheit. Als Datentypen für die Operanden sind alle elementaren Datentypen zulässig. Wenn die Operanden gleich sind, liefert der Operator als Ergebnis TRUE zurück, ansonsten FALSE . Beispiel Ergebnis: VAR1 = TRUE ST: \/\/Implementierung\nVAR1 := 20 = 20; FUP: Elementarer Datentyp Ein elementarer Datentyp ist ein Datentyp, der im CODESYS Development System vordefiniert zur Verfügung steht. Außer den in IEC 61131-3 beschriebenen Datentypen gibt es die CODESYS -spezifischen Datentypen  BIT ,  __UXINT ,  __XINT und  __XWORD . Elementare Datentypen: \n__UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT | TIME | TOD | TIME_OF_DAY | UDINT | UINT | ULINT | USINT | WORD " }, 
{ "title" : "Operator: NE ", 
"url" : "_cds_operator_ne.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: NE ", 
"snippet" : "NE Der IEC-Operator vergleicht zwei Operanden auf Ungleichheit. Als Datentypen für die Operanden sind alle elementaren Datentypen zulässig. Wenn die Operanden ungleich sind, liefert der Operator als Ergebnis TRUE zurück, ansonsten FALSE . Beispiele Ergebnis: Var1 = FALSE ST: Var1 := 40 <> 40; FUP: E...", 
"body" : "NE Der IEC-Operator vergleicht zwei Operanden auf Ungleichheit. Als Datentypen für die Operanden sind alle elementaren Datentypen zulässig. Wenn die Operanden ungleich sind, liefert der Operator als Ergebnis TRUE zurück, ansonsten FALSE . Beispiele Ergebnis: Var1 = FALSE ST: Var1 := 40 <> 40; FUP: Elementarer Datentyp Ein elementarer Datentyp ist ein Datentyp, der im CODESYS Development System vordefiniert zur Verfügung steht. Außer den in IEC 61131-3 beschriebenen Datentypen gibt es die CODESYS -spezifischen Datentypen  BIT ,  __UXINT ,  __XINT und  __XWORD . Elementare Datentypen: \n__UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT | TIME | TOD | TIME_OF_DAY | UDINT | UINT | ULINT | USINT | WORD " }, 
{ "title" : "Operator: ADR ", 
"url" : "_cds_operator_adr.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: ADR ", 
"snippet" : "ADR Der Operator ist eine Erweiterung der Norm IEC 61131-3. ADR liefert die 32-Bit-Adresse (oder gegebenenfalls die 64-Bit-Adresse) seines Arguments zurück. Diese Adresse können Sie an Herstellerfunktionen übergeben oder innerhalb des Projekts einem Pointer zuweisen. Syntax VAR <address name> : DWOR...", 
"body" : "ADR searchresult_toplevel Der Operator ist eine Erweiterung der Norm IEC 61131-3. ADR liefert die 32-Bit-Adresse (oder gegebenenfalls die 64-Bit-Adresse) seines Arguments zurück. Diese Adresse können Sie an Herstellerfunktionen übergeben oder innerhalb des Projekts einem Pointer zuweisen. Syntax VAR\n <address name> : DWORD | LWORD | POINTER TO < basis data type> | __XWORD ;\nEND_VAR\n\n<address name> := ADR( <variable name> ); FUNCTION_BLOCK FB_Adress\nVAR\n piAddress1: POINTER TO INT;\n iVar1 : INT := 5;\n\n lwAddress2 : LWORD;\n iVar2 : INT := 10;\n\n xwAddress3 : _XWORD;\n iVar3 : INT;\nEND_VAR\npiAddress1 := ADR(iVar1); \/\/ piNumber is assigned to address of iVar1\nlwAddress2 := ADR(iVar2); \/\/ works for 64 bit run time system\nxwAddress3 := ADR(iVar3); \/\/ works for 32 bit and 64 bit systems Im Unterschied zu CoDeSys V2.3 können Sie den ADR -Operator mit Funktions-, Programm-, Funktionsbaustein- und Methodennamen verwenden. ADR ersetzt damit den INDEXOF -Operator. Beachten Sie bei der Verwendung von Funktionspointern Folgendes: Sie können Funktionspointer zwar an externe Bibliotheken weitergeben, es gibt jedoch keine Möglichkeit, einen Funktionspointer innerhalb von CODESYS aufzurufen! Um einen Systemaufruf (Laufzeitsystem) zu ermöglichen, müssen Sie die entsprechende Objekteigenschaft (Registerkarte Übersetzen ) für das Funktionsobjekt setzen. Wenn Sie einen Online-Change anwenden, können sich die Inhalte von Adressen verschieben. Dadurch könnten POINTER TO -Variablen auf einen ungültigen Speicherbereich zeigen. Um Probleme zu vermeiden, sollten Sie sicherstellen, dass der Wert von Pointern in jedem Zyklus aktualisiert wird. Pointer-TO -Variablen von Funktionen und Methoden sollten Sie nicht an den Aufrufer zurückgeben oder globalen Variablen zuweisen. " }, 
{ "title" : "Operator: Inhaltsoperator ", 
"url" : "_cds_operator_content_operator.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: Inhaltsoperator ", 
"snippet" : "Inhaltsoperator Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator ermöglicht das Dereferenzieren eines Pointers. Sie hängen den Operator als ^ an den Pointer-Bezeichner an. Beachten Sie bei der Verwendung von Pointern auf Adressen: Wenn Sie einen Online Change anwenden, können sic...", 
"body" : "Inhaltsoperator Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator ermöglicht das Dereferenzieren eines Pointers. Sie hängen den Operator als ^ an den Pointer-Bezeichner an. Beachten Sie bei der Verwendung von Pointern auf Adressen: Wenn Sie einen Online Change anwenden, können sich Inhalte von Adressen verschieben. Beispiel ST pt : POINTER TO INT;\nvar_int1 : INT;\nvar_int2 : INT;\npt := ADR(var_int1);\nvar_int2 := pt^; " }, 
{ "title" : "Operator: BITADR ", 
"url" : "_cds_operator_bitadr.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: BITADR ", 
"snippet" : "BITADR Der Operator ist eine Erweiterung der Norm IEC 61131-3. BITADR liefert den Bit-Offset innerhalb des Segments in einem DWORD . Der Offset hängt davon ab, ob die Option „Byteadressierung“ in den Zielsystemeinstellungen aktiviert ist oder nicht. Der höchstwertige Nibble (4 Bit) in diesem DWORD b...", 
"body" : "BITADR searchresult_toplevel Der Operator ist eine Erweiterung der Norm IEC 61131-3. BITADR liefert den Bit-Offset innerhalb des Segments in einem DWORD . Der Offset hängt davon ab, ob die Option „Byteadressierung“ in den Zielsystemeinstellungen aktiviert ist oder nicht. Der höchstwertige Nibble (4 Bit) in diesem DWORD beschreibt den Speicherbereich. Merker M : 16#40000000 Eingang I : 16#80000000 Ausgang Q : 16#C0000000 Beachten Sie bei der Verwendung von Pointern auf Adressen: Wenn Sie einen Online-Change anwenden, können sich die Inhalte von Adressen verschieben. Beispiel Implementierungssprache ST VAR\n xVar AT %IX2.3 : BOOL;\n dwBitoffset : DWORD;\nEND_VAR\n\ndwBitoffset := BITADR(xVar); (* If byte addressing = TRUE, result = 16#80000013; if byte addressing = FALSE, result = 16#80000023 *) " }, 
{ "title" : "Operator: CAL ", 
"url" : "_cds_operator_cal.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: CAL ", 
"snippet" : "CAL Der IEC Operator dient dem Aufruf eines Funktionsbausteins. CAL ruft in AWL die Instanz eines Funktionsbausteins auf. CAL <function block> (<input variable1> := <value>, <input variableN> := <value>) Beispiel Aufruf der Instanz Inst eines Funktionsbausteins mit Belegung der Eingangsvariablen Par...", 
"body" : "CAL Der IEC Operator dient dem Aufruf eines Funktionsbausteins. CAL ruft in AWL die Instanz eines Funktionsbausteins auf. CAL <function block> (<input variable1> := <value>, <input variableN> := <value>) Beispiel Aufruf der Instanz Inst eines Funktionsbausteins mit Belegung der Eingangsvariablen Par1 , Par2 auf 0 oder TRUE CAL Inst(Par1 := 0, Par2 := TRUE); " }, 
{ "title" : "Operator: ABS ", 
"url" : "_cds_operator_abs.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: ABS ", 
"snippet" : "ABS Der IEC-Operator liefert den Absolutwert einer Zahl. Erlaubte Datentypen für die Eingangs- und Ausgangsvariablen und Zahlenkonstanten: beliebiger numerischer Basisdatentyp Beispiele Ergebnis in i : 2 ST i := ABS(-2); FUP...", 
"body" : "ABS Der IEC-Operator liefert den Absolutwert einer Zahl. Erlaubte Datentypen für die Eingangs- und Ausgangsvariablen und Zahlenkonstanten: beliebiger numerischer Basisdatentyp Beispiele Ergebnis in i : 2 ST i := ABS(-2); FUP " }, 
{ "title" : "Operator: SQRT ", 
"url" : "_cds_operator_sqrt.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: SQRT ", 
"snippet" : "SQRT Der IEC-Operator liefert die Quadratwurzel einer Zahl. Erlaubte Datentypen für die Eingangsvariablen: beliebiger numerischer Basisdatentyp Erlaubte Datentypen für die Ausgangsvariablen: REAL oder LREAL Beispiele Ergebnis in q : 4 ST q := SQRT(16); FUP...", 
"body" : "SQRT Der IEC-Operator liefert die Quadratwurzel einer Zahl. Erlaubte Datentypen für die Eingangsvariablen: beliebiger numerischer Basisdatentyp Erlaubte Datentypen für die Ausgangsvariablen: REAL oder LREAL Beispiele Ergebnis in q : 4 ST q := SQRT(16); FUP " }, 
{ "title" : "Operator: LN ", 
"url" : "_cds_operator_ln.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: LN ", 
"snippet" : "LN Der IEC-Operator liefert den natürlichen Logarithmus einer Zahl. Erlaubte Datentypen für die Eingangsvariablen: beliebiger numerischer Basisdatentyp Erlaubte Datentypen für Ausgangsvariablen: REAL und LREAL Beispiele Ergebnis in q : 3.80666 ST q := LN(45); FUP...", 
"body" : "LN Der IEC-Operator liefert den natürlichen Logarithmus einer Zahl. Erlaubte Datentypen für die Eingangsvariablen: beliebiger numerischer Basisdatentyp Erlaubte Datentypen für Ausgangsvariablen: REAL und LREAL Beispiele Ergebnis in q : 3.80666 ST q := LN(45); FUP " }, 
{ "title" : "Operator: LOG ", 
"url" : "_cds_operator_log.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: LOG ", 
"snippet" : "LOG Der IEC-Operator liefert den Logarithmus zur Basis 10 einer Zahl. Die Eingangsvariable kann von einem beliebigen numerischen Basisdatentyp sein, die Ausgangsvariable muss vom Typ REAL oder LREAL sein. Beispiele Ergebnis in q : 2.49762 ST q := LOG(314.5); FUP...", 
"body" : "LOG searchresult_toplevel Der IEC-Operator liefert den Logarithmus zur Basis 10 einer Zahl. Die Eingangsvariable kann von einem beliebigen numerischen Basisdatentyp sein, die Ausgangsvariable muss vom Typ REAL oder LREAL sein. Beispiele Ergebnis in q : 2.49762 ST q := LOG(314.5); FUP " }, 
{ "title" : "Operator: EXP ", 
"url" : "_cds_operator_exp.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: EXP ", 
"snippet" : "EXP Der IEC-Operator liefert die Exponentialfunktion. Erlaubte Datentypen für die Eingangsvariablen: beliebiger numerischer Basisdatentyp Erlaubte Datentypen für die Ausgangsvariablen: REAL und LREAL Beispiele Ergebnis in q : 7.389056099 ST q := EXP(2); FUP...", 
"body" : "EXP Der IEC-Operator liefert die Exponentialfunktion. Erlaubte Datentypen für die Eingangsvariablen: beliebiger numerischer Basisdatentyp Erlaubte Datentypen für die Ausgangsvariablen: REAL und LREAL Beispiele Ergebnis in q : 7.389056099 ST q := EXP(2); FUP " }, 
{ "title" : "Operator: EXPT ", 
"url" : "_cds_operator_expt.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: EXPT ", 
"snippet" : "EXPT Der IEC-Operator potenziert eine Zahl mit einer anderen und liefert die Potenz von Basis hoch Exponent zurück: power = base exponent . Dabei sind sowohl Basis als auch Exponent Eingabewerte (Parameter). Die Potenzfunktion ist nicht definiert, wenn die Basis 0 und gleichzeitig der Exponent negat...", 
"body" : "EXPT Der IEC-Operator potenziert eine Zahl mit einer anderen und liefert die Potenz von Basis hoch Exponent zurück: power = base exponent . Dabei sind sowohl Basis als auch Exponent Eingabewerte (Parameter). Die Potenzfunktion ist nicht definiert, wenn die Basis 0 und gleichzeitig der Exponent negativ ist. Das Verhalten in diesem Fall ist allerdings plattformabhängig. Syntax EXPT(<Basis>,<Exponent>) Erlaubte Datentypen für die Eingabewerte: Numerische Basisdatentypen ( SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT , REAL , LREAL , BYTE , WORD , DWORD , LWORD ) Erlaubte Datentypen für den Rückgabewert: Gleitkommazahltypen ( REAL , LREAL ) Beispiel Potenzfunktion mit Literalen Var1 := EXPT(7,2); FUP Rückgabewert: Var1 = 49 Beispiel Potenzfunktion mit Variablen PROGRAM PLC_PRG\nVAR\n lrPow : LREAL;\n iBase : INT := 2;\n iExponent : INT := 7;\nEND_VAR\n\nlrPow := EXPT(iBase, iExponent); Rückgabewert: lrPow = 128 " }, 
{ "title" : "Operator: SIN ", 
"url" : "_cds_operator_sin.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: SIN ", 
"snippet" : "SIN Der IEC-Operator liefert den Sinus-Wert für eine Zahl. Erlaubte Datentypen für die Eingangsvariable, die den Winkel im Bogenmaß angibt: beliebiger numerischer Basisdatentyp Erlaubte Datentypen für die Ausgangsvariable: REAL und LREAL Der erlaubte Bereich für den Eingangswert liegt von −2 63 bis ...", 
"body" : "SIN Der IEC-Operator liefert den Sinus-Wert für eine Zahl. Erlaubte Datentypen für die Eingangsvariable, die den Winkel im Bogenmaß angibt: beliebiger numerischer Basisdatentyp Erlaubte Datentypen für die Ausgangsvariable: REAL und LREAL Der erlaubte Bereich für den Eingangswert liegt von −2 63 bis +2 63 . Auf x86- und x64-Systemen gilt: Wenn der Eingangswert außerhalb des erlaubten Bereichs liegt, liefert die Funktion den Eingangswert zurück. Beispiele Ergebnis in q : 0.479426 . ST q := SIN (0.5); FUP " }, 
{ "title" : "Operator: COS ", 
"url" : "_cds_operator_cos.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: COS ", 
"snippet" : "COS Der IEC-Operator liefert den Cosinuswert für eine Zahl. Erlaubte Datentypen für die Eingangsvariable, die den Winkel im Bogenmaß angibt: beliebiger numerischer Basisdatentyp Erlaubte Datentypen für Ausgangsvariablen: REAL und LREAL Der erlaubte Bereich für den Eingangswert liegt von −2 63 bis +2...", 
"body" : "COS Der IEC-Operator liefert den Cosinuswert für eine Zahl. Erlaubte Datentypen für die Eingangsvariable, die den Winkel im Bogenmaß angibt: beliebiger numerischer Basisdatentyp Erlaubte Datentypen für Ausgangsvariablen: REAL und LREAL Der erlaubte Bereich für den Eingangswert liegt von −2 63 bis +2 63 . Auf x86- und x64-Systemen gilt: Wenn der Eingangswert außerhalb des erlaubten Bereichs liegt, liefert die Funktion den Eingangswert zurück. Beispiele Ergebnis in q : 0.877583 ST q := COS(0.5); FUP " }, 
{ "title" : "Operator: TAN ", 
"url" : "_cds_operator_tan.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: TAN ", 
"snippet" : "TAN Der IEC-Operator liefert den Tangens-Wert für eine Zahl. Erlaubte Datentypen für die Eingangsvariable, die den Winkel im Bogenmaß angibt: beliebiger numerischer Basisdatentyp Erlaubte Datentypen für Ausgangsvariablen: REAL und LREAL Beispiele Ergebnis in q : 0.546302 ST q := TAN(0.5); FUP...", 
"body" : "TAN Der IEC-Operator liefert den Tangens-Wert für eine Zahl. Erlaubte Datentypen für die Eingangsvariable, die den Winkel im Bogenmaß angibt: beliebiger numerischer Basisdatentyp Erlaubte Datentypen für Ausgangsvariablen: REAL und LREAL Beispiele Ergebnis in q : 0.546302 ST q := TAN(0.5); FUP " }, 
{ "title" : "Operator: ASIN ", 
"url" : "_cds_operator_asin.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: ASIN ", 
"snippet" : "ASIN Der IEC-Operator liefert den Arcussinus (Umkehrfunktion des Sinus) für eine Zahl. Erlaubte Datentypen für die Eingangsvariable: Beliebiger numerischer Basisdatentyp Erlaubte Datentypen für Ausgangsvariablen: REAL und LREAL Beispiele Ergebnis in q : 0.523599 ST q := ASIN(0,5); FUP...", 
"body" : "ASIN Der IEC-Operator liefert den Arcussinus (Umkehrfunktion des Sinus) für eine Zahl. Erlaubte Datentypen für die Eingangsvariable: Beliebiger numerischer Basisdatentyp Erlaubte Datentypen für Ausgangsvariablen: REAL und LREAL Beispiele Ergebnis in q : 0.523599 ST q := ASIN(0,5); FUP " }, 
{ "title" : "Operator: ACOS ", 
"url" : "_cds_operator_acos.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: ACOS ", 
"snippet" : "ACOS Der IEC-Operator liefert den Arcuscosinus (Umkehrfunktion von Cosinus) für eine Zahl. Der Wert wird in Bogenmaß errechnet. Erlaubte Datentypen für die Eingangsvariable, die den Winkel im Bogenmaß angibt: beliebiger numerischer Basisdatentyp Erlaubte Datentypen für Ausgangsvariablen: REAL und LR...", 
"body" : "ACOS Der IEC-Operator liefert den Arcuscosinus (Umkehrfunktion von Cosinus) für eine Zahl. Der Wert wird in Bogenmaß errechnet. Erlaubte Datentypen für die Eingangsvariable, die den Winkel im Bogenmaß angibt: beliebiger numerischer Basisdatentyp Erlaubte Datentypen für Ausgangsvariablen: REAL und LREAL Beispiele Ergebnis in q: 1.0472 ST q := ACOS(0.5); FUP " }, 
{ "title" : "Operator: ATAN ", 
"url" : "_cds_operator_atan.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: ATAN ", 
"snippet" : "ATAN Der IEC-Operator liefert den Arcustangens (Umkehrfunktion von Tangens) einer Zahl. Der Wert wird in Bogenmaß errechnet. Erlaubte Datentypen für die Eingangsvariable, die den Winkel im Bogenmaß angibt: beliebiger numerischer Basisdatentyp Erlaubte Datentypen für Ausgangsvariablen: REAL und LREAL...", 
"body" : "ATAN Der IEC-Operator liefert den Arcustangens (Umkehrfunktion von Tangens) einer Zahl. Der Wert wird in Bogenmaß errechnet. Erlaubte Datentypen für die Eingangsvariable, die den Winkel im Bogenmaß angibt: beliebiger numerischer Basisdatentyp Erlaubte Datentypen für Ausgangsvariablen: REAL und LREAL Beispiele Ergebnis in q : 0.463648 ST q := ATAN(0.5); FUP " }, 
{ "title" : "Operator: __DELETE ", 
"url" : "_cds_operator_delete.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: __DELETE ", 
"snippet" : "__DELETE Der Operator ist eine Erweiterung der Norm IEC 61131-3. Aus Kompatibilitätsgründen muss die Compiler-Version >= 3.3.2.0 sein. Der Operator gibt den Speicher von Instanzen wieder frei, die der Operator __NEW dynamisch erzeugt hat. Der Operator __DELETE hat keinen Rückgabewert und der Operand...", 
"body" : "__DELETE Der Operator ist eine Erweiterung der Norm IEC 61131-3. Aus Kompatibilitätsgründen muss die Compiler-Version >= 3.3.2.0 sein. Der Operator gibt den Speicher von Instanzen wieder frei, die der Operator __NEW dynamisch erzeugt hat. Der Operator __DELETE hat keinen Rückgabewert und der Operand wird nach dieser Operation auf 0 gesetzt. Voraussetzung: Im Eigenschaftendialog der Applikation ist in der Registerkarte Optionen Applikationserzeugung die Option Dynamische Speicherallozierung verwenden aktiviert. __DELETE (<Pointer>) Zwei Tasks sollten nicht gleichzeitig __DELETE aufrufen. Entweder Sie verwenden ein Semaphor ( SysSemEnter ) oder eine vergleichbare Technik, um einen konkurrierenden Aufruf von __DELETE zu verhindern, oder Sie verwenden __DELETE nur in einer Task (empfohlenes Vorgehen) . Sie können ein Semaphor ( SysSemEnter ) benutzen, um zu vermeiden, dass zwei Tasks gleichzeitig versuchen Speicher zu allozieren. Das hat zur Folge, dass die umfangreiche Nutzung von __DELETE einen höheren Jitter verursacht. Wenn Pointer auf einen Funktionsbaustein zeigt, ruft CODESYS die zugehörige Methode FB_EXIT auf, bevor der Pointer auf 0 gesetzt wird. Beispiel Funktionsbaustein FUNCTION_BLOCK FBDynamic\n\nVAR_INPUT\n in1, in2 : INT;\nEND_VAR\n\nVAR_OUTPUT\n out : INT;\nEND_VAR\n\nVAR\n test1 : INT := 1234;\n _inc : INT := 0;\n _dut : POINTER TO DUT;\n neu : BOOL;\nEND_VAR\n\nout := in1 + in2;\n Methode ( FB_Exit ) METHOD FB_Exit : BOOL\n\nVAR_INPUT\n bInCopyCode : BOOL;\nEND_VAR\n\n__Delete(_dut);\n Methode ( FB_Init ) METHOD FB_Init : BOOL\n\nVAR_INPUT\n bInitRetains : BOOL;\n bInCopyCode : BOOL;\nEND_VAR\n\n_dut := __NEW(DUT);\n Methode METHOD INC : INT\n\nVAR_INPUT\nEND_VAR\n\n_inc := _inc + 1;\nINC := _inc;\n Programm PLC_PRG(PRG)\n\nVAR\n pFB : POINTER TO FBDynamic;\n bInit: BOOL := TRUE;\n bDelete: BOOL;\n loc : INT;\nEND_VAR\n\nIF (bInit) THEN\n pFB := __NEW(FBDynamic);\n bInit := FALSE;\nEND_IF\n\nIF (pFB <> 0) THEN\n pFB^(in1 := 1, in2 := loc, out => loc);\n pFB^.INC();\nEND_IF\n\nIF (bDelete) THEN\n __DELETE(pFB);\nEND_IF " }, 
{ "title" : "Operator: __ISVALIDREF ", 
"url" : "_cds_operator_isvalidref.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: __ISVALIDREF ", 
"snippet" : "__ISVALIDREF Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator dient der Überprüfung, ob eine Referenz auf einen gültigen Wert verweist. Eine Beschreibung der Anwendung und ein Beispiel finden Sie in der Beschreibung des Datentyps REFERENCE ....", 
"body" : "__ISVALIDREF Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator dient der Überprüfung, ob eine Referenz auf einen gültigen Wert verweist. Eine Beschreibung der Anwendung und ein Beispiel finden Sie in der Beschreibung des Datentyps REFERENCE . " }, 
{ "title" : "Operator: __NEW ", 
"url" : "_cds_operator_new.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: __NEW ", 
"snippet" : "__NEW Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der __NEW -Operator reserviert dynamisch Speicher um Funktionsbausteine, benutzerdefinierte Datentypen oder Arrays von Standarddatentypen zu instanzieren. Der Operator gibt einen passend getypten Pointer zurück. Voraussetzung: Im Eigensch...", 
"body" : "__NEW Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der __NEW -Operator reserviert dynamisch Speicher um Funktionsbausteine, benutzerdefinierte Datentypen oder Arrays von Standarddatentypen zu instanzieren. Der Operator gibt einen passend getypten Pointer zurück. Voraussetzung: Im Eigenschaftendialog der übergeordneten Applikation, in der Registerkarte Optionen Applikationserzeugung , ist die Option Dynamische Speicherallozierung verwenden aktiviert. Syntax <pointer name> := __NEW( <type> ( , <size> )? );\n__DELETE( <pointer name> );\n\n<type> : <function block> | <data unit type> | <standard data type> Der Operator erzeugt eine Instanz des Typs <type> und gibt einen Pointer auf diese Instanz zurück. Anschließend wird die Initialisierung der Instanz aufgerufen. Wenn es sich bei <type> um einen skalaren Standarddatentyp handelt, wird zusätzlich der optionale Operand <size> ausgewertet. Der Operator erzeugt dann ein Array des Typs <standard data type> der Größe <size> . Wenn der Versuch Speicher zu allozieren scheitert, gibt __NEW den Wert 0 zurück. Verwenden Sie den Operator innerhalb der Zuweisung „ := „, ansonsten wird eine Fehlermeldung ausgegeben. Ein Funktionsbaustein oder ein benutzerdefinierter Datentyp, dessen Instanz mit __NEW dynamisch erzeugt wird, belegt einen fixen Speicherbereich. Dafür ist es erforderlich, dass Sie die Objekte mit dem Pragma {attribute 'enable_dynamic_creation'} kennzeichnen. Das ist bei Funktionsbausteinen, die Teil einer Bibliothek sind, nicht erforderlich. Wenn Sie im Onlinebetrieb das Datenlayout des Funktionsbausteins ändern, können Sie anschließend kein Einloggen mit Online-Change ausführen. Der Speicherbereich der Funktionsbaustein-Instanz ist nämlich ungültig geworden. Eine Änderung des Datenlayouts nehmen Sie vor, wenn Sie beim Funktionsbaustein neue Variablen hinzufügen, bestehende Variablen löschen oder Datentypen von Variablen ändern. Beispiel Array ( DWORD ) PROGRAM PLC_PRG\nVAR\n pdwScalar : POINTER TO DWORD; \/\/Typed pointer\n xInit : BOOL := TRUE;\n xDelete : BOOL;\nEND_VAR\n\nIF (xInit) THEN\n pdwScalar := __NEW(DWORD, 16); \/\/ Allocates memory (16 dwords) and assigns them to pointer pdwScalar\nEND_IF\nIF (xDelete) THEN\n __DELETE(pdwScalar); \/\/ Frees memory of pointer\nEND_IF Funktionsbaustein {attribute 'enable_dynamic_creation'}\nFUNCTION_BLOCK FBComputeGamma\nVAR_INPUT\n iAlpha : INT;\n iBeta : INT;\nEND_VAR\nVAR_OUTPUT\n iGamma : INT;\nEND_VAR\nVAR\nEND_VAR\n\niGamma := iAlpha + iBeta;\n\nPROGRAM PLC_PRG\nVAR\n pComputeGamma : POINTER TO FBComputeGamma; \/\/ Typed pointer\n xInit : BOOL := TRUE;\n xDelete : BOOL;\n iResult : INT;\nEND_VAR\n\nIF (xInit) THEN\n pComputeGamma := __NEW(FBComputeGamma); \/\/ Allocates memory\n xInit := FALSE;\nEND_IF\npComputeGamma^.iAlpha := (pComputeGamma^.iAlpha + 1)MOD 100; \/\/ Sets first input of pComputeGamma\npComputeGamma^.iBeta := 10; \/\/ Sets second input of pComputeGamma\npComputeGamma^(); \/\/ Calls the FB pComputeGamma is pointing to\niResult := pComputeGamma^.iGamma; \/\/ Reads output of pComputeGamma\nIF (xDelete) THEN\n __DELETE(pComputeGamma); \/\/ Frees memory\nEND_IF Benutzerdefinierter Datentyp (DUT) {attribute 'enable_dynamic_creation'}\nTYPE ABCDATA :\nSTRUCT\n iA, iB, iC, iD : INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n pABCData : POINTER TO ABCDATA; \/\/ Typed pointer\n xInit : BOOL := TRUE;\n xDelete : BOOL;\nEND_VAR\n\nIF (xInit) THEN\n pABCData := __NEW(ABCDATA); \/\/ Allocates memory\n xInit := FALSE;\nEND_IF\nIF (xDelete) THEN\n __DELETE(pABCData); \/\/ Frees memory\nEND_IF Array (BYTE) PROGRAM PLC_PRG\nVAR\n pbDataAlpha : POINTER TO BYTE;\n pbDataBeta : POINTER TO BYTE;\n xInit : BOOL := TRUE;\n xDelete : BOOL;\n usiCnt : USINT;\n bTestC: BYTE;\nEND_VAR\n\nIF (xInit) THEN\n pbDataAlpha := __NEW(BYTE, 16); \/\/ Allocates 16 bytes for pbDataAlpha\n pbDataBeta := __NEW(BYTE); \/\/ Allocates memory for pbDataBeta\n xInit := FALSE;\n\n FOR usiCnt := 0 TO 15 DO\n pbDataAlpha[usiCnt] := usiCnt; \/\/ Writes to new array\n END_FOR\n pbDataBeta^:= 16#FF; \/\/ Writes to new data\nEND_IF\n\nbTestC := pbDataAlpha[12]; \/\/ Reads new array by index access\n\nIF (xDelete) THEN \/\/ Frees memory\n __DELETE(pbDataAlpha);\n __DELETE(pbDataBeta);\nEND_IF Es ist nicht ratsam, zwei Tasks gleichzeitig auszuführen, die beide den __NEW -Operator aufrufen. Entweder Sie verwenden ein Semaphor ( SysSemEnter ) oder eine vergleichbare Technik, um einen konkurrierenden Aufruf von __NEW zu verhindern. Das bewirkt allerdings, dass bei umfangreicher Nutzung von __NEW ein höherer Jitter entsteht. Empfehlenswert ist, nur in einer Task __NEW -Operatoren aufzurufen. " }, 
{ "title" : "Operator: __QUERYINTERFACE ", 
"url" : "_cds_operator_queryinterface.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: __QUERYINTERFACE ", 
"snippet" : "__QUERYINTERFACE Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator führt zur Laufzeit eine Typkonvertierung einer Interface-Referenz zu einer anderen aus. Der Operator liefert ein Ergebnis vom Typ BOOL zurück. TRUE bedeutet, dass CODESYS die Konvertierung erfolgreich durchgeführt ...", 
"body" : "__QUERYINTERFACE Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator führt zur Laufzeit eine Typkonvertierung einer Interface-Referenz zu einer anderen aus. Der Operator liefert ein Ergebnis vom Typ BOOL zurück. TRUE bedeutet, dass CODESYS die Konvertierung erfolgreich durchgeführt hat. __QUERYINTERFACE( <ITF_Source> , <ITF_Dest> ); 1. Operand: Interface-Referenz oder FB-Instanz 2. Operand: Interface-Referenz mit gewünschten Zieltypen Voraussetzung für die explizite Konvertierung ist, dass sowohl das ITF_Source als auch ITF_Dest eine Ableitung vom Interface __System.IQueryInterface sind. Dieses Interface steht implizit zur Verfügung und benötigt keine Bibliothek. Beispiel INTERFACE ItfBase EXTENDS __System.IQueryInterface\nMETHOD mbase : BOOL\nEND_METHOD\n\nINTERFACE ItfDerived1 EXTENDS ItfBase\nMETHOD mderived1 : BOOL\nEND_METHOD\n\nINTERFACE ItfDerived2 EXTENDS ItfBase\nMETHOD mderived2 : BOOL\nEND_METHOD\n\nFUNCTION_BLOCK FB1 IMPLEMENTS ItfDerived1\nMETHOD mbase : BOOL\n mbase := TRUE;\nEND_METHOD\nMETHOD mderived1 : BOOL\n mderived1 := TRUE;\nEND_METHOD\nEND_FUNCTION_BLOCK\n\nFUNCTION_BLOCK FB2 IMPLEMENTS ItfDerived2\nMETHOD mbase : BOOL\n mbase := FALSE;\nEND_METHOD\nMETHOD mderived2 : BOOL\n mderived2 := TRUE;\nEND_METHOD\nEND_FUNCTION_BLOCK\n\nPROGRAMM POU\nVAR\n inst1 : FB1;\n inst2 : FB2;\n itfbase1 : ItfBase := inst1;\n itfbase2 : ItfBase := inst2;\n itfderived1 : ItfDerived1 := 0;\n itfderived2 : ItfDerived2 := 0;\n xResult1, xResult2, xResult3, xResult4: BOOL;\nEND_VAR\n\n\nxResult1 := __QUERYINTERFACE(itfbase1, itfderived1); \/\/ xResult = TRUE, itfderivedi1 <>0\n \/\/ references the instance inst1\nxResult2 := __QUERYINTERFACE(itfbase1, itfderived2); \/\/ xResult = FALSE, itfderived2 = 0\nxResult3 := __QUERYINTERFACE(itfbase2, itfderived1); \/\/ xResult = FALSE, itfderived1 = 0\nxResult4 := __QUERYINTERFACE(itfbase2, itfderived2); \/\/ xResult = TRUE, itfderived2 <> 0\n \/\/ references the instance inst2 " }, 
{ "title" : "Operator: __QUERYPOINTER ", 
"url" : "_cds_operator_querypointer.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: __QUERYPOINTER ", 
"snippet" : "__QUERYPOINTER Der Operator ist eine Erweiterung der IEC61131-3. Der Operator ermöglicht zur Laufzeit die Typkonvertierung einer Interface-Reference eines Funktionsbausteins auf einen Pointer. Der Operator liefert ein Ergebnis vom Typ BOOL zurück. TRUE bedeutet, dass CODESYS die Konvertierung erfolg...", 
"body" : "__QUERYPOINTER Der Operator ist eine Erweiterung der IEC61131-3. Der Operator ermöglicht zur Laufzeit die Typkonvertierung einer Interface-Reference eines Funktionsbausteins auf einen Pointer. Der Operator liefert ein Ergebnis vom Typ BOOL zurück. TRUE bedeutet, dass CODESYS die Konvertierung erfolgreich durchgeführt hat. Aus Kompatibilitätsgründen muss die Definition des zu konvertierenden Pointers eine Erweiterung des Basis-Interface __SYSTEM.IQueryInterface sein. __QUERYPOINTER ( <ITF_Source>, <Pointer_Dest> ) Der Operator bekommt als ersten Operanden eine Interface-Referenz oder eine FB-Instanz mit den gewünschten Zieltypen und als zweiten Operanden einen Pointer. Nach Abarbeiten von __QUERYPOINTER enthält Pointer_Dest den Pointer auf diejenige Referenz oder Instanz eines Funktionsbausteins, auf die die Interface-Referenz ITF_Source aktuell verweist. Pointer_Dest ist nicht getypt und kann auf einen beliebigen Typ gecastet werden. Sie müssen den Typ sicherstellen. Beispielsweise könnte das Interface eine Methode anbieten, die einen Typ-Code zurück liefert. " }, 
{ "title" : "Operator: __TRY, __CATCH, __FINALLY, __ENDTRY ", 
"url" : "_cds_operator_try_catch_finally_endtry.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: __TRY, __CATCH, __FINALLY, __ENDTRY ", 
"snippet" : "__TRY, __CATCH, __FINALLY, __ENDTRY Die Operatoren sind eine Erweiterung der Norm IEC 61131-3 und dienen einem gezielten Exceptionhandling im IEC-Code. Syntax __TRY <statements_try> __CATCH(exec) <statements_catch> __FINALLY <statements_finally> __ENDTRY <statements_next> Wenn eine Anweisung, die un...", 
"body" : "__TRY, __CATCH, __FINALLY, __ENDTRY Die Operatoren sind eine Erweiterung der Norm IEC 61131-3 und dienen einem gezielten Exceptionhandling im IEC-Code. Syntax __TRY\n <statements_try>\n__CATCH(exec)\n <statements_catch>\n__FINALLY\n <statements_finally>\n__ENDTRY\n <statements_next> Wenn eine Anweisung, die unter dem Operator __Try steht, eine Exception produziert, hält die Applikation nicht an. Sie führt stattdessen die Anweisungen unter __Catch aus und startet damit das Exceptionhandling. Danach führt sie die Anweisungen unter __FINALLY aus. Das Exeptionhandling endet mit __ENDTRY . Dann führt die Applikation die anschließenden Anweisungen aus. Eine IEC-Variable für eine Exception hat den Datentyp __System.ExceptionCode . Beispiel Wenn die Anweisung unter __TRY eine Exception produziert, wird die Programmabarbeitung nicht gestoppt, sondern die Anweisung unter __CATCH abgearbeitet. In diesem Beispiel wird also die Funktion exc und dann die Anweisung unter __FINALLY ausgeführt. Danach führt die Applikation die Anweisung unter __ENDTRY aus. FUNCTION Tester : UDINT\nVAR_INPUT\n count : UDINT;\nEND_VAR\nVAR_OUTPUT\n strExceptionText : STRING;\nEND_VAR\nVAR\n exc : __SYSTEM.ExceptionCode;\nEND_VAR\n\n__TRY\nTester := tryFun(count := count, testcase := g_testcase); \/\/This instruction is tested. If it produces an exception, the statement under __CATCH is executed first and then the statement under __FINALLY.\n__CATCH(exc)\nHandleException(exc, strExceptionText => strExceptionText);\n__FINALLY\nGVL.g_count := GVL.g_count + 2;\n__ENDTRY Für weitere Informationen siehe: Ausführung an behandelten Exceptions anhaltenDatentyp __System.ExceptionCode TYPE ExceptionCode :\n(\n\nRTSEXCPT_UNKNOWN := 16#FFFFFFFF,\nRTSEXCPT_NOEXCEPTION := 16#00000000,\nRTSEXCPT_WATCHDOG := 16#00000010,\nRTSEXCPT_HARDWAREWATCHDOG := 16#00000011,\nRTSEXCPT_IO_CONFIG_ERROR := 16#00000012,\nRTSEXCPT_PROGRAMCHECKSUM := 16#00000013,\nRTSEXCPT_FIELDBUS_ERROR := 16#00000014,\nRTSEXCPT_IOUPDATE_ERROR := 16#00000015,\nRTSEXCPT_CYCLE_TIME_EXCEED := 16#00000016,\nRTSEXCPT_ONLCHANGE_PROGRAM_EXCEEDED := 16#00000017,\nRTSEXCPT_UNRESOLVED_EXTREFS := 16#00000018,\nRTSEXCPT_DOWNLOAD_REJECTED := 16#00000019,\nRTSEXCPT_BOOTPROJECT_REJECTED_DUE_RETAIN_ERROR := 16#0000001A,\nRTSEXCPT_LOADBOOTPROJECT_FAILED := 16#0000001B,\nRTSEXCPT_OUT_OF_MEMORY := 16#0000001C,\nRTSEXCPT_RETAIN_MEMORY_ERROR := 16#0000001D,\nRTSEXCPT_BOOTPROJECT_CRASH := 16#0000001E,\nRTSEXCPT_BOOTPROJECTTARGETMISMATCH := 16#00000021,\nRTSEXCPT_SCHEDULEERROR := 16#00000022,\nRTSEXCPT_FILE_CHECKSUM_ERR := 16#00000023,\nRTSEXCPT_RETAIN_IDENTITY_MISMATCH := 16#00000024,\nRTSEXCPT_IEC_TASK_CONFIG_ERROR := 16#00000025,\nRTSEXCPT_APP_TARGET_MISMATCH := 16#00000026,\nRTSEXCPT_ILLEGAL_INSTRUCTION := 16#00000050,\nRTSEXCPT_ACCESS_VIOLATION := 16#00000051,\nRTSEXCPT_PRIV_INSTRUCTION := 16#00000052,\nRTSEXCPT_IN_PAGE_ERROR := 16#00000053,\nRTSEXCPT_STACK_OVERFLOW := 16#00000054,\nRTSEXCPT_INVALID_DISPOSITION := 16#00000055,\nRTSEXCPT_INVALID_HANDLE := 16#00000056,\nRTSEXCPT_GUARD_PAGE := 16#00000057,\nRTSEXCPT_DOUBLE_FAULT := 16#00000058,\nRTSEXCPT_INVALID_OPCODE := 16#00000059,\nRTSEXCPT_MISALIGNMENT := 16#00000100,\nRTSEXCPT_ARRAYBOUNDS := 16#00000101,\nRTSEXCPT_DIVIDEBYZERO := 16#00000102,\nRTSEXCPT_OVERFLOW := 16#00000103,\nRTSEXCPT_NONCONTINUABLE := 16#00000104,\nRTSEXCPT_PROCESSORLOAD_WATCHDOG := 16#00000105,\nRTSEXCPT_FPU_ERROR := 16#00000150,\nRTSEXCPT_FPU_DENORMAL_OPERAND := 16#00000151,\nRTSEXCPT_FPU_DIVIDEBYZERO := 16#00000152,\nRTSEXCPT_FPU_INEXACT_RESULT := 16#00000153,\nRTSEXCPT_FPU_INVALID_OPERATION := 16#00000154,\nRTSEXCPT_FPU_OVERFLOW := 16#00000155,\nRTSEXCPT_FPU_STACK_CHECK := 16#00000156,\nRTSEXCPT_FPU_UNDERFLOW := 16#00000157,\nRTSEXCPT_VENDOR_EXCEPTION_BASE := 16#00002000,\nRTSEXCPT_USER_EXCEPTION_BASE := 16#00010000\n) UDINT ;\nEND_TYPE " }, 
{ "title" : "Operator: __VARINFO ", 
"url" : "_cds_operator_varinfo.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: __VARINFO ", 
"snippet" : "__VARINFO Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator liefert Informationen zu einer Variablen zurück. Sie können die Informationen als Datenstruktur in einer Variablen des Datentyps __SYSTEM.VAR_INFO speichern. Syntax in der Deklaration <name of the info variable> : __SYSTE...", 
"body" : "__VARINFO Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator liefert Informationen zu einer Variablen zurück. Sie können die Informationen als Datenstruktur in einer Variablen des Datentyps __SYSTEM.VAR_INFO speichern. Syntax in der Deklaration <name of the info variable> : __SYSTEM.VAR_INFO; \/\/ Data structure for info variable Syntax beim Aufruf <name of the info variable> := __VARINFO( <variable name> ); \/\/ Call of the operator Beispiel FUNCTION_BLOCK FB_Velocity\nVAR_INPUT\n rVelocity: REAL := 1.2;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n infoVelocity: __SYSTEM.VAR_INFO; \/\/Info of Velocity\nEND_VAR\n\ninfoVelocity := __VARINFO(rVelocity); \/\/ Gets the info of Velocity locally PROGRAM PLC_PRG\nVAR\n iCounter : INT := 0; \/\/ Counts the calls\n infoCounter : __SYSTEM.VAR_INFO; \/\/Info of Counter\n arrA : ARRAY [1..2, 1..2, 1..2] OF INT := [0, 1, 2, 3, 4, 5, 6, 7]; \/\/ Stores the A data\n infoA : __SYSTEM.VAR_INFO; \/\/Info of A\n fbVel : FB_Velocity;\nEND_VAR\n\niCounter := iCounter + 1;\ninfoCounter := __VARINFO(iCounter);\ninfoA := __VARINFO(arrA);\nfbVel(); Im Applikationscode sind die Variablen iCounter und arrA bekannt. Die Variableninformationen werden in den Variablen infoCounter und infoA abgelegt. Außerdem ist der Funktionsbaustein FB_Velocity instanziert. " }, 
{ "title" : "Datentyp __SYSTEM.VAR_INFO ", 
"url" : "_cds_operator_varinfo.html#UUID-a5c59974-aff9-8df3-9a5d-66a904a67842_id_bfe36bd11d79fbf5c0a86463350fcaac_id_f26a4b1dd3c4781cc0a86463447d5db7", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: __VARINFO \/ Datentyp __SYSTEM.VAR_INFO ", 
"snippet" : "Name Datentyp Initialisierung Beschreibung ByteAddress DWORD 0 Adresse der Variablen Beispiel: 16#072E35EC Hinweis: Beim Bitzugriff einer Variablen <variable name>.<bit index> wird die Adresse der Variablen angegeben, die das Bit enthält. ByteOffset DWORD 0 Offset der Variablenadresse in Bytes Beisp...", 
"body" : "Name Datentyp Initialisierung Beschreibung ByteAddress DWORD 0 Adresse der Variablen Beispiel: 16#072E35EC Hinweis: Beim Bitzugriff einer Variablen <variable name>.<bit index> wird die Adresse der Variablen angegeben, die das Bit enthält. ByteOffset DWORD 0 Offset der Variablenadresse in Bytes Beispiel: 13936 Bytes Hinweis: Wenn die Variable global ist, dann ist der Offset relativ zum Beginn der Area. Wenn die Variable eine lokale Variable in einer Funktion oder Methode ist, dann ist der Offset relativ zum aktuellen Stack-Frame. Wenn die Variable eine lokale Variable in einem Funktionsbaustein ist, dann ist der Offset relativ zur Funktionsbaustein-Instanz. Area DINT 0 Speicherbereichsnummer Area im Laufzeitsystem Beispiel: -1 Bedeutet, dass die Variable nicht global im Speicher liegt, sondern relativ zu einer Instanz oder auf dem Stack Hinweis: Die Speicherbereiche sind geräteabhängig. BitNr INT 0 Anzahl der Bits in Bytes Beispiel: 16#00FF Bytes Hinweis: Wenn die Variable kein ganzzahliger Datentyp ist, gilt: BitNr = -1 = 16#FFFF BitSize INT 0 Speicherplatzgröße der Variablen in Bits Beispiel: 16 Bits BitAddress UDINT 0 Bitadresse der Variablen Voraussetzung: Die Variable liegt im Eingangsspeicherbereich I , Ausgangsspeicherbereich Q oder Merkerspeicherbereich M . Ansonsten ist der Wert undefiniert. TypeClass TYPE_CLASS TYPE_BOOL Datentypklasse der Variablen Beispiel: TYPE_INT , TYPE_ARRAY Hinweis: Bei benutzerdefinierten Datentypen oder Funktionsbaustein-Instanzen wird als Datantypklasse TYPE_USERDEF ausgegeben. TypeName STRING(79) ‚‘ Datentypname der Variablen als STRING(79) Hinweis: Bei benutzerdefinierten Datentypen ist der Funktionsbausteinname oder der DUT-Name angegeben. Beispiel: 'INT' , 'ARRAY' NumElements UDINT 0 Anzahl der Arrayelemente Voraussetzung: Die Variable hat den Datentyp ARRAY . Beispiel: 8 BaseTypeClass TYPE_CLASS TYPE_BOOL Elementarer Basisdatentyp der Arrayelemente Voraussetzung: Die Variable hat den Datentyp ARRAY . Beispiel: TYPE_INT bei arrA : ARRAY [1..2,1..2,1..2] OF INT; ElemBitSize UDINT 0 Speicherplatzgröße des Arrayelements in Bits Voraussetzung: Die Variable hat den Datentyp ARRAY . Beispiel: 16 Bits bei arrA : ARRAY [1..2,1..2,1..2] OF INT; MemoryArea MEMORY_AREA MEM_MEMORY Information zum Speicherbereich MEM_GLOBAL : Globaler Speicherbereich Beispiel: in Area 0 MEM_LOCAL : Lokaler Speicherbereich in Area -1 MEM_MEMORY : Merkerspeicherbereich %M Beispiel: in 16#10 in Area 1 MEM_INPUT : Eingangsspeicherbereich %I Beispiel: in 16#04 in Area 2 MEM_OUTPUT : Ausgangsspeicherbereich %Q Beispiel: in 16#08 in Area 3 MEM_RETAIN : Retain-Speicherbereich Beispiel: in 16#20 in Area 0 Beispiel: MEM_GLOBAL Hinweis: Die Speicherbereichkonfiguration ist geräteabhängig. Symbol STRING(39) ‚‘ Variablenname als STRING(39) Beispiel: 'iCounter' , 'arrA' Comment STRING(79) ‚‘ Kommentar der Variablendeklaration Beispiel: 'Counts the calls' oder 'Stores the A data' " }, 
{ "title" : "Operator: __CURRENTTASK ", 
"url" : "_cds_operator_currenttask.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: __CURRENTTASK ", 
"snippet" : "__CURRENTTASK Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator liefert zur Laufzeit Informationen über die gerade ausgeführte IEC-Task. Der Operator wird nur auf Zielsystemen unterstützt , bei denen die Zielsystemeinstellung memory-layout\\max-stack-size auf einen Wert > 0 gesetzt...", 
"body" : "__CURRENTTASK Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator liefert zur Laufzeit Informationen über die gerade ausgeführte IEC-Task. Der Operator wird nur auf Zielsystemen unterstützt , bei denen die Zielsystemeinstellung memory-layout\\max-stack-size auf einen Wert > 0 gesetzt ist. Der Operator ermöglicht Zugriff auf eine Struktur mit zwei Variablen. TaskIndex : Nullbasierter Index, der die Task identifiziert pTaskInfo : Detaillierte Informationen über die gerade ausgeführte Task Kann einem POINTER TO Task_Info2 aus der Bibliothek CmpIecTask zugewiesen werden Der Operator kann nicht in der Deklaration eines Programmbausteins verwendet werden, dies führt zu einer Fehlermeldung. Wenn die aktuelle Task nicht bestimmt werden kann, ist der TaskIndex -1 und die pTaskInfo gleich null. Beispiel \/\/Declaration\nVAR\n idx : INT;\n pInfo : POINTER TO Task_Info2;\nEND_VAR\n\n\/\/Program code\n\nidx := __CURRENTTASK.TaskIndex;\npInfo := __CURRENTTASK.pTaskInfo; " }, 
{ "title" : "Operator: __COMPARE_AND_SWAP ", 
"url" : "_cds_operator_compare_and_swap.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: __COMPARE_AND_SWAP ", 
"snippet" : "__COMPARE_AND_SWAP Der Multicore-Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator kann zur Realisierung einer Semaphore verwendet werden, beispielsweise um den exklusiven Zugriff auf eine Variable zu garantieren, die von verschiedenen Tasks geschrieben wird. __COMPARE_AND_SWAP bekomm...", 
"body" : "__COMPARE_AND_SWAP Der Multicore-Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator kann zur Realisierung einer Semaphore verwendet werden, beispielsweise um den exklusiven Zugriff auf eine Variable zu garantieren, die von verschiedenen Tasks geschrieben wird. __COMPARE_AND_SWAP bekommt als Eingabe einen Pointer auf eine Variable vom Datentyp __XWORD , einen alten Wert und einen neuen Wert, beispielsweise bMutex := __COMPARE_AND_SWAP(ADR(dwSynch), dwOld, dwNew); . Der alte und neue Wert können auch Variablen vom Datentyp __XWORD sein. Die referenzierte __XWORD -Variable wird mit dem alten Wert verglichen und wenn beide gleich sind, dann wird der neue Wert geschrieben. Das Ergebnis der Funktion ist TRUE , wenn der neue Wert geschrieben werden konnte. Der Datentyp __XWORD wird vom Compiler automatisch bei 32-Bit-Systemen durch DWORD und bei 64-Bit-Systemen durch LWORD ersetzt. Diese Operation verläuft atomar, sie kann also nicht von einer anderen Task unterbrochen werden, dies gilt auch auf Multicore-Plattformen. Beispiel Das folgende Beispiel zeigt eine typische Verwendung. Es soll ein exklusiver Zugriff auf eine Variable vom Typ STRING implementiert werden, die über den Pointer pstrOutput angesprochen wird. Der Zugriff auf einen String ist nicht atomar. Wenn mehrere Tasks gleichzeitig auf denselben String schreiben, dann kann der Inhalt inkonsistent sein. Mit dieser Funktion ist es nun möglich in verschiedenen Tasks dieselbe STRING-Variable zu schreiben. FUNCTION ExclusiveStringWrite : BOOL\nVAR_INPUT\n strToWrite : STRING;\n pstrOutput : POINTER TO STRING;\nEND_VAR\nVAR_STAT\n dwSynch : __XWORD;\nEND_VAR\nVAR\n bMutex: BOOL;\nEND_VAR\n\nbMutex:= __COMPARE_AND_SWAP(ADR(dwSynch), 0, 1);\n(* compare with 0 and write 1 as atomic operation *)\nIF bMutex THEN \/\/ bMutex is TRUE if write could be done\n pstrOutput^ := strToWrite; \/\/ Now you can write safely on the string\n dwSynch := 0; \/\/ The __XWORD variable must be reset.\n ExclusiveStringWrite := TRUE; \/\/ Writing was successful\nELSE\n ExclusiveStringWrite := FALSE; \/\/ Writing was not successful\nEND_IF " }, 
{ "title" : "Operator: __XADD ", 
"url" : "_cds_operator_xadd.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: __XADD ", 
"snippet" : "__XADD Der Multicore-Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator kann zur Realisierung eines atomaren Zählers verwendet werden. Wenn eine Integer-Variable mit einer normalen Addition, zum Beispiel iTest := iTest + 1; hochgezählt wird, dann wird diese Operation nicht atomar ausge...", 
"body" : "__XADD Der Multicore-Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator kann zur Realisierung eines atomaren Zählers verwendet werden. Wenn eine Integer-Variable mit einer normalen Addition, zum Beispiel iTest := iTest + 1; hochgezählt wird, dann wird diese Operation nicht atomar ausgeführt. Zwischen dem Lesen und dem Schreiben der Variable könnte ein weiterer Zugriff auf die Variable erfolgen. Wenn der Zähler in mehreren Tasks hochgezählt wird, kann das Ergebnis der Zählung kleiner sein als die Anzahl der Zählvorgänge. Wenn also zwei Tasks den obigen Code einmal ausführen und die Variable zuvor den Wert 0 hatte, dann kann die Variable anschließend den Wert 1 haben. Das ist insbesondere dann problematisch, wenn Arrays in mehreren Tasks bearbeitet werden und in jeder Bearbeitung ein eindeutiger Index für das Array benötigt wird. Die Operator __XADD erhält beim Aufruf als ersten Summanden einen Pointer auf eine Variable vom Typ DINT und als zweiten Summanden einen Wert vom Typ DINT . __XADD liefert den alten Wert des ersten Summanden zurück und addiert im selben Schritt den zweiten Summanden auf den ersten Summanden. Beispielsweise kann der Aufruf der Funktion wie folgt aussehen: diOld := __XADD(ADR(diVar), deAdd); Beispiel Das folgende Beispiel zeigt eine typische Verwendung. Ein Array soll aus zwei Tasks gefüllt werden, dabei sollen alle Positionen im Array verwendet werden und keine Position überschrieben werden. Mit dieser Funktion können mehrere Tasks ein boolsches Array füllen. FUNCTION WriteToNextArrayPosition : BOOL\nVAR_EXTERNAL\n g_diIndex : DINT; \/\/ Index and array are globally defined and used by multiple tasks\n g_boolArray : ARRAY [0..1000] OF BOOL;\nEND_VAR\nVAR_INPUT\n bToWrite : BOOL;\nEND_VAR\nVAR\n diIndex : DWORD;\nEND_VAR\n\ndiIndex := __XADD(ADR(g_diIndex), 1); \/\/ Returns a unique index\nWriteToNextArrayPosition := FALSE;\nIF (diIndex >= 0 AND diIndex <= 1000) THEN\n g_boolArray[diIndex] := bToWrite; \/\/Writes to unique index\n WriteToNextArrayPosition := TRUE; \/\/ TRUE: Array was not full yet\nEND_IF " }, 
{ "title" : "Operator: __POSITION ", 
"url" : "_cds_operator_position.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: __POSITION ", 
"snippet" : "__POSITION Der Operator ist eine Erweiterung der Norm IEC 61131-1. Der Operator liefert zur Laufzeit die Position einer Variablen im Deklarationsteil oder im Implementierunsteil eines Programmierbausteins. Der Variablen vom Typ STRING muss der Operator im Deklarationsteil beziehungsweise im Implemen...", 
"body" : "__POSITION Der Operator ist eine Erweiterung der Norm IEC 61131-1. Der Operator liefert zur Laufzeit die Position einer Variablen im Deklarationsteil oder im Implementierunsteil eines Programmierbausteins. Der Variablen vom Typ STRING muss der Operator im Deklarationsteil beziehungsweise im Implementierungsteil zugewiesen werden. Ergebnis von __POSITION Deklarationsteil: 'Line <line number> (Decl)' Implementierungsteil: 'Line <line number>, Column <Column number> (Impl)' Beispiel PROGRAM PROG1\nVAR\n strPOS : STRING := __POSITION(); \/\/Returns the line number of this declaration\n strlocalPOS : STRING;\nEND_VAR\n\n strlocalPOS := __POSITION(); \/\/Returns row and column number of this assignment " }, 
{ "title" : "Operator: __POUNAME ", 
"url" : "_cds_operator_pouname.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: __POUNAME ", 
"snippet" : "__POUNAME Der Operator ist eine Erweiterung der Norm IEC 61131-1. Der Operator liefert zur Laufzeit den Namen des Programmierbausteins (POU), die den Operator __POUNAME enthält. Das Ergebnis ist vom Typ STRING . Ergebnis von __POUNAME ist abhängig vom Ort der Verwendung Innerhalb eines Programms: Pr...", 
"body" : "__POUNAME Der Operator ist eine Erweiterung der Norm IEC 61131-1. Der Operator liefert zur Laufzeit den Namen des Programmierbausteins (POU), die den Operator __POUNAME enthält. Das Ergebnis ist vom Typ STRING . Ergebnis von __POUNAME ist abhängig vom Ort der Verwendung Innerhalb eines Programms: Progammname Innerhalb einer Funktion: Funktionsname Innerhalb eines Funktionsbausteins: Name des Funktionsbausteins Innerhalb einer Methode: der mit dem FB-Namen qualifizierte Methodenname Innerhalb einer Get-\/Set-Accessors einer Eigenschaft: Der mit dem FB-Namen qualifizierte Eigenschaftsname + Get\/Set Innerhalb eine GVL: Name der GVL Innerhalb einer Struktur: Strukturname Innerhalb einer Datenstruktur UNION : Name der UNION Beispiel PROGRAM PROG1\nVAR\n strPOU : STRING := __POUNAME(); \/\/Returns 'PROG1'\n strlocalPOU : STRING;\nEND_VAR\n\nstrlocalPOU := __POUNAME(); \/\/Returns 'PROG1' " }, 
{ "title" : "Operator: TEST_AND_SET ", 
"url" : "_cds_operator_test_and_set.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: TEST_AND_SET ", 
"snippet" : "TEST_AND_SET Der Multicore-Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator kann zur Realisierung einer Semaphore verwendet werden, beispielsweise um einen exklusiven Zugriff auf eine Variable zu garantieren, die von verschiedenen Tasks geschrieben wird. TEST_AND_SET bekommt als Eing...", 
"body" : "TEST_AND_SET Der Multicore-Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator kann zur Realisierung einer Semaphore verwendet werden, beispielsweise um einen exklusiven Zugriff auf eine Variable zu garantieren, die von verschiedenen Tasks geschrieben wird. TEST_AND_SET bekommt als Eingabe eine Variable vom Typ DWORD . Für diese Variable muss ein Schreibzugriff möglich sein. Die Variable wird auf 1 gesetzt und der vorherige Wert wird als Ergebnis zurückgeliefert. Die Operation verläuft atomar, das bedeutet, dass sie nicht von einer anderen Task unterbrochen werden kann. Dies gilt auch auf Multicore-Plattformen. Der Aufruf im Programm ist beispielsweise dwOldValue := TEST_AND_SET(dw); , wobei die Variablen dwOldValue und dw vom Datentyp DWORD sein müssen. Beispiel Das folgende Beispiel zeigt eine typische Verwendung. Es soll ein exklusiver Zugriff auf eine Variable vom Typ STRING implementiert werden, die über den Pointer pstrOutput angesprochen wird. Der Zugriff auf einen String ist nicht atomar. Wenn mehrere Tasks gleichzeitig auf denselben String schreiben, dann kann der Inhalt inkonsistent sein. Mit der Funktion TEST_AND_SET ist es nun möglich, in verschiedenen Tasks dieselbe STRING -Variable zu schreiben. FUNCTION ExclusiveStringWrite : BOOL\nVAR_INPUT\n strToWrite : STRING;\n pstrOutput : POINTER TO STRING;\nEND_VAR\nVAR_STAT\n dwSynch : DWORD;\nEND_VAR\nVAR\n dwOldValue: DWORD;\nEND_VAR\n\ndwOldValue := TEST_AND_SET(dwSynch); \/\/ Write the 1 and read the old value at the same time\nIF dwOldValue = 0 THEN \/\/ 0 means: no other task is currently writing\n pstrOutput^ := strToWrite; \/\/ Now you can write safely on the string\n dwSynch := 0; \/\/ The DWORD must be reset\n ExclusiveStringWrite := TRUE; \/\/ Writing was successful\nELSE\n ExclusiveStringWrite := FALSE; \/\/ Writing was not successful\nEND_IF " }, 
{ "title" : "Operator: Globaler Namensraum ", 
"url" : "_cds_operator_namespace_global.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: Globaler Namensraum ", 
"snippet" : "Globaler Namensraum Der Operator ist eine Erweiterung der Norm IEC 61131-3. Ein Instanzpfad, der mit einem Punkt . beginnt, öffnet immer einen globalen Namensraum. Wenn es also eine lokale Variable mit dem gleichen Namen <varname> gibt wie eine globale Variable, sprechen Sie mit .<varname> die globa...", 
"body" : "Globaler Namensraum Der Operator ist eine Erweiterung der Norm IEC 61131-3. Ein Instanzpfad, der mit einem Punkt . beginnt, öffnet immer einen globalen Namensraum. Wenn es also eine lokale Variable mit dem gleichen Namen <varname> gibt wie eine globale Variable, sprechen Sie mit .<varname> die globale Variable an. " }, 
{ "title" : "Operator: Namensraum für Globale Variablenlisten ", 
"url" : "_cds_operator_namespace_gvl.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: Namensraum für Globale Variablenlisten ", 
"snippet" : "Namensraum für Globale Variablenlisten Der Operator ist eine Erweiterung der Norm IEC 61131-3. Den Namen einer globalen Variablenliste (GVL) können Sie als Namensraum-Bezeichner für die in der Liste definierten Variablen verwenden. Dadurch ist es möglich, Variablen mit gleichen Namen in verschiedene...", 
"body" : "Namensraum für Globale Variablenlisten Der Operator ist eine Erweiterung der Norm IEC 61131-3. Den Namen einer globalen Variablenliste (GVL) können Sie als Namensraum-Bezeichner für die in der Liste definierten Variablen verwenden. Dadurch ist es möglich, Variablen mit gleichen Namen in verschiedenen globalen Variablenlisten zu verwenden und dennoch eindeutig auf eine bestimmte Variable zuzugreifen. Dem Variablennamen stellen Sie den Namen der globalen Variablenliste getrennt durch einen Punkt . voran. <global variable list name>.<variable> Beispiel globlist1.varx := globlist2.varx; Die globalen Variablenlisten globlist1 und globlist2 enthalten jeweils eine Variable varx . CODESYS kopiert die globale Variable varx aus Liste globlist2 in varx aus Liste globlist1 . Wenn Sie eine Variable, die in mehreren globalen Variablenlisten deklariert ist, ohne den vorangestellten Listennamen referenzieren, erscheint eine Fehlermeldung. " }, 
{ "title" : "Operator: Bibliotheksnamensraum ", 
"url" : "_cds_operator_namespace_lib.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: Bibliotheksnamensraum ", 
"snippet" : "Bibliotheksnamensraum Syntax: <library namespace>.<library POU identifier> Beispiel: LIB_A.FB_A Ein Bibliotheksbausteinbezeichner wird (als Präfix mit einem Punkt getrennt) um den Bibliotheksnamensraum erweitert, um eindeutig und qualifiziert auf den Bibliotheksbaustein zuzugreifen. Üblicherweise st...", 
"body" : "Bibliotheksnamensraum Syntax: <library namespace>.<library POU identifier> Beispiel: LIB_A.FB_A Ein Bibliotheksbausteinbezeichner wird (als Präfix mit einem Punkt getrennt) um den Bibliotheksnamensraum erweitert, um eindeutig und qualifiziert auf den Bibliotheksbaustein zuzugreifen. Üblicherweise stimmen Namensraum und Name einer Bibliothek überein. Beispiel Eine Bibliothek ist in einem Projekt eingebunden und enthält einen Baustein FB_A . In dem Projekt ist aber bereits lokal ein Funktionsbaustein mit gleichem Namen instanziiert. Bezeichnen Sie den Bibliotheksbaustein mit LIB_A.FB_A , um nicht auf den lokalen Funktionsbaustein sondern auf den Bibliotheksbaustein zuzugreifen. var1 := FB_A(in := 12); \/\/ Call of the project function FB_A\nvar2 := LIB_A.FB_A(in := 22); \/\/ Call of the library function FB_A Sie können für den Namensraum eine anderen Bezeichner definieren. Dafür tragen Sie (als Bibliotheksentwickler beim Erstellen eines Bibliotheksprojekts) in den Projektinformationen einen Namensraum ein. Oder Sie bestimmen (als Applikationsentwickler beim Erstellen einer Applikation) im Bibliotheksverwalter für eine Bibliothek im Dialog Eigenschaften einen speziellen Namensraum. Für weitere Informationen siehe: Bibliotheken verwenden" }, 
{ "title" : "Operator # für direkten Zugriff ", 
"url" : "_cds_operator_namespace_lib.html#UUID-743ca1a8-1b92-e8be-7a21-610d20d2e0b2_section-idm13349116767826", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: Bibliotheksnamensraum \/ Operator # für direkten Zugriff ", 
"snippet" : "Der Operator ist eine Erweiterung der Norm IEC 61131-3. Es ist möglich, dass lokale Komponenten eines Funktionsbausteins namensgleiche Bibliotheksbausteine verschatten und so eine Mehrdeutigkeit verursacht wird. Infolgedessen ist ein Zugriff mit der üblichen Namensraumkonvention nicht möglich. Dann ...", 
"body" : "Der Operator ist eine Erweiterung der Norm IEC 61131-3. Es ist möglich, dass lokale Komponenten eines Funktionsbausteins namensgleiche Bibliotheksbausteine verschatten und so eine Mehrdeutigkeit verursacht wird. Infolgedessen ist ein Zugriff mit der üblichen Namensraumkonvention nicht möglich. Dann ist es hilfreich den Operator # zu verwenden, um einen direkten Zugriff zu erzwingen. Mit der folgenden Syntax können Sie einen direkten Zugriff erzwingen: Syntax: <namespace> # <library POU path> Beispiel TYPE Struct1 :\nSTRUCT\n\tStandard : Struct2;\nEND_STRUCT\nEND_TYPE TYPE Struct2 :\nSTRUCT\n\tConcat : DINT;\nEND_STRUCT\nEND_TYPE {attribute 'qualified_only'}\nVAR_GLOBAL\n\tStandard : Struct2;\nEND_VAR PROGRAM PLC_PRG\nVAR\n test : _3S_License#Standard#TON;\n str : STRING;\nEND_VAR\n\n\/\/ access to global variable\n_3S_License.Standard.CONCAT := 123;\n\n\/\/ with hashtag access, the library is explicitly addressed \nstr := _3S_License.Standard#CONCAT('test1', '3444');\nstr := Standard#CONCAT('test1', '3444');\nstr := _3S_License#Standard#CONCAT('test1', '3444');\nstr := _3S_License.Standard#CONCAT('test1', '3444');\nstr := CONCAT('test1', Standard#CONCAT('3444', '444'));\nstr := CONCAT('test1', _3S_License.Standard#CONCAT('3444', '444'));\nstr := CONCAT('test1', _3S_License#Standard#CONCAT('3444', '444'));\nstr := Standard#CONCAT('test1', Standard#CONCAT('3444', '444'));\nstr := Standard#CONCAT('test1', _3S_License.Standard#CONCAT('3444', '444'));\nstr := Standard#CONCAT('test1', _3S_License#Standard#CONCAT('3444', '444'));\nstr := Standard#CONCAT('test1', _3S_License#Standard#CONCAT('asdf', 'fdas'));\n " }, 
{ "title" : "Operator: Enumerations-Namensraum ", 
"url" : "_cds_operator_namespace_enum.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: Enumerations-Namensraum ", 
"snippet" : "Enumerations-Namensraum Der Operator ist eine Erweiterung der Norm IEC 61131-3. Sie können den TYPE-Namen einer Enumeration für einen eindeutigen Zugriff auf eine Enumerations-Konstante verwenden. Somit können Sie Konstanten gleichen Namens in mehreren Enumerationen verwenden. Der Enumerationsname w...", 
"body" : "Enumerations-Namensraum Der Operator ist eine Erweiterung der Norm IEC 61131-3. Sie können den TYPE-Namen einer Enumeration für einen eindeutigen Zugriff auf eine Enumerations-Konstante verwenden. Somit können Sie Konstanten gleichen Namens in mehreren Enumerationen verwenden. Der Enumerationsname wird dem Konstantennamen getrennt durch einen Punkt . vorangestellt. <Enumerationsname>.<Konstantenname> Beispiel Die Konstante Blue ist sowohl eine Komponente der Enumeration Colors als auch eine der Enumeration Feelings . color := Colors.Blue; \/\/ Access to coomponent Blue in enumeration Colors\n\nfeeling := Feelings.Blue; \/\/ Acces to component Blue in enumeration Feelings " }, 
{ "title" : "Operator: __POOL ", 
"url" : "_cds_operator_pool.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: __POOL ", 
"snippet" : "__POOL Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator dient dem Referenzieren von Objekten, die im globalen POUs-Pool, das heißt in der Ansicht POUs verwaltet werden. Der Operator greift direkt auf Objekte in der Ansicht POUs zu. Beispiel PROGRAM PLC_PRG VAR svar_pou : STRING; ...", 
"body" : "__POOL Der Operator ist eine Erweiterung der Norm IEC 61131-3. Der Operator dient dem Referenzieren von Objekten, die im globalen POUs-Pool, das heißt in der Ansicht POUs verwaltet werden. Der Operator greift direkt auf Objekte in der Ansicht POUs zu. Beispiel PROGRAM PLC_PRG\nVAR\n svar_pou : STRING;\nEND_VAR\n\nsvar_pou := __POOL.POU(); Für weitere Informationen siehe: Verschattung vermeiden" }, 
{ "title" : "Operator: INI ", 
"url" : "_cds_operator_ini.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren \/ Operator: INI ", 
"snippet" : "INI Der INI -Operator ist ein Operator von CoDeSys V2.3 . Dieser Operator wird ab CODESYS V3 durch die Methode FB_Init ersetzt. In Projekten, die Sie aus CoDeSys V2.3 importiert haben, können Sie diesen Operator aber weiterhin verwenden. Syntax <boolean variable name> := INI ( <FB instance name> , <...", 
"body" : "INI Der INI -Operator ist ein Operator von CoDeSys V2.3 . Dieser Operator wird ab CODESYS V3 durch die Methode FB_Init ersetzt. In Projekten, die Sie aus CoDeSys V2.3 importiert haben, können Sie diesen Operator aber weiterhin verwenden. Syntax <boolean variable name> := INI ( <FB instance name> , <boolean value> );\n\/\/ <boolean value> : TRUE | FALSE Mit dem INI -Operator können Sie die Initialisierung von Retain-Variablen einer im Baustein verwendeten Funktionsbaustein-Instanz anstoßen. Wenn der zweite Parameter des Operators TRUE ist, initialisiert CODESYS alle im Funktionsbaustein <FB instance name> definierten Retain-Variablen und gibt danach TRUE zurück. Beispiel in ST fbinst ist die Instanz des Funktionsbausteins fb1 , in dem eine Retain-Variable retvar definiert ist. VAR\n fbinst : fb1;\n b : BOOL;\nEND_VAR\n\nb := INI(fbinst, TRUE);\nivar := fbinst.retvar; (* => retvar is initialized *)\n Beispiel in FUP Für weitere Informationen siehe: RETAIN, Daten mit Retain-Variablen erhalten" }, 
{ "title" : "Operatoren für Typkonvertierung ", 
"url" : "_cds_conversion_operators.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung ", 
"snippet" : "Die Rundungslogik für Grenzfälle ist vom Zielsystem beziehungsweise von der FPU ( Floating Point Unit) des Zielsystems abhängig. Ein Wert wie beispielsweise -1.5 kann auf verschiedenen Steuerungen unterschiedlich konvertiert werden. Fangen Sie Überschreitungen von Wertebereichen über die Applikation...", 
"body" : "Die Rundungslogik für Grenzfälle ist vom Zielsystem beziehungsweise von der FPU ( Floating Point Unit) des Zielsystems abhängig. Ein Wert wie beispielsweise -1.5 kann auf verschiedenen Steuerungen unterschiedlich konvertiert werden. Fangen Sie Überschreitungen von Wertebereichen über die Applikation ab, um vom Zielsystem unabhängigen Code zu programmieren. Wenn bei einem Typkonvertierungsoperator der Operandenwert außerhalb des Wertebereichs des Zieldatentyps liegt, ist die Ergebnisausgabe vom Prozessortyp abhängig und damit undefiniert. Dies ist beispielsweise der Fall, wenn ein negativer Operandenwert von LREAL in den Zieldatentyp UINT konvertiert wird. Bei der Typkonvertierung von größeren auf kleinere Typen können Informationen verloren gehen. Stringmanipulation Bei einer Typkonvertierung nach STRING oder WSTRING wird der getypte Wert als Zeichenfolge linksbündig abgelegt und bei Überlänge abgeschnitten. Deklarieren Sie deshalb die Rückgabevariablen für die Typkonvertierungsoperatoren <>_TO_STRING und <>_TO_WSTRING ausreichend lang, so dass die Zeichenfolge ohne Manipulation Platz findet. " }, 
{ "title" : "Typkonvertierung ", 
"url" : "_cds_conversion_operators.html#UUID-a8ef93c9-c5d6-bfc3-02a3-f7ae8780fbce_UUID-42fbcdfe-e4d8-8424-32d5-eb04a19b62c4_section-idm13452249872816", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Typkonvertierung ", 
"snippet" : "Sie können Typkonvertierungsoperatoren explizit aufrufen. Für getypte Konvertierungen von einem elementaren Typ in einen anderen elementaren Typ und auch für Überladungen stehen die unten beschriebenen Typkonvertierungsoperatoren zur Verfügung. Konvertierungen von einem „größeren“ Typ auf einen „kle...", 
"body" : "Sie können Typkonvertierungsoperatoren explizit aufrufen. Für getypte Konvertierungen von einem elementaren Typ in einen anderen elementaren Typ und auch für Überladungen stehen die unten beschriebenen Typkonvertierungsoperatoren zur Verfügung. Konvertierungen von einem „größeren“ Typ auf einen „kleineren“ Typ, wie beispielsweise von INT nach BYTE oder von DINT nach WORD , sind aber auch implizit möglich. " }, 
{ "title" : "Überladene Konvertierung ", 
"url" : "_cds_operator_to_xxx.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Überladene Konvertierung ", 
"snippet" : "Überladung Die Norm IEC61131-3 kennt keine überladenen Funktionen. Wenn Sie strikt nach IEC61131-3 programmieren möchten, verwenden Sie bitte die in den folgenden Abschnitten beschriebenen Operatoren nach der Syntay <Ausgangstyp> _TO_ <Zieltyp>. Die Operatoren konvertieren Werte in andere Datentypen...", 
"body" : "Überladung Die Norm IEC61131-3 kennt keine überladenen Funktionen. Wenn Sie strikt nach IEC61131-3 programmieren möchten, verwenden Sie bitte die in den folgenden Abschnitten beschriebenen Operatoren nach der Syntay <Ausgangstyp> _TO_ <Zieltyp>. Die Operatoren konvertieren Werte in andere Datentypen, wobei explizit nur ein Zieltyp (und kein Ausgangstyp für den Operanden) angegeben wird (überladene Konvertierung). Die Regeln für die getypten Konvertierungen gelten auch hier bei der Überladung. Überladungen sind nicht Teil der IEC 61131-3. Aufrufsyntax : <TO_<Zieltyp> ( <Operand> ) Operand Datentyp Beschreibung Variable, Literal Standarddatentyp DatentypenÜberladungsoperatoren TO_<Zieldatentyp> Operator Beispiel Rückgabewert Beschreibung TO___UXINT TO___UXINT(123.4) 123 __UXINT, __XINT, __XWORDTO___XINT TO___UXINT(123.4) 123 __UXINT, __XINT, __XWORDTO___XWORD __UXINT, __XINT, __XWORDTO_BIT BITTO_BOOL TO_BOOL(0.001) TRUE BOOLTO_BYTE IntegerTO_DATE Syntax: D#jjjj-MM-dd, DATE#jjjj-MM-dd Datentyp: DATETO_DATE_AND_TIME TO_DT TO_DT(0) DT##1970-1-1-0:0:0 Syntax: DT#jjjj-MM-dd-hh:mm:ss, DATE_AND_TIME#jjjj-MM-dd-hh:mm:ss Datentyp: DATETO_DINT IntegerTO_DWORD IntegerTO_INT TO_INT(4.22) TO_INT(123.4) 4 123 IntegerTO_LDATE Syntax: LDATE#jjjj-MM-dd Datentyp: DATETO_LDT Syntax: LDT#jjj-MM-dd-hh:mm:ss.sss Datentyp: DATETO_LINT IntegerTO_LREAL REAL, LREALTO_LTIME Datentyp: TIME, LTIMETO_LTOD Syntax: LTOD#hh:mm:ss.sssssssss Datentyp: DATETO_LWORD IntegerTO_REAL REAL, LREALTO_SINT IntegerTO_STRING TO_STRING(342) '342' STRINGTO_TIME TO_TIME(SysTimeGetMs()) Systemzeit Datentyp: TIME, LTIMETO_TOD Datentyp: DATETO_UDINT IntegerTO_UINT TO_UINT(D#2019-9-3) 44288 IntegerTO_ULINT IntegerTO_USINT IntegerTO_WORD IntegerTO_WSTRING TO_WSTRING('Hello World') \"Hello World!\" WSTRING" }, 
{ "title" : "Konvertierung BOOL ", 
"url" : "_cds_operator_bool_to-2023061.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Konvertierung BOOL ", 
"snippet" : "BOOL Die Operatoren BOOL_TO_<Typ> konvertieren einen booleschen Wert in den angegebenen Datentypen und geben einen typkonvertierten Wert zurück. Aufrufsyntax : < BOOL_TO_<Typ> ( <Operand> ) Operand Datentyp Beschreibung Variable, Literal BOOL Operatoren BOOL_TO_<Typ> Operator Beispiel Rückgabewert B...", 
"body" : "BOOL Die Operatoren BOOL_TO_<Typ> konvertieren einen booleschen Wert in den angegebenen Datentypen und geben einen typkonvertierten Wert zurück. Aufrufsyntax : < BOOL_TO_<Typ> ( <Operand> ) Operand Datentyp Beschreibung Variable, Literal BOOL Operatoren BOOL_TO_<Typ> Operator Beispiel Rückgabewert Beschreibung BOOL_TO___UXINT BOOL_TO___UXINT(TRUE) 1 __UXINT, __XINT, __XWORDBOOL_TO___XINT BOOL_TO___XINT(TRUE) 1 __UXINT, __XINT, __XWORDBOOL_TO___XWORD BOOL_TO___XWINT(TRUE) 1 __UXINT, __XINT, __XWORDBOOL_TO_BIT BOOL_TO___BIT(TRUE) TRUE BITBOOL_TO_BYTE BOOL_TO_BYTE(TRUE) 1 IntegerBOOL_TO_DATE BOOL_TO_DATE(TRUE) D#1970-1-1 Das nullte Bit ist gesetzt, hat aber keine Auswirkungen auf die Anzeige. Datentyp: DATEBOOL_TO_DINT BOOL_TO_DINT(TRUE) 1 IntegerBOOL_TO_DT BOOL_TO_DT(TRUE) DT#1970-01-01-0:0:1 Datentyp: DATEBOOL_TO_DWORD BOOL_TO_DWORD(TRUE) 1 IntegerBOOL_TO_INT BOOL_TO_INT(TRUE) 1 IntegerBOOL_TO_LDATE BOOL_TO_LDATE(TRUE) LD#1970-01-01 Das nullte Bit ist gesetzt, hat aber keine Auswirkungen auf die Anzeige. Datentyp: DATEBOOL_TO_LDT BOOL_TO_LD(TRUE) DT#1970-01-01-0:0:1 Datentyp: DATEBOOL_TO_LINT BOOL_TO_LINT(TRUE) 1 IntegerBOOL_TO_LREAL BOOL_TO_LREAL(TRUE) 1 REAL, LREALBOOL_TO_LTIME BOOL_TO_LTIME(TRUE) LTIME#1NS Datentyp: DATEBOOL_TO_LTOD BOOL_TO_LTOD(TRUE) LTOD#0:0:0.000000001 Datentyp: DATEBOOL_TO_LWORD BOOL_TO_LWORD(TRUE) 1 IntegerBOOL_TO_REAL BOOL_TO_REAL(TRUE) 1 REAL, LREALBOOL_TO_SINT BOOL_TO_SINT(TRUE) 1 IntegerBOOL_TO_STRING BOOL_TO_STRING(TRUE) 'TRUE' STRINGBOOL_TO_TIME BOOL_TO_TIME(TRUE) T#1ms Datentyp: DATEBOOL_TO_TOD BOOL_TO_TOD(TRUE) TOD#0:0:0.001 Datentyp: DATEBOOL_TO_UDINT BOOL_TO_UDINT(TRUE) 1 IntegerBOOL_TO_UINT BOOL_TO_UINT(TRUE) 1 IntegerBOOL_TO_ULINT BOOL_TO_ULINT(TRUE) 1 IntegerBOOL_TO_USINT BOOL_TO_ULSINT(TRUE) 1 IntegerBOOL_TO_WORD BOOL_TO_WORD(TRUE) 1 IntegerBOOL_TO_WSTRING BOOL_TO_WSTRING(TRUE) \"TRUE\" WSTRING" }, 
{ "title" : "Beispiel ", 
"url" : "_cds_operator_bool_to-2023061.html#UUID-682020e5-0008-f30f-f004-09c97f2d0715_UUID-7cb488ce-e3ad-80d5-81d9-c44c2ef838fa_id_a353abc1de5f9c0a8640e006e95fc_id_a764924bfc35ef1cc0a8646370e2d8a1", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Konvertierung BOOL \/ Beispiel ", 
"snippet" : "FB_ConvertFromBool Deklaration in ST FUNCTION_BLOCK FB_ConvertFromBool VAR uxiReturn_1: __UXINT; uxiReturn_10: __UXINT; iReturn_2: __XINT; iReturn_20: __XINT; xwReturn_3: __XWORD; xwReturn_30: __XWORD; bitReturn_4: BOOL; bitReturn_40: BOOL; bReturn_6: BYTE; bReturn_60: BYTE; dateReturn_7: DATE; date...", 
"body" : "FB_ConvertFromBool Deklaration in ST FUNCTION_BLOCK FB_ConvertFromBool\nVAR\n uxiReturn_1: __UXINT;\n uxiReturn_10: __UXINT;\n iReturn_2: __XINT;\n iReturn_20: __XINT;\n xwReturn_3: __XWORD;\n xwReturn_30: __XWORD;\n bitReturn_4: BOOL;\n bitReturn_40: BOOL;\n bReturn_6: BYTE;\n bReturn_60: BYTE;\n dateReturn_7: DATE;\n dateReturn_70: DATE;\n dtReturn_8: DATE_AND_TIME;\n dtReturn_80: DATE_AND_TIME;\n diReturn_9: DINT;\n diReturn_90: DINT;\n dtReturn_10: DATE_AND_TIME;\n dtReturn_100: DATE_AND_TIME;\n dwReturn_11: DWORD;\n dwReturn_110: DWORD;\n iReturn_12: INT;\n iReturn_120: INT;\n liReturn_13: LINT;\n liReturn_130: LINT;\n lrReturn_14: LREAL;\n lrReturn_140: LREAL;\n lwReturn_15: LWORD;\n lwReturn_150: LWORD;\n rReturn_16: REAL;\n rReturn_160: REAL;\n siReturn_17: SINT;\n siReturn_170: SINT;\n sReturn_18: STRING;\n sReturn_180: STRING;\n todReturn_19: TIME_OF_DAY;\n todReturn_190: TIME_OF_DAY;\n timReturn_20: TIME;\n timReturn_200: TIME;\n todReturn_21: TIME_OF_DAY;\n todReturn_210: TIME_OF_DAY;\n udiReturn_22: UDINT;\n udiReturn_220: UDINT;\n uiReturn_23: UINT;\n uiReturn_230: UINT;\n uliReturn_24: ULINT;\n uliReturn_240: ULINT;\n usiReturn_25: USINT;\n usiReturn_250: USINT;\n wReturn_26: WORD;\n wReturn_260: WORD;\n wsReturn_27: WSTRING;\n wsReturn_270: WSTRING;\nEND_VAR\n Implementierung in ST FUNCTION_BLOCK FB_ConvertFromBool\nVAR\nVAR\n uxiReturn_1: __UXINT;\n uxiReturn_10: __UXINT;\n iReturn_2: __XINT;\n iReturn_20: __XINT;\n xwReturn_3: __XWORD;\n xwReturn_30: __XWORD;\n bitReturn_4: BOOL;\n bitReturn_40: BOOL;\n bReturn_6: BYTE;\n bReturn_60: BYTE;\n dateReturn_7: DATE;\n dateReturn_70: DATE;\n dtReturn_8: DATE_AND_TIME;\n dtReturn_80: DATE_AND_TIME;\n diReturn_9: DINT;\n diReturn_90: DINT;\n dtReturn_10: DATE_AND_TIME;\n dtReturn_100: DATE_AND_TIME;\n dwReturn_11: DWORD;\n dwReturn_110: DWORD;\n iReturn_12: INT;\n iReturn_120: INT;\n liReturn_13: LINT;\n liReturn_130: LINT;\n lrReturn_14: LREAL;\n lrReturn_140: LREAL;\n lwReturn_15: LWORD;\n lwReturn_150: LWORD;\n rReturn_16: REAL;\n rReturn_160: REAL;\n siReturn_17: SINT;\n siReturn_170: SINT;\n sReturn_18: STRING;\n sReturn_180: STRING;\n todReturn_19: TIME_OF_DAY;\n todReturn_190: TIME_OF_DAY;\n timReturn_20: TIME;\n timReturn_200: TIME;\n todReturn_21: TIME_OF_DAY;\n todReturn_210: TIME_OF_DAY;\n udiReturn_22: UDINT;\n udiReturn_220: UDINT;\n uiReturn_23: UINT;\n uiReturn_230: UINT;\n uliReturn_24: ULINT;\n uliReturn_240: ULINT;\n usiReturn_25: USINT;\n usiReturn_250: USINT;\n wReturn_26: WORD;\n wReturn_260: WORD;\n wsReturn_27: WSTRING;\n wsReturn_270: WSTRING;\nEND_VAR\n\n\/\/ Return value of operand = TRUE or FALSE\nuxiReturn_1 := BOOL_TO___UXINT(TRUE);\nuxiReturn_10 := BOOL_TO___UXINT(FALSE);\n\niReturn_2 := BOOL_TO___XINT(TRUE);\niReturn_20 := BOOL_TO___XINT(FALSE);\n\nxwReturn_3 := BOOL_TO___XWORD(TRUE);\nxwReturn_30 := BOOL_TO___XWORD(FALSE);\n\nbitReturn_4 := BOOL_TO_BIT(TRUE);\nbitReturn_40 := BOOL_TO_BIT(FALSE);\n\nbReturn_6 := BOOL_TO_BYTE(TRUE);\nbReturn_60 := BOOL_TO_BYTE(FALSE);\n\ndateReturn_7 := BOOL_TO_DATE(TRUE);\ndateReturn_70 := BOOL_TO_DATE(FALSE);\n\ndtReturn_8 := BOOL_TO_DT(TRUE);\ndtReturn_80 := BOOL_TO_DT(FALSE);\n\ndiReturn_9 := BOOL_TO_DINT(TRUE);\ndiReturn_90 := BOOL_TO_DINT(FALSE);\n\ndwReturn_11 := BOOL_TO_DWORD(TRUE);\ndwReturn_110 := BOOL_TO_DWORD(FALSE);\n\niReturn_12 := BOOL_TO_INT(TRUE);\niReturn_120 := BOOL_TO_INT(FALSE);\n\nliReturn_13 := BOOL_TO_LINT(TRUE);\nliReturn_130 := BOOL_TO_LINT(FALSE);\n\nlrReturn_14 := BOOL_TO_LREAL(TRUE);\nlrReturn_140 := BOOL_TO_LREAL(FALSE);\n\nlwReturn_15 := BOOL_TO_LWORD(TRUE);\nlwReturn_150 := BOOL_TO_LWORD(FALSE);\n\nrReturn_16 := BOOL_TO_REAL(TRUE);\nrReturn_160 := BOOL_TO_REAL(FALSE);\n\nsiReturn_17 := BOOL_TO_SINT(TRUE);\nsiReturn_170 := BOOL_TO_SINT(FALSE);\n\nsReturn_18 := BOOL_TO_STRING(TRUE);\nsReturn_180 := BOOL_TO_STRING(FALSE);\n\ntimReturn_20 := BOOL_TO_TIME(TRUE);\ntimReturn_200 := BOOL_TO_TIME(FALSE);\n\ntodReturn_21 := BOOL_TO_TOD(TRUE);\ntodReturn_210 := BOOL_TO_TOD(FALSE);\n\nudiReturn_22 := BOOL_TO_UDINT(TRUE);\nudiReturn_220 := BOOL_TO_UDINT(FALSE);\n\nuiReturn_23 := BOOL_TO_UINT(TRUE);\nuiReturn_230 := BOOL_TO_UINT(FALSE);\n\nuliReturn_24 := BOOL_TO_ULINT(TRUE);\nuliReturn_240 := BOOL_TO_ULINT(FALSE);\n\nusiReturn_25 := BOOL_TO_USINT(TRUE);\nusiReturn_250 := BOOL_TO_USINT(FALSE);\n\nwReturn_26 := BOOL_TO_WORD(TRUE);\nwReturn_260 := BOOL_TO_WORD(FALSE);\n\nwsReturn_27 := BOOL_TO_WSTRING(TRUE);\nwsReturn_270 := BOOL_TO_WSTRING(FALSE); FB_FbdConvertBool Implementierungssprache FUP " }, 
{ "title" : "Konvertierung Integer ", 
"url" : "_cds_operator_convert_integer.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Konvertierung Integer ", 
"snippet" : "Integer Die Operatoren konvertieren einen ganzzahligen Wert in den Zieltyp und geben einen typkonvertierten Wert zurück. Wenn die zu konvertierende Zahl die Bereichsgrenze überschreitet, werden die ersten Bytes der Zahl ignoriert. Aufrufsyntax : <Integertyp>_TO_<Standardtyp> ( <Operand> ) Operand Da...", 
"body" : "Integer Die Operatoren konvertieren einen ganzzahligen Wert in den Zieltyp und geben einen typkonvertierten Wert zurück. Wenn die zu konvertierende Zahl die Bereichsgrenze überschreitet, werden die ersten Bytes der Zahl ignoriert. Aufrufsyntax : <Integertyp>_TO_<Standardtyp> ( <Operand> ) Operand Datentyp Beschreibung Variable, Literal __UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT |STRING | TIME | TOD | TIME_OF_DAY | UDINT | UINT | ULINT | USINT | WORD | WSTRING IntegerSTRING, WSTRINGOperatoren <Integertyp>_TO_<Standardtyp> (Matrix) __UXINT __XINT __XWORD BIT BYTE DINT DWORD INT LINT LWORD SINT UDINT UINT ULINT USINT WORD __UXINT - __XINT_TO___UXINT __XWORD_TO_UXINT BIT_TO___UXINT BYTE_TO___UXINT DINT_TO___UXINT DWORD_TO___UXINT INT_TO___UXINT LINT_TO___UXINT LWORD_TO___UXINT SINT_TO___UXINT UDINT_TO___UXINT UINT_TO___UXINT ULINT_TO___UXINT USINT_TO___XINT WORD_TO___XINT __XINT __UXINT_TO___XINT - __XWORD_TO_XINT BIT_TO___XINT BYTE_TO___XINT DINT_TO___XINT DWORD_TO___XINT INT_TO___XINT LINT_TO___XINT LWORD_TO___XINT SINT_TO___XINT UDINT_TO___XINT UINT_TO___XINT ULINT_TO___XINT USINT_TO___XINT WORD_TO___XINT __XWORD __UXINT_TO___XWORD __XINT_TO___XWORD - BIT_TO___XWORD BYTE_TO___XWORD DINT_TO___XWORD DWORD_TO___XWORD INT_TO___XWORD LINT_TO___XWORD LWORD_TO___XWORD SINT_TO___XWORD UDINT_TO___XWORD UINT_TO___XWORD ULINT_TO___XWORD USINT_TO___XWORD WORD_TO___XWORD BIT __UXINT_TO_BIT __XINT_TO_BIT __XWORD_TO_BIT - BYTE_TO_BIT DINT_TO_BIT DWORD_TO_BIT INT_TO_BIT LINT_TO_BIT LWORD_TO_BIT SINT_TO_BIT UDINT_TO_BIT UINT_TO_BIT ULINT_TO_BIT USINT_TO_BIT WORD_TO_BIT BOOL __UXINT_TO_BOOL __XINT_TO_BOOL __XWORD_TO_BOOL BIT_TO_BOOL BYTE_TO_BOOL DINT_TO_BOOL DWORD_TO_BOOL INT_TO_BOOL LINT_TO_BOOL LWORD_TO_BOOL SINT_TO_BOOL UDINT_TO_BOOL UINT_TO_BOOL ULINT_TO_BOOL USINT_TO_BOOL WORD_TO_BOOL Byte __UXINT_TO_BYTE __XINT_TO_BYTE __XWORD_TO_BYTE BIT_TO_BYTE - DINT_TO_BYTE DWORD_TO_BYTE INT_TO_BYTE LINT_TO_BYTE LWORD_TO_BYTE SINT_TO_BYTE UDINT_TO_BYTE UINT_TO_BYTE ULINT_TO_BYTE USINT_TO_BYTE WORD_TO_BYTE DATE __UXINT_TO_DATE __XINT_TO_DATE __XWORD_TO_DATE BIT_TO_DATE BYTE_TO_DATE DINT_TO_DATE DWORD_TO_DATE INT_TO_DATE LINT_TO_DATE LWORD_TO_DATE SINT_TO_DATE UDINT_TO_DATE UINT_TO_DATE ULINT_TO_DATE USINT_TO_DATE WORD_TO_DATE DINT __UXINT_TO_DINT __XINT_TO_DINT __XWORD_TO_DINT BIT_TO_DINT BYTE_TO_DINT - DWORD_TO_DINT INT_TO_DINT LINT_TO_DINT LWORD_TO_DINT SINT_TO_DINT UDINT_TO_DINT UINT_TO_DINT ULINT_TO_DINT USINT_TO_DINT WORD_TO_DINT DT __UXINT_TO_DT __XINT_TO_DT __XWORD_TO_DT BIT_TO_DT BYTE_TO_DT DINT_TO_DT DWORD_TO_DT INT_TO_DT LINT_TO_DT LWORD_TO_DT SINT_TO_DT UDINT_TO_DT UINT_TO_DT ULINT_TO_DT USINT_TO_DT WORD_TO_DT DWORD __UXINT_TO_DWORD __XINT_TO_DWORD __XWORD_TO_DWORD BIT_TO_DWORD BYTE_TO_DWORD DINT_TO_DWORD - INT_TO_DWORD LINT_TO_DWORD LWORD_TO_DWORD SINT_TO_DWORD UDINT_TO_DWORD UINT_TO_DWORD ULINT_TO_DWORD USINT_TO_DWORD WORD_TO_DWORD INT __UXINT_TO_INT __XINT_TO_INT __XWORD_TO_INT BIT_TO_INT BYTE_TO_INT DINT_TO_INT DWORD_TO_INT - LINT_TO_INT LWORD_TO_INT SINT_TO_INT UDINT_TO_INT UINT_TO_INT ULINT_TO_INT USINT_TO_INT WORD_TO_INT LDATE __UXINT_TO_LDATE __XINT_TO_LDATE __XWORD_TO_LDATE BIT_TO_LDATE BYTE_TO_LDATE DINT_TO_LDATE DWORD_TO_LDATE INT_TO_LDATE LINT_TO_LDATE LWORD_TO_LDATE SINT_TO_LDATE UDINT_TO_LDATE UINT_TO_LDATE ULINT_TO_LDATE USINT_TO_LDATE WORD_TO_LDATE LDT __UXINT_TO_LDT __XINT_TO_LDT __XWORD_TO_LDT BIT_TO_LDT BYTE_TO_LDT DINT_TO_LDT DWORD_TO_LDT INT_TO_LDT LINT_TO_LDT LWORD_TO_LDT SINT_TO_LDT UDINT_TO_LDT UINT_TO_LDT ULINT_TO_LDT USINT_TO_LDT WORD_TO_LDT LINT __UXINT_TO_LINT __XINT_TO_LINT __XWORD_TO_LINT BIT_TO_LINT BYTE_TO_LINT DINT_TO_LINT DWORD_TO_LINT INT_TO_LINT - LWORD_TO_LINT SINT_TO_LINT UDINT_TO_LINT UINT_TO_LINT ULINT_TO_LINT USINT_TO_LINT WORD_TO_LINT LREAL __UXINT_TO_LREAL __XINT_TO_LREAL __XWORD_TO_LREAL BIT_TO_LREAL BYTE_TO_LREAL DINT_TO_LREAL DWORD_TO_LREAL INT_TO_LREAL LINT_TO_LREAL LWORD_TO_LREAL SINT_TO_LREAL UDINT_TO_LREAL UINT_TO_LREAL ULINT_TO_LREAL USINT_TO_LREAL WORD_TO_LREAL LTIME __UXINT_TO_LTIME __XINT_TO_LTIME __XWORD_TO_LTIME BIT_TO_LTIME BYTE_TO_LTIME DINT_TO_LTIME DWORD_TO_LTIME INT_TO_LTIME LINT_TO_LTIME LWORD_TO_LTIME SINT_TO_LTIME UDINT_TO_LTIME UINT_TO_LTIME ULINT_TO_LTIME USINT_TO_LTIME WORD_TO_LTIME LTOD __UXINT_TO_LTOD __XINT_TO_LTOD __XWORD_TO_LTOD BIT_TO_LTOD BYTE_TO_LTOD DINT_TO_LTOD DWORD_TO_LTOD INT_TO_LTOD LINT_TO_LTOD LWORD_TO_LTOD SINT_TO_LTOD UDINT_TO_LTOD UINT_TO_LTOD ULINT_TO_LTOD USINT_TO_LTOD WORD_TO_LTOD LWORD __UXINT_TO_LWORD __XINT_TO_LWORD __XWORD_TO_LWORD BIT_TO_LWORD BYTE_TO_LWORD DINT_TO_LWORD DWORD_TO_LWORD INT_TO_LWORD LINT_TO_LWORD - SINT_TO_LWORD UDINT_TO_LWORD UINT_TO_LWORD ULINT_TO_LWORD USINT_TO_LWORD WORD_TO_LWORD REAL __UXINT_TO_REAL __XINT_TO_REAL __XWORD_TO_REAL BIT_TO_REAL BYTE_TO_REAL DINT_TO_REAL DWORD_TO_REAL INT_TO_REAL LINT_TO_REAL LWORD_TO_REAL SINT_TO_REAL UDINT_TO_REAL UINT_TO_REAL ULINT_TO_REAL USINT_TO_REAL WORD_TO_REAL SINT __UXINT_TO_SINT __XINT_TO_SINT __XWORD_TO_SINT BIT_TO_SINT BYTE_TO_SINT DINT_TO_SINT DWORD_TO_SINT INT_TO_SINT LINT_TO_SINT LWORD_TO_SINT - UDINT_TO_SINT UINT_TO_SINT ULINT_TO_SINT USINT_TO_SINT WORD_TO_SINT STRING __UXINT_TO_STRING __XINT_TO_STRING __XWORD_TO_STRING BIT_TO_STRING BYTE_TO_STRING DINT_TO_STRING DWORD_TO_STRING INT_TO_STRING LINT_TO_STRING LWORD_TO_STRING SINT_TO_STRING UDINT_TO_STRING UINT_TO_STRING ULINT_TO_STRING USINT_TO_STRING WORD_TO_STRING TIME __UXINT_TO_TIME __XINT_TO_TIME __XWORD_TO_TIME BIT_TO_TIME BYTE_TO_TIME DINT_TO_TIME DWORD_TO_TIME INT_TO_TIME LINT_TO_TIME LWORD_TO_TIME SINT_TO_TIME UDINT_TO_TIME UINT_TO_TIME ULINT_TO_TIME USINT_TO_TIME WORD_TO_TIME TOD __UXINT_TO_TOD __XINT_TO_TOD __XWORD_TO_TOD BIT_TO_TOD BYTE_TO_TOD DINT_TO_TOD DWORD_TO_TOD INT_TO_TOD LINT_TO_TOD LWORD_TO_TOD SINT_TO_TOD UDINT_TO_TOD UINT_TO_TOD ULINT_TO_TOD USINT_TO_TOD WORD_TO_TOD UDINT __UXINT_TO_UDINT __XINT_TO_UDINT __XWORD_TO_UDINT BIT_TO_UDINT BYTE_TO_UDINT DINT_TO_UDINT DWORD_TO_UDINT INT_TO_UDINT LINT_TO_UDINT LWORD_TO_UDINT SINT_TO_UDINT - UINT_TO_UDINT ULINT_TO_UDINT USINT_TO_UDINT WORD_TO_UDINT UINT __UXINT_TO_UINT __XINT_TO_UINT __XWORD_TO_UINT BIT_TO_UINT BYTE_TO_UINT DINT_TO_UINT DWORD_TO_UINT INT_TO_UINT LINT_TO_UINT LWORD_TO_UINT SINT_TO_UINT UDINT_TO_UINT - ULINT_TO_UINT USINT_TO_UINT WORD_TO_UINT ULINT __UXINT_TO_ULINT __XINT_TO_ULINT __XWORD_TO_ULINT BIT_TO_ULINT BYTE_TO_ULINT DINT_TO_ULINT DWORD_TO_ULINT INT_TO_ULINT LINT_TO_ULINT LWORD_TO_ULINT SINT_TO_ULINT UDINT_TO_ULINT UINT_TO_ULINT - USINT_TO_ULINT WORD_TO_ULINT USINT __UXINT_TO_USINT __XINT_TO_USINT __XWORD_TO_USINT BIT_TO_USINT BYTE_TO_USINT DINT_TO_USINT DWORD_TO_USINT INT_TO_USINT LINT_TO_USINT LWORD_TO_USINT SINT_TO_USINT UDINT_TO_USINT UINT_TO_USINT ULINT_TO_USINT - WORD_TO_USINT WORD __UXINT_TO_WORD __XINT_TO_WORD __XWORD_TO_WORD BIT_TO_WORD BYTE_TO_WORD DINT_TO_WORD DWORD_TO_WORD INT_TO_WORD LINT_TO_WORD LWORD_TO_WORD SINT_TO_WORD UDINT_TO_WORD UINT_TO_WORD ULINT_TO_WORD USINT_TO_WORD - WSTRING __UXINT_TO_WSTRING __XINT_TO_WSTRING __XWORD_TO_WSTRING BIT_TO_WSTRING BYTE_TO_WSTRING DINT_TO_WSTRING DWORD_TO_WSTRING INT_TO_WSTRING LINT_TO_WSTRING LWORD_TO_WSTRING SINT_TO_WSTRING UDINT_TO_WSTRING UINT_TO_WSTRING ULINT_TO_WSTRING USINT_TO_WSTRING WORD_TO_WSTRING " }, 
{ "title" : "In einen String konvertieren ", 
"url" : "_cds_operator_convert_integer.html#UUID-c464d72e-00eb-40f2-a434-5347b8dfb565_UUID-b3638e7b-8068-7a4c-97c9-8f7221718057_id_a4835caebc899e35c0a8640e0071a02e_id_be3e4f6f29f3e031c0a8646345a1318e", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Konvertierung Integer \/ In einen String konvertieren ", 
"snippet" : "Die Operatoren, die einen Wert in eine Zeichenfolgen des Typs STRING oder WSTRING konvertieren, benötigen einen Operanden, der zum Zieldatentyp passt....", 
"body" : "Die Operatoren, die einen Wert in eine Zeichenfolgen des Typs STRING oder WSTRING konvertieren, benötigen einen Operanden, der zum Zieldatentyp passt. " }, 
{ "title" : "Beispiele ", 
"url" : "_cds_operator_convert_integer.html#UUID-c464d72e-00eb-40f2-a434-5347b8dfb565_UUID-b3638e7b-8068-7a4c-97c9-8f7221718057_section-idm4556665049587232791080776043", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Konvertierung Integer \/ Beispiele ", 
"snippet" : "Beispiel Funktionsbaustein ConvertIntegers Wenn ein größerer in einen kleineren Datentypen konvertiert wird, werden die höherwertigen (vorderen) Bytes abgeschnitten. Wenn ein kleinerer in einen größeren Datentypen konvertiert wird, werden die höherwertigen Bytes mit Nullen aufgefüllt. Deklaration in...", 
"body" : "Beispiel Funktionsbaustein ConvertIntegers Wenn ein größerer in einen kleineren Datentypen konvertiert wird, werden die höherwertigen (vorderen) Bytes abgeschnitten. Wenn ein kleinerer in einen größeren Datentypen konvertiert wird, werden die höherwertigen Bytes mit Nullen aufgefüllt. Deklaration in ST von FB_ConvertIntegersFromInt FUNCTION_BLOCK FB_ConvertIntegersFromInt\nVAR\n uxiReturn: __UXINT;\n xiReturn: __XINT;\n xwReturn: __XWORD;\n bitReturn: BIT;\n xReturn: BOOL;\n bReturn: BYTE;\n dateReturn: DATE;\n diReturn: DINT;\n dtReturn: DATE_AND_TIME;\n dwReturn: DWORD;\n liReturn: LINT;\n lrReturn: LREAL;\n lwReturn: LWORD;\n siReturn: SINT;\n sReturn: STRING;\n timReturn: TIME;\n todReturn: TIME_OF_DAY;\n udiReturn: UDINT;\n uiReturn: UINT;\n usiReturn: USINT;\n wReturn: WORD;\n wsReturn: WSTRING;\n uliReturn: ULINT;\nEND_VAR Implementierung in ST von FB_ConvertIntegersFromInt uxiReturn := INT_TO___UXINT(127);\nxiReturn := INT_TO___XINT(127);\nxwReturn := INT_TO___XWORD(127);\nbitReturn := INT_TO_BIT(127);\nxReturn := INT_TO_BOOL(127);\nbReturn := INT_TO_BYTE(127);\ndateReturn := INT_TO_DATE(127);\ndiReturn := INT_TO_DINT(127);\ndtReturn := INT_TO_DT(127);\ndwReturn := INT_TO_DWORD(127);\nliReturn := INT_TO_LINT(127);\nlrReturn := INT_TO_LREAL(127);\nlwReturn := INT_TO_LWORD(127);\nsiReturn := INT_TO_SINT(127);\nsReturn := INT_TO_STRING(127);\ntimReturn := INT_TO_TIME(127);\ntodReturn := INT_TO_TOD(127);\nudiReturn := INT_TO_UDINT(127);\nuiReturn := INT_TO_UINT(127);\nuliReturn := INT_TO_ULINT(127);\nusiReturn := INT_TO_USINT(127);\nwReturn := INT_TO_WORD(127);\nwsReturn := INT_TO_WSTRING(127); Deklaration in ST von FB_ConvertIntegersToInt FUNCTION_BLOCK FB_ConvertIntegersToInt\nVAR\n iReturn_uxi: INT;\n iReturn_xi: INT;\n iReturn_xw: INT;\n iReturn_bit: INT;\n iReturn_bool: INT;\n iReturn_b: INT;\n iReturn_d: INT;\n iReturn_di: INT;\n iReturn_dt: INT;\n iReturn_dw: INT;\n iReturn_li: INT;\n iReturn_lr: INT;\n iReturn_lw: INT;\n iReturn_r: INT;\n iReturn_si: INT;\n iReturn_s: INT;\n iReturn_tim: INT;\n iReturn_tod: INT;\n iReturn_tod_0: INT;\n iReturn_udi: INT;\n iReturn_ui: INT;\n iReturn_uli: INT;\n iReturn_usi: INT;\n iReturn_w: INT;\n iReturn_ws: INT;\nEND_VAR\n Implementierung in ST von FB_ConvertIntegersToInt FUNCTION_BLOCK FB_ConvertIntegersFromInt\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n uxiReturn: __UXINT;\n xiReturn: __XINT;\n xwReturn: __XWORD;\n bitReturn: BIT;\n xReturn: BOOL;\n bReturn: BYTE;\n dateReturn: DATE;\n diReturn: DINT;\n dtReturn: DATE_AND_TIME;\n dwReturn: DWORD;\n liReturn: LINT;\n lrReturn: LREAL;\n lwReturn: LWORD;\n siReturn: SINT;\n sReturn: STRING;\n timReturn: TIME;\n todReturn: TIME_OF_DAY;\n udiReturn: UDINT;\n uiReturn: UINT;\n usiReturn: USINT;\n wReturn: WORD;\n wsReturn: WSTRING;\n uliReturn: ULINT;\nEND_VAR\n\nuxiReturn := INT_TO___UXINT(127);\nxiReturn := INT_TO___XINT(127);\nxwReturn := INT_TO___XWORD(127);\nbitReturn := INT_TO_BIT(127);\nxReturn := INT_TO_BOOL(127);\nbReturn := INT_TO_BYTE(127);\ndateReturn := INT_TO_DATE(127);\ndiReturn := INT_TO_DINT(127);\ndtReturn := INT_TO_DT(127);\ndwReturn := INT_TO_DWORD(127);\nliReturn := INT_TO_LINT(127);\nlrReturn := INT_TO_LREAL(127);\nlwReturn := INT_TO_LWORD(127);\nsiReturn := INT_TO_SINT(127);\nsReturn := INT_TO_STRING(127);\ntimReturn := INT_TO_TIME(127);\ntodReturn := INT_TO_TOD(127);\nudiReturn := INT_TO_UDINT(127);\nuiReturn := INT_TO_UINT(127);\nuliReturn := INT_TO_ULINT(127);\nusiReturn := INT_TO_USINT(127);\nwReturn := INT_TO_WORD(127);\nwsReturn := INT_TO_WSTRING(127);\n\nFUNCTION_BLOCK FB_ConvertIntegersToInt\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iReturn_uxi: INT;\n iReturn_xi: INT;\n iReturn_xw: INT;\n iReturn_bit: INT;\n iReturn_bool: INT;\n iReturn_b: INT;\n iReturn_d: INT;\n iReturn_di: INT;\n iReturn_dt: INT;\n iReturn_dw: INT;\n iReturn_li: INT;\n iReturn_lr: INT;\n iReturn_lw: INT;\n iReturn_r: INT;\n iReturn_si: INT;\n iReturn_s: INT;\n iReturn_tim: INT;\n iReturn_tod: INT;\n iReturn_tod_0: INT;\n iReturn_udi: INT;\n iReturn_ui: INT;\n iReturn_uli: INT;\n iReturn_usi: INT;\n iReturn_w: INT;\n iReturn_ws: INT;\nEND_VAR\n\niReturn_uxi := __UXINT_TO_INT(18446744073709551615);\niReturn_xi := __XINT_TO_INT(9223372036854775807);\niReturn_xw := __XWORD_TO_INT(16#FFFF_FFFF_FFFF_FFFF);\niReturn_bit := BIT_TO_INT(1);\niReturn_bool := BOOL_TO_INT(TRUE);\niReturn_b := BYTE_TO_INT(2#1111_0000);\niReturn_d := DATE_TO_INT(DATE#2019-9-13);\niReturn_di := DINT_TO_INT(2147483647);\niReturn_dt := DT_TO_INT(DT#1979-1-1-00:00:00);\niReturn_dw := DWORD_TO_INT(16#FFFF_FFFF);\n\/\/ iReturn_i := INT_TO_<>(iData_12);\niReturn_li := LINT_TO_INT(9223372036854775807);\niReturn_lr := LREAL_TO_INT(1.7976931348623157E+30);\niReturn_lw := LWORD_TO_INT(16#FFFF_FFFF_FFFF_FFFF);\niReturn_r := REAL_TO_INT(3.402823E+38);\niReturn_si := SINT_TO_INT(127);\niReturn_s := STRING_TO_INT('127');\niReturn_tim := TIME_TO_INT(T#49D17H2M47S295MS);\niReturn_tod := TOD_TO_INT(TOD#23:59:59.999);\niReturn_tod_0 := TOD_TO_INT(TOD#1:1:1.001);\niReturn_udi := UDINT_TO_INT(4294967295);\niReturn_ui := UINT_TO_INT(65535);\niReturn_uli := ULINT_TO_INT(18446744073709551615);\niReturn_usi := USINT_TO_INT(255);\niReturn_w := WORD_TO_INT(16#FFFF);\niReturn_ws := WSTRING_TO_INT(\"1234567890\");\n\nPROGRAM PLC_PRG\nVAR\n fbConvertIntegersFromInt : FB_ConvertIntegersFromInt;\n fbConvertIntegersToInt : FB_ConvertIntegersToInt;\nEND_VAR\n\nfbConvertIntegersFromInt();\nfbConvertIntegersToInt(); Ausführung Beispiel ConvertIntegers in FUP " }, 
{ "title" : "Konvertierung REAL, LREAL ", 
"url" : "_cds_operator_real_to.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Konvertierung REAL, LREAL ", 
"snippet" : "REAL, LREAL Wenn die Gleitpunktzahl innerhalb des Wertebereichs des Zieldatentyps liegt, arbeitet die Konvertierung auf allen Systemen gleich. Wenn allerdings die Gleitpunktzahl die Bereichsgrenze überschreitet, werden die ersten Bytes der Zahl nicht berücksichtigt. Die Operatoren konvertieren eine ...", 
"body" : "REAL, LREAL Wenn die Gleitpunktzahl innerhalb des Wertebereichs des Zieldatentyps liegt, arbeitet die Konvertierung auf allen Systemen gleich. Wenn allerdings die Gleitpunktzahl die Bereichsgrenze überschreitet, werden die ersten Bytes der Zahl nicht berücksichtigt. Die Operatoren konvertieren eine Gleitpunktzahl in den angegebenen Datentypen und geben einen typkonvertierten Wert zurück. Bei der Konvertierung wird gegebenenfalls gerundet. Bei einer REAL_TO_<Zieltyp> -Konvertierung wird zuerst der Wert nach UDINT konvertiert und erst dann in den Zieltyp gecastet. Bei der LREAL_TO_<Zieltyp> -Konvertierung wird zuerst der Wert nach ULINT konvertiert und erst dann in den Zieltyp gecastet. Aufrufsyntax : REAL_TO_<Zieltyp> ( <Operand> ) , LREAL_TO_<Zieltyp> ( <Operand> ) Operand Typ Beschreibung Variable oder Literal REAL , LREAL REAL, LREALOperator REAL\/LREAL_TO_<Zieltyp> Operator REAL Operator LREAL Beispiel Rückgabewert REAL_TO___UXINT LREAL_TO___UXINT REAL_TO___UXINT(1.234) LREAL_TO___UXINT(0.987654321) 1 1 __UXINT, __XINT, __XWORDREAL_TO___XINT LREAL_TO___XINT __UXINT, __XINT, __XWORDREAL_TO___XWORD LREAL_TO___XWORD __UXINT, __XINT, __XWORDREAL_TO_BIT LREAL_TO_BIT BITREAL_TO_BOOL LREAL_TO_BOOL LREAL_TO_BOOL(0.987654321) TRUE BITREAL_TO_BYTE LREAL_TO_BYTE REAL_TO_BYTE(1.234) LREAL_TO_BYTE(0.987654321) 1 IntegerREAL_TO_DATE LREAL_TO_DATE REAL_TO_DATE(1.234) LREAL_TO_DATE(0.987654321) D#1970-1-1 Datentyp: DATEREAL_TO_DINT LREAL_TO_DINT REAL_TO_DINT(1.234) 1 IntegerREAL_TO_DT LREAL_TO_DT REAL_TO_DT(1.234) D#1970-1-1-0:0:1 Datentyp: DATEREAL_TO_DWORD LREAL_TO_DWORD REAL_TO_DWORD(1.234) 32#1 IntegerREAL_TO_INT LREAL_TO_INT REAL_TO_INT(-1.5) -2 IntegerREAL_TO_LDATE LREAL_TO_LDATE REAL_TO_LDATE(1.234) DT#1970-1-1 Intern wird zuerst nach ULINT gecastet und dann der Wert als Datum zurückgegeben. REAL_TO_LDT LREAL_TO_LDT LREAL_TO_DT(0.987654321) D#1970-1-1-0:0:1 Zieldatentyp LDATE_AND_TIME Datentyp: DATEREAL_TO_LINT LREAL_TO_LINT REAL_TO_LINT(1.234) 1 IntegerREAL_TO_LTOD LREAL_TO_LTOD Datentyp: DATEREAL_TO_LREAL - REAL_TO_LREAL(1.234) 1.234 REAL, LREALREAL_TO_LTIME LREAL_TO_LTIME Intern wird zuerst nach ULINT gecastet und dann der Wert in ns zurückgegeben. Datentyp: TIME, LTIMEREAL_TO_LWORD LREAL_TO_LWORD Integer- LREAL_TO_REAL REAL_TO_SINT LREAL_TO_SINT IntegerREAL_TO_STRING LREAL_TO_STRING REAL_TO_STRING(1.234) '1.234' STRINGREAL_TO_TIME LREAL_TO_TIME REAL_TO_TIME(1.234) T#1ms Intern wird zuerst nach UDINT gecastet und dann der Wert in ms zurückgegeben. Datentyp: TIME, LTIMEREAL_TO_TOD LREAL_TO_TOD REAL_TO_TOD(1.234) TOD#0:0:0.001 Intern wird zuerst nach UDINT gecastet und dann der Wert als TOD zurückgegeben. Syntax: TOD#hh:mm:ss.sss Datentyp: DATEREAL_TO_UDINT LREAL_TO_UDINT IntegerREAL_TO_UINT LREAL_TO_UINT IntegerREAL_TO_ULINT LREAL_TO_ULINT IntegerREAL_TO_USINT LREAL_TO_USINT IntegerREAL_TO__WORD LREAL_TO__WORD REAL_TO_WORD(1.2345678E11) 1 IntegerREAL_TO_WSTRING LREAL_TO_WSTRING REAL_TO_WSTRING(1.23456789E11) \"1.234\" WSTRING" }, 
{ "title" : "Runden ", 
"url" : "_cds_operator_real_to.html#UUID-09b58433-72d6-ced4-b25c-4160070bab9d_UUID-66c29c06-37d8-0602-04a7-7b5bcba80db6_id_a34c7ecbeec3bac0a8640e014adbad_id_d62d1f013f678288c0a864631fef9174", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Konvertierung REAL, LREAL \/ Runden ", 
"snippet" : "Bei der Konvertierung zu einer Integerzahl wird der Operand nach oben oder unten auf einen ganzzahligen Wert gerundet. Bei 1 bis 4 hinter dem Punkt wird abgerundet, bei 5 bis 9 wird aufgerundet. Dann wird die gerundete Zahl in den angegebenen Integertyp konvertiert. Im Fall, dass der gerundete Wert ...", 
"body" : "Bei der Konvertierung zu einer Integerzahl wird der Operand nach oben oder unten auf einen ganzzahligen Wert gerundet. Bei 1 bis 4 hinter dem Punkt wird abgerundet, bei 5 bis 9 wird aufgerundet. Dann wird die gerundete Zahl in den angegebenen Integertyp konvertiert. Im Fall, dass der gerundete Wert außerhalb des Wertebereichs des Integers liegt, wird ein undefinierter, zielsystem-abhängiger Wert zurückgegeben. Auch ein Ausnahmefehler ist dann möglich. " }, 
{ "title" : "Zu einem String konvertieren ", 
"url" : "_cds_operator_real_to.html#UUID-09b58433-72d6-ced4-b25c-4160070bab9d_UUID-66c29c06-37d8-0602-04a7-7b5bcba80db6_id_a34c7ecbeec3bac0a8640e014adbad_id_6cad15a820cf3bd8c0a864633b32def9", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Konvertierung REAL, LREAL \/ Zu einem String konvertieren ", 
"snippet" : "Bei einer Gleitpunktzahl-Konvertierung zu einem String ist die Anzahl der Nachkommastellen der Mantisse auf 6 begrenzt. Wenn die Zahl < 1 ist, gilt für die Mantisse m: 1 <= m < 10 . Wenn die Mantisse mehr Stellen hinter dem Komma hat, wird auf die 6. Stelle gerundet und dann konvertiert. Außerdem ka...", 
"body" : "Bei einer Gleitpunktzahl-Konvertierung zu einem String ist die Anzahl der Nachkommastellen der Mantisse auf 6 begrenzt. Wenn die Zahl < 1 ist, gilt für die Mantisse m: 1 <= m < 10 . Wenn die Mantisse mehr Stellen hinter dem Komma hat, wird auf die 6. Stelle gerundet und dann konvertiert. Außerdem kann die Stringvariable für den Rückgabewert zu kurz deklariert sein. Dann wird der Rückgabestring rechts abgeschnitten. Beispiel " }, 
{ "title" : "Konvertierung STRING, WSTRING ", 
"url" : "_cds_operator_string_to.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Konvertierung STRING, WSTRING ", 
"snippet" : "STRING, WSTRING Die Operatoren konvertieren eine Zeichenfolge ( STRING oder WSTRING ) in den angegebenen Zieldatentyp und geben einen typkonvertierten Wert zurück. Nur wenn der Operand entsprechend der Norm IEC 61131-3 zum Zieldatentyp passt, ist eine Konvertierung mit sinnvollem Ergebnis möglich. D...", 
"body" : "STRING, WSTRING Die Operatoren konvertieren eine Zeichenfolge ( STRING oder WSTRING ) in den angegebenen Zieldatentyp und geben einen typkonvertierten Wert zurück. Nur wenn der Operand entsprechend der Norm IEC 61131-3 zum Zieldatentyp passt, ist eine Konvertierung mit sinnvollem Ergebnis möglich. Das ist der Fall, wenn der Wert des Operanden einer gültigen Konstanten (Literal) des Zieldatentyps entspricht. Konvertierbare Strings enthalten: Zahl mit Typpräfix (Beispiel: '16#FFFFFFFF' ) Zahl mit Gruppierungszeichen (Beispiel: '2#1111_1111' ) Hinweis: Das internationale Gewichtungs- und Maßgruppierungszeichen (Thinspace) wird nicht akzeptiert, nur der Unterstrich. Gleitpunktzahl, auch in Exponentialschreibweise (Beispiel: '9.876' oder '1.2E-34' ) Hinnweis: Gleitkommazahlen sind nicht konvertierbar. Das Komma wird wie ein nachstehendes Zeichen behandelt und abgeschnitten. Zeit- Uhrzeit- und Datumsangabe mit Präfix und Größe (Beispiel: 'T#2h' , 'DT#2019-9-9-12:30:30.9' ) Infinite Werte (Beispiel: '1.7E+400' ) Zusätzliche Zeichen hinter einer Zahl (Beispiel: '2m' oder '3,14' ) Diese werden abgeschnitten. Zusätzliche Zeichen vor einer Zahl sind nicht erlaubt. Leerzeichen davor (Beispiel: '3.14' ) Aufrufsyntax : STRING_TO_<Zieltyp> ( <Operand> ) , WSTRING_TO_<Zieltyp> ( <Operand> ) Operand Datentyp Beschreibung Variable oder Literal STRING , WSTRING STRING, WSTRINGCasting-Operatoren STRING\/WSTRING_TO_<Zieltyp> Operator STRING Operator WSTRING Beispiel Rückgabewert Beschreibung  STRING_TO___UXINT WSTRING_TO___UXINT __UXINT, __XINT, __XWORD STRING_TO___XINT WSTRING_TO___XINT __UXINT, __XINT, __XWORD STRING_TO___XWORD WSTRING_TO___XWORD __UXINT, __XINT, __XWORD STRING_TO_BIT WSTRING_TO_BIT BITSTRING_TO_BOOL WSTRING_TO_BOOL STRING_TO_BOOL('TRUE') STRING_TO_BOOL('true') WSTRING_TO_BOOL(\"TRUE\") WSTRING_TO_BOOL(\"true\") TRUE BOOLSTRING_TO_BYTE WSTRING_TO_BYTE IntegerSTRING_TO_DATE WSTRING_TO_DATE STRING_TO_DATE('DATE#2019-9-9') WSTRING_TO_DATE(\"DATE#2019-9-9\") D#2019-9-9 Syntax: D#jjjj-MM-dd Datentyp: DATESTRING_TO_DINT WSTRING_TO_DINT Wenn der Ausgangsdatentyp größer ist, können Informationen verloren gehen. IntegerSTRING_TO_DT WSTRING_TO_DT STRING_TO_DT('DT#2019-9-9-1:1:1.1') WSTRING_TO_DT(\"DT#2019-9-9-1:1:1.1\") DT#2019-9-9-1:1:1 DT#2019-9-9-1:1:1 Syntax: DT#jjjj-MM-dd-hh:mm:ss Datentyp: DATESTRING_TO_DWORD WSTRING_TO_DWORD IntegerSTRING_TO_INT WSTRING_TO_INT STRING_TO_INT('123abc') WSTRING_TO_INT(\"123abc\") 123 IntegerSTRING_TO_LDATE WSTRING_TO_LDATE Syntax: LDATE#jjjj-MM-dd Angezeigt wird nur der Tag Datentyp: DATESTRING_TO_LDT WSTRING_TO_LDT Syntax: LDT#jjj-MM-dd-hh:mm:ss.sss Datentyp: DATESTRING_TO_LINT WSTRING_TO_LINT IntegerSTRING_TO_LREAL WSTRING_TO_LREAL STRING_TO_LREAL('1.7E+308') WSTRING_TO_LREAL(\"1.7E+308\") 1.7000000000000001E+308 REAL, LREALSTRING_TO_LTIME WSTRING_TO_LTIME STRING_TO_LTIME('LTIME#709ms551us615ns') STRING_TO_LTIME('LTIME#1ms') WSTRING_TO_LTIME(\"LTIME#1ms\") LTIME#709ms551us615ns LTIME#1ms Datentyp: TIME, LTIMESTRING_TO_LTOD WSTRING_TO_LTOD Syntax: LTOD#hh:mm:ss.sssssssss Datentyp: DATESTRING_TO_LWORD WSTRING_TO_LWORD STRING_TO_LWORD('16#0123456789ABCDEF') WSTRING_TO_LWORD(\"16#0123456789ABCDEF\") 81985529216486895 IntegerSTRING_TO_REAL WSTRING_TO_REAL STRING_TO_REAL('1.234') WSTRING_TO_REAL(\"1.234\") 1.234 Bei Konvertierungen aus einem größeren Wertebereich können Informationen verloren gehen oder ein undefiniertes Resultat zurückgegeben werden. REAL, LREALSTRING_TO_SINT WSTRING_TO_SINT Integer- WSTRING_TO_STRING WSTRING_TO_STRING(\"Hello World!\") 'Hello World!' STRING_TO_TIME WSTRING_TO_TIME STRING_TO_TIME('T#5d4h3m2s') WSTRING_TO_TIME(\"T#5d4h3m2s\") T#5d4h3m2s Datentyp: TIME, LTIMESTRING_TO_TOD WSTRING_TO_TOD STRING_TO_TOD('TOD#20:15') WSTRING_TO_TOD(\"TOD#20:15\") TOD#20:15:0 Datentyp: DATESTRING_TO_UDINT WSTRING_TO_UDINT IntegerSTRING_TO_UINT WSTRING_TO_UINT IntegerSTRING_TO_ULINT WSTRING_TO_ULINT STRING_TO_ULINT('615') WSTRING_TO_ULINT(\"615\") 615 IntegerSTRING_TO_USINT WSTRING_TO_USINT IntegerSTRING_TO_WORD WSTRING_TO_WORD IntegerSTRING_TO_WSTRING - STRING_TO_WSTRING('Hello World!') \"Hello World!\" WSTRING" }, 
{ "title" : "Konvertierung in einen booleschen Wert ", 
"url" : "_cds_operator_string_to.html#UUID-5ac2f0be-631a-851c-bdec-0e60611c4db1_UUID-fa2f799f-42c9-2838-9daf-a4b39b9aca2c_id_f500d27d07eb3bec0a8640e013e049a_id_7a13d4613f6786bbc0a864632e419b0d", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Konvertierung STRING, WSTRING \/ Konvertierung in einen booleschen Wert ", 
"snippet" : "Operator STRING_TO_BOOL : Nur wenn der Operandenwert 'TRUE' oder 'true' ist, wird ein TRUE zurückgegeben. Dagegen wird bei 'True' ein FALSE zurückgegeben. Operator WSTRING_TO_BOOL : Nur, wenn der Operandenwert \"TRUE\" oder \"true\" ist, wird ein TRUE zurückgegeben. Dagegen wird bei \"True\" ein FALSE zur...", 
"body" : "Operator STRING_TO_BOOL : Nur wenn der Operandenwert 'TRUE' oder 'true' ist, wird ein TRUE zurückgegeben. Dagegen wird bei 'True' ein FALSE zurückgegeben. Operator WSTRING_TO_BOOL : Nur, wenn der Operandenwert \"TRUE\" oder \"true\" ist, wird ein TRUE zurückgegeben. Dagegen wird bei \"True\" ein FALSE zurückgegeben. " }, 
{ "title" : "Beispiele ", 
"url" : "_cds_operator_string_to.html#UUID-5ac2f0be-631a-851c-bdec-0e60611c4db1_UUID-fa2f799f-42c9-2838-9daf-a4b39b9aca2c_id_f500d27d07eb3bec0a8640e013e049a_id_817822c5d48a11e9a9c394579cee6999", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Konvertierung STRING, WSTRING \/ Beispiele ", 
"snippet" : "FB_ConvertStrings Deklaration FUNCTION_BLOCK FB_ConvertStrings VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR xReturn_0: BOOL; xReturn_1: BOOL; dateReturn: DATE; dtReturn: DATE_AND_TIME; iReturn: INT; lrReturn: LREAL; lrReturn_0: LREAL; lwReturn: LWORD; lwReturn_0: LWORD; lwReturn_1: LWORD; ltReturn: LTIM...", 
"body" : "FB_ConvertStrings Deklaration FUNCTION_BLOCK FB_ConvertStrings\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n\t xReturn_0: BOOL;\n\txReturn_1: BOOL;\n\tdateReturn: DATE;\n\tdtReturn: DATE_AND_TIME;\n\tiReturn: INT;\n\tlrReturn: LREAL;\n\tlrReturn_0: LREAL;\n\tlwReturn: LWORD;\n\tlwReturn_0: LWORD;\n\tlwReturn_1: LWORD;\n\tltReturn: LTIME;\n\tltReturn_0: LTIME;\n\tltReturn_1: LTIME;\n\tltReturn_2: LTIME;\n\trReturn: REAL;\n\trReturn_0: REAL;\n\ttimReturn: TIME;\n\ttimReturn0: TIME;\n\ttimReturn1: TIME;\n\ttimReturn2: TIME;\n\ttodReturn: TIME_OF_DAY;\n\ttodReturn0: TIME_OF_DAY;\n\ttodReturn1: TIME_OF_DAY;\n\ttodReturn2: TIME_OF_DAY;\n\tuliReturn: ULINT;\n\tuliReturn_0: ULINT;\n\tuliReturn_1: ULINT;\n\twReturn: WORD;\n\twReturn_0: WORD;\n\twReturn_1: WORD;\n\twstrReturn: WSTRING;\n\twstrReturn_0: WSTRING;\n\tdtReturn2: DATE_AND_TIME;\nEND_VAR Implementierung FUNCTION_BLOCK FB_ConvertStrings\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n xReturn_0: BOOL;\n xReturn_1: BOOL;\n dateReturn: DATE;\n dtReturn: DATE_AND_TIME;\n iReturn: INT;\n lrReturn: LREAL;\n lrReturn_0: LREAL;\n lwReturn: LWORD;\n lwReturn_0: LWORD;\n lwReturn_1: LWORD;\n ltReturn: LTIME;\n ltReturn_0: LTIME;\n ltReturn_1: LTIME;\n ltReturn_2: LTIME;\n rReturn: REAL;\n rReturn_0: REAL;\n timReturn: TIME;\n timReturn0: TIME;\n timReturn1: TIME;\n timReturn2: TIME;\n todReturn: TIME_OF_DAY;\n todReturn0: TIME_OF_DAY;\n todReturn1: TIME_OF_DAY;\n todReturn2: TIME_OF_DAY;\n uliReturn: ULINT;\n uliReturn_0: ULINT;\n uliReturn_1: ULINT;\n wReturn: WORD;\n wReturn_0: WORD;\n wReturn_1: WORD;\n wstrReturn: WSTRING;\n wstrReturn_0: WSTRING;\nEND_VAR\nxReturn_0 := STRING_TO_BOOL('FALSE');\nxReturn_1 := STRING_TO_BOOL('TRUE');\ndateReturn := STRING_TO_DATE('DATE#2019-9-9');\ndtReturn := STRING_TO_DT('DT#2019-9-9-1:1:1.1');\niReturn := STRING_TO_INT('123abc');\nlrReturn := STRING_TO_LREAL('4.94E-323');\nlrReturn_0 := STRING_TO_LREAL('1.7E+308');\nlwReturn := STRING_TO_LWORD('16#FFFF_FFFF_FFFF_FFFF');\nlwReturn_0 := STRING_TO_LWORD('16#0123456789ABCDEF');\nlwReturn_1 := STRING_TO_LWORD('16#0123456789ABCDEF');\nltReturn := STRING_TO_LTIME('LTIME#213503d23h34m33s709ms551us615ns');\nltReturn_0 := STRING_TO_LTIME('LTIME#0ns');\nltReturn_1 := STRING_TO_LTIME('LTIME#1ms');\nltReturn_2 := STRING_TO_LTIME('LTIME#2s');\nrReturn := STRING_TO_REAL('6.543e21');\nrReturn_0 := STRING_TO_REAL('1.234');\ntimReturn := STRING_TO_TIME('T#5d4h3m2s');\ntimReturn0 := STRING_TO_TIME('TIME#1s');\ntimReturn1 := STRING_TO_TIME('1s');\ntimReturn2 := STRING_TO_TIME('TIME#5s');\ntodReturn := STRING_TO_TOD('TOD#12:0:0.1');\ntodReturn0 := STRING_TO_TOD('TOD#0:0:0.0');\ntodReturn1 := STRING_TO_TOD('20:15');\ntodReturn2 := STRING_TO_TOD('TOD#20:15');\nuliReturn := STRING_TO_ULINT('18446744073709551615');\nuliReturn_0 := STRING_TO_ULINT('1');\nuliReturn_1 := STRING_TO_ULINT('0');\nwReturn := STRING_TO_WORD('16#FFFF_0000');\nwReturn_0 := STRING_TO_WORD('34abc');\nwReturn_1 := STRING_TO_WORD('16#34abc');\nwstrReturn := STRING_TO_WSTRING('Hello World!');\nwstrReturn_0 := STRING_TO_WSTRING('123456789'); FB_ConvertWstrings in ST Deklaration FUNCTION_BLOCK FB_ConvertWstrings\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n\txReturn_0: BOOL;\n\txReturn_1: BOOL;\n\tdateReturn: DATE;\n\tdtReturn: DATE_AND_TIME;\n\tiReturn: INT;\n\tlrReturn: LREAL;\n\tlrReturn_0: LREAL;\n\tlwReturn: LWORD;\n\tlwReturn_0: LWORD;\n\tlwReturn_1: LWORD;\n\tltReturn: LTIME;\n\tltReturn_0: LTIME;\n\tltReturn_1: LTIME;\n\tltReturn_2: LTIME;\n\trReturn: REAL;\n\trReturn_0: REAL;\n\ttimReturn: TIME;\n\ttimReturn0: TIME;\n\ttimReturn1: TIME;\n\ttimReturn2: TIME;\n\ttodReturn: TIME_OF_DAY;\n\ttodReturn0: TIME_OF_DAY;\n\ttodReturn1: TIME_OF_DAY;\n\ttodReturn2: TIME_OF_DAY;\n\tuliReturn: ULINT;\n\tuliReturn_0: ULINT;\n\tuliReturn_1: ULINT;\n\twReturn: WORD;\n\twReturn_0: WORD;\n\twReturn_1: WORD;\n\twstrReturn: WSTRING;\n\twstrReturn_0: WSTRING;\nEND_VAR\n Implementierung in ST FUNCTION_BLOCK FB_ConvertWstrings\nVAR\n xReturn_0: BOOL;\n xReturn_1: BOOL;\n dateReturn: DATE;\n dtReturn: DATE_AND_TIME;\n iReturn: INT;\n lrReturn: LREAL;\n lrReturn_0: LREAL;\n lwReturn: LWORD;\n lwReturn_0: LWORD;\n lwReturn_1: LWORD;\n ltReturn: LTIME;\n ltReturn_0: LTIME;\n ltReturn_1: LTIME;\n ltReturn_2: LTIME;\n rReturn: REAL;\n rReturn_0: REAL;\n timReturn: TIME;\n timReturn0: TIME;\n timReturn1: TIME;\n timReturn2: TIME;\n todReturn: TIME_OF_DAY;\n todReturn0: TIME_OF_DAY;\n todReturn1: TIME_OF_DAY;\n todReturn2: TIME_OF_DAY;\n uliReturn: ULINT;\n uliReturn_0: ULINT;\n uliReturn_1: ULINT;\n wReturn: WORD;\n wReturn_0: WORD;\n wReturn_1: WORD;\n wstrReturn: WSTRING;\n wstrReturn_0: WSTRING;\nEND_VAR\n\nxReturn_0 := WSTRING_TO_BOOL(\"FALSE\");\nxReturn_1 := WSTRING_TO_BOOL(\"TRUE\");\ndateReturn := WSTRING_TO_DATE(\"DATE#2019-9-9\");\ndtReturn := WSTRING_TO_DT(\"DT#2019-9-9-1:1:1.1\");\niReturn := WSTRING_TO_INT(\"123abc\");\nlrReturn := WSTRING_TO_LREAL(\"4.94E-323\");\nlrReturn_0 := WSTRING_TO_LREAL(\"1.7E+308\");\nlwReturn := WSTRING_TO_LWORD(\"16#FFFF_FFFF_FFFF_FFFF\");\nlwReturn_0 := WSTRING_TO_LWORD(\"16#0123456789ABCDEF\");\nlwReturn_1 := WSTRING_TO_LWORD(\"16#0123456789ABCDEF\");\nltReturn := WSTRING_TO_LTIME(\"LTIME#213503d23h34m33s709ms551us615ns\");\nltReturn_0 := WSTRING_TO_LTIME(\"LTIME#0ns\");\nltReturn_1 := WSTRING_TO_LTIME(\"LTIME#1ms\");\nltReturn_2 := WSTRING_TO_LTIME(\"LTIME#2s\");\nrReturn := WSTRING_TO_REAL(\"6.543e21\");\nrReturn_0 := WSTRING_TO_REAL(\"1.234\");\ntimReturn := WSTRING_TO_TIME(\"T#5d4h3m2s\");\ntimReturn0 := WSTRING_TO_TIME(\"TIME#1s\");\ntimReturn1 := WSTRING_TO_TIME(\"1s\");\ntimReturn2 := WSTRING_TO_TIME(\"TIME#5s\");\ntodReturn := WSTRING_TO_TOD(\"TOD#12:0:0.1\");\ntodReturn0 := WSTRING_TO_TOD(\"TOD#0:0:0.0\");\ntodReturn1 := WSTRING_TO_TOD(\"20:15\");\ntodReturn2 := WSTRING_TO_TOD(\"TOD#20:15\");\nuliReturn := WSTRING_TO_ULINT(\"18446744073709551615\");\nuliReturn_0 := WSTRING_TO_ULINT(\"1\");\nuliReturn_1 := WSTRING_TO_ULINT(\"0\");\nwReturn := WSTRING_TO_WORD(\"16#FFFF_0000\");\nwReturn_0 := WSTRING_TO_WORD(\"34abc\");\nwReturn_1 := WSTRING_TO_WORD(\"16#34abc\"); Implementierungssprache FUP " }, 
{ "title" : "Konvertierung TIME, LTIME ", 
"url" : "_cds_operator_time_to.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Konvertierung TIME, LTIME ", 
"snippet" : "TIME, LTIME Die Operatoren konvertieren Zeitangaben ( TIME oder LIME ) in den angegebenen Datentypen und geben diesen typkonvertierten Wert zurück. Aufrufsyntax : <TIME_TO<Zieltyp> ( <Operand> ) , <LTIME_TO<Zieltyp> ( <Operand> ) Operand Datentyp Beschreibung Variable oder Literal TIME , LTIME Daten...", 
"body" : "TIME, LTIME Die Operatoren konvertieren Zeitangaben ( TIME oder LIME ) in den angegebenen Datentypen und geben diesen typkonvertierten Wert zurück. Aufrufsyntax : <TIME_TO<Zieltyp> ( <Operand> ) , <LTIME_TO<Zieltyp> ( <Operand> ) Operand Datentyp Beschreibung Variable oder Literal TIME , LTIME Datentyp: TIME, LTIMECasting-Operatoren TIME\/LTIME_TO_<Zieltyp> Operator Operator Beispiel Rückgabewert Beschreibung TIME_TO___UXINT LTIME_TO___UXINT __UXINT, __XINT, __XWORD TIME_TO___XINT LTIME_TO___XINT __UXINT, __XINT, __XWORD TIME_TO___XWORD LTIME_TO___XWORD __UXINT, __XINT, __XWORD TIME_TO_BIT LTIME_TO_BIT BITTIME_TO_BOOL LTIME_TO_BOOL TIME_TO_BOOL(T#0MS);\nTIME_TO_BOOL(T#59ms);\nLTIME_TO_BOOL(T#0MS);\nLTIME_TO_BOOL(T#59ms); FALSE TRUE Nur genau dann, wenn der Operandenwert als „0“ interpretiert werden kann, wird vom Operator ein FALSE zurückgegeben. BOOLTIME_TO_BYTE LTIME_TO_BYTE IntegerTIME_TO_DATE LTIME_TO_DATE LTIME_TO_DATE(LTIME#2us1ns); D#1970-1-1 Syntax: D#jjjj-MM-dd Datentyp: DATETIME_TO_DINT LTIME_TO_DINT TIME_TO_DT LTIME_TO_DT TIME_TO_DT(T#5d4h3m2s1ms);\nLTIME_TO_DT(LTIME#2us1ns); D#1970-1-1-0:0:0.000000012 Syntax: DT#jjjj-MM-dd-hh:mm:ss Datentyp: DATETIME_TO_DWORD LTIME_TO_DWORD IntegerTIME_TO_INT LTIME_TO_INT LTIME_TO_INT(LTIME#2us1ns); 0 IntegerTIME_TO_LDATE LTIME_TO_LDATE Syntax: LDATE#jjjj-MM-dd Datentyp: DATETIME_TO_LDT LTIME_TO_LDT Syntax: LDT#jjj-MM-dd-hh:mm:ss.sss Datentyp: DATETIME_TO_LINT LTIME_TO_LINT IntegerTIME_TO_LREAL LTIME_TO_LREAL TIME_TO_LREAL(T#5d4h3m2s1ms); x.x TIME_TO_LTIME - TIME_TO_LTOD LTIME_TO_LTOD Syntax: LTOD#hh:mm:ss.sssssssss Datentyp: DATETIME_TO_LWORD LTIME_TO_LWORD TIME_TO_LWORD(T#5d4h3m2s1ms);\nLTIME_TO_LWORD(LTIME#2us1ns); 0 IntegerTIME_TO_REAL LTIME_TO_REAL TIME_TO_REAL(T#1d2h3m4s5ms);\nLTIME_TO_REAL(LTIME#2us1ns); 9.28E+07 0.0 REAL, LREALTIME_TO_SINT LTIME_TO_SINT IntegerTIME_TO_STRING LTIME_TO_STRING TIME_TO_STRING(T#0MS); 'T#0MS' Wichtig: Der getypte Wert wird als Zeichenfolge linksbündig abgelegt und bei Überlänge abgeschnitten. Deklarieren Sie deshalb die Rückgabevariablen ausreichend lang, so dass die Zeichenfolge ohne Manipulation Platz findet. STRING- LTIME_TO_TIME LTIME_TO_TIME(LTIME#2us1ns); T#0ms Datentyp: TIME, LTIMETIME_TO_TOD LTIME_TO_TOD TIME_TO_TOD(T#1d2h3m4s5ms);\nLTIME_TO_TOD(LTIME#2us1ns);\n TOD#2:3:4.005 TOD#0:0:0 Datentyp: DATETIME_TO_UDINT LTIME_TO_UDINT IntegerTIME_TO_UINT LTIME_TO_UINT IntegerTIME_TO_ULINT LTIME_TO_ULINT TIME_TO_ULINT(T#1d2h3m4s5ms); 93784005 IntegerTIME_TO_USINT LTIME_TO_USINT IntegerTIME_TO_WORD LTIME_TO_WORD IntegerTIME_TO_WSTRING LTIME_TO_WSTRING TIME_TO_WSTRING(T#1d2h3m4s5ms);\nLTIME_TO_WSTRING(T#0US); \"T1d2h3m4s5ms\" \"T#0US\" Der getypte Wert wird als Zeichenfolge linksbündig abgelegt und bei Überlänge abgeschnitten. Deklarieren Sie deshalb die Rückgabevariablen ausreichend lang, so dass die Zeichenfolge ohne Manipulation Platz findet. WSTRING" }, 
{ "title" : "Beispiele ", 
"url" : "_cds_operator_time_to.html#UUID-d9d61e4b-1f08-f156-98e7-b50526508425_UUID-05a4d27d-06ae-5b64-4c72-be0a87863b24_id_f415c6acc0350d7c0a8640e00547f10_id_3dd96edd20dc20dcc0a8646366ed7fd7", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Konvertierung TIME, LTIME \/ Beispiele ", 
"snippet" : "FB_ConvertTimeAndDate Deklaration in ST FUNCTION_BLOCK FB_ConvertTimeAndDate VAR ltReturn_1: LTIME; lwReturn_2: LWORD; rReturn_3: REAL; strReturn_4: STRING; timReturn_5: TIME; todReturn_6: TIME_OF_DAY; uliReurn_7: ULINT; wstrReturn_8: WSTRING; wstrReturn_80: WSTRING; uliReurn_70: ULINT; todReturn_60...", 
"body" : "FB_ConvertTimeAndDate Deklaration in ST FUNCTION_BLOCK FB_ConvertTimeAndDate\nVAR\n ltReturn_1: LTIME;\n lwReturn_2: LWORD;\n rReturn_3: REAL;\n strReturn_4: STRING;\n timReturn_5: TIME;\n todReturn_6: TIME_OF_DAY;\n uliReurn_7: ULINT;\n wstrReturn_8: WSTRING;\n wstrReturn_80: WSTRING;\n uliReurn_70: ULINT;\n todReturn_60: TIME_OF_DAY;\n timReturn_50: TIME;\n strReturn_40: STRING;\n rReturn_30: REAL;\n lwReturn_20: LWORD;\n ltReturn_10: LTIME;\n ltReturn_11: LTIME;\n lwReturn_21: LWORD;\n rReturn_31: REAL;\n strReturn_41: STRING;\n timReturn_51: TIME;\n todRedurn_61: TIME_OF_DAY;\n uliReurn_71: ULINT;\n wstrReturn_81: WSTRING;\n ltReturn_12: LTIME;\n xReturn_9: BOOL;\n xReturn_90: BOOL;\n xReturn_91: BOOL;\n xReturn_92: BOOL;\n dateReturn_6: DATE;\n timReturn_60: TIME;\n wReturn_61: WORD;\n todReturn_61: TIME_OF_DAY;\nEND_VAR\n Implementierung in ST FUNCTION_BLOCK FB_ConvertTimeAndDate\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n ltReturn_1: LTIME;\n lwReturn_2: LWORD;\n rReturn_3: REAL;\n strReturn_4: STRING;\n timReturn_5: TIME;\n todReturn_6: TIME_OF_DAY;\n uliReurn_7: ULINT;\n wstrReturn_8: WSTRING;\n wstrReturn_80: WSTRING;\n uliReurn_70: ULINT;\n todReturn_60: TIME_OF_DAY;\n timReturn_50: TIME;\n strReturn_40: STRING;\n rReturn_30: REAL;\n lwReturn_20: LWORD;\n ltReturn_10: LTIME;\n ltReturn_11: LTIME;\n lwReturn_21: LWORD;\n rReturn_31: REAL;\n strReturn_41: STRING;\n timReturn_51: TIME;\n todRedurn_61: TIME_OF_DAY;\n uliReurn_71: ULINT;\n wstrReturn_81: WSTRING;\n ltReturn_12: LTIME;\n xReturn_9: BOOL;\n xReturn_90: BOOL;\n xReturn_91: BOOL;\n xReturn_92: BOOL;\n dateReturn_6: DATE;\n timReturn_60: TIME;\n wReturn_61: WORD;\n todReturn_61: TIME_OF_DAY;\nEND_VAR\n\nltReturn_1 := DT_TO_LTIME(DT#2019-9-9-23:59:59);\nltReturn_10 := DT_TO_LTIME(DT#1970-1-1-0:0:0);\nltReturn_11 := DT_TO_LTIME(DT#1970-1-2-0:0:1);\nltReturn_12 := DT_TO_LTIME(DT#1970-1-3-12:30:30);\n\nlwReturn_2 := TIME_TO_LWORD(T#5D4H2M3S2MS);\nlwReturn_20 := TIME_TO_LWORD(T#0D0H0M0S0MS);\n\nrReturn_3 := TIME_TO_REAL(T#5D4H2M3S2MS);\nrReturn_30 := TIME_TO_REAL(T#0D0H0M0S0MS);\n\nstrREturn_4 := TIME_TO_STRING(T#5D4H2M3S2MS);\nstrREturn_40 := TIME_TO_STRING(T#0D0H0M0S0MS);\n\ntimReturn_5 := TOD_TO_TIME(TOD#23:59:59.999);\ntimReturn_50 := TOD_TO_TIME(TOD#0:0:0.000);\ntimReturn_51 := TOD_TO_TIME(TOD#0:0:0.001);\n\ndateReturn_6 := TOD_TO_DATE(TOD#23:59:59.999);\ntimReturn_60 := TOD_TO_TIME(TOD#0:0:0.000);\nwReturn_61 := TOD_TO_WORD(TOD#0:0:0.001);\n\nuliReurn_7 := DATE_TO_ULINT(D#2019-9-9);\nuliReurn_70 := DATE_TO_ULINT(D#1970-1-1);\nuliReurn_71 := DATE_TO_ULINT(D#1970-1-2);\n\nwstrReturn_8 := DATE_TO_WSTRING(D#2019-9-9);\nwstrReturn_80 := DATE_TO_WSTRING(D#1970-1-1);\nwstrReturn_81 := DATE_TO_WSTRING(D#1970-1-2);\n\nxReturn_9 := DATE_TO_BOOL(D#2019-9-9);\nxReturn_90 := DATE_TO_BOOL(D#1970-1-1);\nxReturn_91 := DATE_TO_BOOL(D#1970-1-2);\nxReturn_92 := DATE_TO_BOOL(D#1970-1-3); Implementierungssprache FUP " }, 
{ "title" : "Konvertierung DATE, DT, TOD, LDATE, LDT, LTOD ", 
"url" : "_cds_operator_date_to.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Konvertierung DATE, DT, TOD, LDATE, LDT, LTOD ", 
"snippet" : "DATE, DT, TOD, LDATE, LDT, LTOD Die Operatoren konvertieren eine Datums- und Uhrzeitangabe in den angegebenen Datentyp und geben einen typkonvertierten Wert zurück. Die Datentypen DATE und DT verwenden intern das gleiche Speicherformat und werden als DWORD abgelegt. Die Auflösung bei DATE ist 1 Tag....", 
"body" : "DATE, DT, TOD, LDATE, LDT, LTOD Die Operatoren konvertieren eine Datums- und Uhrzeitangabe in den angegebenen Datentyp und geben einen typkonvertierten Wert zurück. Die Datentypen DATE und DT verwenden intern das gleiche Speicherformat und werden als DWORD abgelegt. Die Auflösung bei DATE ist 1 Tag. Die Auflösung bei DT ist 1 Sekunde. Beide beginnen mit dem 1. Januar 1970. TOD wird als DWORD mit einer Auflösung von 1 Millisekunde abgelegt. Die Schlüsselwörter DT und TOD sind alternative Schreibweisen für die Datentypen DATE_AND_TIMET und TIME_OF_DAY . Letztere werden jedoch nicht als Typkonvertierungsbefehl abgebildet. Die Datentypen LDATE und LDT und LTOD verwenden intern das 64-Bit Speicherformat LWORD . Aufrufsyntax : DATE\/DT\/TOD_TO_< Zieltyp> ( <Operand> ) Aufrufsyntax : LDATE\/LDT\/LTOD_TO_< Zieltyp> ( <Operand> ) Operand Datentyp Beschreibung Variable oder Literal DATE | DATE_AND_TIME | DT | TIME_OF_DAY | TOD LDATE | LDATE_AND_TIME | LDT | LTIME_OF_DAY | LTOD Datentyp: DATEOperatoren DATE\/DT\/TOD_TO_<Zieltyp> DATE_TO_<Typ> DT_TO_<Typ> TOD_TO_<Typ> Beispiel Rückgabewert Beschreibung DATE_TO___UXINT DT_TO___UXINT TOD_TO___XINT __UXINT, __XINT, __XWORDDATE_TO___XINT DT_TO___XINT TOD_TO___XINT __UXINT, __XINT, __XWORDDATE_TO___XWORD DT_TO___XWORD TOD_TO___XWORD __UXINT, __XINT, __XWORDDATE_TO_BIT DT_TO_BIT TOD_TO_BIT BITDATE_TO_BOOL DT_TO_BOOL TOD_TO_BOOL DATE_TO_BOOL(D#1970-1-1)\nDATE_TO_BOOL(D#2019-9-1)\nDT_TO_BOOL(DT#1970-1-1-0:0:0)\nDT_TO_BOOL(DT#2019-9-1-12:0:0)\nTOD_TO_BOOL(TOD#0:0:0)\nTOD_TO_BOOL(TOD#12:0:0)\n FALSE TRUE FALSE TRUE FALSE TRUE Nur genau dann, wenn der Operandenwert als „0“ interpretiert werden kann, wird vom Operator ein FALSE zurückgegeben. BOOLDATE_TO_BYTE DT_TO_BYTE DTOD_TO_BYTE Integer- DT_TO_DATE TOD_TO_DATE Auflösung in Sekunden, obwohl nur der Tag angezeigt wird DATE_TO_DINT DT_TO_DINT TOD_TO_DINT DATE_TO_DINT(D#1970-1-1)\nDATE_TO_DINT(D#1970-1-2)\nDATE_TO_DINT(D#2019-9-1)\nDT_TO_DINT(DT#1970-1-1-0:0:0)\nDT_TO_DINT(DT#1970-1-1-0:0:1)\nDT_TO_DINT(DT#2019-9-1-12:0:0.0)\nTOD_TO_DINT(TOD#0:0:0)\nTOD_TO_DINT(TOD#12:0:0)\n 0 86400 1567339200 0 1 1567339200 0 43200000 IntegerDATE_TO_DT - TOD_TO_DT Datentyp: DATEDATE_TO_DWORD DT_TO_DWORD TOD_TO_DWORD IntegerDATE_TO_INT DT_TO_INT TOD_TO_INT IntegerDATE_TO_LDATE DT_TO_LDATE TOD_TO_LDATE Datentyp: DATEDATE_TO_LDT DT_TO_LDT TOD_TO_LDT Datentyp: DATEDATE_TO_LINT DT_TO_LINT TOD_TO_LINT IntegerDATE_TO_LREAL DT_TO_LREAL TOD_TO_LREAL REAL, LREALDATE_TO_LTIME DT_TO_LTIME TOD_TO_LTIME Datentyp: DATEDATE_TO_LTOD DT_TO_LTOD TOD_TO_LTOD Datentyp: DATEDATE_TO_LWORD DT_TO_LWORD TOD_TO_LWORD IntegerDATE_TO_REAL DT_TO_REAL TOD_TO_REAL REAL, LREALDATE_TO_SINT DT_TO_SINT TOD_TO_SINT IntegerDATE_TO_STRING DT_TO_STRING TOD_TO_STRING DATE_TO_STRING(D#1970-1-1)\nDT_TO_STRING(D#1970-1-1-0:0:1)\nTOD_TO_STRING(12:0:1) 'D#1970-1-1' 'D#1970-1-1-0:0:1' 'TOD#12:0:1' STRINGDATE_TO_TIME DT_TO_TIME TOD_TO_TIME Datentyp: DATEDATE_TO_TOD DT_TO_TOD - Datentyp: DATEDATE_TO_UDINT DT_TO_UDINT TOD_TO_UDINT IntegerDATE_TO_UINT DT_TO_UINT TOD_TO_UINT IntegerDATE_TO_ULINT DT_TO_ULINT TOD_TO_ULINT IntegerDATE_TO_USINT DT_TO_USINT TODE_TO_USINT IntegerDATE_TO_WORD DT_TO_WORD TOD_TO_WORD IntegerDATE_TO_WSTRING DT_TO_WSTRING TOD_TO_WSTRING DATE_TO_WSTRING(D#1970-1-1)\nDT_TO_WSTRING(D#1970-1-1-0:0:1)\nTOD_TO_WSTRING(12:0:1) \"D#1970-1-1\" \"D#1970-1-1-0:0:1\" \"TOD#12:0:0\" WSTRINGOperatoren LDATE\/LDT\/LTOD_TO_<Zieltyp> LDATE_TO_<Typ> LDT_TO_<Typ> LTOD_TO_<Typ> Beispiel Rückgabewert Beschreibung LDATE_TO___UXINT LDT_TO___UXINT LTOD_TO___XINT __UXINT, __XINT, __XWORDLDATE_TO___XINT LDT_TO___XINT LTOD_TO___XINT __UXINT, __XINT, __XWORDLDATE_TO___XWORD LDT_TO___XWORD LTOD_TO___XWORD __UXINT, __XINT, __XWORDLDATE_TO_BIT LDT_TO_BIT LTOD_TO_BIT BITLDATE_TO_BOOL LDT_TO_BOOL LTOD_TO_BOOL BOOLLDATE_TO_BYTE LDT_TO_BYTE LTOD_TO_BYTE IntegerLDATE_TO_DATE LDT_TO_DATE LTOD_TO_DATE Sekunden, obwohl nur der Tag angezeigt wird Datentyp: DATELDATE_TO_DINT LDT_TO_DINT LTOD_TO_DINT IntegerLDATE_TO_DT LDT_TO_DT LTOD_TO_DT Datentyp: DATELDATE_TO_DWORD LDT_TO_DWORD LTOD_TO_DWORD IntegerLDATE_TO_INT LDT_TO_INT LTOD_TO_INT Integer- LDT_TO_LDATE LTOD_TO_LDATE Nanosekunden, obwohl nur der Tag angezeigt wird Datentyp: DATELDATE_TO_LDT - LTOD_TO_LDT Datentyp: DATELDATE_TO_LINT LDT_TO_LINT LTOD_TO_LINT IntegerLDATE_TO_LREAL LDT_TO_LREAL LTOD_TO_LREAL REAL, LREALLDATE_TO_LTIME LDT_TO_LTIME LTOD_TO_LTIME Datentyp: DATELDATE_TO_LTOD LDT_TO_LTOD - Datentyp: DATELDATE_TO_LWORD LDT_TO_LWORD LTOD_TO_LWORD IntegerLDATE_TO_REAL LDT_TO_REAL LTOD_TO_REAL REAL, LREALLDATE_TO_SINT LDT_TO_SINT LTOD_TO_SINT IntegerLDATE_TO_STRING LDT_TO_STRING LTOD_TO_STRING STRINGLDATE_TO_TIME LDT_TO_TIME LTOD_TO_TIME Datentyp: DATELDATE_TO_TOD LDT_TO_TOD LTOD_TO_TOD Datentyp: DATELDATE_TO_UDINT LDT_TO_UDINT LTOD_TO_UDINT IntegerLDATE_TO_UINT LDT_TO_UINT LTOD_TO_UINT IntegerLDATE_TO_ULINT LDT_TO_ULINT LTOD_TO_ULINT IntegerLDATE_TO_USINT LDT_TO_USINT LTODE_TO_USINT IntegerLDATE_TO_WORD LDT_TO_WORD LTOD_TO_WORD IntegerLDATE_TO_WSTRING LDT_TO_WSTRING LTOD_TO_WSTRING WSTRING" }, 
{ "title" : "In einen String konvertieren ", 
"url" : "_cds_operator_date_to.html#UUID-4ca6892c-e4a7-a5a0-9012-c85dca949d72_UUID-404aff3f-2280-a807-32f4-4186c7d8a3ae_id_af0e820ad05f2c39c0a8640e01c81eb6_id_05525fb43f678c87c0a864636e32204e", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Konvertierung DATE, DT, TOD, LDATE, LDT, LTOD \/ In einen String konvertieren ", 
"snippet" : "Die Operanden des Typs DATE , DATE_AND_TIME , TIME_OF_DAY , DT oder TOD , die für eine Datums- und Uhrzeitkonvertierung an einen Operator übergeben werden, werden in ihrer Konstantenschreibweise (Literalschreibweise) konvertiert. Der erzeugte String enthält die Schlüsselwörter D# , DT# oder TOD# und...", 
"body" : "Die Operanden des Typs DATE , DATE_AND_TIME , TIME_OF_DAY , DT oder TOD , die für eine Datums- und Uhrzeitkonvertierung an einen Operator übergeben werden, werden in ihrer Konstantenschreibweise (Literalschreibweise) konvertiert. Der erzeugte String enthält die Schlüsselwörter D# , DT# oder TOD# und danach die Größe mit ihrer Datums- und Uhrzeiteinheit so wie in der Norm IEC 61131-3 angegeben. " }, 
{ "title" : "Beispiele ", 
"url" : "_cds_operator_date_to.html#UUID-4ca6892c-e4a7-a5a0-9012-c85dca949d72_UUID-404aff3f-2280-a807-32f4-4186c7d8a3ae_id_af0e820ad05f2c39c0a8640e01c81eb6_id_f19e7b8120d3eba4c0a864632cdf6b1f", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Konvertierung DATE, DT, TOD, LDATE, LDT, LTOD \/ Beispiele ", 
"snippet" : "Implementierungssprache FUP Die Steuerung befindet sich im Onlinebetrieb, um die Variablen zu monitoren....", 
"body" : "Implementierungssprache FUP Die Steuerung befindet sich im Onlinebetrieb, um die Variablen zu monitoren. " }, 
{ "title" : "Operator: TRUNC ", 
"url" : "_cds_operator_trunc.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Operator: TRUNC ", 
"snippet" : "TRUNC Der IEC-Operator dient der Konvertierung vom Typ REAL zum Typ DINT . nimmt nur den ganzzahligen Anteil der Zahl. In konvertiert der TRUNC -Operator von REAL nach INT . Wenn Sie ein V2.3 Projekt importieren, wird TRUNC automatisch durch TRUNC_INT ersetzt. Wenn den Eingangswert nicht durch einen...", 
"body" : "TRUNC Der IEC-Operator dient der Konvertierung vom Typ REAL zum Typ DINT . nimmt nur den ganzzahligen Anteil der Zahl. In konvertiert der TRUNC -Operator von REAL nach INT . Wenn Sie ein V2.3 Projekt importieren, wird TRUNC automatisch durch TRUNC_INT ersetzt. Wenn den Eingangswert nicht durch einen DINT oder INT darstellen kann, ist das Ergebnis dieser Funktion undefiniert. Das Verhalten für solche Eingangswerte ist plattformabhängig. Beispiel ST diVar := TRUNC(1.9); (* Result: 1 *)\n\ndiVar := TRUNC(-1.4); (* Result: -1 *) " }, 
{ "title" : "Operator: TRUNC_INT ", 
"url" : "_cds_operator_trunc_int.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operatoren für Typkonvertierung \/ Operator: TRUNC_INT ", 
"snippet" : "TRUNC_INT Der IEC-Operator dient der Konvertierung vom Typ REAL zum Typ INT . nimmt nur den Betrag des ganzzahligen Anteils der Zahl. TRUNC_INT entspricht dem Operator TRUNC in und wird beim Import von V2.3-Projekten automatisch an dessen Stelle verwendet. Beachten Sie die veränderte Funktion von TR...", 
"body" : "TRUNC_INT Der IEC-Operator dient der Konvertierung vom Typ REAL zum Typ INT . nimmt nur den Betrag des ganzzahligen Anteils der Zahl. TRUNC_INT entspricht dem Operator TRUNC in und wird beim Import von V2.3-Projekten automatisch an dessen Stelle verwendet. Beachten Sie die veränderte Funktion von TRUNC in V3. Das Ergebnis dieser Funktion ist undefiniert, wenn den Eingangswert nicht durch einen DINT oder INT darstellen kann. Das Verhalten für solche Eingangswerte ist plattformabhängig. Beispiel ST iVar := TRUNC_INT(1.9); (* Result: 1 *)\n\niVar := TRUNC_INT(-1.4); (* Result: -1 *) " }, 
{ "title" : "Operanden ", 
"url" : "_cds_struct_reference_operands.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Konstanten und Literale ", 
"url" : "_cds_struct_reference_operands.html#UUID-aa359e50-e152-8177-ba90-37d4949fb3ba_section-idm4613159919964832678735357547", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstanten und Literale ", 
"snippet" : "Konstanten sind Bezeichner für unveränderliche Werte. Sie können Konstanten lokal innerhalb eines Programmierbausteins oder global innerhalb einer globalen Variablenliste deklarieren. Der Deklarationsabschnitt wird dazu mit dem Schlüsselwort CONSTANT erweitert. Konstanten sind auch Zeichenfolgen, di...", 
"body" : "Konstanten sind Bezeichner für unveränderliche Werte. Sie können Konstanten lokal innerhalb eines Programmierbausteins oder global innerhalb einer globalen Variablenliste deklarieren. Der Deklarationsabschnitt wird dazu mit dem Schlüsselwort CONSTANT erweitert. Konstanten sind auch Zeichenfolgen, die den Wert eines Basistypen wie beispielsweise Ganzzahlen oder Gleitkommazahlen darstellen, beispielsweise 16#FFFF_FFFF , T#5s oder -1.234 E-5 . Zur Unterscheidung werden solche Konstanten auch als Literale, literale Konstanten oder unbenannte Konstanten bezeichnet. Es gibt logische ( TRUE , FALSE ) oder numerische Literale ( 3.1415 , T#5s ), aber auch Zeichenliterale ( 'Hello world!' , \"black\" ). Syntax Deklaration <scope> CONSTANT\n <identifier> : <data type> := <initial value> ;\nEND_VAR\n\n<scope> : VAR | VAR_INPUT | VAR_STAT | VAR_GLOBAL\n<data type>: <elementary data type | user defined data type | function block >\n<initial value> : literal value | identifier | expression Erlaubte Initialwerte: Literal Beispiele: TRUE , FALSE , 16#FFFF_FFFF Benannte Konstante, die an anderer Stelle deklariert wurde Einfacher Ausdruck aus Literalen, auch kombiniert mit einfachen Operatoren wie beispielsweise + - * Eingänge oder Funktionsaufrufe können nicht als Initialwert angegeben werden. Beispiel VAR_GLOBAL CONSTANT\n g_ciMAX_A : INT := 100;\n g_ciSPECIAL : INT := g_ciMAX_A - 10;\nEND_VAR Konstanten werden nur bei der Deklaration beschrieben. Die Zuweisung eines Initialwerts ist obligat. Innerhalb einer Implementierung werden Konstanten ausschließlich gelesen und stehen deshalb in einer Anweisung immer rechts vom Zuweisungsoperator. Die Konstanten werden beim Compilieren des Codes mit dem Initialwert ersetzt. Der Initialwert muss außerdem zur Compilezeit berechnet werden können. Konstanten von strukturierten oder benutzerdefinierten Typen werden erst zur Laufzeit berechnet. Strukturierte Konstanten in Programmen oder GVLs werden einmal zum Programmstart berechnet. Strukturierte Konstanten in Funktionen oder Methoden werden jedes Mal berechnet, wenn die Funktion oder Methode aufgerufen wird. Die Initialisierung von strukturierten Konstanten kann somit von Eingaben abhängen oder Funktionsaufrufe ausführen. " }, 
{ "title" : "Variablen ", 
"url" : "_cds_struct_reference_operands.html#UUID-aa359e50-e152-8177-ba90-37d4949fb3ba_section-idm4613160443185632678735970218", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Variablen ", 
"snippet" : "Sie können Variablen entweder lokal im Deklarationsteil eines Bausteins oder in einer globalen Variablenliste deklarieren. An welcher Stelle Sie eine Variable verwenden können, hängt von ihrem Datentyp ab. Für weitere Informationen siehe: Zugriff auf Variablen von Arrays, Strukturen und Bausteinen u...", 
"body" : "Sie können Variablen entweder lokal im Deklarationsteil eines Bausteins oder in einer globalen Variablenliste deklarieren. An welcher Stelle Sie eine Variable verwenden können, hängt von ihrem Datentyp ab. Für weitere Informationen siehe: Zugriff auf Variablen von Arrays, Strukturen und Bausteinen und Bitzugriff in Variablen" }, 
{ "title" : "Weitere ", 
"url" : "_cds_struct_reference_operands.html#UUID-aa359e50-e152-8177-ba90-37d4949fb3ba_section-idm461449035556323267873805769", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Weitere ", 
"snippet" : "Für weitere Informationen siehe: Adressen und Funktionen...", 
"body" : "Für weitere Informationen siehe: Adressen und Funktionen" }, 
{ "title" : "Konstante: BOOL ", 
"url" : "_cds_operands_constant_bool.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstante: BOOL ", 
"snippet" : "BOOL BOOL-Konstanten sind die Wahrheitswerte TRUE (1) und FALSE (0). Für weitere Informationen siehe: BOOL...", 
"body" : "BOOL BOOL-Konstanten sind die Wahrheitswerte TRUE (1) und FALSE (0). Für weitere Informationen siehe: BOOL" }, 
{ "title" : "Konstante: Zahl ", 
"url" : "_cds_operands_constant_integer.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstante: Zahl ", 
"snippet" : "Zahlenwerte können als Dualzahlen, Oktalzahlen, Dezimalzahlen und Hexadezimalzahlen auftreten. Wenn ein Integerwert keine Dezimalzahl ist, dann müssen Sie seine Basis gefolgt von einem Doppelkreuz (#) vor die Integerkonstante schreiben. Die Ziffernwerte für die Zahlen 10 bis 15 bei Hexadezimalzahlen...", 
"body" : "Zahlenwerte können als Dualzahlen, Oktalzahlen, Dezimalzahlen und Hexadezimalzahlen auftreten. Wenn ein Integerwert keine Dezimalzahl ist, dann müssen Sie seine Basis gefolgt von einem Doppelkreuz (#) vor die Integerkonstante schreiben. Die Ziffernwerte für die Zahlen 10 bis 15 bei Hexadezimalzahlen geben Sie wie üblich durch die Buchstaben A-F an. Sie können Unterstriche innerhalb eines Zahlenwertes verwenden. Beispiele 14 Dezimalzahl 2#1001_0011 Dualzahl 8#67 Oktalzahl 16#A Hexadezimalzahl DINT#16#A1 Getypter Datentyp DINT# mit Basis 16# kombiniert Mögliche Datentypen für einen Zahlenliteral: BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT Implizite Konvertierungen von „größeren“ zu „kleineren“ Typen sind nicht erlaubt. Sie können eine DINT-Variable nicht ohne Weiteres als INT-Variable benutzen. Hierfür müssen Sie eine Typkonvertierungs-Funktion verwenden. Für weitere Informationen siehe: Konstante: Typisiertes LiteralDa Zahlenkonstanten grundsätzlich als ganzzahlige Werte behandelt werden, müssen Sie in Divisionen die Konstante im Format einer Gleitpunktzahl angeben, um den Rest nicht zu verlieren. Beispiele: Division 1\/10 ergibt 0 und Division 1.0\/10 ergibt 0.1 " }, 
{ "title" : "Konstante: REAL, LREAL ", 
"url" : "_cds_operands_constant_real.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstante: REAL, LREAL ", 
"snippet" : "Sie können Gleitkommazahlen als REAL - und LREAL -Konstanten in Punktschreibweise oder Exponentialschreibweise mit Mantisse und Exponent angeben. Der Punkt dient als Dezimaltrennzeichen gemäß der International System of Units (English). Syntax Exponentialdarstellung <significand> e | E <exponent> ex...", 
"body" : "Sie können Gleitkommazahlen als REAL - und LREAL -Konstanten in Punktschreibweise oder Exponentialschreibweise mit Mantisse und Exponent angeben. Der Punkt dient als Dezimaltrennzeichen gemäß der International System of Units (English). Syntax Exponentialdarstellung <significand> e | E <exponent> exponent : -44..38 \/\/ REAL\nexponent : -324..308 \/\/ LREAL Beispiel REAL -Literal 7.4 Dezimalzahl 7,4 mit Komma liefert Compilerfehler 1\/3.0 Dezimalbruch für 0.333333343 Hinweis: Bei Division von Integertypen bleibt das Ergebnis ein Integertyp. Dabei wird abgeschnitten. Beispielsweise liefert 1\/3 als Ergebnis 0. 1.64e+009 Exponentialdarstellung -3.402823e+38 Kleinste Zahl -1E-44 Größte negative Zahl 1.0E-44 Kleinste positive Zahl 3.402823e+38 Größte Zahl LREAL -Literal -1.7976931348623157E+308 Kleinste Zahl -4.94065645841247E-324 Größte negative Zahl 4.94065645841247E-324 Kleinste positive Zahl 1.7976931348623157E+308 Größte Zahl Für weitere Informationen siehe: REAL, LREAL" }, 
{ "title" : "Konstante: String ", 
"url" : "_cds_operands_constant_string.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstante: String ", 
"snippet" : "String Ein Stringliteral ist eine von einfachen Anführungszeichen umschlossene Zeichenfolge. Die Zeichen werden gemäß Zeichensatz ISO\/IEC 8859-1 (Latin1) codiert. Ein Stringliteral kann folglich Leerzeichen und Umlaute enthalten, da die Zeichen teil des Zeichensatzes sind. Sie wird auch als Zeichenl...", 
"body" : "String Ein Stringliteral ist eine von einfachen Anführungszeichen umschlossene Zeichenfolge. Die Zeichen werden gemäß Zeichensatz ISO\/IEC 8859-1 (Latin1) codiert. Ein Stringliteral kann folglich Leerzeichen und Umlaute enthalten, da die Zeichen teil des Zeichensatzes sind. Sie wird auch als Zeichenliteral oder einfach nur als String bezeichnet. Wenn allerdings die Compile-Option UTF8-Kodierung für STRING aktiviert ist, wird das Stringliteral im UTF-8-Format interpretiert. Diese Kodierung ist kompatibel zu ASCII und auch zu Latin-1. Somit sind die Hexadezimlcodes und die Steuerzeichensonderfälle auch in UTF-8 gültig. Beispiel: 'Hello World!' Stringliterale werden nicht auf Kompatibilität geprüft. Folglich erlaubt der Texteditor die Eingabe aller Zeichen. Der Compiler übersetzt allerdings unbekannte Zeichen mit ? . " }, 
{ "title" : "Hexadezimalcode ", 
"url" : "_cds_operands_constant_string.html#UUID-53b96aec-6e6d-af8b-2d30-6d54f4f8c3e0_section-idm4640076731518432920988296297", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstante: String \/ Hexadezimalcode ", 
"snippet" : "Wenn in einem Stringliteral ein Dollarzeichens ($) ist, werden die nachfolgenden 2 Zeichen als Hexadezimalcode gemäß der Codierung in ISO\/IEC 8859-1 interpretiert. Der Code entspricht auch dem ASCII-Code. Beachten Sie außerdem die Sonderfälle und Steuerzeichen. Hexadezimalcode String mit $-Code Inte...", 
"body" : "Wenn in einem Stringliteral ein Dollarzeichens ($) ist, werden die nachfolgenden 2 Zeichen als Hexadezimalcode gemäß der Codierung in ISO\/IEC 8859-1 interpretiert. Der Code entspricht auch dem ASCII-Code. Beachten Sie außerdem die Sonderfälle und Steuerzeichen. Hexadezimalcode String mit $-Code Interpretation '$<8-Bit-Code>' 8-Bit-Code: Zweistellige hexadezimale Zahl, die gemäß ISO\/IEC 8859-1 interpretiert wird '$41' A '$A9' © '$40' @ '$0D' Steuerzeichen Zeilenumbruch, entspricht ‚$R‘ '$0A' Steuerzeichen neue Zeile, entspricht ‚$L‘ und ‚$N‘ Sonderfälle String mit $-Code Interpretation '$L' , ' $l' Steuerzeichen Zeilenvorschub, entspricht '$0A' '$N' , '$n' Steuerzeichen neue Zeile, entspricht '$0A '$P' , '$p' Steuerzeichen Seitenvorschub '$R' , '$r' Steuerzeichen Zeilenumbruch, entspricht '$0D' '$T' , '$t' Steuerzeichen Tabulator '$$' Dollarzeichen: § '$'' Einfaches Anführungszeichen: ' Konstantendeklaration VAR CONSTANT\n constA : STRING := 'Hello Allgäu';\n constB : STRING := 'Hello Allgäu $21'; \/\/ Hello Allgaeu!\nEND_VAR " }, 
{ "title" : "Konstante: UTF8#-String ", 
"url" : "_cds_operands_constant_string_utf8.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstante: UTF8#-String ", 
"snippet" : "UTF8#-String Mit Compilerversion >= 3.5.18.0 sind UTF-8 kodierte Stringliterale als Single-Byte-String mit Basis STRING möglich. Syntax: UTF8#' <string literal> ' Konstantendeklaration VAR CONSTANT constA : STRING := UTF8#'aäoöuü'; constB : STRING := UTF8#'Hello Allgäu $21'; \/\/ Hello Allgäu! END_VAR...", 
"body" : "UTF8#-String Mit Compilerversion >= 3.5.18.0 sind UTF-8 kodierte Stringliterale als Single-Byte-String mit Basis STRING möglich. Syntax: UTF8#' <string literal> ' Konstantendeklaration VAR CONSTANT\n constA : STRING := UTF8#'aäoöuü';\n constB : STRING := UTF8#'Hello Allgäu $21'; \/\/ Hello Allgäu!\nEND_VAR Um eine korrekte Überwachung zu gewährleisten, kann das Attribut 'monitoring_encoding' := 'UTF-8' hinzugefügt werden. UTF-8-Kodierung nur bei projektweiter Konfigurierung Eine UTF-8-Kodierung wird verwendet, wenn die projektweit gültige Compile-Option UTF8-Kodierung für STRING aktiviert ist. Bibliotheksfunktionen und Add-ons orientieren sich dann auch gemäß diesem Setting. Wenn Sie einzelne UTF-8 kodierte Strings verwenden, dann müssen Sie dafür Sorge tragen, dass diese überall dort, wo sie verwendet werden, auch richtig interpretiert werden. Eine String-Variable im OPC-Server wird zum Beispiel vor der Übertragung zu einem Client nach UTF-8 konvertiert, wenn das Setting nicht angewählt ist. Werte wie beispielsweise UTF8#'äöü' würden dann falsch interpretiert werden. Ähnliche Probleme können bei der Ausgabe von Strings in der Visualisierung entstehen. " }, 
{ "title" : "Konstante: Zeichen ", 
"url" : "_cds_operands_constant_character.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstante: Zeichen ", 
"snippet" : "Zeichen Das Zeichenliteral für ein einzelnes Unicode-Zeichen hat den Basistyp UDINT . Als Kennung wird dem Literal das Typpräfix UCHAR# vorangestellt. Der Zahlenwert des Zeichenliterals entspricht dem Codepunkt des Unicode-Standards. Syntax: UCHAR#' <single charater> ' Literal udiChar : UDINT := UCH...", 
"body" : "Zeichen Das Zeichenliteral für ein einzelnes Unicode-Zeichen hat den Basistyp UDINT . Als Kennung wird dem Literal das Typpräfix UCHAR# vorangestellt. Der Zahlenwert des Zeichenliterals entspricht dem Codepunkt des Unicode-Standards. Syntax: UCHAR#' <single charater> ' Literal udiChar : UDINT := UCHAR#'ฒ'; \/\/ cp 3603\nudiChar_1 : UDINT := UCHAR#'⳧'; \/\/ cp 11495 " }, 
{ "title" : "Konstante: TIME, LTIME ", 
"url" : "_cds_operands_constant_time.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstante: TIME, LTIME ", 
"snippet" : "Sie können TIME -Konstanten benutzen, um die Standard-Timer-Module zu bedienen. Die Konstante hat eine Größe von 32 Bit und somit eine Auflösung in Millisekunden. Außerdem steht Ihnen die Zeitkonstante LTIME als Zeitbasis für hochauflösende Timer zur Verfügung. Die LTIME -Konstante hat eine Größe vo...", 
"body" : "Sie können TIME -Konstanten benutzen, um die Standard-Timer-Module zu bedienen. Die Konstante hat eine Größe von 32 Bit und somit eine Auflösung in Millisekunden. Außerdem steht Ihnen die Zeitkonstante LTIME als Zeitbasis für hochauflösende Timer zur Verfügung. Die LTIME -Konstante hat eine Größe von 64 Bit und somit eine Auflösung in Nanosekunden. " }, 
{ "title" : "Konstante: TIME ", 
"url" : "_cds_operands_constant_time.html#UUID-23174cc0-9514-a362-12b5-3a2a594aefce_id_d7e28b97a6ed17c0a8640e016ca2dd_id_137fbb3719b75a97c0a86463424aa10f", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstante: TIME, LTIME \/ Konstante: TIME ", 
"snippet" : "Syntax <time keyword> # <length of time> <time keyword> : TIME | time | T | t <length of time> : ( <number of days>d )? ( <number of hours>h )? ( <number of minutes>m )? ( <number of seconds>s )? (<number of milleseconds>ms)? \/\/ ( ...)? Optional Die Reihenfolge der Zeiteinheiten darf nicht verändert...", 
"body" : "Syntax <time keyword> # <length of time>\n\n<time keyword> : TIME | time | T | t\n<length of time> : ( <number of days>d )? ( <number of hours>h )? ( <number of minutes>m )? ( <number of seconds>s )? (<number of milleseconds>ms)? \/\/ ( ...)? Optional Die Reihenfolge der Zeiteinheiten darf nicht verändert werden. Es ist jedoch nicht erforderlich, alle Einheiten anzugeben. Es ist erlaubt, die Einheiten in Großbuchstaben zu schreiben. Zeiteinheiten D | d : Tage H | h : Stunden M | m : Minuten s | s : Sekunden MS | ms : Millisekunden Beispiele Korrekte Zeitkonstanten einer ST-Zuweisung VAR\n timLength : TIME := T#14ms;\n timLength1 : TIME := T#100s12ms; \/\/ Overflow in the highest unit is allowed.\n timLength2 : TIME := T#12h34m15s;\n timCompare : TIME;\n xIsOK: BOOL;\n\n timLongest := T#49D17H2M47S295MS; \/\/ 4294967295\nEND_VAR\n\nIF timLength < T#15MS THEN\n IF timCompare < timLength1 THEN\n xIsOK := TRUE;\n END_IF;\nEND_IF Falsche Verwendung timIncorrect := t#5m68s; Überlauf bei einer niedrigeren Stelle timIncorrect1 := 15ms; Zeitkennung T# fehlt timIncorrect2 := t#4ms13d; Unkorrekte Reihenfolge der Zeiteinheiten " }, 
{ "title" : "Konstante: LTIME ", 
"url" : "_cds_operands_constant_time.html#UUID-23174cc0-9514-a362-12b5-3a2a594aefce_id_d7e28b97a6ed17c0a8640e016ca2dd_id_a8919c2919b75a97c0a864635c7068ea", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstante: TIME, LTIME \/ Konstante: LTIME ", 
"snippet" : "Syntax <long time keyword> # <length of high resolution time> <long time keyword> : LTIME | ltime <length of high resolution time> : <length of time> ( <number of microseconds>us )? ( <number of nanoseconds>ns )? \/\/ ( ...)? Optional Sie können für LTIME -Konstanten die gleichen Zeiteinheiten wie für...", 
"body" : "Syntax <long time keyword> # <length of high resolution time>\n\n<long time keyword> : LTIME | ltime\n<length of high resolution time> : <length of time> ( <number of microseconds>us )? ( <number of nanoseconds>ns )? \/\/ ( ...)? Optional Sie können für LTIME -Konstanten die gleichen Zeiteinheiten wie für TIME -Konstanten verwenden. Zusätzlich können Sie Mikrosekunden und Nanosekunden angeben, da die Zeitangabe in höherer Zeitauflösung gerechnet wird. Intern werden LTIME -Literale wie der Datentyp LWORD behandelt und der Wert deswegen in Nanosekunden aufgelöst. Zusätzliche Zeiteinheiten US | us : Mikrosekunden NS | ns : Nanosekunden Beispiele für die korrekte Verwendung einer ST-Zuweisung PROGRAM PLC_PRG\nVAR\n ltimLength := LTIME#1000d15h23m12s34ms2us44ns;\n ltimLength1 := LTIME#3445343m3424732874823ns;\nEND_VAR Für weitere Informationen siehe: Datentyp: TIME, LTIME und Konstante: Datum und Uhrzeit" }, 
{ "title" : "Konstante: Datum und Uhrzeit ", 
"url" : "_cds_operands_constant_date.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstante: Datum und Uhrzeit ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "32-Bit-Datumsangabe: DATE ", 
"url" : "_cds_operands_constant_date.html#UUID-e7937a91-f0b7-607d-fd3d-885eff997859_id_ce3b6c7097a791bfc0a8640e014f1995_id_615fb5921fe0403dc0a864637afb9922", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstante: Datum und Uhrzeit \/ 32-Bit-Datumsangabe: DATE ", 
"snippet" : "Verwenden Sie die Schlüsselwörter DATE ( D ), um Datumsangaben zu machen. Syntax <date keyword>#<year>-<month>-<day> <date keyword> : DATE | date | D | d <year> : 1970-2106 <month> : 1-12 <day> : 1-31 DATE -Literale werden intern wie der Datentyp DWORD behandelt, was einer Obergrenze von DATE#2106-2...", 
"body" : "Verwenden Sie die Schlüsselwörter DATE ( D ), um Datumsangaben zu machen. Syntax <date keyword>#<year>-<month>-<day>\n\n<date keyword> : DATE | date | D | d\n<year> : 1970-2106\n<month> : 1-12\n<day> : 1-31 DATE -Literale werden intern wie der Datentyp DWORD behandelt, was einer Obergrenze von DATE#2106-2-7 entspricht. Beispiel PROGRAM PRG_Date\nVAR\n dateStart : DATE := DATE#2018-8-8;\n dateEnd : DATE := D#2018-8-31;\n dateCompare: DATE := date#1996-05-06;\n xIsDuringTheTime: BOOL;\n\n dateEarliest : DATE := d#1970-1-1; \/\/ = 0\n dateLatest : DATE := DATE#2106-2-7; \/\/ = 4294967295\nEND_VAR\n\nIF dateStart < dateCompare THEN\n IF dateCompare < dateEnd THEN\n xIsDuringTheTime := TRUE;\n END_IF;\nEND_IF " }, 
{ "title" : "64-Bit-Datumsangabe: LDATE ", 
"url" : "_cds_operands_constant_date.html#UUID-e7937a91-f0b7-607d-fd3d-885eff997859_id_ce3b6c7097a791bfc0a8640e014f1995_id_aac82d911fe0403dc0a8646373b64fb2", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstante: Datum und Uhrzeit \/ 64-Bit-Datumsangabe: LDATE ", 
"snippet" : "Verwenden Sie das Schlüsselwort LDATE ( LD ), um Datumsangaben zu machen. Syntax <date keyword>#<year>-<month>-<day> <date keyword> : LDATE | ldate | LD | ld <year> : 1677-2262 <month> : 1-12 <day> : 1-31 LDATE -Literale werden intern wie der Datentyp LWORD behandelt, was einer Obergrenze von DATE#2...", 
"body" : "Verwenden Sie das Schlüsselwort LDATE ( LD ), um Datumsangaben zu machen. Syntax <date keyword>#<year>-<month>-<day>\n\n<date keyword> : LDATE | ldate | LD | ld\n<year> : 1677-2262\n<month> : 1-12\n<day> : 1-31 LDATE -Literale werden intern wie der Datentyp LWORD behandelt, was einer Obergrenze von DATE#2554-7-21 entspricht. Beispiel PROGRAM PRG_Ldate\nVAR\n ldateStart : LDATE := LDATE#2018-8-8;\n ldateEnd : LDATE := ldate#2018-8-31;\n ldateCompare: LDATE := LD#1996-05-06;\n xIsDuringTheTime: BOOL;\n\n ldateEarliest : LDATE := ld#1677-9-22; \/\/ = 0\n ldateLatest : LDATE := LDATE#2262-4-11; \/\/ = 16#7FFFB21D1DB10000\n\n lwValue: LWORD;\nEND_VAR\n\nIF ldateStart < ldateCompare THEN\n IF ldateCompare < ldateEnd THEN\n xIsDuringTheTime := TRUE;\n END_IF;\nEND_IF\nlwValue := LDATE_TO_LWORD(ldateCompare); " }, 
{ "title" : "32-Bit-Datums- und -Uhrzeitangabe: DATE_AND_TIME ", 
"url" : "_cds_operands_constant_date.html#UUID-e7937a91-f0b7-607d-fd3d-885eff997859_id_ce3b6c7097a791bfc0a8640e014f1995_id_0042b76a1fe0403dc0a86463723e9a7f", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstante: Datum und Uhrzeit \/ 32-Bit-Datums- und -Uhrzeitangabe: DATE_AND_TIME ", 
"snippet" : "Verwenden Sie das das Schlüsselwort DATE_AND_TIME ( DT ), um Datums-und Uhrzeitangaben zu machen. Syntax <date and time keyword>#<date and time value> <date and time keyword> : DATE_AND_TIME | date_and_time | DT | dt <date and time value> : <year>-<month>-<day>-<hour>:<minute>:<second> <year> : 1970...", 
"body" : "Verwenden Sie das das Schlüsselwort DATE_AND_TIME ( DT ), um Datums-und Uhrzeitangaben zu machen. Syntax <date and time keyword>#<date and time value>\n\n<date and time keyword> : DATE_AND_TIME | date_and_time | DT | dt\n<date and time value> : <year>-<month>-<day>-<hour>:<minute>:<second>\n<year> : 1970-2106\n<month> : 1-12\n<day> : 1-31\n<hour> : 0-24\n<minute> : 0-59\n<second> : 0-59 DATE_AND_TIME -Literale werden intern als Datentyp DWORD behandelt. Die Zeit wird in Sekunden verarbeitet und kann folglich Werte von 1. Januar 1970 00:00 Uhr bis 07.Februar 2106 6:28:15 Uhr annehmen. Beispiel PROGRAM PLC_PRG\nVAR\n dtDate : DATE_AND_TIME := DATE_AND_TIME#1996-05-06-15:36:30;\n dtDate1: DATE_AND_TIME := DT#1972-03-29-00:00:00;\n dtDate2: DATE_AND_TIME := DT#2018-08-08-13:33:20.5;\n\n dtEarliest : DATE_AND_TIME := DATE_AND_TIME#1970-1-1-00:00:00; \/\/ 0\n dtLatest : DATE_AND_TIME := DATE_AND_TIME#2106-2-7-6:28:15; \/\/ 4294967295\nEND_VAR " }, 
{ "title" : "64-Bit-Datums- und -Uhrzeitangabe: LDATE_AND_TIME ", 
"url" : "_cds_operands_constant_date.html#UUID-e7937a91-f0b7-607d-fd3d-885eff997859_id_ce3b6c7097a791bfc0a8640e014f1995_id_5d8c31881fe0403dc0a8646357871614", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstante: Datum und Uhrzeit \/ 64-Bit-Datums- und -Uhrzeitangabe: LDATE_AND_TIME ", 
"snippet" : "Verwenden Sie das das Schlüsselwort LDATE_AND_TIME ( LDT ), um Datums-und Uhrzeitangaben zu machen. Syntax <date and time keyword>#<long date and time value> <date and time keyword> : LDATE_AND_TIME | ldate_and_time | LDT | ldt <date and time value> : <year>-<month>-<day>-<hour>:<minute>:<second> <y...", 
"body" : "Verwenden Sie das das Schlüsselwort LDATE_AND_TIME ( LDT ), um Datums-und Uhrzeitangaben zu machen. Syntax <date and time keyword>#<long date and time value>\n\n<date and time keyword> : LDATE_AND_TIME | ldate_and_time | LDT | ldt\n<date and time value> : <year>-<month>-<day>-<hour>:<minute>:<second>\n<year> : 1677-2262\n<month> : 1-12\n<day> : 1-31\n<hour> : 0-24\n<minute> : 0-59\n<second> : 0-59 LDATE_AND_TIME#2262-4-10-23:59:59.99999999 LDATE_AND_TIME -Literale werden intern als Datentyp LWORD behandelt. Die Zeit wird in Nanosekunden verarbeitet und kann folglich Werte von 21. September 1677 00:12:43.145224192 Uhr bis 11. April 2262 23:47:16.854775807 Uhr annehmen. Beispiel PROGRAM PLC_PRG\nVAR\n ldtDate : LDATE_AND_TIME := LDATE_AND_TIME#1996-05-06-15:36:30;\n ldtDate1: LDATE_AND_TIME := LDT#1972-03-29-00:00:00;\n ldtDate2: LDATE_AND_TIME := LDT#2018-08-08-13:33:20.5;\n\n dtEarliest : LDT := LDT#1677-9-21-0:12:43.145224192; \/\/ 0\n dtLatest : LDT := LDT#2262-4-11-23:47:16.854775807; \/\/ = 16#7FFFFFFFFFFFFFFF\nEND_VAR " }, 
{ "title" : "32-Bit-Uhrzeitangabe: TIME_OF_DAY ", 
"url" : "_cds_operands_constant_date.html#UUID-e7937a91-f0b7-607d-fd3d-885eff997859_id_ce3b6c7097a791bfc0a8640e014f1995_id_cb1ceee71fe0403dc0a86463160d0889", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstante: Datum und Uhrzeit \/ 32-Bit-Uhrzeitangabe: TIME_OF_DAY ", 
"snippet" : "Verwenden Sie das das Schlüsselwort TIME_OF_DAY ( TOD ), um Uhrzeitangaben zu machen. Syntax <time keyword>#<time value> <time keyword> : TIME_OF_DAY | time_of_day | TOD | tod <time value> : <hour>:<minute>:<second> <hour> : 0-23 <minute> : 0-59 <second> : 0.000-59.999 Sie können bei Sekunden auch S...", 
"body" : "Verwenden Sie das das Schlüsselwort TIME_OF_DAY ( TOD ), um Uhrzeitangaben zu machen. Syntax <time keyword>#<time value>\n\n<time keyword> : TIME_OF_DAY | time_of_day | TOD | tod\n<time value> : <hour>:<minute>:<second>\n<hour> : 0-23\n<minute> : 0-59\n<second> : 0.000-59.999 Sie können bei Sekunden auch Sekundenbruchteile angeben. TIME_OF_DAY -Literale werden intern als DWORD behandelt und somit der Wert in Millisekunden aufgelöst. Beispiele PROGRAM POU\nVAR\n todClockTime : TIME_OF_DAY := TIME_OF_DAY#15:36:30.123;\n todEarliest : TIME_OF_DAY := TIME_OF_DAY#0:0:0.000;\n todLatest : TOD := TOD#23:59:59.999;\nEND_VAR " }, 
{ "title" : "64-Bit-Uhrzeitangabe: LTIME_OF_DAY ", 
"url" : "_cds_operands_constant_date.html#UUID-e7937a91-f0b7-607d-fd3d-885eff997859_id_ce3b6c7097a791bfc0a8640e014f1995_id_89b6b5e319701aa4c0a864633c92579b", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstante: Datum und Uhrzeit \/ 64-Bit-Uhrzeitangabe: LTIME_OF_DAY ", 
"snippet" : "Verwenden Sie das das Schlüsselwort LTIME_OF_DAY ( LTOD ), um Uhrzeitangaben zu machen. Syntax <time keyword>#<time value> <time keyword> : LTIME_OF_DAY | ltime_of_day | LTOD | ltod <time value> : <hour>:<minute>:<second> <hour> : 0-23 <minute> : 0-59 <second> : 0.000-59.999999999 Sie können bei Sek...", 
"body" : "Verwenden Sie das das Schlüsselwort LTIME_OF_DAY ( LTOD ), um Uhrzeitangaben zu machen. Syntax <time keyword>#<time value>\n\n<time keyword> : LTIME_OF_DAY | ltime_of_day | LTOD | ltod\n<time value> : <hour>:<minute>:<second>\n<hour> : 0-23\n<minute> : 0-59\n<second> : 0.000-59.999999999 Sie können bei Sekunden auch Sekundenbruchteile angeben. LTIME_OF_DAY -Literale werden intern als LWORD behandelt und somit der Wert in Nanosekunden aufgelöst. Beispiele PROGRAM POU\nVAR\n ltodClockTime : LTIME_OF_DAY := TIME_OF_DAY#15:36:30.123456789;\n todEarliest : TIME_OF_DAY := TIME_OF_DAY#0:0:0;\n todLatest : TOD := TOD#23:59:59.999999999;\nEND_VAR Für weitere Informationen siehe: Datentyp: DATE" }, 
{ "title" : "Konstante: Typisiertes Literal ", 
"url" : "_cds_operands_constant_typedliterals.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Konstante: Typisiertes Literal ", 
"snippet" : "Mit Ausnahme von REAL oder LREAL -Konstanten (in diesem Fall wird immer LREAL verwendet) wird beim Rechnen mit IEC-Konstanten der kleinstmöglichen Datentyp verwendet. Wenn Sie einen anderen Datentyp verwenden wollen, können Sie dies mit Hilfe von \"Typed Literals\" (Typisierte Konstanten) erreichen, o...", 
"body" : "Mit Ausnahme von REAL oder LREAL -Konstanten (in diesem Fall wird immer LREAL verwendet) wird beim Rechnen mit IEC-Konstanten der kleinstmöglichen Datentyp verwendet. Wenn Sie einen anderen Datentyp verwenden wollen, können Sie dies mit Hilfe von \"Typed Literals\" (Typisierte Konstanten) erreichen, ohne dass Sie die Konstante explizit deklarieren müssen. Versehen Sie hierbei die Konstante mit einem Präfix, das den Typ festlegt. Syntax <type> # <literal> <type> gibt den gewünschten Datentyp an. Mögliche Eingaben sind BOOL , SINT , USINT , BYTE , INT , UINT , WORD , DINT , UDINT , DWORD , REAL und LREAL . Sie müssen den Typ in Großbuchstaben schreiben. <literal> gibt die Konstante an. Die Eingabe muss zum unter <type> angegebenen Datentypen passen. Beispiel diVar := DINT#34; Wenn CODESYS die Konstante nicht ohne Datenverlust in den Zieltyp überführen kann, wird eine Fehlermeldung ausgegeben. Sie können typisierte Konstanten überall dort verwendet, wo Sie normale Konstanten verwenden können. " }, 
{ "title" : "Zugriff auf Variablen von Arrays, Strukturen und Bausteinen ", 
"url" : "_cds_operands_variables_accessing_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Zugriff auf Variablen von Arrays, Strukturen und Bausteinen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Zugriff auf Arrayelemente ", 
"url" : "_cds_operands_variables_accessing_variables.html#UUID-ae836494-8ea7-f000-02ab-8154d9c0ddf6_section-idm4559767227196833962845179725", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Zugriff auf Variablen von Arrays, Strukturen und Bausteinen \/ Zugriff auf Arrayelemente ", 
"snippet" : "Syntax: <Name der Arrayvariable> [ <Kommaseparierete Liste der Dimensionsindexe> ] <Name der Arrayvariable> Name des Arrayvariable Beispiel: aiCounter Für weitere Informationen, siehe: Bezeichner vergeben<Kommaseparierete Liste der Dimensionsindexe> Ein Index pro Dimension, so dass ein Element des A...", 
"body" : "Syntax: <Name der Arrayvariable> [ <Kommaseparierete Liste der Dimensionsindexe> ] <Name der Arrayvariable> Name des Arrayvariable Beispiel: aiCounter Für weitere Informationen, siehe: Bezeichner vergeben<Kommaseparierete Liste der Dimensionsindexe> Ein Index pro Dimension, so dass ein Element des Arrays identifiziert wird Beispiel: 2 Der Index ist beginnend beim Indexminimum bis zum Indexmaximum gültig. Beispiel: 0..9 Beispiele Eindimensionales Array mit 10 Komponenten \/\/Declaration\nVAR\n aiCounter : ARRAY[0..9] OF INT;\n iLocalVariable : INT;\nEND_VAR\n\n\/\/ Implementation\niLocalVariable := aiCounter[2]; Zweidimensionales Array mit 2 mal 2 Komponenten \/\/Declaration\nVAR\n aiCardGame : ARRAY[1..2, 3..4] OF INT;\n iLocal_1 : INT;\nEND_VAR\n\n\/\/Implementation\niLocal_1 := aiCardGame[1, 3]; Für weitere Informationen siehe: ARRAY OF" }, 
{ "title" : "Zugriff auf Strukturkomponenten ", 
"url" : "_cds_operands_variables_accessing_variables.html#UUID-ae836494-8ea7-f000-02ab-8154d9c0ddf6_section-idm4559414443915233962845733495", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Zugriff auf Variablen von Arrays, Strukturen und Bausteinen \/ Zugriff auf Strukturkomponenten ", 
"snippet" : "Syntax: <Name der Strukturvariablen> . <Name der Komponente> <Name der Strukturvariablen> Beispiel: sPolygon Für weitere Informationen, siehe: Bezeichner vergeben<Name der Komponente> Beispiel: aiStart Beispiel \/\/Declaration type TYPE S_POLYGONLINE : STRUCT aiStart : ARRAY[1..2] OF INT := [-99, -99]...", 
"body" : "Syntax: <Name der Strukturvariablen> . <Name der Komponente> <Name der Strukturvariablen> Beispiel: sPolygon Für weitere Informationen, siehe: Bezeichner vergeben<Name der Komponente> Beispiel: aiStart Beispiel \/\/Declaration type\nTYPE S_POLYGONLINE :\nSTRUCT\n aiStart : ARRAY[1..2] OF INT := [-99, -99];\n aiPoint1 : ARRAY[1..2] OF INT;\n aiPoint2 : ARRAY[1..2] OF INT;\n aiPoint3 : ARRAY[1..2] OF INT;\n aiPoint4 : ARRAY[1..2] OF INT;\n aiEnd : ARRAY[1..2] OF INT := [99, 99];\nEND_STRUCT\nEND_TYPE\n\n\/\/Declaration structure variable\nVAR\n sPolygon : S_POLYGONLINE;\n iPoint : INT;\nEND_VAR\n\n\/\/Implementation\niPoint := sPolygon.aiPoint1[1];\n Für weitere Informationen siehe: STRUCT" }, 
{ "title" : "Zugriff auf Variablen in Programmierbausteinen ", 
"url" : "_cds_operands_variables_accessing_variables.html#UUID-ae836494-8ea7-f000-02ab-8154d9c0ddf6_section-idm4560534545832033962845942743", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Zugriff auf Variablen von Arrays, Strukturen und Bausteinen \/ Zugriff auf Variablen in Programmierbausteinen ", 
"snippet" : "Syntax: <POU Name> . <Variablenname> <POU Name> Name einer Funktionsbausteininstanz ( FUNCTION_BLOCK ) oder eines Programms ( PROGRAM ) Beispiel: fbController Für weitere Informationen, siehe: Bezeichner vergeben<Variablenname> Variable der POU Beispiel: xStart Beispiel FUNCTION_BLOCK FB_Controller ...", 
"body" : "Syntax: <POU Name> . <Variablenname> <POU Name> Name einer Funktionsbausteininstanz ( FUNCTION_BLOCK ) oder eines Programms ( PROGRAM ) Beispiel: fbController Für weitere Informationen, siehe: Bezeichner vergeben<Variablenname> Variable der POU Beispiel: xStart Beispiel FUNCTION_BLOCK FB_Controller\nVAR_INPUT\n xStart : BOOL;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n ControlDriveA : S_CONTROL;\nEND_VAR\nIF xStart = TRUE THEN\n \/\/Symbolic bit access\n ControlDriveA.bitEnableOperation := TRUE;\nEND_IF\n\nPROGRAM PLC_PRG\n fbController : FB_Controller;\nEND_VAR\nfbController();\nfbController.xStart := TRUE; " }, 
{ "title" : "Bitzugriff in Variablen ", 
"url" : "_cds_operands_variables_accessing_bits.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Bitzugriff in Variablen ", 
"snippet" : "Implementeren Sie gleichzeitige Bitzugriffe durch zwei Tasks nur, wenn der Prozessor Bitzugriffe direkt auf dem Speicher ausführen kann. Die x86- und x64-Systeme haben Befehle für den Bitzugriff im Speicher. Systeme wie beispielsweise ARM und PPC können Bitzugriffe nicht direkt auf dem Speicher ausf...", 
"body" : "Implementeren Sie gleichzeitige Bitzugriffe durch zwei Tasks nur, wenn der Prozessor Bitzugriffe direkt auf dem Speicher ausführen kann. Die x86- und x64-Systeme haben Befehle für den Bitzugriff im Speicher. Systeme wie beispielsweise ARM und PPC können Bitzugriffe nicht direkt auf dem Speicher ausführen. Wenn gleichzeitige Bitzugriffe durch zwei Tasks ausgeführt werden, obwohl der Prozessor Bitzugriff nicht direkt auf dem Speicher ausführen kann, gehen Sie wie folgt vor: Verwenden ein Semaphor ( SysSemEnter ) oder eine vergleichbare Technik, um einen konkurrierenden Bitzugriff zu verhindern. Am Besten ist es aber, die Bitzugriffe innerhalb einer Task auszuführen. Mit einem Indexzugriff können einzelne Bits in ganzzahligen Variablen adressiert werden. Mit Hilfe einer Strukturvariablen oder einer Funktionsbaustein-Instanz können einzelne Bits symbolisch adressieret werden. " }, 
{ "title" : "Indexzugriff auf Bits in ganzzahligen Variablen ", 
"url" : "_cds_operands_variables_accessing_bits.html#UUID-d4f7a63b-4e5a-3f52-3bfa-4b1a24fbc724_id_b340eb5aade07af3c0a8640e00aa8f9e_id_14902e5878de741ec0a8652000b1e877", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Bitzugriff in Variablen \/ Indexzugriff auf Bits in ganzzahligen Variablen ", 
"snippet" : "Sie können in ganzzahligen Variablen einzelne Bits adressieren. Dazu hängen Sie an die Variable mit einem Punkt abgetrennt den Index des zu adressierenden Bits an. Der Bitindex kann durch eine beliebige Konstante angegeben werden. Die Indizierung ist 0-basiert. Syntax <integer variable name> . <inde...", 
"body" : "Sie können in ganzzahligen Variablen einzelne Bits adressieren. Dazu hängen Sie an die Variable mit einem Punkt abgetrennt den Index des zu adressierenden Bits an. Der Bitindex kann durch eine beliebige Konstante angegeben werden. Die Indizierung ist 0-basiert. Syntax <integer variable name> . <index>\n<integer data typ> = BYTE | WORD | DWORD | LWORD | SINT | USINT | INT | UINT | DINT | UDINT | LINT | ULINT Beispiel Im Programm wird das dritte Bit der Variablen wA auf den Wert der Variablen xB gesetzt. Die Konstante c_usiENABLE fungiert als Index, um auf das dritte Bit der Variablen iX zuzugreifen. Indexzugriff PROGRAM PLC_PRG\nVAR\n wA : WORD := 16#FFFF;\n xB : BOOL := 0;\nEND_VAR\n\n\/\/ Index access in an integer variable\nwA.2 := xB; Ergebnis: wA = 2#1111_1111_1111_1011 = 16#FFFB Konstante als Index \/\/ GVL declaration\nVAR_GLOBAL CONSTANT\n gc_usiENABLE : USINT := 2;\nEND_VAR\n\nPROGRAM PLC_PRG\nVAR\n iX : INT := 0;\nEND_VAR\n\n\/\/ Constant as index\niX.gc_usiENABLE := TRUE; \/\/ Third bit in iX is set TRUE Ergebnis: iX = 4 " }, 
{ "title" : "Symbolischer Bitzugriff in Strukturvariablen ", 
"url" : "_cds_operands_variables_accessing_bits.html#UUID-d4f7a63b-4e5a-3f52-3bfa-4b1a24fbc724_id_b340eb5aade07af3c0a8640e00aa8f9e_id_747b06aff3f15e7bc0a8646368e7d8a5", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Bitzugriff in Variablen \/ Symbolischer Bitzugriff in Strukturvariablen ", 
"snippet" : "Mit dem Datentyp BIT können Sie einzelne Bits mit einem Namen bezeichnen und zu einer Struktur zusammenfassen. Das Bit wird dann mit dem Komponentennamen adressiert. Beispiel Typdeklaration der Struktur TYPE S_CONTROLLER : STRUCT bitOperationEnabled : BIT; bitSwitchOnActive : BIT; bitEnableOperation...", 
"body" : "Mit dem Datentyp BIT können Sie einzelne Bits mit einem Namen bezeichnen und zu einer Struktur zusammenfassen. Das Bit wird dann mit dem Komponentennamen adressiert. Beispiel Typdeklaration der Struktur TYPE S_CONTROLLER :\nSTRUCT\n bitOperationEnabled : BIT;\n bitSwitchOnActive : BIT;\n bitEnableOperation : BIT;\n bitError : BIT;\n bitVoltageEnabled : BIT;\n bitQuickStop : BIT;\n bitSwitchOnLocked : BIT;\n bitWarning : BIT;\nEND_STRUCT\nEND_TYPE Deklaration und Schreibzugriff auf ein Bit PROGRAM PLC_PRG\nVAR\n ControlDriveA : S_CONTROLLER;\nEND_VAR\n\n\/\/ Symbolic bit access to bitEnableOperation\nControlDriveA.bitEnableOperation := TRUE; " }, 
{ "title" : "Symbolischer Bitzugriff in Funktionsbaustein-Instanzen ", 
"url" : "_cds_operands_variables_accessing_bits.html#UUID-d4f7a63b-4e5a-3f52-3bfa-4b1a24fbc724_id_b340eb5aade07af3c0a8640e00aa8f9e_id_eee44594dd9f930dc0a864637e5e6307", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Bitzugriff in Variablen \/ Symbolischer Bitzugriff in Funktionsbaustein-Instanzen ", 
"snippet" : "In Funktionsbausteinen können Sie Variablen für einzelne Bits deklarieren. Beispiel FUNCTION_BLOCK FB_Controller VAR_INPUT bitSwitchOnActive : BIT; bitEnableOperation : BIT; bitVoltageEnabled : BIT; bitQuickStop : BIT; bitSwitchOnLocked : BIT; END_VAR VAR_OUTPUT bitOperationEnabled : BIT; bitError :...", 
"body" : "In Funktionsbausteinen können Sie Variablen für einzelne Bits deklarieren. Beispiel FUNCTION_BLOCK FB_Controller\nVAR_INPUT\n bitSwitchOnActive : BIT;\n bitEnableOperation : BIT;\n bitVoltageEnabled : BIT;\n bitQuickStop : BIT;\n bitSwitchOnLocked : BIT;\nEND_VAR\nVAR_OUTPUT\n bitOperationEnabled : BIT;\n bitError : BIT;\n bitWarning : BIT;\nEND_VAR\nVAR\nEND_VAR\n;\n\nPROGRAM PLC_PRG\nVAR\n fbController : FB_Controller;\nEND_VAR\n\/\/ Symbolic bit access to bitSwitchOnActive\nfbController(bitSwitchOnActive := TRUE); " }, 
{ "title" : "Partieller Variablenzugriff ", 
"url" : "_cds_partial_access.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Partieller Variablenzugriff ", 
"snippet" : "Der Ausdruck ist konform zur Norm IEC 61131-3. Bei IEC-Variablen vom Datentyp BYTE , WORD , DWORD oder LWORD (Datentyp ANY, ANY_ ) ist ein partieller Variablenzugriff möglich. Syntax: <Variablenname> . % <Partieller Typ> <Partieller Index> Nach dem Punktoperator . ist ein Leerzeichen erlaubt. Nach d...", 
"body" : "Der Ausdruck ist konform zur Norm IEC 61131-3. Bei IEC-Variablen vom Datentyp BYTE , WORD , DWORD oder LWORD (Datentyp ANY, ANY_ ) ist ein partieller Variablenzugriff möglich. Syntax: <Variablenname> . % <Partieller Typ> <Partieller Index> Nach dem Punktoperator . ist ein Leerzeichen erlaubt. Nach dem Prozentzeichen % und nach dem partiellen Typ sind keine Leerzeichen erlaubt. <Variablenname> Name der ANY_BIT -Variable vom Typ BYTE , WORD , DWORD oder LWORD <Partieller Typ> X für BIT -Zugriff B für BYTE -Zugriff W für WORD -Zugriff D für DWORD -Zugriff L für LWORD -Zugriff Der Zugriff auf __XWORD ist ebenfalls zulässig und verhält sich je nach Zeigergröße wie ein DWORD oder LWORD . Der Zugriff auf BOOL ist nicht erlaubt, auch wenn der Datentyp BOOL Teil der ANY_BIT -Typen ist. <Partieller Index> Von 0 bis zum Indexmaximum Für weitere Informationen siehe: Datentyp ANY, ANY_Zugriff auf Variablen von Arrays, Strukturen und Bausteinen" }, 
{ "title" : "Verwendung ", 
"url" : "_cds_partial_access.html#UUID-a998d9b0-535e-4892-deb0-bdf9fa13db54_section-idm4642469513468833961518118731", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Partieller Variablenzugriff \/ Verwendung ", 
"snippet" : "Der partielle Zugriff kann nur für nicht-temporäre Variablen verwendet werden (benutzerdefinierte Variablen, Felder, Array-Zugriffe oder Dereferenzierungen). Für temporäre Ergebnisse oder Literale ist dies nicht erlaubt. Der Ausdruck selbst ist nicht temporär und kann als Ausdruck in REFERENCE TO od...", 
"body" : "Der partielle Zugriff kann nur für nicht-temporäre Variablen verwendet werden (benutzerdefinierte Variablen, Felder, Array-Zugriffe oder Dereferenzierungen). Für temporäre Ergebnisse oder Literale ist dies nicht erlaubt. Der Ausdruck selbst ist nicht temporär und kann als Ausdruck in REFERENCE TO oder als ADR -Operator verwendet werden. Beispiel \/\/ Implementation\nPartialVarB := GVL.Variable.%B0;\nPartialVarX := array[idx].%X0;\nPartialVarW := tempVariable.%W2;\nPartialVarD := ptr^.%D2;\nPartialVarB := variable.%W1.%B1\n\n Bei Funktionsaufrufen, Indexausdrücken, Literalen oder Propertys ist ein partieller Zugriff nicht möglich. Negativbeispiel: FunctionCall().%B0\n(1+index).%B0\n(DWORD#16#12345678).%B0\nProperty.%B0 " }, 
{ "title" : "Indexmaximum der partiellen Typen ", 
"url" : "_cds_partial_access.html#UUID-a998d9b0-535e-4892-deb0-bdf9fa13db54_section-idm464701570986723396146942364", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Partieller Variablenzugriff \/ Indexmaximum der partiellen Typen ", 
"snippet" : "Der partielle Zugriff ist nur möglich, wenn der aufgerufene Ausdruck einen konformen Typ hat und der Teilindex kleiner oder gleich dem maximalen Teilindex ist. Ansonsten wird ein Compilerfehler ausgegeben. Partieller Typ Zugriffstyp Maximum des partiellen Index X BYTE 7 WORD 15 DWORD 31 LWORD 63 B B...", 
"body" : "Der partielle Zugriff ist nur möglich, wenn der aufgerufene Ausdruck einen konformen Typ hat und der Teilindex kleiner oder gleich dem maximalen Teilindex ist. Ansonsten wird ein Compilerfehler ausgegeben. Partieller Typ Zugriffstyp Maximum des partiellen Index X BYTE 7 WORD 15 DWORD 31 LWORD 63 B BYTE 0 WORD 1 DWORD 3 LWORD 7 W BYTE Nicht unterstützt WORD 0 DWORD 1 LWORD 3 D BYTE Nicht unterstützt WORD Nicht unterstützt DWORD 0 LWORD 1 L BYTE Nicht unterstützt WORD Nicht unterstützt DWORD Nicht unterstützt LWORD 0 " }, 
{ "title" : "Ausdruck mit partiellem Zugriff ", 
"url" : "_cds_partial_access.html#UUID-a998d9b0-535e-4892-deb0-bdf9fa13db54_section-idm455129619581923396149212589", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Partieller Variablenzugriff \/ Ausdruck mit partiellem Zugriff ", 
"snippet" : "Der Typ eines partiellen Zugriffsausdrucks hängt nur von <Partieller Typ> ab und muss anhand der folgenden Tabelle ausgewählt werden. Partieller Typ Typ des Ausdrucks X BIT B BYTE W WORD D DWORD L LWORD...", 
"body" : "Der Typ eines partiellen Zugriffsausdrucks hängt nur von <Partieller Typ> ab und muss anhand der folgenden Tabelle ausgewählt werden. Partieller Typ Typ des Ausdrucks X BIT B BYTE W WORD D DWORD L LWORD " }, 
{ "title" : "Adressen ", 
"url" : "_cds_partial_access.html#UUID-a998d9b0-535e-4892-deb0-bdf9fa13db54_section-idm4647015711872033961498739737", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Partieller Variablenzugriff \/ Adressen ", 
"snippet" : "Es ist erlaubt, die Adresse von einem partiellen Zugriffsausdrucks des partiellen Typs B , W , D und L zu bilden. Es ist nicht erlaubt, die Adresse von einem partiellen Zugriffsausdrucks des partiellen Typs X zu bilden. Es ist nicht erlaubt, einen partiellen Zugriffsausdruck vom Typ BIT einer VAR_IN...", 
"body" : "Es ist erlaubt, die Adresse von einem partiellen Zugriffsausdrucks des partiellen Typs B , W , D und L zu bilden. Es ist nicht erlaubt, die Adresse von einem partiellen Zugriffsausdrucks des partiellen Typs X zu bilden. Es ist nicht erlaubt, einen partiellen Zugriffsausdruck vom Typ BIT einer VAR_INOUT -Variablen zuzuweisen. Beispiele ADR(var%.B0)\nreferenceVariable REF= var.%W1\n Negativbeispiel: ADR(var.%X0)\nref REF= var.%X0\n " }, 
{ "title" : "Adressen ", 
"url" : "_cds_operands_addresses.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Adressen ", 
"snippet" : "Wenn Sie Pointer auf Adressen verwenden, können sich beim Online-Change Inhalte von Adressen verschieben! Wenn Sie direkte Adressen verwenden, verschieben sich Inhalte von Adressen beim Online-Change nicht! Syntax: % <Speicherbereichspräfix> <Größenpräfix> <Positionsnummer> . <Bitpositionsnummer> % ...", 
"body" : "Wenn Sie Pointer auf Adressen verwenden, können sich beim Online-Change Inhalte von Adressen verschieben! Wenn Sie direkte Adressen verwenden, verschieben sich Inhalte von Adressen beim Online-Change nicht! Syntax: % <Speicherbereichspräfix> <Größenpräfix> <Positionsnummer> . <Bitpositionsnummer> % <Adresse> Obligatorisch Adresse im Speicherbereich % <Speicherbereichspräfix> <Größenpräfix> <Speicherposition> <Speicherbereichspräfix> Obligatorisch I : Eingangsspeicherbereich Speicherbereich für Eingangssignale, Eingänge (Inputs) Für physikalische Eingänge über Eingangstreiber, Sensoren Q : Ausgangsspeicherbereich Speicherbereich für Ausgangssignale, Ausgänge (Outputs) Für physikalische Ausgänge über Ausgangstreiber, Aktoren M : Merkerspeicherbereich <Größenpräfix> Optional kein Größenpräfix: Bit Einzelnes Bit X : Bit Einzelnes Bit B : Byte 8 Bit Datenbreite W : Word 16 Bit Datenbreite D : Dword 32 Bit Datenbreite <Speicherposition> <Positionsnummer> . <Bitpositionsnummer> Beispiel: %IB2.4 steht für das 5. Bit des 3. Bytes <Positionsnummer> Obligatorisch Die Nummerierung ist zielsystemabhängig, bei 0 beginnend. . <Bitpositionsnummer> Optional 0..7 bei einem Byte Bei der Angabe einer Adresse werden die Position im Speicher und die Größe mittels spezieller Zeichenfolgen ausgedrückt. Eine Adresse ist gekennzeichnet mit dem Prozentzeichen % , dann folgt der Speicherbereichspräfix, der optionale Größenpräfix und die Speicherposition. Die Nummerierung, mit der Sie die Speicherposition adressieren, ist zielsystemabhängig. Beispiele %QX7.5 %Q7.5 Einzelbitadresse des Ausgangsbits 7.5 %IW215 Wortadresse des Eingangsworts 215 %QB7 Bytesdresse des Ausgangsbytes 7 %MD48 Adresse eines Doppelworts an Speicherstelle 48 im Merkerbereich %IW2.5.7.1 Wortadresse eines Eingangsworts, Interpretation abhängig von der aktuellen Steuerungskonfiguration VAR \n wVar AT %IW0 : WORD; \nEND_VAR Variablendeklaration mit Adressangabe eines Eingangsworts VAR \n xActuator AT %QW0 : BOOL; \nEND_VAR Boolesche Variablendeklaration Hinweis: Für boolesche Variable wird intern ein Byte alloziert, wenn keine Einzelbitadresse angegeben ist. Eine Wertänderung von xActuator betrifft folglich den Bereich von QX0.0 bis QX0.7 . VAR \n xSensor AT %IX7.5 : BOOL; \nEND_VAR Boolesche Variablendeklaration mit expliziter Angabe einer Einzelbitadresse Beim Zugriff wird nur das Eingangsbit 7.5 gelesen. " }, 
{ "title" : "Speicherposition ", 
"url" : "_cds_operands_addresses.html#UUID-b62e344d-bf98-39e1-ea00-2b46d5561ef3_id_d533aade45c8fc0a8640e00567983_id_448f942037ed6c03c0a864634fc7f314", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Adressen \/ Speicherposition ", 
"snippet" : "So stellen Sie sicher, dass die Adresse gültig ist: Um in einer Applikation eine gültige Adresse zuzuweisen, muss Ihnen zunächst die geforderte Position im Prozessabbild bekannt sein; das bedeutet der zuständige Speicherbereich: Eingangs- ( I ), Ausgangs- ( Q ) oder Merkerspeicherbereich ( M ), sieh...", 
"body" : "So stellen Sie sicher, dass die Adresse gültig ist: Um in einer Applikation eine gültige Adresse zuzuweisen, muss Ihnen zunächst die geforderte Position im Prozessabbild bekannt sein; das bedeutet der zuständige Speicherbereich: Eingangs- ( I ), Ausgangs- ( Q ) oder Merkerspeicherbereich ( M ), siehe oben. Weiterhin müssen Sie das erforderliche Größenpräfix angeben: Bit, BYTE , WORD , DWORD (siehe oben: X , B , W , D ) Eine entscheidende Rolle spielen die aktuell verwendete Gerätekonfiguration und die Geräteeinstellungen (Hardwarestruktur, Gerätebeschreibung, E\/A-Einstellungen). Beachten Sie insbesondere die Unterschiede in der Interpretation von Bitadressen zwischen Geräten mit Byteadressierung und Geräten mit wordorientierter IEC-Adressierung. Bei der Bitadresse %IX5.5 adressiert die Nummer vor dem Punkt in einem byteadressierten Gerät Byte 5 und in einem wordadressierten Gerät Word 5. Dagegen ist die Adressierung mit Word- oder Byteadresse unabhängig vom Gerätetyp: Mit %IW5 wird immer Word 5 angesprochen und mit Byteadresse %IB5 immer Byte 5. Abhängig von der Größe und dem Adressierungsmodus können Sie deshalb mit der gleichen Adressangabe unterschiedliche Speicherzellen ansprechen. Die folgende Tabelle zeigt die Gegenüberstellung der Byteadressierung und der wordorientierten IEC-Adressierung für Bit, Byte, Word und Double Word. Sie zeigt auch die überlappenden Speicherbereiche bei Byteadressierung. Siehe das Beispiel im Anschluss an die Tabelle. Bei der Syntax ist zu beachten, dass die IEC-Adressierung immer wordorientiert ist. Die Wordnummer steht vor dem Punkt, die Bitnummer nach dem Punkt. n = Bytenummer Beispiel für überlappende Speicherbereiche bei Byteadressierung D0 enthält B0 - B3 . W0 enthält B0 und B1 . W1 enthält B2 und B3 . W2 enthält B4 und B5 . W1 , aber auch D1 , D2 und D3 dürfen nicht zur Adressierung verwendet werden. Dadurch werden Überlappungen vermieden. " }, 
{ "title" : "Funktionen ", 
"url" : "_cds_operands_functions.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Operanden \/ Funktionen ", 
"snippet" : "In ST können Sie einen Funktionsaufruf als Operand verwenden. Beispiel: Result := Fct(7) + 3; TIME()-Funktion Diese Funktion liefert die Zeit auf Millisekunden-Basis, die seit Systemstart vergangen ist. Der Zeitstempel ist vom Datentyp TIME (32 Bit). Nach einem Überlauf beginnt der Wert wieder bei 0...", 
"body" : "In ST können Sie einen Funktionsaufruf als Operand verwenden. Beispiel: Result := Fct(7) + 3; TIME()-Funktion Diese Funktion liefert die Zeit auf Millisekunden-Basis, die seit Systemstart vergangen ist. Der Zeitstempel ist vom Datentyp TIME (32 Bit). Nach einem Überlauf beginnt der Wert wieder bei 0 . Beispiel in ST systime := TIME(); " }, 
{ "title" : "Datentypen ", 
"url" : "_cds_reference_datatypes.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen ", 
"snippet" : "In der Programmierung wird eine Variable über Namen und Speicheradresse im Zielsystems identifiziert. Variablennamen sind Bezeichner, unter denen der zugewiesene Speicherplatz adressiert wird. Die Größe der Variable wird durch ihren Datentyp bestimmt. Dieser gibt an, wie viel Speicherplatz für die V...", 
"body" : "In der Programmierung wird eine Variable über Namen und Speicheradresse im Zielsystems identifiziert. Variablennamen sind Bezeichner, unter denen der zugewiesene Speicherplatz adressiert wird. Die Größe der Variable wird durch ihren Datentyp bestimmt. Dieser gibt an, wie viel Speicherplatz für die Variable reserviert wird und wie die Werte im Speicher zu interpretieren sind. Der Datentyp bestimmt auch, welche Operationen erlaubt sind. Darüber hinaus können Funktionsbausteine instanziiert werden. Funktionsbausteininstanzen belegen ähnlich wie Variablen Speicher. Der Speicherbedarf wird durch den Funktionsbaustein bestimmt. Folgende Gruppen von Datentypen stehen Ihnen zur Verfügung Elementarer Datentyp Ein elementarer Datentyp ist ein Datentyp, der im CODESYS Development System vordefiniert zur Verfügung steht. __UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT | TIME | TOD | TIME_OF_DAY | UDINT | UINT | ULINT | USINT | WORD Außer den in der Norm IEC 61131-3 beschriebenen Datentypen gibt es die CODESYS -spezifischen Datentypen BIT , __UXINT , __XINT und __XWORD . Standarddatentyp Ein Standardtyp (Standarddatentyp) ist ein elementarer Datentyp oder ein Stringdatentyp. __UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT |STRING | TIME | TOD | TIME_OF_DAY | UDINT | UINT | ULINT | USINT | WORD | WSTRING Integer-Datentyp __UXINT | __XINT | __XWORD | BIT | BYTE | DINT | DWORD | INT | LINT | LWORD | SINT | UDINT | UINT | ULINT | USINT | WORD Zeitdatentyp TIME , LTIME Datum- und Uhrzeitdatentyp DATE | DATE_AND_TIME | DT | TIME_OF_DAY | TOD | LDATE | LDATE_AND_TIME | LDT | LTIME_OF_DAY | LTOD Erweiterungen zur Norm IEC 61131-3 Benutzerdefinierte Datentypen TYPEFür weitere Informationen siehe: Bezeichnervergabe" }, 
{ "title" : "Datentyp: BOOL ", 
"url" : "_cds_datatype_bool.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: BOOL ", 
"snippet" : "BOOL Datentyp Werte Speicherplatz BOOL TRUE (1), FALSE (0) 8 Bit...", 
"body" : "BOOL Datentyp Werte Speicherplatz BOOL TRUE (1), FALSE (0) 8 Bit " }, 
{ "title" : "Ganzzahlige Datentypen ", 
"url" : "_cds_datatype_integer.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Ganzzahlige Datentypen ", 
"snippet" : "Integer Bei Typkonvertierungen von größeren zu kleineren Typen können Information verloren gehen. In CODESYS stehen Ihnen folgende ganzzahlige Datentypen zur Verfügung Datentyp Untergrenze Obergrenze Speicherplatz BYTE 0 255 8 Bit WORD 0 65535 16 Bit DWORD 0 4294967295 32 Bit LWORD 0 2 64 -1 64 Bit ...", 
"body" : "Integer Bei Typkonvertierungen von größeren zu kleineren Typen können Information verloren gehen. In CODESYS stehen Ihnen folgende ganzzahlige Datentypen zur Verfügung Datentyp Untergrenze Obergrenze Speicherplatz BYTE 0 255 8 Bit WORD 0 65535 16 Bit DWORD 0 4294967295 32 Bit LWORD 0 2 64 -1 64 Bit SINT -128 127 8 Bit USINT 0 255 8 Bit INT -32768 32767 16 Bit UINT 0 65535 16 Bit DINT -2147483648 2147483647 32 Bit UDINT 0 4294967295 32 Bit LINT -2 63 2 63 -1 64 Bit ULINT 0 2 64 -1 64 Bit Für weitere Informationen siehe: Konstante: Zahl" }, 
{ "title" : "Datentyp: REAL, LREAL ", 
"url" : "_cds_datatype_real.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: REAL, LREAL ", 
"snippet" : "REAL, LREAL Die Datentypen REAL und LREAL sind Gleitpunkttypen nach IEEE 754. Gleitpunkttypen sind nötig bei der Verwendung von Dezimalzahlen und Gleitpunktzahlen in Punktdarstellung oder Exponentialdarstellung. Zielsystem Datentyp Betragsmäßig kleinste Zahl Betragsmäßig größte Zahl Speicherplatz RE...", 
"body" : "REAL, LREAL searchresult_toplevel Die Datentypen REAL und LREAL sind Gleitpunkttypen nach IEEE 754. Gleitpunkttypen sind nötig bei der Verwendung von Dezimalzahlen und Gleitpunktzahlen in Punktdarstellung oder Exponentialdarstellung. Zielsystem Datentyp Betragsmäßig kleinste Zahl Betragsmäßig größte Zahl Speicherplatz REAL 1.0E-44 3.402823E+38 32 Bit LREAL 4.94065645841247E-324 1.7976931348623157E+308 64 Bit Beispiel PROGRAM PLC_PRG\nVAR\n rMax: REAL := 3.402823E+38; \/\/ Largest number\n rPosMin : REAL := 1.0E-44; \/\/ Smallest positve number\n rNegMax: REAL := -1.0E-44; \/\/ Largest negative number\n rMin: REAL := -3.402823E+38; \/\/ Smallest number\n\n lrMax: LREAL := 1.7976931348623157E+308; \/\/ Largest number\n lrPosMin : LREAL := 4.94065645841247E-324; \/\/ Smallest positve number\n lNegMax: LREAL := -4.94065645841247E-324; \/\/ Largest negative number\n lrMin: LREAL := -1.7976931348623157E+308; \/\/ Smallest number\nEND_VAR Die Unterstützung des Datentyps LREAL hängt vom verwendeten Zielgerät ab. Bitte sehen Sie in der zugehörigen Dokumentation, ob der 64-Bit-Typ LREAL beim Übersetzen der Applikation in REAL konvertiert wird oder als LREAL erhalten bleibt. Bei einer Konvertierung können nämlich Informationsverluste auftreten. Wenn der Wert der REAL \/ LREAL -Zahl außerhalb des Wertebereichs des Integers liegt, wird bei einer Datentypkonvertierung von REAL oder LREAL nach SINT , USINT , INT , UINT , DINT , UDINT , LINT oder ULINT ein undefiniertes Ergebnis geliefert. Das Ergebnis ist vom Zielsystem abhängt. Auch ein Ausnahmefehler ist möglich!  Um zielsystemunabhängigen Code zu erhalten, muss die Applikation Wertebereichsüberschreitungen abfangen. Wenn die REAL \/ LREAL -Zahl innerhalb des Wertebereichs des ganzzahligen Datentyps liegt, arbeitet die Konvertierung auf allen Systemen gleich. " }, 
{ "title" : "Datentyp: STRING ", 
"url" : "_cds_datatype_string.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: STRING ", 
"snippet" : "STRING Bei einer Latin-1-Kodierung ist der für eine STRING -Variable benötigte Speicherplatz immer 1 Byte pro Zeichen plus ein zusätzliches Byte. Das ergibt beispielsweise 81 Bytes im Falle einer standardmäßigen STRING(80) -Deklaration. Bei einer UTF-8-Kodierung kann ein Zeichen bis zu 4 Byte lang s...", 
"body" : "STRING searchresult_toplevel Bei einer Latin-1-Kodierung ist der für eine STRING -Variable benötigte Speicherplatz immer 1 Byte pro Zeichen plus ein zusätzliches Byte. Das ergibt beispielsweise 81 Bytes im Falle einer standardmäßigen STRING(80) -Deklaration. Bei einer UTF-8-Kodierung kann ein Zeichen bis zu 4 Byte lang sein. Die Länge des Strings gibt aber immer die Anzahl der Bytes an, die für den STRING reserviert werden. Somit gibt es keine 1 : 1 Beziehung mehr zwischen Zeichenanzahl und Stringlänge. Der Datentyp STRING wird als Latin-1 oder UTF-8 interpretiert: Wenn die Compile-Option UTF8-Kodierung für STRING aktiviert ist, werden alle Stringliterale im UTF-8-Format interpretiert. Deklaration: <varible name> : STRING( <size> ) := ' <text> '; <varible name> : STRING[ <size> ] := ' <text> '; Die Speichergröße <size> und die Initialisierung sind optional. Beispiel sVar : STRING(46):= 'This is a string with memory for 46 characters.';\nsVar_µ : STRING[10] := 'µ (Mü)';\nsVar_ß : STRING[10] := 'Eszett'; Eine Variable des Datentyps STRING kann eine beliebige Zeichenkette aufnehmen. Die Größenangabe <size> zur Speicherplatz-Reservierung bei der Deklaration bezieht sich auf die Anzahl an Bytes und steht in runden oder eckigen Klammern. Ist keine Größe angegeben, werden standardmäßig 80 Zeichen reserviert. Wenn eine Variable mit einem Literal initialisiert wird, das zu lang für den Datentyp der Variablen ist, wird das Literal von hinten her entsprechend abgeschnitten. Die Länge der Strings ist aber nicht grundsätzlich begrenzt. Wenn Sie Stringmanipulationen mit den Funktionen der Bibliothek Standard ausführen lassen, werden Strings bis zu einer Länge von 255 korrekt verarbeitet. Wenn Sie Stringmanipulationen mit den Funktionen der Bibliothek StringUtils ausführen lassen, können Sie auch längere Strings (>255 Zeichen) verwenden. Wenn eine Variable des Datentyps STRING durch einen Reset der Applikation neu initialisiert wird, wird der nach dem abschließenden Nullzeichen des Initialwerts vorhandene Inhalt des (alten) Strings nicht überschrieben. Dies gilt sowohl für die Initialisierung mit dem Initialisierungswert als auch für die Initialisierung mit dem Standard-Initialisierungswert 0. Ab Compilerversion 3.5.18.0 haben Sie die Möglichkeit das Kodierungsformat von Strings auszuwählen. Sie haben die Möglichkeit projektweit festzulegen, ob Strings im Latin-1-Format oder im UTF-8-Format interpretiert werden. Aktivieren Sie für die UTF-8-Kodierung die Compile-Option UTF8-Kodierung für STRING . Für weitere Informationen siehe: Compile-Optionen und UTF-8-KodierungBevor Sie das Kodierungsformat umstellen, ist es ratsam, ihren Code auf Regel SA0175 statisch analysieren zu lassen. Für weitere Informationen siehe: Static Analysis LightErgänzen Sie die Deklaration einer Variablen um das Pragma {attribute 'monitoring_encoding' := 'UTF8'} , dann können Sie den Inhalt der Variablen in UTF8-Kodierung monitoren. Für weitere Informationen siehe: Pragma monitoring_encoding" }, 
{ "title" : "Datentyp: TIME, LTIME ", 
"url" : "_cds_datatype_time.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: TIME, LTIME ", 
"snippet" : "Intern wird der Zeitdatentyp TIME wie ein DWORD behandelt. Bei TIME führt das zu einer Auflösung in Millisekunden. Intern wird der Zeitdatentyp LTIME wie ein LWORD behandelt. Bei LTIME führt das zu einer Auflösung in Nanosekunden. Sie können den Datentyp LTIME als Zeitbasis für hochauflösende Timer ...", 
"body" : "Intern wird der Zeitdatentyp TIME wie ein DWORD behandelt. Bei TIME führt das zu einer Auflösung in Millisekunden. Intern wird der Zeitdatentyp LTIME wie ein LWORD behandelt. Bei LTIME führt das zu einer Auflösung in Nanosekunden. Sie können den Datentyp LTIME als Zeitbasis für hochauflösende Timer verwenden. Ein hochauflösender Timer hat eine Auflösung in Nanosekunden. Datentyp Untergrenze Obergrenze Speicherplatz Auflösung Beschreibung TIME T#0MS T#49D17H2M47S295MS 32 Bit Millisekunden Syntax: TIME#xDxHxMxSxMS Syntax: TIME#xdxhxmxsxms Syntax: T#xDxHxMxSxMS Syntax: T#xdxhxmxsxms LTIME LTIME#0NS LTIME#213503D23H34M33S709MS551US615NS 64 Bit Nanosekunden Syntax: LTIME#xDxHxMxSxMSxUSxNS Syntax: LTIME#xdxhxmxsxmsxusxna Beispiel T#1D2H3M4S\nT#49D17H2M47S295MS\nLTIME#1000D15H23M12S34ms2us44ns\nLTIME#213503D23H34M33S709MS551US615NS Für weitere Informationen siehe: Konstante: TIME, LTIME, TIME, LTIME" }, 
{ "title" : "Datentyp: DATE ", 
"url" : "_cds_datatype_date_and_time_of_day.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: DATE ", 
"snippet" : "Die Datentypen für Datum und Uhrzeit DATE , DATE_AND_TIME ( DT ) und TIME_OF_DAY ( TOD ) werden intern wie ein DWORD (32-Bit-Wert) behandelt. Die Datentypen LDATE , LDATE_AND_TIME ( LDT ) und LTIME_OF_DAY ( LTOD ) werden intern wie ein LWORD (64-Bit-Wert) behandelt. Datentyp Untergrenze Default Ober...", 
"body" : "Die Datentypen für Datum und Uhrzeit DATE , DATE_AND_TIME ( DT ) und TIME_OF_DAY ( TOD ) werden intern wie ein DWORD (32-Bit-Wert) behandelt. Die Datentypen LDATE , LDATE_AND_TIME ( LDT ) und LTIME_OF_DAY ( LTOD ) werden intern wie ein LWORD (64-Bit-Wert) behandelt. Datentyp Untergrenze Default Obergrenze Speicherplatz Auflösung Beschreibung DATE D#1970-01-01 D#2106-02-07 32 Bit Sekunden, obwohl nur der Tag angezeigt wird Syntax: DATE#jjj-MM-dd Syntax: D#jjj-MM-dd DATE_AND_TIME DT DT#1970-1-1-0:0:0 DT#2106-2-7-6:28:15 32 Bit Sekunden Syntax: DATE_AND_TIME#jjj-MM-dd-hh:mm:ss Syntax: DT#jjj-MM-dd-hh:mm:ss TIME_OF_DAY TOD TOD#0:0:0 TOD#23:59:59.999 32 Bit Millisekunden Syntax: TIME_OF_DAY#hh:mm:ss Syntax: TOD#hh:mm:ss.sss LDATE LD#1677-9-22 LD#1970-01-01 LDATE#2262-4-11 64 Bit Nanosekunden, obwohl nur der Tag angezeigt wird Syntax: LDATE#jjj-MM-dd LDATE_AND_TIME LDT LDT#1677-9-21-0:12:43.145224192 LDT#1970-1-1-0:0:0 LDT#2262-4-11-23:47:16.854775807 64 Bit Nanosekunden Syntax: LDATE_AND_TIME##jjj-MM-dd-hh:mm:ss.sssssssss Syntax: LDT##jjj-MM-dd-hh:mm:ss.sssssssss LTIME_OF_DAY LTOD LTOD##0:0:0 LTOD#23:59:59.999999999 64 Bit Nanosekunden Syntax: LTIME_OF_DAY#hh:mm:ss.sssssssss Syntax: LTOD#hh:mm:ss.sssssssss Beispiel VAR\n \/\/Date\n dateBottom : DATE := DATE#1970-1-1;\n dateTop : DATE := DATE#2106-2-7;\n dateAppointment : DATE := D#2020-2-7; \/\/ D as data type prohibited\n\n \/\/Date and time\n dtBottom : DATE_AND_TIME := DATE_AND_TIME#1970-1-1-0:0:0;\n dtTop : DT := DATE_AND_TIME#2106-02-07-06:28:15;\n dtAppointment : DT := DT#2020-2-7-12:55:1.234;\n\n \/\/Time of day\n todBottom : TIME_OF_DAY := TIME_OF_DAY#0:0:0;\n todTop : TOD := TIME_OF_DAY#23:59:59.999;\n todAppointment : TOD := TOD#12:3:4.567;\n\n \/\/ Long date\n ldateBottom : LDATE := LDATE#1970-1-1;\n ldateTop : LDATE := LDATE#2106-2-7;\n ldateAppointment : LDATE := LD#2020-2-7; \/\/ LD as data typ prohibited\n\n \/\/ Long date and time\n ldtBottom : LDATE_AND_TIME := LDATE_AND_TIME#1970-1-1-0:0:0;\n ldtTop : LDT := LDATE_AND_TIME#2262-4-10-23:34:33.709551615;\n ldtAppointment : LDT := LDT#2020-2-7-12:55:1.234567891;\n\n \/\/Long time of day\n ltodBottom : LTIME_OF_DAY := LTIME_OF_DAY#0:0:0;\n ltodTop : LTOD := LTIME_OF_DAY#23:59:59.999999999 ;\n ltodAppointment : LTOD := LTOD#12:3:4.567890123;\n\nEND_VAR Für weitere Informationen siehe: Konstante: Datum und Uhrzeit , DATE, DT, TOD, LDATE, LDT, LTOD" }, 
{ "title" : "Datentyp: ANY, ANY_ <Typ> ", 
"url" : "_cds_datatype_any.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: ANY, ANY_ <Typ> ", 
"snippet" : "ANY, ANY_ <Typ> Die Datentypen ANY oder ANY_ <Typ> werden in Schnittstellen von Funktionen, Funktionsbausteinen oder Methoden verwendet, um Eingangsparameter, deren Typ unbekannt oder beliebig ist, formal zu typisieren: Die Eingangsvariablen ( VAR_INPUT ) haben einen generischen Datentyp. Der Compil...", 
"body" : "ANY, ANY_ <Typ> Die Datentypen ANY oder ANY_ <Typ> werden in Schnittstellen von Funktionen, Funktionsbausteinen oder Methoden verwendet, um Eingangsparameter, deren Typ unbekannt oder beliebig ist, formal zu typisieren: Die Eingangsvariablen ( VAR_INPUT ) haben einen generischen Datentyp. Der Compiler ersetzt den Typ der Eingangsvariable intern mit der unten beschriebenen Datenstruktur, wobei der Wert nicht direkt übergeben wird. Stattdessen wird ein Zeiger auf den eigentlichen Wert übergeben, weswegen nur eine Variablen übergeben werden kann. Erst beim Aufruf wird also der Datentyp konkretisiert. Aufrufe solcher Programmierbausteine können daher mit Argumenten, die jeweils unterschiedliche Datentypen haben, erfolgen. Literale, ersetzte Konstanten und Ergebnisse von Funktionsaufrufen oder Ausdrücken können nicht an Eingangsvariablen ( VAR_IN_OUT ) übergeben werden. Aufruf Die Syntaxbeschreibungen beziehen sich auf einen Programmierbaustein mit genau einem Parameter, dem ein Argument übergeben wird. Der Datentyp des Arguments konkretisiert dabei den generischen Datentyp der Eingangsvariable. Beispielsweise können Argumente des Typs BYTE, WORD, DWORD, LWORD an eine ANY_BIT -Eingangsvariable übergeben werden. Syntax Funktionsaufruf: <Name der Funktion> ( <Argument> )\n Syntax Funktionsbausteinaufruf <Name der Funktinonsbausteininstanz> ( <Name der Eingangsvariable> := <Argument> ) Syntax Methodenaufruf <Name der Funktionsbausteininstanz> . <Name der Methode> ( <Name der Eingangsvariable> := <Argument> ) <Argument> Übergabevariable Beispiel PROGRAM PLC_PRG\nVAR\n byValue : BYTE := 16#AB;\n iValue : INT := -1234;\n xResultByte : BOOL;\n xResultInt : BOOL;\n\n fbComputeAnyByte : FB_ComputeAny;\n fbComputeAnyInt : FB_ComputeAny;\n\n fbComputeM1 : FB_ComputeMethod;\n fbComputeM2 : FB_ComputeMethod;\n\n byN : BYTE := 1;\n wBitField1 : WORD := 16#FFFF;\n wBitField2 : WORD := 16#0001;\n xInit : BOOL;\n xResult : BOOL;\nEND_VAR\n\n\/\/Implementation\nxResultByte := funComputeAny(byValue);\nxResultInt := funComputeAny(iValue);\n\nxResult := funGenericCompare(wBitField1, wBitField2);\n\nfbComputeAnyByte(anyInput1 := byValue);\nfbComputeAnyInt(anyInput1 := iValue);\n\nfbComputeM1.methComputeAnny(anyInput1 := byValue);\nfbComputeM2.methComputeAnny(anyInput1 := iValue);\n " }, 
{ "title" : "Interne Datenstruktur bei ANY und ANY_ <Typ> ", 
"url" : "_cds_datatype_any.html#UUID-08811461-dc3a-9612-9aa1-9d1b22125df5_id_ed37729bef786cc0a8640e01c41bef_id_fd745cdad9e24e11c0a8646350ca1289", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: ANY, ANY_ <Typ> \/ Interne Datenstruktur bei ANY und ANY_ <Typ> ", 
"snippet" : "Beim Übersetzen des Codes werden die Eingangsvariablen mit ANY -Datentyp intern durch die folgende Struktur typisiert. Bei Aufruf des Programmierbausteins (zur Laufzeit) wird das Argument an einen Referenzparameter übergeben. TYPE AnyType : STRUCT \/\/ Type of the current parameter typeclass : __SYSTE...", 
"body" : "Beim Übersetzen des Codes werden die Eingangsvariablen mit ANY -Datentyp intern durch die folgende Struktur typisiert. Bei Aufruf des Programmierbausteins (zur Laufzeit) wird das Argument an einen Referenzparameter übergeben. TYPE AnyType :\nSTRUCT\n \/\/ Type of the current parameter\n typeclass : __SYSTEM.TYPE_CLASS ;\n \/\/ Pointer to the current parameter\n pvalue : POINTER TO BYTE;\n \/\/ Size of the data to which the pointer points\n diSize : DINT;\nEND_STRUCT\nEND_TYPE Über diese Struktur können Sie innerhalb des Programmierbausteins auf die Eingangsvariable zugreifen und beispielsweise den übergebenen Wert abfragen. Beispiel Die Funktion vergleicht, ob zwei Eingangsvariablen den gleichen Typ und den gleichen Wert haben. FUNCTION funGenericCompare : BOOL\n\/\/ Declaration\nVAR_INPUT\n any1 : ANY;\n any2 : ANY;\nEND_VAR\nVAR\n pTest : POINTER TO ARRAY [0..100] OF POINTER TO DWORD;\n diCount: DINT;\nEND_VAR\n\n\/\/ Implementation\npTest := ADR(any1);\nGeneric_Compare := FALSE;\nIF any1.typeclass <> any2.typeclass THEN\n RETURN;\nEND_IF\nIF any1.diSize <> any2.diSize THEN\n RETURN;\nEND_IF\n\/\/ Byte comparison\nFOR iCount := 0 TO any1.diSize-1 DO\n IF any1.pvalue[iCount] <> any2.pvalue[iCount] THEN\n RETURN;\n END_IF\nEND_FOR\nGeneric_Compare := TRUE;\nRETURN;\n " }, 
{ "title" : "Deklaration ", 
"url" : "_cds_datatype_any.html#UUID-08811461-dc3a-9612-9aa1-9d1b22125df5_id_ed37729bef786cc0a8640e01c41bef_id_5fb6e029d9e24e20c0a864630acc6b04", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: ANY, ANY_ <Typ> \/ Deklaration ", 
"snippet" : "Die Syntaxbeschreibungen beziehen sich auf einen Programmierbaustein mit genau einem Parameter (eine Eingangsvariable). Syntax <Gültigkeitsbereich> <POU-Name> : <Datentyp des Rückgabewerts> VAR_INPUT <Variablenname> : <Generischer Datentyp> ; END_VAR <Gültigkeitsbereich> Mögliche Gültigkeitsbereiche...", 
"body" : "Die Syntaxbeschreibungen beziehen sich auf einen Programmierbaustein mit genau einem Parameter (eine Eingangsvariable). Syntax <Gültigkeitsbereich> <POU-Name> : <Datentyp des Rückgabewerts> \nVAR_INPUT\n <Variablenname> : <Generischer Datentyp> ;\nEND_VAR\n <Gültigkeitsbereich> Mögliche Gültigkeitsbereiche: FUNCTION FUNCTION_BLOCK METHOD <POU-Name> Name der POU : <Datentyp des Rückgabewerts> Optional <Variablenname> Name der Eingangsvariable <Generischer Datentyp> ANY , ANY_BIT , ANY_DATE , ANY_NUM , ANY_REAL , ANY_INT oder ANY_STRING Beispiel FUNCTION funComputeAny : BOOL\nVAR_INPUT\n anyInput1 : ANY; \/\/ For valid data type see table\nEND_VAR\n\nFUNCTION_BLOCK FB_ComputeAny\nVAR_INPUT\n anyInput1 : ANY;\nEND_VAR\n\nFUNCTION_BLOCK FB_ComputeMethod\nMETHOD methComputeAnny : BOOL\nVAR_INPUT\n anyInput1 : ANY_INT; \/\/ Valid data types are SINT, INT, DINT, LINT, USINT, UINT, UDINT, ULINT\nEND_VAR Ab Compilerversion >= 3.5.1.0 werden die in der Tabelle dargestellten generischen IEC-Datentypen unterstützt. Die Tabelle stellt die Hierarchie der generischen Datentypen dar und gibt Auskunft, welcher generische Datentyp des formalen Parameters (Deklaration) welche elementaren Datentypen des Arguments (Aufruf) erlaubt. Generischer Datentyp beim formalen Parameter Erlaubter elementarer Datentyp beim tatsächlichen Parameter (Argument) ANY ANY_BIT BYTE WORD DWORD LWORD ANY_DATE DATE DATE_AND_TIME , DT TIME_OF_DAY , TOD LDATE LDATE_AND_TIME , LDT LTIME_OF_DAY , LTOD ANY_NUM ANY_REAL REAL , LREAL ANY_INT USINT , UINT , UDINT , ULINT SINT , INT , DINT , LINT ANY_STRING STRING , WSTRING " }, 
{ "title" : "Datentyp: WSTRING ", 
"url" : "_cds_datatype_wstring.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: WSTRING ", 
"snippet" : "WSTRING Gemäß der Norm IEC 61131-3 folgt der Datentyp WSTRING der UCS-2 Kodierung. UCS-2-Kodierung bedeutet, dass ein Zeichen exakt mit der festen Länge von 2 Bytes kodiert wird. UCS-2 umfasst die Zeichen der Codepunkte von U+0000 bis U+D7FF und von U+E000 bis U+FFFF . Der String wird mit 0 terminie...", 
"body" : "WSTRING searchresult_toplevel Gemäß der Norm IEC 61131-3 folgt der Datentyp WSTRING der UCS-2 Kodierung. UCS-2-Kodierung bedeutet, dass ein Zeichen exakt mit der festen Länge von 2 Bytes kodiert wird. UCS-2 umfasst die Zeichen der Codepunkte von U+0000 bis U+D7FF und von U+E000 bis U+FFFF . Der String wird mit 0 terminiert. Deklaration: <variable name> : WSTRING( <size> ) := \" <text> \" Die Größe <size> bestimmt die Stringlänge. Die Initialisierung erfolgt mit der Zeichenkette \" <text> \" . Die Kennzeichnung der Zeichenkette als WSTRING erfolgt mit doppelten Anführungszeichen. Die Angabe der Größe und die Initialisierung sind optional. Wenn eine Variable des Datentyps WSTRING durch einen Reset der Applikation neu initialisiert wird, werden die nach dem abschließenden Null-Wort ( WORD ) des Initialwerts vorhandenen Byte-Paare des (alten) Strings nicht überschrieben. Dies gilt sowohl für die Initialisierung mit dem Initialisierungswert als auch für die Initialisierung mit dem Standard-Initialisierungswert 0. Beispiel Strings des Datentyps WSTRING benötigen 2 Bytes pro Zeichen. Bei Datentyp STRING wird nur 1 Byte pro Zeichen reserviert. wsString : WSTRING := \"This is a WSTRING\";\nsString : STRING := 'This is a STRING'; wsEmpty ist der Leerstring. Die Variable wsMoney mit dem Eurozeichen € hat die Größe 10. Nach 10 Zeichen wird abgeschnitten. Der Variablen wsHan wird das chinesisches Zeichen (U+7BE6) zugewiesen. PROGRAM PRG_Money\nVAR\n wsEmpty : WSTRING := \"\"; \/\/ The empty string\n wsMoney : WSTRING(10) := \"12345678 € 123\"; \/\/ String will be truncated\n wsMoney_2 : WSTRING(10) := \"12345678 €\";\n wsHan : WSTRING(10) := \"篦\"; \/\/ Chinese character U+\/BE6\nEND_VAR " }, 
{ "title" : "Datentyp: BIT ", 
"url" : "_cds_datatype_bit.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: BIT ", 
"snippet" : "BIT Der Datentyp BIT ist nur in Strukturen zur Deklaration von Strukturkomponenten oder in einem Funktionsbaustein zur Deklaration von Variablen gültig. Eine BIT -Variable kann die Werte TRUE (1) und FALSE (0) annehmen. Dabei benötigt die Variable genau ein Bit Speicherplatz. Sie können damit einzel...", 
"body" : "BIT searchresult_toplevel Der Datentyp BIT ist nur in Strukturen zur Deklaration von Strukturkomponenten oder in einem Funktionsbaustein zur Deklaration von Variablen gültig. Eine BIT -Variable kann die Werte TRUE (1) und FALSE (0) annehmen. Dabei benötigt die Variable genau ein Bit Speicherplatz. Sie können damit einzelne Bits symbolisch über einen Namen adressieren. BIT -Variablen, die nacheinander deklariert sind, werden in Bytes zusammengefasst. Dadurch können Sie im Vergleich zu BOOL -Typen, die jeweils mindestens 8 Bits belegen, den Speicherverbrauch optimieren. Allerdings benötigt der Bitzugriff wesentlich mehr Zeit. Deshalb sollten Sie den Datentyp BIT nur verwenden, wenn Sie die Daten in genau vorgegebenem Format definieren wollen. " }, 
{ "title" : "Datentyp: __UXINT, __XINT, __XWORD ", 
"url" : "_cds_datatype_uxint_xword.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: __UXINT, __XINT, __XWORD ", 
"snippet" : "__UXINT, __XINT, __XWORD Variablen mit diesen Spezialdatentypen werden zielsystemabhängig in einen plattformkonformen Datentyp konvertiert. CODESYS unterstützt Systeme mit Adressregistern von 32 Bit Breite und 64 Bit Breite. Um den IEC-Code soweit als möglich vom Zielsystem unabhängig zu machen, kön...", 
"body" : "__UXINT, __XINT, __XWORD Variablen mit diesen Spezialdatentypen werden zielsystemabhängig in einen plattformkonformen Datentyp konvertiert. CODESYS unterstützt Systeme mit Adressregistern von 32 Bit Breite und 64 Bit Breite. Um den IEC-Code soweit als möglich vom Zielsystem unabhängig zu machen, können Sie die Pseudo-Datentypen __UXINT , __XINT und __XWORD verwenden. Der Compiler prüft, welcher Zielsystemtyp aktuell verwendet wird und konvertiert diese Datentypen entsprechend in die passenden Standard-Datentypen. Außerdem stehen für Variablen dieses Datentyps Typkonvertierungsoperatoren zur Verfügung. Pseudodatentyp Typkonvertierung auf 64-Bit-Plattformen Typkonvertierung auf 32-Bit-Plattformen __UXINT ULINT UDINT __XINT LINT DINT __XWORD LWORD DWORD " }, 
{ "title" : "Datentyp: POINTER TO ", 
"url" : "_cds_datatype_pointer.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: POINTER TO ", 
"snippet" : "POINTER TO Ein Pointer speichert zur Laufzeit die Speicheradresse von Objekten wie beispielsweise Variablen oder Funktionsbaustein-Instanzen. Syntax der Pointer-Deklaration: <pointer name>: POINTER TO <data type> | <data unit type> | <function block name> ; FUNCTION_BLOCK FB_Point VAR piNumber: POIN...", 
"body" : "POINTER TO searchresult_toplevel Ein Pointer speichert zur Laufzeit die Speicheradresse von Objekten wie beispielsweise Variablen oder Funktionsbaustein-Instanzen. Syntax der Pointer-Deklaration: <pointer name>: POINTER TO <data type> | <data unit type> | <function block name> ; FUNCTION_BLOCK FB_Point\nVAR\n piNumber: POINTER TO INT;\n iNumber1: INT := 5;\n iNumber2: INT;\nEND_VAR\npiNumber := ADR(iNumber1); \/\/ piNumber is assigned to address of iNumber1\niNumber2 := piNumber^; \/\/ value 5 of iNumber1 is assigned to variable iNumber2 by dereferencing of pointer piNumber Einen Pointer zu dereferenzieren bedeutet, den Wert zu erhalten, auf den der Pointer zeigt. Ein Pointer wird dereferenziert, indem der Inhaltsoperator ^ an den Pointer-Bezeichner angehängt wird, beispielsweise piNumber^ im oben gezeigten Beispiel. Um einem Pointer die Adresse eines Objekts zuzuweisen, wird auf das Objekt der Adressoperator ADR angewendet: ADR(iNumber1) Im Onlinebetrieb können Sie mit dem Gehe zu Referenzvon einem Pointer zur Deklarationsstelle des referenzierten Objekts springen. Wenn ein Pointer auf einen E\/A-Eingang zeigt, gilt der Zugriff als schreibender Zugriff. Dies führt bei der Codeerzeugung zur Compilerwarnung ' <pointer name > ' ist kein gültiges Zuordnungsziel . Beispiel: pwInput := ADR(wInput); Wenn Sie ein Konstrukt dieser Art benötigen, müssen Sie den Eingangswert ( wInput ) zuerst auf eine Variable mit Schreibzugriff kopieren. " }, 
{ "title" : "Indexzugriff auf Pointer ", 
"url" : "_cds_datatype_pointer.html#UUID-ae92281b-697e-83f6-386d-2290b407c800_id_ca488150a6a89ac0a8640e013d12b7_id_bb51ee8bee2b020bc0a864632ddf450d", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: POINTER TO \/ Indexzugriff auf Pointer ", 
"snippet" : "CODESYS erlaubt den Indexzugriff [] auf Variablen vom Typ POINTER TO , ebenso wie auf die Datentypen STRING oder WSTRING . Auf die Daten, auf die der Pointer zeigt, kann auch zugegriffen werden, indem der Klammeroperator [] an den Pointer-Bezeichner angehängt wird, beispielsweise piData[i] . Der Bas...", 
"body" : "CODESYS erlaubt den Indexzugriff [] auf Variablen vom Typ POINTER TO , ebenso wie auf die Datentypen STRING oder WSTRING . Auf die Daten, auf die der Pointer zeigt, kann auch zugegriffen werden, indem der Klammeroperator [] an den Pointer-Bezeichner angehängt wird, beispielsweise piData[i] . Der Basisdatentyp des Pointers bestimmt den Datentyp und die Größe der indizierten Komponente. Der Indexzugriff auf den Pointer erfolgt dabei arithmetisch, indem zur Adresse des Pointers der indexabhängige Offset i * SIZEOF( <base type> ) addiert wird. Gleichzeitig wird der Pointer implizit dereferenziert. Berechnung: piData[i] := (piData + i * SIZEOF(INT))^; Das ist nicht : piData[i] != (piData + i)^; Indexzugriff STRING Wenn Sie den Indexzugriff bei einer Variablen vom Typ STRING verwenden, erhalten Sie das Zeichen am Offset des Indexausdrucks. Das Ergebnis ist vom Typ BYTE . Beispielsweise gibt sData[i] das i-te Zeichen der Zeichenkette sData als SINT (ASCII) zurück. Indexzugriff WSTRING Wenn Sie den Indexzugriff bei einer Variablen vom Typ WSTRING verwenden, erhalten Sie das Zeichen am Offset des Indexausdrucks. Das Ergebnis ist vom Typ WORD . Beispielsweise gibt wsData[i] das i-te Zeichen der Zeichenkette als INT (Unicode) zurück. Referenzen und Pointer auf BIT -Variablen sind ungültige Deklarationen, ebenso wie Arraykomponenten mit Basistyp BIT . " }, 
{ "title" : "Pointer subtrahieren ", 
"url" : "_cds_datatype_pointer.html#UUID-ae92281b-697e-83f6-386d-2290b407c800_id_ca488150a6a89ac0a8640e013d12b7_id_d85f8909ea809296c0a8646357089285", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: POINTER TO \/ Pointer subtrahieren ", 
"snippet" : "Das Ergebnis der Differenz zweier Pointer ist ein Wert vom Typ DWORD , auch auf64-Bit-Plattformen, wenn die Pointer 64-Bit-Pointer sind. Die Verwendung von Referenzen hat den Vorteil dass Typsicherheit garantiert ist. Das ist bei Pointern nicht der Fall. Der Speicherzugriff von Pointern während der ...", 
"body" : "Das Ergebnis der Differenz zweier Pointer ist ein Wert vom Typ DWORD , auch auf64-Bit-Plattformen, wenn die Pointer 64-Bit-Pointer sind. Die Verwendung von Referenzen hat den Vorteil dass Typsicherheit garantiert ist. Das ist bei Pointern nicht der Fall. Der Speicherzugriff von Pointern während der Laufzeit kann durch die implizite Überwachungsfunktion CheckPointer geprüft werden. " }, 
{ "title" : "Datentyp: REFERENCE TO ", 
"url" : "_cds_datatype_reference.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: REFERENCE TO ", 
"snippet" : "REFERENCE TO Mit Compilerversion >= V3.3.0.0 werden Referenzen (mit 0) initialisiert. Wenn eine Referenz auf einen Geräteeingang verweist, gilt der Zugriff als schreibender Zugriff. Dies führt bei der Codeerzeugung zu der Compilerwarnung ...kein gültiges Zuordnungsziel . Beispiel: rInput REF= Input;...", 
"body" : "REFERENCE TO searchresult_toplevel Mit Compilerversion >= V3.3.0.0 werden Referenzen (mit 0) initialisiert. Wenn eine Referenz auf einen Geräteeingang verweist, gilt der Zugriff als schreibender Zugriff. Dies führt bei der Codeerzeugung zu der Compilerwarnung ...kein gültiges Zuordnungsziel . Beispiel: rInput REF= Input; Wenn Sie ein Konstrukt dieser Art benötigen, müssen Sie den Eingangswert, beispielsweise rInput , zuerst auf eine Variable mit Schreibzugriff kopieren. Eine Referenz mit dem Datentyp REFERENCE verweist implizit auf ein anderes Objekt. Die Zuweisung erfolgt mit dem Operator REF= . Beim Zugriff wird die Referenz implizit dereferenziert, und benötigt deswegen keinen speziellen Inhaltsoperator ^ wie ein Pointer. Syntax <identifier> : REFERENCE TO <data type> ;\n<data type>: base type of the reference Gültige Deklaration PROGRAM PLC_PRG\nVAR\n rspeA : REFERENCE TO DUT_SPECIAL;\n pspeA : POINTER TO DUT_SPECIAL;\n speB : DUT_SPECIAL;\nEND_VAR\nrspeA REF= speB; \/\/ Reference rspeA is alias for speB. The code corresponds to pspeA := ADR(speB);\nrspeA := speD; \/\/ The code corresponds to pspeA^ := speD; Ungültige Deklarationen ariTest : ARRAY[0..9] OF REFERENCE TO INT;\npriTest : POINTER TO REFERENCE TO INT;\nrriTest : REFERENCE TO REFERENCE TO INT;\nrbitTest : REFERENCE TO BIT; Ein Referenztyp darf nicht als Basistyp eines Arrays, Pointers oder einer Referenz verwendet werden. Außerdem darf eine Referenz nicht auf eine Bit-Variable verweisen. Solche Konstrukte erzeugen Compilerfehler. Die Lesbarkeit eines Programms wird erschwert, wenn gleichzeitig über einen Bezeichner und dessen Alias auf die gleiche Speicherzelle zugegriffen wird. Beispiel: speB und rspeA Referenzen und Pointer auf BIT -Variablen sind ungültige Deklarationen, ebenso wie Arraykomponenten mit Basistyp BIT . Beispiele Wenn Referenzen mit := zugewiesen, wird immer ein Wert kopiert, egal ob die Referenz links, rechts oder auf beiden Seiten steht: Ref := value schreibt den Wert value and die Stelle, auf die die Referenz verweist. In Pointerschreibweise Ref^ := value value := Ref schreibt den Wert auf den die Referenz verweist nach value . In Pointerschreibweise value := Ref^ Ref1 := Ref2 schreibt den Wert, auf den Ref2 verweist, an die Stelle, auf die Ref1 verweist. In Pointerschreibweise Ref1^ := Ref2^ Wenn REF= verwendet wird, wird immer die Adresse übernommen und es muss eine Referenz auf der linken Seite stehen: Ref REF= value : Die Referenz verweist auf value . In Pointerschreibweise Ref :=ADR(value) Ref1 REF= Ref2 : Ref1 verweist auf den gleichen Wert wie Ref2 . In Pointerschreibweise Ref1 := Ref2 Value REF = Ref führt zu einem Compilefehler In der Deklaration verhält sich REFERENCE TO INT REF= value wie REFERENCE TO INT := value . " }, 
{ "title" : "Vergleich von Referenz und Pointer ", 
"url" : "_cds_datatype_reference.html#UUID-bbf067d0-f5c8-c60a-7bd0-cfeb6b1879c8_id_e9675c6450b1e354c0a8640e011c35ec_id_7cb25b01cab174b8c0a86463367a259c", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: REFERENCE TO \/ Vergleich von Referenz und Pointer ", 
"snippet" : "Eine Referenz hat gegenüber einem Pointer folgende Vorteile: Einfachere Nutzung: Eine Referenz kann direkt, ohne Dereferenzierung auf die Inhalte des referenzierten Objekts zugreifen. Schönere und einfachere Syntax bei Übergabe von Werten: Aufruf eines Funktionsbausteins, der statt einem Pointer ein...", 
"body" : "Eine Referenz hat gegenüber einem Pointer folgende Vorteile: Einfachere Nutzung: Eine Referenz kann direkt, ohne Dereferenzierung auf die Inhalte des referenzierten Objekts zugreifen. Schönere und einfachere Syntax bei Übergabe von Werten: Aufruf eines Funktionsbausteins, der statt einem Pointer eine Referenz ohne Adressoperator übergibt Beispiel: fbDoIt(riInput:=iValue); statt: fbDoIt_1(piInput:=ADR(iValue)); Typsicherheit: Der Compiler prüft bei der Zuweisung zweier Referenzen, ob deren Basistypen übereinstimmen. Bei Pointern wird dies nicht geprüft. " }, 
{ "title" : "Referenz auf Gültigkeit prüfen ", 
"url" : "_cds_datatype_reference.html#UUID-bbf067d0-f5c8-c60a-7bd0-cfeb6b1879c8_id_e9675c6450b1e354c0a8640e011c35ec_id_8030529aea123829c0a8646368002330", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: REFERENCE TO \/ Referenz auf Gültigkeit prüfen ", 
"snippet" : "Sie können den Operator __ISVALIDREF verwenden, um zu prüfen, ob eine Referenz auf einen gültigen Wert verweist, das heißt auf einen Wert ungleich 0. Syntax <boolean variable name> := __ISVALIDREF( <reference name> ); <reference name> : mit REFERENCE TO deklarierter Bezeichner Die boolesche Variable...", 
"body" : "Sie können den Operator __ISVALIDREF verwenden, um zu prüfen, ob eine Referenz auf einen gültigen Wert verweist, das heißt auf einen Wert ungleich 0. Syntax <boolean variable name> := __ISVALIDREF( <reference name> ); <reference name> : mit REFERENCE TO deklarierter Bezeichner Die boolesche Variable wird TRUE , wenn die Referenz auf einen gültigen Wert zeigt, andernfalls FALSE . PROGRAM PLC_PRG\nVAR\n iAlfa : INT;\n riBravo : REFERENCE TO INT;\n riCharlie : REFERENCE TO INT;\n bIsRef_Bravo : BOOL := FALSE;\n bIsRef_Charlie : BOOL := FALSE;\nEND_VAR\niAlfa := iAlfa + 1;\nriBravo REF= iAlfa;\nriCharlie REF= 0;\nbIsRef_Bravo := __ISVALIDREF(riBravo); (* becomes TRUE, because riBravo references to iAlfa, which is non-zero *)\nbIsRef_Charlie := __ISVALIDREF(riCharlie); (* becomes FALSE, because riCharlie is set to 0 *) Die implizite Überwachungsfunktion Checkpointer wirkt ab Compiler-Version 3.5.7.40 auf Variablen vom Typ REFERENCE TO in gleicher Weise wie auf Pointervariablen. " }, 
{ "title" : "Datentyp: ARRAY OF ", 
"url" : "_cds_datatype_array.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: ARRAY OF ", 
"snippet" : "ARRAY OF Ein Array ist eine Sammlung von Datenelementen des gleichen Datentyps. Es werden ein- und mehrdimensionale Arrays von fester oder variabler Länge unterstützt....", 
"body" : "ARRAY OF searchresult_toplevel Ein Array ist eine Sammlung von Datenelementen des gleichen Datentyps. Es werden ein- und mehrdimensionale Arrays von fester oder variabler Länge unterstützt. " }, 
{ "title" : "Eindimensionales Array mit fester Länge ", 
"url" : "_cds_datatype_array.html#UUID-ce9d7e29-a882-1174-ca9c-9117bd3cb42b_id_afe6bda193f4f1e8c0a8640e018f0592_id_b5dd0603c8cd5e60c0a864636e8b5a53", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: ARRAY OF \/ Eindimensionales Array mit fester Länge ", 
"snippet" : "Sie können Arrays im Deklarationsteil einer POU oder in globalen Variablenlisten deklarieren. Syntax der Deklaration eines eindimensionalen Arrays: <variable name> : ARRAY[ <dimension> ] OF <data type> := <initialization> ; <variable name> Name des Arrays Beispiel: aiCounter <dimension> Dimension (u...", 
"body" : "Sie können Arrays im Deklarationsteil einer POU oder in globalen Variablenlisten deklarieren. Syntax der Deklaration eines eindimensionalen Arrays: <variable name> : ARRAY[ <dimension> ] OF <data type> := <initialization> ;\n <variable name> Name des Arrays Beispiel: aiCounter <dimension> Dimension (unterer bis obere Indexgrenze) Beispiel: 1..100 Eine Dimension kann beliebig viele indizierte Elemente haben, bestimmt durch die untere und die obere Indexgrenze Die Indexgrenzen sind ganzzahlige Zahlen, maximal des Datentyps DINT . <data type> Datentyp eines Elements: Elementarer Datentyp Benutzerdefiinierter Datentyp Funktionsbaustein Referenzen und Pointer auf BIT -Variablen sind ungültige Deklarationen, ebenso wie Arraykomponenten mit Basistyp BIT . <initialization> Optional Initialwerte des Arrays Eindimensionales Array von 10 Integerelementen VAR\n aiCounter : ARRAY[0..9] OF INT;\nEND_VAR Untere Indexgrenze: 0 Obere Indexgrenze: 9 Initialisierung für die 10 Elemente: aiCounter : ARRAY[0..9] OF INT := [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]; Datenzugriff iLocalVariable := aiCounter[2]; Der lokalen Variablen wird der Wert 20 zugewiesen. " }, 
{ "title" : "Mehrdimensionales Array fester Länge ", 
"url" : "_cds_datatype_array.html#UUID-ce9d7e29-a882-1174-ca9c-9117bd3cb42b_section-idm4611103852920032708558820554", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: ARRAY OF \/ Mehrdimensionales Array fester Länge ", 
"snippet" : "<variable name> : ARRAY[ <1st dimension> , <next dimensions> ] OF <data type> := <initialization> ; <variable name> [ <index of 1st dimension> , <index of next dimensions> ] <1st dimension> Erste Dimension (unterer Indexgrenze bis obere Indexgrenze) , <next dimensions> Die nächsten Dimensionen (durc...", 
"body" : "<variable name> : ARRAY[ <1st dimension> , <next dimensions> ] OF <data type> := <initialization> ;\n <variable name> [ <index of 1st dimension> , <index of next dimensions> ]\n <1st dimension> Erste Dimension (unterer Indexgrenze bis obere Indexgrenze) , <next dimensions> Die nächsten Dimensionen (durch Komma separiert) Syntax bei Datenzugriff <index of 1st dimension> Indexgrenze der ersten Dimension , <next dimensions> Indexgrenze der nächsten Dimensionen Zweidimensionales Array VAR\n aiCardGame : ARRAY[1..2, 3..4] OF INT;\nEND_VAR 1te Dimension: 1 bis 2 (2 Arrayelemente) 2te Dimension: 3 bis 4 (2 Arrayelemente) Initialisierung für die 2 * 2 Elemente: aiCardGame : ARRAY[1..2, 3..4] OF INT := [2(10),2(20)]; \/\/ Short notation for [10, 10, 20, 20] Datenzugriff iLocal_1 := aiCardGame[1, 3]; \/\/ Assignment of 10\niLocal_2 := aiCardGame[2, 4]; \/\/ Assignment of 20 Dreidimensionales Array VAR\n aiCardGame : ARRAY[1..2, 3..4, 5..6] OF INT;\nEND_VAR 1te Dimension: 1 bis 2 2te Dimension: 3 bis 4 3te Dimension: 5 bis 6 2 * 2 * 2 = 8 Arrayelemente Initialisierung aiCardGame : ARRAY[1..2, 3..4, 5..6] OF INT := [10, 20, 30, 40, 50, 60, 70, 80]; Datenzugriff iLocal_1 := aiCardGame[1, 3, 5]; \/\/ Assignment of 10\niLocal_2 := aiCardGame[2, 3, 5]; \/\/ Assignment of 20\niLocal_3 := aiCardGame[1, 4, 5]; \/\/ Assignment of 30\niLocal_4 := aiCardGame[2, 4, 5]; \/\/ Assignment of 40\niLocal_5 := aiCardGame[1, 3, 6]; \/\/ Assignment of 50\niLocal_6 := aiCardGame[2, 3, 6]; \/\/ Assignment of 60\niLocal_7 := aiCardGame[1, 4, 6]; \/\/ Assignment of 70\niLocal_8 := aiCardGame[2, 4, 6]; \/\/ Assignment of 80 Initialisierung aiCardGame : ARRAY[1..2, 3..4, 5..6] OF INT := [2(10), 2(20), 2(30), 2(40)]; \/\/ Short notation for [10, 10, 20, 20, 30, 30, 40, 40] Datenzugriff iLocal_1 := aiCardGame[1, 3, 5]; \/\/ Assignment of 10\niLocal_2 := aiCardGame[2, 3, 5]; \/\/ Assignment of 10\niLocal_3 := aiCardGame[1, 4, 5]; \/\/ Assignment of 20\niLocal_4 := aiCardGame[2, 4, 5]; \/\/ Assignment of 20\niLocal_5 := aiCardGame[1, 3, 6]; \/\/ Assignment of 30\niLocal_6 := aiCardGame[2, 3, 6]; \/\/ Assignment of 30\niLocal_7 := aiCardGame[1, 4, 6]; \/\/ Assignment of 40\niLocal_8 := aiCardGame[2, 4, 6]; \/\/ Assignment of 40 Dreidimensionales Array einer benutzerdefinierten Struktur TYPE DATA_A\nSTRUCT\n iA_1 : INT;\n iA_2 : INT;\n dwA_3 : DWORD;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n aData_A : ARRAY[1..3, 1..3, 1..10] OF DATA_A;\nEND_VAR Das Array aData_A besteht aus insgesamt 3 * 3 * 10 = 90 Arrayelementen des Datentyps DATA_A . Teilweise initialisieren aData_A : ARRAY[1..3, 1..3, 1..10] OF DATA_A \n := [(iA_1 := 1, iA_2 := 10, dwA_3 := 16#00FF),(iA_1 := 2, iA_2 := 20, dwA_3 := 16#FF00),(iA_1 := 3, iA_2 := 30, dwA_3 := 16#FFFF)]; Im Beispiel werden nur der ersten 3 Elemente explizit initialisiert. Elemente, denen explizit kein Initialisierungswert zugewiesen wird, werden intern mit dem Standardwert des Basisdatentyps initialisiert. Somit werden die Strukturkomponenten ab dem Element aData_A[2, 1, 1] mit 0 initialisiert. Datenzugriff iLocal_1 := aData_A[1,1,1].iA_1; \/\/ Assignment of 1\ndwLocal_2 := aData_A[3,1,1].dwA_3; \/\/ Assignment of 16#FFFF Array eines Funktionsbausteins FUNCTION BLOCK FBObject_A\nVAR\n iCounter : INT;\nEND_VAR\n...\n;\n\nPROGRAM PLC_PRG\nVAR\n aObject_A : ARRAY[1..4] OF FBObject_A;\nEND_VAR Das Array aObject_A besteht aus 4 Elementen. Jedes Element instanziert einen Funktionsbaustein FBObject_A . Funktionsaufruf aObject_A[2](); Zweidimensionales Array eines Funktionsbausteins Implementierung von FB_Something mit Methode FB_Init FUNCTION_BLOCK FB_Something\nVAR\n _nId : INT;\n _lrIn : LREAL;\nEND_VAR\n...\n METHOD FB_Init : BOOL\n VAR_INPUT\n bInitRetains : BOOL;\n bInCopyCode : BOOL;\n nId : INT;\n lrIn : LREAL;\n END_VAR\n _nId := nId;\n _lrIn := lrIN; Der Funktionsbaustein FB_Something hat eine Methode FB_Init , die 2 Parameter benötigt. Instanzierung des Arrays mit Initialisierung PROGRAM PLC_PRG\nVAR\n fb_Something_1 : FB_Something(nId := 11, lrIn := 33.44);\n a_Something : ARRAY[0..1, 0..1] OF FB_Something[(nId := 12, lrIn := 11.22), (nId := 13, lrIn := 22.33), (nId := 14, lrIn := 33.55),(nId := 15, lrIn := 11.22)];\nEND_VAR Beachten Sie die Möglichkeit, während der Laufzeit die Einhaltung der Indexgrenzen durch die implizite Überwachungsfunktion   CheckBounds() zu kontrollieren. " }, 
{ "title" : "Array von Arrays ", 
"url" : "_cds_datatype_array.html#UUID-ce9d7e29-a882-1174-ca9c-9117bd3cb42b_id_afe6bda193f4f1e8c0a8640e018f0592_id_b66cd6345f6ee346c0a864636bd344c4", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: ARRAY OF \/ Array von Arrays ", 
"snippet" : "Die Deklaration eines „Array von Arrays“ ist eine alternative Schreibweise für multidimensionale Arrays. Eine Sammlung von Elementen wird dabei verschachtelt, statt die Elemente zu dimensionieren. Die Schachteltiefe kann beliebig sein. Syntax bei Deklaration <variable name> : ARRAY[ <any dimension> ...", 
"body" : "Die Deklaration eines „Array von Arrays“ ist eine alternative Schreibweise für multidimensionale Arrays. Eine Sammlung von Elementen wird dabei verschachtelt, statt die Elemente zu dimensionieren. Die Schachteltiefe kann beliebig sein. Syntax bei Deklaration <variable name> : ARRAY[ <any dimension> ] OF ARRAY[ <any dimension> ] OF <data type> := <initialization> ;\n Syntax bei Datenzugriff <variable name> [<index of first array> ] [<index of next array> ]\n <variable name> Name des Arrays Beispiel: aaaiCounter ARRAY[ <any dimension> ] OF ARRAY[ <any dimension> ] OF ARRAY[ <any dimension> ] OF Dreifach verschachteltes Array Beispiel: ARRAY[1..2, 1..3] OF ARRAY[1..3] OF ARRAY[1..4] OF ARRAY[1..5] Die Schachteltiefe kann beliebig sein. <data type> Datentyp eines Elements: Elementarer Datentyp Benutzerdefiinierter Datentyp Funktionsbaustein <initialization> Optional Initialwerte für das verschachtelte Array PROGRAM PLC_PRG\nVAR\n aiPoints : ARRAY[1..2,1..3] OF INT := [1,2,3,4,5,6];\n ai2Boxes : ARRAY[1..2] OF ARRAY[1..3] OF INT := [ [1, 2, 3], [ 4, 5, 6]];\n ai3Boxes : ARRAY[1..2] OF ARRAY[1..3] OF ARRAY[1..4] OF INT := [ [ [1, 2, 3, 4], [5, 6, 7, 8 ], [9, 10, 11, 12] ], [ [13, 14, 15, 16], [ 17, 18, 19, 20], [21, 22, 23, 24] ] ];\n ai4Boxes : ARRAY[1..2] OF ARRAY[1..3] OF ARRAY[1..4] OF ARRAY[1..5] OF INT;\nEND_VAR\n\naiPoints[1, 2] := 1200;\nai2Boxes[1][2] := 1200; Die Variablen aiPoints und ai2Boxes sammeln die gleichen Datenelemente, aber die Schreibweisen bei der Deklaration und beim Datenzugriff unterscheiden sich. " }, 
{ "title" : "Array mit variabler Länge ", 
"url" : "_cds_datatype_array.html#UUID-ce9d7e29-a882-1174-ca9c-9117bd3cb42b_id_afe6bda193f4f1e8c0a8640e018f0592_id_05960a2f604f5f86c0a8646342ab6f03", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: ARRAY OF \/ Array mit variabler Länge ", 
"snippet" : "In Funktionsbausteinen, Funktionen oder Methoden können Sie im Deklarationsabschnitt VAR_IN_OUT Arrays mit variabler Länge deklarieren. Um zur Laufzeit die Indexgrenzen des tatsächliche verwendeten Arrays zu ermitteln, stehen Ihnen die Operatoren LOWER_BOUND und UPPER_BOUND zur Verfügung. An ein Arr...", 
"body" : "In Funktionsbausteinen, Funktionen oder Methoden können Sie im Deklarationsabschnitt VAR_IN_OUT Arrays mit variabler Länge deklarieren. Um zur Laufzeit die Indexgrenzen des tatsächliche verwendeten Arrays zu ermitteln, stehen Ihnen die Operatoren LOWER_BOUND und UPPER_BOUND zur Verfügung. An ein Array mit variabler Länge dürfen nur statisch deklarierte, nicht mit Hilfe des Operators __NEW erzeugte Arrays übergeben werden. Syntax der Deklaration eines eindimensionalen Arrays mit variabler Länge <variable name> : ARRAY[*] OF <data type> := <initialization> ;\n <variable name> Name des Arrays Beispiel: aMyVariableArray <data type> Datentyp eines Elements: Elementarer Datentyp Benutzerdefiinierter Datentyp Funktionsbaustein <initialization> Optional Initialwerte für den Array von Arrays Syntax der Deklaration eines mehrdimensionalen Arrays mit variabler Länge <variable name> : ARRAY[*, *] OF <data type> := <initialization> ;\n <variable name> Name des Arrays Beispiel: aMyVariableArray ARRAY[*, *] Deklaration für einen zweidimensionalen Array variabler Länge Formal steht ein Stern für jede Dimension variable Länge. Die Dimensionen sind mit Komma separiert. Erlaubt sind beliebig viele Dimensionen variabler Länge. Syntax der Operatoren zur Grenzindexberechnung LOWER_BOUND( <variable name> , <dimension number> )\nUPPER_BOUND( <variable name> , <dimension number> ) Die Funktion SUM addiert die Integerwerte der Arrayelemente und gibt als Ergebnis die ermittelte Summe zurück. Die Summe wird über alle zur Laufzeit vorhandenen Arrayelemente berechnet. Da die tatsächliche Anzahl an Arrayelementen erst zur Laufzeit bekannt sein wird, wird die lokale Variable als eindimensionales Array variabler Länge deklariert. FUNCTION SUM: INT;\nVAR_IN_OUT\n aiData : ARRAY[*] OF INT;\nEND_VAR\nVAR\n diCounter : DINT;\n iResult : INT;\nEND_VAR\n\niResult := 0;\nFOR diCounter := LOWER_BOUND(aiData, 1) TO UPPER_BOUND(aiData, 1) DO \/\/ Calculates the length of the current array\n iResult := iResult + aiData[diCounter];\nEND_FOR;\nSUM := iResult; " }, 
{ "title" : "Benutzerdefinierter Datentyp TYPE ", 
"url" : "_cds_datatype_type.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE ", 
"snippet" : "TYPE...", 
"body" : "TYPE " }, 
{ "title" : "Datenstruktur: STRUCT ", 
"url" : "_cds_datatype_structure.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Datenstruktur: STRUCT ", 
"snippet" : "STRUCT Eine Struktur ist ein benutzerdefinierter Datentyp, der mehrere Variablen mit beliebigen Datentypen zu einer logischen Einheit zusammenfasst. Die innerhalb einer Struktur deklarierten Variablen werden Komponenten bezeichnet. Die Typdeklaration einer Struktur nehmen Sie in einem DUT -Objekt vo...", 
"body" : "STRUCT Eine Struktur ist ein benutzerdefinierter Datentyp, der mehrere Variablen mit beliebigen Datentypen zu einer logischen Einheit zusammenfasst. Die innerhalb einer Struktur deklarierten Variablen werden Komponenten bezeichnet. Die Typdeklaration einer Struktur nehmen Sie in einem DUT -Objekt vor, das Sie über das Menü Projekt → Objekt hinzufügen → DUT oder über das Kontextmenü einer Applikation anlegen. Für weitere Informationen siehe: DUT" }, 
{ "title" : "Syntax ", 
"url" : "_cds_datatype_structure.html#UUID-95d29ac7-011e-01bb-9b0e-097f1f196365_section-idm234801371238798", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Datenstruktur: STRUCT \/ Syntax ", 
"snippet" : "TYPE <structure name> STRUCT     <member name> : <data type> := <initialization> ; END_STRUCT END_TYPE <structure name> Dieser Bezeichner ist im gesamten Projekt gültig, so dass Sie ihn wie einen Standarddatentyp verwenden können. <member name> : <data type> ; Deklaration einer Komponente Es können ...", 
"body" : "TYPE <structure name> STRUCT     <member name> : <data type> := <initialization> ; END_STRUCT END_TYPE <structure name> Dieser Bezeichner ist im gesamten Projekt gültig, so dass Sie ihn wie einen Standarddatentyp verwenden können. <member name> : <data type> ; Deklaration einer Komponente Es können beliebig viele Deklarationen folgen, mindestens jedoch 2. Weiterhin können Sie Strukturen verschachteln. Das bedeutet, dass Sie eine Strukturkomponente mit einem bestehenden Strukturtypen deklarieren. Dabei ist die einzige Beschränkung, dass Sie der Variablen (Strukturkomponente) keine Adressen zuweisen dürfen. Die AT -Deklaration ist hier nicht zulässig. := <initialization> Optional Typdeklaration TYPE S_POLYGONLINE :\nSTRUCT\n aiStart : ARRAY[1..2] OF INT := [-99, -99];\n aiPoint1 : ARRAY[1..2] OF INT;\n aiPoint2 : ARRAY[1..2] OF INT;\n aiPoint3 : ARRAY[1..2] OF INT;\n aiPoint4 : ARRAY[1..2] OF INT;\n aiEnd : ARRAY[1..2] OF INT := [99, 99];\nEND_STRUCT\nEND_TYPE " }, 
{ "title" : "Erweitern einer Typdeklaration ", 
"url" : "_cds_datatype_structure.html#UUID-95d29ac7-011e-01bb-9b0e-097f1f196365_id_b2e3e6da93f532b0c0a8640e011c7a1d_id_0f4f7c7b39401232c0a8640e0030157d", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Datenstruktur: STRUCT \/ Erweitern einer Typdeklaration ", 
"snippet" : "Ausgehend von einer bestehenden Struktur wird eine weitere Struktur deklariert. Die erweiterte Struktur besitzt zusätzlich zu den eigenen Komponenten die gleichen Strukturkomponenten wie die Basisstruktur. Syntax TYPE <structure name> EXTENDS <base structure> STRUCT     <member declaration> END_STRU...", 
"body" : "Ausgehend von einer bestehenden Struktur wird eine weitere Struktur deklariert. Die erweiterte Struktur besitzt zusätzlich zu den eigenen Komponenten die gleichen Strukturkomponenten wie die Basisstruktur. Syntax TYPE <structure name> EXTENDS <base structure> STRUCT     <member declaration> END_STRUCT END_TYPE Beispiel Typdeklaration S_PENTAGON TYPE S_PENTAGON EXTENDS S_POLYGONLINE :\nSTRUCT\n aiPoint5 : ARRAY[1..2] OF INT;\nEND_STRUCT\nEND_TYPE " }, 
{ "title" : "Deklaration und Initialisierung von Strukturvariablen ", 
"url" : "_cds_datatype_structure.html#UUID-95d29ac7-011e-01bb-9b0e-097f1f196365_id_b2e3e6da93f532b0c0a8640e011c7a1d_id_51c8c615dae0fa66c0a8640e0071defa", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Datenstruktur: STRUCT \/ Deklaration und Initialisierung von Strukturvariablen ", 
"snippet" : "Beispiel PROGRAM progLine VAR sPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]); sPentagon : S_PENTAGON := (aiStart:=[0,0], aiPoint1:=[1,1], aiPoint2:=[2,2], aiPoint3:=[3,3], aiPoint4:=[4,4], aiPoint5:=[5,5], aiEnd:=[0,0]);...", 
"body" : "Beispiel PROGRAM progLine\nVAR\n sPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n sPentagon : S_PENTAGON := (aiStart:=[0,0], aiPoint1:=[1,1], aiPoint2:=[2,2], aiPoint3:=[3,3], aiPoint4:=[4,4], aiPoint5:=[5,5], aiEnd:=[0,0]);\nEND_VAR Sie dürfen keine Initialisierungen mit Variablen verwenden. Ein Beispiel für die Initialisierung eines Arrays einer Struktur finden Sie auf der Hilfeseite zu Datentyp ARRAY OF. " }, 
{ "title" : "Zugriff auf eine Strukturkomponente ", 
"url" : "_cds_datatype_structure.html#UUID-95d29ac7-011e-01bb-9b0e-097f1f196365_id_b2e3e6da93f532b0c0a8640e011c7a1d_id_a8aa433778b4bcc1c0a8640e00eb4380", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Datenstruktur: STRUCT \/ Zugriff auf eine Strukturkomponente ", 
"snippet" : "Sie greifen auf eine Strukturkomponente gemäß folgender Syntax zu: <variable name> . <member name> Beispiel PROGRAM prog_Polygon VAR sPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]); iPoint : INT; END_VAR \/\/ Assigs 5 to ai...", 
"body" : "Sie greifen auf eine Strukturkomponente gemäß folgender Syntax zu: <variable name> . <member name> Beispiel PROGRAM prog_Polygon\nVAR\n sPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n iPoint : INT;\nEND_VAR \/\/ Assigs 5 to aiPoint\niPoint := sPolygon.aiPoint1[1]; Ergebnis: iPoint = 5 " }, 
{ "title" : "Symbolischer Bitzugriff in Strukturvariablen ", 
"url" : "_cds_datatype_structure.html#UUID-95d29ac7-011e-01bb-9b0e-097f1f196365_id_b2e3e6da93f532b0c0a8640e011c7a1d_id_d5b32f89e566c6fcc0a8646322497f5b", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Datenstruktur: STRUCT \/ Symbolischer Bitzugriff in Strukturvariablen ", 
"snippet" : "Sie können eine Struktur mit Variablen des Datentyps BIT deklarieren, um einzelne Bits zu einer logischen Einheit zusammenzufassen. Dann können Sie einzelne Bits symbolisch über einen Namen (statt über den Bitindex) adressieren. Syntax Deklaration TYPE <structure name> : STRUCT     <member name> : B...", 
"body" : "Sie können eine Struktur mit Variablen des Datentyps BIT deklarieren, um einzelne Bits zu einer logischen Einheit zusammenzufassen. Dann können Sie einzelne Bits symbolisch über einen Namen (statt über den Bitindex) adressieren. Syntax Deklaration TYPE <structure name> : STRUCT     <member name> : BIT; END_STRUCT END_TYPE Syntax Bitzugriff <structure name> . <member name> Beispiel Typdeklaration TYPE S_CONTROL :\nSTRUCT\n bitOperationEnabled : BIT;\n bitSwitchOnActive : BIT;\n bitEnableOperation : BIT;\n bitError : BIT;\n bitVoltageEnabled : BIT;\n bitQuickStop : BIT;\n bitSwitchOnLocked : BIT;\n bitWarning : BIT;\nEND_STRUCT\nEND_TYPE Bitzugriff FUNCTION_BLOCK FB_Controller\nVAR_INPUT\n xStart : BOOL;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n ControlDriveA : S_CONTROL;\nEND_VAR\n\nIF xStart = TRUE THEN\n \/\/ Symbolic bit access\n ControlDriveA.bitEnableOperation := TRUE;\nEND_IF\n\nPROGRAM PLC_PRG\n fbController : FB_Controller;\nEND_VAR\n fbController();\nfbController.xStart := TRUE; Für weitere Informationen siehe Bitzugriff in VariablenReferenzen und Pointer auf BIT -Variablen sind ungültige Deklarationen, ebenso wie Arraykomponenten mit Basistyp BIT . " }, 
{ "title" : "Enumeration ", 
"url" : "_cds_datatype_enum.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Enumeration ", 
"snippet" : "Eine Enumeration oder Aufzählung ist ein benutzerdefinierter Datentyp, der sich aus einer kommaseparierten Liste von Komponenten (Enumerationswerte) zusammensetzt, um benutzerdefinierte Variablen zu deklarieren. Die Deklaration einer Enumeration nehmen Sie in einem DUT -Objekt vor, das Sie über den ...", 
"body" : "searchresult_toplevel Eine Enumeration oder Aufzählung ist ein benutzerdefinierter Datentyp, der sich aus einer kommaseparierten Liste von Komponenten (Enumerationswerte) zusammensetzt, um benutzerdefinierte Variablen zu deklarieren. Die Deklaration einer Enumeration nehmen Sie in einem DUT -Objekt vor, das Sie über den Befehl Objekt hinzufügen im Projekt angelegt haben. Im Applikationscode können Sie die Enumerationskomponenten wie konstante Variablen verwenden, deren Bezeichner <enumeration name>.<component name> global im Projekt bekannt sind. Für weitere Informationen siehe: DUT" }, 
{ "title" : "Deklaration ", 
"url" : "_cds_datatype_enum.html#UUID-1311dba6-f878-87c0-5628-03d3a9b811e5_id_c02c7c93f57fccc0a8640e014fa9b7_id_addb6d4f1efde45ac0a8646363edf874", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Enumeration \/ Deklaration ", 
"snippet" : "Syntax {attribute 'strict'} TYPE <ennumeration name> : (     <member name> := <value> ) <base data type> := <initialization> ; END_TYPE {attribute 'strict'} Optional Das Pragma bewirkt, dass eine strenge Typprüfung, so wie unten beschrieben, durchgeführt wird. Das Pragma ist optional, wird aber empf...", 
"body" : "Syntax {attribute 'strict'} TYPE <ennumeration name> : (     <member name> := <value> ) <base data type> := <initialization> ; END_TYPE {attribute 'strict'} Optional Das Pragma bewirkt, dass eine strenge Typprüfung, so wie unten beschrieben, durchgeführt wird. Das Pragma ist optional, wird aber empfohlen. <enumeration name> Name der Enumeration, der im Code als Datentyp verwendet werden kann Beispiel: COLOR_BASIC     <member name> := <initial value> Beliebig viele, aber mindestens zwei Komponenten Eine Enumeration ist eine durch Komma separierte Liste von Komponentennamen in runden Klammern. Die letzte Komponente vor der schließenden runden Klammer benötigt kein Komma. Alle Komponenten haben den gleichen Datentyp. Die Werte der Komponenten werden automatisch initialisiert: Beginnend bei 0 werden die Werte fortlaufend um 1 inkrementiert. Sie können den einzelnen Komponente aber auch explizit einen festen Initialwert zuweisen. Beispiel: yellow := 1 <base data type> Optional Sie können explizit einen der folgenden Basisdatentypen zuweisen: INT | UINT | SINT | USINT | DINT | UDINT | LINT | ULINT | BYTE | WORD | DWORD | LWORD Default: INT := <initialization> Optional Eine der Komponenten kann explizit als initiale Komponente deklariert werden. Default: Falls keine explizite Initialisierung angegeben ist, wird automatisch mit der obersten Komponente initialisiert. Beispiel {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE COLOR_BASIC :\n(\n yellow,\n green,\n blue,\n black\n) \/\/ Basic data type is INT, default initialization for all COLOR_BASIC variables is yellow\n;\nEND_TYPE " }, 
{ "title" : "Enumeration mit explizitem Basisdatentyp ", 
"url" : "_cds_datatype_enum.html#UUID-1311dba6-f878-87c0-5628-03d3a9b811e5_id_c02c7c93f57fccc0a8640e014fa9b7_id_eeaeeade1efde45ac0a864636eafe5b8", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Enumeration \/ Enumeration mit explizitem Basisdatentyp ", 
"snippet" : "Erweiterungen zur Norm IEC 61131-3 Der Basisdatentyp bei einer Enumerationsdeklaration ist standardmäßig INT . Sie können aber auch Enumerationen deklarieren, die explizit auf einen anderen ganzzahligen Datentypen basieren. Beispiel Enumeration mit Basisdatentyp DWORD TYPE COLOR : ( white := 16#FFFF...", 
"body" : "Erweiterungen zur Norm IEC 61131-3 Der Basisdatentyp bei einer Enumerationsdeklaration ist standardmäßig INT . Sie können aber auch Enumerationen deklarieren, die explizit auf einen anderen ganzzahligen Datentypen basieren. Beispiel Enumeration mit Basisdatentyp DWORD TYPE COLOR :\n(\n white := 16#FFFFFF00,\n yellow := 16#FFFFFF00,\n green := 16#FF00FF00,\n blue := 16#FF0000FF,\n black := 16#88000000\n) DWORD := black\n; \/\/ Basic data type is DWORD, default initialization for all COLOR variables is black\nEND_TYPE " }, 
{ "title" : "Strikte Programmierregeln ", 
"url" : "_cds_datatype_enum.html#UUID-1311dba6-f878-87c0-5628-03d3a9b811e5_id_c02c7c93f57fccc0a8640e014fa9b7_id_9f56ad50bcf5b28cc0a8640e01b52258", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Enumeration \/ Strikte Programmierregeln ", 
"snippet" : "Ab CODESYS V3.5 SP7 wird beim Deklarieren einer Enumeration automatisch in der ersten Zeile das Pragma {attribute 'strict'} hinzugefügt. Die strikten Programmierregeln werden mit Hinzufügen des Pragmas {attribute 'strict'} aktiviert. Folgender Code wird dann als Compilerfehler eingestuft: Arithmetis...", 
"body" : "Ab CODESYS V3.5 SP7 wird beim Deklarieren einer Enumeration automatisch in der ersten Zeile das Pragma {attribute 'strict'} hinzugefügt. Die strikten Programmierregeln werden mit Hinzufügen des Pragmas {attribute 'strict'} aktiviert. Folgender Code wird dann als Compilerfehler eingestuft: Arithmetische Operationen mit Enumerationskomponenten Beispielsweise kann eine Enumerationsvariable nicht als Zählvariable in einer FOR -Schleife verwendet werden. Zuweisung eines konstanten Werts, der nicht einem Enumerationswert entspricht, an eine Enumerationskomponente Zuweisung einer nicht-konstanten Variablen, die einen anderen Datentyp als die Enumeration hat, an eine Enumerationskomponente Arithmetischen Operationen können dazu führen, dass Enumerationskomponenten nicht deklarierte Werte zugewiesen werden. Ein besserer Programmierstil ist es, SWITCH - \/ CASE -Anweisungen zu verwenden, um Komponentenwerte zu bearbeiten. " }, 
{ "title" : "Deklaration und Initialisierung von Enumerationsvariablen ", 
"url" : "_cds_datatype_enum.html#UUID-1311dba6-f878-87c0-5628-03d3a9b811e5_id_c02c7c93f57fccc0a8640e014fa9b7_id_c30c45711efde45ac0a864630973c0ee", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Enumeration \/ Deklaration und Initialisierung von Enumerationsvariablen ", 
"snippet" : "Syntax <variable name> : <enumeration name> := <initialization> ; Bei der Deklaration einer Enumerationsvariable mit der benutzerdefinierten Enumeration kann die Variable mit einer Enumerationskomponenten initialisiert werden. Beispiel PROGRAM PLC_PRG VAR colorCar: COLOR; colorTaxi : COLOR := COLOR....", 
"body" : "Syntax <variable name> : <enumeration name> := <initialization> ; Bei der Deklaration einer Enumerationsvariable mit der benutzerdefinierten Enumeration kann die Variable mit einer Enumerationskomponenten initialisiert werden. Beispiel PROGRAM PLC_PRG\nVAR\n colorCar: COLOR;\n colorTaxi : COLOR := COLOR.yellow;\nEND_VAR Die Variable colorCar wird mit COLOR.black initialisiert. Das ist die Standardinitialisierung für alle Enumerationsvariablen des Typs COLOR und so in der Typdeklaration festgelegt. Die Variable colorTaxi hat eine eigene Initialisierung. Wenn keine Initialisierungen angegeben sind, wird mit 0 initialisiert. Beispiel PROGRAM PLC_PRG\nVAR\n cbFlower : COLOR_BASIC;\n cbTree: COLOR_BASIC := COLOR_BASIC.green;\nEND_VAR Die Variable cbFlower wird mit COLOR_BASIC.yellow initialisiert. Das ist die Standardinitialisierung für alle Enumerationsvariablen des Typs COLOR_BASIC . Da in der Enumerationsdeklaration keine Komponente für die Initialisierung angegeben ist, wird automatisch mit der Komponente, die den Wert 0 hat, initialisiert. Das ist üblicherweise die erste der Enumerationskomponenten. Das kann aber auch eine andere Komponente sein, die nicht an erster Stelle steht, aber explizit mit 0 initialisiert wird. Die Variable cbTree hat eine explizite Initialisierung. Wenn sowohl beim Typ als auch bei der Variable kein Wert angegeben ist, dann gilt folgende Regel: Wenn eine Enumeration einen Wert für 0 enthält, dann ist dieser Wert die Standardinitialisierung, wenn nicht, dann die erste Komponente in der Liste. Beispiel Initialisierung mit der 0-Komponente TYPE ENUM :\n(\n e1 := 2,\n e2 := 0,\n e3\n)\n;\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n e : ENUM;\nEND_VAR Die Variable e wird mit ENUM.e2 initialisiert. Initialisierung mit der ersten Komponente TYPE ENUM2 :\n(\n e1 := 3,\n e2 := 1,\n e3\n)\n;\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n e2 : ENUM2;\nEND_VAR Die Variable e2 wird mit ENUM.e1 initialisiert. " }, 
{ "title" : "Eindeutiger Zugriff auf Enumerationskomponenten ", 
"url" : "_cds_datatype_enum.html#UUID-1311dba6-f878-87c0-5628-03d3a9b811e5_id_c02c7c93f57fccc0a8640e014fa9b7_id_fb7c51f31efde45ac0a864636cadf959", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Enumeration \/ Eindeutiger Zugriff auf Enumerationskomponenten ", 
"snippet" : "Erweiterungen zur Norm IEC 61131-3 Die Enumerationskomponenten können auch als konstante Variablen mit dem Bezeichner <enumeration name>.<component name> verwendet werden. Enumerationskomponenten sind global im Projekt bekannt und der Zugriff auf sie ist eindeutig. Deshalb kann ein Komponentenname i...", 
"body" : "Erweiterungen zur Norm IEC 61131-3 Die Enumerationskomponenten können auch als konstante Variablen mit dem Bezeichner <enumeration name>.<component name> verwendet werden. Enumerationskomponenten sind global im Projekt bekannt und der Zugriff auf sie ist eindeutig. Deshalb kann ein Komponentenname in unterschiedlichen Enumerationen verwendet werden. Beispiel Komponente blue PROGRAM PLC_PRG\nVAR\n cbFlower : COLOR_BASIC;\n colorCar : COLOR;\nEND_VAR\n\n(* unambiguous identifiers although the component names are identical *)\ncbFlower := COLOR_BASIC.blue;\ncolorCar := COLOR.blue;\n\n(* invalid code *)\ncbFlower := blue;\ncolorCar := blue; Für weitere Informationen siehe Enumerations-Namensraum. " }, 
{ "title" : "Datentyp: Implizite Enumeration ", 
"url" : "_cds_datatype_implicit_enumeration-1853150.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Datentyp: Implizite Enumeration ", 
"snippet" : "Implizite Enumeration Die implizite Enumeration ermöglicht auf einfache Weise die Deklaration einer neuen Enumerationsvariablen, die nur innerhalb der lokalen POU gültig ist. Eine Variable diesen Typs kann eine begrenzte Anzahl von ganzzahligen Werten annehmen, die in der Komponentenliste deklariert...", 
"body" : "Implizite Enumeration Die implizite Enumeration ermöglicht auf einfache Weise die Deklaration einer neuen Enumerationsvariablen, die nur innerhalb der lokalen POU gültig ist. Eine Variable diesen Typs kann eine begrenzte Anzahl von ganzzahligen Werten annehmen, die in der Komponentenliste deklariert werden. Die implizite Enumeration hat keinen Datentyp-Namen oder Bezeichner. Deklaration : <variable name> : ( <list of component names> ) := <initialization>; <list of component names> Komma separierte Liste von Komponentennamen mit der gewünschten Anzahl von Komponenten Jede Komponente steht für einen ganzzahligen Wert, beginnend bei 0. Der Wert der nachfolgende Komponente erhöht sich jeweils um 1. Beispiel: Alfa, Bravo, Charlie, Delta, Echo Den Komponenten kann auch ein fester Wert zugewiesen werden. Beispiel: Zero, Alfa:=10, Bravo:=20, Charlie:=30, Delta:=40, Echo <initialization> Optional Initialisierungswert, üblicherweise eine Komponente Aufruf : Beispiel PROGRAM PLC_PRG\nVAR\n iAlphabet : (Alfa, Bravo, Charlie, Delta, Echo) := Echo;\n strText : STRING;\n iNumber : INT;\nEND_VAR CASE iAlphabet OF\n\tAlfa:\n\tstrText := 'A';\n\t\n\tBravo: \n\tstrText := 'B';\n\t\n\tCharlie:\n\tstrText := 'C';\n\t\n\tDelta:\n\tstrText := 'D';\n\t\n\tEcho:\n\tstrText := 'E';\nEND_CASE\niNumber := iAlphabet; " }, 
{ "title" : "Interner Datentyp ", 
"url" : "_cds_datatype_implicit_enumeration-1853150.html#UUID-b7c570d8-99e1-924b-7984-9849eebb5a31_section-idm4597855524900833552049065596", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Datentyp: Implizite Enumeration \/ Interner Datentyp ", 
"snippet" : "Bei einer impliziten Enumeration wird intern ein Datentyp erzeugt, dessen Namen folgendem Schema folgt: IMPLICIT_ENUM_ <POU name> _ <variable name> Sie sollten diesen internen Bezeichner jedoch nicht verwenden, da es immer möglich ist, dass der interne Bezeichner anders lautet....", 
"body" : "Bei einer impliziten Enumeration wird intern ein Datentyp erzeugt, dessen Namen folgendem Schema folgt: IMPLICIT_ENUM_ <POU name> _ <variable name> Sie sollten diesen internen Bezeichner jedoch nicht verwenden, da es immer möglich ist, dass der interne Bezeichner anders lautet. " }, 
{ "title" : "Alias ", 
"url" : "_cds_datatype_alias.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Alias ", 
"snippet" : "Ein Datentyp-Alias ist die Deklaration eines benutzerdefinierten Datentyps, mit dem ein alternativer Name für einen Basistyp, Datentyp oder Funktionsbaustein erzeugt wird. Die Typdeklaration eines Alias nehmen Sie in einem DUT -Objekt vor, das Sie über das Menü Projekt → Objekt hinzufügen → DU T ode...", 
"body" : "searchresult_toplevel Ein Datentyp-Alias ist die Deklaration eines benutzerdefinierten Datentyps, mit dem ein alternativer Name für einen Basistyp, Datentyp oder Funktionsbaustein erzeugt wird. Die Typdeklaration eines Alias nehmen Sie in einem DUT -Objekt vor, das Sie über das Menü Projekt → Objekt hinzufügen → DU T oder über das Kontextmenü einer Applikation anlegen. Für weitere Informationen siehe: DUT" }, 
{ "title" : "Syntax ", 
"url" : "_cds_datatype_alias.html#UUID-01335fef-6db0-3bdd-bc29-f0b6e4b38b03_section-idm234801418271509", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Alias \/ Syntax ", 
"snippet" : "TYPE <identifier> : <data type name> ; END_TYPE Erlaubte Typen <data type name> Basisdatentyp Datentyp mit Größenangabe Funktionsbaustein Beispiel Alias-Datentyp für Variablen des Typs STRING oder ARRAY , wenn diese eine bestimmte Länge benötigen Deklaration TYPE FRAME : ARRAY[0..1499] OF BYTE; END_...", 
"body" : "TYPE <identifier> : <data type name> ; END_TYPE Erlaubte Typen <data type name> Basisdatentyp Datentyp mit Größenangabe Funktionsbaustein Beispiel Alias-Datentyp für Variablen des Typs STRING oder ARRAY , wenn diese eine bestimmte Länge benötigen Deklaration TYPE FRAME : ARRAY[0..1499] OF BYTE; END_TYPE\nTYPE SYMBOL : STRING(512); END_TYPE Aufruf PROGRAM PLC_PRG\nVAR\n\tframeF : FRAME;\n\tsymbolS : SYMBOL;\nEND_VAR Beispiel Alias-Datentyp für Variablen, die einen anderen Startwert benötigen als der, der vom Compiler vorgesehen ist TYPE INDEX : DINT := -1; END_TYPE Beispiel Alias-Datentyp für Variablen eines bestimmten Typs, die nur einen bestimmten Unterbereich von Werten des ursprünglichen Typs aufnehmen sollen {attribute 'qualified_only'}\nVAR_GLOBAL CONSTANT\n\tc_diMaxRune : DINT := DINT#16#0010FFFF;\nEND_VAR TYPE RUNE : DINT(0..GVL.c_diMaxRune); END_TYPE Beispiel Alias-Datentyp für Typen aus einem anderen Namensraum Beispielsweise für Typen aus einer unterlagerten Bibliothek, die im aktuellen Namensraum zur Verfügung stehen sollen. TYPE ENCODING: SBB.ENCODING; END_TYPE (*ENUM*)\nTYPE RUNE : UTF8.RUNE; END_TYPE (*SUBTYPE*)\nTYPE INFO : STR.IFNFO; END_TYPE (*STRUCT*)\nTYPE IBuilder : SBB.IBuilder; END_TYPE (*INTERFACE*)\nTYPE Tange: SBB.Range; END_TYPE (*FUNCTION_BLOCK*) Damit kann in vielen Fällen auf eine Container-Bibliothek verzichtet werden, weil alle Typen von unterlagerten Bibliotheken auf diese Weise Teil der eigenen Bibliothek werden. " }, 
{ "title" : "Datenstruktur: UNION ", 
"url" : "_cds_datatype_union.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Datenstruktur: UNION ", 
"snippet" : "UNION UNION ist eine benutzerdefinierte Datenstruktur, deren Komponenten in der Regel unterschiedliche Datentypen und -größen haben. Die Komponenten der Instanz eines UNION -Datentyps belegen alle denselben Speicherplatz. Alle Komponenten haben den gleichen Adress-Offset und teilen sich den Speicher...", 
"body" : "UNION UNION ist eine benutzerdefinierte Datenstruktur, deren Komponenten in der Regel unterschiedliche Datentypen und -größen haben. Die Komponenten der Instanz eines UNION -Datentyps belegen alle denselben Speicherplatz. Alle Komponenten haben den gleichen Adress-Offset und teilen sich den Speicher. Der Speicherbedarf wird von der größten Komponente bestimmt. Eine UNION -Variable speichert den Wert genau einer Komponente. Der Speicher enthält den zuletzt zugewiesenen Wert. Dadurch wird der Speicher effizient genutzt. Für weitere Informationen siehe: Objekt DUT" }, 
{ "title" : "Typdeklaration ", 
"url" : "_cds_datatype_union.html#UUID-77065fbb-1927-c31d-6119-69d4ab77180a_section-idm234800958617735", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Datenstruktur: UNION \/ Typdeklaration ", 
"snippet" : "Syntax: TYPE <identifier> UNION    <member name> : <data type> := <initialization> ; END_UNION END_TYPE <member name> : <data type> ; Deklaration einer Komponente eines elementaren Datentyps Es können beliebig viele Deklarationen folgen, mindestens jedoch 2. := <initialization> Optional Beispiel Typ...", 
"body" : "Syntax: TYPE <identifier> UNION    <member name> : <data type> := <initialization> ; END_UNION END_TYPE <member name> : <data type> ; Deklaration einer Komponente eines elementaren Datentyps Es können beliebig viele Deklarationen folgen, mindestens jedoch 2. := <initialization> Optional Beispiel Typdeklaration U_VAR_12 TYPE U_VAR_12:\nUNION\n wVar1: WORD;\n byVar2 : BYTE;\nEND_UNION\nEND_TYPE Typdeklaration U_INT_ID TYPE U_INT_ID:\nUNION\n iVar: INT;\n dVar : DINT;\nEND_UNION\nEND_TYPE Typdeklaration U_EFFICIENT TYPE U_EFFICIENT\nUNION\n wMember : WORD;\n dwMember : DWORD;\n strMember : STRING := 'A'; \nEND_UNION\nEND_TYPE " }, 
{ "title" : "Variablendeklaration ", 
"url" : "_cds_datatype_union.html#UUID-77065fbb-1927-c31d-6119-69d4ab77180a_section-idm234800997913516", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Datenstruktur: UNION \/ Variablendeklaration ", 
"snippet" : "Instanzierung\/Deklaration einer Variable eines UNION -Datentyps: <variable name> : <name UNION type> := <initialization> ; := <initialization> Optional := ( <member name> := <literal> ) Initialisierung im Detail: Nach dem Zuweisungsoperator folgt in runden Klammern die Zuweisung des Initialwerts an ...", 
"body" : "Instanzierung\/Deklaration einer Variable eines UNION -Datentyps: <variable name> : <name UNION type> := <initialization> ; := <initialization> Optional := ( <member name> := <literal> ) Initialisierung im Detail: Nach dem Zuweisungsoperator folgt in runden Klammern die Zuweisung des Initialwerts an die Komponente. Beispiel TYPE U_AB:\nUNION\n lrA : LREAL;\n liB : LINT;\nEND_UNION\nEND_TYPE Variablendeklaration mit Initialisierung PLC_PRG PROGRAM\nVAR\n uabVAR_1 : U_AB := (lrA := LREAL#1.5);\n uabVAR_2 : U_AB := (liB := LINT#1);\nEND_VAR Beispiel Variablendeklaration in PLC_PRG mit Datentyp U_EFFICIENT PLC_PRG PROGRAM\nVAR\n uefficient_1 : U_EFFICIENT := (strMember := 'A');\nEND_VAR\n Implementierung PLC_PRG uefficient_1.wMember := 16#000A;\n Wenn auf eine Komponente der Variable uefficient_1 geschrieben wird, wirkt sich dies auf alle Komponenten der Variablen aus. " }, 
{ "title" : "Unterbereichstyp ", 
"url" : "_cds_datatype_subint.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Benutzerdefinierter Datentyp TYPE \/ Unterbereichstyp ", 
"snippet" : "Unterbereiche Ein Unterbereichstyp ist ein Datentyp, dessen Wertebereich eine Untermenge eines Basistypen umfasst. Syntax der Deklaration: <variabel name> : <integer type> ( <lower index limit> .. <upper index limit> ) <variabel name> Gültiger IEC-Bezeichner Für weitere Informationen siehe Regeln un...", 
"body" : "Unterbereiche Ein Unterbereichstyp ist ein Datentyp, dessen Wertebereich eine Untermenge eines Basistypen umfasst. Syntax der Deklaration: <variabel name> : <integer type> ( <lower index limit> .. <upper index limit> ) <variabel name> Gültiger IEC-Bezeichner Für weitere Informationen siehe Regeln und Empfehlungen zur Bezeichnervergabe<integer data type> Ganzzahliger Basisdatentyp für den Unterbereich SINT , USINT , INT , UINT , DINT , UDINT , BYTE , WORD , DWORD , LINT , ULINT , LWORD <lower index limit> Konstante für die Untergrenze des Bereichs, die mit dem Basisdatentyp kompatibel sein muss Die Untergrenze selbst gehört zu diesem Bereich. <upper index limit> Konstante für die Obergrenze des Bereichs, die mit dem Basisdatentyp kompatibel sein muss Die Obergrenze selbst gehört zu diesem Bereich. VAR\n i : INT (-4095..4095);\n ui : UINT (0..10000);\nEND_VAR\n Wenn Sie einem Unterbereichstypen in der Deklaration oder in der Implementierung ein Wert zuweisen, der nicht in diesen Bereich fällt gibt CODESYS eine Fehlermeldung aus. i:=5000 \/\/Results in an error message Beachten Sie die Möglichkeit, die Bereichsgrenzen eines Unterbereichstypen während der Laufzeit mit den impliziten Überwachungsfunktionen   CheckRangeSigned und CheckRangeUnsigned zu überwachen. " }, 
{ "title" : "Datentyp: __VECTOR ", 
"url" : "_cds_data_type_vector.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: __VECTOR ", 
"snippet" : "__VECTOR Vektoroperationen werden nur auf 64-Bit-Prozessoren nativ unterstützt und bieten nur auf diesen einen Geschwindigkeitsvorteil. Das Datenblatt der Steuerung informiert Sie über den auf der Steuerung verwendeten Prozessor. Aktuell werden Vektoroperationen auf den Plattformen x86-64Bit mit SSE...", 
"body" : "__VECTOR Vektoroperationen werden nur auf 64-Bit-Prozessoren nativ unterstützt und bieten nur auf diesen einen Geschwindigkeitsvorteil. Das Datenblatt der Steuerung informiert Sie über den auf der Steuerung verwendeten Prozessor. Aktuell werden Vektoroperationen auf den Plattformen x86-64Bit mit SSE2 und ARM64 mit NEON nativ unterstützt. Auf allen anderen Plattformen werden Vektoroperationen in einzelne Anweisungen übersetzt. Beispielsweise wird dann eine Vektoraddition mit mehreren einzelnen Additionen ausgeführt. Die Befehlssatzerweiterungen der Prozessoren sind SIMD-Erweiterungen. SIMD (Single Instruction, Multiple Data) steht für eine Rechnerarchitektur, bei der mit einem Befehlsaufruf gleichzeitig mehrere gleichartige Datensätze parallel und damit schneller verarbeitet werden. Bei Vektoroperationen können dann beispielsweise 4 Zahlenpaare gleichzeitig addiert werden. Syntax <variable name> : __VECTOR[ <vector size> ] OF <element type> := <initialization> ;\n\n<vector size> : 1 |2 | 3 | 4 | 5| 6 | 7| 8\n<element type> : REAL | LREAL\n Die Initialisierung der Variablen ist optional. Ein Vektordatentyp ist ein Gleitpunktzahl-Array mit maximal 8 Elementen. Für diesen Datentyp stehen die Operatoren __vc<operator name> zur Verfügung. Damit können Sie Vektoroperationen ohne zusätzliche Funktionsaufrufe implementieren. Syntax bei Indexzugriff <variable name>[ <index> ]\n<index> : 0 | 1 | 2| 3 | 4 | 5| 6 | 7 Beim Indexzugriff auf eine Vektorvariable können Sie auf ein einzelnes Element des Vektors zugreifen. Der Index beginnt bei 0 und geht bis <vector size> - 1. PROGRAM PLC_PRG\nVAR\n vcA : __VECTOR[3] OF REAL;\nEND_VAR\n\nvcA[0] := 1.1;\nvcA[1] := 2.2;\nvcA[2] := 3.3; " }, 
{ "title" : "Optimale Vektorgröße bestimmen ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-0af01dd3-fba8-5c57-0513-a55c61c26714", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: __VECTOR \/ Optimale Vektorgröße bestimmen ", 
"snippet" : "Verwenden Sie als Vektorgröße die optimale, von Ihrem Zielsystem abhängige Vektorgröße, um möglichst effizienten Code zu programmieren. Bei Zielsystemen, deren Rechnerarchitektur grundsätzlich für eine Vektorverarbeitung geeignet ist, ist es nicht ratsam Vektoren mit beliebiger Größe zu verwenden. A...", 
"body" : "Verwenden Sie als Vektorgröße die optimale, von Ihrem Zielsystem abhängige Vektorgröße, um möglichst effizienten Code zu programmieren. Bei Zielsystemen, deren Rechnerarchitektur grundsätzlich für eine Vektorverarbeitung geeignet ist, ist es nicht ratsam Vektoren mit beliebiger Größe zu verwenden. Abhängig von der Art der Datenverarbeitung des Prozessors gibt es nämlich eine optimale Vektorgröße. Vektoren, die mit dieser Arraygröße deklariert werden, werden schnellstmöglich verarbeitet. Vektoren, die als größeres Array deklariert werden, haben keinen Geschwindigkeitsvorteil. Vektoren, die als kleineres Array deklariert werden, nutzen die Möglichkeiten des Prozessors nicht vollständig. Sie können die optimale Größe zur Laufzeit abfragen. Die Informationen stehen Ihnen in den Konstanten Constants.vcOptimalREAL für Vektoren mit REAL -Elementen und Constants.vcOptimalLREAL für Vektoren mit LREAL -Elementen zur Verfügung, Die Konstanten haben den Datentyp INT . Wenn eine Konstanten als optimale Größe den Wert 1 zurückliefert, bedeutet das, dass das Zielsystem keine beschleunigte Vektorverarbeitung zur Verfügung hat. PROGRAM PLC_PRG\nVAR\n iOVS_REAL : INT; \/\/ Optimal vector size for REAL eleements\n iOVS_LREAL : INT; \/\/ Optimal vector size for LREAL eleements\nEND_VAR\n\niOVS_REAL := Constants.vcOptimalREAL;\niOVS_LREAL := Constants.vcOptimalLREAL; Eine Applikation, die auf das Zielystem CODESYS Control Win V3 x64 geladen wird, liefert zur Laufzeit folgende Werte zurück: " }, 
{ "title" : "Operator: __VCADD ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-f39e8b61-1c8e-f75f-fc5c-a2ab4edf25da", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: __VECTOR \/ Operator: __VCADD ", 
"snippet" : "Der Operator berechnet die Summe zweier Vektoren. Syntax <vector variable> := <1st vector operand> __VCADD <2nd vector operand>; Addieren FUNCTION_BLOCK FB_ADD VAR vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3); vcResult : __VECTOR[3] OF REAL; ...", 
"body" : "Der Operator berechnet die Summe zweier Vektoren. Syntax <vector variable> := <1st vector operand> __VCADD <2nd vector operand>; Addieren FUNCTION_BLOCK FB_ADD\nVAR\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3);\n vcResult : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult := vcA __VCADD vcB; " }, 
{ "title" : "Operator: __VCSUB ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-f310d6e4-89f2-14f1-3296-ddf6afcfffcb", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: __VECTOR \/ Operator: __VCSUB ", 
"snippet" : "Der Operator berechnet die Differenz zweier Vektoren. Syntax <vector variable> := <vector minuend> __VCSUB <vector subtrahend>; Subtrahieren FUNCTION_BLOCK FB_SUB VAR vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3); vcResult0 : __VECTOR[3] OF RE...", 
"body" : "Der Operator berechnet die Differenz zweier Vektoren. Syntax <vector variable> := <vector minuend> __VCSUB <vector subtrahend>; Subtrahieren FUNCTION_BLOCK FB_SUB\nVAR\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3);\n vcResult0 : __VECTOR[3] OF REAL;\n vcResult1 : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult0 := vcA __VCSUB vcB;\nvcResult1 := vcB __VCSUB vcA; " }, 
{ "title" : "Operator: __VCMUL ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-55d1650e-3133-2368-d000-e3a75e0d705b", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: __VECTOR \/ Operator: __VCMUL ", 
"snippet" : "Der Operator berechnet das Produkt zweier Vektoren oder eines Skalars (Gleitpunktzahl) mit einem Vektor. Syntax <vector variable> := <1st vector operand> __VCMUL <2nd vector operand> | <scalar operand> __VCMUL <vector operand> | <vector operand> __VCMUL <scalar operand> ; Multiplizieren FUNCTION_BLO...", 
"body" : "Der Operator berechnet das Produkt zweier Vektoren oder eines Skalars (Gleitpunktzahl) mit einem Vektor. Syntax <vector variable> := <1st vector operand> __VCMUL <2nd vector operand> | <scalar operand> __VCMUL <vector operand> | <vector operand> __VCMUL <scalar operand> ; Multiplizieren FUNCTION_BLOCK FB_MUL\nVAR\n rScalar : REAL := 1.1;\n vcA : __VECTOR[3] OF REAL;\n vcB : __VECTOR[3] OF REAL;\n vcResult0 : __VECTOR[3] OF REAL;\n vcResult1 : __VECTOR[3] OF REAL;\n vcResult2 : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult0 := vcA __VCMUL vcB;\nvcResult1 := rScalar __VCMUL vcB;\nvcResult2 := vcA __VCMUL 3.3; " }, 
{ "title" : "Operator: __VCDIV ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-77b2ab29-e8c3-1279-603e-d874d377ca91", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: __VECTOR \/ Operator: __VCDIV ", 
"snippet" : "Der Operator berechnet den Quotienten zweier Vektoren oder eines Vektors und eines Skalars. Syntax <vector variable> := <vector dividend> __VCDIV <vector divisor> | < vector dividend> __VCMUL <scalar divisor> ; Dividieren FUNCTION_BLOCK FB_DIV VAR iScalar : INT := 3; rScalar : REAL := 1.5; vcA : __V...", 
"body" : "Der Operator berechnet den Quotienten zweier Vektoren oder eines Vektors und eines Skalars. Syntax <vector variable> := <vector dividend> __VCDIV <vector divisor> | < vector dividend> __VCMUL <scalar divisor> ; Dividieren FUNCTION_BLOCK FB_DIV\nVAR\n iScalar : INT := 3;\n rScalar : REAL := 1.5;\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3);\n vcResult0 : __VECTOR[3] OF REAL;\n vcResult1 : __VECTOR[3] OF REAL;\n vcResult2 : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult0 := vcA __VCDIV vcB;\n\/\/ ERROR CODE vcResult1 := rScalar __VCDIV vcB;\n\/\/ ERROR CODE vcResult1 := iScalar __VCDIV vcB;\n\/\/ ERROR CODE vcResult1 := 3.3 __VCDIV vcB;\nvcResult2 := vcA __VCDIV 1.5;\nvcResult2 := vcA __VCDIV iScalar;\nvcResult2 := vcA __VCDIV rScalar; " }, 
{ "title" : "Operator: __VCDOT ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-fed81759-f085-d6b5-cffb-5e72db7228c4", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: __VECTOR \/ Operator: __VCDOT ", 
"snippet" : "Der Operator berechnet das Punktprodukt (Skalarprodukt) zweier Vektoren. Syntax <skalar variable> := <1st vector operand> __VCDOT <2nd vector operand> ; Punktprodukt FUNCTION_BLOCK FB_DOT VAR rResult : REAL; vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VECTOR[3] OF REAL := __VCSET_REA...", 
"body" : "Der Operator berechnet das Punktprodukt (Skalarprodukt) zweier Vektoren. Syntax <skalar variable> := <1st vector operand> __VCDOT <2nd vector operand> ; Punktprodukt FUNCTION_BLOCK FB_DOT\nVAR\n rResult : REAL;\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3);\nEND_VAR\nrResult := vcA __VCDOT vcB; \/\/ = 18 " }, 
{ "title" : "Operator: __VCSQRT ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-45327657-b65b-af06-a4e5-2d3e69420c0f", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: __VECTOR \/ Operator: __VCSQRT ", 
"snippet" : "Der Operator berechnet die Quadratwurzel für jedes Element des Vektors. Syntax <vector variable> := __VCSQRT( <vector operand> ); Quadratwurzel FUNCTION_BLOCK FB_SQRT VAR vcA : __VECTOR[3] OF REAL := __VCSET_REAL(4, 9, 16); vcResult0 : __VECTOR[3] OF REAL; END_VAR vcResult0 := __VCSQRT(vcA);...", 
"body" : "Der Operator berechnet die Quadratwurzel für jedes Element des Vektors. Syntax <vector variable> := __VCSQRT( <vector operand> ); Quadratwurzel FUNCTION_BLOCK FB_SQRT\nVAR\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(4, 9, 16);\n vcResult0 : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult0 := __VCSQRT(vcA); " }, 
{ "title" : "Operator: __VCMAX ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-a9f598fc-3f59-dfd8-7e18-b3d2aab0f705", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: __VECTOR \/ Operator: __VCMAX ", 
"snippet" : "Der Operator berechnet den maximalen Vektor zweier Vektoren. Dabei wird elementweise das Maximum bestimmt. Syntax <vector variable> := __VCMAX( <1st vector operand>, <2nd vector operand>); Maximumvektor FUNCTION_BLOCK FB_MAX VAR vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VECTOR[3] O...", 
"body" : "Der Operator berechnet den maximalen Vektor zweier Vektoren. Dabei wird elementweise das Maximum bestimmt. Syntax <vector variable> := __VCMAX( <1st vector operand>, <2nd vector operand>); Maximumvektor FUNCTION_BLOCK FB_MAX\nVAR\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 6);\n vcResult0 : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult0 := __VCMAX(vcA, vcB); " }, 
{ "title" : "Operator: __VCMIN ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-39832f61-8b64-561c-96f3-95f93a92e2aa", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: __VECTOR \/ Operator: __VCMIN ", 
"snippet" : "Der Operator berechnet den minimalen Vektor zweier Vektoren. Dabei wird elementweise das Minimum bestimmt. Syntax <vector variable> := __VCMIN( <1st vector operand>, <2nd vector operand>); Beispiel Minimumvektor FUNCTION_BLOCK FB_MIN VAR vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VE...", 
"body" : "Der Operator berechnet den minimalen Vektor zweier Vektoren. Dabei wird elementweise das Minimum bestimmt. Syntax <vector variable> := __VCMIN( <1st vector operand>, <2nd vector operand>); Beispiel Minimumvektor FUNCTION_BLOCK FB_MIN\nVAR\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 6);\n vcResult0 : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult0 := __VCMIN(vcA, vcB); " }, 
{ "title" : "Operator: __VCSET_REAL ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-fded852c-b429-752f-fdaf-5036b3560478", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: __VECTOR \/ Operator: __VCSET_REAL ", 
"snippet" : "Der Operator setzt alle Elemente eines Vektors in einer Anweisung. Die Elemente haben den Datentyp REAL . Syntax <vector variable> := __VCSET_REAL( <first literal>, ( < next literal> )+ ) ; ( ... )+ \/\/ number of elements have to match FUNCTION_BLOCK FB_SET VAR vcA : __VECTOR[3] OF REAL := __VCSET_RE...", 
"body" : "Der Operator setzt alle Elemente eines Vektors in einer Anweisung. Die Elemente haben den Datentyp REAL . Syntax <vector variable> := __VCSET_REAL( <first literal>, ( < next literal> )+ ) ;\n( ... )+ \/\/ number of elements have to match FUNCTION_BLOCK FB_SET\nVAR\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3);\nEND_VAR\nvcA := __VCSET_REAL(4, 4, 4);\nvcB := __VCSET_REAL(1.1, 2.2, 3.3); " }, 
{ "title" : "Operator: __VCSET_LREAL ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-b7e3f598-67c3-81cc-c496-d773363bb3d7", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: __VECTOR \/ Operator: __VCSET_LREAL ", 
"snippet" : "Der Operator setzt alle Elemente eines Vektors auf einmal in einer Anweisung. Die Elemente haben den Datentyp LREAL . Sie können den Operator überall dort verwendet werden, wo auch Variablen gültig sind, wie beispielsweise in Zuweisungen in Implementierungen oder als Parameter in Funktionsaufrufen. ...", 
"body" : "Der Operator setzt alle Elemente eines Vektors auf einmal in einer Anweisung. Die Elemente haben den Datentyp LREAL . Sie können den Operator überall dort verwendet werden, wo auch Variablen gültig sind, wie beispielsweise in Zuweisungen in Implementierungen oder als Parameter in Funktionsaufrufen. Syntax <vector variable> := __VCSET_LREAL( <first literal>, ( < next literal> )+ ) ;\n( ... )+ \/\/ number of elements have to match FUNCTION_BLOCK FB_SET\nVAR\n vclA : __VECTOR[3] OF LREAL := __VCSET_LREAL(3, 3, 3);\n vclB : __VECTOR[3] OF LREAL := __VCSET_LREAL(1, 2, 3);\nEND_VAR\nvclA := __VCSET_LREAL(-1.7976931348623158E+308, 0.0, 1.7976931348623158E+308);\nvclB := __VCSET_LREAL(-1.7976931348623158E+308, 0.0, 1.7976931348623158E+308); " }, 
{ "title" : "Operator: __VCLOAD_REAL ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-4cdb7360-779e-c920-db0b-dd01f936bfad", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: __VECTOR \/ Operator: __VCLOAD_REAL ", 
"snippet" : "Der Operator interpretiert einen beliebigen Speicherbereich als Vektor. Das ist hilfreich, um Vektorvariablen mit einem bestehenden Code zu verbinden. Der Operator benötigt 2 Parameter. Der erste Parameter gibt die Anzahl der Vektorelemente an. Der zweite Parameter ist ein Pointer auf die REAL -Date...", 
"body" : "Der Operator interpretiert einen beliebigen Speicherbereich als Vektor. Das ist hilfreich, um Vektorvariablen mit einem bestehenden Code zu verbinden. Der Operator benötigt 2 Parameter. Der erste Parameter gibt die Anzahl der Vektorelemente an. Der zweite Parameter ist ein Pointer auf die REAL -Daten. __VCLOAD_REAL(<n>,<ptr>) liest <n> aufeinander folgende REAL-Werte an der Adresse <ptr> . Wenn sich weniger als <n> Werte an dieser Adresse befinden, kann dies zum Absturz der Steuerung führen oder unerwünschten Speicher lesen. Syntax <vector variable> := __VCLOAD_REAL( <vector size>, <pointer to data of type REAL> ) ;\n<vector size> : 2 | 3 | 4 | 5| 6 | 7| 8 Vektorisieren FUNCTION_BLOCK FB_LOAD\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n rData : ARRAY[0..2] OF REAL := [1.234, 5.678, 9.123];\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\nEND_VAR\n\nvcA := __VCLOAD_REAL(3, ADR(rData[0])); " }, 
{ "title" : "Operator: __VCLOAD_LREAL ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-0203977d-64f5-da8c-acda-ea013ba688bc", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: __VECTOR \/ Operator: __VCLOAD_LREAL ", 
"snippet" : "Der Operator interpretiert einen beliebigen Speicherbereich als Vektor. Das ist hilfreich, um Vektorvariablen mit einem bestehenden Code zu verbinden. Der Operator benötigt 2 Parameter. Der erste Parameter gibt die Anzahl der Vektorelemente an. Der zweite Parameter ist ein Pointer auf die LREAL -Dat...", 
"body" : "Der Operator interpretiert einen beliebigen Speicherbereich als Vektor. Das ist hilfreich, um Vektorvariablen mit einem bestehenden Code zu verbinden. Der Operator benötigt 2 Parameter. Der erste Parameter gibt die Anzahl der Vektorelemente an. Der zweite Parameter ist ein Pointer auf die LREAL -Daten. __VCLOAD_LREAL (<n>,<ptr>) liest <n> aufeinander folgende LREAL-Werte an der Adresse <ptr> . Wenn sich weniger als <n> Werte an dieser Adresse befinden, kann dies zum Absturz der Steuerung führen oder unerwünschten Speicher lesen. Syntax <vector variable> := __VCLOAD_LREAL( <vector size>, <pointer to data of type LREAL> );\n<number of vector elements> : 1 | 2 | 3 | 4 | 5| 6 | 7| 8 Vektorisieren FUNCTION_BLOCK FB_LOAD\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n rData : ARRAY[0..3] OF LREAL := [-1.7976931348623158E+308, 1.6E+308, 1.7E+308, -1.6E+308];\n vcA : __VECTOR[3] OF LREAL := __VCSET_LREAL(1, 2, 3);\nEND_VAR\n\nvcA := __VCLOAD_LREAL(3, ADR(rData[0])); " }, 
{ "title" : "Operator: __VCSTORE ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-883d98ce-208b-793b-46eb-aa5757fa28d1", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: __VECTOR \/ Operator: __VCSTORE ", 
"snippet" : "Der Operator speichert\/kopiert den Inhalt des Vektors an die angegebene Speicheradresse. Die Anzahl und der Type der Elemente werden dabei automatisch von der Vektorvariablen übernommen. __VCSTORE(<n>,<ptr>) schreibt <n> aufeinander folgende Werte an der Adresse <ptr> . Wenn sich weniger als <n> Wer...", 
"body" : "Der Operator speichert\/kopiert den Inhalt des Vektors an die angegebene Speicheradresse. Die Anzahl und der Type der Elemente werden dabei automatisch von der Vektorvariablen übernommen. __VCSTORE(<n>,<ptr>) schreibt <n> aufeinander folgende Werte an der Adresse <ptr> . Wenn sich weniger als <n> Werte an dieser Adresse befinden, kann dies zum Absturz der Steuerung führen oder unerwünschten Speicher schreiben. Syntax __VCSTORE( <pointer to data>, <vector variable> ); Speichern FUNCTION_BLOCK FB_STORE\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n rData : ARRAY[0..2] OF REAL := [1, 2, 3];\n pData: POINTER TO REAL := ADR(rData[0]);\n\n lrData : ARRAY [0..3] OF LREAL := [1, 2, 3, 4];\n plData: POINTER TO LREAL := ADR(lrData[0];\n\n\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL( 1.234, 5.678, 9.123);\n vclA : __VECTOR[4] OF LREAL := __VCSET_LREAL(-1.7976931348623158E+308, 1.6E+308, 1.7E+308, -1.6E+308);\nEND_VAR\n\n__VCSTORE(pData, vcA);\n__VCSTORE(plData, vclA); " }, 
{ "title" : "Datentyp: VERSION ", 
"url" : "_cds_datatype_version.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Datentypen \/ Datentyp: VERSION ", 
"snippet" : "VERSION Der Datentyp VERSION enthält eine Struktur mit verschiedenen Versionsinformationen zum Projekt oder zur Bibliothek. Wenn in den Projektinformationen die Option Automatisch Projektinformationen-POUs erzeugen und\/oder Automatisch Bibliotheksinformationen-POUs erzeugen aktiviert ist, wird in de...", 
"body" : "VERSION Der Datentyp VERSION enthält eine Struktur mit verschiedenen Versionsinformationen zum Projekt oder zur Bibliothek. Wenn in den Projektinformationen die Option Automatisch Projektinformationen-POUs erzeugen und\/oder Automatisch Bibliotheksinformationen-POUs erzeugen aktiviert ist, wird in der Ansicht POUs die Funktion GetVersion mit dem Datentyp VERSION automatisch erzeugt. Auf die einzelnen Strukturelemente kann programmatisch zugegriffen werden. Typdeklaration: TYPE VERSION:\nSTRUCT\n \/\/\/ The major version number. This is typically incremented for significant releases that may include major new features or changes.\n uiMajor : UINT;\n \/\/\/ The minor version number. This is incremented for releases that add smaller features or improvements and may include significant fixes.\n uiMinor : UINT;\n \/\/\/ The service pack number. This is used to indicate updates that usually include bug fixes, performance improvements, and minor feature enhancements.\n uiServicePack : UINT;\n \/\/\/ The patch number. This is incremented for very small changes or bug fixes that do not significantly alter the functionality.\n uiPatch : UINT;\n END_STRUCT\n END_TYPE\n Für weitere Informationen siehe: Optionen zur Bausteinerzeugung für den Zugriff auf Projektinformationen" }, 
{ "title" : "Pragmas ", 
"url" : "_cds_struct_reference_pragmas.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas ", 
"snippet" : "Pragma-Anweisungen beeinflussen die Eigenschaften einer oder mehrerer Variablen bezüglich der Kompilierung oder des Präkompilierungsprozesses. Dafür stehen Ihnen verschiedene Kategorien von Pragmas zur Verfügung. Pragmas werden aktuell nur in Texteditoren unterstützt....", 
"body" : "Pragma-Anweisungen beeinflussen die Eigenschaften einer oder mehrerer Variablen bezüglich der Kompilierung oder des Präkompilierungsprozesses. Dafür stehen Ihnen verschiedene Kategorien von Pragmas zur Verfügung. Pragmas werden aktuell nur in Texteditoren unterstützt. " }, 
{ "title" : "Meldungspragmas ", 
"url" : "_cds_pragma_message.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Meldungspragmas ", 
"snippet" : "Meldungspragmas generieren Ausgabetexte, die nach einem Übersetzungsvorgang in der Ansicht Meldungen angezeigt werden. Zudem kann ein Meldungstyp ( Meldung , Warnung oder Fehler ) zugewiesen werden. Einfügeort: Separate oder bereits bestehende Zeile im Texteditor einer POU. 4 Typen von Meldungspragm...", 
"body" : "Meldungspragmas generieren Ausgabetexte, die nach einem Übersetzungsvorgang in der Ansicht Meldungen angezeigt werden. Zudem kann ein Meldungstyp ( Meldung , Warnung oder Fehler ) zugewiesen werden. Einfügeort: Separate oder bereits bestehende Zeile im Texteditor einer POU. 4 Typen von Meldungspragmas Syntax Meldungspragma Beispiel Codefragment Beschreibung {text <literal> } {text 'Hallo Allgäu!'} {text 'Part PLC_PRG has been compiled completely'} Kein Typ Ausgabe, definiert in Stringliteral <literal> : Hallo Allgäu! Part PLC_PRG has been compiled completely {info <literal> } {info 'I01: This is for your information.' } Typisiert als Meldung Ausgabe: I01:This is for your information. {warning <literal>} {warning 'W01: This is a warning to you.'} Typisiert als Warnung Im Unterschied zum Attributpragma 'obsolete' definieren Sie eine solche Warnung lokal für die aktuelle Position. Der Meldungspragma {warning} ist nur für Objekte, wie beispielsweise POUs, für Anweisungen und für Variablen erlaubt. Ausgabe: C0373: W01: This is a warning to you. {error <literal>} {error 'E00: Error has occured.'}\n Typisiert als Fehler Ausgabe: E00: Error has occurred. In der Ansicht Meldungen stehen die Schaltflächen Fehler , Warnung(en) und Meldung(en) zur Verfügung, mit denen sich die Ausgabetexte filtern lassen. Oder Sie verwenden die Befehle Nächste Meldung und Vorherige Meldung , um durch die einzelnen Ausgaben zu navigieren. Beachten Sie den Befehl Gehe zur Quellposition . Mit diesem Befehl gelangen Sie an die Position, an der das Pragma im Quellcode implementiert ist. Beispiel PROGRAM PLC_PRG\nVAR\n iVar : INT; {info 'Info0: This is for your information.'}\n bVar : BOOL;\n arrTest : ARRAY [0..10] OF INT;\nEND_VAR {text 'Hello Allgäu!'}\n\narrTest[iVar] := arrTest[iVar]+1;\n{warning 'W01: This is a warning'}\niVar := iVar+1;\n{warning 'W02: This is a second warning'}\n\n{text 'Part PLC_PRG has been compiled completely'} Ausgabe im Meldungsfenster: " }, 
{ "title" : "Attributpragmas ", 
"url" : "_cds_f_pragmas_attribute.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas ", 
"snippet" : "Attributpragmas beeinflussen die Kompilierung und die Vorkompilierung. Sie werden nur in Texteditoren unterstützt. CODESYS unterstützt eine Reihe von vordefinierten Attributpragmas. Zusätzlich können Sie benutzerdefinierte Pragmas verwenden, die Sie vor der Übersetzung des Projekts mit Hilfe von bed...", 
"body" : "Attributpragmas beeinflussen die Kompilierung und die Vorkompilierung. Sie werden nur in Texteditoren unterstützt. CODESYS unterstützt eine Reihe von vordefinierten Attributpragmas. Zusätzlich können Sie benutzerdefinierte Pragmas verwenden, die Sie vor der Übersetzung des Projekts mit Hilfe von bedingten Pragmas abfragen können. Attribute werden im Deklarationsteil definiert. Ausnahme: Für die Objekte Aktion und Transition, die keinen eigenen Deklarationsteil haben, können Sie Attribute zu Beginn des Implementierungsteils definieren. Wenn Sie eigene Attribute definieren, achten Sie bitte auf Eindeutigkeit. Sie erreichen dies, indem Sie beispielsweise den Attributnamen mit einem Präfix versehen. Gerätehersteller können hierfür das Vendor-Präfix verwenden. " }, 
{ "title" : "Auswirkungen auf Symbole ", 
"url" : "_cds_pragma_consequences_to_symbols.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Auswirkungen auf Symbole ", 
"snippet" : "Programmierbausteine und Variablen können in Folge von Attributpragmas ihr Verhalten bezüglich der Symbolkonfiguration ändern. Weitere Beschreibungen finden Sie auf der jeweiligen Hilfeseite des betroffenen Pragmas. Pragma mit Attribut Auswirkung Siehe auch {attribute 'call_after_global_init_slot' :...", 
"body" : "Programmierbausteine und Variablen können in Folge von Attributpragmas ihr Verhalten bezüglich der Symbolkonfiguration ändern. Weitere Beschreibungen finden Sie auf der jeweiligen Hilfeseite des betroffenen Pragmas. Pragma mit Attribut Auswirkung Siehe auch {attribute 'call_after_global_init_slot' := ' <slot> '} keine {attribute 'call_after_init'} keine {attribute 'call_after_online_change_slot' := ' <slot> '} keine {attribute 'call_before_global_exit_slot' := ' <slot> ' keine {attribute 'call_on_type_change':= ' comma separated list of referenced function blocks> '} keine {attribute 'conditionalshow' := ' <some text> '} {attribute 'conditionalshow'} {attribute 'conditionalshow_all_locals' := ' <some text> '} {attribute 'conditionalshow_all_locals'} Die ausgezeichneten Variablen sind verborgen und können folglich nicht exportiert werden. Wenn aber von der kompilierten Bibliothek auch die Quellcodedatei vorhanden ist oder wenn CODESYS mit der Kommandozeilenoption conditionalshowsymbols gestartet wurde, sind trotz Pragma die ausgezeichneten Variablen sichtbar. conditionalshowconditionalshow_all_locals{attribute 'const_replaced'} {attribute 'const_non_replaced'} Ersetzte Konstanten stehen im Symbolkonfigurationseditor nicht zur Verfügung und können folglich nicht exportiert werden. Ob eine Konstante ersetzt wird, hängt davon ab, ob die Compileroption Konstanten ersetzen für alle Konstanten aktiviert wurde und ob Pragmas bei einzelnen Konstanten die Compileroption überschreiben. const_replaced, const_non_replaced{attribute 'dataflow'} keine {attribute 'displaymode':= <displaymode> } keine {attribute 'enable_dynamic_creation'} keine {attribute 'estimated-stack-usage' := ' <estimated stack size in bytes> '} keine {attribute 'ExpandFully'} keine {attribute 'global_init_slot' := '<slot>'} keine {attribute 'hide'} Variablen sind verborgen und können folglich nicht exportiert werden hide{attribute 'hide_all_locals'} Variablen sind verborgen und können folglich nicht exportiert werden hide_all_locals{attribute 'initialize_on_call'} keine {attribute 'init_namespace'} keine {attribute 'init_on_onlchange' } keine {attribute 'instance-path'} keine {attribute 'io_function_block'} {attribute 'io_function_block_mapping'} keine {attribute 'is_connected' := ' <input variable> '} keine {attribute 'linkalways'} Programmierbausteine und Bibliotheksbausteine werden in die Compileliste eingebunden und können somit exportiert werden linkalways{attribute 'monitoring' := 'variable'} {attribute 'monitoring' := 'call'} Eigenschaften PROPERTY oder Funktionen ( FUNCTION ) stehen als Symbol zur Verfügung monitoring{'no_assign' } {'no_assign_warning' } keine {attribute 'no_check'} keine {attribute 'no_copy'} keine {attribute 'no-exit'} keine {attribute 'no_init'} {attribute 'no-init'} {attribute 'noinit'} keine {attribute 'no_instance_in_retain'} keine {attribute 'no_virtual_actions'} keine {attribute 'pingroup' := ' <group name> '} keine {attribute 'pin_presentation_order_inputs' := '< input name > '( , <next input name> )* } {attribute 'pin_presentation_order_outputs' := '< output name > '( , <next output name> )* } keine {attribute 'obsolete' := 'user defined text'} keine {attribute 'pack_mode' := ' <pack mode value> '} Kann zu einer absichtlich falschen Speicherausrichtung führen {attribute 'ProcessValue'} keine {attribute 'qualified_only'} keine {attribute 'reflection'} keine {attribute 'subsequent'} keine {attribute 'suppress_warning'} keine suppress_warning{attribute 'symbol' := '<access possibilities>'} Variable wird als Symbol exportiert Nur wenn im Symbolkonfigurationseditor die Option Ansicht , Über Attribut exportierte Symbole aktiviert ist, wird die Variable in der Symbolliste angezeigt. In der Spalte Attribut sind die Zugriffsrechte, die mit dem Pragma definiert wurden, visualisiert. Attribut: symbol {attribute 'to_string'} keine {warning disable <compiler ID> } {warning restore <compiler ID> } keine " }, 
{ "title" : "Benutzerdefiniertes Attribut ", 
"url" : "_cds_user_defined_attributes.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Benutzerdefiniertes Attribut ", 
"snippet" : "Benutzerdefinierte Attribute sind beliebige applikations- oder benutzerdefinierte Attribute, die Sie auf POUs, Aktionen, Datentypdefinitionen und Variablen anwenden können. Ein benutzerdefiniertes Attribut können Sie vor der Übersetzung der Applikation mit Hilfe von bedingten Pragmas abfragen. Sie k...", 
"body" : "Benutzerdefinierte Attribute sind beliebige applikations- oder benutzerdefinierte Attribute, die Sie auf POUs, Aktionen, Datentypdefinitionen und Variablen anwenden können. Ein benutzerdefiniertes Attribut können Sie vor der Übersetzung der Applikation mit Hilfe von bedingten Pragmas abfragen. Sie können benutzerdefinierte Attribute mit bedingten Pragmas mit dem Operator hasattribute abfragen. Weitere Informationen und Beispiele finden Sie unter Bedingte Pragmas Syntax: {attribute 'attribute'} POUs und Aktionen Attribut 'vision' für Funktion fun1 {attribute 'vision'}\nFUNCTION fun1 : INT\nVAR_INPUT\n i : INT;\nEND_VAR Variablen Attribut 'DoCount' für Variable ivar : PROGRAM PLC_PRG\nVAR\n {attribute 'DoCount'};\n ivar:INT;\n bvar:BOOL;\nEND_VAR Datentypen Attribut 'aType' für Datentyp DUT_1 : {attribute 'aType'}\nTYPE DUT_1 :\nSTRUCT\n a:INT;\n b:BOOL;\nEND_STRUCT\nEND_TYPE " }, 
{ "title" : "Attribut: call_after_global_init_slot ", 
"url" : "_cds_pragma_attribute_call_after_global_init_slot.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: call_after_global_init_slot ", 
"snippet" : "call_after_global_init_slot VAR_INPUT -Deklarationen in Funktionen oder Methoden, die das Attribut verwenden, führen zu Übersetzungsfehlern. Grund: Eingabevariablen sind in diesem Fall zum Zeitpunkt des Aufrufs, der implizit während des Online-Change erfolgt, nicht bekannt. Das Pragma bewirkt, dass ...", 
"body" : "call_after_global_init_slot VAR_INPUT -Deklarationen in Funktionen oder Methoden, die das Attribut verwenden, führen zu Übersetzungsfehlern. Grund: Eingabevariablen sind in diesem Fall zum Zeitpunkt des Aufrufs, der implizit während des Online-Change erfolgt, nicht bekannt. Das Pragma bewirkt, dass alle Funktionen und Programme, die damit ausgezeichnet sind, nach der globalen Initialisierung aufgerufen werden. Die Aufrufreihenfolge legen Sie durch den Attributwert fest. Wenn in einer Methode das Attribut gesetzt ist, werden alle Instanzen des übergeordneten Funktionsbausteins ermittelt. Alle Instanzen werden im angegebenen Slot aufgerufen. In diesem Fall haben Sie auf die Reihenfolge der Instanzen untereinander keinen Einfluss. Syntax : {attribute 'call_after_global_init_slot' := '<slot>'} Einfügeort Erste Zeile über dem Deklarationsteil von Funktionen und Programmen <slot> Ganzzahliger Wert, der den Stellenwert in der Reihenfolge der Aufrufe definiert Je niedriger der Wert ist, desto früher erfolgt der Aufruf. Wenn mehrere Bausteine denselben Stellenwert für das Attribut haben, so bleibt die Reihenfolge ihrer Aufrufe unbestimmt. Für weitere Informationen siehe: Global Init Slots" }, 
{ "title" : "Attribut: call_after_init ", 
"url" : "_cds_pragma_attribute_call_after_init.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: call_after_init ", 
"snippet" : "call_after_init VAR_INPUT -Deklarationen in Funktionen oder Methoden, die dieses Attribut verwenden, führen zu Übersetzungsfehlern. Grund: Eingabevariablen sind in diesem Fall zum Zeitpunkt des Aufrufs, der implizit während des Online-Change erfolgt, nicht bekannt. Diese Funktionalität wird ab Compi...", 
"body" : "call_after_init VAR_INPUT -Deklarationen in Funktionen oder Methoden, die dieses Attribut verwenden, führen zu Übersetzungsfehlern. Grund: Eingabevariablen sind in diesem Fall zum Zeitpunkt des Aufrufs, der implizit während des Online-Change erfolgt, nicht bekannt. Diese Funktionalität wird ab Compilerversion 3.4.1.0 unterstützt. Das Pragma bewirkt, dass eine Methode implizit nach der Initialisierung einer Funktionsbaustein-Instanz aufgerufen wird. Aus Performanzgründen müssen Sie das Attribut sowohl dem Funktionsbaustein als auch der Methode in einer eigenen ersten Zeile über dem Deklarationsteil hinzufügen. Eine Methode mit diesem Pragma wird nach der Methode FB_Init und nachdem die Variablenwerte eines Initialisierungsausdrucks in der Instanzdeklaration gültig wurden, aufgerufen Syntax : {attribute 'call_after_init'} Aufruf: Erste Zeile über dem Deklarationsteil der Methode und des Funktionsbausteins. Beispiel Definition {attribute 'call_after_init'}\nFUNCTION_BLOCK FB_DoIt\n... <functionblock definition>\n\n{attribute 'call_after_init'}\nMETHOD FB_AfterInit\n... <method definition> Die Deklaration setzt folgende Deklaration in die nachfolgende Codeabarbeitung um: fbDoIt : FB_DoIt := (in1 := 99); Codeabarbeitung fbDoIt.FB_Init();\nfbDoIt.in1 := 99;\nfbDoIt.FB_AfterInit(); So kann in FB_AfterInit auf die benutzerdefinierte Initialisierung reagiert werden. " }, 
{ "title" : "Attribut: call_after_online_change_slot ", 
"url" : "_cds_pragma_attribute_call_after_online_change_slot.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: call_after_online_change_slot ", 
"snippet" : "call_after_online_change_slot VAR_INPUT -Deklarationen in Funktionen oder Methoden, die das Attribut verwenden, führen zu Übersetzungsfehlern. Grund ist, dass in diesem Fall die Eingabevariablen zum Zeitpunkt des Aufrufs, der implizit während des Online-Change erfolgt, nicht bekannt sind. Da die App...", 
"body" : "call_after_online_change_slot VAR_INPUT -Deklarationen in Funktionen oder Methoden, die das Attribut verwenden, führen zu Übersetzungsfehlern. Grund ist, dass in diesem Fall die Eingabevariablen zum Zeitpunkt des Aufrufs, der implizit während des Online-Change erfolgt, nicht bekannt sind. Da die Applikation während des Online-Change nicht laufen kann, kann jeder Code der in dieser Situation ausgeführt wird, zu einem Jitter führen. Halten Sie deshalb den auszuführenden Codeumfang möglichst gering. Das Pragma bewirkt, dass alle Funktionen und Programme, die dieses Attribut gesetzt haben, nach einem Online-Change aufgerufen werden. Die Aufrufreihenfolge legen Sie durch den Attributwert <slot> fest. Wenn in einer Methode das Attribut gesetzt ist, werden alle Instanzen des übergeordneten Funktionsbausteins ermittelt. Alle Instanzen werden im angegebenen Slot aufgerufen. In diesem Fall haben Sie auf die Reihenfolge der Instanzen untereinander keinen Einfluss. Syntax : {attribute 'call_after_online_change_slot' := '<slot>'} Einfügeort Erste Zeile über dem Deklarationsteil von Funktionen und Programmen <slot> Ganzzahliger Wert, der den Stellenwert in der Reihenfolge der Aufrufe definiert: Je niedriger der Wert ist, desto früher erfolgt der Aufruf. Wenn mehrere Bausteine denselben Stellenwert für das Attribut haben, so bleibt die Reihenfolge ihrer Aufrufe unbestimmt. " }, 
{ "title" : "Attribut: call_before_global_exit_slot ", 
"url" : "_cds_pragma_attribute_call_before_global_exit_slot.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: call_before_global_exit_slot ", 
"snippet" : "call_before_global_exit_slot VAR_INPUT -Deklarationen in Funktionen oder Methoden, die das Attribut verwenden, führen zu Übersetzungsfehlern. Grund: Eingabevariablen sind in diesem Fall zum Zeitpunkt des Aufrufs, der implizit während des Online-Change erfolgt, nicht bekannt. Das Pragma bewirkt, dass...", 
"body" : "call_before_global_exit_slot VAR_INPUT -Deklarationen in Funktionen oder Methoden, die das Attribut verwenden, führen zu Übersetzungsfehlern. Grund: Eingabevariablen sind in diesem Fall zum Zeitpunkt des Aufrufs, der implizit während des Online-Change erfolgt, nicht bekannt. Das Pragma bewirkt, dass alle Funktionen und Programme, in denen dieses Attribut gesetzt ist, vor den GlobalExit aufgerufen werden. GlobalExit findet vor einem erneuten Download oder bei einem Reset statt. Betroffen sind Bausteine, die mit einer FB_Exit -Methode versehen sind. Die Aufrufreihenfolge wird durch den Attributwert festgelegt. Wenn in einer Methode das Attribut gesetzt ist, werden alle Instanzen des übergeordneten Funktionsbausteins ermittelt. Alle Instanzen werden im angegebenen Slot aufgerufen. In diesem Fall haben Sie auf die Reihenfolge der Instanzen untereinander keinen Einfluss. Syntax : {attribute 'call_before_global_exit_slot' := '<slot>'} Einfügeort Erste Zeile über dem Deklarationsteil von Funktionen und Programmen <slot> Ganzzahliger Wert, der den Stellenwert in der Reihenfolge der Aufrufe definiert: Je niedriger der Wert ist, desto früher erfolgt der Aufruf. Wenn mehrere Bausteine denselben Stellenwert für das Attribut haben, so bleibt die Reihenfolge ihrer Aufrufe unbestimmt. " }, 
{ "title" : "Attribut: call_on_type_change ", 
"url" : "_cds_pragma_attribute_call_on_type_change.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: call_on_type_change ", 
"snippet" : "call_on_type_change Das Pragma bewirkt, dass eine damit ausgezeichnete Methode aufgerufen wird, wenn sich im übergeordneten Funktionsbaustein die dort referenzierten Funktionsbausteine im Datentyp ändern. Die Referenzierung kann über eine Pointervariable oder über eine Variable vom Typ REFERENCE TO ...", 
"body" : "call_on_type_change Das Pragma bewirkt, dass eine damit ausgezeichnete Methode aufgerufen wird, wenn sich im übergeordneten Funktionsbaustein die dort referenzierten Funktionsbausteine im Datentyp ändern. Die Referenzierung kann über eine Pointervariable oder über eine Variable vom Typ REFERENCE TO definiert sein. Syntax : {attribute 'call_on_type_change' := ' <comma-separated names of the referenced function modules> '} Einfügeort: Zeile oberhalb der ersten Zeile in der Deklaration der Methode Beispiel Der Funktionsbaustein FB_A referenziert FB_B und FB_C . FUNCTION_BLOCK FB_A\nVAR\n var_pt: POINTER TO FB_B;\n var_ref: REFERENCE TO FB_C;\nEND_VAR\n... Die Methode METH_react_on_type_change wird aufgerufen, wenn sich der Datentyp von FB_B oder FB_C ändert. {attribute 'call_on_type_change' := 'FB_B, FB_C'}\nMETHOD METH_react_on_type_change : INT\nVAR_INPUT\n... " }, 
{ "title" : "Attribut: conditionalshow ", 
"url" : "_cds_pragma_attribute_conditionalshow.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: conditionalshow ", 
"snippet" : "conditionalshow Das Pragma bewirkt, dass die Bezeichner einer eingebundenen kompilierten Bibliothek <library name> .compiled-library , die mit dem Pragma ausgezeichnet wurden, vor Applikationsprogrammierern verborgen werden. Die Bausteine können aufgerufen werden, aber die Variablen sind in der CODE...", 
"body" : "conditionalshow Das Pragma bewirkt, dass die Bezeichner einer eingebundenen kompilierten Bibliothek <library name> .compiled-library , die mit dem Pragma ausgezeichnet wurden, vor Applikationsprogrammierern verborgen werden. Die Bausteine können aufgerufen werden, aber die Variablen sind in der CODESYS -Oberfläche unsichtbar. Betroffene Features Bibliotheksverwaltung Debugging Eingabehilfe Feature \"Komponenten auflisten“ Monitoring Symbolkonfiguration Das ist nützlich, wenn Sie Bibliotheken entwickeln. Als Bibliotheksentwickler zeichnen Sie Funktionsbausteine oder Variablen mit dem Pragma aus. Damit legen Sie fest, welche Bezeichner nach dem Einbinden in eine Applikation verborgen werden. Wenn Sie später die verborgenen Bezeichner beispielsweise beim Debugging oder beim Weiterentwickeln der Bibliothek vermissen, können Sie deren Sichtbarkeit wieder aktivieren. Syntax {attribute 'conditionalshow' := ' <some text> '} Einfügeort: Oberste Zeile im Deklarationsteil eines Funktionsbausteins, oberhalb einer Variablen Einfügeort Erste Zeile über dem Deklarationsteil von Funktionen und Programmen <some text> Optional Stringliteral, um die Sichtbarkeit der mit einem solchen Pragma gekennzeichneten Bezeichner mit einem Kommandozeilenbefehl und diesem Literal zu steuern Wenn das Pragma ohne Literal angegeben ist, sind die Variablen in der CODESYS -Entwicklungsumgebung immer verborgen, unabhängig davon, wie CODESYS gestartet wurde. Weitere Hilfe dazu finden Sie im Dokument „Library Development Summary“. Beispiel Weitere Beispiele finden Sie im Dokument „Library Development Summary“. Verbergen einer Variablen FUNCTION_BLOCK FB_DataManager\nVAR\n {attribute 'conditionalshow' := 'Library_Developer'}\n iLocal : INT;\n iCounter : INT;\nEND_VAR Die Variable iLocal ist unsichtbar. Verbergen eines Funktionsbausteins {attribute 'conditionalshow' := 'Library_Developer'}\nFUNCTION_BLOCK FB_DataManager\nVAR\n iLocal : INT;\n iCounter : INT;\nEND_VAR Die Bezeichner FB_DataManager , iLocal und iCounter sind unsichtbar. " }, 
{ "title" : "Sichtbarkeit bei vorhandener Quellcodedatei ", 
"url" : "_cds_pragma_attribute_conditionalshow.html#UUID-c2eaf3e2-3d4a-2ddd-b40f-5c12f68a8748_id_a67a86e4255dcc0a8646343179ebe_id_f83478949a10c1e9c0a864630e28568a", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: conditionalshow \/ Sichtbarkeit bei vorhandener Quellcodedatei ", 
"snippet" : "Wenn von einer eingebundenen Bibliothek auch die Quellcodedatei <library name> .library am gleichen Speicherort (Repository) vorhanden ist, sind die Bezeichnern trotz Pragmas sichtbar. Das ist unabhängig davon, ob in der Deklaration ein Attributwert angegeben wurde....", 
"body" : "Wenn von einer eingebundenen Bibliothek auch die Quellcodedatei <library name> .library am gleichen Speicherort (Repository) vorhanden ist, sind die Bezeichnern trotz Pragmas sichtbar. Das ist unabhängig davon, ob in der Deklaration ein Attributwert angegeben wurde. " }, 
{ "title" : "Kommandozeilenaufruf zur Aktivierung der Sichtbarkeit ", 
"url" : "_cds_pragma_attribute_conditionalshow.html#UUID-c2eaf3e2-3d4a-2ddd-b40f-5c12f68a8748_id_a67a86e4255dcc0a8646343179ebe_id_cea44f6f9a10c1e9c0a8646337b3d88a", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: conditionalshow \/ Kommandozeilenaufruf zur Aktivierung der Sichtbarkeit ", 
"snippet" : "Sie können die Sichtbarkeit der verborgenen Variablen auch ohne Quellcodedatei aktivieren, indem Sie CODESYS mit der Kommandozeilenoption conditionalshowsymbols starten. Um die Sichtbarkeit zu aktivieren, geben Sie die durch Kommas voneinander getrennten Attributwerte der Pragmas an. Syntax codesys....", 
"body" : "Sie können die Sichtbarkeit der verborgenen Variablen auch ohne Quellcodedatei aktivieren, indem Sie CODESYS mit der Kommandozeilenoption conditionalshowsymbols starten. Um die Sichtbarkeit zu aktivieren, geben Sie die durch Kommas voneinander getrennten Attributwerte der Pragmas an. Syntax codesys.exe --conditionalshowsymbols=\" <some text> ( ,<next text> )* \" Für weitere Informationen siehe: Kommandozeilen-Schnittstelle verwendencodesys.exe --conditionalshowsymbols=\"Library_Developer\" codesys.exe --conditionalshowsymbols=\"Group_A,Group_B\" " }, 
{ "title" : "Auswirkungen des Attributs auf Monitoring und intelligentes Kodieren ", 
"url" : "_cds_pragma_attribute_conditionalshow.html#UUID-c2eaf3e2-3d4a-2ddd-b40f-5c12f68a8748_section-idm43395049804922", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: conditionalshow \/ Kommandozeilenaufruf zur Aktivierung der Sichtbarkeit \/ Auswirkungen des Attributs auf Monitoring und intelligentes Kodieren ", 
"snippet" : "Quellbibliothek: Aktion Attribut gesetzt Attribut nicht gesetzt Intelligentes Kodieren \/ Eingabehilfe Methode sichtbar sichtbar Input sichtbar nicht sichtbar Output sichtbar nicht sichtbar Monitoring Input sichtbar sichtbar Output sichtbar sichtbar Local sichtbar sichtbar Übersetzte Bibliothek Aktio...", 
"body" : "Quellbibliothek: Aktion Attribut gesetzt Attribut nicht gesetzt Intelligentes Kodieren \/ Eingabehilfe Methode sichtbar sichtbar Input sichtbar nicht sichtbar Output sichtbar nicht sichtbar Monitoring Input sichtbar sichtbar Output sichtbar sichtbar Local sichtbar sichtbar Übersetzte Bibliothek Aktion Attribut gesetzt Attribut nicht gesetzt Intelligentes Kodieren \/ Eingabehilfe Methode sichtbar sichtbar Input sichtbar nicht sichtbar Output sichtbar nicht sichtbar Monitoring Input sichtbar nicht sichtbar Output sichtbar nicht sichtbar Local sichtbar nicht sichtbar " }, 
{ "title" : "Attribut: conditionalshow_all_locals ", 
"url" : "_cds_pragma_attribute_conditionalshow_all_locals.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: conditionalshow_all_locals ", 
"snippet" : "conditionalshow_all_locals Das Pragma bewirkt, dass alle lokalen Variablen eines mit dem Pragma ausgezeichneten Bibliotheksbausteins vor Applikationsprogrammierern verborgen werden. Die Bausteine einer eingebundenen kompilierten Bibliothek <library name> .compiled-library können aufgerufen werden, a...", 
"body" : "conditionalshow_all_locals Das Pragma bewirkt, dass alle lokalen Variablen eines mit dem Pragma ausgezeichneten Bibliotheksbausteins vor Applikationsprogrammierern verborgen werden. Die Bausteine einer eingebundenen kompilierten Bibliothek <library name> .compiled-library können aufgerufen werden, aber die Variablen sind in der Basic Level -Oberfläche unsichtbar. Betroffene Features: Bibliotheksverwaltung Debugging Eingabehilfe Funktion “Komponenten auflisten“ Monitoring Symbolkonfiguration Das ist nützlich, wenn Sie Bibliotheken entwickeln. Als Bibliotheksentwickler zeichnen Sie Funktionsbausteine mit dem Pragma aus. Damit legen Sie fest, dass deren Variablen nach dem Einbinden in eine Applikation verborgen werden. Wenn Sie später diese Bezeichner beispielsweise beim Debugging oder beim Weiterentwickeln der Bibliothek vermissen, können Sie deren Sichtbarkeit wieder aktivieren. Für weitere Informationen siehe: Dokumentation „Library Development Summary“ Syntax {attribute 'conditionalshow_all_locals' := ' <some text> ' } Einfügeort Erste Zeile über dem Deklarationsteil des Funktionsbausteins <some text> Optional Optionales Stringliteral, um die Sichtbarkeit der mit einem solchen Pragma gekennzeichneten Bezeichner mit einem Kommandozeilenbefehl und diesem Literal zu steuern Wenn das Pragma ohne Literal angegeben ist, sind die Variablen in der Basic Level -Entwicklungsumgebung immer verborgen, unabhängig davon, wie Basic Level gestartet wurde. Verbergen aller lokale Variablen {attribute 'conditionalshow_all_locals' := 'Library_Developer'}\nFUNCTION_BLOCK FB_DataManager\nVAR\n iLocal : INT;\n iCounter : INT;\nEND_VAR Weitere Beispiele finden Sie im Dokument „Library Development Summary“. " }, 
{ "title" : "Sichtbarkeit bei vorhandener Quellcodedatei ", 
"url" : "_cds_pragma_attribute_conditionalshow_all_locals.html#UUID-db59833b-7bd9-9489-c20e-ebe370f6ad67_id_a15a9e476e49230dc0a864631ad26c45_id_84ae9f519e37d9d3c0a86463554294a0", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: conditionalshow_all_locals \/ Sichtbarkeit bei vorhandener Quellcodedatei ", 
"snippet" : "Wenn von einer eingebundenen Bibliothek auch die Quellcodedatei <library name> .library am gleichen Speicherort (Repository) vorhanden ist, sind die Bibliotheksbausteinvariablen trotz Pragmas sichtbar. Das ist unabhängig davon, ob in der Deklaration ein Attributwert angegeben wurde....", 
"body" : "Wenn von einer eingebundenen Bibliothek auch die Quellcodedatei <library name> .library am gleichen Speicherort (Repository) vorhanden ist, sind die Bibliotheksbausteinvariablen trotz Pragmas sichtbar. Das ist unabhängig davon, ob in der Deklaration ein Attributwert angegeben wurde. " }, 
{ "title" : "Kommandozeilenaufruf zur Aktivierung der Sichtbarkeit ", 
"url" : "_cds_pragma_attribute_conditionalshow_all_locals.html#UUID-db59833b-7bd9-9489-c20e-ebe370f6ad67_id_a15a9e476e49230dc0a864631ad26c45_id_83dd83ba9e37d9d3c0a86463332f087b", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: conditionalshow_all_locals \/ Kommandozeilenaufruf zur Aktivierung der Sichtbarkeit ", 
"snippet" : "Sie können die Sichtbarkeit der verborgenen Variablen auch ohne Quellcodedatei aktivieren, indem Sie Basic Level mit der Kommandozeilenoption conditionalshowsymbols starten. Um die Sichtbarkeit zu aktivieren, geben Sie die durch Kommas voneinander getrennten Attributwerte der Pragmas an. Syntax code...", 
"body" : "Sie können die Sichtbarkeit der verborgenen Variablen auch ohne Quellcodedatei aktivieren, indem Sie Basic Level mit der Kommandozeilenoption conditionalshowsymbols starten. Um die Sichtbarkeit zu aktivieren, geben Sie die durch Kommas voneinander getrennten Attributwerte der Pragmas an. Syntax codesys.exe --conditionalshowsymbols=\" <some text> ( ,<next text> )* \" Beispiel codesys.exe --conditionalshowsymbols=\"Library_Developer\" codesys.exe --conditionalshowsymbols=\"Group_A,Group_B\" Für weitere Informationen siehe: hide_all_locals , conditionalshow und Kapitel „Visibility Control“ " }, 
{ "title" : "Attribut: const_replaced, const_non_replaced ", 
"url" : "_cds_pragma_attribute_const_replaced_non.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: const_replaced, const_non_replaced ", 
"snippet" : "const_replaced, const_non_replaced Das Attribut const_replaced bewirkt, dass die Konstante im Code ersetzt wird, unabhängig von der Einstellung der Compileroption Konstanten ersetzen . Das Attribut hat nur eine Auswirkung für Variablen von skalaren Typen, aber nicht für zusammengesetzte Typen wie Ar...", 
"body" : "const_replaced, const_non_replaced Das Attribut const_replaced bewirkt, dass die Konstante im Code ersetzt wird, unabhängig von der Einstellung der Compileroption Konstanten ersetzen . Das Attribut hat nur eine Auswirkung für Variablen von skalaren Typen, aber nicht für zusammengesetzte Typen wie Arrays und Strukturen. Das Pragma {attribute 'const_non_replaced'} fügen Sie entsprechend ein, um die Compileroption Konstanten ersetzen explizit zu deaktivieren. Dies bewirkt beispielsweise in der Symbolkonfiguration , dass die Konstante verfügbar ist und trotz Compileroption exportiert werden kann. Die Option Konstanten ersetzen im Dialog Projekteinstellungen , Kategorie Compile-Optionen ist für das ganze Projekt voreingestellt, weil Konstanten ersetzen in der Regel zu schnellerem Code und geringerem Speicherverbrauch führt. Syntax : {attribute 'const_replaced'} {attribute 'const_non_replaced'} Einfügeort: Zeile oberhalb der Deklarationszeile der globalen Variablen. Beispiel Die Konstanten iTestCon und xTestCon sind in der Symbolkonfiguration verfügbar, weil die Option Konstanten ersetzen deaktiviert ist. {attribute 'qualified_only'}\nVAR_GLOBAL CONSTANT\n {attribute 'const_non_replaced'}\n iTestCon : INT := 12;\n {attribute 'const_non_replaced'}\n xTestCon : BOOL := TRUE;\n rTestCon : REAL := 1.5;\nEND_VAR\n\nVAR_GLOBAL\n iTestVar : INT := 12;\n xTestVar : BOOL := TRUE;\nEND_VAR " }, 
{ "title" : "Attribut: dataflow ", 
"url" : "_cds_pragma_attribute_dataflow.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: dataflow ", 
"snippet" : "dataflow Mit dem Pragma steuern Sie den Datenfluss in der Abarbeitung von Funktionsbausteinen im FUP\/KOP\/AWL-Editor. Das Attribut legt fest, an welchem Eingang oder Ausgang eines Funktionsbausteins die Weiterverbindung zum nächsten oder vorherigen Baustein anliegt. Sie dürfen nur einen Eingang und e...", 
"body" : "dataflow Mit dem Pragma steuern Sie den Datenfluss in der Abarbeitung von Funktionsbausteinen im FUP\/KOP\/AWL-Editor. Das Attribut legt fest, an welchem Eingang oder Ausgang eines Funktionsbausteins die Weiterverbindung zum nächsten oder vorherigen Baustein anliegt. Sie dürfen nur einen Eingang und einen Ausgang in der Deklaration eines Funktionsbausteins mit dem Attribut auszeichnen. Bei Funktionsbausteinen ohne Attribut 'dataflow' wird automatisch der Datenfluss bestimmt: Zunächst wird die Verbindung zwischen einem Ausgang und einem Eingang gleichen Datentyps gelegt. Dabei wird zuerst immer die oberste Eingangs- oder Ausgangsvariable der Funktionsbausteine genommen. Wenn es keine Variablen mit übereinstimmendem Datentyp gibt, wird der obersten Ausgang mit dem obersten Eingang der benachbarten Bausteins verbunden. Syntax : {attribute 'dataflow'} Einfügeort Zeile oberhalb der Zeile mit der Deklaration der entsprechenden Variablen 'dataflow' Kennzeichnet den Eingang oder Ausgang des Funktionsbausteins, der mit dem vorherigen oder nächsten Baustein verbunden ist Die Verbindung zwischen FB und dem vorhergehenden Funktionsbaustein erfolgt über die Eingangsvariable i1 . Die Verbindung zwischen FB und dem nachfolgenden Funktionsbaustein erfolgt über die Ausgangsvariable outRes1 . FUNCTION_BLOCK FB\nVAR_INPUT\n r1 : REAL;\n {attribute 'dataflow'}\n i1 : INT;\n i2 : INT;\n r2 : REAL;\nEND_VAR\n\nVAR_OUTPUT\n {attribute 'dataflow'}\n outRes1 : REAL;\n out1 : INT;\n g1 : INT;\n g2 : REAL;\nEND_VAR " }, 
{ "title" : "Attribut: displaymode ", 
"url" : "_cds_pragma_attribute_displaymode.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: displaymode ", 
"snippet" : "displaymode Das Pragma definiert den Darstellungsmodus einer einzelnen Variablen. Diese Festlegung überschreibt die globale Einstellung für die Darstellung der Monitoring-Variablen, die über die Befehle im Menü Darstellung: Binär, Dezimal und Hexadezimal erfolgt. Syntax : {attribute 'displaymode':= ...", 
"body" : "displaymode Das Pragma definiert den Darstellungsmodus einer einzelnen Variablen. Diese Festlegung überschreibt die globale Einstellung für die Darstellung der Monitoring-Variablen, die über die Befehle im Menü Darstellung: Binär, Dezimal und Hexadezimal erfolgt. Syntax : {attribute 'displaymode':= <display mode> } Folgende Definitionen sind möglich Binärformat {attribute 'displaymode':='bin'} {attribute 'displaymode':='binary'} Dezimalformat {attribute 'displaymode':='dec'} {attribute 'displaymode':='decimal'} Hexadezimalformat {attribute 'displaymode':='hex'} {attribute 'displaymode':='hexadecimal'} Einfügeort: Zeile oberhalb der Zeile mit der Deklaration der entsprechenden Variablen. Beispiel VAR\n {attribute 'displaymode':='hex'}\n dwVar1: DWORD;\nEND_VAR " }, 
{ "title" : "Attribut: enable_dynamic_creation ", 
"url" : "_cds_pragma_attribute_enable_dynamic_creation.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: enable_dynamic_creation ", 
"snippet" : "enable_dynamic_creation Das Pragma enable_dynamic_creation wird benötigt, um den __NEW bei Funktionsbausteinen zu verwenden. Syntax : {attribute 'enable_dynamic_creation'} Einfügeort: Erste Zeile in der Deklaration des Funktionsbausteins....", 
"body" : "enable_dynamic_creation Das Pragma enable_dynamic_creation wird benötigt, um den __NEW bei Funktionsbausteinen zu verwenden. Syntax : {attribute 'enable_dynamic_creation'} Einfügeort: Erste Zeile in der Deklaration des Funktionsbausteins. " }, 
{ "title" : "Attribut: estimated-stack-usage ", 
"url" : "_cds_pragma_attribute_estimated_stack_usage.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: estimated-stack-usage ", 
"snippet" : "estimated-stack-usage Das Pragma übergibt einen Schätzwert für den Stackgrößenbedarf. Methoden mit rekursivem Aufruf halten einer Stackprüfung nicht stand, weil der Stackverbrauch nicht ermittelt werden kann. Folglich wird eine Warnung ausgegeben. Um diese Warnung zu unterdrücken, können Sie der Met...", 
"body" : "estimated-stack-usage Das Pragma übergibt einen Schätzwert für den Stackgrößenbedarf. Methoden mit rekursivem Aufruf halten einer Stackprüfung nicht stand, weil der Stackverbrauch nicht ermittelt werden kann. Folglich wird eine Warnung ausgegeben. Um diese Warnung zu unterdrücken, können Sie der Methode einen Schätzwert in Bytes für den Stackgrößenbedarf mitgeben. Dann durchläuft die Methode die Stackprüfung erfolgreich. Syntax {attribute 'estimated-stack-usage' := ' <estimated stack size in bytes> '} Einfügeort: Erste Zeile über dem Deklarationsteil der Methode Beispiel {attribute 'estimated-stack-usage' := '127'} \/\/ 127 bytes\nMETHOD PUBLIC DoIt : BOOL\nVAR_INPUT\nEND_VAR Für weitere Informationen siehe: Methodenaufruf" }, 
{ "title" : "Rekursiver Methodenaufruf ", 
"url" : "_cds_pragma_attribute_estimated_stack_usage.html#UUID-4670b30e-eb2d-1ea9-9d6e-61159df75c79_id_dd29a4d911bcf410c0a8640e01471f60_id_918a5ded942a17e2c0a8646316297a73", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: estimated-stack-usage \/ Rekursiver Methodenaufruf ", 
"snippet" : "Innerhalb ihrer Implementierung kann eine Methode sich selbst aufrufen: entweder direkt mit Hilfe des THIS -Pointers, oder mit Hilfe einer lokalen Variablen für den zugeordneten Funktionsbaustein. Verwenden Sie Rekursionen vorwiegend zur Bearbeitung von rekursiven Datentypen wie beispielsweise verke...", 
"body" : "Innerhalb ihrer Implementierung kann eine Methode sich selbst aufrufen: entweder direkt mit Hilfe des THIS -Pointers, oder mit Hilfe einer lokalen Variablen für den zugeordneten Funktionsbaustein. Verwenden Sie Rekursionen vorwiegend zur Bearbeitung von rekursiven Datentypen wie beispielsweise verketteten Listen. Allgemein ist es ratsam bei der Verwendung von Rekursion vorsichtig zu sein, da es bei unerwartet tiefen Rekursionen zu eine Stacküberlauf und damit zu einem Maschinenstillstand kommen kann.“ Berechnung der Fakultät Das folgende Programm PLC_PRG berechnet die Fakultät einer Zahl im Funktionsbaustein FB_Factorial auf unterschiedliche Weise in jeweils einer eigenen Methode. Methode m_Iterative : Iterativ Methode m_Pragmaed : Rekursiv mit Warnungsunterdrückung Methode m_Recursive : Rekursiv Methode m_Temp : Temporär mit Warnungsunterdrückung Nur die Methode m_Recursive erzeugt eine Warnung. \/\/ Contains the data of the factorial calculation of uiNumber\nTYPE FACTORIAL_RESULT :\nSTRUCT\n uiNumber : UINT;\n udiIterative : UDINT;\n udiRecursive : UDINT;\n udiPragmaed : UDINT;\n udiTemp : UDINT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n fb_Factorial_A : FB_Factorial;\n factorial_A : FACTORIAL_RESULT := (uiNumber := 9, udiIterative := 0, udiRecursive := 0, udiPragmaed := 0 );\nEND_VAR\nfb_Factorial_A.p_Number := factorial_A.uiNumber;\nfactorial_A.udiIterative := fb_Factorial_A.m_Iterative();\nfactorial_A.udiRecursive := fb_Factorial_A.m_Recursive(uiN := factorial_A.uiNumber);\nfactorial_A.udiPragmaed := fb_Factorial_A.m_Pragmaed(uiN := factorial_A.uiNumber);\nfactorial_A.udiTemp := fb_Factorial_A.m_Temp(uiN := factorial_A.uiNumber);\n\n\/\/Factorial calculation in different ways\nFUNCTION_BLOCK FB_Factorial\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n uiN : UINT;\n udiIterative : UDINT;\n udiPragmaed : UDINT;\n udiRecursive : UDINT;\nEND_VAR\n\n \/\/ Iterative calculation\n METHOD PUBLIC m_Iterative : UDINT\n VAR\n uiCnt : UINT;\n END_VAR\n m_Iterative := 1;\n IF uiN > 1 THEN\n FOR uiCnt := 1 TO uiN DO\n m_Iterative := m_Iterative * uiCnt;\n END_FOR;\n RETURN;\n ELSE\n RETURN;\n END_IF;\n\n \/\/Recursive calculation with suppressed warning\n {attribute 'estimated-stack-usage' := '99'}\n METHOD PUBLIC m_Pragmaed : UDINT\n VAR_INPUT\n uiN : UINT;\n END_VAR\n VAR\n END_VAR\n m_Pragmaed := 1;\n IF uiN > 1 THEN\n m_Pragmaed := uiN * THIS^.m_Pragmaed(uiN := (uiN - 1));\n RETURN;\n ELSE\n RETURN;\n END_IF;\n \n \/\/Recursive calculation\n METHOD PUBLIC m_Recursive : UDINT\n VAR_INPUT\n uiN : UINT;\n END_VAR\n VAR\n END_VAR\n m_Recursive := 1;\n IF uiN > 1 THEN\n m_Recursive := uiN * THIS^.m_Recursive(uiN := (uiN - 1) );\n RETURN;\n ELSE\n RETURN;\n END_IF;\n \n \/\/ Called by temporary FB instance\n {attribute 'estimated-stack-usage' := '99'}\n METHOD PUBLIC m_Temp : UDINT\n VAR_INPUT\n uiN : UINT;\n END_VAR\n VAR\n fb_Temp : FB_Factorial;\n END_VAR\n m_Temp := 1;\n IF uiN > 1 THEN\n m_Temp := uiN * fb_Temp.m_Temp(uiN := (uiN - 1));\n RETURN;\n ELSE\n RETURN;\n END_IF;\n\nPROPERTY p_Number : UINT\nuiN := p_Number; \/\/Setter method Bei der Ausführung des Programms generiert nur die Methode m_Recursive eine Warnung. " }, 
{ "title" : "Attribut: ExpandFully ", 
"url" : "_cds_pragma_attribute_expandfully.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: ExpandFully ", 
"snippet" : "ExpandFully Das Pragma bewirkt, dass die Komponenten eines Arrays, das als Eingabevariable für referenzierte Visualisierungen verwendet wird, im Eigenschaftendialog der Visualisierung sichtbar gemacht werden. Syntax: {attribute 'ExpandFully'} Einfügeort: Die Zeile oberhalb der Zeile mit der Deklarat...", 
"body" : "ExpandFully Das Pragma bewirkt, dass die Komponenten eines Arrays, das als Eingabevariable für referenzierte Visualisierungen verwendet wird, im Eigenschaftendialog der Visualisierung sichtbar gemacht werden. Syntax: {attribute 'ExpandFully'} Einfügeort: Die Zeile oberhalb der Zeile mit der Deklaration des Arrays. Visualisierung visu soll in einen Frame innerhalb von Visualisierung visu_main eingefügt werden. arr ist als Eingabevariable im Schnittstelleneditor von visu definiert und wird somit später für Zuweisungen im Eigenschaftendialog des Frames in visu_main bereitstehen. Um auch die einzelnen Komponenten von arr in diesem Eigenschaftendialog verfügbar zu bekommen, müssen Sie das Attribut 'ExpandFully' im Schnittstelleneditor von visu direkt vor arr einfügen. Deklaration im Schnittstelleneditor von visu : VAR_INPUT\n{attribute 'ExpandFully'}\n arr : ARRAY[0..5] OF INT;\nEND_VAR " }, 
{ "title" : "Attribut: global_init_slot ", 
"url" : "_cds_pragma_attribute_global_init_slot.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: global_init_slot ", 
"snippet" : "global_init_slot Das Pragma definiert die Reihenfolge der Initialisierung von Programmierbausteinen und globalen Variablenlisten: Variablen innerhalb einer GVL oder POU werden von oben nach unten initialisiert. Im Fall von mehreren globalen Variablenlisten ist deren Initialisierungsreihenfolge unbes...", 
"body" : "global_init_slot Das Pragma definiert die Reihenfolge der Initialisierung von Programmierbausteinen und globalen Variablenlisten: Variablen innerhalb einer GVL oder POU werden von oben nach unten initialisiert. Im Fall von mehreren globalen Variablenlisten ist deren Initialisierungsreihenfolge unbestimmt. Bei Initialisierungen mit Literalwerten, beispielsweise 1 , 'hallo' , 3.6 , oder Konstanten von Basisdatentypen spielt die Reihenfolge der Initialisierungen keine Rolle. Wenn es bei den Initialisierungen jedoch Abhängigkeiten zwischen den Listen gibt, müssen Sie die Initialisierungsreihenfolge festlegen. Dazu können Sie einer GVL oder einer POU mit dem Attribut 'global_init_slot' einen definierten Initialisierungsslot zuweisen. Konstanten werden vor den Variablen initialisiert, und zwar in der gleichen Reihenfolge wie die Variablen. Bei der Initialisierung werden die Bausteine nach dem Wert für <slot> sortiert. Anschließend wird der Code für die Initialisierung der Konstanten erzeugt und danach der Code für die Initialisierung der Variablen. Syntax : {attribute 'global_init_slot' := '<slot>'} Einfügeort Das Pragma wirkt immer auf die gesamte GVL oder POU und muss deshalb oberhalb der VAR_GLOBAL -Deklaration oder der POU-Deklaration stehen <slot> Ganzzahliger Wert, der die Position in der Reihenfolge der Aufrufe definiert Der Standardwert für eine POU (Programm, Funktionsbaustein) ist 50000. Der Standardwert für eine GVL ist 49990. Ein niedrigerer Wert bewirkt eine frühere Initialisierung. Wenn mehrere Programmierbausteine denselben Wert für das Attribut 'global_init_slot' zugewiesen bekommen haben, bleibt die Reihenfolge ihrer Initialisierung unbestimmt. Beispiel Das Projekt enthält die zwei globalen Variablenlisten GVL_1 und GVL_2 und das Programm PLC_PRG , das Variablen aus beiden Listen verwendet. GVL_1 verwendet zur Initialisierung der Variablen A die Variable B , die in GVL_2 mit 1000 initialisiert wird. GVL_1 VAR_GLOBAL \/\/49990\n A : INT := GVL_2.B*100;\nEND_VAR GVL_2 VAR_GLOBAL \/\/49990\n B : INT := 1000;\n C : INT := 10;\nEND_VAR PLC_PRG PROGRAM PLC_PRG \/\/50000\nVAR\n ivar: INT := GVL_1.A;\n ivar2: INT;\nEND_VAR\n\nivar:=ivar+1;\nivar2:=GVL_2.C; In diesem Fall gibt der Compiler einen Fehler aus, weil GVL_2.B zur Initialisierung von GVL_1.A verwendet wird, bevor GVL_2 initialisiert wurde. Dies können Sie verhindern, indem Sie mit dem Attribut global_init_slot die Position von GVL_2 in der Initialisierungsreihenfolge vor GVL_1 stellen. Dazu muss GVL_1 im vorliegenden Beispiel mindestens einen Slot-Wert von 49989 erhalten, um die früheste Initialisierung innerhalb des Programms zu erreichen. Jeder noch niedrigere Wert hat denselben Effekt: GVL_2 {attribute 'global_init_slot' := '100'}\nVAR_GLOBAL\n B : INT := 1000;\nEND_VAR Die Verwendung von GVL_2.C im Implementierungsteil von PLC_PRG ist auch ohne Pragmaverwendung unkritisch, da beide GVLs in jedem Fall vor dem Programm initialisiert werden. Für weitere Informationen siehe: Global Init Slots" }, 
{ "title" : "Attribut: hide ", 
"url" : "_cds_pragma_attribute_hide.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: hide ", 
"snippet" : "hide Das Verbergen von Variablen und Bausteinen mit dem Pragma {attribute 'hide'} ist in den allermeisten Fällen nicht zielführend. Verwenden Sie deshalb bevorzugt das Pragma {attribute 'conditionalshow'} . Das Pragma verhindert, dass die mit ihm definierten Variablen und Programmierbausteine in der...", 
"body" : "hide Das Verbergen von Variablen und Bausteinen mit dem Pragma {attribute 'hide'} ist in den allermeisten Fällen nicht zielführend. Verwenden Sie deshalb bevorzugt das Pragma {attribute 'conditionalshow'} . Das Pragma verhindert, dass die mit ihm definierten Variablen und Programmierbausteine in der CODESYS -Oberfläche angezeigt werden. Somit können Sie diese Bezeichner bewusst verbergen, ohne dass der Zugriff eingeschränkt ist. Das kann nützlich sein, wenn Sie Bibliotheken entwickeln. Betroffene Features: Bibliotheksverwaltung Debugging Eingabehilfe Feature “Komponenten auflisten“ Monitoring Symbolkonfiguration Die mit dem Pragma definierten Variablen oder Bausteine sind weder im Bibliotheksverwalter sichtbar, noch werden sie in der Eingabehilfe oder bei der Funktion „Komponenten auflisten“ angeboten. Das Pragma verhindert, dass damit gekennzeichnete Variablen in der Symbolkonfiguration angezeigt werden. Sie können solche Variablen somit nicht als Symbol exportieren. Auch im Onlinebetrieb sind die Variablen unsichtbar, folglich können deren Werte nicht überwacht werden. Außerdem können Sie keine Debugging-Funktionalitäten anwenden und haben keine Unterstützung bei einer Fehlersuche. Wenn Sie als Applikationsentwickler den Instanzpfad der verborgenen Bausteine und Variablen exakt kennen, können Sie auf diese im Code zugreifen. Syntax : {attribute 'hide'} Einfügeort: Bei Variablen oberhalb der Zeile mit der Deklaration der Variablen. Bei Programmierbausteinen in der ersten Zeile. Verborgene Variable Der Funktionsbaustein FB_MyA enthält das Attributpragma {attribute 'hide'} , um die lokale Variable xInvisibleIn zu verberben. FUNCTION_BLOCK FB_MyA\nVAR_INPUT\n iInA : INT;\n {attribute 'hide'}\n xInvisibleIn : BOOL;\n xInit: BOOL;\nEND_VAR\nVAR_OUTPUT\n iOutA : INT;\nEND_VAR\nVAR\n iCounter : INT;\nEND_VAR Im Hauptprogramm werden 2 Instanzen des Funktionsbausteins FB_MyA definiert. PROGRAM PLC_PRG\nVAR\n fbMyA1, fbMyA2 : FB_MyA;\n xVar2 : BOOL;\n iVar1 : INT;\n iVar2 : INT;\nEND_VAR\nfbMyA1(iInA := 1, xInit := TRUE, xInvisibleIn := TRUE, iOutA => iVar1);\nfbMyA2(iInA := 1, xInit := TRUE, iOutA => iVar2); Während nun ein Eingabewert für fbMyA1 implementiert wird, zeigt die Funktion „Komponenten auflisten“, die sich beim Tippen von fbMyA1. (im Implementierungsteil von PLC_PRG ) öffnet, die Variablen iInA , xInit und iOutA an, nicht aber die versteckte Variable xInvisibleIn . Verborgener Bibliotheksbaustein FB_A ist ein Baustein der Bibliothek HiddenFunctionality mit dem Standard-Namensraum HIDDEN . Um den Bezeichner und den Bausteincode vor Applikationsentwicklern zu verbergen, beginnt die Deklaration des Bausteins mit dem Attributpragma {attribute 'hide'} . Um die untergeordneten Programmierbausteine (Aktionen, Methoden, Eigenschaften, Transitionen) genauso zu verbergen, beginnen auch deren Deklarationen mit {attribute 'hide'} . {attribute 'hide'}\nFUNCTION_BLOCK FB_A\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\n iCount : INT;\n iInvisible : INT;\nEND_VAR\n\n{attribute 'hide'}\nMETHOD METH_Count : INT\nVAR_INPUT\nEND_VAR\niCount := iCount + 1;\n\n{attribute 'hide'}\nMETHOD METH_Invisible : BOOL\nVAR_INPUT\nEND_VAR\niInvisible := iInvisible + 1;\n\n{attribute 'hide'}\nPROPERTY PUBLIC prop_iA : INT Für Sie als Applikationsentwickler sind alle Bausteine unsichtbar. Nur wenn Sie den Instanzpfad kennen, können Sie diese verwenden. PROGRAM PLC_PRG\nVAR\n fbHidden : HIDDEN.FB_A; \/\/ Hidden function block from library HiddenFunctionality\n iCounter : INT;\nEND_VAR\nfbHidden.METH_Invisible();\niCounter := fbHidden.iInvisible; Im Onlinebetrieb wird kein Monitoring durchgeführt. Mit dem Pragma {attribute 'hide_all_locals'} können Sie alle lokalen Variablen eines Programierbausteins verbergen. " }, 
{ "title" : "Attribut: hide_all_locals ", 
"url" : "_cds_pragma_attribute_hide_all_locals.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: hide_all_locals ", 
"snippet" : "hide_all_locals Das Pragma verhindert, dass alle lokalen Variablen einer Signatur in der Anzeige der Funktion „Komponenten auflisten“, in der Eingabehilfe oder im Deklarationsteil im Onlinebetrieb sichtbar sind. Außerdem sind diese Variablen in der Symbolkonfiguration ausgeblendet und können somit n...", 
"body" : "hide_all_locals Das Pragma verhindert, dass alle lokalen Variablen einer Signatur in der Anzeige der Funktion „Komponenten auflisten“, in der Eingabehilfe oder im Deklarationsteil im Onlinebetrieb sichtbar sind. Außerdem sind diese Variablen in der Symbolkonfiguration ausgeblendet und können somit nicht als Symbol exportiert werden. Nützlich ist das Pragma besonders in Bibliotheksbausteinen, um Bausteinvariablen vor Anwendern zu verstecken. Betroffene Features Bibliotheksverwaltung Debugging Eingabehilfe Feature “Komponenten auflisten“ Monitoring Symbolkonfiguration Syntax : {attribute 'hide_all_locals'} Einfügeort: Erste Zeile über dem Deklarationsteil der POU Beispiel Der Funktionsbaustein FB_MyB verwendet das Attribut: {attribute 'hide_all_locals'}\nFUNCTION_BLOCK FB_MyB\nVAR_INPUT\n iInB : INT;\n {attribute 'hide'}\n xInvisibleIn : BOOL;\n xInit: BOOL;\nEND_VAR\nVAR_OUTPUT\n iOutB : INT;\nEND_VAR\nVAR\n iCounter : INT;\n xVar : BOOL;\nEND_VAR Im Hauptprogramm werden zwei Instanzen des Funktionsbausteins FB_MyB definiert. PROGRAM PLC_PRG\nVAR\n fbMyB1, fbMyB2: FB_MyB;\n iVar3: INT;\n iVar4: INT;\nEND_VAR\n\nfbMyB1(iInB := 2, xInvisibleIn := TRUE, iOutB => iVar3);\nfbMyB2(iInB := 2, iOutB => iVar4);\nIF fbMyB2.iCounter > 100 THEN\n fbMyB2.xInit := TRUE;\nEND_IF Wenn Sie nun das Programm auf die Steuerung laden, starten und in den Onlinebetrieb wechseln, werden im Deklarationseditor die Variablen iInB , xInit , iOutB und xReset angezeigt. Jedoch nicht die verborgenen lokalen Variablen iCounter und xVar . " }, 
{ "title" : "Attribut: initialize_on_call ", 
"url" : "_cds_pragma_attribute_initialize_on_call.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: initialize_on_call ", 
"snippet" : "initialize_on_call Das Pragma bewirkt, dass Eingangsvariablen eines Funktionsbausteins bei jedem Aufruf des Funktionsbausteins initialisiert werden. WEnn eine Eingangsvariable betroffen ist, der einen Pointer erwartet, und dieser Pointer im Zuge eines Online-Changes entfernt wurde, wird die Variable...", 
"body" : "initialize_on_call Das Pragma bewirkt, dass Eingangsvariablen eines Funktionsbausteins bei jedem Aufruf des Funktionsbausteins initialisiert werden. WEnn eine Eingangsvariable betroffen ist, der einen Pointer erwartet, und dieser Pointer im Zuge eines Online-Changes entfernt wurde, wird die Variable mit Null initialisiert. Syntax: {attribute 'initialize_on_call'} Einfügeort: Immer in der ersten Zeile im Deklarationsteil für den gesamten Funktionsbaustein und zusätzlich in einer Zeile oberhalb der Deklaration der einzelnen Eingangsvariablen. Beispiel {attribute 'initialize_on_call'}\nFUNCTION_BLOCK fb\nVAR_INPUT\n {attribute 'initialize_on_call'}\n pInt : POINTER TO INT := 0;\n {attribute 'initialize_on_call'}\n iVal : INT := 0;\nEND_VAR " }, 
{ "title" : "Attribut: init_namespace ", 
"url" : "_cds_pragma_attribute_init_namespace.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: init_namespace ", 
"snippet" : "init_namespace Das Pragma bewirkt, dass eine Variable vom Typ STRING oder WSTRING , die in einem Bibliotheksbaustein mit diesem Pragma deklariert ist, bei der Verwendung im Projekt mit dem aktuellen Namensraum der Bibliothek initialisiert wird. Syntax {attribute 'init_namespace'} Einfügeort: Die Zei...", 
"body" : "init_namespace Das Pragma bewirkt, dass eine Variable vom Typ STRING oder WSTRING , die in einem Bibliotheksbaustein mit diesem Pragma deklariert ist, bei der Verwendung im Projekt mit dem aktuellen Namensraum der Bibliothek initialisiert wird. Syntax {attribute 'init_namespace'} Einfügeort: Die Zeile oberhalb der Zeile mit der Deklaration der Variablen in einem Bibliotheksbaustein. Der Funktionsbaustein POU ist mit den nötigen Attributen versehen: FUNCTION_BLOCK POU\nVAR_OUTPUT\n {attribute 'init_namespace'}\n myStr: STRING;\nEND_VAR Innerhalb des Hauptprogramms PLC_PRG ist eine Instanz fb des Funktionsbausteins POU definiert: PROGRAM PLC_PRG\nVAR\n fb:POU;\n newString: STRING;\nEND_VAR\nnewString := fb.myStr; Die Variable myStr wird mit dem aktuellen Namensraum initialisiert, zum Beispiel MyLib . Dieser Wert wird newString im Hauptprogramm zugewiesen. " }, 
{ "title" : "Attribut: init_on_onlchange ", 
"url" : "_cds_pragma_attribute_init_on_onlchange.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: init_on_onlchange ", 
"snippet" : "init_on_onlchange Kein Initialisierungscode bei schnellem Online-Change Seit Compilerversion >= 3.5.0.0 wird für kleine Änderungen ein „schneller Online-Change“ durchgeführt. Bei schnellem Online-Change wird nur der jeweils geänderte Baustein übersetzt und nachgeladen. Insbesondere wird kein Initial...", 
"body" : "init_on_onlchange Kein Initialisierungscode bei schnellem Online-Change Seit Compilerversion >= 3.5.0.0 wird für kleine Änderungen ein „schneller Online-Change“ durchgeführt. Bei schnellem Online-Change wird nur der jeweils geänderte Baustein übersetzt und nachgeladen. Insbesondere wird kein Initialisierungscode erzeugt. Bei Variablen mit dem Attribut init_on_onlchange führt das ebenfalls dazu, dass kein Initialisierungscode erzeugt wird. In den üblichen Szenarien wird das keine Auswirkungen haben: Das Attribut wird üblicherweise verwendet, um Variablen mit Adressen zu initialisieren. Beim schnellen Online-Change kommt es jedoch nicht dazu, dass eine Variable ihre Adresse ändert. Um dennoch die Wirkung des Attributs init_on_onlchange auf den gesamten Applikationscode sicherzustellen, können Sie generell für die Applikation den schnellen Online-Change mit Hilfe der Compiler-Define no_fast_online_change ausschalten. Selektieren Sie dafür im Gerätebaum Ihr Applikationsobjekt und wählen Sie den Kontextbefehl Eigenschaften . Fügen Sie dort unter der Registerkarte Build die Compiler-Define no_fast_online_change hinzu. Für weitere Informationen siehe: BuildDas Pragma bewirkt, dass die Variable, auf die das Pragma angewendet wird, bei jedem Online-Change initialisiert wird. Syntax: {attribute 'init_on_onlchange' } Einfügeort: Die Zeile oberhalb der Zeile mit der Deklaration der Variablen. Beispiel VAR_GLOBAL    \n {attribute 'init_on_onlchange'}    \n g_fastOnlineChange : BOOL := FALSE;\nEND_VAR\n {attribute 'call_after_online_change_slot' := '4567'}\nFUNCTION FUNC_OnlineChangeDetection : BOOL\nVAR_INPUT\nEND_VAR\nVAR\nEND_VAR \n\nIF GVL_OnlineChangeDetection.g_fastOnlineChange THEN    \n \/\/ here you know that you are inside a FastOnlineChange\nEND_IF\n\/\/ reset for next detection\nGVL_OnlineChangeDetection.g_fastOnlineChange := TRUE; " }, 
{ "title" : "Attribut: instance-path ", 
"url" : "_cds_pragma_attribute_instance_path.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: instance-path ", 
"snippet" : "instance-path Das Pragma kann auf eine lokale Stringvariable angewandt werden. Es bewirkt, dass diese lokale Stringvariable in Folge mit dem Gerätebaumpfad der POU, zu der sie gehört, initialisiert wird. Dies kann für Fehlermeldungen nützlich sein. Die Anwendung des Pragmas setzt die Anwendung des A...", 
"body" : "instance-path searchresult_toplevel Das Pragma kann auf eine lokale Stringvariable angewandt werden. Es bewirkt, dass diese lokale Stringvariable in Folge mit dem Gerätebaumpfad der POU, zu der sie gehört, initialisiert wird. Dies kann für Fehlermeldungen nützlich sein. Die Anwendung des Pragmas setzt die Anwendung des Attributs ' reflection ' auf den zugehörigen Programmierbaustein voraus, sowie die Anwendung des zusätzlichen Attributs ' noinit ' auf die Stringvariable selbst. Syntax : {attribute 'instance-path'} Einfügeort: Die Zeile oberhalb der Zeile mit der Deklaration der STRING -Variablen. Beispiel Der folgende Funktionsbaustein enthält die Attribute 'reflection' , 'instance-path' und 'noinit' . {attribute 'reflection'}\nFUNCTION_BLOCK POU\nVAR\n {attribute 'instance-path'}\n {attribute 'noinit'}\n str: STRING;\nEND_VAR Im Hauptprogramm PLC_PRG ist eine Instanz myPOU des Funktionsbausteins POU definiert: PROGRAM PLC_PRG\nVAR\n myPOU:POU;\n myString: STRING;\nEND_VAR\nmyPOU();\nmyString:=myPOU.str; Nach der Initialisierung von Instanz myPOU wird der String-Variablen str der Pfad der Instanz myPOU zugewiesen, im Beispiel PLCWinNT.Application.PLC_PRG.myPOU . Dieser Pfad wird im Hauptprogramm der Variablen myString zugewiesen. Die Länge einer Zeichenkette können Sie beliebig definieren (auch >255). Allerdings müssen Sie bedenken, dass die Zeichenkette (von hinten her) abgeschnitten wird, wenn sie einer Variablen zugewiesen ist, deren Datentyp zu klein dafür ist. " }, 
{ "title" : "Attribut: io_function_block, io_function_block_mapping ", 
"url" : "_cds_pragma_attribute_io_function_block_mapping.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: io_function_block, io_function_block_mapping ", 
"snippet" : "io_function_block, io_function_block_mapping Das Attribut io_function_block bewirkt, dass ein Funktionsbaustein, der damit ausgezeichnet ist, in der Gerätekonfiguration für die Zuweisung auf einen Kanal im E\/A-Abbild bereitsteht Der Funktionsbaustein erscheint im Dialog Funktionsbaustein auswählen ....", 
"body" : "io_function_block, io_function_block_mapping Das Attribut io_function_block bewirkt, dass ein Funktionsbaustein, der damit ausgezeichnet ist, in der Gerätekonfiguration für die Zuweisung auf einen Kanal im E\/A-Abbild bereitsteht Der Funktionsbaustein erscheint im Dialog Funktionsbaustein auswählen . Das Attribut 'io_function_block_mapping' bewirkt in einem solchen Funktionsbaustein, dass ein Parameter gekennzeichnet ist, der beim Abbilden des Funktionsbausteins auf einen Gerätekanal automatisch verwendet wird. Sie können mehrere Parameter des Funktionsbausteins mit dem Attribut versehen. Beim E\/A-Mapping wird automatisch der erste verwendet, der vom Typ her zum Kanal passt (Eingang, Ausgang, Datentyp). Syntax : {attribute 'io_function_block'} {attribute 'io_function_block_mapping'} Einfügeort: Zeile oberhalb der ersten Zeile in der Deklaration des Funktionsbausteins und in der Zeile oberhalb der Parameterdeklaration. Beispiel {attribute 'io_function_block'}\nFUNCTION_BLOCK Scale_Output_Int\nVAR_INPUT\n iInput : INT;\n iNumerator : INT;\n iDenominator : INT :=1;\n iOffset : INT := 0;\nEND_VAR\nVAR_OUTPUT\n {attribute 'io_function_block_mapping'}\n iOutput : INT;\nEND_VAR\n " }, 
{ "title" : "Attribut: is_connected ", 
"url" : "_cds_pragma_attribute_is_connected.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: is_connected ", 
"snippet" : "is_connected Mit dem Pragma 'is_connected' kennzeichnen Sie eine boolsche Funktionsbausteinvariable, die beim Aufruf einer Funktionsbaustein-Instanz Information darüber gibt, ob der zugeordnete Eingang des Bausteins eine Zuweisung erhält. Die Anwendung des Pragmas setzt die Anwendung des Attributs '...", 
"body" : "is_connected Mit dem Pragma 'is_connected' kennzeichnen Sie eine boolsche Funktionsbausteinvariable, die beim Aufruf einer Funktionsbaustein-Instanz Information darüber gibt, ob der zugeordnete Eingang des Bausteins eine Zuweisung erhält. Die Anwendung des Pragmas setzt die Anwendung des Attributs 'reflection' auf den betroffenen Funktionsbaustein voraus. Syntax : {attribute 'is_connected' := '<input variable>'} Beispiel Im Funktionsbaustein FB wird für jede Eingangsvariable ( in1 und in2 ) eine lokale Variable deklariert und dieser jeweils das Attribut 'is connected' mit Angabe der Eingangsvariablen vorangestellt. Der Funktionsbaustein selbst erhält das Pragmaattribut 'reflection' . Wenn eine Instanz des Funktionsbausteins aufgerufen wird, wird die lokale Variable TRUE , falls der ihr zugeordnete Eingang eine Zuweisung bekommen hat. {attribute 'reflection'}\nFUNCTION_BLOCK FB\nVAR_INPUT\n in1: INT;\n in2: INT;\nEND_VAR\nVAR\n {attribute 'is_connected' := 'in1'}\n in1_connection_info: BOOL;\n {attribute 'is_connected' := 'in2'}\n in2_connection_info: BOOL;\nEND_VAR Annahme: in1 erhält beim Aufruf der Funktionsbaustein-Instanz eine Zuweisung von außerhalb, in 2 erhält zu diesem Zeitpunkt keine Zuweisung. Dann entsteht folgender Code: in1_connection_info := TRUE;\nin2_connection_info := FALSE; " }, 
{ "title" : "Attribut: linkalways ", 
"url" : "_cds_pragma_attribute_linkalways.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: linkalways ", 
"snippet" : "linkalways Mittels des Pragmas {attribute 'linkalways'} wird der Compiler angewiesen, einen Programmierbaustein oder einen Bibliotheksbaustein immer in der Compile-Information einzubinden. Beim Übersetzen wird der Baustein kompiliert und ist Teil des Applikationscodes. Beim Download wird der Baustei...", 
"body" : "linkalways Mittels des Pragmas {attribute 'linkalways'} wird der Compiler angewiesen, einen Programmierbaustein oder einen Bibliotheksbaustein immer in der Compile-Information einzubinden. Beim Übersetzen wird der Baustein kompiliert und ist Teil des Applikationscodes. Beim Download wird der Baustein auf die SPS geladen. Syntax : {attribute 'linkalways'} Einfügeort: Erste Zeile im Deklarationsteil des Programmierbausteins oder des Bibliotheksbausteins Der Baustein darf sowohl projektweit (abgelegt in der Ansicht POUs ) als auch applikationsweit (abgelegt in der Ansicht Geräte ) gültig sein. Alternativ können Sie bei einem Baustein in dessen Objekteigenschaften in der Registerkarte Build die Option Immer binden aktivieren. Beispiel Die GVL MoreSymbols enthält das Pragma {attribute 'linkalways'} . Die dort deklarierten Variablen sind damit unabhängig von etwaigen Zugriffen Teil des Applikationscodes. GVL MoreSymbols {attribute 'linkalways'}\nVAR_GLOBAL\n g_iAlfa: INT;\n g_iBravo: INT;\n g_iCharlie: INT;\nEND_VAR Auch die Symbolkonfiguration greift auf die Compile-Information zu. Somit werden im Editor Symbolkonfiguration die Variablen der GVL MoreSymbols immer zur Auswahl angeboten. " }, 
{ "title" : "Attribut: monitoring ", 
"url" : "_cds_pragma_attribute_monitoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: monitoring ", 
"snippet" : "monitoring Das Pragma bewirkt, dass Sie Werte von Eigenschaften oder Funktionsaufrufen in der Onlineansicht des IEC-Editors oder in einer Überwachungsliste monitoren können. Dazu gibt es zwei mögliche Attributwerte: 'variable' und 'call' . Syntax {attribute 'monitoring' := 'variable'} {attribute 'mo...", 
"body" : "monitoring searchresult_toplevel Das Pragma bewirkt, dass Sie Werte von Eigenschaften oder Funktionsaufrufen in der Onlineansicht des IEC-Editors oder in einer Überwachungsliste monitoren können. Dazu gibt es zwei mögliche Attributwerte: 'variable' und 'call' . Syntax {attribute 'monitoring' := 'variable'} {attribute 'monitoring' := 'call'} " }, 
{ "title" : "Monitoring von Programmierobjekten und deren Eigenschaften ", 
"url" : "_cds_pragma_attribute_monitoring.html#UUID-b1b46724-01c4-546c-fe9d-2236c7c9e2df_id_edeaa3c5d0ed2fac0a8640e00361c29_id_a51754afb92821c6c0a86463317326eb", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: monitoring \/ Monitoring von Programmierobjekten und deren Eigenschaften ", 
"snippet" : "Wenn Sie das Pragma {attribute 'monitoring':='call'} einfügen, um zu monitoren, müssen Sie mögliche Seiteneffekte bedenken. Solche Seiteneffekte können auftreten, wenn innerhalb der Eigenschaft zusätzliche Operationen implementiert sind. Das Pragma {attribute 'monitoring'} wird auch für die Symbolko...", 
"body" : "Wenn Sie das Pragma {attribute 'monitoring':='call'} einfügen, um zu monitoren, müssen Sie mögliche Seiteneffekte bedenken. Solche Seiteneffekte können auftreten, wenn innerhalb der Eigenschaft zusätzliche Operationen implementiert sind. Das Pragma {attribute 'monitoring'} wird auch für die Symbolkonfiguration ausgewertet. Beim Wert 'variable' ist dabei nur ein Lesezugriff möglich. Sie können in der Onlineansicht eines Funktionsbausteins oder eines Programms zusätzlich zu den lokalen Variablen die untergeordneten Eigenschaften monitoren. Sie können somit die Werte der Get - und Set -Methoden überwachen. Fügen Sie entweder das Pragma {attribute 'monitoring' := 'variable'} oder das Pragma {attribute 'monitoring' := 'call'} in der Deklaration des Eigenschaftbausteins ein. Dann werden automatisch die aktuellen Werte der Eigenschaft im IEC-Editor oder in einer Überwachungsliste angezeigt. Beispiel Das Objekt PLC_PRG zeigt während des Onlinebetriebs im ST-Editor den Wert der Eigenschaft Minutes an der Aufrufstelle inline an. Denn in der Deklaration der Eigenschaft Minutes steht das Pragma {attribute 'monitoring' := 'variable'} . Prüfen Sie für jeden Anwendungsfall sorgfältig, welches Attributpragma geeignet ist, den gewünschten Wert anzuzeigen. Dies hängt davon ab, ob innerhalb der Eigenschaft weitere Operationen mit den Variablen implementiert sind. Pragma {attribute 'monitoring':='variable'} Für die Eigenschaft wird eine implizite Variable angelegt, die immer dann den aktuellen Eigenschaftswert erhält, wenn die Applikation die Set - oder Get -Methode aufruft. Der zuletzt in dieser Variablen gespeicherte Wert wird im Monitoring dargestellt. Pragma {attribute 'monitoring':='call'} Dieses Attribut können Sie nur für Eigenschaften verwenden, die einfache Datentypen oder Pointer zurückgeben, nicht aber für strukturierte Typen. Der zu monitorende Wert wird durch direktes Aufrufen der Eigenschaft gelesen oder geschrieben. Das bedeutet, dass der Monitoring-Dienst des Laufzeitsystems die Get - oder Set -Methode der Eigenschaft ausführt. Mit dem Kontextmenübefehl Zur Überwachungsliste hinzufügen wird im Onlinebetrieb eine Variable, auf der gerade der Cursor steht, unmittelbar in eine Überwachungsliste aufgenommen. Forcen oder Schreiben von Funktionen wird nicht unterstützt. Forcen können Sie jedoch implizit implementieren, indem Sie einen zusätzlichen Eingabeparameter für die jeweilige Funktion hinzufügen, der als internes Force-Flag dient. Funktionsmonitoring ist im Kompaktlaufzeitsystem nicht möglich. " }, 
{ "title" : "Attribut: monitoring_display ", 
"url" : "_cds_pragma_attribute_monitoring_display.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: monitoring_display ", 
"snippet" : "monitoring_display Dieses Pragma in der Deklaration eines Funktionsbaustein oder einer Struktur bewirkt, dass der aktuelle Wert der angegebenen Komponente ( Eigenschaft oder Variable) im Monitoring mit angezeigt wird. Der Wert der Baustein- oder Strukturkomponente wird dann in der obersten Zeile des...", 
"body" : "monitoring_display Dieses Pragma in der Deklaration eines Funktionsbaustein oder einer Struktur bewirkt, dass der aktuelle Wert der angegebenen Komponente ( Eigenschaft oder Variable) im Monitoring mit angezeigt wird. Der Wert der Baustein- oder Strukturkomponente wird dann in der obersten Zeile des Monitorings für Variablen vom Typ des Funktionsbausteins oder der Struktur dargestellt. Syntax: {attribute 'monitoring_display' := '<component name>'} Einfügeort: Oberhalb der ersten Zeile der Deklaration Beispiel {attribute 'monitoring_display' := 'stMonitoring'} \nTYPE ADUT :\nSTRUCT\t\n val1: INT;\t\n val2: INT;\t\n stMonitoring: STRING := 'to be monitored';\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\t\n mydut: ADUT;\n nTest: INT;\nEND_VAR\nnTest:= iCounter + 1;\nmydut.stMonitoring := INT_TO_STRING(nTest);\n " }, 
{ "title" : "Attribut: monitoring_encoding ", 
"url" : "_cds_pragma_attribute_monitoring_encoding.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: monitoring_encoding ", 
"snippet" : "monitoring_encoding Das Attributpragma ist bei Variablen des Datentyps STRING und bei Variablen eines Alias-Datentyps des Typs STRING erlaubt. Das Attribut bewirkt, dass während des Monitorings die Werte der damit gekennzeichneten Variablen im UTF-8-Format dekodiert werden. Syntax : {attribute 'moni...", 
"body" : "monitoring_encoding Das Attributpragma ist bei Variablen des Datentyps STRING und bei Variablen eines Alias-Datentyps des Typs STRING erlaubt. Das Attribut bewirkt, dass während des Monitorings die Werte der damit gekennzeichneten Variablen im UTF-8-Format dekodiert werden. Syntax : {attribute 'monitoring_encoding' := 'UTF8'} Einfügeort: Oberhalb der Variablendeklaration Beispiel PROGRAM PLC_PRG\nVAR\n {attribute 'monitoring.encoding' := 'UTF8'}\n strDat : STRING := 'abc'; \n attribute 'monitoring_encoding' := 'UTF-8'}\t\n strVarUtf8: STRING := UTF8#'你好,世界!ÜüÄäÖö';\n {attribute 'monitoring_encoding' := 'UTF-8'}\n str1: STRING := UTF8#'AÄyyy';\t\t\n {attribute 'monitoring_encoding' := 'UTF-8'}\t\t\n str2: STRING := UTF8#'AÄxxxÜÜÜ';\t\n\t\t\n strVarUtf8_1: STRING := '你好,世界!ÜüÄäÖö';\n str1_1: STRING := 'AÄyyy';\t\t\t\t\n str2_1: STRING := 'AÄxxxÜÜÜ';\t\t\t\nEND_VAR " }, 
{ "title" : "Attribut: no_assign, no_assign_warning ", 
"url" : "_cds_pragma_attribute_no_assign.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: no_assign, no_assign_warning ", 
"snippet" : "no_assign, no_assign_warning Das Pragma 'no_assign' bewirkt, dass Compilerfehler ausgegeben werden, wenn eine Instanz des Funktionsbausteins einer anderen Instanz desselben Bausteins zugewiesen wird. Solche Zuweisungen sollen oft vermieden werden, wenn der Funktionsbaustein Pointer enthält und Point...", 
"body" : "no_assign, no_assign_warning Das Pragma 'no_assign' bewirkt, dass Compilerfehler ausgegeben werden, wenn eine Instanz des Funktionsbausteins einer anderen Instanz desselben Bausteins zugewiesen wird. Solche Zuweisungen sollen oft vermieden werden, wenn der Funktionsbaustein Pointer enthält und Pointer zu Problemen führen, weil sie bei der Wertzuweisung mit kopiert werden. Das Pragma 'no_assign_warning' bewirkt das Gleiche wie das Pragma 'no_assign' mit dem Unterschied, dass anstelle eines Compilerfehlers eine Compilerwarnung ausgegeben wird. Syntax : {attribute 'no_assign'} Einfügeort: Erste Zeile im Deklarationsteil eines Funktionsbausteins. Beispiel Zuweisung von Funktionsbausteininstanzen, die Pointer enthalten In diesem Beispiel wird die Wertzuweisung der Funktionsbaustein-Instanzen zu Problemen bei der Ausführung von fb_exit führen: VAR_GLOBAL\n inst1 : TestFB;\n awsBufferLogFile : ARRAY [0..9] OF WSTRING(66);(* Area: 0, Offset: 0x1304 (4868)*)\n LogFile : SEDL.LogRecord := (sFileName := 'LogFile.log', pBuffer := ADR(awsBufferLogFile), udiMaxEntriesFile := UDINT#10000, udiMaxBuffered := UDINT#10, uiLineSize := UINT#64, wsSep := \" \", xCircular := TRUE, siDateFormat := SINT#0, siTimeFormat := SINT#0);\nEND_VAR\n\nPROGRAM PLC_PRG\nVAR\n inst2 : TestFB := inst1;\n LogFileNew\nEND_VAR In diesem Fall verwaltet LogRecord eine Liste von Pointern, für die im Fall von fb_exit verschiedene Aktionen ausgeführt werden. Durch die Zuweisung entstehen Probleme, weil fb_exit zweimal ausgeführt werden wird. Sie sollten dies verhindern, indem Sie das Attribut 'no_assign' in der Deklaraton des Funktionsbausteins TestFB hinzufügen: {attribute 'no_assign'}\nFUNCTION_BLOCK TestFB\nVAR_INPUT\n... Dann werden die folgenden Compilerfehler ausgegeben: C0328: Assignment not allowed for type TestFB\nC0328: Assignment not allowed for type LogRecord Wenn anstelle des Pragmas no_assign das Pragma no_assign_warning für den Funktionsbaustein TestFB verwendet wird, werden ebenfalls die Meldungen C0328 ausgegeben, jedoch nicht als Compilerfehler, sondern als Compilerwarnung. " }, 
{ "title" : "Attribut: no_check ", 
"url" : "_cds_pragma_attribute_no_check.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: no_check ", 
"snippet" : "no_check Das Pragma bewirkt, dass für die POU keine Check-Funktion ( POUs für implizite Prüfungen) aufgerufen wird. Da die Check-Funktionen die Abarbeitungsgeschwindigkeit des Programms beeinflussen können, kann es sinnvoll sein, das Attribut auf Bausteine anzuwenden, die schon geprüft sind oder oft...", 
"body" : "no_check Das Pragma bewirkt, dass für die POU keine Check-Funktion ( POUs für implizite Prüfungen) aufgerufen wird. Da die Check-Funktionen die Abarbeitungsgeschwindigkeit des Programms beeinflussen können, kann es sinnvoll sein, das Attribut auf Bausteine anzuwenden, die schon geprüft sind oder oft aufgerufen werden. Sie fügen das Pragma der Deklaration einer POU hinzu. Syntax : {attribute 'no_check'} Einfügeort: Erste Zeile im Deklarationsteil der POU Das Attribut wirkt automatisch auch auf die Kindobjekte einer POU! Beispiel: Wenn das Attribut in einem Programm eingetragen ist, werden auch für Aktionen, die diesem Programm zugewiesen sind, keine Check-Funktionen ausgeführt. " }, 
{ "title" : "Attribut: no_copy ", 
"url" : "_cds_pragma_attribute_no_copy.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: no_copy ", 
"snippet" : "no_copy Im Allgemeinen erfordert ein Online-Change eine Reallozierung von Instanzen eines Programmierbausteins. Dabei wird der Wert der in der Instanz enthaltenen Variablen kopiert. Das Pragma bewirkt, dass im Zuge eines Online-Changes keine Kopie des Variablenwerts der in der Instanz enthaltenen Va...", 
"body" : "no_copy Im Allgemeinen erfordert ein Online-Change eine Reallozierung von Instanzen eines Programmierbausteins. Dabei wird der Wert der in der Instanz enthaltenen Variablen kopiert. Das Pragma bewirkt, dass im Zuge eines Online-Changes keine Kopie des Variablenwerts der in der Instanz enthaltenen Variablen stattfindet; statt dessen wird die Variable im Zuge eines Online-Changes neu initialisiert. Das kann für eine lokale Pointervariable sinnvoll sein, die auf eine Variable zeigt, die gerade durch den Online-Change verschoben wurde und somit eine veränderte Adresse besitzt. Syntax : {attribute 'no_copy'} Sie fügen das Attribut im Deklarationsteil oberhalb der Zeile der Deklaration der betroffenen Variablen ein. " }, 
{ "title" : "Attribut: no-exit ", 
"url" : "_cds_pragma_attribute_no_exit.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: no-exit ", 
"snippet" : "no-exit Das Attribut unterdrückt den Aufruf der FB_Exit -Methode eines Funktionsbausteins für eine bestimmte seiner Instanzen. Dazu fügen Sie das Attribut in der Zeile vor der Deklaration der Funktionsbaustein-Instanz ein. Syntax : {attribute 'no-exit'} Dem Funktionsbaustein POU_ex ist die Methode F...", 
"body" : "no-exit searchresult_toplevel Das Attribut unterdrückt den Aufruf der FB_Exit -Methode eines Funktionsbausteins für eine bestimmte seiner Instanzen. Dazu fügen Sie das Attribut in der Zeile vor der Deklaration der Funktionsbaustein-Instanz ein. Syntax : {attribute 'no-exit'} Dem Funktionsbaustein POU_ex ist die Methode FB_exit hinzugefügt. Im Hauptprogramm PLC_PRG werden 2 Instanzen des Funktionsbausteins POU_ex angelegt. PROGRAM PLC_PRG\nVAR\n POU1 : POU_ex;\n {attribute 'no-exit'}\n POU2 : POU_ex;\nEND_VAR POU 1 wird aufgerufen, POU2 wird nicht aufgerufen. " }, 
{ "title" : "Attribut: noinit ", 
"url" : "_cds_pragma_attribute_noinit.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: noinit ", 
"snippet" : "noinit Das Pragma wird auf Variablen angewendet, die nicht implizit initialisiert werden sollen.. Syntax : {attribute 'no_init'} {attribute 'no-init'} {attribute 'noinit'} Einfügeort: Zeile oberhalb der Deklarationszeile der betroffenen Variablen im Deklarationsteil. Beispiel PROGRAM PLC_PRG VAR iA ...", 
"body" : "noinit Das Pragma wird auf Variablen angewendet, die nicht implizit initialisiert werden sollen.. Syntax : {attribute 'no_init'} {attribute 'no-init'} {attribute 'noinit'} Einfügeort: Zeile oberhalb der Deklarationszeile der betroffenen Variablen im Deklarationsteil. Beispiel PROGRAM PLC_PRG\nVAR\n iA : INT;\n {attribute 'no_init'}\n iB : INT;\nEND_VAR Bei einem Reset der zugehörigen Applikation wird die Integer-Variable iA erneut implizit mit 0 initialisiert, wohingegen die Variable iB ihren aktuellen Wert beibehält. " }, 
{ "title" : "Attribut: no_instance_in_retain ", 
"url" : "_cds_pragma_attribute_no_instance_in_retain.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: no_instance_in_retain ", 
"snippet" : "no_instance_in_retain Das Pragma bewirkt, dass damit ausgezeichnete Funktionsbausteine nicht als eine RETAIN -Variable instanziiert werden können. Das Pragma verhindert, dass die Instanz eines Funktionsbausteins im Retain-Speicherbereich abgelegt wird. Stattdessen wird eine Fehlermeldung ausgegeben....", 
"body" : "no_instance_in_retain Das Pragma bewirkt, dass damit ausgezeichnete Funktionsbausteine nicht als eine RETAIN -Variable instanziiert werden können. Das Pragma verhindert, dass die Instanz eines Funktionsbausteins im Retain-Speicherbereich abgelegt wird. Stattdessen wird eine Fehlermeldung ausgegeben. Syntax : {attribute 'no_instance_in_retain'} Einfügeort: Zeile oberhalb der FUNCTION_BLOCK -Deklaration im Deklarationsteil des Funktionsbausteins. " }, 
{ "title" : "Attribut: no_virtual_actions ", 
"url" : "_cds_pragma_attribute_no_virtual_actions.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: no_virtual_actions ", 
"snippet" : "no_virtual_actions Das Pragma wird für Funktionsbausteine angewendet, die von einem in AS implementierten Funktionsbaustein abgeleitet werden und den grundsätzlichen AS-Ablauf dieser Basisklasse nutzen. Die daraus aufgerufenen Aktionen zeigen dasselbe virtuelle Verhalten wie Methoden. Dies bedeutet,...", 
"body" : "no_virtual_actions Das Pragma wird für Funktionsbausteine angewendet, die von einem in AS implementierten Funktionsbaustein abgeleitet werden und den grundsätzlichen AS-Ablauf dieser Basisklasse nutzen. Die daraus aufgerufenen Aktionen zeigen dasselbe virtuelle Verhalten wie Methoden. Dies bedeutet, dass die Implementierungen der Aktionen in der Basisklasse von der abgeleiteten Klasse durch eigene, spezifische Implementierungen ersetzt werden können. Wenn Sie das Pragma auf die Basisklasse anwenden, dann sind ihre Aktionen vor einem Überladen geschützt. Syntax : {attribute 'no_virtual_actions'} Einfügeort: Oberste Zeile im Deklarationsteil des Funktionsbausteins Der Funktionsbaustein POU_SFC ist die Basisklasse für den abgeleiteten Funktionsbaustein POU_child . Mit der speziellen Variablen SUPER ruft die abgeleitete Klasse POU_child den in AS geschriebenen Ablauf der Basisklasse auf. Die beispielhafte Implementierung dieses Ablauf ist beschränkt auf den Initialschritt gefolgt von einem einzigen Schritt mit angebundener Schrittaktion ActiveAction . Dieser Schritt mit angebundener Schrittaktion übernimmt die Belegung der Ausgangsvariablen. an_int := an_int+1; \/\/ Counting the action calls\ntest_act := 'father_action';\nMETH(); \/\/ Call of the method METH in order to set the string variable test_meth Im Fall der abgeleiteten Klasse POU_child wird die Schrittaktion durch eine spezielle Implementierung von ActiveAction ersetzt. Active Action unterscheidet sich vom Original nur durch Zuweisung der Zeichenkette 'child_action' anstelle von 'father_action' an die Variable test_act . Ebenso wird die Methode METH , die in der Basisklasse der Variablen test_meth den String 'father_method' zuweist, dahingehend überschrieben, dass test_meth nun den Wert 'child_method' erhält.Das Hauptprogramm PLC_PRG ruft eine Instanz des Funktionsbausteins POU_child namens Child auf. Wie erwartet spiegelt der Wert der Strings den Aufruf von Aktion und Methode der abgeleiteten Klasse wieder: Nun stellen Sie der Basis jedoch das Pragma {attribute 'no_virtual_actions'} voran: {attribute 'no_virtual_actions'}\n\nFUNCTION_BLOCK POU_SFC... Dadurch ändert sich das Verhalten: Während für die Methode METH weiterhin die Implementierung der abgeleiteten Klasse herangezogen wird, resultiert der Aufruf der Schrittaktion nun in einem Aufruf der Aktion ActiveAction der Basisklasse. Daher erhält test_act nun den Wert 'father_action' : " }, 
{ "title" : "Attribut: obsolete ", 
"url" : "_cds_pragma_attribute_obsolete.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: obsolete ", 
"snippet" : "obsolete Das Pragma bewirkt, dass zu einer Datentyp-Definition beim Übersetzen eine definierte Warnung ausgegeben wird, wenn der Datentyp (Struktur, Funktionsbaustein etc.) im Projekt verwendet wird. Damit können Sie beispielsweise darauf hinweisen, dass ein Datentyp nicht mehr gültig ist, weil sich...", 
"body" : "obsolete searchresult_toplevel Das Pragma bewirkt, dass zu einer Datentyp-Definition beim Übersetzen eine definierte Warnung ausgegeben wird, wenn der Datentyp (Struktur, Funktionsbaustein etc.) im Projekt verwendet wird. Damit können Sie beispielsweise darauf hinweisen, dass ein Datentyp nicht mehr gültig ist, weil sich beispielsweise eine Schnittstelle geändert hat und dies im Projekt nachgezogen werden sollte. Im Unterschied zu einem Meldungspragma wird diese Warnung zentral für alle Instanzen eines Datentyps definiert. Syntax : {attribute 'obsolete' := 'user defined text'} Einfügeort: Zeile der Datentyp-Definition oder in einer Zeile darüber. Beispiel Das Pragma wird in der Deklaration des Funktionsbausteins FB_I1 eingefügt: {attribute 'obsolete' := 'Data type FB_I1 not valid'}\nFUNCTION_BLOCK FB_I1\nVAR_INPUT\n i:INT;\nEND_VAR\n; Wenn Sie FB_I1 als Datentyp verwenden, zum Beispiel in fbI1 : FB_I1; , dann wird beim Übersetzen des Projekts die folgende Warnung ausgegeben: Data type FB_I1 not valid " }, 
{ "title" : "Attribut: pingroup ", 
"url" : "_cds_pragma_attribute_pingroup.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: pingroup ", 
"snippet" : "pingroup Das Pragma bewirkt, dass in der Deklaration eines Funktionsbausteins die Eingangspins oder Ausgangspins (Parameter) gruppiert werden. Im FUP\/KOP-Editor kann dann eine so definierte Pingruppe am eingefügten Baustein als Einheit reduziert und erweitert angezeigt werden. Mehrere Gruppen sind m...", 
"body" : "pingroup Das Pragma bewirkt, dass in der Deklaration eines Funktionsbausteins die Eingangspins oder Ausgangspins (Parameter) gruppiert werden. Im FUP\/KOP-Editor kann dann eine so definierte Pingruppe am eingefügten Baustein als Einheit reduziert und erweitert angezeigt werden. Mehrere Gruppen sind möglich und werden durch ihre Namen unterschieden. CODESYS speichert den jeweiligen Zustand (reduziert) pro Bausteinbox mit den Projektoptionen. Syntax : {attribute 'pingroup' := '<group name>'} Einfügeort: Zeile oberhalb der Deklaration der betroffenen Eingangs- oder Ausgangsvariablen im Deklarationsteil eines Funktionsbausteins. Beispiel Zwei Gruppen werden definiert: general (i1, out1) und group1 (i2, g1) . r1 , r2 , outRes1 und g2 werden immer angezeigt. FUNCTION_BLOCK FB\nVAR_INPUT\n r1 : REAL;\n {attribute 'pingroup' := 'general'}\n i1 : INT;\n {attribute 'pingroup' := 'group1'}\n i2 : INT;\n r2 : REAL;\nEND_VAR\nVAR_OUTPUT\n outRes1 : REAL;\n {attribute 'pingroup' := 'general'}\n out1 : INT;\n {attribute 'pingroup' := 'group1'}\n g1 : INT;\n g2 : REAL;\nEND_VAR " }, 
{ "title" : "Attribut: pin_presentation_order_inputs, pin_presentation_order_outputs ", 
"url" : "_cds_pragma_attribute_pin_presentation_order.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: pin_presentation_order_inputs, pin_presentation_order_outputs ", 
"snippet" : "pin_presentation_order_inputs, pin_presentation_order_outputs Dieses Pragma wird nicht ausgewertet, wenn das Pragma {attribute 'pingroup' := '<Group_Name>'} verwendet wird. Die Pragmas werden in den grafischen Editoren CFC, FUP und KOP ausgewertet und bewirken, dass die Reihenfolge der Eingänge\/Ausg...", 
"body" : "pin_presentation_order_inputs, pin_presentation_order_outputs Dieses Pragma wird nicht ausgewertet, wenn das Pragma {attribute 'pingroup' := '<Group_Name>'} verwendet wird. Die Pragmas werden in den grafischen Editoren CFC, FUP und KOP ausgewertet und bewirken, dass die Reihenfolge der Eingänge\/Ausgänge des betroffenen Funktionsbausteins wie angegeben dargestellt wird. Sie programmieren die Reihenfolge, indem Sie die Namen der Eingänge\/Ausgänge dem Attribut in der gewünschten Reihenfolge zuweisen. Syntax: {attribute 'pin_presentation_order_inputs' := ' <first input name> ', ' <next input names> '}\n{attribute 'pin_presentation_order_outputs' := ' <first output name> ', ' <next output names> '} ' <first input name> ', ' <next input names> ' Mit Komma separierte Namen der Eingänge in der gewünschten Reihenfolge ' <first output name> ', ' <next output names> ' Mit Komma separierte Namen der Ausgänge in der gewünschten Reihenfolge * Platzhalter für alle nicht angegebenen Namen Wenn der Platzhalter fehlt, werden die fehlenden Eingänge\/Ausgänge an das Ende angehängt. Einfügeort Erste Zeile im Deklarationsteil eines Funktionsbausteins Beispiel {attribute 'pin_presentation_order_inputs' := 'input_2,*,input_1'}\n{attribute 'pin_presentation_order_outputs' := 'output_2, output_1'}\nFUNCTION_BLOCK POU_BASE\nVAR_INPUT\n input_1 : BOOL;\n input_2 : INT;\n input_3 : INT;\n input_4 : INT;\nEND_VAR\nVAR_OUTPUT\n output_1 : BOOL;\n output_2 : INT;\n output_3 : INT;\n output_4 : BOOL;\nEND_VAR\n\nFUNCTION_BLOCK PLC_PRG\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n pouBase_A: POU_BASE;\nEND_VAR Die Pragmas bewirken in der Darstellung der Funktionsbaustein-Instanz pouBase_A folgende Anordnung der Eingangs- und Ausgangspins: " }, 
{ "title" : "Attribut: pack_mode ", 
"url" : "_cds_pragma_attribute_pack_mode.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: pack_mode ", 
"snippet" : "pack_mode Das Pragma legt fest, wie eine Datenstruktur während der Allozierung gepackt wird. Das Attribut muss oberhalb der Datenstruktur eingefügt werden und wirkt sich auf das Packen der gesamten Struktur aus. Syntax : {attribute 'pack_mode' := ' <pack mode value> '} Einfügeort: Oberhalb der Dekla...", 
"body" : "pack_mode Das Pragma legt fest, wie eine Datenstruktur während der Allozierung gepackt wird. Das Attribut muss oberhalb der Datenstruktur eingefügt werden und wirkt sich auf das Packen der gesamten Struktur aus. Syntax : {attribute 'pack_mode' := ' <pack mode value> '} Einfügeort: Oberhalb der Deklaration der Datenstruktur Mögliche Werte für <pack mode value> <pack mode value> Assoziierte Packungsart Beschreibung 0 aligned Es liegen alle Variablen auf Byte-Adressen; es treten keine Speicherlücken auf. 1 1-byte-aligned 2 2-byte-aligned Es liegen 1 Byte-Variablen auf Byte-Adressen 2 Byte-Variablen auf durch 2-teilbare Adressen. Es entsteht maximal eine Lücke von 1 Byte 4 Byte-Variablen auf durch 2-teilbare Adressen. Es entsteht maximal eine Lücke von 1 Byte 8 Byte-Variablen auf durch 2-teilbare Adressen. Es entsteht maximal eine Lücke von 1 Byte Strings immer an Byte-Adressen. Es entsteht keine Lücke. 4 4-byte-aligned Es liegen 1 Byte-Variablen auf Byte-Adressen 2 Byte-Variablen auf durch 2-teilbare Adressen. Es entsteht maximal eine Lücke von 1 Byte 4 Byte-Variablen auf durch 4-teilbare Adressen. Es entsteht maximal eine Lücke von 3 Byte 8 Byte-Variablen auf durch 4-teilbare Adressen. Es entsteht maximal eine Lücke von 3 Byte Strings immer an Byte-Adressen. Es entsteht keine Lücke. 8 8-byte-aligned Es liegen 1 Byte-Variablen auf Byte-Adressen 2 Byte-Variablen auf durch 2-teilbare Adressen. Es entsteht maximal eine Lücke von 1 Byte 4 Byte-Variablen auf durch 4-teilbare Adressen. Es entsteht maximal eine Lücke von 3 Byte 8 Byte-Variablen auf durch 8-teilbare Adressen. Es entsteht maximal eine Lücke von 7 Byte Strings immer an Byte-Adressen. Es entsteht keine Lücke. Abhängig vom Aufbau der Struktur kann es vorkommen, dass es keinen Unterschied in der Speicheraufteilung zwischen den einzelnen Modi gibt. Beispielsweise kann die Speicherverteilung einer Struktur mit dem Pragma {attribute 'pack mode' := '4'} der von {attribute 'pack mode' := '8'} entsprechen. Arrays von Strukturen Werden die Strukturen in Arrays zusammengefasst, dann werden am Ende der Struktur Bytes eingefügt, damit die nächste Struktur wieder aligned ist. Wenn in der Symbolkonfiguration die Option Kompatibilitätslayout aktiviert wird und gleichzeitig das Attribut 'pack_mode' im Code verwendet wird, können Probleme wegen unabsichtlich falscher Speicherausrichtung auftreten. Negative Auswirkungen bei Anwendung von 'pack-mode' Durch die Verwendung des Attributs 'pack_mode' kann es zu nicht ausgerichteten Speicherzugriffen kommen. Das bedeutet beispielsweise, dass ein Datentyp der Größe 4 Byte dann auf einer Adresse liegt, die nicht durch 4 teilbar ist. Normalerweise kann auf einem 32-Bit-System ein 32 Bit großer Datentyp mit einem einzigen Speicherzugriff gelesen und geschrieben werden. Auf manchen Plattformen, wie beispielsweise auf ARM-Plattformen, ist das jedoch nur möglich, wenn dieser Wert im Speicher ausgerichtet ist. Auf anderen Plattformen kann es sein, dass der Zugriff zwar möglich ist, aber deutlich langsamer ausgeführt wird. {attribute 'pack_mode':=1}\n\nTYPE DUT\nSTRUCT\n by1 : BYTE;\n dw1 : DWORD;\nEND_STRUCT\nEND_TYPE Auf einer ARM-Plattform kann der Wert dw1 nicht mit einem einzigen Zugriff gelesen werden. Bei dem Versuch auf dieses Element direkt zuzugreifen, wird der ARM-Prozessor eine Exception auslösen. Annahme: Folgender lesender Zugriff wird durchgeführt: dwTest := dut1.dw1; Für diesen Zugriff auf das DWORD dw1 werden 4 Speicherzugriffe benötigt, da jedes Byte einzeln eingelesen, geshiftet und verodert wird. Der Ablauf ist in etwa der Gleiche, wie wenn in dem folgenden Beispiel aus einem Array von 4 Bytes ein DWORD generiert wird: dwHelp := bytes[0];\ndwResult := dwHelp;\ndwHelp := bytes[1];\ndwHelp := SHL(dwHelp, 8);\ndwResult := dwResult OR dwHelp;\ndwHelp := bytes[2];\ndwHelp := SHL(dwHelp, 16);\ndwResult := dwResult OR dwHelp;\ndwHelp := bytes[3];\ndwHelp := SHL(dwHelp, 24);\ndwResult := dwResult OR dwHelp; Es ist offensichtlich, dass ein solcher Zugriff deutlich langsamer ist als ein Zugriff auf ein DWORD , das passend im Speicher ausgerichtet ist. pdw := ADR(dut1.dw1);\ndwTest := pdw^; Den Zugriff des Beispiels wird der Compiler jedoch nicht generieren, wenn über einen Pointer auf eine solche Komponente zugegriffen wird. Das bedeutet, dass der folgende Code auf einer ARM-Plattform zu einer Exception führt. pdw := ADR(dut1.dw1);\ndwTest := pdw^; Aus Performance-Gründen sollte es daher vermieden werden, mit Strukturen zu arbeiten, die nicht natürlich ausgerichtet sind. Eine gepackte Struktur darf keine ungepackte Struktur enthalten. " }, 
{ "title" : "Beispiel 1 ", 
"url" : "_cds_pragma_attribute_pack_mode.html#UUID-c3d2a0b3-c4ff-c0ae-3564-f9f63f4a7e2b_id_a6bc74d60d70a21fc0a8640e001bdb68_id_6090971608ab9666c0a86463041fc5d3", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: pack_mode \/ Beispiel 1 ", 
"snippet" : "{attribute 'pack_mode' := '1'} TYPE myStruct: STRUCT Enable: BOOL; Counter: INT; MaxSize: BOOL; MaxSizeReached: BOOL; END_STRUCT END_TYPE Der Speicherbereich für eine Variable vom Datentyp myStruct wird „aligned“ alloziert: Ist die Speicheradresse ihrer Komponente Enable beispielsweise 0x0100 , dann...", 
"body" : "{attribute 'pack_mode' := '1'}\n\nTYPE myStruct:\nSTRUCT\n Enable: BOOL;\n Counter: INT;\n MaxSize: BOOL;\n MaxSizeReached: BOOL;\n END_STRUCT\nEND_TYPE Der Speicherbereich für eine Variable vom Datentyp myStruct wird „aligned“ alloziert: Ist die Speicheradresse ihrer Komponente Enable beispielsweise 0x0100 , dann folgt die Komponente Counter an der Adresse 0x0101 , MaxSize an Adresse 0x0103 und MaxSizeReached an Adresse 0x0104 . Mit 'pack_mode':=2 läge Counter bei 0x0102 , MaxSize bei 0x0104 und MaxSizeReached bei 0x0105 . " }, 
{ "title" : "Beispiel 2 ", 
"url" : "_cds_pragma_attribute_pack_mode.html#UUID-c3d2a0b3-c4ff-c0ae-3564-f9f63f4a7e2b_id_a6bc74d60d70a21fc0a8640e001bdb68_id_c397029808b522b2c0a86463026f3ca1", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: pack_mode \/ Beispiel 2 ", 
"snippet" : "STRUCT Var1 : BOOL := 16#01; Var2 : BYTE := 16#11; Var3 : WORD := 16#22; Var4 : BYTE := 16#44; Var5 : DWORD := 16#88776655; Var6 : BYTE := 16#99; Var7 : BYTE := 16#AA; Var8 : DWORD := 16#AA; END_TYPE pack_mode = 8 pack_mode = 0 pack_mode = 1 pack_mode = 2 pack_mode = 4 Variable Wert Variable Wert Va...", 
"body" : "STRUCT\n Var1 : BOOL := 16#01;\n Var2 : BYTE := 16#11;\n Var3 : WORD := 16#22;\n Var4 : BYTE := 16#44;\n Var5 : DWORD := 16#88776655;\n Var6 : BYTE := 16#99;\n Var7 : BYTE := 16#AA;\n Var8 : DWORD := 16#AA;\nEND_TYPE pack_mode = 8 pack_mode = 0 pack_mode = 1 pack_mode = 2 pack_mode = 4 Variable Wert Variable Wert Variable Wert Variable Wert Variable Wert 0 Var1 01 Var1 01 Var1 01 Var1 01 Var1 01 1 Var2 11 Var2 11 Var2 11 Var2 11 Var2 11 2 Var3 22 Var3 22 Var3 22 Var3 22 Var3 22 3 … 00 … 00 … 00 … 00 … 00 4 Var4 44 Var4 44 Var4 44 Var4 44 Var4 44 5 Var5 55 Var5 55 6 … 66 … 66 Var5 55 7 … 77 … 77 … 66 8 Var5 55 … 88 … 88 … 77 Var5 55 9 … 66 Var6 99 Var6 99 … 88 … 66 10 … 77 Var7 AA Var7 AA Var6 99 … 77 11 … 88 Var8 AA Var8 AA Var7 AA … 88 12 Var6 99 … 00 … 00 Var8 AA Var6 99 13 Var7 AA … 00 … 00 … 00 Var7 AA 14 … 00 … 00 … 00 15 … 00 16 Var8 AA Var8 AA 17 … 00 … 00 18 … 00 … 00 19 … 00 … 00 20 21 22 23 24 25 26 27 28 29 30 31 " }, 
{ "title" : "Beispiel 3 ", 
"url" : "_cds_pragma_attribute_pack_mode.html#UUID-c3d2a0b3-c4ff-c0ae-3564-f9f63f4a7e2b_id_a6bc74d60d70a21fc0a8640e001bdb68_id_7104e54be5bdcfb2c0a864634981a863", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: pack_mode \/ Beispiel 3 ", 
"snippet" : "STRUCT Var1 : BYTE := 16#01; Var2 : LWORD := 16#11; Var3 : BYTE := 16#22; Var4 : BYTE := 16#44; Var5 : DWORD := 16#88776655; Var6 : BYTE := 16#99; Var7 : BYTE := 16#AA; Var8 : WORD := 16#AA; END_TYPE pack_mode = 8 pack_mode = 0 pack_mode = 1 pack_mode = 2 pack_mode = 4 Variable Wert Variable Wert Va...", 
"body" : "STRUCT\n Var1 : BYTE := 16#01;\n Var2 : LWORD := 16#11;\n Var3 : BYTE := 16#22;\n Var4 : BYTE := 16#44;\n Var5 : DWORD := 16#88776655;\n Var6 : BYTE := 16#99;\n Var7 : BYTE := 16#AA;\n Var8 : WORD := 16#AA;\nEND_TYPE pack_mode = 8 pack_mode = 0 pack_mode = 1 pack_mode = 2 pack_mode = 4 Variable Wert Variable Wert Variable Wert Variable Wert Variable Wert 0 Var1 01 Var1 01 Var1 01 Var1 01 Var1 01 1 Var2 11 Var2 11 2 … 00 … 00 Var2 11 3 … 00 … 00 … 00 4 … 00 … 00 … 00 Var2 11 5 … 00 … 00 … 00 … 00 6 … 00 … 00 … 00 … 00 7 … 00 … 00 … 00 … 00 8 Var2 11 … 00 … 00 … 00 … 00 9 … 00 Var3 22 Var3 22 … 00 … 00 10 … 00 Var4 44 Var4 44 Var3 22 … 00 11 … 00 Var5 55 Var5 55 Var4 44 … 00 12 … 00 … 66 … 66 Var5 55 Var3 22 13 … 00 … 77 … 77 … 66 Var4 44 14 … 00 … 88 … 88 … 77 15 … 00 Var6 99 Var6 99 … 88 16 Var3 22 Var7 AA Var7 AA Var6 99 Var5 55 17 Var4 44 Var8 AA Var8 AA Var7 AA … 66 18 … 00 … 00 Var8 AA … 77 19 … 00 … 88 20 Var5 55 Var6 99 21 … 66 Var7 AA 22 … 77 Var8 AA 23 … 88 … 00 24 Var6 99 25 Var7 AA 26 Var8 AA 27 … 00 28 29 30 31 " }, 
{ "title" : "Verhalten ohne 'pack-mode' ", 
"url" : "_cds_pragma_attribute_pack_mode.html#UUID-c3d2a0b3-c4ff-c0ae-3564-f9f63f4a7e2b_id_a6bc74d60d70a21fc0a8640e001bdb68_id_4b241196e5bdcfb2c0a864631282e50a", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: pack_mode \/ Verhalten ohne 'pack-mode' ", 
"snippet" : "Wenn 'pack-mode' nicht verwendet wird, dann verwendet der Compiler typischerweise pack-mode 4 oder 8, abhängig von der Gerätebeschreibung. In jedem Fall wird ein für den Prozessor besonders vorteilhafter pack-mode verwendet, so dass Speicherzugriffe besonders effizient durchgeführt werden können. Di...", 
"body" : "Wenn 'pack-mode' nicht verwendet wird, dann verwendet der Compiler typischerweise pack-mode 4 oder 8, abhängig von der Gerätebeschreibung. In jedem Fall wird ein für den Prozessor besonders vorteilhafter pack-mode verwendet, so dass Speicherzugriffe besonders effizient durchgeführt werden können. Dies wird auch natürliches Alignment genannt, oder eine natürliche Ausrichtung der Daten. " }, 
{ "title" : "Attribut: ProcessValue ", 
"url" : "_cds_pragma_attribute_processvalue.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: ProcessValue ", 
"snippet" : "ProcessValue Mit dem Attribut 'ProcessValue' kennzeichnen Sie eine Komponente einer Struktur. Im CFC-Editor können Sie dann den Befehl Attributierte Komponente als Eingang verwenden anwenden, um diese Struktur mit einem Eingang skalaren Typs zu verbinden. Syntax : {attribute 'ProcessValue'} Einfügeo...", 
"body" : "ProcessValue Mit dem Attribut 'ProcessValue' kennzeichnen Sie eine Komponente einer Struktur. Im CFC-Editor können Sie dann den Befehl Attributierte Komponente als Eingang verwenden anwenden, um diese Struktur mit einem Eingang skalaren Typs zu verbinden. Syntax : {attribute 'ProcessValue'} Einfügeort: Zeile oberhalb der betroffenen Strukturkomponente Beispiel TYPE QINT :\nSTRUCT\n Status : STRING;\n {attribute 'ProcessValue'}\n Value1 : INT;\n Value2 : INT;\nEND_STRUCT\nEND_TYPE " }, 
{ "title" : "Attribut: qualified_only ", 
"url" : "_cds_pragma_attribute_qualified_only.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: qualified_only ", 
"snippet" : "qualified_only Das Pragma bewirkt, dass Variablen einer globalen Variablenliste nur durch Angabe des globalen Variablennamens angesprochen werden, zum Beispiel gvl.g_var . Das trifft auch auf Variablen vom Typ Enumeration zu und kann hilfreich sein um eine Verwechslung mit lokalen Variablen zu verme...", 
"body" : "qualified_only Das Pragma bewirkt, dass Variablen einer globalen Variablenliste nur durch Angabe des globalen Variablennamens angesprochen werden, zum Beispiel gvl.g_var . Das trifft auch auf Variablen vom Typ Enumeration zu und kann hilfreich sein um eine Verwechslung mit lokalen Variablen zu vermeiden. Syntax : {attribute 'qualified_only'} Einfügeort: Zeile oberhalb von VAR_GLOBAL in einer GVL Beispiel Globale Variablenliste GVL : {attribute 'qualified_only'}\nVAR_GLOBAL\n iVar:INT;\nEND_VAR Innerhalb eines Programmierbausteins, zum Beispiel PLC_PRG , kann die globale Variable iVar nur unter Verwendung des Präfix GVL angesprochen werden: GVL.iVar:=5; Der folgende unvollständige Aufruf der Variablen wird hingegen einen Fehler erzeugen: iVar:=5; " }, 
{ "title" : "Attribut: reflection ", 
"url" : "_cds_pragma_attribute_reflection.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: reflection ", 
"snippet" : "reflection Das Pragma kennzeichnet einen Programmierbaustein für eine Compilersuche nach Funktionsbausteinvariablen, die mit den Attribut 'instance-path' oder dem Attribut 'is_connected' gekennzeichnet sind. Bausteine mit solchen Variablen verlangen eine Sonderbehandlung. Der Compiler durchsucht nur...", 
"body" : "reflection Das Pragma kennzeichnet einen Programmierbaustein für eine Compilersuche nach Funktionsbausteinvariablen, die mit den Attribut 'instance-path' oder dem Attribut 'is_connected' gekennzeichnet sind. Bausteine mit solchen Variablen verlangen eine Sonderbehandlung. Der Compiler durchsucht nur mit 'reflection' gekennzeichnete Bausteine nach Variablen mit diesen Attributen und benötigt somit weniger Zeit. Syntax : {attribute 'reflection'} Für weitere Informationen siehe: instance-path und is_connected" }, 
{ "title" : "Attribut: subsequent ", 
"url" : "_cds_pragma_attribute_subsequent.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: subsequent ", 
"snippet" : "subsequent VAR_TEMP in einem Programm mit Attribut 'subsequent' führt zu einem Compiler-Fehler. Das Pragma wird verwendet, um Variablen direkt hintereinander im Speicher zu allozieren. Wenn sich die Liste ändert, wird die gesamte Variablenliste an einen neuen Speicherplatz alloziiert. Dieses Pragma ...", 
"body" : "subsequent VAR_TEMP in einem Programm mit Attribut 'subsequent' führt zu einem Compiler-Fehler. Das Pragma wird verwendet, um Variablen direkt hintereinander im Speicher zu allozieren. Wenn sich die Liste ändert, wird die gesamte Variablenliste an einen neuen Speicherplatz alloziiert. Dieses Pragma wird in Programmen und globalen Variablenlisten verwendet. Syntax : {attribute 'subsequent'} Wenn eine Variable in der Liste mit RETAIN qualifiziert ist, werden alle Variablen des Deklarationsabschnitts im Speicherbereich für RETAIN abgelegt. " }, 
{ "title" : "Attribut: to_string ", 
"url" : "_cds_pragma_attribute_to_string.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: to_string ", 
"snippet" : "to_string Das Pragma wirkt sich darauf aus, wie das Ergebnis der Konvertierung einer Enumerationskomponente mit dem Operator TO_STRING ausgegeben wird: Wenn die Enumerationsdeklaration mit dem Pragma versehen ist, erscheint anstelle des numerischen Werts der Name der Enumerationskomponente als Zeich...", 
"body" : "to_string Das Pragma wirkt sich darauf aus, wie das Ergebnis der Konvertierung einer Enumerationskomponente mit dem Operator TO_STRING ausgegeben wird: Wenn die Enumerationsdeklaration mit dem Pragma versehen ist, erscheint anstelle des numerischen Werts der Name der Enumerationskomponente als Zeichenfolge. Syntax: {attribute 'to_string'} Einfügeort: Erste Zeile über dem Deklarationsteil der Enumeration. Beispiel Deklaration der Enumeration color : {attribute 'to_string'}\nTYPE COLOR:\n(\n red := 0,\n blue := 1,\n green := 2\n);\nEND_TYPE Konvertierung mit TO_STRING : PROGRAM PLC_PRG\nVAR\n i_color: COLOR;\n s_show_color: STRING;\nEND_VAR\ni_color := 1;\ns_show_color := TO_STRING(i_color); In diesem Fall erhält s_show_color als Konvertierungsergebnis den Wert 'blue' anstelle von 1 . " }, 
{ "title" : "Attribut: suppress_warning ", 
"url" : "_cds_pragma_attribute_suppress_warning.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: suppress_warning ", 
"snippet" : "suppress_warning Das Pragma bewirkt, dass die in der Definition dieses Pragmas angegebenen Compilerwarnungen unterdrückt werden. Syntax: {attribute 'suppress_warning' := '<warning id1>','<warning id2>',...} Einfügeort: Zeile oberhalb des Deklarationsteils einer POU oder DUT Beispiel {attribute 'supp...", 
"body" : "suppress_warning Das Pragma bewirkt, dass die in der Definition dieses Pragmas angegebenen Compilerwarnungen unterdrückt werden. Syntax: {attribute 'suppress_warning' := '<warning id1>','<warning id2>',...} Einfügeort: Zeile oberhalb des Deklarationsteils einer POU oder DUT Beispiel {attribute 'suppress_warning' := '0125'}\nTYPE DUT_1 :\n(\n enum_member1 := 0,\n enum_member2 := 0\n);\nEND_TYPE\n Die Warnung C0125 wird unterdrückt. " }, 
{ "title" : "Attribut: warning disable, warning restore ", 
"url" : "_cds_pragma_attribute_warning_disable.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Attributpragmas \/ Attribut: warning disable, warning restore ", 
"snippet" : "warning disable , warning restore Das Attribut warning disable bewirkt, dass bestimmte Warnungen unterdrückt werden. Das Pragma warning restore bewirkt, dass eine unterdrückte Meldung wieder aktiviert wird. Dieses Attribut kann für jede Compilerwarnung verwendet werden. Eine Auflistung aller möglich...", 
"body" : "warning disable , warning restore Das Attribut warning disable bewirkt, dass bestimmte Warnungen unterdrückt werden. Das Pragma warning restore bewirkt, dass eine unterdrückte Meldung wieder aktiviert wird. Dieses Attribut kann für jede Compilerwarnung verwendet werden. Eine Auflistung aller möglichen Compilerwarnungen finden Sie im CODESYS Development System in den Projekteinstellungen eines Projekts ( Projekt → Projekteinstellungen , Kategorie Compilerwarnungen ). Syntax : {warning disable <compiler ID>} {warning restore <compiler ID>} <compiler ID> : ID, die am Anfang einer Fehler- oder Warnungsmeldung steht. Beispiel Compilermeldung: typify code ...\nC0195: Implicit conversion from unsigned Type 'UINT' to signed Type 'INT' : possible change of sign\nCompile complete -- 0 errors Das Pragma auf einer Variablendeklaration anwenden: VAR\n {warning disable C0195}\n test1 : UINT := -1;\n {warning restore C0195}\n test2 : UINT := -1;\nEND_VAR test1 erzeugt keine Warnung, test2 erzeugt eine Warnung. " }, 
{ "title" : "Bedingte Pragmas ", 
"url" : "_cds_pragma_conditional.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas ", 
"snippet" : "Einschränkung bei bedingten Pragmas Verwenden Sie Pragmas für bedingte Kompilierung nur in Implementierungen von Programmierbausteinen. In Deklarationen werden diese Pragmas nicht ausgewertet sondern ignoriert. Beachten Sie bitte die folgende Ausnahme: Das IF-Pragma mit dem Operator project_defined ...", 
"body" : "Einschränkung bei bedingten Pragmas Verwenden Sie Pragmas für bedingte Kompilierung nur in Implementierungen von Programmierbausteinen. In Deklarationen werden diese Pragmas nicht ausgewertet sondern ignoriert. Beachten Sie bitte die folgende Ausnahme: Das IF-Pragma mit dem Operator project_defined kann in Deklarationen eingefügt werden. Für weitere Informationen siehe: IF-Pragma mit project_defined (<global define>)Die Pragmas werden vom Compiler beim Vorübersetzungsprozess und beim Übersetzungsprozess ausgewertet. Dieser Vorgang nennt sich bedingte Kompilierung. Die Implementierungssprache ST unterstützt diese Pragmas. Die Pragmas {IF <expression> } zusammen mit {ELSIF <expression> } , {ELSE} und dem abschließenden {END_IF} kennzeichnen in Implementierungen Code, der abhängig von den angegebenen Bedingungen beibehalten oder ignoriert wird. Die angegebenen Bedingungen in <expression> sind ganzzahlige konstante Ausdrücke, die aus verschiedenen Operanden und Operatoren zusammengesetzt sein können. Beim Kompilieren wird als erstes der Ausdruck in <{IF <expression>} ausgewertet. Wenn dessen Rückgabewert FALSE ist, wird in den nächsten {ELSIF <expression>} -Abschnitt verzweigt und der dortige Ausdruck ausgewertet, solange bis ein Abschnitt einen Ausdruck mit TRUE liefert. Die Ausdrücke werden somit sukzessive ausgewertet, bis einer einen Wert ungleich 0 liefert. Nur dieser eine mit einem positiven Ausdruck verknüpfte Codeabschnitt wird kompiliert. Die anderen werden ignoriert. Wenn alle Ausdrücke 0 liefern, wird nach {ELSE} verzweigt. Wenn das {ELSE} -Pragma fehlt, kann der Fall eintreten, dass kein Codeabschnitt kompiliert wird. Syntax Beispiel Codefragment Beschreibung {IF <expression> } {IF defined (DEF0815)}\n{info 'DEF0815 has been defined'}\nCnt0815 := iCnt0815 + 1; Kennzeichnet den Anfang des Codeabschnitts, der bei einer gültiger Bedingung <expression> kompiliert wird {ELSIF <expression> } {ELSIF defined (DEF0816)}\n{info 'DEF0815 has been defined'}\niCnt0816 := iCnt0816 + 1; Keinmal, einmal oder mehrmals Abzweig, der den alternativen Codeabschnitt bei einer gültiger Bedingung <expression> kennzeichnet {ELSE} {ELSE}\n{info 'DEF0815 not defined'}\niCnt0 := iCnt0 - 1; Optional Abzweig, der den Codeabschnitt kennzeichnet, der kompiliert wird, wenn die vorherigen Bedingungen nicht eintreten {END_IF} {END_IF} Kennzeichnet das Ende des bedingten Codeabschnitts <expression> defined (DEF0815) Bedingung Ganzzahliger, zur Kompilierungszeit konstanter Ausdruck, der aus Operatoren und Operanden, wie beispielsweise Compiler-Defines, Variablen oder Literale, zusammengesetzt sein kann " }, 
{ "title" : "Compiler-Define ", 
"url" : "_cds_pragma_conditional.html#UUID-9d13f749-64d4-ea6e-d526-1046cb95981c_section-idm13512919386826", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Compiler-Define ", 
"snippet" : "Compiler-Defines werden als Kennzeichen für bestimmte Zustände im Code verwendet. Ein Compiler-Define kann gesetzt, gelöscht oder mit Hilfe der defined-Operatoren geprüft werden. Syntax Beispiel Beschreibung {define <name> } {define DEF0815} Definiert das Compiler-Define <name> mit Typ BOOL Das Comp...", 
"body" : "Compiler-Defines werden als Kennzeichen für bestimmte Zustände im Code verwendet. Ein Compiler-Define kann gesetzt, gelöscht oder mit Hilfe der defined-Operatoren geprüft werden. Syntax Beispiel Beschreibung {define <name> } {define DEF0815} Definiert das Compiler-Define <name> mit Typ BOOL Das Compiler-Define <name> unterliegt den Regeln für gültige Bezeichner. {define <name> <string> } {define DEF0123 '123'} Definiert das Compiler-Define <name> und weist als Wert das Stringliteral <string> zu {undefine <name>} {undefine DEF0815} Hebt das Compiler-Define <name> auf Der Bezeichner ist danach undefiniert. Ein Pragma mit einem undefinierten Compiler-Define wird ignoriert. Alternativ können Sie Ausdrücke und Compiler-Defines lokal in den Eigenschaften einer POU oder applikationsweit in den Eigenschaften der übergeordneten Applikation definieren. Selektieren Sie dafür die POU oder die übergeordnete Applikation im Gerätebaum. Wählen Sie in deren Kontextmenü Eigenschaften und dann die Registerkarte Build . Dort im Eingabefeld Compiler-Defines können Sie ein Literal oder einen Ausdruck definieren, beispielsweise DEF0815. Das Eingabefeld erwartet keine Pragmaanweisung wie {define } , sondern lediglich einen Namen. Sie können mehrere Compiler-Defines durch Komma getrennt angeben. " }, 
{ "title" : "Operatoren ", 
"url" : "_cds_pragma_conditional.html#UUID-7d0f412c-5a63-338b-4d5a-f9f63d4bbeb3", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "defined (variable: <variable name> ) ", 
"url" : "_cds_pragma_conditional.html#UUID-56a3dfa0-d8ff-39b2-d406-47873393107c", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ defined (variable: <variable name> ) ", 
"snippet" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn die Variable <variable name> innerhalb des aktuellen Gültigkeitsbereichs deklariert ist; ansonsten wird FALSE geliefert. Beispiel Voraussetzung: Es gibt zwei Applikationen App1 und App2 . Die Variable g_bTest ist in App1 deklariert, ...", 
"body" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn die Variable <variable name> innerhalb des aktuellen Gültigkeitsbereichs deklariert ist; ansonsten wird FALSE geliefert. Beispiel Voraussetzung: Es gibt zwei Applikationen App1 und App2 . Die Variable g_bTest ist in App1 deklariert, nicht aber in App2 . {IF defined (variable: g_bTest)}\n (* the following code is only processed in App2*)\n g_bTest := x > 300;\n{END_IF} " }, 
{ "title" : "defined (<identifier>) ", 
"url" : "_cds_pragma_conditional.html#UUID-e54af038-800e-5327-8957-cece6e7ac986", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ defined (<identifier>) ", 
"snippet" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält. Voraussetzung ist, dass der Bezeichner <identifier> mit Hilfe einer {define} -Anweisung definiert wurde und danach nicht mit einer {undefine} -Anweisung wieder undefiniert wurde; ansonsten wird FALSE geliefert. Voraussetzung: Es gibt die ...", 
"body" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält. Voraussetzung ist, dass der Bezeichner <identifier> mit Hilfe einer {define} -Anweisung definiert wurde und danach nicht mit einer {undefine} -Anweisung wieder undefiniert wurde; ansonsten wird FALSE geliefert. Voraussetzung: Es gibt die Applikationen App1 und App2 . Die Variable pdef1 ist durch eine {define} -Anweisung in App1 definiert, nicht aber in App2 . {IF defined (pdef1)}\n(* This code is processed in App1 *)\n{info 'pdef1 defined'}\n hugo := hugo + SINT#1;\n{ELSE}\n(* the following code is only processed in App2 *)\n{info 'pdef1 not defined'}\n hugo := hugo - SINT#1;\n{END_IF} Hier ist zusätzlich ein Beispiel eines Meldungspragmas enthalten: Nur die Meldung pdef1 defined wird im Meldungsfenster angezeigt, wenn die Applikation kompiliert wird, weil pdef1 tatsächlich definiert ist. Die Meldung pdef1 not defined wird ausgegeben, wenn pdef1 nicht definiert ist " }, 
{ "title" : "defined (type: <identifier> ) ", 
"url" : "_cds_pragma_conditional.html#UUID-c146e29c-1435-150f-39b5-3565709c5179", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ defined (type: <identifier> ) ", 
"snippet" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn ein Datentyp mit dem Bezeichner <identifier> deklariert ist; ansonsten wird FALSE geliefert. Beispiel Voraussetzung: Es gibt zwei Applikationen App1 und App2 . Datentyp DUT ist in App1 deklariert, nicht aber in App2 . {IF defined (ty...", 
"body" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn ein Datentyp mit dem Bezeichner <identifier> deklariert ist; ansonsten wird FALSE geliefert. Beispiel Voraussetzung: Es gibt zwei Applikationen App1 und App2 . Datentyp DUT ist in App1 deklariert, nicht aber in App2 . {IF defined (type: DUT)}\n (* the following code is only processed in App1*)\n bDutDefined := TRUE;\n{END_IF} " }, 
{ "title" : "defined (pou: <pou name>) ", 
"url" : "_cds_pragma_conditional.html#UUID-17139d7e-07b4-d059-ab0e-e4045ec20bd0", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ defined (pou: <pou name>) ", 
"snippet" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn eines der folgenden Objekte mit dem Namen <pou-name> vorhanden ist: Funktionsbaustein Funktion Programm Aktion Methode Schnittstelle Ansonsten wird FALSE geliefert. Beispiel Voraussetzung: Es gibt zwei Applikationen App1 und App2 . D...", 
"body" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn eines der folgenden Objekte mit dem Namen <pou-name> vorhanden ist: Funktionsbaustein Funktion Programm Aktion Methode Schnittstelle Ansonsten wird FALSE geliefert. Beispiel Voraussetzung: Es gibt zwei Applikationen App1 und App2 . Der Baustein CheckBounds ist in App1 vorhanden, nicht aber in App2 . {IF defined (pou: CheckBounds)}\n (* the following code is only processed in App1 *)\n arrTest[CheckBounds(0,i,10)] := arrTest[CheckBounds(0,i,10)] + 1;\n{ELSE}\n (* the following code is only processed in App2 *)\n arrTest[i] := arrTest[i]+1;\n{END_IF} " }, 
{ "title" : "defined (resource: <identifier>) ", 
"url" : "_cds_pragma_conditional.html#UUID-0a21b728-bc6a-38b2-4fa2-d84b00fc80ee", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ defined (resource: <identifier>) ", 
"snippet" : "Noch nicht implementiert Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn ein Ressourcen-Objekt mit dem Namen <identifier> für die Applikation vorhanden ist; ansonsten wird FALSE geliefert. Voraussetzung: Es gibt zwei Applikationen App1 und App2 . Ein Ressourcen-Objekt glob_var1 de...", 
"body" : "Noch nicht implementiert Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn ein Ressourcen-Objekt mit dem Namen <identifier> für die Applikation vorhanden ist; ansonsten wird FALSE geliefert. Voraussetzung: Es gibt zwei Applikationen App1 und App2 . Ein Ressourcen-Objekt glob_var1 der Globalen Variablenliste ist für App1 vorhanden, nicht aber für App2 . {IF defined (resource:glob_var1)}\n (* the following code is only processed in App1 *)\n gvar_x := gvar_x + ivar;\n{ELSE}\n (* the following code is only processed in App2 *)\n x := x + ivar;\n{END_IF} " }, 
{ "title" : "defined (task: <task name> ) ", 
"url" : "_cds_pragma_conditional.html#UUID-ccc52caa-f156-4e60-c0cd-17886ea9795b", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ defined (task: <task name> ) ", 
"snippet" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn eine Task mit dem Namen <task name> definiert ist; ansonsten wird FALSE geliefert. Syntax { IF defined (task: <task name> } { ELSIF defined (task: <task name> } Beispiel {IF defined (task: Task_D)} Beispiel Voraussetzung: Es gibt zwe...", 
"body" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn eine Task mit dem Namen <task name> definiert ist; ansonsten wird FALSE geliefert. Syntax { IF defined (task: <task name> }\n{ ELSIF defined (task: <task name> } Beispiel {IF defined (task: Task_D)} Beispiel Voraussetzung: Es gibt zwei Applikationen App1 und App2 . Task PLC_PRG_Task ist in App1 definiert, nicht aber in App2 . {IF defined (task: PLC_PRG_Task)}\n (* the following code is only processed in App1 *)\n erg := plc_prg.x;\n{ELSE}\n (* the following code is only processed in App2 *)\n erg := prog.x;\n{END_IF} " }, 
{ "title" : "defined (IsLittleEndian) ", 
"url" : "_cds_pragma_conditional.html#UUID-516da2c9-04fd-3845-f55a-087fc2d2aeab", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ defined (IsLittleEndian) ", 
"snippet" : "Der Operator bewirkt, dass der Ausdruck den Wert FALSE erhält, wenn der Speicher der CPU in Big-Endian (Motorola Byte Order) organisiert ist....", 
"body" : "Der Operator bewirkt, dass der Ausdruck den Wert FALSE erhält, wenn der Speicher der CPU in Big-Endian (Motorola Byte Order) organisiert ist. " }, 
{ "title" : "defined (IsSimulationMode) ", 
"url" : "_cds_pragma_conditional.html#UUID-3ab4b0b9-4bdc-b8a9-4b97-18745c21d26d", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ defined (IsSimulationMode) ", 
"snippet" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn die Applikation auf einem simulierten Gerät läuft, also im Simulationsbetrieb ist.ei Weitere Informationen finden Sie unter Testen im Simulationsbetrieb....", 
"body" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn die Applikation auf einem simulierten Gerät läuft, also im Simulationsbetrieb ist.ei Weitere Informationen finden Sie unter Testen im Simulationsbetrieb. " }, 
{ "title" : "defined (IsFPUSupported) ", 
"url" : "_cds_pragma_conditional.html#UUID-77021421-79d5-0d58-faff-96b1b4636fcc", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ defined (IsFPUSupported) ", 
"snippet" : "Wenn der Ausdruck den Wert TRUE liefert, erzeugt der Codegenerator bei der Berechnungen mit REAL -Werten einen FPU-Code (für den Floating Point Unit-Porzessor). Ansonsten werden die FPU-Operationen emuliert, was jedoch bedeutend langsamer ist....", 
"body" : "Wenn der Ausdruck den Wert TRUE liefert, erzeugt der Codegenerator bei der Berechnungen mit REAL -Werten einen FPU-Code (für den Floating Point Unit-Porzessor). Ansonsten werden die FPU-Operationen emuliert, was jedoch bedeutend langsamer ist. " }, 
{ "title" : "hasattribute (pou: <pou name>, ' <attribute name> ') ", 
"url" : "_cds_pragma_conditional.html#UUID-5ca43390-2187-c6be-b000-d6a460e76960", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ hasattribute (pou: <pou name>, ' <attribute name> ') ", 
"snippet" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn das Attribut <attribute name> in der ersten Zeile des Deklarationsteils des Bausteins <pou name> angegeben ist; ansonsten wird FALSE zurückgeliefert. Beispiel Voraussetzung: Es gibt zwei Applikationen App1 und App2 . Die Funktion fun...", 
"body" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn das Attribut <attribute name> in der ersten Zeile des Deklarationsteils des Bausteins <pou name> angegeben ist; ansonsten wird FALSE zurückgeliefert. Beispiel Voraussetzung: Es gibt zwei Applikationen App1 und App2 . Die Funktion fun1 ist in App1 und App2 deklariert, aber in App1 ist sie zusätzlich mit dem Pragma {attribute 'vision'} versehen. In App1 : {attribute 'vision'}\nFUNCTION fun1 : INT\nVAR_INPUT\n i : INT;\nEND_VAR\nVAR\nEND_VAR In App2 : FUNCTION fun1 : INT\nVAR_INPUT\n i : INT;\nEND_VAR\nVAR\nEND_VAR Pragmaanweisung: {IF hasattribute (pou: fun1, 'vision')}\n (* the following code is only processed in App1 *)\n ergvar := fun1(ivar);\n{END_IF} " }, 
{ "title" : "hasattribute (variable: <variable name> , ' <attribute name> ') ", 
"url" : "_cds_pragma_conditional.html#UUID-acc24196-3e5c-73ec-b19f-e7572000a697", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ hasattribute (variable: <variable name> , ' <attribute name> ') ", 
"snippet" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn der Variablen das Pragma {attribute '<attribute name>'} in der Zeile vor der Variablendeklaration zugewiesen ist; ansonsten wird FALSE zurückgeliefert. Beispiel Voraussetzung: Es gibt zwei Applikationen App1 und App2 . Die Variable g...", 
"body" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn der Variablen das Pragma {attribute '<attribute name>'} in der Zeile vor der Variablendeklaration zugewiesen ist; ansonsten wird FALSE zurückgeliefert. Beispiel Voraussetzung: Es gibt zwei Applikationen App1 und App2 . Die Variable g_globalInt wird in App1 und App2 verwendet, aber in App1 ist ihr zusätzlich das Attribut 'DoCount' zugewiesen. Deklaration g_GlobalInt in App1 VAR_GLOBAL\n {attribute 'DoCount'}\n g_globalInt : INT;\n g_multiType : STRING;\nEND_VAR Deklaration g_GlobalInt in App2 : VAR_GLOBAL\n g_globalInt : INT;\n g_multiType : STRING;\nEND_VAR Pragmaanweisung: {IF hasattribute (variable: g_globalInt, 'DoCount')}\n (* the following code is only processed in App1 *)\n g_globalInt := g_globalInt + 1;\n{END_IF} " }, 
{ "title" : "hasconstanttype( <constant name> , <boolean literal> ) ", 
"url" : "_cds_pragma_conditional.html#UUID-30672799-4e6a-2fbc-3929-5daa20235b68", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ hasconstanttype( <constant name> , <boolean literal> ) ", 
"snippet" : "Der Operator prüft, ob die mit <constant name> bezeichnete Konstante ersetzt oder nicht ersetzt wurde. Auf was geprüft wird, wird mit dem zweiten Parameter (Boolescher Wert) gesteuert: TRUE : Prüft, ob Konstante ersetzt wurde FALSE : Prüft, ob Konstante nicht ersetzt wurde Wenn der jeweilige Fall ei...", 
"body" : "Der Operator prüft, ob die mit <constant name> bezeichnete Konstante ersetzt oder nicht ersetzt wurde. Auf was geprüft wird, wird mit dem zweiten Parameter (Boolescher Wert) gesteuert: TRUE : Prüft, ob Konstante ersetzt wurde FALSE : Prüft, ob Konstante nicht ersetzt wurde Wenn der jeweilige Fall eintritt, liefert der Operator TRUE zurück. Syntax { IF hasconstanttype( <constant namne> , <boolean literal> ) } { ELSIF hasconstanttype( <constant namne> , <boolean literal> ) } Beispiel {IF hasconstanttype(PLC_PRG.aConst, TRUE)} Das automatische Ersetzen von Konstanten hängt prinzipiell von Folgendem ab: Compile-Option Konstanten ersetzen Konstantentyp (beispielsweise werden STRING -Typen nie ersetzt) Verwendung des Attributs {attribute 'const_non_replaced'} Verwendung des Attributs {attribute 'const_replaced'} Beispiel VAR\n iCntMAXIsReplaced: INT;\n xErrorOccured : BOOL;\nEND_VAR\nVAR CONSTANT\n c_iMAX: INT := 99;\nEND_VAR\n\n{IF hasconstanttype(c_iMAX, TRUE)}\n iCntMAXIsReplaced := iCntMAXIsReplaced + 1;\n{ELSE}\n xErrorOccured := FALSE;\n{END_IF} " }, 
{ "title" : "hasconstantvalue( <constant name> , <variable name> , <comparison operator> ) ", 
"url" : "_cds_pragma_conditional.html#UUID-f4c0c696-3507-eafb-ef9c-09e853c3e51a", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ hasconstantvalue( <constant name> , <variable name> , <comparison operator> ) ", 
"snippet" : "Der Operator vergleicht den Wert der mit <constant name> bezeichneten Konstante mit dem Wert des zweiten Parameters. Der zweite Parameter kann entweder als Literal <literal> oder als Variable <variable name> angegeben werden. Vergleichsoperatoren <comparison operator> : größer ( > ) größer oder glei...", 
"body" : "Der Operator vergleicht den Wert der mit <constant name> bezeichneten Konstante mit dem Wert des zweiten Parameters. Der zweite Parameter kann entweder als Literal <literal> oder als Variable <variable name> angegeben werden. Vergleichsoperatoren <comparison operator> : größer ( > ) größer oder gleich ( >= ) gleich ( = ) ungleich ( <> ) kleiner oder gleich ( <= ) kleiner ( < ) Syntax { IF hasconstantvalue( <constant name> , <variable name> , <comparison operator> ) { IF hasconstantvalue( <constant name> , <literal> , <comparison operator> ) { ELSIF hasconstantvalue( <constant name> , <variable name> , <comparison operator> ) { ELSIF hasconstantvalue( <constant name> , <literal> , <comparison operator> ) Beispiel {IF hasconstantvalue(PLC_PRG.aConst, 99, >)} {ELSIF hasconstantvalue(PLC_PRG.aConst, GVL.intconst99, =)} Beispiel PROGRAM PRG_ConditionConstantValue\nVAR\n iCntMAX: INT;\n iCntGlobalMAX : INT;\n iCntABC: INT;\n iCntGlobalABC : INT;\n xErrorOccured : BOOL;\nEND_VAR\nVAR CONSTANT\n c_iMAX: INT := 999;\n c_sABC: STRING := 'ABC';\n {attribute 'const_non_replaced'}\n c_iNonReplaceable: INT := 888;\nEND_VAR\n\n{IF hasconstantvalue(c_iMAX, 999, =)}\n iCntMAX := iCntMAX + 1;\n{ELSE}\n xErrorOccured := FALSE;\n{END_IF}\n\n{IF hasconstantvalue(c_iMAX, GVL.gc_iMAX, =)}\n iCntGlobalMAX := iCntGlobalMAX + 1;\n{ELSE}\n xErrorOccured := FALSE;\n{END_IF}\n\n{IF hasconstantvalue(c_sABC, 'ABC', =)}\n iCntABC := iCntMAX + 1;\n{ELSE}\n xErrorOccured := FALSE;\n{END_IF}\n{IF hasconstantvalue(c_sABC, GVL.gc_sABC, =)}\n iCntGlobalABC := iCntMAX + 1;\n{ELSE}\n xErrorOccured := FALSE;\n{END_IF} " }, 
{ "title" : "hastype (variable: <variable name>, <data type> ) ", 
"url" : "_cds_pragma_conditional.html#UUID-92747db0-9849-d5df-f302-8252875bbffa", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ hastype (variable: <variable name>, <data type> ) ", 
"snippet" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn die Variable <variable> vom Datentyp <type-spec> ist; ansonsten wird FALSE zurückgeliefert. Mögliche Datentypen <data type> : BOOL | BYTE | DATE | DATE_AND_TIME | DT | DINT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL ...", 
"body" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn die Variable <variable> vom Datentyp <type-spec> ist; ansonsten wird FALSE zurückgeliefert. Mögliche Datentypen <data type> : BOOL | BYTE | DATE | DATE_AND_TIME | DT | DINT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTIME_OF_DAY | LTOD | LWORD | REAL | SINT | STRING | TIME | TIME_OF_DAY | TOD | ULINT | UDINT | UINT | USINT | WORD | WSTRING Beispiel Voraussetzung: Es gibt zwei Applikationen App1 und App2 . Die Variable g_multitype ist in App1 mit Datentyp LREAL deklariert, in App2 mit Datentyp STRING . {IF (hastype (variable: g_multitype, LREAL))}\n (* the following code is only processed in App1 *)\n g_multitype := (0.9 + g_multitype) * 1.1;\n{ELSIF (hastype (variable: g_multitype, STRING))}\n (* the following code is only processed in App2 *)\n g_multitype := 'this is a multitalent';\n{END_IF} " }, 
{ "title" : "hasvalue (PackMode, ' <pack mode value> ') ", 
"url" : "_cds_pragma_conditional.html#UUID-2d0744fc-1387-4648-5d01-12d8bd56a114", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ hasvalue (PackMode, ' <pack mode value> ') ", 
"snippet" : "Der abgeprüfte PackMode hängt von der Gerätebeschreibung ab, nicht vom Pragma, das für einzelne DUTs angegeben werden kann....", 
"body" : "Der abgeprüfte PackMode hängt von der Gerätebeschreibung ab, nicht vom Pragma, das für einzelne DUTs angegeben werden kann. " }, 
{ "title" : "hasvalue (RegisterSize, ' <register size> ') ", 
"url" : "_cds_pragma_conditional.html#UUID-67a2d0e4-3a2a-3ab9-e96a-c17f6bf3b581", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ hasvalue (RegisterSize, ' <register size> ') ", 
"snippet" : "<register size> : Größe eines CPU-Registers in Bit Der Operator bewirkt, dass der Ausdruck den Wert TRUE liefert, wenn die Größe eines CPU-Registers gleich <register size> ist. Mögliche Werte für <register size> 16 für C16x, 64 für X86-64 Bit 32 für X86-32 Bit...", 
"body" : "<register size> : Größe eines CPU-Registers in Bit Der Operator bewirkt, dass der Ausdruck den Wert TRUE liefert, wenn die Größe eines CPU-Registers gleich <register size> ist. Mögliche Werte für <register size> 16 für C16x, 64 für X86-64 Bit 32 für X86-32 Bit " }, 
{ "title" : "hasvalue (<define-ident>, ' <character string> ') ", 
"url" : "_cds_pragma_conditional.html#UUID-a865c5bf-1e43-4a57-cddc-238d2a436773", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ hasvalue (<define-ident>, ' <character string> ') ", 
"snippet" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn eine Variable mit Bezeichner <define-ident> definiert ist und den Wert <character string> hat; ansonsten wird   FALSE zurückgeliefert. Beispiel Voraussetzung: Es gibt zwei Applikationen App1 und App2 . Variable test wird in den Appli...", 
"body" : "Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn eine Variable mit Bezeichner <define-ident> definiert ist und den Wert <character string> hat; ansonsten wird   FALSE zurückgeliefert. Beispiel Voraussetzung: Es gibt zwei Applikationen App1 und App2 . Variable test wird in den Applikationen App1 und App2 verwendet; in App1 erhält sie den Wert 1 , in App2 den Wert   2 . {IF hasvalue(test,'1')}\n (* the following code is only processed in App1 *)\n x := x + 1;\n{ELSIF hasvalue(test,'2')}\n (* the following code is only processed in App2 *)\n x := x + 2;\n{END_IF} " }, 
{ "title" : "project_defined (<global define>) ", 
"url" : "_cds_pragma_conditional.html#UUID-801188c2-bd31-aef6-8db9-6d83d2d1c459", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ project_defined (<global define>) ", 
"snippet" : "Dieser Operator steht ab CODESYS V3.5 SP20 zur Verfügung. Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn das globale Define <global define> in der Liste der globalen Defines in den Compile-Optionen der Projekteinstellungen enthalten ist. Der Operator wird als Bedingung einer IF -...", 
"body" : "Dieser Operator steht ab CODESYS V3.5 SP20 zur Verfügung. Der Operator bewirkt, dass der Ausdruck den Wert TRUE erhält, wenn das globale Define <global define> in der Liste der globalen Defines in den Compile-Optionen der Projekteinstellungen enthalten ist. Der Operator wird als Bedingung einer IF -Anweisung angegeben und kann sowohl in der Implementierung als auch im Deklarationsteil von ST-POUs und von Bibliotheken verwendet werden. Sie können mithilfe der Operatoren AND und OR mit anderen Defines kombiniert werden, wenn diese an der jeweiligen Position erlaubt sind. Im Deklarationsteil von POUs können IF -Anweisungen mit dem Operator project_defined (<global define>) folgende Konstrukte enthalten: Variablendeklarationen Beispiel: {If project_defined(define1)}\n x : DINT;\n{END_IF} Kommentierungen Attribut-Deklarationen Pragma-Anweisungen Folgende Konstrukte sind nicht möglich: Komplette Variablendeklarationen Beispiel {If project_defined(define1)}\nVAR\n x : DINT;\nEND_VAR\n{END_IF} Komplette Deklarationen von POUS Beispiel: {If project_defined(define1)}\nFUNCTION POU : BOOL\nVAR_INPUT\n x : INT;\nEND_VAR\n{END_IF} Gültigkeitsbereiche: VAR_INPUT , VAR_OUTPUT , VAR_IN_OUT " }, 
{ "title" : "NOT <operator> ", 
"url" : "_cds_pragma_conditional.html#UUID-01ae3a3c-e82a-ffd9-c21a-b7e1c89fd024", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ NOT <operator> ", 
"snippet" : "Der Ausdruck erhält den Wert TRUE , wenn der Umkehrwert von <operator> den Wert TRUE liefert. <operator> kann einer der in diesem Kapitel beschriebenen Operatoren sein. Beispiel Voraussetzung: Es gibt zwei Applikationen App1 und App2 . PLC_PRG1 ist in App1 und App2 vorhanden, die POU CheckBounds gib...", 
"body" : "Der Ausdruck erhält den Wert TRUE , wenn der Umkehrwert von <operator> den Wert TRUE liefert. <operator> kann einer der in diesem Kapitel beschriebenen Operatoren sein. Beispiel Voraussetzung: Es gibt zwei Applikationen App1 und App2 . PLC_PRG1 ist in App1 und App2 vorhanden, die POU CheckBounds gibt es nur in App1 . {IF defined (pou: PLC_PRG1) AND NOT (defined (pou: CheckBounds))}\n (* the following code is only processed in App2 *)\n bANDNotTest := TRUE;\n{END_IF} " }, 
{ "title" : " <operator> AND <operator> ", 
"url" : "_cds_pragma_conditional.html#UUID-2570e549-f9f1-cc69-c881-0a2ce3064cef", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ <operator> AND <operator> ", 
"snippet" : "Der Ausdruck erhält den Wert TRUE , wenn die beiden angegebenen Operatoren TRUE liefern. <operator> kann einer der in diesem Kapitel beschriebenen Operatoren sein. Beispiel Voraussetzung: Es gibt die Applikationen App1 und App2 . PLC_PRG1 ist in App1 und App2 vorhanden, die POU CheckBounds nur in Ap...", 
"body" : "Der Ausdruck erhält den Wert TRUE , wenn die beiden angegebenen Operatoren TRUE liefern. <operator> kann einer der in diesem Kapitel beschriebenen Operatoren sein. Beispiel Voraussetzung: Es gibt die Applikationen App1 und App2 . PLC_PRG1 ist in App1 und App2 vorhanden, die POU CheckBounds nur in App1 . {IF defined (pou: PLC_PRG1) AND (defined (pou: CheckBounds))}\n (* the following code is only processed in App1 *)\n bANDTest := TRUE;\n{END_IF} " }, 
{ "title" : "<operator> OR <operator> ", 
"url" : "_cds_pragma_conditional.html#UUID-f4b44590-7911-5a28-1770-b7fdd2a04b3a", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ <operator> OR <operator> ", 
"snippet" : "Der Ausdruck liefert TRUE , wenn einer der beiden angegebenen Operatoren TRUE liefert. <operator> kann einer der hier beschriebenen Operatoren sein. Beispiel Voraussetzung: Es gibt zwei Applikationen App1 und App2 . Die POU PLC_PRG1 ist in App1 und App2 vorhanden, die POU CheckBounds nur in App1 . {...", 
"body" : "Der Ausdruck liefert TRUE , wenn einer der beiden angegebenen Operatoren TRUE liefert. <operator> kann einer der hier beschriebenen Operatoren sein. Beispiel Voraussetzung: Es gibt zwei Applikationen App1 und App2 . Die POU PLC_PRG1 ist in App1 und App2 vorhanden, die POU CheckBounds nur in App1 . {IF defined (pou: PLC_PRG1) OR (defined (pou: CheckBounds))}\n (* the following code is only processed in App1 and in App2 *)\n bORTest := TRUE;\n{END_IF} " }, 
{ "title" : "(<operator>) ", 
"url" : "_cds_pragma_conditional.html#UUID-59abef5c-3fde-2f82-9803-78934d89e364", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Bedingte Pragmas \/ Operatoren \/ (<operator>) ", 
"snippet" : "() klammert die Operatoren....", 
"body" : "() klammert die Operatoren. " }, 
{ "title" : "Region-Pragma ", 
"url" : "_cds_pragma_region.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Pragmas \/ Region-Pragma ", 
"snippet" : "Das Pragma dient dazu, in einem Texteditor mehrere Zeilen zu einem Block zusammenzufassen. Der Block kann mit einem Namen versehen werden. Region-Pragmas können auch ineinander verschachtelt sein. Code mit Region-Pragma: Erweiterte und reduzierte Ansicht Das Pragma kann im ST-Editor und allen Deklar...", 
"body" : "Das Pragma dient dazu, in einem Texteditor mehrere Zeilen zu einem Block zusammenzufassen. Der Block kann mit einem Namen versehen werden. Region-Pragmas können auch ineinander verschachtelt sein. Code mit Region-Pragma: Erweiterte und reduzierte Ansicht Das Pragma kann im ST-Editor und allen Deklarationseditoren verwendet werden. Die Syntaxhervorhebung kann in den Optionen angepasst werden. " }, 
{ "title" : "Bezeichnervergabe ", 
"url" : "_cds_identifiers.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Bezeichnervergabe ", 
"snippet" : "Regeln und Empfehlungen für die Bezeichnervergabe für Variablen, Konstanten, Funktionen, Funktionsbausteine, Methoden und anderen Objekte...", 
"body" : "Regeln und Empfehlungen für die Bezeichnervergabe für Variablen, Konstanten, Funktionen, Funktionsbausteine, Methoden und anderen Objekte " }, 
{ "title" : "Regeln ", 
"url" : "_cds_rules.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Bezeichnervergabe \/ Regeln ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Regeln für Variablen ", 
"url" : "_cds_rules.html#UUID-dad2255f-3304-d0ef-3f4d-daaa6c691390_section-idm4594042020419234099402926422", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Bezeichnervergabe \/ Regeln \/ Regeln für Variablen ", 
"snippet" : "Ein Bezeichner darf keine Leerzeichen oder Sonderzeichen enthalten. Der Unterstrich wird erkannt. Beispielsweise werden A_BCD und AB_CD als zwei verschiedene Bezeichner behandelt. Mehrfach aufeinander folgende Unterstriche sind nicht erlaubt. Groß-\/Kleinschreibung wird nicht unterschieden. Beispiels...", 
"body" : "Ein Bezeichner darf keine Leerzeichen oder Sonderzeichen enthalten. Der Unterstrich wird erkannt. Beispielsweise werden A_BCD und AB_CD als zwei verschiedene Bezeichner behandelt. Mehrfach aufeinander folgende Unterstriche sind nicht erlaubt. Groß-\/Kleinschreibung wird nicht unterschieden. Beispielsweise bezeichnen VAR1 und var1 dieselbe Variable. Die Länge eines Bezeichners ist unbegrenzt. Zusätzlich zu den Punkten, die Sie speziell bei der Variablendeklaration beachten müssen, wird empfohlen die Empfehlungen anzuwenden. Damit erreichen Sie eine möglichst weitgehende Vereinheitlichung bei der Namensvergabe. " }, 
{ "title" : "Regeln bei Mehrfachverwendung (Namensräume) ", 
"url" : "_cds_rules.html#UUID-dad2255f-3304-d0ef-3f4d-daaa6c691390_section-idm4594041991880034099404518269", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Bezeichnervergabe \/ Regeln \/ Regeln bei Mehrfachverwendung (Namensräume) ", 
"snippet" : "Ein Bezeichner darf lokal nicht doppelt deklariert werden. Ein Bezeichner kann global mehrfach verwendet werden. Wenn eine lokale Variable denselben Namen hat wie eine globale Variable, hat die lokale Variable innerhalb einer POU den Vorrang. Ein Bezeichner darf nicht identisch mit einem Schlüsselwo...", 
"body" : "Ein Bezeichner darf lokal nicht doppelt deklariert werden. Ein Bezeichner kann global mehrfach verwendet werden. Wenn eine lokale Variable denselben Namen hat wie eine globale Variable, hat die lokale Variable innerhalb einer POU den Vorrang. Ein Bezeichner darf nicht identisch mit einem Schlüsselwort sein. Beispiel: Gültigkeitsbereich VAR_Global Eine Variable, die in einer globalen Variablenliste deklariert ist, kann denselben Namen haben wie eine Variable, die in einer anderen GVL definiert ist. CODESYS bietet folgende normerweiternde Funktionalitäten bezüglich des Namensraums oder Gültigkeitsbereichs von Variablen an: Globaler Namensraum-Operator Ein Instanzpfad, der mit einem Punkt beginnt, öffnet immer einen globalen Namensraum. Wenn es eine lokale Variable, zum Beispiel ivar , gibt, die denselben Namen hat wie eine globale Variable, sprechen Sie mit .ivar die globale Variable an. Der Name einer globalen Variablenliste kann den Namensraum für die enthaltenen Variablen eindeutig definieren. Somit können Sie Variablen mit demselben Namen in verschiedenen globalen Variablenlisten deklarieren und dennoch durch das Voranstellen des Listennamens eindeutig ansprechen. Beispiel: globlist1.ivar := globlist2.ivar; (* ivar aus GVL globlist2 wird auf ivar in GVL globlist1 kopiert *) Variablen, die in der globalen Variablenliste einer ins Projekt eingebundenen Bibliothek definiert sind, können Sie gemäß der folgenden Syntax eindeutig ansprechen: <name scope library>.< GVL name>.<variable name> Beispiel: globlist1.ivar := lib1.globlist1.ivar (* ivar aus GVL globlist1 in Bibliothek lib1 wird auf ivar in GVL globlist1 kopiert *) Für eine Bibliothek wird beim Einfügen via Bibliotheksverwalter auch ein Namensraum definiert. Somit können Sie einen Bibliotheksbaustein oder eine Bibliotheksvariable über <Namensraum Bibliothek>.<Bausteinname\\|Variablenname> eindeutig ansprechen. Beachten Sie im Fall von verschachtelten Bibliotheken, dass die Namensräume aller beteiligten Bibliotheken in Folge anzugeben sind. Beispiel: Wenn Lib1 durch Lib0 referenziert wird, so wird der in Lib1 enthaltene Baustein func über Lib0.Lib1.fun angesprochen: ivar := Lib0.Lib1.fun(4, 5); (* Rückgabewert von func wird auf Variable ivar im Projekt kopiert *) " }, 
{ "title" : "Backtick-Bezeichner ", 
"url" : "_cds_rules.html#UUID-dad2255f-3304-d0ef-3f4d-daaa6c691390_section-idm4594041889873634099410376242", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Bezeichnervergabe \/ Regeln \/ Backtick-Bezeichner ", 
"snippet" : "Durch die Verwendung von Backticks können in Bezeichnern auch Zeichen verwendet werden, die überlicherweise in Bezeichner nicht erlaubt sind, beispielsweise Sonderzeichen. Für Backticks wird folgendes Zeichen verwendet: ´ (Unicode: U+02CA) Die Verwendung von Backticks wird empfohlen, um in CODESYS d...", 
"body" : "Durch die Verwendung von Backticks können in Bezeichnern auch Zeichen verwendet werden, die überlicherweise in Bezeichner nicht erlaubt sind, beispielsweise Sonderzeichen. Für Backticks wird folgendes Zeichen verwendet: ´ (Unicode: U+02CA) Die Verwendung von Backticks wird empfohlen, um in CODESYS die gleichen Bezeichner wie in anderen Programmiersprachen oder von Dokumenten, beispielsweise Schaltplänen, verwenden zu können. Zwischen zwei Backticks darf jedes Zeichen verwendet werden, außer Zeilenumbrüche und andere Backticks. Auch Schlüsselwörter sind zwischen Backticks als Bezeichner erlaubt. Beispiele: ´Variable+9´ ´INT´ Die Backticks sind Teil des jeweiligen Bezeichners und somit sind var1 und ´var1´ zwei unterschiedliche Bezeichner. Beispiel PROGRAM PLC_PRG\nVAR\n var1 : INT;\n ´var1´: INT;\nEND_VAR\n\nvar1 := var1 + 1;\n´var1´ := 12;\n " }, 
{ "title" : "Empfehlungen ", 
"url" : "_cds_recommendation.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Bezeichnervergabe \/ Empfehlungen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Für Variablen ", 
"url" : "_cds_identifiers_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Bezeichnervergabe \/ Empfehlungen \/ Für Variablen ", 
"snippet" : "Bezeichnen Sie Variablen in Applikationen und Bibliotheken möglichst angelehnt an die ungarische Notation. Finden Sie für jede Variable als Basisnamen eine sinnvolle, möglichst kurze, englische Bezeichnung, die aus mehreren Worten bestehen kann. Schreiben Sie den jeweils ersten Buchstaben eines Wort...", 
"body" : "Bezeichnen Sie Variablen in Applikationen und Bibliotheken möglichst angelehnt an die ungarische Notation. Finden Sie für jede Variable als Basisnamen eine sinnvolle, möglichst kurze, englische Bezeichnung, die aus mehreren Worten bestehen kann. Schreiben Sie den jeweils ersten Buchstaben eines Worts groß, die übrigen Buchstaben klein. Hängen Sie vor den Basisnamen Präfix(e) in Kleinbuchstaben entsprechend dem Datentyp der Variablen. Beispiel: iFileSize : INT; Bezeichnervergabeempfehlung für Datentyp Präfix Beschreibung BOOL x Bewusst wird als Präfix für boolesche Variablen x empfohlen, um sich von Bezeichnern des Datentyps BYTE abzugrenzen. Das Präfix verdeutlicht die Sicht eines IEC-Programmierers. b Reserviert BYTE by Bitfolge, nicht für arithmetische Operationen WORD w Bitfolge, nicht für arithmetische Operationen DWORD dw Bitfolge, nicht für arithmetische Operationen LWORD lw Bitfolge, nicht für arithmetische Operationen SINT si Arithmetischer ganzzahliger Datentyp, 8 Bit USINT usi Arithmetischer ganzzahliger Datentyp, 8 Bit INT i Arithmetischer ganzzahliger Datentyp, 16 Bit UINT ui Arithmetischer ganzzahliger Datentyp, 16 Bit DINT di Arithmetischer ganzzahliger Datentyp, 32 Bit UDINT udi Arithmetischer ganzzahliger Datentyp, 32 Bit LINT li Arithmetischer ganzzahliger Datentyp, 64 Bit ULINT uli Arithmetischer ganzzahliger Datentyp, 64 Bit REAL r Arithmetischer Gleitpunktdatentyp, 32 Bit LREAL lr Arithmetischer Gleitpunktdatentyp, 64 Bit STRING s Einzelbyte-Zeichenfolge variabler Länge (Standardeinstellung 80 Zeichen) WSTRING ws Doppelbyte-Zeichenfolge variabler Länge (Standardeinstellung 80 Zeichen) TIME tim Zeitdauer, 32 Bit LTIME ltim Zeitdauer, 64 Bit TIME_OF_DAY TOD tod Uhrzeit (Tageszeit), 32 Bit LTIME_OF_DAY LTOD ltod Uhrzeit (Tageszeit), 64 Bit DATE_AND_TIME DT dt Datum und Uhrzeit LDATE_AND_TIME LDT ldt DATE dat d Kalenderdatum LDATE ldat ld Kalenderdatum POINTER p ARRAY a Enumeration e Beispiel VAR\n bySubIndix: BYTE;\n xFlag: BOOL;\n udiCounter: UDINT;\nEND_VAR Bezeichnervergabeempfehlung für Beschreibung Beispiel Verschachtelte Deklaration Präfixe werden in der Reihenfolge der Deklaration aneinander gehängt. pabyTelegramData: POINTER TO ARRAY [0..7] OF BYTE; Funktionsbaustein-Instanz Variable vom benutzerdefinierten Datentyp Präfix: Kürzel für den Funktionsbaustein- oder Datentypnamen cansdoReceivedTelegram: CAN_SDOTelegram;\n\nTYPE CAN_SDOTelegram : (* prefix: sdo *)\nSTRUCT\n wIndex: WORD;\n bySubIndex:BYTE;\n byLen:BYTE;\n aby: ARRAY [0..3] OF BYTE;\nEND_STRUCT\nEND_TYPE Lokale Konstante Lokale konstante Variable Präfix: c_ , gefolgt vom Typpräfix und dem Variablennamen VAR CONSTANT\n c_uiSyncID: UINT := 16#80;\nEND_VAR\n Globale Variable An das Bibliothekspräfix wird ein zusätzliches Präfix angehängt. g_ VAR_GLOBAL\n CAN_g_iText: INT;\nEND_VAR\n Globale Konstante Globale konstante Variable An das Bibliothekspräfix wird ein zusätzliches Präfix angehängt. gc_ VAR_GLOBAL CONSTANT\n CAN_gc_dwExample: DWORD;\nEND_VAR\n " }, 
{ "title" : "Für Variablen in CODESYS V3-Bibliotheken ", 
"url" : "_cds_identifiers_var_v3_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Bezeichnervergabe \/ Empfehlungen \/ Für Variablen in CODESYS V3-Bibliotheken ", 
"snippet" : "Für Variablen in Bibliotheken Bezeichnervergabeempfehlung für Beschreibung Beispiel Variable Entspricht der obigen Beschreibung für Variablennamen mit der Ausnahme, dass globale Variablen und Konstanten kein Bibliothekspräfix benötigen, da der Namensraum die Funktion ersetzt. g_iTest: INT; \/\/ Declar...", 
"body" : "Für Variablen in Bibliotheken Bezeichnervergabeempfehlung für Beschreibung Beispiel Variable Entspricht der obigen Beschreibung für Variablennamen mit der Ausnahme, dass globale Variablen und Konstanten kein Bibliothekspräfix benötigen, da der Namensraum die Funktion ersetzt. g_iTest: INT; \/\/ Declaration CAN.g_iTest; \/\/ Implementation; call in the program " }, 
{ "title" : "Für benutzerdefinierte Datentypen ", 
"url" : "_cds_identifiers_dut.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Bezeichnervergabe \/ Empfehlungen \/ Für benutzerdefinierte Datentypen ", 
"snippet" : "Für DUTs Bezeichnervergabeempfehlung für Beschreibung Beispiel Strukturen Bibliothekspräfix, gefolgt von einem Unterstrich und einer kurzen, aussagekräftigen Beschreibung der Struktur Das zugehörige Präfix für angelegte Variablen dieser Struktur soll als Kommentar direkt nach dem Doppelpunkt folgen....", 
"body" : "Für DUTs Bezeichnervergabeempfehlung für Beschreibung Beispiel Strukturen Bibliothekspräfix, gefolgt von einem Unterstrich und einer kurzen, aussagekräftigen Beschreibung der Struktur Das zugehörige Präfix für angelegte Variablen dieser Struktur soll als Kommentar direkt nach dem Doppelpunkt folgen. TYPE CAN_SDOTelegram : (* prefix: sdo *)\n STRUCT\n wIndex : WORD;\n bySubIndex : BYTE;\n byLen : BYTE;\n abyData: ARRAY [0..3] OF BYTE;\n END_STRUCT\nEND_TYPE\n Enumerationen Bibiliothekspräfix, gefolgt von einem Unterstrich und dem Bezeichner in Großbuchstaben In vergangenen CODESYS -Versionen haben Enumerationswerte > 16#7FFF zu Fehlern geführt, da sie nicht automatisch in INT konvertiert wurden. Deklarieren Sie aus diesem Grund Enumerationen stets mit korrekten INT -Werten. TYPE CAL_Day :\n(\nCAL_MONDAY,\nCAL_TUESDAY, \nCAL_WEDNESDAY,\nCAL_THURSDAY,\nCAL_SUNDAY\n);\n Deklaration: eToday: CAL_DAY; " }, 
{ "title" : "Für benutzerdefinierte Datentypen in CODESYS V3-Bibliotheken ", 
"url" : "_cds_identifiers_dut_v3_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Bezeichnervergabe \/ Empfehlungen \/ Für benutzerdefinierte Datentypen in CODESYS V3-Bibliotheken ", 
"snippet" : "Für DUTs in V3-Bibliotheken Bezeichnervergabeempfehlung für Beschreibung Beispiel DUTs in CODESYS V3 -Bibliotheken Es wird auf das Bibliothekspräfix verzichtet, da die Funktion des Bibliothekspräfixes durch den Namensraum ersetzt wird. Auch die Enumerationswerte werden ohne Bibliothekspräfix definie...", 
"body" : "Für DUTs in V3-Bibliotheken Bezeichnervergabeempfehlung für Beschreibung Beispiel DUTs in CODESYS V3 -Bibliotheken Es wird auf das Bibliothekspräfix verzichtet, da die Funktion des Bibliothekspräfixes durch den Namensraum ersetzt wird. Auch die Enumerationswerte werden ohne Bibliothekspräfix definiert. Bibliothek mit Namensraum CAL : TYPE DAY : \n(\nMONDAY,\nTUESDAY,\nWEDNESDAY,\nTHURSDAY,\nFRIDAY,\nSATURDAY,\nSUNDAY\n); Deklaration: eToday: CAL.Day; Verwendung in der Applikation IF eToday = CAL.Day.MONDAY THEN " }, 
{ "title" : "Für Programmierbausteine ", 
"url" : "_cds_identifiers_pous.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Bezeichnervergabe \/ Empfehlungen \/ Für Programmierbausteine ", 
"snippet" : "Bezeichnervergabeempfehlung für Beschreibung Beispiel Funktionen, Funktionsbausteine, Programme Bibliothekspräfix gefolgt von einem Unterstrich und einem aussagekräftigen, möglichst kurzen Namen der POU Wie bei den Variablen soll der jeweils erste Buchstabe eines Worts des Basisnamens groß, die übri...", 
"body" : "Bezeichnervergabeempfehlung für Beschreibung Beispiel Funktionen, Funktionsbausteine, Programme Bibliothekspräfix gefolgt von einem Unterstrich und einem aussagekräftigen, möglichst kurzen Namen der POU Wie bei den Variablen soll der jeweils erste Buchstabe eines Worts des Basisnamens groß, die übrigen klein geschrieben werden. Es wird empfohlen, den Namen der POU aus einem Verb und einem Substantiv zusammenzusetzen. Bei Funktionsbausteinen soll das zugehörige Präfix für angelegte Instanzen als Kommentar direkt nach dem Namen folgen. FUNCTION_BLOCK CAN_SendTelegram (* prefix: canst *) Aktionen Nur Aktionen, die der Baustein selbst aufruft, beginnen mit prv_ . Ansonsten erhalten Aktionen kein Präfix. " }, 
{ "title" : "Für Programmierbausteine in CODESYS V3-Bibliotheken ", 
"url" : "_cds_identifiers_pou_v3_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Bezeichnervergabe \/ Empfehlungen \/ Für Programmierbausteine in CODESYS V3-Bibliotheken ", 
"snippet" : "Für V3-Bibliotheksbausteine Bezeichnervergabeempfehlung für Beschreibung Beispiel POU Es wird auf das Bibliothekspräfix verzichtet, da der Namensraum die Funktion des Bibliothekspräfix ersetzt. FUNCTION_BLOCK SendTelegram (* prefix: canst *) Methode Nur Methoden, die der Baustein selbst aufruft, beg...", 
"body" : "Für V3-Bibliotheksbausteine Bezeichnervergabeempfehlung für Beschreibung Beispiel POU Es wird auf das Bibliothekspräfix verzichtet, da der Namensraum die Funktion des Bibliothekspräfix ersetzt. FUNCTION_BLOCK SendTelegram (* prefix: canst *) Methode Nur Methoden, die der Baustein selbst aufruft, beginnen mit prv_ . Ansonsten erhalten Methoden kein Präfix. Interface Schnittstelle I ICANDevice " }, 
{ "title" : "Für Visualisierungen ", 
"url" : "_cds_identifiers_visu.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Bezeichnervergabe \/ Empfehlungen \/ Für Visualisierungen ", 
"snippet" : "Namenswahlempfehlungen für Visualisierungsobjekte Achten Sie darauf, dass eine Visualisierung nicht denselben Namen erhält wie ein anderer Baustein im Projekt, da dies bei Visualisierungswechseln zu Problemen führen würde....", 
"body" : "Namenswahlempfehlungen für Visualisierungsobjekte Achten Sie darauf, dass eine Visualisierung nicht denselben Namen erhält wie ein anderer Baustein im Projekt, da dies bei Visualisierungswechseln zu Problemen führen würde. " }, 
{ "title" : "Verschattungsregeln ", 
"url" : "_cds_shadowing_rules.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Verschattungsregeln ", 
"snippet" : "In CODESYS ist es prinzipiell erlaubt, den gleichen Bezeichner für verschiedene Elemente zu verwenden. So können beispielsweise ein Baustein und eine Variable gleich benannt werden. Um Verwechslungen vorzubeugen, sollte dies jedoch vermieden werden. Beispiel Negativbeispiel: Im folgenden Codeausschn...", 
"body" : "In CODESYS ist es prinzipiell erlaubt, den gleichen Bezeichner für verschiedene Elemente zu verwenden. So können beispielsweise ein Baustein und eine Variable gleich benannt werden. Um Verwechslungen vorzubeugen, sollte dies jedoch vermieden werden. Beispiel Negativbeispiel: Im folgenden Codeausschnitt hat eine lokale Funktionsbaustein-Instanz den gleichen Namen wie eine Funktion: In einem solchen Fall ist unklar, ob im Programm die Instanz oder die Funktion aufgerufen wird. FUNCTION YYY : INT\n;\nEND_FUNCTION\n\nFUNCTION_BLOCK XXX\n;\nEND_FUNCTION_BLOCK\n\nPROGRAM PLC_PRG\nVAR\n YYY : XXX;\nEND_VAR\nYYY();\nEND_PROGRAM " }, 
{ "title" : "Compilerverhalten bei Verschattung ", 
"url" : "_cds_shadowing_rules.html#UUID-86e09bbc-278d-7399-b9c2-0648c7961f10_section-idm462806727981763350320566511", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Verschattungsregeln \/ Compilerverhalten bei Verschattung ", 
"snippet" : "Der Compiler meldet grundsätzlich weder Fehler noch Warnungen, wenn derselbe Bezeichner für verschiedene Elemente verwendet wird. Stattdessen durchsucht der Compiler den Code in einer bestimmten Reihenfolge nach der Deklaration des Bezeichners. Wenn eine Deklaration gefunden wurde, dann sucht der Co...", 
"body" : "Der Compiler meldet grundsätzlich weder Fehler noch Warnungen, wenn derselbe Bezeichner für verschiedene Elemente verwendet wird. Stattdessen durchsucht der Compiler den Code in einer bestimmten Reihenfolge nach der Deklaration des Bezeichners. Wenn eine Deklaration gefunden wurde, dann sucht der Compiler nicht nach eventuellen weiteren Deklarationen an anderer Stelle. Wenn weitere Deklarationen existieren, dann sind diese für den Compiler „verschattet“. Im Folgenden werden die Verschattungsregeln beschrieben, das heißt die Suchreihenfolgen, die der Compiler bei der Suche nach der Deklaration für Bezeichner verwendet. Im Abschnitt „Uneindeutige Zugriffe und qualifizierte Zugriffe“ werden Möglichkeiten aufgezeigt, um uneindeutige Zugriffe zu vermeiden und die Verschattungsregeln zu umgehen. " }, 
{ "title" : "Verschattung vermeiden ", 
"url" : "_cds_shadowing_rules.html#UUID-86e09bbc-278d-7399-b9c2-0648c7961f10_section-idm4593930303395233503201805458", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Verschattungsregeln \/ Verschattung vermeiden ", 
"snippet" : "Um sicherzustellen, dass Namen immer eindeutig sind, sollten Namenskonventionen beachtet werden, beispielsweise bestimmte Präfixe für Variablen. Für weitere Informationen siehe: BezeichnervergabeNamenskonventionen können mit Hilfe der statischen Codeanalyse von CODESYS automatisch überprüft werden. ...", 
"body" : "Um sicherzustellen, dass Namen immer eindeutig sind, sollten Namenskonventionen beachtet werden, beispielsweise bestimmte Präfixe für Variablen. Für weitere Informationen siehe: BezeichnervergabeNamenskonventionen können mit Hilfe der statischen Codeanalyse von CODESYS automatisch überprüft werden. Die statische Codeanalyse könnte auch die doppelte Verwendung des Namens YYY aufdecken und als Fehler melden. Auch durch die konsequente Verwendung des Attributs qualified_only für Enumerationen und globale Variablenlisten und durch die Verwendung von qualifizierten Bibliotheken können nicht-eindeutige Situationen vermieden werden. Um sicherzustellen, dass beim Aufruf eines Programmierbausteins der Ansicht POUs nicht ein gleichnamiger Programmierbaustein der Ansicht Geräte aufgerufen wird, sollte beim Aufruf dem Namen des Programmierbausteins der Operator __POOL vorangestellt werden. Beispiel: svar_pou := __POOL.POU(); " }, 
{ "title" : "Suchreihenfolge in der Applikation ", 
"url" : "_cds_shadowing_rules.html#UUID-86e09bbc-278d-7399-b9c2-0648c7961f10_id_eb9f3a6f8dc5c0a864633ab16f46_id_ac2947743b785338c0a864635c9601cf", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Verschattungsregeln \/ Suchreihenfolge in der Applikation ", 
"snippet" : "Wenn der Compiler im Code einer Applikation auf einen einzelnen Bezeichner trifft, dann sucht er die zugehörige Deklaration in der folgenden Reihenfolge: Lokale Variablen Lokale Variablen einer Methode Lokale Variablen im Funktionsbaustein, Programm oder Funktion und in eventuellen Basisfunktionsbau...", 
"body" : "Wenn der Compiler im Code einer Applikation auf einen einzelnen Bezeichner trifft, dann sucht er die zugehörige Deklaration in der folgenden Reihenfolge: Lokale Variablen Lokale Variablen einer Methode Lokale Variablen im Funktionsbaustein, Programm oder Funktion und in eventuellen Basisfunktionsbausteinen Lokale Methoden des Bausteins Globale Variablen Globale Variablen in der Applikation, wenn in der Variablenliste, in der die globalen Variablen deklariert sind, nicht das Attribut qualified_only gesetzt ist Globale Variablen in einer Vaterapplikation, sofern in der Variablenliste, in der die globalen Variablen deklariert sind, nicht das Attribut qualified_only gesetzt ist Globale Variablen in angezogenen Bibliotheken, wenn weder die Bibliothek noch die Variablenliste qualifizierten Zugriff erfordert Baustein- oder Typnamen Baustein- oder Typnamen aus der Applikation (das heißt: Namen von Globalen Variablenlisten, Funktionsbausteinen, etc.) Baustein- oder Typnamen aus einer Vaterapplikation Baustein- oder Typnamen aus einer Bibliothek Bibliotheken Namensräume von lokal angezogenen Bibliotheken und Bibliotheken, die von Bibliotheken veröffentlicht werden Ansicht POUs Globale Variablen in der Ansicht POUs , sofern in der Variablenliste, in der sie deklariert sind, nicht das Attribut qualified_only gesetzt ist Baustein- oder Typnamen aus der Ansicht POUs (das heißt: Namen von Globalen Variablenlisten, Funktionsbausteinen, etc.) Bibliotheken aus POUs Bibliotheken, die im Bibliotheksverwalter der Ansicht POUs eingefügt werden, werden mit der entsprechenden Platzhalterauflösung in den Bibliotheksverwalter in allen Applikationen im Projekt gespiegelt. Diese Bibliotheken bilden dann mit den Bibliotheken in der Applikation einen gemeinsamen Namensraum. Daher gibt es keine Verschattung von Bibliotheken im Pool durch Bibliotheken in der Applikation. " }, 
{ "title" : "Suchreihenfolge in der Bibliothek ", 
"url" : "_cds_shadowing_rules.html#UUID-86e09bbc-278d-7399-b9c2-0648c7961f10_id_eb9f3a6f8dc5c0a864633ab16f46_id_6e5cf3e23b785338c0a864631e655a41", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Verschattungsregeln \/ Suchreihenfolge in der Bibliothek ", 
"snippet" : "Wenn der Compiler im Code einer Bibliothek auf einen einzelnen Bezeichner trifft, dann sucht er die zugehörige Deklaration in der folgenden Reihenfolge: Lokale Variablen Lokale Variablen einer Methode Lokale Variablen im Funktionsbaustein, Programm oder Funktion und in eventuellen Basis-Funktionsbau...", 
"body" : "Wenn der Compiler im Code einer Bibliothek auf einen einzelnen Bezeichner trifft, dann sucht er die zugehörige Deklaration in der folgenden Reihenfolge: Lokale Variablen Lokale Variablen einer Methode Lokale Variablen im Funktionsbaustein, Programm oder Funktion und in eventuellen Basis-Funktionsbausteinen Lokale Methoden des Bausteins Globale Variablen Globale Variablen in der lokalen Bibliothek, wenn die Variablenliste, in der die globalen Variablen deklariert sind, nicht das Attribut qualified_only gesetzt hat Globale Variablen in angezogenen Bibliotheken, wenn weder die Bibliothek noch die Variablenliste qualifizierten Zugriff erfordert Bibliotheken Baustein- oder Typnamen aus der lokalen Bibliothek (das heißt: Namen von globalen Variablenlisten, Funktionsbausteinen, etc.) Baustein- oder Typnamen aus einer angezogenen Bibliothek Namensräume von lokal angezogenen Bibliotheken und Bibliotheken, die von lokal angezogenen Bibliotheken veröffentlicht werden " }, 
{ "title" : "Uneindeutige Zugriffe und qualifizierte Zugriffe ", 
"url" : "_cds_shadowing_rules.html#UUID-86e09bbc-278d-7399-b9c2-0648c7961f10_id_eb9f3a6f8dc5c0a864633ab16f46_id_d382bb6d3b785338c0a86463219183c4", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Verschattungsregeln \/ Uneindeutige Zugriffe und qualifizierte Zugriffe ", 
"snippet" : "Trotz dieser Suchreihenfolgen kann es zu uneindeutigen Zugriffen kommen. Das ist zum Beispiel der Fall, wenn eine Variable mit dem gleichen Namen in zwei globalen Variablenlisten vorkommt, die nicht qualifizierten Zugriff erfordern. Einen solchen Fall meldet der Compiler als Fehler (zum Beispiel: Ni...", 
"body" : "Trotz dieser Suchreihenfolgen kann es zu uneindeutigen Zugriffen kommen. Das ist zum Beispiel der Fall, wenn eine Variable mit dem gleichen Namen in zwei globalen Variablenlisten vorkommt, die nicht qualifizierten Zugriff erfordern. Einen solchen Fall meldet der Compiler als Fehler (zum Beispiel: Nicht eindeutige Verwendung des Namens XXX ). Eine solche uneindeutige Verwendung lässt sich durch einen qualifizierten Zugriff, also beispielsweise durch den Zugriff über den Namen der globalen Variablenliste, eindeutig machen (zum Beispiel: GVL.XXX ). Ein qualifizierter Zugriff lässt sich auch immer dazu nutzen, um Verschattungsregeln zu umgehen. Mit dem Namen der globalen Variablenliste kann eindeutig auf eine Variable in dieser Liste zugegriffen werden. Mit dem Namen einer Bibliothek kann eindeutig auf Elemente in dieser Bibliothek zugegriffen werden. Mit dem Pointer THIS kann eindeutig auf Variablen in einem Funktionsbaustein zugegriffen werden, auch wenn eine lokale Variable mit gleichem Namen in einer Methode des Funktionsbausteins existiert. Um jederzeit die Deklarationsstelle eines Bezeichners zu finden, wählen Sie den Befehl Bearbeiten → Symbol suchen → Gehe zur Definition . Dies kann insbesondere dann hilfreich sein, wenn der Compiler eine scheinbar unverständliche Fehlermeldung produziert. " }, 
{ "title" : "Suchen in Instanzpfaden ", 
"url" : "_cds_shadowing_rules.html#UUID-86e09bbc-278d-7399-b9c2-0648c7961f10_id_eb9f3a6f8dc5c0a864633ab16f46_id_4094da363b785338c0a864632107d534", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Verschattungsregeln \/ Suchen in Instanzpfaden ", 
"snippet" : "Die oben beschriebenen Suchreihenfolgen gelten nicht für Bezeichner, die in einem Instanzpfad als Komponente auftauchen, oder für Bezeichner, die als Eingänge in Aufrufen verwendet werden. Für einen Zugriff der folgenden Art yy.component hängt es von der Entität ab, die durch yy beschrieben wird, wo...", 
"body" : "Die oben beschriebenen Suchreihenfolgen gelten nicht für Bezeichner, die in einem Instanzpfad als Komponente auftauchen, oder für Bezeichner, die als Eingänge in Aufrufen verwendet werden. Für einen Zugriff der folgenden Art yy.component hängt es von der Entität ab, die durch yy beschrieben wird, wo nach der Deklaration von component gesucht wird. Wenn yy eine Variable mit strukturiertem Datentyp bezeichnet (also vom Typ STRUCT oder UNION ), dann wird component in dieser Reihenfolge gesucht: Lokale Variablen des Funktionsbausteins Lokale Variablen des Basis-Funktionsbausteins Methoden des Funktionsbausteins Methoden des Basis-Funktionsbausteins Wenn yy eine globale Variablenliste bezeichnet oder ein Programm, dann wird component nur in dieser Liste gesucht. Wenn yy einen Namensraum einer Bibliothek bezeichnet, dann wird component in dieser Bibliothek genau so gesucht, wie es im obigen Abschnitt „Suchreihenfolge in der Bibliothek“ beschrieben ist. Erst in zweiter Instanz entscheidet der Compiler, ob der Zugriff auf das gefundene Element erlaubt ist, das heißt, ob die Variable möglicherweise nur lokal zugreifbar ist, oder ob eine Methode privat ist. Wenn der Zugriff nicht erlaubt ist, dann wird ein Fehler ausgegeben. " }, 
{ "title" : "Schlüsselwörter ", 
"url" : "_cds_keywords.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Schlüsselwörter ", 
"snippet" : "Sie müssen Schlüsselwörter, die beispielweise Gültigkeitsbereiche, Datentypen oder Operatoren bezeichnen, in allen Editoren in Großbuchstaben schreiben. Schlüsselwörter können nicht als Variablennamen verwendet werden. Beispiel VAR END_VAR BOOL_TO_INT IF THEN ELSE LTIME MUL XOR PERSISTENT PROGRAM CO...", 
"body" : "Sie müssen Schlüsselwörter, die beispielweise Gültigkeitsbereiche, Datentypen oder Operatoren bezeichnen, in allen Editoren in Großbuchstaben schreiben. Schlüsselwörter können nicht als Variablennamen verwendet werden. Beispiel VAR\nEND_VAR\nBOOL_TO_INT\nIF\nTHEN\nELSE\nLTIME\nMUL\nXOR\nPERSISTENT\nPROGRAM CODESYS überprüft die korrekte Verwendung von Schlüsselwörtern automatisch und unterkringelt Fehler unmittelbar bei der Eingabe. Wenn CODESYS impliziten Code anlegt, werden Variablen und Funktionen im Regelfall mit einem Namen versehen der „__“ enthält und meistens damit beginnt. Die Verwendung von doppelten Unterstrichen im Implementierungscode wird automatisch verhindert. Somit kann es nicht zu Konflikten zwischen systeminternen und den vom Programmierer vergebenen Bezeichnern kommen. Folgende Schlüsselwörter werden im CODESYS -Export-Format verwendet. Sie dürfen sie deshalb nicht als Bezeichner verwenden: ACTION END_ACTION END_FUNCTION END_FUNCTION_BLOCK END_PROGRAM Ebenfalls als Schlüsselwörter gelten: VAR_ACCESS READ_ONLY READ_WRITE PARAMS " }, 
{ "title" : "Methode: FB_Init , FB_Reinit , FB_Exit ", 
"url" : "_cds_method_fb_init_fb_reinit.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Methode: FB_Init , FB_Reinit , FB_Exit ", 
"snippet" : "Die Methoden können Sie explizit einsetzen, um Einfluss zu nehmen auf die Initialisierung von Funktionsbaustein-Variablen und auf das Verhalten beim Beenden von Funktionsbausteinen. Der Typ des Rückgabewertes für die impliziten Methoden ist BOOL . Der Wert wird vom System nicht ausgewertet, der Typ ...", 
"body" : "Die Methoden können Sie explizit einsetzen, um Einfluss zu nehmen auf die Initialisierung von Funktionsbaustein-Variablen und auf das Verhalten beim Beenden von Funktionsbausteinen. Der Typ des Rückgabewertes für die impliziten Methoden ist BOOL . Der Wert wird vom System nicht ausgewertet, der Typ sollte jedoch nicht geändert werden. FB_Init ist immer implizit verfügbar und wird grundsätzlich bei der Initialisierung aufgerufen. Für eine gezielte Einflussnahme können Sie die Methode außerdem explizit deklarieren und dort zusätzlichen Code zum Standardinitialisierungscode ergänzen. FB_Reinit muss explizit implementiert werden. Wenn diese Methode vorliegt, wird sie aufgerufen, nachdem die Instanz des betreffenden Funktionsbausteins kopiert wurde. Das geschieht während eines Online-Changes nach Änderungen an der Funktionsbausteindeklaration (Signaturänderung), um das neue Instanzmodul zu reinitalisieren. Um eine Reinitialisierung der Basisimplementierung des Funktionsbausteins zu erreichen, müssen Sie FB_Reinit noch explizit aufrufen. FB_Exit müssen Sie explizit implementieren. Wenn eine Implementierung vorliegt, wird die Methode aufgerufen, bevor der Code der Funktionsbaustein-Instanz von der Steuerung entfernt wird (impliziter Aufruf). Im Folgenden sehen Sie für verschiedenen Betriebsfälle einige Anwendungsfälle dieser Methoden. " }, 
{ "title" : "Betriebsfall „Erster Download“ ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_ee2ec072ce4c52dbc0a864631de40b39", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Methode: FB_Init , FB_Reinit , FB_Exit \/ Betriebsfall „Erster Download“ ", 
"snippet" : "Beim Download einer Applikation auf eine Steuerung, die sich im Auslieferungszustand befindet, müssen die Speicherplätze aller Variablen in den gewünschten Ausgangszustand versetzt werden. Dadurch werden die Datenbereiche von Funktionsbaustein-Instanzen mit den gewünschten Werten belegt. Durch die e...", 
"body" : "Beim Download einer Applikation auf eine Steuerung, die sich im Auslieferungszustand befindet, müssen die Speicherplätze aller Variablen in den gewünschten Ausgangszustand versetzt werden. Dadurch werden die Datenbereiche von Funktionsbaustein-Instanzen mit den gewünschten Werten belegt. Durch die explizite Implementierung von FB_Init für Funktionsbausteine können Sie im Code der Applikation in dieser Situation gezielt reagieren. Durch die Auswertung der Methodenparameter bInCopyCode ( FALSE ) und bInitRetains ( TRUE ) können Sie diesen Betriebsfall eindeutig detektieren. " }, 
{ "title" : "Betriebsfall „Online-Change“ ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_11211aface4c52dbc0a864635676a307", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Methode: FB_Init , FB_Reinit , FB_Exit \/ Betriebsfall „Online-Change“ ", 
"snippet" : "Im Rahmen des Online-Changes können Sie über die Methoden FB_Exit , FB_Init und FB_Reinit die Initialisierung von Funktionsbaustein-Instanzen beeinflussen. Im Rahmen des Online-Changes werden die im Offlinebetrieb vollzogenen Änderungen an der Applikation in der laufenden Steuerung nachvollzogen. De...", 
"body" : "Im Rahmen des Online-Changes können Sie über die Methoden FB_Exit , FB_Init und FB_Reinit die Initialisierung von Funktionsbaustein-Instanzen beeinflussen. Im Rahmen des Online-Changes werden die im Offlinebetrieb vollzogenen Änderungen an der Applikation in der laufenden Steuerung nachvollzogen. Deshalb werden die „alten“ Instanzen der Funktionsbausteine durch Ihre „neuen Geschwister“ möglichst stoßfrei ersetzt. Wenn vor dem Login in der Applikation keine Änderungen am Deklarationsteil eines Funktionsbausteins vorgenommen wurde, sondern nur in der Implementierung, dann findet keine Ersetzung der Datenbereiche statt. Es werden nur Codeblöcke ersetzt. Dann werden die Methoden FB_Exit , FB_Init und FB_Reinit nicht aufgerufen! Wenn Sie Änderungen in der Deklaration eines Funktionsbausteins vorgenommen haben, die zum oben beschriebenen Kopiervorgang führen werden, erhalten Sie beim Online-Change eine Meldung zu den „möglicherweise unbeabsichtigten Auswirkungen“. In den Details der Meldungsbox sehen Sie eine Liste aller zu kopierenden Instanzen aufgelistet. Im Code der Methode FB_Init kann durch Auswertung der Parameter bInCopyCode ( TRUE ) ermittelt werden, ob gerade ein Online-Change ausgeführt wird. Beim Online-Change erfolgen nacheinander folgende Aufrufe: FB_Exit old_inst.FB_Exit(bInCopyCode := TRUE); Sie können den Aufruf von FB_Exit beim Verlassen der „alten“ Instanz verwenden, um vor dem Kopiervorgang bestimmte Aufräumarbeiten anzustoßen. So können Sie die Daten für den folgenden Kopiervorgang vorbereiten und den Zustand der „neuen“ Instanz beeinflussen. Andere Teile der Applikation können Sie über die bevorstehende Lageänderung im Speicher informieren. Achten Sie besonders auf Variablen vom Typ POINTER oder REFERENCE . Diese verweisen nach dem Online-Change eventuell nicht mehr auf die gewünschten Speicherstellen. Schnittstellenvariablen ( INTERFACE ) werden vom Compiler gesondert behandelt und beim Online-Change entsprechend angepasst. Externe Ressourcen wie beispielsweise Sockets, Files oder andere Handles können eventuell unverändert von der neuen Instanz übernommen werden. Sie müssen oft während des Online-Changes nicht gesondert behandelt werden. (Siehe „Betriebsfall „Erneuter Download““) FB_Init new_inst.FB_Init(bInitRetains := FALSE, bInCopyCode := TRUE); Der Aufruf von FB_Init erfolgt vor dem Kopiervorgang und kann verwendet werden, um für den Online-Change spezifische Operationen auszuführen. Beispielsweise können Sie darüber Variablen an der „neuen“ Position im Speicher entsprechend initialisieren lassen, oder andere Teile der Applikation über die neue Position bestimmter Variablen im Speicher informieren. Kopiervorgang copy copy(&old_inst, &new_inst); Bestehende Werte bleiben erhalten. Zu diesem Zweck werden sie aus der alten Instanz in die neue kopiert. FB_Reinit new_inst.FB_Reinit(); Diese Methode wird nach dem Kopiervorgang aufgerufen und setzt die Variablen der Instanz auf definierte Werte. Beispielsweise können Sie darüber Variablen an der „neuen“ Position im Speicher entsprechend initialisieren, oder andere Teile der Applikation über die neue Position bestimmter Variablen im Speicher informieren. Gestalten Sie die Implementierung unabhängig vom Online-Change. Die Methode kann nämlich auch aus der Applikation heraus jederzeit aufgerufen werden, um eine Funktionsbaustein-Instanz in den ursprünglichen Zustand zurückzuversetzen. Mit dem Attribut {attribute 'no_copy'} können Sie für eine einzelne Variable des Funktionsbausteins verhindern, dass diese beim Online-Change kopiert wird. Sie behält dann immer den Initialwert. Für weitere Informationen siehe: Einstellungen Speicherreserve für Online-Change" }, 
{ "title" : "Betriebsfall „Erneuter Download“ ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_18382d25ce4c52dbc0a86463733d1d36", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Methode: FB_Init , FB_Reinit , FB_Exit \/ Betriebsfall „Erneuter Download“ ", 
"snippet" : "Beim Download einer Applikation wird eventuell eine bereits vorhandene Applikation auf der Steuerung ersetzt. Deshalb muss der Speicherplatz für die vorhandenen Funktionsbausteine geregelt freigegeben werden. Sie können die Methode FB_Exit verwenden, um die dazu notwendigen Schritte zu implementiere...", 
"body" : "Beim Download einer Applikation wird eventuell eine bereits vorhandene Applikation auf der Steuerung ersetzt. Deshalb muss der Speicherplatz für die vorhandenen Funktionsbausteine geregelt freigegeben werden. Sie können die Methode FB_Exit verwenden, um die dazu notwendigen Schritte zu implementieren. Beispielsweise können Sie externe Ressourcen (mit Socket- oder File-Handles) in einen definierten Zustand versetzen. Sie können diesen Betriebsfall detektieren, indem Sie überprüfen, ob bei der Methode FB_Exit der Parameter bInCopyCode = FALSE ist. " }, 
{ "title" : "Betriebsfall „Start der Applikation“ ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_a4a0f73c27f211e6b1abd7715e61fd27", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Methode: FB_Init , FB_Reinit , FB_Exit \/ Betriebsfall „Start der Applikation“ ", 
"snippet" : "Vor dem ersten Zyklus der Task einer Applikation werden die initialen Zuweisungen verarbeitet. Beispiel T1 : TON := (PT:=t#500ms); Solche Zuweisungen werden erst nach dem Aufruf von FB_Init ausgeführt. Um die Auswirkungen dieser Zuweisungen kontrollieren zu können, dürfen Sie einen Funktionsbaustein...", 
"body" : "Vor dem ersten Zyklus der Task einer Applikation werden die initialen Zuweisungen verarbeitet. Beispiel T1 : TON := (PT:=t#500ms); Solche Zuweisungen werden erst nach dem Aufruf von FB_Init ausgeführt. Um die Auswirkungen dieser Zuweisungen kontrollieren zu können, dürfen Sie einen Funktionsbaustein oder eine Methode eines Funktionsbausteins mit dem Attribut {attribute ‘call_after_init‘} versehen. Sie müssen das Attribut sowohl über dem Deklarationsteil des Funktionsbausteinrumpfes als auch über dem Deklarationsteil der entsprechenden Methode einfügen. Ein Baustein, der einen anderen Baustein erweitert, der das {attribute 'call_after_init'} verwendet, muss ebenfalls mit dem Attribut versehen werden. Aus Gründen der Verständlichkeit wird empfohlen, die entsprechende Methode mit dem gleichen Namen, der gleichen Signatur und dem gleichen Attribut zu überschreiben. Das erfordert einen Aufruf von SUPER^.MyInit . Der Name der Methode ist frei wählbar. (Ausnahmen: FB_Init , FB_Reinit und FB_Exit ). Die Methode wird nach der Verarbeitung der initialen Zuweisungen und vor dem Start der Tasks einer Applikation aufgerufen und kann so auf die Vorgaben des Anwenders entsprechend reagieren. Bedenken Sie bei der Verwendung von FB_Init oder {attribute 'call_after_init'} jedoch auch Folgendes:Das Finden von Fehlern in den Methoden FB_Init oder in Methoden die mit {attribute 'call_after_init'} dekoriert sind, ist mühsam,weil unter Anderem das Setzen von Haltepunkten nicht die gewünschte Wirkung haben kann. Wenn während der Ausführung der explizit definierten Initialisierungscode erreicht wird, ist die Funktionsbaustein-Instanz bereits über den impliziten Initialisierungscode vollständig initialisiert. Es darf deshalb kein SUPER^.FB_Init -Aufruf erfolgen. FB_Init ersetzt den in CoDeSys V2.3 verwendeten INI -Operator. Die Methode ist nicht zu vergleichen mit dem Konstrukt eines Konstruktors, wie man ihn aus C#, C++ oder auch Java kennt. Das hat Konsequenzen für Funktionsbausteine, die andere Funktionsbausteine erweitern. (Siehe unten „Abgeleitete Funktionsbausteine“) " }, 
{ "title" : "Schnittstelle der Methode FB_Init ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_484f4ece66da11e7bb4fee5053811542", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Methode: FB_Init , FB_Reinit , FB_Exit \/ Schnittstelle der Methode FB_Init ", 
"snippet" : "METHOD FB_Init : BOOL VAR_INPUT bInitRetains : BOOL; \/\/ TRUE: the retain variables are initialized (reset warm \/ reset cold) bInCopyCode : BOOL; \/\/ TRUE: the instance will be copied to the copy code afterward (online change) END_VAR Sie können in einer FB_Init -Methode zusätzliche Funktionsbaustein-...", 
"body" : "METHOD FB_Init : BOOL\nVAR_INPUT\n bInitRetains : BOOL; \/\/ TRUE: the retain variables are initialized (reset warm \/ reset cold)\n bInCopyCode : BOOL; \/\/ TRUE: the instance will be copied to the copy code afterward (online change)\nEND_VAR Sie können in einer FB_Init -Methode zusätzliche Funktionsbaustein-Eingänge deklarieren. Sie müssen dann diese Eingänge in der Deklaration der Funktionsbaustein-Instanz setzen. Beispiel Methode FB_Init für den Funktionsbaustein serialdevice METHOD PUBLIC FB_Init : BOOL\nVAR_INPUT\n nbInitRetains : BOOL; \/\/ initializing of retain variable\n bInCopyCode : BOOL; \/\/ instance is copied to copy code\n iCOMnum : INT; \/\/ additional input: number of the COM interface, that is to be observed\nEND_VAR Instanzierung des Funktionsbausteins serialdevice : com1: serialdevice(iCOMnum:=1);\ncom0: serialdevice(iCOMnum:=0); " }, 
{ "title" : "Schnittstelle der Methode FB_Reinit ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_32c7a9d6655911e799f4cbb808a4a9d0", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Methode: FB_Init , FB_Reinit , FB_Exit \/ Schnittstelle der Methode FB_Reinit ", 
"snippet" : "METHOD FB_Reinit : BOOL...", 
"body" : "METHOD FB_Reinit : BOOL " }, 
{ "title" : "Schnittstelle der Methode FB_Exit ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_12190eb0ce4c52dbc0a864635e0a9fea", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Methode: FB_Init , FB_Reinit , FB_Exit \/ Schnittstelle der Methode FB_Exit ", 
"snippet" : "Es gibt es den obligatorischen Parameter bInCopyCode . METHOD FB_Exit : BOOL VAR_INPUT bInCopyCode : BOOL; \/\/ TRUE: the exit method is called in order to leave the instance which will be copied afterwards (online change). END_VAR...", 
"body" : "Es gibt es den obligatorischen Parameter bInCopyCode . METHOD FB_Exit : BOOL\nVAR_INPUT\n bInCopyCode : BOOL; \/\/ TRUE: the exit method is called in order to leave the instance which will be copied afterwards (online change).\nEND_VAR " }, 
{ "title" : "Verhalten bei abgeleiteten Funktionsbausteinen ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_b9d7fa100be0aaf3c0a864636c5fb2da", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Methode: FB_Init , FB_Reinit , FB_Exit \/ Verhalten bei abgeleiteten Funktionsbausteinen ", 
"snippet" : "Wenn ein Funktionsbaustein von einem anderen Funktionsbaustein abgeleitet ist, muss die FB_Init -Methode des abgeleiteten Funktionsbausteins dieselben Parameter definieren wie die FB_Init -Methode des Basisfunktionsbausteins. Sie können jedoch weitere Parameter hinzufügen, um für die Instanz eine sp...", 
"body" : "Wenn ein Funktionsbaustein von einem anderen Funktionsbaustein abgeleitet ist, muss die FB_Init -Methode des abgeleiteten Funktionsbausteins dieselben Parameter definieren wie die FB_Init -Methode des Basisfunktionsbausteins. Sie können jedoch weitere Parameter hinzufügen, um für die Instanz eine spezielle Initialisierung einzurichten. Beispiel Die Funktionsbausteine MainFB , SubFB und SubSubFB leiten voneinander ab. Dabei gilt: SubFB EXTENDS MainFB und SubSubFB EXTENDS SubFB . Aufrufabfolge der Methoden FB_Exit und FB_Init : fbSubSubFb.FB_Exit(...); fbSubFb.FB_Exit(...); fbMainFb.FB_Exit(...); fbMainFb.FB_Init(...); fbSubFb.FB_Init(...); fbSubSubFb.FB_Init(...); " }, 
{ "title" : "Global Init Slots ", 
"url" : "_cds_global_init_slots.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Global Init Slots ", 
"snippet" : "Slot Plugin \/ Bibliothek POU Beschreibung 123 GVLObject __var_persistent_write Kopieren persistenter Variablen aus der persistenten Liste in gemappte Instanzpfade 199 Compiler __var__retain__read__ Kopieren von Retain-Variablen aus dem Retain-Bereich in die Instanzpfade (nur bei Target-Setting retai...", 
"body" : "Slot Plugin \/ Bibliothek POU Beschreibung 123 GVLObject __var_persistent_write Kopieren persistenter Variablen aus der persistenten Liste in gemappte Instanzpfade 199 Compiler __var__retain__read__ Kopieren von Retain-Variablen aus dem Retain-Bereich in die Instanzpfade (nur bei Target-Setting retain-in-cycle-code ) 200 LanguageModelManager __ValidateLicenseMetrics Senden von AppBasedLicenseMetrics an das Laufzeitsystem des Geräts 500 VisualObject Visu__VisualManager__AfterInitProgram Initialisierung der Visualisierung (Aufruf aller mit Called within Visu-Initialization gekennzeichneten Initialisierungen) 500 VisualObject __datasourcesFrameVisualCallTree Interaktion von Visualisierungen mit Datenquellen 600 DataSourcesObject __datasourcesUpdateByDefaultCall Initialisierung von Datenquellen 600 DataSourcesObject __datasourcesUpdateByDefaultGVL Initialisierung von Datenquellen 1000 DeviceObject IoGlobalInit__Pou Initialisierung von Geräteobjektinstanzen 1000 Bibliothek Datasource ApplicationV3 Access Logger Initialisierung der Protokollierung für diese Bibliothek 1000 Bibliothek Datasource Symbolic Access Logger Initialisierung der Protokollierung für diese Bibliothek 1000 Bibliothek Datasources Logger Initialisierung der Protokollierung für diese Bibliothek 1234 ApplicationComposer AC_Init Initialisierung der erzeugten POU 1234 ApplicationComposer AC_OnlineChange Erneute Initialisierung der vom Application Composer erzeugten Strukturen\/FBs 10000 Bibliothek Datasource Symbolic Access GVL_EarlyInit Initialisierung der symbolischen Datenquelle 20000 Bibliothek Alarm Manager AlarmConstants Initialisierung des Alarm-Handling 24000 Bibliothek VisuElemBase Private_Visu_Globals Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu 24000 Bibliothek VisuElemBase GVL_NativeElement Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu 24000 Bibliothek VisuElemBase GVL_TypeInformation Initialisierung der Visualisierung 24000 Bibliothek Visu Interfaces GVL Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu 25000 Bibliothek VisuElemBase GVL_CommandManager Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu 25000 Bibliothek VisuElemBase Visu_Globals Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu 25000 Bibliothek VisuCommandInterface GVL Initialisierung der Visualisierung 25000 Bibliothek RecipeManagement GVL_RecipeManagement_Temp Initialisierung der Visualisierung 25990 Bibliothek VisuElemBase VisuFctDatasourcesResourceEntryAllocatorGet_MBM Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu 25990 Bibliothek VisuElemBase VisuFctDatasourcesResourceEntryAllocatorGet_SysMem Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu 26000 Bibliothek VisuElemBase Visu_Resources Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu 30000 Bibliothek Alarm Manager AlarmGlobals Initialisierung der Alarmverarbeitung 30000 Bibliothek Alarm Manager GloballyForAlarmStorage Initialisierung der Alarmverarbeitung (Teile, die nach _3SStorage initialisiert werden müssen) 30000 Bibliothek VisuFPlot GlobalInstances Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu 30000 Bibliothek VisuTrendStorageAccess GlobalInstances Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu 39900 DeviceObject IoConfig_Globals_ModuleList Die Modulliste aller Konnektoren von allen Geräten (Feldbus-Slaves, SoftMotion-Achsen, ...) 40000 DeviceObject IoConfig_Globals_Mapping Die gemappten neuen Variablen von allen Geräten (Feldbus-Slaves, SoftMotion-Achsen, ...) 40000 TrendRecordingObject __GVL__TrendRecordingManager Initialisierung der Trendaufzeichnung 40100 DeviceObject IoConfig_Forces_Reset Die Force-Variablen für das Mapping, wenn die Option Force-Variablen für das E\/A-Abbild erzeugen gesetzt ist 49980 Compiler Alle VAR_STAT Initialisiert alle in VAR_STAT deklarierten Variablen 49985 Compiler __MemManDefinition Die GVL für die dynamische Speicherverwaltung muss vor den \"normalen\" GVLs initialisiert werden, um sicherzustellen, dass sich die \"normalen\" GVLs auf eine bereits initialisierte dynamische Speicherverwaltung verlassen können. 49990 Compiler Alle GVLs Standardwert für alle GVLs (globale Variablenlisten) 50000 Compiler Standard-Slot Standard-Slot für alle POUs (Programme, Funktionsbausteine) 50000 VisualObject Visu__VisualManager__GVL__0 Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu_generated 50500 VisualObject __VisuInitInstantiation_GVL Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu_generated 51000 VisualObject Visu__VisualManager__CommonGVL Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu_generated 55000 VisualObject Visu__VisualManager__GVL__2 Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu_generated 56000 VisualObject __NativeElementUserDefTypesCall Initialisierung der Visualisierung (Typinformationen für HTML5-Steuerelemente) 56000 VisualObject __NativeElementUserDefTypesGVL Initialisierung der Visualisierung (Typinformationen für HTML5-Steuerelemente) 56000 DataSourcesObject __providerSymbolsCall Initialisierung der Datenquellen 56000 DataSourcesObject __providerSymbolsGVL Initialisierung der Datenquellen 56000 DataSourcesObject __datasourcesSymbolsCall Initialisierung der Datenquellen 56000 DataSourcesObject __datasourcesSymbolsGVL Initialisierung der Datenquellen 56500 DataSourcesObject __GVL_Datasources_Constants Initialisierung der Datenquellen 57000 DataSourcesObject __datasourcesInstancesCall Initialisierung der Datenquellen 57000 DataSourcesObject __datasourcesInstancesGVL Initialisierung der Datenquellen 58000 DataSourcesObject __GVL_Datasources Initialisierung der Datenquellen 60000 DeviceObject IoConfig_Globals Die Funktionsbausteininstanzen aller Geräte (Feldbus-Slaves, SoftMotion-Achsen, ...) 60000 TrendRecordingObject __GVL__TrendRecording__ + _metaObject.Name Initialisierung der Trendaufzechnung 60100 DeviceObject IoConfigRemote_Globals Gemappte Variablen für den Safety-SIL3-Kontext 70000 Bibliothek VisuElemBase Private_Visu_Globals_LateInit Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu_late 70000 Bibliothek Visu Utils PublicVariables Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu_late 70000 Bibliothek Visu Utils Variablen Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu_late 123456 UnitConversionObject \"__\" + _metaObject.Name + \"_InitPrg Interaktion mit Datenquellen 150000 Bibliothek VisuDialogs Dialog_Variables Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu 150000 Bibliothek VisuDialogs Dialog_Variables_Exp Initialisierung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu 150000 RecipeManObject GVL_RecipeManagement_3300 Initialisierung der Rezepturen 150000 RecipeManObject GVL_RecipeManagement Initialisierung der Rezepturen 151000 RecipeManObject RecipeManagementInitAfterGlobalInit Initialisierung der Rezepturen call_after_online_change_concurrent_slot 1000 200000 Bibliothek VisuElemBase GVL_ShutdownCheck Initialisierung \/ Abschaltung der Visualisierung Aufgerufen innerhalb der Visu-Initialisierung visu " }, 
{ "title" : "Fehlermeldungen und Warnungen ", 
"url" : "_cds_struct_reference_errors.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Compilerfehler C0001 ", 
"url" : "_cds_error_c0001.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0001 ", 
"snippet" : "C0001 Meldung : Konstante ‚<constant value>‘ zu groß für Typ ‚<data type>‘ Mögliche Fehlerursache : Eine getypte Konstante ist zu groß für den angegebenen Datentyp oder eine Konstante ist zu groß für jeden möglichen Datentyp. Fehlerbehebung : Verwenden Sie kleinere Konstanten oder einen passenden Da...", 
"body" : "C0001 Meldung : Konstante ‚<constant value>‘ zu groß für Typ ‚<data type>‘ Mögliche Fehlerursache : Eine getypte Konstante ist zu groß für den angegebenen Datentyp oder eine Konstante ist zu groß für jeden möglichen Datentyp. Fehlerbehebung : Verwenden Sie kleinere Konstanten oder einen passenden Datentyp für eine getypte Konstante. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n test1: INT;\n test2: INT;\n test3: LREAL;\nEND_VAR\n\ntest1 := 12345678912345566991923939292939911;\ntest2 := INT#123456;\ntest3 := 10E500;\n Meldung: C0001: Konstante '12345678912345566991923939292939911' ist zu groß für Typ 'ANY_INT' C0001: Konstante 'INT#123456' ist zu groß für Typ 'INT' C0001: Konstante '10E500' ist zu groß für Typ 'ANY_REAL' " }, 
{ "title" : "Compilerfehler C0002 ", 
"url" : "_cds_error_c0002.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0002 ", 
"snippet" : "C0002 Meldung : ‚<operator 1>‘ oder ‚<operator 2>‘ anstelle von ‚<tag>‘ erwartet Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Verwenden Sie die korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG Fun(1; Meldung: C0002: ',' oder ')' an Stelle von ';' erwartet...", 
"body" : "C0002 Meldung : ‚<operator 1>‘ oder ‚<operator 2>‘ anstelle von ‚<tag>‘ erwartet Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Verwenden Sie die korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG\nFun(1;\n Meldung: C0002: ',' oder ')' an Stelle von ';' erwartet " }, 
{ "title" : "Compilerfehler C0003 ", 
"url" : "_cds_error_c0003.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0003 ", 
"snippet" : "C0003 Meldung : ‚<value>‘ ist keine gültige Bit-Nummer für ‚<variable>‘ Mögliche Fehlerursache : Es wird versucht auf ein Bit zuzugreifen, dass außerhalb des Bereichs für einen Datentyp liegt. Fehlerbehebung : Verwenden Sie für den Bitzugriff einen Bitwert, der kleiner ist als die Anzahl der Bits im...", 
"body" : "C0003 Meldung : ‚<value>‘ ist keine gültige Bit-Nummer für ‚<variable>‘ Mögliche Fehlerursache : Es wird versucht auf ein Bit zuzugreifen, dass außerhalb des Bereichs für einen Datentyp liegt. Fehlerbehebung : Verwenden Sie für den Bitzugriff einen Bitwert, der kleiner ist als die Anzahl der Bits im Datentyp der Variable. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n test1: WORD;\n test2: BOOL;\nEND_VAR\n\ntest1 := test2.17;\n Meldung: C0003: '17' ist keine gültige Bit-Nummer für 'w' " }, 
{ "title" : "Compilerfehler C0004 ", 
"url" : "_cds_error_c0004.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0004 ", 
"snippet" : "C0004 Meldung : ‚<variable>‘ ist keine Komponente von ‚<structure>‘ Mögliche Fehlerursache : Komponentenzugriff mit „.“ auf eine Variable, die kein strukturierter Wert ist oder nicht als Komponente der Struktur existiert. Fehlerbehebung : Greifen Sie auf eine definierte Komponente zu, oder ändern Si...", 
"body" : "C0004 Meldung : ‚<variable>‘ ist keine Komponente von ‚<structure>‘ Mögliche Fehlerursache : Komponentenzugriff mit „.“ auf eine Variable, die kein strukturierter Wert ist oder nicht als Komponente der Struktur existiert. Fehlerbehebung : Greifen Sie auf eine definierte Komponente zu, oder ändern Sie die Definition im Datentyp auf den zugegriffen wird. Die Eingabeunterstützung „Komponenten auflisten“ bietet Ihnen alle gültigen Zugriffe an dieser Position an. Beispiel für den Fehler: TYPE DUT:\nSTRUCT\n x, y : INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n test1 : DUT;\n test2 : INT;\nEND_VAR\n\ntest2 := test1.z;\n Meldung: C0032: Typ 'Unbekannter Typ: 'test1.z' kann nicht in Typ 'INT' konvertiert werden C0032: Typ 'Unbekannter Typ: 'test1.z' kann nicht in Typ 'INT' konvertiert werden " }, 
{ "title" : "Compilerfehler C0005 ", 
"url" : "_cds_error_c0005.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0005 ", 
"snippet" : "C0005 Meldung : Konstantenüberlauf in Adresse ‚<address>‘ Mögliche Fehlerursache : Mindestens eine Komponente in der Adresse passt nicht in einen 32-Bit-Integer-Wert. Fehlerbehebung : Verwenden Sie einen gültigen Adressausdruck. Beispiel für den Fehler: PROGRAM PLC_PRG VAR X: BYTE; END_VAR X := %QB5...", 
"body" : "C0005 Meldung : Konstantenüberlauf in Adresse ‚<address>‘ Mögliche Fehlerursache : Mindestens eine Komponente in der Adresse passt nicht in einen 32-Bit-Integer-Wert. Fehlerbehebung : Verwenden Sie einen gültigen Adressausdruck. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n X: BYTE;\nEND_VAR\n\nX := %QB5555555555;\n Meldung : C0005: Konstantenüberlauf in Adresse '%??' " }, 
{ "title" : "Compilerfehler C0006 ", 
"url" : "_cds_error_c0006.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0006 ", 
"snippet" : "C0006 Meldung : ‚<operator>‘ an Stelle von ‚<token>‘ erwartet Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Verwenden Sie die korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG VAR x: INT; bTest : BOOL; END_VAR IF bTest x := 9; END_IF Meldung: C0006: 'THEN' an Stelle von 'x' erwartet...", 
"body" : "C0006 Meldung : ‚<operator>‘ an Stelle von ‚<token>‘ erwartet Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Verwenden Sie die korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n x: INT;\n bTest : BOOL;\nEND_VAR\n\nIF bTest\n x := 9;\nEND_IF\n Meldung: C0006: 'THEN' an Stelle von 'x' erwartet " }, 
{ "title" : "Compilerfehler C0007 ", 
"url" : "_cds_error_c0007.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0007 ", 
"snippet" : "C0007 Meldung : Ausdruck an Stelle von ‚<token>‘ erwartet Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Verwenden Sie die korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG VAR x: INT; bTest : BOOL; END_VAR IF THEN x := 9; END_IF Meldung: C0007: Ausdruck an Stelle von 'THEN' erwartet...", 
"body" : "C0007 Meldung : Ausdruck an Stelle von ‚<token>‘ erwartet Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Verwenden Sie die korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n x: INT;\n bTest : BOOL;\nEND_VAR\n\nIF THEN\n x := 9;\nEND_IF\n Meldung: C0007: Ausdruck an Stelle von 'THEN' erwartet " }, 
{ "title" : "Compilerfehler C0008 ", 
"url" : "_cds_error_c0008.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0008 ", 
"snippet" : "C0008 Meldung : Unerwartetes End-of-file gefunden: ‚<operator 1>‘, ‚<operator 2>‘ oder ‚<operator 3>‘ erwartet Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Verwenden Sie die korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG VAR x: INT; bTest : BOOL; END_VAR IF bTest THEN x := 9; Me...", 
"body" : "C0008 Meldung : Unerwartetes End-of-file gefunden: ‚<operator 1>‘, ‚<operator 2>‘ oder ‚<operator 3>‘ erwartet Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Verwenden Sie die korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n x: INT;\n bTest : BOOL;\nEND_VAR\n\nIF bTest THEN\n x := 9;\n Meldung: C0008: Unerwartetes End-of-file gefunden: 'ELSIF', 'ELSE' oder 'END_IF' erwartet " }, 
{ "title" : "Compilerfehler C0009 ", 
"url" : "_cds_error_c0009.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0009 ", 
"snippet" : "C0009 Meldung : Unerwartetes Token ‚<token>‘ gefunden Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Verwenden Sie die korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG VAR END_VAR END_FOR; Meldung: C0009: Unerwartetes Token 'END_FOR' gefunden...", 
"body" : "C0009 Meldung : Unerwartetes Token ‚<token>‘ gefunden Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Verwenden Sie die korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nEND_FOR;\n Meldung: C0009: Unerwartetes Token 'END_FOR' gefunden " }, 
{ "title" : "Compilerfehler C0010 ", 
"url" : "_cds_error_c0010.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0010 ", 
"snippet" : "C0010 Meldung : Unerwartetes End-of-file gefunden: ‚<token>‘ erwartet Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Verwenden Sie die korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i: INT; END_VAR FOR i := 0 TO 2 DO ; Meldung: C0010: Unerwartetes End-of-file gefunden: 'END_FO...", 
"body" : "C0010 Meldung : Unerwartetes End-of-file gefunden: ‚<token>‘ erwartet Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Verwenden Sie die korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i: INT;\nEND_VAR\n\nFOR i := 0 TO 2 DO\n;\n Meldung: C0010: Unerwartetes End-of-file gefunden: 'END_FOR' erwartet " }, 
{ "title" : "Compilerfehler C0011 ", 
"url" : "_cds_error_c0011.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0011 ", 
"snippet" : "C0011 Meldung : Keine ‚CASE‘-Marke gefunden Mögliche Fehlerursache : Syntaxfehler in einem CASE-Statement. Ein Statement innerhalb einer CASE-Anweisung ist keiner CASE-Marke zugeordnet. Fehlerbehebung : Fügen Sie eine CASE-Marke ein. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i: INT; x: INT; END_V...", 
"body" : "C0011 Meldung : Keine ‚CASE‘-Marke gefunden Mögliche Fehlerursache : Syntaxfehler in einem CASE-Statement. Ein Statement innerhalb einer CASE-Anweisung ist keiner CASE-Marke zugeordnet. Fehlerbehebung : Fügen Sie eine CASE-Marke ein. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i: INT;\n x: INT;\nEND_VAR\n\nCASE i OF\n x := 9;\nEND_CASE\n Meldung: C0011: Keine 'CASE'-Marke gefunden Fehlerbehebung: CASE i OF\n0:\n x := 9;\nEND_CASE " }, 
{ "title" : "Compilerfehler C0013 ", 
"url" : "_cds_error_c0013.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0013 ", 
"snippet" : "C0013 Meldung : Es wird wenigstens eine Anweisung erwartet Mögliche Fehlerursache : An einigen Stellen im Code wird mindestens eine Anweisung erwartet. Beispielsweise im THEN und im ELSE-Teil einer IF-Anweisung oder im Rumpf einer FOR-Schleife. Fehlerbehebung : Fügen Sie mindestens eine Anweisung an...", 
"body" : "C0013 Meldung : Es wird wenigstens eine Anweisung erwartet Mögliche Fehlerursache : An einigen Stellen im Code wird mindestens eine Anweisung erwartet. Beispielsweise im THEN und im ELSE-Teil einer IF-Anweisung oder im Rumpf einer FOR-Schleife. Fehlerbehebung : Fügen Sie mindestens eine Anweisung an der ausgewiesenen Position ein. Es genügt auch die leere Anweisung „;“. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n bTest: BOOL;\nEND_VAR\n\nIF bTest THEN\nEND_IF\n Meldung: C0013: Es wird wenigstens eine Anweisung erwartet " }, 
{ "title" : "Compilerfehler C0015 ", 
"url" : "_cds_error_c0015.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0015 ", 
"snippet" : "C0015 Meldung : Zählvariableninitialisierung erwartet Mögliche Fehlerursache : Syntaxfehler in einer FOR-Schleife. Die Zählvariable wird nicht korrekt initialisiert. Fehlerbehebung : Beachten Sie die korrekte Syntax der FOR-Schleife. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i: INT; END_VAR FOR i...", 
"body" : "C0015 Meldung : Zählvariableninitialisierung erwartet Mögliche Fehlerursache : Syntaxfehler in einer FOR-Schleife. Die Zählvariable wird nicht korrekt initialisiert. Fehlerbehebung : Beachten Sie die korrekte Syntax der FOR-Schleife. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i: INT;\nEND_VAR\n\nFOR i TO 10 DO\n ;\nEND_FOR\n\n--> C0015: Zählvariableninitialisierung erwartet Meldung: C0015: Zählvariableninitialisierung erwartet Fehlerbehebung: FOR i := 0 TO 10 DO\n ;\nEND_FOR " }, 
{ "title" : "Compilerfehler C0018 ", 
"url" : "_cds_error_c0018.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0018 ", 
"snippet" : "C0018 Meldung : <expression> ist kein gültiges Zuweisungsziel Mögliche Fehlerursache : Auf der linken Seite einer Zuweisung steht ein Ausdruck, für den kein Schreibrecht besteht. Zum Beispiel eine Konstante. Fehlerbehebung : Weisen Sie nur auf Variablen Werte zu, auf die auch ein Schreibzugriff best...", 
"body" : "C0018 Meldung : <expression> ist kein gültiges Zuweisungsziel Mögliche Fehlerursache : Auf der linken Seite einer Zuweisung steht ein Ausdruck, für den kein Schreibrecht besteht. Zum Beispiel eine Konstante. Fehlerbehebung : Weisen Sie nur auf Variablen Werte zu, auf die auch ein Schreibzugriff besteht. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i: INT;\nEND_VAR\nVAR CONSTANT\n j: INT := 0;\nEND_VAR\n\nj := i;\n Meldung: C0018: 'j' ist kein gültiges Zuweisungsziel " }, 
{ "title" : "Compilerfehler C0020 ", 
"url" : "_cds_error_c0020.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0020 ", 
"snippet" : "C0020 Meldung : ‚<statement>‘ ist keine gültige Anweisung Mögliche Fehlerursache : Syntaxfehler: Beispielsweise ein Zeichen vergessen oder ein Zeichen zu viel Fehlerbehebung : Achten Sie auf eine syntaktisch korrekte Schreibweise. Beispiel für den Fehler: PROGRAM PLC_PRG VAR x : INT; END_VAR x = 2; ...", 
"body" : "C0020 Meldung : ‚<statement>‘ ist keine gültige Anweisung Mögliche Fehlerursache : Syntaxfehler: Beispielsweise ein Zeichen vergessen oder ein Zeichen zu viel Fehlerbehebung : Achten Sie auf eine syntaktisch korrekte Schreibweise. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n x : INT;\nEND_VAR\n\nx = 2;\n Meldung: C0020: '(x = 2); ' ist keine gültige Anweisung Fehlerbehebung: x := 2; " }, 
{ "title" : "Compilerfehler C0022 ", 
"url" : "_cds_error_c0022.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0022 ", 
"snippet" : "C0022 Meldung : ‚<operator>‘ benötigt genau ‚<number of operands>‘ Operanden Mögliche Fehlerursache : Einem Operator werden zu viele oder zu wenige Operanden zugewiesen. Fehlerbehebung : Weisen Sie dem Operator die benötigte Anzahl an Operanden zu. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i : IN...", 
"body" : "C0022 Meldung : ‚<operator>‘ benötigt genau ‚<number of operands>‘ Operanden Mögliche Fehlerursache : Einem Operator werden zu viele oder zu wenige Operanden zugewiesen. Fehlerbehebung : Weisen Sie dem Operator die benötigte Anzahl an Operanden zu. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\n pt: POINTER TO INT;\nEND_VAR\n\npt := ADR(i,1);\n Meldung: C0022: 'ADR' benötigt genau '1' Operanden Fehlerbehebung: pt := ADR(i); " }, 
{ "title" : "Compilerfehler C0023 ", 
"url" : "_cds_error_c0023.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0023 ", 
"snippet" : "C0023 Meldung : ‚<operator>‘ benötigt wenigstens ‚<number of operands>‘ Operanden Mögliche Fehlerursache : Einem Operator werden zu wenige Operanden zugewiesen. Fehlerbehebung : Weisen Sie dem Operanden die benötigte Anzahl an Operanden zu. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i : INT; END_V...", 
"body" : "C0023 Meldung : ‚<operator>‘ benötigt wenigstens ‚<number of operands>‘ Operanden Mögliche Fehlerursache : Einem Operator werden zu wenige Operanden zugewiesen. Fehlerbehebung : Weisen Sie dem Operanden die benötigte Anzahl an Operanden zu. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\n\ni := MUX(30,40);\n Meldung: C0023: 'MUX' benötigt wenigstens '3' Operanden Fehlerbehebung: i := MUX(30,40,50); " }, 
{ "title" : "Compilerfehler C0026 ", 
"url" : "_cds_error_c0026.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0026 ", 
"snippet" : "C0026 Meldung : Bezeichner an Stelle von ‚<invalid identifier>‘ erwartet Mögliche Fehlerursache : Einer Methode wird ein ungültiger Bezeichner gegeben. Fehlerbehebung : Verwenden Sie gültige Bezeichner. Beispiel für den Fehler: METHOD 123 VAR_INPUT END_VAR Meldung: C0243: Der in der Schnittstelle ve...", 
"body" : "C0026 Meldung : Bezeichner an Stelle von ‚<invalid identifier>‘ erwartet Mögliche Fehlerursache : Einer Methode wird ein ungültiger Bezeichner gegeben. Fehlerbehebung : Verwenden Sie gültige Bezeichner. Beispiel für den Fehler: METHOD 123\nVAR_INPUT\nEND_VAR\n Meldung: C0243: Der in der Schnittstelle verwendete Name ist nicht identisch mit dem Objektnamen C0026: Bezeichner an Stelle von '123' erwartet Fehlerbehebung: METHOD METH123 " }, 
{ "title" : "Compilerfehler C0027 ", 
"url" : "_cds_error_c0027.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0027 ", 
"snippet" : "C0027 Meldung : Länge der Zeichenkette erwartet nach ‚(‚ Mögliche Fehlerursache : Länge der Zeichenkette wird nicht angegeben. Fehlerbehebung : Geben Sie eine Zeichenlänge innerhalb der Klammern an. Beispiel für den Fehler: PROGRAM PLC_PRG VAR str : STRING(); END_VAR Meldung: C0027: Länge der Zeiche...", 
"body" : "C0027 Meldung : Länge der Zeichenkette erwartet nach ‚(‚ Mögliche Fehlerursache : Länge der Zeichenkette wird nicht angegeben. Fehlerbehebung : Geben Sie eine Zeichenlänge innerhalb der Klammern an. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n str : STRING();\nEND_VAR\n Meldung: C0027: Länge der Zeichenkette erwartet nach '(' C0006: ';, :=, REF=, ( oder [' an Stelle von ')' erwartet Fehlerbehebung: str : STRING(100); " }, 
{ "title" : "Compilerfehler C0030 ", 
"url" : "_cds_error_c0030.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0030 ", 
"snippet" : "C0030 Meldung : Direkte Adresse nach ‚AT‘ an Stelle von ‚<identifier>‘ erwartet Mögliche Fehlerursache : Nach ‚AT‘ wird keine oder eine ungültige Adresse zugewiesen. Fehlerbehebung : Geben Sie eine gültige Adresse an. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i AT ABC : INT; END_VAR Meldung: C003...", 
"body" : "C0030 Meldung : Direkte Adresse nach ‚AT‘ an Stelle von ‚<identifier>‘ erwartet Mögliche Fehlerursache : Nach ‚AT‘ wird keine oder eine ungültige Adresse zugewiesen. Fehlerbehebung : Geben Sie eine gültige Adresse an. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i AT ABC : INT;\nEND_VAR\n Meldung: C0030: Direkte Adresse nach 'AT' an Stelle von 'ABC' erwartet Fehlerbehebung: i AT %IW0 : INT; " }, 
{ "title" : "Compilerfehler C0031 ", 
"url" : "_cds_error_c0031.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0031 ", 
"snippet" : "C0031 Meldung : Typdefinition an Stelle von ‚<no data type>‘ erwartet Mögliche Fehlerursache : Dem Bezeichner wird eine ungültige Typdefinition zugewiesen. Fehlerbehebung : Geben Sie eine gültige Typdefinition an. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i : 0; END_VAR Meldung: C0031: Typdefinit...", 
"body" : "C0031 Meldung : Typdefinition an Stelle von ‚<no data type>‘ erwartet Mögliche Fehlerursache : Dem Bezeichner wird eine ungültige Typdefinition zugewiesen. Fehlerbehebung : Geben Sie eine gültige Typdefinition an. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : 0;\nEND_VAR\n Meldung: C0031: Typdefinition an Stelle von '0' erwartet Fehlerbehebung: i : INT; " }, 
{ "title" : "Compilerfehler C0032 ", 
"url" : "_cds_error_c0032.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0032 ", 
"snippet" : "C0032 Meldung : Typ ‚<type 1>‘ kann nicht in Typ ‚<type 2>‘ konvertiert werden Mögliche Fehlerursache : Eine Variable wird einer anderen Variable mit inkompatiblem Typ zugewiesen. Fehlerbehebung : Verwenden Sie eine Typkonvertierung. Beispiel für den Fehler: PROGRAM PLC_PRG VAR test1: INT; test2: ST...", 
"body" : "C0032 Meldung : Typ ‚<type 1>‘ kann nicht in Typ ‚<type 2>‘ konvertiert werden Mögliche Fehlerursache : Eine Variable wird einer anderen Variable mit inkompatiblem Typ zugewiesen. Fehlerbehebung : Verwenden Sie eine Typkonvertierung. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n test1: INT;\n test2: STRING;\nEND_VAR\n\ntest1 := test2;\n Meldung: C0032: Typ 'STRING' kann nicht in Typ 'INT' konvertiert werden Fehlerbehebung: test1 := TO_INT(test2); " }, 
{ "title" : "Compilerwarnung C0033 ", 
"url" : "_cds_error_c0033.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0033 ", 
"snippet" : "C0033 Meldung : Typ ‚<pointer type>“ ist möglicherweise nicht in Typ ‚<data type>‘ konvertierbar. Mögliche Fehlerursache : Dieser Fehler tritt nur beim Prüfen von Poolobjekten auf. Es wurde versucht einen Pointer in eine Ganzzahl umzuwandeln. Da die Größe von Pointern in einer Bibliothek nicht bekan...", 
"body" : "C0033 Meldung : Typ ‚<pointer type>“ ist möglicherweise nicht in Typ ‚<data type>‘ konvertierbar. Mögliche Fehlerursache : Dieser Fehler tritt nur beim Prüfen von Poolobjekten auf. Es wurde versucht einen Pointer in eine Ganzzahl umzuwandeln. Da die Größe von Pointern in einer Bibliothek nicht bekannt ist, können beim Verwenden der Bibliothek Fehler auftreten. Fehlerbehebung : Verwenden Sie für plattformunabhängige Berechnungen mit Pointern den Typ __UXINT oder __XWORD . Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n ptr : POINTER TO INT;\n dw : DWORD;\nEND_VAR\n dw := ptr;\n Meldung: C0033: Typ ‚POINTER TO INT‘ ist möglicherweise nicht in Typ ‚DWORD‘ konvertierbar. " }, 
{ "title" : "Compilerfehler C0035 ", 
"url" : "_cds_error_c0035.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0035 ", 
"snippet" : "C0035 Meldung : Programmname, Funktion oder Funktionsbausteininstanz an Stelle von ‚<invalid function>‘ erwartet Mögliche Fehlerursache : Es wird eine Funktion aufgerufen, die nicht existiert. Fehlerbehebung : Achten Sie darauf nur Programmnamen, Funktionen oder Funktionsbausteinstanzen aufzurufen, ...", 
"body" : "C0035 Meldung : Programmname, Funktion oder Funktionsbausteininstanz an Stelle von ‚<invalid function>‘ erwartet Mögliche Fehlerursache : Es wird eine Funktion aufgerufen, die nicht existiert. Fehlerbehebung : Achten Sie darauf nur Programmnamen, Funktionen oder Funktionsbausteinstanzen aufzurufen, die existieren. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nPLC_PRG.METH1();\n\nMETHOD METH\nVAR_INPUT\nEND_VAR\n Meldung: C0004: 'METH1' ist keine Komponente von 'PLC_PRG' C0035: Programmname, Funktion oder Funktionsbausteininstanz an Stelle von 'PLC_PRG.METH1' erwartet Fehlerbehebung: PLC_PRG.METH(); " }, 
{ "title" : "Compilerfehler C0036 ", 
"url" : "_cds_error_c0036.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0036 ", 
"snippet" : "C0036 Meldung : Objekt vom Typ <type> kann nicht aufgerufen werden Mögliche Fehlerursache : Es wurde versucht ein Objekt aufzurufen, das keine Aufrufe unterstützt. Fehlerbehebung : Nur Funktionen, Funktionsbausteine, Programme, Methoden und Aktionen können aufgerufen werden. Beispiel für den Fehler:...", 
"body" : "C0036 Meldung : Objekt vom Typ <type> kann nicht aufgerufen werden Mögliche Fehlerursache : Es wurde versucht ein Objekt aufzurufen, das keine Aufrufe unterstützt. Fehlerbehebung : Nur Funktionen, Funktionsbausteine, Programme, Methoden und Aktionen können aufgerufen werden. Beispiel für den Fehler: VAR_GLOBAL GVL\n value : INT;\nEND_VAR\nPROGRAM PLC_PRG\nGVL();\n Meldung: C0036: Objekt vom Typ ‚VAR_GLOBAL‘ kann nicht aufgerufen werden. " }, 
{ "title" : "Compilerfehler C0037 ", 
"url" : "_cds_error_c0037.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0037 ", 
"snippet" : "C0037 Meldung : ‚<invalid input>‘ ist kein Eingang von ‚<function name>‘ Mögliche Fehlerursache : Beim Funktionsaufruf wird eine lokale Variable definiert. Fehlerbehebung : Deklarieren Sie die Variable als Input-Parameter. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i : INT; END_VAR i := TEST(iVar ...", 
"body" : "C0037 Meldung : ‚<invalid input>‘ ist kein Eingang von ‚<function name>‘ Mögliche Fehlerursache : Beim Funktionsaufruf wird eine lokale Variable definiert. Fehlerbehebung : Deklarieren Sie die Variable als Input-Parameter. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\ni := TEST(iVar := 1);\n\nFUNCTION TEST : INT\nVAR\n iVar : INT;\nEND_VAR\n Meldung: C0037: 'iVar' ist kein Eingang von 'TEST' Fehlerbehebung: VAR_INPUT\n iVar : INT;\nEND_VAR " }, 
{ "title" : "Compilerfehler C0038 ", 
"url" : "_cds_error_c0038.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0038 ", 
"snippet" : "C0038 Meldung : ‚<invalid output>‘ ist kein Ausgang von ‚<function name>‘ Mögliche Fehlerursache : Beim Funktionsaufruf wird eine lokale Variable als Output behandelt. Fehlerbehebung : Deklarieren Sie die Variable als Output-Parameter Beispiel für den Fehler: PROGRAM PLC_PRG VAR i : INT; x : INT; EN...", 
"body" : "C0038 Meldung : ‚<invalid output>‘ ist kein Ausgang von ‚<function name>‘ Mögliche Fehlerursache : Beim Funktionsaufruf wird eine lokale Variable als Output behandelt. Fehlerbehebung : Deklarieren Sie die Variable als Output-Parameter Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\n x : INT;\nEND_VAR\ni := TEST(iVar => x);\n\nFUNCTION TEST : INT\nVAR\n iVar : INT;\nEND_VAR\n Meldung: C0038: 'iVar' ist kein Ausgang von 'TEST' Fehlerbehebung: VAR_OUTPUT\n iVar : INT;\nEND_VAR " }, 
{ "title" : "Compilerfehler C0039 ", 
"url" : "_cds_error_c0039.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0039 ", 
"snippet" : "C0039 Meldung : VAR_IN_OUT ‚<invalid variable>‘ muss in Aufruf von ‚<function block name>‘ zugewiesen werden Mögliche Fehlerursache : Einem Funktionsbaustein, der eine IN_OUT-Variable benötigt, wird eine solche Variable nicht übergeben. Fehlerbehebung : Weisen Sie die IN_OUT-Variable zu. Beispiel fü...", 
"body" : "C0039 Meldung : VAR_IN_OUT ‚<invalid variable>‘ muss in Aufruf von ‚<function block name>‘ zugewiesen werden Mögliche Fehlerursache : Einem Funktionsbaustein, der eine IN_OUT-Variable benötigt, wird eine solche Variable nicht übergeben. Fehlerbehebung : Weisen Sie die IN_OUT-Variable zu. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\ninst();\n\nFUNCTION_BLOCK FB\nVAR_IN_OUT\n inout : INT;\nEND_VAR\n Meldung: C0039: VAR_IN_OUT 'inout' muss in Aufruf von 'FB' zugewiesen werden Fehlerbehebung: inst(inout := i); " }, 
{ "title" : "Compilerfehler C0040 ", 
"url" : "_cds_error_c0040.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0040 ", 
"snippet" : "C0040 Meldung : Funktion ‚<function name>‘ benötigt genau ‚<number of inputs>‘ Eingänge Mögliche Fehlerursache : Der aufgerufenen Funktion werden zu viele oder zu wenige Parameter übergeben. Fehlerbehebung : Übergeben Sie der Funktion genauso viele Parameter, wie erwartet werden. Beispiel für den Fe...", 
"body" : "C0040 Meldung : Funktion ‚<function name>‘ benötigt genau ‚<number of inputs>‘ Eingänge Mögliche Fehlerursache : Der aufgerufenen Funktion werden zu viele oder zu wenige Parameter übergeben. Fehlerbehebung : Übergeben Sie der Funktion genauso viele Parameter, wie erwartet werden. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\ni := TEST(1,2);\n\n\nFUNCTION TEST : INT\nVAR_INPUT\n IN: INT;\nEND_VAR\n Meldung: C0040: Funktion 'TEST' benötigt genau '1' Eingänge Fehlerbehebung: i := Test(1); " }, 
{ "title" : "Compilerfehler C0041 ", 
"url" : "_cds_error_c0041.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0041 ", 
"snippet" : "C0041 Meldung : VAR_IN_OUT-Parameter ‚<parameter name>‘ von ‚<function name>‘ benötigt eine Variable mit Schreibzugriff als Eingang Mögliche Fehlerursache : Der übergebene Parameter ist keine Variable mit Schreibzugriff (sondern beispielsweise eine Konstante). Fehlerbehebung : Übergeben Sie der Funk...", 
"body" : "C0041 Meldung : VAR_IN_OUT-Parameter ‚<parameter name>‘ von ‚<function name>‘ benötigt eine Variable mit Schreibzugriff als Eingang Mögliche Fehlerursache : Der übergebene Parameter ist keine Variable mit Schreibzugriff (sondern beispielsweise eine Konstante). Fehlerbehebung : Übergeben Sie der Funktion einen VAR_IN_OUT-Parameter mit Schreibzugriff. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\n x : INT;\nEND_VAR\ni := Test(31415);\n\nFUNCTION TEST : INT\nVAR_IN_OUT\n in_out: INT;\nEND_VAR\n Meldung: C0041: VAR_IN_OUT'-Parameter 'in_out' von 'TEST' benötigt eine Variable mit Schreibzugriff als Eingang Fehlerbehebung: i := Test(x); " }, 
{ "title" : "Compilerfehler C0042 (Compiler Version <= 3.4.10) ", 
"url" : "_cds_error_c0042.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0042 (Compiler Version <= 3.4.10) ", 
"snippet" : "C0042 Meldung : In Funktionsaufrufen müssen alle oder kein Formalparameter explizit zugewiesen werden Mögliche Fehlerursache : Der Funktion werden die Parameter in falscher Reihenfolge explizit zugewiesen. Fehlerbehebung : Verwenden Sie einheitlich formale Parameter oder implizite Parameter. Beispie...", 
"body" : "C0042 Meldung : In Funktionsaufrufen müssen alle oder kein Formalparameter explizit zugewiesen werden Mögliche Fehlerursache : Der Funktion werden die Parameter in falscher Reihenfolge explizit zugewiesen. Fehlerbehebung : Verwenden Sie einheitlich formale Parameter oder implizite Parameter. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\n i := Test(iPar1:=2, 5);\n\nFUNCTION Test : INT\nVAR_INPUT\n iPar1 : INT;\n iPar2 : INT;\nEND_VAR\n Meldung: C0042: In Funktionsaufrufen müssen alle oder kein Formalparameter explizit zugewiesen werden " }, 
{ "title" : "Compilerfehler C0043 ", 
"url" : "_cds_error_c0043.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0043 ", 
"snippet" : "C0043 Meldung : Falscher formaler Parameter: ‚<parameter name>‘ an dieser Stelle erwartet Mögliche Fehlerursache : Der Funktion werden die Parameter in falscher Reihenfolge explizit zugewiesen. Fehlerbehebung : Geben Sie die Parameter in richtiger Reihenfolge an. Beispiel für den Fehler: PROGRAM PLC...", 
"body" : "C0043 Meldung : Falscher formaler Parameter: ‚<parameter name>‘ an dieser Stelle erwartet Mögliche Fehlerursache : Der Funktion werden die Parameter in falscher Reihenfolge explizit zugewiesen. Fehlerbehebung : Geben Sie die Parameter in richtiger Reihenfolge an. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\ni := Test(iPar2 := 2, 5);\n\n\nFUNCTION Test : INT\nVAR_INPUT\n iPar1 : INT;\n iPar2 : INT;\nEND_VAR\n Meldung: C0043: Falscher formaler Parameter: 'iPar1' an dieser Stelle erwartet C0412: Mehrfache Eingangszuweisungen für Parameter '' Fehlerbehebung : i := Test(5, iPar2 := 2); " }, 
{ "title" : "Compilerfehler C0044 ", 
"url" : "_cds_error_c0044.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0044 ", 
"snippet" : "C0044 Meldung : Eingangszuweisung für Parameter ‚<input variable name>‘ in Aufruf von ‚<function block name>‘ fehlt. Mögliche Fehlerursache : Es wird ein Parameter übergeben, obwohl keine Input-Variable deklariert ist. Fehlerbehebung : Deklarieren Sie eine Input-Variable. Beispiel für den Fehler: PR...", 
"body" : "C0044 Meldung : Eingangszuweisung für Parameter ‚<input variable name>‘ in Aufruf von ‚<function block name>‘ fehlt. Mögliche Fehlerursache : Es wird ein Parameter übergeben, obwohl keine Input-Variable deklariert ist. Fehlerbehebung : Deklarieren Sie eine Input-Variable. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\ninst(1);\n\n\nFUNCTION_BLOCK FB\nVAR_INPUT\n\nEND_VAR\n Meldung: C0044: Eingangszuweisung für Parameter '1' in Aufruf von 'FB' fehlt Fehlerbehebung: Beispiel:\nVAR_INPUT\n in : INT;\nEND_VAR " }, 
{ "title" : "Compilerfehler C0045 ", 
"url" : "_cds_error_c0045.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0045 ", 
"snippet" : "C0045 Meldung : Verwendung von ‚THIS‘ ist in diesem Zusammenhang nicht erlaubt Mögliche Fehlerursache : THIS kann nur in einer Methode, Aktion, Transition oder im Rumpf eines Funktionsblocks verwendet werden, um auf die aktuelle Instanz zu verweisen. An allen anderen Positionen kommt es zu dieser Fe...", 
"body" : "C0045 Meldung : Verwendung von ‚THIS‘ ist in diesem Zusammenhang nicht erlaubt Mögliche Fehlerursache : THIS kann nur in einer Methode, Aktion, Transition oder im Rumpf eines Funktionsblocks verwendet werden, um auf die aktuelle Instanz zu verweisen. An allen anderen Positionen kommt es zu dieser Fehlermeldung. Fehlerbehebung : Verwenden Sie THIS nur in erlaubtem Kontext. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n test1: INT;\nEND_VAR\n\nTHIS^.test1 := 19;\n Meldung: C0018: 'THIS^.test1' ist kein gültiges Zuweisungsziel C0062: 'THIS^' ist keine Strukturvariable Verwendung von 'THIS' ist in diesem Zusammenhang nicht erlaubt " }, 
{ "title" : "Compilerfehler C0046 ", 
"url" : "_cds_error_c0046.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0046 ", 
"snippet" : "C0046 Meldung : Bezeichner ‚<identifier name>‘ nicht definiert Mögliche Fehlerursache : Es wird ein Bezeichner verwendet, der nicht deklariert ist. Fehlerbehebung : Deklarieren Sie die Variablen, die Sie verwenden wollen. Beispiel für den Fehler: PROGRAM PLC_PRG VAR END_VAR i := 1; Meldung: C0018: '...", 
"body" : "C0046 Meldung : Bezeichner ‚<identifier name>‘ nicht definiert Mögliche Fehlerursache : Es wird ein Bezeichner verwendet, der nicht deklariert ist. Fehlerbehebung : Deklarieren Sie die Variablen, die Sie verwenden wollen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n\nEND_VAR\n\ni := 1;\n Meldung: C0018: 'i' ist kein gültiges Zuweisungsziel C0046: Bezeichner 'i' nicht definiert Fehlerbehebung: VAR\n i : INT;\nEND_VAR " }, 
{ "title" : "Compilerfehler C0047 ", 
"url" : "_cds_error_c0047.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0047 ", 
"snippet" : "C0047 Meldung : Indizierung mit ‚[]‘ kann nicht auf einen Ausdruck mit Typ ‚<data type>‘ angewendet werden Mögliche Fehlerursache : Es wird ein Datentyp mit ‚[]‘ indiziert, der kein Array ist. Fehlerbehebung : Indizieren Sie nur Datentypen mit ‚[]‘, wenn diese auch als Array deklariert sind. Beispie...", 
"body" : "C0047 Meldung : Indizierung mit ‚[]‘ kann nicht auf einen Ausdruck mit Typ ‚<data type>‘ angewendet werden Mögliche Fehlerursache : Es wird ein Datentyp mit ‚[]‘ indiziert, der kein Array ist. Fehlerbehebung : Indizieren Sie nur Datentypen mit ‚[]‘, wenn diese auch als Array deklariert sind. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\ni[1];\n Meldung: C0047: Indizierung mit '[]' kann nicht auf einen Ausdruck mit Typ 'INT' angewendet werden " }, 
{ "title" : "Compilerfehler C0048 ", 
"url" : "_cds_error_c0048.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0048 ", 
"snippet" : "C0048 Meldung : Datenfeld benötigt genau ‚<number>‘ Indizes Mögliche Fehlerursache : Bei der Verwendung des Arrays werden zu viele oder zu wenige Indizes angegeben. Fehlerbehebung : Geben Sie so viele Indizes an, wie dem Array Dimensionen zugewiesen sind. Beispiel für den Fehler: PROGRAM PLC_PRG VAR...", 
"body" : "C0048 Meldung : Datenfeld benötigt genau ‚<number>‘ Indizes Mögliche Fehlerursache : Bei der Verwendung des Arrays werden zu viele oder zu wenige Indizes angegeben. Fehlerbehebung : Geben Sie so viele Indizes an, wie dem Array Dimensionen zugewiesen sind. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n arr1 : ARRAY[1..2,1..3] OF INT;\nEND_VAR\narr1[1] := 5;\n Meldung: C0048: Datenfeld benötigt genau 2 Indizes Fehlerbehebung: arr1[1,2] := 5; " }, 
{ "title" : "Compilerfehler C0049 ", 
"url" : "_cds_error_c0049.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0049 ", 
"snippet" : "C0049 Meldung : Der konstante Index ‚<index value>‘ liegt außerhalb des Bereichs von ‚<start index>‘ bis ‚<end index>‘ Mögliche Fehlerursache : Es wird ein Index angegeben, der außerhalb der Größe des Arrays liegt. Fehlerbehebung : Verwenden Sie nur Indizes, die innerhalb der Größe des Arrays liegen...", 
"body" : "C0049 Meldung : Der konstante Index ‚<index value>‘ liegt außerhalb des Bereichs von ‚<start index>‘ bis ‚<end index>‘ Mögliche Fehlerursache : Es wird ein Index angegeben, der außerhalb der Größe des Arrays liegt. Fehlerbehebung : Verwenden Sie nur Indizes, die innerhalb der Größe des Arrays liegen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n arr1 : ARRAY[1..2] OF INT;\nEND_VAR\narr1[3] := 1;\n Meldung: C0049: Der konstante Index '3' liegt außerhalb des Bereichs von '1' bis '2' Fehlerbehebung: arr1[2] := 1; " }, 
{ "title" : "Compilerfehler C0050 ", 
"url" : "_cds_error_c0050.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0050 ", 
"snippet" : "C0050 Meldung : Bitzugriff benötigt ein Literal oder eine symbolische ganzzahlige Konstante Mögliche Fehlerursache : Es wird beim Bitzugriff kein Literal oder eine ganzzahlige Konstante angegeben. Fehlerbehebung : Verwenden Sie ein Literal oder eine ganzzahlige Konstante. Beispiel für den Fehler: PR...", 
"body" : "C0050 Meldung : Bitzugriff benötigt ein Literal oder eine symbolische ganzzahlige Konstante Mögliche Fehlerursache : Es wird beim Bitzugriff kein Literal oder eine ganzzahlige Konstante angegeben. Fehlerbehebung : Verwenden Sie ein Literal oder eine ganzzahlige Konstante. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\n x : INT;\nEND_VAR\n\ni.x := FALSE;\n Meldung: C0018: 'i.x' ist kein gültiges Zuweisungsziel C0050: Bitzugriff benötigt ein Literal oder eine symbolische ganzzahlige Konstante Fehlerbehebung: i := Test(x); " }, 
{ "title" : "Compilerfehler C0051 ", 
"url" : "_cds_error_c0051.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0051 ", 
"snippet" : "C0051 Meldung : Für einen Attributwert wird eine Single-Byte-Zeichenkette anstelle von ‚<value>‘ erwartet. Mögliche Fehlerursache : An der angezeigten Stelle steht nicht wie erwartet eine Zeichenkette. Fehlerbehebung : Ersetzen Sie den aktuellen Wert durch eine Zeichenkette. Beispiel für den Fehler:...", 
"body" : "C0051 Meldung : Für einen Attributwert wird eine Single-Byte-Zeichenkette anstelle von ‚<value>‘ erwartet. Mögliche Fehlerursache : An der angezeigten Stelle steht nicht wie erwartet eine Zeichenkette. Fehlerbehebung : Ersetzen Sie den aktuellen Wert durch eine Zeichenkette. Beispiel für den Fehler: PROGRAM PLC_PRG\n{IF hasattribute(pou: MyPOU, MyAttribute)}\n{END_IF}\n Meldung: C0051: für einen Attributwert wird eine Single-Byte-Zeichenkette anstelle von MyAttribute erwartet. Fehlerbehebung: PROGRAM PLC_PRG\n{IF hasattribute(pou: MyPOU, 'MyAttribute')}\n{END_IF} " }, 
{ "title" : "Compilerfehler C0053 ", 
"url" : "_cds_error_c0053.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0053 ", 
"snippet" : "C0053 Meldung : Compilerversion <version> wurde zurückgezogen. Bitte verwenden Sie statt dessen eine höhere Compilerversion. Mögliche Fehlerursache : Die aktuelle Compilerversion kann nicht verwendet werden. Fehlerbehebung : Passen Sie die aktuelle Compilerversion im Projekt an (Projektumgebung, Pro...", 
"body" : "C0053 Meldung : Compilerversion <version> wurde zurückgezogen. Bitte verwenden Sie statt dessen eine höhere Compilerversion. Mögliche Fehlerursache : Die aktuelle Compilerversion kann nicht verwendet werden. Fehlerbehebung : Passen Sie die aktuelle Compilerversion im Projekt an (Projektumgebung, Projekteinstellungen). " }, 
{ "title" : "Compilerfehler C0061 ", 
"url" : "_cds_error_c0061.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0061 ", 
"snippet" : "C0061 Meldung : Bitzugriff auf einen Funktionsaufruf ist nicht erlaubt Mögliche Fehlerursache : Es wird ein Bitzugriff auf eine Funktion ausgeführt. Fehlerbehebung : Verwenden Sie den Bitzugriff nur bei unterstützten Datentypen. Beispiel für den Fehler: PROGRAM PLC_PRG VAR END_VAR Test().2; FUNCTION...", 
"body" : "C0061 Meldung : Bitzugriff auf einen Funktionsaufruf ist nicht erlaubt Mögliche Fehlerursache : Es wird ein Bitzugriff auf eine Funktion ausgeführt. Fehlerbehebung : Verwenden Sie den Bitzugriff nur bei unterstützten Datentypen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nTest().2;\n\nFUNCTION Test : INT\nVAR_INPUT\n\nEND_VAR\n Meldung: C0061: Bitzugriff auf einen Funktionsaufruf ist nicht erlaubt " }, 
{ "title" : "Compilerfehler C0062 ", 
"url" : "_cds_error_c0062.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0062 ", 
"snippet" : "C0062 Meldung : ‚<variable name>‘ ist keine Strukturvariable Mögliche Fehlerursache : Eine Variable, die keine Strukturvariable ist, wird wie eine Strukturvariable behandelt. Fehlerbehebung : Achten Sie darauf, dass die Variable tatsächlich eine Strukturvariable ist. Beispiel für den Fehler: PROGRAM...", 
"body" : "C0062 Meldung : ‚<variable name>‘ ist keine Strukturvariable Mögliche Fehlerursache : Eine Variable, die keine Strukturvariable ist, wird wie eine Strukturvariable behandelt. Fehlerbehebung : Achten Sie darauf, dass die Variable tatsächlich eine Strukturvariable ist. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n pt : PUNKT;\n i : INT;\nEND_VAR\n\ni.x := 1024;\n\n\nTYPE Punkt :\nSTRUCT\n x : REAL;\n y : REAL;\nEND_STRUCT\nEND_TYPE\n Meldung: C0018: 'i.x' ist kein gültiges Zuweisungsziel C0062: 'Variable' ist keine Strukturvariable Fehlerbehebung: Beispiel:\npt.x := 1024; " }, 
{ "title" : "Compilerfehler C0064 ", 
"url" : "_cds_error_c0064.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0064 ", 
"snippet" : "C0064 Meldung : Dereferenzierung benötigt einen Pointer Mögliche Fehlerursache : Es wird eine Variable „dereferenziert“, die keine Pointervariable ist. Fehlerbehebung : „Dereferenzieren“ Sie nur Variablen, die Pointervariablen sind. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i : INT; pi : POINTER ...", 
"body" : "C0064 Meldung : Dereferenzierung benötigt einen Pointer Mögliche Fehlerursache : Es wird eine Variable „dereferenziert“, die keine Pointervariable ist. Fehlerbehebung : „Dereferenzieren“ Sie nur Variablen, die Pointervariablen sind. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\n pi : POINTER TO INT;\nEND_VAR\ni^:=1;\n Meldung: C0018: 'i^' ist kein gültiges Zuweisungsziel C0064: Dereferenzierung benötigt einen Pointer Fehlerbehebung: pi := ADR(i);\npi^ := 1; " }, 
{ "title" : "Compilerfehler C0065 ", 
"url" : "_cds_error_c0065.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0065 ", 
"snippet" : "C0065 Meldung : Globale Definition für ‚<name>‘ nicht vorhanden. Mögliche Fehlerursache : Der gesuchte Wert ist keine globale Variable, globale POU oder anderer global zugreifbarer Wert. Fehlerbehebung : Deklarieren Sie ‚<name>‘ als globale Variable. Beispiel für den Fehler: PROGRAM PLC_PRG .someVal...", 
"body" : "C0065 Meldung : Globale Definition für ‚<name>‘ nicht vorhanden. Mögliche Fehlerursache : Der gesuchte Wert ist keine globale Variable, globale POU oder anderer global zugreifbarer Wert. Fehlerbehebung : Deklarieren Sie ‚<name>‘ als globale Variable. Beispiel für den Fehler: PROGRAM PLC_PRG\n.someValue := 5;\n Meldung: C0065: Globale Definition für ‚someValue‘ nicht vorhanden Fehlerbehebung: VAR_GLOBAL\n someValue : INT;\nEND_VAR " }, 
{ "title" : "Compilerfehler C0066 ", 
"url" : "_cds_error_c0066.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0066 ", 
"snippet" : "C0066 Meldung : Typ ‚<data type>‘ kann nicht mit Typ ‚<data type>‘ verglichen werden. Mögliche Fehlerursache : Es werden zwei nicht miteinander vergleichbare Datentypen verglichen. Fehlerbehebung : Vergleichen Sie nur Datentypen, die miteinander vergleichbar sind. Beispiel für den Fehler: PROGRAM PL...", 
"body" : "C0066 Meldung : Typ ‚<data type>‘ kann nicht mit Typ ‚<data type>‘ verglichen werden. Mögliche Fehlerursache : Es werden zwei nicht miteinander vergleichbare Datentypen verglichen. Fehlerbehebung : Vergleichen Sie nur Datentypen, die miteinander vergleichbar sind. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\n re : REAL;\n str: STRING;\n b : BOOL;\nEND_VAR\n\nb := i > str;\n Meldung: C0066: Typ 'INT' kann nicht mit Typ 'STRING' verglichen werden Fehlerbehebung: b := i > re; " }, 
{ "title" : "Compilerfehler C0068 ", 
"url" : "_cds_error_c0068.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0068 ", 
"snippet" : "C0068 Meldung : Vergleich für Objekte vom Typ ‚<data type>‘ nicht möglich Mögliche Fehlerursache : Es wird ein Vergleich mit Objekten durchgeführt, bei denen ein Vergleich nicht möglich ist. Fehlerbehebung : Vergleichen Sie nur Datentypen, bei denen ein Vergleich möglich ist (INT, REAL, etc.). Beisp...", 
"body" : "C0068 Meldung : Vergleich für Objekte vom Typ ‚<data type>‘ nicht möglich Mögliche Fehlerursache : Es wird ein Vergleich mit Objekten durchgeführt, bei denen ein Vergleich nicht möglich ist. Fehlerbehebung : Vergleichen Sie nur Datentypen, bei denen ein Vergleich möglich ist (INT, REAL, etc.). Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n b : BOOL;\n arr1 : ARRAY [1..2] OF INT;\n arr2 : ARRAY [1..2] OF INT;\nEND_VAR\n\nb := arr1 > arr2;\n Meldung: C0068: Vergleich für Objekte vom Typ 'ARRAY [1..2]' nicht möglich " }, 
{ "title" : "Compilerfehler C0069 ", 
"url" : "_cds_error_c0069.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0069 ", 
"snippet" : "C0069 Meldung : Vergleich für Objekte vom Typ ‚<data type>‘ oder ‚<data type>‘ nicht möglich. Mögliche Fehlerursache : Es wird ein Vergleich mit zwei unterschiedlichen Objekten durchgeführt, bei denen ein Vergleich nicht möglich ist. Fehlerbehebung : Vergleichen Sie nur Datentypen, bei denen ein Ver...", 
"body" : "C0069 Meldung : Vergleich für Objekte vom Typ ‚<data type>‘ oder ‚<data type>‘ nicht möglich. Mögliche Fehlerursache : Es wird ein Vergleich mit zwei unterschiedlichen Objekten durchgeführt, bei denen ein Vergleich nicht möglich ist. Fehlerbehebung : Vergleichen Sie nur Datentypen, bei denen ein Vergleich möglich ist (INT, REAL, etc.). Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n b : BOOL;\n arr1 : ARRAY [1..2] OF INT;\n arr2 : ARRAY [1..3] OF INT;\nEND_VAR\n\nb := arr1 > arr2;\n Meldung: C0069: Vergleich für Objekte vom Typ 'ARRAY [1..2]' oder 'ARRAY [1..3]' nicht möglich " }, 
{ "title" : "Compilerfehler C0070 ", 
"url" : "_cds_error_c0070.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0070 ", 
"snippet" : "C0070 Meldung : ‚INI‘-Operator benötigt Funktionsbaustein- oder DUT-Instanz Mögliche Fehlerursache : Auf den INI-Operator wird keine Funktionsbaustein- oder DUT-Instanz angewendet. Fehlerbehebung : Übergeben Sie dem INI-Operator nur Funktionsbaustein- oder DUT-Instanzen: Beispiel für den Fehler: PRO...", 
"body" : "C0070 Meldung : ‚INI‘-Operator benötigt Funktionsbaustein- oder DUT-Instanz Mögliche Fehlerursache : Auf den INI-Operator wird keine Funktionsbaustein- oder DUT-Instanz angewendet. Fehlerbehebung : Übergeben Sie dem INI-Operator nur Funktionsbaustein- oder DUT-Instanzen: Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n b : BOOL;\n inst : FB;\nEND_VAR\n\nb := INI(b, TRUE);\n\nFUNCTION_BLOCK FB\nVAR\nEND_VAR\n Meldung: C0070: 'INI'-Operator benötigt Funktionsbaustein- oder DUT-Instanz Fehlerbehebung: b := INI(inst, TRUE); " }, 
{ "title" : "Compilerfehler C0072 ", 
"url" : "_cds_error_c0072.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0072 ", 
"snippet" : "C0072 Meldung : Operator ‚<operator name>‘ kann auf Typ ‚<data type>‘ nicht angewendet werden. Mögliche Fehlerursache : Ein Operator wird auf einen inkompatiblen Typ angewendet. Fehlerbehebung : Wenden Sie Operatoren nur auf kompatible Datentypen an. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i : ...", 
"body" : "C0072 Meldung : Operator ‚<operator name>‘ kann auf Typ ‚<data type>‘ nicht angewendet werden. Mögliche Fehlerursache : Ein Operator wird auf einen inkompatiblen Typ angewendet. Fehlerbehebung : Wenden Sie Operatoren nur auf kompatible Datentypen an. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\n str : STRING;\nEND_VAR\n\nstr := ABS(str);\n Meldung: C0072: Operator 'Abs' kann auf Typ 'STRING' nicht angewendet werden Fehlerbehebung: i := ABS(i); " }, 
{ "title" : "Compilerfehler C0074 ", 
"url" : "_cds_error_c0074.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0074 ", 
"snippet" : "C0074 Meldung : Unerwartete Datenfeldinitialisierung Mögliche Fehlerursache : Syntaxfehler bei der Datenfeldinitialisierung Fehlerbehebung : Korrigieren Sie die Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG VAR arr1 : INT := [1,2,3,4,5,6]; END_VAR Meldung: C0074: Unerwartete Datenfeldinitialisier...", 
"body" : "C0074 Meldung : Unerwartete Datenfeldinitialisierung Mögliche Fehlerursache : Syntaxfehler bei der Datenfeldinitialisierung Fehlerbehebung : Korrigieren Sie die Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n arr1 : INT := [1,2,3,4,5,6];\nEND_VAR\n Meldung: C0074: Unerwartete Datenfeldinitialisierung C0032: Typ 'Unbekannter Typ: '[1,2,3,4,5,6]' kann nicht in Typ 'INT' konvertiert werden Fehlerbehebung: arr1 : ARRAY [1..6] OF INT := [1,2,3,4,5,6]; " }, 
{ "title" : "Compilerfehler C0075 ", 
"url" : "_cds_error_c0075.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0075 ", 
"snippet" : "C0075 Meldung : Zu viele Initialisierer für Datenfeld Mögliche Fehlerursache : Es werden zu viele Werte für die Größe des Arrays angegeben. Fehlerbehebung : Die Anzahl der zugewiesenen Werte muss der Größe des Arrays entsprechen. Beispiel für den Fehler: PROGRAM PLC_PRG VAR arr1 : ARRAY [1..5] OF IN...", 
"body" : "C0075 Meldung : Zu viele Initialisierer für Datenfeld Mögliche Fehlerursache : Es werden zu viele Werte für die Größe des Arrays angegeben. Fehlerbehebung : Die Anzahl der zugewiesenen Werte muss der Größe des Arrays entsprechen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n arr1 : ARRAY [1..5] OF INT := [1,2,3,4,5,6];\nEND_VAR\n Meldung: C0075: Unerwartete Datenfeldinitialisierung Fehlerbehebung: arr1 : ARRAY [1..6] OF INT := [1,2,3,4,5,6]; " }, 
{ "title" : "Compilerfehler C0076 ", 
"url" : "_cds_error_c0076.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0076 ", 
"snippet" : "C0076 Meldung : Unerwartete Strukturinitialisierung Mögliche Fehlerursache : Syntaxfehler bei der Strukturinitialisierung Fehlerbehebung : Achten Sie auf eine korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG VAR st1 : INT := (p1 := 1); END_VAR Meldung: C0076: Unerwartete Strukturinitialisie...", 
"body" : "C0076 Meldung : Unerwartete Strukturinitialisierung Mögliche Fehlerursache : Syntaxfehler bei der Strukturinitialisierung Fehlerbehebung : Achten Sie auf eine korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n st1 : INT := (p1 := 1);\nEND_VAR\n Meldung: C0076: Unerwartete Strukturinitialisierung C0032: Typ 'STRUCT(p1:=1)' kann nicht in Typ 'INT' konvertiert werden C0046: Bezeichner 'p1' nicht definiert C0018: 'p1' ist kein gültiges Zuweisungsziel Fehlerbehebung: st1 : STRUCT1 := (p1:=1,p2:=10); " }, 
{ "title" : "Compilerfehler C0077 ", 
"url" : "_cds_error_c0077.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0077 ", 
"snippet" : "C0077 Meldung : Unbekannter Typ: ‚<data type>‘ Mögliche Fehlerursache : Ungültiger Datentyp bei der Deklarierung (möglicherweise ein Syntaxtfehler). Fehlerbehebung : Geben Sie nur gültige Datentypen an. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i : INTEGER; END_VAR Meldung: C0077: Unbekannter Typ...", 
"body" : "C0077 Meldung : Unbekannter Typ: ‚<data type>‘ Mögliche Fehlerursache : Ungültiger Datentyp bei der Deklarierung (möglicherweise ein Syntaxtfehler). Fehlerbehebung : Geben Sie nur gültige Datentypen an. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INTEGER;\nEND_VAR\n Meldung: C0077: Unbekannter Typ: 'INTEGER' Fehlerbehebung: arr1 : ARRAY[1..2] OF STRUCT1 := (p1:=1,p2:=10); " }, 
{ "title" : "Compilerfehler C0078 ", 
"url" : "_cds_error_c0078.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0078 ", 
"snippet" : "C0078 Meldung : Nicht unterstützter Typ ‚<data type>‘ Mögliche Fehlerursache : Der verwendete Typ wird vom aktuellen Gerät nicht unterstützt und kann deswegen nicht verwendet werden. Fehlerbehebung : Falls möglich, verwenden Sie einen anderen Typ. Zum Beispiel REAL anstatt LREAL . Beispiel für den F...", 
"body" : "C0078 Meldung : Nicht unterstützter Typ ‚<data type>‘ Mögliche Fehlerursache : Der verwendete Typ wird vom aktuellen Gerät nicht unterstützt und kann deswegen nicht verwendet werden. Fehlerbehebung : Falls möglich, verwenden Sie einen anderen Typ. Zum Beispiel REAL anstatt LREAL . Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n value : LREAL;\nEND_VAR\n Meldung: C0078: Nicht unterstützter Typ: ‚LREAL‘ Fehlerbehebung: PROGRAM PLC_PRG\nVAR\n value : REAL;\nEND_VAR " }, 
{ "title" : "Compilerfehler C0080 ", 
"url" : "_cds_error_c0080.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0080 ", 
"snippet" : "C0080 Meldung : Funktionsbaustein ‚<function block name>‘ muss für den Zugriff instanziiert werden. Mögliche Fehlerursache : Fehlende Funktionsbausteininstanziierung Fehlerbehebung : Instanziieren Sie den Funktionsbaustein Beispiel für den Fehler: PROGRAM PLC_PRG VAR END_VAR FB(); FUNCTION_BLOCK FB ...", 
"body" : "C0080 Meldung : Funktionsbaustein ‚<function block name>‘ muss für den Zugriff instanziiert werden. Mögliche Fehlerursache : Fehlende Funktionsbausteininstanziierung Fehlerbehebung : Instanziieren Sie den Funktionsbaustein Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nFB();\n\n\nFUNCTION_BLOCK FB\nVAR\nEND_VAR\n Meldung: C0080: Funktionsbaustein 'FB' muss für den Zugriff instanziiert werden Fehlerbehebung: VAR\n inst : FB;\nEND_VAR\ninst(); " }, 
{ "title" : "Compilerfehler C0081 ", 
"url" : "_cds_error_c0081.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0081 ", 
"snippet" : "C0081 Meldung : Unerwartetes Pragma: ‚<pragma name>‘ ohne zugehöriges ‚if‘ gefunden Mögliche Fehlerursache : Bei der Pragmaverwendung fehlt die IF-Bedingung Fehlerbehebung : Ergänzen Sie die IF-Bedingung des Pragmas. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i : INT; END_VAR i := 5; {END_IF} Meld...", 
"body" : "C0081 Meldung : Unerwartetes Pragma: ‚<pragma name>‘ ohne zugehöriges ‚if‘ gefunden Mögliche Fehlerursache : Bei der Pragmaverwendung fehlt die IF-Bedingung Fehlerbehebung : Ergänzen Sie die IF-Bedingung des Pragmas. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\n\ni := 5;\n{END_IF}\n Meldung: C0081: Unerwartetes Pragma: 'END_IF' ohne zugehöriges 'if' gefunden Fehlerbehebung: {IF <expression>}\ni := 5;\n{END_IF} " }, 
{ "title" : "Compilerfehler C0082 ", 
"url" : "_cds_error_c0082.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0082 ", 
"snippet" : "C0082 Meldung : ‚<invalid pragma>‘ ist keine gültige Pragma-Bedingung Mögliche Fehlerursache : Bei der Pragmaverwendung wird in der IF-Bedingung ein ungültiger Ausdruck verwendet. Fehlerbehebung : Verwenden Sie gültige Pragma-Bedingungen Beispiel für den Fehler: PROGRAM PLC_PRG VAR i : INT; END_VAR ...", 
"body" : "C0082 Meldung : ‚<invalid pragma>‘ ist keine gültige Pragma-Bedingung Mögliche Fehlerursache : Bei der Pragmaverwendung wird in der IF-Bedingung ein ungültiger Ausdruck verwendet. Fehlerbehebung : Verwenden Sie gültige Pragma-Bedingungen Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\n\n{IF abc}\ni := 5;\n{END_IF}\n Meldung: C0082: '!!!ERROR!!!' ist keine gültige Pragma-Bedingung Fehlerbehebung: {IF defined (abc)} " }, 
{ "title" : "Compilerfehler C0084 ", 
"url" : "_cds_error_c0084.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0084 ", 
"snippet" : "C0084 Meldung : ‚<pragma operand>‘ ist kein gültiger Pragma-Operand Mögliche Fehlerursache : Syntaxfehler. Fehlerbehebung : Verwenden Sie gültige Pragma-Operanden. Beispiel für den Fehler: PROGRAM PLC_PRG VAR END_VAR {IF defined(0)} {END_IF} Meldung: C0084: 'defined(null)' ist kein gültiger Pragma-O...", 
"body" : "C0084 Meldung : ‚<pragma operand>‘ ist kein gültiger Pragma-Operand Mögliche Fehlerursache : Syntaxfehler. Fehlerbehebung : Verwenden Sie gültige Pragma-Operanden. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\nEND_VAR\n\n{IF defined(0)}\n{END_IF}\n Meldung: C0084: 'defined(null)' ist kein gültiger Pragma-Operand Fehlerbehebung: {IF defined (abc)} " }, 
{ "title" : "Compilerfehler C0085 ", 
"url" : "_cds_error_c0085.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0085 ", 
"snippet" : "C0085 Meldung : Define-Wert anstelle von ‚<value>‘ erwartet. Mögliche Fehlerursache : An der angezeigten Stelle des Pragmas wird eine Zeichenkette erwartet anstatt des aktuellen Werts. Fehlerbehebung : Ersetzen Sie den aktuellen Wert durch eine Zeichenkette. Beispiel für den Fehler: PROGRAM PLC_PRG ...", 
"body" : "C0085 Meldung : Define-Wert anstelle von ‚<value>‘ erwartet. Mögliche Fehlerursache : An der angezeigten Stelle des Pragmas wird eine Zeichenkette erwartet anstatt des aktuellen Werts. Fehlerbehebung : Ersetzen Sie den aktuellen Wert durch eine Zeichenkette. Beispiel für den Fehler: PROGRAM PLC_PRG\n\n{IF hasvalue(define, defineValue)}\n{END_IF}\n Meldung: C0085: Define-Wert anstelle von ‚defineValue‘ erwartet Fehlerbehebung: PROGRAM PLC_PRG\n\n{IF hasvalue(define, '120')}\n{END_IF} " }, 
{ "title" : "Compilerfehler C0086 ", 
"url" : "_cds_error_c0086.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0086 ", 
"snippet" : "C0086 Meldung : Keine Definition für Schnittstelle ‚<interface name>‘ gefunden Mögliche Fehlerursache : Es wird eine nicht definierte Schnittstelle verwendet. Fehlerbehebung : Definieren Sie die Schnittstelle. Beispiel für den Fehler: PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTION_BLOCK FB IMPLEMEN...", 
"body" : "C0086 Meldung : Keine Definition für Schnittstelle ‚<interface name>‘ gefunden Mögliche Fehlerursache : Es wird eine nicht definierte Schnittstelle verwendet. Fehlerbehebung : Definieren Sie die Schnittstelle. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB IMPLEMENTS XY\nVAR\nEND_VAR\n Meldung: C0086: Keine Definition für Schnittstelle 'XY' gefunden Fehlerbehebung: INTERFACE XY " }, 
{ "title" : "Compilerfehler C0087 ", 
"url" : "_cds_error_c0087.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0087 ", 
"snippet" : "C0087 Meldung : Keine Implementierung für Methode ‚<method name>‘ aus Schnittstelle ‚<interface name>‘. Mögliche Fehlerursache : Eine von der Schnittstelle vorgegebene Methode wird vom implementierenden Funktionsbaustein nicht zur Verfügung gestellt. Fehlerbehebung : Implementieren Sie alle Methoden...", 
"body" : "C0087 Meldung : Keine Implementierung für Methode ‚<method name>‘ aus Schnittstelle ‚<interface name>‘. Mögliche Fehlerursache : Eine von der Schnittstelle vorgegebene Methode wird vom implementierenden Funktionsbaustein nicht zur Verfügung gestellt. Fehlerbehebung : Implementieren Sie alle Methoden, die von der Schnittstelle vorgegeben werden Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\nINTERFACE XY\nMETHOD METH1\nVAR_INPUT\nEND_VAR\n\nFUNCTION_BLOCK FB IMPLEMENTS XY\nVAR\nEND_VAR\nMETHOD METH2\nVAR_INPUT\nEND_VAR\n Meldung: C0087: Keine Implementierung für Methode 'METH1' aus Schnittstelle 'XY' " }, 
{ "title" : "Compilerfehler C0089 ", 
"url" : "_cds_error_c0089.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0089 ", 
"snippet" : "C0089 Meldung : Schnittstelle der überladenen Methode ‚{0}‘ von Schnittstelle ‚{1}‘ stimmt nicht mit der Deklaration überein Mögliche Fehlerursache : Die Signatur der implementierten Methode stimmt nicht mit der Signatur der Methode in der Schnittstelle überein. Fehlerbehebung : Achten Sie darauf, d...", 
"body" : "C0089 Meldung : Schnittstelle der überladenen Methode ‚{0}‘ von Schnittstelle ‚{1}‘ stimmt nicht mit der Deklaration überein Mögliche Fehlerursache : Die Signatur der implementierten Methode stimmt nicht mit der Signatur der Methode in der Schnittstelle überein. Fehlerbehebung : Achten Sie darauf, dass die gleichen Rückgabetypen und Parameter deklariert sind. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\nINTERFACE XY\nMETHOD METH1\nVAR_INPUT\n iPar : INT;\nEND_VAR\n\nFUNCTION_BLOCK FB IMPLEMENTS XY\nVAR\nEND_VAR\nMETHOD METH1\nVAR_INPUT\nEND_VAR\n Meldung: C0089: Schnittstelle der überladenen Methode 'METH1' von Schnittstelle 'XY' stimmt nicht mit der Deklaration überein " }, 
{ "title" : "Compilerfehler C0090 ", 
"url" : "_cds_error_c0090.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0090 ", 
"snippet" : "C0090 Meldung : Keine Definition für Basis ‚<function name>‘ gefunden Mögliche Fehlerursache : Der als Basis angegebene Funktionsbaustein existiert nicht oder ist kein Funktionsbaustein. Fehlerbehebung : Verwenden Sie einen Funktionsbaustein als Basis. Beispiel für den Fehler: PROGRAM PLC_PRG VAR in...", 
"body" : "C0090 Meldung : Keine Definition für Basis ‚<function name>‘ gefunden Mögliche Fehlerursache : Der als Basis angegebene Funktionsbaustein existiert nicht oder ist kein Funktionsbaustein. Fehlerbehebung : Verwenden Sie einen Funktionsbaustein als Basis. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\nFUNCTION_BLOCK FB EXTENDS POU\nVAR\nEND_VAR\n\nFUNCTION POU\nVAR\nEND_VAR\n Meldung: C0090: Keine Definition für Basis 'POU' gefunden " }, 
{ "title" : "Compilerfehler C0091 ", 
"url" : "_cds_error_c0091.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0091 ", 
"snippet" : "C0091 Meldung : Rekursion in Basisfunktionsbausteinliste: <function name> Mögliche Fehlerursache : Ein Basisfunktionsbaustein wird um sich selbst erweitert. Fehlerbehebung : Rekursion in Basisfunktionsbausteinlisten ist nicht möglich Beispiel für den Fehler: PROGRAM PLC_PRG VAR inst : FB; END_VAR FU...", 
"body" : "C0091 Meldung : Rekursion in Basisfunktionsbausteinliste: <function name> Mögliche Fehlerursache : Ein Basisfunktionsbaustein wird um sich selbst erweitert. Fehlerbehebung : Rekursion in Basisfunktionsbausteinlisten ist nicht möglich Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB EXTENDS FB\nVAR\nEND_VAR\n Meldung: C0091: Rekursion in Basisfunktionsbausteinliste: FB -> FB " }, 
{ "title" : "Compilerfehler C0094 ", 
"url" : "_cds_error_c0094.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0094 ", 
"snippet" : "C0094 Meldung : Schnittstelle der überladenen Methode ‚<method name>‘ von Basis ‚<function block name>‘ stimmt nicht mit der Deklaration überein Mögliche Fehlerursache : Die Signatur der Methode der ersten Schnittstelle stimmt nicht mit der Signatur der Methode in der zweiten Schnittstelle, die um d...", 
"body" : "C0094 Meldung : Schnittstelle der überladenen Methode ‚<method name>‘ von Basis ‚<function block name>‘ stimmt nicht mit der Deklaration überein Mögliche Fehlerursache : Die Signatur der Methode der ersten Schnittstelle stimmt nicht mit der Signatur der Methode in der zweiten Schnittstelle, die um die erste erweitert wird, überein. Fehlerbehebung : Gleichen Sie die Signaturen an. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n xyz : XY2;\nEND_VAR\n\nFUNCTION_BLOCK XY\nMETHOD METH1\nVAR_INPUT\nEND_VAR\n\nFUNCTION_BLOCK XY2 EXTENDS XY\nMETHOD METH1\nVAR_INPUT\n iPar : BOOL;\nEND_VAR\n Meldung: C0094: Schnittstelle der überladenen Methode 'METH1' von Basis 'XY' stimmt nicht mit der Deklaration überein' " }, 
{ "title" : "Compilerfehler C0096 ", 
"url" : "_cds_error_c0096.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0096 ", 
"snippet" : "C0096 Meldung : Nur ein einziger Basisfunktionsbaustein darf in der EXTENDS-Liste definiert sein. Mögliche Fehlerursache : Zwei oder mehr Basisfunktionsbausteine werden in der EXTENDS-Liste definiert. Fehlerbehebung : Definieren Sie nur einen Basisfunktionsbaustein in der EXTENDS-Liste. Beispiel für...", 
"body" : "C0096 Meldung : Nur ein einziger Basisfunktionsbaustein darf in der EXTENDS-Liste definiert sein. Mögliche Fehlerursache : Zwei oder mehr Basisfunktionsbausteine werden in der EXTENDS-Liste definiert. Fehlerbehebung : Definieren Sie nur einen Basisfunktionsbaustein in der EXTENDS-Liste. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n fb : FB;\nEND_VAR\n\nFUNCTION_BLOCK FB EXTENDS FB2, FB3\nVAR\nEND_VAR\n\nFUNCTION_BLOCK FB2\nVAR\nEND_VAR\n\nFUNCTION_BLOCK FB3\nVAR\nEND_VAR\n Meldung: C0096: Nur ein einziger Basisfunktionsbaustein darf in der EXTENDS-Liste definiert sein " }, 
{ "title" : "Compilerfehler C0097 ", 
"url" : "_cds_error_c0097.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0097 ", 
"snippet" : "C0097 Meldung : Mehrfachdefinition von Variable ‚<variable name>‘ in Funktionsbaustein ‚<function block name>‘ und in Basis ‚<base function block name>‘ Mögliche Fehlerursache : Eine Variable wird in einem Funktionsbaustein und seiner Basis mit gleichem Namen deklariert. Fehlerbehebung : Verwenden S...", 
"body" : "C0097 Meldung : Mehrfachdefinition von Variable ‚<variable name>‘ in Funktionsbaustein ‚<function block name>‘ und in Basis ‚<base function block name>‘ Mögliche Fehlerursache : Eine Variable wird in einem Funktionsbaustein und seiner Basis mit gleichem Namen deklariert. Fehlerbehebung : Verwenden Sie unterschiedliche Variablennamen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n fb : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB EXTENDS FB2\nVAR\n i : INT;\nEND_VAR\n\n\nFUNCTION_BLOCK FB2\nVAR\n i : INT;\nEND_VAR\n Meldung: C0097: Mehrfachdefinition von Variable 'i' in Funktionsbaustein 'FB' und in Basis 'FB2' " }, 
{ "title" : "Compilerfehler C0098 ", 
"url" : "_cds_error_c0098.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0098 ", 
"snippet" : "C0098 Meldung : Das Schlüsselwort „FUNCTIONBLOCK“ wird nicht mehr unterstützt. Verwenden Sie stattdessen „FUNCTION_BLOCK“. Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Verwenden Sie das Schlüsselwort „FUNCTION_BLOCK“. Beispiel für den Fehler: PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTION...", 
"body" : "C0098 Meldung : Das Schlüsselwort „FUNCTIONBLOCK“ wird nicht mehr unterstützt. Verwenden Sie stattdessen „FUNCTION_BLOCK“. Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Verwenden Sie das Schlüsselwort „FUNCTION_BLOCK“. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\nFUNCTIONBLOCK FB\nVAR\nEND_VAR\n Meldung: C0098: Das Schlüsselwort \"FUNCTIONBLOCK\" wird nicht mehr unterstützt. Verwenden Sie stattdessen \"FUNCTION_BLOCK\" " }, 
{ "title" : "Compilerfehler C0099 (Compilerversion < 3.5.7.0) ", 
"url" : "_cds_error_c0099.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0099 (Compilerversion < 3.5.7.0) ", 
"snippet" : "C0099 Meldung : Lokale Enumerationen werden nicht mehr unterstützt. Verwenden Sie stattdessen eine DUT-Definition. Mögliche Fehlerursache : Es wurde eine lokale Enumerationsdeklaration zusammen mit einer Compilerversion verwendet, die dies nicht unterstützt. Fehlerbehebung : Verwenden Sie eine neuer...", 
"body" : "C0099 Meldung : Lokale Enumerationen werden nicht mehr unterstützt. Verwenden Sie stattdessen eine DUT-Definition. Mögliche Fehlerursache : Es wurde eine lokale Enumerationsdeklaration zusammen mit einer Compilerversion verwendet, die dies nicht unterstützt. Fehlerbehebung : Verwenden Sie eine neuere Compilerversion, oder definieren Sie die Enumeration in einer DUT. Beispiel für den Fehler: Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n localEnumVar : (RED, GREEN, BLUE) := RED;\nEND_VAR\n Meldung: C0099: Lokale Enumerationen werden nicht mehr unterstützt. Verwenden Sie stattdessen eine DUT-Definition. " }, 
{ "title" : "Compilerfehler C0101 ", 
"url" : "_cds_error_c0101.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0101 ", 
"snippet" : "C0101 Meldung : Datenrekursion: ‚<recursion>‘ Mögliche Fehlerursache : Rekursive Dateninitialisierung über zwei Funktionsbausteine Fehlerbehebung : Vermeiden Sie Rekursionen bei Dateninitialisierungen. Beispiel für den Fehler: PROGRAM PLC_PRG VAR inst0 : FB1; END_VAR FUNCTION_BLOCK FB1 VAR inst1 : F...", 
"body" : "C0101 Meldung : Datenrekursion: ‚<recursion>‘ Mögliche Fehlerursache : Rekursive Dateninitialisierung über zwei Funktionsbausteine Fehlerbehebung : Vermeiden Sie Rekursionen bei Dateninitialisierungen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst0 : FB1;\nEND_VAR\n\nFUNCTION_BLOCK FB1\nVAR\n inst1 : FB2;\nEND_VAR\n\nFUNCTION_BLOCK FB2\nVAR\n inst2 : FB1;\nEND_VAR\n Meldung: C0101: Datenrekursion: FB1->FB2->FB1 " }, 
{ "title" : "Compilerfehler C0102 ", 
"url" : "_cds_error_c0102.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0102 ", 
"snippet" : "C0102 Meldung : Nicht genügend freier Retain-Speicher: Variable ‚<variable name>‘, <byte size> Bytes. Mögliche Fehlerursache : Es wird mehr Retain-Speicher verwendet als auf der SPS verfügbar ist. Alternativ könnte der Retain-Speicher durch inkrementelles Übersetzen zu stark fragmentiert sein. Fehle...", 
"body" : "C0102 Meldung : Nicht genügend freier Retain-Speicher: Variable ‚<variable name>‘, <byte size> Bytes. Mögliche Fehlerursache : Es wird mehr Retain-Speicher verwendet als auf der SPS verfügbar ist. Alternativ könnte der Retain-Speicher durch inkrementelles Übersetzen zu stark fragmentiert sein. Fehlerbehebung : Verwenden Sie bei Fragmentierung des Speichers den Befehl Bereinigen . Damit können Sie die Reallozierung aller Daten beim nächsten Übersetzen erzwingen. " }, 
{ "title" : "Compilerfehler C0103 ", 
"url" : "_cds_error_c0103.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0103 ", 
"snippet" : "C0103 Meldung : Außerhalb des Retain-Speichers: Variable ‚<variable name>‘, <byte size> Bytes. (Größte zusammenhängende Speicherlücke {2}) Mögliche Fehlerursache : Es wird mehr Retain-Speicher verwendet, als auf der SPS verfügbar ist. Alternativ könnte der Retain-Speicher durch inkrementelles Überse...", 
"body" : "C0103 Meldung : Außerhalb des Retain-Speichers: Variable ‚<variable name>‘, <byte size> Bytes. (Größte zusammenhängende Speicherlücke {2}) Mögliche Fehlerursache : Es wird mehr Retain-Speicher verwendet, als auf der SPS verfügbar ist. Alternativ könnte der Retain-Speicher durch inkrementelles Übersetzen zu stark fragmentiert sein. Fehlerbehebung : Verwenden Sie bei Fragmentierung des Speichers den Befehl Bereinigen . Damit können Sie die Reallozierung aller Daten beim nächsten Übersetzen erzwingen. " }, 
{ "title" : "Compilerfehler C0104 ", 
"url" : "_cds_error_c0104.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0104 ", 
"snippet" : "C0104 Meldung : ‚Nicht genügend globaler Datenspeicher: Variable ‚<variable name>‘, <byte size> Bytes. Mögliche Fehlerursache : Es wird mehr Speicher für Daten verwendet als auf der SPS verfügbar ist. Alternativ könnte der Speicher durch inkrementelles Übersetzen zu stark fragmentiert sein. Fehlerbe...", 
"body" : "C0104 Meldung : ‚Nicht genügend globaler Datenspeicher: Variable ‚<variable name>‘, <byte size> Bytes. Mögliche Fehlerursache : Es wird mehr Speicher für Daten verwendet als auf der SPS verfügbar ist. Alternativ könnte der Speicher durch inkrementelles Übersetzen zu stark fragmentiert sein. Fehlerbehebung : Verwenden Sie bei Fragmentierung des Speichers den Befehl Bereinigen . Damit können Sie die Reallozierung aller Daten beim nächsten Übersetzen erzwingen. " }, 
{ "title" : "Compilerfehler C0106 ", 
"url" : "_cds_error_c0106.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0106 ", 
"snippet" : "C0106 Meldungstext : Nicht genügend freier Retain-Speicher: Variable '<variable name>', <byte size> Bytes. (Gesamt verfügbare Größe >byte size> Bytes) Mögliche Fehlerursache : Es wird mehr Retain-Speicher verwendet als auf der SPS verfügbar ist. Alternativ könnte der Retain-Speicher durch inkremente...", 
"body" : "C0106 Meldungstext : Nicht genügend freier Retain-Speicher: Variable '<variable name>', <byte size> Bytes. (Gesamt verfügbare Größe >byte size> Bytes) Mögliche Fehlerursache : Es wird mehr Retain-Speicher verwendet als auf der SPS verfügbar ist. Alternativ könnte der Retain-Speicher durch inkrementelles Übersetzen zu stark fragmentiert sein. Fehlerbehebung : Verwenden Sie bei Fragmentierung des Speichers den Befehl  Bereinigen . Damit können Sie die Reallozierung aller Daten und des Codes beim nächsten Übersetzen erzwingen. " }, 
{ "title" : "Compilerfehler C0114 ", 
"url" : "_cds_error_c0114.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0114 ", 
"snippet" : "C0114 Meldung : Ungültiges Ziel <jump label> für ‚JMP‘ Mögliche Fehlerursache : Syntax- oder Tippfehler im JMP-Ziel. Fehlerbehebung : Korrigieren Sie den Tipp- oder Syntaxfehler Beispiel für den Fehler: PROGRAM PLC_PRG VAR END_VAR JMP 0; Meldung: C0114: Ungültiges Ziel 0 für 'JMP'...", 
"body" : "C0114 Meldung : Ungültiges Ziel <jump label> für ‚JMP‘ Mögliche Fehlerursache : Syntax- oder Tippfehler im JMP-Ziel. Fehlerbehebung : Korrigieren Sie den Tipp- oder Syntaxfehler Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\nEND_VAR\nJMP 0;\n Meldung: C0114: Ungültiges Ziel 0 für 'JMP' " }, 
{ "title" : "Compilerfehler C0115 ", 
"url" : "_cds_error_c0115.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0115 ", 
"snippet" : "C0115 Meldung : Der zweite Parameter eines bedingten Aufrufes (????IMMMER CALC???? ) muss eine gültige Aufrufanweisung sein. Fehlerbehebung : Geben Sie einen Funktions-, Methoden-, oder Funktionbausteinaufruf im zweiten Parameter des bedingten ????CALC???-Aufrufs an. Beispiel für den Fehler: PROGRAM...", 
"body" : "C0115 Meldung : Der zweite Parameter eines bedingten Aufrufes (????IMMMER CALC???? ) muss eine gültige Aufrufanweisung sein. Fehlerbehebung : Geben Sie einen Funktions-, Methoden-, oder Funktionbausteinaufruf im zweiten Parameter des bedingten ????CALC???-Aufrufs an. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n condition : BOOL;\nEND_VAR\nCALC(condition, 1+2);\n Meldung: C0115: Der zweite Parameter eines bedingten Aufrufes muss eine gültige Aufrufanweisung sein. Fehlerbehebung: CALC(condition, MyFunction(1,2)) " }, 
{ "title" : "Compilerfehler C0116 ", 
"url" : "_cds_error_c0116.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0116 ", 
"snippet" : "C0116 Meldung : Marke ‚<jump label>‘ mehrfach definiert Mögliche Fehlerursache : Eine Sprungmarke wird mehrfach definiert. Fehlerbehebung : Definieren Sie jede Sprungmarke nur einmal. Beispiel für den Fehler: PROGRAM PLC_PRG VAR END_VAR JMP label; label: label: Meldung: C0116: Marke 'LABEL' mehrfach...", 
"body" : "C0116 Meldung : Marke ‚<jump label>‘ mehrfach definiert Mögliche Fehlerursache : Eine Sprungmarke wird mehrfach definiert. Fehlerbehebung : Definieren Sie jede Sprungmarke nur einmal. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\nEND_VAR\nJMP label;\nlabel:\n\nlabel:\n Meldung: C0116: Marke 'LABEL' mehrfach definiert " }, 
{ "title" : "Compilerfehler C0117 ", 
"url" : "_cds_error_c0117.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0117 ", 
"snippet" : "C0117 Meldung : Marke ‚<jump label>‘ innerhalb des Bereichs der ‚JMP‘-Anweisung nicht definiert‘ Mögliche Fehlerursache : Es wird zu einer Sprungmarke gesprungen, die nicht existiert. Fehlerbehebung : Definieren Sie die Sprungmarke, die Sie als Ziel angeben Beispiel für den Fehler: PROGRAM PLC_PRG V...", 
"body" : "C0117 Meldung : Marke ‚<jump label>‘ innerhalb des Bereichs der ‚JMP‘-Anweisung nicht definiert‘ Mögliche Fehlerursache : Es wird zu einer Sprungmarke gesprungen, die nicht existiert. Fehlerbehebung : Definieren Sie die Sprungmarke, die Sie als Ziel angeben Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\nEND_VAR\nJMP A;\n Meldung: C0117: Marke 'A' innerhalb des Bereichs der 'JMP'-Anweisung nicht definiert " }, 
{ "title" : "Compilerfehler C0118 ", 
"url" : "_cds_error_c0118.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0118 ", 
"snippet" : "C0118 Meldung : Die Sprungmarke ‚<jump label>‘ wird nicht referenziert. Mögliche Fehlerursache : Es ist eine Sprungmarke definiert, die nicht referenziert wird. Fehlerbehebung : Entfernen Sie die ungenutzten Sprungmarken. Beispiel für den Fehler: PROGRAM PLC_PRG VAR END_VAR LABEL: Meldung: C0118: Di...", 
"body" : "C0118 Meldung : Die Sprungmarke ‚<jump label>‘ wird nicht referenziert. Mögliche Fehlerursache : Es ist eine Sprungmarke definiert, die nicht referenziert wird. Fehlerbehebung : Entfernen Sie die ungenutzten Sprungmarken. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\nEND_VAR\nLABEL:\n Meldung: C0118: Die Marke 'LABEL' wird nicht referenziert " }, 
{ "title" : "Compilerfehler C0119 ", 
"url" : "_cds_error_c0119.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0119 ", 
"snippet" : "C0119 Meldung : Eine ‚FB_init‘-Methode eines Funktionsbausteins oder einer Struktur benötigt zwei Eingänge ‚bInitRetains‘ und ‚bInCopyCode‘ vom Typ BOOL Mögliche Fehlerursache : Einer der Eingänge ‚bInitRetains‘ und ‚bInCopyCode‘ vom Typ BOOL oder beide fehlen. Fehlerbehebung : Definieren Sie die fe...", 
"body" : "C0119 Meldung : Eine ‚FB_init‘-Methode eines Funktionsbausteins oder einer Struktur benötigt zwei Eingänge ‚bInitRetains‘ und ‚bInCopyCode‘ vom Typ BOOL Mögliche Fehlerursache : Einer der Eingänge ‚bInitRetains‘ und ‚bInCopyCode‘ vom Typ BOOL oder beide fehlen. Fehlerbehebung : Definieren Sie die fehlenden Eingänge. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB\nMETHOD FB_init\nVAR_INPUT\nEND_VAR\n Meldung: C0119: Eine 'FB_init'-Methode eines Funktionsbausteins oder einer Struktur benötigt zwei Eingänge 'bInitRetains' und 'bInCopyCode' vom Typ BOOL Fehlerbehebung: METHOD FB_init\nVAR_INPUT\n bInitRetains : BOOL;\n bInCopyCode : BOOL;\nEND_VAR " }, 
{ "title" : "Compilerfehler C0120 ", 
"url" : "_cds_error_c0120.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0120 ", 
"snippet" : "C0120 Meldung : Eine ‚FB_Exit‘-Methode eines Funktionsbausteins oder Struktur benötigt einen Eingang ‚bInCopyCode‘ vom Typ BOOL Mögliche Fehlerursache : Der Eingang bInCopyCode vom Typ BOOL fehlt. Fehlerbehebung : Definieren Sie den Eingang Beispiel für den Fehler: PROGRAM PLC_PRG VAR inst : FB; END...", 
"body" : "C0120 Meldung : Eine ‚FB_Exit‘-Methode eines Funktionsbausteins oder Struktur benötigt einen Eingang ‚bInCopyCode‘ vom Typ BOOL Mögliche Fehlerursache : Der Eingang bInCopyCode vom Typ BOOL fehlt. Fehlerbehebung : Definieren Sie den Eingang Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB\nMETHOD FB_exit\nVAR_INPUT\nEND_VAR\n Meldung: C0120: Eine 'FB_Exit'-Methode eines Funktionsbausteins oder Struktur benötigt einen Eingang 'bInCopyCode' vom Typ BOOL Fehlerbehebung: METHOD FB_exit\nVAR_INPUT\n bInCopyCode : BOOL;\nEND_VAR " }, 
{ "title" : "Compilerfehler C0122 ", 
"url" : "_cds_error_c0122.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0122 ", 
"snippet" : "C0122 Meldung : Ausdruck ‚SUPER‘ ist in diesem Zusammenhang nicht zulässig. Mögliche Fehlerursache : „SUPER^“ wird außerhalb von abgeleiteten Funktionsbausteinen verwendet. Fehlerbehebung : Verwenden Sie „SUPER^“ nur in Funktionsbausteinen. Beispiel für den Fehler: PROGRAM PLC_PRG VAR END_VAR SUPER^...", 
"body" : "C0122 Meldung : Ausdruck ‚SUPER‘ ist in diesem Zusammenhang nicht zulässig. Mögliche Fehlerursache : „SUPER^“ wird außerhalb von abgeleiteten Funktionsbausteinen verwendet. Fehlerbehebung : Verwenden Sie „SUPER^“ nur in Funktionsbausteinen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nSUPER^.METH(TRUE, TRUE);\n Meldung: C0122: Ausdruck 'SUPER' ist in diesem Zusammenhang nicht zulässig " }, 
{ "title" : "Compilerfehler C0124 ", 
"url" : "_cds_error_c0124.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0124 ", 
"snippet" : "C0124 Meldung : ‚Initialisierung‘ ist keine gültige Initialisierung für eine Enumeration Mögliche Fehlerursache : Für die Enum-Initialisierung wird ein Datentyp verwendet, der kein ANY_INT ist. Fehlerbehebung : Verwenden Sie nur ANY_INT für Enum-Initialisierungen. Beispiel für den Fehler: PROGRAM PL...", 
"body" : "C0124 Meldung : ‚Initialisierung‘ ist keine gültige Initialisierung für eine Enumeration Mögliche Fehlerursache : Für die Enum-Initialisierung wird ein Datentyp verwendet, der kein ANY_INT ist. Fehlerbehebung : Verwenden Sie nur ANY_INT für Enum-Initialisierungen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : DUT;\nEND_VAR\n\nTYPE DUT :\n(\n enum_member := 1.5\n) DWORD;\nEND_TYPE\n Meldung: C0032: Typ 'LREAL' kann nicht in Typ 'DUT' konvertiert werden C0124: 'Initialisierung' ist keine gültige Initialisierung für eine Enumeration " }, 
{ "title" : "Compilerfehler C0125 ", 
"url" : "_cds_error_c0125.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0125 ", 
"snippet" : "C0125 Meldung : Die Konstante <constant value> ist mehr als einer Enumeration zugewiesen. Mögliche Fehlerursache : Derselbe Wert wird zwei oder mehr Enumerationen zugewiesen. Fehlerbehebung : Weisen Sie den Enumerationen verschiedene Werte zu. Beispiel für den Fehler: PROGRAM PLC_PRG VAR inst : DUT;...", 
"body" : "C0125 Meldung : Die Konstante <constant value> ist mehr als einer Enumeration zugewiesen. Mögliche Fehlerursache : Derselbe Wert wird zwei oder mehr Enumerationen zugewiesen. Fehlerbehebung : Weisen Sie den Enumerationen verschiedene Werte zu. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : DUT;\nEND_VAR\n\nTYPE DUT :\n(\n enum_member := 0,\n enum_member2 := 0\n);\nEND_TYPE\n Meldung: C0125: Die Konstante 0 ist mehr als einer Enumeration zugewiesen " }, 
{ "title" : "Compilerfehler C0126 ", 
"url" : "_cds_error_c0126.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0126 ", 
"snippet" : "C0126 Meldung : Variable vom Typ ‚<data type>‘ benötigt genau einen Index Mögliche Fehlerursache : Einer Variablen mit einem Index werden mehrere Indizes zugewiesen. Fehlerbehebung : Weisen Sie nur einen Index zu. Beispiel für den Fehler: PROGRAM PLC_PRG VAR pi : POINTER TO INT; END_VAR pi[0,1] := 0...", 
"body" : "C0126 Meldung : Variable vom Typ ‚<data type>‘ benötigt genau einen Index Mögliche Fehlerursache : Einer Variablen mit einem Index werden mehrere Indizes zugewiesen. Fehlerbehebung : Weisen Sie nur einen Index zu. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n pi : POINTER TO INT;\nEND_VAR\npi[0,1] := 0;\n Meldung: C0126: Variable vom Typ 'POINTER TO INT' benötigt genau einen Index Fehlerbehebung: pi[0] := 0; " }, 
{ "title" : "Compilerfehler C0130 ", 
"url" : "_cds_error_c0130.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0130 ", 
"snippet" : "C0130 Meldung : <object> ‚<object name>‘ ohne Klammern ‚()‘ referenziert Mögliche Fehlerursache : Eine Methode wird ohne Klammern referenziert. Fehlerbehebung : Referenzieren Sie Methoden immer mit Klammern. Beispiel für den Fehler: PROGRAM PLC_PRG VAR inst : FB; END_VAR inst.METH1 Meldung: C0130: M...", 
"body" : "C0130 Meldung : <object> ‚<object name>‘ ohne Klammern ‚()‘ referenziert Mögliche Fehlerursache : Eine Methode wird ohne Klammern referenziert. Fehlerbehebung : Referenzieren Sie Methoden immer mit Klammern. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\ninst.METH1\n Meldung: C0130: METHOD 'METH1' ohne Klammern '()' referenziert Fehlerbehebung: inst.METH1(); " }, 
{ "title" : "Compilerfehler C0131 ", 
"url" : "_cds_error_c0131.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0131 ", 
"snippet" : "C0131 Meldung : ‚<value>‘ ist als Operand für ‚ADR‘ nicht erlaubt Mögliche Fehlerursache : Dem Operator ADR wird eine Konstante als Operand gegeben. Fehlerbehebung : Verwenden Sie nur gültige Operanden für ADR. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i : INT; pt : POINTER TO INT; END_VAR pt := ...", 
"body" : "C0131 Meldung : ‚<value>‘ ist als Operand für ‚ADR‘ nicht erlaubt Mögliche Fehlerursache : Dem Operator ADR wird eine Konstante als Operand gegeben. Fehlerbehebung : Verwenden Sie nur gültige Operanden für ADR. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\n pt : POINTER TO INT;\nEND_VAR\n\npt := ADR(1);\n Meldung: C0131: '1' ist als Operand für 'ADR' nicht erlaubt Fehlerbehebung: pt := ADR(i); " }, 
{ "title" : "Compilerfehler C0132 ", 
"url" : "_cds_error_c0132.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0132 ", 
"snippet" : "C0132 Meldung : Keine umschließende Schleifenanweisung auf die EXIT angewendet werden kann Mögliche Fehlerursache : EXIT wird außerhalb einer Schleife verwendet. Fehlerbehebung : Verwenden Sie EXIT nur innerhalb von Schleifen. Beispiel für den Fehler: PROGRAM PLC_PRG VAR END_VAR EXIT ; Meldung: C013...", 
"body" : "C0132 Meldung : Keine umschließende Schleifenanweisung auf die EXIT angewendet werden kann Mögliche Fehlerursache : EXIT wird außerhalb einer Schleife verwendet. Fehlerbehebung : Verwenden Sie EXIT nur innerhalb von Schleifen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nEXIT\n;\n Meldung: C0132: Keine umschließende Schleifenanweisung auf die EXIT angewendet werden kann " }, 
{ "title" : "Compilerfehler C0136 ", 
"url" : "_cds_error_c0136.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0136 ", 
"snippet" : "C0136 Meldung : nicht eindeutige Verwendung des Namens ‚<variable name>‘ Mögliche Fehlerursache : Eine Variable ist in mehreren GVLs deklariert. Fehlerbehebung : Qualifizieren Sie die Variable mit der gewünschten GVL. Beispiel für den Fehler: PROGRAM PLC_PRG VAR j : INT := g_i; END_VAR GVL1: VAR_GLO...", 
"body" : "C0136 Meldung : nicht eindeutige Verwendung des Namens ‚<variable name>‘ Mögliche Fehlerursache : Eine Variable ist in mehreren GVLs deklariert. Fehlerbehebung : Qualifizieren Sie die Variable mit der gewünschten GVL. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n j : INT := g_i;\nEND_VAR\n\nGVL1:\nVAR_GLOBAL\n g_i : INT;\nEND_VAR\n\nGVL2:\nVAR_GLOBAL\n g_i : INT;\nEND_VAR\n\n--> C0136: nicht eindeutige Verwendung des Namens 'g_i' Fehlerbehebung: Beispiel:\nj : INT := GVL1.g_i; Beim Auftreten dieses Fehlers werden im Meldungsfenster alle Positionen der Mehrfachverwendung ausgegeben (C0181). " }, 
{ "title" : "Compilerfehler C0138 ", 
"url" : "_cds_error_c0138.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0138 ", 
"snippet" : "C0138 Meldung : Keine entsprechende ‚FB_Init‘-Methode für Instanzierung von POU gefunden. Mögliche Fehlerursache : Es existiert keine FB_Init -Methode, die die übergebenen Parameter akzeptiert. Fehlerbehebung : Überprüfen Sie, welche Argumente FB_Init erhalten muss und passen Sie die übergebenen Arg...", 
"body" : "C0138 Meldung : Keine entsprechende ‚FB_Init‘-Methode für Instanzierung von POU gefunden. Mögliche Fehlerursache : Es existiert keine FB_Init -Methode, die die übergebenen Parameter akzeptiert. Fehlerbehebung : Überprüfen Sie, welche Argumente FB_Init erhalten muss und passen Sie die übergebenen Argumente an. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n myPOU : POU(arg1 := 1, arg2 := 2);\nEND_VAR\n Meldung: C0138: Keine entsprechende ‚FB_Init‘-Methode für Instanzierung von POU gefunden. " }, 
{ "title" : "Compilerfehler C0139 ", 
"url" : "_cds_error_c0139.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0139 ", 
"snippet" : "C0139 Meldung : Code <code> hat keinen Effekt. Ist dies beabsichtigt? Mögliche Fehlerursache : Der geschriebene Code ist syntaktisch korrekt, aber erfüllt keinen Zweck. Fehlerbehebung : Schreiben Sie Code, der einen Zweck erfüllt. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i : INT; END_VAR i; Meld...", 
"body" : "C0139 Meldung : Code <code> hat keinen Effekt. Ist dies beabsichtigt? Mögliche Fehlerursache : Der geschriebene Code ist syntaktisch korrekt, aber erfüllt keinen Zweck. Fehlerbehebung : Schreiben Sie Code, der einen Zweck erfüllt. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\n\ni;\n Meldung: C0139: Code 'i;' hat keinen Effekt. Ist dies beabsichtigt? " }, 
{ "title" : "Compilerfehler C0140 ", 
"url" : "_cds_error_c0140.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0140 ", 
"snippet" : "C0140 Meldung : Referenzzuweisung ist nur für Variablen von Referenztypen erlaubt Mögliche Fehlerursache : Es wird versucht, einer nicht als Referenztyp definierten Variable einen Referenzwert zuzuweisen. Fehlerbehebung : Definieren Sie die Variable als Referenztyp. Beispiel für den Fehler: PROGRAM ...", 
"body" : "C0140 Meldung : Referenzzuweisung ist nur für Variablen von Referenztypen erlaubt Mögliche Fehlerursache : Es wird versucht, einer nicht als Referenztyp definierten Variable einen Referenzwert zuzuweisen. Fehlerbehebung : Definieren Sie die Variable als Referenztyp. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\n I_r : INT;\nEND_VAR\n\nI_r REF= i;\n Meldung: C0140: Referenzzuweisung ist nur für Variablen von Referenztypen erlaubt Fehlerbehebung: I_r : REFERENCE TO INT; " }, 
{ "title" : "Compilerfehler C0141 ", 
"url" : "_cds_error_c0141.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0141 ", 
"snippet" : "C0141 Meldung : Referenzzuweisung benötigt eine Variable mit Schreibzugriff Mögliche Fehlerursache : Der Referenzzuweisung wird eine Konstante zugewiesen. Fehlerbehebung : Weisen Sie eine beschreibbare Variable zu. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i : INT; I_r : REFERENCE TO INT; END_VAR...", 
"body" : "C0141 Meldung : Referenzzuweisung benötigt eine Variable mit Schreibzugriff Mögliche Fehlerursache : Der Referenzzuweisung wird eine Konstante zugewiesen. Fehlerbehebung : Weisen Sie eine beschreibbare Variable zu. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\n I_r : REFERENCE TO INT;\nEND_VAR\n\nI_r REF= 314;\n Meldung: C0141: Referenzzuweisung benötigt eine Variable mit Schreibzugriff Fehlerbehebung: I_r REF= i; " }, 
{ "title" : "Compilerfehler C0142 ", 
"url" : "_cds_error_c0142.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0142 ", 
"snippet" : "C0142 Meldung : Eine lokale Variable mit dem Namen ‚<variable name>‘ ist bereits in ‚<pou name>‘ definiert Mögliche Fehlerursache : Der gleiche Variablenname wird zweimal verwendet. Fehlerbehebung : Verwenden Sie unterschiedliche Variablennamen. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i : INT; ...", 
"body" : "C0142 Meldung : Eine lokale Variable mit dem Namen ‚<variable name>‘ ist bereits in ‚<pou name>‘ definiert Mögliche Fehlerursache : Der gleiche Variablenname wird zweimal verwendet. Fehlerbehebung : Verwenden Sie unterschiedliche Variablennamen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\n i : INT;\nEND_VAR\n Meldung: C0142: Eine lokale Variable mit dem Namen 'i' ist bereits in 'PLC_PRG' definiert " }, 
{ "title" : "Compilerfehler C0143 ", 
"url" : "_cds_error_c0143.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0143 ", 
"snippet" : "C0143 Meldung : Die Eigenschaft ‚<property name>‘ kann in diesem Zusammenhang nicht verwendet werden, da sie keine Get-Zugriffsdefinition besitzt Mögliche Fehlerursache : Der Eigenschaft fehlt der Get-Zugriff. Fehlerbehebung : Achten Sie darauf, dass die Eigenschaft eine Get-Zugriffsdefinition besit...", 
"body" : "C0143 Meldung : Die Eigenschaft ‚<property name>‘ kann in diesem Zusammenhang nicht verwendet werden, da sie keine Get-Zugriffsdefinition besitzt Mögliche Fehlerursache : Der Eigenschaft fehlt der Get-Zugriff. Fehlerbehebung : Achten Sie darauf, dass die Eigenschaft eine Get-Zugriffsdefinition besitzt. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\n inst: FB;\nEND_VAR\n\ni := inst.Prop;\n\nFUNCTION_BLOCK FB\nVAR\nEND_VAR\n\nPROPERTY Prop : INT\nSet;\n Meldung: C0143: Die Eigenschaft 'Prop' kann in diesem Zusammenhang nicht verwendet werden, da sie keine Get-Zugriffsdefinition besitzt " }, 
{ "title" : "Compilerfehler C0144 ", 
"url" : "_cds_error_c0144.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0144 ", 
"snippet" : "C0144 Meldung : Vererbung ist nur in Funktionsbausteinen, Schnittstellen und Strukturen erlaubt Mögliche Fehlerursache : Es wird versucht, Vererbung in einem Objekt zu verwenden, das keine Vererbung erlaubt. Fehlerbehebung : Verwenden Sie EXTENDS nur in Funktionsbausteinen, Schnittstellen und Strukt...", 
"body" : "C0144 Meldung : Vererbung ist nur in Funktionsbausteinen, Schnittstellen und Strukturen erlaubt Mögliche Fehlerursache : Es wird versucht, Vererbung in einem Objekt zu verwenden, das keine Vererbung erlaubt. Fehlerbehebung : Verwenden Sie EXTENDS nur in Funktionsbausteinen, Schnittstellen und Strukturen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : DUT_1;\nEND_VAR\n\nTYPE DUT:\n(\n enum_member := 0\n);\nEND_TYPE\n\nTYPE DUT_1 EXTENDS DUT:\n(\n enum_memberX := 0\n);\nEND_TYPE\n Meldung: C0144: Vererbung ist nur in Funktionsbausteinen, Schnittstellen und Strukturen erlaubt " }, 
{ "title" : "Compilerfehler C0145 ", 
"url" : "_cds_error_c0145.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0145 ", 
"snippet" : "C0145 Meldung : Schnittstellen können nur von Funktionsbausteinen implementiert werden Mögliche Fehlerursache : Es wird versucht, eine Schnittstelle außerhalb eines Funktionsbausteins zu implementieren. Fehlerbehebung : Implementieren Sie Schnittstellen nur in Funktionsbausteinen. Beispiel für den F...", 
"body" : "C0145 Meldung : Schnittstellen können nur von Funktionsbausteinen implementiert werden Mögliche Fehlerursache : Es wird versucht, eine Schnittstelle außerhalb eines Funktionsbausteins zu implementieren. Fehlerbehebung : Implementieren Sie Schnittstellen nur in Funktionsbausteinen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nPOU();\n\nFUNCTION POU IMPLEMENTS ITF\nVAR\nEND_VAR\n Meldung: C0145: Schnittstellen können nur von Funktionsbausteinen implementiert werden " }, 
{ "title" : "Compilerfehler C0149 ", 
"url" : "_cds_error_c0149.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0149 ", 
"snippet" : "C0149 Meldung : Variablendeklarationen in Schnittstellendefinitionen nicht erlaubt Mögliche Fehlerursache : Es wird versucht, in einer Schnittstelle eine Variable zu definieren. Fehlerbehebung : Definieren Sie keine Variablen in Schnittstellen. Beispiel für den Fehler: PROGRAM PLC_PRG VAR inst : ITF...", 
"body" : "C0149 Meldung : Variablendeklarationen in Schnittstellendefinitionen nicht erlaubt Mögliche Fehlerursache : Es wird versucht, in einer Schnittstelle eine Variable zu definieren. Fehlerbehebung : Definieren Sie keine Variablen in Schnittstellen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : ITF;\nEND_VAR\n\nINTERFACE ITF\nVAR_INPUT\n i : INT;\nEND_VAR\n Meldung: C0149: Variablendeklarationen in Schnittstellendefinitionen nicht erlaubt " }, 
{ "title" : "Compilerfehler C0161 ", 
"url" : "_cds_error_c0161.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0161 ", 
"snippet" : "C0161 Meldung : Datenfeldbereichsgrenze <array bound> ist kein konstanter Wert Mögliche Fehlerursache : Als Arraygrenze ist eine Variable angegeben. Fehlerbehebung : Verwenden Sie Konstanten für die Arraygrenzen. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i : INT := 3; arr1 : ARRAY[1..i] OF INT; E...", 
"body" : "C0161 Meldung : Datenfeldbereichsgrenze <array bound> ist kein konstanter Wert Mögliche Fehlerursache : Als Arraygrenze ist eine Variable angegeben. Fehlerbehebung : Verwenden Sie Konstanten für die Arraygrenzen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT := 3;\n arr1 : ARRAY[1..i] OF INT;\nEND_VAR\n Meldung: C0161: Datenfeldbereichsgrenze 'i' ist kein konstanter Wert Fehlerbehebung: arr1 : ARRAY[1..3] OF INT; " }, 
{ "title" : "Compilerfehler C0162 ", 
"url" : "_cds_error_c0162.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0162 ", 
"snippet" : "C0162 Meldung : Nummer <number of array values> der Arrayinitialisierung ist kein konstanter Wert Mögliche Fehlerursache : Die Initialisierung [Wert1,AnzahlWert2(Wert2)] funktioniert nur mit einer Konstante für AnzahlWert2 . Fehlerbehebung : Verwenden Sie nur Konstanten. Beispiel für den Fehler: PRO...", 
"body" : "C0162 Meldung : Nummer <number of array values> der Arrayinitialisierung ist kein konstanter Wert Mögliche Fehlerursache : Die Initialisierung [Wert1,AnzahlWert2(Wert2)] funktioniert nur mit einer Konstante für AnzahlWert2 . Fehlerbehebung : Verwenden Sie nur Konstanten. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT := 3;\n arr1 : ARRAY[1..4] OF INT := [1,i(7)];\nEND_VAR\n Meldung: C0162: Nummer 'i' der Arrayinitialisierung ist kein konstanter Wert Fehlerbehebung: arr1 : ARRAY[1..4] OF INT := [1,3(7)]; " }, 
{ "title" : "Compilerfehler C0164 ", 
"url" : "_cds_error_c0164.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0164 ", 
"snippet" : "C0164 Meldung : Baustein <name> schreibt auf Ausgang <name> und wird in mehreren Tasks aufgerufen. Mögliche Fehlerursache : Die Geräteeinstellung codegenerator\\check-multiple-task-output-write ist gesetzt und mehrere Tasks greifen auf den gleichen Ausgang zu.. Fehlerbehebung : Rufen Sie ein Programm...", 
"body" : "C0164 Meldung : Baustein <name> schreibt auf Ausgang <name> und wird in mehreren Tasks aufgerufen. Mögliche Fehlerursache : Die Geräteeinstellung codegenerator\\check-multiple-task-output-write ist gesetzt und mehrere Tasks greifen auf den gleichen Ausgang zu.. Fehlerbehebung : Rufen Sie ein Programm, das Ausgänge verändert, nicht in mehreren Tasks aufs. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n Output AT %QB7 : BYTE\nEND_VAR\n\nOutput := 0;\n Meldung: C0164: Baustein PLC_PRG schreibt auf Ausgang QB7 und wird in mehreren Tasks aufgerufen " }, 
{ "title" : "Compilerfehler C0165 ", 
"url" : "_cds_error_c0165.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0165 ", 
"snippet" : "C0165 Meldung : Variable ‚<variable name>‘, welche auf Adresse ‚<address>‘ gemappt ist, wird in verschiedenen Tasks geschrieben. Mögliche Fehlerursache : Die Geräteeinstellung codegenerator\\\\check-multiple-task-output-write ist gesetzt und mehrere Tasks greifen auf den gleichen Ausgang zu. Fehlerbeh...", 
"body" : "C0165 Meldung : Variable ‚<variable name>‘, welche auf Adresse ‚<address>‘ gemappt ist, wird in verschiedenen Tasks geschrieben. Mögliche Fehlerursache : Die Geräteeinstellung codegenerator\\\\check-multiple-task-output-write ist gesetzt und mehrere Tasks greifen auf den gleichen Ausgang zu. Fehlerbehebung : Schreiben Sie einen Ausgang nur in einer festen Task. Sollen mehrere Tasks Daten für einen Ausgang berechnen, sollten Sie versuchen diese Information mittels globaler Variablen an eine feste Task zu übertragen, die die Daten dann auf einen Ausgang schreibt. Beispiel für den Fehler: PROGRAM PLC_PRG_1\nVAR\n Output AT %QB7 : BYTE;\nEND_VAR\nOutput := 0;\n\nPROGRAM PLC_PRG_2\nVAR\n Output AT %QB7 : BYTE;\nEND_VAR\nOutput := 1;\n Meldung: C0165: Variable Output, welche auf Adresse QB7 gemappt ist, wird in verschiedenen Tasks geschrieben. " }, 
{ "title" : "Compilerfehler C0168 ", 
"url" : "_cds_error_c0168.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0168 ", 
"snippet" : "C0168 Meldung : ‚VAR_CONFIG‘-Deklaration ist nur in VAR_CONFIG-Liste erlaubt Mögliche Fehlerursache : ‚VAR_CONFIG‘ wird außerhalb einer VAR_CONFIG-Liste verwendet. Fehlerbehebung : Verwenden Sie ‚VAR_CONFIG‘ nur in VAR_CONFIG-Listen. Beispiel für den Fehler: PROGRAM PLC_PRG VAR_CONFIG i : INT; END_V...", 
"body" : "C0168 Meldung : ‚VAR_CONFIG‘-Deklaration ist nur in VAR_CONFIG-Liste erlaubt Mögliche Fehlerursache : ‚VAR_CONFIG‘ wird außerhalb einer VAR_CONFIG-Liste verwendet. Fehlerbehebung : Verwenden Sie ‚VAR_CONFIG‘ nur in VAR_CONFIG-Listen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR_CONFIG\n i : INT;\nEND_VAR\n Meldung: C0168: 'VAR_CONFIG'-Deklaration ist nur in VAR_CONFIG-Liste erlaubt " }, 
{ "title" : "Compilerfehler C0169 ", 
"url" : "_cds_error_c0169.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0169 ", 
"snippet" : "C0169 Meldung : ‚VAR_GLOBAL‘-Deklaration ist nur in globalen Variablenlisten erlaubt Mögliche Fehlerursache : ‚VAR_GLOBAL‘ wird außerhalb von globalen Variablenlisten verwendet. Fehlerbehebung : Verwenden Sie ‚VAR_GLOBAL‘ nur in globalen Variablenlisten. Beispiel für den Fehler: PROGRAM PLC_PRG VAR_...", 
"body" : "C0169 Meldung : ‚VAR_GLOBAL‘-Deklaration ist nur in globalen Variablenlisten erlaubt Mögliche Fehlerursache : ‚VAR_GLOBAL‘ wird außerhalb von globalen Variablenlisten verwendet. Fehlerbehebung : Verwenden Sie ‚VAR_GLOBAL‘ nur in globalen Variablenlisten. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR_GLOBAL\n i : INT;\nEND_VAR\n Meldung: C0169: 'VAR_GLOBAL'-Deklaration ist nur in globalen Variablenlisten erlaubt " }, 
{ "title" : "Compilerfehler C0173 ", 
"url" : "_cds_error_c0173.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0173 ", 
"snippet" : "C0173 Meldung : ‚<keyword>‘ ist an dieser Stelle nicht erlaubt Mögliche Fehlerursache : Ein Deklarationsschlüsselwort (beispielsweise VAR_INPUT , VAR_OUTPUT , VAR ) ist an dieser Stelle nicht erlaubt. Fehlerbehebung : Korrigieren Sie die Deklaration: Eingänge und Ausgänge sind in Typdefinitionen ode...", 
"body" : "C0173 Meldung : ‚<keyword>‘ ist an dieser Stelle nicht erlaubt Mögliche Fehlerursache : Ein Deklarationsschlüsselwort (beispielsweise VAR_INPUT , VAR_OUTPUT , VAR ) ist an dieser Stelle nicht erlaubt. Fehlerbehebung : Korrigieren Sie die Deklaration: Eingänge und Ausgänge sind in Typdefinitionen oder Globalen Variablenlisten nicht sinnvoll oder nötig. Beispiel für den Fehler: TYPE DUT :\nSTRUCT\n VAR_INPUT\n member : INT;\n END_VAR\nEND_STRUCT\nEND_TYPE\n Meldung: C0173: 'VAR_INPUT' ist an dieser Stelle nicht erlaubt. Fehlerbehebung: Beispiel:\nTYPE DUT :\nSTRUCT\n member : INT;\nEND_STRUCT\nEND_TYPE " }, 
{ "title" : "Compilerfehler C0174 ", 
"url" : "_cds_error_c0174.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0174 ", 
"snippet" : "C0174 Meldung : ‚VAR_TEMP‘-Deklaration an dieser Stelle nicht erlaubt Mögliche Fehlerursache : ‚VAR_TEMP‘ wird außerhalb eines Programms oder Funktionsbausteins verwendet. Fehlerbehebung : Verwenden Sie ‚VAR_TEMP‘ nur innerhalb von Programmen und Funktionsbausteinen. Beispiel für den Fehler: PROGRAM...", 
"body" : "C0174 Meldung : ‚VAR_TEMP‘-Deklaration an dieser Stelle nicht erlaubt Mögliche Fehlerursache : ‚VAR_TEMP‘ wird außerhalb eines Programms oder Funktionsbausteins verwendet. Fehlerbehebung : Verwenden Sie ‚VAR_TEMP‘ nur innerhalb von Programmen und Funktionsbausteinen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nFUN();\n\nFUNCTION FUN\nVAR_TEMP\nEND_VAR\n Meldung: C0174: 'VAR_TEMP'-Deklaration an dieser Stelle nicht erlaubt " }, 
{ "title" : "Compilerfehler C0175 ", 
"url" : "_cds_error_c0175.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0175 ", 
"snippet" : "C0175 Meldung : ‚RETAIN‘ oder ‚PERSISTENT‘ sind an dieser Stelle nicht erlaubt Mögliche Fehlerursache : ‚RETAIN‘ oder ‚PERSISTENT‘ wird in einer Funktion verwendet. Fehlerbehebung : ‚RETAIN‘ oder ‚PERSISTENT‘ an den dafür vorgesehenen Stellen verwenden. Beispiel für den Fehler: PROGRAM PLC_PRG VAR E...", 
"body" : "C0175 Meldung : ‚RETAIN‘ oder ‚PERSISTENT‘ sind an dieser Stelle nicht erlaubt Mögliche Fehlerursache : ‚RETAIN‘ oder ‚PERSISTENT‘ wird in einer Funktion verwendet. Fehlerbehebung : ‚RETAIN‘ oder ‚PERSISTENT‘ an den dafür vorgesehenen Stellen verwenden. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nPOU_1();\n\nFUNCTION POU_1\nVAR RETAIN\nEND_VAR\n Meldung: C0175: 'RETAIN' oder 'PERSISTENT' sind an dieser Stelle nicht erlaubt " }, 
{ "title" : "Compilerfehler C0177 ", 
"url" : "_cds_error_c0177.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0177 ", 
"snippet" : "C0177 Meldung : ‚<object>‘ ist vom Typ ‚<type>‘ und kann nicht instanziiert werden Mögliche Fehlerursache : Es wird versucht, eine Funktion zu instanziieren. Fehlerbehebung : Instanziieren Sie nur Objekte, die instanziiert werden können. Beispiel für den Fehler: PROGRAM PLC_PRG VAR inst : POU; END_V...", 
"body" : "C0177 Meldung : ‚<object>‘ ist vom Typ ‚<type>‘ und kann nicht instanziiert werden Mögliche Fehlerursache : Es wird versucht, eine Funktion zu instanziieren. Fehlerbehebung : Instanziieren Sie nur Objekte, die instanziiert werden können. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : POU;\nEND_VAR\n\nFUNCTION POU\nVAR\nEND_VAR\n Meldung: C0177: 'POU' ist vom Typ 'FUNCTION' und kann nicht instanziert werden " }, 
{ "title" : "Compilerfehler C0178 ", 
"url" : "_cds_error_c0178.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0178 ", 
"snippet" : "C0178 Meldung : Externer Zugriff auf ‚VAR_IN_OUT‘-Parameter ‚<parameter name>‘ von ‚<object name>‘ Mögliche Fehlerursache : Es wird versucht, extern auf einen ‚VAR_IN_OUT‘-Parameter zuzugreifen. Fehlerbehebung : Greifen Sie nicht extern auf ‚VAR_IN_OUT‘-Parameter zu. Beispiel für den Fehler: PROGRAM...", 
"body" : "C0178 Meldung : Externer Zugriff auf ‚VAR_IN_OUT‘-Parameter ‚<parameter name>‘ von ‚<object name>‘ Mögliche Fehlerursache : Es wird versucht, extern auf einen ‚VAR_IN_OUT‘-Parameter zuzugreifen. Fehlerbehebung : Greifen Sie nicht extern auf ‚VAR_IN_OUT‘-Parameter zu. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : FB;\n i : INT;\nEND_VAR\ni := inst.in_out;\n\nFUNCTION_BLOCK FB\nVAR_IN_OUT\n in_out : INT;\nEND_VAR\n Meldung: C0178: Externer Zugriff auf 'VAR_IN_OUT'-Parameter 'in_out' von 'FB' " }, 
{ "title" : "Compilerfehler C0179 ", 
"url" : "_cds_error_c0179.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0179 ", 
"snippet" : "C0179 Meldung : ‚<identifier>‘ ist kein Eingang von ‚Funktionsblock‘ Mögliche Fehlerursache : Die Initialisierung einer Funktionsbaustein-Instanzen darf keine VAR_IN_OUT -Variablen enthalten. Fehlerbehebung : Verwenden Sie VAR_IN_OUT -Variablen nur in Aufrufen eines Funktionsbausteins. Weisen Sie in...", 
"body" : "C0179 Meldung : ‚<identifier>‘ ist kein Eingang von ‚Funktionsblock‘ Mögliche Fehlerursache : Die Initialisierung einer Funktionsbaustein-Instanzen darf keine VAR_IN_OUT -Variablen enthalten. Fehlerbehebung : Verwenden Sie VAR_IN_OUT -Variablen nur in Aufrufen eines Funktionsbausteins. Weisen Sie in der Initialisierung einer Funktionsbaustein-Instanz nur die Eingänge eines Funktionsbausteins zu. Beispiel für den Fehler: Beispiel:\nFUNCTION_BLOCK MyFB\nVAR_IN_OUT\n inOut : INT;\nEND_VAR\n\nPROGRAM PLC_PRG\nVAR\n iValue : INT;\n fb : MyFB := (inOut := iValue);\nEND_VAR\n Meldung: C0179: 'inOut' ist kein Eingang von 'MyFB' " }, 
{ "title" : "Compilerfehler C0180 ", 
"url" : "_cds_error_c0180.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0180 ", 
"snippet" : "C0180 Meldung : Nicht eindeutiger Namensraum ‚<library 1>‘ definiert von Bibliothek ‚<library 2>‘ Mögliche Fehlerursache : Der Namensraum der <library 1> ist nicht eindeutig, er wird bereits für <library 2> verwendet. Fehlerbehebung : Ändern Sie entsprechend den Namensraum der Bibliothek (Schaltfläc...", 
"body" : "C0180 Meldung : Nicht eindeutiger Namensraum ‚<library 1>‘ definiert von Bibliothek ‚<library 2>‘ Mögliche Fehlerursache : Der Namensraum der <library 1> ist nicht eindeutig, er wird bereits für <library 2> verwendet. Fehlerbehebung : Ändern Sie entsprechend den Namensraum der Bibliothek (Schaltfläche Eigenschaften im Bibliotheksverwalter. Beispiel für den Fehler: Meldung: C0180: Nicht eindeutiger Namensraum 'STANDARD' definiert von Bibliothek 'Standard, 3.5.15.0 (System)' " }, 
{ "title" : "Compilerfehler C0182 ", 
"url" : "_cds_error_c0182.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0182 ", 
"snippet" : "C0182 Meldung : Rückgabetyp ist nur für Funktionen und Methoden erlaubt Mögliche Fehlerursache : Es wird versucht, in einem Programm einen Rückgabetyp zu definieren. Fehlerbehebung : Definieren Sie einen Rückgabetyp nur in Methoden und Funktionen. Beispiel für den Fehler: Beispiel für den Fehler: PR...", 
"body" : "C0182 Meldung : Rückgabetyp ist nur für Funktionen und Methoden erlaubt Mögliche Fehlerursache : Es wird versucht, in einem Programm einen Rückgabetyp zu definieren. Fehlerbehebung : Definieren Sie einen Rückgabetyp nur in Methoden und Funktionen. Beispiel für den Fehler: Beispiel für den Fehler: PROGRAM PLC_PRG : BOOL\nVAR\nEND_VAR\n Meldung: C0182: Rückgabetyp ist nur für Funktionen und Methoden erlaubt " }, 
{ "title" : "Compilerfehler C0183 ", 
"url" : "_cds_error_c0183.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0183 ", 
"snippet" : "C0183 Meldung : Globaler Bereichsoperator ‚.‘ kann nicht auf Ausdruck ‚<expression>‘ angewendet werden Mögliche Fehlerursache : Der ‚.‘-Operator soll dem Zugriff auf eine globale Variable dienen. Ihm folgt jedoch an dieser Stelle kein gültiger IEC-Bezeichner, sondern beispielsweise ein Zeichen wie „...", 
"body" : "C0183 Meldung : Globaler Bereichsoperator ‚.‘ kann nicht auf Ausdruck ‚<expression>‘ angewendet werden Mögliche Fehlerursache : Der ‚.‘-Operator soll dem Zugriff auf eine globale Variable dienen. Ihm folgt jedoch an dieser Stelle kein gültiger IEC-Bezeichner, sondern beispielsweise ein Zeichen wie „;“ oder ein reservierter Bezeichner wie FUNCTION , oder ein Operator wie TO_STRING . Fehlerbehebung : Setzen Sie einen gültigen IEC-Bezeichner für eine globale Variable ein. Beispiel für den Fehler: PROGRAM PLC_PRG\n...\n\niVar := .FUNCTION;\nstrVar := .TO_STRING; Meldung: C0183: Globaler Bereichsoperator '.' kann nicht auf Ausdruck '<expression>' angewendet werden Fehlerbehebung: Beispiel: globalValue ist in einer GVL deklariert. PROGRAM PLC_PRG\niVar := .globalValue; " }, 
{ "title" : "Compilerfehler C0185 ", 
"url" : "_cds_error_c0185.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0185 ", 
"snippet" : "C0185 Meldung : Es ist nicht möglich, auf das Ergebnis eines Funktionsaufrufs einen Komponentenzugriff ‚.‘, einen Indexzugriff ‚[]‘ oder einen Aufruf ‚()‘ des Ergebnisses eines Funktionsaufrufs durchzuführen. Weisen Sie zuerst das Ergebnis einer Variablen zu Mögliche Fehlerursache : Es wird ein Komp...", 
"body" : "C0185 Meldung : Es ist nicht möglich, auf das Ergebnis eines Funktionsaufrufs einen Komponentenzugriff ‚.‘, einen Indexzugriff ‚[]‘ oder einen Aufruf ‚()‘ des Ergebnisses eines Funktionsaufrufs durchzuführen. Weisen Sie zuerst das Ergebnis einer Variablen zu Mögliche Fehlerursache : Es wird ein Komponenten- oder Indexzugriff auf das Ergebnis eines Funktionsaufrufs durchgeführt. Fehlerbehebung : Weisen Sie für den Zugriff das Ergebnis einer Variablen zu. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n it : ITF;\nEND_VAR\n\nPOU_1()[0].METH1();\n\nFUNCTION POU_1 : ARRAY[0..0] OF ITF\n\nINTERFACE ITF\n\nMETHOD METH1\n Meldung: C0185: Es ist nicht möglich, auf das Ergebnis eines Funktionsaufrufs einen Komponentenzugriff '.', einen Indexzugriff '[]' oder einen Aufruf '()' des Ergebnisses eines Funktionsaufrufs durchzuführen. Weisen Sie zuerst das Ergebnis einer Variablen zu " }, 
{ "title" : "Compilerfehler C0186 ", 
"url" : "_cds_error_c0186.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0186 ", 
"snippet" : "C0186 Meldung : Eine Schnittstelle, die ein Rückgabewert eines Aufrufs ist, kann nicht verglichen werden. Weisen Sie diese zuerst einer Variablen zu. Mögliche Fehlerursache : Eine Vergleichsoperation wird auf eine Schnittstelle angewendet, die von einer Funktion zurückgegeben wird. Fehlerbehebung : ...", 
"body" : "C0186 Meldung : Eine Schnittstelle, die ein Rückgabewert eines Aufrufs ist, kann nicht verglichen werden. Weisen Sie diese zuerst einer Variablen zu. Mögliche Fehlerursache : Eine Vergleichsoperation wird auf eine Schnittstelle angewendet, die von einer Funktion zurückgegeben wird. Fehlerbehebung : Weisen Sie das Ergebnis des Funktionsaufrufes zuerst einer Variablen zu und vergleichen Sie dann den Wert der Variablen. Dadurch wird auch die Anzahl der nötigen Funktionsaufrufe reduziert. Beispiel für den Fehler: INTERFACE MyInterface\n\nFUNCTION GetInterface : MyInterface\n\nPROGRAM PLC_PRG\nIF GetInterface() <> 0 THEN\n \/\/ ...\nEND_IF\n Meldung: C0186: Eine Schnittstelle, die ein Rückgabewert eines Aufrufs ist, kann nicht verglichen werden. Weisen Sie diese zuerst einer Variablen zu. Fehlerbehebung: PROGRAM PLC_PRG\nVAR_TEMP\n tempInterface : MyInterface;\nEND_VAR\ntempInterface := GetInterface();\nIF tempInterface <> 0 THEN\n \/\/ ...\nEND_IF " }, 
{ "title" : "Compilerwarnung C0187 ", 
"url" : "_cds_error_c0187.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0187 ", 
"snippet" : "C0187 Meldung : Externe Referenzen sind nur für Funktionsbausteine, Methoden, Funktionen und konstante globale Variablenlisten erlaubt. Externe Referenz PROGRAM für '<program name>' wird ignoriert. Mögliche Fehlerursache : Im Eigenschaftendialog eines Programms ist in der Registerkarte Build die Opt...", 
"body" : "C0187 Meldung : Externe Referenzen sind nur für Funktionsbausteine, Methoden, Funktionen und konstante globale Variablenlisten erlaubt. Externe Referenz PROGRAM für '<program name>' wird ignoriert. Mögliche Fehlerursache : Im Eigenschaftendialog eines Programms ist in der Registerkarte Build die Option Externe Implementierung aktiviert. Fehlerbehebung : Deaktivieren Sie die Option Externe Implementierung . " }, 
{ "title" : "Compilerfehler C0188 ", 
"url" : "_cds_error_c0188.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0188 ", 
"snippet" : "C0188 Meldung : Das Gerät ist in der Installation nicht verfügbar. Keine Codeerzeugung möglich. Mögliche Fehlerursache : Das gewünschte Gerät ist nicht installiert. Fehlerbehebung : Installieren Sie das fehlende Gerät ins Geräte-Repository oder ersetzen Sie das bereits im Gerätebaum eingehängte Gerä...", 
"body" : "C0188 Meldung : Das Gerät ist in der Installation nicht verfügbar. Keine Codeerzeugung möglich. Mögliche Fehlerursache : Das gewünschte Gerät ist nicht installiert. Fehlerbehebung : Installieren Sie das fehlende Gerät ins Geräte-Repository oder ersetzen Sie das bereits im Gerätebaum eingehängte Gerät mit einem anderen, bereits installierten Gerät ( Gerät aktualisieren ). " }, 
{ "title" : "Compilerfehler C0189 ", 
"url" : "_cds_error_c0189.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0189 ", 
"snippet" : "C0189 Meldung : ‚;‘ anstatt ‚<token>‘ erwartet Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Achten Sie auf eine korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG VAR INT END_VAR Meldung: C0009: Unerwartetes Token '&lt;Token&gt;' gefunden C0189: ';' anstatt 'INT' erwartet....", 
"body" : "C0189 Meldung : ‚;‘ anstatt ‚<token>‘ erwartet Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Achten Sie auf eine korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n INT\nEND_VAR\n Meldung: C0009: Unerwartetes Token '&lt;Token&gt;' gefunden C0189: ';' anstatt 'INT' erwartet. " }, 
{ "title" : "Compilerfehler C0190 ", 
"url" : "_cds_error_c0190.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0190 ", 
"snippet" : "C0190 Meldung : ‚;‘ anstatt Ende der POU erwartet Mögliche Fehlerursache : Syntaxfehler in POU Fehlerbehebung : Achten Sie auf eine korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i : INT; END_VAR i := 5 Meldung: C0190: ';' anstatt Ende der POU erwartet...", 
"body" : "C0190 Meldung : ‚;‘ anstatt Ende der POU erwartet Mögliche Fehlerursache : Syntaxfehler in POU Fehlerbehebung : Achten Sie auf eine korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\ni := 5\n Meldung: C0190: ';' anstatt Ende der POU erwartet " }, 
{ "title" : "Compilerfehler C0191 ", 
"url" : "_cds_error_c0191.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0191 ", 
"snippet" : "C0191 Meldung : Der Operator ‚INDEXOF‘ wird nicht mehr unterstützt. Benützen Sie stattdessen ‚ADR‘. Wird ‚ADR‘ auf einen POU-Namen angewendet, so wird ein Zeiger auf den POU-Code zurückgeliefert Mögliche Fehlerursache : Es wird der veralteten Operator ‚INDEXOF‘ verwendet. Fehlerbehebung : Verwenden ...", 
"body" : "C0191 Meldung : Der Operator ‚INDEXOF‘ wird nicht mehr unterstützt. Benützen Sie stattdessen ‚ADR‘. Wird ‚ADR‘ auf einen POU-Namen angewendet, so wird ein Zeiger auf den POU-Code zurückgeliefert Mögliche Fehlerursache : Es wird der veralteten Operator ‚INDEXOF‘ verwendet. Fehlerbehebung : Verwenden Sie den Operator ‚ADR‘. " }, 
{ "title" : "Compilerfehler C0195 ", 
"url" : "_cds_error_c0195.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0195 ", 
"snippet" : "C0195 Meldung : Implizite Konvertierung von vorzeichenbehaftetem Datentyp ‚<data type 1>‘ nach nicht vorzeichenbehaftetem Datentyp ‚<data type 2>‘ : Möglicherweise Änderung des Vorzeichens Mögliche Fehlerursache : Bei der impliziten Konvertierung wird ein Vorzeichenkonflikt nicht berücksichtigt. Feh...", 
"body" : "C0195 Meldung : Implizite Konvertierung von vorzeichenbehaftetem Datentyp ‚<data type 1>‘ nach nicht vorzeichenbehaftetem Datentyp ‚<data type 2>‘ : Möglicherweise Änderung des Vorzeichens Mögliche Fehlerursache : Bei der impliziten Konvertierung wird ein Vorzeichenkonflikt nicht berücksichtigt. Fehlerbehebung : Konvertieren Sie nur Datentypen mit dem gleichen Vorzeichen implizit. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\n b : UINT;\nEND_VAR\n\nb := i;\n Meldung: C0195: Implizite Konvertierung von vorzeichenbehaftetem Datentyp 'INT' nach nicht vorzeichenbehaftetem Datentyp 'UINT' : Möglicherweise Änderung des Vorzeichens " }, 
{ "title" : "Compilerfehler C0196 ", 
"url" : "_cds_error_c0196.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0196 ", 
"snippet" : "C0196 Meldung : Implizite Konvertierung von nicht vorzeichenbehaftetem Datentyp ‚<data type 1>‘ nach vorzeichenbehaftetem Datentyp ‚<data type 2>‘ : Möglicherweise Verlust des Vorzeichens Mögliche Fehlerursache : Bei der impliziten Konvertierung wird ein Vorzeichenkonflikt eventuell nicht berücksich...", 
"body" : "C0196 Meldung : Implizite Konvertierung von nicht vorzeichenbehaftetem Datentyp ‚<data type 1>‘ nach vorzeichenbehaftetem Datentyp ‚<data type 2>‘ : Möglicherweise Verlust des Vorzeichens Mögliche Fehlerursache : Bei der impliziten Konvertierung wird ein Vorzeichenkonflikt eventuell nicht berücksichtigt. Fehlerbehebung : Verwenden Sie explizite Konvertierungen Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\n b : UINT;\nEND_VAR\n\ni := b;\n Meldung: C0196: Implizite Konvertierung von nicht vorzeichenbehaftetem Datentyp 'UINT' nach vorzeichenbehaftetem Datentyp 'INT' : Möglicherweise Verlust des Vorzeichens " }, 
{ "title" : "Compilerfehler C0197 ", 
"url" : "_cds_error_c0197.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0197 ", 
"snippet" : "C0197 Meldung : Implizite Konvertierung von ‚<data type 1>‘ nach ‚<data type 2>‘: Möglicher Datenverlust Mögliche Fehlerursache : Es wird versucht, eine Variable vom Datentyp DINT oder LINT in den Datentyp REAL implizit zu konvertieren. Fehlerbehebung : Verwenden Sie für DINT den Datentyp LREAL und ...", 
"body" : "C0197 Meldung : Implizite Konvertierung von ‚<data type 1>‘ nach ‚<data type 2>‘: Möglicher Datenverlust Mögliche Fehlerursache : Es wird versucht, eine Variable vom Datentyp DINT oder LINT in den Datentyp REAL implizit zu konvertieren. Fehlerbehebung : Verwenden Sie für DINT den Datentyp LREAL und achten Sie bei der Konvertierung von LINT auf LREAL, dass der Wert des LINT nicht die Kapazität des LREAL übersteigt. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : DINT;\n b : REAL;\nEND_VAR\nb := i;\n Meldung: C0197: Implizite Konvertierung von 'DINT' nach 'REAL': Möglicher Datenverlust " }, 
{ "title" : "Compilerfehler C0198 ", 
"url" : "_cds_error_c0198.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0198 ", 
"snippet" : "C0198 Meldung : Stringkonstante ‚<string value>‘ ist zu lang für Zieltyp ‚<data type>‘ Mögliche Fehlerursache : Stringkonstante hat zu viele Zeichen. Fehlerbehebung : Verwenden Sie kürzere Stringkonstanten oder deklarieren Sie größere Strings. Beispiel für den Fehler: PROGRAM PLC_PRG VAR str : STRIN...", 
"body" : "C0198 Meldung : Stringkonstante ‚<string value>‘ ist zu lang für Zieltyp ‚<data type>‘ Mögliche Fehlerursache : Stringkonstante hat zu viele Zeichen. Fehlerbehebung : Verwenden Sie kürzere Stringkonstanten oder deklarieren Sie größere Strings. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n str : STRING(4) := '12345';\nEND_VAR\n Meldung: C0198: String-Konstante '12345' ist zu lang für Zieltyp 'STRING(4)' " }, 
{ "title" : "Compilerfehler C0199 ", 
"url" : "_cds_error_c0199.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0199 ", 
"snippet" : "C0199 Meldung : Schnittstelle ‚<interface name>‘ muss instanziiert werden, um darauf zugreifen zu können Mögliche Fehlerursache : Es wird versucht, auf eine Schnittstellenmethode zuzugreifen, ohne dass die Schnittstelle instanziiert wurde. Fehlerbehebung : Instanziieren Sie die Schnittstelle. Beispi...", 
"body" : "C0199 Meldung : Schnittstelle ‚<interface name>‘ muss instanziiert werden, um darauf zugreifen zu können Mögliche Fehlerursache : Es wird versucht, auf eine Schnittstellenmethode zuzugreifen, ohne dass die Schnittstelle instanziiert wurde. Fehlerbehebung : Instanziieren Sie die Schnittstelle. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nITF.METH();\n\nINTERFACE ITF\n\nMETHOD METH\nVAR_INPUT\nEND_VAR\n Meldung: C0199: Schnittstelle 'ITF' muss instanziiert werden, um darauf zugreifen zu können Fehlerbehebung: Beispiel:\nitest: ITF; " }, 
{ "title" : "Compilerfehler C0201 ", 
"url" : "_cds_error_c0201.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0201 ", 
"snippet" : "C0201 Meldung : Typ ‚<data type 1>‘ entspricht nicht dem Typ ‚<data type 2>‘ von VAR_IN_OUT ‚Variable‘ Mögliche Fehlerursache : Der Datentyp, der der Funktion als VAR_IN_OUT-Parameter übergeben wird, stimmt nicht mit dem in ihr definierten Datentyp überein. Fehlerbehebung : Übergeben Sie eine Variab...", 
"body" : "C0201 Meldung : Typ ‚<data type 1>‘ entspricht nicht dem Typ ‚<data type 2>‘ von VAR_IN_OUT ‚Variable‘ Mögliche Fehlerursache : Der Datentyp, der der Funktion als VAR_IN_OUT-Parameter übergeben wird, stimmt nicht mit dem in ihr definierten Datentyp überein. Fehlerbehebung : Übergeben Sie eine Variable mit dem korrekten Datentyp. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n Inst: POU;\n b : BOOL;\nEND_VAR\n\ninst(in_out := b);\n\nFUNCTION_BLOCK POU\nVAR_IN_OUT\n in_out : INT;\nEND_VAR\n Meldung: C0201: Typ 'BOOL' entspricht nicht dem Typ 'INT' von VAR_IN_OUT 'Variable' " }, 
{ "title" : "Compilerfehler C0203 ", 
"url" : "_cds_error_c0203.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0203 ", 
"snippet" : "C0203 Meldung : Nur Strukturen und Funktionsbausteine können Variablen vom Typ BIT beinhalten Mögliche Fehlerursache : Es wird versucht, außerhalb von Strukturen und Funktionsbausteinen eine Variable vom Typ BIT zu deklarieren. Fehlerbehebung : Deklarieren Sie Variablen vom Typ BIT nur in Strukturen...", 
"body" : "C0203 Meldung : Nur Strukturen und Funktionsbausteine können Variablen vom Typ BIT beinhalten Mögliche Fehlerursache : Es wird versucht, außerhalb von Strukturen und Funktionsbausteinen eine Variable vom Typ BIT zu deklarieren. Fehlerbehebung : Deklarieren Sie Variablen vom Typ BIT nur in Strukturen und Funktionsbausteinen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n b : BIT;\nEND_VAR\n Meldung: C0203: Nur Strukturen und Funktionsbausteine können Variablen vom Typ BIT beinhalten " }, 
{ "title" : "Compilerfehler C0204 ", 
"url" : "_cds_error_c0204.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0204 ", 
"snippet" : "C0204 Meldung : Variablen vom Typ BIT müssen innerhalb eines VAR_INPUT-, VAR_OUTPUT oder VAR-Blocks definiert werden Mögliche Fehlerursache : Es wird versucht, eine Variable vom Typ BIT oder als VAR_IN_OUT-Parameter zu definieren. Fehlerbehebung : Definieren Sie Variablen vom Typ BIT nur innerhalb e...", 
"body" : "C0204 Meldung : Variablen vom Typ BIT müssen innerhalb eines VAR_INPUT-, VAR_OUTPUT oder VAR-Blocks definiert werden Mögliche Fehlerursache : Es wird versucht, eine Variable vom Typ BIT oder als VAR_IN_OUT-Parameter zu definieren. Fehlerbehebung : Definieren Sie Variablen vom Typ BIT nur innerhalb eines VAR_INPUT-, VAR_OUTPUT oder VAR-Blocks. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB\nVAR_IN_OUT\n b : BIT;\nEND_VAR\n Meldung: C0204: Variablen vom Typ BIT müssen innerhalb eines VAR_INPUT-, VAR_OUTPUT oder VAR-Blocks definiert werden " }, 
{ "title" : "Compilerfehler C0205 ", 
"url" : "_cds_error_c0205.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0205 ", 
"snippet" : "C0205 Meldung : POINTER TO BIT ist nicht erlaubt Mögliche Fehlerursache : Es wird versucht, einen POINTER TO BIT zu deklarieren. Fehlerbehebung : Deklarieren Sie keinen POINTER TO BIT. Beispiel für den Fehler: PROGRAM PLC_PRG VAR pt : POINTER TO BIT; END_VAR Meldung: C0205: POINTER TO BIT ist nicht ...", 
"body" : "C0205 Meldung : POINTER TO BIT ist nicht erlaubt Mögliche Fehlerursache : Es wird versucht, einen POINTER TO BIT zu deklarieren. Fehlerbehebung : Deklarieren Sie keinen POINTER TO BIT. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n pt : POINTER TO BIT;\nEND_VAR\n Meldung: C0205: POINTER TO BIT ist nicht erlaubt " }, 
{ "title" : "Compilerfehler C0206 ", 
"url" : "_cds_error_c0206.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0206 ", 
"snippet" : "C0206 Meldung : BIT ist nicht als Basistyp eines Arrays erlaubt Mögliche Fehlerursache : Es wird versucht, ein BIT-Array zu deklarieren Fehlerbehebung : Deklarieren Sie keine BIT-Arrays. Beispiel für den Fehler: PROGRAM PLC_PRG VAR arr : ARRAY[1..2] OF BIT; END_VAR Meldung: C0206: BIT ist nicht als ...", 
"body" : "C0206 Meldung : BIT ist nicht als Basistyp eines Arrays erlaubt Mögliche Fehlerursache : Es wird versucht, ein BIT-Array zu deklarieren Fehlerbehebung : Deklarieren Sie keine BIT-Arrays. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n arr : ARRAY[1..2] OF BIT;\nEND_VAR\n Meldung: C0206: BIT ist nicht als Basistyp eines Arrays erlaubt " }, 
{ "title" : "Compilerfehler C0207 ", 
"url" : "_cds_error_c0207.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0207 ", 
"snippet" : "C0207 Meldung : Es existiert keine Systemdefinition für ‚<identifier>‘ Mögliche Fehlerursache : Es wurde versucht auf eine Variable in __SYSTEM zuzugreifen, die nicht existiert. Fehlerbehebung : Überprüfen und korrigieren Sie die Angabe des Bezeichners der betreffenden Variable. Beispiel für den Feh...", 
"body" : "C0207 Meldung : Es existiert keine Systemdefinition für ‚<identifier>‘ Mögliche Fehlerursache : Es wurde versucht auf eine Variable in __SYSTEM zuzugreifen, die nicht existiert. Fehlerbehebung : Überprüfen und korrigieren Sie die Angabe des Bezeichners der betreffenden Variable. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n Value : INT;\nEND_VAR\nValue := __SYSTEM.UnknownVariable;\n Meldung: C0207: Es existiert keine Systemdefinition für ‚UnkownVariable‘ " }, 
{ "title" : "Compilerfehler C0208 ", 
"url" : "_cds_error_c0208.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0208 ", 
"snippet" : "C0208 Meldung : ‚MOD‘ ist für ‚REAL‘ nicht definiert Mögliche Fehlerursache : Es wird versucht, eine Modulo-Operation mit einer Variable vom Typ REAL durchzuführen. Fehlerbehebung : Modulo-Operationen sind nur mit Variablen vom Typ ANY_INT möglich. Beispiel für den Fehler: PROGRAM PLC_PRG VAR r1 : R...", 
"body" : "C0208 Meldung : ‚MOD‘ ist für ‚REAL‘ nicht definiert Mögliche Fehlerursache : Es wird versucht, eine Modulo-Operation mit einer Variable vom Typ REAL durchzuführen. Fehlerbehebung : Modulo-Operationen sind nur mit Variablen vom Typ ANY_INT möglich. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n r1 : REAL;\nEND_VAR\nr1 := r1 MOD 2;\n Meldung: C0208: 'MOD' ist für 'REAL' nicht definiert " }, 
{ "title" : "Compilerfehler C0209 ", 
"url" : "_cds_error_c0209.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0209 ", 
"snippet" : "C0209 Meldung : Sie haben ‚<number>‘ Applikation(en) für Gerät ‚<device name>‘ definiert. Die Maximalanzahl ist ‚<number>‘. Deshalb werden Sie nicht alle Applikation downloaden können. Mögliche Fehlerursache : Manche Geräte unterstützen nur eine bestimmte Anzahl an Applikationen (Gerätebeschreibung)...", 
"body" : "C0209 Meldung : Sie haben ‚<number>‘ Applikation(en) für Gerät ‚<device name>‘ definiert. Die Maximalanzahl ist ‚<number>‘. Deshalb werden Sie nicht alle Applikation downloaden können. Mögliche Fehlerursache : Manche Geräte unterstützen nur eine bestimmte Anzahl an Applikationen (Gerätebeschreibung). Wenn ein Projekt mehr Applikationen enthält, werden nicht alle auf das Gerät geladen. Fehlerbehebung : Entfernen Sie Applikationen aus Ihrem Projekt oder verwenden Sie ein anderes Gerät. " }, 
{ "title" : "Compilerfehler C0211 ", 
"url" : "_cds_error_c0211.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0211 ", 
"snippet" : "C0211 Meldung : Variablendeklaration erwartet statt <expression> Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Achten Sie auf eine korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG VAR VAR END_VAR END_VAR Meldung: C0211: Variablendeklaration erwartet statt VAR END_VAR...", 
"body" : "C0211 Meldung : Variablendeklaration erwartet statt <expression> Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Achten Sie auf eine korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n VAR\n\n END_VAR\nEND_VAR\n Meldung: C0211: Variablendeklaration erwartet statt VAR END_VAR " }, 
{ "title" : "Compilerfehler C0212 ", 
"url" : "_cds_error_c0212.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0212 ", 
"snippet" : "C0212 Meldung : VAR, VAR_INPUT, VAR_OUTPUT oder VAR_INOUT erwartet anstelle von <expression> Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Achten Sie auf eine korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG i : INT; Meldung: C0212: VAR, VAR_INPUT, VAR_OUTPUT oder VAR_INOUT erwarte...", 
"body" : "C0212 Meldung : VAR, VAR_INPUT, VAR_OUTPUT oder VAR_INOUT erwartet anstelle von <expression> Mögliche Fehlerursache : Syntaxfehler Fehlerbehebung : Achten Sie auf eine korrekte Syntax. Beispiel für den Fehler: PROGRAM PLC_PRG\ni : INT;\n Meldung: C0212: VAR, VAR_INPUT, VAR_OUTPUT oder VAR_INOUT erwartet anstelle von i : INT; " }, 
{ "title" : "Compilerfehler C0213 ", 
"url" : "_cds_error_c0213.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0213 ", 
"snippet" : "C0213 Meldung : VAR_Global oder VAR_CONFIG erwartet anstelle von <declaration> Mögliche Fehlerursache : In einer globalen Variablenliste (GVL) befindet sich eine Variablendeklaration außerhalb eines VAR_GLOBAL -Blocks. Fehlerbehebung : Verlagern Sie die Variablendeklaration in den VAR_GLOBAL - oder ...", 
"body" : "C0213 Meldung : VAR_Global oder VAR_CONFIG erwartet anstelle von <declaration> Mögliche Fehlerursache : In einer globalen Variablenliste (GVL) befindet sich eine Variablendeklaration außerhalb eines VAR_GLOBAL -Blocks. Fehlerbehebung : Verlagern Sie die Variablendeklaration in den VAR_GLOBAL - oder VAR_CONFIG -Block. Beispiel für den Fehler VAR_GLOBAL\nEND_VAR\ni : INT; Meldung: C0213: VAR_GLOBAL oder VAR_CONFIG erwartet anstelle von i:INT " }, 
{ "title" : "Compilerfehler C0215 ", 
"url" : "_cds_error_c0215.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0215 ", 
"snippet" : "C0215 Meldung : Direkte Adressdeklaration ist in Persistenten Variablenlisten nicht möglich. Mögliche Fehlerursache : Persistente Variablen dürfen keine direkte Adresse besitzen. Fehlerbehebung : Entfernen Sie die direkte Adresszuweisung in der persistenten Variablenliste. Beispiel für den Fehler: V...", 
"body" : "C0215 Meldung : Direkte Adressdeklaration ist in Persistenten Variablenlisten nicht möglich. Mögliche Fehlerursache : Persistente Variablen dürfen keine direkte Adresse besitzen. Fehlerbehebung : Entfernen Sie die direkte Adresszuweisung in der persistenten Variablenliste. Beispiel für den Fehler: VAR_GLOBAL PERSISTENT RETAIN\n directAddressVar AT %QB7 : BYTE;\nEND_VAR\n Meldung: C0215: Direkte Adressdeklaration ist in Persistenten Variablenlisten nicht möglich. " }, 
{ "title" : "Compilerfehler C0216 ", 
"url" : "_cds_error_c0216.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0216 ", 
"snippet" : "C0216 Meldung : Doppelte ‚CASE‘-Marke Mögliche Fehlerursache : Eine CASE-Marke wird mehr als einmal verwendet. Fehlerbehebung : Verwenden Sie jede CASE-Marke nur einmal. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i : INT; END_VAR CASE i OF 1: i := i+1; 1: i := i+2; ELSE i := i+10; END_CASE; --> C0...", 
"body" : "C0216 Meldung : Doppelte ‚CASE‘-Marke Mögliche Fehlerursache : Eine CASE-Marke wird mehr als einmal verwendet. Fehlerbehebung : Verwenden Sie jede CASE-Marke nur einmal. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\n\nCASE i OF\n 1: i := i+1;\n 1: i := i+2;\nELSE\n i := i+10;\nEND_CASE;\n\n--> C0216: Doppelte 'CASE'-Marke Meldung: C0216: Doppelte 'CASE'-Marke " }, 
{ "title" : "Compilerfehler C0217 ", 
"url" : "_cds_error_c0217.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0217 ", 
"snippet" : "C0217 Meldung : Die ‚CASE‘-Marke <case label> ist auch im Bereich <case range begin> .. <case range end> enthalten Mögliche Fehlerursache : Eine CASE-Marke ist Teil des Bereichs einer anderen CASE-Marke. Fehlerbehebung : Achten Sie auf Überschneidungen. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i...", 
"body" : "C0217 Meldung : Die ‚CASE‘-Marke <case label> ist auch im Bereich <case range begin> .. <case range end> enthalten Mögliche Fehlerursache : Eine CASE-Marke ist Teil des Bereichs einer anderen CASE-Marke. Fehlerbehebung : Achten Sie auf Überschneidungen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\nCASE i OF\n 3..5: i := i+2;\n 4: i := i+2;\nELSE\n i := i+10;\nEND_CASE;\n Meldung: C0217: Die 'CASE'-Marke 4 ist auch im Bereich 3 .. 5 enthalten " }, 
{ "title" : "Compilerfehler C0218 ", 
"url" : "_cds_error_c0218.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0218 ", 
"snippet" : "C0218 Meldung : ‚CASE‘-Marke erfordert ein Literal oder eine symbolische Ganzzahlkonstante Mögliche Fehlerursache : Es wird versucht, eine Variable als CASE-Marke zu verwenden. Fehlerbehebung : Verwenden Sie nur Literale und symbolische Ganzzahlkonstanten. Beispiel für den Fehler: PROGRAM PLC_PRG VA...", 
"body" : "C0218 Meldung : ‚CASE‘-Marke erfordert ein Literal oder eine symbolische Ganzzahlkonstante Mögliche Fehlerursache : Es wird versucht, eine Variable als CASE-Marke zu verwenden. Fehlerbehebung : Verwenden Sie nur Literale und symbolische Ganzzahlkonstanten. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\n a : INT := 2;\nEND_VAR\n\nCASE i OF\n 1: i := i+1;\n a: i := i+2;\nELSE\n i := i+10;\nEND_CASE;\n Meldung: C0218: 'CASE'-Marke erfordert ein Literal oder eine symbolische Ganzzahlkonstante " }, 
{ "title" : "Compilerfehler C0219 ", 
"url" : "_cds_error_c0219.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0219 ", 
"snippet" : "C0219 Meldung : ‚CASE‘ enthält überlappende Bereiche <case range 1 begin> .. <case range 1 end> und <case range 2 begin> .. <case range 2 end> Mögliche Fehlerursache : Zwei Bereiche von CASE-Marken haben gleiche Elemente oder Teilmengen. Fehlerbehebung : Achten Sie auf Überschneidungen. Beispiel für...", 
"body" : "C0219 Meldung : ‚CASE‘ enthält überlappende Bereiche <case range 1 begin> .. <case range 1 end> und <case range 2 begin> .. <case range 2 end> Mögliche Fehlerursache : Zwei Bereiche von CASE-Marken haben gleiche Elemente oder Teilmengen. Fehlerbehebung : Achten Sie auf Überschneidungen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\nCASE i OF\n 3..5: i := i+2;\n 1..4: i := i+2;\nELSE\n i := i+10;\nEND_CASE;\n Meldung: C0219: 'CASE' enthält überlappende Bereiche 1 .. 4 und 3 .. 5 " }, 
{ "title" : "Compilerfehler C0221 ", 
"url" : "_cds_error_c0221.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0221 ", 
"snippet" : "C0221 Meldung : Direkte Adresse ‚<address>‘ nicht korrekt dargestellt Mögliche Fehlerursache : Eine Adresse wird unvollständig dargestellt. Fehlerbehebung : Stellen Sie die Adresse korrekt dar. Beispiel für den Fehler: PROGRAM PLC_PRG VAR xVar : BOOL; END_VAR; xVar := %IX0; Meldung: C0221: Direkte A...", 
"body" : "C0221 Meldung : Direkte Adresse ‚<address>‘ nicht korrekt dargestellt Mögliche Fehlerursache : Eine Adresse wird unvollständig dargestellt. Fehlerbehebung : Stellen Sie die Adresse korrekt dar. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n xVar : BOOL;\nEND_VAR;\nxVar := %IX0;\n Meldung: C0221: Direkte Adresse '%IXO' nicht korrekt dargestellt Fehlerbehebung: xVar := %IX0.2; " }, 
{ "title" : "Compilerfehler C0222 ", 
"url" : "_cds_error_c0222.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0222 ", 
"snippet" : "C0222 Meldung : Ausgänge können nicht vom Typ ‚REFERENCE TO‘ sein Mögliche Fehlerursache : Es wird versucht, REFERENCE TO als Ausgangsparameter zu definieren. Fehlerbehebung : Verwenden Sie REFERENCE TO nicht als Ausgangsparameter. Beispiel für den Fehler: PROGRAM PLC_PRG VAR inst : FB; END_VAR Impl...", 
"body" : "C0222 Meldung : Ausgänge können nicht vom Typ ‚REFERENCE TO‘ sein Mögliche Fehlerursache : Es wird versucht, REFERENCE TO als Ausgangsparameter zu definieren. Fehlerbehebung : Verwenden Sie REFERENCE TO nicht als Ausgangsparameter. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n Implementierung des Funktionsbausteins: FUNCTION_BLOCK FB\nVAR_OUTPUT\n re : REFERENCE TO INT;\nEND_VAR Meldung: C0222: Ausgänge können nicht vom Typ 'REFERENCE TO' sein " }, 
{ "title" : "Compilerfehler C0224 ", 
"url" : "_cds_error_c0224.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0224 ", 
"snippet" : "C0224 Meldung : Aufrufrekursion: <recursion> Mögliche Fehlerursache : Eine Funktion ruft sich selbst auf. Fehlerbehebung : Achten Sie darauf, dass Funktionen nicht rekursiv sind. Beispiel für den Fehler: Beispiel für den Fehler: PROGRAM PLC_PRG VAR END_VAR POU(); FUNCTION POU VAR END_VAR POU(); Meld...", 
"body" : "C0224 Meldung : Aufrufrekursion: <recursion> Mögliche Fehlerursache : Eine Funktion ruft sich selbst auf. Fehlerbehebung : Achten Sie darauf, dass Funktionen nicht rekursiv sind. Beispiel für den Fehler: Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nPOU();\n\nFUNCTION POU\nVAR\nEND_VAR\n\nPOU();\n Meldung: C0224: Aufrufrekursion: POU -> POU " }, 
{ "title" : "Compilerfehler C0225 ", 
"url" : "_cds_error_c0225.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0225 ", 
"snippet" : "C0225 Meldung : ‚<name>‘ ist keine Instanz von ‚<name>‘ Mögliche Fehlerursache : Ein Funktionsbaustein in einer graphischen Programmiersprache wurde mit einem explizit angegebenen Typen versehen, der nicht mit dem deklarierten Typen übereinstimmt. Fehlerbehebung : Ersetzten sie den expliziten Typen ...", 
"body" : "C0225 Meldung : ‚<name>‘ ist keine Instanz von ‚<name>‘ Mögliche Fehlerursache : Ein Funktionsbaustein in einer graphischen Programmiersprache wurde mit einem explizit angegebenen Typen versehen, der nicht mit dem deklarierten Typen übereinstimmt. Fehlerbehebung : Ersetzten sie den expliziten Typen durch den im Deklarationsteil verwendeten, oder entfernen Sie die Angabe des expliziten Typen aus dem Baustein. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n fbVar : MyFB;\nEND_VAR\n Meldung: C0225: ‚fbVar‘ ist keine Instance von ‚MyFB2‘ Fehlerbehebung: oder " }, 
{ "title" : "Compilerfehler C0227 ", 
"url" : "_cds_error_c0227.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0227 ", 
"snippet" : "C0227 Meldung : Konstante <constant name> nicht mit konstantem Wert initialisiert Mögliche Fehlerursache : Eine Konstante wird mit einer Variable initialisiert. Fehlerbehebung : Initialisieren Sie Konstanten nur mit konstanten Werten. Beispiel für den Fehler: PROGRAM PLC_PRG VAR i : INT; END_VAR VAR...", 
"body" : "C0227 Meldung : Konstante <constant name> nicht mit konstantem Wert initialisiert Mögliche Fehlerursache : Eine Konstante wird mit einer Variable initialisiert. Fehlerbehebung : Initialisieren Sie Konstanten nur mit konstanten Werten. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\nVAR CONSTANT\n k : INT := i;\nEND_VAR\n Meldung: C0227: Konstante 'k' nicht mit konstantem Wert initialisiert " }, 
{ "title" : "Compilerfehler C0228 ", 
"url" : "_cds_error_c0228.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0228 ", 
"snippet" : "C0228 Meldung : Kein Initialwert für konstante Variable ‚<constant name>‘ Mögliche Fehlerursache : Eine Konstante wird nicht initialisiert. Fehlerbehebung : Initialisieren Sie die Konstante. Beispiel für den Fehler: PROGRAM PLC_PRG VAR END_VAR VAR CONSTANT k : INT; END_VAR Meldung: C0228: Kein Initi...", 
"body" : "C0228 Meldung : Kein Initialwert für konstante Variable ‚<constant name>‘ Mögliche Fehlerursache : Eine Konstante wird nicht initialisiert. Fehlerbehebung : Initialisieren Sie die Konstante. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\nEND_VAR\nVAR CONSTANT\n k : INT;\nEND_VAR\n Meldung: C0228: Kein Initialwert für konstante Variable 'k' Fehlerbehebung: k : INT := 1; " }, 
{ "title" : "Compilerfehler C0230 ", 
"url" : "_cds_error_c0230.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0230 ", 
"snippet" : "C0230 Meldung : Typbezeichnung ‚<data type>‘ an dieser Stelle nicht erwartet Mögliche Fehlerursache : Der Datentypname einer Enumeration wird an einer ungültigen Stelle verwendet. Fehlerbehebung : Überprüfen Sie, ob der Datentypname an dieser Stelle korrekt verwendet wird. Eventuell liegt ein Schrei...", 
"body" : "C0230 Meldung : Typbezeichnung ‚<data type>‘ an dieser Stelle nicht erwartet Mögliche Fehlerursache : Der Datentypname einer Enumeration wird an einer ungültigen Stelle verwendet. Fehlerbehebung : Überprüfen Sie, ob der Datentypname an dieser Stelle korrekt verwendet wird. Eventuell liegt ein Schreibfehler vor. Beispiel für den Fehler: TYPE MyEnum :\n(\n enum_member := 0\n);\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n value : INT;\nEND_VAR\nvalue := MyEnum;\nMyEnum := value;\n Meldung: Für PLC_PRG wird 2x die Fehlermeldung ausgegeben: C0230: Typbezeichnung 'MyEnum' an dieser Stelle nicht erwartet Fehlerbehebung: value := MyEnum.enum_member;\nMyEnum.enum_member := value; " }, 
{ "title" : "Compilerfehler C0232 ", 
"url" : "_cds_error_c0232.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0232 ", 
"snippet" : "C0232 Meldung : Array-Initialisierung erwartet Mögliche Fehlerursache : Ein „Array von Array“ wird initialisiert, aber die Initialisierungswerte sind nicht geschachtelt angegeben.. Fehlerbehebung : Verwenden Sie eine geschachtelte Array-Initialisierung wie unten im Beispiel gezeigt. Beispiel für den...", 
"body" : "C0232 Meldung : Array-Initialisierung erwartet Mögliche Fehlerursache : Ein „Array von Array“ wird initialisiert, aber die Initialisierungswerte sind nicht geschachtelt angegeben.. Fehlerbehebung : Verwenden Sie eine geschachtelte Array-Initialisierung wie unten im Beispiel gezeigt. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n value : ARRAY[0..2] OF ARRAY[0..2] OF INT := [1,2,3];\nEND_VAR\n Meldung: C0232: Array-Initialisierung erwartet Fehlerbehebung: value : ARRAY[0..2] OF ARRAY[0..2] OF INT := [\n[1,2,3],\n[4,5,6],\n[7,8,9]]; " }, 
{ "title" : "Compilerfehler C0233 ", 
"url" : "_cds_error_c0233.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0233 ", 
"snippet" : "C0233 Meldung : Initialisierungsliste für <data type> erwartet Mögliche Fehlerursache : Ein Array vom Typ einer Struktur wird mit Elementen initialisiert, die keine Strukturinitialisierungen oder Variablen sind. Fehlerbehebung : Verwenden Sie wie im Beispiel unten zu sehen Strukturinitialisierungen ...", 
"body" : "C0233 Meldung : Initialisierungsliste für <data type> erwartet Mögliche Fehlerursache : Ein Array vom Typ einer Struktur wird mit Elementen initialisiert, die keine Strukturinitialisierungen oder Variablen sind. Fehlerbehebung : Verwenden Sie wie im Beispiel unten zu sehen Strukturinitialisierungen oder existierende Variablen, um Arrays von Strukturen zu initialisieren. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n values : ARRAY[0..2] OF COLOR := [1,2,3];\nEND_VAR\n Meldung: C0233: Initialisierungsliste für COLOR erwartet Fehlerbehebung: PROGRAM PLC_PRG\nVAR\n colorVariable : COLOR := (red:=0, green:=0, blue:=255);\n value : ARRAY[0..2] OF COLOR := [\n colorVariable,\n (red:=255, green:=0, blue:=0),\n (red:=0, green:=255, blue:=0)];\nEND_VAR " }, 
{ "title" : "Compilerfehler C0234 ", 
"url" : "_cds_error_c0234.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0234 ", 
"snippet" : "C0234 Meldung : Erster Operand von __QueryInterface muss eine Schnittstellenreferenz oder die Instanz eines Funktionsbausteins sein Mögliche Fehlerursache : Dem Operator __QueryInterface werden falsche Operanden übergeben. Fehlerbehebung : Übergeben Sie eine Schnittstellenreferenz oder die Instanz e...", 
"body" : "C0234 Meldung : Erster Operand von __QueryInterface muss eine Schnittstellenreferenz oder die Instanz eines Funktionsbausteins sein Mögliche Fehlerursache : Dem Operator __QueryInterface werden falsche Operanden übergeben. Fehlerbehebung : Übergeben Sie eine Schnittstellenreferenz oder die Instanz eines Funktionsbausteins. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n a : INT;\n ITFref, ITFref2 : ITF;\n ITFref2 : ITF2;\nEND_VAR\n\n__QueryInterface(a ,ITFref);\n\nINTERFACE ITF EXTENDS __SYSTEM.IQueryInterface\nINTERFACE ITF2 EXTENDS ITF\n Meldung: C0234: Erster Operand von __QueryInterface muss eine Schnittstellenreferenz oder die Instanz eines Funktionsbausteins sein Fehlerbehebung: __QueryInterface(ITFref2, ITFref); " }, 
{ "title" : "Compilerfehler C0235 ", 
"url" : "_cds_error_c0235.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0235 ", 
"snippet" : "C0235 Meldung : Der zweite Operand von __QueryInterface muss eine Interface-Referenz sein Mögliche Fehlerursache : Dem Operator __QueryInterface werden falsche Operanden übergeben. Fehlerbehebung : Übergeben Sie eine Schnittstellenreferenz. Beispiel für den Fehler: PROGRAM PLC_PRG VAR a : INT; ITFre...", 
"body" : "C0235 Meldung : Der zweite Operand von __QueryInterface muss eine Interface-Referenz sein Mögliche Fehlerursache : Dem Operator __QueryInterface werden falsche Operanden übergeben. Fehlerbehebung : Übergeben Sie eine Schnittstellenreferenz. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n a : INT;\n ITFref, ITFref2 : ITF;\n ITFref2 : ITF2;\nEND_VAR\n\n__QueryInterface(ITFref2, a);\n\nINTERFACE ITF EXTENDS __SYSTEM.IQueryInterface\nINTERFACE ITF2 EXTENDS ITF\n Meldung: C0235: Der zweite Operand von __QueryInterface muss eine Interface-Referenz sein Fehlerbehebung: __QueryInterface(ITFref2, ITFref); " }, 
{ "title" : "Compilerfehler C0236 ", 
"url" : "_cds_error_c0236.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0236 ", 
"snippet" : "C0236 Meldung : Falsche Typdefinition für VAR_EXTERNAL <variable name> Mögliche Fehlerursache : Die Variable wird in VAR_GLOBAL \/ VAR_EXTERNAL als unterschiedliche Typen deklariert. Fehlerbehebung : Verwenden Sie in VAR_GLOBAL und VAR_EXTERNAL die gleiche Typdefinition. Beispiel für den Fehler: PROG...", 
"body" : "C0236 Meldung : Falsche Typdefinition für VAR_EXTERNAL <variable name> Mögliche Fehlerursache : Die Variable wird in VAR_GLOBAL \/ VAR_EXTERNAL als unterschiedliche Typen deklariert. Fehlerbehebung : Verwenden Sie in VAR_GLOBAL und VAR_EXTERNAL die gleiche Typdefinition. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR_EXTERNAL\n ig : STRING;\nEND_VAR\n\nVAR_GLOBAL\n ig : INT;\nEND_VAR\n Meldung: C0236: Falsche Typdefinition für VAR_EXTERNAL ig " }, 
{ "title" : "Compilerfehler C0237 ", 
"url" : "_cds_error_c0237.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0237 ", 
"snippet" : "C0237 Meldung : Keine globale Definition für VAR_EXTERNAL ‚<variabler name>‘ gefunden Mögliche Fehlerursache : Es wird versucht, in VAR_EXTERNAL eine Variable zu deklarieren, die nicht in VAR_GLOBAL existiert Fehlerbehebung : Achten Sie darauf, dass die Bezeichner übereinstimmen. Beispiel für den Fe...", 
"body" : "C0237 Meldung : Keine globale Definition für VAR_EXTERNAL ‚<variabler name>‘ gefunden Mögliche Fehlerursache : Es wird versucht, in VAR_EXTERNAL eine Variable zu deklarieren, die nicht in VAR_GLOBAL existiert Fehlerbehebung : Achten Sie darauf, dass die Bezeichner übereinstimmen. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR_EXTERNAL\n i : INT;\nEND_VAR\n\nVAR_GLOBAL\n ig : INT;\nEND_VAR\n Meldung: C0237: Keine globale Definition für VAR_EXTERNAL 'i' gefunden " }, 
{ "title" : "Compilerfehler C0238 ", 
"url" : "_cds_error_c0238.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0238 ", 
"snippet" : "C0238 Meldung : Für VAR_EXTERNAL <variable name> ist kein Initialwert erlaubt Mögliche Fehlerursache : Es wird versucht, in VAR_EXTERNAL eine Variable zu initialisieren. Fehlerbehebung : Initialisieren Sie keine Variablen in VAR_EXTERNAL . Beispiel für den Fehler: PROGRAM PLC_PRG VAR_EXTERNAL ig : I...", 
"body" : "C0238 Meldung : Für VAR_EXTERNAL <variable name> ist kein Initialwert erlaubt Mögliche Fehlerursache : Es wird versucht, in VAR_EXTERNAL eine Variable zu initialisieren. Fehlerbehebung : Initialisieren Sie keine Variablen in VAR_EXTERNAL . Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR_EXTERNAL\n ig : INT := 2;\nEND_VAR\n\nVAR_GLOBAL\n ig : INT;\nEND_VAR\n Meldung: C0238: Für VAR_EXTERNAL ig ist kein Initialwert erlaubt " }, 
{ "title" : "Compilerfehler C0239 ", 
"url" : "_cds_error_c0239.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0239 ", 
"snippet" : "C0239 Meldung : Interface <interface name 1> erweitert nicht <interface name 2> Mögliche Fehlerursache : Die verwendete Schnittstelle erweitert keine andere Schnittstelle. Fehlerbehebung : Erweitern Sie die Schnittstelle. Beispiel für den Fehler: PROGRAM PLC_PRG VAR ITFref : ITF; ITFref2 : ITF2; END...", 
"body" : "C0239 Meldung : Interface <interface name 1> erweitert nicht <interface name 2> Mögliche Fehlerursache : Die verwendete Schnittstelle erweitert keine andere Schnittstelle. Fehlerbehebung : Erweitern Sie die Schnittstelle. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n ITFref : ITF;\n ITFref2 : ITF2;\nEND_VAR\n\n__QueryInterface(ITFref2,ITFref);\n\nINTERFACE ITF\nINTERFACE ITF2 EXTENDS ITF\n Meldung: C0239: Interface ITF erweitert nicht __System.IQueryInterface Fehlerbehebung: INTERFACE ITF EXTENDS __System.IQueryInterface " }, 
{ "title" : "Compilerfehler C0240 ", 
"url" : "_cds_error_c0240.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0240 ", 
"snippet" : "C0240 Meldung : Erster Operand von __QueryPointer muss eine Schnittstellenreferenz oder Instanz eines Funktionsbausteins sein Mögliche Fehlerursache : Dem Operator __QueryPointer werden falsche Operanden übergeben. Fehlerbehebung : Übergeben Sie eine Schnittstellenreferenz oder die Instanz eines Fun...", 
"body" : "C0240 Meldung : Erster Operand von __QueryPointer muss eine Schnittstellenreferenz oder Instanz eines Funktionsbausteins sein Mögliche Fehlerursache : Dem Operator __QueryPointer werden falsche Operanden übergeben. Fehlerbehebung : Übergeben Sie eine Schnittstellenreferenz oder die Instanz eines Funktionsbausteins. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n a : INT;\n ITFref : ITF;\n pt : POINTER TO FB;\nEND_VAR\n\n__QueryPointer(a,pt);\n Meldung: C0240: Erster Operand von __QueryPointer muss eine Schnittstellenreferenz oder Instanz eines Funktionsbausteins sein Fehlerbehebung: __QueryPointer (ITFref, pt); " }, 
{ "title" : "Compilerfehler C0241 ", 
"url" : "_cds_error_c0241.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0241 ", 
"snippet" : "C0241 Meldung : Zweiter Operand von __QueryPointer muss ein Zeiger sein Mögliche Fehlerursache : Dem Operator __QueryPointer werden falsche Operanden übergeben. Fehlerbehebung : Übergeben Sie einen Pointer. Beispiel für den Fehler: PROGRAM PLC_PRG VAR b : INT; ITFref : ITF; pt : POINTER TO FB; END_V...", 
"body" : "C0241 Meldung : Zweiter Operand von __QueryPointer muss ein Zeiger sein Mögliche Fehlerursache : Dem Operator __QueryPointer werden falsche Operanden übergeben. Fehlerbehebung : Übergeben Sie einen Pointer. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n b : INT;\n ITFref : ITF;\n pt : POINTER TO FB;\nEND_VAR\n\n__QueryPointer(ITFref,b);\n\nINTERFACE ITF EXTENDS __System.IQueryInterface\n Meldung: C0241: Zweiter Operand von __QueryPointer muss ein Zeiger sein Fehlerbehebung: __QueryPointer (ITFref, pt); " }, 
{ "title" : "Compilerfehler C0242 ", 
"url" : "_cds_error_c0242.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0242 ", 
"snippet" : "C0242 Meldung : Operand von __DELETE muss ein Pointer sein Mögliche Fehlerursache : Dem Operator __DELETE wird ein falscher Operand übergeben. Fehlerbehebung : Übergeben Sie einen Pointer. Beispiel für den Fehler: PROGRAM PLC_PRG VAR a : INT; pt : POINTER TO INT; END_VAR __DELETE(a); Meldung: C0242:...", 
"body" : "C0242 Meldung : Operand von __DELETE muss ein Pointer sein Mögliche Fehlerursache : Dem Operator __DELETE wird ein falscher Operand übergeben. Fehlerbehebung : Übergeben Sie einen Pointer. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n a : INT;\n pt : POINTER TO INT;\nEND_VAR\n\n__DELETE(a);\n Meldung: C0242: Operand von __DELETE muss ein Pointer sein Fehlerbehebung: __DELETE (pt); " }, 
{ "title" : "Compilerfehler C0243 ", 
"url" : "_cds_error_c0243.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0243 ", 
"snippet" : "C0243 Meldung : Der in der Schnittstelle verwendete Name ist nicht identisch mit dem Objektnamen Mögliche Fehlerursache : Der Objektname und der Name, der im Code verwendet wird, unterscheiden sich. Fehlerbehebung : Achten Sie auf eine Gleichheit der Namen. Beispiel für den Fehler:...", 
"body" : "C0243 Meldung : Der in der Schnittstelle verwendete Name ist nicht identisch mit dem Objektnamen Mögliche Fehlerursache : Der Objektname und der Name, der im Code verwendet wird, unterscheiden sich. Fehlerbehebung : Achten Sie auf eine Gleichheit der Namen. Beispiel für den Fehler: " }, 
{ "title" : "Compilerwarnung C0266 ", 
"url" : "_cds_error_c0266.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0266 ", 
"snippet" : "C0266 Meldung : Schleifenaustrittsbedingung <condition> ist konstant FALSE . Endlosschleife möglich. Mögliche Fehlerursache : In einer FOR -Schleife wird über den gesamten Wertebereich der Kontrollvariablen iteriert. Fehlerbehebung : Gemäß der Norm IEC 61131 werden die Anweisungen innerhalb der FOR ...", 
"body" : "C0266 Meldung : Schleifenaustrittsbedingung <condition> ist konstant FALSE . Endlosschleife möglich. Mögliche Fehlerursache : In einer FOR -Schleife wird über den gesamten Wertebereich der Kontrollvariablen iteriert. Fehlerbehebung : Gemäß der Norm IEC 61131 werden die Anweisungen innerhalb der FOR -Schleife nur ausgeführt, wenn der Wert der Kontrollvariablen den Endwert überschreitet. Verwenden Sie daher für die Kontrollvariable einen ausreichend großen Typ, der den Endwert+1 abbilden kann. Beispiel für die Warnung PROGRAM PLC_PRG\nVAR\n      b : BYTE;\n      i : INT;\nEND_VAR\nFOR b := 0 TO 255 BY 1 DO\n      i := i + 1;\nEND_FOR;\n Meldung: C0266: Schleifenaustrittsbedingung 'b > 255' ist konstant FALSE. Endlosschleife möglich. " }, 
{ "title" : "Compilerwarnung C0269 ", 
"url" : "_cds_error_c0269.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0269 ", 
"snippet" : "C0269 Meldung : Die Instanz, auf die <pointer dereferencing> zeigt, wird für virtuelle Funktionsaufrufe reinitialisiert. Stellen Sie sicher, dass <pointer dereferencing> nicht auf einen Typ zeigt, der von <base FB> abgeleitet ist. Mögliche Fehlerursache : Es wird die Adresse eines abgeleiteten Baust...", 
"body" : "C0269 Meldung : Die Instanz, auf die <pointer dereferencing> zeigt, wird für virtuelle Funktionsaufrufe reinitialisiert. Stellen Sie sicher, dass <pointer dereferencing> nicht auf einen Typ zeigt, der von <base FB> abgeleitet ist. Mögliche Fehlerursache : Es wird die Adresse eines abgeleiteten Bausteins als Adresse des Basisbausteins verwendet. Beispiel für die Warnung FUNCTION_BLOCK FBBase\n...\n\nFUNCTION_BLOCK FBDerived EXTENDS FBBase\n...\n\nFUNCTION_BLOCK FB EXTENDS Base_FB\n...\nPROGRAM PLC_PRG\nVAR\n      pinst : POINTER TO FBBase;\n      inst2_2 : FBDerived;\nEND_VAR\npinst := ADR(inst2_2);\npinst^ := inst2_2;\n Die Pointer-Dereferenzierung produziert die folgende Warnung. Meldung: C0269:  Die Instanz, auf die pinst^ zeigt, wird für virtuelle Funktionsaufrufe reinitialisiert. Stellen Sie sicher, dass pinst^ nicht auf einen Typ zeigt, der von FBBase abgeleitet ist. : " }, 
{ "title" : "Compilerwarnung C0298 ", 
"url" : "_cds_error_c0298.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0298 ", 
"snippet" : "C0298 Meldung : Berechnung des Stackverbrauchs aufgrund rekursiver Aufrufe unvollständig, beginnend bei '<recursive method name'. Mögliche Ursache : Bei Methoden mit rekursivem Aufruf kann die Stackprüfung nicht erfolgreich durchgeführt werden, da der Stackverbrauch nicht ermittelt werden kann. Fehl...", 
"body" : "C0298 Meldung : Berechnung des Stackverbrauchs aufgrund rekursiver Aufrufe unvollständig, beginnend bei '<recursive method name'. Mögliche Ursache : Bei Methoden mit rekursivem Aufruf kann die Stackprüfung nicht erfolgreich durchgeführt werden, da der Stackverbrauch nicht ermittelt werden kann. Fehlerbehebung : Geben Sie der Methode mithilfe des Attributs estimated-stack-usage einen Schätzwert (in Bytes) für den Stackgrößenbedarf mit. Beispiel für den Fehler: METHOD PUBLIC m_Recursive : UDINT\n VAR_INPUT\n uiN : UINT;\n END_VAR\n VAR\n END_VAR\n m_Recursive := 1;\n IF uiN > 1 THEN\n m_Recursive := uiN * THIS^.m_Recursive(uiN := (uiN - 1) );\n RETURN;\n ELSE\n RETURN;\n END_IF; Meldung: C0298: Berechnung des Stackverbrauchs aufgrund rekursiver Aufrufe unvollständig, beginnend bei 'm_Recursive' Fehlerbehebung: {attribute 'estimated-stack-usage' := '99'} Für weitere Informationen siehe: estimated-stack-usage" }, 
{ "title" : "Compilerwarnung C0316 ", 
"url" : "_cds_error_c0316.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0316 ", 
"snippet" : "C0316 Meldung : Methode '<method name>' wird bereits implizit aufgerufen. Mögliche Fehlerursache : In der FB_Exit -Methode eines abgeleiteten Bausteins wird die FB_Exit -Methode des Basisbausteins aufgerufen. Fehlerbehebung : Entfernen Sie den Aufruf in der FB_Exit -Methode. Beispiel für die Warnung...", 
"body" : "C0316 Meldung : Methode '<method name>' wird bereits implizit aufgerufen. Mögliche Fehlerursache : In der FB_Exit -Methode eines abgeleiteten Bausteins wird die FB_Exit -Methode des Basisbausteins aufgerufen. Fehlerbehebung : Entfernen Sie den Aufruf in der FB_Exit -Methode. Beispiel für die Warnung FUNCTION_BLOCK Base_FB...\nMETHOD FB_Exit: BOOL\nVAR_INPUT\n      bInCopyCode : BOOL;\nEND_VAR\n\nFUNCTION_BLOCK FB EXTENDS Base_FB\n...\nMETHOD FB_Exit : BOOL\nVAR_INPUT\n      bInCopyCode : BOOL;\nEND_VAR\nSUPER^.FB_Exit(bInCopyCode); \n Die Anweisung in der Methode FB_Exit produziert die folgende Warnung. Meldung: C0316: Methode 'FB_Exit' wird bereits implizit aufgerufen " }, 
{ "title" : "Compilerfehler C0319 ", 
"url" : "_cds_error_c0319.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0319 ", 
"snippet" : "C0319 Meldung : <> in Schnittstellenbibliothek nicht erlaubt Diese Warnung erscheint, wenn für Schnittstellenbibliotheken geltende Regeln nicht eingehalten werden. Für ausführliche Informationen zu diesen Regeln siehe: Schnittstellenbibliotheken...", 
"body" : "C0319 Meldung : <> in Schnittstellenbibliothek nicht erlaubt Diese Warnung erscheint, wenn für Schnittstellenbibliotheken geltende Regeln nicht eingehalten werden. Für ausführliche Informationen zu diesen Regeln siehe: Schnittstellenbibliotheken " }, 
{ "title" : "Compilerwarnung C0344 ", 
"url" : "_cds_error_c0344.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0344 ", 
"snippet" : "C0344 Meldung : Das Monitoring-Attribut wird für Property '<property name>' nicht unterstützt und wird ignoriert. Mögliche Fehlerursache : Ein Property hat das Monitoring-Attribut 'call' und liefert eine Struktur zurück . Fehlerbehebung : Verwenden Sie das Monitoring-Attribut 'variable' . Beispiel f...", 
"body" : "C0344 Meldung : Das Monitoring-Attribut wird für Property '<property name>' nicht unterstützt und wird ignoriert. Mögliche Fehlerursache : Ein Property hat das Monitoring-Attribut 'call' und liefert eine Struktur zurück . Fehlerbehebung : Verwenden Sie das Monitoring-Attribut 'variable' . Beispiel für die Warnung TYPE ST_Test :STRUCT\n      a,b : INT;  \nEND_STRUCT\nEND_TYPE\n\nFUNCTION_BLOCK FB_Test\n...\n\n{attribute 'monitoring' := 'call'}\nPROPERTY TestProp : ST_Test\n Die Deklaration des Property TestProp produziert die folgende Warnung. Meldung: C0344: Das Monitoring-Attribut wird für Property 'TestProp' nicht unterstützt und wird ignoriert. " }, 
{ "title" : "Compilerwarnung C0351 ", 
"url" : "_cds_error_c0351.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0351 ", 
"snippet" : "C0351 Meldung : Das Attribut <attribute name> ist unbekannt und wird vom Compiler ignoriert. Mögliche Fehlerursache : Es liegt ein Schreibfehler bei einem Attributnamen vor. Fehlerbehebung : Falls Sie ein vordefiniertes Attribut verwenden: Stellen Sie sicher, dass das Attribut richtig geschrieben is...", 
"body" : "C0351 Meldung : Das Attribut <attribute name> ist unbekannt und wird vom Compiler ignoriert. Mögliche Fehlerursache : Es liegt ein Schreibfehler bei einem Attributnamen vor. Fehlerbehebung : Falls Sie ein vordefiniertes Attribut verwenden: Stellen Sie sicher, dass das Attribut richtig geschrieben ist (im Beispiel: call_after_init ) Beispiel für die Warnung {attribute 'call_after_ini'}\nPROGRAM PLC_PRG\nVAR\nEND_VAR\n Meldung: C0351: Das Attribut call_after_ini ist unbekannt und wird vom Compiler ignoriert. " }, 
{ "title" : "Compilerwarnung C0354 ", 
"url" : "_cds_error_c0354.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0354 ", 
"snippet" : "C0354 Meldung : Vergleich eines Enumerationstyps (<type name 1>) mit einem anderen (<type name 2>) Möglich Fehlerunrsache : Es werden Enumerationstypen in Vergleichsoperatoren verwendet. Fehlerbehebung : Verwenden Sie in Ihrem Programmcode vordefinierte Ganzzahl-Datentypen (beispielsweise INT ) anst...", 
"body" : "C0354 Meldung : Vergleich eines Enumerationstyps (<type name 1>) mit einem anderen (<type name 2>) Möglich Fehlerunrsache : Es werden Enumerationstypen in Vergleichsoperatoren verwendet. Fehlerbehebung : Verwenden Sie in Ihrem Programmcode vordefinierte Ganzzahl-Datentypen (beispielsweise INT ) anstelle der Enumerationstypen Kopieren Sie die Werte der Enumerationsvariablen in Hilfsvariablen um (beispielsweise INT -Variablen) und verwenden Sie die Hilfsvariablen im Vergleichsoperator Beispiel für die Warnung {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE ENUM1:\n(\n      enum_member1 := 0,\n      enum_member2 := 1\n);\nEND_TYPE\n\n{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE ENUM2:\n(\n      enum_member := 0\n);\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n      enum1 : ENUM1;\n      enum2 : ENUM2;\n      i:INT;\nEND_VAR\nenum1 := 0;\nenum2 := 0;\nIF enum1 > enum2 THEN\n      i := 1;\nEND_IF;\n Die IF -Anweisung produziert die folgende Warnung. Meldung: C0354: Vergleich eines Enumerationstyps (ENUM1) mit einem anderen (ENUM2) " }, 
{ "title" : "Compilerwarnung C0355 ", 
"url" : "_cds_error_c0355.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0355 ", 
"snippet" : "C0355 Meldung : Ein einzelnes Bit kann nicht referenziert werden. Es wird eine Referenz auf das komplette Byte gespeichert. Mögliche Fehlerursache : Es wird versucht, die Adresse eines Bits zu ermitteln. Beispiel für die Warnung FUNCTION_BLOCK FBVAR       pt : POINTER TO BOOL;       b : BIT; END_VAR...", 
"body" : "C0355 Meldung : Ein einzelnes Bit kann nicht referenziert werden. Es wird eine Referenz auf das komplette Byte gespeichert. Mögliche Fehlerursache : Es wird versucht, die Adresse eines Bits zu ermitteln. Beispiel für die Warnung FUNCTION_BLOCK FBVAR\n      pt : POINTER TO BOOL;\n      b : BIT;\nEND_VAR\npt := ADR(b); Meldung: C0355: Ein einzelnes Bit kann nicht referenziert werden. Es wird eine Referenz auf das komplette Byte gespeichert. " }, 
{ "title" : "Compilerwarnung C0357 ", 
"url" : "_cds_error_c0357.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0357 ", 
"snippet" : "C0357 Meldung : POU '<POU name>' wurde als obsolet markiert: <message text> Mögliche Fehlerursache : Ein Baustein ist mit dem Attribut 'obsolete' dekoriert, wird aber im Programm noch verwendet. Fehlerbehebung : Entfernen Sie das Attribut beim Baustein oder verwenden Sie den Baustein nicht mehr. Bei...", 
"body" : "C0357 Meldung : POU '<POU name>' wurde als obsolet markiert: <message text> Mögliche Fehlerursache : Ein Baustein ist mit dem Attribut 'obsolete' dekoriert, wird aber im Programm noch verwendet. Fehlerbehebung : Entfernen Sie das Attribut beim Baustein oder verwenden Sie den Baustein nicht mehr. Beispiel für die Warnung {attribute 'obsolete':= 'datatype fb not valid!'}\nFUNCTION_BLOCK FB_Test\n\nPROGRAM PLC_PRG\nVAR\n      inst : FB_Test;\nEND_VAR Die Deklaration der Variablen inst produziert die folgende Warnung: Meldung: C0357: POU 'FB_Test' wurde als obsolet markiert: datatype fb not valid! " }, 
{ "title" : "Compilerwarnung C0371 ", 
"url" : "_cds_error_c0371.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0371 ", 
"snippet" : "C0371 Meldung : Zugriff auf VAR_IN_OUT '<variable name>' deklariert in '< function block name>' von externem Kontext '<POU name>'. Mögliche Fehlerursache : In einer Methode eines Bausteins wird auf einen VAR_IN_OUT des Bausteins zugegriffen. Fehlerbehebung : Ändern Sie entweder die Deklaration der V...", 
"body" : "C0371 Meldung : Zugriff auf VAR_IN_OUT '<variable name>' deklariert in '< function block name>' von externem Kontext '<POU name>'. Mögliche Fehlerursache : In einer Methode eines Bausteins wird auf einen VAR_IN_OUT des Bausteins zugegriffen. Fehlerbehebung : Ändern Sie entweder die Deklaration der Variablen oder entfernen Sie die Zuweisung. Beispiel für die Warnung FUNCTION_BLOCK FB_Test\nVAR_IN_OUT\n      bInOut : BOOL;\nEND_VAR\n\nMETHOD METH: BOOL\nVAR\n      bBool : BOOL;\nEND_VAR\nbInOut := bBool; Die Zuweisung in der Methode produziert die folgende Warnung. Meldung: C0371: Zugriff auf VAR_IN_OUT 'bInOut' deklariert in 'FB_Test' von externem Kontext 'METH'. " }, 
{ "title" : "Compilerwarnung C0373 ", 
"url" : "_cds_error_c0373.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0373 ", 
"snippet" : "C0373 Meldung : Anzeige der benutzerdefinierten Meldung, die im Programmcode mit dem Pragma warning definiert wurde. Beispiel PROGRAM PLC_PRG VAR END_VAR {warning 'This is a warning'} Dieses Pragma produziert folgende Warnung: C0373:  This is a warning Für weitere Informationen siehe: Meldungspragma...", 
"body" : "C0373 Meldung : Anzeige der benutzerdefinierten Meldung, die im Programmcode mit dem Pragma warning definiert wurde. Beispiel PROGRAM PLC_PRG\nVAR\nEND_VAR\n{warning 'This is a warning'} Dieses Pragma produziert folgende Warnung: C0373:  This is a warning Für weitere Informationen siehe: Meldungspragmas" }, 
{ "title" : "Compilerfehler C0380 ", 
"url" : "_cds_error_c0380.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0380 ", 
"snippet" : "C0380 Meldung : Die Operatoren LOWER_BOUND und UPPER_BOUND werden nur für Arrays mit variabler Länge unterstützt Mögliche Fehlerursache : Einer der beiden Operatoren LOWER_BOUND oder UPPER_BOUND wird nicht für ein Array mit variabler Länge verwendet. Fehlerbehebung : Verwenden Sie die Operatoren LOW...", 
"body" : "C0380 Meldung : Die Operatoren LOWER_BOUND und UPPER_BOUND werden nur für Arrays mit variabler Länge unterstützt Mögliche Fehlerursache : Einer der beiden Operatoren LOWER_BOUND oder UPPER_BOUND wird nicht für ein Array mit variabler Länge verwendet. Fehlerbehebung : Verwenden Sie die Operatoren LOWER_BOUND oder UPPER_BOUND nur für ein Array mit variabler Länge. Ab Compilerversion 3.5.14.0 können die Operatoren auch für statische Arrays verwendet werden. Somit tritt der Fehler C0380 nur bei früheren Compilerversionen auf. Beispiel für den Fehler: FUNCTION_BLOCK POU\nVAR_IN_OUT\n arrin : ARRAY [*] OF INT;\nEND_VAR\nVAR\n arrtest : ARRAY [0..5] OF INT;\n test1: DINT;\n test2: DINT;\nEND_VAR\n\ntest1 := UPPER_BOUND(arrin, 1);\ntest2 := UPPER_BOUND(arrtest, 1);\n Meldung: C0380: Die Operatoren LOWER_BOUND und UPPER_BOUND werden nur für Arrays mit variabler Länge unterstützt " }, 
{ "title" : "Compilerfehler C0398 ", 
"url" : "_cds_error_c0398.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0398 ", 
"snippet" : "C0398 Meldung : Das Entwicklungssystem hat nicht genügend Speicher, um den Online-Change auszuführen. Bitte starten Sie die Applikation neu, bevor Sie weiterentwickeln. Mögliche Fehlerursache : Auf dem Entwicklungsrechner steht für den Compiler zu wenig Speicher zu Verfügung. Fehlerbehebung : Verwen...", 
"body" : "C0398 Meldung : Das Entwicklungssystem hat nicht genügend Speicher, um den Online-Change auszuführen. Bitte starten Sie die Applikation neu, bevor Sie weiterentwickeln. Mögliche Fehlerursache : Auf dem Entwicklungsrechner steht für den Compiler zu wenig Speicher zu Verfügung. Fehlerbehebung : Verwenden Sie die als Entwicklungsumgebung die 64-Bit Version von CODESYS oder verkleinern Sie stark Ihr CODESYS -Projekt. " }, 
{ "title" : "Compilerwarnung C0406 ", 
"url" : "_cds_error_c0406.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0406 ", 
"snippet" : "C0406 Meldung : Die implizite Prüffunktion '<Name der Prüffunktion>' ist durch eine andere Variable oder Funktion verschattet. Prüfungen werden nicht durchgeführt. Lösen Sie den Konflikt und bereinigen Sie die Applikation, um die Prüffunktion zu verwenden. Mögliche Fehlerursache : Eine Methode eines...", 
"body" : "C0406 Meldung : Die implizite Prüffunktion '<Name der Prüffunktion>' ist durch eine andere Variable oder Funktion verschattet. Prüfungen werden nicht durchgeführt. Lösen Sie den Konflikt und bereinigen Sie die Applikation, um die Prüffunktion zu verwenden. Mögliche Fehlerursache : Eine Methode eines Bausteins hat den gleichen Namen wie eine implizite Prüffunktion. Fehlerbehebung : Benennen Sie die Methode um oder entfernen Sie die implizite Prüffunktion. Beispiel für die Warnung \/\/ Automatically generated code: Do not edit\nFUNCTION CheckBounds: DINT\nVAR_INPUT\n      index, lower, upper:DINT;\nEND_VAR\n\nFUNCTION_BLOCK TestFB\nVAR\n      a:ARRAY [0..1] OF INT;\n      i : INT;\nEND_VAR\na[i] := i;\n\nMETHOD CheckBounds:DINT\nVAR_INPUT\n      index, lower, upper : DINT;\nEND_VAR Der Array-Zugiff im Baustein TestFB produziert die folgende Warnung. Meldung: C0406: Die implizite Prüffunktion 'CHECKBOUNDS' ist durch eine andere Variable oder Funktion verschattet. Prüfungen werden nicht durchgeführt. Lösen Sie den Konflikt und bereinigen Sie die Applikation, um die Prüffunktion zu verwenden. " }, 
{ "title" : "Compilerfehler C0415 ", 
"url" : "_cds_error_c0415.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0415 ", 
"snippet" : "C0415 Grundsätzlich sollten persistenter Variablen nur im unbedingt notwendigen Umfang verwendet werden. Meldung : Nicht genügend persistenter Speicher. Variable '<Variablenname>', <Anzahl> Bytes (Größte zusammenhängende Speicherlücke <Größe>). Das Bearbeiten persistenter Variablenliste kann eine Fr...", 
"body" : "C0415 Grundsätzlich sollten persistenter Variablen nur im unbedingt notwendigen Umfang verwendet werden. Meldung : Nicht genügend persistenter Speicher. Variable '<Variablenname>', <Anzahl> Bytes (Größte zusammenhängende Speicherlücke <Größe>). Das Bearbeiten persistenter Variablenliste kann eine Fragmentierung des Speichers bewirken. Führen Sie den Befehl \"Deklarationen, Liste neu ordnen und Lücken bereinigen\" aus, um die persistenten Variablenlisten zu kompakteren. Mögliche Fehlerursache : Auf dem Entwicklungsrechner steht für den Compiler zu wenig Speicher zu Verfügung. Der persistente Speicher ist für Variablen gedacht, die ihre Werte über den Download hinaus behalten sollen. Dies funktioniert nur gut, wenn sich die Typen der Variablen nicht ändern. Daher sollten möglichst wenige Variablen mit komplexen Datentypen (beispielsweise Strukturen oder Arrays von Strukturen) in den persistenten Bereich gemappt werden. Wenn sich solche Variablen ändern, können große Lücken in den persistenten Daten entstehen, die zu diesem Fehler führen. Fehlerbehebung : Die folgende Aktion kann den Fehler beheben. Wählen Sie den Befehl Liste neu ordnen und Lücken bereinigen , um die persistenten Variablen neu anzuordnen und den Speicher neu zuzuweisen. Die persistenten Variablen müssen dann neu initialisiert werden. Wenn Sie dies vermeiden möchten, können Sie für die aktuellen Werte den Befehl \" Aktuelle Werte in Rezeptur speichern \" aufrufen. Nach einem erneuten Download können Sie den Befehl Werte aus Rezeptur wiederherstellen wählen, um die Werte wiederherzustellen. Für weitere Informationen siehe: Befehl Liste neu ordnen und Lücken bereinigen, Befehl Werte aus Rezeptur wiederherstellen" }, 
{ "title" : "Compilerwarnung C0421 ", 
"url" : "_cds_error_c0421.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0421 ", 
"snippet" : "C0421 Meldung : Verwenden Sie für die Vererbung von Schnittstellen das Schlüsselwort EXTENDS anstelle von IMPLEMENTS Mögliche Fehlerursache : Eine Schnittstelle erweitert eine andere Schnittstelle, verwendet aber das Schlüsselwort IMPLEMENTS . Fehlerbehebung : Ersetzen Sie das Schlüsselwort IMPLEMEN...", 
"body" : "C0421 Meldung : Verwenden Sie für die Vererbung von Schnittstellen das Schlüsselwort EXTENDS anstelle von IMPLEMENTS Mögliche Fehlerursache : Eine Schnittstelle erweitert eine andere Schnittstelle, verwendet aber das Schlüsselwort IMPLEMENTS . Fehlerbehebung : Ersetzen Sie das Schlüsselwort IMPLEMENTS durch EXTENDS . Beispiel für die Warnung INTERFACE ITF\n\nINTERFACE ITF_1 IMPLEMENTS ITF\n Die Deklaration der Schnittstelle ITF_1 produziert die folgende Warnung. Meldung: C0421: Verwenden Sie für die Vererbung von Schnittstellen das Schlüsselwort EXTENDS anstelle von IMPLEMENTS " }, 
{ "title" : "Compilerwarnung C0426 ", 
"url" : "_cds_error_c0426.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0426 ", 
"snippet" : "C0426 Meldung : Es wird wenigstens eine Anweisung erwartet Mögliche Fehlerursache : Eine CASE -Anweisung enthält ein leeres CASE -Label. Fehlerbehebung : Entfernen Sie das leere CASE -Label oder fügen Sie diesem CASE -Label eine Anweisung hinzu. Beispiel für die Warnung PROGRAM PLC_PRG VAR       nVa...", 
"body" : "C0426 Meldung : Es wird wenigstens eine Anweisung erwartet Mögliche Fehlerursache : Eine CASE -Anweisung enthält ein leeres CASE -Label. Fehlerbehebung : Entfernen Sie das leere CASE -Label oder fügen Sie diesem CASE -Label eine Anweisung hinzu. Beispiel für die Warnung PROGRAM PLC_PRG\nVAR\n      nVar:INT;\nEND_VAR\n\nCASE nVar OF\n      1:\n      2:\n         nVar := nVar + 1;\nEND_CASE\n Das CASE -Label 1: produziert die folgende Warnung. Meldung: C0426: Es wird wenigstens eine Anweisung erwartet " }, 
{ "title" : "Compilerwarnung C0441 ", 
"url" : "_cds_error_c0441.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0441 ", 
"snippet" : "C0441 Meldung : Zugriff auf nicht initialisierte VAR_IN_OUT -Variable Mögliche Fehlerursache : Eine VAR_IN_OUT -Variable wird als Initialwert einer anderen Variablendeklaration verwendet. Fehlerbehebung : Entfernen Sie den Initialwert und weisen Sie der Variablen im Implementierungsteil den Wert zu....", 
"body" : "C0441 Meldung : Zugriff auf nicht initialisierte VAR_IN_OUT -Variable Mögliche Fehlerursache : Eine VAR_IN_OUT -Variable wird als Initialwert einer anderen Variablendeklaration verwendet. Fehlerbehebung : Entfernen Sie den Initialwert und weisen Sie der Variablen im Implementierungsteil den Wert zu. Beispiel für die Warnung FUNCTION_BLOCK POU\nVAR_INPUT\n      i:INT;\nEND_VAR\nVAR_OUTPUT\n      b:BOOL := a[i];\nEND_VAR\nVAR_IN_OUT\n      a:ARRAY [1..5] OF BOOL;\nEND_VAR\n Der Initialwert der Variablen b produziert die folgende Warnung. Meldung: C0441: Zugriff auf nicht initialisierte VAR_IN_OUT-Variable " }, 
{ "title" : "Compilerwarnung C0508 ", 
"url" : "_cds_error_c0508.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0508 ", 
"snippet" : "C0508 Meldung : Nicht eindeutige Verwendung des Namens '<identifier>' Mögliche Fehlerursache : Eine lokale Variable eines Programms hat den gleichen Namen wie eine Aktion des Programms. Fehlerbehebung : Ändern Sie den Namen der lokalen Variablen. Beispiel für die Warnung FUNCTION_BLOCK FBRead_Var VA...", 
"body" : "C0508 Meldung : Nicht eindeutige Verwendung des Namens '<identifier>' Mögliche Fehlerursache : Eine lokale Variable eines Programms hat den gleichen Namen wie eine Aktion des Programms. Fehlerbehebung : Ändern Sie den Namen der lokalen Variablen. Beispiel für die Warnung FUNCTION_BLOCK FBRead_Var\nVAR_INPUT\nEND_VAR\n...\n\nPROGRAM PLC_PRG\nVAR\n    read_input : FBRead_Var;\nEND_VAR\nread_input(); \/\/ Call of the action read_input Die Deklaration der Variablen read_input produziert die folgende Warnung. Meldung: C0508:  Nicht eindeutige Verwendung des Namens 'READ_INPUT' " }, 
{ "title" : "Compilerfehler C0509 ", 
"url" : "_cds_error_c0509.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0509 ", 
"snippet" : "C0509 Meldung : Mehrfachzuweisungen sind für Operator ‚__New‘ nicht erlaubt Mögliche Fehlerursache : Innerhalb einer Codezeile wird mehrfach der Zuweisungsoperator „ := “ zusammen mit dem __New -Operator aufgerufen. Fehlerbehebung : Programmieren Sie für jeden Pointer, der auf einen dynamisch allozi...", 
"body" : "C0509 Meldung : Mehrfachzuweisungen sind für Operator ‚__New‘ nicht erlaubt Mögliche Fehlerursache : Innerhalb einer Codezeile wird mehrfach der Zuweisungsoperator „ := “ zusammen mit dem __New -Operator aufgerufen. Fehlerbehebung : Programmieren Sie für jeden Pointer, der auf einen dynamisch allozierten Speicher zeigt, die Speicherallozierung mit dem __New -Operators in einer separaten Codezeile. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n pbAlpha : POINTER TO BYTE; \/\/ Typed pointer to Alpha\n pbBeta: POINTER TO BYTE; \/\/ Typed pointer to Beta\n xInit : BOOL := TRUE;\n xDelete : BOOL;\nEND_VAR\n\nIF (xInit) THEN\n pbBeta := pbAlpha := __NEW(BYTE); \/\/ Incorrect code for memory allocation\nEND_IF\n\npbBeta := pbAlpha := 16#01;\n\nIF (xDelete) THEN\n __DELETE(pbAlpha); \/\/ Frees memory of pointer\nEND_IF\n Meldung: C0509: Mehrfachzuweisungen sind für Operator '__NEW' nicht erlaubt Fehlerbehebung: PROGRAM PLC_PRG\nVAR\n pbAlpha : POINTER TO BYTE; \/\/ Pointer to Alpha\n pbBeta: POINTER TO BYTE; \/\/ Pointer to Beta\n xInit : BOOL := TRUE;\n xDelete : BOOL;\nEND_VAR\n\nIF (xInit) THEN\n pbAlpha := __NEW(BYTE); \/\/ Allocates memory for Alpha\n pbBeta := __NEW(BYTE); \/\/ Allocates memory for Beta\nEND_IF\n\npbBeta := pbAlpha := 16#01; \/\/ Multiple assignment\n\nIF (xDelete) THEN\n __DELETE(pbAlpha); \/\/ Frees memory of pointer\nEND_IF Für weitere Informationen siehe: __NEW" }, 
{ "title" : "Compilerfehler C0511 ", 
"url" : "_cds_error_c0511.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0511 ", 
"snippet" : "C0511 Meldung : Der Funktionsbaustein ‚<function block name>‘ ist ABSTRACT und er kann nicht als Ziel für eine Zuweisung verwendet werden. Mögliche Fehlerursache : Einem abstrakten Funktionsbaustein wurde ein Wert zugewiesen. Die konkreten Funktionsbausteine haben eventuell verschiedene Typen und kö...", 
"body" : "C0511 Meldung : Der Funktionsbaustein ‚<function block name>‘ ist ABSTRACT und er kann nicht als Ziel für eine Zuweisung verwendet werden. Mögliche Fehlerursache : Einem abstrakten Funktionsbaustein wurde ein Wert zugewiesen. Die konkreten Funktionsbausteine haben eventuell verschiedene Typen und können deswegen nicht kopiert werden. Fehlerbehebung : Um die Daten des Funktionsbausteins zu kopieren, müssen konkrete Funktionsbausteine verwendet werden. Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\nrefAbstract1 : REFERENCE TO AbstractPOU;\nrefAbstract2 : REFERENCE TO AbstractPOU;\nEND_VAR\n\nrefAbstract1 := refAbstract2;\n Meldung: C0511: Der Funktionsbaustein 'refAbstract1' ist ABSTRACT und er kann nicht als Ziel für eine Zuweisung verwendet werden Fehlerbehebung: Verwenden Sie die Referenzzuweisung REF= , um die Referenz refAbstract1 auf den selben Funktionsbaustein wie refAbstract2 verweisen zu lassen. " }, 
{ "title" : "Compilerwarnung C0513 ", 
"url" : "_cds_error_c0513.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0513 ", 
"snippet" : "C0513 Meldung : Sollte nicht auf die private Eigenschaft <POU name> <property name> zugreifen Mögliche Fehlerursache : Es wird von außerhalb des Bausteins auf ein Property des Bausteins zugegriffen, dessen Sichtbarkeit mit dem Schlüsselwort PRIVATE auf den Baustein eingeschränkt ist Fehlerbehebung :...", 
"body" : "C0513 Meldung : Sollte nicht auf die private Eigenschaft <POU name> <property name> zugreifen Mögliche Fehlerursache : Es wird von außerhalb des Bausteins auf ein Property des Bausteins zugegriffen, dessen Sichtbarkeit mit dem Schlüsselwort PRIVATE auf den Baustein eingeschränkt ist Fehlerbehebung : Ändern Sie die Sichtbarkeit des Properties (beispielsweise Schlüsselwort PRIVATE entfernen) oder ändern Sie die Deklaration der Variablen. Beispiel für die Warnung FUNCTION_BLOCK POU\nVAR_INPUT\nEND_VAR\n...\n\nPROPERTY PRIVATE Prop : UDINT\n\nPROGRAM\nPLC_PRG\nVAR\n      p:POU := STRUCT(Prop := 7);\nEND_VAR Die Deklaration der Variablen p produziert die folgende Warnung. Meldung: C0513:  Sollte nicht auf die private Eigenschaft POU Prop zugreifen " }, 
{ "title" : "Compilerwarnung C0514 ", 
"url" : "_cds_error_c0514.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0514 ", 
"snippet" : "C0514 Meldung : Sollte nicht auf die interne Eigenschaft <POU name>.<poperty name> der Bibliothek <library name> zugreifen Mögliche Fehlerursache : Eine Bibliothek enthält einen Baustein mit einem Property, dessen Sichtbarkeit mit dem Schlüsselwort INTERNAL auf diese Bibliothek eingeschränkt ist. Es...", 
"body" : "C0514 Meldung : Sollte nicht auf die interne Eigenschaft <POU name>.<poperty name> der Bibliothek <library name> zugreifen Mögliche Fehlerursache : Eine Bibliothek enthält einen Baustein mit einem Property, dessen Sichtbarkeit mit dem Schlüsselwort INTERNAL auf diese Bibliothek eingeschränkt ist. Es wird von außerhalb dieser Bibliothek auf das Property zugegriffen. Fehlerbehbung : Ändern Sie die Sichtbarkeit des Property (beispielsweise Schlüsselwort INTERNAL entfernen) oder ändern Sie die Deklaration der Variablen Beispiel für die Warnung PROGRAM PLC_PRG\nVAR\n      p1: MyLib.POU;\n      somevar1 :INT := p1.Prop;\nEND_VAR Die Deklaration der Variablen somevar1 produziert folgende Warnung: Meldung: C0514: Sollte nicht auf die interne Eigenschaft POU.Prop der Bibliothek MyLib, 1.0.0.0 (MyCompany) zugreifen " }, 
{ "title" : "Compilerwarnung C0515 ", 
"url" : "_cds_error_c0515.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0515 ", 
"snippet" : "C0515 Meldung : Sollte nicht auf die geschützte Eigenschaft <POU name> <property name> zugreifen Mögliche Fehlerursache : Es wird von außerhalb des Bausteins oder dessen Vererbungshierarchie auf ein Property des Bausteins zugegriffen, dessen Sichtbarkeit mit dem Schlüsselwort PROTECTED eingeschränkt...", 
"body" : "C0515 Meldung : Sollte nicht auf die geschützte Eigenschaft <POU name> <property name> zugreifen Mögliche Fehlerursache : Es wird von außerhalb des Bausteins oder dessen Vererbungshierarchie auf ein Property des Bausteins zugegriffen, dessen Sichtbarkeit mit dem Schlüsselwort PROTECTED eingeschränkt ist. Fehlerbehebung : Ändern Sie die Sichtbarkeit des Properties (z. B. Schlüsselwort PROTECTED entfernen) oder ändern Sie die Deklaration der Variablen. Beispiel für die Warnung FUNCTION_BLOCK POU\nVAR_INPUT\nEND_VAR\n...\n\nPROPERTY PROTECTED Prop : UDINT\n\nPROGRAM PLC_PRG\nVAR\n      p:POU := STRUCT(Prop := 7);\nEND_VAR Die Deklaration der Variablen p produziert folgende Warnung: Meldung: C0515: Sollte nicht auf die geschützte Eigenschaft POU Prop zugreifen " }, 
{ "title" : "Compilerwarnung C0516 ", 
"url" : "_cds_error_c0516.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0516 ", 
"snippet" : "C0516 Meldung : Sollte nicht auf die interne Variable <POU name>.<variable name> der Bibliothek <libray name> zugreifen Mögliche Fehlerursache : Eine Bibliothek enthält einen Baustein mit einer Variablen. Die Sichtbarkeit des Bausteins ist mit dem Schlüsselwort INTERNAL auf diese Bibliothek eingesch...", 
"body" : "C0516 Meldung : Sollte nicht auf die interne Variable <POU name>.<variable name> der Bibliothek <libray name> zugreifen Mögliche Fehlerursache : Eine Bibliothek enthält einen Baustein mit einer Variablen. Die Sichtbarkeit des Bausteins ist mit dem Schlüsselwort INTERNAL auf diese Bibliothek eingeschränkt. Es wird von außerhalb dieser Bibliothek auf die Variable zugegriffen. Fehlerbehebung : Ändern Sie die Sichtbarkeit des Bausteins (z. B. Schlüsselwort INTERNAL entfernen) oder ändern Sie die Deklaration der Variablen. Beispiel für die Warnung PROGRAM PLC_PRG\nVAR\n    somevar1 : INT := MyLib.GVL.p.varIn;\nEND_VAR Die Deklaration der Variablen somevar1 produziert die folgende Warnung. Meldung: C0516: Sollte nicht auf die interne Variable InternalPOU.varIn der Bibliothek MyLib, 1.0.0.0 (MyCompany) zugreifen " }, 
{ "title" : "Compilerwarnung C0517 ", 
"url" : "_cds_error_c0517.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0517 ", 
"snippet" : "C0517 Meldung : Sollte nicht auf das interne Objekt <object name> der Bibliothek <library name> zugreifen Mögliche Fehlerursache : Eine Bibliothek enthält einen Baustein, dessen Sichtbarkeit mit dem Schlüsselwort INTERNAL auf diese Bibliothek eingeschränkt ist. Es wird von außerhalb dieser Bibliothe...", 
"body" : "C0517 Meldung : Sollte nicht auf das interne Objekt <object name> der Bibliothek <library name> zugreifen Mögliche Fehlerursache : Eine Bibliothek enthält einen Baustein, dessen Sichtbarkeit mit dem Schlüsselwort INTERNAL auf diese Bibliothek eingeschränkt ist. Es wird von außerhalb dieser Bibliothek der Baustein in einem SIZEOF -Operator verwendet. Fehlerbehebung : Ändern Sie die Sichtbarkeit des Bausteins (z. B. Schlüsselwort INTERNAL entfernen) oder ändern Sie die Deklaration der Variablen. Beispiel für die Warnung PROGRAM PLC_PRG\nVAR\n    somevar1 : INT := SIZEOF(MyLib.POU);\nEND_VAR Meldung: C0517: Sollte nicht auf das interne Objekt POU der Bibliothek MyLib, 1.0.0.0 (MyCompany) zugreifen " }, 
{ "title" : "Compilerwarnung C0525 ", 
"url" : "_cds_error_c0525.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0525 ", 
"snippet" : "C0525 Meldung : Der Typ < type > kann in diesem Kontext keinen Standardwert haben. Mögliche Fehlerursache : Beim Initialwert eines VAR_INPUT liegt ein benutzerdefinierter Datentyp vor. Fehlerbehebung : Entfernen Sie den Initialwert. Beispiel für die Warnung FUNCTION Fun: INT VAR_INPUT       iPar : I...", 
"body" : "C0525 Meldung : Der Typ < type > kann in diesem Kontext keinen Standardwert haben. Mögliche Fehlerursache : Beim Initialwert eines VAR_INPUT liegt ein benutzerdefinierter Datentyp vor. Fehlerbehebung : Entfernen Sie den Initialwert. Beispiel für die Warnung FUNCTION Fun: INT\nVAR_INPUT\n      iPar : INT;\n      xPar : BOOL;\n      aInt : ARRAY [0..1] OF INT := [1, 2];\nEND_VAR\n\nPROGRAM PLC_PRG\nVAR\n     aInt:ARRAY [0..1] OF INT := [1, 2];\nEND_VAR\nFun(1, TRUE, aInt);\n Die Deklaration der Variablen aInt in der Funktion Fun produziert die folgende Warnung. Meldung: C0525: Der Typ ARRAY [0..1] OF INT kann in diesem Kontext keinen Standardwert haben " }, 
{ "title" : "Compilerwarnung C0526 ", 
"url" : "_cds_error_c0526.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0526 ", 
"snippet" : "C0526 Meldung : Standardwert ist nicht konstant Mögliche Fehlerursache : Beim Initialwert eines VAR_INPUT wird keine Konstante, sondern das Ergebnis eines Funktionsaufrufs verwendet. Fehlerbehebung : Verwenden Sie eine Konstante als Initialwert. Beispiel für die Warnung FUNCTION F2: INT FUNCTION F1:...", 
"body" : "C0526 Meldung : Standardwert ist nicht konstant Mögliche Fehlerursache : Beim Initialwert eines VAR_INPUT wird keine Konstante, sondern das Ergebnis eines Funktionsaufrufs verwendet. Fehlerbehebung : Verwenden Sie eine Konstante als Initialwert. Beispiel für die Warnung FUNCTION F2: INT\n\nFUNCTION F1: INT\nVAR_INPUT\n      iPar : INT := F2();\n      xPar : BOOL;\nEND_VAR Die Deklaration der Variable iPar produziert folgende Warnung. Meldung: C0526: Standardwert ist nicht konstant " }, 
{ "title" : "Compilerwarnung C0533 ", 
"url" : "_cds_error_c0533.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0533 ", 
"snippet" : "C0533 Meldung : Der Standardwert für ein VAR_OUTPUT wird nicht in abstrakten oder Schnittstellenmethoden verwendet Mögliche Fehlerursache : In einer Methode eines abstrakten Bausteins wird einem VAR_OUTPUT ein Initialwert zugewiesen. Bei Schnittstellenmethoden und abstrakten Methoden hat der Initial...", 
"body" : "C0533 Meldung : Der Standardwert für ein VAR_OUTPUT wird nicht in abstrakten oder Schnittstellenmethoden verwendet Mögliche Fehlerursache : In einer Methode eines abstrakten Bausteins wird einem VAR_OUTPUT ein Initialwert zugewiesen. Bei Schnittstellenmethoden und abstrakten Methoden hat der Initialwert am Output keine Auswirkungen, im Gegensatz zu Initialwerten am Input. Fehlerbehebung : Entfernen Sie den Initialwert beim betroffenen VAR_OUTPUT . Beispiel für die Warnung FUNCTION_BLOCK ABSTRACT POU\n\nMETHOD METH: BOOL\nVAR_INPUT\n      iPar : INT;\n      xPar : BOOL;\nEND_VAR\nVAR_OUTPUT\n      iOut : INT;\n      xOut : BOOL := TRUE;\nEND_VAR Die Deklaration der Variablen xOut produziert folgende Warnung. Meldung: C0533: Der Standardwert für ein VAR_OUTPUT wird nicht in abstrakten oder Schnittstellenmethoden verwendet " }, 
{ "title" : "Compilerwarnung C0540 ", 
"url" : "_cds_error_c0540.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0540 ", 
"snippet" : "C0540 Meldung : Attribut 'no_assign' fehlt für Baustein '<POU>'. Der Typ der Variablen '<variable>' ist mit 'no_assign' attributiert. Mögliche Fehlerursache : Ein Baustein X enthält eine Variable, deren Typ (Baustein Y) das Attribut 'no_assign' besitzt. Der Baustein X besitzt kein Attribut 'no_assig...", 
"body" : "C0540 Meldung : Attribut 'no_assign' fehlt für Baustein '<POU>'. Der Typ der Variablen '<variable>' ist mit 'no_assign' attributiert. Mögliche Fehlerursache : Ein Baustein X enthält eine Variable, deren Typ (Baustein Y) das Attribut 'no_assign' besitzt. Der Baustein X besitzt kein Attribut 'no_assign' Fehlerbehebung : Dekorieren Sie den Baustein ebenfalls mit dem Attribut 'no_assign' Beispiel für die Warnung {attribute 'no_assign'}\nFUNCTION_BLOCK FB_NotAssignable\nVAR\n      pBool : POINTER TO BOOL;\nEND_VAR\n\nFUNCTION_BLOCK FB_WrapperOfNotAssignable\nVAR\n      fbNotAssingable : FB_NotAssignable;\nEND_VAR\n\n Die Deklaration der Variablen fbNotAssignable produziert folgende Warnung. Meldung: C0540: Attribut 'no_assign' fehlt für Baustein 'FB_WrapperOfNotAssignable'. Der Typ der Variablen 'fbNotAssingable' ist mit 'no_assign' attributiert. Fehlerbehebung: Dekorieren Sie den Baustein FB_WrapperOfNotAssignable ebenfalls mit dem Attribut 'no_assign' . " }, 
{ "title" : "Compilerwarnung C0542 ", 
"url" : "_cds_error_c0542.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0542 ", 
"snippet" : "C0542 Meldung : Vererbung ist für den Datentyp „UNION“ <data type name> nicht vorgesehen. Mögliche Fehlerursache : Ein strukturierter Datentyp ( DUT ) wird durch eine Erweiterung mit EXTENDS von einer UNION abgeleitet, oder eine UNION wird von einem DUT abgeleitet. Eine solche Ableitung ist nicht zu...", 
"body" : "C0542 Meldung : Vererbung ist für den Datentyp „UNION“ <data type name> nicht vorgesehen. Mögliche Fehlerursache : Ein strukturierter Datentyp ( DUT ) wird durch eine Erweiterung mit EXTENDS von einer UNION abgeleitet, oder eine UNION wird von einem DUT abgeleitet. Eine solche Ableitung ist nicht zulässig. Aus Kompatibilitätsgründen wird aber nur eine Warnung ausgegeben. Beispiel für den Fehler: TYPE U_StringExt EXTENDS U_StringBase :\nUNION\n str10 : STRING(10);\nEND_UNION\nEND_TYPE TYPE U_StringBase :\nUNION\n str20 : STRING(20);\nEND_UNION\nEND_TYPE PROGRAM PLC_PRG\nVAR\n uStringExt : U_StringExt;\nEND_VAR\n\nuStringExt.str20 := 'a234567890b234567890'; -> C0542 " }, 
{ "title" : "Compilerfehler C0543 ", 
"url" : "_cds_error_c0543.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0543 ", 
"snippet" : "C0543 Meldung : Der Name <keyword> ist ein reserviertes Schlüsselwort im IEC1131-3-Standard. In zukünftigen Versionen wird ein Fehler ausgegeben. Mögliche Fehlerursache : Es wurde ein reserviertes Schlüsselwort als Name einer Variablen vergeben Fehlerbehebung : Umbenennen der Variable Beispiel für d...", 
"body" : "C0543 Meldung : Der Name <keyword> ist ein reserviertes Schlüsselwort im IEC1131-3-Standard. In zukünftigen Versionen wird ein Fehler ausgegeben. Mögliche Fehlerursache : Es wurde ein reserviertes Schlüsselwort als Name einer Variablen vergeben Fehlerbehebung : Umbenennen der Variable Beispiel für den Fehler: PROGRAM PLC_PRG\nVAR\n char : BYTE;\nEND_VAR\n Meldung: C0543: Der Name 'char' ist ein reserviertes Schlüsselwort im IEC1131-3-Standard. In zukünftigen Versionen wird ein Fehler ausgegeben. Hinweis: Für Verstöße in übersetzten Bibliotheken wird statt einer Warnung nur eine Textnachricht (Information) ausgegeben. Folgende Schlüsselworte sind reserviert: CHAR WCHAR ANY_DERIVED ANY_ELEMENTARY ANY_MAGNITUDE ANY_SIGNED ANY_DURATION ANY_CHARS ANY_CHAR CHAR_TO TO_CHAR WCHAR_TO TO_WCHAR ATAN2 USING CLASS " }, 
{ "title" : "Compilerfehler C0549 ", 
"url" : "_cds_error_c0549.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0549 ", 
"snippet" : "C0549 Meldung : Initialisierung der statischen Variable '<variable name>' ist nicht konstant, oder ersetzte Konstanten ist deaktiviert. Mögliche Fehlerursachen: In einer Funktionsbaustein-Deklaration werden VAR_STAT und CONSTANT -Deklarationen kombiniert verwendet Die Compile-Option Konstanten erset...", 
"body" : "C0549 Meldung : Initialisierung der statischen Variable '<variable name>' ist nicht konstant, oder ersetzte Konstanten ist deaktiviert. Mögliche Fehlerursachen: In einer Funktionsbaustein-Deklaration werden VAR_STAT und CONSTANT -Deklarationen kombiniert verwendet Die Compile-Option Konstanten ersetzen ist deaktiviert Beispiel Die Compile-Option Konstanten ersetzen ist deaktiviert. VAR CONSTANT\n iMaxInst : INT := 2;\nEND_VAR\nVAR_STAT\n iIDs : INT := iMaxInst - 1;\nEND_VAR Meldung: C0549: Initialisierung der statischen Variable 'iIDs' nicht konstant, oder ersetzte Konstanten sind deaktiviert. Fehlerbehebung : Aktivieren Sie die Compile-Option Konstanten ersetzen in Projekt → Projekteinstellungen in der Registerkarte Compile-Optionen . " }, 
{ "title" : "Compilerfehler C0550 ", 
"url" : "_cds_error_c0550.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0550 ", 
"snippet" : "C0550 Meldung : Attribut ‚pack_mode‘ für ‚FUNCTION‘ ( ‚METHOD‘ ) nicht erlaubt Mögliche Fehlerursachen : Funktionen oder Methoden, die mit dem Pragma {attribute 'pack_mode' := ' <pack mode value>' } attributiert sind Beispiel {attribute 'pack_mode' := '2'} METHOD METH : INT VAR_INPUT END_VAR {attrib...", 
"body" : "C0550 Meldung : Attribut ‚pack_mode‘ für ‚FUNCTION‘ ( ‚METHOD‘ ) nicht erlaubt Mögliche Fehlerursachen : Funktionen oder Methoden, die mit dem Pragma {attribute 'pack_mode' := ' <pack mode value>' } attributiert sind Beispiel {attribute 'pack_mode' := '2'}\nMETHOD METH : INT\nVAR_INPUT\nEND_VAR {attribute 'pack_mode' := '1'}\nFUNCTION FunPacked : DINT\nVAR_INPUT\n by1: BYTE;\nEND_VAR\nVAR\n by2: BYTE;\nEND_VAR Meldung: C0550: Attribut 'pack_mode' für 'METHOD' nicht erlaubt C0550: Attribut 'pack_mode' für 'FUNCTION' nicht erlaubt Fehlerbehebung : Löschen Sie die Attribut-Pragmas Für weitere Informationen siehe: pack_mode" }, 
{ "title" : "Compilerfehler C0554 ", 
"url" : "_cds_error_c0554.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0554 ", 
"snippet" : "C0554 Meldung : Keine expliziten Aufrufe von '<FB name>' erlaubt. <value of attribute 'no_explicit_call'> Mögliche Fehlerursachen : Ein Baustein mit dem Attribut no_explicit_call wurde aufgerufen. Beispiel {attribute 'no_explicit_call' := 'Call of this FB is not allowed'} FUNCTION_BLOCK FB1 VAR_INPU...", 
"body" : "C0554 Meldung : Keine expliziten Aufrufe von '<FB name>' erlaubt. <value of attribute 'no_explicit_call'> Mögliche Fehlerursachen : Ein Baustein mit dem Attribut no_explicit_call wurde aufgerufen. Beispiel {attribute 'no_explicit_call' := 'Call of this FB is not allowed'}\nFUNCTION_BLOCK FB1\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\nEND_VAR PROGRAM PLC_PRG\nVAR\n myFB: FB1;\nEND_VAR\n\nmyFB();\n Meldung: C0554: Keine expliziten Aufrufe von 'FB1' erlaubt. Call of this FB is not allowed Fehlerbehebung : Löschen Sie das Attribut-Pragma " }, 
{ "title" : "Compilerwarnung C0555 ", 
"url" : "_cds_error_c0555.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0555 ", 
"snippet" : "C0555 Meldung : Das Stringliteral <literal> enthält nicht darstellbare Zeichen. Die Projektoption 'UTF-8 Kodierung für STRING' könnte verwendet werden. Mögliche Fehlerursachen : Eingabe von unbekannten Zeichen, die nicht nach Latin-1transformiert werden können. Beispiel PROGRAM PLC_PRG VAR str1: STR...", 
"body" : "C0555 Meldung : Das Stringliteral <literal> enthält nicht darstellbare Zeichen. Die Projektoption 'UTF-8 Kodierung für STRING' könnte verwendet werden. Mögliche Fehlerursachen : Eingabe von unbekannten Zeichen, die nicht nach Latin-1transformiert werden können. Beispiel PROGRAM PLC_PRG\nVAR\n\tstr1: STRING(200);\n\tstr2: STRING := '1 €';\n\tstr3: STRING(200) := ' !$\"#$$%&$'()*+,-.\/0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';\nEND_VAR\n\n str1 := '你好,世界';\nstr1 := 'ABC abc 123 äöü ß#~=\" §% \/(!)[]{}\\ ´`^*~°€µ *_-.; 中文字 Ω �';\nstr1 := '1 £';\nstr1 := '1 €';\nstr1 := ' !$\"#$$%&$'()*+,-.\/0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'; Meldung: C0555: Das Stringliteral'你好,世界' enthält nicht darstellbare Zeichen. Die Projektoption 'UTF-8-Kodierung für STRING' könnte verwendet werden. Behebung : Aktivieren Sie die Option. Für weitere Informationen siehe: Compile-Optionen" }, 
{ "title" : "Compilerwarnung C0561 ", 
"url" : "_cds_error_c0561.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0561 ", 
"snippet" : "C0561 Meldung : Aufrufrekursion: <POU> -> <POU> Mögliche Fehlerursache : Der Programmcode enthält einen rekursiven Aufruf. Fehlerbehebung : Den rekursiven Aufruf entfernen, falls dieser nicht gewollt ist. Beispiel für die Warnung METHOD METH: BOOL VAR_INPUT END_VAR Recursive(); PROGRAM Recursive VAR...", 
"body" : "C0561 Meldung : Aufrufrekursion: <POU> -> <POU> Mögliche Fehlerursache : Der Programmcode enthält einen rekursiven Aufruf. Fehlerbehebung : Den rekursiven Aufruf entfernen, falls dieser nicht gewollt ist. Beispiel für die Warnung METHOD METH: BOOL\nVAR_INPUT\nEND_VAR\nRecursive();\n\nPROGRAM Recursive\nVAR\nEND_VAR\nRecursive();\n Der Aufruf von Recursive im Programm Recursive produziert folgende Warnung. Meldung: C0561:  Aufrufrekursion: RECURSIVE -> RECURSIVE " }, 
{ "title" : "Compilerwarnung C0564 ", 
"url" : "_cds_error_c0564.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0564 ", 
"snippet" : "C0564 Meldung : Eine Referenz auf die nicht initialisierte Variable <variable1> wird für die Initialisierung von <variable2> verwendet. Ein Zugriff auf die nicht initialisierte Variable kann zu unerwartetem Verhalten führen. Mögliche Fehlerursache : Eine Referenz auf eine nicht initialisierte Variab...", 
"body" : "C0564 Meldung : Eine Referenz auf die nicht initialisierte Variable <variable1> wird für die Initialisierung von <variable2> verwendet. Ein Zugriff auf die nicht initialisierte Variable kann zu unerwartetem Verhalten führen. Mögliche Fehlerursache : Eine Referenz auf eine nicht initialisierte Variable wird für die Initialisierung einer anderen Variablen verwendet. Fehlerbehebung : Deklarieren Sie <variable1> vor der Variablen <variable2>. Beispiel für die Warnung PROGRAM PLC_PRG\nVAR\n      inst : FB := STRUCT(ii := inst2);\n      inst2 : FBI;\nEND_VAR\n\n Die Initialisierung der Variablen inst bei ihrer Deklaration produziert folgende Warnung. Meldung: C0564: Eine Referenz auf die nicht initialisierte Variable inst2 wird für die Initialisierung von inst verwendet. Ein Zugriff auf die nicht initialisierte Variable kann zu unerwartetem Verhalten führen. Fehlerbehebung: Deklarieren Sie die Variable inst2 vor der Variablen inst . PROGRAM PLC_PRG\nVAR\n      inst2 : FBI;\n      inst : FB := STRUCT(ii := inst2);\nEND_VAR " }, 
{ "title" : "Compilerwarnung C0565 ", 
"url" : "_cds_error_c0565.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0565 ", 
"snippet" : "C0565 Meldung : Eine ‚FB_Exit‘-Methode eines Funktionsbausteins oder Struktur benötigt einen Eingang ‚bInCopyCode‘ vom Typ BOOL. Mögliche Ursache : Der Eingang bInCopyCode vom Typ BOOL fehlt. Behebung: Definieren Sie den Eingang Beispiel für die Warnung: PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTI...", 
"body" : "C0565 Meldung : Eine ‚FB_Exit‘-Methode eines Funktionsbausteins oder Struktur benötigt einen Eingang ‚bInCopyCode‘ vom Typ BOOL. Mögliche Ursache : Der Eingang bInCopyCode vom Typ BOOL fehlt. Behebung: Definieren Sie den Eingang Beispiel für die Warnung: PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB\nMETHOD FB_exit\nVAR_INPUT\nEND_VAR\n Meldung: C0565: Eine 'FB_Exit'-Methode eines Funktionsbausteins oder Struktur benötigt einen Eingang 'bInCopyCode' vom Typ BOOL Behebung: METHOD FB_exit\nVAR_INPUT\n bInCopyCode : BOOL;\nEND_VAR " }, 
{ "title" : "Compilerwarnung C0566 ", 
"url" : "_cds_error_c0566.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0566 ", 
"snippet" : "C0566 Meldung : Die FB_ReInit-Methode eines Funktionsbausteins oder einer Struktur darf keine Eingänge und muss einen Rückgabewert vom Typ BOOL haben. FB_ReInit wird nicht automatisch aufgerufen. Mögliche Ursache : Es sind ein oder mehrere Eingänge für FB_ReInit definiert Der Ausgang ist nicht nur e...", 
"body" : "C0566 Meldung : Die FB_ReInit-Methode eines Funktionsbausteins oder einer Struktur darf keine Eingänge und muss einen Rückgabewert vom Typ BOOL haben. FB_ReInit wird nicht automatisch aufgerufen. Mögliche Ursache : Es sind ein oder mehrere Eingänge für FB_ReInit definiert Der Ausgang ist nicht nur eine BOOL -Variable Behebung : Entfernen Sie die Eingänge der Methode FB_ReInit . Stellen Sie sicher, dass die Methode FB_ReInit nur einen Ausgang hat, und dieser Ausgang vom Typ BOOL ist. Beispiel für die Warnung METHOD FB_ReInit : BOOL\nVAR_INPUT \n input_var : INT; \/\/C0566: unexpected input for FB_ReInit\nEND_VAR\n\nVAR_OUT_PUT\n output_var : INT; \/\/C0566: wrong type for output of FB_ReInit\nEND_VAR Behebung: METHOD FB_ReInit : BOOL\n\/\/ correction: inputs have been removed\nVAR_OUTPUT\n output_var: BOOL; \/\/ correction: ouput has the correct type\nEND_VAR " }, 
{ "title" : "Compilerwarnung C0567 ", 
"url" : "_cds_error_c0567.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0567 ", 
"snippet" : "C0567 Meldung : Interface <interface name 1> erweitert nicht __System.IQueryInterface Mögliche Ursache : Jede Schnittstelle einer Schnittstellenbibliothek muss __System.IQueryInterface erweitern. Die verwendete Schnittstelle erweitert __System.IQueryInterface nicht. Beispiel PROGRAM PLC_PRG VAR ITFr...", 
"body" : "C0567 Meldung : Interface <interface name 1> erweitert nicht __System.IQueryInterface Mögliche Ursache : Jede Schnittstelle einer Schnittstellenbibliothek muss __System.IQueryInterface erweitern. Die verwendete Schnittstelle erweitert __System.IQueryInterface nicht. Beispiel PROGRAM PLC_PRG\nVAR\n ITFref : ITF;\n ITFref2 : ITF2;\nEND_VAR\n\nINTERFACE ITF\nINTERFACE ITF2 EXTENDS ITF Meldung; C0567: Interface ITF erweitert nicht __System.IQueryInterface Fehlerbehebung: INTERFACE ITF EXTENDS __System.IQueryInterface Für eine Übersicht über alle für Schnittstellenbibliotheken einzuhaltenden Regeln siehe: Schnittstellenbibliotheken " }, 
{ "title" : "Compilerwarnung C0568 ", 
"url" : "_cds_error_c0568.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0568 ", 
"snippet" : "C0568 Meldung : Schnittstelle der überladenen Methode ‚<method name>‘ von Basis ‚<function block name>‘ stimmt nicht mit der Deklaration überein Mögliche Ursache : Die Signatur der Methode der ersten Schnittstelle stimmt nicht mit der Signatur der Methode in der zweiten Schnittstelle, die um die ers...", 
"body" : "C0568 Meldung : Schnittstelle der überladenen Methode ‚<method name>‘ von Basis ‚<function block name>‘ stimmt nicht mit der Deklaration überein Mögliche Ursache : Die Signatur der Methode der ersten Schnittstelle stimmt nicht mit der Signatur der Methode in der zweiten Schnittstelle, die um die erste erweitert wird, überein. Behebung : Gleichen Sie die Signaturen an. Beispiel für die Warnung: PROGRAM PLC_PRG\nVAR\n xyz : XY2;\nEND_VAR\n\nFUNCTION_BLOCK XY\nMETHOD METH1\nVAR_INPUT\nEND_VAR\n\nFUNCTION_BLOCK XY2 EXTENDS XY\nMETHOD METH1\nVAR_INPUT\n iPar : BOOL;\nEND_VAR\n Meldung: C0568: Schnittstelle der überladenen Methode 'METH1' von Basis 'XY' stimmt nicht mit der Deklaration überein " }, 
{ "title" : "Compilerwarnung C0569 ", 
"url" : "_cds_error_c0569.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0569 ", 
"snippet" : "C0569 Meldung : Kein passender Instanzpfad für Variable <variable name> in der VAR_PERSISTENT-Liste gefunden. Verwenden Sie den Befehl 'Alle Instanzpfade hinzufügen', um alle Instanzpfade zur VAR_PERSISTENT-Liste hinzuzufügen. Mögliche Ursache : Persistente Variablen, die außerhalb der VAR_PERSISTEN...", 
"body" : "C0569 Meldung : Kein passender Instanzpfad für Variable <variable name> in der VAR_PERSISTENT-Liste gefunden. Verwenden Sie den Befehl 'Alle Instanzpfade hinzufügen', um alle Instanzpfade zur VAR_PERSISTENT-Liste hinzuzufügen. Mögliche Ursache : Persistente Variablen, die außerhalb der VAR_PERSISTENT -Liste deklariert wurden, müssen mit dem Befehl Alle Instanzpfade hinzufügen dieser Liste hinzugefügt werde. Die Warnung wird ausgegeben, wenn dieser Befehl nicht ausgeführt wird, nachdem eine persistente Variable außerhalb der VAR_PERSISTENT -Liste deklariert wurde. Behebung : Wählen Sie den Befehl Alle Instanzpfade hinzufügen des Menüs Deklarationen . Für weitere Informationen siehe: Alle Instanzpfade hinzufügen" }, 
{ "title" : "Compilerwarnung C0571 ", 
"url" : "_cds_error_c0571.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0571 ", 
"snippet" : "C0571 Meldung : FB_EXIT von Instanzen in VAR_RETAIN wird auch während Reset Warm aufgerufen, aber FB_INIT nicht. Vermeiden Sie Retain-Deklarationen von Funktionsbausteinen mit FB_EXIT . Mögliche Fehlerursache : Eine Instanz eines Bausteins, der eine FB_Exit -Methode besitzt, wird in VAR_RETAIN dekla...", 
"body" : "C0571 Meldung : FB_EXIT von Instanzen in VAR_RETAIN wird auch während Reset Warm aufgerufen, aber FB_INIT nicht. Vermeiden Sie Retain-Deklarationen von Funktionsbausteinen mit FB_EXIT . Mögliche Fehlerursache : Eine Instanz eines Bausteins, der eine FB_Exit -Methode besitzt, wird in VAR_RETAIN deklariert. Fehlerbehebung : Vermeiden Sie Retain-Deklarationen von Funktionsbausteinen mit FB_EXIT . Beispiel für die Warnung FUNCTION_BLOCK POU\n...\nMETHOD FB_Exit: BOOL\nVAR_INPUT\n      bInCopyCode : BOOL;\nEND_VAR\n...\nFUNCTION_BLOCK POU_1\nVAR\n      inst2 : POU;\nEND_VAR\n...\nPROGRAM PLC_PRG\nVAR\n      myFB : POU_1;\nEND_VAR\nmyFB();\n Die Deklaration der Variablen myFB produziert folgende Warnung. Meldung: C0571:FB_EXIT von Instanzen in VAR_RETAIN wird auch während Reset Warm aufgerufen, aber FB_INIT nicht. Vermeiden Sie Retain-Deklarationen von Funktionsbausteinen mit FB_EXIT " }, 
{ "title" : "Compilerwarnung C0572 ", 
"url" : "_cds_error_c0572.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0572 ", 
"snippet" : "C0572 Meldung : Die nicht-initialisierte Variable <variable1> wird für die Initialisierung von <variable2> verwendet. Verwenden Sie das Attribut 'global_init_slot' , um die Reihenfolge der Initialisierung zu ändern. Mögliche Fehlerursache : Bei verschachtelten Strukturen kommt anstelle des Fehlers C...", 
"body" : "C0572 Meldung : Die nicht-initialisierte Variable <variable1> wird für die Initialisierung von <variable2> verwendet. Verwenden Sie das Attribut 'global_init_slot' , um die Reihenfolge der Initialisierung zu ändern. Mögliche Fehlerursache : Bei verschachtelten Strukturen kommt anstelle des Fehlers C0268 die Warnung C0572, wenn in einer inneren Struktur eine nicht initialisierte Variable existiert. Beispiel für die Warnung GVL\n{attribute 'qualified_only'}\nVAR_GLOBAL\n      x : INT := 7;\n      y : INT := 9;\nEND_VAR\n\nTYPE DUT :\nSTRUCT\n      a : INT;\n      i : INT := GVL.x;\nEND_STRUCT\nEND_TYPE\n\nTYPE DUT_1 :\nSTRUCT\n      d : DUT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR CONSTANT " }, 
{ "title" : "Compilerwarnung C0573 ", 
"url" : "_cds_error_c0573.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0573 ", 
"snippet" : "C0573 Meldung : Das Schlüsselwort ABSTRACT fehlt Mögliche Fehlerursache : Bei einer Methode, der beim Hinzufügen die Option 'abstract' gesetzt wurde, wurde nachträglich im Editor das Schlüsselwort ABSTRACT entfernt. Fehlerbehebung : Fügen Sie das Schlüsselwort ABSTRACT im Editor wieder ein....", 
"body" : "C0573 Meldung : Das Schlüsselwort ABSTRACT fehlt Mögliche Fehlerursache : Bei einer Methode, der beim Hinzufügen die Option 'abstract' gesetzt wurde, wurde nachträglich im Editor das Schlüsselwort ABSTRACT entfernt. Fehlerbehebung : Fügen Sie das Schlüsselwort ABSTRACT im Editor wieder ein. " }, 
{ "title" : "Compilerfehler C0576 ", 
"url" : "_cds_error_c0040-1853453.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerfehler C0576 ", 
"snippet" : "C0576 Meldung : Kein Zugriff auf VAR_INST '<Variablenname>' von '<Methodenname>' von außerhalb der deklarierenden Methode Mögliche Fehlerursache : Es wird versucht, auf eine VAR_INST -Variable außerhalb der deklarierenden Methode zuzugreifen. Fehlerbehebung : Beispiel für den Fehler: FUNCTION_BLOCK ...", 
"body" : "C0576 Meldung : Kein Zugriff auf VAR_INST '<Variablenname>' von '<Methodenname>' von außerhalb der deklarierenden Methode Mögliche Fehlerursache : Es wird versucht, auf eine VAR_INST -Variable außerhalb der deklarierenden Methode zuzugreifen. Fehlerbehebung : Beispiel für den Fehler: FUNCTION_BLOCK FB_Test\n...\nMETHOD TestMethod: BOOL\nVAR_INST\n      bInst:BOOL;\nEND_VAR\n\nPROGRAM PLC_PRG\nVAR\n      fbTest:FB_Test;\n      bTest:BOOL;\nEND_VAR\nbTest := fbTest.TestMethod.bInst; \n Meldung: C0576: Kein Zugriff auf VAR_INST 'bInst' von 'TestMethod' von außerhalb der deklarierenden Methode Fehlerbehebung: Entfernen Sie die fehlerhafte Anweisung oder ändern Sie die Deklaration der Variablen, auf die zugegriffen wird (anstelle VAR_INST bei der Methode, VAR_INPUT beim Funktionsbaustein). " }, 
{ "title" : "Compilerwarnung C0579 ", 
"url" : "_cds_error_c0579.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Programmierung \/ Fehlermeldungen und Warnungen \/ Compilerwarnung C0579 ", 
"snippet" : "C0579 Meldung : Die Compiler-Funktion '<Name der Compiler-Funktion>' wird nur von der Compiler-Version <Version> oder neuer unterstützt. Mögliche Fehlerursache : Es wird eine Compiler-Funktion in einer Bibliothek mit aktivierter Option Projektkompatibilität erzwingen zu verwendet, das mit der gerade...", 
"body" : "C0579 Meldung : Die Compiler-Funktion '<Name der Compiler-Funktion>' wird nur von der Compiler-Version <Version> oder neuer unterstützt. Mögliche Fehlerursache : Es wird eine Compiler-Funktion in einer Bibliothek mit aktivierter Option Projektkompatibilität erzwingen zu verwendet, das mit der gerade eingestellten Compilerversion nicht verfügbar ist. Fehlerbehebung : Entfernen Sie die Verwendung der Funktion oder aktualisieren Sie auf die in der Meldung genannte Compilerversion. Beispiel Der Gültigkeitsbereich VAR_GENERIC CONSTANT wurde mit Compilerversion 3.5.18.0 eingeführt. Wenn diese Compiler-Funktion in einer Bibliothek mit der aktuell eingestellten Compilerversion 3.5.16.0 verwendet wird, erzeugt der Befehl \" Alle\nPoolobjekte überprüfen \" die folgende Fehlermeldung: C0579:  Die Compiler-Funktion 'Generische konstante Variable' wird erst ab der Compiler-Version 3.5.18.0 unterstützt Für weitere Informationen siehe: VAR_GENERIC CONSTANT" }, 
{ "title" : "Referenz: Benutzeroberfläche ", 
"url" : "_cds_f_reference_user_interface.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Benachrichtigungen ", 
"url" : "_cds_notification.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Benachrichtigungen ", 
"snippet" : "Über die Benachrichtigungen werden Sie über wichtige Informationen, wie verfügbare Updates oder Sicherheitshinweise, informiert. Die Ansicht Benachrichtigungen öffnen Sie über das Icon in der rechten oberen Ecke des Rahmenfensters von CODESYS . In dieser Ansicht werden alle erhaltene Benachrichtigun...", 
"body" : "Über die Benachrichtigungen werden Sie über wichtige Informationen, wie verfügbare Updates oder Sicherheitshinweise, informiert. Die Ansicht Benachrichtigungen öffnen Sie über das Icon in der rechten oberen Ecke des Rahmenfensters von CODESYS . In dieser Ansicht werden alle erhaltene Benachrichtigungen gezeigt. Als gelesen markierte Benachrichtigungen werden beim nächsten Start von CODESYS aus der Liste gelöscht. Neue Benachrichtigungen und deren Anzahl werden über ein rotes Icon signalisiert. " }, 
{ "title" : "Objekte ", 
"url" : "_cds_struct_reference_objects.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte ", 
"snippet" : "Objekte in CODESYS stellen bestimmte Funktionalitäten für die Erstellung Ihrer Applikation zur Verfügung. Beispiele: Applikation, Programm, Funktion, Bibliotheksverwalter, Gerät, Bildersammlung. Objekte werden in den Ansichten Geräte , POUs , Module in Baumstrukturen verwaltet. Sie können ein Objekt...", 
"body" : "Objekte in CODESYS stellen bestimmte Funktionalitäten für die Erstellung Ihrer Applikation zur Verfügung. Beispiele: Applikation, Programm, Funktion, Bibliotheksverwalter, Gerät, Bildersammlung. Objekte werden in den Ansichten Geräte , POUs , Module in Baumstrukturen verwaltet. Sie können ein Objekt mit dem Befehl Projekt → Objekt hinzufügen in den jeweiligen \"Baum\" einfügen . Die Einfügemöglichkeiten hängen von der Position im Baum ab. Jedes Objekt hat Eigenschaften, die Sie über das Kontextmenü des Objekts ansehen und bearbeiten können. " }, 
{ "title" : "Objekt: Applikation ", 
"url" : "_cds_obj_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Applikation ", 
"snippet" : "Applikation Symbol: Das Objekt wird als Knoten im Gerätebaum dargestellt. Es umfasst die Objekte, die für ein lauffähiges Steuerungsprogramm benötigt werden. Sie können ein Applikationsobjekt unterhalb eines Knotens SPS-Logik , also unterhalb eines programmierbaren Geräts, einhängen. Unter jeder App...", 
"body" : "Applikation Symbol: Das Objekt wird als Knoten im Gerätebaum dargestellt. Es umfasst die Objekte, die für ein lauffähiges Steuerungsprogramm benötigt werden. Sie können ein Applikationsobjekt unterhalb eines Knotens SPS-Logik , also unterhalb eines programmierbaren Geräts, einhängen. Unter jeder Applikation muss es eine Taskkonfiguration geben, in der Sie konfigurieren, welches Programm der Applikation von welcher Task mit welchen Einstellungen aufgerufen wird. Weiterhin hängen Sie unter der Applikation die Bausteine Ihres Steuerungsprogramms ein, wie beispielsweise POUs, globale Variablenlisten, Bibliotheksverwalter. Diese Bausteine sind dann nur für diese Applikation verfügbar. Ab CODESYS -Version 3.5 SP20 wird das Hinzufügen von Kindappliaktionen mit dem Befehl Objekt hinzufügen nicht mehr unterstützt. Zusätzlich kann die Applikation aber auch Instanzen projektglobaler Bausteine verwenden. Projektglobale Bausteine verwalten Sie in der Ansicht POUs . Die Verwendung solcher Instanzen entspricht der Denkweise der objektorientierten Programmierung. Unterhalb eines SPS-Geräteobjekts können mehrere Applikationen eingefügt sein. Sie müssen dazu eindeutig benannt sein. Bei einem Online-Change nach Änderung der „Vaterapplikation“ wird die „Kindapplikation“ von der SPS entfernt. Wenn mehrere Applikationen direkt unterhalb eines CODESYS -Geräts hängen, müssen Sie für die E\/A-Behandlung des Geräts die Applikation festlegen, deren Variablen für die Kommunikation mit dem Zielsystem verwendet werden soll. Die Einstellung erfolgt im Geräteeditor in der Registerkarte SPS-Einstellungen . Die Applikation, mit der Sie im Onlinebetrieb arbeiten wollen, muss als „aktive Applikation“ gesetzt sein, siehe App2 in der oben gezeigten Abbildung. Sie können eine Applikation im Dialog Eigenschaften des Applikationsobjekts, in der Registerkarte Optionen Applikationserzeugung , mit speziellen Eigenschaften versehen. Beispiel: Aktivierung dynamischer Speicherallozierung Beim Download der Applikation auf die SPS können Sie Informationen zum Applikationsinhalt mitgeben. Dies ist ebenfalls eine Einstellung in Registerkarte Optionen Applikationserzeugung . Dann können Sie später die Applikation auf der Steuerung mit der aktiven Applikation in CODESYS vergleichen. Wenn Sie der Applikation individuelle Informationen zu Autor, Version und eine individuelle Kurzbeschreibung mitgeben möchten, können Sie dazu die Angaben aus den allgemeinen Projektinformationen im Dialog Eigenschaften in der Registerkarte Information modifizieren. Wenn Sie mit einer Applikation auf das Zielgerät einloggen wollen (SPS oder Simulation), wird erst geprüft, welche Applikationen aktuell auf der SPS liegen und ob die Applikationsparameter auf der Steuerung mit denen in der Projektkonfiguration übereinstimmen. Entsprechende Meldungen zeigen Nichtübereinstimmungen und mögliche Wege des weiteren Vorgehens an. Auch können Sie in diesem Zuge Applikationen auf der SPS löschen. Für weitere Informationen siehe: Applikation auf die SPS übertragenIn der Registerkarte Applikation des Geräteeditors können Sie nachsehen, welche Applikationen gerade auf dem Gerät liegen. Dort können Sie auch Applikationen vom Zielsystem löschen. Eventuell sehen Sie in der Liste zusätzlich Applikationen, die nicht durch ein separates Objekt im Gerätebaum vertreten sind, wie beispielsweise die <Applikation>_symbols.app , die eine für die Applikation erzeugte Symbolliste enthält (siehe „Symbolkonfiguration“). " }, 
{ "title" : "Objekte für Alarmverwaltung ", 
"url" : "_cds_obj_alarm_objects.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekte für Alarmverwaltung ", 
"snippet" : "Die Hilfeseiten zur Alarmverwaltung sind in der Hilfe zur Visualisierung zusammengefasst. Sehen Sie deshalb dort für Hilfe zu den folgenden Objekten: Objekt Alarmkonfiguration Objekt Alarmklasse Objekt Alarmgruppe Objekt Alarmspeicherung Objekt Entfernte Alarme...", 
"body" : "Die Hilfeseiten zur Alarmverwaltung sind in der Hilfe zur Visualisierung zusammengefasst. Sehen Sie deshalb dort für Hilfe zu den folgenden Objekten: Objekt Alarmkonfiguration Objekt Alarmklasse Objekt Alarmgruppe Objekt Alarmspeicherung Objekt Entfernte Alarme " }, 
{ "title" : "Objekt: Bibliotheksverwalter ", 
"url" : "_cds_obj_library_manager.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Bibliotheksverwalter ", 
"snippet" : "Bibliotheksverwalter Symbol: Der Bibliotheksverwalter listet alle Bibliotheken auf, die zur Applikationserstellung im Projekt eingebunden wurden. Er informiert jeweils über ihren Typ, ihre Eigenschaften und ihren Inhalt. Sie können die Liste der eingebundenen Bibliotheken erweitern oder reduzieren, ...", 
"body" : "Bibliotheksverwalter Symbol: Der Bibliotheksverwalter listet alle Bibliotheken auf, die zur Applikationserstellung im Projekt eingebunden wurden. Er informiert jeweils über ihren Typ, ihre Eigenschaften und ihren Inhalt. Sie können die Liste der eingebundenen Bibliotheken erweitern oder reduzieren, sowie bei nicht abhängigen Bibliotheken die Bibliothekseigenschaften bearbeiten. Der Bibliotheksverwalter besteht aus 3 Fensterteilen: Oberer Fensterbereich: Liste der eingebundenen Bibliotheken Unterer linker Fensterbereich: Baumstruktur mit allen Bausteinen der oben gerade selektierten Bibliothek Unterer rechter Fensterbereich: Dokumentation zu dem im Baum selektierten Bibliotheksbaustein Für weitere Informationen siehe: Bibliotheken verwenden und Informationen für Bibliotheksentwickler" }, 
{ "title" : "Liste der eingebundenen Bibliotheken ", 
"url" : "_cds_obj_library_manager.html#UUID-9b9a510b-0925-f73b-58bd-0ea218f5f2d6_id_ad23efddceafc3f3c0a8640e012263e7_id_fc299100cef8fcc5c0a8640e01a9c911", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Bibliotheksverwalter \/ Liste der eingebundenen Bibliotheken ", 
"snippet" : "Wenn eine Bibliothek von anderen Bibliotheken abhängt, werden diese referenzierten Bibliotheken automatisch eingebunden. Darstellung in grauer Schrift Die Bibliothek wurde automatisch durch ein Plug-in in das Projekt eingefügt. Darstellung in schwarzer Schrift Die Bibliothek wurde mit dem Befehl Bib...", 
"body" : "Wenn eine Bibliothek von anderen Bibliotheken abhängt, werden diese referenzierten Bibliotheken automatisch eingebunden. Darstellung in grauer Schrift Die Bibliothek wurde automatisch durch ein Plug-in in das Projekt eingefügt. Darstellung in schwarzer Schrift Die Bibliothek wurde mit dem Befehl Bibliothek hinzufügen in das Projekt eingefügt. Name Darstellung der eingebundenen Bibliothek gemäß folgender Syntax: <Platzhaltername> = <Bibliotheksname>, <Version> (<Firma>): <Platzhaltername> : Wenn es sich bei der Bibliothek um eine Platzhalterbibliothek handelt, steht der Platzhaltername vor einem = . <Platzhaltername> = (nicht aufgelöst) : Die Platzhalterbibliothek ist ohne Auflösung. <Bibliotheksname> : Name der Bibliothek, unter dem sie im Bibliotheksrepository verwaltet wird <Version> : Version, die beim erstmaligen Einbinden referenziert wurde (<Firma>) : Anbieter (optional) Namensraum Namensraum für einen eindeutigen Zugriff auf den Inhalt der Bibliothek Er wird dazu als Präfix vor einem Bausteinbezeichner verwendet: <Namensraum>.<Bibliotheksbausteinbezeichner> Üblicherweise stimmt der Namensraum mit dem Bibliotheksnamen überein. Hinweis: Wenn die Bibliothek die Eigenschaft LanguageModelAttribute \"qualified-access-only\" hat, müssen Sie im Applikationscode über den Namensraum auf den Bibliotheksbaustein zugreifen. Ein qualifizierter (eindeutiger) Zugriff wird erzwungen. Sie können den Standardnamensraum für den lokalen Gebrauch (innerhalb des Projekts) im Dialog Eigenschaften ändern. Effektive Version Version der Bibliothek nach der Auflösung Diese Version der Bibliothek wird in der Applikation verwendet. Voraussetzung: Der Bibliotheksverwalter liegt in der Ansicht Geräte und eine Platzhalterbibliothek ist selektiert. Beispiel: 3.5.10.0 Symbol, dessen Tooltip über die aktuelle vom Standard abweichende Auflösung der gerade selektierten Platzhalter-Bibliothek informiert Beispiel, wenn der Bibliotheksverwalter in der Ansicht Geräte liegt: Dieser Platzhalter wird explizit auf diese Version umgelenkt (siehe Dialog Platzhalter). Beispiel, wenn der Bibliotheksverwalter in der Ansicht POUs liegt: In Gerät 'Device_1‘, wird dieser Platzhalter aufgelöst zu 'VisuElemsAlarms, 1.0.0.0 (System)'. Bibliothek, die mit einem vertrauenswürdigen Zertifikat signiert ist, kompatibel mit CODESYS >= V 3.5 SP15 Bibliothek, die mit einem vertrauenswürdigen Zertifikat signiert ist, aber mindestens eine unsignierte Bibliothek referenziert Bibliothek, die mit einem privaten Schlüssel + Token signiert ist, kompatibel mit CODESYS >= V 3.5 SP15 Bibliothek, die nicht signiert ist, oder die mit einem nicht vertrauenswürdigen oder mit einem abgelaufenen Zertifikat signiert ist Im Fall eines nicht vertrauenswürdigen Zertifikats steht im Kontextmenü der Befehl Zertifikat vertrauen zur Verfügung. Nicht verfügbare Bibliothek oder nicht aufgelöste Platzhalterbibliothek Tipp: Weisen Sie dem Platzhalter eine verfügbare Bibliothek zu. Klicken Sie dafür auf das Befehlsicon . Dort können Sie den Platzhalter bearbeiten und beispielsweise die neueste Version, oder eine andere Bibliothek zuweisen. Bibliothek, die als optional definiert ist und die aktuell nicht verfügbar ist Bibliothek, für die der Status gerade noch bestimmt wird Lizenzierte Bibliothek, für die gerade keine gültige Lizenz vorliegt Bibliothekssymbol für eine Bibliothek, die nicht geladen werden kann, weil ihre Signatur (Verschlüsselung) nicht verifiziert werden konnte Bibliotheken, die vom Bibliotheksverwalter im POU-Pool verwaltet werden Befehle im Bibliotheksverwalter Bibliothek hinzufügen Öffnet einen Dialog zum Auswählen einer Bibliothek Es werden alle im Bibliotheksrepository installierten Bibliotheken angeboten. Bibliothek löschen Entfernt die gerade selektierte Bibliothek aus dem Projekt Eigenschaften Öffnet einen Dialog zur Anzeige und Bearbeitung der Eigenschaften der gerade selektierten Bibliothek Details Öffnet einen Dialog mit Details zur gerade selektierten Bibliothek (allgemeine Informationen, Inhalt, Eigenschaften, Lizenzinformation) Versuchen Bibliothek neu zu laden Wenn Sie eine als nicht gefunden markierte Bibliothek selektieren, können Sie mit diesem Befehl ein erneutes Laden ins Projekt versuchen. Download fehlender Bibliotheken Öffnet einen Dialog, in dem die im Bibliotheksverwalter als fehlend gekennzeichneten Bibliotheken angezeigt werden. Beim Download durchsucht CODESYS die in den Projektoptionen angegebenen Download-Server nach diesen Bibliotheken. Nach dem Download werden diese automatisch installiert. Solange dieser Dialog geöffnet ist, können die neu installierten Bibliotheken wieder deinstalliert werden. Platzhalter Öffnet den Dialog Platzhalter . Dort wird die aktuelle Auflösung dargestellt und Sie können sie bearbeiten. Bibliotheksparameter Öffnet den Dialog Bibliotheksparameter . Dort werden die Parameter der Bibliotheken angezeigt, die im Bibliotheksverwalters der Applikation und des POU-Pools vorhanden sind. Sie können die Parameter in diesem Dialog anpassen. Bibliotheksrepository Öffnet den Dialog Bibliotheksrepository zum Installieren und Deinstallieren von Bibliotheken sowie zum Definieren von Bibliotheksablageorten Icon-Legende Öffnet den Dialog Information mit einer Legende zu den Icons, die in der Liste der eingebundenen Bibliotheken (siehe oben) den aktuellen Status einer Bibliothek anzeigen Zusammenfassung Öffnet den Dialog Bibliothekszusammenfassung In dem Dialog werden in einer Baumstruktur alle im Projekt referenzierten Bibliotheken angezeigt und diejenigen Bibliotheken, die diese Bibliotheken referenzieren. Befehl Alle Vorkommen in der Bibliothekshierarchie anzeigen und Dialog schließen : Im Editor des Bibliotheksverwalters werden in der geöffneten Baumstruktur die Bibliotheken markiert, die diese Bibliothek referenzieren oder verwenden. Voraussetzung ist, dass eine Bibliothek selektiert ist. Der Dialog Information wird anschließend geschlossen. Wenn Sie eine Bibliothek doppelklicken, wird dieser Befehl ebenfalls ausgeführt. Anzeige der Bibliotheken Verwaltete Bibliothek : Name und Version der Bibliothek Anzahl der Vorkommen : Anzahl der Stellen, an denen diese Bibliothek von anderen Bibliotheken referenziert wird Wenn Sie bei einer Bibliothek auf + klicken, werden in der nächsten darunterliegenden Ebene die Bibliotheken angezeigt, die diese Bibliothek referenzieren. Zertifikat vertrauen Nur im Kontextmenü einer im Bibliotheksverwalter selektierten Bibliothek, die mit einem nicht vertrauenswürdigen Zertifikat signiert wurde Der Befehl macht das Zertifikat zu einem vertrauenswürdigen, das vorangestellte Icon ändert sich von zu . Bibliothek exportieren Nur im Kontextmenü einer im Bibliotheksverwalter selektierten Bibliothek Öffnet den Standarddialog zum Speichern der Bibliotheksdatei im Dateisystem " }, 
{ "title" : "Baumstruktur aller Bausteine einer selektierten Bibliothek ", 
"url" : "_cds_obj_library_manager.html#UUID-9b9a510b-0925-f73b-58bd-0ea218f5f2d6_id_ad23efddceafc3f3c0a8640e012263e7_id_6cd6c4dccef8fcc5c0a8640e01f982cf", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Bibliotheksverwalter \/ Baumstruktur aller Bausteine einer selektierten Bibliothek ", 
"snippet" : "Inhalt der selektierten Bibliothek <Bibliotheksname> Alle Bibliotheksbausteine, die mit der Bibliothek eingebunden wurden, sind in einer Baumstruktur aufgelistet. Voraussetzung: Eine Bibliothek ist im oberen Fensterbereich selektiert. Die üblichen Sortier- und Suchfunktionen stehen in der Menüleiste...", 
"body" : "Inhalt der selektierten Bibliothek <Bibliotheksname> Alle Bibliotheksbausteine, die mit der Bibliothek eingebunden wurden, sind in einer Baumstruktur aufgelistet. Voraussetzung: Eine Bibliothek ist im oberen Fensterbereich selektiert. Die üblichen Sortier- und Suchfunktionen stehen in der Menüleiste zur Verfügung. " }, 
{ "title" : "Dokumentation des im linken unteren Fensterbereich ausgewählten Bibliotheksbausteins ", 
"url" : "_cds_obj_library_manager.html#UUID-9b9a510b-0925-f73b-58bd-0ea218f5f2d6_id_ad23efddceafc3f3c0a8640e012263e7_id_b14c72af30bf9a91c0a864635d6eb897", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Bibliotheksverwalter \/ Dokumentation des im linken unteren Fensterbereich ausgewählten Bibliotheksbausteins ", 
"snippet" : "Die Dokumentation von Implementierungsbibliotheken muss einmalig erzeugt werden. Dies erfolgt über den Befehl Klicken zur Aktualisierung der Bibliotheksdokumentation . Registerkarte Eingänge\/Ausgänge Schnittstelle (Eingänge\/Ausgänge) des Bibliotheksbausteins Registerkarte Graphisch Graphische Darste...", 
"body" : "Die Dokumentation von Implementierungsbibliotheken muss einmalig erzeugt werden. Dies erfolgt über den Befehl Klicken zur Aktualisierung der Bibliotheksdokumentation . Registerkarte Eingänge\/Ausgänge Schnittstelle (Eingänge\/Ausgänge) des Bibliotheksbausteins Registerkarte Graphisch Graphische Darstellung der Schnittstelle Registerkarte Dokumentation Dokumentation des Bibliotheksbausteins Hinweis: Beachten sie als Bibliotheksentwickler unbedingt die Regeln zur Dokumentationsmitgabe in „Richtlinien zur Bibliotheksentwicklung“. Für weitere Informationen siehe: Library Development Summary Registerkarte Bibliotheksparameter Voraussetzung: Das Bibliotheksprojekt enthält ein Objekt mit Bibliotheksparametern. Auf der Registerkarte befindet sich der Befehl Konfigurationsdialog öffnen . Dieser Befehl öffnet den Dialog Bibliotheksparameter. " }, 
{ "title" : "Objekt: DUT ", 
"url" : "_cds_obj_dut.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: DUT ", 
"snippet" : "DUT Ein DUT (Data Unit Type) deklariert einen anwenderspezifischen Datentyp. Symbol: DUT Enumeration mit Textlistenunterstützung Sie können ein solches Objekt unterhalb der Applikation oder in der Ansicht POUs hinzufügen. Beim Anlegen des Objekts öffnet sich der Dialog DUT hinzufügen . Dort können S...", 
"body" : "DUT Ein DUT (Data Unit Type) deklariert einen anwenderspezifischen Datentyp. Symbol: DUT Enumeration mit Textlistenunterstützung Sie können ein solches Objekt unterhalb der Applikation oder in der Ansicht POUs hinzufügen. Beim Anlegen des Objekts öffnet sich der Dialog DUT hinzufügen . Dort können Sie den neuen Datentyp konfigurieren und zwischen den Konstrukten Struktur, Enumeration, Alias und Union wählen. Syntax für die Deklaration der benutzerdefinierten Datentypen TYPE <identifier> : <data type declaration> END_TYPE DUT-Konstrukt Eine benutzerdefinierte Datentypdeklaration wird von TYPE und END_TYPE eingeklammert. TYPE <identifier> : STRUCT     <member deklaration> END_STRUCT END_TYPE Eine Struktur umschließt ihre Komponenten mit STRUCT und END_STRUCT . Es können beliebig viele Komponenten deklariert werden, jedoch mindestens zwei. STRUCTTYPE <identifier> : (     <list of members> ) <base data type> := <inittialization> ; END_TYPE Eine Enumeration ist eine durch Komma separierte Liste von Komponentennamen in runden Klammern. Alle Komponenten haben den gleichen Datentyp. Eine Enumeration kann zusätzlich eine Textliste zugeordnet haben. Diese dient dazu, die Werte der Enumeration zu lokalisieren. Das Objekt verfügt dann zusätzlich über eine Lokalisierungsansicht. EnumerationTYPE <identifier> : <data type name> ; END_TYPE Ein Alias ist ein alternativer Bezeichner. AliasTYPE <identifier> : UNION     <member declaration> END_UNION END_TYPE Ein Union umschließt ihre Komponenten mit N UNION und END_UNION . Sie ist ein Datentyp mit mehrere Komponenten, die sich einen Speicherplatz teilen. UNIONBeispiel Deklaration der Struktur S_POLYGONLINE mit teilweiser Initialisierung von Komponenten TYPE S_POLYGONLINE :\nSTRUCT\n aiStart : ARRAY[1..2] OF INT := [-99, -99];\n aiPoint1 : ARRAY[1..2] OF INT;\n aiPoint2 : ARRAY[1..2] OF INT;\n aiPoint3 : ARRAY[1..2] OF INT;\n aiPoint4 : ARRAY[1..2] OF INT;\n aiEnd : ARRAY[1..2] OF INT := [99, 99];\nEND_STRUCT\nEND_TYPE Deklaration der Struktur S_PENTAGON als Erweiterung von S_POLYGONLINE TYPE S_PENTAGON EXTENDS S_POLYGONLINE :\nSTRUCT\n aiPoint5 : ARRAY[1..2] OF INT;\nEND_STRUCT\nEND_TYPE Beispiel Deklaration der Enumeration E_TRAFFICSIGNAL {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_TRAFFICSIGNAL :\n(\n eRed,\n eYellow,\n eGreen := 10\n);\nEND_TYPE Enumeration mit Textlistenunterstützung in der Lokalisierungsansicht Am rechten Rand des Editors befinden sich die Schaltflächen Textuelle Ansicht und Lokalisierungsansicht . Mit Klick auf die Schaltflächen können Sie zwischen den Ansichten wechseln. Beispiel Deklaration eines Alias TYPE A_MESSAGE : STRING[50];\nEND_TYPE Beispiel Deklaration einer UNION TYPE U_DATA :\nUNION\n lrA : LREAL;\n liA : LINT;\n dwA : DWORD;\nEND_UNION\nEND_TYPE " }, 
{ "title" : "Dialog: DUT hinzufügen ", 
"url" : "_cds_obj_dut.html#UUID-a00e77a7-6296-ccb7-ec7b-23e513eff544_id_c3f3067aba82cc0a8640e00158fd5_id_e443a77ca18a3080c0a8646312bf4a62", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: DUT \/ Dialog: DUT hinzufügen ", 
"snippet" : "Funktion : Der Dialog dient der Konfiguration eines neuen Objekts DUT (Data Unit Type). Aufruf : Menü Projekt → Objekt hinzufügen → DUT , Kontextmenü des Applikationsobjekts Name Name des neuen Datentyps DUT Beispiel: S_POLYGONLINE Datentyp Struktur Legt ein Objekt an, das eine Struktur deklariert, ...", 
"body" : "Funktion : Der Dialog dient der Konfiguration eines neuen Objekts DUT (Data Unit Type). Aufruf : Menü Projekt → Objekt hinzufügen → DUT , Kontextmenü des Applikationsobjekts Name Name des neuen Datentyps DUT Beispiel: S_POLYGONLINE Datentyp Struktur Legt ein Objekt an, das eine Struktur deklariert, die mehrere Variablen mit unterschiedlichen Datentypen zu einer logischen Einheit zusammenfasst Die innerhalb der Struktur deklarierten Variablen werden als Komponenten bezeichnet. Beispiel: S_POLYGONLINE Erweitert : Erweitert eine bereits bestehende Struktur um weitere Komponenten Geben Sie eine bestehende Struktur im Eingabefeld daneben an. Die Komponenten der bestehenden Strukur sind automatisch in der neuen verfügbar. Beispiel: S_PENTAGON Enumeration Legt ein Objekt an, das eine Enumeration deklariert, die mehrere Integer-Konstanten zu einer logischen Einheit zusammenfasst Die innerhalb einer Enumeration deklarierten Konstanten werden auch als Enumerationswert bezeichnet. Beispiel: E_TRAFFICSIGNAL Eine Enumeration kann zusätzlich eine Textliste haben. Diese dient dazu, die Werte der Enumeration zu lokalisieren. Das Objekt verfügt dann zusätzlich über eine Lokalisierungsansicht. Textlistenunterstützung hinzufügen : Enumeration, die über keine Textlistenunterstützung verfügt : Enumeration mit zusätzlich hinterlegter Textliste für die Enumerationswerte Die Textliste ermöglicht Ihnen, die Namen der Enumerationswerte zu lokalisieren. Beispiel: ETL_TRAFFICSIGNAL Hinweis: Bei einem bestehenden Enumerationstypen kann die Textlistenunterstützung jederzeit nachträglich hinzugefügt oder wieder entfernt werden. Dazu dienen die Befehle im Kontextmenü des Objekts: Textlistenunterstützung hinzufügen Textlistenunterstützung entfernen Tipp: Die lokalisierten Texte können Sie beispielsweise in einer Visualisierung ausgeben. Dann erscheint in der Textausgabe eines Visualisierungselements statt der numerischen Enumerationswerte die symbolischen in der aktuellen Sprache. Wenn eine textlistenunterstützte Enumerationsvariable in der Eigenschaft Textvariable eines Visualisierungselements eingetragen wird, erhält sie folgenden Zusatz: < <enumeration name> > Beispiel: Sie verwenden in einer Visualisierung die Variable PLC_PRG.eTrafficLight des Typs ETL_TRAFFICSIGNAL . ETL_TRAFFICSIGNAL ist eine textlistenunterstützte Enumeration. Der Eintrag im Eigenschafteneditor des Visualisierungselements sieht dann wie folgt aus: PLC_PRG.eTrafficLight <ETL_TRAFFICSIGNAL> . Für weitere Informationen siehe auch: Texte verwenden Tipp: Wenn Sie den Enumerationstyp in der Applikation editieren, erscheint beim Schließen eine Eingabeaufforderung mit der Frage, ob die betroffenen Visualisierungen automatisch aktualisieren werden sollen. Alias Legt ein Objekt an, das ein Alias deklariert, mit dem ein alternativer Name für einen Basistyp, Datentyp oder einen Funktionsbaustein deklariert wird Beispiel: A_MESSAGE Union Legt ein Objekt an, das eine Union deklariert, die mehrere Komponenten mit meist unterschiedlichen Datentypen zu einer logischen Einheit zusammenfasst Alle Komponenten haben den gleichen Offset, so dass sie am selben Speicherplatz liegen. Der Speicherplatzbedarf einer Union wird bestimmt durch den Speicherplatzbedarf seiner „größten“ Komponente. Beispiel: U_DATA Hinzufügen Beendet den Dialog und legt das neue Objekt an Das Objekt erscheint im Gerätebaum oder in der Ansicht POUs mit dem Symbol . Wenn zusätzlich beim Objekt eine Textliste hinterlegt ist, erscheint das Symbol . " }, 
{ "title" : "Objekt: Externe Datei ", 
"url" : "_cds_obj_external_file.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Externe Datei ", 
"snippet" : "Externe Datei Eine Externe Datei ist eine beliebige Datei, die Sie dem Projekt in der Ansicht POUs oder Geräte als Objekt hinzufügen. Verwenden Sie den Befehl Projekt → Objekt hinzufügen und legen Sie im Dialog Externe Datei hinzufügen fest, in welcher Form die Datei dem Projekt angehört. Das Übertr...", 
"body" : "Externe Datei Eine Externe Datei ist eine beliebige Datei, die Sie dem Projekt in der Ansicht POUs oder Geräte als Objekt hinzufügen. Verwenden Sie den Befehl Projekt → Objekt hinzufügen und legen Sie im Dialog Externe Datei hinzufügen fest, in welcher Form die Datei dem Projekt angehört. Das Übertragen von externen Dateien auf die Steuerung kann mit der Option Übertragung mit Download\/Online-Change konfiguriert werden. Wenn eine Externe Datei auf der Steuerung geändert wird, wird sie im Projekt in keinem Fall aktualisiert. Für weitere Informationen siehe: Registerkarte: Synchronisierte Dateien" }, 
{ "title" : "Dialog: Externe Datei hinzufügen ", 
"url" : "_cds_obj_external_file.html#UUID-df1ad64c-b999-f57c-46aa-2b3f52722fdb_id_b2054b53d955bf7c0a8640e017bbd78_id_559ac53835cd4544c0a8640e01b2e037", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Externe Datei \/ Dialog: Externe Datei hinzufügen ", 
"snippet" : "Dateipfad Pfad der externen Datei Die Schaltfläche öffnet einen Dialog zur Auswahl einer Datei im lokalen Dateisystem. Name Objektname für die Datei in CODESYS Wenn Sie nichts eingeben, erscheint die Datei mit ihrem bisherigen Dateinamen. Verwaltung der Datei Legt fest, wie im CODESYS -Projekt die e...", 
"body" : "Dateipfad Pfad der externen Datei Die Schaltfläche öffnet einen Dialog zur Auswahl einer Datei im lokalen Dateisystem. Name Objektname für die Datei in CODESYS Wenn Sie nichts eingeben, erscheint die Datei mit ihrem bisherigen Dateinamen. Verwaltung der Datei Legt fest, wie im CODESYS -Projekt die externe Datei gespeichert wird Die Verknüpfung speichern : Gespeichert wird die Dateiverknüpfung, die auf die externe Datei im Windows Dateisystem verweist Hinweis: Der Zugriff über die Dateiverknüpfung schlägt fehl, wenn der externe Speicherort der Datei sich ändert. Die Datei ist nur im Projekt verfügbar, solange sie im angegebenen Speicherort vorhanden ist. Die Verknüpfung speichern und ins Projekt einbetten : Gespeichert wird die Dateiverknüpfung, die auf die externe Datei im Windows Dateisystem verweist. Zusätzlich wird, um die Sicherheit zu erhöhen, eine Kopie der Datei im Projekt abgelegt Hinweis zum Verhalten bei Zugriff: Nur wenn der Zugriff über die Verknüpfung fehl schlägt, wird auf die Kopie im Projekt zurückgegriffen. Wenn die externe Datei sich ändert, wird die Kopie entsprechend der unten ausgewählten Option unter Verfolgung von Änerungen behandelt. Ins Projekt einbetten : Es wird eine Kopie der externen Datei im CODESYS -Projekt gespeichert. Es wird immer auf die Kopie zugegriffen. Wenn sich die externe Datei ändert, wird die projektinterne Kopie nicht aktualisiert. Wenn die externe Datei im CODESYS Development System geöffnet wird (Befehl Objekt bearbeiten ), wird zur Bearbeitung eine temporäre Datei erzeugt. Verfolgung von Änderungen Art der Aktualisierung für die im Projekt gespeicherten Kopie, für die gleichzeitig eine Dateiverknüpfung gespeichert wurde Voraussetzung: Die Option Die Verknüpfung speichern und ins Projekt einbetten ist aktiviert. Die Datei automatisch neu laden : Wenn sich die externe Datei ändert, wird automatisch die im Projekt gespeicherte Kopie aktualisiert. Nachfragen, ob die Datei neu geladen werden soll : Wenn sich die externe Datei ändert, erscheint ein Dialog mit der Abfrage, ob die Kopie im Projekt aktualisiert werden soll. Nichts tun : Obwohl die externe Datei sich ändert, bleibt die Kopie im Projekt unverändert. Schaltfläche Dateieigenschaften anzeigen Öffnet den Standarddialog Eigenschaften von <Dateiname> der externen Datei im Windows-Dateisystem Dieser Dialog ist identisch mit dem Dialog Eigenschaften , der in Windows über das Kontextmenü der Datei geöffnet werden kann. Online-Handling Behandlung der Datei während des Onlinebetriebs Übertragung mit Download\/Online-Change : Bei Download und Online-Change wird die externe Datei mit auf die Steuerung geladen und im Zielsystempfad abgelegt. Hinweis: Externen Dateien, die in der Ansicht POUs eingefügt sind, werden beim Download auf alle Steuerungen im Projekt übertragen. Diese Option hat keine Auswirkung auf externe Dateien in Bibliotheken. Diese Dateien werden grundsätzlich nicht übertragen. Zielsystempfad (relativ zu \"$PlcLogic$\" auf dem Gerät) Der Zielsystempfad kann auf folgende Weise eingegeben werden: Für Wurzelverzeichnis $PlcLogic$ : Eingabefeld leer lassen Individueller Ordner (noch nicht vorhanden) im Wurzelverzeichnis Beispiel: MySubDirectory Ordner der Applikation (unterhalb von $PlcLogic$ ) Beispiel für Applikation \"App123\" : App123 Verschachtelte Ordnerstruktur unterhalb des Applikationsordners Beispiel: App123\/Sub01\/SubSub01 Einen anderen vorhandenen Platzhalter verwenden, wie beispielsweise den für die Visualisierung: $visu$ Bei der Verwendung vorhandener Pfade auf dem Gerät muss die Groß- und Kleinschreibung beachtet werden. Schaltfläche Hinzufügen Fügt ein neues Objekt (Typ Externe Datei ) ein. Für weitere Informationen siehe: Eigenschaften: Externe Datei" }, 
{ "title" : "Objekt: C-implementierte Bibliothek ", 
"url" : "_cds_obj_c_implemented_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: C-implementierte Bibliothek ", 
"snippet" : "C-implementierte Bibliothek Symbol: Sie fügen das Objekt einem Bibliotheksprojekt in der Ansicht POUs hinzu. Eine C-implementierte Bibliothek kann mehrere vorkompilierte Module enthalten, wobei jedes dieser Module einem bestimmten Gerät zugeordnet ist. Im Bibliotheksverwalter sind die eingefügten Mo...", 
"body" : "C-implementierte Bibliothek Symbol: Sie fügen das Objekt einem Bibliotheksprojekt in der Ansicht POUs hinzu. Eine C-implementierte Bibliothek kann mehrere vorkompilierte Module enthalten, wobei jedes dieser Module einem bestimmten Gerät zugeordnet ist. Im Bibliotheksverwalter sind die eingefügten Module nicht sichtbar. Wenn Sie das Objekt in der Ansicht POUs doppelklicken, öffnet es sich in seinem Editor. Kompilierte Komponenten Objektdateien für Geräte Auflistung der Geräte mit dem zugeordneten Modul mit folgenden Informationen: Gerät , Version , Dateiname , Dateigröße Hinzufügen Öffnet den Dialog Gerät auswählen , wo Sie ein vorkompiliertes Modul einem Gerät zuweisen können und der C-implementierten Bibliothek hinzufügen können Es können beliebig viele Module in einem solchen Objekt hinzugefügt werden. Beim Download eines konkreten Projekts mit dieser Bibliothek auf ein Gerät wird nur die jeweils passende Datei auf das Gerät geladen. Entfernen Entfernt den ausgewählten Eintrag in Objektdateien für Geräte Gerät auswählen Objektdatei Eingabe einer Datei, die zum Gerät passt und vom Betriebssystem als dynamisches Objekt geladen werden kann Beispiel für Windows: *.dll Beispiel für Linux: *.so Hinweis: Die Datei *.dll muss im Namen den Titel des Bibliotheksprojekts enthalten. Beispiel: Wenn das Bibliotheksprojekt den Namen XYlib hat, dann muss die Objektdatei heißen: <Name>_XYlib.dll Gerät Anbieter Auflistung der Geräte Optionen Nach Kategorien gruppieren : : Die verfügbaren Geräte (neueste Version) sind nach Kategorien sortiert. Die Kategorie ist in der Gerätebeschreibungsdatei definiert. : Die verfügbaren Geräte erscheinen flach und alphabetisch sortiert. Alle Versionen anzeigen (nur für Experten) : Zusätzlich stehen auch alle anderen verfügbaren Versionen der Geräte zur Auswahl. : Nur die neueste Version jedes Geräts steht zur Auswahl. Veraltete Versionen anzeigen : Zusätzlich stehen auch veraltete Versionen der Geräte zur Auswahl. Veraltet Versionen entstehen beispielsweise durch die Aktualisierung von Plug-Ins. : Veraltete Geräteversionen werden nicht angezeigt. Informationen zum Gerät Gerät auswählen Das in Objektdatei vorkompilierte Laufzeitmodul wird dem ausgewählten Gerät zugewiesen. " }, 
{ "title" : "Objekt: Gerät, und Generischer Geräteeditor ", 
"url" : "_cds_f_obj_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor ", 
"snippet" : "Gerät, Generischer Geräteeditor Symbol: Ein Geräteobjekt repräsentiert eine bestimmte Hardware; Beispiele: Steuerungsgerät, Feldbusknoten, Buskoppler, Antrieb, E\/A-Modul, Monitor. Durch die Anordnung der Geräteobjekte im Gerätebaum , also in der Ansicht Geräte in CODESYS ein, bilden Sie die Hardware...", 
"body" : "Gerät, Generischer Geräteeditor Symbol: Ein Geräteobjekt repräsentiert eine bestimmte Hardware; Beispiele: Steuerungsgerät, Feldbusknoten, Buskoppler, Antrieb, E\/A-Modul, Monitor. Durch die Anordnung der Geräteobjekte im Gerätebaum , also in der Ansicht Geräte in CODESYS ein, bilden Sie die Hardwarestruktur ab. In den Konfigurationseditoren der Geräteobjekte können Sie dann auch die E\/As der Geräte mit Projektvariablen verknüpfen. Fügen Sie ein Geräteobjekt mit Befehl Gerät anhängen oder Gerät einfügen in den Gerätebaum ein. CODESYS bietet jeweils die zur Einfügeposition im Baum passenden Geräte zur Auswahl an. Mit einem Doppelklick auf ein Geräteobjekt im Baum öffnen Sie den zugehörigen Geräteeditor . Dieser enthält generische und gerätespezifische Registerkarten zur Konfiguration des Geräts. " }, 
{ "title" : "Generischer Geräteeditor ", 
"url" : "_cds_edt_device_generic.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Generischer Geräteeditor ", 
"snippet" : "Der generische Geräteeditor enthält Registerkarten für die Konfiguration eines SPS-Geräts in CODESYS . Zusätzlich gibt es gerätespezifische Registerkarten, so dass sich der Konfigurationseditor je nach Gerät aus unterschiedlich vielen Dialogen zusammensetzt. Der Editor öffnet sich nach einem Doppelk...", 
"body" : "Der generische Geräteeditor enthält Registerkarten für die Konfiguration eines SPS-Geräts in CODESYS . Zusätzlich gibt es gerätespezifische Registerkarten, so dass sich der Konfigurationseditor je nach Gerät aus unterschiedlich vielen Dialogen zusammensetzt. Der Editor öffnet sich nach einem Doppelklick auf das Geräteobjekt im Gerätebaum (Ansicht Geräte ). In den CODESYS - Optionen in Kategorie Geräteeditor können Sie allgemeine Einstellungen für einen Geräteeditor vornehmen. Beispielsweise können Sie die Registerkarten des generischen Geräteeditors ein- und ausblenden. Ein Geräteeditor ist mit dem Namen des Geräts betitelt. Folgende Registerkarten des generischen Geräteeditors können enthalten sein: Kommunikation : Konfiguration der Verbindung zwischen dem Entwicklungssystem und einem programmierbaren Gerät (SPS). Nicht verfügbar bei reinen I\/O-Geräten Applikationen : Liste der Applikationen auf der Steuerung <Gerät> Parameter : Anzeige und Konfiguration der Geräteparameter Sichern und Wiederherstellen : Konfiguration des Sicherns und Wiederherstellens der applikationsspezifischen Dateien auf der SPS Synchronisierte Dateien : Liste der Dateien, die beim Applikationsdownload mit auf die SPS geladen werden Dateien : Konfiguration der Dateiübertragungen zwischen einem „Host“-Dateisystem und dem Gerät Log : Anzeige der SPS-Log-Datei SPS-Einstellungen : Konfiguration der Behandlung der E\/As: welche Applikation, Verhalten im Stop-Status, Aktualisierung, Buszyklus-Optionen, etc. SPS-Shell : Textbasierter Steuerungsmonitor zur Abfrage bestimmter Informationen aus der Steuerung <Gerät> E\/A-Abbild : Abbildung der Eingangs-, Ausgangs- und Speicheradressen des Steuerungsgeräts auf Variablen oder ganze Funktionsbausteine der Applikation <Gerät> IEC-Objekte : Liste von Objekten, die einen Zugriff aus der IEC-Applikation auf das Gerät ermöglichen Benutzer und Gruppen : Benutzerverwaltung bezüglich Zugriffe auf das Gerät zur Laufzeit Zugriffsrechte : Rechte für Zugriffe auf Objekte und Dateien auf dem Gerät Symbolrechte : Zugriffsrecht einzelner Benutzergruppen auf Symbole (Symbolgruppen) auf dem Gerät Task-Aufstellung : Übersicht aller Ein- und Ausgänge, welche Tasks zugeordnet sind - nützlich zur Fehlersuche Status : Gerätespezifische Status- und Diagnosemeldungen Information : Allgemeine Information zum Gerät (Name, Hersteller, Version etc.) " }, 
{ "title" : "Registerkarte: Kommunikation ", 
"url" : "_cds_edt_device_communication_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Kommunikation ", 
"snippet" : "In dieser Registerkarte des generischen Geräteeditors definieren Sie die Verbindung zwischen CODESYS und dem Gerät, auf dem Ihre Applikation(en) laufen soll(en). Dies beinhaltet auch Sicherheitseinstellungen wie verschlüsselte Kommunikation und Signierung. Wenn Sie die klassische Darstellungsform de...", 
"body" : "In dieser Registerkarte des generischen Geräteeditors definieren Sie die Verbindung zwischen CODESYS und dem Gerät, auf dem Ihre Applikation(en) laufen soll(en). Dies beinhaltet auch Sicherheitseinstellungen wie verschlüsselte Kommunikation und Signierung. Wenn Sie die klassische Darstellungsform des Dialogs bevorzugen, aktivieren Sie diese in den CODESYS - Optionen , Kategorie Geräteeditor . In den Auswahlfeldern wählen Sie ein Gateway und ein Zielgerät aus. Die Auswahlmöglichkeiten hängen von den Einträgen in den Dialogen Gateway verwalten und Bevorzugte Geräte verwalten ab; siehe Menü Gateway . Das Zielgerät können Sie auch direkt eingeben: Entweder über die IP-Adresse (Beispiel: „192.168.101.109“), die Geräteadresse (Beispiel: [056D] ), oder den Gerätenamen (Beispiel: MyDevice ). Nach erfolgter Eingabe sucht CODESYS das Gerät im Netzwerk des Gateways. Die Möglichkeit der Gerätesuche über den Gerätenamen setzt eindeutige Gerätenamen im Netzwerk voraus. Das Punktsymbol rechts unten am Gateway-Symbol gibt Auskunft zum Verbindungsstatus: Rot: CODESYS kann die Verbindung nicht herstellen. Grün: Die Verbindung ist hergestellt. Schwarz: Der Verbindungsstatus ist unklar. Manche Kommunikationsprotokolle ermöglichen kein regelmäßiges Prüfen des Gateways, so dass der Status gar nicht angezeigt werden kann. Durch Mausklick auf das Punktsymbol des Zielgeräts starten Sie eine Suche nach dem Gerät im Netzwerk. Dies funktioniert nur, wenn das Gateway nicht bereits eine Suche gestartet hat. Netzwerk durchsuchen Diese Schaltfläche öffnet den Dialog Gerät auswählen . Er enthält eine Liste aller konfigurierten Gateways mit den zugehörigen Geräten. Aus der Liste können Sie ein Zielgerät auswählen. Wenn der Name des ausgewählten Gerätes eindeutig ist, wird der Name in die Verbindungseinstellungen übernommen. Andernfalls wird die eindeutige Geräteadresse übernommen. Die angezeigten Parameter sind in der SysTarget-Komponente im Laufzeitsystem definiert und stellen im Wesentlichen das sogenannte Typenschild der Steuerung dar. Der Gerätename kann über den Befehl Gerät → Aktives Gerät umbenennen verändert werden. Option Nicht passende Geräte ausblenden, nach Geräte-ID filtern : : Die Anzeige wird auf Geräte beschränkt, die die gleiche Zielsystem-ID haben wie das aktuell im Projekt konfigurierte Gerät. : Alle im Netzwerk verfügbaren Geräte werden angezeigt. Ein Doppelklick auf den Eintrag eines Geräts, das eine andere Zielsystem-ID hat als das im Projekt konfigurierte Gerät, öffnet eine Dialogbox. Diese Dialogbox bietet Ihnen an, die Gerätebeschreibung des Geräts im Projekt auf die zum gewählten Gerät passende zu aktualisieren. Hinweis: Eine solche Aktualisierung ist nur mit Geräten möglich, die sich in der ID unterscheiden, nicht für solche, die sich nur in der Version unterscheiden. Die Aktualisierung setzt außerdem voraus, dass die Gerätebeschreibung bereits im Repository installiert ist. Gateway Dieses Menü enthält folgende Befehle: Neues Gateway hinzufügen : Öffnet den Dialog Gateway zum Definieren eines neuen Gateway-Kanals Gateways verwalten : Öffnet den Dialog Gateways verwalten mit einer Übersicht aller Gateways. Hier können Sie Einträge hinzufügen, löschen, bearbeiten oder ihre Reihenfolge verändern. Lokales Gateway konfigurieren : Öffnet den Dialog Gateway-Konfiguration . Hier können Sie die Blocktreiber-Konfiguration für das lokale Gateway vornehmen. Gerät Dieses Menü enthält folgende Befehle: Optionen: Aktuelles Gerät zu den Favoriten hinzufügen : Fügt das aktuell eingestellte Gerät der Liste der bevorzugten Geräte hinzu Bevorzugte Geräte verwalten : Öffnet den gleichnamigen Dialog mit einer Liste aller bevorzugten Geräte. In diesem Dialog können Sie Geräte hinzufügen, löschen oder ihre Reihenfolge verändern. Das an oberster Stelle stehende Gerät wird zum Standardgerät. Bestätigter Onlinebetrieb : : CODESYS fordert Sie aus Sicherheitsgründen beim Aufrufen der folgenden Onlinebefehle jeweils zu einer Bestätigung auf: Werte forcen , Werte schreiben , Mehrfaches Laden , F orceliste aufheben , Einzelzyklus , Start , Stop . Kommunikationseinstellungen im Projekt speichern : : CODESYS speichert die Kommunikationseinstellungen im Projekt zur Wiederverwendung auf dem selben Computer. Hinweis: Wenn Sie das Projekt auf einem anderen Computer verwenden, müssen Sie den aktiven Pfad neu setzen. : CODESYS speichert die Kommunikationseinstellungen in den Optionen der lokalen Installation zur Wiederverwendung auf demselben Computer. Hinweis: Bei Verwendung von CODESYS SVN sollte die Option deaktiviert sein, um ein Sperren des Geräteobjekts zu vermeiden. Aktives Gerät umbenennen : Öffnet einen Dialog zum Ändern des Gerätenamens Aktives Gerät anblinken : Wenn das Gerät diese Funktion unterstützt, reagiert es mit einem Blinksignal. Echodienst senden : CODESYS sendet fünf Echodienste zur Steuerung. Entsprechend der in der IT bekannten „Ping“-Funktion dienen sie dem Testen der Netzwerkverbindung. Die Dienste werden zunächst ohne, danach mit Nutzdaten gesendet. Der Nutzdatenumfang hängt vom Kommunikationspuffer der Steuerung ab. Ein Meldungsfenster erscheint mit den Informationen zur durchschnittlichen Laufzeit der Echodienste und dem gesendeten Nutzdatenumfang. Verschlüsselte Kommunikation : : Die Kommunikation zu dieser Steuerung wird verschlüsselt. Um sich auf diese Steuerung einzuloggen wird ein Zertifikat dieser Steuerung benötigt. Wenn das Zertifikat nicht zur Verfügung steht, erscheint eine Fehlermeldung mit der Abfrage, ob das Zertifikat angezeigt und installiert werden soll. Wenn in der Ansicht Security-Screen als Security-Level die Option Verschlüsselte Kommunikation erzwingen aktiviert ist, ist der Befehl Verschlüsselte Kommunikation an dieser Stelle deaktiviert. Laufzeitsystemsicherheitrichtlinie ändern Öffnet den Dialog Laufzeitsystemsicherheitsrichtlinie ändern zum Ändern der Geräteeinstellung für die Verschlüsselung der Kommunikation Laufzeitsystem-Passwortrichtlinie ändern Öffnet den Dialog Laufzeitsystem-Passwortrichtlinie ändern zum Ändern der Einstellungen für die Passwortrichtline und die Anmeldesperre. Sicherheitseinstellungen : Dieser Befehl ist nur verfügbar, wenn CODESYS Security Agent >= 1.3.0.0 installiert ist. Er öffnet den Dialog Gerätesicherheitseinstellungen . Die aktuellen Sicherheitseinstellungen auf dem verbundenen Gerät werden angezeigt. Sie können die Einstellungen in der Spalte Wert verändern und mit OK auf das Gerät schreiben. Beispielsweise finden Sie hier unter dem Knoten CmpUserMgr die Einstellungen zur Gerätebenutzerverwaltung und Passwortrichtlinie (siehe dazu auch weiter unten). Dialog Laufzeitsystem-Sicherheitsrichtlinie ändern Wenn Sie in diesem Dialog eine neue Kommunikationsrichtlinie auswählen, wird die Konfiguration im Laufzeitsystem geändert. Kommunikation Aktuelle Richtlinie Anzeige der aktuell ausgewählten Richtlinie zur Verschlüsselung der Kommunikation mit dem Gerät Neue Richtlinie Auswahlliste für die neue Richtlinie zur Verschlüsselung Keine Verschlüsselung : Das Gerät unterstützt keine verschlüsselte Kommunikation. Optionale Verschlüsselung : Das Gerät unterstützt verschlüsselte und unverschlüsselte Kommunikation. Erzwungene Verschlüsselung : Das Gerät unterstützt nur verschlüsselte Kommunikation. Codesignierung Aktuelle Richtlinie Anzeige der aktuell im Laufzeitsystem eingestellten Richtlinie zur Codesignierung Neue Richtlinie Alle : Alle Typen von Applikationscode werden akzeptiert. Erzwungenes Signieren : Nur signierter Applikationscode wird akzeptiert (Verhindern des Ladens einer Applikation aus nicht vertrauenswürdigen Quellen). Gerätebenutzerverwaltung Aktuelle Richtlinie Anzeige der aktuell ausgewählten Richtlinie zur Benutzerverwaltung Neue Richtlinie Optionale Benutzerverwaltung : Es liegt beim Benutzer, die Benutzerverwaltung auf dem Gerät zu aktivieren, oder das Gerät ungeschützt zu lassen. Erzwungene Benutzerverwaltung : Die Benutzerverwaltung auf dem Gerät ist aktiviert und kann vom Benutzer nicht deaktiviert werden. Zugehöriger Eintrag in den Sicherheitseinstellungen : CmpUserMgr UserMgmtEnforce . Anonymes Einloggen erlauben : Bestimmte registrierte Komponenten, beispielsweise OPC UA, können sich ohne die Eingabe von Anmeldeinformationen mit der Steuerung verbinden. Auch wenn der anonyme Zugang zu OPC UA erlaubt ist, bleibt die erstellte Gerätebenutzerverwaltung für die Steuerung aktiv. Zugehöriger Eintrag in den Sicherheitseinstellungen des Geräts: CmpUserMgr UserMgmt.AllowAnonymous . Dialog Laufzeitsystem-Passwortrichtlinie ändern Die hier konfigurierte Laufzeitsystem-Passwortrichtlinie wird im Programmiersystem vorab geprüft, während das Passwort für einen neuen Gerätebenutzer eingegeben oder das bestehende Passwort eines Gerätebenutzers geändert wird. Falls in der Passwortrichtlinie eine begrenzte Gültigkeitsdauer für ein Passwort konfiguriert ist, wird der Benutzer nach Ablauf dieser Zeit beim Einloggen aufgefordert, ein neues Passwort festzulegen. Hinweis: Für das Ändern seines Passworts vor Ablauf der Gültigkeit benötigt ein Benutzer aktuell noch das Leserecht für die Gerätebenutzerverwaltung. Passwortrichtlinie ist aktiv : Passwortrichtlinie ist aktiv : Die Richtlinie ist standardmäßig aktiviert. Die Passworteinstellungen können geändert werden und werden beim Erstellen eines Passworts für die Gerätebenutzerverwaltung angewendet. Die zugehörigen Einträge in den Sicherheitseinstellungen des Geräts sind unter dem Knoten CmpUserMgr ( UserMgmt.PasswordPoliciy.<..> ) zu finden. In der Konfigurationsdatei der CODESYS Control entspricht dies der Section CmpUserMgr . Beispiel: [CmpUserMgr]\nSECURITY.UserMgmt.PasswordPolicy=ENABLED Passworteinstellungen Minimale Länge Standardeinstellung: 8 Anzahl eindeutiger Zeichen Standardeinstellung: 4 Erfordert Kleinbuchstaben Standardeinstellung: aktiviert Erfordert Großbuchstaben Standardeinstellung: aktiviert Erfordert Ziffer Standardeinstellung: aktiviert Erfordert Sonderzeichen Standardeinstellung: aktiviert Darf nicht den Benutzernamen enthalten Standardeinstellung: aktiviert Folgende Regeln für das Passwort gelten immer, auch wenn die Regeln teilweise oder ganz deaktiviert sind: Passwort darf nicht leer sein Passwort darf nicht den Benutzernamen enthalten Passwortablauf ist aktiviert : Die Einstellungen Passwortablauf können bearbeitet werden und werden beim Anmelden angewendet. Zugehörige Einträge in den Sicherheitseinstellungen des Geräts: Unter Knoten CmpUserMgr ( Password.Expiration.<...> ). Einstellungen Passwortablauf : Geltungsbereich : ADMINS : Die Einstellungen gelten für Benutzer mit Administratorrechten. NONADMINS : Die Einstellungen gelten für alle Benutzer, die keine Administratorrechte haben. ALL : Die Einstellungen gelten für alle Benutzer. Geltungsbereich [Tage] : Gültigkeitsdauer des Passworts in Tagen. Wenn diese Zeit überschritten ist, ist mit dem bisherigen Passwort kein Einloggen mehr möglich. Sie erhalten in diesem Fall unmittelbar die Aufforderung, ein neues Passwort festzulegen. Login-Sperre ist aktiv : Die Einstellungen Login-Sperre werden beim Anmelden angewendet. Zugehörige Einträge in den Sicherheitseinstellungen des Geräts: Unter Knoten CmpUserMgr ( UserLogin.<...> ). Einstellungen Login-Sperre Geltungsbereich ADMINS : Die Einstellungen gelten für Benutzer mit Administratorrechten. NONADMINS : Die Einstellungen gelten für alle Benutzer, die keine Administratorrechte haben. ALL : Die Einstellungen gelten für alle Benutzer. Maximal erneute Versuche : Wenn die hier angegebene Anzahl der Einlog-Versuche überschritten wird, wird der Benutzer für die im Feld Dauer der Sperre angezeigte Zeitdauer gesperrt. Der Benutzer kann sich erst wieder einloggen, wenn die Sperre durch einen Administrator aufgehoben wird oder die Sperrzeit abgelaufen ist. Dauer der Sperre [s] : Sperrzeit in Sekunden Für Informationen zum Freischalten eines gesperrten Benutzers siehe: Gerätebenutzerverwaltung handhaben" }, 
{ "title" : "Kommunikationseinstellungen - klassische Ansicht ", 
"url" : "_cds_edt_device_communication_settings.html#UUID-4f041ba7-d0d4-e8fe-3708-a0ef62d6108b_id_a8ca3cbc369b81dc0a8640e012568ee_id_5427e3926f2911e49f48f439849fe1dc", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Kommunikation \/ Kommunikationseinstellungen - klassische Ansicht ", 
"snippet" : "Die klassische Ansicht des Dialogs können Sie in den CODESYS -Optionen aktivieren: Tools → Optionen , Kategorie Geräteeditor. Den Netzwerkpfad zur Steuerung auswählen Gateway-Kanal, über den die Verbindung erfolgen soll Wählen Sie den Kanal aus dem Fenster unten aus. Fenster mit Anzeige der konfigur...", 
"body" : "Die klassische Ansicht des Dialogs können Sie in den CODESYS -Optionen aktivieren: Tools → Optionen , Kategorie Geräteeditor. Den Netzwerkpfad zur Steuerung auswählen Gateway-Kanal, über den die Verbindung erfolgen soll Wählen Sie den Kanal aus dem Fenster unten aus. Fenster mit Anzeige der konfigurierten Gateway-Kanäle und der Geräte im Netzwerk Linkes Teilfenster Baumstruktur der konfigurierten Gateway-Kanäle mit den erreichbaren Geräten im lokalen Netzwerk: Hinweis: CODESYS speichert diese Einträge lokal auf dem System und nicht im Projekt. Den Geräteeinträgen ist ein Symbol vorangestellt. Einträge mit einer Zielsystem-ID, die sich von der gerade im Projekt konfigurierten unterscheidet, sind in grauer Schrift dargestellt. Eine Aktualisierung der Liste erhalten Sie nach Ausführen von Befehl Netzwerk durchsuchen . Hinweis: Wenn Sie das erste Projekt auf dem lokalen System erstellt haben, liegt standardmäßig bereits das lokale Gateway als Eintrag im Baum vor. CODESYS startet dieses Gateway beim Systemstart automatisch. Das Punktsymbol rechts unten am Gateway-Symbol gibt Auskunft zum Verbindungsstatus: Rot: CODESYS Development System kann die Verbindung nicht herstellen. Grün: Die Verbindung ist hergestellt: . Schwarz: Der Verbindungsstatus ist unklar. Hinweis: Manche Kommunikationsprotokolle ermöglichen kein regelmäßiges Prüfen des Gateways, so dass der Status gar nicht angezeigt werden kann. Die Geräteeinträge im Baum bestehen jeweils aus einem Symbol gefolgt von Gerätename > [ Geräteadresse ]. Im rechten Fensterteil sehen Sie zusätzlich Zielsystem-ID , Zielsystemname , Zielsystemtyp, Zielsystemhersteller und Zielsystemversion . Rechtes Teilfenster Informationen zum gerade im linken Fenster selektierten Gateway-Kanal oder Gerät Wenn im linken Fenster ein Gateway-Kanal selektiert ist, werden folgende Informationen angezeigt: Gerätename , IP-Adresse , Port , Treiber Wenn im linken Fenster ein Gerät selektiert ist, werden abhängig vom Gerät folgende Informationen angezeigt: Gerätename , Geräteadresse , Anzahl Kanäle , Blocktreiber , Seriennummer , Verschlüsselte Kommunikation , Zielsystemhersteller , Zielsystem-ID , Zielsystemname , Zielsystemtyp , Zielsystemversion Filter- und Sortierfunktionen im rechten Teil des Dialogs Filter Hier können Sie die Liste auf die Anzeige solcher Geräte reduzieren, die die gleiche Zielsystem-ID haben wie das aktuell im Projekt konfigurierte Gerät. Sortierreihenfolge Hier können Sie die Liste nach Name bzw. Geräteadresse in alphabetischer bzw. aufsteigender Reihenfolge sortieren. Befehlsschaltflächen im rechten Teil des Dialogs Aktiven Pfad setzen Der Befehl setzt den gerade selektierten Kommunikationskanal als den aktiven. Ein Doppelklick auf den Eintrag im Kanalbaum bewirkt dasselbe. Gateway hinzufügen Der Befehl öffnet den Dialog Gateway : In diesem können Sie ein Gateway definieren, den CODESYS zur aktuellen Konfiguration hinzufügen soll. Gerät hinzufügen Der Befehl öffnet den Dialog Gerät hinzufügen . Hier können Sie manuell ein Gerät definieren, das unter dem gerade selektierten Gateway-Eintrag im Baum eingefügt werden soll. Beachten Sie dazu auch die Funktionalität Netzwerk durchsuchen . Netzwerk durchsuchen Der Befehl startet eine Suche nach verfügbaren Geräten im lokalen Netzwerk. Der Konfigurationsbaum des Gateways wird entsprechend aktualisiert. Befehle im Kontextmenü des Gateway- und Gerätebaums im Dialog Suche nach Gerät über Adresse Der Befehl durchsucht das Netzwerk nach Geräten mit einer eindeutigen Geräteadresse wie hier im Konfigurationsbaum. CODESYS stellt die gefundenen Geräte daraufhin unterhalb des Gateways mit der angegebenen Geräteadresse dar. Die Suche bezieht sich immer auf die Geräte unterhalb des Gateways, das gerade selektiert ist oder unterhalb dem gerade ein Eintrag selektiert ist. Suche nach Gerät über Name Der Befehl durchsucht das Netzwerk nach Geräten mit gleichen Namen wie hier im Konfigurationsbaum. Groß-\/Kleinschreibung wird dabei ignoriert. CODESYS stellt die gefundenen Geräte daraufhin unterhalb des Gateways mit dem angegebenen Namen dargestellt, ergänzt mit ihrer eindeutigen Geräteadresse. Die Suche bezieht sich immer auf die Geräte unterhalb des Gateways, das gerade selektiert ist oder unterhalb dessen gerade ein Eintrag selektiert ist. Suche nach Gerät über IP-Adresse Der Befehl durchsucht das Netzwerk nach Geräten mit einer eindeutigen IP-Adresse wie hier im Konfigurationsbaum. CODESYS stellt die gefundenen Geräte daraufhin unterhalb des Gateways mit der angegebenen Geräteadresse dar, ergänzt um ihren Namen. Die Suche bezieht sich immer auf die Geräte unterhalb des Gateways, das gerade selektiert ist oder unterhalb dem gerade ein Eintrag selektiert ist. Echodienst senden CODESYS sendet fünf Echodienste zur Steuerung. Entsprechend der in der IT bekannten „Ping“-Funktion dienen Sie dem Testen der Netzwerkverbindung. Die Dienste werden zunächst ohne, danach mit Nutzdaten gesendet. Der Nutzdatenumfang hängt vom Kommunikationspuffer der Steuerung ab. Ein Meldungsfenster erscheint, mit den Informationen zur durchschnittlichen Laufzeit der Echodienste und dem gesendeten Nutzdatenumfang. Ausgewähltes Gerät löschen Der Befehl löscht das selektierte Gerät im Kanalbaum. Gateway bearbeiten Der Befehl öffnet den Dialog Gateway zum Bearbeiten der Einstellungen für das gerade selektierte Gateway. Lokales Gateway konfigurieren Der Befehl öffnet einen Dialog zur Konfiguration eines lokalen Gateways und bietet daher eine Alternative zur manuellen Bearbeitung der Datei Gateway.cfg . Optionen im unteren Teil des Dialogs Verbindungseinstellungen nicht im Projekt speichern : CODESYS speichert die Kommunikationseinstellungen in den Optionen der lokalen Installation zur Wiederverwendung auf dem selben Computer. Hinweis: Bei Verwendung von CODESYS SVN sollte die Option aktiviert sein, um ein Sperren des Geräteobjekts zu vermeiden. : CODESYS speichert die Kommunikationseinstellungen im Projekt zur Wiederverwendung auf dem selben Computer. Hinweis: Wenn Sie das Projekt auf einem anderen Computer verwenden, müssen Sie den aktiven Pfad neu setzen. Bestätigter Onlinebetrieb : CODESYS fordert Sie aus Sicherheitsgründen beim Aufrufen der folgenden Onlinebefehle jeweils zu einer Bestätigung auf: Werte forcen , Werte schreiben , Mehrfaches Laden , Forceliste aufheben , Einzelzyklus , Start , Stop . " }, 
{ "title" : "Registerkarte: Parameter ", 
"url" : "_cds_edt_device_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Parameter ", 
"snippet" : "Dieser Dialog ist für Testzwecke bestimmt. Werte sollten darin nur von Experten geändert werden. In dieser Registerkarte des generischen Geräteeditors werden die gerätespezifischen Parameter in einer Tabelle angezeigt. Die Gerätebeschreibung legt fest, welche Parameter Sie in diesem Dialog bearbeite...", 
"body" : "Dieser Dialog ist für Testzwecke bestimmt. Werte sollten darin nur von Experten geändert werden. In dieser Registerkarte des generischen Geräteeditors werden die gerätespezifischen Parameter in einer Tabelle angezeigt. Die Gerätebeschreibung legt fest, welche Parameter Sie in diesem Dialog bearbeiten können. Durch einen Mausklick auf die Spaltenüberschrift können Sie die Einträge alphabetisch aufsteigend, absteigend oder in der Standardreihenfolge sortieren. Parameter Parametername, nicht editierbar Typ Datentyp des Parameters, nicht editierbar Wert Zeigt zunächst den Standardwert des Parameters, direkt oder den entsprechenden Symbolnamen. Nicht editierbare Parameter sind hellgrau dargestellt. Wenn der Parameter editierbar ist, können Sie mit einem Doppelklick auf das Tabellenfeld ein Eingabefeld, eine Auswahlliste oder einen Dateiauswahl-Dialog öffnen und darüber den Wert ändern. Standardwert Von der Gerätebeschreibung definierter Standardwert des Parameters, nicht editierbar Einheit Maßeinheit für den Wert; Beispiel: „ms“ für Millisekunden; nicht editierbar Beschreibung Von der Gerätebeschreibung vorgegebene Kurzbeschreibung zum Parameter, nicht editierbar " }, 
{ "title" : "Registerkarte: Applikationen ", 
"url" : "_cds_edt_device_applications.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Applikationen ", 
"snippet" : "In dieser Registerkarte des generischen Geräteeditors sehen Sie, welche Applikationen auf dem Gerät vorhanden sind. Je nach System können Sie die Applikationen auf dem Gerät löschen, oder Detailinformationen zur Applikation abrufen. Applikationen auf der Steuerung Liste der Applikationen, die beim l...", 
"body" : "In dieser Registerkarte des generischen Geräteeditors sehen Sie, welche Applikationen auf dem Gerät vorhanden sind. Je nach System können Sie die Applikationen auf dem Gerät löschen, oder Detailinformationen zur Applikation abrufen. Applikationen auf der Steuerung Liste der Applikationen, die beim letzten Durchsuchen des Steuerungsgeräts über Liste aktualisieren gefunden wurden Löschen Alle löschen Weitere Informationen finden Sie im Kapitel „Untergeordnete Sicherheitssteuerung“. Hinweis: Wenn unter einer Steuerung eine Sicherheitssteuerung eingehängt ist, kann dieser Befehl die Kommunikationsverbindungen der Sicherheitssteuerung zu anderen Sicherheitssteuerungen (über Safety Netzwerkvariablen), zu Feldgeräten und zum Entwicklungssystem dauerhaft unterbrechen! Die sicheren Feldgeräte und die andere Sicherheitssteuerung können als Reaktion in den sicheren Zustand gehen. Die Verbindung zum Entwicklungssystem ist nur betroffen im Fall einer Sicherheitssteuerung, die über den Feldbus an die Hauptsteuerung angeschlossen ist. Löscht die in der Liste selektierte Applikation beziehungsweise alle aufgelisteten Applikationen auf der Steuerung Details Öffnet den Dialog Details . Er zeigt Informationen, die im Registerblatt Informationen des Dialogs Eigenschaften für die Applikation definiert wurden Inhalt Voraussetzung: In den Eigenschaften des Applikationsobjekts, in der Registerkarte Optionen Applikationserzeugung ist die Option Download der Applikationsinfo aktiviert. Das bewirkt, dass zusätzlich Information über den Inhalt der Applikation auf die SPS geladen wird. Die Schaltfläche Inhalt öffnet einen Dialog mit zusätzlichen Informationen über die Unterschiede zwischen dem zuletzt erzeugten Code und dem bereits auf der Steuerung liegenden Code der Applikation. Die unterschiedlichen Bausteine sind in einer Vergleichsansicht dargestellt. Liste aktualisieren Die Steuerung wird nach Applikationen durchsucht, die Liste wird entsprechend aktualisiert. Sie können die Befehle Applikation vom Gerät entfernen oder Applikationen vom Gerät entfernen mit Hilfe des Dialogs Tools → Anpassen als Menübefehle konfigurieren. Diese Befehle entsprechen den Schaltflächen Löschen oder Alle löschen . " }, 
{ "title" : "Registerkarte: Sichern und Wiederherstellen ", 
"url" : "_cds_edt_device_backup_and_restore.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Sichern und Wiederherstellen ", 
"snippet" : "In dieser Registerkarte des generischen Geräteeditors veranlassen Sie das Sichern und Wiederherstellen der applikationsspezifischen Dateien auf der SPS. Dazu legen Sie eine gepackte Sicherungsdatei ab beziehungsweise lesen eine solche wieder ein. Für weitere Informationen siehe: Sichern und Wiederhe...", 
"body" : "In dieser Registerkarte des generischen Geräteeditors veranlassen Sie das Sichern und Wiederherstellen der applikationsspezifischen Dateien auf der SPS. Dazu legen Sie eine gepackte Sicherungsdatei ab beziehungsweise lesen eine solche wieder ein. Für weitere Informationen siehe: Sichern und WiederherstellenVoraussetzung: Die Kommunikationseinstellungen für die Verbindung zum Gerät sind korrekt. Die Applikation, für die Sie eine Sicherung durchführen möchten, ist auf der Steuerung verfügbar. Menüleiste Sicherung Die Schaltfläche öffnet ein Menü mit folgenden Befehlen: Sicherungsinformation vom Gerät lesen : Der Befehl sucht nach applikationsspezifischen Dateien vom $PlcLogic$ -Verzeichnis der SPS und zeigt sie im unteren Teil der Registerkarte als Tabelle an. Sicherungsdatei erzeugen und auf Platte speichern : Voraussetzung: Mit Befehl Sicherungsinformation vom Gerät lesen wurden die sicherungsrelevanten Dateien ermittelt. Sie stehen jetzt in der Tabelle im unteren Teil der Registerkarte. Der Befehl packt die in der Tabelle als Aktiv gesetzten Dateien zusammen mit der Informationsdatei meta.info in eine Sicherungsdatei im ZIP-Format. Die Dateiendung ist tbf (=“Target Backup File“). Sicherungsdatei auf Gerät speichern : Voraussetzung: Die Sicherungsdatei wurde zuvor auf Platte gespeichert. Der Befehl speichert die Sicherungsdatei nun außerdem auf der SPS im Verzeichnis TBF . Wiederherstellen Die Schaltfläche öffnet ein Menü mit folgenden Befehlen: Sicherungsdatei von der Platte laden : Der Befehl öffnet den Dialog Datei öffnen zum Durchsuchen des Dateisystems nach einer gespeicherten Sicherungsdatei. Die enthaltenen Dateien werden dann in der Tabelle im unteren Teil der Registerkarte dargestellt. Sicherungsdatei vom Gerät laden : Der Befehl erzeugt eine Liste aller auf der Steuerung gefundenen Sicherungsdateien. Sie wählen eine der Dateien und erhalten dann deren Inhalt auf der Registerkarte in Tabellenform. Darin können Sie für die bevorstehende Wiederherstellen-Operation noch optionale Komponenten deaktivieren und den Kommentar bearbeiten. Wiederherstellen auf Gerät : Der Befehl ist verfügbar, wenn mindestens eine Komponente der gerade in der Registerkarte geladenen Sicherungsdatei aktiv gesetzt ist. Er veranlaßt ein entsprechendes Wiederherstellen des Applikationsstandes auf dem Gerät. Die Benutzeroberfläche ist während des Wiederherstellens gesperrt. Sie können den Vorgang abbrechen. Zielsysteminformation ID ID der SPS, Beispiel: 0000 0001 Typ Gerättyp, Beispiel: 4096 Version Geräteversion, Beispiel: 3.5.8.0 Sicherungsinformation Dateiname Speicherpfad der Sicherungsdatei. Über Schaltfläche gelangen Sie zum Dateisystem-Browser. Beispiel: PlcLogic$\/Application\/Application.crc Größe der aktiven Dateien Angabe in Kilobytes: Gesamtumfang der unten in der Tabelle als aktiv gesetzten Dateien, Beispiel: 206 KB (210965 bytes) Modus Definiert den Umfang der Sicherung: Applikation .Die applikationsrelevanten Dateien werden gepackt. Kommentar Optionale Eingabe eines Kommentars, der in der Datei meta.info der Sicherung gespeichert wird und beim Wiederherstellen wieder gelesen werden kann. Tabelle der Dateien für die Sicherung Aktiv : Optionale Dateien können Sie hier deaktivieren, damit sie nicht in die Sicherungsdatei aufgenommen werden. Bei zwingend erforderlichen Komponenten erscheint hier nur ein grünes Häkchen ohne Checkbox. Komponente Betroffene Komponente, Beispiel: Dateisystem Datei Name der zu sichernden Datei der Komponente, Beispiel: $PlcLogic$\/Application\/Application.app Größe Größe der Datei in Bytes, Beispiel: 43280 Erfordert STOP : Für die Komponente sollte die Applikation vor dem Sichern oder Wiederherstellen unbedingt gestoppt werden. Sie erhalten in dem Fall beim Anstoßen des Sicherns oder Wiederherstellens eine entsprechende Warnung. " }, 
{ "title" : "Registerkarte: Synchronisierte Dateien ", 
"url" : "_cds_edt_device_synchronized_files.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Synchronisierte Dateien ", 
"snippet" : "Die Registerkarte des generischen Geräteeditors zeigt eine Liste der Dateien, die beim Applikationsdownload mit auf die SPS geladen werden. Beispielsweise sind dies externe Dateien , die einer Applikation hinzugefügt wurden. Implizite Dateien, wie beispielsweise die Quellcode-Archivdatei erscheinen ...", 
"body" : "Die Registerkarte des generischen Geräteeditors zeigt eine Liste der Dateien, die beim Applikationsdownload mit auf die SPS geladen werden. Beispielsweise sind dies externe Dateien , die einer Applikation hinzugefügt wurden. Implizite Dateien, wie beispielsweise die Quellcode-Archivdatei erscheinen hier nur, wenn Ihr Download-Zeitpunkt entsprechend konfiguriert ist und in den CODESYS -Optionen in Kategorie Geräteeditor die Option Implizite Dateien für den Applikationsdownload im Editor einer SPS anzeigen aktiviert ist. Aktualisieren Aktualisierung der Ansicht Datei-Download ‚auf Anforderung‘ Nur für interne Verwendung Dateiname Name der Datei unterhalb der Applikation, oder direkt Name der implizit transferierten Datei, Beispiel: archive.prj (Archive.prj) . Bei Doppelklick auf den Dateinamen wird die Datei geöffnet. Host-Pfad Speicherort beziehungsweise Herkunftsort der Datei, Beispiel: D:\\Proj1\\Files . Bei Doppelklick auf den Pfad wird das Verzeichnis im Datei-Explorer geöffnet. Zeitintervall Zeitintervall der Aktualisierung der Datei auf der SPS, Beispiel: Nach Download\/Online-Change der Applikation Information Objektabhängige Zusatzinformation, Beispiel: Objekt: Externe Datei Herkunft Genereller Herkunftstyp der Datei, Beispiele: Externe Dateiobjekte , Quellcode-Download Provider " }, 
{ "title" : "Registerkarte: Dateien ", 
"url" : "_cds_edt_device_files.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Dateien ", 
"snippet" : "In dieser Registerkarte des g enerischen Geräteeditors können Sie einen Dateitransfer zwischen CODESYS (Host) und dem Steuerungsgerät durchführen. CODESYS stellt die Verbindung zur Steuerung automatisch für die Zeit des Dateitransfers her, wenn die Kommunikationseinstellungen korrekt sind und die St...", 
"body" : "In dieser Registerkarte des g enerischen Geräteeditors können Sie einen Dateitransfer zwischen CODESYS (Host) und dem Steuerungsgerät durchführen. CODESYS stellt die Verbindung zur Steuerung automatisch für die Zeit des Dateitransfers her, wenn die Kommunikationseinstellungen korrekt sind und die Steuerung läuft. " }, 
{ "title" : "", 
"url" : "_cds_edt_device_files.html#UUID-e9ed7dc5-188b-7cea-31fd-715ea645231c_UUID-aa1b8515-35d0-1cd1-0849-d17b1439fc52", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Dateien \/ ", 
"snippet" : "Host \/ Laufzeitsystem Zugang zum Dateisystem des Hosts mit den Funktionalitäten eines standardmäßigen Dateimanagers Speicherort Aktuelles Verzeichnis für den Dateitransfer auf der Hostseite Öffnet einen Dialog zum Anlegen eines neuen Verzeichnisses im eingestellten Pfad Löscht die ausgewählten Datei...", 
"body" : "Host \/ Laufzeitsystem Zugang zum Dateisystem des Hosts mit den Funktionalitäten eines standardmäßigen Dateimanagers Speicherort Aktuelles Verzeichnis für den Dateitransfer auf der Hostseite Öffnet einen Dialog zum Anlegen eines neuen Verzeichnisses im eingestellten Pfad Löscht die ausgewählten Dateien oder Verzeichnisse Aktualisiert für den eingestellten Speicherort die Liste der Dateien und Verzeichnisse dort Kopiert die ausgewählten Dateien und Verzeichnisse ins jeweilige andere Dateisystem von Host und Laufzeitsystem Wenn eine Datei im Zielverzeichnis noch nicht vorhanden ist, wird sie dort neu angelegt. Wenn sie bereits vorliegt, wird sie überschrieben, außer sie ist schreibgeschützt. Dann wird eine entsprechende Meldung ausgegeben. : Entspricht dem Befehl Datei auf Steuerung schreiben : Entspricht dem Befehl Datei von Steuerung laden Doppelklick auf eine Datei Öffnet die selektierte Datei mit ihrem Windows-Standardprogramm Alternativ: Datei selektieren + Taste Eingabe Beispiel: TXT-Datei öffnet im Windows-Editor Hinweis: Öffnen mit Windows-Standardprogrammen ist nur auf der Hostseite möglich. Die Befehle Datei auf Steuerung schreiben und Datei von Steuerung laden sind standardmäßig in keinem Menü enthalten. Sie können sie mit Hilfe des Dialogs Tools → Anpassen aus der Befehlskategorie Online in ein Menü einfügen. " }, 
{ "title" : "Registerkarte: Log ", 
"url" : "_cds_edt_device_log.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Log ", 
"snippet" : "In dieser Registerkarte des generischen Geräteeditors können Sie das „Logbuch“ der SPS einsehen . Es listet die Ereignisse, die auf dem Zielsystem aufgezeichnet wurden. Dies betrifft: Ereignisse beim Systemstart und -beenden (geladene Komponenten mit Version) Applikationsdownload und Laden der Boota...", 
"body" : "In dieser Registerkarte des generischen Geräteeditors können Sie das „Logbuch“ der SPS einsehen . Es listet die Ereignisse, die auf dem Zielsystem aufgezeichnet wurden. Dies betrifft: Ereignisse beim Systemstart und -beenden (geladene Komponenten mit Version) Applikationsdownload und Laden der Bootapplikation Kundenspezifische Einträge Log-Einträge von E\/A-Treibern Log-Einträge von den Datenquellen Die Registerkarte Log öffnet sich auch, wenn Sie den Befehl Log-Seite öffnen auswählen. Den Befehl können Sie über den Dialog Anpassen als Menübefehl konfigurieren. " }, 
{ "title" : "", 
"url" : "_cds_edt_device_log.html#UUID-07798ea7-5bf9-767c-956e-9d523915b989_UUID-f8e0ab33-5cb2-7220-fd3c-9c0abaec2c6a", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Log \/ ", 
"snippet" : "Menüleiste Aktualisiert die Liste der Logereignisse für alle Laufzeitsystemkomponenten Komponenten Filtert die Anzeige der Logereignisse nach den in der Auswahlliste aktivierten Laufzeitsystemkomponenten Beispiel: CmpApp zeigt alle in dieser Komponente aufgetretenen Ereignisse wie beispielsweise „ A...", 
"body" : "Menüleiste Aktualisiert die Liste der Logereignisse für alle Laufzeitsystemkomponenten Komponenten Filtert die Anzeige der Logereignisse nach den in der Auswahlliste aktivierten Laufzeitsystemkomponenten Beispiel: CmpApp zeigt alle in dieser Komponente aufgetretenen Ereignisse wie beispielsweise „ Application [ <name> ] loaded via [OnlineChange] “ an. <Alle Komponenten> : Zeigt die gemeldeten Ereignisse aller Komponenten an Lädt die nächste Seite mit neueren Logmeldungen Lädt die vorherige Seite mit älteren Logmeldungen Lädt die Seite mit den neuesten Logeinträgen und aktiviert das automatische Scrollen : Zeigt an, dass es neue Logmeldungen gibt, die noch nicht angezeigt werden Dies wird auch in der Statusleiste mit Auto-Scroll: ON angezeigt. Lädt die Seite mit den ältesten Logmeldungen Filtert Ereignisse mit der Gewichtung Warnung und informiert über deren Anzahl Blau umrahmte Schaltfläche: Warnungen werden angezeigt Filtert Ereignisse mit der Gewichtung Fehler und informiert über deren Anzahl Blau umrahmte Schaltfläche: Fehler werden angezeigt. Filtert Ereignisse mit der Gewichtung Ausnahme und informiert über deren Anzahl Blau umrahmte Schaltfläche: Ausnahmen (Exceptions) werden angezeigt. Filtert Ereignisse mit der Gewichtung Information und informiert über deren Anzahl Blau umrahmte Schaltfläche: Informationen werden angezeigt. Filtert Ereignisse mit der Gewichtung Debug und informiert über deren Anzahl Blau umrahmte Schaltfläche: Debug-Meldungen werden angezeigt. Suche in Meldungen Eingabefeld für Suchtext Wenn Sie ein oder mehrere Zeichen in das Suchfeld eingeben, werden in den Loggermeldungen die Treffer gelb markiert. Springt zum nächsten Treffer Springt zum vorherigen Treffer Logger Aktiviert einen Logger für die Anzeige seiner aufgezeichneten Ereignisse Standardmäßig ist der vom Zielsystem vorgegebene <default logger> eingestellt. Das ist beispielsweise für ein CODESYS Control Win -Laufzeitsystem der Logger PlcLog . .Audit.log : Dieser Logger zeigt alle Benutzer-Interaktionen mit der Steuerung. Dabei wird der Benutzername mitprotokolliert. Dies sind beispielsweise Aktionen wie Download, Start, Stop oder Haltepunkte setzen. Es werden auch Fehlversuche geloggt, wenn ein Anwender bestimmte Aktionen nicht ausführen darf. UTC-Zeit : Rechnet die unter Zeitstempel angezeigten Zeiten auf die lokale Zeit des Entwicklungssystems um Die Umrechnung basiert auf der Zeitzone des Betriebssystems, auf dem CODESYS läuft. (Standardeinstellung) : Zeigt den ursprünglichen Zeitstempel des Laufzeitsystems an Wenn Sie die Option ändern, wird automatisch der angezeigte Zeitstempel umgerechnet. Exportiert den Listeninhalts in eine XML-Datei Sie können Dateinamen und Speicherort wählen. Importiert eine im Dateisystem abgelegte XML-Datei mit Logmeldungen Für die Anzeige der Logmeldungen öffnet sich ein separates Fenster. Anzeigefenster mit Logdatei Tabellarische Anzeige der Logmeldungen Pro Seite werden 10 000 Logmeldungen angezeigt. Gewichtung : Warnung : Fehler : Ausnahme : Information : Debug-Meldung Zeitstempel Datum und Uhrzeit (des Entwicklungssystems oder des Laufzeitsystems) Beispiel: 12.01.2007 09:48 Beschreibung Beschreibung des Ereignisses Beispiel: PLC started Komponente Laufzeitsystemkomponente, in der das gemeldete Ereignis eintrat Statusleiste Auto-Scroll Zeigt an, ob das automatische Scrollen aktiviert ( ON ) oder deaktiviert ( OFF ) ist ON : Die Logliste wird bei Änderungen automatisch aktualisiert. OFF : Wenn en neues Logereignis eintritt, wird dieses neben dem Off angezeigt. Außerdem wird in der Menüleiste die Schaltfläche dekoriert: . Wenn Sie auf die Schaltfläche klicken, wird Auto-Scroll aktiviert. Fehlersuche Bei Exceptions mit der Beschreibung *SOURCEPOSITION* öffnet mit einem Doppelklick oder mit dem Kontextbefehl Source-Code im Editor anzeigen die betroffene Funktion im Editor. Der Cursor springt an die fehlerverursachende Zeile. Diese Diagnose können Sie auch vornehmen, wenn Ihnen das CODESYS -Projektarchiv inklusive der „Download-Informationsdateien“ und der exportierten Log-Datei vorliegt. Wenn die betroffene Funktion geschützt ist, erscheint die Meldung Der Quellcode ist nicht verfügbar für <Funktionsname>. Wenn eine VendorException gemeldet wird, ist ein herstellerspezifischer Ausnahmefehler im CODESYS -Laufzeitsystem aufgetreten. Für weitere Informationen wenden Sie sich bitte an den Steuerungshersteller. " }, 
{ "title" : "Registerkarte: SPS-Einstellungen ", 
"url" : "_cds_edt_device_plc_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: SPS-Einstellungen ", 
"snippet" : "In dieser Registerkarte des generischen Geräteeditors setzen Sie Grundeinstellungen für die Konfiguration der SPS wie beispielsweise die Behandlung der Ein- und Ausgänge und die Buszyklustask. Applikation für E\/A-Behandlung Applikation, die für die E\/A-Behandlung zuständig ist SPS-Einstellungen E\/As...", 
"body" : "In dieser Registerkarte des generischen Geräteeditors setzen Sie Grundeinstellungen für die Konfiguration der SPS wie beispielsweise die Behandlung der Ein- und Ausgänge und die Buszyklustask. Applikation für E\/A-Behandlung Applikation, die für die E\/A-Behandlung zuständig ist SPS-Einstellungen E\/As aktualisieren im Stop : Die Werte der Ein- und Ausgangskanäle werdenauch dann aktualisiert, wenn die SPS im Betriebsmodus STOP ist. Wenn der Watchdog eine Fehlfunktion feststellt, werden die Ausgänge auf die vordefinierten Standardwerte gesetzt. : Die Werte der Ein- und Ausgangskanäle im Betriebsmodus STOP der SPS werden nicht aktualisiert. Verhalten der Ausgänge bei Stop Behandlung der Ausgangskanäle, wenn die Steuerung in den Betriebsmodus STOP geht: Werte beibehalten : Die aktuellen Werte werden beibehalten. Alle Ausgänge auf Standardwert : Die Standardwerte, die aus dem E\/A-Abbild resultieren, werden zugewiesen. Programm ausführen : Die Behandlung der Ausgangswerte wird über ein im Projekt enthaltenes Programm gesteuert, das im Betriebsmodus STOP ausgeführt wird. Geben Sie den Namen des Programms im Feld rechts an. Variablen immer aktualisieren Legt global fest, ob die E\/A-Variablen in der Buszyklustask aktualisiert werden Diese Einstellung ist für die E\/A-Variablen der Slaves und Module nur wirksam, wenn in deren Aktualisierungseinstellungen \"Deaktiviert\" festgelegt ist. Deaktiviert (Aktualisierung, nur wenn in einer Task verwendet) : Die E\/A-Variablen werden nur dann aktualisiert, wenn sie in einer Task verwendet werden. Aktiviert 1 (Buszyklustask verwenden, wenn in keiner Task verwendet) : Die E\/A-Variablen in der Buszyklustask werden aktualisiert, wenn sie in keiner anderen Task verwendet werden. Aktiviert 2 (immer im Buszyklustask) : Alle Variablen in jedem Zyklus der Buszyklustask werden aktualisiert, unabhängig davon, ob sie verwendet werden und ob sie auf einen Ein- oder Ausgangskanal abgebildet sind. Die Verfügbarkeit dieser Option hängt von der Gerätebeschreibung ab. Buszyklus-Optionen Buszyklustask Task, die den Buszyklus steuert. Standardmäßig ist die von der Gerätebeschreibung definierte Task eingetragen. Standardmäßig gilt die Buszyklus-Einstellung des übergeordneten Busgeräts (Zykluseinstellungen des übergeordneten Busses verwenden). Das heißt, dass der Gerätebaum nach oben hin auf die nächste gültige Definition der Buszyklustask durchsucht wird. Bevor Sie für die Buszyklustask die Einstellung \" <unspezifiziert> \" wählen, sollten Sie sich über Folgendes klar sein: \" <unspezifiziert> \" bedeutet, dass die in der Gerätebeschreibung vorgegebene Standardeinstellung wirksam wird. Prüfen Sie deshalb diese Beschreibung. Als Standard kann dort das Verwenden der Task mit der kürzesten Zykluszeit definiert sein, genauso gut aber auch das Verwenden der Task mit der längsten Zykluszeit! Für Feldbusse ist ein festes Zyklusraster nötig, um ein determiniertes Verhalten sicherzustellen. Verwenden Sie deshalb für eine Buszyklustask nicht den Typ \" freilaufend \". Zusätzliche Einstellungen Force-Variablen für das I\/O Abbild Diese Einstellung ist nur verfügbar, wenn sie vom Gerät unterstützt wird. : Für jeden E\/A-Kanal, der im Dialog E\/A-Abbild auf eine Variable abgebildet (gemappt) ist, werden beim Übersetzen der Applikation zwei globale Variablen erzeugt. Diese können Sie für das Forcen des Eingangs- oder Ausgangswerts an diesem Kanal verwenden, beispielsweise über eine HMI-Visualisierung. Diagnose für Geräte aktivieren : Die Bibliothek CAA Device Diagnosis wird im Projekt eingebunden. Für jedes Gerät wird ein impliziter Funktionsbaustein generiert. Wenn es für das Gerät bereits einen Funktionsbaustein gibt, wird entweder ein erweiterter Funktionsbaustein erzeugt (beispielsweise bei EtherCAT) oder eine weitere Funktionsbaustein-Instanz hinzugefügt. Diese beinhaltet dann eine allgemeine Implementierung zur Gerätediagnose. Mittels der Funktionsbaustein-Instanzen können Sie in der Applikation von allen Geräten den Status ermitteln und Fehler auswerten. Die Bibliothek enthält außerdem Funktionen zum programmatischen Bearbeiten des Gerätebaums. Beispiel: Durchsuchen aller Kinder eines Bussystems, Springen zum Elternelement. Für weitere Informationen siehe: CAA Device Diagnosis Library Documentation E\/A-Warnungen als Fehler anzeigen Warnungen, die die E\/A-Konfiguration betreffen, werden als Fehler ausgegeben. Symbolischer Zugriff für E\/As aktivieren : Für die E\/A-Kanäle des Geräts werden automatisch Ein- und Ausgangsvariablen ( VAR_INPUT und VAR_OUTPUT ) erstellt. Dafür wird je Slave ein erweiterter Funktionsbaustein angelegt. Basis ist der existierende Funktionsbaustein des Slaves. Auf so einen automatisch generierten Funktionsbausteine kann im Applikationscode unmittelbar zugegriffen werden. Dieser symbolische Zugriff funktioniert parallel zum E\/A-Mapping, das manuell aufgesetzt wurde. : Der Zugriff auf E\/A-Kanäle wird nicht unterstützt. Es ist erforderlich, manuell ein Mapping aufzusetzen und gezielt neue oder existierende Variablen je E\/A-Kanal zuzuordnen. " }, 
{ "title" : "Registerkarte: SPS-Shell ", 
"url" : "_cds_edt_device_plc_shell.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: SPS-Shell ", 
"snippet" : "Diese Registerkarte des generischen Geräteeditors enthält einen textbasierten Steuerungsmonitor zur Abfrage bestimmter Informationen aus der Steuerung. Sie können dazu geräteabhängige Kommandos eingeben und erhalten die Antwort der Steuerung in einem Ergebnisfenster. Die SPS-Shell wird im Simulation...", 
"body" : "Diese Registerkarte des generischen Geräteeditors enthält einen textbasierten Steuerungsmonitor zur Abfrage bestimmter Informationen aus der Steuerung. Sie können dazu geräteabhängige Kommandos eingeben und erhalten die Antwort der Steuerung in einem Ergebnisfenster. Die SPS-Shell wird im Simulationsbetrieb nicht unterstützt. Für weitere Informationen siehe: SPS-Shell zur Abfrage von Informationen verwenden" }, 
{ "title" : "", 
"url" : "_cds_edt_device_plc_shell.html#UUID-1cf3dce3-ea3d-52c5-2128-ebac8bef6716_UUID-9403fb45-4885-1a82-e631-65a4038d76bf", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: SPS-Shell \/ ", 
"snippet" : "Standardkommandos Kommando mit möglichen Parametern Beschreibung ? Liste der verfügbaren SPS-Shell-Kommandos mit möglichen Parametern und Kurzbeschreibung getcmdlist Liste der Namen der verfügbaren SPS-Shell-Kommandos mem <memory address> [<size>] Liefert den Hexdump des definierten Speicherbereiche...", 
"body" : "Standardkommandos Kommando mit möglichen Parametern Beschreibung ? Liste der verfügbaren SPS-Shell-Kommandos mit möglichen Parametern und Kurzbeschreibung getcmdlist Liste der Namen der verfügbaren SPS-Shell-Kommandos mem <memory address> [<size>] Liefert den Hexdump des definierten Speicherbereiches Die Größenangabe size ist optional und beschreibt die Anzahl der Bytes, die ausgegeben werden. Standardwert: 16 Beispiel: mem 16x0422139C 8 reflect Wiederholt das eingegebene Kommando (zum Testen der Verbindung) applist Liefert eine Liste aller geladener Applikationen Die Reihenfolge in der Liste definiert beginnend mit 0 den Applikationsindex. pid [<application name> | <application index> ] * Liefert die GUID (Applikationsindex) einer oder aller geladenen Applikationen pinf [<application name> | <application index>] * Liefert aus den Projektinformationen des Projekts die Inhalte folgender Felder: Titel, Version, Autor und Beschreibung. Voraussetzung: Die Option Automatisch POU für den Eigenschaftenzugriff erzeugen im Dialog Projektinformationen wurde aktiviert. startprg [<application name> | <application index> ] * Startet die angegebene Applikation, oder - wenn keine Applikation angegeben ist - alle geladenen Applikationen stopprg [<application name> | <applikation index> ] * Stoppt die angegebene Applikation, oder - wenn keine Applikation angegeben ist - alle geladenen Applikationen resetprg [<applikation name> | <application index> ] * Setzt die angegebene Applikation zurück, oder - wenn keine Applikation angegeben ist - alle geladenen Applikationen resetprgcold [<application name> | <application index> ] * Führt einen Kaltstart der angegebene Applikation durch, oder - wenn keine Applikation angegeben ist - aller geladenen Applikationen reload [<application name> | <application index>] * Lädt die Bootapplikation der angegebene Applikation, oder - wenn keine Applikation angegeben ist - die Bootprojekte aller geladenen Applikationen getprgstat [<application name> | <applikationsindex>] * Liefert den Programmstatus der angegebene Applikation, oder - wenn keine Applikation angegeben ist - den aller geladenen Applikationen plcload Zeigt die Prozessorauslastung der Steuerung in Prozent rtsinfo Liefert Informationen zum Laufzeitsystem, wie beispielsweise Prozessor und Version des Laufzeitsystems channelinfo Liefert Informationen zum Kommunikationskanal rtc-get Liefert die Weltzeit UTC über den String DataTime rtc-set Setzt die Weltzeit UTC über den String DataTime (siehe ISO8601) listpcicards [<vendor ID>] Liefert eine Liste aller oder nach <vendor ID> gefilterten PCI-Karten gettaskgroups Liefert eine Liste mit allen Taskgruppen, ihrer Tasks und die CPU-Kern Bindung cert-getapplist Zeigt alle registrierten angewendeten Zertifikate an (ID der Komponente und Verwendung) cert-genselfsigned [<number for search result by \"cert-getapplist\"> <expdays=>] Erzeugt selbstsignierte Zertifikate Durch expdays= kann die Gültigkeitsdauer des Zertifikats angegeben werden. Standardwert: 365 Tage cert-gendhparams <length in bits> Erzeugt die Parameter für den Diffie-Hellman Schlüsselaustausch Dieser Vorgang kann mehrere Minuten dauern! cert-getcertlist [<trust level>] Listet alle Zertifikate der angegebenen Vertrauensstufe auf Wenn keine Vertrauensstufe angegeben ist, werden alle Zertifikate aufgelistet. Mögliche Vertrauensstufen untrusted : nicht vertrauenswürdige Zertifikate trusted : vertrauenswürdige Zertifikate own : Zertifikate der Steuerung quarantine : Zertifikate, deren Vertrauenstufe (vertrauenswürdig \/ nicht vertrauenswürdig) durch eine Validierung nicht geklärt werden konnte Eingehende Verbindungen wurden daher abgelehnt. cert-createcsr [<number for search result by \"cert-getapplist\">] Erzeugt CSR-Dateien für alle Applikationen cert-import <trust level> <file name.cer> Importiert das angegebene Zertifikat cert-export <trust level> [<number of search result by \"cert-getcertlist\">] Exportiert das angegebene Zertifikat cert-remove <trust level> <number of search result by \"cert-getcertlist\" or \"all\"> Entfernt die angegebenen Zertifikate cpuload Zeigt die Prozessorauslastung der CPU (bei Multicore pro Prozessorkern) gettaskgroups Liefert eine Liste der definierten Taskgruppen Zu jeder Taskgruppe werden die zugewiesenen Tasks angezeigt. getmulticoreinfo Zeigt an, ob Multicore unterstützt wird und wie viele Prozessorkerne verfügbar sind sessinfo-list Liefert eine Liste aller aktuell eingeloggten Clients\/Benutzer sessinfo-getcnt Liefert die Anzahl der aktuell eingeloggten Clients\/Benutzer logsetfilter [<CmpName>...] <FilterValue> Konfiguriert die Einstellungen des Log-Filters mit hexadezimalen Werten. loggetfilter [<CmpName>...] Ruft die aktuellen Einstellungen des Log-Filters für die angegebenen Komponenten ab. logdelfilter [<CmpName>...] Löscht die Einstellungen des Log-Filters für die angegebenen Komponenten. * Applikationsname: Name der Applikation im Gerätebaum Applikationsindex: Ergibt sich aus der Liste aller Applikationen auf der Steuerung, die Sie mit dem Kommando applist abrufen können. Index 0 bezeichnet die erste Applikation in der Liste, Index 1 die zweite. " }, 
{ "title" : "Registerkarte: <Gerätename> E\/A-Abbild ", 
"url" : "_cds_edt_device_io_mapping.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: <Gerätename> E\/A-Abbild ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Geräte mit E\/A-Kanälen ", 
"url" : "_cds_edt_device_io_mapping.html#UUID-fbea3edd-739b-f693-2a4d-f97a628b9269_id_ebd811526ea50336c0a8640e0138a0ff_id_2fed243abb96eb7ec0a864637b4cf8a3", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: <Gerätename> E\/A-Abbild \/ Geräte mit E\/A-Kanälen ", 
"snippet" : "Diese Registerkarte erscheint in Geräteeditoren für Geräte mit E\/A-Kanälen. Sie zeigt die verfügbaren Kanäle und erlaubt die Abbildung der Eingangs-, Ausgangs- und Speicheradressen des Steuerungsgeräts auf Variablen oder ganze Funktionsbausteine der Applikation. Damit erstellen Sie das sogenannte „E...", 
"body" : "Diese Registerkarte erscheint in Geräteeditoren für Geräte mit E\/A-Kanälen. Sie zeigt die verfügbaren Kanäle und erlaubt die Abbildung der Eingangs-, Ausgangs- und Speicheradressen des Steuerungsgeräts auf Variablen oder ganze Funktionsbausteine der Applikation. Damit erstellen Sie das sogenannte „E\/A-Abbild“ („Mapping“). Für weitere Informationen siehe: Geräte konfigurieren und E\/A-Abbild konfigurierenWelche Applikation die E\/A-Behandlung übernehmen soll, definieren Sie in der Registerkarte SPS-Einstellungen . Wenn es vom Gerät unterstützt wird, können Sie den „Online-Konfigurationsmodus“ verwenden. In diesem Modus können Sie auf die E\/As der Hardware zugreifen ohne vorher eine reelle Applikation auf das Gerät geladen haben zu müssen. Wenn ein E\/A-Kanal nicht in der Applikation referenziert sind, dann wird dessen Wert nicht aktualisiert. Wenn Sie nicht referenzierte E\/A-Kanäle monitoren wollen, müssen Sie die Option Variablen immer aktualisieren auf der Registerkarte: SPS-Einstellungen aktivieren. Alternativ können Sie diese Option auch auf der Registerkarte E\/A-Abbild eines Geräts aktivieren. Dann ist die Aktivierung nur für dieses eine Gerät und dessen Kinder gültig. Abbilden „zu großer“ Datentypen Wenn Sie eine Variable eines Datentyps, der größer ist als ein Byte, auf eine Byteadresse abbilden, wird dort der Wert der Variablen auf Byte-Größe abgeschnitten! Für das Monitoring des Variablenwerts im Dialog E\/A-Abbild bedeutet dies: Im Wurzelelement der Adresse wird der Wert angezeigt, den die Variable im Projekt aktuell hat. In den Bit-Elementen darunter werden nacheinander die einzelnen aktuellen Bit-Werte des Bytes dargestellt, was aber gegebenenfalls nicht für den gesamten Variablenwert ausreicht. Beispiel der Registerkarte <Gerätename> E\/A-Abbild für einen CAN-Bus Slave: Die Registerkarte enthält eine Tabelle zum Bearbeiten des E\/A-Abbilds. Die dargestellten Informationen zu den Eingängen und Ausgängen stammen aus der Gerätebeschreibung. Suche (1) Eingabefeld für eine Zeichenfolge, nach der die Mapping-Tabelle durchsucht werden soll Die Suchergebnisse werden gelb markiert. Filter (2) Auswahlliste mit Filtern für die in der Mapping-Tabelle dargestellten E\/A-Zuweisungen: Alles anzeigen Nur Ausgänge anzeigen Nur Eingänge anzeigen Nur nicht-gemappte Variablen anzeigen Nur gemappte Variablen anzeigen Nur Mappings auf bestehende Variablen anzeigen Nur Mappings auf neue Variablen anzeigen FB für E\/A-Kanal hinzufügen (11) Geräteabhängig verfügbar, wenn ein Kanaleintrag in der Mapping-Tabelle selektiert ist Öffnet den Dialog Funktionsbaustein auswählen zur Auswahl des Bausteins, der mit dem Kanal direkt verknüpft werden soll Gehe zu Instanz (12) Verfügbar, wenn ein Eintrag in der Mapping-Tabelle selektiert ist Springt zum entsprechenden Eintrag in der Registerkarte <Gerätename> IEC-Objekte Variable Abhängig vom Gerät erscheinen die Eingänge und Ausgänge des Geräts als Knoten, darunter eingerückt die zugehörigen Kanäle, oder je nach Gerät nur die implizit angelegte Geräteinstanz. Das Symbol zeigt den Kanaltyp an: : Eingang : Ausgang Ein Doppelklick auf die Zelle öffnet ein Eingabefeld. Möglichkeit 1: Die Variable existiert bereits. Kompletten Pfad eintragen: <Applikationsname>.<Bausteinname>.<Variablenname> Beispiel: app1.plc_prg.ivar ; Eingabehilfe über Möglichkeit 2: Die Variable existiert noch nicht. Einfachen Namen eingeben Wird automatisch intern als globale Variable angelegt Abhängig vom Gerät können Eingänge oder Ausgänge direkt mit einem Funktionsbaustein verknüpft werden. In diesem Fall ist die Schaltfläche FB für E\/A-Kanal hinzufügen bedienbar. Siehe oben. Mapping (3) Typ des Abbilds: : Bereits existierende Variable : Neue Variable : Abbild auf Funktionsbaustein-Instanz Kanal (4) Symbolischer Name des Kanals. Adresse (5) Adresse des Kanals, beispielsweise %IW0 Durchgestrichene Adresse: Zeigt an, dass Sie dieser Adresse keine weitere Variable zuweisen sollten. Grund: Die hier angegebene Variable wird - als bereits bestehende - zwar an einem anderen Speicherplatz verwaltet, aber es könnten Mehrdeutigkeiten beim Schreiben der Werte entstehen, speziell bei Ausgängen. : Zeigt an, dass diese Adresse bearbeitet und fixiert wurde Wenn sich die Anordnung der Geräteobjekte im Gerätebaum ändert, passt CODESYS diese Adresse nicht automatisch an. Typ (6) Datentyp des Kanals, beispielsweise BOOL In der Gerätebeschreibung definierte Strukturen oder Bitfelder werden nur angezeigt, wenn sie Teil der IEC-Norm sind und als IEC-Datentyp in der Gerätebeschreibung gekennzeichnet sind. Ansonsten bleibt die Tabellenzelle leer. Beim Abbilden von strukturierten Variablen verhindert der Editor, dass Sie sowohl die Strukturvariable (beispielsweise auf %QB0 ) als auch einzelne Strukturelemente (beispielsweise auf %QB0.1 und QB0.2 ) eintragen können. Wenn es einen Haupteintrag mit einem Unterbaum von Bitkanal-Einträgen in der Mapping-Tabelle gibt gilt deshalb: Sie können entweder in der Zeile des Haupteintrags eine Variable eingeben, oder in den Zeilen der Unterelemente (Bitkanäle), aber nicht in beiden. Standardwert Standardwert des Parameters, der auf dem Kanal anliegt: Erscheint nur, wenn in den SPS-Einstellungen für das Verhalten der Ausgänge bei Stop die Option Alle Ausgänge auf Standardwert setzen aktiviert ist. Hinweis: Ab Compilerversion V3.5 SP11 wird für ein Mapping auf eine bestehende Variable automatisch der Initialisierungswert der Variablen als Standardwert verwendet. Das Feld Standardwert können Sie nur noch bearbeiten, wenn Sie ein Mapping auf eine neu erzeugte Variable vornehmen. In älteren Versionen musste der Anwender explizit dafür sorgen, dass Standardwert und Initialisierungswert identisch sind. Einheit (7) Einheit für den Parameterwert, beispielweise ms für Millisekunden Beschreibung (8) Kurzbeschreibung des Parameters Aktueller Wert Istwert des auf dem Kanal anliegenden Parameters, erscheint nur im Onlinebetrieb Die Änderung des Standardwerts durch einen Online-Change ist erlaubt, jedoch wird der Wert erst nach einem „Reset kalt“ oder „Reset warm“ angewendet. Mapping zurücksetzen (9) CODESYS setzt die Mapping-Einstellungen auf die durch die Gerätebeschreibungsdatei definierten Standardwerte zurück. Variablen aktualisieren (10) Festlegung für das Geräteobjekt bezüglich der Aktualisierung der E\/A-Variablen Der Standardwert ist in der Gerätebeschreibung definiert: Einstellungen des übergeordneten Geräts verwenden : Aktualisierung gemäß den Einstellungen des übergeordneten Geräts. Aktiviert 1 (Buszyklustask verwenden, wenn in keiner Task verwendet) : CODESYS aktualisiert die E\/A-Variablen in der Buszyklustask, falls sie in keiner anderen Task verwendet werden. Aktiviert 2 (immer in Buszyklustask) : CODESYS aktualisiert alle Variablen in jedem Zyklus der Buszyklustask, unabhängig davon ob sie verwendet werden und ob sie auf einen Ein- oder Ausgangskanal abgebildet sind. Wenn eine UNION durch E\/A-Kanäle im Mapping-Dialog vertreten ist, hängt es vom Gerät ab, ob auch ein Abbilden auf das Wurzelelement möglich ist. Für weitere Informationen siehe: Feldbusgeräte und E\/A-Treiber" }, 
{ "title" : "Geräte mit E\/A-Treiber ", 
"url" : "_cds_edt_device_io_mapping.html#UUID-fbea3edd-739b-f693-2a4d-f97a628b9269_id_ebd811526ea50336c0a8640e0138a0ff_id_d5bd0998ff830339c0a8640e014aab3c", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: <Gerätename> E\/A-Abbild \/ Geräte mit E\/A-Treiber ", 
"snippet" : "Bei Geräten mit E\/A-Treiber können Sie hier auf der Registerkarte E\/A-Abbild die Buszyklus-Task einstellen, wenn nicht die allgemeine Einstellung (Registerkarte SPS-Einstellungen ) verwendet werden soll. Buszyklus-Optionen Buszyklus-Task Die Auswahlliste bietet alle Tasks an, die in der Task-Konfigu...", 
"body" : "Bei Geräten mit E\/A-Treiber können Sie hier auf der Registerkarte E\/A-Abbild die Buszyklus-Task einstellen, wenn nicht die allgemeine Einstellung (Registerkarte SPS-Einstellungen ) verwendet werden soll. Buszyklus-Optionen Buszyklus-Task Die Auswahlliste bietet alle Tasks an, die in der Task-Konfiguration der aktiven Applikation definiert sind, wie biespielsweise MainTask . Im Fall von Zykluseinstellungen des übergeordneten Busses verwenden werden die Einstellungen des Vaterknotens verwendet. " }, 
{ "title" : "Allgemeine Informationen zur Buszyklus-Task ", 
"url" : "_cds_edt_device_io_mapping.html#UUID-fbea3edd-739b-f693-2a4d-f97a628b9269_id_ebd811526ea50336c0a8640e0138a0ff_id_3c6e4af3bb96eb7ec0a864634fef4137", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: <Gerätename> E\/A-Abbild \/ Allgemeine Informationen zur Buszyklus-Task ", 
"snippet" : "Grundsätzlich werden für jede IEC-Task die verwendeten Eingangsdaten am Beginn jeder Task gelesen (1) und die geschriebenen Ausgangsdaten am Ende der Task (3) zum E\/A-Treiber übertragen. Die Implementierung im E\/A-Treiber ist entscheidend für den weiteren Transport der E\/A-Daten. Sie ist verantwortl...", 
"body" : "Grundsätzlich werden für jede IEC-Task die verwendeten Eingangsdaten am Beginn jeder Task gelesen (1) und die geschriebenen Ausgangsdaten am Ende der Task (3) zum E\/A-Treiber übertragen. Die Implementierung im E\/A-Treiber ist entscheidend für den weiteren Transport der E\/A-Daten. Sie ist verantwortlich dafür, in welchem Zeitraster und zu welchem Zeitpunkt die tatsächliche Übertragung auf das jeweilige Bussystem stattfindet. Die Buszyklustask der SPS kann für alle Feldbusse global in den SPS-Einstellungen festgelegt werden. Bei einigen Feldbussen können Sie diese jedoch unabhängig von der globalen Einstellung verändern. Als Buszyklustask wird automatisch die Task mit der kürzesten Zykluszeit verwendet (Einstellung: unspezifiziert in den SPS-Einstellungen). In dieser Task werden normalerweise die Nachrichten auf den Bus gesendet. Weitere Tasks kopieren nur die E\/A-Daten aus einem internen Puffer, der nur in der Buszyklustask mit der realen Hardware ausgetauscht wird. (1) Lesen der Eingänge vom Eingangspuffer (2) IEC-Task\n(3) Schreiben der Ausgänge in den Ausgangspuffer (4) Buszyklus\n(5) Eingangspuffer (6) Ausgangspuffer\n(7) Daten vom\/zum Bus kopieren\n(9) Buszyklustask, Priorität 1, 1ms\n(10) Buszyklustask, Priorität 5\n(11) Buszyklustask, Priorität 10, unterbrochen durch Task 5 Taskverwendung In der Registerkarte Taskaufstellung steht Ihnen eine Übersicht der verwendeten E\/A-Kanäle, der eingestellten Buszyklustask und der Verwendung der Kanäle zur Verfügung. Wenn ein Ausgang in verschiedenen Tasks geschrieben wird, so ist der Zustand undefiniert, da dieser jeweils überschrieben werden kann. Bei Verwendung von gleichen Eingängen in verschiedenen Tasks kann es passieren, dass sich der Eingang während der Abarbeitung einer Task verändert. Dies geschieht, wenn die Task durch eine Task mit höherer Priorität unterbrochen und damit das Prozessabbild erneut eingelesen wird. Abhilfe: Am Beginn der IEC-Task die Eingangsvariablen in Variablen kopieren und dann im weiteren Code nur noch mit den lokalen Variablen arbeiten. Fazit: Eine Verwendung von gleichen Ein- und Ausgängen in mehreren Tasks ist nicht sinnvoll und kann in manchen Fällen zu unvorhergesehenen Zuständen führen. " }, 
{ "title" : "Registerkarte: <Gerätename> IEC-Objekte ", 
"url" : "_cds_edt_device_iec_objects.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: <Gerätename> IEC-Objekte ", 
"snippet" : "Bitte beachten Sie, dass das manuelle Anlegen einer weiteren Instanz des Geräteobjekts zu Fehlfunktionen führen kann. In dieser Registerkarte des generischen Geräteeditors sind „Objekte“ aufgelistet, die einen Zugriff aus der IEC-Applikation auf das Gerät ermöglichen. Im Onlinebetrieb dient sie als ...", 
"body" : "Bitte beachten Sie, dass das manuelle Anlegen einer weiteren Instanz des Geräteobjekts zu Fehlfunktionen führen kann. In dieser Registerkarte des generischen Geräteeditors sind „Objekte“ aufgelistet, die einen Zugriff aus der IEC-Applikation auf das Gerät ermöglichen. Im Onlinebetrieb dient sie als Monitoringansicht. Bei Geräten, für die implizit eine Funktionsbausteininstanz erzeugt wird, erscheint mindestens diese Instanz als Objekt hier in der Tabelle. Beispielsweise kann diese Instanz verwendet werden, um aus der Applikation heraus einen Bus neu zu starten oder Informationen abzufragen. Ob und mit welchen Zugriffsmöglichkeiten eine solche Geräteinstanz verfügbar ist, hängt vom Gerätetyp ab. Sehen Sie dazu bitte die Hilfe zur speziellen Gerätekonfiguration. Auch Instanzen von Funktionsbausteinen, die mit Eingängen oder Ausgängen des Geräts verknüpft sind, werden hier dargestellt. Das Mapping eines Funktionsbausteins auf einen Kanal ist auf der Registerkarte <Gerätename> E\/A-Abbild definiert. Mit dem Befehl Gehe zu Instanz gelangen Sie von dort direkt hierher zum betreffenden Objekt. Zusätzlich können Sie hier in der Tabelle weitere Objekte anlegen, die zunächst noch nicht mit einem Gerätekanal verknüpft sind Im Onlinebetrieb können Sie die Tabelle der IEC-Objekte als Monitoringansicht verwenden. Sie zeigt dann auch den aktuellen Wert, die Adresse und den Kommentar zur am Kanal anliegenden Funktionsbausteinvariablen, und bietet die Möglichkeit zum Schreiben und Forcen von Werten. Hinzufügen Bearbeiten Öffnet jeweils den Dialog Funktionsbaustein auswählen zum Anlegen einer neuen Instanz oder zum Bearbeiten der gerade in der Tabelle selektierten Instanz Löschen Löscht den selektierten Eintrag Gehe zu Variable Vom selektierten Eintrag springt man direkt zum zugehörigen Mapping in der Registerkarte <Gerätename> E\/A-Abbild . Variable Der Objektname setzt sich aus dem Gerätenamen und dem Funktionsbausteinnamen zusammen. Beispiel: EL2004_Relay . Ein Ändern des Gerätenamens im Projekt wirkt sich sofort entsprechend aus. Der Teil des Namens hinter dem Gerätenamen hier editierbar. Mapping Mapping-Typ, wie auf Registerkarte <Gerätename> E\/A-Abbild Typ Datentyp, hier Name des Funktionsbausteins Wert Vorbereiteter Wert Adresse Kommentar Nur im Onlinebetrieb: Anzeige des aktuellen Werts, der Adresse und des Kommentars für die am Kanal anliegende Variable Außerdem die Möglichkeit, einen Wert zum Schreiben oder Forcen der Variablen einzutragen. " }, 
{ "title" : "Registerkarte: Zugriffsrechte ", 
"url" : "_cds_edt_device_access_rights.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Zugriffsrechte ", 
"snippet" : "Empfehlungen zur Datensicherheit Um das Risiko von Datensicherheitsverletzungen zu minimieren, empfehlen wir die folgenden organisatorischen und technischen Maßnahmen für das System, auf dem Ihre Applikationen laufen: Vermeiden Sie soweit als möglich, die SPS und Steuerungsnetzwerke offenen Netzwerk...", 
"body" : "Empfehlungen zur Datensicherheit Um das Risiko von Datensicherheitsverletzungen zu minimieren, empfehlen wir die folgenden organisatorischen und technischen Maßnahmen für das System, auf dem Ihre Applikationen laufen: Vermeiden Sie soweit als möglich, die SPS und Steuerungsnetzwerke offenen Netzwerken und dem Internet auszusetzen. Verwenden Sie zum Schutz zusätzliche Sicherungsschichten wie ein VPN für Remote-Zugriffe und installieren Sie Firewall-Mechanismen. Beschränken Sie den Zugriff auf autorisierte Personen, ändern Sie eventuell vorhandene Standard-Passwörter bei der ersten Inbetriebnahme und auch weiterhin regelmäßig. Ausführliche Informationen zum Konzept und zur Verwendung der Gerätebenutzerverwaltung finden Sie im Kapitel Gerätebenutzerverwaltung handhaben. Dort finden Sie auch folgende Anleitungen zur Handhabung des Editors: Erstmaliges Anmelden auf der Steuerung, um deren Benutzerverwaltung zu bearbeiten und anzusehen Neuen Benutzer in der Benutzerverwaltung des Steuerungsgeräts einrichten Zugriffsrechte auf Steuerungsobjekte in der Benutzerverwaltung des Steuerungsgeräts verändern Im Offlinebetrieb eine Benutzerverwaltung aus einer *.dum-Datei laden, ändern und auf das Steuerungsgerät bringen In dieser Registerkarte definieren Sie für Gerätebenutzer die Rechte für Zugriffe auf Objekte auf der Steuerung. Wie in der Projektbenutzerverwaltung muss ein Benutzer Mitglied mindestens einer Benutzergruppe sein und können nur Benutzergruppen bestimmte Zugriffsrechte erhalten. Voraussetzungen, damit die Registerkarte Zugriffsrechte angezeigt wird: Die Option Registerkarte „Zugriffsrechte anzeigen“ in den CODESYS -Optionen in der Kategorie Geräteeditor muss aktiviert sein. Beachten Sie: Diese CODESYS -Option kann durch die Gerätebeschreibung überschrieben werden! Voraussetzungen, damit Zugriffsrechte den Benutzergruppen zugeordnet werden können Eine Komponente für die Benutzerverwaltung muss auf der Steuerung vorhanden sein. Das ist die Grundvoraussetzung Benutzer und Benutzergruppen müssen in der Registerkarte Benutzer und Gruppen konfiguriert sein Objekte In der Baumstruktur sind die Objekte aufgelistet, auf die zur Laufzeit Aktionen ausgeführt werden können. Die Objekte sind jeweils ihrer Objektquelle zugeordnet und teilweise in Objektgruppen sortiert. Für ein selektiertes Objekt können Sie im Rechte -Fenster die Zugriffsmöglichkeit für eine Benutzergruppe konfigurieren. Objektquelle (Wurzelknoten) Dateisystemobjekte → Device : In diesen Objekten können die Rechte auf Ordner des aktuellen Ausführungsverzeichnisses der Steuerung vergeben werden Laufzeitsystemobjekte → \/ : In diesen Objekten werden alle Objekte verwaltet, die einen Onlinezugang in der Steuerung besitzen und die damit die Zugriffsrechte steuern müssen. Eine Beschreibung der Objekte finden Sie in der Tabelle Übersicht über die Objekte Objektgruppen und Objekte (eingerückt) Beispielsweise: Device mit Kindobjekten Logger , PlcLogic , Settings , UserManagement . Rechte Allgemein vererben sich die Zugriffsrechte von dem Wurzelobjekt (also Device oder \/ ) zu den Unterobjekten. D.h. wenn auf einem übergeordneten Objekt ein Recht einer Benutzergruppe entzogen oder explizit vergeben wird, dann wirkt das erstmals auf alle Unterobjekte! Die Tabelle gilt jeweils für das gerade im Baum ausgewählte Objekt. Sie zeigt für jede Benutzergruppe die aktuell konfigurierten Rechte für die möglichen Aktionen auf dieses Objekt. Mögliche Aktionen auf das Objekt: Hinzufügen\/Entfernen Ändern Ansehen Ausführen Mit einem Klick auf ein Objekt erscheint auf der rechten Seite eine Tabelle, die die Zugriffsrechte der verfügbaren Benutzergruppen für das selektierte Objekt anzeigt. Damit kann auf einen Blick erfasst werden: Welche Zugriffsrechte werden von einem Objekt ausgewertet Welche Benutzergruppe hat auf welchem Objekt welche effektiven Rechte Die Bedeutung der Symbole : Zugriffsrecht explizit erteilt : Zugriffsrecht explizit verweigert : Zugriffsrecht neutral: vererbt erteilt : Zugriffsrecht neutral vererbt verweigert : Das Zugriffsrecht wurde nicht explizit gesetzt oder verweigert, auch nicht im Vaterobjekt. Ein Zugriff ist nicht möglich. kein Symbol: Es sind mehrere Objekte ausgewählt, die keine einheitlichen Zugriffsrechte haben. Mit einem Mausklick auf das Symbol ändern Sie das Recht. Beispiel Das Objekt Logger in der Registerkarte Zugriffsrechte wurde von der Komponente „Logger“ angelegt und steuert deren Zugriffsrechte. Es befindet sich direkt unterhalb des Laufzeitsystemobjekts Device . Dabei können für dieses Objekt die möglichen Zugriffsrechte nur für die Aktion Ansehen vergeben werden. Zunächst hat jedes Objekt ein Leserecht. Dies bedeutet, dass jeder Benutzer den „Logger“ einer Steuerung auslesen kann. Wenn nun einer einzelnen Benutzergruppe (im Beispiel Sevice ) dieses Recht entzogen werden soll, dann muss das Leserecht auf dem Logger Objekt explizit verweigert werden: " }, 
{ "title" : "Werkzeugleiste der Registerkarte ", 
"url" : "_cds_edt_device_access_rights.html#UUID-cd3e7f33-8afc-1a1a-14eb-8436f7d0b1e8_UUID-bf0ecbfd-1dbd-5ac2-0f81-c00318625768", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Zugriffsrechte \/ Werkzeugleiste der Registerkarte ", 
"snippet" : "Synchronisierung Schaltet die Synchronisierung zwischen Editor und Benutzerverwaltung auf dem Gerät ein und aus. Wenn die Schaltfläche nicht „gedrückt“ ist, ist der Editor leer, oder enthält eine Konfiguration, die Sie von der Festplatte geladen haben. Wenn Sie die Synchronisierung einschalten, währ...", 
"body" : " Synchronisierung Schaltet die Synchronisierung zwischen Editor und Benutzerverwaltung auf dem Gerät ein und aus. Wenn die Schaltfläche nicht „gedrückt“ ist, ist der Editor leer, oder enthält eine Konfiguration, die Sie von der Festplatte geladen haben. Wenn Sie die Synchronisierung einschalten, während der Editor eine noch nicht mit dem Gerät synchronisierte Benutzerkonfiguration enthält, erhalten Sie zunächst eine Abfrage, was mit dem Editorinhalt geschehen soll. Die Optionen: Vom Gerät hochladen und den Inhalt im Editor überschreiben : Die auf dem Gerät vorliegende Konfiguration wird in den Editor geladen und überschreibt den aktuellen Inhalt. Inhalt des Editors auf das Gerät laden und dort die Benutzerverwaltung überschreiben : Die im Editor enthaltene Konfiguration wird auf das Gerät übertragen und dort wirksam. Importieren von Festplatte Wenn Sie die Schaltfläche in der Registerkarte Benutzer und Gruppen klicken, um eine Gerätebenutzerverwaltungsdatei *.dum2 zu importieren, erscheint der Standarddialog zum Auswählen einer Gerätebenutzerverwaltungsdatei von der Festplatte. Nach Auswahl der Datei öffnet sich der Dialog Passwort eingeben . Sie müssen das Passwort eingeben, das beim Exportieren der Datei vergeben wurde. Damit wird dann die Benutzerverwaltung aktiviert. Hinweis: Vor V3.5 SP16 wurde der Dateityp Gerätebenutzerverwaltungsdateien (*.dum) verwendet, der noch keine Verschlüsselung erforderte. Wenn Sie die Schaltfläche in der Registerkarte Zugriffsrechte klicken, um eine Geräterechteverwaltungsdatei (*.drm) zu importieren, öffnet sich der Standarddialog zum Auswählen einer entsprechenden Datei von der Festplatte. Die bestehende Konfiguration im Dialog wird durch die importierte Datei überschrieben. Exportieren auf Festplatte Wenn Sie die Schaltfläche in der Registerkarte Benutzer und Gruppen klicken, erscheint zunächst der Dialog Passwort eingeben zur Vergabe eines Passworts für die Gerätebenutzerverwaltungsdatei. Beachten Sie: Dieses Passwort muss später bei einem Import dieser Datei wieder eingegeben werden, um diese Benutzerverwaltung auf der Steuerung zu aktivieren.. Nach Schließen des Dialogs zur Passwortvergabe öffnet sich der Standarddialog zum Auswählen und Importieren einer Benutzerverwaltungskonfiguration von der Festplatte. Der Dateityp ist in diesem Fall Gerätebenutzerverwaltungsdateien (*.dum2) (Device User Management). Hinweis: Vor V3.5 SP16 wurde der Dateityp Gerätebenutzerverwaltungsdateien (*.dum) verwendet, der noch keine Verschlüsselung erforderte. Wenn Sie die Schaltfläche in der Registerkarte Zugriffsrechte klicken, ist der Dateityp Geräterechteverwaltungsdateien (*.drm) (Device Rights Management). In diesem Fall muss vor der Ablage kein Passwort für die Datei vergeben werden. Gerätebenutzer Benutzername des gerade auf dem Gerät eingeloggten Benutzers " }, 
{ "title" : "Übersicht über die Objekte ", 
"url" : "_cds_edt_device_access_rights.html#UUID-cd3e7f33-8afc-1a1a-14eb-8436f7d0b1e8_id_ef1aea5deb3245c0a8640e00986ced_id_963abee2e14f82aec0a86312370c73c1", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Zugriffsrechte \/ Übersicht über die Objekte ", 
"snippet" : "Laufzeitsystemobjekte → Device Logger Der Onlinezugriff auf den Logger erfolgt nur lesend. Daher kann hier nur das Recht Ansehen vergeben oder verweigert werden. PLCLogic Alle IEC-Applikationen werden als Unterobjekte beim Download hier automatisch eingehängt. Wenn eine Applikation gelöscht wird, we...", 
"body" : "Laufzeitsystemobjekte → Device Logger Der Onlinezugriff auf den Logger erfolgt nur lesend. Daher kann hier nur das Recht Ansehen vergeben oder verweigert werden. PLCLogic Alle IEC-Applikationen werden als Unterobjekte beim Download hier automatisch eingehängt. Wenn eine Applikation gelöscht wird, werden sie automatisch wieder entfernt. Damit kann dann der Onlinezugriff auf die Applikation gezielt gesteuert werden. Die Zuweisung der Zugriffsrechte über alle Applikationen kann zentral im PlcLogic -Objekt erfolgen. Auf die IEC-Applikationen haben die Benutzergruppen Administrator und Developer Vollzugriff. Die Benutzergruppen Service und Watch besitzen nur Leserechte (zum Beispiel lesendes Monitoring der Werte). Die folgende Tabelle zeigt an, welche Aktion im Einzelnen betroffen ist, wenn ein bestimmtes Zugriffsrecht für eine IEC-Applikation vergeben wurde. x : Das Recht muss explizit gesetzt werden - : Das Recht ist nicht relevant Application Operation Zugriffsrecht Hinzufügen\/Entfernen Ausführen Ändern Ansicht Einloggen - - - x Anlegen x - - - Kindobjekt anlegen x - - - Löschen x - - - Laden \/ Online-Change x - - - Bootapplikation erzeugen x - - - Variable lesen - - - x Variable schreiben - - x x Variable forcen - - x x Haltepunkt setzen und löschen - x x - Nächste Anweisung setzen - x x - Aufrufliste lesen - - - x Einzelzyklus - x - - Ablaufkontrolle einschalten - x x - Start \/ Stop - x - - Reset - x - - Retain-Variablen wiederherstellen - x - - Retain-Variablen speichern - - - x PLCShell Aktuell wird nur das Recht Ändern ausgewertet. Das heißt, nur wenn an eine Benutzergruppe das Recht Ändern vergeben wurde, können auch PLC-Shell-Kommandos ausgeführt werden. RemoteConnections Unter diesem Knotenpunkt können weitere externe Verbindungen zur Steuerung konfiguriert werden. Aktuell kann hier der Zugriff auf den OPCUA-Server konfiguriert werden. Settings Dabei handelt es sich um den Onlinezugriff auf die Konfigurationseinstellungen einer Steuerung. Security Settings : Der Zugriff zum Ändern der Sicherheitseinstellungen wird per Default nur dem Administrator gewährt. UserManagement Dabei handelt es sich um den Onlinezugriff auf die Benutzerverwaltung einer Steuerung. Sowohl der lesende als auch schreibende Zugriff wird per Default nur dem Administrator gewährt. Access Rights : Wenn dieses Objekt selektiert ist, können im Rechte -Fenster Berechtigungen auf der Rechteverwaltung konfiguriert werden. Das heißt, es kann konfiguriert werden, welche Benutzergruppe die Rechteverwaltung grundsätzlich lesen darf, und welche Benutzergruppe die Rechteverwaltung auch ändern darf. Groups : Für jede Benutzergruppe der Gerätebenutzerverwaltung wird automatisch ein eigenes Objekt erzeugt und unter Groups angezeigt. Wenn ein Benutzergruppen-Objekt selektiert ist, können die Berechtigungen auf der Benutzergruppe konfiguriert werden. Das heißt, es kann konfiguriert werden, welche Benutzergruppe die Benutzergruppe lesen oder ändern darf, beispielsweise neue Benutzer der Benutzergruppe hinzufügen darf. Standardmäßig sind für folgende Benutzergruppen Objekte vorhanden: Administrator Developer Service Watch Damit können abgestufte bzw. eingeschränkte Administratorgruppen eingerichtet werden. So kann beispielsweise eine Visualisierungs-Administratorgruppe eingerichtet werden, die der Visualisierungs-Benutzergruppe nur bestehende Benutzer hinzufügen kann, aber keine neuen Benutzer anlegen, oder die Passwörter bestehender Benutzer ändern kann . Users : Wenn dieses Objekt selektiert ist, können die Berechtigungen der Benutzergruppe auf die Benutzer konfiguriert werden. Das heißt, es kann konfiguriert werden, welche Benutzergruppe Benutzer lesen, ändern oder hinzufügen darf, beispielsweise neue Benutzer anlegen darf. Für weitere Informationen siehe: Gerätebenutzerverwaltung handhabenX509 Hierüber wird der Onlinezugriff auf die X.509 Zertifikate gesteuert. Hierbei werden 2 Arten von Zugriffen unterschieden: Lesen ( Ansehen ) Schreiben ( Ändern ) Jede einzelne Operation ist dabei jeweils einem dieser beiden Zugriffsrechte zugeordnet. Jede Operation wird hierbei als Unterobjekt unter X509 eingehängt. Daher kann nun der Zugriff pro Operation nochmals feiner unterteilt werden. Dateisystemobjekte → \/ Unter dem Dateisystemobjekt „ \/ “ werden alle Ordner aus dem Ausführungspfad der Steuerung eingehängt. Damit können Sie spezifische Rechte jedem Ordner des Dateisystems vergeben. " }, 
{ "title" : "Registerkarte: Benutzer und Gruppen ", 
"url" : "_cds_edt_device_users_and_groups.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Benutzer und Gruppen ", 
"snippet" : "Empfehlungen zur Datensicherheit Um das Risiko von Datensicherheitsverletzungen zu minimieren, empfehlen wir die folgenden organisatorischen und technischen Maßnahmen für das System, auf dem Ihre Applikationen laufen: Vermeiden Sie soweit als möglich, die SPS und Steuerungsnetzwerke offenen Netzwerk...", 
"body" : "Empfehlungen zur Datensicherheit Um das Risiko von Datensicherheitsverletzungen zu minimieren, empfehlen wir die folgenden organisatorischen und technischen Maßnahmen für das System, auf dem Ihre Applikationen laufen: Vermeiden Sie soweit als möglich, die SPS und Steuerungsnetzwerke offenen Netzwerken und dem Internet auszusetzen. Verwenden Sie zum Schutz zusätzliche Sicherungsschichten wie ein VPN für Remote-Zugriffe und installieren Sie Firewall-Mechanismen. Beschränken Sie den Zugriff auf autorisierte Personen und ändern Sie eventuell vorhandene Standardpasswörter bei der ersten Inbetriebnahme sowie in regelmäßigen Abständen. In dieser Registerkarte des generischen Geräteeditors bearbeiten Sie die Gerätebenutzerverwaltung des Steuerungsgeräts. Abhängig davon wie es vom Gerät unterstützt wird, können Sie Benutzerkonten und Benutzergruppen definieren. In Kombination mit der Konfiguration auf der Registerkarte Zugriffsrechte steuern Sie damit den Zugriff auf Steuerungsobjekte und Dateien zur Laufzeit. Voraussetzungen: Die Steuerung hat eine Benutzerverwaltung und erlaubt deren Bearbeitung. Sie haben Zugangsdaten, um sich auf der Steuerung einloggen zu können. Es ist möglich, Benutzerkonto-Definitionen aus der Projektbenutzerverwaltung in die Gerätebenutzerverwaltung zu übernehmen (siehe unten, Schaltfläche Importieren ). Benutzer In Baumstruktur werden alle aktuell definierten Benutzer und darunter ihre Mitgliedschaften zu den Benutzergruppen aufgelistet. Hinzufügen Öffnet den Dialog Benutzer hinzufügen zum Anlegen eines neuen Benutzerkontos. Die Beschreibung des Dialogs finden Sie weiter unten auf dieser Seite. Importieren Öffnet den Dialog Benutzer importieren Der Dialog zeigt alle in der Projektbenutzerverwaltung definierten Benutzerkonten. Wählen Sie die gewünschten Einträge aus und klicken Sie OK , um sie in die Gerätebenutzerverwaltung zu übernehmen. ACHTUNG: Die Passwörter werden NICHT übernommen! Bearbeiten Öffnet den Dialog Benutzer <Benutzername> bearbeiten Der Dialog entspricht dem Dialog Benutzer hinzufügen und Sie können darin die Einstellungen des Benutzerkontos verändern. Löschen Löscht das Konto des gerade selektierten Benutzers Gruppen In Baumstruktur werden alle aktuell definierten Gruppen und darunter die ihnen zugeordneten Benutzer aufgelistet. Hinzufügen Öffnet den Dialog Gruppe hinzufügen Definieren Sie einen neuen Gruppennamen. Wählen Sie aus der Liste der definierten Benutzer diejenigen, die der Gruppe angehören sollen. Bestätigen Sie die Auswahl mit OK . Die Gruppe erscheint im Baum. Importieren Öffnet den Dialog Benutzer importieren Der Dialog zeigt alle in der Projektbenutzerverwaltung definierten Benutzergruppen. Wählen Sie die gewünschten Einträge aus und klicken Sie OK , um sie in die Gerätebenutzerverwaltung zu übernehmen. Bearbeiten Öffnet den Dialog Gruppe <Gruppenname> bearbeiten Der Dialog entspricht dem Dialog Gruppe hinzufügen und Sie können darin die Gruppendefinition verändern. Löschen Löscht die gerade selektierte Gruppe Dialog ‚Benutzer hinzufügen‘ Name Name des neuen Benutzers Standardgruppe Auswahlliste mit allen konfigurierten Benutzergruppen Jeder Benutzer muss mindestens einer Gruppe angehören. Sie definieren diese hier als „Standardgruppe“. Passwort Passwort bestätigen Passwortstärke Passwortsicherheit in Stufen von Sehr schwach bis Sehr gut Passwort verbergen : Das Passwort wird bei der Eingabe nur mit Sternchen „*“ dargestellt. Passwort kann vom Benutzer geändert werden Passwort muss beim ersten Einloggen geändert werden Passwortrichtlinie Bei der Eingabe des neuen Passworts werden die geltenden, aber noch nicht eingehaltenen Regeln rot angezeigt. Erst wenn alle Regeln der Passwortrichtlinie erfüllt sind, kann der Dialog mit einem Klick auf die Schaltfläche OK bestätigt werden. Für weitere Informationen zur Laufzeitsystem-Passwortrichtlinie siehe: Tabelle 34, „" }, 
{ "title" : "Werkzeugleiste der Registerkarte ", 
"url" : "_cds_edt_device_users_and_groups.html#UUID-3317c99f-0df2-8051-6bf2-9a5235658be0_UUID-bf0ecbfd-1dbd-5ac2-0f81-c00318625768", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Benutzer und Gruppen \/ Werkzeugleiste der Registerkarte ", 
"snippet" : "Synchronisierung Schaltet die Synchronisierung zwischen Editor und Benutzerverwaltung auf dem Gerät ein und aus. Wenn die Schaltfläche nicht „gedrückt“ ist, ist der Editor leer, oder enthält eine Konfiguration, die Sie von der Festplatte geladen haben. Wenn Sie die Synchronisierung einschalten, währ...", 
"body" : " Synchronisierung Schaltet die Synchronisierung zwischen Editor und Benutzerverwaltung auf dem Gerät ein und aus. Wenn die Schaltfläche nicht „gedrückt“ ist, ist der Editor leer, oder enthält eine Konfiguration, die Sie von der Festplatte geladen haben. Wenn Sie die Synchronisierung einschalten, während der Editor eine noch nicht mit dem Gerät synchronisierte Benutzerkonfiguration enthält, erhalten Sie zunächst eine Abfrage, was mit dem Editorinhalt geschehen soll. Die Optionen: Vom Gerät hochladen und den Inhalt im Editor überschreiben : Die auf dem Gerät vorliegende Konfiguration wird in den Editor geladen und überschreibt den aktuellen Inhalt. Inhalt des Editors auf das Gerät laden und dort die Benutzerverwaltung überschreiben : Die im Editor enthaltene Konfiguration wird auf das Gerät übertragen und dort wirksam. Importieren von Festplatte Wenn Sie die Schaltfläche in der Registerkarte Benutzer und Gruppen klicken, um eine Gerätebenutzerverwaltungsdatei *.dum2 zu importieren, erscheint der Standarddialog zum Auswählen einer Gerätebenutzerverwaltungsdatei von der Festplatte. Nach Auswahl der Datei öffnet sich der Dialog Passwort eingeben . Sie müssen das Passwort eingeben, das beim Exportieren der Datei vergeben wurde. Damit wird dann die Benutzerverwaltung aktiviert. Hinweis: Vor V3.5 SP16 wurde der Dateityp Gerätebenutzerverwaltungsdateien (*.dum) verwendet, der noch keine Verschlüsselung erforderte. Wenn Sie die Schaltfläche in der Registerkarte Zugriffsrechte klicken, um eine Geräterechteverwaltungsdatei (*.drm) zu importieren, öffnet sich der Standarddialog zum Auswählen einer entsprechenden Datei von der Festplatte. Die bestehende Konfiguration im Dialog wird durch die importierte Datei überschrieben. Exportieren auf Festplatte Wenn Sie die Schaltfläche in der Registerkarte Benutzer und Gruppen klicken, erscheint zunächst der Dialog Passwort eingeben zur Vergabe eines Passworts für die Gerätebenutzerverwaltungsdatei. Beachten Sie: Dieses Passwort muss später bei einem Import dieser Datei wieder eingegeben werden, um diese Benutzerverwaltung auf der Steuerung zu aktivieren.. Nach Schließen des Dialogs zur Passwortvergabe öffnet sich der Standarddialog zum Auswählen und Importieren einer Benutzerverwaltungskonfiguration von der Festplatte. Der Dateityp ist in diesem Fall Gerätebenutzerverwaltungsdateien (*.dum2) (Device User Management). Hinweis: Vor V3.5 SP16 wurde der Dateityp Gerätebenutzerverwaltungsdateien (*.dum) verwendet, der noch keine Verschlüsselung erforderte. Wenn Sie die Schaltfläche in der Registerkarte Zugriffsrechte klicken, ist der Dateityp Geräterechteverwaltungsdateien (*.drm) (Device Rights Management). In diesem Fall muss vor der Ablage kein Passwort für die Datei vergeben werden. Gerätebenutzer Benutzername des gerade auf dem Gerät eingeloggten Benutzers " }, 
{ "title" : "Registerkarte: Symbolrechte ", 
"url" : "_cds_edt_device_symbol_rights.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Symbolrechte ", 
"snippet" : "In dieser Registerkarte des generischen Geräteeditors definieren Sie das Zugriffsrecht verschiedener Benutzergruppen (Clients) auf die einzelnen Symbolgruppen, die in der Steuerung verfügbar sind. Für weitere Informationen siehe: Symbolkonfiguration Voraussetzung: Auf dem Steuerungsgerät muss eine B...", 
"body" : "In dieser Registerkarte des generischen Geräteeditors definieren Sie das Zugriffsrecht verschiedener Benutzergruppen (Clients) auf die einzelnen Symbolgruppen, die in der Steuerung verfügbar sind. Für weitere Informationen siehe: Symbolkonfiguration Voraussetzung: Auf dem Steuerungsgerät muss eine Benutzerverwaltung eingerichtet sein. Auf die Steuerung wurde eine Applikation geladen, für die im CODESYS -Projekt Symbolgruppen definiert wurden. Sie haben Zugangsdaten für das Einloggen auf der Steuerung. Im Fenster Symbolgruppen sind unterhalb des Knotens Application alle Symbolgruppen aufgelistet, deren Definition mit der Applikation mit auf die Steuerung geladen wurde. Im Fenster Rechte erscheinen in einer Tabelle die in der Benutzerverwaltung der Steuerung definierten Benutzergruppen. Wenn eine Symbolgruppe selektiert ist, sehen Sie das Zugriffsrecht der jeweiligen Benutzergruppe auf die Symbole dieser Gruppe. : Zugriff erlaubt, : Zugriff nicht erlaubt. Sie können das Zugriffsrecht über einen Doppelklick auf das Symbol ändern. Über die Schaltfläche kann die aktuelle Zugriffskonfiguration in eine xml-Datei gespeichert werden. Der Dateityp ist Gerätesymbolverwaltungsdateien (*.dsm) . Über die Schaltfläche können Sie eine solche Datei wieder von der Festplatte einlesen. " }, 
{ "title" : "Registerkarte: Softwaremetriken zur Bestimmung der Lizenz ", 
"url" : "_cds_edt_device_licensed_software_metrics.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Softwaremetriken zur Bestimmung der Lizenz ", 
"snippet" : "Eine Metrik ist in diesem Umfeld der \"Wert\" (Anzahl) der für die Lizenzberechnung relevanten Einheiten. Abhängig vom Produkt kann dies beispielsweise die Größe des Benutzercodes in Bytes oder die Anzahl der Achsen, der E\/A-Kanäle oder der Feldbus-Instanzen sein. Die Registerkarte des Geräteeditors z...", 
"body" : "Eine Metrik ist in diesem Umfeld der \"Wert\" (Anzahl) der für die Lizenzberechnung relevanten Einheiten. Abhängig vom Produkt kann dies beispielsweise die Größe des Benutzercodes in Bytes oder die Anzahl der Achsen, der E\/A-Kanäle oder der Feldbus-Instanzen sein. Die Registerkarte des Geräteeditors zeigt in einer Baumstruktur die für die Applikation vorliegenden Metriken an. Damit können Sie die aktuell gemessenen Werte einsehen und kontrollieren, ob nicht mehr Code auf eine Steuerung geladen wird, als die Lizenz erlaubt. Die Lizenz wird pro Steuerung erteilt und befindet sich deshalb auf der Steuerung. Dort erfolgt auch die Lizenzprüfung. Die Metriken werden während des Downloads auf die Steuerung übertragen. Sie werden aktualisiert, wenn Sie den Befehl Erstellen → Code erzeugen für die aktive Applikation ausführen. Aktuelle Metriken vom Gerät lesen Ermittelt und überträgt die Metriken von der Steuerung und zeigt sie unter der Spalte Wert auf Gerät an. Code erzeugen, um Metriken zu berechnen Zur Berechnung der Metriken muss der Code erzeugt werden. Lizenzen anzeigen Öffnet den Dialog Lizenzen Der Dialog zeigt die für das Projekt erforderliche Lizenz. Der Befehl Alles im Store öffnen und Dialog schließen öffnet das vorgeschlagene Produkt im CODESYS Store International . Wenn Sie das Produkt im CODESYS Store North America anzeigen wollen, müssen Sie in den CODESYS -Optionen den Store North America auswählen. Metrik Metriktypen pro Applikation Wert im Projekt Anzahl der verwendeten Tags im Entwicklungssystem. Der Wert wird während der Codegenerierung (Befehl Erstellen → Code erzeugen ) gemessen. Details zur Berechnung finden Sie im Abschnitt Berechnung der WerteHinweis: Wenn Sie die Übersetzungsinformation der Applikation löschen, werden die Werte auf 0 zurückgesetzt. Max. erlaubt durch die Lizenz Erlaubte Maximalwerte pro Applikation gemäß der Lizenz auf der Steuerung Wert auf Gerät Tatsächlich gemessener Wert, ausgelesen aus der Steuerung Hinweis: Um diesen Werte zu ermitteln, muss die Kommunikation funktionieren. " }, 
{ "title" : "Berechnung der Werte ", 
"url" : "_cds_edt_device_licensed_software_metrics.html#UUID-f3be4987-31a8-2f1c-3e97-bb89ff6c8b60_section-idm4525765148713633834737187389", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Softwaremetriken zur Bestimmung der Lizenz \/ Berechnung der Werte ", 
"snippet" : "Metrik Wertermittlung Größe des Benutzercodes Wert in Bytes Es wird nur vom Anwender programmierter Code (Implementierung) bewertet. Code, der nicht mit dem IEC-Compiler kompiliert wurde, wird nicht bewertet. Die Anzahl und Größe von Variablen in der Deklaration ist nicht relevant. Vom Anwender entw...", 
"body" : "Metrik Wertermittlung Größe des Benutzercodes Wert in Bytes Es wird nur vom Anwender programmierter Code (Implementierung) bewertet. Code, der nicht mit dem IEC-Compiler kompiliert wurde, wird nicht bewertet. Die Anzahl und Größe von Variablen in der Deklaration ist nicht relevant. Vom Anwender entwickelte IEC-Bibliotheken werden bei der Codegröße bewertet. Standard- und Systembibliotheken und Kommunikationsstacks der CODESYS GmbH werden nicht bewertet. Task Group Assignment Für die Konfiguration von IEC-Taskgruppen in der Taskkonfiguration wird in vielen Fällen eine sogenannten „Task Group Assignment“-Lizenz benötigt, wenn die IEC-Tasks auf verschiedenen CPU-Kernen ausgeführt werden. nein : Bei folgenden Konfigurationen wird keine Lizenz benötigt: Eine konfigurierte Taskgruppe mit der Eigenschaft Fixed Pinned Fixed Core Sequential Pinnend (nur eine IEC Task!) Mehrere konfigurierte Taskgruppen, die alle auf demselben CPU-Kern laufen ja : Bei folgenden Konfigurationen wird eine Lizenz benötigt: Eine konfigurierte Taskgruppe mit der Eigenschaft Free floating Sequential Pinnend (mehrere IEC-Tasks) Mehrere konfigurierte Taskgruppen mit der Eigenschaft Free floating Sequential Pinnend Mehrere konfigurierte Taskgruppen, die alle auf unterschiedlichen CPU-Kernen laufen Feldbus , E\/A-Kanäle Anzahl der gemappten Kanäle mit Basisdatentyp ( BOOL , INT , REAL , ...). Beim Mapping von komplexen Datentypen ( STRUCT , ARRAY ) wird die Anzahl der Subelemente mit Basisdatentyp gezählt. Wenn Sie die Option Variablen immer aktualisieren aktiviert haben, werden alle Kanäle bei der Berechnung berücksichtigt, unabhängig davon, ob sie einer konkreten IEC-Variable zugeordnet sind oder nicht. Instanzen von CANopen, Modbus, PROFIBUS Verwendete Feldbusstack-Instanzen dieses Typs Bei Modbus werden Instanzen der Modus-Clients für RTU und TCP gezählt. Ein Master\/Controller oder ein Slave\/Gerät wird als eine Instanz in der Gerätekonfiguration gezählt. Die Geräte, die im Gerätebaum mit diesen Mastern\/Slaves verknüpft sind, werden nicht gezählt. Diese werden über die E\/A-Kanäle gezählt. Feldbus-Gateways werden ebenfalls als Instanz gezählt (Ausnahme:  CANopen-Gateway). Instanzen von EtherCAT, EtherNet\/IP, PROFINET, SAE J1939 Anzahl der Visualisierungstags siehe Visualisierung - Lizenzierung SoftMotion siehe SoftMotion - Lizenzierung Kommunikation siehe Kommunikation - Lizenzierung Informationen zu den Lizenzpaketen der applikationsbasierten Lizenzen finden Sie im CODESYS Store . " }, 
{ "title" : "Zusätzliche Lizenzen ", 
"url" : "_cds_edt_device_licensed_software_metrics_list.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Softwaremetriken zur Bestimmung der Lizenz \/ Zusätzliche Lizenzen ", 
"snippet" : "Auf der Registerkarte Softwaremetriken zur Bestimmung der Lizenz werden nur die applikationsbasierten Lizenzen angezeigt. Möglicherweise benötigen Sie für Ihre Applikation weitere Lizenzen, die in dieser Übersicht nicht enthalten sind. Eine Übersicht der applikationsbasierten Lizenzen finden Sie im ...", 
"body" : "Auf der Registerkarte Softwaremetriken zur Bestimmung der Lizenz werden nur die applikationsbasierten Lizenzen angezeigt. Möglicherweise benötigen Sie für Ihre Applikation weitere Lizenzen, die in dieser Übersicht nicht enthalten sind. Eine Übersicht der applikationsbasierten Lizenzen finden Sie im CODESYS Store . Folgende Listen geben Ihnen einen Überblick über alle SL-Lizenzen, die nicht in der Registerkarte Softwaremetriken zur Bestimmung der Lizenz angezeigt werden. SoftMotion CODESYS SoftMotion Light CODESYS Depictor Visulisierung CODESYS HMI SL Unlimited variables for CODESYS HMI SL Bibliotheken Object Oriented Alarming Library (100) Object Oriented Alarming Library (200) MsSQL Library SL MySQL Library SL BE KOLLMORGEN s300s700 CAN Dweet Pro Library SL STweep Formatter for CODESYS Janz Tec MQTT library for CODESYS SL JSON HTTP Client Library CODESYS IIoT Libraries SL Python Editor Feldbusse HVAC KNX SL CODESYS BACnet SL CODESYS DNP3 SL CODESYS KNX SL Universal Modbus Client Master SL Protokolle IEC 60870-5-104 Server CODESYS OPC DA Server SL CODESYS IO-Link SL Engineering CODESYS Professional Developer Edition ( CODESYS Static Analysis , CODESYS Test Manager , CODESYS Profiler , CODESYS UML , CODESYS Git , CODESYS SVN ) CODESYS Redundancy SL Safety CODESYS Safety for EtherCAT Safety Module SL " }, 
{ "title" : "Registerkarte: Taskaufstellung ", 
"url" : "_cds_edt_device_task_deployment.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Taskaufstellung ", 
"snippet" : "Dieser Unterdialog des Geräteeditors zeigt eine Tabelle der Ein- und Ausgänge sowie ihre Zuordnung zu den definierten Tasks. Die Information ist erst sichtbar, nachdem für die Applikation Code erzeugt wurde. Sie dient der Fehlersuche, weil sie aufzeigt, wo Eingänge oder Ausgänge in mehreren Tasks mi...", 
"body" : "Dieser Unterdialog des Geräteeditors zeigt eine Tabelle der Ein- und Ausgänge sowie ihre Zuordnung zu den definierten Tasks. Die Information ist erst sichtbar, nachdem für die Applikation Code erzeugt wurde. Sie dient der Fehlersuche, weil sie aufzeigt, wo Eingänge oder Ausgänge in mehreren Tasks mit unterschiedlichen Prioritäten verwendet werden. Mehrfache Verwendung kann zu undefinierten Werten durch Überschreiben führen. E\/A-Aufstellung für Tasks (1) E\/A-Kanäle (2) Alle Eingänge und Ausgänge der angebundenen Geräte. Die Darstellung entspricht der im Dialog E\/A-Abbild des Geräteeditors. Durch einen Doppelklick auf einen Eingang bzw. Ausgang können Sie den zugehörigen E\/A-Abbild-Editor öffnen. <Task-Name> (3) Für jede in der Taskkonfiguration definierte Task erscheint eine Spalte. Im Titel stehen Taskname und Priorität. Von der ersten zur letzten Spalte sinkt die Priorität der Tasks. Für Eingänge und Ausgänge, die durch eine Task geschrieben oder gelesen werden, erscheint ein rotes Kreuz im Kästchen: . Zusätzlich ist an diesen Stellen die Task, die in den SPS-Einstellungen des Geräteeditors als Buszyklus-Task definiert ist, mit einem blauen Doppelpfeil-Symbol gekennzeichnet. Nach einem Mausklick auf die Titelzelle werden nur die E\/As angezeigt, welche dieser Task zugeordnet sind. Nach einem Mausklick auf die Zelle E\/A-Kanäle werden danach wieder alle Kanäle eingeblendet. " }, 
{ "title" : "Registerkarte: Status ", 
"url" : "_cds_edt_device_status.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Status ", 
"snippet" : "In dieser Registerkarte des generischen Geräteeditors erscheinen Status-Informationen, beispielsweise „Running“ oder „Stopped“, und spezifische Diagnosemeldungen aus dem jeweiligen Gerät, auch zur verwendeten Karte und dem internen Bussystem....", 
"body" : "In dieser Registerkarte des generischen Geräteeditors erscheinen Status-Informationen, beispielsweise „Running“ oder „Stopped“, und spezifische Diagnosemeldungen aus dem jeweiligen Gerät, auch zur verwendeten Karte und dem internen Bussystem. " }, 
{ "title" : "Registerkarte: Information ", 
"url" : "_cds_edt_device_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Gerät, und Generischer Geräteeditor \/ Registerkarte: Information ", 
"snippet" : "In dieser Registerkarte des generischen Geräteeditors erscheinen allgemeine Informationen, die aus der Gerätebeschreibungsdatei stammen: Name, Hersteller, Kategorien, Version, Bestellnummer, Beschreibung, gegebenenfalls eine Abbildung....", 
"body" : "In dieser Registerkarte des generischen Geräteeditors erscheinen allgemeine Informationen, die aus der Gerätebeschreibungsdatei stammen: Name, Hersteller, Kategorien, Version, Bestellnummer, Beschreibung, gegebenenfalls eine Abbildung. " }, 
{ "title" : "Objekt: GVL – Globale Variablenliste ", 
"url" : "_cds_obj_gvl.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: GVL – Globale Variablenliste ", 
"snippet" : "GVL Symbol: Eine globale Variablenliste dient der Deklaration, der Bearbeitung und der Anzeige von globalen Variablen . Sie fügen eine GVL mit dem Befehl Projekt → Objekt hinzufügen → Globale Variablenliste der Applikation oder dem Projekt hinzu. Wenn Sie eine GVL unter einer Applikation im Geräteba...", 
"body" : "GVL Symbol: Eine globale Variablenliste dient der Deklaration, der Bearbeitung und der Anzeige von globalen Variablen . Sie fügen eine GVL mit dem Befehl Projekt → Objekt hinzufügen → Globale Variablenliste der Applikation oder dem Projekt hinzu. Wenn Sie eine GVL unter einer Applikation im Gerätebaum einfügen, sind die Variablen innerhalb dieser Applikation gültig. Wenn Sie eine GVL in der Ansicht POUs hinzufügen, sind die Variablen projektweit gültig. Sie können im Dialog Tools → Optionen in den Kategorien Deklarationseditor und Texteditor Einstellungen für den Editor des Objekts vornehmen. Wenn das Zielsystem die Netzwerkfunktionalität unterstützt, können Sie die Variablen einer GVL in Netzwerkvariablen umwandeln, und somit für den Datenaustausch mit anderen Geräten im Netzwerk verwenden. Dazu müssen Sie entsprechende Eigenschaften für die GVL im Dialog Eigenschaften , Registerkarte Netzwerkvariablen definieren. " }, 
{ "title" : "Objekt: GVL – Globale Variablenliste (tasklokal) ", 
"url" : "_cds_obj_gvl_tasklocal.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: GVL – Globale Variablenliste (tasklokal) ", 
"snippet" : "GVL – Globale Variablenliste (tasklokal) Symbol: Eine globale Variablenliste (tasklokal) dient der Deklaration, der Bearbeitung und der Anzeige von globalen Variablen. Bei dieser speziellen globalen Variablenliste können die darin deklarierten Variablen nur von einer Task geschrieben werden. Alle an...", 
"body" : "GVL – Globale Variablenliste (tasklokal) Symbol: Eine globale Variablenliste (tasklokal) dient der Deklaration, der Bearbeitung und der Anzeige von globalen Variablen. Bei dieser speziellen globalen Variablenliste können die darin deklarierten Variablen nur von einer Task geschrieben werden. Alle anderen Tasks können nur lesend darauf zugreifen. Dadurch wird sichergestellt, dass die Werte dieser Variablen auch bei Projekten mit Multicore immer konsistent sind. Für weitere Informationen siehe: Tasklokale Variablen verwendenDas Objekt ist ab Compilerversion 3.5.13.0 und entsprechender Gerätebeschreibung verfügbar. Task mit Schreibzugriff Task, die exklusive Schreibrechte auf die Variablen besitzt " }, 
{ "title" : "Objekt: Netzwerkvariablen-Liste (Sender) ", 
"url" : "_cds_obj_nvl_send.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Netzwerkvariablen-Liste (Sender) ", 
"snippet" : "Netzwerkvariablen-Liste (Sender) Symbol: Eine Netzwerkvariablen-Liste (Sender) dient der Deklaration und Auflistung der globalen Variablen, die an Netzwerkvariablen-Listen (Empfänger) anderer Geräte oder Projekte des Netzwerks gesendet werden sollen. Das Objekt wird im Gerätebaum mit dem Befehl Obje...", 
"body" : "Netzwerkvariablen-Liste (Sender) Symbol: Eine Netzwerkvariablen-Liste (Sender) dient der Deklaration und Auflistung der globalen Variablen, die an Netzwerkvariablen-Listen (Empfänger) anderer Geräte oder Projekte des Netzwerks gesendet werden sollen. Das Objekt wird im Gerätebaum mit dem Befehl Objekt hinzufügen → Netzwerkvariablenliste (Sender) einer Applikation hinzugefügt. Die Protokoll- und Übertragungsparameter können Sie im Dialog Netzwerkvariablen-Liste (Sender) hinzufügen oder im Dialog Eigenschaften des Objekts in der Registerkarte Netzwerkvariablen konfigurieren. Für weitere Informationen siehe: Konfigurieren eines Netzwerkvariablen-AustauschsDialog: Netzwerkvariablen-Liste (Sender) hinzufügen Funktion : In diesem Dialog definieren Sie die Netzwerkeigenschaften für die Sender-NVL. Wenn Sie den Dialog schließen, fügt CODESYS die Sender-NVL der Applikation im Gerätebaum hinzu. Aufruf : Befehl Projekt → Objekt hinzufügen → Netzwerkvariablen-Liste (Sender) , wenn im Gerätebaum das Applikationsobjekt selektiert ist Der Dialog entspricht der Registerkarte Netzwerkvariablen im Dialog Eigenschaften des Objekts Netzwerkvariablen-Liste. " }, 
{ "title" : "Objekt: Netzwerkvariablen-Liste (Empfänger) ", 
"url" : "_cds_obj_nvl_receive.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Netzwerkvariablen-Liste (Empfänger) ", 
"snippet" : "Netzwerkvariablen-Liste (Empfänger) Symbol: Das Objekt dient der Auflistung der empfangenen Netzwerkvariablen und der Anzeige der Informationen: Netzwerk- und Übertragungsinformationen und Sender. Einer Applikation fügen Sie das Objekt mit dem Befehl Objekt hinzufügen → Netzwerkvariablenliste (Empfä...", 
"body" : "Netzwerkvariablen-Liste (Empfänger) Symbol: Das Objekt dient der Auflistung der empfangenen Netzwerkvariablen und der Anzeige der Informationen: Netzwerk- und Übertragungsinformationen und Sender. Einer Applikation fügen Sie das Objekt mit dem Befehl Objekt hinzufügen → Netzwerkvariablenliste (Empfänger) hinzu. Die Netzwerkvariablen-Liste (Empfänger) listet die empfangenen Netzwerkvariablen auf. Diese empfangenen Netzwerkvariablen wurden in der als Sender konfigurierten Netzwerkvariablen-Liste (Sender) eines anderen Geräts oder Projekts deklariert. Sie können die Netzwerkvariablen im Editor des Objekts nicht verändern. Für weitere Informationen siehe: Konfigurieren eines Netzwerkvariablen-AustauschsDer Editor des Objekts besteht aus den 2 Bereichen: Informationen zum Sender und Übertragungsprotokoll der Liste Auflistung der Deklarationen der Netzwerkvariablen " }, 
{ "title" : "Dialog: Netzwerkvariablen-Liste (Empfänger) hinzufügen ", 
"url" : "_cds_obj_nvl_receive.html#UUID-25c4fc5e-603f-f0b5-4a4f-e0f17cb6fe13_id_ffc4dc53ee3e2727c0a8640e01e914d6_id_656884cf32951609c0a8640e00d18f44", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Netzwerkvariablen-Liste (Empfänger) \/ Dialog: Netzwerkvariablen-Liste (Empfänger) hinzufügen ", 
"snippet" : "Funktion : Der Dialog definiert die Empfänger-NVL zu einer Sender-NVL und fügt die Empfänger-NVL dem Applikationsobjekt im Projektnavigator hinzu. Aufruf : Menübefehl Projekt → Objekt hinzufügen → Netzwerkvariablen-Liste (Empfänger) , wenn Sie das Applikationsobjekt selektiert haben Task Task der ak...", 
"body" : "Funktion : Der Dialog definiert die Empfänger-NVL zu einer Sender-NVL und fügt die Empfänger-NVL dem Applikationsobjekt im Projektnavigator hinzu. Aufruf : Menübefehl Projekt → Objekt hinzufügen → Netzwerkvariablen-Liste (Empfänger) , wenn Sie das Applikationsobjekt selektiert haben Task Task der aktuellen Applikation, die die zu empfangenen Variablen kontrolliert Sender Auswahlliste Zur Verfügung stehende Sender-NVLs eines anderen Geräts des Projekts Import aus Datei : Notwendig, wenn die gewünschte Sender-NVL in einem anderen Projekt definiert ist Dazu muss im anderen Projekt die gewünschte Sender-NVL im Eigenschaftendialog der NVL in der Registerkarte Verknüpfung mit Datei als GVL export file *.gvl erzeugt worden sein. Import aus Datei Angabe des Dateinamens im Format GVL export file *.gvl , wenn Sie bei Sender Import aus Datei ausgewählt haben " }, 
{ "title" : "Objekt: Persistente Variablenliste ", 
"url" : "_cds_obj_gvl_persistent.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Persistente Variablenliste ", 
"snippet" : "Persistente Variablenliste Symbol: Das Objekt enthält die Deklaration von globalen persistenten Variablen im Deklarationsabschnitt VAR_GLOBAL PERSISTENT RETAIN .. END_VAR . Die Variablen werden in einem speziellen nichtflüchtigen Speicher gesichert. Der Persistenzeditor stellt die Variablen wie übli...", 
"body" : "Persistente Variablenliste Symbol: Das Objekt enthält die Deklaration von globalen persistenten Variablen im Deklarationsabschnitt VAR_GLOBAL PERSISTENT RETAIN .. END_VAR . Die Variablen werden in einem speziellen nichtflüchtigen Speicher gesichert. Der Persistenzeditor stellt die Variablen wie üblich als Liste dar. Die dargestellte Liste wirkt sich nicht auf das Persistenzverhalten der Variablen aus, sondern nur die intern im Prozessabbild abgelegte Liste. Die Liste dort enthält alle jemals deklarierten Variablen in der Reihenfolge, wie sie historisch deklariert wurden. Variablen, die Sie entfernt haben, werden dort mit einem Platzhalter ersetzt und bestehen als Lücke weiter. Der Deklarationsabschnitt kann außerdem Instanzpfade enthalten, die auf lokal deklarierte persistente Variablen verweisen und mit dem Befehl Deklarationen → Alle Instanzpfade hinzufügen erzeugt wurden. Vor der Entscheidung, auf welchem Weg Sie für eine Applikation Persistenz einrichten, ist es hilfreich, die in Kapitel Datenpersistenz beschriebenen Anwendungsfälle zu kennen. Außerdem ist es hilfreich, die Mechanismen von persistenten Variablen, Retain-Variablen, Variablen des Persistence Managers und Rezepturvariablen unterscheiden zu können. " }, 
{ "title" : "Befehle ", 
"url" : "_cds_obj_gvl_persistent.html#UUID-f626a899-e7ba-9006-b7e2-0aca13999e74_id_cd97ea5ddcd609c0a8640e0075a8ef_id_4d7f128bb7520580c0a8646321d3f70d", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Persistente Variablenliste \/ Befehle ", 
"snippet" : "Im Persistenzeditors stehen folgende Befehle zur Verfügung: Befehl Deklarationen → Alle Instanzpfade hinzufügen Befehl Deklarationen → Liste neu ordnen und Lücken bereinigen...", 
"body" : "Im Persistenzeditors stehen folgende Befehle zur Verfügung: Befehl Deklarationen → Alle Instanzpfade hinzufügen Befehl Deklarationen → Liste neu ordnen und Lücken bereinigen " }, 
{ "title" : "Objekt: POU ", 
"url" : "_cds_f_obj_pou.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU ", 
"snippet" : "POU Symbol: Ein Objekt vom Typ POU ist eine Programm-Organisationseinheit (Programming Organization Unit) in einem CODESYS -Projekt. In POUs schreiben Sie Quellcode für Ihr Steuerungsprogramm. Es gibt folgende Typen von POUs: Programm Funktion Funktionsbaustein Sie fügen ein Objekt POU über den Befe...", 
"body" : "POU Symbol: Ein Objekt vom Typ POU ist eine Programm-Organisationseinheit (Programming Organization Unit) in einem CODESYS -Projekt. In POUs schreiben Sie Quellcode für Ihr Steuerungsprogramm. Es gibt folgende Typen von POUs: Programm Funktion Funktionsbaustein Sie fügen ein Objekt POU über den Befehl Projekt → Objekt hinzufügen im Gerätebaum oder in der Ansicht POUs ein. Beim Hinzufügen einer POU legen Sie den POU-Typ und die Implementierungssprache fest. Andere Programmierobjekte (Methode, Aktion, usw.) können Sie diesen Objekten wiederum als Objekte hinzufügen. POUs aufrufen Bestimmte POUs können andere POUs aufrufen. Rekursionen sind nicht erlaubt. Beim Aufruf von POUs über den Namensraum durchsucht CODESYS das Projekt nach der aufzurufenden POU gemäß folgender Reihenfolge: Aktuelle Applikation Bibliotheksverwalter der aktuellen Applikation Ansicht POUs Bibliotheksverwalter in der POUs -Ansicht Wenn Sie einen Programmierbaustein aufrufen, die mit gleichem Namen sowohl in einer in der Applikation verwendeten Bibliothek, als auch als Objekt in der Ansicht POUs existiert, gilt Folgendes: Es gibt keine Syntax, nach der Sie die POU in der Ansicht POUs nur über ihren Namen aufrufen können. In diesem Fall müssen Sie die betreffende Bibliothek vom Bibliotheksverwalter der Applikation in den Bibliotheksverwalter des Projekts (in der Ansicht POUs ) verschieben. Danach können Sie das POU-Objekt in der Ansicht POUs rein über seinen Namen aufrufen. Wenn Sie den Namensraum der Bibliothek hinzufügen, können Sie die POU der Bibliothek aufrufen. Der Begriff „POU“ wird in CODESYS auch für die POUs -Ansicht verwendet, in der CODESYS die projektweit gültigen Objekte verwaltet. " }, 
{ "title" : "Dialog: POU hinzufügen ", 
"url" : "_cds_f_obj_pou.html#UUID-187a911d-cff8-20fa-f0f6-6a96a4fbedb8_section-idm4612494359414432633791667085", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Dialog: POU hinzufügen ", 
"snippet" : "Funktion : Der Dialog dient der Konfiguration einer neuen POU im Sinne der Norm IEC 61131-3. Dies bedeutet, dass eine POU ein Programm, eine Funktion oder ein Funktionsbaustein sein kann. Aufruf : Menü Projekt → Objekt hinzufügen , Kontextmenü in Ansicht Geräte , wenn eine Applikation selektiert ist...", 
"body" : "Funktion : Der Dialog dient der Konfiguration einer neuen POU im Sinne der Norm IEC 61131-3. Dies bedeutet, dass eine POU ein Programm, eine Funktion oder ein Funktionsbaustein sein kann. Aufruf : Menü Projekt → Objekt hinzufügen , Kontextmenü in Ansicht Geräte , wenn eine Applikation selektiert ist, Kontextmenü in Ansicht POUs Name Name der POU Typ Programm Funktionsbaustein Erweitert : Angabe oder Auswahl eines Basis-Funktionsbausteins im Sinne der objektorientierten Programmierung Wird mit Schlüsselwort EXTENDS in der Funktionsbausteindeklaration angegeben Implementiert : Angabe oder Auswahl einer Schnittstelle im Sinne der objektorientierten Programmierung Wird mit Schlüsselwort IMPLEMENTS in der Funktionsbausteindeklaration angegeben Bei der Anlage der POU werden alle Methoden angelegt, die über die Schnittstelle definiert sind. Final : Abgeleiteter Zugriff ist nicht erlaubt. Das bedeutet, dass Sie den Funktionsbaustein nicht durch einen anderen Funktionsbaustein erweitern können. Dies ermöglicht optimierte Codegenerierung. Abstrakt : Kennzeichnet, dass der Funktionsbaustein eine fehlende oder unvollständige Implementierung hat und nicht instanziiert werden kann Abstrakte FBs dienen ausschließlich als Basis-Funktionsbausteine und die Implementierung erfolgt typischerweise in einem abgeleiteten FB. Wenn ein nicht-abstrakter Funktionsbaustein angelegt wird, der wiederum einen abstrakten Funktionsbaustein erweitert, werden sämtliche abstrakte Methoden des abstrakten Basis-Funktionsbausteins als (nicht-abstrakte) Methoden dem neuen Funktionsbaustein hinzugefügt. Zugriffsmodifizierer PUBLIC : Entspricht der Angabe keines Zugriffsmodifizierers INTERNAL : Der Zugriff auf den Funktionsbaustein ist auf den Namensraum (die Bibliothek) beschränkt. Methoden-Implementierungssprache : Wenn Sie die Option Implementiert ausgewählt haben, können Sie hier eine Implementierungssprache für alle Methodenobjekte auswählen, die CODESYS über die Implementierung der Schnittstelle erzeugt. Die Methoden-Implementierungssprache ist unabhängig von der Implementierungssprache des Funktionsbausteins. Funktion Hinweis: Nicht verfügbar, wenn in der Auswahlliste Implementierungssprache die Sprache Ablaufsprache (AS) ausgewählt ist. Rückgabetyp : Auswahlliste für den Datentyp des Rückgabewerts Implementierungssprache Auswahlliste für die Implementierungssprache der POU " }, 
{ "title" : "Objekt: Programm ", 
"url" : "_cds_obj_program.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Programm ", 
"snippet" : "Programm Ein Programm ist eine POU, die bei der Ausführung einen oder mehrere Werte liefert. Alle Werte bleiben nach einer Ausführung des Programms bis zur nächsten Ausführung erhalten. Die Aufrufreihenfolge der Programme innerhalb einer Applikation definieren Sie in Taskobjekten. Sie fügen der Appl...", 
"body" : "Programm searchresult_toplevel Ein Programm ist eine POU, die bei der Ausführung einen oder mehrere Werte liefert. Alle Werte bleiben nach einer Ausführung des Programms bis zur nächsten Ausführung erhalten. Die Aufrufreihenfolge der Programme innerhalb einer Applikation definieren Sie in Taskobjekten. Sie fügen der Applikation oder dem Projekt ein Programm über den Befehl Projekt → Objekt hinzufügen → POU hinzu. Im Gerätebaum und in der Ansicht POUs haben die Programm-POUs das Suffix (PRG) . Der Editor eines Programms besteht aus dem Deklarationsteil und dem Implementierungsteil. Die oberste Zeile des Deklarationsteils enthält folgende Deklaration: PROGRAM <program> " }, 
{ "title" : "Ein Programm aufrufen ", 
"url" : "_cds_obj_program.html#UUID-ad0a9eae-2290-5bff-bc9e-f203219c6d3b_id_f8163f81a1ed20cc0a8640e00f7941f_id_f8fc98ce4f67d6dbc0a8640e01e44c5e", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Programm \/ Ein Programm aufrufen ", 
"snippet" : "Programme und Funktionsbausteine können ein Programm aufrufen. In einer Funktion ist ein Programmaufruf nicht erlaubt. Von Programmen gibt es keine Instanzen. Wenn eine POU ein Programm aufruft und sich dadurch Werte des Programms verändern, bleiben diese Änderungen bis zum nächsten Programmaufruf e...", 
"body" : "Programme und Funktionsbausteine können ein Programm aufrufen. In einer Funktion ist ein Programmaufruf nicht erlaubt. Von Programmen gibt es keine Instanzen. Wenn eine POU ein Programm aufruft und sich dadurch Werte des Programms verändern, bleiben diese Änderungen bis zum nächsten Programmaufruf erhalten. Die Werte des Programms bleiben auch dann erhalten, wenn der erneute Aufruf durch eine andere POU erfolgt. Dies unterscheidet sich vom Aufruf eines Funktionsbausteins. Beim Funktionsbaustein-Aufruf ändern sich nur die Werte der jeweiligen Instanz des Funktionsbausteins. Die Änderungen sind nur zu beachten, wenn eine POU dieselbe Instanz erneut aufruft. Sie können für ein Programm die Eingabe- und\/oder Ausgabeparameter auch direkt beim Aufruf setzen. Syntax: <program>(<input variable> := <value>, <output value> => <value>): Wenn Sie einen Programmaufruf über die Eingabehilfe einfügen und dabei in der Eingabehilfe die Option Mit Argumenten einfügen aktiviert ist, fügt CODESYS dem Programmaufruf Eingabe- und\/oder Ausgabeparameter gemäß der Syntax zu. Beispiele Aufrufe: AWL: Mit Zuweisung der Parameter: ST: PLC_PRG()\nerg := PLC_PRG.out2; Mit Zuweisung der Parameter: PLC_PRG(in1:=2, out1=>erg); " }, 
{ "title" : "Objekt: Funktionsbaustein ", 
"url" : "_cds_obj_function_block.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Funktionsbaustein ", 
"snippet" : "Funktionsbaustein Ein Funktionsbaustein ist eine POU, die bei der Ausführung einen oder mehrere Werte liefert. Sie fügen das Objekt der Applikation oder dem Projekt über den Befehl Projekt → Objekt hinzufügen → POU hinzu. Im Gerätebaum oder in der Ansicht POUs haben Funktionsbaustein-POUs das Suffix...", 
"body" : "Funktionsbaustein Ein Funktionsbaustein ist eine POU, die bei der Ausführung einen oder mehrere Werte liefert. Sie fügen das Objekt der Applikation oder dem Projekt über den Befehl Projekt → Objekt hinzufügen → POU hinzu. Im Gerätebaum oder in der Ansicht POUs haben Funktionsbaustein-POUs das Suffix (FB) . Sie rufen einen Funktionsbaustein immer über eine Instanz auf, die eine Kopie des Funktionsbausteins ist. Der Editor eines Funktionsbausteins besteht aus dem Deklarationsteil und dem Implementierungsteil. Die Werte der Ausgabevariablen und der internen Variablen bleiben nach einer Ausführung bis zur nächsten erhalten. Dies bedeutet, dass der Funktionsbaustein bei mehrmaligem Aufruf mit denselben Eingabevariablen nicht unbedingt dieselben Ausgabewerte liefert. Zusätzlich zu der in der IEC 61131-3 beschriebenen Funktionalität können Sie Funktionsbausteine in CODESYS auch für folgende Funktionalitäten der objektorientierten Programmierung verwenden: Erweitern eines Funktionsbausteins Implementieren von Schnittstellen Methoden Eigenschaften Die oberste Zeile des Deklarationsteils enthält folgende Deklaration: FUNCTION_BLOCK <access specifier> <function block> \\| EXTENDS <function block> \\| IMPLEMENTS <comma-separated list of interfaces> " }, 
{ "title" : "Einen Funktionsbaustein aufrufen ", 
"url" : "_cds_obj_function_block.html#UUID-bd14b797-a7fe-0201-278a-491e9af37040_id_a70a3a130569cc4fc0a8640e01f8feef_id_fdfeb24e4f64721fc0a8640e01ba60f7", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Funktionsbaustein \/ Einen Funktionsbaustein aufrufen ", 
"snippet" : "Der Aufruf erfolgt immer über eine Instanz des Funktionsbausteins. Beim Aufruf eines Funktionsbausteins ändern sich nur die Werte der jeweiligen Instanz Deklaration der Instanz: <instance> : <function block>; Auf eine Variable des Funktionsbausteins greifen Sie im Implementierungsteil wie folgt zu: ...", 
"body" : "Der Aufruf erfolgt immer über eine Instanz des Funktionsbausteins. Beim Aufruf eines Funktionsbausteins ändern sich nur die Werte der jeweiligen Instanz Deklaration der Instanz: <instance> : <function block>; Auf eine Variable des Funktionsbausteins greifen Sie im Implementierungsteil wie folgt zu: <instance> . <variable> Beachten Sie Folgendes: Sie können nur auf Eingabe- und Ausgabevariablen eines Funktionsbausteins von außerhalb der Funktionsbaustein-Instanz zugreifen, nicht auf die internen Variablen. Der Zugriff auf eine Funktionsbaustein-Instanz ist auf den Baustein begrenzt, in der die Instanz deklariert ist, außer Sie haben die Instanz global deklariert. Sie können beim Aufruf der Instanz den Funktionsbausteinvariablen die gewünschten Werte zuweisen. Beispiel Zugriff auf Funktionsbausteinvariablen: Der Funktionsbaustein FB1 hat die Eingabevariable iVar1 vom Typ INT und die Ausgabevariable out1 . Im Folgenden wird die Variable iVar1 aus dem Programm Prog aufgerufen. PROGRAM Prog\nVAR\ninst1 : FB1;\nEND_VAR\n\ninst1.iVar1 := 33; (* FB1 is called and the value 33 is assigned to the variable iVar1 *)\n\ninst1(); (* FB1 is called, that's necessary for the following access to the output variable *)\n\nires := inst1.out1 (* the output variable out1 of the FB1 is read *) In FUP: Variablenwerte beim Aufruf zuweisen: In den textuellen Sprachen AWL und ST können Sie Werte beim Aufruf des Funktionsbausteins direkt an Eingabe- und\/oder Ausgabevariablen zuweisen. Die Zuweisung eines Werts an einen Eingabevariable erfolgt mit := . Die Zuweisung eines Wert an eine Ausgabevariable erfolgt mit => . Beispiel Die Instanz CMD_TMR des Timer-Funktionsbausteins wird mit Zuweisungen für die Eingabevariable IN und PT aufgerufen. Anschließend wird die Ausgabevariable Q des Timers der Variablen A zugewiesen PROGRAM PLC_PRG\nVAR\n CMD_TMR : TOF;\nEND_VAR\n\nCMD_TMR(IN := %IX5.1, PT := T#100MS);\nA := CMD_TMR.Q; Wenn Sie eine Funktionsbaustein-Instanz über die Eingabehilfe einfügen und im Dialog Eingabehilfe die Option Mit Argumenten einfügen aktiviert ist, fügt CODESYS den Aufruf mit allen Eingabe- und Ausgabevariablen ein. Sie müssen dann nur die gewünschten Wertzuweisung einfügen. Im obigen Beispiel fügt CODESYS den Aufruf wie folgt ein: CMD_TMR (IN:= ,PT:= , Q=> ) . Mit Hilfe des Attributs 'is_connected' auf einer lokalen Variablen können Sie zur Zeit des Aufrufs in der Funktionsbaustein-Instanz feststellen, ob ein bestimmter Eingang eine Zuweisung von außen erhält. " }, 
{ "title" : "Objekt: Funktion ", 
"url" : "_cds_obj_function.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Funktion ", 
"snippet" : "Funktion Eine Funktion ist eine POU , die bei der Ausführung genau ein Datenelement liefert und dessen Aufruf in textuellen Sprachen als Operator in Ausdrücken vorkommen kann. Das Datenelement kann auch ein Array oder eine Struktur sein. Sie fügen das Objekt der Applikation oder dem Projekt über den...", 
"body" : "Funktion Eine Funktion ist eine POU , die bei der Ausführung genau ein Datenelement liefert und dessen Aufruf in textuellen Sprachen als Operator in Ausdrücken vorkommen kann. Das Datenelement kann auch ein Array oder eine Struktur sein. Sie fügen das Objekt der Applikation oder dem Projekt über den Befehl Projekt → Objekt hinzufügen → POU hinzu. Im Gerätebaum oder in der Ansicht POUs haben Funktions-POUs das Suffix (FUN) . Funktionen haben keine interne Statusinformation, das bedeutet, dass Funktionen die Werte ihrer Variablen nicht bis zum nächsten Aufruf speichern. Aufrufe einer Funktion mit den selben Eingabevariablen-Werten liefern immer denselben Ausgabewert. Deshalb dürfen Funktionen keine globalen Variablen und Adressen verwenden! Der Editor einer Funktion besteht aus dem Deklarationsteil und dem Implementierungsteil. Die oberste Zeile des Deklarationsteils enthält folgende Deklaration: FUNCTION <function> : <data type> Darunter deklarieren Sie die Eingabe- und Funktionsvariablen. Die Ausgabevariable einer Funktion ist der Funktionsname. Wenn Sie eine lokale Variable in einer Funktion als RETAIN deklarieren, hat dies keinen Effekt! In diesem Fall gibt CODESYS einen Compilerfehler aus. In CODESYS V3 können Sie explizite und implizite Parameterzuweisungen in Funktionsaufrufen nicht mischen. Das bedeutet dass Sie entweder nur explizite oder nur implizite Parameterzuweisungen in Funktionsaufrufen verwenden. Die Reihenfolge der Parameterzuweisungen beim Funktionsaufruf ist beliebig. " }, 
{ "title" : "Eine Funktion aufrufen ", 
"url" : "_cds_obj_function.html#UUID-031b5d94-7e37-be07-c3ea-2dd9a75bdc3a_id_d8edec4a146076cec0a8640e0081effa_id_f9f95a4f1a50ad0ac0a8640e0134f3b9", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Funktion \/ Eine Funktion aufrufen ", 
"snippet" : "In ST können Sie den Aufruf einer Funktion als Operand in Ausdrücken verwenden. In AS können Sie einen Funktionsaufruf nur innerhalb von Schrittaktionen oder Transitionen verwenden. Beispiele Funktion mit Deklarationsteil und einer Zeile Implementierungs-Code Funktionsaufrufe: ST: result := POU_Func...", 
"body" : "In ST können Sie den Aufruf einer Funktion als Operand in Ausdrücken verwenden. In AS können Sie einen Funktionsaufruf nur innerhalb von Schrittaktionen oder Transitionen verwenden. Beispiele Funktion mit Deklarationsteil und einer Zeile Implementierungs-Code Funktionsaufrufe: ST: result := POU_Funct(5,3,22); AWL: FUP: " }, 
{ "title" : "Funktionen mit zusätzlichen Ausgängen ", 
"url" : "_cds_obj_function.html#UUID-031b5d94-7e37-be07-c3ea-2dd9a75bdc3a_id_d8edec4a146076cec0a8640e0081effa_id_d39a416b1a50ad0bc0a8640e0141d1c9", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Funktion \/ Funktionen mit zusätzlichen Ausgängen ", 
"snippet" : "Nach der Norm IEC 61131-3 können Funktionen zusätzliche Ausgänge haben. Die zusätzlichen Ausgänge deklarieren Sie in der Funktion zwischen den Schlüsselwörtern VAR_OUTPUT und END_VAR . Die Funktion rufen Sie gemäß folgender Syntax auf: <function> (<function output variable1> => <output variable 1>, ...", 
"body" : "Nach der Norm IEC 61131-3 können Funktionen zusätzliche Ausgänge haben. Die zusätzlichen Ausgänge deklarieren Sie in der Funktion zwischen den Schlüsselwörtern VAR_OUTPUT und END_VAR . Die Funktion rufen Sie gemäß folgender Syntax auf: <function> (<function output variable1> => <output variable 1>, <function output variable n> => <output variable n>) Beispiel Die Funktion fun ist mit zwei Eingabevariablen in1 und in2 definiert. Der Ausgabevariablen der Funktion fun wird auf die lokal deklarierten Ausgangsvariablen loc1 und loc2 geschrieben. fun(in1 := 1, in2 := 2, out1 => loc1, out2 => loc2); " }, 
{ "title" : "Objekt: Schnittstelle ", 
"url" : "_cds_obj_interface.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Schnittstelle ", 
"snippet" : "Schnittstelle Symbol: Schlüsselwort: INTERFACE Eine Schnittstelle ist ein Mittel der objektorientierten Programmierung. Das Objekt ITF beschreibt ein Set von Methoden- und Eigenschaft-Prototypen. Prototyp bedeutet in diesem Zusammenhang, dass die Methoden und Eigenschaften nur Deklarationen und kein...", 
"body" : "Schnittstelle Symbol: Schlüsselwort: INTERFACE Eine Schnittstelle ist ein Mittel der objektorientierten Programmierung. Das Objekt ITF beschreibt ein Set von Methoden- und Eigenschaft-Prototypen. Prototyp bedeutet in diesem Zusammenhang, dass die Methoden und Eigenschaften nur Deklarationen und keine Implementierung enthalten. Auf diese Weise können Sie verschiedene Funktionsbausteine, die gemeinsame Eigenschaften haben, gleichartig nutzen. Ein Objekt ITF fügen Sie der Applikation oder dem Projekt mit dem Befehl Projekt → Objekt hinzufügen → Schnittstelle hinzu. Für weitere Informationen siehe: Implementieren einer SchnittstelleSchnittstelle hinzufügen Vererbung Name Schnittstellenname Erweitert : Erweitert die Schnittstelle, die Sie im Eingabefeld eingeben oder über die Eingabehilfe auswählen. Dies bedeutet, dass alle Methoden der Schnittstelle, die die neue Schnittstelle erweitert, auch in der neuen Schnittstelle verfügbar sind. Für weitere Informationen siehe: Erweitern einer SchnittstelleMehrfachvererbung wird bei Schnittstellen unterstützt. Dem Objekt ITF können Sie die Objekte Schnittstelleneigenschaft und Schnittstellenmethode hinzufügen. Schnittstellenmethoden dürfen nur die Deklarationen von Eingabe-, Ausgabe-, und VAR_IN_OUT-Variablen, aber keine Implementierung enthalten. Damit Sie eine Schnittstelle auch im Programm verwenden können, muss es einen Funktionsbaustein geben, der diese Schnittstelle implementiert. Das bedeutet: Der Funktionsbaustein enthält in seinem Deklarationsteil die Schnittstelle in seiner IMPLEMENTS-Liste. Der Funktionsbaustein enthält für alle Methoden und Eigenschaften-Prototypen der Schnittstelle eine Implementierung. Ein Funktionsbaustein kann eine oder mehrere Schnittstellen implementieren. Sie können die gleiche Methode mit identischen Parametern, aber unterschiedlichem Implementierungscode in verschiedenen Funktionsbausteinen verwenden. Beachten Sie Folgendes Sie dürfen keine Variablen innerhalb einer Schnittstelle deklarieren. Eine Schnittstelle hat keinen Implementierungsteil und keine Aktionen. Nur eine Sammlung von Methoden ist definiert und in diesen dürfen Sie nur Eingabe-, Ausgabe- und VAR_IN_OUT-Variablen definieren. CODESYS behandelt Variablen, die mit dem Typ einer Schnittstelle deklariert sind, immer als Referenzen. Ein Funktionsbaustein, der eine Schnittstelle implementiert, muss Implementierungs-Code für die Methoden der Schnittstelle enthalten. Die Methoden haben Sie genauso benannt wie in der Schnittstelle und die Methoden enthalten dieselben Eingabe-, Ausgabe- und VAR_IN_OUT-Variablen wie in der Schnittstelle. Schnittstellenreferenzen und Online-Change Mit Compiler-Version < 3.4.1.0 kann Folgendes passieren: Wenn ein Funktionsbaustein seine Daten ändert, weil Variablen hinzugefügt oder gelöscht werden, oder weil sich der Typ von Variablen ändert, dann kopiert CODESYS alle Instanzen des Funktionsbausteins an einen neuen Speicherplatz. In diesem Fall verweist eine Schnittstellenreferenz aber nicht auf den neuen Speicherplatz, sondern immer noch auf den alten. Mit Compiler-Versionen >= 3.4.1.0 adressiert CODESYS die Schnittstellen-Referenzen automatisch um, so dass CODESYS auch im Falle eines Online-Change die korrekte Schnittstelle referenziert. Dafür benötigt CODESYS zusätzlichen Code und mehr Zeit, sodass abhängig von der Anzahl der betroffenen Objekte Jitter-Probleme auftreten können. Deshalb zeigt CODESYS vor Ausführung des Online-Change die Anzahl der betroffenen Variablen und Schnittstellen-Referenzen an und Sie entscheiden, ob der Online-Change durchgeführt oder abgebrochen wird. Beispiel Definition einer Schnittstelle und Verwendung in einem Funktionsbaustein Sie haben die Schnittstelle ITF unterhalb der Applikation eingefügt. Die Schnittstelle enthält die Methoden Method1 und Method2 . ITF , Method1 und Method2 enthalten keinen Implementierungscode. Nur im Deklarationsteil der Methoden fügen Sie die benötigten Variablendeklarationen ein. Wenn Sie anschließend einen Funktionsbaustein im Gerätebaum einfügen der die Schnittstelle ITF implementiert, fügt CODESYS automatisch auch die Methoden Method1 und Method2 unter dem Funktionsbaustein ein. Hier können Sie in den Methoden funktionsbaustein-spezifischen Code implementieren. " }, 
{ "title" : "Objekt: Methode ", 
"url" : "_cds_obj_method.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Methode ", 
"snippet" : "Methode Symbol: Schlüsselwort: METHOD Methoden sind eine Erweiterung der Norm IEC 61131-3 und ein Mittel der objektorientierten Programmierung, das der Datenkapselung dient. Eine Methode enthält eine Deklaration und eine Implementierung. Eine Methode ist jedoch im Gegensatz zu einer Funktion kein un...", 
"body" : "Methode Symbol: Schlüsselwort: METHOD Methoden sind eine Erweiterung der Norm IEC 61131-3 und ein Mittel der objektorientierten Programmierung, das der Datenkapselung dient. Eine Methode enthält eine Deklaration und eine Implementierung. Eine Methode ist jedoch im Gegensatz zu einer Funktion kein unabhängiger Programmierbaustein, sondern ist einem Funktionsbaustein oder Programm untergeordnet. Eine Methode kann auf alle gültigen Variablen des übergeordneten Programmierbausteins zugreifen. Sie können unterhalb eines Programms oder eines Funktionsbausteins eine Methode hinzufügen. Verwenden Sie dafür den Befehl Projekt → Objekt hinzufügen → Methode , dann öffnet sich der Dialog Methode hinzufügen . Zur Organisation von Methoden können Sie Schnittstellen verwenden. Für weiter Informationen siehe: Implementieren einer SchnittstelleWenn Sie eine Methode, die unterhalb eines Programmierbausteins ist, kopieren und unter einer Schnittstelle einfügen, oder die Methode dahin verschieben, wird automatisch die enthaltene Implementierung entfernt. " }, 
{ "title" : "Deklaration ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_id_e4507ebe4233ac0c0a8640e00a37b12_id_1a9cda980d7f5306c0a86463246390b7", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Methode \/ Deklaration ", 
"snippet" : "Syntax: METHOD <access specifier> <method name> : <type of return value> <access specifier> Optional Zugriffsmodifizierer Je nach deklariertem Zugriffsmodifizierer kann eine Methode nur innerhalb des eigenen Namensraums ( INTERNAL ), nur innerhalb des eigenen Programmierbausteins und seinen Ableitun...", 
"body" : "Syntax: METHOD <access specifier> <method name> : <type of return value> <access specifier> Optional Zugriffsmodifizierer Je nach deklariertem Zugriffsmodifizierer kann eine Methode nur innerhalb des eigenen Namensraums ( INTERNAL ), nur innerhalb des eigenen Programmierbausteins und seinen Ableitungen ( PROTECTED ) oder nur innerhalb des eigenen Programmierbausteins ( PRIVATE ) aufgerufen werden. Bei PUBLIC kann die Methode überall aufgerufen werden. <method name> Bezeichner der Methode <type of retur value> Optional Rückgabetyp der Methode Hinweis: Bei Methoden, die keinen expliziten Rückgabetyp haben, wird die erste deklarierte Ausgabe als Rückgabewert verwendet. Nur wenn weder Rückgabetyp noch Ausgabe deklariert sind, liefert eine Methode keinen Wert zurück. Ein Compilerfehler wird aber in keinem der beiden Fälle erzeugt. Mögliche Gültigkeitsbereiche mit Variablendeklaration (Parameter) <scope list> Gültigkeitsbereiche: VAR_IN_OUT <variable declaration list> END_VAR für Variablendeklaration bei Ein- \/Ausgabevariablen VAR_INPUT <variable declaration list> END_VAR für Variablendeklaration für Eingaben VAR_OUTPUT <variable declaration list> END_VAR für Variablendeklaration für Ausgaben Methoden können wie Funktionen zusätzliche Ausgaben haben. Den zusätzlichen Ausgaben müssen Sie beim Methodenaufruf ebenfalls Argumente (Variablen) übergeben. VAR <variable declaration list> END_VAR für Variablendeklaration für lokale Zwecke <variable declaration list> Variablendeklaration <variable name> : <data type> := <initial value> ; Mit Strichpunkt separierte Liste mit Variablen (Parameter), die einem Gültigkeitsbereich entsprechend ihrem Zweck zugeordnet sind. Variablen für Eingabe und Ein- \/Ausgabe können einen Initialwert zugewiesen haben Die Zuweisung eines Initialwerts ist optional. Wenn aber einer angegeben ist, kann beim Methodenaufruf auf eine Argumentübergabe für diesen Parameter verzichtet werden. Solche Parameter werden optionale Parameter genannt. Die Variablen einer Methode (Parameter) enthalten temporäre Daten, die nur während der Ausführung der Methode gültig sind (Stack-Variablen). Alle Variablen, die in einer Methode deklariert und implementiert sind, werden bei jedem Aufruf der Methode neu initialisiert. Beispiel Deklaration METHOD PUBLIC DoIt : BOOL\nVAR_INPUT\n iInput_1 : DWORD;\n iInput_2 : DWORD;\n sInput_3 : STRING(12);\nEND_VAR " }, 
{ "title" : "Implementierung ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_id_e4507ebe4233ac0c0a8640e00a37b12_id_d5a78e4a116f11e8b6e4d1a39d87c360", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Methode \/ Implementierung ", 
"snippet" : "Optional Bei der Implementierung der Methode ist der Zugriff auf Funktionsbaustein-Instanzen oder Programmvariablen erlaubt Der THIS -Pointer ermöglicht den Zugriff auf die eigene Funktionsbaustein-Instanz. Der Pointer ist somit nur in Methoden erlaubt, die einem Funktionsbausteins zugeordnet sind. ...", 
"body" : "Optional Bei der Implementierung der Methode ist der Zugriff auf Funktionsbaustein-Instanzen oder Programmvariablen erlaubt Der THIS -Pointer ermöglicht den Zugriff auf die eigene Funktionsbaustein-Instanz. Der Pointer ist somit nur in Methoden erlaubt, die einem Funktionsbausteins zugeordnet sind. Eine Methode kann nicht auf VAR_TEMP -Variablen des Funktionsbausteins zugreifen Eine Methode kann sich selbst rekursiv aufrufen Bei Schnittstellenmethoden gibt es keine Implementierung Schnittstellenmethoden können Eingabe-, Ausgabe- und VAR_IN_OUT -Variablen deklariert haben, enthalten aber keine Implementierung. " }, 
{ "title" : "Methodenaufruf ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_id_e4507ebe4233ac0c0a8640e00a37b12_id_7f4f002a7a7c22c7c0a864630de7909a", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Methode \/ Methodenaufruf ", 
"snippet" : "Syntax bei Aufruf <return value variable> := <POU name> . <method name> ( <argument passing> ); <return value variable> Variabel für den Rückgabewert Der Typ muss mit dem Rückgabetyp der Methode übereinstimmen. Hinweis: Bei Methoden, die keinen expliziten Rückgabetyp haben, wird die erste deklariert...", 
"body" : "Syntax bei Aufruf <return value variable> := <POU name> . <method name> ( <argument passing> ); <return value variable> Variabel für den Rückgabewert Der Typ muss mit dem Rückgabetyp der Methode übereinstimmen. Hinweis: Bei Methoden, die keinen expliziten Rückgabetyp haben, wird die erste deklarierte Ausgabe als Rückgabewert verwendet. Nur wenn weder Rückgabetyp noch Ausgabe deklariert sind, liefert eine Methode keinen Wert zurück. Ein Compilerfehler wird aber in keinem der beiden Fälle erzeugt. <POU name> Bezeichner der Funktionsbaustein-Instanz, unter der die Methode angeordnet ist <method name> Bezeichner der Methode <argument passing> Komma separierte Liste mit den tatsächlichen Argumenten An jeden Parameter (Variable) der Methode wird ein Argument übergeben: <parameter name> := <actual argument> Jeder deklarierten Ein-\/Ausgabe oder Eingabe wird das tatsächliche Argument zugewiesen. Das Argument kann ein Wert (Literal), ein Ausdruck oder eine Variable mit passendem Typ sein. Jeder deklarierten Ausgabe wird das tatsächliche Argument (Variable gleichen Typs) zugewiesen. Das Argument muss eine Variable mit passendem Typ sein. Eine Argumentübergabe für eine Eingaben oder eine Ein- \/Ausgaben kann fehlen. Die Anzahl der Argumente in der Liste darf somit kleiner sein als die Anzahl der Parameter (Gültigkeitsbereich Eingabe oder Ein-\/Ausgabe). Insbesondere, wenn es sich um einen optionalen Parameter handelt, für den in der Deklaration ein Default- oder Initialwert angegeben wurde, kann auf eine Argumentübergabe verzichtet werden. Tipp: Wenn Sie sich beim Methodenaufruf von der Eingabehilfe unterstützen lassen, werden Sie dort über bestehende Initialwerte informiert. Eine Argumentübergabe mit Angabe des Parameters mit Namen und Zuweisungsoperator ist optional. Es genügt, nur das Argument anzugeben. Aus der Reihenfolge der Variablen in der Deklaration ergibt sich dann, welches Argument an welchen Parameter übergeben wird. Beispiel Deklaration METHOD PUBLIC DoIt : BOOL\nVAR_INPUT\n iInput_1 : DWORD;\n iInput_2 : DWORD;\n sInput_3 : STRING(12);\nEND_VAR Aufruf mit Argumentübergabe an Parameter bFinishedMethod := fbInstance.DoIt(sInput_3 := 'Hello World ', iInput_2 := 16#FFFF, iInput_1 := 16); Bei Aufruf der Methode wird der Rückgabewert der Methode an eine lokal deklarierte Variable zugewiesen. Beispiel Wenn Sie die Namen der Eingabevariablen weglassen, ergibt sich die Zuordnung der Argumente aus der Deklarationsreihenfolge. Deklaration METHOD PUBLIC DoIt : BOOL\nVAR_INPUT\n iInput_1 : DWORD;\n iInput_2 : DWORD;\n sInput_3 : STRING(12);\nEND_VAR\nIF iInput_1 = iInput_2 THEN\n\tDoIt := TRUE; \/\/ explicit return value\nEND_IF\n\n Aufruf mit Argumentübergabe nach Reihenfolge in der Deklaration bFinishedMethod := fbInstance.DoIt( 16, 16#0010,'Hello World '); " }, 
{ "title" : "Rekursiver Methodenaufruf ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_id_e4507ebe4233ac0c0a8640e00a37b12_id_421cb3a8093e22bac0a8640e01a50890", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Methode \/ Rekursiver Methodenaufruf ", 
"snippet" : "Innerhalb der Implementierung kann eine Methode sich selbst aufrufen: entweder direkt mit Hilfe des THIS -Pointers, oder mit Hilfe einer lokalen Variablen für den zugeordneten Funktionsbaustein. <return value variable> := <POU name> . <method name> ( <argument passing> ); Direkter Aufruf der betroff...", 
"body" : "Innerhalb der Implementierung kann eine Methode sich selbst aufrufen: entweder direkt mit Hilfe des THIS -Pointers, oder mit Hilfe einer lokalen Variablen für den zugeordneten Funktionsbaustein. <return value variable> := <POU name> . <method name> ( <argument passing> ); Direkter Aufruf der betroffenen Funktionsbaustein-Instanz mit dem THIS -Pointer <return value variable> := <POU name> . <method name> ( <argument passing> ); Aufruf über eine lokale Variable der Methode, die temporär den betroffenen Funktionsbaustein instanziiert Bei einem rekursiven Aufruf wird eine Compilerwarnung ausgegeben. Wenn die Methode mit dem Pragma {attribute 'estimated-stack-usage' := '<estimated stack size in bytes>'} versehen ist, wird die Compilerwarnung unterdrückt. Im Kapitel „Attribut 'estimated-stack-usage' “ finden Sie ein Implementierungsbeispiel. Um Methoden rekursiv aufzurufen, genügt es also nicht, nur den Methodennamen anzugeben. Wenn nur der Methodenname angegeben ist, wird ein Compilerfehler ausgegeben: Programmname, Funktion oder Funktionsbaustein-Instanz erwartet statt … " }, 
{ "title" : "Spezielle Methoden eines Funktionsbausteins ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_id_e4507ebe4233ac0c0a8640e00a37b12_id_1c08ae16e567f9b0c0a8640e008b85b9", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Methode \/ Spezielle Methoden eines Funktionsbausteins ", 
"snippet" : "FB_Init Deklarationen automatisch implizit, aber auch explizite Deklaration möglich Enthält Initialisierungscode für den Funktionsbaustein, so wie im Deklarationsteil des Funktionsbausteins definiert FB_Reinit Explizite Deklaration notwendig Aufruf, nachdem die Instanz des Funktionsbausteins kopiert...", 
"body" : "FB_Init Deklarationen automatisch implizit, aber auch explizite Deklaration möglich Enthält Initialisierungscode für den Funktionsbaustein, so wie im Deklarationsteil des Funktionsbausteins definiert FB_Reinit Explizite Deklaration notwendig Aufruf, nachdem die Instanz des Funktionsbausteins kopiert wurde (wie während eines Online-Changes). Reinitialisiert das neue Instanzmodul. FB_Exit Explizite Deklaration notwendig Aufruf für jede Instanz des Funktionsbausteins vor einem erneuten Download oder einem Reset oder während eines Online-Changes für alle verschobenen oder gelöschten Instanzen Eigenschaften Stellt Set - und\/oder Get -Accessormethoden bereit " }, 
{ "title" : "Dialog Methode hinzufügen ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_id_e4507ebe4233ac0c0a8640e00a37b12_id_9181172594148571c0a864634fbe4313", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Methode \/ Dialog Methode hinzufügen ", 
"snippet" : "Funktion : Definiert eine Methode, die mit Beenden des Dialogs unterhalb des selektierten Programmierbausteins angeordnet wird. Aufruf : Projekt → Objekt hinzufügen → Methode , Kontextmenü Voraussetzung : In Ansicht POUs oder Ansicht Geräte ist ein Programm ( PRG ) oder ein Funktionsbausteins ( FUNC...", 
"body" : "Funktion : Definiert eine Methode, die mit Beenden des Dialogs unterhalb des selektierten Programmierbausteins angeordnet wird. Aufruf : Projekt → Objekt hinzufügen → Methode , Kontextmenü Voraussetzung : In Ansicht POUs oder Ansicht Geräte ist ein Programm ( PRG ) oder ein Funktionsbausteins ( FUNCTION_BLOCK ) selektiert. Die Schnittstelle einer unter einem Basis-Funktionsbaustein eingefügten Methode wird beim Einfügen einer Methode gleichen Namens unter einem abgeleiteten Baustein übernommen. Name Beispiel: meth_DoIt . Die Standardmethoden FB_Init und FB_Exit werden in einer Auswahlliste angeboten, wenn sie nicht bereits unterhalb des Bausteins eingefügt sind. Wenn es sich um einen abgeleiteten Funktionsbaustein handelt, bietet die Auswahlliste außerdem alle Methoden des Basisbausteins an. Rückgabetyp Standarddatentyp oder strukturierter Datentyp des Rückgabewerts Beispiel: BOOL Implementierungssprache Beispiel: Strukturierter Text (ST) Zugriffsmodifizierer Regelt den Zugriff auf die Daten. PUBLIC oder keine Angabe: Der Zugriff ist nicht eingeschränkt. PRIVATE : Der Zugriff ist auf das Programm, den Funktionsbaustein oder die GVL beschränkt. Im POUs- oder Gerätebaum ist das Objekt mit (private) gekennzeichnet. Die Deklaration enthält das Schlüsselwort PRIVATE . PROTECTED : Der Zugriff ist auf das Programm, die GVL oder den Funktionsbaustein mit seinen Ableitungen beschränkt. Die Deklaration enthält das Schlüsselwort PROTECTED . Im POUs- oder Gerätebaum ist das Objekt mit (protected) gekennzeichnet. INTERNAL : Der Zugriff auf die Methode ist auf den Namensraum ( Bibliothek) beschränkt. Im POUs- oder Gerätebaum ist das Objekt mit (internal) gekennzeichnet. Die Deklaration enthält das Schlüsselwort INTERNAL . Abstrakt : Kennzeichnet, dass die Methode keine Implementierung hat und die Implementierung durch den abgeleiteten FB bereitgestellt wird. Hinzufügen Fügt unterhalb des selektierten Objekts eine neue Methode hinzu. " }, 
{ "title" : "Eingabeunterstützung beim Erzeugen von erbenden Bausteinen ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_UUID-e3a7d561-c8bd-ff0c-4eda-2e6419e8e10f", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Methode \/ Dialog Methode hinzufügen \/ Eingabeunterstützung beim Erzeugen von erbenden Bausteinen ", 
"snippet" : "Wenn Sie objektorientiert programmieren und die Vererbung (Schlüsselwort EXTENDS ) von Bausteinen nutzen, können Sie folgendermaßen Unterstützung erhalten: Wenn Sie unterhalb eines von einem Basisbaustein abgeleiteten Bausteins eine Aktion, Eigenschaft, Methode oder Transition einfügen, öffnet sich ...", 
"body" : "Wenn Sie objektorientiert programmieren und die Vererbung (Schlüsselwort EXTENDS ) von Bausteinen nutzen, können Sie folgendermaßen Unterstützung erhalten: Wenn Sie unterhalb eines von einem Basisbaustein abgeleiteten Bausteins eine Aktion, Eigenschaft, Methode oder Transition einfügen, öffnet sich der Dialog … hinzufügen . Dort ist das Eingabefeld für den Namen erweitert zu einer Combobox. Die Auswahlliste der Combobox enthält eine gültige Auswahl aus den im Basisbaustein vorhandenen Aktionen, Eigenschaften, Methoden oder Transitionen. Nun können Sie beispielsweise eine Methode des Basisbausteins auf einfache Weise zunächst übernehmen, um sie dann entsprechend für die abgeleitete Funktion des Bausteins anzupassen. Methoden und Eigenschaften mit dem Zugriffsmodifizierer PRIVATE erscheinen in dieser Auswahl nicht, da sie auch nicht vererbt werden. Methoden und Eigenschaften mit dem Zugriffsmodifizierer PUBLIC erhalten beim Übernehmen in den abgeleiteten Baustein automatisch ein leeres Zugriffsmodifiziererfeld, was funktional das Gleiche bedeutet. Für weitere Informationen siehe: Eigenschaft, Methode, Transition, Aktion, Beispiel " }, 
{ "title" : "Objekt: Schnittstellenmethode ", 
"url" : "_cds_obj_interface_method.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Schnittstellenmethode ", 
"snippet" : "Schnittstellenmethode Symbol: Das Objekt dient der objektorientierten Programmierung. Sie fügen das Objekt Schnittstellenmethode einer Schnittstelle über den Befehl Projekt → Objekt hinzufügen hinzu. Wenn eine Methode unterhalb einer Schnittstelle eingefügt ist, können Sie in dieser Methode nur Vari...", 
"body" : "Schnittstellenmethode Symbol: Das Objekt dient der objektorientierten Programmierung. Sie fügen das Objekt Schnittstellenmethode einer Schnittstelle über den Befehl Projekt → Objekt hinzufügen hinzu. Wenn eine Methode unterhalb einer Schnittstelle eingefügt ist, können Sie in dieser Methode nur Variablendeklarationen (Eingabe-, Ausgabe- und EinAusgabe-Variablen) hinzufügen und instanzieren. Der Methode können erst dann Programmcode hinzufügen, wenn ein Funktionsbaustein die Schnittstelle, zu der die Methode gehört, implementiert . CODESYS fügt die Methode dann unterhalb des Funktionsbausteins ein. " }, 
{ "title" : "Objekt: Schnittstelleneigenschaft ", 
"url" : "_cds_obj_interface_property.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Schnittstelleneigenschaft ", 
"snippet" : "Schnittstelleneigenschaft Symbol: Schnittstelleneigenschaften sind eine Erweiterung der Norm IEC 61131-3 und ein Mittel der objektorientierten Programmierung. Eine Schnittstelleneigenschaft deklariert die Accessormethoden Get und Set (kein Implementerungscode). Ein Funktionsbaustein, der eine Schnit...", 
"body" : "Schnittstelleneigenschaft Symbol: Schnittstelleneigenschaften sind eine Erweiterung der Norm IEC 61131-3 und ein Mittel der objektorientierten Programmierung. Eine Schnittstelleneigenschaft deklariert die Accessormethoden Get und Set (kein Implementerungscode). Ein Funktionsbaustein, der eine Schnittstelle implementiert, erbt damit auch deren Schnittstelleneigenschaften. Sie können im Gerätebaum bei einer Schnittstelle eine Schnittstelleneigenschaft hinzufügen, dann wird die Schnittstelle um die Accessormethoden Get und Set erweitert. Der Get -Accessor dient dem Lesezugriff. Der Set -Accessor dient dem Schreibzugriff. Sie können einen nicht benötigten Accessor löschen. Um einen Accessor hinzuzufügen, verwenden Sie den Befehl Projekt → Objekt hinzufügen → Schnittstelleneigenschaft . Dann öffnet sich der Dialog Schnittstelleneigenschaft hinzufügen . Beispiel Deklaration und Implementierung der Schnittstelleneigenschaft Literal_A Die Schnittstelle itf_A hat die Eigenschaft Literal_A mit den Accessormethoden Get und Set . Die Funktionsbausteine fb_A1 und fb_A2 implementieren die Schnittstelle itf_A und erben damit deren Schnittstelleneigenschaft. Jeder FB hat seine eigene Implementierung. Schnittstelle i tf_A INTERFACE itf_A\nVAR\nEND_VAR\nPROPERTY Literal_A : STRING FB fb_A1 FUNCTION_BLOCK fb_A1 IMPLEMENTS itf_A\nVAR\n str_1 : STRING;\n str_2 : STRING;\n iCnt : INT;\nEND_VAR\niCnt := iCnt + 1;\n\nstr_1 := 'Function block A1'; Accessor fb_A1.Literal_A.Get VAR\nEND_VAR\nLiteral_A := CONCAT (str_1,' and property.'); Accessor fb_A1.Literal_A.Set VAR\nEND_VAR\nstr_2 := Literal_A; FB fb_A2 FUNCTION_BLOCK fb_A2 IMPLEMENTS itf_A\nVAR\n str_1 : STRING;\n str_2 : STRING;\n iCnt : INT;\nEND_VAR\n\niCnt := iCnt + 1;\nstr_1 := 'Function block A2'; Accessor fb_A2.Literal_A.Get VAR\nEND_VAR\nLiteral_A := str_1; Accessor fb_A2.Literal_A.Set VAR\nEND_VAR\nstr_2 := Literal_A; Programm PLC_PRG PROGRAM PLC_PRG\nVAR\n iCnt : INT;\n my_1 : fb_A1;\n my_2 : fb_A2;\n strName_1 : STRING;\n strName_2: STRING;\nEND_VAR\n\niCnt := iCnt + 1;\nmy_1();\nmy_2();\nstrName_1:= my_1.Literal_A;\nstrName_2:= my_2.Literal_A;\nmy_1.Literal_A := 'Hello 1';\nmy_2.Literal_A := 'World 2'; Das führt zur Laufzeit der Applikation zu folgendem Monitoring von PLC_PRG : " }, 
{ "title" : "Objekt: Eigenschaft ", 
"url" : "_cds_obj_property.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Eigenschaft ", 
"snippet" : "Eigenschaft Symbol: Schlüsselwort: PROPERTY Eigenschaften sind eine Erweiterung der Norm IEC 61131-3 und ein Mittel der objektorientierten Programmierung. Eigenschaften dienen der Datenkapselung, da sie von außen Zugriff auf Daten ermöglichen und gleichzeitig als Filter fungieren. Dafür stellt eine ...", 
"body" : "Eigenschaft Symbol: Schlüsselwort: PROPERTY Eigenschaften sind eine Erweiterung der Norm IEC 61131-3 und ein Mittel der objektorientierten Programmierung. Eigenschaften dienen der Datenkapselung, da sie von außen Zugriff auf Daten ermöglichen und gleichzeitig als Filter fungieren. Dafür stellt eine Eigenschaft die Accessormethoden Get und Set bereit, die Lese- und Schreibzugriff auf die Daten der Instanz ermöglichen, unter der die Eigenschaft angeordnet ist. Unterhalb eines Programms, eines Funktionsbausteins oder einer Globalen Variablenliste können Sie eine Eigenschaft mit Accessormethoden hinzufügen. Verwenden Sie dafür den Befehl Projekt → Objekt hinzufügen → Eigenschaft , um den Dialog Eigenschaft hinzufügen zu öffnen. Unterhalb einer Schnittstelle können Sie eine Schnittstelleneigenschaft einfügen. Wenn Sie eine Eigenschaft kopieren, die unter einem Programmierbaustein eingehängt ist, und sie unter einer Schnittstelle einfügen, oder wenn Sie die Eigenschaft dorthin verschieben, werden automatisch die enthaltenen Implementierungen entfernt. Monitoring von Eigenschaften im Onlinebetrieb Für das Monitoring von Eigenschaften im Onlinebetrieb stehen folgende Pragmas zur Verfügung, die Sie an oberster Stelle in der Deklaration der Eigenschaft einfügen: {attribute 'monitoring' := 'variable'} Bei jedem Zugriff auf die Eigenschaft speichert CODESYS den Istwert in einer Variablen und stellt den Wert dieser Variablen dar. Dieser Wert kann unter Umständen veralten, wenn im Code kein Zugriff mehr auf die Eigenschaft erfolgt. {attribute 'monitoring' := 'call'} Bei jeder Darstellung des Werts ruft CODESYS den Code des Get -Accessors auf. Wenn dieser Code einen Seiteneffekt enthält, dann wird der Seiteneffekt durch das Monitoring ausgeführt! Sie können eine Eigenschaft mit Hilfe folgender Funktionalitäten monitoren. Inline-Monitoring Voraussetzung: In der Kategorie Texteditor des Optionen -Dialogs ist die Option Inline-Monitoring aktivieren aktiviert. Überwachungsliste " }, 
{ "title" : "Dialog: Eigenschaft hinzufügen ", 
"url" : "_cds_obj_property.html#UUID-9c407fa5-d8b8-4172-1c22-5219eeec8317_id_b08bdbd0d86c0a8640e00400511_id_bf40a4d8ef1988a5c0a864636ff3b754", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Eigenschaft \/ Dialog: Eigenschaft hinzufügen ", 
"snippet" : "Funktion : Legt eine neue Eigenschaft an, die mit Beenden des Dialogs unterhalb des selektierten Programmierbausteins angeordnet wird. Aufruf : Projekt → Objekt hinzufügen → Eigenschaft , Kontextmenü Voraussetzung : In Ansicht POUs oder Ansicht Geräte ist ein Programm ( PRG ), ein Funktionsbaustein ...", 
"body" : "Funktion : Legt eine neue Eigenschaft an, die mit Beenden des Dialogs unterhalb des selektierten Programmierbausteins angeordnet wird. Aufruf : Projekt → Objekt hinzufügen → Eigenschaft , Kontextmenü Voraussetzung : In Ansicht POUs oder Ansicht Geräte ist ein Programm ( PRG ), ein Funktionsbaustein ( FUNCTION_BLOCK ) oder eine Globale Variablenliste ( GVL ) selektiert. Name Name (Bezeichner) der Eigenschaft Beispiel: prop_iA Rückgabetyp Standardtyp oder strukturierter Typ des Rückgabewerts Beispiel: INT Implementierungssprache Beispiel: Stukturierter Text (ST) Zugriffsmodifizierer Regelt den Zugriff auf die Daten PUBLIC oder keine Angabe Der Zugriff ist nicht beschränkt. PRIVATE Der Zugriff ist auf das Programm, den Funktionsbaustein oder die GVL beschränkt. Im POUs- oder Gerätebaum ist das Objekt mit (private) gekennzeichnet. Die Deklaration enthält das Schlüsselwort PRIVATE . PROTECTED Der Zugriff ist auf das Programm, die GVL, oder dem Funktionsbaustein mit seinen Ableitungen beschränkt. Im POUs- oder Gerätebaum ist das Objekt mit (protected) gekennzeichnet. Die Deklaration enthält das Schlüsselwort PROTECTED . INTERNAL Der Zugriff ist auf den Namensraum (Bibliothek) beschränkt. Im POUs- oder Gerätebaum ist das Objekt mit (internal) gekennzeichnet. Die Deklaration enthält das Schlüsselwort INTERNAL . Abstrakt : Kennzeichnet, dass die Eigenschaft keine Implementierung hat und die Implementierung durch den abgeleiteten FB bereitgestellt wird Hinzufügen Fügt unterhalb des selektierten Objekts eine neue Eigenschaft und darunter die Accessormethoden Get und Set hinzu Hinweis: Wenn Sie eine Eigenschaft selektiert haben, können Sie mit dem Befehl Objekt hinzufügen auch explizit einen vorher entfernten Accessor hinzufügen. " }, 
{ "title" : "Editor: Eigenschaft ", 
"url" : "_cds_obj_property.html#UUID-9c407fa5-d8b8-4172-1c22-5219eeec8317_id_b08bdbd0d86c0a8640e00400511_id_8fff2f78bde26345c0a8640e018af0a1", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Eigenschaft \/ Editor: Eigenschaft ", 
"snippet" : "Im Editor können Sie den Datenzugriff programmieren. Der Code darf zusätzliche lokale Variablen enthalten. Aber er darf keine zusätzlichen Eingangsvariablen oder (im Gegensatz zu einer Funktion oder Methode) keine zusätzlichen Ausgangsvariablen enthalten. Beispiel Funktionsbaustein FB_A FUNCTION_BLO...", 
"body" : "Im Editor können Sie den Datenzugriff programmieren. Der Code darf zusätzliche lokale Variablen enthalten. Aber er darf keine zusätzlichen Eingangsvariablen oder (im Gegensatz zu einer Funktion oder Methode) keine zusätzlichen Ausgangsvariablen enthalten. Beispiel Funktionsbaustein FB_A FUNCTION_BLOCK FB_A\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\n\niA := iA + 1; Eigenschaft prop_iA PROPERTY PUBLIC prop_iA : INT Accessormethode FB_A.prop_iA.Get prop_iA := iA; Accessormethode FB_A.prop_iA.Set iA := prop_iA; PROGRAM PLC_PRG\nVAR\n fbA : FB_A;\n iVar: INT;\nEND_VAR\n\nfbA();\nIF fbA.prop_iA > 500 THEN\n fbA.prop_iA := 0;\nEND_IF\niVar := fbA.prop_iA; " }, 
{ "title" : "Get- Accessor, Set-Accessor ", 
"url" : "_cds_obj_property.html#UUID-9c407fa5-d8b8-4172-1c22-5219eeec8317_id_b08bdbd0d86c0a8640e00400511_id_d1b96520c2a88023c0a8640e00496635", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Eigenschaft \/ Get- Accessor, Set-Accessor ", 
"snippet" : "Dei Aufruf des Set -Accessors wird auf die Eigenschaft geschrieben. Sie wird somit wie ein Eingabeparameter verwendet. Bei Aufruf des Get-Accessors wird die Eigenschaft gelesen. Sie wird wie ein Ausgabeparameter verwendet. Der Zugriff wird jeweils über Zugiffsmodifizierer (Qualifizierer) beschränkt....", 
"body" : "Dei Aufruf des Set -Accessors wird auf die Eigenschaft geschrieben. Sie wird somit wie ein Eingabeparameter verwendet. Bei Aufruf des Get-Accessors wird die Eigenschaft gelesen. Sie wird wie ein Ausgabeparameter verwendet. Der Zugriff wird jeweils über Zugiffsmodifizierer (Qualifizierer) beschränkt. Die Objekte sind dabei entsprechend gekennzeichnet. Wenn auf eine Eigenschaft nur lesend oder nur schreibend zugegriffen wird, können Sie den nicht benötigten Accessor löschen. Sie können explizit Accessoren hinzufügen, indem Sie eine Eigenschaft selektieren und den Befehl Objekt hinzufügen ausführen. Es öffnet sich der Dialog Get-Accessor hinzufügen oder Set-Accessor hinzufügen . Dort können Sie die Implementierungssprache und den Zugriff einstellen. Dialog Get (Set)-Accessor hinzufügen Implementierungssprache Beispiel: Strukturierter Text (ST) Zugriffsmodifizierer Qualifizierer für Deklarationsabschnitt PUBLIC oder keine Angabe Der Zugriff ist nicht beschränkt. PRIVATE Der Zugriff ist auf das Programm, den Funktionsbaustein oder die GVL beschränkt. Im POUs- oder Gerätebaum ist das Objekt mit (private) gekennzeichnet. Die Deklaration enthält das Schlüsselwort. PROTECTED Der Zugriff auf die Eigenschaft ist auf das Programm, die GVL oder dem Funktionsbaustein und seine Ableitungen beschränkt. Die Deklaration enthält das Schlüsselwort. Im POUs- oder Gerätebaum ist das Objekt mit (protected) gekennzeichnet. INTERNAL Der Zugriff auf die Methode ist auf den Namensraum (die Bibliothek) beschränkt. Im POUs- oder Gerätebaum ist das Objekt mit (internal) gekennzeichnet. Die Deklaration enthält das Schlüsselwort. Hinzufügen Fügt unterhalb der selektierten Eigenschaft die Accessormethoden Get oder Set hinzu. " }, 
{ "title" : "Eingabeunterstützung beim Erzeugen von erbenden Bausteinen ", 
"url" : "_cds_obj_property.html#UUID-9c407fa5-d8b8-4172-1c22-5219eeec8317_UUID-e3a7d561-c8bd-ff0c-4eda-2e6419e8e10f", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Eigenschaft \/ Eingabeunterstützung beim Erzeugen von erbenden Bausteinen ", 
"snippet" : "Wenn Sie objektorientiert programmieren und die Vererbung (Schlüsselwort EXTENDS ) von Bausteinen nutzen, können Sie folgendermaßen Unterstützung erhalten: Wenn Sie unterhalb eines von einem Basisbaustein abgeleiteten Bausteins eine Aktion, Eigenschaft, Methode oder Transition einfügen, öffnet sich ...", 
"body" : "Wenn Sie objektorientiert programmieren und die Vererbung (Schlüsselwort EXTENDS ) von Bausteinen nutzen, können Sie folgendermaßen Unterstützung erhalten: Wenn Sie unterhalb eines von einem Basisbaustein abgeleiteten Bausteins eine Aktion, Eigenschaft, Methode oder Transition einfügen, öffnet sich der Dialog … hinzufügen . Dort ist das Eingabefeld für den Namen erweitert zu einer Combobox. Die Auswahlliste der Combobox enthält eine gültige Auswahl aus den im Basisbaustein vorhandenen Aktionen, Eigenschaften, Methoden oder Transitionen. Nun können Sie beispielsweise eine Methode des Basisbausteins auf einfache Weise zunächst übernehmen, um sie dann entsprechend für die abgeleitete Funktion des Bausteins anzupassen. Methoden und Eigenschaften mit dem Zugriffsmodifizierer PRIVATE erscheinen in dieser Auswahl nicht, da sie auch nicht vererbt werden. Methoden und Eigenschaften mit dem Zugriffsmodifizierer PUBLIC erhalten beim Übernehmen in den abgeleiteten Baustein automatisch ein leeres Zugriffsmodifiziererfeld, was funktional das Gleiche bedeutet. Für weitere Informationen siehe: Eigenschaft, Methode, Transition, Aktion, Beispiel " }, 
{ "title" : "Objekt: Aktion ", 
"url" : "_cds_obj_action.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Aktion ", 
"snippet" : "Aktion Symbol: Sie können einem Funktionsbaustein oder einem Programm Aktionen hinzufügen. Jede Aktion hat einen Namen. Das Aktionsobjekt implementiert zusätzlichen Code, der in einer anderen Sprache programmiert sein kann als die Basisimplementierung des übergeordneten Programmierbausteins. Aktione...", 
"body" : "Aktion Symbol: Sie können einem Funktionsbaustein oder einem Programm Aktionen hinzufügen. Jede Aktion hat einen Namen. Das Aktionsobjekt implementiert zusätzlichen Code, der in einer anderen Sprache programmiert sein kann als die Basisimplementierung des übergeordneten Programmierbausteins. Aktionen werden häufig in AS implementiert. Eine Aktion hat keine eigene Variablendeklaration. Sie arbeitet mit den Daten ihrer übergeordneten Basisimplementierung und verwendet deren Variablen ( VAR , VAR_INPUT , VAR_OUTPUT , VAR_IN_OUT ). In der objektorientierten Programmierung ist es möglich, einen Funktionsbaustein zusammen mit seinen untergeordneten Aktionen zu vererben. Für weitere Informationen siehe: Eingabeunterstützung beim Erzeugen von erbenden Bausteinen, Aufruf Syntax: <program name> . <action name> ( <parameter passing> ) oder <name of function block instance> . <action name> ( <parameter passing> ) <program name> . Optional Instanzpfad mit Name des Programms Wenn eine Aktion in der zugehörigen Basisimplementierung des Programms aufgerufen wird, genügt die Angabe des Aktionsnamens. <name of function block instance> . Optional Instanzpfad mit Name der Funktionsbaustein-Instanz Wenn eine Aktion in der zugehörigen Basisimplementierung des Funktionsbausteins aufgerufen wird, genügt die Angabe des Aktionsnamens. <action name> Obligatorisch Name der Aktion ( <parameter passing> ) Optional Bei der Parameterübergabe können so wie beim zugehörigen Funktionsbaustein Argumente an die Eingabe- und Ausgabevariablen übergeben werden. Siehe FunktionsbausteinDie in der Aktion verfügbaren Variablen sind im übergeordneten Baustein deklariert. Gleichwohl können beim Aktionsaufruf Parameter übergeben werden. Es kann auf die Variablen ( VAR , VAR_INPUT , VAR_OUTPUT , VAR_IN_OUT ) des übergeordneten Programms oder der Funktionsbaustein-Instanz (anders als beim Methodenaufruf) zugegriffen werden. Beim Aufruf einer Aktion in einem grafischen Editoren werden deshalb alle E\/As des Basisbausteins angezeigt. Beispiel Aufrufe der Aktion Reset (Funktionsbaustein Counter ) von einer anderen POU aus. Instanzierung des Funktionsbausteins PROGRAM PLC_PRG\nVAR\n Inst : Counter;\nEND_VAR Aufruf der Aktion Reset in AWL CAL Inst.Reset(In := FALSE)\nLD Inst.Out\nST ERG Aufruf der Aktion Reset in ST Inst.Reset(In := FALSE);\nErg := Inst.out; Aufruf der Aktion Reset in FUP Beispiel Deklaration des Funktionsbausteins FB_Test FUNCTION_BLOCK FB_Test\nVAR_INPUT\n i_xTest : BOOL;\n i_lrTest : LREAL;\nEND_VAR\nVAR_OUTPUT\n q_xTest : BOOL;\n q_lrTest : LREAL;\nEND_VAR\nVAR\n xSet : BOOL;\n xReset : BOOL;\n SR_0 : SR;\n R_TRIG_0 : R_TRIG;\nEND_VAR Implementierung der Aktion Act_Text (in FUP) mit Zugriff auf die E\/As des zugehörigen Funktionsbausteins Aktionen werden häufig in der Implementierungssprache AS verwendet. " }, 
{ "title" : "Aktion einfügen ", 
"url" : "_cds_obj_action.html#UUID-d3c3a161-09fa-9c3d-d5e0-951656fa2f3d_section-idm234809879408146", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Aktion \/ Aktion einfügen ", 
"snippet" : "Sie fügen einem Funktionsbaustein oder einem Programm eine Aktion mit dem Befehl Projekt → Objekt hinzufügen → Aktion hinzu und legen die Eigenschaften der neuen Aktion im sich öffnenden Dialog fest. Aktion hinzufügen Name Name der Aktion Implementierungssprache Ausgewählt aus der Combobox-Liste mit...", 
"body" : "Sie fügen einem Funktionsbaustein oder einem Programm eine Aktion mit dem Befehl Projekt → Objekt hinzufügen → Aktion hinzu und legen die Eigenschaften der neuen Aktion im sich öffnenden Dialog fest. Aktion hinzufügen Name Name der Aktion Implementierungssprache Ausgewählt aus der Combobox-Liste mit den verfügbaren Implementierungssprachen " }, 
{ "title" : "Objekt: Transition ", 
"url" : "_cds_obj_transition.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Transition ", 
"snippet" : "Transition Symbol: Das Objekt kann in einem in Ablaufsprache implementierten Programmbaustein als Transitionselement verwendet werden. Für weitere Informationen siehe: AS-Elemente: Schritt \/ Transition...", 
"body" : "Transition Symbol: Das Objekt kann in einem in Ablaufsprache implementierten Programmbaustein als Transitionselement verwendet werden. Für weitere Informationen siehe: AS-Elemente: Schritt \/ Transition " }, 
{ "title" : "Eingabeunterstützung beim Erzeugen von erbenden Bausteinen ", 
"url" : "_cds_obj_transition.html#UUID-ec6c8ad0-aa77-27a0-2637-e1d57601e639_UUID-e3a7d561-c8bd-ff0c-4eda-2e6419e8e10f", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU \/ Objekt: Transition \/ Eingabeunterstützung beim Erzeugen von erbenden Bausteinen ", 
"snippet" : "Wenn Sie objektorientiert programmieren und die Vererbung (Schlüsselwort EXTENDS ) von Bausteinen nutzen, können Sie folgendermaßen Unterstützung erhalten: Wenn Sie unterhalb eines von einem Basisbaustein abgeleiteten Bausteins eine Aktion, Eigenschaft, Methode oder Transition einfügen, öffnet sich ...", 
"body" : "Wenn Sie objektorientiert programmieren und die Vererbung (Schlüsselwort EXTENDS ) von Bausteinen nutzen, können Sie folgendermaßen Unterstützung erhalten: Wenn Sie unterhalb eines von einem Basisbaustein abgeleiteten Bausteins eine Aktion, Eigenschaft, Methode oder Transition einfügen, öffnet sich der Dialog … hinzufügen . Dort ist das Eingabefeld für den Namen erweitert zu einer Combobox. Die Auswahlliste der Combobox enthält eine gültige Auswahl aus den im Basisbaustein vorhandenen Aktionen, Eigenschaften, Methoden oder Transitionen. Nun können Sie beispielsweise eine Methode des Basisbausteins auf einfache Weise zunächst übernehmen, um sie dann entsprechend für die abgeleitete Funktion des Bausteins anzupassen. Methoden und Eigenschaften mit dem Zugriffsmodifizierer PRIVATE erscheinen in dieser Auswahl nicht, da sie auch nicht vererbt werden. Methoden und Eigenschaften mit dem Zugriffsmodifizierer PUBLIC erhalten beim Übernehmen in den abgeleiteten Baustein automatisch ein leeres Zugriffsmodifiziererfeld, was funktional das Gleiche bedeutet. Für weitere Informationen siehe: Eigenschaft, Methode, Transition, Aktion, Beispiel " }, 
{ "title" : "Objekt: POUs für implizite Prüfungen ", 
"url" : "_cds_f_obj_pous_implicit_check.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen ", 
"snippet" : "POUs für implizite Prüfungen Diese speziellen POUs können Sie zu einer Applikation hinzufügen, um sie mit implizit zur Verfügung gestellten Überwachungsfunktionalitäten auszustatten. Diese Funktionen überprüfen während der Laufzeit die Grenzen von Arrays oder Unterbereichstypen, die Gültigkeit von P...", 
"body" : "POUs für implizite Prüfungen Diese speziellen POUs können Sie zu einer Applikation hinzufügen, um sie mit implizit zur Verfügung gestellten Überwachungsfunktionalitäten auszustatten. Diese Funktionen überprüfen während der Laufzeit die Grenzen von Arrays oder Unterbereichstypen, die Gültigkeit von Pointeradressen oder eine Division durch Null. Beachten Sie, dass diese Möglichkeit bei Geräten deaktiviert sein kann, wenn solche Prüfbausteine durch eine spezielle implizite Bibliothek bereitgestellt werden. Das Hinzufügen zur Applikation erfolgt mit Hilfe des Befehls Objekt hinzufügen → POU für implizite Prüfungen . Der Befehl öffnet den Dialog POU für implizite Prüfungen hinzufügen , wo Sie einen der Überwachungsfunktionstypen auswählen können, siehe Tabelle unten. Je nach Überwachungsfunktion müssen Sie den Implementierungscode anpassen oder komplett selbst verfassen. Um ein mehrfaches Einbinden zu verhindern, steht eine bereits eingefügte Überwachungsfunktion im Dialog Objekt einfügen nicht mehr zur Auswahl. Für weitere Informationen siehe: Bausteine für implizite Prüfungen verwendenUm die Funktionalität der Überwachungsfunktionen zu erhalten, dürfen Sie deren Deklarationsteil nicht verändern. Als einzige Ausnahme dürfen Sie lokale Variablen hinzufügen. Nach dem Entfernen impliziter Überwachungsfunktionen (beispielsweise CheckBounds ) aus dem Projekt ist kein Online-Change mehr möglich, nur ein Download. Eine entsprechende Meldung wird ausgegeben. CODESYS führt implizite Prüfungen standardmäßig nicht für Bausteine aus den in der Applikation verwendeten Bibliotheken aus. Sie können die Prüfung jedoch folgendermaßen auf die Bibliotheken ausweiten: Öffnen Sie den Dialog Eigenschaften der Applikation und tragen Sie auf der Registerkarte Build im Feld Compiler-Defines die Compilerdefinition checks_in_libs ein. Diese Definition wirkt sich jedoch nur auf Implementierungsbibliotheken ( *.library ) aus, nicht auf geschützte Bibliotheken ( *.compiled-library ). Sie können die Prüfung spezieller POUs im Projekt mit dem Attribut „no_check“ deaktivieren. Verfügbare Funktionen Überwachungsfunktion Typ CheckBounds Feldgrenzenprüfungen Angemessene Behandlung von Verletzungen von Feldgrenzen (beispielsweise durch Setzen eines Fehlerflags oder durch Verändern des Feldindex) CheckDivDInt Divisionsprüfungen : Überwachung des Divisorwerts, um ein Dividieren durch 0 zu vermeiden CheckDivLInt CheckDivReal CheckDivLReal CheckRangeSigned Bereichsprüfungen : Überwachung der Bereichsgrenzen eines Unterbereichstypen während der Laufzeit Gilt für die Datentypen DINT \/ UDINT CheckRangeUnsigned CheckLRangeSigned L-Bereichsprüfungen : Überwachung der Bereichsgrenzen eines Unterbereichstypen während der Laufzeit Gilt für die Datentypen LINT \/ ULINT CheckLRangeUnsigned CheckPointer Pointerprüfungen Diese Funktion müssen Sie komplett selbst mit Implementierungscode füllen. Sehen Sie dazu die Hilfeseite zu „POU ‚CheckPointer‘“. Die Funktion soll überwachen, ob der übergebene Pointer auf eine gültige Speicheradresse verweist und ob die Ausrichtung des referenzierten Speicherbereichs zum Typ der Variablen passt, auf die der Pointer verweist. Wenn beide Bedingungen erfüllt sind, wird der Pointer selbst zurückgegeben. Andernfalls sollte CheckPointer eine angemessene Fehlerbehandlung durchführen. CheckPointer überwacht in der gleichen Weise auch Variablen vom Typ REFERENCE TO . " }, 
{ "title" : "POU: CheckBounds ", 
"url" : "_cds_obj_pou_checkbounds.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen \/ POU: CheckBounds ", 
"snippet" : "CheckBounds Die Aufgabe dieser Überwachungsfunktion ist eine angemessene Behandlung von Verletzungen von Feldgrenzen. Eine Reaktion auf eine Verletzung kann beispielsweise das Setzen eines Error-Flags oder das Verändern des Arrayindex sein. Die Prüfung erfolgt nur bei einem variablen Feldindex. Ein ...", 
"body" : "CheckBounds Die Aufgabe dieser Überwachungsfunktion ist eine angemessene Behandlung von Verletzungen von Feldgrenzen. Eine Reaktion auf eine Verletzung kann beispielsweise das Setzen eines Error-Flags oder das Verändern des Arrayindex sein. Die Prüfung erfolgt nur bei einem variablen Feldindex. Ein fehlerhafter konstanter Arrayindex führt zu einem Compilerfehler. CODESYS ruft die Funktion implizit auf sobald einer Variablen vom Typ ARRAY -Werte zugewiesen werden. Für weitere Informationen siehe: Bausteine für implizite Prüfungen verwenden, Bausteine für implizite Prüfungen verwendenNach dem Einfügen der Funktion erhalten Sie automatisch erzeugten Code in Deklarationsteil und Implementierungsteil. Siehe unten. Um die Funktionalität der Überwachungsfunktionen zu erhalten, dürfen Sie den Deklarationsteil nicht verändern. Als einzige Ausnahme dürfen Sie lokale Variablen hinzufügen. Deklarationsteil \/\/ Automatisch erzeugter Code : NICHT EDITIEREN\nFUNCTION CheckBounds : DINT\nVAR_INPUT\n index, lower, upper: DINT;\nEND_VAR Implementierung \/\/ Automatisch erzeugter Code: Es handelt sich hierbei um einen Implementierungsvorschlag.\nIF index < lower THEN\n CheckBounds := lower;\nELSIF index > upper THEN\n CheckBounds := upper;\nELSE\n CheckBounds := index;\nEND_IF\n\n(* It is also possible to set a breakpoint, log messages or e.g. to halt on an exception:\nAdd CmpApp.library, SysExcept.library and SysTypes2_Itf as newest.\nDeclaration:\nVAR\n _pApp : POINTER TO CmpApp.APPLICATION;\n _result : SysTypes.RTS_IEC_RESULT;\nEND_VAR\n\nImplementation:\n_pApp := AppGetCurrent(pResult:=_result);\nIF index < lower THEN\n CheckBounds := lower;\n IF _pApp <> 0 THEN\n AppGenerateException(pApp:=_pApp, ulException:=RtsExceptions.RTSEXCPT_ARRAYBOUNDS);\n END_IF\nELSIF index > upper THEN\n CheckBounds := upper;\n IF _pApp <> 0 THEN\n AppGenerateException(pApp:=_pApp, ulException:=RtsExceptions.RTSEXCPT_ARRAYBOUNDS);\n END_IF\nELSE\n CheckBounds := index;\nEND_IF\n*) Beim Aufruf erhält die Funktion CheckBounds folgende Eingangsparameter: index :  Index des Arrayelements lower : Untergrenze des Arraybereichs upper : Obergrenze des Arraybereichs Rückgabewert ist der Index des Arrayelements, sofern sich dieser im gültigen Bereich befindet. Ansonsten gibt CODESYS je nach Verletzung des Grenzbereichs die Ober- oder  Untergrenze zurück. Beispiel: Korrektur des Zugriffs auf ein Array außerhalb der definierten Arraygrenzen Im unten stehenden Beispielprogramm unterschreitet der Index die definierte Untergrenze des Arrays a . PROGRAM PLC_PRG\nVAR\n a: ARRAY[0..7] OF BOOL;\n b: INT:=10;\nEND_VAR\n\na[b]:=TRUE; Die Funktion CheckBounds bewirkt in diesem Beispiel, dass der Index 10 in die Obergrenze des Arraybereichs von a abgeändert wird. Damit wird der Wert TRUE dem Element a[7] zugewiesen. Auf diese Weise korrigiert die Funktion Arrayzugriffe außerhalb des gültigen Arraybereichs. Beispiel: Ausgabe einer Ausnahme bei Verletzung von Arraygrenzen Fügen Sie im Bibliotheksverwalter der Applikation folgende Bibliotheken ein: CmpApp.library und SysExcept.library als Platzhalterbibliotheken SysTypes2_Itfs.library mit Immer neueste Version Fügen Sie ein Objekt CheckBounds unter der Applikation ein und ändern Sie den vorgegebenen Code wie folgt: Deklarationsteil FUNCTION CheckBounds : DINT\nVAR_INPUT\n index, lower, upper: DINT;\nEND_VAR\nVAR\n _pApp : POINTER TO CmpApp.APPLICATION;\n _Result : ISystypes2.RTS_IEC_RESULT;\nEND_VAR Implementierungsteil \/\/ Automatisch erzeugter Code: Es handelt sich hierbei um einen Implementierungsvorschlag.\n_pApp := AppGetCurrent(pResult := _Result);\nIF index < lower THEN\n CheckBounds := lower;\n IF _pApp <> 0 THEN\n AppGenerateException(pApp := _pApp, ulException := RtsExceptions.RTSEXCPT_ARRAYBOUNDS);\n END_IF\nELSIF index > upper THEN\n CheckBounds := upper;\n IF _pApp <> 0 THEN\n AppGenerateException(pApp:=_pApp, ulException:=RtsExceptions.RTSEXCPT_ARRAYBOUNDS);\n END_IF\nELSE\n CheckBounds := index;\nEND_IF Programmieren Sie ein Objekt MAIN_PRG mit dem unten gezeigten Inhalt unter der Applikation. PROGRAM MAIN_PRG\nVAR\n xInit : BOOL;\n arData : ARRAY[0..7] OF BYTE;\n i : INT;\n dwAdr : DWORD;\nEND_VAR\n\nIF NOT xInit THEN\n \/\/ Erforderlich für CheckBounds\n xInit := TRUE;\nEND_IF\n\n\/\/ Setze i auf einen Wert > 7 oder < 0\n\/\/ Generiert eine Exception in CheckBounds, Benutzerdefiniert\narData[i] := 11; Wenn Sie diese Applikation laden und starten, wird bei Verletzung der Arraygrenzen eine „Exception“ generiert. Die Abarbeitung stoppt in CheckBounds , so dass die Art des Fehlers erkenntlich ist. " }, 
{ "title" : "POU: CheckDivInt ", 
"url" : "_cds_obj_pou_checkdivint.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen \/ POU: CheckDivInt ", 
"snippet" : "CheckDivInt...", 
"body" : "CheckDivInt " }, 
{ "title" : "Funktionen zur Vermeidung des Divisor-Werts \"0“: CheckDivInt, CheckDivLint, CheckDivReal und CheckDivLReal ", 
"url" : "_cds_obj_pou_checkdivint.html#UUID-072cf6e7-5009-f5d9-a6f2-cfb7ba93eb0e_UUID-4cc55957-06e7-1250-5de0-d97f7051f0e6", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen \/ POU: CheckDivInt \/ Funktionen zur Vermeidung des Divisor-Werts \"0“: CheckDivInt, CheckDivLint, CheckDivReal und CheckDivLReal ", 
"snippet" : "Um ein Teilen durch 0 zu vermeiden, können Sie die Funktionen CheckDivInt , CheckDivLint , CheckDivReal und CheckDivLReal verwenden. Wenn Sie diese Funktionen in die Applikation einbinden, werden sie vor jeder im Code auftretenden Division aufgerufen. Für weitere Informationen siehe: Bausteine für i...", 
"body" : "Um ein Teilen durch 0 zu vermeiden, können Sie die Funktionen CheckDivInt , CheckDivLint , CheckDivReal und CheckDivLReal verwenden. Wenn Sie diese Funktionen in die Applikation einbinden, werden sie vor jeder im Code auftretenden Division aufgerufen. Für weitere Informationen siehe: Bausteine für implizite Prüfungen verwenden, POUs für implizite PrüfungenUm die Funktionalität der Überwachungsfunktionen zu erhalten, dürfen Sie den Deklarationsteil nicht verändern. Als einzige Ausnahme dürfen Sie lokale Variablen hinzufügen. Standardmäßige Implementierung der Funktion CheckDivReal: Deklarationsteil: \/\/ Automatisch erzeugter Code : NICHT EDITIEREN\nFUNCTION CheckDivReal : REAL\nVAR_INPUT\n divisor:REAL;\nEND_VAR Implementierungsteil: \/\/ Automatisch erzeugter Code: Es handelt sich hierbei um einen Implementierungsvorschlag.\nIF divisor = 0 THEN\n CheckDivReal:=1;\nELSE\n CheckDivReal:=divisor;\nEND_IF; Der Operator DIV verwendet die Ausgabe der Funktion CheckDivReal als Divisor. In unten stehenden Beispielprogramm verhindert diese Funktion eine Division durch 0 dadurch, dass der implizit mit „0“ initiierte Wert des Divisors d vor Ausführung der Teilung von der Funktion CheckDivReal in 1 geändert wird. Somit lautet das Ergebnis der Division 799 . PROGRAM PLC_PRG\nVAR\n erg:REAL;\n v1:REAL:=799;\n d:REAL:=0;\nEND_VAR\nerg:= v1 \/ d; " }, 
{ "title" : "POU: CheckDivLInt ", 
"url" : "_cds_obj_pou_checkdivlint.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen \/ POU: CheckDivLInt ", 
"snippet" : "CheckDivLInt...", 
"body" : "CheckDivLInt " }, 
{ "title" : "Funktionen zur Vermeidung des Divisor-Werts \"0“: CheckDivInt, CheckDivLint, CheckDivReal und CheckDivLReal ", 
"url" : "_cds_obj_pou_checkdivlint.html#UUID-99e0b883-c84e-9caf-1987-091b2733937f_UUID-4cc55957-06e7-1250-5de0-d97f7051f0e6", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen \/ POU: CheckDivLInt \/ Funktionen zur Vermeidung des Divisor-Werts \"0“: CheckDivInt, CheckDivLint, CheckDivReal und CheckDivLReal ", 
"snippet" : "Um ein Teilen durch 0 zu vermeiden, können Sie die Funktionen CheckDivInt , CheckDivLint , CheckDivReal und CheckDivLReal verwenden. Wenn Sie diese Funktionen in die Applikation einbinden, werden sie vor jeder im Code auftretenden Division aufgerufen. Für weitere Informationen siehe: Bausteine für i...", 
"body" : "Um ein Teilen durch 0 zu vermeiden, können Sie die Funktionen CheckDivInt , CheckDivLint , CheckDivReal und CheckDivLReal verwenden. Wenn Sie diese Funktionen in die Applikation einbinden, werden sie vor jeder im Code auftretenden Division aufgerufen. Für weitere Informationen siehe: Bausteine für implizite Prüfungen verwenden, POUs für implizite PrüfungenUm die Funktionalität der Überwachungsfunktionen zu erhalten, dürfen Sie den Deklarationsteil nicht verändern. Als einzige Ausnahme dürfen Sie lokale Variablen hinzufügen. Standardmäßige Implementierung der Funktion CheckDivReal: Deklarationsteil: \/\/ Automatisch erzeugter Code : NICHT EDITIEREN\nFUNCTION CheckDivReal : REAL\nVAR_INPUT\n divisor:REAL;\nEND_VAR Implementierungsteil: \/\/ Automatisch erzeugter Code: Es handelt sich hierbei um einen Implementierungsvorschlag.\nIF divisor = 0 THEN\n CheckDivReal:=1;\nELSE\n CheckDivReal:=divisor;\nEND_IF; Der Operator DIV verwendet die Ausgabe der Funktion CheckDivReal als Divisor. In unten stehenden Beispielprogramm verhindert diese Funktion eine Division durch 0 dadurch, dass der implizit mit „0“ initiierte Wert des Divisors d vor Ausführung der Teilung von der Funktion CheckDivReal in 1 geändert wird. Somit lautet das Ergebnis der Division 799 . PROGRAM PLC_PRG\nVAR\n erg:REAL;\n v1:REAL:=799;\n d:REAL:=0;\nEND_VAR\nerg:= v1 \/ d; " }, 
{ "title" : "POU: CheckDivReal ", 
"url" : "_cds_obj_pou_checkdivreal.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen \/ POU: CheckDivReal ", 
"snippet" : "CheckDivReal...", 
"body" : "CheckDivReal " }, 
{ "title" : "Funktionen zur Vermeidung des Divisor-Werts \"0“: CheckDivInt, CheckDivLint, CheckDivReal und CheckDivLReal ", 
"url" : "_cds_obj_pou_checkdivreal.html#UUID-c703e521-3496-9988-34a7-a889e5d5836b_UUID-4cc55957-06e7-1250-5de0-d97f7051f0e6", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen \/ POU: CheckDivReal \/ Funktionen zur Vermeidung des Divisor-Werts \"0“: CheckDivInt, CheckDivLint, CheckDivReal und CheckDivLReal ", 
"snippet" : "Um ein Teilen durch 0 zu vermeiden, können Sie die Funktionen CheckDivInt , CheckDivLint , CheckDivReal und CheckDivLReal verwenden. Wenn Sie diese Funktionen in die Applikation einbinden, werden sie vor jeder im Code auftretenden Division aufgerufen. Für weitere Informationen siehe: Bausteine für i...", 
"body" : "Um ein Teilen durch 0 zu vermeiden, können Sie die Funktionen CheckDivInt , CheckDivLint , CheckDivReal und CheckDivLReal verwenden. Wenn Sie diese Funktionen in die Applikation einbinden, werden sie vor jeder im Code auftretenden Division aufgerufen. Für weitere Informationen siehe: Bausteine für implizite Prüfungen verwenden, POUs für implizite PrüfungenUm die Funktionalität der Überwachungsfunktionen zu erhalten, dürfen Sie den Deklarationsteil nicht verändern. Als einzige Ausnahme dürfen Sie lokale Variablen hinzufügen. Standardmäßige Implementierung der Funktion CheckDivReal: Deklarationsteil: \/\/ Automatisch erzeugter Code : NICHT EDITIEREN\nFUNCTION CheckDivReal : REAL\nVAR_INPUT\n divisor:REAL;\nEND_VAR Implementierungsteil: \/\/ Automatisch erzeugter Code: Es handelt sich hierbei um einen Implementierungsvorschlag.\nIF divisor = 0 THEN\n CheckDivReal:=1;\nELSE\n CheckDivReal:=divisor;\nEND_IF; Der Operator DIV verwendet die Ausgabe der Funktion CheckDivReal als Divisor. In unten stehenden Beispielprogramm verhindert diese Funktion eine Division durch 0 dadurch, dass der implizit mit „0“ initiierte Wert des Divisors d vor Ausführung der Teilung von der Funktion CheckDivReal in 1 geändert wird. Somit lautet das Ergebnis der Division 799 . PROGRAM PLC_PRG\nVAR\n erg:REAL;\n v1:REAL:=799;\n d:REAL:=0;\nEND_VAR\nerg:= v1 \/ d; " }, 
{ "title" : "POU: CheckDivLReal ", 
"url" : "_cds_obj_pou_checkdivlreal.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen \/ POU: CheckDivLReal ", 
"snippet" : "CheckDivLReal...", 
"body" : "CheckDivLReal " }, 
{ "title" : "Funktionen zur Vermeidung des Divisor-Werts \"0“: CheckDivInt, CheckDivLint, CheckDivReal und CheckDivLReal ", 
"url" : "_cds_obj_pou_checkdivlreal.html#UUID-84677e37-4182-0e45-f4bf-d23f7f7919b1_UUID-4cc55957-06e7-1250-5de0-d97f7051f0e6", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen \/ POU: CheckDivLReal \/ Funktionen zur Vermeidung des Divisor-Werts \"0“: CheckDivInt, CheckDivLint, CheckDivReal und CheckDivLReal ", 
"snippet" : "Um ein Teilen durch 0 zu vermeiden, können Sie die Funktionen CheckDivInt , CheckDivLint , CheckDivReal und CheckDivLReal verwenden. Wenn Sie diese Funktionen in die Applikation einbinden, werden sie vor jeder im Code auftretenden Division aufgerufen. Für weitere Informationen siehe: Bausteine für i...", 
"body" : "Um ein Teilen durch 0 zu vermeiden, können Sie die Funktionen CheckDivInt , CheckDivLint , CheckDivReal und CheckDivLReal verwenden. Wenn Sie diese Funktionen in die Applikation einbinden, werden sie vor jeder im Code auftretenden Division aufgerufen. Für weitere Informationen siehe: Bausteine für implizite Prüfungen verwenden, POUs für implizite PrüfungenUm die Funktionalität der Überwachungsfunktionen zu erhalten, dürfen Sie den Deklarationsteil nicht verändern. Als einzige Ausnahme dürfen Sie lokale Variablen hinzufügen. Standardmäßige Implementierung der Funktion CheckDivReal: Deklarationsteil: \/\/ Automatisch erzeugter Code : NICHT EDITIEREN\nFUNCTION CheckDivReal : REAL\nVAR_INPUT\n divisor:REAL;\nEND_VAR Implementierungsteil: \/\/ Automatisch erzeugter Code: Es handelt sich hierbei um einen Implementierungsvorschlag.\nIF divisor = 0 THEN\n CheckDivReal:=1;\nELSE\n CheckDivReal:=divisor;\nEND_IF; Der Operator DIV verwendet die Ausgabe der Funktion CheckDivReal als Divisor. In unten stehenden Beispielprogramm verhindert diese Funktion eine Division durch 0 dadurch, dass der implizit mit „0“ initiierte Wert des Divisors d vor Ausführung der Teilung von der Funktion CheckDivReal in 1 geändert wird. Somit lautet das Ergebnis der Division 799 . PROGRAM PLC_PRG\nVAR\n erg:REAL;\n v1:REAL:=799;\n d:REAL:=0;\nEND_VAR\nerg:= v1 \/ d; " }, 
{ "title" : "POU: CheckRangeSigned ", 
"url" : "_cds_obj_pou_checkrangesigned.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen \/ POU: CheckRangeSigned ", 
"snippet" : "CheckRangeSigned Funktion zur Überwachung der Bereichsgrenzen eines Unterbereichstypen vom Typ DINT Beispiel für CheckRangeSigned Wird einer DINT-Variablen eines vorzeichenbehafteten Unterbereichstyps ein Wert zugewiesen, so bedingt dies einen automatischen Aufruf der Funktion CheckRangeSigned . Die...", 
"body" : "CheckRangeSigned Funktion zur Überwachung der Bereichsgrenzen eines Unterbereichstypen vom Typ DINT Beispiel für CheckRangeSigned Wird einer DINT-Variablen eines vorzeichenbehafteten Unterbereichstyps ein Wert zugewiesen, so bedingt dies einen automatischen Aufruf der Funktion CheckRangeSigned . Die Funktion, welche den Zuweisungswert auf den bei der Variablendeklaration festgesetzten Unterbereich beschränkt,  ist standardmäßig wie folgt in ST implementiert: Deklarationsteil: \/\/ Automatisch erzeugter Code : NICHT EDITIEREN\nFUNCTION CheckRangeSigned : DINT\nVAR_INPUT\n value, lower, upper: DINT;\nEND_VAR Implementierung: \/\/ Automatisch erzeugter Code : Es handelt sich hierbei um einen Implementierungsvorschlag.\nIF (value < lower) THEN\n CheckRangeSigned := lower;\n ELSEIF(value > upper) THEN\n CheckRangeSigned := upper;\nELSE\n CheckRangeSigned := value;\nEND_VAR " }, 
{ "title" : "Bereichsgrenzen überwachen ", 
"url" : "_cds_obj_pou_checkrangesigned.html#UUID-966e7cc4-b54e-471f-136b-0a28b2c4f30a_UUID-2f40e0a8-a491-b3cc-9231-f5c35a224dd7", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen \/ POU: CheckRangeSigned \/ Bereichsgrenzen überwachen ", 
"snippet" : "Aufgabe dieser Überwachungsfunktion ist eine angemessene Behandlung von Verletzungen der Bereichsgrenzen. Eine Reaktion auf eine Verletzung kann beispielsweise das Setzen eines Error-Flags oder das Verändern eines Wertes sein. Der Aufruf der Funktionen erfolgt implizit bei der Zuweisung eines Wertes...", 
"body" : "Aufgabe dieser Überwachungsfunktion ist eine angemessene Behandlung von Verletzungen der Bereichsgrenzen. Eine Reaktion auf eine Verletzung kann beispielsweise das Setzen eines Error-Flags oder das Verändern eines Wertes sein. Der Aufruf der Funktionen erfolgt implizit bei der Zuweisung eines Wertes an eine Variable vom Unterbereichstyp. Um die Funktionalität der Überwachungsfunktionen zu erhalten, dürfen Sie den Deklarationsteil nicht verändern. Als einzige Ausnahme dürfen Sie lokale Variablen hinzufügen. Beim Aufruf werden der Funktion folgende Eingangsparameter übergeben: value :  Wert der der Variablen vom Unterbereichstyp zugewiesen werden soll lower :  Bereichsuntergrenze upper :  Bereichsobergrenze Rückgabewert ist der Zuweisungswert selbst, sofern sich dieser im gültigen Bereich befindet. Ansonsten wird je nach Verletzung des Unterbereichs seine Ober- oder  Untergrenze zurückgegeben. Die Zuweisung i:=10*y wird nun implizit ersetzt durch i := CheckRangeSigned(10*y, -4095, 4095); Hat y beispielsweise den Wert „1000“, so wird der Variablen i nicht wie im ursprünglichem Code vorgesehen der Wert „10*1000=10000“ zugewiesen, sondern der Wert der Bereichsobergrenze, also  „4095“. Dasselbe gilt für die Funktion CheckRangeUnsigned . Steht Ihnen keine Funktion zur Bereichsüberwachung zur Verfügung,  so erfolgt während der Laufzeit keine Überprüfung des Unterbereichs bei entsprechenden Variablen! In diesem Fall können Sie einer Variablen eines Unterbereichtyps von DINT\/UDINT jeden Wert zwischen -2147483648 und +2147483648 beziehungsweise zwischen 0 und 4294967295 zuweisen! Einer Variablen eines Unterbereichtyps von LINT\/ULINT können Sie dann jeden Wert zwischen – 9223372036854775808 und +9223372036854775807 beziehungsweise zwischen 0 und18446744073709551615 zuweisen! Wenn Sie Bereichsüberwachungsfunktionen einbinden, können Endlosschleifen entstehen. Dies ist beispielsweise der Fall, wenn die Zählvariable einer FOR-Schleife vom Unterbereichstyp ist und der Zählbereich der Schleife den definierten Unterbereich verlässt ! Beispiel einer Endlosschleife: VAR\n ui : UINT (0..10000);\n ...\nEND_VAR FOR ui:=0 TO 10000 DO\n ...\nEND_FOR Das Programm verlässt niemals die FOR-Schleife, da die Überwachungsfunktion CheckRangeSigned verhindert, dass ui auf einen Wert größer als 10000 gesetzt wird. " }, 
{ "title" : "POU: CheckLRangeSigned ", 
"url" : "_cds_obj_pou_checklrangesigned.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen \/ POU: CheckLRangeSigned ", 
"snippet" : "CheckLRangeSigned Funktion zur Überwachung der Bereichsgrenzen eines Unterbereichstypen vom Typ LINT Für ein Implementierungsbeispiel einer Bereichsüberwachung sehen Sie die Hilfeseite zur Funktion CheckRangeSigned ....", 
"body" : "CheckLRangeSigned Funktion zur Überwachung der Bereichsgrenzen eines Unterbereichstypen vom Typ LINT Für ein Implementierungsbeispiel einer Bereichsüberwachung sehen Sie die Hilfeseite zur Funktion CheckRangeSigned . " }, 
{ "title" : "Bereichsgrenzen überwachen ", 
"url" : "_cds_obj_pou_checklrangesigned.html#UUID-f6d1d4fb-cc77-0cb6-74fc-fe5983251696_UUID-2f40e0a8-a491-b3cc-9231-f5c35a224dd7", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen \/ POU: CheckLRangeSigned \/ Bereichsgrenzen überwachen ", 
"snippet" : "Aufgabe dieser Überwachungsfunktion ist eine angemessene Behandlung von Verletzungen der Bereichsgrenzen. Eine Reaktion auf eine Verletzung kann beispielsweise das Setzen eines Error-Flags oder das Verändern eines Wertes sein. Der Aufruf der Funktionen erfolgt implizit bei der Zuweisung eines Wertes...", 
"body" : "Aufgabe dieser Überwachungsfunktion ist eine angemessene Behandlung von Verletzungen der Bereichsgrenzen. Eine Reaktion auf eine Verletzung kann beispielsweise das Setzen eines Error-Flags oder das Verändern eines Wertes sein. Der Aufruf der Funktionen erfolgt implizit bei der Zuweisung eines Wertes an eine Variable vom Unterbereichstyp. Um die Funktionalität der Überwachungsfunktionen zu erhalten, dürfen Sie den Deklarationsteil nicht verändern. Als einzige Ausnahme dürfen Sie lokale Variablen hinzufügen. Beim Aufruf werden der Funktion folgende Eingangsparameter übergeben: value :  Wert der der Variablen vom Unterbereichstyp zugewiesen werden soll lower :  Bereichsuntergrenze upper :  Bereichsobergrenze Rückgabewert ist der Zuweisungswert selbst, sofern sich dieser im gültigen Bereich befindet. Ansonsten wird je nach Verletzung des Unterbereichs seine Ober- oder  Untergrenze zurückgegeben. Die Zuweisung i:=10*y wird nun implizit ersetzt durch i := CheckRangeSigned(10*y, -4095, 4095); Hat y beispielsweise den Wert „1000“, so wird der Variablen i nicht wie im ursprünglichem Code vorgesehen der Wert „10*1000=10000“ zugewiesen, sondern der Wert der Bereichsobergrenze, also  „4095“. Dasselbe gilt für die Funktion CheckRangeUnsigned . Steht Ihnen keine Funktion zur Bereichsüberwachung zur Verfügung,  so erfolgt während der Laufzeit keine Überprüfung des Unterbereichs bei entsprechenden Variablen! In diesem Fall können Sie einer Variablen eines Unterbereichtyps von DINT\/UDINT jeden Wert zwischen -2147483648 und +2147483648 beziehungsweise zwischen 0 und 4294967295 zuweisen! Einer Variablen eines Unterbereichtyps von LINT\/ULINT können Sie dann jeden Wert zwischen – 9223372036854775808 und +9223372036854775807 beziehungsweise zwischen 0 und18446744073709551615 zuweisen! Wenn Sie Bereichsüberwachungsfunktionen einbinden, können Endlosschleifen entstehen. Dies ist beispielsweise der Fall, wenn die Zählvariable einer FOR-Schleife vom Unterbereichstyp ist und der Zählbereich der Schleife den definierten Unterbereich verlässt ! Beispiel einer Endlosschleife: VAR\n ui : UINT (0..10000);\n ...\nEND_VAR FOR ui:=0 TO 10000 DO\n ...\nEND_FOR Das Programm verlässt niemals die FOR-Schleife, da die Überwachungsfunktion CheckRangeSigned verhindert, dass ui auf einen Wert größer als 10000 gesetzt wird. " }, 
{ "title" : "POU: CheckRangeUnsigned ", 
"url" : "_cds_obj_pou_checkrangeunsigned.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen \/ POU: CheckRangeUnsigned ", 
"snippet" : "CheckRangeUnsigned Funktion zur Überwachung der Bereichsgrenzen eines Unterbereichstypen vom Typ UDINT Für ein Implementierungsbeispiel einer Bereichsüberwachung sehen Sie die Hilfeseite zur Funktion CheckRangeSigned ....", 
"body" : "CheckRangeUnsigned Funktion zur Überwachung der Bereichsgrenzen eines Unterbereichstypen vom Typ UDINT Für ein Implementierungsbeispiel einer Bereichsüberwachung sehen Sie die Hilfeseite zur Funktion CheckRangeSigned . " }, 
{ "title" : "Bereichsgrenzen überwachen ", 
"url" : "_cds_obj_pou_checkrangeunsigned.html#UUID-8eaae037-91f2-889d-1075-c38a20b7f3b4_UUID-2f40e0a8-a491-b3cc-9231-f5c35a224dd7", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen \/ POU: CheckRangeUnsigned \/ Bereichsgrenzen überwachen ", 
"snippet" : "Aufgabe dieser Überwachungsfunktion ist eine angemessene Behandlung von Verletzungen der Bereichsgrenzen. Eine Reaktion auf eine Verletzung kann beispielsweise das Setzen eines Error-Flags oder das Verändern eines Wertes sein. Der Aufruf der Funktionen erfolgt implizit bei der Zuweisung eines Wertes...", 
"body" : "Aufgabe dieser Überwachungsfunktion ist eine angemessene Behandlung von Verletzungen der Bereichsgrenzen. Eine Reaktion auf eine Verletzung kann beispielsweise das Setzen eines Error-Flags oder das Verändern eines Wertes sein. Der Aufruf der Funktionen erfolgt implizit bei der Zuweisung eines Wertes an eine Variable vom Unterbereichstyp. Um die Funktionalität der Überwachungsfunktionen zu erhalten, dürfen Sie den Deklarationsteil nicht verändern. Als einzige Ausnahme dürfen Sie lokale Variablen hinzufügen. Beim Aufruf werden der Funktion folgende Eingangsparameter übergeben: value :  Wert der der Variablen vom Unterbereichstyp zugewiesen werden soll lower :  Bereichsuntergrenze upper :  Bereichsobergrenze Rückgabewert ist der Zuweisungswert selbst, sofern sich dieser im gültigen Bereich befindet. Ansonsten wird je nach Verletzung des Unterbereichs seine Ober- oder  Untergrenze zurückgegeben. Die Zuweisung i:=10*y wird nun implizit ersetzt durch i := CheckRangeSigned(10*y, -4095, 4095); Hat y beispielsweise den Wert „1000“, so wird der Variablen i nicht wie im ursprünglichem Code vorgesehen der Wert „10*1000=10000“ zugewiesen, sondern der Wert der Bereichsobergrenze, also  „4095“. Dasselbe gilt für die Funktion CheckRangeUnsigned . Steht Ihnen keine Funktion zur Bereichsüberwachung zur Verfügung,  so erfolgt während der Laufzeit keine Überprüfung des Unterbereichs bei entsprechenden Variablen! In diesem Fall können Sie einer Variablen eines Unterbereichtyps von DINT\/UDINT jeden Wert zwischen -2147483648 und +2147483648 beziehungsweise zwischen 0 und 4294967295 zuweisen! Einer Variablen eines Unterbereichtyps von LINT\/ULINT können Sie dann jeden Wert zwischen – 9223372036854775808 und +9223372036854775807 beziehungsweise zwischen 0 und18446744073709551615 zuweisen! Wenn Sie Bereichsüberwachungsfunktionen einbinden, können Endlosschleifen entstehen. Dies ist beispielsweise der Fall, wenn die Zählvariable einer FOR-Schleife vom Unterbereichstyp ist und der Zählbereich der Schleife den definierten Unterbereich verlässt ! Beispiel einer Endlosschleife: VAR\n ui : UINT (0..10000);\n ...\nEND_VAR FOR ui:=0 TO 10000 DO\n ...\nEND_FOR Das Programm verlässt niemals die FOR-Schleife, da die Überwachungsfunktion CheckRangeSigned verhindert, dass ui auf einen Wert größer als 10000 gesetzt wird. " }, 
{ "title" : "POU: CheckLRangeUnsigned ", 
"url" : "_cds_obj_pou_checklrangeunsigned.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen \/ POU: CheckLRangeUnsigned ", 
"snippet" : "CheckLRangeUnsigned Funktion zur Überwachung der Bereichsgrenzen eines Unterbereichstypen vom Typ ULINT Für ein Implementierungsbeispiel einer Bereichsüberwachung sehen Sie die Hilfeseite zur Funktion CheckRangeSigned ....", 
"body" : "CheckLRangeUnsigned Funktion zur Überwachung der Bereichsgrenzen eines Unterbereichstypen vom Typ ULINT Für ein Implementierungsbeispiel einer Bereichsüberwachung sehen Sie die Hilfeseite zur Funktion CheckRangeSigned . " }, 
{ "title" : "Bereichsgrenzen überwachen ", 
"url" : "_cds_obj_pou_checklrangeunsigned.html#UUID-8c7f7188-1427-8235-15d4-450140cc7ca9_UUID-2f40e0a8-a491-b3cc-9231-f5c35a224dd7", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen \/ POU: CheckLRangeUnsigned \/ Bereichsgrenzen überwachen ", 
"snippet" : "Aufgabe dieser Überwachungsfunktion ist eine angemessene Behandlung von Verletzungen der Bereichsgrenzen. Eine Reaktion auf eine Verletzung kann beispielsweise das Setzen eines Error-Flags oder das Verändern eines Wertes sein. Der Aufruf der Funktionen erfolgt implizit bei der Zuweisung eines Wertes...", 
"body" : "Aufgabe dieser Überwachungsfunktion ist eine angemessene Behandlung von Verletzungen der Bereichsgrenzen. Eine Reaktion auf eine Verletzung kann beispielsweise das Setzen eines Error-Flags oder das Verändern eines Wertes sein. Der Aufruf der Funktionen erfolgt implizit bei der Zuweisung eines Wertes an eine Variable vom Unterbereichstyp. Um die Funktionalität der Überwachungsfunktionen zu erhalten, dürfen Sie den Deklarationsteil nicht verändern. Als einzige Ausnahme dürfen Sie lokale Variablen hinzufügen. Beim Aufruf werden der Funktion folgende Eingangsparameter übergeben: value :  Wert der der Variablen vom Unterbereichstyp zugewiesen werden soll lower :  Bereichsuntergrenze upper :  Bereichsobergrenze Rückgabewert ist der Zuweisungswert selbst, sofern sich dieser im gültigen Bereich befindet. Ansonsten wird je nach Verletzung des Unterbereichs seine Ober- oder  Untergrenze zurückgegeben. Die Zuweisung i:=10*y wird nun implizit ersetzt durch i := CheckRangeSigned(10*y, -4095, 4095); Hat y beispielsweise den Wert „1000“, so wird der Variablen i nicht wie im ursprünglichem Code vorgesehen der Wert „10*1000=10000“ zugewiesen, sondern der Wert der Bereichsobergrenze, also  „4095“. Dasselbe gilt für die Funktion CheckRangeUnsigned . Steht Ihnen keine Funktion zur Bereichsüberwachung zur Verfügung,  so erfolgt während der Laufzeit keine Überprüfung des Unterbereichs bei entsprechenden Variablen! In diesem Fall können Sie einer Variablen eines Unterbereichtyps von DINT\/UDINT jeden Wert zwischen -2147483648 und +2147483648 beziehungsweise zwischen 0 und 4294967295 zuweisen! Einer Variablen eines Unterbereichtyps von LINT\/ULINT können Sie dann jeden Wert zwischen – 9223372036854775808 und +9223372036854775807 beziehungsweise zwischen 0 und18446744073709551615 zuweisen! Wenn Sie Bereichsüberwachungsfunktionen einbinden, können Endlosschleifen entstehen. Dies ist beispielsweise der Fall, wenn die Zählvariable einer FOR-Schleife vom Unterbereichstyp ist und der Zählbereich der Schleife den definierten Unterbereich verlässt ! Beispiel einer Endlosschleife: VAR\n ui : UINT (0..10000);\n ...\nEND_VAR FOR ui:=0 TO 10000 DO\n ...\nEND_FOR Das Programm verlässt niemals die FOR-Schleife, da die Überwachungsfunktion CheckRangeSigned verhindert, dass ui auf einen Wert größer als 10000 gesetzt wird. " }, 
{ "title" : "POU: CheckPointer ", 
"url" : "_cds_obj_pou_checkpointer.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POUs für implizite Prüfungen \/ POU: CheckPointer ", 
"snippet" : "CheckPointer Überwachungsfunktion Checkpointer für Pointer Verwenden Sie die Funktion, um den Speicherzugriff von Pointern während der Laufzeit zu überwachen.  Im Unterschied zu anderen Überwachungsfunktionen existiert für die Implementierung von CheckPointer kein standardmäßiger Vorschlag; eine Imp...", 
"body" : "CheckPointer Überwachungsfunktion Checkpointer für Pointer Verwenden Sie die Funktion, um den Speicherzugriff von Pointern während der Laufzeit zu überwachen.  Im Unterschied zu anderen Überwachungsfunktionen existiert für die Implementierung von CheckPointer kein standardmäßiger Vorschlag; eine Implementierung ist vom Benutzer selbst vorzunehmen! Die Funktion CheckPointer soll überprüfen, ob der übergebene Pointer auf eine gültige Speicheradresse verweist und ob die Ausrichtung des referenzierten Speicherbereichs zum Typ der Variablen passt, auf die der Pointer verweist. Sind beide Bedingungen erfüllt, so wird der Pointer selbst zurückgegeben. Anderenfalls sollte die Funktion eine angemessene Fehlerbehandlung durchführen. Um die Funktionalität der Überwachungsfunktionen zu erhalten, dürfen Sie den Deklarationsteil nicht verändern. Als einzige Ausnahme dürfen Sie lokale Variablen hinzufügen. Für den THIS -Pointer und den SUPER -Pointer findet kein impliziter Aufruf der Überwachungsfunktion statt. Die Funktion Checkpointer wirkt ab Compiler Version 3.5.7.40 auch auf Variablen vom Typ REFERENCE in gleicher Weise wie auf Pointervariablen. Vorlage Deklaration: \/\/ Automatically generated code: DO NOT EDIT\nFUNCTION CheckPointer : POINTER TO BYTE\nVAR_INPUT\n ptToTest : POINTER TO BYTE;\n iSize : DINT;\n iGran : DINT;\n bWrite: BOOL;\nEND_VAR Implementierung (unvollständig!): \/\/ Not a standard implementation. Insert your code here.\nCheckPointer := ptToTest; Beim Aufruf werden der Funktion folgende Eingabeparameter übergeben: ptToTest :  Zieladresse des Pointers iSize :  Größe der referenzierten Variable; der Datentyp von iSize muss kompatibel sein zu INT und den Größenbereich der Variablen abdecken iGran : Granularität der referenzierten Größe, also der größte in der referenzierten Variablen enthaltene nicht-strukturierte Datentyp; der Datentyp von iGran muss kompatibel sein zu INT bWrite : Art des Zugriffs ( TRUE =Schreibzugriff, FALSE =Lesezugriff); der Datentyp von bWrite muss BOOL sein Bei positivem Ergebnis der Überprüfung wird der unveränderte Eingabepointer zurückgegeben ( ptToTest ). " }, 
{ "title" : "Objekt: POU Locations ", 
"url" : "_cds_obj_pou_locations.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU Locations ", 
"snippet" : "POU Locations Dieses Objekt ist nur bei speziellen Steuerungen verfügbar und wird automatisch im Gerätebaum angezeigt. Das Objekt kann nicht manuell hinzugefügt oder entfernt werden. Das Objekt kann verwendet werden, um den ausführbaren Code einer Applikation in verschiedene Codebereiche auf der Ste...", 
"body" : "POU Locations Dieses Objekt ist nur bei speziellen Steuerungen verfügbar und wird automatisch im Gerätebaum angezeigt. Das Objekt kann nicht manuell hinzugefügt oder entfernt werden. Das Objekt kann verwendet werden, um den ausführbaren Code einer Applikation in verschiedene Codebereiche auf der Steuerung zu verteilen. Insbesondere kleinere Steuerungen haben oft einen beschränkten internen Codebereich (Flash-Speicher). Falls auf der Steuerung ein oder mehrere weitere Codebereiche (zum Beispiel externer Flash-Speicher) zur Verfügung steht\/stehen, kann die Lage der Codebausteine einer Applikation gezielt verändert werden. Im Falle einer Sicherheitssteuerung (SIL2) kann dies auch dazu verwendet werden, nicht-sicherheitsrelevante Codebausteine oder ganze Bibliotheken in diesen externen Speicher zu verschieben. Wenn keine speziellen Vorgaben gemacht werden, dann werden die Codebausteine sequentiell in den Codebereichen abgelegt ( default ). Das heißt: Erst wenn der erste Codebereich gefüllt ist, werden die folgenden Codebausteine in die folgenden Bereiche gelegt. Im Editor POU Locations sehen Sie die aktuelle Lage der Bausteine in den Speicherbereichen und können sie gezielt verändern. Dies kann speziell im Fall einer Sicherheitsapplikation nötig werden, um alle sicheren Bausteine in den sicheren internen Speicherbereich zu bekommen. Für weitere Informationen siehe: Applikationscode auf verschiedene Speicherbereiche verteilen" }, 
{ "title" : "Editor: POU Locations ", 
"url" : "_cds_obj_pou_locations.html#UUID-26ae340b-748e-2b8d-dcb3-138669ca689f_id_d6ed3981f82e321c0a864631448cd76_id_ea2a3b651ff10e9fc0a8646334153b61", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: POU Locations \/ Editor: POU Locations ", 
"snippet" : "Mit einem Doppelklick auf das Objekt POU Locations im Gerätebaum der Steuerung öffnen Sie den Editor. Zunächst enthält dieser nur den Eintrag <Applikation> . Nach einer Codegenerierung werden alle Programmbausteine der Applikation mit ihrem Objekttyp, ihrer aktuellen Position im Speicher und ihrer C...", 
"body" : "Mit einem Doppelklick auf das Objekt POU Locations im Gerätebaum der Steuerung öffnen Sie den Editor. Zunächst enthält dieser nur den Eintrag <Applikation> . Nach einer Codegenerierung werden alle Programmbausteine der Applikation mit ihrem Objekttyp, ihrer aktuellen Position im Speicher und ihrer Codegröße angezeigt. In der Spalte Konfigurierte Position können Sie pro Baustein oder auch pro Bibliothek einen von Aktuelle Position abweichenden Speicherbereich einstellen. Damit die Bausteine an die neu konfigurierten Speicherorte verschoben werden, müssen Sie zunächst Bereinigen und dann erneut Code erzeugen ! Bitte beachten Sie die Meldungen in der Kategorie POU Locations . Hier wird auch angezeigt, falls ein Codebaustein nicht wie erwartet platziert werden kann. Bereinigen Löschen der Übersetzungsinformation für die Applikation Entspricht dem Menübefehl Erstellen → Bereinigen Voraussetzung für das Verschieben der Bausteine an die konfigurierten Speicherorte! Code erzeugen Starten der Codeerzeugung für die Applikation Entspricht dem Menübefehl Erstellen → Code erzeugen Voraussetzung für das Verschieben der Bausteine an die konfigurierten Speicherorte! Objekte Objekte der Applikation, inklusive der Objekte aus den referenzierten Bibliotheken Typ Objekttyp Beispiele: Functionblock , Method , Library Aktuelle Position Aktueller Speicherort des Bausteins: area_<n> Konfigurierte Position Konfigurierter Speicherort, an den der Baustein bei der nächsten Codeerzeugung verschoben wird. Mögliche Werte: default : Automatisch zugewiesener Bereich area_<n> : Explizit zugewiesener Speicherbereich, n=Nummer Codegröße Codegröße des Bausteins in Bytes " }, 
{ "title" : "Objekt: Projekteinstellungen ", 
"url" : "_cds_obj_project_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Projekteinstellungen ", 
"snippet" : "Projekteinstellungen Symbol: Funktion : Das Objekt enthält die Konfiguration des Projekts. Aufruf Menü Projekt → Projekteinstellungen Doppelklick auf das Objekt im Gerätebaum CODESYS speichert die Projekteinstellungen direkt im Projekt. Wenn Sie zum Beispiel ein Projekt auf ein anderes System übertr...", 
"body" : "Projekteinstellungen Symbol: Funktion : Das Objekt enthält die Konfiguration des Projekts. Aufruf Menü Projekt → Projekteinstellungen Doppelklick auf das Objekt im Gerätebaum CODESYS speichert die Projekteinstellungen direkt im Projekt. Wenn Sie zum Beispiel ein Projekt auf ein anderes System übertragen, wird auch das Objekt Projekteinstellungen übertragen, ohne dass dafür ein Projektarchiv benötigt wird. Die Projekteinstellungen gelten projektweit und bieten für verschiedene Kategorien wie zum Beispiel AS oder Benutzer und Gruppen Einstellmöglichkeiten. Die verfügbaren Kategorien variieren, ja nachdem, welche Softwarepakete Sie über den Package Manager installiert haben. " }, 
{ "title" : "Objekt: Projektinformationen ", 
"url" : "_cds_obj_project_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Projektinformationen ", 
"snippet" : "Projektinformationen Symbol: Funktion : Das Objekt enthält die Eigenschaften, Metainformationen und Informationen des Projekts und ermöglicht Ihnen die Urheberschaft und Integrität des Projekts zu überprüfen. Aufruf Doppelklick auf das Objekt im Gerätebaum Menü Projekt → Projektinformationen Vorauss...", 
"body" : "Projektinformationen Symbol: Funktion : Das Objekt enthält die Eigenschaften, Metainformationen und Informationen des Projekts und ermöglicht Ihnen die Urheberschaft und Integrität des Projekts zu überprüfen. Aufruf Doppelklick auf das Objekt im Gerätebaum Menü Projekt → Projektinformationen Voraussetzung : CODESYS erstellt das Objekt, sobald Sie den Befehl Projekt → Projektinformationen ausgewählt haben und sich der Dialog öffnete. CODESYS speichert die Projektinformationen direkt im Projekt. Wenn Sie zum Beispiel ein Projekt auf ein anderes System übertragen, wird auch das Objekt Projektinformationen übertragen. Sie benötigen kein Projektarchiv. Für weitere Informationen siehe: Projektinformation abfragen und bearbeiten" }, 
{ "title" : "Registerkarte: Datei ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_b48b607558567f4ec0a8640e01c898f6", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Projektinformationen \/ Registerkarte: Datei ", 
"snippet" : "Die Registerkarte zeigt die Eigenschaften der Projektdatei und deren Attribute an. Sie können diese Attribute nicht editieren. Sie entsprechen den Dateieigenschaften des Windows-Explorers....", 
"body" : "Die Registerkarte zeigt die Eigenschaften der Projektdatei und deren Attribute an. Sie können diese Attribute nicht editieren. Sie entsprechen den Dateieigenschaften des Windows-Explorers. " }, 
{ "title" : "Registerkarte: Zusammenfassung ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_c59e7f6558567f53c0a8640e00967a59", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Projektinformationen \/ Registerkarte: Zusammenfassung ", 
"snippet" : "Die Registerkarte enthält die allgemeinen Informationen und Metainformationen der Projektdatei. CODESYS erstellt aus diesen Informationen Schlüssel in der Registerkarte Eigenschaften . Wenn zum Beispiel in Firma der Name Company_A eingetragen ist, ist in der Registerkarte Eigenschaften der Schlüssel...", 
"body" : "Die Registerkarte enthält die allgemeinen Informationen und Metainformationen der Projektdatei. CODESYS erstellt aus diesen Informationen Schlüssel in der Registerkarte Eigenschaften . Wenn zum Beispiel in Firma der Name Company_A eingetragen ist, ist in der Registerkarte Eigenschaften der Schlüssel Company mit dem Wert Company_A vorhanden. Wenn Sie Ihr Projekt als Bibliotheksprojekt speichern , sollten Sie die Richtlinien für Bibliotheksentwickler beachten. Bei einem Bibliotheksprojekt muss eine Firma , ein Titel und eine Version eingetragen sein, um die Bibliothek installieren zu können. Firma Name der Firma, zum Beispiel Company_A Titel Titel des Projekts, zum Beispiel Automation_A Version Version des Projekts, zum Beispiel 0.0.0.1 Freigegeben : Schutz gegen Änderung aktiviert Folge: Wenn Sie nun das Projekt editieren, erscheint eine Eingabeaufforderung, ob das Projekt wirklich geändert werden soll. Wenn Sie diese Abfrage einmalig mit Ja beantworten, erscheinen bei weiteren Editieraktionen keine Abfrage mehr. Bibliothekskategorien Kategorien des Bibliotheksprojekts, nach denen Sie im Dialog Bibliotheksrepository sortieren können Wenn keine Kategorie angegeben ist, wird der Bibliothek die Kategorie Sonstige zugewiesen. Die Kategorien stammen aus einer oder mehreren externen Beschreibungsdateien im XML-Format. Sie können aber auch aus einem bereits erstellten Bibliotheksprojekt stammen. Voraussetzung: Das Projekt ist ein Bibliotheksprojekt. : Der Dialog Bibliothekskategorien öffnet sich, in dem Sie Bibliothekskategorien hinzufügen können. Für weitere Informationen zum Anlegen von Bibliothekskategorien siehe: Library Categories Standard-Namensraum Voraussetzung: Das Projekt ist ein Bibliotheksprojekt. Wenn Sie hier keinen Standardnamensraum definieren, gilt automatisch der Name der Bibliotheksdatei als Namensraum. Platzhalter Voraussetzung: Das Projekt ist ein Bibliotheksprojekt. Platzhaltername, der für den Verweis auf diese Bibliothek verwendet wird Beispiel: SysMem Referenzen, die über Platzhalter funktionieren, werden gemäß Syntax  #<Platzhaltername>  dargestellt Wichtig: Der Name eines Platzhalters kann nicht mehr geändert werden. Deshalb ist es sehr empfehlenswert, einen Namen zu wählen, bei dem die Wahrscheinlichkeit niedrig ist, dass ein anderer ihn genau so wählt. Tipp: Sie können referenzierte Bibliotheken über Bibliotheksplatzhalter einbinden. Damit vermeiden Sie Probleme, die aufgrund von Versionsabhängigkeiten oder der Notwendigkeit, herstellerspezifische Bibliotheken zu verwenden, entstehen können. Autor Autor des Projekts, zum Beispiel Arnold Best Beschreibung Zum Beispiel: Nur für internen Gebrauch Dialog Bibliothekskategorien Liste von Kategorien Liste der Kategorien, die dem Bibliotheksprojekt zugewiesen sind Sie können aus mehrere Quellen stammen. Wenn Sie alle gewünschten Kategorien eingetragen haben, bestätigen Sie den Dialog mit OK . Schaltfläche Hinzufügen Die Befehle Von Beschreibungsdatei und Von anderer Bibliothek erscheinen. Schaltfläche Entfernen CODESYS entfernt die selektierte Kategorie. Befehl Von Beschreibungsdatei Dialog Beschreibungsdatei auswählen erscheint, in dem Sie eine Beschreibungsdatei mit Erweiterung *.libcat.xml auswählen. Die Datei enthält Befehlskategorien. Wenn Sie den Dialog mit Öffnen beenden, übernimmt CODESYS diese Kategorien. Befehl Von anderer Bibliothek Dialog Bibliothek auswählen erscheint, in dem Sie eine Bibliothek auswählen, deren Befehlskategorien übernommen werden sollen. Wenn Sie den Dialog mit Öffnen beenden, übernimmt CODESYS die Kategorien. Schaltfläche OK CODESYS stellt die Kategorien als Projektinformation zur Verfügung und zeigt sie im Feld Bibliothekskategorien an. " }, 
{ "title" : "Registerkarte: Eigenschaften ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_8210ee8558567f55c0a8640e01b29160", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Projektinformationen \/ Registerkarte: Eigenschaften ", 
"snippet" : "In dieser Registerkarte können Sie Schlüssel definieren, die Sie mit anwenderspezifischen externen Programmen von außen steuern können. Wenn Sie ein Bibliotheksprojekt geöffnet haben, beachten Sie bitte die Beschreibung der relevanten Schlüssel in den Richtlinien für Bibliotheksentwickler : „Library...", 
"body" : "In dieser Registerkarte können Sie Schlüssel definieren, die Sie mit anwenderspezifischen externen Programmen von außen steuern können. Wenn Sie ein Bibliotheksprojekt geöffnet haben, beachten Sie bitte die Beschreibung der relevanten Schlüssel in den Richtlinien für Bibliotheksentwickler : „Library Development Summary“. Wenn Sie als Projekt eine Symbolbibliothek geöffnet haben, muss der Schlüssel VisuSymbolLibrary = TRUE definiert sein. Er kennzeichnet die Bibliothek als Symbolbibliothek. Schlüssel Name des Schlüssels Beliebige Zeichenfolge für neuen Schlüssel eintragen, oder einen bereits in der Tabelle Eigenschaften eingetragenen Schlüssel selektieren. Typ Datentyp des Schlüssels Mögliche Typen: Text , Datum , Zahl , Bool , Version Wert Wert des Schlüssels im zulässigen Format: Text : Beliebige Zeichenfolge Datum : Mindesteintrag für dieses Datum: 1.1 Beispiel: Freitag, 1. Januar 2016 00:00:00 Zahl : Ganze Zahl im Integer32-Format, mit oder ohne Vorzeichen Beispiel: -32500 Bool : True oder False , Gross-\/Kleinschreibung nicht relevant Version : maximal vierstellig Beispiele: 1.1 , 1.0.1.0 Hinzufügen Fügt den neu definierten Schlüssel in der Tabelle Eigenschaften hinzu Bearbeiten Speichert die für den in der Tabelle Eigenschaften selektierten Schlüssel vorgenommene Änderung Entfernen Entfernt den in der Tabelle Eigenschaften selektierten Schlüssel Eigenschaften Liste der Eigenschaften, die als Schlüssel definiert sind CODESYS erstellt automatisch Schlüssel zu den Informationen der Registerkarte Zusammenfassung . Klicken Sie auf einen Schlüssel, um ihn in den Eingabefelder, die oberhalb der Liste sind, zu bearbeiten. " }, 
{ "title" : "Registerkarte: Statistik ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_a4b8c2db58567f55c0a8640e000a1036", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Projektinformationen \/ Registerkarte: Statistik ", 
"snippet" : "Der Dialog gibt eine statistische Auskunft, wie viele Objekte der einzelnen Typen im Projekt verwendet sind....", 
"body" : "Der Dialog gibt eine statistische Auskunft, wie viele Objekte der einzelnen Typen im Projekt verwendet sind. " }, 
{ "title" : "Registerkarte: Lizenzierung ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_65b680f358567f57c0a8640e01071248", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Projektinformationen \/ Registerkarte: Lizenzierung ", 
"snippet" : "Der Dialog dient dem Lizenzschutz von Bibliotheken. Sie können nur übersetzte Bibliotheken („Compiled Libraries“) so schützen. Variablen Dongle-Lizenzierung aktivieren : Die Bibliothek benötigt einen Dongle mit Lizenz um verwendet werden zu können. Firmcode Lizenzinformationen, die bei der späteren ...", 
"body" : "Der Dialog dient dem Lizenzschutz von Bibliotheken. Sie können nur übersetzte Bibliotheken („Compiled Libraries“) so schützen. Variablen Dongle-Lizenzierung aktivieren : Die Bibliothek benötigt einen Dongle mit Lizenz um verwendet werden zu können. Firmcode Lizenzinformationen, die bei der späteren Verwendung der Bibliothek vom Dongle geliefert werden müssen Produktcode Aktivierungs-URL Aktivierungs-Mail " }, 
{ "title" : "Registerkarte: Signieren ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_4f62c3fafb05c6ffc0a8640e019c606c", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Projektinformationen \/ Registerkarte: Signieren ", 
"snippet" : "Diese Registerkarte wird nur noch bei bestehenden Bibliotheken angezeigt, deren Signierung mit dieser Registerkarte erstellt wurde. Bei neu erzeugten Bibliotheken ist diese Registerkarte nicht mehr sichtbar. Für weitere Informationen siehe: Projektinformation abfragen und bearbeitenWenn eine zertifi...", 
"body" : "Diese Registerkarte wird nur noch bei bestehenden Bibliotheken angezeigt, deren Signierung mit dieser Registerkarte erstellt wurde. Bei neu erzeugten Bibliotheken ist diese Registerkarte nicht mehr sichtbar. Für weitere Informationen siehe: Projektinformation abfragen und bearbeitenWenn eine zertifikatssignierte Bibliothek erzeugt wird (möglich ab CODESYS V3 3.5 SP15 ) und nicht eine Bibliothekskompatibilität mit CODESYS < V3 3.5 SP15 eingestellt ist, sind die Einstellungen auf dieser Registerkarte deaktiviert. In diesem Fall erfolgt die Signierung über ein Zertifikat, das im Security-Screen dem Benutzerprofil zugeordnet sein muss. Nicht empfohlen, jedoch für die Kompatibilität mit Versionen < 3.5 SP15 in manchen Fällen noch nötig: Die weniger sichere Signierung einer Bibliothek mit Hilfe dieses Dialogs, mit einem anbieterspezifischen, einmaligen Schlüssel. Voraussetzung: Dieser Schlüssel liegt für Sie in Form einer „ Privaten Schlüsseldatei “ *.libpk mit einem zugehörigen Token bereit. Diesen Schlüssel muss auch der Verwender der Bibliothek erhalten, um prüfen zu können, ob die letzte Signierung tatsächlich durch den Bibliotheksanbieter erfolgt ist. Signieren aktivieren : CODESYS signiert das Bibliotheksprojekt mit einem anbieterspezifischen, einmaligen Schlüssel. Private Schlüsseldatei Speicherort der privaten Schlüsseldatei *.libpk , zum Beispiel: D:\\for lib developers only\\mycomp_libkey.libpk Token des öffentlichen Schlüssels Zum Beispiel: 427A5701DA3CF3CF Voraussetzung: Eine privaten Schlüsseldatei ist angegeben und CODESYS hat den Token ausgelesen und eingetragen. Private Schlüsseldatei erzeugen… CODESYS erzeugt eine neue private Schlüsseldatei. " }, 
{ "title" : "Optionen zur Bausteinerzeugung für den Zugriff auf Projektinformationen ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_0a188ec6fa561b9fc0a8640e0019d8bf", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Projektinformationen \/ Optionen zur Bausteinerzeugung für den Zugriff auf Projektinformationen ", 
"snippet" : "Automatisch 'Projektinformationen'-POUs erzeugen Hinweis: Die mit dieser Option erzeugten Funktionen können nur verwendet werden, wenn das Laufzeitsystem den Datentyp WSTRING unterstützt! Wenn dies nicht der Fall ist, können Sie die automatisch für die einzelnen Projektinformationen erzeugten Funkti...", 
"body" : "Automatisch 'Projektinformationen'-POUs erzeugen Hinweis: Die mit dieser Option erzeugten Funktionen können nur verwendet werden, wenn das Laufzeitsystem den Datentyp WSTRING unterstützt! Wenn dies nicht der Fall ist, können Sie die automatisch für die einzelnen Projektinformationen erzeugten Funktionen zumindest in der Applikation für den Eigenschaftenzugriff verwenden. Im Laufzeitsystem sind diese Funktionen nicht registriert! : CODESYS erstellt POU-Objekte des Typs FUNCTION in der Ansicht POUs und ermöglicht damit einen programmatischen Zugriff in der Applikation auf die Projekteigenschaften. Für die Eigenschaften Firma , Titel und Version werden die Funktionsbausteine GetCompany , GetTitle und GetVersion erstellt. Für benutzerdefinierte Eigenschaften stehen folgende Funktionsbausteine zur Verfügung: GetBooleanProperty : BOOL (TRUE\/FALSE) GetNumberProperty : DINT (Zahlenwert) GetTextProperty : WSTRING (Zeichenfolge) GetTextProperty2 : POINTER TO WSTRING (ohne Längenbegrenzung) GetVersionProperty : VERSION (Versionsnummer als Zeichenfolge) Hinweis: Aktivieren Sie diese Option nicht für Standardbibliotheken, da dies auf kleinen Systemen aufgrund des zusätzlichen Speicherbedarfs Probleme verursachen kann. Hinweis: Wenn eine Bibliothek auch diese Projektinformations-POUs enthält, sollten Sie den Operator __POOL verwenden, um sicherzustellen, dass diese POUs zugegriffen wird. Automatisch 'Bibliotheksinformationen‘-POUs erzeugen : CODESYS erstellt Programmierobjekte des Typs FUNCTION in der Ansicht POUs und ermöglicht damit einen programmatischen Zugriff in der Applikation auf die Bibliothekseigenschaften. Für die Eigenschaften Version und Freigegeben werden die Funktionen GetLibVersion (Versionsnummer als Zeichenfolge), GetLibVersionNumber (Versionsnummer als Zahlenwert) und IsLibReleased (TRUE\/FALSE) erstellt. Hinweis: Im Laufzeitsystem sind diese Funktionen nicht registriert! Die Option steht als Ausweichlösung zur Verfügung, falls das Laufzeitsystem den Datentyp WSTRING nicht unterstützt und Sie deshalb die mit der Option Automatisch ‚Projektinformationen‘-POUs erzeugen erzeugten Funktionen nicht verwenden können. Projektkompatibilität erzwingen zu : Wenn Sie eine Bibliothek mit dem Befehl Projekt Speichern unter speichern, wird das gewählte Format gespeichert. Beim erneuten Ausführen des Befehls Projekt speichern unter ist dann die gespeicherte Auswahl per Default ausgewählt. Wenn Sie diese Option aktiviert haben und ein Objekt hinzufügen, das ein neueres Speicherformat erfordert, öffnet sich ein Dialog. In dem Dialog müssen Sie die Aktualisierung explizit bestätigen oder abbrechen. Wenn Sie Ja klicken, werden alle Änderungen im Projekt ohne Datenverlust gespeichert. Allerdings kann das Projekt künftig nicht mehr mit dem ursprünglich eingestellten Speicherformat geöffnet werden. Als neues erzwungenes Speicherformat wird das neue Format festgelegt. Wenn Sie Nein klicken, bleibt das Projekt kompatibel zu dem eingestellten Speicherformat, es werden jedoch eventuell nicht alle Änderungen gespeichert. Die Option Projektkompatibilität erzwingen zu ist für die Entwicklung kompatibler Bibliotheken nützlich. Gleichzeitig wird es damit möglich, die neueste Version des Programmiersystems zu verwenden. Auswirkungen bei aktivierter Option: Die Abfrage zur Aktualisierung des Speicherformats wird unterdrückt. Neuere Features, die im Projekt gespeichert werden müssen, können nicht verwendet werden. Für die reine Entwicklung von Bibliotheken, die nur textuelle Objekte (wie beispielsweise POUs, DUTs, Schnittstellen) enthalten, ist dies keine Einschränkung. Die Compilerversion kann frei ausgewählt werden, Patch-Versionen können jedoch nicht ausgewählt werden. Bei aktuell ausgewählter neuester Compilerversion kann eine ältere Compilerversion ausgewählt werden. " }, 
{ "title" : "Objekt: Taskkonfiguration ", 
"url" : "_cds_f_reference_task_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Taskkonfiguration ", 
"snippet" : "Taskkonfiguration Symbol: Das Objekt dient der Definition und Anzeige der Grundeinstellungen für die Taskkonfiguration. Registerkarten der Taskkonfiguration und ihre Funktionen: Taskgruppen : Definitionen der Taskgruppen und ihrer Zuordnung zu Prozessorkernen Überwachung : Anzeige des Status und akt...", 
"body" : "Taskkonfiguration Symbol: Das Objekt dient der Definition und Anzeige der Grundeinstellungen für die Taskkonfiguration. Registerkarten der Taskkonfiguration und ihre Funktionen: Taskgruppen : Definitionen der Taskgruppen und ihrer Zuordnung zu Prozessorkernen Überwachung : Anzeige des Status und aktueller Statistiken zu den Zykluszeiten im Onlinebetrieb Variablenverwendung : Übersicht, welche Tasks wie auf die Variablen zugreifen Stackverbrauch : Stackgröße in Bytes, aufgeteilt entsprechend der Aufrufhierarchie System-Ereignisse : Verknüpfung von Bausteinaufrufen mit Systemereignissen Eigenschaften : Anzeige der Grundeinstellungen CPU-Auslastung : Grafische Darstellung der CPU-Auslastung im Onlinebetrieb " }, 
{ "title" : "Registerkarte: Taskgruppen ", 
"url" : "_cds_obj_task_config_task_groups.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Taskkonfiguration \/ Registerkarte: Taskgruppen ", 
"snippet" : "Objekt: Taskkonfiguration In der Registerkarte Taskgruppen definieren Sie Taskgruppen. Taskgruppen können bei Multicore -Systemen auf die einzelnen Prozessorkerne verteilt werden. Die Tasks einer Taskgruppe werden gemäß der im Feld Core festgelegten Strategie an die Prozessorkerne gebunden. In der S...", 
"body" : "Objekt: Taskkonfiguration In der Registerkarte Taskgruppen definieren Sie Taskgruppen. Taskgruppen können bei Multicore -Systemen auf die einzelnen Prozessorkerne verteilt werden. Die Tasks einer Taskgruppe werden gemäß der im Feld Core festgelegten Strategie an die Prozessorkerne gebunden. In der Spalte Priorität , wird die Priorität der Task angezeigt, wie sie im Editor der jeweiligen IEC-Task konfiguriert ist. Gruppe hinzufügen Die Schaltfläche fügt eine neue Taskgruppe mit dem Namen NewGroup_<nr> hinzu. Gruppe entfernen Löscht die selektierte Taskgruppe Gruppenname Durch einen Doppelklick in das Feld kann der Namen geändert werden. Core Free floating : Alle IEC-Tasks der Taskgruppe werden vom Betriebssystem per Lastverteilung dynamisch auf die einzelnen Prozessorkerne verteilt. Dies bedeutet, dass die Tasks in der Regel sehr häufig die Prozessorkerne wechseln, auf denen sie ausgeführt werden. Der Anwender kann darauf keinen Einfluss nehmen. Wir empfehlen diese Einstellung für die meisten Anwendungen, da hier die Last vom Betriebssystem automatisch verteilt wird. Sequentially pinned : Alle IEC-Tasks der Taskgruppe werden fest an verschiedene Prozessorkerne gebunden. Wenn es weniger Prozessorkerne als Tasks gibt, werden die Tasks an die einzelnen Prozessorkerne gebunden, beginnend mit Core1 und weiter mit Core2, Core3, etc. Beim Überlauf wird der Vorgang mit Core0, Core, etc. fortgesetzt. Der Anwender kann keinen Einfluss darauf nehmen. Fixed pinned : Alle IEC-Tasks der Taskgruppe werden fest an einen Prozessorkern gebunden. Welcher Prozessorkern dies ist, wird im Laufzeitsystem entschieden (Standardeinstellung). In der Regel wird Core1 verwendet. Wenn es mehrere Taskgruppen mit der Einstellung Fixed pinned gibt, wird jede Taskgruppe auf einen anderen Prozessorkern gebunden. In der Regel wird mit Core1 begonnen. <Fixe Core Nummer> : Alle IEC-Tasks der Taskgruppe werden fest an einen definierten Prozessorkern gebunden. Wenn der Prozessorkern auf der Steuerung nicht vorhanden ist, wird beim Download ein Fehler erzeugt. Die Einstellungen Sequentially pinned , Fixed pinned , und <Fix Core Nummer> können hilfreich sein, um deterministischere Jitterzeiten zu erhalten. Denn bei diesen Einstellungen gibt es keine Beeinflussung durch die dynamische Verteilung der Tasks auf die einzelnen Kerne zur Laufzeit. Allerdings wird dadurch dem Betriebssystem die Möglichkeit genommen, die Last auf die einzelnen Prozessorkerne zu verteilen. Daher empfehlen wir diese Einstellungen nur nach zuvor durchgeführten Tests, die ergeben haben, dass diese Einstellungen ein signifikant besseres Echtzeitverhalten ermöglichen. " }, 
{ "title" : "Registerkarte: Überwachung ", 
"url" : "_cds_obj_task_config_monitor.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Taskkonfiguration \/ Registerkarte: Überwachung ", 
"snippet" : "Objekt: Taskkonfiguration Die Registerkarte zeigt im Onlinebetrieb den Status der CODESYS -Tasks, sowie einige aktuelle Messungen zu den Zyklen und Zykluszeiten. Die Werte werden im gleichen Zeitintervall wie beim Monitoring von Werten aus der Steuerung aktualisiert. Für weitere Informationen siehe:...", 
"body" : "Objekt: Taskkonfiguration Die Registerkarte zeigt im Onlinebetrieb den Status der CODESYS -Tasks, sowie einige aktuelle Messungen zu den Zyklen und Zykluszeiten. Die Werte werden im gleichen Zeitintervall wie beim Monitoring von Werten aus der Steuerung aktualisiert. Für weitere Informationen siehe: Definition von Jitter und LatenzDie angezeigten Werte können mit dem Kontextmenübefehl Zurücksetzen auf den Wert 0 zurückgesetzt werden. Task Taskname, wie in der Taskkonfiguration definiert Status Nicht erzeugt : Task wurde seit der letzten Aktualisierung noch nicht gestartet; speziell für Ereignis-Tasks Erzeugt : Task ist im Laufzeitsystem bekannt, ist aber noch nicht in Betrieb Gültig : Task ist normal in Betrieb Ausnahme : Task hat Ausnahmezustand Anzahl IEC-Zyklen Anzahl der seit dem ersten Starten der Applikation ausgeführten Zyklen, in denen der IEC-Code tatsächlich aufgerufen wurde. Dieser Wert entspricht somit einem Hugo-Zähler im Code. Wenn aber das Zielsystem die Zählfunktion nicht unterstützt, bleibt die Anzahl 0 . Anzahl Zyklen Anzahl der bereits ausgeführten Zyklen seit dem Einloggen auf die Steuerung, auch wenn die Task in STOP ist Die Anzahl entspricht den Aufrufen von IecTaskCycle2 und wird auch dann inkrementiert, wenn die Applikation in STOP ist. Allerdings hängt es vom Zielsystem ab, ob Zyklen gezählt werden, in denen die Applikation nicht läuft. In diesem Fall kann die Anzahl Zyklen größer werden als die Anzahl IEC-Zyklen . Letzte Zykluszeit (µs) Letzte gemessene Zykluszeit [µs] Durchschnittliche Zykluszeit (µs) Durchschnittliche Zykluszeit über alle Zyklen [µs] Max. Zykluszeit  (µs) Maximale gemessene Zykluszeit über alle Zyklen [µs] Min. Zykluszeit  (µs) Minimale gemessene Zykluszeit über alle Zyklen [µs] Jitter  (µs) Aktueller Wert des periodischen Jitters [µs] Hinweis: Von CODESYS 3.5 SP11 bis SP15 wird der Spitze-Spitze-Wert des periodischen Jitters angezeigt. In älteren Versionen wird, wie auch jetzt wieder ab SP16, der aktuelle Wert des periodischen Jitters angezeigt. Min. Jitter  (µs) Minimaler gemessener periodischer Jitter [µs] Max. Jitter  (µs) Maximaler gemessener periodischer Jitter [µs] Core Nummer des Prozessorkerns, auf dem die Task gerade ausgeführt wird Beispiel: 2 Voraussetzung: Die Steuerung verfügt über einen Mehrkernprozessor. Wenn die CPU keine Mehrkern-CPU ist, wird hier der Wert -1 angezeigt. " }, 
{ "title" : "Registerkarte: Variablenverwendung ", 
"url" : "_cds_obj_task_config_variable_usage.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Taskkonfiguration \/ Registerkarte: Variablenverwendung ", 
"snippet" : "Objekt: Taskkonfiguration In der Registerkarte Variablenverwendung erhalten Sie eine Übersicht über alle Variablen und und deren Verwendung. Sie sehen darin, in welchen Tasks die Zugriffe auf die Variablen erfolgen. Bei der Verwendung von Multicore sollte der Schreibzugriff (w) auf eine Variable nur...", 
"body" : "Objekt: Taskkonfiguration In der Registerkarte Variablenverwendung erhalten Sie eine Übersicht über alle Variablen und und deren Verwendung. Sie sehen darin, in welchen Tasks die Zugriffe auf die Variablen erfolgen. Bei der Verwendung von Multicore sollte der Schreibzugriff (w) auf eine Variable nur in einer Task erfolgen, da es sonst zu Inkonsistenzen kommen kann. Über das Kontextmenü können Sie einzelne Tasks ausblenden und die Querverweisliste zu Variablen anzeigen lassen. Variablen Name der Variablen Typ Datentyp Anzahl Anzahl der Tasks, die auf diese Variable zugreifen. <Taskname> Zugriff auf die Variable (r: lesend, w: schreibend, rw: lesend\/schreibend) " }, 
{ "title" : "Registerkarte: Stackverbrauch ", 
"url" : "_cds_obj_task_config_tab_stack_usage.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Taskkonfiguration \/ Registerkarte: Stackverbrauch ", 
"snippet" : "Stackverbrauch Registerkarte im Taskkonfigurations-Editor Die Registerkarte Stackverbrauch zeigt den aktuellen Stackverbrauch für jede Applikation, für jede Task und für die Programmierbausteine im maximalen Aufrufbaum an. Voraussetzung, dass die Informationen angezeigt werden: Der Applikationcode w...", 
"body" : "Stackverbrauch Registerkarte im Taskkonfigurations-Editor Die Registerkarte Stackverbrauch zeigt den aktuellen Stackverbrauch für jede Applikation, für jede Task und für die Programmierbausteine im maximalen Aufrufbaum an. Voraussetzung, dass die Informationen angezeigt werden: Der Applikationcode wurde erzeugt. Dies erfolgt entweder automatisch beim Einloggen auf die Steuerung oder explizit durch den Befehl Erstellen → Code erzeugen . Standard-Stackgröße aus dem Zielsystem überschreiben Das Überschreiben der Stackgröße in Verfügbare Stackgröße ist eine Expertenfunktion. Dieses Eingabefeld ist nur verfügbar, wenn Sie die Option hier aktivieren und die anschließend erscheinende Meldung bestätigen. Die Meldung weist darauf hin, dass die Gefahr eines Stack-Überlaufs bestehen kann. Es können Ausnahmefehler auftreten. : Das Eingabefeld Verfügbare Stackgröße zeigt den aktuell eingestellten Standard-Stackgröße aus der Gerätebeschreibung an. Eine Eingabe ist nicht erlaubt. Defaulteinstellung. : Das Eingabefeld Verfügbare Stackgröße ist editierbar. Sie können dort einen neuen Wert eingeben oder auf den Standardwert zurücksetzen. Zurücksetzen auf Standard Bei Klick auf die Schaltfläche wird der Wert in Verfügbare Stackgröße auf die Standard-Stackgröße zurückgesetzt. Die Standard-Stackgröße ist in der Gerätebeschreibung definiert. Verfügbare Stackgröße Verfügbare Stackgröße in Bytes Beispiel: 4.194.304 In der Gerätebeschreibung ist die maximale Stackgröße angegeben. Diese Standard-Stackgröße wird ausgelesen und als verfügbare Stackgröße übernommen. Sie können den Wert ändern, wenn die Option Standard-Stackgröße aus dem Zielsystem überschreiben aktiviert ist. Der Compiler prüft während der Kompilierung den maximalen Stackverbrauch in der Applikation und meldet anhand dieser berechneten Größe einen Fehler, wenn ein Überlauf möglich ist. Angenommene Stackgröße für externe Aufrufe Stackgröße in Bytes, die für externe Aufrufe ins Laufzeitsystem angenommen wird Beispiel: Wenn hier 24 steht, wird angenommen, dass ein Aufruf einer externen Funktion 24 Byte auf dem Stack verbraucht Hinweis: Das Ergebnis der Berechnung des Stackverbrauchs ist immer eine Schätzung. In der Gerätebeschreibung ist ein allgemeiner Schätzwert für die Stackgröße eines externen Aufrufs angegeben. Dieser Wert wird für die Berechnung verwendet. Es sei denn, einem externen Aufruf wurde mit dem Attribut ' estimated-stack-usage' ein spezieller Schätzwert zugewiesen. In diesem Fall wird der spezielle Wert bevorzugt. Task\/Maximaler Aufrufbaum Beim Kompilieren ermittelter Aufrufbaum (Aufrufhirarchie) Tipp: Wenn in dieser Ansicht der Aufrufbaum leer ist, können Sie einen Kompiliervorgang starten und den Befehl Erstellen → Code erzeugen aufrufen. Danach stehen Ihnen die aktuellen Informationen zum Stackverbrauch zur Verfügung. Stackgröße Genutzte Stackgröße in Bytes pro aufgerufenem Programmierbaustein Oder über die Aufrufhierarchie aufsummierte Stackgröße bei einer Task Der Compiler berechnet während der Kompilierungszeit den maximalen Stackverbrauch bei maximaler Aufrufkette. Wichtig: Wenn ein Programmierbaustein rot dargestellt ist, dann bedeutet das, dass bei diesem Baustein ein Stacküberlauf ermittelt wurde. Die nachfolgenden Programmierbausteine sind wegen Speicherüberlauf ebenfalls in rot dargestellt. Für weitere Informationen siehe: Berechnung des Stackverbrauchs" }, 
{ "title" : "Registerkarte: Systemereignisse ", 
"url" : "_cds_obj_task_config_sys_event.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Taskkonfiguration \/ Registerkarte: Systemereignisse ", 
"snippet" : "Objekt: Taskkonfiguration In der Registerkarte Systemereignisse definieren Sie, welches Ereignis welche Funktion aufruft und ob die Konfiguration aktuell aktiviert ist oder nicht. Sie verwenden die Registerkarte, wenn anstelle einer Task ein „Systemereignis“ eine Funktion des Projekts aufrufen soll....", 
"body" : "Objekt: Taskkonfiguration In der Registerkarte Systemereignisse definieren Sie, welches Ereignis welche Funktion aufruft und ob die Konfiguration aktuell aktiviert ist oder nicht. Sie verwenden die Registerkarte, wenn anstelle einer Task ein „Systemereignis“ eine Funktion des Projekts aufrufen soll. Event-Handler hinzufügen Öffnet den Dialog Event-Handler hinzufügen Event-Handler löschen Löscht die selektierte Zuweisung der Auflistung Ereignisinfo Informationen aus der jeweiligen Ereignisbibliothek Ereignisfunktion öffnen Öffnet den Editor der neuen Funktion der selektierten Zuweisung Die Implementierungssprache der neuen Funktion haben Sie im Dialog Event-Handler hinzufügen ausgewählt. Auflistung der Zuweisungen von aufzurufenden Funktionen zu Ereignissen mit: Name , Beschreibung , Aufzurufende Funktion und Aktiv (Aktivierung\/Deaktivierung der Konfiguration) Event-Handler hinzufügen Fügt der Auflistung eine neue Zuweisung: „Ereignis - aufzurufende Funktion“ hinzu Ereignis Die Auswahlmöglichkeiten sind abhängig vom Zielgerät. Ereignisse, die nicht zur Verfügung stehen, kennzeichnet CODESYS mit einem roten Symbol vor dem Namen. Eine Auflistung aller möglichen Systemereignisse befindet sich am Ende dieses Abschnitts. Aufzurufende Funktion Namen der Funktion ( POU vom Typ FUNCTION ) Sie müssen den Namen einer neuen Funktion eingeben. CODESYS fügt die Funktion nach Bestätigung des Dialogs im Gerätebaum ein. Gültigkeitsbereich Applikation : Funktion ist für die Applikation verfügbar POUs : Funktion ist für das ganze Projekt verfügbar Implementierungssprache Implementierungssprache der neuen Funktion Beschreibung Kurzbeschreibung zum ausgewählten Ereignis " }, 
{ "title" : "Besonderheiten im Onlinebetrieb ", 
"url" : "_cds_obj_task_config_sys_event.html#UUID-c1043114-d606-9162-3795-5a941a24ff08_id_e5ddda49857aab52c0a8640e01f6cda7_id_aca2ec018ac2b258c0a8640e004f986b", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Taskkonfiguration \/ Registerkarte: Systemereignisse \/ Besonderheiten im Onlinebetrieb ", 
"snippet" : "Die Auflistung der Zuweisungen von aufzurufenden Funktionen zu Ereignissen enthält zusätzlich folgende Informationen: Ereignisstatus und Anzahl Aufrufe und die Schaltfläche Online Reset . Ereignisstatus 0 : Es ist kein Fehler aufgetreten. Ungleich 0 : Fehlerfall. Sie müssen die entsprechende Laufzei...", 
"body" : "Die Auflistung der Zuweisungen von aufzurufenden Funktionen zu Ereignissen enthält zusätzlich folgende Informationen: Ereignisstatus und Anzahl Aufrufe und die Schaltfläche Online Reset . Ereignisstatus 0 : Es ist kein Fehler aufgetreten. Ungleich 0 : Fehlerfall. Sie müssen die entsprechende Laufzeitsystem-Dokumentation hinzuziehen. Anzahl Aufrufe Zeigt an, wie oft das Ereignis aufgetreten ist oder die zugehörige Funktion aufgerufen wurde Online Reset CODESYS initialisiert die Ereignislisten neu und setzt den Zähler der Ereignisse\/Funktionsaufrufe zurück. Nicht korrekt initialisierte Ereignisse werden mit einer roten Statuszeile angezeigt. " }, 
{ "title" : "Mögliche Systemereignisse ", 
"url" : "_cds_obj_task_config_sys_event.html#UUID-c1043114-d606-9162-3795-5a941a24ff08_id_e5ddda49857aab52c0a8640e01f6cda7_id_18ba31b03c03a634c0a8640e01f61238", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Taskkonfiguration \/ Registerkarte: Systemereignisse \/ Mögliche Systemereignisse ", 
"snippet" : "Event Beschreibung Task Debuggen PrepareStart Aufruf vor Start der Applikation Kommunikationstask Nein StartDone Aufruf nach Start der Applikation Kommunikationstask Nein PrepareStop Aufruf vor Stopp der Applikation Kommunikationstask Nein StopDone Aufruf nach Stopp der Applikation Kommunikationstas...", 
"body" : "Event Beschreibung Task Debuggen PrepareStart Aufruf vor Start der Applikation Kommunikationstask Nein StartDone Aufruf nach Start der Applikation Kommunikationstask Nein PrepareStop Aufruf vor Stopp der Applikation Kommunikationstask Nein StopDone Aufruf nach Stopp der Applikation Kommunikationstask Nein PrepareReset Aufruf vor Reset der Applikation Kommunikationstask Nein ResetDone Aufruf nach Reset der Applikation Kommunikationstask Nein PrepareOnlineChange Aufruf vor Online-Change der Applikation Kommunikationstask Nein OnlineChangeDone Aufruf nach Online-Change der Applikation Kommunikationstask Nein PrepareDownload Aufruf vor Download der Applikation Kommunikationstask Nein DownloadDone Aufruf nach Download der Applikation Kommunikationstask Nein PrepareDelete Aufruf vor Löschen der Applikation Kommunikationstask Nein DeleteDone Aufruf nach Löschen der Applikation Kommunikationstask Nein PrepareExit Aufruf vor Verlassen der Applikation Kommunikationstask Nein ExitDone Aufruf nach Verlassen der Applikation Kommunikationstask Nein CodeInitDone Ereignis wird nach Code-Init gesendet. Wird innerhalb der Task Safe Section aufgerufen und nur bei Online-Change! (Zum Beispiel wird der Copy-Code für Online-Change hier ausgeführt.) Kommunikationstask Nein Exception Ereignis wird gesendet, wenn eine Exception im Kontext einer Applikation aufgetreten ist. Exceptionshandlingtask des Laufzeitsystems oder - wenn das Laufzeitsystem eine solche nicht hat - Task selbst Abhängig von der Task Login Einloggen eines Clients in diese Applikation Kommunikationstask Nein Logout Ausloggen eines Clients aus dieser Applikation Kommunikationstask Nein BeforeReadingInputs Aufruf vor Lesen der Eingänge IEC-Task Ja AfterReadingInputs Aufruf nach Lesen der Eingänge IEC-Task Ja BeforeWritingOutputs Aufruf vor Schreiben der Ausgänge IEC-Task Ja AfterWritingOutputs Aufruf nach Schreiben der Ausgänge IEC-Task Ja DebugLoop Ereignis wird zyklisch in der Debug-Schleife gesendet, wenn die IEC-Task auf einem Haltepunkt steht. Kommunikationstask Nein PrepareShutdown Ereignis wird unmittelbar vor dem Herunterfahren des Laufzeitsystems gesendet. Laufzeitsystem Hauptschleife Nein PrepareExitComm Ereignis wird vor dem Beenden (Exit) des Kommunikationsservers während des Herunterfahrens gesendet Laufzeitsystem Hauptschleife Nein PrepareExitTasks Ereignis wird gesendet vor dem Beenden ( Exit ) aller Tasks während des Herunterfahrens. Laufzeitsystem Hauptschleife Nein " }, 
{ "title" : "Registerkarte: Eigenschaften ", 
"url" : "_cds_obj_task_config_properties.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Taskkonfiguration \/ Registerkarte: Eigenschaften ", 
"snippet" : "Objekt: Taskkonfiguration In der Registerkarte werden die Grundeinstellungen der Taskkonfiguration angezeigt, die vom Zielsystem vorgegeben werden. Beispielsweise die Maximalwerte für die Tasks und die Watchdog-Parameter....", 
"body" : "Objekt: Taskkonfiguration In der Registerkarte werden die Grundeinstellungen der Taskkonfiguration angezeigt, die vom Zielsystem vorgegeben werden. Beispielsweise die Maximalwerte für die Tasks und die Watchdog-Parameter. " }, 
{ "title" : "Registerkarte: CPU-Auslastung ", 
"url" : "_cds_obj_task_config_core_deployment.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Taskkonfiguration \/ Registerkarte: CPU-Auslastung ", 
"snippet" : "Objekt: Taskkonfiguration Die Registerkarte CPU-Auslastung ist nur bei Multicore -Geräten im Onlinebetrieb verfügbar. Darin wird die Auslastung der einzelnen Prozessoren im Traceditor dargestellt. Für weitere Informationen siehe: Zugriff auf alle Traces der Steuerung Wenn CODESYS Trace installiert i...", 
"body" : "Objekt: Taskkonfiguration Die Registerkarte CPU-Auslastung ist nur bei Multicore -Geräten im Onlinebetrieb verfügbar. Darin wird die Auslastung der einzelnen Prozessoren im Traceditor dargestellt. Für weitere Informationen siehe: Zugriff auf alle Traces der Steuerung Wenn CODESYS Trace installiert ist, können Sie die Tracekonfiguration mit einem Doppelklick auf die Legende im rechten Fenster öffnen. Ein Hinzufügen weiterer Variablen ist jedoch nicht möglich. " }, 
{ "title" : "Mapping der Task-Prioritäten im Linux-System ", 
"url" : "_cds_task_mapping_in_the_linux_system.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Taskkonfiguration \/ Mapping der Task-Prioritäten im Linux-System ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Abhängigkeiten zwischen IEC-Task-Prioritäten und Linux-Prioritäten ", 
"url" : "_cds_task_mapping_in_the_linux_system.html#UUID-b85d83f0-ecf3-8513-c7aa-c29a2e7321c1_id_f1373b689f854d9c0a864633626272f_id_4e49477d8a294f1dc0a864636423535f", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Taskkonfiguration \/ Mapping der Task-Prioritäten im Linux-System \/ Abhängigkeiten zwischen IEC-Task-Prioritäten und Linux-Prioritäten ", 
"snippet" : "Wenn das Zielsystem unter Linux läuft, werden bestimmte Prioritäten der IEC-Tasks auf bestimmte Prioritäten und Scheduling-Richtlinien abgebildet. Es wird je nach Priorität die Scheduling-Richtlinie SCHED_FIFO oder SCHED_OTHER so wie in der Tabelle dargestellt verwendet. IEC-Task-Priorität Linux-Pri...", 
"body" : "Wenn das Zielsystem unter Linux läuft, werden bestimmte Prioritäten der IEC-Tasks auf bestimmte Prioritäten und Scheduling-Richtlinien abgebildet. Es wird je nach Priorität die Scheduling-Richtlinie SCHED_FIFO oder SCHED_OTHER so wie in der Tabelle dargestellt verwendet. IEC-Task-Priorität Linux-Priorität Linux (default) 0 (höchste Echtzeitprio) 56 ( SCHED_FIFO ) 15 (niedrigste Echtzeitprio) 41 ( SCHED_FIFO ) 16 (keine Echtzeitprio) 0 ( SCHED_OTHER ) 31 (keine Echtzeitprio) 0 ( SCHED_OTHER ) " }, 
{ "title" : "Objekt: Task ", 
"url" : "_cds_f_reference_task.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Task ", 
"snippet" : "Task Symbol: Im Objekt konfigurieren Sie die Task. Sie können die Priorität, den Typ mit Zeitverhalten und einen Watchdog konfigurieren. Außerdem können Sie PROGRAM -Aufrufe hinzufügen. Das Objekt befindet sich im Gerätebaum unter der Taskkonfiguration ....", 
"body" : "Task Symbol: Im Objekt konfigurieren Sie die Task. Sie können die Priorität, den Typ mit Zeitverhalten und einen Watchdog konfigurieren. Außerdem können Sie PROGRAM -Aufrufe hinzufügen. Das Objekt befindet sich im Gerätebaum unter der Taskkonfiguration . " }, 
{ "title" : "Registerkarte: Konfiguration ", 
"url" : "_cds_f_reference_task.html#UUID-f12a90d6-4453-79d4-dbff-668d397ebde9", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Task \/ Registerkarte: Konfiguration ", 
"snippet" : "Objekt Task Priorität Mögliche Werte: 0..31, wobei 0 die höchste Priorität darstellt Taskgruppe Zugeordnete Taskgruppe , die bei Multicore bestimmten Prozessorkernen zugewiesen werden kann Beispiel: IEC-Tasks Hinweis: Die Taskgruppe wird im Gerätebaum hinter der Task in Klammern angezeigt. Bei Verwe...", 
"body" : "Objekt Task Priorität Mögliche Werte: 0..31, wobei 0 die höchste Priorität darstellt Taskgruppe Zugeordnete Taskgruppe , die bei Multicore bestimmten Prozessorkernen zugewiesen werden kann Beispiel: IEC-Tasks Hinweis: Die Taskgruppe wird im Gerätebaum hinter der Task in Klammern angezeigt. Bei Verwendung eines Laufzeitsystems unter Linux bestehen feste Abhängigkeiten zwischen Taskgruppen und Prioritäten. Für weitere Informationen siehe: Mapping der Task-Prioritäten im Linux-System" }, 
{ "title" : "Typ ", 
"url" : "_cds_f_reference_task.html#UUID-f12a90d6-4453-79d4-dbff-668d397ebde9_id_b3ea97b9439f77fc0a8640e009ee507_id_2c355b338a28d370c0a8646340a97328", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Task \/ Registerkarte: Konfiguration \/ Typ ", 
"snippet" : "Typ Zyklisch Abarbeitung der Task erfolgt zyklisch Eingabefeld Intervall Obligatorisch Zeitspanne, nach der die Task neu gestartet wird (Taskzykluszeit) als Zeitangabe im TIME# -Format Beispiel: t#200ms als Zahl Beispiel: 200 Hinweis: Die Zahl wird beim nächsten Fokus des Eingabefelds automatisch im...", 
"body" : "Typ Zyklisch Abarbeitung der Task erfolgt zyklisch Eingabefeld Intervall Obligatorisch Zeitspanne, nach der die Task neu gestartet wird (Taskzykluszeit) als Zeitangabe im TIME# -Format Beispiel: t#200ms als Zahl Beispiel: 200 Hinweis: Die Zahl wird beim nächsten Fokus des Eingabefelds automatisch im TIME# -Format angezeigt. Hinweis: Abweichungen der Task von dieser gewünschten Taskzykluszeit werden zur Laufzeit als periodischer Jitter auf der Registerkarte Registerkarte: Überwachung angezeigt. Zeiteinheit des Intervalls Wenn im Eingabefeld Intervall keine Zeitangabe, sondern nur eine Zahl angeben ist, dann bestimmt die hier ausgewählte Einheit die Zeitgröße. Beispiel: ms Hinweis: Eine Taskzykluszeit in µs wird immer als Zahl angezeigt. Typ Ereignis Abarbeitung der Task startet ereignisgesteuert bei steigender Flanke der Ereignisvariablen Eingabefeld Ereignis Globale Variable (Boolescher Typ) Sobald der Variablenwert von 0 auf 1 wechselt, startet die Task. Typ Externes Abarbeitung der Task startet ereignisgesteuert bei steigender Flanke der Ereignisvariablen Auswahlliste Ereignis Liste mit zielsystemabhängigen Ereignissen (Boolescher Typ) Hinweis: Es hängt vom Zielsystem ab, welche Ereignisse unterstützt und in der Auswahlliste angeboten werden. Tipp: Nicht zu verwechseln mit Systemereignissen Intervall Zeitangabe im TIME# -Format oder als Zahl mit Zeiteinheit Hinweis: Nur verfügbar, wenn das Ereignis eine Zeitangabe erfordert Typ Freilaufend Abarbeitung der Task startet bei Programmstart und nach Ende eines Durchlaufs nach einer gewissen Wartezeit automatisch neu in einer fortlaufenden Schleife Wichtig: Nach Beenden eines Durchlaufs wird eine bestimmte Zeit gewartet, bevor die Task erneut ausgeführt wird. Die Dauer ist ein Prozentsatz der letzten Zyklusdauer. Hinweis: Sie definieren keine Zykluszeit. Typ Status Abarbeitung der Task startet zustandsgesteuert von der Ereignisvariablen Eingabefeld Ereignis Globale Variable (Boolescher Typ) Wenn die Variable den Zustand TRUE hat, startet die Task freilaufend. Die Task läuft so lange, bis die Variable den Wert FALSE erhält. Hinweis: Die Variable wird typischerweise in der Task selbst zurückgesetzt. Im Gegensatz zur Ereignistask kann auf diese Weise kein Event verpasst werden. Bei Ereignis muss der Scheduler einen alten Wert speichern und dieser kann sich öfter ändern als er überprüft wird. Wenn also eine Ereignisvariable nur kurz auf TRUE wechselt, dann kann es passieren, dass der Scheduler diesen Wechsel nicht detektiert. Dies kann mit einer Statustask vermieden werden. Die Statusvariable wird von irgendeiner anderen Task auf TRUE gesetzt und von der Statustask wieder zurückgesetzt. Damit ist sichergestellt, dass bei jedem Wechsel auf TRUE die Task einmal ausgeführt wird. Für Feldbusse ist ein festes Zyklusraster nötig, um ein determiniertes Verhalten sicherzustellen. Deshalb sollten Sie für eine Buszyklustask den Typ Freilaufend nicht verwenden. Beachten Sie den folgenden Unterschied zwischen den Abarbeitungstypen Status und Ereignis : Wenn das angegebene Ereignis den Wert TRUE hat, dann ist die Startbedingung einer Task vom Typ Status erfüllt. Im Gegensatz dazu verlangt der Start einer Task vom Typ Ereignis einen Wechsel des Ereignisses von FALSE auf TRUE . Wenn die Abtastrate des Task-Schedulers zu niedrig ist, können steigende Flanken des Ereignisses unbemerkt bleiben. Beim Setzen der Taskzykluszeit müssen Sie berücksichtigen, welches Bussystem gerade verwendet wird: Beispielsweise muss die Taskzykluszeit auf einem CAN-Bus-System zur aktuell gesetzten Baudrate und der Anzahl der auf dem Bus verwendeten Frames passen. Außerdem sollten die für Heartbeat, Nodeguarding und Sync gesetzten Zeiten immer ein Vielfaches der Taskzykluszeit sein. Ansonsten können CAN-Frames verloren gehen. Für weitere Informationen siehe: Registerkarte: Überwachung" }, 
{ "title" : "Watchdog ", 
"url" : "_cds_f_reference_task.html#UUID-f12a90d6-4453-79d4-dbff-668d397ebde9_section-idm23475286613854", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Task \/ Registerkarte: Konfiguration \/ Watchdog ", 
"snippet" : "Definiert die Zeitüberwachung für eine Task. Wenn das Zielsystem eine erweiterte Watchdog-Konfiguration unterstützt, sind möglicherweise folgende Einstellungen in der Gerätebeschreibung vordefiniert: Obere und untere Grenze Standard-Watchdog-Zeit Zeitangabe in Prozent Die hier standardmäßig verwende...", 
"body" : "Definiert die Zeitüberwachung für eine Task. Wenn das Zielsystem eine erweiterte Watchdog-Konfiguration unterstützt, sind möglicherweise folgende Einstellungen in der Gerätebeschreibung vordefiniert: Obere und untere Grenze Standard-Watchdog-Zeit Zeitangabe in Prozent Die hier standardmäßig verwendeten Watchdog-Einstellungen sind geräteabhängig. Aktivieren : Watchdog ist aktiv. Wenn die Task die gerade gesetzte Zeit des Watchdogs überschreitet, wird die Task mit Fehlerstatus (Ausnahme) angehalten. Dabei werden auch die Applikation, in deren Task der Watchdog-Fehler passiert ist, sowie deren Kindapplikationen gestoppt. Damit werden alle Tasks dieser betroffenen Applikationen ebenfalls gestoppt. Dabei wird auch die aktuell angegebene Empfindlichkeit mit eingerechnet. Wenn Sie in den SPS-Einstellungen der Steuerung die Option E\/As aktualisieren aktiviert haben, setzt CODESYS die Ausgänge auf die definierten Standardwerte zurück. Mögliche Fälle: Mehrere aufeinander folgende Zeitüberschreitungen: Empfindlichkeit: 0, 1 - Exception in Zyklus 1 Empfindlichkeit: 2 - Exception in Zyklus 2 Empfindlichkeit: n - Exception in Zyklus n Einmalige Zeitüberschreitung: Exception, wenn die Zykluszeit des aktuellen Zyklus länger ist als (Zeit * Empfindlichkeit). Beispiel: Zeit=t#10ms, Empfindlichkeit=5, das heißt Exception sobald die Task (einmalig) länger als 50 ms läuft. Zeit (z. B. t#200ms) Watchdog-Zeit Definiert zusammen mit der Empfindlichkeit die Zeitüberwachung für eine Task, wie bei Aktivieren beschrieben. Abhängig vom Zielsystem muss die Überwachungszeitspanne möglicherweise in Prozent des Taskintervalls angegeben werden. In diesem Fall ist die Auswahlliste für die Einheit inaktiv dargestellt und zeigt % an. Empfindlichkeit Zahl Definiert zusammen mit der Watchdog-Zeit die Zeitüberwachung für eine Task, wie bei Aktivieren beschrieben. Sie können einen Watchdog mit Hilfe der Funktionen der Bibliothek CmpIecTask.library für bestimmte SPS-Zyklen abschalten. Dies ist für Zyklen nützlich, die aufgrund von Initialisierungen mehr Zeit beanspruchen können. Beispiel Deaktivieren\/Reaktivieren des Watchdogs: VAR\nhIecTask : RTS_IEC_HANDLE;\nEND_VAR\n\nhIecTask := IecTaskGetCurrent(0);\nIecTaskDisableWatchdog(hIecTask); \/\/Watchdog disabled\n...\nIecTaskEnableWatchdog(hIecTask); \/\/Watchdog enabled Der Watchdog wird vor der Initialisierung mit IecTaskDisableWatchDog für den Rest des Zyklus abgeschaltet und ist beim nächsten Zyklus automatisch wieder aktiv. Der Watchdog kann nach der Initialisierung mit IecTaskEnableWatchDog wieder eingeschaltet werden. Die Überwachung ist dann bereits für den Rest des Zyklus wieder aktiv (das Watchdog-Zeitfenster beginnt von vorne). Initialisierungen von Funktionsbausteinen, die innerhalb der Methode FB_Init stattfinden, sind davon nicht betroffen. Aber es gab das Limit von < 30 Sekunden aufgrund des Communication-Timeouts. Dieses Zeitlimit besteht seit V3.5 SP18 nicht mehr, da die Online-Dienste asynchron ausgeführt werden. Der normale Watchdog einer IEC-Task spricht an, wenn die Ausführungszeit der IEC-Task die Watchdogzeit überschreitet. Der sogenannte „Omitted Cylce“-Watchdog spricht an, wenn die Task erst gar nicht anläuft. Das ist der Fall, wenn die Task innerhalb dem Maximum von < Zeit * Empfindlichkeit > oder <2 * Intervall > gar keinen Zyklus ausführt. Ursache könnte eine Verdrängung durch andere Tasks sein oder eine Störung im Scheduler, der die Task nicht mehr aktiviert. " }, 
{ "title" : "Programmaufrufe ", 
"url" : "_cds_f_reference_task.html#UUID-f12a90d6-4453-79d4-dbff-668d397ebde9_section-idm234752870373128", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Task \/ Registerkarte: Konfiguration \/ Programmaufrufe ", 
"snippet" : "Programmbausteine ( POU -Objekt mit Typ PROGRAM ), die von der Task nacheinander aufgerufen werden Die Reihenfolge, in der die Bausteine aufgerufen werden, entspricht der hier konfigurierten Aufrufreihenfolge von oben nach unten. Aufruf hinzufügen Öffnet die Eingabehilfe. Wählen Sie einen PROGRAM -B...", 
"body" : "Programmbausteine ( POU -Objekt mit Typ PROGRAM ), die von der Task nacheinander aufgerufen werden Die Reihenfolge, in der die Bausteine aufgerufen werden, entspricht der hier konfigurierten Aufrufreihenfolge von oben nach unten. Aufruf hinzufügen Öffnet die Eingabehilfe. Wählen Sie einen PROGRAM -Baustein aus. Beim Verlassen der Eingabehilfe mit OK wird dieser als neuer Aufruf der Liste unten hinzugefügt. Aufruf entfernen Entfernt den Aufruf Aufruf ändern Öffnet für den selektierten Aufruf die Eingabehilfe. Wählen Sie einen anderen PROGRAM -Baustein aus. Beim Verlassen der Eingabehilfe mit OK wird der Aufruf geändert. Nach oben Nach unten Verschiebt die Position des Aufrufs in der Liste nach oben oder nach unten. Dementsprechend ändert sich zur Laufzeit die Aufrufreihenfolge. Baustein öffnen Öffnet den Bausteineditor mit der Deklaration und Implementierung des PROGRAM -Bausteins " }, 
{ "title" : "Objekt: Trace ", 
"url" : "_cds_obj_trace_1.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Objekte \/ Objekt: Trace ", 
"snippet" : "Trace Symbol: Ein Objekt vom Typ Trace dient der Konfiguration und Darstellung von applikationsspezifischen Tracedaten in einem oder beliebig vielen Diagrammen. Zur Laufzeit der Applikation werden dazu auf der Steuerung Werteverläufe von Tracevariablen erfasst, die Sie währenddessen in CODESYS im Tr...", 
"body" : "Trace Symbol: Ein Objekt vom Typ Trace dient der Konfiguration und Darstellung von applikationsspezifischen Tracedaten in einem oder beliebig vielen Diagrammen. Zur Laufzeit der Applikation werden dazu auf der Steuerung Werteverläufe von Tracevariablen erfasst, die Sie währenddessen in CODESYS im Traceeditor beobachten können. Für weitere Informationen sehen Sie: ..\/CODESYS Trace\/_cds_obj_trace.html " }, 
{ "title" : "Menübefehle ", 
"url" : "_cds_struct_reference_commands.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle ", 
"snippet" : "Standardmäßig sind die wichtigsten Befehle in der Benutzeroberfläche von CODESYS verfügbar. Wenn Sie die Menükonfiguration individuell anpassen möchten, wählen Sie den Befehl Tools → Anpassen → Menu ....", 
"body" : "Standardmäßig sind die wichtigsten Befehle in der Benutzeroberfläche von CODESYS verfügbar. Wenn Sie die Menükonfiguration individuell anpassen möchten, wählen Sie den Befehl Tools → Anpassen → Menu . " }, 
{ "title" : "Bearbeiten ", 
"url" : "_cds_f_commands_edit.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Standardbefehle ", 
"url" : "_cds_cmd_standard_edit_commands.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Standardbefehle ", 
"snippet" : "CODESYS stellt Ihnen die folgenden Standardbefehle zur Verfügung: : Rückgängig Tastaturkürzel: Strg + Z : Wiederherstellen Tastaturkürzel: Strg + Y : Ausschneiden Tastaturkürzel: Strg + X : Kopieren Tastaturkürzel: Strg + C : Einfügen Tastaturkürzel: Strg + V : Löschen Tastaturkürzel: Entf Alles sel...", 
"body" : "CODESYS stellt Ihnen die folgenden Standardbefehle zur Verfügung: : Rückgängig Tastaturkürzel: Strg + Z : Wiederherstellen Tastaturkürzel: Strg + Y : Ausschneiden Tastaturkürzel: Strg + X : Kopieren Tastaturkürzel: Strg + C : Einfügen Tastaturkürzel: Strg + V : Löschen Tastaturkürzel: Entf Alles selektieren Tastaturkürzel: Strg + A Der Befehl Einfügen wird nicht von allen Editoren unterstützt oder kann in manchen nur eingeschränkt verwendet werden. In grafischen Editoren wird der Befehl nur unterstützt, wenn durch das Einfügen eine korrektes Konstrukt entsteht. In Objektbäumen, wie zum Beispiel im POUs- oder Gerätefenster bezieht sich der Befehl auf das gerade ausgewählte Objekt. Mehrfachauswahl ist möglich. " }, 
{ "title" : "Befehl: Suchen, Im Projekt suchen ", 
"url" : "_cds_cmd_find.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Suchen, Im Projekt suchen ", 
"snippet" : "Suchen, Im Projekt suchen Symbol: Tastaturkürzel: Strg + F Symbol: Tastaturkürzel: Strg + Umschalt + F Funktion : Die Befehle durchsuchen das Projekt oder Teile davon nach einer bestimmten Zeichenkette. Aufruf : Menü Bearbeiten → Suchen Ersetzen Der Befehl öffnet den Dialog Suchen , in dem die zu su...", 
"body" : "Suchen, Im Projekt suchen Symbol: Tastaturkürzel: Strg + F Symbol: Tastaturkürzel: Strg + Umschalt + F Funktion : Die Befehle durchsuchen das Projekt oder Teile davon nach einer bestimmten Zeichenkette. Aufruf : Menü Bearbeiten → Suchen Ersetzen Der Befehl öffnet den Dialog Suchen , in dem die zu suchende Zeichenkette eingegeben und die Suchoptionen definiert werden. " }, 
{ "title" : "Dialog: Suchen ", 
"url" : "_cds_cmd_find.html#UUID-dda521c8-7f56-fdfd-8ee1-6c9e2a366507_id_a6c8fe1a8c54f84c0a8640e01eb30dd_id_33f08ba0ec4b8c25c0a864636ff12b4d", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Suchen, Im Projekt suchen \/ Dialog: Suchen ", 
"snippet" : "Suchen nach Zeichenkette, nach der gesucht wird Groß-\/Kleinschreibung : Die Suche beachtet Groß-\/Kleinschreibung. Nur ganzes Wort : Nur Zeichenketten, die genau die gesuchte Zeichenkette wiedergeben, werden gefunden. Nach oben suchen : Der angegebene Suchraum wird nach oben durchlaufen. : Der angege...", 
"body" : "Suchen nach Zeichenkette, nach der gesucht wird Groß-\/Kleinschreibung : Die Suche beachtet Groß-\/Kleinschreibung. Nur ganzes Wort : Nur Zeichenketten, die genau die gesuchte Zeichenkette wiedergeben, werden gefunden. Nach oben suchen : Der angegebene Suchraum wird nach oben durchlaufen. : Der angegebene Suchraum wird nach unten durchlaufen. Reguläre Ausdrücke verwenden Über die Schaltfläche erhalten Sie Unterstützung bei der Eingabe von regulären Ausdrücken (Regular Expressions). Suchen in : Auswahlliste mit den Bereichen des Projekts, die durchsucht werden sollen Aktiver Editor Alle geöffneten Editoren Ausgewählte Objekte & Subobjekte Gesamtes Projekt Gesamtes Projekt & nicht kompilierte Bibliotheken Nur Selektion : Öffnet einen Dialog, in dem Sie einstellen, in welchen Bereichen des Projekts gesucht werden soll (siehe unten) Weitersuchen Starten der Suche Alle Suchen Alle Suchergebnisse erscheinen im Meldungsfenster mit Angabe von Objektpfad, Projektname, Objektname und Objektposition. Mögliche Zusätze bei der Position: (Dekl) = Deklarationsteil des Objekts, (Impl) = Implementierungsteil des Objekts Mit einem Doppelklick auf den Listeneintrag springt der Fokus zur Trefferposition im jeweiligen Objekteditor. Ersetzen Wechselt zum Dialog Ersetzen Die Farbe der Markierung von Suchergebnissen kann in den Optionen des Texteditors angepasst werden. Dies erfolgt über den Parameter Selektionsfarbe - Inaktiv in der Registerkarte Textbereich . " }, 
{ "title" : "Dialog für die Einstellung der zu durchsuchenden Objekte ", 
"url" : "_cds_cmd_find.html#UUID-dda521c8-7f56-fdfd-8ee1-6c9e2a366507_id_a6c8fe1a8c54f84c0a8640e01eb30dd_id_5df2ec8bf5f911e3b101fb023b1f8cd5", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Suchen, Im Projekt suchen \/ Dialog für die Einstellung der zu durchsuchenden Objekte ", 
"snippet" : "Gesamtes Projekt Alle editierbaren Stellen in allen Objekten des Projekts werden durchsucht. Gesamtes Projekt und alle nicht kompilierten Bibliotheken Alle editierbaren Stellen in allen Objekten des Projekts und eingebundener, nicht kompilierter Bibliotheken werden durchsucht Innerhalb der folgenden...", 
"body" : "Gesamtes Projekt Alle editierbaren Stellen in allen Objekten des Projekts werden durchsucht. Gesamtes Projekt und alle nicht kompilierten Bibliotheken Alle editierbaren Stellen in allen Objekten des Projekts und eingebundener, nicht kompilierter Bibliotheken werden durchsucht Innerhalb der folgenden Objekte Nur die editierbaren Stellen innerhalb der hier definierten Objekte werden durchsucht: Schema : Durch den Befehl Speichern wird die augenblickliche Suchkonfiguration unter dem angegebenen Namen gespeichert. Alle gespeicherten Schemata sind über die Auswahlliste ( ) verfügbar. Objekttypen : : Das Objekt wird durchsucht. Namensfilter : Namensfilter für die zu durchsuchenden Objekte Der Platzhalter „*“ kann verwendet werden. Beispiel: Filter „*CAN*“: Es werden alle Objekte durchsucht, die in ihrem Namen „CAN“ enthalten haben. Alle geöffneten Editoren Alle Editoren, die gerade in einem Fenster geöffnet sind, werden durchsucht. Aktiver Editor Nur der Editor, in dem gerade der Cursor steht, wird durchsucht. Nur Selektion Nur der gerade in einem Objekt selektierte Text wird durchsucht. " }, 
{ "title" : "Befehl: Ersetzen, Im Projekt ersetzen ", 
"url" : "_cds_cmd_replace.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Ersetzen, Im Projekt ersetzen ", 
"snippet" : "Ersetzen, Im Projekt ersetzen Symbol: Tastaturkürzel: Strg + H Symbol: Tastaturkürzel: Strg + Umschalt + H Funktion : Die Befehle durchsuchen das Projekt oder Teile davon nach einer bestimmten Zeichenkette und ersetzen diese. Aufruf : Menü Bearbeiten → Suchen Ersetzen Voraussetzung : Die Applikation...", 
"body" : "Ersetzen, Im Projekt ersetzen Symbol: Tastaturkürzel: Strg + H Symbol: Tastaturkürzel: Strg + Umschalt + H Funktion : Die Befehle durchsuchen das Projekt oder Teile davon nach einer bestimmten Zeichenkette und ersetzen diese. Aufruf : Menü Bearbeiten → Suchen Ersetzen Voraussetzung : Die Applikation ist im Onlinebetrieb. Der Befehl öffnet den Dialog Ersetzen , in dem die zu ersetzende Zeichenkette und die neue Zeichenkette eingegeben und die Suchoptionen definiert werden. Zusätzlich zu den Optionen des Dialogs Suchen sind noch folgende Einstellungen möglich: Ersetzen mit Eingabefeld für die neue Zeichenkette Ersetzen Damit wird jeweils die nächste gefundene Zeichenkette im Editor hervorgehoben und ersetzt (schrittweises Ersetzen). Alles Ersetzen Alle gefundenen Zeichenketten werden auf einmal ersetzt, ohne dass sie in den Editoren angezeigt werden. Geänderte Objekte offen lassen nach „Alles Ersetzen“ Die Editoren der gefundenen Objekte bleiben geöffnet. Ein Ersetzen in referenzierten Bibliotheken ist nicht möglich. " }, 
{ "title" : "Befehl: Weitersuchen ", 
"url" : "_cds_cmd_find_next.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Weitersuchen ", 
"snippet" : "Weitersuchen Symbol: Tastaturkürzel: F3 Funktion : Dieser Befehl selektiert bei der Suche nach einer bestimmten Zeichenkette im Projekt das nächste Suchergebnis an dessen Position im betreffenden Editor. Aufruf : Menü Bearbeiten → Suchen Ersetzen Voraussetzung : Sie haben mit Hilfe der Befehle Suche...", 
"body" : "Weitersuchen Symbol: Tastaturkürzel: F3 Funktion : Dieser Befehl selektiert bei der Suche nach einer bestimmten Zeichenkette im Projekt das nächste Suchergebnis an dessen Position im betreffenden Editor. Aufruf : Menü Bearbeiten → Suchen Ersetzen Voraussetzung : Sie haben mit Hilfe der Befehle Suchen oder Ersetzen eine Suche nach einer bestimmten Zeichenkette im Projekt gestartet. Für weitere Informationen siehe: Projektweites Suchen und Ersetzen" }, 
{ "title" : "Befehl: Weitersuchen (Auswahl) ", 
"url" : "_cds_cmd_find_next_selected.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Weitersuchen (Auswahl) ", 
"snippet" : "Weitersuchen (Auswahl) Tastaturkürzel: Strg + F Funktion : Der Befehl sucht nach der nächsten Zeichenkette im Projekt, die mit der übereinstimmt, die gerade selektiert ist, oder in der gerade der Cursor steht. Aufruf : Menü Bearbeiten → Suchen Ersetzen Voraussetzung : Sie haben den Cursor in einer e...", 
"body" : "Weitersuchen (Auswahl) Tastaturkürzel: Strg + F Funktion : Der Befehl sucht nach der nächsten Zeichenkette im Projekt, die mit der übereinstimmt, die gerade selektiert ist, oder in der gerade der Cursor steht. Aufruf : Menü Bearbeiten → Suchen Ersetzen Voraussetzung : Sie haben den Cursor in einer editierbaren Zeichenkette im Projekt platziert, oder Sie haben eine editierbare Zeichenkette selektiert. Für weitere Informationen siehe: Projektweites Suchen und Ersetzen" }, 
{ "title" : "Befehl: Vorheriges suchen ", 
"url" : "_cds_cmd_find_previous.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Vorheriges suchen ", 
"snippet" : "Vorheriges suchen Symbol: Tastaturkürzel: Umschalt + F3 Funktion : Dieser Befehl selektiert bei der Suche nach einer bestimmten Zeichenkette im Projekt das vorherige Suchergebnis an dessen Position im betreffenden Editor. Aufruf : Menü Bearbeiten → Suchen Ersetzen Voraussetzung : Sie haben mit Hilfe...", 
"body" : "Vorheriges suchen Symbol: Tastaturkürzel: Umschalt + F3 Funktion : Dieser Befehl selektiert bei der Suche nach einer bestimmten Zeichenkette im Projekt das vorherige Suchergebnis an dessen Position im betreffenden Editor. Aufruf : Menü Bearbeiten → Suchen Ersetzen Voraussetzung : Sie haben mit Hilfe der Befehle Suchen oder Ersetzen eine Suche nach einer bestimmten Zeichenkette im Projekt gestartet. Für weitere Informationen siehe: Lesezeichen setzen und verwenden" }, 
{ "title" : "Befehl: Vorheriges suchen (Auswahl) ", 
"url" : "_cds_cmd_find_previous_selected.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Vorheriges suchen (Auswahl) ", 
"snippet" : "Vorheriges suchen (Auswahl) Tastaturkürzel: Strg + Umschalt + F3 Funktion : Der Befehl sucht nach der vorherigen Zeichenkette im Projekt, die mit der übereinstimmt, die gerade selektiert ist, oder in der gerade der Cursor steht. Aufruf : Menü Bearbeiten → Suchen Ersetzen Voraussetzung : Sie haben de...", 
"body" : "Vorheriges suchen (Auswahl) Tastaturkürzel: Strg + Umschalt + F3 Funktion : Der Befehl sucht nach der vorherigen Zeichenkette im Projekt, die mit der übereinstimmt, die gerade selektiert ist, oder in der gerade der Cursor steht. Aufruf : Menü Bearbeiten → Suchen Ersetzen Voraussetzung : Sie haben den Cursor in einer editierbaren Zeichenkette im Projekt platziert, oder Sie haben eine editierbare Zeichenkette selektiert. Für weitere Informationen siehe: Projektweites Suchen und Ersetzen" }, 
{ "title" : "Befehl: Datei als Text einfügen ", 
"url" : "_cds_cmd_insert_file_as_text.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Datei als Text einfügen ", 
"snippet" : "Datei als Text einfügen Funktion : Der Befehl kopiert den Inhalt einer Textdatei in den aktiven Editor an die aktuelle Cursorposition. Aufruf : Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn mit Hilfe des Dialogs Tools → Anpassen aus der Befehlskategorie Texteditor in ein Menü...", 
"body" : "Datei als Text einfügen Funktion : Der Befehl kopiert den Inhalt einer Textdatei in den aktiven Editor an die aktuelle Cursorposition. Aufruf : Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn mit Hilfe des Dialogs Tools → Anpassen aus der Befehlskategorie Texteditor in ein Menü einfügen. Voraussetzung : Die Datei muss die Dateiendung .txt haben. Der Befehl ist nur in einem Texteditor verfügbar. Viele Entwicklungsumgebungen und Textverarbeitungsprogamme bieten die Möglichkeit, Code und Text als Textdatei zu exportieren. Der Inhalt dieser Datei kann mit diesem Befehl in den Editor kopiert werden. Für weitere Informationen siehe: Texteditor" }, 
{ "title" : "Befehl: Überschreibmodus ", 
"url" : "_cds_cmd_overwrite_mode.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Überschreibmodus ", 
"snippet" : "Überschreibmodus Tastaturkürzel: Einfg Funktion : Dieser Befehl \\ aktiviert den Überschreibmodus. Aufruf : Menü Bearbeiten → Erweitert Voraussetzung : Ein Texteditor ist geöffnet. Wenn der Überschreibmodus aktiviert ist, werden Zeichen vor dem Cursor bei der Eingabe neuer Zeichen überschrieben. Wenn...", 
"body" : "Überschreibmodus Tastaturkürzel: Einfg Funktion : Dieser Befehl \\ aktiviert den Überschreibmodus. Aufruf : Menü Bearbeiten → Erweitert Voraussetzung : Ein Texteditor ist geöffnet. Wenn der Überschreibmodus aktiviert ist, werden Zeichen vor dem Cursor bei der Eingabe neuer Zeichen überschrieben. Wenn der Überschreibemodus deaktiviert ist, werden Zeichen eingefügt und bestehende Zeichen vor dem Cursor bleiben erhalten. " }, 
{ "title" : "Befehl: Leerzeichen anzeigen ", 
"url" : "_cds_cmd_view_whitespace.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Leerzeichen anzeigen ", 
"snippet" : "Leerzeichen anzeigen Symbol: Funktion : Der Befehl bewirkt, dass Steuerzeichen für Leerzeichen und Tabulatoren angezeigt werden. Aufruf : Menü Bearbeiten → Erweitert Voraussetzung : Ein Texteditor ist geöffnet. CODESYS visualisiert Leerzeichen durch einen Punkt und Tabulatoren durch einen Pfeil. Für...", 
"body" : "Leerzeichen anzeigen Symbol: Funktion : Der Befehl bewirkt, dass Steuerzeichen für Leerzeichen und Tabulatoren angezeigt werden. Aufruf : Menü Bearbeiten → Erweitert Voraussetzung : Ein Texteditor ist geöffnet. CODESYS visualisiert Leerzeichen durch einen Punkt und Tabulatoren durch einen Pfeil. Für weitere Informationen siehe: Texteditor" }, 
{ "title" : "Befehl: Einrückungshilfslinien anzeigen ", 
"url" : "_cds_cmd_view_indentation_guide.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Einrückungshilfslinien anzeigen ", 
"snippet" : "Einrückungshilfslinien anzeigen Funktion : Der Befehl aktiviert die Einrückungshilfslinien. Aufruf : Menü Bearbeiten → Erweitert Voraussetzung : Ein Texteditor ist geöffnet. Wenn die Einrückungshilfslinien aktiviert sind, wird für jede manuelle Einrückung im Code eine gestrichelte Linie eingefügt. D...", 
"body" : "Einrückungshilfslinien anzeigen Funktion : Der Befehl aktiviert die Einrückungshilfslinien. Aufruf : Menü Bearbeiten → Erweitert Voraussetzung : Ein Texteditor ist geöffnet. Wenn die Einrückungshilfslinien aktiviert sind, wird für jede manuelle Einrückung im Code eine gestrichelte Linie eingefügt. Dies erleichtert den Überblick über die verschiedenen Ebenen im Code. Manuelle Einrückungen können Sie mit der Taste Tabulator einfügen. Für weitere Informationen siehe: Texteditor" }, 
{ "title" : "Befehl: Gehe zu Zeile ", 
"url" : "_cds_cmd_go_to_line.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Gehe zu Zeile ", 
"snippet" : "Gehe zu Zeile Funktion : Mit dem Befehl springt der Cursor zu einer definierten Zeile im Code. Aufruf : Menü Bearbeiten → Erweitert Voraussetzung : Ein Texteditor ist geöffnet. Der Befehls öffnet einen Dialog mit einem Eingabefeld Zeilennummer ....", 
"body" : "Gehe zu Zeile Funktion : Mit dem Befehl springt der Cursor zu einer definierten Zeile im Code. Aufruf : Menü Bearbeiten → Erweitert Voraussetzung : Ein Texteditor ist geöffnet. Der Befehls öffnet einen Dialog mit einem Eingabefeld Zeilennummer . " }, 
{ "title" : "Befehl: In Großbuchstaben umwandeln ", 
"url" : "_cds_cmd_make_uppercase.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: In Großbuchstaben umwandeln ", 
"snippet" : "In Großbuchstaben umwandeln Tastaturkürzel: Strg + Umschalt + U Funktion : Der Befehl wandelt alle Kleinbuchstaben im selektierten Code in Großbuchstaben um. Aufruf : Menü Bearbeiten → Erweitert Voraussetzung : Ein Texteditor ist geöffnet und Code ist selektiert, oder der Deklarationseditor ist geöf...", 
"body" : "In Großbuchstaben umwandeln Tastaturkürzel: Strg + Umschalt + U Funktion : Der Befehl wandelt alle Kleinbuchstaben im selektierten Code in Großbuchstaben um. Aufruf : Menü Bearbeiten → Erweitert Voraussetzung : Ein Texteditor ist geöffnet und Code ist selektiert, oder der Deklarationseditor ist geöffnet und Variablendeklarationen sind selektiert. Für weitere Informationen siehe: Texteditor" }, 
{ "title" : "Befehl: In Kleinbuchstaben umwandeln ", 
"url" : "_cds_cmd_make_lowercase.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: In Kleinbuchstaben umwandeln ", 
"snippet" : "In Kleinbuchstaben umwandeln Tastaturkürzel: Strg + U Funktion : Der Befehl wandelt alle Großbuchstaben im selektierten Code in Kleinbuchstaben um. Aufruf : Menü Bearbeiten → Erweitert Voraussetzung : Ein Texteditor ist geöffnet und Code ist selektiert, oder der Deklarationseditor ist geöffnet und V...", 
"body" : "In Kleinbuchstaben umwandeln Tastaturkürzel: Strg + U Funktion : Der Befehl wandelt alle Großbuchstaben im selektierten Code in Kleinbuchstaben um. Aufruf : Menü Bearbeiten → Erweitert Voraussetzung : Ein Texteditor ist geöffnet und Code ist selektiert, oder der Deklarationseditor ist geöffnet und Variablendeklarationen sind selektiert. Für weitere Informationen siehe: Texteditor" }, 
{ "title" : "Befehl: Gehe zur zugehörigen Klammer ", 
"url" : "_cds_cmd_go_to_matching_bracket.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Gehe zur zugehörigen Klammer ", 
"snippet" : "Gehe zur zugehörigen Klammer Funktion : Der Befehl lässt den Cursor zum anderen Teil der selektierten Codeklammer springen. Aufruf : Menü Bearbeiten → Erweitert Voraussetzung : Ein Texteditor ist geöffnet und der Cursor ist bei einer öffnenden oder schließenden Codeklammer positioniert. Wenn Sie den...", 
"body" : "Gehe zur zugehörigen Klammer Funktion : Der Befehl lässt den Cursor zum anderen Teil der selektierten Codeklammer springen. Aufruf : Menü Bearbeiten → Erweitert Voraussetzung : Ein Texteditor ist geöffnet und der Cursor ist bei einer öffnenden oder schließenden Codeklammer positioniert. Wenn Sie den Cursor bei einer Codeklammer positionieren, zeigt CODESYS die korrespondierende Klammer farblich an, wenn Sie die Option Zusammengehörige Klammern in den CODESYS -Projektoptionen in der Kategorie Texteditor , Registerkarte Textbereich aktiviert haben. " }, 
{ "title" : "Befehl: Bis zur zugehörigen Klammer selektieren ", 
"url" : "_cds_cmd_select_to_matching_bracket.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Bis zur zugehörigen Klammer selektieren ", 
"snippet" : "Bis zur zugehörigen Klammer selektieren Funktion : Der Befehl wählt den gesamten Code-Abschnitt unter der momentan selektierten Codeklammer aus. Aufruf : Menü Bearbeiten → Erweitert Voraussetzung : Ein Texteditor ist geöffnet und der Cursor ist bei einer öffnenden oder schließenden Codeklammer posit...", 
"body" : "Bis zur zugehörigen Klammer selektieren Funktion : Der Befehl wählt den gesamten Code-Abschnitt unter der momentan selektierten Codeklammer aus. Aufruf : Menü Bearbeiten → Erweitert Voraussetzung : Ein Texteditor ist geöffnet und der Cursor ist bei einer öffnenden oder schließenden Codeklammer positioniert. Wenn Sie den Cursor bei einer Codeklammer positionieren, zeigt CODESYS die korrespondierende Klammer farblich an, wenn Sie die Option Zusammengehörige Klammern in den CODESYS -Projektoptionen in der Kategorie Texteditor , Registerkarte Textbereich aktiviert haben. Für weitere Informationen siehe: Texteditor" }, 
{ "title" : "Befehl: Alles ausklappen ", 
"url" : "_cds_cmd_expand_all.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Alles ausklappen ", 
"snippet" : "Alles ausklappen Funktion : Der Befehl klappt alle reduzierten Codeabschnitte (Plus-Symbol) im Texteditor oder Fundstellen in der Querverweisliste wieder auf, so dass der Code beziehungsweise alle Fundstellen wieder komplett angezeigt wird. Voraussetzung : Ein Texteditor ist aktiv und im Dialog Opti...", 
"body" : "Alles ausklappen Funktion : Der Befehl klappt alle reduzierten Codeabschnitte (Plus-Symbol) im Texteditor oder Fundstellen in der Querverweisliste wieder auf, so dass der Code beziehungsweise alle Fundstellen wieder komplett angezeigt wird. Voraussetzung : Ein Texteditor ist aktiv und im Dialog Optionen , Kategorie Texteditor ist die Einrückung aktiviert. Oder die Querverweisliste ist aktiv. Aufruf : In Texteditoren: Menü Bearbeiten → Erweitert , Kontextmenü; in der Querverweisliste: Kontextmenü Für weitere Informationen siehe: Texteditor" }, 
{ "title" : "Befehl: Alles einklappen ", 
"url" : "_cds_cmd_collapse_all.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Alles einklappen ", 
"snippet" : "Alles einklappen Funktion : Der Befehl klappt alle eingerückten Codeabschnitte (Minus-Symbol am Wurzelknoten) im Texteditor oder Fundstellen in der Querverweisliste gleichzeitig ein. Dadurch werden nur noch die oberste Ebene des Codes, beziehungsweise nur die Wurzelknoten der Fundstellen angezeigt. ...", 
"body" : "Alles einklappen Funktion : Der Befehl klappt alle eingerückten Codeabschnitte (Minus-Symbol am Wurzelknoten) im Texteditor oder Fundstellen in der Querverweisliste gleichzeitig ein. Dadurch werden nur noch die oberste Ebene des Codes, beziehungsweise nur die Wurzelknoten der Fundstellen angezeigt. Voraussetzung : Ein Texteditor ist aktiv und im Dialog Optionen , Kategorie Texteditor ist die Einrückung aktiviert. Oder die Querverweisliste ist aktiv. Aufruf : In Texteditoren: Menü Bearbeiten → Erweitert , Kontextmenü; in der Querverweisliste: Kontextmenü Für weitere Informationen siehe: Texteditor" }, 
{ "title" : "Befehl: Selektierte Zeilen auskommentieren ", 
"url" : "_cds_cmd_comment_out.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Selektierte Zeilen auskommentieren ", 
"snippet" : "Selektierte Zeilen auskommentieren Symbol: Tastaturkürzel: Strg + O Funktion : Der Befehl fügt Kommentarzeichen (‚\/\/‘) am Anfang der selektierten Zeilen ein. Aufruf : Menü Bearbeiten → Erweitert , Kontextmenü Voraussetzung : Der Cursor steht im ST-Editor in einer Zeile der Implementierung oder mehre...", 
"body" : "Selektierte Zeilen auskommentieren Symbol: Tastaturkürzel: Strg + O Funktion : Der Befehl fügt Kommentarzeichen (‚\/\/‘) am Anfang der selektierten Zeilen ein. Aufruf : Menü Bearbeiten → Erweitert , Kontextmenü Voraussetzung : Der Cursor steht im ST-Editor in einer Zeile der Implementierung oder mehrere Zeilen im ST-Editor sind selektiert. " }, 
{ "title" : "Befehl: Selektierte Zeilen Auskommentierung entfernen ", 
"url" : "_cds_cmd_uncomment.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Selektierte Zeilen Auskommentierung entfernen ", 
"snippet" : "Selektierte Zeilen Auskommentierung entfernen Symbol , Tastaturkürzel STRG + I Funktion : Aufruf : Menü Bearbeiten -> Erweitert , Kontexmenü Voraussetzung : Der Cursor steht im ST-Editor in einer Zeile der Implementierung oder mehrere Zeilen im ST-Editor sind selektiert....", 
"body" : "Selektierte Zeilen Auskommentierung entfernen Symbol , Tastaturkürzel STRG + I Funktion : Aufruf : Menü Bearbeiten -> Erweitert , Kontexmenü Voraussetzung : Der Cursor steht im ST-Editor in einer Zeile der Implementierung oder mehrere Zeilen im ST-Editor sind selektiert. " }, 
{ "title" : "Befehl: Inline-Monitoring aktivieren ", 
"url" : "_cds_cmd_toggle_inline_monitoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Inline-Monitoring aktivieren ", 
"snippet" : "Inline-Monitoring aktivieren Funktion : Der Befehl schaltet die Funktionalität „Inline-Monitoring“ ein oder, wenn sie gerade aktiviert ist, wieder aus. Dies wirkt synchron mit dem gleichnamigen Schalter in den Texteditor-Optionen, Kategorie Texteditor . Voraussetzung : Ein Texteditor ist aktiv. Aufr...", 
"body" : "Inline-Monitoring aktivieren Funktion : Der Befehl schaltet die Funktionalität „Inline-Monitoring“ ein oder, wenn sie gerade aktiviert ist, wieder aus. Dies wirkt synchron mit dem gleichnamigen Schalter in den Texteditor-Optionen, Kategorie Texteditor . Voraussetzung : Ein Texteditor ist aktiv. Aufruf : Kontextmenü des Texteditors, dort im Untermenü Erweitert Für weitere Informationen siehe: Monitoring von Werten" }, 
{ "title" : "Befehl: Lesezeichen ein-\/ausschalten ", 
"url" : "_cds_cmd_toggle_bookmark.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Lesezeichen ein-\/ausschalten ", 
"snippet" : "Lesezeichen ein-\/ausschalten Symbol: Tastaturkürzel: Strg + F12 Funktion : Der Befehl setzt oder löscht ein Lesezeichen an der aktuellen Position. Aufruf : Menü Bearbeiten → Lesezeichen Voraussetzung : Eine POU ist im Editor geöffnet und der Cursor steht in einer Programmzeile. Für weitere Informati...", 
"body" : "Lesezeichen ein-\/ausschalten Symbol: Tastaturkürzel: Strg + F12 Funktion : Der Befehl setzt oder löscht ein Lesezeichen an der aktuellen Position. Aufruf : Menü Bearbeiten → Lesezeichen Voraussetzung : Eine POU ist im Editor geöffnet und der Cursor steht in einer Programmzeile. Für weitere Informationen siehe: Lesezeichen setzen und verwenden" }, 
{ "title" : "Befehl: Nächstes Lesezeichen (aktiver Editor) ", 
"url" : "_cds_cmd_next_bookmark_active_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Nächstes Lesezeichen (aktiver Editor) ", 
"snippet" : "Nächstes Lesezeichen (aktiver Editor) Symbol: Tastaturkürzel: F12 Funktion : Der Befehl springt zum nächsten Lesezeichen im aktiven Editor. Aufruf : Menü Bearbeiten → Lesezeichen Voraussetzung : Eine POU ist im Editor geöffnet und der Cursor steht in der POU. Für weitere Informationen siehe: Lesezei...", 
"body" : "Nächstes Lesezeichen (aktiver Editor) Symbol: Tastaturkürzel: F12 Funktion : Der Befehl springt zum nächsten Lesezeichen im aktiven Editor. Aufruf : Menü Bearbeiten → Lesezeichen Voraussetzung : Eine POU ist im Editor geöffnet und der Cursor steht in der POU. Für weitere Informationen siehe: Lesezeichen setzen und verwenden" }, 
{ "title" : "Befehl: Nächstes Lesezeichen ", 
"url" : "_cds_cmd_next_bookmark_global.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Nächstes Lesezeichen ", 
"snippet" : "Nächstes Lesezeichen Symbol: Funktion : Der Befehl springt in der Ansicht Lesezeichen und im Projekt zum nächsten Lesezeichen und öffnet die entsprechende POU. Die Reihenfolge, in der die Lesezeichen angesprungen werden, entspricht dabei der Reihenfolge der Lesezeichen in der Tabelle der Ansicht Les...", 
"body" : "Nächstes Lesezeichen Symbol: Funktion : Der Befehl springt in der Ansicht Lesezeichen und im Projekt zum nächsten Lesezeichen und öffnet die entsprechende POU. Die Reihenfolge, in der die Lesezeichen angesprungen werden, entspricht dabei der Reihenfolge der Lesezeichen in der Tabelle der Ansicht Lesezeichen . Aufruf : Schaltfläche Nächstes Lesezeichen in der Ansicht Lesezeichen Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn mit Hilfe des Dialogs Tools → Anpassen aus der Befehlskategorie Lesezeichen in ein Menü einfügen. Voraussetzung : Ein Projekt ist geöffnet. Die Ansicht Lesezeichen ist geöffnet. Für weitere Informationen siehe: Lesezeichen setzen und verwenden" }, 
{ "title" : "Befehl: Vorheriges Lesezeichen (aktiver Editor) ", 
"url" : "_cds_cmd_previous_bookmark_active_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Vorheriges Lesezeichen (aktiver Editor) ", 
"snippet" : "Vorheriges Lesezeichen (aktiver Editor) Symbol: Tastaturkürzel: Umschalt + F12 Funktion : Der Befehl springt zum vorherigen Lesezeichen im aktiven Editor. Aufruf : Menü Bearbeiten → Lesezeichen Eine POU ist im Editor geöffnet und der Cursor steht in der POU. Für weitere Informationen siehe: Projektw...", 
"body" : "Vorheriges Lesezeichen (aktiver Editor) Symbol: Tastaturkürzel: Umschalt + F12 Funktion : Der Befehl springt zum vorherigen Lesezeichen im aktiven Editor. Aufruf : Menü Bearbeiten → Lesezeichen Eine POU ist im Editor geöffnet und der Cursor steht in der POU. Für weitere Informationen siehe: Projektweites Suchen und Ersetzen" }, 
{ "title" : "Befehl: Vorheriges Lesezeichen ", 
"url" : "_cds_cmd_previous_bookmark_global.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Vorheriges Lesezeichen ", 
"snippet" : "Vorheriges Lesezeichen Symbol: Funktion : Der Befehl springt in der Ansicht Lesezeichen und im Projekt zum vorherigen Lesezeichen und öffnet die entsprechende POU. Die Reihenfolge, in der die Lesezeichen angesprungen werden, entspricht dabei der Reihenfolge der Lesezeichen in der Tabelle der Ansicht...", 
"body" : "Vorheriges Lesezeichen Symbol: Funktion : Der Befehl springt in der Ansicht Lesezeichen und im Projekt zum vorherigen Lesezeichen und öffnet die entsprechende POU. Die Reihenfolge, in der die Lesezeichen angesprungen werden, entspricht dabei der Reihenfolge der Lesezeichen in der Tabelle der Ansicht Lesezeichen . Aufruf : Schaltfläche Vorheriges Lesezeichen in der Ansicht Lesezeichen Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn mit Hilfe des Dialogs Tools → Anpassen aus der Befehlskategorie Lesezeichen in ein Menü einfügen. Voraussetzung : Ein Projekt ist geöffnet. Die Ansicht Lesezeichen ist geöffnet. Für weitere Informationen siehe: Lesezeichen setzen und verwenden" }, 
{ "title" : "Befehl: Alle Lesezeichen löschen (aktiver Editor) ", 
"url" : "_cds_cmd_clear_all_bookmarks_active_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Alle Lesezeichen löschen (aktiver Editor) ", 
"snippet" : "Alle Lesezeichen löschen (aktiver Editor) Symbol: Funktion : Der Befehl löscht alle Lesezeichen im aktiven Editor. Aufruf : Menü Bearbeiten → Lesezeichen Voraussetzung : Eine POU ist im Editor geöffnet und der Cursor steht in der POU. Für weitere Informationen siehe: Lesezeichen setzen und verwenden...", 
"body" : "Alle Lesezeichen löschen (aktiver Editor) Symbol: Funktion : Der Befehl löscht alle Lesezeichen im aktiven Editor. Aufruf : Menü Bearbeiten → Lesezeichen Voraussetzung : Eine POU ist im Editor geöffnet und der Cursor steht in der POU. Für weitere Informationen siehe: Lesezeichen setzen und verwenden" }, 
{ "title" : "Befehl: Alle Lesezeichen löschen ", 
"url" : "_cds_cmd_clear_all_bookmarks_global.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Alle Lesezeichen löschen ", 
"snippet" : "Alle Lesezeichen löschen Symbol: Funktion : Der Befehl löscht alle Lesezeichen des geöffneten Projekts. Aufruf : Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn mit Hilfe des Dialogs Tools → Anpassen aus der Befehlskategorie Lesezeichen in ein Menü einfügen. Voraussetzung : Ein...", 
"body" : "Alle Lesezeichen löschen Symbol: Funktion : Der Befehl löscht alle Lesezeichen des geöffneten Projekts. Aufruf : Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn mit Hilfe des Dialogs Tools → Anpassen aus der Befehlskategorie Lesezeichen in ein Menü einfügen. Voraussetzung : Eine POU ist im Editor geöffnet und der Cursor steht in der POU. Für weitere Informationen siehe: Lesezeichen setzen und verwenden" }, 
{ "title" : "Befehl: Querverweise ausgeben ", 
"url" : "_cds_cmd_browse_cross_references.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Querverweise ausgeben ", 
"snippet" : "Querverweise ausgeben Symbol: Funktion : Der Befehl zeigt alle Verwendungsstellen einer Variablen in der Ansicht Querverweisliste . Aufruf : Menü Bearbeiten → Symbol suchen , Symbolleiste in der Ansicht Querverweisliste Voraussetzung : Eine POU ist im Editor geöffnet und der Cursor steht in einer Va...", 
"body" : "Querverweise ausgeben Symbol: Funktion : Der Befehl zeigt alle Verwendungsstellen einer Variablen in der Ansicht Querverweisliste . Aufruf : Menü Bearbeiten → Symbol suchen , Symbolleiste in der Ansicht Querverweisliste Voraussetzung : Eine POU ist im Editor geöffnet und der Cursor steht in einer Variablen. Oder die Ansicht Querverweisliste ist geöffnet und eine Variable ist im Feld Name angegeben. Für weitere Informationen siehe: Verwendungsstellen mit der Querverweisliste finden" }, 
{ "title" : "Befehl: Globale Querverweise ausgeben ", 
"url" : "_cds_cmd_browse_global_cross_references.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Globale Querverweise ausgeben ", 
"snippet" : "Globale Querverweise ausgeben Symbol: Funktion : Der Befehl zeigt die Verwendungsstellen aller Variablen mit dem gleichen Namen in der Ansicht Querverweisliste . Im Gegensatz zum Befehl Querverweise ausgeben kann es sich dabei um unterschiedliche Variablen handeln. Aufruf : Menü Bearbeiten → Symbol ...", 
"body" : "Globale Querverweise ausgeben Symbol: Funktion : Der Befehl zeigt die Verwendungsstellen aller Variablen mit dem gleichen Namen in der Ansicht Querverweisliste . Im Gegensatz zum Befehl Querverweise ausgeben kann es sich dabei um unterschiedliche Variablen handeln. Aufruf : Menü Bearbeiten → Symbol suchen , Symbolleiste in der Ansicht Querverweisliste Voraussetzung : Eine POU ist im Editor geöffnet und der Cursor steht in einer Variablen. Oder die Ansicht Querverweisliste ist geöffnet und eine Variable ist im Feld Name angegeben. Für weitere Informationen siehe: Verwendungsstellen mit der Querverweisliste finden" }, 
{ "title" : "Befehl: Aufrufbaum ausgeben ", 
"url" : "_cds_cmd_browse_call_tree.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Aufrufbaum ausgeben ", 
"snippet" : "Aufrufbaum ausgeben Symbol: Funktion : Der Befehl öffnet die Ansicht Aufrufbaum , die die Aufrufe des Bausteins sowie seine Aufrufer darstellt. Aufruf : Menü Bearbeiten → Symbol suchen Kontextmenü Voraussetzung : Ein Baustein ist im Editor geöffnet und der Cursor steht in einer Variablen, oder ein B...", 
"body" : "Aufrufbaum ausgeben Symbol: Funktion : Der Befehl öffnet die Ansicht Aufrufbaum , die die Aufrufe des Bausteins sowie seine Aufrufer darstellt. Aufruf : Menü Bearbeiten → Symbol suchen Kontextmenü Voraussetzung : Ein Baustein ist im Editor geöffnet und der Cursor steht in einer Variablen, oder ein Baustein ist in der Ansicht Geräte oder POUs selektiert. " }, 
{ "title" : "Befehl: Variable deklarieren ", 
"url" : "_cds_cmd_declare_variable.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Variable deklarieren ", 
"snippet" : "Variable deklarieren Tastaturkürzel: Umschalt + F2 Funktion : Der Befehl öffnet den Dialog Variable deklarieren , der die Deklaration einer Variablen unterstützt. Aufruf : Menü Bearbeiten Voraussetzung : Ein Objekt oder ein Gerät des Projekts ist im Editor geöffnet. Durch die Autodeklarationsfunktio...", 
"body" : "Variable deklarieren Tastaturkürzel: Umschalt + F2 Funktion : Der Befehl öffnet den Dialog Variable deklarieren , der die Deklaration einer Variablen unterstützt. Aufruf : Menü Bearbeiten Voraussetzung : Ein Objekt oder ein Gerät des Projekts ist im Editor geöffnet. Durch die Autodeklarationsfunktion erscheint der Dialog Variable deklarieren auch, wenn der Cursor im Implementierungsteil einer POU in einer Zeile steht, die den Namen einer nicht deklarierten Variablen enthält. Als Voraussetzung hierfür müssen Sie den Befehl Tools → Optionen ausgewählt und in der Kategorie Intelligentes Kodieren die Option Unbekannte Variablen automatisch deklarieren (AutoDeclare) aktiviert haben. Durch die Smart-Tag-Funktion erscheint der Befehl Variable deklarieren auch, wenn Sie im Implementierungsteil des ST-Editors den Cursor auf eine Variable setzen, die nicht deklariert wurde, und anschließend auf klicken. " }, 
{ "title" : "Dialog: Variable deklarieren ", 
"url" : "_cds_cmd_declare_variable.html#UUID-bcf3934d-34a2-e1ad-d7f7-47aa728ded88_id_a21027ccec5d5fc0a8640e01ff1fb3_id_3fd5849fbf939f94c0a8640e00ee08a5", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Variable deklarieren \/ Dialog: Variable deklarieren ", 
"snippet" : "Gültigkeitsbereich Gültigkeitsbereich der noch nicht deklarierten Variable Beispiel: VAR (Standardeinstellung bei lokaler Variable) Name Noch nicht deklarierter Variablenname Beispiel: bIsValid Datentyp Beispiel: BOOL : Listet die Standarddatentypen auf Eingabehilfe : Öffnet den Dialog Eingabehilfe ...", 
"body" : "Gültigkeitsbereich Gültigkeitsbereich der noch nicht deklarierten Variable Beispiel: VAR (Standardeinstellung bei lokaler Variable) Name Noch nicht deklarierter Variablenname Beispiel: bIsValid Datentyp Beispiel: BOOL : Listet die Standarddatentypen auf Eingabehilfe : Öffnet den Dialog Eingabehilfe Arrayassistent : Öffnet den Dialog Array Objekt Objekt, in dem die neue Variable deklariert wird Standardmäßig das Objekt, das Sie gerade bearbeiten. Beispiel: fbA : Listet die Objekte auf, in denen die Variable deklariert werden kann Wenn für den ausgewählten Gültigkeitsbereich keine Objekte verfügbar sind, erscheint der Eintrag <Objekt anlegen> . Wenn Sie den Eintrag <Objekt anlegen> auswählen, öffnet sich der Dialog Objekt hinzufügen zur Erzeugung eines geeigneten Objekts. Initialisierungswert Bespiel: FALSE Wenn Sie keinen Initialisierungswert eingeben, wird die Variable automatisch initialisiert. : Öffnet den Dialog Initialisierungswert Diese Vorgehensweise ist für die Initialisierung von strukturierten Variablen hilfreich. Adresse Speicheradresse der Applikation für die noch nicht deklarierte Variable Beispiel: %IX1.0 Hinweis: Nur möglich bei folgenden Gültigkeitsbereichen: Lokale Variable ( VAR ) Globale Variable ( VAR_GLOBAL ) Persistente Variable ( PERSISTENT ) Flags Attribut-Schlüsselwörter CONSTANT : Schlüsselwort für eine Konstante RETAIN : Schlüsselwort für eine remanente Variable PERSISTENT : Schlüsselwort für eine persistente Variable (strenger als RETAIN ) Das ausgewählte Attribut-Schlüsselwort wird der Variablendeklaration hinzugefügt. Kommentar Beispiel: New input In1 Im tabellarischen Deklarationseditor erfolgt die Anzeige des eingegebenen Kommentars in der Spalte Kommentar , im textuellen Deklarationseditor oberhalb der Variablendeklaration. Änderungen mit Hilfe von Refactoring anwenden : Wenn Sie den Dialog beenden, wird die Variable noch nicht deklariert, sondern es öffnet sich zunächst der Dialog Refactoring . Dort können Sie Ihre Änderungen weiter bearbeiten. Die Option erscheint bei folgenden Gültigkeitsbereichen: Eingabevariable ( VAR_INPUT ) Ausgabevariable ( VAR_OUTPUT ) VAR_IN_OUT -Variablen (Eingabevariable und Ausgabevariable) OK Die Variable wird deklariert und sie erscheint in der Deklaration. Beispiel: VAR RETAIN\n \/\/ New input In1\n xIn1 AT %IX1.0: BOOL := FALSE;\nEND_VAR " }, 
{ "title" : "Dialog: Array ", 
"url" : "_cds_cmd_declare_variable.html#UUID-bcf3934d-34a2-e1ad-d7f7-47aa728ded88_id_a21027ccec5d5fc0a8640e01ff1fb3_id_0d35552abf939f96c0a8640e01838bc5", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Variable deklarieren \/ Dialog: Array ", 
"snippet" : "Dimensions- und Basistyp-Angabe Definition der Feldgrößen ( Dimension ) durch Eingeben der unteren und oberen Grenzen und des Basistyp des Arrays Den Basistypen können Sie direkt eingeben oder mit Hilfe der Dialoge Eingabehilfe oder Array , wenn Sie die Schaltfläche anklicken. Ergebnis Anzeige des d...", 
"body" : "Dimensions- und Basistyp-Angabe Definition der Feldgrößen ( Dimension ) durch Eingeben der unteren und oberen Grenzen und des Basistyp des Arrays Den Basistypen können Sie direkt eingeben oder mit Hilfe der Dialoge Eingabehilfe oder Array , wenn Sie die Schaltfläche anklicken. Ergebnis Anzeige des definierten Arrays CODESYS initialisiert nur Variablen neu, wenn Sie die Initialisierungswerte der Variablen geändert haben. " }, 
{ "title" : "Dialog: Initialisierungswert ", 
"url" : "_cds_cmd_declare_variable.html#UUID-bcf3934d-34a2-e1ad-d7f7-47aa728ded88_id_a21027ccec5d5fc0a8640e01ff1fb3_id_4086b2105903f5bdc0a864637bd9aa66", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Variable deklarieren \/ Dialog: Initialisierungswert ", 
"snippet" : "Auflistung der Variablen mit Namen ( Ausdruck ), Initialisierungswert und Datentyp Geänderte Initialisierungswerte werden fett dargestellt. Eingabefeld unterhalb der Liste Eingabe eines Initialisierungswerts für die selektierte Variable(n) Wert auf ausgewählte Zeilen anwenden Änderung des Initialisi...", 
"body" : "Auflistung der Variablen mit Namen ( Ausdruck ), Initialisierungswert und Datentyp Geänderte Initialisierungswerte werden fett dargestellt. Eingabefeld unterhalb der Liste Eingabe eines Initialisierungswerts für die selektierte Variable(n) Wert auf ausgewählte Zeilen anwenden Änderung des Initialisierungswerts der selektierten Zeile(n) entsprechend dem Wert des Eingabefelds Ausgewählte Zeilen auf Standardwerte zurücksetzen Herstellung der Standard-Initialisierungswerte OK CODESYS übernimmt die Initialisierungswerte in den Dialog Variable deklarieren . Falls die über diesen Dialog zu initialisierende Variable eine Funktionsbaustein-Instanz mit erweiterter FB_Init-Methode ist, wird oberhalb der Tabelle Initialisierungswert eine weitere Tabelle angezeigt. In dieser Tabelle werden die zusätzlichen FB_Init-Parameter aufgelistet. Die Bedeutung und Bedienung entspricht im Wesentlichen der unteren Tabelle mit folgenden Unterschieden: Es müssen alle Variablen mit Initialisierungswerten belegt sein. Ansonsten ist OK nicht anwählbar. Bei komplexen Datentypen (Strukturen, Arrays) werden keine darin enthaltenen Komponenten angezeigt (Typ kann nicht aufgeklappt werden). In diesem Fall muss der komplexe Typ mit einer entsprechenden Variable initialisiert werden. Bei so konfigurierten FB_Init-Parametern wird im Dialog Variable deklarieren ein entsprechendes Symbol hinter dem Initialisierungswert angezeigt. Für weitere Informationen siehe: Methode: und AT-Deklaration" }, 
{ "title" : "Befehl: Eingabehilfe ", 
"url" : "_cds_cmd_input_assistant.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Eingabehilfe ", 
"snippet" : "Eingabehilfe Symbol: Tastaturkürzel: F2 Funktion : Der Befehl öffnet den Dialog Eingabehilfe , der Sie bei der Auswahl eines an der aktuellen Cursorposition möglichen Programmierelements unterstützt. Aufruf : Menü Bearbeiten , Kontextmenü Voraussetzung : Eine POU ist im Editor geöffnet und der Curso...", 
"body" : "Eingabehilfe Symbol: Tastaturkürzel: F2 Funktion : Der Befehl öffnet den Dialog Eingabehilfe , der Sie bei der Auswahl eines an der aktuellen Cursorposition möglichen Programmierelements unterstützt. Aufruf : Menü Bearbeiten , Kontextmenü Voraussetzung : Eine POU ist im Editor geöffnet und der Cursor steht in einer Programmzeile. " }, 
{ "title" : "Dialog: Eingabehilfe - Registerkarte: Kategorien ", 
"url" : "_cds_cmd_input_assistant.html#UUID-6ebae50a-4bd0-b4f9-9ae7-22fbbd5b58ca_id_ac201b561ba225dc0a8640e00215c1f_id_9b1329a161d157c1c0a8640e00c51282", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Eingabehilfe \/ Dialog: Eingabehilfe - Registerkarte: Kategorien ", 
"snippet" : "Der Dialog bietet Ihnen alle Programmierelemente an, die Sie im Editor an der aktuellen Cursorposition einfügen können. Die Elemente sind nach Kategorien sortiert. Sie können in der Kategorie Variablen zusätzlich einen Filter für den Gültigkeitsbereich setzen, wie beispielsweise Lokale Variablen , G...", 
"body" : "Der Dialog bietet Ihnen alle Programmierelemente an, die Sie im Editor an der aktuellen Cursorposition einfügen können. Die Elemente sind nach Kategorien sortiert. Sie können in der Kategorie Variablen zusätzlich einen Filter für den Gültigkeitsbereich setzen, wie beispielsweise Lokale Variablen , Globale Variablen oder Konstanten . Strukturierte Ansicht : Die Elemente werden in einem Strukturbaum dargestellt. Sie können die Spalten Typ , Adresse und Herkunft mit einem Rechtsklick in den Spaltentitel in einem Untermenü aus- oder einblenden. : Die Elemente werden in einer flachen Struktur dargestellt. Dokumentation anzeigen : Der Dialog wird um das Feld Dokumentation erweitert. Mit Argumenten einfügen : Elemente, die Argumente besitzen, wie zum Beispiel Funktionen, werden mit diesen Argumenten an der Cursorposition eingefügt. Beispiel: Wenn Sie den Funktionsbaustein fb1 , der eine Eingabevariable fb1_in und eine Ausgabevariable fb1_out enthält, „mit Argumenten“ einfügen, sieht dies im Editor folgendermaßen aus: fb1(fb1_in:=>, fb1_out=>) . Mit Namensraum-Präfix einfügen : Fügt das ausgewählte Element mit vorangestelltem Namensraum ein Im Fall von Bibliotheksbausteinen können Sie die Checkbox nicht bedienen, wenn in den Eigenschaften der Bibliothek festgelegt ist, dass die Angabe des Namensraums zwingend ist. Wenn Sie Objekte mit dem gleichen Namen und der gleichen Kategorie sowohl global (Ansicht POUs ) als auch einer Applikation zugeordnet (Ansicht Geräte ) anlegen, erscheint nur ein Eintrag in der Eingabehilfe. Die Verwendung folgt nämlich der üblichen Aufrufpriorität (applikationszugeordnet vor global). " }, 
{ "title" : "Dialog: Eingabehilfe - Registerkarte: Textsuche ", 
"url" : "_cds_cmd_input_assistant.html#UUID-6ebae50a-4bd0-b4f9-9ae7-22fbbd5b58ca_id_ac201b561ba225dc0a8640e00215c1f_id_03fff56d17a6622cc0a864633a9aeacf", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Eingabehilfe \/ Dialog: Eingabehilfe - Registerkarte: Textsuche ", 
"snippet" : "In der Registerkarte können Sie nach bestimmten Objekten suchen. Wenn Sie ein oder mehrere Zeichen in das Suchfeld eingeben, listet das Trefferfenster die Namen aller Objekte, deren Name diese Suchzeichenfolge enthält. Mit einem Doppelklick auf das gewünschte Objekt fügen Sie es an der aktuellen Cur...", 
"body" : "In der Registerkarte können Sie nach bestimmten Objekten suchen. Wenn Sie ein oder mehrere Zeichen in das Suchfeld eingeben, listet das Trefferfenster die Namen aller Objekte, deren Name diese Suchzeichenfolge enthält. Mit einem Doppelklick auf das gewünschte Objekt fügen Sie es an der aktuellen Cursorposition im Editor ein. Filter Einschränken der Suche auf eine bestimmte Variablenkategorie Für weitere Informationen siehe: Eingabeunterstützung nutzen" }, 
{ "title" : "Befehl: Gehe zu Quelltextposition ", 
"url" : "_cds_cmd_go_to_source_position.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Gehe zu Quelltextposition ", 
"snippet" : "Gehe zu Quelltextposition Funktion : Mit dem Befehl springen Sie zur Position in Quelltext, die eine Meldung ausgelöst hat. Aufruf : Menü Bearbeiten , Kontextmenü der Meldung im Meldungsfenster Voraussetzung : Es ist eine Meldung im Meldungsfenster selektiert. Um zur Position im Quelltext der nächst...", 
"body" : "Gehe zu Quelltextposition Funktion : Mit dem Befehl springen Sie zur Position in Quelltext, die eine Meldung ausgelöst hat. Aufruf : Menü Bearbeiten , Kontextmenü der Meldung im Meldungsfenster Voraussetzung : Es ist eine Meldung im Meldungsfenster selektiert. Um zur Position im Quelltext der nächsten oder vorherigen Meldung im Meldungsfenster zu gelangen, verwenden Sie die Befehle Nächste Meldung oder Vorherige Meldung . " }, 
{ "title" : "Befehl: Nächste Meldung ", 
"url" : "_cds_cmd_next_message.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Nächste Meldung ", 
"snippet" : "Nächste Meldung Tastaturkürzel: F4 Funktion : Der Befehl selektiert die nächste Meldung im Meldungsfenster. Aufruf : Menü Bearbeiten Wenn die letzte Meldung in der Liste erreicht ist, springt die Markierung zurück an den Anfang....", 
"body" : "Nächste Meldung Tastaturkürzel: F4 Funktion : Der Befehl selektiert die nächste Meldung im Meldungsfenster. Aufruf : Menü Bearbeiten Wenn die letzte Meldung in der Liste erreicht ist, springt die Markierung zurück an den Anfang. " }, 
{ "title" : "Befehl: Vorherige Meldung ", 
"url" : "_cds_cmd_previous_message.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Vorherige Meldung ", 
"snippet" : "Vorherige Meldung Tastaturkürzel: Umschalt + F4 Funktion : Der Befehl selektiert die vorherige Meldung im Meldungsfenster. Aufruf : Menü Bearbeiten Wenn die erste Meldung in der Liste erreicht ist, springt die Markierung zurück an das Ende....", 
"body" : "Vorherige Meldung Tastaturkürzel: Umschalt + F4 Funktion : Der Befehl selektiert die vorherige Meldung im Meldungsfenster. Aufruf : Menü Bearbeiten Wenn die erste Meldung in der Liste erreicht ist, springt die Markierung zurück an das Ende. " }, 
{ "title" : "Befehl: Gehe zur Definition ", 
"url" : "_cds_cmd_goto_definition.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Gehe zur Definition ", 
"snippet" : "Gehe zur Definition Symbol: Funktion : Der Befehl zeigt die Definitionsstelle einer Variablen oder Funktion. Aufruf : Menü Bearbeiten → Symbol suchen Voraussetzung : Eine POU ist im Editor geöffnet und der Cursor steht auf einer Variablen oder Funktion. Für weitere Informationen siehe: Deklaration f...", 
"body" : "Gehe zur Definition Symbol: Funktion : Der Befehl zeigt die Definitionsstelle einer Variablen oder Funktion. Aufruf : Menü Bearbeiten → Symbol suchen Voraussetzung : Eine POU ist im Editor geöffnet und der Cursor steht auf einer Variablen oder Funktion. Für weitere Informationen siehe: Deklaration finden" }, 
{ "title" : "Befehl: Gehe zu Referenz ", 
"url" : "_cds_cmd_goto_reference.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Gehe zu Referenz ", 
"snippet" : "Gehe zu Referenz Symbol: Funktion : Der Befehl öffnet im Onlinebetrieb die Deklarationsstelle der Variablen, die von dem gerade fokussierten Pointer referenziert wird. Aufruf : Kontextmenü im Deklarationsteil oder Implementierungscode Menü Bearbeiten → Symbol suchen Voraussetzung : Onlinebetrieb Ein...", 
"body" : "Gehe zu Referenz Symbol: Funktion : Der Befehl öffnet im Onlinebetrieb die Deklarationsstelle der Variablen, die von dem gerade fokussierten Pointer referenziert wird. Aufruf : Kontextmenü im Deklarationsteil oder Implementierungscode Menü Bearbeiten → Symbol suchen Voraussetzung : Onlinebetrieb Ein Baustein ist im Editor geöffnet und der Cursor steht auf einem Pointer. Die referenzierte Variable liegt in einem statischen Speicher. Wenn der Pointer nicht exakt auf den Beginn der Variablen zeigt, wird beim Wechseln zur Variablendeklaration eine entsprechende Meldung ausgegeben. " }, 
{ "title" : "Befehl: Gehe zu Instanz ", 
"url" : "_cds_cmd_goto_instance.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Gehe zu Instanz ", 
"snippet" : "Gehe zu Instanz Symbol: Funktion : Der Befehl öffnet die Instanz eines Funktionsbausteins in einem neuen Fenster. Aufruf : Menü Bearbeiten → Symbol suchen Voraussetzung : Die Applikation ist im Onlinebetrieb. Eine POU ist im Editor geöffnet und der Cursor steht auf der Instanz eines Funktionsbaustei...", 
"body" : "Gehe zu Instanz Symbol: Funktion : Der Befehl öffnet die Instanz eines Funktionsbausteins in einem neuen Fenster. Aufruf : Menü Bearbeiten → Symbol suchen Voraussetzung : Die Applikation ist im Onlinebetrieb. Eine POU ist im Editor geöffnet und der Cursor steht auf der Instanz eines Funktionsbausteins. Der Befehl ist nicht verfügbar für temporäre Instanzen oder Instanzen aus übersetzten Bibliotheken. Für weitere Informationen siehe: Deklaration finden" }, 
{ "title" : "Befehl: Refactoring: <…> umbenennen ", 
"url" : "_cds_cmd_refactoring_rename.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Refactoring: <…> umbenennen ", 
"snippet" : "Refactoring: <…> umbenennen Funktion : Der Befehl öffnet einen Dialog zum projektweiten Umbenennen eines Objekts oder einer Variablen. Aufruf : Menü Bearbeiten → Refactoring , Kontextmenü Voraussetzung : Ein Objekt im Gerätebaum oder in der Ansicht POUs ist selektiert oder im Deklarationsteil eines ...", 
"body" : "Refactoring: <…> umbenennen Funktion : Der Befehl öffnet einen Dialog zum projektweiten Umbenennen eines Objekts oder einer Variablen. Aufruf : Menü Bearbeiten → Refactoring , Kontextmenü Voraussetzung : Ein Objekt im Gerätebaum oder in der Ansicht POUs ist selektiert oder im Deklarationsteil eines Programmierobjekts ist der Cursor vor oder auf einem Variablenbezeichner positioniert. Folgende können Sie umbenennen: Variablen POUs GVLs Methoden Eigenschaften Geräte Variablen und Einheitenumrechnungen innerhalb des Editors für Einheitenumrechnungen " }, 
{ "title" : "Dialog: Umbenennen ", 
"url" : "_cds_cmd_refactoring_rename.html#UUID-2430b763-4ab5-90f5-a69e-2da0a1ef8661_id_f49c110c42fdcc0a8640e01cee140_id_7c48a1fabf8ddfbec0a8640e0166cc68", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Refactoring: <…> umbenennen \/ Dialog: Umbenennen ", 
"snippet" : "Aktueller Name Name des Objekts oder der Variablen Neuer Name Eingabefeld für einen neuen Namen Wenn der eingegebene Namen bereits existiert, meldet CODESYS dies direkt unter diesem Eingabefeld. OK Aktivierbar, wenn Sie in Neuer Name einen gültigen Namen eingegeben haben Öffnet den Dialog Refactorin...", 
"body" : "Aktueller Name Name des Objekts oder der Variablen Neuer Name Eingabefeld für einen neuen Namen Wenn der eingegebene Namen bereits existiert, meldet CODESYS dies direkt unter diesem Eingabefeld. OK Aktivierbar, wenn Sie in Neuer Name einen gültigen Namen eingegeben haben Öffnet den Dialog Refactoring In beiden Fenstern sind die jeweiligen Objekte und Stellen farblich markiert. " }, 
{ "title" : "Dialog: Refactoring ", 
"url" : "_cds_cmd_refactoring_rename.html#UUID-2430b763-4ab5-90f5-a69e-2da0a1ef8661_id_f49c110c42fdcc0a8640e01cee140_id_f64f5fbfa6beea08c0a8640e01fd503b", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Refactoring: <…> umbenennen \/ Dialog: Refactoring ", 
"snippet" : "Der Dialog zeigt alle Verwendungsstellen innerhalb des Projekts. In beiden Fenstern sind die jeweiligen Objekte und Stellen farblich markiert. Rechtes Fenster Anzeige die jeweiligen Stelle innerhalb eines Objekts, wo Aktueller Name vorkommt Linkes Fenster Navigationsbaum des Projekts mit dem jeweili...", 
"body" : "Der Dialog zeigt alle Verwendungsstellen innerhalb des Projekts. In beiden Fenstern sind die jeweiligen Objekte und Stellen farblich markiert. Rechtes Fenster Anzeige die jeweiligen Stelle innerhalb eines Objekts, wo Aktueller Name vorkommt Linkes Fenster Navigationsbaum des Projekts mit dem jeweiligen Objekt In beiden Fenstern können Sie für jede Verwendungsstelle festlegen, was gemacht werden soll. Dazu stehen Ihnen im Kontextmenü folgende Befehle zur Verfügung: Diese Änderung verwerfen Verwerfen der einzelnen Änderung im rechten Fenster Dieses Objekt annehmen Annehmen aller Änderungen im betroffenen Objekt Dieses Objekt verwerfen Verwerfen aller Änderungen im betroffenen Objekt Das gesamte Projekt annehmen Annehmen aller Änderungen im Projekt Das gesamte Projekt verwerfen Verwerfen aller Änderungen im Projekt CODESYS stellt angenommene Änderungen mit gelbem Hintergrund, verworfene Änderung mit grauem Hintergrund dar. Für weitere Informationen siehe: Refactoring" }, 
{ "title" : "Befehl: Refactoring: Betreffende Anschlüsse aktualisieren ", 
"url" : "_cds_cmd_refactoring_update_referenced_pins.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Refactoring: Betreffende Anschlüsse aktualisieren ", 
"snippet" : "Refactoring: Betreffende Anschlüsse aktualisieren Der Befehl wirkt momentan nur in den Editoren für CFC und FUP\/KOP\/AWL. Er entspricht den Befehlen Anschlüsse zurücksetzen und Parameter aktualisieren . Symbol: Funktion : Der Befehl passt in allen betroffenen Verwendungsstellen des Bausteins die Ansc...", 
"body" : "Refactoring: Betreffende Anschlüsse aktualisieren Der Befehl wirkt momentan nur in den Editoren für CFC und FUP\/KOP\/AWL. Er entspricht den Befehlen Anschlüsse zurücksetzen und Parameter aktualisieren . Symbol: Funktion : Der Befehl passt in allen betroffenen Verwendungsstellen des Bausteins die Anschlüsse an die aktuelle Bausteindeklaration an. Aufruf : Menü Bearbeiten → Refactoring , Kontextmenü Voraussetzung : Der Cursor steht im Namen des Bausteins in der ersten Zeile der Bausteindeklaration oder im Gerätebaum. Für weitere Informationen siehe: Refactoring" }, 
{ "title" : "Befehl: Refactoring: Variable hinzufügen ", 
"url" : "_cds_cmd_refactoring_add_variable.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Refactoring: Variable hinzufügen ", 
"snippet" : "Refactoring: Variable hinzufügen Symbol : Funktion : Der Befehl ermöglicht das Deklarieren einer neuen Variablen in einer POU und die entsprechende automatische Aktualisierung an den Verwendungsstellen der POU. Aufruf : Menü Bearbeiten → Refactoring , Kontextmenü Voraussetzungen : Der Fokus liegt im...", 
"body" : "Refactoring: Variable hinzufügen Symbol : Funktion : Der Befehl ermöglicht das Deklarieren einer neuen Variablen in einer POU und die entsprechende automatische Aktualisierung an den Verwendungsstellen der POU. Aufruf : Menü Bearbeiten → Refactoring , Kontextmenü Voraussetzungen : Der Fokus liegt im Deklarationsteil einer POU. Der Befehl öffnet den Standarddialog zum Deklarieren der Variablen. " }, 
{ "title" : "Dialog: Refactoring ", 
"url" : "_cds_cmd_refactoring_add_variable.html#UUID-581e76a8-35ca-3ac1-f711-53d8a5822085_id_eaa36acdfe35c86c0a8640e01aae2be_id_f770113be1ae9112c0a8640e01d33576", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Refactoring: Variable hinzufügen \/ Dialog: Refactoring ", 
"snippet" : "Nach Schließen des Deklarationsdialogs mit OK erscheint der zweigeteilte Dialog Refactoring . Rechter Dialogteil Deklarationsteil und Implementierung der POU, in deren Deklaration die Variable hinzugefügt wird Farbliche Kennzeichnung der Änderungsstellen: Neu hinzugefügte Deklaration in blauer Schri...", 
"body" : "Nach Schließen des Deklarationsdialogs mit OK erscheint der zweigeteilte Dialog Refactoring . Rechter Dialogteil Deklarationsteil und Implementierung der POU, in deren Deklaration die Variable hinzugefügt wird Farbliche Kennzeichnung der Änderungsstellen: Neu hinzugefügte Deklaration in blauer Schrift und gelb hinterlegt (1) Linker Dialogteil Gerätebaum oder POUs-Baum des Projekts Farbliche Kennzeichnung der Bausteine, in denen die POU verwendet wird: Rote Schrift und gelb hinterlegt (2) Nach Doppelklick auf das POU-Objekt öffnet sich die Detailansicht. Bevor Sie entscheiden welche Änderungen Sie an welchen Stellen übernehmen wollen, wählen Sie die gewünschte Option aus der Auswahlliste (3) rechts oben: Eingänge mit Platzhaltertext hinzufügen Standardplatzhaltertext _REFACTOR_ ; editierbar Der hier definierte Platzhaltertext erscheint an den Verwendungsstellen der neu hinzugefügten Variablen im Implementierungscode. Er dient der Suche nach den betroffenen Stellen. Eingänge mit folgendem Wert hinzufügen Initialisierungswert für die neue Variable Im Kontextmenü der Änderungsstellen, sowohl im linken als auch rechten Teil des Dialogs gibt es Befehle zum Annehmen oder Ablehnen der Änderung(en). Sehen Sie hierzu auch die Beschreibung zu Befehl Refactoring → Umbenennen . Beispiele Baustein fun erhält über Refactoring eine neue Eingangsvariable input3 mit Initialisierungswert 1 . Die Änderung wirkt sich folgendermaßen aus: Vorher: fun(a + b, 3, TRUE);\nfun(input1:= a + b , input2 :=3 , inputx := TRUE); Nachher: fun(a + b, 3, 1, TRUE);\nfun(input1:= a + b , input2 :=3 , _REFACTOR_, inputx := TRUE); Baustein fun erhält über Refactoring eine neue Eingangsvariable input3 mit Platzhaltertext _REFACTOR_ . Vorher: inst(input1 := a + b, input2 := 3, inputx := TRUE);\nfun(a + b, 3, TRUE); Nachher: inst(input1 := a + b, input2 := 3, input3 := _REFACTOR_, inputx := TRUE);\nfun(a + b, 3, _REFACTOR_, TRUE); Für weitere Informationen siehe: Refactoring" }, 
{ "title" : "Befehl: Refactoring: <Variable> entfernen ", 
"url" : "_cds_cmd_refactoring_remove_variable.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Refactoring: <Variable> entfernen ", 
"snippet" : "Refactoring: <Variable> entfernen Symbol: Funktion : Der Befehl entfernt eine Eingangs- oder Ausgangsvariable aus der POU und allen Verwendungsstellen der POU. Aufruf : Menü Bearbeiten → Refactoring , Kontextmenü Voraussetzungen : Der Cursor steht im Bezeichner der zu entfernenden Variablen im Dekla...", 
"body" : "Refactoring: <Variable> entfernen Symbol: Funktion : Der Befehl entfernt eine Eingangs- oder Ausgangsvariable aus der POU und allen Verwendungsstellen der POU. Aufruf : Menü Bearbeiten → Refactoring , Kontextmenü Voraussetzungen : Der Cursor steht im Bezeichner der zu entfernenden Variablen im Deklarationsteil der POU. Der Befehl öffnet zunächst einen Dialog mit den Angaben zur gewünschten Entfernung. Nach dessen Bestätigung erscheint der Dialog Refactoring . Siehe für eine Beschreibung des Dialogs Refactoring die Hilfeseite zu Befehl Bearbeiten → Refactoring → Umbenennen . Wenn Sie die Änderungen in Dialog Refactoring akzeptieren, werden an den Verwendungsstellen der betroffenen POU die entsprechenden Eingangs- oder Ausgangsparameter gelöscht. Im CFC wird nur die Verbindung des entfernten Eingangs oder Ausgangs zum Baustein entfernt. Der Eingang oder Ausgang selbst bleibt im Chart enthalten. Beispiel in ST Sie entfernen in einer POU über „Refactoring“ die Eingangsvariable input4 . An den Verwendungsstellen erfolgt eine automatische Anpassung. Vor der Entfernung: inst(input1 := a + b, input2 := 3, input4 := 1, input5 := TRUE);\nfun(a + b, 3, 1, TRUE); Nach der Entfernung: inst(input1 := a + b, input2 := 3, input5 := TRUE);\nfun(a + b, 3, TRUE); Für weitere Informationen siehe: Refactoring" }, 
{ "title" : "Befehl: Refactoring: Variablen neu ordnen ", 
"url" : "_cds_cmd_refactoring_reorder_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bearbeiten \/ Befehl: Refactoring: Variablen neu ordnen ", 
"snippet" : "Refactoring: Variablen neu ordnen Symbol: Funktion : Der Befehl ermöglicht im Deklarationseditor das Ändern der Reihenfolge der Variablen im gerade fokussierten Gültigkeitsbereich VAR_INPUT , VAR_OUTPUT oder VAR_IN_OUT . Aufruf : Menü Bearbeiten → Refactoring , Kontextmenü des gerade fokussierten Gü...", 
"body" : "Refactoring: Variablen neu ordnen Symbol: Funktion : Der Befehl ermöglicht im Deklarationseditor das Ändern der Reihenfolge der Variablen im gerade fokussierten Gültigkeitsbereich VAR_INPUT , VAR_OUTPUT oder VAR_IN_OUT . Aufruf : Menü Bearbeiten → Refactoring , Kontextmenü des gerade fokussierten Gültigkeitsbereichs im Deklarationseditor Voraussetzung : Der Fokus steht in der Deklaration eines der oben genannten Gültigkeitsbereiche und es ist mehr als 1 Variable darin deklariert. Der Befehl öffnet den Dialog Neu ordnen mit einer Liste aller Deklarationen des gerade fokussierten Gültigkeitsbereichs. Durch Ziehen mit der Maus können Sie eine selektierte Deklaration nach oben oder unten an eine andere Position ziehen. Für weitere Informationen siehe: Refactoring" }, 
{ "title" : "Datei ", 
"url" : "_cds_f_commands_file.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: Neues Projekt ", 
"url" : "_cds_cmd_new_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Neues Projekt ", 
"snippet" : "Neues Projekt Symbol: Tastaturkürzel: Strg + N Funktion : Der Befehl öffnet den Dialog Neues Projekt zum Anlegen einer neuen Projektdatei. Aufruf : Menü Datei...", 
"body" : "Neues Projekt Symbol: Tastaturkürzel: Strg + N Funktion : Der Befehl öffnet den Dialog Neues Projekt zum Anlegen einer neuen Projektdatei. Aufruf : Menü Datei " }, 
{ "title" : "Dialog: Neues Projekt ", 
"url" : "_cds_cmd_new_project.html#UUID-6f88f662-6ca0-6f10-4ff7-01e65ed2eded_id_ad7732caf0c41c1c0a8640e00c145e1_id_1e70c84630a111d6c0a8640e0028ba1d", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Neues Projekt \/ Dialog: Neues Projekt ", 
"snippet" : "Funktion : Auswahl einer Projektkategorie und einer Projektvorlage Aufruf : Befehl Datei → Neues Projekt Je nach gewählter Vorlage erhalten Sie ein Projekt, das automatisch mit einem bestimmten Umfang an Objekten ausgestattet ist. Kategorien Bibliotheken Projekte Vorlagen Kategorie Projekte Leeres P...", 
"body" : "Funktion : Auswahl einer Projektkategorie und einer Projektvorlage Aufruf : Befehl Datei → Neues Projekt Je nach gewählter Vorlage erhalten Sie ein Projekt, das automatisch mit einem bestimmten Umfang an Objekten ausgestattet ist. Kategorien Bibliotheken Projekte Vorlagen Kategorie Projekte Leeres Projekt Enthält nur das Objekt Projekteinstellungen Standardprojekt Enthält einen Basisumfang an Objekten und Bibliotheken Ein Assistent unterstützt das Anlegen des Projekts. Standardprojekt mit Application Composer Enthält einen Basisumfang an Objekten und Bibliotheken für das Arbeiten mit dem Application Composer Ein Assistent unterstützt das Anlegen des Projekts. Kategorie Bibliotheken CODESYS -Container-Bibliothek Bibliothek, die nur weitere Bibliotheken, aber keine eigenen Bausteine enthält CODESYS -Interface-Bibliothek Bibliothek nur für das Definieren der Schnittstelle einer Software-Komponente Enthält somit nur Objekte, die keinen Code erzeugen (Konstanten, Strukturen, Interfaces usw.) Leere Bibliothek Enthält nur das Objekt Projekteinstellungen Externe CODESYS -Bibliothek Zielsystemspezifische Bibliothek Wird als Teil des Laufzeitsystems implementiert (in ANSI C oder C++) Name Name des anzulegenden Projekts Je nach Vorlage erscheint ein Standardname. Der numerische Zusatz stellt die Eindeutigkeit des Namens im Dateisystem sicher. Sie können den Dateinamen unter Berücksichtigung der Dateipfadkonventionen des Betriebssystems abändern. Punkte im Namen sind nicht erlaubt. CODESYS fügt automatisch die der gewählten Vorlage entsprechende Dateierweiterung hinzu. Ort Speicherort für die neue Projektdatei öffnet einen Dialog zum Durchsuchen des Dateisystems. zeigt die Historie früher eingegebener Pfade. OK CODESYS öffnet ein neues Projekt. Auf fehlende Angaben macht ein Fehlersymbol am Eingabefeld aufmerksam. Wenn Sie den Mauszeiger daraufstellen, erhalten Sie über ein Tooltip Hinweise, was zu tun ist. " }, 
{ "title" : "Dialog: Standardprojekt ", 
"url" : "_cds_cmd_new_project.html#UUID-6f88f662-6ca0-6f10-4ff7-01e65ed2eded_id_ad7732caf0c41c1c0a8640e00c145e1_id_2aa85e4f30a111d8c0a8640e01abeee3", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Neues Projekt \/ Dialog: Standardprojekt ", 
"snippet" : "Funktion : Assistent zum Anlegen eines Standardprojekts Aufruf : Befehl Datei → Neues Projekt , im Dialog Neues Projekt Kategorie Projekte und Vorlage Standardprojekt auswählen und OK klicken. Gerät Auswahlliste mit SPS-Geräten Das ausgewählte Gerät wird als Objekt in der Ansicht Geräte unterhalb de...", 
"body" : "Funktion : Assistent zum Anlegen eines Standardprojekts Aufruf : Befehl Datei → Neues Projekt , im Dialog Neues Projekt Kategorie Projekte und Vorlage Standardprojekt auswählen und OK klicken. Gerät Auswahlliste mit SPS-Geräten Das ausgewählte Gerät wird als Objekt in der Ansicht Geräte unterhalb des Wurzelknotens eingefügt. PLC_PRG in Auswahlliste mit den Programmiersprachen Das automatisch eingefügte Programm PLC_PRG wird in der gewählten Sprache angelegt. Für weitere Informationen siehe: Standardprojekt anlegen" }, 
{ "title" : "Befehl: Projekt öffnen ", 
"url" : "_cds_cmd_open_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Projekt öffnen ", 
"snippet" : "Projekt öffnen Symbol: Tastaturkürzel: Strg + O Funktion : Der Befehl öffnet den Standarddialog zum Laden eines Projekts. Sie können das Dateisystem nach einem CODESYS -Projekt durchsuchen und dieses im Entwicklungssystem öffnen. Aufruf : Menü Datei...", 
"body" : "Projekt öffnen Symbol: Tastaturkürzel: Strg + O Funktion : Der Befehl öffnet den Standarddialog zum Laden eines Projekts. Sie können das Dateisystem nach einem CODESYS -Projekt durchsuchen und dieses im Entwicklungssystem öffnen. Aufruf : Menü Datei " }, 
{ "title" : "Dialog: Projekt öffnen ", 
"url" : "_cds_cmd_open_project.html#UUID-8a8b7dbf-6789-e615-a76d-2d52433df19e_id_ec92c4aaf11d53dc0a8640e00e17490_id_f8c83f4b11842681c0a864634a242657", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Projekt öffnen \/ Dialog: Projekt öffnen ", 
"snippet" : "Dateityp Typ des CODESYS -Projekts, das in das Entwicklungssystem geladen wird Alle unterstützten Dateien Filtert nach allen Projekten, die CODESYS laden kann Tipp: Sie können beispielsweise PRO -Projekte, die mit CoDeSys V2.3 erstellt wurden, auswählen. Solche Projekte werden zusätzlich konvertiert...", 
"body" : "Dateityp Typ des CODESYS -Projekts, das in das Entwicklungssystem geladen wird Alle unterstützten Dateien Filtert nach allen Projekten, die CODESYS laden kann Tipp: Sie können beispielsweise PRO -Projekte, die mit CoDeSys V2.3 erstellt wurden, auswählen. Solche Projekte werden zusätzlich konvertiert. Dateiendung project Filtert nach Projekten, die mit CODESYS V3 erstellt wurden Dateiendung projectarchive Filtert nach Projektarchiven, die mit CODESYS V3 erstellt wurden Dateiendung library Filtert nach Bibliotheksprojekten, die mit CODESYS V3 erstellt wurden Öffnen Lädt in CODESYS das von Ihnen ausgewählte Projekt Hinweis: Abhängig vom Stand Ihrer CODESYS -Installation kann es nötig sein, die Installation zu aktualisieren oder zu ergänzen. Wenn dies der Fall ist, dann öffnet sich zunächst ein weiterer Dialog Projektprüfung mit Optionen zur Installationsverwaltung. " }, 
{ "title" : "Dialog: Projektprüfung ", 
"url" : "_cds_cmd_open_project.html#UUID-8a8b7dbf-6789-e615-a76d-2d52433df19e_id_ec92c4aaf11d53dc0a8640e00e17490_id_b8f2d4bb2ffd39eec0a8640e00ffd301", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Projekt öffnen \/ Dialog: Projektprüfung ", 
"snippet" : "Wenn das CODESYS -Projekt, das Sie bearbeiten wollen, nicht geeignet ist, um mit Ihrer aktuellen Installation geladen zu werden, erscheint der Dialog des Assistenten der Projektprüfung. Er weist darauf hin, dass das Projekt mit einer anderen CODESYS -Version gespeichert wurde und bietet Optionen zum...", 
"body" : "Wenn das CODESYS -Projekt, das Sie bearbeiten wollen, nicht geeignet ist, um mit Ihrer aktuellen Installation geladen zu werden, erscheint der Dialog des Assistenten der Projektprüfung. Er weist darauf hin, dass das Projekt mit einer anderen CODESYS -Version gespeichert wurde und bietet Optionen zum weiteren Vorgehen an. Beispiel für eine nicht passende Installation: Das zu öffnende Projekt enthält Objekte der Implementierungssprache UML-Zustandsdiagramm , die Installation enthält aber nicht das Add-on CODESYS UML . Folgende Dialoge des Assistenten werden durchlaufen: Projektprüfung - Überblick Das Projekt wurde mit einer anderen Version <CODESYS Version> gespeichert. Dieses Projekt befindet sich noch in einer Entwicklungsphase. Ich möchte es in dieser Version öffnen und habe nichts dagegen, dass ein anderer Code generiert werden kann. Mit Weiter öffnet sich der Dialog Projektprüfung - Fehlende Add-ons zur Entscheidung, ob vor dem Öffnen in der aktuellen Installation fehlende Add-ons noch ergänzt werden sollen. Dieses Projekt wurde bereits auf einer Maschine\/Anlage eingesetzt. Ich möchte genau denselben Code generieren und benötige daher die Möglichkeit, mich ohne Änderungen anzumelden. Konsequenz: Es wird eine kompatible Version geöffnet oder installiert, falls noch nicht vorhanden. Mit Weiter öffnet sich der Dialog Projektprüfung - Auswahl für das Wechseln auf eine andere Installation. Details Die Schaltfläche ist nur verfügbar, wenn das Projekt mit CODESYS Version 3.5.19.0 oder neuer gespeichert wurde, Öffnet den Dialog Unterschiede . Hier sehen Sie, welche Add-ons beim Speichern des Projekts installiert waren und ob und wie diese in der aktuellen Installation verfügbar sind. Projektprüfung - Fehlende Add-ons Das Projekt enthält Objekte, für die kein passendes Add-on installiert ist Installieren Sie fehlende Add-ons für diese Version und starten Sie neu Mit Weiter erscheint der Dialog Projektprüfung - Add-Ons zur Konfiguration der Installation zusätzlicher Add-ons. Fahren Sie trotzdem fort. Die Objekte können nicht geändert werden. Mit Fertigstellen wird das Projekt in der aktuellen Installation geöffnet. Einschränkungen: Das Projekt öffnet mit Schreibschutz Das Projekt enthält unlesbare, unbekannte Objekte Einloggen auf eine Steuerung ist mit dem Projekt nicht möglich Projektprüfung - Add-ons Erweitert die aktuelle Installation durch die folgenden Add-ons. Die angezeigten fehlenden erforderlichen Add-ons und die explizit ausgewählten optionalen Add-ons werden nach Bestätigen mit Fertigstellen installiert. Dazu wird das CODESYS Development System geschlossen und der Installer gestartet. Erforderliches Add-on , Status Namen, und Versionen und Status der erforderlichen Add-ons Mögliche Status: Fehlt Passt Aktualisieren von <Versionsnummer> zu <Versionsnummer> Optionales Add-on , Status Namen, und Versionen optionaler Add-ons. Dies sind Add-ons, die vom Projekt nicht zwingend gebraucht werden, aber beim Speichern vorhanden waren. Projektprüfung - Auswahl Der Dialog erscheint, wenn auf Projektprüfung - Überblick die Option gewählt wurde, das Projekt zwingend in einer kompatiblen CODESYS -Version zu öffnen. Hier wählen Sie eine andere, projektkompatiblen Installation. Andere Installation verwenden Liste der auf dem Computer gefundenen passenden Installationen. Nach Auswahl einer Installation wird mit Fertigstellen die aktuelle Instanz des CODESYS Development System beendet und das Projekt in der neuen kompatiblen Version geöffnet. Download und Setup einer neuen Installation Mit Weiter erscheint der Dialog Projektprüfung - Add-Ons . Er zeigt die erforderlichen und optionale Add-ons, die in der neu anzulegenden Installation enthalten\/ergänzbar sind. Mit Fertigstellen wird CODESYS Development System beendet und der CODESYS Installer gestartet. Er führt den Download und die neue Installation aus. Für weitere Informationen siehe: V3 und V2.3-Projekt öffnen" }, 
{ "title" : "Befehl: Projekt schließen ", 
"url" : "_cds_cmd_close_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Projekt schließen ", 
"snippet" : "Projekt schließen Funktion : Der Befehl schließt das gerade geöffnete Projekt. CODESYS bleibt geöffnet. Aufruf : Menü Datei ; außerdem implizit beim Öffnen eines neuen\/anderen Projekts, während noch ein Projekt geöffnet ist Wenn das Projekt nicht-gespeicherte Änderungen enthält, erscheint eine Abfra...", 
"body" : "Projekt schließen Funktion : Der Befehl schließt das gerade geöffnete Projekt. CODESYS bleibt geöffnet. Aufruf : Menü Datei ; außerdem implizit beim Öffnen eines neuen\/anderen Projekts, während noch ein Projekt geöffnet ist Wenn das Projekt nicht-gespeicherte Änderungen enthält, erscheint eine Abfrage, ob das Projekt gespeichert werden soll. Wenn Sie das Projekt noch nicht explizit gespeichert haben, erscheint eine Abfrage, ob Sie die Projektdateien löschen wollen. " }, 
{ "title" : "Befehl: Projekt speichern ", 
"url" : "_cds_cmd_save_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Projekt speichern ", 
"snippet" : "Projekt speichern Symbol: Tastaturkürzel: Strg + S Funktion : Der Befehl speichert die Projektdatei. Aufruf : Menü Datei Der Befehl speichert die Projektdatei unter dem aktuellen Projektnamen, der in der Titelleiste des Hauptfensters steht. Falls das Projekt seit dem letzten Speichern geändert wurde...", 
"body" : "Projekt speichern Symbol: Tastaturkürzel: Strg + S Funktion : Der Befehl speichert die Projektdatei. Aufruf : Menü Datei Der Befehl speichert die Projektdatei unter dem aktuellen Projektnamen, der in der Titelleiste des Hauptfensters steht. Falls das Projekt seit dem letzten Speichern geändert wurde, ist der Projektname mit einem Sternchen versehen. Der Befehl ist nicht verfügbar, wenn das Projekt schreibgeschützt ist. Schreibschutz besteht in folgenden Fällen: In den Projektinformationen (Zusammenfassung) ist das Projekt als „Freigegeben“ gekennzeichnet. Beim Öffnen des Projekts wurde im Dialog Projekt öffnen die Option Schreibgeschützt öffnen ausgewählt. Ein Schreibschutz wird durch eine Zeile in der oberen rechten Ecke des Hauptfensters angezeigt. Mit einem Mausklick auf diese Zeile erscheint ein Menü mit Befehlen für die folgenden möglichen Aktionen: Projekt unter einem anderen Dateinamen auf die Platte speichern : Ein Mausklick auf diese Option führt zum „Datei speichern unter“. Schreibschutz-Modus verlassen : Erscheint nur, wenn beim Öffnen des Projekts die Option Schreibgeschützt öffnen gewählt wurde Schreibschutz-Attribut vom Projekt auf der Platte entfernen : Erscheint nur, wenn die Projektdatei zum Zeitpunkt des Öffnens auf der Platte mit der Eigenschaft „Schreibgeschützt“ versehen war Kennzeichnung „Freigegeben“ in den Projektinformationen entfernen : Erscheint nur, wenn dieses Attribut gerade gesetzt ist Sicherungskopie Optional kann eine Sicherungskopie der Projektdatei angelegt werden. Wenn die Option Sicherungskopie erzeugen im Optionen-Dialog Laden und Speichern aktiviert ist, wird das Projekt bei jedem Speichern zusätzlich in eine Datei <projektname.backup> kopiert. Für weitere Informationen siehe: Projekt speichern und Laden und speichern" }, 
{ "title" : "Befehl: Projekt speichern unter ", 
"url" : "_cds_cmd_save_project_as.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Projekt speichern unter ", 
"snippet" : "Projekt speichern unter Der Befehl öffnet den Windows-Standarddialog zum Speichern einer Datei. Das Projekt kann unter dem gewünschten Speicherpfad und Dateityp ablegt werden. Dateityp Die Auswahlliste enthält für normale Projekte wie auch für Bibliotheksprojekte jeweils die Versionen des Entwicklun...", 
"body" : "Projekt speichern unter Der Befehl öffnet den Windows-Standarddialog zum Speichern einer Datei. Das Projekt kann unter dem gewünschten Speicherpfad und Dateityp ablegt werden. Dateityp Die Auswahlliste enthält für normale Projekte wie auch für Bibliotheksprojekte jeweils die Versionen des Entwicklungssystems, für die das Projekt gespeichert werden kann. Wenn das aktuelle Projekt Add-ons enthält, die im ausgewählten Speicherformat (Profil) nicht vorhanden sind, öffnet sich der Dialog Profil erweitern . Projektdateien ( CODESYS V<version>) (*.project) : Das Projekt wird als CODESYS Projektdatei „<projektname>.project “ für die aktuell verwendete oder die ausgewählte Version des Programmiersystems gespeichert. Bibliotheksdateien ( V<version>) (*.library) CODESYS : Das Projekt wird als CODESYS Bibliotheksdatei „<projektname>.library“ für die aktuell verwendete oder die ausgewählte Version des Programmiersystems gespeichert. Wenn das Projekt später in einer älteren Version geöffnet werden soll, ist es sinnvoll genau für dieses Speicherformat zu speichern, da dann sofort über eventuelle Datenverluste informiert wird. Das Speicherformat eines Projekt wird in den Projektinformationen ( Projekt → Projektinformationen , Registerkarte Datei ) angezeigt. Bevor Sie ein Projekt als Bibliothek speichern: Stellen Sie sicher, dass die Regeln für das Erstellen von Bibliotheken eingehalten wurden. Wenn globale Konstanten, die durch die Bibliothek bereitgestellt werden, später in einer Applikation konfiguriert werden können sollen, dann definieren Sie diese in einer Parameterliste. Eine Parameterliste ist ein spezieller Typ einer globalen Variablenliste. Beim Speichern des Projekts wird nicht automatisch eine Überprüfung auf Fehler durchgeführt! Im Unterschied zu CoDeSys V2.3 wird nicht mehr zwischen „externen“ und „Internen“ Bibliotheken unterschieden. Nun kann in den Eigenschaften jedes einzelnen Projektobjekts definiert werden, ob es als „externes“ behandelt werden soll. Überlegen Sie, ob die erzeugte Bibliothek sofort ins System-Bibliotheks-Repository installiert werden soll. Wenn ja, verwenden Sie den Befehl Projekt speichern und ins Bibliotheks-Repository installieren . Wenn Sie das Bibliotheksprojekt gegen spätere Änderungen schützen wollen, setzen Sie das Attribut Freigegeben im Dialog Projektinformation . Dann wird beim nächsten Versuch, das Projekt zu speichern, eine entsprechende Meldung ausgegeben und der Anwender muss auf den Schreibschutz mit bewussten Maßnahmen reagieren. Wenn Sie das Projekt in einer anderen als der aktuell verwendeten Version des Programmiersystems speichern, werden Sie zuvor auf möglichen Datenverlust hingewiesen. " }, 
{ "title" : "Dialog: Profil erweitern ", 
"url" : "_cds_cmd_save_project_as.html#UUID-3a5f4010-3111-46e1-90db-bb8388a40eca_id_fa7eae44c8e9c0a8640e018912b9_id_b152c4d5d9ce2c28c0a864637c36b07f", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Projekt speichern unter \/ Dialog: Profil erweitern ", 
"snippet" : "In diesem Dialog kann das auswählte Profil (Speicherformat) um die Add-ons erweitert werden, die im aktuellen Projekt enthalten sind. Das Profil wird temporär gespeichert und nach dem Speichern oder Exportieren wieder gelöscht. Add To Profile : Das aktuelle Profil wird um das Add-on erweitert, so da...", 
"body" : "In diesem Dialog kann das auswählte Profil (Speicherformat) um die Add-ons erweitert werden, die im aktuellen Projekt enthalten sind. Das Profil wird temporär gespeichert und nach dem Speichern oder Exportieren wieder gelöscht. Add To Profile : Das aktuelle Profil wird um das Add-on erweitert, so dass die Add-on-Daten des aktuellen Projekts ebenfalls abgespeichert werden. AddOn Add-on des aktuellen Projekts, das im ausgewählten Speicherformat nicht enthalten ist Version Im aktuellen Profil angezogene Version des Add-on Wenn mehrere Versionen installiert sind, kann die Version ausgewählt werden. Profil speichern Öffnet den Dialog Profilnamen eingeben In dem Dialog geben Sie den Namen für das neue Profil ein. Das neue Profil wird unter $ProgramData$\/$PRODUCT$\/CustomInformationalProfiles dauerhaft gespeichert. Gespeichertes Profil verwenden Das in Profil speichern dauerhaft gespeicherte Profil wird für das Speichern oder Exportieren des aktuellen Projekts verwendet. Für weitere Informationen siehe: Projekt speichern und Laden und speichern" }, 
{ "title" : "Befehl: Projekt speichern und ins Bibliotheks-Repository installieren ", 
"url" : "_cds_cmd_save_project_and_save_into_library_repository.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Projekt speichern und ins Bibliotheks-Repository installieren ", 
"snippet" : "Projekt speichern und ins Bibliotheks-Repository installieren Funktion : Der Befehl speichert das Projekt als Bibliothek im „System“-Bibliotheks-Repository. Aufruf : Menü Datei Mit dem Befehl speichert CODESYS das Projekt als Bibliothek im „System“-Bibliotheks-Repository. Dies ist eine Erweiterung z...", 
"body" : "Projekt speichern und ins Bibliotheks-Repository installieren Funktion : Der Befehl speichert das Projekt als Bibliothek im „System“-Bibliotheks-Repository. Aufruf : Menü Datei Mit dem Befehl speichert CODESYS das Projekt als Bibliothek im „System“-Bibliotheks-Repository. Dies ist eine Erweiterung zum Speichern eines Projekts als Bibliotheksdatei über den Befehl Projekt speichern unter . Dabei wird die Bibliothek auf dem lokalen System installiert und steht sofort zum Einfügen in einem Projekt bereit. " }, 
{ "title" : "Befehl: Projekt als übersetzte Bibliothek speichern ", 
"url" : "_cds_cmd_save_project_as_compiled_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Projekt als übersetzte Bibliothek speichern ", 
"snippet" : "Projekt als übersetzte Bibliothek speichern Funktion : Der Befehl speichert ein Bibliotheksprojekt in verschlüsseltem Format. Aufruf : Menü Datei Der Befehl öffnet den Standarddialog zum Speichern einer Datei im Dateisystem. Der Dateityp Übersetzte CODESYS Bibliotheken ist bereits voreingestellt. Di...", 
"body" : "Projekt als übersetzte Bibliothek speichern Funktion : Der Befehl speichert ein Bibliotheksprojekt in verschlüsseltem Format. Aufruf : Menü Datei Der Befehl öffnet den Standarddialog zum Speichern einer Datei im Dateisystem. Der Dateityp Übersetzte CODESYS Bibliotheken ist bereits voreingestellt. Die Dateierweiterung ist .compiled-library-v3 oder .compiled-library ( CODESYS < 3.5 SP15 ). In diesem Format ist der Quellcode der Bibliotheksbausteine nicht sichtbar, wenn die Bibliothek in einem Projekt verwendet wird. Wenn in der Ansicht Security-Screen , Registerkarte Benutzer die Option Signieren von übersetzten Bibliotheken erzwingen aktiviert ist, muss ein Bibliotheksprojekt beim Speichern mit einer digitalen zertifikatsbasierten Signatur versehen werden. Wenn ein passendes Zertifikat vorhanden ist, wird es im Security Screen , Registerkarte Benutzer in der Sektion Digitale Signatur bereitgestellt. In den Projektinformationen , Registerkarte Zusammenfassung , ist standardmäßig eine Bibliothekskompatibilität mit einer CODESYS -Version >= 3.5 SP15 eingestellt. In diesem Fall wird die Projektdatei beim Speichern als übersetzte und signierte Bibliothek mit der Dateierweiterung .compiled-library-v3 abgelegt. Wenn Sie im Security-Screen noch kein passendes gültiges Zertifikat für Ihr Benutzerprofil eingetragen haben, erscheint zunächst die Aufforderung, dies zu tun. Danach können Sie den Befehl zum Speichern erneut wählen. In der sonstigen Handhabung verhalten sich übersetzte Bibliotheksdateien genauso wie *.library -Dateien, können also mit den gleichen Schritten installiert und referenziert werden. Die Verwendung übersetzter und mit Zertifikat signierter Bibliotheken ist zu empfehlen. Neben dem Schutz des Quellcodes und der nicht-autorisierten Verwendung einer Bibliothek wird auch weniger Arbeitsspeicher verbraucht, sind also die Ladezeiten kürzer. Wenn Sie über die entsprechenden Hilfsdateien mit Übersetzungen verfügen, können Sie ab CODESYS V 3.5 SP15 die Dokumentation einer Bibliothek folgendermaßen um die Übersetzung in zusätzliche Sprachen erweitern: Legen Sie die für die neuen Sprachen erstellten Dateien __lmd__<language>.aux in ein Verzeichnis <library name>.lmd parallel zum Bibliotheksprojekt <library name>.compiled-library-v3 . Wenn die Dateien korrekt sind, werden sie beim Speichern des Bibliotheksprojekts mit dem Befehl Projekt als übersetzte Bibliothek speichern in die kompilierte Bibliotheksdatei mit aufgenommen. Beispiel: Verzeichnis standard.lmd liegt parallel zur Bibliotheksdatei standard.compiled-library-v3 und enthält die Datei __lmd__fr.aux mit der französischen Übersetzung der Bibliotheksdokumentation. Nach Speichern als übersetzte Bibliothek steht auch die französische Version der Dokumentation im Bibliotheksverwalter zur Verfügung. Für weitere Informationen siehe: Informationen für Bibliotheksentwickler und Projekt speichern und ins Bibliotheks-Repository installieren" }, 
{ "title" : "Befehl: Archiv speichern\/versenden ", 
"url" : "_cds_cmd_save_send_archive.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Archiv speichern\/versenden ", 
"snippet" : "Archiv speichern\/versenden Funktion : Der Befehl öffnet den Dialog Projektarchiv zur Konfiguration des Projektarchivs. Aufruf : Menü Datei → Projektarchiv Eine Archivdatei (*.projectarchive) enthält alle im aktuell geöffneten Projekt enthaltenen und referenzierten Dateien. Sie kann entweder gespeich...", 
"body" : "Archiv speichern\/versenden Funktion : Der Befehl öffnet den Dialog Projektarchiv zur Konfiguration des Projektarchivs. Aufruf : Menü Datei → Projektarchiv Eine Archivdatei (*.projectarchive) enthält alle im aktuell geöffneten Projekt enthaltenen und referenzierten Dateien. Sie kann entweder gespeichert oder als Anhang einer E-Mail verschickt werden. Der Versand per E-Mail ist sehr hilfreich um einem Mitarbeiter alle projektrelevanten Dateien zur Verfügung zu stellen. Die Datei kann mit den Befehl Archiv extrahieren wieder einfach entpackt werden. Die Archivierungsfunktion ist nicht zur Speicherung eines Projekts gedacht, vielmehr zum einfachen Zusammenfassen aller projektrelevanten Dateien. " }, 
{ "title" : "Dialog: Projektarchiv ", 
"url" : "_cds_cmd_save_send_archive.html#UUID-276bb6db-1861-3b1e-cd2f-bfc223682f8d_id_a9a34c3aeeaced8c0a8640e00146045_id_96a5b119635a8e3bc0a8640e005df4c1", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Archiv speichern\/versenden \/ Dialog: Projektarchiv ", 
"snippet" : "Der Dialog zeigt alle Kategorien, die zum Projektarchiv hinzugefügt werden können. Darin können komplette Kategorien oder einzelne Objekte der Kategorien durch Setzen eines Hakens zum Projektarchiv hinzugefügt werden. Einträge, die in der Liste rot dargestellt werden, erfordern Ihre Aufmerksamkeit. ...", 
"body" : "Der Dialog zeigt alle Kategorien, die zum Projektarchiv hinzugefügt werden können. Darin können komplette Kategorien oder einzelne Objekte der Kategorien durch Setzen eines Hakens zum Projektarchiv hinzugefügt werden. Einträge, die in der Liste rot dargestellt werden, erfordern Ihre Aufmerksamkeit. Bewegen Sie den Mauszeiger über diese Bibliothek, um weitere Informationen zu erlangen. \n \n \n \n \n Zusätzliche Dateien \n \n \n Öffnet den Dialog Zusätzliche Dateien \n Darin können durch die Schaltfläche Hinzufügen weitere Dateien zum Archiv hinzugefügt werden. \n \n \n \n Kommentar \n \n \n Öffnet den Dialog ‚Kommentar‘ \n Darin können Kommentare dem Archiv hinzugefügt werden. \n \n \n \n Speichern \n \n \n Erzeugt die Archivdatei und speichert sie \n Speicherort und Archivname werden im Folgedialog festgelegt. \n \n \n \n Senden \n \n \n Erzeugt eine temporäre Archivdatei, die einer leeren E-Mail als Anlage beigefügt wird \n Die erfolgreiche Ausführung dieser Operation setzt eine korrekte Installation des MAPI (Messaging Application Programming Interface) voraus. Ein Fehlschlagen wird durch Ausgabe einer entsprechenden Fehlermeldung dokumentiert. Das temporäre Archiv wird automatisch nach Senden der E-Mail gelöscht. \n \n " }, 
{ "title" : "Befehl: Archiv extrahieren ", 
"url" : "_cds_cmd_extract_archive.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Archiv extrahieren ", 
"snippet" : "Archiv extrahieren Funktion : Der Befehl extrahiert ein Projektarchiv, das mit Hilfe des Befehls Archiv speichern\/versenden angelegt wurde. Zuvor müssen Sie konfigurieren, welche Inhalte des Archivs extrahieren soll und an welche Verzeichnisse im Dateisystem sie kopiert werden sollen. Aufruf : Menü ...", 
"body" : "Archiv extrahieren Funktion : Der Befehl extrahiert ein Projektarchiv, das mit Hilfe des Befehls Archiv speichern\/versenden angelegt wurde. Zuvor müssen Sie konfigurieren, welche Inhalte des Archivs extrahieren soll und an welche Verzeichnisse im Dateisystem sie kopiert werden sollen. Aufruf : Menü Datei → Projektarchiv Ein Archiv trägt standardmäßig die Dateierweiterung .projectarchive . Nach Auswahl des Archivs öffnet der Dialog Projektarchiv extrahieren , in dem Sie das Extrahieren konfigurieren. " }, 
{ "title" : "Dialog: Projektarchiv extrahieren ", 
"url" : "_cds_cmd_extract_archive.html#UUID-0b9634c6-9978-893d-8419-d94a07a18d40_UUID-d609574c-71bc-f347-9967-86de00b02f23", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Archiv extrahieren \/ Dialog: Projektarchiv extrahieren ", 
"snippet" : "Projektarchiv extrahieren Der Dialog zeigt den Inhalt des Projektarchivs. Sie können komplette Kategorien oder einzelne Objekte der Kategorien durch Entfernen des Häkchens von der Extraktion ausnehmen. Wenn im Projektarchiv ein Git-Projekt und Git-Repository-Informationen enthalten sind, achten Sie ...", 
"body" : "Projektarchiv extrahieren Der Dialog zeigt den Inhalt des Projektarchivs. Sie können komplette Kategorien oder einzelne Objekte der Kategorien durch Entfernen des Häkchens von der Extraktion ausnehmen. Wenn im Projektarchiv ein Git-Projekt und Git-Repository-Informationen enthalten sind, achten Sie darauf, dass auch die Repository-Informationen mit entpackt werden. Ansonsten können unerwünschte Effekte auftreten, wenn das entpackte Git-Projekt mit einem Repository verknüpft ist, das den gleichen Namen hat wie ein bereits lokal bestehendes Verzeichnis. Dateipfade In das Verzeichnis extrahieren, in dem das Archiv liegt Das Archiv wird im gleichem Verzeichnis extrahiert. In folgendes Verzeichnis extrahieren Der Archivinhalt wird in den angegebenen Pfad extrahiert. Erweitert Öffnet den Dialog Erweitert , in dem Sie definieren, wohin spezielle und zusätzliche Dateien des Archivs extrahiert werden. Inhalt Objekte Zeigt den Inhalt des Archivs in Objektkategorien strukturiert : Das Objekt wird extrahiert. : Das Objekt wird nicht extrahiert. Kommentar Kommentar, der während des Erstellens des Projektarchivs eingetragen wurde Extrahieren Wenn eine Datei, die extrahiert werden soll, den gleichen Namen trägt wie eine bereits im Zielverzeichnis vorliegende, erscheint ein Warnhinweis mit der Frage, ob die lokale Datei ersetzt werden soll. Die Antwort kann automatisch für alle weiteren Namenskonflikte gültig gemacht werden. Dazu müssen Sie die Option Auf alle Objekte und Dateien anwenden aktivieren. " }, 
{ "title" : "Dialog Erweitert ", 
"url" : "_cds_cmd_extract_archive.html#UUID-0b9634c6-9978-893d-8419-d94a07a18d40_id_e7d1fb8371682c0a8640e01de9372_id_1ab891adf85c11e3ab2595dcbe415eae", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Archiv extrahieren \/ Dialog Erweitert ", 
"snippet" : "Repositorys Geräte installieren in Auswahllisten mit aktuell verfügbaren Repositorys Wählen Sie die Repositorys, in die CODESYS die im Archiv enthaltenen Geräte und Bibliotheken installieren soll. Bibliotheken installieren in Zusätzliche Dateien Standardmäßig sind „zusätzliche Dateien“ mit Nicht ext...", 
"body" : "Repositorys Geräte installieren in Auswahllisten mit aktuell verfügbaren Repositorys Wählen Sie die Repositorys, in die CODESYS die im Archiv enthaltenen Geräte und Bibliotheken installieren soll. Bibliotheken installieren in Zusätzliche Dateien Standardmäßig sind „zusätzliche Dateien“ mit Nicht extrahieren vorkonfiguriert. Sie können dies ändern, indem Sie Einträge in der Tabelle auswählen und eine der folgenden Optionen aktivieren: Extrahieren in Projektverzeichnis Verzeichnis der Projektdatei Extrahieren in Verzeichnis Benutzerdefiniertes Verzeichnis Nicht extrahieren Standardeinstellung " }, 
{ "title" : "Befehl: Quellcode von Steuerung laden ", 
"url" : "_cds_cmd_source_upload.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Quellcode von Steuerung laden ", 
"snippet" : "Quellcode von Steuerung laden Funktion : Der Befehl lädt den Quellcode eines Projektes, der als Projektarchiv auf der Steuerung liegt, aus der Steuerung. Aufruf : Menü Datei Voraussetzung : Der Netzwerkpfad zur Steuerung muss konfiguriert sein. Nachdem Sie den Befehl ausgeführt haben öffnet sich ein...", 
"body" : "Quellcode von Steuerung laden Funktion : Der Befehl lädt den Quellcode eines Projektes, der als Projektarchiv auf der Steuerung liegt, aus der Steuerung. Aufruf : Menü Datei Voraussetzung : Der Netzwerkpfad zur Steuerung muss konfiguriert sein. Nachdem Sie den Befehl ausgeführt haben öffnet sich eine Übersicht mit allen Geräten im Netzwerk. Aus dieser Übersicht wählen Sie die Steuerung aus. Danach öffnet sich der Dialog Projektarchiv extrahieren mit Einstellungen zum Extrahieren. Für weitere Informationen siehe: Laden des Quellcodes auf\/von der SPS" }, 
{ "title" : "Dialog: Projektarchiv extrahieren ", 
"url" : "_cds_cmd_source_upload.html#UUID-0bffdb14-f884-fdff-c7f7-9f985d6beb45_UUID-d609574c-71bc-f347-9967-86de00b02f23", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Quellcode von Steuerung laden \/ Dialog: Projektarchiv extrahieren ", 
"snippet" : "Projektarchiv extrahieren Der Dialog zeigt den Inhalt des Projektarchivs. Sie können komplette Kategorien oder einzelne Objekte der Kategorien durch Entfernen des Häkchens von der Extraktion ausnehmen. Wenn im Projektarchiv ein Git-Projekt und Git-Repository-Informationen enthalten sind, achten Sie ...", 
"body" : "Projektarchiv extrahieren Der Dialog zeigt den Inhalt des Projektarchivs. Sie können komplette Kategorien oder einzelne Objekte der Kategorien durch Entfernen des Häkchens von der Extraktion ausnehmen. Wenn im Projektarchiv ein Git-Projekt und Git-Repository-Informationen enthalten sind, achten Sie darauf, dass auch die Repository-Informationen mit entpackt werden. Ansonsten können unerwünschte Effekte auftreten, wenn das entpackte Git-Projekt mit einem Repository verknüpft ist, das den gleichen Namen hat wie ein bereits lokal bestehendes Verzeichnis. Dateipfade In das Verzeichnis extrahieren, in dem das Archiv liegt Das Archiv wird im gleichem Verzeichnis extrahiert. In folgendes Verzeichnis extrahieren Der Archivinhalt wird in den angegebenen Pfad extrahiert. Erweitert Öffnet den Dialog Erweitert , in dem Sie definieren, wohin spezielle und zusätzliche Dateien des Archivs extrahiert werden. Inhalt Objekte Zeigt den Inhalt des Archivs in Objektkategorien strukturiert : Das Objekt wird extrahiert. : Das Objekt wird nicht extrahiert. Kommentar Kommentar, der während des Erstellens des Projektarchivs eingetragen wurde Extrahieren Wenn eine Datei, die extrahiert werden soll, den gleichen Namen trägt wie eine bereits im Zielverzeichnis vorliegende, erscheint ein Warnhinweis mit der Frage, ob die lokale Datei ersetzt werden soll. Die Antwort kann automatisch für alle weiteren Namenskonflikte gültig gemacht werden. Dazu müssen Sie die Option Auf alle Objekte und Dateien anwenden aktivieren. " }, 
{ "title" : "Befehl: Quellcode auf Steuerung laden ", 
"url" : "_cds_cmd_source_download.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Quellcode auf Steuerung laden ", 
"snippet" : "Quellcode auf Steuerung laden Funktion : Der Befehl lädt den Quellcode eines Projektes als Projektarchiv auf die Steuerung. Aufruf : Menü Datei Voraussetzung : Der Netzwerkpfad zur Steuerung muss konfiguriert sein. Nachdem Sie den Befehl ausgeführt haben öffnet sich eine Übersicht mit allen Geräten ...", 
"body" : "Quellcode auf Steuerung laden Funktion : Der Befehl lädt den Quellcode eines Projektes als Projektarchiv auf die Steuerung. Aufruf : Menü Datei Voraussetzung : Der Netzwerkpfad zur Steuerung muss konfiguriert sein. Nachdem Sie den Befehl ausgeführt haben öffnet sich eine Übersicht mit allen Geräten im Netzwerk. Aus dieser Übersicht wählen Sie die Steuerung aus. Danach wird das Projektarchiv Archiv.prj auf diese Steuerung geladen. Über den Befehl Quellcode von Steuerung laden können Sie dann zu einem späteren Zeitpunkt den vollständigen Quellcode in Ihr CODESYS Entwicklungssystem laden. Wenn Sie bereits mit einer Steuerung verbunden sind (Onlinebetrieb), steht Ihnen für diesen Vorgang auch der Befehl Quellcode auf verbundene Steuerung schreiben zur Verfügung. Für weitere Informationen siehe: Laden des Quellcodes auf\/von der SPS" }, 
{ "title" : "Befehl: Drucken ", 
"url" : "_cds_cmd_print.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Drucken ", 
"snippet" : "Drucken Symbol : Funktion : Der Befehl öffnet den Standard-Dialog von Windows zum Drucken von Dokumenten. Aufruf : Menü Datei...", 
"body" : "Drucken Symbol : Funktion : Der Befehl öffnet den Standard-Dialog von Windows zum Drucken von Dokumenten. Aufruf : Menü Datei " }, 
{ "title" : "Befehl: Druckvorschau ", 
"url" : "_cds_cmd_print_preview.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Druckvorschau ", 
"snippet" : "Druckvorschau Funktion : Der Befehl öffnet eine Vorschau des Drucks für das gerade geöffnete Element. Aufruf : Menü Datei Voraussetzung : Es ist ein Objekt im Editor geöffnet....", 
"body" : "Druckvorschau Funktion : Der Befehl öffnet eine Vorschau des Drucks für das gerade geöffnete Element. Aufruf : Menü Datei Voraussetzung : Es ist ein Objekt im Editor geöffnet. " }, 
{ "title" : "Befehl: Seiteneinstellungen ", 
"url" : "_cds_cmd_page_setup.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Seiteneinstellungen ", 
"snippet" : "Seiteneinstellungen Symbol: Funktion : Der Befehl öffnet den Dialog Seiteneinstellungen zur Konfiguration des Layouts für die Druckversion des Projektinhalts. Aufruf : Menü Datei → Seiteneinstellungen...", 
"body" : "Seiteneinstellungen Symbol: Funktion : Der Befehl öffnet den Dialog Seiteneinstellungen zur Konfiguration des Layouts für die Druckversion des Projektinhalts. Aufruf : Menü Datei → Seiteneinstellungen " }, 
{ "title" : "Befehl: Zuletzt verwendete Projekte ", 
"url" : "_cds_cmd_recent_projects.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Zuletzt verwendete Projekte ", 
"snippet" : "Zuletzt verwendete Projekte Funktion : Der Befehl öffnet die Liste der zuletzt verwendeten Projekte, aus der Sie ein Projekt zum Öffnen auswählen können. Aufruf : Menü Datei...", 
"body" : "Zuletzt verwendete Projekte Funktion : Der Befehl öffnet die Liste der zuletzt verwendeten Projekte, aus der Sie ein Projekt zum Öffnen auswählen können. Aufruf : Menü Datei " }, 
{ "title" : "Befehl: Beenden ", 
"url" : "_cds_cmd_exit.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Datei \/ Befehl: Beenden ", 
"snippet" : "Beenden Tastaturkürzel: Alt + F4 Funktion : Der Befehl beendet das Programmiersystem. Wenn gerade ein Projekt geöffnet ist, das seit dem letzten Speichern verändert wurde, erscheint ein Dialog mit der Abfrage ob das Projekt gespeichert werden soll. Aufruf : Menü Datei...", 
"body" : "Beenden Tastaturkürzel: Alt + F4 Funktion : Der Befehl beendet das Programmiersystem. Wenn gerade ein Projekt geöffnet ist, das seit dem letzten Speichern verändert wurde, erscheint ein Dialog mit der Abfrage ob das Projekt gespeichert werden soll. Aufruf : Menü Datei " }, 
{ "title" : "Ansicht ", 
"url" : "_cds_f_commands_view.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Standardmenü in Ansichten: Geräte, POUs und Module ", 
"url" : "_cds_dropdown_menu_in_standard_views.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Standardmenü in Ansichten: Geräte, POUs und Module ", 
"snippet" : "Die Ansichten Geräte , POUs und Module enthalten in der oberen rechten Ecke jeweils eine Schaltfläche zum Öffnen eines Menüs mit den folgenden Befehlen: In Editor öffnen : Öffnet den in der Ansicht ausgewählten Baustein im entsprechenden Editor Objekt suchen : Öffnet den Dialog Objekt suchen für den...", 
"body" : "Die Ansichten Geräte , POUs und Module enthalten in der oberen rechten Ecke jeweils eine Schaltfläche zum Öffnen eines Menüs mit den folgenden Befehlen: In Editor öffnen : Öffnet den in der Ansicht ausgewählten Baustein im entsprechenden Editor Objekt suchen : Öffnet den Dialog Objekt suchen für den Objektbaum in der Ansicht Wenn Sie beginnen eine Zeichenkette einzugeben, werden immer die aktuellen Suchergebnisse mit Name und Pfad angezeigt. Mit Schaltfläche Öffnen können Sie ein selektiertes Suchergebnis im zugehörigen Editor öffnen. Sortieren nach Typ : Sortiert die Objekte im Fenster nach Typ und alphabetisch Sortieren nach Name : Sortiert die Objekte im Fenster nach Namen und alphabetisch Aufsteigend sortieren : Stellt die oben gewählte Sortierung in aufsteigender Reihenfolge dar Absteigend sortieren : Stellt die oben gewählte Sortierung in absteigender Reihenfolge dar Aktiven Editor verfolgen : CODESYS selektiert das Objekt, das im gerade aktiven Editor geöffnet ist, im Objektbaum der Ansicht. " }, 
{ "title" : "Befehl: Geräte ", 
"url" : "_cds_cmd_devices.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Geräte ", 
"snippet" : "Geräte Symbol: Tastaturkürzel: Alt + 0 Funktion : Der Befehl öffnet die Ansicht Geräte im CODESYS Hauptfenster. Sie enthält den „Gerätebaum“ des Projekts, in dem Sie Ihre Applikationen konfigurieren. Über die Schaltfläche steht das Standardmenü zum Navigieren im Objektbaum der Ansicht bereit. Aufruf...", 
"body" : "Geräte Symbol: Tastaturkürzel: Alt + 0 Funktion : Der Befehl öffnet die Ansicht Geräte im CODESYS Hauptfenster. Sie enthält den „Gerätebaum“ des Projekts, in dem Sie Ihre Applikationen konfigurieren. Über die Schaltfläche steht das Standardmenü zum Navigieren im Objektbaum der Ansicht bereit. Aufruf : Menü Ansicht Für weitere Informationen siehe: Gerätebaum und Geräteeditor" }, 
{ "title" : "Befehl: POUs ", 
"url" : "_cds_cmd_pous.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: POUs ", 
"snippet" : "POUs Symbol: Tastaturkürzel: Alt + 1 Funktion : Der Befehl öffnet die Ansicht POUs im CODESYS Hauptfenster. Hier liegende Bausteine stehen im ganzen Projekt zur Verfügung. Aufruf : Menü Ansicht...", 
"body" : "POUs Symbol: Tastaturkürzel: Alt + 1 Funktion : Der Befehl öffnet die Ansicht POUs im CODESYS Hauptfenster. Hier liegende Bausteine stehen im ganzen Projekt zur Verfügung. Aufruf : Menü Ansicht " }, 
{ "title" : "Befehl: Module ", 
"url" : "_cds_cmd_modules.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Module ", 
"snippet" : "Module Symbol: Funktion : Der Befehl öffnet die Ansicht Module . Darin werden die Module des Application Composer in einer Baumstruktur dargestellt. Aufruf : Menü Ansicht...", 
"body" : "Module Symbol: Funktion : Der Befehl öffnet die Ansicht Module . Darin werden die Module des Application Composer in einer Baumstruktur dargestellt. Aufruf : Menü Ansicht " }, 
{ "title" : "Befehl: Meldungen ", 
"url" : "_cds_cmd_messages.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Meldungen ", 
"snippet" : "Meldungen Symbol: Funktion : Der Befehl öffnet die Ansicht Meldungen . Aufruf : Menü Ansicht...", 
"body" : "Meldungen Symbol: Funktion : Der Befehl öffnet die Ansicht Meldungen . Aufruf : Menü Ansicht " }, 
{ "title" : "Ansicht: Meldungen ", 
"url" : "_cds_cmd_messages.html#UUID-119e042d-47fd-099a-1188-ae75ac690d78_id_af63110db5724c0a8640e01487d4a_id_57525bcedefa7c4cc0a8640e01fa4246", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Meldungen \/ Ansicht: Meldungen ", 
"snippet" : "Meldungskategorie Die Meldungen sind nach Komponente oder Funktionalität kategorisiert und in einem Auswahldialog verfügbar. Filtern Sie die Anzeige der Meldungen durch die Wahl einer Kategorie. Meldungstyp Klicken Sie auf das Symbol des Meldungstyps, um Meldungen ein- oder auszublenden. Neben jedem...", 
"body" : "Meldungskategorie Die Meldungen sind nach Komponente oder Funktionalität kategorisiert und in einem Auswahldialog verfügbar. Filtern Sie die Anzeige der Meldungen durch die Wahl einer Kategorie. Meldungstyp Klicken Sie auf das Symbol des Meldungstyps, um Meldungen ein- oder auszublenden. Neben jedem Symbol zeigt CODESYS die Anzahl der aufgetretenen Meldungen an. : Fehler : Warnung : Information Löscht alle Meldungen in der ausgewählten Meldungskategorie Löscht alle Meldungen in allen Meldungskategorien Beschreibung Meldungstext mit dem verursachenden Objekt und der Position innerhalb des Objekts Doppelklicken Sie auf einen Meldungseintrag in der Tabelle, um zur Quelltextposition zu gelangen. Befehlssymbol Listet bei unaufgelösten Bibliotheken Befehle auf, mit denen der gemeldete Fehler schnell behoben werden kann (Quickfix) Platzhalter '<Bibliothek>' auf neueste Version aktualisieren Dialog 'Platzhalter' des Bibliotheksverwalters öffnen Projekt Name des Projekts, das die Meldung generiert Objekt Objekt, in dem die Meldung generiert wurde Position Position im Code Befehle im Kontextmenü Nächste Meldung Die Quelltextposition der nächsten Meldung wird angezeigt. Vorherige Meldung Die Quelltextposition der vorherigen Meldung wird angezeigt. Gehe zu Quelltextposition Die Quelltextposition der selektierten Meldung wird angezeigt. " }, 
{ "title" : "Befehl: Elementeigenschaften ", 
"url" : "_cds_cmd_element_properties.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Elementeigenschaften ", 
"snippet" : "Elementeigenschaften Symbol: Funktion : Der Befehl öffnet die Ansicht Elementeigenschaften . Aufruf : Menü Ansicht Mit dem Befehl öffnen Sie die Eigenschaftenansicht für das gerade geöffnete Objekt. Diese Ansicht steht Ihnen nur bei wenigen Objekten zur Verfügung, wie beispielsweise Visualisierung u...", 
"body" : "Elementeigenschaften Symbol: Funktion : Der Befehl öffnet die Ansicht Elementeigenschaften . Aufruf : Menü Ansicht Mit dem Befehl öffnen Sie die Eigenschaftenansicht für das gerade geöffnete Objekt. Diese Ansicht steht Ihnen nur bei wenigen Objekten zur Verfügung, wie beispielsweise Visualisierung und POU (AS). Die Eigenschaften werden in einer strukturierten Tabelle angezeigt. Sie ändern die Werte der Eigenschaften durch einen Mausklick in das Wertefeld. Sie können die Ansicht der Eigenschaften filtern oder sortieren. " }, 
{ "title" : "Befehl: Werkzeuge ", 
"url" : "_cds_cmd_tools.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Werkzeuge ", 
"snippet" : "Werkzeuge Symbol: Funktion : Der Befehl öffnet die Ansicht Werkzeuge . Aufruf : Menü Ansicht Mit dem Befehl öffnen Sie die Werkzeuge-Ansicht für das gerade geöffnete Objekt. Diese Ansicht steht Ihnen standardmäßig bei einem grafischen Editor oder einer Visualisierung zur Verfügung. Sie enthält die g...", 
"body" : "Werkzeuge Symbol: Funktion : Der Befehl öffnet die Ansicht Werkzeuge . Aufruf : Menü Ansicht Mit dem Befehl öffnen Sie die Werkzeuge-Ansicht für das gerade geöffnete Objekt. Diese Ansicht steht Ihnen standardmäßig bei einem grafischen Editor oder einer Visualisierung zur Verfügung. Sie enthält die grafischen Programmierelemente, die Sie in den Editor ziehen können. " }, 
{ "title" : "Befehl: Überwachungsliste - Überwachungsliste <n> ", 
"url" : "_cds_cmd_view_watch.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Überwachungsliste - Überwachungsliste <n> ", 
"snippet" : "Überwachungsliste - Überwachungsliste <n> Symbol: Funktion : Der Befehl öffnet die Ansicht Überwachungsliste <n> . Eine Überwachungsliste können Sie mit Variablen aus Ihrem Projekt füllen, um im Onlinebetrieb für diese Variablen innerhalb einer einzigen Ansicht die Werte monitoren, forcen oder schre...", 
"body" : "Überwachungsliste - Überwachungsliste <n> Symbol: Funktion : Der Befehl öffnet die Ansicht Überwachungsliste <n> . Eine Überwachungsliste können Sie mit Variablen aus Ihrem Projekt füllen, um im Onlinebetrieb für diese Variablen innerhalb einer einzigen Ansicht die Werte monitoren, forcen oder schreiben zu können. Der Wert \"n\" kann 1, 2, 3 oder 4 sein, das heißt Sie können bis zu vier Überwachungslisten konfigurieren. Aufruf : Menü Ansicht Für weitere Informationen siehe: Überwachungslisten verwenden" }, 
{ "title" : "Befehl: Überwachungsliste: Alle Forces anzeigen ", 
"url" : "_cds_cmd_view_watch_all_forces.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Überwachungsliste: Alle Forces anzeigen ", 
"snippet" : "Überwachungsliste: Alle Forces anzeigen Symbol: Funktion : Der Befehl öffnet die Ansicht Alle Forces anzeigen , die eine spezielle Form einer Überwachungsliste ist. Aufruf : Menü Ansicht → Überwachungsliste → Alle Forces anzeigen Voraussetzung : Ein Projekt ist im Offline- oder Onlinebetrieb geöffne...", 
"body" : "Überwachungsliste: Alle Forces anzeigen Symbol: Funktion : Der Befehl öffnet die Ansicht Alle Forces anzeigen , die eine spezielle Form einer Überwachungsliste ist. Aufruf : Menü Ansicht → Überwachungsliste → Alle Forces anzeigen Voraussetzung : Ein Projekt ist im Offline- oder Onlinebetrieb geöffnet. Die Ansicht enthält alle derzeit zum Forcen vorbereiteten und alle geforcten Variablen der Applikation in einer Liste. In der Liste sind die Aktionen möglich, die auch in anderen Überwachungslisten möglich sind. Zusätzlich gibt es in der Auswahlliste Force aufheben der Ansicht folgende Befehle: Alle Forces anzeigen Tabellarische Anzeige aller geforcten und für das Forcen vorbereiteten Variablen der Applikation Ausdruck Variablenname Datentyp Datentyp der Variablen Wert Aktueller geforcter Wert der Variablen Vorbereiteter Wert Für das Forcen vorbereiteter Wert Überschriebener Wert am Anfang des Zyklus Bei Eingängen wird der eigentliche Wert bereits vor dem Ausführen des Anwendercodes durch den Forcewert überschrieben. Somit ist dies der geforcte Wert. Bei Ausgängen ist dies der geforcte Wert. Überschriebener Wert am Ende des Zyklus Bei Ausgängen ist dies der Wert, der im Zyklus berechnet wird. Dieser Wert wird jedoch am Ende des Zyklus durch den Forcewert überschrieben. Bei Eingängen ist dies der geforcte Wert. Forcen aufheben und alle ausgewählten Werte beibehalten : Für alle selektierten Einträge der Liste werden die Variablen auf den geforcten Wert gesetzt und das Forcen aufgehoben. Forcen aufheben und alle ausgewählten Werte wiederherstellen : Für alle selektierten Einträge der Liste werden die Variablen auf den Wert zurückgesetzt, den sie vor dem Forcen hatten, und das Forcen wird aufgehoben. Für weitere Informationen siehe: Forcen und Schreiben von Variablen und Überwachungslisten verwenden" }, 
{ "title" : "Befehl: Alle Forces zur Überwachungsliste hinzufügen ", 
"url" : "_cds_cmd_add_all_forces_to_watchlist.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Alle Forces zur Überwachungsliste hinzufügen ", 
"snippet" : "Alle Forces zur Überwachungsliste hinzufügen Funktion : Der Befehl fügt alle aktuell zum Forcen vorbereiteten oder schon geforcten Variablen der aktuellen Applikation zur Überwachungsliste hinzu. Beachten Sie jedoch, dass dies ausschließlich für angedockte Überwachungslisten funktioniert. Aufruf : K...", 
"body" : "Alle Forces zur Überwachungsliste hinzufügen Funktion : Der Befehl fügt alle aktuell zum Forcen vorbereiteten oder schon geforcten Variablen der aktuellen Applikation zur Überwachungsliste hinzu. Beachten Sie jedoch, dass dies ausschließlich für angedockte Überwachungslisten funktioniert. Aufruf : Kontextmenü der Ansicht Überwachungsliste Voraussetzungen : Onlinebetrieb, eine Überwachungsliste ist aktiv. Es gibt eine spezielle Überwachungsliste: Alle Forces betrachten , die stets automatisch alle Variablen zeigt, die zum Forcen vorbereitet wurden oder geforct sind. Sie stellt zusätzlich Kommandos bereit, um das Forcen aufzuheben. Für weitere Informationen siehe: Überwachungsliste: Alle Forces anzeigen" }, 
{ "title" : "Befehl: Lesezeichen ", 
"url" : "_cds_cmd_bookmarks.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Lesezeichen ", 
"snippet" : "Lesezeichen Symbol: Funktion : Der Befehl öffnet die Ansicht Lesezeichen . Aufruf : Menü Ansicht Vorheriges Lesezeichen Springt zum Lesezeichen, das in der Tabelle eine Zeile über der selektierten Zeile angezeigt wird, und öffnet die entsprechende POU im Editor Nächstes Lesezeichen Springt zum Lesez...", 
"body" : "Lesezeichen Symbol: Funktion : Der Befehl öffnet die Ansicht Lesezeichen . Aufruf : Menü Ansicht Vorheriges Lesezeichen Springt zum Lesezeichen, das in der Tabelle eine Zeile über der selektierten Zeile angezeigt wird, und öffnet die entsprechende POU im Editor Nächstes Lesezeichen Springt zum Lesezeichen, das in der Tabelle eine Zeile unter der selektierten Zeile angezeigt wird, und öffnet die entsprechende POU im Editor Löscht das selektierte Lesezeichen aus der Tabelle und in der entsprechenden POU Auflistung der Lesezeichen des Projekts mit den Informationen Lesezeichen , Objekt und Position Sie können Reihenfolge der Lesezeichen per Drag&Drop verändern. Wenn Sie eine Zeile doppelklicken, öffnet CODESYS das entsprechende Objekt im Editor und springt zu diesem Lesezeichen. Lesezeichen Von CODESYS vergebene Bezeichnung der Lesezeichen in nummerierter, aufsteigender Reihenfolge: Lesezeichen_0 , Lesezeichen_2 usw. Wenn das Lesezeichen selektiert ist und Sie in das Feld klicken, wird es edtierbar und Sie können die Bezeichnung des Lesezeichens ändern. Objekt Name und Projektpfad der POU, in der das Lesezeichen gesetzt ist Beispiel: POU_Add [PLC_1: SPS-Logic: Application] Position Position des Lesezeichens innerhalb der POU Beispiel: Zeile3, Spalte 1 (Impl) (Impl) : im Implementierungsteil der POU (Decl) : im Deklarationsteil der POU Für weitere Informationen siehe: Lesezeichen setzen und verwenden" }, 
{ "title" : "Befehl: Haltepunkte ", 
"url" : "_cds_cmd_breakpoints.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Haltepunkte ", 
"snippet" : "Haltepunkte Symbol: Funktion : Der Befehl öffnet die Ansicht Haltepunkte . Aufruf : Menü Ansicht Die Ansicht zeigt Ihnen eine Übersicht aller definierter Haltepunkte einer Applikation. Innerhalb der Ansicht stehen Ihnen alle Befehle für Haltepunkte zur Verfügung. Tabelle der aktuellen Haltepunkte Ap...", 
"body" : "Haltepunkte Symbol: Funktion : Der Befehl öffnet die Ansicht Haltepunkte . Aufruf : Menü Ansicht Die Ansicht zeigt Ihnen eine Übersicht aller definierter Haltepunkte einer Applikation. Innerhalb der Ansicht stehen Ihnen alle Befehle für Haltepunkte zur Verfügung. Tabelle der aktuellen Haltepunkte Applikation Wählen Sie die gewünschte Applikation aus der Liste. POU Name des Bausteins, der den Haltepunkt enthält Position Haltepunkt-Position innerhalb der POU Texteditor: Zeilen- plus Spaltennummer Grafischer Editor: Netzwerk oder Elementnummer „(Impl)“ im Fall von Funktionsbausteinen zeigt an, dass der Haltepunkt in der Implementierung des Funktionsbausteins sitzt, nicht in einer Instanz. Instanzpfad Vollständiger Objektpfad der Haltepunkt-Position Tasks Namen der Tasks, bei deren Ausführung der Haltepunkt wirksam sein soll Wenn keine Einschränkung gilt, steht hier “(alle)“. Bedingung Immer anhalten : Keine zusätzliche Aktivierungsbedingung definiert Der Haltepunkt ist immer aktiv. Boolescher Ausdruck Der Ausdruck muss TRUE liefern, damit der Haltepunkt aktiv ist. Trefferzählbedingung Angabe, wann (in welcher Abhängigkeit von der Trefferanzahl) der Haltepunkt wirksam werden soll Aktuelle Trefferanzahl Angabe, wie oft der Haltepunkt während der Ausführung bis jetzt bereits durchlaufen („getroffen“) wurde Überwachte Werte zuletzt aktualisiert Zeigt den Zeitpunkt der letzten Aktualisierung der überwachten Werte an Werkzeugleiste Neuer Haltepunkt Der Befehl öffnet den Dialog Eigenschaften Haltepunkt . Neuer Datenhaltepunkt Der Befehl öffnet den Dialog Neuer Haltepunkt . Haltepunkt löschen Entfernt den Haltepunkt Nicht mit Deaktivieren zu verwechseln! Haltepunkt aktivieren\/deaktivieren Schaltet den Haltepunkt oder Ausführungspunkt zwischen Status „aktiviert“ und „deaktiviert“ hin und her : Der Haltepunkt ist aktiviert. : Der Haltepunkt ist deaktiviert. : Der Ausführungspunkt ist aktiviert. : Der Ausführungspunkt ist deaktiviert. : Der Datenhaltepunkt ist aktiviert. :Der Datenhaltepunkt ist deaktiviert. : Der Datenausführungspunkt ist aktiviert. : Der Datenausführungspunkt ist deaktiviert. Im Gegensatz zum Haltepunkt löschen bleibt ein deaktivierter Haltepunkt in der Liste erhalten und kann wieder aktiviert werden. Eigenschaften Der Dialog Haltepunkteigenschaften erscheint zur Bearbeitung der Haltepunkt-Parameter. Der Dialog entspricht dem Dialog Neuer Haltepunkt . Im Onlinebetrieb können Sie hier den Haltepunkt zum Ausführungspunkt umwandeln. Gehe zur Quellcodeposition Öffnet die Online-Ansicht des betreffenden Bausteins Der Cursor steht an der Haltepunkt-Position. Alle Haltepunkte löschen Löscht alle Haltepunkte und Ausführungspunkte der Applikation Die Liste wird geleert. Nicht mit Deaktivieren zu verwechseln! Alle Haltepunkte aktivieren Aktiviert alle gerade deaktivierten Haltepunkte und Ausführungspunkte Alle Haltepunkte deaktivieren Deaktiviert alle gerade aktivierten Haltepunkte und Ausführungspunkte Die Punkte bleiben in der Liste und können wieder aktiviert werden. Für weitere Informationen siehe: Verwenden von Haltepunkten" }, 
{ "title" : "Befehl: Querverweisliste ", 
"url" : "_cds_cmd_view_cross_reference_list.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Querverweisliste ", 
"snippet" : "Querverweisliste Symbol: Funktion : Der Befehl öffnet die Ansicht Querverweisliste . Aufruf : Menü Ansicht , oder Bearbeiten → Symbol suchen → Querverweise ausgeben Die Ansicht zeigt eine Liste der Querverweise im Projekt für ein Symbol. Das Symbol kann eine Variable, eine POU (Programm, Funktionsba...", 
"body" : "Querverweisliste Symbol: Funktion : Der Befehl öffnet die Ansicht Querverweisliste . Aufruf : Menü Ansicht , oder Bearbeiten → Symbol suchen → Querverweise ausgeben Die Ansicht zeigt eine Liste der Querverweise im Projekt für ein Symbol. Das Symbol kann eine Variable, eine POU (Programm, Funktionsbaustein, Funktion) oder einen anwenderspezifischen Datentyp (DUT) sein. Dabei bietet die Querverweisliste grundsätzlich zwei Sucharten: Textsuche: Durch die Eingabe eines Symbolnamens werden die Querverweise aller Symbole im Projekt mit diesem Namen angezeigt. Falls mehrere Symbole mit gleichem Namen gefunden werden, kann die Anzeige über das Kontextmenü auf einzelne Deklarationen eingeschränkt werden. Deklarationssuche: Das Symbol kann über die Eingabehilfe oder durch die Eingabe eines qualifizierten Pfads (beispielsweise Device.Application.PLC_PRG.i oder __POOL.POU.a ) ausgewählt werden. Danach werden nur die Verwendungsstellen dieses Symbols angezeigt, auch wenn noch andere Symbole mit dem gleichen Namen existieren. Eingabefeld Symbolname (Variablenname, Bausteinname, DUT-Name) - Eingabemöglichkeiten: Auswahl eines deklarierten Symbols über die Eingabehilfe über die Schaltfläche Händisches Eingeben des Symbolnamens Auslösen der Suche über die Schaltfläche oder die Eingabe Sie können für die Textsuche die Platzhalter „ * “ (beliebig viele Zeichen) oder „ ? “ (genau ein beliebiges Zeichen) in Kombination mit einer Teilzeichenkette eines Variablenbezeichners verwenden. Verwenden Sie „ % “, wenn Sie nach IEC-Adressen suchen wollen. Beispiele: „ %MW8 “, „ %M* “ Verwenden des Befehls Symbol suchen → Querverweise ausgeben , wenn der Name eines deklarierten Symbols in einem Editor selektiert ist oder der Cursor im Namen steht. Eine Suche ist auch möglich, wenn das Objekt im Gerätebaum oder POU-Pool selektiert ist. Automatisch, wenn der Name eines deklarierten Symbols in einem Editor selektiert ist oder der Cursor im Namen steht Eine automatische Suche ist auch möglich, wenn das Objekt im Gerätebaum oder POU-Pool selektiert ist. Voraussetzung: CODESYS -Option Querverweise automatisch bei Selektionsänderung aktualisieren ist aktiviert; Kategorie Intelligentes Kodieren . Folgende Eingaben sind gültig: Variablenname, einfach oder qualifiziert Beispiele: „ iVar „, „ PLC_PRG.iVar „ Bausteinname Beispiele: „ PLC_PRG „, „ myFB „ DUT-Name Beispiel: „ mySTRUCT „ Zeichenfolgen in Kombination mit Platzhalter „*“ (beliebige Zeichen) oder „?“ (genau ein beliebiges Zeichen) Beispiel: „ iVar *“ betrifft iVar1 , iVar_glob2 , iVar45 usw. „ iVar? “ betrifft iVar1 , iVar2 , iVarX usw., nicht aber iVar_glob2 , iVar45 usw. „ %<IEC-Adresse> „: CODESYS sucht nach Variablen, die dieser Adresse zugewiesen sind, und direkte Speicherzugriffe. Beispiel: „ %QB0 „, %Q0 := 2 Eingabehilfe öffnen zur Auswahl eines Symbols Suche durchführen Spalten definieren, in denen nach der Zeichenfolge gesucht wird Eingabefeld Zeichenfolge, nach der in den angewählten Spalten gesucht wird Die Fundstellen werden gelb markiert. Querverweise ohne diese Zeichenfolge werden ausgeblendet. Quellposition des vorherigen Querverweises anzeigen , Umschalt + F4 Quellposition des nächsten Querverweises anzeigen , F4 Ergebnisse auf aktuelle Deklaration beschränken Verfügbar, wenn für ein Symbol mehrere Deklarationen gefunden wurden Begrenzt die Anzeige auf die Deklaration, die Sie gerade in der Liste selektiert haben Quellposition des selektierten Querverweises anzeigen Der Fokus springt zur Verwendungsstelle des Symbols. Querverweisliste drucken Der Standarddialog zum Einrichten eines Druckauftrags erscheint. Die gefundenen Querverweise werden mit folgenden Informationen dargestellt: Symbol Die Fundstellen für die Symbole (Variablen, POUs, DUTs) werden nach ihrer Deklaration gruppiert. Die Deklarationsstelle bildet den Wurzelknoten, darunter eingerückt erscheinen die Verwendungsstellen im Projekt. Dabei wird genau der Ausdruck angezeigt, den das Symbol an der Verwendungsstelle hat. Beispiel: Gibt es im Projekt eine globale Variable i und in einem Baustein eine lokal deklarierte Variable i , dann erscheinen nach einer Textsuche nach den Querverweisen zwei Wurzelknoten-Einträge in der Liste und darunter jeweils die Verwendungsstellen der Variable i . Baustein Bausteinname, DUT-Name; auch beispielsweise Taskname im Falle eines Bausteinaufrufs in der Taskkonfiguration Variable Reiner Variablenname Beispiel: iVar Zugriff Art des Zugriffs auf die Variable an der Verwendungsstelle: Deklaration \/ Lesen \/ Schreiben \/ Aufruf Sonderfall für Pointer Eine Zuweisung der Art p := ADR(var1) wird bei Suche nach var1 als Schreiben | Adresse angezeigt. Grund: Eventuelle Schreibzugriffe auf p werden bei Suche nach var1 nicht angezeigt. Über die Pointervariable sind auch Schreibzugriffe möglich. Typ Datentyp der Variablen Adresse IEC-Adresse, falls der Variablen zugewiesen Beispiel: „ AT %QB0 „ Position Position der Verwendungsstelle innerhalb des Editors der betroffenen POU, beispielsweise Zeilennummer, Netzwerknummer, Deklarationsteil oder Implementierungsteil Beispiel: „ Zeile 1, Spalte 1 (Impl) „ Objekt POU-Name + in eckigen Klammern der komplette Pfad der Verwendungsstelle, falls sich diese in der Ansicht Geräte befindet Beispiel: „ PLC_PRG [Device:Plc Logic:Application] „ Kommentar Kommentar, falls in der Deklaration der Variable vorhanden Die Suche liefert alle Fundstellen im Projekt sowie in eingehängten, nicht kompilierten Bibliotheken. " }, 
{ "title" : "Befehle im Kontextmenü der Querverweisliste ", 
"url" : "_cds_cmd_view_cross_reference_list.html#UUID-623fb12f-e68b-767c-3d16-234d22da3a6e_id_aecb6e1644a20ddec0a8640e0091d2ef_id_9e849137def5910dc0a8640e00806466", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Querverweisliste \/ Befehle im Kontextmenü der Querverweisliste ", 
"snippet" : "Quellposition anzeigen : Öffnet den betroffenen Baustein und markiert die Verwendungsstelle: Für Root-Einträge die Deklaration, für darunter liegende Kindeinträge die jeweilige Verwendungsstelle. Alternativ können Sie auf eine Zeile doppelklicken. Ergebnisse auf ausgewählte Deklaration beschränken :...", 
"body" : "Quellposition anzeigen : Öffnet den betroffenen Baustein und markiert die Verwendungsstelle: Für Root-Einträge die Deklaration, für darunter liegende Kindeinträge die jeweilige Verwendungsstelle. Alternativ können Sie auf eine Zeile doppelklicken. Ergebnisse auf ausgewählte Deklaration beschränken : Grenzt im Fall von mehreren gefundenen Deklarationen die Anzeige der Ergebnisse auf die ausgewählte Symboldeklaration ein Alles erweitern : In der Liste erscheinen alle einzelnen Fundstellen. Alles reduzieren : In der Liste erscheinen nur die Wurzelknoten aller Fundstellen. Für weitere Informationen siehe: Verwendungsstellen mit der Querverweisliste finden" }, 
{ "title" : "Befehl: Querverweise in der klassischen Ansicht ausgeben ", 
"url" : "_cds_cmd_browse_cross_references_classic_view.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Querverweise in der klassischen Ansicht ausgeben ", 
"snippet" : "Querverweise in der klassischen Ansicht ausgeben Symbol: Funktion : Der Befehl öffnet die Ansicht Klassische Querverweisliste . Aufruf : Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn mit Hilfe des Dialogs Tools → Anpassen aus der Befehlskategorie Quelltextnavigation in ein Me...", 
"body" : "Querverweise in der klassischen Ansicht ausgeben Symbol: Funktion : Der Befehl öffnet die Ansicht Klassische Querverweisliste . Aufruf : Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn mit Hilfe des Dialogs Tools → Anpassen aus der Befehlskategorie Quelltextnavigation in ein Menü einfügen. Die Ansicht entspricht der Ansicht Querverweisliste vor CODESYS V3.5 SP6. " }, 
{ "title" : "Befehl: Aufrufliste ", 
"url" : "_cds_cmd_call_stack.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Aufrufliste ", 
"snippet" : "Aufrufliste Symbol: Funktion : Der Befehl öffnet die Ansicht Aufrufliste . Aufruf : Menü Ansicht Diese Ansicht ist sehr nützlich, wenn Sie Programme schrittweise ausführen wollen. Sie zeigt die aktuell erreichte Position mit vollständigem Aufrufpfad. Applikation Name der aktiven Applikation, die den...", 
"body" : "Aufrufliste Symbol: Funktion : Der Befehl öffnet die Ansicht Aufrufliste . Aufruf : Menü Ansicht Diese Ansicht ist sehr nützlich, wenn Sie Programme schrittweise ausführen wollen. Sie zeigt die aktuell erreichte Position mit vollständigem Aufrufpfad. Applikation Name der aktiven Applikation, die den gerade erreichten Programmbaustein kontrolliert Task Name der Task, die den gerade erreichten Programmbaustein kontrolliert POU Name des Programmbausteins, in dem die Programmausführung steht Die erste Zeile in der Liste beschreibt die aktuelle Ausführungsposition. Sie ist mit einem gelben Pfeil markiert. Wenn diese Position in einem Baustein liegt, der von einem anderen aufgerufen wird, wird die Position des Aufrufs in der zweiten Zeile beschrieben. Wenn der Aufrufer wiederum von einem anderen Baustein aufgerufen wird, wird diese Aufrufposition in der dritten Zeile beschrieben, usw. Position Position innerhalb des Programmbausteins, an der die Programmausführung steht Zeilen- und Spaltennummer bei Texteditoren Netzwerk- oder Elementnummer bei grafischen Editoren Instanzpfad Instanz, in der die Programmausführung steht Die Aufrufliste ist auch im Offlinebetrieb verfügbar und im normalen Onlinebetrieb, wenn Sie gerade keine Debugging-Funktionen benützen. In diesem Fall enthält sie die zuletzt während einer schrittweisen Ausführung angezeigte Position, allerdings in „gegrauter“ Schrift. Die Ansicht Aufrufbaum liefert im Unterschied zur Aufrufliste jederzeit Aufrufinformationen zu einem Baustein. Für weitere Informationen siehe: Aufrufbaum und Verwenden von Haltepunkten" }, 
{ "title" : "Befehl: Aufrufbaum ", 
"url" : "_cds_cmd_view_call_tree.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Aufrufbaum ", 
"snippet" : "Aufrufbaum Symbol: Funktion : Der Befehl öffnet die Ansicht Aufrufbaum . Aufruf : Menü Ansicht Kontextmenü eines aufrufbaren Bausteins in der Ansicht Geräte oder POUs...", 
"body" : "Aufrufbaum Symbol: Funktion : Der Befehl öffnet die Ansicht Aufrufbaum . Aufruf : Menü Ansicht Kontextmenü eines aufrufbaren Bausteins in der Ansicht Geräte oder POUs " }, 
{ "title" : "Ansicht: Aufrufbaum ", 
"url" : "_cds_cmd_view_call_tree.html#UUID-8ef23822-0953-bda0-f712-59bcfbcff6c2_id_e97c4a78798cce68c0a8646329524733_id_1d4c07637a2363d1c0a86463011a235d", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Aufrufbaum \/ Ansicht: Aufrufbaum ", 
"snippet" : "Der Aufrufbaum steht jederzeit bereits vor dem Kompilieren (Übersetzen) der Applikation zur Verfügung. Er ist eine statische Darstellung der Aufrufer und der Aufrufe des Bausteins, den Sie explizit angeben. Somit enthält der Baum immer 2 Wurzelknoten, unter denen die jeweilige Aufrufabfolge als nach...", 
"body" : "Der Aufrufbaum steht jederzeit bereits vor dem Kompilieren (Übersetzen) der Applikation zur Verfügung. Er ist eine statische Darstellung der Aufrufer und der Aufrufe des Bausteins, den Sie explizit angeben. Somit enthält der Baum immer 2 Wurzelknoten, unter denen die jeweilige Aufrufabfolge als nacheinander eingerückte Einträge zu sehen ist. Rekursive Aufrufe sind in dieser Baumdarstellung schnell erkennbar. Beispiel für einen Aufrufbaum (1) für Baustein (2) PLC_PRG : Knoten (3): <Bausteinname> wird aufgerufen von Knoten (4): <Bausteinname> ruft auf Bausteinname Name des Programmbausteins Kann händisch, oder durch Ziehen aus einer anderen Ansicht, oder mit Hilfe der Schaltfläche eingegeben werden Die Auswahlliste enthält die zuletzt eingegebenen Bausteinnamen. Symbolleiste und Tastaturbedienung : Baustein finden CODESYS sucht nach dem in Bausteinname angegebenen Baustein und stellt seine Aufrufer und seine Aufrufe dar. : Baustein aus Eingabehilfe entnehmen Der Dialog Eingabehilfe erscheint zur Auswahl eines Bausteinaufrufs oder Instanzaufrufs. Der Aufrufbaum wird nach der Auswahl automatisch aktualisiert. : Quellcodeposition des selektierten Bausteins anzeigen CODESYS springt zur Verwendungsstelle des Bausteins im Quellcode Ihres Programms. F4 : Quellcodeposition des nächsten Bausteins anzeigen Umschalt + F4 : Quellcodeposition des vorherigen Bausteins anzeigen Die Selektion im Aufrufbaum springt zum nächsten oder vorherigen Baustein in der Aufrufstruktur. Gleichzeitig wird die dazugehörige Quellcodeposition im jeweiligen Editor geöffnet. Hinweis: Ein Doppelklick auf einen Eintrag im Aufrufbaum öffnet ebenfalls die zugehörige Quellcodeposition. Darstellung des Aufrufbaums Symbol <Bausteinname> wird aufgerufen von : Unter diesem Knoten erscheint die Aufrufabfolge für den Baustein. Der unterste Eintrag in dieser Baumstruktur zeigt den Start der Aufrufe. <Bausteinname> ruft auf : Unter diesem Knoten erscheinen die von dem Baustein ausgehenden Aufrufe. Der unterste Eintrag in dieser Baumstruktur zeigt das Ende der Aufrufkette. Position Für die Wurzelknoten im Aufrufbaum: Zeilennummer der Deklaration ( Dekl ) des Bausteins Für die Aufrufer oder Aufrufe unter den Wurzelknoten: Je nach Implementierungssprache Zeilennummer, Spaltennummer, Netzwerknummer ihrer Position Kontextmenü für den gerade im Baum selektierten Eintrag Alles reduzieren Die ausgeklappten Einträge im Aufrufbaum werden bis auf die beiden Wurzelknoten zugeklappt. Quellcodeposition anzeigen CODESYS springt zur Verwendungsstelle des Bausteins im Quellcode Ihres Programms. Als neuen Wurzelknoten setzen Der im Aufrufbaum selektierte Eintrag erscheint in Bausteinname . Der Baum wird automatisch für die neuen Wurzelknoten angepasst. Im Unterschied zum statischen Aufrufbaum , der jederzeit Aufrufinformationen zu einem Baustein liefert, ist die Ansicht Aufrufliste für unmittelbare Information während der schrittweisen Abarbeitung eines Programms vorgesehen. Die Aufrufliste zeigt immer den kompletten Aufrufpfad der gerade erreichten Position. Für weitere Informationen siehe: Aufrufliste" }, 
{ "title" : "Befehl: Speicheransicht ", 
"url" : "_cds_cmd_memory.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Speicheransicht ", 
"snippet" : "Speicheransicht Symbol: Funktion : In CODESYS V3.5 Versionen älter als SP11 öffnet der Befehl die Ansicht Speicher . Aufruf : Menü Ansicht Ab SP11 erscheint auf den Befehl hin der Hinweis, dass Sie für die Verwendung der Speicheransicht das Package CODESYS Memory Tools installieren müssen, verfügbar...", 
"body" : "Speicheransicht Symbol: Funktion : In CODESYS V3.5 Versionen älter als SP11 öffnet der Befehl die Ansicht Speicher . Aufruf : Menü Ansicht Ab SP11 erscheint auf den Befehl hin der Hinweis, dass Sie für die Verwendung der Speicheransicht das Package CODESYS Memory Tools installieren müssen, verfügbar im CODESYS Store. Nach der Installation können Sie die Ansicht Speicher über den Befehl Ansicht → Speicheransicht öffnen. " }, 
{ "title" : "Befehl: Security-Screen ", 
"url" : "_cds_cmd_cyber_screen.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Security-Screen ", 
"snippet" : "Security-Screen Symbol: Funktion : Der Befehl öffnet die Ansicht Security-Screen . Aufruf : Menü Ansicht Icon oder in der Statusleiste Das Icon ist blau dargestellt, wenn ein gültiges Zertifikat für die digitale Signatur angegeben ist. Wenn nur ein Client-Zertifikat für die verschlüsselte Kommunikat...", 
"body" : "Security-Screen Symbol: Funktion : Der Befehl öffnet die Ansicht Security-Screen . Aufruf : Menü Ansicht Icon oder in der Statusleiste Das Icon ist blau dargestellt, wenn ein gültiges Zertifikat für die digitale Signatur angegeben ist. Wenn nur ein Client-Zertifikat für die verschlüsselte Kommunikation angeben ist, bleibt das Icon grau, das sich durch das Client-Zertifikat keine erhöhte Security für den Benutzer ergibt. In der Ansicht werden folgende Security-Features von CODESYS konfiguriert und angezeigt: Persönliche Zertifikate des Benutzers Verschlüsselte Kommunikation Verschlüsselung und Signierung des IEC-Projekts Verschlüsselung und Signierung von Download, Online-Change und Bootapplikation Security-Level Wenn der Seurity-Screen geöffnet und wieder geschlossen wird, werden die aktuellen Einstellungen in die Benutzeroptionen übernommen, auch wenn keine aktiven Änderungen vorgenommen wurden. Wenn das Zusatzprodukt CODESYS Security Agent installiert ist, bietet die Ansicht Security-Screen eine weitere Registerkarte: Geräte . Sie ermöglicht das Konfigurieren von Zertifikaten für die verschlüsselte Kommunikation mit Steuerungen. Registerkarte: Geräte Diese Registerkarte ist nur verfügbar, wenn Sie das Add-on CODESYS Security Agent installiert haben. Für weitere Informationen siehe: Security-Screen: Geräte in der CODESYS Security Agent -Hilfe. " }, 
{ "title" : "Registerkarte: Benutzer ", 
"url" : "_cds_cmd_cyber_screen.html#UUID-b01565e9-8d26-9511-6f6b-c6ddb491ec4a_id_f1b6b5ab8b9c634c0a8646304f94292_id_6b26b715c2e29ee4c0a86463458183bc", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Security-Screen \/ Registerkarte: Benutzer ", 
"snippet" : "In dieser Registerkarte werden die Zertifikate konfiguriert, die für die verschlüsselte Kommunikation und die digitale Signatur des Benutzers erforderlich sind. Hier können Sie nur Zertifikate mit privatem Schlüssel angeben. Das Benutzerprofil wird in den Benutzeroptionen als XML gespeichert. Benutz...", 
"body" : "In dieser Registerkarte werden die Zertifikate konfiguriert, die für die verschlüsselte Kommunikation und die digitale Signatur des Benutzers erforderlich sind. Hier können Sie nur Zertifikate mit privatem Schlüssel angeben. Das Benutzerprofil wird in den Benutzeroptionen als XML gespeichert. Benutzerprofil und Zertifikatsauswahl Als Benutzerprofil ist standardmäßig der Anmeldename von Windows eingetragen. Auswahlliste mit bestehenenden Benutzerprofilen : Öffnet den Dialog Benutzerprofile Hier geben Sie den Namen für eine neues Benutzerprofil ein. : Löscht das ausgewählte Benutzerprofil Dieses Benutzerprofil wird dann in der Auswahlliste nicht mehr angezeigt. Digitale Signatur : Öffnet den Dialog Zertifikatsauswahl für die Auswahl des Zertifikats für die digitale Signatur 1 Zertifikat kann ausgewählt werden. Das Zertifikat muss mit privatem Schlüssel sein. : Löscht das angezeigte Zertifikat. 1 Zertifikat kann ausgewählt werden. Das Zertifikat muss mit privatem Schlüssel sein. Projektdateientschlüsselung : Öffnet den Dialog Zertifikatsauswahl für die Auswahl des Zertifikats für die Entschlüsselung von Projektdateien 1 Zertifikat kann ausgewählt werden. Das Zertifikat muss mit privatem Schlüssel sein. : Löscht das angezeigte Zertifikat Für weitere Informationen siehe: ZertifikatsauswahlSecurity-Level Gebrauch von Zertifikaten für erweiterte Security aktivieren Verschlüsselte Kommunikation erzwingen : Wenn der Benutzer mit der Steuerung kommuniziert, wird das Server-Zertifikat der Steuerung für den verschlüsselten Verbindungsaufbau genutzt. Die gesamte Kommunikation erfolgt dann verschlüsselt. Verschlüsselung von Projektdateien erzwingen : Alle Projektdateien des Benutzers werden mit einem Zertifikat verschlüsselt. Das Projekt wird beim Speichern mit dem in den Projekteinstellungen (Dialog Projekteinstellungen → Sicherheit ) angegebenen Zertifikat verschlüsselt. Das ausgewählte Zertifikat wird in der Registerkarte Projekt in Projektdateiverschlüsselung angezeigt. Zum Öffnen dieses Projekts muss das zur Verschlüsselung verwendete Zertifikat mit privatem Schlüssel in Projektdateientschlüsselung eingetragen sein. Signieren von Projektdateien erzwingen : Alle Projektdateien des Benutzers werden mit einem Zertifikat signiert. In Digitale Signatur muss ein Zertifikat mit einem privaten Schlüssel eingetragen sein. Wenn ein Projekt gespeichert wird, wird im Projektverzeichnis ein Signaturdatei <project name>.project.p7s erzeugt, die die Signatur enthält. Verschlüsselung von Downloads, Online-Changes und Bootapplikationen erzwingen : Die Daten, die auf die Steuerung geladen werden, müssen mit einem Steuerungszertifikat verschlüsselt werden. Dieses Zertifikat wird direkt im Eigenschaften-Dialog der Applikation, Registerkarte Verschlüsselung festgelegt oder in der Registerkarte Projekt , Bereich Verschlüsselung von Bootapplikation, Download und Online-Change . Steuerungszertifikate liegen im lokalen Windows Certificate Store im Ordner PLC Certificates . Wenn die Zertifikate Ihrer Steuerung in dem Ordner nicht enthalten sind, müssen Sie zuerst von der Steuerung geladen und in den Ordner installiert werden. Eine Anleitung hierzu finden Sie im Kapitel „ Controller Certificates „ Für weitere Informationen siehe: Applikation schützenSignieren von Downloads, Online-Changes und Bootapplikationen erzwingen : Der Onlinecode, das heißt Downloads, Online-Changes und Bootapplikationen müssen mit einem Zertifikat mit persönlichem Schlüssel signiert sein. Das Zertifikat wählen Sie im Bereich Digitale Signatur aus. Für weitere Informationen siehe: Applikation schützenSignieren von übersetzten Bibliotheken erzwingen : Der Befehl Datei → Projekt als übersetzte Bibliothek speichern erzeugt eine signierte Bibliothek <library name>.compiled-library-v3 . Voraussetzungen Ein Zertifikat mit privatem Schlüssel, das Codesignierung unterstützt, ist vorhanden. In den Projektinformationen ist eine Bibliothekskompatibilität >= CODESYS V3 SP15 eingestellt. Zeitstempelvergabe für signierte Bibliotheken erzwingen : Im Feld Zeitstempel-Server muss die URL des Zeitstempel-Servers, der den Zeitstempel erzeugt, eingetragen sein. Beispiel: timestamp.comodoca.com\/rfc3161 Für weitere Informationen siehe: Projekt als übersetzte Bibliothek speichern" }, 
{ "title" : "Registerkarte: Projekt ", 
"url" : "_cds_cmd_cyber_screen.html#UUID-b01565e9-8d26-9511-6f6b-c6ddb491ec4a_id_f1b6b5ab8b9c634c0a8646304f94292_id_eb95a26f13bac6bec0a864635014e693", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Security-Screen \/ Registerkarte: Projekt ", 
"snippet" : "In dieser Registerkarte werden alle projektspezifischen Einstellungen konfiguriert. Diese Elemente sind nur aktiv, wenn ein primäres Projekt geladen ist. Projektdateiverschlüsselung Technologie : Öffnet den Dialog Projekteinstellungen → Sicherheit Wenn Sie in dem Dialog die Projekteinstellung Versch...", 
"body" : "In dieser Registerkarte werden alle projektspezifischen Einstellungen konfiguriert. Diese Elemente sind nur aktiv, wenn ein primäres Projekt geladen ist. Projektdateiverschlüsselung Technologie : Öffnet den Dialog Projekteinstellungen → Sicherheit Wenn Sie in dem Dialog die Projekteinstellung Verschlüsselung wählen und anschließend Zertifikate aktivieren, können Sie über ein entsprechendes Zertifikat auswählen. Weitere Details finden Sie bei der Beschreibung des Dialogs Projekteinstellungen - Sicherheit . Zertifikate von Anwendern, die dieses Projekt teilen Bereich für die Auflistung der Zertifikate, die die Projektdatei verschlüsseln Verschlüsselung von Bootapplikation, Download und Online-Change Auflistung der Applikationen der Steuerung Ein Doppelklick auf eine Applikation der Liste öffnet den Dialog Eigenschaften → Security . Abhängig von den Einstellungen des Security Level auf Registerkarte Benutzer des Security-Screen sind im geöffneten Eigenschaftendialog folgende Felder verfügbar: Registerkarte Verschlüsselung mit aktivem Bereich Zertifikate Registerkarte Verschlüsselung mit Auswahlliste Verschlüsselungstechnik In dem Dialog Eigenschaften → Verschlüsselung wählen Sie über die Schaltfläche das Steuerungszertifikat zur Verschlüsselung von Bootapplikation, Download und Online-Change aus. Weitere Details finden Sie bei der Beschreibung des Dialogs Eigenschaften - Verschlüsselung . Steuerungszertifikate liegen im lokalen Windows Certificate Store im Ordner Controller Certificates . Wenn die Zertifikate Ihrer Steuerung in dem Ordner nicht enthalten sind, müssen Sie zuerst von der Steuerung geladen und in den Ordner installiert werden. Eine Anleitung hierzu finden Sie im Kapitel Projekt schützen und speichern - Verschlüsselung mit Zertifikaten . Für wetiere Informationen siehe: Applikation schützenFür weitere Informationen siehe: Sichere Entwicklung \/ Quellcode schützen " }, 
{ "title" : "Befehl: Einstellungen Speicherreserve für Online-Change ", 
"url" : "_cds_cmd_memory_reserve_online_change.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Einstellungen Speicherreserve für Online-Change ", 
"snippet" : "Einstellungen Speicherreserve für Online-Change Funktion : Der Befehl öffnet die Ansicht Speicherreserve für Online-Change . Aufruf : Menü Ansicht In der Ansicht werden für Funktionsbausteine Speicherreserven für den Online-Change konfiguriert. Applikation durchsuchen Durchsucht die ausgewählte Appl...", 
"body" : "Einstellungen Speicherreserve für Online-Change Funktion : Der Befehl öffnet die Ansicht Speicherreserve für Online-Change . Aufruf : Menü Ansicht In der Ansicht werden für Funktionsbausteine Speicherreserven für den Online-Change konfiguriert. Applikation durchsuchen Durchsucht die ausgewählte Applikation nach Funktionsbausteinen und zeigt sie im Bereich Funktionsbausteine an Aktualisiert den Bereich Funktionsbausteine , nachdem die Applikation erneut übersetzt wurde Aktualisiert den Bereich Funktionsbausteine nach einem Online-Change Auswahlliste mit den Applikationen des geöffneten Projekts Auswahl der Applikation, deren Funktionsbausteine in dieser Ansicht angezeigt und\/oder bearbeitet werden sollen Funktionsbausteine Alle Alle Funktionsbausteine der ausgewählten Applikation werden angezeigt. Pool Alle Funktionsbausteine der Ansicht POUs , die in der Applikation referenziert werden, werden angezeigt. Keine Speicherreserve Alle Funktionsbausteine mit Speicherreserve 0 Bytes werden angezeigt. <Speicherreserve> Bytes Anzeige aller Funktionsbausteine mit der Anzahl Bytes, die in Speicherreserve definiert ist, wird angezeigt Informationen zu den Funktionsbausteinen Bei der Selektion eines Bausteins für die Konfiguration der Speicherreserve ist auch eine Mehrfachauswahl möglich. Funktionsbaustein Name des Funktionsbausteins Größe Größe des Funktionsbausteins Größe einer Instanz des Funktionsbausteins Angabe in Bytes Instanzanzahl Anzahl der Instanzen des Funktionsbausteins im Projekt Speicherreserve Anzeige der Speicherreserve pro Instanz des Funktionsbausteins Zusätzlicher Speicher für alle Instanzen Produkt aus Instanzanzahl und Speicherreserve Verbleibende der Speicherreserve Anzahl Bytes, die noch als Reserve zur Verfügung stehen Einstellungen Speicherreserve (in Bytes) Eingabefeld für die Speicherreserve für den selektierten Funktionsbaustein Angabe in Bytes Voraussetzung: Die Applikation befindet sich noch nicht auf der Steuerung oder Sie haben durch eine Klick auf die Schaltfläche Bearbeiten im Bereich Bearbeitung erlauben die Änderung der Speicherreserve erlaubt. Für Auswahl anwenden Die Speicherreserve (in Bytes) wird dem Funktionsbaustein zugeordnet und die Tabellenspalte Speicherreserve wird aktualisiert. Bei Mehrfachauswahl wird der eingegebene Wert jedem Funktionsbaustein zugeordnet. Um die Spalten Größe , Instanzanzahl , Zusätzlicher Speicher für alle Instanzen und Verbleibende Größe der Speicherreserve zu aktualisieren, wählen Sie zunächst den Befehl Erstellen → Übersetzen und klicken Sie anschließend auf die Schaltfläche Applikation durchsuchen . Bearbeitung erlauben Bearbeiten Das Eingabefeld Speicherreserve (in Bytes) wird editierbar. Diese Schaltfläche wird in Bearbeitbar geändert. Information Anzahl FBs Gesamtanzahl der Funktionsbausteine in der Applikation Zusatzspeicher für alle Instanzen Summe der Speicherreserven aller Funktionsbaustein-Instanzen der Applikation Angabe in Bytes Für weitere Informationen siehe: Speicherreserve für Online-Change konfigurieren" }, 
{ "title" : "Befehl: Startseite ", 
"url" : "_cds_cmd_start_page.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Startseite ", 
"snippet" : "Startseite Symbol: Funktion : Der Befehl öffnet die Ansicht Startseite . Aufruf : Menü Ansicht Die Ansicht enthält einige Basisbefehle und eine Liste der zuletzt geöffneten Projekte. Weiterhin wird Ihnen die CODESYS Homepage angezeigt. Wenn Sie einen Proxy-Zugang zum Internet verwenden, können Sie d...", 
"body" : "Startseite Symbol: Funktion : Der Befehl öffnet die Ansicht Startseite . Aufruf : Menü Ansicht Die Ansicht enthält einige Basisbefehle und eine Liste der zuletzt geöffneten Projekte. Weiterhin wird Ihnen die CODESYS Homepage angezeigt. Wenn Sie einen Proxy-Zugang zum Internet verwenden, können Sie die Authentifizierungsdaten in den CODESYS Optionen in Kategorie Proxy-Einstellungen hinterlegen. Dann werden Sie nicht bei jedem Aufruf der Homepage zur Eingabe aufgefordert. Durch Bewegen des Mauszeigers über die Liste der zuletzt geöffneten Projekte können Sie einzelne Projekte aus der Liste entfernen oder pinnen. Gepinnte Projekte bleiben so lange in dieser Liste, bis Sie den Pin wieder entfernen. Sie können in den CODESYS Optionen in Kategorie Laden und Speichern konfigurieren, ob diese Startseite automatisch erscheinen soll, wenn Sie CODESYS starten. " }, 
{ "title" : "Befehl: Ganzer Bildschirm ", 
"url" : "_cds_cmd_full_screen.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Ganzer Bildschirm ", 
"snippet" : "Ganzer Bildschirm Symbol: Tastaturkürzel: Strg + Umschalt + F12 Funktion : Der Befehl schaltet die Anzeige von CODESYS in den Vollbild-Modus. Aufruf : Menü Ansicht Wenn Sie den Befehl aktivieren, wird das Hauptfenster der CODESYS Benutzeroberfläche im Vollbildmodus angezeigt. Sie können zur vorher e...", 
"body" : "Ganzer Bildschirm Symbol: Tastaturkürzel: Strg + Umschalt + F12 Funktion : Der Befehl schaltet die Anzeige von CODESYS in den Vollbild-Modus. Aufruf : Menü Ansicht Wenn Sie den Befehl aktivieren, wird das Hauptfenster der CODESYS Benutzeroberfläche im Vollbildmodus angezeigt. Sie können zur vorher eingestellten Größe zurückkehren, wenn Sie den Befehl wieder deaktivieren oder das Tastaturkürzel Strg + Umschalt + F12 betätigen. " }, 
{ "title" : "Befehl: Eigenschaften ", 
"url" : "_cds_cmd_properties.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Ansicht \/ Befehl: Eigenschaften ", 
"snippet" : "Eigenschaften Symbol: Funktion : Der Befehl öffnet die Eigenschaften des gerade selektierten Objekts im POUs- oder Gerätebaum. Aufruf : Menü Ansicht...", 
"body" : "Eigenschaften Symbol: Funktion : Der Befehl öffnet die Eigenschaften des gerade selektierten Objekts im POUs- oder Gerätebaum. Aufruf : Menü Ansicht " }, 
{ "title" : "Projekt ", 
"url" : "_cds_f_commands_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: Objekt hinzufügen ", 
"url" : "_cds_cmd_add_object.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Objekt hinzufügen ", 
"snippet" : "Objekt hinzufügen Symbol: Funktion : Der Befehl öffnet ein Untermenü mit Objekten, das abhängig von der aktuellen Position in der Ansicht Geräte oder POUs alle Objekte enthält, die eingefügt werden können. Aufruf : Menü Projekt , Kontextmenü in der Ansicht Geräte oder POUs Voraussetzung : Wenn CODES...", 
"body" : "Objekt hinzufügen Symbol: Funktion : Der Befehl öffnet ein Untermenü mit Objekten, das abhängig von der aktuellen Position in der Ansicht Geräte oder POUs alle Objekte enthält, die eingefügt werden können. Aufruf : Menü Projekt , Kontextmenü in der Ansicht Geräte oder POUs Voraussetzung : Wenn CODESYS das Objekt im Gerätebaum einfügen soll, selektieren Sie ein bereits vorhandenes Objekt, unterhalb dessen das neue eingerückt angelegt werden kann. Wenn CODESYS das Objekt im POUs-Baum einfügen soll, setzen Sie den Fokus an einer beliebigen freien Stelle im CODESYS Fenster. Für weitere Informationen siehe: Objekte hinzufügen" }, 
{ "title" : "Befehl: Ordner hinzufügen ", 
"url" : "_cds_cmd_add_folder.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Ordner hinzufügen ", 
"snippet" : "Ordner hinzufügen Symbol: Funktion : Der Befehl öffnet einen Dialog zum Definieren eines neuen Ordners in der Ansicht Geräte oder POUs. Aufruf : Menü Projekt , Kontextmenü in der Ansicht Geräte oder POUs Die Anordnung der Geräteknoten und Geräteobjekte können Sie nicht durch selbst angelegte Ordner ...", 
"body" : "Ordner hinzufügen Symbol: Funktion : Der Befehl öffnet einen Dialog zum Definieren eines neuen Ordners in der Ansicht Geräte oder POUs. Aufruf : Menü Projekt , Kontextmenü in der Ansicht Geräte oder POUs Die Anordnung der Geräteknoten und Geräteobjekte können Sie nicht durch selbst angelegte Ordner strukturieren. Der Befehl fügt den Ordner unterhalb des gerade selektierten Objekts im Baum ein. Wenn kein Objekt selektiert ist, fügt CODESYS den Ordner ganz oben im Baum direkt unter dem Wurzelknoten ein. " }, 
{ "title" : "Befehl: Gerät anhängen ", 
"url" : "_cds_cmd_add_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Gerät anhängen ", 
"snippet" : "Gerät anhängen Funktion : Der Befehl öffnet den Dialog Gerät anhängen zur Auswahl eines Geräteobjekts, das im Gerätebaum unterhalb des gerade selektierten Objekts eingefügt werden soll. Aufruf : Kontextmenü eines Geräteobjekts im Gerätebaum Voraussetzung : Im Gerätebaum ist ein Objekt selektiert, un...", 
"body" : "Gerät anhängen Funktion : Der Befehl öffnet den Dialog Gerät anhängen zur Auswahl eines Geräteobjekts, das im Gerätebaum unterhalb des gerade selektierten Objekts eingefügt werden soll. Aufruf : Kontextmenü eines Geräteobjekts im Gerätebaum Voraussetzung : Im Gerätebaum ist ein Objekt selektiert, unterhalb dessen ein Geräteobjekt eingefügt werden kann. " }, 
{ "title" : "Dialog: Gerät anhängen ", 
"url" : "_cds_cmd_add_device.html#UUID-eb0bed63-ea86-053f-3973-94136b2ff14c_id_bd4a3d10fecdecc0a8640e002b80ee_id_b68e4f085aa0f27fc0a8640e01039101", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Gerät anhängen \/ Dialog: Gerät anhängen ", 
"snippet" : "Funktion : Der Dialog bietet abhängig von der gerade selektierten Position im Gerätebaum eine Auswahl der an dieser Stelle einfügbaren Geräte. Er enthält zudem die auch im Kontextmenü verfügbaren Befehle: Gerät anhängen , Gerät einfügen , Gerät einstecken , Gerät aktualisieren . Voraussetzung : Die ...", 
"body" : "Funktion : Der Dialog bietet abhängig von der gerade selektierten Position im Gerätebaum eine Auswahl der an dieser Stelle einfügbaren Geräte. Er enthält zudem die auch im Kontextmenü verfügbaren Befehle: Gerät anhängen , Gerät einfügen , Gerät einstecken , Gerät aktualisieren . Voraussetzung : Die Geräte sind im Geräte-Repository auf dem lokalen System installiert. Wenn Sie den Dialog geöffnet haben, zeigt er immer die zum gerade im Gerätebaum selektierten Objekt passende Auswahl, bis Sie auf die Schaltfläche Schließen klicken. Name Name, mit dem das Gerät im Gerätebaum erscheinen soll Muss ein gültiger IEC-Bezeichner sein Aktion Gerät anhängen CODESYS fügt das ausgewählte Gerät eingerückt unterhalb des selektierten Objekts im Gerätebaum ein. Gerät einfügen CODESYS fügt das ausgewählte Gerät auf gleicher Ebene wie das selektierte Objekt unterhalb von diesem im Gerätebaum ein. Gerät einstecken CODESYS fügt das ausgewählte Gerät im selektierten Steckplatz (Slot) ein. Wenn der Steckplatz bereits belegt ist, wird das vorhandene Modul durch das neue ersetzt. Gerät aktualisieren CODESYS ersetzt das im Gerätebaum selektierte Gerät durch das ausgewählte. Beachten Sie: Abhängig vom Gerät kann dadurch die bereits vorgenommene Konfiguration im Geräteeditor mit den Standardwerten überschrieben werden! Zeichenfolge für die Volltextsuche in allen Geräten Durch einen Klick in dieses Feld wird es editierbar. Wenn Sie eine beliebige Zeichenkette eingeben, werden im unteren Fenster nur die Geräte angezeigt, die die Zeichenkette beinhalten. Die übereinstimmende Zeichenkette ist bei diesen Geräten gelb markiert. Hersteller Auswahlliste mit Herstellern, deren verfügbare Geräte angezeigt werden Nach Kategorie gruppieren : Die verfügbaren Geräte (neueste Version) sind nach Kategorien sortiert. Die Kategorie ist in der Gerätebeschreibungsdatei definiert. : Die verfügbaren Geräte erscheinen flach und alphabetisch sortiert. Alle Versionen anzeigen (nur für Experten) : Zusätzlich stehen auch alle anderen verfügbaren Versionen der Geräte zur Auswahl. : Nur die neueste Version jedes Geräts steht zur Auswahl. Veraltete Versionen anzeigen : Zusätzlich stehen auch veraltete Versionen der Geräte zur Auswahl. Veraltet Versionen entstehen beispielsweise durch die Aktualisierung von Plug-Ins. : Veraltete Geräteversionen werden nicht angezeigt. Die über die Gerätebeschreibungsdatei bereitgestellte Information wird angezeigt: Gerätename, Hersteller, Kategorien, Version, Bestellnummer und eine kurze Beschreibung, gerätespezifisches Bitmap. Für weitere Informationen siehe: Gerät einfügen und Gerät einstecken" }, 
{ "title" : "Befehl: Gerät einstecken ", 
"url" : "_cds_cmd_plug_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Gerät einstecken ", 
"snippet" : "Gerät einstecken Funktion : Der Befehl öffnet wie beim Befehl Gerät anhängen den Dialog Gerät anhängen zur Auswahl eines Geräteobjekts, das im Gerätebaum am gerade selektierten Steckplatz eingefügt werden soll. Aufruf : Kontextmenü des Steckplatzes eines Geräteobjekts im Gerätebaum Voraussetzung : I...", 
"body" : "Gerät einstecken Funktion : Der Befehl öffnet wie beim Befehl Gerät anhängen den Dialog Gerät anhängen zur Auswahl eines Geräteobjekts, das im Gerätebaum am gerade selektierten Steckplatz eingefügt werden soll. Aufruf : Kontextmenü des Steckplatzes eines Geräteobjekts im Gerätebaum Voraussetzung : Im Gerätebaum ist der Steckplatz eines Geräteobjekts selektiert. Ein leerer Steckplatz ist durch das Symbol und den Eintrag „<Leer> (<Leer>)“ gekennzeichnet . Ein belegter Steckplatz erhält das Symbol und den Namen des Geräts. Im Falle eines belegten Steckplatzes wird mit dem Befehl das vorhandene Modul durch das neue ersetzt. " }, 
{ "title" : "Befehl: Geräte suchen ", 
"url" : "_cds_cmd_scan_for_devices.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Geräte suchen ", 
"snippet" : "Geräte suchen Funktion : Der Befehl stellt eine kurzzeitige Verbindung zur Hardware her und ermittelt die Geräte im Netzwerk. Die gefundenen Geräte können Sie dann in den Gerätebaum Ihres Projekts übernehmen. Aufruf : Menü Projekt , Kontextmenü eines Geräteobjekts im Gerätebaum Voraussetzung : Die K...", 
"body" : "Geräte suchen Funktion : Der Befehl stellt eine kurzzeitige Verbindung zur Hardware her und ermittelt die Geräte im Netzwerk. Die gefundenen Geräte können Sie dann in den Gerätebaum Ihres Projekts übernehmen. Aufruf : Menü Projekt , Kontextmenü eines Geräteobjekts im Gerätebaum Voraussetzung : Die Kommunikationseinstellungen zum Steuerungsgerät sind korrekt. Das Gateway und die SPS sind gestartet. Das Gerät unterstützt die Scan-Funktionalität. Folgende Geräte stellen die Scan-Funktion zur Verfügung: EtherCAT Master, EtherNet\/IP Scanner (IEC), Sercos Master, CANopen Manager, CANopen Manager SIL2, Profinet Controller und Profibus DP Master. Sie können den Geräte-Scan sofort durchführen, wenn die Scan-Funktionalität fest in der SPS implementiert ist. Wenn die Scan-Funktionalität in einer Bibliothek implementiert ist, müssen Sie sich einmalig einloggen, um die Bibliothek auf die Steuerung zu laden. Der Befehl bezieht sich auf die im Gerätebaum selektierte Master-Steuerung. Beispielsweise kann ein bereits eingefügter PROFINET IO-Controller ausgewählt werden und mit dem Befehl die ihm zugeordneten E\/A-Geräte und E\/A-Module ermittelt werden. Nach dem Ausführen des Scans erscheint der Dialog Geräte suchen mit den gefundenen Geräte. Die Dialoge für den Scan unterscheiden sich je nach Gerätetyp. Sehen Sie dazu bitte die Hilfeseiten zum jeweiligen Geräteeditor. Gefundene Geräte Gerätename, Gerätetyp, Adresse, Stationsname etc. Daten zum gefundenen Gerät, abhängig vom Netzwerktyp Wenn Sie einen Wert in der Liste der gefundenen Geräte ändern, wird der Wert kursiv dargestellt. Das zeigt an, dass der neue Wert im Editor in CODESYS geändert ist, jedoch noch nicht im Gerät. Sobald Sie den Wert ins Gerät geladen haben, wird er wieder normal dargestellt. Werte, die Unterschiede zwischen Projekt und gefundenen Geräte zeigen, erscheinen orange. Wenn mehrere Gerätebeschreibungen für das gefundene Gerät vorhanden sind, so wird der Name in Fettschrift dargestellt. Die Auswahl der passenden Gerätebeschreibung ist für die verschiedenen Feldbusse unterschiedlich gelöst. Details hierzu finden Sie im entsprechenden Feldbuskapitel. Wenn keine Gerätebeschreibung gefunden wurde, so erscheint die Meldung „Attention! The device was not found in the repository“. Abhängig vom Bussystem werden zusätzliche Informationen wie zum Beispiel Herstellernummer und Produktnummer angezeigt. Ohne die installierte Gerätebeschreibung kann das Gerät nicht in das Projekt eingefügt werden. Unterschiede zum Projekt anzeigen : Die Tabelle zeigt in dem Dialog zusätzlich die konfigurierten Geräte (Geräte im Gerätebaum des Projekts) an. : Die Tabelle zeigt alle gefundenen Geräte. Die konfigurierten Geräte werden nicht angezeigt. Geräte suchen Startet einen erneuten Suchlauf Ins Projekt kopieren Das in der Tabelle selektierte Gerät wird in den Gerätebaum im Projekt eingefügt. Wenn nichts selektiert ist, werden alle gefundenen Geräte übernommen. Wenn Sie mit Alle Geräte ins Projekt kopieren Geräte in den Gerätebaum einfügen, die im Gerätebaum bereits vorhanden sind, ist Folgendes zu beachten: Die Daten der Registerkarten Prozessdaten und <…> E\/A-Abbild der bereits vorhandenen Geräte können mit den Daten der neu eingefügten Geräte überschrieben werden. Konfigurierte Geräte Dieser Teil des Dialogs ist nur sichtbar, wenn Sie die Option Unterschiede zum Projekt anzeigen aktiviert haben. Unterschiede zwischen den gefundenen und konfigurierten Geräten werden farblich markiert. Grün dargestellte Geräte sind auf beiden Seiten identisch. Rot dargestellte Geräte sind nur in der Ansicht der gefundenen oder konfigurierten Geräte vorhanden. Wenn Sie in beiden Ansichten ein Gerät selektiert haben, wird das gefundene Geräte oberhalb des selektierten konfigurierten Geräts eingefügt. Wenn Sie in beiden Ansichten ein Gerät selektiert haben, wird das gefundene Geräte unterhalb des selektierten konfigurierten Geräts eingefügt. Wenn Sie in beiden Ansichten ein Gerät selektiert haben, wird das konfigurierte Geräte durch das gefundene Gerät ersetzt. Alle gefundenen Geräte werden in das Projekt kopiert. Das selektierte konfigurierte Gerät wird gelöscht. Für weitere Informationen siehe: Hardwarestruktur im Gerätebaum abbilden" }, 
{ "title" : "Befehl: Gerät aktualisieren ", 
"url" : "_cds_cmd_update_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Gerät aktualisieren ", 
"snippet" : "Gerät aktualisieren Funktion : Der Befehl öffnet wie beim Befehl Gerät anhängen den Dialog Gerät anhängen zur Auswahl eines Geräteobjekts. Dieses Objekt wird im Gerätebaum an Stelle des gerade selektierten Objekts eingefügt. Aufruf : Kontextmenü eines Geräteobjekts im Gerätebaum Voraussetzung : Im G...", 
"body" : "Gerät aktualisieren Funktion : Der Befehl öffnet wie beim Befehl Gerät anhängen den Dialog Gerät anhängen zur Auswahl eines Geräteobjekts. Dieses Objekt wird im Gerätebaum an Stelle des gerade selektierten Objekts eingefügt. Aufruf : Kontextmenü eines Geräteobjekts im Gerätebaum Voraussetzung : Im Gerätebaum ist ein Objekt selektiert, unterhalb dessen ein Geräteobjekt eingefügt werden kann. Sie können mit diesem Befehl entweder eine andere Version eines Geräts oder einen anderen Gerätetyp anstelle des bisherigen einsetzen. Der im Gerätebaum verwendete symbolische Gerätename bleibt stehen, der in Klammern dahinter angegebene Gerätetyp ändert sich, wenn ein anderer Typ ausgewählt wurde. Wenn also nur die Geräteversion gewechselt wird, erscheint der Objekteintrag unverändert. Wenn sich der Gerätetyp nicht ändert, bleibt der unterhalb des betroffenen Geräteeintrags eingerückte Konfigurationsbaum erhalten. In diesem Fall bleiben auch die Konfigurationseinstellungen bestehen. Inkonsistenzen in der Konfiguration, die durch die Geräteaktualisierung entstehen, meldet CODESYS beim nächsten Übersetzen der Applikation. Dies betrifft auch implizit eingefügte Bibliotheken, die CODESYS bei einem Geräte-Update nicht entsprechend entfernt. Für weitere Informationen siehe: Gerät anhängen" }, 
{ "title" : "Befehl: Diagnose bestätigen, Diagnose für Unterbaum bestätigen ", 
"url" : "_cds_cmd_acknowledge_diagnosis.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Diagnose bestätigen, Diagnose für Unterbaum bestätigen ", 
"snippet" : "Diagnose bestätigen, Diagnose für Unterbaum bestätigen Funktion : Der Befehl quittiert eine Diagnosemeldung. Aufruf : Kontextmenü eines Geräteobjekts im Gerätebaum Voraussetzung : Das Projekt ist im Onlinebetrieb. Der Befehl Diagnose bestätigen bestätigt die Diagnosemeldungen eines einzelnen Geräts....", 
"body" : "Diagnose bestätigen, Diagnose für Unterbaum bestätigen Funktion : Der Befehl quittiert eine Diagnosemeldung. Aufruf : Kontextmenü eines Geräteobjekts im Gerätebaum Voraussetzung : Das Projekt ist im Onlinebetrieb. Der Befehl Diagnose bestätigen bestätigt die Diagnosemeldungen eines einzelnen Geräts. Der Befehl Diagnose für Unterbaum bestätigen bestätigt zusätzlich die Diagnosemeldungen aller untergeordneten Geräte. Die Diagnosemeldung einer anstehenden Störung wird durch ein rotes Ausrufezeichen am Geräteobjekt signalisiert. Die Diagnosemeldung einer behobenen Störung wird durch ein graues Ausrufezeichen am Geräteobjekt signalisiert. Für weitere Informationen siehe: Gerätebaum im Onlinebetrieb" }, 
{ "title" : "Befehl: Objekt bearbeiten ", 
"url" : "_cds_cmd_edit_object.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Objekt bearbeiten ", 
"snippet" : "Objekt bearbeiten Funktion : Der Befehl öffnet das Objekt in seinem Editor. Aufruf : Menü Projekt , Kontextmenü Voraussetzung : Ein Objekt im Gerätebaum oder in der Ansicht POUs ist selektiert....", 
"body" : "Objekt bearbeiten Funktion : Der Befehl öffnet das Objekt in seinem Editor. Aufruf : Menü Projekt , Kontextmenü Voraussetzung : Ein Objekt im Gerätebaum oder in der Ansicht POUs ist selektiert. " }, 
{ "title" : "Befehl: Objekt bearbeiten mit ", 
"url" : "_cds_cmd_edit_object_with.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Objekt bearbeiten mit ", 
"snippet" : "Objekt bearbeiten mit Funktion : Wenn für eine Objekt mehrere Objekte zur Verfügung stehen, öffnet der Befehl einen Dialog, zur Auswahl des gewünschten Editors. Wenn für ein Objekt nur 1 Editor zur Verfügung steht, öffnet der Befehl das Objekt in diesem Editor. Aufruf : Menü Projekt , Kontextmenü Vo...", 
"body" : "Objekt bearbeiten mit Funktion : Wenn für eine Objekt mehrere Objekte zur Verfügung stehen, öffnet der Befehl einen Dialog, zur Auswahl des gewünschten Editors. Wenn für ein Objekt nur 1 Editor zur Verfügung steht, öffnet der Befehl das Objekt in diesem Editor. Aufruf : Menü Projekt , Kontextmenü Voraussetzung : Ein Objekt im Gerätebaum oder in der Ansicht POUs ist selektiert. In der CODESYS Standardinstallation gibt es bisher kein Objekt, für das mehrere Editoren zur Verfügung stehen. " }, 
{ "title" : "Befehl: Objekt (offline) bearbeiten ", 
"url" : "_cds_cmd_edit_object_offline.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Objekt (offline) bearbeiten ", 
"snippet" : "Objekt (offline) bearbeiten Funktion : Der Befehl öffnet das Objekt offline in seinem Editor. Aufruf : Menü Projekt , Kontextmenü Voraussetzung : Die Applikation ist im Onlinebetrieb. Ein Objekt im Gerätebaum oder in der Ansicht POUs ist selektiert. Somit können Sie auch im Onlinebetrieb das Objekt ...", 
"body" : "Objekt (offline) bearbeiten Funktion : Der Befehl öffnet das Objekt offline in seinem Editor. Aufruf : Menü Projekt , Kontextmenü Voraussetzung : Die Applikation ist im Onlinebetrieb. Ein Objekt im Gerätebaum oder in der Ansicht POUs ist selektiert. Somit können Sie auch im Onlinebetrieb das Objekt editieren. Die Änderung übertragen Sie anschließend mit dem Menübefehl Online → Online-Change oder Online → Laden auf die Steuerung. " }, 
{ "title" : "Befehl: Aktive Applikation setzen ", 
"url" : "_cds_cmd_set_active_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Aktive Applikation setzen ", 
"snippet" : "Aktive Applikation setzen Funktion : Der Befehl setzt die selektierte Applikation als die „aktive Applikation“. Aufruf : Menü Projekt , Kontextmenü des Objekts Applikation Voraussetzung : Das Projekt verfügt über mindestens 2 Applikationen. Die selektierte Applikation ist nicht aktiv. Online-Aktione...", 
"body" : "Aktive Applikation setzen Funktion : Der Befehl setzt die selektierte Applikation als die „aktive Applikation“. Aufruf : Menü Projekt , Kontextmenü des Objekts Applikation Voraussetzung : Das Projekt verfügt über mindestens 2 Applikationen. Die selektierte Applikation ist nicht aktiv. Online-Aktionen betreffen immer nur die aktive Applikation. Eine aktive Applikation wird im Gerätebaum fettgedruckt dargestellt. " }, 
{ "title" : "Befehl: Projektinformationen ", 
"url" : "_cds_cmd_project_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Projektinformationen ", 
"snippet" : "Projektinformationen Symbol: Funktion : Der Befehl öffnet den Dialog Projektinformationen . Aufruf : Menü Projekt Wenn Sie den Befehl im Projekt das erste Mal ausführen, legt CODESYS das Objekt Projektinformationen an. Für weitere Informationen siehe: Projektinformation abfragen und bearbeiten...", 
"body" : "Projektinformationen Symbol: Funktion : Der Befehl öffnet den Dialog Projektinformationen . Aufruf : Menü Projekt Wenn Sie den Befehl im Projekt das erste Mal ausführen, legt CODESYS das Objekt Projektinformationen an. Für weitere Informationen siehe: Projektinformation abfragen und bearbeiten" }, 
{ "title" : "Befehl: Projekteinstellungen ", 
"url" : "_cds_cmd_project_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Projekteinstellungen ", 
"snippet" : "Projekteinstellungen Symbol: Funktion : Der Befehl öffnet den Dialog Projekteinstellungen . Aufruf : Menü Projekt oder Doppelklick auf das Objekt Projekteinstellungen in der Ansicht POUs Voraussetzung : Ein Projekt ist geöffnet. Für weitere Informationen siehe: Projekteinstellungen vornehmen...", 
"body" : "Projekteinstellungen Symbol: Funktion : Der Befehl öffnet den Dialog Projekteinstellungen . Aufruf : Menü Projekt oder Doppelklick auf das Objekt Projekteinstellungen in der Ansicht POUs Voraussetzung : Ein Projekt ist geöffnet. Für weitere Informationen siehe: Projekteinstellungen vornehmen" }, 
{ "title" : "Befehl: Projektumgebung ", 
"url" : "_cds_cmd_project_environment.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Projektumgebung ", 
"snippet" : "Projektumgebung Funktion : Der Befehl öffnet den Dialog Projektumgebung . Aufruf : Menü Projekt Voraussetzung : Ein Projekt ist geöffnet. Der Befehl dient der Überprüfung auf Aktualität von Software und Dateien, die im Projekt eingebunden sind, und ermöglicht diese zu aktualisieren....", 
"body" : "Projektumgebung Funktion : Der Befehl öffnet den Dialog Projektumgebung . Aufruf : Menü Projekt Voraussetzung : Ein Projekt ist geöffnet. Der Befehl dient der Überprüfung auf Aktualität von Software und Dateien, die im Projekt eingebunden sind, und ermöglicht diese zu aktualisieren. " }, 
{ "title" : "Befehl: Projektlokalisierung: Lokalisierungsvorlage erzeugen ", 
"url" : "_cds_cmd_project_loc_create_localization_template.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Projektlokalisierung: Lokalisierungsvorlage erzeugen ", 
"snippet" : "Projektlokalisierung: Lokalisierungsvorlage erzeugen Funktion : Der Befehl öffnet den Dialog Lokalisierungsvorlage erzeugen . Hier definieren Sie, welche Textinformationen aus dem Projekt in eine Übersetzungsvorlage des Dateiformats pot exportiert werden sollen. Aufruf : Menü Projekt → Projektlokali...", 
"body" : "Projektlokalisierung: Lokalisierungsvorlage erzeugen Funktion : Der Befehl öffnet den Dialog Lokalisierungsvorlage erzeugen . Hier definieren Sie, welche Textinformationen aus dem Projekt in eine Übersetzungsvorlage des Dateiformats pot exportiert werden sollen. Aufruf : Menü Projekt → Projektlokalisierung Voraussetzung : Ein Projekt ist geöffnet. " }, 
{ "title" : "Dialog: Lokalisierungsvorlage erzeugen ", 
"url" : "_cds_cmd_project_loc_create_localization_template.html#UUID-7af442ed-2731-3bea-0dd4-611b4d702b7c_id_bf604acce1e6ac0a8640e00e72f04_id_97aec47ead1fa1b9c0a8640e01caaf0d", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Projektlokalisierung: Lokalisierungsvorlage erzeugen \/ Dialog: Lokalisierungsvorlage erzeugen ", 
"snippet" : "Der Dialog dient der Auswahl der textuellen Informationen, die in die Lokalisierungsvorlage aufgenommen werden sollen. Folgende Informationen einschließen Namen Texte wie beispielsweise Dialogtitel, Objektnamen im Gerätebaum Bezeichner Variablenbezeichner Beispiel: Counter Zeichenfolgen Beispiel: 'c...", 
"body" : "Der Dialog dient der Auswahl der textuellen Informationen, die in die Lokalisierungsvorlage aufgenommen werden sollen. Folgende Informationen einschließen Namen Texte wie beispielsweise Dialogtitel, Objektnamen im Gerätebaum Bezeichner Variablenbezeichner Beispiel: Counter Zeichenfolgen Beispiel: 'count' in der Deklaration strVar: STRING := 'count'; Kommentare Kommentartexte in den Programmierbausteinen Positionsinformationen Auswahl, welche Positionen der oben ausgewählten Textkategorien im Projekt in die Übersetzungsdatei aufgenommen werden sollen Die Positionsinformation steht jeweils in der\/den ersten Zeile(n) eines Abschnitts für eine Übersetzung. Beispiel: #: D:\\Proj1.project\\Project_Settings:1 msgid \"Projekteinstellungen\" msgstr \"\" Alle : Alle gefundenen Positionen des Texts werden aufgeführt. Erstes Auftreten : In die Übersetzungsdatei wird die Position im Projekt aufgenommen, an der der zu übersetzende Text erstmalig auftritt. Keine Erzeugen Die Schaltfläche öffnet den Dialog zum Speichern einer Datei. Die Übersetzungsvorlage wird in einer Textdatei vom Typ POT Translation Template (*.pot) angelegt. Jedes weitere Erzeugen erstellt wieder eine komplette neue Vorlagedatei. " }, 
{ "title" : "Befehl: Projektlokalisierung: Lokalisierungen verwalten ", 
"url" : "_cds_cmd_project_loc_manage_localizations.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Projektlokalisierung: Lokalisierungen verwalten ", 
"snippet" : "Projektlokalisierung: Lokalisierungen verwalten Funktion : Der Befehl öffnet den Dialog Lokalisierungen verwalten . Im Dialog wählen Sie die gewünschte Lokalisierungssprache oder die Originalversion des Projekts aus. Weiterhin können Sie hier Lokalisierungsdateien *.<Sprache>.po ins Projekt aufnehme...", 
"body" : "Projektlokalisierung: Lokalisierungen verwalten Funktion : Der Befehl öffnet den Dialog Lokalisierungen verwalten . Im Dialog wählen Sie die gewünschte Lokalisierungssprache oder die Originalversion des Projekts aus. Weiterhin können Sie hier Lokalisierungsdateien *.<Sprache>.po ins Projekt aufnehmen oder daraus entfernen. Aufruf : Menü Projekt → Projektlokalisierung Voraussetzung : Ein Projekt ist geöffnet. " }, 
{ "title" : "Dialog: Lokalisierungen verwalten ", 
"url" : "_cds_cmd_project_loc_manage_localizations.html#UUID-81e04e1c-4d12-6b2a-71f2-e34de5e21169_id_e115a730acd0bb1dc0a8640e0057d3f1_id_0580deebc55938f3c0a8640e01d8ca60", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Projektlokalisierung: Lokalisierungen verwalten \/ Dialog: Lokalisierungen verwalten ", 
"snippet" : "Verfügbare Lokalisierungen Liste der im Projekt vorliegenden Lokalisierungsdateien Beispiel: proj1-de.po proj1-en.po <Originalversion> Die Originalversion ist immer verfügbar. Nur in der Originalversion kann das Projekt editiert werden. Hinzufügen Die Schaltfläche öffnet den Dialog zum Auswählen ein...", 
"body" : "Verfügbare Lokalisierungen Liste der im Projekt vorliegenden Lokalisierungsdateien Beispiel: proj1-de.po proj1-en.po <Originalversion> Die Originalversion ist immer verfügbar. Nur in der Originalversion kann das Projekt editiert werden. Hinzufügen Die Schaltfläche öffnet den Dialog zum Auswählen einer weiteren po -Datei aus dem Dateisystem. Entfernen Die Schaltfläche entfernt die links ausgewählte po -Datei aus dem Projekt. Standardlokalisierung : Die gerade selektierte Lokalisierung wird zur Standardlokalisierung. Der Eintrag wird fett dargestellt. Lokalisierung wechseln Mit der Schaltfläche wechseln Sie zur gerade selektierten Lokalisierung. OK Das Projekt wird in der Landessprache dargestellt, die durch die unter Dateien ausgewählten Datei geliefert wird. Wenn Sie <Originalversion> auswählen, erscheint das Projekt in der editierbaren, nicht lokalisierten Fassung. " }, 
{ "title" : "Befehl: Projektlokalisierung: Lokalisierung umschalten ", 
"url" : "_cds_cmd_project_loc_toggle_localization.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Projektlokalisierung: Lokalisierung umschalten ", 
"snippet" : "Projektlokalisierung: Lokalisierung umschalten Symbol: Funktion : Der Befehl schaltet zwischen der aktuell eingestellten Projektlokalisierung und der <Originalversion> um. Aufruf : Menü Projekt → Projektlokalisierung und dann Schaltfläche im Dialog Lokalisierungen verwalten , oder Schaltfläche in de...", 
"body" : "Projektlokalisierung: Lokalisierung umschalten Symbol: Funktion : Der Befehl schaltet zwischen der aktuell eingestellten Projektlokalisierung und der <Originalversion> um. Aufruf : Menü Projekt → Projektlokalisierung und dann Schaltfläche im Dialog Lokalisierungen verwalten , oder Schaltfläche in der Werkzeugleiste Voraussetzung : Ein Projekt ist geöffnet. Eine Standardlokalisierung für das Projekt ist im Dialog Lokalisierungen verwalten definiert. " }, 
{ "title" : "Befehl: Dokumentieren ", 
"url" : "_cds_cmd_document_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Dokumentieren ", 
"snippet" : "Dokumentieren Symbol : Funktion : Der Befehl öffnet den Dialog Projekt dokumentieren , wo Sie die Projektdokumentation definieren. Die Projektdokumentation ist die Auswahl der Objekte des geöffneten Projekts, deren Inhalt sie ausdrucken wollen. Aufruf : Menü Projekt Dialog Projekt dokumentieren Bitt...", 
"body" : "Dokumentieren Symbol : Funktion : Der Befehl öffnet den Dialog Projekt dokumentieren , wo Sie die Projektdokumentation definieren. Die Projektdokumentation ist die Auswahl der Objekte des geöffneten Projekts, deren Inhalt sie ausdrucken wollen. Aufruf : Menü Projekt Dialog Projekt dokumentieren Bitte wählen Sie die auszudruckenden Objekte aus Baumansicht des Projekts In der Ansicht können Sie jedes Objekt aktivieren oder deaktivieren und somit für den Ausdruck aus- oder abwählen. Standardmäßig sind alle Objekte ausgewählt. Deckblatt CODESYS erstellt ein Deckblatt mit dem Titel „Project Documentation“ und folgenden Informationen: File: Dateiname des Projekts Date: Datum der Erstellung der Projektdokumentation Profile: CODESYS Profil des Projekts Inhaltsverzeichnis CODESYS erstellt ein Inhaltsverzeichnis für die Projektdokumentation. Vorschau CODESYS erstellt und öffnet eine Vorschau des Ausdrucks der Projektdokumentation. Auswählen CODESYS öffnet eine Auswahlliste zur Auswahl aller oder einzelner Objekttypen für die Projektdokumentation. Auswahl aufheben CODESYS öffnet eine Auswahllliste zur Auswahl aller oder einzelner Objekttypen, die nicht in der Projektdokumentation enthalten sein sollen. OK Der Dialog Drucken öffnet sich. " }, 
{ "title" : "Befehl: Vergleichen ", 
"url" : "_cds_cmd_project_compare.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Vergleichen ", 
"snippet" : "Vergleichen Symbol: Funktion : Der Befehl öffnet den Dialog Projektvergleich . In diesem Dialog definieren Sie das Referenzprojekt, mit dem das aktuelle Projekt verglichen wird. Über Optionen konfigurieren Sie den Vergleichsprozess. Mit Beenden des Dialogs startet der Vergleich und das Ergebnis wird...", 
"body" : "Vergleichen Symbol: Funktion : Der Befehl öffnet den Dialog Projektvergleich . In diesem Dialog definieren Sie das Referenzprojekt, mit dem das aktuelle Projekt verglichen wird. Über Optionen konfigurieren Sie den Vergleichsprozess. Mit Beenden des Dialogs startet der Vergleich und das Ergebnis wird in der Ansicht Projektvergleich - Unterschiede dargestellt. Aufruf : Projekt → Vergleichen Voraussetzung : Ein Projekt ist geöffnet. Für weitere Informationen siehe: Projekt vergleichen" }, 
{ "title" : "Dialog: Projektvergleich ", 
"url" : "_cds_cmd_project_compare.html#UUID-f5ea182a-cfb7-3593-8e76-0cea6ad834e6_id_b4ab0feb656a504c0a8640e0049e575_id_63feca2505a112dcc0a8640e0093f4b0", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Vergleichen \/ Dialog: Projektvergleich ", 
"snippet" : "Das aktuell geöffnete Projekt vergleichen mit Projekt auf Festplatte Pfad des Referenzprojekts im Dateisystem Projekt in einer Quellcode-Datenbank Host: Name des Hosts, auf dem die Quellcodeverwaltung liegt Port: Nummer des Ports für die Verbindung zur Quellcodeverwaltung Speicherort: Pfad des Refer...", 
"body" : "Das aktuell geöffnete Projekt vergleichen mit Projekt auf Festplatte Pfad des Referenzprojekts im Dateisystem Projekt in einer Quellcode-Datenbank Host: Name des Hosts, auf dem die Quellcodeverwaltung liegt Port: Nummer des Ports für die Verbindung zur Quellcodeverwaltung Speicherort: Pfad des Referenzprojekts Voraussetzung: Das Projekt ist an eine Quellcode-Verwaltung (beispielsweise CODESYS SVN ) angebunden. Vergleichsoptionen: Leerzeichen ignorieren : Abweichungen des aktuellen Projekts vom Referenzprojekt, die nur auf Leerzeichen basieren, werden ignoriert. Kommentare ignorieren : Kommentare im Programmiercode sind vom Vergleich ausgeschlossen. Eigenschaften ignorieren : Objekteigenschaften sind vom Vergleich ausgeschlossen. OK Startet den Projektvergleich und stellt das Ergebnis in der Ansicht Projektvergleich - Unterschiede dar " }, 
{ "title" : "Ansicht: Projektvergleich - Unterschiede ", 
"url" : "_cds_cmd_project_compare.html#UUID-f5ea182a-cfb7-3593-8e76-0cea6ad834e6_id_b4ab0feb656a504c0a8640e0049e575_id_b06064bf995011e79187da3a4d206d74", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Vergleichen \/ Ansicht: Projektvergleich - Unterschiede ", 
"snippet" : "Die Projektvergleichsansicht erscheint, wenn Sie den Dialog Projektvergleich mit OK beenden. (1) Objektbaum des aktuellen Projekts (2) Objektbaum des Referenzprojekts (3) Befehl Block übernehmen , Befehl Einzeln übernehnen (4) Vergleichsoptionen , konfiguriert im Dialog Projektvergleich , Vergleichs...", 
"body" : "Die Projektvergleichsansicht erscheint, wenn Sie den Dialog Projektvergleich mit OK beenden. (1) Objektbaum des aktuellen Projekts (2) Objektbaum des Referenzprojekts (3) Befehl Block übernehmen , Befehl Einzeln übernehnen (4) Vergleichsoptionen , konfiguriert im Dialog Projektvergleich , Vergleichsstatistik : hinzugefügte, gelöschte, geänderte Objekte Symbolleiste Wechselt in die Detailvergleichsansicht Projektvergleich - <Objektname> Unterschiede für das im Baum selektierte Objekt Alternative: Doppelklick auf das Objekt Selektiert im Gerätebaum das nächste untere Objekt, für das Unterschiede gefunden wurden Selektiert im Gerätebaum das nächste obere Objekt, für das Unterschiede gefunden wurden Block übernehmen Der Block (das selektierte Objekt mit allen untergeordneten Objekten und Einheiten) wird für die Übernahme vom Referenzblock in den aktuellen Block ausgewählt. Ein wiederholter Klick auf Block übernehmen macht die Effekte seiner letzten Anwendung rückgängig. Einzeln übernehmen Das Objekt wird für die Übernahme vom Referenzobjekt in das aktuelle Objekt ausgewählt. Voraussetzung: Das im Objektbaum selektierte Objekt ist in den Eigenschaften, den Zugriffsrechten oder der Ordnerzugehörigkeit unterschiedlich. Öffnet den Dialog Übernehmen für Detailabfrage Darstellung der Unterschiede mit Farben und Symbolen Objektname mit Die Kindobjekte der Objekte sind unterschiedlich. Schwarze Schrift Die Objekte sind identisch. Grau hinterlegt Die Objekte sind unterschiedlich. Grau hinterlegt + fette blaue Schrift Das Objekt ist nur im Referenzprojekt vorhanden. Grau hinterlegt + fette grüne Schrift Das Objekt ist nur im geöffneten Projekt (nicht im Referenzobjekt) vorhanden. Grau hinterlegt + rote Schrift + Das Objekt hat unterschiedliche Eigenschaften. Grau hinterlegt + rote Schrift + Die Zugriffsrechte von Objekt und Referenzobjekt sind unterschiedlich. Grau hinterlegt + fette rote Schrift + Die Implementierung der Objekte ist unterschiedlich. Mit Doppelklick auf die Zeile erscheint die objektspezifische Vergleichsansicht. Gelb hinterlegt Das Objekt ist für Übernahme aktiviert. Gelb hinterlegt + Das Hinzufügen des Referenzobjekts ins geöffnete Projekt ist aktiviert. Gelb hinterlegt + Das Löschen des Objekts (im geöffneten Projekt) ist aktiviert. Gelb hinterlegt + Die Übernahme der Eigenschaften des Referenzobjekts ist aktiviert. Gelb hinterlegt + rote Schrift + Die Übernahme der Zugriffsrecht des Referenzobjekts ist aktiviert. Grau hinterlegt + fette rote Schrift + Die Übernahme der Implementierung des Referenzobjekts ist aktiviert. Anzeigen im Fußbereich der Ansicht Vergleichsoptionen Die im Dialog Projektvergleich definierten Vergleichsoptionen Vergleichsstatistik Anzahl der Einfügungen, Löschungen, Änderungen im aktuellen Projekt, verglichen mit dem Referenzprojekt Änderung bedeutet Unterschiede innerhalb eines in beiden Projekten vorhandenen Objekts. Die Eingabeaufforderung Möchten Sie die Änderungen speichern, die Sie in der Vergleichsansicht vorgenommen haben? erscheint. Ja : Die Inhalte, Eigenschaften oder Zugriffsrechte der gelb hinterlegten Objekte werden im Projekt geändert. Sie entsprechen dann denen des Referenzprojekts. Dann wird die Projektvergleichsansicht insgesamt geschlossen. " }, 
{ "title" : "Ansicht: Projektvergleich - <Objektname> Unterschiede ", 
"url" : "_cds_cmd_project_compare.html#UUID-f5ea182a-cfb7-3593-8e76-0cea6ad834e6_id_b4ab0feb656a504c0a8640e0049e575_id_0c281e3bff98a2e4c0a8646318863ab4", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Vergleichen \/ Ansicht: Projektvergleich - <Objektname> Unterschiede ", 
"snippet" : "Funktion : Detailvergleichsansicht Aufruf in der Projektvergleichsansicht Selektieren eines Objekts, das als inhaltlich unterschiedlich gekennzeichnet ist und dessen Inhalt Sie deshalb im Detail benötigen, und klicken auf . Doppelklicken auf das Objekt Symbolleiste Wechselt zurück in die Projektverg...", 
"body" : "Funktion : Detailvergleichsansicht Aufruf in der Projektvergleichsansicht Selektieren eines Objekts, das als inhaltlich unterschiedlich gekennzeichnet ist und dessen Inhalt Sie deshalb im Detail benötigen, und klicken auf . Doppelklicken auf das Objekt Symbolleiste Wechselt zurück in die Projektvergleichsansicht Selektiert im Code die nächste untere Zeile, für die Unterschiede gefunden wurden Selektiert im Code die nächste obere Zeile, für die Unterschiede gefunden wurden Block übernehmen 2 Der Block (mit allen untergeordneten Zeilen) wird für die Übernahme des Referenzblocks in das aktuelle Projekt ausgewählt. Ein Block in der Detailvergleichsansicht besteht aus der Einheit, in der der Cursor aktuell platziert ist, und aus allen zugehörigen Einheiten, die dieselbe Markierung von Unterschieden aufweisen. Eine Einheit ist eine Zeile, ein Netzwerk oder ein Element. Zugehörige Einheiten sind beispielsweise Folgezeilen einer Zeile. Ein wiederholter Klick auf Block übernehmen macht die Effekte seiner letzten Anwendung rückgängig. Einzeln übernehmen Die Zeile wird für die Übernahme der Referenzzeile in das aktuelle Objekt ausgewählt. Diese Schaltfläche ist nur innerhalb der Detailvergleichsansicht verfügbar: Wechselt zwischen folgenden Darstellungen für die unterschiedlichen Einheiten (Zeilen, Netzwerke, Elemente): Sie werden rot markiert und auf gleicher Höhe direkt gegenübergestellt Sie werden je nach Fall im aktuell geöffneten Projekt oder Referenzprojekt als gelöscht oder eingefügt dargestellt. Hinweis: Je nach Darstellung werden gefundene Unterschiede in der Statistik als Änderung, oder als Einfügung und Löschung gezählt! Dritte Ansicht in der Detailvergleichsansicht Die Schaltfläche öffnet oder schließt unterhalb der Gegenüberstellung von aktueller und Referenzansicht ein drittes Teilfenster (siehe nachfolgende Abbildung). Diese dritte Ansicht zeigt das Ergebnis der Aktionen, die zur Auflösung der gefundenen Unterschiede vorgenommen werden. Betroffene Zeilen sind durch einen gelben Balken am Zeilenbeginn gekennzeichnet. (1) Dritte Vergleichsansicht (2) Ergebnis von Aktion Rechte Zeile verwenden (3) Schaltfläche Rechte Zeile verwenden Die linke Zeile, also die Implementierung im aktuellen Projekt, wird verwendet. Der linke Block, also die Implementierung des Blocks im aktuellen Projekt, wird verwendet. Die rechte Zeile, also die Implementierung im Referenzprojekt, wird verwendet. Der rechte Block, also die Implementierung des Blocks im Referenzprojekt, wird verwendet. Nur verfügbar, wenn die Unterschiede nicht direkt gegenübergestellt sind ( ) : Die linke Zeile wird in der dritten (Ergebnis-) Ansicht oberhalb der rechten eingefügt. Nur verfügbar, wenn die Unterschiede nicht direkt gegenübergestellt sind ( ) : Die rechte Zeile wird in der dritten (Ergebnis-) Ansicht oberhalb der linken Zeile eingefügt. Darstellung der Unterschiede mit Farben und Symbolen Schwarze Schrift Die Objekte sind identisch Objektname mit Die Kindobjekte der Objekte sind unterschiedlich Grau hinterlegt + fette blaue Schrift Der Code ist nur im Referenzprojekt vorhanden. Grau hinterlegt + fette grüne Schrift Der Code ist nur im aktuellen Projekt (nicht im Referenzobjekt) vorhanden. Gelb hinterlegt Das Objekt ist für Übernahme aktiviert. Die Eingabeaufforderung Möchten Sie die Änderungen speichern, die Sie in der Vergleichsansicht vorgenommen haben? erscheint. Ja : Der gelb hinterlegte Code wird ins Projekt übernommen. Der Code entspricht dann dem des Referenzprojekts. Dann wird die Detailansicht geschlossen und zur Projektansicht gewechselt. Sie können weiter im Projektvergleich arbeiten. " }, 
{ "title" : "Dialog: Übernehmen ", 
"url" : "_cds_cmd_project_compare.html#UUID-f5ea182a-cfb7-3593-8e76-0cea6ad834e6_id_b4ab0feb656a504c0a8640e0049e575_id_2299abfeff98a2e4c0a864630c6c353e", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Vergleichen \/ Dialog: Übernehmen ", 
"snippet" : "Welche Metainformationen sollen übernommen werden? Zugriffsrechte : Zugriffsrechte, die für die Übernahme ausgewählt sind Akzeptierte Gruppen Gruppen, deren Zugriffrechte vom Referenzprojekt übernommen werden Eine Gruppe wird akzeptiert, wenn sie in beiden Projekten und mit unterschiedlichen Zugriff...", 
"body" : "Welche Metainformationen sollen übernommen werden? Zugriffsrechte : Zugriffsrechte, die für die Übernahme ausgewählt sind Akzeptierte Gruppen Gruppen, deren Zugriffrechte vom Referenzprojekt übernommen werden Eine Gruppe wird akzeptiert, wenn sie in beiden Projekten und mit unterschiedlichen Zugriffsrechten vorhanden ist. Beispiel: Group_A Nicht akzeptierte Gruppen (fehlend in einem Projekt) Die Gruppe wird nicht akzeptiert, wenn sie in einem der beiden Projekten nicht vorhanden sind. Eigenschaften : Eigenschaften aktiviert für Übernahme Voraussetzung: Die Eigenschaften von Referenzobjekt und Objekt sind unterschiedlich. OK Die Einstellungen werden übernommen. " }, 
{ "title" : "Befehl: Übernommene Änderungen übertragen ", 
"url" : "_cds_cmd_commit_accepted_changes.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Übernommene Änderungen übertragen ", 
"snippet" : "Übernommene Änderungen übertragen Symbol: Funktion : Der Befehl überträgt die übernommen Unterschiede aus dem Projektvergleich in das aktuelle Projekt. Aufruf : Projekt → Übernommene Änderungen übertragen Voraussetzung : Änderungen aus dem Projektvergleich wurden übernommen. Die Änderungen werden le...", 
"body" : "Übernommene Änderungen übertragen Symbol: Funktion : Der Befehl überträgt die übernommen Unterschiede aus dem Projektvergleich in das aktuelle Projekt. Aufruf : Projekt → Übernommene Änderungen übertragen Voraussetzung : Änderungen aus dem Projektvergleich wurden übernommen. Die Änderungen werden lediglich in das Projekt kopiert. Sie werden mit diesem Befehl nicht auf Festplatte gespeichert. Für weitere Informationen siehe: Detailvergleichsansicht öffnen" }, 
{ "title" : "Befehl: Als XML exportieren ", 
"url" : "_cds_cmd_export.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Als XML exportieren ", 
"snippet" : "Als XML exportieren Funktion : Der Befehl öffnet einen Dialog zum Exportieren von Objekten eines Projekts in eine XML-Datei. Aufruf : Menü Projekt → Export...", 
"body" : "Als XML exportieren Funktion : Der Befehl öffnet einen Dialog zum Exportieren von Objekten eines Projekts in eine XML-Datei. Aufruf : Menü Projekt → Export " }, 
{ "title" : "Dialog Exportieren ", 
"url" : "_cds_cmd_export.html#UUID-776705e8-b094-bcb8-d7f6-5fd436c5781b_id_e897dec0fff2c0a8640e0188145f_id_96a5b119635a8e3bc0a8640e005df4c1", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Als XML exportieren \/ Dialog Exportieren ", 
"snippet" : "Der Dialog listet alle Objekte aus dem Gerätebaum, dem POU-Baum und dem Modulbaum, die CODESYS exportieren kann. Eine Datei pro Unterbaum : CODESYS erzeugt für jeden Unterbaum, der direkt unterhalb des Root-Knotens hängt und ausgewählte Objekte enthält, eine eigene Exportdatei. : CODESYS erzeugt nur...", 
"body" : "Der Dialog listet alle Objekte aus dem Gerätebaum, dem POU-Baum und dem Modulbaum, die CODESYS exportieren kann. Eine Datei pro Unterbaum : CODESYS erzeugt für jeden Unterbaum, der direkt unterhalb des Root-Knotens hängt und ausgewählte Objekte enthält, eine eigene Exportdatei. : CODESYS erzeugt nur eine einzige Exportdatei für alle ausgewählten Objekte. Speicherversion Die Version sollte der Version entsprechen, in welche die Exportdatei später importiert wird. Wenn das aktuelle Projekt Plug-ins oder Add-ons enthält, die im ausgewählten Speicherformat (Profil) nicht vorhanden sind, öffnet sich der Dialog Profil erweitern . In diesem Dialog kann das auswählte Profil um die Add-ons erweitert werden. Für weitere Informationen siehe: Projekt exportieren und importieren" }, 
{ "title" : "Befehl: Aus XML importieren ", 
"url" : "_cds_cmd_import.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Aus XML importieren ", 
"snippet" : "Aus XML importieren Funktion : Der Befehl öffnet einen Dialog zum Importieren von Objekten aus einer XML-Datei. Aufruf : Menü Projekt → Import Voraussetzung : Ein Projekt ist geöffnet. Vor dem Import des Projekts prüft CODESYS , ob das Projekt Add-ons erfordert, dich nicht installiert sind. Wenn die...", 
"body" : "Aus XML importieren Funktion : Der Befehl öffnet einen Dialog zum Importieren von Objekten aus einer XML-Datei. Aufruf : Menü Projekt → Import Voraussetzung : Ein Projekt ist geöffnet. Vor dem Import des Projekts prüft CODESYS , ob das Projekt Add-ons erfordert, dich nicht installiert sind. Wenn dies der Fall ist, erscheint ein Dialog mit den fehlenden Add-ons. Diese können über diesen Dialog nachinstalliert werden. " }, 
{ "title" : "Dialog: Import ", 
"url" : "_cds_cmd_import.html#UUID-ac71f905-c8c9-883c-f3d4-548c03b37cbc_id_fe172f01dec6b272c0a8640e000bd57a_id_96a5b119635a8e3bc0a8640e005df4c1", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Aus XML importieren \/ Dialog: Import ", 
"snippet" : "Der Dialog listet alle Objekte aus der Exportdatei, die CODESYS an dieser Stelle importieren kann. Aktuell ausgewählte Zielobjekte Objekt, das im Gerätebaum selektiert ist Einfügbare Objekte Zeigt alle Objekte der Exportdatei, die CODESYS unterhalb des selektierten Objekts einfügen kann Inhalte anze...", 
"body" : "Der Dialog listet alle Objekte aus der Exportdatei, die CODESYS an dieser Stelle importieren kann. Aktuell ausgewählte Zielobjekte Objekt, das im Gerätebaum selektiert ist Einfügbare Objekte Zeigt alle Objekte der Exportdatei, die CODESYS unterhalb des selektierten Objekts einfügen kann Inhalte anzeigen Zeigt den Inhalt der Exportdatei in einer Baumstruktur Für weitere Informationen siehe: Projekt exportieren und importieren" }, 
{ "title" : "Befehl: PLCopenXML exportieren ", 
"url" : "_cds_cmd_export_plcopenxml.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: PLCopenXML exportieren ", 
"snippet" : "PLCopenXML exportieren Funktion : Der Befehl öffnet einen Dialog zum Exportieren von Objekten eines Projekts in eine XML-Datei im PLCopen-Format. Aufruf : Menü Projekt → Export Dialog: PLCopenXML exportieren Der Dialog listet alle Objekte aus dem Gerätebaum, die CODESYS in eine XML-Datei gemäß PLCop...", 
"body" : "PLCopenXML exportieren Funktion : Der Befehl öffnet einen Dialog zum Exportieren von Objekten eines Projekts in eine XML-Datei im PLCopen-Format. Aufruf : Menü Projekt → Export Dialog: PLCopenXML exportieren Der Dialog listet alle Objekte aus dem Gerätebaum, die CODESYS in eine XML-Datei gemäß PLCopen-Format exportieren kann. Das PLCopenXML-Schema erlaubt es nicht, VAR_GLOBAL und VAR_GLOBAL CONSTANT Blöcke in derselben Variablenliste zu haben. Wenn Sie also beides exportieren möchten, müssen die Variablen vorher in zwei getrennte Variablenlisten aufgeteilt werden. Für weitere Informationen siehe: Projekt exportieren und importieren" }, 
{ "title" : "Befehl: PLCopenXML importieren ", 
"url" : "_cds_cmd_import_plcopenxml.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: PLCopenXML importieren ", 
"snippet" : "PLCopenXML importieren Funktion : Der Befehl öffnet einen Dialog zum Importieren von Objekten aus einer XML-Datei im PLCopen-Format. Aufruf : Menü Projekt → Import Voraussetzung : Ein Projekt ist geöffnet....", 
"body" : "PLCopenXML importieren Funktion : Der Befehl öffnet einen Dialog zum Importieren von Objekten aus einer XML-Datei im PLCopen-Format. Aufruf : Menü Projekt → Import Voraussetzung : Ein Projekt ist geöffnet. " }, 
{ "title" : "Dialog: PLCopenXML importieren ", 
"url" : "_cds_cmd_import_plcopenxml.html#UUID-30e7f7a4-620a-f8ba-886c-a6ca39fbab9d_id_deccec55c0a8640e00ef38fa_id_96a5b119635a8e3bc0a8640e005df4c1", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: PLCopenXML importieren \/ Dialog: PLCopenXML importieren ", 
"snippet" : "Der Dialog listet alle Objekte aus der PLCopen-Exportdatei, die CODESYS an dieser Stelle importieren kann. Aktuell ausgewähltes Zielobjekt Objekt, das im Gerätebaum selektiert ist Einfügbare Einträge Zeigt alle Objekte der Exportdatei, die CODESYS unterhalb des selektierten Objekts einfügen kann Kon...", 
"body" : "Der Dialog listet alle Objekte aus der PLCopen-Exportdatei, die CODESYS an dieser Stelle importieren kann. Aktuell ausgewähltes Zielobjekt Objekt, das im Gerätebaum selektiert ist Einfügbare Einträge Zeigt alle Objekte der Exportdatei, die CODESYS unterhalb des selektierten Objekts einfügen kann Konfliktlösung Wenn Objekte importiert werden, die den gleiche Namen wie bestehende Objekte haben, kann der Konflikt für jedes Objekt folgendermaßen gelöst werden: Bestehendes Objekt ersetzen : Das im Projekt bestehende Objekt wird mit dem importierten Objekt überschrieben. Neues Objekt umbenennen : Das neue Objekt wird mit geändertem Namen importiert. Dem Namen wird ein _<nr> angehängt. Neues Objekt überspringen : Das Objekt wird nicht importiert. Auswählen Öffnet eine Auswahlliste zum Auswählen von Objekttypen Auswahl aufheben Öffnet eine Auswahlliste zur Abwahl von Objekttypen Konflikte Öffnet eine Auswahlliste zur Lösung aller Konflikte Inhalte anzeigen Öffnet einen Dialog, in dem die Objekte der xml-Datei angezeigt werden Das PLCopenXML Schema erlaubt es nicht, VAR_GLOBAL und VAR_GLOBAL CONSTANT Blöcke in derselben Variablenliste zu haben. Wenn Sie also beides exportieren möchten, müssen die Variablen vorher in zwei getrennte Variablenlisten aufgeteilt werden. Für weitere Informationen siehe: Projekt exportieren und importieren" }, 
{ "title" : "Befehl: IEC-61131-10 exportieren ", 
"url" : "_cds_cmd_export_iec_61131_10.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: IEC-61131-10 exportieren ", 
"snippet" : "IEC-61131-10 exportieren Dieses Feature wird nur für den Austausch mit anderen IDEs empfohlen, da es nur Elemente behandelt, die auch der Standard IEC-61131-10 unterstützt. Andere Objekte, wie zum Beispiel CFC-Objekte oder Bibliotheksverwalter werden nicht unterstützt. Für einen Export\/Import von CO...", 
"body" : "IEC-61131-10 exportieren Dieses Feature wird nur für den Austausch mit anderen IDEs empfohlen, da es nur Elemente behandelt, die auch der Standard IEC-61131-10 unterstützt. Andere Objekte, wie zum Beispiel CFC-Objekte oder Bibliotheksverwalter werden nicht unterstützt. Für einen Export\/Import von CODESYS zu CODESYS empfehlen wir deswegen weiterhin den nativen Import\/Export, um eine 100% Deckung zu erhalten. Symbol: Funktion : Der Befehl öffnet einen Dialog zum Exportieren des aktuell geöffneten Projekts in eine XML-Datei des Formats *.iec6113110.xml . Im Dialog Export werden Objekte der Ansichten Geräte (Knotenpunkt Device ) und POUs (Knotenpunkt Pool-Objects ) angezeigt. Dabei sind all diejenigen Objekte selektiert, die mit diesem Befehl exportiert werden können. Im Dialog können die einzelnen Objekte für den Export selektiert und deselektiert werden. Aufruf : Der Befehl ist in keinem Standardmenü enthalten. Sie können ihn über den Dialog Tools → Anpassen aus der Kategorie Objekte hinzufügen. Für weitere Informationen siehe: Menüs anpassenVoraussetzung : Ein Projekt ist geöffnet. Für weitere Informationen siehe IEC-61131-10 importieren" }, 
{ "title" : "Befehl: IEC-61131-10 importieren ", 
"url" : "_cds_cmd_import_iec_61131_10.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: IEC-61131-10 importieren ", 
"snippet" : "IEC-61131-10 importieren Dieses Feature wird nur für den Austausch mit anderen IDEs empfohlen, da es nur Elemente behandelt, die auch der Standard IEC-61131-10 unterstützt. Andere Objekte, wie zum Beispiel CFC-Objekte oder Bibliotheksverwalter werden nicht unterstützt. Für einen Export\/Import von CO...", 
"body" : "IEC-61131-10 importieren Dieses Feature wird nur für den Austausch mit anderen IDEs empfohlen, da es nur Elemente behandelt, die auch der Standard IEC-61131-10 unterstützt. Andere Objekte, wie zum Beispiel CFC-Objekte oder Bibliotheksverwalter werden nicht unterstützt. Für einen Export\/Import von CODESYS zu CODESYS empfehlen wir deswegen weiterhin den nativen Import\/Export, um eine 100% Deckung zu erhalten. Symbol: Funktion : Der Befehl öffnet einen Standarddialog zum Importieren einer XML-Datei des Formats IecXchangefiles (*.xml) . Beim Import öffnet sich der Dialog Import , der Funktionen zur Selektion, Deselektion von Objekten und zur Behandlung von Konflikten zur Verfügung stellt. Abhängig vom selektierten Objekt in der Ansicht Geräte bzw. POUs wird im Importdialog die Liste der dort einfügbaren Elemente aktualisiert. Solange der Dialog geöffnet ist, kann in der Ansicht Geräte bzw. POUs die Auswahl durch Klicken geändert werden. Aufruf : Der Befehl ist in keinem Standardmenü enthalten. Sie können ihn über den Dialog Tools → Anpassen aus der Kategorie Objekte hinzufügen. Für weitere Informationen siehe: Menüs anpassenVoraussetzung : Ein Projekt ist geöffnet. Dialog: Import Inhalt Einfügbare Elemente Auflistung aller Objekte der Importdatei, die im aktuellen Projekt unterhalb des selektierten Objekts eingefügt werden können. Die einzelnen Objekte können für den Import deselektiert bzw. selektiert werden. Konfliktlösung Mit einem Klick in das Feld, öffnet sich Auswahlliste zur Änderung der angezeigten Konfliktlösung für dieses Element. Voraussetzung: Für das Element besteht ein Konflikt. Wenn Objekte importiert werden, die den gleichen Namen wie bestehende Objekte haben, kann der Konflikt für jedes Objekt folgendermaßen gelöst werden: Bestehendes Objekt ersetzen : Das im Projekt bestehende Objekt wird mit dem importierten Objekt überschrieben Neues Objekt umbenennen : Das neue Objekt wird mit geändertem Namen importiert. Dem Namen wird eine fortlaufende Nummer _<no> angehängt Neues Objekt überspringen : Das Objekt wird nicht importiert Device Mit einem Klick in das Feld, wird die Schaltfläche angezeigt. Über diese Schaltfläche kann im Dialog Gerät auswählen ein anderes Gerät ausgewählt werden. Zusätzliche Informationen Datei-Header Kopfzeile des Inhalts Anzeige der Informationen der Importdatei Auswählen Mithilfe dieser Auswahlliste können alle Objekte oder alle Objekte eines bestimmten Typs selektiert werden. Deselektieren Mithilfe dieser Auswahlliste können alle Objekte oder alle Objekte eines bestimmten Typs deselektiert werden. Konflikte Mithilfe dieser Auswahlliste kann eine Konfliktlösung ausgewählt werden, die für alle Objekte, die einen Konflikt haben, angewendet wird. Um die Konfliktlösung für ein bestimmtes Objekt zu ändern, muss in das Feld Konfliktlösung des jeweiligen Objekts geklickt werden. Für weitere Informationen siehe IEC-61131-10 exportieren" }, 
{ "title" : "Befehl: Benutzerverwaltung: Benutzer anmelden ", 
"url" : "_cds_cmd_usermanagement_logon.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Benutzerverwaltung: Benutzer anmelden ", 
"snippet" : "Benutzerverwaltung: Benutzer anmelden Symbol: Funktion : Der Befehl öffnet den Dialog Anmelden . Aufruf : Menü Projekt → Benutzerverwaltung Im Dialog Anmelden geben Sie das Projekt an, das Sie bearbeiten möchten, und die Zugangsdaten für ein Benutzerkonto mit den entsprechenden Rechten. Außerdem kön...", 
"body" : "Benutzerverwaltung: Benutzer anmelden Symbol: Funktion : Der Befehl öffnet den Dialog Anmelden . Aufruf : Menü Projekt → Benutzerverwaltung Im Dialog Anmelden geben Sie das Projekt an, das Sie bearbeiten möchten, und die Zugangsdaten für ein Benutzerkonto mit den entsprechenden Rechten. Außerdem können Sie von diesem Dialog aus den Passwort-Manager öffnen. Für weitere Informationen siehe: Benutzerverwaltung und Zugriffsrechte für Projekt und Objekte konfigurieren " }, 
{ "title" : "Befehl: Benutzerverwaltung: Benutzer abmelden ", 
"url" : "_cds_cmd_usermanagement_logoff.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Benutzerverwaltung: Benutzer abmelden ", 
"snippet" : "Benutzerverwaltung: Benutzer abmelden Symbol: Funktion : Der Befehl meldet den gerade im Projekt angemeldeten Benutzer wieder ab. Dies geschieht ohne Dialog oder Meldung, außer es ist gerade gar kein Benutzer angemeldet. Aufruf : Menü Projekt → Benutzerverwaltung Wenn der Benutzer gerade in mehreren...", 
"body" : "Benutzerverwaltung: Benutzer abmelden Symbol: Funktion : Der Befehl meldet den gerade im Projekt angemeldeten Benutzer wieder ab. Dies geschieht ohne Dialog oder Meldung, außer es ist gerade gar kein Benutzer angemeldet. Aufruf : Menü Projekt → Benutzerverwaltung Wenn der Benutzer gerade in mehreren Projekten oder in einem eingebundenen Bibliothek angemeldet ist (muss nicht dasselbe Benutzerkonto sein), dann erscheint der Dialog Abmelden . In diesem Dialog kann konkret das Projekt bzw. Bibliotheksprojekt ausgewählt werden, aus dem der aktuelle Benutzer abgemeldet werden soll. Die Statusleiste zeigt immer den gerade im Projekt angemeldeten Benutzer. Ein Doppelklick auf das Feld Aktueller Benutzer in der Statusleiste ermöglicht einen schnellen Zugriff auf den Anmelden - bzw. Abmelden -Dialog. Für weitere Informationen siehe: Benutzerverwaltung und Zugriffsrechte für Projekt und Objekte konfigurieren und Benutzerverwaltung: Benutzer anmelden" }, 
{ "title" : "Befehl: Benutzerverwaltung: Rechte ", 
"url" : "_cds_cmd_usermanagement_rights.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Benutzerverwaltung: Rechte ", 
"snippet" : "Benutzerverwaltung: Rechte Funktion : Der Befehl öffnet den Dialog Rechte . Aufruf : Menü Projekt → Benutzerverwaltung Im Dialog Rechte definieren Sie, welche Aktionen von welchen Benutzergruppen auf welche Projektobjekte ausgeführt werden dürfen. Für weitere Informationen siehe: Benutzerverwaltung ...", 
"body" : "Benutzerverwaltung: Rechte Funktion : Der Befehl öffnet den Dialog Rechte . Aufruf : Menü Projekt → Benutzerverwaltung Im Dialog Rechte definieren Sie, welche Aktionen von welchen Benutzergruppen auf welche Projektobjekte ausgeführt werden dürfen. Für weitere Informationen siehe: Benutzerverwaltung und Zugriffsrechte für Projekt und Objekte konfigurieren " }, 
{ "title" : "Befehl: Gerät einfügen ", 
"url" : "_cds_cmd_insert_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Gerät einfügen ", 
"snippet" : "Gerät einfügen Funktion : Der Befehl öffnet wie beim Befehl Gerät anhängen den Dialog Gerät anhängen zur Auswahl eines Geräteobjekts. Dieses Objekt wird im Gerätebaum auf gleicher Ebene wie das gerade selektierte Objekt eingefügt. Aufruf : Kontextmenü eines Geräteobjekts im Gerätebaum Voraussetzung ...", 
"body" : "Gerät einfügen Funktion : Der Befehl öffnet wie beim Befehl Gerät anhängen den Dialog Gerät anhängen zur Auswahl eines Geräteobjekts. Dieses Objekt wird im Gerätebaum auf gleicher Ebene wie das gerade selektierte Objekt eingefügt. Aufruf : Kontextmenü eines Geräteobjekts im Gerätebaum Voraussetzung : Im Gerätebaum ist ein Objekt selektiert, unterhalb dessen auf gleicher Ebene ein Geräteobjekt eingefügt werden kann. " }, 
{ "title" : "Befehl: EtherCAT-XML erzeugen ", 
"url" : "_cds_cmd_generate_ethercat_xml.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: EtherCAT-XML erzeugen ", 
"snippet" : "EtherCAT-XML erzeugen Der Befehl ist im Standardmenü nicht eingebunden. Sie können ihn über den Dialog Tools → Anpassen aus der Kategorie Geräte hinzufügen. Für weitere Informationen siehe: Menüs anpassenFunktion : Der Befehl öffnet den Standarddialog zum Speichern einer Datei im lokalen Dateisystem...", 
"body" : "EtherCAT-XML erzeugen Der Befehl ist im Standardmenü nicht eingebunden. Sie können ihn über den Dialog Tools → Anpassen aus der Kategorie Geräte hinzufügen. Für weitere Informationen siehe: Menüs anpassenFunktion : Der Befehl öffnet den Standarddialog zum Speichern einer Datei im lokalen Dateisystem. Sie können einen Namen und Ablageort für eine xml-Datei definieren, in der CODESYS die EtherCAT-Konfiguration des gerade im Gerätebaum selektierten EtherCAT-Masters speichern soll. Dies ist möglicherweise nötig, um einen fremden EtherCAT-Stack zu betreiben. Aufruf : Kontextmenü eines EtherCAT-Master-Geräteobjekts im Gerätebaum Für weitere Informationen siehe: E\/A-Anbindung konfigurieren" }, 
{ "title" : "Befehl: sercos SCI XML erzeugen ", 
"url" : "_cds_cmd_generate_sercos3_xml.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: sercos SCI XML erzeugen ", 
"snippet" : "sercos SCI XML erzeugen Der Befehl ist im Standardmenü nicht eingebunden. Sie können ihn über den Dialog Tools → Anpassen aus der Kategorie Geräte hinzufügen. Funktion : Der Befehl öffnet den Standarddialog zum Speichern einer Datei im lokalen Dateisystem. Sie können einen Namen und Ablageort für ei...", 
"body" : "sercos SCI XML erzeugen Der Befehl ist im Standardmenü nicht eingebunden. Sie können ihn über den Dialog Tools → Anpassen aus der Kategorie Geräte hinzufügen. Funktion : Der Befehl öffnet den Standarddialog zum Speichern einer Datei im lokalen Dateisystem. Sie können einen Namen und Ablageort für eine xml-Datei definieren, in der CODESYS die Konfigurationsdaten des gerade im Gerätebaum selektierten sercos-Masters speichern soll. Dies ist möglicherweise nötig, um einen fremden sercos-Stack zu betreiben. Aufruf : Kontextmenü eines sercos-Master-Geräteobjekts im Gerätebaum " }, 
{ "title" : "Befehl: Gerät deaktivieren, Gerät aktivieren ", 
"url" : "_cds_cmd_disable_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Gerät deaktivieren, Gerät aktivieren ", 
"snippet" : "Gerät deaktivieren, Gerät aktivieren Funktion : Der Befehl schaltet zwischen aktivem und deaktivem Zustand eines Geräts im Bus-System hin und her. Aufruf : Kontextmenü eines Geräteobjekts im Gerätebaum Voraussetzung : Das Projekt ist im Offlinebetrieb. Der Bus-Treiber muss die Funktionalität unterst...", 
"body" : "Gerät deaktivieren, Gerät aktivieren Funktion : Der Befehl schaltet zwischen aktivem und deaktivem Zustand eines Geräts im Bus-System hin und her. Aufruf : Kontextmenü eines Geräteobjekts im Gerätebaum Voraussetzung : Das Projekt ist im Offlinebetrieb. Der Bus-Treiber muss die Funktionalität unterstützen. Ein deaktiviertes Gerät wird nicht berücksichtigt und nicht angesprochen. Beachten Sie, dass bei manchen Bus-Systemen das Deaktivieren eines Knotens zum Stillstand des Masters führt. Der Eintrag eines deaktivierten Geräts im Baum erscheint in hellgrauer Schrift. Beim Einloggen werden deaktivierte Geräte zusätzlich mit einem roten Dreieck markiert. " }, 
{ "title" : "Befehl: E\/A-Abbild bearbeiten ", 
"url" : "_cds_cmd_edit_io_mapping.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: E\/A-Abbild bearbeiten ", 
"snippet" : "E\/A-Abbild bearbeiten Funktion : Der Befehl öffnet die Ansicht E\/A-Abbild bearbeiten . Diese Ansicht zeigt alle E\/A-Abbilder („Mapping“) des gerade ausgewählten Geräteobjekts plus die E\/A-Abbilder aller weiteren Geräteobjekte, die im Gerätebaum unter diesem Objekt eingehängt sind. Aufruf : Kontextme...", 
"body" : "E\/A-Abbild bearbeiten Funktion : Der Befehl öffnet die Ansicht E\/A-Abbild bearbeiten . Diese Ansicht zeigt alle E\/A-Abbilder („Mapping“) des gerade ausgewählten Geräteobjekts plus die E\/A-Abbilder aller weiteren Geräteobjekte, die im Gerätebaum unter diesem Objekt eingehängt sind. Aufruf : Kontextmenü eines Geräteobjekts im Gerätebaum " }, 
{ "title" : "Ansicht: E\/A-Abbild bearbeiten ", 
"url" : "_cds_cmd_edit_io_mapping.html#UUID-a0e8fdc8-841e-1079-dd03-c917fffbb646_id_a879c3411c826d0c0a8640e019cc157_id_e4690835796ca3e6c0a8640e002c9eba", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: E\/A-Abbild bearbeiten \/ Ansicht: E\/A-Abbild bearbeiten ", 
"snippet" : "Sie können das E\/A-Abbild in diesem Dialog genauso bearbeiten wie im Dialog E\/A-Abbild der einzelnen Geräteeditoren. Die jeweils anderen Dialoge werden unmittelbar entsprechend aktualisiert. Suche Eingabefeld für eine Zeichenfolge, nach der die Mapping-Tabelle durchsucht werden soll Die Suchergebnis...", 
"body" : "Sie können das E\/A-Abbild in diesem Dialog genauso bearbeiten wie im Dialog E\/A-Abbild der einzelnen Geräteeditoren. Die jeweils anderen Dialoge werden unmittelbar entsprechend aktualisiert. Suche Eingabefeld für eine Zeichenfolge, nach der die Mapping-Tabelle durchsucht werden soll Die Suchergebnisse werden gelb markiert. Filter Auswahlliste mit Filtern für die in der Mapping-Tabelle dargestellten E\/A-Zuweisungen Alles anzeigen Nur Ausgänge anzeigen Nur Eingänge anzeigen Nur nicht-gemappte Variablen anzeigen Nur gemappte Variablen anzeigen Nur Mappings auf bestehende Variablen anzeigen Nur Mappings auf neue Variablen anzeigen Im Kontextmenü finden Sie unter anderem folgende Befehle: E\/A-Abbild in CSV exportieren : Dient dem Speichern der Mappings eines Geräts und seiner Subgeräte in eine externe Datei Sie wählen dazu das Gerät im Gerätebaum oder in der Mapping-Liste aus. E\/A-Abbild von CSV importieren : Dient dem Einfügen von Mappings aus einer vorher durch Export erzeugten Datei Für weitere Informationen siehe: E\/A-Anbindung konfigurieren" }, 
{ "title" : "Befehl: E\/A-Abbild von CSV importieren ", 
"url" : "_cds_cmd_import_io_mapping_csv.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: E\/A-Abbild von CSV importieren ", 
"snippet" : "E\/A-Abbild von CSV importieren Funktion : Der Befehl öffnet den Standarddialog um eine Datei des lokalen Dateisystems zu öffnen. Der Filter ist auf das Dateiformat csv eingestellt, um die E\/A-Abbildkonfiguration eines Geräts aus einer Datei zu importieren, die zuvor mit dem Befehl E\/A-Abbild in CSV ...", 
"body" : "E\/A-Abbild von CSV importieren Funktion : Der Befehl öffnet den Standarddialog um eine Datei des lokalen Dateisystems zu öffnen. Der Filter ist auf das Dateiformat csv eingestellt, um die E\/A-Abbildkonfiguration eines Geräts aus einer Datei zu importieren, die zuvor mit dem Befehl E\/A-Abbild in CSV exportieren exportiert wurde. CODESYS schreibt die Konfiguration in das ausgewählte Gerät. Aufruf : Kontextmenü eines Geräteobjekts in der Ansicht Geräte Voraussetzung : Ein Projekt mit einem Gerät mit E\/A-Abbildkonfiguration ist geöffnet. Das Gerät passt zur exportierten csv -Datei. E\/A-Abbildkonfigurationen werden in csv -Dateien mit dem Trennzeichen gespeichert, das in Windows in den regionalen Einstellungen als Listentrennzeichen festgelegt wurde, also Komma oder Semikolon. Diese Dateien können manuell bearbeitet werden. Wenn die Dateien manuell bearbeitet werden, muss dieses Format unbedingt beibehalten werden, um erfolgreich importiert werden zu können. Beachten Sie Folgendes: Die Zuordnung der Einträge der Datei zu dem E\/A-Abbild des Geräts erfolgt über den Gerätenamen (DeviceName) und den Kanalnamen (Parameter name). Parameternamen, die nicht eindeutig sind, werden in dieser Datei mit einer fortlaufenden Nummerierung @<n> erweitert. Felder ohne Inhalt in der csv -Datei werden beim Import ignoriert. Um einen vorhandenen Eintrag im E\/A-Abbild durch den Import zu entfernen, müssen Sie im betreffenden Feld in der csv -Datei ein Leerzeichen einfügen. Für weitere Informationen siehe: Geräte konfigurieren und E\/A-Abbild konfigurieren" }, 
{ "title" : "Befehl: E\/A-Abbild in CSV exportieren ", 
"url" : "_cds_cmd_export_io_mapping_csv.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: E\/A-Abbild in CSV exportieren ", 
"snippet" : "E\/A-Abbild in CSV exportieren Funktion : Der Befehl öffnet den Standarddialog zum Speichern einer Datei im lokalen Dateisystem. Der Filter ist auf das Dateiformat csv eingestellt. Nach Angabe eines Namens und Ablageorts speichert CODESYS die E\/A-Abbildkonfiguration in eine csv -Datei mit dem Trennze...", 
"body" : "E\/A-Abbild in CSV exportieren Funktion : Der Befehl öffnet den Standarddialog zum Speichern einer Datei im lokalen Dateisystem. Der Filter ist auf das Dateiformat csv eingestellt. Nach Angabe eines Namens und Ablageorts speichert CODESYS die E\/A-Abbildkonfiguration in eine csv -Datei mit dem Trennzeichen, das in Windows in den regionalen Einstellungen als Listentrennzeichen festgelegt wurde, also Komma oder Semikolon. Aufruf : Kontextmenü eines Geräteobjekts in der Ansicht Geräte Voraussetzung : Ein Geräteobjekt mit einer E\/A-Abbildkonfiguration ist im Gerätebaum selektiert. Parameternamen, die nicht eindeutig sind, werden in dieser Datei mit einer fortlaufenden Nummerierung @<n> erweitert. Für weitere Informationen siehe: Geräte konfigurieren und E\/A-Abbild konfigurieren" }, 
{ "title" : "Befehl: SPS-Parameterdatei in Konfiguration einlesen ", 
"url" : "_cds_cmd_read_plc_parameter_file_to_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: SPS-Parameterdatei in Konfiguration einlesen ", 
"snippet" : "SPS-Parameterdatei in Konfiguration einlesen Funktion : Der Befehl liest die Konfigurationsdatei IoConfig.par von der SPS und speichert die Werte im Projekt. Eine solche Datei wird angelegt, wenn die Parameter der SPS durch ein anderes Gerät beispielsweise über eine Visualisierung verändert wurden. ...", 
"body" : "SPS-Parameterdatei in Konfiguration einlesen Funktion : Der Befehl liest die Konfigurationsdatei IoConfig.par von der SPS und speichert die Werte im Projekt. Eine solche Datei wird angelegt, wenn die Parameter der SPS durch ein anderes Gerät beispielsweise über eine Visualisierung verändert wurden. Dann sind diese Parameter nur im Speicher der SPS geändert, jedoch nicht in der Konfiguration des Projekts. Aufruf : Kontextmenü des SPS-Geräteobjekts Voraussetzung : Sie haben den Befehl über den Dialog Tools → Anpassen in der Benutzeroberfläche verfügbar gemacht. Für weitere Informationen siehe: SPS-Parameterdatei in Konfiguration einlesen " }, 
{ "title" : "Befehl: Online-Konfigurationsbetrieb ", 
"url" : "_cds_cmd_online_configuration_mode.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Online-Konfigurationsbetrieb ", 
"snippet" : "Online-Konfigurationsbetrieb Funktion : Der Befehl dient dem Ein- und Ausschalten des Online-Konfigurationsbetriebs. Beim Einschalten baut er eine Verbindung zur SPS auf und lädt dorthin eine implizit erzeugte Applikation HiddenOnlineConfigModeApp . Abhängig vom Gerät geht CODESYS in den einfachen O...", 
"body" : "Online-Konfigurationsbetrieb Funktion : Der Befehl dient dem Ein- und Ausschalten des Online-Konfigurationsbetriebs. Beim Einschalten baut er eine Verbindung zur SPS auf und lädt dorthin eine implizit erzeugte Applikation HiddenOnlineConfigModeApp . Abhängig vom Gerät geht CODESYS in den einfachen Online-Konfigurationsbetrieb, oder es erscheint ein Dialog zum Wählen zwischen einfachem und erweitertem Online-Konfigurationsbetrieb. Aufruf : Kontextmenü des SPS-Objekts im Gerätebaum Voraussetzung : Die Kommunikationseinstellungen für das SPS-Gerät sind korrekt gesetzt. Einfacher Online-Konfigurationsbetrieb Der Befehl erzeugt die implizite Applikation HiddenOnlineConfigModeApp und lädt sie auf die Steuerung. Die Applikation initialisiert automatisch einmal alle Eingänge und Ausgänge der Steuerung. Sie können danach folgendermaßen auf die E\/As zugreifen: E\/As lesen Ausgänge schreiben Diagnose (im Gerätebaum und auf Registerkarte Status des Geräteeditors) Scan (der aktuellen Hardware) Interaktive Online-Funktionen, wenn verfügbar (beispielsweise Schreiben asynchroner Meldungen) Erweiterter Online-Konfigurationsbetrieb (Parameterbetrieb) Wenn bereits Applikationen auf der SPS liegen, und die Steuerung es unterstützt, öffnet der Befehl zunächst den Dialog Geräte , der die auf der Steuerung liegenden Applikationen anzeigt. Sie können aus diesem Dialog über die Schaltfläche Parameterbetrieb zur SPS verbinden und dann auch auf die Werte der Geräteparameter zugreifen, ohne mit einer reellen Applikation einloggen zu müssen. Schreiben und Forcen im E\/A-Abbild Im Online-Konfigurationsbetrieb funktioniert das Schreiben und Forcen von Werten auf der Registerkarte E\/A-Abbild anders als im reellen Onlinebetrieb. Die Ausgänge werden sofort nach dem Einfügen in die Tabelle geschrieben. Es gibt keine Spalte Vorbereiteter Wert , sondern die Ausgangswerte können direkt nach einem Doppelklick auf die Spalte Aktueller Wert verändert werden. " }, 
{ "title" : "Dialog: Konfigurationsbetrieb auswählen ", 
"url" : "_cds_cmd_online_configuration_mode.html#UUID-91bcb393-0216-c2c1-9344-e0347e485d28_id_ec211ca1ba0c0a8640e000c867a_id_ddb7ffbc9269d801c0a8640e000ce2e0", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Projekt \/ Befehl: Online-Konfigurationsbetrieb \/ Dialog: Konfigurationsbetrieb auswählen ", 
"snippet" : "Der Dialog erscheint nach dem Befehl Online-Konfigurationsbetrieb , wenn das Gerät den erweiterten Online-Konfigurationsbetrieb unterstützt und bereits reelle Applikationen auf der Steuerung liegen. Parameterbetrieb Die Steuerungskonfiguration im Projekt wird mit derjenigen auf dem Gerät verglichen....", 
"body" : "Der Dialog erscheint nach dem Befehl Online-Konfigurationsbetrieb , wenn das Gerät den erweiterten Online-Konfigurationsbetrieb unterstützt und bereits reelle Applikationen auf der Steuerung liegen. Parameterbetrieb Die Steuerungskonfiguration im Projekt wird mit derjenigen auf dem Gerät verglichen. Bei Übereinstimmung baut CODESYS eine Verbindung zur SPS auf. Im Unterschied zum einfachen Online-Konfigurationsbetrieb erlaubt sie das Lesen und - wenn vom Treiber unterstützt - Schreiben von Parametern im generischen Geräteeditor. Die auf dem Gerät bereits geladenen Applikationen bleiben in diesem Fall unangetastet! Konfigurationsbetrieb CODESYS schaltet in den „einfachen Online-Konfigurationsbetrieb“. Für weitere Informationen siehe: Überprüfung der Steuerungskonfiguration mit Hilfe des Befehls Online-Konfigurationsbetrieb " }, 
{ "title" : "Erstellen ", 
"url" : "_cds_f_commands_build.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Erstellen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: Code erzeugen ", 
"url" : "_cds_cmd_generate_code.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Erstellen \/ Befehl: Code erzeugen ", 
"snippet" : "Code erzeugen Symbol: Tastaturkürzel: F11 Funktion : Der Befehl startet eine Codeerzeugung für die aktive Applikation. Aufruf : Menü Erstellen Bei der Codeerzeugung mit diesem Befehl wird wie beim Laden der Applikation auf die Steuerung Code erzeugt; der Code wird jedoch nicht auf die Steuerung über...", 
"body" : "Code erzeugen Symbol: Tastaturkürzel: F11 Funktion : Der Befehl startet eine Codeerzeugung für die aktive Applikation. Aufruf : Menü Erstellen Bei der Codeerzeugung mit diesem Befehl wird wie beim Laden der Applikation auf die Steuerung Code erzeugt; der Code wird jedoch nicht auf die Steuerung übertragen. Dabei erfolgen weitere Prüfungen des Quellcodes. Somit können Sie den Code auf Fehler prüfen, die vom Compiler nicht erkannt werden und diese korrigieren, bevor er im Onlinebetrieb verwendet wird. Für weitere Informationen siehe: Applikationscode erzeugen" }, 
{ "title" : "Befehl: Bereinigen ", 
"url" : "_cds_cmd_clean.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Erstellen \/ Befehl: Bereinigen ", 
"snippet" : "Bereinigen Funktion : Der Befehl löscht die Übersetzungsinformation für die gerade aktive Applikation. Aufruf : Menü Erstellen Die Übersetzungsinformation wurde beim letzten Download der Applikation angelegt und in einer Datei (*.compileinfo) gespeichert. Nach einem Bereinigen-Prozess ist für die be...", 
"body" : "Bereinigen Funktion : Der Befehl löscht die Übersetzungsinformation für die gerade aktive Applikation. Aufruf : Menü Erstellen Die Übersetzungsinformation wurde beim letzten Download der Applikation angelegt und in einer Datei (*.compileinfo) gespeichert. Nach einem Bereinigen-Prozess ist für die betroffene Applikation kein Online Change mehr möglich. Die Applikation muss wieder komplett auf die Steuerung geladen werden. Für weitere Informationen siehe: Alles bereinigen" }, 
{ "title" : "Befehl: Alles bereinigen ", 
"url" : "_cds_cmd_clean_all.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Erstellen \/ Befehl: Alles bereinigen ", 
"snippet" : "Alles bereinigen Funktion : Der Befehl löscht die Übersetzungsinformationen für alle Applikationen des Projekts. Aufruf : Menü Erstellen Die Übersetzungsinformation wurde beim letzten Download der Applikation im lokalen Dateisystem angelegt und in einer Datei (*.compileinfo) gespeichert. Der Befehl ...", 
"body" : "Alles bereinigen Funktion : Der Befehl löscht die Übersetzungsinformationen für alle Applikationen des Projekts. Aufruf : Menü Erstellen Die Übersetzungsinformation wurde beim letzten Download der Applikation im lokalen Dateisystem angelegt und in einer Datei (*.compileinfo) gespeichert. Der Befehl bewirkt, dass vor einem erneuten Einloggen zwingend ein Download durchgeführt werden muss. Ein Online-Change ist nicht mehr möglich. Im Unterschied zum Befehl Bereinigen (nur der aktiven Applikation) erzeugt CODESYS das Sprachmodell für alle Objekte neu, was zusätzlich Zeit in Anspruch nimmt. Überlegen Sie sorgfältig, ob es nötig ist, den Befehl anzuwenden. Wenn Sie nur ein erneutes Übersetzen und einen Download der aktiven Applikation wünschen, verwenden Sie den Befehl Bereinigen . " }, 
{ "title" : "Befehl: Übersetzen ", 
"url" : "_cds_cmd_build.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Erstellen \/ Befehl: Übersetzen ", 
"snippet" : "Übersetzen Funktion : Der Befehl startet den Übersetzungsprozess für die gerade aktive Applikation. Aufruf : Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn mit Hilfe des Dialogs Tools → Anpassen aus der Befehlskategorie Übersetzen in ein Menü einfügen. Bei der Übersetzung führ...", 
"body" : "Übersetzen Funktion : Der Befehl startet den Übersetzungsprozess für die gerade aktive Applikation. Aufruf : Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn mit Hilfe des Dialogs Tools → Anpassen aus der Befehlskategorie Übersetzen in ein Menü einfügen. Bei der Übersetzung führt CODESYS eine syntaktische Prüfung aller Objekte der Applikation durch. Dabei wird jedoch kein Code generiert, wie es bei einem Einloggen auf das Zielsystem oder beim Download der Applikation der Fall ist. Der Übersetzungsvorgang wird automatisch immer durchgeführt, wenn Sie mit einem geänderten Programm einloggen wollen. Nach Abschluss der Überprüfung zeigt CODESYS eventuelle Fehlermeldungen oder Warnungen im Meldungsfenster unter der Kategorie Übersetzen an. Wenn das Programm seit dem letzten fehlerfreien Übersetzungsprozess nicht mehr verändert wurde, wird es nicht neu übersetzt. Es erscheint die Meldung „Die Applikation ist aktuell“. Soll die syntaktische Prüfung dennoch wiederholt werden, müssen Sie den Befehl Neu übersetzen verwenden. " }, 
{ "title" : "Befehl: Neu übersetzen ", 
"url" : "_cds_cmd_rebuild.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Erstellen \/ Befehl: Neu übersetzen ", 
"snippet" : "Neu übersetzen Funktion : Der Befehl startet den Übersetzungsprozess für die gerade aktive Applikation, auch wenn sie zuletzt fehlerfrei übersetzt wurde. Aufruf : Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn mit Hilfe des Dialogs Tools → Anpassen aus der Befehlskategorie Übe...", 
"body" : "Neu übersetzen Funktion : Der Befehl startet den Übersetzungsprozess für die gerade aktive Applikation, auch wenn sie zuletzt fehlerfrei übersetzt wurde. Aufruf : Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn mit Hilfe des Dialogs Tools → Anpassen aus der Befehlskategorie Übersetzen in ein Menü einfügen. Für weitere Informationen siehe: Übersetzen" }, 
{ "title" : "Befehl: Laufzeitsystemdateien erzeugen ", 
"url" : "_cds_cmd_generate_runtime_system_files.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Erstellen \/ Befehl: Laufzeitsystemdateien erzeugen ", 
"snippet" : "Laufzeitsystemdateien erzeugen Funktion : Der Befehl generiert aus dem aktuellen Bibliotheksprojekt eine C-Rahmendatei und eine Schnittstellendatei im M4-Dateiformat. Diese Dateien dienen als Basis für die Erstellung einer externen Bibliotheksdatei. Aufruf : Menü Erstellen Voraussetzung : Ein Biblio...", 
"body" : "Laufzeitsystemdateien erzeugen Funktion : Der Befehl generiert aus dem aktuellen Bibliotheksprojekt eine C-Rahmendatei und eine Schnittstellendatei im M4-Dateiformat. Diese Dateien dienen als Basis für die Erstellung einer externen Bibliotheksdatei. Aufruf : Menü Erstellen Voraussetzung : Ein Bibliotheksprojekt ist geöffnet. Der Befehl öffnet den Dialog Laufzeitsystemdateien erzeugen . Ausgabeverzeichnis Verzeichnis, in dem CODESYS die Laufzeitsystem-Dateien anlegt Über Schaltfläche können Sie den Standarddialog zum Browsen im Dateisystem öffnen. Komponentenname Name des Bibliotheksprojekts Welche Dateien möchten Sie erzeugen M4 Interface-Datei : Schnittstellendatei <projectname>Itf.m4 mit Definitionen Sehen Sie dazu auch unten die Tabelle mit den für M4-Export unterstützten IEC-Code-Konstrukten. Beispiel M4-Datei: C Stub-Datei : Rahmendatei für die Ausprogrammierung der Bibliothek in C Beispiel Stub-Datei: Optionen In Bibliotheken enthaltene referenzierte Typen exportieren : Die referenzierten Typen werden mit exportiert Originale Typnamen verwenden : Die Typnamen aus dem Bibliotheksprojekt werden verwendet " }, 
{ "title" : "IEC-Konstrukte, die für den M4-Export unterstützt werden ", 
"url" : "_cds_cmd_generate_runtime_system_files.html#UUID-4294143b-f9fb-2ec4-7378-d8337c13d93c_section-idm234462007759195", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Erstellen \/ Befehl: Laufzeitsystemdateien erzeugen \/ IEC-Konstrukte, die für den M4-Export unterstützt werden ", 
"snippet" : "Alle Typen, die nicht explizit in der Tabelle aufgelistet sind, werden nicht unterstützt. Ihr Verhalten kann sich unbemerkt verändern.. IEC-Konstrukt\/ -Sprachmittel Export in M4-Datei Anmerkung PROGRAM nicht unterstützt FUNCTION_BLOCK struct mit allen Eingabe-\/Ausgabe-\/Ein- und Ausgabe-\/lokalen Vari...", 
"body" : "Alle Typen, die nicht explizit in der Tabelle aufgelistet sind, werden nicht unterstützt. Ihr Verhalten kann sich unbemerkt verändern.. IEC-Konstrukt\/ -Sprachmittel Export in M4-Datei Anmerkung PROGRAM nicht unterstützt FUNCTION_BLOCK struct mit allen Eingabe-\/Ausgabe-\/Ein- und Ausgabe-\/lokalen Variablen Zusätzlich wird eine Methode mit Name <fb_name>__main für die Implementierung des FUNCTION_BLOCK erzeugt FUNCTION STRUCT mit allen Eingabe-\/Ausgabe-\/Ein- und Ausgabe-Variablen und einem DEF_API -Makro INTERFACE struct mit einem einzigen Instanzzeiger METHOD Wie FUNCTION , benannt mit <fb_name>__<method_name> , die den Pointer auf <fb_name> als zusätzlichen Eingang verwendet ACTION gleich wie METHOD TRANSITION Wie METHOD , benannt mit get<transition_name> PROPERTY Methodenpaar mit den Namen, benannt mit get<prop_name> und set<prop_name> GVL nicht unterstützt UNION C- union ENUM #define für jede Enumerationskomponente ALIAS nicht unterstützt STRUCT C- struct Vererbung wird unterstützt. Die Komponenten werden (ohne Struktur) \"flach\" exportiert CONSTANT #define für jede Konstante Konstanten können nicht explizit exportiert werden, aber wenn sie in den anderen Objekten verwendet werden, werden sie automatisch exportiert. Kommentare C-Kommentar Kommentare mit drei Schrägstrichen werden ebenfalls exportiert. Vordefinierte Datentypen (INT, BOOL, REAL, etc.) Entsprechender C-Datentyp derselben Größe Typen, die mit RTS_IEC beginnen Werden nicht separat exportiert, weil sie an anderer Stelle im Laufzeitsystem deklariert sind ANY -Typen struct __SYSTEM.AnyType Alle ANY -Typen (beispielsweise ANY_INT , ANY_BIT , etc.) werden in den C-Typ struct __SYSTEM.AnyType exportiert Arrays C-Array mit fester Größe Zufällige Anzahl von Dimensionen Arraybereiche können negativ sein ARRAY[*] Ein Pointer und eine Größe Strings C-Array von Zeichen mit fester Größe " }, 
{ "title" : "Befehl: Überprüfe alle Poolobjekte ", 
"url" : "_cds_cmd_check_all_pool_objects.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Erstellen \/ Befehl: Überprüfe alle Poolobjekte ", 
"snippet" : "Überprüfe alle Poolobjekte Symbol: Tastaturkürzel: F11 Funktion : Der Befehl veranlasst einen Übersetzungslauf, also eine Syntaxprüfung, für alle Poolobjekte, die in der Ansicht POUs verwaltet werden und somit projektweit verfügbar sind. Dies ist in erster Linie bei der Erstellung von Bibliotheken n...", 
"body" : "Überprüfe alle Poolobjekte Symbol: Tastaturkürzel: F11 Funktion : Der Befehl veranlasst einen Übersetzungslauf, also eine Syntaxprüfung, für alle Poolobjekte, die in der Ansicht POUs verwaltet werden und somit projektweit verfügbar sind. Dies ist in erster Linie bei der Erstellung von Bibliotheken nützlich. Aufruf : Menü Erstellen Voraussetzung : Ein Bibliotheksprojekt ist geöffnet. Der Befehl führt nicht zur Codegenerierung. Es wird auch keine Datei mit Informationen zum Übersetzungslauf im Projektverzeichnis angelegt. " }, 
{ "title" : "Befehl: Code für aktive Applikation erzeugen ", 
"url" : "_cds_cmd_generate_code_for_active_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Erstellen \/ Befehl: Code für aktive Applikation erzeugen ", 
"snippet" : "Code für aktive Applikation erzeugen Funktion : Der Befehl generiert den Code für die Applikation eines Bibliotheksprojekts. Aufruf : Menü Erstellen Voraussetzung : Das Projekt enthält eine Applikation. Ein Bibliotheksprojekt ist geöffnet. Das Bibliotheksprojekt enthält eine Applikation. Bei der Cod...", 
"body" : "Code für aktive Applikation erzeugen Funktion : Der Befehl generiert den Code für die Applikation eines Bibliotheksprojekts. Aufruf : Menü Erstellen Voraussetzung : Das Projekt enthält eine Applikation. Ein Bibliotheksprojekt ist geöffnet. Das Bibliotheksprojekt enthält eine Applikation. Bei der Codeerzeugung mit diesem Befehl wird wie beim Laden der Applikation auf die Steuerung Code erzeugt; der Code wird jedoch nicht auf die Steuerung übertragen. Dabei erfolgen weitere Prüfungen des Quellcodes. Somit können Sie den Code auf Fehler prüfen, die vom Compiler nicht erkannt werden und diese korrigieren, bevor er im Onlinebetrieb verwendet wird. Für weitere Informationen siehe: Laufzeitsystemdateien erzeugen" }, 
{ "title" : "Befehl: Überprüfe alle Applikationsobjekte ", 
"url" : "_cds_cmd_check_all_application_objects.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Erstellen \/ Befehl: Überprüfe alle Applikationsobjekte ", 
"snippet" : "Überprüfe alle Applikationsobjekte Funktion : Der Befehl veranlasst einen Übersetzungslauf für alle Objekte der aktiven Applikation, also auch für die POUs, die von der Applikation nicht verwendet werden. Nach dem Übersetzungslauf werden im Meldungsfenster auch die Fehler angezeigt, die in den nicht...", 
"body" : "Überprüfe alle Applikationsobjekte Funktion : Der Befehl veranlasst einen Übersetzungslauf für alle Objekte der aktiven Applikation, also auch für die POUs, die von der Applikation nicht verwendet werden. Nach dem Übersetzungslauf werden im Meldungsfenster auch die Fehler angezeigt, die in den nicht verwendeten Objekten gefunden wurden. Aufruf : Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn mit Hilfe des Dialogs Tools → Anpassen aus der Befehlskategorie Übersetzen in ein Menü einfügen. Voraussetzung : Eine Applikation des geöffneten Projekts ist aktiv. Der Befehl führt nicht zur Codegenerierung. Es wird auch keine Datei mit Informationen zum Übersetzungslauf im Projektverzeichnis angelegt. " }, 
{ "title" : "Befehl: Bibliothekskompatibilität prüfen ", 
"url" : "_cds_cmd_check_library_compatibility.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Erstellen \/ Befehl: Bibliothekskompatibilität prüfen ", 
"snippet" : "Bibliothekskompatibilität prüfen Funktion : Der Befehl startet eine Prüfung ob das aktuell geöffnete Bibliotheksprojekt zur zuletzt installierten Version dieser Bibliothek (nächstkleinere Versionsnummer) kompatibel ist. Aufruf : Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn m...", 
"body" : "Bibliothekskompatibilität prüfen Funktion : Der Befehl startet eine Prüfung ob das aktuell geöffnete Bibliotheksprojekt zur zuletzt installierten Version dieser Bibliothek (nächstkleinere Versionsnummer) kompatibel ist. Aufruf : Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn mit Hilfe des Dialogs Tools → Anpassen aus der Befehlskategorie Übersetzen in ein Menü einfügen. Voraussetzung : Ein Bibliotheksprojekt ist geöffnet. Die Prüfung achtet auf Unterschiede in den implementierten Schnittstellen (Interfaces) einer Methode. Nach der Prüfung erscheinen somit in folgenden Fällen Fehlermeldungen im Meldungsfenster: Hinzufügen oder Entfernen von Eingänge oder Ausgängen von Funktionsbausteinen, Funktionen oder Methoden Verändern des Datentyps von Ein- oder Ausgängen Ändern der implementierten Schnittstellen (Interfaces) einer Methode Für weitere Informationen siehe: Informationen für Bibliotheksentwickler" }, 
{ "title" : "Befehl: Disassemblierungsdatei erzeugen ", 
"url" : "_cds_cmd_generate_disassembly_file.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Erstellen \/ Befehl: Disassemblierungsdatei erzeugen ", 
"snippet" : "Disassemblierungsdatei erzeugen Funktion : Der Befehl erzeugt aus dem aktuellen Projekt eine Disassemblierungsdatei <project name>.asm und legt Sie im Dateiverzeichnis im Projektordner ab. Aufruf : Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn mit Hilfe des Dialogs Tools → An...", 
"body" : "Disassemblierungsdatei erzeugen Funktion : Der Befehl erzeugt aus dem aktuellen Projekt eine Disassemblierungsdatei <project name>.asm und legt Sie im Dateiverzeichnis im Projektordner ab. Aufruf : Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn mit Hilfe des Dialogs Tools → Anpassen aus der Befehlskategorie Übersetzen in ein Menü einfügen. " }, 
{ "title" : "Online ", 
"url" : "_cds_f_commands_online.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: Aktive Applikation wählen ", 
"url" : "_cds_cmd_active_app_selector.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Aktive Applikation wählen ", 
"snippet" : "Aktive Applikation wählen Symbol: Der Befehl ist realisiert als Auswahlliste, mit der Sie eine Applikation aktiv setzen können. Die Auswahlliste befindet sich standardmäßig in der Symbolleiste. Funktion : Die Auswahlliste zeigt die aktuell aktive Applikation mit deren Gerätepfad an. Aufruf : Die Aus...", 
"body" : "Aktive Applikation wählen Symbol: Der Befehl ist realisiert als Auswahlliste, mit der Sie eine Applikation aktiv setzen können. Die Auswahlliste befindet sich standardmäßig in der Symbolleiste. Funktion : Die Auswahlliste zeigt die aktuell aktive Applikation mit deren Gerätepfad an. Aufruf : Die Auswahlliste enthält alle Applikationen, die unter der Ansicht Geräte angeordnet sind. Mit Klick auf einen Eintrag in der Auswahlliste setzen Sie die ausgewählte Applikation aktiv. Voraussetzung : Das Projekt verfügt über mehrere Applikationen. Beispiel Wenn Sie Befehle des Menüs Erstellen oder Online aufrufen, dann wirken diese Befehle auf die aktive Applikation. Diese wird in der Auswahlliste angezeigt und im Gerätebaum fett dargestellt. Das betrifft vor allem die Befehle Erstellen → Code erzeugen und Online → Einloggen . Sie haben auf diese Befehle auch Zugriff über die Befehlsicons der Symbolleiste, in der sich auch die Auswahlliste befindet. Bei Aufruf der Befehlsicons wirken diese ebenfalls auf die aktive Applikation. Wenn Sie allerdings im Gerätebaum über das Kontextmenü eines Geräteobjekte einen Befehle aufrufen, dann wirkt der Befehle auf das zugehörige Objekt. So können Sie beispielsweise mit Aufruf von Icon eine Verbindung zu einer Applikation auf dem Gerät herstellen, die nicht aktiv ist. " }, 
{ "title" : "Befehl: Einloggen ", 
"url" : "_cds_cmd_login.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Einloggen ", 
"snippet" : "Einloggen Symbol: Tastaturkürzel: Alt + F8 Funktion : Der Befehl verbindet die Applikation mit dem Zielsystem (Steuerung oder simuliertes Gerät) und stellt somit den Onlinebetrieb her. Aufruf : Menü Online , Kontextmenü des Objekts Applikation Voraussetzung : Die Applikation ist fehlerfrei und die K...", 
"body" : "Einloggen Symbol: Tastaturkürzel: Alt + F8 Funktion : Der Befehl verbindet die Applikation mit dem Zielsystem (Steuerung oder simuliertes Gerät) und stellt somit den Onlinebetrieb her. Aufruf : Menü Online , Kontextmenü des Objekts Applikation Voraussetzung : Die Applikation ist fehlerfrei und die Kommunikationseinstellungen sind konfiguriert. Wenn die Kommunikationseinstellungen nicht korrekt sind, erscheint ein Dialog. Sie können dann direkt zu den Kommunikationseinstellungen der Steuerung wechseln. Wenn Sie den Befehl Einloggen aus dem Online-Menü aufrufen, wird die gerade aktive Applikation mit dem Zielsystem verbunden. Wenn Sie den Befehl aus dem Kontextmenü aufrufen und im Gerätebaum eine Applikation selektiert haben, wird mit dieser Applikation eingeloggt, auch wenn sie nicht als „aktive Applikation“ gesetzt ist. Wenn auf dem Zielgerät eine Onlinebenutzerverwaltung eingerichtet ist, werden Sie beim Einloggen aufgefordert, die Benutzerdaten anzugeben. Dazu erscheint der Dialog Geräte-Benutzeranmeldung . Zugriffsmöglichkeiten auf Steuerung prüfen Steuerungen dürfen unter keinen Umständen vom Internet oder nicht vertrauenswürdigen Netzen aus zugreifbar sein! Im Speziellen dürfen die Programmier-Ports der Steuerung unter keinen Umständen ungeschützt aus dem Internet zugreifbar sein (meist UDP-Ports 1740..1743 und TCP-Ports 1217 + 11740 oder die steuerungsspezifischen Ports)! Wenn ein Zugriff aus dem Internet dennoch ermöglicht werden muss, dann muss zwingend ein sicheres Verfahren gewählt werden, um sich mit der Steuerung zu verbinden (z.B. VPN). Für weitere Informationen siehe: Gerätebenutzerverwaltung handhabenWenn unter einer Steuerung eine Sicherheitssteuerung eingehängt ist, kann dieser Befehl die Kommunikationsverbindungen temporär unterbrechen! Betroffen sind Verbindungen der Sicherheitssteuerung zu anderen Sicherheitssteuerungen (über Safety-Netzwerkvariablen), zu Feldgeräten und zum Entwicklungssystem. Die sicheren Feldgeräte oder auch andere Sicherheitssteuerungen können als Reaktion in den sicheren Zustand gehen. Die Verbindung zum Entwicklungssystem ist nur dann betroffen, wenn die Sicherheitssteuerung über den Feldbus an die Hauptsteuerung angeschlossen ist. Weitere Informationen finden Sie im Kapitel „Untergeordnete Sicherheitssteuerungen“. Mögliche Situationen beim Einloggen Auf der Steuerung liegt eine neuere Version der Gerätebeschreibung vor als im Projekt. Sie erhalten eine Warnung mit der Möglichkeit, den Vorgang abzubrechen. Die Applikation existiert noch nicht auf der Steuerung: Sie werden aufgefordert, den Download zu bestätigen. Die Applikation liegt bereits auf der Steuerung und wurde seit dem letzten Laden nicht verändert. Das Einloggen erfolgt ohne weitere Interaktion mit Ihnen. Die Applikation liegt bereits auf der Steuerung, wurde aber seit dem letzten Download verändert. Sie werden aufgefordert, eine der folgenden Optionen zu wählen: Mit Online-Change einloggen (beachten Sie zum Online-Change die Hinweise auf der Hilfeseite „Befehl Online-Change „) Mit Download einloggen Ohne Änderung einloggen An dieser Stelle erhalten Sie außerdem die Möglichkeit, die Bootapplikation auf der Steuerung zu aktualisieren. Eine unbekannte Version der Applikation liegt bereits auf der Steuerung. Sie werden gefragt, ob CODESYS diese ersetzen soll. Eine Version der Applikation liegt bereits auf der Steuerung und  läuft. Sie werden gefragt, ob CODESYS trotzdem einloggen und die gerade laufende Applikation überschreiben soll. Die Applikation auf der Steuerung hält gerade an einem Haltepunkt. Sie haben ausgeloggt und das Programm geändert: CODESYS warnt Sie, dass in Falle eines Online-Change oder Downloads die SPS komplett angehalten wird. Dies geschieht auch, wenn mehrere Tasks vorhanden sind und nur eine von dem Haltepunkt betroffen ist. Mit der Schaltfläche Details in den oben beschriebenen Dialogen öffnen Sie den Dialog Applikationsinformation . Ab der CODESYS -Version V3.5 SP17 kann auf einer Applikation einer Steuerung immer nur genau eine CODESYS -Instanz eingeloggt sein. Wenn sich eine zweite CODESYS -Instanz auf dieselbe Applikation derselben Steuerung einloggen möchte, erscheint eine Fehlermeldung. Für weitere Informationen siehe: Online-Change und Untergeordnete Sicherheitssteuerung" }, 
{ "title" : "Dialog: Applikationsinformation (Details) ", 
"url" : "_cds_cmd_login.html#UUID-51a355d9-96c3-eb5c-5f83-080a64d34b57_id_f7339dad366f5b2ec0a8640e002c9fcf_id_afdfe799069d6517c0a8640e01ead196", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Einloggen \/ Dialog: Applikationsinformation (Details) ", 
"snippet" : "Der Dialog zeigt Informationen über die im Programmiersystem geänderte Applikation, im Vergleich zu ihrer Vorgängerversion, die gerade auf der Steuerung liegt. Es gibt zwei Registerkarten: Applikationsinformation : Die Applikationseigenschaften der Applikation im IDE (Integrated Development Environm...", 
"body" : "Der Dialog zeigt Informationen über die im Programmiersystem geänderte Applikation, im Vergleich zu ihrer Vorgängerversion, die gerade auf der Steuerung liegt. Es gibt zwei Registerkarten: Applikationsinformation : Die Applikationseigenschaften der Applikation im IDE (Integrated Development Environment = Programmiersystem) werden denen der Applikation in der SPS gegenüber gestellt: Projektname, Letzte Änderung, IDE-Version, Autor, Beschreibung. Zusätzlich zeigt CODESYS die Objekte an, die sich seit dem letzten Download geändert haben. Applikationsinhalt : Wenn die Option Download Applikation Info aktiviert ist, kann der Inhalt der Applikation auf der SPS (2) mit dem Inhalt der Applikation im Programmiersystem (1) verglichen werden. Die Option Download Applikation Info finden Sie in den Applikationseigenschaften, Kategorie Übersetzen . Wenn der Code im Programmiersystem nicht aktuell ist, erscheint links unten der Befehl Applikation nicht aktuell. Code jetzt neu erzeugen? (3). Führen Sie diesen Befehl aus, um den Quellcode in der Applikation zu aktualisieren. Diese detaillierte Information hilft Ihnen, die Auswirkungen des Einloggens in der aktuellen Situation besser einzuschätzen und eine Entscheidung bezüglich des Downloads der neuen Applikation zu treffen. Der Vergleich wird auch im Geräteeditor in der Registerkarte Applikationen über die Schaltfläche Inhalt dargestellt. " }, 
{ "title" : "Unbekannte Applikationen auf der SPS ", 
"url" : "_cds_cmd_login.html#UUID-51a355d9-96c3-eb5c-5f83-080a64d34b57_id_f7339dad366f5b2ec0a8640e002c9fcf_id_67cd7a3e1e8ebbd7c0a8640e00b8388e", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Einloggen \/ Unbekannte Applikationen auf der SPS ", 
"snippet" : "Wenn bereits eine oder mehrere Applikationen auf der Steuerung liegen, die nicht im Projekt vorhanden sind, öffnet CODESYS einen Dialog mit einer Liste dieser Applikationen. Sie können darin festlegen, ob und welche Applikation vor dem Laden der aktuellen Applikation von der SPS gelöscht werden soll...", 
"body" : "Wenn bereits eine oder mehrere Applikationen auf der Steuerung liegen, die nicht im Projekt vorhanden sind, öffnet CODESYS einen Dialog mit einer Liste dieser Applikationen. Sie können darin festlegen, ob und welche Applikation vor dem Laden der aktuellen Applikation von der SPS gelöscht werden sollen. Dies betrifft auch Kindapplikationen, die auf der Steuerung sind, jedoch zwischenzeitlich im Projekt gelöscht wurden. " }, 
{ "title" : "Übersetzen des Projekts vor Einloggen ", 
"url" : "_cds_cmd_login.html#UUID-51a355d9-96c3-eb5c-5f83-080a64d34b57_id_f7339dad366f5b2ec0a8640e002c9fcf_id_e30afcf16bc19572c0a8640e014e4835", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Einloggen \/ Übersetzen des Projekts vor Einloggen ", 
"snippet" : "Wenn ein Applikationsprojekt seit seiner letzten Änderung noch nicht kompiliert wurde, übersetzt CODESYS das Projekt vor dem Einloggen. Dieser Vorgang entspricht dem Befehl Code erzeugen im ausgeloggten Zustand. Wenn während des Übersetzens Fehler auftreten, erscheint ein Meldungsdialog. Die Fehler ...", 
"body" : "Wenn ein Applikationsprojekt seit seiner letzten Änderung noch nicht kompiliert wurde, übersetzt CODESYS das Projekt vor dem Einloggen. Dieser Vorgang entspricht dem Befehl Code erzeugen im ausgeloggten Zustand. Wenn während des Übersetzens Fehler auftreten, erscheint ein Meldungsdialog. Die Fehler werden im Meldungsfenster in Kategorie Übersetzen ausgegeben. Sie können dann entscheiden, ob Sie einloggen wollen, ohne das Programm auf die Steuerung zu laden. " }, 
{ "title" : "Fehler beim Login ", 
"url" : "_cds_cmd_login.html#UUID-51a355d9-96c3-eb5c-5f83-080a64d34b57_id_f7339dad366f5b2ec0a8640e002c9fcf_id_dbcc3ada1e8ebbd8c0a8640e015a729c", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Einloggen \/ Fehler beim Login ", 
"snippet" : "Wenn während des Einloggens auf die Steuerung ein Fehler auftritt, bricht CODESYS den Ladevorgang mit einer Fehlermeldung ab. Der Fehlerdialog bietet Ihnen die Möglichkeit, die Fehlerdetails anzuzeigen. Ist ein Ausnahme aufgetreten und der Text *SOURCEPOSITION* in der Logmeldung enthalten, können Si...", 
"body" : "Wenn während des Einloggens auf die Steuerung ein Fehler auftritt, bricht CODESYS den Ladevorgang mit einer Fehlermeldung ab. Der Fehlerdialog bietet Ihnen die Möglichkeit, die Fehlerdetails anzuzeigen. Ist ein Ausnahme aufgetreten und der Text *SOURCEPOSITION* in der Logmeldung enthalten, können Sie mit dem Befehl Im Editor anzeigen die betroffene Funktion im Editor anzeigen. Dabei springt der Cursor an die fehlerverursachende Zeile. " }, 
{ "title" : "Ausgabe von Informationen zum Ladevorgang ", 
"url" : "_cds_cmd_login.html#UUID-51a355d9-96c3-eb5c-5f83-080a64d34b57_id_f7339dad366f5b2ec0a8640e002c9fcf_id_4ba66a1395c4915dc0a8640e0199319f", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Einloggen \/ Ausgabe von Informationen zum Ladevorgang ", 
"snippet" : "Wenn CODESYS das Projekt beim Einloggen auf die Steuerung lädt, werden folgende Informationen im Meldungsfenster ausgegeben: Generierte Codegröße Größe der globalen Daten Resultierender Speicherbedarf auf der Steuerung Eine Liste der betroffenen Bausteine (bei Online-Change) Im Onlinebetrieb können ...", 
"body" : "Wenn CODESYS das Projekt beim Einloggen auf die Steuerung lädt, werden folgende Informationen im Meldungsfenster ausgegeben: Generierte Codegröße Größe der globalen Daten Resultierender Speicherbedarf auf der Steuerung Eine Liste der betroffenen Bausteine (bei Online-Change) Im Onlinebetrieb können Sie die Einstellungen von Geräten oder Modulen nicht verändern. Um Geräteparameter zu ändern, müssen Sie die Applikation ausloggen. Abhängig vom Bussystem kann es jedoch einige spezielle Parameter geben, die Sie auch im Onlinebetrieb verändern können. Die Konfiguration der Ansicht speichert CODESYS im Online- und Offlinebetrieb separat voneinander. Zusätzlich werden Ansichten, welche in einer Betriebsart nicht nutzbar sind, geschlossen. Aus diesem Grund kann sich die Ansicht beim Einloggen automatisch ändern. " }, 
{ "title" : "Befehl: Ausloggen ", 
"url" : "_cds_cmd_logoff.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Ausloggen ", 
"snippet" : "Ausloggen Symbol: Tastaturkürzel: Strg + F8 Funktion : Der Befehl trennt die Applikation vom Zielsystem (Steuerung oder simuliertes Gerät) und kehrt somit zum Offlinebetrieb zurück. Aufruf : Menü Online , Kontextmenü des Objekts Applikation...", 
"body" : "Ausloggen Symbol: Tastaturkürzel: Strg + F8 Funktion : Der Befehl trennt die Applikation vom Zielsystem (Steuerung oder simuliertes Gerät) und kehrt somit zum Offlinebetrieb zurück. Aufruf : Menü Online , Kontextmenü des Objekts Applikation " }, 
{ "title" : "Befehl: Bootapplikation erzeugen ", 
"url" : "_cds_cmd_create_boot_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Bootapplikation erzeugen ", 
"snippet" : "Bootapplikation erzeugen Funktion : Der Befehl erzeugt eine Bootapplikation. Aufruf : Menü Online Eine Bootapplikation ist die Applikation, die automatisch gestartet wird, wenn die Steuerung eingeschaltet oder gestartet wird. Im Offlinebetrieb können Sie die Bootapplikation in ein beliebiges Verzeic...", 
"body" : "Bootapplikation erzeugen Funktion : Der Befehl erzeugt eine Bootapplikation. Aufruf : Menü Online Eine Bootapplikation ist die Applikation, die automatisch gestartet wird, wenn die Steuerung eingeschaltet oder gestartet wird. Im Offlinebetrieb können Sie die Bootapplikation in ein beliebiges Verzeichnis speichern. Im Onlinebetrieb speichert CODESYS die Bootapplikation auf dem Zielgerät. Der Dateiname ist <Applikationsname>.app . Für weitere Informationen siehe: Erzeugen einer Bootapplikation" }, 
{ "title" : "Befehl: Laden ", 
"url" : "_cds_cmd_load.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Laden ", 
"snippet" : "Laden Funktion : Der Befehl bewirkt ein Übersetzen der aktiven Applikation mit anschließendem Download auf die Steuerung. Aufruf : Menü Online Voraussetzung : Die Applikation ist im Onlinebetrieb. Mit dem Befehl führt CODESYS eine Syntax-Prüfung durch und erzeugt den Applikationscode. Dieser Code wi...", 
"body" : "Laden Funktion : Der Befehl bewirkt ein Übersetzen der aktiven Applikation mit anschließendem Download auf die Steuerung. Aufruf : Menü Online Voraussetzung : Die Applikation ist im Onlinebetrieb. Mit dem Befehl führt CODESYS eine Syntax-Prüfung durch und erzeugt den Applikationscode. Dieser Code wird auf die Steuerung geladen. Weiterhin erzeugt CODESYS im Projektverzeichnis das Übersetzungsprotokoll <project name>.<device name>.<application ID>.compileinfo . Beim Laden werden alle Variablen mit Ausnahme von persistenten Variablen neu initialisiert. Wenn unter einer Steuerung eine Sicherheitssteuerung eingehängt ist, kann dieser Befehl die Kommunikationsverbindungen temporär unterbrechen! Betroffen sind Verbindungen der Sicherheitssteuerung zu anderen Sicherheitssteuerungen (über Safety-Netzwerkvariablen), zu Feldgeräten und zum Entwicklungssystem. Die sicheren Feldgeräte oder auch andere Sicherheitssteuerungen können als Reaktion in den sicheren Zustand gehen. Die Verbindung zum Entwicklungssystem ist nur dann betroffen, wenn die Sicherheitssteuerung über den Feldbus an die Hauptsteuerung angeschlossen ist. Für weitere Informationen siehe: Untergeordnete SicherheitssteuerungDie Beschreibung des Befehls Einloggen erläutert die möglichen Situationen beim Einloggen und Laden. Wenn Sie versuchen, eine Applikation zu laden, während die gleiche Version dieser Applikation bereits auf der Steuerung liegt, erscheint die Meldung: „Programm ist unverändert. Applikation wurde nicht geladen“. CODESYS lädt die Applikation nicht auf die SPS. Beim Laden erscheint im Meldungsfenster in der Meldungskategorie Übersetzen ein Protokoll der ablaufenden Aktionen (Erzeugen des Codes, Durchführen der Initialisierungen etc.). Weiterhin werden Informationen zu den Speicherbereichen, zur Größe des Codes, der globalen Daten und des allozierten Speichers ausgegeben. Zum Zweck der Übersichtlichkeit werden im Gegensatz zum Online-Change die geänderten Bausteine nicht mehr aufgelistet. " }, 
{ "title" : "Befehl: Online-Change ", 
"url" : "_cds_cmd_online_change.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Online-Change ", 
"snippet" : "Online-Change Funktion : Der Befehl dient dem Anstoßen eines Online-Change auf die gerade aktive Applikation. Dabei lädt CODESYS nur die geänderten Teile einer bereits auf der Steuerung laufenden Applikation neu in die Steuerung. Aufruf : Menü Online , Kontextmenü des Objekts Applikation Voraussetzu...", 
"body" : "Online-Change Funktion : Der Befehl dient dem Anstoßen eines Online-Change auf die gerade aktive Applikation. Dabei lädt CODESYS nur die geänderten Teile einer bereits auf der Steuerung laufenden Applikation neu in die Steuerung. Aufruf : Menü Online , Kontextmenü des Objekts Applikation Voraussetzung : Die Applikation ist im Onlinebetrieb. Der Befehl ist im Kontextmenü verfügbar, wenn eine Applikation im Gerätebaum selektiert ist. Somit können Sie einen Online-Change gezielt auf eine Applikation ausführen, auch wenn die Applikation aktuell nicht die „aktive“ ist. Ein Online-Change verändert das laufende Applikationsprogramm und bewirkt keinen Neustart. Stellen Sie sicher, dass der neue Applikationscode dennoch das gewünschte Verhalten des gesteuerten Systems bewirkt. Abhängig von der gesteuerten Anlage könnten Schäden an der Anlage und Werkstücken entstehen oder Gesundheit und Leben von Personen gefährdet sein. Wenn ein Online-Change durchgeführt wird, werden die applikationsspezifischen Initialisierungen (zum Beispiel Referenzfahrt) nicht ausgeführt, weil die Maschine ihren Status beibehält. Aus diesem Grund hat der neue Programmcode möglicherweise nicht den gewünschten Effekt. Variablen auf Pointer behalten ihren Wert aus dem letzten Zyklus. Wenn ein Pointer auf eine Variable zeigt, die durch den Online-Change ihre Größe verändert hat, wird der Wert nicht mehr korrekt geliefert. Stellen Sie sicher, dass die Pointer in jedem Zyklus erneut zugewiesen werden. Eine „Kindapplikation“ wird von der Steuerung entfernt, wenn ein Online-Change erfolgt, nachdem Sie die „Vaterapplikation“ geändert haben. Kein Initialisierungscode bei schnellem Online-Change Seit Compilerversion >= 3.5.0.0 wird für kleine Änderungen ein „schneller Online-Change“ durchgeführt. Bei schnellem Online-Change wird nur der jeweils geänderte Baustein übersetzt und nachgeladen. Insbesondere wird kein Initialisierungscode erzeugt. Bei Variablen mit dem Attribut init_on_onlchange führt das ebenfalls dazu, dass kein Initialisierungscode erzeugt wird. In den üblichen Szenarien wird das keine Auswirkungen haben: Das Attribut wird üblicherweise verwendet, um Variablen mit Adressen zu initialisieren. Beim schnellen Online-Change kommt es jedoch nicht dazu, dass eine Variable ihre Adresse ändert. Um dennoch die Wirkung des Attributs init_on_onlchange auf den gesamten Applikationscode sicherzustellen, können Sie generell für die Applikation den schnellen Online-Change mit Hilfe der Compiler-Define no_fast_online_change ausschalten. Selektieren Sie dafür im Gerätebaum Ihr Applikationsobjekt und wählen Sie den Kontextbefehl Eigenschaften . Fügen Sie dort unter der Registerkarte Build die Compiler-Define no_fast_online_change hinzu. Für weitere Informationen siehe: BuildBeim Laden listet CODESYS im Meldungsfenster in der Kategorie Übersetzen auch die geänderten Schnittstellen, betroffenen Variablen und alle Bausteine, für die neuer Code generiert wurde. Wenn sich Speicherorte ändern, wird in einer Dialogbox auf mögliche Probleme in Zusammenhang mit Pointern hingewiesen. In der Ansicht Speicherreserve für Online-Change können für Funktionsbausteine eines Projekts Speicherreserven für den Online-Change konfiguriert werden, sodass bei Änderungen eines Funktionsbausteins beim Online-Change Instanzvariablen im Speicher nicht verschoben werden müssen . Für weitere Informationen siehe: Einstellungen Speicherreserve für Online-Change" }, 
{ "title" : "Was verhindert einen Online-Change? ", 
"url" : "_cds_cmd_online_change.html#UUID-cdc45270-a748-554a-175e-be948d7ae781_id_ef254ea5d484e8d4c0a8640e019da19e_id_6e316fe7ee4c1585c0a86463711858ab", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Online-Change \/ Was verhindert einen Online-Change? ", 
"snippet" : "Es gibt Aktionen in CODESYS , nach denen ein Online-Change auf eine Steuerung nicht mehr möglich ist. Danach ist immer ein vollständiges Neukompilieren der Applikation erforderlich. Ein typischer Fall ist der Befehl Alles bereinigen - Achtung! , der die beim letzten Download abgelegte Übersetzungsin...", 
"body" : "Es gibt Aktionen in CODESYS , nach denen ein Online-Change auf eine Steuerung nicht mehr möglich ist. Danach ist immer ein vollständiges Neukompilieren der Applikation erforderlich. Ein typischer Fall ist der Befehl Alles bereinigen - Achtung! , der die beim letzten Download abgelegte Übersetzungsinformation löscht. Solche Aktionen erzeugen jedoch typischerweise eine Warnung und müssen von Ihnen quittiert werden. Aber es gibt auch „normale“ Editieraktionen, die dazu führen, dass beim nächsten Einloggen ein Online-Change nicht mehr möglich ist. Achten Sie deshalb beim Editieren in den Programmbausteinen auf folgendes Symbol in der Statusleiste: . Wenn dieses Symbol eine rote Farbe annimmt: , kann danach nur noch ein vollständiger Download auf die Steuerung durchgeführt werden. Mit einem Doppelklick auf das Symbol öffnet sich der Dialog Applikationsinformation mit einer Liste der Unterschiede zum letzten Download. Im Dialog finden Sie auch Information dazu, welche der Änderungen einen Online-Change verhindern. Für weitere Informationen siehe: Befehl: Einloggen Aktionen und Änderungen in verschiedenen Bereichen einer Applikation, die einen Online-Change verhindern: Checkfunktionen Aktivieren oder Entfernen einer Checkfunktion ( CheckBounds , CheckRange , CheckDiv usw.) Änderung in der Schnittstelle einer Checkfunktion (auch das Einfügen und Löschen von lokalen Variablen) Taskkonfiguration Änderung in den Konfigurationseinstellungen Projekteinstellungen Änderung der Compile-Optionen in der Sektion Einstellungen (Unicode, Konstanten ersetzen, Logging in Haltepunkten) Änderung in den Compiler-Defines Applikationseigenschaften Änderung der Zielsystem-Speichereinstellungen (Registerkarte Build ) Bausteineigenschaften Änderung der Option Externe Implementierung (Registerkarte Build ) Tasklokale globale Variablenliste Alle Änderungen Funktionsbaustein Ändern des Basisbausteins eines Funktionsbausteins ( EXTENDS FBbase ), auch das Einfügen oder Löschen eines solchen Basisbausteins Änderung in der Schnittstellenliste ( IMPLEMENTS ITF ) Ausnahme: Hinzufügen einer neuen Schnittstelle am Ende der Liste Datentyp Änderung des Datentyps einer Variable von einem benutzerdefinierten Datentyp zu einem anderen benutzerdefinierten Datentyp (beispielsweise von TON zu TOF ) Änderung des Datentyps von einem benutzerdefinierten Datentyp zu einem Basisdatentyp (beispielsweise von TON zu TIME ) Hinweis: Als Workaround sollten Sie gleichzeitig mit dem Datentyp immer auch den Namen der Variable ändern. Dann wird die Variable als neue Variable initialisiert und die alte entfernt. Ein Online-Change ist danach möglich. Alarmkonfiguration Änderung in der Alarmdatenbankkonfiguration Änderung der Anzahl der Latch-Variablen (hat ebenfalls Auswirkungen auf das Speicherformat in der Datenbank) Änderung an der Konfiguration der verteilten Alarme Datenquelle Alle Änderungen in der Konfiguration Gerätekonfiguration Änderung im Gerätebaum (auch durch Befehl Gerät aktualisieren ) Änderung in einer Gerätekonfiguration: Im Standardfall sind Änderungen an Geräteparametern nicht Online-Change-fähig. Ausnahmen können jedoch in der Gerätebeschreibung konfiguriert sein. Hinweis: Das E\/A-Mapping auf Variablen ist über Online-Change möglich. Visualisierung Umschalten der Overlay-Funktion Vor V3.5 SP6: Änderung in der Konfiguration des Trace-Elements Hinweis: Ab V3.5 SP6 gilt: Bei Online-Changes, die Visualisierungen betreffen oder sich auf die Daten der Applikation auswirken (beispielsweise: neue Variable eingefügt), initialisiert sich die Visualisierung vollständig neu. Für die TargetVisu bedeutet dies zum Beispiel, dass sich die Visualisierung schließt und mit der Startseite erneut öffnet. Im Fall der WebvVisu startet die Visualisierung nach einer kurzen Wartezeit ebenfalls neu mit der Startvisualisierung. Einheitenumrechnung Einfügen oder Entfernen von Objekten zur Einheitenumrechnung Trend Änderung der Anzahl Variablen oder der maximalen Anzahl Variablen Änderung der Anzahl Variablen mit Beschreibung oder speziellen Linieneinstellungen Für weitere Informationen siehe: Online-Change ausführen und init_on_onlchange" }, 
{ "title" : "Befehl: Quellcode auf verbundene Steuerung laden ", 
"url" : "_cds_cmd_source_download_connected_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Quellcode auf verbundene Steuerung laden ", 
"snippet" : "Quellcode auf verbundene Steuerung laden Funktion : Der Befehl lädt den Quellcode eines Projektes als Projektarchiv auf die gerade verbundene Steuerung. Aufruf : Menü Online Voraussetzung : Die Applikation ist im Onlinebetrieb....", 
"body" : "Quellcode auf verbundene Steuerung laden Funktion : Der Befehl lädt den Quellcode eines Projektes als Projektarchiv auf die gerade verbundene Steuerung. Aufruf : Menü Online Voraussetzung : Die Applikation ist im Onlinebetrieb. " }, 
{ "title" : "Befehl: Mehrfacher Download ", 
"url" : "_cds_cmd_multiple_download.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Mehrfacher Download ", 
"snippet" : "Mehrfacher Download Funktion : Der Befehl bewirkt die Codegenerierung der im Projekt enthaltenen Applikationen sowie das Laden der Applikationen auf die entsprechenden Steuerungen. Aufruf : Menü Online Der Befehl öffnet einen Dialog mit einer Liste der Applikationen. In diesem Dialog wählen Sie die ...", 
"body" : "Mehrfacher Download Funktion : Der Befehl bewirkt die Codegenerierung der im Projekt enthaltenen Applikationen sowie das Laden der Applikationen auf die entsprechenden Steuerungen. Aufruf : Menü Online Der Befehl öffnet einen Dialog mit einer Liste der Applikationen. In diesem Dialog wählen Sie die Applikationen aus, die geladen werden sollen. Danach führt CODESYS die syntaktische Überprüfung dieser Applikationen durch und erzeugt den zugehörigen Code. Der Code wird anschießend auf die entsprechende Steuerung geladen. Im Projektverzeichnis erzeugt CODESYS für jede ausgewählte Applikation ein Übersetzungsprotokoll mit dem Namen <project name>.<device name>.<application ID>.compileinfo . Wenn unter einer Steuerung eine Sicherheitssteuerung eingehängt ist, kann dieser Befehl die Kommunikationsverbindungen temporär unterbrechen! Betroffen sind Verbindungen der Sicherheitssteuerung zu anderen Sicherheitssteuerungen (über Safety-Netzwerkvariablen), zu Feldgeräten und zum Entwicklungssystem. Die sicheren Feldgeräte oder auch andere Sicherheitssteuerungen können als Reaktion in den sicheren Zustand gehen. Die Verbindung zum Entwicklungssystem ist nur dann betroffen, wenn die Sicherheitssteuerung über den Feldbus an die Hauptsteuerung angeschlossen ist. Für weitere Informationen siehe: Untergeordnete Sicherheitssteuerung" }, 
{ "title" : "Dialog: Mehrfacher Download ", 
"url" : "_cds_cmd_multiple_download.html#UUID-bff2081a-a86c-2315-20e6-97bba25d9cab_id_b6ceffd313d207c0a8640e01914b7b_id_f3237677278f5f78c0a8646372db20c9", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Mehrfacher Download \/ Dialog: Mehrfacher Download ", 
"snippet" : "Bitte wählen Sie die Applikationen aus : Auswahl der Applikationen Dabei werden die Applikationen auch auf unterschiedliche Steuerungen geladen. Nach oben , Nach unten Änderung der Download-Reihenfolge der Applikationen Die Applikationen werden in der Reihenfolge dieser Liste auf die Steuerungen gel...", 
"body" : "Bitte wählen Sie die Applikationen aus : Auswahl der Applikationen Dabei werden die Applikationen auch auf unterschiedliche Steuerungen geladen. Nach oben , Nach unten Änderung der Download-Reihenfolge der Applikationen Die Applikationen werden in der Reihenfolge dieser Liste auf die Steuerungen geladen. Standardmäßig ist diese Liste alphabetisch sortiert. Eltern-Kind-Beziehungen von Applikationen werden dabei berücksichtigt. OK Überprüft alle ausgewählten Applikationen syntaktisch Danach wird für jede Applikation die Kommunikation mit der zugehörigen Steuerung verifiziert, bevor der Download erfolgt. Online-Change Optionen Für den Fall, dass schon eine frühere Version auf der Steuerung existiert und sich diese von der aktuellen Version unterscheidet, stehen Ihnen folgenden Optionen zur Verfügung: Online-Change versuchen. Falls nicht möglich, Download durchführen Standardmäßig aktiviert Wenn ein Online-Change für eine der Applikationen nicht vollzogen werden kann, wird ein Download durchgeführt. Online-Change erzwingen. Falls nicht möglich, Operation abbrechen Wenn ein Online-Change für (zumindest) eine der Applikationen nicht vollzogen werden kann, wird kein Download durchgeführt, sondern es wird abgebrochen; beispielsweise, wenn Sie zuvor den Befehl Alles bereinigen ausgeführt haben. Immer vollen Download durchführen Lädt ohne Berücksichtigung der bereits existierenden Versionen alle Teile der Applikationen auf die Steuerung Für ausgewählte Applikationen, die noch nicht auf der Steuerung existieren, führt CODESYS automatisch einen Download auf die zugehörige Steuerung durch. Zusätzliche Optionen Alle Applikationen auf der Steuerung löschen, die nicht im Projekt enthalten sind : Entsprechende Applikationen werden gelöscht. Nach Download oder Online-Change alle Applikationen starten : Die Applikationen werden nach dem Download\/Online-Change gestartet. Geforcte Variablen nicht freigeben : Wenn sich auf der Steuerung eine Applikation mit geforcten Variablen befindet und die Implementierung dieser Applikation inzwischen geändert wurde, dann wird für diese Applikation kein Download durchgeführt. Im Fenster Mehrfacher Download - Ergebnis erscheint für diese Applikation die Meldung: Fehler: Übersprungen, weil eine oder mehrere Variablen geforct wurden . Beachten Sie, dass Variablen mit dem Schlüsselattribut PERSISTENT RETAIN im Allgemeinen nicht initialisiert werden. Wenn Sie jedoch das Datenlayout verändern, werden die persistenten Variablen automatisch neu initialisiert. Für weitere Informationen siehe: DatenpersistenzNach Abschluss des Downloads erscheint eine Auflistung aller ausgewählten Applikationen in der von Ihnen konfigurierten Reihenfolge ihres Downloads. Zusätzlich erhalten Sie für jede Applikation eine Information zum Erfolg des Downloads im Dialog Mehrfacher Download - Ergebnis : Erstellt : Ein neue Applikation wurde erstellt und auf die Steuerung geladen. Nicht geändert : Die auf der Steuerung bereits bestehende Applikation wurde nicht geändert. Online-Change durchgeführt : Die auf der Steuerung bereits bestehende Applikation wurde durch einen Online-Change geändert. Download durchgeführt : Die auf der Steuerung bereits bestehende Applikation wurde durch eine neu erstellte Applikation ersetzt. Wegen nicht-möglichem Online-Change übersprungen : Für die Applikation konnte kein Online-Change durchgeführt werden, sie wurde nicht verändert. Fehler : Beim Download für diese Applikation ist ein Fehler aufgetreten. Gegebenenfalls werden noch weitere Details angezeigt. Durch den Benutzer abgebrochen : Die Operation wurde durch den Benutzer abgebrochen. Für weitere Informationen siehe: Applikationscode erzeugen" }, 
{ "title" : "Befehl: Reset Kalt ", 
"url" : "_cds_cmd_reset_cold.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Reset Kalt ", 
"snippet" : "Reset Kalt Funktion : Der Befehl bewirkt auf der Steuerung einen Kaltstart der aktiven Applikation. Aufruf : Menü Online Voraussetzung : Die Applikation ist im Onlinebetrieb. Wenn unter einer Steuerung eine Sicherheitssteuerung eingehängt ist, kann dieser Befehl die Kommunikationsverbindungen tempor...", 
"body" : "Reset Kalt Funktion : Der Befehl bewirkt auf der Steuerung einen Kaltstart der aktiven Applikation. Aufruf : Menü Online Voraussetzung : Die Applikation ist im Onlinebetrieb. Wenn unter einer Steuerung eine Sicherheitssteuerung eingehängt ist, kann dieser Befehl die Kommunikationsverbindungen temporär unterbrechen! Betroffen sind Verbindungen der Sicherheitssteuerung zu anderen Sicherheitssteuerungen (über Safety-Netzwerkvariablen), zu Feldgeräten und zum Entwicklungssystem. Die sicheren Feldgeräte oder auch andere Sicherheitssteuerungen können als Reaktion in den sicheren Zustand gehen. Die Verbindung zum Entwicklungssystem ist nur dann betroffen, wenn die Sicherheitssteuerung über den Feldbus an die Hauptsteuerung angeschlossen ist. Für weitere Informationen siehe: Untergeordnete Sicherheitssteuerungen Was bei einem Neustart mit Reset Kalt passiert: Applikationscode bleibt auf der Steuerung erhalten. Variablen werden initialisiert (mit dem Initialisierungswert oder dem Standard-Initialisierungswert 0), die bisherigen Werte gehen verloren. Retain-Variablen werden initialisiert, die bisherigen Werte gehen verloren. Persistente Variablen bleiben mit Werten erhalten. Haltepunkte, die im Code gesetzt waren, bleiben mit Status (beispielsweise aktiviert oder deaktiviert) erhalten. Applikation geht in den Zustand STOP . Sie können übrigens den Befehl auch wählen, während Sie die Applikation debuggen und diese im Zustand HALT AUF BP an einem Haltepunkt steht. Dann wird entweder sofort der Warmstart ausgeführt, oder es werden zunächst die noch fehlenden Anweisungen des aktuellen Zyklus fertig abgearbeitet. Deshalb erscheint ein Meldungsfenster, in dem Sie das weitere Verhalten auswählen können. Das Meldungsfenster erscheint allerdings nur, wenn das Laufzeitsysteme fähig ist, einen Neustart ohne vorheriges Beenden des Zyklus auszuführen. Nach dem Reset können Sie die Applikation wie gewohnt bedienen und beispielsweise mit dem Befehl Debug → Start die Ausführung starten. Für weitere Informationen siehe: Reset Warm und Reset Ursprung" }, 
{ "title" : "Befehl: Reset Warm ", 
"url" : "_cds_cmd_reset_warm.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Reset Warm ", 
"snippet" : "Reset Warm Funktion : Der Befehl bewirkt auf der Steuerung einen Warmstart der aktiven Applikation. Aufruf : Menü Online Voraussetzung : Die Applikation ist im Onlinebetrieb. Wenn unter einer Steuerung eine Sicherheitssteuerung eingehängt ist, kann dieser Befehl die Kommunikationsverbindungen tempor...", 
"body" : "Reset Warm Funktion : Der Befehl bewirkt auf der Steuerung einen Warmstart der aktiven Applikation. Aufruf : Menü Online Voraussetzung : Die Applikation ist im Onlinebetrieb. Wenn unter einer Steuerung eine Sicherheitssteuerung eingehängt ist, kann dieser Befehl die Kommunikationsverbindungen temporär unterbrechen! Betroffen sind Verbindungen der Sicherheitssteuerung zu anderen Sicherheitssteuerungen (über Safety-Netzwerkvariablen), zu Feldgeräten und zum Entwicklungssystem. Die sicheren Feldgeräte oder auch andere Sicherheitssteuerungen können als Reaktion in den sicheren Zustand gehen. Die Verbindung zum Entwicklungssystem ist nur dann betroffen, wenn die Sicherheitssteuerung über den Feldbus an die Hauptsteuerung angeschlossen ist. Für weitere Informationen siehe: Untergeordnete SicherheitssteuerungWas bei einem Neustart mit Reset Warm passiert: Applikationscode bleibt auf der Steuerung geladen. Variablen werden initialisiert (mit dem Initialisierungswert oder dem Standard-Initialisierungswert 0). Retain-Variablen bleiben mit Werten erhalten. Persistente Variablen bleiben mit Werten erhalten. Haltepunkte, die im Code gesetzt waren, bleiben mit Status (beispielsweise aktiviert oder deaktiviert) erhalten. Applikation geht in den Zustand STOP . Sie können übrigens den Befehl auch wählen, während Sie die Applikation debuggen und diese im Zustand HALT AUF BP an einem Haltepunkt steht. Dann wird entweder sofort der Warmstart ausgeführt, oder es werden zunächst die noch fehlenden Anweisungen des aktuellen Zyklus fertig abgearbeitet. Deshalb erscheint ein Meldungsfenster, in dem Sie das weitere Verhalten auswählen können. Das Meldungsfenster erscheint allerdings nur, wenn das Laufzeitsysteme fähig ist, einen Neustart ohne vorheriges Beenden des Zyklus auszuführen. Nach dem Reset können Sie die Applikation wie gewohnt bedienen und beispielsweise mit dem Befehl Debug → Start die Ausführung starten. Für weitere Informationen siehe: Reset der Applikation durchführen und Reset Kalt" }, 
{ "title" : "Befehl: Reset Ursprung ", 
"url" : "_cds_cmd_reset_origin.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Reset Ursprung ", 
"snippet" : "Reset Ursprung Funktion : Der Befehl bewirkt auf der Steuerung das Urlöschen der aktiven Applikation. Aufruf : Menü Online Voraussetzung : Die Applikation ist im Onlinebetrieb. Wenn unter einer Steuerung eine Sicherheitssteuerung eingehängt ist, kann dieser Befehl die Kommunikationsverbindungen daue...", 
"body" : "Reset Ursprung Funktion : Der Befehl bewirkt auf der Steuerung das Urlöschen der aktiven Applikation. Aufruf : Menü Online Voraussetzung : Die Applikation ist im Onlinebetrieb. Wenn unter einer Steuerung eine Sicherheitssteuerung eingehängt ist, kann dieser Befehl die Kommunikationsverbindungen dauerhaft unterbrechen! Betroffen sind Verbindungen der Sicherheitssteuerung zu anderen Sicherheitssteuerungen (über Safety-Netzwerkvariablen), zu Feldgeräten und zum Entwicklungssystem. Die sicheren Feldgeräte oder auch andere Sicherheitssteuerungen können als Reaktion in den sicheren Zustand gehen. Die Verbindung zum Entwicklungssystem ist nur dann betroffen, wenn die Sicherheitssteuerung über den Feldbus an die Hauptsteuerung angeschlossen ist. Für weitere Informationen siehe: Untergeordnete SicherheitssteuerungWas bei einem Neustart mit Reset Ursprung passiert: Applikationscode wird gelöscht, die Applikation hat folglich keinen Zustand. Variablen werden gelöscht, die Werte gehen verloren. Retain-Variablen werden gelöscht, die Werte gehen verloren. Persistente Variablen werden gelöscht, die Werte gehen verloren. Haltepunkte, die im Code gesetzt waren, gehen verloren. Für weitere Informationen siehe: Daten mit persistenten Variablen erhalten" }, 
{ "title" : "Befehl: Reset Ursprung Gerät ", 
"url" : "_cds_cmd_reset_origin_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Reset Ursprung Gerät ", 
"snippet" : "Reset Ursprung Gerät Funktion : Der Befehl öffnet einen Dialog, um das Gerät in den Ursprungszustand (Lieferzustand) zurückzusetzen. Dabei werden alle Applikationen, Bootapplikationen und remanente Variablen auf dem Gerät gelöscht. Je nach Version des Geräts kann in diesem Dialog eine Auswahl der zu...", 
"body" : "Reset Ursprung Gerät Funktion : Der Befehl öffnet einen Dialog, um das Gerät in den Ursprungszustand (Lieferzustand) zurückzusetzen. Dabei werden alle Applikationen, Bootapplikationen und remanente Variablen auf dem Gerät gelöscht. Je nach Version des Geräts kann in diesem Dialog eine Auswahl der zu löschenden Elemente getroffen werden. Wenn diese Elemente im Dialog abgewählt werden, werden sie beim Zurücksetzen nicht mit gelöscht und verbleiben auf der Steuerung. Standardmäßig sind alle Elemente ausgewählt und es wird alles gelöscht. Elemente die nicht zur Auswahl stehen werden in der Regel ebenfalls mit gelöscht. Aufruf : Kontextmenü eines programmierbaren Geräts im Gerätebaum Wenn unter einer Steuerung eine Sicherheitssteuerung eingehängt ist, kann dieser Befehl die Kommunikationsverbindungen dauerhaft unterbrechen! Betroffen sind Verbindungen der Sicherheitssteuerung zu anderen Sicherheitssteuerungen (über Safety-Netzwerkvariablen), zu Feldgeräten und zum Entwicklungssystem. Die sicheren Feldgeräte oder auch andere Sicherheitssteuerungen können als Reaktion in den sicheren Zustand gehen. Die Verbindung zum Entwicklungssystem ist nur dann betroffen, wenn die Sicherheitssteuerung über den Feldbus an die Hauptsteuerung angeschlossen ist. Für weitere Informationen siehe: Untergeordnete SicherheitssteuerungWas bei einem Neustart mit Reset Ursprung Gerät passiert: Alle Applikationen werden wie beim Befehl Reset Ursprung zurückgesetzt. Alle Dateien, die vom Befehl Reset Ursprung nicht erfasst werden, werden gelöscht (Dateien von Visualisierung, Alarme, Rezepturen usw.) Die Benutzerverwaltung wird gelöscht. Alle Zertifikate, die aktuell vom Laufzeitsystem verwaltet werden, werden gelöscht. Hinweise zum Zurücksetzen des Geräts: Beim Zurücksetzen des Geräts werden auch die in diesem Dialog ausgewählten Objekte gelöscht. Wenn in diesem Dialog nicht alle angezeigten Objekte selektiert werden, können möglicherweise andere Objekte nicht mehr verwendet werden oder werden ebenfalls gelöscht. Löschen : Das Objekt wird bei der Ausführung des Befehls Reset Ursprung Gerät gelöscht. Objekt Objekte, die vom Löschen ausgenommen werden können Die aufgelisteten Objekte sind abhängig von der Version der Steuerung. Ab Version 3.5.16.20 können folgende Objekte vom Löschvorgang ausgenommen werden: Benutzerverwaltung SPS-Logik Zertifikate " }, 
{ "title" : "Befehl: Aktuellen Gerätebenutzer ausloggen ", 
"url" : "_cds_cmd_logoff_current_online_user.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Aktuellen Gerätebenutzer ausloggen ", 
"snippet" : "Aktuellen Gerätebenutzer ausloggen Symbol: Funktion : Der Befehl loggt den gerade auf der Steuerung eingeloggten Benutzer aus. Wenn CODESYS noch eine Verbindung zur Steuerung hat, wird diese damit beendet. Aufruf : Menü Online → Sicherheit Voraussetzung : Die Applikation ist im Onlinebetrieb. Zugrif...", 
"body" : "Aktuellen Gerätebenutzer ausloggen Symbol: Funktion : Der Befehl loggt den gerade auf der Steuerung eingeloggten Benutzer aus. Wenn CODESYS noch eine Verbindung zur Steuerung hat, wird diese damit beendet. Aufruf : Menü Online → Sicherheit Voraussetzung : Die Applikation ist im Onlinebetrieb. Zugriffsschutz Geräte Sie können die Gerätebenutzerverwaltung über die Registerkarten Benutzer und Gruppen und Zugriffsrechte des Geräteeditors verwalten. Die Befehle des Menüs Online → Sicherheit bieten Ihnen eine zusätzliche vereinfachte Möglichkeit, den Zugriff auf das Zielgerät zu schützen. Für weitere Informationen siehe: Gerätebenutzerverwaltung handhaben" }, 
{ "title" : "Befehl: Gerätebenutzer hinzufügen ", 
"url" : "_cds_cmd_add_online_user.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Gerätebenutzer hinzufügen ", 
"snippet" : "Gerätebenutzer hinzufügen Symbol: Funktion : Der Befehl definiert auf einfache Weise einen neuen Gerätebenutzer, der automatisch der Gruppe der Administratoren hinzugefügt wird. Aufruf : Menü Online → Sicherheit Voraussetzung : Das Gerät unterstützt eine Gerätebenutzerverwaltung. Sie sind als Benutz...", 
"body" : "Gerätebenutzer hinzufügen Symbol: Funktion : Der Befehl definiert auf einfache Weise einen neuen Gerätebenutzer, der automatisch der Gruppe der Administratoren hinzugefügt wird. Aufruf : Menü Online → Sicherheit Voraussetzung : Das Gerät unterstützt eine Gerätebenutzerverwaltung. Sie sind als Benutzer auf dem Gerät eingeloggt. Zugriffsschutz Geräte Sie können die Gerätebenutzerverwaltung über die Registerkarten Benutzer und Gruppen und Zugriffsrechte des Geräteeditors verwalten. Die Befehle des Menüs Online → Sicherheit bieten Ihnen eine zusätzliche vereinfachte Möglichkeit, den Zugriff auf das Zielgerät zu schützen. Der Befehl öffnet den Dialog Gerätebenutzer hinzufügen . Darin legen Sie die Zugangsdaten des neuen Benutzers fest. Der Dialog entspricht demjenigen, der auf der Registerkarte Benutzer und Gruppen des Geräteeditors zum Hinzufügen eines neuen Benutzers verwendet wird. Bitte verwenden Sie immer ein starkes Passwort. Folgendes ist zu beachten: Passwortlänge >= 8 Zeichen (am besten >= 12) Groß- und Kleinschreibung verwenden Ziffern einbauen Sonderzeichen verwenden Keine bestehenden Namen und leicht zu erratende Zeichenfolgen im Passwort verwenden (“123”, “abc”, “qwerty”, etc.) Nach dieser Aktion können Sie nicht mehr mit leerem Benutzernamen und Passwort einloggen! Sie müssen sich das Passwort merken! " }, 
{ "title" : "Befehl: Gerätebenutzer entfernen ", 
"url" : "_cds_cmd_remove_online_user.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Gerätebenutzer entfernen ", 
"snippet" : "Gerätebenutzer entfernen Symbol: Funktion : Der Befehl entfernt einen Benutzer aus der Benutzerverwaltung auf dem Zielsystem (Gerät). Aufruf : Menü Online → Sicherheit Voraussetzung : Sie sind als Benutzer auf dem Gerät eingeloggt. Zugriffsschutz Geräte Sie können die Gerätebenutzerverwaltung über d...", 
"body" : "Gerätebenutzer entfernen Symbol: Funktion : Der Befehl entfernt einen Benutzer aus der Benutzerverwaltung auf dem Zielsystem (Gerät). Aufruf : Menü Online → Sicherheit Voraussetzung : Sie sind als Benutzer auf dem Gerät eingeloggt. Zugriffsschutz Geräte Sie können die Gerätebenutzerverwaltung über die Registerkarten Benutzer und Gruppen und Zugriffsrechte des Geräteeditors verwalten. Die Befehle des Menüs Online → Sicherheit bieten Ihnen eine zusätzliche vereinfachte Möglichkeit, den Zugriff auf das Zielgerät zu schützen. Der Befehl öffnet den Dialog Gerätebenutzer entfernen . Geben Sie den Benutzernamen und das Passwort des zu entfernenden Benutzers an und bestätigen mit OK . Nach dieser Aktion können Sie nicht mehr mit dem Konto des entfernten Benutzers einloggen! Wenn der Benutzer der einzige auf dem Zielsystem angegebene ist, erhalten Sie eine Meldung, dass dieser Benutzer nicht entfernt werden kann. " }, 
{ "title" : "Befehl: Passwort Gerätebenutzer ändern ", 
"url" : "_cds_cmd_change_password_online_user.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Passwort Gerätebenutzer ändern ", 
"snippet" : "Passwort Gerätebenutzer ändern Symbol: Funktion : Der Befehl ändert das Passwort für den gerade auf der Steuerung eingeloggten Benutzer. Aufruf : Menü Online → Sicherheit Voraussetzung : Sie sind als Benutzer auf dem Gerät eingeloggt. Der Befehl öffnet zur Definition eines neuen Passworts den Dialog...", 
"body" : "Passwort Gerätebenutzer ändern Symbol: Funktion : Der Befehl ändert das Passwort für den gerade auf der Steuerung eingeloggten Benutzer. Aufruf : Menü Online → Sicherheit Voraussetzung : Sie sind als Benutzer auf dem Gerät eingeloggt. Der Befehl öffnet zur Definition eines neuen Passworts den Dialog Passwort Gerätebenutzer ändern . Sie müssen dazu auch das alte Passwort nochmals angeben. Nach Durchführen dieser Aktion können Sie sich mit dem vorherigen Passwort nicht mehr einloggen! Bitte verwenden Sie immer ein starkes Passwort. Folgendes ist zu beachten: Passwortlänge >= 8 Zeichen (am besten >= 12) Groß- und Kleinschreibung verwenden Ziffern einbauen Sonderzeichen verwenden Keine bestehenden Namen und leicht zu erratende Zeichenfolgen im Passwort verwenden (“123”, “abc”, “qwerty”, etc.) Für weitere Informationen siehe: Gerätebenutzerverwaltung handhaben" }, 
{ "title" : "Befehl: Ausführung an behandelten Exceptions anhalten ", 
"url" : "_cds_cmd_stop_execution_on_handled_exceptions.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Ausführung an behandelten Exceptions anhalten ", 
"snippet" : "Ausführung an behandelten Exceptions anhalten Funktion : Der Befehl hält die Applikation an der Fehlerstelle trotz eines programmierten Ausnahmebehandlung an. Aufruf : Der Befehl ist standardmäßig nicht verfügbar, aber über Tools → Anpassen konfigurierbar. Der Befehl befindet sich dort in der Regist...", 
"body" : "Ausführung an behandelten Exceptions anhalten Funktion : Der Befehl hält die Applikation an der Fehlerstelle trotz eines programmierten Ausnahmebehandlung an. Aufruf : Der Befehl ist standardmäßig nicht verfügbar, aber über Tools → Anpassen konfigurierbar. Der Befehl befindet sich dort in der Registerkarte Befehlsicons in Kategorie Online . Voraussetzung : Die Applikation enthält ein programmiertes Ausnahmebehandlung mit den Operatoren __TRY und __CATCH und ist im Onlinebetrieb. Wenn Sie den Befehl in das Menü Online konfiguriert haben und ihn dort aufrufen, ist die gerade aktive Applikation betroffen. Der Befehl unterstützt Sie dann bei der Fehlersuche. Für weitere Informationen siehe: __TRY, __CATCH, __FINALLY, __ENDTRY und Menü" }, 
{ "title" : "Befehl: Verbinden mit Gerät ", 
"url" : "_cds_cmd_connect_to_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Verbinden mit Gerät ", 
"snippet" : "Verbinden mit Gerät Funktion : Der Befehl stellt eine Verbindung mit dem gerade im Gerätebaum ausgewählten Gerät her. Aufruf : Kontextmenü des Geräts Voraussetzung : Es ist ein Gerät im Gerätebaum selektiert. Die Kommunikationseinstellungen sind korrekt eingestellt....", 
"body" : "Verbinden mit Gerät Funktion : Der Befehl stellt eine Verbindung mit dem gerade im Gerätebaum ausgewählten Gerät her. Aufruf : Kontextmenü des Geräts Voraussetzung : Es ist ein Gerät im Gerätebaum selektiert. Die Kommunikationseinstellungen sind korrekt eingestellt. " }, 
{ "title" : "Befehl: Trennen von Gerät ", 
"url" : "_cds_cmd_disconnect_from_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Trennen von Gerät ", 
"snippet" : "Trennen von Gerät Funktion : Der Befehl trennt die bestehende Verbindung zu einem Gerät. Aufruf : Kontextmenü des Geräts Voraussetzung : Es ist ein Gerät im Gerätebaum selektiert....", 
"body" : "Trennen von Gerät Funktion : Der Befehl trennt die bestehende Verbindung zu einem Gerät. Aufruf : Kontextmenü des Geräts Voraussetzung : Es ist ein Gerät im Gerätebaum selektiert. " }, 
{ "title" : "Befehl: Kurzes Blinken ", 
"url" : "_cds_cmd_wink.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Kurzes Blinken ", 
"snippet" : "Kurzes Blinken Symbol: Funktion : Der Befehl bewirkt ein kurzes Blinken einer LED einer verbundenen Steuerung. Dadurch kann die Hardware eindeutig identifiziert werden. Aufruf : Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn mit Hilfe des Dialogs Tools → Anpassen aus der Befeh...", 
"body" : "Kurzes Blinken Symbol: Funktion : Der Befehl bewirkt ein kurzes Blinken einer LED einer verbundenen Steuerung. Dadurch kann die Hardware eindeutig identifiziert werden. Aufruf : Der Befehl ist standardmäßig in keinem Menü enthalten. Sie können ihn mit Hilfe des Dialogs Tools → Anpassen aus der Befehlskategorie Online in ein Menü einfügen. Voraussetzung : Die Steuerung unterstützt diese Funktion und die Verbindungsparameter sind richtig konfiguriert. " }, 
{ "title" : "Befehl: Simulation ", 
"url" : "_cds_cmd_simulation.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Simulation ", 
"snippet" : "Simulation Funktion : Der Befehl schaltet das Entwicklungssystem in einen Simulationsbetrieb. Aufruf : Menü Online Im Simulationsbetrieb können Sie die aktive Applikation auf einem „simulierten Zielgerät“ starten und debuggen. Sie benötigen kein reales Zielgerät um das Onlineverhalten einer Applikat...", 
"body" : "Simulation Funktion : Der Befehl schaltet das Entwicklungssystem in einen Simulationsbetrieb. Aufruf : Menü Online Im Simulationsbetrieb können Sie die aktive Applikation auf einem „simulierten Zielgerät“ starten und debuggen. Sie benötigen kein reales Zielgerät um das Onlineverhalten einer Applikation zu testen. Beim ersten Einloggen erfolgt eine Abfrage, ob die Applikation angelegt und geladen werden soll. Für ein simuliertes Gerät müssen Sie keine Kommunikationseinstellungen vornehmen. Im Simulationsbetrieb stellt CODESYS den Eintrag der Steuerung im Gerätebaum in Kursivschrift dar. Nach erfolgreichem Einloggen signalisiert das Icon im Gerätebaum den Simulationsbetrieb. Sie können die entsprechenden Onlinebefehle verwenden, um die Applikation zu testen. Um den Simulationsbetrieb auszuschalten, loggen Sie sich zunächst aus der Steuerung aus und wählen danach erneut den Befehl Simulation . Der Befehl betrifft immer die aktive Applikation. Die SPS-Shell wird im Simulationsbetrieb nicht unterstützt. " }, 
{ "title" : "Unterschiede zwischen Simulation und Betrieb mit einer realen Steuerung ", 
"url" : "_cds_cmd_simulation.html#UUID-1e9f2166-cf60-2911-9295-8053f1f65558_id_fb4e48096e42d9c0a8640e0168cbf5_id_4c9f73c83797cddcc0a864631a9fb9dd", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Simulation \/ Unterschiede zwischen Simulation und Betrieb mit einer realen Steuerung ", 
"snippet" : "Simulation Reale Steuerung Echtzeitverhalten\/MultiCore Läuft im CODESYS -Prozess mit normaler Priorität SingleCore -> schlechteres Echtzeitverhalten Echtzeit-Betriebssystem Single- oder Multicore Architekturbreite Simulation 64 Bit (hängt von der CODESYS -Installation ab) –> möglicherweise Compilefe...", 
"body" : "Simulation Reale Steuerung Echtzeitverhalten\/MultiCore Läuft im CODESYS -Prozess mit normaler Priorität SingleCore -> schlechteres Echtzeitverhalten Echtzeit-Betriebssystem Single- oder Multicore Architekturbreite Simulation 64 Bit (hängt von der CODESYS -Installation ab) –> möglicherweise Compilefehler in der IEC-Applikation, wenn die Applikation bisher nur auf 32 Bit betrieben wurde (beispielsweise bei Verwendung von DWORD als POINTER) Steuerung 32 Bit FPU (Rundungsfehler) Verwendet FPU des PCs Unterschiedliche Konfiguration der FPU-Exceptions Verwendet FPU der Steuerung oder FPU-Emulation Unterschiedliche Konfiguration der FPU-Exceptions Behandlung von Exceptions Exception-Handling des Windows Runtime System Exception-Handling der Steuerung Externe Bibliotheken (Cmp\/Sys\/CAA\/OEM\/…) Nur wenige externe Cmp\/SysLibs sind real verfügbar. Im Vergleich zu Embedded könnten auch mehr SysLibs vorhanden sein. Andere Implementierung\/Verhalten der SysLibs (Windows im Gegensatz zum OS der Steuerung) „Unresolved Reference error“ beim Download wird ignoriert. Die Applikation kann trotzdem auf die Steuerung geladen und gestartet werden. Wenn die fehlenden Funktionen wirklich aufgerufen werden, liefern sie jedoch unsinnige Werte. Deshalb kann auch bei externen Bausteinen eine IEC-Implementierung vorgegeben werdem. Dieser stellvertretende IEC-Code wird dann in der Simulation ausgeführt. „Unresolved Reference error“ beim Download, wenn externe Bibliotheken in der Steuerung nicht verfügbar ist I\/O-Treiber I\/O-Konfiguration wird erzeugt, aber nicht ausgewertet. Feldbus-Stacks werden nicht ausgeführt. I\/O-Kanäle werden nicht aktualisiert und keine Bustelegramme versendet. Überwiegend keine Einschränkung, jedoch abhängig von den Möglichkeiten der Steuerung SoftMotion-Treiber Alle SoftMotion-Achsen werden auf virtuell gestellt und damit simuliert. Überwiegend keine Einschränkung, jedoch abhängig von den Möglichkeiten der Steuerung Für weitere Informationen siehe: Testen im Simulationsbetrieb" }, 
{ "title" : "Befehl: Operating Mode: Debug, Gesperrt, Betriebsbereit ", 
"url" : "_cds_cmd_operating_modes.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Operating Mode: Debug, Gesperrt, Betriebsbereit ", 
"snippet" : "Operating Mode: Debug, Gesperrt, Betriebsbereit Funktion : Die Befehle setzen die Steuerung in einen Zustand, der ein versehentliches Ändern des Projekts verhindert. Aufruf : Menü Online Mit den Befehlen können Sie beispielsweise den Zustand einer Steuerung sperren, um zu verhindern, dass diese Steu...", 
"body" : "Operating Mode: Debug, Gesperrt, Betriebsbereit Funktion : Die Befehle setzen die Steuerung in einen Zustand, der ein versehentliches Ändern des Projekts verhindert. Aufruf : Menü Online Mit den Befehlen können Sie beispielsweise den Zustand einer Steuerung sperren, um zu verhindern, dass diese Steuerung den Zustand ändert, während Sie an einer anderen Steuerung programmieren. Zum Abschluss der Programmierung soll dann die Steuerung in einen definierten und von außen sichtbaren Zustand gebracht werden, der sich nach einem Neustart wieder genau so einstellt. In der Statuszeile zeigen die Symbole , und die aktuelle Betriebsart an. Ein Doppelklick auf eines dieser Symbole öffnet ein Hilfefenster. Wenn es die Steuerung unterstützt, können Sie die Steuerung in folgende Betriebsarten schalten: : Debug Keine Einschränkungen : Gesperrt Der aktuelle Zustand des Debuggens auf der Applikation wird gelockt. Es können keine weiteren Haltepunkte gesetzt oder weitere Variablen geforct werden. Das Schreiben von Variablen ist jedoch möglich und bereits gesetzte Haltepunkte bleiben weiter aktiv. Nur der Zustand „RUN“ einer Applikation bleibt bei der Betriebsart Gesperrt auch über einen Neustart der Steuerung erhalten. Durch diesen Zustand kann ein Entwickler verhindern, dass er selbst oder ein anderer Entwickler die Applikation auf der Steuerung beispielsweise durch das Setzen oder Löschen eines Haltepunkts, durch Forcen oder durch Änderungen am Dateisystem ändert. Diese Betriebsart ist hilfreich, um einen Download auf eine falsche Steuerung zu verhindern, wenn beispielsweise mehrere Steuerungen einer Anlage programmiert werden. : Betriebsbereit Diese Betriebsart stellt sicher, dass die Steuerung nach einem Neustart wieder die gleichen Applikationen lädt und dass keine Debug-Features mehr aktiv sind. Die Betriebsart wird gesetzt, wenn eine Steuerung fertig programmiert ist und abgenommen werden soll oder dies bereits ist. Bedingungen für die Aktivierung der Betriebsart Betriebsbereit : Es muss eine Bootapplikation für jede Applikation auf der Steuerung sein. Es dürfen keine aktiven Haltepunkte gesetzt sein. Es müssen alle Applikationen laufen. Es dürfen keine geforcten Werte vorhanden sein. Darüber hinaus kann das Gerät noch eigene Restriktionen festlegen. Die Betriebsarten Gesperrt und Betriebsbereit unterscheiden sich in den Anwendungsfällen und in den Voraussetzungen für die Aktivierung der Betriebsart. Bei beiden Betriebsarten verhindert das Laufzeitsystem jedoch die folgenden Aktionen: Die Applikation betreffend Download einer Applikation Online-Change Variablen forcen Haltepunkte setzen Applikation stoppen Applikation zurücksetzen Applikation starten Applikation löschen Den Dateitransfer der Steuerung betreffend Download einer Datei auf die Steuerung Datei auf der Steuerung löschen Datei auf der Steuerung umbenennen Verzeichnis auf der Steuerung erstellen Verzeichnis auf der Steuerung löschen Verzeichnis auf der Steuerung umbenennen Sie können die Betriebsart zwischen Gesperrt und Betriebsbereit nicht umschalten. " }, 
{ "title" : "Befehl: Applikationen beim Download Server zuweisen ", 
"url" : "_cds_assign_server_app_download.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Online \/ Befehl: Applikationen beim Download Server zuweisen ", 
"snippet" : "Applikationen beim Download Server zuweisen Der Befehl steht zur Verfügung, wenn das Add-on CODESYS Automation Server Connector installiert ist. Die Beschreibung des Befehls finden Sie in der Hilfe zum CODESYS Automation Server in Befehl: Applikationen beim Download Server zuweisen...", 
"body" : "Applikationen beim Download Server zuweisen Der Befehl steht zur Verfügung, wenn das Add-on CODESYS Automation Server Connector installiert ist. Die Beschreibung des Befehls finden Sie in der Hilfe zum CODESYS Automation Server in Befehl: Applikationen beim Download Server zuweisen " }, 
{ "title" : "Debug ", 
"url" : "_cds_f_commands_debug.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: Start ", 
"url" : "_cds_cmd_start.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Start ", 
"snippet" : "Start Symbol: Tastaturkürzel: F5 Funktion : Der Befehl startet die Applikation (Zustand LÄUFT ). Aufruf : Menü Debug , Kontextmenü des Objekts Applikation Voraussetzung : Die Applikation ist im Onlinebetrieb im Zustand STOP . Wenn Sie den Befehl über das Menü Debug aufrufen, wirkt er auf die gerade ...", 
"body" : "Start Symbol: Tastaturkürzel: F5 Funktion : Der Befehl startet die Applikation (Zustand LÄUFT ). Aufruf : Menü Debug , Kontextmenü des Objekts Applikation Voraussetzung : Die Applikation ist im Onlinebetrieb im Zustand STOP . Wenn Sie den Befehl über das Menü Debug aufrufen, wirkt er auf die gerade aktive Applikation. Für weitere Informationen siehe: Applikationscode laden, einloggen und SPS starten" }, 
{ "title" : "Befehl: Stop ", 
"url" : "_cds_cmd_stop.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Stop ", 
"snippet" : "Stop Symbol: Tastaturkürzel: Umschalt + F8 Funktion : Der Befehl stoppt die Applikation (Zustand STOP ). Aufruf : Menü Debug , Kontextmenü des Objekts Applikation Voraussetzung : Die Applikation ist im Onlinebetrieb im Zustand LÄUFT . Wenn Sie den Befehl über das Menü Debug aufrufen, wirkt er auf di...", 
"body" : "Stop Symbol: Tastaturkürzel: Umschalt + F8 Funktion : Der Befehl stoppt die Applikation (Zustand STOP ). Aufruf : Menü Debug , Kontextmenü des Objekts Applikation Voraussetzung : Die Applikation ist im Onlinebetrieb im Zustand LÄUFT . Wenn Sie den Befehl über das Menü Debug aufrufen, wirkt er auf die gerade aktive Applikation. " }, 
{ "title" : "Befehl: Einzelzyklus ", 
"url" : "_cds_cmd_single_cycle.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Einzelzyklus ", 
"snippet" : "Einzelzyklus Tastaturkürzel: Strg + F5 Funktion : Der Befehl führt die aktive Applikation für einen Zyklus aus. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und das Programm steht an einem Programmschritt....", 
"body" : "Einzelzyklus Tastaturkürzel: Strg + F5 Funktion : Der Befehl führt die aktive Applikation für einen Zyklus aus. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und das Programm steht an einem Programmschritt. " }, 
{ "title" : "Befehl: Neuer Haltepunkt ", 
"url" : "_cds_cmd_new_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Neuer Haltepunkt ", 
"snippet" : "Neuer Haltepunkt Symbol: Tastaturkürzel: Alt + F7 Funktion : Der Befehl öffnet den Dialog Eigenschaften Haltepunkt . Aufruf : Menü Debug Voraussetzung : Die Applikation muss sich im Onlinebetrieb befinden. Mit dem Befehl Neuer Haltepunkt können Sie im Onlinebetrieb einen neuen Haltepunkt direkt an d...", 
"body" : "Neuer Haltepunkt Symbol: Tastaturkürzel: Alt + F7 Funktion : Der Befehl öffnet den Dialog Eigenschaften Haltepunkt . Aufruf : Menü Debug Voraussetzung : Die Applikation muss sich im Onlinebetrieb befinden. Mit dem Befehl Neuer Haltepunkt können Sie im Onlinebetrieb einen neuen Haltepunkt direkt an der aktuellen Cursor-Position setzen. Für weitere Informationen siehe: Verwenden von Haltepunkten" }, 
{ "title" : "Befehl: Neuer Datenhaltepunkt ", 
"url" : "_cds_cmd_new_data_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Neuer Datenhaltepunkt ", 
"snippet" : "Neuer Datenhaltepunkt Symbol: Funktion : Der Befehl öffnet den Dialog Neuer Haltepunkt . Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb. Die Gerätebeschreibungsdatei des Zielgeräts enthält die Einträge für die Funktionalität „Datenhaltepunkte“. Aktuell sind Datenhaltepunkte...", 
"body" : "Neuer Datenhaltepunkt Symbol: Funktion : Der Befehl öffnet den Dialog Neuer Haltepunkt . Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb. Die Gerätebeschreibungsdatei des Zielgeräts enthält die Einträge für die Funktionalität „Datenhaltepunkte“. Aktuell sind Datenhaltepunkte nur mit der CODESYS Control Win möglich. Für weitere Informationen siehe: Verwenden von Haltepunkten" }, 
{ "title" : "Befehl: Haltepunkt bearbeiten ", 
"url" : "_cds_cmd_edit_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Haltepunkt bearbeiten ", 
"snippet" : "Haltepunkt bearbeiten Symbol: Funktion : Der Befehl öffnet den Dialog Eigenschaften Haltepunkt . Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und der Cursor steht auf einem Haltepunkt. Für weitere Informationen siehe: Verwenden von Haltepunkten...", 
"body" : "Haltepunkt bearbeiten Symbol: Funktion : Der Befehl öffnet den Dialog Eigenschaften Haltepunkt . Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und der Cursor steht auf einem Haltepunkt. Für weitere Informationen siehe: Verwenden von Haltepunkten" }, 
{ "title" : "Befehl: Haltepunkt aktivieren ", 
"url" : "_cds_cmd_activate_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Haltepunkt aktivieren ", 
"snippet" : "Haltepunkt aktivieren Funktion : Der Befehl aktiviert einen deaktivierten Haltepunkt. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und der Cursor steht auf einem deaktivierten Haltepunkt. Für weitere Informationen siehe: Verwenden von Haltepunkten...", 
"body" : "Haltepunkt aktivieren Funktion : Der Befehl aktiviert einen deaktivierten Haltepunkt. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und der Cursor steht auf einem deaktivierten Haltepunkt. Für weitere Informationen siehe: Verwenden von Haltepunkten" }, 
{ "title" : "Befehl: Haltepunkt deaktivieren ", 
"url" : "_cds_cmd_deactivate_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Haltepunkt deaktivieren ", 
"snippet" : "Haltepunkt deaktivieren Funktion : Der Befehl deaktiviert einen aktivierten Haltepunkt. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und der Cursor steht auf einem aktivierten Haltepunkt. Für weitere Informationen siehe: Verwenden von Haltepunkten...", 
"body" : "Haltepunkt deaktivieren Funktion : Der Befehl deaktiviert einen aktivierten Haltepunkt. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und der Cursor steht auf einem aktivierten Haltepunkt. Für weitere Informationen siehe: Verwenden von Haltepunkten" }, 
{ "title" : "Befehl: Haltepunkt umschalten ", 
"url" : "_cds_cmd_toggle_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Haltepunkt umschalten ", 
"snippet" : "Haltepunkt umschalten Tastaturkürzel: F9 Funktion : Der Befehl setzt einen Haltepunkt oder löscht einen bestehenden. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb. Der Cursor steht auf einem Haltepunkt. Für weitere Informationen siehe: Verwenden von Haltepunkten...", 
"body" : "Haltepunkt umschalten Tastaturkürzel: F9 Funktion : Der Befehl setzt einen Haltepunkt oder löscht einen bestehenden. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb. Der Cursor steht auf einem Haltepunkt. Für weitere Informationen siehe: Verwenden von Haltepunkten" }, 
{ "title" : "Befehl: Prozedurschritt ", 
"url" : "_cds_cmd_step_over.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Prozedurschritt ", 
"snippet" : "Prozedurschritt Symbol: Tastaturkürzel: F10 Funktion : Der Befehl führt die Anweisung, an der das Programm aktuell steht, aus und hält vor der nächsten Anweisung im Programmierbaustein an. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und das Programm steht an der aktuelle...", 
"body" : "Prozedurschritt Symbol: Tastaturkürzel: F10 Funktion : Der Befehl führt die Anweisung, an der das Programm aktuell steht, aus und hält vor der nächsten Anweisung im Programmierbaustein an. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und das Programm steht an der aktuellen Halteposition (Debugbetrieb). Wenn in der auszuführenden Anweisung ein Aufruf ist (von einem Programm, einer Funktionsbaustein-Instanz, einer Funktion, einer Methode oder einer Aktion), wird der untergeordnete Programmierbaustein vollständig in einem Schritt durchlaufen und zum Aufruf zurückgekehrt. Dann wird vor der nächsten Anweisung (in der nächsten Codezeile) angehalten. Wählen Sie den Befehl Einzelschritt , um in einen untergeordneten Baustein zu springen, um ihn in Einzelschritten auszuführen. Für weitere Informationen siehe: Schrittweises Abarbeiten eines Programms (Stepping)" }, 
{ "title" : "Befehl: Einzelschritt ", 
"url" : "_cds_cmd_step_into.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Einzelschritt ", 
"snippet" : "Einzelschritt Symbol: Tastaturkürzel: F8 Funktion : Der Befehl führt die Anweisung, an der das Programm aktuell steht, aus und hält vor der nächsten Anweisung. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und das Programm steht an der aktuellen Halteposition (Debugbetrieb...", 
"body" : "Einzelschritt Symbol: Tastaturkürzel: F8 Funktion : Der Befehl führt die Anweisung, an der das Programm aktuell steht, aus und hält vor der nächsten Anweisung. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und das Programm steht an der aktuellen Halteposition (Debugbetrieb). Wenn in der auszuführenden Anweisung ein Aufruf ist (von einem Programm, einer Funktionsbaustein-Instanz, einer Funktion, einer Methode oder einer Aktion), wird in diesen untergeordneten Programmierbaustein gesprungen. Dessen Code erscheint in einem eigenen Editor. Die erste Anweisung dort wird ausgeführt und vor der nächsten Anweisung wird angehalten. Die neue aktuelle Halteposition ist dann im aufgerufenen Programmierbaustein. Wählen Sie den Befehl Prozedurschritt , um im aktuell aktiven Programmierbaustein zu bleiben und den Aufruf in einem Schritt zu durchlaufen. " }, 
{ "title" : "Befehl: Ausführen bis Rücksprung ", 
"url" : "_cds_cmd_step_out.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Ausführen bis Rücksprung ", 
"snippet" : "Ausführen bis Rücksprung Symbol: Tastaturkürzel: Umschalt + F10 Funktion : Der Befehl führt das Programm bis zum nächsten Rücksprung aus und hält danach an. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und das Programm steht an der aktuellen Halteposition (Debugbetrieb). ...", 
"body" : "Ausführen bis Rücksprung Symbol: Tastaturkürzel: Umschalt + F10 Funktion : Der Befehl führt das Programm bis zum nächsten Rücksprung aus und hält danach an. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und das Programm steht an der aktuellen Halteposition (Debugbetrieb). Wenn die aktuelle Halteposition in einem untergeordneten Programmierbaustein ist, wird dieser bis zum Ende durchlaufen. Dann wird zur Aufrufstelle im aufrufenden Programmierbaustein zurückgesprungen und dort angehalten (in der Zeile mit dem Aufruf). Wenn die aktuelle Halteposition im Hauptprogramm ist, wird der Programmierbaustein bis zum Ende durchlaufen. Dann wird zurück an den Anfang (an den Programmstart an die erste Codezeile im Programmierbaustein) gesprungen und dort angehalten. Für weitere Informationen siehe: __TRY, __CATCH, __FINALLY, __ENDTRY und Menü" }, 
{ "title" : "Befehl: Ausführen bis Cursor ", 
"url" : "_cds_cmd_run_to_cursor.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Ausführen bis Cursor ", 
"snippet" : "Ausführen bis Cursor Symbol: Funktion : Der Befehl führt ein Programm bis zu einer mit dem Cursor gekennzeichneten Position aus. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und das Programm steht an der aktuellen Halteposition (Debugbetrieb). Außerdem haben Sie mit dem C...", 
"body" : "Ausführen bis Cursor Symbol: Funktion : Der Befehl führt ein Programm bis zu einer mit dem Cursor gekennzeichneten Position aus. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und das Programm steht an der aktuellen Halteposition (Debugbetrieb). Außerdem haben Sie mit dem Cursor eine beliebige Codezeile in einem beliebigen Programmierbaustein gekennzeichnet. Die Anweisungen, die zwischen der aktuellen Halteposition und der Cursorposition liegen, werden in einem Schritt ausgeführt. Dann hält die Ausführung an der Cursorposition an, die damit zur nächsten Halteposition wird. Beachten Sie, dass die Codezeile, an der Sie den Cursor gesetzt haben, erreicht aber nicht ausgeführt wird. Für weitere Informationen siehe: __TRY, __CATCH, __FINALLY, __ENDTRY und Menü" }, 
{ "title" : "Befehl: Nächste Anweisung festlegen ", 
"url" : "_cds_cmd_set_next_statement.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Nächste Anweisung festlegen ", 
"snippet" : "Nächste Anweisung festlegen Symbol: Funktion : Der Befehl legt fest, welche Anweisung als nächstes ausgeführt wird. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und das Programm steht an der aktuellen Halteposition (Debugbetrieb). Außerdem haben Sie mit dem Cursor eine be...", 
"body" : "Nächste Anweisung festlegen Symbol: Funktion : Der Befehl legt fest, welche Anweisung als nächstes ausgeführt wird. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und das Programm steht an der aktuellen Halteposition (Debugbetrieb). Außerdem haben Sie mit dem Cursor eine beliebige Codezeile in einem beliebigen Programmierbaustein gekennzeichnet. Die mit Cursor gekennzeichnete Codezeile wird zur aktuellen Halteposition, ohne die Anweisungen dazwischen oder die angesprungene Anweisung auszuführen. Für weitere Informationen siehe: Schrittweises Abarbeiten eines Programms (Stepping)" }, 
{ "title" : "Befehl: Nächste Anweisung anzeigen ", 
"url" : "_cds_cmd_show_next_statement.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Nächste Anweisung anzeigen ", 
"snippet" : "Nächste Anweisung anzeigen Symbol: Funktion : Der Befehl zeigt die Programmanweisung an, die im nächsten Schritt abgearbeitet wird. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und das Programm steht an der aktuellen Halteposition (Debugbetrieb). Die Halteposition ist in ...", 
"body" : "Nächste Anweisung anzeigen Symbol: Funktion : Der Befehl zeigt die Programmanweisung an, die im nächsten Schritt abgearbeitet wird. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb und das Programm steht an der aktuellen Halteposition (Debugbetrieb). Die Halteposition ist in einer für Sie nicht sichtbaren Codezeile. Der Befehl bewirkt, dass das Fenster mit der aktuellen Halteposition, die im Code gelb und mit dem Symbol gekennzeichnet ist, aktiv und die Halteposition sichtbar wird. Das ist nützlich, wenn Sie viele Editoren geöffnet haben und die Halteposition sich verdeckt in einem nicht aktiven Editor befindet. Für weitere Informationen siehe: Schrittweises Abarbeiten eines Programms (Stepping)" }, 
{ "title" : "Befehl: Werte forcen ", 
"url" : "_cds_cmd_force_values.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Werte forcen ", 
"snippet" : "Werte forcen Tastaturkürzel: F7 Funktion : Der Befehl setzt den Wert einer Variablen auf der Steuerung dauerhaft auf einen vordefinierten Wert. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb. Das außerordentliche Ändern von Variablenwerten in einer auf der Steuerung laufend...", 
"body" : "Werte forcen Tastaturkürzel: F7 Funktion : Der Befehl setzt den Wert einer Variablen auf der Steuerung dauerhaft auf einen vordefinierten Wert. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb. Das außerordentliche Ändern von Variablenwerten in einer auf der Steuerung laufenden Applikation kann zu unerwünschtem Verhalten der gesteuerten Anlage führen. Evaluieren Sie mögliche Gefahren vor einem Forcen von Variablenwerten und treffen Sie entsprechende Sicherheitsvorkehrungen. Abhängig von der gesteuerten Anlage könnten Schäden an der Anlage und Werkstücken entstehen oder Gesundheit und Leben von Personen gefährdet sein. Mit dem Befehl setzt CODESYS eine oder mehrere Variablen der aktiven Applikation auf der Steuerung permanent auf definierte Werte. Ein „geforcter“ Wert wird mit einem Symbol gekennzeichnet. Sehen Sie zur Funktionsweise des Forcens und der Vorbereitung von Werten bitte die Hilfeseite ‚Forcen und Schreiben von Variablen‘. Der Befehl Werte forcen [alle Applikationen] , der alle Applikationen im Projekt betrifft, ist standardmäßig nicht in einem Menü enthalten. Für weitere Informationen siehe: Forcen und Schreiben von Variablen und Überwachungslisten verwenden" }, 
{ "title" : "Befehl: Werte schreiben ", 
"url" : "_cds_cmd_write_values.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Werte schreiben ", 
"snippet" : "Werte schreiben Tastaturkürzel: Strg + F7 Funktion : Der Befehl setzt den Wert einer Variablen auf der Steuerung einmalig auf einen vordefinierten Wert. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb. Das außerordentliche Ändern von Variablenwerten in einer auf der Steuerun...", 
"body" : "Werte schreiben Tastaturkürzel: Strg + F7 Funktion : Der Befehl setzt den Wert einer Variablen auf der Steuerung einmalig auf einen vordefinierten Wert. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb. Das außerordentliche Ändern von Variablenwerten in einer auf der Steuerung laufenden Applikation kann zu unerwünschtem Verhalten der gesteuerten Anlage führen. Evaluieren Sie mögliche Gefahren vor einem Forcen von Variablenwerten und treffen Sie entsprechende Sicherheitsvorkehrungen. Abhängig von der gesteuerten Anlage könnten Schäden an der Anlage und Werkstücken entstehen oder Gesundheit und Leben von Personen gefährdet sein. Mit dem Befehl setzen Sie eine oder mehrere Variablen der aktiven Applikation auf der Steuerung einmalig auf definierte Werte. Das Schreiben erfolgt einmal zu Beginn des nächsten Zyklus. Sie können Werte wie folgt vorbereiten: Klicken Sie in das Feld vorbereiteter Wert im Deklarationsteil und geben Sie den neuen Wert ein. Bei einer booleschen Variable ändern Sie den Wert durch einfaches Klicken in das Feld. Klicken Sie in das Inline-Monitoring-Feld im Implementierungsteil des FUP\/KOP\/AWL-Editors und geben Sie den neuen Wert ein. Klicken Sie in das Feld vorbereiteter Wert im Monitoringfenster und geben Sie den neuen Wert ein. Der Befehl Werte schreiben [alle Applikationen] , der alle Applikationen im Projekt betrifft, ist standardmäßig nicht in einem Menü enthalten. Für weitere Informationen siehe: Forcen und Schreiben von Variablen" }, 
{ "title" : "Befehl: Forcen für alle Werte aufheben ", 
"url" : "_cds_cmd_unforce_all_values.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Forcen für alle Werte aufheben ", 
"snippet" : "Forcen für alle Werte aufheben Tastaturkürzel: Alt + F7 Funktion : Der Befehl setzt das Forcen aller Variablen zurück. Die Variablen erhalten dabei ihren Istwert aus der Steuerung. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb. Der Befehl Forceliste aufheben hat die gleich...", 
"body" : "Forcen für alle Werte aufheben Tastaturkürzel: Alt + F7 Funktion : Der Befehl setzt das Forcen aller Variablen zurück. Die Variablen erhalten dabei ihren Istwert aus der Steuerung. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb. Der Befehl Forceliste aufheben hat die gleiche Funktion wie dieser Befehl, jedoch mit dem Unterschied: Wenn der Befehl Forceliste aufheben nicht für alle geforcten Variablen ausgeführt werden konnte, erscheint keine Meldung. Das außerordentliche Ändern von Variablenwerten in einer auf der Steuerung laufenden Applikation kann zu unerwünschtem Verhalten der gesteuerten Anlage führen. Evaluieren Sie mögliche Gefahren vor einem Forcen von Variablenwerten und treffen Sie entsprechende Sicherheitsvorkehrungen. Abhängig von der gesteuerten Anlage könnten Schäden an der Anlage und Werkstücken entstehen oder Gesundheit und Leben von Personen gefährdet sein. Der Befehl Forcen aufheben [alle Applikationen] , der alle Applikationen im Projekt betrifft, ist standardmäßig nicht in einem Menü enthalten. Für weitere Informationen siehe: Werte forcen und Forcen und Schreiben von Variablen" }, 
{ "title" : "Befehl: Alle Werte von <Device.Application> forcen ", 
"url" : "_cds_cmd_force_all_values_of_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Alle Werte von <Device.Application> forcen ", 
"snippet" : "Alle Werte von <Device.Application> forcen Funktion : Der Befehl setzt alle Werte der Variablen der selektierten <Device.Application> dauerhaft auf vordefinierte Werte. Aufruf : Kontextmenü der Applikation im Gerätebaum Kontextmenü im Editor einer POU der selektierten Applikation Voraussetzung : Die...", 
"body" : "Alle Werte von <Device.Application> forcen Funktion : Der Befehl setzt alle Werte der Variablen der selektierten <Device.Application> dauerhaft auf vordefinierte Werte. Aufruf : Kontextmenü der Applikation im Gerätebaum Kontextmenü im Editor einer POU der selektierten Applikation Voraussetzung : Die Applikation ist im Onlinebetrieb. Das außerordentliche Ändern von Variablenwerten in einer auf der Steuerung laufenden Applikation kann zu unerwünschtem Verhalten der gesteuerten Anlage führen. Evaluieren Sie mögliche Gefahren vor einem Forcen von Variablenwerten und treffen Sie entsprechende Sicherheitsvorkehrungen. Abhängig von der gesteuerten Anlage könnten Schäden an der Anlage und Werkstücken entstehen oder Gesundheit und Leben von Personen gefährdet sein. Mit dem Befehl setzt CODESYS eine oder mehrere Variablen der aktiven Applikation auf der Steuerung permanent auf definierte Werte. Dieses Setzen erfolgt jeweils am Beginn und am Ende eines Abarbeitungszyklus. Abfolge der Abarbeitung: 1.Eingänge lesen, 2. Werte forcen 3. Code abarbeiten, 4. Werte forcen, 5. Ausgänge schreiben. Sie können Werte wie folgt vorbereiten: Klicken Sie in das Feld vorbereiteter Wert im Deklarationsteil und geben Sie den neuen Wert ein. Bei einer booleschen Variable ändern Sie den Wert durch einfaches Klicken in das Feld. Klicken Sie in das Inline-Monitoring-Feld im Implementierungsteil des FUP\/KOP\/AWL-Editors und geben Sie den neuen Wert ein. Klicken Sie in das Feld vorbereiteter Wert im Monitoringfenster und geben Sie den neuen Wert ein. Ein „geforcter“ Wert wird mit einem Symbol gekennzeichnet. CODESYS führt das Forcen durch, bis es explizit durch den Anwender wie folgt aufgehoben wird: Befehl Forcen für alle Werte aufheben Befehl Forcen für alle Werte von ‚<Device.Application>‘ aufheben Aufheben des Forces über den Dialog Wert vorbereiten Ausloggen aus der Applikation Der Befehl Werte forcen [alle Applikationen] , der alle Applikationen im Projekt betrifft, ist standardmäßig nicht in einem Menü enthalten. Für weitere Informationen siehe: Forcen und Schreiben von Variablen" }, 
{ "title" : "Befehl: Alle Werte von <Device.Application> schreiben ", 
"url" : "_cds_cmd_write_all_values_of_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Alle Werte von <Device.Application> schreiben ", 
"snippet" : "Alle Werte von <Device.Application> schreiben Funktion : Der Befehl setzt alle Werte der Variablen der selektierten <Device.Application> einmalig auf vordefinierte Werte. Aufruf : Kontextmenü der Applikation im Gerätebaum Kontextmenü im Editor einer POU der selektierten Applikation Voraussetzung : D...", 
"body" : "Alle Werte von <Device.Application> schreiben Funktion : Der Befehl setzt alle Werte der Variablen der selektierten <Device.Application> einmalig auf vordefinierte Werte. Aufruf : Kontextmenü der Applikation im Gerätebaum Kontextmenü im Editor einer POU der selektierten Applikation Voraussetzung : Die Applikation ist im Onlinebetrieb. Das außerordentliche Ändern von Variablenwerten in einer auf der Steuerung laufenden Applikation kann zu unerwünschtem Verhalten der gesteuerten Anlage führen. Evaluieren Sie mögliche Gefahren vor einem Forcen von Variablenwerten und treffen Sie entsprechende Sicherheitsvorkehrungen. Abhängig von der gesteuerten Anlage könnten Schäden an der Anlage und Werkstücken entstehen oder Gesundheit und Leben von Personen gefährdet sein. Mit dem Befehl setzen Sie eine oder mehrere Variablen der selektierten <Device.Application> auf der Steuerung einmalig auf definierte Werte. Das Schreiben erfolgt einmal zu Beginn des nächsten Zyklus. Sie können Werte wie folgt vorbereiten: Klicken Sie in das Feld vorbereiteter Wert im Deklarationsteil und geben Sie den neuen Wert ein. Bei einer booleschen Variable ändern Sie den Wert durch einfaches Klicken in das Feld. Klicken Sie in das Inline-Monitoring-Feld im Implementierungsteil des FUP\/KOP\/AWL-Editors und geben Sie den neuen Wert ein. Klicken Sie in das Feld vorbereiteter Wert im Überwachenfenster und geben Sie den neuen Wert ein. Für weitere Informationen siehe: Forcen und Schreiben von Variablen" }, 
{ "title" : "Befehl: Forcen für alle Werte von <Device.Application> aufheben ", 
"url" : "_cds_cmd_unforce_all_values_of_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Forcen für alle Werte von <Device.Application> aufheben ", 
"snippet" : "Forcen für alle Werte von <Device.Application> aufheben Funktion : Der Befehl setzt das Forcen aller Werte der Variablen der selektierten <Device.Application> zurück. Die Variablen erhalten dabei ihren Istwert aus der Steuerung. Aufruf : Kontextmenü der Applikation im Gerätebaum Kontextmenü im Edito...", 
"body" : "Forcen für alle Werte von <Device.Application> aufheben Funktion : Der Befehl setzt das Forcen aller Werte der Variablen der selektierten <Device.Application> zurück. Die Variablen erhalten dabei ihren Istwert aus der Steuerung. Aufruf : Kontextmenü der Applikation im Gerätebaum Kontextmenü im Editor einer POU der selektierten Applikation Voraussetzung : Die Applikation ist im Onlinebetrieb. Das außerordentliche Ändern von Variablenwerten in einer auf der Steuerung laufenden Applikation kann zu unerwünschtem Verhalten der gesteuerten Anlage führen. Evaluieren Sie mögliche Gefahren vor einem Forcen von Variablenwerten und treffen Sie entsprechende Sicherheitsvorkehrungen. Abhängig von der gesteuerten Anlage könnten Schäden an der Anlage und Werkstücken entstehen oder Gesundheit und Leben von Personen gefährdet sein. " }, 
{ "title" : "Befehl: Ablaufkontrollmodus umschalten ", 
"url" : "_cds_cmd_flowcontrol.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Ablaufkontrollmodus umschalten ", 
"snippet" : "Ablaufkontrollmodus umschalten Funktion : Der Befehl aktiviert oder deaktiviert die Ablaufkontrolle. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb. In dem Dialog zur Aktivierung der Ablaufkontrolle kann in einer Auswahlliste die Task ausgewählt werden, bei der die Ablaufko...", 
"body" : "Ablaufkontrollmodus umschalten Funktion : Der Befehl aktiviert oder deaktiviert die Ablaufkontrolle. Aufruf : Menü Debug Voraussetzung : Die Applikation ist im Onlinebetrieb. In dem Dialog zur Aktivierung der Ablaufkontrolle kann in einer Auswahlliste die Task ausgewählt werden, bei der die Ablaufkontrolle angewendet wird. Standardmäßig ist die Option Task automatisch auswählen ausgewählt. Die ausgewählte Task wird im Gerätebaum mit Ablaufkontrolle gekennzeichnet. Wenn der Ablaufkontrollmodus aktiviert ist, stehen im Gerätebaum im Kontextmenü aller Tasks die Befehle Ablaufkontroll-Task → Diese Task auswählen und Ablaufkontroll-Task → Task automatisch auswählen zur Verfügung, um eine andere Task für die Ablaufkontrolle auszuwählen. Eine aktive Ablaufkontrolle verlängert die Laufzeit der Applikation! Wenn die Option Bestätigter Onlinebetrieb in den Kommunikationseinstellungen aktiviert ist, erscheint beim Einschalten der Ablaufkontrolle eine Meldungsbox, über die der Vorgang noch abgebrochen werden kann. Das Verwenden von Haltepunkten und die schrittweise Abarbeitung des Programms sind bei aktivierter Ablaufkontrolle nicht möglich. Für weitere Informationen siehe: Ablaufkontrolle" }, 
{ "title" : "Befehl: Darstellung: Binär, Dezimal und Hexadezimal ", 
"url" : "_cds_cmd_display_mode.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Debug \/ Befehl: Darstellung: Binär, Dezimal und Hexadezimal ", 
"snippet" : "Darstellung: Binär, Dezimal und Hexadezimal Funktion : Die Befehle des Untermenüs Darstellung dienen der Einstellung des Formats für die Darstellung der Werte beim Monitoring im Onlinebetrieb. Aufruf : Menü Debug Voraussetzung : Das Projekt ist im Offline- oder Onlinebetrieb. Die Darstellungsformate...", 
"body" : "Darstellung: Binär, Dezimal und Hexadezimal Funktion : Die Befehle des Untermenüs Darstellung dienen der Einstellung des Formats für die Darstellung der Werte beim Monitoring im Onlinebetrieb. Aufruf : Menü Debug Voraussetzung : Das Projekt ist im Offline- oder Onlinebetrieb. Die Darstellungsformate „Binär“ und „Hexadezimal“ sind vorzeichenlos, „Dezimal“ ist vorzeichenbehaftet. Für weitere Informationen siehe: Monitoring in Programmierobjekten aufrufen" }, 
{ "title" : "Tools ", 
"url" : "_cds_f_commands_tools.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Tools ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: Package Manager ", 
"url" : "_cds_cmd_package_manager.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Tools \/ Befehl: Package Manager ", 
"snippet" : "Package Manager Symbol: Funktion : Der Befehl öffnet den Dialog Package Manager , wo Sie Packages installieren, deinstallieren und verwalten. Aufruf : Menü Tools Sie können den Package Manager auch als alleinstehende Anwendung mit der Kommandozeile aufrufen. Bereits installierte Packages Auflistung ...", 
"body" : "Package Manager Symbol: Funktion : Der Befehl öffnet den Dialog Package Manager , wo Sie Packages installieren, deinstallieren und verwalten. Aufruf : Menü Tools Sie können den Package Manager auch als alleinstehende Anwendung mit der Kommandozeile aufrufen. Bereits installierte Packages Auflistung der installierten Package mit Name , Version , Installationsdatum , Update-Info , Lizenzinformation Wenn ein Package aus dem CODESYS Store International stammt, kennzeichnet CODESYS es mit dem roten Package-Symbol anstelle des gelben Symbols . Wenn ein Update verfügbar ist, zeigt CODESYS dies mit einem Eintrag in der Spalte Update-Info und mit dem Symbol an. Wenn ein Package zur Installation ansteht, kennzeichnet CODESYS es mit dem Symbol . Wenn ein Package zur Deinstallation ansteht, kennzeichnet CODESYS es mit dem Symbol . Aktualisieren Aktualisiert die Auflistung Installieren Öffnet den Standarddialog für das Suchen nach einem Package im Dateisystem Der Dateityp ist standardmäßig *.package. Sie können auch zwei Versionen eines Packages installieren. Nach Auswahl des Packages öffnet sich der Dialog Package-Signaturen überprüfen . In dem Dialog wird das Package mit den Informationen zur Signierung angezeigt. Detaillierte Informationen zur Signierung werden im Tooltip angezeigt und zusätzlich in einem Dialog, der sich öffnet, wenn ein Package doppelgeklickt wird. Unsignierte und selbstsignierte Packages erlauben : Das Package soll installiert werden, obwohl es unsigniert oder selbstsigniert ist. Nach Auswahl des Packages erscheint der Installationsassistent mit den Dialogen: Installation - Lizenzvereinbarung In diesem Dialog zeigt CODESYS auch die Prüfsumme des Packages an. Erscheint nur, wenn das Package eine Lizenzvereinbarung enthält Installationstyp auswählen Die Optionen sind package-abhängig. Komplette Installation : CODESYS installiert alle Komponenten Typische Installation : CODESYS installiert ein im Package definiertes Standard-Set aus Komponenten Angepasste Installation : CODESYS installiert diejenigen Komponenten, die in einem Dialog ausgewählt werden Installation - Zielversionen : Sie wählen aus, welche der bereits vorhandenen Zielversionen durch die Package-Installation aktualisiert werden sollen. Sie müssen mindestens ein Versionsprofil auswählen. Wenn dieser Dialog erfolgreich abgeschlossen ist, steht das ausgewählte Package zur Installation bereit. Damit die Installation des Packages automatisch gestartet und durchgeführt wird, müssen alle CODESYS -Instanzen geschlossen werden. Deinstallieren Deinstalliert das selektierte Package Wenn Versionen anzeigen nicht aktiviert ist, deinstalliert CODESYS alle Versionen des selektierten Packages. Wenn Versionen anzeigen aktiviert ist und Sie einen Package-Knoten auf oberster Ebene ausgewählt haben, deinstalliert CODESYS alle Versionen des ausgewählten Packages. Wenn Versionen anzeigen aktiviert ist und Sie eine einzelne Package-Version selektiert haben, deinstalliert CODESYS genau diese Version. Wenn dieser Dialog abgeschlossen ist, müssen alle CODESYS -Instanzen geschlossen werden, um die Deinstallation des Packages zu starten. Details Öffnet für das selektierte Package den Dialog Details mit folgenden Registerkarten: Package Details Name : Package-Name Version Prüfsumme : SHA-1-Prüfsumme des Packages Anbieter Copyright Beschreibung Installationsdatum Lizenzvereinbarung Installations-Log Im Hintergrund nach Updates suchen : CODESYS führt automatisch nach jedem Start des Programmiersystems und danach einmal pro Stunde ein Suchlauf nach Updates durch. Versionen anzeigen : Zeigt alle Versionen der installierten Packages an Sie können die Prüfsumme , die CODESYS im Dialog Details und im Dialog Installation - Lizenzvereinbarung des Installations-Assistenten anzeigt, mit der Package-Prüfsumme des Package-Anbieters vergleichen. Damit stellen Sie sicher, dass Sie ein Original-Package installiert haben. Wenn Sie eine neuere Version des Programmiersystems im gleichen Installationsverzeichnis wie die vorherige Version installieren, bleibt die Lizenzinformation zu den bereits installierten Packages erhalten und CODESYS zeigt die Information im Dialog Package Manager an. Updates Updates suchen Sucht auf Ihrem System und im CODESYS Store International Updates für das selektierte Package CODESYS zeigt gefundene Updates in der Spalte Update-Info der Package-Liste an. Download Installiert das Update-Package mit Hilfe des Dialogs Package download Im Dialog Package download klicken Sie dazu auf die Schaltfläche Download und Installation . Bewertung Abgabe einer Bewertung des Package CODESYS Store International Link zur Homepage des Stores Für weitere Informationen siehe: Package installieren\/deinstallieren" }, 
{ "title" : "Befehl: Bibliotheksrepository ", 
"url" : "_cds_cmd_library_repository.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Tools \/ Befehl: Bibliotheksrepository ", 
"snippet" : "Bibliotheksrepository Symbol: Funktion : Der Befehl öffnet den Dialog Bibliotheksrepository . In diesem Dialog legen Sie fest, welche Bibliotheken auf dem lokalen System installiert und damit für Ihre Applikation verfügbar sind. Aufruf : Menü Tools...", 
"body" : "Bibliotheksrepository Symbol: Funktion : Der Befehl öffnet den Dialog Bibliotheksrepository . In diesem Dialog legen Sie fest, welche Bibliotheken auf dem lokalen System installiert und damit für Ihre Applikation verfügbar sind. Aufruf : Menü Tools " }, 
{ "title" : "Dialog: Bibliotheksrepository ", 
"url" : "_cds_cmd_library_repository.html#UUID-e51f7153-0441-0423-efa0-7c686a5e982f_id_afbbe45c2ee4c0a8640e008206fd_id_009a224eb32511e3a3e2f1561f0d131d", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Tools \/ Befehl: Bibliotheksrepository \/ Dialog: Bibliotheksrepository ", 
"snippet" : "Speicherort Anzeige des Verzeichnisses auf dem lokalen System, in dem die Bibliotheksdateien liegen Die Bibliotheken dieses Speicherorts sind im Bereich Installierte Bibliotheken aufgelistet. Bearbeiten Öffnet den Dialog Repository-Speicherorte bearbeiten Sie können für neue Repositorys nur leere Ve...", 
"body" : "Speicherort Anzeige des Verzeichnisses auf dem lokalen System, in dem die Bibliotheksdateien liegen Die Bibliotheken dieses Speicherorts sind im Bereich Installierte Bibliotheken aufgelistet. Bearbeiten Öffnet den Dialog Repository-Speicherorte bearbeiten Sie können für neue Repositorys nur leere Verzeichnisse verwenden. Als Speicherort können Sie auch bestehende Repositorys verwenden. Das Repository System ist nicht editierbar. Dies wird durch die Kursivschrift des Eintrags angezeigt. Dialog Repository-Speicherorte bearbeiten Auflistung der Repositorys mit Speicherort und Name Hinzufügen Legt ein neues Repository an Öffnet den Dialog Speicherort für Repository Das ausgewählte Verzeichnis (Eingabefeld Ort ) muss leer sein oder ein bereits bestehendes gültiges Repository sein. Name ist das Eingabefeld für einen symbolischen Repository-Namen. Bearbeiten Öffnet den Dialog Speicherort für Repository (siehe Hinzufügen ) Entfernen Es erscheint eine Abfrage, ob nur der Eintrag aus der Liste der Repositorys entfernt werden soll, oder ob auch das Verzeichnis mit den Bibliotheksdateien aus dem Dateisystem gelöscht werden soll. Wenn Sie das Verzeichnis löschen wollen, müssen Sie dies bestätigen. Installierte Bibliotheken Liste der Bibliotheken in Baumstruktur Darstellung jeder Bibliothek mit Kategorie, Name, Firma und Version Am vorangestellten Icon erkennen Sie, ob die Bibliothek digital signiert oder unsigniert ist. kennzeichnet Bibliotheken im Quellformat, die nicht signiert werden können. Firma Auswahlliste zur Filterung der angezeigten Bibliotheken Installieren Öffnet den Dialog Bibliothek auswählen Mögliche Filter: Alle CODESYS Bibliotheken (*.compiled-library, *.compiled-library-v3, *.library) Übersetzte CODESYS Bibliotheken (*.compiled-library, *.compiled-library-v3) Quellbibliotheken (*.library) für noch nicht übersetzte, nicht signierbare Bibliotheksprojekte Alle Dateien (*.*) Deinstallieren Deinstalliert die selektierte Bibliothek Exportieren Öffnet den Standarddialog zum Speichern des Bibliotheksprojekts ins lokale Dateisystem Der Dateityp ist Bibliotheken (*.library) , Übersetzte Bibliotheken (*.compiled-library) oder Übersetzte Bibliotheken (*.compiled-library-v3) . Suchen Sucht Bibliotheken und Funktionsbausteine Öffnet den Dialog Bibliothek suchen Wenn Sie in das Eingabefeld eine Zeichenfolge eingeben, zeigt CODESYS die Bibliotheken mit gefundenen Übereinstimmungen an. Details Öffnet für die selektierte Version einer Bibliothek den Dialog Details mit Details aus den Projektinformationen der Bibliothek Über die Schaltfläche Mehr im Dialog Details erhalten Sie außerdem folgende Informationen: Größe : Angabe in Bytes Erzeugt : Erstellungsdatum Geändert : Datum der letzten Änderung Letzter Zugriff : Datum Attribute Eigenschaften Abhängigkeiten Öffnet für die ausgewählte Bibliothek den Dialog Abhängigkeiten zur Darstellung der Abhängigkeiten von anderen Bibliotheken Für jede Bibliotheksreferenz werden Titel , Version und Firma angezeigt. Referenzen, die über Platzhalter funktionieren, sind nach Syntax: #<Platzhaltername> dargestellt. Gruppieren nach Kategorie : Gruppierung nach Bibliothekskategorien : Alphabetische Sortierung Die Kategorien werden durch externe Beschreibungsdateien „*.libcat.xml“ definiert. Bibliotheksprofile Ein Bibliotheksprofil definiert, mit welcher Bibliotheksversion ein Bibliotheksplatzhalter automatisch aufgelöst wird, wenn eine bestimmte Compilerversion im Projekt gesetzt ist. Ab Version 3.5.18.0 wird das Bibliotheksprofil ignoriert. Importieren Importiert eine *.libraryprofile -Datei Wenn der Import bereits vorhandene Platzhalter-Einträge beinhaltet, erscheint eine Abfrage, ob CODESYS diese überschreiben soll. Exportieren Exportiert eine xml-Datei mit Erweiterung „ .libraryprofile “ mit den Zuordnungen der selektierten Platzhalter-Einträgen Sie können auch nur einen einzigen Eintrag einer Compilerversion selektieren. Platzhalter-Auflösungen können auch im gerade verwendeten Zielgerät definiert sein und sogar durch eine spezifische lokale Angabe im Platzhalter-Dialog im Bibliotheksverwalter. Wenn Sie ein Projekt mit einer Compilerversion < 3.5.18.0 laden wollen, ist es vorteilhaft, ein CODESYS mit passender Version zu installieren und damit das Projekt zu starten. Für weitere Informationen siehe: Bibliotheksverwalter und Konvertierung einer Bibliotheksreferenz" }, 
{ "title" : "Befehl: Lizenz-Manager ", 
"url" : "_cds_cmd_license_manager.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Tools \/ Befehl: Lizenz-Manager ", 
"snippet" : "Lizenz-Manager Symbol: Funktion : Der Befehl öffnet den Wizard für das Konfigurieren von Lizenzen für CODESYS -Zusatzprodukte. Der Wizard startet mit dem Dialog Lizenz-Manager - Zielgerät auswählen . Aufruf : Menü Tools Der Lizenz-Manager kann Lizenzen für CODESYS -Zusatzprodukte auf dem lokalen Com...", 
"body" : "Lizenz-Manager Symbol: Funktion : Der Befehl öffnet den Wizard für das Konfigurieren von Lizenzen für CODESYS -Zusatzprodukte. Der Wizard startet mit dem Dialog Lizenz-Manager - Zielgerät auswählen . Aufruf : Menü Tools Der Lizenz-Manager kann Lizenzen für CODESYS -Zusatzprodukte auf dem lokalen Computer, sowie Lizenzen für LZS-Erweiterungsprodukte auf Geräten handhaben. Er unterstützt sowohl die Installation in einem Softcontainer wie auch auf einem Dongle. Die Lizenzaktualisierung für Produkt-Abonnements erfolgt automatisch. Sie sehen den aktuellen Lizenzstatus im Lizenz-Manager . " }, 
{ "title" : "Dialog: Lizenz-Manager - Zielgerät auswählen ", 
"url" : "_cds_cmd_license_manager.html#UUID-4c91bfd0-6e5a-4a63-c33f-74e8df7f1048_id_ede5cbc7f814a56fc0a8640e0110cfc6_id_c2501cd1580911e887f0cb8e1905b970", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Tools \/ Befehl: Lizenz-Manager \/ Dialog: Lizenz-Manager - Zielgerät auswählen ", 
"snippet" : "Dies ist der Startdialog des Lizenz-Manager-Wizards. Hier entscheiden Sie, wo die Lizenz installiert werden soll. Workstation Lokaler Computer Gerät Steuerungsgerät Die Verbindung zu diesem Gerät muss korrekt konfiguriert sein, um die Lizenzierung durchführen zu können (Registerkarte Kommunikation d...", 
"body" : "Dies ist der Startdialog des Lizenz-Manager-Wizards. Hier entscheiden Sie, wo die Lizenz installiert werden soll. Workstation Lokaler Computer Gerät Steuerungsgerät Die Verbindung zu diesem Gerät muss korrekt konfiguriert sein, um die Lizenzierung durchführen zu können (Registerkarte Kommunikation des Geräteeditors). Nach Weiter entscheiden Sie, in welchem Container Sie die Lizenzen verwalten wollen. " }, 
{ "title" : "Dialog: Lizenz-Manager - Container auswählen ", 
"url" : "_cds_cmd_license_manager.html#UUID-4c91bfd0-6e5a-4a63-c33f-74e8df7f1048_id_ede5cbc7f814a56fc0a8640e0110cfc6_id_427f0789b3f411e3b5a0cccd02e48994", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Tools \/ Befehl: Lizenz-Manager \/ Dialog: Lizenz-Manager - Container auswählen ", 
"snippet" : "Dongle Ein entsprechender Dongle muss am Computer oder am Gerät aufgesteckt sein. Nicht jedes Gerät unterstützt Dongles. Softcontainer CODESYS Security Key Ein entsprechender Softcontainer muss im CodeMeter Kontrollzentrum registriert sein. Die CODESYS -Installation bringt bereits einen Softcontaine...", 
"body" : "Dongle Ein entsprechender Dongle muss am Computer oder am Gerät aufgesteckt sein. Nicht jedes Gerät unterstützt Dongles. Softcontainer CODESYS Security Key Ein entsprechender Softcontainer muss im CodeMeter Kontrollzentrum registriert sein. Die CODESYS -Installation bringt bereits einen Softcontainer mit. Wenn Sie dabei sind, ein Produkt auf Ihrem lokalen Rechner ( Workstation ) zu lizenzieren, erscheint nach der Entscheidung für einen er Containertypen und Weiter sofort der Dialog Lizenz-Manager für die konkrete Auswahl des Dongles oder Softcontainers und der nächsten Aktionen. Wenn Sie dabei sind, das Erweiterungsprodukt für ein Steuerungsgerät zu lizenzieren, erhalten Sie mit Weiter zunächst noch den Dialog zur Auswahl des Geräts im Netzwerk. Der Dialog entspricht der (klassischen Ansicht der) Registerkarte Kommunikation des Geräteeditors. " }, 
{ "title" : "Dialog: Lizenz-Manager - Übersicht ", 
"url" : "_cds_cmd_license_manager.html#UUID-4c91bfd0-6e5a-4a63-c33f-74e8df7f1048_id_ede5cbc7f814a56fc0a8640e0110cfc6_id_9842496a67cfbaa3c0a864630673a51d", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Tools \/ Befehl: Lizenz-Manager \/ Dialog: Lizenz-Manager - Übersicht ", 
"snippet" : "Lizenzen Liste aller installierten CODESYS -Produkte, die lizenzpflichtig sind und am Computer oder am Gerät gefunden werden. Wenn die Lizenzen über Container bereitstehen, werden die Container als Knoten in der Lizenzauflistung dargestellt. Ein vorangestelltes Symbol zeigt an, ob die Lizenz auf dem...", 
"body" : "Lizenzen Liste aller installierten CODESYS -Produkte, die lizenzpflichtig sind und am Computer oder am Gerät gefunden werden. Wenn die Lizenzen über Container bereitstehen, werden die Container als Knoten in der Lizenzauflistung dargestellt. Ein vorangestelltes Symbol zeigt an, ob die Lizenz auf dem Computer existiert und gültig ist. Rechts vom Fenster erscheint zum gerade selektierten Produkt und der\/den zugehörigen Lizenz(en) folgende Information: Name Firma Einheitenzähler Anzahl Lizenzen Verwendungszeitraum Feature-Liste Aktivierungszeitpunkt Ablaufzeitpunkt Firmcode Produktcode Beschreibung Lizenzen installieren Öffnet den Dialog Lizenzen auf <Computer> installieren - Operation wählen : Lizenz aktivieren : Öffnet den Dialog Lizenzen auf <Computer> installieren - Lizenz aktivieren , siehe weiter unten Lizenz anfordern : Öffnet den Dialog Lizenzen auf <Computer> installieren - Lizenz anfordern , siehe weiter unten Lizenzen installieren : Öffnet den Dialog Lizenzen auf <Computer> installieren - Lizenz installieren , siehe weiter unten Zusätzliche Funktionen Öffnet ein Menü mit den möglichen Aktionen: Blinken : Der zugehörige Lizenz-Dongle am Computer blinkt Lizenz zurückgeben : Öffnet den Dialog Lizenzen zurückgeben , siehe weiter unten Lizenz wiederherstellen : Diese Funktion ist nur im Fall einer Gerätelizenzierung verfügbar. Öffnet den Dialog Lizenzen wiederherstellen , siehe weiter unten Container aktualisieren : Die Auswahlliste mit allen gefundenen Containern wird neu erstellt. Lizenzen auf <Computer> installieren - Lizenz aktivieren Empfohlene Vorgehensweise zum Aktivieren einer Lizenz, die über einen Lizenz-Server im Internet zur Verfügung steht. Voraussetzung: der Computer verfügt über einen Internetzugang. Ticket-ID Eingabefeld für Ticket-ID, die Sie vom Softwareanbieter erhalten Ein Ticket-ID besteht aus 5 Blöcken mit jeweils 5 alphanumerischen Zeichen. Beispiel: LYSQ3-ZU93K-24LWC-XGWJ8-5AY7H Lizenz-Server Auswahlliste für den Lizenz-Server, der die Lizenz für die Aktivierung des Produkts bereitstellt Die URL des Servers erhalten Sie vom Softwareanbieter. Container Auswahlliste für den Container\/Dongle, auf dem die Lizenz installiert werden soll. Ticket aus Repository auswählen Öffnet den Dialog Lizenz-Repository Weiter CODESYS baut eine Verbindung zum Lizenz-Server auf. Wenn das angegebene Ticket nur 1 Lizenz enthält, erscheint nach Abschluss der Serveraktion ein Dialog mit der Bestätigung der erfolgreichen Aktivierung. Wenn das angegebene Ticket mehrere Lizenzen enthält, erscheint der Dialog Lizenzen installieren - Lizenzen auswählen mit der Liste dieser Lizenzen, siehe nachfolgende Beschreibung. Lizenzen installieren - Lizenzen auswählen Auswahl der zu aktivierenden Lizenzen für das Ticket, das Sie im Dialog Lizenzen installieren - Lizenz aktivieren angegeben haben Name Name des Produkts Verfügbar Anzahl noch verfügbarer Lizenzen Verwendet Anzahl bereits verwendeter Lizenzen Gesamt Summe bereits verwendeter und noch verfügbarer Lizenzen Weiter CODESYS baut eine Verbindung zum Lizenz-Server auf. Nach erfolgreichem Abschluss der Serveraktion erscheint ein Dialog mit der Bestätigung der Aktivierung. Lizenzen auf <Computer> installieren - Lizenz anfordern Wenn der Computer keinen Internetzugang besitzt, können Sie mit Hilfe dieses Dialogs eine Kontextdatei erzeugen. Diese Datei (WibuCmRaC) wird über einen internetfähigen Computer an den Lizenz-Server übertragen. Nach der Aktivierung steht eine Lizenz-Update-Datei (WibuCmRaU) zum Download zur Verfügung. Softwareanbieter Eingabefeld für Firmcodes des Softwareanbieters, der die Lizenz zur Aktivierung des Produkts bereitstellt Alternativ können Sie den Softwareanbieter aus der Auswahlliste auswählen. Container Auswahlliste für den Container\/Dongle, für den die Kontextdatei erzeugt werden soll. Kontext-Datei Speicherort und Namen Lizenzen auf <Computer> installieren - Lizenz installieren Wenn Sie während der Software-Aktivierung eine Lizenzaktualisierungsdatei über das Internet heruntergeladen haben, können Sie die Lizenz mit Hilfe dieses Dialogs auf Ihrem Dongle installieren. Dazu geben Sie bei Container den gewünschten Container\/Dongle an und im Eingabefeld bei Datei den Pfad der Lizenzaktualisierungsdatei. Lizenz zurückgeben Wenn die Lizenz es zulässt, können Sie sie „zurückgeben“, um sie danach auf einem anderen System wieder zu aktivieren. Ticket-ID Feld für die Eingabe der Ticket-ID, die für die Lizenzierung verwendet worden war Lizenz-Server Auswahlliste zur Auswahl des Lizenz-Servers, der die Lizenz für die Aktivierung des Produkts bereitstellt Die URL des Servers erhalten Sie vom Softwareanbieter. Lizenz(en) laden Schaltfläche zum Anzeigen aller aktuell für die angegebene Ticket-ID auf dem Server installierten Lizenzen in das Fenster Lizenzen Lizenzen Auflistung der Lizenzen, die für die angegebene Ticket-ID auf dem Server liegen Rechts neben dem Fenster erscheint für die jeweils selektierte Lizenz folgende Information: Name Anzahl Aktivierungen Rückgabe erlaubt Aktivierungstyp Aktivierungsdatum Firmcode Kommentar Lizenz(en) zurückgeben Schaltfläche zur Rückgabe der selektierten Lizenz(en) Diese können danach auf einem anderen System wieder aktiviert werden. Lizenzen installieren - Lizenzen wiederherstellen Gerätelizenzen werden beim Aktivieren in eine Datei ( *.WibuCmRau ) sowohl auf dem lokalen Computer als auch im „ CODESYS Central License Server“ gesichert und können bei Verlust aus dieser Datei auf dem identischen Gerät wiederhergestellt werden. Dieses Verfahren funktioniert nur für Lizenzen, die mit 128... beginnen und die CodeMeter Embedded verwenden: CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ Für neuere, UFC-basierte Lizenzen, die mit 130... beginnen siehe: Sichern und Wiederherstellen von Wibu SL-Lizenzen Ticket-ID Feld für die Eingabe der Ticket-ID, die für die bereits einmal erfolgte Lizenzierung verwendet worden war Wiederherstellen Wenn eine entsprechende Lizenzsicherungsdatei gefunden wird, wird die Lizenz auf dem Gerät wieder aktiviert. Für weitere Informationen siehe: Lizenz-Repository" }, 
{ "title" : "Befehl: Lizenz-Repository ", 
"url" : "_cds_cmd_license_repository.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Tools \/ Befehl: Lizenz-Repository ", 
"snippet" : "Lizenz-Repository Symbol: Funktion : Der Befehl öffnet den Dialog Lizenz-Repository zur Ansicht von Informationen zu einzelnen Lizenzen. Aufruf : Menü Tools Voraussetzung : CODESYS ist im Offline- oder Onlinebetrieb. Im Lizenz-Repository erhalten Sie nach Angabe der Ticket-Nummer vom zentralen Lizen...", 
"body" : "Lizenz-Repository Symbol: Funktion : Der Befehl öffnet den Dialog Lizenz-Repository zur Ansicht von Informationen zu einzelnen Lizenzen. Aufruf : Menü Tools Voraussetzung : CODESYS ist im Offline- oder Onlinebetrieb. Im Lizenz-Repository erhalten Sie nach Angabe der Ticket-Nummer vom zentralen Lizenz-Server Informationen zu den betreffenden Lizenzen. Sie können dazu die Ticket-Nummer(n) aus der Zwischenablage einfügen oder aus einer Textdatei importieren. Tickets <Liste der ins Repository importierten Ticket-IDs für lizenzpflichtige Komponenten> Lizenzen Wenn Sie in der Liste der Tickets einen Eintrag selektieren, wird hier der Name und der Status der lizenzierten Komponente angezeigt. : Die Lizenz is vorhanden und gültig. : Die Lizenz wurde gefunden, aber sie ist ungültig. : Die Lizenz wurde nicht gefunden. Im rechten Teil des Dialogs erhalten Sie dann folgende Informationen zu dieser Lizenz: Name : Name des zu lizenzierenden Produkts Artikelnummer : Artikelnummer im Lizenz-Server Rückgabe erlaubt : Es ist möglich, diese Lizenz deaktivieren zu lassen, so dass sie auf einem anderen System wieder aktiviert werden kann. Aktivierbar : Sie können die Lizenz über den Lizenz-Manager aktiveren lassen. Anzahl Aktivierungen : Bisherige Anzahl erfolgter Aktivierungen Aktivierungsdatum : Datum der aktuellen Aktivierung Container-Seriennummer Firmcodes Kommentar Tickets importieren Der Standarddialog zum Durchsuchen des lokalen Dateisystems erscheint. Wenn Sie eine Textdatei öffnen, die eine oder mehrere „Tickets“, also Lizenznummern enthält, werden diese ins Repository importiert. Alternativ können Sie die Nummern auch aus der Zwischenablage in die Liste einfügen. Für weitere Informationen siehe: Packages und Lizenzen verwalten und Lizenz-Manager" }, 
{ "title" : "Befehl: Geräte-Repository ", 
"url" : "_cds_cmd_device_repository.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Tools \/ Befehl: Geräte-Repository ", 
"snippet" : "Geräte-Repository Symbol: Funktion : Der Befehl öffnet den Dialog Geräte-Repository . Dieser Dialog dient der Verwaltung der Geräte, die auf dem lokalen System installiert sind und in CODESYS -Projekte eingebunden werden können. Aufruf : Menü Tools...", 
"body" : "Geräte-Repository Symbol: Funktion : Der Befehl öffnet den Dialog Geräte-Repository . Dieser Dialog dient der Verwaltung der Geräte, die auf dem lokalen System installiert sind und in CODESYS -Projekte eingebunden werden können. Aufruf : Menü Tools " }, 
{ "title" : "Dialog: Geräte-Repository ", 
"url" : "_cds_cmd_device_repository.html#UUID-c7973f6f-9c3e-2045-8831-d042c5a98295_id_ad0cf3f4f3c53320c0a8640e00a42838_id_8c4c14bcb0f111e3bd3cdc72696803d0", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Tools \/ Befehl: Geräte-Repository \/ Dialog: Geräte-Repository ", 
"snippet" : "Sie dürfen das interne Geräte-Repository nicht manuell verändern. Sie dürfen keine Dateien ins Repository oder von dort woandershin kopieren! Sie müssen immer den Geräte-Repository-Dialog verwenden, um Geräte zu installieren oder zu deinstallieren! Speicherort Anzeige der Geräte-Repository-Verzeichn...", 
"body" : "Sie dürfen das interne Geräte-Repository nicht manuell verändern. Sie dürfen keine Dateien ins Repository oder von dort woandershin kopieren! Sie müssen immer den Geräte-Repository-Dialog verwenden, um Geräte zu installieren oder zu deinstallieren! Speicherort Anzeige der Geräte-Repository-Verzeichnisse auf dem lokalen System Die Auswahlliste zeigt die aktuell eingerichteten Speicherorte. Standardmäßig legt CODESYS mit der Installation das System-Repository an. Die Geräte des ausgewählten Speicherorts werden im Bereich Installierte Gerätebeschreibungen aufgelistet. Bearbeiten Öffnet den Dialog Repository-Speicherorte ändern Dialog Repository-Speicherorte ändern Auflistung der Repositorys mit Speicherort und Name Hinzufügen Legt ein neues Repository an Öffnet den Dialog Repository Speicherort Das ausgewählte Verzeichnis (Eingabefeld Speicherort ) muss leer oder ein bereits bestehendes gültiges Repository sein. Bearbeiten Öffnet den Dialog Repository Speicherort (siehe Hinzufügen) Entfernen Es erscheint eine Abfrage, ob das entsprechende Verzeichnis auch von der Festplatte gelöscht werden soll. Installierte Gerätebeschreibungen Auflistung der Gerätebeschreibungen in mehrstufiger Baumstruktur Darstellung jeder Gerätebeschreibungen mit Name , Hersteller und Version Die obersten Knotenpunkte stellen Gerätekategorien dar, beispielsweise Steuerungen, Feldbusse oder logische Geräte. Zeichenfolge für die Volltextsuche in allen Geräten Durch einen Klick in dieses Feld wird es editierbar. Wenn Sie eine beliebige Zeichenkette eingeben, werden im unteren Fenster nur die Geräte angezeigt, die die Zeichenkette beinhalten. Die übereinstimmende Zeichenkette ist bei diesen Geräten gelb markiert. Hersteller Auswahlliste mit Herstellern, deren verfügbare Geräte angezeigt werden Installieren Öffnet den Dialog Installiere Gerätebeschreibung Für die Standardgeräte des Dateityps „.devdesc.xml“ Sie können auch herstellerspezifische Beschreibungsdateien, wie zum Beispiel „*gsd“-Dateien für PROFIBUS DP Module, *.eds- und dcf-Dateien für CAN-Geräte auswählen. Wenn Sie die Auswahl mit OK bestätigen, fügt CODESYS das neue Gerät im Geräte-Repository ein. Fehler während der Installation (zum Beispiel fehlende Dateien, die von der Gerätebeschreibung referenziert werden) gibt CODESYS im unteren Teil des Geräte-Repository-Dialogs aus. Deinstallieren Deinstalliert das selektierte Gerät Wenn Sie das Gerät aus dem Geräte-Repository löschen, steht es für die Verwendung im Programmiersystem nicht mehr zur Verfügung. Geräte-Repository erneuern Aktualisiert alle Geräte im Geräte-Repository Wenn neue Versionen von Import-Plug-Ins verfügbar sind, können einige Gerätebeschreibungen veraltet sein. Die betroffenen Geräte sind mit dem Symbol gekennzeichnet. Der Befehl öffnet einen Dialog zur Bestätigung des Updates. Download fehlender Beschreibungen Erscheint, wenn Sie Geräte in Ihrem Projekt verwenden, die im Geräte-Repository nicht vorhanden sind Wenn Sie den Befehl ausführen, erscheint eine Liste mit den fehlenden Geräten. Darin können Sie die entsprechenden Geräte auswählen für den Download auswählen. Details Öffnet den Dialog Details für die selektierte Gerätebeschreibung Der Dialog enthält zusätzliche Informationen aus der Gerätebeschreibungsdatei. Während der Installation kopiert CODESYS die Gerätebeschreibungsdateien und alle zusätzlichen Dateien, die von dieser referenziert werden, an einen internen Speicherort. Somit haben Änderungen an den Originaldateien keinen Effekt mehr auf die installierten Geräte. Um solche Änderungen wirksam werden zu lassen, müssen Sie die Geräte neu installieren. Es wird empfohlen, die interne Versionsnummer einer Gerätebeschreibung nach einer Modifikation zu verändern. " }, 
{ "title" : "Befehl: Anpassen ", 
"url" : "_cds_cmd_customize.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Tools \/ Befehl: Anpassen ", 
"snippet" : "Anpassen Funktion : Der Befehl öffnet den Dialog Anpassen . In diesem Dialog passen Sie die Menüs, die Symbolleisten und die Tastaturbelegung Ihren individuellen Anforderungen an. Aufruf : Menü Tools Für weitere Informationen siehe: Menüs anpassen...", 
"body" : "Anpassen Funktion : Der Befehl öffnet den Dialog Anpassen . In diesem Dialog passen Sie die Menüs, die Symbolleisten und die Tastaturbelegung Ihren individuellen Anforderungen an. Aufruf : Menü Tools Für weitere Informationen siehe: Menüs anpassen" }, 
{ "title" : "Befehl: Optionen ", 
"url" : "_cds_cmd_options.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Tools \/ Befehl: Optionen ", 
"snippet" : "Optionen Funktion : Der Befehl öffnet den Dialog Optionen zur Konfiguration der CODESYS -Optionen. Diese Optionen definieren das Verhalten und Aussehen der CODESYS -Benutzeroberfläche. CODESYS speichert die Einstellungen in Ihrem aktuellen Benutzerprofil auf Ihrem lokalen System. Das aktuelle Profil...", 
"body" : "Optionen Funktion : Der Befehl öffnet den Dialog Optionen zur Konfiguration der CODESYS -Optionen. Diese Optionen definieren das Verhalten und Aussehen der CODESYS -Benutzeroberfläche. CODESYS speichert die Einstellungen in Ihrem aktuellen Benutzerprofil auf Ihrem lokalen System. Das aktuelle Profil gibt die Standardeinstellungen vor. Aufruf : Menü Tools " }, 
{ "title" : "Befehl: Optionen importieren und exportieren ", 
"url" : "_cds_cmd_import_export_options.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Tools \/ Befehl: Optionen importieren und exportieren ", 
"snippet" : "Optionen importieren und exportieren Funktion : Der Befehl öffnet den Dialog Optionen importieren und exportieren . Hier können Sie den Export oder Import von ausgewählten Einstellungen der CODESYS -Optionen konfigurieren. Die Einstellungen werden beim Export in eine XML-Datei mit der Standarderweit...", 
"body" : "Optionen importieren und exportieren Funktion : Der Befehl öffnet den Dialog Optionen importieren und exportieren . Hier können Sie den Export oder Import von ausgewählten Einstellungen der CODESYS -Optionen konfigurieren. Die Einstellungen werden beim Export in eine XML-Datei mit der Standarderweiterung options.xml gespeichert. Aufruf : Menü Tools " }, 
{ "title" : "Dialog: Optionen importieren und exportieren ", 
"url" : "_cds_cmd_import_export_options.html#UUID-25bc3cff-9cbf-00c6-2e4e-eb5e83058ec6_id_f16f26eccdc7cec0a864631a9a7d9e_id_290c9402ed02fe4ec0a864633381844a", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Tools \/ Befehl: Optionen importieren und exportieren \/ Dialog: Optionen importieren und exportieren ", 
"snippet" : "Ausgewählte Optionen exportieren Optionen auswählen : In der Tabelle können Sie die Kategorien von maschinen (Computer)- oder benutzerbezogenen Optionen auswählen, deren aktuelle Einstellungen in die XML-Datei exportiert werden sollen. Datei : Pfad der Exportdatei im lokalen Dateisystem Beispiel: D:...", 
"body" : "Ausgewählte Optionen exportieren Optionen auswählen : In der Tabelle können Sie die Kategorien von maschinen (Computer)- oder benutzerbezogenen Optionen auswählen, deren aktuelle Einstellungen in die XML-Datei exportiert werden sollen. Datei : Pfad der Exportdatei im lokalen Dateisystem Beispiel: D:\\system1.options.xml Schaltfläche : Öffnet den Standarddialog zum Suchen nach einer bestehenden, oder zum Anlegen einer neuen Datei im lokalen Dateisystem Der Dateityp Optionenexport (*.options.xml) ist voreingestellt. Ausgewählte Optionen importieren Datei : Pfad der Optionenexportdatei, deren Inhalt importiert werden soll Schaltfläche : Öffnet den Standarddialog zum Suchen nach einer Datei des Typs Optionenexport (*.options.xml) im lokalen Dateisystem Nach Schließen des Dialogs mit OK werden die in der Datei beschriebenen Einstellungen ins Projekt übernommen. Für weitere Informationen siehe: CODESYS" }, 
{ "title" : "Befehl: Installationskonfiguration exportieren ", 
"url" : "_cds_cmd_export_installation_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Tools \/ Befehl: Installationskonfiguration exportieren ", 
"snippet" : "Installationskonfiguration exportieren Funktion : Der Befehl exportiert die Konfigurationsdatei der aktuellen CODESYS -Installation in eine Datei mit dem Format .installation-config . Die Exportdatei enthält Informationen zur Version von CODESYS und der installierten Add-ons. Die Installationskonfig...", 
"body" : "Installationskonfiguration exportieren Funktion : Der Befehl exportiert die Konfigurationsdatei der aktuellen CODESYS -Installation in eine Datei mit dem Format .installation-config . Die Exportdatei enthält Informationen zur Version von CODESYS und der installierten Add-ons. Die Installationskonfiguration ist standardmäßig im Projektarchiv enthalten, das mit dem Befehl Datei → Projektarchiv → Archiv speichern erstellt wird. Aufruf : Menü Tools " }, 
{ "title" : "Befehl: Device License Reader ", 
"url" : "_cds_cmd_device_reader.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Tools \/ Befehl: Device License Reader ", 
"snippet" : "Device License Reader Funktion : Der Befehl öffnet den Standarddialog Gerät auswählen und liest nach Auswahl einer Steuerung die Lizenz- und Produktinformationen dieser Steuerung aus. Diese Lizenz- und Produktinformationen werden im Dialog Device License Reader angezeigt. Aufruf : Menü Tools Vorauss...", 
"body" : "Device License Reader Funktion : Der Befehl öffnet den Standarddialog Gerät auswählen und liest nach Auswahl einer Steuerung die Lizenz- und Produktinformationen dieser Steuerung aus. Diese Lizenz- und Produktinformationen werden im Dialog Device License Reader angezeigt. Aufruf : Menü Tools Voraussetzung : Auf der Steuerung befindet sich keine Applikation. Wenn der Befehl gewählt wird, obwohl sich auf der Steuerung eine Applikation befindet, wird der Anwender in einem Dialog gefragt, ob alle Applikationen von der Steuerung entfernt werden sollen. Wenn der Benutzer in diesem Dialog auf Nein klickt, wird der Befehl Device License Reader abgebrochen. Dialog Device License Reader Status der verfügbaren Geräte-Features Produkt CODESYS -Produkt Beispiel: SoftMotion Feature Feature von Produkt Beispiel: CNC ist ein Feature von SoftMotion . Lizenz Aktiv\/Anzahl Yes : Für das Feature ist eine Lizenz vorhanden. No : Für das Feature ist keine Lizenz vorhanden. Anzahl : Anzahl der Lizenzen " }, 
{ "title" : "Fenster ", 
"url" : "_cds_f_commands_window.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: Nächster Editor ", 
"url" : "_cds_cmd_next_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehl: Nächster Editor ", 
"snippet" : "Nächster Editor Tastaturkürzel: Strg + F6 Funktion : Der Befehl schaltet den Focus vom gerade aktiven Fenster auf das nächste Fenster. Dabei ist das „nächste“ Fenster das, dessen Registerkarte rechts vom gerade aktiven liegt. Aufruf : Menü Fenster Voraussetzung : Es ist mindestens ein Editor geöffne...", 
"body" : "Nächster Editor Tastaturkürzel: Strg + F6 Funktion : Der Befehl schaltet den Focus vom gerade aktiven Fenster auf das nächste Fenster. Dabei ist das „nächste“ Fenster das, dessen Registerkarte rechts vom gerade aktiven liegt. Aufruf : Menü Fenster Voraussetzung : Es ist mindestens ein Editor geöffnet. " }, 
{ "title" : "Befehl: Vorheriger Editor ", 
"url" : "_cds_cmd_previous_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehl: Vorheriger Editor ", 
"snippet" : "Vorheriger Editor Tastaturkürzel: Umschalt + Strg + F6 Funktion : Der Befehl schaltet den Focus vom gerade aktiven Fenster auf das vorherigen Fenster. Dabei ist das „vorherigen“ Fenster das, dessen Registerkarte links vom gerade aktiven liegt. Aufruf : Menü Fenster Voraussetzung : Es ist mindestens ...", 
"body" : "Vorheriger Editor Tastaturkürzel: Umschalt + Strg + F6 Funktion : Der Befehl schaltet den Focus vom gerade aktiven Fenster auf das vorherigen Fenster. Dabei ist das „vorherigen“ Fenster das, dessen Registerkarte links vom gerade aktiven liegt. Aufruf : Menü Fenster Voraussetzung : Es ist mindestens ein Editor geöffnet. " }, 
{ "title" : "Befehl: Alle Editoren schließen ", 
"url" : "_cds_cmd_close_all_editors.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehl: Alle Editoren schließen ", 
"snippet" : "Alle Editoren schließen Symbol: Funktion : Der Befehl schließt alle gerade geöffneten Editorfenster. Aufruf : Menü Fenster Voraussetzung : Es ist mindestens ein Editor geöffnet....", 
"body" : "Alle Editoren schließen Symbol: Funktion : Der Befehl schließt alle gerade geöffneten Editorfenster. Aufruf : Menü Fenster Voraussetzung : Es ist mindestens ein Editor geöffnet. " }, 
{ "title" : "Befehl: Alle Editoren inaktiver Applikationen schließen ", 
"url" : "_cds_cmd_close_all_editors_of_inactive_applications.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehl: Alle Editoren inaktiver Applikationen schließen ", 
"snippet" : "Alle Editoren inaktiver Applikationen schließen Funktion : Der Befehl schließt alle Editorfenster von Objekten, die direkt unter einer gerade nicht aktiven Applikation hängen. Editoren von Objekten der POU-Ansicht bleiben geöffnet. Aufruf : Menü Fenster Voraussetzung : Es ist mindestens ein Editor e...", 
"body" : "Alle Editoren inaktiver Applikationen schließen Funktion : Der Befehl schließt alle Editorfenster von Objekten, die direkt unter einer gerade nicht aktiven Applikation hängen. Editoren von Objekten der POU-Ansicht bleiben geöffnet. Aufruf : Menü Fenster Voraussetzung : Es ist mindestens ein Editor einer nicht aktiven Applikation geöffnet. " }, 
{ "title" : "Befehl: Fenster-Layout zurücksetzen ", 
"url" : "_cds_cmd_reset_window_layout.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehl: Fenster-Layout zurücksetzen ", 
"snippet" : "Fenster-Layout zurücksetzen Funktion : Der Befehl setzt alle gerade geöffneten Fenster und Ansichten auf ihre Standardpositionen zurück. Sie müssen den Befehl vor der Ausführung bestätigen. Aufruf : Menü Tools...", 
"body" : "Fenster-Layout zurücksetzen Funktion : Der Befehl setzt alle gerade geöffneten Fenster und Ansichten auf ihre Standardpositionen zurück. Sie müssen den Befehl vor der Ausführung bestätigen. Aufruf : Menü Tools " }, 
{ "title" : "Befehl: Neue horizontale Registerkarten-Gruppe ", 
"url" : "_cds_cmd_new_horizontal_tab_group.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehl: Neue horizontale Registerkarten-Gruppe ", 
"snippet" : "Neue horizontale Registerkarten-Gruppe Symbol: Funktion : Der Befehl verschiebt das gerade aktive Fenster in eine neue, separate Registerkarten-Gruppe unterhalb der bereits existierenden. Aufruf : Menü Fenster , Kontextmenü der Registerkarte Voraussetzung : Es sind mehrere Editorfenster als Register...", 
"body" : "Neue horizontale Registerkarten-Gruppe Symbol: Funktion : Der Befehl verschiebt das gerade aktive Fenster in eine neue, separate Registerkarten-Gruppe unterhalb der bereits existierenden. Aufruf : Menü Fenster , Kontextmenü der Registerkarte Voraussetzung : Es sind mehrere Editorfenster als Registerblätter nebeneinander angeordnet. Wenn Sie ein weiteres Objekt im Editor öffnen, wird dies automatisch in die Registerkarten-Gruppe eingeordnet, in der der Fokus liegt. " }, 
{ "title" : "Befehl: Neue vertikale Registerkarten-Gruppe ", 
"url" : "_cds_cmd_new_vertical_tab_group.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehl: Neue vertikale Registerkarten-Gruppe ", 
"snippet" : "Neue vertikale Registerkarten-Gruppe Symbol: Funktion : Der Befehl verschiebt das gerade aktive Fenster in eine neue, separate Registerkarten-Gruppe rechts von der bereits existierenden. Aufruf : Menü Fenster , Kontextmenü der Registerkarte Voraussetzung : Es sind mehrere Editorfenster als Registerb...", 
"body" : "Neue vertikale Registerkarten-Gruppe Symbol: Funktion : Der Befehl verschiebt das gerade aktive Fenster in eine neue, separate Registerkarten-Gruppe rechts von der bereits existierenden. Aufruf : Menü Fenster , Kontextmenü der Registerkarte Voraussetzung : Es sind mehrere Editorfenster als Registerblätter nebeneinander angeordnet. Wenn Sie ein weiteres Objekt im Editor öffnen, wird dies automatisch in die Registerkarten-Gruppe eingeordnet, in der der Fokus liegt. " }, 
{ "title" : "Befehl: Unverankert ", 
"url" : "_cds_cmd_window_float.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehl: Unverankert ", 
"snippet" : "Unverankert Funktion : Der Befehl dient dazu, ein Fenster, das am Rahmen der Benutzeroberfläche angedockt (fixiert) ist, vom Rahmen zu lösen und als unverankertes Fenster auf dem Bildschirm zu platzieren. Aufruf : Menü Fenster Voraussetzung : Die Applikation ist im Onlinebetrieb. Dieses Fenster kann...", 
"body" : "Unverankert Funktion : Der Befehl dient dazu, ein Fenster, das am Rahmen der Benutzeroberfläche angedockt (fixiert) ist, vom Rahmen zu lösen und als unverankertes Fenster auf dem Bildschirm zu platzieren. Aufruf : Menü Fenster Voraussetzung : Die Applikation ist im Onlinebetrieb. Dieses Fenster kann dann auch außerhalb der Benutzeroberfläche platziert werden. Um ein unverankertes Fenster wieder an den Rahmen der Benutzeroberfläche zu binden, verwendet man den Befehl Andocken . " }, 
{ "title" : "Befehl: Andocken ", 
"url" : "_cds_cmd_window_dock.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehl: Andocken ", 
"snippet" : "Andocken Funktion : Der Befehl dient dazu, ein Fenster, das vorher dem Befehl Unverankert gelöst wurde und nun als unverankertes Fenster auf dem Bildschirm liegt, wieder an den Rahmen der Benutzeroberfläche „anzudocken“. Aufruf : Menü Fenster...", 
"body" : "Andocken Funktion : Der Befehl dient dazu, ein Fenster, das vorher dem Befehl Unverankert gelöst wurde und nun als unverankertes Fenster auf dem Bildschirm liegt, wieder an den Rahmen der Benutzeroberfläche „anzudocken“. Aufruf : Menü Fenster " }, 
{ "title" : "Befehl: Ausblenden ", 
"url" : "_cds_cmd_window_autohide.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehl: Ausblenden ", 
"snippet" : "Ausblenden Tastaturkürzel: F7 Funktion : Der Befehl dient dazu, ein Fenster „aus- oder einzublenden“. Aufruf : Menü Fenster „Ausblenden“ bedeutet, dass CODESYS das Fenster nur mehr als ein Reiter im Rahmen der Benutzeroberfläche anzeigt und es nur sichtbar wird, wenn Sie die Maus über diesen Reiter ...", 
"body" : "Ausblenden Tastaturkürzel: F7 Funktion : Der Befehl dient dazu, ein Fenster „aus- oder einzublenden“. Aufruf : Menü Fenster „Ausblenden“ bedeutet, dass CODESYS das Fenster nur mehr als ein Reiter im Rahmen der Benutzeroberfläche anzeigt und es nur sichtbar wird, wenn Sie die Maus über diesen Reiter bewegen. Der Befehl funktioniert als Option, d. h. bei einem ausgeblendeten Fenster erscheint er mit einem davor gesetzten Haken im Menü. Wenn Sie den Befehl erneut Anklicken wird der Haken entfernt und das Fenster wieder eingeblendet. " }, 
{ "title" : "Befehl: Nächstes Teilfenster ", 
"url" : "_cds_cmd_next_pane.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehl: Nächstes Teilfenster ", 
"snippet" : "Nächstes Teilfenster Tastaturkürzel: F6 Funktion : Dieser Befehl setzt den Fokus in das nächste Teilfenster. Aufruf : Menü Fenster Voraussetzung : Es ist ein Objekt geöffnet, das zwei oder mehr Teilfenster enthält. Beispiel: Wenn Sie ein Objekt im ST-Editor geöffnet haben und der Cursor gerade im De...", 
"body" : "Nächstes Teilfenster Tastaturkürzel: F6 Funktion : Dieser Befehl setzt den Fokus in das nächste Teilfenster. Aufruf : Menü Fenster Voraussetzung : Es ist ein Objekt geöffnet, das zwei oder mehr Teilfenster enthält. Beispiel: Wenn Sie ein Objekt im ST-Editor geöffnet haben und der Cursor gerade im Deklarationsfenster steht, wird der Fokus mit dem Befehl in den Implementierungsteil gesetzt. " }, 
{ "title" : "Befehl: Vorheriges Teilfenster ", 
"url" : "_cds_cmd_previous_pane.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehl: Vorheriges Teilfenster ", 
"snippet" : "Vorheriges Teilfenster Tastaturkürzel: Umschalt + F6 Funktion : Dieser Befehl setzt den Fokus in das vorherige Teilfenster. Aufruf : Menü Fenster Voraussetzung : Es ist ein Objekt geöffnet, das zwei oder mehr Teilfenster enthält. Beispiel: Wenn Sie ein Objekt im ST-Editor geöffnet haben und der Curs...", 
"body" : "Vorheriges Teilfenster Tastaturkürzel: Umschalt + F6 Funktion : Dieser Befehl setzt den Fokus in das vorherige Teilfenster. Aufruf : Menü Fenster Voraussetzung : Es ist ein Objekt geöffnet, das zwei oder mehr Teilfenster enthält. Beispiel: Wenn Sie ein Objekt im ST-Editor geöffnet haben und der Cursor gerade im Deklarationsfenster steht, wird der Fokus mit dem Befehl in den Implementierungsteil gesetzt. " }, 
{ "title" : "Befehl: Erste Teilansicht umschalten ", 
"url" : "_cds_cmd_toggle_first_pane.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehl: Erste Teilansicht umschalten ", 
"snippet" : "Erste Teilansicht umschalten Tastaturkürzel: Alt + F6 Funktion : Der Befehl blendet das Deklarationsfenster aus\/ein. Aufruf : Menü Fenster Voraussetzung : Der Cursor steht im Editor eines der folgenden Objekte: POU Transition Methode Get-Accessor-Methode einer Eigenschaft Set-Accessor-Methode einer ...", 
"body" : "Erste Teilansicht umschalten Tastaturkürzel: Alt + F6 Funktion : Der Befehl blendet das Deklarationsfenster aus\/ein. Aufruf : Menü Fenster Voraussetzung : Der Cursor steht im Editor eines der folgenden Objekte: POU Transition Methode Get-Accessor-Methode einer Eigenschaft Set-Accessor-Methode einer Eigenschaft Visualisierung Sie können die Teilansichten auch mit Hilfe der Schaltflächen umschalten. " }, 
{ "title" : "Befehl: Zweite Teilansicht umschalten ", 
"url" : "_cds_cmd_toggle_second_pane.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehl: Zweite Teilansicht umschalten ", 
"snippet" : "Zweite Teilansicht umschalten Funktion : Der Befehl blendet das Implementierungsfenster aus\/ein. Aufruf : Menü Fenster Voraussetzung : Der Cursor steht im Editor eines der folgenden Objekte: POU Transition Methode Get-Accessor-Methode einer Eigenschaft Set-Accessor-Methode einer Eigenschaft Visualis...", 
"body" : "Zweite Teilansicht umschalten Funktion : Der Befehl blendet das Implementierungsfenster aus\/ein. Aufruf : Menü Fenster Voraussetzung : Der Cursor steht im Editor eines der folgenden Objekte: POU Transition Methode Get-Accessor-Methode einer Eigenschaft Set-Accessor-Methode einer Eigenschaft Visualisierung Sie können die Teilansichten auch mit Hilfe der Schaltflächen umschalten. " }, 
{ "title" : "Befehl: Fenster ", 
"url" : "_cds_cmd_window.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehl: Fenster ", 
"snippet" : "Fenster Funktion : Der Befehl öffnet den Dialog Fenster , der Ihnen alle geöffneten Objekte zeigt. Sie können darin Fenster aktivieren oder schließen. Aufruf : Menü Fenster...", 
"body" : "Fenster Funktion : Der Befehl öffnet den Dialog Fenster , der Ihnen alle geöffneten Objekte zeigt. Sie können darin Fenster aktivieren oder schließen. Aufruf : Menü Fenster " }, 
{ "title" : "Befehl: Alle Editoren außer diesem hier schließen ", 
"url" : "_cds_cmd_close_all_editor_but_this.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehl: Alle Editoren außer diesem hier schließen ", 
"snippet" : "Alle Editoren außer diesem hier schließen Funktion : Dieser Befehl schließt alle Editorfenster außer dem aktuellen. Aufruf : Kontextmenü der Registerkarte Voraussetzung : Es sind mindestens zwei Objekte geöffnet....", 
"body" : "Alle Editoren außer diesem hier schließen Funktion : Dieser Befehl schließt alle Editorfenster außer dem aktuellen. Aufruf : Kontextmenü der Registerkarte Voraussetzung : Es sind mindestens zwei Objekte geöffnet. " }, 
{ "title" : "Befehl: Objekt im Navigator anwählen ", 
"url" : "_cds_cmd_select_object_in_navigator.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehl: Objekt im Navigator anwählen ", 
"snippet" : "Objekt im Navigator anwählen Funktion : Dieser Befehl selektiert das Objekt des aktiven Editors im Gerätebaum. Aufruf : Kontextmenü der Registerkarte Voraussetzung : Es ist mindestens ein Objekt geöffnet. Dieser Befehl wird automatisch ausgeführt, wenn Sie im Gerätebaum die Option Aktiven Editor ver...", 
"body" : "Objekt im Navigator anwählen Funktion : Dieser Befehl selektiert das Objekt des aktiven Editors im Gerätebaum. Aufruf : Kontextmenü der Registerkarte Voraussetzung : Es ist mindestens ein Objekt geöffnet. Dieser Befehl wird automatisch ausgeführt, wenn Sie im Gerätebaum die Option Aktiven Editor verfolgen aktivieren. " }, 
{ "title" : "Befehl: Elternobjekt im Navigator anwählen ", 
"url" : "_cds_cmd_select_parent_object_in_navigator.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehl: Elternobjekt im Navigator anwählen ", 
"snippet" : "Elternobjekt im Navigator anwählen Funktion : Dieser Befehl selektiert das Elternobjekt im Gerätebaum. Aufruf : Kontextmenü der Registerkarte Voraussetzung : Es ist mindestens ein Objekt geöffnet....", 
"body" : "Elternobjekt im Navigator anwählen Funktion : Dieser Befehl selektiert das Elternobjekt im Gerätebaum. Aufruf : Kontextmenü der Registerkarte Voraussetzung : Es ist mindestens ein Objekt geöffnet. " }, 
{ "title" : "Befehle des Untermenüs: Fenster ", 
"url" : "_cds_cmd_window_n.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Fenster \/ Befehle des Untermenüs: Fenster ", 
"snippet" : "Funktion : Der Befehl aktiviert das ausgewählte Fenster Aufruf : Menü Fenster Für jedes geöffnete Editorfenster enthält das Menü Fenster einen Befehl <n><Objektname> , über den Sie das Fenster aktivieren, also den Fokus dorthin setzen. Im Offline-Betrieb ergänzt CODESYS hinter dem Befehl die Erweite...", 
"body" : "Funktion : Der Befehl aktiviert das ausgewählte Fenster Aufruf : Menü Fenster Für jedes geöffnete Editorfenster enthält das Menü Fenster einen Befehl <n><Objektname> , über den Sie das Fenster aktivieren, also den Fokus dorthin setzen. Im Offline-Betrieb ergänzt CODESYS hinter dem Befehl die Erweiterung (Offline) . Bei Funktionsbausteinen wird zur Unterscheidung von Implementierung und Instanz die Erweiterung (Impl) oder <Instanzpfad hinzugefügt. " }, 
{ "title" : "Hilfe ", 
"url" : "_cds_f_commands_help.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Hilfe ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: CODESYS-Hilfe ", 
"url" : "_cds_cmd_content.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Hilfe \/ Befehl: CODESYS-Hilfe ", 
"snippet" : "CODESYS-Hilfe Symbol: Tastaturkürzel: Strg + Umschalt + F1 Funktion : Der Befehl öffnet die CODESYS -Hilfe. Aufruf : Menü Hilfe Abhängig von der Option Offlinehilfe anstelle von Onlinehilfe verwenden wird die Onlinehilfe oder Offlinehilfe geöffnet....", 
"body" : "CODESYS-Hilfe Symbol: Tastaturkürzel: Strg + Umschalt + F1 Funktion : Der Befehl öffnet die CODESYS -Hilfe. Aufruf : Menü Hilfe Abhängig von der Option Offlinehilfe anstelle von Onlinehilfe verwenden wird die Onlinehilfe oder Offlinehilfe geöffnet. " }, 
{ "title" : "Befehl: Hilfe für installierte Drittanbieterprodukte ", 
"url" : "_cds_cmd_3rd_party_help.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Hilfe \/ Befehl: Hilfe für installierte Drittanbieterprodukte ", 
"snippet" : "Hilfe für installierte Drittanbieterprodukte Symbol: Funktion : Der Befehl öffnet das Verzeichnis ...\\Online Help\\<language code>\\ im Datei-Explorer. Aufruf : Menü Hilfe Voraussetzung : Im Verzeichnis der CHM-Offlinehilfe liegt eine kundenspezifische CHM-Hilfedatei. Dieser Befehl dient dazu, kundens...", 
"body" : "Hilfe für installierte Drittanbieterprodukte Symbol: Funktion : Der Befehl öffnet das Verzeichnis ...\\Online Help\\<language code>\\ im Datei-Explorer. Aufruf : Menü Hilfe Voraussetzung : Im Verzeichnis der CHM-Offlinehilfe liegt eine kundenspezifische CHM-Hilfedatei. Dieser Befehl dient dazu, kundenspezifische CHM-Hilfedateien aus der CODESYS-Benutzeroberfläche zugänglich zu machen. Die Hilfedateien können dann über den Windows-CHM-Viewer geöffnet werden. Mit der Standardinstallation von CODESYS SP21 werden zusätzlich Add-Ons installiert, die noch alte CHM-Hilfedateien mit installieren. Diese Dateien werden ebenfalls im Verzeichnis ...\\Online Help\\<language code>\\ abgelegt. Solange keine zusätzliche, kundenspezifische CHM-Datei in diesem Verzeichnis abgelegt wird, bleibt der Befehl deaktiviert. Der CODESYS -CHM-Viewer ist in SP21 nicht mehr verfügbar. Ein Mergen von CHM-Dateien ist nicht mehr möglich. Das Einbinden von zusätzlichen HTML-Hilfeseiten in die CODESYS -Offlinehilfe ist möglich. Für weitere Informationen siehe: CODESYS-Offlinehilfe mit eigenen Inhalten erweitern" }, 
{ "title" : "Befehl: CODESYS Homepage ", 
"url" : "_cds_cmd_homepage.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Hilfe \/ Befehl: CODESYS Homepage ", 
"snippet" : "CODESYS Homepage Funktion : Der Befehl öffnet die Homepage von CODESYS GmbH . Aufruf : Menü Hilfe...", 
"body" : "CODESYS Homepage Funktion : Der Befehl öffnet die Homepage von CODESYS GmbH . Aufruf : Menü Hilfe " }, 
{ "title" : "Befehl: Informationen ", 
"url" : "_cds_cmd_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Hilfe \/ Befehl: Informationen ", 
"snippet" : "Informationen Funktion : Der Befehl öffnet eine Info-Box mit Informationen zur CODESYS -Version und zu Copyright. Zusätzlich bietet die Info-Box Schaltflächen für weitere Informationen zu Version, Lizenz und Danksagungen. Aufruf : Menü Hilfe Versionsinfo Öffnet den Dialog Detaillierte Versionsinform...", 
"body" : "Informationen Funktion : Der Befehl öffnet eine Info-Box mit Informationen zur CODESYS -Version und zu Copyright. Zusätzlich bietet die Info-Box Schaltflächen für weitere Informationen zu Version, Lizenz und Danksagungen. Aufruf : Menü Hilfe Versionsinfo Öffnet den Dialog Detaillierte Versionsinformationen mit einer Auflistung der CODESYS -Komponenten und Informationen zum Betriebssystem Lizenzinfo Öffnet den Dialog Lizenzinformation Plug-in\/Komponente : Auswahlliste für das Plug-In, für das Lizenzinfo angezeigt werden soll Software-Lizenz : Lizenzinformationen zum ausgewählten Plug-in\/Komponente Danksagungen Dialog: Detaillierte Versionsinformationen Programmiersystem Angabe der Version des Programmiersystems Auflistung der Komponenten mit folgenden Informationen Komponente : Name der Komponente Version : Version der Komponente Add-on : Add-on, das die Komponente enthält Betriebssystem Angabe des Betriebssystems Add-on-Signaturinformation Signaturinformation der selektierten Komponente Expotieren Exportiert die detaillierten Versionsinformationen als *.txt -Datei oder in beliebigem anderem Format " }, 
{ "title" : "Bibliotheken ", 
"url" : "_cds_f_commands_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bibliotheken ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: Bibliothek hinzufügen ", 
"url" : "_cds_cmd_add_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bibliotheken \/ Befehl: Bibliothek hinzufügen ", 
"snippet" : "Bibliothek hinzufügen Funktion : Der Befehl öffnet den Dialog Bibliothek hinzufügen . In diesem Dialog können Sie Bibliotheken zum Bibliotheksverwalter hinzufügen und so in Ihre Applikation einbinden. Aufruf : Menü Bibliotheken Voraussetzung : Der Bibliotheksverwalter ist im Editor geöffnet....", 
"body" : "Bibliothek hinzufügen Funktion : Der Befehl öffnet den Dialog Bibliothek hinzufügen . In diesem Dialog können Sie Bibliotheken zum Bibliotheksverwalter hinzufügen und so in Ihre Applikation einbinden. Aufruf : Menü Bibliotheken Voraussetzung : Der Bibliotheksverwalter ist im Editor geöffnet. " }, 
{ "title" : "Dialog: Bibliothek hinzufügen ", 
"url" : "_cds_cmd_add_library.html#UUID-b7d5aeaf-fe0d-cacd-4cbd-07b0b70036cd_id_cab383442a7a332cc0a8640e00d16ef2_id_c6de462e2a8098cdc0a8640e00eeb4e2", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bibliotheken \/ Befehl: Bibliothek hinzufügen \/ Dialog: Bibliothek hinzufügen ", 
"snippet" : "In der Zeile oberhalb der Bibliotheksliste können Sie nach Bibliotheksnamen oder Bibliotheksbausteinen suchen, indem Sie eine entsprechende Zeichenfolge eintippen. Bibliothek Alle Bibliotheken, die im Bibliotheksrepository installiert sind Die angezeigten Bibliotheken werden standardmäßig in Kategor...", 
"body" : "In der Zeile oberhalb der Bibliotheksliste können Sie nach Bibliotheksnamen oder Bibliotheksbausteinen suchen, indem Sie eine entsprechende Zeichenfolge eintippen. Bibliothek Alle Bibliotheken, die im Bibliotheksrepository installiert sind Die angezeigten Bibliotheken werden standardmäßig in Kategorien gruppiert. Firma Anbieter der Bibliothek Erweitert Öffnet den erweiterten Dialog Bibliothek hinzufügen Die angezeigten Bibliotheken werden in Kategorien gruppiert. Die angezeigten Bibliotheken werden alphabetisch aufgelistet. In der Gerätebeschreibung von Geräten können bestimmte Bibliotheken als „blacklisted“ gekennzeichnet sein. Diese Bibliotheken können im Bibliotheksverwalter unterhalb dieses Geräts nicht hinzugefügt werden. Für weitere Informationen siehe: Bibliotheksrepository" }, 
{ "title" : "Befehl: Versuchen Bibliothek neu zu laden ", 
"url" : "_cds_cmd_reload_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bibliotheken \/ Befehl: Versuchen Bibliothek neu zu laden ", 
"snippet" : "Versuchen Bibliothek neu zu laden Funktion : Der Befehl versucht die selektierte Bibliothek erneut zu laden. Aufruf : Menü Bibliotheken Voraussetzung : Es ist eine Bibliothek selektiert, deren Laden fehlgeschlagen ist. Wenn eine Bibliothek aus irgendeinem Grund nicht im definierten Repository-Pfad b...", 
"body" : "Versuchen Bibliothek neu zu laden Funktion : Der Befehl versucht die selektierte Bibliothek erneut zu laden. Aufruf : Menü Bibliotheken Voraussetzung : Es ist eine Bibliothek selektiert, deren Laden fehlgeschlagen ist. Wenn eine Bibliothek aus irgendeinem Grund nicht im definierten Repository-Pfad bereitsteht, wenn ein Projekt geöffnet wird, gibt CODESYS eine entsprechende Fehlermeldung aus. Nachdem Sie den Fehler behoben haben, also die Bibliothek wieder ordnungsgemäß verfügbar ist, können Sie mit dem Befehl diese Bibliothek nachladen, ohne dass Sie das Projekt verlassen müssen. Für weitere Informationen siehe: Bibliotheksrepository" }, 
{ "title" : "Befehl: Eigenschaften ", 
"url" : "_cds_cmd_library_properties.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bibliotheken \/ Befehl: Eigenschaften ", 
"snippet" : "Eigenschaften Funktion : Der Befehl öffnet den Dialog Eigenschaften für die im Bibliotheksverwalter selektierte Bibliothek. Aufruf Menü Bibliotheken Kontextmenü der selektierten Bibliothek Symbol in der Symbolleiste des Bibliotheksverwalters Voraussetzung : Eine Bibliothek ist selektiert. Dieser Dia...", 
"body" : "Eigenschaften Funktion : Der Befehl öffnet den Dialog Eigenschaften für die im Bibliotheksverwalter selektierte Bibliothek. Aufruf Menü Bibliotheken Kontextmenü der selektierten Bibliothek Symbol in der Symbolleiste des Bibliotheksverwalters Voraussetzung : Eine Bibliothek ist selektiert. Dieser Dialog ist für Bibliotheksentwickler gedacht. Bitte benutzen Sie ihn nur, wenn Sie fundierte Kenntnisse in der Bibliotheksreferenzierung haben und beachten Sie unbedingt die Richtlinien für Bibliotheksentwickler. Für weitere Informationen siehe: Informationen für Bibliotheksentwickler" }, 
{ "title" : "Dialog: Eigenschaften ", 
"url" : "_cds_cmd_library_properties.html#UUID-15f672ba-ddd7-126d-50f4-2ed64e8a9235_id_addd92672ae0c16bc0a8640e011af5c6_id_6803d930a6c811e4a21c94779d6b67d7", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bibliotheken \/ Befehl: Eigenschaften \/ Dialog: Eigenschaften ", 
"snippet" : "Allgemein Namensraum Namensraum der selektierten Bibliothek Üblicherweise identisch mit dem Bibliotheksnamen, außer er wurde beim Erstellen der Bibliothek explizit in den Projektinformationen definiert. Sie können für das (gerade geöffnete) Projekt den Namensraum ändern. Beispiel: LA Standard Biblio...", 
"body" : "Allgemein Namensraum Namensraum der selektierten Bibliothek Üblicherweise identisch mit dem Bibliotheksnamen, außer er wurde beim Erstellen der Bibliothek explizit in den Projektinformationen definiert. Sie können für das (gerade geöffnete) Projekt den Namensraum ändern. Beispiel: LA Standard Bibliothek, die den Platzhalter auflöst, wenn keine andere Auflösung definiert oder möglich ist Voraussetzung: Die selektierte Bibliothek ist ein Bibliotheksplatzhalter, dann ist die Einstellung verfügbar. Hinweis: Ab Compilerversion 3.5.8.0 gilt für einen Bibliotheksplatzhalter, für den es eine Auflösung in der Gerätebeschreibung gibt, der aber im Bibliotheksverwalter der Ansicht POUs liegt: Dieser Platzhalter wird immer automatisch gemäß der Beschreibung des Geräts aufgelöst, für das die Applikation übersetzt wird. Wenn die selektierte Bibliothek gemäß den „Richtlinien für Bibliotheksentwicklung“ entwickelt wurde, ist ein Ändern der folgenden Einstellungen nicht zu empfehlen. Version Auswahl des Versionszwangs Voraussetzung: Nur wenn die selektierte Bibliothek kein Bibliotheksplatzhalter ist, sind die Einstellungen verfügbar. Hinweis: Container- und Interfacebibliotheken werden automatisch mit Bibliotheksreferenzen mit entsprechendem Versionszwang erstellt. Erstellen Sie ansonsten möglichst keine Bibliothek, die Bibliotheksreferenzen mit Versionszwang enthält, sondern referenzieren Sie Bibliotheken über Platzhalter. Eine Platzhalterauflösung können Sie im Dialog Platzhalter bearbeiten. Exakte Version : Die (über Auswahlliste gewählte) Version wird fest im Projekt eingebunden. Hinweis: Diese Option ist für Containerbibliotheken dringend empfohlen und bei diesem Bibliothekstyp üblicherweise voreingestellt. Immer neueste Version : Das Bibliotheksrepository wird durchsucht und die neuste dort gefundene Version wird eingebunden. Hinweis: Wenn eine neuere Version der Bibliothek verfügbar ist, können sich die tatsächlich verwendeten Bibliotheksbausteine ändern. Diese Option ist für Interfacebibliotheken dringend empfohlen und bei diesem Bibliothekstyp üblicherweise voreingestellt. Sichtbarkeit Nur qualifizierten Zugriff auf alle Bezeichner erlauben. : Bibliotheksbausteine (und Variablen) werden im Projekt nur mit vorangestelltem Namensraumpfad aufgerufen. Wenn das aktuelle Projekt in einem anderen Projekt als Bibliothek referenziert wird Hinweis: Nur wenn Sie mit Ihrem Projekt eine Bibliothek erstellen und somit ein Bibliotheksprojekt geöffnet haben, ist ein Ändern der folgenden Einstellungen sinnvoll. Die selektierte Bibliothek wird dabei in der neuen Bibliothek referenziert. Alle IEC-Symbole im Projekt sichtbar machen, als ob diese Referenz hier direkt eingebunden worden wäre. : Die selektierte Bibliothek macht (später in einem Projekt) als Containerbibliothek den Inhalt der referenzierten Bibliothek toplevel (auf ihrer obersten Ebene) sichtbar. Voraussetzung: Sie erstellen mit dem Bibliotheksprojekt eine Containerbibliothek. Eine Containerbibliothek ist eine Bibliothek, die keine eigenen Bausteine implementiert, sondern ausschließlich andere Bibliotheken referenziert. Sie bündelt Bibliotheken. Eine Containerbibliothek kann sinnvoll eingesetzt werden, um mehrere Bibliotheken zusammen (in einer Referenz) in ein Projekt einzubinden. Für jede Bibliotheksreferenz muss dabei diese Option aktiviert sein. Synbolischer Zugriff auf Bibliotheksbausteine: <Namensraum Containerbibliothek>.<Bausteinname> : Der Inhalt der referenzierten Bibliothek ist über den Namensraum eindeutig ansprechbar. Der Pfadname setzt sich aus dem Namen der Bibliothek und dem eigenen Namen (der Bibliotheksreferenz) zusammen und wird dem Bausteinnamen vorangestellt. Voraussetzung: Sie erstellen mit dem Bibliotheksprojekt keine Containerbibliothek. Diese Referenz im Abhängigkeitsbaum nicht anzeigen. : Die selektierte Bibliothek wird (später in einem Projekt) nicht als Bibliotheksreferenz im Bibliotheksverwalter angezeigt. Die Bibliothek wird versteckt referenziert. Warnung: Im Fall von Übersetzungsfehlern, die auf Fehler in der versteckten Bibliothek zurückgehen, kann die Fehlersuche schwierig sein. : Die selektierte Bibliothek wird (später in einem Projekt) als Bibliotheksreferenz angezeigt. Optional (wenn die Bibliothek fehlt, wird kein Fehler ausgegeben). : : Die selektierte Bibliothek wird als optional behandelt. Beim Laden eines Projekts, das die Bibliothek referenziert, wird kein Fehler ausgegeben, auch wenn die Bibliothek im Bibliotheksrepository nicht vorhanden ist. Für weitere Informationen siehe: Platzhalter" }, 
{ "title" : "Befehl: Platzhalter ", 
"url" : "_cds_cmd_placeholder.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bibliotheken \/ Befehl: Platzhalter ", 
"snippet" : "Platzhalter Funktion : Der Befehl öffnet den Dialog Platzhalter . Der Dialog informiert über die selektierte Platzhalterbibliothek und ermöglicht eine speziell für das Projekt gültige Auflösung zuzuweisen. Der Übersetzungsvorgang findet immer für eine bestimmte Applikation statt. Dafür muss es für d...", 
"body" : "Platzhalter Funktion : Der Befehl öffnet den Dialog Platzhalter . Der Dialog informiert über die selektierte Platzhalterbibliothek und ermöglicht eine speziell für das Projekt gültige Auflösung zuzuweisen. Der Übersetzungsvorgang findet immer für eine bestimmte Applikation statt. Dafür muss es für die in einem Bibliotheksverwalter vorhandenen Bibliothekseinträge auch tatsächlich verfügbare Bibliotheken geben. Die Auflösung von Platzhaltern in den verschiedenen Bibliotheksverwaltern eines Projekts (Applikationen, POUs -Pool) ist ein komplexer Vorgang. Das Ergebnis einer Auflösung wird erst beim Übersetzungslauf sichtbar und ist vorher nicht zuverlässig aus den Platzhalterinformationen in den Bibliotheksverwaltern ablesbar. Aufruf : Menü Bibliotheken Symbol in der Symbolleiste im oberen Fensterbereich des Bibliotheksverwalters Quickfixbefehl bei einer Fehlermeldung über eine unaufgelöste Bibliothek. Für weitere Informationen siehe: Meldungen. Ab Compilerversion 3.5.18.0 wird das Bibliotheksprofil für die Auflösung von Platzhaltern ignoriert. Die Platzhalter werden zu \"Freien Platzhaltern\". Voraussetzung : Im Bibliotheksverwalter ist eine Platzhalterbibliothek selektiert. Für die Auflösung einer Platzhalterbibliothek wird nacheinander Folgendes durchsucht: Die aktuelle Platzhalterdefinition im Dialog Platzhalter des\/der Bibliotheksverwalter der Applikation(en) Die Gerätebeschreibungen der verwendeten Geräte Die installierten Add-ons Die Platzhaltertabelle des Bibliotheksverwalters in der Ansicht POUs Das Ergebnis erscheint im Bibliotheksverwalter unter Effektive Version . Information dazu finden Sie im Tooltip des Symbols . Wenn keiner der Auflösungsschritte Erfolg hat, wird die Bibliothek mit (nicht aufgelöst) markiert und die Bibliothek wird beim Kompilieren nicht berücksichtigt. Für weitere Informationen zu Bibliotheksplatzhaltern siehe: Bibliotheken verwendenInformationen für BibliotheksentwicklerBibliotheksplatzhalter aktualisierenEigenschaftenLibDevSummary " }, 
{ "title" : "Dialog: Platzhalter ", 
"url" : "_cds_cmd_placeholder.html#UUID-98becf1f-bedf-8e6a-baab-8f7e3b147e27_id_c70a2add81efc0a8640e016d5a59_id_4450599b767011e6b248ef4427d74153", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bibliotheken \/ Befehl: Platzhalter \/ Dialog: Platzhalter ", 
"snippet" : "Name Bezeichner des Platzhalters Bibliothek Aktuelle Auflösung für das Projekt Doppelklicken Sie auf den Eintrag, um die Platzhalterauflösung zu bearbeiten. Es erscheint eine Auswahlliste der verfügbaren Versionen der Bibliothek. Außerdem erscheint der Befehl Andere Bibliotheken . Befehl Andere Bibl...", 
"body" : "Name Bezeichner des Platzhalters Bibliothek Aktuelle Auflösung für das Projekt Doppelklicken Sie auf den Eintrag, um die Platzhalterauflösung zu bearbeiten. Es erscheint eine Auswahlliste der verfügbaren Versionen der Bibliothek. Außerdem erscheint der Befehl Andere Bibliotheken . Befehl Andere Bibliothek Der Dialog Bibliothek durchsuchen zum Suchen und Installieren von Bibliotheken öffnet sich. Wählen Sie den Befehl, um nicht auf eine andere Version, sondern auf eine spezielle Bibliothek umzuleiten. Info Art der Platzhalterauflösung Aufgelöst durch Gerätebeschreibung Aufgelöst durch Lizenzmechanismus Aufgelöst durch Add-ons Freier Platzhalter aufgelöst durch <spezielle Bibliothek mit fester Version> Alle nicht aufgelösten ungebundenen Platzhalter auf die neuesten verfügbaren Versionen setzen Für die Auflösung noch nicht aufgelöster Platzhalterbibliotheken im Bibliotheksverwalter wird die neueste verfügbare Version eingetragen. " }, 
{ "title" : "Befehl: Bibliothek exportieren ", 
"url" : "_cds_cmd_export_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Bibliotheken \/ Befehl: Bibliothek exportieren ", 
"snippet" : "Bibliothek exportieren Funktion : Dieser Befehl dient dem Speichern der Bibliotheksdatei auf der Festplatte. Aufruf : Menü Bibliotheken , Kontextmenü des Bibliotheksverwalters Voraussetzung : Im Bibliotheksverwalter ist eine Bibliothek selektiert. Der Befehl öffnet den Standarddialog zum Speichern e...", 
"body" : "Bibliothek exportieren Funktion : Dieser Befehl dient dem Speichern der Bibliotheksdatei auf der Festplatte. Aufruf : Menü Bibliotheken , Kontextmenü des Bibliotheksverwalters Voraussetzung : Im Bibliotheksverwalter ist eine Bibliothek selektiert. Der Befehl öffnet den Standarddialog zum Speichern einer Datei im lokalen Dateisystem. Die Bibliotheksdatei kann den Dateityp Bibliotheken (*.library) , Übersetzte Bibliotheken (*.compiled-library) oder Übersetzte Bibliotheken (*.compiled-library-v3) haben. Für weitere Informationen siehe: Bibliotheksdatei exportieren" }, 
{ "title" : "Deklarationen ", 
"url" : "_cds_f_commands_declarations.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Deklarationen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: Einfügen ", 
"url" : "_cds_cmd_insert.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Deklarationen \/ Befehl: Einfügen ", 
"snippet" : "Einfügen Symbol: Funktion : Der Befehl fügt eine neue Zeile für eine Variablendeklaration im tabellarischen Deklarationseditor ein und das Eingabefeld für den Variablennamen öffnet sich. Aufruf : Kontextmenü im tabellarischen Deklarationseditor, Schaltfläche im Deklarationskopf Um die anderen Felder...", 
"body" : "Einfügen Symbol: Funktion : Der Befehl fügt eine neue Zeile für eine Variablendeklaration im tabellarischen Deklarationseditor ein und das Eingabefeld für den Variablennamen öffnet sich. Aufruf : Kontextmenü im tabellarischen Deklarationseditor, Schaltfläche im Deklarationskopf Um die anderen Felder der Deklarationszeile zu bearbeiten, doppelklicken Sie die Felder und wählen Sie die Angaben aus den Auswahllisten oder mit Hilfe der entsprechenden Dialoge. " }, 
{ "title" : "Befehl: Deklarationskopf editieren ", 
"url" : "_cds_cmd_edit_declaration_header.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Deklarationen \/ Befehl: Deklarationskopf editieren ", 
"snippet" : "Deklarationskopf editieren Funktion : Der Befehl öffnet den Dialog Deklarationskopf editieren , der im tabellarischen Deklarationseditor zur Konfiguration der Kopfzeile einer POU dient. Aufruf : Kontextmenü des tabellarischen Deklarationseditors Voraussetzung : Der Fokus liegt im tabellarischen Dekl...", 
"body" : "Deklarationskopf editieren Funktion : Der Befehl öffnet den Dialog Deklarationskopf editieren , der im tabellarischen Deklarationseditor zur Konfiguration der Kopfzeile einer POU dient. Aufruf : Kontextmenü des tabellarischen Deklarationseditors Voraussetzung : Der Fokus liegt im tabellarischen Deklarationseditor. " }, 
{ "title" : "Dialog: Deklarationskopf editieren ", 
"url" : "_cds_cmd_edit_declaration_header.html#UUID-45e0a327-995d-f0be-3bd9-68bfcb2d6ac3_id_be8f1f656b67481c0a8640e01948269_id_96a5b119635a8e3bc0a8640e005df4c1", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Deklarationen \/ Befehl: Deklarationskopf editieren \/ Dialog: Deklarationskopf editieren ", 
"snippet" : "Funktion : In dem Dialog konfigurieren Sie die Kopfzeile des tabellarischen Deklarationsteils einer POU. Aufruf : Mausklick auf die Kopfleiste des tabellarischen Deklarationseditors, Kontextmenü im tabellarischen Deklarationseditor Deklaration Auswahlliste zur Änderung des POU-Typs PROGRAM FUNCTION_...", 
"body" : "Funktion : In dem Dialog konfigurieren Sie die Kopfzeile des tabellarischen Deklarationsteils einer POU. Aufruf : Mausklick auf die Kopfleiste des tabellarischen Deklarationseditors, Kontextmenü im tabellarischen Deklarationseditor Deklaration Auswahlliste zur Änderung des POU-Typs PROGRAM FUNCTION_BLOCK EXTENDS : Eingabefeld für einen Basis-Funktionsbaustein IMPLEMENTS : Eingabefeld für eine Schnittstelle FUNCTION Rückgabetyp Eingabefeld mit aktuellem POU-Namen Sie können den Namen der POU ändern. Beim Umbenennen alle Referenzen automatisch anpassen : Der Dialog Refactoring öffnet sich. : Die Umbenennung wird nur im Deklarationskopf der POU wirksam. Attribute Der Dialog Attribute öffnet sich zur Eingabe von Attributen und Pragmas. Für weitere Informationen siehe: Deklarationseditor verwenden" }, 
{ "title" : "Befehl: Nach unten verschieben ", 
"url" : "_cds_cmd_move_down.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Deklarationen \/ Befehl: Nach unten verschieben ", 
"snippet" : "Nach unten verschieben Symbol: Funktion : Der Befehl verschiebt eine Variablendeklaration um eine Zeile nach unten. Aufruf : Kontextmenü Voraussetzung : Im tabellarischen Deklarationseditor ist eine Zeile mit einer Variablendeklaration selektiert....", 
"body" : "Nach unten verschieben Symbol: Funktion : Der Befehl verschiebt eine Variablendeklaration um eine Zeile nach unten. Aufruf : Kontextmenü Voraussetzung : Im tabellarischen Deklarationseditor ist eine Zeile mit einer Variablendeklaration selektiert. " }, 
{ "title" : "Befehl: Nach oben verschieben ", 
"url" : "_cds_cmd_move_up.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Deklarationen \/ Befehl: Nach oben verschieben ", 
"snippet" : "Nach oben verschieben Symbol: Funktion : Der Befehl verschiebt eine Variablendeklaration um eine Zeile nach oben. Aufruf : Kontextmenü Voraussetzung : Im tabellarischen Deklarationseditor ist eine Zeile mit einer Variablendeklaration selektiert....", 
"body" : "Nach oben verschieben Symbol: Funktion : Der Befehl verschiebt eine Variablendeklaration um eine Zeile nach oben. Aufruf : Kontextmenü Voraussetzung : Im tabellarischen Deklarationseditor ist eine Zeile mit einer Variablendeklaration selektiert. " }, 
{ "title" : "Deklarationen (Persistenz) ", 
"url" : "_cds_f_commands_declarations_persistence.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Deklarationen (Persistenz) ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: Liste neu ordnen und Lücken bereinigen ", 
"url" : "_cds_cmd_reorder_list.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Deklarationen (Persistenz) \/ Befehl: Liste neu ordnen und Lücken bereinigen ", 
"snippet" : "Liste neu ordnen und Lücken bereinigen Funktion : Der Befehl bereinigt die Lücken, die entstehen können, wenn Sie Änderungen in der Deklaration von persistenten Variablen vornehmen. Durch die Bereinigung reduziert sich der Speicherbedarf. Beim Ausführen des Befehls zeigt CODESYS eine Warnmeldung an,...", 
"body" : "Liste neu ordnen und Lücken bereinigen Funktion : Der Befehl bereinigt die Lücken, die entstehen können, wenn Sie Änderungen in der Deklaration von persistenten Variablen vornehmen. Durch die Bereinigung reduziert sich der Speicherbedarf. Beim Ausführen des Befehls zeigt CODESYS eine Warnmeldung an, die den Anwender auf den möglichen Verlust von Daten hinweist. Aufruf : Menü Deklarationen , Kontextmenü Voraussetzung : Der Persistenzeditor (persistente Variablenliste) ist aktiv. Vor einer Bereinigung sollten Sie in Erwägung ziehen, die aktuellen Werte der persistenten Variablen in einer Rezeptur zu speichern (Befehl Aktuelle Werte in Rezeptur speichern ). Dann können Sie die Werte nach dem nächsten Download wieder auf die Steuerung spielen. Für weitere Informationen siehe: Datenpersistenz" }, 
{ "title" : "Befehl: Aktuelle Werte in Rezeptur speichern ", 
"url" : "_cds_cmd_save_actual_values_recipe.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Deklarationen (Persistenz) \/ Befehl: Aktuelle Werte in Rezeptur speichern ", 
"snippet" : "Aktuelle Werte in Rezeptur speichern Funktion : Der Befehl erzeugt eine neue Rezepturdefinition im Rezeptur-Manager und speichert darin die aktuellen Werte der persistenten Variablen. Den Befehl sollten Sie vor dem Befehl Liste neu ordnen und Lücken bereinigen ausführen, um möglichen Datenverlust zu...", 
"body" : "Aktuelle Werte in Rezeptur speichern Funktion : Der Befehl erzeugt eine neue Rezepturdefinition im Rezeptur-Manager und speichert darin die aktuellen Werte der persistenten Variablen. Den Befehl sollten Sie vor dem Befehl Liste neu ordnen und Lücken bereinigen ausführen, um möglichen Datenverlust zu vermeiden. Mit dem Befehl Werte aus Rezeptur wiederherstellen können Sie anschließend die Daten wiederherstellen. Aufruf : Menü Deklarationen Voraussetzung : Die Applikation ist Onlinebetrieb und der Persistenzeditor (persistente Variablenliste) ist aktiv. Wenn beim Speichern einer persistenten Variablenliste bereits eine Liste mit entsprechenden Namen im Rezeptur-Manager existiert, dann werden die aktuellen persistenten Variablen in diese Liste einsortiert: Neue persistente Variablen werden der Liste hinzugefügt. Variablen, die sich nicht in der Liste der persistenten Variablen befinden, werden gelöscht. Es ist daher möglich, zu der Liste im Rezeptur-Manager weitere Rezepturen hinzuzufügen, die beibehalten werden. Wenn aber neue Variablen in die Liste hinzugefügt werden, dann werden diese mit der nächsten Ausführung des Befehls Aktuelle Werte in Rezeptur speichern gelöscht. Für weitere Informationen siehe: TODO " }, 
{ "title" : "Befehl: Werte aus Rezeptur wiederherstellen ", 
"url" : "_cds_cmd_restore_values_recipe.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Deklarationen (Persistenz) \/ Befehl: Werte aus Rezeptur wiederherstellen ", 
"snippet" : "Werte aus Rezeptur wiederherstellen Funktion : Der Befehl stellt die Werte der persistenten Variablen wieder her, die Sie mit dem Befehl Aktuelle Werte in Rezeptur speichern in einer Rezeptur gespeichert haben. Den Befehl wählen Sie üblicherweise nach Ausführung des Befehls Liste neu ordnen und Lück...", 
"body" : "Werte aus Rezeptur wiederherstellen Funktion : Der Befehl stellt die Werte der persistenten Variablen wieder her, die Sie mit dem Befehl Aktuelle Werte in Rezeptur speichern in einer Rezeptur gespeichert haben. Den Befehl wählen Sie üblicherweise nach Ausführung des Befehls Liste neu ordnen und Lücken bereinigen aus. Aufruf : Menü Deklarationen Voraussetzung : Der Persistenzeditor (persistente Variablenliste) ist aktiv. Die Applikation ist im Onlinebetrieb. Für weitere Informationen siehe: Datenpersistenz" }, 
{ "title" : "Befehl: Alle Instanzpfade hinzufügen ", 
"url" : "_cds_cmd_add_all_instance_paths.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Deklarationen (Persistenz) \/ Befehl: Alle Instanzpfade hinzufügen ", 
"snippet" : "Alle Instanzpfade hinzufügen Funktion : Wenn Sie den Befehl im Persistenzeditor auswählen, wird die Applikation nach Deklarationen persistenter Variablen mit dem Schlüsselwort PERSISTENT durchsucht, die sich außerhalb des Persistenzeditors befinden. Für jede gefundene Deklaration wird im Persistenze...", 
"body" : "Alle Instanzpfade hinzufügen Funktion : Wenn Sie den Befehl im Persistenzeditor auswählen, wird die Applikation nach Deklarationen persistenter Variablen mit dem Schlüsselwort PERSISTENT durchsucht, die sich außerhalb des Persistenzeditors befinden. Für jede gefundene Deklaration wird im Persistenzeditor ein Instanzpfad dieser Variablen hinzugefügt. Wenn Sie den Befehl in einer Variablenkonfiguration auswählen, wird für jede Variablen mit unvollständiger Adresse ein Instanzpfad hinzugefügt. Dabei werden alle Funktionsbausteine der Applikation berücksichtigt. Aufruf : Menü Deklarationen , Kontextmenü Voraussetzung Der Persistenzeditor (globale persistente Variablenliste) ist aktiv oder eine Variablenkonfiguration (globale Variablenliste mit VAR_CONFIG -Deklarationen) ist geöffnet. Die Applikation wurde erfolgreich übersetzt. Für weitere Informationen siehe: PERSISTENT und RETAIN" }, 
{ "title" : "Kommunikation: Gateway ", 
"url" : "_cds_f_commands_device_communication.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Kommunikation: Gateway ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: Neues Gateway hinzufügen ", 
"url" : "_cds_cmd_add_gateway.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Kommunikation: Gateway \/ Befehl: Neues Gateway hinzufügen ", 
"snippet" : "Neues Gateway hinzufügen Funktion : Der Befehl öffnet den Dialog Gateway , wo Sie einen Gateway-Kanal definieren und zur aktuellen Gerätekonfiguration hinzufügen können. Aufruf : Menü Gateway im Dialog Kommunikation des Geräteeditors...", 
"body" : "Neues Gateway hinzufügen Funktion : Der Befehl öffnet den Dialog Gateway , wo Sie einen Gateway-Kanal definieren und zur aktuellen Gerätekonfiguration hinzufügen können. Aufruf : Menü Gateway im Dialog Kommunikation des Geräteeditors " }, 
{ "title" : "Dialog: Gateway ", 
"url" : "_cds_cmd_add_gateway.html#UUID-38ab0375-8d48-62f3-f65e-4b40ba5a736f_id_d79c74fc3cfb092c0a8640e0168b9f8_id_1bd97f47c406359cc0a8640e007a53f7", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Kommunikation: Gateway \/ Befehl: Neues Gateway hinzufügen \/ Dialog: Gateway ", 
"snippet" : "Name Name für das Gateway Treiber Treibertyp, aus Auswahlliste Treiberspezifische Einstellungen, beispielsweise: IP-Adresse, Port Bearbeitbar nach einem Doppelklick auf den vorgegebenen Wert Im unteren Teil des Dialogs erscheint jeweils eine Kurzbeschreibung zum Parameter. Hinweis: Sie können auch d...", 
"body" : "Name Name für das Gateway Treiber Treibertyp, aus Auswahlliste Treiberspezifische Einstellungen, beispielsweise: IP-Adresse, Port Bearbeitbar nach einem Doppelklick auf den vorgegebenen Wert Im unteren Teil des Dialogs erscheint jeweils eine Kurzbeschreibung zum Parameter. Hinweis: Sie können auch die Adresse einer DNS-Domaine angeben. Diese muss mit dns: beginnen, beispielsweise dns:MyDynDNSAdress . Der Dialog dient auch der späteren Bearbeitung der Gateway-Einträge Ihres Projekts. Für weitere Informationen siehe: Registerkarte: Kommunikation" }, 
{ "title" : "Befehl: Lokales Gateway konfigurieren ", 
"url" : "_cds_cmd_connect_to_local_gateway.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Kommunikation: Gateway \/ Befehl: Lokales Gateway konfigurieren ", 
"snippet" : "Lokales Gateway konfigurieren Funktion : Der Befehl öffnet den Dialog Gateway-Konfiguration , in dem Sie die Blocktreiberkonfiguration für das lokale Gateway vornehmen können, alternativ zum manuellen Editieren der Konfigurationsdatei Gateway.cfg . Aufruf : Kontextmenü, wenn im Geräteeditor im Dialo...", 
"body" : "Lokales Gateway konfigurieren Funktion : Der Befehl öffnet den Dialog Gateway-Konfiguration , in dem Sie die Blocktreiberkonfiguration für das lokale Gateway vornehmen können, alternativ zum manuellen Editieren der Konfigurationsdatei Gateway.cfg . Aufruf : Kontextmenü, wenn im Geräteeditor im Dialog Kommunikation ein Gatewayeintrag selektiert ist Eine korrekte Konfiguration des Gateway erfordert detailliertes Wissen. Bei Zweifeln lassen Sie die Standard-Konfigurationseinstellungen unverändert! Um die Edge-Gateway-Funktion zu aktivieren und das Edge-Gateway mit dem CODESYS Automation Server zu verbinden, können Sie den  CODESYS Automation Server Connector  oder das CODESYS Service Tool verwenden. Nähere Informationen dazu finden Sie in der Hilfe zum CODESYS Automation Server  im Abschnitt „Edge-Gateway mit dem Server verbinden und Steuerungen eintragen“. Bitte beachten Sie in der Hilfe auch die „Sicherheitshinweise zum Edge-Gateway“. " }, 
{ "title" : "Dialog: Gateway-Konfiguration ", 
"url" : "_cds_cmd_connect_to_local_gateway.html#UUID-113d1b31-e0b0-905d-0a3a-3bc12e9738f0_id_dfde2d61c3f6ec73c0a8640e0083d45e_id_1513b072c607f333c0a8640e00d023da", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Kommunikation: Gateway \/ Befehl: Lokales Gateway konfigurieren \/ Dialog: Gateway-Konfiguration ", 
"snippet" : "Der im Dialog dargestellte Konfigurationsbaum entspricht der Beschreibung in der aktuell gültigen Konfigurationsdatei gateway.cfg . Er zeigt für die beteiligten Schnittstellen die Parameter mit den aktuellen Einstellungen. Änderungen der Konfiguration im Dialog, bestätigt mit OK bewirken eine unmitt...", 
"body" : "Der im Dialog dargestellte Konfigurationsbaum entspricht der Beschreibung in der aktuell gültigen Konfigurationsdatei gateway.cfg . Er zeigt für die beteiligten Schnittstellen die Parameter mit den aktuellen Einstellungen. Änderungen der Konfiguration im Dialog, bestätigt mit OK bewirken eine unmittelbare Aktualisierung der Konfigurationsdatei. Wenn die Gateway-Konfigurationsdatei gateway.cfg verändert wurde, muss das Gateway erst gestoppt und neu gestartet werden, um die Änderungen wirksam zu machen. Hinzufügen Menü mit Befehlen zum Hinzufügen von Schnittstellen und Einstellungen Die Befehle sind auch im Kontextmenü des Dialogs verfügbar. Die Auswahl hängt jeweils davon ab, welcher Eintrag selektiert ist, und welche Einstellungen schon eingefügt sind: Schnittstelle hinzufügen : Wählen Sie eine Schnittstelle für die Kommunikation über das Gateway aus. Sie wird auf oberer Ebene des Baums eingefügt. Siehe die Tabelle unten für die möglichen Blocktreiber-Schnittstellen. Konfigurationseinstellung hinzufügen : Wählen Sie eine Einstellung für die selektierte Schnittstelle aus. Sie wird unterhalb der Schnittstelle im Baum eingefügt. Um den Wert der Einstellung zu bearbeiten, öffnen Sie mit einem Doppelklick in der Spalte Einstellung ein Editierfeld. Siehe die Tabelle unten für die möglichen Einstellungen pro Blocktreiber-Schnittstelle. Löschen Löscht die selektierte Konfigurationseinstellung Nach oben , Nach unten Verschiebt den selektierten Konfigurationseintrag um eine Stelle nach oben oder unten Mögliche Blocktreiber-Schnittstellen COM Port Serieller Port auf dem Gerät, beispielsweise für den Datenaustausch gemäß Norm RS232 auf einem dafür vorgesehenen COM-Port Mögliche Konfigurationseinstellungen: Name : Nur symbolisch Port : Physikalischer serieller Port, der für diese Schnittstelle verwendet wird, beispielsweise COM 5 auf einem Windows-Computer Baudrate : 2400 , 4800 , 9600 , 19200 , 38400 , 57600 , 115200 Autoadressierung aktivieren : (Standard = ) Die Einstellung Local address wird ausgewertet. Die beiden Geräte, die über die serielle Schnittstelle kommunizieren, werden dann ihre Adressen selbständig aushandeln bevor sie mit dem Austausch von Meldungen beginnen. Wenn die Adressen der beiden Geräte gleich lauten, werden sie erneut ausgehandelt. Diese Einstellung ist nützlich für den Fall, dass die lokalen Adressen nicht explizit gesetzt werden können, beispielsweise bei physikalisch getrennten Geräten. Lokale Adresse : Wird nur ausgewertet, wenn Enable Auto Adressing aktiviert ist Standard = Istwert für Port Shared Memory Shared-Memory-Treiber Mögliche Einstellungen: Name : Nur symbolisch Erzwungene Adresse : Standard = -1 (= no forced address ) Beispiel: 42 bedeutet, dass der Treiber die hier definierte feste Adresse verwenden muss und dass Adressen frei im Bereich von 0 - 255 vergeben werden. Diese Einstellung kann nützlich sein, wenn in der Konfiguration mehr als ein Shared-Memory-Treiber aktiviert ist. Ethernet UDP\/IP Ethernet-Schnittstelle für den Datenaustausch gemäß „User Datagram Protocol“ Mögliche Einstellungen: Name : Nur symbolisch Port-Index : Port-Nummer für die Kommunikation Port-Indices liegen im Bereich 0 bis 3 . Sie werden auf folgenden Ethernet-Port abgebildet: 1740 bis 1743 . IP-Adresse : Standard = 127.0.0.1 Diese Einstellung kann nützlich sein, um explizit eine Schnittstelle zu setzen, wenn es mehrere Netzwerkschnittstellen auf dem Gerät gibt. Beispiel: 127.0.0.1 steht für irgendeine lokale Netzwerkschnittstelle, auch als localhost bezeichnet. Jede andere Adresse (beispielsweise 10.27.7.72 ) repräsentiert eine reale IP-Adresse, die auf dem Gerät verfügbar sein muss. Netzwerkmaske : Standard = 255.255.255.0 Beispiel: 255.255.252.0 Diese Einstellung kann nützlich sein, um explizit eine Schnittstelle zu setzen, wenn es mehrere Netzwerkschnittstellen auf dem Gerät gibt. PPP-Remote-Adresse : Standard = 127.0.0.1 Beispiel: 10.13.42.240 Stellt eine logische Point-to-Point-Verbindung zwischen der UDP-Schnittstelle und dem mit der hier gegebenen Adresse bezeichneten Knoten her Bewirkt, dass die UDP-Schnittstelle mit diesem Knoten exklusiv kommuniziert und dass keine Broadcasts im Netzwerk versendet werden Ethernet TCP\/IP Ethernet-Schnittstelle für den Datenaustausch gemäß „Transmission Control Protocol“ Mögliche Einstellungen: Name , Port , IP Adresse : siehe oben bei Ethernet UDP\/IP Inaktivitäts-Timeout : Standard = 0 Diese Einstellung definiert die Zeitspanne in Sekunden, nach der die TCP-Verbindungen geschlossen werden falls keine Daten mehr ausgetauscht werden. CAN Client Name : Nur symbolisch Eine Beschreibung zu den anderen Einstellungen können Sie direkt dem Dialog entnehmen. USB Port Name : Nur symbolisch Eine Beschreibung zu den anderen Einstellungen können Sie direkt dem Dialog entnehmen. Für weitere Informationen siehe: Registerkarte: Kommunikation" }, 
{ "title" : "Sonstige ", 
"url" : "_cds_f_commands_miscellaneous.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Sonstige ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl: Zur Überwachungsliste hinzufügen ", 
"url" : "_cds_cmd_add_watch.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Sonstige \/ Befehl: Zur Überwachungsliste hinzufügen ", 
"snippet" : "Zur Überwachungsliste hinzufügen Symbol: Funktion : Der Befehl fügt die Variable, auf der gerade der Cursor steht, einer Überwachen-Liste hinzu, die dem Online-Monitoring dient. Aufruf : Der Befehl ist im Kontextmenü verfügbar, wenn sich die Applikation im Onlinebetrieb befindet und der Cursor in ei...", 
"body" : "Zur Überwachungsliste hinzufügen Symbol: Funktion : Der Befehl fügt die Variable, auf der gerade der Cursor steht, einer Überwachen-Liste hinzu, die dem Online-Monitoring dient. Aufruf : Der Befehl ist im Kontextmenü verfügbar, wenn sich die Applikation im Onlinebetrieb befindet und der Cursor in einem Editor auf einer Variable steht. Der Befehl fügt die Variable in die gerade geöffnete Überwachen-Liste ein. Wenn gerade keine Überwachen-Liste geöffnet ist, fügt der Befehl die Variable in Liste Überwachen 1 ein und öffnet deren Ansicht. Für weitere Informationen siehe: Überwachungslisten verwenden und Monitoring von Werten" }, 
{ "title" : "Befehl: Schnittstellen implementieren ", 
"url" : "_cds_cmd_implement_interfaces.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Sonstige \/ Befehl: Schnittstellen implementieren ", 
"snippet" : "Schnittstellen implementieren Funktion : Der Befehl aktualisiert für einen Funktionsbaustein die implementierten Schnittstellen. Aufruf : Kontextmenü, wenn der Funktionsbaustein (FB) im Gerätebaum selektiert ist Voraussetzung : Der Funktionsbaustein implementiert eine Schnittstelle, die Sie veränder...", 
"body" : "Schnittstellen implementieren Funktion : Der Befehl aktualisiert für einen Funktionsbaustein die implementierten Schnittstellen. Aufruf : Kontextmenü, wenn der Funktionsbaustein (FB) im Gerätebaum selektiert ist Voraussetzung : Der Funktionsbaustein implementiert eine Schnittstelle, die Sie verändert haben. Beispielsweise haben Sie der Schnittstelle eine weitere Methode hinzugefügt. Wenn Sie beim objektorientierten Programmieren zum Zweck der Vererbung einen Funktionsbaustein (FB) von einem Basis-Funktionsbaustein ableiten, der eine oder mehrere Schnittstellen implementiert, gilt Folgendes: Wenn Sie den Befehl Schnittstellen implementieren für den abgeleiteten FB ausführen, werden alle Schnittstellenmethoden und Schnittstelleneigenschaften des Basis-FB in Form von „Stubs“ (ohne Implementierung) in den abgeleiteten FB übernommen. Sie müssen nun darauf achten, dass im abgeleiteten FB dadurch nicht eine „leere“ Methode\/Eigenschaft in Konflikt mit einer im Basis-FB implementierten gerät. Um Sie dabei zu unterstützen, geschieht Folgendes: Wenn es für eine Methode\/Eigenschaft eine Basisimplementierung gibt, fügt CODESYS ein Pragmaatrribut {error..} in der ersten Zeile der betroffenen abgeleiteten Schnittstellenmethode beziehungsweise Schnittstelleneigenschaft ein, das eine entsprechende Fehlermeldung generieren wird. Wenn es für die Methode\/Eigenschaft keine Basisimplementierung gibt, gibt es einen Pragmaattributeintrag für eine Warnung. Nach Bearbeitung des Bausteins müssen Sie den error-Pragmaattributeintrag jeweils explizit entfernen. Für weitere Informationen siehe: Implementieren einer Schnittstelle" }, 
{ "title" : "Befehl: Ergebnisse auf aktuelle Deklaration beschränken ", 
"url" : "_cds_cmd_limit_results_to_current_declaration.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Menübefehle \/ Sonstige \/ Befehl: Ergebnisse auf aktuelle Deklaration beschränken ", 
"snippet" : "Ergebnisse auf aktuelle Deklaration beschränken Funktion : Wenn mehrere Deklarationen gefunden wurden, reduziert der Befehl die Darstellung in der Querverweisliste. Sie zeigt nur noch die Ergebnisse für die Deklaration, die Sie explizit in der Liste selektiert haben. Aufruf : Kontextmenü Voraussetzu...", 
"body" : "Ergebnisse auf aktuelle Deklaration beschränken Funktion : Wenn mehrere Deklarationen gefunden wurden, reduziert der Befehl die Darstellung in der Querverweisliste. Sie zeigt nur noch die Ergebnisse für die Deklaration, die Sie explizit in der Liste selektiert haben. Aufruf : Kontextmenü Voraussetzung : Die Querverweisliste ist aktiv. Mehrere Deklarationen für das gesuchte Symbol sind als Querverweise aufgelistet. " }, 
{ "title" : "Dialoge ", 
"url" : "_cds_struct_reference_dialogs.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge ", 
"snippet" : "Die Dialoge der CODESYS -Oberfläche sind grundsätzlich auf den Hilfeseiten der CODESYS -Menübefehle oder CODESYS -Objekte beschrieben. Das Hilfe-Buch Dialoge enthält nur folgende Beschreibungen für Dialoge: Beschreibungen für Dialoge, die erst durch mehrstufig erfolgende weitere Aufrufe nach einem M...", 
"body" : "Die Dialoge der CODESYS -Oberfläche sind grundsätzlich auf den Hilfeseiten der CODESYS -Menübefehle oder CODESYS -Objekte beschrieben. Das Hilfe-Buch Dialoge enthält nur folgende Beschreibungen für Dialoge: Beschreibungen für Dialoge, die erst durch mehrstufig erfolgende weitere Aufrufe nach einem Menübefehl oder in einem Objekteditor erscheinen Beschreibungen für Dialoge, die aufgrund ihrer Komplexität nicht auf einer Befehls- oder Objekthilfeseite mit aufgenommen wurden (viele Unterdialoge) " }, 
{ "title" : "Dialog: Importassistent ", 
"url" : "_cds_dlg_import_assistant.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Importassistent ", 
"snippet" : "Importassistent Funktion : Der Dialog ermöglicht die Übernahme von CODESYS -Optionen und Package-Installationen aus einer älteren CODESYS -Installation, die auf dem lokalen Computer gefunden wurde. Aufruf : Der Dialog erscheint, wenn eine neu installierte CODESYS -Version erstmals gestartet wird, un...", 
"body" : "Importassistent Funktion : Der Dialog ermöglicht die Übernahme von CODESYS -Optionen und Package-Installationen aus einer älteren CODESYS -Installation, die auf dem lokalen Computer gefunden wurde. Aufruf : Der Dialog erscheint, wenn eine neu installierte CODESYS -Version erstmals gestartet wird, und auf dem Computer bereits eine ältere Version installiert ist. Programmeinstellungen : Die benutzerspezifischen CODESYS -Optionen werden aus der älteren Installation in die neue Installation übernommen. Packages : Die mit der älteren CODESYS -Version installierten Packages werden in den Package-Manager der neuen Version übernommen. Sehen Sie dazu die Liste der gefundenen Package-Installationen mit den Angaben Name , Version und Installationsdatum . Importieren Die Programmeinstellungen und\/oder Optionen werden in die aktuelle CODESYS -Version übernommen. Überspringen Die Programmeinstellungen und\/oder Optionen werden nicht in die aktuelle CODESYS -Version übernommen. Für weitere Informationen siehe: CODESYS" }, 
{ "title" : "Dialog: Konvertierung einer Bibliotheksreferenz ", 
"url" : "_cds_dlg_library_reference_conversion.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Konvertierung einer Bibliotheksreferenz ", 
"snippet" : "Konvertierung einer Bibliotheksreferenz Funktion : Im Dialog ist definiert, wie Referenzen auf nicht mehr verfügbare Bibliotheken behandelt werden sollen. Hinweis: Die undefinierten Bibliotheksreferenzen finden sich im globalen Bibliotheksverwalter, der in der Ansicht POUs liegt. Aufruf : Der Dialog...", 
"body" : "Konvertierung einer Bibliotheksreferenz Funktion : Im Dialog ist definiert, wie Referenzen auf nicht mehr verfügbare Bibliotheken behandelt werden sollen. Hinweis: Die undefinierten Bibliotheksreferenzen finden sich im globalen Bibliotheksverwalter, der in der Ansicht POUs liegt. Aufruf : Der Dialog erscheint, wenn der Konverter beim Öffnen eines CoDeSys V2.3 -Projekts in V3 eine Bibliothek findet, die in der aktuellen CODESYS -Version nicht mehr verwendet werden kann. Ein CoDeSys V2.3 -Projekt kann nur in ein CODESYS V3 -Projekt konvertiert werden, wenn in CODESYS V3 das Package CODESYS V2.3 Converter installiert ist. Das Package ist im CODESYS Store International erhältlich. Was möchten Sie tun? Die Bibliothek ebenfalls konvertieren und installieren Der Konverter führt auch die Bibliotheksdatei in das neue Format über. Sie bleibt im Projekt referenziert. Sie wird automatisch im Bibliotheks-Repository in Kategorie „Sonstige“ installiert. Wenn die Bibliothek nicht die für eine Installation nötigen Projektinformationen mitbringt, erscheint ein Dialog Projektinformationen eingeben , wo diese nachzutragen sind. Die folgende bereits installierte Bibliothek verwenden Die bisher verwendete Bibliothek wird durch eine andere ersetzt. Über die Schaltfläche Auswählen erscheint dazu ein Dialog zur Auswahl aus den lokalen Bibliotheks-Repositorys. Die Bibliothek ignorieren. Die Referenz wird im konvertierten Projekt nicht erscheinen Die Bibliotheksreferenz wird aus dem Projekt entfernt. Dieses Mapping auch zukünftig verwenden, wenn diese Bibliothek auftritt Die hier im Dialog vorgenommen Einstellungen werden auch für künftige Projektkonvertierungen angewendet. Für weitere Informationen siehe: V2.3-Projekt öffnen" }, 
{ "title" : "Dialog: Funktionsbaustein auswählen ", 
"url" : "_cds_dlg_select_function_block.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Funktionsbaustein auswählen ", 
"snippet" : "Funktionsbaustein auswählen Funktion : Der Dialog dient der Auswahl eines Funktionsbausteins für E\/A-Mapping. Der Funktionsbaustein soll dem auf der Registerkarte <Gerätename> E\/A-Abbild selektierten E\/A-Kanal, oder dem auf Registerkarte <Gerätename> IEC-Objekte selektierten Objekt zugewiesen werden...", 
"body" : "Funktionsbaustein auswählen Funktion : Der Dialog dient der Auswahl eines Funktionsbausteins für E\/A-Mapping. Der Funktionsbaustein soll dem auf der Registerkarte <Gerätename> E\/A-Abbild selektierten E\/A-Kanal, oder dem auf Registerkarte <Gerätename> IEC-Objekte selektierten Objekt zugewiesen werden. Aufruf : Registerkarte <Gerätename> E\/A-Abbild , Befehlsschaltfläche FB für E\/A-Kanal hinzufügen Registerkarte <Gerätename> IEC-Objekte , Befehlsschaltfläche Hinzufügen Der Dialog bietet alle Funktionsbausteine aus der aktiven Applikation und den im Projekt eingebundenen Bibliotheken an, die Folgendes erfüllen: Der Funktionsbaustein ist mit dem Attribut {attribute 'io_function_block'} versehen. Der Funktionsbaustein enthält Eingangs- oder Ausgangsparameter, die zum Kanaltyp (Eingang, Ausgang, Datentyp) passen und mit dem Attribut {attribute 'io_function_block_mapping'} versehen sind. Wenn ein Funktionsbaustein gewählt wird, der mehrere passende Parameter bietet, wird nur der erste davon automatisch auf den Kanal abgebildet. Die weiteren können nur händisch auf der Registerkarte <Gerätename> E\/A-Abbild zugewiesen werden. Nach Zuweisen des Funktionsbausteins wird der Parameter der Funktionsbausteininstanz in der Spalte Variable der Mapping-Tabelle eingetragen. Der Pfad setzt sich folgendermaßen zusammen: <Applikationsname>.<Gerätekanalname>_<Name des FBs>_<fortlaufende FB-Instanz-Nummer>.<FB-Parametername> Beispiel: App1.Out_4_Int_myScale_Output_Int_1.iOutput für den Parameter iOutput der ersten eingefügten Instanz des Funktionsbausteins myScale_Output Suchen Eingabefeld für eine Suche nach Bausteinnamen Type Zum Kanaltyp passende Funktionsbausteine in Baumstruktur Knoten: Applikation, Bibliotheksname(n) Dokumentation Zeigt für die im Baum selektierte Bibliothek oder den Bibliotheksbaustein die verfügbare Dokumentation an Für weitere Informationen siehe: io_function_block, io_function_block_mapping" }, 
{ "title" : "Dialog: Gerätekonvertierung ", 
"url" : "_cds_dlg_device_conversion.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Gerätekonvertierung ", 
"snippet" : "Gerätekonvertierung Funktion : Im Dialog ist definiert, wie Referenzen auf nicht mehr verfügbare Geräte behandelt werden sollen. Aufruf : Der Dialog erscheint, wenn der Konverter beim Öffnen eines CoDeSys V2.3 -Projekts in V3 die Referenzierung eines Geräts findet, das nicht mehr verwendet werden ka...", 
"body" : "Gerätekonvertierung Funktion : Im Dialog ist definiert, wie Referenzen auf nicht mehr verfügbare Geräte behandelt werden sollen. Aufruf : Der Dialog erscheint, wenn der Konverter beim Öffnen eines CoDeSys V2.3 -Projekts in V3 die Referenzierung eines Geräts findet, das nicht mehr verwendet werden kann. Ein CoDeSys V2.3 -Projekt kann nur in ein CODESYS V3 -Projekt konvertiert werden, wenn in CODESYS V3 das Package CODESYS V2.3 Converter installiert ist. Das Package ist im CODESYS Store International erhältlich. Was möchten Sie tun? Das folgende bereits installierte Gerät verwenden CODESYS ersetzt das bisher verwendete Gerät im Gerätebaum durch ein anderes. Über die Schaltfläche Auswählen erscheint dazu ein Dialog zur Auswahl aus dem lokalen Geräte-Repository. Das Gerät ignorieren. Alle gerätespezifischen Objekte werden nicht verfügbar sein. Der Geräteeintrag mit allen darunter eingefügten Objekten wird aus dem Gerätebaum entfernt. Diese Zuordnung für die Zukunft speichern Die hier im Dialog vorgenommen Einstellungen werden in den CODESYS -Optionen, Kategorie CoDeSys V2.3 V2.3-Konverter , gespeichert. Sie sind damit auch für künftige Projektkonvertierungen gültig. Für weitere Informationen siehe: V2.3-Projekt öffnen" }, 
{ "title" : "Dialog: Eigenschaften Haltepunkt ", 
"url" : "_cds_dlg_breakpoint_properties.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Eigenschaften Haltepunkt ", 
"snippet" : "Eigenschaften Haltepunkt Funktion : Der Dialog dient in der Ansicht Haltepunkte zur Darstellung oder Änderung der Eigenschaften des gerade selektierten Haltepunkts. Aufruf : Ansicht Haltepunkte , Schaltfläche Eigenschaften Ansicht Haltepunkte , Schaltfläche Neu , Befehl Neuer Haltepunkt oder Befehl ...", 
"body" : "Eigenschaften Haltepunkt Funktion : Der Dialog dient in der Ansicht Haltepunkte zur Darstellung oder Änderung der Eigenschaften des gerade selektierten Haltepunkts. Aufruf : Ansicht Haltepunkte , Schaltfläche Eigenschaften Ansicht Haltepunkte , Schaltfläche Neu , Befehl Neuer Haltepunkt oder Befehl Neuer Datenhaltepunkt Voraussetzung : In der Liste der Haltepunkte ist ein Eintrag selektiert. Der Dialog ist identisch mit dem Dialog Neuer Haltepunkt , der über die entsprechenden Befehle im Menü Debug geöffnet wird. Sehen Sie deshalb bitte für eine Beschreibung die Hilfeseite zu Dialog Neuer Haltepunkt . " }, 
{ "title" : "Dialog: Rechte ", 
"url" : "_cds_dlg_permissions.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Rechte ", 
"snippet" : "Rechte Funktion : Hier sind die Rechte von Benutzergruppen definiert, mit denen sie bestimmte Aktionen auf bestimmte Objekte im Projekt ausführen dürfen. Aufruf : Befehl Projekt → Benutzerverwaltung Jede vorgenommene Änderung im Dialog wird unmittelbar wirksam....", 
"body" : "Rechte Funktion : Hier sind die Rechte von Benutzergruppen definiert, mit denen sie bestimmte Aktionen auf bestimmte Objekte im Projekt ausführen dürfen. Aufruf : Befehl Projekt → Benutzerverwaltung Jede vorgenommene Änderung im Dialog wird unmittelbar wirksam. " }, 
{ "title" : "Aktionen ", 
"url" : "_cds_dlg_permissions.html#UUID-a96b28c3-bb7e-e6a6-49a3-ce72aed4d7c5_id_a4aafd27a7b86c0a8640e008b3558_id_bed3192ed33cb005c0a8640e01de9170", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Rechte \/ Aktionen ", 
"snippet" : "Unter Aktionen sind alle möglichen Aktionen auf Objekte des Projekts dargestellt. Die Aktionen sind in 4 Kategorien eingeteilt und unter jeder Aktion sind Zuordnungen zu allen aktuellen Projektobjekten zu sehen. Pro Zuordnung Aktion->Objekt können Sie das Recht für jede existierende Benutzergruppe d...", 
"body" : "Unter Aktionen sind alle möglichen Aktionen auf Objekte des Projekts dargestellt. Die Aktionen sind in 4 Kategorien eingeteilt und unter jeder Aktion sind Zuordnungen zu allen aktuellen Projektobjekten zu sehen. Pro Zuordnung Aktion->Objekt können Sie das Recht für jede existierende Benutzergruppe definieren. Aktionenkategorien: Befehle Aktionen bezüglich der Ausführung von Befehlen Benutzer, Gruppen und Rechte Aktionen bezüglich der Konfiguration von Benutzerkonten, Benutzergruppen und deren Rechten Objekttypen Aktionen bezüglich des Anlegens von Objekttypen Projektobjekte Aktionen bezüglich der Anzeige, Bearbeitung, Entfernung und Kindobjektehandhabung von Projektobjekten Aktionen im Einzelnen: Ausführen Ausführen eines Menübefehls Erzeugen Anlegen eines neuen Objekts im Projekt Kindobjekte hinzufügen oder entfernen Unterhalb eines bestehenden Objekts ein Kindobjekt hinzufügen oder entfernen Bearbeiten Modifizieren eines Objekts im Editor oder von Benutzer-, Gruppen- und Rechteeinstellungen im entsprechenden Editor\/Dialog Entfernen Löschen oder Ausschneiden eines Objekts Ansehen Öffnen der Ansicht eines Objekts im Editor Mögliches Ziel einer Aktion Dies können konkrete Projektobjekte, oder die Benutzer-, Gruppen- und Rechtekonfiguration sein. " }, 
{ "title" : "Rechte ", 
"url" : "_cds_dlg_permissions.html#UUID-a96b28c3-bb7e-e6a6-49a3-ce72aed4d7c5_id_a4aafd27a7b86c0a8640e008b3558_id_c220390986c76268c0a864635794e243", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Rechte \/ Rechte ", 
"snippet" : "Unter Rechte finden Sie eine Liste aller aktuell definierten Benutzergruppen (außer der Gruppe „Owner“) und eine Symbolleiste zum Konfigurieren der Rechte für eine Gruppe. erlaubt Die gerade im Aktionen-Fenster ausgewählte Aktion auf das\/die gerade ausgewählte(n) Ziel(e) ist erlaubt , und zwar für d...", 
"body" : "Unter Rechte finden Sie eine Liste aller aktuell definierten Benutzergruppen (außer der Gruppe „Owner“) und eine Symbolleiste zum Konfigurieren der Rechte für eine Gruppe. erlaubt Die gerade im Aktionen-Fenster ausgewählte Aktion auf das\/die gerade ausgewählte(n) Ziel(e) ist erlaubt , und zwar für die gerade selektierte Gruppe. verboten Die gerade im Fenster Aktionen ausgewählte Aktion auf das\/die gerade ausgewählte(n) Ziel(e) ist verboten , und zwar für die gerade selektierte Gruppe. Das Recht, die gerade im Fenster Aktionen ausgewählten Aktionen auf die gerade ausgewählten Ziele auszuführen, wurde nicht explizit erteilt, die Aktionen sind aber standardmäßig erlaubt . Beispielsweise weil das entsprechende Recht dem „Vaterobjekt“ zugewiesen wurde. Beispiel: Die Gruppe hat das Recht für Objekt „myplc“, somit hat sie es standardmäßig auch für Objekt „myplc.pb_1“. Die gerade im Aktionen-Fenster aufgeklappte Aktion auf die gerade ausgewählten Ziele wurde nicht explizit verboten, aber sie ist standardmäßig verboten, beispielsweise weil sie für das „Vaterobjekt“ verboten wurde. kein Symbol Es sind gerade mehrere Aktionen im Aktionen-Fenster ausgewählt sind, für die die Gruppe nicht ein- und dasselbe Recht besitzt.. Symbolleiste: Erlauben Die gerade ausgewählte Aktion auf das gerade ausgewählte Zielobjekt wird für die gerade ausgewählte Gruppe explizit erlaubt. Verbieten Die gerade ausgewählte Aktion auf das gerade ausgewählte Zielobjekt wird für die gerade ausgewählte Gruppe explizit verboten. Zurücksetzen Das Recht zur gerade ausgewählten Aktion auf das gerade ausgewählte Zielobjekt wird für die gerade ausgewählte Gruppe auf den Standardwert zurückgesetzt. Export\/Import Öffnet ein Menü mit den Befehlen Alle Rechte exportieren Ausgewählte Rechte exportieren Rechte importieren Alle Rechte exportieren Exportiert alle Aktionen und ihre konfigurierten Zugriffsrechte des aktuellen Projekts in eine benutzerspezifische Datei des Dateityps *.perms Hierzu öffnet sich der Dialog Rechte exportieren zur Eingabe eines Dateinamens und zur Auswahl eines Speicherorts im Dateiverzeichnis. Als Dateityp ist Persmissions (*.perms) voreingestellt. Ausgewählte Rechte exportieren Exportiert alle selektierten Aktionen und ihre konfigurierten Zugriffsrechte des aktuellen Projekts in eine benutzerspezifische Datei des Dateityps *.perms Hierzu öffnet sich der Dialog Rechte exportieren zur Eingabe eines Dateinamens und zur Auswahl eines Speicherorts im Dateiverzeichnis. Als Dateityp ist Persmissions (*.perms) voreingestellt. Rechte importieren Der Inhalt einer *.perms -Datei wird mit den Aktionen und ihren Rechten des aktuellen Projekts zusammengeführt. Gruppen, die Teil der Datei, aber nicht des Projekts sind, werden ignoriert. Die Aktionen und Rechten werden über den Namen abgeglichen. Wenn sich Rechte der importierten Datei von Rechten im Projekt unterscheiden, werden die Rechte im Projekt überschrieben. Hierzu öffnet sich der Dialog Rechte importieren zur Auswahl der *.perms -Datei aus dem Dateisystem. Für weitere Informationen siehe: Benutzerverwaltung und Zugriffsrechte für Projekt und Objekte konfigurieren " }, 
{ "title" : "Dialog: Wert vorbereiten ", 
"url" : "_cds_dlg_prepare_value.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Wert vorbereiten ", 
"snippet" : "Wert vorbereiten Funktion : Der Dialog dient zur Vorbereitung eines Werts für eine bereits geforcte Variable. CODESYS führt die vorbereitete Aktion mit dem nächsten Forcen aus. CODESYS öffnet den Dialog in folgenden Situationen: Wenn Sie im Deklarationsteil in das Feld vorbereiteter Wert einer gefor...", 
"body" : "Wert vorbereiten Funktion : Der Dialog dient zur Vorbereitung eines Werts für eine bereits geforcte Variable. CODESYS führt die vorbereitete Aktion mit dem nächsten Forcen aus. CODESYS öffnet den Dialog in folgenden Situationen: Wenn Sie im Deklarationsteil in das Feld vorbereiteter Wert einer geforcten Variable klicken Wenn Sie im Implementierungsteil in das Inline-Monitoring-Feld einer geforcten Variablen klicken Wenn Sie im Überwachen-Fenster in das Feld vorbereiteter Wert einer geforcten Variable klicken Einen neuen Wert für die nächste Schreib- oder Force-Operation vorbereiten Wert, den CODESYS bei der nächsten Force-Operation auf die Variable schreibt Vorbereitung mit einem Wert aufheben CODESYS löscht den vorbereiteten Wert. Den Force aufheben, ohne den Wert zu verändern. CODESYS behält den geforcten Wert bei und beendet das Forcen. CODESYS markiert die Variable mit <Unforce> . Den Force aufheben und den Wert auf den Wert zurücksetzen, den er vor der Force-Operation hatte. CODESYS setzt den geforcten Wert zurück und beendet das Forcen. Dabei wird die Variable mit <Unforce and restore> markiert. Für weitere Informationen siehe: Werte forcen" }, 
{ "title" : "Dialog: Neuer Haltepunkt ", 
"url" : "_cds_dlg_new_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Neuer Haltepunkt ", 
"snippet" : "Neuer Haltepunkt Funktion : In dem Dialog definieren Sie die Einstellungen für einen neuen Haltepunkt oder Datenhaltepunkt. Er ist identisch mit dem Dialog Eigenschaften Haltepunkt , der in der Ansicht Haltepunkte verwendet wird.. Aufruf : Befehl Debug → Neuer Haltepunkt Befehl Debug → Neuer Datenha...", 
"body" : "Neuer Haltepunkt Funktion : In dem Dialog definieren Sie die Einstellungen für einen neuen Haltepunkt oder Datenhaltepunkt. Er ist identisch mit dem Dialog Eigenschaften Haltepunkt , der in der Ansicht Haltepunkte verwendet wird.. Aufruf : Befehl Debug → Neuer Haltepunkt Befehl Debug → Neuer Datenhaltepunkt Voraussetzung : Die Applikation ist im Onlinebetrieb. " }, 
{ "title" : "Registerkarte: Bedingung ", 
"url" : "_cds_dlg_new_breakpoint.html#UUID-816d639d-e87b-2c62-8afe-4b8f8899c45f_id_b37f8599ca5eabebc0a864630cdc6bd3_id_1c96e8afbc3c9a60c0a864633bdbd9c2", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Neuer Haltepunkt \/ Registerkarte: Bedingung ", 
"snippet" : "Der Dialog legt fest, unter welchen Voraussetzungen die Programmabarbeitung am Haltepunkt stoppen soll. Die Verwendung bedingter Haltepunkte verlangsamt die Codeausführung, auch wenn die Bedingung nicht TRUE ist. Bedingte Haltepunkte erfordern ein CODESYS Laufzeitsystem >= V3.5.4.0. Tasks Nur anhalt...", 
"body" : "Der Dialog legt fest, unter welchen Voraussetzungen die Programmabarbeitung am Haltepunkt stoppen soll. Die Verwendung bedingter Haltepunkte verlangsamt die Codeausführung, auch wenn die Bedingung nicht TRUE ist. Bedingte Haltepunkte erfordern ein CODESYS Laufzeitsystem >= V3.5.4.0. Tasks Nur anhalten falls der Haltepunkt in einer der folgenden Tasks erreicht wird : CODESYS wertet den Haltepunkt nur aus, wenn er von bestimmten Tasks erreicht wird. Die gewünschten Tasks müssen aktiviert werden. Sie können beispielsweise eine einzige „Debug Task“ definieren und damit verhindern, dass beim Debugging auch andere Tasks betroffen werden, die den Baustein ebenfalls verwenden. Trefferanzahl Trefferanzahl Immer anhalten : Das Programm stoppt immer an diesem Haltepunkt. Alternativ: Das Programm hält am Haltepunkt an, wenn der Haltepunkt so oft getroffen wurde, wie im Folgenden definiert ist (gewünschte Trefferzahl eintragen oder aus der Nummernliste auswählen): Anhalten, wenn die Trefferanzahl gleich Anhalten, wenn die Trefferanzahl ein Vielfaches von Anhalten, wenn die Trefferanzahl größer oder gleich Bedingung Halt, wenn TRUE : CODESYS wertet die angegebene Bedingung aus und hält das Programm an diesem Haltepunkt nur an, wenn das Ergebnis TRUE ist. Als Bedingung können Sie gültige boolesche Ausdrücke eintragen. Beispiele: x>100 , x[y]=z , a AND b , boolVar " }, 
{ "title" : "Registerkarte: Daten ", 
"url" : "_cds_dlg_new_breakpoint.html#UUID-816d639d-e87b-2c62-8afe-4b8f8899c45f_id_b37f8599ca5eabebc0a864630cdc6bd3_id_44f01d14144802b9c0a8640e00e05719", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Neuer Haltepunkt \/ Registerkarte: Daten ", 
"snippet" : "Voraussetzung: Es geht um die Eigenschaften eines „Datenhaltepunkts“. Die Funktion der Datenhaltepunkte ist vom Zielsystem abhängig. Aktuell sind Datenhaltepunkte nur mit der CODESYS Control Win möglich. In der Registerkarte wird die Variable oder Speicheradresse angegeben, für die der Datenhaltepun...", 
"body" : "Voraussetzung: Es geht um die Eigenschaften eines „Datenhaltepunkts“. Die Funktion der Datenhaltepunkte ist vom Zielsystem abhängig. Aktuell sind Datenhaltepunkte nur mit der CODESYS Control Win möglich. In der Registerkarte wird die Variable oder Speicheradresse angegeben, für die der Datenhaltepunkt gesetzt ist oder wird. Ausführung unterbrechen, wenn sich der Wert der angegebenen Variablen ändert Eingabe eines qualifizierten Variablenamens : Auswahl einer Variablen im Dialog Eingabehilfe , in der Kategorie Watch-Variablen Beispiele Variable: PLC_PRG.fb_DoSth.dwVariable Adresse: 16#12A , 0x12A , 129 Größe Anzahl der Bytes der oben angegebenen Variablen oder Speicheradresse, die auf Änderung hin überwacht werden sollen Beim Neueintragen der Variablen\/Adresse wird zunächst automatisch ein zum Datentyp\/Speicherplatz passender Wert eingestellt. Hinweis: Die Größe und Anzahl ist vom Zielsystem abhängig. Für die CODESYS Control Win können maximal 4 Datenhaltepunkte mit einer maximalen Größe von 8 Byte definiert werden. Beispiel: 4 für Datentyp DWORD Beispiel: 2 für Datentyp DWORD : Es werden nur die ersten beiden Bytes der Variablen überwacht. " }, 
{ "title" : "Registerkarte: Ausführungspunkt Einstellungen ", 
"url" : "_cds_dlg_new_breakpoint.html#UUID-816d639d-e87b-2c62-8afe-4b8f8899c45f_id_b37f8599ca5eabebc0a864630cdc6bd3_id_e90f365e144802bbc0a8640e00766226", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Neuer Haltepunkt \/ Registerkarte: Ausführungspunkt Einstellungen ", 
"snippet" : "Hier kann ein bestehender Haltepunkt oder Datenhaltepunkt in einen Ausführungspunkt umgewandelt werden. Ausführungspunkt (Ausführung stoppt nicht am Haltepunkt) : Der Haltepunkt wird zum Ausführungspunkt. Die Abarbeitung hält an diesem Punkt nicht an, es wird jedoch der angegebene Code ausgeführt. A...", 
"body" : "Hier kann ein bestehender Haltepunkt oder Datenhaltepunkt in einen Ausführungspunkt umgewandelt werden. Ausführungspunkt (Ausführung stoppt nicht am Haltepunkt) : Der Haltepunkt wird zum Ausführungspunkt. Die Abarbeitung hält an diesem Punkt nicht an, es wird jedoch der angegebene Code ausgeführt. Ausführungspunkt eines Haltepunkts: aktiviert, deaktiviert Ausführungspunkt eines Datenhaltepunkts: aktiviert, deaktiviert Folgenden Code ausführen Code, der beim Erreichen des Ausführungspunkts ausgeführt wird Schleifenkonstruktionen (For, While) und IF- oder CASE-Ausdrücke sind nicht möglich. Meldung im Geräte-Log ausgeben Diese Option ist nur verfügbar, wenn Sie die Option Logging in Haltepunkten aktivieren in den Projekteinstellungen → Compiler-Optionen freigeschaltet haben. CODESYS kann Variablen mit dem Platzhalter {Variablenname} im Meldungstext ausgegeben. " }, 
{ "title" : "Registerkarte: Ort ", 
"url" : "_cds_dlg_new_breakpoint.html#UUID-816d639d-e87b-2c62-8afe-4b8f8899c45f_id_b37f8599ca5eabebc0a864630cdc6bd3_id_0620c3861dee5ba1c0a8640e0121f47f", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Neuer Haltepunkt \/ Registerkarte: Ort ", 
"snippet" : "Voraussetzung: Der Befehl Neuer Haltepunkt wurde ausgewählt. POU Baustein der aktiven Applikation, in dem der Haltepunkt positioniert ist Position Position des Haltepunkts im Baustein Angabe in Form von Zeilen- und Spaltennummern (Texteditor) oder als Netzwerk- oder Elementnummern Instanzen Bei Funk...", 
"body" : "Voraussetzung: Der Befehl Neuer Haltepunkt wurde ausgewählt. POU Baustein der aktiven Applikation, in dem der Haltepunkt positioniert ist Position Position des Haltepunkts im Baustein Angabe in Form von Zeilen- und Spaltennummern (Texteditor) oder als Netzwerk- oder Elementnummern Instanzen Bei Funktionsbausteinen müssen Sie festlegen, ob der Haltepunkt in der Implementierung oder in einer Instanz gesetzt werden soll. CODESYS setzt den Haltepunkt in der Instanz. Bei dieser Option wählen Sie den Instanzpfad aus. CODESYS setzt den Haltepunkt in der Implementierung. Haltepunkt sofort aktivieren : Der Haltepunkt ist aktiviert. : Der Haltepunkt ist nicht aktiviert. Zur späteren Aktivierung klicken Sie in der Ansicht Haltepunkte auf die Schaltfläche . Für weitere Informationen siehe: Verwenden von Haltepunkten" }, 
{ "title" : "Dialog: Monitoringbereich ", 
"url" : "_cds_dlg_monitoring_range.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Monitoringbereich ", 
"snippet" : "Monitoringbereich Funktion : Der Dialog begrenzt den Bereich an Arrayelementen, deren Werte während des Monitorings angezeigt werden. Aufruf : Klicken Sie in in das Feld der Spalte Datentyp , das zur Arrayvariable gehört. Voraussetzung : Eine POU ist im Onlinebetrieb und wird überwacht. Dabei hat ei...", 
"body" : "Monitoringbereich Funktion : Der Dialog begrenzt den Bereich an Arrayelementen, deren Werte während des Monitorings angezeigt werden. Aufruf : Klicken Sie in in das Feld der Spalte Datentyp , das zur Arrayvariable gehört. Voraussetzung : Eine POU ist im Onlinebetrieb und wird überwacht. Dabei hat eine Variable der POU den Datentyp ARRAY . Gültiger Bereich Gültigkeitsbereich der Arrayelemente, die überwacht werden Beispiel eines dreidimensionalen Arrays: [1..10][-3..3][-10..10] Maximale Zahl an Arrayelementen Anzahl der Elemente der Arrayvariablen Beispiel: 1470 Wenn Sie eine der Einstellungen Start , Ende oder Scrollbereich von 1000 Elementen ändern, werden automatisch die beiden anderen Einstellungen angepasst. Start Index des ersten Arrayelements, dessen Wert angezeigt wird Ende Index des letzten Arrayelements, dessen Wert angezeigt wird Scrollbereich von 1000 Elementen Schiebebalken, um einen Bereich aus der Menge der Arrayelemente auszuwählen Für weitere Informationen siehe: Monitoring in Programmierobjekten aufrufen" }, 
{ "title" : "Dialog: Eigenschaften ", 
"url" : "_cds_f_dlg_properties.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Eigenschaften ", 
"snippet" : "Eigenschaften Der Dialog dient zur Konfiguration der Eigenschaften eines Objekts in CODESYS . Dazu enthält der Dialog je nach Objekt verschiedene Registerkarten, die je eine Kategorie von Eigenschaften behandeln. Aufruf : Menü Ansicht , Kontextmenü des Objekts in der Ansicht Geräte , POUs oder Modul...", 
"body" : "Eigenschaften Der Dialog dient zur Konfiguration der Eigenschaften eines Objekts in CODESYS . Dazu enthält der Dialog je nach Objekt verschiedene Registerkarten, die je eine Kategorie von Eigenschaften behandeln. Aufruf : Menü Ansicht , Kontextmenü des Objekts in der Ansicht Geräte , POUs oder Module Objekte von einigen Add-ons haben zusätzliche Eigenschaften, die in der Hilfe des jeweiligen Add-ons beschrieben sind. Diese speziellen Eigenschaften finden Sie unter: CODESYS Visualization : Eigenschaften des Visualisierungsobjekts CODESYS Visualization Support : Eigenschaften: Textliste CODESYS SFC : Eigenschaften: AS-Einstellungen CODESYS UML : Eigenschaften des UML-Objekts CODESYS CFC : Eigenschaften: CFC-Ausführungsreihenfolge " }, 
{ "title" : "Dialog: Eigenschaften: Allgemein ", 
"url" : "_cds_dlg_properties_common.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Eigenschaften \/ Dialog: Eigenschaften: Allgemein ", 
"snippet" : "Allgemein Funktion : Der Dialog zeigt allgemeinen Informationen zum gerade selektierten Objekt. Aufruf : Befehl Ansicht → Eigenschaften oder Kontextmenü des Objekts, Kategorie Allgemein Voraussetzung : Ein Objekt ist im Gerätebaum oder in der POUs-Ansicht selektiert. Name Objektname wie in POUs- ode...", 
"body" : "Allgemein Funktion : Der Dialog zeigt allgemeinen Informationen zum gerade selektierten Objekt. Aufruf : Befehl Ansicht → Eigenschaften oder Kontextmenü des Objekts, Kategorie Allgemein Voraussetzung : Ein Objekt ist im Gerätebaum oder in der POUs-Ansicht selektiert. Name Objektname wie in POUs- oder Gerätefenster Objekttyp Art des Objekts, zum Beispiel POU, Applikation, Schnittstelle Öffnen mit Typ des Editors, in dem das Objekt angezeigt oder bearbeitet wird " }, 
{ "title" : "Dialog: Eigenschaften: Information ", 
"url" : "_cds_dlg_properties_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Eigenschaften \/ Dialog: Eigenschaften: Information ", 
"snippet" : "Information Funktion : In diesem Dialog können applikationsspezifische Eigenschaften definiert werden. Aufruf : Befehl Ansicht → Eigenschaften, Kontextmenü des Objekts Applikation Voraussetzung : In der Ansicht Geräte oder POUs ist ein Objekt des Typs Applikation selektiert. Dieser Eigenschaften sin...", 
"body" : "Information Funktion : In diesem Dialog können applikationsspezifische Eigenschaften definiert werden. Aufruf : Befehl Ansicht → Eigenschaften, Kontextmenü des Objekts Applikation Voraussetzung : In der Ansicht Geräte oder POUs ist ein Objekt des Typs Applikation selektiert. Dieser Eigenschaften sind sinnvoll, wenn mehrere Applikationen im Projekt vorhanden sind Autor Autor der Applikation Version Version der Applikation, zum Beispiel 0.0.0.1 Beschreibung Beschreibung der Applikation Auf Werte aus der Projektinformation zurücksetzen Die Werte werden zurückgesetzt auf die Werte aus den Projektinformationen. Für weitere Informationen siehe: Projektinformationen" }, 
{ "title" : "Dialog: Eigenschaften: Bootapplikation ", 
"url" : "_cds_dlg_properties_boot_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Eigenschaften \/ Dialog: Eigenschaften: Bootapplikation ", 
"snippet" : "Bootapplikation Funktion : Die Einstellungen in dieser Registerkarte definieren, ob und wann aus der Applikation eine Bootapplikation erzeugt wird. Voraussetzung : Das Gerät unterstützt die Einstellungen. Das Applikationsobjekt ist selektiert. Aufruf : Befehl Ansicht → Eigenschaften , Kategorie Boot...", 
"body" : "Bootapplikation Funktion : Die Einstellungen in dieser Registerkarte definieren, ob und wann aus der Applikation eine Bootapplikation erzeugt wird. Voraussetzung : Das Gerät unterstützt die Einstellungen. Das Applikationsobjekt ist selektiert. Aufruf : Befehl Ansicht → Eigenschaften , Kategorie Bootapplikation oder Kontextmenü Eigenschaften Bootapplikation implizit bei Download Beim Download der Applikation wird automatisch eine Bootapplikation erzeugt. Bootapplikation implizit bei Online-Change Beim Online-Change wird automatisch eine Bootapplikation erzeugt. Beim Schließen des Projekts an Bootapplikation erinnern Vor dem Verlassen des Projekts fragt CODESYS nach, ob die Bootapplikation(en) (neu) angelegt werden soll(en). Bootapplikation nach Erzeugen verifizieren Nach dem Erzeugen der Bootapplikation wird mit einem unabhängigen Dienst geprüft, ob die Bootapplikation korrekt erzeugt wurde. Unabhängig von den hier definierten Voreinstellungen erhalten Sie beim Einloggen immer die Möglichkeit, explizit das Anlegen einer Bootapplikation anzustoßen. " }, 
{ "title" : "Dialog: Eigenschaften: Security ", 
"url" : "_cds_dlg_properties_encryption.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Eigenschaften \/ Dialog: Eigenschaften: Security ", 
"snippet" : "Security Funktion : Der Dialog enthält die Eigenschaften der Applikation bezüglich Verschlüsselung. Wenn der CODESYS Security Agent installiert ist, können Sie hier einen Assistenten für die Verschlüsselung von Downloads, Online-Changes und Bootapplikationen starten. Aufruf : Befehl Ansicht → Eigens...", 
"body" : "Security Funktion : Der Dialog enthält die Eigenschaften der Applikation bezüglich Verschlüsselung. Wenn der CODESYS Security Agent installiert ist, können Sie hier einen Assistenten für die Verschlüsselung von Downloads, Online-Changes und Bootapplikationen starten. Aufruf : Befehl Ansicht → Eigenschaften Kontextmenü eines Applikationsobjekts Die Verschlüsselung mit einem Dongle wird nicht mehr als sichere Verschlüsselungsmethode eingestuft. Es wird empfohlen, stattdessen mit Zertifikaten zu verschlüsseln. Verschlüsselungstechnik Wenn in der Ansicht Security-Screen im Bereich Security-Level die Option Verschlüsselung von Downloads, Online-Changes und Bootapplikationen aktiviert ist, ist in diesem Dialog die Verschlüsselungstechnik Verschlüsselung mit Zertifikaten eingestellt und kann nicht verändert werden. Für weitere Informationen siehe: Applikation schützenKeine Verschlüsselung Einfache Verschlüsselung Sie können die Bootapplikation nur auf die Steuerung laden, wenn der hier definierte Dongle (Lizenzschlüssel) am Rechner steckt. Der Dongle wird von CODESYS GmbH oder dem jeweiligen Hardware-Hersteller bereitgestellt. Der Firmcode wird angezeigt. Geben Sie noch den mitgelieferten Produktcode ein. Verschlüsselung mit Lizenzmanagement Sie können die Bootapplikation nur auf die Steuerung laden, nachdem Sie Produktcode und Firmcode wie hier angegeben eingegeben haben und der entsprechende Dongle am Entwicklungsrechner und an der Steuerung steckt. Die Codes erhalten Sie vom Hersteller, der die Lizenzen verwaltet. Verschlüsselung mit Zertifikaten Sie können die Bootapplikation nur auf die Steuerung laden, wenn ein gültiges Zertifikat dafür vorliegt. Der Bereich Zertifikate ist aktiv. Beschreibung siehe unten. Diese Option ist bereits fest eingestellt, wenn in der Ansicht Security-Screen in der Registerkarte Benutzer die Option Verschlüsselung von Downloads, Online-Changes und Bootapplikationen erzwingen aktiviert ist. Sie können zusätzlich die Option Applikationscode digital signieren aktivieren. Mit Zertifikat signieren Sie können den Applikationscode nur auf die Steuerung laden, wenn er mit einem gültigen Zertifikat signiert wurde. Eine Verschlüsselung ist in diesem Fall nicht nötig. Zertifikate Hinweis: Wenn in der Ansicht Security-Screen im Bereich Security-Level die Option Verschlüsselung von Downloads, Online-Changes und Bootapplikationen aktiviert ist, ist im Dialog Eigenschaften die Verschlüsselungstechnik Verschlüsselung mit Zertifikaten eingestellt und kann nicht verändert werden. : Der Dialog Zertifikatsauswahl öffnet sich. Hier können zuvor installierte Zertifikate von Geräten, für die eine Verschlüsselung von Download, Online-Change und Bootappliaktion aktiviert ist, ausgewählt werden. Die Liste kann mehrere Einträge enthalten, wenn mehrere Geräte berechtigt sind, diese Applikation auszuführen. Applikationscode digital signieren Die Applikation wird mit einer digitalen Signatur signiert. Das Zertifikat für die digitale Signatur ist in der Ansicht Security-Screen in der Registerkarte Benutzer eingetragen. Bereich für die Anzeige der ausgewählten Zertifikate mit zugehörigen Informationen Informationen je Zertifikat: Erzeugt für Erstellt von Gültig ab Gültig bis Daumenabdruck Verschlüsselungsassistent Diese Schaltfläche ist nur verfügbar, wenn der CODESYS Security Agent installiert ist. Sie startet den gleichnamigen Assistenten. Sehen Sie dazu die Hilfe zum CODESYS Security Agent . Für weitere Informationen siehe: Projekt schützen und speichern und Hilfe zum CODESYS Security Agent " }, 
{ "title" : "Dialog: Eigenschaften: Build ", 
"url" : "_cds_dlg_properties_build.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Eigenschaften \/ Dialog: Eigenschaften: Build ", 
"snippet" : "Build Symbol: Funktion : Der Dialog enthält Optionen für das Übersetzen (Build-Vorgang) des Objekts. Aufruf : Befehl Ansicht → Eigenschaften , Kontextmenü des Objekts im Gerätebaum Name Beschreibung Vom Build ausschließen : Das Objekt und rekursiv seine Kindobjekte werden beim nächsten Übersetzungsl...", 
"body" : "Build Symbol: Funktion : Der Dialog enthält Optionen für das Übersetzen (Build-Vorgang) des Objekts. Aufruf : Befehl Ansicht → Eigenschaften , Kontextmenü des Objekts im Gerätebaum Name Beschreibung Vom Build ausschließen : Das Objekt und rekursiv seine Kindobjekte werden beim nächsten Übersetzungslauf nicht berücksichtigt. Der Objekteintrag in der Ansicht Geräte oder POUs wird in grüner Schrift dargestellt. Externe Implementierung (Spätes Binden im Laufzeitsystem) : CODESYS generiert beim Übersetzen des Projekts für dieses Objekt keinen Code. Das Objekt wird erst gelinkt, wenn das Projekt auf dem Zielsystem läuft, vorausgesetzt, es ist dort vorhanden (beispielsweise in einer Bibliothek). Die Länge der Namen dieser Objekte (Funktionsbausteine und Methoden) darf maximal 64 Zeichen betragen. Der Objektname in der Ansicht Geräte oder POUs erhält den Zusatz (EXT) . Systemaufrufe ermöglichen : Ein Systemaufruf (Laufzeitsystem) für Funktionen ist möglich. Hintergrund: Im Gegensatz zu CoDeSys V2.3 kann in V3 der ADR-Operator mit Funktions-, Programm-, Funktionsbaustein- und Methodennamen verwendet werden. Er ersetzt den INSTANCE_OF -Operator. ABER: Es gibt keine Möglichkeit, Funktionspointer innerhalb von CODESYS aufzurufen. Immer binden : Das Objekt ist beim Compiler markiert und damit immer in der Compile-Information enthalten. Dies bedeutet, dass es immer kompiliert und auf die Steuerung geladen wird. Hinweis: Alternativ kann mittels des Pragmas {attribute 'linkalways'} der Compiler angewiesen werden, ein Objekt immer einzubinden. Compiler-Defines Hier können Sie „Defines“ und Bedingungen für das Übersetzen des Objekts eintragen (bedingte Kompilierung). Sie können den Ausdruck expr , der in solchen Pragmas verwendet wird, auch hier eintragen. Mehrere Einträge sind in Form einer Komma separierten Liste möglich (siehe {define} Anweisungen). Beispiel: hallo, test:='1' Zusätzliche Compilerdefinitionen aus der Gerätebeschreibung Definiert im Gerät Auflistung der Compilerdefinitionen, die aus der Gerätebeschreibung stammen Diese Compilerdefinitionen werden beim Übersetzen berücksichtigt, wenn sie im Feld Ignorierte Definitionen nicht aufgelistet sind. Ignorierte Definitionen Auflistung der Compilerdefinitionen aus der Gerätebeschreibung, die beim Übersetzen nicht berücksichtigt werden Kopiert die selektierte Compilerdefinition aus dem Feld Definiert im Gerät in das Feld Ignorierte Definitionen Verschiebt die selektierte Compilerdefinition aus dem Feld Ignorierte Definitionen in das Feld Definiert im Gerät Die Compilerdefinition wird beim Übersetzen berücksichtigt. Für weitere Informationen siehe: Bedingte Pragmas" }, 
{ "title" : "Dialog: Eigenschaften: Zugriffskontrolle ", 
"url" : "_cds_dlg_properties_access_control.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Eigenschaften \/ Dialog: Eigenschaften: Zugriffskontrolle ", 
"snippet" : "Zugriffskontrolle Funktion : Der Dialog dient der Festlegung, welche Benutzergruppen welche Aktionen auf das Objekt ausführen darf. Aufruf : Befehl Ansicht → Eigenschaften , oder im Kontextmenü, Befehl Eigenschaften , Registerkarte Zugriffskontrolle Voraussetzung : In der Ansicht Geräte oder in der ...", 
"body" : "Zugriffskontrolle Funktion : Der Dialog dient der Festlegung, welche Benutzergruppen welche Aktionen auf das Objekt ausführen darf. Aufruf : Befehl Ansicht → Eigenschaften , oder im Kontextmenü, Befehl Eigenschaften , Registerkarte Zugriffskontrolle Voraussetzung : In der Ansicht Geräte oder in der Ansicht POUs ist ein Objekt selektiert. Gruppen, Aktionen und Rechte Tabelle, die für die bestehenden Benutzergruppen zeigt, welche Recht sie haben, eine der folgenden Aktionen auf das Objekt auszuführen: Ansehen Bearbeiten Entfernen Kindobjekte hinzufügen\/löschen Mit Doppelklick auf ein Rechtesymbol öffnen Sie eine Auswahlliste aller möglichen Rechte. Für weitere Informationen siehe: Objekte im Projekt über Zugriffsrechte schützen " }, 
{ "title" : "Dialog: Eigenschaften: Externe Datei ", 
"url" : "_cds_dlg_properties_external_file.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Eigenschaften \/ Dialog: Eigenschaften: Externe Datei ", 
"snippet" : "Eigenschaften: Externe Datei Funktion : In diesem Dialog werden die Eigenschaften des selektierten Objekts (Typ Externe Datei ) dargestellt. Die Eigenschaften wurden beim Hinzufügen des Objekts in den Gerätebaum oder in den Pool initial festgelegt und können hier in diesem Eigenschaftendialog angepa...", 
"body" : "Eigenschaften: Externe Datei Funktion : In diesem Dialog werden die Eigenschaften des selektierten Objekts (Typ Externe Datei ) dargestellt. Die Eigenschaften wurden beim Hinzufügen des Objekts in den Gerätebaum oder in den Pool initial festgelegt und können hier in diesem Eigenschaftendialog angepasst werden. Aufruf : Befehl Ansicht → Eigenschaften , Kontextmenü des Objekts Voraussetzung : In der Ansicht Geräte oder POUs ist ein Objekt des Typs Externe Datei selektiert. Für weitere Informationen siehe: Externe DateiVerwaltung der Datei Legt fest, wie im CODESYS -Projekt die externe Datei gespeichert wird Die Verknüpfung speichern : Gespeichert wird die Dateiverknüpfung, die auf die externe Datei im Windows Dateisystem verweist Hinweis: Der Zugriff über die Dateiverknüpfung schlägt fehl, wenn der externe Speicherort der Datei sich ändert. Die Datei ist nur im Projekt verfügbar, solange sie im angegebenen Speicherort vorhanden ist. Die Verknüpfung speichern und ins Projekt einbetten : Gespeichert wird die Dateiverknüpfung, die auf die externe Datei im Windows Dateisystem verweist. Zusätzlich wird, um die Sicherheit zu erhöhen, eine Kopie der Datei im Projekt abgelegt. Hinweis zum Verhalten bei Zugriff: Nur wenn der Zugriff über die Verknüpfung fehl schlägt, wird auf die Kopie im Projekt zurückgegriffen Wenn die externe Datei sich ändert, wird die Kopie entsprechend der unten ausgewählten Option unter Wenn sich die externe Datei ändert behandelt. Ins Projekt einbetten : Gespeichert wird eine Kopie der externen Datei im Windows Dateisystem Hinweis: Es wird immer auf die Kopie zugegriffen. Wenn sich die externe Datei ändert, wird die projektinterne Kopie nicht aktualisiert. Wenn sich die externe Datei ändert Art der Aktualisierung für die im Projekt gespeicherten Kopie, für die gleichzeitig eine Dateiverknüpfung gespeichert wurde Voraussetzung: Die Option Die Verknüpfung speichern und ins Projekt einbetten ist aktiviert. Die Datei automatisch neu laden : Wenn sich die externe Datei ändert, wird die im Projekt gespeicherte Kopie aktualisiert. Nachfragen, ob die Datei neu geladen werden soll : Wenn sich die externe Datei ändert, erscheint ein Dialog mit der Abfrage, ob die Kopie im Projekt aktualisiert werden soll. Nichts tun : Obwohl die externe Datei sich ändert, bleibt die Kopie im Projekt unverändert. Verknüpfte Datei Informationen über die im Projekt gespeicherte Dateiverknüpfung Voraussetzung: Die Option Die Verknüpfung speichern oder die Option Die Verknüpfung speichern und ins Projekt einbetten ist aktiviert. Name , Ort , Größe , Geändert Informationen über die Dateiverknüpfung Schaltfläche Dateieigenschaften anzeigen Öffnet den Standarddialog Eigenschaften von <Dateiname> der externen Datei im Windows-Dateisystem Dieser Dialog ist identisch mit dem Dialog Eigenschaften , der in Windows über das Kontextmenü der Datei geöffnet werden kann. Eingebettete Datei Informationen über die im Projekt gespeicherte Kopie Voraussetzung: Die Option Die Verknüpfung speichern und ins Projekt einbetten oder Ins Projekt einbetten ist aktiviert. Größe , Geändert Informationen zur Kopie (eingebettete Datei) Eingebettete Datei aktualisieren : Wenn sich die externe Datei geändert hat, wird die im Projekt eingebettete Kopie aktualisiert . Online-Handling Behandlung der Datei während des Onlinebetriebs Übertragung mit Download\/Online-Change : Bei Download und Online-Change wird die externe Datei mit auf die Steuerung geladen und im Zielsystempfad abgelegt. Zielsystempfad (relativ zu \"$PlcLogic$\" auf dem Gerät) Der Zielsystempfad kann auf folgende Weise eingegeben werden: Für Wurzelverzeichnis $PlcLogic$ : Eingabefeld leer lassen Individueller Ordner (noch nicht vorhanden) im Wurzelverzeichnis Beispiel: MySubDirectory Ordner der Applikation (unterhalb von $PlcLogic$ ) Beispiel für Applikation \"App123\": App123 Verschachtelte Ordnerstruktur unterhalb des Applikationsordners Beispiel: App123\/Sub01\/SubSub01 Einen anderen vorhandenen Platzhalter verwenden Beispiel für die Visualisierung: $visu$ Bei der Verwendung vorhandener Pfade auf dem Gerät muss die Groß- und Kleinschreibung beachtet werden. Schaltfläche OK Übernimmt die Einstellungen für das Objekt " }, 
{ "title" : "Dialog: Eigenschaften: Bitmap ", 
"url" : "_cds_dlg_properties_bitmap.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Eigenschaften \/ Dialog: Eigenschaften: Bitmap ", 
"snippet" : "Bitmap Funktion : Der Dialog dient der Festlegung, ob und mit welcher Bitmap-Datei (Bilddatei) das Objekt versehen wird. Das Bitmap wird in der grafischen Ansicht des Bibliotheksverwalters und in der Ansicht Werkzeuge des FUP\/KOP\/AWL-Editors verwendet. Aufruf : Befehl Ansicht → Eigenschaften , Konte...", 
"body" : "Bitmap Funktion : Der Dialog dient der Festlegung, ob und mit welcher Bitmap-Datei (Bilddatei) das Objekt versehen wird. Das Bitmap wird in der grafischen Ansicht des Bibliotheksverwalters und in der Ansicht Werkzeuge des FUP\/KOP\/AWL-Editors verwendet. Aufruf : Befehl Ansicht → Eigenschaften , Kontextmenü des Objekts Voraussetzung : Das Objekt ist in der Ansicht Geräte oder in der Ansicht POUs selektiert. Transparenzfarbe Diese Farbe wird im Bitmap transparent dargestellt. " }, 
{ "title" : "Dialog: Eigenschaften: Optionen Applikationserzeugung ", 
"url" : "_cds_dlg_properties_options_app_generation.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Eigenschaften \/ Dialog: Eigenschaften: Optionen Applikationserzeugung ", 
"snippet" : "Optionen Applikationserzeugung Funktion : Der Dialog enthält Einstellungen, die CODESYS bei der Erzeugung einer Bootapplikation für die Steuerung anwendet. Aufruf : Befehl Ansicht → Eigenschaften , Kontextmenü eines Applikationsobjekts Download Applikation Info Diese Funktionalität erfordert Compile...", 
"body" : "Optionen Applikationserzeugung Funktion : Der Dialog enthält Einstellungen, die CODESYS bei der Erzeugung einer Bootapplikation für die Steuerung anwendet. Aufruf : Befehl Ansicht → Eigenschaften , Kontextmenü eines Applikationsobjekts Download Applikation Info Diese Funktionalität erfordert Compiler-Version >=3.5.0.0, Laufzeitsystemversion >= 3.5.0.0. Die Information zum Inhalt der Applikation wird mit auf die Steuerung geladen. Da dies eine Prüfung auf Unterschiede zwischen der aktuellen Applikation und der Applikation auf der Steuerung ermöglicht, empfehlen wir, die Option aktiviert zu lassen. Es geht um den Vergleich der Anzahl von Bausteinen, der Daten und der Speicherorte. Die Informationen zu den Unterschieden erhalten Sie dann auf der Registerkarte Applikationen des Geräteeditors über die Schaltfläche Details . Ebenso im Meldungsfenster, das erscheint, wenn Sie dabei sind, eine Applikation auf die Steuerung zu laden, die sich von der bereits dort liegenden unterscheidet. Vaterapplikation im Falle einer Exception stoppen Verfügbar für Applikationen mit einer Vaterapplikation Dynamische Speichereinstellungen Für die Applikation wird dynamisch Speicher belegt, beispielsweise bei Verwendung des Operators __NEW . In diesem Fall geben Sie die gewünschte Maximale Speichergröße (Bytes) an. Achtung: Nicht der gesamte Speicher ist für dynamische Objekterstellung verfügbar, sondern einen Teil davon verwendet das System immer für Verwaltungsinformationen. Für weitere Informationen siehe: Applikationscode erzeugen" }, 
{ "title" : "Dialog: Eigenschaften: Zielsystem-Speichereinstellungen ", 
"url" : "_cds_dlg_properties_target_memory_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Eigenschaften \/ Dialog: Eigenschaften: Zielsystem-Speichereinstellungen ", 
"snippet" : "Zielsystem-Speichereinstellungen Funktion : Der Dialog ermöglicht das Ändern der Speichereinstellungen des Zielgeräts. Aufruf : Befehl Ansicht → Eigenschaften , Kontextmenü der Applikation Voraussetzung : Die Applikation ist in der Ansicht Geräte selektiert. Speichereinstellungen des Zielgeräts über...", 
"body" : "Zielsystem-Speichereinstellungen Funktion : Der Dialog ermöglicht das Ändern der Speichereinstellungen des Zielgeräts. Aufruf : Befehl Ansicht → Eigenschaften , Kontextmenü der Applikation Voraussetzung : Die Applikation ist in der Ansicht Geräte selektiert. Speichereinstellungen des Zielgeräts überschreiben : Die in der Gerätebeschreibung hinterlegten Speichereinstellungen werden durch die in Eingangsgröße , Ausgangsgröße und Speichergröße angegebenen Werte überschrieben. Hinweis: Wenn die Speichereinstellungen des Zielgeräts geändert werden, kann auf dem Zielgerät nicht mehr auf eine bestehende Applikation eingeloggt und auch kein Online-Change mehr durchgeführt werden. Eingangsgröße Ausgangsgröße Speichergröße Eingabefelder für die Speichergrößen, mit denen die in der Gerätebeschreibung hinterlegten Werte \"memory-layout\\\\input-size\" , \"memory-layout\\\\output-size\" und \"memory-layout\\\\memory-size\" überschrieben werden Voraussetzung: Die Option Speichereinstellungen des Zielgeräts überschreiben ist aktiviert. " }, 
{ "title" : "Dialog: Eigenschaften: Netzwerkvariablen ", 
"url" : "_cds_dlg_properties_networkvariables.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Eigenschaften \/ Dialog: Eigenschaften: Netzwerkvariablen ", 
"snippet" : "Netzwerkvariablen Symbol: Funktion : In diesem Dialog definieren Sie Netzwerkeigenschaften für die im Gerätebaum selektierte Variablenliste. Daraufhin stehen die in ihr deklarierten Variablen als Netzwerkvariablen zur Verfügung. Aufruf : Kontextmenü der Variablenliste im Gerätebaum → Eigenschaften ,...", 
"body" : "Netzwerkvariablen Symbol: Funktion : In diesem Dialog definieren Sie Netzwerkeigenschaften für die im Gerätebaum selektierte Variablenliste. Daraufhin stehen die in ihr deklarierten Variablen als Netzwerkvariablen zur Verfügung. Aufruf : Kontextmenü der Variablenliste im Gerätebaum → Eigenschaften , dann Auswahl der Registerkarte Netzwerkvariablen Netzwerktyp UDP Task Task der aktuellen Applikation, die die zu sendenden Variablen kontrolliert CODESYS versendet die Variablen immer am Ende eines Task-Zyklus. Variablenlistenkennung Dient der Identifizierung der Netzwerkvariablenliste Muss eindeutig sein Variablen packen Die Größe der Pakete (Telegramme), die übertragen werden, hängt vom Netzwerktyp ab. Bei UDP ist ein Paket 256 Bytes groß. : CODESYS bündelt die Variablen für die Übertragung in Pakete, um möglichst wenig Pakete zu übertragen. Bei Variablen vom Typ Array oder strukturierten Datentypen kann dies zur Aufteilung der Variablen auf mehrere Telegramme führen. Somit sind Dateninkonsistenzen innerhalb dieser Variablen möglich, auch wenn die Variablengröße kleiner als die Paketgröße ist. : CODESYS erzeugt ein Paket pro Variable. Prüfsumme übertragen : Jedem Variablenpaket wird eine Prüfsumme mitgegeben. Die Prüfsumme wird vom Empfänger überprüft, um sicherzustellen, dass die Variablendefinitionen von Sender und Empfänger übereinstimmen. Ein Paket mit nicht passender Prüfsumme wird nicht angenommen. Bestätigung : Für jedes erhaltene Datenpaket sendet CODESYS eine Bestätigungsmeldung. Wenn der Sender keine Bestätigung erhalten hat, bevor er erneut sendet, wird ein Fehler in die Diagnosestruktur geschrieben. Hinweis: Ab Version 3.5.7.0 der Bibliothek NetVarUdp wird kein Empfangskanal mehr belegt, wenn kein bestätigter Transfer gewählt wird. Dadurch ist auch Netzwerkvariablenaustausch zwischen 2 Steuerungen auf 1 Hardwaregerät möglich. Zyklische Übertragung , Intervall CODESYS sendet die Variablen innerhalb des angegebenen Intervalls. Beispiel für Zeitangabe: „T#70ms“ Bei Änderung übertragen , Mindestabstand : CODESYS sendet die Variablen nur, wenn sich ihre Werte geändert haben; mit dem „Mindestabstand“ können Sie angeben, wieviel Zeit mindestens zwischen 2 Übertragungen liegen muss. Bei Ereignis übertragen , Variable : CODESYS sendet die Variablen, sobald die angegebene Variable TRUE wird. Einstellungen Protokollspezifische Einstellungen Die möglichen Einträge hängen von der jeweiligen Netzwerkbibliothek ab: Port : Nummer des Ports, den CODESYS für den Datenaustausch mit anderen Netzwerkteilnehmern verwendet Der Vorgegebene Wert ist „1202“. Den aktuellen Wert können Sie jederzeit im Feld Wert verändern: Feld auswählen, Leertaste drücken, Wert eingeben. Achtung : Die anderen Knoten im Netzwerk müssen denselben Port definieren! Wenn mehr als eine UDP-Verbindung im Projekt definiert ist, wird die Port-Nummer automatisch in allen Konfigurationen an den hier gesetzten Wert angepasst. Broadcast Adr. : Der Vorgegebene Wert ist „255.255.255.255“, was bedeutet, dass der Datenaustausch mit allen Netzwerkteilnehmern erfolgen wird. Den aktuellen Wert können Sie im Feld Wert verändern: Feld auswählen, Leertaste drücken, Adresse bzw. Adressbereich eines Sub-Netzwerks eingeben. Beispiel: 197.200.100.255 , wenn mit allen Knoten kommuniziert werden soll, die IP-Adressen im Bereich von „197.200.100.x“ haben Für weitere Informationen siehe: Konfigurieren eines Netzwerkvariablen-Austauschs" }, 
{ "title" : "Dialog: Eigenschaften: Netzwerkeinstellungen ", 
"url" : "_cds_dlg_properties_network_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Eigenschaften \/ Dialog: Eigenschaften: Netzwerkeinstellungen ", 
"snippet" : "Netzwerkeinstellungen Wenn die Netzwerkfunktionalität vom Gerät unterstützt wird, können die aktuellen Netzwerkeinstellungen für eine GNVL (globale Netzwerkvariablenliste) im Dialog Eigenschaften des Objekts angezeigt und verändert werden. Dabei handelt es sich um die Einstellungen, die beim Einfüge...", 
"body" : "Netzwerkeinstellungen Wenn die Netzwerkfunktionalität vom Gerät unterstützt wird, können die aktuellen Netzwerkeinstellungen für eine GNVL (globale Netzwerkvariablenliste) im Dialog Eigenschaften des Objekts angezeigt und verändert werden. Dabei handelt es sich um die Einstellungen, die beim Einfügen der GNVL in Dialog Netzwerkvariablen-Liste (Empfänger) hinzufügen vorgenommen wurden. Für weitere Informationen siehe: Konfigurieren eines Netzwerkvariablen-Austauschs" }, 
{ "title" : "Dialog: Eigenschaften: Verknüpfung mit Datei ", 
"url" : "_cds_dlg_properties_link_to_file.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Eigenschaften \/ Dialog: Eigenschaften: Verknüpfung mit Datei ", 
"snippet" : "Verknüpfung mit Datei Funktion : Der Dialog definiert die Verknüpfung einer externen Datei mit dem Inhalt der globalen Variablenliste (GVL). Sie können die GVL entweder in eine solche Datei exportieren, oder aus einer solchen Datei importieren. Aufruf : Befehl Ansicht → Eigenschaften , Kontextmenü e...", 
"body" : "Verknüpfung mit Datei Funktion : Der Dialog definiert die Verknüpfung einer externen Datei mit dem Inhalt der globalen Variablenliste (GVL). Sie können die GVL entweder in eine solche Datei exportieren, oder aus einer solchen Datei importieren. Aufruf : Befehl Ansicht → Eigenschaften , Kontextmenü eines Objekts des Typs Globale Variablenliste Dateiname Eingabefeld für den Dateipfad Export vor Übersetzen : Vor jedem Übersetzen des Projekts (beispielsweise mit F11 ) speichert CODESYS eine Datei mit Erweiterung gvl in dem Pfad, der im Feld Dateiname angegeben ist. Import vor Übersetzen : Die Exportdatei, die im Feld Dateiname angegeben ist, wird vor jeder Projektübersetzung automatisch eingelesen. Sie können somit eine GVL, die aus einem anderen Projekt exportiert wurde, importieren, um beispielsweise eine Kommunikation über Netzwerkvariablen aufzusetzen. " }, 
{ "title" : "Dialog: Eigenschaften: Optionen ", 
"url" : "_cds_dlg_properties_options_controller.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Eigenschaften \/ Dialog: Eigenschaften: Optionen ", 
"snippet" : "Optionen...", 
"body" : "Optionen " }, 
{ "title" : "Optionen (Steuerung) ", 
"url" : "_cds_dlg_properties_options_controller.html#UUID-b4ec29e7-91f8-fff3-50ec-7d1a39d7664e_id_efceb58c0a2747d2c0a8640e01d2593a_id_3199fa7b528ae709c0a8640e01bcacf4", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Eigenschaften \/ Dialog: Eigenschaften: Optionen \/ Optionen (Steuerung) ", 
"snippet" : "Funktion : Der Dialog enthält die Einstellungen für Monitoring und das Einloggen für ein Objekt des Typs Gerät. Welche Optionen verfügbar sind, hängt von der Gerätebeschreibung ab. Aufruf : Kontextmenü des Geräteobjekts, oder Befehl Ansicht → Eigenschaften , wenn das Geräteobjekt selektiert ist Über...", 
"body" : "Funktion : Der Dialog enthält die Einstellungen für Monitoring und das Einloggen für ein Objekt des Typs Gerät. Welche Optionen verfügbar sind, hängt von der Gerätebeschreibung ab. Aufruf : Kontextmenü des Geräteobjekts, oder Befehl Ansicht → Eigenschaften , wenn das Geräteobjekt selektiert ist Überwachungsintervall (ms) Intervall für das Monitoring (10 ms - 1000 ms) Interaktiver Login-Mode Dieser Mode dient dazu, ein versehentliches Einloggen auf eine andere Steuerung zu verhindern. Kein Keine Interaktion mit dem Anwender beim Einloggen Entspricht dem bisherigen Verhalten der älteren Versionen ID eingeben Beim Einloggen fordert CODESYS Sie auf, eine ID einzugeben. Die ID ist in der Steuerung hinterlegt. Ohne gültige ID ist kein Einloggen möglich. Bei einem erneuten Einloggen fragt CODESYS nicht mehr nach der ID, wenn der Computername, der Benutzername, der Gerätename und die Geräteadresse unverändert sind. Die Information wird in den Projektoptionen gespeichert. Taste drücken Beim Einloggen erscheint ein Dialog mit der Aufforderung eine Taste auf der Steuerung zu drücken. Der Timeout für diese Aktion ist in der Gerätebeschreibung definiert. Blinken (LED) Beim Einloggen blinkt die verbundene Steuerung. Symbolkonfiguration Variablenzugriff synchron zur IEC-Task : Standardeinstellung, konsistenter Zugriff nicht erlaubt : Konsistenter Zugriff erlaubt Die Einstellung wird erst wirksam, wenn Sie alle Applikationen und Bootapplikationen neu auf die Steuerung laden. Hinweis: Wenn die Option aktiviert ist, kann sich der Jitter für alle IEC-Applikationen auf diesem Gerät erhöhen! Der konsistente Zugriff kann die Echtzeitfähigkeit stören. Für weitere Informationen siehe: Gerät, Generischer Geräteeditor und Symbolkonfiguration " }, 
{ "title" : "Dialog: Eigenschaften: Monitoring ", 
"url" : "_cds_dlg_properties_monitoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Eigenschaften \/ Dialog: Eigenschaften: Monitoring ", 
"snippet" : "Monitoring Funktion : Die Registerkarte enthält Optionen für das Monitoren von Transitionen in der Ablaufsprache. Aufruf : Transitionsobjekt selektieren, Kontextmenü Eigenschaften , oder Befehl Ansicht → Eigenschaften Monitoring freigeben : Eine implizite Variable wird für die Transition angelegt, d...", 
"body" : "Monitoring Funktion : Die Registerkarte enthält Optionen für das Monitoren von Transitionen in der Ablaufsprache. Aufruf : Transitionsobjekt selektieren, Kontextmenü Eigenschaften , oder Befehl Ansicht → Eigenschaften Monitoring freigeben : Eine implizite Variable wird für die Transition angelegt, die immer dann den aktuellen Eigenschaftswert erhält, wenn die Applikation die Transition aufruft. Der zuletzt in dieser Variablen gespeicherte Wert wird im Monitoring dargestellt. Monitoring durch Aufruf : Die zu monitorende Transition wird durch direktes Aufrufen der Transition gelesen. Hinweis: Wenn Sie diese Option aktivieren, müssen Sie mögliche Seiteneffekte bedenken. Solche Seiteneffekte können auftreten, wenn innerhalb der Transition zusätzliche Operationen implementiert sind. Für weitere Informationen siehe: monitoring" }, 
{ "title" : "Dialog: Projekteinstellungen ", 
"url" : "_cds_f_dlg_project_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projekteinstellungen ", 
"snippet" : "Projekteinstellungen Symbol: Funktion : Das Objekt enthält die Grundkonfiguration des Projekts. Sie kann im Dialog Projekteinstellungen bearbeitet werden. Aufruf : Doppelklick auf das Objekt Projekteinstellungen im Gerätebaum, oder Befehl Projekt → Projekteinstellungen CODESYS speichert die Projekte...", 
"body" : "Projekteinstellungen Symbol: Funktion : Das Objekt enthält die Grundkonfiguration des Projekts. Sie kann im Dialog Projekteinstellungen bearbeitet werden. Aufruf : Doppelklick auf das Objekt Projekteinstellungen im Gerätebaum, oder Befehl Projekt → Projekteinstellungen CODESYS speichert die Projekteinstellungen direkt im Projekt. Wenn Sie zum Beispiel ein Projekt auf ein anderes System übertragen, wird auch das Objekt Projekteinstellungen übertragen, ohne dass dafür ein Projektarchiv benötigt wird. Die Projekteinstellungen gelten projektweit und bieten abhängig von den installierten Packages Einstellmöglichkeiten für verschiedene Kategorien, wie zum Beispiel AS oder Benutzer und Gruppen . " }, 
{ "title" : "Dialog: Projekteinstellungen: Benutzer und Gruppen ", 
"url" : "_cds_dlg_project_settings_user_groups.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projekteinstellungen \/ Dialog: Projekteinstellungen: Benutzer und Gruppen ", 
"snippet" : "Benutzer und Gruppen Symbol: Funktion : Der Dialog dient der Konfiguration der Benutzerverwaltung für das aktuelle Projekt. Aufruf : Befehl Projekt → Projekteinstellungen , Kategorie Benutzer und Gruppen...", 
"body" : "Benutzer und Gruppen Symbol: Funktion : Der Dialog dient der Konfiguration der Benutzerverwaltung für das aktuelle Projekt. Aufruf : Befehl Projekt → Projekteinstellungen , Kategorie Benutzer und Gruppen " }, 
{ "title" : "Registerkarte: Benutzer ", 
"url" : "_cds_dlg_project_settings_user_groups.html#UUID-2be88356-b96d-20b2-57af-5b575487a87f_id_c4a56f464271c61c0a8640e019890cd_id_bd8ddfdd6488f1d2c0a8640e00905b40", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projekteinstellungen \/ Dialog: Projekteinstellungen: Benutzer und Gruppen \/ Registerkarte: Benutzer ", 
"snippet" : "Anzeige der Benutzer und ihrer Mitgliedschaften in Gruppen Hinzufügen Öffnet den Dialog Benutzer hinzufügen Bearbeiten Öffnet den Dialog Benutzer bearbeiten Löschen Beim Versuch den letzten Benutzer einer Gruppe zu löschen, erscheint eine Fehlermeldung, da eine Gruppe mindestens ein Mitglied haben m...", 
"body" : "Anzeige der Benutzer und ihrer Mitgliedschaften in Gruppen Hinzufügen Öffnet den Dialog Benutzer hinzufügen Bearbeiten Öffnet den Dialog Benutzer bearbeiten Löschen Beim Versuch den letzten Benutzer einer Gruppe zu löschen, erscheint eine Fehlermeldung, da eine Gruppe mindestens ein Mitglied haben muss. Benutzer hinzufügen \/ Benutzer bearbeiten Eingabefelder für das Einrichten eines neuen oder zum Ändern eines bestehenden Benutzerkontos Aktiviert : (Voreinstellung) Sie können das Benutzerkonto verwenden. : Der Benutzer kann sich nicht anmelden. Wenn der Benutzer wiederholt ein Einloggen mit nicht korrekten Anmeldedaten versucht, kann die Deaktivierung des Kontos automatisch erfolgen, siehe unten: Einstellungen. Mitgliedschaften Auflistung aller Benutzergruppen, die Sie zusätzlich zur Gruppe Everyone (zu der jeder neue Benutzer automatisch gehört) definiert haben <Gruppenname>: Der neue Benutzer gehört der Gruppe an. Export\/Import Benutzer und Gruppen exportieren Der Befehl öffnet den Standarddialog zum Speichern einer Datei im lokalen Dateisystem. Sie können die im Projekt definierten Benutzern und Gruppen in einer Datei *.users im xml-Format ablegen. Benutzer und Gruppen importieren Der Befehl öffnet den Standarddialog zum Suchen nach einer Datei mit der Erweiterung *.users im lokalen Dateisystem, um daraus Benutzer- und Gruppendefinitionen ins Projekt einzulesen. " }, 
{ "title" : "Registerkarte: Gruppen ", 
"url" : "_cds_dlg_project_settings_user_groups.html#UUID-2be88356-b96d-20b2-57af-5b575487a87f_id_c4a56f464271c61c0a8640e019890cd_id_a09a4f276488f1d3c0a8640e011cd62d", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projekteinstellungen \/ Dialog: Projekteinstellungen: Benutzer und Gruppen \/ Registerkarte: Gruppen ", 
"snippet" : "Anzeige der Gruppen und Ihrer Mitglieder Eine Gruppe kann auch Mitglied einer Gruppe sein. Hinzufügen Öffnet den Dialog Gruppe hinzufügen Bearbeiten Öffnet den Dialog Gruppe bearbeiten Löschen Wenn Sie eine Gruppe löschen, bleiben die Benutzerkonten der Mitglieder unverändert. Die Gruppen Everyone u...", 
"body" : "Anzeige der Gruppen und Ihrer Mitglieder Eine Gruppe kann auch Mitglied einer Gruppe sein. Hinzufügen Öffnet den Dialog Gruppe hinzufügen Bearbeiten Öffnet den Dialog Gruppe bearbeiten Löschen Wenn Sie eine Gruppe löschen, bleiben die Benutzerkonten der Mitglieder unverändert. Die Gruppen Everyone und Owner können Sie nicht löschen. Zur Schaltfläche Export\/Import sehen Sie bitte oben bei Benutzer . " }, 
{ "title" : "Registerkarte: Einstellungen ", 
"url" : "_cds_dlg_project_settings_user_groups.html#UUID-2be88356-b96d-20b2-57af-5b575487a87f_id_c4a56f464271c61c0a8640e019890cd_id_fa0bbb63c47411e3a9c4fffae27ed7af", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projekteinstellungen \/ Dialog: Projekteinstellungen: Benutzer und Gruppen \/ Registerkarte: Einstellungen ", 
"snippet" : "Anzeige der Gruppen und Ihrer Mitglieder in Baumstruktur Eine Gruppe kann auch Mitglied einer Gruppe sein. Maximale Anzahl an Anmeldeversuchen : (Voreinstellung) Wenn der Benutzer so oft wie hier angegeben versucht hat, sich mit einem falschen Passwort anzumelden, wird das Benutzerkonto deaktiviert....", 
"body" : "Anzeige der Gruppen und Ihrer Mitglieder in Baumstruktur Eine Gruppe kann auch Mitglied einer Gruppe sein. Maximale Anzahl an Anmeldeversuchen : (Voreinstellung) Wenn der Benutzer so oft wie hier angegeben versucht hat, sich mit einem falschen Passwort anzumelden, wird das Benutzerkonto deaktiviert. : Die Zahl der Fehlversuche ist unbegrenzt. Automatisch abmelden nach Inaktivität : Wenn CODESYS über die hier angegebene Zeitspanne (Minuten) keine Benutzeraktionen über Maus oder Tastatur registriert, wird der Benutzer automatisch abgemeldet. Für weitere Informationen siehe: Projekt schützen und speichern" }, 
{ "title" : "Dialog: Projekteinstellungen: Bibliotheksentwicklung ", 
"url" : "_cds_library_development.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projekteinstellungen \/ Dialog: Projekteinstellungen: Bibliotheksentwicklung ", 
"snippet" : "Bibliotheksentwicklung Symbol: Funktion : Konfiguration der Parameter für den Befehl Überprüfe alle Poolobjekte . Dieser Befehl wird speziell bei Bibliotheken verwendet, um die korrekte Übersetzbarkeit zu überprüfen. Aufruf : Befehl Projekt → Projekteinstellungen, Kategorie Bibliotheksentwicklung Vo...", 
"body" : "Bibliotheksentwicklung Symbol: Funktion : Konfiguration der Parameter für den Befehl Überprüfe alle Poolobjekte . Dieser Befehl wird speziell bei Bibliotheken verwendet, um die korrekte Übersetzbarkeit zu überprüfen. Aufruf : Befehl Projekt → Projekteinstellungen, Kategorie Bibliotheksentwicklung Voraussetzung : Ein Projekt ist geöffnet. Während des Übersetzungsvorgangs einer Applikation werden nur die Bausteine\/Programme\/Funktionen übersetzt, die tatsächlich vom Applikationscode direkt oder indirekt verwendet werden. Der Befehl Überprüfe alle Poolobjekte hingegen prüft auch die nicht verwendeten Bausteine\/Programme\/Funktionen. Dabei sollten, wenn möglich, alle Ablaufpfade im Code berücksichtigt werden. Zu verwendende Compiler-Defines Durchsuchen Durchsucht alle Bausteine\/Programme\/Funktionen der Bibliothek und trägt die gefundenen Compilerdefines als komma-separierte Liste in die Übersicht Zu verwendende Compiler-Defines ein. Bei kaskadierenden {IF defined(…)}-{ELSIF defined(…)} -Anweisungen wird nur das Define bei {IF} berücksichtigt. Überprüfe alle Pool-Objekte Pointergröße Wenn Sie in der Bibliothek eine POINTER-Variable in einer DWORD-Variablen abspeichern, ist diese Bibliothek nur für 32bit-Geräte übersetzbar. Um dieses Problem zu entdecken und zu vermeiden, können Sie die Pointergröße angeben, die beim Befehl Überprüfe alle Poolobjekte angenommen werden soll. Sie können die folgenden Werte auswählen: 32 Bit 64 Bit 32 und 64 Bit Nachfolgendes Beispiel zeigt, wie Sie bei Pointergröße 64 Bit eine ungültige Zuweisungen mit dem Befehl Überprüfe alle Poolobjekte entdecken: FUNCTION F : INT\nVAR\n               \nptr : POINTER TO BYTE;\n               \nptrSave : DWORD;\nEND_VAR\nptrSave := ptr; Diese Zuweisung ergibt den Fehler C0032: Typ 'POINTER TO BYTE' kann nicht in Typ 'DWORD' konvertiert werden . Verwenden Sie folgende Deklaration für ptrSave , um diesen Fehler zu vermeiden: ptrSave : __XWORD; Für weitere Informationen siehe: Überprüfe alle Poolobjekte" }, 
{ "title" : "Dialog: Projekteinstellungen: Compile-Optionen ", 
"url" : "_cds_dlg_project_settings_compile_options.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projekteinstellungen \/ Dialog: Projekteinstellungen: Compile-Optionen ", 
"snippet" : "Compile-Optionen Symbol: Funktion : Informiert über Compiler-Version und konfiguriert Compile-Optionen projektweit Aufruf : Befehl Projekt → Projekteinstellungen , Kategorie Compile-Optionen Voraussetzung : Ein Projekt ist geöffnet. Compilerversion Fix-Version Zeigt die Compilerversion an, die beim ...", 
"body" : "Compile-Optionen Symbol: Funktion : Informiert über Compiler-Version und konfiguriert Compile-Optionen projektweit Aufruf : Befehl Projekt → Projekteinstellungen , Kategorie Compile-Optionen Voraussetzung : Ein Projekt ist geöffnet. Compilerversion Fix-Version Zeigt die Compilerversion an, die beim Übersetzen und während des Ladens zum Übersetzen verwendet wird. Eine Aktualisierung auf die neueste Compilerversion ist möglich, ein Zurücksetzen auf eine ältere Version jedoch nicht. Einstellungen Unicode-Zeichen für Bezeichner erlauben Standardmäßig deaktiviert, da die Verwendung von Unicode-Zeichen in Bezeichnernamen in der IEC-Norm nicht zulässig ist Eventuell notwendig für asiatische Sprachen Konstanten ersetzen : (Voreinstellung) Für jede Konstante skalaren Typs (nicht für STRING , ARRAY oder Strukturen) wird direkt der Wert geladen. Im Onlinebetrieb werden die Konstanten im Deklarationseditor oder Monitoring-Fenster durch ein dem Wert vorangestelltes Symbol gekennzeichnet. In diesem Fall ist ein Zugriff, zum Beispiel über einen ADR -Operator, Forcen und Schreiben, nicht möglich. : Der Zugriff auf Konstanten ist möglich, allerdings verlängert dies die Rechenzeit. Logging in Haltepunkten Für als Ausführungspunkte definierte Haltepunkte können Sie im Dialog Haltepunkteeigenschaften einen Meldungstext eintragen. Dieser Text wird im Geräte-Log ausgegeben, wenn die Applikation am Ausführungspunkt stoppt. UTF8-Kodierung für STRING : Zeichenfolgen mit Datentyp STRING werden projektweit im ASCII-Format kodiert. Ein Indexzugriff auf das Literal funktioniert. : Zeichenfolgen mit Datentyp STRING werden projektweit im UTF-8-Format kodiert. Das gilt für jedes STRING -Literal und wird auch bei deren Monitoring angewendet. Ein Indexzugriff auf das UTF-8-Literal ist nicht ratsam und führt überwiegend zu Fehlert. Wenn eine projektweite Kodierung nach UTF-8-Format nicht gewünscht ist, kann ein einzelner Variablentyp mit einem vorangestellten UTF8# implizit konvertiert werden. UTF-8-Kodierung nur bei projektweiter Konfigurierung Eine UTF-8-Kodierung wird verwendet, wenn die projektweit gültige Compile-Option UTF8-Kodierung für STRING aktiviert ist. Bibliotheksfunktionen und Add-ons orientieren sich dann auch gemäß diesem Setting. Wenn Sie einzelne UTF-8 kodierte Strings verwenden, dann müssen Sie dafür Sorge tragen, dass diese überall dort, wo sie verwendet werden, auch richtig interpretiert werden. Eine String-Variable im OPC-Server wird zum Beispiel vor der Übertragung zu einem Client nach UTF-8 konvertiert, wenn das Setting nicht angewählt ist. Werte wie beispielsweise UTF8#'äöü' würden dann falsch interpretiert werden. Ähnliche Probleme können bei der Ausgabe von Strings in der Visualisierung entstehen. Projekt-Defines bearbeiten Öffnet den Dialog Projekt-Defines bearbeiten . Compilerwarnungen Maximale Anzahl von Warnungen Bezieht sich auf die Warnungen, die im Meldungsfenster ausgegeben werden Die Auswahl der angezeigten Compiler-Warnungen legen Sie im Dialog Projekteinstellungen in der Kategorie Compilerwarnungen fest. Dialog: Projekt-Defines bearbeiten Projekt-Define hinzufügen Fügt in der Tabelle eine neue Zeile hinzu. Mit einem Doppelklick auf diese Zeile öffnet sich der Zeileneditor und der Bezeichner für das neue Projekt-Define kann eingegeben werden. Das neue Projekt-Define muss ein gültiger IEC-Bezeichner sein. Die Projekt-Defines sind im gesamten Projekt und in allen angezogenen Bibliotheken gültig. Sie gelten nicht in öffentlichen Schnittstellen. Für weitere Informationen zu Projekt-Defines siehe: project_defined (<global define>) " }, 
{ "title" : "Dialog: Projekteinstellungen: Compilerwarnungen ", 
"url" : "_cds_dlg_project_settings_compile_warnings.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projekteinstellungen \/ Dialog: Projekteinstellungen: Compilerwarnungen ", 
"snippet" : "Compilerwarnungen Symbol: Funktion : Der Dialog dient der Auswahl der Compilerwarnungen, die CODESYS bei einem Kompilierungslauf im Meldungsfenster anzeigt. Aufruf : Befehl Projekt → Projekteinstellungen , Kategorie Compilerwarnungen Voraussetzung : Ein Projekt ist geöffnet. Durch Klicken auf die Ch...", 
"body" : "Compilerwarnungen Symbol: Funktion : Der Dialog dient der Auswahl der Compilerwarnungen, die CODESYS bei einem Kompilierungslauf im Meldungsfenster anzeigt. Aufruf : Befehl Projekt → Projekteinstellungen , Kategorie Compilerwarnungen Voraussetzung : Ein Projekt ist geöffnet. Durch Klicken auf die Checkbox können die einzelnen Meldungen folgendermaßen konfiguriert werden: : Die Meldung wird nicht ausgegeben : Die Meldung wird als Warnung ausgegeben Die Meldung wird als Fehler ausgegeben. Ein Download der Applikation ist nicht möglich Die maximale Anzahl aufgelisteter Warnungen legen Sie im Dialog Compileroptionen fest. Für weitere Informationen siehe: Compile-Optionen" }, 
{ "title" : "Dialog: Projekteinstellungen: Download Quellcode ", 
"url" : "_cds_dlg_project_settings_source_code.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projekteinstellungen \/ Dialog: Projekteinstellungen: Download Quellcode ", 
"snippet" : "Download Quellcode Symbol: Funktion : Der Dialog definiert die Übertragung und die Speicherung des Quellcodes als Quellcode-Download-Archiv auf eine oder mehrere Steuerungen. Aufruf : Befehl Projekt → Projekteinstellungen , Kategorie Download Quellcode Ein Quellcode-Download-Archiv ist ein Projektar...", 
"body" : "Download Quellcode Symbol: Funktion : Der Dialog definiert die Übertragung und die Speicherung des Quellcodes als Quellcode-Download-Archiv auf eine oder mehrere Steuerungen. Aufruf : Befehl Projekt → Projekteinstellungen , Kategorie Download Quellcode Ein Quellcode-Download-Archiv ist ein Projektarchiv mit dem Namen Archiv.prj . Zielgerät Definiert den Speicherort des Projektarchivs <Name der Steuerung> Ausgewählte Steuerung CODESYS lädt das Projektarchiv auf diese Steuerung. Voraussetzung: Das Projekt enthält mehrere Steuerungen. <Alle Geräte im Projekt> CODESYS lädt das Projektarchiv auf alle Steuerungen des Projekts. Umfang Definiert den Inhalt des Projektarchivs Kompakten Download verwenden : Das Projektarchiv enthält nur das Gerät des Projekts, das die aktive Applikation enthält. : Das Projektarchiv enthält alle Geräte des Projekts. Zusätzliche Dateien Öffnet den Dialog Zusätzliche Dateien , in dem Sie zusätzliche Dateien für den Download auswählen können Zeitpunkt Definiert, wann CODESYS ein Projektarchiv erzeugt Implizit beim Programm-Download und Online-Change CODESYS lädt bei jedem Laden einer Applikation und jedem Online-Change, ohne weitere Eingabeaufforderung, zusätzlich das Projektarchiv auf das oder die Zielgeräte. Implizit beim Erzeugen einer Bootapplikation CODESYS lädt bei jedem Erzeugung einer Bootapplikation, ohne weitere Eingabeaufforderung, zusätzlich das Projektarchiv auf das oder die Zielgeräte. Implizit beim Erzeugen eines Bootapplikation, Download und Online-Change CODESYS lädt bei jeder Erzeugung eines Bootapplikation, bei jedem Laden einer Applikation und bei jedem Online-Change, ohne weitere Eingabeaufforderung, zusätzlich das Projektarchiv auf das oder die Zielgeräte. Aufforderung beim Programm-Download und Online-Change CODESYS öffnet bei jedem Laden einer Applikation und jedem Online-Change eine Eingabeaufforderung. Dort können Sie wählen, ob CODESYS das Projektarchiv auf die Steuerung lädt. Nur auf Anforderung Nur bei Aufruf des Befehls Online → Quellcode auf verbundene Steuerung laden öffnet eine Eingabeaufforderung. Dort können Sie wählen, ob CODESYS das Projektarchiv auf die Steuerung lädt. Für weitere Informationen siehe: Laden des Quellcodes auf\/von der SPS" }, 
{ "title" : "Dialog: Projekteinstellungen - Monitoring ", 
"url" : "_cds_dlg_project_settings_monitoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projekteinstellungen \/ Dialog: Projekteinstellungen - Monitoring ", 
"snippet" : "Monitoring Symbol: Funktion : Der Dialog enthält Einstellungen zur Darstellung von Variablenwerten im Monitoring. Aufruf : Befehl Tools → Optionen , Kategorie Monitoring Darstellung von Integervariablen Binär Der Wert der Variablen wird im Onlinebetrieb im entsprechenden Format dargestellt. Diese Op...", 
"body" : "Monitoring Symbol: Funktion : Der Dialog enthält Einstellungen zur Darstellung von Variablenwerten im Monitoring. Aufruf : Befehl Tools → Optionen , Kategorie Monitoring Darstellung von Integervariablen Binär Der Wert der Variablen wird im Onlinebetrieb im entsprechenden Format dargestellt. Diese Option entspricht der Einstellung des Befehls Debug → Darstellung . Dezimal Hexadezimal Anzahl der angezeigten Stellen Nachkommastellen, die im Onlinebetrieb bei der Darstellung von REAL-Werten angezeigt werden Hinweis: Die Einstellungen wirken auf die Überwachungsliste, das Monitoring des Deklarationseditors und den Traceeditor. Die Konfiguration für das Inline-Monitoring des Editors wird in den Optionen des Texteditors eingestellt. Strukturierte Darstellung der Vererbungshierarchie : Die Vererbungshierarchie von Funktionsbausteinen und Strukturen wird in einer Baumstruktur dargestellt. Die Variablen werden dabei als Kindknoten des Funktionsbausteins oder der Struktur dargestellt, in dem sie deklariert sind. : Die Darstellung erfolgt als flache Liste. Für weitere Informationen siehe: Registerkarte Monitoring " }, 
{ "title" : "Dialog: Projekteinstellungen: Seiteneinstellungen ", 
"url" : "_cds_dlg_project_settings_page_setup.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projekteinstellungen \/ Dialog: Projekteinstellungen: Seiteneinstellungen ", 
"snippet" : "Seiteneinstellungen Symbol: Funktion : Der Dialog definiert das Layout für die Druckversion des Projektinhalts. Das Layout betrifft den Ausdruck der Projektinformationen mit dem Befehl Datei → Drucken und den Ausdruck der Projektdokumentation mit dem Befehl Projekt → Dokumentieren . Aufruf : Befehl ...", 
"body" : "Seiteneinstellungen Symbol: Funktion : Der Dialog definiert das Layout für die Druckversion des Projektinhalts. Das Layout betrifft den Ausdruck der Projektinformationen mit dem Befehl Datei → Drucken und den Ausdruck der Projektdokumentation mit dem Befehl Projekt → Dokumentieren . Aufruf : Befehl Projekt → Projekteinstellungen , Kategorie Seiteneinstellungen Sie können Einstellungen für folgende Eigenschaften vornehmen: Papier Ränder Kopf-\/Fußzeile Dokument Deckblatt Kopfzeile bearbeiten \/ Fußzeile bearbeiten Die Kopf- und Fußzeilen sind in Tabellenform strukturiert. Sie können Zeilen und Spalten konfigurieren und die entstehenden Zellen jeweils mit Text oder Bild füllen. Zeilenüberspannung Anzahl der Zeilen, die CODESYS zu einer einzigen Zeile verschmelzen soll Spaltenüberspannung Anzahl der Spalten, die CODESYS zu einer einzigen Spalte verschmelzen soll Öffnet die Liste der verfügbaren Platzhalter für das Feld Text CODESYS versorgt die Platzhalter beim Ausdrucken der Seite mit den aktuellen Werten. " }, 
{ "title" : "Dialog: Projekteinstellungen: Sicherheit ", 
"url" : "_cds_dlg_project_settings_security.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projekteinstellungen \/ Dialog: Projekteinstellungen: Sicherheit ", 
"snippet" : "Sicherheit Symbol: Funktion : Der Dialog dient der Konfiguration des Projektschutzes durch ein Passwort, einen Dongle oder ein Zertifikat. Aufruf : Befehl Projekt → Projekteinstellungen , Kategorie Sicherheit Wenn das Verschlüsselungspasswort verloren geht, können Sie das Projekt nicht mehr öffnen. ...", 
"body" : "Sicherheit Symbol: Funktion : Der Dialog dient der Konfiguration des Projektschutzes durch ein Passwort, einen Dongle oder ein Zertifikat. Aufruf : Befehl Projekt → Projekteinstellungen , Kategorie Sicherheit Wenn das Verschlüsselungspasswort verloren geht, können Sie das Projekt nicht mehr öffnen. Sie können es auch nicht mehr restaurieren! Kein Schutz : Die Projektdatei ist nicht vor unautorisiertem Zugriff und Datenmanipulation geschützt. Hinweis: Es wird dringend empfohlen, eine Security-Funktionalität zu verwenden. : Die Optionen Passwort , Dongle , Zertifikate können nicht ausgewählt werden. Integritätsprüfung Wenn Sie ein neues Projekt erstellen, ist diese Option standardmäßig aktiviert. : Die Projektdatei ist in einem proprietären Format gespeichert und ihre Integrität wird jedesmal geprüft, wenn das Projekt geladen wird. Die Datei kann inkompatibel mit älteren Versionen des Entwicklungssystems sein. Bitte beachten Sie, dass die Projektdatei nicht verschlüsselt ist. Um Ihre Daten besser zu schützen, aktivieren Sie eine der Verschlüsselungsfunktionalitäten. Verschlüsselung : Die Verschlüsselungsfunktionalitäten Passwort , Dongle , Zertifikate können ausgewählt werden. Passwort Eingabe, Änderung und Bestätigung des Verschlüsselungspassworts Wenn Sie das Projekt mit diesen Einstellungen speichern, müssen Sie später das Passwort eingeben, um das Projekt erneut zu öffnen, auch wenn es als Bibliotheksreferenz geladen werden soll. Dongle Voraussetzung: Sie haben den CODESYS Security Key (Dongle) mit dem Rechner verbunden. Hinzufügen : Dialog Registrierten Dongle hinzufügen erscheint. Registrierte Dongles Auswahlliste der registrierten Dongles Zertifikate Zertifikate werden für die Verschlüsselung des Inhalts der gerade geöffneten Projektdatei verwendet. Voraussetzung: Die Zertifikate für alle Benutzer, die das Projekt teilen, müssen im lokalen Speicher installiert sein. : Der Dialog Zertifikatsauswahl öffnet sich. Registrierten Dongle hinzufügen Dongle Auswahlliste aller verbundenen Dongles Aktualisieren CODESYS aktualisiert die Auswahlliste. Blinken Die LEDs des gerade ausgewählten Dongles blinken zwei Sekunden lang (falls dieser die Funktionalität unterstützt). Der Dongle muss mit dem Rechner verbunden sein, wenn CODESYS das Projekt lädt, auch wenn es als Bibliotheksreferenz geladen wird. Für weitere Informationen siehe: Projekt schützen und speichern" }, 
{ "title" : "Dialog: Projekteinstellungen: Static Analysis Light ", 
"url" : "_cds_dlg_project_settings_stat_analysis_light.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projekteinstellungen \/ Dialog: Projekteinstellungen: Static Analysis Light ", 
"snippet" : "Static Analysis Light Symbol: Funktion : Der Dialog aktiviert die Prüfungen, die bei der Light-Version der Statischen Analyse in CODESYS bei einer Codeerzeugung jeweils durchführt werden. Aufruf : Befehl Projekt → Projekteinstellungen , Kategorie Static Analysis Light Sie können die statische Codean...", 
"body" : "Static Analysis Light Symbol: Funktion : Der Dialog aktiviert die Prüfungen, die bei der Light-Version der Statischen Analyse in CODESYS bei einer Codeerzeugung jeweils durchführt werden. Aufruf : Befehl Projekt → Projekteinstellungen , Kategorie Static Analysis Light Sie können die statische Codeanalyse für Codeteile ausschließen, indem Sie den Code mit dem Pragma {analysis} oder dem Pragma {attribute 'analysis' := '...'} kennzeichnen. Für weitere Informationen siehe: Code statisch analysieren" }, 
{ "title" : "Zusätzliche Kompilierungsprüfungen ", 
"url" : "_cds_dlg_project_settings_stat_analysis_light.html#UUID-bce0b3be-97a6-5ed6-5660-1fba15122580_id_e31a3b0a7345218c0a8640e011b5c22_id_2475103c69e2cf17c0a864637d7f918d", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projekteinstellungen \/ Dialog: Projekteinstellungen: Static Analysis Light \/ Zusätzliche Kompilierungsprüfungen ", 
"snippet" : "SA0033: Nicht verwendete Variablen Ermittelt Variablen, die deklariert sind, aber innerhalb des kompilierten Programmcodes nicht verwendet werden Für GVL-Variablen: Wenn es in einem Projekt mehrere Applikationen gibt, werden nur die Objekte unter der gerade aktiven Applikation berücksichtigt. Wenn e...", 
"body" : "SA0033: Nicht verwendete Variablen Ermittelt Variablen, die deklariert sind, aber innerhalb des kompilierten Programmcodes nicht verwendet werden Für GVL-Variablen: Wenn es in einem Projekt mehrere Applikationen gibt, werden nur die Objekte unter der gerade aktiven Applikation berücksichtigt. Wenn es nur eine einzige Applikation gibt, werden auch die Objekte in der Ansicht POUs betrachtet. SA0028: Überlappende Speicherbereiche Ermittelt die Codestellen, durch die 2 oder mehr Variablen denselben Speicherplatz belegen Beispielsweise tritt dies auf, wenn es die folgenden Deklarationen gibt: var1 AT %QB21: INT und var2 AT %QD5: DWORD . In diesem Fall verwenden beide Variablen Byte 21, d. h. die Speicherbereiche der Variablen überlappen. SA0006: Schreibzugriff aus mehreren Tasks Ermittelt Variablen, auf die von mehr als einer Task geschrieben werden SA0004: Mehrfacher Schreibzugriff auf Ausgang Ermittelt Ausgänge, die an mehr als einer Position geschrieben werden Hinweis: Es wird kein Fehler ausgegeben, wenn auf eine Ausgabevariable ( VAR_IN_OUT ) in verschiedenen Zweigen von IF oder CASE Anweisungen geschrieben werden. Hinweis: Diese Regel kann nicht über Pragma abgeschaltet werden! SA0027: Mehrfachverwendungen von Bezeichnern Ermittelt Mehrfachverwendung des Namens\/Bezeichners einer Variable oder eines Objekts (POU) innerhalb des Gültigkeitsbereichs eines Projekts Die folgenden Fälle werden abgedeckt: Der Name einer Enumerationskonstante ist derselbe, wie der in einer anderen Aufzählung innerhalb der Applikation oder einer eingebundenen Bibliothek verwendeten. Der Name einer Variablen ist derselbe wie der eines Objekts innerhalb der Applikation oder einer eingebundenen Bibliothek. Der Name einer Variablen ist derselbe wie der einer Enumerationskonstante in einer Enumeration in der Applikation oder einer eingebundenen Bibliothek. Der Name eines Objekts ist derselbe wie der eines anderen Objekts in der Applikation. Der Name einer Variablen ist derselbe wie der Name einer Methode. Der Name eines Objekts ist derselbe wie der Name eines Objekts, das übergeordnet ist („Parent object“). SA0167: Temporäre Funktionsbaustein-Instanzen Die Prüfung ermittelt Funktionsbaustein-Instanzen, die als temporäre Variablen deklariert sind. Dies betrifft Instanzen, die in einer Methode oder in einer Funktion oder als VAR_TEMP deklariert sind, und die deshalb in jedem Abarbeitungszyklus oder bei jedem Bausteinaufruf neu initialisiert werden. SA0175 : Verdächtige Operation bei einem String Standardmäßig inaktiv Identifiziert Codestellen, die bei einer UTF-8-Kodierung verdächtig sind Folgende Konstrukte werden erfasst: Indexzugriff auf einen Single-Byte-String Beispiel: str[2] Meldung: Verdächtige Operation auf String: Indexzugriff ' <expression> ' Adresszugriff auf einen Single-Byte-String Beispiel: ADR(str) Meldung: Verdächtige Operation auf String: Möglicher Indexzugriff ' <expression> ' Aufruf einer Stringfunktion der Standardbibliothek außer CONCAT und LEN Meldung: Verdächtige Operation auf String: Möglicher Indexzugriff ' <expression> ' Einzelnes Byte-Literal, das Nicht-ASCII-Zeichen enthält Beispiel: str := '99€'; str := 'Ä'; Meldung: Verdächtige Operation auf String: Literal ' <literal> ' enthält Nicht-ASCII-Zeichen Abhängig vom Ergebnis der Prüfung ist es ratsam, die Compile-Option UTF-8-Kodierung für Strings nicht zu aktivieren. Für weitere Informationen siehe: Compile-OptionenBeispiele SA0003: Leere Anweisungen ;\n(* Comment *);\niVar; SA0006: Gleichzeitiger Zugriff FUNCTION_BLOCK ADD_FB\ng_iTemp1 := g_iTemp1 + INT#1; PROGRAM PLC_PRG \/\/controlled by MainTask\ng_iTemp1 := g_iTemp1 + INT#2;\ng_xTemp2 := g_iTemp1 > INT#10; PROGRAM PLC_PRG_1 \/\/controlled by SubTask\ng_iTemp1 := g_iTemp1 - INT#3;\ng_xTemp2 := g_iTemp1 < INT#-10; SA0004: Mehrfacher Schreibzugriff auf Ausgang VAR_GLOBAL\n g_xVar AT %QX0.0 : BOOL ;\n g_iTest AT %QW0 : INT ;\nEND_VAR PROGRAM PLC_PRG\nIF iCondition < INT#0 THEN\n g_xVar := TRUE;\n g_iTest := INT#12;\nEND_IF CASE iCondition OF\n INT#1:\n g_xVar := FALSE;\n INT#2:\n g_iTest := INT#11;\n ELSE\n g_xVar := TRUE;\n g_iTest := INT#9;\nEND_CASE SA0006: Schreibzugriff aus mehreren Tasks FUNCTION_BLOCK ADD_FB\ng_iTemp1 := g_iTemp1 + INT#1;\n PROGRAM PLC_PRG \/\/ Controlled by MainTask\ng_iTemp1 := g_iTemp1 + INT#2;\ng_xTemp2 := g_iTemp1 > INT#10; PROGRAM PLC_PRG_1 \/\/Controlled by SubTask\ng_iTemp1 := g_iTemp1 - INT#3;\ng_xTemp2 := g_iTemp1 < INT#-10; SA0027: Mehrfachverwendung des Namens PROGRAM PLC_PRG\nVAR\n ton : INT; \/\/ error SA0027\nEND_VAR SA0029: Notation in Implementierung und Deklaration unterschiedlich Im Gerätebaum gibt es einen Baustein PLC_PRG und einen Baustein fnc (Funktion). PROGRAM PLC_PRG\nVAR\n iVar:INT;\n _123test_var_: INT;\nEND_VAR\n ivar := iVar + 1; \/\/ notation different to that in the declaration part -> SA0029\n_123TEST_var_ := _123test_var_INT; \/\/ notation different to that in the declaration part -> SA0029\nFnc(); \/\/ notation different to that in the devices tree -> SA0029 SA0167: Temporäre Funktionsbaustein-Instanzen PROGRAM PLC_PRG\nVAR\nEND_VAR\nVAR_TEMP\n yafb: AFB;\nEND_VAR\n\n FUNCTION Fun : INT\nVAR_INPUT\nEND_VAR\nVAR\n funafb: AFB;\nEND_VAR METHOD METH: INT\nVAR_INPUT\nEND_VAR\nVAR\n methafb: AFB;\nEND_VAR Für weitere Informationen siehe: Code statisch analysieren" }, 
{ "title" : "Dialog: Projekteinstellungen: Visualisierung ", 
"url" : "_cds_dlg_project_settings_visualization.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projekteinstellungen \/ Dialog: Projekteinstellungen: Visualisierung ", 
"snippet" : "Visualisierung Symbol: Funktion : Der Dialog dient der Konfiguration der projektweiten Einstellungen für Objekte des Typs Visualisierung . Aufruf : Befehl Projekt → Projekteinstellungen , Kategorie Visualisierung Voraussetzung : Ein Projekt ist geöffnet....", 
"body" : "Visualisierung Symbol: Funktion : Der Dialog dient der Konfiguration der projektweiten Einstellungen für Objekte des Typs Visualisierung . Aufruf : Befehl Projekt → Projekteinstellungen , Kategorie Visualisierung Voraussetzung : Ein Projekt ist geöffnet. " }, 
{ "title" : "Registerkarte: Allgemein ", 
"url" : "_cds_dlg_project_settings_visualization.html#UUID-a7420fda-c00e-6880-4017-0aae347dbd65_id_ec5a4b10864b2e0c0a8640e008c94e5_id_97bc6eea60007fddc0a8640e010193e0", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projekteinstellungen \/ Dialog: Projekteinstellungen: Visualisierung \/ Registerkarte: Allgemein ", 
"snippet" : "Visualisierungsverzeichnisse Textlisten-Dateien Verzeichnis, das Textlisten enthält, die im Projekt zur Verfügung stehen, um Texte für verschiedene Sprachen zu konfigurieren CODESYS verwendet das Verzeichnis zum Beispiel beim Exportieren oder Importieren von Textlisten. Mit Klick auf die Schaltfläch...", 
"body" : "Visualisierungsverzeichnisse Textlisten-Dateien Verzeichnis, das Textlisten enthält, die im Projekt zur Verfügung stehen, um Texte für verschiedene Sprachen zu konfigurieren CODESYS verwendet das Verzeichnis zum Beispiel beim Exportieren oder Importieren von Textlisten. Mit Klick auf die Schaltfläche erscheint der Dialog Ordner suchen , der das Auswählen eines Verzeichnisses im Dateisystem ermöglicht. Bilddateien Verzeichnis, das Bilddateien enthält, die im Projekt zur Verfügung stehen Mehrere Ordner sind mit einem Strichpunkt voneinander getrennt. CODESYS verwendet das Verzeichnis zum Beispiel beim Exportieren oder Importieren von Bilddateien. Mit Klick auf die Schaltfläche erscheint der Dialog Ordner suchen , der das Auswählen eines Verzeichnisses im Dateisystem ermöglicht. Erweitert Eigenschaften-Handling in allen Elementeigenschaften aktivieren : Sie können ein Visualisierungselement in denjenigen seiner Eigenschaften, in denen Sie eine IEC-Variable auswählen, auch mit einer Eigenschaft konfigurieren. CODESYS erzeugt dann beim Übersetzen einer Visualisierung zusätzlichen Code für das Eigenschaften-Handling. Voraussetzung: Ihr IEC-Code enthält mindestens ein Objekt des Typs Schnittstelleneigenschaft , also eine Eigenschaft . Voraussetzung: Die Option Sichtbar ist aktiviert. Implizite Prüfungen für Visualisierungs-POUs aktivieren : Die implizite Prüfung wird auch für Visualisierungs-POUs durchgeführt. Dadurch wird zusätzlicher Code erzeugt, so dass der Speicherverbrauch steigt. Bei begrenztem Speicher sollte diese Option deaktiviert werden. " }, 
{ "title" : "Registerkarte: Symbolbibliotheken ", 
"url" : "_cds_dlg_project_settings_visualization.html#UUID-a7420fda-c00e-6880-4017-0aae347dbd65_id_ec5a4b10864b2e0c0a8640e008c94e5_id_a34bf5cec3c311e388b6f6b960add9a6", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projekteinstellungen \/ Dialog: Projekteinstellungen: Visualisierung \/ Registerkarte: Symbolbibliotheken ", 
"snippet" : "Visualisierungssymbolbibliotheken Symbolbibliotheken Liste aller installierten Symbolbibliotheken, zum Beispiel VisuSymbols Aktiv : Die Symbolbibliothek ist im Projekt ausgewählt und CODESYS stellt sie in der Ansicht Visualisierungswerkzeuge einer Visualisierung zur Verfügung. : Die Symbolbibliothek...", 
"body" : "Visualisierungssymbolbibliotheken Symbolbibliotheken Liste aller installierten Symbolbibliotheken, zum Beispiel VisuSymbols Aktiv : Die Symbolbibliothek ist im Projekt ausgewählt und CODESYS stellt sie in der Ansicht Visualisierungswerkzeuge einer Visualisierung zur Verfügung. : Die Symbolbibliothek ist im Bibliotheks-Repository installiert, aber CODESYS stellt sie in der Ansicht Visualisierungswerkzeuge einer Visualisierung nicht zur Verfügung. Für weitere Informationen siehe: CODESYS Visualization -Hilfe " }, 
{ "title" : "Dialog: Projekteinstellungen: Visualisierungsprofil ", 
"url" : "_cds_dlg_project_settings_visualzation_profile.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projekteinstellungen \/ Dialog: Projekteinstellungen: Visualisierungsprofil ", 
"snippet" : "Visualisierungsprofil Symbol: Funktion : Der Dialog ermöglicht die Einstellung des Visualisierungsprofils. Aufruf : Befehl Projekt → Projekteinstellungen , Kategorie Visualisierungsprofil Voraussetzung : Ein Projekt ist geöffnet. Visualisierungsprofil Bestimmtes Profil Profil, das CODESYS im Projekt...", 
"body" : "Visualisierungsprofil Symbol: Funktion : Der Dialog ermöglicht die Einstellung des Visualisierungsprofils. Aufruf : Befehl Projekt → Projekteinstellungen , Kategorie Visualisierungsprofil Voraussetzung : Ein Projekt ist geöffnet. Visualisierungsprofil Bestimmtes Profil Profil, das CODESYS im Projekt verwendet und das die Visualisierungselemente bestimmt, die im Projekt zur Verfügung stehen Die Auswahlliste enthält alle bisher installierten Profile. " }, 
{ "title" : "Dialog: Projektumgebung ", 
"url" : "_cds_f_dlg_project_environment.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projektumgebung ", 
"snippet" : "Projektumgebung Funktion : Der Dialog dient der Überprüfung auf Aktualität von Software und Dateien, die im Projekt eingebunden sind. CODESYS überprüft zum Beispiel den ausgewählten Compiler und stellt fest, ob eine neuere Version vorhanden ist. In so einem Fall können Sie dann die betroffenen Kompo...", 
"body" : "Projektumgebung Funktion : Der Dialog dient der Überprüfung auf Aktualität von Software und Dateien, die im Projekt eingebunden sind. CODESYS überprüft zum Beispiel den ausgewählten Compiler und stellt fest, ob eine neuere Version vorhanden ist. In so einem Fall können Sie dann die betroffenen Komponenten aktualisieren. Aufruf : Menü Projekt " }, 
{ "title" : "Dialog: Projektumgebung: Bibliotheksversionen ", 
"url" : "_cds_dlg_project_environment_library_version.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projektumgebung \/ Dialog: Projektumgebung: Bibliotheksversionen ", 
"snippet" : "Bibliotheksversionen Funktion : Der Dialog zeigt die Bibliotheken des geöffneten Projekts, für die neuere Versionen verfügbar sind. Aufruf : Befehl Projekt → Projektumgebung , Registerkarte Bibliotheksversion Dieser Dialog erscheint automatisch, wenn Sie ein Projekt öffnen, das veraltete Bibliotheke...", 
"body" : "Bibliotheksversionen Funktion : Der Dialog zeigt die Bibliotheken des geöffneten Projekts, für die neuere Versionen verfügbar sind. Aufruf : Befehl Projekt → Projektumgebung , Registerkarte Bibliotheksversion Dieser Dialog erscheint automatisch, wenn Sie ein Projekt öffnen, das veraltete Bibliotheken enthält. Die Liste zeigt den Namen der veralteten Bibliothek mit Version, die aktuell verfügbare Version und die geplante Aktion. Aktion Doppelklicken Sie in das Feld, um die gewünschte Aktionen auszuwählen. Beim Laden dieses Projekts automatisch nach Aktualisierungen suchen : Die Prüfung erfolgt bei jedem Öffnen des Projekts. : Die Prüfung erfolgt nur einmal. Alles auf \"neueste\" setzen CODESYS verwendet die neueste verfügbare Version der Bibliothek. OK CODESYS führt die ausgewählte(n) Aktion(en) aus. " }, 
{ "title" : "Dialog: Projektumgebung: Compilerversion ", 
"url" : "_cds_dlg_project_environment_compiler_version.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projektumgebung \/ Dialog: Projektumgebung: Compilerversion ", 
"snippet" : "Compilerversion Funktion : Der Dialog zeigt die aktuelle Compilerversion des Projekts und bietet die Möglichkeit, diese zu aktualisieren. Aufruf : Befehl Projekt → Projektumgebung , Registerkarte Compilerversion Aktuelle Compilerversion im Projekt Zeigt die eingestellte Compilerversion des geöffnete...", 
"body" : "Compilerversion Funktion : Der Dialog zeigt die aktuelle Compilerversion des Projekts und bietet die Möglichkeit, diese zu aktualisieren. Aufruf : Befehl Projekt → Projektumgebung , Registerkarte Compilerversion Aktuelle Compilerversion im Projekt Zeigt die eingestellte Compilerversion des geöffneten Projekts Empfohlen, neueste Version Zeigt die neueste Version an Aktion Nicht aktualisieren : Die zuletzt im Projekt eingestellte Compilerversion bleibt erhalten. Aktualisieren auf x.x.x.x : Für das Projekt wird die neueste Compilerversion eingestellt. Ein Zurücksetzen auf die frühere Version ist danach nicht mehr möglich. Beim Laden dieses Projekts automatisch nach Aktualisierungen suchen : CODESYS prüft bei jedem Öffnen des Projekts, ob neue Versionen verfügbar sind. Wenn dies der Fall ist, erscheint automatisch der entsprechende Aktualisierungsdialog. : Keine Prüfung der Compilerversion. Die Aktualisierungsdialoge erscheinen nicht mehr automatisch. Alles auf \"neueste\" setzen Die Compilerversion wird auf die neueste Version gesetzt. " }, 
{ "title" : "Dialog: Projektumgebung: Geräteversionen ", 
"url" : "_cds_dlg_project_environment_device_versions.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projektumgebung \/ Dialog: Projektumgebung: Geräteversionen ", 
"snippet" : "Geräteversionen Funktion : Der Dialog zeigt die Geräte des geöffneten Projekts, für die neuere Versionen verfügbar sind. Aufruf : Befehl Projekt → Projektumgebung , Registerkarte Geräteversionen Dieser Dialog erscheint automatisch, wenn Sie ein Projekt öffnen, das veraltete Geräte enthält. Namen der...", 
"body" : "Geräteversionen Funktion : Der Dialog zeigt die Geräte des geöffneten Projekts, für die neuere Versionen verfügbar sind. Aufruf : Befehl Projekt → Projektumgebung , Registerkarte Geräteversionen Dieser Dialog erscheint automatisch, wenn Sie ein Projekt öffnen, das veraltete Geräte enthält. Namen der veralteten Geräte und deren Version, sowie die aktuell verfügbare Version und die geplante Aktion Aktion Doppelklicken Sie in das Feld, um die gewünschte Aktionen auszuwählen. Auf Aktualisierungen hin überprüfen, wenn dieses Projekt geladen wird : Die Prüfung erfolgt bei jedem Öffnen des Projekts. : Die Prüfung erfolgt nur einmal. Alles auf \"neueste\" setzen CODESYS verwendet die neueste verfügbare Version der Bibliothek. OK CODESYS führt die ausgewählte(n) Aktion(en) aus. " }, 
{ "title" : "Dialog: Projektumgebung: Visualisierungsprofil ", 
"url" : "_cds_dlg_project_environment_visualization_profile.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projektumgebung \/ Dialog: Projektumgebung: Visualisierungsprofil ", 
"snippet" : "Visualisierungsprofil Funktion : Der Dialog zeigt das aktuelle Visualisierungsprofil des Projekts an. Das Profil kann hier aktualisiert werden. Aufruf : Befehl Projekt → Projektumgebung , Registerkarte Visualisierungsprofil Aktuelles Visualisierungsprofil im Projekt Das eingestellte Visualisierungsp...", 
"body" : "Visualisierungsprofil Funktion : Der Dialog zeigt das aktuelle Visualisierungsprofil des Projekts an. Das Profil kann hier aktualisiert werden. Aufruf : Befehl Projekt → Projektumgebung , Registerkarte Visualisierungsprofil Aktuelles Visualisierungsprofil im Projekt Das eingestellte Visualisierungsprofil des geöffneten Projekts Empfohlen, neuestes Profil Die neueste Version Aktion Nicht aktualisieren : Das Visualisierungsprofil des Projekts bleibt erhalten. Aktualisieren auf x.x.x.x : CODESYS aktualisiert das Projekt auf das gewählte Visualisierungsprofil. Auf Aktualisierung hin überprüfen, wenn dieses Projekt geladen wird : CODESYS prüft bei jedem Öffnen des Projekts, ob neue Profile verfügbar sind. Wenn dies der Fall ist, erscheint automatisch der entsprechende Aktualisierungsdialog. : Keine Prüfung des Profils erfolgt beim Öffnen des Projekts. Die Aktualisierungsdialoge erscheinen nicht mehr automatisch. Alles auf \"neueste\" setzen CODESYS aktualisiert das Profil. Für weitere Informationen siehe: CODESYS Visualization -Hilfe " }, 
{ "title" : "Dialog: Projektumgebung: Visualisierungsstile ", 
"url" : "_cds_dlg_project_environment_visualization_style.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projektumgebung \/ Dialog: Projektumgebung: Visualisierungsstile ", 
"snippet" : "Visualisierungsstile Funktion : Der Dialog zeigt den aktuellen Visualisierungsstil des Projekts und bietet die Möglichkeit, diesen zu aktualisieren. Aufruf : Befehl Projekt → Projektumgebung , Registerkarte Visualisierungsstile Für die folgenden aktuell verwendeten Visualisierungsstile sind neuere V...", 
"body" : "Visualisierungsstile Funktion : Der Dialog zeigt den aktuellen Visualisierungsstil des Projekts und bietet die Möglichkeit, diesen zu aktualisieren. Aufruf : Befehl Projekt → Projektumgebung , Registerkarte Visualisierungsstile Für die folgenden aktuell verwendeten Visualisierungsstile sind neuere Versionen verfügbar Visualisierungsstil Version des eingestellten Visualisierungsstiles des geöffneten Projekts Aktuell Aktuelle Version des Visualisierungsstils Beispiel: 3.5.6.0 Empfohlen Empfohlene Version des Visualisierungsstils Beispiel: 3.5.7.0 Aktion Nicht aktualisieren : Der Visualisierungsstil des Projekts bleibt erhalten. Aktualisieren auf x.x.x.x : CODESYS aktualisiert das Projekt auf die Version des gewählten Visualisierungsstils. Auf Aktualisierung hin überprüfen, wenn dieses Projekt geladen wird : CODESYS prüft bei jedem Öffnen des Projekts, ob neue Versionen verfügbar sind. Wenn dies der Fall ist, erscheint automatisch der entsprechende Aktualisierungsdialog. : Keine Prüfung der Version erfolgt. Die Aktualisierungsdialoge erscheinen nicht mehr automatisch. Alles auf \"neueste\" setzen CODESYS aktualisiert die Version. Für weitere Informationen siehe: Visualisierungsstile verwenden " }, 
{ "title" : "Dialog: Projektumgebung: Visualisierungssymbole ", 
"url" : "_cds_dlg_project_environment_visualization_symbols.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Projektumgebung \/ Dialog: Projektumgebung: Visualisierungssymbole ", 
"snippet" : "Visualisierungssymbole Funktion : Der Dialog listet installierte Symbolbibliotheken auf und ermöglicht, dass Sie Symbolbibliotheken dem Projekt zuweisen können. Aufruf : Befehl Projekt → Projektumgebung , Registerkarte Visualisierungssymbole Voraussetzung : Das geöffnete Projekt enthält eine Visuali...", 
"body" : "Visualisierungssymbole Funktion : Der Dialog listet installierte Symbolbibliotheken auf und ermöglicht, dass Sie Symbolbibliotheken dem Projekt zuweisen können. Aufruf : Befehl Projekt → Projektumgebung , Registerkarte Visualisierungssymbole Voraussetzung : Das geöffnete Projekt enthält eine Visualisierung und ist mit einer Compilerversion < 3.5.7.0 gespeichert worden. CODESYS kennt Symbolbibliotheken ab Compilerversion 3.5.7.0 . Symbolbibliothek Liste aller installierten Symbolbibliotheken Aktiv : Die Symbolbibliothek ist für das Projekt ausgewählt. CODESYS stellt deren Symbole in der Ansicht Visualisierungswerkzeuge zur Verfügung. : Die Symbolbibliothek ist bisher nur im Bibliotheks-Repository installiert. Für weitere Informationen siehe: CODESYS Visualization -Hilfe, Kapitel \"Symbolbibliothek in der Visualisierung verwenden\" " }, 
{ "title" : "Dialog: Optionen ", 
"url" : "_cds_f_dlg_options.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen ", 
"snippet" : "Optionen Funktion : Der Dialog dient zur Auswahl der CODESYS -Optionen, mit denen Sie das Verhalten und Aussehen der Benutzeroberfläche konfigurieren. CODESYS speichert die aktuellen Einstellungen auf dem lokalen System als Standardeinstellungen. Aufruf : Befehl Tools → Optionen...", 
"body" : "Optionen Funktion : Der Dialog dient zur Auswahl der CODESYS -Optionen, mit denen Sie das Verhalten und Aussehen der Benutzeroberfläche konfigurieren. CODESYS speichert die aktuellen Einstellungen auf dem lokalen System als Standardeinstellungen. Aufruf : Befehl Tools → Optionen " }, 
{ "title" : "Dialog: Optionen: Bibliotheken ", 
"url" : "_cds_dlg_options_lib.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Bibliotheken ", 
"snippet" : "Bibliotheken Symbol: Funktion : Der Dialog dient dem Verwalten der Abbildungen von Bibliotheksreferenzen, die CODESYS bei der Konvertierung eines alten Projekts anwendet. Wenn Sie für eine bestimmte Bibliothek noch keine Abbildung gespeichert haben, müssen Sie bei jedem Öffnen eines altes Projekt, i...", 
"body" : "Bibliotheken Symbol: Funktion : Der Dialog dient dem Verwalten der Abbildungen von Bibliotheksreferenzen, die CODESYS bei der Konvertierung eines alten Projekts anwendet. Wenn Sie für eine bestimmte Bibliothek noch keine Abbildung gespeichert haben, müssen Sie bei jedem Öffnen eines altes Projekt, in das diese Bibliothek eingebunden ist, die Abbildung neu definieren. Aufruf : Befehl Tools → Optionen , Kategorie Bibliotheken Eine Abbildung definiert, wie eine Bibliotheksreferenz nach der Konvertierung des Projekts ins aktuelle Format aussieht. Es gibt drei Möglichkeiten: Sie behalten die Referenz bei. Das bedeutet, dass CODESYS die Bibliothek ebenfalls ins aktuelle Format (*.library) konvertiert und im lokalen Bibliotheks-Repository installiert. Sie ersetzen eine Referenz durch eine andere Referenz. Das bedeutet, dass eine der installierten Bibliotheken die bisher eingebundene Bibliothek ersetzt. Sie löschen die Referenz. Das bedeutet, dass das konvertierte Projekt die Bibliothek nicht mehr einbindet. CODESYS wendet alle aufgelisteten Abbildungen bei der nächsten Konvertierung eines alten Projekts auf dessen Bibliotheksreferenzen an. Somit müssen Sie die Abbildungsdefinition wiederholen, wenn dieselbe Bibliothek wieder in einem zu konvertierenden Projekt eingebunden ist. In der letzten Zeile können Sie eine neue Abbildung eingeben. Quellbibliothek Pfad der Bibliothek, die im Projekt vor der Konvertierung eingebunden ist Ein Doppelklick auf einen Eintrag macht das Feld editierbar und die Schaltfläche für die Eingabeunterstützung erscheint. Zielbibliothek Name und Speicherort der Bibliothek, die nach der Konvertierung im Projekt eingebunden sein soll Ein Doppelklick auf einen Eintrag öffnet den Dialog Zielsystembibliothek setzen . Dialog Zielsystembibliothek setzen Durchsuchen Der Dialog Bibliothek hinzufügen erscheint. Dort können Sie eine Bibliothek des Bibliotheks-Repositorys auswählen. Der Dialog entspricht dem Dialog im Bibliotheks-Repository. Ignorieren. Diese Bibliotheksreferenz wird nicht importiert. Wenn CODESYS das Projekt konvertiert, entfernt CODESYS immer die vorliegende Quellbibliothek aus dem Projekt. " }, 
{ "title" : "Dialog: Optionen: Download Bibliotheken ", 
"url" : "_cds_dlg_options_lib_download.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Download Bibliotheken ", 
"snippet" : "Download Bibliotheken Symbol: Funktion : Der Dialog dient der Einstellung von Download-Servern. Aufruf : Befehl Tools → Optionen , Kategorie Bibliotheken Download Wenn Sie auf die Schaltfläche Download fehlender Bibliotheken im Bibliotheksverwalter klicken, durchsucht CODESYS diese Download-Server n...", 
"body" : "Download Bibliotheken Symbol: Funktion : Der Dialog dient der Einstellung von Download-Servern. Aufruf : Befehl Tools → Optionen , Kategorie Bibliotheken Download Wenn Sie auf die Schaltfläche Download fehlender Bibliotheken im Bibliotheksverwalter klicken, durchsucht CODESYS diese Download-Server nach Bibliotheken, die im Bibliotheksverwalter als fehlend markiert sind und verwendet die eingestellten Zugangsdaten für den Proxy-Server. Download-Server URL eines Servers, der Bibliotheksdateien enthält Doppelklick auf (Neuen Download-Server hier eintragen) Ein Eingabefeld öffnet sich, in dem Sie die URL-Adresse eines Servers eingeben können. Für weitere Informationen siehe: Bibliotheksverwalter und Proxy-Einstellungen" }, 
{ "title" : "Dialog: Optionen: CoDeSys V2.3 -Konverter ", 
"url" : "_cds_dlg_options_v23_convert.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: CoDeSys V2.3 -Konverter ", 
"snippet" : "CoDeSys V2.3 -Konverter Symbol: Funktion : Der Dialog dient der Definition des Abbilds bei der Konvertierung eines CoDeSys V2.3 -Projekts. Aufruf : Befehl Tools → Optionen , Kategorie CoDeSys V2.3 -Konverter Ein CoDeSys V2.3 -Projekt kann nur in ein CODESYS V3 -Projekt konvertiert werden, wenn in CO...", 
"body" : "CoDeSys V2.3 -Konverter Symbol: Funktion : Der Dialog dient der Definition des Abbilds bei der Konvertierung eines CoDeSys V2.3 -Projekts. Aufruf : Befehl Tools → Optionen , Kategorie CoDeSys V2.3 -Konverter Ein CoDeSys V2.3 -Projekt kann nur in ein CODESYS V3 -Projekt konvertiert werden, wenn in CODESYS V3 das Package CODESYS V2.3 Converter installiert ist. Das Package ist im CODESYS Store International erhältlich. Registerkarte Geräte Auflistung und Definition der Geräteabbilder bei einer Konvertierung Alle Geräteabbilder dieser Auflistung werden auch bei der nächsten Konvertierung eines CoDeSys V2.3 -Projekts wirksam. Somit müssen Sie die Abbilddefinition nicht neu erstellen, wenn das gleiche Gerät in mehreren Projekten verwendet wird. Quellgerät Ein Doppelklick auf einen Eintrag oder leeres Feld öffnet den Dialog Ursprüngliches Gerät auswählen . CODESYS listet dort alle Geräte auf, die der Konverter verarbeitet kann. Zielgerät Ein Doppelklick auf einen Eintrag oder auf ein leeres Feld öffnet den Dialog Zielsystem auswählen . Wählen Sie ein Zielsystem aus der Liste der installierten Geräte : Bestätigung der Auswahl mit OK . Keines : Das Quellgerät wird im neuen Projekt nicht verfügbar sein. Dies bedeutet auch, dass applikationsspezifische Objekte wie zum Beispiel die Taskkonfiguration nicht übernommen werden . Registerkarte Visualisierungen Definiert die Handhabung der Darstellungsvariante CODESYS TargetVisu und CODESYS WebVisu beim Öffnen eines CoDeSys V2.3 -Projekts Import der Target-Visualisierung Import der Web-Visualisierung Auswahlliste Versuche das alte Verhalten zu imitieren : Die Option ist verfügbar, wenn das gerade verwendete Gerät die Option unterstützt. Die Option bewirkt, dass die neuen TargetVisu- oder WebVisu-Einstellungen möglichst genau den Einstellungen im alten Projekt entsprechen. Den Benutzer einmal fragen : Nur beim ersten Import eines „alten“ Visualisierungsprojekts fordert CODESYS den Anwender auf, die Einstellungen zu definieren. Danach wendet CODESYS die Einstellungen automatisch bei allen weiteren Visualisierungsimports an. Den Benutzer fragen : Bei jedem Öffnen eines „alten“ Visualisierungsprojekts fordert CODESYS den Anwender auf, die Einstellungen zu definieren. Einstellungen der Gerätebeschreibung : CODESYS setzt die Einstellungen gemäß den Einträgen in der Gerätebeschreibung des installierten Zielgeräts. Versuche das alte Verhalten zu imitieren : Die Option ist nur verfügbar, wenn das gerade verwendete Gerät die Option unterstützt. Die Option bewirkt, dass die neuen Darstellungsvarianteneinstellungen für Target- oder Webvisu möglichst genau den Einstellungen im alten Projekt entsprechen. CODESYS TargetVisu unterstützt nicht den Zugriff auf VAR_IN_OUT -Variablen, da dies der Compiler nicht unterstützt. Dieses Verhalten entspricht dem Verhalten von CoDeSys V2.3 -Target-Visualisierungen. Für weitere Informationen siehe: V3" }, 
{ "title" : "Dialog: Optionen: Debugging ", 
"url" : "_cds_dlg_options_debugging.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Debugging ", 
"snippet" : "Debugging Symbol: Funktion : Die Option in diesem Dialog steuert, ob Haltepunkte nach einem Reset noch aktiviert sind. Aufruf : Befehl Tools → Optionen , Kategorie Debugging Haltepunkte nach Reset wiederherstellen : Nach dem Befehl Reset kalt oder Reset warm sind alle gesetzten Haltepunkte noch akti...", 
"body" : "Debugging Symbol: Funktion : Die Option in diesem Dialog steuert, ob Haltepunkte nach einem Reset noch aktiviert sind. Aufruf : Befehl Tools → Optionen , Kategorie Debugging Haltepunkte nach Reset wiederherstellen : Nach dem Befehl Reset kalt oder Reset warm sind alle gesetzten Haltepunkte noch aktiviert. : Nach dem Befehl Reset kalt oder Reset warm sind alle Haltepunkte deaktiviert. " }, 
{ "title" : "Dialog: Optionen: Deklarationseditor ", 
"url" : "_cds_dlg_options_declaration_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Deklarationseditor ", 
"snippet" : "Deklarationseditor Symbol: Funktion: Der Dialog dient der Konfiguration der Anzeigeeinstellungen für den Deklarationseditor. Aufruf Befehl Tools → Optionen , Kategorie Deklarationseditor Nur textuell Textuelle Ansicht des Deklarationseditors Nur tabellarisch Tabellarische Ansicht des Deklarationsedi...", 
"body" : "Deklarationseditor Symbol: Funktion: Der Dialog dient der Konfiguration der Anzeigeeinstellungen für den Deklarationseditor. Aufruf Befehl Tools → Optionen , Kategorie Deklarationseditor Nur textuell Textuelle Ansicht des Deklarationseditors Nur tabellarisch Tabellarische Ansicht des Deklarationseditors Umschaltbar zwischen textuell und tabellarisch Der Deklarationseditor bietet zwei Schaltflächen, um zwischen der textuellen und der tabellarischen Ansicht zu wechseln. : textuelle Ansicht : tabellarische Ansicht Die folgende Option definiert die Ansicht, die standardmäßig beim Öffnen eines Programmierobjekts erscheint: Immer textuell Immer tabellarisch Letzte Einstellung (pro Objekt ) speichern Letzte Einstellung (global) speichern " }, 
{ "title" : "Dialog: Optionen: Download Gerätebeschreibungen ", 
"url" : "_cds_dlg_options_dev_descr_download.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Download Gerätebeschreibungen ", 
"snippet" : "Download Gerätebeschreibungen Symbol: Funktion : Der Dialog dient der Konfiguration von Adressen von Download-Servern für Gerätebeschreibungen. Aufruf : Befehl Tools → Optionen , Kategorie Download Gerätebeschreibungen Download-Server Liste mit Download-Servern, die Gerätebeschreibungen enthalten St...", 
"body" : "Download Gerätebeschreibungen Symbol: Funktion : Der Dialog dient der Konfiguration von Adressen von Download-Servern für Gerätebeschreibungen. Aufruf : Befehl Tools → Optionen , Kategorie Download Gerätebeschreibungen Download-Server Liste mit Download-Servern, die Gerätebeschreibungen enthalten Standardmäßig ist \"https:\/\/store.codesys.com\/CODESYSDevs\" als Download-Server eingetragen. Wenn Sie im Dialog Geräte-Repository die Schaltfläche Download fehlender Gerätebeschreibungen auswählen, verwendet CODESYS die hier eingetragenen Server und verwendet die eingestellten Zugangsdaten für den Proxy-Server. Doppelklick auf (Geben Sie hier einen neuen Download-Server ein) Ein Eingabefeld öffnet sich, in dem Sie die URL-Adresse eines Servers eingeben können. Entf Löscht den selektierten Download-Server Für weitere Informationen siehe: Geräte verwalten und Proxy-Einstellungen" }, 
{ "title" : "Dialog: Optionen: Geräteeditor ", 
"url" : "_cds_dlg_options_device_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Geräteeditor ", 
"snippet" : "Geräteeditor Symbol: Funktion : Der Dialog enthält Einstellungen zur Darstellung des Geräteeditors. Aufruf : Befehl Tools → Optionen , Kategorie Geräteeditor...", 
"body" : "Geräteeditor Symbol: Funktion : Der Dialog enthält Einstellungen zur Darstellung des Geräteeditors. Aufruf : Befehl Tools → Optionen , Kategorie Geräteeditor " }, 
{ "title" : "Registerkarte: Ansicht ", 
"url" : "_cds_dlg_options_device_editor.html#UUID-e361ad24-5293-3d45-6457-8b1691928017_id_a7d16484a2e9f34c0a8640e0124d84a_id_303e1b31bf1d11e3b5929fc0353aead8", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Geräteeditor \/ Registerkarte: Ansicht ", 
"snippet" : "Generische Konfigurationseditoren anzeigen : Die Registerkarte mit der Liste der Geräteparameter ist in den Geräteeditoren parametrierbarer Geräte verfügbar. Querverweise für IEC-Adressen erzeugen (Bereinigen erforderlich) : Erzeugt die Querverweise für nicht abgebildete E\/As Kommunikationsseite Kla...", 
"body" : "Generische Konfigurationseditoren anzeigen : Die Registerkarte mit der Liste der Geräteparameter ist in den Geräteeditoren parametrierbarer Geräte verfügbar. Querverweise für IEC-Adressen erzeugen (Bereinigen erforderlich) : Erzeugt die Querverweise für nicht abgebildete E\/As Kommunikationsseite Klassischer Modus : Die Registerkarte Kommunikation der Geräteeditoren erscheint als zweigeteiltes Fenster: Linker Teil zeigt die aktuell konfigurierten Gatewaykanäle in einer Baumstruktur, rechter Teil zeigt die zugehörigen Daten und Informationen. Einfacher Modus : Die Registerkarte Kommunikation erscheint so, wie es in dem entsprechenden Kapitel in der Hilfe beschrieben ist. Durch kundenspezifische Erweiterungen können noch zusätzliche Modi zur Verfügung stehen. Implizite Dateien für den Applikationsdownload im Editor einer SPS anzeigen : Die Registerkarte Synchronisierte Dateien ist in den Geräteeditoren verfügbar. Synchronisierte Dateien sind Dateien, die beim Applikationsdownload mit auf die SPS geladen werden. Dies können externe Dateien sein, die der Applikation hinzugefügt wurden, sowie implizite Dateien wie beispielsweise ein Quellcode-Archiv. Registerkarte \"Zugriffsrechte\" anzeigen : Die Registerkarte Zugriffsrechte ist in den Geräteeditoren verfügbar. Hinweis: Diese Einstellung kann je nach Gerät durch die Gerätebeschreibung überschrieben werden! " }, 
{ "title" : "Dialog: Optionen: Hilfe ", 
"url" : "_cds_dlg_options_help.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Hilfe ", 
"snippet" : "Hilfe Symbol: Funktion : Der Dialog legt fest, ob beim Hilfeaufruf die CODESYS -Onlinehilfe oder die CODESYS -Offlinehilfe geöffnet wird. Aufruf : Befehl Tools → Optionen , Kategorie Hilfe Offlinehilfe anstatt der Onlinehilfe verwenden : Beim Aufruf der CODESYS -Hilfe öffnet sich die CODESYS -Offlin...", 
"body" : "Hilfe Symbol: Funktion : Der Dialog legt fest, ob beim Hilfeaufruf die CODESYS -Onlinehilfe oder die CODESYS -Offlinehilfe geöffnet wird. Aufruf : Befehl Tools → Optionen , Kategorie Hilfe Offlinehilfe anstatt der Onlinehilfe verwenden : Beim Aufruf der CODESYS -Hilfe öffnet sich die CODESYS -Offlinehilfe. : Beim Aufruf der CODESYS -Hilfe öffnet sich die CODESYS -Onlinehilfe. " }, 
{ "title" : "Dialog: Optionen: Intelligentes Kodieren ", 
"url" : "_cds_dlg_options_smart_code.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Intelligentes Kodieren ", 
"snippet" : "Intelligentes Kodieren Symbol: Funktion : Der Dialog dient der Konfiguration der Einstellungen, die die Eingabe von Code erleichtern. Aufruf : Menü Tools → Optionen , Kategorie Intelligentes Codieren Unbekannte Variablen automatisch deklarieren (AutoDeclare) : Der Dialog Variable deklarieren öffnet ...", 
"body" : "Intelligentes Kodieren Symbol: Funktion : Der Dialog dient der Konfiguration der Einstellungen, die die Eingabe von Code erleichtern. Aufruf : Menü Tools → Optionen , Kategorie Intelligentes Codieren Unbekannte Variablen automatisch deklarieren (AutoDeclare) : Der Dialog Variable deklarieren öffnet sich, sobald Sie einen noch nicht deklarierten Bezeichner in einem Programmiersprachen-Editor eingegeben und die Eingabezeile verlassen haben. Damit die AutoDeclare-Funktion auch im ST-Editor zur Verfügung steht, muss zusätzlich die Option Für den ST-Editor aktivieren aktiviert sein. Für den ST-Editor aktivieren Voraussetzung: Die Option Unbekannte Variablen automatisch deklarieren (AutoDeclare) ist aktiviert. : Die AutoDeclare-Funktion steht auch im ST-Editor zur Verfügung. : Im ST-Editor steht die AutoDeclare-Funktion nicht zur Verfügung. Alle Variablen einer Instanz in der Eingabehilfe anzeigen : Die Funktion Komponenten auflisten bietet auch die lokalen Variablen einer Funktionsbaustein-Instanz zur Auswahl an. : Die Funktion Komponenten auflisten bietet nur die Eingangsvariablen und Ausgangsvariablen einer Funktionsbaustein-Instanz zur Auswahl an. Symbole von Systembibliotheken in der Eingabehilfe anzeigen Systembibliotheken werden im Bibliotheksverwalter automatisch eingefügt und hellgrau dargestellt. : Symbole wie globale Variablen, Datentypen, Funktionsbausteine, etc werden in der Eingabehilfe angeboten. : Die Symbole der Systembibliotheken sind in der Eingabehilfe nicht verfügbar. Komponenten auflisten, nachdem ein Punkt (.) eingegeben wurde : Aktiviert die Funktion Komponenten auflisten Das bedeutet: Wenn Sie an einer Stelle, an der CODESYS einen Bezeichner erwartet, einen Punkt . eingeben, erscheint eine Auswahlliste mit Eingabemöglichkeiten. Komponenten sofort nach Eingabe eines Zeichens auflisten Voraussetzung: Option Komponenten auflisten, nachdem ein Punkt (.) eingegeben wurde ist aktiviert. : Nach Eingabe einer beliebigen Zeichenfolge erscheint eine Auswahlliste der verfügbaren Bezeichner und Operatoren. Mit Namensraum einfügen : Vor dem Kennzeichner fügt CODESYS automatisch den Namensraum mit ein. Schlüsselworte automatisch in Großschreibung umwandeln (Autoformat) : CODESYS schreibt automatisch alle Schlüsselwörter in Großbuchstaben. Querverweise automatisch bei Selektionsänderung aktualisieren : Die Querverweisliste zeigt automatisch die Referenzen der Variablen\/POUs\/DUTs an, die Sie gerade selektieren oder in der Cursor steht. Fehler im Editor unterstreichen : Fehlerhafter oder unbekannter Programmcode wird unterstrichen. Mit dieser Option wird das Precompile-Feature aktiviert bzw. deaktiviert. Es ist zu beachten, dass in der Vorkompilierungsphase nicht alle Fehler erkannt werden, da in dieser Phase kein Code erzeugt wird.  Fehler die nicht erkannt werden sind insbesondere Fehler beim Allozieren der Daten, also wenn beispielsweise der verfügbare Speicher für die Daten ausgeht. Außerdem können in der Vorkompilierungsphase auch Fehler auftreten, die bei der Erzeugung des Codes nicht relevant sind. Ein Beispiel für Fehler die gemeldet werden, aber beim Code erzeugen nicht relevant sind: Probleme, die in Bausteinen gemeldet werden, die nirgends verwendet werden. Wenn es keine Instanz vom Typ eines Funktionsbausteins gibt, dann interessiert sich der Compiler für diese Funktionsbaustein nicht, im Editor werden aber trotzdem Fehler unterstrichen. Symbole hervorheben : Alle Verwendungsstellen eines Symbols, auf dem der Cursor steht, werden innerhalb des Editors farblich markiert. So werden Querverweise innerhalb des Editors schnell erkannt. Maximaler Parallelitätsgrad Auswahlliste für die Anzahl der parallelen Threads, die für die Precompile-Verarbeitung verwendet werden dürfen CODESYS ermittelt die angezeigte Anzahl Threads aus der Anzahl der CPU-Kerne des Prozessors. Diese voreingestellte Anzahl sollte nur in Ausnahmefällen verändert werden. " }, 
{ "title" : "Dialog: Optionen: Internationale Einstellungen ", 
"url" : "_cds_dlg_options_int_set.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Internationale Einstellungen ", 
"snippet" : "Internationale Einstellungen Symbol: Funktion : Der Dialog dient der Konfiguration der Sprache in der Benutzeroberfläche und in der Hilfe. Aufruf Befehl Tools → Optionen , Kategorie Internationale Einstellungen...", 
"body" : "Internationale Einstellungen Symbol: Funktion : Der Dialog dient der Konfiguration der Sprache in der Benutzeroberfläche und in der Hilfe. Aufruf Befehl Tools → Optionen , Kategorie Internationale Einstellungen " }, 
{ "title" : "Dialog: Optionen: Laden und speichern ", 
"url" : "_cds_dlg_options_load_save.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Laden und speichern ", 
"snippet" : "Laden und speichern Symbol: Funktion : Der Dialog enthält Einstellungen für das Verhalten von CODESYS beim Laden und Speichern eines Projekts. Aufruf : Befehl Tools → Optionen , Kategorie Laden und Speichern Sicherungskopie erzeugen : CODESYS speichert bei jedem Speichern das Projekt zusätzlich zur ...", 
"body" : "Laden und speichern Symbol: Funktion : Der Dialog enthält Einstellungen für das Verhalten von CODESYS beim Laden und Speichern eines Projekts. Aufruf : Befehl Tools → Optionen , Kategorie Laden und Speichern Sicherungskopie erzeugen : CODESYS speichert bei jedem Speichern das Projekt zusätzlich zur Datei <Projektname>.project auch als Datei <Projektname>.backup . Sie können die Backup-Datei umbenennen und im Programmiersystem öffnen. Automatisch alle … Minuten speichern : CODESYS speichert das Projekt automatisch im angegebenen Zeitintervall in eine Datei <Projektname>.autosave , die Sie nach einem nicht-regulären Schließen des Programmiersystems wieder laden können. Bei regulärem Schließen oder Speichern des Projekts löscht CODESYS die .autosave -Datei. Bei nicht-regulärem Abbruch behält CODESYS die .autosave -Datei. Wenn Sie ein Projekt öffnen, für das es eine zugehörige .autosave -Datei gibt, öffnet sich der Dialog Auto Save Backup . In dem Dialog wählen Sie aus, ob sich .autosave -Datei oder die zuletzt vom Benutzer gespeicherte Version des Projekts öffnet. Vor dem Übersetzen speichern CODESYS speichert das Projekt automatisch vor jedem Übersetzungslauf. Projektwiederherstellungsinformation erzeugen Voraussetzung: In den Projekteinstellungen in der Kategorie Sicherheit ist die Option Kein Schutz oder die Option Integritätsprüfung aktiviert. Dies bedeutet: Das Projekt ist nicht vor unautorisiertem Zugriff und Datenmanipulation geschützt und beim Laden des Projekts findet keine Integritätsprüfung statt. : Wenn ein Projekt während der Bearbeitung abstürzt, erscheint beim nächsten Öffnen des Projekts eine Abfrage, ob Sie die nicht gespeicherten Daten wiederherstellen und eine neue Projektdatei erstellen möchten. Wenn Sie auf Ja klicken, erscheint ein weiterer Dialog. In diesem Dialog können Sie auswählen, ob Sie das wiederhergestellte Projekt oder ob Sie den Projektvergleich öffnen möchten. In diesem Projektvergleich werden die Unterschiede zwischen dem zuletzt gespeicherten Projekt und dem wiederhergestellten Projekt angezeigt. HINWEIS: Die Projektwiederherstellung zeichnet jede Änderung auf der Festplatte auf, wenn die Änderung durchgeführt wird. Wenn während dieses Vorgangs auf der Festplatte ein Strom- oder Festplattenfehler auftritt, geht die letzte Änderung möglicherweise verloren. Erweiterte Einstellungen Der Dialog Erweiterte Einstellungen öffnet sich. Beim Starten Auswahlliste für den Startbildschirm von CODESYS : Startseite anzeigen : Die Startseite von CODESYS wird angezeigt. Das zuletzt verwendete Projekt öffnen Den Dialog „Projekt öffnen“ anzeigen Den Dialog „Neues Projekt“ anzeigen Eine leere Umgebung anzeigen News Seite URL, die mit dem Befehl Hilfe → CODESYS Homepage geöffnet wird Standardmäßig ist hier http:\/\/www.codesys.com\/startpage eingetragen. Dialog Erweiterte Einstellungen Projektkomprimierung Stufe Voraussetzung: In den Projekteinstellungen in der Kategorie Sicherheit ist die Option Kein Schutz aktiviert. Dies bedeutet: Das Projekt ist nicht vor unautorisiertem Zugriff und Datenmanipulation geschützt und beim Laden des Projekts findet keine Integritätsprüfung statt. Auswahlliste für die Komprimierungsstufe, die beim Speichern des Projekts angewendet wird: Geringste Komprimierung - höchste Geschwindigkeit (empfohlen) Mittlere Komprimierung - mittlere Geschwindigkeit Höchste Komprimierung - kleinste Geschwindigkeit Ladeverhalten Das Laden von Bibliotheken und Übersetzungsinformation erfolgt im Hintergrund, während Sie das Projekt bereits bearbeiten. Für weitere Informationen siehe: Projekt schützen und speichern" }, 
{ "title" : "Dialog: Optionen: Monitoring ", 
"url" : "_cds_dlg_options_monitoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Monitoring ", 
"snippet" : "Monitoring Symbol: Funktion : Der Dialog enthält Einstellungen zur Darstellung von Variablenwerten im Monitoring. Aufruf : Befehl Tools → Optionen , Kategorie Monitoring Darstellung von Integervariablen Binär Der Wert der Variablen wird im Onlinebetrieb im entsprechenden Format dargestellt. Diese Op...", 
"body" : "Monitoring Symbol: Funktion : Der Dialog enthält Einstellungen zur Darstellung von Variablenwerten im Monitoring. Aufruf : Befehl Tools → Optionen , Kategorie Monitoring Darstellung von Integervariablen Binär Der Wert der Variablen wird im Onlinebetrieb im entsprechenden Format dargestellt. Diese Option entspricht der Einstellung des Befehls Debug → Darstellung . Dezimal Hexadezimal Gleitpunktvariablen Anzahl der angezeigten Stellen Nachkommastellen, die im Onlinebetrieb bei der Darstellung von REAL-Werten angezeigt werden Hinweis: Die Einstellungen wirken auf die Überwachungsliste, das Monitoring des Deklarationseditors und den Traceeditor. Die Konfiguration für das Inline-Monitoring des Editors wird in den Optionen des Texteditors eingestellt. Für weitere Informationen siehe: Registerkarte Monitoring " }, 
{ "title" : "Dialog: Optionen - Online ", 
"url" : "_cds_dlg_options_online.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen - Online ", 
"snippet" : "Online Symbol: Funktion : In diesem Dialog kann der Verbindungsabbruch zur Steuerung erzwungen werden, und die Zeit der Inaktivität, nach der die Verbindung zur Steuerung abgebrochen wird, festgelegt werden. Aufruf : Verbindungsabbruch zum Gerät nach Zeit der Inaktivität erzwingen : Die Verbindung z...", 
"body" : "Online Symbol: Funktion : In diesem Dialog kann der Verbindungsabbruch zur Steuerung erzwungen werden, und die Zeit der Inaktivität, nach der die Verbindung zur Steuerung abgebrochen wird, festgelegt werden. Aufruf : Verbindungsabbruch zum Gerät nach Zeit der Inaktivität erzwingen : Die Verbindung zur Steuerung wird nach der in diesem Dialog angegebenen Zeit (in Sekunden) abgebrochen. <Anzahl> Sekunden Standardwert: 1800 Sekunden Wertebereich: [10, 10800] Die hier eingestellte Zeit wird gespeichert, das heißt, dass dieser Wert nach dem Schließen und erneuten Öffnen von CODESYS weiterhin eingestellt ist. Für weitere Informationen siehe: Option --ForceDisconnectAfterInactivity" }, 
{ "title" : "Dialog: Optionen: PLCopenXML ", 
"url" : "_cds_dlg_options_plcopenxml.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: PLCopenXML ", 
"snippet" : "PLCopenXML Symbol: Funktion : Der Dialog enthält Einstellungen für das Verhalten von CODESYS beim PLCopenXML- Export oder - Import . Aufruf : Befehl Tools → Optionen , Kategorie PLCopenXML PLCopenXML-Exporteinstellungen Deklarationen zusätzlich als Klartext exportieren Standardmäßig splittet CODESYS...", 
"body" : "PLCopenXML Symbol: Funktion : Der Dialog enthält Einstellungen für das Verhalten von CODESYS beim PLCopenXML- Export oder - Import . Aufruf : Befehl Tools → Optionen , Kategorie PLCopenXML PLCopenXML-Exporteinstellungen Deklarationen zusätzlich als Klartext exportieren Standardmäßig splittet CODESYS die Deklarationsteile gemäß dem PLCopenXML-Schema in einzelne Variablen auf und verliert somit die Formatierung und manche Kommentarinformationen. : Formatierung und Kommentare bleiben erhalten. CODESYS schreibt den Klartext des exportierten Deklarationsteils zusätzlich in die PLCopenXML-Datei und erweitert somit das PLCopenXML-Schema. Ordnerstruktur exportieren : CODESYS exportiert auch die Ordner, wenn sie eines der ausgewählten Objekte enthalten. Das ist eine CODESYS -spezifische Erweiterung zum PLCopenXML-Schema. PLCopenXML-Importeinstellungen Ordnerstruktur importieren : Wenn die Importdatei-Informationen über die Ordnerstruktur der Objekte enthält, importiert CODESYS diese Struktur mit. : CODESYS importiert Objekte ohne Struktur. Für weitere Informationen siehe: Projekt exportieren und importieren" }, 
{ "title" : "Dialog: Optionen: Proxy-Einstellungen ", 
"url" : "_cds_dlg_options_proxy_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Proxy-Einstellungen ", 
"snippet" : "Proxy-Einstellungen Symbol: Funktion : Der Dialog dient dem Speichern von Authentifizierungsdaten für den Proxy-Server, der aktuell für Zugriffe von CODESYS auf das Internet verwendet wird. Aufruf : Befehl Tools → Optionen , Kategorie Proxy-Einstellungen Voraussetzung : Internetzugang im Netzwerk er...", 
"body" : "Proxy-Einstellungen Symbol: Funktion : Der Dialog dient dem Speichern von Authentifizierungsdaten für den Proxy-Server, der aktuell für Zugriffe von CODESYS auf das Internet verwendet wird. Aufruf : Befehl Tools → Optionen , Kategorie Proxy-Einstellungen Voraussetzung : Internetzugang im Netzwerk erfolgt über einen Proxy-Server. Proxy-Zugangsdaten eingeben Ein Doppelklick öffnet Eingabeaufforderung für Benutzernamen und Passwort für den Proxy-Server. CODESYS verwendet die Zugangsdaten beim Verbindungsaufbau zu den Download-Server für Bibliotheken und Gerätebeschreibung, beim Verbindungsaufbau zum CODESYS und beim Befehl Ansicht → Startseite bei der Anzeige der Startseite. Voraussetzung: Die Schaltfläche ist verfügbar, wenn der Internetzugang Ihres Arbeitsplatzcomputers oder des Netzwerk über einen Proxy-Server erfolgt. " }, 
{ "title" : "Dialog: Optionen: Refactoring ", 
"url" : "_cds_dlg_options_refactoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Refactoring ", 
"snippet" : "Refactoring Symbol: Funktion : Der Dialog dient zur Festlegung der Operationen im Projekt, für die automatisch Refactoring vorgeschlagen wird. Die Refactoring-Funktionalität unterstützt Sie bei ihren Verbesserungswünschen. Aufruf : Befehl Tools → Optionen , Kategorie: Refactoring...", 
"body" : "Refactoring Symbol: Funktion : Der Dialog dient zur Festlegung der Operationen im Projekt, für die automatisch Refactoring vorgeschlagen wird. Die Refactoring-Funktionalität unterstützt Sie bei ihren Verbesserungswünschen. Aufruf : Befehl Tools → Optionen , Kategorie: Refactoring " }, 
{ "title" : "Refactoring für folgende Operationen vorschlagen ", 
"url" : "_cds_dlg_options_refactoring.html#UUID-1bedf43c-55f6-693f-ef62-59657cb1e67e_id_d71dbe1a61c0a8640e00abed65_id_0152096f7d12ab0bc0a864637db0450e", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Refactoring \/ Refactoring für folgende Operationen vorschlagen ", 
"snippet" : "Autodeklaration Wenn Sie in einer Deklaration den Namen einer Variablen ändern, indem Sie die Autodeklaration ( Umschalt + F2 ) aufrufen, erscheint die aktivierte Option Änderungen mit Hilfe von Refactoring anwenden . Dann öffnet sich der Dialog Refactoring und Sie können projektweit die Variable än...", 
"body" : "Autodeklaration Wenn Sie in einer Deklaration den Namen einer Variablen ändern, indem Sie die Autodeklaration ( Umschalt + F2 ) aufrufen, erscheint die aktivierte Option Änderungen mit Hilfe von Refactoring anwenden . Dann öffnet sich der Dialog Refactoring und Sie können projektweit die Variable ändern. Beim Hinzufügen oder Entfernen von Variablen, oder für das Ändern des Gültigkeitsbereichs : Sie löschen in der Autodeklaration (Dialog Variable deklarieren ) den Namen und beenden den Dialog mit OK . Daraufhin öffnet sich der Dialog Refactoring , um projektweit die Variable zu entfernen. Beim Umbenennen von Variablen : Sie benennen in der Autodeklaration (Dialog Variable deklarieren ) den Namen um und beenden den Dialog mit OK . Daraufhin öffnet sich der Dialog Refactoring , um projektweit die Variable umzubenennen. Siehe: Kapitel „Refactoring“, „Variablendeklaration ändern und Refactoring automatisch anwenden“ Editor für Einheitenumrechnung Beim Umbenennen von Einheitenkonvertierungen : Wenn Sie im Editor für Einheitenumrechnung den Namen einer Konvertierung ändern, erscheint die Eingabeaufforderung, ob CODESYS „Automatisches Refactoring“ für das Umbenennen durchführen soll. Mapping-Editor Beim Umbenennen von Variablen : Wenn Sie im Geräteeditor in der Registerkarte E\/A-Abbild einen Variablennamen ändern, erscheint die Eingabeaufforderung, ob CODESYS „Automatisches Refactoring“ für das Umbenennen durchführen soll. Navigator Beim Umbenennen von Objekten : Wenn Sie im Gerätebaum oder in der POUs-Ansicht den Namen eines Objekts ändern, erscheint die Eingabeaufforderung, ob CODESYS „Automatisches Refactoring“ für das Umbenennen durchführen soll. Tabellarischer Deklarationseditor Beim Umbenennen von Variablen : Wenn Sie im tabellarischen Deklarationseditor den Namen einer Variablen ändern, erscheint die Eingabeaufforderung, ob CODESYS „Automatisches Refactoring“ für das Umbenennen durchführen soll. UML Klassendiagramm Optionen für die Unterstützung von Refactoring, also projektweiter IEC-Codeanpassung, bei im Klassendiagramm-Editor vorgenommenen Änderungen Beim Hinzufügen oder Entfernen von Variablen : Wenn Sie im Klassendiagramm Variablen in den Sektionen VAR_INPUT , VAR_OUTPUT und VAR_INOUT hinzufügen oder entfernen, wird Refactoring unterstützt. Beim Umbenennen eines Bausteins : Wenn Sie im Klassendiagramm einen Bausteinnamen ändern, wird Refactoring unterstützt. Beim Umbenennen von Variablen oder Eigenschaften : Wenn Sie im Klassendiagramm eine Variable oder eine Eigenschaft umbenennen, wird Refactoring unterstützt. Hinweis: Wenn die Option Refactoring-Vorschau überspringen in den UML-Optionen aktiviert ist, wird das Refactoring je nach Fall möglicherweise ohne vorheriges Anzeigen im Dialog Refactoring an allen betroffenen Stellen im Projekt durchgeführt. Siehe hierzu: die Hilfeseite „Dialog ‚Optionen‘ - ‚UML‘“ in der Hilfe zu CODESYS UML Für weitere Informationen siehe: Refactoring" }, 
{ "title" : "Dialog: Optionen: Sequence-Editor ", 
"url" : "_cds_dlg_options_seq_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Sequence-Editor ", 
"snippet" : "Sequence-Editor Symbol: Funktion : Der Dialog enthält die Einstellungen für den Sequence-Editor . Aufruf : Befehl Tools → Optionen , Kategorie Sequence-Editor Allgemein Auswahl der Elemente, die CODESYS im Ablaufschritt des Ablaufeditors anzeigt Darstellung Definiert die Darstellung der Ablaufschrit...", 
"body" : "Sequence-Editor Symbol: Funktion : Der Dialog enthält die Einstellungen für den Sequence-Editor . Aufruf : Befehl Tools → Optionen , Kategorie Sequence-Editor Allgemein Auswahl der Elemente, die CODESYS im Ablaufschritt des Ablaufeditors anzeigt Darstellung Definiert die Darstellung der Ablaufschritte und Verbindungslinien zwischen den Ablaufschritten, sowie die Schriftart für Texte , Parameter , Referenzen und E\/A-Kanäle A Verbindung Auswahl der Farbe der Verbindungslinie nach einem Verzweigungsschritt B Verbindung Auswahl der Farbe der Verbindungslinie nach einem Verzweigungsschritt (Alternativzweig) " }, 
{ "title" : "Dialog: Optionen: Texteditor ", 
"url" : "_cds_dlg_options_text_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Texteditor ", 
"snippet" : "Texteditor Symbol: Funktion : Der Dialog enthält Einstellungen für die Darstellung und das Arbeiten in einem Texteditor. Aufruf : Befehl Tools → Optionen , Kategorie Texteditor...", 
"body" : "Texteditor Symbol: Funktion : Der Dialog enthält Einstellungen für die Darstellung und das Arbeiten in einem Texteditor. Aufruf : Befehl Tools → Optionen , Kategorie Texteditor " }, 
{ "title" : "Registerkarte: Theme ", 
"url" : "_cds_dlg_options_text_editor.html#UUID-aee4222a-ae45-5987-36f9-2fa9772b4160_id_e24f8a1565c0a8640e005b0b28_id_b87761b04ff2cdecc0a8640e00bac4c1", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Texteditor \/ Registerkarte: Theme ", 
"snippet" : "In dieser Registerkarte stellen Sie das gewünschte „Theme“ für die Oberflächengestaltung des ST-Editors ein. Theme Farbschema für den Texteditor Das gewählte „Theme“ wird im Fenster Vorschau dargestellt. Die verfügbaren Farbschemata sind im Installationsverzeichnis im Ordner Themes abgelegt....", 
"body" : "In dieser Registerkarte stellen Sie das gewünschte „Theme“ für die Oberflächengestaltung des ST-Editors ein. Theme Farbschema für den Texteditor Das gewählte „Theme“ wird im Fenster Vorschau dargestellt. Die verfügbaren Farbschemata sind im Installationsverzeichnis im Ordner Themes abgelegt. " }, 
{ "title" : "Registerkarte: Editieren ", 
"url" : "_cds_dlg_options_text_editor.html#UUID-aee4222a-ae45-5987-36f9-2fa9772b4160_id_e24f8a1565c0a8640e005b0b28_id_eafa9d684ff2cdefc0a8640e00d4f909", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Texteditor \/ Registerkarte: Editieren ", 
"snippet" : "Anzahl von Rückgängig-Schritten Maximale Anzahl der Bearbeitungsschritte, auf die Sie den Befehl Bearbeiten → Rückgäng anwenden können Gliederung Definiert die Strukturierung des Codes durch Einrückungen Wenn Sie eine Einrückung auswählen, können Sie den Einrückungsabschnitt mit Hilfe eines Plus- un...", 
"body" : "Anzahl von Rückgängig-Schritten Maximale Anzahl der Bearbeitungsschritte, auf die Sie den Befehl Bearbeiten → Rückgäng anwenden können Gliederung Definiert die Strukturierung des Codes durch Einrückungen Wenn Sie eine Einrückung auswählen, können Sie den Einrückungsabschnitt mit Hilfe eines Plus- und Minuszeichens vor der ersten Zeile des jeweiligen Abschnitts auf- oder zuklappen. Einrückung : CODESYS fasst alle Zeilen, die gegenüber der vorausgehenden Zeile eingerückt sind, in einer Einrückungseinheit zusammen. Explizit : Sie kennzeichnen explizit den Code-Abschnitt mit Kommentaren, der in einer Einrückungseinheit zusammengefasst werden soll: Vor dem Abschnitt muss ein Kommentar stehen, der 3 öffnende geschweifte Klammern „{{{“ enthält, nach dem Abschnitt muss ein Kommentar folgen, der 3 schließende geschweifte Klammern „}}}“ enthält. Die Kommentare können zusätzlichen Text enthalten. Beispiel: Wortumbruch Weich : Der Zeilenumbruch erfolgt am Rand des Editorfensters, wenn bei Umbruchsstelle 0 eingetragen ist. Hart : Der Zeilenumbruch erfolgt nach der bei Umbruchsstelle angegebenen Anzahl von Zeichen. Tabulatorgröße Anzahl der Zeichen Tabs beibehalten : Den Leerraum, den Sie mit der Tabulator -Taste eingefügt haben, löst CODESYS hinterher nicht in einzelne Leerzeichen auf. Einzugsgröße Wenn Sie die Option Automatisch Einrücken Intelligent oder Intelligent mit Code-Komplettierung aktiviert haben, fügt CODESYS die Anzahl Leerzeichen am Beginn der Zeile ein. Automatisch einrücken Nicht automatisch einrücken Block : Eine neue Zeile übernimmt automatisch die Einrückung der Vorgängerzeile. Intelligent : Zeilen, die einer Zeile folgen, die ein Schlüsselwort enthält (zum Beispiel VAR ), rücken automatisch um die angegebene Einzugsgröße ein. Intelligent mit Code-Komplettierung : Einrückung wie bei der Option Intelligent , zusätzlich fügt CODESYS das abschließende Schlüsselwort ein (zum Beispiel END_VAR ). " }, 
{ "title" : "Registerkarte: Textbereich ", 
"url" : "_cds_dlg_options_text_editor.html#UUID-aee4222a-ae45-5987-36f9-2fa9772b4160_id_e24f8a1565c0a8640e005b0b28_id_69e944a24ff2cdf1c0a8640e01db5766", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Texteditor \/ Registerkarte: Textbereich ", 
"snippet" : "Aktuelle Zeile hervorheben : Die Zeile, in der der Cursor steht, wird farblich hinterlegt. Zusammengehörige Klammern : Wenn der Cursor vor oder nach einer Klammer innerhalb einer Code-Zeile positioniert ist, wird die zugehörige schließende oder öffnende Klammer durch einen Rahmen markiert. Zeilenmar...", 
"body" : "Aktuelle Zeile hervorheben : Die Zeile, in der der Cursor steht, wird farblich hinterlegt. Zusammengehörige Klammern : Wenn der Cursor vor oder nach einer Klammer innerhalb einer Code-Zeile positioniert ist, wird die zugehörige schließende oder öffnende Klammer durch einen Rahmen markiert. Zeilenmarkierungen : Das Ende jeder Editorzeile wird durch einen kleinen Querstrich hinter dem letzten Zeichen (auch Leerzeichen) der Zeile markiert. Zeilenumbruchstelle : Wenn ein weicher oder harter Zeilenumbruch aktiviert ist, wird die definierte Zeilenumbruchstelle durch eine senkrechte Linie angezeigt. Schriftart Ein Klick auf das Feld öffnet den Standarddialog zum Konfigurieren der Schriftart. " }, 
{ "title" : "Registerkarte: Randbereich ", 
"url" : "_cds_dlg_options_text_editor.html#UUID-aee4222a-ae45-5987-36f9-2fa9772b4160_id_e24f8a1565c0a8640e005b0b28_id_1e6959244ff2cdf1c0a8640e01e6af9e", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Texteditor \/ Registerkarte: Randbereich ", 
"snippet" : "Einstellungen für linken Randbereich des Texteditor-Fensters, der durch eine senkrechte Linie vom Eingabebereich abgetrennt ist Zeilen nummerieren : Deklarations- und Implementierungsteil des Editors erhalten links eine Zeilennummerierung, jeweils mit 1 beginnend. Aktuelle Zeile hervorheben : Die Ze...", 
"body" : "Einstellungen für linken Randbereich des Texteditor-Fensters, der durch eine senkrechte Linie vom Eingabebereich abgetrennt ist Zeilen nummerieren : Deklarations- und Implementierungsteil des Editors erhalten links eine Zeilennummerierung, jeweils mit 1 beginnend. Aktuelle Zeile hervorheben : Die Zeilennummer der Zeile, in der der Cursor steht, wird farblich hervorgehoben. Klammerbereich anzeigen : Eine Klammerung umfasst die Zeilen zwischen den Schlüsselwörtern, die ein Konstrukt öffnen und abschließen, zum Beispiel IF und END_IF . Wenn die Option aktiviert ist und der Cursor vor, nach oder in einem der Schlüsselwörter eines Konstrukts steht, wird der Klammerungsbereich durch eine eckige Klammer im Randbereich angezeigt.. Mausaktionen Eine der folgenden Aktionen können Sie jeder der angegebenen Mausaktionen oder Maus-Tastenkombinationen zuordnen. CODESYS führt die ausgewählte Aktion aus, wenn Sie die Mausaktion auf das Plus- oder Minuszeichen vor der Kopfzeile eines geklammerten Bereichs ausführen: Keine : Die Mausaktion löst keine Aktion aus. Gliederung markieren : CODESYS wählt alle Zeilen des geklammerten Bereichs aus. Gliederung umschalten : CODESYS öffnet oder schließt den geklammerten Bereich, oder wenn geschachtelte Klammerungen vorliegen, die erste Ebene des geklammerten Bereichs. Gliederung vollst. umschalten : CODESYS öffnet oder schließt alle Ebenen eines geschachtelt geklammerten Bereichs. " }, 
{ "title" : "Registerkarte: Monitoring ", 
"url" : "_cds_dlg_options_text_editor.html#UUID-aee4222a-ae45-5987-36f9-2fa9772b4160_id_e24f8a1565c0a8640e005b0b28_id_0ca52533c15411e3a290e57e01b702a2", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Optionen \/ Dialog: Optionen: Texteditor \/ Registerkarte: Monitoring ", 
"snippet" : "Einstellungen für die Darstellung der Monitoring-Felder Inline-Monitoring aktivieren : Anzeige der Monitoring-Felder hinter den Variablen im Onlinebetrieb Anzahl der angezeigten Ziffern Anzahl der angezeigten Ziffern für Gleitkommazahlen im Monitoring-Feld Beispiel: Wert: 12.345, Anzahl dargestellte...", 
"body" : "Einstellungen für die Darstellung der Monitoring-Felder Inline-Monitoring aktivieren : Anzeige der Monitoring-Felder hinter den Variablen im Onlinebetrieb Anzahl der angezeigten Ziffern Anzahl der angezeigten Ziffern für Gleitkommazahlen im Monitoring-Feld Beispiel: Wert: 12.345, Anzahl dargestellter Ziffern: 3, Anzeige 12.3 Stringlänge Maximale Länge von String-Variablenwerten im Monitoring-Feld " }, 
{ "title" : "Dialog: Anpassen ", 
"url" : "_cds_f_dlg_customize.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Anpassen ", 
"snippet" : "Anpassen Der Dialog enthält Registerkarten für die Konfiguration der Benutzeroberfläche. Sie können die CODESYS -Standardeinstellungen jederzeit über die Schaltfläche Zurücksetzen wieder herstellen....", 
"body" : "Anpassen Der Dialog enthält Registerkarten für die Konfiguration der Benutzeroberfläche. Sie können die CODESYS -Standardeinstellungen jederzeit über die Schaltfläche Zurücksetzen wieder herstellen. " }, 
{ "title" : "Dialog: Anpassen: Menü ", 
"url" : "_cds_dlg_customize_menu.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Anpassen \/ Dialog: Anpassen: Menü ", 
"snippet" : "Menü Funktion : Mit dem Dialog definieren Sie die Struktur und den Inhalt der Menüs für die Benutzeroberfläche. Aufruf : Befehl Tools → Anpassen , Registerkarte Menü Wenn Sie den Dialog mit OK beenden, werden die Änderungen in der Menüleiste der CODESYS -Benutzeroberfläche sichtbar. Menü Darstellung...", 
"body" : "Menü Funktion : Mit dem Dialog definieren Sie die Struktur und den Inhalt der Menüs für die Benutzeroberfläche. Aufruf : Befehl Tools → Anpassen , Registerkarte Menü Wenn Sie den Dialog mit OK beenden, werden die Änderungen in der Menüleiste der CODESYS -Benutzeroberfläche sichtbar. Menü Darstellung der aktuell definierten Menüs, Untermenüs und der enthaltenen Befehle CODESYS kennzeichnet einen Menü- oder Untermenü-Titel mit dem Symbol . Die Anordnung von oben nach unten entspricht der später im CODESYS -Menü dargestellten Anordnung. Befehl hinzufügen Auswählbar, wenn Sie einen Befehl selektiert haben Fügt oberhalb des selektierten Befehls einen Befehl hinzu Öffnet den Dialog Befehl hinzufügen Der Dialog Befehl hinzufügen dient zur Auswahl eines oder mehrerer Befehle. Linker Teil: Auflistung der Kategorien Rechter Teil: Auflistung der Befehle der selektierten Kategorie Trennstrich hinzufügen Fügt einen Trennstrich oberhalb des selektierten Befehls ein Popup-Menü hinzufügen Fügt oberhalb des selektierten Menüs, Untermenüs oder Befehls ein Popup-Menü hinzu Öffnet den Dialog Popup-Menü hinzufügen Popup-Menü editieren Öffnet den Dialog Popup-Menü editieren Zurücksetzen Setzt das gesamte Menü auf die Standardeinstellungen zurück Laden Lädt die Einstellungen aus einer abgespeicherten Datei (<Dateiname>.opt.menu) Popup-Menü hinzufügen CODESYS zeigt ein neues Menü in der Menüleiste nur an, wenn das Menü mindestens einen Befehl besitzt. Standardtext Wählen Sie diese Option, wenn keine Lokalisierung verfügbar ist. Lokalisierte Texte Auflistung der Sprachen und lokalisierten Texte Sprache hinzufügen Öffnet eine Auswahlliste für die Sprache CODESYS zeigt die ausgewählte Sprache im Bereich Lokalisierte Texte: an. Die Spalte Text dient zur Eingabe des lokalisierten Texts. Für weitere Informationen siehe: Menüs anpassen" }, 
{ "title" : "Dialog: Anpassen: Befehlicons ", 
"url" : "_cds_dlg_customize_command_icon.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Anpassen \/ Dialog: Anpassen: Befehlicons ", 
"snippet" : "Befehlicons Funktion : Mit dem Dialog definieren Sie die Icons der Menübefehle. Aufruf : Befehl Tools → Anpassen , Registerkarte Befehl-Icons Befehl-Icons Zuweisen Öffnet einen Dialog, in dem Sie das neue Icon auswählen können ( *.ico ) Entfernen Entfernt das benutzerdefinierte Icon Das Standard-Ico...", 
"body" : "Befehlicons Funktion : Mit dem Dialog definieren Sie die Icons der Menübefehle. Aufruf : Befehl Tools → Anpassen , Registerkarte Befehl-Icons Befehl-Icons Zuweisen Öffnet einen Dialog, in dem Sie das neue Icon auswählen können ( *.ico ) Entfernen Entfernt das benutzerdefinierte Icon Das Standard-Icon wird wieder wirksam. Zurücksetzen Setzt alle Befehl-Icons auf die Standardeinstellungen zurück Laden Lädt die Einstellungen aus einer abgespeicherten Datei ( <file name>.opt.keyb ) Speichern Speichert die aktuellen Einstellungen in eine Datei ( <file name>.opt.keyb ) Für weitere Informationen siehe: Befehls-Icon anpassen" }, 
{ "title" : "Dialog: Anpassen: Symbolleisten ", 
"url" : "_cds_dlg_customize_toolbar.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Anpassen \/ Dialog: Anpassen: Symbolleisten ", 
"snippet" : "Symbolleisten Funktion : Mit dem Dialog erzeugen Sie neue Symbolleisten, oder Sie passen bestehende Symbolleisen an. Aufruf : Befehl Tools → Anpassen , Registerkarte Symbolleisten Wenn Sie den Dialog mit OK beenden, werden die Änderungen in der Menüleiste der CODESYS -Benutzeroberfläche sichtbar. Sy...", 
"body" : "Symbolleisten Funktion : Mit dem Dialog erzeugen Sie neue Symbolleisten, oder Sie passen bestehende Symbolleisen an. Aufruf : Befehl Tools → Anpassen , Registerkarte Symbolleisten Wenn Sie den Dialog mit OK beenden, werden die Änderungen in der Menüleiste der CODESYS -Benutzeroberfläche sichtbar. Symbolleisten Darstellung der aktuell definierten Symbolleisten Darunter listet CODESYS die zugehörigen Befehle in der Reihenfolge auf, die später in der Symbolleiste gilt. Durch einen Doppelklick auf eine Symbolleiste in der Liste wechseln Sie in den Editier-Modus. Symbolleiste hinzufügen Auswählbar, wenn Sie eine Symbolleiste selektiert haben CODESYS fügt oberhalb der selektierten Symbolleiste eine Symbolleiste hinzu und positioniert den Cursor im Namensfeld der neuen Symbolleiste. Befehl hinzufügen Auswählbar, wenn Sie einen Befehl oder einen leeren Befehleintrag unterhalb einer Symbolleiste selektiert haben Fügt oberhalb des selektierten Befehls einen Befehl hinzu Öffnet den Dialog Befehl hinzufügen Mit dem Dialog Befehl hinzufügen wählen Sie einen oder mehrere Befehle aus. Linker Teil: Auflistung der Kategorien Rechter Teil: Auflistung der Befehle der selektierten Kategorie Trennstrich hinzufügen Fügt einen Trennstrich oberhalb des selektierten Befehls ein Ausblenden Blendet die selektierte Symbolleiste aus der CODESYS -Benutzeroberfläche aus Einblenden Blendet die selektierte ausgeblendete Symbolleiste in der CODESYS -Benutzeroberfläche ein Zurücksetzen Setzt die Symbolleisten auf die Standardeinstellungen zurück Laden Lädt die Einstellungen aus einer abgespeicherten Datei (<Dateiname>.opt.tbar) Für weitere Informationen siehe: Symbolleisten anpassen" }, 
{ "title" : "Dialog: Anpassen: Tastatur ", 
"url" : "_cds_dlg_customize_keyboard.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Anpassen \/ Dialog: Anpassen: Tastatur ", 
"snippet" : "Tastatur Funktion : Mit dem Dialog definieren Sie Tastaturkürzel (Tasten oder Tastenkombinationen) für die Befehle. Aufruf : Befehl Tools → Anpassen , Registerkarte Tastatur Registerkarte Tastatur Tastaturkürzel für ausgewählten Befehl Tastaturkürzel für den ausgewählten Befehl Die Auswahlliste kann...", 
"body" : "Tastatur Funktion : Mit dem Dialog definieren Sie Tastaturkürzel (Tasten oder Tastenkombinationen) für die Befehle. Aufruf : Befehl Tools → Anpassen , Registerkarte Tastatur Registerkarte Tastatur Tastaturkürzel für ausgewählten Befehl Tastaturkürzel für den ausgewählten Befehl Die Auswahlliste kann auch mehrere Tastaturkürzel für den Befehl enthalten. Taste für Tastaturkürzel drücken Eingabefeld (Aufzeichnung) für das Tastaturkürzel für den selektierten Befehl Erlaubt sind Kombinationen aus Umschalt , Strg , Alt und anderen Tasten. Das aufgezeichnete Tastaturkürzel weisen Sie über die Schaltfläche Zuweisung dem selektierten Befehl zu. Tastaturkürzel momentan belegt durch Befehl, der dem aktuell festgelegten Tastaturkürzel zugewiesen ist Zurücksetzen Setzt alle Tastaturkürzel auf die Standardeinstellungen zurück Laden Lädt die Einstellungen aus der abgespeicherten Datei <Dateiname>.opt.keyb Für weitere Informationen siehe: Tastaturkürzel anpassen, Tastaturkürzel, Windows™ Tastaturkürzel" }, 
{ "title" : "Dialog: Zertifikatsauswahl ", 
"url" : "_cds_dlg_certificate_selection.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Zertifikatsauswahl ", 
"snippet" : "Zertifikatsauswahl Symbol: Funktion : Der Dialog dient der Auswahl der Zertifikate für Verschlüsselung, Entschlüsselung und digitale Signatur. Aufruf : Ansicht Security-Screen , Registerkarte Benutzer Befehl Ansicht → Eigenschaften , Registerkarte Security , wenn im Gerätebaum die Application selekt...", 
"body" : "Zertifikatsauswahl Symbol: Funktion : Der Dialog dient der Auswahl der Zertifikate für Verschlüsselung, Entschlüsselung und digitale Signatur. Aufruf : Ansicht Security-Screen , Registerkarte Benutzer Befehl Ansicht → Eigenschaften , Registerkarte Security , wenn im Gerätebaum die Application selektiert ist Befehl Projekt → Projekteinstellungen , Kategorie Sicherheit " }, 
{ "title" : "Dialog Zertifikatsauswahl ", 
"url" : "_cds_dlg_certificate_selection.html#UUID-e72f57e4-30c1-3979-3c7c-8789f178b99d_id_fbfcef7f68cc8d6c0a864630f88b355_id_66ae7b16c2e29ee4c0a8646372161059", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Zertifikatsauswahl \/ Dialog Zertifikatsauswahl ", 
"snippet" : "Der Zweck des Zertifikats, das in dem Dialog ausgewählt wird, ist abhängig von der Aufrufstelle: Aufrufstelle: Ansicht Security-Screen , Registerkarte Benutzer Zertifikat für die digitale Signatur Zertifikat für die Entschlüsselung von Projektdateien Zertifikat für verschlüsselte Kommunikation Aufru...", 
"body" : "Der Zweck des Zertifikats, das in dem Dialog ausgewählt wird, ist abhängig von der Aufrufstelle: Aufrufstelle: Ansicht Security-Screen , Registerkarte Benutzer Zertifikat für die digitale Signatur Zertifikat für die Entschlüsselung von Projektdateien Zertifikat für verschlüsselte Kommunikation Aufrufstelle: Ansicht → Eigenschaften der Applikation Zertifikate von Geräten, die den verschlüsselten Download und die Bootapplikation teilen Aufrufstelle: Projekt → Projekteinstellungen , Kategorie Sicherheit Zertifikat für Projektverschlüsselung Auflistung der ausgewählten Zertifikate in tabellarischer Form Für jedes ausgewählte X.509 Zertifikat werden die folgenden Eigenschaften angezeigt: Erzeugt für Erzeugt von Gültig ab Gültig bis Daumenabdruck : SHA1-Fingerabdruck Ein Doppelklick auf einen Eintrag öffnet den Dialog Zertifikat mit den Registerkarten Allgemein , Details und Zertifizierungspfad . In der Registerkarte finden Sie einen Verweis zur Windows-Hilfe, wo Sie weitere Informationen zum Dialog finden. Fügt das selektierte verfügbare Zertifikat zur Auflistung der ausgewählten Zertifikate hinzu Löscht das in der Auflistung selektierte Zertifikat Verfügbare Zertifikate im lokalen Windows Certificate Store Ein Doppelklick auf einen Eintrag öffnet den Dialog Zertifikat mit den Registerkarten Allgemein , Details und Zertifizierungspfad . In der Registerkarte finden Sie einen Verweis zur Windows-Hilfe, wo Sie weitere Informationen zum Dialog finden. Icons der Zertifikate : Zertifikat mit privatem Schlüssel : nicht vertrauenswürdiges Zertifikat Für weitere Informationen siehe: Security-Screen" }, 
{ "title" : "Dialog: Bibliotheksparameter ", 
"url" : "_cds_dlg_library_parameter.html", 
"breadcrumbs" : "CODESYS Essentials \/ Referenz: Benutzeroberfläche \/ Dialoge \/ Dialog: Bibliotheksparameter ", 
"snippet" : "Bibliotheksparameter In diesem Dialog werden die Bibliotheksparameter der Bibliotheken angezeigt, die im Bibliotheksverwalters der Applikation und des POU-Pools vorhanden sind. In dem Dialog können die Werte der Parameter verändert werden. Weiterhin steht ein Export und Import der Parameter zur Verf...", 
"body" : "Bibliotheksparameter In diesem Dialog werden die Bibliotheksparameter der Bibliotheken angezeigt, die im Bibliotheksverwalters der Applikation und des POU-Pools vorhanden sind. In dem Dialog können die Werte der Parameter verändert werden. Weiterhin steht ein Export und Import der Parameter zur Verfügung. Exportieren Öffnet den Dialog Bibliotheksparameter exportieren zur Auswahl der zu exportierenden Parameterlisten. Es wird eine CSV-Datei für jede Parameterliste erzeugt. Importieren Öffnet einen Dialog zur Auswahl der zu importierenden Parameterlisten Reset (Werkzeugleiste) Setzt die Werte aller Parameter auf ihren Standardwert zurück Wert (editierbar) Wert für den Parameter. Der Wert kann editiert werden. Standardwert Standardwert der Parameter, wie in der Bibliothek definiert Reset Durch einen Mausklick auf das Symbol können einzelne Parameter, alle Parameter einer Parameterliste oder alle Parameter aller Parameterlisten auf ihren Standardwert zurückgesetzt werden. " }, 
{ "title" : "Tastaturkürzel ", 
"url" : "_cds_shortcuts.html", 
"breadcrumbs" : "CODESYS Essentials \/ Tastaturkürzel ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Standard-Tastaturkürzel ", 
"url" : "_cds_shortcuts.html#UUID-5d1e0bf4-8c51-7fbb-189a-4bb7f0ecc719", 
"breadcrumbs" : "CODESYS Essentials \/ Tastaturkürzel \/ Standard-Tastaturkürzel ", 
"snippet" : "Bei der Installation des CODESYS Development System s werden die folgenden Tastenkombinationen standardmäßig festgelegt. Sie können die Standard-Tastenkürzel an Ihre persönlichen Bedürfnisse anpassen. Die Standard-Tastenkürzel sind im Menü Tools → Anpassen in der Registerkarte Tastatur verfügbar. Si...", 
"body" : "Bei der Installation des CODESYS Development System s werden die folgenden Tastenkombinationen standardmäßig festgelegt. Sie können die Standard-Tastenkürzel an Ihre persönlichen Bedürfnisse anpassen. Die Standard-Tastenkürzel sind im Menü Tools → Anpassen in der Registerkarte Tastatur verfügbar. Sie können einem dort aufgelisteten Befehle ein Tastaturkürzel zuweisen, es entfernen oder ändern. Für weitere Informationen siehe: Tastaturkürzel anpassen. Icon Befehle Tastaturkürzel Beschreibung Kategorie Ansicht Menü AnsichtGeräte Alt + 0 Öffnet die Ansicht Geräte Ganzer Bildschirm Strg + Umschalt + F12 Der Befehl Ganzer Bildschirm schaltet zwischen Vollbildmodus und Fenstermodus um POUs Alt + 1 Öffnet die Ansicht POUs Module Alt + 2 Öffnet die Ansicht ModuleMeldungen Alt + 3 Mit Meldungen erscheint das Meldungsfenster Kategorie CFC Menü CFC Alles auswählen Strg + Umschalt + A Markiert alles im CFC-Editor Anschlüsse zurücksetzen Strg + U Setzt die Anschlüsse eines Bausteins zurück Ausgang einfügen Strg + A Neuer Ausgang Baustein einfügen Strg + Umschalt + B Neuer Baustein Bausteinelemente aus der Eingabehilfe einfügen Strg + B Öffnet die Eingabehilfe Bausteinelemente mit EN\/ENQ aus der Eingabehilfe einfügen Strg + Umschalt + E Öffnet die Eingabehilfe Eingang einfügen Strg + Q Negieren Strg + N Sprung einfügen Strg + L Umschalten zwischen S\/R\/Ref\/None Strg + M Kategorie Datei Menü DateiBeenden ALT + F4 Beendet CODESYS Development System Neues Projekt Strg + N Projekt öffnen Strg + O Projekt speichern Strg + S Kategorie FUP\/KOP Menü FUP\/KOP AWL-Zeile löschen Strg + Entf Flankenerkennung Strg + E Vor dem selektierten Bausteineingang oder Bausteinausgang Bausteinaufruf einfügen Strg + B Im selektierten Netzwerk am Ende Bausteinaufruf mit EN\/ENQ einfügen Strg + Umschalt + E Leitungsverzweigung einfügen Strg + Umschalt + V An der selektierten Leitung Spule einfügen Strg + A Kontakt einfügen Strg + K Kontakt einfügen (rechts) Strg + D Kontakt parallel einfügen (oberhalb) Strg + P Kontakt parallel einfügen (unterhalb) Strg + R Zuweisung einfügen Strg + A Flankenerkennung einfügen Strg + E Leeren Baustein einfügen Strg + Umschalt + B Netzwerk einfügen Strg + I Netzwerk einfügen (unterhalb) Strg + T Bausteineingang einfügen Strg + Q Sprung einfügen Strg + L Negation Strg + N Darüber einfügen Strg + H Darunter einfügen Strg + F Rechts einfügen (danach) Strg + G Weiterschaltung festlegen Strg + W Set\/Reset Strg + M Kommentierung ein\/aus Strg + O Parameter aktualisieren Strg + U Als Funktionsbausteinsprache anzeigen Strg + 1 Als Anweisungsliste anzeigen Strg + 3 Als Kontaktplan anzeigen Strg + 2 Kategorie Deklaration Menü Deklaration Einfügen Einfg EinfügenKategorie Fenster Menü FensterEditor schließen Strg + F4 Vorheriger Editor Strg + Umschalt + F6 Nächster Editor Strg + F6 Vorheriges Teilfenster Umschalt + F6 Nächstes Teilfenster F6 Erste Teilansicht umschalten Alt + F6 Kategorie Haltepunkte Menü DebugHaltepunkt umschalten F9 Einzelschritt F8 Ausführen bis Rücksprung Umschalt + F10 Prozedurschritt F10 Kategorie Hilfe HilfeInhalt Strg + Umschalt + F1 Kategorie Intelligentes Codieren Eingabehilfe F2 EingabehilfeVariable deklarieren Umschalt + F2 Variable deklarierenKatagorie Kontaktplan (LD2) Menü Kontaktplan Auskommentiert Strg + O Baustein einfügen Strg + B Flankenerkennung umschalten Strg + E Kontakt einfügen Strg + K Spule einfügen Strg + A Eingang einfügen Strg + Umschalt + I Ausgang einfügen Strg + Umschalt + O ST-Baustein einfügen Strg + Umschalt + S Negieren Strg + N Netzwerk einfügen Strg + I Set\/Reset-Modifizierer umschalten Strg + M Sprung einfügen Strg + L Return einfügen Strg + R EN Strg + Umschalt + E Fügt einen EN-Eingang hinzu oder weg ENQ Strg + Umschalt + N Fügt einen EN0-Eingang hinzu Parallele Verzweigung öffnen Strg + P Parallele Verzweigung schließen Strg + Umschalt + P Kategorie Lesezeichen Menü Bearbeiten → Lesezeichen Nächstes Lesezeichen (aktiver Editor) F12 Nächstes Lesezeichen (aktiver Editor)Vorheriges Lesezeichen (aktiver Editor) Umschalt + F12 Vorheriges Lesezeichen (aktiver Editor)Lesezeichen ein-\/ausschalten Strg + F12 Lesezeichen ein-\/ausschaltenKategorie \"Meldungsfenster\" Nächste Meldung F4 Nächste MeldungVorherige Meldung Umschalt + F4 Vorherige MeldungKategorie Online OnlineDebugWerte forcen F7 Werte forcenEinloggen ALT + F8 Ausloggen Strg + F8 Einzelzyklus Strg + F5 Start F5 Stop Umschalt + F8 Forcen für alle Werte aufheben [aktive Applikation] ALT + F7 Werte schreiben [aktive Applikation] Strg + F7 Kategorie Quelltextnavigation Gehe zu Definition Strg + Umschalt + D Gehe zur DefinitionQuerverweise ausgeben Strg + Umschalt + X Querverweise ausgebenKategorie Rückgängig\/Wiederherstellen StandardbefehleRückgängig Strg + Z Wiederherstellen Strg + Y Kategorie Suchen\/Ersetzen BearbeitenErsetzen Strg + H Im Projekt ersetzen Strg + Umschalt + H Suchen Strg + F Im Projekt suchen Strg + Umschalt + F Vorheriges Suchen Umschalt + F3 Vorheriges Suchen (Auswahl) Strg + Umschalt + F3 Weitersuchen F3 Weitersuchen (Auswahl) Strg + F3 Kategorie Texteditor Strukturierter Text und Erweiterter Strukturierter Text (ExST)Feld für inkrementelle Suche umschalten Strg + Umschalt + I In Kleinbuchstaben umwandeln Strg + U In Kleinbuchstaben umwandelnIn Großbuchstaben umwandeln Strg + Umschalt + U In Großbuchstaben umwandelnÜberschreibmodus Einfg ÜberschreibmodusSelektierte Zeilen auskommentieren Strg + O Selektierte Zeilen auskommentierenSelektierte Zeilen Auskommentierung entfernen Strg + I Selektierte Zeilen Auskommentierung entfernenKategorie Erstellen Code erzeugen F11 Code erzeugenKategorie Zwischenablage StandardbefehleKopieren Strg + Einfg Ausschneiden Strg + X Löschen Entf Einfügen Strg + V Alles selektieren Strg + A " }, 
{ "title" : "Tastaturkürzel im ST-Editor ", 
"url" : "_cds_shortcuts.html#UUID-f3d4b715-919a-f02b-f433-3a0754c935f4", 
"breadcrumbs" : "CODESYS Essentials \/ Tastaturkürzel \/ Tastaturkürzel im ST-Editor ", 
"snippet" : "ST-Editor Tastenkombination Umschalt + Alt + → Erweitert die Rechteckselektion des IEC-Codes nach rechts. Tipp: Verwenden Sie die Rechteckselektion, um die Einrückung des Codes zu ändern. Umschalt + Alt + ← Erweitert die Rechteckselektion des IEC-Codes nach links Umschalt + Alt + ↑ Erweitert die Rec...", 
"body" : "ST-Editor Tastenkombination Umschalt + Alt + → Erweitert die Rechteckselektion des IEC-Codes nach rechts. Tipp: Verwenden Sie die Rechteckselektion, um die Einrückung des Codes zu ändern. Umschalt + Alt + ← Erweitert die Rechteckselektion des IEC-Codes nach links Umschalt + Alt + ↑ Erweitert die Rechteckselektion des IEC-Codes nach oben Umschalt + Alt + ↓ Erweitert die Rechteckselektion des IEC-Codes nach unten Umschalt + → Erweitert die Selektion um ein Zeichen nach rechts Umschalt + ← Erweitert die Selektion um ein Zeichen nach links. Umschalt + ↑ Erweitert die Selektion um eine Zeile nach oben. Umschalt + ↓ Erweitert die Selektion um eine Zeile nach unten. Umschalt + Mausrad drehen Scrollt den IEC-Codes entlang der Bildlaufleiste Eine Bildlaufleiste erscheint automatisch, wenn der Code nicht mehr im Fenster angezeigt werden kann. Strg + Mausrad drehen Zoomt in den IEC-Code hinein und heraus Strg + Umschalt + i Öffnet den Dialog für das inkrementelle Suchen nach Zeichenfolgen Geben Sie eine Zeichenfolge ein. Nach dieser Zeichenfolge wird gefiltert und alle Übereinstimmungen werden hervorgehoben. Alt + Bild auf Alt + Bild ab Springt die nächste hervorgehobene Übereinstimmung im IEC-Code an Die Tastenkürzel sind nur aktiv, wenn der Dialog für die inkrementelle Suche geöffnet ist. " }, 
{ "title" : "Tastaturkürzel bei der Variablendeklaration ", 
"url" : "_cds_shortcuts.html#UUID-b084a34b-4c9b-2f23-7f63-b00a45a8774d", 
"breadcrumbs" : "CODESYS Essentials \/ Tastaturkürzel \/ Tastaturkürzel bei der Variablendeklaration ", 
"snippet" : "Im textuellen Deklarationseditor können Sie dort, wo Sie Variablen deklarieren, Tastaturkürzel verwenden, um sich Tipparbeit zu ersparen. Geben Sie in einer Codezeile die Kurzform ein und schließen Sie die Aktion mit der Tastenkombination Strg + Eingabe ab. Die Codezeile wird daraufhin automatisch v...", 
"body" : "Im textuellen Deklarationseditor können Sie dort, wo Sie Variablen deklarieren, Tastaturkürzel verwenden, um sich Tipparbeit zu ersparen. Geben Sie in einer Codezeile die Kurzform ein und schließen Sie die Aktion mit der Tastenkombination Strg + Eingabe ab. Die Codezeile wird daraufhin automatisch vervollständigt. Sie können die Angabe des Gültigkeitsbereichs abkürzen und Sie können die Variablendeklaration abkürzen. Für weitere Informationen siehe Abschnitt \"Kurzformmodus\": Eingabeunterstützung nutzenGültigkeitsbereich Kurzer Gültigkeitsbereich Wird nach Eingabe von Strg + Enter vervollständigt zu v VAR ev END_VAR vi VAR_INPUT vo VAR_OUTPUT vio VAR_IN_OUT Variablendeklaration mit Kurzform <Kurze Deklaration> + Strg + Eingabe Die kurze Deklaration wird ergänzt zu einer vollständigen Variablendeklaration mit Einrückung, abschließendem Semikolon und Kommentar. Geben Sie in einer Codezeile zuerst einen Variablennamen und nach einem Leerzeichen die Abkürzungen für Datentyp, Adresse, Initialisierung und Kommentar (alle optional) ein. Schließen Sie die Eingabe mit der Tastenkombination Strg + Eingabe ab. Daraufhin wird die verkürzte Eingabe ergänzt. <Variablenname> % <Adresse> <Kurzform für Datentyp> <Initialisierung> ; <Kommentar> Optionen für die kurze Deklaration <Variablenname> Geben Sie mindestens einen Variablennamen an. Sie können auch mehrere Variablennamen mit Leerzeichen getrennt eingeben. Das Komma wird automatisch ergänzt. % <Adresse> Optional Die kurze Adresse wird ergänzt zu einer AT-Deklaration . <Kurzform für Datentyp> Optional Default ist der Datentyp BOOL . Wenn kein Datentyp angegeben ist, wird BOOL ergänzt. Mögliche Kurzformen mit vollständiger Schreibweise in Klammer b ( : BOOL ) d ( : DINT ) i ( := INT) l ( : LINT ) r ( : REAL ) s ( : STRING ) s 8 ( : STRING(8) mit Stringlänge t ( : TIME ) u ( : UINT ) w ( : WORD ) <Initialisierung> Optional Geben Sie ein zum Datentyp passendes Literal an. Die Option wird ergänzt zu :=  <literal> ; <Kommentar> Optional Beispiele Kurze Deklaration Wird nach Eingabe von Strg + Enter vervollständigt zu xStart xStart : BOOL; xStop b xStop : BOOL; xSensor %IX7.5 xSensor AT %IX7.5: BOOL; diMax d 999 diMax: DINT; iMaxLoop i 100 iMaxLoop : INT := 100; liBigLoop l liBigLoop : LINT; rRadius r rRadius : REAL; strStateInProgress s 32 ; State in progress strStateInProgress : STRING(32); \/\/ State in Progress tMaxTime t tMaxTime : TIME; uiCounter u uiCounter : UINT; wFilter w 16#aaaa wFilter : WORD := 16#AAAA; Error_1 Error_2 Error_3 i ; Errorcodes Error_1, Error_2, Error_3 : INT; \/\/ Errorcodes " }, 
{ "title" : "Windows™ Tastaturkürzel ", 
"url" : "_cds_shortcuts.html#UUID-f952bfa4-6c2c-721d-4fad-ddafaad7c598", 
"breadcrumbs" : "CODESYS Essentials \/ Tastaturkürzel \/ Windows™ Tastaturkürzel ", 
"snippet" : "Grundsätzlich werden von CODESYS die Windows™ Tastenkombinationen unterstützt. Navigieren Sie mit den folgenden Tastaturkürzel in der Ansicht Geräte , Ansicht POUs , im Bibliotheksverwalter (im Inhalt), in der Taskkonfiguration, in der Eingabehilfe, in der Querverweisliste, in der Ansicht Visualisie...", 
"body" : "Grundsätzlich werden von CODESYS die Windows™ Tastenkombinationen unterstützt. Navigieren Sie mit den folgenden Tastaturkürzel in der Ansicht Geräte , Ansicht POUs , im Bibliotheksverwalter (im Inhalt), in der Taskkonfiguration, in der Eingabehilfe, in der Querverweisliste, in der Ansicht Visualisierungswerkzeuge , in den Eigenschaften, in der Visualisierungstags-Ansicht, in der Trendaufzeichnung, in der Tracekonfiguration oder in Repositorys. Objekte in den oben genannten Ansichten sind mit dem Symbol gekennzeichnet, wenn sich darunter weitere Objete befinden. Die Ansicht kann an dieser Stelle erweitert werden. Objekte sind mit dem Symbol gekennzeichnet, wenn sich darunter keine weiteren Objekte sind. Die Ansicht ist vollständig aufgeklappt. Nützliche Tastenkombinationen aus der Windows-Welt für die Navigation Tastaturbereich Taste Vorgehensweise Auswirkung Ziffernblock * Selektieren Sie in der Baumansicht einen mit dem Symbol gekennzeichneten Eintrag. Drücken Sie dann die Taste * . Alles, was sich in einer Baumansicht unterhalb des ausgewählten Objekts oder Ordners befindet, wird aufgeklappt. Ziffernblock Pfeiltasten + → Selektieren Sie in der Baumansicht einen mit dem Symbol gekennzeichneten Eintrag. Drücken Sie dann die Taste + oder → . Der Knoten ist mit dem Symbol gekennzeichnet. Das Objekt oder der Ordner wird aufgeklappt. Ziffernblock - Selektieren Sie in der Baumansicht einen mit dem Symbol gekennzeichneten Eintrag. Drücken Sie dann die Taste - . Der Ordner oder das Element wird zugeklappt. Ziffernblock Pfeiltasten \/ ← Selektieren Sie in der Baumansicht einen mit dem Symbol gekennzeichneten Eintrag. Drücken Sie dann die Taste \/ oder ← . Alles unter dem ausgewählten Objekt oder Ordner wird zugeklappt. Pfeiltasten ↓ Selektieren Sie einen Knoten in der Baumansicht. Drücken Sie dann die Taste ↓ . Selektion geht nach unten Pfeiltasten ↑ Selektieren Sie einen Knoten in der Baumansicht. Drücken Sie dann die Taste ↑ . Selektion geht nach oben Achten Sie darauf, dass der Ziffernblock aktiviert ist, wenn Sie Tastenkombinationen verwenden mit Tasten des Ziffernblocks. Zoomen Tastaturbereich Tastaturkürzel Auswirkung Ziffernblock, Tastenblock Strg + + Hineinzoomen Ziffernblock, Tastenblock Strg + - Herauszoomen " }, 
{ "title" : "Feldbusunterstützung ", 
"url" : "f_device_editors.html", 
"breadcrumbs" : "CODESYS Essentials \/ Feldbusunterstützung ", 
"snippet" : "CODESYS unterstützt die Anbindung an die gängigen Feldbustypen. Für allgemeine Informationen zur Verwendung von Geräten siehe: Gerätebaum und GeräteeditorFür spezielle Informationen zur Verwendung von Geräten für einen bestimmten Feldbustypen siehe die Hilfe zu diesem Feldbustyp. Zur Verwendung eine...", 
"body" : "CODESYS unterstützt die Anbindung an die gängigen Feldbustypen. Für allgemeine Informationen zur Verwendung von Geräten siehe: Gerätebaum und GeräteeditorFür spezielle Informationen zur Verwendung von Geräten für einen bestimmten Feldbustypen siehe die Hilfe zu diesem Feldbustyp. Zur Verwendung einer cifX-Karte von Hilscher GmbH (mit entsprechender IEC-Bibliothek als Treiber) muss die CODESYS -Konfigurationsdatei ( .cfg ) um folgenden Eintrag ergänzt werden:\n Component. <nächste freie Nummer> =CmpHilscherCIFX " }, 
{ "title" : "Gerätediagnose ", 
"url" : "_cds_device_diagnosis.html", 
"breadcrumbs" : "CODESYS Essentials \/ Feldbusunterstützung \/ Gerätediagnose ", 
"snippet" : "CODESYS stellt Ihnen allgemeine und feldbusspezifische Funktionsbausteine zur Verfügung, mit denen Sie eine Diagnose der verbundenen Geräte durchführen können. Busspezifische Diagnose Busspezifische Diagnosemöglichkeiten finden Sie in den Diagnosekapiteln der einzelnen Feldbusse. Für weitere Informa...", 
"body" : "CODESYS stellt Ihnen allgemeine und feldbusspezifische Funktionsbausteine zur Verfügung, mit denen Sie eine Diagnose der verbundenen Geräte durchführen können. Busspezifische Diagnose Busspezifische Diagnosemöglichkeiten finden Sie in den Diagnosekapiteln der einzelnen Feldbusse. Für weitere Informationen siehe: PROFINET-Diagose CANbus-Diagnose EtherCAT-Diagnose " }, 
{ "title" : "Allgemeine Diagnose ", 
"url" : "_cds_device_diagnosis.html#UUID-72f58fb2-a1cc-a2fd-a40b-f4a3fa8ca139_id_daf5ed59161447ec0a864634c91a40a_id_6d82803d91777a29c0a864635f481699", 
"breadcrumbs" : "CODESYS Essentials \/ Feldbusunterstützung \/ Gerätediagnose \/ Allgemeine Diagnose ", 
"snippet" : "Unabhängig vom Feldbus können Sie eine Diagnose der Geräte durchführen. Dazu stehen Ihnen die Funktionsbausteine der Bibliothek CAA Device Diagnosis zur Verfügung. Bevor Sie mit diesen Funktionsbausteinen arbeiten können, müssen Sie die Option Diagnose für Geräte aktivieren in den SPS-Einstellungen ...", 
"body" : "Unabhängig vom Feldbus können Sie eine Diagnose der Geräte durchführen. Dazu stehen Ihnen die Funktionsbausteine der Bibliothek CAA Device Diagnosis zur Verfügung. Bevor Sie mit diesen Funktionsbausteinen arbeiten können, müssen Sie die Option Diagnose für Geräte aktivieren in den SPS-Einstellungen aktivieren. Dies bewirkt, dass CODESYS automatisch Instanzen der Diagnose-FBs anlegt. Diese Funktionsbausteinen können Sie dann für Ihre Diagnose nutzen. Bitte arbeiten Sie ausschließlich mit den automatisch erzeugten Instanzen der Diagnose-FBs. Legen Sie keine eigenen Instanzen an. Für weitere Informationen siehe: Registerkarte: SPS-EinstellungenBibliothek CAA DeviceDiagnosis Gerätebaum und Geräteeditor" }, 
{ "title" : "Feldbusgeräte und E\/A-Treiber ", 
"url" : "_cds_device_fieldbus_devices_io_driver.html", 
"breadcrumbs" : "CODESYS Essentials \/ Feldbusunterstützung \/ Feldbusgeräte und E\/A-Treiber ", 
"snippet" : "Die technische Basis für jedes Feldbusgerät, das im Gerätebaum konfiguriert wird, ist der E\/A-Treiber. Der E\/A-Treiber ist das Bindeglied zwischen dem Feldbus-Stack, der IEC-Applikation und der -IDE. Der Treiber konfiguriert den Feldbus-Stack aus den Daten der Gerätekonfiguration. Er zeigt die Diagn...", 
"body" : "Die technische Basis für jedes Feldbusgerät, das im Gerätebaum konfiguriert wird, ist der E\/A-Treiber. Der E\/A-Treiber ist das Bindeglied zwischen dem Feldbus-Stack, der IEC-Applikation und der -IDE. Der Treiber konfiguriert den Feldbus-Stack aus den Daten der Gerätekonfiguration. Er zeigt die Diagnose an, bietet eine API für die IEC-Applikation und ist zuständig für das so genannte E\/A-Abbild (siehe Abschnitt „E\/A-Abbild“). Dieses Kapitel gibt einen kurzen Überblick über die grundlegende Funktionsweise von E\/A-Treiber-Geräten, ohne auf Details spezifischer Bussysteme einzugehen. Zudem werden einige Empfehlungen für die Konfiguration gegeben. Mehrere E\/A-Treiber und Tasks (Problembehandlung) Wenn konsistente Zugriffe auf E\/A-Daten aus mehreren Tasks und möglicherweise über mehrere E\/A-Treiber-Instanzen synchronisiert werden müssen, kann es unter Umständen zur ungewünschten gegenseitigen Beeinflussung der Bus- und Applikationstask kommen. Dies ist beispielsweise bei hoher allgemeiner Systemlast der Fall oder wenn die E\/A-Daten des echtzeitkritischen Feldbussystems zusammen mit E\/A-Daten eines langsamen und blockierenden lokalen Bussystems in der gleichen Task verwendet werden. Bei unerwarteten Störungen der Kommunikation, bei den besonders echtzeitkritischen Feldbussen (EtherCAT, Profinet, CAN) sollte daher zunächst das Task-Monitoring auf sehr großen Jitter oder Ausreißer bei der Zykluszeit (Maximalwert verglichen mit Mittelwert) untersucht werden. Die Taskaufstellung gibt detailliert Aufschluss über die Benutzung von E\/A-Daten in verschieden Tasks. Eventuell kann die Verwendung von E\/A-Daten verschiedener Bussysteme in ein und derselben Task vermieden oder auch die Anzahl der E\/A-Tasks reduziert werden. Für weitere Informationen siehe: Registerkarte: Taskaufstellung" }, 
{ "title" : "Buszyklustask ", 
"url" : "_cds_device_fieldbus_devices_io_driver.html#UUID-0697b338-d922-83f2-5218-d9fb5943436b_id_cc679fb955dea19c0a86463511f6cb4_id_28c562449569c838c0a8646342ae39cb", 
"breadcrumbs" : "CODESYS Essentials \/ Feldbusunterstützung \/ Feldbusgeräte und E\/A-Treiber \/ Buszyklustask ", 
"snippet" : "Die Buszyklustask ist die IEC-Task, in deren Kontext der E\/A-Treiber ausgeführt wird. Einige E\/A-Treiber verwenden mehrere Tasks: In der Regel eine echtzeitkritische Task (mit hoher Priorität), die dem Transfer der E\/A-Daten dient, und eine weitere Task mit niedriger Priorität für Aufgaben wie der A...", 
"body" : "Die Buszyklustask ist die IEC-Task, in deren Kontext der E\/A-Treiber ausgeführt wird. Einige E\/A-Treiber verwenden mehrere Tasks: In der Regel eine echtzeitkritische Task (mit hoher Priorität), die dem Transfer der E\/A-Daten dient, und eine weitere Task mit niedriger Priorität für Aufgaben wie der Auswertung von Diagnose und Ausführung azyklischer Dienste des Bussystems. Bei echtzeitkritischen Bussystemen muss sichergestellt sein, dass im Kontext dieser Bustask keine Operationen ausgeführt werden, die aufgrund der Ausführungsdauer den Bustakt stören. Die Bustask kann im E\/A-Abbild-Dialog des E\/A-Treiber-Geräts konfiguriert werden. Zu beachten ist, dass standardmäßig die Einstellungen des Elterngeräts vererbt werden. Ist dieses Gerät die SPS, dann gilt deren SPS-Einstellung in der Buszyklustask. Wenn diese o.g. Einstellung nicht gesetzt ist, dann wird die Task mit der kürzesten Zykluszeit verwendet. Auf diese Weise kann unbeabsichtigt ein nicht echtzeitfähiger E\/A-Treiber im Task-Kontext eines echtzeitkritischen Treibers ausgeführt werden, was deren Kommunikation stört. Zur Diagnose dieser Kommunikationsstörungen empfiehlt sich ein Blick in das Task-Monitoring. Für weitere Informationen siehe: Buszyklus-Optionen " }, 
{ "title" : "E\/A-Abbild ", 
"url" : "_cds_device_fieldbus_devices_io_driver.html#UUID-0697b338-d922-83f2-5218-d9fb5943436b_id_cc679fb955dea19c0a86463511f6cb4_id_a15ed2aa9569c838c0a864637ae138e7", 
"breadcrumbs" : "CODESYS Essentials \/ Feldbusunterstützung \/ Feldbusgeräte und E\/A-Treiber \/ E\/A-Abbild ", 
"snippet" : "Eine wesentliche Funktion eines -E\/A-Treibers ist die Aktualisierung des E\/A-Abbilds. Darunter versteht man die Abbildung der E\/A-Daten des Bussystems auf Variablen der IEC-Applikation (und umgekehrt). Die Ein-\/Ausgangsdaten werden zyklisch durch Kopier- und Konvertierungsoperationen in beiden Richt...", 
"body" : "Eine wesentliche Funktion eines -E\/A-Treibers ist die Aktualisierung des E\/A-Abbilds. Darunter versteht man die Abbildung der E\/A-Daten des Bussystems auf Variablen der IEC-Applikation (und umgekehrt). Die Ein-\/Ausgangsdaten werden zyklisch durch Kopier- und Konvertierungsoperationen in beiden Richtungen vom internen Speicherabbild des Bussystems auf IEC-Variablen abgebildet, die %I- und %Q-Adressen zugeordnet sind. Für den E\/A-Treiber gibt es intern keinen Unterschied, ob für dieses E\/A-Abbild symbolische Namen oder ein „direkter“ Zugriff auf die %I- und %Q-Adressen verwendet wird. Für die Wartbarkeit der Anwendung empfiehlt es sich, grundsätzlich aussagekräftige Variablennamen zu verwenden (Beispiel: Variable „TemperatureReactor“ anstatt „%IW117“-Zugriff). Die Aktualisierung des E\/A-Abbilds kann über Variablen immer aktualisieren (global in den SPS-Einstellungen oder individuell für jedes Gerät im E\/A-Abbild-Dialog) eingestellt werden: Deaktiviert: Es werden nur E\/A-Daten abgebildet, die in der Applikation verwendet werden. Das bringt unter Umständen durch die Vermeidung der Kopieroperationen einen Performance-Gewinn, kann aber für Verwirrung sorgen, wenn die E\/A-Daten im E\/A-Abbild-Dialog nicht aktualisiert werden (die Werte werden dann ausgegraut dargestellt). Diese Einstellung empfiehlt sich für eine Anwendung, deren Entwicklung abgeschlossen ist. Aktiviert 1: Alle Daten werden aktualisiert Aktiviert 2: Die Verfügbarkeit dieser Option hängt von der Gerätebeschreibung ab. Achtung: Nur in Sonderfällen produktiv verwenden! Dadurch entstehen unter Umständen inkonsistente E\/A-Daten, da diese durch die Buszyklustask gelesen\/geschrieben werden, während sie in anderen Tasks vom Applikationscode verwendet werden. Für weitere Informationen siehe: Registerkarte: <Gerätename> E\/A-Abbild" }, 
{ "title" : "Konsistenz E\/A-Daten ", 
"url" : "_cds_device_fieldbus_devices_io_driver.html#UUID-0697b338-d922-83f2-5218-d9fb5943436b_id_cc679fb955dea19c0a86463511f6cb4_id_8f4981b79569c838c0a8646301a3da14", 
"breadcrumbs" : "CODESYS Essentials \/ Feldbusunterstützung \/ Feldbusgeräte und E\/A-Treiber \/ Konsistenz E\/A-Daten ", 
"snippet" : "Das -Programmiersystem ermöglicht der IEC-Applikation die Verwendung mehrerer parallel ausgeführter Tasks (für Visualisierung, Feldbusse, sonstige POUs). Der Code der Applikation kann aus dem Kontext dieser Tasks über die gemappten IEC-Variablen beliebig auf E\/A-Daten zugreifen. Durch den Zugriff au...", 
"body" : "Das -Programmiersystem ermöglicht der IEC-Applikation die Verwendung mehrerer parallel ausgeführter Tasks (für Visualisierung, Feldbusse, sonstige POUs). Der Code der Applikation kann aus dem Kontext dieser Tasks über die gemappten IEC-Variablen beliebig auf E\/A-Daten zugreifen. Durch den Zugriff auf ein und dieselben Daten aus unterschiedlichen Tasks könnte es zu inkonsistenten oder korrupten Daten kommen (zum Beispiel durch unterbrochene Schreibzugriffe). Der E\/A-Treiber gewährleistet die Konsistenz der Daten, indem er jeder Task für die Ausführung eines Taskzyklus ein jeweils in sich konsistentes Abbild - sozusagen eine Momentaufnahme - aller verwendeten E\/A-Daten bereitstellt. Ein Code wie im nachfolgenden Beispiel kann also nicht zu Problemen führen: (Anmerkung „DIV by ZERO“) IF(inputData <> 0) THEN \/\/ inputData is mapped to %I\n x := y \/ inputData; \/\/ This will never result in DIV_BY_ZERO Exception\nEND_IF \/\/ inputData is not updated by bus cycle during execution of POU Mit der Option Variablen immer aktualisieren = Aktiviert 2 – immer in Buszyklustask wird dieser Mechanismus ausgehebelt. Dementsprechend muss dies vom Applikationscode berücksichtigt werden. " }, 
{ "title" : "Dienste ", 
"url" : "_cds_device_fieldbus_devices_io_driver.html#UUID-0697b338-d922-83f2-5218-d9fb5943436b_id_cc679fb955dea19c0a86463511f6cb4_id_06856b5b9569c838c0a864632fe4dc2e", 
"breadcrumbs" : "CODESYS Essentials \/ Feldbusunterstützung \/ Feldbusgeräte und E\/A-Treiber \/ Dienste ", 
"snippet" : "Einige E\/A-Treiber stellen zusätzlich zur Basisfunktionalität Dienste zur Verfügung, die von der -IDE aufgerufen werden können, so zum Beispiel die Geräte-Scan-Funktion oder das Setzen von Geräteadressen....", 
"body" : "Einige E\/A-Treiber stellen zusätzlich zur Basisfunktionalität Dienste zur Verfügung, die von der -IDE aufgerufen werden können, so zum Beispiel die Geräte-Scan-Funktion oder das Setzen von Geräteadressen. " }, 
{ "title" : "Allgemeine Empfehlungen ", 
"url" : "_cds_device_fieldbus_devices_io_driver.html#UUID-0697b338-d922-83f2-5218-d9fb5943436b_id_cc679fb955dea19c0a86463511f6cb4_id_597a65569569c838c0a864636c5a9a3d", 
"breadcrumbs" : "CODESYS Essentials \/ Feldbusunterstützung \/ Feldbusgeräte und E\/A-Treiber \/ Allgemeine Empfehlungen ", 
"snippet" : "Einstellungen: SPS-Einstellungen : E\/A aktualisieren im Stop: Der Buszyklus läuft auch im Stop der Applikation weiter, beispielsweise wenn die Anwendung auf einem Debug-Haltepunkt steht. Dadurch wird die Kommunikation zu den Feldgeräten weiter aufrechterhalten und kann ohne Unterbrechung unmittelbar...", 
"body" : "Einstellungen: SPS-Einstellungen : E\/A aktualisieren im Stop: Der Buszyklus läuft auch im Stop der Applikation weiter, beispielsweise wenn die Anwendung auf einem Debug-Haltepunkt steht. Dadurch wird die Kommunikation zu den Feldgeräten weiter aufrechterhalten und kann ohne Unterbrechung unmittelbar fortgesetzt werden. SPS-Einstellungen : Variablen immer aktualisieren = Aktiviert 1 – Buszyklustask verwenden, wenn in keiner Task verwendet : Während der Entwicklung der Applikation ist es sinnvoll, die Werte aller E\/A-Daten zu sehen. Taskkonfiguration: Besonders für echtzeitkritische Feldbussystemen wie Profinet, EtherCAT oder CAN, die auf das Einhalten eines exakten Sende-\/Empfangstakts angewiesen sind, empfiehlt es sich, jeweils eine eigene Buszyklustask mit hoher Priorität zu verwenden. Für weniger echtzeitkritische Tasks (beispielsweise Visualisierung) sollte eine deutlich geringere Priorität als für die Buszyklustask gewählt werden. Um maximalen und möglichst versatzfreien E\/A-Durchsatz zu erreichen, können eigene POUs in der Bustask des Feldbussystems ausgeführt werden. Diese müssen dann jedoch den Echtzeitanforderungen genügen: Es dürfen beispielsweise keine Dateizugriffe oder blockierende Socket-Funktionen ausgeführt werden, sondern beispielsweise nur die Berechnung der Ausgangsdaten. " }, 
{ "title" : "Buszyklus-Task ", 
"url" : "_cds_buscycle_task.html", 
"breadcrumbs" : "CODESYS Essentials \/ Feldbusunterstützung \/ Buszyklus-Task ", 
"snippet" : "Grundsätzlich werden für jede IEC-Task die verwendeten Eingangsdaten am Beginn jeder Task gelesen (1) und die geschriebenen Ausgangsdaten am Ende der Task (3) zum E\/A-Treiber übertragen. Die Implementierung im E\/A-Treiber ist entscheidend für den weiteren Transport der E\/A-Daten. Sie ist verantwortl...", 
"body" : "Grundsätzlich werden für jede IEC-Task die verwendeten Eingangsdaten am Beginn jeder Task gelesen (1) und die geschriebenen Ausgangsdaten am Ende der Task (3) zum E\/A-Treiber übertragen. Die Implementierung im E\/A-Treiber ist entscheidend für den weiteren Transport der E\/A-Daten. Sie ist verantwortlich dafür, in welchem Zeitraster und zu welchem Zeitpunkt die tatsächliche Übertragung auf das jeweilige Bussystem stattfindet. Die Buszyklustask der SPS kann für alle Feldbusse global in den SPS-Einstellungen festgelegt werden. Bei einigen Feldbussen können Sie diese jedoch unabhängig von der globalen Einstellung verändern. Als Buszyklustask wird automatisch die Task mit der kürzesten Zykluszeit verwendet (Einstellung: unspezifiziert in den SPS-Einstellungen). In dieser Task werden normalerweise die Nachrichten auf den Bus gesendet. Weitere Tasks kopieren nur die E\/A-Daten aus einem internen Puffer, der nur in der Buszyklustask mit der realen Hardware ausgetauscht wird. (1) Lesen der Eingänge vom Eingangspuffer (2) IEC-Task (3) Schreiben der Ausgänge in den Ausgangspuffer (4) Buszyklus (5) Eingangspuffer (6) Ausgangspuffer (7) Daten vom\/zum Bus kopieren (9) Buszyklustask, Priorität 1, 1ms (10) Buszyklustask, Priorität 5 (11) Buszyklustask, Priorität 10, unterbrochen durch Task 5 Taskverwendung In der Registerkarte Taskaufstellung steht Ihnen eine Übersicht der verwendeten E\/A-Kanäle, der eingestellten Buszyklustask und der Verwendung der Kanäle zur Verfügung Wenn ein Ausgang in verschiedenen Tasks geschrieben wird, so ist der Zustand undefiniert, da dieser jeweils überschrieben werden kann. Bei Verwendung von gleichen Eingängen in verschiedenen Tasks kann es passieren, dass sich der Eingang während der Abarbeitung einer Task verändert. Dies geschieht, wenn die Task durch eine Task mit höherer Priorität unterbrochen und damit das Prozessabbild erneut eingelesen wird. Abhilfe: Am Beginn der IEC-Task die Eingangsvariablen in Variablen kopieren und dann im weiteren Code nur noch mit den lokalen Variablen arbeiten. Fazit: Eine Verwendung von gleichen Ein- und Ausgängen in mehreren Tasks ist nicht sinnvoll und kann in manchen Fällen zu unvorhergesehenen Zuständen führen. Für weitere Informationen siehe: TaskkonfigurationBuszyklus-Task beim CANopen Manager Buszyklus-Task bei EtherCAT Buszyklus-Task bei Sercos Buszyklus-Task bei EtherNet\/IP Buszyklus-Task bei PROFIBUS " }, 
{ "title" : "Symbolisch auf einen EA-Kanal zugreifen ", 
"url" : "_cds_symbolic_access_io_channels.html", 
"breadcrumbs" : "CODESYS Essentials \/ Feldbusunterstützung \/ Symbolisch auf einen EA-Kanal zugreifen ", 
"snippet" : "Sie erhalten über eigens generierte Funktionsbausteine direkt Zugriff auf die EA-Kanäle Ihres Geräts, ohne aktiv bei jedem Gerät und für jeden Kanal ein Mapping manuell aufsetzen zu müssen. Automatisierte Generierung Unter dem Namen des EA-Kanals werden die Eingänge und Ausgänge zu einem Funktionsba...", 
"body" : "Sie erhalten über eigens generierte Funktionsbausteine direkt Zugriff auf die EA-Kanäle Ihres Geräts, ohne aktiv bei jedem Gerät und für jeden Kanal ein Mapping manuell aufsetzen zu müssen. Automatisierte Generierung Unter dem Namen des EA-Kanals werden die Eingänge und Ausgänge zu einem Funktionsbaustein zusammengefasst. Dabei wird möglichst der Basisbaustein, der in der Gerätebeschreibung definiert ist, erweitert. Der Kanalname entspricht dem Namen, wie er im Geräteeditor auf der Registerkarte: <Gerätename> E\/A-Abbild in der Spalte Kanal angegeben ist. Im Eingabeassistenten werden die so erzeugten Ein- und Ausgangsvariablen ebenfalls angezeigt. Wenn die EA-Kanäle strukturiert oder Enumerationen sind, werden deren Funktionsbausteine ebenfalls entsprechend strukturiert. Die generierten Funktionsbausteine enthalten demgemäß strukturierte Ein- und Ausgänge oder Enumerationen. Bei Kanälen mit identischen Namen wird dem Ein- oder Ausgang des Funktionsbausteins das Suffix _<number> angehängt. Wenn ein Gerät keine eigenen EA-Kanäle hat (wie beispielsweise beim Slave EK1100), wird kein Funktionsbaustein erstellt. " }, 
{ "title" : "Automatisches Mapping aktivieren ", 
"url" : "_cds_symbolic_access_io_channels.html#UUID-0a064dd1-3562-5c32-2219-21a759dad045_section-idm4536908457891232946602093636", 
"breadcrumbs" : "CODESYS Essentials \/ Feldbusunterstützung \/ Symbolisch auf einen EA-Kanal zugreifen \/ Automatisches Mapping aktivieren ", 
"snippet" : "Öffnen Sie in der Ansicht Geräte das Top-Gerät. Wählen Sie im Geräteeditor die Registerkarte SPS-Einstellungen . Unter Zusätzliche Einstellungen befindet sich die Option Symbolischer Zugriff für E\/As aktiviern. Selektieren Sie das Kontrollkästchen. In der Registerkarte IEC-Objekte des Geräts wird di...", 
"body" : "Öffnen Sie in der Ansicht Geräte das Top-Gerät. Wählen Sie im Geräteeditor die Registerkarte SPS-Einstellungen . Unter Zusätzliche Einstellungen befindet sich die Option Symbolischer Zugriff für E\/As aktiviern. Selektieren Sie das Kontrollkästchen. In der Registerkarte IEC-Objekte des Geräts wird die generierte Funktionsbaustein-Instanz angezeigt. Für jeden EA-Kanal wird nun automatisch ein (meist erweiterter) Funktionsbaustein erstellt und instanziiert. Damit ist für Sie ein direkter Zugriff unmittelbar möglich. Sie können über die Variablen des Funktionsbausteins auf den EA-Kanal zugreifen. Beispiel: EtherCAT Slave Der neue Funktionsbaustein erweitert den bestehenden Funktionsbaustein. Im Geräteeditor unter der Registerkarte EtherCAT IEC-Objekte wird die Funktionsbaustein-Instanz EL1008 aufgelistet. Der Funktionsbaustein DrvEghercatLib.ETCSlave_Diag wird erweitert zu EL1008_FB und erhält die Ausgangsvariablen Input_<n> . Funktionsbaustein EL1008_FB Beispiel: Gerät ohne definierten Basisbaustein Wenn in der Gerätebeschreibung kein Funktionsbaustein definiert ist, der erweitert werden kann, wird ein neuer Funktionsbaustein generiert. Im Geräteeditor unter der Registerkarte IEC-Objekte wird beispielsweise die Funktionsbaustein-Instanz Generic_XN1AI aufgelistet. Neuer Funktionsbaustein Generic_XN_1AI_F Beispiel: CANopen Der Funktionsbaustein BK5120_FB , der gemäß der Gerätebeschreibung den existierende Funktionsbaustein _3SCOS.CANRemoteDevicee erweitert, wird generiert. Im Geräteeditor in der Registerkarte CANopen IEC-Objekte wird die Funktionsbaustein-Instanz BK5120 gelistet. Funktionsbaustein BK5120_FB " }, 
{ "title" : "Onlinebetrieb ", 
"url" : "_cds_symbolic_access_io_channels.html#UUID-0a064dd1-3562-5c32-2219-21a759dad045_section-idm4536908379939232946873025889", 
"breadcrumbs" : "CODESYS Essentials \/ Feldbusunterstützung \/ Symbolisch auf einen EA-Kanal zugreifen \/ Onlinebetrieb ", 
"snippet" : "Während des Onlinebetriebs erfolgt die Aktualisierung der Daten über die bestehenden Funktionen. Allerdings werden nur diejenigen der generierten Variablen aktualisiert, die tatsächlich verwendet werden. Oder wenn die Option Variablen immer aktualisieren aktiviert ist. Wenn auf einen Kanal gleichzei...", 
"body" : "Während des Onlinebetriebs erfolgt die Aktualisierung der Daten über die bestehenden Funktionen. Allerdings werden nur diejenigen der generierten Variablen aktualisiert, die tatsächlich verwendet werden. Oder wenn die Option Variablen immer aktualisieren aktiviert ist. Wenn auf einen Kanal gleichzeitig symbolisch und über IO-Mapping zugegriffen wird, erscheinen Compilerwarnungen. " }, 
{ "title" : "Bibliotheken ", 
"url" : "f_libraries.html", 
"breadcrumbs" : "CODESYS Essentials \/ Bibliotheken ", 
"snippet" : "Bibliotheken dienen der Bereitstellung von Bausteinen und Funktionen zur Verwendung in -Applikationen. Neben den hier in der Hilfe vorliegenden Beschreibungen sehen Sie bitte immer auch die in der Bibliothek enthaltene Dokumentation. Zur Handhabung von Bibliotheken im -Projekt beachten Sie bitte: Bi...", 
"body" : "Bibliotheken dienen der Bereitstellung von Bausteinen und Funktionen zur Verwendung in -Applikationen. Neben den hier in der Hilfe vorliegenden Beschreibungen sehen Sie bitte immer auch die in der Bibliothek enthaltene Dokumentation. Zur Handhabung von Bibliotheken im -Projekt beachten Sie bitte: Bibliotheken verwendenWenn Sie selbst mit Bibliotheken erstellen, beachten Sie unbedingt die Richtlinien für Bibliotheksentwickler . " }, 
{ "title" : "Richtlinien für das Erstellen von Bibliotheken ", 
"url" : "_cds_guidelines_for_creating_libraries.html", 
"breadcrumbs" : "CODESYS Essentials \/ Bibliotheken \/ Richtlinien für das Erstellen von Bibliotheken ", 
"snippet" : "Bibliotheken müssen nach bestimmten Regeln erstellt sein, um Kompatibilitätsprobleme zu vermeiden. Die wichtigsten Punkte sind: Definieren Sie einen sinnvollen Bibliotheksnamen (obligatorisch) Verwenden Sie Vorlagen, um Konsistenz zu erreichen (optional) Verwenden Sie eine bekannte und soweit als mö...", 
"body" : "Bibliotheken müssen nach bestimmten Regeln erstellt sein, um Kompatibilitätsprobleme zu vermeiden. Die wichtigsten Punkte sind: Definieren Sie einen sinnvollen Bibliotheksnamen (obligatorisch) Verwenden Sie Vorlagen, um Konsistenz zu erreichen (optional) Verwenden Sie eine bekannte und soweit als möglich einheitliche Projektstruktur (optional) Lassen Sie einen eindeutigen globalen Bibliotheksnamensraum registrieren (obligatorisch) Füllen Sie die Projektinformation aus (obligatorisch) Referenzieren Sie andere Bibliotheken korrekt (obligatorisch) Implementieren Sie brauchbare externe und interne Schnittstellen (obligatorisch) Implementieren Sie eine benutzerfreundliche Fehlerverwaltung (obligatorisch) Wenden Sie die passenden Methoden (Schutz) für die Bereitstellung an (obligatorisch) Folgen Sie einer Namenskonvention, um sauberen Code zu erhalten (optional) Wenn Sie eine bestehende Bibliothek weiterentwickeln, achten Sie auf Schnittstellenkompatibilität zu vorherigen Versionen. Folgen Sie deshalb bitte den Richtlinien für Bibliotheksentwicklung in CODESYS : \"Library Development Summary“. " }, 
{ "title" : "Für diesen Hilfeaufruf gibt es keine Hilfeseite ", 
"url" : "_cds_f_development_system_introduction.html", 
"breadcrumbs" : "CODESYS Essentials \/ Für diesen Hilfeaufruf gibt es keine Hilfeseite ", 
"snippet" : "Hier geht es zur Startseite des Hilfeportals...", 
"body" : "Hier geht es zur Startseite des Hilfeportals " }
]
$(document).trigger('search.ready');
});