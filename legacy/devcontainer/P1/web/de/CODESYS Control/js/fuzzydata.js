$(document).ready(function () {indexDict['de'] = [{ "title" : "CODESYS Control ", 
"url" : "_rtsl_start_page.html", 
"breadcrumbs" : "CODESYS Control \/ CODESYS Control ", 
"snippet" : "Sie können das Laufzeitsystem CODESYS Control for <device> SL auf den unterschiedlichsten Industriegeräten installieren. Sie haben damit folgende Möglichkeiten bei der Programmierung und Steuerung der Geräte: Einheitliche Programmierung nach IEC 61131-3 mit CODESYS Development System Laden, Verwalte...", 
"body" : "Sie können das Laufzeitsystem CODESYS Control for <device> SL auf den unterschiedlichsten Industriegeräten installieren. Sie haben damit folgende Möglichkeiten bei der Programmierung und Steuerung der Geräte: Einheitliche Programmierung nach IEC 61131-3 mit CODESYS Development System Laden, Verwalten und Ausführen des von CODESYS erzeugten Applikationscodes Debugging der Steuerungsapplikation innerhalb von CODESYS Handling der E\/A-Systeme und Feldbusse Ausführung optionaler Komponenten wie beispielsweise CODESYS TargetVisu , CODESYS WebVisu , CODESYS SoftMotion CNC + Robotics und OPC UA Server " }, 
{ "title" : "Sicherheitshinweise ", 
"url" : "_rtsl_start_page.html#UUID-421e9fc4-30bc-da26-ebd8-4038f3d434c1_section-idm4550391658761633048843474945", 
"breadcrumbs" : "CODESYS Control \/ CODESYS Control \/ Sicherheitshinweise ", 
"snippet" : "Steuerungen dürfen unter keinen Umständen vom Internet aus zugreifbar sein! Speziell die Programmierports der Steuerung dürfen auf keinen Fall ungeschützt aus dem Internet zugreifbar sein. Die folgenden Portnummern sind die Wichtigsten für alle Laufzeitsysteme. Sie werden vom System standardmäßig ve...", 
"body" : "Steuerungen dürfen unter keinen Umständen vom Internet aus zugreifbar sein! Speziell die Programmierports der Steuerung dürfen auf keinen Fall ungeschützt aus dem Internet zugreifbar sein. Die folgenden Portnummern sind die Wichtigsten für alle Laufzeitsysteme. Sie werden vom System standardmäßig vergeben, können jedoch über die Konfiguration verändert werden: 1740..1743: UDP-Blocktreiber in Gateway und Laufzeitsystem. 11740..11743: TCP-Blocktreiber in Gateway und Laufzeitsystem. 1217: Gateway, zur Verbindung von CODESYS zum Gateway. 8080: CODESYS Web-Server 443: CODESYS WebServer (SSL) * * 9090: für Beaglebone 4840: CODESYS OPC UA-Server 22: SSH-Verbindung zum Zielsystem (Installation\/Update von Linux-basierten SL-Laufzeitsystemen über das CODESYS -Programmiersystem) Wenn ein Zugriff aus dem Internet dennoch möglich sein muss, dann muss zwingend ein sicheres Verfahren für die Verbindung mit der Steuerung gewählt werden (zum Beispiel VPN). Da die Laufzeitsysteme Zugriff auf den PC ermöglichen, sollten sie unbedingt mit einer entsprechenden Benutzer- und Rechteverwaltung ausgestattet sein. Sie können die Produkte zu CODESYS Control im CODESYS Store International oder im CODESYS Store North America herunterladen. Dort finden Sie auch das Datenblatt zum Produkt. CODESYS Deploy Tool " }, 
{ "title" : "Übersicht Produkte ", 
"url" : "_rtsl_product_overview.html", 
"breadcrumbs" : "CODESYS Control \/ Übersicht Produkte ", 
"snippet" : "Informationen zu den Systemanforderungen und den Lieferumfängen der CODESYS Control for <device> SL -Produkte finden Sie im CODESYS Store International : Die Lizenzen zu den Laufzeitsystemen finden Sie im CODESYS Store International . Ohne gültige Lizenz ist die Laufzeit aller Laufzeitsysteme auf 2 ...", 
"body" : "Informationen zu den Systemanforderungen und den Lieferumfängen der CODESYS Control for <device> SL -Produkte finden Sie im CODESYS Store International : Die Lizenzen zu den Laufzeitsystemen finden Sie im CODESYS Store International . Ohne gültige Lizenz ist die Laufzeit aller Laufzeitsysteme auf 2 Stunden begrenzt. " }, 
{ "title" : "Hardwareunabhängige Laufzeitsysteme ", 
"url" : "_rtsl_product_overview.html#UUID-da861021-6b3f-718d-ac40-c1e7e9f72bd8_section-idm4613712476080033169570967262", 
"breadcrumbs" : "CODESYS Control \/ Übersicht Produkte \/ Hardwareunabhängige Laufzeitsysteme ", 
"snippet" : "CODESYS Control Win SL CODESYS Control RTE SL CODESYS Control for Linux SL CODESYS Control for Linux ARM\/ARM64 CODESYS Virtual Control SL CODESYS Virtual Safe Control SL...", 
"body" : "CODESYS Control Win SL CODESYS Control RTE SL CODESYS Control for Linux SL CODESYS Control for Linux ARM\/ARM64 CODESYS Virtual Control SL CODESYS Virtual Safe Control SL " }, 
{ "title" : "Hardwarespezifische Laufzeitsysteme ", 
"url" : "_rtsl_product_overview.html#UUID-da861021-6b3f-718d-ac40-c1e7e9f72bd8_section-idm4589278258244833169573395522", 
"breadcrumbs" : "CODESYS Control \/ Übersicht Produkte \/ Hardwarespezifische Laufzeitsysteme ", 
"snippet" : "CODESYS Control for Beaglebone SL CODESYS Control for Raspberry PI SL CODESYS Control for PFC100 SL CODESYS Control for PFC200 SL CODESYS Control for emPC-A\/iMX6 SL CODESYS Control for WAGO Touch Panels 600 SL CODESYS Control for PLCnext SL CODESYS Control RTE SL (for Beckhoff CX)...", 
"body" : "CODESYS Control for Beaglebone SL CODESYS Control for Raspberry PI SL CODESYS Control for PFC100 SL CODESYS Control for PFC200 SL CODESYS Control for emPC-A\/iMX6 SL CODESYS Control for WAGO Touch Panels 600 SL CODESYS Control for PLCnext SL CODESYS Control RTE SL (for Beckhoff CX) " }, 
{ "title" : "Edge Gateways ", 
"url" : "_rtsl_product_overview.html#UUID-da861021-6b3f-718d-ac40-c1e7e9f72bd8_section-idm4544772720513633169577754493", 
"breadcrumbs" : "CODESYS Control \/ Übersicht Produkte \/ Edge Gateways ", 
"snippet" : "Das CODESYS Edge Gateway ist ein erweitertes CODESYS -Gateway, das den CODESYS Automation Server mit CODESYS -Steuerungen in einem lokalen Netzwerk verbindet. CODESYS Edge Gateway for Linux CODESYS Edge Gateway for Windows...", 
"body" : "Das CODESYS Edge Gateway ist ein erweitertes CODESYS -Gateway, das den CODESYS Automation Server mit CODESYS -Steuerungen in einem lokalen Netzwerk verbindet. CODESYS Edge Gateway for Linux CODESYS Edge Gateway for Windows " }, 
{ "title" : "Linuxbasierte Laufzeitsysteme ", 
"url" : "_rtsl_linux_runtime_systems.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Erste Schritte ", 
"url" : "_rtsl_first_steps.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte ", 
"snippet" : "In diesem Kapiel erfahren Sie, wie Sie ein Gerät mit CODESYS Control SL-Laufzeitsystem in Betrieb nehmen, eine kleine CODESYS -Applikation starten und die Steuerung lizenzieren....", 
"body" : "In diesem Kapiel erfahren Sie, wie Sie ein Gerät mit CODESYS Control SL-Laufzeitsystem in Betrieb nehmen, eine kleine CODESYS -Applikation starten und die Steuerung lizenzieren. " }, 
{ "title" : "Vorbereitung ", 
"url" : "_rtsl_preparation_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Vorbereitung ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Steuerung ", 
"url" : "_rtsl_preparation_linux.html#UUID-6cfdd13d-15e9-2ce9-6bfc-ddfaec59e7f5_section-idm234655601003053", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Vorbereitung \/ Steuerung ", 
"snippet" : "Voraussetzung: Auf Ihrer Steuerung muss ein aktuelles Linux-Betriebssystem (beispielsweise Debian oder Ubuntu) installiert und ein ssh-Server installiert und aktiviert sein. Zur Überprüfung, ob der ssh-Server aktiv ist, führen Sie auf Ihrer Steuerung folgenden Befehl aus: sudo systemctl status ssh W...", 
"body" : "Voraussetzung: Auf Ihrer Steuerung muss ein aktuelles Linux-Betriebssystem (beispielsweise Debian oder Ubuntu) installiert und ein ssh-Server installiert und aktiviert sein. Zur Überprüfung, ob der ssh-Server aktiv ist, führen Sie auf Ihrer Steuerung folgenden Befehl aus: sudo systemctl status ssh Wenn der ssh-Server aktiv ist, sollte die Ausgabe wie folgt aussehen: ssh.service - OpenBSD Secure Shell server \n Loaded: loaded (\/lib\/systemd\/system\/ssh.service; enabled; preset: enabled) \n Active: active (running) since [...] \n Docs: man:sshd(8) \n man:sshd_config(5) \n Main PID: 741 (sshd) \n Tasks: 1 (limit: 18876) \n Memory: 10.4M \n CPU: 12.778s \n CGroup: \/system.slice\/ssh.service \n └─741 \"sshd: \/usr\/sbin\/sshd -D [listener] 0 of 10-100 startups\" Wenn der ssh-Server nicht aktiviert sein sollte, können Sie den Server mit folgendem Befehl dauerhaft aktivieren:  sudo systemctl enable ssh . Überprüfen Sie anschließend, wie oben beschrieben, ob der Dienst aktiv ist. Wenn Sie die CODESYS Virtual Control for Linux SL verwenden möchten, muss außerdem folgende Software in einer aktuellen Version installiert sein: Python3 Docker oder Podman Eine Anleitung für die Installation eines Docker auf Debian finden Sie in Docker-Engine auf Debian installieren " }, 
{ "title" : "CODESYS Entwicklungsumgebung ", 
"url" : "_rtsl_preparation_linux.html#UUID-6cfdd13d-15e9-2ce9-6bfc-ddfaec59e7f5_section-idm234655602655537", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Vorbereitung \/ CODESYS Entwicklungsumgebung ", 
"snippet" : "Installieren Sie mit dem CODESYS Installer eine aktuelle Version des CODESYS Development System sowie des CODESYS -Package für die Steuerung, auf der Sie das Laufzeitsystem verwenden möchten. Sie benötigen mindestens die folgenden Packages: l CODESYS Control SL Deploy Tool CODESYS Control for <devic...", 
"body" : "Installieren Sie mit dem CODESYS Installer eine aktuelle Version des CODESYS Development System sowie des CODESYS -Package für die Steuerung, auf der Sie das Laufzeitsystem verwenden möchten. Sie benötigen mindestens die folgenden Packages: l CODESYS Control SL Deploy Tool CODESYS Control for <device>, beispielsweise CODESYS Control for Linux ARM . " }, 
{ "title" : "Package CODESYS Control for <device> SL in CODESYS installieren ", 
"url" : "_rtsl_preparation_linux.html#UUID-6cfdd13d-15e9-2ce9-6bfc-ddfaec59e7f5_section-idm43465561410290", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Vorbereitung \/ Package CODESYS Control for <device> SL in CODESYS installieren ", 
"snippet" : "Starten Sie das CODESYS Development System . Wählen Sie den Befehl Tools → CODESYS Installer . Es öffnet sich der Dialog CODESYS Installer . Klicken Sie unter Add-ons auf Durchsuchen . Wählen Sie das Package des Laufzeitsystem-Produkts aus. Das Package wird installiert: Laufzeitsystem-Package, Bibli...", 
"body" : "Starten Sie das CODESYS Development System . Wählen Sie den Befehl Tools → CODESYS Installer . Es öffnet sich der Dialog CODESYS Installer . Klicken Sie unter Add-ons auf Durchsuchen . Wählen Sie das Package des Laufzeitsystem-Produkts aus. Das Package wird installiert: Laufzeitsystem-Package, Bibliotheken, Gerätebeschreibungen und Beispielprojekte werden auf dem Entwicklungssystem abgelegt. Das Laufzeitsystem-Package steht je nach Produkt als Debian- oder IPK-Laufzeitsystemdatei im Ordner ..\\user\\<user name>\\CODESYS Control for <device> zur Verfügung. " }, 
{ "title" : "Betriebssystem installieren ", 
"url" : "_rtsl_linux_install_operating_system.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Vorbereitung \/ Betriebssystem installieren ", 
"snippet" : "Für die Installation von CODESYS Control for <device> SL auf Ihrem Gerät\/Hardware benötigen Sie ein Linux-Betriebssystem. Beachten Sie die herstellerspezifischen Anleitungen. Installieren Sie das Linux-Betriebssystem auf die Speicherkarte Ihres Geräts gemäß der Beschreibung auf der Homepage des Hers...", 
"body" : "Für die Installation von CODESYS Control for <device> SL auf Ihrem Gerät\/Hardware benötigen Sie ein Linux-Betriebssystem. Beachten Sie die herstellerspezifischen Anleitungen. Installieren Sie das Linux-Betriebssystem auf die Speicherkarte Ihres Geräts gemäß der Beschreibung auf der Homepage des Herstellers. Das Betriebssystem ist auf der Speicherkarte installiert Starten Sie das Gerät mit der Speicherkarte. Das Betriebssystem wird ausgeführt und ist funktionsbereit " }, 
{ "title" : "Gerätespezifische Einstellungen ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm4599163518809633054177648631", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Vorbereitung \/ Betriebssystem installieren \/ Gerätespezifische Einstellungen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "BeagleBone ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm43305417852438", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Vorbereitung \/ Betriebssystem installieren \/ Gerätespezifische Einstellungen \/ BeagleBone ", 
"snippet" : "Wenn der BeagleBone direkt über ein USB-Kabel an Ihr lokales System angeschlossen ist, ist die Default-IP-Adresse: 192.168.7.2 ....", 
"body" : "Wenn der BeagleBone direkt über ein USB-Kabel an Ihr lokales System angeschlossen ist, ist die Default-IP-Adresse: 192.168.7.2 . " }, 
{ "title" : "PFC100\/200 ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm43305417882662", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Vorbereitung \/ Betriebssystem installieren \/ Gerätespezifische Einstellungen \/ PFC100\/200 ", 
"snippet" : "Stellen Sie sicher, dass die WAGO-Steuerung mit Spannung versorgt und in Ihr Netzwerk eingebunden ist. Das Netzwerkkabel, das die Steuerung mit der CODESYS -Engineeringplattform verbindet, muss an der Buchse X1 eingesteckt sein. Die Buchse X2 wird für die Feldbusse verwendet. Wenn Sie einen Ethernet...", 
"body" : "Stellen Sie sicher, dass die WAGO-Steuerung mit Spannung versorgt und in Ihr Netzwerk eingebunden ist. Das Netzwerkkabel, das die Steuerung mit der CODESYS -Engineeringplattform verbindet, muss an der Buchse X1 eingesteckt sein. Die Buchse X2 wird für die Feldbusse verwendet. Wenn Sie einen Ethernet-Feldbus verwenden, müssen Sie die Ethernet-Schnittstellen der PFC100\/200 auf „Separated“ setzen. Geben Sie dazu die IP-Adresse des Geräts in Ihren Browser ein. Es erscheint die Verwaltungsseite „Web-based Management“ des Geräts. Wählen Sie den Menübefehl Networking → TCP-IP . Wenn Sie zur Eingabe von Benutzerdaten aufgefordert werden, geben Sie als Benutzernamen admin und als Passwort wago ein. Wählen Sie unter Switch Configuration die Option Separated und bestätigen Sie die Änderung mit Submit . Schließen Sie den Browser. Hinweise zum Web-based Management: Eine Änderung der aktiven Partition ist in der aktuellen Version von CODESYS Control for PFC100\/200 noch nicht möglich (Menüeintrag „Mass Storage“). Die Lizenzinformationen im Menüeintrag Information → Controller Details → License Information beziehen sich auf die vorinstallierte WAGO-PLC und nicht auf das CODESYS Control for PFC100\/200 . Die Einstellungen zur Firewall ( PLC Runtime und PLC WebVisu ) beziehen sich ebenfalls auf die von WAGO vorinstallierte PLC und nicht auf das CODESYS Control for PFC100\/200 . Wenn die Firewall für CODESYS Control for PFC100\/200 konfiguriert werden soll, können „User Filter“ für eine manuelle Konfiguration verwendet werden. Hinweise zum Netzwerkadapter: Bei ethernetbasierten Feldbussen nutzt das Laufzeitsystem automatisch die zweite Netzwerkschnittstelle („X2“ oder „br1“). Einstellungen im Ethernet-Adapter und EtherCAT-Konfigurator zur verwendeten Netzwerkschnittstelle werden überschrieben. " }, 
{ "title" : "Raspberry PI ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm43305417928746", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Vorbereitung \/ Betriebssystem installieren \/ Gerätespezifische Einstellungen \/ Raspberry PI ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Raspberry Pi konfigurieren ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm41652708964375", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Vorbereitung \/ Betriebssystem installieren \/ Gerätespezifische Einstellungen \/ Raspberry PI \/ Raspberry Pi konfigurieren ", 
"snippet" : "Führen Sie in einer Konsole oder per SSH (eventuell über das Tool Putty ) das Kommando sudo raspi-config aus. Hinweis: Ab Debian Version 8 („Jessie“) gibt es auch eine grafische Konfigurationsoberfläche mit den gleichen Einstellungen. Das Konfigurationstool startet. Wählen Sie den Befehl 1 Expand Fi...", 
"body" : "Führen Sie in einer Konsole oder per SSH (eventuell über das Tool Putty ) das Kommando sudo raspi-config aus. Hinweis: Ab Debian Version 8 („Jessie“) gibt es auch eine grafische Konfigurationsoberfläche mit den gleichen Einstellungen. Das Konfigurationstool startet. Wählen Sie den Befehl 1 Expand Filesystem . Optional: Wählen Sie den Befehl 8 Advanced Options und geben Sie dem Raspberry Pi einen eigenen Namen. Optional: Wählen Sie den Befehl 5 Enable Camera . Die Kamera ist betriebsbereit. Verlassen Sie das Konfigurationstool und führen Sie einen Neustart aus. " }, 
{ "title" : "Peripherieschnittstellen I²C, SPI und 1-Wire aktivieren ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm43305417928748", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Vorbereitung \/ Betriebssystem installieren \/ Gerätespezifische Einstellungen \/ Raspberry PI \/ Peripherieschnittstellen I²C, SPI und 1-Wire aktivieren ", 
"snippet" : "Editieren Sie die Datei \/boot\/config.txt mit einem Texteditor, beispielsweise mittels sudo nano \/boot\/config.txt . Beachten Sie die Zugriffsrechte. Überprüfen Sie Ihre Konfiguration und passen Sie sie gegebenenfalls an. Folgende Zeilen sind enthalten (und nicht mittels # auskommentiert): dtparam=i2c...", 
"body" : "Editieren Sie die Datei \/boot\/config.txt mit einem Texteditor, beispielsweise mittels sudo nano \/boot\/config.txt . Beachten Sie die Zugriffsrechte. Überprüfen Sie Ihre Konfiguration und passen Sie sie gegebenenfalls an. Folgende Zeilen sind enthalten (und nicht mittels # auskommentiert): dtparam=i2c_arm=on\ndtparam=spi=on\ndtoverlay=w1-gpio-pullup,pullup=1 Hinweis: I²C, SPI und 1-Wire sind optional. " }, 
{ "title" : "Kamera aktivieren ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm46610835857494", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Vorbereitung \/ Betriebssystem installieren \/ Gerätespezifische Einstellungen \/ Raspberry PI \/ Kamera aktivieren ", 
"snippet" : "Führen Sie in einer Konsole oder über SSH (beispielsweise über Tool Putty ) das Kommando sudo raspi-config aus. Wählen Sie den Befehl 5 Enable Camera . Führen Sie folgende Kommandos aus: sudo apt-get update sudo apt-get dist-upgrade sudo rpi-update git clone https:\/\/github.com\/silvanmelchior\/RPi_Cam...", 
"body" : "Führen Sie in einer Konsole oder über SSH (beispielsweise über Tool Putty ) das Kommando sudo raspi-config aus. Wählen Sie den Befehl 5 Enable Camera . Führen Sie folgende Kommandos aus: sudo apt-get update\nsudo apt-get dist-upgrade\nsudo rpi-update\ngit clone https:\/\/github.com\/silvanmelchior\/RPi_Cam_Web_Interface.git\ncd RPi_Cam_Web_Interface\nchmod u+x RPi_Cam_Web_Interface_Installer.sh\n.\/RPi_Cam_Web_Interface_Installer.sh install Starten Sie einen Webbrowser und öffnen Sie http:\/\/<network address> . Bei erfolgreicher Installation wird die Benutzeroberfläche von RPi Cam Control geladen und Sie können die Kamera verwenden. " }, 
{ "title" : "Verbindung herstellen ", 
"url" : "_rtsl_establish_connection_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Verbindung herstellen ", 
"snippet" : "Voraussetzung: Das Betriebssystem ist bereits auf der Steuerung installiert. Wenn dies nicht der Fall ist, befolgen Sie die Schritte im Kapitel Betriebssystem installieren. Die nachfolgende Anleitung beschreibt, wie Sie die Netzwerkadresse des Linux-Geräts ermitteln, um das Deploy Tool mit dem Gerät...", 
"body" : "Voraussetzung: Das Betriebssystem ist bereits auf der Steuerung installiert. Wenn dies nicht der Fall ist, befolgen Sie die Schritte im Kapitel Betriebssystem installieren. Die nachfolgende Anleitung beschreibt, wie Sie die Netzwerkadresse des Linux-Geräts ermitteln, um das Deploy Tool mit dem Gerät zu verbinden. " }, 
{ "title" : "Netzwerkadresse ermitteln ", 
"url" : "_rtsl_establish_connection_linux.html#UUID-8282f374-6dd3-23b6-eb03-311464e44f1b_section-idm43466295058734", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Verbindung herstellen \/ Netzwerkadresse ermitteln ", 
"snippet" : "Netzwerkadresse mit CODESYS über Netzwerk ermitteln Starten Sie CODESYS . Wählen Sie den Befehl Tools → Control SL ausrollen . Die Ansicht Kommunikation öffnet sich. Klicken Sie neben Port <Port> auf die Schaltfläche Durchsuchen . Der Dialog Verfügbare Geräte listet die IP-Adressen der im Netzwerk v...", 
"body" : "Netzwerkadresse mit CODESYS über Netzwerk ermitteln Starten Sie CODESYS . Wählen Sie den Befehl Tools → Control SL ausrollen . Die Ansicht Kommunikation öffnet sich. Klicken Sie neben Port <Port> auf die Schaltfläche Durchsuchen . Der Dialog Verfügbare Geräte listet die IP-Adressen der im Netzwerk verfügbaren Geräte auf. Identifizieren Sie Ihr Gerät. Netzwerkadresse mit dem Gerät ermitteln Voraussetzung: Ihr Gerät hat einen Anschluß für Tastatur, Maus und Monitor. Loggen Sie sich ein. Öffnen Sie eine Konsole und führen Sie den Befehl ip a s aus. Die Netzwerkadresse wird zurückgeliefert. Netzwerkadresse mit Windows über Netzwerk ermitteln Voraussetzung: Ihr Gerät hat im Netzwerk einen bekannten und eindeutigen Namen (beispielsweise “BeagleBoneBlack“). Öffnen Sie eine Windows-Eingabeaufforderung. Führen Sie das Kommando ping an den Gerätenamen (Default: BeagleBoneBlack) aus. Die Netzwerkadresse wird zurückgeliefert. Als nächsten Schritt installieren Sie das Laufzeitsystem auf der Steuerung " }, 
{ "title" : "Verbindung zum Zielsystem herstellen ", 
"url" : "_rtsl_establish_connection_linux.html#UUID-8282f374-6dd3-23b6-eb03-311464e44f1b_section-idm43466297829590", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Verbindung herstellen \/ Verbindung zum Zielsystem herstellen ", 
"snippet" : "Die Verbindung zum Zielsystem ist die Voraussetzung für das spätere Installieren von Images und Packages sowie für das Erstellen und Verwalten von Instanzen. Wählen Sie den Befehl Tools → Deploy Control SL . Das Objekt Deploy Control SL öffnet sich. Konfigurieren sie in der Registerkarte Kommunikati...", 
"body" : "Die Verbindung zum Zielsystem ist die Voraussetzung für das spätere Installieren von Images und Packages sowie für das Erstellen und Verwalten von Instanzen. Wählen Sie den Befehl Tools → Deploy Control SL . Das Objekt Deploy Control SL öffnet sich. Konfigurieren sie in der Registerkarte Kommunikation die Verbindungseinstellungen zum Zielgerät. Geben Sie die IP-Adresse des Zielsystems ein oder klicken Sie zunächst auf die Schaltfläche Durchsuchen , um alle im Netzwerk zur Verfügung stehenden IP-Adressen anzuzeigen. Anschließend geben Sie den Port an. Für das Einloggen auf dem Zielsystem werden folgende Methoden unterstützt: Zugangsdaten: Benutzername und Passwort Schlüsselbasierte Authentifizierung. Für weitere Informationen siehe Mit Public-Key-Authentifizierung verbinden" }, 
{ "title" : "Standardzugangsdaten der Geräte ", 
"url" : "_rtsl_establish_connection_linux.html#UUID-8282f374-6dd3-23b6-eb03-311464e44f1b_section-idm43466298221944", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Verbindung herstellen \/ Standardzugangsdaten der Geräte ", 
"snippet" : "In der Liste sehen Sie die Standardzugangsdaten. Bitte prüfen Sie bei Problemen die Zugangsdaten der Geräte auf der Homepage des Herstellers. Benutzer Passwort Raspberry PI pi raspberry BeagleBone root leer IOT2000 konfigurierte Anmeldedaten des Gerätes PFC100\/200 root wago PLCnext admin aufgedruckt...", 
"body" : "In der Liste sehen Sie die Standardzugangsdaten. Bitte prüfen Sie bei Problemen die Zugangsdaten der Geräte auf der Homepage des Herstellers. Benutzer Passwort Raspberry PI pi raspberry BeagleBone root leer IOT2000 konfigurierte Anmeldedaten des Gerätes PFC100\/200 root wago PLCnext admin aufgedruckt auf der Steuerung WAGO TP600 root wago emPC-A-iMX6 konfigurierte Anmeldedaten des Gerätes " }, 
{ "title" : "Laufzeitsystem auf Steuerung installieren ", 
"url" : "_rtsl_install_runtime_on_controller.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Laufzeitsystem auf Steuerung installieren ", 
"snippet" : "Voraussetzung: Der Befehl Tools → Control SL ausrollen wurde ausgeführt und die Verbindung zum Gerät ist hergestellt. Wenn dies nicht der Fall ist, befolgen Sie die Schritte im Kapitel Verbindung herstellen. Das Add-on für die gewünschte Steuerung (beispielsweise CODESYS Control for Linux ARM64 ) is...", 
"body" : "Voraussetzung: Der Befehl Tools → Control SL ausrollen wurde ausgeführt und die Verbindung zum Gerät ist hergestellt. Wenn dies nicht der Fall ist, befolgen Sie die Schritte im Kapitel Verbindung herstellen. Das Add-on für die gewünschte Steuerung (beispielsweise CODESYS Control for Linux ARM64 ) ist im CODESYS Development System installiert. " }, 
{ "title" : "Paketbasierte Steuerungen ", 
"url" : "_rtsl_install_runtime_on_controller.html#UUID-ccf57e50-e4fa-81ce-6f6c-813f0b8b1aca_section-idm234664620258912", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Laufzeitsystem auf Steuerung installieren \/ Paketbasierte Steuerungen ", 
"snippet" : "Die nachfolgenden Anleitungen beschreiben, wie Sie das Laufzeitsystem auf dem Linux-Gerät installieren. Öffnen Sie die Registerkarte Bereitstellung . Wählen Sie in der Auswahlliste Produkt das gewünschte Produkt aus. Wählen Sie in der Auswahlliste Version die gewünschte Version aus. Klicken Sie die ...", 
"body" : "Die nachfolgenden Anleitungen beschreiben, wie Sie das Laufzeitsystem auf dem Linux-Gerät installieren. Öffnen Sie die Registerkarte Bereitstellung . Wählen Sie in der Auswahlliste Produkt das gewünschte Produkt aus. Wählen Sie in der Auswahlliste Version die gewünschte Version aus. Klicken Sie die Schaltfläche Installieren . Das ausgewählte Laufzeitsystem wird auf dem Gerät installiert. Die Steuerung wird automatisch neu gestartet. Es ist kein manueller Neustart notwendig. Um ein Paket zu deinstallieren, gehen Sie folgendermaßen vor: Wählen Sie den entsprechenden Eintrag im Abschnitt Installierte Packages aus. Stoppen Sie die Steuerung, wenn sie läuft und klicken Sie auf die Schaltfläche . Klicken Sie im nachfolgendem Dialog auf Ja . Das Paket wird deinstalliert Überprüfen Sie die Installation anhand eines Beispielprojekts, das im CODESYS -Package enthalten ist. " }, 
{ "title" : "Containerisierte Steuerungen ", 
"url" : "_rtsl_install_runtime_on_controller.html#UUID-ccf57e50-e4fa-81ce-6f6c-813f0b8b1aca_section-idm234664621921259", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Laufzeitsystem auf Steuerung installieren \/ Containerisierte Steuerungen ", 
"snippet" : "Im Folgenden werden Ihnen die Schritte aufgezeigt, wie Sie Images und Instanzen verwalten....", 
"body" : "Im Folgenden werden Ihnen die Schritte aufgezeigt, wie Sie Images und Instanzen verwalten. " }, 
{ "title" : "Images verwalten ", 
"url" : "_rtsl_install_runtime_on_controller.html#UUID-ccf57e50-e4fa-81ce-6f6c-813f0b8b1aca_section-idm43466462476384", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Laufzeitsystem auf Steuerung installieren \/ Containerisierte Steuerungen \/ Images verwalten ", 
"snippet" : "Für die Konfiguration eines virtuellen Produkts (beispielsweise Runtime-Instanz oder Gateway-Instanz) muss ein entsprechendes Image auf dem Zielgerät vorhanden sein. Bei der Installation von CODESYS Virtual Control for Linux SL werden Images im Verzeichnis C:\\Users\\<user>\\CODESYS Virtual Control for...", 
"body" : "Für die Konfiguration eines virtuellen Produkts (beispielsweise Runtime-Instanz oder Gateway-Instanz) muss ein entsprechendes Image auf dem Zielgerät vorhanden sein. Bei der Installation von CODESYS Virtual Control for Linux SL werden Images im Verzeichnis C:\\Users\\<user>\\CODESYS Virtual Control for Linux SL\\Delivery\\ als Archiv mit der Endung .tar.gz abgelegt. Image installieren Öffnen Sie die Registerkarte Bereitstellung . Wählen Sie in der Auswahlliste Produkt das gewünschte virtuelle Produkt aus. Wählen Sie in der Auswahlliste Version die gewünschte Version. Klicken Sie auf die Schaltfläche Installieren . Das Image wird auf das Zielsystem übertragen und erscheint im Abschnitt Installierte Images . Im Gegensatz zu den nicht-virtuellen Produkten findet kein automatischer Start statt. Bei virtuellen Produkten muss zuerst in der Registerkarte Operation eine Instanz erstellt werden. Image vom Zielsystem löschen Selektieren Sie in der Registerkarte Bereitstellung im Bereich Images verwalten das entsprechende Image und klicken Sie die Schaltfläche und wählen den Befehl Löschen . Wenn ein Image von einer Instanz verwendet wird, kann es nicht gelöscht werden. " }, 
{ "title" : "Virtuelle Instanzen verwalten ", 
"url" : "_rtsl_install_runtime_on_controller.html#UUID-ccf57e50-e4fa-81ce-6f6c-813f0b8b1aca_section-idm43466462511166", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Laufzeitsystem auf Steuerung installieren \/ Containerisierte Steuerungen \/ Virtuelle Instanzen verwalten ", 
"snippet" : "Die Instanzen auf dem Zielsystem werden in der Registerkarte Operation verwaltet. Einige Werte der Konfiguration können nicht geändert werden. Für laufende Instanzen kann die Konfiguration nicht geändert werden. Eine neue Instanz anlegen und konfigurieren Klicken Sie auf die Schaltfläche . Der Dialo...", 
"body" : "Die Instanzen auf dem Zielsystem werden in der Registerkarte Operation verwaltet. Einige Werte der Konfiguration können nicht geändert werden. Für laufende Instanzen kann die Konfiguration nicht geändert werden. Eine neue Instanz anlegen und konfigurieren Klicken Sie auf die Schaltfläche . Der Dialog Neue Instanz hinzufügen öffnet sich. Geben Sie in Name einen eindeutigen Namen ein. Der Name darf nur aus Buchstaben und Zahlen und den Zeichen .-_ bestehen. Die Zeichen .-_ dürfen jedoch nicht am Anfang stehen. Optional: Wählen Sie in der Auwahlliste Filter den Typ des Images (beispielsweise Laufzeitsystem oder Gateway ) aus. Die Liste der verfügbaren Images reduziert sich auf Images des ausgewählten Typs. Selektieren Sie anschließend das entsprechende Image . Abschließend klicken Sie auf OK . Die neue Instanz wird im Abschnitt VPLCs angezeigt. Selektieren Sie die Instanz, um die neu angelegte Instanz zu konfigurieren. Die Einstellungen für die ausgewählte Instanz erscheinen rechts im Abschnitt Einstellungen . In diesem Abschnitt können Sie alle Einstellungen dieser Instanz sehen und bearbeiten. Für weitere Informationen siehe: Konfiguration Eine Instanz löschen Hinweis: Gestartete Instanzen können nicht gelöscht werden. Selektieren Sie die Instanz in der Registerkarte Operation . Klicken Sie auf die Schaltfläche und wählen Sie den Befehl Selektierte löschen . Die selektierte Instanz, die Konfiguration und das Bootprojekt der Instanz werden gelöscht. Der Befehl Bereinigen stoppt und löscht alle Instanzen, Konfigurationen und alle auf dem Zielgerät vorhandenen CODESYS -Images. " }, 
{ "title" : "Laufzeitsystem starten ", 
"url" : "_rtsl_start_runtime.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Laufzeitsystem starten ", 
"snippet" : "Hinweis : Für den Betrieb des Laufzeitsystems muss auf Ihrem PC eine gültige Lizenz installiert sein. Wenn dies nicht der Fall ist, startet die Steuerung zeitbegrenzt, jedoch mit vollem Funktionsumfang im Demobetrieb. Bei den Laufzeitsystemen handelt es sich um Gerätelizenzen. Sie aktivieren diese L...", 
"body" : "Hinweis : Für den Betrieb des Laufzeitsystems muss auf Ihrem PC eine gültige Lizenz installiert sein. Wenn dies nicht der Fall ist, startet die Steuerung zeitbegrenzt, jedoch mit vollem Funktionsumfang im Demobetrieb. Bei den Laufzeitsystemen handelt es sich um Gerätelizenzen. Sie aktivieren diese Lizenzen über den Lizenzmanager. Für weitere Informationen siehe: Produkte lizenzieren Wählen Sie den Befehl Tools → Deploy SL ausrollen . Die Registerkarten von Deploy Control SL öffnen sich. Wählen Sie die Registerkarte Operation und selektieren Sie den gewünschten Eintrag. Sie können nur einen Eintrag selektieren. Wählen Sie den Befehl Ausgewählte starten . Die Steuerung wird gestartet und die Listen werden aktualisiert und zeigen den neuen Status an. Um eine Gateway-Instanz in den CODESYS Automation Server einzubinden, kann die Gateway-Instanz im Maintenance Mode gestartet werden. Wenn Sie die Instanzen der CODESYS Virtual Control for Linux SL korrekt konfiguriert haben, können Sie nun eine Verbindung zu diesen Instanzen herstellen. Für weitere Informationen siehe Verbindung zu einer Instanz aufbauen. " }, 
{ "title" : "CODESYS -Applikation auf die Steuerung laden und starten ", 
"url" : "_rtsl_load_and_start_application.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ CODESYS -Applikation auf die Steuerung laden und starten ", 
"snippet" : "Hinweis für CODESYS Virtual Control for Linux SL Voraussetzung: Es existiert eine laufende Instanz eines \"Virtual Edge Gateways\". Installieren Sie hierfür ein aktuelles Image des CODESYS Virtual Edge Gateway for Linux , erstellen Sie eine neue Instanz und starten Sie diese. Für weitere Informationen...", 
"body" : "Hinweis für CODESYS Virtual Control for Linux SL Voraussetzung: Es existiert eine laufende Instanz eines \"Virtual Edge Gateways\". Installieren Sie hierfür ein aktuelles Image des CODESYS Virtual Edge Gateway for Linux , erstellen Sie eine neue Instanz und starten Sie diese. Für weitere Informationen siehe Laufzeitsystem auf Steuerung installieren - virtuelle Steuerung . Erstellen Sie in CODESYS ein Standardprojekt: Wählen Sie dazu den Befehl Datei → Neues Projekt . Wählen Sie im Dialog Neues Projekt die Vorlage Standardprojekt und geben Sie einen Namen und einen Ablageort ein. Wählen Sie dann im Dialog Standardprojekt die entsprechende Steuerung. Im Gerätebaum (Ansicht Geräte ) des neuen Projekts gibt es nun einen Eintrag für die Steuerung ( Device(...) ), darunter eine Applikation mit einem Programmbaustein ( PLC_PRG (PRG) und einer Task MainTask , die PLC_PRG aufruft). Programmieren Sie in PLC_PRG ein einfaches Programm, beispielsweise einen Zähler. PROGRAM PLC_PRG\nVAR\n iCount: INT;\nEND_VAR\n\niCount := iCount+1; Stellen Sie die Verbindung zur Steuerung her. Dazu verwenden Sie die Registerkarte Kommunikation des Geräteeditors. Sie können sie mit einem Doppelklick auf den Eintrag Device (...) im Gerätebaum öffnen. Das Gateway ist im Normalfall jetzt bereits aktiv. Wenn dies nicht der Fall ist, prüfen Sie den Status und starten Sie das Gateway gegebenenfalls explizit. Wählen Sie dann in der Registerkarte Kommunikation den Befehl Netzwerk durchsuchen . Der Dialog Gerät auswählen erscheint mit den gefundenen Geräten. Wenn Ihre Steuerung nicht gefunden wird, stellen Sie sicher, dass sie korrekt installiert und gestartet wurde. Selektieren Sie die gefundene Steuerung und bestätigen Sie mit OK . Wenn Ihre Steuerung nicht angezeigt wird, überprüfen Sie Folgendes: Deaktivieren Sie die Option Netzwerksuche nach Zielsystem-ID filtern im Menü Gerät → Optionen (Registerkarte Kommunikation ). Wenn Ihr Gerät nun angezeigt wird, haben Sie eine falsche TargetID . Möglicherweise wurde Ihre Komponente SysTargetOEM nicht korrekt geladen. Ist Ihr Gerät mit Ihrem Netzwerk verbunden? Standardmäßig wird mit Ihrem Gerät über UDP kommuniziert. Wenn Sie diese Kommunikationsmethode verwenden, muss sich Ihr Gerät im gleichen Sub-Netzwerk befinden wie Ihr Host. Beide Geräte benötigen die exakt gleich konfigurierte Netzwerkmaske. Sie können die Netzwerkeinstellungen bei den Meldungen des Laufzeitsystems beim Starten überprüfen. Sie sollten beispielsweise wie folgt lauten: 1287759127: Cmp=CmpBlkDrvUdp, Class=1, Error=0, Info=6, pszInfo=Network interface: <ipaddress>192.168.101.41<\/ipaddress> <subnetmask>255.255.252.0<\/subnetmask> CODESYS versucht sich auf diesem Zielsystem zu authentifizieren und einen Kommunikationskanal zu erhalten. Die Verbindung wird hergestellt. Wählen Sie den Befehl Online → Einloggen . Der Dialog zur Bestätigung des Downloads der Applikation öffnet sich. Führen Sie den Download durch und starten Sie die Applikation. Die Applikation wird auf Ihrem Gerät abgearbeitet. Überprüfen Sie im Programm PLC_PRG , ob der Zähler läuft. " }, 
{ "title" : "Steuerung lizenzieren ", 
"url" : "_rtsl_license_controller_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Steuerung lizenzieren ", 
"snippet" : "Anwendungsfälle für die Lizenzierung von CODESYS Control -Runtime-Produkten: Lokale Lizenzierung Die Lizenz, um das CODESYS Control -Produkt zu betreiben, befindet sich auf dem Gerät selbst. Netzwerklizenzierung Die Lizenz, um das CODESYS Control -Produkt zu betreiben, befindet sich auf einem Gerät ...", 
"body" : "Anwendungsfälle für die Lizenzierung von CODESYS Control -Runtime-Produkten: Lokale Lizenzierung Die Lizenz, um das CODESYS Control -Produkt zu betreiben, befindet sich auf dem Gerät selbst. Netzwerklizenzierung Die Lizenz, um das CODESYS Control -Produkt zu betreiben, befindet sich auf einem Gerät im Netzwerk. Mehrere Steuerungen können dieses zentrale Gerät kontaktieren, um eine CODESYS -Lizenz zu erhalten. Hierfür wird das Produkt CODESYS Network License Server benötigt. Die CODESYS Virtual Control SL kann aktuell nur mit Netzwerklizenzen lizensiert werden. Hierfür muss in der jeweiligen Instanz die IP-Adresse des Lizenzservers im Feld Lizenzserver konfiguriert werden. " }, 
{ "title" : "Lizenzen erwerben ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234389354567343", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Steuerung lizenzieren \/ Lizenzen erwerben ", 
"snippet" : "Lizenzen für die CODESYS Control -Produkte können im CODESYS Store International oder im CODESYS Store North America erworben werden....", 
"body" : "Lizenzen für die CODESYS Control -Produkte können im CODESYS Store International oder im CODESYS Store North America erworben werden. " }, 
{ "title" : "Lokale Lizenzierung ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm4588328499004833054120306755", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Steuerung lizenzieren \/ Lokale Lizenzierung ", 
"snippet" : "Die Lizenz kann auf einen USB-Dongle oder Softcontainer installiert werden. Bei der Verwendung des Softcontainers wird die Lizenz bei der Aktivierung an das Gerät gebunden und kann nur auf diesem Gerät aktiviert oder wiederhergestellt werden. Voraussetzungen: Das Entwicklungssystem mit CODESYS Devel...", 
"body" : "Die Lizenz kann auf einen USB-Dongle oder Softcontainer installiert werden. Bei der Verwendung des Softcontainers wird die Lizenz bei der Aktivierung an das Gerät gebunden und kann nur auf diesem Gerät aktiviert oder wiederhergestellt werden. Voraussetzungen: Das Entwicklungssystem mit CODESYS Development System verfügt über einen Internetzugang und ist mit dem Gerät verbunden. Öffnen Sie CODESYS . Erstellen Sie ein Standardprojekt. Aktualisieren Sie das Gerät im Gerätebaum. Öffnen Sie mit dem Befehl Tools → Lizenz-Manager den CODESYS Lizenzmanager. Wählen Sie im Wizard zunächst Gerät , dann je nach Gerät Dongle oder Softcontainer . Der Dialog Gerät auswählen öffnet sich. Wählen Sie das entsprechende Gerät aus. Der Dialog Lizenz-Manager öffnet sich. Als Container wird der Name des Softcontainers oder Dongles auf dem Gerät angezeigt. Im Fenster Produkte ist noch kein Eintrag für das entsprechende Gerät. Wählen Sie unten links die Aktion Lizenzen installieren . Der Wizard Lizenzen auf <Zielgerät> <Container-Bezeichnung> installieren - Operation auswählen startet. Wählen Sie die Option Lizenz aktivieren . Geben Sie die Ticket-ID ein und bestätigen Sie mit Weiter . Die Lizenz wird aktiviert. " }, 
{ "title" : "Netzwerklizenzierung ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234367072936383", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Steuerung lizenzieren \/ Netzwerklizenzierung ", 
"snippet" : "Das Produkt CODESYS Network License Server ermöglicht die Netzwerklizenzierung für CODESYS -Produkte, beispielsweise für Linux-basierte CODESYS Control SL Runtimes aus dem CODESYS Store International . Der CODESYS Network License Server basiert auf der WIBU CodeMeter-Runtime im Netzwerkmodus und bie...", 
"body" : "Das Produkt CODESYS Network License Server ermöglicht die Netzwerklizenzierung für CODESYS -Produkte, beispielsweise für Linux-basierte CODESYS Control SL Runtimes aus dem CODESYS Store International . Der CODESYS Network License Server basiert auf der WIBU CodeMeter-Runtime im Netzwerkmodus und bietet Unterstützung für das webbasierte Management-Framework \"Cockpit\" (siehe: https:\/\/cockpit-project.org\/ ). Um den Netzwerklizenzserver zu verwenden müssen Sie zuerst das Add-on CODESYS Network License Server über den CODESYS Installer installieren. Dann können Sie das Produkt über die Registerkarte Bereitstellung auf dem Gerät installieren. Für weitere Information siehe Registerkarte Bereitstellung . " }, 
{ "title" : "Besonderheiten der Netzwerklizenzierung ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234373994123211", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Steuerung lizenzieren \/ Netzwerklizenzierung \/ Besonderheiten der Netzwerklizenzierung ", 
"snippet" : "Der Befehl Installieren installiert den CODESYS Network License Server (inklusive WIBU CodeMeter Runtime) Wenn das Framework \"Cockpit\" noch nicht auf dem Zielsystem installiert ist, erscheint diese Meldung: Wenn das Framework \"Cockpit\" bereits auf dem Zielsystem installiert ist, werden lediglich die...", 
"body" : "Der Befehl Installieren installiert den CODESYS Network License Server (inklusive WIBU CodeMeter Runtime) Wenn das Framework \"Cockpit\" noch nicht auf dem Zielsystem installiert ist, erscheint diese Meldung: Wenn das Framework \"Cockpit\" bereits auf dem Zielsystem installiert ist, werden lediglich die CODESYS -Cockpit-Plugins zur Bedienung des CODESYS Network License Server installiert. Die Befehle Start und Stop sind deaktiviert, da der Dienst nicht gestoppt\/gestartet werden muss. Der Befehl Cockpit öffnen öffnet das webbasierte Management des Linuxgeräts im Standardbrowser. " }, 
{ "title" : "Aktivieren der Netzwerklizenz ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234373989651141", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Steuerung lizenzieren \/ Netzwerklizenzierung \/ Aktivieren der Netzwerklizenz ", 
"snippet" : "Um ein Lizenzticket auf dem CODESYS Network License Server zu aktivieren, gehen Sie folgendermaßen vor: Öffnen Sie mit dem Befehl Cockpit öffnen das webbasierte Management im Browser Benutzen Sie dazu den normalen Linux-Login. Wählen Sie die Befehle CODESYS WBM (1) → CODESYS Licensing (2). Kopieren ...", 
"body" : "Um ein Lizenzticket auf dem CODESYS Network License Server zu aktivieren, gehen Sie folgendermaßen vor: Öffnen Sie mit dem Befehl Cockpit öffnen das webbasierte Management im Browser Benutzen Sie dazu den normalen Linux-Login. Wählen Sie die Befehle CODESYS WBM (1) → CODESYS Licensing (2). Kopieren Sie die Seriennummer (1). Tragen Sie die Seriennummer im Feld Serialnumber (2) ein. Tragen Sie die Ticket-Nummer im Feld Ticket (3) ein. Klicken Sie auf die Schaltfläcne ACTIVATE TICKET Überprüfen Sie in der Übersicht am Ende der Seite, ob die gewünschten Artikel\/ProduktCodes (als Teil des Tickets) auf dem Netzwerklizenzserver installiert wurden. Standardmäßig erstellt das Package CODESYS Network License Server einen Lizenz-Container, in den Sie eine Lizenz installieren können. Wenn Sie einen neuen Container erstellen wollen, gehen Sie folgendermaßen vor: Kopieren Sie die Datei *.WibuCmLif vom CODESYS Network License Server auf Ihren Rechner (beispielsweise mithilfe eines SSH-Clients oder scp). Klicken Sie im webbasierten Management die Schaltfäche Durchsuchen in der Sektion Create new container und wählen die Datei aus, die Sie zuvor gespeichert haben. Klicken Sie die Schaltfläche CREATE Überprüfen Sie in der Übersicht am Ende der Seite, ob der neue Container erstellt wurde. Im Falle eines Fehlers können Sie auf der Seite Logs weitere Informationen finden. " }, 
{ "title" : "Verwenden der Netzwerklizenz ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234460444116218", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Steuerung lizenzieren \/ Netzwerklizenzierung \/ Verwenden der Netzwerklizenz ", 
"snippet" : "Damit die Steuerung den vorher konfigurierten Lizenzserver verwenden kann, muss dieser noch in die Konfiguration eingetragen werden. Dazu müssen in der Datei \/etc\/codesyscontrol\/CODESYSControl_User.cfg folgende Einstellungen in der Sektion [CmpCodeMeter] hinzugefügt werden: EnableNetLicenses=1 Licen...", 
"body" : "Damit die Steuerung den vorher konfigurierten Lizenzserver verwenden kann, muss dieser noch in die Konfiguration eingetragen werden. Dazu müssen in der Datei \/etc\/codesyscontrol\/CODESYSControl_User.cfg folgende Einstellungen in der Sektion [CmpCodeMeter] hinzugefügt werden: EnableNetLicenses=1\nLicenseServer.1=<IP1>\nLicenseServer.2=<IP2> " }, 
{ "title" : "Sichern und Wiederherstellen von CODESYS -Lizenzen ", 
"url" : "_rtsl_backup_restore_wibu.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Sichern und Wiederherstellen von CODESYS -Lizenzen ", 
"snippet" : "Diese Anweisungen gelten nicht für Produkte der Produktfamilie CODESYS Virtual Control SL l....", 
"body" : "Diese Anweisungen gelten nicht für Produkte der Produktfamilie CODESYS Virtual Control SL l. " }, 
{ "title" : "Lizenzen für Codemeter Embedded ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4622936815712034049201310732", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Sichern und Wiederherstellen von CODESYS -Lizenzen \/ Lizenzen für Codemeter Embedded ", 
"snippet" : "CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ Backup & Restore License...", 
"body" : "CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ Backup & Restore License " }, 
{ "title" : "Lizenz sichern ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4641146992569634049209836102", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Sichern und Wiederherstellen von CODESYS -Lizenzen \/ Lizenzen für Codemeter Embedded \/ Lizenz sichern ", 
"snippet" : "Stellen Sie eine Verbindung von CODESYS zu Ihrer Steuerung her. Wählen Sie im Gerätebaum Ihre Steuerung aus und öffnen Sie die Registerkarte Dateien . Klicken Sie im rechten Fenster auf das Aktualisierungssymbol . Die auf Ihrer Steuerung vorhandenen Dateien werden angezeigt. Wählen Sie im linken Fen...", 
"body" : "Stellen Sie eine Verbindung von CODESYS zu Ihrer Steuerung her. Wählen Sie im Gerätebaum Ihre Steuerung aus und öffnen Sie die Registerkarte Dateien . Klicken Sie im rechten Fenster auf das Aktualisierungssymbol . Die auf Ihrer Steuerung vorhandenen Dateien werden angezeigt. Wählen Sie im linken Fenster das Verzeichnis aus, in dem Sie die Sicherung speichern wollen. Wählen Sie im rechten Fenster das Verzeichnis cmact_licenses aus und klicken Sie auf die Schaltfläche . Eine Sicherungskopie Ihres Lizenzierungsverzeichnisses wird auf Ihrem Computer erstellt. Überprüfen Sie, ob die Sicherungskopie erfolgreich erstellt wurde. " }, 
{ "title" : "Lizenz wiederherstellen ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm451020213344483404921010438", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Sichern und Wiederherstellen von CODESYS -Lizenzen \/ Lizenzen für Codemeter Embedded \/ Lizenz wiederherstellen ", 
"snippet" : "Beachten Sie, dass bei der Ausführung der nachfolgenden Anweisungen im Schritt 6 ein Datenverlust möglich ist. Lesen Sie deshalb diese Anweisung genau durch. Stellen Sie eine Verbindung von CODESYS zu Ihrer Steuerung her. Wählen Sie im Gerätebaum Ihre Steuerung aus und öffnen Sie die Registerkarte D...", 
"body" : "Beachten Sie, dass bei der Ausführung der nachfolgenden Anweisungen im Schritt 6 ein Datenverlust möglich ist. Lesen Sie deshalb diese Anweisung genau durch. Stellen Sie eine Verbindung von CODESYS zu Ihrer Steuerung her. Wählen Sie im Gerätebaum Ihre Steuerung aus und öffnen Sie die Registerkarte Dateien . Klicken Sie im rechten Fenster auf das Aktualisierungssymbol . Die auf Ihrer Steuerung vorhandenen Dateien werden angezeigt. Wählen Sie im rechten Fenster das Zielverzeichnis aus. Dies muss das Verzeichnis auf oberster Ebene sein ( Speicherort : \/ ) Wählen Sie im linken Fenster die zuvor erstellte Sicherungskopie auf Ihrem Computer und klicken Sie auf die Schaltfläche . Die Sicherungskopie wird auf Ihre Steuerung kopiert. Wenn ein Verzeichnis mit demselben Namen existiert, werden Sie gefragt, ob Sie eventuell enthaltene Dateien überschreiben wollen. Achtung: Wenn Sie \"Ja\" wählen, werden alle Dateien mit dem selben Namen wie im Sicherungsverzeichnis aus dem vorhandenen Verzeichnis entfernt. Der gleiche Name bedeutet nicht unbedingt, dass der Inhalt identisch ist. Achten Sie also darauf, dass Sie nicht versehentlich Dateien überschreiben, die Sie benötigen. Starten Sie Ihre Steuerung neu, nachdem die Sicherungskopie erfolgreich übertragen wurde. " }, 
{ "title" : "Lizenzen für Codemeter Runtime ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4592433740225634049202010617", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Sichern und Wiederherstellen von CODESYS -Lizenzen \/ Lizenzen für Codemeter Runtime ", 
"snippet" : "CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control Win SL CODESYS Control RTE SL...", 
"body" : "CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control Win SL CODESYS Control RTE SL " }, 
{ "title" : "Lizenz sichern ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4582704430054434049230836628", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Sichern und Wiederherstellen von CODESYS -Lizenzen \/ Lizenzen für Codemeter Runtime \/ Lizenz sichern ", 
"snippet" : "Bei der Verwendung von CodeMeter Runtime ist es nicht notwendig, ein Backup zu erstellen....", 
"body" : "Bei der Verwendung von CodeMeter Runtime ist es nicht notwendig, ein Backup zu erstellen. " }, 
{ "title" : "Lizenz wiederherstellen ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4548752769854434049231197546", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Sichern und Wiederherstellen von CODESYS -Lizenzen \/ Lizenzen für Codemeter Runtime \/ Lizenz wiederherstellen ", 
"snippet" : "Restore License Erzeugen einer License-Request-Datei Öffnen Sie in CODESYS den Lizenz-Manager. Wählen Sie in den beiden folgenden Dialogen Gerät und Softcontainer aus. Stellen Sie eine Verbindung von CODESYS zu der Steuerung her, auf der Sie die Lizenz wiederherstellen wollen. Klicken Sie auf Lizenz...", 
"body" : " Restore License Erzeugen einer License-Request-Datei Öffnen Sie in CODESYS den Lizenz-Manager. Wählen Sie in den beiden folgenden Dialogen Gerät und Softcontainer aus. Stellen Sie eine Verbindung von CODESYS zu der Steuerung her, auf der Sie die Lizenz wiederherstellen wollen. Klicken Sie auf Lizenzen installieren , wählen Sie Lizenz anfordern und klicken Sie auf Weiter . Wenn das Feld Softwareanbieter leer ist, können Sie den Firmcode verwenden. Wie Sie den Firmcode abrufen können, ist im Abschnitt \"Firmencode abrufen\" beschrieben. Wählen Sie den Container aus, in den die Lizenz installiert werden soll, und den Ort, an dem die Lizenzanforderungsdatei auf Ihrem Computer gespeichert werden soll. Klicken Sie auf Fertigstellen . Download der License-Update-Datei Öffnen Sie das License Central WebDepot und geben Sie dort die Ticket-ID ein, die Sie wiederherstellen möchten. Klicken Sie auf Next . Klicken Sie auf Restore Licenses . Klicken Sie unten rechts auf File-based license transfer (wenn auf der Seite Direct license transfer steht, sind Sie bereits auf der richtigen Seite) Laden Sie die zuvor erstellte Lizenzanforderungsdatei hoch und klicken Sie auf Upload request and continue now . Klicken Sie auf Download license update file now und speichern Sie die Datei auf Ihrem Computer. License-Update installieren Öffnen Sie in CODESYS den Lizenz-Manager. Wählen Sie in den beiden folgenden Dialogen Gerät und Softcontainer aus. Stellen Sie eine Verbindung von CODESYS zu der Steuerung her, auf der Sie die Lizenz wiederherstellen wollen. Klicken Sie auf Lizenzen installieren , wählen Sie Lizenz installieren und klicken Sie auf Weiter . Wählen Sie den Container, in dem Sie die Lizenz installieren möchten, und wählen Sie die zuvor heruntergeladene Aktualisierungsdatei (Dateierweiterung .WibuCmRaU ). Klicken Sie auf Fertigstellen . Nach ein paar Sekunden erscheint die Lizenz in der Lizenzverwaltung. " }, 
{ "title" : "Firmcode abrufen ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4641146913656034049243306333", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Erste Schritte \/ Sichern und Wiederherstellen von CODESYS -Lizenzen \/ Lizenzen für Codemeter Runtime \/ Firmcode abrufen ", 
"snippet" : "Öffnen Sie das License Central WebDepot und geben Sie dort die Ticket-ID ein, die Sie wiederherstellen möchten. Klicken Sie auf Next . Klicken Sie auf Restore Licenses . Klicken Sie unten rechts auf File-based license transfer . Kopieren Sie den unter Punkt 1 angegebenen Firm-Code....", 
"body" : "Öffnen Sie das License Central WebDepot und geben Sie dort die Ticket-ID ein, die Sie wiederherstellen möchten. Klicken Sie auf Next . Klicken Sie auf Restore Licenses . Klicken Sie unten rechts auf File-based license transfer . Kopieren Sie den unter Punkt 1 angegebenen Firm-Code. " }, 
{ "title" : "Konfigurieren und Erweitern ", 
"url" : "_rtsl_configure_and_extend.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS Control Extension Package ", 
"url" : "_rtsl_extension.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Überblick ", 
"url" : "_rtsl_extension_overview.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Überblick ", 
"snippet" : "Das CODESYS Control Extension Package bietet viele verschiedene Möglichkeiten und Schnittstellen, eigene Programme an das Linux-Laufzeitsystem und die IEC-Applikation anzubinden. Dadurch können Sie beispielsweise die SPS kontrollieren, auf Ereignisse der SPS reagieren, oder die SPS oder die IEC-Appl...", 
"body" : "Das CODESYS Control Extension Package bietet viele verschiedene Möglichkeiten und Schnittstellen, eigene Programme an das Linux-Laufzeitsystem und die IEC-Applikation anzubinden. Dadurch können Sie beispielsweise die SPS kontrollieren, auf Ereignisse der SPS reagieren, oder die SPS oder die IEC-Applikation um eigene Funktionalität erweitern. Sehen Sie im Folgenden die wichtigsten Schnittstellen und Funktionalitäten im Überblick. Beachten Sie dabei: „Von außerhalb der SPS“ bedeutet jeweils trotzdem, dass man sich auf dem Linux-System befindet. Die Schnittstellen sind nicht auf einem anderen Gerät verfügbar, sondern nur auf dem Linux-System, aber eben außerhalb des Laufzeitsystem-Prozesses. Externe Ereignistask: Sie können den Ausführungszeitpunkt für eine IEC-Task selbst kontrollieren (von außerhalb der SPS). Eventmechanismus: Sie können außerhalb der SPS auf Ereignisse der IEC-Applikation (z. B. Start\/Stop\/Exception) reagieren. Zugriff auf die SPS-Shell: Sie können außerhalb der SPS auf die SPS-Shell zugreifen. START\/STOPP-Schalter: Sie können mit sehr einfachen Mitteln einen eigenen Start\/Stopp-Schalter (außerhalb der SPS) anbinden. Aufruf einer externen Funktion: Sie können sehr einfach eigene Funktionalität aufrufen, die außerhalb der SPS implementiert ist. Anbindung eigener EA’s: Sie können sehr einfach eigene (beispielsweise lokale) E\/A’s außerhalb der SPS anbinden. Extension SDK: Sie können sehr einfach eigene Funktionen in C-Code implementieren, die dann von der IEC-Applikation aus verwendet werden können. Retain-Daten im Shared Memory: Sie können Retain-Daten aus der Applikation über SHM in der Steuerung anbinden. Eine Übersicht über die getroffenen Sicherheitsmaßnahmen sowie sicherheitsrelevante Hinweise finden Sie in Sicherheitsmechanismen. Diese neuen Mechanismen und Schnittstellen basieren größtenteils auf Prozesstrennung auf Basis von Linux Standardresourcen (Dateien, Sockets, o. ä.). Es werden unter anderem „unix domain sockets“ verwendet, eine „Gegenstelle“ kann somit technologieunabhängig umgesetzt werden (Python, C usw.). Die Anbindung von eigenem C-Code (Extension SDK) ist eine Ausnahme, da hier kompilierter C-Code in Form einer dynamischen Laufzeitsystemkomponente (Shared Object) direkt zum CODESYS -Laufzeitsystem hinzugeladen und ausgeführt wird. Für weitere Informationen siehe: Extension SDK . Die Beispiele liegen im Installationsverzeichnis des CODESYS Control Extension Package . Standardmäßig ist dies: C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\Examples . " }, 
{ "title" : "Sicherheitsmechanismen ", 
"url" : "_rtsl_extension_security.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Sicherheitsmechanismen ", 
"snippet" : "Die Extension-API bietet umfangreiche Möglichkeiten, auf das Laufzeitsystem einzuwirken. Deshalb sind Sicherheitsmaßnahmen notwendig, die der Anwender beachten muss. Seit CODESYS Control Extension Package 4.4.0.0 wird mit der Installation des Packages die Gruppe codesysuser angelegt. Einige Funktion...", 
"body" : "Die Extension-API bietet umfangreiche Möglichkeiten, auf das Laufzeitsystem einzuwirken. Deshalb sind Sicherheitsmaßnahmen notwendig, die der Anwender beachten muss. Seit CODESYS Control Extension Package 4.4.0.0 wird mit der Installation des Packages die Gruppe codesysuser angelegt. Einige Funktionen der Extension-API setzen voraus, dass der Linux-Benutzer, der sie verwendet, Mitglied der Gruppe codesysuser ist. Sie können mit Administratorrechten einen Benutzer mit beispielsweise folgendem Befehl dieser Gruppe hinzufügen: $ sudo adduser $USER codesysuser Hintergrund dieser Vorgehensweise ist, dass die Mechanismen die Arbeitsverzeichnisse \/var\/run\/codesysextension\/ sowie \/var\/opt\/codesysextension\/ verwenden. Diese sind mit dem Recht 770 versehen und der Gruppe codesysuser zugeordnet. Damit wird erreicht, dass unbefugte Benutzer keinen Einfluss auf das Laufzeitsystem nehmen können. Alle Mitglieder der Gruppe codesysuser können auf das Laufzeitsystem einwirken. Die folgenden Mechanismen basieren auf einem Unix Domain Socket (UDS): Externe Ereignistask Eventmechanismus Zugriff auf die SPS-Shell Aufruf einer externen Funktion Anbindung eigener EA’s Es ist für den IEC-Programmierer notwendig, dass er bei diesen Mechanismen gegebenfalls Fehlercodes des jeweiligen Funktionsbausteins abfragt und geeignet reagiert (zum Beispiel: Verbindungsaufbau\/Verbindungsabbruch). Um einen Systemlastangriff zu verhindern, müssen die UDS-Gegenstellen ( U nix D omain S ockets) mindestens die gleiche Priorität oder eine höhere Priorität als die IEC-Task selbst haben. Die UDS-Gegenstellen sind die mitgelieferten Beispiele oder die vom Anwender erstellten Programme, die die Funktionen der Extension-API verwenden. Diese Priorität ist nicht die in der Taskkonfiguration von CODESYS angezeigte Priorität. Sie lässt sich auf dem Linux-System mit htop ermitteln. Es handelt sich dabei um eine Task, die denselben Namen hat wie die in CODESYS vergebene IEC-Task. Die SPS-Shell benötigt den „anonymen Benutzer“. Ist dieser aktiviert, kann nicht nachvollzogen werden, welcher Linux-Benutzer die SPS-Shell verwendet hat. Die neuen Schnittstellen des CODESYS Control Extension Package bieten durch die Prozesstrennung keine Möglichkeit der Benutzerauthentifizierung (aus Sicht des CODESYS Development System ). Es kann einem IEC-Anwender nicht ein entsprechender Linux-Anwender\/Benutzername zugeordnet werden. Daraus resultiert, dass bei der Sicherheitsbetrachtung der IEC-Applikation nicht nur die IEC-Anwender sondern auch die Linux-Anwender betrachtet und entsprechend administriert werden müssen! Es dürfen nur berechtigte Benutzer administrativen Zugang auf das Linux-System des Laufzeitsystems haben. Bei den Schnittstellen, die Prozesstrennung nutzen, kann nicht ausgeschlossen werden, dass Daten unverschlüsselt auf dem System weitergereicht werden. Das bedeutet, ein Angreifer mit administrativen Rechten auf dem System könnte diese mitschneiden. " }, 
{ "title" : "Externe Ereignistask ", 
"url" : "_rtsl_extension_external_event_task.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Externe Ereignistask ", 
"snippet" : "Über den Mechanismus „Externe Ereignistask“ kann eine Task über ein externes Ereignis (Event) angestoßen werden. Zur Prozesstrennung werden „Unix Domain Sockets“ verwendet. Entsprechend dem vom Benutzer gewählten Namen für das externe Ereignis liegt auf dem Zielsystem die dazugehörige Socket-Datei i...", 
"body" : "Über den Mechanismus „Externe Ereignistask“ kann eine Task über ein externes Ereignis (Event) angestoßen werden. Zur Prozesstrennung werden „Unix Domain Sockets“ verwendet. Entsprechend dem vom Benutzer gewählten Namen für das externe Ereignis liegt auf dem Zielsystem die dazugehörige Socket-Datei in: \/var\/run\/codesyscontrolapi\/eventtasks\/<EventName>.sock " }, 
{ "title" : "Anlegen einer Task vom Typ „Externes Ereignis“ ", 
"url" : "_rtsl_extension_external_event_task.html#UUID-3c54739a-5fc2-8bad-4ca3-572d189df031_fe5af4cc6c60dcbcc0a8646324da24c1_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Externe Ereignistask \/ Anlegen einer Task vom Typ „Externes Ereignis“ ", 
"snippet" : "Externes Ereignis anlegen Selektieren Sie im Gerätebaum Task Configuration und wählen Sie im Kontextmenü den Befehl Externe Ereignisse verwalten (1). Fügen Sie im Dialog Externe Ereignisse verwalten (2) das neue Event ein. Der Name darf keine Leerzeichen oder Sonderzeichen enthalten. → Konfigurieren...", 
"body" : "Externes Ereignis anlegen Selektieren Sie im Gerätebaum Task Configuration und wählen Sie im Kontextmenü den Befehl Externe Ereignisse verwalten (1). Fügen Sie im Dialog Externe Ereignisse verwalten (2) das neue Event ein. Der Name darf keine Leerzeichen oder Sonderzeichen enthalten. → Konfigurieren Sie eine Task als neue External Event Task: Wählen Sie in der Taskkonfiguration eine Task aus. Wählen Sie in der Auswahlliste bei Typ den neu verfügbaren Tasktyp Extern (3). Ordnen Sie der Task das gewünschte Externe Ereignis (4) zu. → Das mitgelieferte Beispielprojekt ExternalEventTask.project enthält die oben beschriebene Konfiguration. Die Task ist dem externen Event MYEVENT1 zugeordnet, die Datei \/var\/opt\/codesyscontrolapi\/eventtasks\/MYEVENT1.sock ist auf dem System angelegt. Mit dem Kommandozeilentool „socat“ können Sie sehr einfach diese Schnittstelle bedienen, beispielsweise mit folgendem Befehl: $ socat - UNIX-CLIENT:\/var\/opt\/codesyscontrolapi\/eventtasks\/MYEVENT1.sock Damit wird eine Socket-Verbindung im Terminalfenster aufgebaut und Sie können einzelne Nachrichten an den Socket schicken. Mit jeder Nachricht wird die in der SPS konfigurierte Task getriggert. Der Inhalt der Nachricht ist für das Auslösen des externen Ereignisses nicht relevant. Als Nachrichtenlänge ist 1 Byte spezifiziert. Verwendung der Schnittstelle nur als Mitglied der Linux-Benutzergruppe codesyscontrolapi JA Prozesstrennung JA " }, 
{ "title" : "Eventmechanismus ", 
"url" : "_rtsl_extension_event_mechanism.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Eventmechanismus ", 
"snippet" : "Das Laufzeitsystem verwendet „Events“, um Ereignisse wie den Start\/Stopp\/Reset der SPS, das Auftreten einer Exception etc. mitzuteilen. Mit dem „Eventmechanismus“ ist es möglich, eine Nachricht zu erhalten, sobald ein ausgewähltes Ereignis ausgelöst wurde. Folgende applikationsbezogene Events werden...", 
"body" : "Das Laufzeitsystem verwendet „Events“, um Ereignisse wie den Start\/Stopp\/Reset der SPS, das Auftreten einer Exception etc. mitzuteilen. Mit dem „Eventmechanismus“ ist es möglich, eine Nachricht zu erhalten, sobald ein ausgewähltes Ereignis ausgelöst wurde. Folgende applikationsbezogene Events werden weitergeleitet: EVT_StartDone EVT_StopDone EVT_ResetDone EVT_ExitDone EVT_AllBootprojectsLoaded EVT_CmpApp_Exception EVT_StateChanged EVT_CmpDevice_InteractiveLogin EVT_CmpMgr_LicenseState SysGraphic_EVT_OpenKeyboard SysGraphic_EVT_CloseKeyboard Das mitgelieferte Beispiel uds_events.py bietet die Klasse CODESYS_EventHandler , welche das Registrieren auf ein Ereignis implementiert. Diese Klasse benötigt die eventid sowie die componentid des zu registrierenden Ereignisses, welche in der Liste liEvents hinterlegt sind: liEvents = {\n \"CmpApp_EVT_StartDone\" : (0x00000002, 0x10000 + 2),\n \"CmpApp_EVT_StopDone\" : (0x00000002, 0x10000 + 4),\n \"CmpApp_EVT_ResetDone\" : (0x00000002, 0x10000 + 6),\n \"CmpApp_EVT_ExitDone\" : (0x00000002, 0x10000 + 15),\n \"CmpApp_EVT_AllBootprojectsLoaded\" : (0x00000002, 0x10000 + 25),\n \"CmpApp_EVT_CmpApp_Exception\" : (0x00000002, 0x00080000 + 28),\n \"CmpApp_EVT_StateChanged\" : (0x00000002,0x10000 + 43),\n \"CmpDevice_EVT_CmpDevice_InteractiveLogin\" : (0x0000000E, 0x00010000+ 1),\n \"CmpMgr_EVT_LicenseState\" : (0x00000001, 0x00010000 + 9),\n \"SysGraphic_EVT_OpenKeyboard\" : (0x00000142, 0x00010000 + 1),\n \"SysGraphic_EVT_CloseKeyboard\" : (0x00000142, 0x00010000 + 2,\n} Außerdem muss eine Callback-Funktion angegeben werden, die beim Eintreffen des Ereignisses aufgerufen wird: def callbackfunction_start(componentid, eventid):\n print(\"Start event occured\") Innerhalb von Main wird wie folgt auf ein Ereignis registriert und die nötige Callback-Funktion angegeben: componentid, eventid = liEvents[\"CmpApp_EVT_StartDone\"]\nmyEventHandler_Start = CODESYS_EventHandler(componentid, eventid, callbackfunction_start)\nmyEventHandler_Start.start() Nun wird die Callback-Funktion callbackfunction_start aufgerufen, sobald das Laufzeitsystem in Start gewechselt hat. Der zugrundeliegende Mechanismus ist in der folgenden Abbildung gezeigt: Verwendung der Schnittstelle nur als Mitglied der Linux-Benutzergruppe codesysuser JA Prozesstrennung JA " }, 
{ "title" : "Zugriff auf die SPS-Shell ", 
"url" : "_rtsl_extension_accessing_plc_shell.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Zugriff auf die SPS-Shell ", 
"snippet" : "Die Extension-API ermöglicht den externen Zugriff auf die SPS-Shell. Für diese Funktion wird ein „Unix Domain Socket“ verwendet, den das Laufzeitsystem verwendet, um eintreffende Befehle entgegenzunehmen und die entsprechende Antwort zu senden. Die dazugehörige Socket-Datei ist \/var\/opt\/codesyscontr...", 
"body" : "Die Extension-API ermöglicht den externen Zugriff auf die SPS-Shell. Für diese Funktion wird ein „Unix Domain Socket“ verwendet, den das Laufzeitsystem verwendet, um eintreffende Befehle entgegenzunehmen und die entsprechende Antwort zu senden. Die dazugehörige Socket-Datei ist \/var\/opt\/codesyscontrolapi\/plcshell.sock . Für diese Funktion muss das Laufzeitsystem den „Anonymen Benutzer“ aktiviert haben. Das Erlauben eines anonymen Einloggens erfolgt über die Kommunikationseinstellungen des Geräts im Dialog Kommunikationsrichtlinie ändern (1): Option Anonymes Einloggen erlauben (2). " }, 
{ "title" : "Beispiele ", 
"url" : "_rtsl_extension_accessing_plc_shell.html#UUID-f4776bb8-9dd5-0306-cfe0-2ef01425a6f9_e67b71746d20c0a8646363fbfe36_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Zugriff auf die SPS-Shell \/ Beispiele ", 
"snippet" : "Voraussetzungen Das Laufzeitsystem hat den „Anonymen Benutzer“ aktiviert. Sie haben sich auf das Linux-System eingeloggt. Ihr Benutzer ist der Gruppe codesyscontrolapi zugeordnet. Händischer Zugriff über das Terminal Führen Sie den folgenden Befehl aus: $ socat - UNIX-CLIENT:\/var\/opt\/codesyscontrola...", 
"body" : "Voraussetzungen Das Laufzeitsystem hat den „Anonymen Benutzer“ aktiviert. Sie haben sich auf das Linux-System eingeloggt. Ihr Benutzer ist der Gruppe codesyscontrolapi zugeordnet. Händischer Zugriff über das Terminal Führen Sie den folgenden Befehl aus: $ socat - UNIX-CLIENT:\/var\/opt\/codesyscontrolapi\/plcshell.sock Nun können Sie die Befehle der SPS-Shell in dem Terminal ausführen. Beispielskript Kopieren Sie plcshell.py aus den mitgelieferten Beispielen auf das Linux-System. Führen Sie das Skript aus. Das Python-Skript führt nacheinander eine Reihe von Kommandos über die SPS-Shell aus und demonstriert die Verwendung der SPS-Shell in Python. Für weitere Informationen siehe: Registerkarte <Gerätename> SPS-Shell Verwendung der Schnittstelle nur als Mitglied der Linux-Benutzergruppe codesyscontrolapi JA Prozesstrennung JA " }, 
{ "title" : "START\/STOPP-Schalter ", 
"url" : "_rtsl_extension_start_stop_switch.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ START\/STOPP-Schalter ", 
"snippet" : "Der START\/STOPP-Schalter bildet einen physikalischen Schalter ab, mit dem sich die SPS in den Zustand Start oder Stopp versetzen lässt. Dieser Mechanismus ist aktiv, wenn die Datei \/var\/opt\/codesyscontrolapi\/runstop.switch vorhanden ist. Achtung, anders als die anderen Funktionalitäten des Extension...", 
"body" : "Der START\/STOPP-Schalter bildet einen physikalischen Schalter ab, mit dem sich die SPS in den Zustand Start oder Stopp versetzen lässt. Dieser Mechanismus ist aktiv, wenn die Datei \/var\/opt\/codesyscontrolapi\/runstop.switch vorhanden ist. Achtung, anders als die anderen Funktionalitäten des Extension Packages, wird die Datei in \/var\/opt\/codesyscontrolapi\/ abgefragt. Diese Datei wird nicht vom Laufzeitsystem angelegt. Sie müssen die Datei anlegen, wenn Sie die START\/STOPP-Funktion nutzen möchten. Wenn der Inhalt von runstop.switch „ RUN “ ist, wird die SPS gestartet. Bei einem anderen Inhalt wird die SPS in Stopp versetzt. Die switch-Datei wird zyklisch ausgelesen. Die SPS kann zur Laufzeit gestoppt und gestartet werden. Wenn die Datei runstop.switch zur Laufzeit gelöscht wird, verliert die Komponente ihre Funktion und die SPS startet. Einschränkung: Die Linux-basierten SL-Produkte, die bereits einen START\/STOPP-Schalter in der Hardware verbaut haben, unterstützen diesen Mechanismus nicht. Dies sind u. a. folgende Produkte: CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for WAGO Touch Panel 600 Verwendung der Schnittstelle nur als Mitglied der Linux-Benutzergruppe codesyscontrolapi JA Prozesstrennung JA " }, 
{ "title" : "Aufruf einer externen Funktion ", 
"url" : "_rtsl_extension_calling_external_function.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Aufruf einer externen Funktion ", 
"snippet" : "Mit diesem Mechanismus lässt sich in einer IEC-Applikation über einen Unix Domain Socket eine externe Funktion aufrufen. Dadurch können eigene Funktionalitäten erstellt werden. Gleichzeitig wird eine Prozesstrennung erreicht. Als Schnittstelle in IEC wird der Funktionsbaustein EXTAPI.UDSExternalFunc...", 
"body" : "Mit diesem Mechanismus lässt sich in einer IEC-Applikation über einen Unix Domain Socket eine externe Funktion aufrufen. Dadurch können eigene Funktionalitäten erstellt werden. Gleichzeitig wird eine Prozesstrennung erreicht. Als Schnittstelle in IEC wird der Funktionsbaustein EXTAPI.UDSExternalFunction in der Bibliothek ExtensionAPI mitgeliefert. In Python dient dafür die Klasse ExternalFunctionBase , die im mitgelieferten Beispiel bereitgestellt wird. Auch die Verwendung des Mechanismus wird anhand dieses Beispiels erklärt. Das Beispiel enthält ein IEC-Projekt mit implementiertem Aufruf einer externen Funktion. Weiter enthält das Beispiel die Implementierung der aufgerufenen Funktion myExternalFunction in Python. Sie finden das Beispiel UDSExternalCallExample.project und das Python-Skript uds_external_function.py nach der Installation von CODESYS Control Extension Package im Verzeichnis C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\Examples\\ExternalCall . " }, 
{ "title" : "Beispiel, IEC-Applikation ", 
"url" : "_rtsl_extension_calling_external_function.html#UUID-a1f120f1-d7f7-9c1c-f2c1-f02f0f73aa23_c32c4ba6c484ae1c0a864634bce6538_id_da88391a8bc94ccdc0a864631f91843d", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Aufruf einer externen Funktion \/ Beispiel, IEC-Applikation ", 
"snippet" : "Im Beispielprojekt UDSExternalCallExample.project wird ein neuer Funktionsbaustein myExternalFunction erstellt. Dieser erweitert den FB EXTAPI.UDSExternalFunction um Ein- und Ausgänge vom Typ DINT . Auch andere Datentypen sind möglich. Zu Beginn muss der Name der in Python aufzurufenden Funktion übe...", 
"body" : "Im Beispielprojekt UDSExternalCallExample.project wird ein neuer Funktionsbaustein myExternalFunction erstellt. Dieser erweitert den FB EXTAPI.UDSExternalFunction um Ein- und Ausgänge vom Typ DINT . Auch andere Datentypen sind möglich. Zu Beginn muss der Name der in Python aufzurufenden Funktion übergeben werden. Dieser muss eindeutig sein. Mit folgendem Code werden die Eingänge der externen Funktion der Schnittstelle hinzugefügt: Result := THIS^.AddParameter('parameterIn1', 'DINT', TO_STRING(diIn1)); Mit folgendem Code wird dann die externe Funktion aufgerufen: Result := THIS^.Call(); Mit folgendem Code wird der Rückgabewert der in Python implementierten Funktion abgefragt: Result := THIS^.GetParameter('parameterOut', 'DINT', ADR(sValue)); Die Parameter sind vom Typ String . Entsprechend muss in den gewünschten Datentyp gecastet werden. " }, 
{ "title" : "Beispiel, Python-Skript ", 
"url" : "_rtsl_extension_calling_external_function.html#UUID-a1f120f1-d7f7-9c1c-f2c1-f02f0f73aa23_c32c4ba6c484ae1c0a864634bce6538_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Aufruf einer externen Funktion \/ Beispiel, Python-Skript ", 
"snippet" : "Die mitgelieferten Python-Beispiele für die Extension-API erfordern Python 3.0. Das mitgelieferte Beispiel uds_external_function.py bietet die Klasse ExternalFunctionBase , die die Unix Domain Socket-Kommunikation mit dem Laufzeitsystem für diese Funktionalität ermöglicht. Die im Beispiel implementi...", 
"body" : "Die mitgelieferten Python-Beispiele für die Extension-API erfordern Python 3.0. Das mitgelieferte Beispiel uds_external_function.py bietet die Klasse ExternalFunctionBase , die die Unix Domain Socket-Kommunikation mit dem Laufzeitsystem für diese Funktionalität ermöglicht. Die im Beispiel implementierte Klasse myExternalFunction erweitert die Klasse ExternalFunctionBase . Notwendig ist die Funktion Call() , die von dem Mechanismus aus IEC aufgerufen wird. Ein- und Ausgabeparameter werden in Form von Tupeln von Strings übergeben. Beispiel: {'parameterIn1': ('DINT', '11'), 'parameterIn2': ('DINT', '22')} Im Beispiel implementiert die Call() -Funktion ein einfaches Addieren der zwei Eingangsparameter: def Call(self, dictParams):\n in1 = int(dictParams['parameterIn1'][1])\n in2 = int(dictParams['parameterIn2'][1])\n\n dictRetParams = {}\n dictRetParams['parameterOut'] = 'DINT', in1 + in2\n\n return dictRetParams Kopieren Sie das Skript uds_external_function.py , das nach der Installation von CODESYS Control Extension Package im Verzeichnis C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\Examples\\ExternalCall liegt, auf das Zielgerät. Starten Sie das Skript uds_external_function.py . Anschließend starten Sie in CODESYS das Beispielprojekt UDSExternalCallExample.project Sie sehen, dass das Projekt die Funktion myExternalFunction() des Python-Skripts aufruft und die zwei Eingabeparameter addiert werden. Verwendung der Schnittstelle nur als Mitglied der Linux-Benutzergruppe codesysuser JA Prozesstrennung JA " }, 
{ "title" : "Anbindung eigener EA’s ", 
"url" : "_rtsl_extension_connecting_user_ios.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Anbindung eigener EA’s ", 
"snippet" : "Mit dieser Funktionalität lassen sich lokale E\/As an eine Steuerung anbinden und aus der IEC-Applikation verwenden....", 
"body" : "Mit dieser Funktionalität lassen sich lokale E\/As an eine Steuerung anbinden und aus der IEC-Applikation verwenden. " }, 
{ "title" : "Editieren der Gerätebeschreibung ", 
"url" : "_rtsl_extension_connecting_user_ios.html#UUID-13dba825-3390-b677-ab9e-c88d5217ab74_a82230b6c3b57c1c0a86463472f7ec5_id_f93f1df46d57d55ac0a864632a96c684", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Anbindung eigener EA’s \/ Editieren der Gerätebeschreibung ", 
"snippet" : "In dem mitgelieferten Beispiel UDSIoDrvExample.project werden mit der Gerätebeschreibung zwei Ein- und Ausgänge erstellt, die über den Unix Domain Socket angebunden werden. Sie finden das Beispiel im Installationsverzeichnis von CODESYS im Unterverzeichnis CODESYS Control SL Extension Package\\<versi...", 
"body" : "In dem mitgelieferten Beispiel UDSIoDrvExample.project werden mit der Gerätebeschreibung zwei Ein- und Ausgänge erstellt, die über den Unix Domain Socket angebunden werden. Sie finden das Beispiel im Installationsverzeichnis von CODESYS im Unterverzeichnis CODESYS Control SL Extension Package\\<version>\\Examples\\ExternalIoDrv . Um eigene Eingänge und Ausgänge zu definieren, muss die Gerätebeschreibungsdatei SocketUnixIOTemplate.devdesc.xml angepasst werden. Für jeden der Eingänge und Ausgänge muss ein xml-Element Parameter definiert werden. Die ParameterId muss hier innerhalb der Gerätebeschreibungsdatei eindeutig sein. Wir empfehlen einfach aufsteigend lückenlos zu nummerieren (1000, 1001, 1002 usw.) Eingänge sind ab 1000 zu nummerieren, Ausgänge ab 2000. Wenn die Gerätebeschreibung anpasst wird, muss sie erneut in das Geräterepository installiert werden, damit sie im Projekt verfügbar ist. <Parameter ParameterId=\"1000\" type=\"std:DWORD\">\n <Attributes channel=\"input\"\/>\n <Default\/>\n <Name name=\"local:in1\">\/Namne>\n<\/Parameter> Name Beschreibung ParameterId Eindeutige ID, über die der Eingang\/Ausgang aufgerufen wird type Definition der Breite des Eingangs\/Ausgangs. Sie erfolgt über die Angabe eines entsprechend breiten Datentyps wie std:BYTE , std:WORD , std:DWORD , std:LWORD . Auch andere einfache Datentypen sind zulässig. Attributes channel input oder output Name name Name für den dazugehörigen Eingang\/Ausgang Außerdem muss die Geräte-ID vergeben werden, die in <DeviceIdentification> definiert wird. Dafür ist der Bereich 0x0001 8000 bis 0x0001 80FF vorgesehen, um Kollisionen mit bestehenden Gräten zu vermeiden. Die Gerätebeschreibung sowie auch der darunter liegende E\/A-Treiber sollen nicht mehrfach unter einer SPS instanziiert werden, da die Reihenfolge der Module nicht festgelegt ist. Dies kann dazu führen, dass der E\/A-Treiber die Zuordnung nicht sicherstellen kann. " }, 
{ "title" : "Python-Beispiel ", 
"url" : "_rtsl_extension_connecting_user_ios.html#UUID-13dba825-3390-b677-ab9e-c88d5217ab74_a82230b6c3b57c1c0a86463472f7ec5_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Anbindung eigener EA’s \/ Python-Beispiel ", 
"snippet" : "Im Python-Beispiel uds_io_driver.py werden die Ausgänge entgegengenommen und die Eingänge des Geräts geschrieben. Eingangsparameter (IEC-Ausgänge) werden als Tupel von Strings ( paramType , paramValue) mit der Parameter-ID der Gerätebeschreibung als Index übergeben. Der Treiber kann die Datentypen U...", 
"body" : "Im Python-Beispiel uds_io_driver.py werden die Ausgänge entgegengenommen und die Eingänge des Geräts geschrieben. Eingangsparameter (IEC-Ausgänge) werden als Tupel von Strings ( paramType , paramValue) mit der Parameter-ID der Gerätebeschreibung als Index übergeben. Der Treiber kann die Datentypen USINT , UINT , UDINT , ULINT handhaben. Andere Datentypen müssen in einen passenden Datentyp gecastet werden. Beispiel: ( '2000': ('UDINT', '11'), '2001': ('UDINT', '22')} . Die Ausgangsparameter sind im gleichen Format. Auch für die Gegenstelle ist ein „Output“\/Ausgangsparameter trotzdem ein Ausgangswert, der von der IEC-Applikation „nach außen“ hin transportiert werden soll (beispielsweise auf reale GPIOs hinausgeschrieben). Die im Beispiel implementierte Klasse UDS_IODriver_0 erweitert die Klasse ExternalFunctionBase . Der Name der Klasse leitet sich aus UDS_IODriver_ gefolgt vom Instanzindex in aufsteigender Reihenfolge ab. Notwendig ist die Funktion Call() , die von dem Mechanismus aus IEC aufgerufen wird. Hier können nun die IEC-Ausgänge ausgewertet und IEC-Eingänge übergeben werden. Verwendung der Schnittstelle nur als Mitglied der Linux-Benutzergruppe codesysuser JA Prozesstrennung JA " }, 
{ "title" : "Retain-Daten im Shared Memory ", 
"url" : "_rtsl_extension_retains_in_shared_memory.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Retain-Daten im Shared Memory ", 
"snippet" : "Einige Produkte beinhalten (aufgrund fehlender allgemeingültiger Speichermöglichkeiten) keine automatische Anbindung von Retain-Daten aus der Applikation in der Steuerung. Es gibt aber einen existierenden Mechanismus im Laufzeitsystem durch eine Anbindung über ein Shared Memory (SHM), der durch ents...", 
"body" : "Einige Produkte beinhalten (aufgrund fehlender allgemeingültiger Speichermöglichkeiten) keine automatische Anbindung von Retain-Daten aus der Applikation in der Steuerung. Es gibt aber einen existierenden Mechanismus im Laufzeitsystem durch eine Anbindung über ein Shared Memory (SHM), der durch entsprechende Konfiguration dafür genutzt werden kann. Die Nutzung ist beispielsweise mit folgenden CODESYS Control SL-Produkten möglich: CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control for Raspberry Pi CODESYS Control for BeagleBone Versionshinweis: Die Mindestversion des CODESYS Control SL-Produkts ist V4.4.0.0 ( CODESYS Control Version 3.5.17.30) Grundsätzlich erfolgt die Aktivierung der \"Retains\" über SHM durch folgende Einstellungen in \/etc\/CODESYSControl_User.cfg auf dem Zielgerät: [CmpApp]\n RetainType.Applications=InSHM [CmpRetain]\n Retain.SHM.Size=0x1FFFF ; Total size of remanent memory in bytes\n Retain.SHM.Name=MyRetainMemory ; Optional (Default: \"RetainMemory\") Nach einem Neustart erzeugt das Laufzeitsystem dann eine Shared-Memory-Datei mit dem konfigurierten Namen unter \/dev\/shm . Durch Mappen dieser Datei kann der Speicher auf eine beliebige nicht-flüchtige Datei umgeleitet werden, beispielsweise durch folgende Kommandos: sudo touch \/dev\/shm\/MyRetainMemory\nsudo mount -o bind \/var\/opt\/MyRetainMemory \/dev\/shm\/MyRetainMemory Der Zugriff auf die Datei erfolgt zyklisch entsprechend der in der SPS-Applikation eingestellten Zykluszeit. Die SHM-Datei sollte deshalb auf keinen Fall auf eine Datei in einem Flash-basierten Dateisystem umgeleitet werden, da sonst die Gefahr besteht, dass der Speicher zerstört wird. " }, 
{ "title" : "Extension SDK ", 
"url" : "_rtsl_extension_extension_sdk.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Extension SDK ", 
"snippet" : "Mit dem Extension SDK können Sie eigene Funktionen in C implementieren und diese aus der IEC-Applikation aufrufen. Für diese Anbindung wird der C-Code in Form einer eigenen dynamischen Komponente ( shared object ) ins Laufzeitsystem eingebunden. Es gibt zwei Möglichkeiten, wie die Einbindung stattfi...", 
"body" : "Mit dem Extension SDK können Sie eigene Funktionen in C implementieren und diese aus der IEC-Applikation aufrufen. Für diese Anbindung wird der C-Code in Form einer eigenen dynamischen Komponente ( shared object ) ins Laufzeitsystem eingebunden. Es gibt zwei Möglichkeiten, wie die Einbindung stattfinden kann: Auf der Steuerung vorbereitet: Die dynamische Komponente ist bereits zum CODESYS -Laufzeitsystem hinzukonfiguriert (ein shared object ist auf dem Linux-System vorhanden und konfiguriert). Es wird dann nur noch die dazugehörige IEC-Bibliothek benötigt. In Form einer IEC-Bibliothek mit integrierter dynamischer Komponente. Auf dem Linux-System selbst muss nichts vorbereitet sein. Bei Verwendung der IEC-Bibliothek wird die dynamische Komponente automatisch zum CODESYS -Laufzeitsystem hinzugeladen und verwendet. In beiden Fällen muss der Anwender selbst in der Lage sein, ein shared object passend zur Architektur des Laufzeitsystems (x64\/ARM6\/ARM7\/AARCH64) zu erzeugen. Das Extension SDK unterstützt Sie beim Erzeugen einer solchen dynamischen Komponente ( shared object ). Nachfolgend wird beschrieben, wie Sie für beide Varianten die Bibliothek und die dynamische Komponente erzeugen. " }, 
{ "title" : "Entwicklungsumgebung ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_3742f1416db55357c0a864630d1ff3cd", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Extension SDK \/ Entwicklungsumgebung ", 
"snippet" : "Entwicklungsumgebung Öffnen Sie CODESYS und erstellen Sie eine neue Bibliothek. Setzen Sie den Titel der Bibliothek ( Projekt Informationen , Registerkarte Zusammenfassung ) und speichern Sie die Bibliothek unter demselben Namen. Fügen Sie die gewünschten Funktionen hinzu und markieren Sie diese als...", 
"body" : "Entwicklungsumgebung Öffnen Sie CODESYS und erstellen Sie eine neue Bibliothek. Setzen Sie den Titel der Bibliothek ( Projekt Informationen , Registerkarte Zusammenfassung ) und speichern Sie die Bibliothek unter demselben Namen. Fügen Sie die gewünschten Funktionen hinzu und markieren Sie diese als Externe Implementierung . Wählen Sie im Kontextmenü der Funktion im Projektnavigator den Befehl Eigenschaften . Wählen Sie auf Registerkarte Build und aktivieren Sie Externe Implementierung . Hinweis: Die Funktion muss „ _cext “ im Namen enthalten. Generieren Sie nun die *c und *m4 -Dateien: Wählen Sie den Befehl Erstellen → Laufzeitsystemdateien erzeugen Wählen Sie M4-Interface-Datei und C-Stub-Datei aus. Wählen Sie den Speicherort aus " }, 
{ "title" : "Linux ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_8bf074606db55357c0a864636bb48d02", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Extension SDK \/ Linux ", 
"snippet" : "Kopieren Sie das Extension-SDK auf ein Linux-System, auf dem die entsprechende Compile-Umgebung für das Zielsystem vorhanden ist. Das Extension-SDK finden Sie standardmäßig unter: C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\ExtensionSDK . Das Verzeichnis...", 
"body" : "Kopieren Sie das Extension-SDK auf ein Linux-System, auf dem die entsprechende Compile-Umgebung für das Zielsystem vorhanden ist. Das Extension-SDK finden Sie standardmäßig unter: C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\ExtensionSDK . Das Verzeichnis wird in den folgenden Schritten als <SDK DIR> bezeichnet. Erstellen Sie einen neuen Ordner, in dem Sie die C-Implementierung erstellen. Dieser Ordner ist im Folgendem <PROJECT DIR> . Navigieren Sie nach <PROJECT DIR> und führen Sie Folgendes aus: $ make -f <SDKDIR>\/makefile newproject Kopieren Sie die *c und *m4 -Dateien, die sie in der -Entwicklungsumgebung erstellt haben, in <PROJECT DIR> . Implementieren Sie die Funktionen in C. Erstellen Sie das Shared Object: $ make all Das shared object ist generiert und liegt in <PROJECT DIR>\/out\/libCmpMyTest.so . Damit haben Sie eine dynamische Komponente erzeugt, die jetzt aus der IEC-Applikation über Ihre IEC-Bibliothek aufgerufen werden kann. Details zum Buildprozess ( make ) finden Sie auch in den Makefiles und der README -Datei im Extension SDK. Entscheiden Sie sich jetzt für einen der beiden folgenden Wege die Komponente einzubinden: " }, 
{ "title" : "Einbinden der dynamischen Komponente ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_section-idm234821879525116", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Extension SDK \/ Einbinden der dynamischen Komponente ", 
"snippet" : "Sie haben folgende Optionen die Komponente einzubinden:...", 
"body" : "Sie haben folgende Optionen die Komponente einzubinden:\n " }, 
{ "title" : "Einbinden der dynamischen Komponente auf dem Zielgerät ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_e85c7db98c25e844c0a864634a8e2492", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Extension SDK \/ Einbinden der dynamischen Komponente \/ Einbinden der dynamischen Komponente auf dem Zielgerät ", 
"snippet" : "Mit dieser Methode können Sie das zuvor in C erstellte Shared Object zur Laufzeit in das Laufzeitsystem einbinden. Es sind dafür keine weiteren Systemrechte für den Anwender notwendig und die Bibliothek lässt sich mit gewohnten Methoden auf die Geräte ausrollen. Kopieren Sie das oben erzeugte Shared...", 
"body" : "Mit dieser Methode können Sie das zuvor in C erstellte Shared Object zur Laufzeit in das Laufzeitsystem einbinden. Es sind dafür keine weiteren Systemrechte für den Anwender notwendig und die Bibliothek lässt sich mit gewohnten Methoden auf die Geräte ausrollen. Kopieren Sie das oben erzeugte Shared Object auf das Runtime-System. Kopieren Sie das Shared Object in \/usr\/lib\/ oder ein gleichwertiges Bibliotheksverzeichnis, in dem Bibliotheken von dem System gefunden werden. Stoppen Sie das Laufzeitsystem (beispielsweise mit $ sudo \/etc\/init.d\/codesyscontrol stop ) Öffnen Sie \/etc\/CODESYSControl_User.cfg mit Administratorrechten: $ sudo nano \/etc\/CODESYSControl_User.cfg Fügen Sie in der Sektion [ComponentManager] die erstellten Shared Objects hinzu: [ComponentManager]\nComponent.1=CmpFirstTest\nComponent.2=CmpSomeOtherComponent\n... Hinweis: Die Nummer ist eine fortlaufende Nummer, die nicht mit bestehenden Komponenten kollidieren darf. Starten Sie das Laufzeitsystems: $ sudo \/etc\/init.d\/codesyscontrol start Sie können nun prüfen, ob die Komponente geladen worden ist: $ cat \/tmp\/codesyscontrol.log " }, 
{ "title" : "Einbinden der dynamischen Komponente in der IEC Bibliothek ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_4cf431216db55357c0a86463621d9489", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Extension SDK \/ Einbinden der dynamischen Komponente \/ Einbinden der dynamischen Komponente in der IEC Bibliothek ", 
"snippet" : "Fügen Sie der IEC-Bibliothek mit Hilfe der Funktionalität „C-Code Integration“ die dynamische Komponente hinzu. Sehen Sie dazu die allgemeine Hilfe C-Code-Integration . Öffnen Sie die IEC Bibliothek mit . Fügen Sie in den POUs ein Objekt C-implementierte Bibliothek hinzu. Fügen Sie in diesem Objekt ...", 
"body" : "Fügen Sie der IEC-Bibliothek mit Hilfe der Funktionalität „C-Code Integration“ die dynamische Komponente hinzu. Sehen Sie dazu die allgemeine Hilfe C-Code-Integration . Öffnen Sie die IEC Bibliothek mit . Fügen Sie in den POUs ein Objekt C-implementierte Bibliothek hinzu. Fügen Sie in diesem Objekt eine Objektdatei für Geräte hinzu: Wählen Sie die vorher gebaute dynamische Komponente (Datei) aus und fügen Sie diese hinzu. Geben Sie einen passenden Komponentennamen ein. Wählen Sie das passende Gerät aus. Jetzt wird bei Verwendung dieser Bibliothek mit dem ausgewählten Gerät automatisch die dynamische Komponente zum Laufzeitsystem hinzugefügt und kann über die Bausteine der Bibliothek aufgerufen werden. " }, 
{ "title" : "Weiteres ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Extension Package \/ Extension SDK \/ Weiteres ", 
"snippet" : "Einschränkungen: Mit dem Extension SDK kann nur C-Code eingebunden werden. Der C-Code kann nicht mit Hilfe eines Debuggers (beispielsweise mit dem -Programmiersystem) untersucht \/ gedebuggt werden. Der C-Code kann nicht mit dem Laufzeitsystem oder der IEC-Applikation „interagieren“. Das bedeutet: Au...", 
"body" : "Einschränkungen: Mit dem Extension SDK kann nur C-Code eingebunden werden. Der C-Code kann nicht mit Hilfe eines Debuggers (beispielsweise mit dem -Programmiersystem) untersucht \/ gedebuggt werden. Der C-Code kann nicht mit dem Laufzeitsystem oder der IEC-Applikation „interagieren“. Das bedeutet: Automatische Zugriffe auf Variablen der IEC-Applikation sind nicht möglich. Zugriffe auf Funktionalität des Laufzeitsystems sind nicht möglich. Zugriffe auf Variablen der IEC-Applikation sind aber natürlich durch Übergabe an eine in C-Code implementierte Funktion by reference möglich (beispielsweise per POINTER ). Verwendung der Schnittstelle nur als Mitglied der Linux-Benutzergruppe codesysuser NEIN Prozesstrennung NEIN " }, 
{ "title" : "Produktspezifische Konfiguration ", 
"url" : "_rtsl_product_configuration_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Beaglebone ", 
"url" : "_rtsl_linux_beaglebone.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Beaglebone ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CAN\/Serial Capes konfigurieren ", 
"url" : "_rtsl_linux_rbp_can_capes.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Beaglebone \/ CAN\/Serial Capes konfigurieren ", 
"snippet" : "Für den BeagleBone Black stehen Ihnen verschiedene Capes (Erweiterungsplatinen) zur Verfügung, um den Funktionsumfang zu erweitern. Ein Cape wird auf die Erweiterungsschnittstelle des BeagleBone Black aufgesteckt und stellt selbst wieder eine Erweiterungsschnittstelle zur Verfügung. Ein BeagleBone B...", 
"body" : "Für den BeagleBone Black stehen Ihnen verschiedene Capes (Erweiterungsplatinen) zur Verfügung, um den Funktionsumfang zu erweitern. Ein Cape wird auf die Erweiterungsschnittstelle des BeagleBone Black aufgesteckt und stellt selbst wieder eine Erweiterungsschnittstelle zur Verfügung. Ein BeagleBone Black kann um maximal 4 Capes erweitert werden. Dieses Kapitel beschreibt allgemein die Konfiguration eines BeagleBone Black , der um ein CAN Cape erweitert wird. Voraussetzung für die Erweiterung mit Capes ist eine Kernel-Version 4.1. Für andere Kernel-Versionen können die Beschreibungen leicht abweichen. Sie können die Kernel-Version (zum Beispiel über SSH angeschlossen) über folgenden Kommandozeilenbefehl ermitteln: uname -a uname -r " }, 
{ "title" : "Montieren des Capes ", 
"url" : "_rtsl_linux_rbp_installing_capes.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Beaglebone \/ CAN\/Serial Capes konfigurieren \/ Montieren des Capes ", 
"snippet" : "Montieren Sie das passende Cape, wie im Benutzerhandbuch des Capes beschrieben, auf dem BeagleBone Black . Versorgen Sie den BeagleBone Black mit Strom. Prüfen Sie die Verbindung mit dem Befehl: cat \/sys\/devices\/platform\/bone_capemgr\/slots Sie erhalten zum Beispiel folgende Ausgabe: Mon 0: P---L- 0 ...", 
"body" : "Montieren Sie das passende Cape, wie im Benutzerhandbuch des Capes beschrieben, auf dem BeagleBone Black . Versorgen Sie den BeagleBone Black mit Strom. Prüfen Sie die Verbindung mit dem Befehl: cat \/sys\/devices\/platform\/bone_capemgr\/slots Sie erhalten zum Beispiel folgende Ausgabe: Mon\n0: P---L- 0 cape-CBB-Serial,r01,Logic Supply,cape-CBB-Serial\n1: PF---- -1\n2: PF---- -1\n3: PF---- -1 Alternativ können Sie die Kernel-Ausgabe prüfen mit: dmesg | grep cape Die Ausgabe sollte wie folgt aussehen: ...\n\n[3.719868] bone_capemgr bone_capemgr: Baseboard: 'A335BNLT,000B,1614BBBK0256'\n[3.719904] bone_capemgr bone_capemgr: compatible-baseboard=ti,beaglebone-black - #slots=4\n[3.762237] bone_capemgr bone_capemgr: slot #0: 'cape-CBB-Serial,r01,Logic Supply,cape-CBB-Serial'\n[3.818178] bone_capemgr bone_capemgr: slot #1: No cape found\n[3.878171] bone_capemgr bone_capemgr: slot #2: No cape found\n[3.938165] bone_capemgr bone_capemgr: slot #3: No cape found\n[3.944194] bone_capemgr bone_capemgr: initialized OK.\n[3.963568] bone_capemgr bone_capemgr: slot #0: dtbo 'cape-CBB-Serial-r01.dtbo' loaded; overlay id #0\n\n... Diese Ausgabe zeigt an, dass ein Cape gefunden wurde und ein entsprechendes DeviceTree Overlay geladen wurde. " }, 
{ "title" : "CAN-Schnittstellen konfigurieren und testen ", 
"url" : "_rtsl_linux_bbb_configuring_can.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Beaglebone \/ CAN\/Serial Capes konfigurieren \/ CAN-Schnittstellen konfigurieren und testen ", 
"snippet" : "CAN testen Wenn Sie den CAN direkt über die Kommandozeile testen wollen, können Sie das Debian-Package can-utils verwenden: Installieren Sie das Debian-Package: sudo apt-get install can-utils Senden Sie eine CAN-Nachricht: cansend can0 5A1#ABCDABCD Empfangen Sie eine CAN-Nachricht: candump can0...", 
"body" : "CAN testen Wenn Sie den CAN direkt über die Kommandozeile testen wollen, können Sie das Debian-Package can-utils verwenden: Installieren Sie das Debian-Package: sudo apt-get install can-utils Senden Sie eine CAN-Nachricht: cansend can0 5A1#ABCDABCD Empfangen Sie eine CAN-Nachricht: candump can0 " }, 
{ "title" : "CAN konfigurieren ", 
"url" : "_rtsl_linux_bbb_configuring_can.html#UUID-efad06fa-f9d6-75e9-4a70-c5faf6598419_id_c96cb9d2e581efc0a86463263b6289-id-749f3d54d353c531c0a864631cb78ab4", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Beaglebone \/ CAN\/Serial Capes konfigurieren \/ CAN-Schnittstellen konfigurieren und testen \/ CAN konfigurieren ", 
"snippet" : "Wenn auf einem BeagleBone Black der DCAN0 verwendet wird, kollidiert dieser mit der I2C-2-Funktionalität. Deshalb wird typischerweise DCAN1 mit den Pins P9 pin24 (Rx) und P9 pin26 (Tx) verwendet. Voraussetzung: Sie sind über einen SSH-Client beispielsweise „ Putty “ mit dem BeagleBone Black verbunde...", 
"body" : "Wenn auf einem BeagleBone Black der DCAN0 verwendet wird, kollidiert dieser mit der I2C-2-Funktionalität. Deshalb wird typischerweise DCAN1 mit den Pins P9 pin24 (Rx) und P9 pin26 (Tx) verwendet. Voraussetzung: Sie sind über einen SSH-Client beispielsweise „ Putty “ mit dem BeagleBone Black verbunden. Wenn Sie den CAN manuell konfigurieren und testen wollen, geben Sie die folgenden Befehle ein: sudo modprobe can\nsudo modprobe can-dev\nsudo modprobe can-raw Mit dem folgenden Befehl wird das Kernel-Modul geladen (gegebenenfalls muss bei abweichender Hardware ein anderes Modul geladen werden): sudo modprobe c_can_platform Gegebenenfalls muss bei abweichender Hardware ein anderes Modul geladen werden. Tragen Sie alle Treiber, die für den Betrieb des CAN Capes benötigt werden, in der Datei „ ..\/etc\/modules “ ein. Beispiel: can\ncan-dev\ncan-raw Jetzt kann der Linux-Mechanismus socketcan verwendet werden. Dieser wird von CODESYS Control for BeagleBone standardmäßig unterstützt. Die Kernel-Module werden beim Start des BeagleBone Black automatisch geladen. Setzen Sie die Baudrate: sudo ip link set can0 up type can bitrate 125000 Aktivieren Sie die Schnittstelle: sudo ifconfig can0 up Die CAN-Schnittstelle ist konfiguriert. " }, 
{ "title" : "UARTs konfigurieren und testen ", 
"url" : "_rtsl_linux_rbp_configuring_uarts.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Beaglebone \/ CAN\/Serial Capes konfigurieren \/ UARTs konfigurieren und testen ", 
"snippet" : "UARTs testen Führen Sie das folgende Python-Snippet in einer interaktiven Python-Shell aus, oder legen Sie eine kleine Textdatei mit Erweiterung .py an und führen Sie diese mit dem Python-Interpreter aus: import serial import time uart2_file='\/dev\/ttyO2' baud=115200 ser = serial.Serial(uart2_file, b...", 
"body" : "UARTs testen Führen Sie das folgende Python-Snippet in einer interaktiven Python-Shell aus, oder legen Sie eine kleine Textdatei mit Erweiterung .py an und führen Sie diese mit dem Python-Interpreter aus: import serial\nimport time\nuart2_file='\/dev\/ttyO2'\nbaud=115200\nser = serial.Serial(uart2_file, baud)\nwhile True:\n ser.write(\"Testing\")\n time.sleep(1) UART2 mit Baudrate 115200 wird geöffnet und sendet jede Sekunde die Teichenfolge Testing . Jetzt können Sie ein serielles Kabel anschließen und die Ausgabe auf Ihrem PC prüfen (beispielsweise mit Putty). " }, 
{ "title" : "UARTs konfigurieren ", 
"url" : "_rtsl_linux_rbp_configuring_uarts.html#UUID-b5665400-7f51-ce43-e2ec-127a0725936a_id_be9f181d33627c4c0a8646366c6b2ff-id-4c119c87d346da4ec0a86463175a71c5", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Beaglebone \/ CAN\/Serial Capes konfigurieren \/ UARTs konfigurieren und testen \/ UARTs konfigurieren ", 
"snippet" : "Auf die seriellen Schnittstellen (auch UART genannte) auf diesem Cape (UART2 und UART4) kann über die Geräte \/dev\/ttyO2 und \/dev\/ttyO4 zugegriffen werden. Wenn Sie selbst außerhalb von CODESYS auf den seriellen Port zugreifen wollen, beachten Sie die entsprechende Linux-Dokumentation. Wenn Sie über ...", 
"body" : "Auf die seriellen Schnittstellen (auch UART genannte) auf diesem Cape (UART2 und UART4) kann über die Geräte \/dev\/ttyO2 und \/dev\/ttyO4 zugegriffen werden. Wenn Sie selbst außerhalb von CODESYS auf den seriellen Port zugreifen wollen, beachten Sie die entsprechende Linux-Dokumentation. Wenn Sie über CODESYS auf UARTs zugreifen wollen, tragen Sie die SysCom-Konfiguration in die Datei CODESYSControl.cfg ein: [SysCom]\nLinux.Devicefile=\/dev\/ttyO Es ist möglich, die Konfigurationseinträge zu indizieren. Beispiel: Linux.Devicefile.7=\/dev\/usb0 Damit wird \/dev\/usb0  auf COM7 gemappt. " }, 
{ "title" : "Bekannte Probleme ", 
"url" : "_rtsl_linux_bbb_problems.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Beaglebone \/ CAN\/Serial Capes konfigurieren \/ Bekannte Probleme ", 
"snippet" : "Serial-RS485 Beim Verwenden des RS485 des gegebenen CAN\/Serial Capes gibt es ein Problem mit der Verwendung des RS485-Transceivers. Da der Linux-Treiber nicht zwischen Sende- und Empfangsbetrieb hin- und herschalten kann, arbeiten Applikationen möglicherweise nicht wie erwartet. Detaillierte Beschre...", 
"body" : "Serial-RS485 Beim Verwenden des RS485 des gegebenen CAN\/Serial Capes gibt es ein Problem mit der Verwendung des RS485-Transceivers. Da der Linux-Treiber nicht zwischen Sende- und Empfangsbetrieb hin- und herschalten kann, arbeiten Applikationen möglicherweise nicht wie erwartet. Detaillierte Beschreibung: Der serielle Treiber des BeagleBone Black(OMAP) unterstützt nicht die für RS-485 nötige Kontrolle der Sende-\/Empfangsumschaltung (DE\/RE bzw. RTS). Stattdessen hat er einen RS485-Modus, der einen fest zugeordneten GPIO-Pin für die Kontrolle der DE\/RE Leitungen verwendet, und er hat eine modifizierte Struktur (serial_rs485 struct) verglichen mit dem seriellen Standardtreiber. Sie müssen ioctl auf der entsprechenden devtty-Datei verwenden, um den seriellen Treiber in RS-485-Betrieb zu bringen und ihm mitzuteilen, welchen Pin er verwenden muss. Außerdem müssen Sie sich um das Multiplexing des Pins im GPIO Mode kümmern. " }, 
{ "title" : "GPIOs und analoge Eingänge verwenden ", 
"url" : "_rtsl_linux_bbb_gpios_analog_inputs.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Beaglebone \/ GPIOs und analoge Eingänge verwenden ", 
"snippet" : "Dieses Kapitel beschreibt die Einschränkungen für die Verwendung des E\/A-Abbilds eines BeagleBone Black beim Zugriff auf die GPIOs und analogen Eingänge....", 
"body" : "Dieses Kapitel beschreibt die Einschränkungen für die Verwendung des E\/A-Abbilds eines BeagleBone Black beim Zugriff auf die GPIOs und analogen Eingänge. " }, 
{ "title" : "Zugriff-Pins auf P8\/P9 ", 
"url" : "_rtsl_linux_bbb_access_pins.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Beaglebone \/ GPIOs und analoge Eingänge verwenden \/ Zugriff-Pins auf P8\/P9 ", 
"snippet" : "Die Stecker P8 und P9 ermöglichen Zugriff auf viele GPIOs und die analogen Eingänge. Allerdings sind standardmäßig nicht alle frei verwendbar. Die Standard-“Slots“ HDMI und Linux Devicetree verwenden einige Pins für HDMI, eMMC und MCASP0. Die folgende Liste zeigt, welche Pins als GPIOs oder analoge ...", 
"body" : "Die Stecker P8 und P9 ermöglichen Zugriff auf viele GPIOs und die analogen Eingänge. Allerdings sind standardmäßig nicht alle frei verwendbar. Die Standard-“Slots“ HDMI und Linux Devicetree verwenden einige Pins für HDMI, eMMC und MCASP0. Die folgende Liste zeigt, welche Pins als GPIOs oder analoge Eingänge verwendet werden können und welche bereits vom System verwendet werden. Bitte beachten Sie die unterschiedlichen erlaubten Spannungen und Stromstärken für die Eingänge und Ausgänge. Stecker P9 Header-Pin Pin-Name CODESYS -Unterstützung Vom System verwendet P9_01 GND NO NO P9_02 GND NO NO P9_03 DC_3.3V NO NO P9_04 DC_3.3V NO NO P9_05 VDD_5V NO NO P9_06 VDD_5V NO NO P9_07 SYS_5V NO NO P9_08 SYS_5V NO NO P9_09 PWR_BUT NO NO P9_10 SYS_RESETn NO NO P9_11 UART4_RXD YES NO P9_12 GPIO1_28 YES NO P9_13 UART4_TXD YES NO P9_14 EHRPWM1A YES NO P9_15 GPIO1_16 YES NO P9_16 EHRPWM1B YES NO P9_17 I2C1_SCL NO PINMUX I 2 C P9_18 I2C1_SDA NO PINMUX I 2 C P9_19 I2C2_SCL NO PINMUX I 2 C P9_20 I2C2_SDA NO PINMUX I 2 C P9_21 UART2_TXD YES NO P9_22 UART2_RXD YES NO P9_23 GPIO1_17 YES NO P9_24 UART1_TXD YES NO P9_25 GPIO3_21 NO MCASPO P9_26 UART1_RXD YES NO P9_27 GPIO3_19 YES NO P9_28 SPI1_CS0 NO MCASP0 P9_29 SPI1_D0 NO MCASP0 P9_30 SPI1_D1 NO MCASP0 P9_31 SPI1_SCLK NO MCASP0 P9_32 VADC NO NO P9_33 AIN4 YES NO P9_34 AGND NO NO P9_35 AIN6 YES NO P9_36 AIN5 YES NO P9_37 AIN2 YES NO P9_38 AIN3 YES NO P9_39 AIN0 YES NO P9_40 AIN1 YES NO P9_41 GPIO0_20 YES NO P9_42 GPIO0_7 YES NO P9_43 GND NO NO P9_44 GND NO NO P9_45 GND NO NO P9_46 GND NO NO Stecker P8 Header-Pin Pin-Name CODESYS -Unterstützung Vom System verwendet P8_01 DGND NO NO P8_02 DGND NO NO P8_03 GPIO1_6 NO eMMC P8_04 GPIO1_7 NO eMMC P8_05 GPIO1_2 NO eMMC P8_06 GPIO1_3 NO eMMC P8_07 TIMER4 YES NO P8_08 TIMER7 YES NO P8_09 TIMER5 YES NO P8_10 TIMER6 YES NO P8_11 GPIO1_13 YES NO P8_12 GPIO1_12 YES NO P8_13 EHRPWM2B YES NO P8_14 GPIO0_26 YES NO P8_15 GPIO1_15 YES NO P8_16 GPIO1_14 YES NO P8_17 GPIO0_27 YES NO P8_18 GPIO2_1 YES NO P8_19 EHRPWM2A YES NO P8_20 GPIO1_31 NO eMMC P8_21 GPIO1_30 NO eMMC P8_22 GPIO1_5 NO eMMC P8_23 GPIO1_4 NO eMMC P8_24 GPIO1_1 NO eMMC P8_25 GPIO1_0 NO eMMC P8_26 GPIO1_29 YES NO P8_27 GPIO2_22 NO HDMI P8_28 GPIO2_24 NO HDMI P8_29 GPIO2_23 NO HDMI P8_30 GPIO2_25 NO HDMI P8_31 UART5_CTSN NO HDMI P8_32 UART5_RTSN NO HDMI P8_33 UART4_RTSN NO HDMI P8_34 UART3_RTSN NO HDMI P8_35 UART4_CTSN NO HDMI P8_36 UART3_CTSN NO HDMI P8_37 UART5_TXD NO HDMI P8_38 UART5_TXD NO HDMI P8_39 GPIO2_12 NO HDMI P8_40 GPIO2_13 NO HDMI P8_41 GPIO2_10 NO HDMI P8_42 GPIO2_11 NO HDMI P8_43 GPIO2_8 NO HDMI P8_44 GPIO2_9 NO HDMI P8_45 GPIO2_6 NO HDMI P8_46 GPIO2_7 NO HDMI " }, 
{ "title" : "Externe Speichergeräte konfigurieren ", 
"url" : "_rtsl_linux_bbb_external_storage.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Beaglebone \/ Externe Speichergeräte konfigurieren ", 
"snippet" : "Sie können den BeagleBone Black so konfigurieren, dass von CODESYS Control for BeagleBone aus ein Zugriff auf ein USB-Speichergerät oder eine µSD-Karte möglich ist. Die Kompatibilität spezifischer USB-Speicher oder µSD-Karten hängt von der Hardware ab. Theoretisch jedoch funktioniert jeder USB-Speic...", 
"body" : "Sie können den BeagleBone Black so konfigurieren, dass von CODESYS Control for BeagleBone aus ein Zugriff auf ein USB-Speichergerät oder eine µSD-Karte möglich ist. Die Kompatibilität spezifischer USB-Speicher oder µSD-Karten hängt von der Hardware ab. Theoretisch jedoch funktioniert jeder USB-Speicher oder jede µSD-Karte mit dem BeagleBone Black . Auf USB-Speicher oder µSD-Karte zugreifen Linux für Automount konfigurieren Debian stellt ein Package bereit, das sich um das Automount von steckbaren Speichermedien kümmert. Dieses Package kann auch auf Ihrem BeagleBone Black installiert werden. Installieren des Packages usbmount aus dem Debian-Verzeichnis: command> sudo apt-get install usbmount Das Gerät muss mit dem Internet verbunden sein, und es muss so konfiguriert sein, dass es auf die Debian-Server zugreifen kann. Auf USB-Speicher zugreifen Wenn ein USB-Speicher angeschlossen ist, erzeugt usbautomount automatisch den Ordner \/media\/usb , über den Sie auf die Dateien auf dem USB-Speicher zugreifen können. Das CODESYS Control Laufzeitsystem ist so konfiguriert, dass USB-Speicher automatisch angezeigt werden, wenn sie verfügbar sind. Wenn ein USB-Speichergerät angeschlossen ist, wird es in dem Ordner \/media\/usb eingehängt. Auf diesen Ordner kann von CODESYS aus über den Platzhalter $USB$ zugegriffen werden. Hierfür gibt es 2 Möglichkeiten: Sie können über den Dateitransfer im CODESYS Development System auf den Platzhalter $USB$ zugreifen. Sie können auf dieselben Dateien aus Ihrer IEC-Applikation heraus zugreifen und dazu die Bibliothek CAA_File verwenden. Beachten Sie, dass die Dateien gegebenenfalls nicht zugreifbar sind, weil das Medium steckbar ist. Prüfen Sie deshalb das Ergebnis von CAAFileOpen. " }, 
{ "title" : "Raspberry PI ", 
"url" : "_rtsl_linux_raspberry.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI ", 
"snippet" : "Verwenden Sie den Raspberry Pi mit dem Betriebssystem Raspbian, das über die Raspberry Pi Foundation bezogen werden kann. Der Raspberry Pi wurde für Test- und Lehrzwecke entwickelt. Ein Einsatz für industrielle Zwecke ist nicht empfehlenswert! Erste Schritte mit dem Raspberry Pi Ab Raspberry Pi Vers...", 
"body" : "Verwenden Sie den Raspberry Pi mit dem Betriebssystem Raspbian, das über die Raspberry Pi Foundation bezogen werden kann. Der Raspberry Pi wurde für Test- und Lehrzwecke entwickelt. Ein Einsatz für industrielle Zwecke ist nicht empfehlenswert! Erste Schritte mit dem Raspberry Pi Ab Raspberry Pi Version 2 steht Ihnen ein multicore-fähiges Laufzeitsystem zur Verfügung. " }, 
{ "title" : "Entwicklung von Treibern ", 
"url" : "_rtsl_linux_rbp_driver_development.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI \/ Entwicklung von Treibern ", 
"snippet" : "Es gibt eine Reihe von Geräten, die an den Raspberry Pi angeschlossen werden können. CODESYS Control for Raspberry Pi unterstützt nur eine kleine Teilmenge der verfügbaren Hardware. Wenn Sie ein nicht unterstütztes Gerät an Ihren Raspberry Pi anschließen möchten, können Sie einen eigenen I\/O-Treiber...", 
"body" : "Es gibt eine Reihe von Geräten, die an den Raspberry Pi angeschlossen werden können. CODESYS Control for Raspberry Pi unterstützt nur eine kleine Teilmenge der verfügbaren Hardware. Wenn Sie ein nicht unterstütztes Gerät an Ihren Raspberry Pi anschließen möchten, können Sie einen eigenen I\/O-Treiber schreiben. Um dies zu tun, benötigen Sie einige Konfigurations- und Programmierkenntnisse. Sie können grundsätzlich folgende Ansätze verfolgen, um zusätzliche Geräte über die Systemschnittstellen I 2 C, SPI (Serial Peripheral Interface) oder 1-Wire anzuschließen und zu betreiben. Einen Funktionsbaustein (FB) implementieren Der Funktionsbaustein übernimmt das Mapping der Daten auf bestehende oder neue Variablen und sorgt für die Zykluskonsistenz der Daten. Deklarieren Sie dafür manuell die Schnittstelle und rufen Sie eine Instanz im Programm auf. Einen Funktionsbaustein (FB) mit Gerätebeschreibung implementieren Dann können Sie ein spezielles Gerät in den CODESYS -Gerätebaum einhängen und konfigurieren. I\/O-Treiber implementieren Diese und verschiedene weitere Ansätze werden auf der Open-Source-Plattform CODESYS Forge in Menü Drivers → I\/O Drivers beschrieben. " }, 
{ "title" : "Konfigurieren des LZS ", 
"url" : "_rtsl_linux_rbp_configure_runtime.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI \/ Konfigurieren des LZS ", 
"snippet" : "CODESYS Control for Raspberry Pi unterstützt seit Version V3.5 SP14 auch multicore-fähige Hardware ( Raspberry Pi 2 und Raspberry Pi 3). Das Laufzeitsystem kann hierfür in drei verschiedenen Modi betrieben werden: Multicore 64-Bit (Aarch64): Dieser Modus nutzt ein multicore-fähiges Laufzeitsystem im...", 
"body" : "CODESYS Control for Raspberry Pi unterstützt seit Version V3.5 SP14 auch multicore-fähige Hardware ( Raspberry Pi 2 und Raspberry Pi 3). Das Laufzeitsystem kann hierfür in drei verschiedenen Modi betrieben werden: Multicore 64-Bit (Aarch64): Dieser Modus nutzt ein multicore-fähiges Laufzeitsystem im 64-Bit-Betrieb und muss mit einer dafür optimierten Gerätebeschreibung betrieben werden. Multicore 32-Bit (ARMv7): Dieser Modus nutzt ein multicore-fähiges Laufzeitsystem im 32-Bit-Betrieb und muss mit einer dafür optimierten Gerätebeschreibung betrieben werden. Standard: Dieser Modus kann für alle Raspberry Pi -Varianten verwendet werden und ist kompatibel mit früheren Versionen von CODESYS Control for Raspberry Pi inkl. Gerätebeschreibung. Er unterstützt nicht die CODESYS -Multicore-Funktionalität. Bei Installation des Raspberry Pi Laufzeitsystems wird automatisch ein Modus vorausgewählt,. Im Logfenster können Sie erkennen, welcher Modus gewählt wurde. Um den Modus zu ändern, wählen Sie zuerst das Raspberry Pi Laufzeitsystem in der Liste der Services aus. Auf der rechten Seite erscheint nach kurzer Ladezeit die aktuelle Runtime-Architektur. Über die Auswahlliste Laufzeitsystem-Architektur können Sie die gewünschte Architektur auswählen. Mit einem klick auf Speichern wird die Änderung auf das Gerät übertragen. Welcher Modus verwendet werden kann, hängt auch vom verwendeten Betriebssystem-Image ab. Wenn Sie ein reines 64-Bit-Image verwenden, kann nur der 64-Bit Modus verwendet werden. Wenn Sie ein reines 32-Bit-Image verwenden, können nur die 32-Bit Modi ausgewählt werden. Je nach verwendeter Hardware (Raspberry PI 2B, PI 3, PI 4 ...) sind nur ausgewählte Modi unterstützt. (siehe Tooltip). Wenn Sie den Modus wechseln wollen, müssen Sie sicherstellen, dass die dazu passende Gerätebeschreibung im Projekt konfiguriert ist. Andernfalls ist eine Kommunikation mit der Steuerung nicht mehr möglich. Auf der Steuerung bestehende Bootapplikationen können nach dem Wechsel nicht mehr geladen werden und müssen mit der passenden Gerätebeschreibung erneut auf die Steuerung geladen werden. " }, 
{ "title" : "Beispielprojekte ", 
"url" : "_rtsl_linux_rbp_examples.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI \/ Beispielprojekte ", 
"snippet" : "Im Installationsverzeichnis, beispielsweise C:\\Users\\<Name>\\ CODESYS Control for Raspberry Pi \\3.5.11.0\\Examples , finden Sie die folgenden Beispielprojekte....", 
"body" : "Im Installationsverzeichnis, beispielsweise C:\\Users\\<Name>\\ CODESYS Control for Raspberry Pi \\3.5.11.0\\Examples , finden Sie die folgenden Beispielprojekte. " }, 
{ "title" : "WebVisu projektieren ", 
"url" : "_rtsl_linux_rbp_examples_webvisu.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI \/ Beispielprojekte \/ WebVisu projektieren ", 
"snippet" : "Das Projekt: WebVisu.project enthält eine Applikation mit einer mit CODESYS Visualization erstellten Benutzeroberfläche. Öffnen Sie das Projekt WebVisu.project . Doppelklicken Sie auf Device im Gerätebaum. Wählen Sie in Kommunikation den Befehl Netzwerk durchsuchen . Wenn das Gerät sich im gleichen ...", 
"body" : "Das Projekt: WebVisu.project enthält eine Applikation mit einer mit CODESYS Visualization erstellten Benutzeroberfläche. Öffnen Sie das Projekt WebVisu.project . Doppelklicken Sie auf Device im Gerätebaum. Wählen Sie in Kommunikation den Befehl Netzwerk durchsuchen . Wenn das Gerät sich im gleichen Netzwerk wie Ihr Entwicklungs-PC befindet, erscheint Ihr Gerät zur Auswahl. Selektieren Sie Ihr Gerät und wählen Sie den Befehl Online → Einloggen . Die Applikation wird auf Ihrem Raspberry Pi geladen. Starten Sie das Programm beispielsweise mit F5 . Öffnen Sie einen beliebigen Browser (eventuell auf einem Smartphone) und geben Sie die Adresse <Netzwerk-Adresse>:8080\/webvisu.htm ein. Im Browser sehen Sie die Benutzeroberfläche, wie sie im Projekt angelegt wurde. " }, 
{ "title" : "Kameramodul projektieren ", 
"url" : "_rtsl_linux_rbp_examples_camera.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI \/ Beispielprojekte \/ Kameramodul projektieren ", 
"snippet" : "Kamerabilder visualisieren Das Projekt CameraStream.project enthält eine Applikation mit einer WebVisu-Benutzeroberfläche, die einen Kamera-Livestream oder auch ein Einzelbild darstellt. Voraussetzung: Die Erweiterungshardware Raspberry Pi Camera ist angeschlossen und aktiviert. In Abhängigkeit der ...", 
"body" : "Kamerabilder visualisieren Das Projekt CameraStream.project enthält eine Applikation mit einer WebVisu-Benutzeroberfläche, die einen Kamera-Livestream oder auch ein Einzelbild darstellt. Voraussetzung: Die Erweiterungshardware Raspberry Pi Camera ist angeschlossen und aktiviert. In Abhängigkeit der Version von RPi_Cam_Web_Interface und der enthaltenen Apache-Installation kann der voreingestellte Speicherort ..\/var\/www\/ oder ..\/var\/www\/html\/ sein. Der Speicherort wird in der Applikation in PLC_PRG in Zeile 3 verwendet und Sie müssen ihn entsprechend angepassen. Öffnen Sie das Projekt CameraStream.project und aktualisieren Sie es. Doppelklicken Sie auf Device im Gerätebaum. Der Geräteeditor öffnet sich. Wählen Sie in Kommunikation den Befehl Netzwerk durchsuchen . Wenn Ihr Raspberry Pi und das Entwicklungssystem im gleichen Netzwerk sind, erscheint Ihr Raspberry Pi zur Auswahl. Selektieren Sie es und wählen Sie den Befehl Online → Einloggen . Die Applikation wird auf Ihrem Raspberry Pi geladen. Starten Sie das Programm (mit F5 ). Öffnen Sie einen beliebigen Browser (eventuell auf einem Smartphone) und geben Sie die Adresse <Netzwerk-Adresse>:8080\/webvisu.htm ein. Die Benutzeroberfläche des Projekts erscheint. Im oberen Teil ist der Livestream der Kamera und darunter das letzte Einzelbild dargestellt. Wenn Sie auf den Button klicken, wird das Einzelbild aktualisiert. " }, 
{ "title" : "Kamerabilder speichern ", 
"url" : "_rtsl_linux_rbp_examples_camera.html#UUID-7ae4b070-9730-d58c-9609-58bda5038aa4_id_fa1d2aa65ca341bec0a864637b1b4eb2-id-919df6bb9f68aed4c0a864630c86131d", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI \/ Beispielprojekte \/ Kameramodul projektieren \/ Kamerabilder speichern ", 
"snippet" : "Voraussetzung: Die Erweiterungshardware Raspberry Pi Camera ist angeschlossen und aktiviert. Das Projekt Camera.project enthält eine Applikation, die ein Raspberry Pi Camera-Modul steuert, einzelne Bilder aufnimmt und als Datei speichert. Bei einigen Modellen muss die vorinstallierte Applikation RPi...", 
"body" : "Voraussetzung: Die Erweiterungshardware Raspberry Pi Camera ist angeschlossen und aktiviert. Das Projekt Camera.project enthält eine Applikation, die ein Raspberry Pi Camera-Modul steuert, einzelne Bilder aufnimmt und als Datei speichert. Bei einigen Modellen muss die vorinstallierte Applikation RPi Cam Control deaktiviert werden. Öffnen Sie dafür einen Browser und geben Sie http:\/\/<Netzwerk-Adresse> ein. Es öffnet sich die Konfigurationsseite. Führen sie dort den Befehl stop camera aus. Öffnen Sie das Projekt Camera.project und aktualisieren Sie es. Doppelklicken Sie auf Device im Gerätebaum. Der Geräteeditor öffnet sich. Wählen Sie in Kommunikation den Befehl Netzwerk durchsuchen . Wenn Ihr Raspberry Pi und das Entwicklungssystem im gleichen Netzwerk sind, erscheint Ihr Raspberry Pi zur Auswahl. Selektieren Sie es und wählen Sie den Befehl Online → Einloggen . Die Applikation wird auf Ihrem Raspberry Pi geladen. Starten Sie das Programm (mit F5 ). Setzen die Variable xTakePicture auf TRUE . Die Kamera nimmt ein Bild auf und speichert es im lokalen Dateisystem unter dem Namen Picture.jpg . Sie können die Bilddatei im Geräteeditor unter Dateien auf Ihr Entwicklungssystem kopieren. Mit Klick auf das Symbol aktualisieren Sie die Dateiansicht. " }, 
{ "title" : "GPIO projektieren ", 
"url" : "_rtsl_linux_rbp_examples_gpio.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI \/ Beispielprojekte \/ GPIO projektieren ", 
"snippet" : "Das Projekt GPIO.project enthält eine Applikation mit freien GPIOs, in dessen Geräteeditor das E\/A-Abbild konfiguriert ist. Dort sind auch die digitalen Ein- und Ausgänge festgelegt. Im Geräteeditor unter der Registerkarte GPIOs E\/A-Abbild sind für die Eingänge und für die Ausgänge jeweils eine DWOR...", 
"body" : "Das Projekt GPIO.project enthält eine Applikation mit freien GPIOs, in dessen Geräteeditor das E\/A-Abbild konfiguriert ist. Dort sind auch die digitalen Ein- und Ausgänge festgelegt. Im Geräteeditor unter der Registerkarte GPIOs E\/A-Abbild sind für die Eingänge und für die Ausgänge jeweils eine DWORD -Variable deklariert. Das Bit<X> enthält den Wert von GPIO<X> . Im Beispiel wurde GPIO18 als Ausgang definiert. Es wird im Programm PLC_PRG mit einem Blinksignal belegt. Die Visualisierung stellt den Wert der Eingänge dar und erlaubt das Setzen der Ausgänge. Für die Modellvariante Raspberry Pi B+ gibt es eine eigene, erweiterte Gerätebeschreibung. Um statt der Gerätebeschreibung GPIOs A\/B die Gerätebeschreibung GPIOs B+\/Pi2 zu verwenden, wählen Sie den Kontextbefehl Gerät aktualisieren und wählen im Dialog den Gerätetyp GPIOs B+\/Pi2 aus. In Abhängigkeit von den geladenen Treibern können manche GPIOs permanent mit anderen Funktionen belegt sein und folglich nicht zur Verfügung stehen. " }, 
{ "title" : "PiFace Digital projektieren ", 
"url" : "_rtsl_linux_rbp_examples_piface.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI \/ Beispielprojekte \/ PiFace Digital projektieren ", 
"snippet" : "Mit PiFace Control and Display-Modul steuern und bedienen Voraussetzung: Die Erweiterungshardware PiFace Control and Display ist angeschlossen. Das Projekt PiFaceDisplayAndControl.project enthält eine Applikation, die neben der E\/A-Hardware Raspberry PiFace Digital mit 8 digitalen Ein- und Ausgängen...", 
"body" : "Mit PiFace Control and Display-Modul steuern und bedienen Voraussetzung: Die Erweiterungshardware PiFace Control and Display ist angeschlossen. Das Projekt PiFaceDisplayAndControl.project enthält eine Applikation, die neben der E\/A-Hardware Raspberry PiFace Digital mit 8 digitalen Ein- und Ausgängen ein 2-zeiliges Textdisplay steuert, um Applikationsparameter einzustellen. Sie erreichen das Board PiFace Control and Display über den SPI-Port 1 \/dev\/spidev0.1 , der im SPI Master eingestellt ist. Durch das Einhängen des Geräts in den Gerätebaum wird eine FB-Instanz angelegt, die diverse Methoden und Eigenschaften zur Ansteuerung des Geräts bereitstellt. Außerdem wird der Zustand der Taster zurückgegeben. Die Bits 0 bis 7 des Ausgangs bySwitches stehen dabei für folgende Taster: Im Beispielprojekt wird der FB PiFace_Control_Display an eine Instanz des FBs ParamListPiFace übergeben, der einen Parametereditor implementiert. In dessen Ansichtsmodus können Sie über den Navigationstaster (6\/7) die Parameterliste durchlaufen. Durch Drücken des Navigationstasters (5) sehen Sie den Parameter der ersten Zeile im Detail. Die Detailansicht verlassen Sie über den Taster 4. Durch erneutes Drücken von 5 gelangen Sie in den Editiermodus. Dort können Sie den Wert im zulässigen Bereich mit den Tastern 0 und 1 verändern. Mit Taster 2 wird der Wert gespeichert. Mit Taster 4 wird der Editiermodus verlassen. " }, 
{ "title" : "E\/A-Hardware PiFace Digital steuern ", 
"url" : "_rtsl_linux_rbp_examples_piface.html#UUID-c604b911-bae8-3ccf-0ad8-13b30c6d647a_id_a539525ca8913fc0a864630d69208b-id-9f45924d66a164bcc0a864631b646b6a", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI \/ Beispielprojekte \/ PiFace Digital projektieren \/ E\/A-Hardware PiFace Digital steuern ", 
"snippet" : "Voraussetzung: Die Erweiterungshardware PiFace Digital ist angeschlossen. Das Projekt PiFace.project enthält eine Applikation, die eine E\/A-Hardware Raspberry PiFace Digital mit 8 digitale Ein- und Ausgängen steuert. Öffnen Sie das Projekt PiFace.project und aktualisieren Sie es. Doppelklicken Sie a...", 
"body" : "Voraussetzung: Die Erweiterungshardware PiFace Digital ist angeschlossen. Das Projekt PiFace.project enthält eine Applikation, die eine E\/A-Hardware Raspberry PiFace Digital mit 8 digitale Ein- und Ausgängen steuert. Öffnen Sie das Projekt PiFace.project und aktualisieren Sie es. Doppelklicken Sie auf Device im Gerätebaum. Der Geräteeditor öffnet sich. Wählen Sie in Registerkarte Kommunikation den Befehl Netzwerk durchsuchen . Wenn Ihr Raspberry Pi und das Entwicklungssystem im gleichen Netzwerk sind, erscheint Ihr Raspberry Pi zur Auswahl. Selektieren Sie es und wählen Sie den Befehl Online → Einloggen . Die Applikation wird auf Ihrem Raspberry Pi geladen. Starten Sie das Programm (mit F5 ). Wenn Sie den Taster S1 drücken wird der Relaisausgang K0 mit einer Sekunde Zeitverzögerung geschaltet. Wenn Sie den Taster S2 drücken, wird K1 sofort geschaltet. K1 wird um eine halbe Sekunde nach dem Loslassen von S2 nachgehalten. Beachten Sie auch, dass Sie mehrere Instanzen (Hardware-Adresse über Jumper JP1, JP2 änderbar) verwenden können, indem Sie den Geräteparameter beim PiFace-Gerät im Gerätebaum entsprechend anpassen. Die Bibliothek Raspberry SPI_PiFace , die die Anbindung ermöglicht, steht ihnen als Quellcode zur Verfügung. Sie kann als Beispiel für andere Anschaltungen dienen. Die Bibliothek Raspberry Pi Peripherals ist die Basis für die Kommunikation über SPI. Deren Schnittstellen sind sowohl in der Hilfe als auch im Bibliotheksverwalter dokumentiert. " }, 
{ "title" : "PiFace Digital-Modul über E\/A-Treiber steuern ", 
"url" : "_rtsl_linux_rbp_examples_piface.html#UUID-c604b911-bae8-3ccf-0ad8-13b30c6d647a_id_a539525ca8913fc0a864630d69208b-id-24768c9d66a164bcc0a864631df6fefb", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI \/ Beispielprojekte \/ PiFace Digital projektieren \/ PiFace Digital-Modul über E\/A-Treiber steuern ", 
"snippet" : "Voraussetzung: Die Erweiterungshardware PiFace Digital ist angeschlossen. Das Projekt: PiFaceIoDrv.project enthält eine Applikation, die ebenfalls eine E\/A-Hardware Raspberry PiFace Digital mit 8 digitalen Ein- und Ausgängen steuert. Aber es wird anstelle einer impliziten FB-Instanz ein E\/A-Treiber ...", 
"body" : "Voraussetzung: Die Erweiterungshardware PiFace Digital ist angeschlossen. Das Projekt: PiFaceIoDrv.project enthält eine Applikation, die ebenfalls eine E\/A-Hardware Raspberry PiFace Digital mit 8 digitalen Ein- und Ausgängen steuert. Aber es wird anstelle einer impliziten FB-Instanz ein E\/A-Treiber verwendet. Der E\/A-Treiber realisiert den Austausch der Ein- und Ausgänge in SPS üblicher Art und Weise über das Prozessabbild. Die Bibliothek IoDrvPiFace enthält den E\/A-Treiber als Quellcode. " }, 
{ "title" : "I 2 C projektieren ", 
"url" : "_rtsl_linux_rbp_examples_i2c.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI \/ Beispielprojekte \/ I 2 C projektieren ", 
"snippet" : "Voraussetzung: Über I²C ist eine spezielle Hardware angeschlossen. Das Projekt I2CExample.project enthält eine Applikation, die diverse, über I²C angeschlossene Chips\/Breakouts steuert. Angebundene Hardware: Adafruit 16-Channel\/12-Bit PWM SRF02 (Ultraschall-Entfernungssensor) Drotek IMU 9DOF - MPU91...", 
"body" : "Voraussetzung: Über I²C ist eine spezielle Hardware angeschlossen. Das Projekt I2CExample.project enthält eine Applikation, die diverse, über I²C angeschlossene Chips\/Breakouts steuert. Angebundene Hardware: Adafruit 16-Channel\/12-Bit PWM SRF02 (Ultraschall-Entfernungssensor) Drotek IMU 9DOF - MPU9150 (Gyroskop, Beschleunigungsmesser, Magnetoskop) Die Bibliotheken Raspberry I2C <Name> , die eine Anbindung ermöglichen, stehen Ihnen als Quellcode zur Verfügung. Sie können als Beispiel für andere Anschaltungen dienen. Die Bibliothek Raspberry Pi Peripherals ist die Basis für die Kommunikation über I²C. Deren Schnittstellen sind sowohl in der Hilfe als auch im Bibliotheksverwalter dokumentiert. " }, 
{ "title" : "A\/D-Wandler MPC3008 projektieren ", 
"url" : "_rtsl_linux_rbp_examples_mcp3008.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI \/ Beispielprojekte \/ A\/D-Wandler MPC3008 projektieren ", 
"snippet" : "Voraussetzung: Über SPI ist eine spezielle Hardware angeschlossen. Das Projekt MCP3008_Temperature.project enthält eine Applikation, die einen analogen Temperatursensor (LM35), der an einen A\/D-Wandler-Chip (MCP3008) angeschlossen wurde, über SPI ausliest. Der MCP3008 kann 8 analoge Kanäle auswerten...", 
"body" : "Voraussetzung: Über SPI ist eine spezielle Hardware angeschlossen. Das Projekt MCP3008_Temperature.project enthält eine Applikation, die einen analogen Temperatursensor (LM35), der an einen A\/D-Wandler-Chip (MCP3008) angeschlossen wurde, über SPI ausliest. Der MCP3008 kann 8 analoge Kanäle auswerten, wobei in diesem Beispiel nur einer benutzt wird. Testaufbau: Die Bibliothek SPI_MCP3008 , die die Anbindung ermöglicht, steht ihnen als Quellcode zur Verfügung. Sie kann als Beispiel für andere Anschaltungen dienen. Die Bibliothek Raspberry Pi Peripherals ist die Basis für die Kommunikation über SPI. Deren Schnittstellen sind sowohl in der Hilfe als auch im Bibliotheksverwalter dokumentiert. " }, 
{ "title" : "Port-Expander MCP23S17 projektieren ", 
"url" : "_rtsl_linux_rbp_examples_mcp23s17.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI \/ Beispielprojekte \/ Port-Expander MCP23S17 projektieren ", 
"snippet" : "Voraussetzung: Über SPI ist eine spezielle Hardware angeschlossen. Das Projekt MCP23S17.project enthält eine Applikation, in der ein Portexpander-Chip (MCP23S17) über SPI angebunden wurde. Sie können im Geräteeditor einstellen, welche der GPIO-Pins als Eingang und welche als Ausgang verwendet werden...", 
"body" : "Voraussetzung: Über SPI ist eine spezielle Hardware angeschlossen. Das Projekt MCP23S17.project enthält eine Applikation, in der ein Portexpander-Chip (MCP23S17) über SPI angebunden wurde. Sie können im Geräteeditor einstellen, welche der GPIO-Pins als Eingang und welche als Ausgang verwendet werden. Außerdem können Sie für die Eingänge einen Pull-up-Widerstand aktivieren. Je nach Belegung der Adress-IO-Pins muss die Hardware-Adresse entsprechend eingestellt sein. " }, 
{ "title" : "1-Wire projektieren ", 
"url" : "_rtsl_linux_rbp_examples_1_wire.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI \/ Beispielprojekte \/ 1-Wire projektieren ", 
"snippet" : "Voraussetzung: Ein 1-Wire-Temperatursensor ist angeschlossen. Das Projekt OneWire.project enthält eine Applikation, die Geräte erkennt, die über 1-Wire angeschlossen sind. Außerdem wird ein Temperatursensor vom Typ DS18B20 angesteuert. Dabei ist die 1-Wire-Datenleitung an den GPIO4 angeschlossen. Si...", 
"body" : "Voraussetzung: Ein 1-Wire-Temperatursensor ist angeschlossen. Das Projekt OneWire.project enthält eine Applikation, die Geräte erkennt, die über 1-Wire angeschlossen sind. Außerdem wird ein Temperatursensor vom Typ DS18B20 angesteuert. Dabei ist die 1-Wire-Datenleitung an den GPIO4 angeschlossen. Sie können die Beispielapplikation verwenden, um die ID zu ermitteln. Funktion der Beispielapplikation: Durchsuchen des Netzwerkes nach 1-Wire-Geräten und Anzeige der IDs der gefundenen Geräte in einer Visualisierung Messen und anzeigen der Sensortemperatur, wenn unter den gefundenen Geräte ein DS18B20 mit korrekt konfigurierter ID ist. Der Datenaustausch über 1-Wire nimmt viel Zeit in Anspruch. Währenddessen ist die Task blockiert. Ordnen Sie bei zeitlich kritischen Anwendungen die Applikation der 1-Wire-Feldbusgeräten einer anderen Task zu! Im Geräteeditor in der Registerkarte Taskaufstellung können Sie Tasks zuordnen. " }, 
{ "title" : "Servomotor projektieren ", 
"url" : "_rtsl_linux_rbp_examples_softmotion_servo.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI \/ Beispielprojekte \/ Servomotor projektieren ", 
"snippet" : "Voraussetzung: Über I²C ist eine Adafruit 16-Channel\/12Bit PWM-Platine angeschlossen, auf derem ersten PWM-Kanal ein Modellbau-Servo verkabelt ist. Das Projekt SoftMotion Servo Example.project enthält eine Applikation, in der CODESYS SoftMotion in Verbindung mit Modellbau-Servomotoren verwendet wird...", 
"body" : "Voraussetzung: Über I²C ist eine Adafruit 16-Channel\/12Bit PWM-Platine angeschlossen, auf derem ersten PWM-Kanal ein Modellbau-Servo verkabelt ist. Das Projekt SoftMotion Servo Example.project enthält eine Applikation, in der CODESYS SoftMotion in Verbindung mit Modellbau-Servomotoren verwendet wird. Als Kommunikationsinterface wird eine über I²C verbundene Erweiterungsplatine (Adafruit ID 815) verwendet. Öffnen Sie das Projekt SoftMotion Servo Example.project und aktualisieren Sie es. Doppelklicken Sie auf Device im Gerätebaum. Der Geräteeditor öffnet sich. Wählen Sie in Kommunikation den Befehl Netzwerk durchsuchen . Wenn Ihr Raspberry Pi und das Entwicklungssystem im gleichen Netzwerk sind, erscheint Ihr Raspberry Pi zur Auswahl. Selektieren Sie es und wählen Sie den Befehl Online → Einloggen . Die Applikation wird auf Ihrem Raspberry Pi geladen. Starten Sie das Programm (mit F5 ). Der Servomotor beginnt sich stetig von links nach rechts zu drehen. Dafür verantwortlich ist das in AS implementierte Programm PLC_PRG . Es schaltet die Achse ein und bewegt sie dann zwischen den Positionen -60 und +60, die in der Konfiguration der Achse SM_Drive_Servo als Endlagen angegeben wurden. Die Vorgabe der Position wird über die bei Modellbau-Servos übliche PWM-Schnittstelle transportiert. Dabei wird in einem festen Takt (Default: 50Hz; Parameter des Adafruit PWM Softmotion-Geräts) ein HIGH-Puls gesendet, der zwischen 1ms und 2 ms lang ist. 1 ms steht dabei für die untere, 2 ms für die obere Endlage. Der Bewegungsbereich ist von Motortyp zu Motortyp unterschiedlich. Wenn der Motor in Winkelgrad gesteuert wird, müssen Sie den Bewegungsbereich ausmessen. Dafür fahren Sie die Endlagen (im Beispiel -60, +60) an und tragen die gemessenen Positionen im Konfigurationsbildschirm ein: Öffnen Sie einen beliebigen Browser (eventuell auf einem Smartphone) und geben Sie die Adresse <Netzwerk-Adresse>:8080\/webvisu.htm ein. Die Visualisierung öffnet sich und stellt die erzeugten Sollpositionen dar. Sie können die Geschwindigkeit steuern. " }, 
{ "title" : "EtherCAT projektieren ", 
"url" : "_rtsl_linux_rbp_examples_ethercat.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI \/ Beispielprojekte \/ EtherCAT projektieren ", 
"snippet" : "Voraussetzung: An den Ethernet-Adapter sind die Geräte Beckhoff EK1100 mit Beckhoff EL2008 angeschlossen. Das Projekt EtherCAT.project enthält eine Applikation, in der ein EtherCAT-Felbusgerät gesteuert wird. Es werden die acht vorhandenen Ausgänge geschaltet. Wenn Sie den LAN-Port des Raspberry Pi ...", 
"body" : "Voraussetzung: An den Ethernet-Adapter sind die Geräte Beckhoff EK1100 mit Beckhoff EL2008 angeschlossen. Das Projekt EtherCAT.project enthält eine Applikation, in der ein EtherCAT-Felbusgerät gesteuert wird. Es werden die acht vorhandenen Ausgänge geschaltet. Wenn Sie den LAN-Port des Raspberry Pi für den EtherCAT-Feldbus verwenden, wird eine alternative Programmierschnittstelle benötigt. Verwenden Sie einen USB-WLAN-Adapter wie beispielsweise den Edimax N150. Öffnen Sie das Projekt EtherCAT.project und aktualisieren Sie es. Doppelklicken Sie auf Device im Gerätebaum. Der Geräteeditor öffnet sich. Wählen Sie in Kommunikation den Befehl Netzwerk durchsuchen . Wenn Ihr Raspberry Pi und das Entwicklungssystem im gleichen Netzwerk sind, erscheint Ihr Raspberry Pi zur Auswahl. Selektieren Sie es und wählen Sie den Befehl Online → Einloggen . Die Applikation wird auf Ihrem Raspberry Pi geladen. Starten Sie das Programm (mit F5 ). Die Ausgänge der Klemme EL2008 ändern sich daraufhin laufend. " }, 
{ "title" : "OPC UA projektieren ", 
"url" : "_rtsl_linux_rbp_examples_opc_ua.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI \/ Beispielprojekte \/ OPC UA projektieren ", 
"snippet" : "Das Projekt OPCUA.project enthält eine Applikation, in der Variablen für den Zugriff eines OPC UA-Clients konfiguriert sind. Dazu wurden im Objekt Symbolkonfiguration die beiden Variablen des Objekts PLC_PRG veröffentlicht. In einem geeigneten OPC UA-Client, wie beispielsweise Unified Automation UaE...", 
"body" : "Das Projekt OPCUA.project enthält eine Applikation, in der Variablen für den Zugriff eines OPC UA-Clients konfiguriert sind. Dazu wurden im Objekt Symbolkonfiguration die beiden Variablen des Objekts PLC_PRG veröffentlicht. In einem geeigneten OPC UA-Client, wie beispielsweise Unified Automation UaExpert, können Sie zu Ihrem RaspberryPi über die URL opc.tcp:\/\/<Netzwerkadresse>:4840 eine Verbindung aufbauen. Im Client werden dessen Symbole (veröffentlichte Variablen) dargestellt und die aktuellen Werte angezeigt. Wenn in der Symbolkonfiguration das Schreibrecht erteilt ist, können Sie auf die Symbole schreiben. " }, 
{ "title" : "Sense HAT projektieren ", 
"url" : "_rtsl_linux_rbp_examples_sense_hat.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ Raspberry PI \/ Beispielprojekte \/ Sense HAT projektieren ", 
"snippet" : "Voraussetzung: Sie benötigen die Raspberry Pi -Erweiterungshardware Sense HAT. Ein Raspberry Pi mit aufgesteckter Erweiterungshardware Sense HAT verfügt über Sensoren für Beschleunigung, Luftfeuchtigkeit, Temperatur und barometrischen Druck; außerdem noch über Sensoren für ein Gyroskop und ein Magne...", 
"body" : "Voraussetzung: Sie benötigen die Raspberry Pi -Erweiterungshardware Sense HAT. Ein Raspberry Pi mit aufgesteckter Erweiterungshardware Sense HAT verfügt über Sensoren für Beschleunigung, Luftfeuchtigkeit, Temperatur und barometrischen Druck; außerdem noch über Sensoren für ein Gyroskop und ein Magnetometer. Sie können damit beispielsweise eine Wetterstation realisieren. Das Projekt SenseHat.project stellt eine Applikation bereit, um eine Sense HAT-Erweiterungshardware zu bedienen. Funktion der Beispielapplikation: Messen und Anzeigen der Sensordaten Steuern Sensoren Steuern mit dem Joystick Benutzeroberfläche: " }, 
{ "title" : "PLCnext ", 
"url" : "_rtsl_plcnext.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ PLCnext ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Anwendungsspezifische Hinweise ", 
"url" : "_rtsl_plcnext_hints.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ PLCnext \/ Anwendungsspezifische Hinweise ", 
"snippet" : "Zur Optimierung spezieller Anwendungsfälle empfehlen wir folgende Applikations-\/Konfigurationseinstellungen....", 
"body" : "Zur Optimierung spezieller Anwendungsfälle empfehlen wir folgende Applikations-\/Konfigurationseinstellungen. " }, 
{ "title" : "Konfiguration für Anwendungsfall PROFINET ", 
"url" : "_rtsl_plcnext_hints.html#UUID-1e21ef99-5642-2ae9-585e-0f712913f733_section-idm4605464568745633478907338798", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ PLCnext \/ Anwendungsspezifische Hinweise \/ Konfiguration für Anwendungsfall PROFINET ", 
"snippet" : "Beim Einsatz von PROFINET sollten Sie folgende Hinweise beachten: Verwenden Sie, wenn möglich, das MultiCore-Feature von CODESYS . Verwenden Sie dabei Kern 0 für PROFINET -Tasks. Verwenden Sie, wenn möglich, einen separaten Netzwerkadapter für die PROFINET -Anbindung. Wenn Sie sicherstellen möchten,...", 
"body" : "Beim Einsatz von PROFINET sollten Sie folgende Hinweise beachten: Verwenden Sie, wenn möglich, das MultiCore-Feature von CODESYS . Verwenden Sie dabei Kern 0 für PROFINET -Tasks. Verwenden Sie, wenn möglich, einen separaten Netzwerkadapter für die PROFINET -Anbindung. Wenn Sie sicherstellen möchten, dass Ihr Feldbus weiterhin Frames sendet und empfängt, auch wenn die Anwendung gestoppt ist, aktivieren Sie in den SPS-Einstellung die Option E\/As aktualisieren im Stop . " }, 
{ "title" : "Konfiguration für Anwendungsfall Axioline ", 
"url" : "_rtsl_plcnext_hints.html#UUID-1e21ef99-5642-2ae9-585e-0f712913f733_section-idm458155578255363347890799443", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ PLCnext \/ Anwendungsspezifische Hinweise \/ Konfiguration für Anwendungsfall Axioline ", 
"snippet" : "Beim Einsatz von Axioline sollten Sie folgende Hinweise beachten: Verwenden Sie, wenn möglich, das MultiCore-Feature von CODESYS . Verwenden Sie dabei Kern 1 für Axioline Task\/Buszyklustask. Einige Axioline-Module der PLCNext-Steuerung verfügen über zusätzliche Informationen, so genannte PDI-Objekte...", 
"body" : "Beim Einsatz von Axioline sollten Sie folgende Hinweise beachten: Verwenden Sie, wenn möglich, das MultiCore-Feature von CODESYS . Verwenden Sie dabei Kern 1 für Axioline Task\/Buszyklustask. Einige Axioline-Module der PLCNext-Steuerung verfügen über zusätzliche Informationen, so genannte PDI-Objekte. Auf diese Informationen können Sie über IoDrvPLCNextAxioLib.PdiRead und IoDrvPLCNextAxioLib.PdiWrite zugreifen. " }, 
{ "title" : "CODESYS Virtual Control for Linux SL ", 
"url" : "_rtsl_codesys_virtual_for_linux_control_sl.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ CODESYS Virtual Control for Linux SL ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Überblick ", 
"url" : "_rtsl_virtual_control_sl_overview.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ CODESYS Virtual Control for Linux SL \/ Überblick ", 
"snippet" : "Mit dem Add-on CODESYS Virtual Control for Linux SL lassen sich die virtuellen Runtime- und Gateway-Instanzen verwalten. Ein virtuelles Laufzeitsystem baut auf der Docker oder Podman Containertechnologie auf. Docker unterscheidet beispielsweise zwischen einem Image und einem Container. Ein Image ist...", 
"body" : "Mit dem Add-on CODESYS Virtual Control for Linux SL lassen sich die virtuellen Runtime- und Gateway-Instanzen verwalten. Ein virtuelles Laufzeitsystem baut auf der Docker oder Podman Containertechnologie auf. Docker unterscheidet beispielsweise zwischen einem Image und einem Container. Ein Image ist die Vorlage für einen Container, der einen Prozess gekapselt von dem restlichen System ausführt. Durch die Kapselung ist es möglich, mehrere Container gleichzeitig hardwareunabhängig auf dem selben System auszuführen. CODESYS Virtual Control for Linux SL nutzt diese Eigenschaften, um eine hardwareunabhängige Steuerung anzubieten. Sie finden Beschreibungen dazu, wie Sie das Tool \"Runtime Deploy\" verwenden, um Images auf das Zielsystem zu transportieren, aus den Images Instanzen anlegen und diese Instanzen verwalten. Containerisierte SteuerungenLaufzeitsystem startenVerbindung zu einer Instanz aufbauen CODESYS Virtual Control SL " }, 
{ "title" : "Verbindung zu einer Instanz aufbauen ", 
"url" : "_rtsl_extablish_connection_to_instance.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ CODESYS Virtual Control for Linux SL \/ Verbindung zu einer Instanz aufbauen ", 
"snippet" : "Direkte Verbindung zu einer Runtime-Instanz aufbauen Durch Portweiterleitung können Sie eine direkte Verbindung zu den Runtime-Instanzen herstellen. Dazu werden neben der Runtime-Instanz keine weiteren Instanzen benötigt. Voraussetzungen Der Port der Runtime-Instanz für die direkte Kommunikation ( 1...", 
"body" : "Direkte Verbindung zu einer Runtime-Instanz aufbauen Durch Portweiterleitung können Sie eine direkte Verbindung zu den Runtime-Instanzen herstellen. Dazu werden neben der Runtime-Instanz keine weiteren Instanzen benötigt. Voraussetzungen Der Port der Runtime-Instanz für die direkte Kommunikation ( 11740 ) muss weitergeleitet werden. Hinweise: Dies ist nicht die Standardkonfiguration für eine Runtime-Instanz, sondern die Instanz muss nachträglich konfiguriert werden! Die Mehrfachkonfiguration desselben Ports auf demselben Zielgerät ist nicht möglich. Es ist jedoch möglich, dass Sie für die zweite Runtime-Instanz den nächsten freien Port verwenden. Zum Beispiel: 11741:11740 usw. Es existiert ein konfiguriertes, erreichbares Gateway. Dieses Gateway muss nicht im selben Netzwerk sein. Wählen Sie in der Registerkarte Kommunikation ein aktives Gateway aus. Anschließend tragen Sie auf der Seite des zu verbindenden Geräts die IP-Adresse Ihres Hostsystems ein, auf dem die Runtime-Instanz läuft, ein, gefolgt von dem weitergeleiteten Port. Registerkarte Kommunikation : Gateway-Instanz auf Zielgerät Mit Hilfe einer Gateway-Instanz können Sie eine CODESYS -Verbindung zu Ihren Runtime-Instanzen herstellen. Voraussetzungen: Der Port der Gateway-Instanz für die Gateway-Kommunikation ( 1217 ) muss weitergeleitet werden. Dies ist die Standardkonfiguration für eine Gateway-Instanz. Gateway- und Runtime-Instanzen müssen sich im gleichen Container-Netzwerk befinden. Dies ist die Standardkonfiguration. Um nun eine Verbindung zu einer ausgeführten Instanz aufzubauen, erstellen Sie ein neues CODESYS -Projekt mit dem Gerät CODESYS Virtual Control for Linux SL . Erstellen Sie ein neues Gateway und tragen Sie dabei für das neue Gateway im Dialog Gateway in das Feld IP-Adress die IP-Adresse Ihres Hostrechners ein, auf dem die CODESYS Virtual Control for Linux SL läuft. Wählen Sie das neue Gateway aus und führen Sie einen Netzwerk-Scan durch. Die konfigurierten und gestarteten Runtime-Instanzen werden angezeigt. " }, 
{ "title" : "Konfiguration CODESYS Virtual Control for Linux SL ", 
"url" : "_rtsl_reference.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ CODESYS Virtual Control for Linux SL \/ Konfiguration CODESYS Virtual Control for Linux SL ", 
"snippet" : "Einstellungsmöglichkeiten Instanzen Konfiguration Wert Beschreibung Autostart TRUE oder FALSE Automatischer Start der Instanz beim Start\/Boot des Zielgeräts. Dabei werden die Abhängigkeiten aufgelöst und die Instanzen in der korrekten Reihenfolge gestartet. Capabilities Komma-separierte Liste, Beisp...", 
"body" : "Einstellungsmöglichkeiten Instanzen Konfiguration Wert Beschreibung Autostart TRUE oder FALSE Automatischer Start der Instanz beim Start\/Boot des Zielgeräts. Dabei werden die Abhängigkeiten aufgelöst und die Instanzen in der korrekten Reihenfolge gestartet. Capabilities Komma-separierte Liste, Beispiele: cap_sys_admin, cap_sched, cap_chown, cap_ipc_lock Berechtigungen für die Instanz auf dem Zielgerät. Die Vorauswahl wird für die Einhaltung von Echtzeit benötigt. Die Einstellungen für Docker siehe: Docker docs: Runtime Privilege and Linux capabilities Abhängigkeiten String Kommaseparierte Liste von Instanzen, von denen die aktuelle Instanz abhängt. Die hier gelisteten Instanzen werden also vorher gestartet, um den Shared Memory zur Verfügung zu stellen. Wenn die eingegebenen Instanz nicht existiert, wird eine Fehlermeldung ausgegeben. Inst_B,Inst_C Wenn die aktuelle Instanz (beispielsweise Inst_A ) mit dem Befehl Selektierte starten gestartet wird, erscheint eine Warnung, dass auch Inst_B und Inst_C gestartet werden müssen. Wenn dies bestätigt wird, werden diese beiden Instanzen zuerst hochgefahren und dann die Instanz Inst_A . Hostname String Netzwerkname der Instanz Standardwert ist der Instanzname Image String Verwendetes Image für die Instanz IPC String Grundsätzlich sind alle Werte erlaubt, die auch in den Docker Docs für das Feld eingetragen sind. Eine Validierung des Felds findet nur dann statt, wenn das Feld den container: -Prefix enthält. Laut Docker Docs dient dieser dazu, einen bereits bestehenden Shared Memory zu verwenden („joinen“). Dieser Shared Memory muss auf der hinter container: genannten Instanz durch das Schlüsselwort shareable erstellt werden. Um sicherzustellen, dass der Shared Memory verfügbar ist, wenn die Instanz startet, muss auf der hinter dem container: -Präfix eingetragenen Instanz eine entsprechende Dependency definiert sein. shareable none container:Inst_first Lizenzserver String IP-Adressen der Lizenzserver Angabe in einer kommaseparierten Liste Beispiel: 192.168.0.1,10.0.0.1,172.17.0.2 Mounts Kommaseparierte Liste Mounts der Instanz zu dem Host. Anzugeben in der Form Host path:Instance path Hinweise: Pfade sind absolut Hostpfad enthält Instanznamen. Für Defaultmounts (data \/ conf) darf dieser Pfad nicht verändert werden. Netzwerk String Netzwerk, in dem die Instanz auf dem Host eingebunden wird. Siehe: Docker docs: network settings Hinweis: Es kann nur ein Netzwerk angegeben werden. Docker-Netzwerke erlauben es Containern untereinander zu kommunizieren. Wenn das konfiguierte Docker-Netzwerk noch nicht existiert, wird es neu erstellt. Die IP-Adresse der jeweiligen Instanz innerhalb dieses Netzwerk kann über das Feld Nic konfiguiert werden. Weiterführende Informationen zu Docker-Netzwerken finden Sie in der Docker Dokumentation . Nic String Konfiguration der Netzwerkadapter des Zielsystems, die einer Instanz exklusiv zugeordnet werden. Diese Konfiguration wird benötigt, falls Ethernet-basierte Feldbusse verwendet werden sollen. Zur Konfiguration wird folgendes Format verwendet: <Nic>\/<IP>\/<network mask>,<Nic2>\/<IP2>\/<network mask2>,... Mehrere Netzwerkadapter können mit einer kommaseparierten Liste angegeben werden. Beispiele: Gewünschte Konfiguration Konfiguration \"Nic\" NIC : eno1 IP : 192.168.0.100 Maske: 255.255.255.0 → \/24 eno1\/192.168.0.100\/24 NIC : eno1 IP : - Maske: - NIC2 : eno2 IP2 : 192.168.0.100 Maske2: 255.255.248.0 → \/21 eno1,eno2\/102.168.0.100\/21 NIC : eno1 IP : - Maske: - NIC2 : eno2 IP2 : - Maske2: - eno1,2eno2 Hinweise: Ein Adapter kann nur einer Instanz zugeordnet werden. Dieser Adapter ist damit auch auf dem Zielsystem nicht mehr verfügbar. Die IP Adresse muss zusammen mit der dazugehörigen Netzwerkmaske angegeben werden. Die Netzwerkmaske wird mit einem Suffix angegeben. z. B.: \"\/24\", oder \"\/21\". Es ist nicht möglich, einem Adapter mehrere IP-Adressen zuzuweisen. Ports Komma-separierte Liste, z. B.: 1217:1217, 8081:8080 Verwendete Ports der Runtime-Instanz Anzugeben in der Form HostPort:InstancePort (komma-separierte Liste) Hinweis: Ein Host-Port ist nicht mehrfach belegbar Häufige Anwendungsfälle oder Ports siehe: CODESYS ControlBeispiele: Gateway 1217. Webvisu (https) 443, OPC UA 4840 Produktyp Runtime \/ Gateway Typ des Produkts: Runtime oder Gateway Dieser Wert kann nicht geändert werden. Technologie Docker \/ Podman Verwendete Container-Technologie auf dem Zielsystem Dieser Wert kann nicht geändert werden. Nächster Start im Wartungsbetrieb TRUE oder FALSE Nur für CODESYS Virtual Edge Gateway for Linux und CODESYS Edge Gateway for Linux Diese Einstellung legt fest, ob das Edge Gateway im Wartungsmodus gestartet wird oder nicht. In diesem Modus kann eine Verbindung zwischen dem Edge Gateway und dem Automatisierungsserver über den CODESYS Automation Server Connector konfiguriert werden. Verwenden Sie diesen Modus nur in einer sicheren Umgebung Dieser Modus wird nach 30 Minuten oder bei einem Neustart des Gateways oder nach Beendigung der Konfiguration wieder deaktiviert. " }, 
{ "title" : "CODESYS TargetVisu for Linux SL ", 
"url" : "_rtsl_target_visu_for_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ CODESYS TargetVisu for Linux SL ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Konfigurieren der CODESYS TargetVisu for Linux SL ", 
"url" : "_rtsl_target_visu_for_linux.html#UUID-016a8869-7c4e-0746-0a61-0b8ff307940e_section-idm234374412744104", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ CODESYS TargetVisu for Linux SL \/ Konfigurieren der CODESYS TargetVisu for Linux SL ", 
"snippet" : "Standardmäßig zeigt die Target-Visualisierung beim Start mehrere Dialoge an, in denen die benötigten Informationen zur Herstellung einer Verbindung zur Steuerung abgefragt werden. Diese Informationen werden gespeichert und können später über die Konfiguration der Target-Visualisierung angepasst oder...", 
"body" : "Standardmäßig zeigt die Target-Visualisierung beim Start mehrere Dialoge an, in denen die benötigten Informationen zur Herstellung einer Verbindung zur Steuerung abgefragt werden. Diese Informationen werden gespeichert und können später über die Konfiguration der Target-Visualisierung angepasst oder gelöscht werden. Sie können diese Parameter auch vor dem ersten Start der Visualisierung definieren. Dann werden beim Starten der Visualisierung keine Dialoge mehr angezeigt. Settings Applikation Der Name der Applikation, in der die Visualisierung läuft CODESYS Password Passwort des CODESYS -Anwenders, mit dem sich die Visualisierung bei der Steuerung anmeldet. CODESYS User Benutzername, mit dem sich die Visualisierung bei der Steuerung anmeldet. Host Name Der Hostname der SPS, mit der sich die Visualisierung verbindet. Der Name kann auf den meisten Linux-Distributionen über den Befehl hostname -Befehl herausgefunden werden. Um sich mit einer Steuerung auf dem aktuellen Zielgerät zu verbinden, muss hier der Hostname dieser SPS definiert werden. Einstellungen beim nächsten Start anfordern Die Einstellungen werden zurückgesetzt und die Target-Visualisierung wird beim nächsten Start alle Informationen über entsprechende Dialoge abfragen. " }, 
{ "title" : "Autostart ", 
"url" : "_rtsl_target_visu_for_linux.html#UUID-016a8869-7c4e-0746-0a61-0b8ff307940e_section-idm234374413098957", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ CODESYS TargetVisu for Linux SL \/ Autostart ", 
"snippet" : "Nach einem Neustart des Zielgeräts öffnet sich die Target-Visualisierung automatisch. Es kann bis zu einer Minute dauern, bis alle Module geladen sind und die Anwendung erscheint. Beim ersten Verbindungsaufbau mit der SPS kann es noch etwas länger dauern, da die in der Visualisierung verwendeten Ass...", 
"body" : "Nach einem Neustart des Zielgeräts öffnet sich die Target-Visualisierung automatisch. Es kann bis zu einer Minute dauern, bis alle Module geladen sind und die Anwendung erscheint. Beim ersten Verbindungsaufbau mit der SPS kann es noch etwas länger dauern, da die in der Visualisierung verwendeten Assets einmalig übertragen werden müssen. " }, 
{ "title" : "Vor CODESYS TargetVisu for Linux SL Version 4.13.0.0 ", 
"url" : "_rtsl_target_visu_for_linux.html#UUID-016a8869-7c4e-0746-0a61-0b8ff307940e_section-idm234461986157731", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ CODESYS TargetVisu for Linux SL \/ Autostart \/ Vor CODESYS TargetVisu for Linux SL Version 4.13.0.0 ", 
"snippet" : "Der Autostart wird durch eine .desktop -Datei realisiert. Bei der Installation des Package gibt es 2 Möglichkeiten: Ablage der Datei codesysvisualization.desktop unter \/etc\/xdg\/autostart\/ Anhängen des Startskripts in ~\/.xinitrc oder alternativ \/etc\/X11\/xinit Wenn in Ihrem System diese Verzeichnisse ...", 
"body" : "Der Autostart wird durch eine .desktop -Datei realisiert. Bei der Installation des Package gibt es 2 Möglichkeiten: Ablage der Datei codesysvisualization.desktop unter \/etc\/xdg\/autostart\/ Anhängen des Startskripts in ~\/.xinitrc oder alternativ \/etc\/X11\/xinit Wenn in Ihrem System diese Verzeichnisse nicht vorhanden sind oder Sie nicht damit arbeiten, müssen Sie den Autostart selbst konfigurieren. Die Start- und Stopp-Skripte liegen unter \/opt\/codesysvisualization\/scripts . Weitere Informationen zur Verzeichnisstruktur finden Sie unter https:\/\/content.helpme-codesys.com\/de\/CODESYS%20Control\/_rtsl_linux_installation_without_pm.html CODESYS TargetVisu for Linux SL verändert nicht das Anmeldeverhalten des aktuellen Linux-Account. Wenn Ihr Linux-Account das automatische Anmelden deaktiviert hat, so ist nach wie vor eine Authentifizierung zum Starten der Visualisierung notwendig. " }, 
{ "title" : "Ab CODESYS TargetVisu for Linux SL Version 4.13.0.0 ", 
"url" : "_rtsl_target_visu_for_linux.html#UUID-016a8869-7c4e-0746-0a61-0b8ff307940e_section-idm234461987255572", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Produktspezifische Konfiguration \/ CODESYS TargetVisu for Linux SL \/ Autostart \/ Ab CODESYS TargetVisu for Linux SL Version 4.13.0.0 ", 
"snippet" : "Der Autostart wird durch systemd realisiert. Die Unit-Datei liegt unter ~\/.config\/systemd\/user\/codesysvisualization.service . Um den Autostart selbst zu konfigurieren können Sie mit systemctl --user disable codesysvisualization den Service dauerhaft deaktivieren oder die Unit-Datei anpassen und mit ...", 
"body" : "Der Autostart wird durch systemd realisiert. Die Unit-Datei liegt unter ~\/.config\/systemd\/user\/codesysvisualization.service . Um den Autostart selbst zu konfigurieren können Sie mit systemctl --user disable codesysvisualization den Service dauerhaft deaktivieren oder die Unit-Datei anpassen und mit systemctl --user daemon-reload neu laden.“ " }, 
{ "title" : "CODESYS Virtual Safe Control for Linux SL ", 
"url" : "_rtsl_codesys_virtual_for_linux_control_sl-1825956.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Virtual Safe Control for Linux SL ", 
"snippet" : "Die CODESYS Virtual Safe Control for Linux SL ist eine hardwareunabhängige, funktional sichere Steuerung, die als eigenständiges Laufzeitsystem parallel zur funktionalen Steuerung CODESYS Virtual Control SL läuft. Beachten Sie, dass diese Dokumentation nur zu Informationszwecken zur Verfügung gestel...", 
"body" : "Die CODESYS Virtual Safe Control for Linux SL ist eine hardwareunabhängige, funktional sichere Steuerung, die als eigenständiges Laufzeitsystem parallel zur funktionalen Steuerung CODESYS Virtual Control SL läuft. Beachten Sie, dass diese Dokumentation nur zu Informationszwecken zur Verfügung gestellt wird.Einschränkungen und Informationen zur Sicherheit und Zertifizierung entnehmen Sie bitte dem Sicherheitshandbuch H1 - SafetyManual.pdf . Bei Betrieb der CODESYS Virtual Safe Control for Linux SL müssen die Sicherheitsanforderungen des Security-Whitepapers beachtet werden. Für weitere Informationen siehe: CODESYS Security Whitepaper Für weitere Informationen zur Entwicklung von sicherheitskritischen Applikationen mit CODESYS siehe: Sicherheitshandbuch H1 - SafetyManual.pdf , das im Verzeichnis ..\/<User>\/CODESYS Virtual Safe Control Linux SL\/Delivery\/Manuals abgelegt ist. CODESYS Safety Extension Eine Anleitung, wie Sie eine CODESYS Virtual Safe Control for Linux SL initial aufsetzen, ist im Szenario Szenario \"The Safe House\": vPLC + vSafe + ProfiSafe + Time Provider + Lizenzserver beschrieben. " }, 
{ "title" : "Zeitstempel-Exceptions ", 
"url" : "_rtsl_timestamp_exceptions.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Virtual Safe Control for Linux SL \/ Zeitstempel-Exceptions ", 
"snippet" : "Im folgenden werden Fehler beschrieben, die beim Validieren des Zeitverhaltens der sicheren Steuerung auftreten können. Zum Validieren des Zeitverhaltens wird eine unabhängige zweite Zeitbasis benötigt...", 
"body" : "Im folgenden werden Fehler beschrieben, die beim Validieren des Zeitverhaltens der sicheren Steuerung auftreten können. Zum Validieren des Zeitverhaltens wird eine unabhängige zweite Zeitbasis benötigt " }, 
{ "title" : "Die verschiedenen Zeitstempel ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm234959765203734", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Virtual Safe Control for Linux SL \/ Zeitstempel-Exceptions \/ Die verschiedenen Zeitstempel ", 
"snippet" : "Es gibt 3 Zeitstempel, die zur Validierung des Zeitverhaltens der sicheren Steuerung verwendet werden. Remote Timestamp : Zeitstempel, der auf dem Time Provider-Rechner genommen wurde. Sample Timestamp : Zeitstempel, der lokal zum Zeitpunkt des Empfangs genommen wurde. Local Timestamp : Zeitstempel,...", 
"body" : "Es gibt 3 Zeitstempel, die zur Validierung des Zeitverhaltens der sicheren Steuerung verwendet werden. Remote Timestamp : Zeitstempel, der auf dem Time Provider-Rechner genommen wurde. Sample Timestamp : Zeitstempel, der lokal zum Zeitpunkt des Empfangs genommen wurde. Local Timestamp : Zeitstempel, der lokal zum Zeitpunkt der Ausführung der Applikation genommen wurde. " }, 
{ "title" : "Mögliche Fehlermeldungen ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm234959951496687", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Virtual Safe Control for Linux SL \/ Zeitstempel-Exceptions \/ Mögliche Fehlermeldungen ", 
"snippet" : "Alle Fehler durch den Time Provider geben vier Hex-Zahlenwerte zurück. Bei diesen Werten handelt es sich um Zeitwerte in Mikrosekunden. Sie haben folgende Bedeutung: Wert 1: Zeit zwischen den letzten beiden Local Timestamps Wert 2: Zeit zwischen den letzten beiden Remote Timestamps Wert 3: Zeit zwis...", 
"body" : "Alle Fehler durch den Time Provider geben vier Hex-Zahlenwerte zurück. Bei diesen Werten handelt es sich um Zeitwerte in Mikrosekunden. Sie haben folgende Bedeutung: Wert 1: Zeit zwischen den letzten beiden Local Timestamps Wert 2: Zeit zwischen den letzten beiden Remote Timestamps Wert 3: Zeit zwischen den letzten beiden Sample Timestamps Wert 4: Zeit zwischen dem Empfang des letzten Remote Timestamps und Auswertung dieses Zeitstempels Die Reihenfolge der Werte stimmt mit der in der Fehlermeldung überein. Bei der Zeitvalidierung gibt es 3 mögliche Fehlermeldungen. Im Folgenden befindet sich eine Beschreibung der Prüfung, die zu diesem Fehler führt, des auftretenden Fehlers und einige mögliche Ursachen des Fehlers. In der Registerkarte Log ist immer nur der erste aufgetretene Fehler aufgezeichnet, da die IEC-Applikation nach diesem Fehler bereits gestoppt wurde. Zur genaueren Analyse der Ursache des Fehlers können die vier Hex-Zahlenwerte, die mit der Fehlermeldung ausgegeben werden, betrachtet werden. " }, 
{ "title" : "Meldung: Plausibility check of the local timestamp to the cycle time ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm43495995265356", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Virtual Safe Control for Linux SL \/ Zeitstempel-Exceptions \/ Mögliche Fehlermeldungen \/ Meldung: Plausibility check of the local timestamp to the cycle time ", 
"snippet" : "Prüfung: Vergleich der eingestellten Zykluszeit und der tatsächlich vergangenen Zeit seit dem letzten Zyklus. Verwendet wird hierfür der Local Timestamp . Fehler: Die interne Zeitmessung, die jeden Zyklus stattfindet, zeigt, dass die vergangene Zeit (nach dem internen Clock des Rechners) mehr als 5%...", 
"body" : "Prüfung: Vergleich der eingestellten Zykluszeit und der tatsächlich vergangenen Zeit seit dem letzten Zyklus. Verwendet wird hierfür der Local Timestamp . Fehler: Die interne Zeitmessung, die jeden Zyklus stattfindet, zeigt, dass die vergangene Zeit (nach dem internen Clock des Rechners) mehr als 5% von der eingestellten Zykluszeit abweicht. Häufige Ursachen: Probleme beim Scheduling der sicheren Applikation. " }, 
{ "title" : "Meldung: Plausibility check of the remote timestamp to the cycle time ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm43495995331862", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Virtual Safe Control for Linux SL \/ Zeitstempel-Exceptions \/ Mögliche Fehlermeldungen \/ Meldung: Plausibility check of the remote timestamp to the cycle time ", 
"snippet" : "Prüfung: Vergleich der eingestellten Zykluszeit mit dem Zeitraum zwischen den letzten beiden Sample Timestamps . Verwendet wird der Sample Timestamp . Es werden immer die letzten gültigen empfangenen Zeitstempel innerhalb eines Zyklus verwendet. Die Vorherigen werden verworfen. Somit führt ein ungül...", 
"body" : "Prüfung: Vergleich der eingestellten Zykluszeit mit dem Zeitraum zwischen den letzten beiden Sample Timestamps . Verwendet wird der Sample Timestamp . Es werden immer die letzten gültigen empfangenen Zeitstempel innerhalb eines Zyklus verwendet. Die Vorherigen werden verworfen. Somit führt ein ungültiger Zeitstempel nicht sofort zu einem Systemfehler. Fehler: Es wurde länger als ein Zyklus kein neuer Remote Timestamp mehr empfangen. Häufige Ursachen: Time Provider ist ausgefallen oder gestoppt Keine Netzwerkverbindung zwischen Steuerung und Time Provider Netzwerkausfall Schwere Scheduling-Probleme " }, 
{ "title" : "Meldung: Plausibility check of remote timestamp to local timestamp ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm43495995376508", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Virtual Safe Control for Linux SL \/ Zeitstempel-Exceptions \/ Mögliche Fehlermeldungen \/ Meldung: Plausibility check of remote timestamp to local timestamp ", 
"snippet" : "Prüfung: Vergleich des Abstands der letzten beiden verwendeten Sample Timestamps und des Abstands der letzten beiden verwendeten Remote Timestamps . Verwendet werden der Sample Timestamp und der Remote Timestamp . Fehler: Die Differenz zwischen dem Abstand der letzten beiden Sample Timestamps und de...", 
"body" : "Prüfung: Vergleich des Abstands der letzten beiden verwendeten Sample Timestamps und des Abstands der letzten beiden verwendeten Remote Timestamps . Verwendet werden der Sample Timestamp und der Remote Timestamp . Fehler: Die Differenz zwischen dem Abstand der letzten beiden Sample Timestamps und dem Abstand der letzten beiden Remote Timestamps ist größer als die erlaubte Toleranz von 5%. Häufige Ursache: Scheduling-Probleme beim Time Provider Scheduling-Probleme des Threads zum Empfang der Zeitstempel Verzögerungen im Übertragungsnetzwerk (Switches etc.) " }, 
{ "title" : "Applikationsstart ", 
"url" : "_rtsl_application_start.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Virtual Safe Control for Linux SL \/ Applikationsstart ", 
"snippet" : "Für die CODESYS Virtual Safe Control SL muss ein Start der Bootapplikation vom Anwender bestätigt werden. Ab CODESYS Safety Extension Version 4.3.0.0 wird der neue Zustand ( waiting for confirmation ) im Projektbaum und im Status der aktiven Applikation angezeigt. Bei CODESYS Safety Extension kleine...", 
"body" : "Für die CODESYS Virtual Safe Control SL muss ein Start der Bootapplikation vom Anwender bestätigt werden. Ab CODESYS Safety Extension Version 4.3.0.0 wird der neue Zustand ( waiting for confirmation ) im Projektbaum und im Status der aktiven Applikation angezeigt. Bei CODESYS Safety Extension kleiner Version 4.3.0.0 wird der Zustand nicht angezeigt, weder im Gerätebaum noch im Status. Der Zustand kann jedoch aus dem Log der sicheren Steuerung entnommen werden. Die Bestätigung zum Start der geladenen Bootapplikation erfolgt über den Funktionsbaustein StartBootApp Bedingungen für den Start der Bootapplikation: Der aktuelle Wert des FB-Ausgangs SafeApplication.BootAppConfirmation muss dem Funktionsbaustein StartBootApp übergeben werden. Eine ClientID muss angegeben werden. Die ClientID ist in der CFG-Datei des Laufzeitsystems definiert. Standardeinstellung für die Standard-Applikation: 16#ED387206 . Die ClientID, Firmware-Version, AppID und der Wert von SafeApplication.BootAppConfirmtion müssen an die Steuerung gesendet werden. Dies erfolgt über den Funktionsbaustein StartBootApp . Für weitere Informationen siehe: CODESYS Safety Extension . " }, 
{ "title" : "CODESYS Virtual Safe Time Provider ", 
"url" : "_rtsl_virtual_safe_time_provider.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Virtual Safe Time Provider ", 
"snippet" : "Der CODESYS Virtual Safe Time Provider ist eine Standard-Schnittstelle, über die der Anwender eine zweite und externe Zeitbasis an das CODESYS Virtual Safe Control übergeben kann. Die Implementierung erfolgt als Client, der auf einem anderen System mit einer unabhängigen Zeitbasis laufen muss....", 
"body" : "Der CODESYS Virtual Safe Time Provider ist eine Standard-Schnittstelle, über die der Anwender eine zweite und externe Zeitbasis an das CODESYS Virtual Safe Control übergeben kann. Die Implementierung erfolgt als Client, der auf einem anderen System mit einer unabhängigen Zeitbasis laufen muss. " }, 
{ "title" : "Installation ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm234964887312564", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Virtual Safe Time Provider \/ Installation ", 
"snippet" : "Die Installation des CODESYS Virtual Safe Time Provider SL erfolgt über der CODESYS Control SL Deploy Tool . Für weitere Informationen siehe Szenario \"The Safe House\": vPLC + vSafe + ProfiSafe + Time Provider + Lizenzserver. Der CODESYS Virtual Safe Time Provider SL darf nicht auf dem selben Host wi...", 
"body" : "Die Installation des CODESYS Virtual Safe Time Provider SL erfolgt über der CODESYS Control SL Deploy Tool . Für weitere Informationen siehe Szenario \"The Safe House\": vPLC + vSafe + ProfiSafe + Time Provider + Lizenzserver. Der CODESYS Virtual Safe Time Provider SL darf nicht auf dem selben Host wie das CODESYS Virtual Safe Control SL laufen. " }, 
{ "title" : "Funktionsweise ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm234964887538634", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Virtual Safe Time Provider \/ Funktionsweise ", 
"snippet" : "Der Time Provider dient als zweite Zeitquelle für das CODESYS Virtual Safe Control SL und schickt einen Zeitstempel in einem definierten Intervall als Nachricht über das Netzwerk. Diese Nachricht kann dann von verschiedenen Empfängern ( CODESYS Virtual Safe Control l SL, redundanter Time Provider ) ...", 
"body" : "Der Time Provider dient als zweite Zeitquelle für das CODESYS Virtual Safe Control SL und schickt einen Zeitstempel in einem definierten Intervall als Nachricht über das Netzwerk. Diese Nachricht kann dann von verschiedenen Empfängern ( CODESYS Virtual Safe Control l SL, redundanter Time Provider ) empfangen und ausgewertet werden. Das CODESYS Virtual Safe Control SL führt die Applikation mit einer definierten Zykluszeit aus, in der mindestens ein Zeitstempel eines externen Zeitgebers ankommen muss. Das Sendeintervall des Time Provider sollte kleiner als die halbe Zykluszeit der Applikation konfiguriert werden. Um die Stabilität aufgrund von Netzwerk- oder Schedulingproblemen des Time Provider und damit der CODESYS Virtual Safe Control SL zu erhöhen, kann der Time Provider redundant ausgeführt werden. Hierbei wird zwischen zwei Arten unterschieden. " }, 
{ "title" : "Time Provider -Redundanz ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm43496653769816", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Virtual Safe Time Provider \/ Funktionsweise \/ Time Provider -Redundanz ", 
"snippet" : "Bei der Time Provider -Redundanz laufen zwei Time Provider -Instanzen auf zwei voneinander unabhängigen Hosts. Eine Instanz agiert dabei als aktiver Sender, die andere Instanz überwacht passiv das Senden der Zeitstempel. Um die Funktionalität zu nutzen, müssen zwei Time Provider -Instanzen gestartet...", 
"body" : "Bei der Time Provider -Redundanz laufen zwei Time Provider -Instanzen auf zwei voneinander unabhängigen Hosts. Eine Instanz agiert dabei als aktiver Sender, die andere Instanz überwacht passiv das Senden der Zeitstempel. Um die Funktionalität zu nutzen, müssen zwei Time Provider -Instanzen gestartet werden und der Redundanzparameter muss in beiden Instanzen auf TRUE gesetzt werden. Sobald das Senden des Zeitstempels der aktiven Instanz verzögert wird, oder ausbleibt, übernimmt die passive Instanz direkt das Senden mit dem letzten bekannten Offset der aktiven Instanz. Somit kommt es zu keinen Ausfällen der CODESYS Virtual Safe Control SL. Dabei ist es wichtig, dass beide Instanzen auf dem gleichen Netzwerk laufen. Nur dann kann die passive Instanz die gesendeten Nachrichten der aktiven Instanz überwachen. Wenn ein aktiver Time Provider in einem Netzwerk eine andere aktive Instanz auf dem Bus bemerkt, bleibt die Instanz mit der höchstprioren IP-Addresse aktiv und alle anderen Instanzen gehen in den passiven Modus. " }, 
{ "title" : "Netzwerk-Redundanz ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm43496653810142", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Virtual Safe Time Provider \/ Funktionsweise \/ Netzwerk-Redundanz ", 
"snippet" : "Bei der Netzwerk-Redundanz verwenden die Time Provider -Instanzen jeweils ein eigenes Netzwerk im Gegensatz zu der Time Provider -Redundanz. Dennoch ist es notwendig, dass die passive Time Provider -Instanz die Nachrichten der aktiven Instanz empfängt, um bei einer Verzögerung oder Ausbleiben das Se...", 
"body" : "Bei der Netzwerk-Redundanz verwenden die Time Provider -Instanzen jeweils ein eigenes Netzwerk im Gegensatz zu der Time Provider -Redundanz. Dennoch ist es notwendig, dass die passive Time Provider -Instanz die Nachrichten der aktiven Instanz empfängt, um bei einer Verzögerung oder Ausbleiben das Senden zu übernehmen. Die Netzwerk-Redundanz ist aktuell noch nicht implementiert. " }, 
{ "title" : "Konfiguration ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm234964888427036", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Virtual Safe Time Provider \/ Konfiguration ", 
"snippet" : "Option Beschreibung Standardwert -a\/--address Target-IP-Adresse 127.0.0.1 (localhost) -p\/--port Target-Port 60000 -c\/--cycletime Sendeintervall der Time Provider -Zeitstempel in [ms] 3 -P\/--priority SCHED_FIFO Scheduling-Priorität 55 -C\/--cpu_pin CPU-Pinning Alle Threads werden auf eine definierte C...", 
"body" : "Option Beschreibung Standardwert -a\/--address Target-IP-Adresse 127.0.0.1 (localhost) -p\/--port Target-Port 60000 -c\/--cycletime Sendeintervall der Time Provider -Zeitstempel in [ms] 3 -P\/--priority SCHED_FIFO Scheduling-Priorität 55 -C\/--cpu_pin CPU-Pinning Alle Threads werden auf eine definierte CPU gepinnt, angefangen mit dem Wert 0. 0 -r\/--redundancy Redundanzmodus Wenn deaktiviert, sendet der Time Provider sofort Zeitstempel. Wenn aktiviert, sendet der Time Provider nur, wenn kein anderer höherpriorer Time Provider sendet. Für weitere Informationen siehe: Time ProviderDeaktiviert -s\/--syslog Protokollierung des syslog nach \/dev\/log Deaktiviert --stat_print_time Diagnoseintervall in [s] 60 Der Standardwert der IP-Adresse ist 127.0.0.1 (localhost). Sie sollten diesen Wert nur für die Inbetriebnahme und Test verwenden. Der Time Provider liefert eine unabhängige Zeitbasis und darf somit nicht lokal betrieben werden. Wenn Sie den Standardwert verwenden, gibt der Time Provider eine Warnung aus. " }, 
{ "title" : "Diagnose ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm234964888678287", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Virtual Safe Time Provider \/ Diagnose ", 
"snippet" : "Die Fehler, die bei der Auswertung der Zeitstempel auf der Seite der CODESYS Virtual Safe Control SL auftreten können: Der konfigurierte Port ist bereits in Benutzung. Wenn der konfigurierte Port bereits verwendet wird und nicht geöffnet werden kann, wird folgende Meldung ausgegeben: Could not open ...", 
"body" : "Die Fehler, die bei der Auswertung der Zeitstempel auf der Seite der CODESYS Virtual Safe Control SL auftreten können: Der konfigurierte Port ist bereits in Benutzung. Wenn der konfigurierte Port bereits verwendet wird und nicht geöffnet werden kann, wird folgende Meldung ausgegeben: Could not open port <Port number> it is already in use! Das Senden des Zeitstempels in der aktiven Instanz wird verzögert oder findet nicht statt. Wenn ein Zeitstempel des aktiven Senders verzögert wird oder nicht gesendet wird und eine passive Time Provider -Instanz das Senden übernimmt, wird folgende Diagnosemeldung ausgegeben: Started sending: take over from higher priority time provider <priority> Wenn die höherpriore Time Provider -Instanz wieder verfügbar ist und das Senden von der ehemaligen passiven Instanz übernimmt, wird folgende Meldung ausgegeben: Stopped sending: higher priority time provider is active: <priority> Zyklische Statistiken zu den Zeitstempeln (aktive Instanz\/Sender) Die Statistiken zu den versendeten Zeitstempeln werden im konfigurierten Intervall (Option –stat_print_time ) in der Auflösung Mikrosekunden [us] ausgegeben. Dabei wird das minimale sowie das maximale Sendeintervall ausgegeben, sowie eine Durchschnittswert über den konfigurierten Zeitraum: Statistics: min: <minimum sending interval>, max: <maximum sending interval>, avg: <average sending interval> - send time interval Zyklische Statistiken zu den Zeitstempeln (passive Instanz\/Receiver) Da die passive Instanz die versendeten Zeitstempel der aktiven Instanz empfängt, können die empfangenen Informationen zu Diagnosezwecke ausgewertet werden. Die Statistiken werden im konfigurierten Intervall (Option –stat_print_time ) in der Auflösung Mikrosekunden [us], sowie prozentual [%] ausgegeben. Dabei wird das minimale sowie das maximale Intervall ausgegeben, sowie eine Durchschnittswert über den konfigurierten Zeitraum. Statistics: min: <minimum deviation in percent>, max: <maximum deviation in percent>, avg: <average deviation in percent> - remote to sample time deviation Statistics: min: <minimum sample intervall>, max: <maximum sample intervall>, avg: <average sample intervall> - sample time interval Statistics: min: <minimun remote intervall>, max: <maximum remote intervall>, avg: <average remote intervall> - remote time interval Zähler für verlorene Nachrichten Wenn ein Zeitstempel von der aktiven Instanz nicht verschickt wird, wird ein Zähler erhöht und ausgegeben: Statistics: lost messages: <number of lost messages> " }, 
{ "title" : "Performance-Optimierung ", 
"url" : "_rtsl_performance_optimization_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Performance-Optimierung ", 
"snippet" : "Auf dieser Seite zeigen wir Ihnen, wie Sie Ihr Gerät, CODESYS Virtual Control SL und Ihre Anwendung einrichten, damit Sie die bestmögliche Leistung erzielen. Wir geben Ihnen Werkzeuge an die Hand, mit denen Sie den aktuellen Status Ihres Systems überprüfen und bewerten können. Wir empfehlen nachfolg...", 
"body" : "Auf dieser Seite zeigen wir Ihnen, wie Sie Ihr Gerät, CODESYS Virtual Control SL und Ihre Anwendung einrichten, damit Sie die bestmögliche Leistung erzielen. Wir geben Ihnen Werkzeuge an die Hand, mit denen Sie den aktuellen Status Ihres Systems überprüfen und bewerten können. Wir empfehlen nachfolgende Vorgehensweise. Arbeiten Sie diese Schritte in der vorgegebenen Reihenfolge ab. Es macht keinen Sinn, zum nächsten Schritt überzugehen, wenn der aktuelle nicht so optimiert ist, wie es nötig wäre. Überprüfen der HardwareEinrichten von LinuxKonfigurieren des CODESYS-LaufzeitsystemsKonfigurieren der IEC-ApplicationÜberprüfen Sie nach jedem Schritt, ob die zuletzt durchgeführte Änderungen die Optimierungen aus den vorangegangenen Schritten nicht negativ beeinflusst hat. Wenn Sie die gewünschte Performance unter normaler Last erreicht haben, können Sie optional einen Test unter hoher Last mit stress-ng oder iperf durchführen. Sie finden weiterführende Informationen auf folgenden Internetseiten: Linux foundation Linutronix " }, 
{ "title" : "Überprüfen der Hardware ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm4640115908976034154363059654", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Performance-Optimierung \/ Überprüfen der Hardware ", 
"snippet" : "Verwenden Sie keine gemeinsamen Caches für die Prozessorkerne Ihrer Steuerung. Verwenden Sie für Ihr Zielgerät einen physikalischen Adapter für ethernet-basierte Feldbusse, wenn Sie diese einsetzen. Verwenden Sie keine Switch-Architektur....", 
"body" : "Verwenden Sie keine gemeinsamen Caches für die Prozessorkerne Ihrer Steuerung. Verwenden Sie für Ihr Zielgerät einen physikalischen Adapter für ethernet-basierte Feldbusse, wenn Sie diese einsetzen. Verwenden Sie keine Switch-Architektur. " }, 
{ "title" : "Einrichten von Linux ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm43415437655754", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Performance-Optimierung \/ Einrichten von Linux ", 
"snippet" : "Verwenden Sie einen Echtzeit-Kernel. Wir empfehlen die Verwendung des RT-Preempt-Kernels ( https:\/\/rt.wiki.kernel.org ) für Ihr Linux-System. Bei Debian- \/ Ubuntu-Distributionen finden Sie einen RT-Kernel als Package, das Sie einfach über apt installieren können. Details dazu finden Sie im Handbuch ...", 
"body" : "Verwenden Sie einen Echtzeit-Kernel. Wir empfehlen die Verwendung des RT-Preempt-Kernels ( https:\/\/rt.wiki.kernel.org ) für Ihr Linux-System. Bei Debian- \/ Ubuntu-Distributionen finden Sie einen RT-Kernel als Package, das Sie einfach über apt installieren können. Details dazu finden Sie im Handbuch Ihrer Distribution. Auf Debian-Systemen sudo apt-get install linux-image-rt-amd64 Überprüfung, welchen Kernel Sie verwenden, beispielsweise mit dem Befehl uname -a . Vermeiden Sie die Verwendung eines Window-Managers, GUI\/X-Servers oder Ähnliches auf Ihrem System. Die Verwendung der genannten Tools wird die Echtzeitfähigkeiten Ihres Systems beeinträchtigen, was zu einem hohen Jitter bei der IEC-Anwendung führt. Test Verwendung von \"rt-tools\": Installieren von \"rt-tools\" :  sudo apt install rt-tests Starten von \"cyclictest\" :  sudo cyclictest -p 99 -t -m Der Befehl man cyclictest zeigt Ihnen weitere Kommandozeilenoptionen, mit denen Sie mehr oder bestimmte Leistungsaspekte Ihres Systems besser messen können. Ob der mit \"cyclictest\" ermittelte Wert als \"gut\" angesehen werden kann, hängt von Ihrer Hardware ab. Wenn Sie einen sehr starken Prozessor einsetzen (beispielsweise Intel Core i7), sollten Sie eine niedrige 1-stellige Zahl als Maximum haben. Wenn Sie einen alten ARM-Prozessors einsetzen, könnte 100 ein gutes Ergebnis sein. Optimierungsmöglichkeiten Nach dem Verändern jeder Einstellung oder Kombination von Einstellungen sollten Sie das Programm \"cyclictest\" ausführen, um die Effektivität der Änderungen zu verifizieren. Diese Einstellungen sind nicht persistiert und müssen deshalb nach einem Systemstart\/Reboot neu gesetzt werden. Deaktivieren Sie den CPU-Energiesparmodus. Deaktivieren Sie Hyperthreading. Sie können das Hyperthreading beispielsweise mit folgendem Befehl deaktivieren: echo off | sudo tee \/sys\/devices\/system\/cpu\/smt\/control Deaktivieren Sie CPU-Frequenzskalierung und -Umschaltung so weit wie möglich. Setzen Sie beispielsweise die minimale und maximale CPU-Frequenz auf denselben (festen) Wert. Deaktivieren Sie den RealTime-Throttling-Mechanismus des Linux-Kernels, da dieser zu Jitter auf Ihrem System führen kann. Für weitere Informationen siehe: The Linux Foundation: Scheduling - RT Throttling Sie können das RealTime-Throttling beispielsweise mit folgendem Befehl deaktivieren: echo -1 > \/proc\/sys\/kernel\/sched_rt_runtime_us Prüfen und ändern Sie den Scheduling\/Scaling Governor. Prüfen des verwendeten Scheduling\/Scaling Governor: cat \/sys\/devices\/system\/cpu\/cpu0\/cpufreq\/scaling_governor Ändern des verwendeten Scheduling\/Scaling Governors (als root\/admin ) auf Performance : echo \"performance\" > \/sys\/devices\/system\/cpu\/cpu0\/cpufreq\/scaling_governor\n# set it for all available cores:\necho \"performance\" > \/sys\/devices\/system\/cpu\/cpu1\/cpufreq\/scaling_governor\necho \"performance\" > \/sys\/devices\/system\/cpu\/cpu2\/cpufreq\/scaling_governor\necho \"performance\" > \/sys\/devices\/system\/cpu\/cpu3\/cpufreq\/scaling_governor Beachten Sie, dass der Scaling Governor nach jedem Systemstart neu gesetzt werden muss. Sie können ihn auch über die Kernelkonfiguration setzen. Der Kerneltreiber intel_pstate kann die korrekte Einstellung erschweren. Überprüfen Sie deshalb Ihre Konfiguration mit dem Befehl cpufreq-info . Sie können auch Programme wie cpu-freq-utils verwenden. Dies könnte mit den Intel-Pstate-Treibern interferieren. Diese Treiber benötigen normalerweise einen anderen Ansatz, um die CPU-Frequenz festzulegen. Für weitere Informationen siehe https:\/\/www.kernel.org\/doc\/Documentation\/cpu-freq\/governors.txt Deaktivieren Sie im Bios HyperV , falls verfügbar. " }, 
{ "title" : "Konfigurieren des CODESYS-Laufzeitsystems ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm4554832147912034154456684842", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Performance-Optimierung \/ Konfigurieren des CODESYS-Laufzeitsystems ", 
"snippet" : "Erstellen Sie eine Testanwendung, die in etwa die Anwendung beschreibt, für die Sie Ihr System optimieren möchten (in Bezug auf benötigte Ressourcen, erforderliche Leistung und Projektgröße). Sie können dies iterativ tun: Erstellen Sie zunächst eine sehr grobe Annäherung und erweitern Sie diese dann...", 
"body" : "Erstellen Sie eine Testanwendung, die in etwa die Anwendung beschreibt, für die Sie Ihr System optimieren möchten (in Bezug auf benötigte Ressourcen, erforderliche Leistung und Projektgröße). Sie können dies iterativ tun: Erstellen Sie zunächst eine sehr grobe Annäherung und erweitern Sie diese dann, um der tatsächlichen Applikation immer näher zu kommen. Test Wenn die Applikation läuft, überprüfen Sie die Taskkonfiguration. Öffnen Sie die Taskkonfiguration und wählen Sie die Registerkarte Monitor . Min. Jitter (µs) \/ Max. Jitter (µs) Die Werte sollten so nah wie möglich an den Werten liegen, die durch das Programm \"cycletest\" ermittelt wurden. Details dazu sind im Abschnitt Einrichten von Linux beschrieben. Für weitere Informationen bezüglich Jitter und Latenz siehe: Definitionen Jitter, Latenz Für weitere Informationen zur Registerkarte Überwachung siehe: Registerkarte: Überwachung Durchschnittliche Zykluszeit (µs) \/ Max. Zykluszeit (µs) Der maximale Zyklus sollte nie in die Nähe der konfigurierten Zyklusdauer kommen. Dies führt zu Problemen, sobald das System eine hohe Last erfährt. Halten Sie die Zykluszeit generell immer so niedrig wie möglich. Optimierungsmöglichkeiten Nach dem Verändern jeder Einstellung oder Kombination von Einstellungen sollten Sie das Programm \"cyclictest\" ausführen um die Effektivität der Änderungen zu verifizieren. Splitten Sie lang laufende Tasks in mehrere kleinere Tasks. Während des Betriebs sollte die maximale Zykluszeit der höchstpriorisierten Task niemals die konfigurierte Zykluszeit erreichen. Wenn Sie dies nicht vermeiden können, sollten Sie die konfigurierte Zykluszeit erhöhen, um konsistente Ausführungszeiten zu gewährleisten. Beim Start von Feldbussystemen (beispielsweise EtherCAT \/ PROFINET) kann es durch die Startzyklen zu einer etwas höheren CPU-Last kommen. Für diesen Fall ist es sinnvoll, die CPU-Last kurz nach dem Start der Applikation zu überwachen. Die folgenden Optionen können nicht in CODESYS Virtual Control SL geändert werden, sondern müssen auf dem Host konfiguriert werden: Setzen Sie den Wert für DisableCpuDmaLatency  auf 1: [SysCpuHandling]\nLinux.DisableCpuDmaLatency=1 Beachten Sie, dass dies die Standardeinstellung ab Laufzeitversion 4.11.0.0 ist. Sie können Ihre Laufzeitversion über den Befehl Extras → Linux aktualisieren → System → System-Info überprüfen. Prüfen Sie, ob der Echtzeit-Kernel wirklich verwendet wird. Ab Version 4.11.0.0 können Sie den SPS-Shell-Befehl rt-get kernelinfo verwenden, um dies zu überprüfen. Wenn Sie eine ältere Version haben, können Sie dies direkt auf der Kommandozeile mit dem Befehl uname -a . Wenn der Echtzeit-Kernel nicht verwendet wird, müssen Sie von Grund auf neu starten. " }, 
{ "title" : "Konfigurieren der IEC-Application ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm4633380190436834154474610871", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Performance-Optimierung \/ Konfigurieren der IEC-Application ", 
"snippet" : "Dieser Abschnitt bezieht sich auf Ihre eigentliche Applikation. Test Sie können die Tests aus dem vorherigen Schritt Konfigurieren des CODESYS-Laufzeitsystems verwenden, um Ihre IEC-Anwendung zu testen. Optimierungsmöglichkeiten Nach dem Verändern jeder Einstellung oder Kombination von Einstellungen...", 
"body" : "Dieser Abschnitt bezieht sich auf Ihre eigentliche Applikation. Test Sie können die Tests aus dem vorherigen Schritt Konfigurieren des CODESYS-Laufzeitsystems verwenden, um Ihre IEC-Anwendung zu testen. Optimierungsmöglichkeiten Nach dem Verändern jeder Einstellung oder Kombination von Einstellungen sollten Sie das Programm \"cyclictest\" ausführen um die Effektivität der Änderungen zu verifizieren. Sie können das Multicore -Feature in CODESYS nutzen. Legen Sie die richtigen Prioritäten für Ihre Tasks fest. Wichtige Tasks sollten eine höhere Priorität haben. Zuordnung von IEC-Task-Prioritäten und Linux-Thread-Prioritäten: IEC-Taskpriorität Linux-Priorität -- 88 (SCHED_FIFO) -- 57 (SCHED_FIFO) 0 (höchste Echtzeit Prio) 56 (SCHED_FIFO) 15 (niedrigste Echtzeit Prio) 41 (SCHED_FIFO) 16 (nicht Echtzeit Prio) 0 (SCHED_OTHER) 31 (nicht Echtzeit Prio) 0 (SCHED_OTHER) -- 0 (SCHED_OTHER) Auf einem herkömmlichen Linuxsystem befinden sich die meisten Interrupts (IRQs) und Kernel-Worker auf Linux-Priorität 50. Das Verwenden von Prioritäten (mit hoher Last) oberhalb kann dazu führen, dass Systemfunktionen (Netzwerk\/Speicher) nicht wie gewünscht funktionieren. Sie können die Priorität einer Task in der jeweiligen Taskkonfiguration konfigurieren. Wenn Sie nach allen hier genannten Schritten nicht die gewünschte Performance erreichen, können Sie einen Blick auf die folgenden Abschnitte werfen: Feldbus-spezifische Informationen[Für Experten] - Zusätzliche Tools und Themen" }, 
{ "title" : "Feldbus-spezifische Informationen ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm4494465964555234154489740927", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Performance-Optimierung \/ Feldbus-spezifische Informationen ", 
"snippet" : "Test Überprüfen Sie die Werte Send Time \/ Recv Time auf der EtherCAT-Statusseite Eine x64 CPU mit einem Intel Core i7-Prozessor und einem guten Adapter sollte weniger als 10µs haben. ARM-Prozessoren mit integriertem Chip werden ~50µs oder mehr haben. Überprüfen Sie die Werte Send Time \/ Recv Time au...", 
"body" : "Test Überprüfen Sie die Werte Send Time \/ Recv Time auf der EtherCAT-Statusseite Eine x64 CPU mit einem Intel Core i7-Prozessor und einem guten Adapter sollte weniger als 10µs haben. ARM-Prozessoren mit integriertem Chip werden ~50µs oder mehr haben. Überprüfen Sie die Werte Send Time \/ Recv Time auf der PROFINET-Statusseite. Eine x64 CPU mit einem Intel Core i7-Prozessor und einem guten Adapter sollte weniger als 10µs haben. ARM-Prozessoren mit integriertem Chip werden ~50µs oder mehr haben. Optimierungsmöglichkeiten Um Ihre Prioritäten und benötigten IRQs zu sortieren, können Sie die SPS-Shell-Befehle irq-list und irq-set-prio verwenden. Diese Befehle verwenden die normalen Linux-Prioritäten und nicht die IEC-Prioritäten. Diese Optimierung ist nicht in CODESYS Virtual Control SL möglich, sondern auf dem Host-System. Verwenden Sie einen eigenen\/separaten Netzwerkadapter für die Geräte. Für weitere Informationen siehe: EtherCAT PROFINET Ethernet\/IP CANbus, CANopen " }, 
{ "title" : "[Für Experten] - Zusätzliche Tools und Themen ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm464011317245123415449146407", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Performance-Optimierung \/ [Für Experten] - Zusätzliche Tools und Themen ", 
"snippet" : "Die in diesem Abschnitt beschriebenen Tools und Optionen sind nur für fortgeschrittene Benutzer gedacht und erfordern eigene Nachforschungen, da die zu ergreifenden Maßnahmen stark vom jeweiligen System abhängen. Daher können wir Ihnen keine spezifischen Lösungen anbieten. Kernelshark \/ Kernel-Trace...", 
"body" : "Die in diesem Abschnitt beschriebenen Tools und Optionen sind nur für fortgeschrittene Benutzer gedacht und erfordern eigene Nachforschungen, da die zu ergreifenden Maßnahmen stark vom jeweiligen System abhängen. Daher können wir Ihnen keine spezifischen Lösungen anbieten. Kernelshark \/ Kernel-Trace Dies ist das Programm Ihrer Wahl, wenn Sie feststellen, dass die Ursache für Ihre Performance-Probleme im Scheduling liegt. Mit Hilfe von \"Kernel-Trace\" können Sie sehen, ob Ihre Task durch eine andere Task, durch einen anderen Dienst oder einen Interrupt unterbrochen wird. trace-cmd record -p function Sie können Kernelshark verwenden, um die erzeugte Datei trace.dat zu untersuchen. Im Allgemeinen lassen sich die Probleme beim Scheduling in zwei Kategorien einteilen: Supersession \/ preemption Wenn der Interrupt oder die Task, die Ihre Ausführung verhindert, unnötig ist, deaktivieren Sie diese. Erhöhen Sie die Priorität Ihrer Task oder verringern Sie die der anderen. Wechseln Sie zu einem anderen CPU-Kern. Überprüfen Sie die Wirksamkeit der Änderungen mit Hilfe der im vorigen Kapitel beschriebenen Programme. Execution time Siehe nachfolgend \"Kernel-functiontrace\" Kernel-functiontrace Wenn Sie feststellen, dass die Code-Ausführungszeit zu hoch ist, können Sie dieses Tool verwenden, um das Problem zu lokalisieren. Wenn die Funktion mit zu hoher Ausführungszeit in Ihrem eigenem Code liegt, müssen Sie ihn optimieren. Wenn sich die Funktion mit zu hoher Ausführungszeit im Kernel befindet, können Sie versuchen, die gewünschte Funktionaliät mit einer anderen Kernel-Funktion zu erreichen. Alternativ können Sie dem Kernel-Treiber möglicherweise Konfigurationsparameter übergeben, um die Ausführungszeit zu verringern. Wenn keine dieser Optionen das Problem löst, müssen Sie wahrscheinlich eine leistungsstärkere Hardware einsetzen. Schauen Sie sich die folgenden Punkte an und prüfen Sie, ob sie das richtige Instrument sind, um Ihre Performance-Ziele zu erreichen: PREEMPT_FULL isolcpu rcu_nocbs rcu_nocb_poll nosoftlockup irqbalance disable kernel.sched_rt_runtime_us " }, 
{ "title" : "Anwendungsfälle ", 
"url" : "_rtsl_use_cases_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Mit Public-Key-Authentifizierung verbinden ", 
"url" : "_rtsl_linux_public_key_authentification.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Mit Public-Key-Authentifizierung verbinden ", 
"snippet" : "SSH ermöglicht eine Verbindung zur Steuerung, die sicher, verschlüsselt und authentifiziert ist. So können Sie die Fernverwaltung der Steuerung in einem abgesicherten Kontext durchführen. Die Authentifizierung kann über die Eingabe von Zugangsdaten (Benutzername und Passwort) erfolgen. Sie können ab...", 
"body" : "SSH ermöglicht eine Verbindung zur Steuerung, die sicher, verschlüsselt und authentifiziert ist. So können Sie die Fernverwaltung der Steuerung in einem abgesicherten Kontext durchführen. Die Authentifizierung kann über die Eingabe von Zugangsdaten (Benutzername und Passwort) erfolgen. Sie können aber auch mit einer schlüsselbasierten Authentifizierung (Public-Key-Authentifizierung) eine stärkere Methode wählen. Der Benutzer meldet sich dabei mit Hilfe eines Schlüssels an der Steuerung an. Ein Schlüssel besteht aus einem öffentlichen und einem privaten Schlüssel. Ein solches Schlüsselpaar ist wesentlich schwerer zu kompromittieren als ein Kennwort. Beim Anmeldevorgang wird überprüft, ob der öffentliche Schlüssel der Steuerung zum privaten Schlüssel des Entwicklungssystems passt. Wenn das der Fall ist, wird der Zugang gewährt, ohne dass ein Kennwort verwendet wird. Die in CODESYS verwendeten SSH-Schlüssel erstellen Sie auf dem Entwicklungssystem unter Windows. Dabei können Sie optional eine Passphrase (Passwort-Phrase) angeben, so dass sich die Sicherheit der Public-Key-Authentifizierung um einen weiteren Faktor erhöht. Den öffentlichen Schlüssel können Sie auf eine oder sogar mehrere Steuerungen kopieren, was beispielsweise bei einer Maschine erwünscht sein kann, die aus mehreren Steuerungen besteht. Der private Schlüssel bleibt dabei immer auf dem Entwicklungssystem und darf auf keinen Fall weitergegeben werden. Geben Sie den privaten Schlüssel niemals weiter. " }, 
{ "title" : "SSH-Key erstellen ", 
"url" : "_rtsl_linux_public_key_authentification.html#UUID-3411cc39-494f-56fd-579b-6a59fc3a254e_section-idm4635616815128032538919569496", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Mit Public-Key-Authentifizierung verbinden \/ SSH-Key erstellen ", 
"snippet" : "Erstellen Sie zunächst unter Windows einen SSH-Key bestehend aus einem privatem und einem öffentlichem Schlüssel. Installieren Sie das Open-Source-Tool “ PuTTY“. Unter C:\\Program Files (x86)\\PuTTY finden Sie die verschiedenen Anwendungen. Öffnen Sie das Tool „PuTTYgen“. Der folgende Dialog erscheint...", 
"body" : "Erstellen Sie zunächst unter Windows einen SSH-Key bestehend aus einem privatem und einem öffentlichem Schlüssel. Installieren Sie das Open-Source-Tool “ PuTTY“. Unter C:\\Program Files (x86)\\PuTTY finden Sie die verschiedenen Anwendungen. Öffnen Sie das Tool „PuTTYgen“. Der folgende Dialog erscheint. Wählen Sie die Option RSA und danach die Schaltfläche Generate . Die Erstellung des Schlüssels beginnt. Bewegen Sie währenddessen die Maus in der freien Fläche unter dem Fortschrittsbalken, bis der Schlüssel erstellt ist. Folgender Dialog erscheint: Falls erforderlich, können Sie in Key passphrase und Confirm passphrase eine sichere und eindeutige Passphrase vergeben. Wenn Sie eine Passphrase vergeben haben, sind die Schlüssel zusätzlich gesichert. Jedes Mal, wenn Sie sich in CODESYS auf Ihre Steuerung schlüsselbasiert einloggen, werden Sie die Passphrase benötigen. Halten Sie die Passphrase geheim, so dass nur Zugangsberechtigte sie kennen. Wählen Sie die Schaltfläche Save private key und geben Sie als Dateiname beispielsweise serviceuser.ppk ein. Wählen Sie Speichern . Der private PPK-Schlüssel ist erstellt. Wählen Sie den Befehl Conversions → Export OpenSSH key . Geben Sie einen Dateinamen an, beispielsweise serviceuser.openssh . Der private OPENSSH-Schlüssel ist erstellt. Selektieren Sie nun im Textfeld Public key for pasting into OpenSSH authorized_keys file die Zeichenfolge vollständig. Kopieren Sie den String mit Kontextmenü → Kopieren in die Zwischenablage und von dort in eine Textdatei. Benennen Sie diese beispielsweise serviceuser.pub . Der öffentliche PUB-Schlüssel ist erstellt. Verschieben Sie die Schlüssel an einen geeigneten, vielleicht sogar versteckten Speicherort auf dem Entwicklungsrechner. Oder sichern Sie die Dateien auf einem USB-Stick, der beim Entwicklungssystem bleibt. Beispielweise befinden sich die privaten und der öffentliche Schlüssel nun im Verzeichnis D:\\PLCs\\BeagleBone\\Keys . Achten Sie darauf, dass der private Schlüssel stets auf dem Entwicklungssystem bleibt. Der private Schlüssel darf niemals weitergegeben werden. " }, 
{ "title" : "Öffentlichen Schlüssel auf die Steuerung kopieren ", 
"url" : "_rtsl_linux_public_key_authentification.html#UUID-3411cc39-494f-56fd-579b-6a59fc3a254e_section-idm4635616712388832538922040216", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Mit Public-Key-Authentifizierung verbinden \/ Öffentlichen Schlüssel auf die Steuerung kopieren ", 
"snippet" : "Kopieren Sie den öffentlichen Schlüssel (beispielsweise serviceuser.pub ) auf Ihre Steuerung. Beachten Sie dabei die Angaben des Herstellers....", 
"body" : "Kopieren Sie den öffentlichen Schlüssel (beispielsweise serviceuser.pub ) auf Ihre Steuerung. Beachten Sie dabei die Angaben des Herstellers. " }, 
{ "title" : "Privaten Schlüssel in CODESYS verknüpfen ", 
"url" : "_rtsl_linux_public_key_authentification.html#UUID-3411cc39-494f-56fd-579b-6a59fc3a254e_section-idm4570645292920032538924011205", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Mit Public-Key-Authentifizierung verbinden \/ Privaten Schlüssel in CODESYS verknüpfen ", 
"snippet" : "Öffnen Sie CODESYS und wählen Sie den Befehl Tools → Control SL ausrollen . Expandieren Sie auf der Registerkarte Kommunikation den Abschnitt Schlüsselbasiertes Einloggen . Klicken Sie auf die Schaltfläche Schlüsseldatei hinzufügen . Ein Dateiauswahldialog öffnet sich. Wählen Sie den gewünschten pri...", 
"body" : "Öffnen Sie CODESYS und wählen Sie den Befehl Tools → Control SL ausrollen . Expandieren Sie auf der Registerkarte Kommunikation den Abschnitt Schlüsselbasiertes Einloggen . Klicken Sie auf die Schaltfläche Schlüsseldatei hinzufügen . Ein Dateiauswahldialog öffnet sich. Wählen Sie den gewünschten privaten Schlüssel (OPENSSH-Datei) aus. Beispiel: serviceuser.openssh Bestätigen Sie den Dialog mit OK . Der Dialog beendet sich. CODESYS verfügt nun über den privaten Schlüssel. Sie können den privaten Schlüssel auch in den Optionen, Kategorie Runtime Deploy Tool verknüpfen. " }, 
{ "title" : "Mit SSH-Key schlüsselbasiert einloggen ", 
"url" : "_rtsl_linux_public_key_authentification.html#UUID-3411cc39-494f-56fd-579b-6a59fc3a254e_section-idm4570645233654432538931011655", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Mit Public-Key-Authentifizierung verbinden \/ Mit SSH-Key schlüsselbasiert einloggen ", 
"snippet" : "Loggen Sie sich mit dem SSH- Schlüssel auf der Steuerung ein. Wählen Sie den Befehl Tools → Control SL ausrollen . Das Runtime Deploy Tool öffnet sich. Aktivieren Sie die Option SSH-Login schlüsselbasiert . Eine Auswahlliste mit allen in CODESYS bekannten Schlüsseln erscheint. Wählen Sie den gewünsc...", 
"body" : "Loggen Sie sich mit dem SSH- Schlüssel auf der Steuerung ein. Wählen Sie den Befehl Tools → Control SL ausrollen . Das Runtime Deploy Tool öffnet sich. Aktivieren Sie die Option SSH-Login schlüsselbasiert . Eine Auswahlliste mit allen in CODESYS bekannten Schlüsseln erscheint. Wählen Sie den gewünschten Schlüssel serviceuser.openssh aus. Geben Sie den Benutzernamen und das Passwort sowie gegebenenfalls die Passphrase in die entsprechenden Eingabefelder ein. Klicken Sie auf die Schaltfläche Durchsuchen . Im Netzwerk wird nach passenden Steuerungen gesucht. Das Ergebnis der Suche wird ausgegeben. Wählen Sie aus der Liste der Steuerungen die gewünschte aus. Wählen Sie beispielsweise den Befehl System-Info . Der SSH-Server auf der Steuerung überprüft, ob der private Schlüssel zum öffentlichen Schlüssel passt. Wenn das der Fall ist, sind Sie authentifiziert und werden eingeloggt. Danach wird der Befehl ausgeführt und die Systeminformationen der Steuerung werden in CODESYS angezeigt. " }, 
{ "title" : "Installieren von SL-Produkten ohne Package Manager ", 
"url" : "_rtsl_linux_installation_without_pm.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Installieren von SL-Produkten ohne Package Manager ", 
"snippet" : "Das Update-Tool für die SL-Produkte kopiert im Hintergrund ein Installationspackage (.deb oder .ipk) auf das Zielgerät und installiert es anschließend. Dies setzt voraus, dass der Package Manager dpkg oder ipkg auf dem Zielgerät installiert ist. Wenn kein Package Manager installiert ist, kann das Up...", 
"body" : "Das Update-Tool für die SL-Produkte kopiert im Hintergrund ein Installationspackage (.deb oder .ipk) auf das Zielgerät und installiert es anschließend. Dies setzt voraus, dass der Package Manager dpkg oder ipkg auf dem Zielgerät installiert ist. Wenn kein Package Manager installiert ist, kann das Update-Tool kein Laufzeitsystem installieren. Es ist jedoch immer noch möglich, das Package \"von Hand\" zu installieren, wenn dies gewünscht wird. Für die generischen Produkte wird dies im Folgenden am Beispiel von CODESYS Control​ for Linux V4.7.0.0 erläutert: CODESYS Control unterstützt keine Geräte mit (teilweise) schreibgeschütztem Dateisystem. Wenn Ihr Gerät ein schreibgeschütztes Dateisystem hat und Sie bei der Installation oder beim Starten eines Produkts Probleme haben, überprüfen Sie, ob die Probleme nach Deaktivieren des Schreibschutzes noch auftreten. " }, 
{ "title" : "Manuelle Installation des Laufzeitsystems auf dem Zielgerät ", 
"url" : "_rtsl_linux_installation_without_pm.html#UUID-aa2a93d5-f31b-688e-1fbf-002f3f403c41_section-idm4590635748291233589649632523", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Installieren von SL-Produkten ohne Package Manager \/ Manuelle Installation des Laufzeitsystems auf dem Zielgerät ", 
"snippet" : "Nach der Installation des Packages CODESYS Control​ for Linux befinden sich die benötigten Dateien auf dem Windows-PC: <User>\/CODESYS Control for Linux SL\/Delivery\/codesyscontrol_linux_4.7.0.0-b.trunk.39_amd64.deb oder <User>\/CODESYS Control for Linux SL\/Delivery\/codesyscontrol_linux_4.7.0.0-b.trunk...", 
"body" : "Nach der Installation des Packages CODESYS Control​ for Linux befinden sich die benötigten Dateien auf dem Windows-PC: <User>\/CODESYS Control for Linux SL\/Delivery\/codesyscontrol_linux_4.7.0.0-b.trunk.39_amd64.deb oder <User>\/CODESYS Control for Linux SL\/Delivery\/codesyscontrol_linux_4.7.0.0-b.trunk.39_amd64.ipk <User>\/CODESYS Control for Linux SL\/Dependency\/codemeter-lite_<Version>.deb (für die Lizenzierung) Kopieren Sie diese Dateien auf das Zielgerät. Entpacken Sie das Package: $ ar -x codesyscontrol_linux_<Version> Es werden folgende Dateien erstellt: control.tar.gz : Enthält die Skripte, die der Pakage Manager vor und nach der Installation oder Deinstallation ausführt. Dies ist für die manuelle Installation nicht relevant. data.tar.gz : Enthält Binärdateien des Laufzeitsystems, Bibliotheken, Startskripte und Konfigurationen debian-binary : Gibt die Version des .deb-Packages an. Dies ist für die manuelle Installation nicht relevant Entpacken Sie die Datei data.tar.gz . Legen Sie dafür vorher einen neuen Ordner an: $ mkdir data\n$ tar -xf data.tar.gz -C data In data\/ finden Sie nun die Dateien, die für den Betrieb des Laufzeitsystems wichtig sind: data\n├── etc\n│ ├── default\n│ │ └── codesyscontrol\n│ ├── init.d\n│ │ └── codesyscontrol\n│ └── codesyscontrol\n│ ├── 3S.dat\n│ ├── CODESYSControl.cfg\n│ └── CODESYSControl_User.cfg\n├── opt\n│ └── codesys\n│ ├── bin\n│ │ └── codesyscontrol.bin\n│ ├── lib\n│ │ ├── libCmpHilscherCIFX.so\n│ │ └── libSysPci.so\n│ └── scripts\n│ ├── init-functions\n│ ├── init-vars\n│ ├── PlcWink.sh\n│ └── rts_set_baud.sh\n├── usr\n│ └── share\n│ └── doc\n│ └── codesyscontrol\n│ └── copyright\n└── var\n └── opt\n └── codesys\n ├── bacstac.ini\n ├── cmact_licenses\n └── .SoftContainer_CmRuntime.wbb Nun würde normalerweise der Package Manager dpkg oder ipkg diese Verzeichnisstruktur in das Stammverzeichnis des Systems kopieren. Dies muss ohne Package Manager manuell geschehen: Wechseln Sie in das Verzeichnis data\/ , in das die Datei data.tar.gz \" entpackt wurde: $ cd data\/ Kopieren Sie die einzelnen Verzeichnisse in die jeweiligen Stammverzeichnisse des Ziels: Wenn Sie einen Fehler machen, kann dieser Schritt Ihr Zielgerät unbrauchbar machen und Sie müssen es zurücksetzen. $ sudo cp -r etc\/* \/etc\n$ sudo cp -r opt\/* \/opt\n$ sudo cp -r usr\/* \/usr\n$ sudo cp -r var\/* \/var Nun würde der Package Manager einige Nachinstallationsschritte ausführen, um die Installation abzuschließen. Führen Sie diese Schritte manuell aus: $ sudo chmod a+rw \/etc\/codesyscontrol\/CODESYSControl.cfg\n$ sudo chmod a+rw \/etc\/codesyscontrol\/CODESYSControl_User.cfg Wenn die Gruppe codesysuser noch nicht auf dem Zielgerät existiert, fügen Sie diese hinzu. $ groupadd codesysuser Diese Gruppe wird für die Externsion-API verwendet. Für weitere Informationen siehe: SicherheitsmechanismenDas Laufzeitsystem ist nun installiert. Es benötigt jedoch noch die Codemeter-Laufzeitumgebung. " }, 
{ "title" : "Manuelle Installation der Codemeter-Laufzeitumgebung auf dem Zielgerät ", 
"url" : "_rtsl_linux_installation_without_pm.html#UUID-aa2a93d5-f31b-688e-1fbf-002f3f403c41_section-idm4590635833291233589649827584", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Installieren von SL-Produkten ohne Package Manager \/ Manuelle Installation der Codemeter-Laufzeitumgebung auf dem Zielgerät ", 
"snippet" : "Nach der Installation des CODESYS Control SL-Package wird das .deb-Package in <User>\/CODESYS Control für Linux SL\/Dependency\/codemeter-lite_<Version>.deb gespeichert. Kopieren Sie auch dieses .deb-Package auf das Zielsystem in einen neu erstellten, leeren Ordner. Entpacken Sie das Debian-Package. $ ...", 
"body" : "Nach der Installation des CODESYS Control SL-Package wird das .deb-Package in <User>\/CODESYS Control für Linux SL\/Dependency\/codemeter-lite_<Version>.deb gespeichert. Kopieren Sie auch dieses .deb-Package auf das Zielsystem in einen neu erstellten, leeren Ordner. Entpacken Sie das Debian-Package. $ ar -x codemeter-lite_<Version>.deb Die Dateien control.tar.gz , data.tar.gz , debian-binary und zusätzlich _gpgorigin werden entpackt. Entpacken Sie die Datei data.tar.gz in einen neu erstellten Ordner. $ mkdir data\n$ tar -xf data.tar.gz -C data Danach sind die Binärdateien und andere Dateien wie Bibliotheken und Skripte unter data\/ verfügbar: data\n├── etc\n│ ├── init.d\n│ │ ├── codemeter\n│ │ └── codemeter-webadmin\n│ └── wibu\n│ └── CodeMeter\n│ └── Server.ini\n├── lib\n│ ├── systemd\n│ │ └── system\n│ │ ├── codemeter.service\n│ │ └── codemeter-webadmin.service\n│ └── udev\n│ └── rules.d\n│ └── 60-codemeter-lite.rules\n├── usr\n│ ├── bin\n│ │ ├── cmu\n│ │ └── codemeter-info\n│ ├── lib\n│ │ └── x86_64-linux-gnu\n│ │ ├── jni\n│ │ │ ├── libwibucmJNI64.so -> libwibucmJNI.so\n│ │ │ └── libwibucmJNI.so\n│ │ ├── libwibucmlin64-4.so -> libwibucm.so\n│ │ ├── libwibucmlin64.so -> libwibucm.so\n│ │ ├── libwibucmlin.so -> libwibucm.so\n│ │ └── libwibucm.so\n│ ├── sbin\n│ │ ├── CmWebAdmin\n│ │ └── CodeMeterLin\n│ └── share\n│ ├── bash-completion\n│ │ └── completions\n│ │ └── cmu\n│ ├── doc\n│ │ ├── CodeMeter\n│ │ │ ├── OpenSource_en.pdf\n│ │ │ └── README\n│ │ └── codemeter-lite\n│ │ ├── changelog.gz\n│ │ └── copyright\n│ └── man\n│ └── man1\n│ └── codemeter-info.1.gz\n└── var\n ├── lib\n │ └── CodeMeter\n │ ├── Backup\n │ ├── CmAct\n │ ├── CmCloud\n │ ├── NamedUser\n │ └── WebAdmin\n └── log\n └── CodeMeter Wechseln Sie in das Verzeichnis data\/ , in das die Datei data.tar.gz entpackt wurde: $ cd data\/ Kopieren Sie nun das gesamte Verzeichnis in das Stammverzeichnis des Zielgeräts: Wenn Sie einen Fehler machen, kann dieser Schritt Ihr Ziel unbrauchbar machen und Sie müssen es zurücksetzen $ sudo cp -r etc\/* \/etc\n$ sudo cp -r lib\/* \/lib\n$ sudo cp -r usr\/* \/usr\n$ sudo cp -r var\/* \/var Nun würde des Codemeter-Package einige Nachinstallationsschritte ausführen, um die Installation abzuschließen. Führen Sie diese Schritte manuell aus: $ sudo udevadm trigger -vn --subsystem-match=usb --attr-match=idVendor=064f | xargs -rn1 -d\\\\n udevadm trigger -b\n$ sudo mkdir -p \"\/etc\/systemd\/system\/multi-user.target.wants\/\"\n$ sudo ln -sT \/lib\/systemd\/system\/codemeter.service \/etc\/systemd\/system\/multi-user.target.wants\/codemeter.service Nun müssen Sie den Codemeter-Dienst mit folgendem Befehl einrichten (als root starten): CodemeterLin -x\n Die Installation von Codemeter-Lite und dem Laufzeitsystem ist nun abgeschlossen. " }, 
{ "title" : "Manuelle Installation des Edge Gateways: ", 
"url" : "_rtsl_linux_installation_without_pm.html#UUID-aa2a93d5-f31b-688e-1fbf-002f3f403c41_section-idm4604985458336033589650100426", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Installieren von SL-Produkten ohne Package Manager \/ Manuelle Installation des Edge Gateways: ", 
"snippet" : "Sie können das Edge Gateway auf die gleiche Weise wie das Laufzeitsystem und das Codemeter installieren. Auf dem Windows-PC ist das Package in <User>\/CODESYS Edge Gateway for Linux\/Delivery\/codesysedge_edgeamd64_<Version>.deb abgelegt. Kopieren Sie das Debian-Package auf das Zielgerät in einen neuen...", 
"body" : "Sie können das Edge Gateway auf die gleiche Weise wie das Laufzeitsystem und das Codemeter installieren. Auf dem Windows-PC ist das Package in <User>\/CODESYS Edge Gateway for Linux\/Delivery\/codesysedge_edgeamd64_<Version>.deb abgelegt. Kopieren Sie das Debian-Package auf das Zielgerät in einen neuen, leeren Ordner. Entpacken Sie das Debian-Package: $ ar -x codesysedge_edgeamd64_<Version>.deb Die Dateien control.tar.gz , data.tar.gz und debian-binary werden entpackt. Entpacken Sie die Datei data.tar.gz in einen neu erstellten Ordner: $ mkdir data\n$ tar -xf data.tar.gz -C data Danach sind die Binärdateien und andere Dateien wie Bibliotheken und Skripte unter data\/ verfügbar: data\n├── etc\n│ ├── default\n│ │ └── codesysedge\n│ ├── init.d\n│ │ └── codesysedge\n│ └── codesysedge\n│ ├── Gateway.cfg\n│ ├── GatewayvControl.cfg\n│ └── Gateway_User.cfg\n├── opt\n│ └── codesysedge\n│ ├── bin\n│ │ └── codesysedge.bin\n│ ├── lib\n│ └── scripts\n│ ├── rts_set_baud.sh\n│ └── startup.sh\n├── usr\n│ └── share\n\n│ └── doc\n│ └── codesysedge\n│ └── copyright\n└── var\n └── opt\n └── codesysedge Wechseln Sie in das Verzeichnis data\/ , in das die Datei data.tar.gz entpackt wurde: $ cd data\/ Kopieren Sie nun das gesamte Verzeichnis in das Stammverzeichnis des Zielgeräts: Wenn Sie einen Fehler machen, kann dieser Schritt Ihr Ziel unbrauchbar machen und Sie müssen es zurücksetzen. $ sudo cp -r etc\/* \/etc\n$ sudo cp -r opt\/* \/opt\n$ sudo cp -r usr\/* \/usr\n$ sudo cp -r var\/* \/var Führen Sie erneut die Nachbearbeitungsschritte des Package Managers aus: $ chmod a+rw \/etc\/codesysedge\/Gateway.cfg\n$ chmod a+rw \/etc\/codesysedge\/Gateway_User.cfg Das Edge Gateway ist nun installiert. " }, 
{ "title" : "Starten von Codemeter, des Laufzeitsystems und des Edge Gateways ", 
"url" : "_rtsl_linux_installation_without_pm.html#UUID-aa2a93d5-f31b-688e-1fbf-002f3f403c41_section-idm4554611316182433589650574679", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Installieren von SL-Produkten ohne Package Manager \/ Starten von Codemeter, des Laufzeitsystems und des Edge Gateways ", 
"snippet" : "Die installierten Packages können nun gestartet werden: Codemeter $ sudo \/usr\/sbin\/CodeMeterLin Sie können Codemeter mit dem Flag -v starten, um erweiterte Ausgaben zu erhalten. Mit der Eingabe von -Help erhalten Sie Hilfe zu weiteren Funktionen. Laufzeitsystem und Edge Gateway $ sudo \/etc\/init.d\/co...", 
"body" : "Die installierten Packages können nun gestartet werden: Codemeter $ sudo \/usr\/sbin\/CodeMeterLin Sie können Codemeter mit dem Flag -v starten, um erweiterte Ausgaben zu erhalten. Mit der Eingabe von -Help erhalten Sie Hilfe zu weiteren Funktionen. Laufzeitsystem und Edge Gateway $ sudo \/etc\/init.d\/codesyscontrol start\n$ sudo \/etc\/init.d\/codesysedge start " }, 
{ "title" : "Installieren der CODESYS TargetVisu for Linux SL ohne Package Manager ", 
"url" : "_rtsl_targetvisu_installation_without_pm.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Installieren der CODESYS TargetVisu for Linux SL ohne Package Manager ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Manuelle Installation des Laufzeitsystems auf dem Zielgerät ", 
"url" : "_rtsl_targetvisu_installation_without_pm.html#UUID-b70db7d9-478d-5a8c-9e0b-7e2599f42fe7_section-idm4590635748291233589649632523", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Installieren der CODESYS TargetVisu for Linux SL ohne Package Manager \/ Manuelle Installation des Laufzeitsystems auf dem Zielgerät ", 
"snippet" : "Nach der Installation des Packages CODESYS Control​ for Linux befinden sich die benötigten Dateien auf dem Windows-PC: <User>CODESYS TargetVisu for Linux SL\/Delivery\/visualization<Architectur>\/codesysvisualization_visualizationamd64_4.13.0.0_amd64.deb Kopieren Sie diese Dateien auf das Zielgerät. En...", 
"body" : "Nach der Installation des Packages CODESYS Control​ for Linux befinden sich die benötigten Dateien auf dem Windows-PC: <User>CODESYS TargetVisu for Linux SL\/Delivery\/visualization<Architectur>\/codesysvisualization_visualizationamd64_4.13.0.0_amd64.deb Kopieren Sie diese Dateien auf das Zielgerät. Entpacken Sie das Package: $ ar -x codesyscontrol_linux_<Version> Es werden folgende Dateien erstellt: control.tar.gz : Enthält die Skripte, die der Pakage Manager vor und nach der Installation oder Deinstallation ausführt. Dies ist für die manuelle Installation nicht relevant. data.tar.gz : Enthält Binärdateien des Laufzeitsystems, Bibliotheken, Startskripte und Konfigurationen debian-binary : Gibt die Version des .deb-Packages an. Dies ist für die manuelle Installation nicht relevant Entpacken Sie die Datei data.tar.gz . Legen Sie dafür vorher einen neuen Ordner an: $ mkdir data\n$ tar -xf data.tar.gz -C data In data\/ finden Sie nun die Dateien, die für den Betrieb des Laufzeitsystems wichtig sind: data\n├── etc\n│ └── codesysvisualization\n│ ├── CODESYSVisualization.cfg\n│ ├── CODESYSVisualizationTV.cfg\n│ └── CODESYSVisualization_User.cfg\n├── opt\n│ └── codesysvisualization\n│ ├── bin\n│ │ └── codesysvisualization.bin\n│ └── codesysvisualization.service\n├── usr\n│ └── share\n│ └── doc\n│ └── codesysvisualization\n│ └── copyright\n└── var \n └── opt \n └── codesysvisualization\n Nun würde normalerweise der Package Manager dpkg diese Verzeichnisstruktur in das Stammverzeichnis des Systems kopieren. Dies muss ohne Package Manager manuell geschehen: Wechseln Sie in das Verzeichnis data\/ , in das die Datei data.tar.gz \" entpackt wurde: $ cd data\/ Kopieren Sie die einzelnen Verzeichnisse in die jeweiligen Stammverzeichnisse des Ziels: Wenn Sie einen Fehler machen, kann dieser Schritt Ihr Zielgerät unbrauchbar machen und Sie müssen es zurücksetzen. $ sudo cp -r etc\/* \/etc\n$ sudo cp -r opt\/* \/opt\n$ sudo cp -r usr\/* \/usr\n$ sudo cp -r var\/* \/var Nun würde der Package Manager einige Nachinstallationsschritte ausführen, um die Installation abzuschließen. Führen Sie diese Schritte manuell aus: $ sudo chmod a+rw \/etc\/codesysvisualization\/CODESYSVisualization.cfg\n$ sudo chmod a+rw \/etc\/codesysvisualization\/CODESYSVisualization_User.cfg Wenn die Gruppe codesysvisualization noch nicht auf dem Zielgerät existiert, fügen Sie diese hinzu. $ groupadd codesysvisualization Legen Sie weitere Ordner an und bereiten Sie den Service vor. $ mkdir -p .config\/systemd\/user\/\n$ cp \/opt\/codesysvisualization\/codesysvisualization.service .config\/systemd\/user\/\n$ mkdir -p .config\/systemd\/user\/graphical.target.wants\/\n$ ln -s .config\/systemd\/user\/codesysvisualization.service .config\/systemd\/user\/graphical.target.wants\/. Setzen Sie die Berechtigungen und die Nutzer auf die Verzeichnisse. $ sudo chmod -R u+x \/etc\/codesysvisualization\/\n$ sudo chmod 740 \/opt\/codesysvisualization\/bin\/codesysvisualization.bin\n$ sudo chmod 640 ~\/.config\/systemd\/user\/codesysvisualization.service\n$ sudo chmod -R 640 \/var\/opt\/codesysvisualization\/\n$ sudo chmod -R u+X \/var\/opt\/codesysvisualization\/\n$ sudo chmod 640 \/usr\/share\/doc\/codesysvisualization\/copyright\n$ sudo chown --recursive <USER> \/var\/opt\/codesysvisualization\n$ sudo chown --recursive <USER> \/opt\/codesysvisualization\/\n$ sudo chown --recursive <USER> \/etc\/codesysvisualization\/\n$ sudo chown --recursive <USER> .config\/systemd\/ " }, 
{ "title" : "Installieren des Lizenzservers ohne Package Manager ", 
"url" : "_rtsl_licenseserver_installation_without_pm.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Installieren des Lizenzservers ohne Package Manager ", 
"snippet" : "Voraussetzung: Auf dem Gerät ist Codemeter Runtime installiert. Für weitere Informationen zur Installation von Codemeter ohne Package Manager siehe Manuelle Installation der Codemeter-Laufzeitumgebung auf dem ZielgerätCODESYS WBM kann nur mit Cockpit verwendet werden. Außerdem muss Ihr Computer glei...", 
"body" : "Voraussetzung: Auf dem Gerät ist Codemeter Runtime installiert. Für weitere Informationen zur Installation von Codemeter ohne Package Manager siehe Manuelle Installation der Codemeter-Laufzeitumgebung auf dem ZielgerätCODESYS WBM kann nur mit Cockpit verwendet werden. Außerdem muss Ihr Computer gleichzeitig eine Verbindung zum Zielgerät und zum Internet haben. " }, 
{ "title" : "Wenn Cockpit nicht installiert ist und oder nicht installiert werden kann ", 
"url" : "_rtsl_licenseserver_installation_without_pm.html#UUID-9309cb91-08d3-fde6-39f2-4317ba0b2561_section-idm234676479498753", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Installieren des Lizenzservers ohne Package Manager \/ Wenn Cockpit nicht installiert ist und oder nicht installiert werden kann ", 
"snippet" : "Sie müssen manuell den Lizenzserver einrichten, den Softcontainer erstellen und die Lizenzen einspielen. LicenseServer einrichten Stoppen Sie Codemeter: sudo \/etc\/init.d\/codemeter stop Stellen Sie auf Netzwerkserver um. Dazu müssen Sie in \/etc\/wibu\/CodeMeter\/Server.ini den Wert IsNetworkServer auf 1...", 
"body" : "Sie müssen manuell den Lizenzserver einrichten, den Softcontainer erstellen und die Lizenzen einspielen. LicenseServer einrichten Stoppen Sie Codemeter: sudo \/etc\/init.d\/codemeter stop Stellen Sie auf Netzwerkserver um. Dazu müssen Sie in \/etc\/wibu\/CodeMeter\/Server.ini den Wert IsNetworkServer auf 1 setzen: IsNetworkServer=1 Speichern Sie die Änderungen und starten Sie Codemeter: sudo \/etc\/init.d\/codemeter start Softcontainer erstellen Überprüfen Sie, ob bereits ein Softcontainer existiert: cmu -x | grep 'FC=6000437' Wenn ein Eintrag erscheint, können Sie diesen Abschnitt überspringen, da bereits ein Softcontainer existiert. Entpacken Sie das Lizenzserver-Debian-Package. Dieses Package ist normalerweise im CODESYS -Package des Lizenzservers enthalten. Darin liegt unter \/opt\/codesyslicenseserver\/bin eine Datei .UFC_SoftContainer_CmRuntime.WibuCmLif . Übertragen Sie diese auf das Gerät auf dem der LicenseServer laufen soll. Erstellen Sie den Softcontainer: cmu --import --file .UFC_SoftContainer_CmRuntime.WibuCmLif Prüfen Sie, ob der Befehl cmu -x | grep 'FC=6000437' einen Eintrag liefert. Lizenz einspielen Ermitteln Sie mit dem Befehl cmu -x die Seriennummer des Softcontainers, in den die Lizenz eingespielt werden soll. Erstellen Sie die Kontext-Datei: cmu -c 6000437 -s <Serial number> --file <file name>.WibuCmRaC Übertragen Sie das Kontext-File auf ein Gerät mit Internetzugang. Öffnen Sie die Adresse https:\/\/license.codesys.com\/ und geben Sie dort die Nummer des Lizenztickets ein. Klicken Sie auf NEXT und in der folgenden Seite auf ACTIVATE LICENSES . Wählen Sie danach den gewünschten Containertyp. Klicken Sie auf der nachfolgenden Seite rechts auf den Link File-based license transfer . Laden Sie die zuvor generierte Kontextdatei hoch und klicken Sie Start activation now . Laden Sie die Lizenz-Update-Datei herunter und übertragen Sie die Datei auf das Gerät, das als Lizenzserver agieren soll. Importieren Sie die Datei: cmu --import --file <File name>.WibuCmRaU Die Lizenz ist nun aktiviert " }, 
{ "title" : "Wenn Cockpit installiert ist ", 
"url" : "_rtsl_licenseserver_installation_without_pm.html#UUID-9309cb91-08d3-fde6-39f2-4317ba0b2561_section-idm234676479776826", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Installieren des Lizenzservers ohne Package Manager \/ Wenn Cockpit installiert ist ", 
"snippet" : "Kopieren Sie die Dateien des CODESYS WBM ins System: Entpacken Sie das Debian-Paket codesyswbmbase und legen Sie die Dateien, die in \/usr\/share\/cockpit\/codesys_wbm liegen, in ein gleichnamiges Verzeichnis im gleichen Pfad auf Ihrem System. Entpacken Sie das Debian-Paket codesyswbmlicensing und legen...", 
"body" : "Kopieren Sie die Dateien des CODESYS WBM ins System: Entpacken Sie das Debian-Paket codesyswbmbase und legen Sie die Dateien, die in \/usr\/share\/cockpit\/codesys_wbm liegen, in ein gleichnamiges Verzeichnis im gleichen Pfad auf Ihrem System. Entpacken Sie das Debian-Paket codesyswbmlicensing und legen Sie die Dateien, die in \/usr\/share\/cockpit\/codesys_wbm\/codesys_licensing liegen, in ein gleichnamiges Verzeichnis im gleichen Pfad auf Ihrem System. Starten Sie cockpit neu: systemctl restart cockpit.socket Nun sollten Sie das Cockpit Interface über Ihren Browser auf Port 9090 erreichen und dort mithilfe des CODESYS WBM die Lizenzierung durchführen können. " }, 
{ "title" : "Szenario \"Virtual Playground\": vPLC + Lizenzserver + Edge Gateway ", 
"url" : "_rtsl_scenario_virtual_playground.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"Virtual Playground\": vPLC + Lizenzserver + Edge Gateway ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Voraussetzungen ", 
"url" : "_rtsl_scenario_virtual_playground.html#UUID-135a713b-cb33-fd0c-80cc-22d356b14153_section-idm43465397081398", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"Virtual Playground\": vPLC + Lizenzserver + Edge Gateway \/ Voraussetzungen ", 
"snippet" : "Hardware Es werden folgende Geräte weiter benötigt: Desktop PC mit installiertem CODESYS Linux-PC (mit installiertem Docker oder Podman, Python3 und SSH-Zugang), hier als \"Linux-Host-PC\" bezeichnet. Folgende AddOn-Produkte müssen auf dem Desktop-PC (mit installiertem CODESYS ) installiert sein: CODE...", 
"body" : "Hardware Es werden folgende Geräte weiter benötigt: Desktop PC mit installiertem CODESYS Linux-PC (mit installiertem Docker oder Podman, Python3 und SSH-Zugang), hier als \"Linux-Host-PC\" bezeichnet. Folgende AddOn-Produkte müssen auf dem Desktop-PC (mit installiertem CODESYS ) installiert sein: CODESYS Virtual Edge Gateway for Linux . CODESYS Virtual Control for Linux SL CODESYS License Server for Linux SL " }, 
{ "title" : "Linux-Host-PC ", 
"url" : "_rtsl_scenario_virtual_playground.html#UUID-135a713b-cb33-fd0c-80cc-22d356b14153_section-idm43465397111438", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"Virtual Playground\": vPLC + Lizenzserver + Edge Gateway \/ Linux-Host-PC ", 
"snippet" : "Führen Sie den Befehl Tools → Control SL ausrollen aus und stellen Sie auf der eine Verbindung zum Linux-Host-PC her (Registerkarte Kommunikation ). Für weitere Informationen siehe Verbindung herstellenInstallieren Sie nachfolgende Packages\/Images in der neuesten Version (Registerkarte Bereitstellun...", 
"body" : "Führen Sie den Befehl Tools → Control SL ausrollen aus und stellen Sie auf der eine Verbindung zum Linux-Host-PC her (Registerkarte Kommunikation ). Für weitere Informationen siehe Verbindung herstellenInstallieren Sie nachfolgende Packages\/Images in der neuesten Version (Registerkarte Bereitstellung ): CODESYS Virtual Edge Gateway for Linux CODESYS Virtual Control for Linux SL CODESYS License Server for Linux SL Für weitere Informationen siehe Image installierenDer Lizenzserver kann auch auf einem anderen Hostsystem (Voraussetzung: Linux-Betriebssystem) installiert und betrieben werden. Die Kommunikation vom Linux-Host-PC zum Lizenzserver erfolgt über das TCP\/IP-Protokoll. Legen Sie die benötigten Instanzen an und konfigurieren Sie diese. Auf dem Linux-Host-PC werden Instanz für Gateway und PLC(s) benötigt. Legen Sie die Instanzen wie folgt in der Registerkarte Operation an: Installieren der Instanz für Gateway Klicken Sie im Abschnitt VPLCs auf die Schaltfläche Der Dialog Neue Instanz hinzufügen öffnet sich. Geben Sie im Eingabefeld Name beispielsweise vGateway ein. Wählen Sie in der Auswahlliste Filter den Wert Gateway aus. Selektieren Sie das Image CODESYS Virtual Edge Gateway for Linux in der neuesten Version. Abschließend klicken Sie auf OK . Die neue Instanz wird in der Sektion VPLCs angezeigt. Installieren der Instanz für vPLC(s) Klicken Sie im Abschnitt VPLCs auf die Schaltfläche Der Dialog Neue Instanz hinzufügen öffnet sich. Geben Sie im Eingabefeld Name beispielsweise vPLC1 ein. Wählen Sie in der Auswahlliste Filter den Wert Runtime aus. Selektieren Sie das Image CODESYS Virtual Control for Linux SL in der neuesten Version. Abschließend klicken Sie auf OK . Die neue Instanz wird in der Sektion VPLCs angezeigt. Tragen Sie unter Lizenzserver die IP-Adresse des Lizenzservers ein. Im dargestellten Beispiel ist dies die IP-Adresse des Linux-Host-PCs. Bestätigen Sie die Änderung mit Speichern . Die Einstellungen werden auf dem Linux-Host-PC übernommen. Optional: Wiederholen Sie diese Schritte für zusätzliche vPLC-Instanzen. Für weitere Informationen siehe Todo \"Instanzen anlegen\" Starten Sie die virtuellen Instanzen. Starten sie alle Instanzen, in dem Sie im Abschnitt VPLCs auf die Schaltfläche  Alle starten klicken. In der Spalte Zustand wechselt der Status aller virtueller Instanzen auf Läuft . Ab jetzt können die laufenden virtuellen Steuerungsinstanzen wie gewöhnliche PLCs über CODESYS erreicht und programmiert werden. Die Verbindungsaufnahme erfolgt dabei über das eingerichtete \"vGateway \". Ohne gültige Lizenz laufen die PLCs im Demobetrieb (2h Laufzeit). " }, 
{ "title" : "Lizenz(en) installieren ", 
"url" : "_rtsl_scenario_virtual_playground.html#UUID-135a713b-cb33-fd0c-80cc-22d356b14153_section-idm234664177345706", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"Virtual Playground\": vPLC + Lizenzserver + Edge Gateway \/ Linux-Host-PC \/ Lizenz(en) installieren ", 
"snippet" : "Lizenzen für den Betrieb der PLC(s) können Sie über den CODESYS Store International beziehen und auf dem Lizenzserver installieren. Für weitere Informationen siehe Aktivieren der Netzwerklizenz...", 
"body" : "Lizenzen für den Betrieb der PLC(s) können Sie über den CODESYS Store International beziehen und auf dem Lizenzserver installieren. Für weitere Informationen siehe Aktivieren der Netzwerklizenz" }, 
{ "title" : "Szenario Virtual Control mit VLAN ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario Virtual Control mit VLAN ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Voraussetzungen ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm43465397081398", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario Virtual Control mit VLAN \/ Voraussetzungen ", 
"snippet" : "Szenario Erfolgreiches Einrichten des Szenarios Szenario \"Virtual Playground\": vPLC + Lizenzserver + Edge GatewayMindestens zwei Instanzen der CODESYS Virtual Control for Linux SL , in diesem Beispiel vPLC1 und vPLC2 Hardware Ein VLAN-fähiger Switch Feldbus-Geräte (Ethernet-basiert), beispielsweise ...", 
"body" : "Szenario Erfolgreiches Einrichten des Szenarios Szenario \"Virtual Playground\": vPLC + Lizenzserver + Edge GatewayMindestens zwei Instanzen der CODESYS Virtual Control for Linux SL , in diesem Beispiel vPLC1 und vPLC2 Hardware Ein VLAN-fähiger Switch Feldbus-Geräte (Ethernet-basiert), beispielsweise Profinet " }, 
{ "title" : "Konfigurieren des Switch ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm43465397111438", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario Virtual Control mit VLAN \/ Konfigurieren des Switch ", 
"snippet" : "Wenn Sie Ihr Gerät falsch konfigurieren, verlieren Sie möglicherweise den Zugriff auf das Gerät. Verbinden Sie den Adapter, auf dem die VLANs definiert werden sollen, mit dem Switch. In diesem Beispiel werden auf dem folgenden Adapter zwei VLAN-Interfaces hinzugefügt: enp1s0: <BROADCAST,MULTICAST,UP...", 
"body" : "Wenn Sie Ihr Gerät falsch konfigurieren, verlieren Sie möglicherweise den Zugriff auf das Gerät. Verbinden Sie den Adapter, auf dem die VLANs definiert werden sollen, mit dem Switch. In diesem Beispiel werden auf dem folgenden Adapter zwei VLAN-Interfaces hinzugefügt: enp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\n    link\/ether f0:b2:b9:11:b8:b3 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.2.2\/24 brd 192.168.2.255 scope global noprefixroute enp1s0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::2e96:178c:586a:b97b\/64 scope link noprefixroute\n       valid_lft forever preferred_lft forever Öffnen Sie die Konfigurationsoberfläche des Switchs. Eine Anleitung zum Öffnen der Oberfläche und die Anmeldedaten entnehmen Sie bitte der Anleitung des Herstellers. Öffnen Sie nach der Anmeldung die Konfigurationsseite für VLAN. Wenn Ihr Switch unterschiedliche Protokolle unterstützt, wählen Sie 802.1Q VLAN . Konfigurieren Sie in der Seite Port Config den Link Type des zuvor angeschlossenen Port als Trunk . Verbinden Sie alle Feldbusgeräte mit dem Switch. Fügen Sie in der Seite VLAN Config zwei neue VLANs hinzu. In diesem Beispiel arbeiten Sie mit den VLAN-IDs 100 und 200. Fügen Sie in jedes VLAN den zuvor angeschlossenen und als Trunk konfigurierten Port hinzu. Fügen Sie in jedes VLAN den Port eines Feldbusgeräts. In der folgenden Beispielkonfiguration wurde auf Port 14 die Verbindung von der Steuerung zum Switch hergestellt. Der Link Type dieses Ports wurde als Trunk konfiguriert. An Port 11 und 12 ist jeweils ein Feldbusgerät angeschlossen. VLAN ID Beschreibung Ports 100 VLAN 100 11, 14 200 VLAN 200 12, 14 " }, 
{ "title" : "Konfigurieren der VLAN-Interfaces ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm234821994565272", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario Virtual Control mit VLAN \/ Konfigurieren der VLAN-Interfaces ", 
"snippet" : "Bevor Sie permanente Änderungen an Ihrer Netzwerkkonfiguration vornehmen, sollten Sie die Einstellungen testen und an Ihre Bedürfnisse anpassen. Erstellen Sie einen neuen Adapter vom Typ VLAN . Der Befehl hat folgendes Format: sudo ip link add link <physical_adapter> name <virtual_adapter_name> type...", 
"body" : "Bevor Sie permanente Änderungen an Ihrer Netzwerkkonfiguration vornehmen, sollten Sie die Einstellungen testen und an Ihre Bedürfnisse anpassen. Erstellen Sie einen neuen Adapter vom Typ VLAN . Der Befehl hat folgendes Format: sudo ip link add link <physical_adapter> name <virtual_adapter_name> type vlan id <vlan_id> Es ist Konvention die VLAN-ID an den Namen des virtuellen Adapter anzuhängen. Im Falle des oben gezeigten Adapters und Switch-Konfiguration sieht der Befehl folgendermaßen aus: sudo ip link add link enp1s0 name enp1s0.100 type vlan id 100 Ersetzen Sie enp1s0 und die VLAN-ID durch die Werte auf Ihrem System. Wenn Sie jetzt ip a ausführen, sollten Sie in etwa folgende Ausgabe sehen: enp1s0.100@enp1s0: <BROADCAST,MULTICAST,PROMISC> mtu 1500 qdisc noop state DOWN group default qlen 1000 Führen Sie diesen Befehl auch für das zweite VLAN durch. " }, 
{ "title" : "Testen der Konfiguration ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm234822002492998", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario Virtual Control mit VLAN \/ Testen der Konfiguration ", 
"snippet" : "Öffnen Sie das CODESYS Control SL Deploy Tool und stellen Sie eine Verbindung zu Ihrer Steuerung her. Für weitere Informationen siehe: Verbindung herstellen. Wechseln Sie auf die Registerkarte Operation und wählen Sie die Instanz vPLC1 . Klicken Sie Im Konfigurationsfenster auf der rechten Seite die...", 
"body" : "Öffnen Sie das CODESYS Control SL Deploy Tool und stellen Sie eine Verbindung zu Ihrer Steuerung her. Für weitere Informationen siehe: Verbindung herstellen. Wechseln Sie auf die Registerkarte Operation und wählen Sie die Instanz vPLC1 . Klicken Sie Im Konfigurationsfenster auf der rechten Seite die Zeile Nic und auf die Schaltfläche am rechten Rand. Es öffnet sich der Nic-Konfigurationsdialog Klicken Sie in der Liste der verfügbaren Adapter auf enp1s0.100 und aktivieren Sie die Option Map to Instance . Konfigurieren Sie, falls benötigt, eine IP-Adresse und Netzwerkmaske. Die Netzwerkmaske hat das Format der CIDR-Notation, beispielsweise 24 . Für weitere Informationen siehe: https:\/\/de.wikipedia.org\/wiki\/Classless_Inter-Domain_Routing Klicken Sie auf die Schaltflächen OK und Speichern . Wählen Sie die Instanz vPLC2 und führen Sie die Schritte 3-6 mit dem Adapter enp1s0.200 durch. Starten Sie die Instanzen sowie ein Gateway auf Ihrer Steuerung. Für weitere Informationen siehe: Laufzeitsystem startenLaden Sie auf die beiden Instanzen je eine kleine Applikation, mit der Sie die Funktionalität des Netzwerkes überprüfen können. Für weitere Informationen siehe: CODESYS" }, 
{ "title" : "Persistieren der Adapterkonfiguration ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm234821994914623", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario Virtual Control mit VLAN \/ Persistieren der Adapterkonfiguration ", 
"snippet" : "Wenn Ihre Konfiguration korrekt ist, müssen Sie diese noch persistent abspeichern. Eine Anleitung zum persistenten Abspeichern der Konfiguration Ihres Switches entnehmen Sie der Anleitung des Herstellers. Die Konfiguration der beiden Instanzen vPLC1 und vPLC2 sind bereits persistent. Hier müssen Sie...", 
"body" : "Wenn Ihre Konfiguration korrekt ist, müssen Sie diese noch persistent abspeichern. Eine Anleitung zum persistenten Abspeichern der Konfiguration Ihres Switches entnehmen Sie der Anleitung des Herstellers. Die Konfiguration der beiden Instanzen vPLC1 und vPLC2 sind bereits persistent. Hier müssen Sie lediglich die Einstellung Autostart auf Ja setzen. Die folgenden Schritte beschreiben, wie Sie die beiden VLAN-Adapter auf Ihrer Steuerung so konfigurieren, dass diese bei Systemstart verfügbar sind. Diese Einstellungen können potenziell schädlich sein für Ihr System. Erstellen Sie ein Backup von allen wichtigen Dateien. Erstellen Sie von allen Dateien, die modifiziert werden, zuvor eine Kopie, damit Sie Änderungen leicht rückgängig machen können. Öffnen Sie \/etc\/network\/interfaces mit einem Editor: sudo nano \/etc\/network\/interfaces . Fügen Sie folgende Zeilen hinzu (passen Sie die Adapternamen und VLAN-IDs auf Ihre Steuerung an): # enp1s0.100 vlan (vPLC1)\nauto enp1s0.100\niface enp1s0.100 inet dhcp\n    vlan-raw-device enp1s0\n# enp1s0.200 vlan (vPLC2)\nauto enp1s0.200\niface enp1s0.200 inet dhcp\n    vlan-raw-device enp1s0 Für weitere Informationen zu dieser Datei siehe: https:\/\/wiki.debian.org\/NetworkConfiguration Starten Sie Ihr System neu oder führen Sie den Befehl sudo systemctl restart networking aus, damit die Änderungen aktiv werden. Dieser Weg der Konfiguration wurde auf Debian 12 getestet. Möglicherweise müssen Sie für Ihr Gerät\/Betriebssystem eine andere Methode wählen, um die Konfiguration persistent zu speichern. Andere Beispiele sind netplan ( https:\/\/netplan.readthedocs.io\/en\/stable\/structure-id\/ ) oder NetworkManager ( https:\/\/networkmanager.dev\/ ). Die passende Anleitung für Ihre Steuerung finden Sie in der entsprechenden Dokumentation. " }, 
{ "title" : "Szenario \"Virtual with Fieldbus\": vPLC + Lizenzserver + Edge Gateway + Fieldbus ", 
"url" : "_rtsl_scenario_virtual_fieldbus.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"Virtual with Fieldbus\": vPLC + Lizenzserver + Edge Gateway + Fieldbus ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Voraussetzungen ", 
"url" : "_rtsl_scenario_virtual_fieldbus.html#UUID-8d90cd73-67b3-e75d-2d43-8f604bccd457_section-idm43465397081398", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"Virtual with Fieldbus\": vPLC + Lizenzserver + Edge Gateway + Fieldbus \/ Voraussetzungen ", 
"snippet" : "Szenario Erfolgreiches Einrichten des Szenarios Szenario \"Virtual Playground\": vPLC + Lizenzserver + Edge GatewayHardware Es wird zusätzlich folgendes Gerät benötigt: Feldbusteilnehmer (Ethernet-basiert), beispielsweise Profinet....", 
"body" : "Szenario Erfolgreiches Einrichten des Szenarios Szenario \"Virtual Playground\": vPLC + Lizenzserver + Edge GatewayHardware Es wird zusätzlich folgendes Gerät benötigt: Feldbusteilnehmer (Ethernet-basiert), beispielsweise Profinet. " }, 
{ "title" : "Konfigurieren des Feldbusses ", 
"url" : "_rtsl_scenario_virtual_fieldbus.html#UUID-8d90cd73-67b3-e75d-2d43-8f604bccd457_section-idm43465397111438", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"Virtual with Fieldbus\": vPLC + Lizenzserver + Edge Gateway + Fieldbus \/ Konfigurieren des Feldbusses ", 
"snippet" : "Ein Ethernet-Adapter für die Feldbusanbindung wird einer virtuellen PLC-Instanz wie folgt zugeordnet: Selektieren Sie im Abschnitt VPLCs die gewünschte vPLC-Instanz und klicken Sie auf Ausgewählte stoppen . Der Status der PLC wechselt auf \"Stopped\". Die zugehörigen Einstellungen werden unter Einstel...", 
"body" : "Ein Ethernet-Adapter für die Feldbusanbindung wird einer virtuellen PLC-Instanz wie folgt zugeordnet: Selektieren Sie im Abschnitt VPLCs die gewünschte vPLC-Instanz und klicken Sie auf Ausgewählte stoppen . Der Status der PLC wechselt auf \"Stopped\". Die zugehörigen Einstellungen werden unter Einstellungen angezeigt. Selektieren Sie unter NIC den Netzwerkadapter des Linux-Host-PCs, der für die Feldbusanbindung verwendet wird. Vergeben Sie, falls erforderlich, eine IP-Adresse und Netzwerkmaske. Bestätigen Sie die Änderung mit Speichern . Die Einstellungen werden auf dem Linux-Host-PC übernommen. Starten Sie die vPLC-Instanz durch Klicken auf Ausgewählte starten . Der Status der PLC wechselt auf \"Running\". Der Netzwerkadapter ist nun exklusiv der konfigurierten vPLC zugeordnet und auf dem Linux-Host-PC nicht mehr verfügbar. Nun kann der Feldbus wie gewohnt über CODESYS projektiert und verwendet werden. " }, 
{ "title" : "Szenario \"The Safe House\": vPLC + vSafe + ProfiSafe + Time Provider + Lizenzserver ", 
"url" : "_rtsl_scenario_safe_house.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"The Safe House\": vPLC + vSafe + ProfiSafe + Time Provider + Lizenzserver ", 
"snippet" : "Die Dokumentation auf den folgenden Seiten nur zu Informationszwecken zur Verfügung gestellt. Für Einschränkungen und Sicherheits- oder Zertifizierungsinformationen konsultieren Sie bitte die Sicherheitsdokumentation des Herstellers des Geräts, das Sie programmieren....", 
"body" : "Die Dokumentation auf den folgenden Seiten nur zu Informationszwecken zur Verfügung gestellt. Für Einschränkungen und Sicherheits- oder Zertifizierungsinformationen konsultieren Sie bitte die Sicherheitsdokumentation des Herstellers des Geräts, das Sie programmieren. " }, 
{ "title" : "Voraussetzungen ", 
"url" : "_rtsl_scenario_safe_house.html#UUID-8c70494a-5eac-cd26-0994-8e503c1ca9ab_section-idm234653932399925", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"The Safe House\": vPLC + vSafe + ProfiSafe + Time Provider + Lizenzserver \/ Voraussetzungen ", 
"snippet" : "Szenarios: Voraussetzung für dieses Szenario ist das erfoglreiche Einrichten des Szenario Szenario \"Virtual with Fieldbus\": vPLC + Lizenzserver + Edge Gateway + FieldbusHardware Es werden weiter folgende Geräte benötigt: Desktop-PC mit installiertem CODESYS Development System Linux-Host-PC mit insta...", 
"body" : "Szenarios: Voraussetzung für dieses Szenario ist das erfoglreiche Einrichten des Szenario Szenario \"Virtual with Fieldbus\": vPLC + Lizenzserver + Edge Gateway + FieldbusHardware Es werden weiter folgende Geräte benötigt: Desktop-PC mit installiertem CODESYS Development System Linux-Host-PC mit installierten virtual Edge Gateway, virtual PLC 1 und Lizenzserver Es werden zusätzlich folgende Geräte benötigt: Host für den Timeprovider, im Schaubild als Linux-Host-PC 2 benannt. Anforderungen an diesen Host: Linux-Betriebssystem und Docker müssen installiert und SSH konfiguriert sein. Echtzeitfähiges Netzwerk zum Linux-Host-PC, um das deterministische Senden der Datenpakete zu gewährleisten. Add-On-Produkte Auf dem Desktop-PC muss CODESYS Virtual Safe Control SL installiert sein. " }, 
{ "title" : "Linux-Host-PC 2 ", 
"url" : "_rtsl_scenario_safe_house.html#UUID-8c70494a-5eac-cd26-0994-8e503c1ca9ab_section-idm2346539369198", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"The Safe House\": vPLC + vSafe + ProfiSafe + Time Provider + Lizenzserver \/ Linux-Host-PC 2 ", 
"snippet" : "Richten Sie den Timeprovider auf dem Linux-Host-PC 2 ein. Der Timeprovider sendet die aktuelle Zeit an ein konfiguriertes Ziel und kann verwendet werden, um die von der Virtual Safe Control SL benötigte zweite Zeit zu liefern. Führen Sie den Befehl Tools → Control SL ausrollen aus und stellen Sie ei...", 
"body" : "Richten Sie den Timeprovider auf dem Linux-Host-PC 2 ein. Der Timeprovider sendet die aktuelle Zeit an ein konfiguriertes Ziel und kann verwendet werden, um die von der Virtual Safe Control SL benötigte zweite Zeit zu liefern. Führen Sie den Befehl Tools → Control SL ausrollen aus und stellen Sie eine Verbindung zum Linux-Host-PC 2 her (Registerkarte Kommunikation ). Für weitere Informationen siehe Verbindung herstellenInstallieren Sie nachfolgende Images in der neuesten Version (Registerkarte Bereitstellung ): CODESYS Virtual Safe Timeprovider Für weitere Informationen siehe Image installierenWechseln Sie zur Registerkarte Bereitstellung . Wählen Sie in der Auswahlliste Produkt CODESYS Virtual Safe Time Provider SL aus. Wählen Sie in der Auswahlliste Version die neueste Version. Klicken Sie auf die Schaltfläche Installieren . In der Sektion Installierte Images erscheint das Image CODESYS Virtual Safe Time Provider SL Legen Sie die benötigten Instanzen an Auf dem Linux-Host-PC 2 wird die Instanz timeprovider benötigt, die Sie wie folgt in der Registerkarte Operation anlegen: Klicken Sie im Abschnitt VPLCs auf die Schaltfläche Der Dialog Neue Instanz hinzufügen öffnet sich. Vergeben Sie als Namen timeprovider . Wählen Sie in der Auswahllliste Filter Safety Timeprovider aus. Selektieren Sie das Image CODESYS Virtual Safe Timeprovider SL in der neuesten Version und klicken Sie auf OK . Die neue Instanz wird in der Sektion VPLCs angezeigt. Konfigurieren Sie die Instanzen Für die Instanz timeprovider muss die Ziel-IP-Adresse und der Ziel-Port konfiguriert werden. Ziel ist der vHost und standardmäßig der Port 60000 . Genericcommands: -e TARGET_IP=[IP oder Hostname des Linux Host PC] -e TARGET_PORT=60000 60000 ist der Standardport für eine virtuelle sichere Steuerung SL, um eine externe Zeitquelle vom Zeitgeber zu empfangen. Autostart Ja Wenn Ja ausgewählt ist, wird die Instanz bei jedem Booten des Systems automatisch gestartet. Klicken Sie im Abschnitt VPLCs auf die Instanz timeprovider . Rechts erscheinen die Einstellungen für die Instanz timeprovider . TARGET_IP und TARGET_PORT sind bereits unter Genericcommands mit den Werten vSafePLC1 und 60000 vorbelegt Ändern Sie die TARGET_IP auf den Hostnamen oder die IP-Adresse des Linux-Host-PC 1. Für weitere Informationen Netzwerkadresse ermittelnÄndern Sie in der Auswahlliste Autostart den Wert auf Ja . Klicken Sie die Speichern um die Änderungen zu speichern. Für weitere Informationen siehe Eine neue Instanz anlegen und konfigurierenStarten Sie die Instanz. Starten Sie die Instanz timeprovider , in dem Sie diese im Abschnitt VPLCs auswählen und anschließend auf die Schaltfläche  Ausgewählte starten klicken. In der Spalte Zustand wechselt der Status bei allen Instanzen zu Läuft . " }, 
{ "title" : "Linux-Host-PC ", 
"url" : "_rtsl_scenario_safe_house.html#UUID-8c70494a-5eac-cd26-0994-8e503c1ca9ab_section-idm234653987267355", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"The Safe House\": vPLC + vSafe + ProfiSafe + Time Provider + Lizenzserver \/ Linux-Host-PC ", 
"snippet" : "Richten Sie die CODESYS Virtual Safe Control for Linux SL auf dem Linux-Host-PC ein. Führen Sie den Befehl Tools → Control SL ausrollen aus und stellen Sie eine Verbindung zum Linux-Host-PC 2 her (Registerkarte Kommunikation ). Wechseln Sie auf die Registerkarte Operation . Installieren Sie nachfolg...", 
"body" : "Richten Sie die CODESYS Virtual Safe Control for Linux SL auf dem Linux-Host-PC ein. Führen Sie den Befehl Tools → Control SL ausrollen aus und stellen Sie eine Verbindung zum Linux-Host-PC 2 her (Registerkarte Kommunikation ). Wechseln Sie auf die Registerkarte Operation . Installieren Sie nachfolgende Images in der neuesten Version (Registerkarte Bereitstellung ): CODESYS Virtual Safe Control SL Legen Sie die benötigten Instanzen an. Auf dem Linux Host PC 1 wird die Instanz vSafePLC benötigt, die Sie wie folgt in der Registerkarte Operation anlegen: Klicken Sie im Abschnitt VPLCs auf die Schaltfläche . Der Dialog Neue Instanz hinzufügen öffnet sich. Vergeben Sie als Namen vSafePLC . Wählen Sie in der Auswahlliste Filter Safety Laufzeitsystem aus. Selektieren Sie anschließend das CODESYS Virtual Safe Control for Linux SL Image in der neuesten Version. Abschließend klicken Sie auf OK . Die neue Instanz wird in der Sektion VPLCs angezeigt. Zusammen mit den Instanzen, die Sie im letzten Szenario auf diesem Gerät angelegt haben, sollten jetzt nachfolgende Instanzen im Abschnitt VPLCs vorhanden sein: Instanz Status Produkt vGateway Gestoppt Gateway vPLC Gestoppt Laufzeitsystem vSafePLC Gestoppt Safety-Laufzeitsystem Überprüfen Sie, ob nachfolgender Eintrag im Abschnitt Services vorhanden ist: Produkt Status CODESYS LicenseServer for Linux SL Läuft Stoppen Sie vor dem Umkonfigurieren die Instanzen, indem Sie auf die Schaltfläche Alle Stoppen klicken. Der Status aller Instanzen wechsel auf Gestoppt . Klicken Sie im Abschnitt VPLCs auf die Instanz vSafePLC . Rechts erscheinen die Einstellungen für die Instanz vSafePLC . Konfigurieren Sie die Instanz vSafePLC folgendermaßen: Ports: 60000:60000\/udp Dies ist der Standardport für eine Virtual Safe Control SL, um eine externe Zeitquelle vom timeprovider zu empfangen Ipc: container:vPLC Beitritt zum IPC-Namensraum der vPLC-Instanz für die Kommunikation zwischen diesen beiden Instanzen. Dependencies: vPLC Die vPLC muss zuerst gestartet werden, da diese den IPC-Namespace erstellt, dem diese Instanz beitreten möchte. Eine Abhängigkeit wird die richtige Startreihenfolge sicherstellen. Klicken Sie im Abschnitt VPLCs auf die Instanz vPLC . Rechts erscheinen die Einstellungen für die Instanz vPLC... Konfigurieren Sie die Instanz vPLC folgendermaßen: IPC: shareable Erstellen Sie einen IPC-Namespace für diesen Container, der von anderen Containern genutzt werden kann. In diesem Fall sollte die vSafePLC-Instanz für die Kommunikation zwischen diesen beiden Instanzen beitreten Starten Sie die Instanzen. Starten sie alle Instanzen, in dem Sie im Abschnitt VPLCs auf die Schaltfläche  Alle starten klicken. In der Spalte Zustand wechselt der Status aller Instanzen auf Läuft . Überprüfen Sie die Konfiguration. Um sicherzustellen, dass die Zeiten des timeproviders auch wie gewünscht und konfiguriert, bei der vSafePLC ankommen, können Sie dies im Log der Instanz überprüfen. Wählen Sie hierzu in der Sektion VPLCs die Instanz vSafePLCs aus. Klicken Sie im Abschnitt Aktionen oben rechts auf die Schaltfläche Protokoll anzeigen . Das Fenster Laufzeitsystemprotokoll öffnet sich. Die Meldung External Time Provider found existiert im Log. Damit sind alle notwendigen Geräte fertig vorbereitet. Die weiteren Schritte zur Erstellung eines Projekts und Einbindung von PROFIsafe sind in der Dokumentation CODESYS Safety Extension beschrieben. " }, 
{ "title" : "Szenario \"Virtual Redundancy\": vPLC + vPLC + Lizenzserver + Edge Gateway auf einem System ", 
"url" : "_rtsl_scenario_virtual_redundancy.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"Virtual Redundancy\": vPLC + vPLC + Lizenzserver + Edge Gateway auf einem System ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Voraussetzungen ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm43465397081398", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"Virtual Redundancy\": vPLC + vPLC + Lizenzserver + Edge Gateway auf einem System \/ Voraussetzungen ", 
"snippet" : "Szenario Erfolgreiches Einrichten des Szenarios Szenario \"Virtual Playground\": vPLC + Lizenzserver + Edge Gateway mit mindestens zwei vPLCs....", 
"body" : "Szenario Erfolgreiches Einrichten des Szenarios Szenario \"Virtual Playground\": vPLC + Lizenzserver + Edge Gateway mit mindestens zwei vPLCs. " }, 
{ "title" : "Konfigurieren des Container-Netzwerks: ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm43465397111438", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"Virtual Redundancy\": vPLC + vPLC + Lizenzserver + Edge Gateway auf einem System \/ Konfigurieren des Container-Netzwerks: ", 
"snippet" : "Um die Funktionalität der Redundanz zu gewährleisten, müssen die verwendeten Steuerungen über statische IP-Adressen verfügen. Wenn sich eine IP-Adresse ändern sollte, kann die Verbindung zum Gerät nicht automatisch wiederhergestellt werden. Die Konfiguration der Netzwerke muss direkt über die verwen...", 
"body" : "Um die Funktionalität der Redundanz zu gewährleisten, müssen die verwendeten Steuerungen über statische IP-Adressen verfügen. Wenn sich eine IP-Adresse ändern sollte, kann die Verbindung zum Gerät nicht automatisch wiederhergestellt werden. Die Konfiguration der Netzwerke muss direkt über die verwendete Container-Engine erfolgen. Dazu verbinden Sie sich über SSH mit Ihrem Linux-Host-PC. Im Terminal geben Sie folgenden Befehl ein, wobei IP-Adresse, Subnet und der Name des Netzwerks frei gewählt werden kann. docker network create --subnet=192.168.5.0\/24 mynetwork " }, 
{ "title" : "Konfiguration der Instanzen ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm23496702624416", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"Virtual Redundancy\": vPLC + vPLC + Lizenzserver + Edge Gateway auf einem System \/ Konfiguration der Instanzen ", 
"snippet" : "Für die vPLC-Instanzen müssen Sie nun eine eigene IP-Adresse spezifizieren und das Netzwerk zuweisen. Virtual PLC 1: Genericcommands --ip 192.168.5.1 Statische IP-Adresse der Instanz. Der Genericcommand --ip ist nur zulässig, wenn die Instanz in einem Containernetzwerk mit entsprechendem Subnetz ist...", 
"body" : "Für die vPLC-Instanzen müssen Sie nun eine eigene IP-Adresse spezifizieren und das Netzwerk zuweisen. Virtual PLC 1: Genericcommands --ip 192.168.5.1 Statische IP-Adresse der Instanz. Der Genericcommand --ip ist nur zulässig, wenn die Instanz in einem Containernetzwerk mit entsprechendem Subnetz ist. Network mynetwork Container-Netzwerk für die konfigurierten Instanzen Virtual PLC 2: Genericcommands: --ip 192.168.5. 2 Statische IP-Adresse der Instanz. Der Genericcommand --ip ist nur zulässig, wenn die Instanz in einem Containernetzwerk mit entsprechendem Subnetz ist. Network: mynetwork Container-Netzwerk für die konfigurierten Instanzen Das virtual Edge Gateway muss dann ebenfalls in das Netzwerk eingefügt werden. Virtual Edge Gateway: Network mynetwork Container-Netzwerk für die konfigurierten Instanzen " }, 
{ "title" : "Starten der virtuellen Instanzen ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm234967029997363", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"Virtual Redundancy\": vPLC + vPLC + Lizenzserver + Edge Gateway auf einem System \/ Starten der virtuellen Instanzen ", 
"snippet" : "Im Abschnitt vPLCs klicken Sie auf die Schaltfläche Start All . Der Status der konfigurierten virtuellen Instanzen wechselt auf Running . Für die Redundanzfunktionalität folgen Sie der Anleitung Erste Schritte - Redundanzsystem konfigurieren...", 
"body" : "Im Abschnitt vPLCs klicken Sie auf die Schaltfläche Start All . Der Status der konfigurierten virtuellen Instanzen wechselt auf Running . Für die Redundanzfunktionalität folgen Sie der Anleitung Erste Schritte - Redundanzsystem konfigurieren " }, 
{ "title" : "Szenario \"Virtual Redundancy\": vPLC + vPLC + Lizenzserver + Edge Gateway auf zwei Systemen ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm234968298823991", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"Virtual Redundancy\": vPLC + vPLC + Lizenzserver + Edge Gateway auf einem System \/ Szenario \"Virtual Redundancy\": vPLC + vPLC + Lizenzserver + Edge Gateway auf zwei Systemen ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Voraussetzungen ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm43496829968904", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"Virtual Redundancy\": vPLC + vPLC + Lizenzserver + Edge Gateway auf einem System \/ Szenario \"Virtual Redundancy\": vPLC + vPLC + Lizenzserver + Edge Gateway auf zwei Systemen \/ Voraussetzungen ", 
"snippet" : "Szenario Erfolgreiches Einrichten des Szenarios Szenario \"Virtual Redundancy\": vPLC + vPLC + Lizenzserver + Edge Gateway auf einem System. Hardware Es werden folgende Geräte zusätzlich benötigt: Host für weitere vPLCs, im Schaubild als Linux Host PC 2 benannt. Anforderungen an diesen Host Linux Betr...", 
"body" : "Szenario Erfolgreiches Einrichten des Szenarios Szenario \"Virtual Redundancy\": vPLC + vPLC + Lizenzserver + Edge Gateway auf einem System. Hardware Es werden folgende Geräte zusätzlich benötigt: Host für weitere vPLCs, im Schaubild als Linux Host PC 2 benannt. Anforderungen an diesen Host Linux Betriebssystem und Docker müssen installiert und SSH konfiguriert sein. Echtzeitfähiges Netzwerk zum Linux Host PC, um das deterministische Senden der temporalen Datenpakete zu gewährleisten. Zusätzliche Konfiguration der Instanzen auf beiden Systemen. Für weitere Informationen siehe: Konfiguration der InstanzenFür die beiden Instanzen auf den jeweiligen Hosts muss folgendes konfiguriert werden. Ports 1205:1205 Dies ist der Standardport für die Kommunikation der Redundanz. Sie können diesen Port auch in der Oberfläche der Redundanz-Konfiguration im Projekt ändern. Beachten Sie jedoch, dass die Änderung auch in der Konfiguration der entsprechenden Instanzen vorgenommen werden muss. " }, 
{ "title" : "Starten der virtuellen Instanzen ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm43496830001058", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ Szenario \"Virtual Redundancy\": vPLC + vPLC + Lizenzserver + Edge Gateway auf einem System \/ Szenario \"Virtual Redundancy\": vPLC + vPLC + Lizenzserver + Edge Gateway auf zwei Systemen \/ Voraussetzungen \/ Starten der virtuellen Instanzen ", 
"snippet" : "Im Abschnitt vPLCs klicken Sie auf die Schaltfläche Start All . Der Status der konfigurierten virtuellen Instanzen wechselt auf Running . Für die Redundanzfunktionalität folgen Sie der Anleitung Erste Schritte - Redundanzsystem konfigurieren...", 
"body" : "Im Abschnitt vPLCs klicken Sie auf die Schaltfläche Start All . Der Status der konfigurierten virtuellen Instanzen wechselt auf Running . Für die Redundanzfunktionalität folgen Sie der Anleitung Erste Schritte - Redundanzsystem konfigurieren " }, 
{ "title" : "CODESYS TargetVisu for Linux SL ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ CODESYS TargetVisu for Linux SL ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Anwendungsfälle ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374412002576", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ CODESYS TargetVisu for Linux SL \/ Anwendungsfälle ", 
"snippet" : "Die CODESYS TargetVisu for Linux SL ist ein separates kleines Laufzeitsystem, das die Darstellung einer Visualisierung verwaltet. Folgende Anwendungsfälle deckt die CODESYS TargetVisu for Linux SL ab: Die CODESYS TargetVisu for Linux SL kann unterschiedlich konfiguriert werden: Als Remote TargetVisu...", 
"body" : "Die CODESYS TargetVisu for Linux SL ist ein separates kleines Laufzeitsystem, das die Darstellung einer Visualisierung verwaltet. Folgende Anwendungsfälle deckt die CODESYS TargetVisu for Linux SL ab: Die CODESYS TargetVisu for Linux SL kann unterschiedlich konfiguriert werden: Als Remote TargetVisu, die sich mit einer anderen Steuerung verbindet Als lokale TargetVisu, die direkt auf der Steuerung läuft Dieser Anwendungsfall ist nicht für Steuerungen mit Echtzeitanforderungen geeignet. Für weitere Informationen siehe Performance-OptimierungGegenüber einer klassischen Target-Visualisierung bietet die CODESYS TargetVisu for Linux SL folgende Vorteile: Die Prozesse sind voneinander getrennt. Ein Fehler in der Visualisierung führt nicht automatisch zum Stillstand der Maschine. Die Visualisierung verbraucht weniger Ressourcen, da sie weniger Komponenten benötigt. Die gesamte Kommunikation erfolgt über das CODESYS -Kommunikationsprotokoll und ist deshalb sicher. " }, 
{ "title" : "Voraussetzungen ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374412127657", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ CODESYS TargetVisu for Linux SL \/ Voraussetzungen ", 
"snippet" : "Damit Sie die CODESYS TargetVisu for Linux SL einsetzen können, müssen auf Ihrem System folgende Anforderungen erfüllen: Auf dem System müssen folgende Bibliotheken installiert sein: libqt6core6 libqt6gui6 libqt6widgets6 libqt6network6 libqt6svg6 libqt6webenginewidgets6 libqt6webenginecore6 libqt6we...", 
"body" : "Damit Sie die CODESYS TargetVisu for Linux SL einsetzen können, müssen auf Ihrem System folgende Anforderungen erfüllen: Auf dem System müssen folgende Bibliotheken installiert sein: libqt6core6 libqt6gui6 libqt6widgets6 libqt6network6 libqt6svg6 libqt6webenginewidgets6 libqt6webenginecore6 libqt6webenginequick6 libqt6webview6 libqt6webviewquick6 libqt6qmlworkerscript6 libqt6quickshapes6 libqt6quickcontrols2-6 libqt6quickcontrols2impl6 libqt6quicktemplates2-6 Auf dem System muss eine Desktop-Umgebung installiert sein, beispielsweise: Xfce KDE gnome lxde Am Zielgerät muss ein physikalisches Display angeschlossen sein. Eine Verwendung mit X-Forwarding oder ähnliches ist nicht getestet. Qt muss in Version 6.4.2 oder höher installiert sein (beispielsweise Debian 12 oder Ubuntu 23.10 oder neuer). " }, 
{ "title" : "Verwenden der CODESYS TargetVisu for Linux SL im Projekt ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374412333472", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ CODESYS TargetVisu for Linux SL \/ Verwenden der CODESYS TargetVisu for Linux SL im Projekt ", 
"snippet" : "Für die Verwendung der CODESYS TargetVisu for Linux SL muss im Visualisierungsmanager die Option Client-Animation und Überlagerung systemeigener Elemente unterstützen deaktiviert werden. Selektieren Sie im Gerätebaum den Visualisierungsmanager. Fügen Sie darunter das Objekt Remote TargetVisu ein. Öf...", 
"body" : "Für die Verwendung der CODESYS TargetVisu for Linux SL muss im Visualisierungsmanager die Option Client-Animation und Überlagerung systemeigener Elemente unterstützen deaktiviert werden. Selektieren Sie im Gerätebaum den Visualisierungsmanager. Fügen Sie darunter das Objekt Remote TargetVisu ein. Öffnen Sie die Remote TargetVisu im Geräteeditor und definieren Sie dort die gewünschte Startvisualisierung. " }, 
{ "title" : "Installieren der CODESYS TargetVisu for Linux SL auf dem Zielgerät ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374412538107", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ CODESYS TargetVisu for Linux SL \/ Installieren der CODESYS TargetVisu for Linux SL auf dem Zielgerät ", 
"snippet" : "Wählen Sie den Menübefehl Tools → Control SL ausrollen . Die Registerkarte Deploy Control SL öffnet sich. Stellen Sie die Verbindung zur Steuerung. Für weitere Informationen siehe: Verbindung zum Zielsystem herstellenWechseln Sie zur Registerkarte Deployment . Wählen Sie in der Auswahlliste Produkt ...", 
"body" : "Wählen Sie den Menübefehl Tools → Control SL ausrollen . Die Registerkarte Deploy Control SL öffnet sich. Stellen Sie die Verbindung zur Steuerung. Für weitere Informationen siehe: Verbindung zum Zielsystem herstellenWechseln Sie zur Registerkarte Deployment . Wählen Sie in der Auswahlliste Produkt das Produkt CODESYS TargetVisu for Linux SL aus. Wählen Sie in der Auswahlliste Version die gewünschte Version aus. Kicken Sie auf die Schaltfläche Installieren . Der Account, mit dem die CODESYS TargetVisu for Linux SL installiert wird, muss der gleiche Account sein, mit dem sich der Anwender am Gerät anmeldet. CODESYS prüft, ob alle benötigten Bibliotheken installiert sind und Qt mindestens in der oben genannten Version vorliegt. Bevor Sie die Target-Visualisierung verwenden können, muss das Zielgerät einmal neu gestartet werden. " }, 
{ "title" : "Fehlerbehebung ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374413199442", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Anwendungsfälle \/ CODESYS TargetVisu for Linux SL \/ Fehlerbehebung ", 
"snippet" : "Vor CODESYS TargetVisu for Linux SL Version 4.13.0.0 Lokales Einloggen schlägt fehl Wenn nach der Installation beim Einloggen ein schwarzer Bildschirm erscheint und danach wieder der Login-Bildschirm angezeigt wird, so ist möglicherweise ein Fehler mit der gesetzten Umgebungsvariable DISPLAY vorhand...", 
"body" : "Vor CODESYS TargetVisu for Linux SL Version 4.13.0.0 Lokales Einloggen schlägt fehl Wenn nach der Installation beim Einloggen ein schwarzer Bildschirm erscheint und danach wieder der Login-Bildschirm angezeigt wird, so ist möglicherweise ein Fehler mit der gesetzten Umgebungsvariable DISPLAY vorhanden. Um dies zu überprüfen, können Sie im Konfigurationsdialog der Target-Visualisierung in CODESYS die Option Bei Login: X Display setzen + User verwenden deaktivieren. Wenn danach das Einloggen am Zielgerät funktioniert, überprüfen Sie die Ausgabe von echo $DISPLAY . Tragen Sie diesen Wert in \/etc\/default\/codesysvisualization beim Wert XDISPLAY ein und versuchen Sie es erneut. " }, 
{ "title" : "Fehlerbehebung ", 
"url" : "_rtsl_troubleshooting.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Programmiersystem \/ IDE \/ Deploy Tool ", 
"url" : "_rtsl_toubleshooting_deploytool.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Programmiersystem \/ IDE \/ Deploy Tool ", 
"snippet" : "In diesen Kapiteln finden Sie Anleitungen zur Fehlerbehebung bei Problemen mit linuxbasierten SL-Produkten und dem CODESYS Development System oder dem Deploy Tool . Das Deploy Tool ist ein Plug-in, mit dem Sie die linuxbasierten SL-Produkte auf Ihrem Linux-System installieren können....", 
"body" : "In diesen Kapiteln finden Sie Anleitungen zur Fehlerbehebung bei Problemen mit linuxbasierten SL-Produkten und dem CODESYS Development System oder dem Deploy Tool . Das Deploy Tool ist ein Plug-in, mit dem Sie die linuxbasierten SL-Produkte auf Ihrem Linux-System installieren können. " }, 
{ "title" : "Die Installation des Produkts endet mit einem Fehler ", 
"url" : "_rtsl_toubleshooting_deploytool1.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Programmiersystem \/ IDE \/ Deploy Tool \/ Die Installation des Produkts endet mit einem Fehler ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Voraussetzungen ", 
"url" : "_rtsl_toubleshooting_deploytool1.html#UUID-11b462c5-1f28-10cc-d2e1-e6130d87abc3_section-idm234790470711208", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Programmiersystem \/ IDE \/ Deploy Tool \/ Die Installation des Produkts endet mit einem Fehler \/ Voraussetzungen ", 
"snippet" : "Die CODESYS -Installation enthält das produktspezifische CODESYS -Paket (und dessen abhängigen Produkten). Einen Überblick über die installierten Produkte erhalten Sie im CODESYS Installer in der Übersicht der installierten Add-ons....", 
"body" : "Die CODESYS -Installation enthält das produktspezifische CODESYS -Paket (und dessen abhängigen Produkten). Einen Überblick über die installierten Produkte erhalten Sie im CODESYS Installer in der Übersicht der installierten Add-ons. " }, 
{ "title" : "Fehlerbehebung ", 
"url" : "_rtsl_toubleshooting_deploytool1.html#UUID-11b462c5-1f28-10cc-d2e1-e6130d87abc3_section-idm234790470799509", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Programmiersystem \/ IDE \/ Deploy Tool \/ Die Installation des Produkts endet mit einem Fehler \/ Fehlerbehebung ", 
"snippet" : "Fehler bei der Installation können durch das Zielgerät verursacht werden. Häufige Fehler sind schreibgeschützte Dateisysteme und veraltete oder fehlende Abhängigkeiten. Alle Produkte erwarten, dass ihr Package an dem Ort abgelegt ist, an dem der CODESYS Installer es bei der Installation des Add-ons ...", 
"body" : "Fehler bei der Installation können durch das Zielgerät verursacht werden. Häufige Fehler sind schreibgeschützte Dateisysteme und veraltete oder fehlende Abhängigkeiten. Alle Produkte erwarten, dass ihr Package an dem Ort abgelegt ist, an dem der CODESYS Installer es bei der Installation des Add-ons ablegt hat. Für jedes Produkt, das installiert wird, führt das Deploy Tool folgende Schritte durch: Stoppen des Runtime-Prozesses Sichern der alten Konfigurationsdatei Löschen des bestehenden Packages Übertragen des neuen Packages Nachfolgend sind zusätzliche produktspezifische Prüfungen aufgeführt, die das Deploy Tool abhängig vom Produkt ausführt und überprüft. Danach versucht der Package Manager, das neu übertragene Package zu installieren: BeagleBoneBlack Es werden keine weiteren Schritte oder Überprüfungen durchgeführt. Edge Gateway Das Deploy Tool prüft, ob es sich bei dem Gerät um eine armv4-, armv5- oder armv6-Architektur handelt. Der Wert wird durch Ausführen des Befehls uname -m ausgelesen. emPC Es werden keine weiteren Schritte oder Überprüfungen durchgeführt. IOT2000 Es werden keine weiteren Schritte oder Überprüfungen durchgeführt. Lizenzserver Das Deploy Tool versucht, eine aktuelle Version von Codemeter zu installieren. Wenn Codemeter oder Codemeter-lite in der gleichen oder einer neueren Version installiert ist als die Version, die das Deploy Tool erwartet, werden keine Änderungen am System vorgenommen. Wenn ein Upgrade oder eine Änderung notwendig ist, werden Sie in einem Dialog um Ihre Zustimmung gebeten, bevor Änderungen an Ihrem System vorgenommen werden. Wenn Sie zustimmen, wird die derzeit installierte Version von Codemeter entfernt und eine aktuelle Version installiert. Beachten Sie, dass der CODESYS Lizenzserver for Linux SL nicht verwendet werden kann, wenn Codemeter nicht auf dem System installiert ist. Das Deploy Tool bietet Ihnen auch an, ein optionales Plug-in namens „Cockpit“ zu installieren. Damit kann das CODESYS WBM verwendet werden, das die Aktivierung von Lizenzen auf dem Zielgerät erleichtert. Sie können diese Option ablehnen und der Installationsprozess wird fortgesetzt. Wenn Sie zustimmen und während der Installation des Cockpit-Package ein Fehler auftritt, wird der Installationsprozess abgebrochen. Linux SL LinuxARM SL LinuxARM64 SL Das Deploy Tool versucht, eine aktuelle Version von Codemeter zu installieren. Wenn Codemeter oder Codemeter-lite in der gleichen oder einer neueren Version installiert ist als die Version, die das Deploy Tool erwartet, werden keine Änderungen am System vorgenommen. Wenn ein Upgrade oder eine Änderung notwendig ist, werden Sie in einem Dialog um Ihre Zustimmung gebeten, bevor Änderungen an Ihrem System vorgenommen werden. Wenn Sie zustimmen, wird die derzeit installierte Version von Codemeter entfernt und stattdessen eine aktuelle Version installiert. Beachten Sie, dass diese Produkte nicht verwendet werden können, wenn Codemeter nicht auf dem System installiert ist. Safe Control Es werden keine weiteren Schritte oder Überprüfungen durchgeführt. SafeTimeProvider Es werden keine weiteren Schritte oder Überprüfungen durchgeführt. PFC100 PFC200 Vor Version 4.15: Das Deploy Tool versucht, das EntropyHelper-Package zu installieren. Die Produkte erwarten, dass das Package an dem Ort abgelegt ist, an dem der CODESYS Installer es bei der Installation des Add-ons ablegt hat. Wenn das Paket nicht ausgeführt wird, nicht gefunden wird oder die Installation fehlschlägt, wird das Produkt nicht installiert. TP600 Es werden keine weiteren Schritte oder Überprüfungen durchgeführt. PLCNext Das Deploy Tool versucht, die Firmware-Version mit dem folgenden Befehl zu lesen: cat \/etc\/plcnext\/arpversion | head -1 | cut -f2 -d' ' | cut -f-3 -d '.' Wenn die Version nicht gelesen werden kann, wird die Installation abgebrochen. Das Deploy Tool sucht lokal nach dem Package codesys-arp PLCNext in einer zur Firmware passenden Version. Das Package wird installiert. Wenn kein Package gefunden wird oder die Installation fehlschlägt, wird die Installation des Produkts abgebrochen. Raspberry Pi Nach der Installation des Package wird der Laufzeittyp festgelegt, der verwendet werden soll. Der Typ hängt von den auf dem System verfügbaren Loadern ab. Die Loader werden wie im Kapitel Userland-Architekturen beschrieben abgerufen. Wenn kein Loader gefunden wird, wird die Variante armv6l verwendet. Die folgende Liste zeigt die einzelnen Varianten: Multicore 64-Bit: aarch64 Multicore 32-Bit: ARMv7 Standard (kein Multicore): ARMv6 Abhängig von Ihrem System können Sie diese Einstellung im Deploy Tool nach der Installation des Produkts ändern. TargetVisualization Es werden keine weiteren Schritte oder Überprüfungen durchgeführt. Virtual Control Virtual Edge Virtual Safe Virtual SafeTimeProvider Auf Ihrem Gerät muss Python in Version 3.9 oder neuer und entweder Docker oder Podman installiert sein. " }, 
{ "title" : "Die Verbindung zum Zielgerät schlägt fehl ", 
"url" : "_rtsl_toubleshooting_deploytool2.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Programmiersystem \/ IDE \/ Deploy Tool \/ Die Verbindung zum Zielgerät schlägt fehl ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Voraussetzungen ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790221847662", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Programmiersystem \/ IDE \/ Deploy Tool \/ Die Verbindung zum Zielgerät schlägt fehl \/ Voraussetzungen ", 
"snippet" : "Der SSH-Server auf dem Zielgerät ist in Betrieb und läuft auf einem bekannten Port (beispielsweise 22). Die richtige IP-Adresse des Zielgeräts ist bekannt. Das Zielgerät kann über die IP-Adresse angepingt werden....", 
"body" : "Der SSH-Server auf dem Zielgerät ist in Betrieb und läuft auf einem bekannten Port (beispielsweise 22). Die richtige IP-Adresse des Zielgeräts ist bekannt. Das Zielgerät kann über die IP-Adresse angepingt werden. " }, 
{ "title" : "Fehlerbehebung ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790223645865", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Programmiersystem \/ IDE \/ Deploy Tool \/ Die Verbindung zum Zielgerät schlägt fehl \/ Fehlerbehebung ", 
"snippet" : "Andere Probleme wie ein langsames Netzwerk oder ein Netzwerkfehler können ebenfalls eine Unterbrechung der Verbindung verursachen. Nach der Verbindung zum Zielgerät liest das Deploy Tool einige Systemparameter aus, um zu ermitteln, welche Packages und Funktionen verfügbar sind. Dabei werden folgende...", 
"body" : "Andere Probleme wie ein langsames Netzwerk oder ein Netzwerkfehler können ebenfalls eine Unterbrechung der Verbindung verursachen. Nach der Verbindung zum Zielgerät liest das Deploy Tool einige Systemparameter aus, um zu ermitteln, welche Packages und Funktionen verfügbar sind. Dabei werden folgende Aspekte des Zielgeräts überprüft: " }, 
{ "title" : "Userland-Architekturen ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790227601997", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Programmiersystem \/ IDE \/ Deploy Tool \/ Die Verbindung zum Zielgerät schlägt fehl \/ Fehlerbehebung \/ Userland-Architekturen ", 
"snippet" : "Das Deploy Tool ermittelt die verfügbaren Loader auf dem Zielgerät. Die verfügbaren Loader bestimmen, welche Binärdateien ausgeführt werden können. Dazu führt das Deploy Tool folgenden Befehl aus: ls -la \/lib*\/ld-linux* Wenn die Ausgabe einen der folgenden Werte enthält, gilt die jeweilige Architekt...", 
"body" : "Das Deploy Tool ermittelt die verfügbaren Loader auf dem Zielgerät. Die verfügbaren Loader bestimmen, welche Binärdateien ausgeführt werden können. Dazu führt das Deploy Tool folgenden Befehl aus: ls -la \/lib*\/ld-linux* Wenn die Ausgabe einen der folgenden Werte enthält, gilt die jeweilige Architektur als verfügbar: x86-64, i386, x32, armhf, aarch64 Bei Version 4.14.0.0: Wurde keiner dieser Werte gefunden, wird die Verbindung unterbrochen. Ab Version 4.15.0.0: Wenn keiner dieser Werte gefunden wurde, gibt das Deploy Tool eine Logmeldung aus, dass keine Userland-Architektur gefunden wurde. Danach werden nachfolgende Paramenter geprüft. Dies sollte jedoch nicht zu einer Unterbrechung der Verbindung führen. " }, 
{ "title" : "Gerätearchitektur ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790234401598", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Programmiersystem \/ IDE \/ Deploy Tool \/ Die Verbindung zum Zielgerät schlägt fehl \/ Fehlerbehebung \/ Gerätearchitektur ", 
"snippet" : "Das Deploy Tool prüft, welche CPU auf dem Zielgerät vorhanden ist. Dazu führt das Deploy Tool die folgenden Befehle aus: lscpu | grep ^Architecture: Wenn die Ausgabe einen der folgenden Werte enthält, wird die entsprechende Architektur verwendet: x86_64, i686, aarch64, armv7l, armv6l Wenn die Ausgab...", 
"body" : "Das Deploy Tool prüft, welche CPU auf dem Zielgerät vorhanden ist. Dazu führt das Deploy Tool die folgenden Befehle aus: lscpu | grep ^Architecture: Wenn die Ausgabe einen der folgenden Werte enthält, wird die entsprechende Architektur verwendet: x86_64, i686, aarch64, armv7l, armv6l Wenn die Ausgabe keinen dieser Werte enthält, wird der Befehl cat \/proc\/cpuinfo | grep '^model name' ausgeführt. cat \/proc\/cpuinfo | grep '^model name' Wenn die Ausgabe einen der folgenden Werte enthält, wird die entsprechende Architektur verwendet: x86_64, i686, aarch64, armv7l, armv6l Wenn die Ausgabe keinen dieser Werte enthält , wird eine Logmeldung ausgegeben. " }, 
{ "title" : "Container-Engine ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790244053777", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Programmiersystem \/ IDE \/ Deploy Tool \/ Die Verbindung zum Zielgerät schlägt fehl \/ Fehlerbehebung \/ Container-Engine ", 
"snippet" : "Das Deploy Tool prüft, welche Container-Engines auf dem Zielgerät verfügbar sind. Dazu führt das Deploy Tool folgende Befehle aus: which docker Wenn der Exit-Codes 0 ist, wird Docker als Engine erkannt. which podman Wenn der Exit-Codes 0 ist, wird Podman als Engine erkannt. Der gleichzeitige Einsatz...", 
"body" : "Das Deploy Tool prüft, welche Container-Engines auf dem Zielgerät verfügbar sind. Dazu führt das Deploy Tool folgende Befehle aus: which docker Wenn der Exit-Codes 0 ist, wird Docker als Engine erkannt. which podman Wenn der Exit-Codes 0 ist, wird Podman als Engine erkannt. Der gleichzeitige Einsatz von zwei Container-Engines ist nicht getestet und wird nicht vollständig unterstützt. Dies könnte deshalb zu Problemen führen. " }, 
{ "title" : "Container-Architektur ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm2347902491793", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Programmiersystem \/ IDE \/ Deploy Tool \/ Die Verbindung zum Zielgerät schlägt fehl \/ Fehlerbehebung \/ Container-Architektur ", 
"snippet" : "Das Deploy Tool prüft, welche Architekturen die Container-Engine ausführen kann. Dazu führt das Deploy Tool , abhängig von der ermittelten Engine, folgenden Befehl aus: docker info Wenn die Ausgabe Architecture: einen der folgenden Werte enthält, wird die entsprechende Architektur verwendet: x86_64,...", 
"body" : "Das Deploy Tool prüft, welche Architekturen die Container-Engine ausführen kann. Dazu führt das Deploy Tool , abhängig von der ermittelten Engine, folgenden Befehl aus: docker info Wenn die Ausgabe Architecture: einen der folgenden Werte enthält, wird die entsprechende Architektur verwendet: x86_64, aarch64, armv7l, armv6l Wenn keiner dieser Werte gefunden wird, wird eine Logmeldung ausgegeben. podman info Wenn die Ausgabe arch: einen der folgenden Werte enthält, wird die entsprechende Architektur verwendet: amd64, aarch64, armv7l, armv6l Wenn keiner dieser Werte gefunden wird, wird eine Logmeldung ausgegeben. " }, 
{ "title" : "Init-Prozess ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790249419828", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Programmiersystem \/ IDE \/ Deploy Tool \/ Die Verbindung zum Zielgerät schlägt fehl \/ Fehlerbehebung \/ Init-Prozess ", 
"snippet" : "Das Deploy Tool prüft, welche Init-Prozesse auf dem Zielgerät verfügbar sind. Dazu führt das Deploy Tool folgende Befehle aus: systemctl > \/dev\/null 2>&1 ; echo $? Wenn der Exit-Code 0 ist und die Ausgabe 0 enthält, dann wird systemd als verfügbarer Init-Prozess erkannt. ls \/etc\/init.d > \/dev\/null 2...", 
"body" : "Das Deploy Tool prüft, welche Init-Prozesse auf dem Zielgerät verfügbar sind. Dazu führt das Deploy Tool folgende Befehle aus: systemctl > \/dev\/null 2>&1 ; echo $? Wenn der Exit-Code 0 ist und die Ausgabe 0 enthält, dann wird systemd als verfügbarer Init-Prozess erkannt. ls \/etc\/init.d > \/dev\/null 2>&1 ; echo $? Wenn der Exit-Code 0 ist und die Ausgabe 0 enthält, dann wird initd als verfügbarer Init-Prozess erkannt. " }, 
{ "title" : "Package Manager ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790249681867", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Programmiersystem \/ IDE \/ Deploy Tool \/ Die Verbindung zum Zielgerät schlägt fehl \/ Fehlerbehebung \/ Package Manager ", 
"snippet" : "Das Deploy Tool prüft, welche Packagemanager auf dem Zielgerät verfügbar sind. Dazu führt das Deploy Tool folgende Befehle aus: which dpkg > \/dev\/null 2>&1; echo $? Wenn der Exit-Code 0 ist und die Ausgabe 0 enthält, dann wird dpkg als verfügbarer Package Manager registriert. which ipkg > \/dev\/null ...", 
"body" : "Das Deploy Tool prüft, welche Packagemanager auf dem Zielgerät verfügbar sind. Dazu führt das Deploy Tool folgende Befehle aus: which dpkg > \/dev\/null 2>&1; echo $? Wenn der Exit-Code 0 ist und die Ausgabe 0 enthält, dann wird dpkg als verfügbarer Package Manager registriert. which ipkg > \/dev\/null 2>&1; echo $? Wenn der Exit-Code 0 ist und die Ausgabe 0 enthält, dann wird ipkg als verfügbarer Package Manager registriert. which opkg > \/dev\/null 2>1; echo $? Wenn der Exit-Code 0 ist und die Ausgabe 0 enthält, dann wird opkg als verfügbarer Package Manager registriert. Ab Version 4.15: which rpm > \/dev\/null 2>1; echo $? Wenn der Exit-Code 0 ist und die Ausgabe 0 enthält, dann wird rpm als verfügbarer Package Manager registriert. Wenn ein Produkt und Ihr System dpkg und ipkg oder opkg unterstützen, wird dpkg verwendet. " }, 
{ "title" : "Python ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790250012792", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Programmiersystem \/ IDE \/ Deploy Tool \/ Die Verbindung zum Zielgerät schlägt fehl \/ Fehlerbehebung \/ Python ", 
"snippet" : "Das Deploy Tool prüft, ob Python auf Ihrem Ziel verfügbar ist. Dazu führt das Deploy Tool folgenden Befehl aus: python3 -v Wenn der Exit-Code 0 und die Version größer-gleich als 3.9 ist, wird Python als installiert erkannt....", 
"body" : "Das Deploy Tool prüft, ob Python auf Ihrem Ziel verfügbar ist. Dazu führt das Deploy Tool folgenden Befehl aus: python3 -v Wenn der Exit-Code 0 und die Version größer-gleich als 3.9 ist, wird Python als installiert erkannt. " }, 
{ "title" : "Das Produkt zur Installation auf dem Zielgerät kann nicht ausgewählt werden ", 
"url" : "_rtsl_toubleshooting_deploytool3.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Programmiersystem \/ IDE \/ Deploy Tool \/ Das Produkt zur Installation auf dem Zielgerät kann nicht ausgewählt werden ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Voraussetzungen ", 
"url" : "_rtsl_toubleshooting_deploytool3.html#UUID-492eba96-8c2f-b3cd-6935-f8dd7506d72f_section-idm23478724692167", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Programmiersystem \/ IDE \/ Deploy Tool \/ Das Produkt zur Installation auf dem Zielgerät kann nicht ausgewählt werden \/ Voraussetzungen ", 
"snippet" : "Die CODESYS -Installation enthält das produktspezifische CODESYS -Package (und dessen abhängigen Produkte). Einen Überblick über die installierten Produkte erhalten Sie im CODESYS Installer in der Übersicht der installierten Add-ons....", 
"body" : "Die CODESYS -Installation enthält das produktspezifische CODESYS -Package (und dessen abhängigen Produkte). Einen Überblick über die installierten Produkte erhalten Sie im CODESYS Installer in der Übersicht der installierten Add-ons. " }, 
{ "title" : "Fehlerbehebung ", 
"url" : "_rtsl_toubleshooting_deploytool3.html#UUID-492eba96-8c2f-b3cd-6935-f8dd7506d72f_section-idm234787250012849", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Programmiersystem \/ IDE \/ Deploy Tool \/ Das Produkt zur Installation auf dem Zielgerät kann nicht ausgewählt werden \/ Fehlerbehebung ", 
"snippet" : "Sie können mit dem Deploy Tool nur dann ein Produkt auswählen, wenn das Zielgerät die Anforderungen für dieses Produkt erfüllt (verfügbare Architekturen, Package-Manager, Init-Prozesse,...). Jedes Produkt benötigt eine passende Userland-Architektur, einen Package-Manager und einen Init-Prozess (wenn...", 
"body" : "Sie können mit dem Deploy Tool nur dann ein Produkt auswählen, wenn das Zielgerät die Anforderungen für dieses Produkt erfüllt (verfügbare Architekturen, Package-Manager, Init-Prozesse,...). Jedes Produkt benötigt eine passende Userland-Architektur, einen Package-Manager und einen Init-Prozess (wenn nicht anders angegeben, ist initd notwendig). Für weitere Informationen siehe: Fehlerbehebung. Die nachfolgende Liste zeigt, was die einzelnen Produkte überprüfen: Produkt BeagleBoneBlack Die Ausgabe von cat \/proc\/cpuinfo | grep '^model name\\|^Hardware' muss ARMv7 und Generic AM33XX enthalten. Edge Gateway Bei Verwendung auf einer PLCNext-Steuerung muss das Add-On PLCNext Edge Gateway auf Ihrem Windows-Computer verfügbar sein (es sollte sich im PLCNext-Verzeichnis befinden). uname -m darf uarmv4 , uarmv5 oder uarmv6 nicht enthalten. emPC eth0 oder eth1 muss eine MAC-Adresse haben, die mit 00:90:E9 beginnt. IOT2000 eth0 oder eth1 muss eine MAC-Adresse haben, die mit E0:DC:A0 beginnt. License Server Keine weiteren Überprüfungen LinuxARM SL und LinuxARM64 SL Es muss die passende Userland-Architektur verfügbar sein ( armhf oder aarch64 ). Safe Control Erfordert eine 32-Bit-AMD-Architektur (i386) SafeTimeProvider Erfordert eine 64-Bit-AMD-Architektur (x86-64) und die Verfügbarkeit von Python. Eine Beschreibung, wie Sie das überprüfen können, finden Sie im Kapitel Die Verbindung zum Zielgerät schlägt fehl im Abschnitt \"Python\". Linux SL Erfordert eine 64-Bit-AMD-Architektur (x86-64) PFC100 PFC200 TP600 Erfordert ipkg oder opkg und eine 32-Bit-Arm-Architektur ( armhf ) PLCNext Erfordert das Vorhandensein von \/etc\/plcnext\/arpversion Raspberry Pi cat \/proc\/cpuinfo | grep ^Model | awk -F':' '{print $2}' muss \"Raspberry\" enthalten TargetVisualization Die folgenden Packages müssen installiert sein libqt6core6 libqt6gui6 libqt6widgets6 libqt6network6 libqt6svg6 libqt6webenginewidgets6 libqt6webenginecore6 Die Namen müssen exakt übereinstimmen. Das installierte Package wird mit diesem Befehl ermittelt: Die Ausgabe des Befehls dpkg -l <package> | awk '\/<package>\/ {print }' muss ii für alle Packages enthalten. libqt6core6 muss mindestens in der Version 6.4.2 installiert sein. Die Version wird mit diesem Befehl ermittelt: dpkg -s libqt6core6 | grep '^Version:' | grep -o -E '\\b[0-9]+\\.[0-9]+\\.[0-9]+\\b' Virtual Control Virtual Edge Virtual Safe Virtual SafeTimeProvider Python muss verfügbar sein. Eine Beschreibung, wie Sie das überprüfen können, finden Sie im Kapitel Die Verbindung zum Zielgerät schlägt fehl im Abschnitt \"Python\". Podman oder Docker müssen installiert sein und es muss ein Image verfügbar sein, das zu einer verfügbaren Containerarchitektur passt. Virtual SafeTimeProvider Die x86-64 Userland-Architektur und Python müssen verfügbar sein. Eine Beschreibung, wie Sie das überprüfen können, finden Sie im Kapitel Die Verbindung zum Zielgerät schlägt fehl im Abschnitt \"Python\". Virtual Safe Die i386 Userland-Architektur und Python müssen verfügbar sein. Eine Beschreibung, wie Sie das überprüfen können, finden Sie im Kapitel Die Verbindung zum Zielgerät schlägt fehl im Abschnitt \"Python\". Virtual Control Virtual Edge Eine der Userland-Architekturen x86-64, armhf oder arm64 ist erforderlich, und Python muss verfügbar sein. Eine Beschreibung, wie Sie das überprüfen können, finden Sie im Kapitel Die Verbindung zum Zielgerät schlägt fehl im Abschnitt \"Python\". " }, 
{ "title" : "Linux Target ", 
"url" : "_rtsl_toubleshooting_linuxtarget.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Linux Target ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Seltsames Verhalten in der IEC-Applikation ", 
"url" : "_rtsl_toubleshooting_linuxtarget_stange.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Linux Target \/ Seltsames Verhalten in der IEC-Applikation ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Voraussetzungen ", 
"url" : "_rtsl_toubleshooting_linuxtarget_stange.html#UUID-15af7838-c568-6bc8-9b0d-6c5ba94f66cf_section-idm234790740254336", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Linux Target \/ Seltsames Verhalten in der IEC-Applikation \/ Voraussetzungen ", 
"snippet" : "Sie verwenden ein CODESYS -Laufzeitsystem....", 
"body" : "Sie verwenden ein CODESYS -Laufzeitsystem. " }, 
{ "title" : "Fehlerbehebung ", 
"url" : "_rtsl_toubleshooting_linuxtarget_stange.html#UUID-15af7838-c568-6bc8-9b0d-6c5ba94f66cf_section-idm234790740478094", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ Linux Target \/ Seltsames Verhalten in der IEC-Applikation \/ Fehlerbehebung ", 
"snippet" : "Wenn Sie auf ein seltsames Verhalten stoßen, sollten Sie prüfen, ob der Logger des Laufzeitsystems wertvolle Hinweise oder Informationen liefert. Der CODESYS -Laufzeitsystem-Logger verfügt über einen Mechanismus zum Filtern von Meldungen nach ihrer Kategorie. Standardmäßig ist die Kategorie Debug ni...", 
"body" : "Wenn Sie auf ein seltsames Verhalten stoßen, sollten Sie prüfen, ob der Logger des Laufzeitsystems wertvolle Hinweise oder Informationen liefert. Der CODESYS -Laufzeitsystem-Logger verfügt über einen Mechanismus zum Filtern von Meldungen nach ihrer Kategorie. Standardmäßig ist die Kategorie Debug nicht aktiviert. Aktivieren Sie diese Kategorie, um die Ursache für seltsames Verhalten oder unerwartete Symptome zu finden. Es gibt globale und komponentenspezifische Log-Filter. Eine Liste aller möglichen komponentenspezifischen Filter können Sie in der Logdatei des Laufzeitsystems im Detail sehen. Verwenden Sie die Filter wie nachfolgend beschrieben. Symptome bezogen auf möglicher komponentenbasierter Log-Filter Lizenzierung CmpCodeMeter IEC-Tasks \/ Timing (higher level) CmpIecTask IEC-Tasks \/ Timing (low level) CmpSchedule , SysTask IEC-Applikation (allgemein) CmpApp , CmpIecTask IEC-Applikation (Speicher) SysMem Socket-Kommunikation SysSocket Ethernet-Kommunikation SysEthernet Dateien \/ Ordner SysFile , SysDir Aktivieren Sie nicht alle Debug-Kategorien auf einmal, da es sonst schwierig wird, das eigentliche Problem zu finden. Gehen Sie Schritt für Schritt vor und deaktivieren Sie „nicht relevante“ Filter, um einen besseren Überblick über das Problem zu erhalten. Aktiveren der Meldungskategorie Debug über die PLCShell (bei Laufzeitversionen >= SP20) Öffnen Sie Ihr CODESYS -Projekt und verbinden Sie es mit der Steuerung. Öffnen Sie die SPS-Shell durch einen Doppelklick auf die Steuerung im Gerätebaum. Geben Sie in der Shell \"?\" ein, um alle möglichen Befehle zu sehen. Verwenden Sie die Befehle logsetfilter , loggetfilter und logdelfilter , um einen Filter zu schreiben, zu lesen und zu löschen. Sie können entweder globale Debug-Filter für das gesamte Laufzeitzeitsystem oder Filter für eine bestimmte Komponente verwenden. Globales Lesen der aktuellen Log-Kategirie: loggetfilter könnte folgende Ausgabe liefern: Logger.0.Filter : 0x0000000F Globales Setzen der aktuellen Log-Kategorie: logsetfilter 0xffffffff Lesen der aktuellen Log-Kategorie für eine bestimmte Komponente (beispielsweise CmpCodeMeter ): loggetfilter CmpCodeMeter Setzen der aktuellen Log-Kategorie für eine bestimmte Komponente (beispielsweise CmpCodeMeter ): logsetfilter CmpCodeMeter 0xffffffff Aktivieren der Logger-Kategorie über die Runtime-Konfigurationsdatei (bei älteren Laufzeit-Versionen) Beispiel: über eine SSH-Verbindung und einen Texteditor Beenden Sie das Laufzeitsystem über das DeployTool. Verbinden Sie sich mit Ihrem Zielsystem (beispielsweise über putty oder einen anderen SSH-Client). Öffnen Sie die benutzerspezifische Konfigurationsdatei der Laufzeitumgebung mit einem Texteditor (beispielsweise nano ): sudo nano \/etc\/codesyscontrol\/CODESYSControl_User.cfg Suchen Sie den Abschnitt CmpLog und setzen Sie den Filter. Setzen eines globalen Filters Beispiel: Logger.0.Filter=0xFFFFFFFF zum Aktivieren aller Debug-Meldungen Setzen eines komponentenspezifischen Filters [CmpLog]\nCmpCodeMeter.Filter=0xFFFFFFFF\nSysTask.Filter=0xFFFFFFFF Speichern und schließen Sie die Datei. Führen Sie einen Neustart des Laufzeitsystems mit dem Deploy Tool durch. " }, 
{ "title" : "IEC-Applikation ", 
"url" : "_rtsl_toubleshooting_iec.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ IEC-Applikation ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Die IEC-Anwendung hängt aufgrund von Semaphoren ", 
"url" : "_rtsl_toubleshooting_iec_semaphores.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ IEC-Applikation \/ Die IEC-Anwendung hängt aufgrund von Semaphoren ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Voraussetzunge ", 
"url" : "_rtsl_toubleshooting_iec_semaphores.html#UUID-0421c326-6af8-0336-eb1f-9f6120d597b5_section-idm234795575934472", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ IEC-Applikation \/ Die IEC-Anwendung hängt aufgrund von Semaphoren \/ Voraussetzunge ", 
"snippet" : "Sie haben ein Linux- oder Windows-basiertes Laufzeitsystem der Version >= SP20....", 
"body" : "Sie haben ein Linux- oder Windows-basiertes Laufzeitsystem der Version >= SP20. " }, 
{ "title" : "Fehlerbehebung ", 
"url" : "_rtsl_toubleshooting_iec_semaphores.html#UUID-0421c326-6af8-0336-eb1f-9f6120d597b5_section-idm234795576141488", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ IEC-Applikation \/ Die IEC-Anwendung hängt aufgrund von Semaphoren \/ Fehlerbehebung ", 
"snippet" : "Wenn Sie beim Ausführen Ihrer IEC-Applikation oder bei Operationen mit Ihrem CODESYS -Laufzeitsystem Deadlocks oder ein Hängen von Semaphoren beobachten, kann dies durch Semphorensperren \/ Deadlocks verursacht worden sein. Laufzeitsysteme ab SP20 (Linux und Windows) sind in der Lage, mit einer Diagn...", 
"body" : "Wenn Sie beim Ausführen Ihrer IEC-Applikation oder bei Operationen mit Ihrem CODESYS -Laufzeitsystem Deadlocks oder ein Hängen von Semaphoren beobachten, kann dies durch Semphorensperren \/ Deadlocks verursacht worden sein. Laufzeitsysteme ab SP20 (Linux und Windows) sind in der Lage, mit einer Diagnosefunktion für Semaphoren zu helfen. Mit dieser Diagnose kann die Semaphore oder die Interaktion zwischen verwandten Tasks, die auf der problematischen Semaphore arbeiten, gefunden werden. Diese Funktion müssen Sie in der Konfigurationsdatei aktivieren: [SysSem]\nSemEnterDiagnosis=1 Dies kann schwerwiegende Auswirkungen auf die Leistung und das Zeitverhalten der Anwendung (und der Laufzeit) haben. Nur für Diagnosezwecke verwenden Nicht in Produktivsystemen verwenden Die Ausgabe könnte folgendermaßen aussehen In diesem Beispiel hält MainTask_1 eine Semaphore für einige Millisekunden, und MainTask versucht, auf diese Semaphore zuzugreifen. " }, 
{ "title" : "Die IEC-Applikation kann keine weiteren Datei-Handles öffnen ", 
"url" : "_rtsl_toubleshooting_iec_filehandles.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ IEC-Applikation \/ Die IEC-Applikation kann keine weiteren Datei-Handles öffnen ", 
"snippet" : "Bevor Sie das Limit für Datei-Handles auf Ihrem System ändern, sollten Sie dringend die Konsequenzen für alle Dienste auf Ihrem Linux-System bedenken. Wir empfehlen stattdessen die Ursache für das Leck zu finden....", 
"body" : "Bevor Sie das Limit für Datei-Handles auf Ihrem System ändern, sollten Sie dringend die Konsequenzen für alle Dienste auf Ihrem Linux-System bedenken. Wir empfehlen stattdessen die Ursache für das Leck zu finden. " }, 
{ "title" : "Fehlerbehebung ", 
"url" : "_rtsl_toubleshooting_iec_filehandles.html#UUID-4043602f-b92d-ba82-ffe1-5d6eea5cf6f5_section-idm234795576141488", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ IEC-Applikation \/ Die IEC-Applikation kann keine weiteren Datei-Handles öffnen \/ Fehlerbehebung ", 
"snippet" : "Folgende Effekte können durch ein Datei-Handle-Leck verursacht werden: Verlust des Lizenzstatus. Die WIBU-Lizenz wird nach einer bestimmten Zeit unterbrochen. Neue Dateien können nicht geöffnet werden. Das Standardverhalten von Linux-Prozessen ist, eine maximal zulässige Anzahl von offenen Datei-Han...", 
"body" : "Folgende Effekte können durch ein Datei-Handle-Leck verursacht werden: Verlust des Lizenzstatus. Die WIBU-Lizenz wird nach einer bestimmten Zeit unterbrochen. Neue Dateien können nicht geöffnet werden. Das Standardverhalten von Linux-Prozessen ist, eine maximal zulässige Anzahl von offenen Datei-Handles zu erlauben. Wenn ein Prozess dieses Limit erreicht, können keine neuen Dateien mehr geöffnet werden. Sie können den Grenzwert Ihres Systems mit dem Konsolenbefehl überprüfen: ulimit -n Jeder Prozess in Linux hat eine Prozess-ID und der Kernel stellt detaillierte Informationen über jeden Prozess in seinem Datei-\/Ordnersystem procfs bereit. Somit können Sie einfach die Anzahl der Datei-Handles ermitteln, die ein Prozess zu einem bestimmten Zeitpunkt hat. Wir empfehlen die folgenden Schritte, um ein mögliches Dateihandle-Leck zu untersuchen: Finden Sie die Prozess-ID der CODESYS -Laufzeitumgebung Sie können Standard-Linux-Tools verwenden, um die Prozess-ID der CODESYS -Laufzeitumgebung zu finden: htop zeigt normalerweise die Prozess-ID in der erste Spalte (PID) an. top zeigt normalerweise die Prozess-ID in der erste Spalte (PID) an. Sie können die Befehle ps und grep für eine schnelle Suche kombinieren: ps aux | grep codesyscontrol Notieren Sie sich die Prozess-ID und verwenden Sie sie in den folgenden Befehlen, in denen der Platzhalter <pid> verwendet wird Überprüfung und Überwachung der Datei-Handles Listen Sie nun die Einträge im procfs , um die Datei-Handles des Laufzeitprozesses zu sehen. sudo ls -la \/proc\/<pid>\/fd\/ Dies könnte folgendermaßen aussehen Wenn es sich bei den Datei-Handles um „echte“ Dateien handelt, können Sie den Pfad sehen. Andere Datei-Handles könnten Sockets oder ähnliches sein. Wenn Sie diesen Befehl mehrmals hintereinander ausführen, können Sie beobachten, ob Sie eine zunehmende Anzahl von Datei-Handles haben und welche Dateien geöffnet sind. Mit dem Befehl watch wird eine Ansicht erstellt, die sich alle 2 Sekunden aktualisiert. watch sudo ls -la \/proc\/<pid>\/fd\/ Mit diesen Maßnahmen können Sie die geöffneten Handles überwachen und somit herausfinden, welche Dateien an dem Dateihandle-Leck beteiligt sein könnten. " }, 
{ "title" : "Der Speicherverbrauch meiner IEC-Applikation nimmt zu ", 
"url" : "_rtsl_toubleshooting_iec_memory.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ IEC-Applikation \/ Der Speicherverbrauch meiner IEC-Applikation nimmt zu ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Vorbereitungen ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234795798419608", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ IEC-Applikation \/ Der Speicherverbrauch meiner IEC-Applikation nimmt zu \/ Vorbereitungen ", 
"snippet" : "Sie benötigen ein Laufzeitsystem, in der die Komponente CmpMemGC aktiviert und aktiv ist. Sie können im Runtime-Protokoll überprüfen, ob diese Komponente geladen ist....", 
"body" : "Sie benötigen ein Laufzeitsystem, in der die Komponente CmpMemGC aktiviert und aktiv ist. Sie können im Runtime-Protokoll überprüfen, ob diese Komponente geladen ist. " }, 
{ "title" : "Fehlerbehebung ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234795576141488", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ IEC-Applikation \/ Der Speicherverbrauch meiner IEC-Applikation nimmt zu \/ Fehlerbehebung ", 
"snippet" : "Wenn Sie nach einer bestimmten Betriebszeit Ihrer IEC-Anwendung seltsame Effekte feststellen, wie den Verlust des Lizenzstatus oder dass kein neuer Speicher zugewiesen werden kann, könnte dies durch ein Speicherleck verursacht worden sein. Sie sollten diese Effekte untersuchen und herausfinden, wohe...", 
"body" : "Wenn Sie nach einer bestimmten Betriebszeit Ihrer IEC-Anwendung seltsame Effekte feststellen, wie den Verlust des Lizenzstatus oder dass kein neuer Speicher zugewiesen werden kann, könnte dies durch ein Speicherleck verursacht worden sein. Sie sollten diese Effekte untersuchen und herausfinden, woher das Problem kommt. " }, 
{ "title" : "CODESYS Memory DeviceTrace ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234796058905879", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ IEC-Applikation \/ Der Speicherverbrauch meiner IEC-Applikation nimmt zu \/ Fehlerbehebung \/ CODESYS Memory DeviceTrace ", 
"snippet" : "Diese Funktion ist in Laufzeitsystemen ab Version SP19 (SL Version 4.9.0.0) vorhanden und kann sehr einfach verwendet werden: Aktivieren Sie die Einstellung in der Laufzeitumgebung. Beenden Sie das Laufzeitsystem über das Deploy Tool . Verbinden Sie sich über putty oder einen anderen SSH-Client mit ...", 
"body" : "Diese Funktion ist in Laufzeitsystemen ab Version SP19 (SL Version 4.9.0.0) vorhanden und kann sehr einfach verwendet werden: Aktivieren Sie die Einstellung in der Laufzeitumgebung. Beenden Sie das Laufzeitsystem über das Deploy Tool . Verbinden Sie sich über putty oder einen anderen SSH-Client mit Ihrem Zielsystem. Öffnen Sie die Konfigurationsdatei der Laufzeitumgebung mit einem Texteditor (beispielsweise nano). sudo nano \/etc\/codesyscontrol\/CODESYSControl.cfg Fügen Sie den Eintrag EnableMemTrace=1 in den Abschnitt CmpMemGC hinzu. [CmpMemGC]\nEnableMemTrace=1 Speichern und schließen Sie die Datei. Starten Sie das Laufzeitsystem neu über das Deploy Tool . Fügen Sie den Device Trace zu Ihrem CODESYS -Projekt (in dem dieses Problem auftritt) hinzu. Rechtsklicken Sie auf das Gerät im Gerätebaum. Wählen Sie den Befehl Objekt hinzufügen → Device Trace . Das Objekt Device Trace wird unterhalb der Steuerung eingefügt. Die Registerkarte Device Trace wird angezeigt. Wählen Sie den Befehl Trace → Trace hochladen . Der Dialog Online-Traces des Geräts 'CODESYS_Control_for_Linux_SL' wird angezeigt. Wenn Sie den Eintrag MemGCTrace nicht finden können, ist die Einstellung aus Schritt 1 nicht richtig gesetzt. Sollte Ihre Steuerung den Mechanismus nicht unterstützen, verwenden Sie für die Diagnose eine der beiden nachfolgenden Möglichkeiten. Wählen Sie den Eintrag MemGCTrace und klicken Sie auf Hochladen und Dialog schließen . Der Speicher-Trace ( MemGCTrace ) ist zum DeviceTrace hinzugefügt. Für weitere Informationen siehe: Befehl: Trace hochladen " }, 
{ "title" : "CODESYS -Bibliothek SysMem ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234796059265431", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ IEC-Applikation \/ Der Speicherverbrauch meiner IEC-Applikation nimmt zu \/ Fehlerbehebung \/ CODESYS -Bibliothek SysMem ", 
"snippet" : "Sie können auch programmatisch auf interne Informationen zugreifen. Über IEC-Bibliotheksfunktionen können Sie auf die aktuelle Übersicht aller alloziierten RAM- \/ Heap-Speicher zugreifen. SysMem.SysMemGetCurrentHeapSize() Dieser Wert kann verwendet werden, um die aktuelle Heap-Größe zu beobachten. S...", 
"body" : "Sie können auch programmatisch auf interne Informationen zugreifen. Über IEC-Bibliotheksfunktionen können Sie auf die aktuelle Übersicht aller alloziierten RAM- \/ Heap-Speicher zugreifen. SysMem.SysMemGetCurrentHeapSize() Dieser Wert kann verwendet werden, um die aktuelle Heap-Größe zu beobachten. Sie können diesen Wert überwachen oder ihn in einen Trace schreiben. So können Sie feststellen, ob der Anstieg des allozierten Speichers in einem zeitlichen Zusammenhang mit bestimmten anderen Ereignissen Ihrer IEC-Anwendung steht. " }, 
{ "title" : "Linux-Kommandozeile ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234796059607787", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ IEC-Applikation \/ Der Speicherverbrauch meiner IEC-Applikation nimmt zu \/ Fehlerbehebung \/ Linux-Kommandozeile ", 
"snippet" : "Wenn Sie Zugriff auf die Linux-Konsole haben (beispielsweise über einen SSH-Client), können Sie auch das Speicherverhalten überprüfen. Es gibt verschiedene Werkzeuge und Befehle, um dies zu erreichen: htop \/ top Dies sind grafische Werkzeuge zur Analyse der Prozesse (und Threads) auf einem Linux-Sys...", 
"body" : "Wenn Sie Zugriff auf die Linux-Konsole haben (beispielsweise über einen SSH-Client), können Sie auch das Speicherverhalten überprüfen. Es gibt verschiedene Werkzeuge und Befehle, um dies zu erreichen: htop \/ top Dies sind grafische Werkzeuge zur Analyse der Prozesse (und Threads) auf einem Linux-System. Fast alle Linux-Distributionen bieten diese Werkzeuge an, so dass Sie sie einfach über apt oder dnf oder die Paketverwaltung der Distribution installieren können. htop \n# or \ntop Beide Werkzeuge können verwendet werden, um die Threads in einer Baumansicht zu sehen und den CODESYS -Laufzeitprozess und seine Threads zu analysieren. Jede IEC-Task ist ein pthread innerhalb des Laufzeitprozesses. Im Werkzeug htop können Sie die Ansicht über F2 (Setup-Menü) anpassen: Wir empfehlen Ihnen, die Optionen Tree view und show custom thread names zu aktivieren. Im oberen Bereich können Sie die Baumansicht mit der Tastenkombination Shift + V aktivieren und somit die CPU-Nutzung \/ Speichernutzung pro Thread sehen. So können Sie feststellen, ob der Anstieg des alloziierten Speichers in einem zeitlichen Zusammenhang mit bestimmten anderen Ereignissen Ihrer IEC-Anwendung steht, oder ob Sie überhaupt ein Speicherleck haben. " }, 
{ "title" : "Das Safety-Laufzeitsystem zeigt in der Logdatei Timing-Fehler ", 
"url" : "_rtsl_toubleshooting_iec_safety.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ IEC-Applikation \/ Das Safety-Laufzeitsystem zeigt in der Logdatei Timing-Fehler ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Vorbereitungen ", 
"url" : "_rtsl_toubleshooting_iec_safety.html#UUID-fb433041-da54-96ca-38a9-082bdc100698_section-idm234795798419608", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ IEC-Applikation \/ Das Safety-Laufzeitsystem zeigt in der Logdatei Timing-Fehler \/ Vorbereitungen ", 
"snippet" : "Sie betreiben eine CODESYS Safe Control SL oder CODESYS Virtual Safe Control SL in Kombination mit dem CODESYS Safe Time Provider ....", 
"body" : "Sie betreiben eine CODESYS Safe Control SL oder CODESYS Virtual Safe Control SL in Kombination mit dem CODESYS Safe Time Provider . " }, 
{ "title" : "Fehlerbehebung ", 
"url" : "_rtsl_toubleshooting_iec_safety.html#UUID-fb433041-da54-96ca-38a9-082bdc100698_section-idm234795576141488", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ IEC-Applikation \/ Das Safety-Laufzeitsystem zeigt in der Logdatei Timing-Fehler \/ Fehlerbehebung ", 
"snippet" : "Wenn Sie auf Probleme stoßen, die von der CODESYS Safe Control SL-Laufzeitumgebung gemeldet werden und Timing-Probleme erwähnen (von der Komponente CmpSIL3 ), haben Sie möglicherweise Timing-Probleme im sicheren Zeitnetzwerk, die Sie untersuchen sollten. Eine Log-Meldung könnte folgendermaßen ausseh...", 
"body" : "Wenn Sie auf Probleme stoßen, die von der CODESYS Safe Control SL-Laufzeitumgebung gemeldet werden und Timing-Probleme erwähnen (von der Komponente CmpSIL3 ), haben Sie möglicherweise Timing-Probleme im sicheren Zeitnetzwerk, die Sie untersuchen sollten. Eine Log-Meldung könnte folgendermaßen aussehen: #### Exception: ID: 0x40000066 <p0>0xb633<\/p0> <p1>0xbcdd<\/p1> <p2>0xbce1<\/p2> <p3>0xb2fd<\/p3> <p4>0x0<\/p4> Die Ausnahmefehler habe die folgende Bedeutung: 0x40000065 : Ausnahmefehler Kanal x: Plausibilitätsprüfung des lokalen Zeitstempels zur Zykluszeit 0x40000066 : Ausnahmefehler Kanal x: Plausibilitätsprüfung des entfernten Zeitstempels zur Zykluszeit 0x40000067 : Ausnahmefehler Kanal x: Plausibilitätsprüfung des entfernten Zeitstempels zum lokalen Zeitstempel Das sichere Zeitnetzwerk (zwischen dem CODESYS Safe Time Provider und der CODESYS Safe Control -Laufzeitumgebung) hat die gleichen hohen Anforderungen an Stabilität und Echtzeit wie ein Feldbusnetzwerk (beispielsweise EtherCAT oder Profinet). " }, 
{ "title" : "Nachverfolgung mit tcpdump ", 
"url" : "_rtsl_toubleshooting_iec_safety.html#UUID-fb433041-da54-96ca-38a9-082bdc100698_section-idm234795897227037", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ IEC-Applikation \/ Das Safety-Laufzeitsystem zeigt in der Logdatei Timing-Fehler \/ Fehlerbehebung \/ Nachverfolgung mit tcpdump ", 
"snippet" : "Mit dem Tool tcpdump können Sie auf der Linux-Kommandozeile leicht ein Trace erstellen. Wenn Sie bereits mit WireShark oder einem Hardware-Trace-Gerät vertraut sind, können Sie auch damit einen Trace erstellen. Die grundlegenden Schritte, die Sie befolgen müssen: Ermitteln Sie den Netzwerkadapter, d...", 
"body" : "Mit dem Tool tcpdump können Sie auf der Linux-Kommandozeile leicht ein Trace erstellen. Wenn Sie bereits mit WireShark oder einem Hardware-Trace-Gerät vertraut sind, können Sie auch damit einen Trace erstellen. Die grundlegenden Schritte, die Sie befolgen müssen: Ermitteln Sie den Netzwerkadapter, den Sie verfolgen möchten. Finden Sie heraus, was Sie verfolgen wollen (Inhalt\/Paketart\/Protokoll usw.) (um den Trace kleiner zu machen). Nützliche Befehle Installieren Sie tcpdump (abhängig von Ihrer Distribution \/ Softwarepaketverwaltung) beispielsweise debian\/ubuntu „apt“-basiert: sudo apt install tcpdump RedHat-„yum\/dnf“-basiert: sudo yum install tcpdump Sie können alle verfügbaren Netzwerkadapter sehen, die tcpdump monitoren kann: > tcpdump -D \n1.eno1 [Up, Running, Connected]\n2.any (Pseudo-device that captures on all interfaces) [Up, Running]\n3.lo [Up, Running, Loopback] Es ist möglich, tcpdump als normaler Benutzer auszuführen. Wenn Sie dies tun möchten, lesen Sie bitte die tcpdump -Dokumentation für weitere Details. tcpdump-Kommandozeilen-Argumente Details zu allen möglichen Befehlen mit tcpdump finden Sie in der tcpdump -Manpage: https:\/\/www.tcpdump.org\/manpages\/tcpdump.1.html Oder rufen Sie tcpdump auf: > tcpdump --help \n\ntcpdump version 4.99.3\nlibpcap version 1.10.3 (with TPACKET_V3)\nOpenSSL 3.0.15 3 Sep 2024\nUsage: tcpdump [-AbdDefhHIJKlLnNOpqStuUvxX#] [ -B size ] [ -c count ] [--count]\n                [ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]\n                [ -i interface ] [ --immediate-mode ] [ -j tstamptype ]\n                [ -M secret ] [ --number ] [ --print ] [ -Q in|out|inout ]\n                [ -r file ] [ -s snaplen ] [ -T type ] [ --version ]\n                [ -V file ] [ -w file ] [ -W filecount ] [ -y datalinktype ]\n                [ --time-stamp-precision precision ] [ --micro ] [ --nano ]\n                [ -z postrotate-command ] [ -Z user ] [ expression ] Die wichtigsten Flags \/ Filter: Flag (kurz\/lang) Beschreibung -D --list-interfaces Gibt die Liste der Netzwerkschnittstellen aus, die auf dem System verfügbar sind und auf denen der Befehl tcpdump Packages erfassen kann -i <interface> --interface <interface> Frägt die Schnittstelle ab und gibt folgende Informationen aus: Liste der Link-Layer-Typen Liste der Zeitstempeltypen Ergebnisse der Kompilierung eines Filterausdrucks -c <Count> Beendet die Abfrage nach Empfang oder Lesen einer Anzahl von <count> Packages -n Verhindert die Konvertierung von Adressen (Hostadressen, Portnummern usw.) in Namen -A Gibt jedes Package (abzüglich seines Link-Level-Headers) in ASCII aus -x Gibt beim Parsen neben den Kopfzeilen jedes Package auch die Daten jedes Package (abzüglich der Link-Level-Kopfzeilen) in hexadezimal aus -s <snaplen> --snapshot-length=<snaplen> Verwendet <snaplen> Bytes von Daten aus jedem Paket anstelle des Standardwerts von 262144 Bytes -w <file> Schreibt die Rohdaten-Packages in eine Datei, anstatt sie zu analysieren und auszugeben -t Verhindert die Ausgabe eines Zeitstempels in jeder Dump-Zeile -tt Gibt den Zeitstempels in jeder Dump-Zeile aus, als Sekunden seit dem 1. Januar 1970, 00:00:00, UTC, und Sekundenbruchteile seit diesem Zeitpunkt -ttt Gibt ein Delta (Mikrosekunden- oder Nanosekunden-Auflösung, abhängig von der Option --time-stamp-precision ) aus zwischen der aktuellen und der vorherigen Zeile in jeder Dump-Zeile. Die Standardeinstellung ist eine Auflösung in Mikrosekunden. -tttt Gibt einen Zeitstempels in jeder Dump-Zeile aus in Form von Stunden, Minuten, Sekunden und Sekundenbruchteilen seit Mitternacht. Der Ausgabe ist das Datum vorangestellt. -v Gibt zusätzliche Informationen aus Nachverfolgung des Package Einfache Erfassung und Ausgabe auf der Konsole: > sudo tcpdump -i <interfacename>\n\n# e.g. with interface \"eno1\":\n> sudo tcpdump -i eno1 Erfassung und Ausgabe als „Wireshark“-kompatible Datei > sudo tcpdump -i <interfacename> -w <file>\n \n# e.g.\n> sudo tcpdump -i eno1 -w myfirsttrace.pcap Dann kann die Datei myfirsttrace.pcap in WireShark geöffnet werden ( .pcap ist die Standard-Dateierweiterung für WireShark-Trace-Dateien). Beispiel > sudo tcpdump -i eno1 -w myfirsttrace.cap -s 200 udp port 60000 " }, 
{ "title" : "Untersuchung \/ Analyse ", 
"url" : "_rtsl_toubleshooting_iec_safety.html#UUID-fb433041-da54-96ca-38a9-082bdc100698_section-idm234795898218432", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Fehlerbehebung \/ IEC-Applikation \/ Das Safety-Laufzeitsystem zeigt in der Logdatei Timing-Fehler \/ Fehlerbehebung \/ Untersuchung \/ Analyse ", 
"snippet" : "Nachdem ein Trace erstellt wurde, muss dieser analysiert werden. Dies kann mit tcpdump oder grafisch mit WireShark erfolgen Zeichnen Sie die Aufzeichnung auf dem Host der Safe Control SL (Empfangsseite der Zeitgeberkommunikation) auf, wie im obigen Beispiel gezeigt. Öffnen Sie dann die pcap-Datei mi...", 
"body" : "Nachdem ein Trace erstellt wurde, muss dieser analysiert werden. Dies kann mit tcpdump oder grafisch mit WireShark erfolgen Zeichnen Sie die Aufzeichnung auf dem Host der Safe Control SL (Empfangsseite der Zeitgeberkommunikation) auf, wie im obigen Beispiel gezeigt. Öffnen Sie dann die pcap-Datei mit Wireshark. Sie sieht dann ähnlich aus wie diese: Sie werden feststellen, dass die Pakete normalerweise mit einem Intervall von 1 Millisekunde (der Zeitdifferenz zwischen den Paketen) gesendet werden, siehe Paket Nummer 58 und folgende. Eine typische problematische Situation, in der CODESYS Safe Control SL aufgrund des Timings eine Ausnahme \/ ein Problem auslöst, ist in Paket Nummer 74 zu sehen: Dieses Paket wird ~ 2 ms nach dem vorherigen Paket empfangen, die Verzögerung beträgt also ~ 1 ms. Dies ist für CODESYS Safe Control SL nicht akzeptabel als ein zuverlässiger und echtzeitfähiger Zeitstempel Maßnahmen zur Reduzierung der Verzögerung Finden Sie heraus, ob das Problem auf Empfangsseite oder Sendeseite sichtbar ist. Dabei müssen Sie sowohl die Empfangsseite ( CODESYS Safe Control -Host) also auch die sendende Seite ( CODESYS Safe Time Provider -Host) betrachten. Verbessern Sie die Echtzeitfähigkeiten und die Robustheit dieser Zeitstempelkommunikation im Allgemeinen. Dies erreichen Sie, indem Sie andere störende Kommunikation und Last aus diesem Netz entfernen (ausschließliche Verwendung für sichere Zeitstempel). Verbessern Sie die Sende- und Empfangsleistung durch Konfigurieren der Prozesspriorität des entsprechenden IRQ (des Netzwerktreibers). Wenn Sie keine weitere Verbesserung erzielen können und Ihr Sicherheitsprozess dies zulässt, können Sie die Zykluszeit des CODESYS Safe Time Provider (Senden des Zeitstempels) erhöhen. " }, 
{ "title" : "Referenz ", 
"url" : "_rtsl_reference_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Referenz ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Befehl Control SL ausrollen ", 
"url" : "_rtsl_cmd_deploy_control_sl.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Referenz \/ Befehl Control SL ausrollen ", 
"snippet" : "Funktion : Der Befehl öffnet die Registerkarten Kommunikation , Bereitstellung und Operation . Aufruf : Menü Tools Für weitere Informationen siehe: Registerkarte BereitstellungRegisterkarte KommunikationRegisterkarte Operation...", 
"body" : "Funktion : Der Befehl öffnet die Registerkarten Kommunikation , Bereitstellung und Operation . Aufruf : Menü Tools Für weitere Informationen siehe: Registerkarte BereitstellungRegisterkarte KommunikationRegisterkarte Operation" }, 
{ "title" : "Registerkarte Bereitstellung ", 
"url" : "_rtsl_dlg_deploy_deployment.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Referenz \/ Registerkarte Bereitstellung ", 
"snippet" : "Produkt installieren und bereitstellen Produkt Das zu installierende Produkt Wenn ein Produkt ausgewählt ist, werden im unteren Teil der Registerkarte die installierten CODESYS -Packages angezeigt. Dabei werden nur Packages angezeigt, die auf dem aktuell verbundenen Gerät installiert werden können. ...", 
"body" : "Produkt installieren und bereitstellen Produkt Das zu installierende Produkt Wenn ein Produkt ausgewählt ist, werden im unteren Teil der Registerkarte die installierten CODESYS -Packages angezeigt. Dabei werden nur Packages angezeigt, die auf dem aktuell verbundenen Gerät installiert werden können. Version Die zu installierende Version des ausgewählten Produkts. Wenn die ausgewählte Version des Produkts bereits installiert ist, wird rechts von der Auswahlliste ein Hinweis angezeigt. Installieren Startet die Installation Installierte Packages Produkt Der Produktname des Packages Version Die Version des Packages Installierte Images Produkt Zugehöriges Produkt (Runtime, Safe-Runtime, Edge-Gateway, Timeprovider) Image-Version Die Version des Image Architektur Die Architektur des Image. Dies ist relevant, wenn die Steuerung und Container-Engine mehrere Architekturen unterstützt. Verwendet von Eine Liste der Instanzen, die dieses Image verwenden " }, 
{ "title" : "Registerkarte Kommunikation ", 
"url" : "_rtsl_dlg_deploy_communication.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Referenz \/ Registerkarte Kommunikation ", 
"snippet" : "Einloggen IP-Adresse Die IP-Adresse der Steuerung mit der Sie sich verbinden. Alternativ kann hier der Hostname der Steuerung verwenden werden. Wenn weder Hostname noch IP-Adresse bekannt sind, können mit dem Befehl Durchsuchen die verfügbaren Geräte angezeigt werden. Über die MAC-Adresse kann dann ...", 
"body" : "Einloggen IP-Adresse Die IP-Adresse der Steuerung mit der Sie sich verbinden. Alternativ kann hier der Hostname der Steuerung verwenden werden. Wenn weder Hostname noch IP-Adresse bekannt sind, können mit dem Befehl Durchsuchen die verfügbaren Geräte angezeigt werden. Über die MAC-Adresse kann dann das Gerät gefunden werden. Wenn keine dieser Informationen bekannt sind, müssen Sie sich direkt mit der Steuerung verbinden, um den Hostnamen oder die IP-Adresse herauszufinden. Port Der Port, über den Sie sich verbinden Durchsuchen Öffnet den Dialog Verfügbare Geräte . Darin werden die sichtbaren Geräte im Netzwerk angezeigt. Benutzername Der Account, mit dem Sie sich auf der Steuerung anmelden Passwort Das Passwort des Accounts, mit dem Sie sich anmelden Status Der aktuelle Verbindungsstatus Verbinden Stellt eine Verbindung zur Steuerung mit den oben angegeben Parametern her Trennen Trennt die aktuelle Verbindung Schlüsselbasiertes Einloggen SSH-Login schlüsselbasiert : Aktiviert die Verwendung des ausgewählten SSH-Keys Passphrase Optional, die Passphrase für den ausgewählten SSH-Key Schlüsseldatei Auswahlliste mit den konfigurierten SSH-Keys Schlüsseldatei hinzufügen Öffnet die Optionen Runtime Deploy Tool . Dort können Sie SSH-Keys hinzufügen. Geräteinformation Neustart Startet die Steuerung neu Dialog Verfügbare Geräte Oberstes Eingabefeld Filter für IP- oder MAC-Adresse Abbrechen Schließt den Dialog Erneut durchsuchen Startet den Scanvorgang erneut OK Wenn ein Eintrag aus der Liste ausgewählt ist, wird dessen IP-Adresse in das Feld IP-Adresse im äußeren Dialog eingefügt. " }, 
{ "title" : "Registerkarte Operation ", 
"url" : "_rtsl_dlg_deploy_operation.html", 
"breadcrumbs" : "CODESYS Control \/ Linuxbasierte Laufzeitsysteme \/ Referenz \/ Registerkarte Operation ", 
"snippet" : "Services Alle starten Startet alle aufgelisteten Services Alle stoppen Stoppt alle aufgelisteten Services Ausgewählte starten Startet den ausgewählten Service Ausgewählte stoppen Stopp den ausgewählten Service Produkt Der Name des Service Zustand Aktueller Status des Service Refresh Ruft den aktuell...", 
"body" : "Services Alle starten Startet alle aufgelisteten Services Alle stoppen Stoppt alle aufgelisteten Services Ausgewählte starten Startet den ausgewählten Service Ausgewählte stoppen Stopp den ausgewählten Service Produkt Der Name des Service Zustand Aktueller Status des Service Refresh Ruft den aktuellsten Stand aller Elemente ab und aktualisiert die Tabellen Duplizieren Erstellt eine neue Instanz auf Basis des aktuell ausgewählten Services Export Erstellt eine Export-Datei im zip-Format. Darin ist die aktuell ausgewählten Instanz enthalten. Import Öffnet einen Dialog zum Importieren einer zuvor generierte Export-Datei VPLCs Alle starten Startet alle aufgelisteten VPLCs Alle stoppen Stoppt alle aufgelisteten VPLCs Ausgewählte starten Startet die ausgewählte VPLC Ausgewählte stoppen Stoppt die ausgewählt VPLC Instanz Name der VPLC Zustand Status der VPLC Produkt Art der VPLC (Runtime, Safe-Runtime, Edge-Gateway, Timeprovider) Abängigkeiten Andere Instanzen, von denen die ausgewählte Instanz abhängt. Diese anderen Instanzen werden vor der ausgewählten Instanz gestartet und nach dieser gestoppt. Öffnet den Dialog Neue Instanz hinzufügen Löschen einzelner oder aller Instanzen. Eine laufende Instanz kann nicht gelöscht werden.\"Purge\" löscht alle Instanzen und installierten Images. Aktualisiert den aktuellsten Stand aller Elemente Aktionen Abhängig vom ausgewählten Element werden unterschiedliche Befehle angezeigt. Protokoll anzeigen Zeigt das Log des jeweiligen Elements an Bootapplikation deaktivieren Deaktiviert die Bootapplikation der Runtime WBM öffnen Öffnet das CODESYS Web Based Management im Browser Einstellungen Eine dynamische Liste aller Optionen für das ausgewählte Element. Eine ausführliche Beschreibung der jeweiligen Optionen finden Sie im Kapitel Konfigurieren und ErweiternSpeichern Der Befehl wird aktiviert, sobald eine Einstellung verändert und in der Konfiguration keine Fehler erkannt wurden. Neue Instanz hinzufügen Name Der Name der neuen Instanz Filter Filter für die Liste an verfügbaren Images Image Liste an verfügbaren Images OK Wird aktiviert, wenn ein Image ausgewählt und ein gültiger Name eingegeben wurde. Die neue Instanz wird erstellt und angezeigt. Abbrechen Schliesst den Dialog, es werden keinerlei Änderungen vorgenommen Nic konfigurieren Verfügbare Adapter Die auf dem System aktuell verfügbaren Adapter. Wenn ein Adapter bereits auf eine Instanz abgebildet wurde, wird in dieser Liste ein kleiner Hinweis angezeigt. Auf Instanz abbilden Bestimmt, ob dieser Adapter auf die aktuell ausgewählte Instanz abgebildet wird Adapter Kann nicht verändert werden. Zeigt den Namen des ausgewählten Adapters IP IP-Adresse dieses Adapters im Container. Wenn dieser Wert angegeben wird, muss auch die Maske angegeben werden. Maske Netzwerkmaske dieses Adapters im Container. Wenn dieser Wert angegeben wird, muss auch die IP-Adresse angegeben werden. " }, 
{ "title" : "Windowsbasierte Laufzeitsysteme ", 
"url" : "_rtsl_windows_runtime_systems.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Erste Schritte ", 
"url" : "_rtsl_first_steps_win.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte ", 
"snippet" : "In diesem Kapiel erfahren Sie, wie Sie ein Gerät mit CODESYS Control SL-Laufzeitsystem in Betrieb nehmen, eine kleine CODESYS -Applikation starten und die Steuerung lizenzieren....", 
"body" : "In diesem Kapiel erfahren Sie, wie Sie ein Gerät mit CODESYS Control SL-Laufzeitsystem in Betrieb nehmen, eine kleine CODESYS -Applikation starten und die Steuerung lizenzieren. " }, 
{ "title" : "Laufzeitsystem auf Steuerung installieren ", 
"url" : "_rtsl_first_steps_win.html#UUID-965da881-e78f-71a0-a964-5d8b615dfdfc", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ Laufzeitsystem auf Steuerung installieren ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS Control RTE installieren ", 
"url" : "_rtsl_first_steps_win.html#UUID-965da881-e78f-71a0-a964-5d8b615dfdfc_section-idm43305899023692", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ Laufzeitsystem auf Steuerung installieren \/ CODESYS Control RTE installieren ", 
"snippet" : "Die ausführbare Datei Setup_CODESYSControlRTE<32|64>V3.<version>setup.exe des Installationspakets wird im Folgenden „Setup“ genannt. Das Setup installiert alle verfügbaren Treiber, die im Paket enthalten sind. Das Setup ermittelt den Typ der Plattform, auf der installiert werden soll, und passt - na...", 
"body" : "Die ausführbare Datei Setup_CODESYSControlRTE<32|64>V3.<version>setup.exe des Installationspakets wird im Folgenden „Setup“ genannt. Das Setup installiert alle verfügbaren Treiber, die im Paket enthalten sind. Das Setup ermittelt den Typ der Plattform, auf der installiert werden soll, und passt - nach einer Bestätigung von Ihnen - die Konfigurationsdatei CODESYSControl.cfg automatisch an. Das Arbeitsverzeichnis der CODESYS Control RTE ist standardmäßig C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 . Voraussetzungen: Sie wissen, wie viele CPU-Kerne das System hat, auf dem Sie die CODESYS Control RTE installieren wollen. Sie haben die oben beschriebenen Vorbereitungen auf Ihrem System getroffen. (Im „System“-Dialog der Windows-Systemsteuerung finden Sie die genaue Bezeichnung Ihrer CPU und können damit im Internet die Anzahl der physikalischen CPU-Kerne recherchieren.) Bitte beachten Sie auch die Hinweise zur Hardwarekonfiguration: Hardwarekonfiguration - EmpfehlungenLaden Sie das Installationspaket auf Ihren Computer. Die CODESYS Control RTE ist im CODESYS Store International als Single-License-Version erhältlich. Starten Sie die Installation durch Ausführen der Datei CODESYS Control RTE <32|64> <version>.exe . Folgen Sie dem Assistenten mit den Standardeingaben, bis der Dialog MultiCore CPU Usage erscheint. Ergebnis: Der Installationsassistent versucht, die gesamte Anzahl der physikalischen Prozessorkerne Cores Total zu ermitteln. Bitte prüfen und korrigieren Sie gegebenenfalls diese Angabe. Legen Sie bei Cores RTE fest, wie viele Prozessorkerne exklusiv für die CODESYS Control RTE -Tasks reserviert werden sollen. Diese Kerne stehen dann für Windows nicht mehr zur Verfügung („AMP“-Modus). Hinweis: Die bereits eingetragene Zahl (Beispiel 6 ) ist nur ein Vorschlag des Setups. Normalerweise kann das Setup die Anzahl der physikalischen CPU-Kerne Ihres Systems korrekt ermitteln. Ein CPU-Kern, der von Windows angezeigt wird, kann auch ein „logischer“ CPU-Kern sein, der nicht geeignet ist, um ein Echtzeitsystem darauf zu betreiben („Hyperthreading-Kern“). Befolgen Sie auch den Hinweis Hyperthreading MUST be disabled by BIOS settings! . CPU-Features wie Hyperthreading beeinflussen das Echtzeitverhalten negativ. Sie werden später noch in einem Dialog bestätigen müssen, dass das Setup durch Änderung der Bootkonfiguration des Systems einen CPU-Kern für die RTE reservieren soll. Dazu wird die Bootoption numproc auf <Anzahl physikalische Kerne minus 1 > gesetzt werden. Bestätigen Sie mit Next die angegebene Zahl der Kerne. Sie erhalten den Dialog Boot Options will change mit Informationen zu den vorgemerkten Änderungen an der Bootkonfiguration des PCs. Gehen Sie mit Next zum Dialog Set Boot Options? . Ergebnis: Im Dialog Set Boot Options entscheiden Sie, ob das Setup folgende Änderungen an der Startkonfiguration des Systems vornehmen soll: Begrenzung der Anzahl der CPU-Kerne, die für Windows zur Verfügung stehen, mittels der Bootoption „ numproc “ auf <Anzahl physikalischer Kerne> - 1 . Deaktivierung der Prozessorfunktionalität „Data Execution Prevention“. Abschalten der Prozessorfunktionalität „Physical Address Extension (PAE)“. Die Prozessor-Funktionalitäten „Data Execution Prevention“ und „PAE“ müssen nicht zwingend ausgeschaltet werden. Über eine manuelle Bearbeitung der Startkonfiguration können Sie auch nur die Anzahl der Kerne für Windows begrenzen. Eine solche Konfiguration wird aber von CODESYS nicht getestet. Die Bootoption numproc ist für das Funktionieren der RTE in dieser Konfiguration unbedingt notwendig. Wenn Sie sich hier also entscheiden, dass das Setup diese Option nicht setzen soll, müssen Sie die Option manuell aktivieren. Wenn das Setup die gerade beschriebenen Änderungen vornehmen soll, wählen Sie Yes… . Wenn Sie diese Änderungen statt dessen später noch manuell durchführen wollen, wählen Sie No… . Gehen Sie mit Next weiter zum Dialog Target Type of RTE . Ergebnis: Mit der Version CODESYS 3.5 SP17 ist eine Unterscheidung zwischen den Gerätetypen „Control“ und „Softmotion“ nicht mehr notwendig. Der Gerätetyp „Control“ beinhaltet auch die volle Funktionalität, die bisher Softmotion-Geräten vorbehalten war. Die Unterscheidung gibt es nur noch aus Kompatibilitätsgründen. Für neue Projekte wird empfohlen, „Control“ zu verwenden. Wählen Sie im Dialog Target Type of RTE den zu installierenden RTE-Typ: CODESYS Control RTE oder CODESYS SoftMotion RTE . Der Typ der Installation ist abhängig von Ihrer Anwendung und der Lizenz. Wählen Sie nur dann „Softmotion“, wenn Sie auch eine CODESYS SoftMotion RTE -Lizenz verwenden wollen und besitzen, sonst startet die RTE im zeitbegrenzten Demobetrieb. Im nachfolgenden Dialog Select Features können Sie die Auswahl der tatsächlich zu installierenden Funktionalitäten noch ändern: CODESYS SoftMotion RTE und CodeMeter ® for Windows . Sie können eine Umstellung zwischen den beiden CODESYS Control RTE -Typen auch später manuell durch Bearbeiten der Konfigurationsdatei CODESYSControl.cfg durchführen. Dazu müssen Sie in der Konfigurationsdatei CODESYSControl.cfg folgende Einträge vornehmen: [SysTarget] TargetType=0x1006 DeviceName=CODESYS SoftmotionRTE V3 Durch Löschen dieser Einträge (oder Voranstellen eines Strichpunkts) erhält man wieder eine CODESYS Control RTE . Wählen Sie im Dialog Select Features welche Funktionalitäten Sie installieren wollen. Öffnen Sie die Firewall, wenn Sie von anderen Computern auf die CODESYS Control RTE zugreifen wollen. Dies ist beispielsweise für Kommunikation mit CODESYS , CODESYS -OPC und beim Einsatz von Ethernet-basierten Feldbussen notwendig. Ergebnis: In einem der Ausführungsschritte erhalten Sie noch die Abfrage, ob durch Erstellen und Aktivieren eines Hardwareprofils die Zeitgenauigkeit der CODESYS Control RTE erhöht werden soll. Wenn Sie dies bejahen, wird die Energieoption „Höchstleistung“ (Systemsteuerung -> Energieoptionen) gewählt, und die CPU-Frequenz wird auf 100% festgelegt. Nach erfolgreicher Beendigung der Installation erscheint in der Statusleiste des Bildschirms das Symbol . Mit einem Rechtsklick darauf können Sie das CODESYS Control RTE -Menü öffnen. Die Konfigurationsdatei CODESYSControl.cfg wird automatisch angepasst. Prüfen Sie, ob die aktuelle Gerätebeschreibung für CODESYS Control RTE in Ihrem CODESYS Development System installiert ist. Diese Installation ist nötig, um CODESYS Control RTE mit CODESYS verwenden zu können. (Das Entwicklungssystem befindet sich nicht notwendigerweise auf dem Zielsystem, auf dem die RTE läuft.) Wenn Sie die Gerätebeschreibung neu installieren müssen, beispielsweise weil eine nachträgliche Änderung nötig war, öffnen Sie das CODESYS -Geräterepository und wählen Sie den Befehl Installieren . Die zur RTE passenden Beschreibungsdateien ( .devdesc.xml ) werden vom Setup im Installationsverzeichnis Others erzeugt. Führen Sie den Neustart, der zum Abschluss der Installation gefordert wird, unbedingt durch. Für weitere Informationen siehe: Geräte installieren " }, 
{ "title" : "Konfiguration von CODESYS Control RTE anpassen ", 
"url" : "_rtsl_first_steps_win.html#UUID-965da881-e78f-71a0-a964-5d8b615dfdfc_section-idm43305899148826", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ Laufzeitsystem auf Steuerung installieren \/ CODESYS Control RTE installieren \/ Konfiguration von CODESYS Control RTE anpassen ", 
"snippet" : "Voraussetzung: Sie haben die Installation wie oben beschrieben durchgeführt. Sie haben CODESYS installiert. Es gibt folgende Optionen: Sie wollen Ihr Gerät mit der nach der Installation vorliegenden Konfiguration verwenden: Fahren Sie nun mit der unten folgenden Anleitung „ CODESYS Control RTE start...", 
"body" : "Voraussetzung: Sie haben die Installation wie oben beschrieben durchgeführt. Sie haben CODESYS installiert. Es gibt folgende Optionen: Sie wollen Ihr Gerät mit der nach der Installation vorliegenden Konfiguration verwenden: Fahren Sie nun mit der unten folgenden Anleitung „ CODESYS Control RTE starten“ fort. Sie wollen die Konfiguration der lokal installierten CODESYS Control RTE noch anpassen: Klicken Sie auf das CODESYS Control RTE -Symbol in der Systemleiste Ihres PCs. Wählen Sie im CODESYS Control RTE -Menü den Befehl PLC Configuration , um den Konfigurationseditor zu öffnen. Bearbeiten Sie die Einstellungen wie gewünscht. Sie wollen die auf einem entfernten PC installierte CODESYS Control RTE verwenden. Klicken Sie auf das CODESYS Control RTE -Symbol in der Systemleiste Ihres PCs. Wählen Sie im CODESYS Control RTE -Menü den Befehl Remote PLC . Konfigurieren Sie im sich öffnenden Dialog die Verbindungseinstellungen zur entfernten SPS. Die Konfiguration wird in der Konfigurationsdatei CODESYSControl.cfg im Verzeichnis C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 gespeichert. " }, 
{ "title" : "CODESYS Control Win installieren ", 
"url" : "_rtsl_first_steps_win.html#UUID-965da881-e78f-71a0-a964-5d8b615dfdfc_section-idm4555504420804833058987427815", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ Laufzeitsystem auf Steuerung installieren \/ CODESYS Control Win installieren ", 
"snippet" : "Nach einer erfolgreichen Installation läuft CODESYS Control Win als Dienst auf Ihrem Computer. Sie erhalten eine Installation auf folgenden Wegen: Sie haben das CODESYS Development System installiert. Damit wird automatisch eine CODESYS Control Win -Version mit begrenzter Laufzeit auf Ihrem PC mit i...", 
"body" : "Nach einer erfolgreichen Installation läuft CODESYS Control Win als Dienst auf Ihrem Computer. Sie erhalten eine Installation auf folgenden Wegen: Sie haben das CODESYS Development System installiert. Damit wird automatisch eine CODESYS Control Win -Version mit begrenzter Laufzeit auf Ihrem PC mit installiert. Sie haben CODESYS Control Win aus dem CODESYS Store geladen und durch Ausführen der Setup-Datei installiert. " }, 
{ "title" : "Laufzeitsystem starten ", 
"url" : "_rtsl_start_runtime-1816376.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ Laufzeitsystem starten ", 
"snippet" : "Hinweis : Für den Betrieb des Laufzeitsystems muss auf Ihrem PC eine gültige Lizenz installiert sein. Wenn dies nicht der Fall ist, startet die Steuerung zeitbegrenzt, jedoch mit vollem Funktionsumfang im Demobetrieb. Bei den Laufzeitsystemen handelt es sich um Gerätelizenzen. Sie aktivieren diese L...", 
"body" : "Hinweis : Für den Betrieb des Laufzeitsystems muss auf Ihrem PC eine gültige Lizenz installiert sein. Wenn dies nicht der Fall ist, startet die Steuerung zeitbegrenzt, jedoch mit vollem Funktionsumfang im Demobetrieb. Bei den Laufzeitsystemen handelt es sich um Gerätelizenzen. Sie aktivieren diese Lizenzen über den Lizenzmanager. Für weitere Informationen siehe: Produkte lizenzieren " }, 
{ "title" : "CODESYS Control RTE ", 
"url" : "_rtsl_start_runtime-1816376.html#UUID-065101d1-259a-9d21-37c7-74cc493827e0_section-idm43463171121528", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ Laufzeitsystem starten \/ CODESYS Control RTE ", 
"snippet" : "Starten Sie CODESYS Control RTE mit dem Befehl Start PLC des CODESYS Control RTE -Menüs ( ). Wenn das Symbol in der Systemleiste nicht vorhanden ist, stellen Sie sicher, dass korrekt installiert wurde. Mit Doppelklick auf die Datei CODESYSControlRTESysTray.exe im Installationsverzeichnis von CODESYS...", 
"body" : "Starten Sie CODESYS Control RTE mit dem Befehl Start PLC des CODESYS Control RTE -Menüs ( ). Wenn das Symbol in der Systemleiste nicht vorhanden ist, stellen Sie sicher, dass korrekt installiert wurde. Mit Doppelklick auf die Datei CODESYSControlRTESysTray.exe im Installationsverzeichnis von CODESYS Control RTE können Sie die Anzeige der Benutzerschnittstelle in der Systemleiste händisch starten. Das Symbol in der Systemleiste verändert sich nach Start von CODESYS Control RTE zu . Die nachfolgende Anleitung beschreibt, wie Sie eine einfache CODESYS -Applikation erstellen, die auf der CODESYS Control RTE laufen soll. " }, 
{ "title" : "CODESYS Control Win ", 
"url" : "_rtsl_start_runtime-1816376.html#UUID-065101d1-259a-9d21-37c7-74cc493827e0_section-idm43463171151726", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ Laufzeitsystem starten \/ CODESYS Control Win ", 
"snippet" : "Bei der CODESYS Control Win handelt es sich um eine Gerätelizenz. Sie aktivieren diese Lizenz über den Lizenzmanager. Für weitere Informationen siehe: Produkte lizenzieren Automatischer Start: Wenn CODESYS Control Win automatisch beim Systemstart starten soll, müssen Sie den Dienst folgendermaßen ko...", 
"body" : "Bei der CODESYS Control Win handelt es sich um eine Gerätelizenz. Sie aktivieren diese Lizenz über den Lizenzmanager. Für weitere Informationen siehe: Produkte lizenzieren Automatischer Start: Wenn CODESYS Control Win automatisch beim Systemstart starten soll, müssen Sie den Dienst folgendermaßen konfigurieren: Öffnen Sie über das Startmenü Ihres Computers den Windows System-Dialog Dienste . Selektieren Sie in der Liste den Dienst CODESYS Control Win V3 und öffnen Sie über das Kontextmenü den Dialog Eigenschaften . In der Registerkarte Allgemein setzen Sie den Starttyp auf Automatisch . Manueller Start: Klicken Sie mit der rechten Maustaste in der Systemleiste auf das Symbol beziehungsweise und wählen Sie aus dem Menü den Befehl Start PLC . Wenn das Symbol in der Systemleiste fehlt, stellen Sie sicher, dass korrekt installiert wurde und die Anzeige in der Systemleiste gestartet ist. Hinweis dazu: Mit Doppelklick auf die Datei CODESYSControlSysTray.exe im Installationsunterverzeichnis GatewayPLC können Sie die Anzeige der Benutzerschnittstelle in der Systemleiste händisch starten. Nach erfolgreichem Start verändert sich das CODESYS Control Win -Symbol in der Systemleiste zu beziehungsweise . " }, 
{ "title" : "CODESYS -Applikation auf die Steuerung laden und starten ", 
"url" : "_rtsl_load_and_start_application_win.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ CODESYS -Applikation auf die Steuerung laden und starten ", 
"snippet" : "Voraussetzung: Die Steuerung ist gestartet. Erstellen Sie in CODESYS ein Standardprojekt: Wählen Sie dazu den Befehl Datei → Neues Projekt . Wählen Sie im Dialog Neues Projekt die Vorlage Standardprojekt und geben Sie einen Namen und einen Ablageort ein. Wählen Sie dann im Dialog Standardprojekt die...", 
"body" : "Voraussetzung: Die Steuerung ist gestartet. Erstellen Sie in CODESYS ein Standardprojekt: Wählen Sie dazu den Befehl Datei → Neues Projekt . Wählen Sie im Dialog Neues Projekt die Vorlage Standardprojekt und geben Sie einen Namen und einen Ablageort ein. Wählen Sie dann im Dialog Standardprojekt die entsprechende Steuerung. Im Gerätebaum (Ansicht Geräte ) des neuen Projekts gibt es nun einen Eintrag für die Steuerung ( Device(...) ), darunter eine Applikation mit einem Programmbaustein ( PLC_PRG (PRG) und einer Task MainTask , die PLC_PRG aufruft). Programmieren Sie in PLC_PRG ein einfaches Programm, beispielsweise einen Zähler. PROGRAM PLC_PRG\nVAR\n iCount: INT;\nEND_VAR\n\niCount := iCount+1; Stellen Sie die Verbindung zur Steuerung her. Dazu verwenden Sie die Registerkarte Kommunikation des Geräteeditors. Sie können sie mit einem Doppelklick auf den Eintrag Device (...) im Gerätebaum öffnen. Das Gateway ist im Normalfall jetzt bereits aktiv. Wenn dies nicht der Fall ist, prüfen Sie den Status und starten das Gateway gegebenenfalls explizit. Wählen Sie dann in der Registerkarte Kommunikation den Befehl Netzwerk durchsuchen . Der Dialog Gerät auswählen erscheint mit den gefundenen Geräten. Falls Ihre Steuerung nicht gefunden wird, stellen Sie sicher, dass sie korrekt installiert und gestartet wurde. Selektieren Sie die gefundene Steuerung und bestätigen Sie mit OK . Wenn Ihre Steuerung nicht angezeigt wird, überprüfen Sie Folgendes: Deaktivieren Sie die Option Netzwerksuche nach Zielsystem-ID filtern im Menü Gerät → Optionen (Registerkarte Kommunikation ). Wenn Ihr Gerät nun angezeigt wird, haben Sie eine falsche TargetID . Möglicherweise wurde Ihre Komponente SysTargetOEM nicht korrekt geladen. Ist Ihr Gerät mit Ihrem Netzwerk verbunden? Standardmäßig wird mit Ihrem Gerät über UDP kommuniziert. Wenn Sie diese Kommunikationsmethode verwenden, muss sich Ihr Gerät im gleichen Sub-Netzwerk befinden wie Ihr Host. Beide Geräte benötigen die exakt gleich konfigurierte Netzwerkmaske. Sie können die Netzwerkeinstellungen bei den Meldungen des Laufzeitsystems beim Starten überprüfen. Sie sollten beispielsweise wie folgt lauten: 1287759127: Cmp=CmpBlkDrvUdp, Class=1, Error=0, Info=6, pszInfo=Network interface: <ipaddress>192.168.101.41<\/ipaddress> <subnetmask>255.255.252.0<\/subnetmask> CODESYS versucht sich auf diesem Zielsystem zu authentifizieren und einen Kommunikationskanal zu erhalten. Die Verbindung wird hergestellt. Wählen Sie den Befehl Online → Einloggen . Der Dialog zur Bestätigung des Downloads der Applikation öffnet sich. Führen Sie den Download durch und starten Sie die Applikation. Die Applikation wird auf Ihrem Gerät abgearbeitet. Überprüfen Sie im Programm PLC_PRG , ob der Zähler läuft. " }, 
{ "title" : "Steuerung lizenzieren ", 
"url" : "_rtsl_license_controller_win.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ Steuerung lizenzieren ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Lizenzen erwerben ", 
"url" : "_rtsl_license_controller_win.html#UUID-3805d9ea-0c7b-2463-7ef4-1d99d0c4e100_section-idm234389354567343", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ Steuerung lizenzieren \/ Lizenzen erwerben ", 
"snippet" : "Lizenzen für die CODESYS Control -Produkte können im CODESYS Store International oder im CODESYS Store North America erworben werden....", 
"body" : "Lizenzen für die CODESYS Control -Produkte können im CODESYS Store International oder im CODESYS Store North America erworben werden. " }, 
{ "title" : "Lokale Lizenzierung ", 
"url" : "_rtsl_license_controller_win.html#UUID-3805d9ea-0c7b-2463-7ef4-1d99d0c4e100_section-idm4588328499004833054120306755", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ Steuerung lizenzieren \/ Lokale Lizenzierung ", 
"snippet" : "Die Lizenz kann auf einen USB-Dongle oder Softcontainer installiert werden. Bei der Verwendung des Softcontainers wird die Lizenz bei der Aktivierung an das Gerät gebunden und kann nur auf diesem Gerät aktiviert oder wiederhergestellt werden. Voraussetzungen: Das Entwicklungssystem mit CODESYS Devel...", 
"body" : "Die Lizenz kann auf einen USB-Dongle oder Softcontainer installiert werden. Bei der Verwendung des Softcontainers wird die Lizenz bei der Aktivierung an das Gerät gebunden und kann nur auf diesem Gerät aktiviert oder wiederhergestellt werden. Voraussetzungen: Das Entwicklungssystem mit CODESYS Development System verfügt über einen Internetzugang und ist mit dem Gerät verbunden. Öffnen Sie CODESYS . Erstellen Sie ein Standardprojekt. Aktualisieren Sie das Gerät im Gerätebaum. Öffnen Sie mit dem Befehl Tools → Lizenz-Manager den CODESYS Lizenzmanager. Wählen Sie im Wizard zunächst Gerät , dann je nach Gerät Dongle oder Softcontainer . Der Dialog Gerät auswählen öffnet sich. Wählen Sie das entsprechende Gerät aus. Der Dialog Lizenz-Manager öffnet sich. Als Container wird der Name des Softcontainers oder Dongles auf dem Gerät angezeigt. Im Fenster Produkte ist noch kein Eintrag für das entsprechende Gerät. Wählen Sie unten links die Aktion Lizenzen installieren . Der Wizard Lizenzen auf <Zielgerät> <Container-Bezeichnung> installieren - Operation auswählen startet. Wählen Sie die Option Lizenz aktivieren . Geben Sie die Ticket-ID ein und bestätigen Sie mit Weiter . Die Lizenz wird aktiviert. " }, 
{ "title" : "Sichern und Wiederherstellen von CODESYS -Lizenzen ", 
"url" : "_rtsl_backup_restore_wibu_win.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ Sichern und Wiederherstellen von CODESYS -Lizenzen ", 
"snippet" : "Diese Anweisungen gelten nicht für Produkte der Produktfamilie CODESYS Virtual Control....", 
"body" : "Diese Anweisungen gelten nicht für Produkte der Produktfamilie CODESYS Virtual Control. " }, 
{ "title" : "Lizenzen für Codemeter Embedded ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4622936815712034049201310732", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ Sichern und Wiederherstellen von CODESYS -Lizenzen \/ Lizenzen für Codemeter Embedded ", 
"snippet" : "CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ Backup & Restore License...", 
"body" : "CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ Backup & Restore License " }, 
{ "title" : "Lizenz sichern ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4641146992569634049209836102", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ Sichern und Wiederherstellen von CODESYS -Lizenzen \/ Lizenzen für Codemeter Embedded \/ Lizenz sichern ", 
"snippet" : "Stellen Sie eine Verbindung von CODESYS zu Ihrer Steuerung her. Wählen Sie im Gerätebaum Ihre Steuerung aus und öffnen Sie die Registerkarte Dateien . Klicken Sie im rechten Fenster auf das Aktualisierungssymbol . Die auf Ihrer Steuerung vorhandenen Dateien werden angezeigt. Wählen Sie im linken Fen...", 
"body" : "Stellen Sie eine Verbindung von CODESYS zu Ihrer Steuerung her. Wählen Sie im Gerätebaum Ihre Steuerung aus und öffnen Sie die Registerkarte Dateien . Klicken Sie im rechten Fenster auf das Aktualisierungssymbol . Die auf Ihrer Steuerung vorhandenen Dateien werden angezeigt. Wählen Sie im linken Fenster das Verzeichnis aus, in dem Sie die Sicherung speichern wollen. Wählen Sie im rechten Fenster das Verzeichnis cmact_licenses aus und klicken Sie auf die Schaltfläche . Eine Sicherungskopie Ihres Lizenzierungsverzeichnisses wird auf Ihrem Computer erstellt. Überprüfen Sie, ob die Sicherungskopie erfolgreich erstellt wurde. " }, 
{ "title" : "Lizenz wiederherstellen ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm451020213344483404921010438", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ Sichern und Wiederherstellen von CODESYS -Lizenzen \/ Lizenzen für Codemeter Embedded \/ Lizenz wiederherstellen ", 
"snippet" : "Beachten Sie, dass bei der Ausführung der nachfolgenden Anweisungen im Schritt 6 ein Datenverlust möglich ist. Lesen Sie deshalb diese Anweisung genau durch. Stellen Sie eine Verbindung von CODESYS zu Ihrer Steuerung her. Wählen Sie im Gerätebaum Ihre Steuerung aus und öffnen Sie die Registerkarte D...", 
"body" : "Beachten Sie, dass bei der Ausführung der nachfolgenden Anweisungen im Schritt 6 ein Datenverlust möglich ist. Lesen Sie deshalb diese Anweisung genau durch. Stellen Sie eine Verbindung von CODESYS zu Ihrer Steuerung her. Wählen Sie im Gerätebaum Ihre Steuerung aus und öffnen Sie die Registerkarte Dateien . Klicken Sie im rechten Fenster auf das Aktualisierungssymbol . Die auf Ihrer Steuerung vorhandenen Dateien werden angezeigt. Wählen Sie im rechten Fenster das Zielverzeichnis aus. Dies muss das Verzeichnis auf oberster Ebene sein ( Speicherort : \/ ) Wählen Sie im linken Fenster die zuvor erstellte Sicherungskopie auf Ihrem Computer und klicken Sie auf die Schaltfläche . Die Sicherungskopie wird auf Ihre Steuerung kopiert. Wenn ein Verzeichnis mit demselben Namen existiert, werden Sie gefragt, ob Sie eventuell enthaltene Dateien überschreiben wollen. Achtung: Wenn Sie \"Ja\" wählen, werden alle Dateien mit dem selben Namen wie im Sicherungsverzeichnis aus dem vorhandenen Verzeichnis entfernt. Der gleiche Name bedeutet nicht unbedingt, dass der Inhalt identisch ist. Achten Sie also darauf, dass Sie nicht versehentlich Dateien überschreiben, die Sie benötigen. Starten Sie Ihre Steuerung neu, nachdem die Sicherungskopie erfolgreich übertragen wurde. " }, 
{ "title" : "Lizenzen für Codemeter Runtime ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4592433740225634049202010617", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ Sichern und Wiederherstellen von CODESYS -Lizenzen \/ Lizenzen für Codemeter Runtime ", 
"snippet" : "CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control Win SL CODESYS Control RTE SL...", 
"body" : "CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control Win SL CODESYS Control RTE SL " }, 
{ "title" : "Lizenz sichern ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4582704430054434049230836628", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ Sichern und Wiederherstellen von CODESYS -Lizenzen \/ Lizenzen für Codemeter Runtime \/ Lizenz sichern ", 
"snippet" : "Bei der Verwendung von CodeMeter Runtime ist es nicht notwendig, ein Backup zu erstellen....", 
"body" : "Bei der Verwendung von CodeMeter Runtime ist es nicht notwendig, ein Backup zu erstellen. " }, 
{ "title" : "Lizenz wiederherstellen ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4548752769854434049231197546", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ Sichern und Wiederherstellen von CODESYS -Lizenzen \/ Lizenzen für Codemeter Runtime \/ Lizenz wiederherstellen ", 
"snippet" : "Restore License Erzeugen einer License-Request-Datei Öffnen Sie in CODESYS den Lizenzmanager. Wählen Sie in den beiden folgenden Dialogen Gerät und Softcontainer aus. Stellen Sie eine Verbindung von CODESYS zu der Steuerung her, auf der Sie die Lizenz wiederherstellen wollen. Klicken Sie auf Lizenze...", 
"body" : " Restore License Erzeugen einer License-Request-Datei Öffnen Sie in CODESYS den Lizenzmanager. Wählen Sie in den beiden folgenden Dialogen Gerät und Softcontainer aus. Stellen Sie eine Verbindung von CODESYS zu der Steuerung her, auf der Sie die Lizenz wiederherstellen wollen. Klicken Sie auf Lizenzen installieren , wählen Sie Lizenz anfordern und klicken Sie auf Weiter . Wenn das Feld Softwareanbieter leer ist, können Sie den Firm-Code verwenden. Wie Sie den Firm-Code abrufen können, ist im Abschnitt \"Firmencode abrufen\" beschrieben. Wählen Sie den Container aus, in den die Lizenz installiert werden soll, und den Ort, an dem die Lizenzanforderungsdatei auf Ihrem Computer gespeichert werden soll. Klicken Sie auf Fertigstellen . Download der License-Update-Datei Öffnen Sie das License Central WebDepot und geben Sie dort die Ticket-ID ein, die Sie wiederherstellen möchten. Klicken Sie auf Next . Klicken Sie auf Restore Licenses . Klicken Sie unten rechts auf File-based license transfer (wenn auf der Seite Direct license transfer steht, sind Sie bereits auf der richtigen Seite) Laden Sie die zuvor erstellte Lizenzanforderungsdatei hoch und klicken Sie auf Upload request and continue now . Klicken Sie auf Download license update file now und speichern Sie die Datei auf Ihrem Computer. License-Update installieren Öffnen Sie in CODESYS den Lizenzmanager. Wählen Sie in den beiden folgenden Dialogen Gerät und Softcontainer aus. Stellen Sie eine Verbindung von CODESYS zu der Steuerung her, auf der Sie die Lizenz wiederherstellen wollen. Klicken Sie auf Lizenzen installieren , wählen Sie Lizenz installieren und klicken Sie auf Weiter . Wählen Sie den Container, in dem Sie die Lizenz installieren möchten, und wählen Sie die zuvor heruntergeladene Aktualisierungsdatei (Dateierweiterung .WibuCmRaU ). Klicken Sie auf Fertigstellen . Nach ein paar Sekunden erscheint die Lizenz in der Lizenzverwaltung. " }, 
{ "title" : "Firm-Code abrufen ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4641146913656034049243306333", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Erste Schritte \/ Sichern und Wiederherstellen von CODESYS -Lizenzen \/ Lizenzen für Codemeter Runtime \/ Firm-Code abrufen ", 
"snippet" : "Öffnen Sie das License Central WebDepot und geben Sie dort die Ticket-ID ein, die Sie wiederherstellen möchten. Klicken Sie auf Next . Klicken Sie auf Restore Licenses . Klicken Sie unten rechts auf File-based license transfer . Kopieren Sie den unter Punkt 1 angegebenen Firm-Code....", 
"body" : "Öffnen Sie das License Central WebDepot und geben Sie dort die Ticket-ID ein, die Sie wiederherstellen möchten. Klicken Sie auf Next . Klicken Sie auf Restore Licenses . Klicken Sie unten rechts auf File-based license transfer . Kopieren Sie den unter Punkt 1 angegebenen Firm-Code. " }, 
{ "title" : "Konfigurieren und Erweitern ", 
"url" : "_rtsl_configure_and_extend-1816377.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS Control Win V3 ", 
"url" : "_rtsl_windows_win_v3.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Win V3 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Dynamische Komponenten hinzufügen ", 
"url" : "_rtsl_windows_win_v3_dynamic_components.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Win V3 \/ Dynamische Komponenten hinzufügen ", 
"snippet" : "Die Konfiguration der CODESYS Control Win erfolgt mit Hilfe einer Konfigurationsdatei ( CODESYSControl.cfg ). Die cfg-Datei im Installationspfad enthält nur einen Verweis auf die eigentliche Konfigurationsdatei CODESYSControl.cfg im Arbeitsverzeichnis: [SysFile] Windows.WorkingDirectory=C:\\ProgramDa...", 
"body" : "Die Konfiguration der CODESYS Control Win erfolgt mit Hilfe einer Konfigurationsdatei ( CODESYSControl.cfg ). Die cfg-Datei im Installationspfad enthält nur einen Verweis auf die eigentliche Konfigurationsdatei CODESYSControl.cfg im Arbeitsverzeichnis: [SysFile]\nWindows.WorkingDirectory=C:\\ProgramData\\CODESYS\\CODESYSControlWinV3x64\\801BFF8C In die cfg-Datei im Arbeitsverzeichnis können Sie die gewünschten zusätzlichen Komponenten (Treiber) eintragen. Diese werden dann bei einem Neustart der CODESYS Control Win immer mit geladen. Sie tragen eine neue Komponente in der Sektion [ComponentManager] ein. Wichtig ist, dass eine lückenlose Nummerierung aller Komponenteneinträge entsteht: [ComponentManager]\n...\nComponent.6=SysCpuBreakpoints\nComponent.7=<Neue Komponente>\n... Sehen Sie im Folgenden, welche Komponenten Sie hinzufügen können. " }, 
{ "title" : "Unterstützung optionaler Feldbuskarten ", 
"url" : "_rtsl_windows_win_v3_dynamic_components.html#UUID-8ec48f4e-4fbf-ff18-64cb-d07a65c567cc_id_e00e47aa45e147ec0a8646334522c52-id-035992cdebec2318c0a8646340efc345", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Win V3 \/ Dynamische Komponenten hinzufügen \/ Unterstützung optionaler Feldbuskarten ", 
"snippet" : "Treiber CmpHilscherCIFX Diese Komponente unterstützt eine NetX PC-Karte der Fa. Hilscher. Dazu müssen Sie nur die Komponente „CmpHilscherCIFX“ in der Konfigurationsdatei der CODESYS Control Win wie folgt eintragen: [ComponentManager] Component.<n>=CmpHilscherCIFX Nach dem Einbau der Karte müssen Sie...", 
"body" : "Treiber CmpHilscherCIFX Diese Komponente unterstützt eine NetX PC-Karte der Fa. Hilscher. Dazu müssen Sie nur die Komponente „CmpHilscherCIFX“ in der Konfigurationsdatei der CODESYS Control Win wie folgt eintragen: [ComponentManager]\nComponent.<n>=CmpHilscherCIFX Nach dem Einbau der Karte müssen Sie beim Starten des Betriebssystems nur noch den Treiber SysDrv3S.sys installieren. Dieser liegt im CODESYS Installationsverzeichnis unter $\\GatewayPLC\\Driver für ein 32Bit Windows Betriebssystem, oder unter $\\GatewayPLC\\Driver\\x64 für ein 64bit Windows Betriebssystem. Hinweis: Der Hilscher Konfigurator SyCon bzw. SYCON.net und der Hilscher Treiber dürfen nicht parallel zu CODESYS betrieben werden! Treiber CmpSoftingProfibus Diese Komponente ist notwendig, wenn Sie eine PROFIBUS Master USB Schnittstellenkarte der Firma Softing Industrial Automation GmbH mit CODESYS in einer IEC-Applikation verwenden wollen. Sie stellt dabei die Schnittstelle zwischen dem Laufzeitsystem und dem proprietären Treiber von Softing dar, die von unserer Treiberbibliothek IoDrvSoftingPROFIusb verwendet wird. In CODESYS wird diese Bibliothek automatisch im Bibliotheksverwalter aufgenommen, wenn Sie ein Gerät PROFIusb im Gerätebaum einfügen. Dadurch können Sie das CODESYS -Laufzeitsystem auf einem Windows PC als PROFIBUS Master verwenden und entsprechend konfigurieren. Für weitere Informationen siehe: Hinzufügen eines USB-Interfaces für PROFIBUS Treiber CmpBACnet Die Komponente ist notwendig, wenn Sie die BACnet IP-Anbindung der CODESYS Control Win nutzen wollen. In der Konfigurationsdatei ist dazu nur folgender Eintrag nötig: [ComponentManager]\nComponent.<n>=CmpBACnet Treiber CmpPCANBasicDrv Diese Komponente implementiert die Anbindung von Peak CAN Hardware mittels PCAN Basic API. Installationsanleitung siehe Onlinehilfe. Keine Konfigurationsdateieinträge nötig. Treiber CmpCAACanL2 Diese Komponente bietet eine Hardware unabhängige Schnittstelle zum Senden und Empfangen von CAN-Nachrichten. Folgende Konfigurationsdateieinträge sind optional: [CmpCAACanL2]\n;If setting PersistentBaudrate is enabled (0: disabled; 1: enabled)\n;the baudrate will be stored into Net.X.DefaultBaudrate (where X equals NetId) when opening the driver.\nPersistentBaudrate=1\n;Default baudrate for CAN network 0. This baudrate will be used when the network is opened (e.g from CmpBlkDrvCan or CANopen) with the baudrate set to 0.\nNet.0.DefaultBaudrate=1000 In der Konfigurationsdatei kann per CAN-Netzwerk (=physikalischer CAN-Anschluss) eine Standard-Baudrate hinterlegt werden. Diese Standard-Baudrate wird immer dann verwendet, wenn die CL2-Funktion DriverOpenH mit Baudrate 0 aufgerufen wird und der Treiber bisher noch nicht offen ist. Wenn dieser Konfigurationsdatei-Eintrag fehlt, dann wird in dem genannten Fall ein Fehler gemeldet, da die Baudrate unbekannt ist. Wirklich sinnvoll ist der Eintrag erst im Zusammenhang mit der Funktionalität PersistenBaudrate , die standardmäßig abgeschaltet ist. Wenn PersistentBaudrate=1 , dann schreibt CODESYS bei jedem Aufruf von DriverOpenH mit einer konkreten Baudrate, diese Baudrate mittels der Funktion CmpSettings in die Konfigurationsdatei. Dies bewirkt beispielsweise, dass der Eintrag Net.0.DefaultBaudrate verändert wird. Das ist besonders nützlich, wenn eine Steuerung über den CAN-Blocktreiber kommuniziert. Wenn im CmpBlkDrvCanServer die Baudrate auf 0 steht ( 0.Baudrate = 0 ), dann kann der Anwender mittels Ändern der Baudrate im Projekt, Herunterladen der Applikation und Neustart der Steuerung die Baudrate der Blocktreiber-Kommunikation ändern. Treiber CmpCAASdoClient Diese Komponente implementiert das CANopen SDO Client Protokoll. Optionale Konfigurationseinträge: [CmpCAASdoClient]\nMaxSegmentsPerCycle=0 ; for block download: maximum of sent segments per cycle; 0 means infinity Hiermit können Sie die Anzahl der CAN-Nachrichten reduzieren, die bei einem Blocktransfer pro Zyklus verschickt werden. Dies ist nötig, wenn eine Steuerung Probleme mit einer Folge von vielen CAN-Frames auf derselben ID hat. Allerdings schränkt dies auch die Performance ein, weshalb ein Blocktransfer länger dauert. Treiber CmpCAASDOServer Diese Komponente implementiert das CANopen SDO Server Protokoll. Optionale Konfigurationsdateieinträge: [CmpCAASdoClient]\nMaxSegmentsPerCycle=0 ; for block download: maximum of sent segments per cycle; 0 means infinity Hier kann die Anzahl der CAN-Nachrichten reduziert werden, die bei einem Blocktransfer pro Zyklus verschickt werden. Treiber CmpEL6751CanDrv Diese Komponente implementiert die Anbindung der Beckhoff EL6751 CAN\/EtherCAT Gateway-Klemme. Da die Komponente einen CAN-Minitreiber implementiert, können Sie die CANL2 -Komponente und alle CODESYS CAN-basierten Stacks verwenden. Keine Konfigurationsdatei-Einträge nötig. Treiber CmpNetXCanDlDrv Diese Komponente ist ein CAN-Mini-Treiber für eine NetX-CAN-Karte. Mit diesem Treiber kann CODESYS Control Win über eine NetX-Karte die CAN-Bibliotheken von CODESYS GmbH benutzen. Die Konfiguration der Komponente in der Konfigurationsdatei der CODESYS Control Win : [CmpNetXCanDlDrv]\nMaxNumberOfCanNetworks=0..n -> number of the CAN networks (number of the NetIds)\nNetId.0.Channel=0 -> mapping of the NetId onboard nad NetX channels (see CmpHilscherCIFX)\nNetId.0.Board=0\n\n[ComponentManager]\n...\nComponent.6=CmpHilscherCIFX\nComponent.7=CmpNetXCanDlDrv\n... " }, 
{ "title" : "Optionale Kommunikationskanäle ", 
"url" : "_rtsl_windows_win_v3_dynamic_components.html#UUID-8ec48f4e-4fbf-ff18-64cb-d07a65c567cc_id_e00e47aa45e147ec0a8646334522c52-id-8aa5b4ef9fc59bd9c0a8646351124931", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control Win V3 \/ Dynamische Komponenten hinzufügen \/ Optionale Kommunikationskanäle ", 
"snippet" : "Treiber CmpBlkDrvCanClient Diese Komponente implementiert einen CODESYS -Blocktreiber zur Kommunikation eines CODESYS Gateways mit einer CODESYS -Steuerung via CAN (Service-Kommunikation). Die Kommunikation wird mittels des CANopen SDO-Protokolls („Segmented“ oder „Block Transfer“) realisiert. Die K...", 
"body" : "Treiber CmpBlkDrvCanClient Diese Komponente implementiert einen CODESYS -Blocktreiber zur Kommunikation eines CODESYS Gateways mit einer CODESYS -Steuerung via CAN (Service-Kommunikation). Die Kommunikation wird mittels des CANopen SDO-Protokolls („Segmented“ oder „Block Transfer“) realisiert. Die Komponente CmpBlkDrvCanClient wird auf Gatewayseite benötigt, sowie CAN-Hardware von der Firma Peak (besipielsweise ein PCAN USB Dongle). Eine typische Konfiguration in der Gateway-Konfigurationsdatei sieht wie folgt aus: [ComponentManager]\nComponent.1=CmpBlkDrvCANClient\nComponent.2=CmpCAASdoClient\nComponent.3=CmpCAACanL2\nComponent.4=CmpPCANBasicDrv\n\n[CmpBlkDrvCanClient]\nCycleTimeMs=1\nNumChannels=1 ; Number of block driver instances\n0.Name=BlkDrvCanClient\n0.NetId=0 ; CANbus Network Id (0..n)\n0.Baudrate=1000 ; CANbus Baudrate in kbit\/s\n0.NodeId=1 ; unique NodeId of Gateway\n0.BlockTransfer=1 ; Use block transfer for more performance\n\n[CmpCAASdoClient]\nMaxSegmentsPerCycle=0 ; for block download: maximum of sent segments per cycle; 0 means infinity\n[CmpBlkDrvCanClient]\nCycleTimeMs=1\nNumChannels=1 ; Number of block driver instances\n0.Name=BlkDrvCanClient\n0.NetId=0 ; CANbus Network Id (0..n)\n0.Baudrate=1000 ; CANbus Baudrate in kbit\/s\n0.NodeId=1 ; unique NodeId of Gateway\n0.BlockTransfer=1 ; Use block transfer for more performance\n\n[CmpCAASdoClient]\nMaxSegmentsPerCycle=0 ; for block download: maximum of sent segments per cycle; 0 means infinity Treiber CmpBlkDrvCanServer Diese Komponente implementiert einen CODESYS -Blocktreiber zur Kommunikation eines CODESYS -Gateways mit einer CODESYS -Steuerung via CAN (Service-Kommunikation). Die Kommunikation wird mittels des CANopen SDO-Protokolls („Segmented“ oder „Block Transfer“) realisiert. Die Komponente CmpBlkDrvCanServer wird auf Steuerungsseite benötigt, sowie ein entsprechender CAN-Minitreiber. Eine typische Konfiguration in der Steuerungskonfigurationsdatei sieht wie folgt aus: [Components]\nComponent.1=CmpAnyCANMiniDriverComponent ; TODO: Replace component name by your CAN Mini driver component\nComponent.2=CmpBlkDrvCanServer\n[Components]\nComponent.1=CmpAnyCANMiniDriverComponent ; TODO: Replace component name by your CAN Mini driver component\nComponent.2=CmpBlkDrvCanServer\n\n[CmpCAACanL2]\n;If setting PersistentBaudrate is enabled (0: disabled; 1: enabled)\n;the baudrate will be stored into Net.X.DefaultBaudrate (where X equals NetId)\n;when opening the driver.\nPersistentBaudrate=1\n;Default baudrate for CAN network 0. This baudrate will be used when the network \n;is opened (e.g from CmpBlkDrvCan or CANopen) with the baudrate set to 0.\nNet.0.DefaultBaudrate=1000\n\n[CmpBlkDrvCanServer]\nCycleTimeMs=1\n0.NetId=0\n0.Baudrate=0 ; 0 means: use setting from CmpCAACanL2 section\n0.NodeId=10\n\n[CmpCAASdoServer]\nMaxSegmentsPerCycle=0 ;for block upload: maximum of sent segments per cycle\n;0 means infinity " }, 
{ "title" : "CODESYS Control RTE V3 ", 
"url" : "_rtsl_windows_rts_v3.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "TCP\/UDP Protokollhandler (SysSocketLwIP) ", 
"url" : "_rtsl_windows_rte_v3_tcp_udp-protocol_handler.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ TCP\/UDP Protokollhandler (SysSocketLwIP) ", 
"snippet" : "Seit der Version 3.5.16.0 ist in der CODESYS Control RTE ein TCP\/UDP-Stack integriert. In der Vergangenheit gab es immer wieder Probleme auf Ethernet-basierten Feldbussen, die auf Protokollstacks (= Protokollhandler) von Windows basieren (beispielsweise EtherNet\/IP, ModbusTCP). Diese Feldbusse konnt...", 
"body" : "Seit der Version 3.5.16.0 ist in der CODESYS Control RTE ein TCP\/UDP-Stack integriert. In der Vergangenheit gab es immer wieder Probleme auf Ethernet-basierten Feldbussen, die auf Protokollstacks (= Protokollhandler) von Windows basieren (beispielsweise EtherNet\/IP, ModbusTCP). Diese Feldbusse konnten die Erwartungen an ein Echtzeitsystem nicht zuverlässig erfüllen. Mit der Einführung des internen Protokollstacks werden die SysEthernet-Netzwerkkartentreiber ( CmpEt100Drv , CmpEt1000Drv , CmpRTL813xMpd , CmpRTL8169Mpd , CmpCX5000Mpd ) nicht mehr ausschließlich von SysEthernet (bzw. von IoDrvEtherCAT und IoDrvProfinet ) angesprochen. Sie werden nun auch vom TCP\/UDP-Protokollstack zur direkten IP-Kommunikation angesprochen. " }, 
{ "title" : "Konfiguration ", 
"url" : "_rtsl_windows_rte_v3_tcp_udp_configuration.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ TCP\/UDP Protokollhandler (SysSocketLwIP) \/ Konfiguration ", 
"snippet" : "Damit der integrierte TCP\/UDP-Protokollstack vom Laufzeitsystem benutzt werden kann, muss der entsprechende Netzwerkkartentreiber in der Komponentenliste der RTE konfiguriert sein. Es muss der Treiber in der Konfigurationsdatei der RTE CODESYSControl_User.cfg im Abschnitt [ComponentManager] eingetra...", 
"body" : "Damit der integrierte TCP\/UDP-Protokollstack vom Laufzeitsystem benutzt werden kann, muss der entsprechende Netzwerkkartentreiber in der Komponentenliste der RTE konfiguriert sein. Es muss der Treiber in der Konfigurationsdatei der RTE CODESYSControl_User.cfg im Abschnitt [ComponentManager] eingetragen werden. Alle möglichen Einträge hier sind vom Setup der RTE bereits vorkonfiguriert und können im Menü PLC Configuration → Component Manager oder durch Löschen des „;“ am Zeilenanfang aktiviert werden. (Beispiel für alle 10\/100\/1000MBit-Netzwerkadapter von Intel: Component.xy=CmpEt1000Drv ) Zusätzliche Einstellungen sind nicht erforderlich. Die Netzwerkadapter-Konfiguration wird von Windows übernommen. Für die betreffenden Adapter muss einer der SysEthernet-Netzwerkkartentreiber auch im Gerätemanager von Windows installiert sein, siehe Verfügbare dynamische Komponenten. Die Treiber der Netzwerkadapter melden sich beim internen Protokollstack an und entscheiden zur Laufzeit, ob für das benutzte Protokoll der interne Protokollstack oder Windows benutzt werden muss. " }, 
{ "title" : "Log-Ausgaben des Protokollstacks ", 
"url" : "_rtsl_windows_rte_v3_tcp_udp_log.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ TCP\/UDP Protokollhandler (SysSocketLwIP) \/ Log-Ausgaben des Protokollstacks ", 
"snippet" : "Die einzige Möglichkeit des Anwenders, das Verhalten des integrierten Protokollstacks zu beobachten, sind Log-Ausgaben. Durch Setzen des Log-Filters werden mehr Ausgaben in den Logger geschrieben, als es die Standardeinstellung vorsieht. Dazu wird in der Konfigurationsdatei der RTE CODESYSControl_Us...", 
"body" : "Die einzige Möglichkeit des Anwenders, das Verhalten des integrierten Protokollstacks zu beobachten, sind Log-Ausgaben. Durch Setzen des Log-Filters werden mehr Ausgaben in den Logger geschrieben, als es die Standardeinstellung vorsieht. Dazu wird in der Konfigurationsdatei der RTE CODESYSControl_User.cfg , im Abschnitt [CmpLog] , der Wert Logger.0.Filter auf 0xFFFFFFFF gesetzt. Folgende Log-Ausgaben und deren Ursache können dem integrierten TCP\/UDP-Protokollstack zugeordnet werden: *** SysSocketlwIP -> No network-adapter for LwIP available! Keiner der Netzwerktreiber wurde geladen, weil sie entweder in der Konfiguration (Komponentenliste) nicht vorhanden sind, oder nicht über den Windows-Gerätemanager für mindestens eine Netzwerkkarte installiert wurden. *** SysSocketlwIP -> x network-adapters for LwIP available. Mindestens ein Netzwerkadapter steht für die Benutzung durch den integrierten Protokollstack zur Verfügung *** SysSocketlwIP -> Switched to Winsock, use of unknown adapter! Winsock: 0xxxxxxxx . Ein Socket mit der Handle-Adresse nach dem Doppelpunkt wurde zur weiteren Benutzung an den IP-Stack von Windows übergeben. Die Ursache ist meist ein Aufruf von SysSockBind oder SysSockSendTo an eine dem internen Protokollstack unbekannte Adapteradresse, wie z.B. 127.0.0.1 (localhost) oder 0.0.0.0 (ANY_ADDR). Die Ausgabe solcher Logs ist beim Start des Laufzeitsystems normal, da interne Komponenten wie der OPC UA Server, der Webserver, oder der CmpBlkDrvTcp an localhost\/ANY_ADDR binden. *** Error: SysSocketlwIP driver -> local receive buffer overrun. Wenn das Laufzeitsystem stark ausgelastet ist,beispielsweise durch IEC-Tasks, die über 80 oder 90 Prozent der insgesamt zur Verfügung stehenden Rechenleistung verbrauchen, kann es vorkommen, dass empfangene Ethernet-Frames nicht rechtzeitig vom Protokollstack ausgewertet werden können, bevor der Empfangspuffer voll ist. Im Falle von UDP sind diese Daten verloren und eine Wiederholung hängt vom darüber liegenden Protokoll ab. Bei TCP-Verbindungen ist eine Blockwiederholung vorgesehen. Andere *** Error… Log-Ausgaben sollten nicht vorkommen und sind bei Bedarf über den Support zu melden. " }, 
{ "title" : "Kommunikationstask des Protokollstacks ", 
"url" : "_rtsl_windows_rte_v3_tcp_udp_communication_task.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ TCP\/UDP Protokollhandler (SysSocketLwIP) \/ Kommunikationstask des Protokollstacks ", 
"snippet" : "Der interne Protokollstack braucht für die Bearbeitung von vielen UDP\/TCP-IP-Aufgaben eine eigene Task. Diese wird unmittelbar beim Initialisieren des Laufzeitsystems angelegt und besitzt die Priorität 55, was einer IEC-Task-Priorität von 23 entspricht. IEC-Tasks mit höherer Priorität werden von der...", 
"body" : "Der interne Protokollstack braucht für die Bearbeitung von vielen UDP\/TCP-IP-Aufgaben eine eigene Task. Diese wird unmittelbar beim Initialisieren des Laufzeitsystems angelegt und besitzt die Priorität 55, was einer IEC-Task-Priorität von 23 entspricht. IEC-Tasks mit höherer Priorität werden von der UDP\/TCP-Kommunikation nicht beeinflusst, IEC-Tasks mit einer niedrigeren Priorität werden unter Umständen von der UDP\/TCP-Kommunikation beeinflusst. Die Priorität wurde absichtlich so gelegt, um dem Anwendungsentwickler die Möglichkeit zu lassen, die (Feldbus-)Kommunikation nicht durch niederpriore, zeitintensive Aufgaben zu stören. Oder um Aufgaben zu definieren, die wichtiger als eine zeitgenaue Kommunikation sind. " }, 
{ "title" : "Zeitverhalten überprüfen ", 
"url" : "_rtsl_windows_rte_v3_check_timing_rte.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Zeitverhalten überprüfen ", 
"snippet" : "Erzeugen Sie ein einfaches Standardprojekt mit CODESYS . Konfigurieren Sie die einzige Task auf 1ms Zykluszeit. Programmieren Sie eine Zählervariable vom Typ DWORD , die die Zyklen zählt. Sie erkennen damit sofort, ob die 1000er-Stelle wirklich, wie in diesem Fall gewünscht, um ca. 1 pro Sekunde ink...", 
"body" : "Erzeugen Sie ein einfaches Standardprojekt mit CODESYS . Konfigurieren Sie die einzige Task auf 1ms Zykluszeit. Programmieren Sie eine Zählervariable vom Typ DWORD , die die Zyklen zählt. Sie erkennen damit sofort, ob die 1000er-Stelle wirklich, wie in diesem Fall gewünscht, um ca. 1 pro Sekunde inkrementiert wird. Öffnen Sie im Onlinebetrieb die Taskkonfiguration , Registerkarte Überwachung . Sie sehen die Jitter-Zeiten, die von der RTE berechnet werden. Auf einem normalen System bewegen sich diese zwischen +-100 μs. Wenn die Hardware über eine serielle oder parallele Schnittstelle verfügt, können Sie in dem oben beschriebenen Projekt mit der Bibliothek SysPort.library Ausgaben auf einzelne Pins dieser Schnittstellen programmieren. Dann können Sie mit Hilfe eines Oszilloskops das Zeitverhalten der CODESYS Control RTE sehr genau untersuchen. Wenn Sie über einen EtherCAT-Slave mit digitalen E\/As verfügen, können Sie mit Hilfe dieser E\/As sehr gut Messungen, ebenfalls mit einem Oszilloskop, durchführen. Für weitere Informationen siehe: Echtzeitverhalten auf speziellen Plattformen konfigurieren und Registerkarte: Überwachung " }, 
{ "title" : "Echtzeitverhalten auf speziellen Plattformen konfigurieren ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Echtzeitverhalten auf speziellen Plattformen konfigurieren ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Echtzeitverhalten von CODESYS Control RTE auf speziellen Plattformen ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html#UUID-0de36483-e275-5115-ca6b-72e31d34cfa5_id_d0c967c50de44a45c0a864631c66299f-id-904131440f59a05ac0a864633beb1ad4", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Echtzeitverhalten auf speziellen Plattformen konfigurieren \/ Echtzeitverhalten von CODESYS Control RTE auf speziellen Plattformen ", 
"snippet" : "Das Zeitverhalten von CODESYS Control RTE hängt von der Konstanz des CPU-Taktes und vom Takt des sogenannten Front-Side-Bus ab. Mit bestimmten Einstellungen im BIOS und in Windows können Sie das Zeitverhalten an die Gegebenheiten verschiedener Plattformen anpassen....", 
"body" : "Das Zeitverhalten von CODESYS Control RTE hängt von der Konstanz des CPU-Taktes und vom Takt des sogenannten Front-Side-Bus ab. Mit bestimmten Einstellungen im BIOS und in Windows können Sie das Zeitverhalten an die Gegebenheiten verschiedener Plattformen anpassen. " }, 
{ "title" : "Einstellungen im BIOS ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html#UUID-0de36483-e275-5115-ca6b-72e31d34cfa5_id_d0c967c50de44a45c0a864631c66299f-id-24bd95e00f59a05ac0a8646332b0218d", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Echtzeitverhalten auf speziellen Plattformen konfigurieren \/ Einstellungen im BIOS ", 
"snippet" : "Da die meisten Plattformen über ein unterschiedliches BIOS verfügen, können nur grobe Empfehlungen zur Optimierung des Zeitverhaltens der CODESYS Control RTE gegeben werden....", 
"body" : "Da die meisten Plattformen über ein unterschiedliches BIOS verfügen, können nur grobe Empfehlungen zur Optimierung des Zeitverhaltens der CODESYS Control RTE gegeben werden. " }, 
{ "title" : "Einstellungen in Windows ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html#UUID-0de36483-e275-5115-ca6b-72e31d34cfa5_id_d0c967c50de44a45c0a864631c66299f-id-6c4e42d628502216c0a864630d4e6b2f", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Echtzeitverhalten auf speziellen Plattformen konfigurieren \/ Einstellungen in Windows ", 
"snippet" : "Empfehlung: Das Energieschema sollte immer „Dauerbetrieb“ ( Always on ) heißen. Automatische Updates : Updates sollten für eine Industriesteuerung immer nur manuell erfolgen, da der PC unter Umständen vom automatischen Mechanismus ohne weitere Rückfrage neu gebootet wird....", 
"body" : "Empfehlung: Das Energieschema sollte immer „Dauerbetrieb“ ( Always on ) heißen. Automatische Updates : Updates sollten für eine Industriesteuerung immer nur manuell erfolgen, da der PC unter Umständen vom automatischen Mechanismus ohne weitere Rückfrage neu gebootet wird. " }, 
{ "title" : "Anpassungen an die Hardware-Plattformen \"APIC\" (Single- und Multiprozessor) und \"AMP\" (Betrieb der RTE auf eigenem CPU-Kern) ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html#UUID-0de36483-e275-5115-ca6b-72e31d34cfa5_id_d0c967c50de44a45c0a864631c66299f-id-3cbaa0b1908b4745c0a86463315e2cd5", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Echtzeitverhalten auf speziellen Plattformen konfigurieren \/ Anpassungen an die Hardware-Plattformen \"APIC\" (Single- und Multiprozessor) und \"AMP\" (Betrieb der RTE auf eigenem CPU-Kern) ", 
"snippet" : "Die generelle Anpassung an die Besonderheiten der Plattformen erfolgt durch die Komponenten CmpDrvSchedulerAMP und  CmpDrvSchedulerAPIC (seit der Abkündigung von Windows 7 nicht mehr relevant). Vom Setup der CODESYS Control RTE wird standardmäßig der CmpDrvSchedulerAMP installiert. CmpDrvSchedulerAP...", 
"body" : "Die generelle Anpassung an die Besonderheiten der Plattformen erfolgt durch die Komponenten CmpDrvSchedulerAMP und  CmpDrvSchedulerAPIC (seit der Abkündigung von Windows 7 nicht mehr relevant). Vom Setup der CODESYS Control RTE wird standardmäßig der CmpDrvSchedulerAMP installiert. CmpDrvSchedulerAPIC wird nur aus Kompatibilitätsgründen noch mitgeliefert und ist nur noch manuell auf alten Windows 7-PCs installierbar. Generell gilt, dass die CODESYS Control RTE nur auf PCs mit mehr als einem Prozessorkern ausgeführt werden kann ( CmpDrvSchedulerAMP ). Einzige Ausnahme ist die Windows-Plattform \"Windows 7 \/ 32 Bit\". Nur auf dieser Plattform kann noch der CmpDrvSchedulerAPIC verwendet werden, mit dem sich die CODESYS Control RTE per Zeitscheibenverfahren mit Windows den CPU-Core 0 teilen kann. Beim ersten Start der CODESYS Control RTE werden aufwendige Messungen durchgeführt, um die Taktfrequenzen auf Mikrosekunden zu skalieren. Die Ergebnisse dieser Messung werden in der Windows-Registry gespeichert: HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\CmpDrvSchedulerAMP\\Params oder HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\CmpDrvSchedulerAPIC\\Params , Werte SetClocksPerUS und SetCountsPerMS . Bei jedem weiteren Start der CODESYS Control RTE werden die Messungen nicht erneut durchgeführt, wenn die aus der Messung beim ersten Start erhaltenen Werte aus der Registry gelesen werden können. Wenn eine im System vorgenommene Anpassung (beispielsweise der Energiespareinstellung im BIOS) dazu geführt hat, dass sich der CPU-Takt gegenüber der Messung verändert hat, müssen diese Werte in der Windows-Registry gelöscht werden. Nur dann werden beim nächsten Start der CODESYS Control RTE die Taktfrequenzen neu skaliert. Für weitere Informationen siehe: Hardwarekonfiguration - Empfehlungen" }, 
{ "title" : "Hilscher CIFX-Karte in Betrieb nehmen ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Hilscher CIFX-Karte in Betrieb nehmen ", 
"snippet" : "Im Folgenden sind die Schritte zur Installation einer Hilscher CIFX-Netzwerk-Karte mit CODESYS Control RTE beschrieben. Das Vorgehen ist unabhängig vom verwendeten Feldbussystem. Folgende Feldbusse mit CIFX werden unterstützt: PROFINET Controller und PROFINET -Device PROFIBUS Master und PROFIBUS Con...", 
"body" : "Im Folgenden sind die Schritte zur Installation einer Hilscher CIFX-Netzwerk-Karte mit CODESYS Control RTE beschrieben. Das Vorgehen ist unabhängig vom verwendeten Feldbussystem. Folgende Feldbusse mit CIFX werden unterstützt: PROFINET Controller und PROFINET -Device PROFIBUS Master und PROFIBUS Controller netX-CAN EtherNet\/IP Scanner " }, 
{ "title" : "Windows-Treiber installieren ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-3b8953bc0e40fc79c0a8646325dd6b8e", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Hilscher CIFX-Karte in Betrieb nehmen \/ Windows-Treiber installieren ", 
"snippet" : "Wenn Sie die Hilscher-Karte mit dem Laufzeitsystem CODESYS Control RTE betreiben, dürfen Sie nicht den mitgelieferten Hilscher-Treiber der Netzwerkkarte verwenden. Wenn Sie eine CODESYS Control RTE mit NetX verwenden, müssen Sie den mit dem RTE-Installationspaket gelieferten SysDrv3s.sys (Unterverze...", 
"body" : "Wenn Sie die Hilscher-Karte mit dem Laufzeitsystem CODESYS Control RTE betreiben, dürfen Sie nicht den mitgelieferten Hilscher-Treiber der Netzwerkkarte verwenden. Wenn Sie eine CODESYS Control RTE mit NetX verwenden, müssen Sie den mit dem RTE-Installationspaket gelieferten SysDrv3s.sys (Unterverzeichnis SysDrv3S ) installieren. " }, 
{ "title" : "NetX-Firmware und NetX-Bootloader ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-82e7a36597005e19c0a864632973a990", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Hilscher CIFX-Karte in Betrieb nehmen \/ NetX-Firmware und NetX-Bootloader ", 
"snippet" : "NetX Firmware und NetX Bootloader werden zusammen mit dem Installationspaket ausgeliefert und befinden sich nach der Installation in Unterordner HilscherCIFX\\Firmware ....", 
"body" : "NetX Firmware und NetX Bootloader werden zusammen mit dem Installationspaket ausgeliefert und befinden sich nach der Installation in Unterordner HilscherCIFX\\Firmware . " }, 
{ "title" : "Komponente hinzufügen ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-6d2a7e991eb48aa8c0a86463368630e2", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Hilscher CIFX-Karte in Betrieb nehmen \/ Komponente hinzufügen ", 
"snippet" : "Wählen Sie im CODESYS Control RTE -Menü den Befehl PLC Configuration . Wechseln Sie im Dialog zur Registerkarte Component Manager . Fügen Sie die optionale Komponente CmpHilscherCIFX hinzu und bestätigen Sie mit OK ....", 
"body" : "Wählen Sie im CODESYS Control RTE -Menü den Befehl PLC Configuration . Wechseln Sie im Dialog zur Registerkarte Component Manager . Fügen Sie die optionale Komponente CmpHilscherCIFX hinzu und bestätigen Sie mit OK . " }, 
{ "title" : "RTE mit „CODESYSControl.cfg“ konfigurieren ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-a4398f680e40fc88c0a864635dd4fc93", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Hilscher CIFX-Karte in Betrieb nehmen \/ RTE mit „CODESYSControl.cfg“ konfigurieren ", 
"snippet" : "Die Konfigurationsdatei CODESYSControl.cfg befindet sich im Installationsverzeichnis. Fügen Sie die Komponente CmpHilscherCifX hinzu: [ComponentManager] ...Component.x=CmpHilscherCIFX ... Aktivieren Sie im Abschnitt CmpHilscherCIFX die entsprechenden Zeilen, je nach Anzahl der CIFX-Karten(entfernen ...", 
"body" : "Die Konfigurationsdatei CODESYSControl.cfg befindet sich im Installationsverzeichnis. Fügen Sie die Komponente CmpHilscherCifX hinzu: [ComponentManager]\n...Component.x=CmpHilscherCIFX\n... Aktivieren Sie im Abschnitt CmpHilscherCIFX die entsprechenden Zeilen, je nach Anzahl der CIFX-Karten(entfernen von „;“ am Zeilenanfang. ...\n[CmpHilscherCIFX]\n;TraceLevel=0xFFFFFFFF\nDevice.0.BootloaderFilePath=... (see image)\nDevice.0.Channel.0.FirmwareFile=...\n\n TraceLevel : Um zusätzliche Debug-Ausgaben im CODESYS-Logger zu aktivieren BootloaderFilePath : Dateipfad und Dateinamen des NetX-Bootloaders für jeden NetX-Controller. Ein relativer Pfad startet im Installationsverzeichnis, ein absoluter Pfad kann ebenfalls verwendet werden. Wenn Sie mehr als einen NetX-Controller verwenden, dann müssen Sie mehr als einen Dateipfad angegeben. ...\nDevice.0.BootloaderFilePath=NXCIF50-RTE.bin\nDevice.1.BootloaderFilePath=NXCIF50-RTE.bin\n... Device.X.Channel.X.FirmwareFile : Dateipfad und Dateinamen der NetX-Firmware für jede Karte und jeden Kanal. Ein relativer Pfad startet im Installationsverzeichnis, ein absoluter Pfad kann ebenfalls verwendet werden. Meistens wird nur „Channel 0“ verwendet. Wenn Sie mehr als einen NetX-Chip verwenden, dann müssen Sie mehr als einen Dateipfad spezifizieren. ...\nDevice.0.Channel.0.FirmwareFile=cifxdpm.nxf\nDevice.1.Channel.0.FirmwareFile=cifxdpm.nxf\n... Ergebnis: " }, 
{ "title" : "Laufzeitsystem starten ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-b219f19c0e40fc88c0a864630469e13f", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Hilscher CIFX-Karte in Betrieb nehmen \/ Laufzeitsystem starten ", 
"snippet" : "Starten Sie das Laufzeitsystem mit dem Befehl n Start PLC im SysTray-Menü der CODESYS Control RTE Sobald das Laufzeitsystem läuft, erscheinen Einträge im Laufzeitsystem-Logger für CmpHilscherCIFX . Sie sehen die Einträge im Dialog Log des Geräteeditors in CODESYS , sowie in der Datei LogPLCxx.csv im...", 
"body" : "Starten Sie das Laufzeitsystem mit dem Befehl n Start PLC im SysTray-Menü der CODESYS Control RTE Sobald das Laufzeitsystem läuft, erscheinen Einträge im Laufzeitsystem-Logger für CmpHilscherCIFX . Sie sehen die Einträge im Dialog Log des Geräteeditors in CODESYS , sowie in der Datei LogPLCxx.csv im CODESYS Control RTE -Verzeichnis. Prüfen Sie Folgendes: Die Komponente CmpHilscherCIFX muss geladen worden sein. Die Toolkit-Version der CmpHilscherCIFX -Komponente muss angezeigt werden. Die Firmware wird geladen. Der Logger informiert über den Namen und die Version der Firmware. Wenn Sie TraceLevel auf 0xFFFFFFFF setzen, dann werden von CmpHilscherCIFX Informationen für jeden konfigurierten NetX-Kanal ausgegeben. Für weitere Informationen siehe: Registerkarte: Log " }, 
{ "title" : "CODESYS -Projekt mit E\/A-Konfiguration anlegen ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-1f474e4c0e40fc88c0a8646300249b0e", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Hilscher CIFX-Karte in Betrieb nehmen \/ CODESYS -Projekt mit E\/A-Konfiguration anlegen ", 
"snippet" : "Sie können nun können ein einfaches CODESYS -Projekt mit laufendem Feldbus erzeugen. Legen Sie in CODESYS ein neues Standardprojekt an. Wählen Sie beim Anlegen das Gerät CODESYS Control RTE . Fügen Sie im Gerätebaum einen Feldbus-Master CIFX-PB ein. Öffnen Sie den Konfigurationsdialog für den Feldbu...", 
"body" : "Sie können nun können ein einfaches CODESYS -Projekt mit laufendem Feldbus erzeugen. Legen Sie in CODESYS ein neues Standardprojekt an. Wählen Sie beim Anlegen das Gerät CODESYS Control RTE . Fügen Sie im Gerätebaum einen Feldbus-Master CIFX-PB ein. Öffnen Sie den Konfigurationsdialog für den Feldbus-Master durch Doppelklick auf den Eintrag im Gerätebaum. Wechseln Sie zur Registerkarte NetX Konfiguration . Setzen Sie die Werte von Slot und NetX Com Channel so, dass sie identisch mit den Gerätenummern in der Konfigurationsdatei CODESYSControl.cfg sind. Vergleichen sie die Werte mit den Loggereinträgen des Laufzeitsystems. Übersetzen Sie die Applikation. Laden Sie die Applikation auf die Steuerung und starten Sie sie. Jeder Knoten des Gerätebaums muss jetzt grün markiert sein. " }, 
{ "title" : "FAQ ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-d19e04ada023b398c0a8646370386558", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Hilscher CIFX-Karte in Betrieb nehmen \/ FAQ ", 
"snippet" : "Der Feldbus-Master wird im Gerätebaum nicht grün. Wie kann ich das Problem finden? Öffnen Sie den Konfigurationseditor der SPS (in diesem Editor sind auch die Kommunikationseinstellungen zu finden), wechseln Sie zur Registerkarte Log und klicken Sie auf die grünen Pfeile. CODESYS lädt nun alle Logge...", 
"body" : "Der Feldbus-Master wird im Gerätebaum nicht grün. Wie kann ich das Problem finden? Öffnen Sie den Konfigurationseditor der SPS (in diesem Editor sind auch die Kommunikationseinstellungen zu finden), wechseln Sie zur Registerkarte Log und klicken Sie auf die grünen Pfeile. CODESYS lädt nun alle Logger-Einträge von der SPS hoch und zeigt sie an. Nun können Sie Fehler und Exceptions suchen. Es gibt nicht aufgelöste Referenzen. Wenn in der Applikation nicht aufgelöste Referenzen vorliegen, dann wird die Laufzeitsystemkomponente nicht geladen oder eine falsche Version wird geladen. Bitte kontrollieren Sie den CODESYS -Logger. Die Komponente CmpHilscherCIFX muss geladen worden sein. Wenn CmpHilscherCIFX nicht geladen wurde, tragen Sie die Komponente in der Datei CODESYSControl.cfg ein Wenn CmpHilscherCIFX geladen wurde, wurde eventuell eine veraltete Version verwendet. Aktualisieren Sie in diesem Fall das ganze Laufzeitsystem durch Neuinstallation der RTE. TraceLevel wurde aktiviert, aber ein neuer Eintrag für die CmpHilscherCIFX -Komponente ist nicht zu finden. Das bedeutet, dass das Laufzeitsystem die NetX-Karte\/-Chip nicht findet. Kontrollieren Sie, ob die Karte korrekt eingesteckt ist und der zugehörige Treiber installiert wurde. Siehe hierzu oben: Windows-Treiber installieren. " }, 
{ "title" : "Hardwarekonfiguration - Empfehlungen ", 
"url" : "_rtsl_windows_rte_v3_examples_hints.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Hardwarekonfiguration - Empfehlungen ", 
"snippet" : "Damit die CODESYS Control RTE auf der jeweiligen Plattform mit optimal niedrigem Jitter läuft, müssen Sie gegebenenfalls die BIOS-Einstellungen anpassen. Sehen Sie hierzu im Folgenden einige Beispiele solcher Anpassungen, die jedoch nur als Empfehlung verstanden werden sollten. Folgende Bios-Einstel...", 
"body" : "Damit die CODESYS Control RTE auf der jeweiligen Plattform mit optimal niedrigem Jitter läuft, müssen Sie gegebenenfalls die BIOS-Einstellungen anpassen. Sehen Sie hierzu im Folgenden einige Beispiele solcher Anpassungen, die jedoch nur als Empfehlung verstanden werden sollten. Folgende Bios-Einstellungen sollten grundsätzlich deaktiviert werden: HT (Hyperthreading bei Intel-CPU; Simultaneous Multi-Threading bei AMD-CPU) VT (Virtualization Technology bei Intel-CPUs, AMD-V bei AMD-CPUs) VT führt bei Windows 10 oder höher dazu, dass Windows selbst in einer virtuellen Umgebung gestartet wird und die RTE deshalb nicht in der Lage ist, einen CPU-Core zu starten, obwohl der von Windows nicht verwendet wird. Eine Alternative zum Deaktivieren dieser BIOS-Option ist somit das Deaktivieren des Windows-Features \"VM-Plattform\" oder \"Hyper-V-Plattform\". Wobei das Deaktivieren der BIOS-Option VT die bessere Option ist. Legacy-USB oder andere BIOS-Funktionen, die zu periodischen SMIs führen. SMIs sind Systemmanagement-Interrupts, die das gesamte System für einige zehn oder hundert Mikrosekunden anhalten. Energiesparoptionen von Intel- oder AMD-Prozessoren, die zu Frequenzänderungen führen (wie EIST bei Intel-CPUs, Cool'n'Quiet bei AMD-CPUs) Periodische Selbsttests oder Speichertests Eine entscheidende Rolle spielen die „Schlafzustände“, die in der ACPI-Terminologie „C-States“ heißen. Höhere Zahlen hinter dem „C“ kennzeichnen tiefere Schlafphasen. In der Schlafphase senken die Prozessoren nicht nur Kernspannung und Taktfrequenz, sondern sie schalten auch Cache und ganze Bereiche im Dienst ab. Im BIOS heißt die dafür verantwortliche Option typischerweise „C-States“. Intels „Speedstep“ oder AMDs „PowerNow“ werden manchmal als „EIST“ bezeichnet und müssen in jedem Fall deaktiviert sein. Für den Fall, dass die Überprüfung oder Konfiguration der Prozessoreinstellungen nicht von BIOS erledigt wird, oder die Option nicht verfügbar ist, finden Sie entsprechende Tools im Internet. Beispiele: RightMark CPU CPU-Z (CPUID) RM Clock Energieoptionen wie beispielsweise Schnellstart oder Hibernation dürfen auf keinen Fall zugelassen werden. " }, 
{ "title" : "Verfügbare dynamische Komponenten ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Verfügbare dynamische Komponenten ", 
"snippet" : "Optionale Komponenten dienen der Anpassung von CODESYS Control RTE an spezielle Hardware. Sie können solche Komponenten auf der Registerkarte Component Manager des Dialogs PLC Configuration zusätzlich in die Konfiguration laden. Für weitere Informationen siehe Dialog: System Configuration - Componen...", 
"body" : "Optionale Komponenten dienen der Anpassung von CODESYS Control RTE an spezielle Hardware. Sie können solche Komponenten auf der Registerkarte Component Manager des Dialogs PLC Configuration zusätzlich in die Konfiguration laden. Für weitere Informationen siehe Dialog: System Configuration - Component Manager" }, 
{ "title" : "Anpassung an die Hardware-Plattform ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html#UUID-02a278cf-2b50-1c37-599d-a5067a66fff9_id_fd05abe0de24135c0a8646368ec8e61-id-80961508ba9b6b22c0a8646354292cdd", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Verfügbare dynamische Komponenten \/ Anpassung an die Hardware-Plattform ", 
"snippet" : "Auf Mehrkern-Prozessoren wird immer CmpDrvSchedulerAMP vom Setup installiert. Damit wird die Ausführung der RTE auf einen von Windows nicht genutzten CPU-Kern verlagert. Auf Windows 64-Bit oder Windows-Verisonen > 7 ist ausschließlich mit diesem Vorgehen ein Echtzeitbetrieb möglich. Das Setup wird d...", 
"body" : "Auf Mehrkern-Prozessoren wird immer CmpDrvSchedulerAMP vom Setup installiert. Damit wird die Ausführung der RTE auf einen von Windows nicht genutzten CPU-Kern verlagert. Auf Windows 64-Bit oder Windows-Verisonen > 7 ist ausschließlich mit diesem Vorgehen ein Echtzeitbetrieb möglich. Das Setup wird dabei per Boot-Option numproc die Ausführung von Windows auf die ersten <Anzahl physikalisch vorhandener Kerne - 1> Kerne begrenzen. Auf Hyperthreading-Kerne muss komplett verzichtet werden. Das Setup erkennt die Plattform und trägt automatisch den erforderlichen Treiber als erste Komponente in die cfg-Datei der RTE ein. Diese darf nie geändert werden. Die Treiber speichern jeweils unter ihren Namen im Pfad der Systemdienste HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Service im Schlüssel Params ihre Messergebnisse aus der Messung beim ersten Start, bei der die Geschwindigkeit der verwendeten Hardware ermittelt wird. Bei allen folgenden Systemstarts wird der ermittelte Wert aus der Registry gelesen. Wenn Werte fehlen, wird erneut gemessen. " }, 
{ "title" : "Unterstützung optionaler Feldbuskarten ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html#UUID-02a278cf-2b50-1c37-599d-a5067a66fff9_id_fd05abe0de24135c0a8646368ec8e61-id-db3e9d0eba9b6b22c0a86463246ec925", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Verfügbare dynamische Komponenten \/ Unterstützung optionaler Feldbuskarten ", 
"snippet" : "Treiber CmpEt1000Drv Dieser Treiber unterstützt direkt die Pro1000 -kompatiblen Chipsätze von Intel. Um die Komponente benutzen zu können, müssen Sie den originalen Treiber von Intel im Gerätemanager von Windows durch diesen Treiber ersetzen. Gehen Sie wie folgt vor: Öffnen Sie den Windows-Geräteman...", 
"body" : "Treiber CmpEt1000Drv Dieser Treiber unterstützt direkt die Pro1000 -kompatiblen Chipsätze von Intel. Um die Komponente benutzen zu können, müssen Sie den originalen Treiber von Intel im Gerätemanager von Windows durch diesen Treiber ersetzen. Gehen Sie wie folgt vor: Öffnen Sie den Windows-Gerätemanager. Wählen Sie mit der rechten Maustaste den Befehl Treibersoftware aktualisieren für die selektierte Pro1000 -Netzwerkkarte. Wählen Sie den Treiber manuell aus und geben Sie den Pfad auf <RTE-Installationsverzeichnis>\\CmpET1000MPD an. Falls der Gerätemanager sich weigert, den Treiber zu installieren, deinstallieren Sie den originalen Treiber von Intel mit der <Entf> -Taste und löschen Sie im Verzeichnis <SystemRoot>\\inf die entsprechenden inf - und pnf -Dateien. Hinweis: SystemRoot ist üblicherweise „ C:Windows “. Die hier zu verwendenden inf -Dateien heißen meist net557*.inf \/ pnf oder net559*.inf \/ pnf . Hinweis: Wenn in der inf -Datei auf Pro1000 verwiesen wird, handelt es sich normalerweise um die richtige Datei. Die pnf -Datei hat immer den gleichen Namen wie die inf -Datei. Wenn nun das System neu gestartet wird, kann Windows den Treiber nicht mehr automatisch installieren. Der Hardwaremanager wird gestartet und ihm wird der Treiber in <RTE-Installationsverzeichnis>\\CmpET1000MPD übergeben. Zusätzlich müssen Sie die Laufzeitkomponenten in der Datei  CODESYSControl_User.cfg  aktivieren: Component.<subsequent number>=CmpEt1000Drv Treiber CmpEt100Drv Hinweis: Dieser Treiber wird nur aus Kompatibilitätsgründen ausgeliefert, die Hardware kann nicht mehr erworben werden. Dieser Treiber unterstützt direkt die Pro100 -kompatiblen Chipsätze von Intel. Um die Komponente benutzen zu können, müssen Sie den originalen Treiber von Intel im Gerätemanager von Windows durch diesen Treiber ersetzen. Gehen Sie wie folgt vor: Öffnen Sie den Windows-Gerätemanager. Wählen Sie mit der rechten Maustaste den Befehl Treibersoftware aktualisieren für die selektierte Pro100 -Netzwerkkarte. Wählen Sie den Treiber manuell aus und geben Sie den Pfad auf <RTE-Installationsverzeichnis>\\CmpET100MPD an. Falls der Gerätemanager sich weigert, den Treiber zu installieren, deinstallieren Sie den originalen Treiber von Intel mit der <Entf> -Taste und löschen Sie im Verzeichnis <SystemRoot>\\inf die entsprechenden inf - und pnf -Dateien. Hinweis: SystemRoot ist üblicherweise „ C:\\Windows “. Die hier zu verwendenden inf -Dateien heißen meist net557*.inf \/ pnf oder net559*.inf \/ pnf . Hinweis: Wenn in der inf -Datei auf Pro100 verwiesen wird, handelt es sich normalerweise um die richtige Datei. Die pnf -Datei hat immer den gleichen Namen wie die inf -Datei. Wenn nun das System neu gestartet wird, kann Windows den Treiber nicht mehr automatisch installieren. Der Hardwaremanager wird gestartet und ihm wird der Treiber in <RTE-Installationsverzeichnis>\\CmpET100MPD übergeben. Zusätzlich müssen Sie die Laufzeitkomponenten in der Datei  CODESYSControl_User.cfg  aktivieren: Component.<subsequent number>=CmpEt100Drv Treiber CmpSJACanDrv CmpSJACanDrv ist ein generischer Treiber für CAN-Hardware, die auf dem CAN-Controller SJA1000 oder kompatiblen Controllern basiert. Die PCI-Karten von Peak, Ixxat (passive CAN-Karte) und Automata werden direkt unterstützt. Sie können nach dem Einbau der Karte den entsprechenden Treiber aus dem Verzeichnis W2K_XP_Drivers (im RTE-Installationsverzeichnis) wählen und installieren. Dazu verwenden Sie den Assistenten, der direkt über Neue Hardware gefunden erscheint, oder den Gerätemanager von Windows (Kontextmenü, Befehl Treibersoftware aktualisieren ). Durch manuelle Auswahl eines Treibers und Navigation in eines der oben genannten Verzeichnisse installieren Sie den gewünschten Treiber. Das Gerät befindet sich dann in der Kategorie „ 3S compatible devices “. Hinweis: Der Originaltreiber des Herstellers darf nicht installiert werden! Der CmpSJACanDrv kann auch fest auf der Hardware vorhandene SJA1000 -Controller ansprechen. Die Eigenschaften solcher on-Board-CAN-Controller können Sie dem Treiber über Einträge in der Konfigurationsdatei der CODESYS Control RTE im Abschnitt [CmpSJACanDrv] übergeben. Hier die möglichen Einträge: NumDevices=1 <number of SJAs> ;Number of SJAs, that are configured in the following>\n;(optional: <DisableRetain=1> The driver is told that it should\n; not create any retain entry in the cfg file, even if a CAN adapter is equipped with NVRAM.)\n0.Address=<physical address of the SJA1000> \n0.Interrupt=<interrupt vector of the SJA1000>\n0.IntEdgeTrig=<0 or 1. 0 hardware dependent>\n0.XtalFrequency=<frequency> ;normally 16000000Hz, 24000000Hz is also a possible variant\n0.BusType=<bus type> ;depending on the type of switching of the SJA, \n;1 for ISA, 3 for PCI, 0 for memory\n0.Alignment=<alignment> ;normally 1, hardware dependent\n0.Name=<any name>\n.OutputCtrl=<valid values:e.g. 0xFE, 4C, 1A> ;Depends on the CAN switching\n0.PortAddress=<port address> ;This address is written one time for \n;initializing the CAN switching.\n0.PortValue=<vlaue> ;The value that is written for the initialization. Treiber CmpNetXCanDlDrv Diese Komponente ist ein CAN-Mini-Treiber für eine NetX-CAN-Karte. Mit diesem Treiber kann CODESYS Control RTE über eine NetX-Karte die CAN-Bibliotheken von CODESYS GmbH benutzen. CmpNetXCanDlDrv kann nur zusammen mit CmpHilscherCIFX verwendet werden, über die Sie eine CAN-Firmware (Master oder Slave) laden müssen. Ob Master oder Slave verwendet wird, ist unerheblich, da CmpNetXCanDlDrv nur die CAN-Treiberschnittstelle der Karte benutzt. Das Protokoll wird von einer 3S-CAN-Bibliothek verwaltet. Die Konfiguration der Komponente in der Konfigurationsdatei der CODESYS Control RTE : [CmpNetXCanDlDrv]MaxNumberOfCanNetworks=0..n -> number of the CAN networks (number of the NetIds)\nNetId.0.Channel=0 -> mapping of the NetId onboard nad NetX channels (see CmpHilscherCIFX)\nNetId.0.Board=0 Treiber CmpRTL81x9Mpd Hinweis: Dieser Treiber wird nur aus Kompatibilitätsgründen ausgeliefert, die Hardware kann nicht mehr erworben werden. Dieser Treiber unterstützt direkt den Realtek RTL8139 (und kompatiblen) Ethernet-Contoller. Die Kombi-Chipsätze 8100 und 8110 sind ebenfalls kompatibel. Die Installation erfolgt ebenfalls analog zu CmpEt100Drv . Treiber CmpRTL8169Mpd Analog zu CmpRTL81x9Mpd , für die Gigabit-Variante der o.g. Realtek Ethernet-Controller. Treiber CmpSercos3Master Dieser Treiber unterstützt die SERCOS III PCI Karte 700353x0 der Fa. Automata. Nach dem Einbau der Karte installieren Sie den Treiber aus W2K_XP_Drivers\\Automata_SERCOS3 . Treiber CmpHilscherCIFX Dieser Treiber unterstützt eine CIFX-Karte der Fa. Hilscher. Nach dem Einbau der Karte können Sie den von der Fa. Hilscher mitgelieferten Treiber oder den SysDrv3S installieren. (Lieferumfang des CODESYS Control Win -Laufzeitsystems für Windows von CODESYS GmbH ). Tragen Sie die Komponente in die cfg -Datei der CODESYS Control RTE ein. Das ist mit einem Editor oder über den Dialog PLC Configuration möglich. Erzeugen Sie zusätzlich den Abschnitt [CmpHilscherCIFX] . Für den Treiber sind folgende Einträge nötig (Beispiel): Device.0.BootloaderFilePath=NXCIF50-RTE.bin\nDevice.0.Channel.0.FirmwareFile=cifxdpm.nxf In diesem Beispiel ist die 0 in Device.0 der 0-basierte Index der Karte, falls mehrere benutzt werden. Hinter Channel steht immer 0 , weil alle PCI-Karten von Hilscher nur einen Kanal unterstützen. Die Dateien, die Bootloader oder Firmware enthalten, werden mit der CIFX-Karte von der Firma Hilscher geliefert. Sie müssen sie im Root-Dateiverzeichnis der CODESYS Control RTE platzieren. Eventuell müssen Sie noch die Namen der Dateien, oder die Einträge in der Konfigurationsdatei, anpassen. Für weitere Informationen siehe: Hilscher CIFX-Karte in Betrieb nehmen " }, 
{ "title" : "NVRAM PCI Einsteckkarten ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html#UUID-02a278cf-2b50-1c37-599d-a5067a66fff9_id_fd05abe0de24135c0a8646368ec8e61-id-70a6f7c2ba9b6b22c0a86463083c7758", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Verfügbare dynamische Komponenten \/ NVRAM PCI Einsteckkarten ", 
"snippet" : "Treiber CmpPciRetain Dieser Treiber ermöglicht NVRAM auf einer PCI-Karte als Retain-Speicher zu nutzen. Voraussetzungen: Das NVRAM ist direkt über die physikalische Adresse, die in den PCI-Registern steht, erreichbar und es unterstützt jede Zugriffsbreite, also Byte-, Wort- und Doppelwortzugriffe. S...", 
"body" : "Treiber CmpPciRetain Dieser Treiber ermöglicht NVRAM auf einer PCI-Karte als Retain-Speicher zu nutzen. Voraussetzungen: Das NVRAM ist direkt über die physikalische Adresse, die in den PCI-Registern steht, erreichbar und es unterstützt jede Zugriffsbreite, also Byte-, Wort- und Doppelwortzugriffe. Sie können die Komponente in der Konfigurationsdatei CoDeSysControl.cfg der CODESYS Control RTE in Abschnitt [CmpPciRetain] mit folgenden Einträgen konfigurieren: VendorID , DeviceID , SubDeviceID , SubVendorID : Identifizierung des PCI-Geräts. AddressIndex : PCI-Adressregister ( BAR0 – BAR5 ) das die physikalische Basisadresse des NVRAMs enthält. Standardwert: 0 . MemorySize : Größe (Bytes) des verfügbaren NVRAM. Standardwert: 0x80000 , also 512 kByte. AddrOffset : Verschiebung des NVRAM gegen das benutzte Adressregister. Sehen Sie für die Werte von AddressIndex , MemorySize und AddrOffset die Dokumentation zur verwendeten PCI-Karte. Die Standardwerte der vier IDs identifizieren das MRAM-Gerät in einem Siemens NanoBox-PC. " }, 
{ "title" : "Beckhoff CX5xxx-spezifische Komponenten ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html#UUID-02a278cf-2b50-1c37-599d-a5067a66fff9_id_fd05abe0de24135c0a8646368ec8e61-id-821f92efba9b6b32c0a8646353736f59", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Verfügbare dynamische Komponenten \/ Beckhoff CX5xxx-spezifische Komponenten ", 
"snippet" : "Treiber CmpCX5000Mpd Dieser Treiber ist ein Windows-Netzwerktreiber. Er kann nur auf einem Beckhoff PC der Reihe CXxxxx verwendet werden, auf dem also ein CX5000 Kommunikationsprozessor vorhanden ist. Wenn das Setup der CODESYS Control RTE auf einem CXxxxx -PC ausgeführt wird, wird der Treiber CmpCX...", 
"body" : "Treiber CmpCX5000Mpd Dieser Treiber ist ein Windows-Netzwerktreiber. Er kann nur auf einem Beckhoff PC der Reihe CXxxxx verwendet werden, auf dem also ein CX5000 Kommunikationsprozessor vorhanden ist. Wenn das Setup der CODESYS Control RTE auf einem CXxxxx -PC ausgeführt wird, wird der Treiber CmpCX5000Mpd automatisch installiert und in die Liste der Komponenten (in der cfg-Datei) eingetragen. Zusätzliche Informationen und manuelle Installation: Annahme: Ein CX-IPC wurde standardmäßig mit „Windows7 embedded standard“ installiert. Das umfaßt einen Beckhoff-Treiber für das PCI-Gerät mit den Hardware-IDs VendorID = SubVendorID = 0x15ec und DeviceID = SubDeviceID = 0x5000 . Diesen Treiber können Sie nun nach der Installation von CODESYS Control RTE durch den Treiber CmpCX5000Mpd.sys ersetzen. Verwenden Sie dazu die Funktionalität Treibersoftware aktualisieren der Windows Systemsteuerung: Öffnen Sie den Gerätemanager von Windows. Suchen und selektieren Sie das Systemgerät von Beckhoff und wählen Sie mit der rechten Maustaste den Befehl Treibersoftware aktualisieren . Wählen Sie im Assistenten die Option Treibersoftware manuell suchen und klicken have disk . Wählen Sie die inf -Datei im Installationsverzeichnis der CODESYS Control RTE , Unterverzeichnis CmpCX5000Mpd . Beantworten Sie Nachfragen, ob der Treiber installiert werden soll, mit Ja. Windows installiert daraufhin einen Netzwerkadapter mit der Bezeichnung CX5000 driver for CODESYS Ethernet . Tragen Sie den Treiber in der Konfigurationsdatei CoDeSysControl.cfg (Installationsverzeichnis der CODESYS Control RTE ) manuell ein: Beispiel: Component.3=CmpCX5000Mpd . Anschließend sollte ein Download eines CODESYS -Projekts mit EtherCAT keine unaufgelösten Referenzen mehr anzeigen. Treiber CmpCXSecUPS Dieser Treiber kann nur auf einem „embedded PC“ der Serie CX5000 oder CX5100 der Firma Beckhoff verwendet werden. Die Komponente überwacht im niederprioren, zyklischen Aufruf der Kommunikationstask einen Pin, der den Zustand der Spannungsversorgung überwacht. Wenn ein Spannungsausfall erkannt wird, werden die Applikationen gestoppt und die Retain-Daten in eine Datei (typischerweise Application.ret ) gespeichert. Hinweis: Es gibt folgende Einschränkungen beim Sichern der Retain-Daten: Je nach Auslastungszustand der PLC wird der Spannungsausfall erst mit Verzögerung erkannt. Je nach Auslastung des PCs variiert die Zeit, die nach einem Spannungsausfall zur Speicherung von Daten genutzt werden kann. Wegen dieser Einschränkungen müssen Sie die Speicherung der Retain-Daten zusammen mit der fertigen Applikation testen. Außerdem wird empfohlen, beim Applikationsstart die Gültigkeit der remanenten Variablen zu prüfen. Die Komponente besitzt keine Konfigurationsmöglichkeiten. Sie müssen sie nur der Komponentenliste der Steuerung hinzufügen. Für weitere Informationen siehe: Registry-Einträge der RTE " }, 
{ "title" : "Registry-Einträge der RTE ", 
"url" : "_rtsl_windows_rte_v3_registry_entries.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ CODESYS Control RTE V3 \/ Registry-Einträge der RTE ", 
"snippet" : "Das Verhalten der CODESYS Control RTE ist zum Teil im Windows Registrierungs-Editor (Windows „Registry“) konfigurierbar. Die nachfolgende Tabelle gibt Auskunft über die Werte und den jeweiligen Standardwert, der verwendet wird, wenn der Wert selbst fehlt. Nur ein Teil dieser Werte kann über den Dial...", 
"body" : "Das Verhalten der CODESYS Control RTE ist zum Teil im Windows Registrierungs-Editor (Windows „Registry“) konfigurierbar. Die nachfolgende Tabelle gibt Auskunft über die Werte und den jeweiligen Standardwert, der verwendet wird, wenn der Wert selbst fehlt. Nur ein Teil dieser Werte kann über den Dialog PLC Configuration der CODESYS Control RTE geändert werden. Alle Werte befinden sich in der Registry im Pfad HKEY_LOCAL_MACHINE\\SOFTWARE\\3S-Smart Software Solutions GmbH\\CODESYS SP\\3SRTE3 oder relativ dazu, wenn in der Tabelle ein Schlüssel vor dem Namen angegeben ist. Name Typ Bedeutung Standardwert AutoStartPLC DWORD 0 oder 1 : Mit 1 wird die SPS vom Systemdienst automatisch gestartet. 0 AllowSetAppConfiguration DWORD 0 oder 1 : Legt fest, ob der Benutzer mit dem Dialog die Werte des Konfigurationsdialogs Application setzen darf. 1 AllowSetCMConfiguration DWORD 0 oder 1 : <Analog zum Eintrag vorher> 1 AllowSetFileConfiguration DWORD 0 oder 1 : <Analog zum Eintrag vorher> 1 AllowSetLoggerConfiguration DWORD 0 oder 1 : <Analog zum Eintrag vorher> 1 AllowSetSchedConfiguration DWORD DWORD 0 oder 1 : <Analog zum Eintrag vorher> 1 AllowSetTargetConfiguration DWORD 0 oder 1 : <Analog zum Eintrag vorher> 1 CallBuffersize DWORD Größe des Puffers für asynchrone Funktionsaufrufe (alle Funktionsaufrufe, die über Windows ausgeführt werden, beispielsweise File-Dienste, Socket-Funktionen usw.) Je mehr gleichzeitige Aufrufe eine Applikation benötigt, desto größer sollte aus Performancegründen dieser Puffer sein. 65536 CfgFile STRING Dieser Wert zeigt direkt auf die Konfigurationsdatei der CODESYS Control RTE . <Installationspfad der CODESYS Control RTE > DisablePlcAutoStart DWORD Dieser Wert wird intern vom Konfigurationsdialog PLC Configuration benutzt. Diese Variable darf manuell nur geändert werden, wenn beispielsweise der Konfigurationsdialog abgestürzt wäre und die Variable nie mehr automatisch auf 0 geschrieben wird. 0 ShowAppConfiguration DWORD 0 oder 1 : Legt fest, ob der Benutzer im Konfigurationsdialog PLC Configuration die Registerkarte Application sehen kann. 1 ShowCMConfiguration DWORD 0 oder 1 : <Analog zum Eintrag vorher> 1 ShowFileConfiguration DWORD 0 oder 1 : <Analog zum Eintrag vorher> 1 ShowLoggerConfiguration DWORD 0 oder 1 : <Analog zum Eintrag vorher> 1 ShowSchedConfiguration DWORD 0 oder 1 : <Analog zum Eintrag vorher> 1 ShowTargetConfiguration DWORD 0 oder 1 : <Analog zum Eintrag vorher> 1 LastExit DWORD 0 oder 1 zur Kontrolle, ob das letzte Beenden der RTE erfolgreich war. 1 Path STRING Dieser Wert zeigt auf das Verzeichnis, das der Root-Pfad des Dateisystems der CODESYS Control RTE ist. <Installationspfad der CODESYS Control RTE > SysTrayLocalPort DWORD TCP\/IP-Port, auf dem lokal die Kommunikation zwischen „SysTray“ und dem Systemdienst der CODESYS Control RTE stattfindet. 15965 SysTrayRemoteAddr DWORD DWORD IP-Adresse des Remote-Systems, das mit dem „SysTray“ der CODESYS Control RTE administriert werden soll. 0 SysTrayRemotePort DWORD Wie SysTrayLocalPort , für das entfernte System. 15965 SysTrayUseRemotePLC DWORD 0 oder 1 : Legt fest, ob die lokale oder eine CODESYS Control RTE auf einem anderen PC (Remote System) angesprochen werden soll. 0 KernelVersion STRING Version der CODESYS Control RTE , die auf diesem PC zuletzt gestartet wurde. Wird bei jedem Systemstart der CODESYS Control RTE geschrieben. <Versionskennung> VersionSrv STRING Version des Systemdienstes der CODESYS Control RTE . Sollte immer die gleiche Version wie die des Kernels sein, außer bei manuellen Patches, bei denen der Kernel oder der Systemservice zu Testzwecken manuell durch eine andere Version ersetzt wurde. <Versionskennung> IO Driverpool KEY Alle Subkeys in diesem Key werden in der Dropdown-Liste der verfügbaren Komponenten im Konfigurationsdialog PLC Configuration angezeigt. StackSizePerTask DWORD Größe des Stacks für jede Task bei Bedarf (unerklärliche Abstürze bei komplexen Funktionsaufrufen). 0x6000 (24Kbyte) CreateBluescreenOnFirstException DWORD Die erste Exception, die auftritt, soll einen Bluescreen (und damit einen für Diagnosezwecke verwertbaren Speicherdump) erzeugen. In der Windows-Systemeinstellung für Starten und Wiederherstellen sollte Kernelspeicher gewählt sein. 0 Für weitere Informationen siehe: Echtzeitverhalten auf speziellen Plattformen konfigurieren " }, 
{ "title" : "Performance-Optimierung ", 
"url" : "_rtsl_performance_realtime_windows.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Performance-Optimierung ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "\"Soft Realtime\"-Verhalten der CODESYS Control Win ", 
"url" : "_rtsl_performance_realtime_windows.html#UUID-260b1b52-f206-9ca7-1cd0-920e224c4997_section-idm43415804467536", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Konfigurieren und Erweitern \/ Performance-Optimierung \/ \"Soft Realtime\"-Verhalten der CODESYS Control Win ", 
"snippet" : "Die CODESYS Control Win wird zwar als \"Realtime\" Prozess unter Windows betrieben, aber das ist nicht mit harten Echtzeitanforderungen einer SPS gleichzusetzen. Latenzen und Jitterzeiten liegen im Bereich mehrerer Millisekunden. In Ausnahmefällen können es auch mehrere 10 Millisekunden sein. Diese Ve...", 
"body" : "Die CODESYS Control Win wird zwar als \"Realtime\" Prozess unter Windows betrieben, aber das ist nicht mit harten Echtzeitanforderungen einer SPS gleichzusetzen. Latenzen und Jitterzeiten liegen im Bereich mehrerer Millisekunden. In Ausnahmefällen können es auch mehrere 10 Millisekunden sein. Diese Verzögerung ist von mehreren Faktoren abhängig, beispielsweise von der Auslastung im Windows Kernel, der Netzwerklast, der Verwendung von ungünstigen oder veralteten Treibern und der Leistungsfähigkeit des Computers. Durch diese Verzögerungen ist die CODESYS Control Win für typische Motion-Anwendungen nicht geeignet. Generell müssen die Anforderungen der realen Applikation gegen die Möglichkeiten und Einschränkungen der CODESYS Control Win auf dem konkreten PC validiert werden. Eine allgemeine Aussage, mit welchen maximalen Jitterzeiten zu rechnen ist, ist aufgrund der vielen Randbedingungen nicht möglich. " }, 
{ "title" : "Referenz ", 
"url" : "_rtsl_reference_windows.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Referenz ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Dialoge ", 
"url" : "_rtsl_reference_dialogs.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Referenz \/ Dialoge ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Dialog: Optionen - Runtime Deploy Tool ", 
"url" : "_rtsl_dlg_options_runtime_deploy_tool.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Referenz \/ Dialoge \/ Dialog: Optionen - Runtime Deploy Tool ", 
"snippet" : "Symbol: Funktion : Der Dialog ermöglicht den Zugriff auf das Dateisystem des Entwicklungssystems, um den privaten SSH-Schlüssel zu verwalten. Aufruf : Menü Tools → Optionen , Kategorie Runtime Deploy Tool Voraussetzung : Der Dialog ist nur verfügbar, wenn wenigstens ein CODESYS SL-Produkt installier...", 
"body" : "Symbol: Funktion : Der Dialog ermöglicht den Zugriff auf das Dateisystem des Entwicklungssystems, um den privaten SSH-Schlüssel zu verwalten. Aufruf : Menü Tools → Optionen , Kategorie Runtime Deploy Tool Voraussetzung : Der Dialog ist nur verfügbar, wenn wenigstens ein CODESYS SL-Produkt installiert wurde. Sehen Sie im Tools → Package Manager , welche Produkte installiert wurden. SSH-Key Key Name der OPENSSH-Datei, die als privater Schlüssel fungiert Beispiel: serviceuser.openssh Hinweis: Es werden nur auf Korrektheit überprüfte Schlüsseldateien angezeigt. Pfad Speicherort des SSH-Keys Beispiel: D:\\PLCs\\Keys\\serviceuser.openssh Hinzufügen Öffnet einen Dateiverwaltungsdialog Dort wählen Sie die Schlüsseldatei mit dem privaten Schlüssel (OPENSSH-Datei) aus. Die Datei wird mit dem Runtime Deploy Tool verknüpft. Tipp: Sichern Sie den privaten Schlüssel auf dem Entwicklungsrechner an einem geeigneten oder auch geheimen Speicherort. Hinweis: Geben Sie den privaten Schlüssel niemals weiter. Entfernen Entfernt die Verknüpfung zur selektierten Schlüsseldatei OK Übernimmt die Einstellungen und beendet den Dialog Cancel Beendet den Dialog " }, 
{ "title" : "Dialog: System Configuration - Diagnostic ", 
"url" : "_rtsl_dlg_system_config_diagnosis.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Referenz \/ Dialoge \/ Dialog: System Configuration - Diagnostic ", 
"snippet" : "Aufruf : Menü CODESYS Control RTE in der Statusleiste Der Dialog System Configuration öffnet sich mit der ersten Registerkarte: Diagnostic . Sie enthält Informationen zu diversen Zuständen und IDs aus der Steuerung....", 
"body" : "Aufruf : Menü CODESYS Control RTE in der Statusleiste Der Dialog System Configuration öffnet sich mit der ersten Registerkarte: Diagnostic . Sie enthält Informationen zu diversen Zuständen und IDs aus der Steuerung. " }, 
{ "title" : "Dialog: System Configuration - Target ", 
"url" : "_rtsl_dlg_system_config_target.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Referenz \/ Dialoge \/ Dialog: System Configuration - Target ", 
"snippet" : "Aufruf: Menü CODESYS Control RTE in der Statusleiste, dann Auswählen der Registerkarte Target Hier kann in Target name ein fester Name für die installierte CODESYS Control RTE eingetragen werden. Standardmäßig meldet sich die SPS mit dem Namen des Rechners, auf dem sie läuft....", 
"body" : "Aufruf: Menü CODESYS Control RTE in der Statusleiste, dann Auswählen der Registerkarte Target Hier kann in Target name ein fester Name für die installierte CODESYS Control RTE eingetragen werden. Standardmäßig meldet sich die SPS mit dem Namen des Rechners, auf dem sie läuft. " }, 
{ "title" : "Dialog: System Configuration - File ", 
"url" : "_rtsl_dlg_system_config_file.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Referenz \/ Dialoge \/ Dialog: System Configuration - File ", 
"snippet" : "Aufruf: Menü CODESYS Control RTE in der Statusleiste, dann Auswählen der Registerkarte File Hier können Standardablageorte für verschiedene Dateitypen auf der CODESYS Control RTE konfiguriert werden. File Relative file path Relativer Pfad zum Arbeitsverzeichnis der RTE.( C:\\ProgramData\\CODESYS\\CODES...", 
"body" : "Aufruf: Menü CODESYS Control RTE in der Statusleiste, dann Auswählen der Registerkarte File Hier können Standardablageorte für verschiedene Dateitypen auf der CODESYS Control RTE konfiguriert werden. File Relative file path Relativer Pfad zum Arbeitsverzeichnis der RTE.( C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 ) Files to store in thies file path (e.g. *.app, *.crc) Dateitypen, die im Dateipfad gespeichert werden sollen. Kommaseparierte Auflistung, Beispiel: *.app, *.crc " }, 
{ "title" : "Dialog: System Configuration - Scheduler ", 
"url" : "_rtsl_dlg_system_config_scheduler.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Referenz \/ Dialoge \/ Dialog: System Configuration - Scheduler ", 
"snippet" : "Aufruf: Menü CODESYS Control RTE in der Statusleiste, dann Auswählen der Registerkarte Scheduler Hier finden sich Einstellungen für den Task-Scheduler des Laufzeitsystems. Sie betreffen das Durchführen einer Lastüberwachung und das Verhalten im Fall einer Grenzwertverletzung. Eine Änderung dieser Ei...", 
"body" : "Aufruf: Menü CODESYS Control RTE in der Statusleiste, dann Auswählen der Registerkarte Scheduler Hier finden sich Einstellungen für den Task-Scheduler des Laufzeitsystems. Sie betreffen das Durchführen einer Lastüberwachung und das Verhalten im Fall einer Grenzwertverletzung. Eine Änderung dieser Einstellungen ist nur für spezielle Anforderungen nötig. Processor Load Max. processor load Lastbegrenzung des Systems Ab dieser CPU-Last wird entweder eine Exception ausgelöst oder das Timeslicing begonnen. Eine Änderung dieser Einstellung kann zum Ausfall (Exception) der Steuerung führen. Für weitere Informationen siehe: CODESYS Control V3 Runtime System Documentation " }, 
{ "title" : "Dialog: System Configuration - Logger ", 
"url" : "_rtsl_dlg_system_config_logger.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Referenz \/ Dialoge \/ Dialog: System Configuration - Logger ", 
"snippet" : "Aufruf: Menü CODESYS Control RTE in der Statusleiste, dann Auswählen der Registerkarte Logger Hier finden sich Einstellungen zum Speichern der Log-Meldungen aus der SPS in eine oder mehrere Dateien. Standard Logger Enable : Die Vorgänge in der SPS werden geloggt. Backend File Enable : : Eine oder me...", 
"body" : "Aufruf: Menü CODESYS Control RTE in der Statusleiste, dann Auswählen der Registerkarte Logger Hier finden sich Einstellungen zum Speichern der Log-Meldungen aus der SPS in eine oder mehrere Dateien. Standard Logger Enable : Die Vorgänge in der SPS werden geloggt. Backend File Enable : : Eine oder mehrere Dateien mit den Log-Meldungen werden im Arbeitsverzeichnis angelegt ( C:\\ProgramData\\CODESYS\\CODESYSControlRTE ). Bei Bedarf wird jeweils die älteste Datei überschrieben. Max. Files : Maximale Anzahl von Dateien. 0 bedeutet, dass keine Dateien überschrieben werden, also alle Log-Einträge archiviert werden. Max. Files Size : Maximale Größe einer Datei. Max. Entries : Maximale Anzahl von Log-Einträgen in einer Datei. Für weitere Informationen siehe: Registerkarte: Log " }, 
{ "title" : "Dialog: System Configuration - Application ", 
"url" : "_rtsl_dlg_system_config_application.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Referenz \/ Dialoge \/ Dialog: System Configuration - Application ", 
"snippet" : "Aufruf: Menü CODESYS Control RTE in der Statusleiste, dann Auswählen der Registerkarte Application Hier werden Einstellungen für die Applikationskomponente der SPS vorgenommen. Bootapplications Create on Download : Beim Download wird implizit eine Bootapplikation erzeugt. Store only on Download : Be...", 
"body" : "Aufruf: Menü CODESYS Control RTE in der Statusleiste, dann Auswählen der Registerkarte Application Hier werden Einstellungen für die Applikationskomponente der SPS vorgenommen. Bootapplications Create on Download : Beim Download wird implizit eine Bootapplikation erzeugt. Store only on Download : Beim Download wird implizit eine Bootapplikation erzeugt, das Projekt aber nicht in den Speicher geladen. (Nur für spezielle Anwendungen) Behaviour on Retain Mismatch Optionen für das Verhalten der SPS im Fall von korrupten Retain-Daten: Do not load : Die Bootapplikation wird nicht geladen. Load with Exception : Die Bootapplikation wird geladen, aber nicht gestartet. Eine Exception wird ausgegeben. Load and Initialize Retains : Die Bootapplikation wird geladen und wie nach einem Download initialisiert. Invalidate bootapplications Optionen bezüglich des Invalidierens der Bootapplikation, im Fall dass die Steuerung nicht ordnungsgemäß beendet wurde: Never : Die Bootapplikation wird nie invalidiert. By Setting : Die Bootapplikation wird in der Konfigurationsdatei der SPS ( *.cfg ) für ungültig erklärt. By Rename : Die *.app -Datei der Bootapplikation wird umbenannt und die Bootapplikation damit ungültig. Retain Type Optionen für das Speichern der Retain-Datein auf der CODESYS Control RTE : None : Die Daten werden nicht gespeichert, die SPS kann keine Retain-Daten verwenden. SRAM : Die SPS kann einen physikalischen, nichtflüchtigen Speicher für die Retain-Daten verwenden. On Powerfail : Beim Herunterfahren der Steuerung werden die Retain-Daten in einer Datei gespeichert. Dazu muss das System mit einer USV ausgestattet sein. Dann werden auch Stromausfälle berücksichtigt. Persistent Force Wenn aktiviert, bleiben die geforcten Werte auch über einen Neustart der Steuerung erhalten. Für weitere Informationen siehe: Erzeugen einer Bootapplikation " }, 
{ "title" : "Dialog: System Configuration - Component Manager ", 
"url" : "_rtsl_dlg_system_config_component_manager.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Referenz \/ Dialoge \/ Dialog: System Configuration - Component Manager ", 
"snippet" : "Aufruf: Menü CODESYS Control RTE in der Statusleiste, dann Auswählen der Registerkarte Component Manager Hier werden zusätzliche Komponenten, die von der SPS nicht standardmäßig geladen werden, verwaltet. Für weitere Informationen siehe Verfügbare dynamische KomponentenComponent Manager Plc Configur...", 
"body" : "Aufruf: Menü CODESYS Control RTE in der Statusleiste, dann Auswählen der Registerkarte Component Manager Hier werden zusätzliche Komponenten, die von der SPS nicht standardmäßig geladen werden, verwaltet. Für weitere Informationen siehe Verfügbare dynamische KomponentenComponent Manager Plc Configuration Path Root-Pfad des Dateisystems der SPS. Beispiel: C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 Additional Components Komponenten, die von der SPS nicht standardmäßig geladen werden, können hier eingetragen\/ausgewählt werden. " }, 
{ "title" : "Dialog: System Configuration - Startup ", 
"url" : "_rtsl_dlg_system_config_startup.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Referenz \/ Dialoge \/ Dialog: System Configuration - Startup ", 
"snippet" : "Aufruf: Menü CODESYS Control RTE in der Statusleiste, dann Auswählen der Registerkarte Startup Wählen Sie eine der Optionen bezüglich des Hochfahrens der CODESYS Control RTE : Startup Start the RTE basic system service when booting Der Systemdienst (Anzeigename „ 3S RTE Service V3 “) wird beim Start...", 
"body" : "Aufruf: Menü CODESYS Control RTE in der Statusleiste, dann Auswählen der Registerkarte Startup Wählen Sie eine der Optionen bezüglich des Hochfahrens der CODESYS Control RTE : Startup Start the RTE basic system service when booting Der Systemdienst (Anzeigename „ 3S RTE Service V3 “) wird beim Starten des Systemsautomatisch gestartet. Damit ist der Dienst bereits vor der Anmeldung eines Benutzers verfügbar. Start the PLC with the basic system service Die SPS wird beim Start des Systemdienstes gestartet. Zusammen mit der ersten Option wird also die SPS sofort nach dem Hochfahren des PCs gestartet. Do not load boot applications Die SPS lädt ihre Bootapplikation auch bei einem automatischen Start nicht. " }, 
{ "title" : "Befehle ", 
"url" : "_rtsl_commands.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Referenz \/ Befehle ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Menüs in der Systemleiste ", 
"url" : "_rtsl_cmd_menu.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Referenz \/ Befehle \/ Menüs in der Systemleiste ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS Control ", 
"url" : "_rtsl_cmd_menu.html#UUID-dc0920ec-91e3-5d46-7959-a04fb4357af3_section-idm4616768769337633167655660684", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Referenz \/ Befehle \/ Menüs in der Systemleiste \/ CODESYS Control ", 
"snippet" : "Zugriff auf die Benutzerschnittstelle der CODESYS Control Win erhalten Sie über das Symbol in der Systemleiste („Systray“) Ihres PCs. Ein Klick mit der rechten Maustaste auf das Symbol öffnet ein Menü mit folgenden Befehlen: Start PLC : Schaltet die SPS ein. Das Symbol in der Statusleise wechselt zu...", 
"body" : "Zugriff auf die Benutzerschnittstelle der CODESYS Control Win erhalten Sie über das Symbol in der Systemleiste („Systray“) Ihres PCs. Ein Klick mit der rechten Maustaste auf das Symbol öffnet ein Menü mit folgenden Befehlen: Start PLC : Schaltet die SPS ein. Das Symbol in der Statusleise wechselt zu . Hinweis: Wenn die SPS beim Systemstart automatisch eingeschaltet werden soll, müssen Sie in den Eigenschaften des Dienstes die entsprechende Startoption einstellen. Sehen Sie dazu auf der Hilfeseite „Installation und erste Schritte“. Stop PLC : Schaltet die SPS aus. Das Symbol wechselt zu . Exit PLC Control : Beendet die Verfügbarkeit des Benutzermenüs in der Systemleiste. Das Symbol verschwindet, die SPS läuft jedoch weiter. Die für die Anzeige in der Systemleiste zuständige ausführbare Datei ist CODESYSControlSysTray.exe . Sie liegt im Installationsverzeichnis in Unterverzeichnis GatewayPLC von CODESYS Control Win . About… : Zeigt Versionsinformationen zur installierten CODESYS Control Win . " }, 
{ "title" : "CODESYS Control RTE ", 
"url" : "_rtsl_cmd_menu.html#UUID-dc0920ec-91e3-5d46-7959-a04fb4357af3_section-idm4544772591294433167656742159", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Referenz \/ Befehle \/ Menüs in der Systemleiste \/ CODESYS Control RTE ", 
"snippet" : "Zugriff auf die Benutzerschnittstelle der CODESYS Control RTE erhalten Sie über das Symbol in der Systemleiste („Systray“) Ihres PCs. Ein Klick mit der rechten Maustaste auf das Symbol öffnet ein Menü mit folgenden Befehlen: Start PLC : Schaltet die SPS ein. Das Symbol wechselt zu . Stop PLC : Schal...", 
"body" : "Zugriff auf die Benutzerschnittstelle der CODESYS Control RTE erhalten Sie über das Symbol in der Systemleiste („Systray“) Ihres PCs. Ein Klick mit der rechten Maustaste auf das Symbol öffnet ein Menü mit folgenden Befehlen: Start PLC : Schaltet die SPS ein. Das Symbol wechselt zu . Stop PLC : Schaltet die SPS aus. Das Symbol wechselt zu . Exit PLC Control : Die Kontrolle der CODESYS Control RTE über die Systemleiste ist nicht mehr möglich. Das Symbol verschwindet, die SPS läuft jedoch weiter. PLC Configuration : Öffnet den Dialog System Configuration . Verschiedene Registerkarten enthalten Diagnoseinformationen und die Konfigurationseinstellungen der CODESYS Control RTE . Remote PLC : Öffnet den Dialog Remote Configuration . Durch Aktivieren oder Deaktivieren der Option Control remote PC, not local legen Sie fest, ob eine auf einem entfernten PC liegende oder die auf dem lokalen PC laufende SPS verwendet wird. Entsprechend beziehen sich die Menübefehle Start PLC , Stop PLC und PLC Configuration auf den lokalen oder auf einen über das Netzwerk erreichbaren PC. Tragen Sie für den entfernten PC dessen IP-Adresse ( Target PC address ), die Portnummer ( Port number ) und einen Timeout -Wert in Millisekunden für die Verbindung ( Remote Timeout [ms] ) ein. About : Zeigt Versionsinformationen zur installierten CODESYS Control RTE " }, 
{ "title" : "Befehl: Update Edge Gateway ", 
"url" : "_rtsl_cmd_update_edge_gateway.html", 
"breadcrumbs" : "CODESYS Control \/ Windowsbasierte Laufzeitsysteme \/ Referenz \/ Befehle \/ Befehl: Update Edge Gateway ", 
"snippet" : "Funktion : Der Befehl öffnet die Ansicht Edge Gateway . In der Ansicht können Sie das Edge-Gateway-Package (DEB-Datei) installieren, starten und stoppen. Außerdem werden auf System- und Laufzeitebene Funktionalitäten bereitgestellt, die Sie bei der Inbetriebnahme und der Applikationsentwicklung unte...", 
"body" : "Funktion : Der Befehl öffnet die Ansicht Edge Gateway . In der Ansicht können Sie das Edge-Gateway-Package (DEB-Datei) installieren, starten und stoppen. Außerdem werden auf System- und Laufzeitebene Funktionalitäten bereitgestellt, die Sie bei der Inbetriebnahme und der Applikationsentwicklung unterstützen. Aufruf : Menü Tools Login-Anmeldedaten Benutzername Benutzername und Passwort des Linux-Computers Passwort Zielgerät auswählen IP-Adresse IP-Adresse oder Name des Zielgeräts Beispiel: 192.168.99.39 Durchsuchen Öffnet den Dialog Durchsuchen Edge Gateway Dort sind alle Geräte mit IP-Adresse und der zugehörigen MAC-Adresse (in Klammern) aufgelistet, die im Netz aktuell verbunden sind und dem Gerätetyp entsprechen. Der Gerätetyp wird dabei über die MAC-Adresse identifiziert. Beispiel: 192.168.123.123(BB:27:EB:FA:98:52) CODESYS Edge Gateway for Linux Package Version Version und Architektur des Edge Gateways, das installiert wird Beispiel: V3.5.15.0 (amd64) Installieren Startet den Installationsvorgang für das Edge-Gateway-Package in der eingestellten Version und Architektur Entfernen Entfernt die Installation, die aktuell auf dem Linux -Gerät ist Daraufhin können Sie eine beliebige Version installieren. Package-Verzeichnis Ordner, in dem sich die-Edge-Gateway-Packages ( *.deb ) befinden Zusätzliche Packages Installieren Installiert zusätzliche Linux-Packages auf die Steuerung oder aktualisiert bereits vorhandene Packages Beispiel: Wibu CodeMeter Runtime-Package. Sie können das Package von der Wibu-Systems-Homepage herunterladen und mit diesem Befehl auf der Steuerung installieren oder aktualisieren. Verwalten Öffnet einen Dialog, der alle installierten Packages mit zusätzlichen Informationen zeigt Sie können einzelne Packages in diesem Dialog deinstallieren. System System-Info Öffnet den Dialog Systeminformation <Benutzername@<IP-Adresse> Beispiel: Systeminformation root@192.168.123.123 Zielgerät neu starten Führt auf der Steuerung einen Neustart des Systems durch Edge Gateway Start Startet das Edge Gateway Stop Stoppt das Edge Gateway " }
]
$(document).trigger('search.ready');
});