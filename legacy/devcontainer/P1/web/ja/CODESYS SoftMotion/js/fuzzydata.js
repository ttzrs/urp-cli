$(document).ready(function () {indexDict['ja'] = [{ "title" : "CODESYS SoftMotion ", 
"url" : "_sm_start_page.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion ", 
"snippet" : "と CODESYS SoftMotion 、PLCの動きを効率的に作成できます。これは、単純な単軸の動きやカムから、多次元での複雑な動きにまで及びます。特に、モーション機能に加えてフロー制御とプロセス制御を含むアプリケーションは、 CODESYS SoftMotion 。 ダウンロードできます CODESYS SoftMotion から  CODESYS Store International  または  CODESYS Store North America .そこには、製品のデータシートもあります。 こちらも参照 CODESYS SoftMotion の中に CODESYSフォーラム...", 
"body" : "と CODESYS SoftMotion 、PLCの動きを効率的に作成できます。これは、単純な単軸の動きやカムから、多次元での複雑な動きにまで及びます。特に、モーション機能に加えてフロー制御とプロセス制御を含むアプリケーションは、 CODESYS SoftMotion 。 ダウンロードできます CODESYS SoftMotion から  CODESYS Store International  または  CODESYS Store North America .そこには、製品のデータシートもあります。 こちらも参照 CODESYS SoftMotion の中に CODESYSフォーラム " }, 
{ "title" : "ライセンス ", 
"url" : "_sm_licensing.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ ライセンス ", 
"snippet" : "一般的なものに加えて、 ライセンスを取得したソフトウェアのメトリクス 、メトリクスは次のように定義されています CODESYS SoftMotion ダウンロード中にチェックされます。 の SoftMotion メトリクスはコンパイル中に計算され、現在の値はその後にのみエディターに表示されます。 決定された値は 1 つのアプリケーションを指します。複数のアプリケーションが存在する場合、各アプリケーションの値が合計されます。 グループ メトリック 確定値 軸数 実軸 メトリックの値は、使用される実軸と仮想軸の大きい方の値によって定義されます。 例: 3 つの実軸と 4 つの仮想軸の場合、アプリケ...", 
"body" : "一般的なものに加えて、 ライセンスを取得したソフトウェアのメトリクス 、メトリクスは次のように定義されています CODESYS SoftMotion ダウンロード中にチェックされます。 の SoftMotion メトリクスはコンパイル中に計算され、現在の値はその後にのみエディターに表示されます。 決定された値は 1 つのアプリケーションを指します。複数のアプリケーションが存在する場合、各アプリケーションの値が合計されます。 グループ メトリック 確定値 軸数 実軸 メトリックの値は、使用される実軸と仮想軸の大きい方の値によって定義されます。 例: 3 つの実軸と 4 つの仮想軸の場合、アプリケーションの値 = 4。 仮想軸 軸グループとCNC補間器の数 軸グループ メトリックの値は、軸グループと CNC 補間器の合計によって定義されます。 例: 2 つの軸グループと 2 つの CNC 補間器の場合、アプリケーションの値 = 4。 CNC補間装置 " }, 
{ "title" : "のコンポーネント CODESYS SoftMotion ", 
"url" : "_sm_components.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ のコンポーネント CODESYS SoftMotion ", 
"snippet" : "CODESYS SoftMotion は、モーションコントロールの開発およびランタイム環境として使用されるソフトウェアパッケージです。それは次のように概説されています： ドライブ構成 ：ドライブ構成は、ドライブハードウェアの構造と構成を設定するためのエディターを提供します。 CODESYS ユーザーインターフェース。このとき、ドライブを表すIEC機能ブロックのインスタンスが作成されます。この機能ブロックは、IECプログラマーによる追加の作業なしで、ドライブと自動的に通信します。更新されたデータを送信する責任があります。 ドライブを制御するために、IECプログラムは、の機能ブロックを使用してドラ...", 
"body" : "CODESYS SoftMotion は、モーションコントロールの開発およびランタイム環境として使用されるソフトウェアパッケージです。それは次のように概説されています： ドライブ構成 ：ドライブ構成は、ドライブハードウェアの構造と構成を設定するためのエディターを提供します。 CODESYS ユーザーインターフェース。このとき、ドライブを表すIEC機能ブロックのインスタンスが作成されます。この機能ブロックは、IECプログラマーによる追加の作業なしで、ドライブと自動的に通信します。更新されたデータを送信する責任があります。 ドライブを制御するために、IECプログラムは、の機能ブロックを使用してドライブをアドレス指定できます。 SoftMotion ライブラリ。または、この目的のために独自の機能ブロックを開発することもできます。設定値（位置、速度、加速度など）は、これらの機能ブロックによって周期的に書き込まれます。 注： CODESYS SoftMotion Light 製品はの標準インストールの一部です CODESYS 。軸を指令する機能を提供します。この上、 CODESYS 目標位置のみを定義し、軸コントローラからの応答を待ちます。軸コントローラは、動作計画を担当します。による複数の軸の協調運動 CODESYS 不可能である。 カムエディタ ：カムエディタでは、カムをグラフィカルに、またはテーブルを使用して記述することができます。 CODESYS これから、カムを記述するデータ構造のグローバルインスタンスを生成します。これは、該当するPOUがアクセスできるアプリケーションに渡されます。 CNCエディター ：CNCエディタでは、多次元の動きを生成できます。 CNCパスは、テキストエディタ（DIN 66025に準拠）またはグラフィックエディタを使用して作成できます。テキストエディタの代わりに、簡略化された表形式のビューで作業することもできます。 軸グループ構成 ：軸グループは、空間内のツールまたはツールプレートを集合的に配置および方向付ける複数の機械的に依存する軸間の関係を定義します。 Configuratorを使用して、使用するキネマティクスを選択して構成します。さらに、SoftMotion軸を割り当てることができます。 The SM3_Basic ライブラリはすべての人のための基本的なライブラリです SoftMotion アプリケーション。具体的には、次のものが含まれます。 PLCopen規格に準拠したPLCopenファンクションブロック これらの機能ブロックを使用すると、2軸（電気カム、電気ドライブ）の1軸移動またはマスター\/スレーブ移動を制御できます。 PLCopen機能でカバーされていない追加のFB ヘルプ機能：たとえば、ファイルの処理やエラーメッセージ用 The SM3_CNC ライブラリはに基づいています SM3_Basic 図書館。キネマティック変換の機能ブロックに加えて、CNCモーションの生成、実行、表示に必要なすべてのPOUを提供します。また、パスの前処理とパスの再構築のための機能ブロックも提供します。 The SM3_Robotics ライブラリには、ロボット工学用のPLCopen Part4に準拠した機能ブロックと追加の機能ブロックが含まれています。含まれています SM3_Transformations ライブラリには、サポートされているキネマティック変換が含まれています。 The ドライブインターフェース の一部です SM3_Basic ライブラリであり、IECプログラムとドライブ間の通信を担当します。サポートされているドライブについては、 CODESYS SoftMotion このドライブインターフェイスを実装するライブラリを提供します。 アプリケーション例の説明も参照してください。 " }, 
{ "title" : "CODESYS RTE V3 と CODESYS WIN V3 コントローラーの使用 ", 
"url" : "_sm_rtev3_winv3.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS RTE V3 と CODESYS WIN V3 コントローラーの使用 ", 
"snippet" : "で CODESYS Development System SP20 以降では、 SoftMotion コントローラ CODESYS SoftMotion RTE V3 と CODESYS SoftMotion Win V3 は利用できなくなりました。 CODESYS Control RTE V3 と CODESYS Control Win V3 コントローラが使用されるようになりました。は コマンド：有効にする コマンドは、標準コントローラを次のものに変換するために使用されます。 SoftMotion コントローラー。...", 
"body" : "で CODESYS Development System SP20 以降では、 SoftMotion コントローラ CODESYS SoftMotion RTE V3 と CODESYS SoftMotion Win V3 は利用できなくなりました。 CODESYS Control RTE V3 と CODESYS Control Win V3 コントローラが使用されるようになりました。は コマンド：有効にする コマンドは、標準コントローラを次のものに変換するために使用されます。 SoftMotion コントローラー。 " }, 
{ "title" : "SoftMotion マルチコアプロセッサを使用 ", 
"url" : "_sm_multicore_hint.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ SoftMotion マルチコアプロセッサを使用 ", 
"snippet" : "モーションタスクを複数のプロセッサコアに分散することにより、より多くの軸または軸グループを作動させることができます。 SoftMotion 。その結果、CNCパスの前処理やCP移動のロボットパス計画など、計算量の多いタスクを別のプロセッサコアにスワップアウトできます。その後、バスタスクの他のタスクのためのより多くの時間があります。シングルコアコントローラーの計算能力が不十分であるという事実は、ロボット工学の場合、原因不明の経路速度の低下によって示されます。 システム要求 SMV4.5.1.0以降 コンパイラV3.5.12.0以降 マルチコア互換のランタイムシステム 使用法 ロボット工学とCNC...", 
"body" : "モーションタスクを複数のプロセッサコアに分散することにより、より多くの軸または軸グループを作動させることができます。 SoftMotion 。その結果、CNCパスの前処理やCP移動のロボットパス計画など、計算量の多いタスクを別のプロセッサコアにスワップアウトできます。その後、バスタスクの他のタスクのためのより多くの時間があります。シングルコアコントローラーの計算能力が不十分であるという事実は、ロボット工学の場合、原因不明の経路速度の低下によって示されます。 システム要求 SMV4.5.1.0以降 コンパイラV3.5.12.0以降 マルチコア互換のランタイムシステム 使用法 ロボット工学とCNC：計画とバスのタスクを異なるプロセッサコアに設定します 異なるバスシステムを使用する場合は、個々のバスタスクを異なるプロセッサコアに設定します 複数のタスクと複数のプロセッサコアを使用する場合は、次の点に注意してください。 CNC プランニングタスクに含まれるファンクションブロックは、次のような点で新たな可能性を広げています。 Execute 補間器の特定の状態でのみ入力 ( iStatus 出力)。これはシングルコアにも当てはまります IPO_UNKNOWN IPO_WAIT IPO_FINISHED IPO_INIT（最初の開始のみで、再起動ではありません） 相互依存軸（軸グループ、カム、CNCキネマティクス）のバスタスクは、同じプロセッサコアで実行する必要があります。 " }, 
{ "title" : "CODESYS SoftMotion Drives ", 
"url" : "_sm_f_drive_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SoftMotionドライブ構成 ", 
"url" : "_sm_f_drive_configuration.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotionドライブ構成 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概要 ", 
"url" : "_sm_overview_drive_configuration.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotionドライブ構成 \/ 概要 ", 
"snippet" : "SoftMotion ドライブ インターフェイスは、IEC プログラム内でドライブ ハードウェアをリンク、構成、およびアドレス指定するために使用する標準化されたインターフェイスです。異なるハードウェアを 1 つのインターフェイスにマッピングすることで、ドライブを簡単に交換し、IEC プログラムを再利用できます。このインターフェイスは、ドライブを I\/O マッピングに結合し、必要なモーション データを更新してドライブ コントロールに送信する役割を担います。 ドライブ インターフェイスは次のコンポーネントで構成されます。 デバイスの説明 SoftMotion デバイスをデバイスツリー内の表現に合わ...", 
"body" : "SoftMotion ドライブ インターフェイスは、IEC プログラム内でドライブ ハードウェアをリンク、構成、およびアドレス指定するために使用する標準化されたインターフェイスです。異なるハードウェアを 1 つのインターフェイスにマッピングすることで、ドライブを簡単に交換し、IEC プログラムを再利用できます。このインターフェイスは、ドライブを I\/O マッピングに結合し、必要なモーション データを更新してドライブ コントロールに送信する役割を担います。 ドライブ インターフェイスは次のコンポーネントで構成されます。 デバイスの説明 SoftMotion デバイスをデバイスツリー内の表現に合わせる デバイス記述で参照され、基本機能ブロックを拡張またはオーバーロードするライブラリ。 軸参照SM3 特定のドライブタイプの要件に応じて フィールドバスドライバの標準機能をラップするための非周期的なデータの読み取りと書き込みのための機能ブロックを含むライブラリ 使用する場合 SoftMotion PLCなど CODESYS SoftMotion Win すると、ライブラリマネージャでベースライブラリが自動的にリンクされます。これらの種類のコントローラは、 SoftMotion 一般軸プール ここに空きドライブユニットを挿入できます。 " }, 
{ "title" : "結合ドライブユニット ", 
"url" : "_sm_inserting_connected_drive_devices.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotionドライブ構成 \/ 結合ドライブユニット ", 
"snippet" : "結合されたドライブは、フィールドバストポロジ内のドライブを表すデバイスに属します。これらのドライブのシンボルには、対応するフィールドバスタイプを示す小さなマークが付いています。たとえば、すべての標準サーボドライブはフィールドバスによってコントローラに接続されています。 ドライブを使用する場合、 CODESYS SoftMotion フィールドバスマスターの特定のデバイスの説明を提供します（「_SoftMotion」サフィックス）。これらは、ドライブの基本的なパラメータを最適化しています。 使用されるドライブの場合 CODESYS SoftMotion ドライブ内でモジュロ処理を無効にする必要が...", 
"body" : "結合されたドライブは、フィールドバストポロジ内のドライブを表すデバイスに属します。これらのドライブのシンボルには、対応するフィールドバスタイプを示す小さなマークが付いています。たとえば、すべての標準サーボドライブはフィールドバスによってコントローラに接続されています。 ドライブを使用する場合、 CODESYS SoftMotion フィールドバスマスターの特定のデバイスの説明を提供します（「_SoftMotion」サフィックス）。これらは、ドライブの基本的なパラメータを最適化しています。 使用されるドライブの場合 CODESYS SoftMotion ドライブ内でモジュロ処理を無効にする必要があります。モジュロ処理は次のように実行されます。 CODESYS SoftMotion コントローラで。可能であれば、最大移動範囲は 32 ビットに設定する必要があります。 結合ドライブデバイスの追加（EtherCAT） 要件: SoftMotion 互換コントローラーがプロジェクトに挿入されている。 を選択 SoftMotion デバイスツリーのコントローラー。 コンテキストメニューで、をクリックします デバイスを追加 。 の中に デバイスを追加 ダイアログで、 フィールドバス→EtherCAT→マスター→EtherCATマスターSoftMotion 端末。 クリック デバイスを追加 ボタン。 デバイスがデバイスツリーに追加されます。 The デバイスを追加 ダイアログは開いたままです。 デバイスツリーに追加したデバイスを選択します。 の中に デバイスを追加 ダイアログで、SoftMotionスレーブを選択します（ フィールドバス→EtherCAT→スレーブ→<SoftMotionドライブ> ）。 クリック デバイスを追加 ボタン。 デバイスがデバイスツリーに追加されます。 デバイスをダブルクリックすると、対応するデバイスエディタが開きます。 " }, 
{ "title" : "エンコーダ軸 ", 
"url" : "_sm_encoder_drive_devices.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotionドライブ構成 \/ エンコーダ軸 ", 
"snippet" : "エンコーダ軸は、エンコーダの値をマスター軸として使用できるSoftMotion軸に変換するために使用されます MC_CamIn 、 MC_GearIn 、およびその他のマスター\/スレーブ機能ブロック。 エンコーダ軸は、ドライブユニットからの追加のエンコーダを表すことができます。この場合、それらはデバイスツリーのフィールドバスデバイスの下に特別なエンコーダー軸として設定されます。または、 ジェネラル・アクシス・プール アナログ入力をエンコーダ軸として使用することもできます。 詳細については、以下を参照してください。 無料のエンコーダ[プロパティ] 論理軸と同様に、エンコーダー軸は「読み取り専用」...", 
"body" : "エンコーダ軸は、エンコーダの値をマスター軸として使用できるSoftMotion軸に変換するために使用されます MC_CamIn 、 MC_GearIn 、およびその他のマスター\/スレーブ機能ブロック。 エンコーダ軸は、ドライブユニットからの追加のエンコーダを表すことができます。この場合、それらはデバイスツリーのフィールドバスデバイスの下に特別なエンコーダー軸として設定されます。または、 ジェネラル・アクシス・プール アナログ入力をエンコーダ軸として使用することもできます。 詳細については、以下を参照してください。 無料のエンコーダ[プロパティ] 論理軸と同様に、エンコーダー軸は「読み取り専用」です。これらは位置と速度の値のみを提供します。それらには動きを命令することはできません エンコーダ軸の軸の状態は常に standstill 。 これがモーションコントロールパート1のPLCOopenの状態で、最もよく一致しています。ステートチャートによると、この状態は軸の準備が整っていてエラーがないことを意味します。さらに、PLCが指示する動きはいずれも軸上ではアクティブではありません。 前に注意してください CODESYS SoftMotion バージョン 4.18.0.0 では、エンコーダの軸はこの状態でした。 power_off 。ただし、いつ MC_Power 呼ばれたんだけど、彼らは調子に乗っていた standstill 。 エンコーダ軸のゼロ位置は次の式でオフセットできます。 MC_SetPosition 。 マスター\/スレーブファンクションブロックは常にエンコーダー軸の実際の値を使用します。 エンコーダ軸の下の論理軸をデッドタイム補正に使用できます。 エンコーダ軸を使用する場合、呼び出す必要はありません MC_Power そして、エンコーダ軸の動作には何の違いもありません CODESYS SoftMotion バージョン 4.18.0.0 以降。 " }, 
{ "title" : "フリードライブユニットの挿入 ", 
"url" : "_sm_f_free_drive_devices.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotionドライブ構成 \/ フリードライブユニットの挿入 ", 
"snippet" : "フリードライブユニットは、デバイスツリー内の他のデバイスと永続的に結合されていません。それらは下のデバイスツリーに挿入されます SoftMotion 一般的なドライブプール 。...", 
"body" : "フリードライブユニットは、デバイスツリー内の他のデバイスと永続的に結合されていません。それらは下のデバイスツリーに挿入されます SoftMotion 一般的なドライブプール 。 " }, 
{ "title" : "ドライブコントロール 'Drive_PosControl' ", 
"url" : "_sm_drive_controller_drive_poscontrol.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotionドライブ構成 \/ フリードライブユニットの挿入 \/ ドライブコントロール 'Drive_PosControl' ", 
"snippet" : "とともに Drive_PosControl ドライブ制御、あなたは軸の位置制御をさせることができます CODESYS 実行を継続します。要件は、設定された速度によって制御され、現在の位置を返すデバイスです。たとえば、これは位置フィードバックを備えた速度制御デバイス（周波数変換器）にすることができます。 ドライブコントロールの追加 要件：SoftMotionコントローラーがプロジェクトに挿入されている。 デバイスツリーで、 SoftMotion 一般軸プール 。 コンテキストメニューで、をクリックします デバイスを追加 。 の中に デバイスを追加 ダイアログで、 SoftMotionドライブ→位...", 
"body" : "とともに Drive_PosControl ドライブ制御、あなたは軸の位置制御をさせることができます CODESYS 実行を継続します。要件は、設定された速度によって制御され、現在の位置を返すデバイスです。たとえば、これは位置フィードバックを備えた速度制御デバイス（周波数変換器）にすることができます。 ドライブコントロールの追加 要件：SoftMotionコントローラーがプロジェクトに挿入されている。 デバイスツリーで、 SoftMotion 一般軸プール 。 コンテキストメニューで、をクリックします デバイスを追加 。 の中に デバイスを追加 ダイアログで、 SoftMotionドライブ→位置制御ドライブ→SMC_Drive_PosControl 端末。 クリック デバイスを追加 ボタン。 デバイスがデバイスツリーに追加されます。 デバイスをダブルクリックすると、対応するデバイスエディタが開きます。 詳細については、次を参照してください。 タブ：一般" }, 
{ "title" : "論理ドライブ ", 
"url" : "_sm_drive_controller_logical_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotionドライブ構成 \/ フリードライブユニットの挿入 \/ 論理ドライブ ", 
"snippet" : "論理ドライブは、あらゆる種類のドライブユニットに追加できます。論理ドライブの軸は、スタンドアロンインスタンスを表している間、マスター軸の動きを反映しています。 これにより、主軸に影響を与えることなく、以下の命令を実行できます。 MC_SetPosition ：位置を定義された値に設定します（例：0） MC_TouchProbe ：トリガー信号の現在の軸位置を保存する MC_AbortTrigger ：以前にアクティブ化されたセンサーを非アクティブ化する MC_TouchProbe 1つのアプリケーションは、複数の処理ステーションを通過するコンベヤーベルトです。コンポーネントの位置は、外部信号（...", 
"body" : "論理ドライブは、あらゆる種類のドライブユニットに追加できます。論理ドライブの軸は、スタンドアロンインスタンスを表している間、マスター軸の動きを反映しています。 これにより、主軸に影響を与えることなく、以下の命令を実行できます。 MC_SetPosition ：位置を定義された値に設定します（例：0） MC_TouchProbe ：トリガー信号の現在の軸位置を保存する MC_AbortTrigger ：以前にアクティブ化されたセンサーを非アクティブ化する MC_TouchProbe 1つのアプリケーションは、複数の処理ステーションを通過するコンベヤーベルトです。コンポーネントの位置は、外部信号（たとえば、光バリア）によって検出され、軸は定義された位置に設定されます（タッチプローブ機能）。論理ドライブは、信号をフィルタリングする機能を提供します。したがって、論理ドライブは、ノイズ信号を送信するエンコーダとともに使用することもできます。 論理ドライブの追加 要件：SoftMotionコントローラーがプロジェクトに挿入されている。 デバイスツリーでドライブユニットを選択します。 コンテキストメニューで、をクリックします デバイスを追加 。 の中に デバイスを追加 ダイアログで、 SoftMotionドライブ→仮想ドライブ→SM_Drive_Logical 端末。 クリック デバイスを追加 ボタン。 デバイスがデバイスツリーに追加されます。 デバイスをダブルクリックすると、対応するデバイスエディタが開きます。 " }, 
{ "title" : "仮想ドライブ ", 
"url" : "_sm_drive_controller_virtual_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotionドライブ構成 \/ フリードライブユニットの挿入 \/ 仮想ドライブ ", 
"snippet" : "仮想ドライブは、ソフトウェアでシミュレートされたドライブです。これにより、ハードウェアを接続せずにプログラムをテストしたり、拡張機能を実装したりできます。これらの種類の機能には、たとえば、軸運動のオーバーライドの制御や、空間内のロボットの手動デカルト法が含まれます。 詳細については、次を参照してください。 仮想時間軸を使用したカムドライブの制御仮想ドライブは、前のサイクルの設定位置を使用して物理ドライブをシミュレートし、サイクル開始時の位置、速度、加速度の実際の値を計算します。物理ドライブを必要とする機能 (例 MC_TouchProbe ドライブ内またはドライブ内で使用する場合 SMC_Se...", 
"body" : "仮想ドライブは、ソフトウェアでシミュレートされたドライブです。これにより、ハードウェアを接続せずにプログラムをテストしたり、拡張機能を実装したりできます。これらの種類の機能には、たとえば、軸運動のオーバーライドの制御や、空間内のロボットの手動デカルト法が含まれます。 詳細については、次を参照してください。 仮想時間軸を使用したカムドライブの制御仮想ドライブは、前のサイクルの設定位置を使用して物理ドライブをシミュレートし、サイクル開始時の位置、速度、加速度の実際の値を計算します。物理ドライブを必要とする機能 (例 MC_TouchProbe ドライブ内またはドライブ内で使用する場合 SMC_SetControllerMode 、はサポートされていません。 仮想ドライブの追加 要件：SoftMotionコントローラーがプロジェクトに挿入されている。 デバイスツリーで、 SoftMotion 一般軸プール 。 コンテキストメニューで、をクリックします デバイスを追加 。 の中に デバイスを追加 ダイアログで、 SoftMotionドライブ→仮想ドライブ→SM_Drive_Virtual 端末。 クリック デバイスを追加 ボタン。 デバイスがデバイスツリーに追加されます。 デバイスをダブルクリックすると、対応するデバイスエディタが開きます。 " }, 
{ "title" : "無料のエンコーダ ", 
"url" : "_sm_drive_controller_free_encoder.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotionドライブ構成 \/ フリードライブユニットの挿入 \/ 無料のエンコーダ ", 
"snippet" : "使用 無料のエンコーダ I \/ Oまたはハードウェアに永続的に結合されていないエンコーダーを統合するため。 無料のエンコーダーを追加する デバイスツリーで、 SoftMotion 一般軸プール 。 コンテキストメニューで、をクリックします デバイスを追加 。 の中に デバイスを追加 ダイアログで、 SoftMotionドライブ→無料エンコーダー→SMC_FreeeEncoder 端末。 クリック デバイスを追加 ボタン。 デバイスがデバイスツリーに追加されます。 でエンコーダを開きます 編集者 。 設定をハードウェアに適合させ、ビット幅とスケーリングを設定します。 エンコーダの入力値をに割り当...", 
"body" : "使用 無料のエンコーダ I \/ Oまたはハードウェアに永続的に結合されていないエンコーダーを統合するため。 無料のエンコーダーを追加する デバイスツリーで、 SoftMotion 一般軸プール 。 コンテキストメニューで、をクリックします デバイスを追加 。 の中に デバイスを追加 ダイアログで、 SoftMotionドライブ→無料エンコーダー→SMC_FreeeEncoder 端末。 クリック デバイスを追加 ボタン。 デバイスがデバイスツリーに追加されます。 でエンコーダを開きます 編集者 。 設定をハードウェアに適合させ、ビット幅とスケーリングを設定します。 エンコーダの入力値をに割り当てます <FREE_ENCODER_AXIS>.diEncoderPosition 変数。これは、IECコードとして、または入力データのメモリをマッピングすることによって可能です。 フィールドバスの初期化中に、この入力によって無効な値が生成される可能性があります。使用できます b遅延アクティベーション input を使用して、有効な値が使用可能になるまで入力の評価を無効にします。 これで、エンコーダをドライブのように使用できます。 詳細については、以下を参照してください。 エンコーダ軸" }, 
{ "title" : "プログラムによる座標軸の作成 ", 
"url" : "_sm_programmatic_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotionドライブ構成 \/ フリードライブユニットの挿入 \/ プログラムによる座標軸の作成 ", 
"snippet" : "以下のフリードライブユニットもプログラムで作成できます。 軸 AXIS デバイスツリーに追加せずに仮想軸を作成します 詳細については、以下を参照してください。 仮想ドライブSMC_Logical_Axis デバイスツリーに追加せずに論理軸を作成します。 詳細については、以下を参照してください。 論理ドライブSMC_FreeEncoder デバイスツリーに追加せずにエンコーダ軸を作成します 詳細については、以下を参照してください。 無料のエンコーダ...", 
"body" : "以下のフリードライブユニットもプログラムで作成できます。 軸 AXIS デバイスツリーに追加せずに仮想軸を作成します 詳細については、以下を参照してください。 仮想ドライブSMC_Logical_Axis デバイスツリーに追加せずに論理軸を作成します。 詳細については、以下を参照してください。 論理ドライブSMC_FreeEncoder デバイスツリーに追加せずにエンコーダ軸を作成します 詳細については、以下を参照してください。 無料のエンコーダ" }, 
{ "title" : "対応ドライブ ", 
"url" : "_sm_drives_supported_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 対応ドライブ ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "対応ドライブ:EtherCAT ", 
"url" : "_sm_drives_supported_drives_ethercat.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 対応ドライブ \/ 対応ドライブ:EtherCAT ", 
"snippet" : "EtherCAT Beckhoff EL2521 Beckhoff EL5101 Beckhoff EL72x1 Beckhoff EL7031 Beckhoff EL7037 Beckhoff EL7041 Beckhoff EL7047 Beckhoff EP7041 Bonfiglioli iBMD Bosch Rexroth IndraDrive CoE Bosch Rexroth ctrlX DRIVE CoE Bosch Rexroth ctrlX DRIVE SoE CMZ BD CMZ LBD CMZ SBD Control Techniques Digitax Control...", 
"body" : "EtherCAT Beckhoff EL2521 Beckhoff EL5101 Beckhoff EL72x1 Beckhoff EL7031 Beckhoff EL7037 Beckhoff EL7041 Beckhoff EL7047 Beckhoff EP7041 Bonfiglioli iBMD Bosch Rexroth IndraDrive CoE Bosch Rexroth ctrlX DRIVE CoE Bosch Rexroth ctrlX DRIVE SoE CMZ BD CMZ LBD CMZ SBD Control Techniques Digitax Control Techniques Mentor Control Techniques Unidrive M Copley Accelnet Danfoss ISD 520 Delta ASDA A2 Delta ASDA A3 Delta ASDA B3 Delta R1-EC5621 Festo CMMP EtherCAT 汎用 CiA 402 ドライバ:を参照してください ジェネリック CiA402 アクシスのコンフィギュレーションGenerischer SoE Treiber (auch für mehrachsige Antriebe) Hitachi ADV series Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB H6 KEBA KeDrive D3 Kollmorgen AKD Kollmorgen AKD-N\/C Kollmorgen MKD-N\/C Kollmorgen AKD2G Kollmorgen KED Metronix ARS 2000-Serie Mitsubishi Melservo MR-J5 Mitsubishi Melservo MR-JET Omron G5 Panasonic MINAS A5B Panasonic MINAS A6B Panasonic MINAS A6 MultiDrive Parker compax3 Parker SBC Parker PSD Sanyo Denki RS2 Schneider Electric Lexium32 Schneider Electric Lexium32i Servotronix CDHD Stäubli uniVAL Stöber Posidrive Stöber SD6 Stöber SI6\/SC6 WEG SCA06 Yaskawa Sigma7 series " }, 
{ "title" : "対応ドライブ:CAN ", 
"url" : "_sm_drives_supported_drives_can.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 対応ドライブ \/ 対応ドライブ:CAN ", 
"snippet" : "できる Bonfiglioli iBMD CMZ BD CMZ SD CMZ LBD CMZ SBD Festo EMCA Festo CMMP 汎用 CiA 402 ドライバ:を参照してください ジェネリック CiA402 アクシスのコンフィギュレーションInfranor cd1-k Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB Stepless Technology Maxon EPOS4 Metronix ARS 2000-Serie Nanotec PD4C Schneider Electric Lexium05...", 
"body" : "できる Bonfiglioli iBMD CMZ BD CMZ SD CMZ LBD CMZ SBD Festo EMCA Festo CMMP 汎用 CiA 402 ドライバ:を参照してください ジェネリック CiA402 アクシスのコンフィギュレーションInfranor cd1-k Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB Stepless Technology Maxon EPOS4 Metronix ARS 2000-Serie Nanotec PD4C Schneider Electric Lexium05 Schneider Electric Lexium23 Schneider Electric Lexium28 Schneider Electric Lexium32 Schneider Electric Lexium32i Schneider Electric SD-3 " }, 
{ "title" : "ユースケース ", 
"url" : "_sm_f_use_cases_drive_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユースケース ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "標準的なユースケース ", 
"url" : "_sm_special_use_cases.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユースケース \/ 標準的なユースケース ", 
"snippet" : "The SM3_Basic ライブラリには、標準の設定\/実際の値のインターフェイスを介してドライブと対話しない上位の機能ブロックが含まれています。これらの機能ブロックは、コマンドを提供したり、インスタンスのパラメータを読み書きすることによってドライブの設定を変更したりします。 AXIS_REF_SM3 。...", 
"body" : "The SM3_Basic ライブラリには、標準の設定\/実際の値のインターフェイスを介してドライブと対話しない上位の機能ブロックが含まれています。これらの機能ブロックは、コマンドを提供したり、インスタンスのパラメータを読み書きすることによってドライブの設定を変更したりします。 AXIS_REF_SM3 。 " }, 
{ "title" : "ドライブの再初期化 ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_0e9f93f91e8d4c6dc0a8640e01d50c94", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユースケース \/ 標準的なユースケース \/ ドライブの再初期化 ", 
"snippet" : "実行時にドライブパラメータを変更した場合は、ドライブを再初期化する必要があります。例:ロータリードライブのスケーリング係数またはモジュロ周期を変更します。を呼び出して SMC3_ドライブを再起動 にライジングエッジがあるファンクションブロック Execute 入力、 wCommuncationState ドライブのパラメータがリセットされ、ドライブの完全な起動プロセスが繰り返されます。 再初期化は、軸が必要な状態に達するまで待機する必要があります SMC_COMSTATE_BASE_COM_INITIALIZATION 以上。そうしないと、エラーが出力されます SMC_RAG_ERROR_AX...", 
"body" : "実行時にドライブパラメータを変更した場合は、ドライブを再初期化する必要があります。例:ロータリードライブのスケーリング係数またはモジュロ周期を変更します。を呼び出して SMC3_ドライブを再起動 にライジングエッジがあるファンクションブロック Execute 入力、 wCommuncationState ドライブのパラメータがリセットされ、ドライブの完全な起動プロセスが繰り返されます。 再初期化は、軸が必要な状態に達するまで待機する必要があります SMC_COMSTATE_BASE_COM_INITIALIZATION 以上。そうしないと、エラーが出力されます SMC_RAG_ERROR_AXIS_NOT_INITIALIZED 。 下位フィールドバスの通信が中断された場合、明示的な再初期化はもはや必要ありません CODESYS SoftMotion バージョン 4.18.0.0 以降。軸は、フィールドバス通信が回復するとすぐに自動的に再初期化されます。バージョン 4.18.0.0 より前のバージョンでは、フィールドバスの通信が中断された後、明示的に次の呼び出しが行われていました SMC3_ReinitDrive 必要でした (エラー: SMC_DI_GENERAL_COMMUNICATION_ERROR ) フィールドバス通信が復元され次第。 以前の動作は、次のように設定することで復元できます。 AutoRestart の入力 SMC_AxisChangeSettings ファンクションブロックへ SMC_AXIS_AUTORESTART_MODE.OFF 。 " }, 
{ "title" : "ドライブのオンとオフを切り替える ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_bd45abb41e8d4c6dc0a8640e01589872", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユースケース \/ 標準的なユースケース \/ ドライブのオンとオフを切り替える ", 
"snippet" : "The bRegulatorOn と bDriveStart のパラメータ AXIS_REF_SM3 ファンクションブロックは、ドライブのパフォーマンスレベルと減速を制御します。アクセスは、 MC_Power ファンクションブロック。 出力ステージを解放するには、を設定する必要があります bRegulatorOn のパラメータ MC_Power ファンクションブロック。ドライブは、このプロセスの現在のステータスを bRegulatorRealState 出力。ドライブでサポートされている場合、 bRegulatorOn 移動中にリセットすると、すぐにトルクが無効になります。この場合、機能ブロッ...", 
"body" : "The bRegulatorOn と bDriveStart のパラメータ AXIS_REF_SM3 ファンクションブロックは、ドライブのパフォーマンスレベルと減速を制御します。アクセスは、 MC_Power ファンクションブロック。 出力ステージを解放するには、を設定する必要があります bRegulatorOn のパラメータ MC_Power ファンクションブロック。ドライブは、このプロセスの現在のステータスを bRegulatorRealState 出力。ドライブでサポートされている場合、 bRegulatorOn 移動中にリセットすると、すぐにトルクが無効になります。この場合、機能ブロックはエラーを報告し、軸を errorstop 州。 The bDriveStart 変数は、ドライブの移動を許可するかどうかを決定します。このパラメータの現在の状態は、 bDriveStartRealState 。 ドライブでサポートされている場合、 bDriveStart パラメータリセットは、モーション中に設定されたランプ（「QuickStop」）でドライブを減速します。その後、設定されている限り、ドライブは到達位置で停止します bRegulatorOn 。軸は stopping 「QuickStop」メカニズムがアクティブである限り状態（ bDriveStart input = FALSE）。ドライブが以前に機能ブロックによって移動されたことがある場合は、次のように表示されます CommandAborted 。これは、 MC_Stop エラーを報告し、軸をに設定する機能ブロック errorstop 州。 " }, 
{ "title" : "機械式ブレーキの取り扱い ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_6670a1571e8d4c6ec0a8640e01f5eecb", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユースケース \/ 標準的なユースケース \/ 機械式ブレーキの取り扱い ", 
"snippet" : "ドライブでサポートされている場合、 eBrakeControl 変数は、次の方法で設定またはリセットできます。 SMC3_BrakeControl ファンクションブロック。 3つの異なるモードが可能です。 SMC3_BrakeSetState SMC_BRAKE_AUTO ：ブレーキの状態はドライブによって制御されます。 SMC_BRAKE_OPEN ：ブレーキが開いています。 SMC_BRAKE_CLOSE ：ブレーキが閉まっています。 The bBrakeClosedRealState 変数はブレーキの現在のステータスを報告します。 の観点から SoftMotion 、制御、および機械式ブ...", 
"body" : "ドライブでサポートされている場合、 eBrakeControl 変数は、次の方法で設定またはリセットできます。 SMC3_BrakeControl ファンクションブロック。 3つの異なるモードが可能です。 SMC3_BrakeSetState SMC_BRAKE_AUTO ：ブレーキの状態はドライブによって制御されます。 SMC_BRAKE_OPEN ：ブレーキが開いています。 SMC_BRAKE_CLOSE ：ブレーキが閉まっています。 The bBrakeClosedRealState 変数はブレーキの現在のステータスを報告します。 の観点から SoftMotion 、制御、および機械式ブレーキの状態は、ドライブの状態や走行動作に依存しません。 " }, 
{ "title" : "コントローラーモードの変更 ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_959f85271e8d4c6ec0a8640e01ed4fcb", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユースケース \/ 標準的なユースケース \/ コントローラーモードの変更 ", 
"snippet" : "と SMC_コントローラモードを設定 ファンクションブロックでは、さまざまなコントローラーモードを切り替えることができます。 byControllerMode と byRealControllerMode からのパラメーター AXIS_REF_SM3 コントローラーの目的のモードと現在のモードを表します。 可能な値 SMC_nocontrol SoftMotion ドライブにサイクリックデータを送信しません。これにより、他の方法でドライブを制御することが可能になります。 SMC_torque トルク\/力制御 SMC_velocity 速度制御 SMC_position 、 位置制御 を書いた後...", 
"body" : "と SMC_コントローラモードを設定 ファンクションブロックでは、さまざまなコントローラーモードを切り替えることができます。 byControllerMode と byRealControllerMode からのパラメーター AXIS_REF_SM3 コントローラーの目的のモードと現在のモードを表します。 可能な値 SMC_nocontrol SoftMotion ドライブにサイクリックデータを送信しません。これにより、他の方法でドライブを制御することが可能になります。 SMC_torque トルク\/力制御 SMC_velocity 速度制御 SMC_position 、 位置制御 を書いた後 byControllerMode 変数では、現在のモードが目的のコントローラーモードと一致するまでチェックされます。 ファンクションブロックは、新しいモードがドライブによって確認されるまで設定値を計算します。ドライブが新しいモードを確認するとすぐに bDone 出力が設定され、 SMC_SetControllerMode 設定値を書き込まなくなりました。これは他のファンクションブロックを使って行わなければなりません。 例:ザ・ bDone 出力は、に接続されます。 Execute ファンクションブロックの入力 (例: MC_MoveVelocity 、 MC_MoveAbsolute 、または MC_Halt 。そうしないと、モードが変更された直後に軸が停止します。設定位置の計算にはデッドタイムが使用されることに注意してください。詳細については、以下を参照してください 実績値、設定値、デッドタイム。 " }, 
{ "title" : "ホーミング（ドライブ制御） ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_7fa66d251e8d4c6fc0a8640e00782f3b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユースケース \/ 標準的なユースケース \/ ホーミング（ドライブ制御） ", 
"snippet" : "の SoftMotion 、ドライブを参照する方法は2つあります。 PLC内のコントローラによる参照：この参照は、 SMC_Homing ファンクションブロック。基準信号は、コントロールユニットのI \/ Oマッピングの一部である必要があります。参照時、ドライブは制御モード「位置制御」のままです。一般に、この方法は、位置の検出（参照スイッチがアクティブになっているとき）がドライブによって取得された現在の位置に基づいているため、特に正確ではありません。その結果、精度は通信サイクルによって制限されます。 ドライブ内のコントローラーによる参照：参照スイッチはドライブに配線されています。その位置はより速...", 
"body" : "の SoftMotion 、ドライブを参照する方法は2つあります。 PLC内のコントローラによる参照：この参照は、 SMC_Homing ファンクションブロック。基準信号は、コントロールユニットのI \/ Oマッピングの一部である必要があります。参照時、ドライブは制御モード「位置制御」のままです。一般に、この方法は、位置の検出（参照スイッチがアクティブになっているとき）がドライブによって取得された現在の位置に基づいているため、特に正確ではありません。その結果、精度は通信サイクルによって制限されます。 ドライブ内のコントローラーによる参照：参照スイッチはドライブに配線されています。その位置はより速く、より正確に検出されます。ドライブ制御の基準経路の間、ドライブは別の制御モードにあり、ドライブは内部プロセスによって制御され、コントロールユニットの設定値に従わない。参照パスが終了すると、ドライブは元の制御モードにリセットされます。 The MC_Home 機能ブロックは、以下を設定することにより、ドライブ制御の基準経路を開始します。 fReference と bStartReference 。また、 AXIS_REF_SM3 （（ wState ） に設定されています homing 。ドライブが参照パスを通過すると（つまり、コントロールユニットによって指定された値に従わなくなると）、ドライブはパラメータを次のように設定します。 TRUE 。参照パスの終わりを表示するために、ドライバーは次の値を設定します。 bStartReference と bStartReferenceRealState に FALSE 。 " }, 
{ "title" : "ラッチング ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_index_14", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユースケース \/ 標準的なユースケース \/ ラッチング ", 
"snippet" : "ドライブがサポートするドライブ機能に応じて、さまざまな方法で軸の位置を検出できます。 ドライブは軸位置自体を検出します（統合されているか、外部センサーをオンにすることによって）。実際の位置はドライブ自体によって転送されるため、信号の転送時間は最小限で正確です。 軸の現在の位置は、ドライブとは独立して決定され、入力を介してコントローラに転送されます。コントローラ入力のレイテンシとアプリケーションサイクルが発生すると、この方法の精度が低下します。 ドライブ自体の位置が転送されると、通常はメーカーに応じてそれぞれのドライバーによってアプリケーションで直接処理されます。この種の軸の位置を決定するには、...", 
"body" : "ドライブがサポートするドライブ機能に応じて、さまざまな方法で軸の位置を検出できます。 ドライブは軸位置自体を検出します（統合されているか、外部センサーをオンにすることによって）。実際の位置はドライブ自体によって転送されるため、信号の転送時間は最小限で正確です。 軸の現在の位置は、ドライブとは独立して決定され、入力を介してコントローラに転送されます。コントローラ入力のレイテンシとアプリケーションサイクルが発生すると、この方法の精度が低下します。 ドライブ自体の位置が転送されると、通常はメーカーに応じてそれぞれのドライバーによってアプリケーションで直接処理されます。この種の軸の位置を決定するには、 MC_TouchProbe ファンクションブロック。これにより、軸の位置を構成可能なトリガーに、位置ウィンドウ内で記録できます。位置がドライブによって転送されない場合は、たとえば制御のために、ドライブのデバイスドライバに渡す必要があります。 詳細については、次を参照してください。 SM_Drive_PosControlを使用したコントローラーの位置制御" }, 
{ "title" : "軸位置の永続化 ", 
"url" : "_sm_storing_axis_position_persistently.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユースケース \/ 軸位置の永続化 ", 
"snippet" : "アブソリュートエンコーダーを備えた軸は、位置を保存して、コントローラーを再起動した後も前の位置を維持できます。ホーミングは不要です。は SMC3_PersistPosition そして SMC3_PersistPositionLogical ファンクションブロックは保存操作のための機能を提供します。必要なデータはに保存されます。 SMC3_PersistPosition_Data そして SMC3_PersistPositionLogical_Data 。 ザル bPositionStored 出力は、次の内容かどうかを示します。 PersistentData 変更されました。これはパーシステ...", 
"body" : "アブソリュートエンコーダーを備えた軸は、位置を保存して、コントローラーを再起動した後も前の位置を維持できます。ホーミングは不要です。は SMC3_PersistPosition そして SMC3_PersistPositionLogical ファンクションブロックは保存操作のための機能を提供します。必要なデータはに保存されます。 SMC3_PersistPosition_Data そして SMC3_PersistPositionLogical_Data 。 ザル bPositionStored 出力は、次の内容かどうかを示します。 PersistentData 変更されました。これはパーシステンスのタイプによって異なるタイミングで発生します エンコーダによって保持される値の範囲は、以下で設定する必要があります。 SMC_PersistPosition.maxPersistedValue 入力。マルチターンエンコーダの場合、値は次のように設定されます 16#FFFFFFFFFF 。たとえば、12 ビットのシングルターンエンコーダの場合、値は 2^12 = 4096 に設定されます 詳細については、以下を参照してください。 データの永続性 インスタンスは、次のような宣言によって永続化されます。 VAR_PERSISTENT またはApplicationComposerのPersistenceManager。 論理軸の軸位置を永続化する 要件：軸は論理的です。 を使う SMC3_パーシスト・ポジション (ロジカル) 論理軸の位置を固定するためのファンクションブロック。これは、上位の物理軸の位置が固定されている場合にのみ機能します。これらの FB を使用して仮想軸の位置を固定することはできません のインスタンスを作成する SMC3_PersistPositionLogical 軸のファンクションブロック。 ppl: SM3_BASIC.SMC3_PersistPositionLogical; の永続データ構造をインスタンス化します SMC3_PersistPositionLogical_Data タイプ。 ppl_Data: SMC3_PersistPositionLogical_Data; モーションタスクのプログラムを拡張して、 SMC3_PersistPositionLogical インスタンスが実装され、タイプの永続データ SMC3_PersistPositionLogical_Data それに渡されます。 " }, 
{ "title" : "マルチターンアブソリュートエンコーダの軸位置を物理軸で永続化 ", 
"url" : "_sm_storing_axis_position_persistently.html#UUID-71a9dfd2-c008-608a-c739-86d0c80e041d_id_f83d9cd75f3d951cc0a8640e00a495cd_id_49c53944c3ac11e3ae6789f982afc4cc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユースケース \/ 軸位置の永続化 \/ マルチターンアブソリュートエンコーダの軸位置を物理軸で永続化 ", 
"snippet" : "要件：軸にはマルチターンアブソリュートエンコーダがあります。 使用 SMC3_PersistPosition 物理軸の位置を永続化するためのFB。それぞれのプログラムはモーションタスクで実行されます。 のインスタンスを作成する SMC3_PersistPosition 軸のファンクションブロック。 pp: SM3_BASIC.SMC3_PersistPosition; の永続データ構造をインスタンス化します SMC3_PersistPosition_Data タイプ。 pp_Data: SM3_BASIC.SMC3_PersistPosition_Data1; モーションタスクのプログラムを拡...", 
"body" : "要件：軸にはマルチターンアブソリュートエンコーダがあります。 使用 SMC3_PersistPosition 物理軸の位置を永続化するためのFB。それぞれのプログラムはモーションタスクで実行されます。 のインスタンスを作成する SMC3_PersistPosition 軸のファンクションブロック。 pp: SM3_BASIC.SMC3_PersistPosition; の永続データ構造をインスタンス化します SMC3_PersistPosition_Data タイプ。 pp_Data: SM3_BASIC.SMC3_PersistPosition_Data1; モーションタスクのプログラムを拡張して、 SMC3_PersistPosition インスタンスはそこで実装されます。 CFCに実装された呼び出し： 機能ブロックは、モーションタスクと周期的に呼び出されます。 The SMC3_PersistPosition インスタンスは、起動操作中に保存された位置の復元を実行します。通常の操作では、FBはそれぞれのデータ構造に実際の位置を保存します。 " }, 
{ "title" : "物理軸によるシングルターンアブソリュートエンコーダの軸位置の持続 ", 
"url" : "_sm_storing_axis_position_persistently.html#UUID-71a9dfd2-c008-608a-c739-86d0c80e041d_id_f83d9cd75f3d951cc0a8640e00a495cd_id_a4cc9967c3ac11e3ae6789f982afc4cc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユースケース \/ 軸位置の永続化 \/ 物理軸によるシングルターンアブソリュートエンコーダの軸位置の持続 ", 
"snippet" : "要件：物理軸にはシングルターンアブソリュートエンコーダがあります。 を使う SMC3_パーシスト・ポジション 軸の位置を固定するためのファンクションブロック。それぞれのプログラムはモーションタスクで実行されます。位置が正しく表示されるのは、軸がまったく移動していない場合、またはコントローラーのスイッチをオフにしてからオンにするまでの距離が短い場合 (1 回転距離の最大半分) の場合に限られます。たとえば、機械式ブレーキを使用してこれを行うことができます。コントローラーのスイッチを切ったときに軸が大きく動くと、誤った位置になります。FBでは確認できません のインスタンスを作成する SMC3_Pe...", 
"body" : "要件：物理軸にはシングルターンアブソリュートエンコーダがあります。 を使う SMC3_パーシスト・ポジション 軸の位置を固定するためのファンクションブロック。それぞれのプログラムはモーションタスクで実行されます。位置が正しく表示されるのは、軸がまったく移動していない場合、またはコントローラーのスイッチをオフにしてからオンにするまでの距離が短い場合 (1 回転距離の最大半分) の場合に限られます。たとえば、機械式ブレーキを使用してこれを行うことができます。コントローラーのスイッチを切ったときに軸が大きく動くと、誤った位置になります。FBでは確認できません のインスタンスを作成する SMC3_PersistPosition 軸のファンクションブロック。 ppst_X: SM3_BASIC.SMC3_PersistPositionSinglturn; の永続データ構造をインスタンス化します SMC3_PersistPosition_Data タイプ。 ppst_Data_X: SMC3_PersistPositionSingleturn_Data; モーションタスクのプログラムを拡張して、次の呼び出しを行うようにする SMC3_PersistPosition インスタンスが実装され、の永続データ構造が実装されました。 SMC_PersistPosition_Data タイプが渡されます。 " }, 
{ "title" : "モジュロ軸の初期位置検出 ", 
"url" : "_sm_initial_positioning_of_a_rotary_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユースケース \/ モジュロ軸の初期位置検出 ", 
"snippet" : "ドライブまたはエンコーダーの実際の位置は、DWORDとしてコントローラーに送信されます。 モジュロ軸の場合、周期Pは、モジュロ値とスケーリングによって増分で定義されます。期間Pは、ローテーションの正確な増分数を指定します。これは、位置値X、X + 1 * P、X + 2 * Pなどが同じ物理位置を表すことを意味します。 nが十分に大きい場合、位置X + n * PはDWORDの制限を超えます。これは位置0x100 00 00 00で発生します。次に、先頭の場所が切り取られ、値はで始まります。 0 。 Pがの要因でない場合 0x1 00 00 00 00 、その場合、位置Xは、中断の前後で同じ物...", 
"body" : "ドライブまたはエンコーダーの実際の位置は、DWORDとしてコントローラーに送信されます。 モジュロ軸の場合、周期Pは、モジュロ値とスケーリングによって増分で定義されます。期間Pは、ローテーションの正確な増分数を指定します。これは、位置値X、X + 1 * P、X + 2 * Pなどが同じ物理位置を表すことを意味します。 nが十分に大きい場合、位置X + n * PはDWORDの制限を超えます。これは位置0x100 00 00 00で発生します。次に、先頭の場所が切り取られ、値はで始まります。 0 。 Pがの要因でない場合 0x1 00 00 00 00 、その場合、位置Xは、中断の前後で同じ物理的位置を表すことはなくなります。 周期が係数にならないようにギア比が設定されている場合 0x1 0000 0000 、次に回転軸の位置をアクティブ化後に移動できます。 例 軸は位置から始まります 0x0 。 0°です。 1周期は360°です。スケーリングは、これが対応するように選択されます 3600000 = 0x36 EE80 増分。 1193回転後、軸はで停止します 0xFFFD 7280=1193*3600000 。さらに完全に回転すると、軸はその位置に到達します 0x10034 6100 。中断時に、先頭の1がカットされ、位置が 0x34 6100 形成されます。軸を元の位置に戻すと 0x0 、次に軸は位置16.7296°で停止します。したがって、位置 0x0 実際の中断に応じて、0°、16.7296°などの位置に対応します。 上記の効果が発生するようにスケーリングを選択し、プログラムの開始時にホーミングが不可能または必要でない場合は、を使用して最後の非アクティブ化の前の位置を回復できます。 SMC3_PersistPosition ファンクションブロック。ここでは絶対値エンコーダーを使用します。 " }, 
{ "title" : "CiA402 軸 ", 
"url" : "_sm_cia402_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ CiA402 軸 ", 
"snippet" : "詳細については、「」を参照してください。 追加...", 
"body" : "詳細については、「」を参照してください。 追加 " }, 
{ "title" : "ジェネリック CiA402 アクシスのコンフィギュレーション ", 
"url" : "_sm_drives_generic_cia402_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ CiA402 軸 \/ ジェネリック CiA402 アクシスのコンフィギュレーション ", 
"snippet" : "CODESYS SoftMotion さまざまなドライブ用のドライバが用意されています。使用している CiA402 ドライブに特定のドライバがない場合は、汎用 CiA402 軸を使用できます ただし、汎用軸の互換性と動作は、それぞれのドライブの CiA402 実装に大きく依存します。実際には、特にエラー処理とリミットスイッチのサポートに関して、メーカーによってCiA402規格の解釈が異なることが示されています そのため、一般的なCiA402軸が特定のドライブで常に正しく、または完全に機能することを保証することはできません。 ドライブのデバイス記述で数値が指定されていない場合、汎用 CiA402...", 
"body" : "CODESYS SoftMotion さまざまなドライブ用のドライバが用意されています。使用している CiA402 ドライブに特定のドライバがない場合は、汎用 CiA402 軸を使用できます ただし、汎用軸の互換性と動作は、それぞれのドライブの CiA402 実装に大きく依存します。実際には、特にエラー処理とリミットスイッチのサポートに関して、メーカーによってCiA402規格の解釈が異なることが示されています そのため、一般的なCiA402軸が特定のドライブで常に正しく、または完全に機能することを保証することはできません。 ドライブのデバイス記述で数値が指定されていない場合、汎用 CiA402 ドライバーは最大 8 軸をサポートします。それ以外の場合は、デバイスの説明で定義された軸数がサポートされます。 CANopen : 可能な軸の数は、EDS ファイル内の論理デバイスのプロファイルによって異なります ( 1000H オブジェクトと 67FFH + X * 800H 、 どこ X = 論理デバイスの数)。詳細については、CANopen CiA301 規格を参照してください。 EtherCAT : 可能な軸の数は、ESI ファイルで定義された CiA402 チャネル (CoE DS402Channels) によって異なります。 EDS または ESI ファイルの調整は、デバイスの製造元が行う必要があります。 " }, 
{ "title" : "試運転時に使用されるオブジェクト ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e06c925bc32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ CiA402 軸 \/ ジェネリック CiA402 アクシスのコンフィギュレーション \/ 試運転時に使用されるオブジェクト ", 
"snippet" : "試運転時に、デバイスでサポートされている場合は、次のオブジェクトにアクセスします。 物体 読み取り\/書き込みアクセス (M) 必須 (O) 任意 コメント 0x1000:0 読んだ M 下限値は402である必要があります。それ以外の場合はキャンセルします。 0x1018:1 読んだ O 0x1018:2 読んだ O 0x1018:3 読んだ O 0x1018:4 読んだ O 0x6502:0 読んだ O 0x605A:0 読んだ O 0x60C2:1 書く パラメータの場合 Set60C2 = TRUE 0x60C2:2 書く パラメータの場合 Set60C2 = TRUE 0x6076:0 ...", 
"body" : "試運転時に、デバイスでサポートされている場合は、次のオブジェクトにアクセスします。 物体 読み取り\/書き込みアクセス (M) 必須 (O) 任意 コメント 0x1000:0 読んだ M 下限値は402である必要があります。それ以外の場合はキャンセルします。 0x1018:1 読んだ O 0x1018:2 読んだ O 0x1018:3 読んだ O 0x1018:4 読んだ O 0x6502:0 読んだ O 0x605A:0 読んだ O 0x60C2:1 書く パラメータの場合 Set60C2 = TRUE 0x60C2:2 書く パラメータの場合 Set60C2 = TRUE 0x6076:0 読んだ O " }, 
{ "title" : "操作中に使用されるオブジェクト ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e7dfc492c32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ CiA402 軸 \/ ジェネリック CiA402 アクシスのコンフィギュレーション \/ 操作中に使用されるオブジェクト ", 
"snippet" : "使用する機能に応じて、操作中に次のオブジェクトが使用されます。 0x603F:00 、 0x6040:00 、 0x6041:00 、 0x6060:00 、 0x6061:00 、 0x6062:00 、 0x6064:00 、 0x606B:00 、 0x606C:00 、 0x6074:00 、 0x6077:00 、 0x6078:00 、 0x607C:00 、 0x60B1:00 、 0x60B2:00, 0x60B8:00 0x60B9:00 、 0x60BA:00 、 0x60BB:00 、 0x60BC:00 、 0x60BD:00 、 0x60F4:00 ....", 
"body" : "使用する機能に応じて、操作中に次のオブジェクトが使用されます。 0x603F:00 、 0x6040:00 、 0x6041:00 、 0x6060:00 、 0x6061:00 、 0x6062:00 、 0x6064:00 、 0x606B:00 、 0x606C:00 、 0x6074:00 、 0x6077:00 、 0x6078:00 、 0x607C:00 、 0x60B1:00 、 0x60B2:00, 0x60B8:00 0x60B9:00 、 0x60BA:00 、 0x60BB:00 、 0x60BC:00 、 0x60BD:00 、 0x60F4:00 . " }, 
{ "title" : "高度な構成 ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e7e012b4c32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ CiA402 軸 \/ ジェネリック CiA402 アクシスのコンフィギュレーション \/ 高度な構成 ", 
"snippet" : "を選択する必要があります。 汎用デバイス構成エディターを表示する のオプション オプション – デバイスエディター ダイアログが表示され、パラメータを含むタブが表示されます。 次のパラメータを使用して、CiA402ステートチャートのフローを微調整できます。 CiA402パラメータ 説明 _readVelocityFactor_6096 TRUE : 速度係数 (オブジェクト) 6096 ) が読み込まれ、速度単位の変換に使用されます。 FALSE : 速度係数は読み込まれません。速度単位は 1 秒あたりのインクリメントと仮定されます _bImmediateDisabling TRUE ： いつ...", 
"body" : "を選択する必要があります。 汎用デバイス構成エディターを表示する のオプション オプション – デバイスエディター ダイアログが表示され、パラメータを含むタブが表示されます。 次のパラメータを使用して、CiA402ステートチャートのフローを微調整できます。 CiA402パラメータ 説明 _readVelocityFactor_6096 TRUE : 速度係数 (オブジェクト) 6096 ) が読み込まれ、速度単位の変換に使用されます。 FALSE : 速度係数は読み込まれません。速度単位は 1 秒あたりのインクリメントと仮定されます _bImmediateDisabling TRUE ： いつ bRegulator にリセットされます FALSE 、ドライブのステータスを から切り替えます。 Operation enabled 直接に Switch on disabled 。 FALSE : 「スイッチオン」と「スイッチオン準備完了」を介してステータスを切り替え、ドライブにクイックストップを実行してブレーキを適切に処理する機会を与えます。 注: このオプションが FALSE 、その後、即時無効化がオフに切り替えられる状態は、ビットマスクで微調整できます _dwStatesImmediateDisabling . _bForbidReenableDuringDisabling 次の場合にのみ関連 _bImmediateDisabling = FALSE . TRUE : ドライブの信号が入力されるまで、ドライブは段階的に無効化されます。 Ready to switch on 新しい enable コマンドが処理される前。 dwStatesImmediateDisabling 次の場合にのみ関連 _bImmediateDisabling = FALSE . 即時無効化がオンになっている状態のビット マスク。 ビット 0: 通常動作 ビット 1: クイックストップ ビット 2: 外部クイックストップ ビット 3: ホーミング 例: 仮定 _bImmediateDisabling = FALSE 、 値 2#0110 状態「通常動作」および「ホーミング」に対してのみ、即時無効化がオフになることを意味します。 「Quickstop」および「External Quickstop」の状態では、即時無効化がオンになります。 _uiPreHomingWait ステートマシンがその状態で待機するサイクル数 PRE_HOMING ビットを設定して原点復帰プロセスを開始する前に 4 コントロールワードの。 _uiPostHomingWait ステート マシンがとどまるサイクル数 HOMING_DONE 「通常運用」に戻す前に。 _uiHomingMinCycles 開始時のサイクル数 HOMING 「完了した」ビットが無視された場合。 _uiWaitCyclesForStateSwitch ドライブが状態変更コマンドを実行するまでシステムが待機するサイクル数。ドライブに障害が発生した場合、システムは次の状態に戻ります。 SWITCH_ON_DISABLED 。 _bPreHomingWaitBit12Clear TRUE : お待ちください PRE_HOMING ステータス ワードのビット 12 がドライブによってクリアされるまで、ホーミングを開始する前に (コントロール ワードのビット 4 を設定する前に)。 いずれにせよ、ステート マシンはそのままであることに注意してください。 PRE_HOMING 少なくとも _uiPreHomingCycles . _bCheckBit10PostHoming TRUE ：ビット12とビット10が TRUE 、 そうして HOMING_DONE 状態がアクティブになります。 開始時のサイクル数 HOMING ここで、完了ビット (ステータス ワードのビット 10\/12) は無視されます。 _bCheckOpMode TRUE : チェックしてください 0x6061 に設定されている値を示します 0x6060 軸を有効にするとき。 FALSE ：チェックを省略し、動作モード設定直後に有効にしてください。 _abyControllerMode これ ARRAY[0..7] OF BYTE 動作モード (オブジェクト 0x6060 ) に対応します AXIS_REF_SM3.byOperationMode 。 （索引 0,3 = 位置;索引 1 = 速度;索引 2 =トルク) _bCheckBit12InPositionMode TRUE : AxisIsReadyForMotion CSP または IP のビット 12 をチェックします。 FALSE : AxisIsReadyForMotion ビット 12 はチェックしません。 _bDoHaltWhenStopInterruptsHome TRUE ： いつ MC_Stop 制御ワードのビット 8 でホーミングを中止します。 FALSE : ビット 8 を設定せず、直接動作モードを切り替えてください。 _bCheckBit13InHomingMode TRUE ： の HOMING_ACTIVE 、 wStatusWord.13 = TRUE エラー停止につながり、 wControlWord.8 := TRUE （応じて _bDoHaltWhenStopInterruptsHome ） _bSetControlBit4InCSP TRUE ：ステータスワードのビット4もCSPモードに設定します。標準ではありませんが、一部のドライブではこれが必要です。 _uiHomingWaitListeningBits101213 状態で HOMING_ACTIVE 、ビット 4 の設定からのこのサイクル数の間、ビット 10、12、および 13 をリッスンしません (一部のドライブでは、これらのビットをリセットするのに時間がかかります)。 _bRegulatorOnRequiresVoltageEnabled ステータス ワードのビット 4 (電圧有効) が必要かどうか TRUE となることによって bRegulatorRealState = TRUE (デフォルト値: FALSE ）。 _bDriveStartRequiresOperationEnabled ステータスワード（動作可能）のビット 2 が必要かどうか TRUE となることによって bDriveStartRealState = TRUE (デフォルト値: TRUE ）。 _modeOfOperation_Torque ザル ModeOfOperation コントローラーモードで使用します。 torque 。サイクリック同期トルクモードのように動作する必要があります _modeOfOperation_Velocity ザル ModeOfOperation コントローラーモードで使用します。 velocity 。サイクリック同期ベロシティモードのように動作する必要があります _modeOfOperation_Position ザル ModeOfOperation コントローラーモードで使用します。 position 。サイクリック・シンク・ポジション・モードのように動作する必要があります _bStayInSwitchOnDisabled FALSE : からの自動移行 SWITCH_ON_DISABLED へ READY_TO_SWITCH_ON が実行されます (次のいずれかに該当する場合) MC_Power.bDriveStart は TRUE またはクイックストップオプションコード ( object 0x605A:00 ) は 4 より大きい。 TRUE: からの移行 SWITCH_ON_DISABLED へ READY_TO_SWITCH_ON は次の場合のみ実行されます MC_Power.bRegulatorOn は TRUE 。 " }, 
{ "title" : "タッチプローブ ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_section-idm235087437140543", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ CiA402 軸 \/ ジェネリック CiA402 アクシスのコンフィギュレーション \/ タッチプローブ ", 
"snippet" : "ザ・ MC_TouchProbe ファンクションブロックには以下が必要です。 TRIGGER_REF 入力として。 TRIGGER_REF.iTriggerNumber ジェネリック CIA402 軸には次のような意味があります。 トリガー_REF.I トリガー番号 意味 0 タッチプローブ 1、ポジティブエッジ 1 タッチプローブ 1、マイナスエッジ 2 タッチプローブ 2、ポジティブエッジ 3 タッチプローブ 2、マイナスエッジ...", 
"body" : "ザ・ MC_TouchProbe ファンクションブロックには以下が必要です。 TRIGGER_REF 入力として。 TRIGGER_REF.iTriggerNumber ジェネリック CIA402 軸には次のような意味があります。 トリガー_REF.I トリガー番号 意味 0 タッチプローブ 1、ポジティブエッジ 1 タッチプローブ 1、マイナスエッジ 2 タッチプローブ 2、ポジティブエッジ 3 タッチプローブ 2、マイナスエッジ " }, 
{ "title" : "エラー診断:ドライブを経由して電源を入れることはできません MC_Power ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_section-idm235087440495495", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ CiA402 軸 \/ ジェネリック CiA402 アクシスのコンフィギュレーション \/ エラー診断:ドライブを経由して電源を入れることはできません MC_Power ", 
"snippet" : "汎用軸は、ステータスワードに次のビットが戻ってくることを想定しています。 MC_Power.Status = TRUE : ビット 0 (スイッチオン準備完了) ビット 1 (スイッチオン) ビット 2 (操作有効) ビット 5 (クイックストップ) ビット 12 ただし、ビット 12 はすべてのドライブで設定されるわけではありません。ドライブがビットを設定しない場合、 _bCheckBit12InPositionMode 汎用軸のパラメータは次のように設定できます。 FALSE 。...", 
"body" : "汎用軸は、ステータスワードに次のビットが戻ってくることを想定しています。 MC_Power.Status = TRUE : ビット 0 (スイッチオン準備完了) ビット 1 (スイッチオン) ビット 2 (操作有効) ビット 5 (クイックストップ) ビット 12 ただし、ビット 12 はすべてのドライブで設定されるわけではありません。ドライブがビットを設定しない場合、 _bCheckBit12InPositionMode 汎用軸のパラメータは次のように設定できます。 FALSE 。 " }, 
{ "title" : "タッチプローブ ", 
"url" : "_sm_touch_probe.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ CiA402 軸 \/ タッチプローブ ", 
"snippet" : "CiA402プロファイルのドライブは、タッチプローブソースの選択をサポートしている場合があります。を使用してソースを設定することはできません。 MC_TouchProbe ファンクションブロック。デフォルトでは、タッチプローブのデジタル入力が使用されます ソースの変更: タッチプローブオブジェクトの手動書き込み 0x60B8 これを行うには、に電話する必要があります MC_WriteParameter ファンクションブロックと ParameterNumber = 10184 。これは CiA 402 オブジェクトに対応します 0x60B8 。 出力の場合 MC_WriteParameter.D...", 
"body" : "CiA402プロファイルのドライブは、タッチプローブソースの選択をサポートしている場合があります。を使用してソースを設定することはできません。 MC_TouchProbe ファンクションブロック。デフォルトでは、タッチプローブのデジタル入力が使用されます ソースの変更: タッチプローブオブジェクトの手動書き込み 0x60B8 これを行うには、に電話する必要があります MC_WriteParameter ファンクションブロックと ParameterNumber = 10184 。これは CiA 402 オブジェクトに対応します 0x60B8 。 出力の場合 MC_WriteParameter.Done = TRUE そうすると、以下のようにコマンドを実行できます。 MC_TouchProbe 通常どおりのファンクションブロック。 オブジェクトからのビットのみ 0x60B8 以下のように定義できるセットです。 MC_TouchProbe (以下で示されます: )。残りのビットはステップ 1 の値を保持します (以下を参照) ): オブジェクトのビット数 0x60B8 タッチプローブ 2 タッチプローブ 1 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 オブジェクト 0x60D0 に関する注意 タッチプローブオブジェクト内 0x60B8 、ソースを指定してオブジェクト経由で解決できます。 0x60D0 。これはビットの組み合わせに対応します 10 b ビット用 3 、 2 または 11 、 10 オブジェクトの 0x60B8 。この場合は、オブジェクトを書く必要があります。 0x60D0 実行する前に MC_TouchProbe 。そのためには、以下を使用する必要があります MC_WriteParameter ファンクションブロック。このブロックには、 ParameterNumber を使用して計算されます。 SMC_ParameterNumber_CoE 関数。 " }, 
{ "title" : "実績値、設定値、デッドタイム ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 実績値、設定値、デッドタイム ", 
"snippet" : "このページでは、実際の値と設定値がいつ送受信され、デッドタイムとどのように関連しているのかという質問に答えます。わかりやすくするために位置に焦点を当てていますが、速度やトルクなどの他の値についても同じことが言えます。また、EtherCATにも重点を置いています。動作は他のフィールドバスでも同様です。(ここでは、デフォルトおよび推奨構成を想定していることに注意してください FrameAtTaskStart = TRUE .)...", 
"body" : "このページでは、実際の値と設定値がいつ送受信され、デッドタイムとどのように関連しているのかという質問に答えます。わかりやすくするために位置に焦点を当てていますが、速度やトルクなどの他の値についても同じことが言えます。また、EtherCATにも重点を置いています。動作は他のフィールドバスでも同様です。(ここでは、デフォルトおよび推奨構成を想定していることに注意してください FrameAtTaskStart = TRUE .) " }, 
{ "title" : "実際の金額はいつ届きますか？ ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054861776368", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 実績値、設定値、デッドタイム \/ 実際の金額はいつ届きますか？ ", 
"snippet" : "The actual position ( <DriveA>.fActPosition ) is received at the beginning of the current bus task cycle. It is the actual position of the drive at the time of the previous EtherCAT SYNC event. バスタスクサイクル i では、前のバスタスクサイクル i-1 で送信された EtherCAT フレームが受信されます。このフレームには、SYNC イベント i-2 でドライブがラッチした実際の位置が含まれます...", 
"body" : "The actual position ( <DriveA>.fActPosition ) is received at the beginning of the current bus task cycle. It is the actual position of the drive at the time of the previous EtherCAT SYNC event. バスタスクサイクル i では、前のバスタスクサイクル i-1 で送信された EtherCAT フレームが受信されます。このフレームには、SYNC イベント i-2 でドライブがラッチした実際の位置が含まれます " }, 
{ "title" : "設定値はいつ送信されますか？ ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862001312", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 実績値、設定値、デッドタイム \/ 設定値はいつ送信されますか？ ", 
"snippet" : "現在のバスタスクサイクル i で計算された設定値は、次のバスタスクサイクル i+1 でドライブに送信され、SYNC イベント i+1 でドライブによって適用されます。上の図を参照してください。...", 
"body" : "現在のバスタスクサイクル i で計算された設定値は、次のバスタスクサイクル i+1 でドライブに送信され、SYNC イベント i+1 でドライブによって適用されます。上の図を参照してください。 " }, 
{ "title" : "デッドタイムとは何か、どのように推定され、どのように使用されるのか？ ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862210917", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 実績値、設定値、デッドタイム \/ デッドタイムとは何か、どのように推定され、どのように使用されるのか？ ", 
"snippet" : "一般に、デッドタイムは、ドライブがある位置に到達した時点でアクションを実行する必要がある場合に重要です。特定の時間におけるドライブ位置を正確に決定するには、デッドタイムも重要です。例としては、接着剤を高速で塗布したり、PLCに高精度のデジタル入力を接続してPLCでタッチプローブを実行したりすることが挙げられます。...", 
"body" : "一般に、デッドタイムは、ドライブがある位置に到達した時点でアクションを実行する必要がある場合に重要です。特定の時間におけるドライブ位置を正確に決定するには、デッドタイムも重要です。例としては、接着剤を高速で塗布したり、PLCに高精度のデジタル入力を接続してPLCでタッチプローブを実行したりすることが挙げられます。 " }, 
{ "title" : "デッドタイムの定義 ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862962511", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 実績値、設定値、デッドタイム \/ デッドタイムとは何か、どのように推定され、どのように使用されるのか？ \/ デッドタイムの定義 ", 
"snippet" : "デッドタイムは、ドライブがPLCによって送信された設定位置に実際に到達するまでにかかる時間です。つまり、その間のタイムラグです fActPosition と fSetPosition 、現在のバスタスクサイクルの開始時。デッドタイムは一般的なドライブエディタ () で設定できます タブ：一般) または MC_WRITE パラメータ パラメータ番号 1070 のファンクションブロック ( fSetActTimeLagCycles )。 デッドタイムは次の時間の合計です。 設定した位置をドライブに送信するのにかかる時間 ドライブコントローラが設定位置に到達するまでの時間 ドライブから実際の位置を受...", 
"body" : "デッドタイムは、ドライブがPLCによって送信された設定位置に実際に到達するまでにかかる時間です。つまり、その間のタイムラグです fActPosition と fSetPosition 、現在のバスタスクサイクルの開始時。デッドタイムは一般的なドライブエディタ () で設定できます タブ：一般) または MC_WRITE パラメータ パラメータ番号 1070 のファンクションブロック ( fSetActTimeLagCycles )。 デッドタイムは次の時間の合計です。 設定した位置をドライブに送信するのにかかる時間 ドライブコントローラが設定位置に到達するまでの時間 ドライブから実際の位置を受け取るまでにかかる時間 " }, 
{ "title" : "デッドタイムの推定 ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054864599382", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 実績値、設定値、デッドタイム \/ デッドタイムとは何か、どのように推定され、どのように使用されるのか？ \/ デッドタイムの推定 ", 
"snippet" : "デッドタイムは、以下を使用して推定できます。 SMC_デッドタイムの見積もり ファンクションブロック。ドライブは一定の速度で移動し、複数のデッドタイム測定値の中央値または平均値を使用する必要があります または、トレースエディターを使用してデッドタイムを推定することもできます。詳細については、以下を参照してください システムのデッドタイムの決定...", 
"body" : "デッドタイムは、以下を使用して推定できます。 SMC_デッドタイムの見積もり ファンクションブロック。ドライブは一定の速度で移動し、複数のデッドタイム測定値の中央値または平均値を使用する必要があります または、トレースエディターを使用してデッドタイムを推定することもできます。詳細については、以下を参照してください システムのデッドタイムの決定" }, 
{ "title" : "デッドタイムの使用 ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054865995483", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 実績値、設定値、デッドタイム \/ デッドタイムとは何か、どのように推定され、どのように使用されるのか？ \/ デッドタイムの使用 ", 
"snippet" : "デッドタイムは次の機能で使用されます。これらの関数のいずれかを使用していて、高い精度が必要な場合は、必ずデッドタイムを決定して設定してください。 コントローラーモードをコントローラーモードに切り替えるとき SMC_position 詳細については、以下を参照してください。 標準的なユースケースコントローラーモードで SMC_velocity 実際の位置と設定された速度から設定位置を計算します。 コントローラーモードで SMC_torque 実際の位置と実際の速度から設定位置を計算します。 ソフトウェアポジションラグモニタリングがオンになっている場合 で SMC_GetTravelTime 入力...", 
"body" : "デッドタイムは次の機能で使用されます。これらの関数のいずれかを使用していて、高い精度が必要な場合は、必ずデッドタイムを決定して設定してください。 コントローラーモードをコントローラーモードに切り替えるとき SMC_position 詳細については、以下を参照してください。 標準的なユースケースコントローラーモードで SMC_velocity 実際の位置と設定された速度から設定位置を計算します。 コントローラーモードで SMC_torque 実際の位置と実際の速度から設定位置を計算します。 ソフトウェアポジションラグモニタリングがオンになっている場合 で SMC_GetTravelTime 入力のファンクションブロック ValueSource 次の値があります。 MC_SOURCE.ACT で SMC_DigitalCamSwitch_HighPrecision 入力のファンクションブロック ValueSource 次の値があります。 MC_SOURCE.ACT で SMC_ETC_InterpolateAxisPosition ファンクションブロック (PLC ベースのタッチプローブ) " }, 
{ "title" : "例 ", 
"url" : "_sm_drives_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 例 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SM_Drive_PosControlを使用したコントローラーの位置制御 ", 
"url" : "_sm_example_poscontrol.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 例 \/ SM_Drive_PosControlを使用したコントローラーの位置制御 ", 
"snippet" : "を参照してください PosControl.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 ほとんどの場合、サーボ制御がドライブの位置制御、および電力制御と回転速度制御を引き継ぎます。ただし、コントローラが軸の位置制御を引き継ぐユースケースがあります。この例は、速度制御されたデバイス（たとえば、位置フィードバックを備えた周波数変換器）がどのように位置制御されるかを示しています。 CODESYS SoftMotion 。 要件は、設定された速度によって制御され、現在の位置を返すデバイスです。...", 
"body" : "を参照してください PosControl.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 ほとんどの場合、サーボ制御がドライブの位置制御、および電力制御と回転速度制御を引き継ぎます。ただし、コントローラが軸の位置制御を引き継ぐユースケースがあります。この例は、速度制御されたデバイス（たとえば、位置フィードバックを備えた周波数変換器）がどのように位置制御されるかを示しています。 CODESYS SoftMotion 。 要件は、設定された速度によって制御され、現在の位置を返すデバイスです。この例では、10Vアナログ出力端子EL4031が、周波数変換器の速度設定値として使用される信号とともに使用されます。エンコーダ端子EL5101は位置フィードバックに使用されます。 " }, 
{ "title" : "SM_Drive_PosControlによる軸位置の制御 ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_7bfb9b9f2d9ce618c0a8646335ff28dd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 例 \/ SM_Drive_PosControlを使用したコントローラーの位置制御 \/ SM_Drive_PosControlによる軸位置の制御 ", 
"snippet" : "タイプの位置制御軸を追加します SM_Drive_PosControl 未満 SoftMotion一般軸プール デバイスツリー内。 アナログ端子（EL4031）とエンコーダ（EL5101）の端子をデバイスツリーに追加します。 デバイスツリー： フィールドバスデバイスのデバイスの説明は、製造元からダウンロードしてインストールする必要があります。 を開きます SM_Drive_PosControl エディターでデバイスを指定し、一般パラメーターModuloを値で指定します 360.0 に 全般的 タブ。 クリック スケーリング\/マッピング タブ。モーター回転あたりの増分数は、エンコーダーのデータシ...", 
"body" : "タイプの位置制御軸を追加します SM_Drive_PosControl 未満 SoftMotion一般軸プール デバイスツリー内。 アナログ端子（EL4031）とエンコーダ（EL5101）の端子をデバイスツリーに追加します。 デバイスツリー： フィールドバスデバイスのデバイスの説明は、製造元からダウンロードしてインストールする必要があります。 を開きます SM_Drive_PosControl エディターでデバイスを指定し、一般パラメーターModuloを値で指定します 360.0 に 全般的 タブ。 クリック スケーリング\/マッピング タブ。モーター回転あたりの増分数は、エンコーダーのデータシートから取得されます。この例では、 4096 増分（1）は1モーター回転です。アプリケーションで角度度を操作しているため、値を指定します 360 （2） アプリケーションの単位 。 設定： に切り替えます SoftMotionドライブ：位置制御ループ タブをクリックして、次のパラメータを指定します。 D 2.0 デッドタイムは、受信した実際の位置（エンコーダ）が軸の設定位置に位相シフトされるサイクル数を決定します。デッドタイムは、適用されるコンポーネントによって異なり、試行錯誤によって決定する必要があります。 Kp 0.0 比例定数は、位置誤差（設定位置と実際の位置の偏差）を掛けて、後で設定速度に加算する係数です。次に、この値をに設定します 0 。値は後で実験的に決定します。 Bit width: 16 実際の値のビット幅は、使用するコンポーネントに応じて受信され、16、24、または32ビット値として設定できます。値をに設定します 16 使用されたコンポーネントが次のように位置を生成するため UINT 。 max 位置エラー監視スイッチはオフのままにします。必要に応じて、再びオンに切り替えることができます。チェックボックスを選択し、最大許容ラグを指定します。運転中にこの値を超えると、軸はエラー状態になります。 δ\/δt パラメータの値は1であり、非常に特殊な場合にのみ変更する必要があります。設定速度と位置の導出との関係を定義します。値の範囲は0から1です。 0 ：の値 fSetVelocity ソースとして使用されます。 1 ：設定位置の数値微分をソースとして使用します。 制御ループ： 次に、アクチュエータに送信される速度値を設定します。この目的のために、アプリケーション単位での最大速度と、転送されたデータの対応する生の値を知る必要があります。この例では、最大速度は値の出力によって達成されます 16#7FFF 、これは毎秒10回転の速度に対応します。これは、設定によると、毎秒3600度にも相当します。 設定： " }, 
{ "title" : "入力と出力への変数のマッピング ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_869c8e3e2852db2ec0a8640e00c42e8b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 例 \/ SM_Drive_PosControlを使用したコントローラーの位置制御 \/ 入力と出力への変数のマッピング ", 
"snippet" : "軸データを含む変数をI \/ Oモジュールにマップします。軸の利用可能な循環データは、データ構造にあります in と out 。この接続は、プログラムまたは直接のいずれかで、入出力デバイスのデバイスエディタで確立できます。 出力（設定速度）をEL4031デバイスに接続します。エディターでデバイスを開き、をクリックします EtherCAT I \/ Oマッピング タブ。変数を割り当てます out.iSetVelocity 軸の出力への。 32ビット出力の場合、 out.diSetVelocity 使用されている。 マッピング： 位置入力も同様に行ってください。エディターでEL5101デバイスを開き、...", 
"body" : "軸データを含む変数をI \/ Oモジュールにマップします。軸の利用可能な循環データは、データ構造にあります in と out 。この接続は、プログラムまたは直接のいずれかで、入出力デバイスのデバイスエディタで確立できます。 出力（設定速度）をEL4031デバイスに接続します。エディターでデバイスを開き、をクリックします EtherCAT I \/ Oマッピング タブ。変数を割り当てます out.iSetVelocity 軸の出力への。 32ビット出力の場合、 out.diSetVelocity 使用されている。 マッピング： 位置入力も同様に行ってください。エディターでEL5101デバイスを開き、位置入力値をに設定します。 in.wActPosition 。 32ビット入力の場合、値を次のように設定します。 in.dwActPosition 。マッピング： 制御イネーブル、クイックストップ、およびリミットスイッチを操作するために、 SMC_PosControlInput ドライブの値によって定義する必要があります。の出力 SMC_PosControlOutput ドライブに送信する必要があります（以下の説明を参照）。たとえば、ドライブがクイックストップをサポートしていない場合は、 SM_Drive_PosControl.in.bDriveStartRealState := TRUE 設定する必要があり、 SM_Drive_PosControl.out.bDriveStart 無視できます。この例では、 bDriveStartRealState と bRegulatorRealState アプリケーションで設定する必要があります。 SM_Drive_PosControl.in.bDriveStartRealState := TRUE;\nSM_Drive_PosControl.in.bRegulatorRealState := TRUE; " }, 
{ "title" : "システムのデッドタイムの決定 ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_section-idm43260109050006", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 例 \/ SM_Drive_PosControlを使用したコントローラーの位置制御 \/ システムのデッドタイムの決定 ", 
"snippet" : "次に、軸を使用してオンラインモードを設定し、制御パラメータを設定します。 軸が制御不能になる可能性があることに注意してください。したがって、対応する安全対策を講じる必要があります。 次に、位置制御なしで軸を操作してみてください。 fKp はすでに0.0に設定されており、スケーリング設定が検証されています。軸をに切り替えます MC_Power 開始します MC_MoveVelocity 。軸は、プログラムされた速度1 U \/ sで移動します。偏差の場合は、それに応じてスケーリングを修正する必要があります。 動きを終了します。 MC_MoveRelative 、トレース機能を開始します。 設定位置...", 
"body" : "次に、軸を使用してオンラインモードを設定し、制御パラメータを設定します。 軸が制御不能になる可能性があることに注意してください。したがって、対応する安全対策を講じる必要があります。 次に、位置制御なしで軸を操作してみてください。 fKp はすでに0.0に設定されており、スケーリング設定が検証されています。軸をに切り替えます MC_Power 開始します MC_MoveVelocity 。軸は、プログラムされた速度1 U \/ sで移動します。偏差の場合は、それに応じてスケーリングを修正する必要があります。 動きを終了します。 MC_MoveRelative 、トレース機能を開始します。 設定位置と実際の位置との時間差を測定して、システムのデッドタイムを決定します。 の MC_MoveRelative 、最大速度と大きな加速度を設定します。でサンプリングトレースを開始します MC_MoveRelative 。次に、設定位置の開始移動と実際の位置の最初の反応との間の時間差を決定します。 痕跡： デッドタイムを決定するには D 、この時間差をサイクルタイム (D = 時差\/サイクルタイム) で割ります。 ソフトモーションドライブ:ポジションコントロール タブをクリックし、次の制御ループでこの値を指定します。 D 。 ここで、 fKp . の正しい設定を決定してみよう。これを行うには、ウォッチリストの変数 <drive>.controller.fKp の値を変更する。 セット fKp 小さい数値 (例:0.0001) にして、少しずつ値を増やしていきます。各変化の挙動をサンプリングトレースで確認します。変動を検出するとすぐに上限に達したことになります。次に、の値を下げてください。 fKp 約 10% ずつ上げて指定してください ソフトモーションドライブ:ポジションコントロール コントロールループ内のタブ Kp 。 これで、軸を使用できます。 " }, 
{ "title" : "機能ブロック：SMC_PosControlInput ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_666f8939fd0b11e3b1f5b5a0173eacdc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 例 \/ SM_Drive_PosControlを使用したコントローラーの位置制御 \/ 機能ブロック：SMC_PosControlInput ", 
"snippet" : "図書館： SM3_Drive_PosControl 入力（VAR_INPUT） 名前 データ・タイプ 初期値 説明 bLimitPos BOOL 正方向のリミットスイッチ（有限軸のみ） 以来 SoftMotion バージョン 4.12.0.0 では、リミットスイッチモニタリングはデフォルトで有効になっています。古いバージョンでは、設定して手動で有効にする必要があります。 bHWLimitEnable へ TRUE 。これは通常、対応するパラメータ番号を記述することによって行われます 1206 という手段で MC_WriteBoolParameter 。 TRUE ：リミットスイッチ未作動 FA...", 
"body" : "図書館： SM3_Drive_PosControl 入力（VAR_INPUT） 名前 データ・タイプ 初期値 説明 bLimitPos BOOL 正方向のリミットスイッチ（有限軸のみ） 以来 SoftMotion バージョン 4.12.0.0 では、リミットスイッチモニタリングはデフォルトで有効になっています。古いバージョンでは、設定して手動で有効にする必要があります。 bHWLimitEnable へ TRUE 。これは通常、対応するパラメータ番号を記述することによって行われます 1206 という手段で MC_WriteBoolParameter 。 TRUE ：リミットスイッチ未作動 FALSE ：リミットスイッチ作動 bLimitNeg BOOL マイナス方向のリミットスイッチ TRUE ：リミットスイッチ未作動 FALSE ：リミットスイッチ作動 wActPosition WORD 16ビット値としての現在位置（実際の位置） dwActPosition DWORD 32ビット値としての現在位置（実際の位置） bExternalError BOOL 外部エラー bRegulatorRealState BOOL TRUE ：制御されている軸 bDriveStartRealState BOOL FALSE ：軸の Quick Stop dwEncoderCounterModulo DWORD 0 bDelayActivation BOOL TRUE ： に限って bDelayActivation は TRUE 、 SM3_Drive_PosControl 通信状態に切り替わらない 100 。 ユースケース：値はで保持されます TRUE 適用されたエンコーダが有効な位置値を生成するまで。 " }, 
{ "title" : "機能ブロック：SMC_PosControlOutput ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_60809817bdae11e9b2a8cd92ec450e2f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 例 \/ SM_Drive_PosControlを使用したコントローラーの位置制御 \/ 機能ブロック：SMC_PosControlOutput ", 
"snippet" : "図書館： SM3_Drive_PosControl 出力（VAR_OUTPUT） 名前 データ・タイプ 初期値 説明 bRegulatorOnIn BOOL TRUE ：軸を制御する必要があります。 bDriveStart BOOL FALSE ：軸はクイックストップを実行する必要があります。 diSetVelocity DINT 速度を設定する iSetVelocity INT 速度を設定する...", 
"body" : "図書館： SM3_Drive_PosControl 出力（VAR_OUTPUT） 名前 データ・タイプ 初期値 説明 bRegulatorOnIn BOOL TRUE ：軸を制御する必要があります。 bDriveStart BOOL FALSE ：軸はクイックストップを実行する必要があります。 diSetVelocity DINT 速度を設定する iSetVelocity INT 速度を設定する " }, 
{ "title" : "機能ブロック：SMC_SetPosControlParams ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_6080e639bdae11e9b2a8cd92ec450e2f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ 例 \/ SM_Drive_PosControlを使用したコントローラーの位置制御 \/ 機能ブロック：SMC_SetPosControlParams ", 
"snippet" : "図書館： SM3_Drive_PosControl のパラメータを変更します SM3_Drive_PosControl 軸 入力（VAR_INPUT） 名前 データ・タイプ 初期値 説明 Axis AXIS_REF_POSCONTROL 軸リファレンス bExecute BOOL TRUE ：機能ブロックの実行を有効化します fKp LREAL -1 ラグの比例ゲイン 0未満の値は無視されます。 fPartVelPilotControl LREAL -1 速度制御の係数 fSetPosition 0：速度パイロット制御なし。 1：の直接出力 fSetVelocity 。 0未満の値は無視されま...", 
"body" : "図書館： SM3_Drive_PosControl のパラメータを変更します SM3_Drive_PosControl 軸 入力（VAR_INPUT） 名前 データ・タイプ 初期値 説明 Axis AXIS_REF_POSCONTROL 軸リファレンス bExecute BOOL TRUE ：機能ブロックの実行を有効化します fKp LREAL -1 ラグの比例ゲイン 0未満の値は無視されます。 fPartVelPilotControl LREAL -1 速度制御の係数 fSetPosition 0：速度パイロット制御なし。 1：の直接出力 fSetVelocity 。 0未満の値は無視されます。 fDeadTime LREAL -1 間のサイクルのタイムラグ fSetPosition と fActPositioin この値は0であってはなりません。0未満の値は無視されます。 fMaxPositionDiff LREAL -1 最大位置遅れ 0は、最大位置遅れのチェックを無効にします。 0未満の値は無視されます。 出力（VAR_OUTPUT） 名前 データ・タイプ 初期値 説明 bDone BOOL 機能ブロックの実行が終了しました。 bError BOOL TRUE ：機能ブロックでエラーが発生しました。 ErrorID SMC_ERROR エラーの識別 例 軸ドライブのパラメータ SM_Drive_PosControl 設定されています。 PROGRAM PLC_PRG\nVAR\n fbSetPosControlParams : SMC_SetPosControlParams;\nEND_VAR\n\nfbSetPosControlParams.fKp := 1;\nfbSetPosControlParams.fPartVelPilotControl :=0;\nfbSetPosControlParams.fDeadTime :=0.1;\nfbSetPosControlParams.fMaxPositionDiff :=1;\n\nfbSetPosControlParams(Axis:= SM_Drive_PosControl, bExecute:= TRUE); " }, 
{ "title" : "ユーザーインターフェース ", 
"url" : "_sm_drives_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユーザーインターフェース ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド：追加 SoftMotion CiA402軸 ", 
"url" : "_sm_cmd_add_softmotion_cia402_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユーザーインターフェース \/ コマンド：追加 SoftMotion CiA402軸 ", 
"snippet" : "追加 SoftMotion CiA402軸 関数 : コマンドは将軍を追加します SoftMotion デバイス ツリーのフィールドバス スレーブの下にある CiA402 軸。 電話 : 計画 メニュー;デバイス ツリーのデバイス オブジェクトのコンテキスト メニュー 必要条件 : デバイスツリーで、このドライブをサポートするデバイスが選択されます。例:EtherCAT スレーブまたは ドライブの ESI ファイルには、それが CiA402 軸であるというエントリが含まれています ( ProfileNo 402 )。 このコマンドは一般的な CIA402 軸を挿入します。詳細については、以下を...", 
"body" : "追加 SoftMotion CiA402軸 関数 : コマンドは将軍を追加します SoftMotion デバイス ツリーのフィールドバス スレーブの下にある CiA402 軸。 電話 : 計画 メニュー;デバイス ツリーのデバイス オブジェクトのコンテキスト メニュー 必要条件 : デバイスツリーで、このドライブをサポートするデバイスが選択されます。例:EtherCAT スレーブまたは ドライブの ESI ファイルには、それが CiA402 軸であるというエントリが含まれています ( ProfileNo 402 )。 このコマンドは一般的な CIA402 軸を挿入します。詳細については、以下を参照してください ジェネリック CiA402 アクシスのコンフィギュレーション " }, 
{ "title" : "コマンド：追加 SoftMotion Sercos Axis ", 
"url" : "_sm_cmd_add_softmotion_sercos_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユーザーインターフェース \/ コマンド：追加 SoftMotion Sercos Axis ", 
"snippet" : "追加 SoftMotion Sercos Axis 関数 ：コマンドは一般を追加します SoftMotion Sercosモジュールの下のSercos軸。 電話 ： 計画 メニュー; Sercosスレーブのコンテキストメニュー 要件 ：デバイスツリーで適切なSercosスレーブが選択されています。 Sercos軸はサポートされなくなりました SoftMotion バージョン 4.17.0.0 以上。 このコマンドは、サーボドライブが動作するために使用されます CODESYS SoftMotion 。ドライブはSercos標準をサポートする必要があるだけです。 CODESYS デバイスとの通信に...", 
"body" : "追加 SoftMotion Sercos Axis 関数 ：コマンドは一般を追加します SoftMotion Sercosモジュールの下のSercos軸。 電話 ： 計画 メニュー; Sercosスレーブのコンテキストメニュー 要件 ：デバイスツリーで適切なSercosスレーブが選択されています。 Sercos軸はサポートされなくなりました SoftMotion バージョン 4.17.0.0 以上。 このコマンドは、サーボドライブが動作するために使用されます CODESYS SoftMotion 。ドライブはSercos標準をサポートする必要があるだけです。 CODESYS デバイスとの通信に標準のドライバーを使用します。ドライブがデバイスで機能するかどうかは、デバイス自体の実装によって異なります。したがって、ドライバーがデバイスでどのように動作するかどうかは保証されません。 一般的なSercosドライバーは、最大8軸の多軸デバイスをサポートします。 " }, 
{ "title" : "コマンド：追加 SoftMotion SoE軸 ", 
"url" : "_sm_cmd_add_softmotion_soe_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユーザーインターフェース \/ コマンド：追加 SoftMotion SoE軸 ", 
"snippet" : "追加 SoftMotion SoE軸 関数 ：コマンドは一般を追加します SoftMotion EtherCATスレーブの下のSoE軸。 電話 ： 計画 メニュー;スレーブのコンテキストメニュー 要件 ：デバイスツリーで適切なEtherCATスレーブが選択されています。 このコマンドは、サーボドライブが動作するために使用されます CODESYS SoftMotion 。サーボドライブはSoE規格のみをサポートする必要があります。 CODESYS デバイスとの通信に標準のドライバーを使用します。ドライブがデバイスで機能するかどうかは、デバイス自体の実装によって異なります。したがって、ドライバーが...", 
"body" : "追加 SoftMotion SoE軸 関数 ：コマンドは一般を追加します SoftMotion EtherCATスレーブの下のSoE軸。 電話 ： 計画 メニュー;スレーブのコンテキストメニュー 要件 ：デバイスツリーで適切なEtherCATスレーブが選択されています。 このコマンドは、サーボドライブが動作するために使用されます CODESYS SoftMotion 。サーボドライブはSoE規格のみをサポートする必要があります。 CODESYS デバイスとの通信に標準のドライバーを使用します。ドライブがデバイスで機能するかどうかは、デバイス自体の実装によって異なります。したがって、ドライバーがデバイスでどのように動作するかどうかは保証されません。 一般的なSoEドライバーは、最大8軸の多軸デバイスをサポートします。 " }, 
{ "title" : "SoftMotion ドライブ ", 
"url" : "_sm_f_reference_object_sm_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユーザーインターフェース \/ SoftMotion ドライブ ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "タブ：一般 ", 
"url" : "_sm_edt_drive_general.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユーザーインターフェース \/ SoftMotion ドライブ \/ タブ：一般 ", 
"snippet" : "軸タイプと設定 軸タイプ 仮想モード : ドライブは、仮想ドライブユニットに似たシミュレーションに置き換えられます。結合ドライブがあっても、フィールドバスデバイスには影響しません。物理デバイスとの間でメッセージを送受信しなくても、通常どおり機能します 注：IECコードを使用して、ドライブの仮想モードを設定およびリセットすることもできます。 SMC3_ReinitDrive ファンクションブロック。 モジュロ ：ドライブは、移動範囲を制限することなく無限に回転します（例：ベルトドライブ）。 モジュロ値[u] ：1サイクルの値（モジュロ周期） 値はに保存されます fPositionPeriod の...", 
"body" : "軸タイプと設定 軸タイプ 仮想モード : ドライブは、仮想ドライブユニットに似たシミュレーションに置き換えられます。結合ドライブがあっても、フィールドバスデバイスには影響しません。物理デバイスとの間でメッセージを送受信しなくても、通常どおり機能します 注：IECコードを使用して、ドライブの仮想モードを設定およびリセットすることもできます。 SMC3_ReinitDrive ファンクションブロック。 モジュロ ：ドライブは、移動範囲を制限することなく無限に回転します（例：ベルトドライブ）。 モジュロ値[u] ：1サイクルの値（モジュロ周期） 値はに保存されます fPositionPeriod のパラメータ AXIS_REF_SM3 ファンクションブロック。 注：を選択した場合 モジュロ ドライブタイプ、次に製品 fPositionPeriod * dwRatioTechUnitsDenom 整数である必要があります。 有限の ：ドライブには固定作業領域があります（例：1つのリニアドライブ）。 ソフトウェアリミットスイッチ 有効化 ：位置の値は下限によって制限されます ネガティブ と上限 ポジティブ 。 ネガティブ ：負の制限値の入力フィールド ポジティブ ：正の制限値の入力フィールド モータータイプ ロータリー : での設定 スケーリング ロータリーモーターに適用。 線形 : での設定 スケーリング リニアモーターに適用。(ギヤやモーターターンのないシンプルな構成 速度ランプタイプ モーションを生成する単軸モジュールとマスター\/スレーブモジュールの速度プロファイルを定義します。 注:ランプの種類 Sin² と 二次 (スムーズ) ロボット工学ではサポートされていません。 台形 : 台形速度プロファイル (各セグメントの加速度が一定) Sin² : sin² 関数で定義される速度プロファイル (一定の加速度曲線を使用)。 二次方程式 : ジャーク制限付きの台形形状の加速度プロファイル 二次 (スムーズ) : 好き 二次方程式 しかし、ジャンプせずにジャークプロファイルを生成します。 身分証明書 ID 整数識別子。ドライブごとに一意である必要があります。たとえば、この識別子は PLC ログでエラーが発生したときにドライブを識別するために使用されます。 デッドタイム サイクル 間のサイクル単位のデッドタイム fActPosition と fSetPosition このサイクルの初めに ダイナミックリミット PLCOpen Part 4 POUの制限値が考慮されています。さらに、次のような名前のライブラリPOUでも使用されます SMC_ControlAxisBy* ジャンプの検出用。 速度 [u\/秒] 速度、加速、減速、およびジャークの制限値 アクセラレーション [u\/s²] 減速 [u\/s²] ジャーク [u\/s³] 監視とエラー対応 ソフトウェア制限 アクティベート : ポジション値は下限によって制限されます マイナス そして上限 ポジティブ 。 ネガティブ : 負の制限値の入力フィールド ポジティブ : 正の制限値の入力フィールド ソフトウェアエラーリアクション ソフトウェアエラーの原因 ソフトウェアのリミットスイッチに到達 ソフトウェア遅延の最大許容値を超えています 有限軸の場合:32 ビットのオーバーフローが多すぎます MC_Power.bRegulatorOn = FALSE アクティブな移動中 (エラー: SMC_FB_ACTIVE_AXIS_DISABLED ) モーションファンクションブロック付き Busy=TRUE 呼び出されません (エラー: SMC_FB_WASNT_CALLED_DURING_MOTION ) ソフトウェアエラー対応については、 減速 、 マックス。 、ダイナミックリミットの減速も考慮されます。最大距離から減速も計算されます。これらの減速値のうち大きい方がエラーランプに使用されます 減速 [u\/s²] : エラーランプの減速 最大距離 [u] オプション エラーが発生した後、ドライブはこの距離内で停止状態になっている必要があります。 ポジションラグモニタリング 検出されたラグに対するシステム応答。 設定位置と補正された実際の位置との差がラグ制限を超えると、ラグが検出されます。外挿された実際のポジションは次の式で計算されます extrapolated actual position := actual position + actual velocity * cycle time * Axis.fSetActTimeLagCycles この値は、デッドタイムによって補正された軸の実際の位置です。 注:ラグを監視している場合は、デッドタイムを確認して入力する必要があります。説明については、次の章を参照してください 実績値、設定値、デッドタイム. 注:ラグモニタリングは仮想ドライブでは使用できません。 非アクティブ化 応答なし ラグモニタリングは無効になっています。 ドライブを無効にする ザ・ bRegulatorOn ビットは強制的に FALSE (と比較) MC_Power input): 最初にドライブを強制的に減速させ、次にドライブを強制的に非アクティブにします (ドライブの実装によって異なります)。 クイックストップを行う ザ・ bDriveStart ビットは強制的に FALSE (と比較) MC_Power input) を押すと、ドライブに強制的にクイックストップが実行されます。 有効状態を維持 ドライブの電源はオンのままですが、実行中の動作はすべて突然停止します。 ラグリミット : コントローラーのラグモニタリング ドライブで独立した監視を行うこともできますが、このダイアログでは設定されていません。 オンライン 要件：PLCはオンラインモードです。 変数テーブル 変数名を持つドライブ変数のリスト、 設定値 と 現在の価値 状態 SoftMotionドライブの現在のステータスの表示 通信設定 現在の通信状態の表示 エラー 軸エラー FBエラー uiDriveInterfaceError strDriveInterfaceError 詳細については、次を参照してください。 システムのデッドタイムの決定例 次の画像は、さまざまなランプタイプの効果を示しています。位置は緑、速度は青、加速度は赤で描かれています。 台形 速度は部分的に線形で連続的ですが、部分的に一定の加速度はジャンプを示します。 Sin² 速度プロファイルの切れ目は、加速のジャンプを減らすために（線の代わりにsin²関数を使用して）滑らかになります。 ユーザーは、このランプタイプのジャークを制限することはできません。設定された最大ジャークは、移動の開始時に加速度がゼロに等しくなく、中断された減速および加速ランプをシームレスに継続できない場合にのみ効果があります。次に、ジャーク制限を考慮して、現在の移動が開始される前に加速度がゼロに減少します。台形速度プロファイルと比較して、この場合、減速にはより多くの時間がかかります。 二次 加速は部分的に線形で連続的であり、ジャークにはジャンプがあります。速度は、2次セグメントと線形セグメントで構成されます。 二次（スムーズ） 二次ランプタイプの線形加速ランプは、最初と最後の勾配値がゼロの「滑らかな」関数に置き換えられます。その結果、ジャークも継続します。 注：動きが中断されると、ジャークが中断する可能性があります。 詳細については、以下を参照してください。 動きの中断" }, 
{ "title" : "タブ：スケーリング\/マッピング ", 
"url" : "_sm_edt_drive_scaling_mapping.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユーザーインターフェース \/ SoftMotion ドライブ \/ タブ：スケーリング\/マッピング ", 
"snippet" : "このタブでは、技術単位（ミリメートルや度など）とドライブ単位（増分）の関係を定義できます。デバイスの説明に応じて、設定オプションが簡略化されて表示されます（パラメータ bHiresMode = TRUE ）、および\/またはリニアモーターのスケーリングも可能です（パラメーター IsLinearMotor = TRUE ）。必要に応じて、周期的に送信されるドライブオブジェクトのIEC変数へのマッピングに影響を与えることもできます。 スケーリング 方向を反転します ：回転方向が逆になります。モーターは反対の符号で指定された値を取得します。 精度（10進数） 要件：デバイスの説明で、簡略化された構成ダ...", 
"body" : "このタブでは、技術単位（ミリメートルや度など）とドライブ単位（増分）の関係を定義できます。デバイスの説明に応じて、設定オプションが簡略化されて表示されます（パラメータ bHiresMode = TRUE ）、および\/またはリニアモーターのスケーリングも可能です（パラメーター IsLinearMotor = TRUE ）。必要に応じて、周期的に送信されるドライブオブジェクトのIEC変数へのマッピングに影響を与えることもできます。 スケーリング 方向を反転します ：回転方向が逆になります。モーターは反対の符号で指定された値を取得します。 精度（10進数） 要件：デバイスの説明で、簡略化された構成ダイアログ（パラメーター）を指定します bHiresMode = TRUE ）。この場合、非表示の設定はデフォルト値の 1 。 スケーリングおよび転送される増分のユーザー単位の小数点以下の桁数。例えば、 3 10の精度に対応します 3 。 増分<=>モーター回転 与えられたモーター回転数に対応する増分の数。あなたはでパラメータを見ることができます 構成 デバイスエディタのタブ。 モーター回転<=>ギア出力回転 与えられたギア出力回転数に対応するモーター回転数。 ギア出力はアプリケーションで<=>単位回転します アプリケーションのユニットに対応するギア出力ターン数。 包括的な構成の例 サンプル構成では、モーターの回転に対して3600の増分があるドライブは、アプリケーションの技術単位が真っ直ぐな角度になるようにスケーリングされます。 マッピング 注：これらのパラメーターは、Drive_PosControlでは使用できません。 自動マッピング ：ドライブに影響を与えるIECパラメータは、デバイスの対応する入力と出力に自動的にマッピングされます。オプションを無効にした後、マッピングを手動で編集できます。これを行うには、入力と出力のアドレスまたはタイプを、デバイス記述ファイルに従って作成された表示されたパラメーターリストに変更します。 " }, 
{ "title" : "タブ：試運転 ", 
"url" : "_sm_edt_drive_commisioning.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユーザーインターフェース \/ SoftMotion ドライブ \/ タブ：試運転 ", 
"snippet" : "このページのボタンを使用してドライブを移動できます。ドライブが予期しない動きをする可能性があります。 必要なすべての安全対策を講じてください。 このタブは、物理ドライブを試運転する際のテスト目的で使用されます。次の場合にのみ使用できます オンライン構成モード 有効になっています。このモードでは、開発システムがデバイスに接続されます。ただし、アプリケーションをダウンロードする必要はありません。 オンライン 要件：PLCはオンラインモードです。 変数テーブル 変数名を持つドライブ変数のリスト、 設定値 と 現在の価値 状態 SoftMotionドライブの現在のステータスの表示 通信設定 現在の通信...", 
"body" : "このページのボタンを使用してドライブを移動できます。ドライブが予期しない動きをする可能性があります。 必要なすべての安全対策を講じてください。 このタブは、物理ドライブを試運転する際のテスト目的で使用されます。次の場合にのみ使用できます オンライン構成モード 有効になっています。このモードでは、開発システムがデバイスに接続されます。ただし、アプリケーションをダウンロードする必要はありません。 オンライン 要件：PLCはオンラインモードです。 変数テーブル 変数名を持つドライブ変数のリスト、 設定値 と 現在の価値 状態 SoftMotionドライブの現在のステータスの表示 通信設定 現在の通信状態の表示 エラー 軸エラー FBエラー uiDriveInterfaceError strDriveInterfaceError " }, 
{ "title" : "操作要素 ", 
"url" : "_sm_edt_drive_commisioning.html#UUID-44ff80c7-7f0e-b818-51b8-af95752bbbbd_id_b3c83ad0f91194c0a8646325634a44_id_063bbc9a58bd11e68fa9d28177272265", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユーザーインターフェース \/ SoftMotion ドライブ \/ タブ：試運転 \/ 操作要素 ", 
"snippet" : "操作要素 力 ドライブには電力が供給されています（と比較してください） MC_Power ）。 エラーリセット エラーの後にドライブをリセットします（と比較してください） MC_Reset ）。 ホーミングを開始します ドライブは、ドライブに設定されたパラメータを使用してホーミングを実行します（と比較してください） MC_Home ）。 ジョギング <および>スイッチを使用すると、ドライブは、の指定された値に従って前後に移動できます。 距離 、 速度 、 加速度 、 減速 、 と ぴくぴく動く （と比べて MC_Inch ）。 読み書き 指定されたドライブパラメータについて、現在の 価値 PL...", 
"body" : "操作要素 力 ドライブには電力が供給されています（と比較してください） MC_Power ）。 エラーリセット エラーの後にドライブをリセットします（と比較してください） MC_Reset ）。 ホーミングを開始します ドライブは、ドライブに設定されたパラメータを使用してホーミングを実行します（と比較してください） MC_Home ）。 ジョギング <および>スイッチを使用すると、ドライブは、の指定された値に従って前後に移動できます。 距離 、 速度 、 加速度 、 減速 、 と ぴくぴく動く （と比べて MC_Inch ）。 読み書き 指定されたドライブパラメータについて、現在の 価値 PLCから読み取って表示します。の 準備された価値 、小さなボタンを使用して、新しい値を指定し、ドライブのパラメータに書き込むことができます（と比較してください） MC_ReadParameter 、 MC_WriteParameter ）。 " }, 
{ "title" : "タブ：SoftMotionドライブ–位置制御 ", 
"url" : "_sm_edt_drive_poscontrol_position_control_loop.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユーザーインターフェース \/ SoftMotion ドライブ \/ タブ：SoftMotionドライブ–位置制御 ", 
"snippet" : "このタブでは、位置制御のパラメータを設定します。 例にも注意してください  SM_Drive_PosControlを使用したコントローラーの位置制御. 位置制御ループ fSetPosition 位置値を設定する D デッドタイムは、受信した実際の位置（エンコーダ）が軸の設定位置に位相シフトされるサイクル数を決定します。デッドタイムは、適用されるコンポーネントによって異なり、試行錯誤によって決定する必要があります。 詳細については、次を参照してください。 システムのデッドタイムの決定fActPosition 実際の位置の値 ビット幅 実際の値のビット幅は、使用するコンポーネントに応じて受信され、...", 
"body" : "このタブでは、位置制御のパラメータを設定します。 例にも注意してください  SM_Drive_PosControlを使用したコントローラーの位置制御. 位置制御ループ fSetPosition 位置値を設定する D デッドタイムは、受信した実際の位置（エンコーダ）が軸の設定位置に位相シフトされるサイクル数を決定します。デッドタイムは、適用されるコンポーネントによって異なり、試行錯誤によって決定する必要があります。 詳細については、次を参照してください。 システムのデッドタイムの決定fActPosition 実際の位置の値 ビット幅 実際の値のビット幅は、使用するコンポーネントに応じて受信され、16、24、または32ビット値として設定できます。 マックス ：位置エラー監視が有効になります。 最大許容ラグの入力 運転中にこの値を超えると、軸はエラー状態になります。 Kp 比例定数は、位置誤差（設定位置と実際の位置の偏差）を掛けて、後で設定速度に加算する係数です。 fSetVelocity ベロシティ値を設定する 速度出力のスケーリング fActPositionと速度出力は反対方向です ：速度出力と現在位置が反対方向の場合、オプションを有効にすることで修正されます。 アプリケーション[tu \/ s] 最小および最大速度値（アプリケーション単位）。たとえば、1秒あたり3600回転。 出力値 アクチュエータに送信される最小および最大出力値（例：16＃7FFF）。 " }, 
{ "title" : "タブ：論理軸 ", 
"url" : "_sm_edt_drive_logical_general.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユーザーインターフェース \/ SoftMotion ドライブ \/ タブ：論理軸 ", 
"snippet" : "軸タイプ モジュロ ：ドライブは、移動範囲を制限することなく無限に回転します（例：ベルトドライブ）。 モジュロ設定 モジュロ値 ：1サイクルの値 値はに保存されます fPositionPeriod のパラメータ AXIS_REF_SM3 ファンクションブロック。 注：を選択した場合 モジュロ ドライブタイプ、次に製品 fPositionPeriod * dwRatioTechUnitsDenom 整数である必要があります。 有限の ：ドライブには固定作業領域があります（例：1つのリニアドライブ）。 ネガティブ ：負の制限値の入力フィールド ポジティブ ：正の制限値の入力フィールド マスター基準...", 
"body" : "軸タイプ モジュロ ：ドライブは、移動範囲を制限することなく無限に回転します（例：ベルトドライブ）。 モジュロ設定 モジュロ値 ：1サイクルの値 値はに保存されます fPositionPeriod のパラメータ AXIS_REF_SM3 ファンクションブロック。 注：を選択した場合 モジュロ ドライブタイプ、次に製品 fPositionPeriod * dwRatioTechUnitsDenom 整数である必要があります。 有限の ：ドライブには固定作業領域があります（例：1つのリニアドライブ）。 ネガティブ ：負の制限値の入力フィールド ポジティブ ：正の制限値の入力フィールド マスター基準値 設定 ：マスタの設定値を論理軸とデッドタイム補正の入力として使用します。 実際 ：マスタの実際の値は、論理軸とデッドタイム補正の入力として使用されます。 時間オフセット マスター値に対する時間オフセット サイクル数 この期間に設定値を外挿する必要があります 入力データフィルター フィルタを使用すると、PT1フィルタを使用してエンコーダの位置と速度の値を滑らかにすることができます。 ポジション PT1フィルターの時定数として使用されるサイクル数。 値の範囲：[0..999.9] 値0：フィルタリングは実行されません（生の値が返されます）。 フィルター処理された戻り値は、PT1フィルター処理された位置信号と、速度信号を使用した追加の位置外挿の組み合わせです。外挿自体もPT1フィルターを使用してノイズを軽減し、適切な時定数を自動的に選択します。 設定値のみをフィルタリングする場合、または軸が速度信号を送信する場合、外挿PT1の時定数は位置PT1フィルターの場合と同じです。 それ以外の場合は、ヒューリスティックなアプローチが使用されます。 T Extrapolate = (T Pos + T Dead ) * T Pos \/ T Cycle T Extrapolate : PT1 外挿フィルタからの時定数 T Pos : PT1位置フィルタからの時定数 T Cycle : タクトタイム T Dead : 論理軸のマスター値に対するタイム シフトを使用したデッド タイム補正  n Shift  そしてサイクルタイム  T Cycle : T Dead = n Shift * T Cycle 速度 PT1フィルターの時定数として使用されるサイクル数。 値の範囲：[0..999.9] 値0：フィルタリングは実行されません（生の値が返されます）。 フィルタリングされた戻り値は、PT1フィルタリングされた速度信号と、加速度信号を使用した追加の速度外挿の組み合わせです。外挿は、軸が速度信号を送信する場合、または設定値をフィルタリングする必要がある場合にのみ使用されることに注意してください。外挿自体もPT1フィルターを使用してノイズを軽減し、適切な時定数を自動的に選択します。 T Extrapolate = (T Vel + T Dead ) * T Vel \/ T Cycle と T Extrapolate : PT1 外挿フィルタからの時定数 T Vel : PT1 速度フィルターからの時定数 T Cycle : タクトタイム T Dead : 論理軸のマスター値に対するタイム シフトを使用したデッド タイム補正   n Shift  そしてサイクルタイム  T Cycle : T Dead = n Shift * T Cycle 論理軸の速度信号 ( fActVelocity ): ケース 1: マスター基準値 = 設定 fSetVelocity マスタ軸の速度信号は、論理軸の速度信号の生の値として使用されます。 ケース 2: マスター基準値 = 実際 マスター軸からの速度信号はありません。 論理軸のフィルタリングされた位置の数値導関数 ( fActPosition ) は、論理軸の速度信号の生の値として使用されます。 ケース 3: マスター基準値 = 実際 マスター軸からの速度信号。 速度信号は、論理軸の速度信号の生の値として使用されます。 この生信号に対して速度フィルタリングが実行されます。これは、デフォルト値で構成されている場合、 usiFilterDepthVelocity = 0 の場合、このシグナルは変更されずに渡されます fActVelocity . ケース 2 では、フィルタリングされていない位置の数値導関数を使用することもできます ( fActPosition マスター軸の)。フィルタリングされた位置が選択されています。この場合、 fActVelocity 論理軸の fActPosition 速度フィルタリングなしのデフォルト構成。 速度の場合、フィルター遅延の外挿は、ケース 1 と 3 でのみ実行されます。ケース 2 では、これは数値的に安定しないか、意味のある加速度のフィルタリングが多すぎる必要があります。 論理軸の加速度 ( fActAcceleration ) ケース 1: マスター基準値 = 設定 fSetAcceleration マスタ軸の加速度信号を論理軸の加速度信号に使用します。 ケース 2: マスター基準値 = 実際 マスター軸からの速度信号。 論理軸のフィルタリングされた速度の数値導関数 ( fActVelocity ) は、論理軸の加速度信号に使用されます。 ケース 3: マスター基準値 = 実際 マスター軸からの速度信号はありません。 値 0 ノイズの多い位置を 2 回微分すると使用できない結果になるため、論理軸の加速度信号に を使用します。 論理軸のジャーク ( fActJerk ) 論理軸のジャーク ( fActJerk ) はどちらか ケース 1: マスター基準値 = 設定 fSetJerk マスタ軸のジャーク信号は論理軸のジャーク信号に使用されます。 ケース 2: マスター基準値 = 実際 値 0 ノイズの多い位置信号を 3 回微分すると使用できない結果になるため、論理軸のジャーク信号には が使用されます。 加速度信号とジャーク信号のむだ時間補償は実行されません。 論理軸のすべての設定値 (位置、速度、加速度、ジャーク) は実際の値に対応します。 値を書く の値を書き込みます 入力データフィルター と 時間オフセット PLCで。 身元 ID 論理軸の一意のID オンライン 要件：PLCはオンラインモードです。 変数テーブル 変数名を持つドライブ変数のリスト、 設定値 と 現在の価値 状態 SoftMotionドライブの現在のステータスの表示 通信設定 現在の通信状態の表示 エラー 軸エラー FBエラー uiDriveInterfaceError strDriveInterfaceError " }, 
{ "title" : "タブ：エンコーダー ", 
"url" : "_sm_edt_drive_free_encoder_general.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ ユーザーインターフェース \/ SoftMotion ドライブ \/ タブ：エンコーダー ", 
"snippet" : "一般的なエンコーダ設定 モジュロ モジュロドライブでは、このオプションをアクティブにして、 モジュロ値 指定。 ：ドライブは、移動範囲を制限することなく無限に回転します（例：ベルトドライブ）。 NS モジュロ設定 ウィンドウが表示されます： モジュロ値 ：モジュロ値の入力フィールド 値はに保存されます fPositionPeriod のパラメータ AXIS_REF_SM3 ファンクションブロック。 注：を選択した場合 モジュロ ドライブタイプ、次に製品 fPositionPeriod * dwRatioTechUnitsDenom 整数である必要があります。 有限の ：ドライブが制限されていま...", 
"body" : "一般的なエンコーダ設定 モジュロ モジュロドライブでは、このオプションをアクティブにして、 モジュロ値 指定。 ：ドライブは、移動範囲を制限することなく無限に回転します（例：ベルトドライブ）。 NS モジュロ設定 ウィンドウが表示されます： モジュロ値 ：モジュロ値の入力フィールド 値はに保存されます fPositionPeriod のパラメータ AXIS_REF_SM3 ファンクションブロック。 注：を選択した場合 モジュロ ドライブタイプ、次に製品 fPositionPeriod * dwRatioTechUnitsDenom 整数である必要があります。 有限の ：ドライブが制限されています。 ビット幅 適切なビット幅のリストボックス スケーリング デバイスによって送信される整数の位置値の変換の定義。 IECアプリケーションで使用される増分および技術単位で。 方向を反転します ：エンコーダは指定された値を逆符号で受け取るため、反対の回転方向に回転します。 増分<=>エンコーダ回転 の数 増分 完了した数に対応します エンコーダーの回転 アプリケーションのエンコーダ回転<=>単位 の数 エンコーダーターン 対応する アプリケーションの単位 オンライン 要件：PLCはオンラインモードです。 変数テーブル 変数名を持つドライブ変数のリスト、 設定値 と 現在の価値 状態 SoftMotionドライブの現在のステータスの表示 通信設定 現在の通信状態の表示 エラー 軸エラー FBエラー uiDriveInterfaceError strDriveInterfaceError " }, 
{ "title" : "CODESYS Softmotion Basic ", 
"url" : "_sm_basic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概要 ", 
"url" : "_sm_overview_basic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 概要 ", 
"snippet" : "CODESYS Softmotion Basic 個々の軸のモーション制御のためのファンクションブロックのインターフェースを提供します。このインターフェースは、PLCopen仕様「モーション制御用ファンクションブロックパート1 V2.0」に基づいています。軌道計画は、 CODESYS コントローラ。機能の範囲は、目標位置または速度への移動から、2 つの移動の重ね合わせや同期移動、仮想ギアおよびカム経由まで多岐にわたります。動作コマンドは、サイクル精度でバッファリングおよび中止できるほか、オーバーライドによって減速または停止して再開することもできます。...", 
"body" : "CODESYS Softmotion Basic 個々の軸のモーション制御のためのファンクションブロックのインターフェースを提供します。このインターフェースは、PLCopen仕様「モーション制御用ファンクションブロックパート1 V2.0」に基づいています。軌道計画は、 CODESYS コントローラ。機能の範囲は、目標位置または速度への移動から、2 つの移動の重ね合わせや同期移動、仮想ギアおよびカム経由まで多岐にわたります。動作コマンドは、サイクル精度でバッファリングおよび中止できるほか、オーバーライドによって減速または停止して再開することもできます。 " }, 
{ "title" : "はじめに CODESYS Softmotion Basic ", 
"url" : "_sm_basic_first_steps.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ はじめに CODESYS Softmotion Basic ", 
"snippet" : "動きをプログラムするには CODESYS Softmotion Basic 、デバイスツリーで少なくとも1つの軸を構成する必要があります。これには軸タイプの設定が含まれます（ モジュロ または 有限の ）、速度ランプタイプ、ソフトウェア リミット スイッチ、およびエラー反応です。 サポートされている移動タイプの概要については、 単軸動作 章。 単軸動作のプログラミング方法については、 単一軸の動きの制御 章。 カムの基本的な使用法の詳細については、 仮想時間軸を使用したカムドライブの制御 章。 バッファリング、ブレンディング、動きの重ね合わせの詳細については、 複数の動きを指揮する セクション...", 
"body" : "動きをプログラムするには CODESYS Softmotion Basic 、デバイスツリーで少なくとも1つの軸を構成する必要があります。これには軸タイプの設定が含まれます（ モジュロ または 有限の ）、速度ランプタイプ、ソフトウェア リミット スイッチ、およびエラー反応です。 サポートされている移動タイプの概要については、 単軸動作 章。 単軸動作のプログラミング方法については、 単一軸の動きの制御 章。 カムの基本的な使用法の詳細については、 仮想時間軸を使用したカムドライブの制御 章。 バッファリング、ブレンディング、動きの重ね合わせの詳細については、 複数の動きを指揮する セクション。 詳細については、以下を参照してください。 の概要 カム章： カムの切り替えアプリケーションからオンラインでカムを作成する: カムのデータ構造章： MC_SetOverride による動的適応" }, 
{ "title" : "管理機能ブロック ", 
"url" : "_sm_administrative_fbs.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 管理機能ブロック ", 
"snippet" : "管理機能ブロックは、情報の照会や特定の設定の変更に使用されます。ただし、動きのきっかけになることはありません。 物理ドライブ (これ以降はドライブと呼びます) は、 CODESYS SoftMotion ソフトウェアオブジェクトによって AXIS_REF_SM3 (これからは軸と呼びます)。使用する管理機能ブロックに応じて、実行はドライブ、軸、またはその両方で行われます。 ファンクションブロック MC_Power ドライブのパワーステージを制御します MC_Reset 軸エラーとドライブエラーをリセット MC_SetPosition 軸の座標系を任意の値にシフトします。たとえば、これは参照に役...", 
"body" : "管理機能ブロックは、情報の照会や特定の設定の変更に使用されます。ただし、動きのきっかけになることはありません。 物理ドライブ (これ以降はドライブと呼びます) は、 CODESYS SoftMotion ソフトウェアオブジェクトによって AXIS_REF_SM3 (これからは軸と呼びます)。使用する管理機能ブロックに応じて、実行はドライブ、軸、またはその両方で行われます。 ファンクションブロック MC_Power ドライブのパワーステージを制御します MC_Reset 軸エラーとドライブエラーをリセット MC_SetPosition 軸の座標系を任意の値にシフトします。たとえば、これは参照に役立ちます。 SMC3_BrakeControl ドライブがこの機能をサポートしている場合、機械式ブレーキを制御します SMC3_BrakeStatus メカニカルブレーキの現在の状態を読み取ります SMC_ChangeDynamicLimits 軸のダイナミックリミット (速度、加速、減速、ジャーク、トルク) を設定します 詳細については、以下を参照してください。の動的制限 タブ：一般SMC_ChangeAxisScalingLinear 直線軸のスケーリングを変更します SMC_ChangeAxisScalingRotary 回転軸のスケーリングを変更します SMC_SetForecast を設定します 予報 軸の SMC_GetForecast 軸の設定された予測を返します SMC_GetTravelTime 軸が特定の位置に達した時間を返します。これは、と組み合わせると特に便利です 予報。 SMC_SetAdditionalConversionFactors 変換のその他の要素を設定します。たとえば、トルクの係数を使用してギアボックスを考慮に入れることができます SMC_SetControllerMode ドライブがこの機能をサポートしている場合、軸に別の操作モードを設定します SMC_SetMovementType 仮想軸の移動タイプを次のように設定します。 制限付き または モジュロ 詳細については、以下を参照してください。 タブ：一般。 SMC_SetRampType 軸の速度ランプタイプを設定します 詳細については、以下を参照してください。 ベロシティランプタイプ で タブ：一般 チャプター SMC_SetSoftwareLimits 制限された軸の位置制限とエラー発生時の対応する反応を設定します 詳細については、以下を参照してください。 ソフトウェア・リミット・スイッチ そして ソフトウェアエラーリアクション で タブ：一般 チャプター MC_TouchProbe 定義したトリガーイベントが発生したときのドライブ位置を返します MC_AbortTrigger トリガーイベントを使用する関数を中止します (例: MC_TouchProbe ) SMC_ReadFBError 軸のファンクションブロックエラーメモリから最も古いエントリを返します。この情報は、たとえばビジュアライゼーションでの表示に使用できます。 SMC_ClearFBError 軸のファンクションブロックエラーメモリから最も古いエントリを削除します。 SMC_ReadSetPosition 軸の設定位置を返します SMC_ReadSetValues 設定位置、設定速度、設定加速度、設定ジャークを返します。いつ 予報 を有効にすると、後でデータをクエリすることもできます。 詳細については、以下を参照してください。 SMC_SetForecast MC_ReadActualPosition ドライブの実際の位置を返します MC_ReadActualVelocity ドライブの実際の速度を返します MC_ReadActualTorque ドライブの実際のトルクまたは実際の力を返します。 MC_ReadAxisError ドライブからエラーを読み取ります MC_ReadStatus 軸の現在の状態を読み取ります SMC_CheckAxisCommunication 軸の通信状態を返します SMC_CheckLimits 現在の設定値が軸の設定ダイナミック制限を超えているかどうかをチェックします 詳細については、以下を参照してください。 SMC_ダイナミックリミットの変更 そして ダイナミックリミット で タブ：一般SMC_GetTrackingError 軸のラグ (軸の設定位置とドライブの実際の位置との差) を返します SMC_InPosition ラグが設定可能な範囲内にあるかどうかを返します SMC_MeasureDistance ブロックが開始されてから軸が移動した距離を返します。これは特にモジュロ軸の場合に便利です MC_ReadBoolParameter 軸またはドライブから Boolean 値を読み取ります MC_ReadParameter 軸またはドライブから値を読み取ります MC_WriteBoolParameter Boolean 値を軸またはドライブに書き込みます MC_WriteParameter 軸またはドライブに値を書き込みます 診断機能ブロック SMC_AxisDiagnosticLog 軸とドライブの設定値と実際の値 (位置、速度、加速度) をファイルに周期的に書き込みます。これは、他のツールのエラーや動作シーケンスの診断に役立ちます SMC_GetMaxSetVelocity 軸の設定速度の最大値を記録します。このファンクションブロックは診断に役立ちます。 SMC_GetMaxSetAccDec 設定した軸の加速度の最大値を記録します。このファンクションブロックは診断に役立ちます。 パーシスト SMC3_PersistPosition アブソリュートエンコーダーで軸の位置を固定 「Persist」の詳細については、以下を参照してください。 軸位置の永続化SMC3_PersistPositionLogical 論理軸の位置を維持します 論理軸の詳細については、以下を参照してください。 論理ドライブ" }, 
{ "title" : "単軸動作 ", 
"url" : "_sm_basic_single_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 単軸動作 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概要 ", 
"url" : "_sm_overview_single_axis_movement.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 単軸動作 \/ 概要 ", 
"snippet" : "CODESYS SoftMotion 単一の軸にのみ作用する動きと、2つの軸が同期する動き（例えば、電子カムや仮想ギアを介して）を区別します。後者は、 2軸の同期動作 ヘルプページ。 基本的に、単一の軸のみに作用するモーション ブロックは、次のカテゴリに分類できます。 モーションブロック ブロック 説明 MC_MoveAbsolute 指定された位置への移動を実行します MC_MoveRelative 現在の位置を基準に指定された距離だけ移動を実行します MC_MoveAdditive 別の動作の最後に指示された目標位置を基準として指定された距離だけ動作を実行します（たとえば、 MC_Move...", 
"body" : "CODESYS SoftMotion 単一の軸にのみ作用する動きと、2つの軸が同期する動き（例えば、電子カムや仮想ギアを介して）を区別します。後者は、 2軸の同期動作 ヘルプページ。 基本的に、単一の軸のみに作用するモーション ブロックは、次のカテゴリに分類できます。 モーションブロック ブロック 説明 MC_MoveAbsolute 指定された位置への移動を実行します MC_MoveRelative 現在の位置を基準に指定された距離だけ移動を実行します MC_MoveAdditive 別の動作の最後に指示された目標位置を基準として指定された距離だけ動作を実行します（たとえば、 MC_MoveAbsolute ） MC_MoveSuperimposed 指定された相対距離の移動を、別のアクティブな移動（例えば、 MC_MoveAbsolute ）。アクティブな動作は中止されません。 MC_MoveVelocity 指定された速度で連続的に動く動作を実行します SMC_MoveContinuousAbsolute 指定された位置への移動を実行します。この場合、定義された速度で目標位置に到達し、その後その速度が維持されます。 SMC_MoveContinuousRelative 現在の位置を基準として指定された距離だけ移動を実行します。この場合、定義された速度で目標位置に到達し、その後その速度が維持されます。 MC_Jog 軸が前方または後方に移動する限り、指定された速度で連続的に移動する動作を実行します。 SMC_Inch 軸が前方または後方に移動する限り、現在の位置に対して指定された距離だけ移動を実行します。 動きの停止 ブロック 説明 MC_Halt 制御された停止を実行し、アクティブな動きを中断し、軸を停止させます。 MC_Halt 停止は新たな動作によって中断される可能性があるため、通常の動作条件を対象としています。また、軸は動作状態のままであるため、停止後も動作をより簡単に再開できます。 MC_Stop 制御された停止を実行し、アクティブな動きを中断し、軸を停止させます。 MC_Stop 停止は新たな動きによって中断されないため、緊急時用に設計されています。停止後は軸は停止状態となり、新たな動きは受け付けられません。新たな動きは停止が完了し、 Execute 入力は FALSE 。 MC_HaltSuperImposed 制御された停止を実行します SuperImposed 動き。基礎となる動きはプロセス中に中止されない。 ホーミング ブロック 説明 MC_Home ドライブによって制御される軸の原点復帰を開始します。操作とそのパラメータは、ドライブと製造元によって異なります。 SMC_Homing コントローラによって制御される軸の原点復帰を開始します MC_SetPosition 軸は移動せず、ゼロ点のみをシフトします。このように、ブロックは参照などに使用できます。また、アクティブな移動中にブロックを呼び出すこともできます。 特別な動き ブロック 説明 SMC_FollowPosition 軸の設定位置を書き込みます。これを使用して、独自に計算した軌道を軸に渡すことができます。 SMC_FollowVelocity 軸の設定速度を書き込みます。これを使用して、独自に計算した軌道を軸に渡すことができます。 SMC_FollowPositionVelocity 軸の設定位置と速度を書き込みます。これを使用して、独自に計算した軌道を軸に渡すことができます。 SMC_FollowSetValues 軸の設定位置、速度、加速度、ジャーク、および\/または設定目標トルクを選択的に書き込みます。これを使用して、独自に計算した軌道を軸に渡すことができます。 SMC_SetTorque 軸の設定トルクを書き込みます。軸の動作モードに応じて、値はトルク フィード フォワード制御に使用されるか、軸が適用するトルクとして使用されます。 " }, 
{ "title" : "動きの中断 ", 
"url" : "_sm_interrupt_single_axis_movement.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 単軸動作 \/ 動きの中断 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "単軸運動の中断 ", 
"url" : "_sm_interrupt_single_axis_movement.html#UUID-1984849b-9835-f096-d6a5-a51b59ed2387_section-idm234855926060424", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 単軸動作 \/ 動きの中断 \/ 単軸運動の中断 ", 
"snippet" : "単軸の動き (例: MC_ムーブアブソリュート 、他の動きによっていつでも中断される可能性があります。これは、別の位置への移動、または同じ種類の動きと同じ位置への最大速度、加速度、またはジャークの変化である可能性があります。割り込みは、速度が急上昇しないように実装されています。どのタイプの二次ランプでも、加速度に急激な変化はありません 特定のケースでは、動きが中止されたために軸の逆転が避けられないことがあります。 の新しいターゲット位置の場合 MC_MoveAbsolute 現在の減速距離の終了前に存在します 中止された動きに対してより小さい最大減速および\/またはより小さい最大ジャークが使用さ...", 
"body" : "単軸の動き (例: MC_ムーブアブソリュート 、他の動きによっていつでも中断される可能性があります。これは、別の位置への移動、または同じ種類の動きと同じ位置への最大速度、加速度、またはジャークの変化である可能性があります。割り込みは、速度が急上昇しないように実装されています。どのタイプの二次ランプでも、加速度に急激な変化はありません 特定のケースでは、動きが中止されたために軸の逆転が避けられないことがあります。 の新しいターゲット位置の場合 MC_MoveAbsolute 現在の減速距離の終了前に存在します 中止された動きに対してより小さい最大減速および\/またはより小さい最大ジャークが使用された場合、その結果、減速距離が目標位置を超えて延長されます。 もし SMC_MoveContinuousAbsolute または SMC_MoveContinuousRelative と併用されます。 EndVelocity 現在の軸の状態からは反転しないと到達できません。 ランプがタイプされるとき sin² そして 二次 (スムーズ) を使用した場合、必要がないように見えても、中断中に逆転が発生する可能性があります。(つまり、上記の理由が当てはまらない場合でも。以下の説明を参照してください。)そうすると、新しいターゲット位置が古いターゲット位置より前には位置していなくても、オーバートラベルされてしまう可能性があります。これは、最大減速と最大ジャークが変化せず (あるいは増加せず)、中止された動きと比べて最終速度が変わらない場合でも起こり得ます。この場合、以下のルールが適用されます 台形および二次ランプタイプの場合、オーバートラベルは発生しません。 の場合 sin² ランプタイプで、新しい目標位置と加速度と減速の制限値が古い値と等しい場合、オーバートラベルは発生しません。 それ以外の場合は、オーバートラベルが発生する可能性があります sin² そして 二次 (スムーズ) ランプタイプ。 の説明 sin² ランプタイプ:中止された動作は、新しい sin² 速度ランプから始まります。つまり、加速度は 0 から始まり、徐々に増減します。中止時に軸の加速度が 0 でない場合、sin² 速度ランプの開始時に加速度は 0 にジャンプします。加速度の増減には時間がかかるため、これはオーバートラベルにつながる可能性があります の説明 二次法 (平滑化) ランプタイプ:と同じ説明が当てはまります sin² だが加速の代わりにジャークのためだ オーバーライドに関する注意 上記の説明に基づいて、 MC_SetOverride と sin² そして 二次 (平滑化) ランプタイプはお勧めしません。 " }, 
{ "title" : "減速フェーズ中の中断 ", 
"url" : "_sm_interrupt_single_axis_movement.html#UUID-1984849b-9835-f096-d6a5-a51b59ed2387_id_fbc677d73098ed1c0a86463411e7edd_id_b5d8fdf3fc0362bfc0a8658d00b6a52e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 単軸動作 \/ 動きの中断 \/ 減速フェーズ中の中断 ", 
"snippet" : "のような単軸の動き MC_MoveAbsolute 、他の動きによっていつでも中断される可能性があります。これは、別の位置への移動、または速度や加速度の変化である可能性があります。基本的に、動きの中断は、速度のジャンプがないように別の動きの中断によって実装されます。すべてのランプタイプ（を除く） 台形 ）、加速のジャンプもありません。ランプタイプの場合 sin² と 二次（スムーズ） を使用すると、中断中に反転が発生する可能性があり、最初は必要ないように見えます（説明を参照）。次に、新しい目標位置は、古い目標位置の前に配置されていませんが、オーバートラベルされます。これは、次の状況で発生する可...", 
"body" : "のような単軸の動き MC_MoveAbsolute 、他の動きによっていつでも中断される可能性があります。これは、別の位置への移動、または速度や加速度の変化である可能性があります。基本的に、動きの中断は、速度のジャンプがないように別の動きの中断によって実装されます。すべてのランプタイプ（を除く） 台形 ）、加速のジャンプもありません。ランプタイプの場合 sin² と 二次（スムーズ） を使用すると、中断中に反転が発生する可能性があり、最初は必要ないように見えます（説明を参照）。次に、新しい目標位置は、古い目標位置の前に配置されていませんが、オーバートラベルされます。これは、次の状況で発生する可能性があります。 キャンセル動作の最大減速度値を以前より小さく設定した場合 この場合、新しい目標位置までの利用可能な減速距離が短すぎる可能性があります（すべてのランプタイプで）。 したがって、 二次 と 二次（スムーズ） ジャークに低い最大値が設定されている場合のランプタイプ ただし、これらの最大値が変更されない（または増加する）場合は、次のルールが適用されます。 にとって 台形 と 二次 ランプタイプでは、オーバートラベルはありません。 のために sin² ランプタイプの場合、新しい目標位置と加速および減速の制限値が古い値と等しい場合、オーバートラベルはありません。 他のすべての場合、 sin² と 二次（スムーズ） ランプタイプ。 " }, 
{ "title" : "2軸の同期動作 ", 
"url" : "_sm_basic_synch_movements_2_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概要 ", 
"url" : "_sm_overview_synch_movements_2_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ 概要 ", 
"snippet" : "このセクションでは、1 つの軸が別の軸と同期して移動する動作の概要を説明します (時間または位置によって異なります)。 カム: ドライブ (マスター) に応じて、別のドライブ (スレーブ) が定義されたあらゆる種類の動作を実行する必要があります。詳細については、以下を参照してください。 カム定義された伝達比を使用して2つの軸を同期させる MC_ギアイン 、 MC_ギアアウト 、 そして MC_ギアインポジション これらの関数の詳細については、それぞれの関数ブロックのドキュメントを参照してください。 マスター軸とスレーブ軸間の位相オフセット MC_フェージング この関数の詳細については、関数ブロ...", 
"body" : "このセクションでは、1 つの軸が別の軸と同期して移動する動作の概要を説明します (時間または位置によって異なります)。 カム: ドライブ (マスター) に応じて、別のドライブ (スレーブ) が定義されたあらゆる種類の動作を実行する必要があります。詳細については、以下を参照してください。 カム定義された伝達比を使用して2つの軸を同期させる MC_ギアイン 、 MC_ギアアウト 、 そして MC_ギアインポジション これらの関数の詳細については、それぞれの関数ブロックのドキュメントを参照してください。 マスター軸とスレーブ軸間の位相オフセット MC_フェージング この関数の詳細については、関数ブロックのドキュメントを参照してください。 機械部品（例えばギアボックス）間のバックラッシュを補正する SMC_バックラッシュ補正 この関数の詳細については、関数ブロックのドキュメントを参照してください。 " }, 
{ "title" : "カム ", 
"url" : "_sm_f_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概要 ", 
"url" : "_sm_overview_synch_movements_2_axis_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ 概要 ", 
"snippet" : "の SoftMotion camはユーザーインターフェースに統合されています CODESYS カムエディタでは、カムとタペットをグラフィカルに、またはテーブルを使用して実装できます。対応するアプリケーションのコードが生成されるとすぐに、IECプログラムがアクセスできるグローバルデータ構造（「カムデータ」）が作成されます。この目的のために、 SM3_Basic SoftMotion ドライブを挿入すると、プロジェクトに自動的にリンクされます。 詳細については、以下を参照してください。 の定義 そして カムの作成方法...", 
"body" : "の SoftMotion camはユーザーインターフェースに統合されています CODESYS カムエディタでは、カムとタペットをグラフィカルに、またはテーブルを使用して実装できます。対応するアプリケーションのコードが生成されるとすぐに、IECプログラムがアクセスできるグローバルデータ構造（「カムデータ」）が作成されます。この目的のために、 SM3_Basic SoftMotion ドライブを挿入すると、プロジェクトに自動的にリンクされます。 詳細については、以下を参照してください。 の定義 そして カムの作成方法" }, 
{ "title" : "の定義 SoftMotion カム ", 
"url" : "_sm_cam_definition_softmotion_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ の定義 SoftMotion カム ", 
"snippet" : "カムは、あるドライブ（スレーブ）の別のドライブ（マスター）への機能依存性を表します。この関係は、定義された範囲のマスター値をスレーブ値にマップする連続関数（または曲線）によって記述されます。より正確に言うと、マスター軸を適切なセグメントに分割した後、これらの関数のグラフは、これらの各間隔で線または5次多項式で表すことができます。 例 カムグラフでは、マスター値が横軸に適用され、スレーブ値が縦軸に適用されます。 この例では、マスター値は0〜360です。この範囲は、次の3つの間隔に分割されます。 （1）最初の間隔：[0、140] （2）2番目の間隔：[140、280] （3）3番目の間隔：[280...", 
"body" : "カムは、あるドライブ（スレーブ）の別のドライブ（マスター）への機能依存性を表します。この関係は、定義された範囲のマスター値をスレーブ値にマップする連続関数（または曲線）によって記述されます。より正確に言うと、マスター軸を適切なセグメントに分割した後、これらの関数のグラフは、これらの各間隔で線または5次多項式で表すことができます。 例 カムグラフでは、マスター値が横軸に適用され、スレーブ値が縦軸に適用されます。 この例では、マスター値は0〜360です。この範囲は、次の3つの間隔に分割されます。 （1）最初の間隔：[0、140] （2）2番目の間隔：[140、280] （3）3番目の間隔：[280、360] 関数（グラフ）は1番目と3番目の間隔で線形であり、そのグラフは線として表示されます。その結果、その1次導関数（勾配）は一定であり、すべての高次導関数は0です。 2番目の区間では、グラフは5次多項式で記述されます。したがって、その1次導関数は4次多項式、2次導関数（曲線）は3次多項式、3次導関数は2次多項式などです。 関数がマスターの位置に応じたスレーブの動きを記述する場合、その1次導関数はスレーブの速度に対応し、2次導関数はその加速度に対応します。 この物理的な解釈を念頭に置くと、マッピングが継続的でなければならないことは明らかです。これは、そのグラフにジャンプが許可されていないことを意味します。特に、2つの間隔が交わる各ポイントで連続性も満たされる必要があります。さらに、一般に連続性は一次および二次導関数によっても必要とされます。 （実際、区間の始点と終点でのこれらの3つの連続性条件は、2つの直線セグメントの間に挿入される5次多項式の係数を決定します。 さらに、任意の位置でカムにタペット（バイナリスイッチ）を追加できます。このようにして、タペットのみを含むカムテーブルを作成できます。次に、マスター値の範囲全体でスレーブ位置がゼロに設定されます。 " }, 
{ "title" : "定義済みセグメントタイプの概要 ", 
"url" : "_sm_overview_segment_types.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ 定義済みセグメントタイプの概要 ", 
"snippet" : "CODESYS SoftMotion には、カム用のさまざまなセグメントタイプが用意されています。 に応じて コンパイル形式 、一部のセグメントタイプのみがサポートされています。 XYVA: ラインとポリゴン 5 のみ。 セグメント:すべてのセグメントタイプがサポートされています。 セグメントタイプ パラメーター カーブ Poly7 境界条件 マスターポジション スレーブポジション スレーブ速度 スレーブ加速 スレーブジャーク Poly5 境界条件 マスターポジション スレーブポジション スレーブ速度 スレーブ加速 ModifiedSine 境界条件 マスターポジション スレーブポジション ス...", 
"body" : "CODESYS SoftMotion には、カム用のさまざまなセグメントタイプが用意されています。 に応じて コンパイル形式 、一部のセグメントタイプのみがサポートされています。 XYVA: ラインとポリゴン 5 のみ。 セグメント:すべてのセグメントタイプがサポートされています。 セグメントタイプ パラメーター カーブ Poly7 境界条件 マスターポジション スレーブポジション スレーブ速度 スレーブ加速 スレーブジャーク Poly5 境界条件 マスターポジション スレーブポジション スレーブ速度 スレーブ加速 ModifiedSine 境界条件 マスターポジション スレーブポジション スレーブ速度 セグメントパラメーター いずれかの変曲点パラメーター λ (0≤λ≤1) または加速度パラメーター C a * (最大減速) Line 境界条件 マスターポジション スレーブポジション InclinedSine 境界条件 マスターポジション スレーブポジション セグメントタイプにはそれぞれ特殊な動的プロパティがあるため、どのセグメントタイプを選択するかはアプリケーションによって異なります。移動タスクに応じて、適用できるセグメントタイプはさまざまです (例えば、ドウェル — 一定速度) 次の表は概要を示しています。 ドウェル (v=0, a=0) 一定速度 (v­­≠0, a=0) リバーサル (v=0, a≠0) ムーブメント (v≠0, a≠0) ドウェル (v=0, a=0) Line Poly5\/7 InclinedSine ModifiedSine Poly5\/7 ModifiedSine Poly5\/7 Poly5\/7 一定速度 (v≠0, a=0) Poly5\/7 ModifiedSine Line Poly5\/7 ModifiedSine Poly5\/7 Poly5\/7 リバーサル (v=0, a≠0) Poly5\/7 Poly5\/7 Poly5\/7 Poly5\/7 ムーブメント (v≠0, a≠0) Poly5\/7 Poly5\/7 Poly5\/7 Poly5\/7 " }, 
{ "title" : "カムエディタの構造 ", 
"url" : "_sm_cam_editor_layout.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ カムエディタの構造 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概要 ", 
"url" : "_sm_overview_synch_movements_2_axis_cam_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ カムエディタの構造 \/ 概要 ", 
"snippet" : "ダブルクリックしてカムエディタを開きます。 カム デバイス ツリー内のオブジェクト。 エディターは次のタブで構成されています。 タブ：カム タブ: このエディターでは、グラフィカル エディターを使用してカム パスを作成します。ここでは、スレーブの位置、スレーブの速度、スレーブの加速度、スレーブのジャークを表示および変更できます。グラフィカル エディターでは、高加速度の動きをプログラムするとすぐに認識できます。 カムテーブル タブ: このエディターでは、ベース ポイントがテーブルに表示されます。ここで、正確な位置と速度を指定できます。 タペット タブ: このエディターでは、タペット (スイッチ ...", 
"body" : "ダブルクリックしてカムエディタを開きます。 カム デバイス ツリー内のオブジェクト。 エディターは次のタブで構成されています。 タブ：カム タブ: このエディターでは、グラフィカル エディターを使用してカム パスを作成します。ここでは、スレーブの位置、スレーブの速度、スレーブの加速度、スレーブのジャークを表示および変更できます。グラフィカル エディターでは、高加速度の動きをプログラムするとすぐに認識できます。 カムテーブル タブ: このエディターでは、ベース ポイントがテーブルに表示されます。ここで、正確な位置と速度を指定できます。 タペット タブ: このエディターでは、タペット (スイッチ ポイント) を図にプログラムします。この表示により、タペットの順序を非常にわかりやすく把握できます。 タペットテーブル タブ: このエディターでは、スイッチ ポイントがテーブルに表示されます。ここで、正確なスイッチ ポイントを指定できます。 タブはエディターと ツールボックス 表示および プロパティ ビュー。 カムエディタを使用したプログラム例 " }, 
{ "title" : "タブ：カム ", 
"url" : "_sm_obj_cam_table_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ カムエディタの構造 \/ タブ：カム ", 
"snippet" : "このグラフィカルエディタでは、カムグラフが定義されています。いつでも、グラフィカルエディタと代替の表形式エディタを切り替えることができます（ タブ：カムテーブル）。 エディターには 4 つのグラフの曲線が表示されます。 スレーブ位置（黒） スレーブ速度（青） スレーブ加速（緑） スレーブジャーク（黄色） 4つの座標系すべての横軸は、マスター値（[0,360]）の範囲を示しています。位置図の縦軸は、カムのプロパティで定義されている値の範囲を示しています。速度、加速度、ジャークの縦軸は自動的にスケーリングされます。 新しく挿入されたカムには、デフォルト値が割り当てられます。これは、グラフを[0,1...", 
"body" : "このグラフィカルエディタでは、カムグラフが定義されています。いつでも、グラフィカルエディタと代替の表形式エディタを切り替えることができます（ タブ：カムテーブル）。 エディターには 4 つのグラフの曲線が表示されます。 スレーブ位置（黒） スレーブ速度（青） スレーブ加速（緑） スレーブジャーク（黄色） 4つの座標系すべての横軸は、マスター値（[0,360]）の範囲を示しています。位置図の縦軸は、カムのプロパティで定義されている値の範囲を示しています。速度、加速度、ジャークの縦軸は自動的にスケーリングされます。 新しく挿入されたカムには、デフォルト値が割り当てられます。これは、グラフを[0,120]、[120,240]、および[240,360]の3つのセクションに分割する4つのポイントで構成されています。カムグラフの各区間部分は、タイプPoly5（5次多項式）です。 すべてのカーブを編集できます。速度、加速度、およびジャークは派生カーブなので、グラフの 1 つを変更すると他のグラフにも影響します 水平分離バーを移動して、ダイアグラムの高さを変更します。 ビュー： ツールボックス 選択する このツールを使用して、テーブル内の行を選択します。 を押すと、選択したポイントが削除されます デル 鍵。 ポイントを追加 このツールで新しいポイントを追加します。図の挿入ポイントをクリックします。次に、グラフは、その曲線が新しく挿入されたポイントを通過するように自動的に調整されます。 「プロパティ」ビュー X スレーブ軸のX位置 Y スレーブ軸のY位置 V スレーブ軸の速度 A スレーブ軸の加速 J 奴隷軸のジャーク 詳細については、以下を参照してください。 ダイアログ：プロパティ–カム と カムの作成方法" }, 
{ "title" : "タブ：カムテーブル ", 
"url" : "_sm_obj_cam_table_cam_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ カムエディタの構造 \/ タブ：カムテーブル ", 
"snippet" : "グラフィカルエディタの代わりに、カムテーブルでカムグラフを定義することもできます（ カム タブ）。表形式のエディターとグラフィカルなエディターはいつでも切り替えることができます。 テーブルの最初の行には常にマスターの開始位置（および関連するスレーブ値）が含まれ、最後の行は常に終了位置です。中間の線は、セグメントとポイントを交互に定義します。 新しい行を挿入します 選択したセグメントを削除します X スレーブ軸のX位置 Y スレーブ軸のY位置 V スレーブ軸の速度 A スレーブ軸の加速 J 奴隷軸のジャーク セグメントタイプ Line : ライン Poly5 : 5 次多項式 Poly7 : 7...", 
"body" : "グラフィカルエディタの代わりに、カムテーブルでカムグラフを定義することもできます（ カム タブ）。表形式のエディターとグラフィカルなエディターはいつでも切り替えることができます。 テーブルの最初の行には常にマスターの開始位置（および関連するスレーブ値）が含まれ、最後の行は常に終了位置です。中間の線は、セグメントとポイントを交互に定義します。 新しい行を挿入します 選択したセグメントを削除します X スレーブ軸のX位置 Y スレーブ軸のY位置 V スレーブ軸の速度 A スレーブ軸の加速 J 奴隷軸のジャーク セグメントタイプ Line : ライン Poly5 : 5 次多項式 Poly7 : 7 次多項式 InclinedSine : 傾斜正弦線 ModifiedSine : 修正正弦線 ラムダ 修正された正弦線の変曲点パラメーター アクセラレーションパラメーター 修正された正弦線の最大遅延パラメーター 以下の値は、それぞれのセグメントの値から得られたものです。変更することはできません。 min（位置） スレーブ位置の最小値 max（位置） スレーブ位置の最大値 max（速度） マスター軸に基づくスレーブの速度の最大値 max（加速度） マスター軸に基づくスレーブの加速度の最大値 ビュー： ツールボックス 選択する このツールを使用して、テーブル内の行を選択します。 を押すと、選択したポイントが削除されます デル 鍵。 詳細については、以下を参照してください。 ダイアログ：プロパティ–カム と カムの作成方法" }, 
{ "title" : "タブ：タペット ", 
"url" : "_sm_obj_cam_table_tappets.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ カムエディタの構造 \/ タブ：タペット ", 
"snippet" : "このグラフィカルエディタでは、タペットパスが定義されています。タペットパスは、マスター位置に応じて1つ以上のタペットを定義します。エディタウィンドウの上端で、横軸がマスター位置の範囲に近づいています。個々のタペットパスは以下のとおりです。 いつでも、グラフィカルエディタと代替の表形式エディタを切り替えることができます（ タブ：タペットテーブル）。 タペットパスの「トラックID」 タペットパスのすべてのタペットは、同じタペットスイッチ（タイプBOOLの変数）を参照します。 ビュー： ツールボックス 選択する このツールを使用して、タペットを選択します。選択したタペットを別の位置にドラッグできます...", 
"body" : "このグラフィカルエディタでは、タペットパスが定義されています。タペットパスは、マスター位置に応じて1つ以上のタペットを定義します。エディタウィンドウの上端で、横軸がマスター位置の範囲に近づいています。個々のタペットパスは以下のとおりです。 いつでも、グラフィカルエディタと代替の表形式エディタを切り替えることができます（ タブ：タペットテーブル）。 タペットパスの「トラックID」 タペットパスのすべてのタペットは、同じタペットスイッチ（タイプBOOLの変数）を参照します。 ビュー： ツールボックス 選択する このツールを使用して、タペットを選択します。選択したタペットを別の位置にドラッグできます。 タペットのスイッチのオン\/オフ属性を変更するには、 交差線。 を押して、選択したタペットを削除します デル 鍵。 このツールで新しいタペットを追加します。パスの挿入ポイントをクリックします。 「プロパティ」ビュー タペットは、マスター軸の位置から正（マスター値の増加）または負の方向に渡された場合、結果に割り当てられます。 X タペットの位置 ポジティブパス オン\/オフ属性を切り替えます 何もしない オンに切り替えます オフに切り替えます 反転 ネガティブパス オン\/オフ属性を切り替えます 何もしない オンに切り替えます オフに切り替えます 反転 タペット属性の可能な組み合わせの表 タペットシンボル ポジティブパス ネガティブパス 何もしない 何もしない オンに切り替えます 何もしない オフに切り替えます 何もしない 何もしない オンに切り替えます 何もしない オフに切り替えます オンに切り替えます オフに切り替えます オンに切り替えます オフに切り替えます オフに切り替えます オンに切り替えます オフに切り替えます オフに切り替えます 反転 何もしない 何もしない 反転 オンに切り替えます 反転 反転 オンに切り替えます 反転 オフに切り替えます オフに切り替えます 反転 反転 反転 詳細については、以下を参照してください。 スイッチポイントを定義する方法" }, 
{ "title" : "タブ：タペットテーブル ", 
"url" : "_sm_obj_cam_table_tappet_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ カムエディタの構造 \/ タブ：タペットテーブル ", 
"snippet" : "この表形式の表では、グラフィカルエディタの代わりにタペットパスを設定することもできます（ タブ：タペット）。タペットパスは、マスター位置に応じて1つ以上のタペットを定義します。表では、それぞれのタペットの定義を含む行が、タペットパスを定義する各行の下にリストされています。 表形式のエディターとグラフィカルなエディターはいつでも切り替えることができます。 新しいタペットを挿入します タペットを削除します トラックID タペットパスのID タペットパスのすべてのタペットは、同じタペットスイッチ（タイプBOOLの変数）を参照します。 X タペットの位置 ポジティブパス オン\/オフ属性を切り替えます ...", 
"body" : "この表形式の表では、グラフィカルエディタの代わりにタペットパスを設定することもできます（ タブ：タペット）。タペットパスは、マスター位置に応じて1つ以上のタペットを定義します。表では、それぞれのタペットの定義を含む行が、タペットパスを定義する各行の下にリストされています。 表形式のエディターとグラフィカルなエディターはいつでも切り替えることができます。 新しいタペットを挿入します タペットを削除します トラックID タペットパスのID タペットパスのすべてのタペットは、同じタペットスイッチ（タイプBOOLの変数）を参照します。 X タペットの位置 ポジティブパス オン\/オフ属性を切り替えます 何もしない オンに切り替えます オフに切り替えます 反転 ネガティブパス オン\/オフ属性を切り替えます 何もしない オンに切り替えます オフに切り替えます 反転 ビュー： プロパティ タペットは、マスター軸の位置から正（マスター値の増加）または負の方向に渡された場合、結果に割り当てられます。 X タペットの位置 ポジティブパス オン\/オフ属性を切り替えます 何もしない オンに切り替えます オフに切り替えます 反転 ネガティブパス オン\/オフ属性を切り替えます 何もしない オンに切り替えます オフに切り替えます 反転 詳細については、以下を参照してください。 スイッチポイントを定義する方法" }, 
{ "title" : "カムの作成方法 ", 
"url" : "_sm_cam_creating_a_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ カムの作成方法 ", 
"snippet" : "カムを作成する手順は、8つのスロット（45°分割）を備えた回転台を説明するサンプルアプリケーションを使用して説明されています。内部には超音波で融着された部品があります。回転台が回転した後、溶接工具はリニアドライブによって供給されます。溶接後、直線軸が戻り、回転台が回転し続けます。 作業手順 回転台が45°回転します（持続時間：400ms）。 溶接ヘッドを垂直軸250mm（持続時間：200ms）だけ下に動かします。 溶接を開始します（持続時間：1200ms）。 溶接ヘッドは、垂直軸250 mm（持続時間：200 ms）だけ上に移動します。 合計時間から2000ミリ秒のサイクルタイムが発生します。...", 
"body" : "カムを作成する手順は、8つのスロット（45°分割）を備えた回転台を説明するサンプルアプリケーションを使用して説明されています。内部には超音波で融着された部品があります。回転台が回転した後、溶接工具はリニアドライブによって供給されます。溶接後、直線軸が戻り、回転台が回転し続けます。 作業手順 回転台が45°回転します（持続時間：400ms）。 溶接ヘッドを垂直軸250mm（持続時間：200ms）だけ下に動かします。 溶接を開始します（持続時間：1200ms）。 溶接ヘッドは、垂直軸250 mm（持続時間：200 ms）だけ上に移動します。 合計時間から2000ミリ秒のサイクルタイムが発生します。 アプリケーションは、継続的に実行される（モジュロ）仮想マスター軸によって実装されます。軸の終了値は、2000msのサイクルタイムに従って予測されます。回転台はカムとして実現されます（モジュロ;終了値：45°）。縦軸もカムとして実現（制限あり、最終値：300mm）。溶接プロセスはタペットによって制御されます。 カムのプロパティの設定 を選択 ロータリーテーブル、回転盤 デバイスツリーのカム。 クリック プロパティ の中に 意見 メニューまたはコンテキストメニュー。 を選択 カム タブ。 次の値を指定します。 マスター開始位置 ：0 マスターエンドポジション ：2000 スレーブ開始位置 ：0 スレーブ終了位置 ：45 スムーズな移行 ： （無効） クリック わかった ダイアログを終了します。カムオブジェクトを変更するためのダイアログを確認します。 の値を変更します 縦軸 同じ方法でカム： マスター開始位置 ：0 マスターエンドポジション ：2000 スレーブ開始位置 ：0 スレーブ終了位置 ：300 スムーズな移行 ： （有効） クリック わかった ダイアログを終了します。カムオブジェクトを変更するためのダイアログを確認します。 " }, 
{ "title" : "デバイスツリーにカムを追加する ", 
"url" : "_sm_cam_creating_a_cam.html#UUID-7c227a8f-47be-4a95-ca96-f0cd1d78635d_id_edb85f246cc9d9f4c0a8646368ed3bd6_id_fa86c256038b2152c0a864632d864483", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ カムの作成方法 \/ デバイスツリーにカムを追加する ", 
"snippet" : "要件：SoftMotionコントローラーが選択されている。 デバイスツリーで、 応用 物体。 クリック プロジェクト→オブジェクトの追加→カムテーブル 。 名前を指定してください ロータリーテーブル、回転盤 カムの場合はクリックします わかった 。 オブジェクトがデバイスツリーに挿入されます。カムエディタが開きます。 名前の付いた別のカムを挿入します 縦軸 。...", 
"body" : "要件：SoftMotionコントローラーが選択されている。 デバイスツリーで、 応用 物体。 クリック プロジェクト→オブジェクトの追加→カムテーブル 。 名前を指定してください ロータリーテーブル、回転盤 カムの場合はクリックします わかった 。 オブジェクトがデバイスツリーに挿入されます。カムエディタが開きます。 名前の付いた別のカムを挿入します 縦軸 。 " }, 
{ "title" : "カムパスを変更する方法 ", 
"url" : "_sm_cam_changing_the_course.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ カムパスを変更する方法 ", 
"snippet" : "これらの手順では、 カムの作成方法 カムを交換する方法を示す章。...", 
"body" : "これらの手順では、 カムの作成方法 カムを交換する方法を示す章。 " }, 
{ "title" : "グラフィカルエディタでパスを変更する ", 
"url" : "_sm_cam_changing_the_course.html#UUID-709e6439-f0d2-35ec-865b-a7484c34883c_id_c04b066ccb6844c0a8646367ecded3_id_0e7e8ac72c554f26c0a86463347ccca5", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ カムパスを変更する方法 \/ グラフィカルエディタでパスを変更する ", 
"snippet" : "を開きます ロータリーテーブル、回転盤 エディターのカム。 The カム タブが表示されます。 120のポイントを選択し、Deleteキーを押して削除します（ デル ）。 240のポイントも削除します。 を選択 ポイントを追加 からのツール ツールボックス 見る。 マウスポインタをエディタに移動すると、マウスポインタが十字に変わります。 近くをクリック マスターポジション 400と スレーブ位置 上のグラフの45（スレーブ位置）。 スレーブ位置のカーブが変更されます。速度、加速度、ジャークの曲線も変化します。 新しく挿入された点をクリックして選択します。 ポイントを別の位置にドラッグします。 ...", 
"body" : "を開きます ロータリーテーブル、回転盤 エディターのカム。 The カム タブが表示されます。 120のポイントを選択し、Deleteキーを押して削除します（ デル ）。 240のポイントも削除します。 を選択 ポイントを追加 からのツール ツールボックス 見る。 マウスポインタをエディタに移動すると、マウスポインタが十字に変わります。 近くをクリック マスターポジション 400と スレーブ位置 上のグラフの45（スレーブ位置）。 スレーブ位置のカーブが変更されます。速度、加速度、ジャークの曲線も変化します。 新しく挿入された点をクリックして選択します。 ポイントを別の位置にドラッグします。 それに応じてスレーブ位置のカーブが調整されます。 変更 バツ と Y それぞれ400と45の正確な値にプロパティ。 同様に、マスター位置 2000 のポイントの X 値を 45 に変更します。 を選択 選択する からのツール ツールボックス 見る。 2番目の曲線要素（400〜2000）を選択します。 変更 セグメントタイプ プロパティに ライン 。 グラフィカルエディタで曲線を確認してください。 画面： " }, 
{ "title" : "カムテーブルでパスを変更する ", 
"url" : "_sm_cam_changing_the_course.html#UUID-709e6439-f0d2-35ec-865b-a7484c34883c_id_c04b066ccb6844c0a8646367ecded3_id_a888a2ff556a11e6abf6d2d0503b3e46", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ カムパスを変更する方法 \/ カムテーブルでパスを変更する ", 
"snippet" : "を開きます 縦軸 エディターのカム。 The カム タブが表示されます。 を選択 カムテーブル タブ。 クリック 120のポイントを削除する記号。240のポイントも削除します。 クリック シンボル。 （1000\/150）に新しいポイントと新しいセグメントが挿入されます。 さらに2つのポイントを追加します。 次の点の値X \/ Yを変更します。 ポイント1： 0 \/ 0 ポイント2： 400 \/ 0 ポイント3： 600 \/ 250 ポイント4： 1800 \/ 250 ポイント5： 2000 \/ 0 スレーブ位置のカーブが変更されます。速度、加速度、ジャークの曲線も変化します。 カムテーブルで、 ...", 
"body" : "を開きます 縦軸 エディターのカム。 The カム タブが表示されます。 を選択 カムテーブル タブ。 クリック 120のポイントを削除する記号。240のポイントも削除します。 クリック シンボル。 （1000\/150）に新しいポイントと新しいセグメントが挿入されます。 さらに2つのポイントを追加します。 次の点の値X \/ Yを変更します。 ポイント1： 0 \/ 0 ポイント2： 400 \/ 0 ポイント3： 600 \/ 250 ポイント4： 1800 \/ 250 ポイント5： 2000 \/ 0 スレーブ位置のカーブが変更されます。速度、加速度、ジャークの曲線も変化します。 カムテーブルで、 セグメントタイプ 1番目と3番目のセグメントの ライン 。 グラフィカルエディタで曲線を確認してください。 画面： 実際には、サイクル時間を節約するために、さまざまなカムの曲線が重なり合うものとして定義されることがよくあります。上記の例では、回転台がまだ動いている間に（たとえば、X：350で）、垂直軸がすでに動きを開始している可能性があります。 " }, 
{ "title" : "スイッチポイントを定義する方法 ", 
"url" : "_sm_cam_defining_tappets.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ スイッチポイントを定義する方法 ", 
"snippet" : "マスター位置に応じて、スイッチポイントを使用してイベントをトリガーします。たとえば、これは出力の設定または機能ブロックの呼び出しである可能性があります。 これらの手順では、 カムの作成方法 スイッチポイントを定義する方法を示す章。この例では、タペットが溶接プロセスを開始および停止します。 を開きます 縦軸 エディターのカム。 The カム タブが表示されます。 を選択 タブ：タペット。 の中に ツールボックス ビュー、を選択します タペットを追加する 道具。 マウスポインタをエディタに移動すると、マウスポインタが十字に変わります。 位置600の近くのマスター位置の下をクリックします。 タペット...", 
"body" : "マスター位置に応じて、スイッチポイントを使用してイベントをトリガーします。たとえば、これは出力の設定または機能ブロックの呼び出しである可能性があります。 これらの手順では、 カムの作成方法 スイッチポイントを定義する方法を示す章。この例では、タペットが溶接プロセスを開始および停止します。 を開きます 縦軸 エディターのカム。 The カム タブが表示されます。 を選択 タブ：タペット。 の中に ツールボックス ビュー、を選択します タペットを追加する 道具。 マウスポインタをエディタに移動すると、マウスポインタが十字に変わります。 位置600の近くのマスター位置の下をクリックします。 タペットパス1にタペットが挿入されます。 タペットを選択します。 [プロパティ]ビューでタペットの値を変更します。 バツ ：600 ポジティブパス ： スイッチをつける ネガティブパス ： 何もしない X：1800のタペットパス1に別のタペットを挿入します。 バツ ：1800 ポジティブパス ： スイッチをオフにします ネガティブパス ： 何もしない 結果を確認してください。 の値を変更することもできます ポジティブパス と ネガティブパス のそれぞれの端をクリックして 十字線。 でスイッチポイントを設定することもできることに注意してください タペットテーブル タブ。このエディターは同じオプションを提供しますが、表形式です。 " }, 
{ "title" : "プログラムによるカムの作成 ", 
"url" : "_sm_basic_cam_programmatic_creation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ プログラムによるカムの作成 ", 
"snippet" : "現在 CODESYS SoftMotion バージョン4.17.0.0、 CamBuilder ファンクション ブロックは、IEC アプリケーションで直接プログラムによってカムを作成するためのインターフェイスを提供します。 詳細については、次の例を参照してください。 プログラムによるカムの作成...", 
"body" : "現在 CODESYS SoftMotion バージョン4.17.0.0、 CamBuilder ファンクション ブロックは、IEC アプリケーションで直接プログラムによってカムを作成するためのインターフェイスを提供します。 詳細については、次の例を参照してください。 プログラムによるカムの作成" }, 
{ "title" : "CamBuilder 関数ブロックの使用 (SM 4.17.0.0 以降) ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm4552813176932834337885510319", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ プログラムによるカムの作成 \/ CamBuilder 関数ブロックの使用 (SM 4.17.0.0 以降) ", 
"snippet" : "デバイス ツリーにカム オブジェクトが作成されると、次のカムがデフォルトで作成されます。 カムは、次の 4 つの境界値を持つ 3 つの 5 次多項式で構成されます。 X Y V A 0 0 0 0 120 120 1 0 240 240 1 0 360 360 0 0 このカムをプログラム的に作成するには、 CamBuilder 関数ブロックは最初に宣言されます: VAR camBuilder : SMCB.CamBuilder; END_VAR 実装部分では、 CamBuilder インスタンスは最初に初期化する必要があります。 Poly5 その後、 Append 方法： camBuilde...", 
"body" : "デバイス ツリーにカム オブジェクトが作成されると、次のカムがデフォルトで作成されます。 カムは、次の 4 つの境界値を持つ 3 つの 5 次多項式で構成されます。 X Y V A 0 0 0 0 120 120 1 0 240 240 1 0 360 360 0 0 このカムをプログラム的に作成するには、 CamBuilder 関数ブロックは最初に宣言されます: VAR\n camBuilder : SMCB.CamBuilder;\nEND_VAR 実装部分では、 CamBuilder インスタンスは最初に初期化する必要があります。 Poly5 その後、 Append 方法： camBuilder.Init();\n \ncamBuilder.Append(\n SMCB.Poly5(\n\tSMCB.BoundImplicit(),\n\tSMCB.Bound(120, 120, 1)));\ncamBuilder.Append(\n SMCB.Poly5(\n\tSMCB.BoundImplicit(),\n\tSMCB.Bound(240, 240, 1)));\ncamBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.Bound(360, 360))); 多項式は左境界条件と右境界条件によって定義されます。例では、 BoundImplicit 関数は常に左境界に使用されます。その結果、前のセグメントの右境界条件が適用されます。 BoundImplicit 関数が最初のセグメントの左境界として使用された場合、ゼロから始まります。この例では、Poly5 セグメントは (X, Y, V, A) = (0, 0, 0, 0) です。 いつ MC_CamTableSelect そして MC_CamIn ファンクションブロックが使用されています。カムは CamBuilder ファンクションブロックは最終的に次のように変換する必要があります MC_CamRef 。これを行うには、CamBuilder の呼び出し先に応じて 2 つの方法があります バスタスクでCamBuilderを呼び出す： まず、宣言部分を対応するインスタンスで拡張する必要があります。 VAR\n    ...\n    camRef : MC_CAM_REF;\n    aCamSegments : ARRAY[1..3] OF SMC_CAM_SEGMENT;\nEND_VAR 次に、ファンクションブロックインスタンス MC_CAM_REF を使用して初期化され、書き込まれます Write の方法 CamBuilder ファンクションブロック。 SMCB.InitCamRef(camRef, ADR(aCamSegments), XSIZEOF(aCamSegments));\ncamBuilder.Write(camRef); 別のタスク（マルチタスク、マルチコア）でCamBuilderを呼び出す： 最初に、カムのマルチタスク\/マルチコアセーフインスタンスが GVL で作成されます。このインスタンスには、バスタスクと CamBuilder タスクの両方からアクセスされます。 VAR_GLOBAL\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\nEND_VAR その後、バスタスクから他のタスクでのカムの作成が開始されます。 新しいカムが他のタスクにいつ書き込まれたかをバスタスクで判断するために、プログラムは次の情報を記憶します。 CamId で STATE_INIT_ONLINE_TABLE_MULTITASK カムが作成される前。 その後、カムの作成は次のタスクで開始されます。 STATE_START_CREATE_ONLINE_TABLE_MULTITASK 状態。 次に、作成されたカムがに読み込まれます。 STATE_READ_ONLINE_TABLE_MULTITASK 状態。 PROGRAM BUS_TASK\nVAR\n    state : UDINT;\n    error : SMC_ERROR;\n    camIdBeforeCreate : UDINT;\n    camSegments: ARRAY[0..99] OF SMC_CAM_SEGMENT;\n    camRef: MC_CAM_REF;\nEND_VAR\nVAR CONSTANT\n    STATE_INIT_ONLINE_TABLE_MULTITASK : UDINT := 0;\n    STATE_START_CREATE_ONLINE_TABLE_MULTITASK : UDINT := 10;\n    STATE_READ_ONLINE_TABLE_MULTITASK : UDINT := 20;\n    STATE_ERROR : UDINT := 1000;\nEND_VAR\n\n\nCASE state OF\nSTATE_INIT_ONLINE_TABLE_MULTITASK:\n    camIdBeforeCreate := GVL.safeCam.CamId;\n\n    state := STATE_START_CREATE_ONLINE_TABLE_MULTITASK;\n\nSTATE_START_CREATE_ONLINE_TABLE_MULTITASK:\n    CamBuilderTask.BuildCam := TRUE;\n\n    state := STATE_READ_ONLINE_TABLE_MULTITASK;\n\nSTATE_READ_ONLINE_TABLE_MULTITASK:\n    IF CamBuilderTask.Error THEN\n        error := CamBuilderTask.ErrorId;\n        state := state + STATE_ERROR;\n    ELSIF GVL.safeCam.CamId <> camIdBeforeCreate THEN\n        error := GVL.safeCam.GetCopy(\n            camRef:= camRef,\n            pCamSegments:= ADR(camSegments),\n            arraySize:= XSIZEOF(camSegments));\n\n        IF error = SMC_NO_ERROR THEN\n            state := state + 10;\n        ELSE\n            state := state + STATE_ERROR;\n        END_IF\n    END_IF\nEND_CASE CamBuilderタスクでは、マルチタスク\/マルチコアセーフカムは呼び出して書き込まれます CamBuilder.WriteMulticoreSafe() : PROGRAM CamBuilderTask\nVAR_INPUT\n    BuildCam : BOOL;\nEND_VAR\nVAR_OUTPUT\n    Error : BOOL;\n    ErrorId : SMC_ERROR;\nEND_VAR\nVAR\n    camBuilder : SMCB.CamBuilder;\nEND_VAR\n\nIF BuildCam THEN\n    BuildCam := FALSE;\n\n    camBuilder.Init();\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(120, 120, 1)));\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(240, 240, 1)));\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(360, 360)));\n     \n Error := camBuilder.IsErrorPending(errorID=> ErrorId);\n\n    IF NOT Error THEN\n        ErrorId := camBuilder.WriteMulticoreSafe(GVL.safeCam);\n        Error := ErrorId <> SMC_NO_ERROR;\n    END_IF\nEND_IF " }, 
{ "title" : "暗黙的境界条件と明示的境界条件 ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433930557874", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ プログラムによるカムの作成 \/ CamBuilder 関数ブロックの使用 (SM 4.17.0.0 以降) \/ 暗黙的境界条件と明示的境界条件 ", 
"snippet" : "暗黙の境界条件は次のように定義される。 BoundImplicit 隣接セグメントへの移行が可能な限りスムーズになるようにします。これを行うには、隣接セグメントの境界条件を明示的に定義する必要があります。 Bound 方法。したがって、セグメントの左境界条件が暗黙的である場合、前のセグメントの右境界条件は明示的にする必要があります。逆に、右境界条件が暗黙的である場合、後続のセグメントの左境界条件は明示的にする必要があります。 最も一般的な使用例は、上記の例のように、セグメントの右側の境界条件のみが明示的に指定されていると考えられます。左側の境界条件が暗黙的であるため、セグメントの遷移は自動的に...", 
"body" : "暗黙の境界条件は次のように定義される。 BoundImplicit 隣接セグメントへの移行が可能な限りスムーズになるようにします。これを行うには、隣接セグメントの境界条件を明示的に定義する必要があります。 Bound 方法。したがって、セグメントの左境界条件が暗黙的である場合、前のセグメントの右境界条件は明示的にする必要があります。逆に、右境界条件が暗黙的である場合、後続のセグメントの左境界条件は明示的にする必要があります。 最も一般的な使用例は、上記の例のように、セグメントの右側の境界条件のみが明示的に指定されていると考えられます。左側の境界条件が暗黙的であるため、セグメントの遷移は自動的に可能な限りスムーズになり、定義領域にギャップはありません。次の例は、このアプローチから逸脱すると便利な単純なケースです。 スレーブ軸は位置 20 から 100 まで一定の速度で移動する必要があります。 camBuilder.Append(\n SMCB.Line(\n SMCB.Bound(20, 20),\n SMCB.Bound(100, 100))); この前後には、 Poly5 セグメントは加速と減速に使用されます。 camBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.BoundImplicit()));\ncamBuilder.Append(\n SMCB.Line(\n SMCB.Bound(20, 20),\n SMCB.Bound(100, 100)));\ncamBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.Bound(120, 120, 0))); このように定義されたカムには、Poly5 セグメント (速度は青色) に不要な加速フェーズと減速フェーズがあります。 これを避けるには、タイプセグメントのマスター位置を調整するだけで十分です。 Line (例えば、左の境界が 20 から 30 に、右の境界が 100 から 90 に) ...\ncamBuilder.Append(\n SMCB.Line(\n SMCB.Bound(30, 20),\n SMCB.Bound(90, 100)));\n... タイプのセグメントを調整する必要はない Poly5 定義された境界条件により、可能な限り滑らかに線分に自動的に追加されるため、 BoundImplicit 関数。 " }, 
{ "title" : "エラー処理 ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433930649954", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ プログラムによるカムの作成 \/ CamBuilder 関数ブロックの使用 (SM 4.17.0.0 以降) \/ エラー処理 ", 
"snippet" : "の Append 方法の CamBuilder ファンクションブロックの戻り値 TRUE セグメントが正常に追加されたときに、 FALSE エラーが発生した場合。エラーが発生すると、それ以上セグメントを追加することができなくなり、 CamBuilder 関数ブロックは、 Init メソッド。エラーの原因は、 IsErrorPending 方法： camBuilder.IsErrorPending(errorId=> errorId);...", 
"body" : "の Append 方法の CamBuilder ファンクションブロックの戻り値 TRUE セグメントが正常に追加されたときに、 FALSE エラーが発生した場合。エラーが発生すると、それ以上セグメントを追加することができなくなり、 CamBuilder 関数ブロックは、 Init メソッド。エラーの原因は、 IsErrorPending 方法： camBuilder.IsErrorPending(errorId=> errorId); " }, 
{ "title" : "データ構造 MC_CAM_REF の手動作成 (SM 4.17.0.0 より前) ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm4565212026644834337937734299", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ プログラムによるカムの作成 \/ データ構造 MC_CAM_REF の手動作成 (SM 4.17.0.0 より前) ", 
"snippet" : "使用することをお勧めします SM3_カムビルダー ライブラリ CODESYS SoftMotion 4.17.0.0。...", 
"body" : "使用することをお勧めします SM3_カムビルダー ライブラリ CODESYS SoftMotion 4.17.0.0。 " }, 
{ "title" : "カムのデータ構造 ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793858538", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ プログラムによるカムの作成 \/ データ構造 MC_CAM_REF の手動作成 (SM 4.17.0.0 より前) \/ カムのデータ構造 ", 
"snippet" : "プロジェクトのコンパイル時に、作成されたカムデータは内部的にグローバル変数リストに変換されます。 生成されたコードを表示する カム エディターでは、自動的に作成されたグローバル変数を表示できます。 各カムはデータ構造によって表される MC_CAM_REF このデータ構造には、IECプログラムまたは前処理関数と関数ブロックを使用してアクセスできます。 SM3_Basic 図書館。 カムを記述する機能ブロックは、実行時に IEC プログラムによって生成または設定することもできます。 例 データ構造の定義: TYPE mySMC_CAMTable_LREAL_10000_2 : STRUCT Tab...", 
"body" : "プロジェクトのコンパイル時に、作成されたカムデータは内部的にグローバル変数リストに変換されます。 生成されたコードを表示する カム エディターでは、自動的に作成されたグローバル変数を表示できます。 各カムはデータ構造によって表される MC_CAM_REF このデータ構造には、IECプログラムまたは前処理関数と関数ブロックを使用してアクセスできます。 SM3_Basic 図書館。 カムを記述する機能ブロックは、実行時に IEC プログラムによって生成または設定することもできます。 例 データ構造の定義: TYPE mySMC_CAMTable_LREAL_10000_2 :\nSTRUCT\n Table: ARRAY[0..9999] OF ARRAY[0..1] OF LREAL;\n (* set all scaling definitions to 0 and 1\n result: all values of the table are not scaled *)\n fEditorMasterMin: REAL := 0;\n fEditorMasterMax: REAL := 1;\n fEditorSlaveMin: REAL := 0;\n fEditorSlaveMax: REAL := 1;\n fTableMasterMin: REAL := 0;\n fTableMasterMax: REAL := 1;\n fTableSlaveMin: REAL := 0;\n fTableSlaveMax: REAL := 1;\nEND_STRUCT\nEND_TYPE データ構造のインスタンス化: Cam: MC_CAM_REF;\nCam_PointArray : mySMC_CAMTable_LREAL_10000_2; カムの計算: Cam.byType:=2;\nCam.byVarType:=6;\nCam.nTappets:=0;\nCam.strCAMName:='myCAM';\nCam.pce:= ADR(CAM_PointArray);\nFOR i:=0 TO 9999 DO\n (* example cam: master 0..360, slave 0..100,\n constant velocity *)\n Cam_PointArray.Table[i][0]:=UDINT_TO_LREAL(I)\/10000 * 360; (* X *)\n Cam_PointArray.Table[i][1]:=UDINT_TO_LREAL(I)\/10000 * 100; (* Y *)\nEND_FOR\nCam.nElements:=10000\nCam.xStart:=0.0;\nCam.xEnd:=360.0; " }, 
{ "title" : "手動で生成されたカム ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793936406", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ プログラムによるカムの作成 \/ データ構造 MC_CAM_REF の手動作成 (SM 4.17.0.0 より前) \/ 手動で生成されたカム ", 
"snippet" : "カム エディタを使用せずに IEC プログラムでカムを作成できます。 例 宣言： VAR i: INT; CAM: MC_CAM_REF := ( byType:=2, (* non-equidistant *) byVarType:=2, (* UINT *) nElements:=128, xStart:=0, xEnd:=360); Table: SMC_CAMTable_UINT_128_2 := ( fEditorMasterMin := 0, fEditorMasterMax := 360, fTableMasterMin := 0, fTableMasterMax := 6000...", 
"body" : "カム エディタを使用せずに IEC プログラムでカムを作成できます。 例 宣言： VAR\ni: INT;\nCAM: MC_CAM_REF := (\n byType:=2, (* non-equidistant *)\n byVarType:=2, (* UINT *)\n nElements:=128,\n xStart:=0,\n xEnd:=360);\nTable: SMC_CAMTable_UINT_128_2 := (\n fEditorMasterMin := 0, fEditorMasterMax := 360,\n fTableMasterMin := 0, fTableMasterMax := 6000,\n fEditorSlaveMin := 0, fEditorSlaveMax := 360,\n fTableSlaveMin := 0, fTableSlaveMax := 6000);\nEND_VAR 実装： (* Create cam disk (example straight line); unambiguous *)\nFOR i:=0 TO 127 DO\n Table.Table[i][0] := Table.Table[i][1] := REAL_TO_UINT(i \/ 127.0 * 6000);\nEND_FOR\n(* Link pointer; must be done in every cycle! *)\nCAM.pce := ADR(Table); この生成されたカムは、 MC_CamTableSelect ファンクションブロックとその出力を再利用して MC_CamIn 。 " }, 
{ "title" : "カム定義のコンパイル ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793975398", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ プログラムによるカムの作成 \/ データ構造 MC_CAM_REF の手動作成 (SM 4.17.0.0 より前) \/ カム定義のコンパイル ", 
"snippet" : "コンパイル時に、型の変数 MC_CAM_REF カム用に作成されます。カムの各セグメントの説明が含まれます。この種のデータ構造は、 MC_CamTable選択 機能ブロック。この構造は、 SM3_Basic 図書館。...", 
"body" : "コンパイル時に、型の変数 MC_CAM_REF カム用に作成されます。カムの各セグメントの説明が含まれます。この種のデータ構造は、 MC_CamTable選択 機能ブロック。この構造は、 SM3_Basic 図書館。 " }, 
{ "title" : "カムの切り替え ", 
"url" : "_sm_cam_switch_between_cams.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ カムの切り替え ", 
"snippet" : "基本的に、いつでも異なるカムを切り替えることができます。ただし、いくつかの点を考慮する必要があります。 カムエディタでは、スレーブの位置はカム関数の関数値として一意に定義されます。この関数はマスター値の範囲で定義され、次のように表すことができます。 SlavePosition = CAM( MasterPosition ) マスタードライブの現在の位置は通常、マスター値の範囲から外れているため、有効な引数を表すには、カム関数の定義範囲でマスター位置をスケーリングする必要があります。 SlavePosition = CAM( MasterScale*MasterPosition + Master...", 
"body" : "基本的に、いつでも異なるカムを切り替えることができます。ただし、いくつかの点を考慮する必要があります。 カムエディタでは、スレーブの位置はカム関数の関数値として一意に定義されます。この関数はマスター値の範囲で定義され、次のように表すことができます。 SlavePosition = CAM( MasterPosition ) マスタードライブの現在の位置は通常、マスター値の範囲から外れているため、有効な引数を表すには、カム関数の定義範囲でマスター位置をスケーリングする必要があります。 SlavePosition = CAM( MasterScale*MasterPosition + MasterOffset ) 同様に、モードでカムが開始した場合は、機能値（スレーブ位置）をスケーリングする必要があります Absolute ジャンプにつながるでしょう： SlavePosition = SlaveScale*CAM( MasterPosition ) + SlaveOffset 両方のスケーリング値を適用する必要がある場合があります。その結果、次のようになります。 Slaveposition = SlaveScale*CAM( MasterScale*Masterposition + MasterOffset ) + SlaveOffset スケーリングおよびオフセットパラメータの適切な値は、期間ごとに異なります。 カムの切り替えは、次の 3 つの方法で行うことができます。 2番目のインスタンスを介して2番目のカメラを起動します MC_CamIn と BufferMode = MC_BUFFER_MODE.Buffered 、 StartMode = relative 、 MasterAbsolute = FALSE 、 そして SlaveAbsolute = FALSE 。 現在 CODESYS SoftMotion バージョン 4.17.0.0 割り当てて新しいカムを開始します MC_CamIn.CamTableID 新しいカムに（再起動なし MC_CamIn 機能ブロックが必要です）。 次の点がユースケースに当てはまる場合は、このバリアントをお勧めします。 以下のすべてのカムは、 MasterAbsolute = FALSE また SlaveAbsolute = FALSE 。 新しいカムは、前のカムの最後から正確に開始する必要があります。 他のパラメーターは変更されません（例： SlaveOffset ）。 定期的なカムと次の例で説明されているジャンプ SlaveAbsolute = FALSE 、します いいえ 次のカムは前のカムの終了位置に正確に配置されるため、このバリアントに適用されます。 新しいカムは、前のカムが報告したときと同じサイクルで新しいカムへの切り替えが行われた場合にのみ、前のカムの最後に正確に配置されます EndOfProfile = TRUE 。 再起動して新しいカムを開始します MC_CamIn ファンクションブロック。 新しいカムの正しい機能のためにパラメータを変更する必要がある場合は、このバリアントをお勧めします（たとえば、 SlaveOffset 次の例から）。次の例の制限が適用されます。 例 次の例では、 CAM1 に CAM2 ： CAM1 5次多項式とそれに続く2つの線分で構成されます。 CAM2 2つの線分とそれに続く1つの5次多項式で構成されます。 両方のカムを切り替えるときは、次のことを考慮する必要があります。 ジャンプを防ぐために、最初のカムの終点での速度と加速度の値は、2番目のカムの始点での値と一致する必要があります。この例では、同じ速度（= 1）と加速度（= 0）がの終点に割り当てられているため、この条件が満たされます。 CAM1 との出発点 CAM2 。 2番目のカムを開始できます Relative スレーブの開始位置を0として定義した場合は、モードになります。ただし、最初のカムはで実行されている必要があります。 non-periodic モード。それ以外の場合、 CAM1 定期的だった、そして Relative 設定するとジャンプします。 倍率はからの移行を示しています CAM1 に CAM2 。青い線は、マスター位置でのカム機能の評価を示しています x1 と x2 。 今、私たちはの不利なケースを見ていきます periodic ： MasterAbsolute := TRUE; SlaveAbsolute := FALSE; CAM(x1, CAM1, PERIODIC:=TRUE); 呼び出しは、マスター位置でカムの評価を開始します x1 、のマスターの終了位置よりも小さい CAM1 。それで CAM1 デフォルトで評価され、ポイントを生成します 1 奴隷の位置として。 CAM(x2, CAM1, PERIODIC:=TRUE); モジュールの次の呼び出しでは、マスターの位置 x2 マスター値の範囲外です CAM1 、その限界は緑の破線で示され、点の水平軸と一致している。 3p したがって、 EndOfProfile 設定されています。 CAM1 で始まった periodic モードでは、値の範囲の終わりで再開され、最終的にポイントが生成されます。 2p モジュール呼び出しの結果として。 CAM(EXECUTE:=FALSE); 新しいカムに切り替えます CAM(x2, CAM2, PERIODIC:=TRUE); 修士課程での2回目の評価 x2 。今回は、新しい CAM2 評価されます。後 CAM2 で開始されます Relative モード、現在のスレーブ位置（ 2p ）のカム機能の画像にオフセットとして追加されます CAM2 。これにより、グラフの開始点がその点に移動します 3p マスターポジションでの評価 x2 ポイントを生成します 4p 、したがって、好ましくないジャンプ。 を選択 non-periodic ジャンプを防ぐためのモード： MasterAbsolute := TRUE; SlaveAbsolute := FALSE; CAM(x1, CAM1, PERIODIC:=FALSE); 呼び出しは、マスター位置でカムの評価を開始します x1 、のマスターの終了位置よりも小さい CAM1 。それで CAM1 デフォルトで評価され、スレーブの位置としてポイント1が生成されます。 CAM(x2, CAM1, PERIODIC:=FALSE); モジュールの次の呼び出しでは、マスターの位置 x2 マスター値の範囲外です CAM1 、その限界は緑の破線で示され、点の水平軸と一致している。 3n したがって、 EndOfProfile 設定されています。 CAM1 で始まった non-periodic モード、スレーブ位置（ 2n ）マスターポジションに任命 x2 スレーブが値の範囲の終わりに到達したときの位置と同一である。 CAM1 （ 3n ）。 CAM(EXECUTE:=FALSE); 新しいカムに切り替えます。 CAM(x2, CAM2, PERIODIC:=FALSE); 修士課程での2回目の評価 x2 。今回は、新しい CAM2 評価されます。後 CAM2 で開始されます Relative モード、現在のスレーブ位置（ 2n ）のカム機能の画像にオフセットとして追加されます CAM2 。これにより、グラフの開始点がその点に移動します 3n マスターポジションでの評価 x2 ポイントを生成します 4n 、ポイントを通る特定の線上にあります 1 と 3n 。 カムを開始するには Absolute モードでは、スレーブが適切な開始位置にあることを確認する必要があります。マスターの値の範囲がスレーブの周期と一致する場合、カムが周期的であるかどうかに関係なく、カム間の切り替えに問題はありません。 上記の例では、開始できます CAM2 の Absolute マスターとスレーブの周期がマスター値の範囲と一致する場合のモード CAM2 （それぞれ360°です）。 そうでない場合、たとえば、スレーブの期間が 270° （水色の線で示されています）、次に Absolute オプションは、追加のアクションを実行せずに許可されていません。 この場合、から切り替えるときにスレーブは90°になります CAM1 に CAM2 。起動 CAM2 の Absolute モードでは、0°にジャンプします（灰色の線で示されます）。 ただし、スレーブオフセットを適切な値の90°に設定することにより、ジャンプを防ぐことができます。 " }, 
{ "title" : "周期カム ", 
"url" : "_sm_basic_periodic_cams.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ 周期カム ", 
"snippet" : "カムは繰り返し作動させることができる。 Periodic の入力 MC_CamTableSelect 機能ブロックは次のように設定されている TRUE カムは終了位置に到達すると自動的に再起動します。この入力が FALSE 、 そうして EndOfProfile 出力変数の MC_CamIn 機能ブロックは次のように設定されている TRUE マスターの終了位置に到達すると、スレーブは現在の位置で一時停止します。 カムの動作はマスター値の範囲を離れた後も停止しないことに注意してください。マスター ドライブがマスター値の範囲に再び入ると、スレーブ ドライブは再びカム プレートに従います。 の場合の...", 
"body" : "カムは繰り返し作動させることができる。 Periodic の入力 MC_CamTableSelect 機能ブロックは次のように設定されている TRUE カムは終了位置に到達すると自動的に再起動します。この入力が FALSE 、 そうして EndOfProfile 出力変数の MC_CamIn 機能ブロックは次のように設定されている TRUE マスターの終了位置に到達すると、スレーブは現在の位置で一時停止します。 カムの動作はマスター値の範囲を離れた後も停止しないことに注意してください。マスター ドライブがマスター値の範囲に再び入ると、スレーブ ドライブは再びカム プレートに従います。 の場合の行動 Slave.EndPosition <> Slave.StartPosition : 機能ブロック MC_CamIn 期間の終わりに内部オフセットを計算します。後続の期間では、カムはこのオフセットによってシフトされ、スレーブの現在の位置で継続し、結果としてジャンプを防止します。 周期的なカムの場合は、 スムーズな移行 カムプロパティのオプションを選択します。これは、ある周期から別の周期に移行するときにジャンプが発生するのを防ぐために使用されます。スレーブは、終了位置で開始位置と同じ速度と加速度を持ちます。周期とフィードはスレーブスケーリングの単位で測定されます。 スムーズな移行 オプションでは、カムを連続的に操作できます。この場合、遷移の一貫性が十分に満たされていることを確認する必要があります。 " }, 
{ "title" : "「オンラインカムエディタ」視覚化要素 ", 
"url" : "_sm_cam_visu_elem_online_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ 「オンラインカムエディタ」視覚化要素 ", 
"snippet" : "オンラインカムエディタは、ビジュアライゼーションにカムを表示するビジュアライゼーションテンプレートです。この要素を使うと、オンラインモードでカムを変更できます。 ビジュアライゼーション要素はビジュアライゼーションテンプレートで利用できるようになります ( SMC_Visu_CamEditor ) の SM3_Basic_Visu ライブラリ。このファイルは、ビジュアライゼーションエディタのビジュアライゼーションエディタにあります。 ツールボックス で表示 SM3_ベーシック_ビザ タグ。 ザル SMC_Visu_CamEditor フレームを介してビジュアライゼーションに挿入されます。 この視...", 
"body" : "オンラインカムエディタは、ビジュアライゼーションにカムを表示するビジュアライゼーションテンプレートです。この要素を使うと、オンラインモードでカムを変更できます。 ビジュアライゼーション要素はビジュアライゼーションテンプレートで利用できるようになります ( SMC_Visu_CamEditor ) の SM3_Basic_Visu ライブラリ。このファイルは、ビジュアライゼーションエディタのビジュアライゼーションエディタにあります。 ツールボックス で表示 SM3_ベーシック_ビザ タグ。 ザル SMC_Visu_CamEditor フレームを介してビジュアライゼーションに挿入されます。 この視覚化要素の詳細については、以下を参照してください。 ビジュアライゼーションエレメント:フレーム 。 フレーム要素のプロパティに加えて、このテンプレートには次のプロパティが含まれています。 プロパティ [説明] セーフカム 編集するカムへの参照 [位置を表示] ポジションカーブの表示のオンとオフを切り替えるブール変数 ベロシティを表示 速度曲線の表示のオンとオフを切り替えるブール変数 アクセラレーションを表示 加速度曲線の表示のオンとオフを切り替えるブール変数 ショージャーク ジャークカーブの表示のオンとオフを切り替えるブール変数 選択したセグメントを表示 選択したセグメントの強調表示のオンとオフを切り替えるブール変数 編集するカムは、のインスタンスを介して転送されます SMCB.CAM_REF_MULTICORE_SAFE ファンクションブロック。 PROGRAM PLC_PRG\nVAR\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\nEND_VAR " }, 
{ "title" : "オンラインモードのカムエディタ ", 
"url" : "_sm_cam_visu_elem_online_cam.html#UUID-2e587bbc-4adf-7494-0ee4-e771bd15b571_id_ba4cc02c6ccda90bc0a864637badf4e0_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ 「オンラインカムエディタ」視覚化要素 \/ オンラインモードのカムエディタ ", 
"snippet" : "オンラインモードでは、カムの個々のセグメントをグラフで選択できます。右側のセグメントエディターでは、セグメントの追加や削除、選択したセグメントの境界条件の調整ができます (1) ロードカム 設定したカムをエディタにロードします (2) カムを保存 編集したカムを保存します (3) ステータスバー ステータスメッセージを表示します (4) セグメント選択 セグメントは矢印を使用して選択できます。セグメントタイプはリストボックスで変更できます (5) マスターポジション セグメントの左端と右端のマスターポジション (6) スレーブポジション セグメントの左端と右端のスレーブ位置。 (7) スレーブ...", 
"body" : "オンラインモードでは、カムの個々のセグメントをグラフで選択できます。右側のセグメントエディターでは、セグメントの追加や削除、選択したセグメントの境界条件の調整ができます (1) ロードカム 設定したカムをエディタにロードします (2) カムを保存 編集したカムを保存します (3) ステータスバー ステータスメッセージを表示します (4) セグメント選択 セグメントは矢印を使用して選択できます。セグメントタイプはリストボックスで変更できます (5) マスターポジション セグメントの左端と右端のマスターポジション (6) スレーブポジション セグメントの左端と右端のスレーブ位置。 (7) スレーブ速度 セグメントの左端と右端のスレーブ速度。すべてのセグメントタイプで編集できるわけではありません (8) スレーブアクセラレーション セグメントの左端と右端のスレーブアクセラレーション。すべてのセグメントタイプで編集できるわけではありません (9) スレーブジャーク セグメントの左端と右端のスレーブジャークです。すべてのセグメントタイプで編集できるわけではありません (10) ラムダパラメータ 修正された正弦線のラムダパラメータ。 (11) スプリット 選択したセグメントを 2 つのセグメントに分割します。 (12) 削除 選択したセグメントを削除します。 " }, 
{ "title" : "作成したカムをアプリケーションで使用する ", 
"url" : "_sm_cam_visu_elem_online_cam.html#UUID-2e587bbc-4adf-7494-0ee4-e771bd15b571_section-idm234870310600632", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 2軸の同期動作 \/ カム \/ 「オンラインカムエディタ」視覚化要素 \/ 作成したカムをアプリケーションで使用する ", 
"snippet" : "で作成したカムを使用できます SMC_Visu_CamEditor を呼び出して、アプリケーション内のビジュアライゼーション要素を作成します。 GetCopy のメソッド CAM_REF_MULTICORE_SAFE インスタンス。 PROGRAM PLC_PRG VAR     safeCam : SMCB.CAM_REF_MULTICORE_SAFE;     camRef : MC_CAM_REF;     camSegments : ARRAY[0..99] OF SMC_CAM_SEGMENT;     error : SMC_ERROR; END_VAR IF safeCam.Ca...", 
"body" : "で作成したカムを使用できます SMC_Visu_CamEditor を呼び出して、アプリケーション内のビジュアライゼーション要素を作成します。 GetCopy のメソッド CAM_REF_MULTICORE_SAFE インスタンス。 PROGRAM PLC_PRG\nVAR\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\n    camRef : MC_CAM_REF;\n    camSegments : ARRAY[0..99] OF SMC_CAM_SEGMENT;\n    error : SMC_ERROR;\nEND_VAR\n\nIF safeCam.CamId <> oldCamId THEN\n     error :=\n         safeCam.GetCopy(\n            camRef:= camRef,\n            pCamSegments:= ADR(camSegments),\n            arraySize:= XSIZEOF(camSegments));\n\n oldCamId := safeCam.CamId;\nEND_IF プログラムは最初に新しいカムが作成されたかどうかを確認します ( CamId <> oldCamID )。その場合は、を使用してこのカムのコピーが作成されます。 GetCopy メソッド。呼び出しが戻った場合 SMC_NO_ERROR そして、 camRef のインスタンス MC_CAM_REF ファンクションブロックは SoftMotion カムファンクションブロックと一緒に使用できます。 MC_CamTableSelect そして MC_CamIn 。ザ・ GetCopy 呼び出しはタスクセーフなので、Visu タスクから行う必要はありません。 " }, 
{ "title" : "複数の動きを指揮する ", 
"url" : "_sm_basic_mulitple_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 複数の動きを指揮する ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概要 ", 
"url" : "_sm_overview_mulitple_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 複数の動きを指揮する \/ 概要 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "バッファモード ", 
"url" : "_sm_overview_mulitple_movements.html#UUID-2f590113-2f84-eead-4ae8-73304891aaa0_section-idm43431844820766", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 複数の動きを指揮する \/ 概要 \/ バッファモード ", 
"snippet" : "いくつかの機能ブロックには BufferMode 動作の時系列順序を制御するために使用される入力。バッファ モードは、関数ブロックが非バッファ モード (「中止」、標準動作) で動作するか、バッファ モード (「バッファ」) で動作するかを定義します。これら 2 つのモードの違いは、アクションを開始する時間です。 「非バッファモード」: 移動コマンドは、別の移動を中断した場合でも、すぐに有効になります。コマンドされた移動のバッファは削除されます。 「バッファモード」：移動コマンドは、現在の機能ブロックが出力を設定するまで待機します。 Done （または InPosition 、 または InV...", 
"body" : "いくつかの機能ブロックには BufferMode 動作の時系列順序を制御するために使用される入力。バッファ モードは、関数ブロックが非バッファ モード (「中止」、標準動作) で動作するか、バッファ モード (「バッファ」) で動作するかを定義します。これら 2 つのモードの違いは、アクションを開始する時間です。 「非バッファモード」: 移動コマンドは、別の移動を中断した場合でも、すぐに有効になります。コマンドされた移動のバッファは削除されます。 「バッファモード」：移動コマンドは、現在の機能ブロックが出力を設定するまで待機します。 Done （または InPosition 、 または InVelocity など)。バッファ モードは、動きの遷移時に速度曲線がどのように表示されるか定義するためにも使用されます。 BufferMode 入力は、MC_BUFFER_MODE 型の ENUM です。 Aborting バッファリングなしのデフォルト モード。ファンクション ブロックはすぐに開始され、アクティブな動作を中止します。コマンドは軸にすぐに反映されます。 Buffered ファンクションブロックは、最後に指示された動作が終了するとすぐに開始されます。ここではブレンドは行われません。新しい動作は、終了条件に達したときの前の動作の速度で開始されます（ Done 、 InVelocity 、 InEndVelocity 、 InGear 、 InSync 、 EndOfProfile など）。前回の動きが MC_MoveAbsolute または MC_MoveRelative すると、停止状態から新たな動きが始まります。 BlendingLow ファンクション ブロックは、最後にコマンドされた動作が終了するとすぐに開始されます。軸は動作間で停止せず、2 つの動作コマンドのうちの低い方の速度で最初の動作の終了位置を通過します。 BlendingPrevious ファンクション ブロックは、最後にコマンドされた動作が終了するとすぐに開始されます。軸は動作間で停止せず、最初の動作コマンドの速度で最初の動作の終了位置を通過します。 BlendingNext ファンクション ブロックは、最後にコマンドされた動作が終了するとすぐに開始されます。軸は動作間で停止せず、2 番目の動作コマンドの速度で最初の動作の終了位置を通過します。 BlendingHigh ファンクション ブロックは、最後にコマンドされた動作が終了するとすぐに開始されます。軸は動作間で停止せず、2 つの動作コマンドのうちの高速な速度で最初の動作の終了位置を通過します。 " }, 
{ "title" : "サポートされている機能ブロック ", 
"url" : "_sm_overview_mulitple_movements.html#UUID-2f590113-2f84-eead-4ae8-73304891aaa0_section-idm43431844838676", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 複数の動きを指揮する \/ 概要 \/ バッファモード \/ サポートされている機能ブロック ", 
"snippet" : "バッファリング\/ブレンディング コマンドとして指定できるすべての機能ブロックには、次の入力と出力があります。 BufferMode 入力（ MC_BUFFER_MODE タイプ） Active 出力: ( BOOL タイプ） ファンクションブロックが状態に切り替わるとコマンドが受け入れられます Busy 新しい動きが命令された後。 機能ブロック バッファ\/ブレンディングコマンドとして定義できます バッファ\/ブレンディングコマンドが続くことができる 次のバッファ\/ブレンディングFBをアクティブ化するための関連信号 MC_Power いいえ いいえ MC_Home いいえ いいえ MC_Stop ...", 
"body" : "バッファリング\/ブレンディング コマンドとして指定できるすべての機能ブロックには、次の入力と出力があります。 BufferMode 入力（ MC_BUFFER_MODE タイプ） Active 出力: ( BOOL タイプ） ファンクションブロックが状態に切り替わるとコマンドが受け入れられます Busy 新しい動きが命令された後。 機能ブロック バッファ\/ブレンディングコマンドとして定義できます バッファ\/ブレンディングコマンドが続くことができる 次のバッファ\/ブレンディングFBをアクティブ化するための関連信号 MC_Power いいえ いいえ MC_Home いいえ いいえ MC_Stop いいえ いいえ MC_Halt いいえ いいえ MC_MoveAbsolute MC_MoveRelative はい はい Done MC_MoveAdditive いいえ はい （ Buffered のみ） Done MC_MoveSuperImposed MC_HaltSuperImposed いいえ いいえ 詳細については、以下を参照してください。 MC_MoveSuperImposed と MC_HaltSuperImposed の動作MC_MoveVelocity はい はい （ Buffered のみ） InVelocity SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative いいえ はい （ Buffered のみ） InEndVelocity MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile いいえ はい （ Buffered のみ） Done MC_CamIn はい (のみ Buffered と BlendingPrevious ) はい、定期的な場合（ Buffered ） EndOfProfile MC_CamOut いいえ はい （ Buffered のみ） Done MC_GearIn はい （ BlendingPrevious のみ） はい （ Buffered のみ） InGear MC_GearOut いいえ はい （ Buffered のみ） Done MC_GearInPos はい （ BlendingPrevious のみ） はい （ Buffered のみ） InSync SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues いいえ いいえ SMC_SetTorque いいえ いいえ MC_Phasing いいえ いいえ MC_Jog SMC_Inch いいえ いいえ これらの機能ブロックは、バッファモードで移動がコマンドされる場合には使用しないでください。 Buffered または Blending* ジョギングと指示された動作が互いに中断する可能性があります。 SMC_BacklashCompensation いいえ いいえ SMC_TrackAxis いいえ いいえ SMC_TrackSetValues いいえ いいえ 注意事項 MC_GearInPos そして MC_GearIn : 他のバッファモードの動作 BlendingPrevious 確立するのは困難です。主な問題は、これらの機能ブロックの速度がマスター軸に応じていつでも変更できることです。ブレンディングは、ブレンディング速度ができるだけ早くわかっている場合に最も効果的に機能するため、 BlendingPrevious サポートされています。 の場合 BlendingPrevious マスター軸の方向もいつでも変更できます。つまり、MC_GearInPos のスレーブ軸の方向は、ブレンディングが完了したときにのみわかります。ただし、ブレンディングの開始時にブレンディングの動きの方向が必要です。これが、後続の動きによって定義される方向に関係なく、最初の動きがブレンディング速度と方向の両方を定義する理由です。 MC_GearIn(Pos) 。 " }, 
{ "title" : "バッファリングされた動きの場合の動作 ", 
"url" : "_sm_buffermode_buffered_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 複数の動きを指揮する \/ バッファリングされた動きの場合の動作 ", 
"snippet" : "バッファリングされた移動が後に命令されたとき MC_MoveAbsolute また MC_MoveRelative 、バッファリングされた動きは、前の動きが報告するのと同じサイクルでアクティブになります Done ただし、バッファリングされた動きの補間は次のサイクルまで開始されないため、サイクル終了時の軸の速度は0に等しくなります。 バッファリングされた移動が命令された後 MC_CamIn バッファリングされた動きは、前の動きが報告された同じサイクルでアクティブになります。 EndOfProfile このサイクルでは、バッファリングされた動きの補間が直ちに開始されます。...", 
"body" : "バッファリングされた移動が後に命令されたとき MC_MoveAbsolute また MC_MoveRelative 、バッファリングされた動きは、前の動きが報告するのと同じサイクルでアクティブになります Done ただし、バッファリングされた動きの補間は次のサイクルまで開始されないため、サイクル終了時の軸の速度は0に等しくなります。 バッファリングされた移動が命令された後 MC_CamIn バッファリングされた動きは、前の動きが報告された同じサイクルでアクティブになります。 EndOfProfile このサイクルでは、バッファリングされた動きの補間が直ちに開始されます。 " }, 
{ "title" : "ブレンディングの場合の動作 ", 
"url" : "_sm_buffermode_blending.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 複数の動きを指揮する \/ ブレンディングの場合の動作 ", 
"snippet" : "のブレンド動作の基本的なプロパティ CODESYS SoftMotion 軸は、バッファリングされた移動中とブレンド中に同じ位置に沿って移動します。唯一の違いは、これらの位置に沿った速度です。 これは単純なケースでは明らかです。これについては、次の例を参照してください。 バッファ モードとは無関係に軸が同じ位置を移動するという特性が、2 つの動作間の有効なブレンド速度に影響を与える場合があります。たとえば、上記の例が変更され、2 番目の動作の最大速度が非常に高くなり、ブレンド位置で到達できない場合がこれに該当します。PLCopen で説明されているルールによると、ブレンド速度は 500 u\/s...", 
"body" : "のブレンド動作の基本的なプロパティ CODESYS SoftMotion 軸は、バッファリングされた移動中とブレンド中に同じ位置に沿って移動します。唯一の違いは、これらの位置に沿った速度です。 これは単純なケースでは明らかです。これについては、次の例を参照してください。 バッファ モードとは無関係に軸が同じ位置を移動するという特性が、2 つの動作間の有効なブレンド速度に影響を与える場合があります。たとえば、上記の例が変更され、2 番目の動作の最大速度が非常に高くなり、ブレンド位置で到達できない場合がこれに該当します。PLCopen で説明されているルールによると、ブレンド速度は 500 u\/s である必要があります。ただし、位置 100 u でこの速度を達成するには、軸を反転し、負の方向に 0 u 未満の位置まで移動してから、500 u\/s まで加速する必要があります。代わりに、このような場合、有効なブレンド速度は、反転や位置オーバーシュートなしで達成できる最大速度に制限されます。この例では、最大速度は 447 u\/s です。 有効な混合速度に関する次のルールは、バッファモードが駆動位置を変更しないという特性に起因します。 位置のオーバーシュートなしで混合速度に到達できない場合、有効な混合速度は、オーバーシュートなしで到達できる次の可能な速度です（上記の例を参照）。 注：有効な混合速度は、混合速度よりも高くても低くてもかまいません。 2番目の動きの開始時の方向が最初の動きの方向と反対である場合、有効なブレンド速度は0に設定されます。これにより、位置が目標位置を超えて最初の動きの方向にオーバーシュートするのを防ぎます。 2番目の動きの経路が短すぎて、混合速度から停止するまで減速できない場合は、有効な混合速度が調整されます。これは、2番目の動きの経路で停止するまで安全にブレーキをかけることができる最大速度に設定されています。 モジュロ軸の場合、入力の効果 Direction の MC_MoveAbsolute 2番目の楽章へのブレンドの影響を受けません。これは、ブレンドムーブメントが続くかどうかに関係なく、最初のムーブメントのターゲット位置が常に同じモジュロ期間にあることを意味します。 モジュロ軸とタイプの2番目の楽章の場合 MC_MoveAbsolute 、ブレンド速度は、次の場合に2番目の動きの目標位置のモジュロ周期に影響を与えません。 Direction = fastest 使用されている。これは、2番目の移動がコマンドされているかどうかに関係なく、同じターゲット期間が選択されることを意味します Buffered また Blending 。 " }, 
{ "title" : "ブレンド中の加速、減速、ジャーク ", 
"url" : "_sm_buffermode_blending.html#UUID-60273b62-3ad5-7014-3fa9-e2fa61f7a008_section-idm235068399508112", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 複数の動きを指揮する \/ ブレンディングの場合の動作 \/ ブレンド中の加速、減速、ジャーク ", 
"snippet" : "バッファモード ( BlendingLow \/ BlendingHigh \/ BlendingPrevious \/ BlendingNext 2 番目のムーブメントの) によって、ムーブメントの開始位置に到達する速度が決まります。 対照的に、ブレンド中の最大加速、減速、最大ジャークは常に最初の動きの値です。その理由は、たとえば 2 番目の動きの最大遅延が 1 番目の動きの最大遅延よりも小さく、使用する遅延が小さいほうの動きの場合、最初の動きの目標位置を超える可能性があるためです...", 
"body" : "バッファモード ( BlendingLow \/ BlendingHigh \/ BlendingPrevious \/ BlendingNext 2 番目のムーブメントの) によって、ムーブメントの開始位置に到達する速度が決まります。 対照的に、ブレンド中の最大加速、減速、最大ジャークは常に最初の動きの値です。その理由は、たとえば 2 番目の動きの最大遅延が 1 番目の動きの最大遅延よりも小さく、使用する遅延が小さいほうの動きの場合、最初の動きの目標位置を超える可能性があるためです " }, 
{ "title" : "連続的または同期的な動きからのバッファリング\/ブレンド ", 
"url" : "_sm_buffermode_continuous_motion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 複数の動きを指揮する \/ 連続的または同期的な動きからのバッファリング\/ブレンド ", 
"snippet" : "PLCopenによると、ブレンディングバッファモードは最初の動きの終わりの速度を決定します。 場合によっては、速度は最初の動きによってすでに完全に決定されています。これは、最初の楽章が次のいずれかのタイプの場合です。 連続移動（ MC_MoveVelocity 、 SMC_MoveContinuousRelative 、 また SMC_MoveContinuousAbsolute ）。 同期運動（ MC_CamIn 、 MC_GearIn 、 また MC_GearInPos ）。 これらの場合、 CODESYS SoftMotion のみをサポートします Buffered と Aborting...", 
"body" : "PLCopenによると、ブレンディングバッファモードは最初の動きの終わりの速度を決定します。 場合によっては、速度は最初の動きによってすでに完全に決定されています。これは、最初の楽章が次のいずれかのタイプの場合です。 連続移動（ MC_MoveVelocity 、 SMC_MoveContinuousRelative 、 また SMC_MoveContinuousAbsolute ）。 同期運動（ MC_CamIn 、 MC_GearIn 、 また MC_GearInPos ）。 これらの場合、 CODESYS SoftMotion のみをサポートします Buffered と Aborting バッファモード。ブレンディングバッファモードの1つを使用すると、FBエラーが発生します（ SMC_BLENDING_NOT_SUPPORTED_BY_PREVIOUS_MOVEMENT) 。 後続のバッファリングされたコマンドがアクティブになると、出力 CommandAborted に設定されています TRUE 前回の移動コマンドのInxxx出力（例えば、 InVelocity のために MC_MoveVelocity または InGear のために MC_GearIn ）と出力 Busy 1サイクルに設定されています。これはPLCopenのセクション2.4.1とは対照的です。 CommandAborted そして「Inxxx」と Busy 相互に排他的です。 " }, 
{ "title" : "移動機能ブロックの実行順序 ", 
"url" : "_sm_buffermode_execution_order.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 複数の動きを指揮する \/ 移動機能ブロックの実行順序 ", 
"snippet" : "バッファリングされた動作またはブレンド動作がコマンドされる場合、後続の動作をコマンドするファンクション ブロック インスタンスは、前の動作をコマンドしたファンクション ブロック インスタンスよりも先に実行してはなりません。 この順序に違反した場合、新しいエラーは SMC_FB_WASNT_CALLED_DURING_MOTION がレポートされ、軸が次の状態に切り替わります Errorstop 。 例 movement1(); movement2(); 正しい実行順序 実行 movement1() 実行 movement2() 出来るだけ早く movement1() アクティブです 実行順序が...", 
"body" : "バッファリングされた動作またはブレンド動作がコマンドされる場合、後続の動作をコマンドするファンクション ブロック インスタンスは、前の動作をコマンドしたファンクション ブロック インスタンスよりも先に実行してはなりません。 この順序に違反した場合、新しいエラーは SMC_FB_WASNT_CALLED_DURING_MOTION がレポートされ、軸が次の状態に切り替わります Errorstop 。 例 movement1();\nmovement2(); 正しい実行順序 実行 movement1() 実行 movement2() 出来るだけ早く movement1() アクティブです 実行順序が無効です 実行 movement2() 実行 movement1() 出来るだけ早く movement2() アクティブです これにより、 SMC_MOVING_WITHOUT_ACTIVE_MOVEMENT エラー。 " }, 
{ "title" : "1つのファンクションブロックインスタンスを使用して複数の動きを制御する ", 
"url" : "_sm_buffermode_one_fb.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 複数の動きを指揮する \/ 1つのファンクションブロックインスタンスを使用して複数の動きを制御する ", 
"snippet" : "単一のファンクションブロックインスタンス（例えば、 MC_MoveAbsolute ）は、複数のバッファリング\/ブレンディング動作を制御するために使用することはできません。 Busy 。 ファンクションブロックインスタンスが Busy 、このインスタンスで新しいバッファリングまたはブレンドされた動きのコマンドを実行すると、エラーが発生します。 SMC_MORE_THAN_ONE_MOVEMENT_PER_INSTANCE 。 同じタイプの複数のバッファリングされた動きまたはブレンドされた動きを短い順序で命令するには、複数の機能モジュール インスタンスが必要です。...", 
"body" : "単一のファンクションブロックインスタンス（例えば、 MC_MoveAbsolute ）は、複数のバッファリング\/ブレンディング動作を制御するために使用することはできません。 Busy 。 ファンクションブロックインスタンスが Busy 、このインスタンスで新しいバッファリングまたはブレンドされた動きのコマンドを実行すると、エラーが発生します。 SMC_MORE_THAN_ONE_MOVEMENT_PER_INSTANCE 。 同じタイプの複数のバッファリングされた動きまたはブレンドされた動きを短い順序で命令するには、複数の機能モジュール インスタンスが必要です。 " }, 
{ "title" : "エラーが発生した場合の動作 ", 
"url" : "_sm_basic_behavior_error.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 複数の動きを指揮する \/ エラーが発生した場合の動作 ", 
"snippet" : "軸エラーが発生した場合（たとえば、軸が状態に切り替わる場合） Errorstop ）、アクティブな動きは、他のすべての受け入れられた動きとともにエラーを報告します。 アクティブなムーブメントの機能ブロックでFBエラーが発生した場合、後で受け入れられたすべてのムーブメントもエラーを報告します。これは、後続のコマンドがFBエラーの後に実行を継続するPLCopenのセクション2.2.2とは対照的です。...", 
"body" : "軸エラーが発生した場合（たとえば、軸が状態に切り替わる場合） Errorstop ）、アクティブな動きは、他のすべての受け入れられた動きとともにエラーを報告します。 アクティブなムーブメントの機能ブロックでFBエラーが発生した場合、後で受け入れられたすべてのムーブメントもエラーを報告します。これは、後続のコマンドがFBエラーの後に実行を継続するPLCopenのセクション2.2.2とは対照的です。 " }, 
{ "title" : "MC_MoveSuperImposed と MC_HaltSuperImposed の動作 ", 
"url" : "_sm_buffermode_movesuperimposed.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 複数の動きを指揮する \/ MC_MoveSuperImposed と MC_HaltSuperImposed の動作 ", 
"snippet" : "もし MC_MoveSuperImposed または MC_HaltSuperImposed アクティブで基礎となる動きが中止された場合、 MC_MoveSuperImposed \/ MC_HaltSuperImposed も中止されます。 基礎となる動きがキャンセルされずに、モードの別の動きがキャンセルされた場合 Buffered または、Blending-BufferMode のいずれかがコマンドされた場合、動作は次のようになります。 MC_MoveSuperImposed \/ MC_HaltSuperImposed ブレンドが始まったり、新しい動きがアクティブになったりしてもキャンセルさ...", 
"body" : "もし MC_MoveSuperImposed または MC_HaltSuperImposed アクティブで基礎となる動きが中止された場合、 MC_MoveSuperImposed \/ MC_HaltSuperImposed も中止されます。 基礎となる動きがキャンセルされずに、モードの別の動きがキャンセルされた場合 Buffered または、Blending-BufferMode のいずれかがコマンドされた場合、動作は次のようになります。 MC_MoveSuperImposed \/ MC_HaltSuperImposed ブレンドが始まったり、新しい動きがアクティブになったりしてもキャンセルされません。代わりに、 MC_MoveSuperImposed \/ MC_HaltSuperImposed 終了するまでバックグラウンドで継続されます。 " }, 
{ "title" : "現在 CODESYS SoftMotion バージョン 4.17.0.0 ", 
"url" : "_sm_buffermode_movesuperimposed.html#UUID-55e334a2-da44-00d6-2f2a-9f3f03732605_section-idm234439539337338", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 複数の動きを指揮する \/ MC_MoveSuperImposed と MC_HaltSuperImposed の動作 \/ 現在 CODESYS SoftMotion バージョン 4.17.0.0 ", 
"snippet" : "とき MC_MoveAbsolute バッファモードまたはブレンディングモードが設定されていると、結果の終了位置は、 MC_MoveAbsolute 設定された距離 MC_MoveSuperImposed \/ MC_HaltSuperImposed かどうかは関係ありません MC_MoveSuperImposed \/ MC_HaltSuperImposed は引き続きアクティブです。SuperImposed 距離は、SuperImposed 動作が完了した後も保持されます。中止動作がコマンドされるとすぐに、SuperImposed 距離はリセットされます。...", 
"body" : "とき MC_MoveAbsolute バッファモードまたはブレンディングモードが設定されていると、結果の終了位置は、 MC_MoveAbsolute 設定された距離 MC_MoveSuperImposed \/ MC_HaltSuperImposed かどうかは関係ありません MC_MoveSuperImposed \/ MC_HaltSuperImposed は引き続きアクティブです。SuperImposed 距離は、SuperImposed 動作が完了した後も保持されます。中止動作がコマンドされるとすぐに、SuperImposed 距離はリセットされます。 " }, 
{ "title" : "前に CODESYS SoftMotion バージョン 4.17.0.0 ", 
"url" : "_sm_buffermode_movesuperimposed.html#UUID-55e334a2-da44-00d6-2f2a-9f3f03732605_section-idm234439540497353", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 複数の動きを指揮する \/ MC_MoveSuperImposed と MC_HaltSuperImposed の動作 \/ 前に CODESYS SoftMotion バージョン 4.17.0.0 ", 
"snippet" : "もし MC_MoveAbsolute バッファモードが割り当てられているか、ブレンディングモードが指示されているときに MC_MoveSuperImposed \/ MC_HaltSuperImposed がアクティブな場合、結果の終了位置は MC_MoveSuperImposed \/ MC_HaltSuperImposed 当時、 MC_MoveAbsolute アクティブです。 MC_MoveSuperImposed \/ MC_HaltSuperImposed この時点でまだアクティブである場合、結果の終了位置は、 MC_MoveAbsolute そして距離 MC_MoveSuperImpo...", 
"body" : "もし MC_MoveAbsolute バッファモードが割り当てられているか、ブレンディングモードが指示されているときに MC_MoveSuperImposed \/ MC_HaltSuperImposed がアクティブな場合、結果の終了位置は MC_MoveSuperImposed \/ MC_HaltSuperImposed 当時、 MC_MoveAbsolute アクティブです。 MC_MoveSuperImposed \/ MC_HaltSuperImposed この時点でまだアクティブである場合、結果の終了位置は、 MC_MoveAbsolute そして距離 MC_MoveSuperImposed \/ MC_HaltSuperImposed 一方、もし MC_MoveSuperImposed \/ MC_HaltSuperImposed この時点でアクティブではなくなった場合、結果として得られる終了位置は MC_MoveAbsolute 距離がなければ MC_MoveSuperImposed \/ MC_HaltSuperImposed 同様に、結果として生じる速度は MC_MoveVelocity の状態によって異なります MC_MoveSuperImposed \/ MC_HaltSuperImposed いつ MC_MoveVelocity アクティブです。 下の曲線は MC_MoveSuperImposed （ すする 機能ブロック）ブレンディングバッファモードによる3つの絶対移動に平行 BlendingHigh 1回目と2回目の動きは100 u\/sの速度で指令され、 ま0 そして ま1 機能ブロック。 ま2 ファンクションブロックは、120 u\/sの速度で3番目の移動を命令します。最初の目標位置は10 u、2番目は25 u、3番目は40 uです。重ね合わせた移動の速度は20、距離は10です。結果の位置は50 uです。最後の絶対移動の位置と距離を加えたものです。 MC_MoveSuperimposed 。 " }, 
{ "title" : "デジタル・スイッチ・ポイント ", 
"url" : "_sm_digital_switches.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ デジタル・スイッチ・ポイント ", 
"snippet" : "CODESYS SoftMotion には、デジタルスイッチポイントを作成するためのさまざまなオプションがあります。このセクションでは、それぞれのメリットとデメリットの概要を説明します。...", 
"body" : "CODESYS SoftMotion には、デジタルスイッチポイントを作成するためのさまざまなオプションがあります。このセクションでは、それぞれのメリットとデメリットの概要を説明します。 " }, 
{ "title" : "アプリケーション例 ", 
"url" : "_sm_digital_switches.html#UUID-5c8c3ded-d3b5-7c4d-2e37-1277ff2bb5f0_section-idm235063632666072", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ デジタル・スイッチ・ポイント \/ アプリケーション例 ", 
"snippet" : "たとえば、軸の位置に応じてグルーガンのスイッチを入れるには、デジタルスイッチポイントが必要です。次の例では、グルーガンは製品に 90 の位置から 120 の位置まで接着剤を塗布する必要があります。 グルーガンでは、スイッチを入れてから接着剤を塗布するまでに遅延があります。スイッチを切る場合も同様です。そのため、位置90の50ミリ秒前にグルーガンのスイッチが入り、ポジション120の50ミリ秒前にオフになるように、オン\/オフ補正が必要です...", 
"body" : "たとえば、軸の位置に応じてグルーガンのスイッチを入れるには、デジタルスイッチポイントが必要です。次の例では、グルーガンは製品に 90 の位置から 120 の位置まで接着剤を塗布する必要があります。 グルーガンでは、スイッチを入れてから接着剤を塗布するまでに遅延があります。スイッチを切る場合も同様です。そのため、位置90の50ミリ秒前にグルーガンのスイッチが入り、ポジション120の50ミリ秒前にオフになるように、オン\/オフ補正が必要です " }, 
{ "title" : "ファンクションブロックの概要 ", 
"url" : "_sm_digital_switches.html#UUID-5c8c3ded-d3b5-7c4d-2e37-1277ff2bb5f0_section-idm235063632773598", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ デジタル・スイッチ・ポイント \/ ファンクションブロックの概要 ", 
"snippet" : "ファンクションブロック 複数のスイッチポイント オン\/オフ補正 予測 高精度 (サイクルタイムよりも高い時間分解能) データベース [メモ] SMC_DigitalCamSwitch_HighPrecision 1 2 位置または実際の位置を設定 より高い時間精度が必要な場合に役立ちます。高精度の動作には、このファンクションブロックに加えて、高精度のデジタル出力カードが必要です。この組み合わせにより、サイクルタイムが長くても高い時間精度で出力を切り替えることが可能になります 関数ブロックの使用方法の詳細については、以下を参照してください。例 MC_DigitalCamSwitch_HighPr...", 
"body" : "ファンクションブロック 複数のスイッチポイント オン\/オフ補正 予測 高精度 (サイクルタイムよりも高い時間分解能) データベース [メモ] SMC_DigitalCamSwitch_HighPrecision 1 2 位置または実際の位置を設定 より高い時間精度が必要な場合に役立ちます。高精度の動作には、このファンクションブロックに加えて、高精度のデジタル出力カードが必要です。この組み合わせにより、サイクルタイムが長くても高い時間精度で出力を切り替えることが可能になります 関数ブロックの使用方法の詳細については、以下を参照してください。例 MC_DigitalCamSwitch_HighPrecisionを使用しています。。 SMC_GetTravelTime 2 位置または実際の位置を設定 の別バージョンの場合に便利 DigitalCamSwitch 関数ブロックを実装する必要があります (たとえば、追加の関数が必要な場合など)。 MC_DigitalCamSwitch 3 位置または実際の位置を設定 サイクル精度の時間分解能で十分な場合に役立ちます。 SMC_GetTappetValue 位置または実際の位置を設定 これらのファンクションブロックは互換性のためだけに保持されています。現在および将来のプロジェクトでは、他のより高度なファンクションブロックを使用する必要があります SMC_CamRegister 位置または実際の位置を設定 1 正確。予測のデータが使用されます。 2 予測は次の方法で設定する必要があります SMC_SetForecast ファンクションブロック。予測の詳細については、以下を参照してください 予報. 3 外挿によるみ " }, 
{ "title" : "MC_SetOverride による動的適応 ", 
"url" : "_sm_adjust_dynamics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ MC_SetOverride による動的適応 ", 
"snippet" : "アクティブな動きと将来の動きのダイナミクス (速度、加速度、ジャーク) は、次の方法で調整できます。 MC_SetOverride 。ダイナミクスの適応は、常に、最初に命令された動作と比較して縮小を意味します (1 より大きい係数は許可されません)。これにより、機械オペレーターは動作を一時的に停止できます ( VelFactor = 0 ) または、新しい動作シーケンスを確認する場合などに、ダイナミック値を減らして実行します。 ダイナミクスの適応 MC_SetOverride そして、その結果として生じる軌道の適応は、同じサイクル内で直接有効になります。このための要件は、 MC_SetOver...", 
"body" : "アクティブな動きと将来の動きのダイナミクス (速度、加速度、ジャーク) は、次の方法で調整できます。 MC_SetOverride 。ダイナミクスの適応は、常に、最初に命令された動作と比較して縮小を意味します (1 より大きい係数は許可されません)。これにより、機械オペレーターは動作を一時的に停止できます ( VelFactor = 0 ) または、新しい動作シーケンスを確認する場合などに、ダイナミック値を減らして実行します。 ダイナミクスの適応 MC_SetOverride そして、その結果として生じる軌道の適応は、同じサイクル内で直接有効になります。このための要件は、 MC_SetOverride アクティブな移動機能ブロックの前に呼び出されます。 詳細については、例も参照してください。 SoftMotion 軸の速度オーバーライド。 " }, 
{ "title" : "サポートされるファンクションブロック ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4626631011382434026679825113", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ MC_SetOverride による動的適応 \/ サポートされるファンクションブロック ", 
"snippet" : "ファンクションブロック サポート： MC_SetOverride コメント MC_Stop -- MC_Stop は緊急停止であり、常にできるだけ早く実行する必要があります。したがって、動的要因は、 MC_SetOverride 動きには何の影響もありません。 MC_Halt ✓ 速度係数は影響しません。 MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative ...", 
"body" : "ファンクションブロック サポート： MC_SetOverride コメント MC_Stop -- MC_Stop は緊急停止であり、常にできるだけ早く実行する必要があります。したがって、動的要因は、 MC_SetOverride 動きには何の影響もありません。 MC_Halt ✓ 速度係数は影響しません。 MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative ✓ MC_Jog SMC_Inch ✓ SMC_Homing ✓ SMC_ControlAxisByPos SMC_ControlAxisByPosVel SMC_ControlAxisByVel O 動的要因は、次の場合にのみ影響します。 bAvoidGaps 機能が有効になり、ジャンプが検出されました。要因 MC_SetOverride ギャップを埋めるために、停止とその後の絶対的な動きの両方を考慮してください。 MC_Home -- 原点復帰はドライブによって独立して実行されるため、動的要因が影響を受けません。 MC_SetOverride 効果はありません。 MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile -- 使用することをお勧めします MC_CamIn これらの機能ブロックの代わりに。 MC_CamIn O 動きが同期されるとすぐに、動的要因は効果を持たなくなります ( MC_CamIn.InSync = TRUE ）。 MC_CamOut -- MC_CamOut 調整可能な動的制限はなく、現在の速度を維持する必要があります。動的要因 MC_SetOverride したがって、効果はありません。 MC_GearIn O 動きが同期されるとすぐに、動的要因は効果を持たなくなります ( MC_GearIn.InGear = TRUE ）。ランピング中は、加速度とジャーク係数のみが考慮されます。速度係数の変更 (特に VelFactor=0 ) は無視されます。 MC_GearInPos -- 対照的に、 MC_GearIn 、設定可能なランピング動作はありません。したがって、動的要因は、 MC_SetOverride 効果はありません。 SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues -- これらのファンクション ブロックは、軸の設定値を書き込みます (たとえば、 fSetPosition ）。これらの値は変更しないでください。したがって、動的要因は、 MC_SetOverride 効果はありません。 MC_Phasing O 動きが同期されるとすぐに、動的要因は効果を持たなくなります ( MC_Phasing.Done = TRUE ）。ランピング中は、加速度とジャーク係数のみが考慮されます。速度係数の変更 (特に VelFactor=0 ) は無視されます。 SMC_BacklashCompensation -- 動的要因は同期動作には影響しません。したがって、この機能ブロックは動的要因を無視します。 MC_SetOverride 。 " }, 
{ "title" : "動的係数の変更による目標位置または目標速度の超過 ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4552469374918434026680028303", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ MC_SetOverride による動的適応 \/ 動的係数の変更による目標位置または目標速度の超過 ", 
"snippet" : "アクティブな動作中に加速度係数および\/またはジャーク係数が減少すると、目標位置または目標速度が一時的に超過する可能性があります。機械の損傷につながる可能性があります。 と SMC_MoveContinuousAbsolute そして SMC_MoveContinuousRelative 、速度係数の変更により、制限を超えたり、逆転したりする可能性もあります。詳細については、2 つの機能ブロックのドキュメントを参照してください。...", 
"body" : "アクティブな動作中に加速度係数および\/またはジャーク係数が減少すると、目標位置または目標速度が一時的に超過する可能性があります。機械の損傷につながる可能性があります。 と SMC_MoveContinuousAbsolute そして SMC_MoveContinuousRelative 、速度係数の変更により、制限を超えたり、逆転したりする可能性もあります。詳細については、2 つの機能ブロックのドキュメントを参照してください。 " }, 
{ "title" : "MC_SetOverride の使用における速度プロファイルの影響 ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4552469646968034026680341439", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ MC_SetOverride による動的適応 \/ MC_SetOverride の使用における速度プロファイルの影響 ", 
"snippet" : "一般的には使用することをお勧めします MC_SetOverride 座標軸の台形または二次速度プロファイルと一緒に。二次平滑化速度プロファイルと sin² 速度プロファイルは、動きを再開したり中断したりしてもうまく反応しない場合があります 動きの中断)。オーバーライドを変更すると、制限を変更した状態で動きが再開されることと同じであるため、これらの速度プロファイルを組み合わせて使用すると、指示された制限を超えることもあります MC_SetOverride 。...", 
"body" : "一般的には使用することをお勧めします MC_SetOverride 座標軸の台形または二次速度プロファイルと一緒に。二次平滑化速度プロファイルと sin² 速度プロファイルは、動きを再開したり中断したりしてもうまく反応しない場合があります 動きの中断)。オーバーライドを変更すると、制限を変更した状態で動きが再開されることと同じであるため、これらの速度プロファイルを組み合わせて使用すると、指示された制限を超えることもあります MC_SetOverride 。 " }, 
{ "title" : "軸グループとの連携動作に対する MC_SetOverride の影響 ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm456655390848963402668059106", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ MC_SetOverride による動的適応 \/ 軸グループとの連携動作に対する MC_SetOverride の影響 ", 
"snippet" : "軸グループと連携した動き (例: MC_MoveLinearAbsolute ) で設定されたオーバーライドを考慮します。 MC_SetOverride 動作計画時に各軸ごとに。逆に、 MC_GroupSetOverride 軸グループの各軸のオーバーライドを上書きします。...", 
"body" : "軸グループと連携した動き (例: MC_MoveLinearAbsolute ) で設定されたオーバーライドを考慮します。 MC_SetOverride 動作計画時に各軸ごとに。逆に、 MC_GroupSetOverride 軸グループの各軸のオーバーライドを上書きします。 " }, 
{ "title" : "予報 ", 
"url" : "_sm_basic_forecast.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 予報 ", 
"snippet" : "予測機能を使用すると、軸の将来の動きに関する情報を照会できます。予測の重要な用途は、位置に到達するまでの時間を決定することです (トリガー機能と同様)。もう 1 つの用途は、特定の時間に軸が持つ位置と速度を決定することです。この方法では、たとえば接着ノズルがオンになったときなど、アクチュエータがオンになったときにデッド タイムを補正できます。また、デッド タイムのあるアクチュエータを正確に制御するために使用することもできます。たとえば、100 ミリ秒後の軸速度に基づいて接着出力を制御するなどです。 これらのアプリケーションを実装するには、 SMC_Get旅行時間 そして SMC_ReadSet...", 
"body" : "予測機能を使用すると、軸の将来の動きに関する情報を照会できます。予測の重要な用途は、位置に到達するまでの時間を決定することです (トリガー機能と同様)。もう 1 つの用途は、特定の時間に軸が持つ位置と速度を決定することです。この方法では、たとえば接着ノズルがオンになったときなど、アクチュエータがオンになったときにデッド タイムを補正できます。また、デッド タイムのあるアクチュエータを正確に制御するために使用することもできます。たとえば、100 ミリ秒後の軸速度に基づいて接着出力を制御するなどです。 これらのアプリケーションを実装するには、 SMC_Get旅行時間 そして SMC_ReadSetValues 予測期間を設定した後の機能ブロック SMC_予測設定 。 使用例については、以下を参照してください。 単軸の動きの予測" }, 
{ "title" : "予測機能を備えた移動機能ブロック ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm2344331274012", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 予報 \/ 予測機能を備えた移動機能ブロック ", 
"snippet" : "次の概要は、どの機能ブロックが予測機能をサポートしているかを示しています。 機能ブロック 予報 MC_Home -- MC_Stop ✓ MC_Halt ✓ MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed MC_HaltSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative ✓ MC_PositionProfile MC_VelocityProfile MC_Acceleration...", 
"body" : "次の概要は、どの機能ブロックが予測機能をサポートしているかを示しています。 機能ブロック 予報 MC_Home -- MC_Stop ✓ MC_Halt ✓ MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed MC_HaltSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative ✓ MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile -- MC_CamIn ✓ MC_CamOut ✓ MC_GearIn ✓ MC_GearOut ✓ MC_GearInPos ✓ SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues -- SMC_SetTorque -- MC_Phasing ✓ MC_Jog SMC_Inch ✓ SMC_BacklashCompensation ✓ " }, 
{ "title" : "予測機能を有効にする ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433129890703", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 予報 \/ 予測機能を有効にする ", 
"snippet" : "予測機能はデフォルトでは無効になっています。つまり、 SMC_ReadSetValues 有効な値のみを返します TimeOffset 0秒（現在のタスクサイクルの開始）からタスク間隔（現在のタスクサイクルの終了）の間、および SMC_GetTravelTime このサイクルで到達した位置に対してのみ有効な時間を返します。 の SMC_予測設定 ファンクションブロックは、必要な予測期間と SMC_予測を取得 ファンクションブロックは読み取りに使用されます。 ノート： 予測期間はいつでも変更できます。 予測計算には計算時間がかかるため、予測期間を不必要に長くしないでください。アプリケーションに十...", 
"body" : "予測機能はデフォルトでは無効になっています。つまり、 SMC_ReadSetValues 有効な値のみを返します TimeOffset 0秒（現在のタスクサイクルの開始）からタスク間隔（現在のタスクサイクルの終了）の間、および SMC_GetTravelTime このサイクルで到達した位置に対してのみ有効な時間を返します。 の SMC_予測設定 ファンクションブロックは、必要な予測期間と SMC_予測を取得 ファンクションブロックは読み取りに使用されます。 ノート： 予測期間はいつでも変更できます。 予測計算には計算時間がかかるため、予測期間を不必要に長くしないでください。アプリケーションに十分な最小値を選択してください。 マスター\/スレーブ機能ブロック（ MC_CamIn ）の場合、マスター軸とスレーブ軸の両方で予測を有効にする必要があります。 " }, 
{ "title" : "コールオーダー ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130424909", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 予報 \/ コールオーダー ", 
"snippet" : "予測関数が最良の結果をもたらすためには、マスター\/スレーブ関数ブロックが正しい順序で呼び出されることを確認することが重要です。これは、 MC_CamIn 、 MC_GearIn 、 MC_GearInPos 、 MC_Phasing 、 SMC_BacklashCompensation 、 そして SMC_TrackAxis マスター軸の移動機能ブロックは、マスター\/スレーブ機能ブロックの前に呼び出す必要があります。 予測がなくても、呼び出し順序が正しければ軌道は良くなります。順序が間違っていると、スレーブの動きが 1 サイクル遅れます。 のために MC_SetOverride 、このファンク...", 
"body" : "予測関数が最良の結果をもたらすためには、マスター\/スレーブ関数ブロックが正しい順序で呼び出されることを確認することが重要です。これは、 MC_CamIn 、 MC_GearIn 、 MC_GearInPos 、 MC_Phasing 、 SMC_BacklashCompensation 、 そして SMC_TrackAxis マスター軸の移動機能ブロックは、マスター\/スレーブ機能ブロックの前に呼び出す必要があります。 予測がなくても、呼び出し順序が正しければ軌道は良くなります。順序が間違っていると、スレーブの動きが 1 サイクル遅れます。 のために MC_SetOverride 、このファンクションブロックも軸の移動ファンクションブロックの前に呼び出される必要があります。オーバーライドを変更すると、同じタスクサイクルで軸の動きが変更されます。その結果、予測に基づいて以前に決定された値は有効性を失います。次回に再び決定されます。 SMC_GetTravelTime または SMC_ReadSetValues と呼ばれます。 " }, 
{ "title" : "バッファモード ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130652478", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 予報 \/ バッファモード ", 
"snippet" : "予測機能は単一の動きに限定されません。ブレンディング モードまたはバッファ バッファ モードでコマンドされる後続のすべての動きにも適用されます。 軸上で中止動作が実行されると、このタスクサイクルにおける軸の動作が変更されます。その結果、予測に基づいて以前に決定された値は有効性が失われます。次回に再度決定されます。 SMC_GetTravelTime または SMC_ReadSetValues と呼ばれます。...", 
"body" : "予測機能は単一の動きに限定されません。ブレンディング モードまたはバッファ バッファ モードでコマンドされる後続のすべての動きにも適用されます。 軸上で中止動作が実行されると、このタスクサイクルにおける軸の動作が変更されます。その結果、予測に基づいて以前に決定された値は有効性が失われます。次回に再度決定されます。 SMC_GetTravelTime または SMC_ReadSetValues と呼ばれます。 " }, 
{ "title" : "有効な予測\/制限 ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130869747", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 予報 \/ 有効な予測\/制限 ", 
"snippet" : "理想的には、有効な予測期間は、構成された予測期間と等しくなります。ただし、有効な予測が構成された予測よりも短くなる要因がいくつかあります。 マスター\/スレーブ移動が実行されると、スレーブの有効予測は、マスターの有効予測とスレーブの構成済み予測の最小値になります。 論理軸とエンコーダ軸の場合、有効な予測は常に 0 になります。 アクティブ移動機能ブロックが予測機能をサポートしていない場合、有効な予測も 0 になります。 それ以外の場合、有効な予測は構成された予測と同じになります。...", 
"body" : "理想的には、有効な予測期間は、構成された予測期間と等しくなります。ただし、有効な予測が構成された予測よりも短くなる要因がいくつかあります。 マスター\/スレーブ移動が実行されると、スレーブの有効予測は、マスターの有効予測とスレーブの構成済み予測の最小値になります。 論理軸とエンコーダ軸の場合、有効な予測は常に 0 になります。 アクティブ移動機能ブロックが予測機能をサポートしていない場合、有効な予測も 0 になります。 それ以外の場合、有効な予測は構成された予測と同じになります。 " }, 
{ "title" : "診断 ", 
"url" : "_sm_basic_error_diagnosis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 診断 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "よくあるエラー ", 
"url" : "_sm_basic_common_errors.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 診断 \/ よくあるエラー ", 
"snippet" : "このページでは、使用時によくあるエラーについて説明します。 CODESYS Softmotion Basic 、その原因、およびエラーを修正するために実行できるアクション。考えられるすべてのエラーのリストと簡単な説明については、ライブラリのドキュメントを参照してください。 エラー エラーコード 説明と原因 行動 SMC_DI_AXIS_ERROR ドライブからエラーが報告されました。 考えられる原因： 位置ラグ リミットスイッチ 過負荷（I²tエラー） ドライブが報告しているエラーを確認します。エラーは、ドライブのディスプレイ（利用可能な場合）から読み取るか、 MC_ReadAxisError...", 
"body" : "このページでは、使用時によくあるエラーについて説明します。 CODESYS Softmotion Basic 、その原因、およびエラーを修正するために実行できるアクション。考えられるすべてのエラーのリストと簡単な説明については、ライブラリのドキュメントを参照してください。 エラー エラーコード 説明と原因 行動 SMC_DI_AXIS_ERROR ドライブからエラーが報告されました。 考えられる原因： 位置ラグ リミットスイッチ 過負荷（I²tエラー） ドライブが報告しているエラーを確認します。エラーは、ドライブのディスプレイ（利用可能な場合）から読み取るか、 MC_ReadAxisError 機能ブロック。 SMC_AXIS_ERROR_DURING_MOTION ドライブがエラーを報告しました。移動中に、アクティブなモーション ブロックがこのエラーを返します。 エラーに対する対処方法を確認する SMC_DI_AXIS_ERROR 。 SMC_FB_WASNT_CALLED_DURING_MOTION アクティブな動きを制御する機能ブロックは、現在のサイクルでは呼び出されていません。 考えられる原因: バッファリングされた動きまたはブレンドされた動きの呼び出し順序が正しくありません。次の動きのファンクションブロックインスタンスは、前の動きを指揮したファンクションブロックインスタンスより先に呼び出してはいけません 現在 SoftMotion バージョン 4.15.0.0 では、このエラーのログ メッセージに、影響を受ける関数ブロックへのインスタンス パスが含まれます。 アプリケーションで、関数ブロックが周期的に呼び出されなかった理由を確認します。 呼び出しが周期的に実行されるように修正します (少なくともブロックが使用されている間は)。 SMC_BLOCKING_MC_STOP_WASNT_CALLED アクティブストップ中、関連する機能ブロック MC_Stop 現在のサイクルでは呼び出されませんでした。 エラーに対する対処方法を確認する SMC_FB_WASNT_CALLED_DURING_MOTION 。 SMC_AXIS_NOT_READY_FOR_MOTION 軸は使用できる状態ではなく、目的の動作を実行できません。 考えられる原因： 軸はそれぞれの動作に対して動作状態ではありません（例えば、 power_off または errorstop ）。 軸はエラー状態にあり、バッファリングされたすべての動きがこのエラーを返します。 軸は stopping 状態（アクティブ MC_Stop ) と新たな中止動作が命令されます。 軸の状態を確認します。 軸は動作状態にありますか？ MC_Power ? 軸は errorstop 状態ですか? そうであれば、軸エラーを特定して修正します。 軸の状態はコマンドされた動きと一致していますか? たとえば、 MC_CamOut 軸が同期動作の状態にある場合にのみ指令できます。 SMC_FB_CALLED_FROM_WRONG_TASK の SoftMotion ブロックは、軸のバス タスクに対応していないタスクから呼び出されました。 なぜなら SoftMotion ブロックが軸の値を変更すると、バス タスク以外のタスクから呼び出しが行われると、矛盾した状態が発生する可能性があります。これにより、未定義のエラーが発生する可能性がありますが、このエラーによって回避されます。 ログを確認します。影響を受ける軸とブロック インスタンスがログに記録されます。 間違ったタスクからの呼び出しを削除します。 SMC_DI_FIELDBUS_LOST_SYNCRONICITY 使用時に発生する EtherCAT 分散クロックでは、コントローラからドライブへのフレームが時間どおりに（定義された時間ウィンドウ（「SyncWindow」）内に）受信されなかったか、まったく受信されなかった場合です。 考えられる原因： リアルタイムの問題: タスクのジッターが高すぎます。 タスクの優先度は EtherCAT タスクが低すぎます。 その他のフィールドバス（例えば、 Modbus ）または時間のかかる操作（例えばファイルアクセス）に加えて、 EtherCAT タスク Modbus 別のタスクで実行されますが、そのタスクで使用されるI\/Oチャネルも参照されます。 EtherCAT タスク。 特にLinuxオペレーティングシステムでは、システムの構成（IRQの優先順位など） コミュニケーションの問題 EtherCAT スレーブ: 接続が中断された、電磁両立性 (EMC) の問題など。 動作の原因を確認します。次の機能が役立ちます。 の ステータスページ の EtherCAT マスター EtherCATタスクのサイクルとジッター時間の分析 タスク構成 リアルタイムの問題に対する可能なアクション: リアルタイムを最適化します。そのためには、の指示に従ってください パフォーマンス最適化 サイクルタイムを延長する EtherCAT タスク。 増加 DCInSyncWindow の EtherCAT マスター。参照: IoDrvEtherCAT.DCInSyncWindow (PROP) 有効にする FrameAtTaskStart のために EtherCAT マスター。参照: IoDrvEtherCAT.FrameAtTaskStart (PROP) ドライブが同期の問題を処理できる場合は、同期チェックを無効にすることができます。 SMC_Set_ETC_DC同期監視 。 SMC_DI_SWLIMITS_EXCEEDED 軸は正または負のソフトウェア リミット スイッチの方向に移動し、現在のダイナミクスでその位置を超えます。必要なブレーキ距離も計算に含まれているため、実際のリミット スイッチの位置よりも前にエラーが発生します。 この位置範囲で動きが望ましいかどうかを確認します。 必要に応じて、負または正のソフトウェアリミットスイッチの位置を調整します。 タブ：一般SMC_DI_HWLIMITS_EXCEEDED 正または負のハードウェア リミット スイッチがトリガーされ、軸がこのリミット スイッチの方向に移動します。 移動の指示された位置を確認します。これはハードウェア リミット スイッチの位置を超えてはなりません。 動きが正常であれば、ハードウェア リミット スイッチの信号を確認します。 SMC_MOVING_WITHOUT_ACTIVE_MOVEMENT アクティブな動きはありませんが、設定された速度はゼロではなく、軸は設定された値に従う動作状態にあります。 考えられる原因： 使用する場合 MC_PositionProfile 、 MC_VelocityProfile 、 または MC_AccelerationProfile 軸はこの動きの終わりに停止するか、同じサイクルで後続の動きを命令する必要があります。そうでない場合は、このエラーが返されます。 問題の原因を確認してください: バッファリングされた動きとブレンドの動きの呼び出し順序が正しくありません。呼び出し順序を調整してください。詳細については、セクションを参照してください。 移動機能ブロックの実行順序。 MC_PositionProfile 、 MC_VelocityProfile 、 または MC_AccelerationProfile が使用され、最後に停止に達しない場合：プロファイルを調整して、最後に停止に達するようにします。または、代わりに カムは、これらの機能ブロックと同様のユースケースをカバーしますが、より柔軟で使いやすいです。 " }, 
{ "title" : "パフォーマンス ", 
"url" : "_sm_diagnosis_performance.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 診断 \/ パフォーマンス ", 
"snippet" : "を使用する POU AXIS_REF_SM3 ファンクションブロックは、バスサイクルタスクから呼び出されているかどうかを常にチェックします。このチェックは、コンパイラの定義によって、タイム クリティカルなアプリケーションに対して無効にすることができます。 SM3_DISABLE_TASK_CHECKS ....", 
"body" : "を使用する POU AXIS_REF_SM3 ファンクションブロックは、バスサイクルタスクから呼び出されているかどうかを常にチェックします。このチェックは、コンパイラの定義によって、タイム クリティカルなアプリケーションに対して無効にすることができます。 SM3_DISABLE_TASK_CHECKS . " }, 
{ "title" : "例 ", 
"url" : "_sm_basic_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "単軸動作 ", 
"url" : "_sm_basic_examples_single_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ 単軸動作 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "単一軸の動きの制御 ", 
"url" : "_sm_example_single_axis_motion_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ 単軸動作 \/ 単一軸の動きの制御 ", 
"snippet" : "を参照してください PLCopenSingle.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例は、PLCopenの標準化された機能ブロックを使用してドライブを制御する方法を示しています。 名前の付いた仮想ドライブを挿入します Drive 下のデバイスツリーで SoftMotion一般軸プール 。 作成する MOTION_PRG STのプログラム。 PROGRAM MOTION_PRG VAR iStatus: INT; Power: MC_Power; MoveAbsolute:...", 
"body" : "を参照してください PLCopenSingle.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例は、PLCopenの標準化された機能ブロックを使用してドライブを制御する方法を示しています。 名前の付いた仮想ドライブを挿入します Drive 下のデバイスツリーで SoftMotion一般軸プール 。 作成する MOTION_PRG STのプログラム。 PROGRAM MOTION_PRG\nVAR\n iStatus: INT;\n Power: MC_Power;\n MoveAbsolute: MC_MoveAbsolute;\n p:REAL:=100;\nEND_VAR\n\nCASE iStatus OF\n\n\/\/ initialization of the axis\n0:\n Power(Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE, Axis:=Drive);\n IF Power.Status THEN\n iStatus := iStatus + 1;\n END_IF\n\n\/\/ Move the axis to position p by use of the MC_MoveAbsolute function block\n1:\n MoveAbsolute(Execute:=TRUE, Position:= p, Velocity:=100, Acceleration:=100, Deceleration:=100, Axis:=Drive);\n IF MoveAbsolute.Done THEN\n MoveAbsolute(Execute:=FALSE, Axis:=Drive);\n iStatus := iStatus + 1;\n END_IF\n\n\/\/ Move the axis back to position 0 by use of the MC_MoveAbsolute function block:\n2:\n MoveAbsolute(Execute:=TRUE, Position:= 0, Velocity:=100, Acceleration:=100, Deceleration:=100, Axis:=Drive);\n IF MoveAbsolute.Done THEN\n MoveAbsolute(Execute:=FALSE, Axis:=Drive);\n iStatus := 1;\n END_IF MOTION_PRGプログラムの呼び出しをタスクに追加します 主な任務 。 デバイスツリー： プロジェクトをコントローラーにダウンロードして開始します。 を開きます ドライブ エディターの仮想軸。 の中に オンライン の一部 全般的 タブ、あなたは軸の動きを見る。 " }, 
{ "title" : "視覚化テンプレートを使用してCFCの単一軸の動きを制御する ", 
"url" : "_sm_example_single_axis_visu_template.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ 単軸動作 \/ 視覚化テンプレートを使用してCFCの単一軸の動きを制御する ", 
"snippet" : "を参照してください PLCopenSingle2.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 STの代わりに他のIEC実装言語（ここではCFCなど）を使用することもできます。この言語は、機能ブロックの開始および割り込みメカニズムを示しています。さらに、機能ブロックのさまざまな開始モード MC_MoveAbsolute 回転軸をテストできます。 名前の付いた仮想ドライブを挿入します Drive 下のデバイスツリーで SoftMotion一般軸プール 。 オブジェクトをダブルクリックして...", 
"body" : "を参照してください PLCopenSingle2.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 STの代わりに他のIEC実装言語（ここではCFCなど）を使用することもできます。この言語は、機能ブロックの開始および割り込みメカニズムを示しています。さらに、機能ブロックのさまざまな開始モード MC_MoveAbsolute 回転軸をテストできます。 名前の付いた仮想ドライブを挿入します Drive 下のデバイスツリーで SoftMotion一般軸プール 。 オブジェクトをダブルクリックして、エディターを開きます。 パラメータを360°周期のロータリードライブに変更します。 軸タイプ ：モジュロ モジュロ値[u] ：360.0 作成する MOTION_PRG CFCのプログラム。機能ブロックを挿入します MC_Power 、 MC_MoveAbsolute 、 と MC_MoveVelocity 。 通常、ファンクションブロック入力を初期化することをお勧めします。その後、このテストアプリケーションを起動するときに、値を何度も指定する必要はありません。 PROGRAM MOTION_PRG\nVAR\n mcp: MC_Power := (Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n mcmv: MC_MoveVelocity :=(Velocity:=100, Acceleration:=100, Deceleration:=100, Direction:=positive);\n mcma: MC_MoveAbsolute := (Position:=180, Velocity:=100, Acceleration:=100, Deceleration:=100, Direction:=positive);\nEND_VAR CFC： の呼び出しを追加します MOTION_PRG タスクへのプログラム 主な任務 。 追加する 視覚化 アプリケーションに反対します。 視覚化テンプレートを配置します VISU_NEW_MC_MoveAbsolute 、 VISU_NEW_MC_MoveVelocity 、 VISU_NEW_MC_Power 、 と RotDrive 視覚化エディタで。これらをの機能ブロックインスタンスにリンクします MOTION_PRG 。 視覚化： プロジェクトをビルドし、PLCにダウンロードします。プロジェクトを開始します。 エディターでビジュアライゼーションを開きます。クリック 有効 入力（MC_Power）、次に 実行する 入力（MC_Move_Absolute）。 ドライブが回転します。 を開きます ドライブ エディターの仮想軸。 の中に オンライン の一部 全般的 タブ、あなたは軸の動きを見る。 これらの機能ブロックのパラメーターを試してください。パラメータを変更し、動作を観察します。 " }, 
{ "title" : "単軸の動きの予測 ", 
"url" : "_sm_basic_example_forecast.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ 単軸動作 \/ 単軸の動きの予測 ", 
"snippet" : "の BasicMotion_Forecast.project サンプルプロジェクトは、インストールディレクトリにあります。 CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例では、軸の将来の状態に関する情報を取得するために、軸の予測を定義する方法を示します。 この例では、軸上で位置 10 への絶対移動が実行されます。軸に 300 ミリ秒の予測を設定すると、軸が位置 8 を通過するタイミングとダイナミクスをアプリケーションで事前に確認できます。 軸の予測に関する詳細については、以下を参照してください。 予報...", 
"body" : "の BasicMotion_Forecast.project サンプルプロジェクトは、インストールディレクトリにあります。 CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例では、軸の将来の状態に関する情報を取得するために、軸の予測を定義する方法を示します。 この例では、軸上で位置 10 への絶対移動が実行されます。軸に 300 ミリ秒の予測を設定すると、軸が位置 8 を通過するタイミングとダイナミクスをアプリケーションで事前に確認できます。 軸の予測に関する詳細については、以下を参照してください。 予報" }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_basic_example_forecast.html#UUID-0813b57c-b654-1961-50ef-d370b88506f6_section-idm43442768266588", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ 単軸動作 \/ 単軸の動きの予測 \/ アプリケーションの構造 ", 
"snippet" : "アプリケーションは、 PLC_PRG プログラムと Trace 。 PLC_PRG 仮想軸は、 STATE_POWER_DRIVE 状態。その後、 SMC_SetForecast 関数ブロックは、軸の300ミリ秒の予測を定義するために使用されます。 STATE_SET_FORECAST 状態。 SMC_GetForecast 関数ブロックを使用して、軸に設定された予測を読み取ることができます。 の中に STATE_MOVE_TO_POSITION 状態になると、位置10への絶対移動が実行されます。 SMC_GetTravelTime ファンクションブロックも開始されます。このファンクションブロ...", 
"body" : "アプリケーションは、 PLC_PRG プログラムと Trace 。 PLC_PRG 仮想軸は、 STATE_POWER_DRIVE 状態。その後、 SMC_SetForecast 関数ブロックは、軸の300ミリ秒の予測を定義するために使用されます。 STATE_SET_FORECAST 状態。 SMC_GetForecast 関数ブロックを使用して、軸に設定された予測を読み取ることができます。 の中に STATE_MOVE_TO_POSITION 状態になると、位置10への絶対移動が実行されます。 SMC_GetTravelTime ファンクションブロックも開始されます。このファンクションブロックは、軸が位置8に到達する時間を読み取るために使用されます。 SMC_ReadSetValues 関数ブロックは、位置 8 のダイナミクスを決定するために使用されます。軸のダイナミクスを読み取る必要があるこの関数ブロックに時間オフセットを渡すことができます。この場合、軸が位置 8 に到達するのに必要な期間を渡します。 痕跡 トレースを使用して、仮想軸の動きを追跡できます。軸の現在の位置、速度、加速度が記録されます。位置 8 までの期間と、この位置での軸のダイナミクスも表示されます。 の期間は SMC_GetTravelTime サイクルの開始を基準として指定されます。軸の設定値はサイクルの終了時の値に対応します。 " }, 
{ "title" : "試運転 ", 
"url" : "_sm_basic_example_forecast.html#UUID-0813b57c-b654-1961-50ef-d370b88506f6_section-idm43442768283734", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ 単軸動作 \/ 単軸の動きの予測 \/ 試運転 ", 
"snippet" : "アプリケーションをビルドし、コントローラーにダウンロードします。 トレースおよびアプリケーションを起動します。 トレースでは、仮想軸の動きを追跡できます。位置 8 までの期間と位置 8 でのダイナミクスに注目してください。...", 
"body" : "アプリケーションをビルドし、コントローラーにダウンロードします。 トレースおよびアプリケーションを起動します。 トレースでは、仮想軸の動きを追跡できます。位置 8 までの期間と位置 8 でのダイナミクスに注目してください。 " }, 
{ "title" : "2軸の同期動作 ", 
"url" : "_sm_basic_synch_movements_2_axis_example.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ 2軸の同期動作 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "電子ギア、位相オフセット、ギアバックラッシュの補正 ", 
"url" : "_sm_basic_example_synchronized_motion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ 2軸の同期動作 \/ 電子ギア、位相オフセット、ギアバックラッシュの補正 ", 
"snippet" : "を参照してください BasicMotion_SynchronizedMotion.project インストールディレクトリの例 CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例では、位相オフセットとギア バックラッシュ補正と組み合わせて電子ギアボックスを使用する方法を示します。...", 
"body" : "を参照してください BasicMotion_SynchronizedMotion.project インストールディレクトリの例 CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例では、位相オフセットとギア バックラッシュ補正と組み合わせて電子ギアボックスを使用する方法を示します。 " }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_basic_example_synchronized_motion.html#UUID-5f979be9-50d7-427c-01e2-01bc4a0e21cb_section-idm4538843986680034227085857199", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ 2軸の同期動作 \/ 電子ギア、位相オフセット、ギアバックラッシュの補正 \/ アプリケーションの構造 ", 
"snippet" : "アプリケーションは、 PLC_PRG プログラムとトレースは、機能ブロックの機能を簡単に追跡するために使用できます。 軸を有効にするには MC_Power 。 (STATE_POWER ） 同期動作を開始し、マスター軸を位置0と位置100（ STATE_COMMAND_POS_0 そして STATE_COMMAND_POS_1 ）。...", 
"body" : "アプリケーションは、 PLC_PRG プログラムとトレースは、機能ブロックの機能を簡単に追跡するために使用できます。 軸を有効にするには MC_Power 。 (STATE_POWER ） 同期動作を開始し、マスター軸を位置0と位置100（ STATE_COMMAND_POS_0 そして STATE_COMMAND_POS_1 ）。 " }, 
{ "title" : "使用法 ", 
"url" : "_sm_basic_example_synchronized_motion.html#UUID-5f979be9-50d7-427c-01e2-01bc4a0e21cb_section-idm4561564117984034227086974585", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ 2軸の同期動作 \/ 電子ギア、位相オフセット、ギアバックラッシュの補正 \/ 使用法 ", 
"snippet" : "マスター軸 (トレース図の黒) は、最大速度 50 単位\/秒で位置 0 と位置 100 の間を連続的に前後に移動します。 電子ギアボックス（ MC_GearIn ）は、ギア比2:3でマスタームーブメントを Slave0 軸（トレース図の緑色）です。ギアから生じる最大速度は 1 秒あたり 75 単位です。 次に、位相オフセット（ MC_Phasing ）30単位が適用されます Slave1 軸（トレース図ではオレンジ色）の速度は Slave0 ランプインフェーズを除いて、軸と同じです。 最後に、ギアのバックラッシュ補正を使用して、動きを Drive 軸（トレース図では青）です。デモンストレーショ...", 
"body" : "マスター軸 (トレース図の黒) は、最大速度 50 単位\/秒で位置 0 と位置 100 の間を連続的に前後に移動します。 電子ギアボックス（ MC_GearIn ）は、ギア比2:3でマスタームーブメントを Slave0 軸（トレース図の緑色）です。ギアから生じる最大速度は 1 秒あたり 75 単位です。 次に、位相オフセット（ MC_Phasing ）30単位が適用されます Slave1 軸（トレース図ではオレンジ色）の速度は Slave0 ランプインフェーズを除いて、軸と同じです。 最後に、ギアのバックラッシュ補正を使用して、動きを Drive 軸（トレース図では青）です。デモンストレーションのために、ギアのバックラッシュには非現実的な 5 単位の値が設定されています。図は、動きの開始時と動きの方向が反転するたびに補正動作を示しています。 " }, 
{ "title" : "GearInPos (フライングソー) ", 
"url" : "_sm_basic_example_gearinpos.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ 2軸の同期動作 \/ GearInPos (フライングソー) ", 
"snippet" : "を参照してください BasicMotion_GearInPos.project インストールディレクトリ内の例 CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例では、 MC_GearInPos フライングソーを実装します。このプロジェクトでは、インストールすることをお勧めします CODESYS Depictor 、アプリケーションを 3D アニメーションとして表示できます。(ライセンスのない無料バージョンでもこれを行うには十分です。)...", 
"body" : "を参照してください BasicMotion_GearInPos.project インストールディレクトリ内の例 CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例では、 MC_GearInPos フライングソーを実装します。このプロジェクトでは、インストールすることをお勧めします CODESYS Depictor 、アプリケーションを 3D アニメーションとして表示できます。(ライセンスのない無料バージョンでもこれを行うには十分です。) " }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm4565133330038434227193133829", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ 2軸の同期動作 \/ GearInPos (フライングソー) \/ アプリケーションの構造 ", 
"snippet" : "アプリケーションは、 PLC_PRG プログラム、3D表現（シーン、 DepictorCalculation プログラム）、簡単なワークピースシミュレーション（ SimulateWorkpiece プログラムの実行結果（実行結果のグラフ、実行結果の要約、実行結果の要約）と、関数ブロックの効果を簡単に理解できるトレースを提供します。 PLC_PRG のフローは次のとおりです。 軸を有効にするには MC_Power 。 （ STATE_POWER ） 光バリアがワークピースを検出するまで待ちます。 STATE_WAIT_FOR_WORKPIECE ） 光バリアがワークピースを検出するとすぐに、鋸を...", 
"body" : "アプリケーションは、 PLC_PRG プログラム、3D表現（シーン、 DepictorCalculation プログラム）、簡単なワークピースシミュレーション（ SimulateWorkpiece プログラムの実行結果（実行結果のグラフ、実行結果の要約、実行結果の要約）と、関数ブロックの効果を簡単に理解できるトレースを提供します。 PLC_PRG のフローは次のとおりです。 軸を有効にするには MC_Power 。 （ STATE_POWER ） 光バリアがワークピースを検出するまで待ちます。 STATE_WAIT_FOR_WORKPIECE ） 光バリアがワークピースを検出するとすぐに、鋸をコンベアベルトと平行に搬送するスレーブがコンベアベルト上のワークピースと同期します（ Master 軸）。 STATE_WAIT_FOR_SYNC ） 同期が達成されると、鋸はワークピースに対して垂直に前後に1回移動します。 STATE_MOVE_TOOL_0\/1 ） スレーブを休止位置に移動し、プロセスを 2 から再度開始します。( STATE_MOVE_TO_REST ） " }, 
{ "title" : "座標系と次元 ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm4627667581768034227193767932", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ 2軸の同期動作 \/ GearInPos (フライングソー) \/ 座標系と次元 ", 
"snippet" : "座標系の原点はコンベア ベルトの中心にあり、Z 軸は上向き、X 軸はコンベア ベルトの移動方向を指します。コンベア ベルトから見ると、Y 軸はのこぎりから離れる方向を指します。 コンベアベルトとワークピースの寸法、光バリアの位置、およびワークピースと同期して鋸が動作する位置は、定数として保存されます。 GVL Const 。...", 
"body" : "座標系の原点はコンベア ベルトの中心にあり、Z 軸は上向き、X 軸はコンベア ベルトの移動方向を指します。コンベア ベルトから見ると、Y 軸はのこぎりから離れる方向を指します。 コンベアベルトとワークピースの寸法、光バリアの位置、およびワークピースと同期して鋸が動作する位置は、定数として保存されます。 GVL Const 。 " }, 
{ "title" : "使用法 ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm458752582335683422719410462", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ 2軸の同期動作 \/ GearInPos (フライングソー) \/ 使用法 ", 
"snippet" : "アプリケーションを起動します。 シーン Depictor オブジェクトとトレースでは、マスター (コンベア ベルト上のワークピース) とスレーブ (のこぎり) 間の同期がどのように実行されるかを確認できます。...", 
"body" : "アプリケーションを起動します。 シーン Depictor オブジェクトとトレースでは、マスター (コンベア ベルト上のワークピース) とスレーブ (のこぎり) 間の同期がどのように実行されるかを確認できます。 " }, 
{ "title" : "カム ", 
"url" : "_sm_basic_examples_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ カム ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "交互カム ", 
"url" : "_sm_example_changing_cams.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ カム \/ 交互カム ", 
"snippet" : "を参照してください PLCopenMultiCAM.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例は、2つの交互のカムを使用してカムの動きを作成する方法を示しています。プログラムはSTに実装され、「仮想時間軸を使用したカムドライブ制御」の例と同じアクションを実行します。最初のカムの終わりに、 MC_CamIn 機能ブロックは、 EndOfProfile 出力。このようにして、他の曲線テーブルがに割り当てられます MC_CamTableSelect と MC_CamIn 再起動され...", 
"body" : "を参照してください PLCopenMultiCAM.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例は、2つの交互のカムを使用してカムの動きを作成する方法を示しています。プログラムはSTに実装され、「仮想時間軸を使用したカムドライブ制御」の例と同じアクションを実行します。最初のカムの終わりに、 MC_CamIn 機能ブロックは、 EndOfProfile 出力。このようにして、他の曲線テーブルがに割り当てられます MC_CamTableSelect と MC_CamIn 再起動されます。 " }, 
{ "title" : "仮想時間軸を使用したカムドライブの制御 ", 
"url" : "_sm_example_drive_control_virtual_time_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ カム \/ 仮想時間軸を使用したカムドライブの制御 ", 
"snippet" : "を参照してください PLCopenMulti.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例は、リニアドライブに周期カムを実装する方法を示しています。この例では、タペット機能の使用方法も示しています。 名前の付いたカムを挿入します Example 下のデバイスツリーで 応用 。エディターでカムを開きます。 でタペットを定義します タペット タブ。 NS ： 8.0 ポジティブパス ： Invert ネガティブパス ： Invert 名前の付いた仮想ドライブを挿入します Drive...", 
"body" : "を参照してください PLCopenMulti.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例は、リニアドライブに周期カムを実装する方法を示しています。この例では、タペット機能の使用方法も示しています。 名前の付いたカムを挿入します Example 下のデバイスツリーで 応用 。エディターでカムを開きます。 でタペットを定義します タペット タブ。 NS ： 8.0 ポジティブパス ： Invert ネガティブパス ： Invert 名前の付いた仮想ドライブを挿入します Drive 下のデバイスツリーで SoftMotion一般軸プール 。この軸には、軸タイプを選択します モジュロ モジュロ値が 360 。 名前の付いた別の仮想ドライブを挿入します Virtual 。この軸には、 モジュロ モジュロ値が 10 。 作成する MOTION_PRG CFCのプログラム。 PROGRAM MOTION_PRG\nVAR\n power1, power2: MC_Power;\n TableSelect: MC_CamTableSelect;\n CamIn: MC_CamIn;\n Tappet: SMC_GetTappetValue;\n MoveVirtual: MC_MoveVelocity;\nEND_VAR ボックス要素を挿入し、変数を割り当てます power1 それに。ボックス要素は、スイッチをオンにするために使用されます Drive 。 次のように入力を構成します。 軸 ： Drive 有効 ： TRUE bRegulatorOn ： TRUE bDriveStart TRUE ボックス要素を挿入し、変数を割り当てます power2 それに。ボックス要素は、スイッチをオンにするために使用されます Virtual ドライブ。 次のように入力を構成します。 軸 ： Virtual 有効 ： TRUE bRegulatorOn ： TRUE bDriveStart TRUE ボックス要素を挿入し、変数を割り当てます MoveVirtual それに。ボックス要素は、仮想マスターを移動するために使用されます。 次のように入力を構成します。 軸 ： Virtual 実行する ： power2.Status 速度 ： 2 加速度 10 減速 10 方向 positive ボックス要素を挿入し、変数を割り当てます TableSelect それに。ボックス要素は、カムを選択するために使用されます。 次のように入力を構成します。 主人 ： Virtual 奴隷 ： Drive CamTable ： Example 実行する TRUE 定期的 TRUE MasterAbsolute TRUE SlaveAbsolute TRUE ボックス要素を挿入し、変数を割り当てます CamIn それに。ボックス要素は、選択したカムプレートを実装します。 次のように入力を構成します。 主人 ： Virtual 奴隷 ： Drive 実行する power1.Status MasterOffset ： 0 SlaveOffset ： 0 MasterScaling ： 1 SlaveScaling ： 1 StartMode ： absolute CamTableID ： TableSelect.CamTableID VelocityDiff ： 1 加速度 ： 1 減速 ： 1 TappetHysteresis ： 1 ボックス要素を挿入し、変数を割り当てます Tappet それに。ボックス要素は、カムスイッチの設定をチェックします。 次のように入力を構成します。 タペット ： CamIn.Tappets iID ： 1 bInitValue FALSE bSetInitValueAtReset ： FALSE タペットは、反転タペットとして定義されています。このため、その値は10秒ごとに変更されます。 サンプルプロジェクトは、個々の機能ブロックと軸の位置を確認するための視覚化を提供します。 の呼び出しを追加します MOTION_PRG タスクへのプログラム 主な任務 。 プロジェクトをコントローラーにダウンロードして開始します。 詳細については、以下を参照してください。 MC_Power MC_CamTableSelect MC_CamIn SMC_GetTappetValue MC_MoveVelocity " }, 
{ "title" : "プログラムによるカムの作成 ", 
"url" : "_sm_basic_example_cam_programmatic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ カム \/ プログラムによるカムの作成 ", 
"snippet" : "の BasicMotion_CreateCamTableOnline.project サンプルプロジェクトは、インストールディレクトリにあります。 CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例は、IEC コードを使用してカムを作成して使用する方法を示しています。ここでは以下の点について説明します カムエディタで作成されたカムは、IEC コードを使用して再度作成されます。 あるケースでは、カムディスクはバスタスクで生成されます。 それ以外の場合は、カムディスクは別のタスクで生成されます。 次に、3 つのカムすべてが同じマスター軸と異なるスレーブ軸で...", 
"body" : "の BasicMotion_CreateCamTableOnline.project サンプルプロジェクトは、インストールディレクトリにあります。 CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例は、IEC コードを使用してカムを作成して使用する方法を示しています。ここでは以下の点について説明します カムエディタで作成されたカムは、IEC コードを使用して再度作成されます。 あるケースでは、カムディスクはバスタスクで生成されます。 それ以外の場合は、カムディスクは別のタスクで生成されます。 次に、3 つのカムすべてが同じマスター軸と異なるスレーブ軸で動作します。3 つのスレーブの動きは同じです IEC コードで生成されたカムがビジュアライゼーションに表示されます。 プログラムによるカムの作成に関する詳細については、以下を参照してください。 プログラムによるカムの作成" }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_basic_example_cam_programmatic.html#UUID-ea402455-f321-1e3f-0d8c-522b4772732e_section-idm4538843986680034227085857199", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ カム \/ プログラムによるカムの作成 \/ アプリケーションの構造 ", 
"snippet" : "アプリケーションは次のコンポーネントで構成されています。 CamOffline カムエディタで作成したカム。IEC コードを使用して再度作成する必要があります。 PLC_PRG このプログラムは、単純なステートマシンと、論理的には3つの部分で構成されています。第 1 部と第 2 部では IEC コードでカムが作成されています。第 3 部では、以前に作成したカムとオフラインで作成した同一のカムを実行します パート1： 最初の状態では STATE_CREATE_ONLINE_TABLE 、カムはIECコードで作成されます。 SMCB.カムビルダー 機能ブロックから SM3_CamBuilder こ...", 
"body" : "アプリケーションは次のコンポーネントで構成されています。 CamOffline カムエディタで作成したカム。IEC コードを使用して再度作成する必要があります。 PLC_PRG このプログラムは、単純なステートマシンと、論理的には3つの部分で構成されています。第 1 部と第 2 部では IEC コードでカムが作成されています。第 3 部では、以前に作成したカムとオフラインで作成した同一のカムを実行します パート1： 最初の状態では STATE_CREATE_ONLINE_TABLE 、カムはIECコードで作成されます。 SMCB.カムビルダー 機能ブロックから SM3_CamBuilder この目的にはライブラリが使用されます。3つのセグメントが追加されます。Poly5要素、Line要素、そしてもう1つのPoly5要素です。ビルダーは カムオンライン ここからカムを作成します。この時点から、カムはIECコードで作成され、 カムオフライン カム エディターでオフラインで作成されたカム。 パート2： で STATE_INIT_ONLINE_TABLE_MULTITASK 、 STATE_START_CREATE_ONLINE_TABLE_MULTITASK 、および STATE_READ_ONLINE_TABLE_MULTITASK という状態で、カムの作成は別のタスクで開始されてから読み込まれます。 パート 3: で STATE_POWER_DRIVES 状態、マスター軸と 3 つのスレーブ軸の仮想軸が初期化されます。次に、以下を使用してカムを選択します MC_CamTableSelect で STATE_SELECT_TABLE ファイナルでステートと実行 STATE_MOVEMENT 状態。マスター軸は以下を使用して移動されます MC_MoveVelocity そして 3 つのカムのマスターとして使用されます。 MultitaskCamBuilder 第 1 回で説明したカムを生成するプログラム PLC_PRG 。唯一の違いは、カムのマルチタスク\/マルチコアセーフバリアントが使用されていることです GVL カムのマルチタスク\/マルチコアセーフバリアントがここでインスタンス化されています。 Visualization ビジュアライゼーションには SMC_Visu_CamDisplayer カムを表示するためのエレメント。のパート 1 で生成されたカム PLC_PRG が表示されます。 CamDisplayerSettings にカムを表示するための追加要素 Visualization Trace トレースを使用して仮想軸の動きを追跡できます。マスターの現在位置と、3 つのスレーブ軸の位置、速度、加速度が記録されます " }, 
{ "title" : "試運転 ", 
"url" : "_sm_basic_example_cam_programmatic.html#UUID-ea402455-f321-1e3f-0d8c-522b4772732e_section-idm4561564117984034227086974585", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ カム \/ プログラムによるカムの作成 \/ 試運転 ", 
"snippet" : "アプリケーションをビルドし、コントローラーにダウンロードします。 トレースおよびアプリケーションを起動します。 サンプリングトレースを観察します。 生成されたカムのビジュアライゼーションでの表示...", 
"body" : "アプリケーションをビルドし、コントローラーにダウンロードします。 トレースおよびアプリケーションを起動します。 サンプリングトレースを観察します。 生成されたカムのビジュアライゼーションでの表示 " }, 
{ "title" : "MC_DigitalCamSwitch_HighPrecisionを使用しています。 ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ カム \/ MC_DigitalCamSwitch_HighPrecisionを使用しています。 ", 
"snippet" : "この例 BasicMotion_DigitalCamSwitch_HighPrecision.project はインストールディレクトリにあります。 CODESYS 下に ..\\CODESYS SoftMotion\\Examples 。 この例は、の出力を使用する方法を示しています SMC_DigitalCamSwitch_HighPrecision デジタル出力を高い時間分解能で制御します。ベッコフのEL2258端子とEL2252端子が例として使われています Beckhoffのデバイスの説明はこの例には含まれていません。これらはベンダーから直接ダウンロードして、デバイスリポジトリにインストー...", 
"body" : "この例 BasicMotion_DigitalCamSwitch_HighPrecision.project はインストールディレクトリにあります。 CODESYS 下に ..\\CODESYS SoftMotion\\Examples 。 この例は、の出力を使用する方法を示しています SMC_DigitalCamSwitch_HighPrecision デジタル出力を高い時間分解能で制御します。ベッコフのEL2258端子とEL2252端子が例として使われています Beckhoffのデバイスの説明はこの例には含まれていません。これらはベンダーから直接ダウンロードして、デバイスリポジトリにインストールできます。この例を実行するには、EK1100 バスカプラー、EL2258 ターミナル、および EL2252 ターミナルが必要です この例は、EL2258のリビジョン0017およびEL2252のリビジョン0020に従って開発およびテストされました。これはあくまで一例に過ぎません。その正確性を保証するものではありません。ソースコードは使用前にテストする必要があります。必要であれば、端末の他のリビジョンに合わせて修正する必要があります " }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856510750361", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ カム \/ MC_DigitalCamSwitch_HighPrecisionを使用しています。 \/ アプリケーションの構造 ", 
"snippet" : "アプリケーションの構成は Main プログラム、 DigitalCamSwitch_EL2258 そして DigitalCamSwitch_EL2252 ファンクションブロック、およびEL2258およびEL2252出力端子を備えたEK1100バスカプラー。 ザル DigitalCamSwitch_EL2258 そして DigitalCamSwitch_EL2252 この例ではファンクションブロックが重要な部分です。の使い方を示しています Events の出力 SMC_DigitalCamSwitch_HighPrecision デジタル出力をプログラムします。ファンクションブロックは、他のハー...", 
"body" : "アプリケーションの構成は Main プログラム、 DigitalCamSwitch_EL2258 そして DigitalCamSwitch_EL2252 ファンクションブロック、およびEL2258およびEL2252出力端子を備えたEK1100バスカプラー。 ザル DigitalCamSwitch_EL2258 そして DigitalCamSwitch_EL2252 この例ではファンクションブロックが重要な部分です。の使い方を示しています Events の出力 SMC_DigitalCamSwitch_HighPrecision デジタル出力をプログラムします。ファンクションブロックは、他のハードウェアにも適用できる例として理解しておく必要があります。 " }, 
{ "title" : "DigitalCamSwitch_EL2258 ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856513787236", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ カム \/ MC_DigitalCamSwitch_HighPrecisionを使用しています。 \/ アプリケーションの構造 \/ DigitalCamSwitch_EL2258 ", 
"snippet" : "ファンクションブロックは次のように機能します。 ファンクションブロックは、のライジングエッジで初期化されます Enable 入力。 STATE_INIT_0 と STATE_INIT_1 ステート、 OutputBufferReset EL2258 ターミナルのシグナルが書き込まれ、 aLastEventIds 配列が初期化されます。各トラックで最後に処理されたイベントの ID がこの配列に保存されます。これにより、イベントが端末に複数回転送されるのを防ぎます。 初期化後 ( STATE_ACTIVE ) を指定すると、すべてのトラックが順番に処理され、各トラックに対して次のロジックが実行され...", 
"body" : "ファンクションブロックは次のように機能します。 ファンクションブロックは、のライジングエッジで初期化されます Enable 入力。 STATE_INIT_0 と STATE_INIT_1 ステート、 OutputBufferReset EL2258 ターミナルのシグナルが書き込まれ、 aLastEventIds 配列が初期化されます。各トラックで最後に処理されたイベントの ID がこの配列に保存されます。これにより、イベントが端末に複数回転送されるのを防ぎます。 初期化後 ( STATE_ACTIVE ) を指定すると、すべてのトラックが順番に処理され、各トラックに対して次のロジックが実行されます。 EL2258ターミナルが最後にコマンドされたイベントをすでに受け入れているかどうかを確認します（ ChannelsIn[channel].OutputOrderFeedback = ChannelsOut[channel].OutputOrderCounter )。 トラックのすべてのイベントをループ処理します。該当するイベントのみ ToggleEventId が最後に処理された ID よりも大きい場合は、さらに処理されたものとみなされます。(クエリ) EventId_GreaterThan(event^.ToggleEventId, aLastEventIds[channel]) ) 「イベント順序に関する注意」セクションを参照してください。 を変換する Duration イベントの EtherCAT タイムスタンプへの書き込みと、それに対応するイベントの書き込み ChannelsOut[channel].OutputEventState と ChannelsOut[channel].OutputEventTime 出力。 最大 5 件のイベントが発生すると、処理を中止します。 少なくとも 1 つのイベントが見つかった場合は、新しいイベントが存在することを端末に通知します ( ChannelsOut[channel].OutputOrderCounter := ChannelsOut[channel].OutputOrderCounter + 1 )。 イベント順序に関する注意事項 イベントは、によって返されます。 SMC_DigitalCamSwitch_HighPrecision 配列内の各トラックのファンクションブロック。 SwitchNumber と ToggleEventId イベントごとに返されます。これ ToggleEventId はトラックごとにユニークで昇順になっています。 詳細については、以下を参照してください。 SMC_CAMSWITCH_TOGGLE_EVENT 。 この例では、 aLastEventIds[trackNo] 各トラックの配列には以下の内容が格納されます。 ToggleEventId 前回のファンクションブロック呼び出しで端末に最後に転送されました。 ToggleEventIds が昇順であれば、次の呼び出しでどのイベントをまだ転送する必要があるかが正確にわかります。 次の 2 つの詳細について検討する必要があります。 どっちなのかわからないから ToggleEventId イベントが開始すると、 valid フラグは EventId に加えてデータタイプ。 EventId_GreaterThan 比較、これ valid フラグはそれに応じて考慮されます。 ザル ToggleEventIds 32 ビットのデータ型である UDINT そのため、動作時間が長くなったり、スイッチング周波数が高くなったりすると、原則としてオーバーフローする可能性があります。その後、値は 2^32-1 から 0 に戻ります。比較関数です。 EventId_GreaterThan 32 ビットのオーバーフローも考慮されます。 プロッドマッピング EL2258 ザル ChannelsOut と ChannelsIn の出力 DigitalCamSwitch_EL2258 ファンクションブロックは EL2258 ターミナルの各 I\/O チャンネルに接続されています。以下の画像はチャンネル1のマッピングを示しています。チャネル 2 も同様ですが、アクセスする場合だけです。 ChannelsOut と ChannelsIn インデックスは 1 ではなく 2 です。 " }, 
{ "title" : "DigitalCamSwitch_EL2252 ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234861434780928", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ カム \/ MC_DigitalCamSwitch_HighPrecisionを使用しています。 \/ アプリケーションの構造 \/ DigitalCamSwitch_EL2252 ", 
"snippet" : "基本原則は以下と同じです DigitalCamSwitch_EL2258 。EL2252ターミナルはアクティブなイベントを 1 つしかプログラムできないため、シグナルの書き方が異なります まず、ファンクションブロックは次の式で初期化されます STATE_INIT 。 それから STATE_CHECK_FOR_EVENT からのイベントかどうかをチェックします SMC_DigitalCamSwitch_HighPrecision ファンクションブロックは保留中です。 イベントがある場合は、そのイベントを次の2サイクル以内にプログラムする必要があります。 出力とEtherCATタイムスタンプは最初...", 
"body" : "基本原則は以下と同じです DigitalCamSwitch_EL2258 。EL2252ターミナルはアクティブなイベントを 1 つしかプログラムできないため、シグナルの書き方が異なります まず、ファンクションブロックは次の式で初期化されます STATE_INIT 。 それから STATE_CHECK_FOR_EVENT からのイベントかどうかをチェックします SMC_DigitalCamSwitch_HighPrecision ファンクションブロックは保留中です。 イベントがある場合は、そのイベントを次の2サイクル以内にプログラムする必要があります。 出力とEtherCATタイムスタンプは最初のサイクルで書き込まれます。 Activate 出力は 0 に設定されます。 2 番目のサイクルでは、 Activate 出力は 3 インチに設定されています。 STATE_ACTIVATE_EVENT_IN_EL2252 。これにより、ターミナルでイベントがアクティブになります で STATE_WAIT_UNTIL_THE_INPUTS_MATCH_THE_OUTPUTS その後、システムはイベントが実行されるまで待機します。からのシグナル Feedback これには端末の入力が使用されます。 プロッドマッピング EL2252 " }, 
{ "title" : "Main ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234861434889277", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ カム \/ MC_DigitalCamSwitch_HighPrecisionを使用しています。 \/ アプリケーションの構造 \/ Main ", 
"snippet" : "メインプログラムでは、4つのスイッチ（各トラックに2つ）が設定されています。また、トラックごとにオン\/オフ補正が異なります OnComp 、 OffComp ): このプログラムには、軸の予測を有効にし、それを常に180°\/s（*）で動かすために必要な関数ブロック呼び出しが含まれています。また、 SMC_DigitalCamSwitch_HighPrecision 、 DigitalCamSwitch_EL2258 、および DigitalCamSwitch_EL2252 。ムーブメントを開始する前に、フィールドバスの電源を完全にオンにする必要があります。そうしないと、イベントを端末に送信でき...", 
"body" : "メインプログラムでは、4つのスイッチ（各トラックに2つ）が設定されています。また、トラックごとにオン\/オフ補正が異なります OnComp 、 OffComp ): このプログラムには、軸の予測を有効にし、それを常に180°\/s（*）で動かすために必要な関数ブロック呼び出しが含まれています。また、 SMC_DigitalCamSwitch_HighPrecision 、 DigitalCamSwitch_EL2258 、および DigitalCamSwitch_EL2252 。ムーブメントを開始する前に、フィールドバスの電源を完全にオンにする必要があります。そうしないと、イベントを端末に送信できません。 （*）例をシンプルでわかりやすくするために、一定の動きを選択しました。ただし、 SMC_DigitalCamSwitch_HighPrecision ファンクションブロックはあらゆる種類の動きに対応します。たとえば、アクセラレーションフェーズやカムを使ったときなど、正確なタイムスタンプも表示されます " }, 
{ "title" : "コミッショニング ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856511865803", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ カム \/ MC_DigitalCamSwitch_HighPrecisionを使用しています。 \/ コミッショニング ", 
"snippet" : "アプリケーションをビルドし、コントローラーにダウンロードします。 アプリケーションを起動します。...", 
"body" : "アプリケーションをビルドし、コントローラーにダウンロードします。 アプリケーションを起動します。 " }, 
{ "title" : "カムのエクスポートとインポート ", 
"url" : "_sm_example_cams_export_import.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ カム \/ カムのエクスポートとインポート ", 
"snippet" : "ザ・ BasicMotion_CamExportAndImport.project サンプルプロジェクトは、のインストールディレクトリにあります。 CODESYS 下に ..\\CODESYS SoftMotion\\Examples 。 この例は、カムのエクスポートとインポートの方法を示しています。...", 
"body" : "ザ・ BasicMotion_CamExportAndImport.project サンプルプロジェクトは、のインストールディレクトリにあります。 CODESYS 下に ..\\CODESYS SoftMotion\\Examples 。 この例は、カムのエクスポートとインポートの方法を示しています。 " }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_example_cams_export_import.html#UUID-a44eacc8-df29-93b8-408e-06aec7d8a9f5_section-idm235085906313629", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ カム \/ カムのエクスポートとインポート \/ アプリケーションの構造 ", 
"snippet" : "アプリケーションの構成は PLC_PRG プログラムと CamEditor カム。 PLC_PRG このプログラムは、IECコードでカムが作成されるシンプルなステートマシンで構成されています。 STATE_CREATE_CAM 状態。詳細については、以下を参照してください プログラムによるカムの作成。 次に、このカムはにエクスポートされます STATE_EXPORT_CAM ステートを使用した状態 SMC_WriteCam ファンクションブロックをインポートしてからにインポートします STATE_START_IMPORT_CAM ステートを使用した状態 SMC_ReadCam ファンクションブ...", 
"body" : "アプリケーションの構成は PLC_PRG プログラムと CamEditor カム。 PLC_PRG このプログラムは、IECコードでカムが作成されるシンプルなステートマシンで構成されています。 STATE_CREATE_CAM 状態。詳細については、以下を参照してください プログラムによるカムの作成。 次に、このカムはにエクスポートされます STATE_EXPORT_CAM ステートを使用した状態 SMC_WriteCam ファンクションブロックをインポートしてからにインポートします STATE_START_IMPORT_CAM ステートを使用した状態 SMC_ReadCam ファンクションブロック。 CamEditor カムはアプリでは使われていないので、最初は何の意味もありません。からエクスポートされたカム PLC_PRG カムエディターにインポートできます。これは手動の手順で、次のセクションで説明します。 " }, 
{ "title" : "コミッショニング ", 
"url" : "_sm_example_cams_export_import.html#UUID-a44eacc8-df29-93b8-408e-06aec7d8a9f5_section-idm23508590648994", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ カム \/ カムのエクスポートとインポート \/ コミッショニング ", 
"snippet" : "アプリケーションをビルドし、コントローラーにダウンロードします。 アプリケーションを起動します。 ザ・ PLC_PRG プログラムはカムを生成し、それをにエクスポートします。 PlcLogic コントローラのディレクトリ。 エクスポートしたカムをカムエディタで表示および編集することもできます。これを行うには、を開きます。 CamEditor カムを作成し、を使用してカムをインポートします。 CamOnlineファイルを読む コマンド。 変更を加えたら、を使用して修正したカムをエクスポートできます カムオンラインファイルを書く コマンド。このカムは、次のコマンドで IEC コードに読み込むことが...", 
"body" : "アプリケーションをビルドし、コントローラーにダウンロードします。 アプリケーションを起動します。 ザ・ PLC_PRG プログラムはカムを生成し、それをにエクスポートします。 PlcLogic コントローラのディレクトリ。 エクスポートしたカムをカムエディタで表示および編集することもできます。これを行うには、を開きます。 CamEditor カムを作成し、を使用してカムをインポートします。 CamOnlineファイルを読む コマンド。 変更を加えたら、を使用して修正したカムをエクスポートできます カムオンラインファイルを書く コマンド。このカムは、次のコマンドで IEC コードに読み込むことができます SMC_ReadCAM ファンクションブロックでアプリケーションで使用されます。 " }, 
{ "title" : "SoftMotion 軸の速度オーバーライド ", 
"url" : "_sm_example_override.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ SoftMotion 軸の速度オーバーライド ", 
"snippet" : "の BasicMotion_Override.project ここで説明するサンプル プロジェクトは、次のインストール ディレクトリにあります。 CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例では、SoftMotion 軸の速度オーバーライドを定義する方法を示します。 オーバーライドの詳細については、次を参照してください。 MC_SetOverride による動的適応...", 
"body" : "の BasicMotion_Override.project ここで説明するサンプル プロジェクトは、次のインストール ディレクトリにあります。 CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例では、SoftMotion 軸の速度オーバーライドを定義する方法を示します。 オーバーライドの詳細については、次を参照してください。 MC_SetOverride による動的適応" }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_example_override.html#UUID-ba001b0a-d3fc-8a58-4f4f-ec6aee022bd0_section-idm4552520462032034028650702932", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ SoftMotion 軸の速度オーバーライド \/ アプリケーションの構造 ", 
"snippet" : "アプリケーションは次のもので構成されます。 PLC_PRG プログラムと Trace 。 PLC_PRG プログラムは単純なステート マシンで構成されます。最初の状態では STATE_POWER 、仮想軸 Drive 初期化されます。 2番目の状態では STATE_COMMAND_MOVEMENT では、軸の移動が半分の速度でのみ実行されるように、速度オーバーライド 0.5 が設定されています。次に、動きは次を使用して実行されます。 MC_MoveAbsolute 最大速度 20 ユニット\/秒が機能ブロックで指定されています。 仮想軸に設定された速度オーバーライドにより、移動は最大速度 10 ...", 
"body" : "アプリケーションは次のもので構成されます。 PLC_PRG プログラムと Trace 。 PLC_PRG プログラムは単純なステート マシンで構成されます。最初の状態では STATE_POWER 、仮想軸 Drive 初期化されます。 2番目の状態では STATE_COMMAND_MOVEMENT では、軸の移動が半分の速度でのみ実行されるように、速度オーバーライド 0.5 が設定されています。次に、動きは次を使用して実行されます。 MC_MoveAbsolute 最大速度 20 ユニット\/秒が機能ブロックで指定されています。 仮想軸に設定された速度オーバーライドにより、移動は最大速度 10 ユニット\/秒で実行されます。 動作の半分が位置 5 で完了するとすぐに、速度オーバーライドは 0.25 に減少します。 STATE_CHANGE_OVERRIDE 州。軸は 5 単位\/秒まで減速し、残りの動作はこの速度で実行されます。 仮想軸のアクティブなオーバーライド係数 (速度、加速度、ジャーク) もプログラムに読み込まれます。の SMC_GetOverride これにはファンクションブロックが使用されます。 痕跡 トレースを使用して、仮想軸の動きを追跡できます。現在指定されている軸の位置、速度、加速度、およびアクティブな速度オーバーライドが記録されます。 " }, 
{ "title" : "試運転 ", 
"url" : "_sm_example_override.html#UUID-ba001b0a-d3fc-8a58-4f4f-ec6aee022bd0_section-idm4563439233780834028650966211", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ SoftMotion 軸の速度オーバーライド \/ 試運転 ", 
"snippet" : "アプリケーションをビルドし、コントローラーにダウンロードします。 トレースとアプリケーションを開始します。 トレースでは、仮想軸の動きを追跡できます。...", 
"body" : "アプリケーションをビルドし、コントローラーにダウンロードします。 トレースとアプリケーションを開始します。 トレースでは、仮想軸の動きを追跡できます。 " }, 
{ "title" : "距離ベースのランプ ", 
"url" : "_sm_axis_based_ramp_in.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ 距離ベースのランプ ", 
"snippet" : "の BasicMotion_CamIn_StartModes.project ここで説明するサンプルプロジェクトは、 CODESYS 下 ..\\CODESYS SoftMotion\\Examples ディレクトリ。 この例では、 StartMode の入力 MC_CamIn ファンクションブロック。この入力は、スレーブ軸がマスター軸とどのように同期するかを設定するために使用されます。 MC_CamIn が開始されます。 基本的に、3 つの方法があります。 スレーブ軸は、カムとマスター軸によって指定された軌道に直ちに追従します。スレーブ軸の開始ステータスに応じて、スレーブ軸の位置、速度、および\/...", 
"body" : "の BasicMotion_CamIn_StartModes.project ここで説明するサンプルプロジェクトは、 CODESYS 下 ..\\CODESYS SoftMotion\\Examples ディレクトリ。 この例では、 StartMode の入力 MC_CamIn ファンクションブロック。この入力は、スレーブ軸がマスター軸とどのように同期するかを設定するために使用されます。 MC_CamIn が開始されます。 基本的に、3 つの方法があります。 スレーブ軸は、カムとマスター軸によって指定された軌道に直ちに追従します。スレーブ軸の開始ステータスに応じて、スレーブ軸の位置、速度、および\/または加速度がジャンプする可能性があります。 StartMode : absolute 、 relative スレーブ軸は、事前に定義された速度、加速、減速、ジャーク制限を維持しながら、可能な限り迅速に同期します。 StartMode : ramp_in 、 ramp_in_pos 、 ramp_in_neg マスター位置はカムで指定され、スレーブ軸はカムとマスター軸によって指定された軌道をたどる必要があります。同期は、マスター軸からの設定可能な距離で行われます。 StartMode : ramp_in_dist MC_CamIn 関数ブロックの詳細については、以下を参照してください。 MC_CamIn (FB) " }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_axis_based_ramp_in.html#UUID-08122319-fcc2-39b9-d37e-80454ce1f88b_section-idm4561064201451234280796827706", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ 距離ベースのランプ \/ アプリケーションの構造 ", 
"snippet" : "アプリケーションは、 PLC_PRG プログラムとトレース。さらに、4つの仮想軸があります。マスター軸 Master そして3つの奴隷斧 SlaveAbsolute 、 SlaveRampIn 、 そして SlaveRampInDist そしてカムがある Cam 。 の中に PLC_PRG プログラム、3つのインスタンス MC_CamIn 実行されるのは StartMode input 異なる設定: ciSlaveAbsolute と StartMode = absolute ciSlaveRampIn と StartMode = ramp_in ciSlaveRampInDist と Sta...", 
"body" : "アプリケーションは、 PLC_PRG プログラムとトレース。さらに、4つの仮想軸があります。マスター軸 Master そして3つの奴隷斧 SlaveAbsolute 、 SlaveRampIn 、 そして SlaveRampInDist そしてカムがある Cam 。 の中に PLC_PRG プログラム、3つのインスタンス MC_CamIn 実行されるのは StartMode input 異なる設定: ciSlaveAbsolute と StartMode = absolute ciSlaveRampIn と StartMode = ramp_in ciSlaveRampInDist と StartMode = ramp_in_dist ファンクションブロックインスタンスは対応する仮想軸を制御する SlaveAbsolute 、 SlaveRampIn 、 そして SlaveRampInDist マスター軸は一定速度で移動し、 MC_MoveVelocity 実例。 3つの奴隷軸の軌跡と Active そして InSync の出力 MC_CamIn インスタンスはトレースで追跡できます。 全て MC_CamIn マスター軸が位置 40 を超えるとインスタンスが開始されます。 の SlaveAbsolute 軸はカムから定義された設定値に即座にジャンプします。対応する MC_CamIn インスタンスはすぐに Active そして InSync 。 の SlaveRampIn 軸は、指令された動的制限を維持しながら同期します。対応する MC_CamIn インスタンスはすぐに Active マスターポジションから ~114 スレーブ軸はカムとマスター軸によって指定された軌道をたどり、 MC_CamIn インスタンスレポート InSync 。 の SlaveRampInDist マスター軸が近づくまで軸は静止したままです MasterSyncPosition 120までの MasterStartDistance 60個のうち、 MC_CamIn instance . 同期が始まり、 MC_CamIn インスタンスレポート Active マスター軸が MasterSyncPosition の 120 スレーブ軸はカムとマスター軸によって指定された軌道をたどり、 MC_CamIn インスタンスレポート InSync 。 " }, 
{ "title" : "試運転 ", 
"url" : "_sm_axis_based_ramp_in.html#UUID-08122319-fcc2-39b9-d37e-80454ce1f88b_section-idm4602846053456034280814845985", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ 例 \/ 距離ベースのランプ \/ 試運転 ", 
"snippet" : "アプリケーションをビルドし、コントローラーにダウンロードします。 トレースおよびアプリケーションを起動します。 トレースでは、仮想軸の動きを追跡できます。...", 
"body" : "アプリケーションをビルドし、コントローラーにダウンロードします。 トレースおよびアプリケーションを起動します。 トレースでは、仮想軸の動きを追跡できます。 " }, 
{ "title" : "ユーザーインターフェース ", 
"url" : "_sm_basic_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ ユーザーインターフェース ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "カム ", 
"url" : "_sm_basic_user_interface_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ ユーザーインターフェース \/ カム ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "ダイアログ：プロパティ–カム ", 
"url" : "_sm_dlg_properties_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ ユーザーインターフェース \/ カム \/ ダイアログ：プロパティ–カム ", 
"snippet" : "関数 ：このダイアログを使用して、カムのグローバル変数を定義します。 寸法 マスターの開始\/終了位置 マスターの開始位置と終了位置は、マスター値の範囲を定義し、したがってカムの水平軸のスケールを定義します。デフォルト設定は角度度で指定され、制限値は0と360です。 スレーブの開始\/終了位置 関連するスレーブ位置は、カムに定義されているグラフタイプによって決定されます。ただし、曲線で示されるセグメント（これは垂直軸のスケールでもあります）は、ここで指定されているスレーブの開始位置と終了位置によって定義できます。 期間 これらの設定は、カム エディターとカム テーブルでの作業に影響します。これらの...", 
"body" : "関数 ：このダイアログを使用して、カムのグローバル変数を定義します。 寸法 マスターの開始\/終了位置 マスターの開始位置と終了位置は、マスター値の範囲を定義し、したがってカムの水平軸のスケールを定義します。デフォルト設定は角度度で指定され、制限値は0と360です。 スレーブの開始\/終了位置 関連するスレーブ位置は、カムに定義されているグラフタイプによって決定されます。ただし、曲線で示されるセグメント（これは垂直軸のスケールでもあります）は、ここで指定されているスレーブの開始位置と終了位置によって定義できます。 期間 これらの設定は、カム エディターとカム テーブルでの作業に影響します。これらのパラメータに応じて、スレーブの開始点は終了点が変更されると自動的に調整され、その逆も同様です。この調整により、周期遷移が可能な限りスムーズでジャークのない状態になるように最適化されます。 スムーズな移行 ：位置、速度、加速度の値は自動的に調整されます。 奴隷時代 スレーブ期間が機械的に繰り返される時期を示します。その場合、マスター期間の開始時と終了時のスレーブ位置は、この値の1倍の整数倍だけずれることがあります。 この値は、 スムーズな移行 チェックボックスが選択されています。 継続性の要件 カーブの連続性に関するこれらのオプションを有効にしても、カムの編集時には影響はありません。ただし、連続性チェックが促され、違反があればメッセージビューに報告されます ( カム カテゴリ)。位置曲線のジャンプを編集することはできません。デフォルト設定では、速度と加速度の連続性も必要です。たとえば、直線セグメントのみで構成される曲線の特殊なケースでは、これらのオプションをクリアできます。ただし、これにより位置曲線が途切れる可能性があります。デフォルトでは、ジャーク (4 次導関数) はジャンプに対してテストされません。 ポジション ：カーブのジャンプがチェックされます。 速度 加速度 ぴくぴく動く フォーマットのコンパイル コンパイル時には、 MC_CAM_REF 構造変数が生成されます。カムは以下のオプションに従って記述されます 多項式（XYVA） マスター位置、スレーブ位置、スレーブ速度、およびスレーブ加速度で構成される、個々のポイントの多項式記述。 一次元の点配列 スレーブ位置の1Dテーブル 2次元の点配列 複合マスター\/スレーブ位置の2Dテーブル 要素 1 次元または 2 次元の点配列の要素数。この配列はで既に作成されています SM3_Basic 標準ケース用 128 そして 256 。別の値を入力する場合は、アプリケーション内に構造を作成する必要があります。これについては、次の例を参照してください。 セグメント 標準コンパイル形式。すべてのセグメントタイプをサポート 720要素の配列の例 TYPE SMC_CAMTable_LREAL_720_2 :\nSTRUCT\n Table: ARRAY[0..719] OF ARRAY[0..1] OF LREAL;\n fEditorMasterMin, fEditorMasterMax: REAL;\n fEditorSlaveMin, fEditorSlaveMax: REAL;\n fTableMasterMin, fTableMasterMax: REAL;\n fTableSlaveMin, fTableSlaveMax: REAL;\nEND_STRUCT\nEND_TYPE 詳細については、以下を参照してください。 カムの作成方法" }, 
{ "title" : "コマンド：生成されたコードを表示 ", 
"url" : "_sm_cmd_cam_display_generated_code.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ ユーザーインターフェース \/ カム \/ コマンド：生成されたコードを表示 ", 
"snippet" : "生成されたコードを表示する 関数 ：コマンドは 生成されたコード 表示されたカムのIEC初期化コードが表示されるダイアログ。 電話 ： カム メニュー 要件 ：カムエディタが開いており、カムが表示されます。 の生成コードは表示されません セグメント コンパイル形式。CamBuilder API を使用すると、より適切な方法でプログラムでカムを生成できるため、生成されたコードはもう必要ありません ダイアログ：生成されたコード 例：IEC初期化コード {attribute 'linkalways'} VAR_GLOBAL Cam_A: ARRAY[0..3] OF SMC_CAMXYVA := [...", 
"body" : "生成されたコードを表示する 関数 ：コマンドは 生成されたコード 表示されたカムのIEC初期化コードが表示されるダイアログ。 電話 ： カム メニュー 要件 ：カムエディタが開いており、カムが表示されます。 の生成コードは表示されません セグメント コンパイル形式。CamBuilder API を使用すると、より適切な方法でプログラムでカムを生成できるため、生成されたコードはもう必要ありません ダイアログ：生成されたコード 例：IEC初期化コード {attribute 'linkalways'}\n\nVAR_GLOBAL\nCam_A: ARRAY[0..3] OF SMC_CAMXYVA := [\n (dX := 0, dY := 0, dV := 0, dA := 0),\n (dX := 120, dY := 120, dV := 1, dA := 0),\n (dX := 240, dY := 240, dV := 1, dA := 0),\n (dX := 360, dY := 360, dV := 0, dA := 0)];\nCam: MC_CAM_REF := (nElements := 4, byType := 3, xStart := 0, xEnd := 360, nTappets := 0, strCAMName := 'Cam', pce := ADR(Cam_A), xPartofLM := TRUE);\nEND_VAR " }, 
{ "title" : "コマンド：ASCIIテーブルからカムデータを読み取る ", 
"url" : "_sm_cmd_cam_read_data_from_ascii_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ ユーザーインターフェース \/ カム \/ コマンド：ASCIIテーブルからカムデータを読み取る ", 
"snippet" : "ASCIIテーブルからカムデータを読み取る 関数 ：コマンドは ASCII ファイル。 電話 ： カム メニュー 要件 ：カムエディタが開いています。 読み取られると、ファイルデータはカムのX \/ Y値として解釈されます。 NS ポイント数 ダイアログが開き、補間点の数を減らすことができます。次に、決定されたポイントがカムに補間され、エディタに表示されます。 NS カムデータをASCIIテーブルに書き込む コマンドは適切なを作成します TXT ファイル。...", 
"body" : "ASCIIテーブルからカムデータを読み取る 関数 ：コマンドは ASCII ファイル。 電話 ： カム メニュー 要件 ：カムエディタが開いています。 読み取られると、ファイルデータはカムのX \/ Y値として解釈されます。 NS ポイント数 ダイアログが開き、補間点の数を減らすことができます。次に、決定されたポイントがカムに補間され、エディタに表示されます。 NS カムデータをASCIIテーブルに書き込む コマンドは適切なを作成します TXT ファイル。 " }, 
{ "title" : "ダイアログ：ポイント数 ", 
"url" : "_sm_cmd_cam_read_data_from_ascii_table.html#UUID-dc22ffbd-b76b-ca74-a92b-235fbf0143cb_id_d53fe1240e8dd1c0a8640e0032565c_id_b03dff25496d07f6c0a8646340c5ba9e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ ユーザーインターフェース \/ カム \/ コマンド：ASCIIテーブルからカムデータを読み取る \/ ダイアログ：ポイント数 ", 
"snippet" : "ポイント数 補間に使用されるポイントの数。 プリセット：読み取ったファイルに保存されているX \/ Y値の数に応じて。例： 256 より少ない補間点でカムを決定するために、プリセット値を減らすことができます。補間点を決定するとき、それらのX値は等距離に分布します。 カムは5次多項式を使用して補間されるため、補間点の数が多いと振動が発生する可能性があります。...", 
"body" : "ポイント数 補間に使用されるポイントの数。 プリセット：読み取ったファイルに保存されているX \/ Y値の数に応じて。例： 256 より少ない補間点でカムを決定するために、プリセット値を減らすことができます。補間点を決定するとき、それらのX値は等距離に分布します。 カムは5次多項式を使用して補間されるため、補間点の数が多いと振動が発生する可能性があります。 " }, 
{ "title" : "コマンド：カムデータをASCIIテーブルに書き込む ", 
"url" : "_sm_cmd_cam_write_data_into_ascii_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ ユーザーインターフェース \/ カム \/ コマンド：カムデータをASCIIテーブルに書き込む ", 
"snippet" : "カムデータをASCIIテーブルに書き込む 関数 ：コマンドは ASCII ファイル （ TXT 拡張）開発システム上。このファイルには、指定された数のアクティブカムのX \/ Y値が保存されます。デフォルトのダイアログが最初に開き、次に ポイント数 ダイアログ。 電話 ： カム メニュー 要件 ：カムエディタが開いており、カムが表示されます。...", 
"body" : "カムデータをASCIIテーブルに書き込む 関数 ：コマンドは ASCII ファイル （ TXT 拡張）開発システム上。このファイルには、指定された数のアクティブカムのX \/ Y値が保存されます。デフォルトのダイアログが最初に開き、次に ポイント数 ダイアログ。 電話 ： カム メニュー 要件 ：カムエディタが開いており、カムが表示されます。 " }, 
{ "title" : "ダイアログ：ポイント数 ", 
"url" : "_sm_cmd_cam_write_data_into_ascii_table.html#UUID-b84e5af8-679e-916c-e8a6-2358c4cccb5c_id_c2bdaa8241199e2c0a8640e018c7af7_id_b03dff25496d07f6c0a8646340c5ba9e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ ユーザーインターフェース \/ カム \/ コマンド：カムデータをASCIIテーブルに書き込む \/ ダイアログ：ポイント数 ", 
"snippet" : "ASCIIテーブルには、カムに関する情報は含まれていません。 ポイント数 ファイルに保存され、曲線形状で表されるX \/ Y値の数。この目的のために、X曲線は等距離に分割され、それぞれのY値が決定されます。...", 
"body" : "ASCIIテーブルには、カムに関する情報は含まれていません。 ポイント数 ファイルに保存され、曲線形状で表されるX \/ Y値の数。この目的のために、X曲線は等距離に分割され、それぞれのY値が決定されます。 " }, 
{ "title" : "コマンド：CamOnlineファイルを読む ", 
"url" : "_sm_cmd_cam_read_online_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ ユーザーインターフェース \/ カム \/ コマンド：CamOnlineファイルを読む ", 
"snippet" : "CamOnlineファイルを読む 関数 ：コマンドは、カムデータを含む外部ファイルを読み取ります。ファイル拡張子は CAM 。カムエディタにカムが表示されます。 電話 ： カム メニュー 要件 ：カムエディタが開いています。 NS カムオンラインファイルを書く コマンドはで適切なファイルを作成します CAM フォーマット。...", 
"body" : "CamOnlineファイルを読む 関数 ：コマンドは、カムデータを含む外部ファイルを読み取ります。ファイル拡張子は CAM 。カムエディタにカムが表示されます。 電話 ： カム メニュー 要件 ：カムエディタが開いています。 NS カムオンラインファイルを書く コマンドはで適切なファイルを作成します CAM フォーマット。 " }, 
{ "title" : "コマンド：CamOnlineファイルを書き込む ", 
"url" : "_sm_cmd_cam_write_online_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ ユーザーインターフェース \/ カム \/ コマンド：CamOnlineファイルを書き込む ", 
"snippet" : "カムオンラインファイルを書く 関数 ：コマンドはファイルを作成します（ CAM 拡大）。このファイルには、エディターでアクティブなカムのデータが含まれています。 電話 ： カム メニュー 要件 ：カムエディタが開いており、カムが表示されます。 カムデータは、カムの説明とカムの位置とタイプで構成されます。 NS CAM ファイルは、を使用してエディターに読み取ることができます。 カムオンラインファイルを読む 指図。 さらに、のインスタンス SMC_ReadCAM 関数ブロックは、実行時にカムテーブルをアプリケーションにロードするためにファイルを読み取ることができます。 詳細については、以下を参照...", 
"body" : "カムオンラインファイルを書く 関数 ：コマンドはファイルを作成します（ CAM 拡大）。このファイルには、エディターでアクティブなカムのデータが含まれています。 電話 ： カム メニュー 要件 ：カムエディタが開いており、カムが表示されます。 カムデータは、カムの説明とカムの位置とタイプで構成されます。 NS CAM ファイルは、を使用してエディターに読み取ることができます。 カムオンラインファイルを読む 指図。 さらに、のインスタンス SMC_ReadCAM 関数ブロックは、実行時にカムテーブルをアプリケーションにロードするためにファイルを読み取ることができます。 詳細については、以下を参照してください。 カムのデータ構造" }, 
{ "title" : "CODESYS SoftMotion CNC ", 
"url" : "_sm_f_cnc.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "編集者 ", 
"url" : "_sm_f_cnc_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 編集者 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概要 ", 
"url" : "_sm_overview_cnc_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 編集者 \/ 概要 ", 
"snippet" : "CNC エディターでは、DIN 66025 の CNC 言語に従って、表形式エディターまたはテキスト エディターで複雑な多次元モーションを実装します。さらに、エディターには次の機能があります。 パスを表示するためのグラフィカルエディタ グラフィカルエディターのツールボックス 選択したパス要素のプロパティを表示する...", 
"body" : "CNC エディターでは、DIN 66025 の CNC 言語に従って、表形式エディターまたはテキスト エディターで複雑な多次元モーションを実装します。さらに、エディターには次の機能があります。 パスを表示するためのグラフィカルエディタ グラフィカルエディターのツールボックス 選択したパス要素のプロパティを表示する " }, 
{ "title" : "CNCエディターの基礎 ", 
"url" : "_sm_cnc_edt_basics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 編集者 \/ CNCエディターの基礎 ", 
"snippet" : "DIN 66025を使用すると、最大9次元のパスを作成できます。これらの次元のうちの3つは、線形補間されません。 X \/ Y \/ Zでは、線、円弧、楕円、放物線、スプラインをプログラムできます。さらに8つの追加軸が提供されます。これらのうち、5つは線形補間され（P \/ Q \/ U \/ V \/ W）、3つは3次多項式（A \/ B \/ C）で補間されます。 CNCプログラムのモーションブロックごとに、補間器がトラバースパスを計算します。同時に、補間器は、指定された補間に従って、パスの形状、速度、加速度、およびジャークを計算します。プログラムされたパスごとに、 CODESYS IECプログラムで使用...", 
"body" : "DIN 66025を使用すると、最大9次元のパスを作成できます。これらの次元のうちの3つは、線形補間されません。 X \/ Y \/ Zでは、線、円弧、楕円、放物線、スプラインをプログラムできます。さらに8つの追加軸が提供されます。これらのうち、5つは線形補間され（P \/ Q \/ U \/ V \/ W）、3つは3次多項式（A \/ B \/ C）で補間されます。 CNCプログラムのモーションブロックごとに、補間器がトラバースパスを計算します。同時に、補間器は、指定された補間に従って、パスの形状、速度、加速度、およびジャークを計算します。プログラムされたパスごとに、 CODESYS IECプログラムで使用できるCNCデータを使用してグローバルデータ構造を自動的に作成します。 この目的にはさまざまなオプションがあります。 SMC_CNC_REF : CNC プログラムは、アプリケーションの実行時に処理される G コードワードの配列として保存されます。 SMC_NCInterpreter 。その結果、一連の GEOINFO 構造オブジェクトとして記述された CNC パスが得られます。 SM3_CNC ライブラリのパス前処理モジュール (例: 工具半径補正) を使用して、これらのオブジェクトを編集、補間、変換し、ドライブ インターフェイスから通信用のハードウェアに転送することができます。 SMC_OUTQUEUE : CNC プログラムは、次の名前を持つ GEOINFO 構造オブジェクトのリストとしてデータ構造に書き込まれます。 SMC_OUTQUEUE 、そしてそれを補間器に直接入力することができます。その結果、それとは対照的に、 SMC_CNC_REF 、インタープリタ機能ブロックとパス前処理機能ブロックを呼び出す必要はありません。ただし、プログラムは実行時に変更できず、このモードでは G コード内の変数を使用できません。 FILE ：次に、CNCプログラムがASCIIファイルとしてコントローラのファイルシステムに保存され、段階的に読み取られて実装されます。この方法は、メモリに完全に保存できない大きなプログラムに特に適しています。また、コントローラアプリケーションのコンパイル後にユーザーが生成したプログラムにも適しています。 " }, 
{ "title" : "CNCエディターの構造 ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_43423fe2e9a24fa0c0a864632228473f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 編集者 \/ CNCエディターの基礎 \/ CNCエディターの構造 ", 
"snippet" : "CNCエディターは次のコンポーネントで構成されています。 メインエディタ：テキストエディタはDIN 66025プログラムを表示するか、表形式のエディタはCNCパスを表示します。 グラフィカルエディタ：パスのグラフィカルビューがここに表示されます。 プロパティ CNC要素のビュー ツールボックス ビュー：パス要素を選択および挿入するためのツールが含まれています を押すと F6 キーを押すと、フォーカスがメインエディタとグラフィカルエディタの間で切り替わります。グラフィカルエディタでパス要素が選択されている場合、それぞれのモーションブロックまたはラインがテキストエディタまたは表形式エディタで暗黙的...", 
"body" : "CNCエディターは次のコンポーネントで構成されています。 メインエディタ：テキストエディタはDIN 66025プログラムを表示するか、表形式のエディタはCNCパスを表示します。 グラフィカルエディタ：パスのグラフィカルビューがここに表示されます。 プロパティ CNC要素のビュー ツールボックス ビュー：パス要素を選択および挿入するためのツールが含まれています を押すと F6 キーを押すと、フォーカスがメインエディタとグラフィカルエディタの間で切り替わります。グラフィカルエディタでパス要素が選択されている場合、それぞれのモーションブロックまたはラインがテキストエディタまたは表形式エディタで暗黙的に選択されます。同様に、表形式エディターまたはテキストエディターで選択された要素は、グラフィカルエディターでも選択されます。グラフィックエディタでの変更は、テキストエディタまたは表形式エディタで適用され、その逆も同様です。 アプリケーション全体のCNC設定が適用され、 CNC設定 物体。 オブジェクト固有のCNC設定が適用され、 プロパティ CNCオブジェクトのダイアログ。 " }, 
{ "title" : "CNCエディタのSoftMotionソフトウェアコンポーネント ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_92f7df24e9a24fa0c0a864630c4c4560", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 編集者 \/ CNCエディターの基礎 \/ CNCエディタのSoftMotionソフトウェアコンポーネント ", 
"snippet" : "（1）CNCエディター （2）IECプログラム （3）パラメータ (4) 通訳 （5）GeoInfo （6）パスの前処理 （7）補間器 （8）パスポイント （9）デカルト座標 （10）直接運動学 （11）マシン固有の変換 （12）逆運動学 （13）軸位置 （14）ドライブインターフェース...", 
"body" : "（1）CNCエディター （2）IECプログラム （3）パラメータ (4) 通訳 （5）GeoInfo （6）パスの前処理 （7）補間器 （8）パスポイント （9）デカルト座標 （10）直接運動学 （11）マシン固有の変換 （12）逆運動学 （13）軸位置 （14）ドライブインターフェース " }, 
{ "title" : "CNCオブジェクトのコンパイル ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_c0635f14eddc9007c0a8646316c80481", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 編集者 \/ CNCエディターの基礎 \/ CNCオブジェクトのコンパイル ", 
"snippet" : "The コンパイルモード 新しいCNCオブジェクトを追加するときにが選択され、必要に応じてで変更できます。 プロパティ ダイアログ（ CNC CNCオブジェクトのタブ）。に応じて コンパイルモード 、 SMC_OutQueue ファンクションブロック、 SMC_CNC_REF 機能ブロック、またはプログラムされたCNCパスを持つASCIIファイルがコンパイル時に作成されます。 の場合 ビルドから除外する オプションが選択されている プロパティ のダイアログ 建てる CNCオブジェクトのタブの場合、IECデータは生成されません。コンパイルモードの場合 ファイル 、データはコントローラーにダウンロ...", 
"body" : "The コンパイルモード 新しいCNCオブジェクトを追加するときにが選択され、必要に応じてで変更できます。 プロパティ ダイアログ（ CNC CNCオブジェクトのタブ）。に応じて コンパイルモード 、 SMC_OutQueue ファンクションブロック、 SMC_CNC_REF 機能ブロック、またはプログラムされたCNCパスを持つASCIIファイルがコンパイル時に作成されます。 の場合 ビルドから除外する オプションが選択されている プロパティ のダイアログ 建てる CNCオブジェクトのタブの場合、IECデータは生成されません。コンパイルモードの場合 ファイル 、データはコントローラーにダウンロードされません。 " }, 
{ "title" : "開く CoDeSys V2.3 プロジェクト ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_88cb0aeee9a24fa0c0a864634f00b359", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 編集者 \/ CNCエディターの基礎 \/ 開く CoDeSys V2.3 プロジェクト ", 
"snippet" : "あなたが開くとき CoDeSys V2.3 のプロジェクト CODESYS 、SoftMotionコントローラが使用されている限り、次の機能を実行するためのコンバータが提供されます。 すべてのCNCプログラムは、同じ名前と実装タイプDIN 66025のCNCオブジェクトに変換されます。コンパイルモード、キューサイズ、および変換されたプログラムの開始位置も、ステップ抑制のステータスとして適用されます。 の場合 ビルドから除外する オプションは、のCNCプログラムで選択されています CoDeSys V2.3 プロジェクトの場合、このオプションが受け入れられます。 The CNC設定 オブジェクトは...", 
"body" : "あなたが開くとき CoDeSys V2.3 のプロジェクト CODESYS 、SoftMotionコントローラが使用されている限り、次の機能を実行するためのコンバータが提供されます。 すべてのCNCプログラムは、同じ名前と実装タイプDIN 66025のCNCオブジェクトに変換されます。コンパイルモード、キューサイズ、および変換されたプログラムの開始位置も、ステップ抑制のステータスとして適用されます。 の場合 ビルドから除外する オプションは、のCNCプログラムで選択されています CoDeSys V2.3 プロジェクトの場合、このオプションが受け入れられます。 The CNC設定 オブジェクトは自動的に生成されます。 すべてのCNCオブジェクトは、SoftMotion対応のアプリケーションの下に一覧表示されます。 " }, 
{ "title" : "CNCプログラムの作成 ", 
"url" : "_sm_cnc_creating_cnc_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 編集者 \/ CNCプログラムの作成 ", 
"snippet" : "デバイスツリーでアプリケーションを選択します。 クリック プロジェクト→オブジェクトの追加→CNCプログラム 。 で名前を指定します CNCプログラムを追加 ダイアログを表示し、 実装 リストボックスから： DIN 66025 ：テキストエディタでプログラムを作成するには テーブル ：表形式のエディタでプログラムを作成するには を選択 コンパイルモード コンパイル時の動作を決定するには： SMC_OutQueue ：SMC_OutQueueデータ構造はコンパイル時に生成されます。によってグローバルアクセスが許可されます g_CNCQueueManager （SMC_OutQueue）。 SMC...", 
"body" : "デバイスツリーでアプリケーションを選択します。 クリック プロジェクト→オブジェクトの追加→CNCプログラム 。 で名前を指定します CNCプログラムを追加 ダイアログを表示し、 実装 リストボックスから： DIN 66025 ：テキストエディタでプログラムを作成するには テーブル ：表形式のエディタでプログラムを作成するには を選択 コンパイルモード コンパイル時の動作を決定するには： SMC_OutQueue ：SMC_OutQueueデータ構造はコンパイル時に生成されます。によってグローバルアクセスが許可されます g_CNCQueueManager （SMC_OutQueue）。 SMC_CNC_REF ：プログラム変数はコンパイル時に生成されます。によってグローバルアクセスが許可されます g_CNCProgManager （SMC-CNC_REF）IECプログラム。 ファイル ：Gコードで生成されたファイルは、ログインするたびにダウンロードおよび更新されます。 PLCは、ファンクションブロックを使用してこのファイルをダウンロードできます。 あなたは変更することができます 実装 と コンパイルモード 後で プロパティ ダイアログ（ CNC CNCプログラムのタブ）。 クリック 追加 。 CNCオブジェクトがデバイスツリーに挿入され、エディターで開かれます。 " }, 
{ "title" : "DIN66025に準拠したパスのプログラミング ", 
"url" : "_sm_cnc_programming_din_66025.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 編集者 \/ DIN66025に準拠したパスのプログラミング ", 
"snippet" : "SoftMotionは、CNCオブジェクトのエディターで幾何学的パスのプログラミングを可能にするCNC言語DIN66025の一部をサポートします。 The DIN66025エディター CNCオブジェクト（CNCテキストエディタ）は、DIN 66025CNC言語でプログラミングするために提供されています。 要件：A CNCプログラム オブジェクトはで開いています DIN 66025 実装。 空白行にカーソルを置きます。 エディターにGコードブロックを1行ずつ入力します。 ブロックに入ったとき（例： N10 G01 X100 Y100 E100 F100 E-200 ）、パス要素はグラフィカルエデ...", 
"body" : "SoftMotionは、CNCオブジェクトのエディターで幾何学的パスのプログラミングを可能にするCNC言語DIN66025の一部をサポートします。 The DIN66025エディター CNCオブジェクト（CNCテキストエディタ）は、DIN 66025CNC言語でプログラミングするために提供されています。 要件：A CNCプログラム オブジェクトはで開いています DIN 66025 実装。 空白行にカーソルを置きます。 エディターにGコードブロックを1行ずつ入力します。 ブロックに入ったとき（例： N10 G01 X100 Y100 E100 F100 E-200 ）、パス要素はグラフィカルエディタにすぐに表示されます。 ここで、操作フィールドを使用して、さまざまな軸のビューとビューの方向を変更できます。 グラフィカルエディタでパス要素を選択すると、そのプロパティがに表示されます。 プロパティ 見る。 詳細については、以下を参照してください。 DIN66025の基礎" }, 
{ "title" : "表形式エディターでのパスのプログラミング ", 
"url" : "_sm_cnc_programming_table_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 編集者 \/ 表形式エディターでのパスのプログラミング ", 
"snippet" : "要件：A CNCプログラム オブジェクトはで作成されます テーブル 実装、およびオブジェクトはで開いています 表形式のエディター 。...", 
"body" : "要件：A CNCプログラム オブジェクトはで作成されます テーブル 実装、およびオブジェクトはで開いています 表形式のエディター 。 " }, 
{ "title" : "要素の挿入 ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f56fa52f4ccd11e69d4cb2db330b91fd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 編集者 \/ 表形式エディターでのパスのプログラミング \/ 要素の挿入 ", 
"snippet" : "ダブルクリック 空の のセル タイプ 桁。リストボックスから要素を選択し、を押します 入力 鍵。 これがテーブルの最初の要素である場合、フィールドには要素の初期値が入力されます。それ以外の場合、要素は前の行の要素から値を受け取ります。 他のすべてのフィールドは灰色でシェーディングされたままで、要素はグラフィカルエディタに表示されます。 表の最後の行は、次のタイプの空白行です。 空の 。 別の要素を追加するには、をクリックすることもできます 要素を挿入 テーブルエントリのコンテキストメニューのコマンド。...", 
"body" : "ダブルクリック 空の のセル タイプ 桁。リストボックスから要素を選択し、を押します 入力 鍵。 これがテーブルの最初の要素である場合、フィールドには要素の初期値が入力されます。それ以外の場合、要素は前の行の要素から値を受け取ります。 他のすべてのフィールドは灰色でシェーディングされたままで、要素はグラフィカルエディタに表示されます。 表の最後の行は、次のタイプの空白行です。 空の 。 別の要素を追加するには、をクリックすることもできます 要素を挿入 テーブルエントリのコンテキストメニューのコマンド。 " }, 
{ "title" : "テーブルエントリの変更 ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f568c7504ccd11e69d4cb2db330b91fd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 編集者 \/ 表形式エディターでのパスのプログラミング \/ テーブルエントリの変更 ", 
"snippet" : "要素のテーブルエントリをダブルクリックします。 フィールドは編集可能であるか、 リストボックスの記号。 グラフィカルエディタでは、要素は赤でマークされています。 テーブルエントリの値を変更します。 変更はグラフィカルエディタに表示されます。 コマンドをクリックすると すべての要素に値を適用する テーブルエントリのコンテキストメニューで、現在の値が同じ列の他のすべてのエントリに適用されます。要件：値は、それぞれの要素タイプに使用できます。 行番号は編集できません。...", 
"body" : "要素のテーブルエントリをダブルクリックします。 フィールドは編集可能であるか、 リストボックスの記号。 グラフィカルエディタでは、要素は赤でマークされています。 テーブルエントリの値を変更します。 変更はグラフィカルエディタに表示されます。 コマンドをクリックすると すべての要素に値を適用する テーブルエントリのコンテキストメニューで、現在の値が同じ列の他のすべてのエントリに適用されます。要件：値は、それぞれの要素タイプに使用できます。 行番号は編集できません。 " }, 
{ "title" : "要素を削除する ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f0684d0502561eafc0a864633d0e8542", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 編集者 \/ 表形式エディターでのパスのプログラミング \/ 要素を削除する ", 
"snippet" : "テーブルの行を選択して、コマンドをクリックします 要素を削除します コンテキストメニューで。 タイプのテーブルの最後の行 空の 削除できません。...", 
"body" : "テーブルの行を選択して、コマンドをクリックします 要素を削除します コンテキストメニューで。 タイプのテーブルの最後の行 空の 削除できません。 " }, 
{ "title" : "CNCデータ構造とグローバルアクセス ", 
"url" : "_sm_cnc_data_structure_global_access.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 編集者 \/ CNCデータ構造とグローバルアクセス ", 
"snippet" : "プロジェクトで利用可能なCNCオブジェクトは、タイプの機能ブロックにコンパイルされます。 SMC_OUTQUEUE また SMC_CNC_REF 。 （これは、コンパイルメソッドの場合は発生しません ファイル 使用されている。） プロジェクトがコンパイルされると、作成されたCNCデータは内部で管理されます。 SMC_CNC_Data ファンクションブロック。コンパイルモードの場合 SMC_OutQueue 、各CNC要素は SMC_OUTQUEUE ファンクションブロック。コンパイルモードの場合 SMC_CNC_REF 、CNC要素はで表されます SMC_CNC_REF 。 IECプログラムが...", 
"body" : "プロジェクトで利用可能なCNCオブジェクトは、タイプの機能ブロックにコンパイルされます。 SMC_OUTQUEUE また SMC_CNC_REF 。 （これは、コンパイルメソッドの場合は発生しません ファイル 使用されている。） プロジェクトがコンパイルされると、作成されたCNCデータは内部で管理されます。 SMC_CNC_Data ファンクションブロック。コンパイルモードの場合 SMC_OutQueue 、各CNC要素は SMC_OUTQUEUE ファンクションブロック。コンパイルモードの場合 SMC_CNC_REF 、CNC要素はで表されます SMC_CNC_REF 。 IECプログラムが処理されている間、機能ブロックがインスタンス化され、IECプログラムで処理できる値が入力されます。これらのPOUはすべてに含まれています SM3_CNC 。 " }, 
{ "title" : "CNCデータへのグローバルアクセス ", 
"url" : "_sm_cnc_data_structure_global_access.html#UUID-aaee586d-72f4-405c-8bb5-b4b2cb32f52d_id_cb8536efda52bb5c0a8646375871841_id_4fd460ed02599820c0a864633ab223de", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 編集者 \/ CNCデータ構造とグローバルアクセス \/ CNCデータへのグローバルアクセス ", 
"snippet" : "初期化中に、生成されたオブジェクトのタイプと数がCNCプログラムから確認されます。これらのオブジェクトはすべて、暗黙的に宣言されたグローバルデータ構造にまとめてリストされます。タイプのオブジェクト SMC_OUTQUEUE グローバルデータオブジェクトにリストされています g_CNCQueueManager プロパティで Count と方法 GetOutQueue(int n) 。タイプのオブジェクト SMC_CNC_REF グローバルデータオブジェクトにリストされています g_CNCProgManager プロパティで Count と方法 GetProgram(int n) 。これで、ユーザ...", 
"body" : "初期化中に、生成されたオブジェクトのタイプと数がCNCプログラムから確認されます。これらのオブジェクトはすべて、暗黙的に宣言されたグローバルデータ構造にまとめてリストされます。タイプのオブジェクト SMC_OUTQUEUE グローバルデータオブジェクトにリストされています g_CNCQueueManager プロパティで Count と方法 GetOutQueue(int n) 。タイプのオブジェクト SMC_CNC_REF グローバルデータオブジェクトにリストされています g_CNCProgManager プロパティで Count と方法 GetProgram(int n) 。これで、ユーザーはIECプログラムでアクセスできるようになります。 例 構造体のデータオブジェクトへのアクセス SMC_OUTQUEUE PROGRAM CNCManageQueue\nVAR\n pCNC_OutQueue : POINTER TO SMC_OUTQUEUE;\n n: INT;\n i: INT;\nEND_VAR\n\nn := g_CNCQueueManager.Count;\nFOR i:= 0 to n-1 DO\n pCNC_OutQueue := g_CNCQueueManager.GetOutQueue(I);\n (* calculate pCNC_OutQueue *)\nEND_FOR 構造体のデータオブジェクトへのアクセス SMC_CNC_REF PROGRAM CNCManageRef\nVAR\n pCNC_Ref: POINTER TO SMC_CNC_REF;\n n: INT;\nEND_VAR\n\nn := g_CNCProgManager.Count;\nFOR i:= 0 to n-1 DO\n pCNC_Ref := g_CNCProgManager.GetProgram(I);\n (* calculate pCNC_Ref *)\nEND_FOR " }, 
{ "title" : "キネマティック変換 ", 
"url" : "_sm_f_cnc_kinematic_transformations.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "順方向および逆方向の変換 ", 
"url" : "_sm_cnc_forward_backward_transformation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ 順方向および逆方向の変換 ", 
"snippet" : "CODESYS SoftMotion 多くの一般的な運動学の数学的順変換および逆変換の関数ブロックを提供します。 キネマティックデザインごとに、2つの機能ブロックを変換に使用できます。名前の付いたPOU SMC_TRAFO_<kinematics> 空間内の位置から軸の位置を計算します（逆変換）。名前の付いたPOU SMC_TRAFOF_<kinematics> 軸の位置から空間内の位置を計算します（前方変換）。 キネマティクスを視覚化するために、フォワードトランスフォーメーションPOUのインスタンスを視覚化テンプレートにすばやく簡単にリンクできます。 SMC_TRAFOV_ 一部の逆変換では...", 
"body" : "CODESYS SoftMotion 多くの一般的な運動学の数学的順変換および逆変換の関数ブロックを提供します。 キネマティックデザインごとに、2つの機能ブロックを変換に使用できます。名前の付いたPOU SMC_TRAFO_<kinematics> 空間内の位置から軸の位置を計算します（逆変換）。名前の付いたPOU SMC_TRAFOF_<kinematics> 軸の位置から空間内の位置を計算します（前方変換）。 キネマティクスを視覚化するために、フォワードトランスフォーメーションPOUのインスタンスを視覚化テンプレートにすばやく簡単にリンクできます。 SMC_TRAFOV_ 一部の逆変換では、パス速度とパス方向を使用して軸速度を計算します。これらの変換POUの名前は、 SMC_TRAFOV_ それ以外の SMC_TRAFO_ 。これらのPOUは、パスの接線を取得します（ v ）およびパス速度（ dVel ）補間器からの追加入力として。また、設定された速度を返します（ dvx\/dvy\/dvz ）設定された位置に加えて。利点は、ドライブがこの方法をサポートしている場合、速度の入力制御によってドライブの遅延を最小限に抑えることができることです。設定した速度をドライブに転送するには、次を使用する必要があります SMC_ControlAxisByPosVel それ以外の SMC_ControlAxisByPos この場合。 詳細については、以下を参照してください。 SMC_ControlAxisByPos（FB） 、 SMC_ControlAxisByVel（FB） 、 と SMC_ControlAxisByPosVel（FB） " }, 
{ "title" : "5軸変換 ", 
"url" : "_sm_trafo_pou_five_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ 5軸変換 ", 
"snippet" : "5軸変換を使用すると、3つの線形空間軸（X、Y、Z）とツールヘッドで構成されるキネマティクスを制御できます。ツールヘッドは、ツールを保持する2つの軸で構成されています。工具軸はZ軸を中心に回転し、工具は次のスキームに従って他の軸を傾斜させます。 パラメータ：の長さ dTool =処理ポイント（ツールチップ= TCP）から回転軸の傾きまでの距離。 5つの位置値による5軸変換の制御： X \/ Y \/ Z-に含まれる処理ポイント（TCP）の位置 pi.dX, pi.dY, pi.dZ 。単位：軸の単位を配置します。 に含まれる球面座標（傾斜と方位角）によるツールの方向 pi.dB と pi.dC 。...", 
"body" : "5軸変換を使用すると、3つの線形空間軸（X、Y、Z）とツールヘッドで構成されるキネマティクスを制御できます。ツールヘッドは、ツールを保持する2つの軸で構成されています。工具軸はZ軸を中心に回転し、工具は次のスキームに従って他の軸を傾斜させます。 パラメータ：の長さ dTool =処理ポイント（ツールチップ= TCP）から回転軸の傾きまでの距離。 5つの位置値による5軸変換の制御： X \/ Y \/ Z-に含まれる処理ポイント（TCP）の位置 pi.dX, pi.dY, pi.dZ 。単位：軸の単位を配置します。 に含まれる球面座標（傾斜と方位角）によるツールの方向 pi.dB と pi.dC 。単位：角度。 ゼロ位置 処理ポイント（TCP）は次の位置にあります（ 0\/0\/-dTool ）。 ツールは負のZ軸の方向に伸びます。回転軸の傾きは、正の方向に回転すると工具が正のX軸の方向に移動するように配置されます。 例 ムーブメントN30の場合、最初にX方向を指す傾斜軸が回転し、ムーブメントの終了時に負のX方向に傾斜したままになります。 N0 PB360 PC360 (set axis B and C in modulo mode 360)\nN10 F10 FB100 FC100 (velocity in X\/Y\/Z: 10, in B and C 100)\nN20 G0 X0 Y0 Z0 C0 B30 (start position)\nN30 G1 X20 B-30 (target position) 詳細については、以下を参照してください。 SMC_TRAFO_5Axes（FB） と SMC_TRAFOF_5Axes（FB） " }, 
{ "title" : "ガントリーシステム ", 
"url" : "_sm_trafo_pou_gantry_system.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ ガントリーシステム ", 
"snippet" : "ガントリーシステムは、直角に配置された2つまたは3つの直線軸で構成されています。 ガントリーシステムで変換を実行する必要がないため、逆変換と順変換のそれぞれのモジュールは、2次元または3次元でX、Y、およびZ軸に1つのオフセットのみを追加します。 詳細については、以下を参照してください。 MC_TRAFO_Gantry2（FB） SMC_TRAFOF_Gantry2（FB） SMC_TRAFO_Gantry3（FB） SMC_TRAFOF_Gantry3（FB）...", 
"body" : "ガントリーシステムは、直角に配置された2つまたは3つの直線軸で構成されています。 ガントリーシステムで変換を実行する必要がないため、逆変換と順変換のそれぞれのモジュールは、2次元または3次元でX、Y、およびZ軸に1つのオフセットのみを追加します。 詳細については、以下を参照してください。 MC_TRAFO_Gantry2（FB） SMC_TRAFOF_Gantry2（FB） SMC_TRAFO_Gantry3（FB） SMC_TRAFOF_Gantry3（FB） " }, 
{ "title" : "方向軸を備えたガントリーシステム ", 
"url" : "_sm_trafo_pou_gantry_cutter.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ 方向軸を備えたガントリーシステム ", 
"snippet" : "「ガントリーカッター」とは、切削工具を備えた回転軸を備えたガントリーシステムです。 回転軸を備えたガントリーシステムの構成は、単純なガントリーシステムの構成と似ています。ただし、これらのシステムには、垂直カッティングユニットが取り付けられている回転軸もあります。 回転軸を備えたガントリーシステムを使用する場合は、 SMC_TRAFO<n>_GantryCutter<n> 代わりにPOU SMC_TRAFO<n>_Gantry<n> 。次に、回転軸は、現在のパスの接線に沿って方向付けられるように制御されます。 ガントリーカッターPOUには、次の追加入力があります。 DriveR ：360°の周期...", 
"body" : "「ガントリーカッター」とは、切削工具を備えた回転軸を備えたガントリーシステムです。 回転軸を備えたガントリーシステムの構成は、単純なガントリーシステムの構成と似ています。ただし、これらのシステムには、垂直カッティングユニットが取り付けられている回転軸もあります。 回転軸を備えたガントリーシステムを使用する場合は、 SMC_TRAFO<n>_GantryCutter<n> 代わりにPOU SMC_TRAFO<n>_Gantry<n> 。次に、回転軸は、現在のパスの接線に沿って方向付けられるように制御されます。 ガントリーカッターPOUには、次の追加入力があります。 DriveR ：360°の周期で使用する必要がある回転軸 dOffsetR ：回転軸のオフセット iDirectionR ： 回転方向 詳細については、以下を参照してください。 SMC_TRAFO_GantryCutter2 (FB) SMC_TRAFOF_GantryCutter2（FB） SMC_TRAFO_GantryCutter3（FB） SMC_TRAFOF_GantryCutter3（FB） 逆変換のPOUには、補間器の出力である現在のパスの接線（v）のベクトルも含める必要があります。 詳細については、以下を参照してください。 SMC_TRAFOV_GantryCutter2（FB） と SMC_TRAFOV_GantryCutter3（FB） " }, 
{ "title" : "ツールオフセット付きガントリーシステム ", 
"url" : "_sm_trafo_pou_gantry_system_tool.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ ツールオフセット付きガントリーシステム ", 
"snippet" : "ツールの軸にオフセットがあり、ガントリーシステムのZ軸と一致しない場合、ツールの接触点はガントリーシステムのX \/ Y \/ Z位置と一致しません。 Z軸を回転できない場合、結果として得られるX座標とY座標のオフセットは一定であり、標準のガントリー変換に直接使用できます。 ツールがC軸（約Z）だけ回転している場合、オフセットは一定ではありませんが、C軸の位置に依存します。この場合、ツールの形式に応じて、2つのPOUのいずれかを選択できます。 SMC_TRAFO_Gantry2Tool1 と SMC_TRAFOF_Gantry2Tool1 ツールは、X軸に沿って回転します。 dAlpha との長さ...", 
"body" : "ツールの軸にオフセットがあり、ガントリーシステムのZ軸と一致しない場合、ツールの接触点はガントリーシステムのX \/ Y \/ Z位置と一致しません。 Z軸を回転できない場合、結果として得られるX座標とY座標のオフセットは一定であり、標準のガントリー変換に直接使用できます。 ツールがC軸（約Z）だけ回転している場合、オフセットは一定ではありませんが、C軸の位置に依存します。この場合、ツールの形式に応じて、2つのPOUのいずれかを選択できます。 SMC_TRAFO_Gantry2Tool1 と SMC_TRAFOF_Gantry2Tool1 ツールは、X軸に沿って回転します。 dAlpha との長さを持っています dToolA 。 SMC_TRAFO_Gantry2Tool2 と SMC_TRAFOF_Gantry2Tool2 ツールは部分的にX軸の方向に回転しています dAlpha （長さ： dToolA ）および部分的に回転したY軸の方向（長さ： dToolB ）。 次の例の図では、レーザーはX方向とY方向の両方にオフセットして取り付けられています。 この1次元変換を実行する代わりに、ツールオフセットを使用してパスを変調することもできます。このとき、工具は直線に近づきます。 The SMC_ToolCorr また SMC_ToolRadiusCorr これには機能ブロックが使用されます。これら2つの方法の違いは、ツールポイントの速度です。モジュレーションを使用する場合 SMC_ToolCorr 、次に回転点の速度はCNCプログラム（F、E）のプリセットに従って制御されます。ツールポイントの速度は変動する可能性があります。 1次元変換を使用する場合、ツールポイントの速度はCNCプログラムによって決定されます。 ツールの向きを計算するには、 SMC_CalcDirectionFromVector POUが使用されます。 " }, 
{ "title" : "固定軸を備えたHガントリー ", 
"url" : "_sm_trafo_pou_h_gantry_stationary_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ 固定軸を備えたHガントリー ", 
"snippet" : "キネマティック構成はガントリーシステムに似ていますが、軸（ドライブ）がしっかりと取り付けられています。彼らはベルトによってツールホルダーを動かします。 による変換 SMC_TRAFO_GantryH2 と SMC_TRAFOF_GantryH2 POUには、次の軸構成が必要です。 xとyを交換することにより、他の構成を実行できます。 この変換には、特別なホーミングが必要です。両方の軸を同じ速度で移動する必要があります。移動をX方向にする必要がある場合は、ドライブAとBを移動する必要がありますが、厳密にX移動するには、逆速度で移動する必要があります。 X移動の場合のみ、反対の速度で移動する必要が...", 
"body" : "キネマティック構成はガントリーシステムに似ていますが、軸（ドライブ）がしっかりと取り付けられています。彼らはベルトによってツールホルダーを動かします。 による変換 SMC_TRAFO_GantryH2 と SMC_TRAFOF_GantryH2 POUには、次の軸構成が必要です。 xとyを交換することにより、他の構成を実行できます。 この変換には、特別なホーミングが必要です。両方の軸を同じ速度で移動する必要があります。移動をX方向にする必要がある場合は、ドライブAとBを移動する必要がありますが、厳密にX移動するには、逆速度で移動する必要があります。 X移動の場合のみ、反対の速度で移動する必要があります。ホーミングが見つかった場合、フォワードトランスフォーメーションPOUから計算されたX値とY値がオフセットとして使用されます（ dOffsetX と dOffsetY ）。 " }, 
{ "title" : "固定軸を備えたTガントリー ", 
"url" : "_sm_trafo_pou_t_gantry_statinary_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ 固定軸を備えたTガントリー ", 
"snippet" : "このキネマティックシステムは、Hガントリーシステムに似ています。ここのドライブも固定されて取り付けられており、ツールホルダーはベルトによって動かされます。 によって実行される変換 SMC_TRAFO_GantryT2 と SMC_TRAFOF_GantryT2 POUは、次のドライブコンステレーション用に設計されています。 この変換には特別なホーミングが必要であることに注意してください。 X方向に移動する場合は、AドライブとBドライブを同じ速度で移動する必要があります。厳密にY移動を実行する場合、ドライブは反対方向に回転する必要があります。ドライブが原点復帰位置を検出すると、順方向変換POUか...", 
"body" : "このキネマティックシステムは、Hガントリーシステムに似ています。ここのドライブも固定されて取り付けられており、ツールホルダーはベルトによって動かされます。 によって実行される変換 SMC_TRAFO_GantryT2 と SMC_TRAFOF_GantryT2 POUは、次のドライブコンステレーション用に設計されています。 この変換には特別なホーミングが必要であることに注意してください。 X方向に移動する場合は、AドライブとBドライブを同じ速度で移動する必要があります。厳密にY移動を実行する場合、ドライブは反対方向に回転する必要があります。ドライブが原点復帰位置を検出すると、順方向変換POUから計算されたX値とY値がオフセットとして使用されます（ dOffsetX と dOffsetY ）。 The SMC_TRAFO_GantryT2_O と SMC_TRAFOF_GantryT2_O 関数ブロックは、次のコンスタレーションを使用して同じ計算を実行します。 " }, 
{ "title" : "極座標系 ", 
"url" : "_sm_trafo_pou_polar_system.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ 極座標系 ", 
"snippet" : "極座標系は、回転軸（方向）と直線軸（距離）で構成されます。 直線軸の原点と方向は、オフセットを使用して変更できます dPhi と dR 。 詳細については、以下を参照してください。 SMC_TRAFO_Polar（FB） と SMC_TRAFOF_Polar（FB）...", 
"body" : "極座標系は、回転軸（方向）と直線軸（距離）で構成されます。 直線軸の原点と方向は、オフセットを使用して変更できます dPhi と dR 。 詳細については、以下を参照してください。 SMC_TRAFO_Polar（FB） と SMC_TRAFOF_Polar（FB） " }, 
{ "title" : "2関節スカラシステム ", 
"url" : "_sm_trafo_pou_two_jointed_scara.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ 2関節スカラシステム ", 
"snippet" : "The 選択的コンプライアンスアセンブリロボットアーム （スカラ）は、人間の腕に似た特殊なタイプの産業用ロボットです。スカラシステムには2つの軸と2つの自由度があります。移動はX \/ Y平面に制限されます。 詳細については、以下を参照してください。 SMC_TRAFO_Scara2（FB） と SMC_TRAFOF_Scara2（FB）...", 
"body" : "The 選択的コンプライアンスアセンブリロボットアーム （スカラ）は、人間の腕に似た特殊なタイプの産業用ロボットです。スカラシステムには2つの軸と2つの自由度があります。移動はX \/ Y平面に制限されます。 詳細については、以下を参照してください。 SMC_TRAFO_Scara2（FB） と SMC_TRAFOF_Scara2（FB） " }, 
{ "title" : "3関節SCARAシステム ", 
"url" : "_sm_trafo_pou_three_jointed_scara.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ 3関節SCARAシステム ", 
"snippet" : "3関節スカラシステムには、一定方向への移動を可能にする第3軸があります。 2ジョイントシステムと同様に、移動はX \/ Y平面に制限されます。 詳細については、以下を参照してください。 SMC_TRAFO_Scara3（FB） と SMC_TRAFOF_Scara3（FB）...", 
"body" : "3関節スカラシステムには、一定方向への移動を可能にする第3軸があります。 2ジョイントシステムと同様に、移動はX \/ Y平面に制限されます。 詳細については、以下を参照してください。 SMC_TRAFO_Scara3（FB） と SMC_TRAFOF_Scara3（FB） " }, 
{ "title" : "パラレルキネマティクス ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ パラレルキネマティクス ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "直線軸の三脚 ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_b6b32d1fbe665307c0a8640e00033022", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ パラレルキネマティクス \/ 直線軸の三脚 ", 
"snippet" : "このシステムには、互いに定義された角度にある3つのリニアドライブがあります。ドライブは、トラバーススライドを備えた3本のレールで構成されています。ツールプレートは、同じ長さのコネクティングロッドによってトラバーススライドに接続されます。コネクティングロッドのペアのセットは、同じ方向で床に平行にツールプレートを保持します。キネマティクスは、ツールプレートを3次元で動かすことができます。 これらの運動学の順方向および逆方向の変換は、 SMC_Trafo_Tripod_Lin と SMC_TrafoF_Tripod_Lin POU。三脚の軸角度は、レールと垂直軸の間の角度によって定義されます（ dA...", 
"body" : "このシステムには、互いに定義された角度にある3つのリニアドライブがあります。ドライブは、トラバーススライドを備えた3本のレールで構成されています。ツールプレートは、同じ長さのコネクティングロッドによってトラバーススライドに接続されます。コネクティングロッドのペアのセットは、同じ方向で床に平行にツールプレートを保持します。キネマティクスは、ツールプレートを3次元で動かすことができます。 これらの運動学の順方向および逆方向の変換は、 SMC_Trafo_Tripod_Lin と SMC_TrafoF_Tripod_Lin POU。三脚の軸角度は、レールと垂直軸の間の角度によって定義されます（ dAxisAngle ）。 機械的要件と座標系 3軸の長さは同じです。 コネクティングロッドの長さは同じです。 コネクティングロッドのペア間の距離は、すべてのペアで同じです。 ドライブレールと垂直軸の間の軸角度は、3つのドライブすべてで同じです。許容角度は0°から90°の間です。 軸は、スライダーのコネクティングロッドジョイント間のポイントの動きを定義します。 XYZ座標系は右手です。 XベクトルとYベクトルは水平で、Zは上を向いています。原点は、3つの移動軸とXY平面（下の図：点A）の交点が[0,0,0]の位置の円上にあるように定義されます。 SMC_TrafoF_Tripod_Lin機能ブロックのパラメーター化 名前 説明 dInnerRadius ツールプレートの中心からコネクティングロッドのグリップポイントまでの距離 dOuterRadius 点Aは、軸とXY平面の交点です。 dLength コネクティングロッドの長さ dDistance 1対の2つのコネクティングロッド間の距離 dRotationOffset 最初の軸の点Aは、デフォルトでX軸を定義します。オフセットは、構造全体をZ軸を中心に回転させるために使用されます。この場合、ポイントAはX軸上にありません。 dOffsetA オフセットは、軸の位置値をデフォルト設定のゼロに設定するために使用されます。 dOffsetB dOffsetC ライブラリの説明には、他のパラメータに関する情報があります。 " }, 
{ "title" : "垂直軸を備えた三脚 ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_74ba1833be665308c0a8640e019694c6", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ パラレルキネマティクス \/ 垂直軸を備えた三脚 ", 
"snippet" : "このシステムは、上記の運動学的設計の特殊な変形であり、同じ機械的要件があります。角度 dAxisAngle ガイドレールと垂直軸の間は0°で、ガイドレールは垂直軸に平行です。 これらの運動学の順方向および逆方向の変換は、 SMC_Trafo_Tripod_Lin と SMC_TrafoF_Tripod_Lin ファンクションブロック。三脚の軸角度は、レールと垂直軸の間の角度によって定義されます（ dAxisAngle ）。 SMC_TrafoF_Tripod_Lin機能ブロックのパラメーター化 名前 説明 dInnerRadius このパラメータは、ツールプレートへのコネクティングロッドの6つ...", 
"body" : "このシステムは、上記の運動学的設計の特殊な変形であり、同じ機械的要件があります。角度 dAxisAngle ガイドレールと垂直軸の間は0°で、ガイドレールは垂直軸に平行です。 これらの運動学の順方向および逆方向の変換は、 SMC_Trafo_Tripod_Lin と SMC_TrafoF_Tripod_Lin ファンクションブロック。三脚の軸角度は、レールと垂直軸の間の角度によって定義されます（ dAxisAngle ）。 SMC_TrafoF_Tripod_Lin機能ブロックのパラメーター化 名前 説明 dInnerRadius このパラメータは、ツールプレートへのコネクティングロッドの6つのグリップポイントによって表される円の半径を定義します。 dOuterRadius dLength コネクティングロッドの長さ dDistance コネクティングロッドのペア同士の距離 dRotationOffset 最初の軸の点Aは、デフォルトでX軸を定義します。オフセットは、構造全体をZ軸を中心に回転させるために使用されます。この場合、ポイントAはX軸上にありません。 dOffsetA オフセットは、軸の位置値をデフォルト設定のゼロに設定するために使用されます。 dOffsetB dOffsetC ライブラリの説明には、他のパラメータに関する情報があります。 " }, 
{ "title" : "回転軸付き三脚 ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_30491f2ca003ef70c0a864631e92f50c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ パラレルキネマティクス \/ 回転軸付き三脚 ", 
"snippet" : "三脚の場合、キネマティクスは、アームとコネクティングロッドによってツールプレートに接続されている3つのロータリードライブによって実装されます。 座標系の原点は、3つのアームすべてが水平位置にあるときのツールプレートの中心の位置です。 これらの運動学の順方向および逆方向の変換は、 SMC_TRAFO_Tripod_Arm と SMC_TRAFOF_Tripod_Arm ファンクションブロック。 機械的要件と座標系 3つの軸の長さは同じです。 コネクティングロッドの長さは同じです。 コネクティングロッドのペア間の距離は、すべてのペアで同じです。 SMC_TrafoF_Tripod_Arm機能ブロッ...", 
"body" : "三脚の場合、キネマティクスは、アームとコネクティングロッドによってツールプレートに接続されている3つのロータリードライブによって実装されます。 座標系の原点は、3つのアームすべてが水平位置にあるときのツールプレートの中心の位置です。 これらの運動学の順方向および逆方向の変換は、 SMC_TRAFO_Tripod_Arm と SMC_TRAFOF_Tripod_Arm ファンクションブロック。 機械的要件と座標系 3つの軸の長さは同じです。 コネクティングロッドの長さは同じです。 コネクティングロッドのペア間の距離は、すべてのペアで同じです。 SMC_TrafoF_Tripod_Arm機能ブロックのパラメーター化 名前 説明 dArmLength1 dArmLength2 dArm1Radius パラメータは、ドライブの3点Pによって確立される円の半径を定義します。 dStewartRadius このパラメータは、ツールプレートへのコネクティングロッドの6つのグリップポイントによって表される円の半径を定義します。 dDistance 1対の2つのコネクティングロッド間の距離 dOffsetA dOffsetB dOffsetC ライブラリの説明には、他のパラメータに関する情報があります。 この画像は、すべての軸のゼロ位置を示しています。 （3つの上部アームは水平です。）MCSはツールプレートに表示されます。 A0、A1、およびA2軸の矢印は、右手の法則に従ったドライブの回転方向を示しています。 機械座標系（MCS） 元 3つの上部アーム（A0、A1、またはA2に直接接続されているもの）がすべて水平位置にあるときに、ツールプレートの中点で定義されます X 原点から、最初のモーター（A0）から離れた方向を指し、最初のアームの上腕セグメントに平行です。 Y MCSが右手になるようにXとZによって決定されます Z ツールプレートに直交 ツールプレートからモーターの方向へのポイント それぞれの変換は、次のPOUによって実行されます SMC_TRAFO_Tripod_Arm と SMC_TRAFOF_Tripod_Arm ： 例：3S三脚 変換設定 tta:\nSMC_TRAFO_Tripod_Arm := (dArmLength1:=200, dArmLength2:=300, dArm1Radius:=112, dStewartRadius:=53,dDistance:=41,dMaxAngleBallJoint:=60);\nttaf:\nSMC_TRAFOF_Tripod_Arm := (dArmLength1:=200, dArmLength2:=300, dArm1Radius:=112, dStewartRadius:=53,dDistance:=41); " }, 
{ "title" : "4軸パレタイザーキネマティクス ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ 4軸パレタイザーキネマティクス ", 
"snippet" : "4軸パレタイザーキネマティクスは、パレタイズ作業に頻繁に使用される一般的なロボットタイプです。キネマティクスには、4つの制御された回転軸（赤でマーク）と5番目の機械的な回転軸（灰色でマーク）が備わっています。 The SMC_Trafo_4AxisPalletizer と SMC_TrafoF_4AxisPalletizer POUは、順変換と逆変換を実装します。 デカルト座標系は、パレタイザーの基礎です。 Z軸は垂直に下向きになり、X軸は「前方」になります。これは、アームが軸のゼロ方向を指す方向を意味します。デカルト座標系の原点は、関節軸1とロボットの下側の交点です。 オブジェクト データ構...", 
"body" : "4軸パレタイザーキネマティクスは、パレタイズ作業に頻繁に使用される一般的なロボットタイプです。キネマティクスには、4つの制御された回転軸（赤でマーク）と5番目の機械的な回転軸（灰色でマーク）が備わっています。 The SMC_Trafo_4AxisPalletizer と SMC_TrafoF_4AxisPalletizer POUは、順変換と逆変換を実装します。 デカルト座標系は、パレタイザーの基礎です。 Z軸は垂直に下向きになり、X軸は「前方」になります。これは、アームが軸のゼロ方向を指す方向を意味します。デカルト座標系の原点は、関節軸1とロボットの下側の交点です。 オブジェクト データ構造 SMC_TrafoConfig_4AxisPalletizer および機能ブロック SMC_Trafo_4AxisPalletizer と SMC_TrafoF_4AxisPalletizer ライブラリにリンクされています SM3_Transformation 。パラメータの説明については、ライブラリマネージャでこれらのオブジェクトを検索してください。 " }, 
{ "title" : "軸の定義 ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_945c0811df409256c0a8657d0066458b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ 4軸パレタイザーキネマティクス \/ 軸の定義 ", 
"snippet" : "次の画像は、4つの軸の回転方向を示しています。黒い矢印は関節軸に沿って走っています。回転方向は右手の法則に従って決定されます。右手の親指が矢印に沿って下を向いている場合、正の回転方向はわずかに湾曲した指の方向になります。たとえば、上から見た場合、軸0の正の回転方向は時計回りですが、軸1と2は正の回転のために「前方」に傾斜しています。 キネマティクスには、4つの制御された回転軸（赤色の軸a0、a1、a2、a3を参照）と5番目の機械式回転軸（灰色の軸Mを参照）があります。 軸の値の範囲： 軸0：]-180°、180°[ 軸1：[-90°、90°] 軸2：[-180°、90 [ M軸:機械式回転軸制...", 
"body" : "次の画像は、4つの軸の回転方向を示しています。黒い矢印は関節軸に沿って走っています。回転方向は右手の法則に従って決定されます。右手の親指が矢印に沿って下を向いている場合、正の回転方向はわずかに湾曲した指の方向になります。たとえば、上から見た場合、軸0の正の回転方向は時計回りですが、軸1と2は正の回転のために「前方」に傾斜しています。 キネマティクスには、4つの制御された回転軸（赤色の軸a0、a1、a2、a3を参照）と5番目の機械式回転軸（灰色の軸Mを参照）があります。 軸の値の範囲： 軸0：]-180°、180°[ 軸1：[-90°、90°] 軸2：[-180°、90 [ M軸:機械式回転軸制限なし 軸3：無制限。範囲は360°より大きくすることもできます " }, 
{ "title" : "ゼロ位置と寸法 ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_e7016982df408f59c0a8657d017550b3", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ 4軸パレタイザーキネマティクス \/ ゼロ位置と寸法 ", 
"snippet" : "この画像は、すべての軸のゼロ位置での運動学を示しています。ゼロ位置では、工具座標系の軸は機械座標系の軸と平行になります。構成構造で指定された寸法を指定します SMC_TrafoConfig_4AxisPalletizer また、すべてを指定します a_i 正の兆候とすべて d_i 負の符号付き。パラメータの名前は、Denavit-Hartenbergの規則に従っています。 関節のDenavit–Hartenberg変換 ジョイントオフセット（sigma_i） 関節距離（d_i） アーム要素の長さ（a_i） ねじれ（alpha_i） 1 0° d_1 a_1 90° 2 -90° 0 a_2 0...", 
"body" : "この画像は、すべての軸のゼロ位置での運動学を示しています。ゼロ位置では、工具座標系の軸は機械座標系の軸と平行になります。構成構造で指定された寸法を指定します SMC_TrafoConfig_4AxisPalletizer また、すべてを指定します a_i 正の兆候とすべて d_i 負の符号付き。パラメータの名前は、Denavit-Hartenbergの規則に従っています。 関節のDenavit–Hartenberg変換 ジョイントオフセット（sigma_i） 関節距離（d_i） アーム要素の長さ（a_i） ねじれ（alpha_i） 1 0° d_1 a_1 90° 2 -90° 0 a_2 0° 3 90° 0 a_3 0° 4 0° 0 a_4 90° 5 0° d_5 0 180° " }, 
{ "title" : "Gコードでのプログラミング ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_67269b93df408f35c0a8657d0178e964", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ 4軸パレタイザーキネマティクス \/ Gコードでのプログラミング ", 
"snippet" : "グリッパーの位置はX、Y、およびZで制御されます。垂直方向のグリッパーの回転は、追加の軸Cによって制御されます。角度は度で指定されます。...", 
"body" : "グリッパーの位置はX、Y、およびZで制御されます。垂直方向のグリッパーの回転は、追加の軸Cによって制御されます。角度は度で指定されます。 " }, 
{ "title" : "6軸多関節ロボット ", 
"url" : "_sm_trafo_pou_six_dof_robot.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ 6軸多関節ロボット ", 
"snippet" : "6つの回転軸と6つの自由度（DoF）を備えた関節式アームロボットの変換。ロボットアームの3つの方向軸は、ジョイントの中心という1点で交差します。 NS SMC_Trafo_ArticulatedRobot_6DOF と SMC_TrafoF_ArticulatedRobot_6DOF 機能ブロックは、6つの回転軸を持つ関節式アームロボットの順方向および逆方向の変換を実装します。この画像では、デカルト座標系が軸0で下にマークされています。z軸は下向きで、x軸はツールの中心点（TCP）の方向に前向きです。デカルト座標系の原点は、交点軸0とロボットの下側です。 変換オブジェクト データ構造 SMC_...", 
"body" : "6つの回転軸と6つの自由度（DoF）を備えた関節式アームロボットの変換。ロボットアームの3つの方向軸は、ジョイントの中心という1点で交差します。 NS SMC_Trafo_ArticulatedRobot_6DOF と SMC_TrafoF_ArticulatedRobot_6DOF 機能ブロックは、6つの回転軸を持つ関節式アームロボットの順方向および逆方向の変換を実装します。この画像では、デカルト座標系が軸0で下にマークされています。z軸は下向きで、x軸はツールの中心点（TCP）の方向に前向きです。デカルト座標系の原点は、交点軸0とロボットの下側です。 変換オブジェクト データ構造 SMC_TrafoConfig_ArticulatedRobot_6DOF そしてその SMC_Trafo_ArticulatedRobot_6DOF と SMC_TrafoF_ArticulatedRobot_6DOF 機能ブロックはにリンクされています SM3_CNC 。 " }, 
{ "title" : "軸の定義 ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_7e060a95379b6b55c0a8640e01f01d63", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ 6軸多関節ロボット \/ 軸の定義 ", 
"snippet" : "回転軸は黒い矢印で識別されます。正の回転方向は右手の法則によって与えられます。たとえば、軸0を正の方向に回転させると、ロボットは上から見て時計回りに回転します。 軸は次の範囲に制限されています。 軸0、1、3、および4：]-180°、180°[ 軸2：[-90°、180°] 軸5：無制限。範囲は360°より大きくなる場合があります。...", 
"body" : "回転軸は黒い矢印で識別されます。正の回転方向は右手の法則によって与えられます。たとえば、軸0を正の方向に回転させると、ロボットは上から見て時計回りに回転します。 軸は次の範囲に制限されています。 軸0、1、3、および4：]-180°、180°[ 軸2：[-90°、180°] 軸5：無制限。範囲は360°より大きくなる場合があります。 " }, 
{ "title" : "ホーミング位置と寸法 ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_e7016982df408f59c0a8657d017550b3", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ 6軸多関節ロボット \/ ホーミング位置と寸法 ", 
"snippet" : "左の画像は、キネマティクスの原点復帰位置を示しています。これは、すべての軸がゼロ位置にある位置です。構成構造で指定された寸法を指定します SMC_TrafoConfig_ArticulatedRobot_6DOF 。パラメータの名前と記号は、Denavit-Hartenbergの規則に従っています。右の画像は、追加のDenavit–Hartenbergパラメーターを示しています d3 。 ノート： a1、a3、d4、およびd6は> = 0である必要があります a2は> 0でなければなりません（> g_fSMC_CNC_EPS ） d1は<= 0でなければなりません 関節のDenavit–Har...", 
"body" : "左の画像は、キネマティクスの原点復帰位置を示しています。これは、すべての軸がゼロ位置にある位置です。構成構造で指定された寸法を指定します SMC_TrafoConfig_ArticulatedRobot_6DOF 。パラメータの名前と記号は、Denavit-Hartenbergの規則に従っています。右の画像は、追加のDenavit–Hartenbergパラメーターを示しています d3 。 ノート： a1、a3、d4、およびd6は> = 0である必要があります a2は> 0でなければなりません（> g_fSMC_CNC_EPS ） d1は<= 0でなければなりません 関節のDenavit–Hartenberg変換 ジョイントオフセット（sigma_i） レバーオフセット（d_i） レバーの長さ（a_i） レバー回転（alpha_i） 1 0° d1 a_1 -90° 2 90° 0 a_2 0° 3 0° d3 a_3 90° 4 0° d4 0 90° 5 0° 0 0 -90° 6 0° d6 0 0° " }, 
{ "title" : "プログラミング ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_9cf41a3c6a5fb376c0a8640e005461c1", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ 6軸多関節ロボット \/ プログラミング ", 
"snippet" : "ツールセンターの位置は、X、Y、およびZで制御されます。X、Y、およびZの単位は、パラメータに使用されるものと同じです。 a_i と d_i （例：mm）。方向は、A（ヨー）、B（ピッチ）、およびC（ロール）で度単位で制御されます。...", 
"body" : "ツールセンターの位置は、X、Y、およびZで制御されます。X、Y、およびZの単位は、パラメータに使用されるものと同じです。 a_i と d_i （例：mm）。方向は、A（ヨー）、B（ピッチ）、およびC（ロール）で度単位で制御されます。 " }, 
{ "title" : "のキネマティック変換関数ブロック用ラッパー SM3_Transformation ライブラリ ", 
"url" : "_sm_wrapper_kinematic_fbs.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ キネマティック変換 \/ のキネマティック変換関数ブロック用ラッパー SM3_Transformation ライブラリ ", 
"snippet" : "ザル SMC_Trafo_Wrapper と SMC_Traff_Wrapper ファンクションブロックでは、以下のキネマティクスを使用できます。 SM3_Transformation CNC アプリケーション用ライブラリ。 のキネマティクスの詳細については SM3_Transformation ライブラリ。以下を参照してください。 運動学以下を実装する任意の変換を使用できます。 MC_KIN_REF_SM3 インターフェイス。さらに、「位置運動学」と「配向運動学」の組み合わせも可能です 詳細については、以下を参照してください。 位置と方向の運動学の組み合わせ...", 
"body" : "ザル SMC_Trafo_Wrapper と SMC_Traff_Wrapper ファンクションブロックでは、以下のキネマティクスを使用できます。 SM3_Transformation CNC アプリケーション用ライブラリ。 のキネマティクスの詳細については SM3_Transformation ライブラリ。以下を参照してください。 運動学以下を実装する任意の変換を使用できます。 MC_KIN_REF_SM3 インターフェイス。さらに、「位置運動学」と「配向運動学」の組み合わせも可能です 詳細については、以下を参照してください。 位置と方向の運動学の組み合わせ" }, 
{ "title" : "DIN66025のCNC言語 ", 
"url" : "_sm_struct_reference_programming_din66025.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "DIN66025の基礎 ", 
"url" : "_sm_cnc_din66025_basics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ DIN66025の基礎 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "DIN66025プログラムの構造 ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_c348b29fedfe7b9ec0a86463427bc61d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ DIN66025の基礎 \/ DIN66025プログラムの構造 ", 
"snippet" : "DIN 66025プログラムは、個々のモーションブロックで構成されています。ブロック番号は、各ブロックの先頭にあります。 ['%' <Programmname>] <Satz>{<Satz>} ブロックは次のように構成できます。 N<block number> G<expression> <G code words> N<block number> <G code words> （NS G<expression> 前のブロックのが適用されます） N<block number> M<expression> <G code words> N<block number> <subroutine na...", 
"body" : "DIN 66025プログラムは、個々のモーションブロックで構成されています。ブロック番号は、各ブロックの先頭にあります。 ['%' <Programmname>]\n<Satz>{<Satz>} ブロックは次のように構成できます。 N<block number> G<expression> <G code words> N<block number> <G code words> （NS G<expression> 前のブロックのが適用されます） N<block number> M<expression> <G code words> N<block number> <subroutine name> ( <ActualParamList> ) サブルーチンの追加のブロック構造： SUBPROGRAM <Name> {<FormalParamList>} <RESTORE_OPT> N<block number> RETURN END_SUBPROGRAM 例 2本の線と円弧からのパスとそれに続くサブルーチン呼び出し % MyProgram\nN10 G01 X100 Y100 E100 F100 E-200\nN20 G01 Z40 F20\nN30 G03 X-100 R200 F100\nN40 SubPrg{5} " }, 
{ "title" : "構文 ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_section-idm4580346248046432600861986014", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ DIN66025の基礎 \/ 構文 ", 
"snippet" : "['％' <プログラム名>] オプションのヘッダー ％で始まり、その後にプログラム名が続きます。 スペース また タブ <ブロック> ブロックは、右から左に単語ごとに処理されます。 \/ ステップ抑制 ブロックが\/で始まり、 CNC➔ステップ抑制 コマンドを選択すると、ブロックは実行されません。 N <ブロック番号> ブロック番号は、ジャンプターゲットを定義するためのマーカーとして使用されます。 例： N01 G <式> トラベルコマンド ブロックに移動コマンドが指定されていない場合、前のブロックの移動コマンドが自動的に補足されます。 大文字と小文字は無視されます。 先行ゼロは無視されます。した...", 
"body" : "['％' <プログラム名>] オプションのヘッダー ％で始まり、その後にプログラム名が続きます。 スペース また タブ <ブロック> ブロックは、右から左に単語ごとに処理されます。 \/ ステップ抑制 ブロックが\/で始まり、 CNC➔ステップ抑制 コマンドを選択すると、ブロックは実行されません。 N <ブロック番号> ブロック番号は、ジャンプターゲットを定義するためのマーカーとして使用されます。 例： N01 G <式> トラベルコマンド ブロックに移動コマンドが指定されていない場合、前のブロックの移動コマンドが自動的に補足されます。 大文字と小文字は無視されます。 先行ゼロは無視されます。したがって、 G01 = g1 適用されます パス要素またはパスオブジェクトに対応します 例： G1 （線形）、 G2 （アーク） パスオブジェクトが補間される速度。原則として、設定されたパス速度、パス加速、パス減速に対応します。補間器は、これらの制限値を超えないようにします。 <Gコードワード> 大文字と小文字は無視されます。 Gコードワード アドレスで構成されます (例: E ) と表現 (例 100 ; 一緒に E100 ) 大文字と小文字は無視されます。 先行ゼロは無視されます。 単語の番号を変数に書き込みます 単語の文字は変数名です。 travelコマンドはこれにアクセスします。 すべての数値は浮動小数点値にすることができます。これは、 G<expression> 旅行コマンド、 M<expression> M関数、および H<expression> スイッチポイント。 ブロックの単語は、 スペース また タブ 。 <式> 見る： 式() コメント 括弧内の文字はコメントとして解釈されます。 注：コメントは、 bParenthesesAsComments 入力 ( FB SMC_ReadNCFile2 ) 。 2つの連続するブロック間の補間 2つの隣接するオブジェクトを遷移するときの速度は、次のルールによって決定されます。 2つのオブジェクトの1つが G0 、次に遷移速度= 0。 遷移時の両方のパス要素の接線間の角度が角度許容値よりも大きい場合、遷移速度= 0です。 それ以外の場合、遷移速度は両方のパス要素の中で指定された最小速度です。 原則として、移動コマンドは、最後の移動コマンドの目標位置を、現在の移動コマンドで指定された目標位置に補間して実行する役割を果たします。最初の移動コマンドは、デコーダーまたはCNCエディターで定義された位置から始まります。この位置が定義されていない場合、開始点はX = 0、Y = 0、Z = 0です。 " }, 
{ "title" : "移動コマンドと対応するパス要素 ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_48e0dea1edfe7b9ec0a8646321fb969d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ DIN66025の基礎 \/ 移動コマンドと対応するパス要素 ", 
"snippet" : "トラベルコマンド 説明 パス要素 G0 ツール操作なしの直接移動。線形運動 ポジショニングG1 工具操作による直線運動 線形運動G2 時計回りの円形セグメントまたは円 アークG3 反時計回りの円形セグメントまたは円 アークG4 滞留時間 滞留時間G5 2Dカーディナルスプラインのポイント スプラインG6 放物線 放物線G8 楕円弧または楕円、時計回り 楕円G9 楕円弧または楕円、反時計回り 楕円G10 3Dカーディナルスプラインのポイント スプラインG15 2Dに切り替えます 3DモードG16 法線ベクトルで3Dモードをアクティブにして3Dに切り替えます I \/ J \/ K 飛行機に 3Dモー...", 
"body" : "トラベルコマンド 説明 パス要素 G0 ツール操作なしの直接移動。線形運動 ポジショニングG1 工具操作による直線運動 線形運動G2 時計回りの円形セグメントまたは円 アークG3 反時計回りの円形セグメントまたは円 アークG4 滞留時間 滞留時間G5 2Dカーディナルスプラインのポイント スプラインG6 放物線 放物線G8 楕円弧または楕円、時計回り 楕円G9 楕円弧または楕円、反時計回り 楕円G10 3Dカーディナルスプラインのポイント スプラインG15 2Dに切り替えます 3DモードG16 法線ベクトルで3Dモードをアクティブにして3Dに切り替えます I \/ J \/ K 飛行機に 3DモードG17 で3Dモードをアクティブにして3Dに切り替えます X \/ Y 飛行機 3DモードG18 で3Dモードをアクティブにして3Dに切り替えます Z \/ X 飛行機 3DモードG19 で3Dモードをアクティブにして3Dに切り替えます Y \/ Z 飛行機 3DモードG20 条件付きジャンプ L 、 もしも K <> 0 ジャンプG31 デコード停止で残り距離を削除 プロービング機能 (残り距離クリア)G36 値を書く D 変数に O 変数の値の変更G37 インクリメント変数 O 値で D 変数の値の変更G38 拡張前処理機能を有効にする 拡張前処理機能の有効化G39 拡張前処理機能を無効にする 拡張前処理機能の有効化G40 工具径補正終了 前処理G41 移動方向の左側の工具半径補正の開始 前処理G42 工具径補正の開始、進行方向の右側 前処理G43 工具長補正を開始します 前処理G50 コーナーラウンド\/スムージングの終了 前処理G51 コーナースムージングの開始 前処理G52 コーナーラウンドの開始 前処理G53 座標変換を終了し、デコーダーの座標系を元の位置にリセットします（=マシンの座標系） 座標系のシフト、回転、およびスケーリングG54 座標の絶対変換 座標系のシフト、回転、およびスケーリングG55 座標の相対変換 座標系のシフト、回転、およびスケーリングG56 DCSの現在の方向、位置、およびスケーリングを設定し、基準点として設定します 座標系のシフト、回転、およびスケーリングG60 ループ終了抑制 前処理G61 ループ抑制の開始 前処理G70 追加の軸のスムージングの終了 見る： SMC_SmoothAddAxes 前処理G71 追加の軸のスムージングを開始 見る： SMC_SmoothAddAxes 前処理G75 補間器とのタイミング同期 補間器とのタイミング同期G90 座標（ X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ）は絶対値として解釈されます。 （これがデフォルト設定です。） モードG91 座標（ X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ）は、現在の位置を基準にした値として解釈されます。 モードG92 ジャンプによるポジショニング ポジショニングG98 軸の中点（ I \/ J \/ K ）は絶対値として解釈されます。 モードG99 軸の中点（ I \/ J \/ K ）は、開始位置を基準にした値として解釈されます。 （これがデフォルト設定です。） モード" }, 
{ "title" : "Gコードの単語認識 ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_591ac87c61b577fcc0a8640e0070747c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ DIN66025の基礎 \/ Gコードの単語認識 ", 
"snippet" : "A 追加スプライン軸の目標位置 デコーダー座標系での座標変換の場合、単語には角度が含まれます。 B C D 補正用の工具半径 G40 - G42 コーナーラウンドの工具距離 G50 - G51 可変値 G36 \/ G37 E [u \/秒単位の最大パス加速\/減速 2 ]。値> 0：加速度;値<0：減速 EF の経路加減速 G0 モーション E<axis> 指定された個別の加速\/減速（> 0 \/ <0） <axis> 追加の軸 追加の軸は A 、 B 、 C 、 P 、 Q 、 U 、 V 、 W 、そしてまた Z 2Dモードで。 このGコードが使用されている場合、パス処理ブロック SMC_Ext...", 
"body" : "A 追加スプライン軸の目標位置 デコーダー座標系での座標変換の場合、単語には角度が含まれます。 B C D 補正用の工具半径 G40 - G42 コーナーラウンドの工具距離 G50 - G51 可変値 G36 \/ G37 E [u \/秒単位の最大パス加速\/減速 2 ]。値> 0：加速度;値<0：減速 EF の経路加減速 G0 モーション E<axis> 指定された個別の加速\/減速（> 0 \/ <0） <axis> 追加の軸 追加の軸は A 、 B 、 C 、 P 、 Q 、 U 、 V 、 W 、そしてまた Z 2Dモードで。 このGコードが使用されている場合、パス処理ブロック SMC_ExtendedVelocityChecks 速度を制限するために使用する必要があります。 F 速度（[u \/秒]）：「フィード」 FF の速度 G0 動き F<axis> 指定された追加軸の個々の速度<軸> 追加の軸は A 、 B 、 C 、 P 、 Q 、 U 、 V 、 W 、そしてまた Z 2Dモードで。 このGコードが使用されている場合、パス処理ブロック SMC_ExtendedVelocityChecks 速度を制限するために使用する必要があります。 G パス条件 H スイッチポイント（H機能） ポジティブ：スイッチを入れる ネガティブ：スイッチをオフにします I の円\/楕円の中点のX座標 G02 \/ G03 \/ G08 \/ G09 放物線の頂点のX座標 G06 3D平面関数の法線ベクトル（X） の拡張前処理機能をアクティブ化するためのパラメータ G38 \/ G39 X方向のスケーリング G54 \/ G55 \/ G56 X方向の工具オフセット G43 J の円\/楕円の中点のY座標 G02 \/ G03 \/ G08 \/ G09 放物線の頂点のY座標 G06 3D平面関数の法線ベクトル（Y） の拡張前処理機能をアクティブ化するためのパラメータ G38 \/ G39 のY方向のスケーリング G54 \/ G55 \/ G56 Y方向の工具オフセット G43 K 主楕円軸の方向。数学的に：0°= O 、90°= N 、 NS。 のジャンプ条件 G20 M関数のdT1パラメーター値 の円の中点のZ座標 G02 \/ G03 3Dモードで 3D平面関数の法線ベクトル（Z） の拡張前処理機能をアクティブ化するためのパラメータ G38 \/ G39 のZ方向のスケーリング G54 \/ G55 \/ G56 のZ方向の工具オフセット G43 L H 関数の絶対スイッチ位置。パス要素の始点から測定 (位置が 0 より大きい場合)、またはパス要素の終点から測定 (位置 < 0 の場合)。 ジャンプターゲット G20 M関数のdT2パラメーター値 の追加軸の番号 G70 と G71 M 機械の追加オプション。 M関数も O H機能の値範囲[0..1]の相対スイッチポイント位置 可変値 G36 \/ G37 。 M関数のパラメーターのデータ構造 P 追加直線軸の目標位置 P P<axis><period> モジュロ軸の構成 もしも Period = 0が適用されます（例： PA0 ）、軸の動作は線形です。 PROBE 動きのプロービング機能（残り距離をクリア）を有効にします Q 追加直線軸の目標位置 Q R I、Jの代わりとなる円半径 G02 \/ G03 [0..1]の値の範囲での楕円形の2次\/ 1次軸の長さの比率 G08 \/ G09 S 直線軸のSプロファイル ポジティブ：スイッチを入れる ネガティブ：スイッチをオフにします 軸 3 ：Z、Zが2Dモードの場合 7 ： NS 8 ： NS 9 ：U 10 ：V 11 ：W T コマンド固有のパラメーター U 追加直線軸の目標位置 U V 追加直線軸の目標位置 V W 追加直線軸の目標位置 W X 目標位置のX座標 Y 目標位置のY座標 Z 目標位置のZ座標 " }, 
{ "title" : "3Dモード ", 
"url" : "_sm_cnc_din66025_3dmode.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 3Dモード ", 
"snippet" : "Gコード ： G15 、 G16 、 G17 、 G18 、 G19 Gコード 説明 G15 2Dモードに切り替えます。他のすべての要素に有効 G16 法線ベクトルI \/ J \/ Kを使用して、法平面で3D平面機能をアクティブにし、3Dモードに切り替えます。 他のすべての要素に有効 G17 X \/ Y平面で3D平面機能をアクティブにし、3Dモードに切り替えます 他のすべての要素に有効 G18 X \/ Z平面の3D平面機能をアクティブにします。 3Dモードに切り替えます 他のすべての要素に有効 G19 Y \/ Z平面の3D平面機能をアクティブにします。 3Dモードに切り替えます 他のすべての要素...", 
"body" : "Gコード ： G15 、 G16 、 G17 、 G18 、 G19 Gコード 説明 G15 2Dモードに切り替えます。他のすべての要素に有効 G16 法線ベクトルI \/ J \/ Kを使用して、法平面で3D平面機能をアクティブにし、3Dモードに切り替えます。 他のすべての要素に有効 G17 X \/ Y平面で3D平面機能をアクティブにし、3Dモードに切り替えます 他のすべての要素に有効 G18 X \/ Z平面の3D平面機能をアクティブにします。 3Dモードに切り替えます 他のすべての要素に有効 G19 Y \/ Z平面の3D平面機能をアクティブにします。 3Dモードに切り替えます 他のすべての要素に有効 3D モードでは、3 次元パス要素が使用されます。 3D 空間では、点を設定して 3D スプラインで接続できます。任意の空間平面に円弧を挿入することもできます。 X\/Y 座標のみを使用する 2.5D パス要素とは対照的に、パスの速度と加速度は X\/Y\/Z 座標の動きを参照します。 Z 軸は、X 軸および Y 軸と同じように扱われます。したがって、すべての移動は Z 方向に実装できます。 3Dモード このモードは、楕円、放物線、および2Dスプラインをサポートしていません。エラーメッセージが発行されます。 SMC_CheckVelocities Zコンポーネントをチェックします SMC_ToolCorr と SMC_AvoidLoop エラーを生成する 2.5Dと3Dの主な違い 2.5Dと3Dの主な違い 速度と加速度（F \/ E）： 3Dの場合：パスの速度と加速度を定義します。 2.5Dの場合：X \/ Y平面上のパスの投影の速度と加速度を定義します。 スプライン 3D：ジャークのない滑らかなZコンポーネント（G10） 2.5D：Z方向で平滑化されていない（G5） アーク 3D：空間内のすべての可能な平面で定義できます（G2 \/ G3とG16 \/ G17 \/ G18 \/ G19） 2.5D：X \/ Y平面に制限（G2 \/ G3） 例 3Dと2.5Dの速度比較 N0 G1 X1 Z100 F1 オブジェクトの長さにはZコンポーネントが含まれているため、3Dでは約100秒間のモーションが必要です。 長さ=（1 2 + 100 2 ） 1\/2 速度が1の場合、約100秒かかります。 Z成分の速度は約1です。 2.5Dでは、モーションは計算に約1秒、または長さ= 1を必要とします。Z方向の速度は約100です。 " }, 
{ "title" : "拡張前処理機能の有効化 ", 
"url" : "_sm_cnc_din66025_activating_extended_preprocessor_functions.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 拡張前処理機能の有効化 ", 
"snippet" : "Gコード ： G38 、 G39 関数 ：これらのコマンドは、拡張前処理機能をアクティブおよび非アクティブにします。 構文 G38 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> G39 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> Gコードワード 説明 <ビット> 0から31までの値。関数へのビットの割り当ては開発者に任されています。のようないくつかの機能ブロック SMC_SmoothMerge また SMC_SmoothBSpline 、入力があります wFeatureBit ...", 
"body" : "Gコード ： G38 、 G39 関数 ：これらのコマンドは、拡張前処理機能をアクティブおよび非アクティブにします。 構文 G38 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value>\nG39 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> Gコードワード 説明 <ビット> 0から31までの値。関数へのビットの割り当ては開発者に任されています。のようないくつかの機能ブロック SMC_SmoothMerge また SMC_SmoothBSpline 、入力があります wFeatureBit （初期値0）使用するビットを定義します。ビットは変数に保存されます SMC_GeoInfo.dwFeatureFlags 。 <Param1Value> 任意の値。値は配列に保存されます SMC_GeoInfo.aAdditionalParams : ARRAY[0..MAX_ADDITIONAL_PARAMS-1] OF LREAL 。 <Param1Value> <Param1Value> " }, 
{ "title" : "座標系のシフト、回転、およびスケーリング ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 座標系のシフト、回転、およびスケーリング ", 
"snippet" : "Gコード ： G53 、 G54 、 G55 、 G56 関数 ： Gコードコマンド G54 、 G55 、 そして G56 インタープリタ関数ブロックによって内部的に使用されるデコーダ座標系をシフト、回転、およびスケールする SMC_NCInterpreter 座標変換は、実行中にすべてのパス要素に対して計算されます。 SMC_NCInterpreter 関数ブロックインスタンス。 Gコードコマンド G53 デコーダーの座標系を元の位置、方向、およびスケーリング（マシンの座標系に対応）にリセットします。 位置、方向、またはスケーリングのみが異なる同じパス要素のGコードを再利用するために、デコ...", 
"body" : "Gコード ： G53 、 G54 、 G55 、 G56 関数 ： Gコードコマンド G54 、 G55 、 そして G56 インタープリタ関数ブロックによって内部的に使用されるデコーダ座標系をシフト、回転、およびスケールする SMC_NCInterpreter 座標変換は、実行中にすべてのパス要素に対して計算されます。 SMC_NCInterpreter 関数ブロックインスタンス。 Gコードコマンド G53 デコーダーの座標系を元の位置、方向、およびスケーリング（マシンの座標系に対応）にリセットします。 位置、方向、またはスケーリングのみが異なる同じパス要素のGコードを再利用するために、デコーダーの座標系をシフトおよび回転します。 デコーダー座標系の回転とスケーリングは、オンライン インタープリターでのみ機能します (CNC エディターでは機能しません)。 " }, 
{ "title" : "MCSおよびDCS座標系 ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_f644d63d98ef7863c0a864636e4c0bd6", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 座標系のシフト、回転、およびスケーリング \/ MCSおよびDCS座標系 ", 
"snippet" : "機械座標系（MCS）は、その位置と方向を決定する適用された運動学によって定義されます。 デコーダ座標系（DCS）はインタープリタ（ SMC_NCInterpreter ファンクションブロックインスタンス）。モーションコマンドのすべての座標情報は、この座標系で解釈されます。これは、移動の目標位置（ X\/Y\/Z ）、および円弧の中点（ I\/J\/K ）または、 G15\/G16\/G17\/G18\/G19 。 DCSはコマンドでプログラムされます G53\/G54\/G55\/G56 。マシンの座標系に対してDCSを回転、シフト、およびスケーリングできるため、Gコードファイル内の位置、方向、およびスケーリングを...", 
"body" : "機械座標系（MCS）は、その位置と方向を決定する適用された運動学によって定義されます。 デコーダ座標系（DCS）はインタープリタ（ SMC_NCInterpreter ファンクションブロックインスタンス）。モーションコマンドのすべての座標情報は、この座標系で解釈されます。これは、移動の目標位置（ X\/Y\/Z ）、および円弧の中点（ I\/J\/K ）または、 G15\/G16\/G17\/G18\/G19 。 DCSはコマンドでプログラムされます G53\/G54\/G55\/G56 。マシンの座標系に対してDCSを回転、シフト、およびスケーリングできるため、Gコードファイル内の位置、方向、およびスケーリングを何度でも調整できます。 DCSに関連するパス要素をプログラムします。たとえば、これは、異なる位置と方向にある同じパス要素にとって有利な場合があります。 次の画像は、シフト（左）と回転を伴うシフト（右）を示しています。 通訳者は、 eOriConv 入力するかどうか A\/B\/C 追加の軸または方向値として扱われます。パス要素の座標はそれに応じて変換されます。したがって、インタープリタ関数ブロックはアクティブな座標系を管理します。最初に、DCS がシフト、回転、またはスケーリングされていない場合、DCS は MCS に対応します。開始位置とターゲット位置、および円弧の平面は、生成された GeoInfo オブジェクトで常に MCS を基準として指定されます。 SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ADDAXES 方向の規則は指定されていません。 GコードワードA \/ B \/ Cの内容はシフト値として解釈されます。 SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ZYZ 方向の規則は、標準のY規則（Z、Y '、Z' '）です。 GコードワードA \/ B \/ Cの内容は、角度値として解釈されます。 SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ZYX 方向の規則は、ヨーピッチロールの規則（Z、Y '、X' '）です。 GコードワードA \/ B \/ Cの内容は、角度値として解釈されます。 SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.XYZ 方向の規則はXYZの規則（X、Y '、Z' '）です。 GコードワードA \/ B \/ Cの内容は、角度値として解釈されます。 " }, 
{ "title" : "コマンドG53、G54、G55、G56 ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_02170a739e1947dec0a864637ea0fc00", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 座標系のシフト、回転、およびスケーリング \/ コマンドG53、G54、G55、G56 ", 
"snippet" : "Gコード 説明 G53 デコーダーの座標系をリセットします DCSは、MCSと同じ位置と方向にリセットされます。 G54 絶対 DCSのシフト、回転、およびスケーリング 値はMCSを参照します。 オリエンテーションの慣例が ない 指定された （ SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ADDAXES ）の場合、コマンドは X\/Y\/Z\/A\/B\/C 軸に沿ってのみシフトし、追加のすべての直線軸 P\/Q\/U\/V\/W 上でシフトします。したがって、A\/B\/C 軸に沿ってシフトをプログラムすることもできます。 方向の規則が指定されている場合、コマン...", 
"body" : "Gコード 説明 G53 デコーダーの座標系をリセットします DCSは、MCSと同じ位置と方向にリセットされます。 G54 絶対 DCSのシフト、回転、およびスケーリング 値はMCSを参照します。 オリエンテーションの慣例が ない 指定された （ SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ADDAXES ）の場合、コマンドは X\/Y\/Z\/A\/B\/C 軸に沿ってのみシフトし、追加のすべての直線軸 P\/Q\/U\/V\/W 上でシフトします。したがって、A\/B\/C 軸に沿ってシフトをプログラムすることもできます。 方向の規則が指定されている場合、コマンドは軸X \/ Y \/ Zおよび追加の直線軸P \/ Q \/ U \/ V \/ Wに沿ってシフトします。さらに、座標軸が回転します。次に、方向規則は回転順序を提供し、GコードワードA \/ B \/ Cは回転角を度単位で提供します。 注: デコーダーは、-180° から +180° の範囲で方向回転を実行できます。この範囲外の角度を指定した場合、デコーダーは実行可能な範囲内になるように値を変換します。その後、デコーダーは座標軸を回転させます。たとえば、350° の角度の場合は -10° の回転が実行されます。 G55 相対的 DCSの現在の位置と方向へのシフト、回転、およびスケーリング したがって、値は現在のDCS原点を基準にしており、DCSの現在の座標軸の方向で解釈されます。機械の座標系に関して、追加のシフト\/回転が追加されます。 オリエンテーション規則が いいえ 指定すると、コマンドは軸X \/ Y \/ Z \/ A \/ B \/ Cに沿ってのみ相対シフトとすべての追加の直線軸P \/ Q \/ U \/ V \/ Wになります。したがって、シフトはA \/ B \/ C軸に沿ってプログラムすることもできます。 方向の規則が指定されている場合、コマンドにより、軸X \/ Y \/ Zおよび追加の直線軸P \/ Q \/ U \/ V \/ Wにも相対シフトが発生します。しかし何よりも、座標軸はさらに回転します。次に、方向規則は回転順序を提供し、GコードワードA \/ B \/ Cは回転角を提供します。 G56 デコーダー座標系の基準点をリセットします DCSの現在の方向、位置、およびスケーリングが参照として設定されます。 ヒント：基準点がX0 Y0 Z0 A0 B0 C0の場合、DCSは現在の位置と方向と同じように設定されます。 構文 G53\nG54 X Y Z A B C I J K P Q U V W\nG55 X Y Z A B C I J K P Q U V W\nG56 X Y Z A B C I J K P Q U V W Gコードワード 説明 X Y Z デコーダーの座標系がシフトされる値 A B C 入力が eOriConf = SMC_ORI_CONVENTION.ADDAXES で SMC_NCInterpreter の場合、値はそれぞれの追加軸がどれだけシフトされるかの単位で与えられます。したがって、このパラメータは、マシン座標系に対するデコーダ座標系の各軸のシフトを定義します。 もし、 eOriConf 入力は SMC_ORI_CONVENTION.ZYZ 、 SMC_ORI_CONVENTION.ZYX 、 または SMC_ORI_CONVENTION.XYZ で SMC_NCInterpreter 、方向規則が提供されます。この場合、ここで指定された値は自動的に度として解釈され、デコーダー座標系の軸がマシン座標系に対してどれだけ回転するかを決定します。したがって、方向規則に従ってメイン軸の回転を定義します。 注: DCS回転をプログラミングする場合、回転角度は常に A\/B\/C 3軸すべてについて回転角度が欠落していると、デコード時にエラーが発生します（ SMC_DEC_DCS_NOT_ALL_OF_ABC_GIVEN ）。 I 方向のスケーリング NS 例： 10 10倍に拡張する場合 J 方向のスケーリング Y 例： 10 10倍に拡張する場合 K 方向のスケーリング Z 例： 10 10倍に拡張する場合 P Q U V W デコーダー座標系の追加軸がシフトされる値 " }, 
{ "title" : "DCSのシフト ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_4557d91f9e1947dec0a864630016f87d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 座標系のシフト、回転、およびスケーリング \/ DCSのシフト ", 
"snippet" : "をセットする eOriConv の入力 SMC_NCInterpreter ファンクションブロックインスタンス SMC_ORI_CONVENTION.ADDAXES 。 DCSはシフトできます。回転はできません。 CNCパスをプログラムします。まず、DCSの位置シフトを指定します。 例： G54 X10 Y10 Z10 A30 B30 C30 DCSのX \/ Y \/ Z \/ A \/ B \/ C軸がずれています。 例 絶対オフセット N10 G0 X100 Y100 F100 N20 G54 X50 Y50 (Offset auf 50\/50) N30 G1 X0 Y0 (Fahrt nach ...", 
"body" : "をセットする eOriConv の入力 SMC_NCInterpreter ファンクションブロックインスタンス SMC_ORI_CONVENTION.ADDAXES 。 DCSはシフトできます。回転はできません。 CNCパスをプログラムします。まず、DCSの位置シフトを指定します。 例： G54 X10 Y10 Z10 A30 B30 C30 DCSのX \/ Y \/ Z \/ A \/ B \/ C軸がずれています。 例 絶対オフセット N10 G0 X100 Y100 F100\nN20 G54 X50 Y50 (Offset auf 50\/50)\nN30 G1 X0 Y0 (Fahrt nach 50\/50)\nN40 G54 X100 Y100 (Offset auf 100\/100)\nN50 G1 X0 Y0 (Fahrt nach 100\/100)\nN60 G53 (Offset auf 0)\nN70 G1 X0 Y0 (Fahrt nach 0\/0) オフセットとしての現在位置 N0 G0 X100 Y100 F100\nN10 G56 X0 Y0 (Aktuelle Position 100\/100 wird 0\/0)\nN20 G1 X10 (Fahrt nach 110\/100)\nN30 G56 X20 Y0 (Aktuelle Position 110\/100 wird 20\/0)\nN40 G1 X0 (Fahrt nach 90\/100) オフセットを値で調整 N0 G54 X10 Y20 Z30 U7 (Offset: X=10, Y=20, Z=30, U=7)\nN10 G55 X-10 U7 (Offset: X=0, Y=20, Z=30, U=14) 2つの位置にある同じパス要素 N05 G17\nN10 G54 X10 Y10 Z10\nN20 G01 X6.574 Y-10 Z-1.961 I8.287 J-0.000\nN30 G02 X-0.480 Y-10 Z0.008 I-3.527 J4.988E-05\nN040 G02 X3.418 Y-9.806 Z4.482 I1.949 J0.097\nN50 G55 X10 Y10 Z10\nN60 G01 X6.574 Y-10 Z-1.961 I8.287 J-0.000\nN70 G02 X-0.480 Y-10 Z0.008 I-3.527 J4.988E-05\nN80 G02 X3.418 Y-9.806 Z4.482 I1.949 J0.097 " }, 
{ "title" : "DCSのシフトと回転 ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_df6926f62eedd311c0a8646378b457e7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 座標系のシフト、回転、およびスケーリング \/ DCSのシフトと回転 ", 
"snippet" : "をセットする eOriConv の入力 SMC_NCInterpreter ファンクションブロックインスタンスを希望の方向規則（例えば、 SMC_ORI_CONVENTION.ZYZ ）。 DCSのX \/ Y \/ Z軸の方向規則と回転順序がプログラムされます。にとって SMC_ORI_CONVENTION.ZYZ 、回転順序はZY'Z ''であり、標準のYコンベンションに対応します。 注：入力がある限り eOriConv 値ではなく方向規則が含まれています SMC_ORI_CONVENTION.ADDAXES 、単語の値 A\/B\/C Gコードコマンドの回転の角度値として解釈されます G54\/G...", 
"body" : "をセットする eOriConv の入力 SMC_NCInterpreter ファンクションブロックインスタンスを希望の方向規則（例えば、 SMC_ORI_CONVENTION.ZYZ ）。 DCSのX \/ Y \/ Z軸の方向規則と回転順序がプログラムされます。にとって SMC_ORI_CONVENTION.ZYZ 、回転順序はZY'Z ''であり、標準のYコンベンションに対応します。 注：入力がある限り eOriConv 値ではなく方向規則が含まれています SMC_ORI_CONVENTION.ADDAXES 、単語の値 A\/B\/C Gコードコマンドの回転の角度値として解釈されます G54\/G55\/G56 。 CNCパスをプログラムします。まず、DCSの位置シフトと回転を指定します。 例： G54 X10 Y10 Z10 A30 B30 C30 言葉の価値 A\/B\/C 回転方向と角度を度単位で指定します。それに応じて座標系が回転します。言葉の価値 X\/Y\/Z シフトを定義します。 注: DCS回転をプログラミングする場合、回転角度は常に A\/B\/C 3軸すべてについて回転角度が欠落していると、デコード時にエラーが発生します（ SMC_DEC_DCS_NOT_ALL_OF_ABC_GIVEN ）。 もし、 eOriConv の入力 SMC_NCInterpreter 関数ブロックインスタンスには値が含まれています SMC_ORI_CONVENTION.ADDAXES の場合、DCSを回転させることはできません。 G54\/G55\/G56 追加のスプライン軸値として解釈されます。シフトが可能です。 例 オリエンテーション規則は、例では標準のY規則として定義されています（ eOriConv = SMC_ORI_CONVENTION.ZYZ ）。一般的に G54 ： X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W MCSで絶対値を提供します。 G55 ： X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W DCSの相対値を提供します。 G56 ： X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W DCSに絶対的な新しい値を提供します。 G54での絶対標定 N01 G54 X10 A30 B0 C0 G54 シフトと回転が発生します。位置と方向は、MCSに対して絶対的に提供されます。 G55との相対的な向き N01 G54 X10 A30 B0 C0 (Bezieht sich auf MCS)\nN02 G55 Y10 A0 B30 C0 (Bezieht sich auf das in 01 definierte DCS) G54 その結果、X方向に10単位シフトし、MCSに対して絶対的なZ軸を中心に30°回転します。ブロック０２において、ＤＣＳは、回転されたＹ軸の方向にさらに１０単位シフトされ、次に、回転されたＹ軸を中心にさらに３０°回転される。したがって、ブロック02の変換は、ブロック01の変換に関連しています。 G56での現在の方向に関する参照 N01 G01 X10 A10 B90 C10 (Orientierung ist A=10°, B=90°, C=10°)\nN02 G56 A0 B0 C0 (DCS wird auf X=10, A=10°, B=90°, C=10° gesetzt) G56 その結果、DCSの現在の方向（例のブロック01でプログラムされている）が参照として設定されます。 例：アーク N0 G17\nN0 G54 A0 B90 C0 選択した円形平面は、DCSを基準にして解釈されます。この例では、X \/ Y平面は次のように選択されています。 G17 次に、DCSがY軸を中心に90°回転します。次に、DCSで選択された平面は、前と同じようにX \/ Y平面です。これは、MCSのX \/ Z平面のそれに対応します。 と G17 、X \/ Y平面が選択されています。次に、DCSが90°回転します。これにより、X \/ Yプレーンが以前と同様にDCSでアクティブになります。これは、MCSのX \/ Y平面に対応します。 2.5Dモード（ G15 ) では、Z 軸を中心に回転することのみが許可されます。他の軸を中心に回転すると、デコーダーによってエラーが発生します ( SMC_DEC_DCS_2D_NOT_IN_XY_PLANE したがって、MCS の X\/Y 平面は常に 2.5D モードに設定されたままになります。 " }, 
{ "title" : "座標系のスケーリング ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_52b3763cadb811e79ffc84f8a2d3d270", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 座標系のシフト、回転、およびスケーリング \/ 座標系のスケーリング ", 
"snippet" : "不均等なスケーリングの後に回転がプログラムされている場合、クリッピングが発生する可能性があります。この場合、エラー SMC_DEC_ROTATION_AFFECTS_SCALING 発行されません。 3つのスケーリング係数をすべて指定するか、まったく指定しないでください。 絶対スケーリング 構文： G54 I<i> J<j> K<k> 座標系は、3つの空間方向に伸縮できます X\/Y\/Z 互いに独立して。各方向の係数を指定できます。 XをIに、YをJに、ZをKにスケーリング係数を指定します。スケーリング係数> 1が拡張されます。スケーリング係数<1は圧縮します。 10倍に拡張： N01 G01 ...", 
"body" : "不均等なスケーリングの後に回転がプログラムされている場合、クリッピングが発生する可能性があります。この場合、エラー SMC_DEC_ROTATION_AFFECTS_SCALING 発行されません。 3つのスケーリング係数をすべて指定するか、まったく指定しないでください。 絶対スケーリング 構文： G54 I<i> J<j> K<k> 座標系は、3つの空間方向に伸縮できます X\/Y\/Z 互いに独立して。各方向の係数を指定できます。 XをIに、YをJに、ZをKにスケーリング係数を指定します。スケーリング係数> 1が拡張されます。スケーリング係数<1は圧縮します。 10倍に拡張： N01 G01 X10\nN02 G54 A90 B0 C0 I10 J1 K1\nN03 G01 X10 Y20\nN04 G01 X5 Y10 すべてのターゲットポイントは、回転したX軸の方向に10倍延長されます。 次のコードは同じパスを生成します。 N01 G01 X10\nN02 G01 X-20 Y100\nN03 G01 X-10 Y50. IもJもKも指定されていない場合、以前に設定された値は変更されません。 N01 G54 I10 J1 K1\nN02 G54 X1\nN03 G01 X10 次のコードでも同じパスが実現されます。 N01 G01 X101 相対スケーリング 構文： G55 I<i> J<j> K<k> 1より大きい倍率が拡張されます。スケーリング係数<1は圧縮します。スケーリング係数が乗算されます。 100倍に拡張： N01 G54 I10 J1 K1\nN02 G55 I10 J1 K1\nN03 G01 X10 Y20\nN04 G01 X5 Y10 次のコードは同じスケーリングになります。 N01 G55 I100 J1 K1 円形スケーリング 円弧のスケーリングは、スケーリング後も要素が円弧（楕円ではない）である場合にのみ有効です。 有効なパスの結果： 3つの倍率がすべて同じ値の場合 円形平面がDCSの主平面の1つであり、対応する2つのスケール係数が同じ値である場合 " }, 
{ "title" : "座標系のミラーリング ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_adba25b098ef7863c0a8646324d700b4", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 座標系のシフト、回転、およびスケーリング \/ 座標系のミラーリング ", 
"snippet" : "負のスケーリング係数を使用した絶対スケーリング I 、 J 、 また K その結果、現在の座標系がミラーリングされます。 負のスケールファクター G54 A30 B0 C0 I-1 J1 K1...", 
"body" : "負のスケーリング係数を使用した絶対スケーリング I 、 J 、 また K その結果、現在の座標系がミラーリングされます。 負のスケールファクター G54 A30 B0 C0 I-1 J1 K1 " }, 
{ "title" : "モード ", 
"url" : "_sm_cnc_din66025_modi.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ モード ", 
"snippet" : "関数 ：これらのコマンドは、座標と軸の中点を絶対値として解釈するか、相対座標として解釈するかを決定します。 Gコード 説明 G90 座標（ X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ）は絶対値として解釈されます。 （これがデフォルト設定です。） G91 座標（ X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ）は、現在の位置を基準にした値として解釈されます。 G98 軸の中点（ I \/ J \/ K ）は絶対値として解釈されます。 G99 軸の中点（ I \/ J \/ K ）は、開始位置を基準にした値として解釈されます。...", 
"body" : "関数 ：これらのコマンドは、座標と軸の中点を絶対値として解釈するか、相対座標として解釈するかを決定します。 Gコード 説明 G90 座標（ X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ）は絶対値として解釈されます。 （これがデフォルト設定です。） G91 座標（ X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ）は、現在の位置を基準にした値として解釈されます。 G98 軸の中点（ I \/ J \/ K ）は絶対値として解釈されます。 G99 軸の中点（ I \/ J \/ K ）は、開始位置を基準にした値として解釈されます。 （これがデフォルト設定です。） 構文 G90\nG91\nG98\nG99 例 絶対値としての座標値 補間器は10\/10に移動し、次に100\/10に移動します。座標は絶対値として解釈されます。 N0 G90\nN10 G1 X10 Y10 F100 (Startposition)\nN20 G1 X100 (Nächste Position) 相対値としての座標値 補間器は10\/10に移動し、次に110\/10に移動します。座標は相対値として解釈されます。 N0 G91\nN10 G1 X10 Y10 F100\nN20 G1 X100 I \/ J \/ Kの絶対値としての座標値 半円の中点は150\/0です。座標は絶対値として解釈されます。 N00 G98\nN10 G92 X100 Y0 (Startposition)\nN20 G2 X200 Y0 I150 J0 F100 I \/ J \/ Kの相対値としての座標値 半円の中点は150\/0です。座標は相対値として解釈されます。 N00 G99\nN10 G92 X100 Y0 (Startposition)\nN20 G2 X200 Y0 I50 J0 F100 詳細については、以下を参照してください。 単一の追加軸をモジュロ軸として構成する（PA \/ PB \/…）" }, 
{ "title" : "滞留時間 ", 
"url" : "_sm_cnc_din66025_delay.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 滞留時間 ", 
"snippet" : "Gコード ： G4 関数 ：このコマンドにより、補間器は特定の時間現在の位置に留まります。 例 滞留時間 N0 G4 T1 補間器は1秒間一時停止します。...", 
"body" : "Gコード ： G4 関数 ：このコマンドにより、補間器は特定の時間現在の位置に留まります。 例 滞留時間 N0 G4 T1 補間器は1秒間一時停止します。 " }, 
{ "title" : "スイッチポイント（H機能） ", 
"url" : "_sm_cnc_din66025_hfunction.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ スイッチポイント（H機能） ", 
"snippet" : "関数 ：スイッチポイント機能またはH機能は、バイナリのパス依存スイッチをアクティブにします。最大3つのスイッチポイント（ MAX_SWITCHES ）パス要素ごとに処理できます。 構文 [G-Befehl] H O\/L 最初に、スイッチポイント番号H <number>が定義され、次にパス要素内のスイッチポイントの位置が絶対（L <position>ワード）または相対（O <position>ワード）として定義されます。 Gコードワード 説明 H {-} <番号> H関数の数 H番号が正の場合、それぞれのスイッチ機能がオンになります。 H数が負の場合、スイッチ機能はオフになります。 H番号はゼロ...", 
"body" : "関数 ：スイッチポイント機能またはH機能は、バイナリのパス依存スイッチをアクティブにします。最大3つのスイッチポイント（ MAX_SWITCHES ）パス要素ごとに処理できます。 構文 [G-Befehl] H O\/L 最初に、スイッチポイント番号H <number>が定義され、次にパス要素内のスイッチポイントの位置が絶対（L <position>ワード）または相対（O <position>ワード）として定義されます。 Gコードワード 説明 H {-} <番号> H関数の数 H番号が正の場合、それぞれのスイッチ機能がオンになります。 H数が負の場合、スイッチ機能はオフになります。 H番号はゼロ以外で、-32768〜32767の範囲です。 O <位置> パス要素内の相対位置[0…1] 0：要素の開始 1：終了 L <位置> L> 0：始点までの距離 L <0：終点までの距離 グラフ表示 グラフィカルエディタでは、マウスを使用してパスに沿ってスイッチポイントを移動できます。マウスをH機能の上に移動すると、H機能のH番号とともにツールチップが表示されます。 への影響 SMC_Interpolator ファンクションブロック 補間器は、最後に切り替えられたH番号を iLastSwitch 出力。 iLastSwitch H機能がオンのときは正です。 NS dwSwitches 出力はビットマスクです。ビット番号 i H機能（i + 1）が現在設定されているかどうかを示します。 H番号が1〜32の場合、対応するビットが補間器に設定されます。 dwSwitches 出力。 -1から-32の間の負の値は、ビットをリセットします。 NS iLastSwitch 値が-32〜32の範囲外であっても、出力には最後に実行されたスイッチポイントの番号が含まれます。 例 エレメントに対する位置でスイッチポイント2をオフにします スイッチポイント2は、エレメントの第1四半期の後、位置X = 40 \/ Y = 25でオフになります。 N90 G1 X20 Y20\nN100 G1 X100 Y40 H-2 O0.25 開始点と終了点を基準にした位置でスイッチポイント2のオンとオフを切り替えます スイッチポイント2は、パス要素の開始点から20単位後の位置X = 40でオンになります。スイッチポイント2は、エンドポイントの10単位前の位置X = 90でオフになります。 N90 G1 X20\nN100 G1 X100 H2 L20 H-2 L-10 " }, 
{ "title" : "M機能 ", 
"url" : "_sm_cnc_din66025_mfunction.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ M機能 ", 
"snippet" : "関数 ：M関数または追加関数は、Gコードの補間中にアクションを開始します。 補間器は速度0に減速し、キューに入れられたM関数の番号を出力に送信します wM 、で確認を待ちます bAcknM 再び加速する前に。スイッチポイントとは対照的に、プログラムは、補間器に入力を設定してM機能が確認されるまで、現在の位置に留まります。 もしも SMC_PreAcknowledgeM が実行されると、機能ブロックはM機能を早期に確認します。機能ブロックが時間どおりに実行された場合、補間器は停止せず、プログラムはM命令が存在しないかのように続行します。 M関数はアプリケーションによって実装され、システムによって...", 
"body" : "関数 ：M関数または追加関数は、Gコードの補間中にアクションを開始します。 補間器は速度0に減速し、キューに入れられたM関数の番号を出力に送信します wM 、で確認を待ちます bAcknM 再び加速する前に。スイッチポイントとは対照的に、プログラムは、補間器に入力を設定してM機能が確認されるまで、現在の位置に留まります。 もしも SMC_PreAcknowledgeM が実行されると、機能ブロックはM機能を早期に確認します。機能ブロックが時間どおりに実行された場合、補間器は停止せず、プログラムはM命令が存在しないかのように続行します。 M関数はアプリケーションによって実装され、システムによって定義されません。 構文 M K L O Gコードワード 説明 M M関数の数、M> 0 注：番号65533〜65535は、内部機能用に予約されています。 K 数値パラメータ（ LREAL ） L 数値パラメータ（ LREAL ） O O $ var $がタイプの変数である参照 SMC_M_PARAMETERS 他のパラメータが含まれています。アプリケーションでは、変数のパラメーター値は、関数を使用して実行時に読み取られます。 SMC_GetMParameters 。さらに、すべてのパラメータはデコード時に評価され、データ構造に保存されます SMC_GEOINFO バッファの SMC_OUTQUEUE 。原則として、これは補間器でM関数を実行する前に一度に発生します。 変数が使用された機能ブロックによって見つけられるように (例えば SMC_ReadNCFile2 ) デコード中に、その SMC_VARLIST タイプと SMC_VARTYPE.SMC_TYPE_USERDEF . 例 パラメータ付きのM M機能10が起動します。 N90のプログラム実行の場合、システムは確認が可能になるまで待機します。 N90 M10 K100.7 追加パラメータ付きのM M機能10が起動します。ユーザー定義のデータ構造 g_myMParams （データ・タイプ SMC_M_PARAMETER ）はで参照されます O $ var $ 。 g_myMParams 追加のパラメータが含まれています。 K、Lの値、およびからのパラメータ g_myMParams M機能のパス停止時に読み取ることができます。これは、機能ブロックのインスタンスを呼び出すことによって行われます。 SMC_GetMParameters 。 N150 M13 O$g_myMParams$ " }, 
{ "title" : "補間器とのタイミング同期 ", 
"url" : "_sm_cnc_din66025_time_synchronisation_with_interpolator.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 補間器とのタイミング同期 ", 
"snippet" : "Gコード ： G75 関数 ：このコマンドは、補間器が前のすべてのオブジェクトを通過するまで、デコーダーの機能ブロックがGコードを処理しないようにします。補間器が到達したとき G75 、すべてのキューが空であり、NCDecoderとすべての前処理機能ブロックが実行を継続します。 この関数は、変数を使用する場合に役立ちます。対応する行が処理されると、デコーダーが変数を置き換えます。ただし、補間器による実行は、キューメカニズムに従って指定された時間の後に行われます。あなたが使用することができます G75 変数の評価とその後の補間器による処理を待機して同期するため。 構文 G75 例 N10 G1 ...", 
"body" : "Gコード ： G75 関数 ：このコマンドは、補間器が前のすべてのオブジェクトを通過するまで、デコーダーの機能ブロックがGコードを処理しないようにします。補間器が到達したとき G75 、すべてのキューが空であり、NCDecoderとすべての前処理機能ブロックが実行を継続します。 この関数は、変数を使用する場合に役立ちます。対応する行が処理されると、デコーダーが変数を置き換えます。ただし、補間器による実行は、キューメカニズムに従って指定された時間の後に行われます。あなたが使用することができます G75 変数の評価とその後の補間器による処理を待機して同期するため。 構文 G75 例 N10 G1 X100\nN20 G75\nN30 G1 Y$g_y$ 変数 g_y は要素G1で使用可能であり、事前に検出されません。もしも G75 が挿入されていない場合、 NCDecoder 値が検出される直前に行30を処理します。 G75 CNCエディターまたはCNCエディターが生成するパスには影響しません SMC_OutQueue 。 " }, 
{ "title" : "ジャンプ ", 
"url" : "_sm_cnc_din66025_jump.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ ジャンプ ", 
"snippet" : "Gコード ：G20 関数 ：コマンドは条件付きジャンプを実行します。 構文 G20 L K Gコードワード 説明 L ジャンプターゲット： 定義された行番号（例： L20 ） ジャンプラベル ジャンプは疑問符とインデックスで定義されます（例： L?4 ）。ジャンプターゲット自体のコマンドは、感嘆符と対応するインデックスによって識別されます（例： L!4 ）。ジャンプターゲットは、任意のGコードコマンドにアタッチできます。 このジャンプは、ターゲットラインが不明な場合に自動生成されたCNCプログラムに使用されます。 ジャンプラベルへの不明なターゲットを使用したジャンプは、オンラインデコーダーでの...", 
"body" : "Gコード ：G20 関数 ：コマンドは条件付きジャンプを実行します。 構文 G20 L K Gコードワード 説明 L ジャンプターゲット： 定義された行番号（例： L20 ） ジャンプラベル ジャンプは疑問符とインデックスで定義されます（例： L?4 ）。ジャンプターゲット自体のコマンドは、感嘆符と対応するインデックスによって識別されます（例： L!4 ）。ジャンプターゲットは、任意のGコードコマンドにアタッチできます。 このジャンプは、ターゲットラインが不明な場合に自動生成されたCNCプログラムに使用されます。 ジャンプラベルへの不明なターゲットを使用したジャンプは、オンラインデコーダーでのみ機能します（CNCエディターでは機能しません）。 要件：ジャンプラベルのある行は、jumpコマンドのある行の後に配置する必要があります。 「ジャンプバック」はできません。 「ターゲットライン」が定義されていない場合、ジャンプコマンドに続くコマンドは実行されません。 K 状態 K <> 0の場合、ジャンプが実行されます。 Kが定義されていない場合は、内部デコーダー変数が使用されます。 内部デコーダー変数の値は、次のように定義できます。 変数の値の変更 コマンド。この内部変数のデフォルト値は -1 。 例：内部カウンター= 0になるまでジャンプを実行します 10本の線は相対モードでリンクされています。これにより、ラインが100\/100に移動します。 N00 G36 D10 (set counter to 10)\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN30 G37 D-1 (decrement counter)\nN40 G20 L20 (jump, if counter != 0) 例：デコード時のジャンプ状態の評価 要件：変数の動作 bvar アプリケーションでプログラムされています。 X軸が位置15を超える場合は、 bvar FALSE が設定されています。 （（ bVar 最初はに設定されています TRUE 。） 最初のプログラムサイクルでは、X位置は10で、プログラムは20行目にジャンプします。条件の評価はデコード時に行われ、補間器がまだ開始されていないか、処理でビジーであるため、ループは継続的に実行されます。バッファの先頭にあるオブジェクトの数。この条件が満たされ、バッファがいっぱいになり、補間器が処理を開始するのに十分なオブジェクトが生成された後でのみ、デコーダはループからジャンプします。 2回目の実行では、X軸はまだ位置20にありません。条件が満たされておらず、 bVar に設定されていません FALSE IECコードで。 N0 G92 X0 Y0\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN30 G20 L20 K$bvar$ (jump, if counter != 0) 例：タイミング同期を挿入する G75は、補間器のタイミング同期を実行します。 G75は、補間器とメカニックがそれぞれの位置に到達するまで、デコーダーの処理を一時停止します。 N0 G92 X0 Y0\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN25 G75\nN30 G20 L20 K$x$ (jump, if counter != 0) 詳細については、以下を参照してください。 補間器とのタイミング同期例：ジャンプラベルにジャンプ 注：ジャンプラベルへのジャンプは、オンラインデコーダーでのみ機能します（CNCエディターでは機能しません）。 N0 G16 F100 E100 E-100\nN10 G20 L?4 \/\/unconditional jump to the unknown target with index 4\nN15 G20 L60\nN20 G1 X1\nN30 G1 X1 L!5 \/\/resolution unknown jump target with index 5\nN40 G1 Z1 L!4 \/\/resolution unknown jump target with index 4\nN50 G20 L15\nN55 G1 Y1\nN60 G0 X0 Y0 Z0 " }, 
{ "title" : "アーク ", 
"url" : "_sm_cnc_din66025_arc.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ アーク ", 
"snippet" : "Gコード ： G2 、 G3 関数 ：このコマンドは、円弧を現在の位置から円形のパスに沿って目標位置まで補間します。 G2 時計回りに動き、 G3 反時計回りに移動します。 アークは次のように定義されます。 半径法 ターゲット座標+半径：ターゲット座標はX \/ Y \/ Zで定義されます。曲線は半径Rで定義されます。 中点法 ターゲット座標+中点座標：ターゲット座標はX \/ Y \/ Zで定義されます。曲線は、中点座標I \/ J \/ Kによって定義されます。中点座標は、開始点と終了点の垂直二等分線上にあります。そうでない場合は、中点座標が自動的に修正されます。偏差は10％を超えてはなりません。 開...", 
"body" : "Gコード ： G2 、 G3 関数 ：このコマンドは、円弧を現在の位置から円形のパスに沿って目標位置まで補間します。 G2 時計回りに動き、 G3 反時計回りに移動します。 アークは次のように定義されます。 半径法 ターゲット座標+半径：ターゲット座標はX \/ Y \/ Zで定義されます。曲線は半径Rで定義されます。 中点法 ターゲット座標+中点座標：ターゲット座標はX \/ Y \/ Zで定義されます。曲線は、中点座標I \/ J \/ Kによって定義されます。中点座標は、開始点と終了点の垂直二等分線上にあります。そうでない場合は、中点座標が自動的に修正されます。偏差は10％を超えてはなりません。 開き角法 開き角+中点座標：Tで定義された開き角とI \/ J \/ Kの中点座標。目標位置は自動的に計算されます。 パラメータに一貫性がないと、円ではなく線が移動します。例：半径が開始点とターゲットの間の距離の半分未満の場合、偏差は修正できません。これは、開始位置と目標位置までの定義された中点の距離が異なる場合にも当てはまります。 構文 G2 X Y Z R A B C P Q U V W F E H L\/O D S\nG2 X Y Z I J K A B C P Q U V W F E H L\/O D S\nG2 I J K T A B C P Q U V W F E H L\/O D S\nG3 X Y Z R A B C P Q U V W F E H L\/O D S\nG3 X Y Z I J K A B C P Q U V W F E H L\/O D S\nG3 I J K T A B C P Q U V W F E H L\/O D S Gコードワード 説明 X Y Z デカルト軸の目標位置 R 円の半径 I J K 円の中点座標 T 開き角度（度単位） A B C P Q U V W 追加軸の目標位置 F E 経路速度、経路加減速 H L\/O スイッチポイント D 工具径 S Sプロファイル グラフ表示 ：円弧は黒い端点で表されます。要素を選択すると、終点を移動できます。 3Dモードでのアーク 3Dモードでは、システムはG15-G19によって定義された補間平面によって円弧を定義します。 例 X \/ Z平面に1つの半円とX \/ Y平面に1つの半円 N10 G1 X100 Y100\nN15 G18\nN20 G2 X200 R50\nN25 G17\nN30 G3 X100 R50 " }, 
{ "title" : "半径法 ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_535707857cba3404c0a86463692656db", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ アーク \/ 半径法 ", 
"snippet" : "180°未満の円弧を生成するには、半径法を使用できます。半径法は2つの円弧に有効です。 1つは半円よりも小さく、もう1つは半円よりも大きいです。システムは常に小さい方の円弧を使用します。 例 半円 N10 G1 X100 Y100 F100 N20 G2 X200 Y100 R50 開き角が180°を超えるアークを生成するには、I \/ J \/ Kを使用した中点法を使用します。半径の方法は、円の始点と終点が同じである場合を除いて、独特です。これは、ヌル円または完全な円のいずれかを定義します。この場合、システムは完全な円を挿入します。...", 
"body" : "180°未満の円弧を生成するには、半径法を使用できます。半径法は2つの円弧に有効です。 1つは半円よりも小さく、もう1つは半円よりも大きいです。システムは常に小さい方の円弧を使用します。 例 半円 N10 G1 X100 Y100 F100\nN20 G2 X200 Y100 R50 開き角が180°を超えるアークを生成するには、I \/ J \/ Kを使用した中点法を使用します。半径の方法は、円の始点と終点が同じである場合を除いて、独特です。これは、ヌル円または完全な円のいずれかを定義します。この場合、システムは完全な円を挿入します。 " }, 
{ "title" : "中点法 ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_7dc8851b7cba3404c0a864637c8195be", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ アーク \/ 中点法 ", 
"snippet" : "中点法を使用する場合は、座標I \/ J \/ Kが相対座標か絶対座標かを区別します。もしも I 、 J 、 と K が正しく指定されていない場合、アークは不可能であり、システムはそれをラインに置き換えます。正しければ、中点と始点または終点の間の距離は同じです。 例 半径法と同じ半円。相対中点で指定 N10 G1 X100 Y100 F100 N15 G99 N20 G2 X200 Y100 I50 J0 半径法と同じ半円。絶対中点で指定 N10 G1 X100 Y100 F100 N15 G98 N20 G2 X200 Y100 I150 J100...", 
"body" : "中点法を使用する場合は、座標I \/ J \/ Kが相対座標か絶対座標かを区別します。もしも I 、 J 、 と K が正しく指定されていない場合、アークは不可能であり、システムはそれをラインに置き換えます。正しければ、中点と始点または終点の間の距離は同じです。 例 半径法と同じ半円。相対中点で指定 N10 G1 X100 Y100 F100\nN15 G99\nN20 G2 X200 Y100 I50 J0 半径法と同じ半円。絶対中点で指定 N10 G1 X100 Y100 F100\nN15 G98\nN20 G2 X200 Y100 I150 J100 " }, 
{ "title" : "開き角法 ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_955d99e37cba3404c0a864634d5c784c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ アーク \/ 開き角法 ", 
"snippet" : "開き角Tで円を定義すると、最大3つの完全な円が許可されます（T≤1080）。 開き角法は、180°を超える円弧に適しています。 例 半径法と同じ半円。開き角度で指定 N10 G1 X100 Y100 N15 G99 N20 G2 I50 J0 T180 らせん（2つの完全な円） N10 G1 X100 Y100 N15 G99 N20 G2 I50 J0 T720...", 
"body" : "開き角Tで円を定義すると、最大3つの完全な円が許可されます（T≤1080）。 開き角法は、180°を超える円弧に適しています。 例 半径法と同じ半円。開き角度で指定 N10 G1 X100 Y100\nN15 G99\nN20 G2 I50 J0 T180 らせん（2つの完全な円） N10 G1 X100 Y100\nN15 G99\nN20 G2 I50 J0 T720 " }, 
{ "title" : "楕円 ", 
"url" : "_sm_cnc_din66025_ellipse.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 楕円 ", 
"snippet" : "Gコード ： G8 、 G9 関数 ：このコマンドは、ターゲット座標X \/ Y、楕円の中点I \/ J、楕円の主軸方向K、および主軸と副軸の間の長さ比Rを通る楕円円弧を指定します。 構文 G8 X Y Z R I J K A B C P Q U V W F E H L\/O D S G9 X Y Z R I J K A B C P Q U V W F E H L\/O D S Gコードワード 説明 X Y Z デカルト軸の目標位置 R 一次軸と二次軸の間の長さ比R。 範囲: 0 < R <= 1 R は、楕円弧が主軸の端点、中点、傾きによって一意に定義されない場合にのみ使用されます。これは、両方の端...", 
"body" : "Gコード ： G8 、 G9 関数 ：このコマンドは、ターゲット座標X \/ Y、楕円の中点I \/ J、楕円の主軸方向K、および主軸と副軸の間の長さ比Rを通る楕円円弧を指定します。 構文 G8 X Y Z R I J K A B C P Q U V W F E H L\/O D S\nG9 X Y Z R I J K A B C P Q U V W F E H L\/O D S Gコードワード 説明 X Y Z デカルト軸の目標位置 R 一次軸と二次軸の間の長さ比R。 範囲: 0 < R <= 1 R は、楕円弧が主軸の端点、中点、傾きによって一意に定義されない場合にのみ使用されます。これは、両方の端点から主軸までの距離が同じ場合です。その場合、両方の端点から副軸までの距離が同じでなければなりません。そうでない場合、これらの点を通る楕円は存在せず、システムは楕円を線に置き換えます I J 中点 K 楕円の主軸の方向（度単位） 0：X軸方向 90：Y軸方向 -90：Y軸の反対方向 A B C P Q U V W 追加軸の目標位置 F E 経路速度、経路加減速 H L\/O スイッチポイント D 工具径 S Sプロファイル 楕円は2.5Dオブジェクトです。これは、楕円が常にX \/ Y平面に属することを意味します。他の平面の楕円はサポートされていません。 例 N10 G0 X100 Y100 F100\nN15 G98\nN20 G8 X200 Y100 I150 J100 K45 R0.5 " }, 
{ "title" : "線形運動 ", 
"url" : "_sm_cnc_din66025_line.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 線形運動 ", 
"snippet" : "Gコード ： G1 関数 ：この位置決めコマンドは、ライン補間を実行します。ライン補間は、補間ポイントを現在の位置からライン上の定義されたターゲット座標に移動します。すべての軸が同時にそこに到着します。線の説明には、ターゲット座標（X \/ Y \/ Z）を定義する必要があります。 空間内の動きに加えて、デカルト座標と同時に到達する追加の軸A \/ B \/ C \/ P \/ Q \/ U \/ V \/ Wの目標位置を指定できます。 2つの連続する同一の位置では、常にこの位置で移動が停止します。停止は、後続のパスが着実に接続され、停止せずに移動できる場合にも発生します。 構文 G1 X Y Z A B C ...", 
"body" : "Gコード ： G1 関数 ：この位置決めコマンドは、ライン補間を実行します。ライン補間は、補間ポイントを現在の位置からライン上の定義されたターゲット座標に移動します。すべての軸が同時にそこに到着します。線の説明には、ターゲット座標（X \/ Y \/ Z）を定義する必要があります。 空間内の動きに加えて、デカルト座標と同時に到達する追加の軸A \/ B \/ C \/ P \/ Q \/ U \/ V \/ Wの目標位置を指定できます。 2つの連続する同一の位置では、常にこの位置で移動が停止します。停止は、後続のパスが着実に接続され、停止せずに移動できる場合にも発生します。 構文 G1 X Y Z A B C P Q U V W F E H L\/O D S Gコードワード 説明 X Y Z デカルト軸の目標位置 A B C P Q U V W 追加軸の目標位置 F E 経路速度、経路加減速 H L\/O スイッチポイント D 工具径 S Sプロファイル 例 線形補間 工具は開始位置0\/0\/0（プリセット）に配置され、速度1、加速度10、減速20で目標位置1\/2\/3まで直線で移動します。同時に、方向軸Aは180度移動します。 N010 G01 X1 Y2 Z3 A180 F1 E10 E-20 開始位置 開始位置50\/50\/50、フィード100で50\/50\/50から64\/30\/0への線形補間 N000 G92 X50 Y50 Z50 F100\nN010 G01 X64 Y30 Z0 " }, 
{ "title" : "放物線 ", 
"url" : "_sm_cnc_din66025_parabel.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 放物線 ", 
"snippet" : "Gコード ： G6 関数 ：このコマンドは、終点X \/ Y \/ Zと頂点I \/ Jの座標によって定義される放物線を補間します。頂点は、要素の接線が始点と終点の接続線に平行になる点です。 放物線は、常にX \/ Y平面にある2.5Dオブジェクトです。他の平面の放物線はサポートされていません。 構文 G6 X Y Z I J A B C P Q U V W F E H L\/O D S Gコードワード 説明 X Y Z デカルト軸の目標位置 I J 放物線の頂点 A B C P Q U V W 追加軸の目標位置 F E 経路速度、経路加減速 H L\/O H関数 D 工具径 S Sプロファイル 例 N0...", 
"body" : "Gコード ： G6 関数 ：このコマンドは、終点X \/ Y \/ Zと頂点I \/ Jの座標によって定義される放物線を補間します。頂点は、要素の接線が始点と終点の接続線に平行になる点です。 放物線は、常にX \/ Y平面にある2.5Dオブジェクトです。他の平面の放物線はサポートされていません。 構文 G6 X Y Z I J A B C P Q U V W F E H L\/O D S Gコードワード 説明 X Y Z デカルト軸の目標位置 I J 放物線の頂点 A B C P Q U V W 追加軸の目標位置 F E 経路速度、経路加減速 H L\/O H関数 D 工具径 S Sプロファイル 例 N010 G00 X100 Y200 Z0 F100\nN020 G98\nN030 G06 X-100 Y200 Z00 I0 J0 " }, 
{ "title" : "ポジショニング ", 
"url" : "_sm_cnc_din66025_positioning.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ ポジショニング ", 
"snippet" : "Gコード ： G0 、 G92 関数 ：これらのコマンドはツールを配置します。 G0 は、定義された位置への直線上の高速位置決めを指令します (通常はツール操作なし)。 G92はすぐに位置を設定します。その結果、座標軸でもジャンプが実行されます。もし SMC_ControlAxisByPos.bAvoidGaps:=TRUE が設定されている場合、ジャンプは実行されません。代わりに、すべての軸が個別に、最短距離でターゲット位置に移動します。パスの先頭に G92 を挿入して開始位置を設定できます 一連のG92コマンドでは、最後のコマンドが最初に実行されます。前のものはスキップされます。同一座標の...", 
"body" : "Gコード ： G0 、 G92 関数 ：これらのコマンドはツールを配置します。 G0 は、定義された位置への直線上の高速位置決めを指令します (通常はツール操作なし)。 G92はすぐに位置を設定します。その結果、座標軸でもジャンプが実行されます。もし SMC_ControlAxisByPos.bAvoidGaps:=TRUE が設定されている場合、ジャンプは実行されません。代わりに、すべての軸が個別に、最短距離でターゲット位置に移動します。パスの先頭に G92 を挿入して開始位置を設定できます 一連のG92コマンドでは、最後のコマンドが最初に実行されます。前のものはスキップされます。同一座標のG1ブロックを挿入すると、ジャンプが1サイクル実行されます。これは、ジャンプコマンドの位置間のパスが重要ではないが、指定された位置をできるだけ速く移動する必要がある場合に有利です。 NS SMC_ControlAxisByPos* 機能ブロックは、指定された値へのジャンプを検出し、補間器を一時停止し、各軸を可能な限り高速に個別に補間します。 2つの連続する同一の位置では、常にこの位置で移動が停止します。停止は、後続のパスが着実に接続され、停止せずに移動できる場合にも発生します。 詳細については、次のライブラリのドキュメントを参照してください。 Direct Axis Control 構文 G0 X Y Z A B C P Q U V W F FF E EF H L\/O S\nG92 X Y Z A B C P Q U V W H L\/O Gコードワード 説明 X Y Z デカルト軸の目標位置 A B C P Q U V W 追加軸の目標位置 E パスの加速\/減速 EF G0モーションの場合のみパスの加速\/減速。がEF <> 0に設定されている場合、Eで定義されている値はG0の動きでは考慮されません。 F 経路速度 FF G0運動にのみ使用される速度。がFF <> 0に設定されている場合、Fで定義されている値はG0の動きでは考慮されません。 H L\/O H関数 S Sプロファイル グラフ表示 グラフィカルエディタでは、G0コマンドは緑色の線で表されます。 G92コマンドは直接表されません。後続の要素の開始点を移動するだけです。位置決めコマンドは、CNCテキストエディタまたは表形式エディタにのみ挿入できます。それらはグラフィカルエディタで移動できます。 例 定義された送りによる線形補間による位置決め N0 G92 X10 Y10 Sets the start position at 10\/10\nN10 G1 X20 F10 Linear interpolation to 20\/10 with feed 10\nN20 G0 Y20 F100 Linear positioning to 20\/20 with feed 100 さまざまなポジショニングモード N0 G92 X100 Y100 F100 Sets the position at 100\/100\nN10 G1 X100 Y100 Saves the output of this position for one cycle\nN20 G92 X50 Y100 Sets the position suddenly to 50\/100 定義されたパス速度でのポジショニング N1 G0 X1000 Y0 FF1000 EF10000 EF-10000 Positioning with velocity 1000\nN2 G1 Y100 F100 E100 E-100 Interpolating positioning with velocity 100\nN3 G0 X0 Y0 Positioning with velocity 1000\nN4 G0 X1000 FF0 EF0 Positioning with velocity 100 because FF and FE are reset; thus the values in F and E are used. " }, 
{ "title" : "スプライン ", 
"url" : "_sm_cnc_din66025_spline.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ スプライン ", 
"snippet" : "Gコード ： G5 、 G10 関数 ：このコマンドは、前のパス要素から次のパス要素への遷移が途切れることなく互いにマージされるように、パス要素をスプラインで補間します。同時に、前のパス要素の終了接線がスプラインの開始接線と一致するように、システムからのスプラインセグメントが計算されます。同様に、スプラインの終了接線は後続のパス要素と一致します。 関数 : コマンドは、指定された位置にスプライン セグメントを作成します。前のパス要素から次のパス要素への遷移は、位置と接線が連続しています。 構文 G5 X Y Z A B C P Q U V W F E H L\/O D S G10 X Y Z A...", 
"body" : "Gコード ： G5 、 G10 関数 ：このコマンドは、前のパス要素から次のパス要素への遷移が途切れることなく互いにマージされるように、パス要素をスプラインで補間します。同時に、前のパス要素の終了接線がスプラインの開始接線と一致するように、システムからのスプラインセグメントが計算されます。同様に、スプラインの終了接線は後続のパス要素と一致します。 関数 : コマンドは、指定された位置にスプライン セグメントを作成します。前のパス要素から次のパス要素への遷移は、位置と接線が連続しています。 構文 G5 X Y Z A B C P Q U V W F E H L\/O D S\nG10 X Y Z A B C P Q U V W F E H L\/O D S Gコードワード 説明 X Y Z デカルト軸の目標位置 A B C P Q U V W 追加軸の目標位置 F E 経路速度、経路加減速 H L\/O スイッチポイント D 工具径 S Sプロファイル 複数の連続するスプライン セグメントは次のように接続されます。 接線を開始 ツール操作のあるパス要素が存在する場合（例：G1、G2、G3、G8、G9）、パス要素の終了接線がスプラインの開始接線として使用されます。 ツール操作で使用できるパス要素がない場合（G0、G92、Mなど）、開始点と最初のスプライン点の間の接続線が開始接線として使用されます。 スプラインの真ん中で接線 隣接するポイントが接続されます。ポイントの接線は、この接続線（緑色の線）に平行です。 接線の終了 ツール操作を伴うパス要素が存在する場合 (例: G1、G2、G3、G8、G9)、パス要素の開始接線がスプラインの終了接線として使用されます。 ツール操作で使用できるパス要素がない場合（たとえば、G0、G92、M）、終点と最初のスプライン点の間の接続線が終点の接線として使用されます。 例 スプラインが丸みを帯びた階段プロファイル N0 G0 X0 Y0 Z0 F100 (Startposition)\nN10 G5 X20 Y0\nN20 G5 X20 Y20\nN30 G5 X40 Y20\nN40 G5 X40 Y40 ダブルスプラインで丸みを帯びたプロファイル N0 G0 X0 Y0 F100 (Startposition)\nN5 G1 X5 Y0\nN10 G5 X20 Y0\nN20 G5 X20 Y20\nN21 G5 X20 Y20\nN30 G5 X40 Y20\nN40 G5 X40 Y40\nN45 G1 X0 Y40 X20Y20のスプライン点は2回存在します。このようにして、スプラインは中断され、再起動されます。これは、この時点での接線の定義方法によって決定されます。始点と終点は、前後の線分の開始接線によって定義されます。 " }, 
{ "title" : "前処理 ", 
"url" : "_sm_cnc_din66025_preprocessor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 前処理 ", 
"snippet" : "Gコード ：G40、G41、G42、G43、G50、G51、G52、G60、G61、G70、G71 関数 ：コマンドは、次のような前処理モジュールをアクティブにします SMC_SmoothPath 、 SMC_RoundPath 、 SMC_AvoidLoop 、 SMC_ToolCorr 、 SMC_ToolLengthCorr 、 と SMC_ToolRadiusCorr 。 の場合 前処理されたパスを表示する オプションを選択すると、編集したパスがグラフィカルエディタに表示されます。 構文 G40 G41 D G42 D G50 G51 D G52 D G60 G61 Gコードワード 説...", 
"body" : "Gコード ：G40、G41、G42、G43、G50、G51、G52、G60、G61、G70、G71 関数 ：コマンドは、次のような前処理モジュールをアクティブにします SMC_SmoothPath 、 SMC_RoundPath 、 SMC_AvoidLoop 、 SMC_ToolCorr 、 SMC_ToolLengthCorr 、 と SMC_ToolRadiusCorr 。 の場合 前処理されたパスを表示する オプションを選択すると、編集したパスがグラフィカルエディタに表示されます。 構文 G40\nG41 D\nG42 D\nG50\nG51 D\nG52 D\nG60\nG61 Gコードワード 説明 D の工具半径またはオーバーレイ半径 G51\/G52 。 4.18.0.0より前のバージョンの場合：角度の丸め\/スムージング（ G51\/G52 ) および工具半径補正 ( G41\/G42 ) はいずれの前処理も G コードの各 D ワードを解釈するため、相互に影響し合う可能性があります。たとえば、角度の丸めが D=5 で始まるときに radius=1 の工具半径補正が有効な場合、結果として工具半径の修正でも半径 5 バージョン 4.18.0.0 以降:角度の丸め\/スムージング ( G51\/G52 ) および工具半径補正 ( G41\/G42 ）互いに影響を与えずに同時に使用できます。これには以下の動作が当てはまります。 工具半径補正用 ( G41\/G42 ): デフォルトでは、「ツール」の半径は SMC_ToolRadiusCorr は 0 です。G ワードの後に D ワードを指定した場合 G41\/G42 次に、「ツール」半径が調整され、ファンクションブロックによって考慮されます。値が指定されていない場合は、現在設定されている「ツール」半径が使用されます。 角丸め\/スムージング用 ( G51\/G52 ): デフォルトでは、「スムーズ」半径は以下で使用されます SMC_Round\/SmoothPath は 0 です。G ワードの後に D ワードが指定された場合 (以下を除く) G36\/G37\/G40\/G41\/G42 ) または単独で (たとえば、 N00 D5 ) とすると、これが現在の「スムーズ」半径に影響し、次の計算で考慮されます SMC_Round\/SmoothPath ファンクションブロック。 工具補正用コマンド Gコード 説明 G40 工具径補正終了 G41 ワークの左側にある工具径補正の開始 G42 ワークの右側の工具径補正の開始 G43 工具長補正の開始。 修正する工具オフセットはパラメータで指定します I, J K （にとって X, Y, Z ）。パラメータをゼロに設定すると、工具長補正が無効になります。アクティブ化または非アクティブ化した後、ランプインまたはランプアウトが実行されます。 詳細については、以下を参照してください。 SMC_ToolLengthCorr 注：ツールの長さは、パスを壊す可能性があるため、アクティブなツール半径補正中に変更しないでください。 工具長補正（G43）は、オンラインデコーダーでのみ機能します（CNCエディターでは機能しません）。 角度の丸めと角度のスムージングのコマンド Gコード 説明 G50 角度の丸めとスムージングの終了 G51 による角度スムージングの開始 SMC_SmoothPath G52 による角度丸めの開始 SMC_RoundPath G70 による追加軸のスムージングの終了 SMC_SmoothAddAxes G71 による追加軸のスムージングの開始 SMC_SmoothAddAxes ループ抑制のコマンド Gコード 説明 G60 ループ抑制の関数の終了 G61 によるループ抑制のための関数の開始 SMC_AvoidLoop 例：角度スムージング N0 G51 D10 F100\nN10 G01 X$g_x$ Y0 F50 E30 E-30\nN20 G01 X0 Y$g_y$\nN30 G01 X0 Y0\nN40 G50 " }, 
{ "title" : "追加のスプライン軸A、B、C ", 
"url" : "_sm_cnc_din66025_additional_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 追加のスプライン軸A、B、C ", 
"snippet" : "Gコードワード ： A 、 B 、 C ファンクション : 使用 A 、 B 、および C 追加のスプライン軸のターゲット位置を定義します。これらの軸は以下と似ています。 P 、 Q 、 U 、 V 、および W 。 P 、 Q 、 U 、および V 直線的に補間され、 A 、 B 、および C 3 次多項式で補間されます。 を使う A 、 B 、または C 追加軸の使用は除外されます。 U 、 V 、および W なぜなら U 、 V 、および W グラデーションを定義します。 座標軸 A 、 B 、または C のビット 3、4、または 5 で選択できます。 wAxis の入力 SMC_リミッ...", 
"body" : "Gコードワード ： A 、 B 、 C ファンクション : 使用 A 、 B 、および C 追加のスプライン軸のターゲット位置を定義します。これらの軸は以下と似ています。 P 、 Q 、 U 、 V 、および W 。 P 、 Q 、 U 、および V 直線的に補間され、 A 、 B 、および C 3 次多項式で補間されます。 を使う A 、 B 、または C 追加軸の使用は除外されます。 U 、 V 、および W なぜなら U 、 V 、および W グラデーションを定義します。 座標軸 A 、 B 、または C のビット 3、4、または 5 で選択できます。 wAxis の入力 SMC_リミット・ダイナミクス または wAddAxis の SMC_リミットをチェック 。 ザの SMC_SmoothPath 、 SMC_SmoothMerge 、 SMC_スムースBスプライン 、および SMC_ABC スロープを再計算 ファンクションブロックは、追加する軸の傾きを自動的に決定します。つまり、以下の定義は U 、 V 、または W 必要ありません。 例1 Gコード N10 G0 X0 A0 P0 F10 E30 E-30\nN20 G1 X100 A100 P100 線形追加軸Pは、移動経路に対して線形補間されます。したがって、その時間プロファイルは、パス速度の時間プロファイルを返します。 追加のスプライン軸Aは、多項式関数として補間されます。 例 2 スプライン関数を使用する必要があります。特に、接線遷移が一定のパスを使用する場合は、補間関数を速度0まで減速する必要はありません。 Gコード N10 G0 X0 A0 P0 F10 E30 E-30\nN20 G1 X50 A40 P40\nN30 G1 X100 A100 P100 線形の場合、最初の部分では40単位の追加軸が50パス単位で移動し、2番目の部分では60単位の追加軸が50パス単位で移動するため、速度が急上昇します。パス速度はパスデカルト空間の後にのみ（XYZ）を定義するため、Xの一定速度により、Pの速度ジャンプが発生します。 スプライン軸には、次のプロファイルが表示されます。 例 3 終了位置での軸A、B、およびCの勾配は、U、V、およびWワードで定義できます。勾配の単位は、空間内のパス単位ごとの追加軸のパス単位です。 Gコード N10 G0 X0 A0 F10 E30 E-30\nN20 G1 X100 A100 U1.5\nN30 G1 X200 A200 U0 このプログラムにはA軸間の連続的な遷移が含まれているため、ユーザーがプログラムしたA軸の勾配 (U=2) が適用されます N20 そして N30 。したがって、X=100 の場合、A 軸の位置はパスの長さの 2 倍の速さで増加します " }, 
{ "title" : "複数のオブジェクトを使用した追加の軸モーションのスムージング ", 
"url" : "_sm_cnc_din66025_smooth_additional_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 複数のオブジェクトを使用した追加の軸モーションのスムージング ", 
"snippet" : "Gコード ： G70 、 G71 関数 ： G71 開始し、 G70 Lで指定され、複数のオブジェクト上を移動する追加の軸でのモーションのスムージングを終了します。 構文 G70 L4 G71 L4 Gコードワード 追加の軸 L4 A L5 B L6 C L7 P L8 Q L9 U L10 V L11 W...", 
"body" : "Gコード ： G70 、 G71 関数 ： G71 開始し、 G70 Lで指定され、複数のオブジェクト上を移動する追加の軸でのモーションのスムージングを終了します。 構文 G70 L4\nG71 L4 Gコードワード 追加の軸 L4 A L5 B L6 C L7 P L8 Q L9 U L10 V L11 W " }, 
{ "title" : "単一の追加軸をモジュロ軸として構成する（PA \/ PB \/…） ", 
"url" : "_sm_cnc_din66025_define_additional_axis_modulo.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 単一の追加軸をモジュロ軸として構成する（PA \/ PB \/…） ", 
"snippet" : "関数： 軸A、B、C、P、Q、U、V、およびWの場合、次の単語を設定することにより、モジュロ周期を指定できます。 PA 、 PB 、 PC 、など。デフォルトでは、 PA 、 PB 、などの値は0です。これは、軸が線形であることを意味します。追加の軸がモジュロ軸として構成されている場合、最短距離は常に開始位置から目標位置まで補間されます。モジュロ期間が360の場合、移動は次のように開始位置270から目標位置45までです。線形タイムラインの場合のように、正の方向（過去360）は全体で135単位であり、負の方向は225単位ではありません。 。 補間器の位置出力は、間隔[0..period limi...", 
"body" : "関数： 軸A、B、C、P、Q、U、V、およびWの場合、次の単語を設定することにより、モジュロ周期を指定できます。 PA 、 PB 、 PC 、など。デフォルトでは、 PA 、 PB 、などの値は0です。これは、軸が線形であることを意味します。追加の軸がモジュロ軸として構成されている場合、最短距離は常に開始位置から目標位置まで補間されます。モジュロ期間が360の場合、移動は次のように開始位置270から目標位置45までです。線形タイムラインの場合のように、正の方向（過去360）は全体で135単位であり、負の方向は225単位ではありません。 。 補間器の位置出力は、間隔[0..period limit [。 （たとえば、360のモジュロ期間では40ではなく400です。）位置は、次のようなPOUに従うことにより、モジュロ範囲に移動されます。 SMC_ControlAxisByPos 、 また SMC_FollowPosition 。 例 モジュロモードによる軸の回転制御 ブロック30では、軸Aが正の方向に270°から360°= 0°まで90°移動します。 N10 PA360 (A axis has a period of 360 degree)\nN20 G92 A270 (Set the position of A axis to 270)\nN30 G1 A0 " }, 
{ "title" : "変数の使用 ", 
"url" : "_sm_cnc_din66025_usage_of_variables.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 変数の使用 ", 
"snippet" : "構文 $<Variablenname>$ 変数と式の有効なIEC基本タイプ： INT 、 SINT 、 USINT 、 UINT 、 DINT 、 UDINT 、 BYTE 、 WORD 、 DWORD 、 REAL 、 と LREAL 。例外には、M関数のOパラメーターが含まれます（タイプの変数が必要です）。 SMC_M_PARAMETERS ） と G36\/G37 （文字列変数も許可されます）。 変数または式は、Nワード（ブロック番号）を除くすべてのワードに対して定義できます。 IEC式と変数は、オンラインデコーダーPOUでのみ現在の値に置き換えられます。これは、ラインがデコードされるとき...", 
"body" : "構文 $<Variablenname>$ 変数と式の有効なIEC基本タイプ： INT 、 SINT 、 USINT 、 UINT 、 DINT 、 UDINT 、 BYTE 、 WORD 、 DWORD 、 REAL 、 と LREAL 。例外には、M関数のOパラメーターが含まれます（タイプの変数が必要です）。 SMC_M_PARAMETERS ） と G36\/G37 （文字列変数も許可されます）。 変数または式は、Nワード（ブロック番号）を除くすべてのワードに対して定義できます。 IEC式と変数は、オンラインデコーダーPOUでのみ現在の値に置き換えられます。これは、ラインがデコードされるときに発生します。これは、要素が補間器で処理される前の時間です。 オフラインモードの変数の値は、 変数のオフライン値 ダイアログ。を使用してダイアログを開きます CNC→変数の設定 コマンドまたは 変数 CNCオブジェクトのプロパティのボタン。 オフラインモードでのグローバル変数の使用 グローバル変数リストで変数を宣言します。 CNCエディターの変数を少なくとも1つの場所で使用します。 を実行します CNC→変数の設定 指図。 NS 変数のオフライン値 ダイアログが開きます。 テーブルで目的の値を指定します。 例 VAR_GLOBAL\n rVal_x1: REAL:=100;\n rVal_y1: REAL:=50;\nEND_VAR\n\n\/\/ CNC-Editor\nN0 G01 X$rVal_x1$ Y0 F50 E30 E-30\nN10 G01 X0 Y$rVal_y1$\nN20 G01 X0 Y0 オンラインモードでの動作 デコーダーPOUがプログラムをプログラム変数としてオンラインで処理する場合 SMC_CNC_REF 、変数を使用できます。変数は、デコーダーがそれぞれの行を処理するときに置き換えられます。オンラインで読み取られるGコードプログラムで変数を使用するには、次のような追加の準備が必要です。 SMC_VARLIST 。 CNCプログラムが次のようにコンパイルされている場合 SMC_OUTQUEUE 、その場合、可変メカニズムは機能しません。これは、パスがオフラインで生成され、アプリケーションの変更できないデータ構造として渡されるためです。この場合、エディターは変数をオフライン値に置き換えて、オフラインモードで表示します。 詳細については、以下を参照してください。 CNCデータ構造とグローバルアクセス" }, 
{ "title" : "変数の値の変更 ", 
"url" : "_sm_cnc_din66025_change_variable_values.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 変数の値の変更 ", 
"snippet" : "Gコード ： G36 、 G37 関数 ：コマンドは変数の値を変更します。 G36 指定された値を変数に書き込みます。 G37 指定された値で変数をインクリメントします。 O$var$ 編集される変数を定義します。 D のために書かれる値を定義します G36 またはのために追加 G37 。このコマンドは、たとえば、条件付きジャンプに必要なループカウンターに使用されます。 構文 G36 O D G37 O D G36のGコードワード 説明 O 書き込まれる変数。もし O が定義されていない場合は、内部デコーダ変数が使用されます。この内部変数のデフォルト値は -1 。 内部変数は、次の場所で使用で...", 
"body" : "Gコード ： G36 、 G37 関数 ：コマンドは変数の値を変更します。 G36 指定された値を変数に書き込みます。 G37 指定された値で変数をインクリメントします。 O$var$ 編集される変数を定義します。 D のために書かれる値を定義します G36 またはのために追加 G37 。このコマンドは、たとえば、条件付きジャンプに必要なループカウンターに使用されます。 構文 G36 O D\nG37 O D G36のGコードワード 説明 O 書き込まれる変数。もし O が定義されていない場合は、内部デコーダ変数が使用されます。この内部変数のデフォルト値は -1 。 内部変数は、次の場所で使用できます。 ジャンプ コマンド。 D 新しい変数値 G37のGコードワード O インクリメントされる変数。もしも O が定義されていない場合は、内部デコーダー変数が使用されます。 D インクリメント 例 カウンターのプログラミング（パスがオンラインで処理される場合） NS g_i グローバル変数は5に設定されます。 N1000 G36 O$g_i$ D5 1010号線と1020号線は5回運行されています。 N1000 G36 O$g_i$ D5\nN1010 G1 X100 F100 E100 E-100\nN1020 G1 X0\nN1030 G37 O$g_i$ D-1\nN1040 G20 L1010 K$g_i$ このメカニズムは、パスがオンラインで処理される場合にのみ機能します。これは、その場合にのみ変数を使用できるためです。このメカニズムは、CNCエディターでは機能しません。 オフラインモードのカウンターのプログラミング オフラインでエディターを操作するには、を使用して変数を指定しないでください。 O 。次に、タイプの暗黙的なデコーダー変数 INT 使用されている。ただし、使用できる変数は1つだけです。ネストされたジャンプやループをプログラムすることはできません。 文字列変数の使用 GコードのOワードで文字列変数を使用できます。さらに、コマンドを使用して、文字列値をこの変数に割り当てて挿入することもできます。 G36 と G37 。 例 N10 G36 O$strTest$ D'Name' NS strTest 変数はName値を取得します。 N20 G37 O$strTest$ D'=Test' 値 =Test 変数に追加されます strTest 。 文字列変数がCNCプログラムで使用されている場合、およびCNCプログラム（IECプログラム内）が SMC_ReadNCFile 機能ブロックの場合、文字列のバッファはIECプログラムで予約する必要があります。それ以外の場合、エラー SMV_RNCF_NO_STRINGBUFFER 発生します。 NS SMC_StringBuffer 機能ブロックはこの目的で使用できます。 CNCプログラムのすべての文字列は、の機能ブロックインスタンスに独自のスペースを必要とします。 SMC_StringBuffer 、同じ文字列が複数回出現する場合でも。 次の宣言は、32個の文字列をバッファリングできます。次に例を示します。 sb: SMC_StringBuffer(uiBufferSize := 32); 機能ブロックインスタンス sb へのポインタとして渡されます pStringBuffer の入力 SMC_ReadNCFile 実例。 " }, 
{ "title" : "サブプログラム ", 
"url" : "_sm_cnc_din66025_subprograms.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ サブプログラム ", 
"snippet" : "関数 ：サブプログラムの呼び出し ポケットフライス盤、穴あけ、工具交換などの頻繁に繰り返されるタスクは、Gコードサブプログラムにスワップアウトして、そこから呼び出すことができます。呼び出し中に、パラメータをサブプログラムに渡すことができます。データ型 BOOL 、 LREAL 、 と STRING この目的のために許可されています。 サブプログラムを使用する場合は、汎用ブロックを使用する必要があります SMC_ReadNCFile2 と SMC_NCInterpreter それ以外の SMC_ReadNCFile と SMC_NCDecoder 。 サブプログラムはオンラインデコーダーでのみ機...", 
"body" : "関数 ：サブプログラムの呼び出し ポケットフライス盤、穴あけ、工具交換などの頻繁に繰り返されるタスクは、Gコードサブプログラムにスワップアウトして、そこから呼び出すことができます。呼び出し中に、パラメータをサブプログラムに渡すことができます。データ型 BOOL 、 LREAL 、 と STRING この目的のために許可されています。 サブプログラムを使用する場合は、汎用ブロックを使用する必要があります SMC_ReadNCFile2 と SMC_NCInterpreter それ以外の SMC_ReadNCFile と SMC_NCDecoder 。 サブプログラムはオンラインデコーダーでのみ機能します（CNCエディターでは機能しません）。 各サブプログラムは個別のファイルに保存されます。これらのファイルは、コントローラー上の1つ以上のサブディレクトリーに保存されます。彼らはファイル拡張子を持っている必要があります .cnc 。ファイル名は、サブプログラムの名前に対応し、小文字である必要があります。例：サブプログラム名「ドリル」->ファイル名 drill.cnc 。 サブプログラムのファイル名は小文字で記述する必要があることに注意してください。 POU SMC_ReadNCFile2 入力があります aSubProgramDirs : ARRAY[0..4] OF STRING(174) 。これを超えて、最大5つのサブディレクトリを指定できます。それらは指定された順序でスキャンされます。複数のディレクトリに同じ名前のサブプログラムがある場合、配列内でインデックスが最も低いディレクトリを持つサブプログラムが見つかります。サブプログラム名は小文字に変換されます。 例 aSubProgramDirs = ['subprograms\/user', 'subprograms\/system', ''] サブプログラム DrillA1 ファイル内で最初にスキャンされます subprograms\/user\/drilla1.cnc 。このファイルが存在しない場合、検索は次の場所で続行されます。 subprograms\/system\/drilla1.cnc 。 変数を使用して（より正確には、型の式を使用して）サブプログラムを間接的に呼び出すことができます。 STRING ）。式（したがって、変数のルックアップも）は、インタープリターが行に到達したときの前処理時に評価されます（通常、Gコードで変数を使用する場合）。この場合、引数の型チェックは、静的呼び出しの場合のように、インタープリターが行に到達したときにのみ実行され、解析中には実行されません。 CNCエディタでサブプログラムをオフラインで作成することはできません。 サブプログラム呼び出しの最大ネスティング深度 バージョン 4.18.0.0 以前:サブプログラム呼び出しの最大ネスト深度は 14 に制限されています。 バージョン 4.18.0.0 以降:ネスティングの深さはメモリによってのみ制限されるようになりました。最大値は library パラメーターを使用して変更できます。 SMC_CNC_LibParams.MAX_SUBPROGRAM_NESTING_DEPTH 。 " }, 
{ "title" : "呼び出しの構文 ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_f644d63d98ef7863c0a864636e4c0bd6", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ サブプログラム \/ 呼び出しの構文 ", 
"snippet" : "サブプログラム呼び出しは、ブロック番号と呼び出しのみで構成されるGコードの特別なブロックです。追加の単語は許可されていません。 N<SentenceNo> <Name> <BracketOpen> <ActualParamList> <BracketClosed> N<SentenceNo> DYNCALL <BracketOpen> <SubNameExp> [, <ActualParamListNotEmpty] <BracketClosed> <SubNameExp> : An expression with exactly one value of type STRING <Actua...", 
"body" : "サブプログラム呼び出しは、ブロック番号と呼び出しのみで構成されるGコードの特別なブロックです。追加の単語は許可されていません。 N<SentenceNo> <Name> <BracketOpen> <ActualParamList> <BracketClosed>\nN<SentenceNo> DYNCALL <BracketOpen> <SubNameExp> [, <ActualParamListNotEmpty] <BracketClosed>\n\n<SubNameExp> : An expression with exactly one value of type STRING\n<ActualParamList> ::= Empty | <ActualParamListNotEmpty>\n<ActualParamListNotEmpty> ::= <ActualParamValue> | <ActualParamValue>, <ActualParamListNotEmpty> <Name> 最小 3 文字から最大 80 文字の有効な IEC 識別子。サブプログラムが定義されているファイル名 (拡張子なし) に対応している必要があります。サブプログラム名は大文字でも小文字でもかまいません。 [a-zA-Z0-9_] 許可されています。 次のキーワードは名前には無効です。 RETURN,\\\\ IF,\\\\ ELSE,\\\\ END_IF,\\\\ CASE,\\\\ END_CASE,\\\\ FOR,\\\\ END_FOR,\\\\ WHILE,\\\\ END_WHILE, REPEAT,\\\\ UNTIL,\\\\ END_REPEAT 。 <ActualParamList> サブプログラムが定義するのとまったく同じ数のパラメーター値を指定する必要があります（「宣言の構文」を参照）。各パラメーター値のタイプは、宣言と一致する必要があります。 <BracketOpen>\/<BracketClosed> 互換性の理由から、デフォルト設定では括弧の代わりに中括弧が使用されます。 SMC_ReadNCFile2 サブプログラムの呼び出しと宣言。括弧はコメントのGコードで有効です。 機能ブロック SMC_ReadNCFile2 モードがあります（ bParenthesesAsComments 入力）括弧はコメントではありません。代わりに、複数行コメントはで開かれます (* で閉じます *) 。この新しいモードでは、中括弧と括弧の両方をサブプログラムの呼び出しと宣言に使用できます。 <ActualParamValue> 変数、リテラル、または任意の式 例 N10 SUB1()\nN20 DRILL(10.0)\nN30 SUB2(5, \"Text\", 2.5)\nN40 G36 O#SUBNAME D'DRILL' % Indirect call via local variable\nN40 DYNCALL(#SUBNAME, 2) % equivalent to N40 DRILL(2)\nN50 DYNCALL($SUBNAME$, 2, 4) % Indirect call via IEC variable " }, 
{ "title" : "宣言の構文 ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_02170a739e1947dec0a864637ea0fc00", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ サブプログラム \/ 宣言の構文 ", 
"snippet" : "サブプログラムは別のファイルに保存する必要があります。最初の行（空でもコメント行でもない）には、サブプログラムの宣言が含まれている必要があります。次の構文が適用されます。 SUBPROGRAM <Name> <BracketOpen> <FormalParamList> <BracketClosed> <RESTORE_OPT> <Inhalt Unterprogramm> END_SUBPROGRAM <FormalParamList> ::= Empty | <FormalParamListNotEmpty> <FormalParamListNoEmpty> ::= <FormalPara...", 
"body" : "サブプログラムは別のファイルに保存する必要があります。最初の行（空でもコメント行でもない）には、サブプログラムの宣言が含まれている必要があります。次の構文が適用されます。 SUBPROGRAM <Name> <BracketOpen> <FormalParamList> <BracketClosed> <RESTORE_OPT>\n<Inhalt Unterprogramm>\nEND_SUBPROGRAM\n\n<FormalParamList> ::= Empty | <FormalParamListNotEmpty>\n<FormalParamListNoEmpty> ::= <FormalParam> | <FormalParam> , <FormalParamListNotEmpty>\n<FormalParam> ::= <ParamName> : <ParamType>\n<ParamName> ::= #[a-zA-Z0-9_]+\n\n<ParamType> ::= LREAL | BOOL | STRING ; String with a maximum length of 255 bytes\n<RESTORE_OPT> ::= RESTORE_MODES <ParamName> 名前の長さは最大80文字です（プレフィックスは含まれません） # ）。 RESTORE_MODES このキーワードが指定されている場合、呼び出し側プログラムに戻るときに、次のモーダル状態が復元されます（呼び出し時に持っていた値に設定されます）。 アクティブなGコード 相対\/絶対モード（G90 \/ G91、G98 \/ G99） 円形平面と2D \/ 3Dモード デコーダー座標系（スケーリングを含む） 送り速度（経路と追加の軸）、早送り速度、最大加速と減速（経路と追加の軸） 機能フラグと一般パラメータ（G38） 工具径（Dワード） ツールオフセット（G43） Sプロファイル（Sワード） 次のモーダル状態は復元されません。 デコーダー\/インタープリターの現在の位置と現在の基本的なスプライン状態。位置には構造全体が含まれます SMC_POSINFO (つまり、X、Y、Z、方向、およびすべての追加軸)。 パス前処理POU（G40-G43、G50-G52、G60-G61、G70-G71）の状態（オン\/オフ） 追加軸のモジュロ設定（PA、PB、…） 注：このキーワードに関係なく、暗黙のカウンター変数（G36、G37）は、サブプログラムから呼び出し側プログラムに戻るときに復元されます。 例 SUBPROGRAM SUB1() ; no formal parameters\nSUBPROGRAM DRILL(#depth : LREAL)\nSUBPROGRAM SUB2(#a : LREAL, #b : STRING, #c : LREAL)\nSUBPROGRAM SRM1() RESTORE_MODES " }, 
{ "title" : "戻り値の構文 ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_4557d91f9e1947dec0a864630016f87d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ サブプログラム \/ 戻り値の構文 ", 
"snippet" : "戻りは、サブプログラムテキストの最後（ END_SUBPROGRAM ）または次の構文で明示的に： N<block number> RETURN 。...", 
"body" : "戻りは、サブプログラムテキストの最後（ END_SUBPROGRAM ）または次の構文で明示的に： N<block number> RETURN 。 " }, 
{ "title" : "サブプログラムで仮パラメータを使用する ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_ba614a0b6544562fc0a864631e9ee966", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ サブプログラム \/ サブプログラムで仮パラメータを使用する ", 
"snippet" : "仮パラメータの値には、サブプログラムで次の方法でアクセスできます。 #<ParamName> 。 正式なパラメータの数は21に制限されています。 例 SUBPROGRAM SUB(#Param1 : LREAL) N10 G01 X#Param1...", 
"body" : "仮パラメータの値には、サブプログラムで次の方法でアクセスできます。 #<ParamName> 。 正式なパラメータの数は21に制限されています。 例 SUBPROGRAM SUB(#Param1 : LREAL)\nN10 G01 X#Param1 " }, 
{ "title" : "コールスタックの表示 ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_1c910ecf4b371465c0a86463522d8482", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ サブプログラム \/ コールスタックの表示 ", 
"snippet" : "通訳（ SMC_NCInterpreter ）には、上位10個のアクティブなプログラム\/サブプログラムを含む出力があります。 aActivePrograms : ARRAY[0..9] OF STRING 。最初のエントリ（ aActivePrograms[0] ）は現在解釈されているプログラム\/サブプログラムです。 2番目のエントリ（ aActivePrograms[1] ）は呼び出し側プログラム\/サブプログラムなどです。呼び出し側プログラムがない場合、対応する文字列は空です。 コールスタックは、補間時に表示することもできます。 NS SMC_DisplayNCCallstack POUは、...", 
"body" : "通訳（ SMC_NCInterpreter ）には、上位10個のアクティブなプログラム\/サブプログラムを含む出力があります。 aActivePrograms : ARRAY[0..9] OF STRING 。最初のエントリ（ aActivePrograms[0] ）は現在解釈されているプログラム\/サブプログラムです。 2番目のエントリ（ aActivePrograms[1] ）は呼び出し側プログラム\/サブプログラムなどです。呼び出し側プログラムがない場合、対応する文字列は空です。 コールスタックは、補間時に表示することもできます。 NS SMC_DisplayNCCallstack POUは、アクティブなプログラム\/サブプログラムをインタプリタと同じ形式で、後で（つまり、移動が実行されたときに）表示します。そうすることで、インタープリターの出力 CallstackInfo (SMC_NCCallstackInfo) 補間器は次のように渡されます VAR_IN_OUT 変数。 SMC_NCCallstackInfo 対応するものを含む、すべてのコールスタックの変更を保存します SMC_GeoInfo リングバッファ内のオブジェクト番号。現時点では、これにより、解釈時間と補間時間の間の保存可能なコールスタックの変更数が128に制限されます。リングバッファがマルチタスク基準を満たしていないため、 SMC_DisplayNCCallstack インタプリタタスクから呼び出す必要があります。 サンプルプログラム CNC 例 07: 式とサブプログラムの使用補間時のコール スタックの表示例を示します。 " }, 
{ "title" : "式 ", 
"url" : "_sm_cnc_din66025_expressions.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 式 ", 
"snippet" : "関数 ： バージョン4.4.0.0以降では、数式、ブール式、および文字列式を使用できます。 NS SMC_ReadNCFile2 と SMC_NCInterpreter これには、関数ブロックを使用する必要があります（代わりに SMC_ReadNCFile と SMC_NCDecoder ）。 式はオンラインデコーダーでのみ機能します（CNCエディターでは機能しません）。 原則として、式はGコードで次の2つの位置で使用できます。 Gワードの値として（1つのGワードはアドレスと値で構成されます（例：「G1」））。 サブプログラム呼び出しの転送パラメータとして...", 
"body" : "関数 ： バージョン4.4.0.0以降では、数式、ブール式、および文字列式を使用できます。 NS SMC_ReadNCFile2 と SMC_NCInterpreter これには、関数ブロックを使用する必要があります（代わりに SMC_ReadNCFile と SMC_NCDecoder ）。 式はオンラインデコーダーでのみ機能します（CNCエディターでは機能しません）。 原則として、式はGコードで次の2つの位置で使用できます。 Gワードの値として（1つのGワードはアドレスと値で構成されます（例：「G1」））。 サブプログラム呼び出しの転送パラメータとして " }, 
{ "title" : "構文–一般 ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_42546a9cc18a4349c0a86463750fefea", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 式 \/ 構文–一般 ", 
"snippet" : "式は、次の要素で構成できます。 数値および文字列リテラル グローバル変数とローカル変数 中置演算子と関数 カンマと角かっこ 同様に、括弧（コメントの識別に使用されていない場合）と中括弧は、式の構造化に使用できます。これは、式が (1 + 2} * 3 許可されています。 機能ブロック SMC_ReadNCFile2 新しいモードがあります（ bParenthesesAsComments 入力）括弧はコメントではありません。代わりに、複数行コメントはそれぞれ「（*」および「*）」で開閉されます。この新しいモードでは、中括弧と括弧の両方を式に使用できます。 Gアドレスの後のスペースは、次の場合にの...", 
"body" : "式は、次の要素で構成できます。 数値および文字列リテラル グローバル変数とローカル変数 中置演算子と関数 カンマと角かっこ 同様に、括弧（コメントの識別に使用されていない場合）と中括弧は、式の構造化に使用できます。これは、式が (1 + 2} * 3 許可されています。 機能ブロック SMC_ReadNCFile2 新しいモードがあります（ bParenthesesAsComments 入力）括弧はコメントではありません。代わりに、複数行コメントはそれぞれ「（*」および「*）」で開閉されます。この新しいモードでは、中括弧と括弧の両方を式に使用できます。 Gアドレスの後のスペースは、次の場合にのみ必要です。 SMC_ReadNCFile2 独立したトークンとして認識されません（例： X abs{-2} それ以外の Xabs{-2}. ）。 STとは対照的に、単一位置関数は必ずしも括弧付きで呼び出す必要はありません（例： sin 3 ）。 解析時に、各部分式には、BOOL、LREAL、またはSTRINGの3つのタイプのいずれかが割り当てられます。したがって、各中置演算子と各関数は、非準拠（間違った型、少なすぎる、または多すぎる引数）がエラーを返す特定の引数型のシーケンスを予期します。 制限： ブロック番号は数値リテラルである必要があります。 厳密に技術的な理由から、ジャンプマーカー（ x の L!x ）ローカル変数を含めることはできません。 詳細については、以下を参照してください。 ジャンプ、 変数の使用" }, 
{ "title" : "例 ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_5b6258e8c18a4349c0a864632640e903", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 式 \/ 例 ", 
"snippet" : "N01 G36 O$var$ D concat{'prefix_', concat{$var$, '_suffix'}} N02 G1 X$var$ + sin{pi + 3 * #locvar} N03 G20 L0 K NOT {myfun{$var$, expt{2, #locvar}} XOR myfun{0, 0}}...", 
"body" : "N01 G36 O$var$ D concat{'prefix_', concat{$var$, '_suffix'}}\nN02 G1 X$var$ + sin{pi + 3 * #locvar}\nN03 G20 L0 K NOT {myfun{$var$, expt{2, #locvar}} XOR myfun{0, 0}} " }, 
{ "title" : "サポートされている演算子と関数 ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_da2d0ac5c18a4349c0a864637cb30dc8", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 式 \/ サポートされている演算子と関数 ", 
"snippet" : "中置演算子 キャラクター タイプ 引数 優先順位 MOD LREAL LREAL , LREAL 14 * LREAL LREAL , LREAL 13 \/ LREAL LREAL , LREAL 13 + LREAL LREAL , LREAL 12 - LREAL LREAL , LREAL 12 = BOOL BOOL , BOOL 10 = BOOL LREAL , LREAL 10 = BOOL STRING , STRING 10 <> BOOL BOOL , BOOL 10 <> BOOL LREAL , LREAL 10 <> BOOL STRING , STRING 10 >...", 
"body" : "中置演算子 キャラクター タイプ 引数 優先順位 MOD LREAL LREAL , LREAL 14 * LREAL LREAL , LREAL 13 \/ LREAL LREAL , LREAL 13 + LREAL LREAL , LREAL 12 - LREAL LREAL , LREAL 12 = BOOL BOOL , BOOL 10 = BOOL LREAL , LREAL 10 = BOOL STRING , STRING 10 <> BOOL BOOL , BOOL 10 <> BOOL LREAL , LREAL 10 <> BOOL STRING , STRING 10 > BOOL LREAL , LREAL 10 < BOOL LREAL , LREAL 10 >= BOOL LREAL , LREAL 10 <= BOOL LREAL , LREAL 10 AND BOOL BOOL , BOOL 6 XOR BOOL BOOL , BOOL 5 OR BOOL BOOL , BOOL 4 関数 キャラクター タイプ 引数 - LREAL LREAL ABS LREAL LREAL MAX LREAL LREAL , LREAL MIN LREAL LREAL , LREAL NOT BOOL BOOL TRUE BOOL FALSE BOOL SIN LREAL LREAL COS LREAL LREAL TAN LREAL LREAL ASIN LREAL LREAL ACOS LREAL LREAL ATAN LREAL LREAL EXP LREAL LREAL LN LREAL LREAL SQRT LREAL LREAL EXPT LREAL LREAL , LREAL FLOOR LREAL LREAL CEIL LREAL LREAL PI LREAL LEN LREAL STRING CONCAT STRING STRING , STRING " }, 
{ "title" : "独自の関数を定義する ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_fca8916cc18a4349c0a8646350db2bd3", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 式 \/ 独自の関数を定義する ", 
"snippet" : "独自の関数を追加したり、既存の実装を上書きしたりすることができます。 （Gコードを解析する場合、ユーザー関数で最初に関数が検索されます。） SMC_NC_IFunctionインタフェースを実装し、対応するPOUのグローバルインスタンスをに転送する必要があります SMC_ReadNCFile2 または SMC_ReadNCFromStream 構造体を介して SMC_NC_GFunctionTable 。 列挙 SMC_GVar_Type 戻り型と引数型に使用されます。そこに含まれるエントリ T_OTHER タイプのプレースホルダーとして使用できます。解析時に、システムは、に対応するすべての引数...", 
"body" : "独自の関数を追加したり、既存の実装を上書きしたりすることができます。 （Gコードを解析する場合、ユーザー関数で最初に関数が検索されます。） SMC_NC_IFunctionインタフェースを実装し、対応するPOUのグローバルインスタンスをに転送する必要があります SMC_ReadNCFile2 または SMC_ReadNCFromStream 構造体を介して SMC_NC_GFunctionTable 。 列挙 SMC_GVar_Type 戻り型と引数型に使用されます。そこに含まれるエントリ T_OTHER タイプのプレースホルダーとして使用できます。解析時に、システムは、に対応するすべての引数が T_OTHER 署名のは同じタイプです。タイプは関係ありません。 詳細については、以下を参照してください。 ユーザー固有のGコード機能" }, 
{ "title" : "エラー処理 ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_1c910ecf4b371465c0a86463522d8482", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ 式 \/ エラー処理 ", 
"snippet" : "可能であれば、欠陥のあるトークンの正確な位置とその長さが構文エラーで発行されます。エラー位置はにリストされています SMC_ReadNCFile2.errorPos 。...", 
"body" : "可能であれば、欠陥のあるトークンの正確な位置とその長さが構文エラーで発行されます。エラー位置はにリストされています SMC_ReadNCFile2.errorPos 。 " }, 
{ "title" : "ローカル変数 ", 
"url" : "_sm_cnc_din66025_local_variables.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ ローカル変数 ", 
"snippet" : "各Gコードファイルはローカル変数を宣言できます。メインプログラムの場合、宣言は最初に挿入する必要があります。サブプログラムの場合、サブプログラム宣言の直後。 ローカル変数は、それらが宣言されているプログラムまたはサブプログラムでのみ表示されます。 （動的スコープなし） ローカル変数はオンラインデコーダーでのみ機能します（CNCエディターでは機能しません）。 ローカル変数の数 バージョン 4.18.0.0 以前:ローカル変数の数は、サブプログラムごとおよびメインプログラムで 21 に制限されていました。 バージョン 4.18.0.0 以降:ローカル変数の数はメモリによってのみ制限されます。最大値...", 
"body" : "各Gコードファイルはローカル変数を宣言できます。メインプログラムの場合、宣言は最初に挿入する必要があります。サブプログラムの場合、サブプログラム宣言の直後。 ローカル変数は、それらが宣言されているプログラムまたはサブプログラムでのみ表示されます。 （動的スコープなし） ローカル変数はオンラインデコーダーでのみ機能します（CNCエディターでは機能しません）。 ローカル変数の数 バージョン 4.18.0.0 以前:ローカル変数の数は、サブプログラムごとおよびメインプログラムで 21 に制限されていました。 バージョン 4.18.0.0 以降:ローカル変数の数はメモリによってのみ制限されます。最大値はライブラリパラメーターを使用して変更できます SMC_CNC_LibParams.MAX_SUBPROGRAM_PARAMS 。 詳細については、以下を参照してください。 ライブラリパラメーター 宣言の構文 構文は、サブプログラムパラメータの宣言に使用される構文に似ています。ブロックごとに1つの変数を宣言できます。ブロックはNワードで始まりません。変数は、宣言時にオプションの初期値を指定できます。それ以外の場合は、データ型に応じてデフォルト値が割り当てられます（ LREAL: 0, BOOL: FALSE, STRING: ‘‘ ）。 宣言の構文： LET <FormalParam> [:= <InitialValue>] 。 <FormalParam> ::= <ParamName> : <ParamType>\n<ParamName> ::= #[a-zA-Z0-9_]+\n\n<ParamType> ::= LREAL | BOOL | STRING ; String mit maximaler Länge von 255 Bytes <InitialValue> ：変数と一致する値と型を持つ式。式はローカル変数（およびサブプログラムではサブプログラムのパラメーター）を使用することもできますが、プログラムコードで上記で宣言されたもののみです。 例 • LET #x : LREAL (* Variable #x, Typ LREAL, Initialwert 0 *)\n• LET #y : LREAL := #x + 1 (* Variable #y, Typ LREAL, Initialwert #x+1 = 1 *)\n• LET #b : BOOL := #x >= #y (* Variable #b, Typ BOOL, Initialwert FALSE *) サブプログラムパラメータと同様に、ローカル変数では大文字と小文字は区別されません。 （両方 #x と #X 同じ変数を示します。）プログラム\/サブプログラムで宣言されたすべてのローカル変数の名前は異なっている必要があります。それらは、サブプログラムの仮パラメーターの名前とは異なる必要があります。 ローカル変数は、サブプログラムのパラメーターのようにGコードで使用できます。 例 • N10 G01 X#x Y#y\n• N20 G20 L10 K#b " }, 
{ "title" : "プロービング機能 (残り距離クリア) ", 
"url" : "_sm_probe_movement.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ DIN66025のCNC言語 \/ プロービング機能 (残り距離クリア) ", 
"snippet" : "Gコード : G31 \/任意の移動コマンドと PROBE 単語 ファンクション : プロービング機能 (残り距離クリア) は信号が出るとすぐに中止される特殊な動きです ( PROBE ) は保留中です。残りのGコードは、プログラムされた動きの終了位置からではなく、動きが中止された位置から継続します プロービング機能（残り距離をクリア）は、次の動きの前に暗黙的にデコードを停止させます（と同様） G75 )。Gコードのデコードは、信号が受信された後にのみ続行されます。一般的な使用例としては、ツール長の測定 (スイッチへの移動) やブロックへの移動などがあります プロービング機能（残り距離のクリア）...", 
"body" : "Gコード : G31 \/任意の移動コマンドと PROBE 単語 ファンクション : プロービング機能 (残り距離クリア) は信号が出るとすぐに中止される特殊な動きです ( PROBE ) は保留中です。残りのGコードは、プログラムされた動きの終了位置からではなく、動きが中止された位置から継続します プロービング機能（残り距離をクリア）は、次の動きの前に暗黙的にデコードを停止させます（と同様） G75 )。Gコードのデコードは、信号が受信された後にのみ続行されます。一般的な使用例としては、ツール長の測定 (スイッチへの移動) やブロックへの移動などがあります プロービング機能（残り距離のクリア）は、直線や円弧など、任意の数の動きに対してアクティブにできます。このためには、 PROBE Gコードに単語を追加する必要があります。 G31 はプロービング機能付きの直線的な動きで (残り距離をクリア)、デフォルトのプローブ番号は1です。このデフォルトは PROBE ワードで上書きできます 各ムーブメントには最大で1つしかありません PROBE 単語。 Hファンクション (トリガー) はプロービング機能 (残り距離クリア) による動きには対応していません。 コーナースムージング、ツール半径補正などのパスの前処理は、プロービング機能（残り距離のクリア）による動きには対応していません。 プローブ番号は正でなければなりません。 プロービング機能による動きの処理中にプローブ信号が受信されない場合（残り距離をクリア）、動きの終了時に補間が停止し、エラーが発生します。 プローブ信号を受信したら、まず補間器を停止する必要があります。入力の 1 つ。 bSlow_Stop 、 bQuick_Stop 、または bEmergency_Stop この目的に使用できます。補間が停止するとすぐにプロービング機能 (残り距離のクリア) を確認できます。そのためにライジングエッジを当てるのが、 SMC_Interpolator.bAcknProbe 入力。 構文 G31 X Y Z A B C P Q U V W F E S PROBE\nG1\/2\/3\/8\/9 X Y Z A B C P Q U V W F E S PROBE Gコードワード [説明] X Y Z デカルト座標軸の目標位置 A B C P Q U V W 追加軸のターゲット位置 F E 経路速度、経路加速\/減速 S S プロファイル PROBE プローブ番号は正でなければなりません。 例 直線的な動き プロービング機能（残り距離をクリア）とデフォルトのプローブ番号1による直線運動 N010 G31 X100 円形の動き プロービング機能（残り距離をクリア）とプローブ番号7による円状移動 N010 G02 X100 R50 PROBE 7 詳細については、次の例を参照してください。 CNC 事例16: プロービング機能 (残り距離をクリア) (G31)" }, 
{ "title" : "パスの前処理とキューサイズ ", 
"url" : "_sm_preprocessing_queuesize.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ パスの前処理とキューサイズ ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Gコード処理のパイプライン ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103127844091", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ パスの前処理とキューサイズ \/ Gコード処理のパイプライン ", 
"snippet" : "Gコードをファイルから読み取る場合、加工を開始する前にファイル全体を読み取って処理することは現実的ではないことがよくあります。アプリケーションによっては、Gコードファイルの行数が数十万行から数百万行になることもあります。すべてを一度に読み取るには長い時間がかかり、大量のメモリも必要になります 代わりに、Gコードは1行ずつ読み取られますが、各時点でメモリに保持されるのはごく一部（数百行）だけです。この部分はキューに保持されます。つまり、「先入れ先出し」の原則、つまり生成関数ブロックがキューに要素を追加するという原則に従って機能するデータ構造に格納されます。コンシューマー・ファンクション・ブロック...", 
"body" : "Gコードをファイルから読み取る場合、加工を開始する前にファイル全体を読み取って処理することは現実的ではないことがよくあります。アプリケーションによっては、Gコードファイルの行数が数十万行から数百万行になることもあります。すべてを一度に読み取るには長い時間がかかり、大量のメモリも必要になります 代わりに、Gコードは1行ずつ読み取られますが、各時点でメモリに保持されるのはごく一部（数百行）だけです。この部分はキューに保持されます。つまり、「先入れ先出し」の原則、つまり生成関数ブロックがキューに要素を追加するという原則に従って機能するデータ構造に格納されます。コンシューマー・ファンクション・ブロックは、挿入されたのと同じ順序で要素の読み取りと削除を行います この図は、システム内のGコードの流れを示しています。最初に G コードがファイルから読み込まれ、インタープリターによっていわゆる GeoInfo 要素に変換されます。これらの要素はパス前処理ファンクションブロックによって処理され、最後に補間されます。「GeoInfo」とマークされた部分はキューを表しています。複数のパスプリプロセッサ (など) の場合 SMC_SmoothPath 、 SMC_ToolRadiusCorr 、または SMC_AvoidLoop ) を使用するとキューで接続されます。 " }, 
{ "title" : "推奨キューサイズ ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103128036484", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ パスの前処理とキューサイズ \/ 推奨キューサイズ ", 
"snippet" : "経験則として、ほとんどのキューには 16 要素のサイズが適しています。の前の最後のキュー SMC_Interpolator ファンクションブロック (通常は前のパス前処理ファンクションブロックのキュー) SMC_CheckVelocities ) のキューサイズは大きいはずです。ほとんどのアプリケーションでは 100 要素から始めるとよいでしょう。 これらのルールを理解し、いつルールから逸脱すべきかを知るために、キューサイズの影響を調べます。 レイテンシー 処理時間:キューが大きいほど、最初にキューがいっぱいになるまでの時間が長くなります。は SMC_Interpolator 関数ブロックは、...", 
"body" : "経験則として、ほとんどのキューには 16 要素のサイズが適しています。の前の最後のキュー SMC_Interpolator ファンクションブロック (通常は前のパス前処理ファンクションブロックのキュー) SMC_CheckVelocities ) のキューサイズは大きいはずです。ほとんどのアプリケーションでは 100 要素から始めるとよいでしょう。 これらのルールを理解し、いつルールから逸脱すべきかを知るために、キューサイズの影響を調べます。 レイテンシー 処理時間:キューが大きいほど、最初にキューがいっぱいになるまでの時間が長くなります。は SMC_Interpolator 関数ブロックは、最後のキューがいっぱいになるまで待ってから、補間を開始します。レイテンシーについては、キューの合計サイズ (すべてのキューサイズの合計) 先を見据えて 補間器の:その前の最後のキューのサイズ SMC_Interpolator 補間の先読みを決定します。トラジェクトリーを計算する場合、補間器は先読みの最後までしか計画できません。ルックアヘッドが小さすぎると、補間器が全経路速度に達しない可能性があります。経路速度と要素の長さによっては、100 要素から始めるのが適切ですが、速度が速い場合や要素数が短い場合は、キューサイズを大きくする必要がある場合があります への影響 特定のファンクションブロック : 次のようなファンクションブロック SMC_AvoidLoop または SMC_SmoothMerge 効果的に機能させるには、一定サイズの受信キューが必要です。たとえば、G コード内のループを検出するには、そのループがキューに収まらないようにする必要があります SMC_AvoidLoop 。詳細については、パス処理パイプラインのファンクションブロックのドキュメントを確認してください。 " }, 
{ "title" : "処理関数ブロックを呼び出す ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103128219711", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ パスの前処理とキューサイズ \/ 処理関数ブロックを呼び出す ", 
"snippet" : "前述のように、補間はすべてのキューがいっぱいになった後にのみ開始されます。これにより、加工開始時に初期待ち時間が発生します。キューの合計サイズを減らす以外に、この待ち時間を減らす方法は他にもあります。 パス前処理関数ブロックは、次のような例に示すように、通常、周期的なバックグラウンドタスクで呼び出されます。 CNC 例 03: パスの前処理をオンラインで実行する。レイテンシーを減らすために、プログラムは呼び出します SMC_ReadNCFile2 、 SMC_NCInterpreter また、パスプリプロセッサをループで呼び出すこともできます。アプリケーションとタスクの優先順位によっては、1 ...", 
"body" : "前述のように、補間はすべてのキューがいっぱいになった後にのみ開始されます。これにより、加工開始時に初期待ち時間が発生します。キューの合計サイズを減らす以外に、この待ち時間を減らす方法は他にもあります。 パス前処理関数ブロックは、次のような例に示すように、通常、周期的なバックグラウンドタスクで呼び出されます。 CNC 例 03: パスの前処理をオンラインで実行する。レイテンシーを減らすために、プログラムは呼び出します SMC_ReadNCFile2 、 SMC_NCInterpreter また、パスプリプロセッサをループで呼び出すこともできます。アプリケーションとタスクの優先順位によっては、1 回のタスク呼び出しでプログラムを複数回 (例:100 回) 実行するか、一定時間 (例:5 ms) 後にループを終了すれば十分な場合があります " }, 
{ "title" : "例 ", 
"url" : "_sm_cnc_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CNC 例 01: OutQueue を直接生成する ", 
"url" : "_sm_example_cnc_1.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 01: OutQueue を直接生成する ", 
"snippet" : "を参照してください CNC01_direct.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . この例は、2 つの軸を持つ CNC プログラムを示しています。定義された速度と加速度で、X\/Y 平面内の 4 つの位置にアプローチします。プログラムは、パス上に 2 つのパス スイッチ ポイントを設定します。プログラムは、を使用してデータ構造に直接書き込まれます。 SMC_OutQueue コンパイルモード。 試運転 作成したプログラムをコンパイルして起動します。プログラムは、CNCモーションを...", 
"body" : "を参照してください CNC01_direct.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . この例は、2 つの軸を持つ CNC プログラムを示しています。定義された速度と加速度で、X\/Y 平面内の 4 つの位置にアプローチします。プログラムは、パス上に 2 つのパス スイッチ ポイントを設定します。プログラムは、を使用してデータ構造に直接書き込まれます。 SMC_OutQueue コンパイルモード。 試運転 作成したプログラムをコンパイルして起動します。プログラムは、CNCモーションを実行するとすぐに Execute 補間器の入力が設定されました。プログラムが完全に実行されたら、新しい立ち上がりエッジを使用してプログラムを再起動できます。 補間機能ブロックの視覚化にも表示されるパススイッチの機能に注意してください。 " }, 
{ "title" : "CNCエディタでNCプログラムを作成する ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_0decf30fe1170213c0a864632e7a1fa2", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 01: OutQueue を直接生成する \/ CNCエディタでNCプログラムを作成する ", 
"snippet" : "作成する CNCdirect とのプロジェクト SoftMotion コントローラ。 を挿入します CNCプログラム 名前の付いたオブジェクト Example 。 を選択 実装 Din66025 そしてその コンパイルモード SMC_OutQueue 。 次のモーションブロックを指定します。 CNCエディター：...", 
"body" : "作成する CNCdirect とのプロジェクト SoftMotion コントローラ。 を挿入します CNCプログラム 名前の付いたオブジェクト Example 。 を選択 実装 Din66025 そしてその コンパイルモード SMC_OutQueue 。 次のモーションブロックを指定します。 CNCエディター： " }, 
{ "title" : "ドライブインターフェースとPLC構成の作成 ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_502a86c7e1170213c0a864631de910a9", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 01: OutQueue を直接生成する \/ ドライブインターフェースとPLC構成の作成 ", 
"snippet" : "次のように、2つのリニアドライブを備えたドライブ構造を定義します。 2つの仮想ドライブを挿入します X_Drive と Y_Drive 下 SoftMotion一般軸プール 。 をセットする 軸タイプ パラメータを Finite （1）。 構成エディター：...", 
"body" : "次のように、2つのリニアドライブを備えたドライブ構造を定義します。 2つの仮想ドライブを挿入します X_Drive と Y_Drive 下 SoftMotion一般軸プール 。 をセットする 軸タイプ パラメータを Finite （1）。 構成エディター： " }, 
{ "title" : "IECプログラムの作成 ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_2840ecebe1170213c0a8646360b1cd08", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 01: OutQueue を直接生成する \/ IECプログラムの作成 ", 
"snippet" : "新しいCFCプログラムを追加する Ipo アプリケーションに接続し、3ミリ秒の間隔で循環タスクを構成します。 でドライブをアクティブにします MC_Power ファンクションブロック。 POU： を挿入します SMC_Interpolator POU。機能ブロックは、GEOINFOオブジェクトによって定義されたパスを個別のパスポイントに変換します。ファンクションブロックは、入力で作成されたCNCプログラムのアドレスを受け取ります poqDataIn 。次に、IECタスクサイクルタイムを入力に書き込む必要があります dwIpoTime 。これらは入力で定数値として指定できます dwIpoTime...", 
"body" : "新しいCFCプログラムを追加する Ipo アプリケーションに接続し、3ミリ秒の間隔で循環タスクを構成します。 でドライブをアクティブにします MC_Power ファンクションブロック。 POU： を挿入します SMC_Interpolator POU。機能ブロックは、GEOINFOオブジェクトによって定義されたパスを個別のパスポイントに変換します。ファンクションブロックは、入力で作成されたCNCプログラムのアドレスを受け取ります poqDataIn 。次に、IECタスクサイクルタイムを入力に書き込む必要があります dwIpoTime 。これらは入力で定数値として指定できます dwIpoTime または、変数を使用できます dwCycle PLC構成からの軸グループ構造の。これの利点は、タスクのサイクル時間を変更したときに、正しい時刻が補間器の入力として自動的に使用されることです。 POU： この例では、ガントリーシステムが制御されます。この目的のために、から逆変換および順変換関数ブロックのインスタンスを挿入します。 SM_Trafo 図書館。順変換機能ブロックには、入力としてドライブが含まれています。逆変換関数ブロックには、補間器の設定位置が含まれている必要があります。この例の順方向変換は、視覚化にのみ必要です。 機能ブロックインスタンス： 機能ブロックの出力（軸座標）をドライブに書き込む必要があります。これはで行われます SMC_ControlAxisByPos ファンクションブロック。アプリケーションは、補間器の出力が一定であることを保証しないため（たとえば、パスが開始した場所以外のポイントで終了する）、ギャップ回避をアクティブにします（ bAvoidGaps 、 fGapVelocity 、 fGapAcceleration 、 fGapDeceleration ）。次に、を接続します StopIpo に出力 bEmergency_Stop 補間器の入力と接続補間器の出力 iStatus 軸制御機能ブロックのそれぞれの入力に。 CFCでプログラミングする場合は、機能ブロックの正しい順序に注意してください。 CFC： " }, 
{ "title" : "オペレーティングインターフェイスとテストインターフェイスの作成 ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_af479c23e1170213c0a8646355fa8e27", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 01: OutQueue を直接生成する \/ オペレーティングインターフェイスとテストインターフェイスの作成 ", 
"snippet" : "2つのビジュアライゼーションオブジェクトを新しいビジュアライゼーションにリンクします。補間器のテンプレートと変換のテンプレートです。プレースホルダーを使用して、これらをそれぞれの関数ブロックインスタンスにリンクする必要があります（ここでは： Ipo.smci と Ipo.trafof ）。...", 
"body" : "2つのビジュアライゼーションオブジェクトを新しいビジュアライゼーションにリンクします。補間器のテンプレートと変換のテンプレートです。プレースホルダーを使用して、これらをそれぞれの関数ブロックインスタンスにリンクする必要があります（ここでは： Ipo.smci と Ipo.trafof ）。 " }, 
{ "title" : "CNC 例 02: 変数を使用したオンライン デコード ", 
"url" : "_sm_example_cnc_2.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 02: 変数を使用したオンライン デコード ", 
"snippet" : "を参照してください CNC02_online.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . この例は、次の方法を示しています。 変数を使用する CNC プログラムをデコードします。 試運転 作成したプログラムをコンパイルして起動します。プログラムは、CNCモーションを実行するとすぐに Execute デコーダーとインターポレーターの入力が設定されています。グローバル変数の値を変更すると、デコーダーが再起動され、それに応じてパスが調整されるときに使用されます。の機能を監視する Appen...", 
"body" : "を参照してください CNC02_online.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . この例は、次の方法を示しています。 変数を使用する CNC プログラムをデコードします。 試運転 作成したプログラムをコンパイルして起動します。プログラムは、CNCモーションを実行するとすぐに Execute デコーダーとインターポレーターの入力が設定されています。グローバル変数の値を変更すると、デコーダーが再起動され、それに応じてパスが調整されるときに使用されます。の機能を監視する Append デコーダーの入力も。 " }, 
{ "title" : "CNCエディタでNCプログラムを作成する ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_4c86ec04e529c0bcc0a864636a6ae1dc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 02: 変数を使用したオンライン デコード \/ CNCエディタでNCプログラムを作成する ", 
"snippet" : "作成する CNCOnline とのプログラム SoftMotion コントローラ。 グローバル変数リストを作成し、2つの変数を宣言します。 VAR_GLOBAL g_x: REAL:=100; g_y:REAL:=50; END_VAR を挿入します CNCプログラム 名前の付いたオブジェクト Example 。 を選択 実装 Din66025 そしてその コンパイルモード SMC_CNC_REF .プログラムで変数を使用するため、このモードが必要です。 次のモーションブロックを指定します。 CNCエディター：...", 
"body" : "作成する CNCOnline とのプログラム SoftMotion コントローラ。 グローバル変数リストを作成し、2つの変数を宣言します。 VAR_GLOBAL\n g_x: REAL:=100;\n g_y:REAL:=50;\nEND_VAR を挿入します CNCプログラム 名前の付いたオブジェクト Example 。 を選択 実装 Din66025 そしてその コンパイルモード SMC_CNC_REF .プログラムで変数を使用するため、このモードが必要です。 次のモーションブロックを指定します。 CNCエディター： " }, 
{ "title" : "ドライブインターフェースとPLC構成の作成 ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_7e9d1704e529c0bcc0a8646343b60bbd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 02: 変数を使用したオンライン デコード \/ ドライブインターフェースとPLC構成の作成 ", 
"snippet" : "ドライブ構造を定義します（例： CNCdirect ）。...", 
"body" : "ドライブ構造を定義します（例： CNCdirect ）。 " }, 
{ "title" : "IECプログラムの作成 ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_3989abe9e529c0bcc0a864630f20ee19", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 02: 変数を使用したオンライン デコード \/ IECプログラムの作成 ", 
"snippet" : "名前の付いたPOU（CFC）を追加します Path アプリケーションに。 OUTQUEUEのNCプログラムのデコードと速度チェックは、 Path プログラム。 呼び出し SMC_CheckVelocities 必要とされている。 CFC： 名前の付いたPOU（CFC）を追加します Ipo アプリケーションに。 このプログラムは、 CNCdirect サンプルプロジェクト。ただし、補間器のデータ入力はCNCプログラム名に対応していません（ ADR(Example) ）、ただしパス前処理機能ブロックのOutQueue出力（ checkVel.poqDataOut ）。...", 
"body" : "名前の付いたPOU（CFC）を追加します Path アプリケーションに。 OUTQUEUEのNCプログラムのデコードと速度チェックは、 Path プログラム。 呼び出し SMC_CheckVelocities 必要とされている。 CFC： 名前の付いたPOU（CFC）を追加します Ipo アプリケーションに。 このプログラムは、 CNCdirect サンプルプロジェクト。ただし、補間器のデータ入力はCNCプログラム名に対応していません（ ADR(Example) ）、ただしパス前処理機能ブロックのOutQueue出力（ checkVel.poqDataOut ）。 " }, 
{ "title" : "パス前処理用のタスクの作成 ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_3014d45de529c0bcc0a86463617895a7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 02: 変数を使用したオンライン デコード \/ パス前処理用のタスクの作成 ", 
"snippet" : "コンパイルモードを選択したため SMC_CNC_REF 、IECプログラムでデコードとパス前処理を実行する必要があります。この計算には時間がかかります。デコーダー呼び出しごとに1つのパスオブジェクトが生成されるため、補間器サイクルで実行する必要はありません。このオブジェクトは通常、多くの補間器呼び出しに使用されます。この操作を、優先度が低く、呼び出しの頻度が少ないタスクに交換する必要があります。 作成する PathTask タスク。 次のパラメータを定義します。 優先順位 ：10 間隔 ：T＃30ms 追加します Path タスクへのPOU。 「PathTask」タスク 根本的なメカニズム： ...", 
"body" : "コンパイルモードを選択したため SMC_CNC_REF 、IECプログラムでデコードとパス前処理を実行する必要があります。この計算には時間がかかります。デコーダー呼び出しごとに1つのパスオブジェクトが生成されるため、補間器サイクルで実行する必要はありません。このオブジェクトは通常、多くの補間器呼び出しに使用されます。この操作を、優先度が低く、呼び出しの頻度が少ないタスクに交換する必要があります。 作成する PathTask タスク。 次のパラメータを定義します。 優先順位 ：10 間隔 ：T＃30ms 追加します Path タスクへのPOU。 「PathTask」タスク 根本的なメカニズム： 遅いタスクでは、最初はサイクルごとに約1つのGEOINFOオブジェクトが生成されます。このオブジェクトは、デコーダ機能ブロックのOUTQUEUE構造に格納されます。 OUTQUEUEがいっぱいになると、低速タスクの機能ブロックは、OUTQUEUEがいっぱいでなくなるまで一時停止します。これは、高速タスクが最初のGEOINFOオブジェクトを処理し、それをOUTQUEUEから削除するとすぐに発生します。 次に、低速タスクの機能ブロックが再びアクティブになり、OUTQUEUE構造を埋めます。 高速タスクでは、OUTQUEUE構造からのパスポイント。 DataIn への入力ポイントは、各サイクルで計算および処理されます。 GEOINFOオブジェクトは通常、複数のパスポイントで構成されているため、最初のGEOINFOオブジェクトが補間器によって自動的に処理および削除されるまでに数サイクルかかります。 GEOINFOオブジェクトの処理は、作成とは対照的に数サイクル続くため、遅いタスクは速いタスクよりも頻繁に呼び出すことができません。 ただし、タスク時間は、十分なGEOINFOオブジェクトが常に低速タスクの最後のOUTQUEUEに格納されるように選択する必要があります。これにより、データのアンダーランが発生しなくなります。これは、DataInから補間器に使用できるGEOINFOオブジェクトがなく、パスの終わりにまだ到達していない場合に発生します。この場合、補間器は速度を落とし、新しいデータ要素が再び利用可能になるまで停止します。 " }, 
{ "title" : "オペレーティングインターフェイスとテストインターフェイスの作成 ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_af479c23e1170213c0a8646355fa8e27", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 02: 変数を使用したオンライン デコード \/ オペレーティングインターフェイスとテストインターフェイスの作成 ", 
"snippet" : "視覚化はに対応します CNCdirect.project サンプルプロジェクト。新しい機能ブロックにテンプレートを追加します（ SMC_NCDecoder と SMC_CheckVelocities ）。グローバル変数の表示も作成します g_x と g_y 後で試運転時にそれらの機能を確認できるようにします。...", 
"body" : "視覚化はに対応します CNCdirect.project サンプルプロジェクト。新しい機能ブロックにテンプレートを追加します（ SMC_NCDecoder と SMC_CheckVelocities ）。グローバル変数の表示も作成します g_x と g_y 後で試運転時にそれらの機能を確認できるようにします。 " }, 
{ "title" : "CNC 例 03: パスの前処理をオンラインで実行する ", 
"url" : "_sm_example_cnc_3.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 03: パスの前処理をオンラインで実行する ", 
"snippet" : "を参照してください CNC03_prepro.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . この例は、パスの前処理を PLC でオンラインで実行する方法を示しています。 拡張する CNC02_online 1 つのパス プリプロセッサを使用したプロジェクト。次に、の動きの角度 CNConline プロジェクトはスプラインによって丸められます。これは、 SMC_SmoothPath 機能ブロック。 CNCプログラムの拡張：前のプログラムに要素を追加します G51\/G50 。 クリック C...", 
"body" : "を参照してください CNC03_prepro.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . この例は、パスの前処理を PLC でオンラインで実行する方法を示しています。 拡張する CNC02_online 1 つのパス プリプロセッサを使用したプロジェクト。次に、の動きの角度 CNConline プロジェクトはスプラインによって丸められます。これは、 SMC_SmoothPath 機能ブロック。 CNCプログラムの拡張：前のプログラムに要素を追加します G51\/G50 。 クリック CNC → 前処理されたパスを表示 以下のスクリーンショットのように、パスの前処理によって作成されたスプラインがエディターに表示されるようにします。 画面： 変数を使用せずに、この形式のプログラムをキューとしてコンパイルし、補間器に直接入力することができます。ただし、変数が使用可能であるため、デコードと角度スムージングを自分で実行する必要があります。 タイプの新しい機能ブロックを宣言します SMC_SmoothPath 。デコーダーの後でそれを呼び出します。 補間関数ブロックのデータ入力を通常どおりに設定します。 poqDataOut の出力 CheckVelocities ファンクションブロック。 入力用に新しいバッファを宣言する必要があります SMC_SmoothPath.pbyBufferOutQueue 。 CFC： 試運転 作成したプログラムをコンパイルして起動します。以前のプログラムとは対照的に、このプログラムは、パスの前処理によってパスの角度にねじれがないため、NCプログラムの角度で停止しなくなりました。 " }, 
{ "title" : "CNC の例 04: テーブル エディターを使用した CNC のプログラミング ", 
"url" : "_sm_example_cnc_4.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC の例 04: テーブル エディターを使用した CNC のプログラミング ", 
"snippet" : "を参照してください CNC04_table.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . このプロジェクトでは、 CNC03_prepro.project サンプル プロジェクトは、表形式エディターでプログラムされています。とは対照的に CNC03_prepro.project 、このプロジェクトでは IEC 変数は使用されません。代わりに、固定値で計算されます。それ以外の機能は同じです。...", 
"body" : "を参照してください CNC04_table.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . このプロジェクトでは、 CNC03_prepro.project サンプル プロジェクトは、表形式エディターでプログラムされています。とは対照的に CNC03_prepro.project 、このプロジェクトでは IEC 変数は使用されません。代わりに、固定値で計算されます。それ以外の機能は同じです。 " }, 
{ "title" : "CNC 例 05: ファイルから CNC を作成する ", 
"url" : "_sm_example_cnc_5.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 05: ファイルから CNC を作成する ", 
"snippet" : "を参照してください CNC05_File.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . このサンプルプロジェクトでは、PLCに保存されているASCIIファイルからGコードプログラムを読み取る方法を理解できます。この種のファイルを使用することは、Gコードプログラムが非常に大きい場合に意味があります。 プロジェクトの機能は、 CNC02_online.project サンプルプロジェクト。ただし、G コードプログラムは ASCII ファイルから読み込みます。変数は使用されず、処理順序は C...", 
"body" : "を参照してください CNC05_File.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . このサンプルプロジェクトでは、PLCに保存されているASCIIファイルからGコードプログラムを読み取る方法を理解できます。この種のファイルを使用することは、Gコードプログラムが非常に大きい場合に意味があります。 プロジェクトの機能は、 CNC02_online.project サンプルプロジェクト。ただし、G コードプログラムは ASCII ファイルから読み込みます。変数は使用されず、処理順序は CNC02_online.project サンプルプロジェクト。 次の違いを判断できます。 追加の仮想ドライブ（z軸） ファンクションブロック smoothpath 必要ありません ファイルから読み取られたGコード オンラインでの前処理 (参照 CNC02_online.project ) " }, 
{ "title" : "CNC 例 06: Path3D の使用 SoftMotion CNC ", 
"url" : "_sm_example_cnc_6.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 06: Path3D の使用 SoftMotion CNC ", 
"snippet" : "を参照してください CNC06_File_3DPath.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . この例は前の例を拡張したものです CNC05_File .これは、Path3D 視覚化要素の可能なアプリケーションを示しています。 CODESYS SoftMotion CNC。 プログラムCNC_FileをCNC_File_Path3Dに拡張する を開きます ライブラリマネージャー を追加します SM3_CNC_Visu 図書館。 のインスタンスを作成します SMC_PathCopi...", 
"body" : "を参照してください CNC06_File_3DPath.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . この例は前の例を拡張したものです CNC05_File .これは、Path3D 視覚化要素の可能なアプリケーションを示しています。 CODESYS SoftMotion CNC。 プログラムCNC_FileをCNC_File_Path3Dに拡張する を開きます ライブラリマネージャー を追加します SM3_CNC_Visu 図書館。 のインスタンスを作成します SMC_PathCopierFile の CNC_PreparePath パス処理の開始時に呼び出します（ iState=0 ）。 プログラミング： の中に 視覚化 視覚化、以前に使用した位置のグラフィック表示を Path3D エレメント。 のプロパティを変更します Path3D エレメント： パスの説明→パスデータ（VisuStruct3DTrack） ： CNC_prepare_path.pcf.vs3dt を挿入します フレーム 視覚化要素。 を参照してください コントロールパネル からの視覚化 VisuElem3DPath 図書館。この要素は、要素のカメラ位置を制御するために使用されます。 の宣言で CNC_PreparePath プログラム、のインスタンスを作成します VisuStruct3DControl （（ VisuElem3DPath 図書館）： vc: VisuStruct3DControl; 。 このインスタンスは、Path3D要素とカメラコントロールパネルの間のデータインターフェイスを形成します。 のプロパティを変更します Path3D エレメント： カメラ制御→制御データ構造（VisuStruct3DControl） ： CNC_PreparePath.vc のプロパティを変更します コントロールパネル エレメント： 参照→VisuElem3DPath.ControlPanel→vc ： CNC_PreparePath.vc アプリケーションをコンパイル、ダウンロード、および起動します。 Path3D要素はパスを示します。パネルからカメラの位置を制御できます。 のインスタンスを追加します SMC_PositionTracker の機能ブロック CNC プログラム。現在のトラック（最後に移動した位置）をトレースするためのメモリを作成します。 pt: SMC_PositionTracker; pointbuffer_pt: ARRAY [0..1000] OF VisuStruct3DPathPoint; インスタンスの呼び出しを挿入します。 SMC_PositionTracker に Interpolation アクション CFC： パスデータをPath3D要素にリンクします。のプロパティを変更します Path3D エレメント： パスの説明→パスデータ（VisuStruct3DTrack） ： CNC.pt.vs3dt オンラインにして、アプリケーションを起動します。 Path3D要素は、パスに対して最後に補間されたパスも表示します。 の他のプロパティを構成する Path3D 。たとえば、処理されたパス要素を灰色で表示するように構成します。 ハイライト→ハイライトカラー ： Gray サンプルプロジェクト：「3Dパスジェネレーター」 " }, 
{ "title" : "CNC 例 07: 式とサブプログラムの使用 ", 
"url" : "_sm_example_cnc_7.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 07: 式とサブプログラムの使用 ", 
"snippet" : "を参照してください CNC07_Subprogram.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . この例では、 サブプログラム CNC ファイルから、および使用する 式 CNCモーション命令で。 の中に CNC プログラムでは、他の例のように、ドライブが最初にオンになります。 NS CNC_PreparePath プログラムはを使用します SMC_ReadNCFile2 CNCファイルを読み取るための機能ブロック。 SMC_ReadNCFile2 を作成します SMC_ReadNCF...", 
"body" : "を参照してください CNC07_Subprogram.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . この例では、 サブプログラム CNC ファイルから、および使用する 式 CNCモーション命令で。 の中に CNC プログラムでは、他の例のように、ドライブが最初にオンになります。 NS CNC_PreparePath プログラムはを使用します SMC_ReadNCFile2 CNCファイルを読み取るための機能ブロック。 SMC_ReadNCFile2 を作成します SMC_ReadNCFile POUを拡張し、サブプログラムと式をサポートします。 CNCプログラム CNC2Main.cnc によって変換されます SMC_NCInterpreter ファンクションブロック。 SMC_NCInterpreter を作成します SMC_NCDecoder POUを拡張し、サブルーチンと式をサポートします。 プロジェクトには2つのCNCプログラムが含まれています：メインプログラム CNC2Main.cnc およびサブプログラム CNC2.cnc 。メインプログラムは値を渡します 25 の中に #RADIUS サブプログラムへのパラメータ。サブプログラムでは、式 X#RADIUS*2 円形パスの計算に使用されます。 メインプログラム N0 G01 X$g_x$ Y0 F50 E30 E-30\nN10 G01 X0 Y$g_y$\nN20 CNC2{25}\nN30 G01 X0 Y-200 サブプログラム SUBPROGRAM CNC2{#RADIUS : LREAL}\nN010 G91\nN020 G02 X#RADIUS*2 Y0 R#RADIUS Z2.5 F100 E-100 E100\nN030 G02 X-#RADIUS*2 Y0 R#RADIUS Z7.5\nEND_SUBPROGRAM " }, 
{ "title" : "CNC 例 08: 追加軸の使用 ", 
"url" : "_sm_example_external_axes_usage.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 08: 追加軸の使用 ", 
"snippet" : "を参照してください CNC08_AdditionalAxes.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . この例は、 CNC01_direct.projekt で説明されているプロジェクト CNC 例 01: OutQueue を直接生成する.追加の軸を使用する方法を示します。 CNC 例 01 のように、定義された速度と加速度で X\/Y 平面内の 4 つの位置にアプローチします。さらに、各移動中に追加の軸 A が実行されます。プログラムは、パス上に 2 つのパス スイッチ ポイント...", 
"body" : "を参照してください CNC08_AdditionalAxes.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . この例は、 CNC01_direct.projekt で説明されているプロジェクト CNC 例 01: OutQueue を直接生成する.追加の軸を使用する方法を示します。 CNC 例 01 のように、定義された速度と加速度で X\/Y 平面内の 4 つの位置にアプローチします。さらに、各移動中に追加の軸 A が実行されます。プログラムは、パス上に 2 つのパス スイッチ ポイントを設定します。 " }, 
{ "title" : "エディターでのCNCプログラムの編集 ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4510557821784033079793683298", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 08: 追加軸の使用 \/ エディターでのCNCプログラムの編集 ", 
"snippet" : "を開きます CNC01_direct.project のインストールディレクトリからのプロジェクト CODESYS . プロジェクトで、CNCプログラムを開きます Example 。 追加の軸Aの位置を移動コマンドに追加します。 CNCエディター N0 G01 X82.9 Y 8.9 A20 F50 E30 E-30 N10 G02 X84.9 Y84.6 A40 R100 H12 L10 N20 G01 X 6.6 Y25.7 A60 H-1 O0.8 N30 G03 X54.6 Y49.7 A80 R100...", 
"body" : "を開きます CNC01_direct.project のインストールディレクトリからのプロジェクト CODESYS . プロジェクトで、CNCプログラムを開きます Example 。 追加の軸Aの位置を移動コマンドに追加します。 CNCエディター N0 G01 X82.9 Y 8.9 A20 F50 E30 E-30\nN10 G02 X84.9 Y84.6 A40 R100 H12 L10\nN20 G01 X 6.6 Y25.7 A60 H-1 O0.8\nN30 G03 X54.6 Y49.7 A80 R100 " }, 
{ "title" : "ドライブインターフェースとPLC構成の作成 ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4590758202758433079807306962", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 08: 追加軸の使用 \/ ドライブインターフェースとPLC構成の作成 ", 
"snippet" : "追加の仮想ドライブを挿入します A_Drive 下 SoftMotion一般軸プール 。 パラメータを次のように設定します。...", 
"body" : "追加の仮想ドライブを挿入します A_Drive 下 SoftMotion一般軸プール 。 パラメータを次のように設定します。 " }, 
{ "title" : "IECプログラムの編集 ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4590758311412833079809057524", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 08: 追加軸の使用 \/ IECプログラムの編集 ", 
"snippet" : "CFCプログラムを開く Ipo 。 以前に追加したドライブをアクティブ化する A_Drive とともに MC_Power ファンクションブロック。 この例では、単純な方向軸（ A_Drive ）追加の軸Aで制御する必要があります。このため、これ以上の変換モジュールは必要ありません。補間器の設定位置は、ドライブの設定位置に直接対応し、 SMC_POSINFO セレクター SMC_ControlAxisByPos ファンクションブロック。アプリケーションは、補間器の出力が連続していることを保証しません。たとえば、追加の軸の位置は、開始点とは異なるポイントで終了します。したがって、ギャップ回避を有効...", 
"body" : "CFCプログラムを開く Ipo 。 以前に追加したドライブをアクティブ化する A_Drive とともに MC_Power ファンクションブロック。 この例では、単純な方向軸（ A_Drive ）追加の軸Aで制御する必要があります。このため、これ以上の変換モジュールは必要ありません。補間器の設定位置は、ドライブの設定位置に直接対応し、 SMC_POSINFO セレクター SMC_ControlAxisByPos ファンクションブロック。アプリケーションは、補間器の出力が連続していることを保証しません。たとえば、追加の軸の位置は、開始点とは異なるポイントで終了します。したがって、ギャップ回避を有効にする必要があります（ bAvoidGaps 、 fGapVelocity 、 fGapAcceleration 、 と fGapDeceleration ）。次に、 bStopIpo に出力 bEmergency_Stop 補間器の入力と接続補間器の出力 iStatus 軸制御機能ブロックのそれぞれの入力に。 何よりも、CFCでプログラミングするときは、機能ブロックの正しい順序に注意してください。 " }, 
{ "title" : "試運転 ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4584880865328033079813143466", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 08: 追加軸の使用 \/ 試運転 ", 
"snippet" : "作成したプログラムをコンパイルして起動します。プログラムは、CNCモーションを実行するとすぐに Execute 補間器の入力が設定されました。プログラムが完全に実行されたら、新しい立ち上がりエッジを適用してプログラムを再起動できます。 CNCプログラムの実行中に、追加の軸Aの位置に注意してください（ piSetPosition.dA ）これは、補間POUの視覚化に表示されます。...", 
"body" : "作成したプログラムをコンパイルして起動します。プログラムは、CNCモーションを実行するとすぐに Execute 補間器の入力が設定されました。プログラムが完全に実行されたら、新しい立ち上がりエッジを適用してプログラムを再起動できます。 CNCプログラムの実行中に、追加の軸Aの位置に注意してください（ piSetPosition.dA ）これは、補間POUの視覚化に表示されます。 " }, 
{ "title" : "CNC 例 09: 工具長補正の使用 ", 
"url" : "_sm_example_tool_correction_usage.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 09: 工具長補正の使用 ", 
"snippet" : "を参照してください CNC09_ToolLengthCorr.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . この例では、 SMC_ToolLengthCorr 工具の長さを補正する POU。 工具長補正のトピックの詳細については、次を参照してください。 前処理...", 
"body" : "を参照してください CNC09_ToolLengthCorr.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . この例では、 SMC_ToolLengthCorr 工具の長さを補正する POU。 工具長補正のトピックの詳細については、次を参照してください。 前処理" }, 
{ "title" : "応用 ", 
"url" : "_sm_example_tool_correction_usage.html#UUID-1d022e7a-4834-0535-1cca-7cab7ecde5dd_section-idm458488080921763308005489139", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 09: 工具長補正の使用 \/ 応用 ", 
"snippet" : "この例では、Gantry3キネマティックが追加された方向軸（ AxisA ）Z軸を中心に回転できます。次に、Z方向に2単位の長さの工具が、配向軸に取り付けられます。 簡単なCNCプログラムを実行する必要があります。これは外部としてプロジェクトに保存されます CNC.cnc ファイルであり、テキストエディタで開くことができます。 CNCプログラムでは、工具長補正は最初にGコードによってアクティブ化されます G43 。 The I 、 J 、 と K パラメータは、このためのX、Y、およびZ方向のオフセットに対応します。次に、XY平面で3つのポイントが移動します。最後のポイントへの移動中に、追加の...", 
"body" : "この例では、Gantry3キネマティックが追加された方向軸（ AxisA ）Z軸を中心に回転できます。次に、Z方向に2単位の長さの工具が、配向軸に取り付けられます。 簡単なCNCプログラムを実行する必要があります。これは外部としてプロジェクトに保存されます CNC.cnc ファイルであり、テキストエディタで開くことができます。 CNCプログラムでは、工具長補正は最初にGコードによってアクティブ化されます G43 。 The I 、 J 、 と K パラメータは、このためのX、Y、およびZ方向のオフセットに対応します。次に、XY平面で3つのポイントが移動します。最後のポイントへの移動中に、追加の軸Aも90度回転します。 N000 G43 I0 J0 K2 (Activate tool length correction with tool offset X=0 Y=0 Z=2)\nN010 G01 X10 F10 E100 E-100\nN020 G03 Y10 R5N030 G01 X0 A90 アプリケーションは複数の部分で構成されています。の中に CNC_PreparePath プログラム、CNCプログラム CNC.cnc コントローラからファイルとしてインポートされ、前処理されます。の中に CNC プログラムでは、他の例のように、ドライブが最初にオンになります。次に、以前に読み取ったCNCプログラムの補間が実行されます。各サイクルで、補間器は設定された位置を出力します (piSetPosition ）およびツールの現在のオフセット (adToolLength ）。 The SMC_ToolLengthCorr POUは、指定された工具長を補正するためにこの情報を必要とします。次に、補正された位置が変換され、最終的に軸に渡されます。 SMC_ControlAxisByPos POU。 プログラムは他の例とほとんど同じです。のみ SMC_ToolLengthCorr POUは、補間器によって出力された設定位置を処理するために、補間器の後、変換の前に挿入されています。 " }, 
{ "title" : "試運転 ", 
"url" : "_sm_example_tool_correction_usage.html#UUID-1d022e7a-4834-0535-1cca-7cab7ecde5dd_section-idm4590758219934433080059282556", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 例 09: 工具長補正の使用 \/ 試運転 ", 
"snippet" : "作成したプログラムをコンパイルして起動します。プログラムはすぐにCNCの動きを実行します CNC_PreparePath.xStart 入力が設定されました。あなたはクリックすることができます 始める ボタンをクリックして、アプリケーションまたはビジュアライゼーションでこの変数を設定します。プログラムが完全に実行されたら、新しい立ち上がりエッジを適用してプログラムを再起動できます。 CNCプログラムの実行中に、補間器の出力に注意してください（ piSetPosition 、 adToolLength ）および補正された位置（ piOut ）の SMC_ToolLengthCorr POU。 注...", 
"body" : "作成したプログラムをコンパイルして起動します。プログラムはすぐにCNCの動きを実行します CNC_PreparePath.xStart 入力が設定されました。あなたはクリックすることができます 始める ボタンをクリックして、アプリケーションまたはビジュアライゼーションでこの変数を設定します。プログラムが完全に実行されたら、新しい立ち上がりエッジを適用してプログラムを再起動できます。 CNCプログラムの実行中に、補間器の出力に注意してください（ piSetPosition 、 adToolLength ）および補正された位置（ piOut ）の SMC_ToolLengthCorr POU。 注：の回転 AxisA この例では、CNCプログラムの最後の移動中に、補正されたデカルト位置に（追加の）影響はありません。これは、ツールがZ方向にオフセットしかないためです。ツールのオフセット（CNCファイル内、アプリケーションフォルダー内のコントローラー上）にX方向とY方向にコンポーネントを追加すると、 AxisA 最後の動きの間、補正された位置に追加の効果があります。 " }, 
{ "title" : "インターポレータの状態を読み込む ", 
"url" : "_sm_example_state_interpolator.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ インターポレータの状態を読み込む ", 
"snippet" : "を参照してください CNC13_ReadInterpolatorState.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下に ..\\CODESYS SoftMotion\\Examples 。 サンプルプロジェクトでは、CNC 補間器の状態を読み取る方法を示しています。ステートは、マシン座標とデコーダー座標の両方におけるマシンの位置の表示に使用されます...", 
"body" : "を参照してください CNC13_ReadInterpolatorState.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下に ..\\CODESYS SoftMotion\\Examples 。 サンプルプロジェクトでは、CNC 補間器の状態を読み取る方法を示しています。ステートは、マシン座標とデコーダー座標の両方におけるマシンの位置の表示に使用されます " }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_example_state_interpolator.html#UUID-7d495950-6d6e-d3d4-336b-0d7c83f08247_section-id235234546899564", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ インターポレータの状態を読み込む \/ アプリケーションの構造 ", 
"snippet" : "この構造はCNCアプリケーションでは一般的です。G コードはバックグラウンドタスクで読み込まれます。補間はバスタスクで実行されます 補間中、 SMC_ReadAdditionalIpoState ファンクションブロックが呼び出されました。 補間が始まるとすぐに、 Valid 出力は TRUE 。常にマシン座標系 (MCS) で出力される補間器の位置が、現在のデコーダー座標系 (DCS) を使用して変換され SMC_V3_Set(pos_MCS, ipo.piSetPosition.dX, ipo.piSetPosition.dY, ipo.piSetPosition.dZ); readStat...", 
"body" : "この構造はCNCアプリケーションでは一般的です。G コードはバックグラウンドタスクで読み込まれます。補間はバスタスクで実行されます 補間中、 SMC_ReadAdditionalIpoState ファンクションブロックが呼び出されました。 補間が始まるとすぐに、 Valid 出力は TRUE 。常にマシン座標系 (MCS) で出力される補間器の位置が、現在のデコーダー座標系 (DCS) を使用して変換され SMC_V3_Set(pos_MCS, ipo.piSetPosition.dX, ipo.piSetPosition.dY, ipo.piSetPosition.dZ);\n\nreadState(\n    Enable:= TRUE,\n    ipo:= ipo);\n\nIF readState.Valid THEN\n    SMC_PosInfo_Trf_Inverse(\n        piOut:= piMCS_to_DCS,\n        piIn:= readState.State.DCS,\n        eOriConv:= readState.State.OriConv);\n\n SMC_PosInfo_Trf_Apply(\n        vDst:= pos_DCS,\n        piTrf:= piMCS_to_DCS,\n        vSrc:= pos_MCS,\n        eOriConv:= readState.State.OriConv);\nEND_IF デコーダー座標系の詳細については、以下を参照してください。 座標系のシフト、回転、およびスケーリング. " }, 
{ "title" : "コミッショニング ", 
"url" : "_sm_example_state_interpolator.html#UUID-7d495950-6d6e-d3d4-336b-0d7c83f08247_section-id235234714771807", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ インターポレータの状態を読み込む \/ コミッショニング ", 
"snippet" : "アプリケーションをビルドし、コントローラーにダウンロードします。 ビジュアライゼーションを開きます。 アプリケーションを起動し、を押します 開始 ビジュアライゼーションのボタン。 MCS と DCS の X 座標と Y 座標の動きを追跡できます。...", 
"body" : "アプリケーションをビルドし、コントローラーにダウンロードします。 ビジュアライゼーションを開きます。 アプリケーションを起動し、を押します 開始 ビジュアライゼーションのボタン。 MCS と DCS の X 座標と Y 座標の動きを追跡できます。 " }, 
{ "title" : "パス前処理ファンクションブロックの実装 ", 
"url" : "_sm_example_cnc14_path_preprocessing.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ パス前処理ファンクションブロックの実装 ", 
"snippet" : "を参照してください CNC14_PathPreprocessing.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下に ..\\CODESYS SoftMotion\\Examples 。 サンプルプロジェクトは、新しいパス前処理関数ブロックを実装する方法を示しています。 パスの前処理は通常、Gコードから読み取られたパスを変更するために使用されます。これにより、工具半径補正やコーナースムージングなどの機能を実装できます。ただし、特定のマシンまたはアプリケーション用の特定の関数をパス前処理ファンクションブロックとして統合することもできます パスの前処理の詳細に...", 
"body" : "を参照してください CNC14_PathPreprocessing.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下に ..\\CODESYS SoftMotion\\Examples 。 サンプルプロジェクトは、新しいパス前処理関数ブロックを実装する方法を示しています。 パスの前処理は通常、Gコードから読み取られたパスを変更するために使用されます。これにより、工具半径補正やコーナースムージングなどの機能を実装できます。ただし、特定のマシンまたはアプリケーション用の特定の関数をパス前処理ファンクションブロックとして統合することもできます パスの前処理の詳細については、以下を参照してください。 パスの前処理とキューサイズ. パス前処理関数ブロックの使用方法の例については、以下を参照してください。 CNC 例 03: パスの前処理をオンラインで実行する. " }, 
{ "title" : "接線変更の制限 ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234576416031", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ パス前処理ファンクションブロックの実装 \/ 接線変更の制限 ", 
"snippet" : "この例は、2D カッティングアプリケーションを示しています。Gコードで定義された経路に沿って切断するには、ナイフを使用する必要があります。は SMC_TRAFO_GantryCutter2 トランスフォームを使用して、パスの現在の接線に基づいてナイフの角度を決定します。 課題は、ナイフの回転が速すぎないようにすることです。さもないと、切れ目がきれいになりません。ナイフの角速度の制限は、サンプルプロジェクトで新しく作成されたパス前処理関数ブロックを使用して解決されています LimitTangentVelocity 。接線の変化速度が設定可能な最大値を超えないように、経路上の送り速度を変更します ...", 
"body" : "この例は、2D カッティングアプリケーションを示しています。Gコードで定義された経路に沿って切断するには、ナイフを使用する必要があります。は SMC_TRAFO_GantryCutter2 トランスフォームを使用して、パスの現在の接線に基づいてナイフの角度を決定します。 課題は、ナイフの回転が速すぎないようにすることです。さもないと、切れ目がきれいになりません。ナイフの角速度の制限は、サンプルプロジェクトで新しく作成されたパス前処理関数ブロックを使用して解決されています LimitTangentVelocity 。接線の変化速度が設定可能な最大値を超えないように、経路上の送り速度を変更します Gコードは、角が滑らかになったシンプルな長方形です。 トレースには実行結果が表示されます。ナイフの回転速度に対応するC軸の速度がオレンジ色で表示されます。指定どおりに 45°\/s に制限されています " }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234546899564", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ パス前処理ファンクションブロックの実装 \/ アプリケーションの構造 ", 
"snippet" : "この構造はCNCアプリケーションでは一般的です。G コードはバックグラウンドタスクで読み込まれ、パスの前処理もここで行われます。補間はバスタスクで実行されます。 ザ・ LimitTangentVelocity 関数ブロックには、パス前処理関数ブロックに必要なステップと状態が表示されます。 基本的な原則は、関数ブロックがパス要素 (type) を読み取り、処理してから書き込むことです。 SMC_GEOINFO ) 入力キューから ( poqDataIn () を出力キュー () に送ります。 poqDataOut )。要素は入力キューから削除されます。 送り速度を変更するロジックは 102 行目...", 
"body" : "この構造はCNCアプリケーションでは一般的です。G コードはバックグラウンドタスクで読み込まれ、パスの前処理もここで行われます。補間はバスタスクで実行されます。 ザ・ LimitTangentVelocity 関数ブロックには、パス前処理関数ブロックに必要なステップと状態が表示されます。 基本的な原則は、関数ブロックがパス要素 (type) を読み取り、処理してから書き込むことです。 SMC_GEOINFO ) 入力キューから ( poqDataIn () を出力キュー () に送ります。 poqDataOut )。要素は入力キューから削除されます。 送り速度を変更するロジックは 102 行目から 138 行目にあります。補助機能です。 ComputeMaxCurvature 特定のパスエレメントで発生する可能性がある最大曲率を計算します。 \/\/ Our velocity limitation comes here. This modifies an element from the\n\/\/ input queue and copies the modified element to the output queue.\n\/\/ Finally, the element is removed from the input queue\n\nm_geo := pgeo^; \/\/ Copy the element\n \/\/ Note: the feature flags set in the G-Code with G38\/G39 can be queried\n \/\/ by reading pgo^.dwFeatureFlags, like this:\n IF (SHR(m_geo.dwFeatureFlags, featureFlag) AND 1) = 1 THEN\n     \/\/ feature is turned on\n\n     ok := ComputeMaxCurvature(m_geo, kappa=> kappa_max);\n     IF NOT ok THEN\n         \/\/ Curvature cannot be computed\n         m_state := STATE_ERROR;\n         ErrorID := SMC_INVALID_PARAMETER;\n         OnExit();\n         RETURN;\n     END_IF\n\n     \/\/ Compute maximum allowed path velocity based on maximum curvature\n     \/\/ and maximum allowed angular velocity\n     IF kappa_max = 0 THEN\n         \/\/ No curvature, no limitation necessary\n         vel := m_geo.dVel;\n     ELSE\n         vel := m_maxAngularVelocity_rad \/ kappa_max;\n     END_IF\n\n     IF velMin < 0 OR vel < velMin THEN\n         velMin := vel;\n     END_IF\n\n     \/\/ Set new maximum velocity for the element\n     m_geo.dVel := MIN(m_geo.dVel, vel);\n ELSE\n     \/\/ feature is turned off\n END_IF " }, 
{ "title" : "コミッショニング ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234584108811", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ パス前処理ファンクションブロックの実装 \/ コミッショニング ", 
"snippet" : "アプリケーションをビルドし、コントローラーにダウンロードします。 アプリケーションを起動します。 トレースを開き、コントローラにダウンロードします。 値を書き込む TRUE 変数に Path.bExecute と PLC_PRG.bStart 。 トレース内のGコードの処理を追跡できます。...", 
"body" : "アプリケーションをビルドし、コントローラーにダウンロードします。 アプリケーションを起動します。 トレースを開き、コントローラにダウンロードします。 値を書き込む TRUE 変数に Path.bExecute と PLC_PRG.bStart 。 トレース内のGコードの処理を追跡できます。 " }, 
{ "title" : "大容量Gコードファイルの前処理 ", 
"url" : "_sm_example_large_c_code.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ 大容量Gコードファイルの前処理 ", 
"snippet" : "ザ・ CNC15_LargeGCode.project サンプルプロジェクトは、のインストールディレクトリにあります。 CODESYS 下に ..\\CODESYS SoftMotion\\Examples 。 サンプルプロジェクトは、大きなGコードファイルを処理する方法を示しています。非常に大きなファイルは CAD\/CAM システムからの出力として特に一般的であるため、このケースを例として示します CAD\/CAMシステムは、数十万行のGコードファイルを生成することがよくあります。これらは非常に短い線形セグメント G1 ）、通常は100マイクロメートルから1ミリメートルの範囲です。これらの短い直線...", 
"body" : "ザ・ CNC15_LargeGCode.project サンプルプロジェクトは、のインストールディレクトリにあります。 CODESYS 下に ..\\CODESYS SoftMotion\\Examples 。 サンプルプロジェクトは、大きなGコードファイルを処理する方法を示しています。非常に大きなファイルは CAD\/CAM システムからの出力として特に一般的であるため、このケースを例として示します CAD\/CAMシステムは、数十万行のGコードファイルを生成することがよくあります。これらは非常に短い線形セグメント G1 ）、通常は100マイクロメートルから1ミリメートルの範囲です。これらの短い直線セグメントはワークピースの輪郭をトレースします。それらは滑らかな経路を形成しません。通常、接線は直線セグメント間を移動します。 この例は、一定のメモリ要件でこれらの大きなファイルを効率的に読み取る方法と、非常に多くの短い線形セグメントで構成されるパス上で滑らかな速度曲線を実現する方法を示しています。G コードを前処理している間に、ワークピースの元の輪郭が再構築されます " }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231424931037", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ 大容量Gコードファイルの前処理 \/ アプリケーションの構造 ", 
"snippet" : "この構造はCNCアプリケーションでは一般的です。G コードはバックグラウンドタスクで読み込まれます PathTask )、そしてパスの前処理もここで行われます。補間はバスタスク ( MainTask )。...", 
"body" : "この構造はCNCアプリケーションでは一般的です。G コードはバックグラウンドタスクで読み込まれます PathTask )、そしてパスの前処理もここで行われます。補間はバスタスク ( MainTask )。 " }, 
{ "title" : "大容量ファイルの読み取り ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425324995", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ 大容量Gコードファイルの前処理 \/ 大容量ファイルの読み取り ", 
"snippet" : "Gコード処理開始時のレイテンシを短くするために、バックグラウンドタスクではループが使用されます。わかりやすくするために、中止条件にはカウンタを使用します。アプリケーション、G コード、PLC のパフォーマンスによっては、タイマーなどの他の中止条件が役立つ場合があります。パスキューがいっぱいになると、この中止条件に達する前にループは終了します \/\/ Set this value depending on your other tasks, PLC performance, and G-Code counter := 25; WHILE counter > 0 AND       (poqData...", 
"body" : "Gコード処理開始時のレイテンシを短くするために、バックグラウンドタスクではループが使用されます。わかりやすくするために、中止条件にはカウンタを使用します。アプリケーション、G コード、PLC のパフォーマンスによっては、タイマーなどの他の中止条件が役立つ場合があります。パスキューがいっぱいになると、この中止条件に達する前にループは終了します \/\/ Set this value depending on your other tasks, PLC performance, and G-Code\ncounter := 25;\n\nWHILE counter > 0 AND\n      (poqDataOut = 0 OR_ELSE (NOT poqDataOut^.bFull AND NOT poqDataOut^.bEndOfList))\nDO\n     <Read G-Code and process it>\n\n     counter := counter - 1;\nEND_WHILE のパイプライン処理によって 前処理 、非常に大きなGコードファイルでも、必要なメモリが少なくて一定であれば読み取ることができます。キューサイズは、それぞれのファンクションブロックが十分に予測できるように十分に大きくなるように選択されます の出力キュー SMC_NCInterpreter の入力キューでもあります SMC_SmoothMerge 。合計128+3個のエレメントが出力キュー用に予約されています。3個は出力キューの予備です SMC_OutQueue そして128は予測としてまだ使われています SMC_SmoothMerge 。 SMC_SmoothMerge 最大 128 個の短い線形セグメントを 1 つのスプラインに結合します。 の出力キュー SMC_SmoothMerge は、の入力キューでもあります。 SMC_SmoothPath 。 SMC_SmoothPath 、少なくとも 2 つの要素と 3 つの予備要素が必要です。M 関数が平滑化された 2 つの要素の間にある場合、M 関数の数に応じてさらに多くの要素が必要になります の出力キュー SMC_SmoothMerge は、の入力キューでもあります。 SMC_Interpolator 。100 要素の予測はほとんどのアプリケーションに適しています。詳細については、以下を参照してください パスの前処理とキューサイズ。 \/\/\/ Buffer of the interpreter, lookahead for SMC_SmoothMerge\naBufIp : ARRAY[0..130] OF SMC_GeoInfo;\n\/\/\/ Buffer of SMC_SmoothMerge\naBufSmm : ARRAY[0..15] OF SMC_GeoInfo;\n\/\/\/ Buffer of SMC_SmoothPath, lookahead for SMC_Interpolator\naBufSmp : ARRAY[0..99] OF SMC_GeoInfo; " }, 
{ "title" : "線形セグメントの前処理 ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425764624", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ 大容量Gコードファイルの前処理 \/ 線形セグメントの前処理 ", 
"snippet" : "ザ・ SMC_SmoothMerge ファンクションブロックは、多数の非常に短い線形セグメントで滑らかな速度曲線を保証します。指定された許容値を維持しながら、できるだけ多くの連続する線形セグメントを 1 つのスプラインに結合します。この例では、X と Y の最大偏差は 0.1 mm PARAMETERS.piMaxDifference )。 図は段階的な処理を示しています。 短い線形セグメントの読み取り を使用して複数の線形セグメントをスプラインに結合する SMC_SmoothMerge 。 によるスプライン間のスムージング SMC_SmoothPath これは、前述のように、スプライン同士が...", 
"body" : "ザ・ SMC_SmoothMerge ファンクションブロックは、多数の非常に短い線形セグメントで滑らかな速度曲線を保証します。指定された許容値を維持しながら、できるだけ多くの連続する線形セグメントを 1 つのスプラインに結合します。この例では、X と Y の最大偏差は 0.1 mm PARAMETERS.piMaxDifference )。 図は段階的な処理を示しています。 短い線形セグメントの読み取り を使用して複数の線形セグメントをスプラインに結合する SMC_SmoothMerge 。 によるスプライン間のスムージング SMC_SmoothPath これは、前述のように、スプライン同士が接線方向に接続されていないためです。 " }, 
{ "title" : "コミッショニング ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425998344", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ 大容量Gコードファイルの前処理 \/ コミッショニング ", 
"snippet" : "アプリケーションをビルドし、コントローラーにダウンロードします。 トレースを開き、コントローラにダウンロードします。 アプリケーションを起動します。 Gコードの処理を追跡できます。...", 
"body" : "アプリケーションをビルドし、コントローラーにダウンロードします。 トレースを開き、コントローラにダウンロードします。 アプリケーションを起動します。 Gコードの処理を追跡できます。 " }, 
{ "title" : "CNC 事例16: プロービング機能 (残り距離をクリア) (G31) ", 
"url" : "_sm_example_cnc_16.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 事例16: プロービング機能 (残り距離をクリア) (G31) ", 
"snippet" : "を参照してください CNC16_G31.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下に ..\\CODESYS SoftMotion\\Examples 。 サンプルプロジェクトでは、プロービング機能 (残り距離をクリア) の使用方法を示しています。 この例では、マシンはライトバリアに達するまでX方向に移動します X=50 。光の障壁に達するとすぐに、機械は停止しなければなりません。残りのGコードは、この位置から処理を開始する必要があります...", 
"body" : "を参照してください CNC16_G31.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下に ..\\CODESYS SoftMotion\\Examples 。 サンプルプロジェクトでは、プロービング機能 (残り距離をクリア) の使用方法を示しています。 この例では、マシンはライトバリアに達するまでX方向に移動します X=50 。光の障壁に達するとすぐに、機械は停止しなければなりません。残りのGコードは、この位置から処理を開始する必要があります " }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_example_cnc_16.html#UUID-78892014-10dd-8256-9708-05f2d78a2884_section-id235224424924168", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 事例16: プロービング機能 (残り距離をクリア) (G31) \/ アプリケーションの構造 ", 
"snippet" : "この構造はCNCアプリケーションでは一般的です。G コードはバックグラウンドタスクで読み込まれます PathTask )。このタスクではパスの前処理も行われます。補間はバスタスク () で行われます。 MainTask )。 次のGコードが使用されています。ブロック内 N10 、迅速な位置決めが行われます X = 20 。そして、G31 (プロービング機能:残った経路をクリア) で、次のような動きをします X = 100 。最後に、ブロックで N30 、直線的な動きが作られます X = 20, Y = 50 。 N10 G0 X20 F100 E1000 E-1000 N20 G31 X100...", 
"body" : "この構造はCNCアプリケーションでは一般的です。G コードはバックグラウンドタスクで読み込まれます PathTask )。このタスクではパスの前処理も行われます。補間はバスタスク () で行われます。 MainTask )。 次のGコードが使用されています。ブロック内 N10 、迅速な位置決めが行われます X = 20 。そして、G31 (プロービング機能:残った経路をクリア) で、次のような動きをします X = 100 。最後に、ブロックで N30 、直線的な動きが作られます X = 20, Y = 50 。 N10 G0 X20 F100 E1000 E-1000\nN20 G31 X100\nN30 G1 X20 Y50 補間器とインタプリタ間の相互作用は、プロービング機能にとって特に重要です（残りの経路をクリア）。 インタープリターはGコードをデコードし、次のコードから直線を生成します X=20 に X=100 ブロック用 N20 。その後、デコードを停止します インターポレータは直線運動を行い、同時にプローブ番号を出力します udiActProbe 。G31 の場合、サンプル番号は常に 1 です アプリケーションでは、補間器は次のように停止します。 bQuick_Stop ドライブが位置を超えて移動するとすぐに X=50 。(これはライトバリアをシミュレートします。 バスタスクでは、 SMC_SetInterpreterStartPosition ファンクションブロックは、マシンの現在位置を継続的にコピーするために使用されます。 の中に PathTask 、開始位置が入力に割り当てられます。 SMC_NCInterpreter.piStartPosition : inter(\n    sentences:= read.sentences,\n    bExecute:= read.bExecute,\n    nSizeOutQueue:= SIZEOF(bufIpo),\n    pbyBufferOutQueue:= ADR(bufIpo),\n    piStartPosition:= Main.setStart.StartPos); 補間器が停止するとすぐに、 bAcknProbe 入力は G31 コマンドの確認に使用されます。実際のアプリケーションでは、この時点で軸が実際に停止位置に達したかどうかも確認する必要があります。は SMC_InPosition これにはファンクションブロックを使用できます。 これにより、インタープリターはデコードを再開しますが、開始位置が更新され、次のブロックになります N30 位置から開始されます。 X=55.5 。 次の図は、これらのステップを示しています。括弧内の数字は、上で説明したプロセスの対応するステップを示しています。 " }, 
{ "title" : "コミッショニング ", 
"url" : "_sm_example_cnc_16.html#UUID-78892014-10dd-8256-9708-05f2d78a2884_section-id235224425037675", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC 事例16: プロービング機能 (残り距離をクリア) (G31) \/ コミッショニング ", 
"snippet" : "アプリケーションをビルドし、コントローラーにダウンロードします。 トレースを開き、コントローラにダウンロードします。 アプリケーションを起動し、ビジュアライゼーションを開きます。...", 
"body" : "アプリケーションをビルドし、コントローラーにダウンロードします。 トレースを開き、コントローラにダウンロードします。 アプリケーションを起動し、ビジュアライゼーションを開きます。 " }, 
{ "title" : "CNC の例 17: 文字列からの G コードの読み取り ", 
"url" : "_sm_example_cnc_17.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC の例 17: 文字列からの G コードの読み取り ", 
"snippet" : "を参照してください CNC17_ReadGCodeFromStrings.project 以下のCODESYSのインストールディレクトリにあるサンプルプロジェクト ..\\CODESYS SoftMotion\\Examples 。 サンプルプロジェクトは使用方法を示しています SMC_StringStream2 文字列から G コードを読み取ります。 この例は出発点と見なすことができ、ネットワーク通信（ソケット）などを介して他のソースからGコードを読み取るために使用できます。この場合、以下を実装するファンクションブロックを実装する必要があります。 SMC_ITextStream インターフェース...", 
"body" : "を参照してください CNC17_ReadGCodeFromStrings.project 以下のCODESYSのインストールディレクトリにあるサンプルプロジェクト ..\\CODESYS SoftMotion\\Examples 。 サンプルプロジェクトは使用方法を示しています SMC_StringStream2 文字列から G コードを読み取ります。 この例は出発点と見なすことができ、ネットワーク通信（ソケット）などを介して他のソースからGコードを読み取るために使用できます。この場合、以下を実装するファンクションブロックを実装する必要があります。 SMC_ITextStream インターフェースを作成し、テキスト (ソケットなどから) を読み取ります。これは方法と似ています SMC_StringStream2 このインターフェイスを実装して、文字列から G コードを読み取ります。 " }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_example_cnc_17.html#UUID-7c947453-e422-10bd-3720-9f55e7b54f9f_section-id235224424924168", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC の例 17: 文字列からの G コードの読み取り \/ アプリケーションの構造 ", 
"snippet" : "この構造はCNCアプリケーションでは一般的です。G コードはバックグラウンドタスクで読み込まれます PathTask )、そしてパスの前処理もここで行われます。補間はバスタスクで実行されます の中に Path プログラム、 SMC_ReadNCFromStream ファンクションブロックは G コードの読み取りに使用されます。技術的な理由から、タイプのストリームだけではありません SMC_StringStream2 この関数ブロックに渡されるだけでなく、パラメータによってサイズが決まる配列も渡されます。 SMC_CNC_LibParams.MAX_SUBPROGRAM_NESTING_DEPT...", 
"body" : "この構造はCNCアプリケーションでは一般的です。G コードはバックグラウンドタスクで読み込まれます PathTask )、そしてパスの前処理もここで行われます。補間はバスタスクで実行されます の中に Path プログラム、 SMC_ReadNCFromStream ファンクションブロックは G コードの読み取りに使用されます。技術的な理由から、タイプのストリームだけではありません SMC_StringStream2 この関数ブロックに渡されるだけでなく、パラメータによってサイズが決まる配列も渡されます。 SMC_CNC_LibParams.MAX_SUBPROGRAM_NESTING_DEPTH 。配列の最初のストリームはメインプログラムに使用され、他のストリームはサブプログラムの呼び出しに使用されます 最初に、メインプログラムは配列の最初のストリームにロードされます。 \/\/ Load G-Code into first stream\naStringStream[0].Init(sProgramName) ;\naStringStream[0].AppendData(sGCode) ;\naStringStream[0].SetEndOfData() ; これで、通常のGコードプログラムを読むための準備がすべて整います。また、この例ではサブプログラム呼び出しをどのようにサポートできるかも示しています そのためには、以下を実装する関数ブロックを作成する必要があります。 SMC_INCLookup インターフェイス。このファンクションブロックは、サブプログラムが読み取られたときにサブプログラムの G コードを返す役割を果たします SMC_ReadNCFromStream 。ザ・ Lookup メソッドはサブプログラムの名前を受け取り、受信ストリームを G コードで初期化します。 METHOD LookUp : SMC_ERROR\nVAR_IN_OUT CONSTANT\n    programName : STRING;\nEND_VAR\nVAR_INPUT\n    stream : SMC_ITextStream;\nEND_VAR\nVAR\n    i : UDINT ;\n    pStringStream : POINTER TO SMC_StringStream2 ;\nEND_VAR この例では、サブプログラムの配列を検索します。この配列は次のように定義されています。 Path プログラムとして VAR_INPUT : \/\/ The table of subprograms.\n aSubs : ARRAY[0..0] OF SubProgram := [\n            (stName := 'SUB1',\n             stContent := '\nSUBPROGRAM SUB1{#p1 : LREAL, #p2 : LREAL, #p3 : LREAL}\nN10 G1 X#p1\nN20 G1 X#p2\nN30 G1 X#p3\nEND_SUBPROGRAM')\n        ] ; で Lookup 、一致する名前のサブプログラムが見つかるまで、配列が繰り返し処理されます。 i := 0 ;\nWHILE i < nNumSPs DO\n IF psp[i].stName = programName THEN\n IF NOT __QUERYPOINTER(stream, pStringStream) OR_ELSE\n pStringStream = 0\n THEN\n \/\/ A stream of the wrong type has been passed by SMC_ReadNCFromStream.\n LookUp := SMC_CNC_INTERNAL_ERROR ;\n ELSE\n pStringStream^.Init(sName := psp[i].stName) ;\n LookUp := pStringStream^.AppendData(psp[i].stContent) ;\n pStringStream^.SetEndOfData() ;\n END_IF\n RETURN ;\n END_IF\n\n i := i + 1 ;\nEND_WHILE\n \n\/\/ No subprogram with name programName has been found in the array psp.\nLookUp := SMC_RNCF_SUBPROGRAM_FILE_NOT_FOUND ; " }, 
{ "title" : "コミッショニング ", 
"url" : "_sm_example_cnc_17.html#UUID-7c947453-e422-10bd-3720-9f55e7b54f9f_section-id235224425037675", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC の例 17: 文字列からの G コードの読み取り \/ コミッショニング ", 
"snippet" : "アプリケーションをビルドし、コントローラーにダウンロードします。 ビジュアライゼーションを開きます。 プレス 開始 G コード処理を開始します。...", 
"body" : "アプリケーションをビルドし、コントローラーにダウンロードします。 ビジュアライゼーションを開きます。 プレス 開始 G コード処理を開始します。 " }, 
{ "title" : "CNC の例 10: 動的 CNC パスのプログラミング ", 
"url" : "_sm_example_dynamic_path.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ CNC の例 10: 動的 CNC パスのプログラミング ", 
"snippet" : "を参照してください CNC10_DynamicPath.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . この例では、CNC プログラム オブジェクトまたはファイルから G コードを入力せずに、実行時にアプリケーションで CNC パスを直接作成する方法を示します。この種の従来の CNC プログラムをコンパイルすると、パス データは SMC_CNC_Data データ構造タイプ。この内部データは、コンパイル モードに応じて特定のグローバル データ構造にコンパイルされます ( SMC_CNC_R...", 
"body" : "を参照してください CNC10_DynamicPath.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . この例では、CNC プログラム オブジェクトまたはファイルから G コードを入力せずに、実行時にアプリケーションで CNC パスを直接作成する方法を示します。この種の従来の CNC プログラムをコンパイルすると、パス データは SMC_CNC_Data データ構造タイプ。この内部データは、コンパイル モードに応じて特定のグローバル データ構造にコンパイルされます ( SMC_CNC_REF また SMC_OutQueue ）。 コンパイルモードの場合 SMC_CNC_REF 、データはの配列に格納されます SMC_GEOINFO 要素。アプリケーションコードの配列は通常、関数ブロックインスタンスに渡されます SMC_NCDecoder 。実行時に、データはそこでデコードされ、タイプのグローバルデータ構造に格納されます SMC_OUTQUEUE 。次に、パス前処理機能ブロックを呼び出すことができます。 コンパイルモードの場合 SMC_OutQueue 、グローバルデータ構造（ SMC_OUTQUEUE ）が生成されます 直接 。アプリケーションコード内のこのデータ構造は、補間器に渡されます（ SMC_Interpolator FBインスタンス）。機能ブロック SMC_NCDecoder は呼び出されません。 コンパイルモードの場合 ファイル 、データはファイルに保存されます。データは、タイプの要素の配列として格納されます SMC_GEOINFO コンパイルモードで生成されたデータに対応します SMC_CNC_REF 。 CNCパスをプログラミングする代わりに、タイプのデータ構造をインスタンス化するアプリケーションコードをプログラミングできます。 SMC_OUTQUEUE 実行時に、その値を割り当てます。実行時に動的に生成されるCNCパスをプログラムします。データ構造を他の汎用ブロックインスタンス（たとえば、パス前処理汎用ブロックまたは汎用ブロック）に渡すことができます。 SMC_Interpolator ）。 プログラミング The CNCDynamicPath サンプルプロジェクトは、のインストールディレクトリにあります。 CODESYS 。サンプルプロジェクトは、 CNConline 事業。それは含まれています Path グラフィカルにプログラムされた代わりにプログラム Example 道。タイプのデータ構造 SMC_OUTQUEUE 動的に生成されます。 宣言： タイプのデータ構造を宣言します SMC_OUTQUEUE 。データ構造にはCNCパスデータが含まれており、動的に入力されます。 例： QUEUE 必要な量のパスにメモリを割り当てます。 SMC_GEOINFO 要素。 例： BUF タイプの変数を宣言します SMC_GEOINFO 最初のステップで。 例： GEO 実装： データ型の配列要素 SMC_GEOINFO CNCコードのパス要素に対応します。要素をに追加するには、要素ごとに次の手順を実行する必要があります。 SMC_OUTQUEUE ： すべての配列要素には、前の配列要素の終了位置に対応する開始位置があります。 例： GEO.piStartPos.dX := 0; また GEO.piStartPos := GEO.piDestPos; 各配列要素の移動タイプを決定します。 例： GEO.iMoveType := CCLW; また GEO.iMoveType := LIN; 移動タイプのパラメータを設定します。これは、すべての移動タイプに必要なわけではありません。 例：円弧（移動タイプ：CCLW）の場合、次の位置を設定する必要があります。 geoinfo_A[i].dP1 := 200; geoinfo_A[i].dP2 := 100; geoinfo_A[i].dP3 := 50; geoinfo_A[i].dT1 := 0; geoinfo_A[i].dT2 := 90; 終了位置の計算を挿入します。 SMC_CalcEndPnt(ADR(GEO)); オブジェクトの長さの計算を挿入します。 SMC_CalcLengthGeo(ADR(GEO)); オブジェクトをに保存します QUEUE ： SMC_AppendObj(POQ:=ADR(QUEUE), PGI:=ADR(GEO)); パスが完全に作成されたら、終了マーカーを設定する必要があります。 QUEUE-bEndOfList = TRUE; 次に、パス前処理機能ブロックが呼び出されると、の開始ビットまたは終了ビットを設定する必要があります。 InternMark 。 例 2つのパス要素を持つCNCパス この例では、配列はX \/ Y位置で定義されていません。説明したようにこれが2つのパス要素を持つ例である場合、これらの配列にはそれぞれ2つの要素が必要です。 たとえば、サンプルプロジェクトから派生したもの： xp:ARRAY[1..2] OF REAL:= [100,50]; yp:ARRAY[1..2] OF REAL:= [0,100]; PROGRAM Path\nVAR\n iState : INT;\n QUEUE : SMC_OUTQUEUE;\n BUF : ARRAY[0..49] OF SMC_GEOINFO;\n \/\/ Memory allocation\n GEO : SMC_GEOINFO:=(dT1:=0, dT2:=1, dToolRadius:=0, dVel:=100, dVel_End:=100, dAccel:=200, dDecel:=500, iObj_Nr:=0);\n \/\/ Initial path element\n n : INT := 0;\n QUEUE.nSize := SIZEOF(BUF);\nEND_VAR\n\nCASE iState OF\n0:\n QUEUE.pbyBuffer := ADR(BUF[0]);\n \/\/ Initialize QUEUE\n SMC_SetQueueCapacity(ADR(QUEUE), SIZEOF(BUF));\n iState := iState + 1;\n\n1:\n \/\/ Fill QUEUE\n WHILE NOT QUEUE.bFull DO\n \/\/ When QUEUE is full, wait until it has been processed by the following FBs\n n := n + 1;\n GEO.iSourceLine_No := n;\n GEO.piStartPos := GEO.piDestPos;\n \/\/ Copying last destination\n GEO.iMoveType := LIN;\n \/\/ Generating linear movement\n GEO.iObjNo := GEO.iObjNo + 1;\n \/\/ Calculating number\n GEO.piDestPos.dX := xp[n];\n \/\/ Generatint position\n GEO.piDestPos.dY := yp[n];\n SMC_CalcLengthGeo(pg := ADR(GEO));\n \/\/ Calculating length of object with the help of the standard function\n SMC_AppendObj(poq:=ADR(QUEUE), pgi:=ADR(GEO));\n \/\/ Appending object to QUEUE\n IF n = SIZEOF(xp)\/SIZEOF(xp[1]) THEN\n \/\/ All target positions processed\n QUEUE.bEndOfList := TRUE;\n n := 0;\n iState := 2;\n EXIT;\n END_IF\n END_WHILE\n\n2:\n \/\/Done\n ;\nEND_CASE\n\nCheckVel(bExecute:=TRUE , poqDataIn:=ADR(queue)); \/\/ Preprocessing の場合 SMC_OUTQUEUE データ構造には次のデータが入力されます SMC_GEOINFO データとデータ構造要素がに設定されました bFULL = TRUE 、その後の割り当てはお勧めしません SMC_GEOINFO データ。この場合、パスの作成は、実行時に、の最初の要素まで中断されます。 SMC_OUTQUEUE データ構造は補間器で処理されます。その場合にのみ、別の要素が挿入されます。 十分なメモリを割り当てることにより、この中断を回避してください。変数を参照してください BUF 。 データ構造の場合 SMC_OUTQUEUE 最初の実行後に補充され、次に補間器とすべての前処理機能ブロックが補充されます（例： SMC_CheckVelocities ）で立ち上がりエッジで再起動する必要があります Execute 。 " }, 
{ "title" : "ブロック検索の使用 ", 
"url" : "_sm_example_using_block_search.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ ブロック検索の使用 ", 
"snippet" : "ブロック検索により、中断後も補間を続行できます。停止位置が最初に移動し、パスはこの位置から変更されずに移動します。このためには、補間を実行するプログラムとパス前処理を実行するプログラムを拡張する必要があります。 例 中断されたフライス盤が移動を停止します。修復後、パスはブロック検索を続行できます。 次の方法でアプリケーションを拡張します 前処理位置を保存する補間タスクの機能ブロックインスタンス パス要素を短縮するパスタスクの機能ブロックインスタンス 詳細については、SMC_BlockSearchSavePos、SMC_BlockSearchPos、およびSMC_BlockSearchを参照して...", 
"body" : "ブロック検索により、中断後も補間を続行できます。停止位置が最初に移動し、パスはこの位置から変更されずに移動します。このためには、補間を実行するプログラムとパス前処理を実行するプログラムを拡張する必要があります。 例 中断されたフライス盤が移動を停止します。修復後、パスはブロック検索を続行できます。 次の方法でアプリケーションを拡張します 前処理位置を保存する補間タスクの機能ブロックインスタンス パス要素を短縮するパスタスクの機能ブロックインスタンス 詳細については、SMC_BlockSearchSavePos、SMC_BlockSearchPos、およびSMC_BlockSearchを参照してください。 ブロック検索の使用 のインスタンス SMC_BlockSearch 関数ブロックは、残りのパスの前処理と同じタスクで、通常は直前に呼び出す必要があります。 SMC_CheckVelocities ファンクションブロック。立ち上がりエッジが存在する場合 bExecute 、次にブロック検索が実行されます。開始後、保存された位置が移動し、パスはこの位置から変更されずに移動します。 のインスタンスを宣言します SMC_BlockSearch パス前処理が実行するプログラムの機能ブロック。 bs: SMC_BlockSearch; のトリガーを実装します bExecute の入力 SMC_BlockSearch 実例。 以前に保存された位置 SMC_BlockSearchSavePos 関数ブロックは、として渡される必要があります epos の入力 SMC_BlockSearch ファンクションブロック。 例：パス前処理でのブロック検索 PROGRAM CNC_PreparePath\n...\nVAR\n bs: SMC_BlockSearch;\nEND_VAR\n...\nbs(\n ePos:=CNC.bssp.ePos ,\n bExecute:=rncf.bExecuteDecoder ,\n bAbort:= ,\n bAppend:= ,\n poqDataIn:=ncd.poqDataOut ,\n bStartFromSavedPos:=CNC.bssp.bPositionStored ,\n nSizeOutQueue:=SIZEOF(agiBufBlockSearch) ,\n pbyBufferOutQueue:=ADR(agiBufBlockSearch) ,\n bDone=> ,\n bBusy=> ,\n bError=> ,\n wErrorID=> ,\n poqDataOut=> ); NS bStartFromSavedPos 入力は、制御変数を使用してアクティブにすることもできます。キャンセル後、最後に保存した位置から再開するために、制御変数をアクティブにすることができます。 " }, 
{ "title" : "前処理位置の保存 ", 
"url" : "_sm_example_using_block_search.html#UUID-c7e93ecd-388f-baf1-4162-0ba994d84585_id_defc89f86dbffeecc0a86463490ce87e_id_04188a3f3bea4adbc0a8640e000b4984", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ ブロック検索の使用 \/ 前処理位置の保存 ", 
"snippet" : "あなたは使用することができます SMC_BlockSearchSavePos コマンドの現在位置を保存するための機能ブロック。このとき、関数ブロックのインスタンスは補間器のタスクで実行する必要があります。この例の補間プログラムの名前は「CNC」です。 のインスタンスを宣言します SMC_BlockSearchSavePos 補間が実行するプログラムの機能ブロック。 bssp: SMC_BlockSearchSavePos; 接続します ipo の入力 SMC_BlockSearchSavePos 補間インスタンスへのインスタンス。 接続します bExecute CNCプログラムがキャンセルされ...", 
"body" : "あなたは使用することができます SMC_BlockSearchSavePos コマンドの現在位置を保存するための機能ブロック。このとき、関数ブロックのインスタンスは補間器のタスクで実行する必要があります。この例の補間プログラムの名前は「CNC」です。 のインスタンスを宣言します SMC_BlockSearchSavePos 補間が実行するプログラムの機能ブロック。 bssp: SMC_BlockSearchSavePos; 接続します ipo の入力 SMC_BlockSearchSavePos 補間インスタンスへのインスタンス。 接続します bExecute CNCプログラムがキャンセルされたときにアプリケーションで設定される制御変数への入力（たとえば、 bAbort SMC_Interpolatorインスタンスの入力が設定されました）。に保存されている位置 ePos 出力は、次の方法によるブロック検索に使用されます。 SMC_BlockSearc 。中断後、 bExecute 立ち上がりエッジでリセットする必要があります。 例 のインスタンスで補間を実行するプログラムの一部 SMC_BlockSearchSavePos CFCの機能ブロック。 " }, 
{ "title" : "トークン修飾子付きの NCFile2 の読み取り ", 
"url" : "_sm_example_readncfile2_token_modifier.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ トークン修飾子付きの NCFile2 の読み取り ", 
"snippet" : "ザル CNC12_TokenModifier.project サンプルプロジェクトは、のインストールディレクトリにあります。 CODESYS 下に ..\\CODESYS SoftMotion\\Examples 。 この例では、インポート時にGコードを変更して、経路速度 (Fワード) の単位をmm\/minからmm\/sに変換する方法を示します。これは、Gコードを挿入することによって行われます。 1\/60.0 * FワードのGコードを読み込んでいる間、ベロシティ値の前。 F6000 すると、次のようになります。 F 1\/60.0 * 6000 、これは後でによって処理されます。 SMC_NCInte...", 
"body" : "ザル CNC12_TokenModifier.project サンプルプロジェクトは、のインストールディレクトリにあります。 CODESYS 下に ..\\CODESYS SoftMotion\\Examples 。 この例では、インポート時にGコードを変更して、経路速度 (Fワード) の単位をmm\/minからmm\/sに変換する方法を示します。これは、Gコードを挿入することによって行われます。 1\/60.0 * FワードのGコードを読み込んでいる間、ベロシティ値の前。 F6000 すると、次のようになります。 F 1\/60.0 * 6000 、これは後でによって処理されます。 SMC_NCInterpreter へのファンクションブロック F100 。単純なケースでは、以下のように掛け算を省略できます 1\/60 そして、値を調整するだけです (たとえば、 6000 に 100 )。ただし、乗算は変数を使用する場合にも機能するため、より一般的です F $SPEED$ になります F 1\/60.0 * $SPEED$ 。 " }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869818233271", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ トークン修飾子付きの NCFile2 の読み取り \/ アプリケーションの構造 ", 
"snippet" : "CNC アプリケーションではよくあることですが、このアプリケーションにはパス処理が含まれます ( CNC_PreparePath プログラム) と補間 () CNC プログラム)。補間は他の例と変わらないので、ここではこれ以上説明しません パス処理は、低優先度では 20 ミリ秒ごとに周期的に呼び出されます。 PathTask 。高優先度では、補間は 4 ミリ秒ごとに周期的に呼び出されます MotionTask 。バックグラウンドタスク VISU_TASK ビジュアライゼーション用に定義されています。 ビジュアライゼーションで G コードの処理を開始できます。G コードと機械の動き (3D ガン...", 
"body" : "CNC アプリケーションではよくあることですが、このアプリケーションにはパス処理が含まれます ( CNC_PreparePath プログラム) と補間 () CNC プログラム)。補間は他の例と変わらないので、ここではこれ以上説明しません パス処理は、低優先度では 20 ミリ秒ごとに周期的に呼び出されます。 PathTask 。高優先度では、補間は 4 ミリ秒ごとに周期的に呼び出されます MotionTask 。バックグラウンドタスク VISU_TASK ビジュアライゼーション用に定義されています。 ビジュアライゼーションで G コードの処理を開始できます。G コードと機械の動き (3D ガントリー) がビジュアライゼーションの右側に表示されます " }, 
{ "title" : "Gコード ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869818432406", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ トークン修飾子付きの NCFile2 の読み取り \/ Gコード ", 
"snippet" : "CNC_PathSpeed N10 G01 X1000 F6000 N20 Y1000 このGコードでは、ブロック単位の経路速度 N10 と設定されています。 F6000 6000 ミリメートル\/分までただし、CNC ファンクションブロックでは mm\/s 単位の経路速度を想定しているため、まず 2 つの直線運動が指示されます。 X=1000 そしてそれから X=1000, Y=1000 。...", 
"body" : "CNC_PathSpeed N10 G01 X1000 F6000\nN20 Y1000 このGコードでは、ブロック単位の経路速度 N10 と設定されています。 F6000 6000 ミリメートル\/分までただし、CNC ファンクションブロックでは mm\/s 単位の経路速度を想定しているため、まず 2 つの直線運動が指示されます。 X=1000 そしてそれから X=1000, Y=1000 。 " }, 
{ "title" : "トークン処理 ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869819460923", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ トークン修飾子付きの NCFile2 の読み取り \/ トークン処理 ", 
"snippet" : "ザル SMC_ReadNCFile2 そして SMC_ReadNCFromStream ファンクションブロックを使用すると、G コードの読み取り時に独自の変換を実行できます。ここでは、と一緒に使用しています SMC_ITokenModifier インターフェイスを介して渡されます。 aTokenModifier 入力。 このインターフェースは「トークン」で動作します。これらはGコードの基本部分で、処理が開始されるとGコードのテキストが細分化されます 例 N50 G36 O$plc_variable$ D'TextTest' X-1 (Comment) このGコードは次のように分類されます。 テ...", 
"body" : "ザル SMC_ReadNCFile2 そして SMC_ReadNCFromStream ファンクションブロックを使用すると、G コードの読み取り時に独自の変換を実行できます。ここでは、と一緒に使用しています SMC_ITokenModifier インターフェイスを介して渡されます。 aTokenModifier 入力。 このインターフェースは「トークン」で動作します。これらはGコードの基本部分で、処理が開始されるとGコードのテキストが細分化されます 例 N50 G36 O$plc_variable$ D'TextTest' X-1 (Comment) このGコードは次のように分類されます。 テキスト SMC_TOKENTYPE SMC_TOKENVALUE N identifer stValue = 'N' 50 number fValue = 50.0 G identifer stValue = 'G' 36 number fValue = 36.0 O identifer stValue = 'O' $plc_variable$ variable stValue = 'plc_variable' D identifer stValue = 'D' 'TextTest' strLiteral stValue = 'TextTest' X identifer stValue = 'X' - operator stValue = '-' 1 number fValue = 1.0 以降の処理に必要のない情報 (空白文字、改行、コメントなど) は、トークンのリストに表示されません。 いつ SMC_ITokenModifier インタフェースが実装され、新しいトークンの追加、トークンの削除、トークンの値を変更することで、トークンのリストを調整できます。 このインターフェースは次の 2 つのメソッドを定義します。 Start : ファンクションブロックの初期化。内部状態がリセットされます Call : Gコードの処理中にこのメソッドを呼び出します。トークンは読み込んで、入力キューから削除し、出力キューに追加できます " }, 
{ "title" : "実装 ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869819739016", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ トークン修飾子付きの NCFile2 の読み取り \/ 実装 ", 
"snippet" : "PLC_PRGの処理フローは次のとおりです。 すべてのトークンが入力キューから出力キューに移動されます。 F ワードが検出されると、2 つの新しいトークンが、 1\/60 そして * 、は「F」のトークンの後に、速度値のトークンの前に追加されます。 ザル Call メソッドにはトークンを処理するロジックが含まれています。まず、入力キューからトークンを移動すると便利です ( tokensIn () を一時キューへ () m_tmpQueue )、そこで処理し、出力キューに移動する ( tokensOut )。テンポラリキューはパス速度を調整するために絶対に必要なわけではありませんが、複雑なケースで...", 
"body" : "PLC_PRGの処理フローは次のとおりです。 すべてのトークンが入力キューから出力キューに移動されます。 F ワードが検出されると、2 つの新しいトークンが、 1\/60 そして * 、は「F」のトークンの後に、速度値のトークンの前に追加されます。 ザル Call メソッドにはトークンを処理するロジックが含まれています。まず、入力キューからトークンを移動すると便利です ( tokensIn () を一時キューへ () m_tmpQueue )、そこで処理し、出力キューに移動する ( tokensOut )。テンポラリキューはパス速度を調整するために絶対に必要なわけではありませんが、複雑なケースではプログラム構造を簡略化できます 方法:コール 最初は、システムが待機します STATE_RUNNING 処理が開始されるまでの状態 (入力キューにトークンがあり、出力キューにまだ空きがある場合)。 IF NOT SMC_NC_CanProcessTokens(tokensIn, tokensOut) THEN\n    \/\/ Wait until processing can proceed\n    RETURN;\nEND_IF その後、トークンは入力キューから一時キューに移動されます。 IF m_tmpQueue.IsEmpty() THEN\n    \/\/ Move the next token from the in-queue to the tmp-queue.\n  pt := tokensIn.GetFromStart(0);\n    m_tmpQueue.Append(pt^);\n    tokensIn.RemoveFirst();\nEND_IF 実際の処理は ConvertSpeed メソッド。 IF NOT m_tmpQueue.IsEmpty() THEN\n    \/\/ The actual processing is done here\n    ConvertSpeed();\nEND_IF メソッドの最後に、トークンは一時キューから出力キューに移動されます。 方法:変換速度 テンポラリキューの最初のトークンがチェックされます。 値を持つ識別子の場合 F が見つかると、さらに 2 つのトークン (数値) が追加されます。 1\/60.0 そしてオペレーター * 。 (テンポラリキューのサイズは、入力キューの 1 つのトークンに加えて、さらに 2 つのトークンがキューに収まるように選択されます)。 tk := m_tmpQueue.GetFromStart(0)^;\n\nIF tk.tokenType = SMC_TokenType.identifier THEN\n tk.GetString(pbyString => pby, iSize => iSize);\n \/\/ 70 = ASCII code for F (path velocity)\n IF iSize = 1 AND pby^ = 70 THEN\n \/\/ Insert the number 1\/60\n SMC_Token_InitNumber(\n tk:= tkNumber,\n value:= 1\/60.0,\n srcPos:= tk.srcPos);\n m_tmpQueue.Append(tkNumber);\n\n \/\/ Insert operator '*' for multiplication\n SMC_Token_InitOperator(\n tk:= tkOperator,\n value:= '*',\n srcPos:= tk.srcPos);\n m_tmpQueue.Append(tkOperator);\n END_IF\nEND_IF " }, 
{ "title" : "コミッショニング ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869820021001", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ トークン修飾子付きの NCFile2 の読み取り \/ コミッショニング ", 
"snippet" : "アプリケーションをビルドし、コントローラーにダウンロードします。 アプリケーションを起動し、ビジュアライゼーションに切り替えて、を押します Start 。...", 
"body" : "アプリケーションをビルドし、コントローラーにダウンロードします。 アプリケーションを起動し、ビジュアライゼーションに切り替えて、を押します Start 。 " }, 
{ "title" : "ユーザー固有のGコード機能 ", 
"url" : "_sm_custom_g_code_functions.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ ユーザー固有のGコード機能 ", 
"snippet" : "ザル CNC11_CustomFunctions.project サンプルプロジェクトは、のインストールディレクトリにあります。 CODESYS 下に ..\\CODESYS SoftMotion\\Examples 。 この例は、Gコードの式で使用する独自の関数を作成する方法を示しています。 Gコードの式と関数の詳細については、以下を参照してください。 式.ここには、デフォルトでサポートされているすべての演算子と関数のリストが表示されます。 この例では以下のように定義しています。 SEL IEC 61131-3のオペレータなので、Gコードでも使用できます。...", 
"body" : "ザル CNC11_CustomFunctions.project サンプルプロジェクトは、のインストールディレクトリにあります。 CODESYS 下に ..\\CODESYS SoftMotion\\Examples 。 この例は、Gコードの式で使用する独自の関数を作成する方法を示しています。 Gコードの式と関数の詳細については、以下を参照してください。 式.ここには、デフォルトでサポートされているすべての演算子と関数のリストが表示されます。 この例では以下のように定義しています。 SEL IEC 61131-3のオペレータなので、Gコードでも使用できます。 " }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867931475267", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ ユーザー固有のGコード機能 \/ アプリケーションの構造 ", 
"snippet" : "CNC アプリケーションではよくあることですが、このアプリケーションにはパス処理が含まれます ( CNC_PreparePath プログラム) と補間 () CNC プログラム)。補間は他の例と変わらないため、このトピックについてはここではこれ以上説明しません パス処理は、低優先度では 20 ミリ秒ごとに周期的に呼び出されます。 PathTask 。高優先度では、補間は 4 ミリ秒ごとに周期的に呼び出されます MotionTask 。バックグラウンドタスク VISU_TASK ビジュアライゼーション用に定義されています。 ビジュアライゼーションでは、Gコードの処理を開始して変数の値を設定できま...", 
"body" : "CNC アプリケーションではよくあることですが、このアプリケーションにはパス処理が含まれます ( CNC_PreparePath プログラム) と補間 () CNC プログラム)。補間は他の例と変わらないため、このトピックについてはここではこれ以上説明しません パス処理は、低優先度では 20 ミリ秒ごとに周期的に呼び出されます。 PathTask 。高優先度では、補間は 4 ミリ秒ごとに周期的に呼び出されます MotionTask 。バックグラウンドタスク VISU_TASK ビジュアライゼーション用に定義されています。 ビジュアライゼーションでは、Gコードの処理を開始して変数の値を設定できます $LONGLINE$ 。G コードと機械の動き (3D ガントリー) がビジュアライゼーションの右側に表示されます " }, 
{ "title" : "Gコード ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867932695176", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ ユーザー固有のGコード機能 \/ Gコード ", 
"snippet" : "CNC LET #WIDTH : LREAL N10 G36 O#WIDTH D SEL($LONGLINE$, 40, 110) N20 F50 E100 E-100 N30 G01 X#WIDTH Y#WIDTH Z#WIDTH\/2 N40 Y-#WIDTH N50 X-#WIDTH Z-#WIDTH\/2 N60 Y#WIDTH N70 X0 Y0 Z0 1行目:ローカル変数の宣言 #WIDTH タイプの LREAL 。 2行目、ブロックN10: の値の割り当て SEL($LONGLINE$, 40, 110) 変数に #WIDTH 。PLC 変数の値の場合 $LONGLINE$ は TR...", 
"body" : "CNC LET #WIDTH : LREAL\nN10 G36 O#WIDTH D SEL($LONGLINE$, 40, 110)\nN20 F50 E100 E-100\nN30 G01 X#WIDTH Y#WIDTH Z#WIDTH\/2\nN40 Y-#WIDTH\nN50 X-#WIDTH Z-#WIDTH\/2\nN60 Y#WIDTH\nN70 X0 Y0 Z0 1行目:ローカル変数の宣言 #WIDTH タイプの LREAL 。 2行目、ブロックN10: の値の割り当て SEL($LONGLINE$, 40, 110) 変数に #WIDTH 。PLC 変数の値の場合 $LONGLINE$ は TRUE その場合、式の値は 110 です。それ以外の場合は 40 です。 次の行では、Z 方向にさらに移動した長方形がトラバースされます。長方形の片側の長さは 2*#WIDTH 。 " }, 
{ "title" : "の実装 SEL ファンクション ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867935164437", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ ユーザー固有のGコード機能 \/ の実装 SEL ファンクション ", 
"snippet" : "ユーザー定義関数を作成するには、以下を実装する関数ブロックを作成する必要があります。 SMC_NC_IFunction インターフェイス。 詳細については、以下を参照してください。 SMC_NC_IFunction 。 このインターフェースは次の 2 つのメソッドを定義します。 GetSignature 。戻り値の型、カウント、および関数の引数の型がここに返されます。この例では、 SEL 関数は次の型の値を返します。 T_OTHER と、3 つのタイプの引数があります T_BOOL 、 T_OTHER 、および T_OTHER 。 T_OTHER 任意のタイプを表す (いずれか T_BOOL ...", 
"body" : "ユーザー定義関数を作成するには、以下を実装する関数ブロックを作成する必要があります。 SMC_NC_IFunction インターフェイス。 詳細については、以下を参照してください。 SMC_NC_IFunction 。 このインターフェースは次の 2 つのメソッドを定義します。 GetSignature 。戻り値の型、カウント、および関数の引数の型がここに返されます。この例では、 SEL 関数は次の型の値を返します。 T_OTHER と、3 つのタイプの引数があります T_BOOL 、 T_OTHER 、および T_OTHER 。 T_OTHER 任意のタイプを表す (いずれか T_BOOL 、 T_LREAL 、または T_STRING ]。の 3 つの出現すべて T_OTHER 同じタイプでなければなりません。 METHOD GetSignature\nVAR_OUTPUT\n    resultType : SMC_GVar_Type;\n    nNumArguments : UDINT;\n    pType : POINTER TO SMC_GVar_Type;\nEND_VAR\nVAR    argTypes : ARRAY[0..2] OF SMC_GVar_Type :=\n        [SMC_GVar_Type.T_BOOL,\n         SMC_GVar_Type.T_OTHER,\n         SMC_GVar_Type.T_OTHER];\nEND_VAR\n\nresultType := SMC_GVAR_Type.T_OTHER;\nnNumArguments := 3;\npType := ADR(argTypes); Call : このメソッドは、G コードの処理中に呼び出されます。引数はを介して渡されます pa 入力。エクスプレッション pa[0].argValue.bValue 番目の引数のブール値にアクセスするために使用されます。2 番目の引数の型によって異なります。 pa[1].argType 、結果は戻り値です。 result.argType そして CASE ステートメントへの分岐。 METHOD Call\nVAR_IN_OUT\n    result : SMC_NC_GArgument;\nEND_VAR\nVAR_INPUT\n    pa : POINTER TO SMC_NC_GArgument;\nEND_VA\nRVAR_OUTPUT\n    eError : SMC_ERROR;\nEND_VAR\nVAR\n    g : BOOL;\nEND_VAR\n\ng := pa[0].argValue.bValue;\n\nresult.argType := pa[1].argType;\n\nCASE result.argType OF\nSMC_GVAR_Type.T_BOOL:\n    result.argValue.bValue := SEL(g, pa[1].argValue.bValue, pa[2].argValue.bValue);\n\nSMC_GVAR_Type.T_STRING:\n    result.argValue.sValue := SEL(g, pa[1].argValue.sValue, pa[2].argValue.sValue);\n\nSMC_GVAR_Type.T_LREAL:\n    result.argValue.fValue := SEL(g, pa[1].argValue.fValue, pa[2].argValue.fValue);\n\nELSE\n    eError := SMC_INVALID_PARAMETER;\nEND_CASE " }, 
{ "title" : "の構成 SMC_ReadNCFile2 ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867956933133", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ ユーザー固有のGコード機能 \/ の構成 SMC_ReadNCFile2 ", 
"snippet" : "のインスタンス CNC_Sel ファンクションブロックは、に作成されます。 GVL_CNCFunctions グローバル変数リスト。 配列 aCNCFunctions 長さ 1 は関数ブロックの名前とインスタンスで初期化されます。その後、この配列はテーブル内でリンクされます。 funTable タイプの SMC_NC_GFunctionTable 。 aCNCFunctions : ARRAY[0..0] OF SMC_NC_GFunction :=     [(stName:= 'SEL', iFunc:= GVL_CNCFunctions.g_Sel)]; funTable : SMC_N...", 
"body" : "のインスタンス CNC_Sel ファンクションブロックは、に作成されます。 GVL_CNCFunctions グローバル変数リスト。 配列 aCNCFunctions 長さ 1 は関数ブロックの名前とインスタンスで初期化されます。その後、この配列はテーブル内でリンクされます。 funTable タイプの SMC_NC_GFunctionTable 。 aCNCFunctions : ARRAY[0..0] OF SMC_NC_GFunction :=\n    [(stName:= 'SEL', iFunc:= GVL_CNCFunctions.g_Sel)];\n\nfunTable : SMC_NC_GFunctionTable :=\n    (numFunctions:= 1,     pFunction:= ADR(aCNCFunctions)) ; 最後に、このテーブルはに渡されます SMC_ReadNCFile2 ファンクションブロック: rncf2 : SMC_ReadNCFile2 := (bParenthesesAsComments:= FALSE);\n\n[...]\n\nrncf2(\n    bExecute:= TRUE,\n    sFileName:= sFileName,\n    pCustomFunTable:= ADR(funTable),\n    pvl:= ADR(varList)); " }, 
{ "title" : "コミッショニング ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867960408693", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ 例 \/ ユーザー固有のGコード機能 \/ の構成 SMC_ReadNCFile2 \/ コミッショニング ", 
"snippet" : "アプリケーションをビルドし、コントローラーにダウンロードします。 アプリケーションを起動し、ビジュアライゼーションに切り替えて、を押します Start 。 Longline 変数の値を設定するラジオボタン $LONGLINE$ Gコードで TRUE または FALSE 。...", 
"body" : "アプリケーションをビルドし、コントローラーにダウンロードします。 アプリケーションを起動し、ビジュアライゼーションに切り替えて、を押します Start 。 Longline 変数の値を設定するラジオボタン $LONGLINE$ Gコードで TRUE または FALSE 。 " }, 
{ "title" : "ユーザーインターフェース ", 
"url" : "_sm_cnc_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド：ダイナミクスを分析する ", 
"url" : "_sm_cmd_cnc_analyze_dynamics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：ダイナミクスを分析する ", 
"snippet" : "ダイナミクスを分析する 関数 ：このコマンドは、エディターでアクティブなCNCパスのダイナミクス解析を開始します。同時に、CNCパスの位置、速度、加速度、ジャークの寸法は時間に応じて決定され、それらはのタイムチャートに表示されます。 ダイナミクス解析 ダイアログ。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 CNCパスのダイナミクス解析を実行するには、パスの前処理の計算にエラーがあってはなりません。 詳細については、以下を参照してください。 前処理されたパスを表示する...", 
"body" : "ダイナミクスを分析する 関数 ：このコマンドは、エディターでアクティブなCNCパスのダイナミクス解析を開始します。同時に、CNCパスの位置、速度、加速度、ジャークの寸法は時間に応じて決定され、それらはのタイムチャートに表示されます。 ダイナミクス解析 ダイアログ。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 CNCパスのダイナミクス解析を実行するには、パスの前処理の計算にエラーがあってはなりません。 詳細については、以下を参照してください。 前処理されたパスを表示する" }, 
{ "title" : "ダイアログ：ダイナミクス解析 ", 
"url" : "_sm_cmd_cnc_analyze_dynamics.html#UUID-172573a8-7bc5-69ee-931b-3074ace95453_id_f14ff69a244133a5c0a8640e0144954d_id_72da7ed158aa22a9c0a864637a09d164", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：ダイナミクスを分析する \/ ダイアログ：ダイナミクス解析 ", 
"snippet" : "ダイアログの設定は、ダイナミクス解析を表示するためだけに使用され、CNCプログラムやCNC設定には影響しません。 ダイナミクス解析では、移動するパス全体について、位置、速度、加速度、およびジャークの次元の時間曲線が決定されます。タイムチャートは、同じ時間軸のダイアログに表示されます。ダイアログの設定が使用されます（プリセットまたは保存）。 ポジションチャート 選択した軸の位置曲線（黒） 赤い丸;パス要素の始まりを示します マーカーのツールチップは、それぞれのGコードまたはテーブルの行番号に関する情報を提供します。 速度チャート 選択した軸の速度曲線（青） 加速チャート 選択した軸の加速度曲線（...", 
"body" : "ダイアログの設定は、ダイナミクス解析を表示するためだけに使用され、CNCプログラムやCNC設定には影響しません。 ダイナミクス解析では、移動するパス全体について、位置、速度、加速度、およびジャークの次元の時間曲線が決定されます。タイムチャートは、同じ時間軸のダイアログに表示されます。ダイアログの設定が使用されます（プリセットまたは保存）。 ポジションチャート 選択した軸の位置曲線（黒） 赤い丸;パス要素の始まりを示します マーカーのツールチップは、それぞれのGコードまたはテーブルの行番号に関する情報を提供します。 速度チャート 選択した軸の速度曲線（青） 加速チャート 選択した軸の加速度曲線（緑） ジャークチャート 選択した軸のジャークカーブ（オレンジ） 設定は閉じたときに保存され、次にダイアログを開いたときに使用されます。たとえば、ズーム係数は曲線の一部のみを表示します。 時間曲線の一部にズームインします 別： NS + + NS + マウスホイール 時間曲線をズームアウトします 別： NS + - NS + マウスホイール CNCパス全体が表示されるように、時間曲線を拡大します 軸 軸の選択： X 、 Y 、 Z 、 A 、 B 、 C 、 A1(P) 、 A2(Q) 、 A3 (U) 、 A4(V) 、 A5(W) 、 A6 、 また 道 プリセット： X 軸 道 軸：パス位置、パス速度、パス加速度、およびパスジャークの表示 サイクルタイム[µs] の値 dwIpoTime の入力 SMC_Interpolator ファンクションブロック プリセット：値 サイクルタイム[µs] オブジェクト内 CNC設定 （タブ 事前補間 ） 速度モード の値 iVelMode の入力 SMC_Interpolator ファンクションブロック 台形 台形速度プロファイル シグモイド お気に入り 台形 、ただし、立ち上がりエッジまたは立ち下がりエッジは、同じサーフェスのsin²関数に置き換えられます。 この速度モードでは、制限値を約π\/ 2倍超えます。 シグモイド限定 お気に入り シグモイド 、ただし、パスを補間するための期間は、速度モードの場合と同じ長さです。 台形 。 ディフォルト 二次 ジャーク制限のある台形の加速プロファイル ジャークはで最大値に達します 最大ジャーク[u \/s³] 。これにより、2次速度プロファイルが得られます。位置プロファイルは、3次多項式で構成されます。その結果、速度プロファイルは放物線で構成され、加速度は線形セグメントで構成され、ジャークは水平線分で構成されます。 最大ジャーク[u \/s³] ジャーク制限 " }, 
{ "title" : "コマンド：DXFファイルからインポート ", 
"url" : "_sm_cmd_cnc_dxf_import.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：DXFファイルからインポート ", 
"snippet" : "DXFファイルからインポート 関数 ：コマンドはデフォルトのダイアログを開きます。ファイルを選択した後、 DXFファイルをインポートする DXFファイルのCNCエディターへのインポートを構成するためのダイアログが開きます。 電話 ： CNC メニュー 要件 ：CNCオブジェクトがエディターで開いています。 ファイルインポート時のDXF規格の制限 SPLINE 要素は正確にインポートされません。これらの枢機卿スプラインによって読み取られ、配置されるのは、制御点のみです。 外部参照はサポートされていません。 （これらは、内の他のDXFファイルへの参照です。 BLOCK エレメント。） 楕円は、X ...", 
"body" : "DXFファイルからインポート 関数 ：コマンドはデフォルトのダイアログを開きます。ファイルを選択した後、 DXFファイルをインポートする DXFファイルのCNCエディターへのインポートを構成するためのダイアログが開きます。 電話 ： CNC メニュー 要件 ：CNCオブジェクトがエディターで開いています。 ファイルインポート時のDXF規格の制限 SPLINE 要素は正確にインポートされません。これらの枢機卿スプラインによって読み取られ、配置されるのは、制御点のみです。 外部参照はサポートされていません。 （これらは、内の他のDXFファイルへの参照です。 BLOCK エレメント。） 楕円は、X \/ Y平面に存在する場合にのみサポートされます。 アーク（要素 ARC ）と円（要素 CIRCLE ）は、スケーリングがすべての空間軸（要素のパラメーター41、42、および43）で等しい場合にのみサポートされます。 INSERT ）。これは要素にも影響します POLYLINE と LWPOLYLINE アークを含む（パラメータ bulge 等しくない 0 ）。 ブロック参照（要素 INSERT ）は、スケーリングマトリックスがミラーでない場合にのみサポートされます。 （スケーリング係数の積は正でなければなりません。） エリア要素、ポリゴンメッシュ、およびポリフェースメッシュはサポートされていません。ソリッド要素（ SOLID 、…）もサポートされていません。 要素 MLINE （マルチライン）、 RAY 、 XLINE 、 と LEADER （引出線）はサポートされていません。 要素 TEXT 、 MTEXT 、 と DIMENSION サポートされていません。 線の幅、色、スタイル、および要素の可視性に関する情報は無視されます。 バイナリDXFファイル（ファイル拡張子 DXB ）はサポートされていません。 サポートされていない要素は、インポート時に（暗黙的に）無視されます。 " }, 
{ "title" : "ダイアログ：DXFファイルのインポート ", 
"url" : "_sm_cmd_cnc_dxf_import.html#UUID-ceb47740-324e-76a2-abd9-2d1fa27e1a26_id_fde6e1824400e36c0a8640e013dba7a_id_754451675df6e481c0a8646326153262", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：DXFファイルからインポート \/ ダイアログ：DXFファイルのインポート ", 
"snippet" : "レイヤー 製図のすべてのレイヤー。 DXFファイルのデータから決定 ：レイヤーがインポートされます。 最大ギャップサイズ 幾何学的要素の端点間の距離。点が相互接続されていると見なされるまで。 DXFファイルのデータから決定されます。 例： 0.001 CNCパスでプレビュー 選択したDXFファイルのデータは、CNCエディタにインポートされた方法で表示されます。表示用に選択されたレイヤーも考慮されます。 例： 意見 プレビューウィンドウで考慮されるレイヤーを切り替える。 x \/ y平面;表示用に選択 x \/ z平面 y \/ z平面 ボタン ' 輸入 ' データはCNCエディターにロードされ、既存...", 
"body" : "レイヤー 製図のすべてのレイヤー。 DXFファイルのデータから決定 ：レイヤーがインポートされます。 最大ギャップサイズ 幾何学的要素の端点間の距離。点が相互接続されていると見なされるまで。 DXFファイルのデータから決定されます。 例： 0.001 CNCパスでプレビュー 選択したDXFファイルのデータは、CNCエディタにインポートされた方法で表示されます。表示用に選択されたレイヤーも考慮されます。 例： 意見 プレビューウィンドウで考慮されるレイヤーを切り替える。 x \/ y平面;表示用に選択 x \/ z平面 y \/ z平面 ボタン ' 輸入 ' データはCNCエディターにロードされ、既存のCNCプログラムが置き換えられます。ブロック番号は自動的に割り当てられます。 CNCオブジェクトはその名前を保持します。 " }, 
{ "title" : "コマンド：CNC情報 ", 
"url" : "_sm_cmd_cnc_info.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：CNC情報 ", 
"snippet" : "CNC情報 関数 ：コマンドは プログラム<name>に関するCNC情報 ダイアログ。 電話 ： CNC メニュー オブジェクトのコンテキストメニュー（タイプ CNCプログラム ） 要件 ：CNCプログラムがエディターで開いています。 ダイアログ：生成されたコード ダイアログには、機能ブロックのコンパイルモードに応じて、アクティブなCNCプログラムのIEC初期化コードが表示されます。 SMC_OutQueue また SMC_CNC_REF 。 例：IEC初期化コード {attribute 'linkalways'} VAR_GLOBAL {attribute 'init_on_onlchang...", 
"body" : "CNC情報 関数 ：コマンドは プログラム<name>に関するCNC情報 ダイアログ。 電話 ： CNC メニュー オブジェクトのコンテキストメニュー（タイプ CNCプログラム ） 要件 ：CNCプログラムがエディターで開いています。 ダイアログ：生成されたコード ダイアログには、機能ブロックのコンパイルモードに応じて、アクティブなCNCプログラムのIEC初期化コードが表示されます。 SMC_OutQueue また SMC_CNC_REF 。 例：IEC初期化コード {attribute 'linkalways'}\nVAR_GLOBAL\n {attribute 'init_on_onlchange'}\n {attribute 'init_on_onlchange'}\n Example : SMC_CNC_REF := (nElements := 22, strProgramName := 'Example', piStartPosition := (iFrameNo:=0, wAuxData:=7, wSProfile:=0, dX:=0, dY:=0, dZ:=0, dA:=0, dB:=0, dC:=0, dA1:=0, dA2:=0, dA3:=0, dA4:=0, dA5:=0, dA6:=0), pgc := ADR(Example_D), xPartofLM := TRUE);\n {attribute 'blobinit'}\n {attribute 'init_on_onlchange'}\n Example_D : ARRAY[0..21] OF SMC_GCODE_WORD := [\n {p 35184372088832 }\n (byLetter := 78, fValue:=0, diValue:=0),\n {p 35184372088832 }\n (byLetter := 70, fValue:=0, diValue:=0),\n {p 35184372088832 }\n (byLetter := 69, fValue:=100, diValue:=100),\n {p 35184372088832 }\n (byLetter := 69, fValue:=-100, diValue:=-100),\n {p 35184372088832 }\n (byLetter := 128, fValue:=1, diValue:=1),\n {p 36283883716609 }\n (byLetter := 78, fValue:=0, diValue:=0),\n {p 36835250143233 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 38486665068545 }\n (byLetter := 88, pAdr := ADR(g_x), byVarType := ANY_TO_BYTE(__TYPEOF(g_x) + 32)),\n {p 36291399909377 }\n (byLetter := 89, fValue:=0, diValue:=0),\n {p 36842766336001 }\n (byLetter := 70, fValue:=50, diValue:=50),\n {p 36844913819649 }\n (byLetter := 69, fValue:=30, diValue:=30),\n {p 37396817117185 }\n (byLetter := 69, fValue:=-30, diValue:=-30),\n {p 35184372088832 }\n (byLetter := 128, fValue:=2, diValue:=2),\n {p 36833639530498 }\n (byLetter := 78, fValue:=10, diValue:=10),\n {p 36835787014146 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 36288178683906 }\n (byLetter := 88, fValue:=0, diValue:=0),\n {p 38488812552194 }\n (byLetter := 89, pAdr := ADR(g_y), byVarType := ANY_TO_BYTE(__TYPEOF(g_y) + 32)),\n {p 35184372088832 }\n (byLetter := 128, fValue:=3, diValue:=3),\n {p 36833639530499 }\n (byLetter := 78, fValue:=20, diValue:=20),\n {p 36835787014147 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 36288178683907 }\n (byLetter := 88, fValue:=0, diValue:=0),\n {p 36289789296643 }\n (byLetter := 89, fValue:=0, diValue:=0)];\nEND_VAR " }, 
{ "title" : "ダイアログ：<name>プログラムのCNC情報 ", 
"url" : "_sm_cmd_cnc_info.html#UUID-ad8caf78-e0cf-3500-0750-16c2eb5fabe7_id_dc9afe4124423d69c0a8640e01f781e8_id_fc2c1e2959841990c0a864630e5a26e5", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：CNC情報 \/ ダイアログ：<name>プログラムのCNC情報 ", 
"snippet" : "ダイアログには、指定したCNCプログラムに関する情報が表示されます。 プログラム名 例： Workpiece_1 機能ブロックのバージョン 例： 4.2.0.0 行数 例： 5 オブジェクトの数 例： 3 パスの長さ[単位] 例： 261.803398874992 期間[秒] 前処理されたパスを移動する時間（秒単位） 例： 10.158 要件：エラーのないパス前処理と正常に生成された補間ポイント 生成されたコードを表示する NS 生成されたコード ダイアログが開きます。 要件：プログラムにエラーが含まれていません。...", 
"body" : "ダイアログには、指定したCNCプログラムに関する情報が表示されます。 プログラム名 例： Workpiece_1 機能ブロックのバージョン 例： 4.2.0.0 行数 例： 5 オブジェクトの数 例： 3 パスの長さ[単位] 例： 261.803398874992 期間[秒] 前処理されたパスを移動する時間（秒単位） 例： 10.158 要件：エラーのないパス前処理と正常に生成された補間ポイント 生成されたコードを表示する NS 生成されたコード ダイアログが開きます。 要件：プログラムにエラーが含まれていません。 " }, 
{ "title" : "コマンド：ASCIIファイルからプログラムをロード ", 
"url" : "_sm_cmd_cnc_load_program_from_ascii_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：ASCIIファイルからプログラムをロード ", 
"snippet" : "ASCIIファイルからプログラムをロードする 関数 ：コマンドは ASCII CNCプログラムデータを含むファイルをCNCエディタに入力します。 CNCオブジェクトはその名前を保持します。 電話 ： CNC メニュー 要件 ：CNCオブジェクトがエディターで開いています。 このコマンドは、ファイルシステムを検索するためのデフォルトのダイアログを開きます。フィルタは、CNC、GCODE、またはTXTに設定する必要があります。選択したファイルがアクティブなCNCエディタにロードされます。既存のCNCプログラムはすべて上書きされます（別のクエリの後）。...", 
"body" : "ASCIIファイルからプログラムをロードする 関数 ：コマンドは ASCII CNCプログラムデータを含むファイルをCNCエディタに入力します。 CNCオブジェクトはその名前を保持します。 電話 ： CNC メニュー 要件 ：CNCオブジェクトがエディターで開いています。 このコマンドは、ファイルシステムを検索するためのデフォルトのダイアログを開きます。フィルタは、CNC、GCODE、またはTXTに設定する必要があります。選択したファイルがアクティブなCNCエディタにロードされます。既存のCNCプログラムはすべて上書きされます（別のクエリの後）。 " }, 
{ "title" : "コマンド：プログラムの移動 ", 
"url" : "_sm_cmd_cnc_move_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：プログラムの移動 ", 
"snippet" : "移動プログラム 関数 ：コマンドは 翻訳ベクトル CNCパスの動きを設定するためのダイアログ。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。...", 
"body" : "移動プログラム 関数 ：コマンドは 翻訳ベクトル CNCパスの動きを設定するためのダイアログ。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 " }, 
{ "title" : "制約 ", 
"url" : "_sm_cmd_cnc_move_program.html#UUID-67135dbc-74ff-3167-05ff-7a200cb0af34_id_f409bfb22439d072c0a8640e01561fb2_id_e69692297289ca8ec0a864631a178469", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：プログラムの移動 \/ 制約 ", 
"snippet" : "CNCパスの移動は、次の条件下で可能です。 使用しない 軸A、B、またはCの 変数の...", 
"body" : "CNCパスの移動は、次の条件下で可能です。 使用しない 軸A、B、またはCの 変数の " }, 
{ "title" : "ダイアログ：翻訳ベクトル ", 
"url" : "_sm_cmd_cnc_move_program.html#UUID-67135dbc-74ff-3167-05ff-7a200cb0af34_id_f409bfb22439d072c0a8640e01561fb2_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：プログラムの移動 \/ ダイアログ：翻訳ベクトル ", 
"snippet" : "すべての軸の座標での並進ベクトル X ディフォルト： 1.0000000 Y Z P Q U V W わかった これにより、CNCパスが移動します。さらに、G0コマンド（相対位置決めコマンド）が、最初の位置決めコマンドの前に、CNCプログラムの平行移動ベクトルの座標とともに挿入されます。位置決めコマンドは、G1、G2、G3、G5、G6、G8、G9、G10、G11、およびG92です。 G54、G55、またはG56コマンドがCNCプログラムの座標系をシフトする場合、引数はこれらのコマンドに適合されます。 G53までのドットのないブロックは、さらに調整する必要があります。 G56コマンドが最初の測位...", 
"body" : "すべての軸の座標での並進ベクトル X ディフォルト： 1.0000000 Y Z P Q U V W わかった これにより、CNCパスが移動します。さらに、G0コマンド（相対位置決めコマンド）が、最初の位置決めコマンドの前に、CNCプログラムの平行移動ベクトルの座標とともに挿入されます。位置決めコマンドは、G1、G2、G3、G5、G6、G8、G9、G10、G11、およびG92です。 G54、G55、またはG56コマンドがCNCプログラムの座標系をシフトする場合、引数はこれらのコマンドに適合されます。 G53までのドットのないブロックは、さらに調整する必要があります。 G56コマンドが最初の測位コマンドである場合、そのコマンドのみが適合されます。 ブロック番号は自動的に割り当てられます。 " }, 
{ "title" : "コマンド：CNCプログラムの番号を付け直します ", 
"url" : "_sm_cmd_cnc_renumber_cnc_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：CNCプログラムの番号を付け直します ", 
"snippet" : "CNCプログラムの番号を付け直す シンボル： 関数 ：このコマンドは、CNCプログラムのプログラム行の番号を更新します。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 番号は0から始まり、10ずつ増加します。ブロック番号のない各ブロックは番号を受け取ります。 G20ブロックのLコードが修正されました。...", 
"body" : "CNCプログラムの番号を付け直す シンボル： 関数 ：このコマンドは、CNCプログラムのプログラム行の番号を更新します。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 番号は0から始まり、10ずつ増加します。ブロック番号のない各ブロックは番号を受け取ります。 G20ブロックのLコードが修正されました。 " }, 
{ "title" : "コマンド：方向を反転 ", 
"url" : "_sm_cmd_cnc_reverse_direction.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：方向を反転 ", 
"snippet" : "方向を反転します 関数 ：コマンドはCNCプログラムを逆にし、パス要素を逆の順序で設定します。 CNCプログラムのブロック番号も自動的にリセットされます。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 制約 CNCパスの反転は、次の条件下で可能です。 CNCプログラムに前処理が選択されている場合、G41 \/ G42ブロックは逆プログラムで処理されます。G41はG42になり、G42はG41になります。修正の方向も逆になります。 CNCプログラムに開き角（2D要素の場合はパラメーターK、3D要素の場合はパラメーターT）で定義された円弧が含まれている場合、コマンドは正確...", 
"body" : "方向を反転します 関数 ：コマンドはCNCプログラムを逆にし、パス要素を逆の順序で設定します。 CNCプログラムのブロック番号も自動的にリセットされます。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 制約 CNCパスの反転は、次の条件下で可能です。 CNCプログラムに前処理が選択されている場合、G41 \/ G42ブロックは逆プログラムで処理されます。G41はG42になり、G42はG41になります。修正の方向も逆になります。 CNCプログラムに開き角（2D要素の場合はパラメーターK、3D要素の場合はパラメーターT）で定義された円弧が含まれている場合、コマンドは正確な逆円弧を生成しません。 CNCパスが次の方法でプログラムされている場合、反転することはできません。 逆転しない 軸A、B、またはCを使用する 変数の使用 ステップ抑制の呼び出し " }, 
{ "title" : "コマンド：プログラムを回転 ", 
"url" : "_sm_cmd_cnc_rotate_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：プログラムを回転 ", 
"snippet" : "プログラムのローテーション 関数 ：コマンドは 回転パラメータ CNCパスの回転が設定されているダイアログ。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。...", 
"body" : "プログラムのローテーション 関数 ：コマンドは 回転パラメータ CNCパスの回転が設定されているダイアログ。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 " }, 
{ "title" : "制約 ", 
"url" : "_sm_cmd_cnc_rotate_program.html#UUID-b9a9e82f-9e38-05fb-3bf2-345a94e26b09_id_b540ec0a8640e01ab500e_id_45841f775e56fd50c0a864632eb28d67", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：プログラムを回転 \/ 制約 ", 
"snippet" : "CNCパスの回転は、次の条件下で可能です。 使用しない 軸A、B、またはCの 変数の...", 
"body" : "CNCパスの回転は、次の条件下で可能です。 使用しない 軸A、B、またはCの 変数の " }, 
{ "title" : "ダイアログ：回転パラメータ ", 
"url" : "_sm_cmd_cnc_rotate_program.html#UUID-b9a9e82f-9e38-05fb-3bf2-345a94e26b09_id_b540ec0a8640e01ab500e_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：プログラムを回転 \/ ダイアログ：回転パラメータ ", 
"snippet" : "角度（度） を中心とした回転角（度単位） 回転軸 。 例： 与えられた Z軸を中心とした回転 X軸は右を指し、Y軸は下を指します。視線方向は回転軸に対してです（右手の法則）。 負の値の場合、回転は時計回りに実行されます。正の値の場合、回転は反時計回りに実行されます。 回転軸 回転軸の選択は、CNCパスの要素がすべて3D要素である場合にのみ可能です。 次の要素のいずれかのCNCパスに次のものが含まれている場合は選択できません。 G5スプライン 放物線 楕円 2Dアーク 回転軸はパラメータによって定義されます NS 、 Y 、 と Z 。 ディフォルト： NS ：0、 Y ：0、 Z ：1-> Z...", 
"body" : "角度（度） を中心とした回転角（度単位） 回転軸 。 例： 与えられた Z軸を中心とした回転 X軸は右を指し、Y軸は下を指します。視線方向は回転軸に対してです（右手の法則）。 負の値の場合、回転は時計回りに実行されます。正の値の場合、回転は反時計回りに実行されます。 回転軸 回転軸の選択は、CNCパスの要素がすべて3D要素である場合にのみ可能です。 次の要素のいずれかのCNCパスに次のものが含まれている場合は選択できません。 G5スプライン 放物線 楕円 2Dアーク 回転軸はパラメータによって定義されます NS 、 Y 、 と Z 。 ディフォルト： NS ：0、 Y ：0、 Z ：1-> Z軸を中心とした回転 X ディフォルト： 0.00000 Y ディフォルト： 0.00000 Z ディフォルト： 1.00000 わかった ローテーションが実行されます。ブロック番号は自動的に割り当てられます。 " }, 
{ "title" : "コマンド：スケールプログラム ", 
"url" : "_sm_cmd_cnc_scale_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：スケールプログラム ", 
"snippet" : "スケールプログラム 関数 ：コマンドは スケールプログラム CNCパスのスケーリングが設定されているダイアログ。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。...", 
"body" : "スケールプログラム 関数 ：コマンドは スケールプログラム CNCパスのスケーリングが設定されているダイアログ。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 " }, 
{ "title" : "制約 ", 
"url" : "_sm_cmd_cnc_scale_program.html#UUID-d8f93f90-76cd-f349-684b-7ab5ca0dd141_id_fc67fe112446a403c0a8640e01ee1047_id_1320e28c7289c9f2c0a864633d064770", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：スケールプログラム \/ 制約 ", 
"snippet" : "CNCパスのスケーリングは、次の条件下で可能です。 使用しない 軸A、B、またはCの 変数の...", 
"body" : "CNCパスのスケーリングは、次の条件下で可能です。 使用しない 軸A、B、またはCの 変数の " }, 
{ "title" : "ダイアログ：スケールプログラム ", 
"url" : "_sm_cmd_cnc_scale_program.html#UUID-d8f93f90-76cd-f349-684b-7ab5ca0dd141_id_fc67fe112446a403c0a8640e01ee1047_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：スケールプログラム \/ ダイアログ：スケールプログラム ", 
"snippet" : "スケーリングファクター ディフォルト： 0.001 条件：スケーリング係数> = 1e-3 倍率が1より大きい場合は、拡大されます。 軸 ：軸がスケーリングされます。 D（工具半径） ：工具半径Dがスケーリングされます。 わかった スケーリングが実行されます。ブロック番号は自動的に割り当てられます。...", 
"body" : "スケーリングファクター ディフォルト： 0.001 条件：スケーリング係数> = 1e-3 倍率が1より大きい場合は、拡大されます。 軸 ：軸がスケーリングされます。 D（工具半径） ：工具半径Dがスケーリングされます。 わかった スケーリングが実行されます。ブロック番号は自動的に割り当てられます。 " }, 
{ "title" : "コマンド：スクロールパスビュー ", 
"url" : "_sm_cmd_cnc_scroll_path_view.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：スクロールパスビュー ", 
"snippet" : "パスビューをスクロール 関数 ：このコマンドは、CNCパスのスクロールをアクティブまたは非アクティブにします。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 スクロールがアクティブになっている場合、CNCパスのビューは、CNCプログラムで選択されたパス要素が完全に表示されるように、グラフィックエディタでスクロールおよびズームされます。...", 
"body" : "パスビューをスクロール 関数 ：このコマンドは、CNCパスのスクロールをアクティブまたは非アクティブにします。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 スクロールがアクティブになっている場合、CNCパスのビューは、CNCプログラムで選択されたパス要素が完全に表示されるように、グラフィックエディタでスクロールおよびズームされます。 " }, 
{ "title" : "コマンド：変数を設定する ", 
"url" : "_sm_cmd_cnc_set_offline_variables.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：変数を設定する ", 
"snippet" : "変数を設定する 関数 ：コマンドは 変数のオフライン値 ダイアログ。 CNCプログラムの変数は、オフラインモード用にここで定義できます。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。...", 
"body" : "変数を設定する 関数 ：コマンドは 変数のオフライン値 ダイアログ。 CNCプログラムの変数は、オフラインモード用にここで定義できます。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 " }, 
{ "title" : "ダイアログ：変数のオフライン値 ", 
"url" : "_sm_cmd_cnc_set_offline_variables.html#UUID-101f0c28-cef6-51dc-ec33-33b8d27ee9c8_id_c97aba1d244400ffc0a8640e01a5ad6c_id_d54502d95df6e2f6c0a8646351ba116d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：変数を設定する \/ ダイアログ：変数のオフライン値 ", 
"snippet" : "変数 CNCプログラムの変数 例： G_X 変数が灰色のイタリックで表示されている場合は、CNCプログラムで使用されていません。 価値 構成されたオフライン値 例： 100 オンライン値に設定 値は、アプリケーションで現在割り当てられている値で上書きされます。 要件：コマンドは、アプリケーションが実行されていて、CNCエディターがオンラインモードである場合に使用できます。次に、オンライン値をロードすることができます。 わかった 値が有効な場合、それらはCNCプログラムに適用され、エディターのパスが更新されます。...", 
"body" : "変数 CNCプログラムの変数 例： G_X 変数が灰色のイタリックで表示されている場合は、CNCプログラムで使用されていません。 価値 構成されたオフライン値 例： 100 オンライン値に設定 値は、アプリケーションで現在割り当てられている値で上書きされます。 要件：コマンドは、アプリケーションが実行されていて、CNCエディターがオンラインモードである場合に使用できます。次に、オンライン値をロードすることができます。 わかった 値が有効な場合、それらはCNCプログラムに適用され、エディターのパスが更新されます。 " }, 
{ "title" : "コマンド：エンドポイントを表示 ", 
"url" : "_sm_cmd_cnc_show_end_points.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：エンドポイントを表示 ", 
"snippet" : "エンドポイントを表示 関数 ：このコマンドは、CNCパスポイントの表示をアクティブまたは非アクティブにします。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 表示がアクティブになっている場合、すべてのパス要素にエンドポイントが提供されます。...", 
"body" : "エンドポイントを表示 関数 ：このコマンドは、CNCパスポイントの表示をアクティブまたは非アクティブにします。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 表示がアクティブになっている場合、すべてのパス要素にエンドポイントが提供されます。 " }, 
{ "title" : "コマンド：グリッドを表示 ", 
"url" : "_sm_cmd_cnc_show_grid.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：グリッドを表示 ", 
"snippet" : "グリッドを表示 シンボル： 関数 ：このコマンドは、グラフィカルエディタでのグリッドの表示をアクティブまたは非アクティブにします。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 ズーム率は、グリッド線の間隔を決定します。パスを展開すると、グリッドサイズが決まります。...", 
"body" : "グリッドを表示 シンボル： 関数 ：このコマンドは、グラフィカルエディタでのグリッドの表示をアクティブまたは非アクティブにします。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 ズーム率は、グリッド線の間隔を決定します。パスを展開すると、グリッドサイズが決まります。 " }, 
{ "title" : "コマンド：補間点を表示 ", 
"url" : "_sm_cmd_cnc_show_interpolation_points.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：補間点を表示 ", 
"snippet" : "補間点を表示 シンボル： 関数 ：このコマンドは、補間点の表示をアクティブまたは非アクティブにします。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 補間点の表示が有効になっている場合、CNCパスは補間点とともに表示されます。 CNC設定のダイアログで設定されるサイクルタイム（ 事前補間 タブ）、補間点を決定するために使用されます。また、この機能は、エディタでの前処理でCNCパスを表示するかどうかを決定します。...", 
"body" : "補間点を表示 シンボル： 関数 ：このコマンドは、補間点の表示をアクティブまたは非アクティブにします。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 補間点の表示が有効になっている場合、CNCパスは補間点とともに表示されます。 CNC設定のダイアログで設定されるサイクルタイム（ 事前補間 タブ）、補間点を決定するために使用されます。また、この機能は、エディタでの前処理でCNCパスを表示するかどうかを決定します。 " }, 
{ "title" : "グラフィカルエディタで表示する ", 
"url" : "_sm_cmd_cnc_show_interpolation_points.html#UUID-043dd64e-e07a-5e2b-2f1d-fc2a843ef4b7_id_be380e1242fa185c0a8640e005adee9_id_d6d5fcd172c9c53cc0a864633c37464d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：補間点を表示 \/ グラフィカルエディタで表示する ", 
"snippet" : "補間点は、移動方向に垂直な線で表示されます。線の長さは、現在のパス速度に比例します。これにより、速度の振る舞いを大まかに見積もることができます。 より長い距離と長いライン 高速度 距離が短く、ラインが短い 低速 赤 補間器は減速されます。 緑 補間器が加速されます。 グレー 補間器の速度は一定です。...", 
"body" : "補間点は、移動方向に垂直な線で表示されます。線の長さは、現在のパス速度に比例します。これにより、速度の振る舞いを大まかに見積もることができます。 より長い距離と長いライン 高速度 距離が短く、ラインが短い 低速 赤 補間器は減速されます。 緑 補間器が加速されます。 グレー 補間器の速度は一定です。 " }, 
{ "title" : "コマンド：ステップ抑制 ", 
"url" : "_sm_cmd_cnc_step_suppression.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：ステップ抑制 ", 
"snippet" : "ステップ抑制 シンボル： 関数 ：このコマンドは、ステップ抑制をアクティブまたは非アクティブにします。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 CNCプログラムはDIN66025として実装されています。 ステップ抑制が有効になっている場合、CNCプログラムでで始まるブロック \/ 無視されます。 CNCプログラムがテーブルとして実装されている場合、コマンドは使用できません。...", 
"body" : "ステップ抑制 シンボル： 関数 ：このコマンドは、ステップ抑制をアクティブまたは非アクティブにします。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 CNCプログラムはDIN66025として実装されています。 ステップ抑制が有効になっている場合、CNCプログラムでで始まるブロック \/ 無視されます。 CNCプログラムがテーブルとして実装されている場合、コマンドは使用できません。 " }, 
{ "title" : "コマンド：プログラムをASCIIファイルに書き込む ", 
"url" : "_sm_cmd_cnc_write_program_to_ascii_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：プログラムをASCIIファイルに書き込む ", 
"snippet" : "ASCIIファイルへのプログラムの書き込み 関数 ：このコマンドは、ファイルをファイルシステムに保存するためのデフォルトのダイアログを開きます。 CNCプログラムはASCIIファイルとして保存できます。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 名前 デフォルト：CNCオブジェクトの名前 例： cncSpiral_A ファイルの種類 ファイル拡張子： TXT 、 GCODE 、 CNC...", 
"body" : "ASCIIファイルへのプログラムの書き込み 関数 ：このコマンドは、ファイルをファイルシステムに保存するためのデフォルトのダイアログを開きます。 CNCプログラムはASCIIファイルとして保存できます。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 名前 デフォルト：CNCオブジェクトの名前 例： cncSpiral_A ファイルの種類 ファイル拡張子： TXT 、 GCODE 、 CNC " }, 
{ "title" : "コマンド：前処理されたパスを表示 ", 
"url" : "_sm_cmd_cnc_show_preprocessed_path.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ コマンド：前処理されたパスを表示 ", 
"snippet" : "前処理されたパスを表示する シンボル： 関数 ：このコマンドは、前処理を使用してCNCパスの表示をアクティブまたは非アクティブにします。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 ディスプレイがアクティブな場合、パスは前処理で表示され、元のパスは背景に薄い灰色で表示されます。 前処理はで構成されます CNC設定 ダイアログ（ パスの前処理 タブ）。そこで設定された前処理が表示されます。次に、前処理に対するさまざまな機能ブロック（直列）の影響をシミュレートできます。 このコマンドは、コード生成には影響しません。 CNCプログラムのコンパイル時にSMC_OutQu...", 
"body" : "前処理されたパスを表示する シンボル： 関数 ：このコマンドは、前処理を使用してCNCパスの表示をアクティブまたは非アクティブにします。 電話 ： CNC メニュー 要件 ：CNCパスがエディターで開いています。 ディスプレイがアクティブな場合、パスは前処理で表示され、元のパスは背景に薄い灰色で表示されます。 前処理はで構成されます CNC設定 ダイアログ（ パスの前処理 タブ）。そこで設定された前処理が表示されます。次に、前処理に対するさまざまな機能ブロック（直列）の影響をシミュレートできます。 このコマンドは、コード生成には影響しません。 CNCプログラムのコンパイル時にSMC_OutQueueファイル構造が生成された場合でも、コマンドはファイルの内容に影響を与えません。コンパイル時には、前処理が常に考慮されます。 " }, 
{ "title" : "オブジェクト：CNCプログラム ", 
"url" : "_sm_f_reference_object_cnc_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ オブジェクト：CNCプログラム ", 
"snippet" : "CNCプログラム...", 
"body" : "CNCプログラム " }, 
{ "title" : "概要 ", 
"url" : "_sm_f_reference_object_cnc_program-1561724.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ オブジェクト：CNCプログラム \/ 概要 ", 
"snippet" : "CODESYS DIN66025用のエディターと表形式のエディターの2つの異なるエディターでCNCプログラムを作成する機能を提供します。両方のエディターは、プログラムされたパスのグラフィカルビューを表示します。 プログラミングは編集者間で交換できますが、これは情報の損失につながる可能性があります。 個々のエディターは、要素のさまざまな処理を提供します。 エレメント DIN66025のエディター 表形式のエディター ポジショニング X X ライン X X アーク X X 楕円 X X スプライン X X 迅速なポジショニング X X M機能 X X 放物線 X 変数の使用 X ジャンプ X 座標...", 
"body" : "CODESYS DIN66025用のエディターと表形式のエディターの2つの異なるエディターでCNCプログラムを作成する機能を提供します。両方のエディターは、プログラムされたパスのグラフィカルビューを表示します。 プログラミングは編集者間で交換できますが、これは情報の損失につながる可能性があります。 個々のエディターは、要素のさまざまな処理を提供します。 エレメント DIN66025のエディター 表形式のエディター ポジショニング X X ライン X X アーク X X 楕円 X X スプライン X X 迅速なポジショニング X X M機能 X X 放物線 X 変数の使用 X ジャンプ X 座標シフト X ステップ抑制 X 滞留時間 X 補間器とのタイミング同期 X 詳細については、以下を参照してください。 表形式のエディター と DIN66025のエディター" }, 
{ "title" : "表形式のエディター ", 
"url" : "_sm_obj_cnc_program_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ オブジェクト：CNCプログラム \/ 表形式のエディター ", 
"snippet" : "表形式のエディターでは、パスコマンドが表に一覧表示されます。に 表形式のエディター タブ、 CNC設定 、このテーブルの列をカスタマイズできます。 NS CNC設定 デバイスツリー内のオブジェクトとして配置されます。 デフォルトでは、選択したパス要素のプロパティがテーブルの右側に表示されます。これらはそこで編集できません。 線を選択すると、それぞれのモーションパスがグラフィックエディタに描画されます。要素タイプは、パス要素のどの特定のプロパティを変更できるかを決定します。編集できないパラメータは網掛けになっています。を押す F6 キーを押すと、フォーカスがグラフィカルエディタに切り替わり、元に...", 
"body" : "表形式のエディターでは、パスコマンドが表に一覧表示されます。に 表形式のエディター タブ、 CNC設定 、このテーブルの列をカスタマイズできます。 NS CNC設定 デバイスツリー内のオブジェクトとして配置されます。 デフォルトでは、選択したパス要素のプロパティがテーブルの右側に表示されます。これらはそこで編集できません。 線を選択すると、それぞれのモーションパスがグラフィックエディタに描画されます。要素タイプは、パス要素のどの特定のプロパティを変更できるかを決定します。編集できないパラメータは網掛けになっています。を押す F6 キーを押すと、フォーカスがグラフィカルエディタに切り替わり、元に戻ります。 このエディタでサポートされている要素の概要については、「オブジェクトCNCプログラム」の章を参照してください。 詳細については、以下を参照してください。 表形式エディターでのパスのプログラミング と グラフィカルエディタ" }, 
{ "title" : "DIN66025のエディター ", 
"url" : "_sm_obj_cnc_program_din66025.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ オブジェクト：CNCプログラム \/ DIN66025のエディター ", 
"snippet" : "このエディタでは、DIN 66025に従ってパス要素をCNCプログラムとして指定します。デフォルトでは、選択したパス要素のプロパティが右側に表示されます。ただし、そこで変更することはできません。 線を選択すると、それぞれのモーションパスがグラフィックエディタに描画されます。を押す F6 キーを押すと、フォーカスがグラフィカルエディタに切り替わり、元に戻ります。 このエディタでサポートされている要素の概要については、「オブジェクトCNCプログラム」の章を参照してください。 グローバル変数の参照は、インタープリターがブロックを処理しているときにデコーダー モジュールで評価されることに注意してくださ...", 
"body" : "このエディタでは、DIN 66025に従ってパス要素をCNCプログラムとして指定します。デフォルトでは、選択したパス要素のプロパティが右側に表示されます。ただし、そこで変更することはできません。 線を選択すると、それぞれのモーションパスがグラフィックエディタに描画されます。を押す F6 キーを押すと、フォーカスがグラフィカルエディタに切り替わり、元に戻ります。 このエディタでサポートされている要素の概要については、「オブジェクトCNCプログラム」の章を参照してください。 グローバル変数の参照は、インタープリターがブロックを処理しているときにデコーダー モジュールで評価されることに注意してください。これは、オブジェクトが移動する数サイクル前に発生する可能性があります。 詳細については、以下を参照してください。 DIN66025に準拠したパスのプログラミング と CNC設定" }, 
{ "title" : "グラフィカルエディタ ", 
"url" : "_sm_obj_cnc_program_graphical.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ オブジェクト：CNCプログラム \/ グラフィカルエディタ ", 
"snippet" : "グラフィカルエディタは、CNC表形式エディタとDIN 66025のエディタの下部にあります。エディタは、プログラムされたCNCプログラムを表示するために使用されます。 エディターは、パスを変更および拡張するためのツールを提供します。 エディターの構造 （1）：表形式のエディターまたはDIN66025に準拠したエディター （2）：プロパティビュー：選択したパス要素のプロパティを表示します （3）：グラフィカルエディタ （4）：コントロールパネル：カメラの位置と視線方向を制御するための要素 （5）：パスを変更するためのツール グラフィカルエディタの操作に関する注意事項 選択したパス要素が赤で表示さ...", 
"body" : "グラフィカルエディタは、CNC表形式エディタとDIN 66025のエディタの下部にあります。エディタは、プログラムされたCNCプログラムを表示するために使用されます。 エディターは、パスを変更および拡張するためのツールを提供します。 エディターの構造 （1）：表形式のエディターまたはDIN66025に準拠したエディター （2）：プロパティビュー：選択したパス要素のプロパティを表示します （3）：グラフィカルエディタ （4）：コントロールパネル：カメラの位置と視線方向を制御するための要素 （5）：パスを変更するためのツール グラフィカルエディタの操作に関する注意事項 選択したパス要素が赤で表示されます。 位置決め指令（G0）とスイッチポイント機能は緑色で表示されます。 要素の終点が移動可能な場合、それは小さな黒い輪郭の円として表示されます。 開始接線と終了接線は灰色で表示されます。 選択したパス要素の現在位置がステータスバーに表示されます。 パス全体をスケーリングおよび移動するためのCNCメニューコマンドに注意してください。 のインストールに含まれているサンプルプログラムに注意してください CODESYS SoftMotion 。 " }, 
{ "title" : "ツール ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_0ffa6b2d9c1625bec0a8646341693b76", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ オブジェクト：CNCプログラム \/ グラフィカルエディタ \/ ツール ", 
"snippet" : "ツールを使用して、グラフィカルエディタでモーションパスを変更および拡張できます。変更は、テキストエディタと表形式エディタで同時に表示されます。 選択する ：このツールは、ポイントまたはパス要素を選択します。次に、要素は青の開始点で赤で表示されます。グラフィカルエディタのマウスポインタがポインタに変わります。 ライン ：新しい行を追加または挿入します。グラフィカルエディタのマウスポインタが十字に変わります。 円を挿入（時計回り） ：新しい円弧を追加または挿入します（時計回り）。グラフィカルエディタのマウスポインタが十字に変わります。 円を挿入します（反時計回り） ：新しい円弧を追加または挿入しま...", 
"body" : "ツールを使用して、グラフィカルエディタでモーションパスを変更および拡張できます。変更は、テキストエディタと表形式エディタで同時に表示されます。 選択する ：このツールは、ポイントまたはパス要素を選択します。次に、要素は青の開始点で赤で表示されます。グラフィカルエディタのマウスポインタがポインタに変わります。 ライン ：新しい行を追加または挿入します。グラフィカルエディタのマウスポインタが十字に変わります。 円を挿入（時計回り） ：新しい円弧を追加または挿入します（時計回り）。グラフィカルエディタのマウスポインタが十字に変わります。 円を挿入します（反時計回り） ：新しい円弧を追加または挿入します（反時計回り）。グラフィカルエディタのマウスポインタが十字に変わります。 スプライン ：新しいスプライン点を追加または挿入します。グラフィカルエディタのマウスポインタが十字に変わります。 " }, 
{ "title" : "カメラの位置と視線方向 ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_05ff18059c1625bec0a864634ba4f71d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ オブジェクト：CNCプログラム \/ グラフィカルエディタ \/ カメラの位置と視線方向 ", 
"snippet" : "マウスを使用して、プログラムパス上の位置とカメラの視点を任意の方法で変更できます。 マウスの左ボタン 押された+マウスの動き：表示面の軸に沿ってカメラの位置を移動します。 マウスの右ボタン 押された+マウスの動き：CNCプログラムのビューを回転します。 NS + マウスホイール ：ズーム率を変更します。...", 
"body" : "マウスを使用して、プログラムパス上の位置とカメラの視点を任意の方法で変更できます。 マウスの左ボタン 押された+マウスの動き：表示面の軸に沿ってカメラの位置を移動します。 マウスの右ボタン 押された+マウスの動き：CNCプログラムのビューを回転します。 NS + マウスホイール ：ズーム率を変更します。 " }, 
{ "title" : "ディスプレイ制御用操作パネル ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_4693d34dba46042bc0a864633b130501", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ オブジェクト：CNCプログラム \/ グラフィカルエディタ \/ ディスプレイ制御用操作パネル ", 
"snippet" : "グラフィカルエディタの左上隅にある操作パネルには、パスの表示を変更するためのさまざまなコマンドがあります。パスはプロセスで変更されません。代わりに、カメラの位置とカメラの視点のみが変更されます。 エディターワークスペースのサイズを最大化するために、黒い矢印をクリックしてコントロールパネルを折りたたむことができます。もう一度クリックすると、コントロールパネルが展開されます。 コントロールパネルには、向き、位置、ズームを設定するための次のコマンドがあります。 ズームイン ズームアウトする カメラのピッチを変更する（時計回り） カメラのピッチを変更します（反時計回り） カメラのヨーを変更します（時計...", 
"body" : "グラフィカルエディタの左上隅にある操作パネルには、パスの表示を変更するためのさまざまなコマンドがあります。パスはプロセスで変更されません。代わりに、カメラの位置とカメラの視点のみが変更されます。 エディターワークスペースのサイズを最大化するために、黒い矢印をクリックしてコントロールパネルを折りたたむことができます。もう一度クリックすると、コントロールパネルが展開されます。 コントロールパネルには、向き、位置、ズームを設定するための次のコマンドがあります。 ズームイン ズームアウトする カメラのピッチを変更する（時計回り） カメラのピッチを変更します（反時計回り） カメラのヨーを変更します（時計回り） カメラのヨーを変更します（反時計回り） カメラを（時計回りに）回転させます カメラを（反時計回りに）回転させます カメラを上に移動します カメラを左に移動します カメラを右に移動します カメラを下に移動します 視線の方向を負のz軸に設定し、再スケールします 視線の方向をx軸に設定し、再スケールします 視線の方向をy軸に設定し、再スケールします " }, 
{ "title" : "ダイアログ：CNCプロパティ ", 
"url" : "_sm_dlg_cnc_program_properties.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ オブジェクト：CNCプログラム \/ ダイアログ：CNCプロパティ ", 
"snippet" : "シンボル： 関数 ：ダイアログは、のパラメータを提供します CNCプログラム 物体。 電話 ： 表示→プロパティ 指図;オブジェクトのコンテキストメニュー 要件 ：デバイスツリーでCNCオブジェクトが選択されています。 アプリケーション全体のCNC設定はに保存されます CNC設定 物体。...", 
"body" : "シンボル： 関数 ：ダイアログは、のパラメータを提供します CNCプログラム 物体。 電話 ： 表示→プロパティ 指図;オブジェクトのコンテキストメニュー 要件 ：デバイスツリーでCNCオブジェクトが選択されています。 アプリケーション全体のCNC設定はに保存されます CNC設定 物体。 " }, 
{ "title" : "タブ：一般 ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_e398c87e5062d26bc0a86520014051d1", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ オブジェクト：CNCプログラム \/ ダイアログ：CNCプロパティ \/ タブ：一般 ", 
"snippet" : "CNCオブジェクトの名前を変更します。...", 
"body" : "CNCオブジェクトの名前を変更します。 " }, 
{ "title" : "タブ：アクセス制御 ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_6f1287e45062d25bc0a865200009f33d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ オブジェクト：CNCプログラム \/ ダイアログ：CNCプロパティ \/ タブ：アクセス制御 ", 
"snippet" : "ここでは、ユーザーグループの権限を指定します。 詳細については、以下を参照してください。 プロパティ–アクセス制御...", 
"body" : "ここでは、ユーザーグループの権限を指定します。 詳細については、以下を参照してください。 プロパティ–アクセス制御 " }, 
{ "title" : "タブ：ビルド ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_18be1ff163875181c0a865ca014256df", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ オブジェクト：CNCプログラム \/ ダイアログ：CNCプロパティ \/ タブ：ビルド ", 
"snippet" : "CNCオブジェクトをビルドから除外するオプションをアクティブにします。その場合、IECデータは生成されません。ただし、GコードをASCIIファイルとして保存することは可能です。実行時にこの種のファイルを読み取るために、からの機能ブロックを使用することができます。 SM3_CNC 図書館。 詳細については、以下を参照してください。 プロパティ–アクセス制御...", 
"body" : "CNCオブジェクトをビルドから除外するオプションをアクティブにします。その場合、IECデータは生成されません。ただし、GコードをASCIIファイルとして保存することは可能です。実行時にこの種のファイルを読み取るために、からの機能ブロックを使用することができます。 SM3_CNC 図書館。 詳細については、以下を参照してください。 プロパティ–アクセス制御 " }, 
{ "title" : "タブ：CNC ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ オブジェクト：CNCプログラム \/ ダイアログ：CNCプロパティ \/ タブ：CNC ", 
"snippet" : "実装 Din66025 ：モーションパスはCNC言語DIN66025で定義されています。 テーブル ：モーションパスは、テーブルのパラメータ化によって定義されます。 コンパイルモード コンパイル時の動作 SMC_OutQueue ：SMC_OutQueueデータ構造はコンパイル時に生成されます。によってグローバルアクセスが許可されます g_CNCQueueManager 。 SMC_CNC_REF ：プログラム変数はコンパイル時に生成されます。によってグローバルアクセスが許可されます g_CNCProgManager 。 ファイル ：Gコードで生成されたファイルは、ログインするたびにダウンロー...", 
"body" : "実装 Din66025 ：モーションパスはCNC言語DIN66025で定義されています。 テーブル ：モーションパスは、テーブルのパラメータ化によって定義されます。 コンパイルモード コンパイル時の動作 SMC_OutQueue ：SMC_OutQueueデータ構造はコンパイル時に生成されます。によってグローバルアクセスが許可されます g_CNCQueueManager 。 SMC_CNC_REF ：プログラム変数はコンパイル時に生成されます。によってグローバルアクセスが許可されます g_CNCProgManager 。 ファイル ：Gコードで生成されたファイルは、ログインするたびにダウンロードおよび更新されます。 PLCは、ファンクションブロックを使用してこのファイルをダウンロードできます。 Gコードファイルは、アプリケーションにログインするたびに更新されます。これは、PLC上のファイルがログインのたびに上書きされることを意味します。 ファイル名 要件： コンパイルモード に設定されています ファイル 。 ディフォルト： $ ObjectName $ .cnc 。このデフォルト値は、ログイン時にCNCオブジェクトのオブジェクト名（有効なファイル名）に置き換えられるプレースホルダーです。ファイル名には、文字[a-zA-Z0-9 $ _。]のみを使用できます。ファイル名のフィールドは、空白にすることも、ドットで開始または終了することもできません。さらに、ドットはファイル名のパスの一部である必要はありません。 キューサイズ[要素] デフォルト：100 サイズ設定は、生成されるサイズには影響しません SMC_OutQueue データ構造（このモードが選択されている場合）。サイズ SMC_OutQueue パスオブジェクトの数によってのみ決定されます。ただし、このパラメーターは、前処理FBのバッファー・サイズを設定します（たとえば、 SMC_NCDecoder 、 SMC_RoundPath ）内部で使用され、先読みバッファのサイズを定義します。 デフォルト値 速度（F）[u \/ s] この値は、CNCプログラムでベロシティの値（「F」ワード）が設定されていない場合に使用されます。 1秒あたりのパス単位。値の範囲：[0、1e9]。デフォルト：0 加速度（E +）[u \/s²] この値は、加速度の値（正の値を持つ「E」ワード内）が設定されていない場合に使用されます。パス単位\/秒の2乗。値の範囲：] 0、1e9]。 デフォルト：100 減速（E-）[u \/s²] この値は、減速度の値（負の値の「E」ワード）が設定されていない場合に使用されます。パス単位\/秒の2乗。値の範囲：] 0、1e9]。 デフォルト：100 早送りのデフォルト値（G0） 速度（FF）[u \/ s] この値は、速度の送り値（「FF」ワード）がCNCプログラムで設定されていない場合に使用されます。 1秒あたりのパス単位。値の範囲：[0、1e9]。 デフォルト：0 加速度（EF +）[u \/s²] この値は、加速度の送り値（正の値を持つ「EF +」ワード内）が設定されていない場合に使用されます。パス単位\/秒の2乗。値の範囲：[0、1e9]。 デフォルト：0 減速（EF-）[u \/s²] この値は、減速度の送り値（負の値の「EF-」ワード）が設定されていない場合に使用されます。パス単位\/秒の2乗。値の範囲：[0、1e9]。 デフォルト：0 3Dモード 要件：実装 Din66025 、翻訳モード CNC_REF 、 と OUTQueue ：3Dモードがデフォルト値です。 変数のオフライン値 変数 ：オフライン値が定義されている場合、 変数のオフライン値 ダイアログが開きます。このダイアログには、編集可能な変数が表示されます。 開始位置 デフォルト：0 精度 技術単位でのパスの精度。この値は、G コードから読み取られる位置の精度を指定します。たとえば、G コードが小数点以下 3 桁で指定されている場合、精度は 0.001 単位に設定する必要があります。精度は負であってはなりません。この値は、たとえば次のようなパスの前処理で使用されます。 SMC_ToolRadiusCorr そして SMC_AvoidLoop 。 " }, 
{ "title" : "オブジェクト：CNC設定 ", 
"url" : "_sm_obj_cnc_settings.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ オブジェクト：CNC設定 ", 
"snippet" : "CNC設定 シンボル： このオブジェクトの設定は、アプリケーションのすべてのCNCオブジェクトに有効です。オブジェクトはアプリケーションのデバイスツリーに追加されるか、CNCオブジェクトがアプリケーションに追加されると自動的に生成されます。オブジェクトは、アプリケーションごとに1回だけ存在する可能性があり、名前を変更することはできません。 オブジェクトのエディターでは、パス前処理モジュール、前補間、およびCNC表形式エディターの設定を指定できます。あなたは削除することができます CNC設定 アプリケーションの下にCNCオブジェクトが存在しない場合にのみオブジェクト。 特定のCNCプログラムにの...", 
"body" : "CNC設定 シンボル： このオブジェクトの設定は、アプリケーションのすべてのCNCオブジェクトに有効です。オブジェクトはアプリケーションのデバイスツリーに追加されるか、CNCオブジェクトがアプリケーションに追加されると自動的に生成されます。オブジェクトは、アプリケーションごとに1回だけ存在する可能性があり、名前を変更することはできません。 オブジェクトのエディターでは、パス前処理モジュール、前補間、およびCNC表形式エディターの設定を指定できます。あなたは削除することができます CNC設定 アプリケーションの下にCNCオブジェクトが存在しない場合にのみオブジェクト。 特定のCNCプログラムにのみ有効な設定は、 設定 CNCプログラムのダイアログ。 " }, 
{ "title" : "タブ：パスプリプロセッサ ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_id_e55a0b19a1678229c0a8646353e40d98_id_de809dbaa55775c9c0a8646311985883", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ オブジェクト：CNC設定 \/ タブ：パスプリプロセッサ ", 
"snippet" : "このタブでは、機能ブロックを選択することにより、パスの前処理がプログラムされます。 利用可能な機能ブロック 使用可能なすべての機能ブロックのリスト アクティブな機能ブロックインスタンス 選択した機能ブロックインスタンスのリスト リスト内の位置は処理順序を定義し、変更できます。 機能ブロックは、リスト内で複数回インスタンス化できます。 パラメータ を開きます <選択されたアクティブな機能ブロックインスタンス>のパラメータエディタ ダイアログ 別の方法：アクティブな汎用ブロックインスタンスをダブルクリックします 機能ブロックのインスタンスをに追加します アクティブな機能ブロックインスタンス で選択...", 
"body" : "このタブでは、機能ブロックを選択することにより、パスの前処理がプログラムされます。 利用可能な機能ブロック 使用可能なすべての機能ブロックのリスト アクティブな機能ブロックインスタンス 選択した機能ブロックインスタンスのリスト リスト内の位置は処理順序を定義し、変更できます。 機能ブロックは、リスト内で複数回インスタンス化できます。 パラメータ を開きます <選択されたアクティブな機能ブロックインスタンス>のパラメータエディタ ダイアログ 別の方法：アクティブな汎用ブロックインスタンスをダブルクリックします 機能ブロックのインスタンスをに追加します アクティブな機能ブロックインスタンス で選択されている アクティブな機能ブロックインスタンス 選択した機能ブロックインスタンスを削除します 薄い灰色のイタリック体で表示されている機能ブロックの機能ブロックインスタンスは削除できません。 選択したアクティブな機能ブロックインスタンスを1行上に移動します 代替：プレス シフト + 上矢印 選択したアクティブな機能ブロックインスタンスを1行下に移動します 代替：プレス シフト + 下矢印 <選択されたアクティブな機能ブロックインスタンス>のパラメータエディタ ダイアログ ダイアログは、選択したインスタンスの入力を表示および変更するために使用されます。すべての入力が表示されるわけではありません。 Spalte1 選択したアクティブな機能ブロックインスタンスのパラメータの名前 Spalte2 値を設定するためのリストボックス Spalte3 パラメータの説明 " }, 
{ "title" : "タブ：事前補間 ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_id_e55a0b19a1678229c0a8646353e40d98_id_9a258724a55775c9c0a8646350128da9", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ オブジェクト：CNC設定 \/ タブ：事前補間 ", 
"snippet" : "サイクルタイムµs 補間時間 初期値：20000 速度モード 台形 ：台形形状の速度プロファイル シグモイド ：台形プロファイルに似ていますが、線形速度ランプを置き換えるsin²関数を使用した速度プロファイル シグモイド限定 ：シグモイドプロファイルと同様の速度プロファイルですが、加速と減速の制限を考慮しています 二次 ：で定義されているジャーク制限のある台形形状の加速プロファイル 最大ジャーク 。結果として得られる2次速度プロファイルもS曲線として認識されます。 二次（スムーズ） ：のように動作します 二次 モードですが、ジャンプなしでジャークプロファイルを生成します。 最大ジャーク[u \/...", 
"body" : "サイクルタイムµs 補間時間 初期値：20000 速度モード 台形 ：台形形状の速度プロファイル シグモイド ：台形プロファイルに似ていますが、線形速度ランプを置き換えるsin²関数を使用した速度プロファイル シグモイド限定 ：シグモイドプロファイルと同様の速度プロファイルですが、加速と減速の制限を考慮しています 二次 ：で定義されているジャーク制限のある台形形状の加速プロファイル 最大ジャーク 。結果として得られる2次速度プロファイルもS曲線として認識されます。 二次（スムーズ） ：のように動作します 二次 モードですが、ジャンプなしでジャークプロファイルを生成します。 最大ジャーク[u \/s³] ジャークの絶対値の制限 二次速度プロファイルにのみ使用されます 補間器が呼び出されるそれぞれのタスクの補間時間とサイクル時間は、CNCエディタとオンラインアプリケーションの同じ動作に一致する必要があります。 " }, 
{ "title" : "タブ：表形式のエディター ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_section-idm43260108321858", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ ユーザーインターフェース \/ オブジェクト：CNC設定 \/ タブ：表形式のエディター ", 
"snippet" : "表形式エディターの列とその順序は、このタブで定義されます。 テーブルの列 使用可能なすべての属性のリスト ：属性は表形式のエディターに表示されます。 このリストの順序によって、表形式エディターの行の順序が決まります。 選択した属性を1行上に移動します 選択した属性を1行下に移動します...", 
"body" : "表形式エディターの列とその順序は、このタブで定義されます。 テーブルの列 使用可能なすべての属性のリスト ：属性は表形式のエディターに表示されます。 このリストの順序によって、表形式エディターの行の順序が決まります。 選択した属性を1行上に移動します 選択した属性を1行下に移動します " }, 
{ "title" : "CODESYS SoftMotion Robotics ", 
"url" : "_sm_f_robotics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概要 ", 
"url" : "_sm_overview_robotics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 概要 ", 
"snippet" : "CODESYS SoftMotion Robotics は、PLCopen 仕様「モーション コントロール用機能ブロック パート 4」に基づいた、ロボットのモーション コントロール用の機能ブロック インターフェイスを提供します。複雑な動作シーケンスは、直線や円弧などの単純なポイントツーポイントまたは連続パス動作で構成できます。個々の動作間のブレンドは構成可能です (たとえば、距離または速度に基づく)。個々の軸とパスの両方の速度、加速度、ジャーク制限が考慮されます。 軌道計画はオンラインで行われます CODESYS コントローラは、動作の実行と並行して、処理時にロボットを停止することなく新しい動...", 
"body" : "CODESYS SoftMotion Robotics は、PLCopen 仕様「モーション コントロール用機能ブロック パート 4」に基づいた、ロボットのモーション コントロール用の機能ブロック インターフェイスを提供します。複雑な動作シーケンスは、直線や円弧などの単純なポイントツーポイントまたは連続パス動作で構成できます。個々の動作間のブレンドは構成可能です (たとえば、距離または速度に基づく)。個々の軸とパスの両方の速度、加速度、ジャーク制限が考慮されます。 軌道計画はオンラインで行われます CODESYS コントローラは、動作の実行と並行して、処理時にロボットを停止することなく新しい動作を追加できます。 納品範囲には、シンプルなガントリーからデルタおよびスカラ ロボット、一般的な 6 軸産業用ロボットまで、さまざまな標準ロボットの運動学モデルが含まれます。特殊な機械用のカスタム運動学モデルは、IEC 61131-3 機能ブロックの形式でリンクできます。同様に、発生する力とトルクを制限し、トルク フィード フォワード制御を可能にするために、インターフェイスを介して動的モデルを使用できます。 その他の機能ブロックは、一般的な使用例を簡単に実装するために使用されます。これには、移動座標系との同期、動作の中断と再開、トリガーによる高精度デジタル出力の制御などが含まれます。 " }, 
{ "title" : "はじめる ", 
"url" : "_sm_robotics_first_steps.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ はじめる ", 
"snippet" : "ロボットの軸の動きをプログラムするには、まずプロジェクトのアプリケーションの下に軸グループを作成する必要があります。詳細については、次を参照してください。 軸グループを作成する方法. 作成した軸グループを希望の運動学で構成します。デバイスの下に実軸または仮想軸を挿入し、これらの軸を軸グループにリンクします。詳細については、ヘルプページを参照してください。 運動学: 軸グループの状態位置と方向の運動学の組み合わせロータリージョイントとモジュロ軸360°を超える値の範囲を持つ回転軸軸を作成および構成した後で、軸制御用のプログラムを作成する方法を例として以下に示します。 軸グループを制御するプログラ...", 
"body" : "ロボットの軸の動きをプログラムするには、まずプロジェクトのアプリケーションの下に軸グループを作成する必要があります。詳細については、次を参照してください。 軸グループを作成する方法. 作成した軸グループを希望の運動学で構成します。デバイスの下に実軸または仮想軸を挿入し、これらの軸を軸グループにリンクします。詳細については、ヘルプページを参照してください。 運動学: 軸グループの状態位置と方向の運動学の組み合わせロータリージョイントとモジュロ軸360°を超える値の範囲を持つ回転軸軸を作成および構成した後で、軸制御用のプログラムを作成する方法を例として以下に示します。 軸グループを制御するプログラムの作成方法さまざまなモーション コントロール要求を実装する方法については、次の追加のヘルプ ページを参照してください。 運動制御 . 動きのバッファリングとブレンド軸グループのジョギング動きの中断と継続移動座標系との同期ツールオフセットの構成特定の動きがどのように実行されるかを理解するための背景情報は、次の場所にあります。 CP運動の方向補間上級ユーザー向け: トルク制限とトルクフィードフォワード制御カスタムキネマティクスの作成" }, 
{ "title" : "アクシスグループ ", 
"url" : "_sm_robotics_axis_group.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ アクシスグループ ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "軸グループを作成する方法 ", 
"url" : "_sm_creating_an_axis_group.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ アクシスグループ \/ 軸グループを作成する方法 ", 
"snippet" : "デバイスツリーへのオブジェクトの追加 次の手順では、軸グループを作成および構成する方法について説明します。 新しい標準プロジェクトを作成します CODESYS Control 。 POUの場合 PLC_PRG 、CFC 実装言語を選択します。 デバイス ツリーで、デバイスのコンテキスト メニューを開きます。 デバイス オブジェクトを選択し、 ソフトモーションを有効にする 指図。 あ SoftMotion 一般軸プール オブジェクトは下に挿入されます デバイス 。 デバイスツリーで、 SoftMotion一般軸プール 。コンテキストメニューで、をクリックします デバイスを追加 。 The デバイ...", 
"body" : "デバイスツリーへのオブジェクトの追加 次の手順では、軸グループを作成および構成する方法について説明します。 新しい標準プロジェクトを作成します CODESYS Control 。 POUの場合 PLC_PRG 、CFC 実装言語を選択します。 デバイス ツリーで、デバイスのコンテキスト メニューを開きます。 デバイス オブジェクトを選択し、 ソフトモーションを有効にする 指図。 あ SoftMotion 一般軸プール オブジェクトは下に挿入されます デバイス 。 デバイスツリーで、 SoftMotion一般軸プール 。コンテキストメニューで、をクリックします デバイスを追加 。 The デバイスを追加 ダイアログが開きます。 を選択 SM_ドライブ_仮想 デバイス。デバイスの名前を「DriveX」として指定します。 同様に、「DriveY」および「DriveZ」という名前のさらに 2 つのドライブを挿入します。 デバイスツリーで、 応用 オブジェクトをクリックして プロジェクト → オブジェクトを追加 → アクシスグループ 指定した名前のオブジェクトを挿入する 軸グループ 。 The 軸グループ オブジェクトがアプリケーションの下に挿入されます。軸グループコンフィギュレータが開きます。 構成エディターで、 キネマティクスを選択 ボタン。 The キネマティクスを選択 ダイアログが開き、使用可能なすべてのキネマティック構成とその説明のリストが表示されます。 を選択 TRAFO.Kin_Gantry3 運動学的構成。 選択したキネマティック構成の構成エディターが開きます。 の中に 軸へのマッピング パラメータグループで、軸をプロジェクトで使用されるドライブにマッピングします。これを行うには、値を指定します DriveX の中に バツ 入力フィールド、値 DriveY の中に はい 入力フィールドと値 DriveZ の中に ず 入力フィールド。入力アシスタントを使用することもできます ドライブを選択するか、デバイス ツリーから入力フィールドにドラッグします。 詳細については、以下を参照してください。 軸グループエディター" }, 
{ "title" : "軸グループエディター ", 
"url" : "_sm_obj_axis_group.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ アクシスグループ \/ 軸グループエディター ", 
"snippet" : "シンボル： のエディターで 軸グループ オブジェクトで、基本的な運動学と方向運動学のタイプを選択します。オリエンテーションキネマティクスは、基本キネマティクスでサポートされている場合にのみ選択できます。さらに、キネマティクスの軸をプロジェクトのドライブにマッピングします。 キネマティクス キネマティクスを選択 キネマティクスを変更する によってサポートされているすべてのキネマティクスのリストを開きます CODESYS キネマティクスのタイプを選択すると、リストの右側のフレームに簡単な説明が表示されます。 キネマティクスのタイプを選択した後、エディタでそれぞれのパラメータを変更できます。 オリエ...", 
"body" : "シンボル： のエディターで 軸グループ オブジェクトで、基本的な運動学と方向運動学のタイプを選択します。オリエンテーションキネマティクスは、基本キネマティクスでサポートされている場合にのみ選択できます。さらに、キネマティクスの軸をプロジェクトのドライブにマッピングします。 キネマティクス キネマティクスを選択 キネマティクスを変更する によってサポートされているすべてのキネマティクスのリストを開きます CODESYS キネマティクスのタイプを選択すると、リストの右側のフレームに簡単な説明が表示されます。 キネマティクスのタイプを選択した後、エディタでそれぞれのパラメータを変更できます。 オリエンテーション運動学 キネマティクスを選択 キネマティクスを変更する によってサポートされているすべてのオリエンテーションキネマティクスのリストを開きます CODESYS キネマティクスのタイプを選択すると、リストの右側のフレームに簡単な説明が表示されます。 キネマティクスのタイプを選択した後、エディタでそれぞれのパラメータを変更できます。 軸マッピング 選択したキネマティクスに応じて、キネマティクスの軸をプロジェクトのドライブにマッピングします。 追加軸 [軸を追加] 追加の軸の設定フィールドを追加します。この構成フィールドには、プロジェクトのドライブが入力されます。 タスク バスサイクルタスク 軸がすでにマップされている場合は、軸のバスサイクルタスク ここでは設定を変更できません。 計画タスク CPタスクの計画のためのタスク 最初の軸グループが挿入されると、計画タスクが自動的に作成されます。実行時間が大幅に変動する可能性があるため、ウォッチドッグは構成しないでください。 詳細については、以下を参照してください。 計画タスクの構成このタスクを削除すると、メッセージビューにエラーが表示されます。新しいタスクを作成するには、 プロジェクト → 計画タスクを作成する 。 詳細については、以下を参照してください。 軸グループを作成する方法" }, 
{ "title" : "軸グループの状態 ", 
"url" : "_sm_robotics_state_machine.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ アクシスグループ \/ 軸グループの状態 ", 
"snippet" : "下の画像は、軸グループの可能な状態と状態間の遷移を示しています。 個々の軸の誤差は常に軸グループを GroupErrorStop 州。 軸グループが GroupMoving 、その後すべての軸が SynchronizedMotion 。 軸グループが GroupMoving に GroupStandby 、その後すべての軸が standstill 。 軸グループが GroupMoving に GroupErrorStop 、その後すべての軸が GroupErrorStop 。 軸グループが GroupStandby 、その場合、個々の軸は必ずしもすべてではありません standstill これ...", 
"body" : "下の画像は、軸グループの可能な状態と状態間の遷移を示しています。 個々の軸の誤差は常に軸グループを GroupErrorStop 州。 軸グループが GroupMoving 、その後すべての軸が SynchronizedMotion 。 軸グループが GroupMoving に GroupStandby 、その後すべての軸が standstill 。 軸グループが GroupMoving に GroupErrorStop 、その後すべての軸が GroupErrorStop 。 軸グループが GroupStandby 、その場合、個々の軸は必ずしもすべてではありません standstill これらは、次のような単軸モーション機能ブロックによって制御できるためです。 MC_Jog 。 動作がエラーで終了した場合、バッファリングされた後続の動作はすべて中止され、 CommandAborted 。 軸グループが動的座標系に従う限り、それは GroupMoving 。 軸グループは GroupMoving グループが調整された方法で移動された場合（パート4のモーションブロックの1つによって）。からの切り替え GroupMoving に GroupStandby 最後の位置変更から1サイクル後に行われます。 " }, 
{ "title" : "計画タスクの構成 ", 
"url" : "_sm_configuration_planning_task.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ アクシスグループ \/ 計画タスクの構成 ", 
"snippet" : "軸グループの移動計画は、軸グループが挿入されると「SoftMotion_PlanningTask」という名前で自動的に作成される別のタスクで実行されます。デフォルトでは、この計画タスクはバス タスクと同じプロセッサ コアで実行されます。マルチコア システムでは、別のコアに配置することをお勧めします。計画タスクが独自のコアで実行されるかどうかに応じて、異なる構成にする必要があります。 シングルコア 計画タスクがバス タスクと同じコアで実行される場合、リアルタイム優先度が低いフリーホイール タスクとして構成する必要があります。これはデフォルトで設定されています。計画タスクは、優先度 15 のフリー...", 
"body" : "軸グループの移動計画は、軸グループが挿入されると「SoftMotion_PlanningTask」という名前で自動的に作成される別のタスクで実行されます。デフォルトでは、この計画タスクはバス タスクと同じプロセッサ コアで実行されます。マルチコア システムでは、別のコアに配置することをお勧めします。計画タスクが独自のコアで実行されるかどうかに応じて、異なる構成にする必要があります。 シングルコア 計画タスクがバス タスクと同じコアで実行される場合、リアルタイム優先度が低いフリーホイール タスクとして構成する必要があります。これはデフォルトで設定されています。計画タスクは、優先度 15 のフリーホイール タスクとして自動的に作成されます。 マルチコア マルチコア システムでは、計画タスクは最高の優先度 (0) を持つ別のコアで実行する必要があります。タスク タイプは周期的に設定し、タスク間隔は低い値 (たとえば、2 ミリ秒) に設定する必要があります。 これらの設定では、計画タスクは頻繁にタスク間隔を超えます。これは想定内のことであり、問題ではありません。タスク設定は、実行後すぐに計画タスクが再度呼び出されるように選択されています。このようにして、移動計画に専用コアが最大限に使用されます。 タスク構成の詳細については、以下を参照してください。 タスク構成 オブジェクト: タスク構成 オブジェクト: タスク " }, 
{ "title" : "運動学 ", 
"url" : "_sm_robotics_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動学 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概要 ", 
"url" : "_sm_overview_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動学 \/ 概要 ", 
"snippet" : "ロボット工学における最も重要なタスクの1つは、ツール（ツールプレートや溶接ガンなど）をあらかじめ定義された経路に沿って移動させることです。そのためには、 CODESYS SoftMotion Robotics ツールの先端であるツールセンターポイント (TCP) が指示された経路を任意の方向でたどるように、ロボットの個々の関節がどのように動く必要があるかを計算します。キネマティクスまたはキネマティック変換は、この計算の基本です。関節位置から TCP 位置および TCP 方向への変換、およびその逆の変換が実装されています 計算ルールは、使用するロボットの種類によって異なります。 CODESYS ...", 
"body" : "ロボット工学における最も重要なタスクの1つは、ツール（ツールプレートや溶接ガンなど）をあらかじめ定義された経路に沿って移動させることです。そのためには、 CODESYS SoftMotion Robotics ツールの先端であるツールセンターポイント (TCP) が指示された経路を任意の方向でたどるように、ロボットの個々の関節がどのように動く必要があるかを計算します。キネマティクスまたはキネマティック変換は、この計算の基本です。関節位置から TCP 位置および TCP 方向への変換、およびその逆の変換が実装されています 計算ルールは、使用するロボットの種類によって異なります。 CODESYS SoftMotion Robotics 多数の標準ロボット用の設定可能なキネマティクスが含まれています。 詳細については、以下を参照してください。 運動学を含む キネマティクスは、ポジショニングキネマティクスとオリエンテーションキネマティクスに分かれており、組み合わせることができます。 詳細については、以下を参照してください。 位置と方向の運動学の組み合わせ実行時に変更できるツールオフセットを設定できます。 詳細については、以下を参照してください。 ツールオフセットの構成回転ジョイントでは、無限に回転するモジュロ軸がサポートされています。 詳細については、以下を参照してください。 ロータリージョイントとモジュロ軸付属のキネマティクスのどれでも計算ルールをマッピングできない特殊なロボットタイプでは、ファンクションブロックの形で独自のキネマティクスを実装できます。 詳細については、以下を参照してください。 カスタムキネマティクスの作成" }, 
{ "title" : "運動学を含む CODESYS SoftMotion ", 
"url" : "_sm_robotics_cds_sm_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動学 \/ 運動学を含む CODESYS SoftMotion ", 
"snippet" : "ガントリーシステム 名前 表現 方向運動学とリンク可能 追加情報 Gantry2 ✓ キン・ガントリー2 (FB) Gantry3 ✓ キン・ガントリー3 (FB) HGantry2 ✓ キン_HGantry2 (FB) HGantry3 ✓ Kin_HGantry3 (FB) TGantry2 ✓ キン_TGantry2 (FB) 5軸ガントリー -- キン5アクシス（FB） SCARAシステム 名前 表現 方向運動学とリンク可能 追加情報 ポーラー ✓ キンポーラー（FB） Z軸付き極座標 ✓ キン・ポーラーZ（FB） Z軸付きScara2 ✓ キン_スカラ2_Z (FB) Z軸付きSca...", 
"body" : "ガントリーシステム 名前 表現 方向運動学とリンク可能 追加情報 Gantry2 ✓ キン・ガントリー2 (FB) Gantry3 ✓ キン・ガントリー3 (FB) HGantry2 ✓ キン_HGantry2 (FB) HGantry3 ✓ Kin_HGantry3 (FB) TGantry2 ✓ キン_TGantry2 (FB) 5軸ガントリー -- キン5アクシス（FB） SCARAシステム 名前 表現 方向運動学とリンク可能 追加情報 ポーラー ✓ キンポーラー（FB） Z軸付き極座標 ✓ キン・ポーラーZ（FB） Z軸付きScara2 ✓ キン_スカラ2_Z (FB) Z軸付きScara3 -- キン_スカラ3_Z (FB) 多関節ロボット 名前 表現 方向運動学とリンク可能 追加情報 3つの回転軸を備えた多関節ロボット ✓ キンポスRRR（FB） 4軸パレタイザー -- Kin_4Axesパレタイザー (FB) 6軸多関節ロボット -- Kin_関節型ロボット_6DOF (FB) 並列システム 名前 表現 方向運動学とリンク可能 追加情報 回転軸付きバイポッド ✓ キン・バイポッド・ロータリー (FB) 回転軸付き三脚 ✓ キン・トライポッド・ロータリー (FB) 直線軸付き三脚 ✓ キン_三脚_リニア (FB) 方向運動学 名前 表現 追加情報 C軸 キン_CAxis (FB) ツール付きC軸 Kin_CAxis_ツール (FB) 道具 キンツール（FB） Wrist2 キン_リスト2 (FB) Wrist3 キン_リスト3 (FB) " }, 
{ "title" : "位置と方向の運動学の組み合わせ ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動学 \/ 位置と方向の運動学の組み合わせ ", 
"snippet" : "軸グループコンフィギュレータを使用すると、位置運動学と方向運動学を組み合わせることができます。その結果、少数の運動学で多数のロボットを構成できます。 位置運動学の例には、ガントリー（ Kin_Gantry3 ）と三脚（ Kin_Tripod_Lin 、 Kin_Tripod_Rotary ）。これらのキネマティクスは、任意のポイントまたは位置に移動できますが、任意の数の方向を実行することはできません。位置キネマティックシステムのフロント座標系は、フランジ座標系と呼ばれます。これは、方向の運動学が固定される場所を定義します（左の図）。 配向運動学の例は次のとおりです。 Kin_CAxis 、 K...", 
"body" : "軸グループコンフィギュレータを使用すると、位置運動学と方向運動学を組み合わせることができます。その結果、少数の運動学で多数のロボットを構成できます。 位置運動学の例には、ガントリー（ Kin_Gantry3 ）と三脚（ Kin_Tripod_Lin 、 Kin_Tripod_Rotary ）。これらのキネマティクスは、任意のポイントまたは位置に移動できますが、任意の数の方向を実行することはできません。位置キネマティックシステムのフロント座標系は、フランジ座標系と呼ばれます。これは、方向の運動学が固定される場所を定義します（左の図）。 配向運動学の例は次のとおりです。 Kin_CAxis 、 Kin_Wrist2 、 と Kin_Wrist3 。これらの運動学は、TCPの望ましい方向をもたらす可能性がありますが、どの位置にも到達できません（右の図を参照）。 位置キネマティクスと方向キネマティクスの両方を組み合わせることにより、任意の数の位置を目的の方向に、またはその逆に移動することができます。 カスタマイズされたキネマティクスに関する注意 独自の位置または方向の運動学を作成したいユーザーは、運動学関数ブロックに次の追加インターフェースを実装する必要があります。 位置キネマティクスの場合：インターフェース ISMPositionKinematics2 メソッドで AxesToOrientation と GetOrientationImage 。 AxesToOrientation は、軸の値からフランジ座標系の方向を計算する「省略された」前方変換です。効率の理由でのみ必要です。たとえば、ガントリーで計算する必要はありませんが、一定の方向を返すことができます。 GetOrientationImage フランジ座標系の方向がどのように変化するかを返します。この方法は、方向の運動学が位置の運動学と互換性があるかどうかを確認するためにのみ必要です。 オリエンテーションキネマティクスの場合：インターフェース ISMToolKinematics2 メソッドで GetPositionFromOrientation2 と IsCompatibleWithPosKin 。 GetPositionFromOrientation2 フランジ座標系とTCPの間のベクトルを目的の方向（MCS）から計算します。この計算は、結合された運動学の逆変換に必要です。メソッド IsCompatibleWithPosKin 方向キネマティクスが位置キネマティクスと互換性があるかどうかをチェックします。 " }, 
{ "title" : "無効な組み合わせ ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html#UUID-ccacfa9e-092b-a9a9-875d-01e9182027a1_id_dd90bf9efee04f9c0a8646352f64466_id_718d71abf014b14bc0a864635271f262", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動学 \/ 位置と方向の運動学の組み合わせ \/ 無効な組み合わせ ", 
"snippet" : "位置キネマティクスと方向キネマティクスのすべての組み合わせが可能であるとは限りません。これは、一意の逆変換を決定できない場合があるためです。一例は、位置運動学としての2つの関節関節を備えたスカラです。 Kin_CAxis_Tool X座標またはY座標で0ではないツールオフセットを使用した方向キネマティクスとして。スカラのフランジ座標系の向きは一定ではありません。 0の位置を基準にしてZ軸を中心に回転します。逆変換の計算では、この回転はまだわかっていないため、この場合、軸角度を明確に決定することはできません。 組み合わせが可能かどうかは、キネマティクスのパラメータ化に依存するため、実行時に確認で...", 
"body" : "位置キネマティクスと方向キネマティクスのすべての組み合わせが可能であるとは限りません。これは、一意の逆変換を決定できない場合があるためです。一例は、位置運動学としての2つの関節関節を備えたスカラです。 Kin_CAxis_Tool X座標またはY座標で0ではないツールオフセットを使用した方向キネマティクスとして。スカラのフランジ座標系の向きは一定ではありません。 0の位置を基準にしてZ軸を中心に回転します。逆変換の計算では、この回転はまだわかっていないため、この場合、軸角度を明確に決定することはできません。 組み合わせが可能かどうかは、キネマティクスのパラメータ化に依存するため、実行時に確認できます。この場合、エラー SMC_TRAFO_INVALID_COUPLING 発行されます。 " }, 
{ "title" : "「不可能な」方向をプログラミングするときの動作 ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html#UUID-ccacfa9e-092b-a9a9-875d-01e9182027a1_id_dd90bf9efee04f9c0a8646352f64466_id_5ba01e61f014b14bc0a86463044fcdf7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動学 \/ 位置と方向の運動学の組み合わせ \/ 「不可能な」方向をプログラミングするときの動作 ", 
"snippet" : "実際には、キネマティクスで使用できないオリエンテーションをプログラムできると便利なことがよくあります。簡単な例として、1つの自由度（Z軸を中心とした回転）を持つツールを備えたスカラロボットを考えてみます。原則として、このロボットは、ツールが垂直下向きになる方向のみを受け入れることができます。 ワークピース上で位置を移動する必要がある場合、ワークピースはX \/ Y平面から簡単に傾斜します。ユーザーはワークピースを教えてから、ワークピースに対する相対的な位置と方向をプログラムします。ワークを傾けると、工具の方向が垂直からわずかに傾く方向になります。 このような不可能で到達不可能な方向をどう扱うか？...", 
"body" : "実際には、キネマティクスで使用できないオリエンテーションをプログラムできると便利なことがよくあります。簡単な例として、1つの自由度（Z軸を中心とした回転）を持つツールを備えたスカラロボットを考えてみます。原則として、このロボットは、ツールが垂直下向きになる方向のみを受け入れることができます。 ワークピース上で位置を移動する必要がある場合、ワークピースはX \/ Y平面から簡単に傾斜します。ユーザーはワークピースを教えてから、ワークピースに対する相対的な位置と方向をプログラムします。ワークを傾けると、工具の方向が垂直からわずかに傾く方向になります。 このような不可能で到達不可能な方向をどう扱うか？ 極端な方法としては、ワークスペース違反を報告することです。 しかし、例が示すように、これではプログラミングが面倒になります。 そのため、方向運動学（ Kin_CAxis_Tool この例では、コマンドされた方向はツールが直立するように傾けられ、この方向が受け入れられます。 動作は、次のルールに減らすことができます（位置キネマティクスが3つの空間方向すべてに配置できる場合）。 位置は常に正確に近づきます（そうでない場合はエラーが報告されます）。 方向に到達できない場合、方向は最も近いアクセス可能な方向に「投影」されます。 方向を投影するときは、ツールの方向が優先されます。 ここで説明する問題は、方向運動学がすべての望ましい方向を達成するための3つの自由度を持っていないために発生します。これは Kin_Wrist2 と Kin_CAxis 、しかしではない Kin_Wrist3 。 位置運動学にもすべての空間自由度がない場合は、さらに問題が発生します。 （これは実際には頻繁には発生しません。）1つの例は、 Kin_Gantry2 、X \/ Yのみに配置できるガントリー Kin_Wrist2 、自由度が2つしかないツール。この場合、Z座標は工具の長さと方向軸の位置によってすでに定義されているため、不可能な方向と不可能な位置があります。したがって、これらの種類の組み合わせを使用するのではなく、達成可能な位置のみをプログラムすることをお勧めします。 " }, 
{ "title" : "キネマティック構成 ", 
"url" : "_sm_configure_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動学 \/ キネマティック構成 ", 
"snippet" : "キネマティック構成は、軸グループ内の軸の相互のレイアウトを記述します。キネマティクスに応じて、同じTCP位置に対して複数の構成が可能です。 たとえば、SCARA2の2つの可能な構成が示されています。 軸グループにはアクティブな構成があり、必ずしも現在の軸の位置に対応している必要はありません。移動が指示された場合、目標位置は軸座標に変換される場合があります。コマンド時にアクティブな構成が使用されます。 このアクティブな設定は、機能ブロックで設定できます SMC_SetKinConfiguration 。初期化中およびキネマティクスが変更されるたびに、軸グループは標準構成を適用します。構成を持つす...", 
"body" : "キネマティック構成は、軸グループ内の軸の相互のレイアウトを記述します。キネマティクスに応じて、同じTCP位置に対して複数の構成が可能です。 たとえば、SCARA2の2つの可能な構成が示されています。 軸グループにはアクティブな構成があり、必ずしも現在の軸の位置に対応している必要はありません。移動が指示された場合、目標位置は軸座標に変換される場合があります。コマンド時にアクティブな構成が使用されます。 このアクティブな設定は、機能ブロックで設定できます SMC_SetKinConfiguration 。初期化中およびキネマティクスが変更されるたびに、軸グループは標準構成を適用します。構成を持つすべてのキネマティクスには、標準構成があります。 2つの構成間のCP移動はできません。この場合、ポジショニングはPTPムーブメントを使用して行う必要があります。 現在の構成は、機能ブロックで決定することができます MC_GroupReadActualPosition 。 " }, 
{ "title" : "1つのキネマティックデザインの構成を設定する ", 
"url" : "_sm_configure_kinematics.html#UUID-a0dd90bd-a3ae-b4c7-c573-b244e5ca8497_id_fd441540121e3a8c0a8646325f17a66_id_b2318eb4acf011e79acc88930c5b16a7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動学 \/ キネマティック構成 \/ 1つのキネマティックデザインの構成を設定する ", 
"snippet" : "構成を使用するすべてのキネマティックデザインには、構成データを計算するための独自のPOUがあります。この機能ブロックの名前は、キネマティクスの名前と接尾辞に対応しています。 _config 。 POUは、さまざまな構成をデータ型に変換します ConfigData 。このデータ型は機能ブロックに渡されます SMC_SetKinConfiguration 。 例：SCARA2キネマティックデザインの構成を設定する 機能ブロックを呼び出す Kin_Scara2_Z_Config 図書館から SM3_Transformation 。入力 xElbowRight = TRUE 機能ブロックは、タイプの構...", 
"body" : "構成を使用するすべてのキネマティックデザインには、構成データを計算するための独自のPOUがあります。この機能ブロックの名前は、キネマティクスの名前と接尾辞に対応しています。 _config 。 POUは、さまざまな構成をデータ型に変換します ConfigData 。このデータ型は機能ブロックに渡されます SMC_SetKinConfiguration 。 例：SCARA2キネマティックデザインの構成を設定する 機能ブロックを呼び出す Kin_Scara2_Z_Config 図書館から SM3_Transformation 。入力 xElbowRight = TRUE 機能ブロックは、タイプの構成データを生成します ConfigData 。 機能ブロックを呼び出す SMC_SetKinConfiguration 図書館から SM3_Robotics 。入力を書き込む ConfigData 以前に決定された構成データを使用します。 SCARA2のアクティブな構成を設定します。 VAR\n config: TRAFO.Kin_Scara2_Z_Config;\n skc: SMC_SetKinConfiguration;\nEND_VAR\n\nconfig(xElbowRight := TRUE);\nskc(AxisGroup := Scara2, Execute := TRUE, ConfigData := config.Config); " }, 
{ "title" : "結合された運動学の取り扱い ", 
"url" : "_sm_configure_kinematics.html#UUID-a0dd90bd-a3ae-b4c7-c573-b244e5ca8497_id_fd441540121e3a8c0a8646325f17a66_id_b22c1067acf011e79acc88930c5b16a7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動学 \/ キネマティック構成 \/ 結合された運動学の取り扱い ", 
"snippet" : "位置キネマティクスと方向キネマティクスが同時に使用される場合、結合キネマティクスが存在します。これにより、を呼び出すことにより、両方の構成から「結合」構成が得られます。 Kin_Coupled_Config 図書館から SM3_Transformation 。位置キネマティクスと方向キネマティクスの構成は、入力の機能ブロックに提供されます。 詳細については、以下を参照してください。 360°を超える値の範囲を持つ回転軸...", 
"body" : "位置キネマティクスと方向キネマティクスが同時に使用される場合、結合キネマティクスが存在します。これにより、を呼び出すことにより、両方の構成から「結合」構成が得られます。 Kin_Coupled_Config 図書館から SM3_Transformation 。位置キネマティクスと方向キネマティクスの構成は、入力の機能ブロックに提供されます。 詳細については、以下を参照してください。 360°を超える値の範囲を持つ回転軸" }, 
{ "title" : "ツールオフセットの構成 ", 
"url" : "_sm_configure_tool_offset.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動学 \/ ツールオフセットの構成 ", 
"snippet" : "ツールオフセットを設定することにより、キネマティクスのフランジ座標系（XYZ）とキネマティクスのTCP座標系（X'Y'Z '）の間のオフセットを設定できます。このツールオフセットは、後続のすべての動きに作用します。 TCP：ツールセンターポイント ツールオフセットはシフトによって指定されます v=(x,y,z) とローテーション r=(A,B,C) ZYZオイラー角で。シフトと回転は、キネマティクスのフランジ座標系を基準にして表されます。 ツールオフセットを設定すると、現在のキネマティクスと互換性がなくなる場合があります。その結果、ツールオフセットによってキネマティクスが方向を達成できなくなる...", 
"body" : "ツールオフセットを設定することにより、キネマティクスのフランジ座標系（XYZ）とキネマティクスのTCP座標系（X'Y'Z '）の間のオフセットを設定できます。このツールオフセットは、後続のすべての動きに作用します。 TCP：ツールセンターポイント ツールオフセットはシフトによって指定されます v=(x,y,z) とローテーション r=(A,B,C) ZYZオイラー角で。シフトと回転は、キネマティクスのフランジ座標系を基準にして表されます。 ツールオフセットを設定すると、現在のキネマティクスと互換性がなくなる場合があります。その結果、ツールオフセットによってキネマティクスが方向を達成できなくなる可能性があります。この状況では、エラーが発生し、ツールオフセットは無視されます。たとえば、キネマティクスのZ方向にツールオフセットを設定できます。 Kin_Scara2_Z 一方、X方向またはY方向の部品のオフセットはエラーになります。運動学にこのような制限がある場合は、 運動学 。 " }, 
{ "title" : "機能ブロック：SMC_GroupSetTool ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_348cb75b4119d4bfc0a864631ca28fed", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動学 \/ ツールオフセットの構成 \/ 機能ブロック：SMC_GroupSetTool ", 
"snippet" : "機能ブロックは、入力で指定された工具オフセットを構成します ToolOffset （タイプ MC_COORD_REF ）軸グループの場合。ただし、軸グループが状態にある限り GroupDisabled また GroupErrorStop 、 いいえ ツールオフセットを設定できます。 ツールが現在のキネマティクスと互換性がない場合、POUはエラーを発行します SMC_AXIS_GROUP_TOOL_OFFSET_INCOMPATIBLE_WITH_KINEMATICS 。このエラーは、インターフェイスが ISMKinematicsWithOrientationImage キネマティクスの説明には...", 
"body" : "機能ブロックは、入力で指定された工具オフセットを構成します ToolOffset （タイプ MC_COORD_REF ）軸グループの場合。ただし、軸グループが状態にある限り GroupDisabled また GroupErrorStop 、 いいえ ツールオフセットを設定できます。 ツールが現在のキネマティクスと互換性がない場合、POUはエラーを発行します SMC_AXIS_GROUP_TOOL_OFFSET_INCOMPATIBLE_WITH_KINEMATICS 。このエラーは、インターフェイスが ISMKinematicsWithOrientationImage キネマティクスの説明には実装されていません。 " }, 
{ "title" : "機能ブロック：SMC_GroupReadTool ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_c1689be51d4132b4c0a864637c06bdff", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動学 \/ ツールオフセットの構成 \/ 機能ブロック：SMC_GroupReadTool ", 
"snippet" : "この機能ブロックは工具オフセットを読み取ります：出力 ToolOffset （タイプ MC_COORD_REF ）。このプロセスでは、入力 ReadMode アクティブな移動のツール、最後にコマンドされた移動、または軸グループに現在設定されているツールを読み取るかどうかを決定します。...", 
"body" : "この機能ブロックは工具オフセットを読み取ります：出力 ToolOffset （タイプ MC_COORD_REF ）。このプロセスでは、入力 ReadMode アクティブな移動のツール、最後にコマンドされた移動、または軸グループに現在設定されているツールを読み取るかどうかを決定します。 " }, 
{ "title" : "互換性のあるキネマティクス ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_ff04bb6d41a8190bc0a864635e26fe13", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動学 \/ ツールオフセットの構成 \/ 互換性のあるキネマティクス ", 
"snippet" : "すべてのキネマティクスがすべてのツールオフセットをサポートしているわけではありません。次のリストは、どのツールがどのキネマティクスに適しているかを示しています。 キネマティクス 互換性のあるツール SCARA2キネマティクス Kin_Scara2_Z Z方向に位置がオフセットされ、方向がオフセットされている工具 SCARA3キネマティクス Kin_Scara3_Z すべてのツール 極運動学 Kin_Polar 、 Kin_Polar_Z Z方向に位置がオフセットされ、方向がオフセットされている工具 3軸多関節ロボット Kin_Pos_RRR 方向にオフセットがある工具 6軸多関節ロボット Ki...", 
"body" : "すべてのキネマティクスがすべてのツールオフセットをサポートしているわけではありません。次のリストは、どのツールがどのキネマティクスに適しているかを示しています。 キネマティクス 互換性のあるツール SCARA2キネマティクス Kin_Scara2_Z Z方向に位置がオフセットされ、方向がオフセットされている工具 SCARA3キネマティクス Kin_Scara3_Z すべてのツール 極運動学 Kin_Polar 、 Kin_Polar_Z Z方向に位置がオフセットされ、方向がオフセットされている工具 3軸多関節ロボット Kin_Pos_RRR 方向にオフセットがある工具 6軸多関節ロボット Kin_ArticulatedRobot_6DOF すべてのツール 4軸パレタイザー Kin_4AxisPalletizer すべてのツール バイポッド Kin_Bipod_Rotary すべてのツール 5軸ガントリー Kin_5Axes すべてのツール ガントリーシステム すべてのツール Hガントリーシステム すべてのツール Tガントリーシステム すべてのツール ロータリーまたはリニア三脚 すべてのツール キネマティックシステムに方向の3自由度がない場合は、すべてのツールオフセットに互換性があるとは限りません。 " }, 
{ "title" : "カスタムキネマティクスの場合 ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_6c7b39581d4132b4c0a8646366a3228c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動学 \/ ツールオフセットの構成 \/ カスタムキネマティクスの場合 ", 
"snippet" : "ツールオフセットでカスタムキネマティクスを使用するには、 ISMKinematicsWithOrientationImage インターフェース。カスタム位置運動学にツールオフセットを追加するには、まずインターフェースを実装する必要があります。 ISMPositionKinematics2 。...", 
"body" : "ツールオフセットでカスタムキネマティクスを使用するには、 ISMKinematicsWithOrientationImage インターフェース。カスタム位置運動学にツールオフセットを追加するには、まずインターフェースを実装する必要があります。 ISMPositionKinematics2 。 " }, 
{ "title" : "インターフェイス：ISMKinematicsWithOrientationImage ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_592ee99f1d4132b4c0a864637bd8a061", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動学 \/ ツールオフセットの構成 \/ インターフェイス：ISMKinematicsWithOrientationImage ", 
"snippet" : "キネマティックインターフェースはメソッドを提供します GetFlangeOrientationImage 変数を使って mR_Flange データ型の SMC_Matrix3 、フランジのコマンドされた方向が含まれています。結果として、メソッドは可能な結果の方向を返します oriInfo データ型として OrientationSpace 。 インターフェイスの動作 特に、指令された方向でのフランジの方向がわかっている場合、 dof = zero 返され、 mOriZero 既知の方向に設定されます。 オリエンテーションの場合 R フランジのは、フォームで部分的にしか知られていません R*vU ...", 
"body" : "キネマティックインターフェースはメソッドを提供します GetFlangeOrientationImage 変数を使って mR_Flange データ型の SMC_Matrix3 、フランジのコマンドされた方向が含まれています。結果として、メソッドは可能な結果の方向を返します oriInfo データ型として OrientationSpace 。 インターフェイスの動作 特に、指令された方向でのフランジの方向がわかっている場合、 dof = zero 返され、 mOriZero 既知の方向に設定されます。 オリエンテーションの場合 R フランジのは、フォームで部分的にしか知られていません R*vU = vRot （どこ vU と vRot 既知の単位ベクトルです）、 dof = one が返されます。 mOriZero 到達可能なスペースの方向に設定されます。 さもないと、 dof = three が返されます。 計算された方向を考慮してフランジ位置を一意に計算できる場合、指定されたツールオフセットはキネマティクスと互換性があります。これは、計算された方向がキネマティクスによって達成できる場合に常に当てはまります。ツールオフセットは、すべての方向に到達できない場合にのみ互換性がない可能性があります。また、その方法が GetFlangeOrientationImage 戻り値 dof = zero 、その後、すべてのツールオフセットに互換性があります。メソッドが返す場合 dof = one 、次に工具位置オフセットのみ v_off 単位ベクトルに平行 vU 互換性があります。この場合、 R*v_off = R*vU*x = vRot*x 方向行列の未知の部分に依存しません R 。これには、次のような工具オフセットも含まれます。 v_off = 0 （ここで、x = 0）。もしも dof = three が返されると、x \/ y \/ zにオフセットのない位置シフトのみが互換性があります。 実装上の注意 インターフェイスを実装する ISMOrientationKinematicsWithOriImage2 オリエンテーションキネマティクス用。次に、ツールオフセットを使用して、方向キネマティクスと位置キネマティクスを結合できます。インターフェイスにはメソッドがあります GetOrientationImage2 変数を使って VAR_IN_OUT CONSTANT mR_Flange データ型の SMC_Matrix3 、フランジのコマンドされた方向が含まれています。 メソッドは csTool と oriinfo データ型 OrientationSpace 方向運動学の基本座標系で。 さらに、メソッドはに戻ります bActive からの自由度かどうか orinfo アクティブです（ TRUE ）またはパッシブ（ FALSE ）。 アクティブな自由度の例： Kin_CAxis 。 z軸を中心とした回転は、方向運動学軸によって制御されます。 受動的な自由度の例： Kin_Wrist2 。残りの自由度は、ユーザーがプログラムした方向を指すZ軸を中心としたX \/ Yの回転です。 工具交換時の最後の指令動作と新動作の両方がCP動作（直線動作または回転動作）の場合、後続動作のバッファモードを以下から変更します。 Blending また Aborting に Buffered 。 後に新しい工具オフセットを設定する場合 MC_GroupInterrupt と前に MC_GroupContinue 、その後、古いツールオフセットが中断された動きに使用されます。新しいツールオフセットは、後で命令される移動にのみ使用されます。 キネマティクスが変更されたとき（ MC_SetKinTransform ）、ツールオフセットがリセットされます（シフトなし、回転なし）。 " }, 
{ "title" : "ロータリージョイントとモジュロ軸 ", 
"url" : "_sm_robotics_rotary_joints_modulo_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動学 \/ ロータリージョイントとモジュロ軸 ", 
"snippet" : "SoftMotion 4.12.0.0以降、軸グループ内のモジュロ軸がサポートされています。 モジュロ軸は、キネマティクスのスイベルジョイントでのみ許可されます。これらは、そのためのスイベルジョイントです SMKinematicWithInfo.GetAxisProperties 値を返します props.eType = Axis_Type.Rotary 。モジュロ軸が線形ジョイントまたは実装されていないキネマティックに使用される場合 ISMKinematicWithInfo 、 それから MC_GroupEnable を返します SMC_MODULO_AXIS_FOR_NON_ROTARY_...", 
"body" : "SoftMotion 4.12.0.0以降、軸グループ内のモジュロ軸がサポートされています。 モジュロ軸は、キネマティクスのスイベルジョイントでのみ許可されます。これらは、そのためのスイベルジョイントです SMKinematicWithInfo.GetAxisProperties 値を返します props.eType = Axis_Type.Rotary 。モジュロ軸が線形ジョイントまたは実装されていないキネマティックに使用される場合 ISMKinematicWithInfo 、 それから MC_GroupEnable を返します SMC_MODULO_AXIS_FOR_NON_ROTARY_JOINT エラー。モジュロ軸が使用され、運動学がスイベルジョイントの範囲を制限する場合、 MC_GroupEnable を返します SMC_MODULO_AXIS_FOR_LIMITED_ROTARY_JOINT エラー。 モジュロ軸は、モジュロ周期が360°の場合にのみサポートされます。この理由は、スイベルジョイントに接続された軸は、1つの技術単位[u]が1つの角度[°]に対応するように構成する必要があるためです。 1周期は、1回転に対応する必要があります。 360°以外の周期のモジュロ軸が使用されている場合、 MC_GroupEnable を返します SMC_MODULO_AXIS_PERIOD_NOT_360 エラー。 バージョン4.12.0.0以降、 SoftMotion のみをサポートします shortest モード（ MC_DIRECTION ）。これは、モジュロ軸の距離と方向が、軸の開始位置にできるだけ近くなるように選択されることを意味します。たとえば、方向軸が移動の開始時にa2 = 30°にあり、ターゲット位置でa2 = 290°にある場合、位置a2 = 290°–360°= –70°が選択され、軸が移動します。正の方向に260°移動するのではなく、負の方向に100°移動します。 " }, 
{ "title" : "カスタムキネマティクスの作成 ", 
"url" : "_sm_kinematic_transformations.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動学 \/ カスタムキネマティクスの作成 ", 
"snippet" : "オープンソースツール wkhtmltopdf ファンクションブロックのコメントからキネマティクスのドキュメントを生成するために必要です。ただし、このコンポーネントは、のセットアップには含まれなくなりました。 CODESYS バージョン3.5SP15以降。 DLLはからダウンロードできます https:\/\/wkhtmltopdf.org\/downloads.html 。という名前のディレクトリを作成します DocScripting\\3.5.xx.x\\bin のインストールディレクトリ CODESYS ファイルを保存します wkhtmltox.dll そこの。 注意：以来 wkhtmltox.dl...", 
"body" : "オープンソースツール wkhtmltopdf ファンクションブロックのコメントからキネマティクスのドキュメントを生成するために必要です。ただし、このコンポーネントは、のセットアップには含まれなくなりました。 CODESYS バージョン3.5SP15以降。 DLLはからダウンロードできます https:\/\/wkhtmltopdf.org\/downloads.html 。という名前のディレクトリを作成します DocScripting\\3.5.xx.x\\bin のインストールディレクトリ CODESYS ファイルを保存します wkhtmltox.dll そこの。 注意：以来 wkhtmltox.dll バージョン0.12.6以降では、デフォルトでイメージをサポートしなくなりました。バージョン0.12.5以下を使用する必要があります。 軸グループのキネマティック変換のインスタンスを使用する場合、インスタンスの入力を変更してはなりません。 キネマティックトランスフォーメーションのパラメータ化を変更するには、可能であれば設定を使用するか、複数のインスタンスを作成する必要があります。 カスタムキネマティクスを作成するときは、次の点に注意する必要があります。 キネマティクスは、ライブラリまたはライブラリに保存できる特別な機能ブロックによって記述されます。 POU プロジェクトのビュー。 にとって CODESYS 構成機にキネマティクスをリストするには、関連する機能ブロックが実装する必要があります。 MC_KIN_REF_SM3 インターフェイス（の一部 SM3_Transformation.library ）。 運動学は他の2つの運動学の組み合わせとして定義できます。ツールプレートまたはツールを取り付ける可能性のある運動学は、 ISM位置運動学2 インターフェース。ツールプレートまたはツールを指定するキネティクスは、 ISMツールキネマティクス2 インターフェース。 のみを実装する場合 ISMPositionKinematics \/ ISMToolKinematics それ以外の ISMPositionKinematics2 \/ ISMToolKinematics2 、その後、「使用できない」方向が正しく処理されない可能性があります。 インターフェイスも実装する場合 ISMPositionKinematics_Offset 、オリエンテーションモードを使用できます Axis 。 POUに sm_kin_libdoc 属性、機能ブロックで指定されたコメントは、キネマティクスの説明としてコンフィギュレータで使用されます。これには「RestructuredText」フォーマットが使用されます。ただし、リンクはサポートされていないことに注意してください。 アームの長さや角度などの設計関連のパラメータは、ファンクションブロックのVAR_INPUT変数として作成されます。コメントはコンフィギュレータでの説明として機能するため、パラメータにコメントを付ける必要があります。パラメータが数値型で値の範囲が制限されている場合は、 sm_kin_param_range 属性。 値の範囲の構文は次のとおりです。 [a .. b] 閉じた間隔と ]a .. b[ オープンインターバル用。結合されたフォーム ]a .. b] と [a .. b[ 可能です。この目的のために、 a と b パラメータタイプに適切なリテラルである必要があります。特別な値 +inf と -inf オープンインターバル制限が可能です。例： [0 .. 1] 、 [1 .. +inf[ 、 ]-inf .. -5] 。 パラメータは、任意の数値型または BOOL 。パラメータには、デフォルト値として使用される初期値が必要です。オプションの属性でパラメータの単位を指定できます sm_kin_param_unit （例： \"rad\"、 \"°\"、 \"deg\"）。長さと距離には単位「u」を使用する必要があります。ドライブのアプリケーションとスケーリングによって、これらの単位が「mm」、「cm」、または「m」のいずれであるかが決まります。 ファンクション ブロックに使用できるライブラリ ドキュメントがない場合、FB 要素のコメントがフォールバック オプションとしてそれぞれの位置に表示されます。 で構成された言語 CODESYS LibDocドキュメントに表示される言語です。この言語でローカリゼーションが利用できない場合は、ライブラリのデフォルト言語が使用されます。 キネマティクスの軸名は、FB属性によって定義されます sm_kin_axes 。属性の値は、軸名のリストです（例：「A1、A2、A3」）。 オプションのアイコンがFB属性で指定されている sm_kin_icon 。値は次の形式で指定されます <image pool>.<identifier> 。イメージプールは、機能ブロックに関連して指定されます。 回転軸を使用してカスタムキネマティクス機能ブロックを作成する場合（たとえば、 Kin_Scara3_Z_Config ）、次に、これらの軸に期間の概念を使用して、 ISMKinPeriodHandling インターフェース。回転軸の場合、逆運動学的変換のみ（ CartesianToAxes ）角度の計算を担当します。それで CODESYS SoftMotion この角度を自動的に正しい周期にシフトします。たとえば、変換で] -180°、180°]の範囲の角度が計算される場合、 CODESYS SoftMotion ドライブのソフトウェア境界が0°..360°の場合、この角度を[0°、360°[]の範囲にシフトします。さらに、実装する必要があります ISMKinematicsWithConfiguration3 インターフェース。これは、CP運動の運動学が問題なく機能することを確認する唯一の方法です。 位置と方向のキネマティクスのレイアウトが不規則な結合キネマティクスの場合は、 ISMCoupledKinematics3 インターフェース。このようにして、システムは、位置または方向の運動学の軸がそれぞれの軸番号に属するかどうかを検出できます。 注：実装する必要があります ISMKinematicWithConfigurations2.CPConnectible 期間設定が比較時に無視されるような方法。それで CPConnectible 値を返します TRUE 、期間設定が異なっていても。 すべての逆変換には、タイプの入力があります CONFIGDATA これには、キネマティクスの構成に関する情報を含むバイト配列が含まれています。順方向変換には、対応する出力があります。構成を使用するキネマティクスは、 ISMKinematicWithConfigurations インターフェース。これらのキネマティクスにはそれぞれ、実装する必要のある機能ブロックが含まれています。 ISMConfigurationData インターフェイス（構成データのシリアル化のための機能）。この機能ブロックの名前は、キネマティクスに接尾辞を加えたものと同じ名前である必要があります _config 。このFBを使用して、アプリケーションの設定を変更することができます（機能ブロックを使用） SMC_SetKinConfiguration ブロック）。ただし、キネマティクスは、対応するFBのインスタンスを保持するべきではありません。 詳しい手順については、 カスタムキネマティクス 章。 " }, 
{ "title" : "座標系 ", 
"url" : "_sm_coordinate_systems.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 座標系 ", 
"snippet" : "CODESYS SoftMotion Robotics には、動きを制御できるさまざまな座標系が用意されています。 座標軸システム (ACS) ツール座標系 (TCS) ワールド座標系 (WCS) マシン座標系 (MCS) プロダクト座標系 (PCS_1、PCS_2) 座標系 [説明] 座標軸システム (ACS) 軸座標系は、ロボットの各軸が 1 次元にまたがる軸空間の座標系を定義します。その結果、ロボットの各軸の位置を指定できます ツール座標系 (TCS) ツール座標系は、キネマティクスのツール中心点 (TCP) 上にあるデカルト座標系です。その位置と向きはロボットの位置によって異なります。...", 
"body" : "CODESYS SoftMotion Robotics には、動きを制御できるさまざまな座標系が用意されています。 座標軸システム (ACS) ツール座標系 (TCS) ワールド座標系 (WCS) マシン座標系 (MCS) プロダクト座標系 (PCS_1、PCS_2) 座標系 [説明] 座標軸システム (ACS) 軸座標系は、ロボットの各軸が 1 次元にまたがる軸空間の座標系を定義します。その結果、ロボットの各軸の位置を指定できます ツール座標系 (TCS) ツール座標系は、キネマティクスのツール中心点 (TCP) 上にあるデカルト座標系です。その位置と向きはロボットの位置によって異なります。 ワールド座標系 (WCS) ワールド座標系は静的なデカルト座標系で、以降のすべての座標系の基礎となります。これらはワールド座標系を基準にして定義されます マシン座標系 (MCS) マシン座標系は静的なデカルト座標系です。物理ロボットに対するMCSの位置と向きは、キネマティクスによって定義されます ザル MC_Set 座標トランスフォーム ファンクションブロックを使用して、ワールド座標系 (WCS) を基準にして座標系をシフトできます。 プロダクト座標系 (PCS_1、PCS_2) 製品座標系は、ユーザーが定義できるデカルト座標系です。これらはワールド座標系 (WCS) を基準にして表され、静的でも動的でもかまいません 静的 ザル MC_Set 座標トランスフォーム ファンクションブロックを使用して、ワールド座標系 (WCS) を基準にして座標系を移動できます。 ダイナミック 次のファンクションブロックを使用して動的座標系を定義できます。 MC_DYN 座標変換の設定 SMC_Set DyncoordTransformEX MC_トラックコンベヤーベルト MC_トラックロータリーテーブル " }, 
{ "title" : "座標系の初期位置と方向 ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056579261585", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 座標系 \/ 座標系の初期位置と方向 ", 
"snippet" : "ロボットの運動学によって、座標系の初期位置と向きが決まります。これはキネマティクスのドキュメンテーションに記載されています キネマティクスは以下を定義します。 物理ロボットに対するマシン座標系 (MCS) の位置と方向 MCS、ひいては工具座標系 (TCS) に対する工具中心点 (TCS) の位置と方向 ロボットのゼロ位置、および個々の軸の回転または移動方向 ワールド座標系 (WCS) とプロダクト座標系 (PCS_1、PCS_2) は最初はシフトされず、マシン座標系と同じです。...", 
"body" : "ロボットの運動学によって、座標系の初期位置と向きが決まります。これはキネマティクスのドキュメンテーションに記載されています キネマティクスは以下を定義します。 物理ロボットに対するマシン座標系 (MCS) の位置と方向 MCS、ひいては工具座標系 (TCS) に対する工具中心点 (TCS) の位置と方向 ロボットのゼロ位置、および個々の軸の回転または移動方向 ワールド座標系 (WCS) とプロダクト座標系 (PCS_1、PCS_2) は最初はシフトされず、マシン座標系と同じです。 " }, 
{ "title" : "複数のロボットとワークピース ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056581220108", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 座標系 \/ 複数のロボットとワークピース ", 
"snippet" : "座標系の位置と方向は、ロボットごとに定義されます。複数のロボットが連携して作業する場合、ワールド座標系 (WCS) を共通の基本座標系として定義すると便利です。この座標系に基づいて、個々のロボットのマシン座標系 (MCS) と製品座標系 (PCS_1、PCS_2)...", 
"body" : "座標系の位置と方向は、ロボットごとに定義されます。複数のロボットが連携して作業する場合、ワールド座標系 (WCS) を共通の基本座標系として定義すると便利です。この座標系に基づいて、個々のロボットのマシン座標系 (MCS) と製品座標系 (PCS_1、PCS_2) " }, 
{ "title" : "例 ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056581719182", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 座標系 \/ 例 ", 
"snippet" : "回転関節が 2 つあるロボットの使用例 ( a0 そして a1 )...", 
"body" : "回転関節が 2 つあるロボットの使用例 ( a0 そして a1 ) " }, 
{ "title" : "キネマティクス ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056582142746", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 座標系 \/ 例 \/ キネマティクス ", 
"snippet" : "キネマティクスはロボットのゼロ位置を定義します (下図参照)。マシン座標系の原点は軸の回転軸上にあります a0 。X 軸は、1 番目の軸の位置が 1 番目のリンクの方向を指します a0 は 0 。Y 軸は、1 番目の軸の位置が 1 番目のリンクの方向を指すようになります a0 は +90° 。反時計回りの回転は正の回転方向に対応します。ツールセンターポイント (TCP) はロボットの 2 番目のリンク (下図) の端にあり、TCS の原点を形成します。TCS は X 軸が 2 番目のリンクに沿って走るように位置合わせされています...", 
"body" : "キネマティクスはロボットのゼロ位置を定義します (下図参照)。マシン座標系の原点は軸の回転軸上にあります a0 。X 軸は、1 番目の軸の位置が 1 番目のリンクの方向を指します a0 は 0 。Y 軸は、1 番目の軸の位置が 1 番目のリンクの方向を指すようになります a0 は +90° 。反時計回りの回転は正の回転方向に対応します。ツールセンターポイント (TCP) はロボットの 2 番目のリンク (下図) の端にあり、TCS の原点を形成します。TCS は X 軸が 2 番目のリンクに沿って走るように位置合わせされています " }, 
{ "title" : "座標軸システム (ACS) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056582875889", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 座標系 \/ 例 \/ 座標軸システム (ACS) ", 
"snippet" : "キネマティクスは、ロボットのゼロ位置と個々の軸の回転方向を指定しています。ロボットは 2 つの軸で構成されているからです。 a0 そして a1 、軸の位置を指定できます a0 そして a1 ACSで。 最初の画像では、位置を指定します（ a0:= 0, a1:= 0 )。これはロボットのゼロ位置に相当します。 2番目の画像では、位置を指定します（ a0:= 90, a1:= 0 )。1 番目の軸であるゼロ位置から開始します a0 回転している 90° 正の回転方向に。2 番目の軸 a1 ゼロ位置のままです。 3番目の画像では、位置を指定します（ a0:= 90, a1:= -90 )。1 番目...", 
"body" : "キネマティクスは、ロボットのゼロ位置と個々の軸の回転方向を指定しています。ロボットは 2 つの軸で構成されているからです。 a0 そして a1 、軸の位置を指定できます a0 そして a1 ACSで。 最初の画像では、位置を指定します（ a0:= 0, a1:= 0 )。これはロボットのゼロ位置に相当します。 2番目の画像では、位置を指定します（ a0:= 90, a1:= 0 )。1 番目の軸であるゼロ位置から開始します a0 回転している 90° 正の回転方向に。2 番目の軸 a1 ゼロ位置のままです。 3番目の画像では、位置を指定します（ a0:= 90, a1:= -90 )。1 番目の軸であるゼロ位置から開始します a0 回転している 90° 正の回転方向に (2 番目の画像のように)。さらに、2 番目の軸は a1 回転している 90° 負の回転方向に。 " }, 
{ "title" : "ツール座標系 (TCS) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056583569251", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 座標系 \/ 例 \/ ツール座標系 (TCS) ", 
"snippet" : "キネマティクスは TCP と TCS の位置と方向を定義します。ロボットをどのように動かすかによって、TCS の位置と向きも変わります。...", 
"body" : "キネマティクスは TCP と TCS の位置と方向を定義します。ロボットをどのように動かすかによって、TCS の位置と向きも変わります。 " }, 
{ "title" : "ワールド座標系 (WCS)、マシン座標系 (MCS)、およびプロダクト座標系 (PCS_1、PCS_2) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056584038831", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 座標系 \/ 例 \/ ワールド座標系 (WCS)、マシン座標系 (MCS)、およびプロダクト座標系 (PCS_1、PCS_2) ", 
"snippet" : "生産ホールでは、コンベヤーベルトの左右に2台のロボットが立っています。ロボットはコンベアベルト上で製品を処理する必要があります。共通のワールド座標系を定義し、それを生産ホールの左上隅に配置します。この座標系から始めて、マシン座標系とプロダクトまでの距離と回転を決定し、それに応じて座標系をシフトします この例では、すべての座標系が同じ方法で整列されているため、座標系をシフトするだけで済みます。左側のロボットのマシン座標系は Y 方向に、右側のロボットのマシン座標系は X 方向に、プロダクト座標系は X 方向と Y 方向の両方にシフトします...", 
"body" : "生産ホールでは、コンベヤーベルトの左右に2台のロボットが立っています。ロボットはコンベアベルト上で製品を処理する必要があります。共通のワールド座標系を定義し、それを生産ホールの左上隅に配置します。この座標系から始めて、マシン座標系とプロダクトまでの距離と回転を決定し、それに応じて座標系をシフトします この例では、すべての座標系が同じ方法で整列されているため、座標系をシフトするだけで済みます。左側のロボットのマシン座標系は Y 方向に、右側のロボットのマシン座標系は X 方向に、プロダクト座標系は X 方向と Y 方向の両方にシフトします " }, 
{ "title" : "運動制御 ", 
"url" : "_sm_f_motion_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概要 ", 
"url" : "_sm_overview_robotics_motion_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 概要 ", 
"snippet" : "この章では、ロボット工学における基本的な動きの種類について説明します。 ジョギング SMC_グループジョグ2 PTP移動（ポイントツーポイント） MC_MoveDirect絶対 MC_MoveDirectRelative CP 移動 (連続パス) MC_MoveLinearAbsolute MC_線形相対移動 MC_円形絶対移動 MC_円形相対移動 待って SMC_グループ待機 停止（参照 MC_GroupHalt または MC_GroupStop によるパス上での停止 そして 運動の中断と継続） MC_グループ停止 MC_グループストップ MC_グループ割り込み さらに、動きに関連するすべて...", 
"body" : "この章では、ロボット工学における基本的な動きの種類について説明します。 ジョギング SMC_グループジョグ2 PTP移動（ポイントツーポイント） MC_MoveDirect絶対 MC_MoveDirectRelative CP 移動 (連続パス) MC_MoveLinearAbsolute MC_線形相対移動 MC_円形絶対移動 MC_円形相対移動 待って SMC_グループ待機 停止（参照 MC_GroupHalt または MC_GroupStop によるパス上での停止 そして 運動の中断と継続） MC_グループ停止 MC_グループストップ MC_グループ割り込み さらに、動きに関連するすべての重要なトピックについても説明されています。 動きのバッファリングとブレンド移動座標系との同期外部軸の同期、トルクフィードフォワード制御その他の軸動きが遅い、またはぎくしゃくしている場合の診断" }, 
{ "title" : "軸グループを制御するプログラムの作成方法 ", 
"url" : "_sm_creating_an_axis_group_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 軸グループを制御するプログラムの作成方法 ", 
"snippet" : "次の手順では、軸グループを制御するためのプログラムを作成する方法について説明します。 要件 ：プロジェクトは、で指定されているように、軸グループで作成されています 軸グループを作成する方法 章。 軸グループを制御するためのプログラムは、 PLC_PRG 実装言語としてCFCを使用したPOU。 を開きます PLC_PRG エディターのプログラム。 をドラッグします 箱 エディターへの要素。 機能ブロックをマッピングする SMC_GroupPower 箱に。 次の図に従って機能ブロックを構成します。 説明： ファンクションブロックは軸グループのドライブを起動します。 出力 Status コントロー...", 
"body" : "次の手順では、軸グループを制御するためのプログラムを作成する方法について説明します。 要件 ：プロジェクトは、で指定されているように、軸グループで作成されています 軸グループを作成する方法 章。 軸グループを制御するためのプログラムは、 PLC_PRG 実装言語としてCFCを使用したPOU。 を開きます PLC_PRG エディターのプログラム。 をドラッグします 箱 エディターへの要素。 機能ブロックをマッピングする SMC_GroupPower 箱に。 次の図に従って機能ブロックを構成します。 説明： ファンクションブロックは軸グループのドライブを起動します。 出力 Status コントローラの有効化が成功したことを示します。 タイプの機能ブロックを作成します MC_GroupEnable 。 この機能ブロックは、リンクされた軸の制御を 軸グループ 軸グループ。 を接続します。 Status の出力 SMC_GroupPower ファンクションブロックから Execute の入力 MC_GroupEnable ファンクションブロック。 説明： すべての軸コントローラに電源が入っている場合（ Status = TRUE ）の場合、軸の制御は軸グループに転送されます。 の Done 出力はコマンドの成功を報告します。 を挿入します MC_MoveDirectAbsolute ドライブを実行するための機能ブロック。 を接続します。 Done の出力 MC_GroupEnable ファンクションブロックから Execute の入力 MC_MoveDirectAbsolute ファンクションブロック。 次のようにプログラムを拡張します。 説明： の MC_MoveDirectAbsolute ファンクションブロックはPTP動作を命令し、 軸グループ 軸グループ。 この例では、キネマティクスは位置 (X = 10、Y= 20、Z = 30) に移動します。この値は、 Position 経由で入力 SMC_POS_REF 構造。 位置は機械座標系 (MCS) で指定されます。座標系は次の方法で選択されます。 CoordSystem 入力。 プログラムの開始 プログラムが完全に作成され、エラーなくコンパイルできる場合は、それをコントローラに転送できます。 開始する CODESYS Control Win ランタイムシステム（ CODESYSControlService.exe プログラム \"...\\GatewayPLC\" ディレクトリ）。 入れて 通信設定 コントローラーへの接続パス。 クリック オンライン → ログイン 。 プロジェクトをコントローラーにダウンロードします。 クリック デバッグ→開始 。 クリック デバッグ → 始める 。 軸の位置が変わります。 クリック デバッグ → 始める 。 軸の位置が変わります。 " }, 
{ "title" : "軸グループのジョギング ", 
"url" : "_sm_cartesian_jogging.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 軸グループのジョギング ", 
"snippet" : "あなたは使用することができます SMC_GroupJog2 空間内の軸グループを移動するための機能ブロック。 の SMC_GroupJog2 関数ブロックには、各座標に対して 2 つのブール入力があります。1 つの入力はこの座標に沿って前方に移動するためのもので、もう 1 つの入力は後方に移動するためのものです。 異なる座標のブール入力 SMC_GroupJog2 さまざまな方法で解釈できます。たとえば、設定されている座標系に応じて、直交座標、機械座標、軸座標、ツール座標などです。特別な入力 ABC_as_ACS: BOOL 、X\/Y\/Zとツールキネマティクスの軸の両方を、直交座標と軸座標で同...", 
"body" : "あなたは使用することができます SMC_GroupJog2 空間内の軸グループを移動するための機能ブロック。 の SMC_GroupJog2 関数ブロックには、各座標に対して 2 つのブール入力があります。1 つの入力はこの座標に沿って前方に移動するためのもので、もう 1 つの入力は後方に移動するためのものです。 異なる座標のブール入力 SMC_GroupJog2 さまざまな方法で解釈できます。たとえば、設定されている座標系に応じて、直交座標、機械座標、軸座標、ツール座標などです。特別な入力 ABC_as_ACS: BOOL 、X\/Y\/Zとツールキネマティクスの軸の両方を、直交座標と軸座標で同時にジョグすることができます。「混合」ジョグは、キネマティクスが結合され、位置キネマティクスがインターフェースを実装している場合にのみサポートされます。 ISMPositionKinematics_Offset （そうでない場合、関数ブロックはエラーを生成します。） ジョギングモードでは、Aは設定された座標系（MCS、WCS、PCS、またはTCS）のX軸を中心にTCPを回転させます。 BとCは、同じ座標系でY軸とZ軸を中心にTCPを回転させます。ただし、これは次の場合にのみ適用されます ABC_as_ACS = FALSE 。 デカルトジョギングは、 SMC_GroupJog2 機能ブロックは立ち上がりエッジを受け取り、 Busy 出力。デカルトジョギングは、アクティブな協調運動または運動学の軸の運動の中断を引き起こします。デカルトジョギングは、ジョギングが動き（協調または運動学の軸上）によって中断されたとき、または位置が作業スペースの外にあるときに終了します。ジョギングするとき、軸の制限は常にキネマティクスの軸に維持されます。 詳細については、次を参照してください。 ロボットのジョギング" }, 
{ "title" : "パス不変のPTPの動き ", 
"url" : "_sm_robotics_path_invariant_ptp_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ パス不変のPTPの動き ", 
"snippet" : "PTPの動きの場合、空間内のパスは運動学に依存し、開始点と目的地のみが固定されます。動作は完全に同期しているため、すべての軸の加速、一定の動作、および減速フェーズが同時に開始および終了します。 PTPの動きは常にパス不変であるため、次の特性が適用されます。 パスはオーバーライドに依存しません。 パスは、軸のすべてのダイナミクス制限（速度、加速、減速、およびジャークの制限）から独立しています。唯一の例外は、のカットオフポイントを決定することです。 TMStartVelocity モード。 で TMCornerDistance モードでは、パスはブレンドタイプに依存しません（ BlendingHi...", 
"body" : "PTPの動きの場合、空間内のパスは運動学に依存し、開始点と目的地のみが固定されます。動作は完全に同期しているため、すべての軸の加速、一定の動作、および減速フェーズが同時に開始および終了します。 PTPの動きは常にパス不変であるため、次の特性が適用されます。 パスはオーバーライドに依存しません。 パスは、軸のすべてのダイナミクス制限（速度、加速、減速、およびジャークの制限）から独立しています。唯一の例外は、のカットオフポイントを決定することです。 TMStartVelocity モード。 で TMCornerDistance モードでは、パスはブレンドタイプに依存しません（ BlendingHigh \/ Low \/ Previous \/ Next ）。 パスは停止または停止時に出発しません（ MC_GroupHalt \/ MC_GroupStop ）。 パスは、割り込みまたは続行時に出発しません（ MC_GroupInterrupt \/ MC_GroupContinue ）。 " }, 
{ "title" : "CP ムーブメント ", 
"url" : "_sm_robotics_cp_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ CP ムーブメント ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概要 ", 
"url" : "_sm_overview_robotics_motion_control_cp.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ CP ムーブメント \/ 概要 ", 
"snippet" : "CP動作（連続パス）は幾何学的経路によって与えられる。ロボットの場合、これらは直線セグメント（ MC_MoveLinearAbsolute そして MC_MoveLinearRelative ) と円セグメント ( MC_MoveCircularAbsolute そして MC_MoveCircularRelative ）。 CP 動作には、最大パス速度、最大パス加速度、および最大パスジャークを指定できます。 2 つの CP 動作間でブレンディングが行われ、両方の動作が共通の平面にある場合、この平面はブレンディング中に残されません。たとえば、2 つの連続する直線セグメントは常に 1 つの平面にあ...", 
"body" : "CP動作（連続パス）は幾何学的経路によって与えられる。ロボットの場合、これらは直線セグメント（ MC_MoveLinearAbsolute そして MC_MoveLinearRelative ) と円セグメント ( MC_MoveCircularAbsolute そして MC_MoveCircularRelative ）。 CP 動作には、最大パス速度、最大パス加速度、および最大パスジャークを指定できます。 2 つの CP 動作間でブレンディングが行われ、両方の動作が共通の平面にある場合、この平面はブレンディング中に残されません。たとえば、2 つの連続する直線セグメントは常に 1 つの平面にあります。 パスの形状は、TCPの方向が開始方向から目標方向にどのように変換されるかをまだ決定していません。これは、 CP運動の方向補間 セクション。 CPの動きは常に同じ場所で始まり、終わります 構成 ロボットのCP動作では、ロボットが単一の位置を通過するため、構成を変更することはできません。単一の位置を通過すると、軸速度が無制限になる可能性があります。 パス不変のPTPの動き 構成を切り替えます。 " }, 
{ "title" : "CP運動の方向補間 ", 
"url" : "_sm_robotics_orientation_interpolation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ CP ムーブメント \/ CP運動の方向補間 ", 
"snippet" : "などのCPムーブメントの場合 MC_MoveLinearAbsolute 、 MC_MoveLinearRelative 、 MC_MoveCircularAbsolute 、 また MC_MoveCircularRelative 、ツールの任意のターゲット方向は、ムーブメントのターゲット位置によって指定できます。その結果、ツールの先端がパス上を移動するパスの移動中に、ツールの方向がターゲットの方向に変換されます。方向補間の場合、軸座標（ACS）またはマシン座標（MCS）のいずれかで、ターゲットの方向が指定された座標系に違いはありません。 次の画像は、同時方向補間を使用した線形補間を示していま...", 
"body" : "などのCPムーブメントの場合 MC_MoveLinearAbsolute 、 MC_MoveLinearRelative 、 MC_MoveCircularAbsolute 、 また MC_MoveCircularRelative 、ツールの任意のターゲット方向は、ムーブメントのターゲット位置によって指定できます。その結果、ツールの先端がパス上を移動するパスの移動中に、ツールの方向がターゲットの方向に変換されます。方向補間の場合、軸座標（ACS）またはマシン座標（MCS）のいずれかで、ターゲットの方向が指定された座標系に違いはありません。 次の画像は、同時方向補間を使用した線形補間を示しています。赤い矢印は、始点と終点でのツールの方向を示しています。赤い破線は、補間中にツールがいくつかの場所にどのように配置されるかを示します。 パス移動に関する上記の機能ブロックには、 OrientationMode 入力。この入力は、開始方向がターゲット方向に渡される方法を定義します。 大圏補間（ SMC_Orientation_Mode.GreatCircle ） これはデフォルト設定です。この設定では、開始方向も最短距離でターゲット方向に渡されます。最短距離とは、回転の進行角度が最小になるように、ツールがターゲット方向に回転することを意味します。 軸方向補間（ SMC_Orientation_Mode.Axis ） 例1：大円補間 -360°から360°の値の範囲のC軸を持つガントリーを考えてみましょう。開始方向はC = 179°で、目標方向はC = -175°です。大円補間は、ZYZオイラー角（A、B、C）のC軸を、180°を過ぎた正の方向の179°から185°までのパス上の移動距離に比例して移動します。これは-175°に対応します。この場合、それは6°の合計角度を移動します。 例2：軸方向の補間 -180°から180°の値の範囲のC軸を持つガントリーをもう一度考えてみましょう。開始方向はC = 179°で、目標方向はC = -175°です。軸補間により、ガントリーのC軸は、パス上の移動距離に比例して、179°から負の方向に0°を超えて-175°まで移動し、合計角度は354°になります。 （この例で大円補間を使用した場合、C軸の作業スペースを超えていたため、エラーが発生していました。） これらの2つのタイプの補間は、いくつかの重要な特性が異なります。 大円補間では、工具の向きの変化を予測できます。軸補間では、方向軸が位置によって方向に異なる影響を与える可能性があるため、方向の変化を予測することは困難です。軸方向補間は、この特性をPTPの動きと共有します。 （ただし、これは、軸方向補間の空間内のパスを予測することが難しいことを意味するものではありません。パスは両方のタイプの方向補間で同じであり、TCPは常に定義された輪郭を正確に移動します。） 大円補間では、標定運動学の特異点を移動することはできません。これは、軸補間で簡単に可能です。 大円補間では、2 番目の例で述べたように、方向軸の軸制限に違反する可能性があります。したがって、コマンドを発行するときには、最短の回転で目標方向に移動するときに軸制限に違反していないことを確認する必要があります。 軸補間を使用すると、360° を超えて回転できます。方向軸の作業領域が 360° を超える場合、たとえば、位置 180° ではなく位置 540° に移動できます。これは、ツールの同じ方向に対応します。大円補間では、これは不可能です。ターゲット方向への最短の回転は、常に合計角度が最大 180° に相当します。 軸方向の補間には、位置とツールのキネマティクスで構成される結合キネマティクスが必要です。位置部分はインターフェースを実装する必要があります ISMPositionKinematics_Offset2 。 キネマティクスに回転軸がなく、インターフェースを実装している場合 ISMPositionKinematics 、次に選択した方向モード（ SMC_Orientation_Mode ）は無視されます。 軸方向補間の特異点 軸方向補間を使用すると、方向運動学の特異点を介してパスの移動を行うことができ、プログラミングが大幅に容易になります。この目的のために、位置運動学の特異点が変化します。 大きな円補間の場合、フランジ点（A3）が最初のアーム部分によって定義された線上にある場合（2番目の関節角度が0°の場合）、Scara3_Zは特異点を持ちます。 軸方向補間の場合、位置キネマティクスの特異点が変化するため、TCPはフランジポイント（A3）とは異なる役割を果たします。この特異性は、TCP（フランジポイントではない）が最初のアーム部分によって定義された線上にある場合に発生します。軸方向補間を使用して移動を指令する場合、この変更された特異点が移動の開始位置と目標位置の間にあるかどうかがチェックされます。その場合、移動は受け入れられず、エラーが発行されます。 6軸関節式アームロボットの場合、状況はScara3_Zに匹敵しますが、2つの特異点が考えられます。 1つ目は、TCPがA2とA3を通る回線上にある場合に発生します。 2つ目は、TCPがA1を通る回線上にある場合に発生します。司令部はまた、特異点が通過していないことをここでチェックします。 軸方向補間を使用して移動すると、Scara3（または6軸関節式アームロボット）の構成が変更される場合があります。ただし、移動の終了時には、ロボットが開始点で持っていたのと同じ構成が常に適用されます。 " }, 
{ "title" : "その他の軸 ", 
"url" : "_sm_additional_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ その他の軸 ", 
"snippet" : "追加軸は、軸グループの一部ではあるがキネマティクスの一部ではない軸です。キネマティクスの調整された動きと同期して動かすことができます。追加した軸とキネマティクスの軸が動き始め、同時に目標位置に到達します。追加の軸の動きはバッファされ、調整された動きとブレンドされます。同じことが、キネマティクスの動きを一切加えずに、軸の動きを純粋に追加する場合にも当てはまります...", 
"body" : "追加軸は、軸グループの一部ではあるがキネマティクスの一部ではない軸です。キネマティクスの調整された動きと同期して動かすことができます。追加した軸とキネマティクスの軸が動き始め、同時に目標位置に到達します。追加の軸の動きはバッファされ、調整された動きとブレンドされます。同じことが、キネマティクスの動きを一切加えずに、軸の動きを純粋に追加する場合にも当てはまります " }, 
{ "title" : "単軸移動との違い ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062102818545", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ その他の軸 \/ 単軸移動との違い ", 
"snippet" : "次のようなファンクションブロックで操作される単軸移動との主な違い MC_MoveAbsolute または MC_MoveRelative はムーブメントの同期です。同期が重要でない場合は、1 軸のファンクションブロックを使用して座標軸を操作すると軸の移動速度が速くなるため、意味がある場合があります。もう 1 つの違いは、追加の軸は軸グループと一緒に管理されることです。これらは以下で有効になります SMC_GroupPower また、エラーは次の方法でリセットできます。 MC_GroupReset 。なお、追加軸の単軸誤差は軸グループ誤差の原因となります...", 
"body" : "次のようなファンクションブロックで操作される単軸移動との主な違い MC_MoveAbsolute または MC_MoveRelative はムーブメントの同期です。同期が重要でない場合は、1 軸のファンクションブロックを使用して座標軸を操作すると軸の移動速度が速くなるため、意味がある場合があります。もう 1 つの違いは、追加の軸は軸グループと一緒に管理されることです。これらは以下で有効になります SMC_GroupPower また、エラーは次の方法でリセットできます。 MC_GroupReset 。なお、追加軸の単軸誤差は軸グループ誤差の原因となります " }, 
{ "title" : "さらなる軸の動きを指揮 ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062103093337", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ その他の軸 \/ さらなる軸の動きを指揮 ", 
"snippet" : "追加の軸の動きを指示するときは、軸グループの主な動きが絶対的か相対的かにかかわらず、いつでも絶対移動と相対運動のどちらかを選択できます。たとえば、軸の相対的な移動を同期して指示できます MC_MoveLinearAbsolute コマンド。 その他の軸の動きは、以下のコマンドで制御されます。 AdditionalAxes 軸グループのモーションファンクションブロックの入力。たとえば、PTP の絶対移動と軸の相対的な移動は、次のように命令できます 追加の軸だけを移動させる場合は、長さが 0 の調整された移動になります (たとえば、 MC_MoveDirectRelative 距離あり 0 ) は...", 
"body" : "追加の軸の動きを指示するときは、軸グループの主な動きが絶対的か相対的かにかかわらず、いつでも絶対移動と相対運動のどちらかを選択できます。たとえば、軸の相対的な移動を同期して指示できます MC_MoveLinearAbsolute コマンド。 その他の軸の動きは、以下のコマンドで制御されます。 AdditionalAxes 軸グループのモーションファンクションブロックの入力。たとえば、PTP の絶対移動と軸の相対的な移動は、次のように命令できます 追加の軸だけを移動させる場合は、長さが 0 の調整された移動になります (たとえば、 MC_MoveDirectRelative 距離あり 0 ) は追加の軸移動と同時に命令できます。 " }, 
{ "title" : "[メモ] ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062106608843", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ その他の軸 \/ [メモ] ", 
"snippet" : "モジュロ軸は追加の軸としてもサポートされています。これらは常に以下のように操作されます。 shortest 軸の動きを絶対的に追加するモード。 詳細については、以下を参照してください。 MC_DirectionMC_Direction 追加する軸の最大数は、ライブラリパラメーターによって制限されます。 MAX_NUM_ADDITIONAL_AXES から SM3_CPKernelDefaults ライブラリ。このパラメーターはライブラリマネージャーで変更できます。 追加軸の使用方法の例については、以下を参照してください。 ロボット工学における追加軸の使用...", 
"body" : "モジュロ軸は追加の軸としてもサポートされています。これらは常に以下のように操作されます。 shortest 軸の動きを絶対的に追加するモード。 詳細については、以下を参照してください。 MC_DirectionMC_Direction 追加する軸の最大数は、ライブラリパラメーターによって制限されます。 MAX_NUM_ADDITIONAL_AXES から SM3_CPKernelDefaults ライブラリ。このパラメーターはライブラリマネージャーで変更できます。 追加軸の使用方法の例については、以下を参照してください。 ロボット工学における追加軸の使用" }, 
{ "title" : "パス精度の許容差 ", 
"url" : "_sm_path_accuracy_tolerances.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ パス精度の許容差 ", 
"snippet" : "軸グループにはパス精度の許容値を設定できます。動的座標系が予期しない動きをした場合、これらの許容値により軸グループはエラーで停止するのではなく、この座標系に追いつくことができます。 SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED 、 SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED 、 または SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED 。...", 
"body" : "軸グループにはパス精度の許容値を設定できます。動的座標系が予期しない動きをした場合、これらの許容値により軸グループはエラーで停止するのではなく、この座標系に追いつくことができます。 SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED 、 SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED 、 または SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED 。 " }, 
{ "title" : "概要 ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4560250800668834033944790208", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ パス精度の許容差 \/ 概要 ", 
"snippet" : "パスの精度に許容誤差が必要なのはなぜですか?理想的には、軸グループはパスに正確に従う必要があります。ただし、動的座標系（ベルトや回転テーブル上のオブジェクト、別の軸グループで指定された座標系など）を使用している場合、パスをたどることができない場合があります。 例: ロボットは部品をコンベア ベルト上に配置する必要があります。ベルトは一定速度で移動しますが、ロボットが部品を配置する位置に到達する直前にベルトが予期せぬ加速をします。この状況では、部品を配置するための軌道はすでに計算されていますが、ベルトが一定の速度で動き続けることが前提となっています。したがって、残りの動作により、ロボットのいずれ...", 
"body" : "パスの精度に許容誤差が必要なのはなぜですか?理想的には、軸グループはパスに正確に従う必要があります。ただし、動的座標系（ベルトや回転テーブル上のオブジェクト、別の軸グループで指定された座標系など）を使用している場合、パスをたどることができない場合があります。 例: ロボットは部品をコンベア ベルト上に配置する必要があります。ベルトは一定速度で移動しますが、ロボットが部品を配置する位置に到達する直前にベルトが予期せぬ加速をします。この状況では、部品を配置するための軌道はすでに計算されていますが、ベルトが一定の速度で動き続けることが前提となっています。したがって、残りの動作により、ロボットのいずれかの軸の最大加速度の違反が発生する可能性があります。 このような状況では、公差が重要になります。これらにより、軸グループが指定された制限内でパスから逸脱し、再び座標系に追いつくことができます。 パスの精度はフィルターによって制御されます。フィルターは計画された軌道を受け取ります ( q_ref ) と最後に計算されたターゲット位置 ( q_set ) を入力として使用します。フィルターの出力はターゲット位置 ( q_set )、ドライブに転送されます。もし q_ref 軸の制限の 1 つに違反すると、フィルターはパスを離れ、軸の制限に違反することなく、計画された軌道にできるだけ近づきます。間のラグがある限り、 q_set そして q_ref 許容範囲内であれば、エラーは出力されません。 パス精度の許容値は、次のいくつかの値で構成されます。 TCP の最大ラグ (技術単位) (デフォルト値: 1 u ） TCP の最大方向誤差 (角度単位) (デフォルト値: 1 deg ） 軸の技術単位での各軸の最大許容ラグ (デフォルト値: 無限大) " }, 
{ "title" : "管理機能ブロックへの影響 ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4579672191731234033944887183", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ パス精度の許容差 \/ 管理機能ブロックへの影響 ", 
"snippet" : "によって返される位置、速度、加速度、ジャークの値。 SMC_GroupReadSetPosition 、 SMC_GroupReadSetVelocity 、 SMC_GroupReadSetAcceleration 、 そして SMC_GroupReadSetJerk 機能ブロックは計画された軌道に基づいて計算されます ( q_ref ）。したがって、フィルターの影響は含まれていません。 一方、位置、速度、ジャークの実際の値は、 MC_GroupReadActualPosition 、 MC_GroupReadActualVelocity 、 そして MC_GroupReadActualAc...", 
"body" : "によって返される位置、速度、加速度、ジャークの値。 SMC_GroupReadSetPosition 、 SMC_GroupReadSetVelocity 、 SMC_GroupReadSetAcceleration 、 そして SMC_GroupReadSetJerk 機能ブロックは計画された軌道に基づいて計算されます ( q_ref ）。したがって、フィルターの影響は含まれていません。 一方、位置、速度、ジャークの実際の値は、 MC_GroupReadActualPosition 、 MC_GroupReadActualVelocity 、 そして MC_GroupReadActualAcceleration 機能ブロック – 軸グループのドライブの実際の位置に基づいて計算されます。したがって、これらにはフィルターの影響も含まれます。 によって返されるパス ダイナミクス SMC_GroupReadPathDynamics と Source = MC_SOURCE.SET 計画された軌道に基づいています ( q_ref ) なので、フィルターの影響を受けません。 (その他の値については、 Source 入力にはフィルターの寄与が含まれます) トリガーは常に計画された軌道を参照します ( q_ref ）。によって返される時刻 MC_GroupReadTrigger 計画された軌道がトリガーに到達する時刻です。フィルターが有効な場合 ( q_ref<>q_set )、軸グループは通常、トリガの位置や時間に正確に到達しません。 注: 移動レポート Done 計画された軌道 ( q_ref ) 動作の終わりに達し、フィルターはアクティブではありません (またはもはやアクティブではありません) (つまり、遅延の可能性が排除されています)。次に、設定位置 ( q_set ) は移動の目標位置に対応します。 " }, 
{ "title" : "許容値の設定とパス偏差の監視 ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4575205545955234033945121691", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ パス精度の許容差 \/ 許容値の設定とパス偏差の監視 ", 
"snippet" : "公差は次を使用して設定できます。 SMC_GroupSetPathTolerance ファンクションブロック。 フィルターのステータスと計画された軌道間の現在の遅れ q_ref と設定値 q_set 軸グループの状態をモニタできます。 InSync 、 PositionLag 、 そして OrientationLag の出力 MC_GroupReadStatus 。 InSync = TRUE という意味です q_ref = q_set そしてフィルターがアクティブではないこと。 InSync = FALSE という意味です q_ref<>q_set フィルターがアクティブであることを確認しま...", 
"body" : "公差は次を使用して設定できます。 SMC_GroupSetPathTolerance ファンクションブロック。 フィルターのステータスと計画された軌道間の現在の遅れ q_ref と設定値 q_set 軸グループの状態をモニタできます。 InSync 、 PositionLag 、 そして OrientationLag の出力 MC_GroupReadStatus 。 InSync = TRUE という意味です q_ref = q_set そしてフィルターがアクティブではないこと。 InSync = FALSE という意味です q_ref<>q_set フィルターがアクティブであることを確認します。 " }, 
{ "title" : "動きのバッファリングとブレンド ", 
"url" : "_sm_robotics_blending.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 動きのバッファリングとブレンド ", 
"snippet" : "移動コマンドは以下でバッファリングできます CODESYS SoftMotion 。命令された動きごとに、動きをバッファする方法と、前の動きから新しい動きまでどのようにブレンドするかを指定できます。指令された経路は、その経路が止まることなく移動できるように、角を丸めることで調整されます 動きをバッファリングするかどうか、またどのように行うかは、次の方法で設定できます。 BufferMode ムーブメントブロックの入力 (例: MC_MoveDirectAbsolute または MC_MoveCircularRelative )。詳細については、以下を参照してください MC_Buffer_Mod...", 
"body" : "移動コマンドは以下でバッファリングできます CODESYS SoftMotion 。命令された動きごとに、動きをバッファする方法と、前の動きから新しい動きまでどのようにブレンドするかを指定できます。指令された経路は、その経路が止まることなく移動できるように、角を丸めることで調整されます 動きをバッファリングするかどうか、またどのように行うかは、次の方法で設定できます。 BufferMode ムーブメントブロックの入力 (例: MC_MoveDirectAbsolute または MC_MoveCircularRelative )。詳細については、以下を参照してください MC_Buffer_Mode 。 ザ・ TransitionMode と TransitionParameter 入力によって角の丸み付け方法が決まります。詳細については、以下を参照してください MC_TRANSITION_MODE 。 ムーブメントの詳細については、以下を参照してください。 ムーブメント用ファンクションブロック ブレンディングモードでは、 TransitionMode 次の値と等しくならないようにしてください。 TMNone 。 2 つの楽章の融合は、早くても第 1 楽章の半ばで始まり、遅くても第 2 楽章の半ばで終わります。 最初の動作がすでに計画されすぎている場合は、設定されたパラメータでブレンドができなくなる可能性があります。その場合、ブレンド領域が縮小されるか、ブレンドができなくなります。ブレンドが確実に成功するためには、両方の動作を同じサイクルでコマンドする必要があります。 " }, 
{ "title" : "ブレンド時のパスダイナミクス ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-idm43523137701146", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 動きのバッファリングとブレンド \/ ブレンド時のパスダイナミクス ", 
"snippet" : "CPの動きの間（直線セグメントと円形セグメントの間）でブレンドを行う場合、ブレンド中に最大パス加速度と最大パスジャークを超える可能性があることに注意してください。ブレンド範囲が短いほど、この効果はより顕著になります。ただし、軸の制限 (最大軸加速度と最大軸ジャーク) は常に維持されます したがって、最大パス加速度が低く、最大軸加速度が高い場合、ブレンド時に高すぎる加速度が発生する可能性があります。これは、次の方法で相殺できます AccFactor 動きの最大軸加速度を下げるなどして、モーションブロックに入力します。...", 
"body" : "CPの動きの間（直線セグメントと円形セグメントの間）でブレンドを行う場合、ブレンド中に最大パス加速度と最大パスジャークを超える可能性があることに注意してください。ブレンド範囲が短いほど、この効果はより顕著になります。ただし、軸の制限 (最大軸加速度と最大軸ジャーク) は常に維持されます したがって、最大パス加速度が低く、最大軸加速度が高い場合、ブレンド時に高すぎる加速度が発生する可能性があります。これは、次の方法で相殺できます AccFactor 動きの最大軸加速度を下げるなどして、モーションブロックに入力します。 " }, 
{ "title" : "の特徴 TMStartVelocity ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-id235231378653745", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 動きのバッファリングとブレンド \/ の特徴 TMStartVelocity ", 
"snippet" : "ブレンドポイントの計算は理想的なベロシティカーブに基づいており、実際のベロシティカーブとは異なる場合があります。このとき、ブレンドポイントに向かう元の経路で減速ランプがシミュレートされ、ブレンドポイントから離れる加速ランプがシミュレートされます。プログラムされた経路速度の最小値と、軸の限界値から得られる推定最大経路速度の両方が目標速度として使用されます また、直線同士をブレンドする場合、直線間の角度が考慮されます。ブレンディングエレメントの最小曲率半径は、目的の経路速度と推定されるダイナミクス制限値によって決まります。点A' と B' は、この半径と直線間の角度から順番に得られます 係数を1に...", 
"body" : "ブレンドポイントの計算は理想的なベロシティカーブに基づいており、実際のベロシティカーブとは異なる場合があります。このとき、ブレンドポイントに向かう元の経路で減速ランプがシミュレートされ、ブレンドポイントから離れる加速ランプがシミュレートされます。プログラムされた経路速度の最小値と、軸の限界値から得られる推定最大経路速度の両方が目標速度として使用されます また、直線同士をブレンドする場合、直線間の角度が考慮されます。ブレンディングエレメントの最小曲率半径は、目的の経路速度と推定されるダイナミクス制限値によって決まります。点A' と B' は、この半径と直線間の角度から順番に得られます 係数を1に設定したにもかかわらず、ブレンドプロセス中に動きが遅くなる場合は、係数を増やすとよいでしょう。 " }, 
{ "title" : "例 ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-id235231380207819", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 動きのバッファリングとブレンド \/ 例 ", 
"snippet" : "小さなサンプルアプリケーションでは、ワークピースをピックアップすることになっています。ロボットはまずワークピースの上を移動し、次に下に移動してワークピースを拾う必要があります。ワークピースにできるだけ速く到達するには、2 つの動きの間を止めるのではなく、混ぜ合わせる必要があります。2 番目の楽章へのブレンドは、1 番目の楽章の終わりに達する 10 単位前に開始する必要があります 要件を満たすには、2つの動きを指揮する必要があります。最初の楽章 moveAbove ) ワークピースの上と 2 番目の動き ( moveDown ) ワークピースに向かって下向きに。2 番目の動きでは、動きをどのよう...", 
"body" : "小さなサンプルアプリケーションでは、ワークピースをピックアップすることになっています。ロボットはまずワークピースの上を移動し、次に下に移動してワークピースを拾う必要があります。ワークピースにできるだけ速く到達するには、2 つの動きの間を止めるのではなく、混ぜ合わせる必要があります。2 番目の楽章へのブレンドは、1 番目の楽章の終わりに達する 10 単位前に開始する必要があります 要件を満たすには、2つの動きを指揮する必要があります。最初の楽章 moveAbove ) ワークピースの上と 2 番目の動き ( moveDown ) ワークピースに向かって下向きに。2 番目の動きでは、動きをどのように緩衝してブレンドするかを定義する必要があります 次の画像に示すように、 BlendingHigh に選ばれたのは BufferMode 。これにより、最初の動きの後に動きをバッファリングしてからブレンドする必要があると定義されます。さらに、 TransitionMode 、 TMCornerDistance 最初の動きが2番目の動きにスムーズに溶け込むように、10単位の距離で定義されています。2 つの入力を設定するには TransitionMode と TransitionParameter 適切には、 SMC_CornerDistance ファンクションブロックが使用されています。 " }, 
{ "title" : "動きの間に待つ ", 
"url" : "_sm_robotics_wait.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 動きの間に待つ ", 
"snippet" : "SoftMotion Robotics 2 つの動作の間に特定の時間待機する機能を提供します。これは、たとえば、ロボットが次の動作を開始する前に、動作の目標位置でワークピースを掴む必要がある場合に必要になることがあります。 動きと同様に、待機時間は SMC_GroupWait 機能ブロック。この機能ブロックの詳細については、以下を参照してください。 SMC_グループ待機 。...", 
"body" : "SoftMotion Robotics 2 つの動作の間に特定の時間待機する機能を提供します。これは、たとえば、ロボットが次の動作を開始する前に、動作の目標位置でワークピースを掴む必要がある場合に必要になることがあります。 動きと同様に、待機時間は SMC_GroupWait 機能ブロック。この機能ブロックの詳細については、以下を参照してください。 SMC_グループ待機 。 " }, 
{ "title" : "MC_GroupHalt または MC_GroupStop によるパス上での停止 ", 
"url" : "_sm_robotics_halt_stop.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ MC_GroupHalt または MC_GroupStop によるパス上での停止 ", 
"snippet" : "の MC_GroupHalt そして MC_GroupStop 機能ブロックを使用すると、設定可能な減速とジャーク制限を考慮して、パス上で停止できます。停止は直ちに開始されます。 停止時の減速とジャークの制限は、アクティブな動作の制限とは異なっており、大きくすることも小さくすることもできます。これらは、パスを離れない限り維持されます。たとえば、パスの途中では、減速を低く抑えてスムーズに停止できます。ただし、パスの終了時には、減速は少なくとも終了点を超えて移動できないようにするのに十分な強さになります。 との差 MC_GroupHalt そして MC_GroupStop 主な違いは MC_Gro...", 
"body" : "の MC_GroupHalt そして MC_GroupStop 機能ブロックを使用すると、設定可能な減速とジャーク制限を考慮して、パス上で停止できます。停止は直ちに開始されます。 停止時の減速とジャークの制限は、アクティブな動作の制限とは異なっており、大きくすることも小さくすることもできます。これらは、パスを離れない限り維持されます。たとえば、パスの途中では、減速を低く抑えてスムーズに停止できます。ただし、パスの終了時には、減速は少なくとも終了点を超えて移動できないようにするのに十分な強さになります。 との差 MC_GroupHalt そして MC_GroupStop 主な違いは MC_GroupHalt そして MC_GroupStop それは MC_GroupStop 中止することはできず、その後の移動は Execute 入力がリセットされました。 MC_GroupStop 軸グループの移動を防ぎます。 との差別化 MC_GroupInterrupt 対照的に MC_GroupHalt そして MC_GroupStop 、 MC_GroupInterrupt 短い遅延で開始し、減速とジャークの制限は設定できません。代わりに、アクティブな動きの制限が使用されます。 MC_GroupInterrupt 中断された動きは、 MC_GroupContinue の助けを借りて SMC_GroupSaveContinueData 、これはまた可能です MC_GroupHalt そして MC_GroupStop 詳細については、以下を参照してください。 運動の中断と継続。 移動座標系における動きを伴う動作 動きについては 移動する座標系 （例えば、ロボットがベルトコンベアに対して移動する場合）、 MC_GroupHalt または MC_GroupStop 絶対停止になります。したがって、移動座標系に対して停止するわけではありません。軸グループは、機械座標系（MCS）で移動したはずの経路上に留まります。 MC_GroupHalt または MC_GroupStop 命令されていた。 " }, 
{ "title" : "移動計画 ", 
"url" : "_sm_robotics_factor_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 移動計画 ", 
"snippet" : "例えば、 MC_MoveLinearAbsolute ロボットの最終的な速度は次の要因によって決まります。 軸グループの各軸に設定された最大速度、加速度、およびジャーク。(軸設定で設定) 上限は、各軸の移動速度を定義します。以下で説明するその他の制限は、有効な制限を減らすことしかできません。これらの制限を超えて増やすことはできません。 移動機能ブロックへの入力として提供される最大速度、加速度、およびジャーク。これらの上限は、TCP がパスに沿って移動できる速度を定義します。これらは、個々の軸の制限に加えて適用されます。 現在のオーバーライド（ MC_GroupSetOverride ）および軸...", 
"body" : "例えば、 MC_MoveLinearAbsolute ロボットの最終的な速度は次の要因によって決まります。 軸グループの各軸に設定された最大速度、加速度、およびジャーク。(軸設定で設定) 上限は、各軸の移動速度を定義します。以下で説明するその他の制限は、有効な制限を減らすことしかできません。これらの制限を超えて増やすことはできません。 移動機能ブロックへの入力として提供される最大速度、加速度、およびジャーク。これらの上限は、TCP がパスに沿って移動できる速度を定義します。これらは、個々の軸の制限に加えて適用されます。 現在のオーバーライド（ MC_GroupSetOverride ）および軸グループの補助限界 これらすべての制限がどのように組み合わされて有効なパスと軸の制限が計算されるかについては、 SMC_グループセット補助軸制限 、 SMC_グループセット補助パス制限 、 そして SMC_グループセット軸制限係数 。 ロボットのプログラムされた経路 たとえば、動作間のブレンドによって曲率半径が非常に小さくなる場合、ロボットは軸の制限を超えないようにゆっくりと移動する必要があります。 これらの要素を組み合わせることで、パス上の有効な最大速度が決まります。ただし、達成可能な速度を制限するもう 1 つの要素が PLC のパフォーマンスです。パフォーマンスが動作の計画に十分でない場合、ロボットはより遅い速度で移動します。パフォーマンス上の理由により、計画アルゴリズムが加速しても安全であることを確認できない場合は、代わりにより遅い速度で移動します。詳細については、以下を参照してください。 パフォーマンス" }, 
{ "title" : "動きの中断と継続 ", 
"url" : "_sm_robotics_stop_continue_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 動きの中断と継続 ", 
"snippet" : "軸グループの移動中は、移動を停止できます。これは意図的な停止である可能性があります（ MC_GroupHalt 、 MC_GroupStop ）、またはパスの一時停止（ MC_GroupInterrupt ）、またはエラーによる停止。すべての場合において、 CODESYS SoftMotion 軸グループを計画パスに戻し、それを続行するための機能ブロックを提供します。 エラーによる動作停止 エラーにより動作が停止した場合、軸グループの個々の軸が個別に停止し、エラー状態に切り替わります。その過程で、TCPは計画されたパスを離れます。これで、エラーを確認し、軸グループをリセットして、エラーが検出さ...", 
"body" : "軸グループの移動中は、移動を停止できます。これは意図的な停止である可能性があります（ MC_GroupHalt 、 MC_GroupStop ）、またはパスの一時停止（ MC_GroupInterrupt ）、またはエラーによる停止。すべての場合において、 CODESYS SoftMotion 軸グループを計画パスに戻し、それを続行するための機能ブロックを提供します。 エラーによる動作停止 エラーにより動作が停止した場合、軸グループの個々の軸が個別に停止し、エラー状態に切り替わります。その過程で、TCPは計画されたパスを離れます。これで、エラーを確認し、軸グループをリセットして、エラーが検出された位置に移動できます。その後、以前に計画された移動を続行するように軸グループに指示できます。 あなたは SMC_GroupEnableResumeAfterError エラー後にプログラムされた動作を再開できるようにする機能ブロック。ファンクションブロックは、バスサイクルタスクで周期的に呼び出す必要があります。この機能ブロックのインスタンスは、軸グループごとに1つだけ呼び出すことができます。 軸グループがエラーを検出し、状態に切り替わった場合 Errorstop 、次に、すでに受け入れられている動きと必要なステータス情報をタイプの変数に保存します SMC_AXIS_GROUP_CONTINUE_DATA 。次に、この変数には「継続データ」が含まれ、の入力として渡されます。 SMC_GroupEnableResumeAfterError 。 これにより、後で使用して移動を再開できます。 MC_GroupContinue 。エラーがコマンドされた移動（たとえば、ワークスペース違反または無効な円弧半径）によって引き起こされた場合、この方法でエラーを解決することはできません。これらのエラーは、移動が続行された後に再び発生します。このメカニズムは、単軸エラーや、軸グループを強制的にエラー停止させるその他の外部イベントを対象としています。 MC_GroupContinue 移動を継続するときは、軸グループが特定の位置にある必要があります。エラー後に再開する場合、この位置はエラーが検出されたときの現在の位置です。あなたは使用することができます SMC_GroupGetContinuePosition この位置を取得するための機能ブロック。 軸グループエラーが移動の継続を許可しない場合（継続データの書き込み時の内部エラーなど）、 MC_GroupContinue と SMC_GroupGetContinuePosition 新しいエラーIDを返します SMC_AXIS_GROUP_CONTINUE_DATA_NOT_WRITTEN 。 もし MC_GroupStop エラーが発生するとアクティブになり、その後 MC_GroupStop 移動が続くと、も再アクティブ化されます。軸グループはすでに停止されており、 MC_GroupStop 移動が発生しないように、保留中のすべての移動を削除しました。 軸グループエラーが発生すると、アクティブな移動の機能ブロックインスタンスがエラーを発行します（出力 Active と Busy 切り替える FALSE 、および出力 Error に切り替えます TRUE ）。まだアクティブになっていない、バッファリングされたムーブメントまたはブレンドされたムーブメントのファンクションブロックインスタンスもエラーを発行します。再起動後、これらの機能ブロックインスタンスはすべて次のようにリセットされます。 Busy \/ Active そしてそれらの出力はにリセットされます Error \/ CommandAborted 。 " }, 
{ "title" : "一時停止して動作を停止する ", 
"url" : "_sm_robotics_stop_continue_movements.html#UUID-5b8e7899-940c-fb66-b17a-ee1b74aa00fd_id_d17b9abed7a5b50cc0a864636890315c_id_74b10b31cbbdb856c0a8646354735c5f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 動きの中断と継続 \/ 一時停止して動作を停止する ", 
"snippet" : "あなたは使用することができます MC_GroupInterrupt と MC_GroupInterruptAt 命令された動きの実行を中断する機能ブロック。にとって MC_GroupInterrupt 、即時停止が実行されます。にとって MC_GroupInterruptAt 、特定の位置で停止します。その後、動きを後で続けることができます MC_GroupContinue 。 機能ブロック MC_GroupInterruptAt 入力を提供します SMC_GroupInterruptPositionMvtRel 。これは、動きに対する割り込み位置を指定します。動きはそのによって参照されます ...", 
"body" : "あなたは使用することができます MC_GroupInterrupt と MC_GroupInterruptAt 命令された動きの実行を中断する機能ブロック。にとって MC_GroupInterrupt 、即時停止が実行されます。にとって MC_GroupInterruptAt 、特定の位置で停止します。その後、動きを後で続けることができます MC_GroupContinue 。 機能ブロック MC_GroupInterruptAt 入力を提供します SMC_GroupInterruptPositionMvtRel 。これは、動きに対する割り込み位置を指定します。動きはそのによって参照されます SMC_Movement_Id 。ムーブメント内の位置は、0から1までの値（実数）で定義されます。ここで、0はムーブメントの開始、1は終了です。ポイントBとポイントAの間の位置は、ブレンドがなかったかのように正確に解釈されます。 P間の位置 始める およびBまたはAとPの間 dest ブレンディングパスに投影されます。 MC_GroupInterruptAtのエラー処理 指定された移動IDが不明な場合、機能ブロックはエラーを返します。走行動作は中断されません。 軸グループの現在の動的状態で、指定された割り込み位置の前に停止状態に達することができない場合は、 SMC_GroupInterruptAt まったく同じように動作します MC_GroupInterrupt ：割り込みはすぐに実行され、軸グループはコマンドされた割り込み位置の後ろのどこかで停止します。 他のすべてのエラーは、MC_GroupInterruptの場合とまったく同じように処理されます MC_GroupInterruptAtの制限 特定の位置での割り込みは、割り込み位置で停止するプロセスがまだ開始されていない限り、別の動作で中止できます。 特定の位置で同時に指令できる割り込みは1つだけです。割り込みが命令された場合、別の割り込みを受け入れることができるように、割り込みを完了するか中止する必要があります。 実行するとき MC_GroupInterrupt また MC_GroupInterruptAt 、パス不変の停止が最初に実行されます。 MC_GroupHalt 。次に、軸グループの状態（「データの継続」）が、ユーザーによって転送された変数（タイプ SMC_AXIS_GROUP_CONTINUE_DATA ）。これで、軸グループは状態になります GroupStandby 正常に使用できます。典型的な例は、軸グループがジョグされていることです。 後で使用できます MC_GroupContinue 中断された実行を続行します。これを行うには、保存された「継続データ」を転送します。これがエラーなしで機能するためには、軸グループの位置が実行後の位置と一致している必要があります。 MC_GroupInterrupt 。 （見る SMC_GroupGetContinuePosition 。） 追跡動作が中断された場合（動的座標系に対して命令された動作を意味します）、 MC_GroupInterrupt 絶対に止まらない（ MC_GroupHalt ）、ただし動的座標系と比較して。たとえば、ワークピースが回転台で追跡されている場合、 MC_GroupInterrupt ワークに対して停止します。軸グループは引き続きワークピースを追跡します。継続データは次のように更新する必要があります SMC_GroupUpdateContinueData キネマティックに複数の周期を持つ回転軸がある場合。その後、動きを続けることができます MC_GroupContinue 。 タイプの変数 SMC_AXIS_GROUP_CONTINUE_DATA 永続的に保存したり、オンライン変更中に変更したりしないでください。 機能ブロックの使用 SMC_GroupWait 、プログラム可能な時間、2つの動きの間のパスを待つことができます。 " }, 
{ "title" : "MC_GroupHaltまたはMC_GroupStopを介した移動停止 ", 
"url" : "_sm_robotics_stop_continue_movements.html#UUID-5b8e7899-940c-fb66-b17a-ee1b74aa00fd_id_d17b9abed7a5b50cc0a864636890315c_id_28e8e9a71ed1fa93c0a8646375852228", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 動きの中断と継続 \/ MC_GroupHaltまたはMC_GroupStopを介した移動停止 ", 
"snippet" : "によって引き起こされた動きの停止後 MC_GroupHalt また MC_GroupStop 、軸グループの移動は、情報を失うことなく次のように再開できます。機能ブロックを呼び出します。 SMC_GroupSaveContinueData 電話する前に MC_GroupHalt また MC_GroupStop 。このPOUは、停止または停止コマンドが呼び出された時点での現在のステータス、現在の位置、およびすべてのコマンドされた動きを保存します。これにより、後で正確にこの位置から移動を続けることができます。注：これは、軸グループが停止位置に達した後に持っていた位置ではありません。 バージョン4....", 
"body" : "によって引き起こされた動きの停止後 MC_GroupHalt また MC_GroupStop 、軸グループの移動は、情報を失うことなく次のように再開できます。機能ブロックを呼び出します。 SMC_GroupSaveContinueData 電話する前に MC_GroupHalt また MC_GroupStop 。このPOUは、停止または停止コマンドが呼び出された時点での現在のステータス、現在の位置、およびすべてのコマンドされた動きを保存します。これにより、後で正確にこの位置から移動を続けることができます。注：これは、軸グループが停止位置に達した後に持っていた位置ではありません。 バージョン4.12.0.0より前の動作： SMC_GroupSaveContinueData 関数ブロックは、同じサイクルで呼び出す必要があります。 MC_GroupHalt また MC_GroupStop と呼ばれます。このとき、次のことを確認する必要があります SMC_GroupSaveContinueData 前に呼び出されます MC_GroupHalt また MC_GroupStop 。それ以外の場合、中止された移動はキューから削除されます。 バージョン4.12.0.0以降の動作： SMC_GroupSaveContinueData 機能ブロックは、呼び出し後の最初の移動までいつでも呼び出すことができます MC_GroupHalt また MC_GroupStop 。継続位置は、機能ブロックの最初の呼び出し時の現在の軸グループ位置です。保存されたパスは、停止\/停止コマンドの前に受け入れられたすべての動きで構成されます。 軸グループが停止した位置でパスを継続できるようにする MC_GroupHalt また MC_GroupStop 、 SMC_GroupSaveContinueData 次のサイクルで呼び出す必要があります MC_GroupHalt また MC_GroupStop を設定します Done 信号。 の1つのインスタンスのみ SMC_GroupSaveContinueData 軸グループごとに呼び出すことができます。 停止\/停止コマンドの前に現在のステータスを保存するには数サイクルかかる場合がありますが、最初のサイクルのステータス情報は、移動が中断される前に保存されることが保証されています。 SMC_GroupSaveContinueData 呼び出しに関連するだけでなく、現在の状態を保存するためにいつでも呼び出すことができます MC_GroupHalt また MC_GroupStop 。 " }, 
{ "title" : "単軸運動との相互作用 ", 
"url" : "_sm_additional_axes_single_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 単軸運動との相互作用 ", 
"snippet" : "軸グループの各軸 (追加の軸を含む) も、1 軸の動きで移動できます。そのためには、軸を軸グループから削除する必要はありません。以下のルールが用いられます。 軸グループが GroupStandby その軸のいずれかで単軸の動きが指示されると、軸グループはその状態のままになります。 詳細については、以下を参照してください。 軸グループの状態軸グループが GroupMoving 一軸の動きをその軸の 1 つで指示すると、軸グループが次の軸に切り替わる状態 GroupError 状態。 SMC_AXIS_GROUP_INTERRUPTED_BY_SINGLE_AXIS が報告され、他の軸はすべて停止...", 
"body" : "軸グループの各軸 (追加の軸を含む) も、1 軸の動きで移動できます。そのためには、軸を軸グループから削除する必要はありません。以下のルールが用いられます。 軸グループが GroupStandby その軸のいずれかで単軸の動きが指示されると、軸グループはその状態のままになります。 詳細については、以下を参照してください。 軸グループの状態軸グループが GroupMoving 一軸の動きをその軸の 1 つで指示すると、軸グループが次の軸に切り替わる状態 GroupError 状態。 SMC_AXIS_GROUP_INTERRUPTED_BY_SINGLE_AXIS が報告され、他の軸はすべて停止します。 軸グループで動きが指示され、その軸の少なくとも1つの軸で単軸の動きがアクティブになっている場合、軸グループは GroupError 状態。 " }, 
{ "title" : "移動座標系との同期 ", 
"url" : "_sm_robotics_dynamic_tracking.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 移動座標系との同期 ", 
"snippet" : "統合されたトラッキング機能により、移動座標系に対するモーションのプログラミングが可能になります。典型的な使用例は、コンベヤー ベルトから製品をピックアップし、それを別のコンベヤー ベルトに置くことです。各ベルトの動的座標系を定義した後、ユーザーはこれらの座標系に関連する移動の目標位置を簡単に指定できます。 CODESYS SoftMotion 指令された軸群の動きとベルトの動きを重ね合わせます。 一般的なトラッキング モーションは、次の 3 つのフェーズで構成されます。 トラッキング イン: 別の座標系から動的座標系への移動。目標位置に到達すると、軸グループは動的座標系の動きに従います。 移動...", 
"body" : "統合されたトラッキング機能により、移動座標系に対するモーションのプログラミングが可能になります。典型的な使用例は、コンベヤー ベルトから製品をピックアップし、それを別のコンベヤー ベルトに置くことです。各ベルトの動的座標系を定義した後、ユーザーはこれらの座標系に関連する移動の目標位置を簡単に指定できます。 CODESYS SoftMotion 指令された軸群の動きとベルトの動きを重ね合わせます。 一般的なトラッキング モーションは、次の 3 つのフェーズで構成されます。 トラッキング イン: 別の座標系から動的座標系への移動。目標位置に到達すると、軸グループは動的座標系の動きに従います。 移動の追跡: 同じ動的座標系内の別の位置への移動。指令された動きと動的座標系の動きが重ね合わされます。 トラッキング アウト: 動的座標系から別の座標系への移動。目標位置に到達すると、軸グループのモーションは動的座標系のモーションの影響を受けなくなります。 " }, 
{ "title" : "動的座標系の定義 ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4599737357387233382157942652", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 移動座標系との同期 \/ 動的座標系の定義 ", 
"snippet" : "動的追跡アプリケーションを実装する最初のステップは、動的座標系を定義することです。 CODESYS SoftMotion 動的座標系を定義するための 4 つの機能ブロックを提供します。 MC_TrackConveyorBelt : コンベヤ ベルトの追跡という一般的なユース ケース向けの使いやすい機能ブロックです。実際のベルトへの参照は、 ConveyorBelt タイプの SoftMotion 軸を期待する入力 AXIS_REF_SM3 . MC_TrackRotaryTable : 回転テーブルを追跡する一般的なユース ケース向けの使いやすいファンクション ブロック。実際の回転テーブルへの...", 
"body" : "動的追跡アプリケーションを実装する最初のステップは、動的座標系を定義することです。 CODESYS SoftMotion 動的座標系を定義するための 4 つの機能ブロックを提供します。 MC_TrackConveyorBelt : コンベヤ ベルトの追跡という一般的なユース ケース向けの使いやすい機能ブロックです。実際のベルトへの参照は、 ConveyorBelt タイプの SoftMotion 軸を期待する入力 AXIS_REF_SM3 . MC_TrackRotaryTable : 回転テーブルを追跡する一般的なユース ケース向けの使いやすいファンクション ブロック。実際の回転テーブルへの参照は、 RotaryTable タイプの SoftMotion 軸を期待する入力 AXIS_REF_SM3 . MC_SetDynCoordTransform : 機能ブロックは次のように機能します。 MC_TrackConveyorBelt と MC_TrackRotaryTable 、ただし、単一の軸によって制御されるのではなく、完全な軸グループによって制御されます。これにより、最大 6 つの自由度を持つ動的座標系を実装できます。 SMC_SetDynCoordTransformEx : 機能ブロックにより、完全にカスタムの動的座標系を実装できます。 4 つの機能ブロックのそれぞれには、 CoordSystem 基本的に座標系に名前を付けることができる入力、 PCS_1 また PCS_2 .移動を指示するとき、座標系はこの名前で参照されます。 " }, 
{ "title" : "動的座標系の位置への移動を命令する ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4620464078688033382158385681", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 移動座標系との同期 \/ 動的座標系の位置への移動を命令する ", 
"snippet" : "動的座標系を定義した後、この座標系の位置への移動を命令するのは簡単です。各動作機能ブロック、例えば MC_MoveLinearAbsolute 、 があります CoordSystem 入力。この入力は名前に設定する必要があります ( PCS_1 また PCS_2 ) 動的座標系に与えられます。の Position 入力は、動的座標系の原点を基準とした目的の位置に設定できます。移動ファンクションブロックを実行すると、移動座標系内の位置に移動します。目標位置に到達すると、軸グループはこの相対位置にとどまりながら動的座標系に従います。...", 
"body" : "動的座標系を定義した後、この座標系の位置への移動を命令するのは簡単です。各動作機能ブロック、例えば MC_MoveLinearAbsolute 、 があります CoordSystem 入力。この入力は名前に設定する必要があります ( PCS_1 また PCS_2 ) 動的座標系に与えられます。の Position 入力は、動的座標系の原点を基準とした目的の位置に設定できます。移動ファンクションブロックを実行すると、移動座標系内の位置に移動します。目標位置に到達すると、軸グループはこの相対位置にとどまりながら動的座標系に従います。 " }, 
{ "title" : "動的座標系機能ブロックの「使用中」出力 ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4663886345662433382158689616", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 移動座標系との同期 \/ 動的座標系機能ブロックの「使用中」出力 ", 
"snippet" : "各動的座標系機能ブロック ( MC_TrackConveyorBelt 、 MC_TrackRotaryTable 、 MC_SetDynCoordTransform 、 と SMC_SetDynCoordTransformEx ） 持っています InUse 出力。座標系がまだ使用されているときにファンクション ブロックを再起動することは許可されておらず、エラーが発生します。 SMC_AXIS_GROUP_PCS_STILL_IN_USE .動的座標系は、座標系のある位置への移動が命令されるとすぐに使用されます。異なる座標系の目標位置に到達するまで使用され続けます。...", 
"body" : "各動的座標系機能ブロック ( MC_TrackConveyorBelt 、 MC_TrackRotaryTable 、 MC_SetDynCoordTransform 、 と SMC_SetDynCoordTransformEx ） 持っています InUse 出力。座標系がまだ使用されているときにファンクション ブロックを再起動することは許可されておらず、エラーが発生します。 SMC_AXIS_GROUP_PCS_STILL_IN_USE .動的座標系は、座標系のある位置への移動が命令されるとすぐに使用されます。異なる座標系の目標位置に到達するまで使用され続けます。 " }, 
{ "title" : "動きを追跡するための軸の制限 ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4557758355867233382158929251", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 移動座標系との同期 \/ 動きを追跡するための軸の制限 ", 
"snippet" : "軸の制限は、座標系の動きと、座標系に対する指令された動きの両方を考慮する必要があります。座標系に追従するために高軸ダイナミクスが必要な場合、座標系に対する動きが遅くなるか、まったく動かなくなる可能性があります。軸グループがキネマティクスの特異点に近い場合、これは比較的動きの遅い座標系でも発生する可能性があります。 詳細については、次を参照してください。 タブ：一般...", 
"body" : "軸の制限は、座標系の動きと、座標系に対する指令された動きの両方を考慮する必要があります。座標系に追従するために高軸ダイナミクスが必要な場合、座標系に対する動きが遅くなるか、まったく動かなくなる可能性があります。軸グループがキネマティクスの特異点に近い場合、これは比較的動きの遅い座標系でも発生する可能性があります。 詳細については、次を参照してください。 タブ：一般" }, 
{ "title" : "追跡中の CP の動きのパス ダイナミクス ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm466388653271043338215917861", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 移動座標系との同期 \/ 追跡中の CP の動きのパス ダイナミクス ", 
"snippet" : "CP運動の経路ダイナミクスには特別な考慮を払う必要がある。これには以下が含まれる。 Velocity 、 Acceleration 、 Deceleration 、 そして Jerk の入力 MC_MoveLinearAbsolute 、 MC_MoveLinearRelative 、 MC_MoveCircularAbsolute 、 そして MC_MoveCircularRelative 開始位置と目標位置が同じ動的座標系にある場合、パス ダイナミクスはこの座標系を基準とします。ただし、開始位置と終了位置が異なる座標系にある場合、パス ダイナミクスは最初の座標系を基準とするダイナミクスから...", 
"body" : "CP運動の経路ダイナミクスには特別な考慮を払う必要がある。これには以下が含まれる。 Velocity 、 Acceleration 、 Deceleration 、 そして Jerk の入力 MC_MoveLinearAbsolute 、 MC_MoveLinearRelative 、 MC_MoveCircularAbsolute 、 そして MC_MoveCircularRelative 開始位置と目標位置が同じ動的座標系にある場合、パス ダイナミクスはこの座標系を基準とします。ただし、開始位置と終了位置が異なる座標系にある場合、パス ダイナミクスは最初の座標系を基準とするダイナミクスから 2 番目の座標系を基準とするダイナミクスにブレンドされます。パス ダイナミクスは、2 つの座標系間のダイナミクスの差の絶対値よりも高く設定することが重要です。特に、静的座標系から動的座標系に移動する場合、パス ダイナミクスは、座標系のダイナミクスの絶対値よりも高く設定する必要があります。 経路速度は、 SMC_GroupReadPathDynamics 座標系間を移動するとき (トラッキング イン、アウト、または異なる動的座標系間)。 SMC_GroupReadPathDynamics 指定された座標系に対するパス ダイナミクスを計算します。トラッキング インまたはトラッキング アウト、またはダイナミック座標系間を移動する場合、これは 2 つの座標系に依存する移動です (開始座標系と目的座標系は異なります)。その結果、 SMC_GroupReadPathDynamics 機能ブロックは、これらの場合のパス ダイナミクスの計算には適していません。 " }, 
{ "title" : "SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED、SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED、または SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED のエラーを回避します。 ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4558812953211233382159412375", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 移動座標系との同期 \/ SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED、SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED、または SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED のエラーを回避します。 ", 
"snippet" : "エラー SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED 、 SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED 、 または SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED 設定された軸制限またはパスダイナミクスに違反することなくコマンドされたパスに従うことができない場合に報告されます。このエラーが発生した場合は、まず軸制限とパスダイナミクスが前の2つのセクションに従って設定されているかどうかを確認する必要があります。パス偏差は出力で監視できます。 PositionLag そして Orientatio...", 
"body" : "エラー SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED 、 SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED 、 または SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED 設定された軸制限またはパスダイナミクスに違反することなくコマンドされたパスに従うことができない場合に報告されます。このエラーが発生した場合は、まず軸制限とパスダイナミクスが前の2つのセクションに従って設定されているかどうかを確認する必要があります。パス偏差は出力で監視できます。 PositionLag そして OrientationLag の MC_GroupReadStatus 機能ブロック。 考えられる解決策は次のとおりです。 軸の制限を増やします。 動的座標系に追跡するときの CP 移動のパス ダイナミクスを増やします。 座標系のダイナミクスを減らします。 ロボットの位置を変更するなど、キネマティクスの特異点に近い動きを避けます。 動的座標系がノイズの多いエンコーダの出力によって制御されている場合、論理軸を使用してエンコーダ信号をフィルタリングすると役立つ場合があります。詳細については、次を参照してください。 タブ：論理軸. 位置と方向のラグの許容誤差は、 SMC_GroupSetPathTolerance 機能ブロック。 " }, 
{ "title" : "360°を超える値の範囲を持つ回転軸 ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 360°を超える値の範囲を持つ回転軸 ", 
"snippet" : "CP運動の場合の行動 CP移動中（ MC_MoveLinearAbsolute \/ MC_MoveLinearRelative 、 MC_MoveCircularAbsolute \/ MC_MoveCircularRelative ）、回転軸は常に自動モード（期間0）で駆動されます。軸の周期は、軸にジャンプがないように常に選択されます。 CP移動の終了時に、指令された軸の値に到達しない可能性がありますが、期間の自動選択により、軸は別の期間に到着する可能性があります。これは、選択した移動タイプではコマンド位置に到達できないことを意味します。この競合は目標位置に到達する前に検出され、軸グループが停...", 
"body" : "CP運動の場合の行動 CP移動中（ MC_MoveLinearAbsolute \/ MC_MoveLinearRelative 、 MC_MoveCircularAbsolute \/ MC_MoveCircularRelative ）、回転軸は常に自動モード（期間0）で駆動されます。軸の周期は、軸にジャンプがないように常に選択されます。 CP移動の終了時に、指令された軸の値に到達しない可能性がありますが、期間の自動選択により、軸は別の期間に到着する可能性があります。これは、選択した移動タイプではコマンド位置に到達できないことを意味します。この競合は目標位置に到達する前に検出され、軸グループが停止してエラーが発生します。 例: 3 つの回転軸 A1、A2、A3 を持つ SCARA ロボットを使用します。A3 の値の範囲は -360° から +360° です。軸座標で 2 つの位置をティーチします。Position1 = (A1 = 0°、A2 = 90°、A3 = 170°)、Position2 = (A1 = 10°、A2 = 90°、A3 = -170°)。 次に直線運動を命令します（ MC_MoveLinear\/MC_MoveAbsolute) ）の方向モード GreatCircle 。 ACS でのコマンドと大円方向補間の組み合わせにより、競合が発生します。方向補間に従うには、軸 A3 は正方向の 170° から 190° まで移動する必要があります。したがって、必要なターゲット位置 (-170°) に到達できません。 コメント: CP 動作の場合、回転軸の周期は選択した補間タイプによって決まります。これはまた、軸の目標位置が目標点に近づく経路によって決まることも意味します。したがって、たとえば、2 つの動作をブレンドすると、バッファ動作の場合とは異なる周期で軸が到達する可能性があります。 詳細については、以下を参照してください。 CP運動の方向補間" }, 
{ "title" : "序章 ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html#UUID-12fb3c35-3bac-219e-b53a-31166417b16d_id_da342072b79533ffc0a864635077a64a_id_48a1e2bdb79a4093c0a864631bc39e2b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 360°を超える値の範囲を持つ回転軸 \/ 序章 ", 
"snippet" : "多くの場合、ロボットには360°を超える値の範囲の回転軸があります。たとえば、スカラロボットの最後の軸（方向軸A3）は、多くの場合、約-540°から540°まで、複数の回転を移動できます。 これは、同じ位置と向きに複数の方法でアプローチできることを意味します。たとえばスカラを考えると、最後の軸が-170°にあるか190°（=-170°+ 360°）にあるかに関係なく、ツールの方向と位置は同じです。その結果、デカルトの位置と方向の軸値への変換（運動学的逆変換）は一意ではありませんが、いくつかの解決策があります。 これは、たとえば、Pick＆Placeアプリケーションで使用して、-170°ではなく...", 
"body" : "多くの場合、ロボットには360°を超える値の範囲の回転軸があります。たとえば、スカラロボットの最後の軸（方向軸A3）は、多くの場合、約-540°から540°まで、複数の回転を移動できます。 これは、同じ位置と向きに複数の方法でアプローチできることを意味します。たとえばスカラを考えると、最後の軸が-170°にあるか190°（=-170°+ 360°）にあるかに関係なく、ツールの方向と位置は同じです。その結果、デカルトの位置と方向の軸値への変換（運動学的逆変換）は一意ではありませんが、いくつかの解決策があります。 これは、たとえば、Pick＆Placeアプリケーションで使用して、-170°ではなく170°から190°に移動することで時間を節約できます。 注：これらのアプリケーションでは、スカラ配向軸の動きがサイクルタイムの制限要因になる可能性があります。 " }, 
{ "title" : "あいまいさの解決 ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html#UUID-12fb3c35-3bac-219e-b53a-31166417b16d_id_da342072b79533ffc0a864635077a64a_id_e9620f70b79a4093c0a86463477a7031", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 360°を超える値の範囲を持つ回転軸 \/ あいまいさの解決 ", 
"snippet" : "移動するポイントが軸座標系（ACS）で指令されている場合、各軸について、ターゲットポイントでどのような値を取るかが明確になります。一方、デカルトコマンド（X \/ Y \/ Z-位置とA \/ B \/ Cの方向）では、このあいまいさは回転軸に存在します。 キネマティクスの構成は、このあいまいさを解決するために使用されます。スカラロボットの場合、構成には、スカラがポイントに近づくべきかどうかの設定がすでに含まれています。 ElbowRight また ElbowLeft 。さらに、スカラ構成には設定も含まれています nPeriodA3 、軸A3のあいまいさをどのように解決するかを決定するために使用できま...", 
"body" : "移動するポイントが軸座標系（ACS）で指令されている場合、各軸について、ターゲットポイントでどのような値を取るかが明確になります。一方、デカルトコマンド（X \/ Y \/ Z-位置とA \/ B \/ Cの方向）では、このあいまいさは回転軸に存在します。 キネマティクスの構成は、このあいまいさを解決するために使用されます。スカラロボットの場合、構成には、スカラがポイントに近づくべきかどうかの設定がすでに含まれています。 ElbowRight また ElbowLeft 。さらに、スカラ構成には設定も含まれています nPeriodA3 、軸A3のあいまいさをどのように解決するかを決定するために使用できます。 この目的のために、値の範囲全体が最大長360°の期間に分割されます。 -540°から-180°までの期間-1 -180°から180°までの期間1-180° 180°から540°までの期間2 （軸の値の範囲が大きい場合、それに応じてより多くの可能な期間があります。） 特別な価値もあります。もしも nPeriodA3 := 0 が設定されると、あいまいさの自動解決がアクティブになります。 PTP移動の場合、これは、軸4の開始位置と目標位置の間の距離ができるだけ小さくなるように期間が選択されることを意味します。 （CP動作での動作を以下に説明します。） したがって、それに応じて運動学的構成を設定することにより、回転軸のあいまいさの解決を制御することが可能です（を参照）。 SMC_SetKinConfiguration ）。この機能をサポートするキネマティクスは、インターフェースを実装します SMKinematicWithConfigurations3 。 の SMC_GroupReadSetPosition 、 MC_GroupReadActualPosition 、 と SMC_GroupTargetPosition 機能ブロックは常に、有効化された期間の自動解決を使用して構成を出力します。明示的に設定された期間を持つ現在の構成は、ACS 内の位置を読み取り、それを次の方法で MCS に変換することで読み出すことができます。 SMC_GroupConvertPosition 。返された構成には、明示的に期間が設定されています。 詳細については、以下を参照してください。 キネマティック構成" }, 
{ "title" : "外部軸の同期、トルクフィードフォワード制御 ", 
"url" : "_sm_robotics_external_axis_torque_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ 外部軸の同期、トルクフィードフォワード制御 ", 
"snippet" : "軸グループの軸の軸値は、通常、ユーザーがプログラムしたアプリケーション コードが実行された後のサイクルの終わりに計算されます。ただし、特定のアプリケーションでは、これらの値をアプリケーション コードで使用するために、より早く使用できるようにする必要があります。の SMC_グループ更新 ファンクション ブロックは、軸グループの一部であるすべての軸の値が即時に更新されることを確認します。 1 つのユースケース SMC_GroupUpdate 軸グループに属さない軸の同期です。例としては、XY ガントリーの場合の X 軸の 2 番目のドライブが挙げられます。 前に CODESYS SoftMotio...", 
"body" : "軸グループの軸の軸値は、通常、ユーザーがプログラムしたアプリケーション コードが実行された後のサイクルの終わりに計算されます。ただし、特定のアプリケーションでは、これらの値をアプリケーション コードで使用するために、より早く使用できるようにする必要があります。の SMC_グループ更新 ファンクション ブロックは、軸グループの一部であるすべての軸の値が即時に更新されることを確認します。 1 つのユースケース SMC_GroupUpdate 軸グループに属さない軸の同期です。例としては、XY ガントリーの場合の X 軸の 2 番目のドライブが挙げられます。 前に CODESYS SoftMotion バージョン4.13.0.0: SMC_GroupUpdate 機能ブロックはトルクフィードフォワード制御です。現在のサイクルで計算された軸の値を使用して、ロボットの動的モデルを使用して適切な設定トルクを計算できます。 で CODESYS SoftMotion バージョン4.13.0.0以降: 軸グループに動的モデルが割り当てられている場合、 SMC_GroupSetDynamics 、設定されたトルクは自動的に周期的に計算され、トルクフィードフォワード制御に使用できます。 SMC_GroupUpdate このユースケースでは不要になりました。詳細については、以下を参照してください。 トルク制限とトルクフィードフォワード制御" }, 
{ "title" : "トリガー ", 
"url" : "_sm_digital_switches-1517880.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ トリガー ", 
"snippet" : "トリガーは、軸グループがパス上の定義された位置に達したときにアクションを実行するために使用されます。たとえば、グルーディスペンサーは、接着位置に達したときにオンになるように設定できます。トリガーはタイムシフトにも対応しているので、指定した位置に達する前または後の正確な時間にアクションを実行できます。これは、例えば、グルーディスペンサーのデッドタイムを補うために使用できます。この目的のために、 CODESYS SoftMotion 動きに合わせてトリガーを設定し、その位置に到達するまでの残り時間を連続的に読み取ることができます。 トリガーを使用する場合は、次の点に注意してください。 トリガ到達ま...", 
"body" : "トリガーは、軸グループがパス上の定義された位置に達したときにアクションを実行するために使用されます。たとえば、グルーディスペンサーは、接着位置に達したときにオンになるように設定できます。トリガーはタイムシフトにも対応しているので、指定した位置に達する前または後の正確な時間にアクションを実行できます。これは、例えば、グルーディスペンサーのデッドタイムを補うために使用できます。この目的のために、 CODESYS SoftMotion 動きに合わせてトリガーを設定し、その位置に到達するまでの残り時間を連続的に読み取ることができます。 トリガーを使用する場合は、次の点に注意してください。 トリガ到達までの時間は、設定可能な予測時刻までに軸グループがトリガに近づいた場合のみ取得できます。この予測がどのように構成され、その設定がどのような影響を与えるかについては、「」で説明されています。 トリガーを使用するようにアプリケーションを構成する セクション。 トリガーを使用しても軌道は変更されません。特に、設定された予測に従うために軌道が減速されることはありません。たとえば、動きの開始時のトリガーの位置に 0.01 秒後にすでに到達している場合、その点に到達することを 0.01 秒以上前に通知することは、より高い予測でも実現できません。 詳細については、例を参照してください トリガーの例 1: 簡単な例 と トリガー例2：接着工程。 " }, 
{ "title" : "トリガーを使用するようにアプリケーションを構成する ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4612456003211233798533752147", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ トリガー \/ トリガーを使用するようにアプリケーションを構成する ", 
"snippet" : "予測期間の構成 予測期間によって、計画がどのくらい先のことまで行われるかが決まります。これは、 fPlanningForecastDuration のパラメータ SMC_TuneCPKernel ファンクションブロック。このパラメータをどのように設定するかは、アプリケーションの要件によって異なります。基本的に相反する 2 つの要件があります。 可能な限り最長の予測期間 可能な限り低い遅延。最初に予測を確立する必要があるため、動きを開始するときの待ち時間が長くなります。この追加の遅延のサイズは、主に使用されるコントローラーのパフォーマンスに依存し、通常は構成された予測よりも大幅に低くなります。さ...", 
"body" : "予測期間の構成 予測期間によって、計画がどのくらい先のことまで行われるかが決まります。これは、 fPlanningForecastDuration のパラメータ SMC_TuneCPKernel ファンクションブロック。このパラメータをどのように設定するかは、アプリケーションの要件によって異なります。基本的に相反する 2 つの要件があります。 可能な限り最長の予測期間 可能な限り低い遅延。最初に予測を確立する必要があるため、動きを開始するときの待ち時間が長くなります。この追加の遅延のサイズは、主に使用されるコントローラーのパフォーマンスに依存し、通常は構成された予測よりも大幅に低くなります。さらに、軸グループが中止動作や割り込みに反応するまでの遅延は、設定された予測によって増加します。予測には影響はありません MC_GroupHalt と MC_GroupStop 。どちらの機能ブロックも、構成された予測とは独立して、常に即座に動作します。 の fPlanningForecastDuration のパラメータ SMC_TuneCPKernel したがって、機能ブロックは必要なだけ高く設定する必要がありますが、できるだけ低く設定する必要があります。予測が必要ない場合は、パラメータをデフォルト値の 0 のままにすることができます。 実際に利用可能な予測は、たとえば最後の動作の終わりに近づいている場合など、さまざまな理由により、設定された予測と異なる場合があります。現在利用可能な予測は、次の方法で監視できます。 CurrentPlanningForecast の出力 MC_GroupReadStatus 。 動作ごとのトリガーの最大数の設定 納品されたとおり、 CODESYS SoftMotion 動作ごとに最大 8 つのトリガーをサポートします。この数が十分でない場合は、 MAX_NUM_TRIGGERS_PER_MOVEMENT パラメータはライブラリパラメータとして変更できます。これは、 図書館管理者 およびそれぞれの編集者 ライブラリパラメータ 。ライブラリパラメータを使用するには、 CODESYS バージョン SP19 以上を推奨します。 " }, 
{ "title" : "トリガーのコマンドと評価 ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4620348699414433798534144567", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ トリガー \/ トリガーのコマンドと評価 ", 
"snippet" : "トリガーのコマンドには 2 つの機能ブロックが使用できます。 SMC_グループ準備トリガー と SMC_GroupReadTrigger 。 トリガーは動作に割り当てられます。個々のトリガーを使用して準備する必要があります。 SMC_GroupPrepareTrigger ファンクションブロック。位置は、相対的、絶対的、または平面との交点として指定できます (「 SMC_TriggerPositionType ）。呼び出し順序は、 SMC_GroupPrepareTrigger 準備されたトリガーは同じサイクルで命令される次の動作に割り当てられるため、それぞれの動作は特に重要です。したがって、...", 
"body" : "トリガーのコマンドには 2 つの機能ブロックが使用できます。 SMC_グループ準備トリガー と SMC_GroupReadTrigger 。 トリガーは動作に割り当てられます。個々のトリガーを使用して準備する必要があります。 SMC_GroupPrepareTrigger ファンクションブロック。位置は、相対的、絶対的、または平面との交点として指定できます (「 SMC_TriggerPositionType ）。呼び出し順序は、 SMC_GroupPrepareTrigger 準備されたトリガーは同じサイクルで命令される次の動作に割り当てられるため、それぞれの動作は特に重要です。したがって、すべてのアプリケーションで次の点に注意する必要があります。 SMC_GroupPrepareTrigger 移動機能ブロックの前に必ず呼び出す必要があります。 トリガーとそれぞれの動きは常に同じサイクルで命令される必要があります。サイクル内で動きが開始されない場合、準備されたトリガーは破棄され、 CommandAborted の出力 SMC_GroupPrepareTrigger ファンクションブロックを設定します。 トリガーが動作に割り当てられている場合、トリガーに関する情報は次を使用して取得できます。 SMC_GroupReadTrigger 。トリガーが利用可能な予測期間内になるとすぐに、ステータスは次のように変わります。 SMC_TRIGGER_STATUS.Active トリガーに達するまでの時間を読み取ることができます。時間は常に現在のサイクルの開始時間を指します。トリガーをいつトリガーすべきか (位置に到達する前、途中、または後) に応じて、アプリケーションで適切なサイクルで目的のアクションを実行できます。 トリガーが動作に割り当てられている場合、トリガーを中止することはできません。代わりに、単に無視することもできます。 動作が次の動作によって中止された場合、 MC_BUFFER_MODE.Aborting , すると、最初の動きに割り当てられたトリガーも消えます。 " }, 
{ "title" : "ブレンドによる動きのトリガー ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4612455902227233798534431018", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 運動制御 \/ トリガー \/ ブレンドによる動きのトリガー ", 
"snippet" : "での動きについては、 動きのバッファリングとブレンド、トリガーがブレンディング パス上に投影されます。次の図は、P1 から P2 への移動とそれに続く移動をそれぞれブレンディングで指令した場合を定性的に示しています。最初の動きへのブレンドはポイント B で終了し、前の動きへのブレンドはポイント A から始まります。青いトリガーは P1 と B の間にあります。最初のブレンドの動きの後半に投影されます (青い線で強調表示されています)。 。同様に、A と P2 の間にある赤いトリガーが、2 番目のブレンド動作の前半分に投影されます (赤い線で強調表示されています)。緑のトリガーはブレンディング領...", 
"body" : "での動きについては、 動きのバッファリングとブレンド、トリガーがブレンディング パス上に投影されます。次の図は、P1 から P2 への移動とそれに続く移動をそれぞれブレンディングで指令した場合を定性的に示しています。最初の動きへのブレンドはポイント B で終了し、前の動きへのブレンドはポイント A から始まります。青いトリガーは P1 と B の間にあります。最初のブレンドの動きの後半に投影されます (青い線で強調表示されています)。 。同様に、A と P2 の間にある赤いトリガーが、2 番目のブレンド動作の前半分に投影されます (赤い線で強調表示されています)。緑のトリガーはブレンディング領域の外側にあり、シフトされていません。 トリガーとブレンドする場合、動きとそれぞれのトリガーのステータスに関する特別な機能があります。 P1 レポートから P2 レポートに移動するためのコマンド機能ブロック Done A点に到達するとすぐに。ただし、この動きに関連付けられた赤いトリガーは、それが投影されたブレンディング要素上の位置に到達するまでアクティブのままです。 " }, 
{ "title" : "トルク制限とトルクフィードフォワード制御 ", 
"url" : "_sm_torque_limitation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ トルク制限とトルクフィードフォワード制御 ", 
"snippet" : "のトルク制限 CODESYS SoftMotion 調整された動作中にドライブのトルクまたは力の指定された制限を超えないようにします。これらのトルクと力の制限は、ドライブの速度、加速度、ジャークに対する既存の制限に加えて尊重されます。これの要件は、適用されるキネマティクスの動的モデルであり、機能ブロックの形で実装されます。 ISMDynamics からのインターフェース SM3_Dynamics 図書館。基本的に、 AxesStateToTorque 軸の特定の状態 (位置、速度、および加速度) に必要なトルクを計算するメソッドが必要です。 トルク制限に加えて、動的モデルにより、トルク フィー...", 
"body" : "のトルク制限 CODESYS SoftMotion 調整された動作中にドライブのトルクまたは力の指定された制限を超えないようにします。これらのトルクと力の制限は、ドライブの速度、加速度、ジャークに対する既存の制限に加えて尊重されます。これの要件は、適用されるキネマティクスの動的モデルであり、機能ブロックの形で実装されます。 ISMDynamics からのインターフェース SM3_Dynamics 図書館。基本的に、 AxesStateToTorque 軸の特定の状態 (位置、速度、および加速度) に必要なトルクを計算するメソッドが必要です。 トルク制限に加えて、動的モデルにより、トルク フィード フォワード制御の設定トルクを計算できます。の章でアプリケーションの例を見つけることができます 動的ロボットモデル. " }, 
{ "title" : "ユースケース ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4597660278291233422349551383", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ トルク制限とトルクフィードフォワード制御 \/ ユースケース ", 
"snippet" : "多くのキネマティクス、特にシリアル キネマティクスでは、複数のジョイントまたはすべてのジョイントのカップリングがあります。これの簡単な例は、以下に示すように、ジョイントにドライブを備えた二重振り子です。 ユースケース 1 ユースケース 2 第 1 ジョイントのドライブは 90° 回転します。 2 番目の関節は動かないはずです (使用例 1)。受動的な第 2 関節を仮定すると、二重振り子の第 2 肢がその慣性により左に回転することは容易に想像できます。この回転を防ぐために、第 2 ジョイントのドライブは右方向にトルクを生成する必要があります。したがって、最初のドライブの動きには、2 番目のドライ...", 
"body" : "多くのキネマティクス、特にシリアル キネマティクスでは、複数のジョイントまたはすべてのジョイントのカップリングがあります。これの簡単な例は、以下に示すように、ジョイントにドライブを備えた二重振り子です。 ユースケース 1 ユースケース 2 第 1 ジョイントのドライブは 90° 回転します。 2 番目の関節は動かないはずです (使用例 1)。受動的な第 2 関節を仮定すると、二重振り子の第 2 肢がその慣性により左に回転することは容易に想像できます。この回転を防ぐために、第 2 ジョイントのドライブは右方向にトルクを生成する必要があります。したがって、最初のドライブの動きには、2 番目のドライブからの反応が必要です。 反対方向のカップリングは、たとえば、最初のドライブが一定の速度で移動し、2 番目のドライブが二重振り子の 2 番目のリムを引っ込める場合に存在します (ユース ケース 2)。これにより、最初のジョイントに関する二重振り子の慣性行列が減少します。角運動量 (慣性行列と角速度の積) を取得するには、最初のジョイントの角速度を増加させる必要があります。角速度を一定に保つには、最初のドライブのトルクをその回転方向に対して変化させて、角運動量を減少させる必要があります。したがって、2 番目のドライブの移動には、1 番目のドライブからの反応が必要です。 動的モデルがない場合は、設定位置、設定速度、および設定加速度のみをドライブに送信できます。最初のケースでは、最初のジョイントが動いているかどうかに関係なく、一定の設定位置が 2 番目のドライブに対して定義されます。 2 番目のドライブのコントロール ユニットは、同じ設定値に対してトルクを生成する必要がある場合と生成しない場合があるという事実に対処できる必要があります。動作は 2 番目のケースと似ています。ここでは、第 2 関節が動いているかどうかに関係なく、同じ一定の設定速度が第 1 ドライブに指定されています。ここでも、ドライブの制御ユニットは、同じ設定値に対して異なるトルクを生成する必要があるという事実に対処する必要があります。 動的モデルを使用すると、設定トルクを計算してドライブに送信できます。そこでは、コントロール ユニットのフィード フォワード ディメンションとして使用できます。その結果、制御ユニットは、制御品質の改善を可能にする追加情報を受信する。 トルク制限により、ドライブの制限をより正確に遵守できます。多くの場合、決定的なのはドライブの速度や加速度の制限ではなく、トルクの制限です。トルク制限の利点は、前述の二重振り子の例から、次の動きを比較すると明らかになります。つまり、第 1 駆動装置の第 2 肢が縮んだ状態の動きと、第 1 駆動装置の第 2 肢が伸びた状態の動きです。収縮状態では、第 1 関節に関する慣性行列は、伸長状態よりも小さくなります。したがって、同じ動き (ドライブの同じ速度曲線と加速曲線) の場合、収縮状態よりも伸長状態の方がより大きなトルクが必要になります。動的モデルがない場合は、速度と加速度の制限を設定して、両方の状態でトルクの制限が守られるようにする必要があります。これにより、最初のドライブは、ドライブのトルク制限を遵守するために必要な速度または加速よりも低い速度または加速度で収縮状態で移動する可能性があります。動的モデルを使用すると、トルク制限を構成して、動作を計画するときに考慮できるため、両方の状態で十分に活用できます。 もう少し複雑な例は、前述の最初のケースで、最初のドライブが移動中で、2 番目のドライブがその位置を保持する必要があります。位置を保持するために 2 番目のドライブに必要なトルクは、最初のドライブの動きに依存します。最初のドライブの加速が急すぎると、原則として、2 番目のドライブのトルク制限に違反する可能性があります。動的モデルがない場合、これを防ぐには、最初のドライブの加速制限を適切に構成する必要があります。動的モデルでは、移動を計画する際に 2 番目のドライブの設定されたトルク制限を考慮に入れることができ、最初のドライブの加速を制限することができます。 より複雑な動きやキネマティクスの場合、ここで説明する結合効果は、さらに多くの結合効果と一緒になります。動的モデルを使用すると、これらのカップリングを考慮に入れることができるため、設定値の仕様が向上し、ドライブの制限への準拠が向上します。 " }, 
{ "title" : "動的モデルの構成 ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4510933957710433418427140333", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ トルク制限とトルクフィードフォワード制御 \/ 動的モデルの構成 ", 
"snippet" : "を実装する機能ブロックの形式の既存の動的モデル ISMDynamics インターフェイスは、軸グループに割り当てることができます。 SMC_GroupSetDynamics 機能ブロック。動的モデルに加えて、関数ブロックを使用して、重力加速度の方向と大きさを機械座標系のベクトル形式で構成する必要があります。...", 
"body" : "を実装する機能ブロックの形式の既存の動的モデル ISMDynamics インターフェイスは、軸グループに割り当てることができます。 SMC_GroupSetDynamics 機能ブロック。動的モデルに加えて、関数ブロックを使用して、重力加速度の方向と大きさを機械座標系のベクトル形式で構成する必要があります。 " }, 
{ "title" : "負荷の考慮 ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552490173838433418429772624", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ トルク制限とトルクフィードフォワード制御 \/ 負荷の考慮 ", 
"snippet" : "追加の負荷 (たとえば、把持されたオブジェクトまたは取り付けられたツール) は、 SMC_GroupSetLoad 関数ブロックであり、実行時に変更されます。の ExecutionMode 機能ブロックの入力を使用して、負荷の変更がいつ有効になるかを定義できます (たとえば、すぐに、または現在の移動が完了した後のみ)。 との続き MC_GroupContinue : 継続する場合、継続データに格納されているすべての動きは、最初に指令された荷重を維持します。継続後に命令される移動は、最後に設定された負荷を使用します。...", 
"body" : "追加の負荷 (たとえば、把持されたオブジェクトまたは取り付けられたツール) は、 SMC_GroupSetLoad 関数ブロックであり、実行時に変更されます。の ExecutionMode 機能ブロックの入力を使用して、負荷の変更がいつ有効になるかを定義できます (たとえば、すぐに、または現在の移動が完了した後のみ)。 との続き MC_GroupContinue : 継続する場合、継続データに格納されているすべての動きは、最初に指令された荷重を維持します。継続後に命令される移動は、最後に設定された負荷を使用します。 " }, 
{ "title" : "ギアボックスの検討 ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552678559262433422353734728", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ トルク制限とトルクフィードフォワード制御 \/ ギアボックスの検討 ", 
"snippet" : "設定トルクはギアボックス出力に対して計算され、ドライブに自動的に変換されません。の SMC_SetAdditionalConversionFactors 機能ブロックを使用して、各軸のトルクの追加の変換係数を構成できます。ギアボックスもこの方法で考慮することができます。...", 
"body" : "設定トルクはギアボックス出力に対して計算され、ドライブに自動的に変換されません。の SMC_SetAdditionalConversionFactors 機能ブロックを使用して、各軸のトルクの追加の変換係数を構成できます。ギアボックスもこの方法で考慮することができます。 " }, 
{ "title" : "単位 ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4597662777713633422354433707", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ トルク制限とトルクフィードフォワード制御 \/ 単位 ", 
"snippet" : "力とトルク、およびそれらの制限は、基本的にアプリケーションでニュートン (N) またはニュートン メートル (Nm) で指定されます。設定された力または設定されたトルクがドライブに送られる前に、再スケーリングが行われる場合があります。このため、CiA 402 規格では、たとえば、定格トルク (mNm) の 1000 分の 1 で設定トルクをドライブに送信する必要があります。 長さの単位は、SoftMotion ではユーザー固有です。力とトルクは固定単位 (N または Nm) として定義されるため、ユーザー固有の長さ単位からメートルへの変換係数を構成する必要があります (メートルが長さ単位として...", 
"body" : "力とトルク、およびそれらの制限は、基本的にアプリケーションでニュートン (N) またはニュートン メートル (Nm) で指定されます。設定された力または設定されたトルクがドライブに送られる前に、再スケーリングが行われる場合があります。このため、CiA 402 規格では、たとえば、定格トルク (mNm) の 1000 分の 1 で設定トルクをドライブに送信する必要があります。 長さの単位は、SoftMotion ではユーザー固有です。力とトルクは固定単位 (N または Nm) として定義されるため、ユーザー固有の長さ単位からメートルへの変換係数を構成する必要があります (メートルが長さ単位として使用されている場合を除く)。これは、 SMC_GroupSetUnits 機能ブロック。 " }, 
{ "title" : "移動座標系でのトルク制限 ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552049322772833422354993274", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ トルク制限とトルクフィードフォワード制御 \/ 移動座標系でのトルク制限 ", 
"snippet" : "軸グループが可動座標系で移動する場合、トルク制限は、軸グループが可動座標系に正確に従うことができる場合にのみ尊重されます。これが不可能で、偏差の許容範囲が次の方法で設定されている場合 SMC_GroupSetPathTolerance 偏差を補正しようとすると、トルク制限を超える可能性があります。偏差が許容範囲外であるためにエラーが発生した場合、軸グループは停止します。この停止中に、トルク制限を超えることもあります。設定トルクはそれぞれのケースで計算され、ドライブに送信されます。...", 
"body" : "軸グループが可動座標系で移動する場合、トルク制限は、軸グループが可動座標系に正確に従うことができる場合にのみ尊重されます。これが不可能で、偏差の許容範囲が次の方法で設定されている場合 SMC_GroupSetPathTolerance 偏差を補正しようとすると、トルク制限を超える可能性があります。偏差が許容範囲外であるためにエラーが発生した場合、軸グループは停止します。この停止中に、トルク制限を超えることもあります。設定トルクはそれぞれのケースで計算され、ドライブに送信されます。 " }, 
{ "title" : "エラー時のトルク制限 ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4612699285196833422355410226", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ トルク制限とトルクフィードフォワード制御 \/ エラー時のトルク制限 ", 
"snippet" : "計画中にエラーが検出された場合 (たとえば、命令された移動が作業領域に違反するなど)、軸グループは以前に命令されたパスで停止します。そうすることで、トルク制限が守られます。パス上で停止できない場合 (たとえば、ドライブがエラーを報告したため)、トルク制限も順守できません。...", 
"body" : "計画中にエラーが検出された場合 (たとえば、命令された移動が作業領域に違反するなど)、軸グループは以前に命令されたパスで停止します。そうすることで、トルク制限が守られます。パス上で停止できない場合 (たとえば、ドライブがエラーを報告したため)、トルク制限も順守できません。 " }, 
{ "title" : "単軸動作と協調動作の違い ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4483062104566433422355806924", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ トルク制限とトルクフィードフォワード制御 \/ 単軸動作と協調動作の違い ", 
"snippet" : "基本的に、設定トルクは、動的モデルを持つ軸グループの一部であるすべての軸に対して計算されます。これは、停止時と、単軸移動によって軸が移動する場合の両方に適用されます (たとえば、 MC_MoveAbsolute ) または軸グループ全体が調整された移動によって移動します (たとえば、 MC_MoveDirectAbsolute ）。 トルク制限は、協調動作に対してのみ有効です。この理由は、前述のように、軸の必要なトルクが、軸グループ内の他の軸の一部またはすべての位置と動きに依存するためです。したがって、トルクの制限は、軸グループのすべての軸が協調動作として移動できる場合にのみ可能です。 例外は...", 
"body" : "基本的に、設定トルクは、動的モデルを持つ軸グループの一部であるすべての軸に対して計算されます。これは、停止時と、単軸移動によって軸が移動する場合の両方に適用されます (たとえば、 MC_MoveAbsolute ) または軸グループ全体が調整された移動によって移動します (たとえば、 MC_MoveDirectAbsolute ）。 トルク制限は、協調動作に対してのみ有効です。この理由は、前述のように、軸の必要なトルクが、軸グループ内の他の軸の一部またはすべての位置と動きに依存するためです。したがって、トルクの制限は、軸グループのすべての軸が協調動作として移動できる場合にのみ可能です。 例外は、 SMC_GroupJog 関数ブロック。このファンクション ブロックは、トルク制限をサポートしていません。使用することをお勧めします SMC_GroupJog2 代わりは。 " }, 
{ "title" : "診断 ", 
"url" : "_sm_robotics_diagnosis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 診断 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "よくあるエラー ", 
"url" : "_sm_robotics_errors.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 診断 \/ よくあるエラー ", 
"snippet" : "このページでは、一般的な軸グループのエラー、その原因、およびエラーを修正するための可能なアクションについて説明します。考えられるすべてのエラーのリストと簡単な説明については、ヘルプページを参照してください。 SMC_ERROR (列挙) 。 エラーコード 説明と原因 行動 SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED 軸グループは、軸制限 (速度、加速度、またはジャーク) に違反せずにコマンドされた...", 
"body" : "このページでは、一般的な軸グループのエラー、その原因、およびエラーを修正するための可能なアクションについて説明します。考えられるすべてのエラーのリストと簡単な説明については、ヘルプページを参照してください。 SMC_ERROR (列挙) 。 エラーコード 説明と原因 行動 SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED 軸グループは、軸制限 (速度、加速度、またはジャーク) に違反せずにコマンドされたパスに従うことができません。 このエラーは、 追跡 動的座標系が予期せず移動した場合。 このエラーは、経路がロボットの特異点の近くを通過するときにも発生する可能性があります。特異点とは、異なるロボット間で発生するものです。 構成 (例えば、SCARA ロボットでアームが完全に伸びたときなど)。 見る SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED、SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED、または SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED のエラーを回避します。動的座標系を使用しない場合は、ロボットのパスが特異な位置の近くを通過しないようにしてください。 SMC_CP_QUEUE_UNDERRUN 軸グループの軌道 (速度プロファイル) を十分な速さで計算できなかったため、軸グループは移動を中止する必要があります。 考えられる原因： パフォーマンスの問題。使用中のコントローラーが十分なパフォーマンスを提供していないか、優先度の高いタスクで計算される量が多すぎます。 不利なタスク設定: 軌道の計算が他のタスクによって置き換えられます。 計算集約型のコマンド。たとえば、ブレンディング動作が中止動作によって中断され、その後再び中止動作によって中断された場合、より多くの計算時間が必要になることがあります。トラッキング（動的座標系）の使用にもより多くの計算時間が必要です。 SMC_GroupSaveContinueData 移動中や、同時にアクティブなトリガーを多数使用すると、必要な計算時間が長くなることもあります。 軸グループの計画タスクのタスク設定が正しく選択されているかどうかを確認し、可能であれば、このタスクを別の専用 CPU コアに再配置します。 詳細については、以下を参照してください。 計画タスクの構成上の 監視 タスク設定のタブ 1 優先度の高いタスクに多くの計算時間が必要かどうかを確認し、可能であれば、パフォーマンスを集中的に使用する計算を優先度の低いタスクに移動します。 使用 SMC_TuneCPKernel 計画間隔を長くします。 詳細については、以下を参照してください。 動きが遅い、またはぎくしゃくしている場合の診断注: パフォーマンスカウンタは、 SMC_GroupReadPlanningStatistics これらのアクションの効果を判断するためです。 詳細については、以下を参照してください。 動きが遅い、またはぎくしゃくしている場合の診断SMC_TRAFO_INVALID_CONSTELLATION SMC_AXIS_POSITION_EXCEEDS_POSLIMITS SMC_AXIS_INVERSE_TRAFO_EXCEEDING_POSLIMITS パスが完全にまたは部分的にロボットの作業スペースの外側にあります。 考えられる原因： 移動の開始点または終了点がワークスペースの外側にあります。 ロボットのタイプによっては、CP 動作の一部がワークスペースの外側に出る場合があります。半径が大きすぎる円セグメントは、開始と終了がワークスペース内に収まりますが、中間セクションはワークスペースの外側に出ることがあります。 トラッキング (動的座標系) を使用する場合、座標系の移動により、以前にワークスペース内に配置されていた位置が時間の経過とともにワークスペースから外れる可能性があります。 注意: エラーが報告された場合、軸グループは必ずしも問題のある位置に近いとは限りません。軌道の計算中にエラーが見つかり、報告され、現在の位置からまだ遠いパス セグメントに関連している可能性があります。 指示された動作を確認し、それが完全に作業スペース内にあることを確認します。 トラッキングを使用する場合: 適切な制限を使用して、軸グループが時間の経過とともに作業スペースから移動しないようにします。たとえば、コンベア ベルトを使用した Pick&Place では、部品をコンベア ベルトからピックアップできる安全な領域を定義するのが一般的です。部品がこの領域を離れた後は、軸グループは部品に移動しなくなります。 SMC_CP_CONFIGS_DIFFER SMC_CP_AXIS_ORIENTATION_IPO_CONFIG_DIFFERS CP 移動の開始位置と目標位置は、異なる構成で配置されます。 設定の取り扱いについては、 キネマティック構成 章。 使用する場合 OrientationMode Axis 、を参照してください CP運動の方向補間 ロボットの方向部分の設定の詳細については、この章を参照してください。 可能なアクション: CP 移動の開始位置と終了位置が同じ構成になっていることを確認します。 必要に応じて、 SMC_SetKinConfiguration ロボットの初期構成を設定するための機能ブロック（ MC_GroupEnable ）。 必要に応じて、PTP 動作を使用して構成を切り替えます。 " }, 
{ "title" : "パフォーマンス ", 
"url" : "_sm_robotics_performance.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 診断 \/ パフォーマンス ", 
"snippet" : "計算には CPU 負荷がかかるため、動作の計画は別のタスクで実行されます。この別のタスクは計画タスクと呼ばれ、バス タスクと並行して実行されます。PLC のパフォーマンスが、バス タスクに間に合うように計画タスクでパスを計画するのに十分でない場合、パフォーマンスの問題が発生します。 動作計画におけるパフォーマンスの問題は、 SMC_CP_QUEUE_UNDERRUN エラーが発生するだけでなく、動きがぎくしゃくしたり、予想よりも遅くなったりすることもあります。 SMC_CP_QUEUE_UNDERRUN エラーについては、 よくあるエラー 章。動作に関するパフォーマンス関連の問題の診断について...", 
"body" : "計算には CPU 負荷がかかるため、動作の計画は別のタスクで実行されます。この別のタスクは計画タスクと呼ばれ、バス タスクと並行して実行されます。PLC のパフォーマンスが、バス タスクに間に合うように計画タスクでパスを計画するのに十分でない場合、パフォーマンスの問題が発生します。 動作計画におけるパフォーマンスの問題は、 SMC_CP_QUEUE_UNDERRUN エラーが発生するだけでなく、動きがぎくしゃくしたり、予想よりも遅くなったりすることもあります。 SMC_CP_QUEUE_UNDERRUN エラーについては、 よくあるエラー 章。動作に関するパフォーマンス関連の問題の診断については、以下で説明します。 " }, 
{ "title" : "動きが遅い、またはぎくしゃくしている場合の診断 ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm4597696111868834242456592379", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 診断 \/ パフォーマンス \/ 動きが遅い、またはぎくしゃくしている場合の診断 ", 
"snippet" : "パフォーマンス上の問題がない場合、各動作は、少なくとも1つの 有効限度 は、動作全体を通して到達されます。例として、X 軸と Y 軸の 2 つの単純な 2 次元ガントリーと、位置 (0,0) から (10,-10) への PTP 動作を考えます。最大軸速度は 20、最大軸加速度は 100、最大軸ジャークは 1000 です。 予想される動きは次のようになります。 最初に最大ジャークで加速が確立され、加速制限値 100 に達します。一定加速の短いフェーズの後、最大ジャークで再び加速が低減され、加速度 0 で速度制限値 20 に達します。一定速度のフェーズの後、減速が行われ、速度と加速度 0 で目標...", 
"body" : "パフォーマンス上の問題がない場合、各動作は、少なくとも1つの 有効限度 は、動作全体を通して到達されます。例として、X 軸と Y 軸の 2 つの単純な 2 次元ガントリーと、位置 (0,0) から (10,-10) への PTP 動作を考えます。最大軸速度は 20、最大軸加速度は 100、最大軸ジャークは 1000 です。 予想される動きは次のようになります。 最初に最大ジャークで加速が確立され、加速制限値 100 に達します。一定加速の短いフェーズの後、最大ジャークで再び加速が低減され、加速度 0 で速度制限値 20 に達します。一定速度のフェーズの後、減速が行われ、速度と加速度 0 で目標位置に到達します。 実際の動きがこの理想的な曲線から逸脱する理由は 2 つ考えられます。 計画タスクのパフォーマンスの問題により、計画された動きは理想的な曲線と一致しません。 計画された動きは理想的な曲線に対応していますが、ロボットはそれを期待どおりに実行しません。 " }, 
{ "title" : "ケース1: 計画タスクのパフォーマンスの問題 ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433006527711", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 診断 \/ パフォーマンス \/ 動きが遅い、またはぎくしゃくしている場合の診断 \/ ケース1: 計画タスクのパフォーマンスの問題 ", 
"snippet" : "計画中にパフォーマンスに問題がある場合は、代わりに次の動きになる場合があります。 これは、バス タスクの実行と並行して、計画タスクで移動が計画されるためです。平均すると、計画タスクはバス タスクに必要なだけの軌道を提供する必要があります。パフォーマンスがこれに十分でない場合、移動は遅くなります。これにより、波状の速度曲線が発生します。 このような問題を診断するための最初の、そして最も重要なツールはトレースです。 fSetPosition 、 fSetVelocity 、 そして fSetAcceleration 各軸の変数は、 numTimeBudgetExceeded そして numSlow...", 
"body" : "計画中にパフォーマンスに問題がある場合は、代わりに次の動きになる場合があります。 これは、バス タスクの実行と並行して、計画タスクで移動が計画されるためです。平均すると、計画タスクはバス タスクに必要なだけの軌道を提供する必要があります。パフォーマンスがこれに十分でない場合、移動は遅くなります。これにより、波状の速度曲線が発生します。 このような問題を診断するための最初の、そして最も重要なツールはトレースです。 fSetPosition 、 fSetVelocity 、 そして fSetAcceleration 各軸の変数は、 numTimeBudgetExceeded そして numSlowDownLowIpoQueue の出力 SMC_GroupReadPlanningStatistics 機能ブロックも記録する必要があります。これらのカウンターが継続的に増加する場合は、パフォーマンスに問題があります。 同様に fSetPosition 、 fSetVelocity 、 そして fSetAcceleration 変数には、 fSetJerk ジャークの変数。ジャークはバスタスクサイクル中に適用される平均ジャークではなく（よく予想されるように）、サイクルの終わりの瞬間ジャークであることに注意する必要があります。したがって、 FSetJerk パフォーマンスの問題を診断する上での重要性は限られています。 " }, 
{ "title" : "動きを改善する方法 ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm43443300985204", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 診断 \/ パフォーマンス \/ 動きが遅い、またはぎくしゃくしている場合の診断 \/ ケース1: 計画タスクのパフォーマンスの問題 \/ 動きを改善する方法 ", 
"snippet" : "次のリストには、パフォーマンスの問題を処理する手順が含まれています。 速度、加速度、ジャークの制限値の調整: 現在の速度から停止まで減速するのにかかる時間が長くなるほど、必要な計算能力は大きくなります。 したがって、速度の有効制限値が高く、加速度とジャークの有効制限値が低いと、パフォーマンスの問題が発生する可能性が高くなります。 特に、加速度とジャークの制限値は不必要に低く設定すべきではない。 計画タスクの優先度を上げるか、計画タスクをブロックしている他のタスクの優先度を下げます。計画タスクは、バス タスクに次いで 2 番目に高い優先度にする必要があります。 複数のCPUコアが利用可能な場合は...", 
"body" : "次のリストには、パフォーマンスの問題を処理する手順が含まれています。 速度、加速度、ジャークの制限値の調整: 現在の速度から停止まで減速するのにかかる時間が長くなるほど、必要な計算能力は大きくなります。 したがって、速度の有効制限値が高く、加速度とジャークの有効制限値が低いと、パフォーマンスの問題が発生する可能性が高くなります。 特に、加速度とジャークの制限値は不必要に低く設定すべきではない。 計画タスクの優先度を上げるか、計画タスクをブロックしている他のタスクの優先度を下げます。計画タスクは、バス タスクに次いで 2 番目に高い優先度にする必要があります。 複数のCPUコアが利用可能な場合は、計画タスクを専用コアに割り当てます（ 計画タスクの構成）。 使用 SMC_TuneCPKernel 価値を高めるために fPlanningInterval および\/または fSyncBufferDuration 計画パラメータ。 の fPlanningInterval パラメータは、計画の最大増分（秒単位）を指定します。計画タスクのサイクルタイムは、この値を永続的に超えてはいけません。値を大きくすると計算能力が低下しますが、速度、加速度、ジャークの設定された制限値が完全に利用されない可能性もあります。開始値0.016秒（ CODESYS SoftMotion バージョン 4.6.0.0 以降では、パフォーマンスが許容できるレベルになるまで値を徐々に増やしていく必要があります。 の fSyncBufferDuration パラメータは、計画タスクとバス タスク間のバッファのサイズを指定します。計画タスクのピーク サイクル タイムは、この値を超えてはなりません。値を大きくすると、計画タスクのサイクル タイムのピークを補正できます。ただし、同時に、割り込みの実行と動作の中止の待ち時間も長くなります。 " }, 
{ "title" : "ケース2: ロボットが計画された動きに期待通りに従わない ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433008452776", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 診断 \/ パフォーマンス \/ 動きが遅い、またはぎくしゃくしている場合の診断 \/ ケース2: ロボットが計画された動きに期待通りに従わない ", 
"snippet" : "ロボットが計画された動きに期待どおりに従わない場合は、次の理由が考えられます。 コントローラのリアルタイム機能が不十分 ドライブの制御ループの問題 リアルタイム非対応のコントローラでは、 CODESYS Control Win 、または基盤となる Linux システムのリアルタイム パッチが適用されていない Linux ベースのコントローラーでは、十分なパフォーマンスがあっても、動作が遅すぎたり、ぎくしゃくしたりすることがあります。これは、バス タスクが設定された時間枠内で時間どおりに実行されない場合に発生します。...", 
"body" : "ロボットが計画された動きに期待どおりに従わない場合は、次の理由が考えられます。 コントローラのリアルタイム機能が不十分 ドライブの制御ループの問題 リアルタイム非対応のコントローラでは、 CODESYS Control Win 、または基盤となる Linux システムのリアルタイム パッチが適用されていない Linux ベースのコントローラーでは、十分なパフォーマンスがあっても、動作が遅すぎたり、ぎくしゃくしたりすることがあります。これは、バス タスクが設定された時間枠内で時間どおりに実行されない場合に発生します。 " }, 
{ "title" : "動きを改善する方法 ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433012326085", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 診断 \/ パフォーマンス \/ 動きが遅い、またはぎくしゃくしている場合の診断 \/ ケース2: ロボットが計画された動きに期待通りに従わない \/ 動きを改善する方法 ", 
"snippet" : "タスク設定の「監視」タブ 1 バスタスクのタスクジッターをチェックする 2 高すぎます。これは、バス タスクが同等またはより高い優先度のタスクに置き換えられているか、コントローラが十分なリアルタイム機能を備えていないことが原因である可能性があります。 ジッターが高すぎて、バス タスクの優先度が最高であることがすでに確認されている場合は、コントローラーのリアルタイム機能が不十分です。この場合は、リアルタイム特性が優れたコントローラーを使用してください。 ドライブに制御ループの問題がある場合は、制御ループ パラメータを調整する必要があります。トルク フィード フォワード制御によって、制御ループのパ...", 
"body" : "タスク設定の「監視」タブ 1 バスタスクのタスクジッターをチェックする 2 高すぎます。これは、バス タスクが同等またはより高い優先度のタスクに置き換えられているか、コントローラが十分なリアルタイム機能を備えていないことが原因である可能性があります。 ジッターが高すぎて、バス タスクの優先度が最高であることがすでに確認されている場合は、コントローラーのリアルタイム機能が不十分です。この場合は、リアルタイム特性が優れたコントローラーを使用してください。 ドライブに制御ループの問題がある場合は、制御ループ パラメータを調整する必要があります。トルク フィード フォワード制御によって、制御ループのパフォーマンスを向上させることもできます。 詳細については、以下を参照してください。 トルク制限とトルクフィードフォワード制御1 : アプリケーションの起動後の最初の PLC サイクルでは、期間が長くなり、ジッターが増加することが多いため、コンテキスト メニューでタスク監視の測定値をリセットすることをお勧めします。 2 : ジッター値が約 20 マイクロ秒までであれば非常に良好で、約 100 マイクロ秒までであれば良好です。使用するドライブによっては、より高いジッター値での動作も可能な場合があります。ジッター値がバス タスクのタスク間隔の桁に達すると、上記のエラー パターンが発生する可能性があります。 " }, 
{ "title" : "ロギング情報 ", 
"url" : "_sm_information_logging.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 診断 \/ ロギング情報 ", 
"snippet" : "ザル SMC_Group イベントロギング ファンクションブロックは SoftMotion バージョン 4.18.0.0 で導入されました。ファンクションブロックを使用して軸グループのログメッセージを有効にできます。ログメッセージが有効になるとすぐに、軸グループが実行するアクションが軸グループに書き込まれます ログ デバイスの。これにより、軸グループのイベントを時系列で追跡できます。これは、軸グループの問題や予期しない動作を調査する場合に役立ちます。 ムーブメント、ロード、ツールなどに名前を付けると、有益なログメッセージが得られます。で CODESYS SoftMotion バージョン 4.1...", 
"body" : "ザル SMC_Group イベントロギング ファンクションブロックは SoftMotion バージョン 4.18.0.0 で導入されました。ファンクションブロックを使用して軸グループのログメッセージを有効にできます。ログメッセージが有効になるとすぐに、軸グループが実行するアクションが軸グループに書き込まれます ログ デバイスの。これにより、軸グループのイベントを時系列で追跡できます。これは、軸グループの問題や予期しない動作を調査する場合に役立ちます。 ムーブメント、ロード、ツールなどに名前を付けると、有益なログメッセージが得られます。で CODESYS SoftMotion バージョン 4.18.0.0 以降では、一部のコマンド機能ブロック (など) MC_MoveLinearAbsolute 、 SMC_GroupSetTool そして MC_SetCoordinateTransform ) には新しいものが提供されました Name 入力。 ロギングはパフォーマンスに悪影響を及ぼす可能性があるため、を使用して有効にする必要があります SMC_GroupEventLogging ファンクションブロック。 で CODESYS SoftMotion バージョン 4.18.0.0 では、軸グループのパスに関連するメッセージが記録されます。 カテゴリー [アクション] [説明] [追加情報] ムーブメント 動きが始まる 軸グループが動きの補間を開始しました。 概要ムーブメント終了 軸グループが動きの補間を完了しました。 ブレンド開始 軸グループは、アクティブな動きから次の動きまでブレンドを開始しました。 ブレンドエンド 軸グループはブレンドを完了し、次の動きで補間を続けます。 中止開始 軸グループが現在の動きを中止し、中止した動きに溶け込んでいます。 中止終了 軸グループはブレンドを完了し、中止した動きの補間を続けます。 待機開始 軸グループは現在の位置で待機します。 待機終了 枢軸グループは待機を終了しました。 停止\/停止開始 軸グループが経路上で停止\/停止を実行し始めました。 停止\/停止終了 軸グループがパスの停止\/停止を実行しました。 ツール ツール付属 軸グループは新しいツールを使用します。 ツールオフセットの構成読み込み ロードアタッチ 軸グループは新しい荷重を使用します。 トルク制限とトルクフィードフォワード制御オーバーライド 軸またはパスのオーバーライドが変更されました 軸またはパスのオーバーライドが変更され、軸グループによって適用されました。 MC_グループセットオーバーライド (FB) 経路精度 パスが逸脱しました 軸の制限に違反しないように、軸グループがコマンドパスを離れました。軸グループは再び指令された経路に到達しようとします。 パス精度の許容差再びたどり着いた道 軸グループが再びコマンドパスに到達しました。 中断-続行 割り込み開始 軸グループが割り込みを実行し始めました。 動きの中断と継続割り込み終了 軸グループが割り込みを実行し、Continueデータを保存しました。 続行開始 軸グループが継続データを読み取り、継続を開始します。 " }, 
{ "title" : "例 ", 
"url" : "_sm_robotics_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "ロボットのジョギング ", 
"url" : "_sm_robotics_jogging.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ ロボットのジョギング ", 
"snippet" : "を参照してください Robotics_Jogging.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例は、軸グループをジョギングする方法を示しています。 SMC_GroupJog2 POU。 をインストールすることをお勧めします CODESYS Depictor この例では（無料のデモバージョンで十分です）。または、Depictorなしで例を使用するために、対応するコード部分を例から削除することもできます。...", 
"body" : "を参照してください Robotics_Jogging.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例は、軸グループをジョギングする方法を示しています。 SMC_GroupJog2 POU。 をインストールすることをお勧めします CODESYS Depictor この例では（無料のデモバージョンで十分です）。または、Depictorなしで例を使用するために、対応するコード部分を例から削除することもできます。 " }, 
{ "title" : "応用 ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4584875037158433080105006434", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ ロボットのジョギング \/ 応用 ", 
"snippet" : "可能な限り最も一般的なケースを示すために、この例には次の関数があります。 特異点のあるロボット（6軸多関節ロボット）の使用。この例は、ACSの特異点を介してロボットを移動し、別の構成でデカルトの方法でジョギングを続けることができることを示しています。 ワールド座標系（WCS）に対するロボットの機械座標系（MCS）のシフトと回転。このようにして、MCSとWCSでジョギングがどのように異なるかを確認できます。 フランジ（F）に対してシフトおよび回転したツールの構成。次の図では、ツールと、フランジ（F）に対するTCSのシフトと回転を確認できます。 直線追加軸 Add0 そして回転軸を追加します。 A...", 
"body" : "可能な限り最も一般的なケースを示すために、この例には次の関数があります。 特異点のあるロボット（6軸多関節ロボット）の使用。この例は、ACSの特異点を介してロボットを移動し、別の構成でデカルトの方法でジョギングを続けることができることを示しています。 ワールド座標系（WCS）に対するロボットの機械座標系（MCS）のシフトと回転。このようにして、MCSとWCSでジョギングがどのように異なるかを確認できます。 フランジ（F）に対してシフトおよび回転したツールの構成。次の図では、ツールと、フランジ（F）に対するTCSのシフトと回転を確認できます。 直線追加軸 Add0 そして回転軸を追加します。 Add1 。 " }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4576391101379233081218831739", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ ロボットのジョギング \/ アプリケーションの構造 ", 
"snippet" : "メインプログラム メインプログラム PLC_PRG ステートマシンで構成され、 軸グループをアクティブにします（状態0） ツールを構成します（状態5） MCSを構成します（状態6） ジョギングを開始します（状態10） 状態20では、ジョギングエラーが処理され、移動コマンドが受け入れられます（ 位置へ移動 視覚化のスイッチ)。 その他の状態は、移動 (60、70) の実行と、エラーの処理および確認 (900、1000) に使用されます。 ステートマシンによれば、すべてのロボットPOUと GroupJog2 プログラムは周期的に呼び出され、Depictor での 3D 表示のための計算がいくつか実...", 
"body" : "メインプログラム メインプログラム PLC_PRG ステートマシンで構成され、 軸グループをアクティブにします（状態0） ツールを構成します（状態5） MCSを構成します（状態6） ジョギングを開始します（状態10） 状態20では、ジョギングエラーが処理され、移動コマンドが受け入れられます（ 位置へ移動 視覚化のスイッチ)。 その他の状態は、移動 (60、70) の実行と、エラーの処理および確認 (900、1000) に使用されます。 ステートマシンによれば、すべてのロボットPOUと GroupJog2 プログラムは周期的に呼び出され、Depictor での 3D 表示のための計算がいくつか実行されます。 GroupJog2プログラム このプログラムには、次の手順を実行するステートマシンが含まれています。 状態10では、SMC_GroupJog2の入力が設定され、ロボット軸の構成が読み取られます（SMC_GroupReadActualPosition）。この構成は、軸グループ（SMC_SetKinConfiguration）の状態20で実行されます。 状態30では、システムはジョギング中のエラー、およびジョギングの設定の変更（たとえば、変更された座標系）に反応します。変更がある場合、システムは状態10に戻ります。 状態50は、イネーブル入力の立ち下がりエッジで入力されます。ジョギングはMC_GroupHaltによって停止されます。 " }, 
{ "title" : "試運転 ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4584880854092833081221538291", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ ロボットのジョギング \/ 試運転 ", 
"snippet" : "作成したプログラムをコンパイルして起動します。ビジュアライゼーションを使用してロボットを実行できます。ジョギングに関連するすべての設定を定義できます（たとえば、どの座標系がどの速度でジョギングされるか）。 インストールしている場合 CODESYS Depictor 、次に、Depictorを使用してウィンドウを配置することをお勧めします（ Scene POU）視覚化ウィンドウの横。 Depictorは、ロボットの前面にあるTCS（ツール座標系）を表します。さらに、TCSの現在の回転軸は紫色で表示されます。これは、さまざまなタイプの向きの変化を確認するのに役立ちます（たとえば、 ABC_as_A...", 
"body" : "作成したプログラムをコンパイルして起動します。ビジュアライゼーションを使用してロボットを実行できます。ジョギングに関連するすべての設定を定義できます（たとえば、どの座標系がどの速度でジョギングされるか）。 インストールしている場合 CODESYS Depictor 、次に、Depictorを使用してウィンドウを配置することをお勧めします（ Scene POU）視覚化ウィンドウの横。 Depictorは、ロボットの前面にあるTCS（ツール座標系）を表します。さらに、TCSの現在の回転軸は紫色で表示されます。これは、さまざまなタイプの向きの変化を確認するのに役立ちます（たとえば、 ABC_as_ACS オプションと TCS 座標系）。 " }, 
{ "title" : "運動の中断と継続 ", 
"url" : "_sm_robotics_example_stop_continue.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ 運動の中断と継続 ", 
"snippet" : "の Robotics_Interrupt_Continue.project ここで説明するサンプルプロジェクトは、 CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例では、コマンドされた動作が SMC_GroupInterrupt ファンクションブロックを実行し、後で再開します SMC_GroupContinue ファンクションブロック。軸グループは中断と継続の間の任意の動作を実行できます。...", 
"body" : "の Robotics_Interrupt_Continue.project ここで説明するサンプルプロジェクトは、 CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 この例では、コマンドされた動作が SMC_GroupInterrupt ファンクションブロックを実行し、後で再開します SMC_GroupContinue ファンクションブロック。軸グループは中断と継続の間の任意の動作を実行できます。 " }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_robotics_example_stop_continue.html#UUID-0303b007-363c-c1b9-a999-ee926c8f8deb_section-idm4519127872464034232302809299", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ 運動の中断と継続 \/ アプリケーションの構造 ", 
"snippet" : "アプリケーションは、 PLC_PRG プログラムとトレースにより、状態遷移を簡単に追跡できます。 まず、軸と軸グループが有効になります。( STATE_POWER_ON ） そして、2つの動き、 moveLinearA そして moveLinearB 、ブレンディングで命令されます。（ STATE_START_MOVING ） 2 番目の動作がアクティブになるとすぐに (ブレンディングが開始されると)、動作は中断されます。原因としては、たとえば、ツールの欠陥が検出されたことが考えられます。 (STATE_INTERRUPT ） たとえば、欠陥の後でツールを交換するために、正の Z 方向に相対的...", 
"body" : "アプリケーションは、 PLC_PRG プログラムとトレースにより、状態遷移を簡単に追跡できます。 まず、軸と軸グループが有効になります。( STATE_POWER_ON ） そして、2つの動き、 moveLinearA そして moveLinearB 、ブレンディングで命令されます。（ STATE_START_MOVING ） 2 番目の動作がアクティブになるとすぐに (ブレンディングが開始されると)、動作は中断されます。原因としては、たとえば、ツールの欠陥が検出されたことが考えられます。 (STATE_INTERRUPT ） たとえば、欠陥の後でツールを交換するために、正の Z 方向に相対的な PTP 移動が実行されます。 (STATE_INTERMEDIATE_MOVEMENT ） 再開する前に、システムは元の動きが中断された位置に戻ります。 STATE_GET_CONTINUE_POS \/ STATE_MOVE_TO_CONTINUE_POS ） 本来の動きが再開されます。 (STATE_CONTINUE) " }, 
{ "title" : "使用法 ", 
"url" : "_sm_robotics_example_stop_continue.html#UUID-0303b007-363c-c1b9-a999-ee926c8f8deb_section-idm4586020725065634232302901331", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ 運動の中断と継続 \/ 使用法 ", 
"snippet" : "作成したプログラムをコンパイルしてログインします。さまざまな状態を追跡するには、トレースをコントローラーにダウンロードします。アプリケーションを起動します。...", 
"body" : "作成したプログラムをコンパイルしてログインします。さまざまな状態を追跡するには、トレースをコントローラーにダウンロードします。アプリケーションを起動します。 " }, 
{ "title" : "Pick＆Placeを使用したロボットのプログラミング ", 
"url" : "_sm_example_robotics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ Pick＆Placeを使用したロボットのプログラミング ", 
"snippet" : "を参照してください Robotics_PickAndPlace.project と Robotics_PickAndPlace_without_Depictor.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 The Robotics_PickAndPlace.project プロジェクトには CODESYS Depictor インストールするDepictorパッケージ。このプロジェクトは、運動学を3Dアニメーションで表示します。プロジェクト Robotics_PickAndPlace_...", 
"body" : "を参照してください Robotics_PickAndPlace.project と Robotics_PickAndPlace_without_Depictor.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 The Robotics_PickAndPlace.project プロジェクトには CODESYS Depictor インストールするDepictorパッケージ。このプロジェクトは、運動学を3Dアニメーションで表示します。プロジェクト Robotics_PickAndPlace_without_Depictor.project は、視覚化画面にシーケンスの簡略化された形式を示しています。 この章では、に関連するオブジェクトのみを取り上げます。 SoftMotion 。 この例は、三脚、回転台、およびコンベヤーで構成されています。 キネマティクスは、回転台にあるリングをピックアップします。ピックアップすると、キネマティクスのツールプレートが回転台と同期して移動します。 次に、リングはコンベヤーベルト上にあるコーンに配置されます。配置するとき、キネマティクスはコンベヤーベルトと同期して動きます。 シーケンスを制御するための2つのボタンが視覚化画面にあります。を押すと 自動 ボタンを押すと、リングが自動的に設定されます。それ以外の場合は、 演奏する リングを配置するためのボタンが表示されます。 MC_TrackConveyorBelt と MC_TrackRotaryTable ファンクションブロック The MC_TrackRotaryTable で呼び出される機能ブロック Ring 機能ブロックは、を決定するために使用されます PCS_1 部分座標系。この座標系は、回転台にリングを置いたときに設定されます。 回転台座標系の原点 RotaryTableOrigin 回転台の中点です。 Z軸は回転台の回転軸です。 PCS_1は、入力変数の関数として回転台座標系のZ軸を中心に回転します。 RotaryTable 。軸グループはPCS_1で移動するため、テーブルの回転に従います。 動作はに似ています MC_TrackConveyorBelt で呼び出される機能ブロック Cone ファンクションブロック。この場合、PCS（ PCS_2 ）座標系のX軸に従います ConveyorBeltOrigin 。 " }, 
{ "title" : "ストラクチャ プロジェクトの ", 
"url" : "_sm_example_robotics.html#UUID-39569b76-aa01-d4da-f1dd-395ea28c5771_id_e806d396dc0abefc0a864632a6f2305_id_9645ebb75a1273b0c0a8640e01c9af58", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ Pick＆Placeを使用したロボットのプログラミング \/ ストラクチャ プロジェクトの ", 
"snippet" : "CODESYS SoftMotion コントローラ 軸グループ 三脚 ：軸グループは、運動学と個々の軸へのマッピングを定義します Tripod1 、 Tripod2 、 と Tripod3 。 DepictorCalculations（PRG） 、 環境（PRG） 、 リング（FB） ：完全なシーケンスと視覚化を制御するためのプログラム。これらのPOUは、製品座標系（PCS_1およびPCS_2）の定義を除いて、PLCopenブロックの理解には関係ありません。 ロボット（PRG） ：モーションシーケンスを制御するためのプログラム。詳細な説明は次の段落にあります。 視覚化 ：シーケンスを明確にする...", 
"body" : "CODESYS SoftMotion コントローラ 軸グループ 三脚 ：軸グループは、運動学と個々の軸へのマッピングを定義します Tripod1 、 Tripod2 、 と Tripod3 。 DepictorCalculations（PRG） 、 環境（PRG） 、 リング（FB） ：完全なシーケンスと視覚化を制御するためのプログラム。これらのPOUは、製品座標系（PCS_1およびPCS_2）の定義を除いて、PLCopenブロックの理解には関係ありません。 ロボット（PRG） ：モーションシーケンスを制御するためのプログラム。詳細な説明は次の段落にあります。 視覚化 ：シーケンスを明確にするためのアニメーションによる視覚化。 Tripod1 、 Tripod2 、 Tripode3 ：三脚の直線軸。 DriveRotaryTable ：回転台の軸。 DriveConveyorBelt ：コンベヤーベルトの軸。 " }, 
{ "title" : "ロボット（PRG）シーケンシャルプログラムの構造 ", 
"url" : "_sm_example_robotics.html#UUID-39569b76-aa01-d4da-f1dd-395ea28c5771_id_e806d396dc0abefc0a864632a6f2305_id_d2b72ec95a1273b5c0a8640e012cc527", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ Pick＆Placeを使用したロボットのプログラミング \/ ロボット（PRG）シーケンシャルプログラムの構造 ", 
"snippet" : "NS Robot (PRG) プログラムはサイクルで実行されます。このとき、個々のステップは、 state 。プログラムの終了時に、使用されているすべての機能ブロックの呼び出しは、モーションコマンドの準備ができています。 三脚の単軸が作動します（機能ブロック pwA1 、 pwA2 、 と pwA3 タイプの MC_Power ）。 CASE 0 ：参加軸が動作するのを待ちます。 CASE 10 ：原点復帰位置を設定します。物理的なアプリケーションでは、ホーミングはこの位置で実行されます（機能ブロック spA1 、 spA2 、 と spA3 タイプの MC_SetPosition ）。 CA...", 
"body" : "NS Robot (PRG) プログラムはサイクルで実行されます。このとき、個々のステップは、 state 。プログラムの終了時に、使用されているすべての機能ブロックの呼び出しは、モーションコマンドの準備ができています。 三脚の単軸が作動します（機能ブロック pwA1 、 pwA2 、 と pwA3 タイプの MC_Power ）。 CASE 0 ：参加軸が動作するのを待ちます。 CASE 10 ：原点復帰位置を設定します。物理的なアプリケーションでは、ホーミングはこの位置で実行されます（機能ブロック spA1 、 spA2 、 と spA3 タイプの MC_SetPosition ）。 CASE 20 ：ワールド座標系での機械座標系の配置（機能ブロック setCoord タイプの MC_SetCoordinateTransform ）。 CASE 30 ：軸グループの解除（機能ブロック） enable タイプの MC_GroupEnable 。 軸グループがすべての値を適用したという応答を待ちます。 CASE 40 に CASE 130 ：Pick＆Placeアプリケーション：すべての動きは、おそらく複数のインスタンスで命令されます MC_MoveDirectAbsolute 、 MC_MoveDirectRelative 、 と MC_MoveLinear サイクルで呼び出されます。の立ち上がりエッジ Execute 各ステータスでこれらのPOUを入力すると、新しいモーションコマンドが発行されます。 bCommandAccepted プロセスの成功を示します。コマンドの典型的なチェーンは、次のモーションコマンドの前にこの出力を問い合わせることから生じます。 " }, 
{ "title" : "動的ロボットモデル ", 
"url" : "_sm_dynamic_robot_model.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ 動的ロボットモデル ", 
"snippet" : "を参照してください Robotics_DynamicModel.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . 移動中の軸のトルク\/力を制限するには、現在の軸の状態 (位置、速度、および加速度) からこれらの値を計算する動的モデルが必要です。この例には、次の部分が含まれています。 パート 1 では、既存の動的モデルをアプリケーションで使用する方法と、いくつかのサンプル動作の結果を示します。 パート 2 では、KM Lynch と FC Park の共著「Modern Robotics」に...", 
"body" : "を参照してください Robotics_DynamicModel.project のインストールディレクトリにあるサンプルプロジェクト CODESYS 下 ..\\CODESYS SoftMotion\\Examples . 移動中の軸のトルク\/力を制限するには、現在の軸の状態 (位置、速度、および加速度) からこれらの値を計算する動的モデルが必要です。この例には、次の部分が含まれています。 パート 1 では、既存の動的モデルをアプリケーションで使用する方法と、いくつかのサンプル動作の結果を示します。 パート 2 では、KM Lynch と FC Park の共著「Modern Robotics」に記載されているアルゴリズムに基づいて、SCARA ロボットの動的モデルを作成する方法を説明します。 " }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4640407923376033369958289569", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ 動的ロボットモデル \/ アプリケーションの構造 ", 
"snippet" : "パート 1: アプリケーションでの動的モデルの使用 この部分のコードは、 TorqueLimitationDemo フォルダ。 PLC_PRG テスト動作をトリガーするステートマシンを含むメインプログラムです。 動きは、 Trace 。 パート 2: 動的ロボット モデルの作成 動的モデルのコードは、 DynModel フォルダ。 DynModel_Scara2_Z SCARAロボットの動的モデルです。 DynModel_Tests すべてのテストを実行します Test_DynModel_Scara2_Z よくある間違いをチェックします。 動的モデルは、2 つの回転ジョイントと 1 つの直動 ...", 
"body" : "パート 1: アプリケーションでの動的モデルの使用 この部分のコードは、 TorqueLimitationDemo フォルダ。 PLC_PRG テスト動作をトリガーするステートマシンを含むメインプログラムです。 動きは、 Trace 。 パート 2: 動的ロボット モデルの作成 動的モデルのコードは、 DynModel フォルダ。 DynModel_Scara2_Z SCARAロボットの動的モデルです。 DynModel_Tests すべてのテストを実行します Test_DynModel_Scara2_Z よくある間違いをチェックします。 動的モデルは、2 つの回転ジョイントと 1 つの直動 Z 軸を持つスカラ ロボットに基づいています。動的モデルに必要な寸法と座標系を備えたロボットの図を以下に示します。 図の寸法 関数ブロック DynModel_Scara2_Z のサンプル プロジェクトの対応する変数名 h0 baseHeight h1 armOneHeight h2 armTwoHeight h3 zAxisLength h4 zAxisOffset l1 armOneLength l1 armTwoLength " }, 
{ "title" : "パート 1: アプリケーションでの動的モデルの使用 ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4592064830952033369979173999", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ 動的ロボットモデル \/ パート 1: アプリケーションでの動的モデルの使用 ", 
"snippet" : "アプリケーションで動的モデルを使用するには、 ISMDynamics のインターフェース SM3_Dynamics 図書館。からの動的モデル パート 2: 動的ロボット モデルの作成 がこのデモンストレーションに使用されます。 モデルは、次を使用して軸グループに割り当てることができます SMC_GroupSetDynamics .この手順では、MCS に対する重力加速度を設定する必要があります。この例のスカラは床に取り付けられているため、重力加速度は正の z0 方向を指します。重力加速度は、ユーザー単位 u\/s² で指定する必要があります。この例のすべての長さはユーザー単位 m で定義されてい...", 
"body" : "アプリケーションで動的モデルを使用するには、 ISMDynamics のインターフェース SM3_Dynamics 図書館。からの動的モデル パート 2: 動的ロボット モデルの作成 がこのデモンストレーションに使用されます。 モデルは、次を使用して軸グループに割り当てることができます SMC_GroupSetDynamics .この手順では、MCS に対する重力加速度を設定する必要があります。この例のスカラは床に取り付けられているため、重力加速度は正の z0 方向を指します。重力加速度は、ユーザー単位 u\/s² で指定する必要があります。この例のすべての長さはユーザー単位 m で定義されているため、重力加速度も m\/s² で指定する必要があります。 SMC_ChangeDynamicLimits 各軸の制限を調整するために使用できます。を使用して、軸グループを再度有効にする必要があることに注意してください。 MC_GroupEnable 新しい動的制限をアクティブにするため。 追加の質量が TCP に追加される場合 (たとえば、ロボットによってピックアップされるツールまたはオブジェクト)、 SMC_GroupSetLoad 負荷の定義に使用できます。 の PLC_PRG プログラムには上記のすべてのコンポーネントが含まれており、2 つのテスト動作を実行します。 動き 1 ムーブメント 2 (a0=0°, a1=0°, a2=0 m) から (a0=90°, a1=0°, a2=0.02 m) までのまっすぐな腕の動き: (a0=0°, a1=-120°, a2=0 m) から (a0=90°, a1=-120°, a2=0,02 m) への角度付きアームの動き: 各移動は、次の境界条件で 3 回連続して実行されます。 全軸のトルク制限は無限（無制限）です。 アーム 2 のトルク制限は、無制限移動時の最大到達トルクよりも低い値に設定されています。値は任意に設定されました 2 Nm . アーム 2 のトルク制限はそのままです。 2 Nm 、さらに負荷が TCP に適用されました ( mLoad=3 kg 、 lLoad=0.2 m ): 負荷の慣性計算は、細いロッドを使用することで簡素化されました。 動きはトレースで監視できます。移動 1 の結果は次のとおりです。 アーム 2 は移動 1 で移動しませんが、アーム 1 の移動により加減速時にアーム 2 にトルクが発生します。計算されたトルクはドライブに送信され、コントローラ モードでコントローラ ループを改善できる可能性があります。 SMC_velocity また SMC_position .トルクフィードフォワード制御ともいう。 トルクを制限した 2 回目の実行では、アーム 2 が動かなくても、アーム 2 のトルク制限によってアーム 1 の動きが遅くなることを示しています。動的モデルがなければ、アーム 1 の加速と減速を手動で減らす必要があります。アーム 2 に過度の機械的ストレスがかかるのを防ぐためです。 負荷のある 3 回目の実行では、アーム 2 のトルク制限に違反しないように、アーム 1 の動きをさらに遅くします。 動的モデルを使用する利点は明らかです。動的モデルを使用せずに過度の機械的応力を防止するには: ロボットの現在の状態に応じて、すべての動きの動的制限を設定する必要があります。 または、すべての潜在的な動きがどの軸にも過度の機械的ストレスをもたらさないように、すべての軸の動的制限を減らす必要があります。 最初の方法は複雑なタスクであり、妥当な制限を計算するのが難しい場合があります。一方、2 番目の方法では、ほとんどの場合、動きができるだけ速くなりません。これらの欠点は、動的モデルには存在しなくなりました。これは、ロボットが各軸の機械的制限を尊重しながら常に可能な限り速く動くためです。 これらの利点は、動き 2 の結果によって示されます。 アーム 2 が角度を付けられているため、アーム 2 の結果のトルクは動作 1 よりもかなり低くなります。したがって、3 つの実行すべてが軸トルクによって制限されることはありません。動作 1 に基づいて調整された動的制限を使用した場合 (アーム 2 のトルク制限に違反しないように加速と減速を減らします)、この動作は必要以上に遅くなります。 " }, 
{ "title" : "パート 2: 動的ロボット モデルの作成 ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4583105024958433369980945572", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ 動的ロボットモデル \/ パート 2: 動的ロボット モデルの作成 ", 
"snippet" : "この例で作成されたモデルは、KM Lynch と FC Park による書籍「Modern Robotics」で紹介されているオープン チェーン ロボットのアルゴリズムに基づいています (第 8 章「Dynamics of Open Chains」を参照)。このアルゴリズムの説明は、この例の範囲を超えています。代わりに、この例では、アルゴリズムの入力値を定義する方法に焦点を当てています。 単純化 この例をより理解しやすくするために、いくつかの簡略化が行われています。 腕の長さ l1 と l2 (回転軸間の距離) は、それぞれの合計アーム長として使用されます。 質量の中心は常に各リンクの幾何学的...", 
"body" : "この例で作成されたモデルは、KM Lynch と FC Park による書籍「Modern Robotics」で紹介されているオープン チェーン ロボットのアルゴリズムに基づいています (第 8 章「Dynamics of Open Chains」を参照)。このアルゴリズムの説明は、この例の範囲を超えています。代わりに、この例では、アルゴリズムの入力値を定義する方法に焦点を当てています。 単純化 この例をより理解しやすくするために、いくつかの簡略化が行われています。 腕の長さ l1 と l2 (回転軸間の距離) は、それぞれの合計アーム長として使用されます。 質量の中心は常に各リンクの幾何学的中心に位置します。 アームと Z 軸の空間慣性行列は、細いロッドに対して計算されます。 動的モデルの要件 SoftMotionアプリケーションでダイナミックモデルを使用するには、このモデルは ISMDynamics インターフェースの SM3_Dynamics 図書館。 動的モデルのゼロ位置、座標系、正の回転方向は、理論的には運動学的モデルから逸脱する可能性があります。ただし、これらの違いを考慮する必要があるため、動的モデルを単純化するために、運動学的モデルの定義を使用することをお勧めします。 動的モデルは Nm 単位のトルク値と N 単位の力を計算する必要があるため、長さのユーザー単位 u を SI 単位 m に変換する必要があります。変換係数は、 SMC_GroupSetUnits に含まれており、 addParams の入力 ISMDynamics.AxesStateToTorque .この例では、長さに m のみを使用しているため、変換係数を無視できます。 モデルの形状データと動的データの仕様 KM Lynch と FC Park による書籍「Modern Robotics」で紹介されているアルゴリズムの IEC 実装 (第 8 章「Dynamics of Open Chains」を参照) には、次の入力値が必要です。 ロボットがホームポジションにあるときの各リンクの重心位置。位置は前のリンクの座標系で指定されます (最初のリンクはベース座標系を基準にして指定されます)。 各リンクの空間慣性マトリックスと質量は、それぞれのリンク フレームで表されます。 ベースフレームで表現された各ジョイントのネジ軸。 重心位置 各リンクの重心位置を示すフレームは次のとおりです。 リンク フレーム アーム1 ベース座標系 x で表されるアーム 1 の重心 0 、y 0 、z 0 : x0 軸を中心に 180° 回転していることに注意してください。 アーム 2 アーム 1 の座標系で表される、アーム 2 の重心: Z軸 アーム 2 の座標系で表される Z 軸の重心: 工具中心点 (TCP) Z 軸の座標系で表される、TCP での任意の負荷 (たとえば、ツール、製品、または両方の組み合わせによる) を処理するための 1 つの追加フレーム: 空間慣性行列 空間慣性値は、それぞれのリンク フレームで表現する必要があります。フレームは質量の中心で定義されるため、空間慣性は 3x3 の回転慣性行列と物体の質量で表すことができます。 ジョイントに細いロッドを使用することを簡略化すると、回転慣性マトリックスの成分は次のようになります。 リンク 空間慣性マトリックス アーム1、アーム2 対応する質量を持つアーム 1 とアーム 2 m1 と m2 、および長さ l1 と l2 : Z軸 ねじ軸 すべてのジョイントのねじ軸は、ベース座標系 x を基準にして表現する必要があります 0 、y 0 、z 0 . リンク ねじ軸 アーム1 ターンテーブルがジョイント 1 の周りを正の方向に 1 rad\/s の角速度で回転しているとします。 ベース座標系で表される、これは z を中心とした正の回転です。 0 -右手の法則に従った軸: アーム 1 の回転軸はベース座標系の中心に等しいため、直線速度はゼロです。 アーム 2 再び、次の図のアーム 1 の上面図に示されているように、1 rad\/s の角速度でジョイント 2 の周りを正の方向に回転するターンテーブルを想像してください。 アーム 1 に関しては、角速度は次のとおりです。 図は、結果の線速度 v を示しています。 2,年 、これは負の y を指します 0 方向であり、v に等しい 2,年 =-ω 2,z * l 1 . Z軸 Z 軸は、次の規則が適用されるプリズム軸です。 角速度ベクトル ω はゼロです。 直線速度ベクトルは、正の並進方向の単位ベクトルです。 これにより、ベース座標系 x で表される次のベクトルが得られます。 0 、y 0 、z 0 : テスト すべてのモデル パラメーターが定義されているため、動的モデルをテストできるようになりました。このセクションには、モデルのいくつかの基本的なテストが含まれています。 ねじ軸の確認 ねじ軸 S 角速度 ω と線速度 v の要素として表現できます。 se(3) : 前方変換 T ネジ軸で実行可能 S 、エンド エフェクタ フレーム M ロボットのゼロ位置と関節角度 θ 各関節の: サンプル プロジェクトには、この方程式を解く関数が既に含まれています ( SMC_OpenChainKinematics_SolveForward ）。詳細については、KM Lynch と FC Park による著書「Modern Robotics」を参照してください。 順変換方程式を使用して、既知の軸位置でテストを実行し、変換が期待される結果につながるかどうかを確認できるようになりました。 停止時のトルク計算の確認 質量中心の位置フレームを確認するには、特定の軸位置で停止時の軸トルクを手動で計算し、モデルによって計算された値と比較します。この例は床に取り付けられた SCARA ロボットに基づいているため、停止時のすべての軸位置で、ドライブのトルクまたは力は同じになります。 ジョイント 結果のトルク\/力 アーム1 アーム 1 は回転軸であるため、結果はトルクになります。 M1=0 Nm . アーム 2 アーム 2 は回転軸であるため、結果はトルクになります。 M2=0 Nm . Z軸 Z 軸はプリズム軸であるため、結果は力になります。 F3=m3*g N 重力加速度で g . " }, 
{ "title" : "カスタムキネマティクス ", 
"url" : "_sm_example_custom_robotics_kinematic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ カスタムキネマティクス ", 
"snippet" : "を参照してください PLCopenSingle2.project サンプルプロジェクトと CustomKinematics.library のインストールディレクトリにあるライブラリ CODESYS 下 ..\\CODESYS SoftMotion\\Examples. この例では、カスタムのキネマティック変換を使用してライブラリを作成する方法について説明します ( Gantry3C ) と、このライブラリをプロジェクトで使用してロボットを制御する方法も紹介しています。 ザ・ Gantry3C キネマティック・トランスフォーメーションは、ツールヘッドを搭載した 3 つの直線軸 (X、Y、Z) で構...", 
"body" : "を参照してください PLCopenSingle2.project サンプルプロジェクトと CustomKinematics.library のインストールディレクトリにあるライブラリ CODESYS 下 ..\\CODESYS SoftMotion\\Examples. この例では、カスタムのキネマティック変換を使用してライブラリを作成する方法について説明します ( Gantry3C ) と、このライブラリをプロジェクトで使用してロボットを制御する方法も紹介しています。 ザ・ Gantry3C キネマティック・トランスフォーメーションは、ツールヘッドを搭載した 3 つの直線軸 (X、Y、Z) で構成されています。ツールヘッドは、取り付けられた工具を支える余分な軸で構成されています。ツールヘッドは Z 軸を中心に回転できます。 " }, 
{ "title" : "1.新しいライブラリプロジェクトを作成します ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_3b0657d06b6990f1c0a8646379b25f1e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ カスタムキネマティクス \/ 1.新しいライブラリプロジェクトを作成します ", 
"snippet" : "で新しいプロジェクトを作成します 空のライブラリ レンプレート。...", 
"body" : "で新しいプロジェクトを作成します 空のライブラリ レンプレート。 " }, 
{ "title" : "2.ライブラリマネージャーを追加します。 ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_0125d98b6b6990f1c0a8646339c29917", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ カスタムキネマティクス \/ 2.ライブラリマネージャーを追加します。 ", 
"snippet" : "ライブラリマネージャーを追加する POU（発注書） ビュー。追加 SM3_Transformation 、 SM3_Math 、 そして SM3_Error ライブラリをライブラリ マネージャーに追加します。...", 
"body" : "ライブラリマネージャーを追加する POU（発注書） ビュー。追加 SM3_Transformation 、 SM3_Math 、 そして SM3_Error ライブラリをライブラリ マネージャーに追加します。 " }, 
{ "title" : "3.Gantry3C機能ブロックを作成します。 ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_b156dbec6b6990f1c0a86463322b661a", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ カスタムキネマティクス \/ 3.Gantry3C機能ブロックを作成します。 ", 
"snippet" : "この機能ブロックはインターフェースを実装します MC_KIN_REF_SM3 と ISMKinematicsWithInfo2 図書館から SM3_Transformation 。各軸の入力としてオフセットを定義できます。このオフセットは、順変換の前に減算され、逆変換の後に加算されます。 の例 Gantry3C 2つの分離された運動学と KinCoupled ： FUNCTION_BLOCK Custom_Kin_Gantry3 IMPLEMENTS ISMPositionKinematics FUNCTION_BLOCK Custom_Kin_CAxis IMPLEMENTS ISMOrie...", 
"body" : "この機能ブロックはインターフェースを実装します MC_KIN_REF_SM3 と ISMKinematicsWithInfo2 図書館から SM3_Transformation 。各軸の入力としてオフセットを定義できます。このオフセットは、順変換の前に減算され、逆変換の後に加算されます。 の例 Gantry3C 2つの分離された運動学と KinCoupled ： FUNCTION_BLOCK Custom_Kin_Gantry3 IMPLEMENTS ISMPositionKinematics\nFUNCTION_BLOCK Custom_Kin_CAxis IMPLEMENTS ISMOrientationKinematics\n\nFUNCTION_BLOCK Custom_Kin_Gantry3C EXTENDS Kin_Coupled 機能ブロックを提供する Custom_Kin_Gantry3 と Custom_Kin_CAxis 機能ブロックの入力として Kin_Coupled 初期化中。今 Custom_Kin_Gantry3C 位置と方向のキネマティクスを組み合わせた結合キネマティクスになります。 " }, 
{ "title" : "4.MC_KIN_REF_SM3インターフェイスとNumAxes4プロパティのメソッドを実装します。 ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_f0953a666b6990f1c0a864632a54ddd5", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ カスタムキネマティクス \/ 4.MC_KIN_REF_SM3インターフェイスとNumAxes4プロパティのメソッドを実装します。 ", 
"snippet" : "AxesToCartesian ：順運動学：軸の値から位置と方向を計算します。 CartesianToAxes ：逆運動学：位置と方向からの軸値の計算。 NumAxes ：キネマティクスの軸数...", 
"body" : "AxesToCartesian ：順運動学：軸の値から位置と方向を計算します。 CartesianToAxes ：逆運動学：位置と方向からの軸値の計算。 NumAxes ：キネマティクスの軸数 " }, 
{ "title" : "5.ISMKinematicsWithInfo2およびISMKinematicsWithInfoインターフェイスのメソッドを実装します。 ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_cd5f17f76b6990f1c0a86463705dcfa1", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ カスタムキネマティクス \/ 5.ISMKinematicsWithInfo2およびISMKinematicsWithInfoインターフェイスのメソッドを実装します。 ", 
"snippet" : "GetAxisProperties ：軸のタイプなどのプロパティ。各軸の制限を定義できます。 GetKinematicsName ：キネマティクスの名前 IsSingularity ：このキネマティクスでは無視できます...", 
"body" : "GetAxisProperties ：軸のタイプなどのプロパティ。各軸の制限を定義できます。 GetKinematicsName ：キネマティクスの名前 IsSingularity ：このキネマティクスでは無視できます " }, 
{ "title" : "6.プロジェクト情報を指定します。 ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_2f5ca72b6b6990f1c0a864634f9c8dd7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ カスタムキネマティクス \/ 6.プロジェクト情報を指定します。 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "7.ライブラリでコンパイラエラーを確認します。 ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_24eaad936b6990f1c0a864633896924b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ カスタムキネマティクス \/ 7.ライブラリでコンパイラエラーを確認します。 ", 
"snippet" : "ライブラリを確認するには、 建てる → すべてのプールオブジェクトをチェック 。...", 
"body" : "ライブラリを確認するには、 建てる → すべてのプールオブジェクトをチェック 。 " }, 
{ "title" : "8.軸グループコンフィギュレータで説明を作成します。 ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_51fd948a6c11885ac0a8646354b16b84", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ カスタムキネマティクス \/ 8.軸グループコンフィギュレータで説明を作成します。 ", 
"snippet" : "ディスクリプションを作成するには、まず、をインストールする必要があります。 CODESYS Library Documentation Support アドオン。このアドオンには、以下の手順で必要な libdoc.exe プログラムが含まれています アドオンは以下からインストールできます CODESYS Installer 。 POUに属性がある場合 sm_kin_libdoc 、機能ブロックで指定されたコメントは、キネマティクスの説明として軸グループコンフィギュレータで使用されます。これには、再構築されたテキストフォーマットが使用されます。 軸グループエディタの機能ブロックコメントからキネマ...", 
"body" : "ディスクリプションを作成するには、まず、をインストールする必要があります。 CODESYS Library Documentation Support アドオン。このアドオンには、以下の手順で必要な libdoc.exe プログラムが含まれています アドオンは以下からインストールできます CODESYS Installer 。 POUに属性がある場合 sm_kin_libdoc 、機能ブロックで指定されたコメントは、キネマティクスの説明として軸グループコンフィギュレータで使用されます。これには、再構築されたテキストフォーマットが使用されます。 軸グループエディタの機能ブロックコメントからキネマティクスの説明を生成するには、次の手順に従います。 属性を含める sm_kin_libdoc 上の画像に示すように。 必要なプロジェクトプロパティを含める DocFormat と DocLanguages （プロジェクト情報ダイアログ内）ライブラリのドキュメントに関連しています。 結果： のインストールディレクトリが CODESYS が含まれています libdoc.exe 実行可能ファイル（ディレクトリ： ...\\DocScripting\\3.5.xx.0 \\）。 バージョン0.12.5以下の32ビットwkhtmltoxコンバーターをからダウンロードします。 https:\/\/wkhtmltopdf.org\/downloads.html 。を抽出します wkhtmltox.dll ファイルしてコピーします ...\\\\DocScripting\\\\3.5.xx.0\\\\bin の中に CODESYS インストールディレクトリ。 以来 wkhtmltox.dll バージョン0.12.6以降では、デフォルトでイメージをサポートしなくなりました。バージョン0.12.5以下を使用する必要があります。 システム変数を作成します LIBDOC_CODESYS Windowsで。のファイルパスに値を設定します CODESYS.exe 。パス名とプロファイル名は必ず二重引用符で囲んで指定してください。 結果： ライブラリプロジェクトを保存して閉じ、再度開きます。 クリック ファイル→プロジェクトをコンパイル済みライブラリとして保存 。 コンパイルされたライブラリは、このキネマティクスを使用するプロジェクトにインストールされます。 " }, 
{ "title" : "プロジェクトでのライブラリの使用（CustomKinematics_Implementation.project） ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_3c747e2a6b6990f1c0a864637a72fb84", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ カスタムキネマティクス \/ プロジェクトでのライブラリの使用（CustomKinematics_Implementation.project） ", 
"snippet" : "このプロジェクトは、前のセクションで作成したキネマティクスを使用して、ジョギングまたは動きを命令することによって制御する方法を示しています。 作成する CODESYS との標準プロジェクト CODESYS SoftMotion Win コントローラ。 ライブラリマネージャーを開き、ライブラリをインストールします CustomKinematics.compiled-library （前のセクションで作成）キネマティクスGantry3Cが含まれています。ライブラリをライブラリマネージャーに追加します。 軸グループオブジェクトを追加し、 KinCustom.Gantry3C キネマティクス。 結果：...", 
"body" : "このプロジェクトは、前のセクションで作成したキネマティクスを使用して、ジョギングまたは動きを命令することによって制御する方法を示しています。 作成する CODESYS との標準プロジェクト CODESYS SoftMotion Win コントローラ。 ライブラリマネージャーを開き、ライブラリをインストールします CustomKinematics.compiled-library （前のセクションで作成）キネマティクスGantry3Cが含まれています。ライブラリをライブラリマネージャーに追加します。 軸グループオブジェクトを追加し、 KinCustom.Gantry3C キネマティクス。 結果： 4つの仮想軸をに追加します SoftMotion一般軸プール デバイスツリーの軸プール。 （DriveX、Y、Z、およびC） 軸グループコンフィギュレータを開きます。の中に 軸へのマッピング セクションで、軸をそれぞれのフィールドにマップします。 結果： プログラム Prg_Visu 軸グループを制御するメインプログラムです。アプリケーションが起動すると、 Prg_Visu 軸グループの電源を入れて有効にします。さらに、軸グループ（ジョギング、線形およびPTPの動き）を制御するために必要なすべての機能ブロックを呼び出します。これらの動きはすべて、添付のビジュアライゼーションから制御できます。 結果： 機能ブロック: Jog : このFBは軸空間と直交座標空間でのジョギングを組み合わせます。 SMC_GroupJog2 1つは軸空間用、もう1つは直交空間用です。この関数ブロックは視覚化テンプレートで使用できます。 V_ロボット位置軸 そして V_ロボット位置_カート_ジョグ 直交座標と軸空間で任意の運動学をジョグします。 結果： FB SMC_TRAFOF_Gantry3C ：この機能ブロックは、Gantry3Cキネマティクスの入力軸値をそれぞれのTCP値に変換します。さらに、軸の値は、視覚化テンプレートで使用できるように正規化されています TRAFOF_Gantry3C_YZ 運動学の動きを視覚化する。 結果： アプリケーションをコンパイルして実行します。ビジュアライゼーションを開きます。軸空間とデカルト空間でロボットをジョギングできます。線形またはPTPの動きを命令するための視覚化テンプレートもあります。 結果： ここで説明する例では、一般的な機能ブロックの位置決め軸と方向軸について説明します。多くのキネマティクスは、2つの分離された部分キネマティクスで構成できます。1つはポジショニングキネマティクス（デルタ、ガントリーなど）、もう1つはオリエンテーションキネマティクス（C軸、Wrist2、Wrist3などのツール）です。両方のキネマティクスは、ポジショニングキネマティクスのTCPである「フランジポイント」で相互に接続されています。配向運動学は、フランジ点から結合運動学のTCPまでのベクトルを計算できるという事実によって特徴付けられます。計算は、このTCPの方向のみを使用して行われます（つまり、位置決めの運動学に依存しないか、フランジポイントの方向に依存しません）。次に、位置決め運動学は、フランジポイントの位置のみからその軸位置を決定できなければなりません。フランジポイントの方向に依存してはなりません。 この場合、次のようなインターフェースを利用できます。 ISMPositionKinematics または ISMOrientationKinematics これらのインターフェースを実装するには、実装する関数ブロックを1つ定義します。 ISMPositionKinematics そして実装する別の機能ブロック ISMOrientationKinematics 最後に、関数ブロックを拡張する関数ブロックを定義します。 Kin_Coupled （から SM3_Transformation ) を、以前に定義した機能ブロックを入力として使用します。 詳細については、以下を参照してください。 カスタムキネマティクスの作成" }, 
{ "title" : "Depictorを使用して軸グループを視覚化する ", 
"url" : "_sm_example_axis_group_depictor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ Depictorを使用して軸グループを視覚化する ", 
"snippet" : "このプロジェクトでは、 CODESYS Depictor 有効なライセンスを持つアドオン。 SoftMotionアプリケーションは、軸グループとして構成された4つのロータリードライブで構成されています。最初の3つの軸はTCPをX \/ Y平面で移動し、4番目の軸はZ平面で移動します。 この例は、Kin_Scara3_Zキネマティック構成でDepictorを使用する方法を示しています。他のキネマティック構成に対して同じ手順をカスタマイズすることもできます。 プログラムの開始とテスト プロジェクトの視覚化で軸の値を変更できます。アクティブな移動コマンドをコメントアウトした場合（ MoveAbs......", 
"body" : "このプロジェクトでは、 CODESYS Depictor 有効なライセンスを持つアドオン。 SoftMotionアプリケーションは、軸グループとして構成された4つのロータリードライブで構成されています。最初の3つの軸はTCPをX \/ Y平面で移動し、4番目の軸はZ平面で移動します。 この例は、Kin_Scara3_Zキネマティック構成でDepictorを使用する方法を示しています。他のキネマティック構成に対して同じ手順をカスタマイズすることもできます。 プログラムの開始とテスト プロジェクトの視覚化で軸の値を変更できます。アクティブな移動コマンドをコメントアウトした場合（ MoveAbs... 、...）プログラム内 PLC_PRG 2番目の移動コマンドのコメントを削除すると、デカルト座標を変更できます。 プロジェクトをビルドし、PLCにダウンロードします。 プロジェクトでDepictorオブジェクトのエディターを開きます。 ビジュアライゼーションに切り替えて、軸の値またはデカルト値を変更します。 Depictorでスカラロボットの動きを観察します。 " }, 
{ "title" : "標準プロジェクトの作成 ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a87f67372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ Depictorを使用して軸グループを視覚化する \/ 標準プロジェクトの作成 ", 
"snippet" : "を使用して標準プロジェクトを作成します CODESYS SoftMotion Win コントローラとSTプログラミング言語。 にライブラリマネージャーを追加します POU 見る。 ライブラリマネージャーを開き、ライブラリを追加します SM3_Depictor と DepictorBase 。...", 
"body" : "を使用して標準プロジェクトを作成します CODESYS SoftMotion Win コントローラとSTプログラミング言語。 にライブラリマネージャーを追加します POU 見る。 ライブラリマネージャーを開き、ライブラリを追加します SM3_Depictor と DepictorBase 。 " }, 
{ "title" : "軸の追加とパラメータ化 ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a65c81372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ Depictorを使用して軸グループを視覚化する \/ 軸の追加とパラメータ化 ", 
"snippet" : "オブジェクトの下に4つの仮想軸を挿入します SoftMotion一般軸プール 軸にDrive1 ... Drive4という名前を付けます。 軸ドライブ1、ドライブ2、ドライブ3、およびドライブ4を軸タイプとしてパラメータ化します 有限の ソフトウェアエンドスイッチを使用して-180度から180度に切り替えます。 構成エディター： 詳細については、以下を参照してください。 仮想ドライブ...", 
"body" : "オブジェクトの下に4つの仮想軸を挿入します SoftMotion一般軸プール 軸にDrive1 ... Drive4という名前を付けます。 軸ドライブ1、ドライブ2、ドライブ3、およびドライブ4を軸タイプとしてパラメータ化します 有限の ソフトウェアエンドスイッチを使用して-180度から180度に切り替えます。 構成エディター： 詳細については、以下を参照してください。 仮想ドライブ" }, 
{ "title" : "軸グループの構成 ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a5e750372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ Depictorを使用して軸グループを視覚化する \/ 軸グループの構成 ", 
"snippet" : "アプリケーションの下に「KinScara」軸グループを追加します。これを行うには、をクリックします プロジェクト→オブジェクトの追加→軸グループ 。 構成要素で、をクリックします キネマティクスを選択 。を選択 TRAFO.Kin_Scara3_Z キネマティクス。 パラメータを次のように定義します。 dArmLength1 、 dArmLength2 、 dArmLength3 ：500 dOffsetA1 、 dOffsetA2 、 dOffsetA3 、 dOffsetZ ：0 次のように軸を注文します。 A1 ：Drive1 A2 ：Drive2 A3 ：Drive3 Z ：Drive...", 
"body" : "アプリケーションの下に「KinScara」軸グループを追加します。これを行うには、をクリックします プロジェクト→オブジェクトの追加→軸グループ 。 構成要素で、をクリックします キネマティクスを選択 。を選択 TRAFO.Kin_Scara3_Z キネマティクス。 パラメータを次のように定義します。 dArmLength1 、 dArmLength2 、 dArmLength3 ：500 dOffsetA1 、 dOffsetA2 、 dOffsetA3 、 dOffsetZ ：0 次のように軸を注文します。 A1 ：Drive1 A2 ：Drive2 A3 ：Drive3 Z ：Drive4 注：軸を入力フィールドに直接ドラッグできます。 詳細については、以下を参照してください。 運動学" }, 
{ "title" : "コントローラプログラムの作成 ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_26c321018be5c522c0a864636ae45467", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ Depictorを使用して軸グループを視覚化する \/ コントローラプログラムの作成 ", 
"snippet" : "の中に PLC_PRG プログラム、インスタンスを宣言します MC_Power すべてのドライブの機能ブロック。を作成します istate ステートチャートの変数。 VAR Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 : MC_Power; istate: INT; END_VAR 実装でステートチャートを定義します。 CASE istate OF 0: 1: 2: END_CASE 状態のすべてのドライブをアクティブ化する 0 。 0: Power_Drive1(Axis:=Drive1, Enable:=TRUE, bReg...", 
"body" : "の中に PLC_PRG プログラム、インスタンスを宣言します MC_Power すべてのドライブの機能ブロック。を作成します istate ステートチャートの変数。 VAR\n Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 : MC_Power;\n istate: INT;\nEND_VAR 実装でステートチャートを定義します。 CASE istate OF\n 0:\n 1:\n 2:\nEND_CASE 状態のすべてのドライブをアクティブ化する 0 。 0:\n Power_Drive1(Axis:=Drive1, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive2(Axis:=Drive2, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive3(Axis:=Drive3, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive4(Axis:=Drive4, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n IF Power_Drive1.Status AND Power_Drive2.Status AND Power_Drive3.Status AND Power_Drive4.Status THEN\n istate:=istate+1;\n END_IF 軸がアクティブになったら、軸グループを有効にします（「非アクティブ」から「スタンバイ」に切り替えます）。 VAR\n GroupEnable:MC_GroupEnable;\nEND_VAR\n\n1:\n GroupEnable(AxisGroup:=KinScara, Execute:=TRUE);\n IF GroupEnable.Done THEN\n istate:=istate+1;\n END_IF 変数を宣言して初期化し、設定値を機械座標に保存します。タイプの2つのインスタンスを宣言します SMC_POS_REF TCPをデカルト座標と軸座標で表します。 VAR\n Frame: MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & orientation of the TCP\n Pos_Cart: SMC_POS_REF; \/\/ This variable represents the position of the TCP in cartesian coordinates coordinates\n Pos_Axis: SMC_POS_REF := (a := axispos);\/\/ This variable represents the position of the TCP in Axis coordinates\nEND_VAR\nVAR CONSTANT\n axispos: TRAFO.AXISPOS_REF := (a0 := 0, a1 := 100, a2:=60);\nEND_VAR\n\n2:\n Pos_Cart.c:= Frame; \/\/ To represent the TCP in cartesian coordinates; のインスタンスを宣言します MC_MoveDirectAbsolute スカラロボットを指定の座標に移動します。 VAR\n MoveAbs:MC_MoveDirectAbsolute; \/\/ Moves the TCP to the defined coordinates\nEND_VAR\n\n2:\n MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Axis,CoordSystem:=SMC_COORD_SYSTEM.ACS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined Axis coordinates\n \/\/MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Cart,CoordSystem:=SMC_COORD_SYSTEM.MCS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined cartesian coordinates\n\n IF MoveAbs.Done THEN\n MoveAbs(AxisGroup:=KinScara, Execute:=FALSE); \/\/ Waits for the next new coordinates\n istate:=2;\n END_IF タイプの変数を宣言します SMC_GroupReadSetPosition デカルト座標と軸座標でロボットの現在の値を読み取ります。 VAR\n Car_pos, Axis_pos :SMC_GroupReadSetPosition; \/\/to read the current axis values\nEND_VAR\n\n2:\n Car_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.MCS, Enable:=TRUE); \/\/ to read the current position in cartesian coordinates\n Axis_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.ACS, Enable:=TRUE); \/\/ to read the current axis values " }, 
{ "title" : "PLC_PRGプログラム全体 ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a5721f372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ Depictorを使用して軸グループを視覚化する \/ PLC_PRGプログラム全体 ", 
"snippet" : "プログラムを比較し、不足しているプログラム部分を追加します。 宣言 PROGRAM PLC_PRG VAR Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 :MC_Power; istate: INT; GroupEnable:MC_GroupEnable; Frame:MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & orientation of the TCP Pos_Cart:SMC_POS_REF; \/\/ Thi...", 
"body" : "プログラムを比較し、不足しているプログラム部分を追加します。 宣言 PROGRAM PLC_PRG\nVAR\n Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 :MC_Power;\n istate: INT;\n\n GroupEnable:MC_GroupEnable;\n\n Frame:MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & orientation of the TCP\n Pos_Cart:SMC_POS_REF; \/\/ This variable represents the position of the TCP in cartesian coordinates coordinates\n Pos_Axis:SMC_POS_REF := (a := axispos);\/\/ This variable represents the position of the TCP in Axis coordinates\n\n MoveAbs:MC_MoveDirectAbsolute; \/\/ Moves the TCP to the defined coordinates (PTP)\n\n Car_pos,Axis_pos :SMC_GroupReadSetPosition; \/\/to read the current position of the TCP in Cartesian and Axis Coordinates and display it on the visu\n\n scara_Config:trafo.Kin_Scara3_Z_Config; \/\/ To set the configuration of the SCARA_3_Z\n kin_Config:SMC_SetKinConfiguration; \/\/ To set the defined configuration of SCARA_3_Z to the axis group used\n nPeriod:DINT:=0; \/\/ SCARA_3_Z Period\n Xelbow:BOOL:=TRUE;\n\nEND_VAR\nVAR CONSTANT\n axispos : TRAFO.AXISPOS_REF := (a0 := 0, a1 := 100, a2:=60);\nEND_VAR 実装 CASE istate OF\n\n0:\n Power_Drive1(Axis:=Drive1, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive2(Axis:=Drive2, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive3(Axis:=Drive3, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive4(Axis:=Drive4, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n\n IF Power_Drive1.Status AND Power_Drive2.Status AND Power_Drive3.Status AND Power_Drive4.Status THEN\n istate:=istate+1;\n END_IF\n\n1:\n GroupEnable(AxisGroup:=KinScara, Execute:=TRUE);\n\n IF GroupEnable.Done THEN\n istate:=istate+1;\n END_IF\n\n2:\n scara_Config(xElbowRight:=Xelbow, nPeriodA3:=nPeriod);\n kin_Config(AxisGroup:=KinScara,ConfigData:=scara_Config.Config, Execute:=TRUE);\n Pos_Cart.c:=Frame; \/\/ To represent the TCP in cartesian coordinates\n\n Car_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.MCS, Enable:=TRUE); \/\/ read the current position in cartesian coordinates\n Axis_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.ACS, Enable:=TRUE); \/\/ read the current position in Axis coordinates\n\n MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Axis,CoordSystem:=SMC_COORD_SYSTEM.ACS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined axis coordinates\n \/\/MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Cart,CoordSystem:=SMC_COORD_SYSTEM.MCS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined cartesian coordinates\n\n IF MoveAbs.Done THEN\n MoveAbs(AxisGroup:=KinScara, Execute:=FALSE); \/\/ Waits for the next new coordinates\n istate:=2;\n END_IF\nEND_CASE " }, 
{ "title" : "Depictorプログラムの作成 ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_8f044cf9373811e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ Depictorを使用して軸グループを視覚化する \/ Depictorプログラムの作成 ", 
"snippet" : "アプリケーションの下に「プログラム」タイプの新しい「Depic」POUを追加します。これを行うには、をクリックします プロジェクト→オブジェクトの追加→POU 。 タイプの変数を宣言します SM3_Depictor.SMC_R_Scara3_Z_Data 。変数を宣言する LrSize タイプの LREAL 変数を値100で初期化します。 VAR ScaraTrafo : SM3_Depictor.SMC_R_Scara3_Z_Data; LrSize:LREAL:=100; END_VAR 実装に関数ブロックへの呼び出しを挿入します。 ScaraTrafo(AxisGroup:=KinSca...", 
"body" : "アプリケーションの下に「プログラム」タイプの新しい「Depic」POUを追加します。これを行うには、をクリックします プロジェクト→オブジェクトの追加→POU 。 タイプの変数を宣言します SM3_Depictor.SMC_R_Scara3_Z_Data 。変数を宣言する LrSize タイプの LREAL 変数を値100で初期化します。 VAR\n ScaraTrafo : SM3_Depictor.SMC_R_Scara3_Z_Data;\n LrSize:LREAL:=100;\nEND_VAR 実装に関数ブロックへの呼び出しを挿入します。 ScaraTrafo(AxisGroup:=KinScara, trf:=KinScara.trafo); 「Depic」POUをに追加します 主な任務 。 " }, 
{ "title" : "Depictorの構成 ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a523fe372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ Depictorを使用して軸グループを視覚化する \/ Depictorの構成 ", 
"snippet" : "アプリケーションの下に「Depictor」オブジェクトを追加します。これを行うには、をクリックします プロジェクト→オブジェクトの追加→デピクター 。 オブジェクトをダブルクリックします。 を選択 ポーズ Depictorツリーの要素。 クリック 描写者→要素を追加 。 NS 箱 ポーズの下に要素が追加されます。 を選択 DepictorRef。 要素のプロパティのオプション。 クリック ボタン。 を選択 SMC_R_Depictor_Scara3_Z からのオブジェクト SM3_Depictor 図書館。 インターフェイス変数を次のように定義します。 fb ：Depic.ScaraTrafo...", 
"body" : "アプリケーションの下に「Depictor」オブジェクトを追加します。これを行うには、をクリックします プロジェクト→オブジェクトの追加→デピクター 。 オブジェクトをダブルクリックします。 を選択 ポーズ Depictorツリーの要素。 クリック 描写者→要素を追加 。 NS 箱 ポーズの下に要素が追加されます。 を選択 DepictorRef。 要素のプロパティのオプション。 クリック ボタン。 を選択 SMC_R_Depictor_Scara3_Z からのオブジェクト SM3_Depictor 図書館。 インターフェイス変数を次のように定義します。 fb ：Depic.ScaraTrafo lrZ_ ：Drive1.fSetPosition lrZmin ：10 lrZmax ：-50 lrSize ：Depic.LrSize xShowPlane ：0 " }, 
{ "title" : "ビジュアライゼーションの作成 ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a460ad372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ Depictorを使用して軸グループを視覚化する \/ ビジュアライゼーションの作成 ", 
"snippet" : "デカルト座標と軸座標を表示および変更できる視覚化画面を作成します。 アプリケーションの下に「視覚化」オブジェクトを追加します。これを行うには、をクリックします プロジェクト→オブジェクトの追加→視覚化 。 エディターでビジュアライゼーションを開きます。 を挿入します 矩形 視覚化要素（1）。 要素のプロパティを変更します。 テキスト→テキスト ： ％NS テキスト変数→テキスト変数 ： PLC_PRG.Car_pos.Position.c.X 入力設定→OnMouseDown→変数の書き込み 入力方式 ： VisuDialogs.Numpad 別の変数を使用する ： PLC_PRG.Frame...", 
"body" : "デカルト座標と軸座標を表示および変更できる視覚化画面を作成します。 アプリケーションの下に「視覚化」オブジェクトを追加します。これを行うには、をクリックします プロジェクト→オブジェクトの追加→視覚化 。 エディターでビジュアライゼーションを開きます。 を挿入します 矩形 視覚化要素（1）。 要素のプロパティを変更します。 テキスト→テキスト ： ％NS テキスト変数→テキスト変数 ： PLC_PRG.Car_pos.Position.c.X 入力設定→OnMouseDown→変数の書き込み 入力方式 ： VisuDialogs.Numpad 別の変数を使用する ： PLC_PRG.Frame.X 他を挿入します 箱 視覚化要素。 要素（2）と（3）のプロパティを変更します。 テキスト→テキスト ： ％NS テキスト変数→テキスト変数 ： PLC_PRG.Car_pos.Position.c.Y また PLC_PRG.Car_pos.Position.c.Z 入力設定→OnMouseDown→変数の書き込み 入力方式 ： VisuDialogs.Numpad 別の変数を使用する ： PLC_PRG.Frame.Y と PLC_PRG.Frame.Z 要素（4）、（5）、および（6）のプロパティを変更します。 テキスト→テキスト ： ％NS テキスト変数→テキスト変数 ： PLC_PRG.Frame.A また PLC_PRG.Frame.B また PLC_PRG.Frame.C 要素（7）、（8）、（9）、および（10）のプロパティを変更します。 テキスト→テキスト ： ％NS テキスト変数→テキスト変数 ： PLC_PRG.Axis_pos.Position.a.a0 また PLC_PRG.Axis_pos.Position.a.a1 また PLC_PRG.Axis_pos.Position.a.a2 また PLC_PRG.Axis_pos.Position.a.a3 入力設定→OnMouseDown→変数の書き込み 入力方式 ： VisuDialogs.Numpad 別の変数を使用する ： PLC_PRG.Pos_Axis.a.a0 と PLC_PRG.Pos_Axis.a.a1 と PLC_PRG.Pos_Axis.a.a2 と PLC_PRG.Pos_Axis.a.a3 視覚化要素にラベルを付けます ラベル エレメント。 " }, 
{ "title" : "トリガーの例 1: 簡単な例 ", 
"url" : "_sm_example_digital_switches1.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ トリガーの例 1: 簡単な例 ", 
"snippet" : "の Robotics_Trigger.project ここで説明するサンプル プロジェクトは、次のインストール ディレクトリにあります。 CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 トリガは、軸グループが指令されたパス上の特定の点にいつ到達するかを正確に知るために使用されます。この情報は、たとえば、正確なタイミングでツールをオンまたはオフにするために使用できます。この例では、単一のトリガーが動作でどのように指令され、周期的に読み取られるかを示します。これに基づいて、 トリガー例2：接着工程 プロジェクトは現実的なサンプル アプリケーションを示しています...", 
"body" : "の Robotics_Trigger.project ここで説明するサンプル プロジェクトは、次のインストール ディレクトリにあります。 CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 トリガは、軸グループが指令されたパス上の特定の点にいつ到達するかを正確に知るために使用されます。この情報は、たとえば、正確なタイミングでツールをオンまたはオフにするために使用できます。この例では、単一のトリガーが動作でどのように指令され、周期的に読み取られるかを示します。これに基づいて、 トリガー例2：接着工程 プロジェクトは現実的なサンプル アプリケーションを示しています。 " }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_example_digital_switches1.html#UUID-69fc12d0-622f-ba4d-33ec-32604b337f95_section-idm4609369968113633803655575311", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ トリガーの例 1: 簡単な例 \/ アプリケーションの構造 ", 
"snippet" : "このアプリケーションは2つのプログラムで構成されています。 Main_PRG バスタスクで実行され、 Planning_PRG 軸グループ計画タスクで実行されています。また、トレースもあります。 メイン_PRG : の Main_PRG プログラムにはアプリケーションのメイン ステート マシンが含まれています。最初の 2 つの状態は、ドライブと軸グループを初期化し、スイッチをオンにするために使用されます。の中に STATE_COMMAND_MOVEMENT_WITH_TRIGGER 状態では、まずインスタンスを使用してトリガーが準備されます。 SMC_GroupPrepareTrigger フ...", 
"body" : "このアプリケーションは2つのプログラムで構成されています。 Main_PRG バスタスクで実行され、 Planning_PRG 軸グループ計画タスクで実行されています。また、トレースもあります。 メイン_PRG : の Main_PRG プログラムにはアプリケーションのメイン ステート マシンが含まれています。最初の 2 つの状態は、ドライブと軸グループを初期化し、スイッチをオンにするために使用されます。の中に STATE_COMMAND_MOVEMENT_WITH_TRIGGER 状態では、まずインスタンスを使用してトリガーが準備されます。 SMC_GroupPrepareTrigger ファンクションブロック。位置は 0.6 の値で相対的に指定されます。その結果、割り当てられた動作の 60% が完了した時点でトリガーが配置されます。準備されたトリガーは、次のコマンド動作に割り当てられます。この例では、位置 (X=20、Y=10) への直線移動がコマンドによって命令されます。 MC_MoveLinearAbsolute 。 prepTrigger.PositionType := SMC_TriggerPositionType.MvtRelative;\nprepTrigger.Position.MvtPosition := 0.6;\nprepTrigger(AxisGroup:= AxisGroup, Execute:= TRUE);\n \nmoveLinear(AxisGroup:= AxisGroup, Execute:= prepTrigger.Prepared); 次の状態では STATE_ENABLE_READ_TRIGGER 、のインスタンス SMC_GroupReadTrigger コマンドされたトリガーの状態を読み取るために開始されます。トリガーへのリンクは、 TriggerId によって返されました SMC_GroupPrepareTrigger 。 readTrigger.TriggerId := prepTrigger.TriggerId;\nreadTrigger.Enable := TRUE; の中に STATE_CHECK_TRIGGER 状態に応じて、トリガーのステータスが最終的に周期的にチェックされます。出来るだけ早く SMC_GroupReadTrigger レポート Active ステータスとして、トリガーに達するまでの時間を読み取ることができます。期間は常に現在のサイクルの開始を指します。したがって、継続時間がサイクル時間 (この例では 0.004 秒) より短い場合、現在のサイクルでトリガーに達します。 IF readTrigger.TriggerInfo.status = SMC_TRIGGER_STATUS.Active THEN\n IF readTrigger.TriggerInfo.triggerTime <= 0.004 THEN\n triggerFired := TRUE;\n ...\n END_IF\nEND_IF 企画_PRG の中に Planning_PRG プログラムでは、計画の予測期間は、 SMC_TuneCPKernel ファンクションブロック。の SMC_GroupReadTrigger ファンクションブロックは、トリガーが予測期間に達したときに出力できます。この例では、予測期間は 0.1 秒に設定されています。したがって、のステータスは、 SMC_GroupReadTrigger ファンクションブロックは次のように変わります Active 軸グループがトリガに到達する 0.1 秒前から有効期間を出力します。 tuneCpKernel(AxisGroup:= axisGroup, Execute:= TRUE, fPlanningForecastDuration:= 0.1); 痕跡 トレースを使用して、 SMC_GroupReadTrigger ファンクションブロック。 最初の図では、(X=0, Y=0) から (X=20, Y=10) まで移動が実行されることがわかります。トリガーはムーブメント上の相対位置 0.6、つまり (X=12、Y=6) にあります。 2 番目の図は、 triggerTime からの出力 SMC_GroupReadTrigger 。計画の予測期間が 0.1 秒であるため、値は 0.1 秒にジャンプし、その後、位置 (X=12、Y=6) で値 0 に達するまで直線的に減少します。 3 番目の図は、 triggerFired に設定される変数 STATE_CHECK_TRIGGER の状態 Main_PRG 軸グループがトリガから 0.004 秒未満の距離に近づくとすぐに実行されます。 " }, 
{ "title" : "トリガー例2：接着工程 ", 
"url" : "_sm_example_digital_switches2.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ トリガー例2：接着工程 ", 
"snippet" : "の Robotics_Trigger_Advanced.project ここで説明するサンプル プロジェクトは、次のインストール ディレクトリにあります。 CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 トリガーを使用して、接着ノズルのオン\/オフの切り替えなど、パス上の特定の位置でアクションを実行できます。 この例には次のコンポーネントが含まれています。 による軌道の保証された予測の構成 fPlanningForecastDuration からのパラメータ SMC_TuneCPKernel ファンクションブロック。 さまざまなトリガーのコマンド。ここでは、...", 
"body" : "の Robotics_Trigger_Advanced.project ここで説明するサンプル プロジェクトは、次のインストール ディレクトリにあります。 CODESYS 下 ..\\CODESYS SoftMotion\\Examples 。 トリガーを使用して、接着ノズルのオン\/オフの切り替えなど、パス上の特定の位置でアクションを実行できます。 この例には次のコンポーネントが含まれています。 による軌道の保証された予測の構成 fPlanningForecastDuration からのパラメータ SMC_TuneCPKernel ファンクションブロック。 さまざまなトリガーのコマンド。ここでは、パスの位置を定義するために利用可能な 3 つの方法がすべて使用されています (「 SMC_TriggerPositionType ）。 タイムシフトによるトリガーの使用。サンプル アプリケーションには、 TriggerWithTimeShift 関数ブロックは、時間オフセットを使用してパス位置に到達することに反応できます (より早くまたはより遅く)。 これらのコンポーネントは、接着プロセスのサンプル アプリケーションに示されています。以下の画像で赤色で表示されている動きが実行されます（ブレンディングあり）。 トリガーは緑色でマークされた位置に定義されています。 位置 1: その位置に到達する 0.05 秒前に糊付け装置のスイッチを入れます。 位置 1: 位置に到達したら、UV ランプのスイッチをオンにします。 位置 2: 位置に到達したら、接着剤供給コンテナを充填します。 位置 3: 接着装置のスイッチを切り、その位置に到達する 0.05 秒前に接着剤供給コンテナへの充填を停止します。 位置 3: その位置に到達してから 1.5 秒後に UV ランプをオフにします。 " }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4589008317470433803801762921", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ トリガー例2：接着工程 \/ アプリケーションの構造 ", 
"snippet" : "アプリケーションは次の部分で構成されます。 GlueApplication : このプログラムには、接着プロセスのトリガーの使用方法を示すサンプル アプリケーションが含まれています。 Planning_PRG : このプログラムでは、軌道の予測を設定します。 TriggerWithTimeShift : このファンクション ブロックには、タイム シフトを伴うトリガーのロジックが含まれており、 GlueApplication サンプルプログラム。 Trace : トレースは軸のダイナミクスと、 GlueApplication トリガーで切り替わるプログラム。...", 
"body" : "アプリケーションは次の部分で構成されます。 GlueApplication : このプログラムには、接着プロセスのトリガーの使用方法を示すサンプル アプリケーションが含まれています。 Planning_PRG : このプログラムでは、軌道の予測を設定します。 TriggerWithTimeShift : このファンクション ブロックには、タイム シフトを伴うトリガーのロジックが含まれており、 GlueApplication サンプルプログラム。 Trace : トレースは軸のダイナミクスと、 GlueApplication トリガーで切り替わるプログラム。 " }, 
{ "title" : "予測の構成 ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4570491496867233803803206327", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ トリガー例2：接着工程 \/ 予測の構成 ", 
"snippet" : "トリガーに達する前に、たとえば 0.05 秒前などに早めに反応したい場合は、 fPlanningForecastDuration SMC_ からのパラメータ SMC_TuneCPKernel ファンクションブロックは少なくとも 0.05 秒に設定する必要があります。このパラメータはレイテンシに直接影響するため、その値を必要以上に大きくすべきではありません (ドキュメントを参照) f計画予測期間 ）。ご了承ください SMC_TuneCPKernel で呼び出す必要があります SoftMotion 計画タスク。このため、メインプログラムでは設定は実行されません。 GlueApplication 、...", 
"body" : "トリガーに達する前に、たとえば 0.05 秒前などに早めに反応したい場合は、 fPlanningForecastDuration SMC_ からのパラメータ SMC_TuneCPKernel ファンクションブロックは少なくとも 0.05 秒に設定する必要があります。このパラメータはレイテンシに直接影響するため、その値を必要以上に大きくすべきではありません (ドキュメントを参照) f計画予測期間 ）。ご了承ください SMC_TuneCPKernel で呼び出す必要があります SoftMotion 計画タスク。このため、メインプログラムでは設定は実行されません。 GlueApplication 、しかし、 Planning_PRG プログラム。 このサンプル アプリケーションでは、位置に到達する 0.05 秒前にトリガーの評価が必要です。このため、パラメータ fPlanningForecastDuration =0.05が設定されています。 Planning_PRG プログラム。 " }, 
{ "title" : "機能ブロック: TriggerWithTimeShift ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4609369977958433803803968971", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ トリガー例2：接着工程 \/ 機能ブロック: TriggerWithTimeShift ", 
"snippet" : "の TriggerWithTimeShift 関数ブロックは、トリガーを使用するための簡素化されたインターフェイスを提供します。さらに、時間シフトを定義して、ある位置 (負の値) に到達した後だけでなく、ある位置 (正の値) の前でもトリガーが反応できるようにすることができます。アプリケーションで必要な時間精度に応じて、トリガーに達したときの反応は次のようになります。 必要な時間精度 >= バス タスク サイクル: この場合、 TriggerWithTimeShift.TriggerReachedThisCycle 出力を使用できます。 必要な時間精度 < バスタスクサイクル: この場合、正確...", 
"body" : "の TriggerWithTimeShift 関数ブロックは、トリガーを使用するための簡素化されたインターフェイスを提供します。さらに、時間シフトを定義して、ある位置 (負の値) に到達した後だけでなく、ある位置 (正の値) の前でもトリガーが反応できるようにすることができます。アプリケーションで必要な時間精度に応じて、トリガーに達したときの反応は次のようになります。 必要な時間精度 >= バス タスク サイクル: この場合、 TriggerWithTimeShift.TriggerReachedThisCycle 出力を使用できます。 必要な時間精度 < バスタスクサイクル: この場合、正確な残り時間 TriggerWithTimeShift.TriggerTime トリガーに達するまで使用できます。 初めの、 TriggerWithTimeShift を使用します SMC_GroupPrepareTrigger と SMC_GroupReadTrigger 機能ブロック。 " }, 
{ "title" : "トリガーのコマンド ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4608844104630433803805051855", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ トリガー例2：接着工程 \/ トリガーのコマンド ", 
"snippet" : "の中に GlueApplication プログラムに従って、動きとトリガーが命令されます。トリガーは次を使用して準備されるため、呼び出し順序はトリガーにとって特に重要です。 SMC_GroupPrepareTrigger は、同じサイクル内で指令された次の動作に割り当てられます。したがって、すべてのアプリケーションで次の点に注意する必要があります。 トリガーを命令するためのファンクション ブロックは、常に移動ファンクション ブロックの前に呼び出されます。 トリガーとそれぞれの動作は常に同じサイクルで指令されます。 トリガーは以下のすべてのタイプを使用します。 SMC_TriggerPositi...", 
"body" : "の中に GlueApplication プログラムに従って、動きとトリガーが命令されます。トリガーは次を使用して準備されるため、呼び出し順序はトリガーにとって特に重要です。 SMC_GroupPrepareTrigger は、同じサイクル内で指令された次の動作に割り当てられます。したがって、すべてのアプリケーションで次の点に注意する必要があります。 トリガーを命令するためのファンクション ブロックは、常に移動ファンクション ブロックの前に呼び出されます。 トリガーとそれぞれの動作は常に同じサイクルで指令されます。 トリガーは以下のすべてのタイプを使用します。 SMC_TriggerPositionType : 位置 1 のトリガーは相対距離の定義を使用します ( SMC_TriggerPositionType.MvtRelative )、位置 0.5 として。それぞれの動きの距離は 10 であるため、トリガーは X=5 に配置されます。 位置 2 のトリガーは、ユーザー単位 u での距離の定義を使用します ( SMC_TriggerPositionType.MvtDistance その結果、トリガーも X=5 に配置されます。 位置 3 のトリガーは、平面との交差を使用します ( SMC_TriggerPositionType.PlaneIntersection ）。平面は、トリガーが X=5 に配置されるように定義されています。 GlueApplication 持っています EnableGlue 、 EnableUVLamp 、 と RefillGlueStorage 出力。これらは適切なトリガーで切り替わります。 GlueApplication.EvaluateTriggers() 。これらの出力の動きと状態はトレースで監視および評価できます。 " }, 
{ "title" : "ロボット工学における追加軸の使用 ", 
"url" : "_sm_example_additional_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ ロボット工学における追加軸の使用 ", 
"snippet" : "ザ・ Robotics_AdditionalAxes.project サンプルプロジェクトでは、ロボット工学における追加軸の設定方法と使用方法を示しています。追加軸とは、ロボットの協調動作と同期して移動する軸です プロジェクトは、のインストールディレクトリにあります CODESYS 下に ..\\CODESYS SoftMotion\\Examples 。...", 
"body" : "ザ・ Robotics_AdditionalAxes.project サンプルプロジェクトでは、ロボット工学における追加軸の設定方法と使用方法を示しています。追加軸とは、ロボットの協調動作と同期して移動する軸です プロジェクトは、のインストールディレクトリにあります CODESYS 下に ..\\CODESYS SoftMotion\\Examples 。 " }, 
{ "title" : "アプリケーションの構造 ", 
"url" : "_sm_example_additional_axes.html#UUID-c2402508-ef5a-d02d-ee68-db3b85c8530d_section-idm235063293414778", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ ロボット工学における追加軸の使用 \/ アプリケーションの構造 ", 
"snippet" : "軸グループは、以下で設定されます。 軸グループ オブジェクト。3 軸 (2 つの回転軸と 1 つの直線 Z 軸) のスカラロボットを使用します さらに 2 つの軸が以下に追加されました。 軸の追加 そして、2 つの軸にリンクされています。 DriveAdd1 と DriveAdd2 。 ザ・ PLC_PRG プログラムには、プログラムフロー用のシンプルなステートマシンが含まれています。まず、軸グループが有効な状態になります 0 そして、その位置への PTP 移動 (X=50, Y=50) が実行されます。その後、これを直線的な動きにブレンドして位置を決めます。 (X=50, Y=-50) 。 ...", 
"body" : "軸グループは、以下で設定されます。 軸グループ オブジェクト。3 軸 (2 つの回転軸と 1 つの直線 Z 軸) のスカラロボットを使用します さらに 2 つの軸が以下に追加されました。 軸の追加 そして、2 つの軸にリンクされています。 DriveAdd1 と DriveAdd2 。 ザ・ PLC_PRG プログラムには、プログラムフロー用のシンプルなステートマシンが含まれています。まず、軸グループが有効な状態になります 0 そして、その位置への PTP 移動 (X=50, Y=50) が実行されます。その後、これを直線的な動きにブレンドして位置を決めます。 (X=50, Y=-50) 。 最初のロボットの動きでは、距離に応じて軸が相対的に移動します (10, 20) 命令されます。2 回目のロボットの移動では、追加する軸の距離は (-10, -20) 。 ザ・ MC_GroupReadActualPosition そして MC_GroupReadActualVelocity ファンクションブロックは、キネマティクスと追加軸の位置と速度を読み取るために使用されます。 " }, 
{ "title" : "コミッショニング ", 
"url" : "_sm_example_additional_axes.html#UUID-c2402508-ef5a-d02d-ee68-db3b85c8530d_section-idm235063296617065", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ 例 \/ ロボット工学における追加軸の使用 \/ コミッショニング ", 
"snippet" : "アプリケーションをビルドし、コントローラーにダウンロードします。 トレースを開き、コントローラにダウンロードします。 アプリケーションを起動します。 X 座標と Y 座標、およびトレース内の 2 つの追加軸の動きを追跡できます。...", 
"body" : "アプリケーションをビルドし、コントローラーにダウンロードします。 トレースを開き、コントローラにダウンロードします。 アプリケーションを起動します。 X 座標と Y 座標、およびトレース内の 2 つの追加軸の動きを追跡できます。 " }, 
{ "title" : "ユーザーインターフェース ", 
"url" : "_sm_robotics_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ ユーザーインターフェース ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド：計画タスクの作成 ", 
"url" : "_sm_cmd_create_planning_task.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ ユーザーインターフェース \/ コマンド：計画タスクの作成 ", 
"snippet" : "関数 ：このコマンドは、計画タスクを自動的に作成します。このタスクは、CPの移動を計画するために必要です（たとえば、直線移動または円形移動）。 電話 ： 計画 メニュー;軸グループのコンテキストメニュー 要件 ：このコマンドは、軸グループに計画タスクが設定されていない場合にのみ使用できます。...", 
"body" : "関数 ：このコマンドは、計画タスクを自動的に作成します。このタスクは、CPの移動を計画するために必要です（たとえば、直線移動または円形移動）。 電話 ： 計画 メニュー;軸グループのコンテキストメニュー 要件 ：このコマンドは、軸グループに計画タスクが設定されていない場合にのみ使用できます。 " }, 
{ "title" : "軸グループエディター ", 
"url" : "_sm_obj_axis_group-1018069.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ ユーザーインターフェース \/ 軸グループエディター ", 
"snippet" : "シンボル： のエディターで 軸グループ オブジェクトで、基本的な運動学と方向運動学のタイプを選択します。オリエンテーションキネマティクスは、基本キネマティクスでサポートされている場合にのみ選択できます。さらに、キネマティクスの軸をプロジェクトのドライブにマッピングします。 キネマティクス キネマティクスを選択 キネマティクスを変更する によってサポートされているすべてのキネマティクスのリストを開きます CODESYS キネマティクスのタイプを選択すると、リストの右側のフレームに簡単な説明が表示されます。 キネマティクスのタイプを選択した後、エディタでそれぞれのパラメータを変更できます。 オリエ...", 
"body" : "シンボル： のエディターで 軸グループ オブジェクトで、基本的な運動学と方向運動学のタイプを選択します。オリエンテーションキネマティクスは、基本キネマティクスでサポートされている場合にのみ選択できます。さらに、キネマティクスの軸をプロジェクトのドライブにマッピングします。 キネマティクス キネマティクスを選択 キネマティクスを変更する によってサポートされているすべてのキネマティクスのリストを開きます CODESYS キネマティクスのタイプを選択すると、リストの右側のフレームに簡単な説明が表示されます。 キネマティクスのタイプを選択した後、エディタでそれぞれのパラメータを変更できます。 オリエンテーション運動学 キネマティクスを選択 キネマティクスを変更する によってサポートされているすべてのオリエンテーションキネマティクスのリストを開きます CODESYS キネマティクスのタイプを選択すると、リストの右側のフレームに簡単な説明が表示されます。 キネマティクスのタイプを選択した後、エディタでそれぞれのパラメータを変更できます。 軸マッピング 選択したキネマティクスに応じて、キネマティクスの軸をプロジェクトのドライブにマッピングします。 追加軸 [軸を追加] 追加の軸の設定フィールドを追加します。この構成フィールドには、プロジェクトのドライブが入力されます。 タスク バスサイクルタスク 軸がすでにマップされている場合は、軸のバスサイクルタスク ここでは設定を変更できません。 計画タスク CPタスクの計画のためのタスク 最初の軸グループが挿入されると、計画タスクが自動的に作成されます。実行時間が大幅に変動する可能性があるため、ウォッチドッグは構成しないでください。 詳細については、以下を参照してください。 計画タスクの構成このタスクを削除すると、メッセージビューにエラーが表示されます。新しいタスクを作成するには、 プロジェクト → 計画タスクを作成する 。 詳細については、以下を参照してください。 軸グループを作成する方法" }, 
{ "title" : "ユーザーインターフェース ", 
"url" : "_sm_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ ユーザーインターフェース ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド：有効にする SoftMotion ", 
"url" : "_sm_cmd_enable_softmotion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ ユーザーインターフェース \/ コマンド：有効にする SoftMotion ", 
"snippet" : "関数 ：コマンドは、のコンポーネントを有効にします SoftMotion 選択したコントローラに対して、コントローラをモーションコントローラとして使用できるようにします。 電話 ： 計画 メニュー;デバイスツリーで選択したデバイスのコンテキストメニュー 要件 ：選択したコントローラーでは、SoftMotionは有効になっていません。 コマンドにより、 SoftMotion一般軸プール オブジェクトがまだ欠落している限り、コントローラー構成の下に追加されるデバイス。最大で1つあります SoftMotion一般軸プール PLCデバイスごと。さらに、SoftMotionライブラリ（プレフィックス付き...", 
"body" : "関数 ：コマンドは、のコンポーネントを有効にします SoftMotion 選択したコントローラに対して、コントローラをモーションコントローラとして使用できるようにします。 電話 ： 計画 メニュー;デバイスツリーで選択したデバイスのコンテキストメニュー 要件 ：選択したコントローラーでは、SoftMotionは有効になっていません。 コマンドにより、 SoftMotion一般軸プール オブジェクトがまだ欠落している限り、コントローラー構成の下に追加されるデバイス。最大で1つあります SoftMotion一般軸プール PLCデバイスごと。さらに、SoftMotionライブラリ（プレフィックス付き） SM3_ ）がライブラリマネージャに追加されます。 その結果、従来のすべてのPLCでSoftMotion機能を使用でき、たとえば、少なくともデモモードでは、ライセンスがなくてもSoftMotionファンクションブロックを呼び出すことができます。 自動アクティベーション デバイスでSoftMotionが無効になっていて、デバイスの下にSoftMotionオブジェクトを追加した場合は、 SoftMotionを有効にする コマンドはすぐに暗黙的に実行されます。 SoftMotionオブジェクトは、カムオブジェクト、CNCオブジェクト、軸グループオブジェクト、または任意のSoftMotion軸です。 SoftMotionPLCから標準PLCへのデバイスの更新 SoftMotionが有効になっていて、デバイスが以下で構成されている場合 SoftMotion一般軸プール 、とにかくデバイスを標準のPLCに更新できます。これは、これらのデバイスが更新後も利用可能なままであるためです。たとえば、から更新できます CODESYS SoftMotion RTE に CODESYS Control RTE 損失なし。 " }, 
{ "title" : "コマンド：無効にする SoftMotion ", 
"url" : "_sm_cmd_disable_softmotion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ ユーザーインターフェース \/ コマンド：無効にする SoftMotion ", 
"snippet" : "関数 ：コマンドはのコンポーネントを無効にします SoftMotion 。 電話 ： 計画 メニュー;デバイスツリーで選択したデバイスのコンテキストメニュー 要件 ：選択したコントローラーについて、 SoftMotion コマンドによって有効にされました。 SoftMotion サポートを目的としたコントローラーでは無効にできません SoftMotion （例： CODESYS SoftMotion Win ）。 コマンドにより、 SoftMotion一般軸プール コントローラ構成の下から削除するデバイス。さらに、SoftMotionライブラリ（プレフィックス付き） SM3_ ）はライブラリマ...", 
"body" : "関数 ：コマンドはのコンポーネントを無効にします SoftMotion 。 電話 ： 計画 メニュー;デバイスツリーで選択したデバイスのコンテキストメニュー 要件 ：選択したコントローラーについて、 SoftMotion コマンドによって有効にされました。 SoftMotion サポートを目的としたコントローラーでは無効にできません SoftMotion （例： CODESYS SoftMotion Win ）。 コマンドにより、 SoftMotion一般軸プール コントローラ構成の下から削除するデバイス。さらに、SoftMotionライブラリ（プレフィックス付き） SM3_ ）はライブラリマネージャから削除されます。 SoftMotion機能は使用できなくなりました。 " }
]
$(document).trigger('search.ready');
});