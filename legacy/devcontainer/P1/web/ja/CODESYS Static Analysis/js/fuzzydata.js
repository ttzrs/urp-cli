$(document).ready(function () {indexDict['ja'] = [{ "title" : "CODESYS Static Analysis ", 
"url" : "_san_start_page.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ CODESYS Static Analysis ", 
"snippet" : "と CODESYS Static Analysis 、IEC ソース コードのチェックは、定義されたルール、命名規則、またはメトリックを使用して実行できます。その結果、潜在的な開発上の問題の兆候が強調表示され、フィールド テスト前にエラーを特定して修正できます。これにより、アプリケーションの開発とエラー チェックにかかる時間を大幅に節約できます。 で CODESYS Static Analysis 、100 を超えるルール (一部はパラメーター化可能) がすでに実装されています。これらのルールを組み合わせて、カスタマイズされたルール セットを作成できます。一部のルールには、「PLCopen C...", 
"body" : "と CODESYS Static Analysis 、IEC ソース コードのチェックは、定義されたルール、命名規則、またはメトリックを使用して実行できます。その結果、潜在的な開発上の問題の兆候が強調表示され、フィールド テスト前にエラーを特定して修正できます。これにより、アプリケーションの開発とエラー チェックにかかる時間を大幅に節約できます。 で CODESYS Static Analysis 、100 を超えるルール (一部はパラメーター化可能) がすでに実装されています。これらのルールを組み合わせて、カスタマイズされたルール セットを作成できます。一部のルールには、「PLCopen Coding Guidelines」で定義されているルールセットが含まれます。また、考えられるデータ型ごとに命名規則を定義し、準拠しているかどうかをチェックすることもできます。さらに、定期的に計算すれば、基礎となるソース コードを分析し、マイナスの傾向や品質目標からの逸脱を示すことができる 20 を超える指標が利用可能です。 ダウンロードできます CODESYS Static Analysis から CODESYSストアインターナショナル または CODESYSストア北米 。製品のデータシートもそこにあります。製品はライセンスの対象となります。 ウェビナー CODESYS Static Analysis もし CODESYS Static Analysis がインストールされているが、ライセンスがアクティベートされていない場合、次の機能を備えたインターフェイスが縮小されます。 Static Analysis Light 表示されています。 の代替として CODESYS Static Analysis 、 CODESYS Development System を提供します Static Analysis Light アドオン。アドオンは自動的に CODESYS いつ いいえ CODESYS Static Analysis がインストールされています。 " }, 
{ "title" : "Static Analysis Light ", 
"url" : "_san_start_page.html#UUID-cc139654-e7d3-fe83-903e-e33f8fd0a5ec_section-idm452529692233763389020840932", 
"breadcrumbs" : "CODESYS Static Analysis \/ CODESYS Static Analysis \/ Static Analysis Light ", 
"snippet" : "Static Analysis Light の機能セットは大幅に制限されており、コンパイル チェックは 7 つしか提供されません。製品は無料でご利用いただけます。コンパイル チェックを個別に有効にできます。 プロジェクト → プロジェクト設定 メニューの、 静的解析ライト カテゴリー。 詳細については、以下を参照してください。 プロジェクト設定: 静的解析ライト...", 
"body" : "Static Analysis Light の機能セットは大幅に制限されており、コンパイル チェックは 7 つしか提供されません。製品は無料でご利用いただけます。コンパイル チェックを個別に有効にできます。 プロジェクト → プロジェクト設定 メニューの、 静的解析ライト カテゴリー。 詳細については、以下を参照してください。 プロジェクト設定: 静的解析ライト " }, 
{ "title" : "概要 ", 
"url" : "_san_overview.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 概要 ", 
"snippet" : "静的解析は、現在のプロジェクトでアプリケーション コードに対してのみ実行されます。ライブラリとそのソースコードは分析されません。 CODESYS Static Analysis 実装中に、より適切で読みやすいコードを作成し、競合するプログラム部分やサポートされていないプログラム部分を特定するのに役立ちます。特に、潜在的なエラーの原因が明らかになります。たとえば、テスト コードがまだ含まれている場所が特定されます。または、逆参照前に 0 がチェックされていないポインタが見つかりました。または（ SA0119 ルール）オブジェクト指向が使用されている場所が解析され、オブジェクト指向をサポートしてい...", 
"body" : "静的解析は、現在のプロジェクトでアプリケーション コードに対してのみ実行されます。ライブラリとそのソースコードは分析されません。 CODESYS Static Analysis 実装中に、より適切で読みやすいコードを作成し、競合するプログラム部分やサポートされていないプログラム部分を特定するのに役立ちます。特に、潜在的なエラーの原因が明らかになります。たとえば、テスト コードがまだ含まれている場所が特定されます。または、逆参照前に 0 がチェックされていないポインタが見つかりました。または（ SA0119 ルール）オブジェクト指向が使用されている場所が解析され、オブジェクト指向をサポートしていない別の開発環境に移植されるため、不可能になります。その結果、コードの移植性が保証されます。 プリコンパイル情報に基づいて静的解析によって報告されるエラーについては、即時エラー処理 (「クイックフィックス」) がサポートされています。これにより、分析中に報告されたコード内の場所をすばやく見つけて修正できます。 ソース コードの読みやすさを向上させるために、命名規則を定義し、準拠しているかどうかをチェックできます。 さらに、コードの品質を評価するために、ソース コードから決定されたメトリクスを表示できます。例としては、コードのテスト容易性の尺度としての McCabe メトリクスや、ソース コードの可読性と保守性の尺度としての認知複雑度が挙げられます。静的解析で実行されるデータ フロー解析は、定数伝播の原理に基づいています。 とともに 作成 → 静的解析の実行 メニュー コマンドを使用すると、静的解析を明示的にアクティブ化します。 の中に 設定 ダイアログで、各コードのコンパイル後に自動的に実行される静的分析を有効にします。 あなたが使う プラグマステートメント コードの個々の部分またはブロックを分析から除外します。 の中に ルール ダイアログでは、どのルールが構成されているか、どのようにアクティブ化されているか、各ルールに対していつチェックが実行されるかを確認できます。そこで、自分に関連するルールを有効にします。 の中に 命名規則 ダイアログでは、宣言で期待されるプレフィックスを各データ型に割り当てます。逸脱が報告されます。 の中に 静的分析設定: メトリクス ダイアログで、関連するメトリクスをアクティブにします。 とともに 現在のエディターの認知的複雑性を表示 コマンドを実行すると、決定された増分がアクティブなエディターに 1 行ずつ表示されます。 の 現在のエディタの定数伝播の値を表示 このコマンドは、アクティブなエディターのデータ フローを詳細に分析し、パスごとに表示します。これに応じて、コードを改善することが可能です。 詳細については、以下を参照してください。 ルール、 メトリクス、 そして プラグマと属性" }, 
{ "title" : "静的コード分析を構成して実行する ", 
"url" : "_san_configuring_and_running.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 静的コード分析を構成して実行する ", 
"snippet" : "単純なサンプルプロジェクトに基づいて、静的コード分析を構成および実行するための最も重要な手順とオプションを以下に示します。 要件： CODESYS Static Analysis インストールされています。...", 
"body" : "単純なサンプルプロジェクトに基づいて、静的コード分析を構成および実行するための最も重要な手順とオプションを以下に示します。 要件： CODESYS Static Analysis インストールされています。 " }, 
{ "title" : "サンプルプロジェクト ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-5b7b70fe166a598dc0a864631da88a82", 
"breadcrumbs" : "CODESYS Static Analysis \/ 静的コード分析を構成して実行する \/ サンプルプロジェクト ", 
"snippet" : "サンプルプロジェクトを再プログラムする場合は、標準プロジェクトを作成し、アプリケーションの下にある以下に示すブロックをデバイスツリーに挿入します。その後、ローカルに接続するための通信設定を構成します CODESYS Control Win 。 FUNCTION_BLOCK fb1 VAR_INPUT iVar_fb1in1 : INT; ivar_fb1in2 : INT; rVar_fb1in3 : REAL; END_VAR VAR_OUTPUT iVar_fb1out:INT; END_VAR VAR P_fSampleProperty : INT; rVar : REAL; PRO :...", 
"body" : "サンプルプロジェクトを再プログラムする場合は、標準プロジェクトを作成し、アプリケーションの下にある以下に示すブロックをデバイスツリーに挿入します。その後、ローカルに接続するための通信設定を構成します CODESYS Control Win 。 FUNCTION_BLOCK fb1\nVAR_INPUT\n iVar_fb1in1 : INT;\n ivar_fb1in2 : INT;\n rVar_fb1in3 : REAL;\nEND_VAR\nVAR_OUTPUT\n iVar_fb1out:INT;\nEND_VAR\nVAR\n P_fSampleProperty : INT;\n rVar : REAL;\n PRO : BOOL;\nEND_VAR\n iVar_fb1out:=iVar_fb1in1 + 1; FUNCTION_BLOCK fb2\nVAR_INPUT\n iVar_fb2in:INT;\nEND_VAR\nVAR_OUTPUT\n iVar_fb2out:INT;\nEND_VAR\nVAR\nEND_VAR\n iVar_fb2out:=iVar_fb2in - 1; PROGRAM PLC_PRG\nVAR\n fb1_inst: fb1;\n fb2_inst: fb2;\nEND_VAR fb1_inst(iVar_fb1in1 := 99);\nfb2_inst(iVar_fb2in := 22);\nfb2_inst(iVar_fb2in := 1); " }, 
{ "title" : "ルールへの準拠を確認する ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-9641312f166a598dc0a864630126d291", 
"breadcrumbs" : "CODESYS Static Analysis \/ 静的コード分析を構成して実行する \/ ルールへの準拠を確認する ", 
"snippet" : "コマンドを選択します ビルド→静的分析→設定 。切り替える タブ ルール 。 可能なすべてのルールチェックのリストを取得します。それらは、テーマ別のカテゴリでツリー構造に配置されます。 「ルール番号」は丸括弧で囲まれて追加されます。例： 未使用の変数（33） カテゴリ内 未使用のオブジェクトを一覧表示する 。 最初の行（ノード）のチェックボックスをクリックします ルール ）。 クリックすると、アクティベーション ステータスが切り替わります。ツリー全体のチェック ボックスに赤またはオレンジのチェック マークが付いているか、チェック マークがまったく付いていません。 この方法で、赤いチェックマーク...", 
"body" : "コマンドを選択します ビルド→静的分析→設定 。切り替える タブ ルール 。 可能なすべてのルールチェックのリストを取得します。それらは、テーマ別のカテゴリでツリー構造に配置されます。 「ルール番号」は丸括弧で囲まれて追加されます。例： 未使用の変数（33） カテゴリ内 未使用のオブジェクトを一覧表示する 。 最初の行（ノード）のチェックボックスをクリックします ルール ）。 クリックすると、アクティベーション ステータスが切り替わります。ツリー全体のチェック ボックスに赤またはオレンジのチェック マークが付いているか、チェック マークがまったく付いていません。 この方法で、赤いチェックマークが付いたすべてのエントリをアクティブにします。この意味は CODESYS Static Analysis エラーとして検出されたルール違反を報告します。 コマンドを選択します ビルド→静的分析→静的分析の実行 。 メッセージウィンドウにエラーが表示されます。メッセージテキストには マークを付けて、エラー番号「SA <ルール番号>」で開始します。 メッセージをダブルクリックします SA0033: 未使用の変数 'iVar_fb2out' 。 フォーカスは機能ブロックの宣言部分にジャンプします fb2 関連する変数が選択されます。変数は宣言されていますが、使用されていません。これはルール33でチェックされます（ 未使用の変数 ）。影響を受ける領域は、コード内で丸で囲まれています。 分析の自動実行をテストするには、 ビルド → 静的解析 → 設定 .上で 設定 タブで、 コンパイル後に自動的に静的解析を実行 オプション。クリック OK ダイアログを終了します。 コマンドを選択します オンライン→ログイン 。 メッセージボックスは、変換エラーがあることを示します。以前と同様に、コード分析によって報告されたエラーがメッセージウィンドウに表示されます。 コマンドを選択します ビルド→静的分析→設定 。タブに切り替えます ルール 。次に、ダイアログ内のすべてのルールを非アクティブ化します。カテゴリをチェックイン 未使用のオブジェクトを一覧表示する 明示的にルールSA0035（ 未使用の入力変数（35） ）オレンジ色のチェックマークを付けます。つまり、「警告」を発行します。ルールテキストのツールチップを確認してください。 このルールは、次のPLCopenルールに対応しています。CP24 ）。とのダイアログを閉じる わかった 。 コマンドを選択します ビルド→コードの生成 。 分析は自動的に実行されます。メッセージ ビューでは、2 つのエラーが 静的解析メッセージ カテゴリー： § SA0035: 未使用の入力 'iVar_fb1in2' § SA0035: 未使用の入力 'iVar_fb1in3' 各メッセージをダブルクリックして、コメントアウトするか、宣言を削除します。コード分析を再度実行します。 エラーメッセージはありません。 " }, 
{ "title" : "定義された命名規則への準拠を確認してください ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-d64b88b5166a598dc0a864632e22b38d", 
"breadcrumbs" : "CODESYS Static Analysis \/ 静的コード分析を構成して実行する \/ 定義された命名規則への準拠を確認してください ", 
"snippet" : "コマンドを選択します ビルド→静的分析→設定 。タブに切り替えます 命名規則 。 変数とプログラムブロックの拡張可能なカテゴリに分割されたツリー構造のテーブルが表示されます。 カテゴリを展開する 変数のプレフィックス - タイププレフィックス on：着用 INT（14） 列に プレフィックス 1 i 1。 カテゴリを展開する POUのプレフィックス - POUタイプのプレフィックス の上。コラムで着用 プレフィックス 次のように入力します。 プログラム（122） ： prog 、 で 機能ブロック（103） ： fb 。 オプションを有効にする プレフィックスの後の最初の文字は大文字にする必要...", 
"body" : "コマンドを選択します ビルド→静的分析→設定 。タブに切り替えます 命名規則 。 変数とプログラムブロックの拡張可能なカテゴリに分割されたツリー構造のテーブルが表示されます。 カテゴリを展開する 変数のプレフィックス - タイププレフィックス on：着用 INT（14） 列に プレフィックス 1 i 1。 カテゴリを展開する POUのプレフィックス - POUタイプのプレフィックス の上。コラムで着用 プレフィックス 次のように入力します。 プログラム（122） ： prog 、 で 機能ブロック（103） ： fb 。 オプションを有効にする プレフィックスの後の最初の文字は大文字にする必要があります 。他のすべてのオプションを無効にします。 コマンドを選択します ビルド→静的分析→静的分析の実行 。 エラーメッセージ： NC0102: 無効な名前 'PLC_PRG': プレフィックス 'prog' が必要です PLC_PRG には必要なプレフィックスがないため プレフィックスの後の最初の文字は大文字にする必要があります: 'ivar_fb1in2' なぜなら ivar_fb1in2 : INT; いる fb1 。 NC0014: 無効な変数名 P_fSampleProperty: 接頭辞 'i' が必要です この整数変数には必要なプレフィックスがないためです。 " }, 
{ "title" : "許容性について記号を確認する ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-7e83abe1166a598dc0a86463714e1dc5", 
"breadcrumbs" : "CODESYS Static Analysis \/ 静的コード分析を構成して実行する \/ 許容性について記号を確認する ", 
"snippet" : "コマンドを選択します ビルド→静的分析→設定 。切り替える タブ 禁止されている記号 。 ラインエディタを使用すると、コードで使用してはならない文字列を入力できます。 空の行をダブルクリックして、例として無効な文字列を入力します PRO 直接。次の空の行をダブルクリックして、ボタンで開きます 入力ヘルプ。選ぶ 標準タイプ そいつ 本物 アウト。とのダイアログを閉じる わかった 。 コマンドを選択します ビルド→静的分析→静的分析の実行 。 エラーメッセージがメッセージウィンドウに表示されます Verbotenes Symbol 'REAL' と Verbotenes Symbol 'PRO' ...", 
"body" : "コマンドを選択します ビルド→静的分析→設定 。切り替える タブ 禁止されている記号 。 ラインエディタを使用すると、コードで使用してはならない文字列を入力できます。 空の行をダブルクリックして、例として無効な文字列を入力します PRO 直接。次の空の行をダブルクリックして、ボタンで開きます 入力ヘルプ。選ぶ 標準タイプ そいつ 本物 アウト。とのダイアログを閉じる わかった 。 コマンドを選択します ビルド→静的分析→静的分析の実行 。 エラーメッセージがメッセージウィンドウに表示されます Verbotenes Symbol 'REAL' と Verbotenes Symbol 'PRO' メッセージテキストをダブルクリックすると、問題のコードにジャンプできます。 " }, 
{ "title" : "指標を表示する ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ 静的コード分析を構成して実行する \/ 指標を表示する ", 
"snippet" : "CODESYS Static Analysis 選択したコードを測定し、結果を表示できます。 コマンドを選択します ビルド→静的分析→設定 。切り替える タブ メトリック 。 テーブルであなたはから見ることができます CODESYS Static Analysis コードに適用可能なメトリック。 この例では、メトリックを有効にします 入力変数の数 値の許容範囲を指定します：下限 1 、 上限 2 。 さらにいくつかのメトリクスをアクティブ化します。たとえば、 コードサイズ そして コール数 。 コマンドを選択します 作成→静的分析→デフォルトのメトリックを表示 。 ビューには、それぞれに1行の...", 
"body" : "CODESYS Static Analysis 選択したコードを測定し、結果を表示できます。 コマンドを選択します ビルド→静的分析→設定 。切り替える タブ メトリック 。 テーブルであなたはから見ることができます CODESYS Static Analysis コードに適用可能なメトリック。 この例では、メトリックを有効にします 入力変数の数 値の許容範囲を指定します：下限 1 、 上限 2 。 さらにいくつかのメトリクスをアクティブ化します。たとえば、 コードサイズ そして コール数 。 コマンドを選択します 作成→静的分析→デフォルトのメトリックを表示 。 ビューには、それぞれに1行のテーブルが表示されます プログラムユニット サンプルプログラムの。有効なメトリックごとに、測定値を示す列があります。設定で定義された値の範囲外の値は赤で強調表示されます。私たちの特定の例の場合、これは少なくともフィールドです PLC_PRG \/入力 、このブロックの入力変数の数が定義された上限を超えているため 2 。 " }, 
{ "title" : "STコードのルール違反をすばやく修正 ", 
"url" : "_san_fix_errors_quickly.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ STコードのルール違反をすばやく修正 ", 
"snippet" : "対話中 設定静的分析 タブの下 ルール プリコンパイル情報に基づいて準拠がチェックされるSTコードのルールをアクティブ化できます。このようなルール違反を見つけるために静的コード分析を明示的に呼び出す必要はありません。ルールへの準拠は、プリコンパイル中およびコンパイルが成功した後、アクティブなSTエディターでチェックされます。ルール違反が発生した場合は、すぐに下線を引いてSTエディタに表示されます。さらに、ビューのメッセージウィンドウに表示されます コンパイル前 エラーメッセージまたは警告。 これへのガイド： 定義された命名規則への準拠を確認してくださいクイックフィックスは、ST エディターで波...", 
"body" : "対話中 設定静的分析 タブの下 ルール プリコンパイル情報に基づいて準拠がチェックされるSTコードのルールをアクティブ化できます。このようなルール違反を見つけるために静的コード分析を明示的に呼び出す必要はありません。ルールへの準拠は、プリコンパイル中およびコンパイルが成功した後、アクティブなSTエディターでチェックされます。ルール違反が発生した場合は、すぐに下線を引いてSTエディタに表示されます。さらに、ビューのメッセージウィンドウに表示されます コンパイル前 エラーメッセージまたは警告。 これへのガイド： 定義された命名規則への準拠を確認してくださいクイックフィックスは、ST エディターで波線の下線が付いたコードをクリックしてから電球のシンボルをクリックすると見つかります。 、またはメッセージ ビューで エラーメッセージ行のボタンをクリックします。それぞれの場合において、ルール違反を処理するための対応するコマンドが提供されます。 エラーに応じて、次のコマンドが迅速なトラブルシューティング（迅速な修正）のために提供されます。 エラーメッセージ\/警告を無視する このコマンドは、プラグマまたは属性をコードに自動的に挿入して、そのコード行に関連付けられているルールをチェックできないようにします。 <プログラミングオブジェクト名>のエラーメッセージ\/警告をグローバルに無視する このコマンドにより、プログラミングオブジェクトの宣言部分の先頭に属性が自動的に挿入されます。次に、このプログラミングオブジェクトに関連付けられたルールのチェックが除外されます。 ルール違反を回避するためにSTコードを変更する方法を提案するコマンド（クイックフィックス）。例えば SA0168：割り当て 'enum1：= 5'を削除します チェックをオフにします このコマンドにより、関連するルールのチェックが設定で無効になります。 どちらのコマンドを呼び出しても、その効果を元に戻すことができます。これを行うには、最初にビューをクリックします 装置 （または代わりにビューで POU ）。次に、コマンド 元に戻す 起動しました。 " }, 
{ "title" : "ルールを有効にする ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-1cca77b1336bf579c0a8646302e5e6f3", 
"breadcrumbs" : "CODESYS Static Analysis \/ STコードのルール違反をすばやく修正 \/ ルールを有効にする ", 
"snippet" : "コマンドを選択します ビルド→静的分析→設定 。タブに切り替えます ルール 。 可能なすべてのルールチェックのリストを取得します。それらは、テーマ別のカテゴリでツリー構造に配置されます。 「ルール番号」は丸括弧内に追加されます。ルールをフィルタリングしたり、オプションで並べ替えたり、リストとして表示したりできます。 フィルタをクリックします 構造化ビュー アイコン上 オプションを選択します 実行時間による構造化 。 プリコンパイル中にチェックできるルールは以下にリストされています。 プリコンパイル中およびコンパイルの成功後に実行されます。 ノード。これらは、チェック マークで識別されるルールで...", 
"body" : "コマンドを選択します ビルド→静的分析→設定 。タブに切り替えます ルール 。 可能なすべてのルールチェックのリストを取得します。それらは、テーマ別のカテゴリでツリー構造に配置されます。 「ルール番号」は丸括弧内に追加されます。ルールをフィルタリングしたり、オプションで並べ替えたり、リストとして表示したりできます。 フィルタをクリックします 構造化ビュー アイコン上 オプションを選択します 実行時間による構造化 。 プリコンパイル中にチェックできるルールは以下にリストされています。 プリコンパイル中およびコンパイルの成功後に実行されます。 ノード。これらは、チェック マークで識別されるルールです。 プリコンパイル カラム。左側の列で、チェックのルールを有効にできます。 ルール（168）の行で、チェックボックスをクリックして、ステータスが「赤い目盛り」から「黄色い目盛り」、「目盛りなし」に変わるようにします。 赤いチェックマークは、ルール違反がエラーメッセージとして出力されることを意味します。黄色のチェックマークは、ルール違反が警告として発行されることを意味します。ティックがないということは、ルールがチェックされていないことを意味します。 これで、アクティブ化されたルールがチェックされ、違反した場合はコードにマークが付けられ、メッセージウィンドウに表示されます。 " }, 
{ "title" : "メッセージウィンドウにルール違反を表示する ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-8f3e8ec3336bf579c0a86463654e2139", 
"breadcrumbs" : "CODESYS Static Analysis \/ STコードのルール違反をすばやく修正 \/ メッセージウィンドウにルール違反を表示する ", 
"snippet" : "コマンドを選択します 表示→メッセージ 。 メッセージウィンドウが開きます。 メッセージウィンドウで、選択リストからカテゴリを選択します コンパイル前 。 このカテゴリには、プリコンパイル中およびコンパイルの成功後に検出され、Quickfix で解決できるルール違反のみが表示されます。の ボタンは、これに対するそれぞれのコマンドを提供します。...", 
"body" : "コマンドを選択します 表示→メッセージ 。 メッセージウィンドウが開きます。 メッセージウィンドウで、選択リストからカテゴリを選択します コンパイル前 。 このカテゴリには、プリコンパイル中およびコンパイルの成功後に検出され、Quickfix で解決できるルール違反のみが表示されます。の ボタンは、これに対するそれぞれのコマンドを提供します。 " }, 
{ "title" : "迅速なトラブルシューティングを実行する ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-8a9adfb3336bf579c0a8646308d0b385", 
"breadcrumbs" : "CODESYS Static Analysis \/ STコードのルール違反をすばやく修正 \/ 迅速なトラブルシューティングを実行する ", 
"snippet" : "ルール168が設定でアクティブになり、ルール違反がSTエディターに表示されます。 要件: ST コード内に少なくとも 1 行に波線の下線があり、それぞれの SA 番号がメッセージ ビューに表示されます。 波線の下線が付いているコード行をクリックします。 象徴 が表示されます。 電球のアイコンをクリックします。 エラー処理用のメニュー コマンドを含むウィンドウが開きます。 エラーを修正したい。したがって、コマンドを選択します 割り当て 'enum1：= GVL.CONST' 。 これで、コマンドに示されているように、コードの行が自動的に変更されます。問題は修正されました。 3番目のコマンドには、...", 
"body" : "ルール168が設定でアクティブになり、ルール違反がSTエディターに表示されます。 要件: ST コード内に少なくとも 1 行に波線の下線があり、それぞれの SA 番号がメッセージ ビューに表示されます。 波線の下線が付いているコード行をクリックします。 象徴 が表示されます。 電球のアイコンをクリックします。 エラー処理用のメニュー コマンドを含むウィンドウが開きます。 エラーを修正したい。したがって、コマンドを選択します 割り当て 'enum1：= GVL.CONST' 。 これで、コマンドに示されているように、コードの行が自動的に変更されます。問題は修正されました。 3番目のコマンドには、ルール違反に応じて、コードを変更してエラーを修正する方法に関する提案が含まれています。 同じエラー処理はボタンクリックによるものです メッセージウィンドウのエラーメッセージ行で可能です。 " }, 
{ "title" : "コード行のルールチェックを無効にする ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-107e44f0336bf579c0a8646347e7d5cc", 
"breadcrumbs" : "CODESYS Static Analysis \/ STコードのルール違反をすばやく修正 \/ コード行のルールチェックを無効にする ", 
"snippet" : "ルール（168）が設定でアクティブになり、ルール違反がSTエディターに表示されます。 要件: ST コード内に少なくとも 1 行に波線の下線があり、それぞれの SA 番号がメッセージ ビューに表示されます。 波線の下線が付いているコード行をクリックします。 象徴 が表示されます。 電球のアイコンをクリックします。 エラー処理用のメニュー コマンドを含むウィンドウが開きます。 エラーを修正したくありません。そのため、コマンドを選択します エラーメッセージ\/警告を無視する 。 これで、コード行にプラグマが自動的に提供されます。プラグマは、影響を受けるルールの行がチェックされないようにするために使用...", 
"body" : "ルール（168）が設定でアクティブになり、ルール違反がSTエディターに表示されます。 要件: ST コード内に少なくとも 1 行に波線の下線があり、それぞれの SA 番号がメッセージ ビューに表示されます。 波線の下線が付いているコード行をクリックします。 象徴 が表示されます。 電球のアイコンをクリックします。 エラー処理用のメニュー コマンドを含むウィンドウが開きます。 エラーを修正したくありません。そのため、コマンドを選択します エラーメッセージ\/警告を無視する 。 これで、コード行にプラグマが自動的に提供されます。プラグマは、影響を受けるルールの行がチェックされないようにするために使用されます。エラー メッセージや警告は発行されません。 ボタンを使用して、影響を受けるコード行のルールチェックを無効にすることもできます メッセージウィンドウのエラーメッセージ行に表示されます。 " }, 
{ "title" : "プログラミングオブジェクトのルールチェックを無効にする ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-6dee377f336bf579c0a8646357b65fa8", 
"breadcrumbs" : "CODESYS Static Analysis \/ STコードのルール違反をすばやく修正 \/ プログラミングオブジェクトのルールチェックを無効にする ", 
"snippet" : "ルール168が設定でアクティブになり、ルール違反がSTエディターに表示されます。 要件: ST コード内に少なくとも 1 行に波線の下線があり、それぞれの SA 番号がメッセージ ビューに表示されます。 波線の下線が付いているコード行をクリックします。 象徴 が表示されます。 電球をクリックします。 エラー処理用のメニュー コマンドを含むウィンドウが開きます。 指定されたルールについてプログラミングオブジェクトがチェックされないようにする必要があります。そのため、2番目のコマンドを選択します PLC_PRGのエラーメッセージ\/警告をグローバルに無視する 。 オブジェクトの宣言に属性が自動的に提...", 
"body" : "ルール168が設定でアクティブになり、ルール違反がSTエディターに表示されます。 要件: ST コード内に少なくとも 1 行に波線の下線があり、それぞれの SA 番号がメッセージ ビューに表示されます。 波線の下線が付いているコード行をクリックします。 象徴 が表示されます。 電球をクリックします。 エラー処理用のメニュー コマンドを含むウィンドウが開きます。 指定されたルールについてプログラミングオブジェクトがチェックされないようにする必要があります。そのため、2番目のコマンドを選択します PLC_PRGのエラーメッセージ\/警告をグローバルに無視する 。 オブジェクトの宣言に属性が自動的に提供されるようになりました。この属性は、影響を受けるルールがオブジェクトに対してチェックされなくなったことを意味します。エラーメッセージや警告は発行されません。 ボタンを介してメッセージを無視するコマンドを見つけることもできます メッセージウィンドウのエラーメッセージ行に表示されます。 " }, 
{ "title" : "一般的にルールのチェックを無効にします ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ STコードのルール違反をすばやく修正 \/ 一般的にルールのチェックを無効にします ", 
"snippet" : "ルール168が設定でアクティブになり、ルール違反がSTエディターに表示されます。 要件: ST コード内に少なくとも 1 行に波線の下線があり、それぞれの SA 番号がメッセージ ビューに表示されます。 波線の下線のあるコード行をクリックします。 象徴 が表示されます。 電球をクリックします。 エラー処理用のメニュー コマンドを含むウィンドウが開きます。 表示されたルールをチェックしないようにします。そのため、4番目のコマンドを選択します チェックをオフにします 。 静的解析の設定でルールが無効になります。 コマンドを選択します ビルド→静的分析→設定 。タブに切り替えます ルール 。 ルール...", 
"body" : "ルール168が設定でアクティブになり、ルール違反がSTエディターに表示されます。 要件: ST コード内に少なくとも 1 行に波線の下線があり、それぞれの SA 番号がメッセージ ビューに表示されます。 波線の下線のあるコード行をクリックします。 象徴 が表示されます。 電球をクリックします。 エラー処理用のメニュー コマンドを含むウィンドウが開きます。 表示されたルールをチェックしないようにします。そのため、4番目のコマンドを選択します チェックをオフにします 。 静的解析の設定でルールが無効になります。 コマンドを選択します ビルド→静的分析→設定 。タブに切り替えます ルール 。 ルール 168 は無効になっています。 ボタンを使用してチェックをグローバルに非アクティブ化するためのコマンドを見つけることもできます メッセージウィンドウのエラーメッセージ行に表示されます。 " }, 
{ "title" : "命名規則を定義する ", 
"url" : "_san_define_naming_conventions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 命名規則を定義する ", 
"snippet" : "対話中 設定静的分析 タブの下 命名規則 コードで従う命名規則を定義します。スコープと修飾子に応じて、プログラミングブロック、変数、およびデータ型の識別子のプレフィックスを定義します。 次に、静的分析で命名規則への準拠を確認できます。 これへのガイド： 定義された命名規則への準拠を確認してください...", 
"body" : "対話中 設定静的分析 タブの下 命名規則 コードで従う命名規則を定義します。スコープと修飾子に応じて、プログラミングブロック、変数、およびデータ型の識別子のプレフィックスを定義します。 次に、静的分析で命名規則への準拠を確認できます。 これへのガイド： 定義された命名規則への準拠を確認してください" }, 
{ "title" : "プレフィックスを定義する ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-291ced2808fb693bc0a8646323d0819d", 
"breadcrumbs" : "CODESYS Static Analysis \/ 命名規則を定義する \/ プレフィックスを定義する ", 
"snippet" : "対話中 設定静的分析 タブの下 命名規則 列の入力フィールドで命名規則を定義します プレフィックス 。 文字リテラル 例： PRG_ の POUのプレフィックス 、 POUタイプのプレフィックス 、 プログラム（102） エントリごとに複数のリテラル、コンマで区切る 構文： <prefix> ( , <next prefix> )* 例： PRG_, PRG の POUのプレフィックス 、 POUタイプのプレフィックス 、 プログラム（102） 正規表現 正規表現 、プレフィックスのセットを定義します 構文： @ <expression> 例： @x[a-dA-D] で始まるプレフィックスを定...", 
"body" : "対話中 設定静的分析 タブの下 命名規則 列の入力フィールドで命名規則を定義します プレフィックス 。 文字リテラル 例： PRG_ の POUのプレフィックス 、 POUタイプのプレフィックス 、 プログラム（102） エントリごとに複数のリテラル、コンマで区切る 構文： <prefix> ( , <next prefix> )* 例： PRG_, PRG の POUのプレフィックス 、 POUタイプのプレフィックス 、 プログラム（102） 正規表現 正規表現 、プレフィックスのセットを定義します 構文： @ <expression> 例： @x[a-dA-D] で始まるプレフィックスを定義します x 開始し、その後に範囲の1文字だけが続きます a-dA-D @[A-Za-z][A-Za-z][A-Za-z][A-Za-z0-9] 4文字で構成されるプレフィックスを定義します。最初の3文字は文字で、4番目の文字は数字にすることもできます " }, 
{ "title" : "組み合わせ可能なデータ型のプレフィックスを定義する ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-e9a24404c19ad708c0a86463215af896", 
"breadcrumbs" : "CODESYS Static Analysis \/ 命名規則を定義する \/ 組み合わせ可能なデータ型のプレフィックスを定義する ", 
"snippet" : "以下のデータ型は、標準データ型、既存のデータ型、または機能ブロックに基づいています。 ポインタ： POINTER TO <basic type> リファレンス： REFERENCE TO <basic type> 配列： ARRAY[ <lower index bound> .. <upper index bound> ] OF <basic type> これらのデータ型は、ネストして相互に組み合わせることができます。オプションの場合 組み合わせ可能なデータ型の再帰プレフィックス がアクティブ化されると、静的分析は、そのような組み合わせ可能なデータ型の変数に対して再帰的に構成されたプレフィック...", 
"body" : "以下のデータ型は、標準データ型、既存のデータ型、または機能ブロックに基づいています。 ポインタ： POINTER TO <basic type> リファレンス： REFERENCE TO <basic type> 配列： ARRAY[ <lower index bound> .. <upper index bound> ] OF <basic type> これらのデータ型は、ネストして相互に組み合わせることができます。オプションの場合 組み合わせ可能なデータ型の再帰プレフィックス がアクティブ化されると、静的分析は、そのような組み合わせ可能なデータ型の変数に対して再帰的に構成されたプレフィックスを期待します。プレフィックスは宣言の後に続き、基本的なデータ型で合意されている命名規則に対応しています。 例 次の命名規則が設定されています。 i の 変数のプレフィックス 、 INT（26） p の 変数のプレフィックス 、 ポインター（26） ref の 変数のプレフィックス 、 参考文献（27） struct の 変数のプレフィックス 、 構造（32） オプション 組み合わせ可能なデータ型の再帰プレフィックス ： 次のコードは命名規則に違反しており、読みにくいものです。 PROGRAM plc1\nVAR\n var1 : ARRAY[100..110] OF ARRAY[30..50] OF ARRAY[6..7] OF BOOL;\n var2 : ARRAY[1..3] OF INT;\n var3 : REFERENCE TO INT;\n iVar4 : INT;\n iVar5 : INT;\n var6 : ARRAY[1..3] OF INT := [11, 22, 33];\n var7 : POINTER TO ARRAY[1..3] OF INT;\n var8 : REFERENCE TO INT;\n var9 : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n var0 : ARRAY[0..3] OF S_POLYGONLINE; \/\/ S_POLYGONLINE is a already defined structure\nEND_VAR\n\niVar4 := iVar4 + 1;\nvar8 REF= iVar4;\nvar1[100][30][6] := TRUE;\nvar9.aiPoint1[1] := 99;\nvar7 := ADR(var6);\nvar6[2] := 44;\niVar5 := var7^[2];\nvar0[0] := var9; 静的分析は、命名規則の次の違反を報告します。 NC0102：無効な名前 'plc1'：予期されるプレフィックス 'PRG_' NC0014：無効な変数名 'var0'：予期されるプレフィックス 'astruct' NC0014：無効な変数名 'var1'：予期されるプレフィックス 'aaax' NC0014：無効な変数名 'var2'：予期されるプレフィックス 'ai' NC0014：無効な変数名 'var3'：予期されるプレフィックス 'refi' NC0014：無効な変数名 'var6'：予期されるプレフィックス 'ai' NC0014：無効な変数名 'var7'：予期されるプレフィックス 'pai' NC0014：無効な変数名 'var8'：予期されるプレフィックス 'refi' NC0014：無効な変数名 'var9'：予期されるプレフィックス 'struct' " }, 
{ "title" : "エイリアスの変数のプレフィックスを定義する ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-9f66c39a945e11eab0a0b46479d263a5", 
"breadcrumbs" : "CODESYS Static Analysis \/ 命名規則を定義する \/ エイリアスの変数のプレフィックスを定義する ", 
"snippet" : "データ型変数にプレフィックスを使用できます エイリアス プレースホルダー付きのリテラルとして {datatype} 定義。次に、静的分析では、プレースホルダーではなく、基本データ型のプレフィックスが必要です。 オプション 名前空間プレフィックスとデータ型プレフィックスを組み合わせる プレフィックスの使用には影響しません {datatype} 。 例 次の命名規則が設定されています。 s の 変数のプレフィックス 、 タイププレフィックス 、 STRING（）19 A_{datatype} の 変数のプレフィックス 、 エイリアス（33） コード TYPE A_MESSAGE : STRING[...", 
"body" : "データ型変数にプレフィックスを使用できます エイリアス プレースホルダー付きのリテラルとして {datatype} 定義。次に、静的分析では、プレースホルダーではなく、基本データ型のプレフィックスが必要です。 オプション 名前空間プレフィックスとデータ型プレフィックスを組み合わせる プレフィックスの使用には影響しません {datatype} 。 例 次の命名規則が設定されています。 s の 変数のプレフィックス 、 タイププレフィックス 、 STRING（）19 A_{datatype} の 変数のプレフィックス 、 エイリアス（33） コード TYPE A_MESSAGE : STRING[50]; \/\/ base data type is STRING\nEND_TYPE\n\nVAR\n A_sMessage_N1 : A_MESSAGE := 'Robot is running.';\n A_s_Message_N2 : A_MESSAGE := 'Robot has been finished.';\n As_Message_N3 : A_MESSAGE := 'Robot has been stopped.';\n AsMessage_N4 : A_MESSAGE := 'Error 3 has been occured.';\nEND_VAR 静的分析は、命名規則の次の違反を報告します。 NC0033：無効な変数名 'As_Message_N3'：予期されるプレフィックス 'A_s' NC0033：無効な変数名 'AsMessage_N4'：予期されるプレフィックス 'A_s' ' " }, 
{ "title" : "プロパティのプレフィックスを定義する ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-e0cda739c19ad708c0a864636e955ca0", 
"breadcrumbs" : "CODESYS Static Analysis \/ 命名規則を定義する \/ プロパティのプレフィックスを定義する ", 
"snippet" : "データ型のビルディングブロック（POU）にプレフィックスを使用できます PROPERTY ワイルドカードを使用したリテラルとして {datatype} 定義。次に、静的分析では、プレースホルダーではなく、プロパティの戻りデータ型のプレフィックスが必要です。 オプション 名前空間プレフィックスとデータ型プレフィックスを組み合わせる プレースホルダーの使用には影響しません {datatype} 。 例 次の命名規則が設定されています。 fb の 変数のプレフィックス 、 タイププレフィックス 、 機能ブロックインスタンス FB_ の POUのプレフィックス 、 POUタイプのプレフィックス 、 機...", 
"body" : "データ型のビルディングブロック（POU）にプレフィックスを使用できます PROPERTY ワイルドカードを使用したリテラルとして {datatype} 定義。次に、静的分析では、プレースホルダーではなく、プロパティの戻りデータ型のプレフィックスが必要です。 オプション 名前空間プレフィックスとデータ型プレフィックスを組み合わせる プレースホルダーの使用には影響しません {datatype} 。 例 次の命名規則が設定されています。 fb の 変数のプレフィックス 、 タイププレフィックス 、 機能ブロックインスタンス FB_ の POUのプレフィックス 、 POUタイプのプレフィックス 、 機能ブロック（103） prop_{datatype} の POUのプレフィックス 、 POUタイプのプレフィックス 、 プロパティ（107） コード FUNCTION_BLOCK blocka \/\/ Invalid function block name\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\nPROPERTY PUBLIC vara : INT \/\/ Invalid property name, return data type is INT\nGet\n vara := iA;\nSet\niA := vara;\n\nPROGRAM plc1\nVAR\n var10 : blocka; \/\/ Invalid variable name of typ function block\n iVar11: INT;\nEND_VAR\n\nvar10();\nIF var10.vara > 500 THEN\n var10.vara := 0;\nEND_IF\niVar11 := var10.vara; 静的分析は、命名規則の次の違反を報告します。 NC0102：無効な名前 '' plc1 '：予期されるプレフィックス' PRG_ '' NC0031：無効な変数名 '' var10 '：予期されるプレフィックス' 'fb' ' NC0103：無効な変数名 '' blocka '：予期されるプレフィックス' FB_ '' NC0107：無効な変数名 'blocka.vara'：予期されるプレフィックス 'prop_i' ' 命名規則に従ったコード FUNCTION_BLOCK FB_A\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\nPROPERTY PUBLIC prop_iA : INT\nGet\n prop_iA := iA;\nSet\n iA := prop_iA;\n\nPROGRAM PRG_PLC1\nVAR\n fbA : FB_A;\n iVar11: INT;\nEND_VAR\n\nfbA();\nIF fbA.prop_iA > 500 THEN\n fbA.prop_iA := 0;\nEND_IF\niVar11 := fbA.prop_iA; " }, 
{ "title" : "構造のプレフィックスを定義する ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-ed64228609104c08c0a864630c58c86b", 
"breadcrumbs" : "CODESYS Static Analysis \/ 命名規則を定義する \/ 構造のプレフィックスを定義する ", 
"snippet" : "プロジェクト内の構造の一般的な接頭辞は、次の場所で設定できます。 DUTのプレフィックス 、 構造（151） 定義。特別な接頭辞が付いた構造を提供することもできます。次に、特別なプレフィックスが一般的なプレフィックスをシャドウします。 特別なプレフィックスは、プラグマを使用した構造のデータ型宣言で指定されます {attribute 'nameprefix' := <special prefix> '} 定義されています。次に、この構造のすべての変数をこのプレフィックスで開始します <special prefix> 。 例 次の命名規則が設定されています。 struct の 変数のプレフィックス...", 
"body" : "プロジェクト内の構造の一般的な接頭辞は、次の場所で設定できます。 DUTのプレフィックス 、 構造（151） 定義。特別な接頭辞が付いた構造を提供することもできます。次に、特別なプレフィックスが一般的なプレフィックスをシャドウします。 特別なプレフィックスは、プラグマを使用した構造のデータ型宣言で指定されます {attribute 'nameprefix' := <special prefix> '} 定義されています。次に、この構造のすべての変数をこのプレフィックスで開始します <special prefix> 。 例 次の命名規則が設定されています。 struct の 変数のプレフィックス 、 構造（32） S_ の DUTのプレフィックス 、 構造（151） 組み合わせ可能なデータ型の再帰プレフィックス ： コード TYPE S_POLYGONLINE :\nSTRUCT\n aiStart : ARRAY[1..2] OF INT := [-99, -99];\n aiPoint1 : ARRAY[1..2] OF INT;\n aiPoint2 : ARRAY[1..2] OF INT;\n aiPoint3 : ARRAY[1..2] OF INT;\n aiPoint4 : ARRAY[1..2] OF INT;\n aiEnd : ARRAY[1..2] OF INT := [99, 99];\nEND_STRUCT\nEND_TYPE\n\n{attribute 'nameprefix' := 'penta'} \/\/ Pragma to define a special prefix\nTYPE S_PENTA EXTENDS S_POLYGONLINE :\nSTRUCT\n aiPoint5 : ARRAY[1..2] OF INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PRG_Compute\nVAR\n structPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n structPentagon : S_PENTAGON := (aiStart:=[0,0], aiPoint1:=[1,1], aiPoint2:=[2,2], aiPoint3:=[3,3], aiPoint4:=[4,4], aiPoint5:=[5,5]);\n structLine0 : S_PENTA;\n pentaLine1 : S_PENTA;\n iXPoint: INT;\n aPoint0: ARRAY [1..2] OF INT;\n aPoint1: ARRAY [1..2] OF INT;\nEND_VAR\n\niXPoint := structPolygon.aiPoint1[1];\naPoint0 := structLine0.aiEnd;\naiPoint1 := pentaLine1.aiEnd; 静的分析は、命名規則の次の違反を報告します。 無効な変数名 'structLine0'：予期されるプレフィックス 'penta' " }, 
{ "title" : "さらに遠く CODESYS Static Analysis -プロジェクトに命名規則を提供する ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ 命名規則を定義する \/ さらに遠く CODESYS Static Analysis -プロジェクトに命名規則を提供する ", 
"snippet" : "命名規則をCSAファイルに保存します。このファイルは他の場所でも使用できます CODESYS Static Analysis -プロジェクトをロードして使用します。 ファイルに保存 コマンドを選択します ビルド→静的分析→設定 。 ボタンを選択 コンピューターに保存 。 ファイル選択ダイアログが開きます。そこで、ファイル拡張子がCSAの任意の名前のファイルに命名規則を保存できます。 命名規則を使用してファイルをロードする コマンドを選択します ビルド→静的分析→設定 。 ボタンを選択 ロード 。 ファイル選択ダイアログが開きます。表示されたCSAファイルから1つを選択します。...", 
"body" : "命名規則をCSAファイルに保存します。このファイルは他の場所でも使用できます CODESYS Static Analysis -プロジェクトをロードして使用します。 ファイルに保存 コマンドを選択します ビルド→静的分析→設定 。 ボタンを選択 コンピューターに保存 。 ファイル選択ダイアログが開きます。そこで、ファイル拡張子がCSAの任意の名前のファイルに命名規則を保存できます。 命名規則を使用してファイルをロードする コマンドを選択します ビルド→静的分析→設定 。 ボタンを選択 ロード 。 ファイル選択ダイアログが開きます。表示されたCSAファイルから1つを選択します。 " }, 
{ "title" : "コードクローンの検出 ", 
"url" : "_san_find_code_clone.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ コードクローンの検出 ", 
"snippet" : "要件： CODESYS Static Analysis インストールされています。 あ CODESYS プロジェクトはオープンしています。プロジェクトには、少なくとも 2 つのプログラミング オブジェクトに同じコード ブロックが含まれています。 クリック  ビルド → 静的解析 → クローンの検出 。 景色 検索結果のクローンを作成する 開きます。 クリック 結果 。 見つかったコードクローンは、ウィンドウにツリービューとして表示されます。 同一のコードクローンに加えて相違点のあるコードクローンがある場合、これらの子ノードはツリービューで色で強調表示されます。 ツリービューで、子ノードの2つの...", 
"body" : "要件： CODESYS Static Analysis インストールされています。 あ CODESYS プロジェクトはオープンしています。プロジェクトには、少なくとも 2 つのプログラミング オブジェクトに同じコード ブロックが含まれています。 クリック  ビルド → 静的解析 → クローンの検出 。 景色 検索結果のクローンを作成する 開きます。 クリック 結果 。 見つかったコードクローンは、ウィンドウにツリービューとして表示されます。 同一のコードクローンに加えて相違点のあるコードクローンがある場合、これらの子ノードはツリービューで色で強調表示されます。 ツリービューで、子ノードの2つのコードクローンを選択し、ボタンをクリックします 選択したクローンを表示する 。 この重複コードを含む2つのプログラミングオブジェクトがエディターで開かれ、ビューの上部に表示されます。 同一のコードクローンは明るい黄色でマークされ、コードクローンには、この例の変数名などの違いがあります。 ivar3 と ivarx 、は赤で強調表示されます。 プログラミングオブジェクトの同一のコードクローンから取得するには POU_1 関数を作成するには、最初にツリービューでのコードクローンの行をダブルクリックします 物体 POU_1 。 プログラミングオブジェクト POU_1 エディターで開き、実装部分で、重複したコードを含む4行がマークされます。 選択したコードブロックのコンテキストメニューでコマンドを使用する場合 抽出機能 を選択すると、コードブロックがオフになります POU_1 抽出され、そこから新しいメソッドが作成されます。の実装部分のコードブロック POU_1 メソッドを呼び出すことで自動的に置き換えられます。 2番目のプログラミングオブジェクトでは、重複するコードを手動で削除し、メソッド呼び出しに置き換える必要があります。 後のバージョンでは、重複したコードブロックが両方のプログラミングオブジェクトから自動的に抽出され、正しい関数呼び出しに置き換えられるように、機能が拡張されます。 " }, 
{ "title" : "定数伝播 ", 
"url" : "_san_constant_propagation.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 定数伝播 ", 
"snippet" : "とともに CODESYS Static Analysis バージョン V5.0.0.0 では、コードの分析は定数伝播に基づいています。定数伝播の結果はさまざまなチェックに使用されます。たとえば、ポインタが 0 に等しくないか、配列インデックスが有効範囲外かどうかをチェックします。 この分析がどのように機能するのか、またその制限は何なのかを知るだけで、静的分析を効果的にサポートできます。...", 
"body" : "とともに CODESYS Static Analysis バージョン V5.0.0.0 では、コードの分析は定数伝播に基づいています。定数伝播の結果はさまざまなチェックに使用されます。たとえば、ポインタが 0 に等しくないか、配列インデックスが有効範囲外かどうかをチェックします。 この分析がどのように機能するのか、またその制限は何なのかを知るだけで、静的分析を効果的にサポートできます。 " }, 
{ "title" : "定数伝播 ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078132035233833484992758", 
"breadcrumbs" : "CODESYS Static Analysis \/ 定数伝播 \/ 定数伝播 ", 
"snippet" : "静的分析では、変数の使用状況に基づいて変数の値を決定しようとします。 例 PROGRAM PLC_PRG \/\/Declaration VAR x: INT; bTest: BOOL; END_VAR \/\/Implementation x := 99; IF x < 100 THEN bTest := TRUE; END_IF 1 行目の実装では、定数の伝播によって値が記録されます。 99 変数の場合 x この値をさらなる分析に使用します。分析により、次の式が認識されます。 IF -ステートメント定数 TRUE は。...", 
"body" : "静的分析では、変数の使用状況に基づいて変数の値を決定しようとします。 例 PROGRAM PLC_PRG\n\/\/Declaration\nVAR\n x: INT;\n bTest: BOOL;\nEND_VAR \/\/Implementation\nx := 99;\nIF x < 100 THEN\n bTest := TRUE;\nEND_IF 1 行目の実装では、定数の伝播によって値が記録されます。 99 変数の場合 x この値をさらなる分析に使用します。分析により、次の式が認識されます。 IF -ステートメント定数 TRUE は。 " }, 
{ "title" : "ローカルで実行される定数伝播 ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4525765239721633833551650952", 
"breadcrumbs" : "CODESYS Static Analysis \/ 定数伝播 \/ 定数伝播 \/ ローカルで実行される定数伝播 ", 
"snippet" : "値は機能ブロック内でローカルにのみ決定されます。入力がどのように渡されるかは関係ありません。関数呼び出しの結果も無関係です。 例 FUNCTION Func : BOOL \/\/Declaration VAR_INPUT bText : BOOL; END_VAR \/\/Implementation IF bTest THEN Func := OtherFunc(TRUE); END_IF パラメータであっても、 bTest に設定されています TRUE すべての呼び出しにおいて、これは定数の伝播には影響しません。たとえ OtherFunc(TRUE) 常に戻ってきます TRUE 、これは定数伝播...", 
"body" : "値は機能ブロック内でローカルにのみ決定されます。入力がどのように渡されるかは関係ありません。関数呼び出しの結果も無関係です。 例 FUNCTION Func : BOOL\n\/\/Declaration\nVAR_INPUT\n bText : BOOL;\nEND_VAR \/\/Implementation\nIF bTest THEN\n Func := OtherFunc(TRUE);\nEND_IF パラメータであっても、 bTest に設定されています TRUE すべての呼び出しにおいて、これは定数の伝播には影響しません。たとえ OtherFunc(TRUE) 常に戻ってきます TRUE 、これは定数伝播には影響しません。 " }, 
{ "title" : "初期値を持つのは一時変数のみです。 ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4505885763755233833526533567", 
"breadcrumbs" : "CODESYS Static Analysis \/ 定数伝播 \/ 定数伝播 \/ 初期値を持つのは一時変数のみです。 ", 
"snippet" : "プログラムやファンクションブロック内の静的ローカル変数には、想定される初期値がありません。変数は最後の呼び出しからの値を保持しているため、原則として「任意」にすることができます。 関数内のローカル変数と一時変数には、呼び出しごとに初期値があります。定数伝播はこの初期値で計算されます。 例 PROGRAM PLC_PRG \/\/Declaration VAR x: INT := 6; bTest: BOOL; END_VAR VAR_TEMP y : INT := 8; END_VAR bText := x < y; 変数 y 毎回実行される PLC_PRG 値は 8 です。変数 x ただし、必ず...", 
"body" : "プログラムやファンクションブロック内の静的ローカル変数には、想定される初期値がありません。変数は最後の呼び出しからの値を保持しているため、原則として「任意」にすることができます。 関数内のローカル変数と一時変数には、呼び出しごとに初期値があります。定数伝播はこの初期値で計算されます。 例 PROGRAM PLC_PRG\n\/\/Declaration\nVAR\n x: INT := 6;\n bTest: BOOL;\nEND_VAR\nVAR_TEMP\n y : INT := 8;\nEND_VAR bText := x < y; 変数 y 毎回実行される PLC_PRG 値は 8 です。変数 x ただし、必ずしもそうではありません。したがって、定数伝播は次の場合にのみ使用されます。 y 値を仮定しますが、 x 。 常に最初に書き込まれてから一時変数として読み取られる変数を宣言することをお勧めします。 " }, 
{ "title" : "定数の伝播により、数値データ型の値の範囲が決まります。 ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078129465633833541363136", 
"breadcrumbs" : "CODESYS Static Analysis \/ 定数伝播 \/ 定数伝播 \/ 定数の伝播により、数値データ型の値の範囲が決まります。 ", 
"snippet" : "複雑さを軽減するために、変数ごとに上限と下限のある値の範囲が決定されます。 例 PROGRAM PLC_PRG VAR x: INT := 6; bTest: BOOL; y : INT; END_VAR \/\/Implementation IF bTest THEN x := 1; ELSSE x := 100; END_IF IF x = 77 THEN y := 13; END_IF ここでの値の範囲は [1..100] 変数に対して決定されます x 。その結果、7 行目で比較が行われます。 x = 77 は定数式として認識されません。 77 値の範囲内です。...", 
"body" : "複雑さを軽減するために、変数ごとに上限と下限のある値の範囲が決定されます。 例 PROGRAM PLC_PRG\nVAR\n x: INT := 6;\n bTest: BOOL;\n y : INT; \nEND_VAR\n \/\/Implementation\nIF bTest THEN\n x := 1;\nELSSE\n x := 100;\nEND_IF\nIF x = 77 THEN\n y := 13;\nEND_IF ここでの値の範囲は [1..100] 変数に対して決定されます x 。その結果、7 行目で比較が行われます。 x = 77 は定数式として認識されません。 77 値の範囲内です。 " }, 
{ "title" : "繰り返し発生する複雑な式は、同じ変数として認識されません。 ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4581954142281633833566535545", 
"breadcrumbs" : "CODESYS Static Analysis \/ 定数伝播 \/ 定数伝播 \/ 繰り返し発生する複雑な式は、同じ変数として認識されません。 ", 
"snippet" : "複雑な式には値が割り当てられていない場合があります。このような式が複数回出現する場合は、補助変数を導入すると便利です。 例 PROGRAM PLC_PRG VAR x: DINT; py : POINTER TO INT; y : INT; testArray : ARRAY [0..4] OF DINT; END_VAR \/\/Implementation IF py^ >= 0 AND py^<= 4 THEN x := testArray[py^]; END_IF y := py^; IF y <= 0 AND y <=4 THEN x := testArray[y]; END_IF 2 ...", 
"body" : "複雑な式には値が割り当てられていない場合があります。このような式が複数回出現する場合は、補助変数を導入すると便利です。 例 PROGRAM PLC_PRG\nVAR\n x: DINT;\n py : POINTER TO INT;\n y : INT; \n testArray : ARRAY [0..4] OF DINT; \nEND_VAR\n \/\/Implementation\nIF py^ >= 0 AND py^<= 4 THEN\n x := testArray[py^];\nEND_IF\ny := py^;\nIF y <= 0 AND y <=4 THEN\n x := testArray[y];\nEND_IF 2 行目では、ポインタが指す領域はチェックされていますが、値へのポインタを介したアクセスの可能性に対してエラーが発行されます。最初に値がローカル変数にコピーされ、その範囲がチェックされると、定数の伝播によってその変数の値の範囲が決定され、7 行目の配列へのアクセスが許可されます。 " }, 
{ "title" : "分岐 ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078204272033833577361725", 
"breadcrumbs" : "CODESYS Static Analysis \/ 定数伝播 \/ 定数伝播 \/ 分岐 ", 
"snippet" : "分岐の場合、個々の分岐は個別に計算されます。次に、個々の範囲の値範囲が結合されて、新しい値範囲が形成されます。 例 \/\/Implementation IF func(TRUE) THEN x := 1; ELSE x := 10; END_IF IF func(FALSE) THEN y := x; ELSE Y := 2*x; END_IF 6行目で、 x 範囲があります [1..10] 。 11行目以降、 y 値の範囲があります [1..20] ;これは 2 つの値の範囲を結合した結果です [1..10] そして [2..20] 。...", 
"body" : "分岐の場合、個々の分岐は個別に計算されます。次に、個々の範囲の値範囲が結合されて、新しい値範囲が形成されます。 例 \/\/Implementation\nIF func(TRUE) THEN\n x := 1;\nELSE \n x := 10;\nEND_IF\n\nIF func(FALSE) THEN\n y := x;\nELSE\n Y := 2*x;\nEND_IF 6行目で、 x 範囲があります [1..10] 。 11行目以降、 y 値の範囲があります [1..20] ;これは 2 つの値の範囲を結合した結果です [1..10] そして [2..20] 。 " }, 
{ "title" : "条件 ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4505886343398433833583258632", 
"breadcrumbs" : "CODESYS Static Analysis \/ 定数伝播 \/ 定数伝播 \/ 条件 ", 
"snippet" : "例 条件により、コード ブロック内の変数の値の範囲を制限できます。いくつかの条件を組み合わせることができます。相互に排他的な条件により、値の範囲が空になる場合もあります。 IF y > 0 AND y < 10 THEN x := y; ELSE x:= 0; END_IF IF x < 0 THEN i := 99; END_IF y には値の範囲があります [1..9] 2 行目。これにより、値の範囲が決まります。 [0..9] のために x 6行目。条件と組み合わせる x < 0 、これにより、可能な値の空のセットが得られます。 x 8 行目。コードにアクセスできません。静的解析では、次...", 
"body" : "例 条件により、コード ブロック内の変数の値の範囲を制限できます。いくつかの条件を組み合わせることができます。相互に排他的な条件により、値の範囲が空になる場合もあります。 IF y > 0 AND y < 10 THEN\n x := y;\nELSE\n x:= 0;\nEND_IF\nIF x < 0 THEN\n i := 99;\nEND_IF y には値の範囲があります [1..9] 2 行目。これにより、値の範囲が決まります。 [0..9] のために x 6行目。条件と組み合わせる x < 0 、これにより、可能な値の空のセットが得られます。 x 8 行目。コードにアクセスできません。静的解析では、次のような状態がレポートされます。 x < 0 常に戻ってきます FALSE この時点で。 " }, 
{ "title" : "ループ ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4649940201660833833593476437", 
"breadcrumbs" : "CODESYS Static Analysis \/ 定数伝播 \/ 定数伝播 \/ ループ ", 
"snippet" : "定数の伝播では、ループ内の変数の値が変更されなくなるまでコードがループされます。ループは何度でも実行できると想定されています。これまでに決定された値は、以前の値と結合されます。ループ内で変更される変数の範囲は連続的に増加します。ここで、定数の伝播では範囲のすべての可能な値を取得するのではなく、コード内で発生する制限のみを使用し、値 0、1、2、3、および 10 も使用します。これは、これらの値が関連することが多いためです。 例 手順を説明する最も簡単な方法は、次の例です。 PROGRAM PLC_PRG VAR x: DINT; i : DINT; y : DINT; END_VAR \/\/Im...", 
"body" : "定数の伝播では、ループ内の変数の値が変更されなくなるまでコードがループされます。ループは何度でも実行できると想定されています。これまでに決定された値は、以前の値と結合されます。ループ内で変更される変数の範囲は連続的に増加します。ここで、定数の伝播では範囲のすべての可能な値を取得するのではなく、コード内で発生する制限のみを使用し、値 0、1、2、3、および 10 も使用します。これは、これらの値が関連することが多いためです。 例 手順を説明する最も簡単な方法は、次の例です。 PROGRAM PLC_PRG\nVAR\n x: DINT;\n i : DINT;\n y : DINT;\nEND_VAR \/\/Implementation\nx := 0;\ny := 0;\nFOR i := 0 TO 5 DO\n x := x + 1;\n y := i;\nEND_FOR 定数の伝播では、ループについて次のことがわかります。 i 、 x 、 そして y ループの最初の実行の開始時には 0 です。条件 i <= 5 ループ内のコードに適用されます。条件 i > 5 ループ後のコードに適用されます。 ループ内の変数の値については、定数の伝播によって次の値が決定されます。 i x y [0..5] [0..MAXDINT] [0..5] 詳細には、次の中間ステップが実行されます。 合格 i x y 1 0 [0..1] 0 i 0 で初期化されました。 y は常に i と同じ値を取得します。 2 [0..1] [0..2] [0..1] 6 [0..5] [0..6] [0..5] まずは範囲 [0..6] 実際に計算されるのは i 。ただし、知られているのは、 i < 5 が条件です。したがって、ループ内のコードの値はこの値に制限されます。 7 [0..5] [0..7] [0..5] 10 [0..5] [0..10] [0..5] x どんどん増えていきます。から 10 ただし、値は「切り上げ」られます。 MAXINT 。 11 [0..5] [0..MAXDINT] [0..5] MAXDINT + 1 結果として MAXDINT 11日現在 11 回目のパス以降、ループ内の値は変更されません。伝播は終了します。 さらに、 i = 6 このループに続くコードに適用されます。範囲 [0..6] ループ内で決定され、これが条件と組み合わされます。 i > 5 、その結果は正確に値 6 になります。 " }, 
{ "title" : "参照：ユーザーインターフェイス ", 
"url" : "_san_f_reference_user_interface.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド ", 
"url" : "_san_struct_reference_commands.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ コマンド ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド：関数の抽出 ", 
"url" : "_san_cmd_extract_function.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ コマンド \/ コマンド：関数の抽出 ", 
"snippet" : "抽出機能 関数 ：コマンドはダイアログを開きます 関数抽出の構成 。 このコマンドは、STエディターから選択したコードの場所を抽出し、このコードを含む新しいメソッドまたは関数を作成します。 STエディターで影響を受けるコードは、正しい呼び出しに置き換えられます。関数ブロックまたは関数ブロックの子からコードが抽出されると、コードから新しいメソッドが作成されます。プログラムまたは関数からコードを抽出すると、そのコードから新しい関数が作成されます。 この文脈でも注意してください： コードクローンの検出電話 ： コンテキストメニュー リファクタリング 要件 、選択したコードが1つ以上のステートメントで...", 
"body" : "抽出機能 関数 ：コマンドはダイアログを開きます 関数抽出の構成 。 このコマンドは、STエディターから選択したコードの場所を抽出し、このコードを含む新しいメソッドまたは関数を作成します。 STエディターで影響を受けるコードは、正しい呼び出しに置き換えられます。関数ブロックまたは関数ブロックの子からコードが抽出されると、コードから新しいメソッドが作成されます。プログラムまたは関数からコードを抽出すると、そのコードから新しい関数が作成されます。 この文脈でも注意してください： コードクローンの検出電話 ： コンテキストメニュー リファクタリング 要件 、選択したコードが1つ以上のステートメントで構成されている場合： 選択したコードに変換エラーは含まれていません 選択したコードは、STプログラミングブロックの実装部分にあります 選択したコードに発信ジャンプが含まれていません アウトバウンドジャンプの例は次のとおりです。 周囲の機能を RETURN コードを囲むループを終了します CONTINUE また EXIT あなたはコマンドによってそれを行うことができます 抽出機能 デバイスツリーにカーソルを置き、コマンドを実行して、プロジェクトで行った変更を元に戻します。 編集→元に戻す 選択する。 ダイアログ 関数抽出の構成 姓 新しく作成された関数またはメソッドの名前 デフォルトで入力されている名前は変更できます。 戻り値 複数の出力および\/または入出力パラメーターがある場合の関数の戻り値の決定 パラメータ 利用可能なPOUの表示 パラメーターを入力変数、出力変数、または入出力変数として使用するかどうかの構成 ：入力変数 ：出力変数 ：入出力変数 で 姓 、 戻り値 また パラメータ 加えられた変更は取り消されます。 上部コードウィンドウ 新しく作成された呼び出しポイントのコード 下のコードウィンドウ 関数またはメソッドの新しく作成されたコード わかった 表示されたコード変更はSTブロックに採用され、ダイアログが閉じます。 割り込み 表示されたコード変更は破棄され、ダイアログが閉じます。 " }, 
{ "title" : "コマンド: IF ステートメントを反転する ", 
"url" : "_san_cmd_invert_if_statement.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ コマンド \/ コマンド: IF ステートメントを反転する ", 
"snippet" : "IF ステートメントを反転する 関数 : このコマンドは、 IF のセマンティクスを変更せずにステートメントを作成します。 IF 声明。条件は否定されます。の声明は、 THEN そして ELSE 枝が入れ替わる。すべてのコメントは保持されます。 電話 : 下のコンテキストメニュー リファクタリング 指示 要件: カーソルが任意の場所に配置されている 内で の IF 声明。 否定のルール 表現 否定表現 説明 < >= 「より小さい」の比較は「より大きい」になり、その逆も同様です。 <= > 「以下」の比較は「より大きい」になり、その逆も同様です。 = <> 「等しい」の比較は「等しくない」にな...", 
"body" : "IF ステートメントを反転する 関数 : このコマンドは、 IF のセマンティクスを変更せずにステートメントを作成します。 IF 声明。条件は否定されます。の声明は、 THEN そして ELSE 枝が入れ替わる。すべてのコメントは保持されます。 電話 : 下のコンテキストメニュー リファクタリング 指示 要件: カーソルが任意の場所に配置されている 内で の IF 声明。 否定のルール 表現 否定表現 説明 < >= 「より小さい」の比較は「より大きい」になり、その逆も同様です。 <= > 「以下」の比較は「より大きい」になり、その逆も同様です。 = <> 「等しい」の比較は「等しくない」になり、その逆も同様です。 <表現1> AND <表現2> ( NOT <表現1> ) OR ( NOT <表現2> ) ド・モルガンによれば、否定は AND オペレーター <表現1> OR <表現2> (NOT <表現1> ) AND (NOT <表現2> ) ド・モルガンによれば、否定は OR オペレーター <表現> NOT <表現> 標準の否定 NOT <表現> <表現> ダブルなし NOT 表現 a (*コメント*) = b a (*コメント*) <> b コメントは保持されます。これは特にスワップされたオペランドに当てはまります 例 PROGRAM Inversion1\nVAR\n xA, xB, xC : BOOL;\n iVar : INT;\nEND_VAR iVar := 0;\nIF NOT(xA AND xB AND xC) THEN\n\tiVar:= 1; (* IF 1 *)\nELSE\n\tiVar := iVar + 1; (* ELSE counter*)\nEND_IFiVar := 0;\n 同じセマンティクスの反転ロジックでコマンドを呼び出した後のコード: iVar := 0;\nIF (xA AND xB AND xC) THEN\n iVar := iVar + 1; (* ELSE counter*)\nELSE\n iVar:= 1; (* IF 1 *)\nEND_IF " }, 
{ "title" : "コマンド: 現在のエディタの定数伝播の値を表示 ", 
"url" : "_san_cmd_show_values_of_constant_propagation_for_current_editor.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ コマンド \/ コマンド: 現在のエディタの定数伝播の値を表示 ", 
"snippet" : "現在のエディタの定数伝播の値を表示 シンボル： 関数 : このコマンドは静的コード分析を開始し、現在のエディターでのコードの定数伝播の測定値を計算します。ダイアログが開き、結果が視覚化されます。解析されたコードが一覧表示され、求められた測定値が表示されます。 電話 : ビルド → 静的解析 メニュー 要件 : ST 実装言語のプログラミング オブジェクトがエディターで開かれています。 詳細については、以下を参照してください。 定数伝播...", 
"body" : "現在のエディタの定数伝播の値を表示 シンボル： 関数 : このコマンドは静的コード分析を開始し、現在のエディターでのコードの定数伝播の測定値を計算します。ダイアログが開き、結果が視覚化されます。解析されたコードが一覧表示され、求められた測定値が表示されます。 電話 : ビルド → 静的解析 メニュー 要件 : ST 実装言語のプログラミング オブジェクトがエディターで開かれています。 詳細については、以下を参照してください。 定数伝播" }, 
{ "title" : "ダイアログ: 定数伝播の結果 ", 
"url" : "_san_cmd_show_values_of_constant_propagation_for_current_editor.html#UUID-948900c6-97a3-c88d-ff29-bca9a5de0d7b_section-idm4549177267643233866303721891", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ コマンド \/ コマンド: 現在のエディタの定数伝播の値を表示 \/ ダイアログ: 定数伝播の結果 ", 
"snippet" : "例...", 
"body" : "例 " }, 
{ "title" : "コマンド：静的解析を実行します ", 
"url" : "_san_cmd_run_static_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ コマンド \/ コマンド：静的解析を実行します ", 
"snippet" : "静的分析を実行します シンボル： 関数 ：このコマンドは、アクティブなアプリケーションの静的コード分析を開始し、すべてのプログラミングブロックのメトリックをテーブルに表示します。 電話 ：メニュー 作成→静的分析 コード分析をリード CODESYS Static Analysis コマンドによる、およびコマンドによるコード生成 ビルド→コードの生成 。分析結果は、カテゴリのメッセージウィンドウに表示されます 翻訳すること 間違いとして と警告 発行済み。番号は対応するものを参照しています ルール 、プロジェクト設定で定義されているとおり。メッセージ出力の構文は次のとおりです。 SA <ルール番...", 
"body" : "静的分析を実行します シンボル： 関数 ：このコマンドは、アクティブなアプリケーションの静的コード分析を開始し、すべてのプログラミングブロックのメトリックをテーブルに表示します。 電話 ：メニュー 作成→静的分析 コード分析をリード CODESYS Static Analysis コマンドによる、およびコマンドによるコード生成 ビルド→コードの生成 。分析結果は、カテゴリのメッセージウィンドウに表示されます 翻訳すること 間違いとして と警告 発行済み。番号は対応するものを参照しています ルール 、プロジェクト設定で定義されているとおり。メッセージ出力の構文は次のとおりです。 SA <ルール番号>：<ルールテキスト> 。 " }, 
{ "title" : "コマンド：設定 ", 
"url" : "_san_cmd_settings.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ コマンド \/ コマンド：設定 ", 
"snippet" : "アイデア 関数 ：コマンドはダイアログを開きます 設定静的分析 。 電話 ：メニュー 作成→静的分析 要件 ： その包み CODESYS Static Analysis がインストールされています。 プロジェクトが開いています...", 
"body" : "アイデア 関数 ：コマンドはダイアログを開きます 設定静的分析 。 電話 ：メニュー 作成→静的分析 要件 ： その包み CODESYS Static Analysis がインストールされています。 プロジェクトが開いています " }, 
{ "title" : "コマンド: 標準メトリックの表示 ", 
"url" : "_san_cmd_view_standard_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ コマンド \/ コマンド: 標準メトリックの表示 ", 
"snippet" : "デフォルトの指標を表示する シンボル： 関数 : このコマンドは、アクティブなアプリケーションの静的コード分析を開始します。すべてのプログラミング ブロックのデフォルトのメトリクスが計算され、画面上の表に表示されます。 標準指標 タブ。 電話 : ビルド → 静的解析 メニュー 詳細については、以下を参照してください。 指標を表示するメトリクス...", 
"body" : "デフォルトの指標を表示する シンボル： 関数 : このコマンドは、アクティブなアプリケーションの静的コード分析を開始します。すべてのプログラミング ブロックのデフォルトのメトリクスが計算され、画面上の表に表示されます。 標準指標 タブ。 電話 : ビルド → 静的解析 メニュー 詳細については、以下を参照してください。 指標を表示するメトリクス" }, 
{ "title" : "タブ: 標準メトリクス ", 
"url" : "_san_cmd_view_standard_metrics.html#UUID-c2310f81-c613-bf67-ba1e-4f10694a38a1_section-idm4622240725232033866114829692", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ コマンド \/ コマンド: 標準メトリックの表示 \/ タブ: 標準メトリクス ", 
"snippet" : "例 の中に 静的分析設定: メトリクス ダイアログで、メトリクスの構成を変更できます。メトリックの計算を無効にすることができます。また、特定のメトリクスに対して制限値を定義できます。 値が構成された上限と下限の範囲外にある場合、テーブル内のフィールドが赤色で強調表示されます。 テーブルのコンテキスト メニューには次のコマンドが用意されています。 計算する 値を更新します テーブルのコピー テーブルをクリップボードにコピーします 区切り文字はタブです。 印刷テーブル 印刷ジョブを設定するためのデフォルトのダイアログを開きます エクスポートテーブル テーブルを CSV ファイルにエクスポートします...", 
"body" : "例 の中に 静的分析設定: メトリクス ダイアログで、メトリクスの構成を変更できます。メトリックの計算を無効にすることができます。また、特定のメトリクスに対して制限値を定義できます。 値が構成された上限と下限の範囲外にある場合、テーブル内のフィールドが赤色で強調表示されます。 テーブルのコンテキスト メニューには次のコマンドが用意されています。 計算する 値を更新します テーブルのコピー テーブルをクリップボードにコピーします 区切り文字はタブです。 印刷テーブル 印刷ジョブを設定するためのデフォルトのダイアログを開きます エクスポートテーブル テーブルを CSV ファイルにエクスポートします 区切り文字はセミコロンです。 キビアト図 要件: 上限と下限が定義されている少なくとも 3 つのメトリックが有効になっています。 選択した機能ブロックのメトリクスをレーダー チャートとして表します これにより、特定の標準に対する POU コードの品質が視覚化されます。 各メトリックは、中心（値0）から始まり、円の3つのリングゾーンを通って外側に伸びる軸として円で表されます。内側のリングゾーンは、メトリックに定義された下限より下の値の範囲を表し、外側のリングゾーンは上限より上です。影響を受けるメトリックの軸は、円上に均等に分散されます。 軸上の個々のメトリックの現在の値は線で接続されており、理想的には線全体が中央の円ゾーンにあります。 構成、設定 テーブルを開いて、必要なメトリクスを選択します これはプロジェクト設定のテーブルに対応します。 POUを開く POU を含むエディターを開きます 例 5つのメトリックのKiviatチャートの例 メトリックの名前は軸の端にあり、モジュールの名前は右上にあります。 " }, 
{ "title" : "コマンド: 標準メトリクスを計算してエクスポートする ", 
"url" : "_san_calculate_and_export_standard_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ コマンド \/ コマンド: 標準メトリクスを計算してエクスポートする ", 
"snippet" : "標準メトリクスの計算とエクスポート 機能: エディターにメトリック テーブルを表示せずに、標準メトリックを直接計算してエクスポートします。標準のファイルダイアログでCSVエクスポートファイルの適切な名前を指定します。 呼び出し: このコマンドは、デフォルトではどのメニューでも使用できません。 あるいは、 標準メトリクスを表示する コマンドを使用してエディターにメトリクスを表示します。とりわけ、エディターは以下を提供します。 エクスポートテーブル コンテキストコマンド。 メニューのカスタマイズ コマンドの提供 クリック ツール → カスタマイズ 。 の メニュー タブが開きます。まず、コマンドの...", 
"body" : "標準メトリクスの計算とエクスポート 機能: エディターにメトリック テーブルを表示せずに、標準メトリックを直接計算してエクスポートします。標準のファイルダイアログでCSVエクスポートファイルの適切な名前を指定します。 呼び出し: このコマンドは、デフォルトではどのメニューでも使用できません。 あるいは、 標準メトリクスを表示する コマンドを使用してエディターにメトリクスを表示します。とりわけ、エディターは以下を提供します。 エクスポートテーブル コンテキストコマンド。 メニューのカスタマイズ コマンドの提供 クリック ツール → カスタマイズ 。 の メニュー タブが開きます。まず、コマンドのメニュー位置を定義する必要があります。この場合、次の項目を選択するのが合理的です。 ビルド → 静的解析 メニュー。 希望の位置を選択し、 コマンドの追加 ボタン。 すべてのコマンドは次のとおりです。 コマンドの追加 ダイアログ。 を選択 静的解析 左側でカテゴリを選択し、右側で目的のコマンドを選択します。クリック わかりました をクリックしてダイアログを閉じます。次にクリックします わかりました もう一度閉じます カスタマイズ ダイアログ。 の 標準メトリクスの計算とエクスポート コマンドは現在、 ビルド → 静的解析 メニュー。 " }, 
{ "title" : "コマンド：クローンを検索 ", 
"url" : "_san_cmd_find_clones.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ コマンド \/ コマンド：クローンを検索 ", 
"snippet" : "クローンを探す 関数 ：コマンドは、オープンのプログラムコードを検索します CODESYS -コピーされたコードのプロジェクトとビューを開きます 検索結果のクローンを作成する 見つかったクローンコードブロックを表示します。特定のサイズより大きいコードのブロックのみがクローンと見なされます。非常に小さなコードはクローンとして表示されません。 この点にも注意してください 抽出機能 と指示 コードクローンの検出。 電話 ： メニュー 作成→静的分析 コンテキストメニュー 静的解析 要件 ： CODESYS Static Analysis -プロジェクトは開いています。 次のプロパティがある場合、2つ...", 
"body" : "クローンを探す 関数 ：コマンドは、オープンのプログラムコードを検索します CODESYS -コピーされたコードのプロジェクトとビューを開きます 検索結果のクローンを作成する 見つかったクローンコードブロックを表示します。特定のサイズより大きいコードのブロックのみがクローンと見なされます。非常に小さなコードはクローンとして表示されません。 この点にも注意してください 抽出機能 と指示 コードクローンの検出。 電話 ： メニュー 作成→静的分析 コンテキストメニュー 静的解析 要件 ： CODESYS Static Analysis -プロジェクトは開いています。 次のプロパティがある場合、2つのコードはクローンと見なされます。 同じ構造設計 変数のデータ型は同じです 変数名は異なる場合があります（例外：コンポーネントアクセス）。ただし、コードに複数回含まれている識別子は、両方のコードで同じ位置にある必要があります。 リテラルのデータ型は同じです リテラルは異なる場合があります。コードに複数回出現するリテラルは、両方のコードの同じ位置に出現する必要があります。 意見 検索結果のクローンを作成する まとめ 検索結果を表示するためのタブ 見つかった複製されたコードブロックの数 比較されたステートメントの数 複製されたコード内のステートメントの数 クローン部分 ：パーセントでの仕様： 複製されたコード内のステートメントの数 \/ 比較されたステートメントの数 結果 タブでは、コードクローンがツリービューに表示され、コマンドとフィルターオプションを使用できます。 重複のセットから重複が最初に発生した場合は、ルートノードと見なされます。子ノードの背景色は、コードが異なるか同一かを表します。同じ色は「同じコード」を意味します。ツリービューの内容は、重複したコード内のステートメントの数の降順で並べ替えられます。 タブ内のコマンドとフィルター 結果 サブモジュール\/クローン コードブロック内のサブモジュール（命令）の数 サブモジュールの数が20未満の場合、コードクローンは考慮されません。 オブジェクトでフィルタリング の入力フィールド 物体 、クローンのコレクションがフィルタリングされます 選択したクローンを表示する 要件：同じ親ノードの2つの子ノードが選択されている。 比較のために、2つのプログラミングオブジェクトがビューの上部に表示されます。コードの重複はマークされ、相違点（異なる変数名など）は異なる色で強調表示されます。 コードクローンのリスト 列 説明 サブモジュール\/クローン 物体 ポジション 子ノードをダブルクリックすると、対応するプログラミングオブジェクトが開き、重複したコードブロックが選択されます。 " }, 
{ "title" : "コマンド: 現在のエディターの認知的複雑性を表示 ", 
"url" : "_san_cmd_show_cognitive_complexity_for_current_editor.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ コマンド \/ コマンド: 現在のエディターの認知的複雑性を表示 ", 
"snippet" : "現在のエディターの認知的複雑性を表示 シンボル： 関数 : このコマンドは静的コード分析を開始し、現在のエディターでのコードの認知的複雑さの測定値を計算します。開いたダイアログでは結果が視覚化され、タイトルに測定値の合計が指定されます。分析されたコードがリストされ、検出された複雑さとともに表示されます。 電話 : ビルド → 静的解析 メニュー 要件 : ST 実装言語のプログラミング オブジェクトがエディターで開かれています。...", 
"body" : "現在のエディターの認知的複雑性を表示 シンボル： 関数 : このコマンドは静的コード分析を開始し、現在のエディターでのコードの認知的複雑さの測定値を計算します。開いたダイアログでは結果が視覚化され、タイトルに測定値の合計が指定されます。分析されたコードがリストされ、検出された複雑さとともに表示されます。 電話 : ビルド → 静的解析 メニュー 要件 : ST 実装言語のプログラミング オブジェクトがエディターで開かれています。 " }, 
{ "title" : "ダイアログ: <POU 名> の認知複雑度: <計算された測定値> ", 
"url" : "_san_cmd_show_cognitive_complexity_for_current_editor.html#UUID-315a7cbe-83be-ba91-4d86-234b9f3e6fc3_section-idm4549177267643233866303721891", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ コマンド \/ コマンド: 現在のエディターの認知的複雑性を表示 \/ ダイアログ: <POU 名> の認知複雑度: <計算された測定値> ", 
"snippet" : "例...", 
"body" : "例 " }, 
{ "title" : "コマンド:静的解析を実行して SARIF ファイルにエクスポート ", 
"url" : "_san_cmd_run_and_export_to_sarif_file.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ コマンド \/ コマンド:静的解析を実行して SARIF ファイルにエクスポート ", 
"snippet" : "静解析を実行して SARIFファイルにエクスポート シンボル: ファンクション : このコマンドは静的コード解析を開始し、結果を SARIF ファイルに保存します。 電話 : ビルド → 静的解析 メニュー SARIF ファイル (」 スタティック解析結果交換フォーマット 「) はファイル拡張子が\" の付いた、機械で読み取り可能な JSON ファイルです。 *.sarif.json 「」は、結果を標準化された形式で保存するためにスタティック・アナリシスによって作成されます。 SARIFはオアシスの標準です。つまり、さまざまなツールやプラットフォームがこれを使用して分析結果を交換したり処理したり...", 
"body" : "静解析を実行して SARIFファイルにエクスポート シンボル: ファンクション : このコマンドは静的コード解析を開始し、結果を SARIF ファイルに保存します。 電話 : ビルド → 静的解析 メニュー SARIF ファイル (」 スタティック解析結果交換フォーマット 「) はファイル拡張子が\" の付いた、機械で読み取り可能な JSON ファイルです。 *.sarif.json 「」は、結果を標準化された形式で保存するためにスタティック・アナリシスによって作成されます。 SARIFはオアシスの標準です。つまり、さまざまなツールやプラットフォームがこれを使用して分析結果を交換したり処理したりできるということです " }, 
{ "title" : "コマンドラインコマンド ", 
"url" : "_san_cmd_run_and_export_to_sarif_file.html#UUID-b1a6530c-4103-8c37-7a9e-f6ad763d2402_section-idm235003337576496", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ コマンド \/ コマンド:静的解析を実行して SARIF ファイルにエクスポート \/ コマンドラインコマンド ", 
"snippet" : "コマンドは次の方法で自動的に実行することもできます CODESYS Scripting 。バッチコマンド [\"staticanalysis\", \"runandexportosarif\"] 以下の引数を受け入れます。 引数: --sariffile --sariffile=<path to output>; 生成される SARIF ファイルを書き込むパスを指定します。パスを指定しない場合、ファイルは現在のプロジェクトのフォルダーに保存されます 引数: --rulesfile --rulesfile=<patch to CSA file>; スタティック解析に使用する CSA ファイルへのパスを指...", 
"body" : "コマンドは次の方法で自動的に実行することもできます CODESYS Scripting 。バッチコマンド [\"staticanalysis\", \"runandexportosarif\"] 以下の引数を受け入れます。 引数: --sariffile --sariffile=<path to output>; 生成される SARIF ファイルを書き込むパスを指定します。パスを指定しない場合、ファイルは現在のプロジェクトのフォルダーに保存されます 引数: --rulesfile --rulesfile=<patch to CSA file>; スタティック解析に使用する CSA ファイルへのパスを指定します。パスを指定しない場合、現在の設定が使用されます Python スクリプトでの呼び出しの例 system.commands[\"staticanalysis\", \"runandexportosarif\"].execute(\"--sariffile=result.sarif\", \"--rulesfile=rules.csa\") " }, 
{ "title" : "コマンド: フォーマット ", 
"url" : "_san_cmd_format.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ コマンド \/ コマンド: フォーマット ", 
"snippet" : "フォーマット デバッグモード この機能は、 CODESYS インスタンスはデバッグ モードで起動されます。 これを行うには、次のコマンドライン呼び出しでインスタンスを起動します。 codesys.exe --debug 関数 : このコマンドは、で設定されたルールに従って ST オブジェクトをフォーマットします。 CODESYS コードの可読性を向上させるためのオプション。 電話 : 下のコンテキスト メニュー リファクタリング メニュー 要件: ST エディターが開いており、カーソルが宣言または実装内にあります。 詳細については、以下を参照してください。 オートフォーマッタ...", 
"body" : "フォーマット デバッグモード この機能は、 CODESYS インスタンスはデバッグ モードで起動されます。 これを行うには、次のコマンドライン呼び出しでインスタンスを起動します。 codesys.exe --debug 関数 : このコマンドは、で設定されたルールに従って ST オブジェクトをフォーマットします。 CODESYS コードの可読性を向上させるためのオプション。 電話 : 下のコンテキスト メニュー リファクタリング メニュー 要件: ST エディターが開いており、カーソルが宣言または実装内にあります。 詳細については、以下を参照してください。 オートフォーマッタ" }, 
{ "title" : "対話 ", 
"url" : "_san_struct_reference_dialogs.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ 対話 ", 
"snippet" : "静的コード分析を構成するためのダイアログは、次の場所にあります。 ビルド→静的分析→設定 。前提条件として、 CODESYS -プロジェクトはオープンです。...", 
"body" : "静的コード分析を構成するためのダイアログは、次の場所にあります。 ビルド→静的分析→設定 。前提条件として、 CODESYS -プロジェクトはオープンです。 " }, 
{ "title" : "ダイアログ：設定静的解析：設定 ", 
"url" : "_san_dlg_settings_static_analysis_settings.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ 対話 \/ ダイアログ：設定静的解析：設定 ", 
"snippet" : "設定 関数 ：ダイアログで自動をアクティブにします 静的コード分析 静的コード分析用のプロジェクト設定をCSAファイルとして保存またはロードします。 ボタン 構成ダイアログを開く の プロジェクト→プロジェクト設定 、 カテゴリー 静的コード分析 メニュー ビルド→静的分析→設定 要件 ： その包み CODESYS Static Analysis インストールされています プロジェクトが開いています 静的解析を自動的に実行します ： CODESYS Static Analysis コマンドが実行されるときなど、コードが生成されるたびにコードチェックを自動的に実行します ビルド→コードの生成 ま...", 
"body" : "設定 関数 ：ダイアログで自動をアクティブにします 静的コード分析 静的コード分析用のプロジェクト設定をCSAファイルとして保存またはロードします。 ボタン 構成ダイアログを開く の プロジェクト→プロジェクト設定 、 カテゴリー 静的コード分析 メニュー ビルド→静的分析→設定 要件 ： その包み CODESYS Static Analysis インストールされています プロジェクトが開いています 静的解析を自動的に実行します ： CODESYS Static Analysis コマンドが実行されるときなど、コードが生成されるたびにコードチェックを自動的に実行します ビルド→コードの生成 またはダウンロード前。 ：コードチェックは自動的には実行されませんが、コマンドを使用して明示的に実行できます ビルド→静的分析→静的分析の実行 実行されます。 ロード 標準ダイアログを開きます 静的解析の負荷構成 静的分析のプロジェクト設定をファイルシステムからcsaファイルとしてロードします。ボタンをクリックすると 開ける クリックすると、選択したcsaファイルがロードされます。 コンピューターに保存 標準ダイアログを開きます 静的解析の構成を保存します カテゴリのすべてのプロジェクト設定を保存します 静的コード分析 ファイルシステムのcsaファイルとして。 " }, 
{ "title" : "ダイアログ：静的解析設定：ルール ", 
"url" : "_san_dlg_settings_sa_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ 対話 \/ ダイアログ：静的解析設定：ルール ", 
"snippet" : "ルール 関数 ：ダイアログで、 ルール プロジェクトのソースコードの静的分析中にチェックされます。これに関する詳細情報： 静的コード分析を構成して実行する詳細については、以下を参照してください。 静的コード分析を構成して実行する電話 ： ボタン 構成ダイアログを開く メニューで プロジェクト→プロジェクト設定 、 カテゴリー 静的コード分析 メニュー ビルド→静的分析→設定 要件 ： The CODESYS Static Analysis パッケージがインストールされます。 プロジェクトが開いています このタブには、静的コード分析中にチェックできるすべてのルールがツリー構造で表示されます。デフ...", 
"body" : "ルール 関数 ：ダイアログで、 ルール プロジェクトのソースコードの静的分析中にチェックされます。これに関する詳細情報： 静的コード分析を構成して実行する詳細については、以下を参照してください。 静的コード分析を構成して実行する電話 ： ボタン 構成ダイアログを開く メニューで プロジェクト→プロジェクト設定 、 カテゴリー 静的コード分析 メニュー ビルド→静的分析→設定 要件 ： The CODESYS Static Analysis パッケージがインストールされます。 プロジェクトが開いています このタブには、静的コード分析中にチェックできるすべてのルールがツリー構造で表示されます。デフォルトでは、SA0016、SA0024、SA0073、SA0101、SA0105、SA0106、SA0133、SA0134、SA0150、SA0162、およびすべての「IEC厳密ルール」を除くすべてのルールが有効になっています。 各ルールには一意の番号があります。ルールチェックの結果が一致した場合、ルール番号とエラーの説明がカテゴリのメッセージウィンドウに表示されます。 翻訳すること 次の形式で発行されます。 SA <ルール番号> 、「SA」は「静的分析」を意味します。例：ルール番号3の「SA003」。 使用可能なルールのリストは、特定のプラグインによって拡張できます。 フィルター 検索する文字列の入力フィールド ルールはカテゴリごとにグループ化されています。 重要度別に構造化 : 並べ替え順 重要度高 、 重要度中程度 、 そして 重要度が低い デフォルト : のルールのデフォルト構造 CODESYS Static Analysis : ルールはフラット リストとして表示されます。対応する列ヘッダーをクリックすると、ルール番号、アクティブ化\/非アクティブ化、ルール固有の構成、または重要度によってリストを並べ替えることができます。 ここでダイアログでアクティブ化されるいくつかのルールは、 プラグマ アプリケーションで一時的にオフになっています チェックボックスをクリックすると、設定が切り替わります。 、 と 。 ノードをアクティブ化または非アクティブ化すると、このノードの下にあるすべてのルールもアクティブ化または非アクティブ化されます。 列 ルール ルール番号付きのルールのリスト ルールの検討 ：ルールはチェックされません。 ：テスト結果が陽性の場合、メッセージウィンドウにaが表示されます 静的コード分析エラーがスローされました。 ：テスト結果が陽性の場合、 静的コード分析の警告が発行されました。 コンパイル前 事前コンパイル中にチェックできるルールは、この列でチェックされます マークされた。 プリコンパイル中にチェックできるルールは、チェック マーク ( ) このコラムでは。これは、コードが入力されたときにルールがすでにチェックされていることを意味します。 これらのルールでは、迅速なエラー訂正（迅速な修正）の可能性があります。影響を受けるコードに対して直接、自動で即時のエラー処理を実行できます。 : マークされていないルールは、コンパイルが成功した後にのみチェックされます。 ルール固有の構成 一部のルールでは、フィールドをダブルクリックすると、ルールを構成するためのルール固有のダイアログが開きます。 重要性 ルールの重要性： 3つの赤い星：高い 2つのオレンジ色の星：中 1灰色の星：低い " }, 
{ "title" : "ダイアログ：静的解析設定：命名規則 ", 
"url" : "_san_dlg_settings_sa_naming_conventions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ 対話 \/ ダイアログ：静的解析設定：命名規則 ", 
"snippet" : "命名規則 関数 ：対話で 定義 データ型と変数スコープのプレフィックス、およびPOUとユーザー定義データ型（DUT）のプレフィックス。 the 遵守 命名規則の一部は、静的コード分析によってチェックされます。規則に違反すると、静的コード分析のビューにエラーメッセージが表示されます メッセージ 表示されます。これに関する詳細情報： 静的コード分析を構成して実行する電話 ： ボタン 構成ダイアログを開く メニューで プロジェクト→プロジェクト設定 、 カテゴリー 静的コード分析 メニュー ビルド→静的分析→設定 要件 ： その包み CODESYS Static Analysis インストールされて...", 
"body" : "命名規則 関数 ：対話で 定義 データ型と変数スコープのプレフィックス、およびPOUとユーザー定義データ型（DUT）のプレフィックス。 the 遵守 命名規則の一部は、静的コード分析によってチェックされます。規則に違反すると、静的コード分析のビューにエラーメッセージが表示されます メッセージ 表示されます。これに関する詳細情報： 静的コード分析を構成して実行する電話 ： ボタン 構成ダイアログを開く メニューで プロジェクト→プロジェクト設定 、 カテゴリー 静的コード分析 メニュー ビルド→静的分析→設定 要件 ： その包み CODESYS Static Analysis インストールされています プロジェクトが開いています エラーメッセージは次の形式になっています NC <Präfix-Konventionsnummer> : <Meldungstext> 表示されます。 NCはネーミングコンベンションの略です。たとえば、エラーメッセージは NC0102：名前が無効です。。。 タイプのPOUの命名規則102の違反 PROGRAM 。 あなたはシングルのためにできます 識別子 プラグマを使用した命名規則 'naming' 非アクティブ化します。その後、識別子は自由に開始できますが、必ずしもプレフィックスで開始する必要はありません。 フィルター 検索する文字列の入力フィールド 命名規則の表 名前 プレフィックスを定義できるノードと要素 たとえば、各項目の後の括弧内の数字 プログラム（102） 、は、命名規則に違反した場合に返されるプレフィックス規則番号です。 プレフィックス プレフィックスの入力フィールド 複数のプレフィックスをコンマで区切って入力できます。 例： POUのプレフィックス 、 PROGRAM (102) ： prog, PRG_ POUのプレフィックス 、 FUNCTION (103) ： fun, FUN_ プレフィックスには正規表現（RegEx）も使用できます。このためにあなたは必要です @ 接頭辞が付きます。 例： 名前はそれに合わせなければなりません x 開始してから、その領域に別の文字を追加できます a-dA-D 含む： @x[a-dA-D] データ型変数の場合 エイリアス およびデータ型のビルディングブロック（POU）用 財産 プレースホルダー付きのプレフィックス {datatype} 定義します 変数のプレフィックス データ型またはスコープに応じてプレフィックスを使用して定義できるすべての変数の組織ハブ POUのプレフィックス プレフィックスを定義できるすべてのPOUタイプとメソッドスコープの組織ノード DUTのプレフィックス プレフィックスを定義できるDUTデータ型の構造、列挙、エイリアス、またはユニオンの組織ノード カスタムタイプのプレフィックス 特別なユーザー定義タイプ、特にライブラリからのタイプの組織ハブ 規則のリストを展開できます。下の空白行をクリックしてください。次に、カスタムタイプ名を入力するか、ダイアログでカスタムタイプを選択します 入力ヘルプ アウト。 規則を選択してボタンを押すと、規則を削除できます 距離 選択する。 注これらの規則は、属性に関連付けられているプレフィックスよりも優先されます {attribute 'nameprefix' := '<prefix>'} 定義されています。 オプション プレフィックスの後の最初の文字は大文字にする必要があります ：静的コード分析では、定義されたプレフィックスの後の変数名の最初の文字が大文字でない場合、変数のエラーが報告されます。 名前空間プレフィックスとデータ型プレフィックスを組み合わせる ：変数には、名前空間の定義済みプレフィックスと、それに続くデータ型の定義済みプレフィックスが必要です。 例：次のプレフィックスが定義されています。 VAR_GLOBAL g_ 、データ型の場合 本物 r 。 コード分析は、プレフィックスを持たないグローバルREAL変数のエラーを報告します g_r 持つため。 ：変数に名前空間規則が指定されている場合、これらの規則が考慮されます。その後、データ型の規則はすべて無視されます。 例：次のプレフィックスが定義されています。 VAR_GLOBAL g_ 、データ型の場合 本物 r 。 コード分析は、グローバルのエラーのみを報告します REAL -プレフィックスがない変数 g_ 持つため。 組み合わせ可能なデータ型の再帰プレフィックス ：結合されたデータ型の変数には、定義された命名規則に準拠する複合プレフィックスが必要です。 例： ppiVariable : POINTER TO POINTER TO INT; データ型変数の場合 POINTER TO プレフィックスになりました p データ型に対して定義されています INT プレフィックス i 。 静的コード分析は、すべてのデータ型変数のエラーを報告します POINTER TO POINTER TO INT 、プレフィックスではありません ppi 持つため。 refaiVar : REFERENCE TO ARRAY[1..3] OF INT; データ型の場合 REFERENCE TO プレフィックスになりました ref 配列の場合、プレフィックスを定義します a およびデータ型の場合 INT プレフィックス i 。 静的コード分析は、すべてのデータ型変数のエラーを報告します REFERENCE TO ARRAY[1..3] OF INT 、プレフィックスではありません refai 持つため。 例 次の命名規則は、の「識別子」に対して行われた推奨事項に厳密に従っています。 CODESYS が説明されています。 例 命名規則（1）は標準ブロックを参照します TON 。その結果、特殊ライブラリビルディングブロックの宣言でprefx \"ton_\"がチェックされます。空白行（2）をクリックすると、命名規則をさらに追加できます。 " }, 
{ "title" : "ダイアログ：静的分析設定：メトリック ", 
"url" : "_san_dlg_settings_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ 対話 \/ ダイアログ：静的分析設定：メトリック ", 
"snippet" : "静的分析設定: メトリクス シンボル： 関数 : メトリクスが、 デフォルトの指標を表示する コマンドが実行されます。 電話 ： プロジェクト → プロジェクト設定 メニュー、 静的解析 カテゴリー、 設定ダイアログを開く リンク ビルド → 静的解析 → 設定 メニュー 要件 ： その包み CODESYS Static Analysis インストールされています プロジェクトが開いています 詳細については、以下を参照してください。 静的コード分析を構成して実行するメトリック すべて選択可能 メトリクス 欄に表示されます。 アクティブ ：メトリックはコマンドにあります 作成→静的分析→デフォル...", 
"body" : "静的分析設定: メトリクス シンボル： 関数 : メトリクスが、 デフォルトの指標を表示する コマンドが実行されます。 電話 ： プロジェクト → プロジェクト設定 メニュー、 静的解析 カテゴリー、 設定ダイアログを開く リンク ビルド → 静的解析 → 設定 メニュー 要件 ： その包み CODESYS Static Analysis インストールされています プロジェクトが開いています 詳細については、以下を参照してください。 静的コード分析を構成して実行するメトリック すべて選択可能 メトリクス 欄に表示されます。 アクティブ ：メトリックはコマンドにあります 作成→静的分析→デフォルトのメトリックを表示 ウィンドウ内 標準メトリック ビルディングブロックごとに表示されます。 ：メトリックはコマンドにあります 作成→静的分析→デフォルトのメトリックを表示 ウィンドウ内 標準メトリック 表示されません。 下限 メトリックが表示される下限値 上限 メトリックが表示される上限値 メトリック コードサイズ 、 可変サイズ 、 スタックサイズ と ビューの数 プロジェクトに統合されているライブラリからのブロックに対してのみ出力されます。 ルールを介して、有効なメトリックの上限と下限の違反を検出できます SA0150 変換エラーとして出力された静的コード分析。 " }, 
{ "title" : "ダイアログ：静的分析設定：禁止記号 ", 
"url" : "_san_dlg_settings_sa_forbidden_symbols.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ 対話 \/ ダイアログ：静的分析設定：禁止記号 ", 
"snippet" : "禁止記号 関数 ：ダイアログで、プロジェクトのコードで使用できないキーワードと記号を定義します。これに関する詳細情報： 静的コード分析を構成して実行する電話 ： ボタン 構成ダイアログを開く メニューで プロジェクト→プロジェクト設定 、 カテゴリー 静的コード分析 メニュー ビルド→静的分析→設定 要件 ： その包み CODESYS Static Analysis インストールされています プロジェクトが開いています 入力行 行をダブルクリックすると、キーワードまたは記号を入力するためのラインエディタが開きます。 ：入力ヘルプが開き、記号またはキーワードを選択できます。...", 
"body" : "禁止記号 関数 ：ダイアログで、プロジェクトのコードで使用できないキーワードと記号を定義します。これに関する詳細情報： 静的コード分析を構成して実行する電話 ： ボタン 構成ダイアログを開く メニューで プロジェクト→プロジェクト設定 、 カテゴリー 静的コード分析 メニュー ビルド→静的分析→設定 要件 ： その包み CODESYS Static Analysis インストールされています プロジェクトが開いています 入力行 行をダブルクリックすると、キーワードまたは記号を入力するためのラインエディタが開きます。 ：入力ヘルプが開き、記号またはキーワードを選択できます。 " }, 
{ "title" : "ダイアログ: オプション: 自動フォーマッタ ", 
"url" : "_cds_dlg_options_smart_code.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ 対話 \/ ダイアログ: オプション: 自動フォーマッタ ", 
"snippet" : "オートフォーマッタ デバッグモード この機能は、 CODESYS インスタンスはデバッグ モードで起動されます。 これを行うには、次のコマンドライン呼び出しでインスタンスを起動します。 codesys.exe --debug シンボル： 関数 : IEC コードの自動フォーマットはこのダイアログで設定します。 電話 : ツール → オプション メニュー、 オートフォーマッタ カテゴリー...", 
"body" : "オートフォーマッタ デバッグモード この機能は、 CODESYS インスタンスはデバッグ モードで起動されます。 これを行うには、次のコマンドライン呼び出しでインスタンスを起動します。 codesys.exe --debug シンボル： 関数 : IEC コードの自動フォーマットはこのダイアログで設定します。 電話 : ツール → オプション メニュー、 オートフォーマッタ カテゴリー " }, 
{ "title" : "オートフォーマッタ ", 
"url" : "_cds_dlg_options_smart_code.html#UUID-ed744990-e58a-afa4-07c6-a11c0254c4c0_section-idm4605775334425634132064038043", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：ユーザーインターフェイス \/ 対話 \/ ダイアログ: オプション: 自動フォーマッタ \/ オートフォーマッタ ", 
"snippet" : "一般的な 宣言と実施 空行を潰す true (デフォルト): 空白行は削除されます。 false ：空白行は保持されます。 インターフェース 宣言 変数の型を揃える true （デフォルト）： 変数ブロック内のすべての型は、同じ行深さで始まるように配置されます。 false : 変数の初期化を調整する true （デフォルト）： 変数ブロック内のすべての初期化は、同じ行深さで開始されるように配置されます。 false : 変数の末尾のコメントを揃える true （デフォルト）： 変数宣言と同じ行にあるすべてのコメントは、同じ行深さで始まります。 false : 呼び出し 最大値を超えると、すべ...", 
"body" : "一般的な 宣言と実施 空行を潰す true (デフォルト): 空白行は削除されます。 false ：空白行は保持されます。 インターフェース 宣言 変数の型を揃える true （デフォルト）： 変数ブロック内のすべての型は、同じ行深さで始まるように配置されます。 false : 変数の初期化を調整する true （デフォルト）： 変数ブロック内のすべての初期化は、同じ行深さで開始されるように配置されます。 false : 変数の末尾のコメントを揃える true （デフォルト）： 変数宣言と同じ行にあるすべてのコメントは、同じ行深さで始まります。 false : 呼び出し 最大値を超えると、すべての通話がフォーマットされます。 例： 最大。改行前のパラメータの数 単一行の呼び出しに含めることができるパラメータの数は制限されています。 例: 4 (デフォルト) 最大。改行前のパラメータの char の長さ パラメータ名の文字数には制限があります。 例: 300 (デフォルト) " }, 
{ "title" : "参照：プログラミング ", 
"url" : "_san_f_reference_programming.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "プラグマと属性 ", 
"url" : "_san_struct_reference_pragmas.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ プラグマと属性 ", 
"snippet" : "CODESYS Static Analysis 静的コード分析の個々のルールまたは命名規則を有効または無効にするプラグマと属性を提供します。 要件：ルールまたは規則は、プロジェクト設定でアクティブ化または定義されています。 属性はプログラミングブロックの宣言部分に挿入され、プログラミングオブジェクト全体の特定のルールをオフにします。 プラグマは、プログラミングビルディングブロックの実装部分で使用され、コードの個々の行の特定のルールを無効にします。例外はルール164で、これは宣言部分でオフにすることもできます。 プロジェクト設定で無効になっているルールは、プラグマまたは属性を介して有効にすること...", 
"body" : "CODESYS Static Analysis 静的コード分析の個々のルールまたは命名規則を有効または無効にするプラグマと属性を提供します。 要件：ルールまたは規則は、プロジェクト設定でアクティブ化または定義されています。 属性はプログラミングブロックの宣言部分に挿入され、プログラミングオブジェクト全体の特定のルールをオフにします。 プラグマは、プログラミングビルディングブロックの実装部分で使用され、コードの個々の行の特定のルールを無効にします。例外はルール164で、これは宣言部分でオフにすることもできます。 プロジェクト設定で無効になっているルールは、プラグマまたは属性を介して有効にすることはできません。 ルールSA0004は、プラグマまたは属性を介して無効にすることはできません。 " }, 
{ "title" : "プラグマ：analysis ", 
"url" : "_san_pragma_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ プラグマと属性 \/ プラグマ：analysis ", 
"snippet" : "このプラグマを使用すると、プログラミングブロック内の個々のコード行のコーディングルールを非アクティブ化して、プログラミングブロックで使用できるようにします。 静的コード分析 考慮されません。ルール番号とその前のマイナス記号（ \"-\"）を指定して、コーディングルールを無効にします。プラス記号（ \"+\"）は、アクティブ化のために接頭辞が付けられます。プラグマでは、ルールをいくつでも指定できます。 挿入位置 ：非アクティブ化：実装部分で、コード分析が非アクティブ化されるコードの最初の行の前に、 {analysis - ...} 。アクティベーション：非アクティベーションの最後の行の後 {analys...", 
"body" : "このプラグマを使用すると、プログラミングブロック内の個々のコード行のコーディングルールを非アクティブ化して、プログラミングブロックで使用できるようにします。 静的コード分析 考慮されません。ルール番号とその前のマイナス記号（ \"-\"）を指定して、コーディングルールを無効にします。プラス記号（ \"+\"）は、アクティブ化のために接頭辞が付けられます。プラグマでは、ルールをいくつでも指定できます。 挿入位置 ：非アクティブ化：実装部分で、コード分析が非アクティブ化されるコードの最初の行の前に、 {analysis - ...} 。アクティベーション：非アクティベーションの最後の行の後 {analysis + ...} 。ルール164の場合、プラグマはコメントの前の宣言部分に挿入することもできます。 構文： Deaktivierung von Regeln:\n\n{analysis -<rule number> ( , -<further rule number> )* }\n* : optional none, one or more further rule numbers Aktivierung von Regeln:\n\nanalysis +<rule number> ( , +<further rule number> )* }\n* : none, one or more further rule numbers 例 ルール24は2行で無効にされてから、再度有効になります。これは、これらの行でルール24がチェックされていないことを意味します。たとえば、 nTest:=DINT#99 許可されています。 {analysis -24}\nnTest := 99;\niVar := INT#2;\n{analysis +24} 複数のルールを無効にします。 {analysis -10, -24, -18} " }, 
{ "title" : "属性：analysis ", 
"url" : "_san_attribute_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ プラグマと属性 \/ 属性：analysis ", 
"snippet" : "この属性は、プログラミングオブジェクト全体の特定のルールを無効にして、それらがに適用されないようにします。 静的コード分析 考慮されません。ルール番号と前のマイナス記号（ \"-\"）を指定して、コーディングルールを非アクティブ化します。属性には、ルールをいくつでも指定できます。 挿入位置 ：1行目のプログラミングブロックの宣言部分。 構文 ： {attribute 'analysis' := '-<rule number> ( , -<further rule number> )* '} * : none, one or more further rule numbers 例 ルール33と31は...", 
"body" : "この属性は、プログラミングオブジェクト全体の特定のルールを無効にして、それらがに適用されないようにします。 静的コード分析 考慮されません。ルール番号と前のマイナス記号（ \"-\"）を指定して、コーディングルールを非アクティブ化します。属性には、ルールをいくつでも指定できます。 挿入位置 ：1行目のプログラミングブロックの宣言部分。 構文 ： {attribute 'analysis' := '-<rule number> ( , -<further rule number> )* '}\n* : none, one or more further rule numbers 例 ルール33と31は、構造全体でオフになっています。 {attribute 'analysis' := '-33, -31'}\nTYPE My_Structure :\nSTRUCT\n iLocal : INT;\n uiLocal : UINT;\n udiLocal : UDINT;\nEND_STRUCT\nEND_TYPE 配列のルール100はオフになっています。 {attribute 'analysis' := '-100'}\nPROGRAM PLC_PRG\nVAR\n aBigData: ARRAY[1..10000] OF DWORD;\n aBigDATA_2: ARRAY[1..10000] OF DWORD;\nEND_VAR\n; " }, 
{ "title" : "属性'naming' ", 
"url" : "_san_attribute_naming.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ プラグマと属性 \/ 属性'naming' ", 
"snippet" : "属性は、によって使用されるコード行を識別します 命名規則の分析 除外されます。コード分析が中断されるコードの最初の行の前に、プラグマ属性がオンになっています off 、最後の行の後 on 割り当てられました。いつ omit 割り当てられると、コードの次の行のみが無視されます。 挿入位置 ：非アクティブ化：関連する行の上のPOUおよびDUTの宣言部分。アクティベーション：関連する行の下。 構文 ： {attribute 'naming' := '<switch state>'} <switch state> : on | off | omit on : naming is switched on...", 
"body" : "属性は、によって使用されるコード行を識別します 命名規則の分析 除外されます。コード分析が中断されるコードの最初の行の前に、プラグマ属性がオンになっています off 、最後の行の後 on 割り当てられました。いつ omit 割り当てられると、コードの次の行のみが無視されます。 挿入位置 ：非アクティブ化：関連する行の上のPOUおよびDUTの宣言部分。アクティベーション：関連する行の下。 構文 ： {attribute 'naming' := '<switch state>'}\n<switch state> : on | off | omit\non : naming is switched on\noff : naming is switched off\nomit : only next codeline is switched off 例 定義された命名規則：（1）INT変数の識別子には、「intVar1」などの「int」プレフィックスを付ける必要があります。 （2）プログラム名は「prog」で始まる必要があります。 以下に示すコードの場合、静的分析は次の変数についてのみレポートします。 cccVar 、 aVariable 、 bVariable 。 VAR\n{attribute 'naming' := 'off'}\n iVarA : INT;\n iVarB : INT;\n{attribute 'naming' := 'on'}\n iVarC : INT;\nEND_VAR VAR\n ...\n{attribute 'naming' := 'omit'}\n iVarC : INT;\n...\nEND_VAR {attribute 'naming' := 'omit'}\nPROGRAM PLC_PRG\nVAR\n...\nEND_VAR {attribute 'naming' := 'off'}\nPROGRAM DoSomethingA\nVAR\n{attribute 'naming' := 'on'}\n iVarA : INT;\n iVarB : INT;\n …\nVAR_END " }, 
{ "title" : "属性： nameprefix ", 
"url" : "_san_attribute_nameprefix.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ プラグマと属性 \/ 属性： nameprefix ", 
"snippet" : "nameprefix この属性は、構造化データ型の変数のプレフィックスを定義します。プレフィックスは、このタイプで宣言された変数の識別子の前に置く必要があります。この命名規則は、 静的コード分析 。 挿入位置 ：構造化データ型の宣言前の行 構文 ： {attribute 'nameprefix' := '<prefix>'} 例 次の例では、変数名が「point」で始まっていないため、静的分析はpBのメッセージを発行します。 {attribute 'nameprefix' := 'point'} TYPE DATAPOINT : STRUCT iX: INT; iY: INT; END_STR...", 
"body" : "nameprefix この属性は、構造化データ型の変数のプレフィックスを定義します。プレフィックスは、このタイプで宣言された変数の識別子の前に置く必要があります。この命名規則は、 静的コード分析 。 挿入位置 ：構造化データ型の宣言前の行 構文 ： {attribute 'nameprefix' := '<prefix>'} 例 次の例では、変数名が「point」で始まっていないため、静的分析はpBのメッセージを発行します。 {attribute 'nameprefix' := 'point'}\nTYPE DATAPOINT :\nSTRUCT\n iX: INT;\n iY: INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n pointA : DATAPOINT;\n pB : DATAPOINT;\nEND_VAR\npointA.iX := 1;\npointA.iY := 10;\npB.iX := 2;\npB.iY := 20; 静的コード分析後のエラーメッセージ： 無効な変数名 'pB'：予期されるプレフィックス 'point' " }, 
{ "title" : "属性：analysis:report-multiple-instance-calls ", 
"url" : "_san_attribute_analysis_report_multiple_instance_calls.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ プラグマと属性 \/ 属性：analysis:report-multiple-instance-calls ", 
"snippet" : "analysis:report-multiple-instance-calls 属性は、チェックの汎用モジュールを識別します 規則105 ：この属性を持つ機能ブロックのみが、機能ブロックのインスタンスが複数回呼び出されているかどうかを確認するためにチェックされます。ルール105の場合 プロジェクト設定 が無効になっている場合、属性は効果がありません。 挿入位置 ：機能ブロックの宣言部分の最初の行。 構文 ： {attribute 'analysis:report-multiple-instance-calls'} 例 \/\/ {attribute 'analysis:report-multipl...", 
"body" : "analysis:report-multiple-instance-calls 属性は、チェックの汎用モジュールを識別します 規則105 ：この属性を持つ機能ブロックのみが、機能ブロックのインスタンスが複数回呼び出されているかどうかを確認するためにチェックされます。ルール105の場合 プロジェクト設定 が無効になっている場合、属性は効果がありません。 挿入位置 ：機能ブロックの宣言部分の最初の行。 構文 ： {attribute 'analysis:report-multiple-instance-calls'} 例 \/\/ {attribute 'analysis:report-multiple-instance-calls'} deactivated\nFUNCTION_BLOCK FB_DoA\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\n{attribute 'analysis:report-multiple-instance-calls'}\nFUNCTION_BLOCK FB_DoB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iB : INT;\nEND_VAR\niB := iB +1;\n\nPROGRAM PLC_PRG\nVAR\n fbA : FB_DoA;\n fbB : FB_DoB;\nND_VAR\n\nfbA();\nfbB(); \/\/ SA0105\nfbA();\nfbB(); \/\/ SA0105\n ビュー内の出力 メッセージ : SA0105: インスタンス 'fbB' が数回呼び出されました " }, 
{ "title" : "ルール ", 
"url" : "_san_struct_reference_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0001：到達不能コード ", 
"url" : "_san_rule_sa0001.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0001：到達不能コード ", 
"snippet" : "たとえば、次のような理由で実行されないコード行を検出します。 RETURN または CONTINUE 声明 理由：到達不能コードはどのような場合でも避ける必要があります。多くの場合、 テスト 再度削除する必要のあるテストコードがまだ含まれていることを示します。 重要性：高い PLCopenルール：CP2 例 PROGRAM PLC_PRG VAR xReturn_Before_End: BOOL; xContinue_In_Loop_FUN: BOOL; iCounter: INT; END_VAR xContinue_In_Loop_FUN := FALSE; FOR iCounter :=...", 
"body" : "たとえば、次のような理由で実行されないコード行を検出します。 RETURN または CONTINUE 声明 理由：到達不能コードはどのような場合でも避ける必要があります。多くの場合、 テスト 再度削除する必要のあるテストコードがまだ含まれていることを示します。 重要性：高い PLCopenルール：CP2 例 PROGRAM PLC_PRG\nVAR\n xReturn_Before_End: BOOL;\n xContinue_In_Loop_FUN: BOOL;\n iCounter: INT;\nEND_VAR\n xContinue_In_Loop_FUN := FALSE;\nFOR iCounter := INT#0 TO INT#5 BY INT#1 DO\n CONTINUE;\n xContinue_In_Loop_FUN := FALSE;\nEND_FOR での出力 メッセージ ビュー： SA0001: 'PLC_PRG' で到達不能なコードが検出されました " }, 
{ "title" : "SA0002：空のオブジェクト ", 
"url" : "_san_rule_sa0002.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0002：空のオブジェクト ", 
"snippet" : "コードを含まないPOU、GVL、データ型宣言、またはインターフェイスを検出します。 理由：空のオブジェクトは避ける必要があります。多くの場合、オブジェクトが完全に実装されていないことを示しています。例外：場合によっては、関数ブロックがインターフェースを介してのみ使用される場合、関数ブロックの本体にコードが与えられません。それ以外の場合、メソッドはインターフェイスに必要なためにのみ作成され、メソッドに意味のある実装はできません。いずれにせよ、そのような状況についてコメントする必要があります。 重要性：中...", 
"body" : "コードを含まないPOU、GVL、データ型宣言、またはインターフェイスを検出します。 理由：空のオブジェクトは避ける必要があります。多くの場合、オブジェクトが完全に実装されていないことを示しています。例外：場合によっては、関数ブロックがインターフェースを介してのみ使用される場合、関数ブロックの本体にコードが与えられません。それ以外の場合、メソッドはインターフェイスに必要なためにのみ作成され、メソッドに意味のある実装はできません。いずれにせよ、そのような状況についてコメントする必要があります。 重要性：中 " }, 
{ "title" : "SA0003：空のステートメント ", 
"url" : "_san_rule_sa0003.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0003：空のステートメント ", 
"snippet" : "セミコロンを含むコード行を検索します ; 、ただし、説明は含まれていません。 理論的根拠：空のステートメントは、欠落しているコードを示している可能性があります。 注: 空のステートメントを使用するのには十分な理由があります。たとえば、 CASE このステートメントでは、何もすることがない場合も含め、すべてのケースを明示的にプログラムすることが合理的です。こういう空の時は CASE ステートメントにコメントが含まれている場合、静的解析はエラー メッセージを生成しません。 重要性：低い 例 CASE value OF 1: DoSomething(); 2: ; 3: DoSomethingEls...", 
"body" : "セミコロンを含むコード行を検索します ; 、ただし、説明は含まれていません。 理論的根拠：空のステートメントは、欠落しているコードを示している可能性があります。 注: 空のステートメントを使用するのには十分な理由があります。たとえば、 CASE このステートメントでは、何もすることがない場合も含め、すべてのケースを明示的にプログラムすることが合理的です。こういう空の時は CASE ステートメントにコメントが含まれている場合、静的解析はエラー メッセージを生成しません。 重要性：低い 例 CASE value OF\n 1:\n DoSomething();\n 2:\n ;\n 3:\n DoSomethingElse();\nEND_CASE\n での出力 メッセージ ビュー： SA0003: 空のステートメント CASE value OF\n 1:\n DoSomething();\n 2:\n ; \/\/nothing to do\n 3:\n DoSomethingElse();\nEND_CASE\n での出力 メッセージ ビュー： SAエラーなし " }, 
{ "title" : "SA0004：出力への複数の書き込みアクセス ", 
"url" : "_san_rule_sa0004.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0004：出力への複数の書き込みアクセス ", 
"snippet" : "複数の場所に書き込まれる出力を検索します。 理論的根拠：出口がコード内のさまざまな場所に書き込まれると、保守性が低下します。その場合、どの書き込みアクセスが実際にプロセスに影響を与えるのかは不明です。補助変数で出力変数の計算を行い、サイクルの最後の1つのポイントで計算値を割り当てることをお勧めします。 重要性：高い PLCopenルール：CP12 出力変数にアクセスするときにエラーはスローされません（ VAR_IN_OUT ）のさまざまなブランチで IF また CASE 指示が書かれています。 このルールは、プラグマを介してオフにすることはできません。 例 VAR_GLOBAL g_xVar ...", 
"body" : "複数の場所に書き込まれる出力を検索します。 理論的根拠：出口がコード内のさまざまな場所に書き込まれると、保守性が低下します。その場合、どの書き込みアクセスが実際にプロセスに影響を与えるのかは不明です。補助変数で出力変数の計算を行い、サイクルの最後の1つのポイントで計算値を割り当てることをお勧めします。 重要性：高い PLCopenルール：CP12 出力変数にアクセスするときにエラーはスローされません（ VAR_IN_OUT ）のさまざまなブランチで IF また CASE 指示が書かれています。 このルールは、プラグマを介してオフにすることはできません。 例 VAR_GLOBAL\n g_xVar AT %QX0.0 : BOOL ;\n g_iTest AT %QW0 : INT ;\nEND_VAR PROGRAM PLC_PRG IF g_iCondition < INT#0 THEN\n g_xVar := TRUE;\n g_iTest := INT#12;\nEND_IF\n\nCASE g_iCondition OF\n INT#1:\n g_xVar := FALSE;\n INT#2:\n g_iTest := INT#11;\n ELSE\n g_xVar := TRUE;\n g_iTest := INT#9;\nEND_CASE\n での出力 メッセージ ビュー： SA0004: 出力 '%QX0.0' に対する複数の書き込みアクセス SA0004: 出力 '%QW0' に対する複数の書き込みアクセス " }, 
{ "title" : "SA0006：複数のタスクからの書き込みアクセス ", 
"url" : "_san_rule_sa0006.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0006：複数のタスクからの書き込みアクセス ", 
"snippet" : "複数のタスクによって書き込まれる変数を決定します。 理由：いくつかのタスクで記述された変数は、その値を予期せず変更する可能性があります。これは混乱を招く状況につながる可能性があります。文字列変数および一部の32ビットシステムでは、変数が2つのタスクで同時に書き込まれる場合、64ビット整数変数も一貫性のないステータスになる可能性があります。 例外：場合によっては、いくつかのタスクで変数を書き込む必要があります。次に、たとえばセマフォを使用して、アクセスによって一貫性のない状態が発生しないことを確認します。 重要性：高い PLCopenルール：CP10 例 VAR_GLOBAL g_iTemp1:...", 
"body" : "複数のタスクによって書き込まれる変数を決定します。 理由：いくつかのタスクで記述された変数は、その値を予期せず変更する可能性があります。これは混乱を招く状況につながる可能性があります。文字列変数および一部の32ビットシステムでは、変数が2つのタスクで同時に書き込まれる場合、64ビット整数変数も一貫性のないステータスになる可能性があります。 例外：場合によっては、いくつかのタスクで変数を書き込む必要があります。次に、たとえばセマフォを使用して、アクセスによって一貫性のない状態が発生しないことを確認します。 重要性：高い PLCopenルール：CP10 例 VAR_GLOBAL\n g_iTemp1: INT;\nEND_VAR PROGRAM PLC_PRG \/\/ Controlled by MainTask\ng_iTemp1 := g_iTemp1 + INT#2;\n PROGRAM PLC_PRG_1 \/\/Controlled by SubTask\ng_iTemp1 := g_iTemp1 - INT#3; での出力 メッセージ ビュー： SA0006: タスク MainTask、SubTask の 'g_iTemp1' への同時書き込みアクセス " }, 
{ "title" : "SA0007: 定数のアドレス演算子 ", 
"url" : "_san_rule_sa0007.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0007: 定数のアドレス演算子 ", 
"snippet" : "演算子が存在するコード行を検索します ADR 定数に適用されます。 理由：定数変数へのポインターは、 CONSTANT 変数のプロパティ。変数は、コンパイラーがこれを報告しなくても、ポインターを介して変更できます。 例外：まれに、定数へのポインタを関数に転送することが理にかなっている場合があります。ただし、この関数が転送された値を変更しないことを確認する必要があります。可能であれば使用する VAR_IN_OUT CONSTANT 。 重要性：高い とき 定数を置換する オプションが選択されています コンパイラオプション プロジェクト設定のアドレス演算子はスカラー定数 (整数、 BOOL 、 R...", 
"body" : "演算子が存在するコード行を検索します ADR 定数に適用されます。 理由：定数変数へのポインターは、 CONSTANT 変数のプロパティ。変数は、コンパイラーがこれを報告しなくても、ポインターを介して変更できます。 例外：まれに、定数へのポインタを関数に転送することが理にかなっている場合があります。ただし、この関数が転送された値を変更しないことを確認する必要があります。可能であれば使用する VAR_IN_OUT CONSTANT 。 重要性：高い とき 定数を置換する オプションが選択されています コンパイラオプション プロジェクト設定のアドレス演算子はスカラー定数 (整数、 BOOL 、 REAL ）とコンパイルエラーが発生します。 (定数文字列、構造体、配列には常にアドレスがあります。) 例 PROGRAM PLC_PRG\nVAR CONSTANT\n c_iValue : INT := INT#15;\nEND_VAR\nVAR\n poiValue : POINTER TO INT;\nEND_VAR\n poiValue := ADR(c_iValue); \/\/ SA0007 での出力 メッセージ ビュー： SA0007: 定数変数 'c_iValue' へのアドレス " }, 
{ "title" : "SA0008：サブエリアタイプを確認してください ", 
"url" : "_san_rule_sa0008.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0008：サブエリアタイプを確認してください ", 
"snippet" : "サブレンジタイプのレンジ違反を検出します。割り当てられたリテラルは、コンパイラによってすでにチェックされています。定数が割り当てられている場合、値は定義された範囲内にある必要があります。変数をマップする場合、データ型は同じである必要があります。 理由：サブエリアタイプを使用する場合は、このサブエリアが終了しないようにする必要があります。コンパイラーは、定数割り当てについてそのようなサブ範囲違反のみをチェックします。 重要度：低 コード構造で許可されていないため、CFCオブジェクトのチェックは実行されません。 例 VAR_GLOBAL iVarGlob:INT; END_VAR PROGRAM ...", 
"body" : "サブレンジタイプのレンジ違反を検出します。割り当てられたリテラルは、コンパイラによってすでにチェックされています。定数が割り当てられている場合、値は定義された範囲内にある必要があります。変数をマップする場合、データ型は同じである必要があります。 理由：サブエリアタイプを使用する場合は、このサブエリアが終了しないようにする必要があります。コンパイラーは、定数割り当てについてそのようなサブ範囲違反のみをチェックします。 重要度：低 コード構造で許可されていないため、CFCオブジェクトのチェックは実行されません。 例 VAR_GLOBAL\n iVarGlob:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n iSubr1: INT (INT#1..INT#10);\n iSubr2: INT (INT#1..INT#1000);\n iCount: INT;\n by_SubType : BYTE (BYTE#0..BYTE#11);\n iVar : INT (-4095..4095);\nEND_VAR\n iSubr1 := nCount; \/\/ SA0008\niSubr1 := subr2; \/\/ SA0008\niSubr1 := gvl.iVarGlob; \/\/ SA0008\n\/\/byBYTE_SubType := BYTE#123; \/\/already detected by compiler, error \"Cannot convert type...\" での出力 メッセージ ビュー： SA0008: 部分範囲変数 'iSubr1' が許容範囲外である可能性があります " }, 
{ "title" : "SA0009：未使用の戻り値 ", 
"url" : "_san_rule_sa0009.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0009：未使用の戻り値 ", 
"snippet" : "戻り値が使用されていない関数、メソッド、およびプロパティの呼び出しを検出します。 理由: 関数またはメソッドが戻り値を返すときは、それも評価する必要があります。戻り値は多くの場合、関数が正常に実行されたかどうかを示します。評価がない場合、戻り値が忘れられていたのか、それとも実際には必要ではなかったのかを後で特定することができなくなります。 例外: 戻り値が呼び出しに無関係な場合は、これを文書化し、割り当てを省略する必要があります。エラーが返された場合は決して無視してはなりません。 重要性：中 PLCopenルール：CP7 \/ CP17 例 FUNCTION Return_BOOL : BOOL...", 
"body" : "戻り値が使用されていない関数、メソッド、およびプロパティの呼び出しを検出します。 理由: 関数またはメソッドが戻り値を返すときは、それも評価する必要があります。戻り値は多くの場合、関数が正常に実行されたかどうかを示します。評価がない場合、戻り値が忘れられていたのか、それとも実際には必要ではなかったのかを後で特定することができなくなります。 例外: 戻り値が呼び出しに無関係な場合は、これを文書化し、割り当てを省略する必要があります。エラーが返された場合は決して無視してはなりません。 重要性：中 PLCopenルール：CP7 \/ CP17 例 FUNCTION Return_BOOL : BOOL\nVAR_INPUT\nEND_VAR\nVAR\n    xTest : BOOL;\nEND_VAR xTest := FALSE;\nReturn_BOOL := xTest; PROGRAM PLC_PRG\nReturn_BOOL();  \/\/ SA0009\n での出力 メッセージ ビュー： SA0009: 'Return_BOOL' の戻り値を無視します " }, 
{ "title" : "SA0010：コンポーネントが1つしかないアレイ ", 
"url" : "_san_rule_sa0010.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0010：コンポーネントが1つしかないアレイ ", 
"snippet" : "コンポーネントが1つしかない配列を検索します。 理由：1つのコンポーネントを持つ配列は、基本型の変数に置き換えることができます。この変数へのアクセスは、インデックスを使用して変数にアクセスするよりも大幅に高速です。 例外: 配列の長さは定数によって決定されることが多く、これはプログラムのパラメーターです。そうすれば、プログラムはさまざまな長さの配列を扱うことができ、長さが 1 だけの場合は変更する必要がありません。この種の状況は、それに応じて文書化する必要があります。 重要度：低 例 PROGRAM PLC_PRG VAR aoiEmpty : ARRAY [22..22] OF INT :=...", 
"body" : "コンポーネントが1つしかない配列を検索します。 理由：1つのコンポーネントを持つ配列は、基本型の変数に置き換えることができます。この変数へのアクセスは、インデックスを使用して変数にアクセスするよりも大幅に高速です。 例外: 配列の長さは定数によって決定されることが多く、これはプログラムのパラメーターです。そうすれば、プログラムはさまざまな長さの配列を扱うことができ、長さが 1 だけの場合は変更する必要がありません。この種の状況は、それに応じて文書化する必要があります。 重要度：低 例 PROGRAM PLC_PRG\nVAR\n aoiEmpty : ARRAY [22..22] OF INT := [22];\n aorEmpty : ARRAY [2..2] OF REAL := [2.2];\n iVar : INT;\n rVAR : REAL;\nEND_VAR iVar := aoiEmpty[22];\nrVAR := aorEmpty[2];\n での出力 メッセージ ビュー： SA0010: 変数 'aoiEmpty' 内の空の配列要素 SA0010: 変数 'aorEmpty' 内の空の配列要素 " }, 
{ "title" : "SA0011: メンバーが 1 つしかない無駄な宣言 ", 
"url" : "_san_rule_sa0011.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0011: メンバーが 1 つしかない無駄な宣言 ", 
"snippet" : "メンバーが 1 つだけある構造体または列挙型を検出します 理由: メンバーが 1 つだけの構造体や列挙型は宣言すべきではありません。このような宣言は読者を混乱させる可能性があります。要素が 1 つだけある構造体は、エイリアス型で置き換えることができます。要素が 1 つだけある列挙は定数に置き換えることができます。 PLCopenルール：CP22 \/ CP24 重要度：低 例 {attribute 'qualified_only'} {attribute 'strict'} TYPE SINGLE_ENUM : ( OnlyOne := 1 ); END_TYPE TYPE SINGLE_UNI...", 
"body" : "メンバーが 1 つだけある構造体または列挙型を検出します 理由: メンバーが 1 つだけの構造体や列挙型は宣言すべきではありません。このような宣言は読者を混乱させる可能性があります。要素が 1 つだけある構造体は、エイリアス型で置き換えることができます。要素が 1 つだけある列挙は定数に置き換えることができます。 PLCopenルール：CP22 \/ CP24 重要度：低 例 {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE SINGLE_ENUM :\n(\n\tOnlyOne := 1\n);\nEND_TYPE TYPE SINGLE_UNION :\nUNION\n\tlrValue : LREAL;\nEND_UNION\nEND_TYPE {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE SINGLE_ENUM :\n(\n\tOnlyOne := 1\n);\nEND_TYPE での出力 メッセージ ビュー： SA0011: 無駄な宣言 'SINGLE_ENUM': メンバーが 1 つしかない構造体\/列挙体は使用しないでください SA0011: 無駄な宣言 'SINGLE_UNION': メンバーが 1 つだけの Struct\/Enum は使用しないでください SA0011: 役に立たない宣言 'SINGLE_STRUCT': メンバーが 1 つしかない Struct\/Enum は使用しないでください " }, 
{ "title" : "SA0012：定数として宣言できる変数 ", 
"url" : "_san_rule_sa0012.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0012：定数として宣言できる変数 ", 
"snippet" : "書き込みのためにアクセスされないため、定数として宣言できる変数を判別します。 正当性: 変数が宣言点でのみ書き込まれ、それ以外は読み取りのみに使用される場合、静的分析では変数も変更すべきではないと想定されます。まず、定数として宣言すると、プログラム変更時に変数が変更されないことがチェックされます。次に、定数として宣言すると、コードが高速になる可能性があります。 プロジェクトに複数のアプリケーションがある場合は、現在アクティブなアプリケーションの下にあるオブジェクトのみが考慮されます。アプリケーションが1つしかない場合は、一般的なPOUプール内のオブジェクトも考慮されます。 重要度：低 例 PR...", 
"body" : "書き込みのためにアクセスされないため、定数として宣言できる変数を判別します。 正当性: 変数が宣言点でのみ書き込まれ、それ以外は読み取りのみに使用される場合、静的分析では変数も変更すべきではないと想定されます。まず、定数として宣言すると、プログラム変更時に変数が変更されないことがチェックされます。次に、定数として宣言すると、コードが高速になる可能性があります。 プロジェクトに複数のアプリケーションがある場合は、現在アクティブなアプリケーションの下にあるオブジェクトのみが考慮されます。アプリケーションが1つしかない場合は、一般的なPOUプール内のオブジェクトも考慮されます。 重要度：低 例 PROGRAM PLC_PRG\nVAR\n iVar : INT := INT#17;\n iTest : INT;\nEND_VAR\n iTest := iTest + iVar; \/\/ SA0012: 'iVar' could be declared as constant での出力 メッセージ ビュー： SA0012: 変数 'iVar' が定数として宣言される可能性があります " }, 
{ "title" : "SA0013：同じ変数名の宣言 ", 
"url" : "_san_rule_sa0013.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0013：同じ変数名の宣言 ", 
"snippet" : "他の変数によって既に使用されている名前を持つ変数を検出します (たとえば、同じ名前を持つグローバル変数とローカル変数)。同じアクセス範囲内で関数名、アクション名、メソッド名、またはプロパティ名が使用されている変数も検出されます。の GVL で宣言された変数も検出されます。 デバイス ビューまたは POU プール内で。ただし、この場合、 POU ビューはアプリケーション プログラムで使用する必要があります。 理論的根拠：同じ名前はコードを読み取るときに混乱する可能性があり、間違ったオブジェクトに誤ってアクセスするとエラーが発生する可能性があります。このような状況を回避する命名規則を使用することを...", 
"body" : "他の変数によって既に使用されている名前を持つ変数を検出します (たとえば、同じ名前を持つグローバル変数とローカル変数)。同じアクセス範囲内で関数名、アクション名、メソッド名、またはプロパティ名が使用されている変数も検出されます。の GVL で宣言された変数も検出されます。 デバイス ビューまたは POU プール内で。ただし、この場合、 POU ビューはアプリケーション プログラムで使用する必要があります。 理論的根拠：同じ名前はコードを読み取るときに混乱する可能性があり、間違ったオブジェクトに誤ってアクセスするとエラーが発生する可能性があります。このような状況を回避する命名規則を使用することをお勧めします。 PLCopenルール：N5 \/ N9 重要性：中 例 VAR_GLOBAL\n xVar1 : BOOL;\n iVar3 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n xVar1 : BOOL; \/\/ SA0013\n iVar3 : INT; \/\/ SA0013\nEND_VAR\n xVar1 := NOT GVL.xVar1;\niVar3 := iVar3 + INT#2;\niVar3 := GVL.iVar3; での出力 メッセージ ビュー： SA0013: 'iVar1' の宣言によりシンボル 'GVL.iVar1' が非表示になります SA0013: 'xVar3' の宣言によりシンボル 'GVL.xVar3' が非表示になります 例 の FB_Pou ファンクションブロックには ACT アクション、 METH メソッドと同じ名前のローカル変数。 FUNCTION_BLOCK FB_Pou\nVAR\n ACT : UINT; \/\/ SA0013\n METH : BYTE; \/\/ SA0013\nEND_VAR PROGRAM PLC_PRG\nVAR\n fbPou : FB_Pou;\nEND_VAR\n fbPou(); での出力 メッセージ ビュー： SA0013: 'ACT' の宣言によりシンボル 'FB_Pou.ACT' が非表示になります SA0013: 「METH」の宣言によりシンボル「FB_Pou.METH」が非表示になります " }, 
{ "title" : "SA0014：インスタンスへの割り当て ", 
"url" : "_san_rule_sa0014.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0014：インスタンスへの割り当て ", 
"snippet" : "機能ブロックインスタンスへの割り当てを決定します。ポインタ変数または参照変数を持つインスタンスの場合、これらの割り当てにはリスクが伴う可能性があります。 理由：これはパフォーマンスの警告です。インスタンスが別のインスタンスに割り当てられている場合、すべての要素とサブ要素が1つのインスタンスから別のインスタンスにコピーされます。データへのポインタもコピーされますが、参照データはコピーされないため、ターゲットインスタンスとソースインスタンスには、割り当て後に同じデータが含まれます。インスタンスのサイズによっては、このような割り当てに時間がかかる場合があります。たとえば、インスタンスを処理のために関...", 
"body" : "機能ブロックインスタンスへの割り当てを決定します。ポインタ変数または参照変数を持つインスタンスの場合、これらの割り当てにはリスクが伴う可能性があります。 理由：これはパフォーマンスの警告です。インスタンスが別のインスタンスに割り当てられている場合、すべての要素とサブ要素が1つのインスタンスから別のインスタンスにコピーされます。データへのポインタもコピーされますが、参照データはコピーされないため、ターゲットインスタンスとソースインスタンスには、割り当て後に同じデータが含まれます。インスタンスのサイズによっては、このような割り当てに時間がかかる場合があります。たとえば、インスタンスを処理のために関数に渡す場合は、インスタンスへのポインタを渡す方がはるかに効率的です。 あるインスタンスから別のインスタンスに値を選択的にコピーする場合は、コピーメソッドが便利です： inst_First.Copy_From(inst_Second) 重要性：中 例 PROGRAM PLC_PRG\nVAR\n inst_First : My_FB;\n inst_Second : My_FB;\nEND_VAR\n inst_First();\ninst_Second := inst_First; \/\/ SA0014 での出力 メッセージ ビュー： SA0014: インスタンスの割り当て " }, 
{ "title" : "SA0015：FB_Initを介したグローバルデータへのアクセス ", 
"url" : "_san_rule_sa0015.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0015：FB_Initを介したグローバルデータへのアクセス ", 
"snippet" : "メソッドを介したグローバル変数への関数ブロックのアクセスを決定します FB_Init 。この変数の値は、初期化の順序によって異なります。 理由：ブロックのインスタンスの宣言ポイントによっては、ルールに違反した場合に初期化されていない変数にアクセスする可能性があります。 重要性：高い 例 VAR_GLOBAL g_xTest1 : BOOL; g_iTest3 : INT; END_VAR METHOD PUBLIC fb_init : BOOL VAR_INPUT (* If TRUE, the retain variables are initialized (warm start \/ co...", 
"body" : "メソッドを介したグローバル変数への関数ブロックのアクセスを決定します FB_Init 。この変数の値は、初期化の順序によって異なります。 理由：ブロックのインスタンスの宣言ポイントによっては、ルールに違反した場合に初期化されていない変数にアクセスする可能性があります。 重要性：高い 例 VAR_GLOBAL\n g_xTest1 : BOOL;\n g_iTest3 : INT;\nEND_VAR METHOD PUBLIC fb_init : BOOL\nVAR_INPUT\n (* If TRUE, the retain variables are initialized (warm start \/ cold start) *)\n bInitRetains : BOOL; \n (* If TRUE, the instance afterwards gets moved into the copy code (online change) *)\n bInCopyCode : BOOL; \nEND_VAR\n g_xTest1 := NOT g_xTest1; \/\/ SA0015\ng_iTest3 := g_iTest3 + INT#1; \/\/ SA0015 での出力 メッセージ ビュー： SA0015: ファンクション ブロック 'POU' の FB_Init メソッドがグローバル データにアクセスします " }, 
{ "title" : "SA0016：構造のギャップ ", 
"url" : "_san_rule_sa0016.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0016：構造のギャップ ", 
"snippet" : "現在設定されているターゲットシステムのアライメント要件によって引き起こされる構造または機能ブロックのギャップを特定します。可能であれば、構造要素を再配置するか、ダミー要素で埋めることによって、ギャップを削除する必要があります。これが不可能な場合は、プラグマを介して影響を受ける構造のルールを使用できます analysis 非アクティブ化します。 理由：プラットフォームごとに配置要件が異なるため、このような構造のメモリには異なるレイアウトが存在する可能性があります。その後、コードはプラットフォームに応じて異なる動作をする可能性があります。 重要度：低 例 TYPE Unpadded_Structu...", 
"body" : "現在設定されているターゲットシステムのアライメント要件によって引き起こされる構造または機能ブロックのギャップを特定します。可能であれば、構造要素を再配置するか、ダミー要素で埋めることによって、ギャップを削除する必要があります。これが不可能な場合は、プラグマを介して影響を受ける構造のルールを使用できます analysis 非アクティブ化します。 理由：プラットフォームごとに配置要件が異なるため、このような構造のメモリには異なるレイアウトが存在する可能性があります。その後、コードはプラットフォームに応じて異なる動作をする可能性があります。 重要度：低 例 TYPE Unpadded_Structure :\nSTRUCT\n xTest : BOOL;\n iTest : INT; \/\/ SA0016\n byTest : BYTE;\n wTest : WORD;\nEND_STRUCT\nEND_TYPE\n PROGRAM PLC_PRG\nVAR\n myStruct : Unpadded_Structure;\nEND_VAR\n myStruct.iTest := 0; での出力 メッセージ ビュー： SA0016: 構造体「Unpadded_Structure」はパディングする必要があります (pack-mode=8) " }, 
{ "title" : "SA0017: ポインター変数への異常な代入 ", 
"url" : "_san_rule_sa0017.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0017: ポインター変数への異常な代入 ", 
"snippet" : "アドレスを持たないポインタへの割り当てを決定します（演算子 ADR またはポインタ変数）または定数 0 それは。 理由: ポインタに有効なアドレスではない値が割り当てられている場合、ポインタの逆参照により「アクセス違反例外」が発生します。 重要性：高い 例 PROGRAM PLC_PRG VAR pInt : POINTER TO INT; dwAddress : DWORD; END_VAR dwAddress := dwAddress + DWORD#1; pInt := dwAddress; \/\/ SA0017 での出力 メッセージ ビュー： SA0017: ポインター変数への異常な代入...", 
"body" : "アドレスを持たないポインタへの割り当てを決定します（演算子 ADR またはポインタ変数）または定数 0 それは。 理由: ポインタに有効なアドレスではない値が割り当てられている場合、ポインタの逆参照により「アクセス違反例外」が発生します。 重要性：高い 例 PROGRAM PLC_PRG\nVAR\n pInt : POINTER TO INT;\n dwAddress : DWORD;\nEND_VAR\n dwAddress := dwAddress + DWORD#1;\npInt := dwAddress; \/\/ SA0017 での出力 メッセージ ビュー： SA0017: ポインター変数への異常な代入 " }, 
{ "title" : "SA0018：異常なビットアクセス ", 
"url" : "_san_rule_sa0018.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0018：異常なビットアクセス ", 
"snippet" : "符号付き変数へのビットアクセスを検出します。ただし、IEC 61131-3 規格では、ビット フィールドに対するビット アクセスとビット シフト操作のみが許可されています。 厳格なルールも参照してください SA0147 そして SA0148 。 理由：符号付きデータ型をビットフィールドとして使用しないでください。その逆も同様です。 IEC 61131-3規格ではそのようなアクセスは規定されていないため、ポータブルコードを作成する場合は、この規則に従う必要があります。 重要性：中 フラグ列挙型の例外：プラグマ属性を使用した列挙型の場合 {attribute 'flags'} フラグとして宣言され...", 
"body" : "符号付き変数へのビットアクセスを検出します。ただし、IEC 61131-3 規格では、ビット フィールドに対するビット アクセスとビット シフト操作のみが許可されています。 厳格なルールも参照してください SA0147 そして SA0148 。 理由：符号付きデータ型をビットフィールドとして使用しないでください。その逆も同様です。 IEC 61131-3規格ではそのようなアクセスは規定されていないため、ポータブルコードを作成する場合は、この規則に従う必要があります。 重要性：中 フラグ列挙型の例外：プラグマ属性を使用した列挙型の場合 {attribute 'flags'} フラグとして宣言され、操作によるビットアクセスに使用されます OR 、 AND また NOT 間違い SA0018 使われていません。 例 PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n diTemp3 : DINT;\n uliTemp4 : ULINT;\n siTemp5 : SINT;\n usiTemp6 : USINT;\n byTemp2 : BYTE;\nEND_VAR\n iTemp1.3 := TRUE; \/\/SA0018\ndiTemp3.4 := TRUE; \/\/SA0018\nuliTemp4.18 := FALSE; \/\/no error because this is an unsigned data type\nsiTemp5.2 := FALSE; \/\/SA0018\nusiTemp6.3 := TRUE; \/\/no error because this is an unsigned data type\nbyTemp2.5 := FALSE; \/\/no error because the byte is a bitfield での出力 メッセージ ビュー： SA0018: 異常なビットアクセス " }, 
{ "title" : "SA0020：REAL変数への切り捨てられた値の割り当ての可能性 ", 
"url" : "_san_rule_sa0020.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0020：REAL変数への切り捨てられた値の割り当ての可能性 ", 
"snippet" : "データ型変数の切り捨てられた値を含む可能性のある整数変数の演算を検出します REAL 割り当てられています。 理由：整数計算の結果が次の場合、静的コード分析でエラーが発生します REAL - また LREAL -変数が割り当てられます。プログラマーは、そのような割り当ての解釈が正しくない可能性があることに注意する必要があります。 lrealvar := dintvar1 * dintvar2 。 からの値の範囲から LREAL のそれよりも大きい DINT 、計算の結果はいずれにせよ LREAL 表示することができます。そうではありません。プロセッサは、乗算の結果を整数として計算してから、結果...", 
"body" : "データ型変数の切り捨てられた値を含む可能性のある整数変数の演算を検出します REAL 割り当てられています。 理由：整数計算の結果が次の場合、静的コード分析でエラーが発生します REAL - また LREAL -変数が割り当てられます。プログラマーは、そのような割り当ての解釈が正しくない可能性があることに注意する必要があります。 lrealvar := dintvar1 * dintvar2 。 からの値の範囲から LREAL のそれよりも大きい DINT 、計算の結果はいずれにせよ LREAL 表示することができます。そうではありません。プロセッサは、乗算の結果を整数として計算してから、結果を再キャストします LREAL 。整数計算のオーバーフローは失われます。問題を回避したい場合は、請求書はすでに次のようになっている必要があります REAL -行われた手術： lreal_var := TO_LREAL(dintvar1) * TO_LREAL(dintvar2) 重要性：高い 例 PROGRAM PLC_PRG\nVAR\n rX : LREAL;\n dI : DINT;\nEND_VAR\n rX := dI * dI \/\/ SA0020\nrX := TO_LREAL(dI) * TO_LREAL(dI) \/\/no message での出力 メッセージ ビュー： SA0020: 切り捨てられた値が REAL 変数に代入されている可能性があります " }, 
{ "title" : "SA0021：一時変数のアドレスの転送 ", 
"url" : "_san_rule_sa0021.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0021：一時変数のアドレスの転送 ", 
"snippet" : "非一時変数への一時変数（スタック上の変数）のアドレス割り当てを取得します。 理由：関数またはメソッドのローカル変数がスタック上に作成され、関数またはメソッドが処理されている間のみ存在します。メソッドまたは関数が処理された後にポインタがそのような変数を指している場合、このポインタを使用して未定義のメモリにアクセスしたり、別の関数の誤った変数にアクセスしたりできます。いかなる場合でも、この状況は回避する必要があります。 重要性：高い 例 FUNCTION TempVarInFUNC : DWORD VAR uiTemp : UINT; END_VAR TempVarInFUNC := ADR(ui...", 
"body" : "非一時変数への一時変数（スタック上の変数）のアドレス割り当てを取得します。 理由：関数またはメソッドのローカル変数がスタック上に作成され、関数またはメソッドが処理されている間のみ存在します。メソッドまたは関数が処理された後にポインタがそのような変数を指している場合、このポインタを使用して未定義のメモリにアクセスしたり、別の関数の誤った変数にアクセスしたりできます。いかなる場合でも、この状況は回避する必要があります。 重要性：高い 例 FUNCTION TempVarInFUNC : DWORD\nVAR\n uiTemp : UINT;\nEND_VAR\n TempVarInFUNC := ADR(uiTemp); \/\/SA0021 PROGRAM PLC_PRG\nVAR\n dwTest : DWORD;\nEND_VAR dwTest := TempVarInFUNC(); での出力 メッセージ ビュー： SA0021: 一時変数のアドレスを外部スコープのシンボルに転送しています " }, 
{ "title" : "SA0022 :(おそらく）割り当てられていない戻り値 ", 
"url" : "_san_rule_sa0022.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0022 :(おそらく）割り当てられていない戻り値 ", 
"snippet" : "戻り値に割り当てられていない実行スレッドを含むすべての関数とメソッドを検索します。 理論的根拠：関数またはメソッドの未割り当ての戻り値は、コードが欠落していることを示しています。戻り値に常にデフォルト値がある場合でも、あいまいさを避けるために、これを明示的に再度割り当てることは常に理にかなっています。 重要性：中 例 FUNCTION FUN : DINT VAR_INPUT bTest : BOOL; END_VAR IF bTest THEN RETURN; END_IF FUN := 99; での出力 メッセージ ビュー： SA0022: (おそらく) 未割り当ての戻り値...", 
"body" : "戻り値に割り当てられていない実行スレッドを含むすべての関数とメソッドを検索します。 理論的根拠：関数またはメソッドの未割り当ての戻り値は、コードが欠落していることを示しています。戻り値に常にデフォルト値がある場合でも、あいまいさを避けるために、これを明示的に再度割り当てることは常に理にかなっています。 重要性：中 例 FUNCTION FUN : DINT\nVAR_INPUT\n bTest : BOOL;\nEND_VAR\n IF bTest THEN\n RETURN;\nEND_IF\nFUN := 99; での出力 メッセージ ビュー： SA0022: (おそらく) 未割り当ての戻り値 " }, 
{ "title" : "SA0023：複雑な戻り値 ", 
"url" : "_san_rule_sa0023.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0023：複雑な戻り値 ", 
"snippet" : "プロセッサの単純なレジスタコピーでは返すことができない複雑な戻り値を決定します。これには、構造体、配列、およびタイプの戻り値が含まれます STRING （占有ストレージスペースのサイズに関係なく）。 理由: これはパフォーマンスに関する警告です。関数、メソッド、またはプロパティの結果として大きな値が返された場合、プロセッサはコードの実行時にそれらの値を複数回コピーします。これは実行時の問題を引き起こす可能性があるため、可能な限り回避する必要があります。構造化された値を次のように渡すことでパフォーマンスを向上させることができます。 VAR_IN_OUT 関数またはメソッドに追加し、それを関数また...", 
"body" : "プロセッサの単純なレジスタコピーでは返すことができない複雑な戻り値を決定します。これには、構造体、配列、およびタイプの戻り値が含まれます STRING （占有ストレージスペースのサイズに関係なく）。 理由: これはパフォーマンスに関する警告です。関数、メソッド、またはプロパティの結果として大きな値が返された場合、プロセッサはコードの実行時にそれらの値を複数回コピーします。これは実行時の問題を引き起こす可能性があるため、可能な限り回避する必要があります。構造化された値を次のように渡すことでパフォーマンスを向上させることができます。 VAR_IN_OUT 関数またはメソッドに追加し、それを関数またはメソッドに入力します。 重要性：中 例 TYPE LargeStructure :\nSTRUCT\n a : LINT;\n b : BOOL;\nEND_STRUCT\nEND_TYPE\n FUNCTION Large_Return_Value_FUNC : LargeStructure \/\/ SA0023 での出力 メッセージ ビュー： SA0023: 複雑な戻り値 " }, 
{ "title" : "SA0024: 型なしリテラル\/定数 ", 
"url" : "_san_rule_sa0024.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0024: 型なしリテラル\/定数 ", 
"snippet" : "操作の一部である型なしリテラルを識別します 理由: 型指定されていないリテラルは、その使用法に従って自動的に型指定されます。場合によっては、次のような dw := ROL(DWORD#1, i); 、これにより、独自の説明を提供するために型付きリテラルを使用した方がよいという予期せぬ状況が発生する可能性があります。 重要度：低 例 PROGRAM PLC_PRG VAR iTemp1 : INT := 10; \/\/no part of operation diTemp2 : DINT; liTemp3 : LINT; rTemp4 : REAL; lrTemp5 : LREAL; END_VA...", 
"body" : "操作の一部である型なしリテラルを識別します 理由: 型指定されていないリテラルは、その使用法に従って自動的に型指定されます。場合によっては、次のような dw := ROL(DWORD#1, i); 、これにより、独自の説明を提供するために型付きリテラルを使用した方がよいという予期せぬ状況が発生する可能性があります。 重要度：低 例 PROGRAM PLC_PRG\nVAR\n iTemp1 : INT := 10; \/\/no part of operation\n diTemp2 : DINT;\n liTemp3 : LINT;\n rTemp4 : REAL;\n lrTemp5 : LREAL;\n END_VAR iTemp1 := iTemp1 + INT#34;\ndiTemp2 := diTemp2 + 23; \/\/ SA0024\nliTemp3 := liTemp3 + 124; \/\/ SA0024\nrTemp4 := rTemp4 + 1.1; \/\/ SA0024\nlrTemp5 := lrTemp5 + 3.4; \/\/ SA0024\n での出力 メッセージ ビュー： SA0024: 型なしリテラルが見つかりました " }, 
{ "title" : "SA0025：修飾されていない列挙定数 ", 
"url" : "_san_rule_sa0025.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0025：修飾されていない列挙定数 ", 
"snippet" : "列挙の前に修飾名がない場合の列挙定数を決定します。 理由: 限定されたアクセスにより、コードが読みやすくなり、保守が容易になります。修飾された変数名を強制しないと、プログラムの拡張時に追加の列挙が挿入される可能性があります。この列挙には、既存の列挙と同じ名前の定数が含まれています (以下の例を参照: \"red\")。これにより、このコード部分へのアクセスがあいまいになります。 どのような場合でも、プラグマでは列挙型のみを使用することをお勧めします。 {attribute 'qualified-only'} 。 重要性：中 例 TYPE COLOR : (red, green, blue); EN...", 
"body" : "列挙の前に修飾名がない場合の列挙定数を決定します。 理由: 限定されたアクセスにより、コードが読みやすくなり、保守が容易になります。修飾された変数名を強制しないと、プログラムの拡張時に追加の列挙が挿入される可能性があります。この列挙には、既存の列挙と同じ名前の定数が含まれています (以下の例を参照: \"red\")。これにより、このコード部分へのアクセスがあいまいになります。 どのような場合でも、プラグマでは列挙型のみを使用することをお勧めします。 {attribute 'qualified-only'} 。 重要性：中 例 TYPE COLOR :\n (red,\n green,\n blue);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n myColor : COLOR;\nEND_VAR\n myColor := COLOR.red; \/\/ OK\nmyColor := red; \/\/ SA0025 での出力 メッセージ ビュー： SA0025: 列挙定数 'red' は修飾されていません 詳細については、以下を参照してください。 静的コード分析を構成して実行する " }, 
{ "title" : "SA0026：文字列の切り捨ての可能性 ", 
"url" : "_san_rule_sa0026.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0026：文字列の切り捨ての可能性 ", 
"snippet" : "十分な文字列長を使用していない文字列割り当てと文字列初期化子を検出します。 理由：異なる長さの文字列が割り当てられている場合、文字列が切り捨てられる可能性があります。その場合、結果は期待どおりではありません。 重要性：中 例 PROGRAM PLC_PRG VAR strVar1 : STRING[10]; strVar2 : STRING[6]; strVar3 : STRING[6] := 'abcdefghi'; \/\/ SA0026 END_VAR strVar2 := strVar1; \/\/ SA0026 での出力 メッセージ ビュー： SA0026: 'abcdefghi' の切り詰...", 
"body" : "十分な文字列長を使用していない文字列割り当てと文字列初期化子を検出します。 理由：異なる長さの文字列が割り当てられている場合、文字列が切り捨てられる可能性があります。その場合、結果は期待どおりではありません。 重要性：中 例 PROGRAM PLC_PRG\nVAR\n strVar1 : STRING[10];\n strVar2 : STRING[6];\n strVar3 : STRING[6] := 'abcdefghi'; \/\/ SA0026\nEND_VAR\n strVar2 := strVar1; \/\/ SA0026 での出力 メッセージ ビュー： SA0026: 'abcdefghi' の切り詰め SA0026: 文字列 'strVar1' が切り捨てられる可能性があります 詳細については、以下を参照してください。 静的コード分析を構成して実行する " }, 
{ "title" : "SA0027：識別子の複数の使用 ", 
"url" : "_san_rule_sa0027.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0027：識別子の複数の使用 ", 
"snippet" : "プロジェクトのスコープ内での変数またはオブジェクト（POU）の名前\/識別子の複数の使用を検出します。 列挙の場合、修飾名が考慮されます。 理論的根拠：同じ名前は、コードを読むときに混乱する可能性があります。間違ったオブジェクトに誤ってアクセスすると、エラーが発生する可能性があります。したがって、このような状況を回避するために、命名規則を定義して従います。 次のケースがカバーされています。 列挙定数の名前は、アプリケーション内またはリンクライブラリ内の別の列挙の名前と同じです。 変数の名前は、アプリケーションまたは統合ライブラリ内の別のオブジェクトの名前と同じです。 変数の名前は、アプリケーショ...", 
"body" : "プロジェクトのスコープ内での変数またはオブジェクト（POU）の名前\/識別子の複数の使用を検出します。 列挙の場合、修飾名が考慮されます。 理論的根拠：同じ名前は、コードを読むときに混乱する可能性があります。間違ったオブジェクトに誤ってアクセスすると、エラーが発生する可能性があります。したがって、このような状況を回避するために、命名規則を定義して従います。 次のケースがカバーされています。 列挙定数の名前は、アプリケーション内またはリンクライブラリ内の別の列挙の名前と同じです。 変数の名前は、アプリケーションまたは統合ライブラリ内の別のオブジェクトの名前と同じです。 変数の名前は、アプリケーションまたは統合ライブラリの列挙型の列挙型定数の名前と同じです。 オブジェクトの名前は、アプリケーションまたはリンクライブラリ内の別のオブジェクトの名前と同じです。 重要性：中 例 TYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n color : INT;\nEND_VAR\n での出力 メッセージ ビュー： SA0027: 'PLC_PRG' の変数名 'color' は、このアプリケーションのオブジェクトにすでに使用されています 詳細については、以下を参照してください。 静的解析の構成と実行 " }, 
{ "title" : "SA0028：重複するメモリ領域 ", 
"url" : "_san_rule_sa0028.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0028：重複するメモリ領域 ", 
"snippet" : "2つ以上の変数が同じメモリ空間を占めるコードを決定します。 理由: 2 つの変数が同じメモリを予約すると、コードが予期しない結果で動作する可能性があります。このような状況は何としても避けるべきです。値をさまざまな解釈で使用することを避けられない場合 (たとえば、ある値を次のように解釈する) DINT そしてまた別の時として REAL ) の場合は、を定義する必要があります。 UNION 。ポインターを使用すると、値を変換せずに、異なる型の値にアクセスすることもできます。 重要性：高い 例 PROGRAM PLC_PRG VAR iVvar1 AT %QB21: INT; dwVar2 AT %...", 
"body" : "2つ以上の変数が同じメモリ空間を占めるコードを決定します。 理由: 2 つの変数が同じメモリを予約すると、コードが予期しない結果で動作する可能性があります。このような状況は何としても避けるべきです。値をさまざまな解釈で使用することを避けられない場合 (たとえば、ある値を次のように解釈する) DINT そしてまた別の時として REAL ) の場合は、を定義する必要があります。 UNION 。ポインターを使用すると、値を変換せずに、異なる型の値にアクセスすることもできます。 重要性：高い 例 PROGRAM PLC_PRG\nVAR\n iVvar1 AT %QB21: INT;\n dwVar2 AT %QD5: DWORD;\nEND_VAR\n での出力 メッセージ ビュー： 次の変数は同じメモリにアクセスします。 SA0028: iVar1 AT %QB21 SA0028: dwVar2 AT %QD5 詳細については、以下を参照してください。 静的コード分析を構成して実行する " }, 
{ "title" : "SA0029：実装と宣言の表記が異なります ", 
"url" : "_san_rule_sa0029.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0029：実装と宣言の表記が異なります ", 
"snippet" : "識別子の表記が宣言の表記と異なるコード位置を決定します。 根拠: IEC 61131-3 標準では、識別子は大文字と小文字を区別しないと定義されています。これは、「」として宣言された変数を意味します。 varx 「」としても使用できます VaRx ただし、これは混乱を招き誤解を招くため、避けてください。 重要性：中 例 デバイスツリーにブロックがあります PLC_PRG とレンガ fnc （関数）。 PROGRAM PLC_PRG VAR iVar: INT; _123test_var_: INT; END_VAR ivar := iVar + 1; \/\/ SA0029 _123TEST_va...", 
"body" : "識別子の表記が宣言の表記と異なるコード位置を決定します。 根拠: IEC 61131-3 標準では、識別子は大文字と小文字を区別しないと定義されています。これは、「」として宣言された変数を意味します。 varx 「」としても使用できます VaRx ただし、これは混乱を招き誤解を招くため、避けてください。 重要性：中 例 デバイスツリーにブロックがあります PLC_PRG とレンガ fnc （関数）。 PROGRAM PLC_PRG\nVAR\n iVar: INT;\n _123test_var_: INT;\nEND_VAR\n ivar := iVar + 1; \/\/ SA0029\n_123TEST_var_ := _123test_var_; \/\/ SA0029\nFnc(); \/\/ SA0029 での出力 メッセージ ビュー： SA0029: コード内の表記 (ivar) は宣言 (iVar) と等しくなければなりません SA0029: コード内の表記 (_123TEST_var_) は宣言 (_123test_var_) と等しくなければなりません SA0029: コード内の表記 (Fnc) は宣言 (fnc) と等しくなければなりません 詳細については、以下を参照してください。 静的解析の構成と実行 " }, 
{ "title" : "未使用のオブジェクトを一覧表示する ", 
"url" : "_san_list_unused_objects.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 未使用のオブジェクトを一覧表示する ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0031：未使用の署名 ", 
"url" : "_san_rule_sa0031.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 未使用のオブジェクトを一覧表示する \/ SA0031：未使用の署名 ", 
"snippet" : "コンパイルされたプログラムコード内で呼び出されないプログラム、関数ブロック、関数、データ型、インターフェイス、メソッド、プロパティ、およびアクションを識別します。 理論的根拠：未使用のオブジェクトはプロジェクトに不要なバルクを追加し、コードを読み取るときに混乱する可能性があります。 重要度：低 PLCopenルール：CP2 プロジェクトに複数のアプリケーションがある場合は、現在アクティブなアプリケーションの下にあるオブジェクトのみが考慮されます。アプリケーションが1つしかない場合は、POUプール内のオブジェクトも考慮されます。 も参照してください 静的コード分析を構成して実行する...", 
"body" : "コンパイルされたプログラムコード内で呼び出されないプログラム、関数ブロック、関数、データ型、インターフェイス、メソッド、プロパティ、およびアクションを識別します。 理論的根拠：未使用のオブジェクトはプロジェクトに不要なバルクを追加し、コードを読み取るときに混乱する可能性があります。 重要度：低 PLCopenルール：CP2 プロジェクトに複数のアプリケーションがある場合は、現在アクティブなアプリケーションの下にあるオブジェクトのみが考慮されます。アプリケーションが1つしかない場合は、POUプール内のオブジェクトも考慮されます。 も参照してください 静的コード分析を構成して実行する " }, 
{ "title" : "SA0032：未使用の列挙定数 ", 
"url" : "_san_rule_sa0032.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 未使用のオブジェクトを一覧表示する \/ SA0032：未使用の列挙定数 ", 
"snippet" : "コンパイルされたプログラムコードで使用されない列挙定数を決定します。 理由：未使用の列挙定数は、列挙定義を不必要に拡大し、プログラムを読み取るときに混乱する可能性があります。 PLCopenルール：CP24 重要度：低 プロジェクトに複数のアプリケーションがある場合は、現在アクティブなアプリケーションの下にあるオブジェクトのみが考慮されます。アプリケーションが1つしかない場合は、一般的なPOUプール内のオブジェクトも考慮されます。 例 TYPE My_Enum : ( one := 1, two := 2 ); END_TYPE での出力 メッセージ ビュー： SA0032: 未使用の列挙定数...", 
"body" : "コンパイルされたプログラムコードで使用されない列挙定数を決定します。 理由：未使用の列挙定数は、列挙定義を不必要に拡大し、プログラムを読み取るときに混乱する可能性があります。 PLCopenルール：CP24 重要度：低 プロジェクトに複数のアプリケーションがある場合は、現在アクティブなアプリケーションの下にあるオブジェクトのみが考慮されます。アプリケーションが1つしかない場合は、一般的なPOUプール内のオブジェクトも考慮されます。 例 TYPE My_Enum :\n(\n one := 1, \n two := 2\n);\nEND_TYPE\n での出力 メッセージ ビュー： SA0032: 未使用の列挙定数 'one' SA0032: 未使用の列挙定数 'two' 詳細については、以下を参照してください。 静的解析の構成と実行 " }, 
{ "title" : "SA0033：未使用の変数 ", 
"url" : "_san_rule_sa0033.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 未使用のオブジェクトを一覧表示する \/ SA0033：未使用の変数 ", 
"snippet" : "宣言されているが、コンパイルされたプログラムコード内で使用されていない変数を決定します。 理論的根拠：未使用の変数は、プログラムを読みにくくし、保守しにくくします。使用されない変数は、メモリを不必要に占有し、初期化中に実行時間のコストを不必要に消費します。 重要性：中 PLCopenルール：CP22 \/ CP24 GVL 変数の場合:プロジェクトに複数のアプリケーションが存在する場合、現在アクティブなアプリケーションの下にあるオブジェクトのみが考慮されます。アプリケーションが 1 つしかない場合は、共通 POU プール内のオブジェクトも考慮されます 例 PROGRAM PLC_PRG VAR ...", 
"body" : "宣言されているが、コンパイルされたプログラムコード内で使用されていない変数を決定します。 理論的根拠：未使用の変数は、プログラムを読みにくくし、保守しにくくします。使用されない変数は、メモリを不必要に占有し、初期化中に実行時間のコストを不必要に消費します。 重要性：中 PLCopenルール：CP22 \/ CP24 GVL 変数の場合:プロジェクトに複数のアプリケーションが存在する場合、現在アクティブなアプリケーションの下にあるオブジェクトのみが考慮されます。アプリケーションが 1 つしかない場合は、共通 POU プール内のオブジェクトも考慮されます 例 PROGRAM PLC_PRG\nVAR\n iCounter1 : INT;\n iCounter2 : INT; \/\/ SA0033\nEND_VAR\n iCounter1 := 100; での出力 メッセージ ビュー： SA0033: 未使用の変数 'iCounter2' 詳細については、以下を参照してください。 静的解析の構成と実行 " }, 
{ "title" : "SA0035：未使用の入力変数 ", 
"url" : "_san_rule_sa0035.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 未使用のオブジェクトを一覧表示する \/ SA0035：未使用の入力変数 ", 
"snippet" : "関数ブロックインスタンスで使用されない入力変数を決定します。 理由:未使用の入力変数は、プログラムの可読性と保守性を低下させます。未使用の変数はメモリを不必要にいっぱいにし、初期化中にランタイムを不必要に浪費します。 入力が使用されるのは、関数ブロックインスタンス自体の実装 (またはメソッド) 内でアクティブに参照されている場合のみです。 重要性：中 PLCopenルール：CP24 例 FUNCTION_BLOCK FB_Afb VAR_INPUT iIn1: INT; iIn2: INT; END_VAR VAR_OUTPUT iOut1: INT; END_VAR iOut1 := iIn...", 
"body" : "関数ブロックインスタンスで使用されない入力変数を決定します。 理由:未使用の入力変数は、プログラムの可読性と保守性を低下させます。未使用の変数はメモリを不必要にいっぱいにし、初期化中にランタイムを不必要に浪費します。 入力が使用されるのは、関数ブロックインスタンス自体の実装 (またはメソッド) 内でアクティブに参照されている場合のみです。 重要性：中 PLCopenルール：CP24 例 FUNCTION_BLOCK FB_Afb\nVAR_INPUT\n iIn1: INT;\n iIn2: INT;\nEND_VAR\nVAR_OUTPUT\n iOut1: INT;\nEND_VAR iOut1 := iIn1; \/\/ iIn1 is used here PROGRAM PLC_PRG\nVAR\n fbAfb: FB_Afb;\nEND_VAR\n fbAfb(iIn2 := 99); \/\/ iIn2 is unused internally => error での出力 メッセージ ビュー： SA0035: 未使用の入力 'iIn2' " }, 
{ "title" : "SA0036：未使用の出力変数 ", 
"url" : "_san_rule_sa0036.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 未使用のオブジェクトを一覧表示する \/ SA0036：未使用の出力変数 ", 
"snippet" : "関連する機能または機能ブロック内で割り当てられていない機能および機能ブロックの出力変数を決定します。 理論的根拠：未使用の変数は、プログラムを読みにくくし、保守しにくくします。使用されない変数は、メモリを不必要に占有し、初期化中に実行時間のコストを不必要に消費します。 重要性：中 PLCopenルール：CP24 例 FUNCTION_BLOCK FB_Afb VAR_INPUT iIn1: INT; iIn2: INT; END_VAR VAR_OUTPUT iOut1: INT; iOut2: INT; END_VAR iOut1 := iIn1 + iIn2; での出力 メッセージ ビュー...", 
"body" : "関連する機能または機能ブロック内で割り当てられていない機能および機能ブロックの出力変数を決定します。 理論的根拠：未使用の変数は、プログラムを読みにくくし、保守しにくくします。使用されない変数は、メモリを不必要に占有し、初期化中に実行時間のコストを不必要に消費します。 重要性：中 PLCopenルール：CP24 例 FUNCTION_BLOCK FB_Afb\nVAR_INPUT\n iIn1: INT;\n iIn2: INT;\nEND_VAR\nVAR_OUTPUT\n iOut1: INT;\n iOut2: INT;\nEND_VAR\n iOut1 := iIn1 + iIn2; での出力 メッセージ ビュー： SA0036: 未使用の出力 'iOut1' " }, 
{ "title" : "SA0034：割り当てが正しくない列挙型変数 ", 
"url" : "_san_rule_sa0034.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0034：割り当てが正しくない列挙型変数 ", 
"snippet" : "列挙型変数に割り当てられた値を取得します。定義された列挙定数のみを列挙変数に割り当てることができます。 理由: 列挙型の変数には、意図した値のみが含まれている必要があります。そうでないと、この変数を使用するコードが正しく動作しない可能性があります。プラグマでは常に列挙型を使用することをお勧めします。 {attribute 'strict'} 。その後、コンパイラは列挙コンポーネントが正しく使用されているかどうかをすでにチェックしています。 重要性：高い 例 TYPE COLOR : ( Red := 0, Green, Yellow ); END_TYPE PROGRAM PLC_PRG VA...", 
"body" : "列挙型変数に割り当てられた値を取得します。定義された列挙定数のみを列挙変数に割り当てることができます。 理由: 列挙型の変数には、意図した値のみが含まれている必要があります。そうでないと、この変数を使用するコードが正しく動作しない可能性があります。プラグマでは常に列挙型を使用することをお勧めします。 {attribute 'strict'} 。その後、コンパイラは列挙コンポーネントが正しく使用されているかどうかをすでにチェックしています。 重要性：高い 例 TYPE COLOR :\n(\n Red := 0,\n Green,\n Yellow\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n eColor1: COLOR;\nEND_VAR\n eColor1 := COLOR.Red;\neColor1 := 1; \/\/ SA0034 での出力 メッセージ ビュー： SA0034: 'INT#1' の代わりに列挙値を使用します 詳細については、以下を参照してください。 静的解析の構成と実行 " }, 
{ "title" : "SA0037：入力変数への書き込みアクセス ", 
"url" : "_san_rule_sa0037.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0037：入力変数への書き込みアクセス ", 
"snippet" : "入力変数を検出します ( VAR_INPUT ) POU 内で書き込み権限でアクセスされます。 理由：IEC 61131-3規格によると、入力変数はブロック内で変更してはなりません。このようなアクセスもエラーの原因であり、コードの保守が困難になります。次に、変数が入力として使用され、同時に補助変数として使用されることを示します。このような二重使用は避けてください。 重要性：中 例 VAR_GLOBAL g_xGlob AT %QX0.0 : BOOL; END_VAR PROGRAM PLC_PRG VAR_INPUT xVarIn1 : BOOL; xVarIn2 : BOOL; END_V...", 
"body" : "入力変数を検出します ( VAR_INPUT ) POU 内で書き込み権限でアクセスされます。 理由：IEC 61131-3規格によると、入力変数はブロック内で変更してはなりません。このようなアクセスもエラーの原因であり、コードの保守が困難になります。次に、変数が入力として使用され、同時に補助変数として使用されることを示します。このような二重使用は避けてください。 重要性：中 例 VAR_GLOBAL\n g_xGlob AT %QX0.0 : BOOL;\nEND_VAR PROGRAM PLC_PRG\nVAR_INPUT\n xVarIn1 : BOOL;\n xVarIn2 : BOOL;\nEND_VAR\nVAR\n iCondition : INT;\nEND_VAR\n iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n g_xGlob := xVarIn1;\n INT#2:\n g_xGlob := xVarIn2;\n ELSE\n g_xGlob := FALSE;\n xVarIn1 := FALSE; \/\/ SA0037\nEND_CASE での出力 メッセージ ビュー： SA0037: 入力変数 'xVarIn1' への書き込みアクセス " }, 
{ "title" : "SA0038：出力変数への読み取りアクセス ", 
"url" : "_san_rule_sa0038.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0038：出力変数への読み取りアクセス ", 
"snippet" : "出力変数を検出します ( VAR_OUTPUT ) POU 内の読み取り権限でアクセスされます。 理由：61131-3によると、ブロック内の出力を読み取ることは禁止されています。これは、出力が出力としてだけでなく、中間結果の一時変数としても使用されることを示します。このような二重使用は避けてください。 重要度：低 例 VAR_GLOBAL g_xGlob AT %QX0.0 : BOOL ; g_iGlob AT %QW1 : INT ; END_VAR PROGRAM PLC_PRG VAR_OUTPUT xVarOut1:BOOL; xVarOut2:INT; xVarOut3:INT; ...", 
"body" : "出力変数を検出します ( VAR_OUTPUT ) POU 内の読み取り権限でアクセスされます。 理由：61131-3によると、ブロック内の出力を読み取ることは禁止されています。これは、出力が出力としてだけでなく、中間結果の一時変数としても使用されることを示します。このような二重使用は避けてください。 重要度：低 例 VAR_GLOBAL\n g_xGlob AT %QX0.0 : BOOL ;\n g_iGlob AT %QW1 : INT ;\nEND_VAR PROGRAM PLC_PRG\nVAR_OUTPUT\n xVarOut1:BOOL;\n xVarOut2:INT;\n xVarOut3:INT;\nEND_VAR\nVAR\n iCondition : INT;\nEND_VAR iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n xVarOut1 := g_xGlob;\n xVarOut2 := g_iGlob;\n INT#2:\n xVarOut3 := xVarOut2; \/\/ SA0038\n ELSE\n xVarOut1 := FALSE;\n g_xGlob := xVarOut1; \/\/ SA0038\n xVarOut2 := INT#0;\n xVarOut3 := INT#-1;\nEND_CASE での出力 メッセージ ビュー： SA0038: 出力変数 'xVarOUT2' への読み取りアクセス SA0026: SA0038: 出力変数 'xVarOUT1' への読み取りアクセス " }, 
{ "title" : "SA0040：ゼロによる除算の可能性 ", 
"url" : "_san_rule_sa0040.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0040：ゼロによる除算の可能性 ", 
"snippet" : "ゼロ除算が発生する可能性のあるコードを判別します。 正当化: による除算 0 エラーが発生します。除算する変数は常に最初に 0 であるかどうかをチェックする必要があります。 重要性：高い 例 VAR_GLOBAL g_iVar AT %QW1 : INT; END_VAR PROGRAM PLC_PRG VAR iCounter : INT; iSumme:INT; iMid:INT; iVal1:INT := INT#2; iVal2:INT; iVal3:INT := INT#3; iVal4:INT := INT#4; iVal5:INT; END_VAR IF iVal2 <> 0 T...", 
"body" : "ゼロ除算が発生する可能性のあるコードを判別します。 正当化: による除算 0 エラーが発生します。除算する変数は常に最初に 0 であるかどうかをチェックする必要があります。 重要性：高い 例 VAR_GLOBAL\n g_iVar AT %QW1 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n iCounter : INT;\n iSumme:INT;\n iMid:INT;\n iVal1:INT := INT#2;\n iVal2:INT;\n iVal3:INT := INT#3;\n iVal4:INT := INT#4;\n iVal5:INT;\nEND_VAR IF iVal2 <> 0 THEN\n iVal1 := iVal1\/iVal2; \/\/ no error\nEND_IF;\niMid := iSumme \/ iCounter; \/\/ SA0040\niCounter := iCounter + INT#1;\niSumme := g_iVar + iSumme;\nIF iMid < INT#100 THEN\n iVal1 := iVal1 \/ iVal2; \/\/ SA0040\nEND_IF での出力 メッセージ ビュー： SA0040: ゼロ除算の可能性 SA0040: ゼロ除算の可能性 " }, 
{ "title" : "SA0041：ループ不変コードの可能性 ", 
"url" : "_san_rule_sa0041.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0041：ループ不変コードの可能性 ", 
"snippet" : "各ループ サイクルで同じ値を計算するループ内の代入を検出します。このようなコード行はループの外側に挿入される可能性があります。 理由: これはパフォーマンスに関する警告です。ループ内で実行されるが、各ループ サイクルで同じことを行うコードは、ループの外で実行できます。 重要性：中 例 PROGRAM PLC_PRG VAR iCounter, iVar1, iVar2 : INT; END_VAR FOR iCounter := 0 TO 10 DO iVar1 := 100; \/\/ SA0041 iVar2 := iVar2 + iVar1; END_FOR での出力 メッセージ ビュー： ...", 
"body" : "各ループ サイクルで同じ値を計算するループ内の代入を検出します。このようなコード行はループの外側に挿入される可能性があります。 理由: これはパフォーマンスに関する警告です。ループ内で実行されるが、各ループ サイクルで同じことを行うコードは、ループの外で実行できます。 重要性：中 例 PROGRAM PLC_PRG\nVAR\n iCounter, iVar1, iVar2 : INT;\nEND_VAR FOR iCounter := 0 TO 10 DO\n iVar1 := 100; \/\/ SA0041\n iVar2 := iVar2 + iVar1;\nEND_FOR\n での出力 メッセージ ビュー： SAN0041: ループ不変コード「iVar1 := 100」の可能性があります " }, 
{ "title" : "SA0042：異なるアクセスパスの使用 ", 
"url" : "_san_rule_sa0042.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0042：異なるアクセスパスの使用 ", 
"snippet" : "同じ変数に対する異なるアクセスパスの使用を検出します。 理由：同じ要素へのアクセスが異なると、プログラムの可読性と保守性が低下します。一貫して使用することをお勧めします {attribute 'qualified-only'} ライブラリ、グローバル変数リスト、および列挙型の場合。これにより、完全に修飾されたアクセスが強制されます。 重要度：低 例 VAR_GLOBAL iTemp:INT; instPOU:POU; END_VAR FUNCTION_BLOCK POU VAR a:INT; END_VAR a := INT#1; PROGRAM SA0042 VAR ptiTemp:POIN...", 
"body" : "同じ変数に対する異なるアクセスパスの使用を検出します。 理由：同じ要素へのアクセスが異なると、プログラムの可読性と保守性が低下します。一貫して使用することをお勧めします {attribute 'qualified-only'} ライブラリ、グローバル変数リスト、および列挙型の場合。これにより、完全に修飾されたアクセスが強制されます。 重要度：低 例 VAR_GLOBAL\n iTemp:INT;\n instPOU:POU;\nEND_VAR FUNCTION_BLOCK POU\nVAR\n a:INT;\nEND_VAR\n a := INT#1; PROGRAM SA0042\nVAR\n ptiTemp:POINTER TO INT;\n sTemp:STRING;\nEND_VAR ptiTemp := ADR(iTemp);\n\nptiTemp^ := INT#1;\niTemp := INT#2; \/\/ SA0042 - direct access on variable\nGVL.iTemp := INT#3; \/\/ SA0042 - access on variable via GVL\n\nsTemp := CONCAT( 'ab', 'cd'); \/\/ SA0042 - direct access on function\nsTemp := Standard.CONCAT( 'ab', 'cd'); \/\/ SA0042 - access on function via Standard\n\ninstPOU(); \/\/ SA0042 - direct access on POU instance\nGVL.instPOU(); \/\/ SA0042 - access via GVL\n での出力 メッセージ ビュー： SA0042: 'CONCAT' の異なるアクセス パス SA0042: 'Standard.CONCAT' の異なるアクセス パス SA0042: 'instPOU' の異なるアクセス パス SA0042: 「GVL.instPOU」の異なるアクセス パス SA0042: 「iTemp」の異なるアクセス パス SA0042: 「GVL.iTemp」の異なるアクセス パス " }, 
{ "title" : "SA0043: 1 つの POU のみでのグローバル変数の使用 ", 
"url" : "_san_rule_sa0043.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0043: 1 つの POU のみでのグローバル変数の使用 ", 
"snippet" : "単一のビルディングブロックでのグローバル変数の使用を検出します。 理由: 1 つの場所でのみ使用されるグローバル変数も、その場所でのみ宣言する必要があります。 重要性：中 PLCopenルール：CP26 例 VAR_GLOBAL g_xVar AT %QX0.0 : BOOL ; g_iTest AT %QW1 : INT ; g_wTest AT %QW2 : WORD; END_VAR PROGRAM prog1 VAR iCondition : INT; bTemp : BOOL; END_VAR iCondition := iCondition + INT#1; IF iConditi...", 
"body" : "単一のビルディングブロックでのグローバル変数の使用を検出します。 理由: 1 つの場所でのみ使用されるグローバル変数も、その場所でのみ宣言する必要があります。 重要性：中 PLCopenルール：CP26 例 VAR_GLOBAL\n g_xVar AT %QX0.0 : BOOL ;\n g_iTest AT %QW1 : INT ;\n g_wTest AT %QW2 : WORD;\nEND_VAR PROGRAM prog1\nVAR\n iCondition : INT;\n bTemp : BOOL;\nEND_VAR\n iCondition := iCondition + INT#1;\nIF iCondition < INT#0 THEN\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\n ELSIF iCondition = INT#0 THEN\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\nELSE\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\n g_wTest := WORD#4; \/\/ g_WTest used also in prog2 -> OK\nEND_IF PROGRAM prog2\nVAR\n iCondition : INT;\nEND_VAR\n iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n g_iTest := WORD_TO_INT(g_wTest); \/\/ SA0043 - g_iTest only written in this POU\n INT#2:\n g_iTest := INT#2; \/\/ SA0043 - g_iTest only written in this POU\n ELSE\n g_iTest := INT#3; \/\/ SA0043 - g_iTest only written in this POU\nEND_CASE での出力 メッセージ ビュー： SA0043: グローバル変数 'g_xVar' は 'prog1' でのみ使用されます SA0043: グローバル変数 'g_iTest' は 'prog2' でのみ使用されます " }, 
{ "title" : "SA0044：インターフェース参照付きの宣言 ", 
"url" : "_san_rule_sa0044.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0044：インターフェース参照付きの宣言 ", 
"snippet" : "で宣言を決定します REFERENCE TO -インターフェースと宣言 VAR_IN_OUT -インターフェースを備えた変数（暗黙的に REFERENCE TO 気がついた）。 理由：インタフェースタイプは常に、このインタフェースを実装する汎用モジュールのインスタンスへの暗黙の参照です。したがって、インターフェースへの参照は参照への参照であり、非常に望ましくない動作につながる可能性があります。 重要性：高い 例 ITF プロジェクトで定義されたインターフェースです。 FUNCTION_BLOCK POU VAR_INPUT inst_itf2 : ITF; END_VAR VAR_OUTPUT...", 
"body" : "で宣言を決定します REFERENCE TO -インターフェースと宣言 VAR_IN_OUT -インターフェースを備えた変数（暗黙的に REFERENCE TO 気がついた）。 理由：インタフェースタイプは常に、このインタフェースを実装する汎用モジュールのインスタンスへの暗黙の参照です。したがって、インターフェースへの参照は参照への参照であり、非常に望ましくない動作につながる可能性があります。 重要性：高い 例 ITF プロジェクトで定義されたインターフェースです。 FUNCTION_BLOCK POU\nVAR_INPUT\n inst_itf2 : ITF;\nEND_VAR\nVAR_OUTPUT\n inst_itf3 : ITF;\nEND_VAR\nVAR_IN_OUT\n inst_itf4 : ITF; \/\/ SA0044\nEND_VAR\n PROGRAM PLC_PRG\nVAR\n inst : POU;\n itf_inst1 : ITF;\n itf_ref : REFERENCE TO ITF; \/\/ SA0044\nEND_VAR での出力 メッセージ ビュー： SA0044: インターフェース「itf4_ref」への参照 SA0044: インターフェース「itf_ref」への参照 " }, 
{ "title" : "変換 ", 
"url" : "_san_conversion.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 変換 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0019: 暗黙的なポインタ変換 ", 
"url" : "_san_rule_sa0019.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 変換 \/ SA0019: 暗黙的なポインタ変換 ", 
"snippet" : "暗黙的に生成されたポインター変換を検出します 正当化:はい CODESYS ポインタは厳密に入力されているわけではなく、どのような方法でも相互に割り当てることができます。これはよく使われるので、コンパイラからは報告されません。ただし、不正アクセスや予期しないアクセスにつながる可能性もあります。たとえば、タイプを割り当てたとします。 POINTER TO DWORD 次の型のポインタへ POINTER TO BYTE 、メモリは望ましくない方法で上書きされる可能性があります。 したがって、常にこのルールを確認して、意図的に別のタイプの値にアクセスしたい場合にのみメッセージをブロックしてください。...", 
"body" : "暗黙的に生成されたポインター変換を検出します 正当化:はい CODESYS ポインタは厳密に入力されているわけではなく、どのような方法でも相互に割り当てることができます。これはよく使われるので、コンパイラからは報告されません。ただし、不正アクセスや予期しないアクセスにつながる可能性もあります。たとえば、タイプを割り当てたとします。 POINTER TO DWORD 次の型のポインタへ POINTER TO BYTE 、メモリは望ましくない方法で上書きされる可能性があります。 したがって、常にこのルールを確認して、意図的に別のタイプの値にアクセスしたい場合にのみメッセージをブロックしてください。 への変換、およびからの変換 POINTER TO BYTE データ型は SA0019 ルールではチェックされません。これらは常に許可されています 暗黙的なデータ型の変換は、別のメッセージで報告されます。 重要性：高い PLCopenルール：CP25 例外： BOOL <-> BIT 例 PROGRAM PLC_PRG\nVAR\n pInt : POINTER TO INT;\n byteVar : BYTE;\nEND_VAR\n pInt := ADR(byteVar); での出力 メッセージ ビュー: SA0019: 'バイトへのポインタ' へのポインタから 'ポインタから INT へのポインタ' への暗黙の変換 " }, 
{ "title" : "SA0130: 暗黙的な拡張変換 ", 
"url" : "_san_rule_sa0130.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 変換 \/ SA0130: 暗黙的な拡張変換 ", 
"snippet" : "算術演算中に小さいデータ型から大きいデータ型への変換が暗黙的に実行されるコードの位置を検出します。 理由: ソース型の値の範囲がターゲット型の値の範囲内に完全に含まれている場合、コンパイラは異なる型の代入を許可します。ただし、コンパイラは、できる限り遅いタイミングでコードへの変換を構築します。タイプの割り当ての場合 lint := dint * dint の場合、コンパイラは乗算後にのみ暗黙的な変換を実行します。 lint := TO_LINT(dint * dint); したがって、オーバーフローは切り捨てられます。これを防ぎたい場合は、要素をすでに変換できます。 lint := TO_LI...", 
"body" : "算術演算中に小さいデータ型から大きいデータ型への変換が暗黙的に実行されるコードの位置を検出します。 理由: ソース型の値の範囲がターゲット型の値の範囲内に完全に含まれている場合、コンパイラは異なる型の代入を許可します。ただし、コンパイラは、できる限り遅いタイミングでコードへの変換を構築します。タイプの割り当ての場合 lint := dint * dint の場合、コンパイラは乗算後にのみ暗黙的な変換を実行します。 lint := TO_LINT(dint * dint); したがって、オーバーフローは切り捨てられます。これを防ぎたい場合は、要素をすでに変換できます。 lint := TO_LINT(dint) * TO_LINT(dint); したがって、コンパイラが暗黙的な変換を実装する場所を報告して、これらが正確に意図したものであるかどうかを確認すると役立つ場合があります。さらに、他のシステムの型チェックがより制限されている場合は、明示的な変換を使用して、他のシステムへの移植性を向上させることができます。 重要度：低 例 PROGRAM PLC_PRG\nVAR\n d : DINT;\n l : LINT;\n ui : UINT;\n uli : ULINT;\n usi : USINT;\n lw : LWORD;\n udi : UDINT;\n lr : LREAL;\n b : BYTE;\nEND_VAR\n (*The following lines could result in unwanted truncating by implicit conversions \nand should be reported with SA0130*) \nl := d * d;\nuli := usi * usi;\nlw := udi * udi;\nlr := b * b;\nd := ui * ui; での出力 メッセージ ビュー： SA0130: 型 'DINT' から型 'LINT' への暗黙的な拡張変換 SA0130: 型 'USINT' から型 'ULINT' への暗黙的な拡張変換 SA0130: 'UDINT' 型から 'LWORD' 型への暗黙的な拡張変換 SA0130: 'USINT' 型から 'LREAL' 型への暗黙的な拡張変換 SA0130: 型 'UINT' から型 'DINT' への暗黙的な拡張変換 " }, 
{ "title" : "SA0133：明示的なナローイング変換 ", 
"url" : "_san_rule_sa0133.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 変換 \/ SA0133：明示的なナローイング変換 ", 
"snippet" : "大きいデータ型から小さいデータ型への明示的に実行された変換を決定します。 根拠: 多数の型変換が行われる場合は、変数に間違ったデータ型を選択したことを示している可能性があります。このため、データ型変換の明示的な理由を要求するプログラミング ガイドラインがあります。 重要度：低 例 PROGRAM SA0133 VAR siVar:SINT; diVar:DINT; liVar:LINT; byVar:BYTE; uiVar:UINT; dwVar:DWORD; lwVar:LWORD; rVar:REAL; lrVar:LREAL; END_VAR siVar := LINT_TO_SINT(...", 
"body" : "大きいデータ型から小さいデータ型への明示的に実行された変換を決定します。 根拠: 多数の型変換が行われる場合は、変数に間違ったデータ型を選択したことを示している可能性があります。このため、データ型変換の明示的な理由を要求するプログラミング ガイドラインがあります。 重要度：低 例 PROGRAM SA0133\nVAR\n siVar:SINT;\n diVar:DINT;\n liVar:LINT;\n byVar:BYTE;\n uiVar:UINT;\n dwVar:DWORD;\n lwVar:LWORD;\n rVar:REAL;\n lrVar:LREAL;\nEND_VAR\n siVar := LINT_TO_SINT(liVar); \/\/ SA0133\nbyVar := DINT_TO_BYTE(diVar); \/\/ SA0133\nsiVar := DWORD_TO_SINT(dwVar); \/\/ SA0133\nuiVar := LREAL_TO_UINT(lrVar); \/\/ SA0133\nrVar := LWORD_TO_REAL(lwVar); \/\/ SA0133 での出力 メッセージ ビュー： SA0133: 型 'LINT' から型 'SINT' への明示的な縮小変換 SA0133: 型 'DINT' から型 'BYTE' への明示的な縮小変換 SA0133: 型 'DWORD' から型 'SINT' への明示的な絞り込み変換 SA0133: 'LREAL' 型から 'UINT' 型への明示的な縮小変換 SA0133: 型 'LWORD' から型 'REAL' への明示的な縮小変換 " }, 
{ "title" : "SA0134：明示的な符号付き\/符号なし変換 ", 
"url" : "_san_rule_sa0134.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 変換 \/ SA0134：明示的な符号付き\/符号なし変換 ", 
"snippet" : "明示的に実行された、符号付きデータ型から符号なしデータ型への変換、およびその逆の変換を検出します。 正当性: 型変換を過度に使用すると、変数に対して間違ったデータ型が選択された可能性があります。このため、データ型変換の明示的な理由を要求するプログラミング ガイドラインがあります。 重要度：低 例 PROGRAM PLC_PRG VAR byVar :BYTE; udiVar : UDINT; uliVar : ULINT; lwVar : LWORD; wVar : WORD; siVar : SINT; iVar : INT; diVar : DINT; liVar : LINT; END_...", 
"body" : "明示的に実行された、符号付きデータ型から符号なしデータ型への変換、およびその逆の変換を検出します。 正当性: 型変換を過度に使用すると、変数に対して間違ったデータ型が選択された可能性があります。このため、データ型変換の明示的な理由を要求するプログラミング ガイドラインがあります。 重要度：低 例 PROGRAM PLC_PRG\nVAR\n byVar :BYTE;\n udiVar : UDINT;\n uliVar : ULINT;\n lwVar : LWORD;\n wVar : WORD;\n siVar : SINT;\n iVar : INT;\n diVar : DINT;\n liVar : LINT;\nEND_VAR\n liVar := ULINT_TO_LINT(uliVar);\nudiVar := DINT_TO_UDINT(diVar);\nsiVar := BYTE_TO_SINT(byVar);\nwVar := INT_TO_WORD(iVar);\nlwVar := SINT_TO_LWORD(siVar); での出力 メッセージ ビュー： SA0134: 'ULINT' 型から 'LINT' 型への明示的な符号付き\/符号なし変換 SA0134: 'DINT' 型から 'UDINT' 型への明示的な符号付き\/符号なし変換 SA0134: 'BYTE' 型から 'SINT' 型への明示的な符号付き\/符号なし変換 SA0134: 'INT' 型から 'WORD' 型への明示的な符号付き\/符号なし変換 SA0134: 'SINT' 型から 'LWORD' 型への明示的な符号付き\/符号なし変換 " }, 
{ "title" : "直接アドレスの使用 ", 
"url" : "_san_use_direct_adresses.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 直接アドレスの使用 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0005：無効なアドレスとデータ型 ", 
"url" : "_san_rule_sa0005.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 直接アドレスの使用 \/ SA0005：無効なアドレスとデータ型 ", 
"snippet" : "無効なアドレスとデータ型の指定を検出します。アドレス内の有効なサイズプレフィックス：X for BOOL 、Bは1バイトのデータ型、Wは2バイトのデータ型、Dは4バイトのデータ型です。 理由：直接アドレスにある変数は、データ型の範囲に対応するアドレスに関連付ける必要があります。たとえば、次の場合、コードの読者を混乱させる可能性があります。 DWORD に BYTE アドレスが設定されます。 重要度：低 例 PROGRAM Check_Address_Type_PRG VAR iVar AT %QB0 : INT ; \/\/ OK e. g.: %QW0 xTest AT %QW1 : BOOL ...", 
"body" : "無効なアドレスとデータ型の指定を検出します。アドレス内の有効なサイズプレフィックス：X for BOOL 、Bは1バイトのデータ型、Wは2バイトのデータ型、Dは4バイトのデータ型です。 理由：直接アドレスにある変数は、データ型の範囲に対応するアドレスに関連付ける必要があります。たとえば、次の場合、コードの読者を混乱させる可能性があります。 DWORD に BYTE アドレスが設定されます。 重要度：低 例 PROGRAM Check_Address_Type_PRG\nVAR\n iVar AT %QB0 : INT ; \/\/ OK e. g.: %QW0\n xTest AT %QW1 : BOOL ; \/\/ OK e. g.: %QX1.0\nEND_VAR iVar := iVar + INT#1;\nxTest := NOT xTest;\n での出力 メッセージ ビュー： SA0005: データ型「iVar」のアドレスが無効です 詳細については、以下を参照してください。 静的コード分析を構成して実行する " }, 
{ "title" : "SA0047：直接アドレスへのアクセス ", 
"url" : "_san_rule_sa0047.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 直接アドレスの使用 \/ SA0047：直接アドレスへのアクセス ", 
"snippet" : "実装コードでの直接アドレスアクセスを決定します。 理由：シンボリックプログラミングが常に望ましい：変数には意味を持つこともできる名前があります。アドレスが何に使用されているかはわかりません。 重要性：高い PLCopenルール：N1 \/ CP1 例 PROGRAM PLC_PRG VAR xVar : BOOL; byVar : BYTE; END_VAR xVar := %IX0.0; %QX0.0 := xVar; %MX0.1 := xVar; %MB1 := byVar; での出力 メッセージ ビュー： SA0047: 直接アドレス '%IX0.0' へのアクセス SA0026: 直接...", 
"body" : "実装コードでの直接アドレスアクセスを決定します。 理由：シンボリックプログラミングが常に望ましい：変数には意味を持つこともできる名前があります。アドレスが何に使用されているかはわかりません。 重要性：高い PLCopenルール：N1 \/ CP1 例 PROGRAM PLC_PRG\nVAR\n xVar : BOOL;\n byVar : BYTE;\nEND_VAR\n xVar := %IX0.0;\n%QX0.0 := xVar;\n%MX0.1 := xVar;\n%MB1 := byVar; での出力 メッセージ ビュー： SA0047: 直接アドレス '%IX0.0' へのアクセス SA0026: 直接アドレス '%QX0.0' へのアクセス SA0026: 直接アドレス '%MX0.1' へのアクセス SA0026: 直接アドレス '%MB1' へのアクセス " }, 
{ "title" : "SA0048：直接アドレスのAT宣言 ", 
"url" : "_san_rule_sa0048.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 直接アドレスの使用 \/ SA0048：直接アドレスのAT宣言 ", 
"snippet" : "決定 AT -直接アドレスに関する宣言。 コード内で直接アドレスを使用すると、アドレスが複数の場所に出現するため問題が発生します。 最初のコントローラー構成では、物理オブジェクトのアドレスへの割り当てが定義されます。 プログラムの 2 番目では、変数がこれらのアドレスに割り当てられます。 構成の変更によりアドレスが再配置された場合は、プログラム内のまったく別の場所にあるアドレスに変数を再割り当てする必要があります。これはエラーの原因となり、コードの可読性や保守性が低下します。したがって、デバイス エディタの I\/O マッピングですべての割り当てを実行することが最善です。 重要性：高い PLCo...", 
"body" : "決定 AT -直接アドレスに関する宣言。 コード内で直接アドレスを使用すると、アドレスが複数の場所に出現するため問題が発生します。 最初のコントローラー構成では、物理オブジェクトのアドレスへの割り当てが定義されます。 プログラムの 2 番目では、変数がこれらのアドレスに割り当てられます。 構成の変更によりアドレスが再配置された場合は、プログラム内のまったく別の場所にあるアドレスに変数を再割り当てする必要があります。これはエラーの原因となり、コードの可読性や保守性が低下します。したがって、デバイス エディタの I\/O マッピングですべての割り当てを実行することが最善です。 重要性：高い PLCopenルール：N1 \/ CP1 直接アドレスのみを使用することをお勧めします。 I\/Oマッピング デバイスエディターのタブ。 例 PROGRAM PLC_PRG\nVAR\n xVar1 AT %IX0.0 : BOOL;\n byVar1 AT %IB1 : BYTE;\n xVar2 AT %QX0.0 : BOOL;\nEND_VAR\n での出力 メッセージ ビュー： SA0048: 宣言では直接アドレス '%IX0.0' が使用されています SA0048: 宣言は直接アドレス '%IB1' を使用しています SA0048: 宣言では直接アドレス '%QX0.0' が使用されています " }, 
{ "title" : "オペレーターのためのルール ", 
"url" : "_san_rule_operators.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ オペレーターのためのルール ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0051：BOOL変数の比較演算 ", 
"url" : "_san_rule_sa0051.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ オペレーターのためのルール \/ SA0051：BOOL変数の比較演算 ", 
"snippet" : "タイプの変数の比較演算を決定します BOOL 。 理由: CODESYS このような種類の比較が可能になります。しかし、それらは非常に珍しいため、混乱を招く可能性があります。 IEC 61131-3 規格では、これらの比較は規定されていません。これらを回避すると、他の開発システムへのコードの移植性が高まります。 重要性：中 例 PROGRAM PLC_PRG VAR xBool1, xBool2 : BOOL; xResult : BOOL; END_VAR xResult := xBool1 > xBool2; \/\/ SA0051 xBool1 := NOT xBool1; \/\/ OK! x...", 
"body" : "タイプの変数の比較演算を決定します BOOL 。 理由: CODESYS このような種類の比較が可能になります。しかし、それらは非常に珍しいため、混乱を招く可能性があります。 IEC 61131-3 規格では、これらの比較は規定されていません。これらを回避すると、他の開発システムへのコードの移植性が高まります。 重要性：中 例 PROGRAM PLC_PRG\nVAR\n xBool1, xBool2 : BOOL;\n xResult : BOOL;\nEND_VAR\n xResult := xBool1 > xBool2; \/\/ SA0051\nxBool1 := NOT xBool1; \/\/ OK!\nxBool2 := xBool2 XOR xBool1; \/\/ OK! での出力 メッセージ ビュー： SA0051: BOOL 変数の比較演算 " }, 
{ "title" : "SA0052：異常なシフト操作 ", 
"url" : "_san_rule_sa0052.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ オペレーターのためのルール \/ SA0052：異常なシフト操作 ", 
"snippet" : "符号付き変数のシフト演算（ビットシフト）を決定します。ビットフィールドデータ型のシフト操作の場合（ Byte 、 DWORD 、 LWORD 、 WORD ）エラーは出力されません。 理由： CODESYS 署名されたデータ型のシフト操作を許可します。ただし、これらの操作は一般的ではなく、混乱を招く可能性があります。 IEC-61131-3規格はそのような操作を規定しておらず、他の開発システムへのコードの移植性を高めるためにそれらを避ける必要があります。 重要性：中 例 PROGRAM PLC_PRG VAR iTemp : INT; dwTemp1 : DWORD; byTemp2 : BY...", 
"body" : "符号付き変数のシフト演算（ビットシフト）を決定します。ビットフィールドデータ型のシフト操作の場合（ Byte 、 DWORD 、 LWORD 、 WORD ）エラーは出力されません。 理由： CODESYS 署名されたデータ型のシフト操作を許可します。ただし、これらの操作は一般的ではなく、混乱を招く可能性があります。 IEC-61131-3規格はそのような操作を規定しておらず、他の開発システムへのコードの移植性を高めるためにそれらを避ける必要があります。 重要性：中 例 PROGRAM PLC_PRG\nVAR\n iTemp : INT;\n dwTemp1 : DWORD;\n byTemp2 : BYTE;\n diTemp3 : DINT;\n siTemp4 : SINT;\n liTemp5 : LINT;\nEND_VAR\n \/\/the following lines each will cause an SA0052:\niTemp := SHL(iTemp, BYTE#2);\ndiTemp3 := SHR(diTemp3, BYTE#4);\nsiTemp4 := ROL(siTemp4, BYTE#2);\nliTemp5 := ROR(liTemp5, BYTE#2);\n\n\/\/no error SA0052 because DWORD and BYTE are bitfield datatypes:\ndwTemp1 := SHL(dwTemp1, BYTE#3);\nbyTemp2 := SHR(byTemp2, BYTE#1); での出力 メッセージ ビュー： SA0052: 異常なシフト操作 " }, 
{ "title" : "SA0053：ビット単位のシフトが大きすぎます ", 
"url" : "_san_rule_sa0053.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ オペレーターのためのルール \/ SA0053：ビット単位のシフトが大きすぎます ", 
"snippet" : "オペランドのビット単位シフト（ビットシフト）を行う場合、オペランドのデータ型幅を超えていないか判断します。 理由：移動操作がデータ型の幅を超えると、定数が作成されます 0 。 回転シフトがデータ型の幅を超えている場合、読み取りが困難であるため、回転値を切り捨てる必要があります。 重要性：高い 例 PROGRAM PLC_PRG VAR byTemp1 : BYTE; wTemp2 : WORD; dwTemp3 : DWORD; lwTemp4 : LWORD; END_VAR byTemp1 := SHR(byTemp1, BYTE#25); wTemp2 := SHL(wTemp2, BY...", 
"body" : "オペランドのビット単位シフト（ビットシフト）を行う場合、オペランドのデータ型幅を超えていないか判断します。 理由：移動操作がデータ型の幅を超えると、定数が作成されます 0 。 回転シフトがデータ型の幅を超えている場合、読み取りが困難であるため、回転値を切り捨てる必要があります。 重要性：高い 例 PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\n wTemp2 : WORD;\n dwTemp3 : DWORD;\n lwTemp4 : LWORD;\nEND_VAR\n byTemp1 := SHR(byTemp1, BYTE#25);\nwTemp2 := SHL(wTemp2, BYTE#45);\ndwTemp3 := ROR(dwTemp3, BYTE#78);\nlwTemp4 := ROL(lwTemp4, BYTE#111); での出力 メッセージ ビュー： SA0053: ビット単位のシフトが大きすぎます " }, 
{ "title" : "SA0054：REAL \/ LREALを比較して等式\/不等式 ", 
"url" : "_san_rule_sa0054.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ オペレーターのためのルール \/ SA0054：REAL \/ LREALを比較して等式\/不等式 ", 
"snippet" : "比較演算子かどうかを決定します = （平等）と <> （不等式）タイプのオペランド REAL また LREAL 比べる。 理由: REAL \/ LREAL 値は、IEEE 754 標準に従って浮動小数点数として実装されます。この標準は、特定の一見単純な 10 進数を正確に表現できないことを意味します。その結果、以下のように異なる表現が存在する可能性があります。 LREAL 同じ 10 進数の場合。 次のコード行を考えてみましょう。 lr11 := 1.1; lr33 := 3.3; lrVar1 := lr11 + lr11; lrVar2 := lr33 - lr11; botest := ...", 
"body" : "比較演算子かどうかを決定します = （平等）と <> （不等式）タイプのオペランド REAL また LREAL 比べる。 理由: REAL \/ LREAL 値は、IEEE 754 標準に従って浮動小数点数として実装されます。この標準は、特定の一見単純な 10 進数を正確に表現できないことを意味します。その結果、以下のように異なる表現が存在する可能性があります。 LREAL 同じ 10 進数の場合。 次のコード行を考えてみましょう。 lr11 := 1.1;\nlr33 := 3.3;\nlrVar1 := lr11 + lr11;\nlrVar2 := lr33 - lr11;\nbotest := lrVar1 = lrVar2; この場合、 botest 戻り値 FALSE たとえ変数が lrVar1 そして lrVar2 どちらも監視値「2.2」を返します。これはコンパイラのエラーではなく、すべての従来のプロセッサの浮動小数点ユニットの特性です。これを回避するには、値が異なる可能性がある最小値を指定します。 botest := ABS(lrVar1 - lrVar2) < 0.1; 例外: との比較 0.0 この分析では報告されていません。 0 については、IEEE 754 標準に正確な表現があるため、比較は通常、期待どおりに機能します。したがって、パフォーマンスを向上させるために、ここで直接比較を許可することは理にかなっています。 重要性：高い PLCopenルール：CP54 例 PROGRAM PLC_PRG\nVAR\n rTest1 : REAL;\n rTest2 : REAL;\n lrTest3 : LREAL;\n lrTest4 : LREAL;\n xResult : BOOL;\nEND_VAR \/\/the following lines each will cause an SA0054:\nxResult := rTest1 = rTest1;\nxResult := rTest1 = rTest2;\nxResult := rTest1 <> rTest2;\nxResult := lrTest3 = lrTest3;\nxResult := lrTest3 = lrTest4;\nxResult := lrTest3 <> lrTest4;\n\/\/the following lines each will not cause an SA0054:\nxResult := rTest1 > rTest2;\nxResult := lrTest3 < lrTest4;\n での出力 メッセージ ビュー： SA0054: REAL\/LREAL の等価\/不等価の比較 " }, 
{ "title" : "SA0055：符号なしオペランドの不要な比較演算 ", 
"url" : "_san_rule_sa0055.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ オペレーターのためのルール \/ SA0055：符号なしオペランドの不要な比較演算 ", 
"snippet" : "符号なしオペランドとの不要な比較を検出します。符号なしデータ型がゼロ未満になることはありません。これは、サインチェックとして使用できます。 理由：このチェックで検出された比較は一定の結果を返し、これはコードのエラーを示します。 重要性：高い 例 PROGRAM PLC_PRG VAR byTest: BYTE; END_VAR \/\/ SA0055 WHILE byTest >= 0 DO byTest := byTest - 1; END_WHILE での出力 メッセージ ビュー： SA0055: 符号なしオペランドの不必要な比較...", 
"body" : "符号なしオペランドとの不要な比較を検出します。符号なしデータ型がゼロ未満になることはありません。これは、サインチェックとして使用できます。 理由：このチェックで検出された比較は一定の結果を返し、これはコードのエラーを示します。 重要性：高い 例 PROGRAM PLC_PRG\nVAR\n byTest: BYTE;\nEND_VAR\n \/\/ SA0055\nWHILE byTest >= 0 DO\n byTest := byTest - 1;\nEND_WHILE での出力 メッセージ ビュー： SA0055: 符号なしオペランドの不必要な比較 " }, 
{ "title" : "SA0056：定数が範囲外 ", 
"url" : "_san_rule_sa0056.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ オペレーターのためのルール \/ SA0056：定数が範囲外 ", 
"snippet" : "演算子の範囲外のリテラル（定数）を検索します。 理由：このメッセージは、値がこの値の値の範囲外にある定数と比較された場合に発行されます。その後、比較は定数を返します TRUE また FALSE 。これはプログラミングエラーを示しています。 重要性：高い 例 PROGRAM PLC_PRG VAR byTestVar: BYTE; END_VAR WHILE byTestVar >= 260 DO byTestVar := byTestVar + 1; END_WHILE での出力 メッセージ ビュー： SA0056: 定数が有効範囲外です...", 
"body" : "演算子の範囲外のリテラル（定数）を検索します。 理由：このメッセージは、値がこの値の値の範囲外にある定数と比較された場合に発行されます。その後、比較は定数を返します TRUE また FALSE 。これはプログラミングエラーを示しています。 重要性：高い 例 PROGRAM PLC_PRG\nVAR\n byTestVar: BYTE;\nEND_VAR\n WHILE byTestVar >= 260 DO\n byTestVar := byTestVar + 1;\nEND_WHILE での出力 メッセージ ビュー： SA0056: 定数が有効範囲外です " }, 
{ "title" : "SA0057：小数点以下の桁数が失われる可能性 ", 
"url" : "_san_rule_sa0057.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ オペレーターのためのルール \/ SA0057：小数点以下の桁数が失われる可能性 ", 
"snippet" : "小数点以下の桁数が失われる可能性のある命令を決定します。 理由：次の種類のコードの一部： diTemp2 := 1 rTemp1 := TO_REAL(diTemp2 \/ DINT#2) 誤解を招く可能性があります。このコード行の作成者または読者は、分割が次のようになると想定する場合があります。 REAL -実行された操作と結果はこの場合になります REAL#0.5 であること。ただし、これは当てはまりません。演算は整数演算として実行され、結果は次のようになります。 REAL キャストと rTemp1 値を取得します REAL#0 。 これを回避するには、キャストを使用して操作が確実に実行され...", 
"body" : "小数点以下の桁数が失われる可能性のある命令を決定します。 理由：次の種類のコードの一部： diTemp2 := 1 rTemp1 := TO_REAL(diTemp2 \/ DINT#2) 誤解を招く可能性があります。このコード行の作成者または読者は、分割が次のようになると想定する場合があります。 REAL -実行された操作と結果はこの場合になります REAL#0.5 であること。ただし、これは当てはまりません。演算は整数演算として実行され、結果は次のようになります。 REAL キャストと rTemp1 値を取得します REAL#0 。 これを回避するには、キャストを使用して操作が確実に実行されるようにします。 REAL 手術： rTemp1 := TO_REAL(diTemp2) \/ REAL#2; 重要性：中 例 PROGRAM PLC_PRG\nVAR\n rTemp1 : REAL;\n diTemp2 : DINT;\n liTemp3 : LINT;\nEND_VAR diTemp2 := diTemp2 + DINT#11;\n\/\/ SA0057\nrTemp1 := DINT_TO_REAL(diTemp2 \/ DINT#3); \nrTemp1 := DINT_TO_REAL(diTemp2) \/ REAL#3.0;\nliTemp3 := liTemp3 + LINT#13;\n\/\/ SA0057\nrTemp1 := LINT_TO_REAL(liTemp3 \/ LINT#7);\nrTemp1 := LINT_TO_REAL(liTemp3) \/ REAL#7.0; での出力 メッセージ ビュー： SA0057: 小数点以下の桁が失われる可能性があります " }, 
{ "title" : "SA0058：列挙変数の操作 ", 
"url" : "_san_rule_sa0058.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ オペレーターのためのルール \/ SA0058：列挙変数の操作 ", 
"snippet" : "データ型列挙型の変数に対する操作を決定します。割り当てが許可されます。 理由: 列挙型は通常の整数値として使用すべきではありません。あるいは、エイリアス データ型を定義したり、サブレンジ型を使用したりすることもできます。 重要性：中 例外：属性を持つ列挙型の場合 {attribute 'strict'} がマークされている場合、コンパイラはすでにそのような操作を報告しています。 プラグマによる列挙の場合 {attribute 'flags'} フラグとして宣言されている AND -、 OR -、 NOT - また XOR -操作はエラーを返しませんでした。 例 TYPE My_Enum : (...", 
"body" : "データ型列挙型の変数に対する操作を決定します。割り当てが許可されます。 理由: 列挙型は通常の整数値として使用すべきではありません。あるいは、エイリアス データ型を定義したり、サブレンジ型を使用したりすることもできます。 重要性：中 例外：属性を持つ列挙型の場合 {attribute 'strict'} がマークされている場合、コンパイラはすでにそのような操作を報告しています。 プラグマによる列挙の場合 {attribute 'flags'} フラグとして宣言されている AND -、 OR -、 NOT - また XOR -操作はエラーを返しませんでした。 例 TYPE My_Enum :\n(\n red := 1, blue := 2, green := 3, black := 4\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n abc : My_Enum;\nEND_VAR iTemp1 := iTemp1 + INT#1;\nabc := My_Enum.red; \/\/ OK\niTemp1 := My_Enum.black \/ My_Enum.blue; \/\/ SA0058\niTemp1 := My_Enum.green \/ My_Enum.red; \/\/ SA0058\n での出力 メッセージ ビュー： SA0058: 列挙型変数の操作 プラグマ {attribute 'flags'} を使用した例 {attribute 'flags'} \/\/ declaring the enumeration as a \"flag\"\nTYPE Flags :\n(\n Unknown := 16#00000001,\n Stopped := 16#00000002,\n Running := 16#00000004\n) DWORD;\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n abc : Flags;\n batate : BYTE;\n dwFlags : DWORD;\n dwState : DWORD;\nEND_VAR \/\/ OK for the following\nIF (dwFlags AND Flags.Unknown) <> DWORD#0 THEN\n dwState := dwState AND Flags.Unknown;\n ELSIF (dwFlags OR Flags.Stopped) <> DWORD#0 THEN\n dwState := dwState OR Flags.Running;\nEND_IF " }, 
{ "title" : "SA0059：常にTRUEまたはFALSEを返す比較操作 ", 
"url" : "_san_rule_sa0059.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ オペレーターのためのルール \/ SA0059：常にTRUEまたはFALSEを返す比較操作 ", 
"snippet" : "結果が常に次になるリテラルとの比較を検出します。 TRUE または FALSE 、コンパイル時にすでに処理できます。 理論的根拠：一定の演算 TRUE また FALSE 戻り値はプログラミングエラーを示します。 重要性：高い 例 PROGRAM PLC_PRG VAR byTemp1 : BYTE; END_VAR WHILE byTemp1 <= 255 DO byTemp1 := byTemp1 + 1; END_WHILE での出力 メッセージ ビュー： SA0059: 関係演算子「<=」は常に「TRUE」と評価されます...", 
"body" : "結果が常に次になるリテラルとの比較を検出します。 TRUE または FALSE 、コンパイル時にすでに処理できます。 理論的根拠：一定の演算 TRUE また FALSE 戻り値はプログラミングエラーを示します。 重要性：高い 例 PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\nEND_VAR\n WHILE byTemp1 <= 255 DO\n byTemp1 := byTemp1 + 1;\nEND_WHILE での出力 メッセージ ビュー： SA0059: 関係演算子「<=」は常に「TRUE」と評価されます\n " }, 
{ "title" : "SA0060：無効なオペランドとしてNull ", 
"url" : "_san_rule_sa0060.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ オペレーターのためのルール \/ SA0060：無効なオペランドとしてNull ", 
"snippet" : "オペランドに値が含まれる操作を検出します。 0 無効または無意味な操作を引き起こす 理由：このような式は、プログラミングエラーを示している可能性があります。いずれにせよ、それは不必要に実行時間を要します。 重要性：中 例 PROGRAM PLC_PRG VAR byTemp1 : BYTE; wTemp2 : WORD; dwTemp3 : DWORD; END_VAR byTemp1 := byTemp1 + 0; wTemp2 := wTemp2 - WORD#0; dwTemp3 := dwTemp3 * DWORD#0; での出力 メッセージ ビュー： SA0060: 無効なオペランド...", 
"body" : "オペランドに値が含まれる操作を検出します。 0 無効または無意味な操作を引き起こす 理由：このような式は、プログラミングエラーを示している可能性があります。いずれにせよ、それは不必要に実行時間を要します。 重要性：中 例 PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\n wTemp2 : WORD;\n dwTemp3 : DWORD;\nEND_VAR\n byTemp1 := byTemp1 + 0;\nwTemp2 := wTemp2 - WORD#0;\ndwTemp3 := dwTemp3 * DWORD#0; での出力 メッセージ ビュー： SA0060: 無効なオペランドとしてゼロが使用されました " }, 
{ "title" : "SA0061：ポインタの異常な操作 ", 
"url" : "_san_rule_sa0061.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ オペレーターのためのルール \/ SA0061：ポインタの異常な操作 ", 
"snippet" : "タイプの変数に対する操作を決定します POINTER TO それはしません = （平等）、 <> （不平等）、 + （追加）または ADR それは。 の CODESYS ポインタ演算は一般的に許可されており、賢明に使用することもできます。したがって、整数値を持つポインターの追加は、ポインターに対する通常の操作として分類されます。これにより、ポインタを使用して可変長の配列を処理できます。ポインタを使用する他のすべての（異常な）操作は、SA0061で報告されます。 重要性：高い PLCopenルール：E2 \/ E3 例 PROGRAM PLC_PRG VAR piTemp : POINTER TO...", 
"body" : "タイプの変数に対する操作を決定します POINTER TO それはしません = （平等）、 <> （不平等）、 + （追加）または ADR それは。 の CODESYS ポインタ演算は一般的に許可されており、賢明に使用することもできます。したがって、整数値を持つポインターの追加は、ポインターに対する通常の操作として分類されます。これにより、ポインタを使用して可変長の配列を処理できます。ポインタを使用する他のすべての（異常な）操作は、SA0061で報告されます。 重要性：高い PLCopenルール：E2 \/ E3 例 PROGRAM PLC_PRG\nVAR\n piTemp : POINTER TO INT;\n iTemp : INT;\nEND_VAR\n iTemp := iTemp + INT#1;\npiTemp := ADR(iTemp);\npiTemp := piTemp * DWORD#5; \/\/ SA0061\npiTemp := piTemp \/ DWORD#2; \/\/ SA0061\npiTemp := piTemp MOD DWORD#3; \/\/ SA0061\npiTemp := piTemp + DWORD#1;\npiTemp := piTemp - DWORD#1; \/\/ SA0061 での出力 メッセージ ビュー： SA0061: ポインタに対する異常な操作 " }, 
{ "title" : "SA0062: エクスプレッションは定数です ", 
"url" : "_san_rule_sa0062.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ オペレーターのためのルール \/ SA0062: エクスプレッションは定数です ", 
"snippet" : "実行時に常に同じ値を持つ式の使用を検出します。 理由:複雑な式が繰り返し計算され、常に同じ値が生成される場合は、エラーを示している可能性があります。これは特に何か別の意図があった場合に当てはまります。いずれの場合も、この表現はプログラムの実行時に不必要に負担をかけます 重要性：中 例 PROGRAM PLC_PRG VAR value : INT; condition : BOOL; END_VAR value := 8; condition := value = 8 \/\/ Reports: Expression (value=8) is always TRUE での出力 メッセージ ビュー:...", 
"body" : "実行時に常に同じ値を持つ式の使用を検出します。 理由:複雑な式が繰り返し計算され、常に同じ値が生成される場合は、エラーを示している可能性があります。これは特に何か別の意図があった場合に当てはまります。いずれの場合も、この表現はプログラムの実行時に不必要に負担をかけます 重要性：中 例 PROGRAM PLC_PRG\nVAR\n value : INT;\n condition : BOOL;\nEND_VAR\n value := 8;\ncondition := value = 8 \/\/ Reports: Expression (value=8) is always TRUE での出力 メッセージ ビュー: SA0062: 式 '(値 = 8)' は常に真です " }, 
{ "title" : "SA0063：おそらく16ビット互換ではない操作 ", 
"url" : "_san_rule_sa0063.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ オペレーターのためのルール \/ SA0063：おそらく16ビット互換ではない操作 ", 
"snippet" : "中間結果で16ビット演算を決定します。背景：32ビットの中間結果は、16ビットシステムでは切り捨てることができます。例： (int+10) 16ビットを超えることができます。 理由：このメッセージは、16ビットプロセッサと32ビットプロセッサの両方で実行する必要があるコードを記述しなければならないという非常にまれなケースでの問題から保護することを目的としています。 重要度：低 例 PROGRAM PLC_PRG VAR iVar : INT; END_VAR iVar := (iVar + 10) \/ 2; での出力 メッセージ ビュー： SA0063: 16 ビットの互換性 – 中間結果が切...", 
"body" : "中間結果で16ビット演算を決定します。背景：32ビットの中間結果は、16ビットシステムでは切り捨てることができます。例： (int+10) 16ビットを超えることができます。 理由：このメッセージは、16ビットプロセッサと32ビットプロセッサの両方で実行する必要があるコードを記述しなければならないという非常にまれなケースでの問題から保護することを目的としています。 重要度：低 例 PROGRAM PLC_PRG\nVAR\n iVar : INT;\nEND_VAR\n iVar := (iVar + 10) \/ 2; での出力 メッセージ ビュー： SA0063: 16 ビットの互換性 – 中間結果が切り捨てられる可能性があります " }, 
{ "title" : "SA0064：ポインタの追加 ", 
"url" : "_san_rule_sa0064.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ オペレーターのためのルール \/ SA0064：ポインタの追加 ", 
"snippet" : "ポインタの追加を決定します。 位置揃え: で CODESYS 、ポインター演算は一般に許可されており、適切に使用することもできます。ただし、これはエラーの原因でもあります。したがって、一般にポインター演算を禁止するプログラミング規則が存在します。このテストでは、そのような要件を確認できます。 重要性：中 例 PROGRAM PLC_PRG VAR iTest : INT; ariTest : ARRAY[0..10] OF INT; {attribute 'analysis':='-111'} piTest : POINTER TO INT; i : INT; END_VAR piTest :...", 
"body" : "ポインタの追加を決定します。 位置揃え: で CODESYS 、ポインター演算は一般に許可されており、適切に使用することもできます。ただし、これはエラーの原因でもあります。したがって、一般にポインター演算を禁止するプログラミング規則が存在します。このテストでは、そのような要件を確認できます。 重要性：中 例 PROGRAM PLC_PRG\nVAR\n iTest : INT;\n ariTest : ARRAY[0..10] OF INT;\n {attribute 'analysis':='-111'}\n piTest : POINTER TO INT;\n i : INT;\nEND_VAR\n piTest := ADR(ariTest[0]); \/\/ OK\npiTest^ := 0;\npiTest := ADR(ariTest) + SIZEOF(INT); \/\/ SA0064\npiTest^ := 1;\npiTest := ADR(ariTest) + 6; \/\/ SA0064\npiTest^ := 3;\npiTest := ADR(ariTest[10]);\nFOR i:=0 TO 10 DO\n piTest^ := i;\n piTest := piTest + 2; \/\/ SA0064\nEND_FOR での出力 メッセージ ビュー： SA0064: ポインタの追加 " }, 
{ "title" : "SA0065：ポインタの追加がベースサイズと一致しません ", 
"url" : "_san_rule_sa0065.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ オペレーターのためのルール \/ SA0065：ポインタの追加がベースサイズと一致しません ", 
"snippet" : "追加される値がポインターの基本サイズと一致しないポインターの追加を検出します。基本データ サイズとその倍数のリテラルのみをエラーなく追加できます。 位置揃え: で CODESYS (C および C++ とは対照的に) 整数値を持つポインターを追加する場合、整数値に基本サイズを乗算したものではなく、この整数値のみがバイト数として追加されます。 STの例 pINT := ADR(array_of_int[0]); pINT := pINT + 2; \/\/in CODESYS, pINT then points to array_of_int[1] このコードは、Cでは異なる動作をします。 shor...", 
"body" : "追加される値がポインターの基本サイズと一致しないポインターの追加を検出します。基本データ サイズとその倍数のリテラルのみをエラーなく追加できます。 位置揃え: で CODESYS (C および C++ とは対照的に) 整数値を持つポインターを追加する場合、整数値に基本サイズを乗算したものではなく、この整数値のみがバイト数として追加されます。 STの例 pINT := ADR(array_of_int[0]);\npINT := pINT + 2; \/\/in CODESYS, pINT then points to array_of_int[1] このコードは、Cでは異なる動作をします。 short* pShort\npShort = &(array_of_short[0])\npShort = pShort + 2; \/\/in C, pShort then points to array_of_short[2] したがって、 CODESYS の場合は、常にポインターの基本サイズの倍数をポインターに加算する必要があります。それ以外の場合、ポインタは次を指す可能性があります。 揃っていない (プロセッサによっては) アクセス時にアライメント例外が発生する可能性があるメモリ。 重要性：高い 例 VAR\n pudiTest:POINTER TO UDINT;\n udiTest:UDINT;\n prTest:POINTER TO REAL;\n rTest:REAL;\nEND_VAR pudiTest := ADR(udiTest) + 4; \/\/ OK\npudiTest := ADR(udiTest) + ( 2 + 2 ); \/\/ OK\npudiTest := ADR(udiTest) + SIZEOF(UDINT); \/\/ OK\npudiTest := ADR(udiTest) + 3; \/\/ SA0065\npudiTest := ADR(udiTest) + 2*SIZEOF(UDINT); \/\/ OK\npudiTest := ADR(udiTest) + ( 3 + 2 ); \/\/ SA0065\nprTest := ADR(rTest);\nprTest := prTest + 4; \/\/ OK\nprTest := prTest + ( 2 + 2 ); \/\/ OK\nprTest := prTest + SIZEOF(REAL); \/\/ OK\nprTest := prTest + 1; \/\/ SA0065\nprTest := prTest + 2; \/\/ SA0065\nprTest := prTest + 3; \/\/ SA0065\nprTest := prTest + ( SIZEOF(REAL) - 1 ); \/\/ SA0065\nprTest := prTest + ( 1 + 4 ); \/\/ SA0065\n での出力 メッセージ ビュー： SA0065: 基本サイズへのポインタの追加が正しくありません " }, 
{ "title" : "SA0066：中間結果の使用 ", 
"url" : "_san_rule_sa0066.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ オペレーターのためのルール \/ SA0066：中間結果の使用 ", 
"snippet" : "レジスタ サイズより小さいデータ型を持つステートメントでの一時結果の使用を検出します。この場合、暗黙的なキャストによって望ましくない結果が生じる可能性があります。 正当な理由: パフォーマンス上の理由から、 CODESYS Static Analysis プロセッサのレジスタ幅に対して演算を実行します。中間結果は切り捨てられません。これは、次のような誤解を招く可能性があります。 例 usintTest := 0; xError := usintTest - 1 <> 255; で CODESYS 、 xError は TRUE この場合、操作が usintTest - 1 通常、32 ビット操...", 
"body" : "レジスタ サイズより小さいデータ型を持つステートメントでの一時結果の使用を検出します。この場合、暗黙的なキャストによって望ましくない結果が生じる可能性があります。 正当な理由: パフォーマンス上の理由から、 CODESYS Static Analysis プロセッサのレジスタ幅に対して演算を実行します。中間結果は切り捨てられません。これは、次のような誤解を招く可能性があります。 例 usintTest := 0; xError := usintTest - 1 <> 255; で CODESYS 、 xError は TRUE この場合、操作が usintTest - 1 通常、32 ビット操作として実行され、結果はバイト サイズにキャストされません。次に、値 16#ffffffff (255 に等しくない) がレジスタ内にあります。 これを回避するには、中間結果を明示的にキャストする必要があります。 xError := TO_USINT(usintTest - 1) <> 255; この通知がアクティブ化されると、コード内のかなり問題のない場所が多数報告されます。問題が発生するのは、操作によってデータ型にオーバーフローまたはアンダーフローが発生した場合のみですが、静的分析では個々の位置を区別できません。 報告されたすべての場所に明示的な型キャストをインストールすると、コードが大幅に遅くなり、読みにくくなります。 重要度：低 例 PROGRAM PLC_PRG\nVAR\n byTest:BYTE;\n liTest:LINT;\n xError:BOOL;\nEND_VAR \/\/type size smaller than register size;\nbyTest := 0;\nIF (byTest - 1) <> 255 THEN \/\/use of temporary result + implicit casting -> SA0066\n xError := TRUE;\nELSE\n xError := FALSE;\nEND_IF\n\n\/\/type size equal to or bigger than register size;\nliTest := 0;\nIF (liTest - 1) <> -1 THEN \/\/ use of temporary result and no implicit casting -> OK\n xError := TRUE;\nELSE\n xError := FALSE;\nEND_IF\n での出力 メッセージ ビュー： SA0066: 一時結果の使用 (byTest - USINT #1) " }, 
{ "title" : "指示の規則 ", 
"url" : "_san_rule_instructions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 指示の規則 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0072：カウンタ変数の使用が無効です ", 
"url" : "_san_rule_sa0072.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 指示の規則 \/ SA0072：カウンタ変数の使用が無効です ", 
"snippet" : "内のカウンター変数の使用を決定します FOR -リボン。 理由: でのカウンタ変数の操作 FOR ループすると簡単に無限ループが発生する可能性があります。カウンタ変数の特定の値に対するループの実行を防ぐには、次を使用します。 CONTINUE または単に IF 。 重要性：高い PLCopenルール：L12 例 PROGRAM PLC_PRG VAR_TEMP iIndex : INT; END_VAR FOR iIndex := INT#0 TO INT#20 BY INT#1 DO iIndex := iIndex - INT#1; END_FOR での出力 メッセージ ビュー： SA00...", 
"body" : "内のカウンター変数の使用を決定します FOR -リボン。 理由: でのカウンタ変数の操作 FOR ループすると簡単に無限ループが発生する可能性があります。カウンタ変数の特定の値に対するループの実行を防ぐには、次を使用します。 CONTINUE または単に IF 。 重要性：高い PLCopenルール：L12 例 PROGRAM PLC_PRG\nVAR_TEMP\n iIndex : INT;\nEND_VAR FOR iIndex := INT#0 TO INT#20 BY INT#1 DO\n iIndex := iIndex - INT#1;\nEND_FOR での出力 メッセージ ビュー： SA0072: カウンタ変数 'iIndex' の無効な使用 " }, 
{ "title" : "SA0073：非一時的なカウンター変数の使用 ", 
"url" : "_san_rule_sa0073.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 指示の規則 \/ SA0073：非一時的なカウンター変数の使用 ", 
"snippet" : "の非一時変数の使用を検出します FOR -グラインド。 理由：これはパフォーマンスの警告です。カウンタ変数は、プログラミングブロックが呼び出されるたびに常に初期化されます。このような変数を一時変数として使用できます（ VAR_TEMP ）、アクセスが高速になる可能性があり、変数は永続的なメモリスペースを占有しません。 重要性：中 PLCopenルール：CP21 \/ L13 例 PROGRAM PLC_PRG VAR nIndex : INT; iVar : INT; END_VAR FOR nIndex := INT#0 TO INT#20 BY INT#1 DO iVar := iVar +...", 
"body" : "の非一時変数の使用を検出します FOR -グラインド。 理由：これはパフォーマンスの警告です。カウンタ変数は、プログラミングブロックが呼び出されるたびに常に初期化されます。このような変数を一時変数として使用できます（ VAR_TEMP ）、アクセスが高速になる可能性があり、変数は永続的なメモリスペースを占有しません。 重要性：中 PLCopenルール：CP21 \/ L13 例 PROGRAM PLC_PRG\nVAR\n nIndex : INT;\n iVar : INT;\nEND_VAR FOR nIndex := INT#0 TO INT#20 BY INT#1 DO\n iVar := iVar + nIndex;\nEND_FOR\n ビュー内の出力 メッセージ : SA0073: カウンタ変数が一致しません " }, 
{ "title" : "SA0075：ELSEがありません ", 
"url" : "_san_rule_sa0075.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 指示の規則 \/ SA0075：ELSEがありません ", 
"snippet" : "決定 CASE -なしの指示 ELSE -ブランチ。 理論的根拠：防御的なプログラミングには、 ELSE それぞれに CASE -命令。もし私が ELSE -何もすることがない場合は、コメントでマークする必要があります。そうすれば、コードの読者には、事件が単に忘れられたのではないことが明らかになります。 重要度：低 PLCopenルール：L17 For CASE 属性付きの列挙を使用するステートメント strict  すべての列挙定数が CASE ステートメントが使用されている場合、エラー メッセージは発行されません。 例 PROGRAM PLC_PRG VAR iVar : INT; xTe...", 
"body" : "決定 CASE -なしの指示 ELSE -ブランチ。 理論的根拠：防御的なプログラミングには、 ELSE それぞれに CASE -命令。もし私が ELSE -何もすることがない場合は、コメントでマークする必要があります。そうすれば、コードの読者には、事件が単に忘れられたのではないことが明らかになります。 重要度：低 PLCopenルール：L17 For CASE 属性付きの列挙を使用するステートメント strict  すべての列挙定数が CASE ステートメントが使用されている場合、エラー メッセージは発行されません。 例 PROGRAM PLC_PRG\nVAR\n iVar : INT;\n xTemp : BOOL;\nEND_VAR iVar := iVar + INT#1;\nCASE iVar OF\n INT#1:\n xTemp := FALSE;\n INT#2:\n xTemp := TRUE;\nEND_CASE\n での出力 メッセージ ビュー： SA0075: CASE ステートメントに ELSE がありません " }, 
{ "title" : "SA0076：列挙定数がありません ", 
"url" : "_san_rule_sa0076.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 指示の規則 \/ SA0076：列挙定数がありません ", 
"snippet" : "各列挙定数が条件として使用されるかどうかを決定します。 CASE ステートメントとクエリ CASE 支店。 理論的根拠：防御プログラミングでは、列挙型のすべての可能な値を処理する必要があります。特定の列挙値にアクションが必要ない場合は、コメントで明示的にマークする必要があります。そうすれば、コードの読者には、値が単に忘れられたのではないことが明らかになります。 重要度：低 例 TYPE My_Enum : ( red := 1, blue := 2, green := 3, black := 4 ); END_TYPE PROGRAM PLC_PRG VAR iVar : My_Enum; x...", 
"body" : "各列挙定数が条件として使用されるかどうかを決定します。 CASE ステートメントとクエリ CASE 支店。 理論的根拠：防御プログラミングでは、列挙型のすべての可能な値を処理する必要があります。特定の列挙値にアクションが必要ない場合は、コメントで明示的にマークする必要があります。そうすれば、コードの読者には、値が単に忘れられたのではないことが明らかになります。 重要度：低 例 TYPE My_Enum :\n(\n red := 1, blue := 2, green := 3, black := 4\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iVar : My_Enum;\n xTemp : BOOL;\nEND_VAR iVar := My_Enum.black;\nCASE iVar OF\n My_Enum.red:\n xTemp := FALSE;\n My_Enum.blue, My_Enum.green:\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n での出力 メッセージ ビュー： SA0076: CASE ステートメントに列挙定数 'black' がありません " }, 
{ "title" : "SA0077: 列挙型が一致しません CASE 表現 ", 
"url" : "_san_rule_sa0077.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 指示の規則 \/ SA0077: 列挙型が一致しません CASE 表現 ", 
"snippet" : "aが当てはまるコード位置を検出します CASE ステートメントは列挙値と非列挙型を混在させます。 理由:CASE 構文に列挙値と整数値を混在させると、データ型の安全性が損なわれ、コードの可読性が低下し、保守性に影響します。列挙値によって意味が明確になります。未処理の整数値を使用すると、軽微なエラーが発生するリスクがあり、コードが理解しにくくなります。列挙のデータ型が変更されると、整数ベースの分岐が壊れてしまい、見過ごされてしまうこともあります 重要度：低 例 {attribute 'qualified_only'} {attribute 'strict'} TYPE DUT_MyEnum : ...", 
"body" : "aが当てはまるコード位置を検出します CASE ステートメントは列挙値と非列挙型を混在させます。 理由:CASE 構文に列挙値と整数値を混在させると、データ型の安全性が損なわれ、コードの可読性が低下し、保守性に影響します。列挙値によって意味が明確になります。未処理の整数値を使用すると、軽微なエラーが発生するリスクがあり、コードが理解しにくくなります。列挙のデータ型が変更されると、整数ベースの分岐が壊れてしまい、見過ごされてしまうこともあります 重要度：低 例 {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE DUT_MyEnum :\n(\n\tOne := 1, \n\tTwo := 2, \n\tThree := 3, \n\tFour := 4\n);\nEND_TYPE PROGRAM PRG_Case\nVAR\ndiVar : DINT;\nxTemp : BOOL;\n\neMyEnum : DUT_MyEnum;\nEND_VAR\n CASE diVar OF\n 1 :\n xTemp := FALSE;\n DUT_MyEnum.Two : \/\/ SA0077\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n\nCASE eMyEnum OF\n 1 : \/\/ SA0077\n xTemp := FALSE;\n DUT_MyEnum.Two:\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE での出力 メッセージ ビュー： SA0077: CASE 式と型が一致しません " }, 
{ "title" : "SA0078：CASEブランチのないCASEステートメント ", 
"url" : "_san_rule_sa0078.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 指示の規則 \/ SA0078：CASEブランチのないCASEステートメント ", 
"snippet" : "決定 CASE -なしの指示 CASE -ブランチと1つだけ ELSE -命令。 理由: A CASE ケースのないステートメントは実行時間が無駄になり、読みにくくなります。 重要性：中 例 PROGRAM PLC_PRG VAR iVar : INT; xTemp : BOOL; END_VAR iVar := iVar + INT#1; \/\/in the following the case descriptions are missing: CASE iVar OF ELSE xTemp := NOT xTemp; END_CASE での出力 メッセージ ビュー： SA0078: CAS...", 
"body" : "決定 CASE -なしの指示 CASE -ブランチと1つだけ ELSE -命令。 理由: A CASE ケースのないステートメントは実行時間が無駄になり、読みにくくなります。 重要性：中 例 PROGRAM PLC_PRG\nVAR\n iVar : INT;\n xTemp : BOOL;\nEND_VAR iVar := iVar + INT#1;\n\/\/in the following the case descriptions are missing:\nCASE iVar OF\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n での出力 メッセージ ビュー： SA0078: CASE ブランチが欠落しています " }, 
{ "title" : "SA0081：上限は定数値ではありません ", 
"url" : "_san_rule_sa0081.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 指示の規則 \/ SA0081：上限は定数値ではありません ", 
"snippet" : "を検出します FOR 上限が定数値で定義されていないステートメント 理由：ループの上限が可変値である場合、ループが実行される頻度を確認することはできなくなります。これにより、実行時に深刻な問題が発生する可能性があり、最悪の場合、無限ループが発生する可能性があります。 重要性：高い 例 PROGRAM PLC_PRG VAR i:INT; iBorder1: INT := 10; iBorder2: INT := 10; iCounter: INT; END_VAR VAR CONSTANT ciBorder:INT := 10; END_VAR FOR i:=0 TO 10 DO \/\/OK i...", 
"body" : "を検出します FOR 上限が定数値で定義されていないステートメント 理由：ループの上限が可変値である場合、ループが実行される頻度を確認することはできなくなります。これにより、実行時に深刻な問題が発生する可能性があり、最悪の場合、無限ループが発生する可能性があります。 重要性：高い 例 PROGRAM PLC_PRG\nVAR\n i:INT;\n iBorder1: INT := 10;\n iBorder2: INT := 10;\n iCounter: INT;\nEND_VAR\nVAR CONSTANT\n ciBorder:INT := 10;\nEND_VAR\n FOR i:=0 TO 10 DO \/\/OK\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO ciBorder DO \/\/ OK\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO iBorder1 DO \/\/ SA0081\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO iBorder2 DO \/\/ SA0081\n iCounter := i;\n IF iCounter = 10 THEN\n iBorder2 := 50;\n END_IF\nEND_FOR\n での出力 メッセージ ビュー： SA0081: for ループの上限は定数値でなければなりません " }, 
{ "title" : "SA0090: 関数終了前の RETURN ステートメント ", 
"url" : "_san_rule_sa0090.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 指示の規則 \/ SA0090: 関数終了前の RETURN ステートメント ", 
"snippet" : "コードの場所を検出します。 RETURN ステートメントは、関数、メソッド、プロパティ、またはプログラムの最後のステートメントではありません。設置場所 RETURN 内に存在します IF ブランチも検出されます。 理由：A RETURN コード内にあると、コードの保守性、テスト性、および可読性が低下します。 A RETURN コード内は簡単に見落とされます。関数が終了するときに必ず実行する必要があるコーディングを、それぞれの前に行う必要があります。 RETURN 挿入すると、それはしばしば忘れられます。 重要性：中 PLCopenルール：CP14 例 FUNCTION SA0090: DINT...", 
"body" : "コードの場所を検出します。 RETURN ステートメントは、関数、メソッド、プロパティ、またはプログラムの最後のステートメントではありません。設置場所 RETURN 内に存在します IF ブランチも検出されます。 理由：A RETURN コード内にあると、コードの保守性、テスト性、および可読性が低下します。 A RETURN コード内は簡単に見落とされます。関数が終了するときに必ず実行する必要があるコーディングを、それぞれの前に行う必要があります。 RETURN 挿入すると、それはしばしば忘れられます。 重要性：中 PLCopenルール：CP14 例 FUNCTION SA0090: DINT\nVAR_INPUT\n bTest : BOOL;\nEND_VAR IF bTest THEN\n RETURN;\nEND_IF\nSA0090 := 99; での出力 メッセージ ビュー： SA0090: POUは単一の出口を持つ必要があります " }, 
{ "title" : "SA0095：条件の割り当て ", 
"url" : "_san_rule_sa0095.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0095：条件の割り当て ", 
"snippet" : "の条件で割り当てを決定します IF -、 CASE - また REPEAT -構築します。 理由：割り当て（：=）と比較（=）は簡単に混同される可能性があります。したがって、条件内の割り当ては、意図せずに簡単に行われる可能性があるため、報告されます。これは、コードの読者を混乱させる可能性もあります。 重要性：高い 例 PROGRAM PLC_PRG VAR iCond1:INT := INT#1; iCond2:INT := INT#2; xCond:BOOL := FALSE; iVar : INT; END_VAR IF INT_TO_BOOL(iCond1 := iCond2) THEN...", 
"body" : "の条件で割り当てを決定します IF -、 CASE - また REPEAT -構築します。 理由：割り当て（：=）と比較（=）は簡単に混同される可能性があります。したがって、条件内の割り当ては、意図せずに簡単に行われる可能性があるため、報告されます。これは、コードの読者を混乱させる可能性もあります。 重要性：高い 例 PROGRAM PLC_PRG\nVAR\n iCond1:INT := INT#1;\n iCond2:INT := INT#2;\n xCond:BOOL := FALSE;\n iVar : INT;\nEND_VAR IF INT_TO_BOOL(iCond1 := iCond2) THEN \/\/ SA0095\n iCond1 := INT#1;\n iCond2 := INT#2;\n ELSIF (iCond1 := 11) = 11 THEN \/\/ SA0095\n iCond1 := INT#1;\n iCond2 := INT#2;\nEND_IF\n\nIF xCond := TRUE THEN \/\/ SA0095\n xCond := FALSE;\nEND_IF\n\nIF (xCond := FALSE) OR (iCond1 := iCond2) = 12 THEN \/\/ SA0095\n xCond := FALSE;\n iCond1 := INT#1;\n iCond2 := INT#2;\nEND_IF\n\nIF (iVar := iVar + 1) = 120 THEN \/\/ SA0095 (can be valid, but is not reparable very well\n iVar := 0;\nEND_IF\n\nWHILE (xCond = TRUE) OR (iCond1 := iCond2) = 12 DO \/\/ SA0095\n xCond := FALSE;\nEND_WHILE\n\n\/\/Error: assignment in repeat loop\nREPEAT\n xCond := FALSE;\nUNTIL (xCond = TRUE) OR (iCond1 := iCond2) = 12 \/\/ SA0095\nEND_REPEAT での出力 メッセージ ビュー： SA0095: 条件の代入: '...' " }, 
{ "title" : "SA0100：<n>バイトより大きい変数 ", 
"url" : "_san_rule_sa0100.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0100：<n>バイトより大きい変数 ", 
"snippet" : "nバイトを超える変数を検索します。ここで、nは現在の構成で指定されます。デフォルト：1024バイト。行をダブルクリックすると、値を変更できます。 理論的根拠：一部のプログラミングガイドラインでは、単一の変数の最大サイズが設定されています。これはここで確認できます。 重要度：低 例 PROGRAM PLC_PRG VAR aobyTest : ARRAY [0..1024] OF BYTE; END_VAR aobyTest[INT#0] := aobyTest[INT#0] + BYTE#1; での出力 メッセージ ビュー： SA0100: 変数 'aobyTest' が 1024 バイトを超...", 
"body" : "nバイトを超える変数を検索します。ここで、nは現在の構成で指定されます。デフォルト：1024バイト。行をダブルクリックすると、値を変更できます。 理論的根拠：一部のプログラミングガイドラインでは、単一の変数の最大サイズが設定されています。これはここで確認できます。 重要度：低 例 PROGRAM PLC_PRG\nVAR\n aobyTest : ARRAY [0..1024] OF BYTE;\nEND_VAR\n aobyTest[INT#0] := aobyTest[INT#0] + BYTE#1; での出力 メッセージ ビュー： SA0100: 変数 'aobyTest' が 1024 バイトを超えています " }, 
{ "title" : "SA0101：長さが不正な名前 ", 
"url" : "_san_rule_sa0101.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0101：長さが不正な名前 ", 
"snippet" : "無効な長さの名前を検索します。ダイアログでこのルールの行をダブルクリックする プロジェクト設定 名前の長さを定義し、これに対する例外を指定できるダイアログが開きます。 理由：一部のプログラミングガイドラインでは、変数名の最小長が指定されています。この分析でコンプライアンスを確認できます。 重要度：低 PLCopenルール：N6 すべてのルールは次のとおりです。 静的解析の設定: ルール ダイアログ。そこで「ルール 101」をダブルクリックして、ルール固有の構成を開くことができます。次に、最小文字数と最大文字数を定義し、それらの文字に対する例外を設定できます。 名前の長さ ダイアログ。 例 PR...", 
"body" : "無効な長さの名前を検索します。ダイアログでこのルールの行をダブルクリックする プロジェクト設定 名前の長さを定義し、これに対する例外を指定できるダイアログが開きます。 理由：一部のプログラミングガイドラインでは、変数名の最小長が指定されています。この分析でコンプライアンスを確認できます。 重要度：低 PLCopenルール：N6 すべてのルールは次のとおりです。 静的解析の設定: ルール ダイアログ。そこで「ルール 101」をダブルクリックして、ルール固有の構成を開くことができます。次に、最小文字数と最大文字数を定義し、それらの文字に対する例外を設定できます。 名前の長さ ダイアログ。 例 PROGRAM PLC1 \/\/ SA0101\nVAR\n iVar1 : INT; \/\/ SA0101\nEND_VAR\n での出力 メッセージ ビュー： SA0101: 名前「PLC1」の長さが無効です " }, 
{ "title" : "SA0102: 外部からのプログラム\/FB 変数へのアクセス ", 
"url" : "_san_rule_sa0102.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0102: 外部からのプログラム\/FB 変数へのアクセス ", 
"snippet" : "プログラムまたは機能ブロックのローカル変数への外部アクセスを決定します。 理由： CODESYS プログラムまたは機能ブロックのローカル変数への外部読み取りアクセスを有効にします。これは、データのカプセル化（データの非表示）の原則に違反し、IEC61131-3規格に準拠していません。 重要性：中 例 PROGRAM PLC_PRG VAR iCounter : INT; afb_Instance : AFB; bfb_Instance : BFB; END_VAR iCounter := A_PRG.iLocal; \/\/ SA0102 iCounter := bfb_Instance.iLoc...", 
"body" : "プログラムまたは機能ブロックのローカル変数への外部アクセスを決定します。 理由： CODESYS プログラムまたは機能ブロックのローカル変数への外部読み取りアクセスを有効にします。これは、データのカプセル化（データの非表示）の原則に違反し、IEC61131-3規格に準拠していません。 重要性：中 例 PROGRAM PLC_PRG\nVAR\n iCounter : INT;\n afb_Instance : AFB;\n bfb_Instance : BFB;\nEND_VAR iCounter := A_PRG.iLocal; \/\/ SA0102\niCounter := bfb_Instance.iLocal; \/\/ SA0102\nA_PRG(); FUNCTION_BLOCK AFB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iLocal: INT;\nEND_VAR METHOD METH : INT\nVAR_INPUT\nEND_VAR iLocal := iLocal + 1; FUNCTION_BLOCK BFB EXTENDS AFB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\nEND_VAR\nMETHOD METH : INT\nVAR_INPUT\nEND_VAR iLocal := iLocal + 1; PROGRAM A_PRG\nVAR\n iLocal: INT;\nEND_VAR iLocal := iLocal + 1;\n での出力 メッセージ ビュー： SA0102: プログラム\/FB変数「iLocal」への外部からのアクセス " }, 
{ "title" : "SA0103：非アトミックデータへの同時アクセス ", 
"url" : "_san_rule_sa0103.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0103：非アトミックデータへの同時アクセス ", 
"snippet" : "非アトミック変数（データ型など）かどうかを判断します STRING 、 WSTRING 、 ARRAY 、 STRUCT 、FBインスタンス、64ビットデータ型）は、複数のタスクで使用できます。 理由：アクセス中に同期がない場合、あるタスクでの読み取りと別のタスクでの書き込みにより、読み取られる値に一貫性がなくなる可能性があります。 重要性：中 一部のデータ型、特に64ビット整数では、アクセスがアトミックであるかどうかはプラットフォームに依存します。静的コード分析は、コントローラーが64ビット整数データ型へのアトミックアクセスをサポートしていない場合にのみ問題を報告します。 このルールは、次の...", 
"body" : "非アトミック変数（データ型など）かどうかを判断します STRING 、 WSTRING 、 ARRAY 、 STRUCT 、FBインスタンス、64ビットデータ型）は、複数のタスクで使用できます。 理由：アクセス中に同期がない場合、あるタスクでの読み取りと別のタスクでの書き込みにより、読み取られる値に一貫性がなくなる可能性があります。 重要性：中 一部のデータ型、特に64ビット整数では、アクセスがアトミックであるかどうかはプラットフォームに依存します。静的コード分析は、コントローラーが64ビット整数データ型へのアトミックアクセスをサポートしていない場合にのみ問題を報告します。 このルールは、次の場合には適用されません。 ターゲットシステムにFPU（浮動小数点ユニット）がある場合、複数のタスクへのアクセスが制限されます LREAL -変数が決定されていません ターゲットシステムが64ビットプロセッサであるか、ターゲットデバイスに適切なターゲット設定が設定されている場合、ルールは64ビットデータタイプには適用されません。 例 プロジェクトには2つのプログラムが含まれています PRG1 と PRG2 。 プログラム PRG1 タスクによって使用されます MainTask_1 プログラムと呼ばれる PRG2 タスクから MainTask_2 。 VAR_GLOBAL\n lrTest : LREAL; \/\/ Since the target system has an FPU, SA0103 does apply.\n lint1 : LINT;\n sTest : STRING; \/\/ SA0103\n wsTest : WSTRING; \/\/ SA0103\nEND_VAR PROGRAM PRG1 GVL.lrTest := 5.0;\nGVL.sTest := 'welt';\nGVL.wsTest := \"welt\";\nGVL.lint1 := 99;\n PROGRAM PRG2 GVL.lrTest := 5.0;\nGVL.sTest := 'hallo';\nGVL.wsTest := \"hallo\";\nGVL.lint1 := 88; での出力 メッセージ ビュー： SA0103: アトミックではないデータ「sTest」に対する同時アクセス SA0103: アトミックではないデータ「wsTest」に対する同時アクセス " }, 
{ "title" : "SA0105：複数のインスタンス呼び出し ", 
"url" : "_san_rule_sa0105.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0105：複数のインスタンス呼び出し ", 
"snippet" : "複数回呼び出されるファンクションブロックのインスタンスを検出します。この目的のために、関数ブロックは次のプラグマでマークされる必要があります。 {attribute 'analysis:report-multiple-instance-calls'} 理由: 一部の機能ブロックは、サイクル内で 1 回だけ呼び出せるように設計されています。このテストでは、複数の場所で通話が行われているかどうかを確認します。 重要度：低 PLCopenルール：CP16 \/ CP20 例 \/\/ {attribute 'analysis:report-multiple-instance-calls'} Deactiv...", 
"body" : "複数回呼び出されるファンクションブロックのインスタンスを検出します。この目的のために、関数ブロックは次のプラグマでマークされる必要があります。 {attribute 'analysis:report-multiple-instance-calls'} 理由: 一部の機能ブロックは、サイクル内で 1 回だけ呼び出せるように設計されています。このテストでは、複数の場所で通話が行われているかどうかを確認します。 重要度：低 PLCopenルール：CP16 \/ CP20 例 \/\/ {attribute 'analysis:report-multiple-instance-calls'} Deactivated\nFUNCTION_BLOCK FB_DoA\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\n iA := iA + 1; {attribute 'analysis:report-multiple-instance-calls'}\nFUNCTION_BLOCK FB_DoB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iB : INT;\nEND_VAR\n iB := iB + 1; PROGRAM PLC_PRG\nVAR\n fbA : FB_DoA;\n fbB : FB_DoB;\nEND_VAR fbA();\nfbB(); \/\/ SA0105\nfbA();\nfbB(); \/\/ SA0105\n での出力 メッセージ ビュー： SA0105: インスタンス 'fbB' が複数回呼び出されました " }, 
{ "title" : "SA0106：FB_Initでの仮想メソッド呼び出し ", 
"url" : "_san_rule_sa0106.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0106：FB_Initでの仮想メソッド呼び出し ", 
"snippet" : "メソッド内のメソッド呼び出しを検出します FB_Init 基本FBから派生した機能ブロックによって上書きされる基本機能ブロックの。 理由：このような場合、基本FBの上書きされたメソッドの変数が初期化されていない可能性があります。 重要性：高い 例 ファンクションブロック FB_A メソッドがあります FB_Init と Meth_MyInit 。 FB_Init 呼び出し Meth_MyInit 初期化用。ファンクションブロック FB_B の FB_A 派生。 PLC_PRG 呼び出し FB_B したがって、その変数を使用します mbMyDintB 初期化される前。 FB_B.Meth_MyI...", 
"body" : "メソッド内のメソッド呼び出しを検出します FB_Init 基本FBから派生した機能ブロックによって上書きされる基本機能ブロックの。 理由：このような場合、基本FBの上書きされたメソッドの変数が初期化されていない可能性があります。 重要性：高い 例 ファンクションブロック FB_A メソッドがあります FB_Init と Meth_MyInit 。 FB_Init 呼び出し Meth_MyInit 初期化用。ファンクションブロック FB_B の FB_A 派生。 PLC_PRG 呼び出し FB_B したがって、その変数を使用します mbMyDintB 初期化される前。 FB_B.Meth_MyInit 上書きします FB_A.Meth_MyInit 。 FUNCTION_BLOCK FB_A\nVAR\n mbMyDintA : DINT;\nEND_VAR FUNCTION_BLOCK FB_B EXTENDS FB_A\nVAR\n mbMyDintB : DINT;\nEND_VAR METHOD FB_Init : BOOL\nVAR_INPUT\n bInitRetains:BOOL;\n bInCopyCode:BOOL;\nEND_VAR\nVAR\n diDummy:DINT; \/\/SA0106\nEND_VAR\n mbMyDintA := 123;\ndiDummy := Meth_MyInit(); METHOD Meth_MyInit : DINT\nVAR_INPUT\nEND_VAR\n mbMyDintB := 123; \/\/access to member of FB_B PROGRAM PLC_PRG\nVAR\n g_BInst : FB_B;\n xVar : BOOL;\nEND_VAR\n\n xVar := g_BInst.fb_init(TRUE, TRUE);\n\/\/this instruction causes the following order of initializations:\n\/\/FB_A.fb_init\n\/\/FB_B.Meth_MyInit \/\/SA0106\n\/\/FB_B.fb_init\n\/\/FB_B.Meth_MyInit での出力 メッセージ ビュー： SA0106: FB_INIT の仮想メソッド呼び出し 'Meth_MyInit' " }, 
{ "title" : "SA0107：正式なパラメータがありません ", 
"url" : "_san_rule_sa0107.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0107：正式なパラメータがありません ", 
"snippet" : "正式なパラメーターが欠落しているかどうかを判別します。 理由: 呼び出しで仮パラメータを指定すると、コードが読みやすくなります。 重要度：低 例 FUNCTION FUNA : BOOL VAR_INPUT bDo : BOOL; bInit : BOOL; bManual : BOOL; END_VAR VAR iInit : INT; iLocal : INT; iManual : INT; END_VAR IF bInit = TRUE THEN iInit := iInit + 1; END_IF IF bDo = TRUE THEN iLocal := iLocal + 1; END...", 
"body" : "正式なパラメーターが欠落しているかどうかを判別します。 理由: 呼び出しで仮パラメータを指定すると、コードが読みやすくなります。 重要度：低 例 FUNCTION FUNA : BOOL\nVAR_INPUT\n bDo : BOOL;\n bInit : BOOL;\n bManual : BOOL;\nEND_VAR\nVAR\n iInit : INT;\n iLocal : INT;\n iManual : INT;\nEND_VAR\n IF bInit = TRUE THEN\n iInit := iInit + 1;\nEND_IF\nIF bDo = TRUE THEN\n iLocal := iLocal + 1;\nEND_IF\nIF bManual = TRUE THEN\n iManual := iManual + 1;\nEND_IF\nFUNA := TRUE;\n PROGRAM PLC_PRG\nVAR\nEND_VAR\n FUNA(bInit := TRUE, bDo := TRUE, bManual := FALSE); \/\/ OK\nFUNA(TRUE, TRUE, bManual:= FALSE); \/\/ SA0107 での出力 メッセージ ビュー： SA0107: 入力「TRUE」の仮パラメータが欠落しています " }, 
{ "title" : "厳格なIECルールを確認してください ", 
"url" : "_san_check_strict_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 厳格なIECルールを確認してください ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0111：ポインタ変数 ", 
"url" : "_san_rule_sa0111.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 厳格なIECルールを確認してください \/ SA0111：ポインタ変数 ", 
"snippet" : "タイプの変数を決定します POINTER TO 。 理由：IEC61131-3規格ではポインターが許可されていません。 重要度：低 例 VAR piTemp : POINTER TO INT; pbyTemp : POINTER TO BYTE; END_VAR での出力 メッセージ ビュー： SA0111: データ型 POINTER は使用できません...", 
"body" : "タイプの変数を決定します POINTER TO 。 理由：IEC61131-3規格ではポインターが許可されていません。 重要度：低 例 VAR\n piTemp : POINTER TO INT;\n pbyTemp : POINTER TO BYTE;\nEND_VAR\n での出力 メッセージ ビュー： SA0111: データ型 POINTER は使用できません " }, 
{ "title" : "SA0112：参照変数 ", 
"url" : "_san_rule_sa0112.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 厳格なIECルールを確認してください \/ SA0112：参照変数 ", 
"snippet" : "型の変数を検出します。 REFERENCE TO 理由：IEC61131-3規格では参照が許可されていません。 重要度：低 例 VAR ref_int : REFERENCE TO INT; ref_dw : REFERENCE TO DWORD; END_VAR での出力 メッセージ ビュー： SA0112: データ型 REFERENCE は許可されません...", 
"body" : "型の変数を検出します。 REFERENCE TO 理由：IEC61131-3規格では参照が許可されていません。 重要度：低 例 VAR\n ref_int : REFERENCE TO INT;\n ref_dw : REFERENCE TO DWORD;\nEND_VAR\n での出力 メッセージ ビュー： SA0112: データ型 REFERENCE は許可されません " }, 
{ "title" : "SA0113：データ型WSTRINGの変数 ", 
"url" : "_san_rule_sa0113.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 厳格なIECルールを確認してください \/ SA0113：データ型WSTRINGの変数 ", 
"snippet" : "型の変数を決定します WSTRING 。 理由：すべてのシステムがそれをサポートしているわけではありません WSTRING 。クリックするとコードの移植性が高まります WSTRING 免除。 重要度: 低 例 VAR wstrTemp : WSTRING; END_VAR での出力 メッセージ ビュー： SA0113: データ型 WSTRING は使用できません...", 
"body" : "型の変数を決定します WSTRING 。 理由：すべてのシステムがそれをサポートしているわけではありません WSTRING 。クリックするとコードの移植性が高まります WSTRING 免除。 重要度: 低 例 VAR\n wstrTemp : WSTRING;\nEND_VAR\n での出力 メッセージ ビュー： SA0113: データ型 WSTRING は使用できません " }, 
{ "title" : "SA0114：データ型LTIMEの変数 ", 
"url" : "_san_rule_sa0114.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 厳格なIECルールを確認してください \/ SA0114：データ型LTIMEの変数 ", 
"snippet" : "型の変数を検出します。 LTIME 理由：すべてのシステムがそれをサポートしているわけではありません LTIME 。クリックするとコードの移植性が高まります LTIME 免除。 重要度：低 例 VAR ltVar : LTIME; \/\/ SA0114 END_VAR での出力 メッセージ ビュー： SA0114: データ型 LTIME は許可されません 詳細については、以下を参照してください。 'analysis：report-multiple-instance-calls'属性...", 
"body" : "型の変数を検出します。 LTIME 理由：すべてのシステムがそれをサポートしているわけではありません LTIME 。クリックするとコードの移植性が高まります LTIME 免除。 重要度：低 例 VAR\n ltVar : LTIME; \/\/ SA0114\nEND_VAR\n での出力 メッセージ ビュー： SA0114: データ型 LTIME は許可されません 詳細については、以下を参照してください。 'analysis：report-multiple-instance-calls'属性 " }, 
{ "title" : "SA0115：データ型UNIONの宣言 ", 
"url" : "_san_rule_sa0115.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 厳格なIECルールを確認してください \/ SA0115：データ型UNIONの宣言 ", 
"snippet" : "の宣言を取得します UNION -データ型と型aの変数の宣言 UNION 。 根拠: IEC 61131-3 標準には共用体が含まれていません。共用体を使用しないとコードの移植が容易になります。 重要度：低 例 TYPE A_UNION: UNION lrTemp : LREAL; liTemp : LINT; END_UNION END_TYPE PROGRAM PLC_PRG VAR aunionVar: A_UNION; liVar : LINT; END_VAR aunionVar.lrTemp := 0.123E-12; liVar := aunionVar.liTemp; での出力...", 
"body" : "の宣言を取得します UNION -データ型と型aの変数の宣言 UNION 。 根拠: IEC 61131-3 標準には共用体が含まれていません。共用体を使用しないとコードの移植が容易になります。 重要度：低 例 TYPE A_UNION: \nUNION\n lrTemp : LREAL;\n liTemp : LINT;\nEND_UNION\nEND_TYPE PROGRAM PLC_PRG\nVAR\n aunionVar: A_UNION;\n liVar : LINT;\nEND_VAR aunionVar.lrTemp := 0.123E-12;\nliVar := aunionVar.liTemp; での出力 メッセージ ビュー： SA0115: 共用体は使用できません " }, 
{ "title" : "SA0117：データ型BITの変数 ", 
"url" : "_san_rule_sa0117.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 厳格なIECルールを確認してください \/ SA0117：データ型BITの変数 ", 
"snippet" : "データ型の変数宣言を検出します。 BIT (構造定義内で可能) 根拠: IEC 61131-3 規格にはデータ型が含まれていません。 BIT 。コードは、 BIT 。 重要度：低 例 TYPE Struct1 : STRUCT bitVar : BIT; iVar : INT; bVar : BOOL; END_STRUCT END_TYPE での出力 メッセージ ビュー： SA0117: データ型が BIT の変数...", 
"body" : "データ型の変数宣言を検出します。 BIT (構造定義内で可能) 根拠: IEC 61131-3 規格にはデータ型が含まれていません。 BIT 。コードは、 BIT 。 重要度：低 例 TYPE Struct1 :\nSTRUCT\n bitVar : BIT;\n iVar : INT;\n bVar : BOOL;\nEND_STRUCT\nEND_TYPE\n での出力 メッセージ ビュー： SA0117: データ型が BIT の変数 " }, 
{ "title" : "SA0119：オブジェクト指向機能 ", 
"url" : "_san_rule_sa0119.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 厳格なIECルールを確認してください \/ SA0119：オブジェクト指向機能 ", 
"snippet" : "関数ブロック宣言などのオブジェクト指向機能の使用を決定します EXTENDS と IMPLEMENTS 、またはプロパティとインターフェイスの宣言。このルールは、他の61131-3システムに移植するコードを作成するときに役立ちます。 理由：すべてのシステムがオブジェクト指向プログラミングをサポートしているわけではありません。オブジェクト指向を使用しない場合、コードはより移植性が高くなります。 重要度：低 例 \/\/Function block extended by another and implementing an interface: FUNCTION_BLOCK POU EXTENDS...", 
"body" : "関数ブロック宣言などのオブジェクト指向機能の使用を決定します EXTENDS と IMPLEMENTS 、またはプロパティとインターフェイスの宣言。このルールは、他の61131-3システムに移植するコードを作成するときに役立ちます。 理由：すべてのシステムがオブジェクト指向プログラミングをサポートしているわけではありません。オブジェクト指向を使用しない場合、コードはより移植性が高くなります。 重要度：低 例 \/\/Function block extended by another and implementing an interface:\nFUNCTION_BLOCK POU EXTENDS CTD IMPLEMENTS ITF \/\/SA0119\n;\n \/\/ Declaration parts of property methods assigned to a function block:\nPOU.Prop.Get \/\/SA0119 POU.Prop.Set \/\/SA0119 での出力 メッセージ ビュー： SA0119: オブジェクト指向機能は許可されていません " }, 
{ "title" : "SA0120：プログラム呼び出し ", 
"url" : "_san_rule_sa0120.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 厳格なIECルールを確認してください \/ SA0120：プログラム呼び出し ", 
"snippet" : "プログラム呼び出しを決定します。 理由：IEC 61131-3規格によると、プログラムはタスク構成でのみ呼び出すことができます。プログラムを他の場所で呼び出さないと、コードの移植性が高まります。 重要度：低 例 PROGRAM prog_control VAR END_VAR ; PROGRAM PLC_PRG VAR END_VAR prog_control(); での出力 メッセージ ビュー： SA0120: 'prg_control' へのプログラム呼び出しは許可されていません...", 
"body" : "プログラム呼び出しを決定します。 理由：IEC 61131-3規格によると、プログラムはタスク構成でのみ呼び出すことができます。プログラムを他の場所で呼び出さないと、コードの移植性が高まります。 重要度：低 例 PROGRAM prog_control\nVAR\nEND_VAR\n; PROGRAM PLC_PRG\nVAR\nEND_VAR\n prog_control(); での出力 メッセージ ビュー： SA0120: 'prg_control' へのプログラム呼び出しは許可されていません " }, 
{ "title" : "SA0121: VAR_EXTERNAL 宣言がありません ", 
"url" : "_san_rule_sa0121.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 厳格なIECルールを確認してください \/ SA0121: VAR_EXTERNAL 宣言がありません ", 
"snippet" : "関数ブロックで宣言されていないグローバル変数の使用を検出します。 VAR_EXTERNAL 理由：IEC 61131-3規格によると、グローバル変数へのアクセスは、 VAR_EXTERNAL -宣言は許可されています。 重要度：低 PLCopenルール：CP18 例 VAR_GLOBAL iGlob1 : INT; END_VAR PROGRAM PLC_PRG VAR ivar : INT; END_VAR ivar := iGlob1; \/\/ SA0121 での出力 メッセージ ビュー： SA0121: 変数 'iGlob1' には VAR_EXTERNAL 宣言が必要です エラー回避の例...", 
"body" : "関数ブロックで宣言されていないグローバル変数の使用を検出します。 VAR_EXTERNAL 理由：IEC 61131-3規格によると、グローバル変数へのアクセスは、 VAR_EXTERNAL -宣言は許可されています。 重要度：低 PLCopenルール：CP18 例 VAR_GLOBAL\n iGlob1 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n ivar : INT;\nEND_VAR\n ivar := iGlob1; \/\/ SA0121 での出力 メッセージ ビュー： SA0121: 変数 'iGlob1' には VAR_EXTERNAL 宣言が必要です エラー回避の例 VAR_GLOBAL\n iGlob1:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n ivar:INT;\nEND_VAR\nVAR_EXTERNAL\n iGlob1:INT;\nEND_VAR\n ivar:=iGlob1; \/\/ OK " }, 
{ "title" : "SA0122：式として定義された配列インデックス ", 
"url" : "_san_rule_sa0122.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 厳格なIECルールを確認してください \/ SA0122：式として定義された配列インデックス ", 
"snippet" : "配列インデックスを宣言するときの式の使用を検出します。 理由：すべてのシステムが式を配列境界として許可しているわけではありません。 重要度：低 例 PROGRAM PLC_PRG VAR CONSTANT c_iValue : INT := INT#15; END_VAR VAR arr : ARRAY [0..c_iValue + 1] OF INT; END_VAR での出力 メッセージ ビュー： SA0122: 配列定義 'arr' には定数のみが許可されます...", 
"body" : "配列インデックスを宣言するときの式の使用を検出します。 理由：すべてのシステムが式を配列境界として許可しているわけではありません。 重要度：低 例 PROGRAM PLC_PRG\nVAR CONSTANT\n c_iValue : INT := INT#15;\nEND_VAR\nVAR\n arr : ARRAY [0..c_iValue + 1] OF INT;\nEND_VAR\n での出力 メッセージ ビュー： SA0122: 配列定義 'arr' には定数のみが許可されます " }, 
{ "title" : "SA0123：INI、ADR、またはBITADRの使用 ", 
"url" : "_san_rule_sa0123.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 厳格なIECルールを確認してください \/ SA0123：INI、ADR、またはBITADRの使用 ", 
"snippet" : "の使用を決定します CODESYS Static Analysis -特定の演算子 INI 、 ADR と BITADR 。 理由： CODESYS -特定の演算子は、コードの移植性を妨げます。 重要度：低 例 PROGRAM PLC_PRG VAR uiTemp : UINT; TempVarInFUNC : DWORD; END_VAR TempVarInFUNC := ADR(uiTemp); \/\/SA0123 での出力 メッセージ ビュー： SA0123: 演算子「ADR」は許可されていません...", 
"body" : "の使用を決定します CODESYS Static Analysis -特定の演算子 INI 、 ADR と BITADR 。 理由： CODESYS -特定の演算子は、コードの移植性を妨げます。 重要度：低 例 PROGRAM PLC_PRG\nVAR\n uiTemp : UINT;\n TempVarInFUNC : DWORD;\nEND_VAR\n TempVarInFUNC := ADR(uiTemp); \/\/SA0123 での出力 メッセージ ビュー： SA0123: 演算子「ADR」は許可されていません " }, 
{ "title" : "SA0147：異常な移動操作-strict ", 
"url" : "_san_rule_sa0147.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 厳格なIECルールを確認してください \/ SA0147：異常な移動操作-strict ", 
"snippet" : "ビットフィールドデータ型に適用されないビットシフト操作を決定します（ BYTE 、 WORD 、 DWORD 、 LWORD ） それぞれ。 理由：IEC 61131-3規格では、ビットフィールドデータ型へのビットアクセスのみが許可されています。 the CODESYS ただし、コンパイラは、符号なしデータ型を使用したビットシフト演算も許可します。 重要度：低 非厳密なルールも参照してください SA0018 。 例 PROGRAM PLC_PRG VAR in_byte : BYTE := 16#45; \/\/ 2#01000101 in_word : WORD := 16#0045; \/\/ 2...", 
"body" : "ビットフィールドデータ型に適用されないビットシフト操作を決定します（ BYTE 、 WORD 、 DWORD 、 LWORD ） それぞれ。 理由：IEC 61131-3規格では、ビットフィールドデータ型へのビットアクセスのみが許可されています。 the CODESYS ただし、コンパイラは、符号なしデータ型を使用したビットシフト演算も許可します。 重要度：低 非厳密なルールも参照してください SA0018 。 例 PROGRAM PLC_PRG\nVAR\n in_byte : BYTE := 16#45; \/\/ 2#01000101\n in_word : WORD := 16#0045; \/\/ 2#0000000001000101\n in_uint : UINT;\n in_dint : DINT;\n erg_byte : BYTE;\n erg_word : WORD;\n erg_uint : UINT;\n erg_dint : DINT;\n n: BYTE := 2;\nEND_VAR\n erg_byte := SHL(in_byte,n); \/\/ no error because BYTE is a bit field\nerg_word := SHL(in_word,n); \/\/ no error because WORD is a bit field\nerg_uint := SHL(in_uint,n); \/\/ SA0147\nerg_dint := SHL(in_dint,n); \/\/ SA0147 での出力 メッセージ ビュー： SA0147: 異常なシフト操作 – 厳密 " }, 
{ "title" : "SA0148：異常なビットアクセス-strict ", 
"url" : "_san_rule_sa0148.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 厳格なIECルールを確認してください \/ SA0148：異常なビットアクセス-strict ", 
"snippet" : "ビットフィールドのデータ型に基づかないビットアクセスを決定します（ BYTE 、 WORD 、 DWORD 、 LWORD ） それぞれ。 IEC 61131-3規格では、ビットフィールドデータ型へのビットアクセスのみが許可されています。 the CODESYS ただし、コンパイラは符号なしデータ型へのビットアクセスも許可します。 重要度: 低 例 PROGRAM PLC_PRG VAR iTemp1 : INT; diTemp3 : DINT; uliTemp4 : ULINT; siTemp5 : SINT; usiTemp6 : USINT; byTemp2 : BYTE; END_VA...", 
"body" : "ビットフィールドのデータ型に基づかないビットアクセスを決定します（ BYTE 、 WORD 、 DWORD 、 LWORD ） それぞれ。 IEC 61131-3規格では、ビットフィールドデータ型へのビットアクセスのみが許可されています。 the CODESYS ただし、コンパイラは符号なしデータ型へのビットアクセスも許可します。 重要度: 低 例 PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n diTemp3 : DINT;\n uliTemp4 : ULINT;\n siTemp5 : SINT;\n usiTemp6 : USINT;\n byTemp2 : BYTE;\nEND_VAR\n iTemp1.3 := TRUE; \/\/ SA0148\ndiTemp3.4 := TRUE; \/\/ SA0148\nuliTemp4.18 := FALSE; \/\/ SA0148\nsiTemp5.2 := FALSE; \/\/ SA0148\nusiTemp6.3 := TRUE; \/\/ SA0148\nbyTemp2.5 := FALSE; \/\/ no error because BYTE is a bitfield での出力 メッセージ ビュー： SA0148: 異常なビット アクセス – 厳密 " }, 
{ "title" : "SA0118：定数を使用しない初期化 ", 
"url" : "_san_rule_sa0118.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 厳格なIECルールを確認してください \/ SA0118：定数を使用しない初期化 ", 
"snippet" : "定数を割り当てない初期化子を検索します。 理由：初期化は可能な限り一定であり、他の変数を参照しないようにする必要があります。特に、初期化中の関数呼び出しは、初期化されていないデータへのアクセスにつながる可能性があるため、避ける必要があります。 重要性：中 例 PROGRAM PLC_PRG VAR dwTemp : DWORD := 22; dwTest : DWORD := dwTemp; \/\/ SA0118 dwVar : DWORD := TempVarInFUNC(); \/\/ SA0118 END_VAR での出力 メッセージ ビュー： SA0118: 定数を使用しない初期化...", 
"body" : "定数を割り当てない初期化子を検索します。 理由：初期化は可能な限り一定であり、他の変数を参照しないようにする必要があります。特に、初期化中の関数呼び出しは、初期化されていないデータへのアクセスにつながる可能性があるため、避ける必要があります。 重要性：中 例 PROGRAM PLC_PRG\nVAR\n dwTemp : DWORD := 22;\n dwTest : DWORD := dwTemp; \/\/ SA0118\n dwVar : DWORD := TempVarInFUNC(); \/\/ SA0118\nEND_VAR\n での出力 メッセージ ビュー： SA0118: 定数を使用しない初期化 " }, 
{ "title" : "SA0124：宣言部分でのポインターの間接参照 ", 
"url" : "_san_rule_sa0124.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 厳格なIECルールを確認してください \/ SA0124：宣言部分でのポインターの間接参照 ", 
"snippet" : "宣言部分の初期化に使用されるポインター逆参照を決定します。 理由: ポインターと参照は初期化に使用しないでください。ポインターが初期化されていない場合、アクセス違反が発生する可能性があります。 重要性：中 例 TYPE TESTSTRUCT : STRUCT xA : BOOL; xB : BOOL; END_STRUCT END_TYPE FUNCTION_BLOCK FB_Test VAR_INPUT pTeststruct : POINTER TO TESTSTRUCT; END_VAR VAR xA : BOOL := pTeststruct^.xA; \/\/SA0124 END_VAR...", 
"body" : "宣言部分の初期化に使用されるポインター逆参照を決定します。 理由: ポインターと参照は初期化に使用しないでください。ポインターが初期化されていない場合、アクセス違反が発生する可能性があります。 重要性：中 例 TYPE TESTSTRUCT :\nSTRUCT\n xA : BOOL;\n xB : BOOL;\nEND_STRUCT\nEND_TYPE FUNCTION_BLOCK FB_Test\nVAR_INPUT\n pTeststruct : POINTER TO TESTSTRUCT;\nEND_VAR\nVAR\n xA : BOOL := pTeststruct^.xA; \/\/SA0124 \nEND_VAR\n\n xA := TRUE; PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\nEND_VAR\n fbTest(); での出力 メッセージ ビュー： SA0124: 宣言内のポインター逆参照 " }, 
{ "title" : "SA0125：初期化の参照変数 ", 
"url" : "_san_rule_sa0125.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ 厳格なIECルールを確認してください \/ SA0125：初期化の参照変数 ", 
"snippet" : "宣言部分の初期化に使用される参照変数を決定します。 理由: ポインターと参照は初期化に使用しないでください。ポインターが初期化されていない場合、アクセス違反が発生する可能性があります。 重要性：中 例 TYPE TESTSTRUCT : STRUCT xA : BOOL; xB : BOOL; END_STRUCT END_TYPE FUNCTION_BLOCK FB_Test VAR_INPUT refTeststruct: REFERENCE TO TESTSTRUCT; END_VAR VAR xA : BOOL := refTeststruct.xA; \/\/SA0125 END_VAR...", 
"body" : "宣言部分の初期化に使用される参照変数を決定します。 理由: ポインターと参照は初期化に使用しないでください。ポインターが初期化されていない場合、アクセス違反が発生する可能性があります。 重要性：中 例 TYPE TESTSTRUCT :\nSTRUCT\n xA : BOOL;\n xB : BOOL;\nEND_STRUCT\nEND_TYPE FUNCTION_BLOCK FB_Test\nVAR_INPUT\n refTeststruct: REFERENCE TO TESTSTRUCT;\nEND_VAR\nVAR\n xA : BOOL := refTeststruct.xA; \/\/SA0125\nEND_VAR\n xA := TRUE; PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\nEND_VAR\n fbTest(); での出力 メッセージ ビュー： SA0125: 初期化で使用される参照 " }, 
{ "title" : "SA0140：ステートメントがコメントアウトされました ", 
"url" : "_san_rule_sa0140.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0140：ステートメントがコメントアウトされました ", 
"snippet" : "コメントアウトされたステートメントを検索します 理論的根拠：コードは、デバッグ目的でコメントアウトされることがよくあります。そのようなコメントがリリースされたとき、コードを削除する必要があるのか、それともデバッグ目的でコメントアウトされて誤ってコメントされていないのかは後で不明になります。 重要性：高い PLCopenルール：C4 例 PROGRAM PLC_PRG VAR iValue1: INT; iValue2: INT; END_VAR iValue1 := 100; iValue2 := 200; \/\/ iValue2 := 300; での出力 メッセージ ビュー： SA0140: ...", 
"body" : "コメントアウトされたステートメントを検索します 理論的根拠：コードは、デバッグ目的でコメントアウトされることがよくあります。そのようなコメントがリリースされたとき、コードを削除する必要があるのか、それともデバッグ目的でコメントアウトされて誤ってコメントされていないのかは後で不明になります。 重要性：高い PLCopenルール：C4 例 PROGRAM PLC_PRG\nVAR\n iValue1: INT;\n iValue2: INT;\nEND_VAR\n iValue1 := 100;\niValue2 := 200;\n\/\/ iValue2 := 300; での出力 メッセージ ビュー： SA0140: コメントアウトされたステートメント: iValue2 := 300 " }, 
{ "title" : "おそらく初期化されていない変数が使用されています ", 
"url" : "_san_non_initialized_variables.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ おそらく初期化されていない変数が使用されています ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0039：nullポインタの逆参照の可能性 ", 
"url" : "_san_rule_sa0039.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ おそらく初期化されていない変数が使用されています \/ SA0039：nullポインタの逆参照の可能性 ", 
"snippet" : "nullポインタが逆参照される可能性のあるコードを決定します。 正当性: ポインターは、各逆参照の前にチェックして、ゼロに等しくないことを確認する必要があります。そうしないと、実行時にアクセス違反が発生する可能性があります。 重要性：高い 例 PROGRAM PLC_PRG VAR ptiVar1:POINTER TO INT; ptiVar2:POINTER TO INT; ptiVar3:POINTER TO INT; iVar:INT; iCount :INT; iCondition: INT; END_VAR iCount := iCount + INT#1; ptiVar1 := A...", 
"body" : "nullポインタが逆参照される可能性のあるコードを決定します。 正当性: ポインターは、各逆参照の前にチェックして、ゼロに等しくないことを確認する必要があります。そうしないと、実行時にアクセス違反が発生する可能性があります。 重要性：高い 例 PROGRAM PLC_PRG\nVAR\n ptiVar1:POINTER TO INT;\n ptiVar2:POINTER TO INT;\n ptiVar3:POINTER TO INT;\n iVar:INT;\n iCount :INT;\n iCondition: INT;\nEND_VAR\n iCount := iCount + INT#1;\nptiVar1 := ADR(iVar);\nptiVar1^ := iCondition; \/\/ OK - valid reference\nptiVar2^ := iCondition; \/\/ SA0039 - null pointer dereferenciation\niVar := ptiVar3^; \/\/ SA0039 - null pointer dereferenciation での出力 メッセージ ビュー： SA0039: NULL ポインターの参照 'ptiVar2^' の可能性があります SA0039: NULL ポインターの参照 'ptiVar3^' の可能性があります " }, 
{ "title" : "SA0046：初期化されていないインターフェイスが使用されている可能性があります ", 
"url" : "_san_rule_sa0046.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ おそらく初期化されていない変数が使用されています \/ SA0046：初期化されていないインターフェイスが使用されている可能性があります ", 
"snippet" : "使用前に初期化されていないインターフェースの使用を検出します。 理由: インターフェイス参照は、使用する前に <> 0 であるかどうかをチェックする必要があります。そうしないと、アクセス中にアクセス違反が発生する可能性があります。 重要性：高い 例 \/\/Declaration of INTERFACE ITF and assigned METH2: METHOD METH2 : BOOL VAR_INPUT iInput2:INT; END_VAR \/\/Declaration of INTERFACE Master_ITF1 and assigned METH: METHOD METH : B...", 
"body" : "使用前に初期化されていないインターフェースの使用を検出します。 理由: インターフェイス参照は、使用する前に <> 0 であるかどうかをチェックする必要があります。そうしないと、アクセス中にアクセス違反が発生する可能性があります。 重要性：高い 例 \/\/Declaration of INTERFACE ITF and assigned METH2:\nMETHOD METH2 : BOOL\nVAR_INPUT\n iInput2:INT;\nEND_VAR \/\/Declaration of INTERFACE Master_ITF1 and assigned METH:\nMETHOD METH : BOOL\nVAR_INPUT\n iInput:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n instPOU : POU;\n instITF : ITF;\n instMasterITF1 : Master_ITF1;\n instMasterITF2 : Master_ITF2;\n iDummy : INT;\n xDummy : BOOL;\n instNoInitITF : ITF;\n instNoInitITF2 : ITF;\n instNoInitMasterITF1 : Master_ITF1;\n instNoInitMasterITF2 : Master_ITF2;\nEND_VAR instITF := instPOU;\nxDummy := instITF.METH(iInput := iDummy); \/\/ OK\ninstMasterITF1 := instPOU;\nxDummy := instMasterITF1.METH(iInput := iDummy); \/\/ OK\n\nxDummy := instNoInitITF.METH(iInput := INT#1); \/\/ SA0046\nxDummy := instNoInitITF.METH2(iInput2 := INT#2); \/\/ SA0046\nxDummy := instNoInitMasterITF1.METH(iInput := INT#3); \/\/ SA0046\niDummy := instNoInitMasterITF2.Prop; \/\/ SA0046\n\nIF instNoInitITF <> 0 THEN\n instNoInitITF.Prop; \/\/ OK, because the interface can't be 0\nEND_IF での出力 メッセージ ビュー： SA0046: 初期化されていないインターフェイス 'instNoInitITF' が使用されている可能性があります SA0046: 初期化されていないインターフェイス 'instNoInitITF' が使用されている可能性があります SA0046: 初期化されていないインターフェイス 'instNoInitMasterITF1' が使用されている可能性があります SA0046: 初期化されていないインターフェイス 'instNoInitMasterITF2' が使用されている可能性があります " }, 
{ "title" : "SA0145：初期化されていない参照の使用の可能性 ", 
"url" : "_san_rule_sa0145.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ おそらく初期化されていない変数が使用されています \/ SA0145：初期化されていない参照の使用の可能性 ", 
"snippet" : "使用前に初期化できず、オペレーターによっても初期化されない可能性のある、使用済みのすべての参照変数を取得します __ISVALIDREF チェックされます。このルールは、POUの実装部分に適用されます。宣言にはルールがあります SA0124 。 理由: アクセス中にアクセス違反が発生する可能性があるため、アクセス前に参照の有効性をチェックする必要があります。 重要性：高い 例 PROGRAM PLC_PRG VAR_INPUT ref_iTest : REFERENCE TO INT; END_VAR ref_iTest := 99; \/\/ SA0145 IF __ISVALIDREF(ref...", 
"body" : "使用前に初期化できず、オペレーターによっても初期化されない可能性のある、使用済みのすべての参照変数を取得します __ISVALIDREF チェックされます。このルールは、POUの実装部分に適用されます。宣言にはルールがあります SA0124 。 理由: アクセス中にアクセス違反が発生する可能性があるため、アクセス前に参照の有効性をチェックする必要があります。 重要性：高い 例 PROGRAM PLC_PRG\nVAR_INPUT\n ref_iTest : REFERENCE TO INT;\nEND_VAR\n ref_iTest := 99; \/\/ SA0145\nIF __ISVALIDREF(ref_iTest) THEN\n ref_iTest := 88;\nEND_IF での出力 メッセージ ビュー： SA0145: 初期化されていない参照 'ref_iTest' が使用されている可能性があります " }, 
{ "title" : "SA0150：メトリックの下限または上限の違反 ", 
"url" : "_san_rule_sa0150.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0150：メトリックの下限または上限の違反 ", 
"snippet" : "下限または上限で有効なメトリックに違反しているビルディングブロックを識別します。 理論的根拠：特定のメトリックに準拠するコードは、読みやすく、保守しやすく、テストしやすいです。 重要性：高い PLCopenルール：CP9 例 初期状況：メトリック ビューの数 対話中です プロジェクト設定→静的コード分析→メトリクス 起動しました。下限： 0 、 上限： 3 。建築用ブロック Prog_1 ただし、5回呼び出されます。 静的解析を実行すると、エラーが発生します SA0150：Prog_1のメトリック違反。メトリックビューのスコア（5）> 2 カテゴリのメッセージウィンドウ 翻訳すること 発行済み...", 
"body" : "下限または上限で有効なメトリックに違反しているビルディングブロックを識別します。 理論的根拠：特定のメトリックに準拠するコードは、読みやすく、保守しやすく、テストしやすいです。 重要性：高い PLCopenルール：CP9 例 初期状況：メトリック ビューの数 対話中です プロジェクト設定→静的コード分析→メトリクス 起動しました。下限： 0 、 上限： 3 。建築用ブロック Prog_1 ただし、5回呼び出されます。 静的解析を実行すると、エラーが発生します SA0150：Prog_1のメトリック違反。メトリックビューのスコア（5）> 2 カテゴリのメッセージウィンドウ 翻訳すること 発行済み。 " }, 
{ "title" : "SA0160：再帰呼び出し ", 
"url" : "_san_rule_sa0160.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0160：再帰呼び出し ", 
"snippet" : "ファンクションブロックのアクション、メソッド、およびプロパティでの再帰呼び出しを決定します。また、仮想関数呼び出しとインターフェース呼び出しを介して可能な再帰を検出します。 理由：再帰は非決定論的な動作につながるため、エラーの原因になります。 重要性：中 PLCopenルール：CP13 例 機能ブロック FB_Test 次の方法です Call 割り当て： FUNCTION_BLOCK FB_Test VAR bParameter: BOOL; END_VAR METHOD Call : BOOL VAR_INPUT END_VAR Call := THIS^.Call(); \/\/SA0160 ...", 
"body" : "ファンクションブロックのアクション、メソッド、およびプロパティでの再帰呼び出しを決定します。また、仮想関数呼び出しとインターフェース呼び出しを介して可能な再帰を検出します。 理由：再帰は非決定論的な動作につながるため、エラーの原因になります。 重要性：中 PLCopenルール：CP13 例 機能ブロック FB_Test 次の方法です Call 割り当て： FUNCTION_BLOCK FB_Test\nVAR\n bParameter: BOOL;\nEND_VAR\n METHOD Call : BOOL\nVAR_INPUT\nEND_VAR\n Call := THIS^.Call(); \/\/SA0160 プログラム PLC_PRG 呼び出し FB_Test の上： PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\n bValue : BOOL;\nEND_VAR\n bValue := fbTest.bParameter;\nfbTest.Call(); での出力 メッセージ ビュー： SA0160: 再帰呼び出しが検出されました: 'PLC_PRG' -> 'FB_Test.Call' -> 'FB_Test.Call' " }, 
{ "title" : "SA0161：パック構造のアンパック構造 ", 
"url" : "_san_rule_sa0161.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0161：パック構造のアンパック構造 ", 
"snippet" : "パック構造で使用されるアンパック構造を決定します。 理由: コンパイラは通常、アンパックされた構造体を、構造体内のすべての要素への整列されたアクセスを許可するアドレスに設定します。この構造をパック構造で作成すると、整列アクセスは不可能になります。さらに、アンパックされた構造内の要素にアクセスすると、「不整列例外」が発生する可能性があります。 重要性：高い 例 構造 structSingleDataRecord パックされていますが、アンパックされた構造が含まれています struct4Byte と struct9Byte 。 {attribute 'pack_mode' := '1'} TYPE...", 
"body" : "パック構造で使用されるアンパック構造を決定します。 理由: コンパイラは通常、アンパックされた構造体を、構造体内のすべての要素への整列されたアクセスを許可するアドレスに設定します。この構造をパック構造で作成すると、整列アクセスは不可能になります。さらに、アンパックされた構造内の要素にアクセスすると、「不整列例外」が発生する可能性があります。 重要性：高い 例 構造 structSingleDataRecord パックされていますが、アンパックされた構造が含まれています struct4Byte と struct9Byte 。 {attribute 'pack_mode' := '1'}\nTYPE structSingleDataRecord :\nSTRUCT\n str9ByteData: struct9Byte; (* 9 BYTE *)\n str4ByteData: struct4Byte; (* 4 BYTE *)\n udi1: UDINT;\n udi2: UDINT;\n udi3: UDINT;\n usi4: USINT;\nEND_STRUCT\nEND_TYPE (* 9 BYTE *)\nTYPE struct9Byte :\nSTRUCT\n usiRotorSlots: USINT; (* 1 BYTE *)\n uiMaxCurrent: UINT; (* 2 BYTE *)\n usiVelocity: USINT; (* 1 BYTE *)\n uiAcceleration: UINT; (* 2 BYTE *)\n uiDeceleration: UINT; (* 2 BYTE *)\n usiDirectionChange: USINT; (* 1 BYTE *)\nEND_STRUCT\nEND_TYPE TYPE struct4Byte :\nSTRUCT\n \/\/udiDummy : UDINT;\n rRealDummy : REAL;\nEND_STRUCT\nEND_TYPE での出力 メッセージ ビュー： SA0161: パックされた構造体 'structSingleDataRecord' 内のアンパックされた構造体 'struct9ByteData' の宣言 SA0161: パックされた構造体 'structSingleDataRecord' 内のアンパックされた構造体 'struct4ByteData' の宣言 " }, 
{ "title" : "SA0162：コメントがありません ", 
"url" : "_san_rule_sa0162.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0162：コメントがありません ", 
"snippet" : "プログラム内のコメントされていない位置を決定します。 理論的根拠：多くのプログラミングガイドラインでは完全なコメントが必要であり、コードの可読性と保守性が向上します。 重要度：低 PLCopenルール：C2 コメントが必要です 変数の宣言。コメントはその上または右側にあります。 プログラム、関数ブロック、またはメソッドの宣言。コメントは宣言の上にあります（最初の行）。 例 PROGRAM PLC_PRG VAR iMaxValue: INT; END_VAR での出力 メッセージ ビュー： SA0162: 'PLC_PRG' のコメントがありません SA0162: 「iMaxValue」のコメ...", 
"body" : "プログラム内のコメントされていない位置を決定します。 理論的根拠：多くのプログラミングガイドラインでは完全なコメントが必要であり、コードの可読性と保守性が向上します。 重要度：低 PLCopenルール：C2 コメントが必要です 変数の宣言。コメントはその上または右側にあります。 プログラム、関数ブロック、またはメソッドの宣言。コメントは宣言の上にあります（最初の行）。 例 PROGRAM PLC_PRG\nVAR\n iMaxValue: INT;\nEND_VAR\n での出力 メッセージ ビュー： SA0162: 'PLC_PRG' のコメントがありません SA0162: 「iMaxValue」のコメントがありません " }, 
{ "title" : "SA0163：ネストされたコメント ", 
"url" : "_san_rule_sa0163.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0163：ネストされたコメント ", 
"snippet" : "ネストされたコメントを検出します。 理論的根拠：ネストされたコメントは読みにくいため、避ける必要があります。 重要度：低 PLCopenルール：C3 例 {attribute 'do-analysis'} (* That is (* nested comment 1 *) *) PROGRAM PLC_PRG VAR (* That is \/\/ nested comment 2 comment *) iVal1: INT; iVal2: INT; (* That is (* nested comment 3 *) *) pVal3: POINTER TO DWORD; hugo: INT; E...", 
"body" : "ネストされたコメントを検出します。 理論的根拠：ネストされたコメントは読みにくいため、避ける必要があります。 重要度：低 PLCopenルール：C3 例 {attribute 'do-analysis'}\n(* That is\n(* nested comment 1 *)\n*)\nPROGRAM PLC_PRG\nVAR\n(* That is\n\/\/ nested comment 2\ncomment *)\n iVal1: INT;\n iVal2: INT;\n\n(* That is\n(* nested comment 3 *) *)\n pVal3: POINTER TO DWORD;\n hugo: INT;\nEND_VAR\n (* That is\n\/\/ nested comment 4\ncomment *)\niVal1 := iVal1 + 1;\n(* That is\n(* nested comment 5 *)\n*)\n\n(* Not that one *) での出力 メッセージ ビュー： SA0163: ネストされたコメント 'ネストされたコメント 1' SA0163: ネストされたコメント 'ネストされたコメント 2' SA0163: ネストされたコメント 'ネストされたコメント 3' SA0163: ネストされたコメント 'ネストされたコメント 4' SA0163: ネストされたコメント 'ネストされたコメント 5' " }, 
{ "title" : "SA0164：複数行コメント ", 
"url" : "_san_rule_sa0164.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0164：複数行コメント ", 
"snippet" : "で始まる複数行のコメントを検索します (* comment *) エンコードされます。で始まる単一行のコメントのみが許可されます \/\/ comment エンコードされます。 理論的根拠：一部のプログラミングガイドラインでは、コメントの最初と最後が見えなくなったり、エラーによって終了コメントブラケットが削除されたりする可能性があるため、コード内の複数行コメントを禁止しています。 プラグマで確認できます analysis 宣言部分のコメントに対しても無効にします。 重要度：低 PLCopenルール：C5 例 {attribute 'do-analysis'} (* This is a multi-...", 
"body" : "で始まる複数行のコメントを検索します (* comment *) エンコードされます。で始まる単一行のコメントのみが許可されます \/\/ comment エンコードされます。 理論的根拠：一部のプログラミングガイドラインでは、コメントの最初と最後が見えなくなったり、エラーによって終了コメントブラケットが削除されたりする可能性があるため、コード内の複数行コメントを禁止しています。 プラグマで確認できます analysis 宣言部分のコメントに対しても無効にします。 重要度：低 PLCopenルール：C5 例 {attribute 'do-analysis'}\n(*\n This is a multi-line comment \/\/ SA0164\n*)\nPROGRAM PLC_PRG\nVAR\n\/\/ This is a single line comment\n a: DINT;\nEND_VAR\n (* This is not a single line comment *) \/\/ SA0164\na := a + 1; での出力 メッセージ ビュー： SA0164: 単一行のコメントのみを使用する " }, 
{ "title" : "SA0165：プログラム以外のPOUを呼び出すタスク ", 
"url" : "_san_rule_sa0165.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0165：プログラム以外のPOUを呼び出すタスク ", 
"snippet" : "このチェックは、プログラムの代わりに関数ブロックまたは関数を呼び出すタスクを識別します。 理由：このルールはPLCopenコーディングガイドラインの一部であるため、コンプライアンスも含まれています CODESYS チェックしました。で見る CODESYS タスクがプログラム以外のPOUを呼び出す場合、データの整合性に関する問題はありません。ただし、コードを他のプラットフォームに移植する場合は、問題が発生する可能性があります。 重要度：低 PLCopenルール：CP16 タスクは、タスク構成の下に挿入されます。タスクは、呼び出されるPOUを構成します。 POUはタイプである必要があります プログ...", 
"body" : "このチェックは、プログラムの代わりに関数ブロックまたは関数を呼び出すタスクを識別します。 理由：このルールはPLCopenコーディングガイドラインの一部であるため、コンプライアンスも含まれています CODESYS チェックしました。で見る CODESYS タスクがプログラム以外のPOUを呼び出す場合、データの整合性に関する問題はありません。ただし、コードを他のプラットフォームに移植する場合は、問題が発生する可能性があります。 重要度：低 PLCopenルール：CP16 タスクは、タスク構成の下に挿入されます。タスクは、呼び出されるPOUを構成します。 POUはタイプである必要があります プログラム であること。そいつ 汎用モジュール また 関数 許可されていません。 例 " }, 
{ "title" : "SA0166：input\/output\/in-out変数の最大数 ", 
"url" : "_san_rule_sa0166.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0166：input\/output\/in-out変数の最大数 ", 
"snippet" : "このチェックは、定義された数の入力変数（ VAR_INPUT ）、出力変数（ VAR_OUTPUT ） また VAR_IN_OUT -ブロック内の変数を超えています。のダイアログで最大数を定義します プロジェクト設定 ルールのある行をダブルクリックしたとき。 理由：個々のプログラミングガイドラインを確認することです。多くのプログラミングガイドラインでは、ブロックのパラメータの最大数が規定されています。パラメータが多すぎると、コードが判読できなくなり、ブロックのテストが困難になります。 重要性：中 PLCopenルール：CP23 例 ルール166のプロジェクト設定に VAR_IN_OUT -変数...", 
"body" : "このチェックは、定義された数の入力変数（ VAR_INPUT ）、出力変数（ VAR_OUTPUT ） また VAR_IN_OUT -ブロック内の変数を超えています。のダイアログで最大数を定義します プロジェクト設定 ルールのある行をダブルクリックしたとき。 理由：個々のプログラミングガイドラインを確認することです。多くのプログラミングガイドラインでは、ブロックのパラメータの最大数が規定されています。パラメータが多すぎると、コードが判読できなくなり、ブロックのテストが困難になります。 重要性：中 PLCopenルール：CP23 例 ルール166のプロジェクト設定に VAR_IN_OUT -変数の最大数 1 定義されています。 FUNCTION_BLOCK FB1\nVAR_INPUT\n xIn : BOOL;\nEND_VAR\nVAR_IN_OUT\n xInOut1 : BOOL;\n xInOut2 : BOOL;\nEND_VAR\n での出力 メッセージ ビュー： SA0166: POU 'FB1' の VAR_IN_OUT 変数が多すぎます " }, 
{ "title" : "SA0167：一時的な機能ブロックインスタンス ", 
"url" : "_san_rule_sa0167.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0167：一時的な機能ブロックインスタンス ", 
"snippet" : "このチェックにより、一時変数として宣言されている機能ブロックインスタンスが決定されます。これは、メソッド内、関数内、またはとしてのインスタンスに影響します VAR_TEMP 宣言されているため、各処理サイクルまたは各ブロック呼び出しで再初期化されます。 理由: 機能ブロックには、通常、複数の PLC サイクルにわたって維持される状態があります。スタック上のインスタンスは、関数呼び出しの間のみ存在します。したがって、インスタンスを一時変数として作成することはほとんど意味がありません。 第 2 に、関数ブロック インスタンスは多くの場合大きく、スタック上に多くのスペースを必要とします (通常はコン...", 
"body" : "このチェックにより、一時変数として宣言されている機能ブロックインスタンスが決定されます。これは、メソッド内、関数内、またはとしてのインスタンスに影響します VAR_TEMP 宣言されているため、各処理サイクルまたは各ブロック呼び出しで再初期化されます。 理由: 機能ブロックには、通常、複数の PLC サイクルにわたって維持される状態があります。スタック上のインスタンスは、関数呼び出しの間のみ存在します。したがって、インスタンスを一時変数として作成することはほとんど意味がありません。 第 2 に、関数ブロック インスタンスは多くの場合大きく、スタック上に多くのスペースを必要とします (通常はコントローラーに制限されます)。 第三に、初期化と、多くの場合、機能ブロックのスケジューリングにも時間がかかることがあります。 重要性：中 例 PROGRAM PLC_PRG\nVAR\nEND_VAR\nVAR_TEMP\n yafb: AFB;\nEND_VAR FUNCTION Fun : INT\nVAR_INPUT\nEND_VAR\nVAR\n funafb: AFB;\nEND_VAR\n METHOD METH : INT\nVAR_INPUT\nEND_VAR\nVAR\n methafb: AFB; \/\/ SA0167\nEND_VAR での出力 メッセージ ビュー： SA0167: 一時関数ブロック インスタンス: 'methafb' " }, 
{ "title" : "SA0168：不要な割り当て ", 
"url" : "_san_rule_sa0168.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0168：不要な割り当て ", 
"snippet" : "コードに影響を与えない変数への割り当てを検索します。 理由：割り当て間で変数が評価されることなく、値が変数に複数回割り当てられている場合、最初の割り当てはプログラムに影響を与えません。 重要度：低 例 PROGRAM PLC_PRG VAR dwVal1 : DWORD; dwVal2 : DWORD; END_VAR \/\/ unnecessary assignment dwVal1 := 1; IF dwVal2 > 100 THEN dwVal2 := 0; dwVal2 := dwVal2 + 1; END_IF dwVal1 := 2; での出力 メッセージ ビュー： SA0168: ...", 
"body" : "コードに影響を与えない変数への割り当てを検索します。 理由：割り当て間で変数が評価されることなく、値が変数に複数回割り当てられている場合、最初の割り当てはプログラムに影響を与えません。 重要度：低 例 PROGRAM PLC_PRG\nVAR\n dwVal1 : DWORD;\n dwVal2 : DWORD;\nEND_VAR\n \/\/ unnecessary assignment\ndwVal1 := 1; \nIF dwVal2 > 100 THEN\n dwVal2 := 0;\n dwVal2 := dwVal2 + 1;\nEND_IF\ndwVal1 := 2; での出力 メッセージ ビュー： SA0168: 変数 'dwVal1' が割り当てられていますが、その値は決して使用されません。 " }, 
{ "title" : "SA0169：無視された出口 ", 
"url" : "_san_rule_sa0169.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0169：無視された出口 ", 
"snippet" : "メソッドまたは関数が呼び出されたときに指定されていないメソッドおよび関数の出口を決定します。 理論的根拠：結果が使用されないため、無視された出口は、未処理のエラーまたは無意味な関数呼び出しを示している可能性があります。 重要性：中 例 FUNCTION Fun1 VAR_INPUT bIn : BOOL; VAR_END VAR_OUTPUT bOut : BOOL; END_VA ; PROGRAM PLC_PRG VAR bValue :BOOl; END_VAR Fun1(bIn : TRUE); での出力 メッセージ ビュー： SA0169: 出力 'bOut' は呼び出されたときに無...", 
"body" : "メソッドまたは関数が呼び出されたときに指定されていないメソッドおよび関数の出口を決定します。 理論的根拠：結果が使用されないため、無視された出口は、未処理のエラーまたは無意味な関数呼び出しを示している可能性があります。 重要性：中 例 FUNCTION Fun1\nVAR_INPUT\n bIn : BOOL;\nVAR_END\nVAR_OUTPUT\n bOut : BOOL;\nEND_VA\n ; PROGRAM PLC_PRG\nVAR\n bValue :BOOl;\nEND_VAR\n Fun1(bIn : TRUE);\n での出力 メッセージ ビュー： SA0169: 出力 'bOut' は呼び出されたときに無視されます " }, 
{ "title" : "SA0170: 出力変数のアドレスは使用できません ", 
"url" : "_san_rule_sa0170.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0170: 出力変数のアドレスは使用できません ", 
"snippet" : "出力変数のアドレスが含まれるコードの位置を検出します ( VAR_OUTPUT 、 VAR_IN_OUT ファンクションブロックの）を使用します。 理由: ファンクション ブロック出力のアドレスを次の方法で使用することは許可されていません。 経由 ADR -オペレーター によって REF= 例外: 出力変数が同じ関数ブロック内で使用されている場合、エラーは報告されません。 重要性：中 例 ファンクションブロック FB1 持っています VAR_OUTPUT 変数 iOutVal : INT; 別のブロックで次のアクセスを行うと、エラーSA0170が生成されます。 \/\/FB1_inst is of...", 
"body" : "出力変数のアドレスが含まれるコードの位置を検出します ( VAR_OUTPUT 、 VAR_IN_OUT ファンクションブロックの）を使用します。 理由: ファンクション ブロック出力のアドレスを次の方法で使用することは許可されていません。 経由 ADR -オペレーター によって REF= 例外: 出力変数が同じ関数ブロック内で使用されている場合、エラーは報告されません。 重要性：中 例 ファンクションブロック FB1 持っています VAR_OUTPUT 変数 iOutVal : INT; 別のブロックで次のアクセスを行うと、エラーSA0170が生成されます。 \/\/FB1_inst is of type FB1\naddr1 := ADR(FB1_inst.iOutVal); \/\/SA0170\nrefINT REF= FB1_inst.iOutVal; \/\/SA0179\n 機能ブロック内での後続のアクセス FB1 また、エラーが発生します。 \/\/other is a POINTER TO FB1\nptr := ADR(other^.iOutVal); \/\/SA0170 以下は、機能ブロック内で直接アクセスします。 FB1 エラーは発生しません： \/\/iInputVal is a VAR_INPUT of FB1\niOutVal := iInputVal; \n\/\/ptr is a POINTER TO INT\nptr := ADR(THIS^.iOutVal); \nptr := ADR(iOutVal); での出力 メッセージ ビュー： SA0170: 出力変数のアドレスを受け取るべきではありません " }, 
{ "title" : "SA0171：列挙型には「strict」属性が必要です ", 
"url" : "_san_rule_sa0171.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0171：列挙型には「strict」属性が必要です ", 
"snippet" : "属性と一致しない列挙型の宣言を取得します {attribute 'strict'} 提供されています。 理由：属性 {attribute 'strict'} コードが厳密な列挙プログラミングルールに違反している場合、コンパイラエラーがスローされます。デフォルトでは、新しい列挙を作成するときに、宣言は属性を使用して自動的に作成されます 'strict' 間違い。 詳細については、以下を参照してください。 データ型の列挙 重要性：高い 例 TYPE COLOR : ( red, green, blue ); END_TYPE での出力 メッセージ ビュー： SA0171: 列挙には「strict」...", 
"body" : "属性と一致しない列挙型の宣言を取得します {attribute 'strict'} 提供されています。 理由：属性 {attribute 'strict'} コードが厳密な列挙プログラミングルールに違反している場合、コンパイラエラーがスローされます。デフォルトでは、新しい列挙を作成するときに、宣言は属性を使用して自動的に作成されます 'strict' 間違い。 詳細については、以下を参照してください。 データ型の列挙 重要性：高い 例 TYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE での出力 メッセージ ビュー： SA0171: 列挙には「strict」属性が必要です プログラミング ルールに違反しない: {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE " }, 
{ "title" : "SA0172: 配列の境界外へのアクセス試行の可能性 ", 
"url" : "_san_rule_sa0172.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0172: 配列の境界外へのアクセス試行の可能性 ", 
"snippet" : "配列の境界外の配列インデックスへのアクセスの可能性を検出します。 多くの場合、配列インデックスの範囲を超えます。 FOR インデックス変数を使用して配列インデックスにアクセスするループ。 重要度: 高 例 PROGRAM Test VAR_TEMP iIndex: INT; arUSINT: Array[0..10] OF INT; END_VAR FOR iIndex := INT#0 TO INT#50 DO arUSINT[iIndex] := 0; END_FOR での出力 メッセージ ビュー： SA0172: 配列の境界外へのアクセス試行の可能性...", 
"body" : "配列の境界外の配列インデックスへのアクセスの可能性を検出します。 多くの場合、配列インデックスの範囲を超えます。 FOR インデックス変数を使用して配列インデックスにアクセスするループ。 重要度: 高 例 PROGRAM Test\nVAR_TEMP\n iIndex: INT;\n arUSINT: Array[0..10] OF INT;\nEND_VAR\n FOR iIndex := INT#0 TO INT#50 DO\n arUSINT[iIndex] := 0;\nEND_FOR での出力 メッセージ ビュー： SA0172: 配列の境界外へのアクセス試行の可能性 " }, 
{ "title" : "SA0175: 文字列に対する不審な操作 ", 
"url" : "_san_rule_sa0175.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0175: 文字列に対する不審な操作 ", 
"snippet" : "このルールを常に有効にしないでください。 UTF-8 エンコーディングに変換するときにチェックする必要があるコード内の場所を見つけるために必要な場合にのみ、ルールを有効にします。 プロジェクトオプションかどうかをチェックします STRING の UTF-8 エンコーディング 有効にすることができます。これは、疑わしい操作を含むコードの場所が見つからない場合です。 UTF-8 エンコーディングに切り替えると、最初の 127 文字が ASCII エンコーディングに対応します。ただし、他のすべての文字は複数のバイトでエンコードされます。これにより、文字列を処理する際の動作が変化する可能性があります。...", 
"body" : "このルールを常に有効にしないでください。 UTF-8 エンコーディングに変換するときにチェックする必要があるコード内の場所を見つけるために必要な場合にのみ、ルールを有効にします。 プロジェクトオプションかどうかをチェックします STRING の UTF-8 エンコーディング 有効にすることができます。これは、疑わしい操作を含むコードの場所が見つからない場合です。 UTF-8 エンコーディングに切り替えると、最初の 127 文字が ASCII エンコーディングに対応します。ただし、他のすべての文字は複数のバイトでエンコードされます。これにより、文字列を処理する際の動作が変化する可能性があります。その結果、ASCII 以外の文字を含む文字列リテラルは長くなる可能性があります。または、インデックスによる文字列へのアクセスは、間違った要素にアクセスする可能性があります。最後に、無効なバイト オフセットへのアクセスも発生する可能性があります。 ルールがアクティブな場合、次の構成のいずれかを含むすべてのコードの場所が報告されます。 バイト文字列へのインデックス アクセス 例： str[2] メッセージ： SA0175: 属性 'strict' の列挙: 文字列に対する不審な操作: インデックス アクセス '<式>' 半角文字列へのアドレスアクセス 例： ADR(str) メッセージ： SA0175:属性 'strict' の列挙: 文字列に対する不審な操作: インデックス アクセス '<式>' の可能性があります の文字列関数の呼び出し Standard ライブラリ、呼び出し時を除く CONCAT と LEN 機能 メッセージ： SA0175:属性 'strict' の列挙: 文字列に対する不審な操作: インデックス アクセス '<式>' の可能性があります 非 ASCII 文字を含むバイト リテラル 例: str := '99€';\nstr :='Ä'; メッセージ： SA0175: 文字列に対する不審な操作: リテラル '<literal>' に非 ASCII 文字が含まれています " }, 
{ "title" : "SA0180: インデックス範囲が配列全体をカバーしていません ", 
"url" : "_san_rule_sa0180.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ ルール \/ SA0180: インデックス範囲が配列全体をカバーしていません ", 
"snippet" : "インデックス範囲が不完全にカバーされている配列を検出します 配列はループ内で処理されることが多く、ループ インデックスによって配列にインデックスが付けられるため、配列のすべてのコンポーネントが隙間なくジャンプされます。これは、ループ インデックスと配列インデックスがすべての次元で同じである場合に与えられます。インデックス範囲が配列を完全にカバーしていない場合、これは配列内の未処理のコンポーネントを示します。 重要度: 中 例 {attribute 'do-analysis'} PROGRAM PLC_PRG VAR a : INT; arWord : ARRAY [0..100] OF WOR...", 
"body" : "インデックス範囲が不完全にカバーされている配列を検出します 配列はループ内で処理されることが多く、ループ インデックスによって配列にインデックスが付けられるため、配列のすべてのコンポーネントが隙間なくジャンプされます。これは、ループ インデックスと配列インデックスがすべての次元で同じである場合に与えられます。インデックス範囲が配列を完全にカバーしていない場合、これは配列内の未処理のコンポーネントを示します。 重要度: 中 例 {attribute 'do-analysis'}\nPROGRAM PLC_PRG\nVAR\n a : INT;\n arWord : ARRAY [0..100] OF WORD;\nEND_VAR\n\/\/Implementation\nFOR a := INT#1 TO INT#100 BY 1 DO \/\/SA0180: Lower range is not reached\n\tarWord[a] := INT_TO_WORD(a);\nEND_FOR;\n;\n での出力 メッセージ ビュー： SA0180: インデックス範囲が配列全体をカバーしていません " }, 
{ "title" : "メトリクス ", 
"url" : "_san_reference_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス ", 
"snippet" : "提供されるメトリクスの詳細な説明 CODESYS Static Analysis の コードサイズ 、 可変サイズ 、 スタックサイズ 、 そして コール数 メトリクスは、プロジェクトに統合されているライブラリからの POU についてのみレポートされます。...", 
"body" : "提供されるメトリクスの詳細な説明 CODESYS Static Analysis の コードサイズ 、 可変サイズ 、 スタックサイズ 、 そして コール数 メトリクスは、プロジェクトに統合されているライブラリからの POU についてのみレポートされます。 " }, 
{ "title" : "メトリクス: コードサイズ (バイト数) ", 
"url" : "_san_reference_metrics.html#UUID-35adc4d5-9253-44d6-f130-aab7171bff69", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ メトリクス: コードサイズ (バイト数) ", 
"snippet" : "コードサイズ（バイト数） カテゴリ: 有益、効率 ファンクション ブロックがアプリケーション コードに寄与するバイト数 この数はコード ジェネレーターによっても異なります。たとえば、ARM プロセッサ用のコード ジェネレータは通常、x86 プロセッサ用のコード ジェネレータよりも多くのバイトを生成します。...", 
"body" : "コードサイズ（バイト数） カテゴリ: 有益、効率 ファンクション ブロックがアプリケーション コードに寄与するバイト数 この数はコード ジェネレーターによっても異なります。たとえば、ARM プロセッサ用のコード ジェネレータは通常、x86 プロセッサ用のコード ジェネレータよりも多くのバイトを生成します。 " }, 
{ "title" : "メトリック: 可変サイズ (バイト数) ", 
"url" : "_san_reference_metrics.html#UUID-b07882e2-be28-fe1e-eb10-ed5defcf3c74", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ メトリック: 可変サイズ (バイト数) ", 
"snippet" : "変数サイズ（バイト数） カテゴリー : 有益、効率化 オブジェクトが使用する静的メモリのサイズ 関数ブロックの場合、これは関数ブロックのインスタンスに使用されるサイズです (メモリ アライメントに応じて、メモリ ギャップが含まれる場合があります)。プログラム、関数、およびグローバル変数リストの場合、これはすべての静的変数のサイズの合計です。 例 FUNCTION FUN1 : INT VAR_INPUT a,b : INT; END_VAR VAR c,d : INT; END_VAR VAR_STAT f,g,h : INT; END_VAR この関数には次の型の 3 つの静的変数があります...", 
"body" : "変数サイズ（バイト数） カテゴリー : 有益、効率化 オブジェクトが使用する静的メモリのサイズ 関数ブロックの場合、これは関数ブロックのインスタンスに使用されるサイズです (メモリ アライメントに応じて、メモリ ギャップが含まれる場合があります)。プログラム、関数、およびグローバル変数リストの場合、これはすべての静的変数のサイズの合計です。 例 FUNCTION FUN1 : INT\nVAR_INPUT\n a,b : INT;\nEND_VAR\nVAR\n c,d : INT;\nEND_VAR\nVAR_STAT\n f,g,h : INT;\nEND_VAR この関数には次の型の 3 つの静的変数があります。 INT (f 、 g 、 そして h )、それぞれに 2 バイトのメモリが必要です。結果として、 FUN1 可変サイズは 6 バイトです。 " }, 
{ "title" : "メトリック: スタック サイズ (バイト数) ", 
"url" : "_san_reference_metrics.html#UUID-52e032c0-e190-f5c0-344b-e6c04694a3ef", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ メトリック: スタック サイズ (バイト数) ", 
"snippet" : "スタックサイズ（バイト数） カテゴリー : 有益、効率、信頼性 関数または関数ブロックの呼び出しに必要なバイト数 入力変数と出力変数はメモリに合わせて配置されます。これにより、これらの変数とローカル変数の間にギャップが生じる可能性があります。このギャップがカウントされます。 呼び出された関数の戻り値がレジスタに収まらない場合は、スタックにプッシュされます。これらの値の最大値によって追加の割り当てメモリが決まり、これもカウントされます。検討中の POU 内で呼び出される関数または関数ブロックには、独自のスタック フレームがあります。したがって、そのような呼び出しのためのメモリはカウントされません...", 
"body" : "スタックサイズ（バイト数） カテゴリー : 有益、効率、信頼性 関数または関数ブロックの呼び出しに必要なバイト数 入力変数と出力変数はメモリに合わせて配置されます。これにより、これらの変数とローカル変数の間にギャップが生じる可能性があります。このギャップがカウントされます。 呼び出された関数の戻り値がレジスタに収まらない場合は、スタックにプッシュされます。これらの値の最大値によって追加の割り当てメモリが決まり、これもカウントされます。検討中の POU 内で呼び出される関数または関数ブロックには、独自のスタック フレームがあります。したがって、そのような呼び出しのためのメモリはカウントされません。 使用するコード ジェネレーターによっては、計算の中間結果でもスタックが使用されます。これらの結果はカウントされません。 例 \/\/Declaration\nFUNCTION FUN1 : INT\nVAR_INPUT\n a,b : INT;\nEND_VAR\nVAR\n c,d,e : INT;\nEND_VAR\nVAR_STAT\n f,g,h : INT;\nEND_VAR\n\n\/\/Implementation\nc := b;\nd := a;\ne := a+b; 仮定: 計算のために、次のことを仮定します。 CODESYS Control Win x86 コードジェネレーターを使用します。 上の例の呼び出し元のサイズは 8 バイトです。つまり、2 つの呼び出し元のサイズは 4 バイトです。 INT inputs 戻り値用の 4 バイト。デバイスのスタック アライメントは 4 バイトであるため、2 バイトのギャップがあります。呼び出し元のサイズは 8 バイトです。それぞれ 2 バイトの 3 つのローカル変数に、スタック アライメント用の 2 バイトのギャップを加えたものです。その結果、スタックの合計サイズは、 FUN1 は 16 バイトです。 VAR_STAT スタックに格納されないため、POU のスタック サイズは増加しません。 " }, 
{ "title" : "メトリクス: コール数 (コール) ", 
"url" : "_san_reference_metrics.html#UUID-652fc3dc-10b7-711b-cea7-9b006e6249b5", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ メトリクス: コール数 (コール) ", 
"snippet" : "通話数（通話） カテゴリー : 有益な情報 POU のコール数 プログラムユニット 例 \/\/Declaration PLC_PRG PROGRAM PLC_PRG VAR myFB : FB1; END_VAR \/\/Implementation myFB(b := FALSE); \/\/Declaration FB1 FUNCTION_BLOCK FB1 VAR_INPUT b : BOOL; END_VAR VAR i : INT; END_VAR \/\/Implementation METH(i); IF b THEN METH(i*i); END_IF \/\/Declaration FB1.M...", 
"body" : "通話数（通話） カテゴリー : 有益な情報 POU のコール数 プログラムユニット 例 \/\/Declaration PLC_PRG\nPROGRAM PLC_PRG\nVAR\n myFB : FB1;\nEND_VAR\n\n\/\/Implementation\nmyFB(b := FALSE); \/\/Declaration FB1\nFUNCTION_BLOCK FB1\nVAR_INPUT\n b : BOOL;\nEND_VAR\nVAR\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH(i);\nIF b THEN\n METH(i*i);\nEND_IF\n \/\/Declaration FB1.METH\nMETHOD METH : BOOL\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH := i >= 42; もし PLC_PRG タスク内で呼び出された場合、この呼び出しもカウントされます。 FB1 呼び出しが 1 つだけあります ( PLC_PRG ）。 METH 2 つの呼び出しがあり、両方とも FB1 。 " }, 
{ "title" : "メトリック: タスクからの呼び出し数 (タスク) ", 
"url" : "_san_reference_metrics.html#UUID-3768e9b9-fdef-e8c5-d81a-3ab94c3eed82", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ メトリック: タスクからの呼び出し数 (タスク) ", 
"snippet" : "タスクからの呼び出し数（タスク） カテゴリー ：保守性、信頼性 タスクの数 ( タスク ) ここで、POU は以下で指定されます。 プログラムユニット と呼ばれます ファンクション ブロックの場合、ファンクション ブロック自体、またはファンクション ブロックの継承ツリー内の任意のファンクション ブロックが呼び出されるタスクの数がカウントされます。 メソッドとアクションの場合、(親) ファンクション ブロックが呼び出されるタスクの数が表示されます。 例 FUNCTION_BLOCK FB \/\/... FUNCTION_BLOCK FB2 EXTENDS FB \/\/... FUNCTION_BLO...", 
"body" : "タスクからの呼び出し数（タスク） カテゴリー ：保守性、信頼性 タスクの数 ( タスク ) ここで、POU は以下で指定されます。 プログラムユニット と呼ばれます ファンクション ブロックの場合、ファンクション ブロック自体、またはファンクション ブロックの継承ツリー内の任意のファンクション ブロックが呼び出されるタスクの数がカウントされます。 メソッドとアクションの場合、(親) ファンクション ブロックが呼び出されるタスクの数が表示されます。 例 FUNCTION_BLOCK FB\n\/\/... FUNCTION_BLOCK FB2 EXTENDS FB\n\/\/... FUNCTION_BLOCK FB3 EXTENDS FB2\n\/\/... 各関数ブロックは独自に呼び出されます。 PROGRAM 。それぞれ PROGRAM には独自のタスクがあります。 の タスクで呼び出される メトリクスは 1 を返します FB3 と2 FB2 なぜなら、からの電話は FB3 そして FB2 カウントされます。メトリクスの結果は 3 になります。 FB この場合、からの呼び出しは FB3 、 FB2 、 そして FB カウントされます。 " }, 
{ "title" : "メトリック: 使用されるグローバル変数の数 (グローバル) ", 
"url" : "_san_reference_metrics.html#UUID-04068c53-4046-0979-468b-866b1a155a8a", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ メトリック: 使用されるグローバル変数の数 (グローバル) ", 
"snippet" : "使用されるグローバル変数の数 (Globals) カテゴリー : 保守性、再利用性 POU で使用されているグローバル変数の数 プログラムユニット 例 \/\/GVL VAR_GLOBAL gvla : INT; gvlb : INT; gvlc : INT; END_VAR \/PRG declaration PROGRAM PRG VAR x : INT := GVL.gvlc; y : INT; END_VAR \/\/PRG implementation x := GVL.gvla; y := GVL.gvla*GVL.gvlb; の PRG プログラムは次の 3 つの変数を使用します GVL ...", 
"body" : "使用されるグローバル変数の数 (Globals) カテゴリー : 保守性、再利用性 POU で使用されているグローバル変数の数 プログラムユニット 例 \/\/GVL\nVAR_GLOBAL\n gvla : INT;\n gvlb : INT;\n gvlc : INT;\nEND_VAR \/PRG declaration\nPROGRAM PRG\nVAR\n x : INT := GVL.gvlc;\n y : INT;\nEND_VAR\n\n\/\/PRG implementation\nx := GVL.gvla;\ny := GVL.gvla*GVL.gvlb; の PRG プログラムは次の 3 つの変数を使用します GVL : gvla 、 gvlb 、 そして gvlc 。 " }, 
{ "title" : "メトリクス: ダイレクト アドレス アクセス (IO) の数 ", 
"url" : "_san_reference_metrics.html#UUID-792a6162-1022-f930-dadb-104aa5a51709", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ メトリクス: ダイレクト アドレス アクセス (IO) の数 ", 
"snippet" : "ダイレクト アドレス アクセス (IO) の数 カテゴリー : 再利用性、保守性 ダイレクトアドレスアクセス数（ IO ) オブジェクトの実装で。 例 \/\/Declaration PROGRAM PRG VAR xVar : BOOL:= %IX0.0; \/\/ +1 direct address access byVar : BYTE; END_VAR \/\/Implementation xVar := %IX0.0; \/\/ +1 direct address access %QX0.0 := xVar; \/\/ +1 %MX0.1 := xVar; \/\/ +1 %MB1 := byVar; \/\/...", 
"body" : "ダイレクト アドレス アクセス (IO) の数 カテゴリー : 再利用性、保守性 ダイレクトアドレスアクセス数（ IO ) オブジェクトの実装で。 例 \/\/Declaration\nPROGRAM PRG\nVAR\n xVar : BOOL:= %IX0.0; \/\/ +1 direct address access\n byVar : BYTE;\nEND_VAR\n\n\/\/Implementation\nxVar := %IX0.0; \/\/ +1 direct address access\n%QX0.0 := xVar; \/\/ +1\n%MX0.1 := xVar; \/\/ +1\n%MB1 := byVar; \/\/ +1 この例には 5 つの直接アドレス アクセスがあります。 " }, 
{ "title" : "メトリック: ローカル変数の数 (ローカル) ", 
"url" : "_san_reference_metrics.html#UUID-f738f257-cf3a-1e7c-979e-1d6b4733c2d9", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ メトリック: ローカル変数の数 (ローカル) ", 
"snippet" : "ローカル変数の数 (ローカル) カテゴリー : 有益、効率化 で宣言された変数の数 VAR POU の領域。継承された変数はカウントされません。 例 \/\/Declaration FUNCTION_BLOCK FB VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR i,j,k,l : INT; m,n,o : BOOL; END_VAR ファンクションブロック内では7つのローカル変数が宣言されています。...", 
"body" : "ローカル変数の数 (ローカル) カテゴリー : 有益、効率化 で宣言された変数の数 VAR POU の領域。継承された変数はカウントされません。 例 \/\/Declaration\nFUNCTION_BLOCK FB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i,j,k,l : INT;\n m,n,o : BOOL;\nEND_VAR\n ファンクションブロック内では7つのローカル変数が宣言されています。 " }, 
{ "title" : "メトリクス: 入力変数 (Input) の数 ", 
"url" : "_san_reference_metrics.html#UUID-03e01655-9ac0-74f4-3fd7-cf22f23db4f6", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ メトリクス: 入力変数 (Input) の数 ", 
"snippet" : "入力変数の数 (Input) カテゴリー : 保守性、再利用性 対応するデフォルトの上限 SA0166 ルール: 10 で宣言された変数の数 VAR_INPUT プログラム単位の。継承された入力変数はカウントされません。 例 FUNCTION_BLOCK FB VAR_INPUT i : INT; r : REAL; END_VAR 関数ブロックでは、2 つの入力変数が宣言されています。 i そして r 。 METHOD METH : BOOL VAR_INPUT j : INT; l : LREAL; END_VAR このメソッドには 2 つの入力があります。 j そして l...", 
"body" : "入力変数の数 (Input) カテゴリー : 保守性、再利用性 対応するデフォルトの上限 SA0166 ルール: 10 で宣言された変数の数 VAR_INPUT プログラム単位の。継承された入力変数はカウントされません。 例 FUNCTION_BLOCK FB\nVAR_INPUT\n i : INT;\n r : REAL;\nEND_VAR\n 関数ブロックでは、2 つの入力変数が宣言されています。 i そして r 。 METHOD METH : BOOL\nVAR_INPUT\n j : INT;\n l : LREAL;\nEND_VAR\n このメソッドには 2 つの入力があります。 j そして l " }, 
{ "title" : "メトリック: 出力変数の数 (出力) ", 
"url" : "_san_reference_metrics.html#UUID-7bba3bc6-748c-311d-7f8c-4878fdce9da0", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ メトリック: 出力変数の数 (出力) ", 
"snippet" : "出力変数の数 (出力) カテゴリー : 保守性、再利用性 対応するデフォルトの上限 SA0166 ルール: 10 変数の数 VAR_OUTPUT プログラム単位の ファンクション ブロックの場合、これはカスタム出力変数の数です ( VAR_OUTPUT ）。メソッドと関数の場合、これはカスタム出力変数の数に戻り値がある場合は 1 を加えたものになります。戻り値もカウントされます。継承された出力変数はカウントされません。 出力変数の数が多い場合は、一意の責任の原則に違反していることを示します。 例 FUNCTION_BLOCK FB VAR_OUTPUT i : INT; \/\/ +1 outpu...", 
"body" : "出力変数の数 (出力) カテゴリー : 保守性、再利用性 対応するデフォルトの上限 SA0166 ルール: 10 変数の数 VAR_OUTPUT プログラム単位の ファンクション ブロックの場合、これはカスタム出力変数の数です ( VAR_OUTPUT ）。メソッドと関数の場合、これはカスタム出力変数の数に戻り値がある場合は 1 を加えたものになります。戻り値もカウントされます。継承された出力変数はカウントされません。 出力変数の数が多い場合は、一意の責任の原則に違反していることを示します。 例 FUNCTION_BLOCK FB\nVAR_OUTPUT\n i : INT; \/\/ +1 output\n r : REAL; \/\/ +1 output\nEND_VAR 関数ブロックには 2 つの出力変数があります。 i そして r METHOD METH : BOOL\nVAR_INPUT\n j : INT;\n l : LREAL;\nEND_VAR このメソッドには 3 つの出力があります。 METH 、 j 、 そして l METHOD METH1 \/\/ +0 outputs (no return type)\nVAR_OUTPUT\n ar : ARRAY[0..10] OF INT; \/\/ +1 output\n l : LREAL; \/\/ +1 output\nEND_VAR の METH1 メソッドには 2 つの出力があります。 ar そして i " }, 
{ "title" : "メトリック: NOS – ステートメントの数 ", 
"url" : "_san_reference_metrics.html#UUID-82054fe5-816d-0c12-0afa-11dabf2c47b3", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ メトリック: NOS – ステートメントの数 ", 
"snippet" : "NOS – ステートメントの数 カテゴリー : 有益な情報 ファンクションブロック、関数、またはメソッドの実装におけるステートメントの数 宣言内のステートメント、空のステートメント、またはプラグマはカウントされません。 例 \/\/Declaration: FUNCTION POU : BOOL VAR_INPUT END_VAR VAR c : INT := 100; \/\/ statements in the declaration are not counted END_VAR VAR_OUTPUT test : INT; i : INT; END_VAR \/\/Implementation: ...", 
"body" : "NOS – ステートメントの数 カテゴリー : 有益な情報 ファンクションブロック、関数、またはメソッドの実装におけるステートメントの数 宣言内のステートメント、空のステートメント、またはプラグマはカウントされません。 例 \/\/Declaration:\nFUNCTION POU : BOOL\nVAR_INPUT\nEND_VAR\nVAR\n c : INT := 100; \/\/ statements in the declaration are not counted\nEND_VAR\nVAR_OUTPUT\n test : INT;\n i : INT;\nEND_VAR\n\n\/\/Implementation:\nIF TRUE THEN \/\/if statement: +1\n test := 0; \/\/ +1\nEND_IF\n\nWHILE test = 1 DO \/\/while statement: +1\n ; \/\/ empty statements do not add to the statement count\nEND_WHILE\n\nFOR c := 0 TO 10 BY 2 DO \/\/for statement: +1\n i := i+i; \/\/ +1\nEND_FOR\n\n{text 'simple text pragma'} \/\/pragmas are not counted\ntest := 2; \/\/+1 この例には 6 つのステートメントがあります。 " }, 
{ "title" : "指標: コメントの割合 ", 
"url" : "_san_reference_metrics.html#UUID-abd88d31-c33e-db93-0f69-bec1a38795f7", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ 指標: コメントの割合 ", 
"snippet" : "コメントの割合 カテゴリー : メンテナンス性 ソースコード内のコメントの割合 この数値は次の式に従って計算されます。 パーセンテージ = 100 * <コメント内の文字数> \/ <ソース コード内の文字数とコメント内の文字数の合計> ソース コード内の複数の連続したスペースは 1 つのスペースとしてカウントされるため、インデントされたソース コードの重み付けが高くなります。空のオブジェクト (ソース コードもコメントもなし) の場合は、0 のパーセンテージが返されます。 例 宣言部分: FUNCTION_BLOCK FB \/\/comments in the declaration are c...", 
"body" : "コメントの割合 カテゴリー : メンテナンス性 ソースコード内のコメントの割合 この数値は次の式に従って計算されます。 パーセンテージ = 100 * <コメント内の文字数> \/ <ソース コード内の文字数とコメント内の文字数の合計> ソース コード内の複数の連続したスペースは 1 つのスペースとしてカウントされるため、インデントされたソース コードの重み付けが高くなります。空のオブジェクト (ソース コードもコメントもなし) の場合は、0 のパーセンテージが返されます。 例 宣言部分: FUNCTION_BLOCK FB \/\/comments in the declaration are counted, as well\nVAR_TEMP\n hugo : INT;\nEND_VAR 実装： hugo := hugo + 1;\n\/\/Declaration: 40 letters non comment; 50 letters comment\n\/\/Implementation: 13 letters non comment; 152 letters comment\n\/\/ 100 * 202 \/ 255 -> 79% comments パーセンテージ 100 * 202 \/ 255 を計算すると、79% が返されます。 " }, 
{ "title" : "指標: 複雑さ (McCabe) ", 
"url" : "_san_reference_metrics.html#UUID-ea21160c-97be-30d4-7748-0adac68532a8", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ 指標: 複雑さ (McCabe) ", 
"snippet" : "複雑さ (マッケイブ) カテゴリー : テスト容易性 推奨上限：10 McCabe 氏によると、循環的複雑さはソース コードの読みやすさとテストしやすさの尺度です。これは、POU の制御フロー内のバイナリ分岐の数をカウントすることによって計算されます。ただし、分岐が多いとテスト カバレッジを高めるために必要なテスト ケースの数が増加するため、循環的な複雑さによって分岐が多くなると不利になります。 例： IF 声明 \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch IF b...", 
"body" : "複雑さ (マッケイブ) カテゴリー : テスト容易性 推奨上限：10 McCabe 氏によると、循環的複雑さはソース コードの読みやすさとテストしやすさの尺度です。これは、POU の制御フロー内のバイナリ分岐の数をカウントすることによって計算されます。ただし、分岐が多いとテスト カバレッジを高めるために必要なテスト ケースの数が増加するため、循環的な複雑さによって分岐が多くなると不利になります。 例： IF 声明 \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nIF b1 THEN \/\/ +1 for the THEN branch\n ;\n ELSIF b2 THEN \/\/ +1 for the THEN branch of the IF inside the else\n ;\nELSE \n IF b3 OR b4 THEN \/\/ +1 for the THEN branch\n ;\n END_IF\nEND_IF コード スニペットの循環複雑度は 4 です。 例： CASE 声明 \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nCASE a OF\n 1:\t; \/\/ +1\n 2:\t; \/\/ +1\n 3,4,5:\t; \/\/ +1\nELSE \/\/ the ELSE statement does not increase the cyclomatic complexity\n ;\nEND_CASE コード スニペットの循環複雑度は 4 です。 例: ループステートメント \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nWHILE b1 DO \/\/ +1 for the WHILE loop\n ;\nEND_WHILE\n\nREPEAT \/\/ +1 for the REPEAT loop\n ;\n UNTIL b2\nEND_REPEAT\n\nFOR a := 0 TO 100 BY 2 DO \/\/ +1 for the REPEAT loop\n ;\nEND_FOR コード スニペットの循環複雑度は 4 です。 例: その他のステートメント 次のステートメントも循環的複雑さを増大させます。 \/\/Declaration\nFUNCTION FUN : STRING\nVAR_INPUT\n condition_return : BOOL;\n condition_jmp : BOOL;\nEND_VAR\nVAR\nEND_VAR\n\n\/\/Implementation\n\/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nJMP(condition_jmp) lbl; \/\/Conditional jumps increase the cyclomatic complexity by 1\n\nFUN := 'u';\nRETURN(condition_return); \/\/Conditional returns increase the cyclomatic complexity by 1, too\n\nlbl:\nFUN := 't';\n コード スニペットの循環複雑度は 3 です。 " }, 
{ "title" : "指標: 認知の複雑さ ", 
"url" : "_san_reference_metrics.html#UUID-cd064f18-bd35-1d86-1bd4-2ae3a8fe344f", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ 指標: 認知の複雑さ ", 
"snippet" : "認知の複雑さ カテゴリー : メンテナンス性 対応する SA0178 ルールのデフォルトの上限: 20 認知的複雑さは、2016 年に Sonarsource™ によって導入されたソース コードの読みやすさと理解しやすさの尺度です。ただし、制御フローの大量のネストや複雑なブール式にはペナルティが課せられます。認知の複雑さは、構造化テキストの実装についてのみ計算されます。 次の例は、認知の複雑性がどのように計算されるかを示しています。 の 現在のエディターの認知的複雑性を表示 コマンドを使用すると、構造化テキストの増分をさらに表示できます。 例: 制御フロー 制御フローを操作するステートメントは...", 
"body" : "認知の複雑さ カテゴリー : メンテナンス性 対応する SA0178 ルールのデフォルトの上限: 20 認知的複雑さは、2016 年に Sonarsource™ によって導入されたソース コードの読みやすさと理解しやすさの尺度です。ただし、制御フローの大量のネストや複雑なブール式にはペナルティが課せられます。認知の複雑さは、構造化テキストの実装についてのみ計算されます。 次の例は、認知の複雑性がどのように計算されるかを示しています。 の 現在のエディターの認知的複雑性を表示 コマンドを使用すると、構造化テキストの増分をさらに表示できます。 例: 制御フロー 制御フローを操作するステートメントは認知の複雑さを 1 増加させます IF TRUE THEN \/\/ +1 cognitive complexity\n ;\nEND_IF\n\nWHILE TRUE DO \/\/+1 cognitive complexity\n ;\nEND_WHILE\n\nFOR i := 0 TO 10 BY 1 DO \/\/+1 cognitive complexity\n ;\nEND_FOR\n\nREPEAT \/\/+1 cognitive complexity\n ;\nUNTIL TRUE\nEND_REPEAT コード スニペットの認知複雑度は 4 です。 例: 制御フローのネスト 制御フローをネストする場合、ネストのレベルごとに 1 ずつ追加されます。 IF TRUE THEN \/\/+1 cognitive complexity\n WHILE TRUE DO \/\/+2 (+1 for the loop itself, +1 for the nesting inside the IF)\n FOR i := 0 TO 10 BY 1 DO \/\/+3 (+1 for the FOR loop itself, +2 for the nesting inside the WHILE and the IF)\n\t\t\t;\n END_FOR\n END_WHILE\n\n REPEAT \/\/+2 (+1 for the loop itself, +1 for the nesting inside the IF)\n ;\n UNTIL TRUE\n END_REPEAT\nEND_IF コード スニペットの認知複雑度は 8 です。 例: ブール式 ブール式はソース コードを理解する上で重要な役割を果たすため、認知の複雑さを計算するときにも考慮されます。 同じブール演算子に関連付けられたブール式を理解することは、交互のブール演算子を含むブール式を理解することほど難しくありません。したがって、式内に同一のブール演算子が連鎖すると、認知の複雑さが増大します。 b := b1; \/\/+0: a simple expression, containing no operators, has no increment\n 演算子のない単純な式の増分は 0 です。 b := b1 AND b2; \/\/+1: one chain of AND operators を使った表現は、 AND リンクの増分は 1 です。 b := b1 AND b2 AND b3; \/\/+1: one more AND, but the number of chains of operators does not change この式にはもう 1 つあります AND 。ただし、同じ演算子であるため、同じ演算子で形成されるチェーンの数は変わりません。 b := b1 AND b2 OR b3; \/\/+2: one chain of AND operators and one chain of OR operators 式には次のような連鎖があります。 AND 演算子と一連の OR オペレーター。これにより、増分は 2 になります。 b := b1 AND b2 OR b3 AND b4 AND b5; \/\/+3 コード スニペットの増分は 3 です。 b := b1 AND NOT b2 AND b3; \/\/+1: the unary NOT operator is not considered in the cognitive complexity 単項演算子 NOT 認知の複雑さでは考慮されていません。 例: インクリメントのあるその他のステートメント 構造化テキストには、制御フローを変更する追加のステートメントと式があります。 次のステートメントには、認知の複雑さが増すというペナルティが課されます。 aNewLabel:\nx := MUX(i, a,b,c); \/\/+1 for MUX operator\ny := SEL(b, i,j); \/\/+1 for SEL operator\nJMP aNewLabel; \/\/+1 for JMP to label EXIT そして RETURN ステートメントは認知の複雑さを増加させません。 " }, 
{ "title" : "メトリック: DIT – 継承ツリーの深さ ", 
"url" : "_san_reference_metrics.html#UUID-c7e1c296-e321-f999-8ed7-9713ebdb50fc", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ メトリック: DIT – 継承ツリーの深さ ", 
"snippet" : "DIT – 継承ツリーの深さ カテゴリー : メンテナンス性 他の機能ブロックを拡張しない機能ブロックに到達するまでの継承の数 例 FUNCTION_BLOCK MyBaseFB \/\/ ... FUNCTION_BLOCK AChildFB EXTENDS MyBaseFB \/\/ ... FUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB \/\/ ... MyBaseFB は、それ自体が他の機能ブロックを拡張しない機能ブロックであるため、DIT は 0 です。 のために AChildFB に到達するには 1 つのステップが必要であるため、DIT は 1 で...", 
"body" : "DIT – 継承ツリーの深さ カテゴリー : メンテナンス性 他の機能ブロックを拡張しない機能ブロックに到達するまでの継承の数 例 FUNCTION_BLOCK MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AChildFB EXTENDS MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB\n\/\/ ... MyBaseFB は、それ自体が他の機能ブロックを拡張しない機能ブロックであるため、DIT は 0 です。 のために AChildFB に到達するには 1 つのステップが必要であるため、DIT は 1 です。 MyBaseFB 。 AGrandChildFB DIT は 2 です。次の手順が 1 つ必要です。 AChildFB そしてもう一つは MyBaseFB 。 " }, 
{ "title" : "指標: NOC – 子供の数 ", 
"url" : "_san_reference_metrics.html#UUID-04314eaf-28e7-40ea-0aa9-e7f46e79bfa0", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ 指標: NOC – 子供の数 ", 
"snippet" : "NOC – 子供の数 カテゴリー : 再利用性、保守性 指定された基本機能ブロックを拡張する機能ブロックの数。基本機能ブロックを間接的に拡張する機能ブロックはカウントされません。 例 FUNCTION_BLOCK MyBaseFB \/\/ ... FUNCTION_BLOCK AChildFB EXTENDS MyBaseFB \/\/ ... FUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB \/\/ ... MyBaseFB 子オブジェクトは 1 つだけあります: AChildFB 、これには 1 つの子オブジェクトがあり、 AGrandChildFB 。 ...", 
"body" : "NOC – 子供の数 カテゴリー : 再利用性、保守性 指定された基本機能ブロックを拡張する機能ブロックの数。基本機能ブロックを間接的に拡張する機能ブロックはカウントされません。 例 FUNCTION_BLOCK MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AChildFB EXTENDS MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB\n\/\/ ... MyBaseFB 子オブジェクトは 1 つだけあります: AChildFB 、これには 1 つの子オブジェクトがあり、 AGrandChildFB 。 AGrandChildFB には子オブジェクトがありません。 " }, 
{ "title" : "メトリック: RFC – クラスの応答 ", 
"url" : "_san_reference_metrics.html#UUID-0fcfc138-e361-a392-6fbe-11240e7a6e2a", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ メトリック: RFC – クラスの応答 ", 
"snippet" : "クラスの応答 (RFC) カテゴリー : 保守性、再利用性 呼び出されて、以下で指定された POU の応答を生成するさまざまな POU、メソッド、またはアクションの数。 プログラムユニット 例 \/\/Declaration FB1 FUNCTION_BLOCK FB1 VAR d,x,y : INT; END_VAR \/\/Implementation x := METH(d+10); y := FUN(42, 0.815); \/\/Declaration FB1.METH METHOD METH : INT VAR_INPUT i : INT; END_VAR \/\/Implementation M...", 
"body" : "クラスの応答 (RFC) カテゴリー : 保守性、再利用性 呼び出されて、以下で指定された POU の応答を生成するさまざまな POU、メソッド、またはアクションの数。 プログラムユニット 例 \/\/Declaration FB1\nFUNCTION_BLOCK FB1\nVAR\n d,x,y : INT;\nEND_VAR\n\n\/\/Implementation\nx := METH(d+10);\ny := FUN(42, 0.815); \/\/Declaration FB1.METH\nMETHOD METH : INT\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH := FUN(CUBE(i), 3.1415); \/\/Declaration CUBE\nFUNCTION CUBE : INT\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nCUBE := i*i*i; \/\/Declaration Function FUN\nFUNCTION FUN : INT\nVAR_INPUT\n a : INT;\n lr : LREAL;\nEND_VAR\n\n\/\/Implementation\nFUN := LREAL_TO_INT(lr*10)*a; で始まります FUN そして CUBE 、これらの関数は計算のために他の関数、関数ブロック、またはメソッドを呼び出していないため、RFC は 0 です。 FB1.METH 用途 FUN そして CUBE 、その結果、RFC は 2 になります。 ファンクションブロック FB1 それ自体が呼び出します METH そして FUN 、これにより RFC が 2 増加します。 FB1 の場合、その METH メソッドも考慮する必要があります。 METH は FUN と CUBE を使用します。 FUN はすでに RFC に追加されています。したがって、METH で CUBE を使用する場合のみ、FB1 の RFC が 3 に増加します。 " }, 
{ "title" : "メトリック: CBO – オブジェクト間の結合 ", 
"url" : "_san_reference_metrics.html#UUID-d98bd2a3-497b-920f-1f11-f4f38973066f", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ メトリック: CBO – オブジェクト間の結合 ", 
"snippet" : "CBO – オブジェクト間の結合 カテゴリー : 保守性、再利用性 対応する SA0179 ルールのデフォルトの上限: 30 インスタンス化され、ファンクション ブロック内で使用される他のファンクション ブロックの数 オブジェクト間の結合度が高い機能ブロックは、多くの異なるタスクに関与する可能性が高いため、固有責任の原則に違反します。 例 \/\/ Declaration FUNCTION_BLOCK FB_Child EXTENDS FB_Base objects \/\/ +0 for EXTENDS VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR i_fb1 :...", 
"body" : "CBO – オブジェクト間の結合 カテゴリー : 保守性、再利用性 対応する SA0179 ルールのデフォルトの上限: 30 インスタンス化され、ファンクション ブロック内で使用される他のファンクション ブロックの数 オブジェクト間の結合度が高い機能ブロックは、多くの異なるタスクに関与する可能性が高いため、固有責任の原則に違反します。 例 \/\/ Declaration\nFUNCTION_BLOCK FB_Child EXTENDS FB_Base objects \/\/ +0 for EXTENDS\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i_fb1 : FB1; \/\/ +1 instantiated here\n i_fb2 : FB2; \/\/ +1 instantiated here\nEND_VAR\n\n\/\/Implementation\ni_fb3(); \/\/ +0 instantiated in FB_Base, no increment for call 機能ブロックを拡張しても、オブジェクト間の結合は増加しません。 i_fb3 の実装でインスタンス化されます FB_Base そして FB_Child に渡されます ( EXTENDS ）。コールイン FB_Child オブジェクト間の結合は増加しません。 のCBO FB_Child は2です。 " }, 
{ "title" : "指標: 参照の複雑さ (Elshof) ", 
"url" : "_san_reference_metrics.html#UUID-a43f74c1-523d-b649-00e5-788c653e5ea1", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ 指標: 参照の複雑さ (Elshof) ", 
"snippet" : "参照の複雑さ (エルスホフ) カテゴリー : 効率、保守性、再利用性 POUのデータフローの複雑さ 参照の複雑さは、次の式に従って計算されます。 <使用する変数の数> \/ <変数のアクセス数> POU の実装部分の変数アクセスのみが考慮されます。 例 \/\/Declaration PROGRAM PRG VAR i, j : INT; k : INT := GVL.m; b, c : BOOL; myFB : FB; END_VAR \/\/Implementation myFB(paramA := b); \/\/ +3 accesses (myFB, paramA and b) i := j; \/\/...", 
"body" : "参照の複雑さ (エルスホフ) カテゴリー : 効率、保守性、再利用性 POUのデータフローの複雑さ 参照の複雑さは、次の式に従って計算されます。 <使用する変数の数> \/ <変数のアクセス数> POU の実装部分の変数アクセスのみが考慮されます。 例 \/\/Declaration\nPROGRAM PRG\nVAR\n i, j : INT;\n k : INT := GVL.m;\n b, c : BOOL;\n myFB : FB;\nEND_VAR\n\n\/\/Implementation\nmyFB(paramA := b); \/\/ +3 accesses (myFB, paramA and b)\ni := j; \/\/ +2 accesses (i and j)\nj := GVL.d; \/\/ +2 accesses (j and GVL.d) コード スニペットの複雑さを参照すると、次のようになります。 6 使用される変数の数 \/ 7 変数アクセス数 = 0.85 注意： c そして k は使用されていないため、「使用された変数」としてカウントされません。 課題 k : INT := GVL.m はプログラムの宣言の一部であるためカウントされません。 " }, 
{ "title" : "指標: 手法の一貫性の欠如 – LCOM ", 
"url" : "_san_reference_metrics.html#UUID-068c2765-4709-d4e2-80b6-d173998195a8", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ 指標: 手法の一貫性の欠如 – LCOM ", 
"snippet" : "手法の一貫性の欠如 – LCOM 手法の一貫性の欠如 – LCOM カテゴリー : 保守性、再利用性 関数ブロック、そのアクション、遷移、およびメソッド間の結合度は、それらが同じ変数にアクセスするかどうかを示します。 メソッドの凝集性の欠如は、機能ブロックのオブジェクトが互いにどの程度強く結びついているかを表します。凝集性の欠如が低いほど、オブジェクト間の接続は強くなります。 凝集度が著しく低い機能ブロックは、多くの異なるタスクに関与する可能性が高いため、固有の責任の原則に違反します。 メトリックは次の式に従って計算されます。 MAX(0, <凝集性のないオブジェクト ペアの数> - <凝集性...", 
"body" : "手法の一貫性の欠如 – LCOM 手法の一貫性の欠如 – LCOM カテゴリー : 保守性、再利用性 関数ブロック、そのアクション、遷移、およびメソッド間の結合度は、それらが同じ変数にアクセスするかどうかを示します。 メソッドの凝集性の欠如は、機能ブロックのオブジェクトが互いにどの程度強く結びついているかを表します。凝集性の欠如が低いほど、オブジェクト間の接続は強くなります。 凝集度が著しく低い機能ブロックは、多くの異なるタスクに関与する可能性が高いため、固有の責任の原則に違反します。 メトリックは次の式に従って計算されます。 MAX(0, <凝集性のないオブジェクト ペアの数> - <凝集性のあるオブジェクト ペアの数>) 例 \/\/Declaration\nFUNCTION_BLOCK FB\nVAR_INPUT\n a : BOOL;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i,b : BOOL;\nEND_VAR\n\n\/\/Implementation\ni := 42;\n\/\/FB.ACT\ni:= 0; \/\/FB.METH Declaration\nMETHOD METH : BOOL\nVAR_INPUT\n\tc : BOOL;\nEND_VAR\n\n\/\/Implementation\nMETH := c;\ni := 1; \/\/FB.SecondMETH Declaration\nMETHOD SecondMETH : INT\nVAR_INPUT\nEND_VAR\n\n\/\/Implementation\nSecondMETH := SEL(c,3,4); 接続のないオブジェクト ペア (4 ペア): FB, FB.ACT FB 、 FB.METH FB.ACT 、 FB.SecondMETH FB.METH 、 FB.SecondMETH 接続のあるオブジェクトのペア (2 ペア): FB 、 FB.SecondMETH (どちらも使用します c ） FB.ACT 、 FB.METH (どちらも使用します i ) この表は、どの変数が FB のどのオブジェクトに接続されているかを示しています。 FB FB.ACT FB.METH FB.SecondMETH FB.SecondMETH c 0 0 . FB.METH 0 i . . FB.ACT 0 . . . FB - . . . " }, 
{ "title" : "指標: SFC ブランチ数 ", 
"url" : "_san_reference_metrics.html#UUID-d74f2703-e85d-ed16-b335-69a4dfd4a8bd", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ 指標: SFC ブランチ数 ", 
"snippet" : "SFC支店数 カテゴリー : テスト容易性、保守容易性 SFC（逐次関数チャート）実装言語のPOUの代替分岐および並列分岐の数 例 SFC の上記のコード スニペットには 4 つの分岐があります: 3 つの代替分岐と 1 つの並列分岐です。...", 
"body" : "SFC支店数 カテゴリー : テスト容易性、保守容易性 SFC（逐次関数チャート）実装言語のPOUの代替分岐および並列分岐の数 例 SFC の上記のコード スニペットには 4 つの分岐があります: 3 つの代替分岐と 1 つの並列分岐です。 " }, 
{ "title" : "メトリック: SFC ステップ数 ", 
"url" : "_san_reference_metrics.html#UUID-19d1353f-ebce-6c25-6214-7b3a97c92490", 
"breadcrumbs" : "CODESYS Static Analysis \/ 参照：プログラミング \/ メトリクス \/ メトリック: SFC ステップ数 ", 
"snippet" : "SFCステップ数 カテゴリー : メンテナンス性 SFC の POU のステップ数 (逐次関数チャート) SFC でプログラムされた POU に含まれるステップのみがカウントされます。 POU で呼び出されるアクションまたは遷移の実装に含まれるステップはカウントされません。 例 SFC のコード スニペットには 10 のステップがあります。...", 
"body" : "SFCステップ数 カテゴリー : メンテナンス性 SFC の POU のステップ数 (逐次関数チャート) SFC でプログラムされた POU に含まれるステップのみがカウントされます。 POU で呼び出されるアクションまたは遷移の実装に含まれるステップはカウントされません。 例 SFC のコード スニペットには 10 のステップがあります。 " }
]
$(document).trigger('search.ready');
});