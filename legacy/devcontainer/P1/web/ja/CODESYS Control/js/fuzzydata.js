$(document).ready(function () {indexDict['ja'] = [{ "title" : "CODESYS Control ", 
"url" : "_rtsl_start_page.html", 
"breadcrumbs" : "CODESYS Control \/ CODESYS Control ", 
"snippet" : "をインストールできます。 CODESYS Control for <device> SL さまざまな産業用デバイスのランタイム システム。その結果、デバイスのプログラミングと制御には次のオプションがあります。 IEC 61131-3 に準拠した統一プログラミング CODESYS Development System によってコンパイルされたアプリケーション コードのダウンロード、管理、および実行 CODESYS 内部からの制御アプリケーションのデバッグ CODESYS I\/O システムとフィールドバスの取り扱い 次のようなオプション コンポーネントの実行 CODESYS TargetVisu ...", 
"body" : "をインストールできます。 CODESYS Control for <device> SL さまざまな産業用デバイスのランタイム システム。その結果、デバイスのプログラミングと制御には次のオプションがあります。 IEC 61131-3 に準拠した統一プログラミング CODESYS Development System によってコンパイルされたアプリケーション コードのダウンロード、管理、および実行 CODESYS 内部からの制御アプリケーションのデバッグ CODESYS I\/O システムとフィールドバスの取り扱い 次のようなオプション コンポーネントの実行 CODESYS TargetVisu 、 CODESYS WebVisu 、 CODESYS SoftMotion CNC + ロボティクス、および OPC UA サーバー " }, 
{ "title" : "セキュリティ通知 ", 
"url" : "_rtsl_start_page.html#UUID-421e9fc4-30bc-da26-ebd8-4038f3d434c1_section-idm4550391658761633048843474945", 
"breadcrumbs" : "CODESYS Control \/ CODESYS Control \/ セキュリティ通知 ", 
"snippet" : "コントローラは、いかなる状況でもインターネットからアクセスできてはなりません。特に、コントローラのプログラミング ポートは、いかなる状況下でも保護なしでインターネットからアクセスできてはなりません。 すべてのランタイムシステムで最も重要なポート番号を以下に示します。デフォルトではシステムによって割り当てられますが、設定によって変更できます。 1740..1743: ゲートウェイおよびランタイム システムの UDP ブロック ドライバー 11740..11743: ゲートウェイおよびランタイム システムの TCP ブロック ドライバー 1217: 接続用ゲートウェイ CODESYS ゲートウェイ...", 
"body" : "コントローラは、いかなる状況でもインターネットからアクセスできてはなりません。特に、コントローラのプログラミング ポートは、いかなる状況下でも保護なしでインターネットからアクセスできてはなりません。 すべてのランタイムシステムで最も重要なポート番号を以下に示します。デフォルトではシステムによって割り当てられますが、設定によって変更できます。 1740..1743: ゲートウェイおよびランタイム システムの UDP ブロック ドライバー 11740..11743: ゲートウェイおよびランタイム システムの TCP ブロック ドライバー 1217: 接続用ゲートウェイ CODESYS ゲートウェイへ 8080: CODESYS ウェブサーバー 443: CODESYS ウェブサーバー (SSL) * * 9090: ビーグルボーン用 4840: CODESYS OPC UAサーバー 22: ターゲットへのSSH接続（LinuxベースのSLランタイムのインストール\/アップデート経由） CODESYS プログラミングシステム) それでもインターネットからのアクセスを可能にする必要がある場合は、PLC への接続に安全な方法を選択することが不可欠です (例: VPN)。 ランタイム システムは PC へのアクセスを許可するため、対応するユーザーおよび権限管理を装備する必要があります。 製品は次の場所にダウンロードできます CODESYS Control から コーデシス・ストア・インターナショナル または コーデシスストア北米 。そこには、製品のデータシートもあります。 CODESYS Deploy Tool " }, 
{ "title" : "製品の概要 ", 
"url" : "_rtsl_product_overview.html", 
"breadcrumbs" : "CODESYS Control \/ 製品の概要 ", 
"snippet" : "システムの要求と納品範囲に関する情報 CODESYS Control for <device> SL 製品はで見つけることができます CODESYS Store International : ランタイム システムのライセンスは、次の場所にあります。 CODESYS Store International .有効なライセンスがない場合、すべてのランタイム システムのランタイムは 2 時間に制限されます。...", 
"body" : "システムの要求と納品範囲に関する情報 CODESYS Control for <device> SL 製品はで見つけることができます CODESYS Store International : ランタイム システムのライセンスは、次の場所にあります。 CODESYS Store International .有効なライセンスがない場合、すべてのランタイム システムのランタイムは 2 時間に制限されます。 " }, 
{ "title" : "ハードウェアに依存しないランタイム システム ", 
"url" : "_rtsl_product_overview.html#UUID-da861021-6b3f-718d-ac40-c1e7e9f72bd8_section-idm4613712476080033169570967262", 
"breadcrumbs" : "CODESYS Control \/ 製品の概要 \/ ハードウェアに依存しないランタイム システム ", 
"snippet" : "CODESYS Control Win SL CODESYS Control RTE SL CODESYS Control for Linux SL CODESYS Control for Linux ARM\/ARM64 CODESYS Virtual Control SL CODESYS Virtual Safe Control SL...", 
"body" : "CODESYS Control Win SL CODESYS Control RTE SL CODESYS Control for Linux SL CODESYS Control for Linux ARM\/ARM64 CODESYS Virtual Control SL CODESYS Virtual Safe Control SL " }, 
{ "title" : "ハードウェア固有のランタイム システム ", 
"url" : "_rtsl_product_overview.html#UUID-da861021-6b3f-718d-ac40-c1e7e9f72bd8_section-idm4589278258244833169573395522", 
"breadcrumbs" : "CODESYS Control \/ 製品の概要 \/ ハードウェア固有のランタイム システム ", 
"snippet" : "CODESYS Control for Beaglebone SL CODESYS Control for Raspberry PI SL CODESYS Control for PFC100 SL CODESYS Control for PFC200 SL CODESYS Control for emPC-A\/iMX6 SL CODESYS Control for WAGO Touch Panels 600 SL CODESYS Control for PLCnext SL CODESYS Control RTE SL (for Beckhoff CX)...", 
"body" : "CODESYS Control for Beaglebone SL CODESYS Control for Raspberry PI SL CODESYS Control for PFC100 SL CODESYS Control for PFC200 SL CODESYS Control for emPC-A\/iMX6 SL CODESYS Control for WAGO Touch Panels 600 SL CODESYS Control for PLCnext SL CODESYS Control RTE SL (for Beckhoff CX) " }, 
{ "title" : "エッジ ゲートウェイ ", 
"url" : "_rtsl_product_overview.html#UUID-da861021-6b3f-718d-ac40-c1e7e9f72bd8_section-idm4544772720513633169577754493", 
"breadcrumbs" : "CODESYS Control \/ 製品の概要 \/ エッジ ゲートウェイ ", 
"snippet" : "の CODESYS Edge Gateway 拡張です CODESYS をつなぐゲートウェイ CODESYS Automation Server と CODESYS ローカル ネットワークのコントローラ。 Linux用CODESYSエッジゲートウェイ Windows用CODESYSエッジゲートウェイ...", 
"body" : "の CODESYS Edge Gateway 拡張です CODESYS をつなぐゲートウェイ CODESYS Automation Server と CODESYS ローカル ネットワークのコントローラ。 Linux用CODESYSエッジゲートウェイ Windows用CODESYSエッジゲートウェイ " }, 
{ "title" : "Linux ベースのランタイム システム ", 
"url" : "_rtsl_linux_runtime_systems.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "入門 ", 
"url" : "_rtsl_first_steps.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 ", 
"snippet" : "この章では、デバイスを試運転する方法を学習します CODESYS Control SLランタイム、小さなものから始めましょう CODESYS アプリケーションを作成し、コントローラーのライセンスを取得します。...", 
"body" : "この章では、デバイスを試運転する方法を学習します CODESYS Control SLランタイム、小さなものから始めましょう CODESYS アプリケーションを作成し、コントローラーのライセンスを取得します。 " }, 
{ "title" : "準備 ", 
"url" : "_rtsl_preparation_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ 準備 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コントローラー ", 
"url" : "_rtsl_preparation_linux.html#UUID-6cfdd13d-15e9-2ce9-6bfc-ddfaec59e7f5_section-idm234655601003053", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ 準備 \/ コントローラー ", 
"snippet" : "要件:最新の Linux オペレーティングシステム (Debian や Ubuntu など) をコントローラーにインストールし、SSH サーバーをインストールしてアクティブ化する必要があります。 SSH サーバーがアクティブかどうかを確認するには、コントローラーで次のコマンドを実行します。 sudo systemctl status ssh SSH サーバーがアクティブな場合、出力は次のようになります。 ssh.service - OpenBSD Secure Shell server Loaded: loaded (\/lib\/systemd\/system\/ssh.service; enabl...", 
"body" : "要件:最新の Linux オペレーティングシステム (Debian や Ubuntu など) をコントローラーにインストールし、SSH サーバーをインストールしてアクティブ化する必要があります。 SSH サーバーがアクティブかどうかを確認するには、コントローラーで次のコマンドを実行します。 sudo systemctl status ssh SSH サーバーがアクティブな場合、出力は次のようになります。 ssh.service - OpenBSD Secure Shell server \n Loaded: loaded (\/lib\/systemd\/system\/ssh.service; enabled; preset: enabled) \n Active: active (running) since [...] \n Docs: man:sshd(8) \n man:sshd_config(5) \n Main PID: 741 (sshd) \n Tasks: 1 (limit: 18876) \n Memory: 10.4M \n CPU: 12.778s \n CGroup: \/system.slice\/ssh.service \n └─741 \"sshd: \/usr\/sbin\/sshd -D [listener] 0 of 10-100 startups\" SSH サーバーがアクティブ化されていない場合は、次のコマンドを使用してサーバーを永続的にアクティブ化できます。 sudo systemctl enable ssh 。次に、上記のようにサービスがアクティブになっているかどうかを確認します。 使用したい場合 CODESYS Virtual Control for Linux SL その場合は、次のソフトウェアの最新バージョンもインストールする必要があります。 パイソン 3 ドッカーまたはポッドマン Debian に Docker をインストールする方法については、以下を参照してください。 Debian に Docker エンジンをインストールする 。 " }, 
{ "title" : "CODESYS 開発環境 ", 
"url" : "_rtsl_preparation_linux.html#UUID-6cfdd13d-15e9-2ce9-6bfc-ddfaec59e7f5_section-idm234655602655537", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ 準備 \/ CODESYS 開発環境 ", 
"snippet" : "を使う CODESYS Installer 最新バージョンのをインストールするには CODESYS Development System と CODESYS ランタイムシステムを使用するコントローラーのパッケージ。 少なくとも以下のパッケージが必要です。 l CODESYS Control SL Deploy Tool CODESYS Control は、例えば CODESYS Control for Linux ARM )...", 
"body" : "を使う CODESYS Installer 最新バージョンのをインストールするには CODESYS Development System と CODESYS ランタイムシステムを使用するコントローラーのパッケージ。 少なくとも以下のパッケージが必要です。 l CODESYS Control SL Deploy Tool CODESYS Control は、例えば CODESYS Control for Linux ARM ) " }, 
{ "title" : "のインストール CODESYS Control for <device> SL パッケージイン CODESYS ", 
"url" : "_rtsl_preparation_linux.html#UUID-6cfdd13d-15e9-2ce9-6bfc-ddfaec59e7f5_section-idm43465561410290", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ 準備 \/ のインストール CODESYS Control for <device> SL パッケージイン CODESYS ", 
"snippet" : "を起動します CODESYS Development System 。 クリック [ツール] → コーデシスインストーラー 。 ザ・ CODESYS インストーラー ダイアログが開きます。 アンダー アドオン 、クリック ブラウズ 。 ランタイムプロダクトのパッケージを選択します。 パッケージがインストールされます。ランタイムパッケージ、ライブラリ、デバイスの説明、およびサンプルプロジェクトが開発システムに保存されます。 製品によっては、ランタイムシステムパッケージはDebianまたはIPKのランタイムシステムファイルとして ..\\Users\\<user name>\\CODESYS Contr...", 
"body" : "を起動します CODESYS Development System 。 クリック [ツール] → コーデシスインストーラー 。 ザ・ CODESYS インストーラー ダイアログが開きます。 アンダー アドオン 、クリック ブラウズ 。 ランタイムプロダクトのパッケージを選択します。 パッケージがインストールされます。ランタイムパッケージ、ライブラリ、デバイスの説明、およびサンプルプロジェクトが開発システムに保存されます。 製品によっては、ランタイムシステムパッケージはDebianまたはIPKのランタイムシステムファイルとして ..\\Users\\<user name>\\CODESYS Control for <device> フォルダにあります。 " }, 
{ "title" : "オペレーティング システムのインストール ", 
"url" : "_rtsl_linux_install_operating_system.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ 準備 \/ オペレーティング システムのインストール ", 
"snippet" : "インストールするには CODESYS Control for <device> SL デバイスまたはハードウェアでは、Linux オペレーティング システムが必要です。 メーカー固有の指示に注意してください。 製造元のホームページの説明に従って、デバイスのメモリ カードに Linux オペレーティング システムをインストールします。 オペレーティング システムは、メモリ カードにインストールされます。 メモリカードでデバイスを起動します。 オペレーティング システムが実行されており、使用する準備ができています。...", 
"body" : "インストールするには CODESYS Control for <device> SL デバイスまたはハードウェアでは、Linux オペレーティング システムが必要です。 メーカー固有の指示に注意してください。 製造元のホームページの説明に従って、デバイスのメモリ カードに Linux オペレーティング システムをインストールします。 オペレーティング システムは、メモリ カードにインストールされます。 メモリカードでデバイスを起動します。 オペレーティング システムが実行されており、使用する準備ができています。 " }, 
{ "title" : "デバイス固有の設定 ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm4599163518809633054177648631", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ 準備 \/ オペレーティング システムのインストール \/ デバイス固有の設定 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "BeagleBone ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm43305417852438", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ 準備 \/ オペレーティング システムのインストール \/ デバイス固有の設定 \/ BeagleBone ", 
"snippet" : "BeagleBone が USB ケーブルでローカル システムに直接接続されている場合、デフォルトの IP アドレスは 192.168.7.2 ....", 
"body" : "BeagleBone が USB ケーブルでローカル システムに直接接続されている場合、デフォルトの IP アドレスは 192.168.7.2 . " }, 
{ "title" : "PFC100\/200 ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm43305417882662", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ 準備 \/ オペレーティング システムのインストール \/ デバイス固有の設定 \/ PFC100\/200 ", 
"snippet" : "WAGO コントローラの電源が入っていて、ネットワークに接続されていることを確認してください。コントローラを CODESYS エンジニアリング プラットフォームを X1 ソケットに挿入する必要があります。 X2 ソケットはフィールドバスに使用されます。 イーサネット フィールドバスを使用する場合、PFC100\/200 のイーサネット インターフェイスを「分離」に設定する必要があります。デバイスの IP アドレスをブラウザに入力します。 デバイスの「Web ベースの管理」ページが開きます。 をクリックします [ネットワーク] → TCP IP メニューコマンド。 ユーザー ログイン データの提供...", 
"body" : "WAGO コントローラの電源が入っていて、ネットワークに接続されていることを確認してください。コントローラを CODESYS エンジニアリング プラットフォームを X1 ソケットに挿入する必要があります。 X2 ソケットはフィールドバスに使用されます。 イーサネット フィールドバスを使用する場合、PFC100\/200 のイーサネット インターフェイスを「分離」に設定する必要があります。デバイスの IP アドレスをブラウザに入力します。 デバイスの「Web ベースの管理」ページが開きます。 をクリックします [ネットワーク] → TCP IP メニューコマンド。 ユーザー ログイン データの提供を求められた場合は、ユーザー名を入力します。 admin とパスワード wago . の スイッチ構成 、 を選択 別れた オプションをクリックして 送信 確認するために。 ブラウザを閉じます。 Web ベースの管理に関する注意: 現在のバージョンでは、アクティブパーティションの変更はまだできません。 CODESYS Control for PFC100\/200 (メニュー項目:「大容量ストレージ」)。 のライセンス情報 情報 → コントローラーの詳細 → ライセンス情報 メニュー項目はプリインストールされた WAGO コントローラに関するもので、 CODESYS Control for PFC100\/200 。 ファイアウォールの設定 ( PLC ランタイム と PLC WebVisu ) プリインストールされた WAGO コントローラも参照してください。 CODESYS Control for PFC100\/200 . ファイアウォールを構成する必要がある場合 CODESYS Control for PFC100\/200 の場合、「ユーザー フィルター」を使用して手動で構成できます。 ネットワーク アダプタに関する情報: イーサネット ベースのフィールドバスの場合、ランタイムは自動的に 2 番目のネットワーク インターフェイス (「X2」または「br1」) を使用します。使用しているネットワーク インターフェイスのイーサネット アダプタおよび EtherCAT コンフィギュレータの設定は上書きされます。 " }, 
{ "title" : "Raspberry Pi ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm43305417928746", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ 準備 \/ オペレーティング システムのインストール \/ デバイス固有の設定 \/ Raspberry Pi ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Raspberry Pi の設定 ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm41652708964375", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ 準備 \/ オペレーティング システムのインストール \/ デバイス固有の設定 \/ Raspberry Pi \/ Raspberry Pi の設定 ", 
"snippet" : "実行します sudo raspi-config コンソールまたは SSH 経由のコマンド (たとえば、 Putty 道具）。 注: Debian バージョン 8 (「Jessie」) の時点で、同じ設定のグラフィカル構成インターフェースもあります。 設定ツールが起動します。 を選択 1 Expand Filesystem 指図。 オプション: を選択 8 Advanced Options コマンドを実行し、Raspberry Pi の一意の名前を指定します。 オプション: を選択 5 Enable Camera 指図。 カメラは動作しています。 設定ツールを終了し、再起動します。...", 
"body" : "実行します sudo raspi-config コンソールまたは SSH 経由のコマンド (たとえば、 Putty 道具）。 注: Debian バージョン 8 (「Jessie」) の時点で、同じ設定のグラフィカル構成インターフェースもあります。 設定ツールが起動します。 を選択 1 Expand Filesystem 指図。 オプション: を選択 8 Advanced Options コマンドを実行し、Raspberry Pi の一意の名前を指定します。 オプション: を選択 5 Enable Camera 指図。 カメラは動作しています。 設定ツールを終了し、再起動します。 " }, 
{ "title" : "I²C、SPI、および 1-Wire ペリフェラル インターフェイスのアクティブ化 ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm43305417928748", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ 準備 \/ オペレーティング システムのインストール \/ デバイス固有の設定 \/ Raspberry Pi \/ I²C、SPI、および 1-Wire ペリフェラル インターフェイスのアクティブ化 ", 
"snippet" : "編集 \/boot\/config.txt ファイルをテキスト エディターで (たとえば、 sudo nano \/boot\/config.txt ）。権限に注意してください。 構成を確認し、必要に応じて調整します。 次の行が含まれています (コメントアウトされていません)。 # ): dtparam=i2c_arm=on dtparam=spi=on dtoverlay=w1-gpio-pullup,pullup=1 注: I²C、SPI、および 1-Wire ペリフェラル インターフェイスはオプションです。...", 
"body" : "編集 \/boot\/config.txt ファイルをテキスト エディターで (たとえば、 sudo nano \/boot\/config.txt ）。権限に注意してください。 構成を確認し、必要に応じて調整します。 次の行が含まれています (コメントアウトされていません)。 # ): dtparam=i2c_arm=on\ndtparam=spi=on\ndtoverlay=w1-gpio-pullup,pullup=1 注: I²C、SPI、および 1-Wire ペリフェラル インターフェイスはオプションです。 " }, 
{ "title" : "カメラの起動 ", 
"url" : "_rtsl_linux_install_operating_system.html#UUID-e9eaeb45-2c97-aac1-178f-782912ad77d6_section-idm46610835857494", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ 準備 \/ オペレーティング システムのインストール \/ デバイス固有の設定 \/ Raspberry Pi \/ カメラの起動 ", 
"snippet" : "実行します sudo raspi-config コンソールまたは SSH 経由のコマンド (たとえば、 Putty 道具）。 を選択 5 Enable Camera 指図。 次のコマンドを実行します。 sudo apt-get update sudo apt-get dist-upgrade sudo rpi-update git clone https:\/\/github.com\/silvanmelchior\/RPi_Cam_Web_Interface.git cd RPi_Cam_Web_Interface chmod u+x RPi_Cam_Web_Interface_Installer....", 
"body" : "実行します sudo raspi-config コンソールまたは SSH 経由のコマンド (たとえば、 Putty 道具）。 を選択 5 Enable Camera 指図。 次のコマンドを実行します。 sudo apt-get update\nsudo apt-get dist-upgrade\nsudo rpi-update\ngit clone https:\/\/github.com\/silvanmelchior\/RPi_Cam_Web_Interface.git\ncd RPi_Cam_Web_Interface\nchmod u+x RPi_Cam_Web_Interface_Installer.sh\n.\/RPi_Cam_Web_Interface_Installer.sh install ウェブブラウザを起動して開く http:\/\/<network address> . インストールが成功すると、RPi Cam Control ユーザー インターフェイスが読み込まれ、カメラを使用できるようになります。 " }, 
{ "title" : "接続を確立する ", 
"url" : "_rtsl_establish_connection_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ 接続を確立する ", 
"snippet" : "要件:オペレーティングシステムはコントローラに既にインストールされています。そうでない場合は、の手順に従ってください オペレーティング システムのインストール チャプター。 以下の手順では、Deploy Tool をデバイスに接続するために Linux デバイスのネットワークアドレスを確認する方法について説明します。...", 
"body" : "要件:オペレーティングシステムはコントローラに既にインストールされています。そうでない場合は、の手順に従ってください オペレーティング システムのインストール チャプター。 以下の手順では、Deploy Tool をデバイスに接続するために Linux デバイスのネットワークアドレスを確認する方法について説明します。 " }, 
{ "title" : "ネットワークアドレスの検出 ", 
"url" : "_rtsl_establish_connection_linux.html#UUID-8282f374-6dd3-23b6-eb03-311464e44f1b_section-idm43466295058734", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ 接続を確立する \/ ネットワークアドレスの検出 ", 
"snippet" : "でネットワークアドレスを検出する CODESYS ネットワーク経由 [開始] CODESYS 。 をクリックします ツール → コントロール SL をデプロイ コマンド。 ザ・ コミュニケーション ビューが開きます。 Port <port> の横にある Scan ボタンをクリックする。 ザ・ 使用可能なデバイス ダイアログには、ネットワークで利用可能なデバイスの IP アドレスが一覧表示されます。 デバイスを識別します。 デバイスによるネットワークアドレスの検出 要件:デバイスには、キーボード、マウス、モニターが接続されている。 ログイン。 コンソールを開いて実行します ip a s コマンド...", 
"body" : "でネットワークアドレスを検出する CODESYS ネットワーク経由 [開始] CODESYS 。 をクリックします ツール → コントロール SL をデプロイ コマンド。 ザ・ コミュニケーション ビューが開きます。 Port <port> の横にある Scan ボタンをクリックする。 ザ・ 使用可能なデバイス ダイアログには、ネットワークで利用可能なデバイスの IP アドレスが一覧表示されます。 デバイスを識別します。 デバイスによるネットワークアドレスの検出 要件:デバイスには、キーボード、マウス、モニターが接続されている。 ログイン。 コンソールを開いて実行します ip a s コマンド。 ネットワークアドレスが返されます。 ネットワーク経由の Windows によるネットワークアドレスの検出 要件:お使いのデバイスには、ネットワーク上で既知の固有の名前が付けられています (例:「BeagleBoneBlack」)。 Windows コマンドプロンプトを開きます。 を実行する ping デバイス名を指定するコマンド (デフォルト:ビーグルボーンブラック)。 ネットワークアドレスが返されます。 次のステップは、ランタイムシステムをコントローラーにインストールすることです。 " }, 
{ "title" : "ターゲットシステムへの接続 ", 
"url" : "_rtsl_establish_connection_linux.html#UUID-8282f374-6dd3-23b6-eb03-311464e44f1b_section-idm43466297829590", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ 接続を確立する \/ ターゲットシステムへの接続 ", 
"snippet" : "ターゲットシステムへの接続は、その後のイメージやパッケージのインストール、およびインスタンスの作成と管理に必要です。 をクリックします [ツール] → コントロール SL をデプロイ コマンド。 ザ・ デプロイコントロール SL オブジェクトが開きます。 で コミュニケーション タブで、ターゲットデバイスへの接続設定を行います。ターゲットシステムの IP アドレスを指定するか、最初に [] をクリックします。 スキャン ボタンをクリックすると、ネットワーク上で使用可能なすべての IP アドレスが表示されます。次に、ポートを指定します。 ターゲットシステムへのログインには、次の方法がサポートされ...", 
"body" : "ターゲットシステムへの接続は、その後のイメージやパッケージのインストール、およびインスタンスの作成と管理に必要です。 をクリックします [ツール] → コントロール SL をデプロイ コマンド。 ザ・ デプロイコントロール SL オブジェクトが開きます。 で コミュニケーション タブで、ターゲットデバイスへの接続設定を行います。ターゲットシステムの IP アドレスを指定するか、最初に [] をクリックします。 スキャン ボタンをクリックすると、ネットワーク上で使用可能なすべての IP アドレスが表示されます。次に、ポートを指定します。 ターゲットシステムへのログインには、次の方法がサポートされています。 認証情報:ユーザー名とパスワード キーベースの認証。詳しくは、以下を参照してください 公開鍵認証で接続する" }, 
{ "title" : "デバイスのデフォルト認証情報 ", 
"url" : "_rtsl_establish_connection_linux.html#UUID-8282f374-6dd3-23b6-eb03-311464e44f1b_section-idm43466298221944", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ 接続を確立する \/ デバイスのデフォルト認証情報 ", 
"snippet" : "デフォルトの認証情報は次のとおりです。問題が発生した場合は、製造元のホームページで問題のデバイスの認証情報を確認してください。 ユーザ パスワード ラズベリーパイ pi raspberry ビーグルボーン root 空白 IOT デバイスの設定済み認証情報 PFC100\/200 root wago PLCネクスト admin コントローラーに印刷されています ワゴー TP600 root wago EMPC-A-Mix6 デバイスの設定済み認証情報...", 
"body" : "デフォルトの認証情報は次のとおりです。問題が発生した場合は、製造元のホームページで問題のデバイスの認証情報を確認してください。 ユーザ パスワード ラズベリーパイ pi raspberry ビーグルボーン root 空白 IOT デバイスの設定済み認証情報 PFC100\/200 root wago PLCネクスト admin コントローラーに印刷されています ワゴー TP600 root wago EMPC-A-Mix6 デバイスの設定済み認証情報 " }, 
{ "title" : "コントローラーへのランタイムのインストール ", 
"url" : "_rtsl_install_runtime_on_controller.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ コントローラーへのランタイムのインストール ", 
"snippet" : "必要条件: ザ・ ツール → コントロール SL をデプロイ コマンドが実行され、デバイスへの接続が確立されました。そうでない場合は、の手順に従ってください 接続を確立する チャプター。 目的のコントローラーのアドオン (例: CODESYS Control for Linux ARM64 ) は、にインストールされています CODESYS Development System 。...", 
"body" : "必要条件: ザ・ ツール → コントロール SL をデプロイ コマンドが実行され、デバイスへの接続が確立されました。そうでない場合は、の手順に従ってください 接続を確立する チャプター。 目的のコントローラーのアドオン (例: CODESYS Control for Linux ARM64 ) は、にインストールされています CODESYS Development System 。 " }, 
{ "title" : "パッケージベースのコントローラー ", 
"url" : "_rtsl_install_runtime_on_controller.html#UUID-ccf57e50-e4fa-81ce-6f6c-813f0b8b1aca_section-idm234664620258912", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ コントローラーへのランタイムのインストール \/ パッケージベースのコントローラー ", 
"snippet" : "以下の手順では、ランタイムシステムを Linux デバイスにインストールする方法について説明します。 を開く デプロイメント タブ。 で 製品 リストボックスで、目的の製品を選択します。 で バージョン リストボックスで、目的のバージョンを選択します。 をクリックします インストール ボタン。 選択したランタイムシステムがデバイスにインストールされます。コントローラーは自動的に再起動されます。手動で再起動する必要はありません パッケージをアンインストールするには、次の手順に従います。 で インストール済みパッケージ セクションで、対応するエントリを選択します。 コントローラーが動作している場合...", 
"body" : "以下の手順では、ランタイムシステムを Linux デバイスにインストールする方法について説明します。 を開く デプロイメント タブ。 で 製品 リストボックスで、目的の製品を選択します。 で バージョン リストボックスで、目的のバージョンを選択します。 をクリックします インストール ボタン。 選択したランタイムシステムがデバイスにインストールされます。コントローラーは自動的に再起動されます。手動で再起動する必要はありません パッケージをアンインストールするには、次の手順に従います。 で インストール済みパッケージ セクションで、対応するエントリを選択します。 コントローラーが動作している場合は停止し、をクリックします ボタン。 次のダイアログで、をクリックします [はい] 。 パッケージがアンインストールされます。 に含まれているサンプルプロジェクトをテストして、インストールを確認します CODESYS パッケージ。 " }, 
{ "title" : "コンテナベースのコントローラー ", 
"url" : "_rtsl_install_runtime_on_controller.html#UUID-ccf57e50-e4fa-81ce-6f6c-813f0b8b1aca_section-idm234664621921259", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ コントローラーへのランタイムのインストール \/ コンテナベースのコントローラー ", 
"snippet" : "次のステップは、イメージとインスタンスを管理する方法を示しています。...", 
"body" : "次のステップは、イメージとインスタンスを管理する方法を示しています。 " }, 
{ "title" : "画像の管理 ", 
"url" : "_rtsl_install_runtime_on_controller.html#UUID-ccf57e50-e4fa-81ce-6f6c-813f0b8b1aca_section-idm43466462476384", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ コントローラーへのランタイムのインストール \/ コンテナベースのコントローラー \/ 画像の管理 ", 
"snippet" : "仮想製品 (ランタイムインスタンスやゲートウェイインスタンスなど) の設定では、対応するイメージがターゲットデバイスに存在する必要があります。 Bei der Installation von CODESYS Virtual Control for Linux SL werden Images im Verzeichnis C:\\Users\\<user>\\CODESYS Virtual Control for Linux SL\\Delivery\\ als Archiv mit der Endung .tar.gz abgelegt. Installing an image を開く デプロイメン...", 
"body" : "仮想製品 (ランタイムインスタンスやゲートウェイインスタンスなど) の設定では、対応するイメージがターゲットデバイスに存在する必要があります。 Bei der Installation von CODESYS Virtual Control for Linux SL werden Images im Verzeichnis C:\\Users\\<user>\\CODESYS Virtual Control for Linux SL\\Delivery\\ als Archiv mit der Endung .tar.gz abgelegt. Installing an image を開く デプロイメント タブ。 で 製品 リストボックスで、目的の仮想製品を選択します。 で バージョン リストボックスで、目的のバージョンを選択します。 をクリックします インストール ボタン。 イメージがターゲットシステムに転送され、に一覧表示されます。 インストール済みイメージ セクション。 非仮想製品とは対照的に、自動起動はありません。仮想製品の場合は、まずでインスタンスを作成する必要があります オペレーション タブ。 ターゲットシステムからのイメージの削除 で デプロイメント タブ、 イメージを管理する エリアで、該当する画像を選択し、 ボタンをクリックし、 [削除] コマンド。 インスタンスでイメージが使用されている場合、そのイメージは削除できません。 " }, 
{ "title" : "仮想インスタンスの管理 ", 
"url" : "_rtsl_install_runtime_on_controller.html#UUID-ccf57e50-e4fa-81ce-6f6c-813f0b8b1aca_section-idm43466462511166", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ コントローラーへのランタイムのインストール \/ コンテナベースのコントローラー \/ 仮想インスタンスの管理 ", 
"snippet" : "ターゲットシステム上のインスタンスは、上で管理されます。 オペレーション タブ。 設定の一部の値は変更できません。 実行中のインスタンスの設定は変更できません。 新しいインスタンスの作成と設定 をクリックします ボタン。 ザ・ 新しいインスタンスを追加 ダイアログが開きます。 で [名前] 一意の名前を指定してください。名前には英数字と次の文字のみを使用できます .-_ 。しかし、登場人物 .-_ 最初であってはいけません。 オプション:で [フィルタ] リストボックスで、画像のタイプを選択します (例: ランタイムシステム または ゲートウェイ )。 使用可能な画像のリストは、選択したタイプ...", 
"body" : "ターゲットシステム上のインスタンスは、上で管理されます。 オペレーション タブ。 設定の一部の値は変更できません。 実行中のインスタンスの設定は変更できません。 新しいインスタンスの作成と設定 をクリックします ボタン。 ザ・ 新しいインスタンスを追加 ダイアログが開きます。 で [名前] 一意の名前を指定してください。名前には英数字と次の文字のみを使用できます .-_ 。しかし、登場人物 .-_ 最初であってはいけません。 オプション:で [フィルタ] リストボックスで、画像のタイプを選択します (例: ランタイムシステム または ゲートウェイ )。 使用可能な画像のリストは、選択したタイプの画像に縮小されます。 次に、対応する項目を選択します。 [画像] 。次に、をクリックします OK 。 新しいインスタンスがに表示されます。 VPLC セクション。 インスタンスを選択して、新しく作成されたインスタンスを設定します。選択したインスタンスの設定は、の右側に表示されます。 [設定] セクション。 このセクションでは、このインスタンスのすべての設定を表示および編集できます。 詳細については、以下を参照してください。 構成: インスタンスを削除する 注:起動したインスタンスは削除できません。 で オペレーション タブをクリックし、インスタンスを選択します。 をクリックします ボタンを選択し、 [選択を削除] コマンド。 選択したインスタンス、構成、およびインスタンスのブートプロジェクトが削除されます。 ザ・ パージ コマンドはすべてのインスタンス、構成、その他をすべて停止して削除します。 CODESYS ターゲットデバイス上に存在するイメージ。 " }, 
{ "title" : "ランタイム システムの起動 ", 
"url" : "_rtsl_start_runtime.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ ランタイム システムの起動 ", 
"snippet" : "ノート : ランタイム システムを操作するには、PC に有効なライセンスをインストールする必要があります。そうでない場合、コントローラは完全に機能しますが、時間制限のあるデモ モードで起動します。 ランタイム システムの場合、これらはデバイス ライセンスです。これらのライセンスは、License Manager でアクティブ化します。 詳細については、次を参照してください。 製品のライセンス をクリックします ツール → コントロール SL をデプロイ コマンド。 ザ・ デプロイコントロール SL タブが開きます。 選択してください オペレーション Tab キーを押して、目的のエントリを選択し...", 
"body" : "ノート : ランタイム システムを操作するには、PC に有効なライセンスをインストールする必要があります。そうでない場合、コントローラは完全に機能しますが、時間制限のあるデモ モードで起動します。 ランタイム システムの場合、これらはデバイス ライセンスです。これらのライセンスは、License Manager でアクティブ化します。 詳細については、次を参照してください。 製品のライセンス をクリックします ツール → コントロール SL をデプロイ コマンド。 ザ・ デプロイコントロール SL タブが開きます。 選択してください オペレーション Tab キーを押して、目的のエントリを選択します。選択できるエントリは 1 つだけです。 をクリックします [選択を開始] コマンド。 コントローラが起動し、リストが更新されて新しいステータスが表示されます。 にゲートウェイインスタンスを含めるには CODESYS Automation Server ゲートウェイインスタンスはメンテナンスモードで起動できます。 のインスタンスを正しく設定した場合 CODESYS Virtual Control for Linux SL これで、このインスタンスに接続できます。詳細については、以下を参照してください。 インスタンスへの接続の確立。 " }, 
{ "title" : "のダウンロードと起動 CODESYS コントローラ上のアプリケーション ", 
"url" : "_rtsl_load_and_start_application.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ のダウンロードと起動 CODESYS コントローラ上のアプリケーション ", 
"snippet" : "に関する注意事項 CODESYS Virtual Control for Linux SL 要件:「仮想 Edge ゲートウェイ」の実行中のインスタンスが存在します。そのためには、の現在のイメージをインストールします CODESYS Virtual Edge Gateway for Linux 、新しいインスタンスを作成して起動します。 詳細については、以下を参照してください。 コントローラーへのランタイムのインストール — 仮想コントローラー の CODESYS 、標準プロジェクトを作成します: をクリックします ファイル→新規プロジェクト .の中に 新しい計画 ダイアログで、 標準プロジェ...", 
"body" : "に関する注意事項 CODESYS Virtual Control for Linux SL 要件:「仮想 Edge ゲートウェイ」の実行中のインスタンスが存在します。そのためには、の現在のイメージをインストールします CODESYS Virtual Edge Gateway for Linux 、新しいインスタンスを作成して起動します。 詳細については、以下を参照してください。 コントローラーへのランタイムのインストール — 仮想コントローラー の CODESYS 、標準プロジェクトを作成します: をクリックします ファイル→新規プロジェクト .の中に 新しい計画 ダイアログで、 標準プロジェクト テンプレートを作成し、名前と場所を指定します。次に、 標準プロジェクト ダイアログで、それぞれのコントローラーを選択します。 デバイス ツリー ( デバイス 新しいプロジェクトのビュー) には、コントローラー (コントローラー) のエントリがあります。 デバイス （...） )、その下に POU 付きのアプリケーション ( PLC_PRG (PRG) そしてタスク 主な任務 これは PLC_PRG を呼び出します)。 の PLC_PRG 、簡単なプログラム (たとえば、カウンター) を作成します。 PROGRAM PLC_PRG\nVAR\n iCount: INT;\nEND_VAR\n\niCount := iCount+1; コントローラへの接続を確立します。これを行うには、 通信設定 デバイスエディタのタブ。をダブルクリックして開くことができます。 デバイス （...） デバイス ツリーのエントリ。 通常、ゲートウェイはすでにアクティブになっています。そうでない場合は、ステータスを確認し、必要に応じてゲートウェイを明示的に起動してください。次に、 コミュニケーション タブをクリックし、 ネットワークをスキャン コマンド。 ザ・ [デバイスを選択] ダイアログが開き、検出されたデバイスが表示されます。コントローラーが見つからない場合は、コントローラーが正しくインストールされ、起動されていることを確認してください。 検出されたコントローラを選択し、 わかった . コントローラが見つからない場合は、次のことを確認してください。 上で 通信設定 タブの デバイス → オプション メニューで、 ターゲット ID によるネットワーク スキャンのフィルタリング オプション。 デバイスが今表示されている場合は、間違っています TargetID 。コンポーネント SysTargetOEM 正しくロードされていない可能性があります。 デバイスはネットワークに接続されていますか？ デフォルトでは、UDPを介してデバイスとの通信が行われます。この通信方法を使用する場合、デバイスはホストと同じサブネットワークに存在する必要があります。どちらのデバイスにも、まったく同じ構成済みのネットワークマスクが必要です。 起動時に、ランタイムシステムのメッセージのネットワーク設定を確認できます。たとえば、次のようになります。 1287759127: Cmp=CmpBlkDrvUdp, Class=1, Error=0, Info=6, pszInfo=Network interface: <ipaddress>192.168.101.41<\/ipaddress> <subnetmask>255.255.252.0<\/subnetmask> CODESYS このターゲットシステムで自身を認証し、通信チャネルを取得しようとします。接続が確立されます。 をクリックします [オンライン] → ログイン コマンド。 アプリケーションのダウンロードを確認するダイアログが開きます。 ダウンロードを実行し、アプリケーションを起動します。アプリケーションはデバイス上で処理されます。 の中に PLC_PRG プログラムで、カウンタが動作しているかどうかを確認します。 " }, 
{ "title" : "コントローラのライセンス ", 
"url" : "_rtsl_license_controller_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ コントローラのライセンス ", 
"snippet" : "ライセンスの使用例 CODESYS Control ランタイム製品: ローカルライセンス 運営許可証 CODESYS Control 製品はデバイス自体にあります。 ネットワークライセンス 運営許可 CODESYS Control 製品はネットワーク内のデバイス上にあります。複数のコントローラがこの中央デバイスに接続して、 CODESYS ライセンス。 の CODESYS Network License Server これには製品が必要です。 現在、使用できるのはネットワークライセンスのみです CODESYS Virtual Control SL 。そのためには、ライセンスサーバーの IP ア...", 
"body" : "ライセンスの使用例 CODESYS Control ランタイム製品: ローカルライセンス 運営許可証 CODESYS Control 製品はデバイス自体にあります。 ネットワークライセンス 運営許可 CODESYS Control 製品はネットワーク内のデバイス上にあります。複数のコントローラがこの中央デバイスに接続して、 CODESYS ライセンス。 の CODESYS Network License Server これには製品が必要です。 現在、使用できるのはネットワークライセンスのみです CODESYS Virtual Control SL 。そのためには、ライセンスサーバーの IP アドレスを以下で設定する必要があります ライセンスサーバー 各インスタンスのフィールド。 " }, 
{ "title" : "ライセンスの取得 ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234389354567343", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ コントローラのライセンス \/ ライセンスの取得 ", 
"snippet" : "ダウンロードできます CODESYS Control 製品から CODESYSストアインターナショナル または CODESYSストア北米 。...", 
"body" : "ダウンロードできます CODESYS Control 製品から CODESYSストアインターナショナル または CODESYSストア北米 。 " }, 
{ "title" : "ローカルライセンス ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm4588328499004833054120306755", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ コントローラのライセンス \/ ローカルライセンス ", 
"snippet" : "ライセンスは、USB ドングルまたはソフト コンテナにインストールできます。ソフト コンテナを使用する場合、ライセンスはアクティベーション中にデバイスにロックされ、このデバイスでのみアクティベートまたは復元できます。 要件: 開発システムには CODESYS Development System インターネットにアクセスでき、デバイスに接続されています。 開ける CODESYS 。 標準プロジェクトを作成します。 デバイスツリーでデバイスを更新します。 クリック ツール → ライセンスマネージャー 開く CODESYS ライセンス マネージャー。 選択する 端末 ウィザードで、を選択します ド...", 
"body" : "ライセンスは、USB ドングルまたはソフト コンテナにインストールできます。ソフト コンテナを使用する場合、ライセンスはアクティベーション中にデバイスにロックされ、このデバイスでのみアクティベートまたは復元できます。 要件: 開発システムには CODESYS Development System インターネットにアクセスでき、デバイスに接続されています。 開ける CODESYS 。 標準プロジェクトを作成します。 デバイスツリーでデバイスを更新します。 クリック ツール → ライセンスマネージャー 開く CODESYS ライセンス マネージャー。 選択する 端末 ウィザードで、を選択します ドングル また ソフトコンテナ 、デバイスによって異なります。 の デバイスを選択 ダイアログが開きます。 それぞれのデバイスを選択します。 の ライセンス マネージャー ダイアログが開きます。 容器 デバイス上のソフトコンテナまたはセキュリティキーの名前が表示されます。 製品 窓。 を選択 ライセンスのインストール 左下のアクション。 The <ターゲットデバイス> <コンテナ名>にライセンスをインストールする– [操作]を選択します ウィザードが起動します。 を選択 ライセンスのアクティベート オプション。指定する チケットID そしてクリック 次 . ライセンスがアクティブ化されます。 " }, 
{ "title" : "ネットワークライセンス ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234367072936383", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ コントローラのライセンス \/ ネットワークライセンス ", 
"snippet" : "の CODESYS Network License Server この製品はネットワークライセンスを許可します CODESYS 製品、例えばLinuxベースの CODESYS Control SLのランタイム CODESYS Store International 。 の CODESYS Network License Server ネットワーク モードの WIBU CodeMeter ランタイムに基づいており、Web ベースの管理フレームワーク「Cockpit」のサポートを提供します (参照: (https:\/\/cockpit-project.org\/) より 。 ネットワークライセンスサー...", 
"body" : "の CODESYS Network License Server この製品はネットワークライセンスを許可します CODESYS 製品、例えばLinuxベースの CODESYS Control SLのランタイム CODESYS Store International 。 の CODESYS Network License Server ネットワーク モードの WIBU CodeMeter ランタイムに基づいており、Web ベースの管理フレームワーク「Cockpit」のサポートを提供します (参照: (https:\/\/cockpit-project.org\/) より 。 ネットワークライセンスサーバーを使用するには、まず CODESYS Installer をインストールするには CODESYS Network License Server アドオン。その後、を使用して製品をデバイスにインストールできます デプロイ タブ。 詳細については、以下を参照してください。 タブ:デプロイ。 " }, 
{ "title" : "ネットワークライセンスの特徴 ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234373994123211", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ コントローラのライセンス \/ ネットワークライセンス \/ ネットワークライセンスの特徴 ", 
"snippet" : "の インストール コマンドは、 CODESYS Network License Server (WIBU CodeMeter ランタイムを含む)。 ターゲット システムに Cockpit フレームワークがまだインストールされていない場合は、次のメッセージが表示されます。 コックピットフレームワークがすでにターゲットシステムにインストールされている場合は、 CODESYS コックピットプラグインは、操作するためにインストールされます CODESYS Network License Server 。 の 始める そして 停止 サービスを停止または開始する必要がないため、コマンドは無効になっています...", 
"body" : "の インストール コマンドは、 CODESYS Network License Server (WIBU CodeMeter ランタイムを含む)。 ターゲット システムに Cockpit フレームワークがまだインストールされていない場合は、次のメッセージが表示されます。 コックピットフレームワークがすでにターゲットシステムにインストールされている場合は、 CODESYS コックピットプラグインは、操作するためにインストールされます CODESYS Network License Server 。 の 始める そして 停止 サービスを停止または開始する必要がないため、コマンドは無効になっています。 の オープンコックピット コマンドは、デフォルトのブラウザで Linux デバイスの Web ベースの管理を開きます。 " }, 
{ "title" : "ネットワークライセンスの有効化 ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234373989651141", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ コントローラのライセンス \/ ネットワークライセンス \/ ネットワークライセンスの有効化 ", 
"snippet" : "ライセンスチケットをアクティブ化するには CODESYS Network License Server 次の手順に従います。 クリック オープンコックピット ボタンをクリックするとブラウザでウェブベースの管理が開きます これには通常の Linux ログインを使用します。 クリック コードシスWBM （１）→ CODESYSライセンス （2）ボタン。 シリアル番号（1）をコピーします。 シリアル番号を入力してください シリアルナンバー （２）分野 チケット番号を入力してください チケット フィールド（３）。 クリック チケットを有効にする ボタン。 ページの下部にある概要をチェックして、必要な記...", 
"body" : "ライセンスチケットをアクティブ化するには CODESYS Network License Server 次の手順に従います。 クリック オープンコックピット ボタンをクリックするとブラウザでウェブベースの管理が開きます これには通常の Linux ログインを使用します。 クリック コードシスWBM （１）→ CODESYSライセンス （2）ボタン。 シリアル番号（1）をコピーします。 シリアル番号を入力してください シリアルナンバー （２）分野 チケット番号を入力してください チケット フィールド（３）。 クリック チケットを有効にする ボタン。 ページの下部にある概要をチェックして、必要な記事と製品コード (チケットの一部) がネットワーク ライセンス サーバーにインストールされていることを確認します。 デフォルトでは、 CODESYS Network License Server パッケージは、ライセンスをインストールできるライセンスコンテナを作成します。新しいコンテナを作成する場合は、次の手順に従ってください。 コピー *.WibuCmLif ファイルから CODESYS Network License Server コンピューターに接続します (たとえば、SSH クライアントまたは SCP を使用)。 ウェブベースの管理では、 ブラウズ ボタンの 新しいコンテナを作成する セクションで、以前に保存したファイルを選択します。 クリック 作成する ボタン。 ページの下部にある概要をチェックして、新しいコンテナが作成されたことを確認します。 エラーが発生した場合は、 ログ ページ。 " }, 
{ "title" : "ネットワークライセンスの使用 ", 
"url" : "_rtsl_license_controller_linux.html#UUID-53f421ed-1a14-45c3-9ab9-72e9a694ef91_section-idm234460444116218", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ コントローラのライセンス \/ ネットワークライセンス \/ ネットワークライセンスの使用 ", 
"snippet" : "コントローラが以前に設定されたライセンスサーバーを使用できるようにするには、これを構成に入力する必要があります。これを行うには、次の設定を追加する必要があります。 [CmpCodeMeter] セクションの \/etc\/codesyscontrol\/CODESYSControl_User.cfg ファイル： EnableNetLicenses=1 LicenseServer.1=<IP1> LicenseServer.2=<IP2>...", 
"body" : "コントローラが以前に設定されたライセンスサーバーを使用できるようにするには、これを構成に入力する必要があります。これを行うには、次の設定を追加する必要があります。 [CmpCodeMeter] セクションの \/etc\/codesyscontrol\/CODESYSControl_User.cfg ファイル： EnableNetLicenses=1\nLicenseServer.1=<IP1>\nLicenseServer.2=<IP2> " }, 
{ "title" : "バックアップと復元 CODESYS ライセンス ", 
"url" : "_rtsl_backup_restore_wibu.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ バックアップと復元 CODESYS ライセンス ", 
"snippet" : "これらの指示は、以下の製品には適用されません CODESYS Virtual Control SL 製品ファミリー。...", 
"body" : "これらの指示は、以下の製品には適用されません CODESYS Virtual Control SL 製品ファミリー。 " }, 
{ "title" : "Codemeter Embedded のライセンス ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4622936815712034049201310732", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ バックアップと復元 CODESYS ライセンス \/ Codemeter Embedded のライセンス ", 
"snippet" : "CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ ライセンスのバックアップと復元...", 
"body" : "CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ ライセンスのバックアップと復元 " }, 
{ "title" : "ライセンスのバックアップ ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4641146992569634049209836102", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ バックアップと復元 CODESYS ライセンス \/ Codemeter Embedded のライセンス \/ ライセンスのバックアップ ", 
"snippet" : "から接続を確立します CODESYS コントローラーに。 デバイス ツリーでコントローラーを選択し、 ファイル タブ。 右側のウィンドウで、更新アイコン ( ）。 コントローラで利用可能なファイルが表示されます。 左側のウィンドウで、バックアップを保存するディレクトリを選択します。 右側のウィンドウで、 cmact_licenses ディレクトリをクリックし、 ボタン。 ライセンス ディレクトリのバックアップ コピーがコンピュータ上に作成されます。 バックアップ コピーが正常に作成されたことを確認します。...", 
"body" : "から接続を確立します CODESYS コントローラーに。 デバイス ツリーでコントローラーを選択し、 ファイル タブ。 右側のウィンドウで、更新アイコン ( ）。 コントローラで利用可能なファイルが表示されます。 左側のウィンドウで、バックアップを保存するディレクトリを選択します。 右側のウィンドウで、 cmact_licenses ディレクトリをクリックし、 ボタン。 ライセンス ディレクトリのバックアップ コピーがコンピュータ上に作成されます。 バックアップ コピーが正常に作成されたことを確認します。 " }, 
{ "title" : "ライセンスの復元 ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm451020213344483404921010438", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ バックアップと復元 CODESYS ライセンス \/ Codemeter Embedded のライセンス \/ ライセンスの復元 ", 
"snippet" : "次のステップ 6 の手順を実行すると、データが失われる可能性があることに注意してください。したがって、これらの手順をよく読んでください。 から接続を確立します CODESYS コントローラーに。 デバイス ツリーでコントローラーを選択し、 ファイル タブ。 右側のウィンドウで、更新アイコン ( ）。 コントローラで利用可能なファイルが表示されます。 右側のウィンドウで、ターゲット ディレクトリを選択します。これは最上位のディレクトリである必要があります ( ストレージの場所 : \/ ) 左側のウィンドウで、コンピュータ上に以前に作成したバックアップ コピーを選択し、 ボタン。 バックアップ コ...", 
"body" : "次のステップ 6 の手順を実行すると、データが失われる可能性があることに注意してください。したがって、これらの手順をよく読んでください。 から接続を確立します CODESYS コントローラーに。 デバイス ツリーでコントローラーを選択し、 ファイル タブ。 右側のウィンドウで、更新アイコン ( ）。 コントローラで利用可能なファイルが表示されます。 右側のウィンドウで、ターゲット ディレクトリを選択します。これは最上位のディレクトリである必要があります ( ストレージの場所 : \/ ) 左側のウィンドウで、コンピュータ上に以前に作成したバックアップ コピーを選択し、 ボタン。 バックアップ コピーがコントローラにコピーされます。 同じ名前のディレクトリがすでに存在する場合は、そこに含まれるファイルを上書きするように求めるメッセージが表示されます。 注意: 「はい」を選択すると、バックアップ ディレクトリ内と同じ名前のすべてのファイルが既存のディレクトリから削除されます。同じ名前であっても、内容が同じであるとは限りません。したがって、必要なファイルを誤って上書きしないように注意してください。 バックアップ コピーが正常に転送されたら、コントローラーを再起動します。 " }, 
{ "title" : "コードメーター ランタイムのライセンス ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4592433740225634049202010617", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ バックアップと復元 CODESYS ライセンス \/ コードメーター ランタイムのライセンス ", 
"snippet" : "CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control Win SL CODESYS Control RTE SL...", 
"body" : "CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control Win SL CODESYS Control RTE SL " }, 
{ "title" : "ライセンスのバックアップ ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4582704430054434049230836628", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ バックアップと復元 CODESYS ライセンス \/ コードメーター ランタイムのライセンス \/ ライセンスのバックアップ ", 
"snippet" : "CodeMeter Runtime を使用する場合、バックアップを作成する必要はありません。...", 
"body" : "CodeMeter Runtime を使用する場合、バックアップを作成する必要はありません。 " }, 
{ "title" : "ライセンスの復元 ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4548752769854434049231197546", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ バックアップと復元 CODESYS ライセンス \/ コードメーター ランタイムのライセンス \/ ライセンスの復元 ", 
"snippet" : "ライセンスを復元する ライセンス要求ファイルの作成 で CODESYS ライセンスマネージャを開きます。 次の 2 つのダイアログで、 デバイス そして ソフトコンテナ 。 から接続を確立します CODESYS ライセンスを復元するコントローラにコピーします。 クリック ライセンスのインストール 、 選択する ライセンスのリクエスト をクリックして、 次 。 もし ソフトウェアベンダー フィールドが空の場合、企業コードを使用できます。会社コードを取得する方法については、「会社コードの取得」のセクションで説明しています ライセンスをインストールするコンテナを選択し、ライセンス要求ファイルをコンピ...", 
"body" : " ライセンスを復元する ライセンス要求ファイルの作成 で CODESYS ライセンスマネージャを開きます。 次の 2 つのダイアログで、 デバイス そして ソフトコンテナ 。 から接続を確立します CODESYS ライセンスを復元するコントローラにコピーします。 クリック ライセンスのインストール 、 選択する ライセンスのリクエスト をクリックして、 次 。 もし ソフトウェアベンダー フィールドが空の場合、企業コードを使用できます。会社コードを取得する方法については、「会社コードの取得」のセクションで説明しています ライセンスをインストールするコンテナを選択し、ライセンス要求ファイルをコンピュータ上で保存する場所を選択します。クリック 仕上げる 。 ライセンス更新ファイルのダウンロード を開きます。 ライセンスセントラル WebDepot 復元したいチケットIDを指定します。クリック 次 。 クリック ライセンスを復元する 。 右下にある をクリックします。 ファイルベースのライセンス転送 。 (ページに次のような記載がある場合 ライセンスの直接転送 場合は、すでに正しいページにアクセスしています)。 以前に作成したライセンス要求ファイルをアップロードし、クリックします。 リクエストをアップロードして今すぐ続行してください 。 クリック 今すぐライセンス更新ファイルをダウンロード ファイルをコンピュータに保存します。 ライセンスアップデートのインストール で CODESYS ライセンスマネージャを開きます。 次の 2 つのダイアログで、 デバイス そして ソフトコンテナ 。 から接続を確立します CODESYS ライセンスを復元するコントローラにコピーします。 クリック ライセンスのインストール 、 選択する ライセンスのインストール をクリックして、 次 。 ライセンスをインストールするコンテナを選択し、以前にダウンロードしたアップデート ファイル (拡張子: .WibuCmRaU ）。 クリック 仕上げる 。 数秒後、ライセンスがライセンス マネージャーに表示されます。 " }, 
{ "title" : "企業コードの取得 ", 
"url" : "_rtsl_backup_restore_wibu.html#UUID-57d4ee15-5742-5abd-e5e9-6b46481fad0b_section-idm4641146913656034049243306333", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 入門 \/ バックアップと復元 CODESYS ライセンス \/ コードメーター ランタイムのライセンス \/ 企業コードの取得 ", 
"snippet" : "を開きます。 ライセンスセントラル WebDepot 復元したいチケットIDを指定します。クリック 次 。 クリック ライセンスを復元する 。 右下にある をクリックします。 ファイルベースのライセンス転送 。 最初のポイントで指定した企業コードをコピーします。...", 
"body" : "を開きます。 ライセンスセントラル WebDepot 復元したいチケットIDを指定します。クリック 次 。 クリック ライセンスを復元する 。 右下にある をクリックします。 ファイルベースのライセンス転送 。 最初のポイントで指定した企業コードをコピーします。 " }, 
{ "title" : "構成と拡張 ", 
"url" : "_rtsl_configure_and_extend.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS Control Extension Package ", 
"url" : "_rtsl_extension.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概要 ", 
"url" : "_rtsl_extension_overview.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ 概要 ", 
"snippet" : "の CODESYS Control Extension Package は、独自のプログラムを Linux ランタイム システムおよび IEC アプリケーションに接続するためのさまざまなオプションとインターフェイスを提供します。 これにより、たとえば、PLCを制御したり、PLCからのイベントに応答したり、PLCまたはIECアプリケーションに独自の機能を追加したりできます。 最も重要なインターフェースと機能の概要については、以下を参照してください。注：「PLCの外部から」とは、Linuxシステムを使用していることを意味します。インターフェイスはLinuxシステムでのみ使用でき、別のデバイスでは使...", 
"body" : "の CODESYS Control Extension Package は、独自のプログラムを Linux ランタイム システムおよび IEC アプリケーションに接続するためのさまざまなオプションとインターフェイスを提供します。 これにより、たとえば、PLCを制御したり、PLCからのイベントに応答したり、PLCまたはIECアプリケーションに独自の機能を追加したりできます。 最も重要なインターフェースと機能の概要については、以下を参照してください。注：「PLCの外部から」とは、Linuxシステムを使用していることを意味します。インターフェイスはLinuxシステムでのみ使用でき、別のデバイスでは使用できませんが、ランタイムシステムプロセスの外部で使用できます。 外部イベントタスク：IECタスクの実行時間を自分で制御できます（PLCの外部から）。 イベントメカニズム：PLCの外部でIECアプリケーションのイベントに反応することができます（例：開始\/停止\/例外）。 PLCシェルへのアクセス：PLCの外部からPLCシェルにアクセスできます。 START \/ STOPスイッチ：非常に簡単な方法で、独自の開始\/停止スイッチ（PLCの外部）を接続できます。 外部関数の呼び出し：PLCの外部で実装されている独自の機能を非常に簡単に呼び出すことができます。 自分のI \/ Oをリンクする：PLCの外部で独自のI \/ O（例：ローカル）を簡単に接続できます。 拡張SDK：独自の関数をCコードで非常に簡単に実装でき、IECアプリケーションから使用できます。 共有メモリにデータを保持する：コントローラ内のSHM経由でアプリケーションからリテインデータを接続できます。 実施されたセキュリティ対策の概要、およびセキュリティ関連の通知については、以下を参照してください。 セキュリティメカニズム。 これらの新しいメカニズムとインターフェースは、主にLinux標準リソース（ファイル、ソケットなど）に基づくプロセス分離に基づいています。 とりわけ、「unixドメインソケット」が使用されるため、「リモート端末」はテクノロジー（Python、Cなど）に依存せずに実装できます。 独自のCコード（Extension SDK）を接続することは例外です。これは、動的ランタイムシステムコンポーネント（共有オブジェクト）の形式でここでコンパイルされたCコードが直接に追加されるためです。 CODESYS ランタイムシステムと実行。詳細については、以下を参照してください。 拡張SDK 。 サンプルは CODESYS Control Extension Package . のインストール・ディレクトリにあります。デフォルトでは、これは C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\Examples である。 " }, 
{ "title" : "セキュリティメカニズム ", 
"url" : "_rtsl_extension_security.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ セキュリティメカニズム ", 
"snippet" : "拡張APIは、ランタイムシステムに影響を与える包括的なオプションを提供します。その結果、ユーザーは必要なセキュリティ対策に注意を払う必要があります。 にとって CODESYS Control Extension Package 4.4.0.0以降、 codesysuser グループは、パッケージのインストール時に作成されます。拡張APIの一部の機能では、それらを使用するLinuxユーザーがメンバーである必要があります。 codesysuser グループ。次のコマンド（例として）を使用して、管理者権限を持つユーザーをこのグループに追加できます。 $ sudo adduser $USER code...", 
"body" : "拡張APIは、ランタイムシステムに影響を与える包括的なオプションを提供します。その結果、ユーザーは必要なセキュリティ対策に注意を払う必要があります。 にとって CODESYS Control Extension Package 4.4.0.0以降、 codesysuser グループは、パッケージのインストール時に作成されます。拡張APIの一部の機能では、それらを使用するLinuxユーザーがメンバーである必要があります。 codesysuser グループ。次のコマンド（例として）を使用して、管理者権限を持つユーザーをこのグループに追加できます。 $ sudo adduser $USER codesysuser この方法の背後にある理由は、メカニズムが \/var\/run\/codesysextension\/ および\/ var \/ opt \/ codesysextension \/作業ディレクトリ。これらには770の権限があり、 codesysuser グループ。これにより、許可されていないユーザーがランタイムシステムに干渉することがなくなります。 のすべてのメンバー codesysuser グループはランタイムシステムに影響を与える可能性があります。 次のメカニズムは、Unixドメインソケット（UDS）に基づいています。 外部イベントタスク イベントメカニズム PLCシェルへのアクセス 外部関数の呼び出し 自分のI \/ Oをリンクする IECプログラマーは、これらのメカニズムのそれぞれの機能ブロックのエラーコードを照会し、適切に対応する必要があります（例：接続の確立または終了）。 ワークロード攻撃を防ぐために、Unixピア（ U nix D オマイン S ockets）は、IECタスク自体と少なくとも同じ優先度またはより高い優先度を持つ必要があります。 UDSピアは、提供されている例、またはExtensionAPIの機能を使用するユーザー作成プログラムです。 この優先度は、のタスク構成に表示される優先度ではありません CODESYS 。 Linuxシステムでは、次の方法で判別できます。 htop 。これは、で割り当てられたIECタスクと同じ名前のタスクです。 CODESYS 。 The PLCシェル 「匿名ユーザー」が必要です。これが有効になっている場合、どのLinuxユーザーがPLCシェルを使用したかを追跡することはできません。 プロセスの分離により、 CODESYS Control Extension Package ユーザー認証の機能を提供しない（の観点から） CODESYS Development System ）。対応するLinuxユーザーまたはユーザー名をIECユーザーに割り当てることはできません。 その結果、IECアプリケーションのセキュリティを検討する際には、IECユーザーだけでなく、Linuxユーザーも考慮して管理する必要があります。 許可されたユーザーのみが、ランタイムシステムのLinuxシステムへの管理アクセス権を持つことができます。 プロセス分離を使用するインターフェースの場合、データが暗号化されずにシステムに渡されることを排除することはできません。これは、システムの管理者権限を持つ攻撃者がそれらを記録する可能性があることを意味します。 " }, 
{ "title" : "外部イベントタスク ", 
"url" : "_rtsl_extension_external_event_task.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ 外部イベントタスク ", 
"snippet" : "「外部イベントタスク」メカニズムを使用して、外部イベントを介してタスクをトリガーできます。 「Unixドメインソケット」は、プロセスの分離に使用されます。対応するソケットファイルは、外部イベント用にユーザーが選択した名前に従って、ターゲットシステムに配置されます。 \/var\/run\/codesyscontrolapi\/eventtasks\/<EventName>.sock...", 
"body" : "「外部イベントタスク」メカニズムを使用して、外部イベントを介してタスクをトリガーできます。 「Unixドメインソケット」は、プロセスの分離に使用されます。対応するソケットファイルは、外部イベント用にユーザーが選択した名前に従って、ターゲットシステムに配置されます。 \/var\/run\/codesyscontrolapi\/eventtasks\/<EventName>.sock " }, 
{ "title" : "「外部イベント」タイプのタスクを作成する ", 
"url" : "_rtsl_extension_external_event_task.html#UUID-3c54739a-5fc2-8bad-4ca3-572d189df031_fe5af4cc6c60dcbcc0a8646324da24c1_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ 外部イベントタスク \/ 「外部イベント」タイプのタスクを作成する ", 
"snippet" : "外部イベントを作成します。 デバイスツリーで、 タスク構成 コンテキストメニューでクリックします 外部イベントを管理する （1）。の中に 外部イベントを管理する ダイアログ（2）で、新しいイベントを追加します。名前にスペースや特殊文字を含めることはできません。 → タスクを新しい外部イベントタスクとして構成します。 の中に タスク構成 リストボックスで、タスクを選択します。の中に タイプ リストボックスで、最近利用可能なものを選択します 外部の タスクタイプ（3）。必要なものを割り当てます 外部イベント （4）タスクに。 → 提供されたサンプルプロジェクト 外部イベントタスクプロジェクト 上記...", 
"body" : "外部イベントを作成します。 デバイスツリーで、 タスク構成 コンテキストメニューでクリックします 外部イベントを管理する （1）。の中に 外部イベントを管理する ダイアログ（2）で、新しいイベントを追加します。名前にスペースや特殊文字を含めることはできません。 → タスクを新しい外部イベントタスクとして構成します。 の中に タスク構成 リストボックスで、タスクを選択します。の中に タイプ リストボックスで、最近利用可能なものを選択します 外部の タスクタイプ（3）。必要なものを割り当てます 外部イベント （4）タスクに。 → 提供されたサンプルプロジェクト 外部イベントタスクプロジェクト 上記の設定が含まれています。タスクはに割り当てられます マイイベント (1) 外部イベントとファイル \/var\/opt\/codesyscontrolapi\/eventtasks\/MYEVENT1.sock がシステム上に作成されます。 「socat」コマンドラインツールを使用すると、たとえば次のコマンドを使用して、このインターフェイスを非常に簡単に操作できます。 $ socat - UNIX-CLIENT:\/var\/opt\/codesyscontrolapi\/eventtasks\/MYEVENT1.sock これにより、ターミナルウィンドウでソケット接続が確立され、個々のメッセージをソケットに送信できるようになります。 メッセージごとに、PLCで設定されているタスクがトリガーされます。メッセージの内容は、外部イベントのトリガーには関係ありません。メッセージの長さは1バイトとして指定されます。 Linuxのメンバーとしてのみインターフェースを使用する codesyscontrolapi ユーザーグループ はい プロセス分離 はい " }, 
{ "title" : "イベントメカニズム ", 
"url" : "_rtsl_extension_event_mechanism.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ イベントメカニズム ", 
"snippet" : "ランタイムシステムは、「イベント」を使用して、PLCの開始\/停止\/リセット、例外の発生などのイベントを通信します。 「イベントメカニズム」を使用すると、選択したイベントがトリガーされるとすぐにメッセージを受信することができます。 次のアプリケーション関連のイベントが転送されます。 EVT_StartDone EVT_StopDone EVT_ResetDone EVT_ExitDone EVT_AllBootprojectsLoaded EVT_CmpApp_Exception EVT_StateChanged EVT_CmpDevice_InteractiveLogin EVT_CmpMgr...", 
"body" : "ランタイムシステムは、「イベント」を使用して、PLCの開始\/停止\/リセット、例外の発生などのイベントを通信します。 「イベントメカニズム」を使用すると、選択したイベントがトリガーされるとすぐにメッセージを受信することができます。 次のアプリケーション関連のイベントが転送されます。 EVT_StartDone EVT_StopDone EVT_ResetDone EVT_ExitDone EVT_AllBootprojectsLoaded EVT_CmpApp_Exception EVT_StateChanged EVT_CmpDevice_InteractiveLogin EVT_CmpMgr_LicenseState SysGraphic_EVT_OpenKeyboard SysGraphic_EVT_CloseKeyboard 配信 uds_events.py サンプルは CODESYS_EventHandler イベントへの登録を実装するクラス。 このクラスには eventid だけでなく、 componentid of 登録するイベントの liEvents リスト： liEvents = {\n \"CmpApp_EVT_StartDone\" : (0x00000002, 0x10000 + 2),\n \"CmpApp_EVT_StopDone\" : (0x00000002, 0x10000 + 4),\n \"CmpApp_EVT_ResetDone\" : (0x00000002, 0x10000 + 6),\n \"CmpApp_EVT_ExitDone\" : (0x00000002, 0x10000 + 15),\n \"CmpApp_EVT_AllBootprojectsLoaded\" : (0x00000002, 0x10000 + 25),\n \"CmpApp_EVT_CmpApp_Exception\" : (0x00000002, 0x00080000 + 28),\n \"CmpApp_EVT_StateChanged\" : (0x00000002,0x10000 + 43),\n \"CmpDevice_EVT_CmpDevice_InteractiveLogin\" : (0x0000000E, 0x00010000+ 1),\n \"CmpMgr_EVT_LicenseState\" : (0x00000001, 0x00010000 + 9),\n \"SysGraphic_EVT_OpenKeyboard\" : (0x00000142, 0x00010000 + 1),\n \"SysGraphic_EVT_CloseKeyboard\" : (0x00000142, 0x00010000 + 2,\n} さらに、イベントが発生したときに呼び出されるコールバック関数を指定する必要があります。 def callbackfunction_start(componentid, eventid):\n print(\"Start event occured\") 以内に Main 、イベントは次のように登録され、必要なコールバック関数が指定されます。 componentid, eventid = liEvents[\"CmpApp_EVT_StartDone\"]\nmyEventHandler_Start = CODESYS_EventHandler(componentid, eventid, callbackfunction_start)\nmyEventHandler_Start.start() 今コールバック関数 callbackfunction_start ランタイムシステムがStartに変更されるとすぐに呼び出されます。 基になるメカニズムを次の図に示します。 Linuxのメンバーとしてのみインターフェースを使用する codesysuser ユーザー・グループ はい プロセス分離 はい " }, 
{ "title" : "PLCシェルへのアクセス ", 
"url" : "_rtsl_extension_accessing_plc_shell.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ PLCシェルへのアクセス ", 
"snippet" : "拡張 API は PLC シェルへの外部アクセスを可能にします。この機能では、「Unix ドメインソケット」が使用され、ランタイムシステムはこれを使用して着信コマンドを受信し、対応する応答を送信します。対応するソケットファイルは \/var\/opt\/codesyscontrolapi\/plcshell.sock 。 この機能を使用するには、ランタイムシステムで「匿名ユーザー」を許可する必要があります。匿名ログインの許可は、 通信設定 のデバイスの コミュニケーションポリシーの変更 ダイアログ（1）： 匿名ログインを許可する オプション（2）。...", 
"body" : "拡張 API は PLC シェルへの外部アクセスを可能にします。この機能では、「Unix ドメインソケット」が使用され、ランタイムシステムはこれを使用して着信コマンドを受信し、対応する応答を送信します。対応するソケットファイルは \/var\/opt\/codesyscontrolapi\/plcshell.sock 。 この機能を使用するには、ランタイムシステムで「匿名ユーザー」を許可する必要があります。匿名ログインの許可は、 通信設定 のデバイスの コミュニケーションポリシーの変更 ダイアログ（1）： 匿名ログインを許可する オプション（2）。 " }, 
{ "title" : "例 ", 
"url" : "_rtsl_extension_accessing_plc_shell.html#UUID-f4776bb8-9dd5-0306-cfe0-2ef01425a6f9_e67b71746d20c0a8646363fbfe36_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ PLCシェルへのアクセス \/ 例 ", 
"snippet" : "必要条件 ランタイムシステムは「匿名ユーザー」を許可しています。 Linuxシステムにログインしました。 ユーザーはに割り当てられています codesyscontrolapi グループ。 ターミナル経由の手動アクセス 次のコマンドを実行します。 $ socat - UNIX-CLIENT:\/var\/opt\/codesyscontrolapi\/plcshell.sock これで、ターミナルでPLCシェルのコマンドを実行できます。 サンプルスクリプト コピー plcshell.py 提供されている例からLinuxシステムまで。 スクリプトを実行します。 Pythonスクリプトは、PLCシェルを使用...", 
"body" : "必要条件 ランタイムシステムは「匿名ユーザー」を許可しています。 Linuxシステムにログインしました。 ユーザーはに割り当てられています codesyscontrolapi グループ。 ターミナル経由の手動アクセス 次のコマンドを実行します。 $ socat - UNIX-CLIENT:\/var\/opt\/codesyscontrolapi\/plcshell.sock これで、ターミナルでPLCシェルのコマンドを実行できます。 サンプルスクリプト コピー plcshell.py 提供されている例からLinuxシステムまで。 スクリプトを実行します。 Pythonスクリプトは、PLCシェルを使用して一連のコマンドを順番に実行し、PythonでのPLCシェルの使用法を示します。 詳細については、以下を参照してください。 タブ：<デバイス名> PLCシェル Linuxのメンバーとしてのみインターフェースを使用する codesyscontrolapi ユーザーグループ はい プロセス分離 はい " }, 
{ "title" : "START \/ STOPスイッチ ", 
"url" : "_rtsl_extension_start_stop_switch.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ START \/ STOPスイッチ ", 
"snippet" : "START \/ STOPスイッチは、PLCを開始または停止状態に設定するために使用できる物理スイッチを表します。 このメカニズムは、次の場合に有効です。 \/var\/opt\/codesyscontrolapi\/runstop.switch 存在します。注意:拡張パッケージの他の機能とは異なり、中のファイルは \/var\/opt\/codesyscontrolapi\/ が照会されます。このファイルはランタイムシステムでは作成されません。START\/STOP 関数を使用する場合はファイルを作成する必要があります。内容が runstop.switch は \"RUN 「、PLC が起動します。内容が異なる場...", 
"body" : "START \/ STOPスイッチは、PLCを開始または停止状態に設定するために使用できる物理スイッチを表します。 このメカニズムは、次の場合に有効です。 \/var\/opt\/codesyscontrolapi\/runstop.switch 存在します。注意:拡張パッケージの他の機能とは異なり、中のファイルは \/var\/opt\/codesyscontrolapi\/ が照会されます。このファイルはランタイムシステムでは作成されません。START\/STOP 関数を使用する場合はファイルを作成する必要があります。内容が runstop.switch は \"RUN 「、PLC が起動します。内容が異なる場合、PLCは停止に設定されます。 スイッチファイルは周期的に読み取られます。 PLCは、実行時に停止および開始できます。 の場合 runstop.switch ファイルは実行時に削除され、コンポーネントはその機能を失い、PLCが起動します。 制約事項：ハードウェアにSTART \/ STOPスイッチが組み込まれているLinuxベースのSL製品は、このメカニズムをサポートしていません。これらには、次の製品が含まれます。 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for WAGO Touch Panel 600 Linuxのメンバーとしてのみインターフェースを使用する codesyscontrolapi ユーザーグループ はい プロセス分離 はい " }, 
{ "title" : "外部関数の呼び出し ", 
"url" : "_rtsl_extension_calling_external_function.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ 外部関数の呼び出し ", 
"snippet" : "このメカニズムは、Unixドメインソケットを介してIECアプリケーションの外部関数を呼び出すために使用できます。これにより、独自の機能を作成できます。同時に、プロセスの分離が達成されます。 IECのインターフェースとして、 EXTAPI.UDSExternalFunction 機能ブロックは、 ExtensionAPI ライブラリ。Pythonでは、 ExternalFunctionBase クラスはこの目的で使用されます。これは、提供されている例で提供されています。 この例では、メカニズムの使用方法についても説明します。この例には、外部関数の呼び出しが実装された IEC プロジェクトが含まれ...", 
"body" : "このメカニズムは、Unixドメインソケットを介してIECアプリケーションの外部関数を呼び出すために使用できます。これにより、独自の機能を作成できます。同時に、プロセスの分離が達成されます。 IECのインターフェースとして、 EXTAPI.UDSExternalFunction 機能ブロックは、 ExtensionAPI ライブラリ。Pythonでは、 ExternalFunctionBase クラスはこの目的で使用されます。これは、提供されている例で提供されています。 この例では、メカニズムの使用方法についても説明します。この例には、外部関数の呼び出しが実装された IEC プロジェクトが含まれています。さらに、この例には、呼び出される関数の実装が含まれています。 myExternalFunction Pythonで。 CODESYS Control Extension Package がインストールされると、以下のディレクトリに UDSExternalCallExample.project の例とPythonスクリプト uds_external_function.py がある： C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\Examples\\ExternalCall . " }, 
{ "title" : "例、IECアプリケーション ", 
"url" : "_rtsl_extension_calling_external_function.html#UUID-a1f120f1-d7f7-9c1c-f2c1-f02f0f73aa23_c32c4ba6c484ae1c0a864634bce6538_id_da88391a8bc94ccdc0a864631f91843d", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ 外部関数の呼び出し \/ 例、IECアプリケーション ", 
"snippet" : "の中に UDSExternalCallExample.project サンプルプロジェクト、新しい myExternalFunction 機能ブロックが作成されます。これにより、 EXTAPI.UDSExternalFunction タイプの入力と出力を備えたFB DINT 。他のデータ型も可能です。最初に、Pythonで呼び出される関数の名前を渡す必要があります。このアドレスは一意である必要があります。 次のコードは、インターフェイスの外部関数の入力を追加するために使用されます。 Result := THIS^.AddParameter('parameterIn1', 'DINT', TO_...", 
"body" : "の中に UDSExternalCallExample.project サンプルプロジェクト、新しい myExternalFunction 機能ブロックが作成されます。これにより、 EXTAPI.UDSExternalFunction タイプの入力と出力を備えたFB DINT 。他のデータ型も可能です。最初に、Pythonで呼び出される関数の名前を渡す必要があります。このアドレスは一意である必要があります。 次のコードは、インターフェイスの外部関数の入力を追加するために使用されます。 Result := THIS^.AddParameter('parameterIn1', 'DINT', TO_STRING(diIn1)); 次に、次のコードを使用して外部関数を呼び出します。 Result := THIS^.Call(); 次のコードは、Pythonで実装された関数の戻り値をクエリするために使用されます。 Result := THIS^.GetParameter('parameterOut', 'DINT', ADR(sValue)); パラメータはタイプです string 。したがって、目的のデータ型にキャストする必要があります。 " }, 
{ "title" : "例、Pythonスクリプト ", 
"url" : "_rtsl_extension_calling_external_function.html#UUID-a1f120f1-d7f7-9c1c-f2c1-f02f0f73aa23_c32c4ba6c484ae1c0a864634bce6538_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ 外部関数の呼び出し \/ 例、Pythonスクリプト ", 
"snippet" : "拡張 API 用に提供されている Python の例では、Python 3.0 が必要です。 含まれています uds_external_function.py サンプルは ExternalFunctionBase この機能のためにランタイムシステムとのUnixドメインソケット通信を提供するクラス。 The myExternalFunction 例で実装されたクラスは、 ExternalFunctionBase クラス。 Call() IECのメカニズムから呼び出される関数が必要です。入力パラメータと出力パラメータは、文字列のタプルの形式で渡されます。 例： {'parameterIn1': (...", 
"body" : "拡張 API 用に提供されている Python の例では、Python 3.0 が必要です。 含まれています uds_external_function.py サンプルは ExternalFunctionBase この機能のためにランタイムシステムとのUnixドメインソケット通信を提供するクラス。 The myExternalFunction 例で実装されたクラスは、 ExternalFunctionBase クラス。 Call() IECのメカニズムから呼び出される関数が必要です。入力パラメータと出力パラメータは、文字列のタプルの形式で渡されます。 例： {'parameterIn1': ('DINT', '11'), 'parameterIn2': ('DINT', '22')} 例では、 Call() 関数は、2つの入力パラメーターの単純な追加を実装します。 def Call(self, dictParams):\n in1 = int(dictParams['parameterIn1'][1])\n in2 = int(dictParams['parameterIn2'][1])\n\n dictRetParams = {}\n dictRetParams['parameterOut'] = 'DINT', in1 + in2\n\n return dictRetParams スクリプト uds_external_function.py ( CODESYS Control Extension Package をインストールした後のディレクトリ C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\Examples\\ExternalCall にある）をターゲット・デバイスにコピーします。 スクリプトを実行する uds_external_function.py 。 次に、 UDSExternalCallExample.project のサンプルプロジェクト CODESYS 。 プロジェクトが myExternalFunction() Python スクリプトの関数と 2 つの入力パラメータが追加されます。 Linuxのメンバーとしてのみインターフェースを使用する codesysuser ユーザー・グループ はい プロセス分離 はい " }, 
{ "title" : "自分のI \/ Oをリンクする ", 
"url" : "_rtsl_extension_connecting_user_ios.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ 自分のI \/ Oをリンクする ", 
"snippet" : "この機能により、ローカルI \/ Oをコントローラーに接続し、IECアプリケーションから使用できます。...", 
"body" : "この機能により、ローカルI \/ Oをコントローラーに接続し、IECアプリケーションから使用できます。 " }, 
{ "title" : "デバイスの説明を編集する ", 
"url" : "_rtsl_extension_connecting_user_ios.html#UUID-13dba825-3390-b677-ab9e-c88d5217ab74_a82230b6c3b57c1c0a86463472f7ec5_id_f93f1df46d57d55ac0a864632a96c684", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ 自分のI \/ Oをリンクする \/ デバイスの説明を編集する ", 
"snippet" : "提供されているサンプル UDSIoDrvExample.project では、2 つの入力と出力がデバイス記述と一緒に作成されています。入力と出力はUnixドメイン・ソケットを介してリンクされています。このサンプルは、 CODESYS 子目录 CODESYS Control SL Extension Package\\<version>\\Examples\\ExternalIoDrv . 独自の入力と出力を定義するには、デバイス記述ファイル SocketUnixIOTemplate.devdesc.xml 適応させる必要があります。 XML parameter 要素は、入力と出力のそれぞれに対して...", 
"body" : "提供されているサンプル UDSIoDrvExample.project では、2 つの入力と出力がデバイス記述と一緒に作成されています。入力と出力はUnixドメイン・ソケットを介してリンクされています。このサンプルは、 CODESYS 子目录 CODESYS Control SL Extension Package\\<version>\\Examples\\ExternalIoDrv . 独自の入力と出力を定義するには、デバイス記述ファイル SocketUnixIOTemplate.devdesc.xml 適応させる必要があります。 XML parameter 要素は、入力と出力のそれぞれに対して定義する必要があります。 ParameterId ここでは、デバイス記述ファイル内で一意である必要があります。ギャップなしで昇順で番号を付けることをお勧めします。例：1000 1001 1002など：入力には1000から、出力には2000から番号を付けます。 デバイスの説明を変更した場合は、プロジェクトで使用できるようにデバイスリポジトリに再インストールする必要があります。 <Parameter ParameterId=\"1000\" type=\"std:DWORD\">\n <Attributes channel=\"input\"\/>\n <Default\/>\n <Name name=\"local:in1\">\/Namne>\n<\/Parameter> 名前 説明 ParameterId 入力または出力が呼び出される一意のID タイプ 入力または出力の幅の定義。これは、次のような適切に広いデータ型を指定することによって行われます。 std:BYTE 、 std:WORD 、 std:DWORD 、 また std:LWORD 。他の単純なデータ型も許可されます。 属性チャネル input また output 名前名前 それぞれの入力または出力の名前 さらに、デバイスIDを割り当てる必要があります。これは、 <DeviceIdentification> 。0x00018000〜0x0001 80FFの範囲は、既存のデバイスとの衝突を回避するためにこの目的のために提供されています。 モジュールの順序は固定されていないため、デバイスの説明と基盤となるI \/ Oドライバを1つのPLCで複数回インスタンス化しないでください。これにより、I \/ Oドライバーが割り当てを保証できなくなる可能性があります。 " }, 
{ "title" : "Pythonの例 ", 
"url" : "_rtsl_extension_connecting_user_ios.html#UUID-13dba825-3390-b677-ab9e-c88d5217ab74_a82230b6c3b57c1c0a86463472f7ec5_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ 自分のI \/ Oをリンクする \/ Pythonの例 ", 
"snippet" : "Pythonの例では uds_io_driver.py 、出力が受信され、デバイスの入力が書き込まれます。入力パラメータ（IEC出力）は、文字列のタプルとして渡されます（ paramType 、 paramValue ）デバイス記述のパラメータIDをインデックスとして使用します。 ドライバーはデータ型を処理できます USINT 、 UINT 、 UDINT 、 と ULINT 。他のデータ型は、適切なデータ型にキャストする必要があります。 例： （ '2000': ('UDINT', '11'), '2001': ('UDINT', '22')} 。出力パラメータは同じ形式です。 ピアの場合も...", 
"body" : "Pythonの例では uds_io_driver.py 、出力が受信され、デバイスの入力が書き込まれます。入力パラメータ（IEC出力）は、文字列のタプルとして渡されます（ paramType 、 paramValue ）デバイス記述のパラメータIDをインデックスとして使用します。 ドライバーはデータ型を処理できます USINT 、 UINT 、 UDINT 、 と ULINT 。他のデータ型は、適切なデータ型にキャストする必要があります。 例： （ '2000': ('UDINT', '11'), '2001': ('UDINT', '22')} 。出力パラメータは同じ形式です。 ピアの場合も、「出力」\/出力パラメータは、それでもIECアプリケーションによって「外部」に転送される出力値です（たとえば、実際のGPIOに書き出されます）。 The UDS_IODriver_0 例で実装されたクラスは、 ExternalFunctionBase class。クラスの名前はから派生しています UDS_IODriver_ 昇順でインスタンスインデックスが続きます。 Call() IECのメカニズムから呼び出される機能が必要です。ここでIEC出力を評価し、IEC入力を転送することができます。 Linuxのメンバーとしてのみインターフェースを使用する codesysuser ユーザー・グループ はい プロセス分離 はい " }, 
{ "title" : "共有メモリにデータを保持する ", 
"url" : "_rtsl_extension_retains_in_shared_memory.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ 共有メモリにデータを保持する ", 
"snippet" : "一部の製品には、コントローラー内のアプリケーションからの保持データの自動接続が含まれていません（一般的に有効なストレージオプションがないため）。ただし、ランタイムシステムには、共有メモリ（SHM）を介した接続による既存のメカニズムがあり、それぞれの構成でこの目的に使用できます。 たとえば、次のように使用できます。 CODESYS Control SL製品： CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control for Raspberry P...", 
"body" : "一部の製品には、コントローラー内のアプリケーションからの保持データの自動接続が含まれていません（一般的に有効なストレージオプションがないため）。ただし、ランタイムシステムには、共有メモリ（SHM）を介した接続による既存のメカニズムがあり、それぞれの構成でこの目的に使用できます。 たとえば、次のように使用できます。 CODESYS Control SL製品： CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control for Raspberry Pi CODESYS Control for BeagleBone バージョンノート：の最小バージョン CODESYS Control SL製品はV4.4.0.0（ CODESYS Control バージョン3.5.17.30） 基本的に、「保持」は、SHMを介して次の設定で有効になります。 \/etc\/CODESYSControl_User.cfg ターゲットデバイス上： [CmpApp]\n RetainType.Applications=InSHM [CmpRetain]\n Retain.SHM.Size=0x1FFFF ; Total size of remanent memory in bytes\n Retain.SHM.Name=MyRetainMemory ; Optional (Default: \"RetainMemory\") 再起動後、ランタイム システムは設定された名前で共有メモリ ファイルを作成します。 \/dev\/shm .このファイルをマッピングすることにより、たとえば次のコマンドを使用して、メモリを任意の不揮発性ファイルにリダイレクトできます。 sudo touch \/dev\/shm\/MyRetainMemory\nsudo mount -o bind \/var\/opt\/MyRetainMemory \/dev\/shm\/MyRetainMemory PLCアプリケーションで設定されたサイクルタイムに従って、ファイルに周期的にアクセスします。したがって、SHMファイルをフラッシュベースのファイルシステム内のファイルにリダイレクトしないでください。リダイレクトしないと、メモリが破壊されるリスクがあります。 " }, 
{ "title" : "拡張SDK ", 
"url" : "_rtsl_extension_extension_sdk.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ 拡張SDK ", 
"snippet" : "Extension SDKを使用すると、Cで独自の関数を実装し、IECアプリケーションからそれらを呼び出すことができます。 この接続では、Cコードは個別の動的コンポーネントの形式でランタイムシステムに統合されます（ shared object ）。 含めるには2つの方法があります。 コントローラで準備：動的コンポーネントはすでに次のように構成されています CODESYS ランタイムシステム（ shared object 存在し、Linuxシステムで構成されています）。次に、それぞれのIECライブラリのみが必要です。 統合された動的コンポーネントを備えたIECライブラリの形式。 Linuxシステ...", 
"body" : "Extension SDKを使用すると、Cで独自の関数を実装し、IECアプリケーションからそれらを呼び出すことができます。 この接続では、Cコードは個別の動的コンポーネントの形式でランタイムシステムに統合されます（ shared object ）。 含めるには2つの方法があります。 コントローラで準備：動的コンポーネントはすでに次のように構成されています CODESYS ランタイムシステム（ shared object 存在し、Linuxシステムで構成されています）。次に、それぞれのIECライブラリのみが必要です。 統合された動的コンポーネントを備えたIECライブラリの形式。 Linuxシステム自体で何も準備する必要はありません。 IECライブラリを使用する場合、動的コンポーネントは自動的に CODESYS ランタイムシステムと使用。 どちらの場合も、ユーザーはを作成できる必要があります shared object これは、ランタイムシステム（x64 \/ ARM6 \/ ARM7 \/ AARCH64）のアーキテクチャに適しています。ExtensionSDKは、この種の動的コンポーネントの作成をサポートします。 (shared object ）。 次に、両方のバリアントのライブラリと動的コンポーネントを作成する方法について説明します。 " }, 
{ "title" : "開発環境 ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_3742f1416db55357c0a864630d1ff3cd", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ 拡張SDK \/ 開発環境 ", 
"snippet" : "開発環境 開ける CODESYS 新しいライブラリを作成します。 ライブラリのタイトルを設定します（ プロジェクト情報 、 概要 タブ）そして同じ名前でライブラリを保存します。 必要な機能を追加し、それらにマークを付けます 外部実装 。 プロジェクトナビゲータの関数のコンテキストメニューで、をクリックします。 プロパティ 。に 建てる タブで、 外部実装 。 注：関数には「 _cext \" 名前に。 次に、* cファイルと* m4ファイルを生成します。 クリック ビルド→ランタイムシステムファイルの生成 。 選択する M4インターフェースファイル と Cスタブファイル 。 保存場所を選択します...", 
"body" : "開発環境 開ける CODESYS 新しいライブラリを作成します。 ライブラリのタイトルを設定します（ プロジェクト情報 、 概要 タブ）そして同じ名前でライブラリを保存します。 必要な機能を追加し、それらにマークを付けます 外部実装 。 プロジェクトナビゲータの関数のコンテキストメニューで、をクリックします。 プロパティ 。に 建てる タブで、 外部実装 。 注：関数には「 _cext \" 名前に。 次に、* cファイルと* m4ファイルを生成します。 クリック ビルド→ランタイムシステムファイルの生成 。 選択する M4インターフェースファイル と Cスタブファイル 。 保存場所を選択します。 " }, 
{ "title" : "Linux ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_8bf074606db55357c0a864636bb48d02", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ 拡張SDK \/ Linux ", 
"snippet" : "拡張SDKを、ターゲットシステムに対応するコンパイル環境を持つLinuxシステムにコピーします。 デフォルトでは、ExtensionSDKは次の場所にあります。 C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\ExtensionSDK . 以下のステップでは、このディレクトリを <SDK DIR> 呼ぶ。 C実装を作成する新しいフォルダーを作成します。このフォルダは次の場所にあります <PROJECT DIR> 。 案内する <PROJECT DIR> 実行します...", 
"body" : "拡張SDKを、ターゲットシステムに対応するコンパイル環境を持つLinuxシステムにコピーします。 デフォルトでは、ExtensionSDKは次の場所にあります。 C:\\Program Files\\CODESYS <version>\\CODESYS\\CODESYS Control SL Extension Package\\<version>\\ExtensionSDK . 以下のステップでは、このディレクトリを <SDK DIR> 呼ぶ。 C実装を作成する新しいフォルダーを作成します。このフォルダは次の場所にあります <PROJECT DIR> 。 案内する <PROJECT DIR> 実行します： $ make -f <SDKDIR>\/makefile newproject 開発環境で作成した* cおよび* m4ファイルをにコピーします <PROJECT DIR> 。 Cで関数を実装します。 共有オブジェクトを作成します。 $ make all The shared object 生成され、に配置されます <PROJECT DIR>\/out\/libCmpMyTest.so 。 その結果、動的コンポーネントが作成され、IECライブラリを介してIECアプリケーションから呼び出すことができるようになりました。ビルドプロセスの詳細（ make ）makefilesおよび README file 拡張SDKで。 次に、コンポーネントを含める次の2つの方法のいずれかを決定します。 " }, 
{ "title" : "動的コンポーネントを含む ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_section-idm234821879525116", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ 拡張SDK \/ 動的コンポーネントを含む ", 
"snippet" : "コンポーネントを含めるには、次のオプションがあります。...", 
"body" : "コンポーネントを含めるには、次のオプションがあります。 " }, 
{ "title" : "ターゲットデバイスに動的コンポーネントを含める ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_e85c7db98c25e844c0a864634a8e2492", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ 拡張SDK \/ 動的コンポーネントを含む \/ ターゲットデバイスに動的コンポーネントを含める ", 
"snippet" : "このメソッドを使用すると、以前にCで作成した共有オブジェクトをランタイムシステムに含めることができます。ユーザーに追加のシステム権限は必要ありません。ライブラリは、使い慣れた方法を使用してデバイスにロールアウトできます。 上で作成した共有オブジェクトをランタイムシステムにコピーします。 共有オブジェクトをにコピーします \/usr\/lib\/ または、システムによってライブラリが検出される同等のライブラリディレクトリ。 ランタイムシステムを停止します（例： $ sudo \/etc\/init.d\/codesyscontrol stop ）。 開ける \/etc\/CODESYSControl_User....", 
"body" : "このメソッドを使用すると、以前にCで作成した共有オブジェクトをランタイムシステムに含めることができます。ユーザーに追加のシステム権限は必要ありません。ライブラリは、使い慣れた方法を使用してデバイスにロールアウトできます。 上で作成した共有オブジェクトをランタイムシステムにコピーします。 共有オブジェクトをにコピーします \/usr\/lib\/ または、システムによってライブラリが検出される同等のライブラリディレクトリ。 ランタイムシステムを停止します（例： $ sudo \/etc\/init.d\/codesyscontrol stop ）。 開ける \/etc\/CODESYSControl_User.cfg 管理者権限を持つ： $ sudo nano \/etc\/CODESYSControl_User.cfg の中に [ComponentManager] セクションで、作成した共有オブジェクトを追加します。 [ComponentManager]\nComponent.1=CmpFirstTest\nComponent.2=CmpSomeOtherComponent\n... 注：番号は増分番号であり、既存のコンポーネントと競合してはなりません。 ランタイムシステムを起動します。 $ sudo \/etc\/init.d\/codesyscontrol start これで、コンポーネントがロードされているかどうかを確認できます。 $ cat \/tmp\/codesyscontrol.log " }, 
{ "title" : "動的コンポーネントをIECライブラリに含める ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_4cf431216db55357c0a86463621d9489", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ 拡張SDK \/ 動的コンポーネントを含む \/ 動的コンポーネントをIECライブラリに含める ", 
"snippet" : "「Cコード統合」機能を使用して、動的コンポーネントをIECライブラリに追加します。詳細については、を参照してください。 Cコード統合 一般的なヘルプで。 IECライブラリを開きます。 の POU 、を追加します C-実装ライブラリ 物体。 このオブジェクトに、 デバイスのオブジェクトファイル ： 以前に作成した動的コンポーネント（ファイル）を選択して追加します。 適切なコンポーネント名を指定してください。 適切なデバイスを選択してください。 これで、選択したデバイスでこのライブラリを使用すると、動的コンポーネントがランタイムシステムに自動的に追加され、ライブラリのPOUを使用して呼び出すことが...", 
"body" : "「Cコード統合」機能を使用して、動的コンポーネントをIECライブラリに追加します。詳細については、を参照してください。 Cコード統合 一般的なヘルプで。 IECライブラリを開きます。 の POU 、を追加します C-実装ライブラリ 物体。 このオブジェクトに、 デバイスのオブジェクトファイル ： 以前に作成した動的コンポーネント（ファイル）を選択して追加します。 適切なコンポーネント名を指定してください。 適切なデバイスを選択してください。 これで、選択したデバイスでこのライブラリを使用すると、動的コンポーネントがランタイムシステムに自動的に追加され、ライブラリのPOUを使用して呼び出すことができます。 " }, 
{ "title" : "他の ", 
"url" : "_rtsl_extension_extension_sdk.html#UUID-3ac62e45-5305-2a8b-ab6e-32d8fb0157a0_b7087d6c52d870c0a86463346a7ac7_id_f3621caa6c33ff2dc0a8646306fdb730", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Extension Package \/ 拡張SDK \/ 他の ", 
"snippet" : "制限： Extension SDKでは、Cコードのみを含めることができます。 デバッガーを使用してCコードを調べたりデバッグしたりすることはできません（たとえば、プログラミングシステムの場合など）。 Cコードは、ランタイムシステムまたはIECアプリケーションと「相互作用」することはできません。これの意味は： IECアプリケーションの変数への自動アクセスはできません。 ランタイムシステムの機能にアクセスすることはできません。ただし、IECアプリケーションの変数へのアクセスは、Cコードで実装された関数に渡すことでもちろん可能です。 by reference （たとえば、経由 POINTER ）。 ...", 
"body" : "制限： Extension SDKでは、Cコードのみを含めることができます。 デバッガーを使用してCコードを調べたりデバッグしたりすることはできません（たとえば、プログラミングシステムの場合など）。 Cコードは、ランタイムシステムまたはIECアプリケーションと「相互作用」することはできません。これの意味は： IECアプリケーションの変数への自動アクセスはできません。 ランタイムシステムの機能にアクセスすることはできません。ただし、IECアプリケーションの変数へのアクセスは、Cコードで実装された関数に渡すことでもちろん可能です。 by reference （たとえば、経由 POINTER ）。 Linuxのメンバーとしてのみインターフェースを使用する codesysuser ユーザー・グループ 番号 プロセス分離 番号 " }, 
{ "title" : "製品固有の構成 ", 
"url" : "_rtsl_product_configuration_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "BeagleBone ", 
"url" : "_rtsl_linux_beaglebone.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ BeagleBone ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CAN \/シリアルケープの構成 ", 
"url" : "_rtsl_linux_rbp_can_capes.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ BeagleBone \/ CAN \/シリアルケープの構成 ", 
"snippet" : "各種ケープ（拡張ボード）をご用意しております。 BeagleBone Black 機能の幅を広げるため。ケープは拡張スロットに差し込まれています。 BeagleBone Black そしてそれ自体が追加の拡張スロットを提供します。あ BeagleBone Black 最大4つのケープを拡張できます。 この章では、システムの一般的な構成について説明します。 BeagleBone Black これは CAN ケープで拡張されます。 ケープを拡張するための要件は、カーネルバージョン4.1です。他のカーネルバージョンでは、説明が若干異なる場合があります。 コマンドラインで次のコマンドを使用して、カーネ...", 
"body" : "各種ケープ（拡張ボード）をご用意しております。 BeagleBone Black 機能の幅を広げるため。ケープは拡張スロットに差し込まれています。 BeagleBone Black そしてそれ自体が追加の拡張スロットを提供します。あ BeagleBone Black 最大4つのケープを拡張できます。 この章では、システムの一般的な構成について説明します。 BeagleBone Black これは CAN ケープで拡張されます。 ケープを拡張するための要件は、カーネルバージョン4.1です。他のカーネルバージョンでは、説明が若干異なる場合があります。 コマンドラインで次のコマンドを使用して、カーネルのバージョンを確認できます（たとえば、SSH接続を介して）。 uname -a uname -r " }, 
{ "title" : "ケープの取り付け ", 
"url" : "_rtsl_linux_rbp_installing_capes.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ BeagleBone \/ CAN \/シリアルケープの構成 \/ ケープの取り付け ", 
"snippet" : "対応するケープを BeagleBone Black ケープのユーザーマニュアルに記載されているとおりです。 に電源を供給します。 BeagleBone Black 。 次のコマンドで接続を確認します。 cat \/sys\/devices\/platform\/bone_capemgr\/slots たとえば、次の出力が得られます。 Mon 0: P---L- 0 cape-CBB-Serial,r01,Logic Supply,cape-CBB-Serial 1: PF---- -1 2: PF---- -1 3: PF---- -1 または、次のようにカーネルの表示を確認することもできます。 dme...", 
"body" : "対応するケープを BeagleBone Black ケープのユーザーマニュアルに記載されているとおりです。 に電源を供給します。 BeagleBone Black 。 次のコマンドで接続を確認します。 cat \/sys\/devices\/platform\/bone_capemgr\/slots たとえば、次の出力が得られます。 Mon\n0: P---L- 0 cape-CBB-Serial,r01,Logic Supply,cape-CBB-Serial\n1: PF---- -1\n2: PF---- -1\n3: PF---- -1 または、次のようにカーネルの表示を確認することもできます。 dmesg | grep cape 出力は次のようになります。 ...\n\n[3.719868] bone_capemgr bone_capemgr: Baseboard: 'A335BNLT,000B,1614BBBK0256'\n[3.719904] bone_capemgr bone_capemgr: compatible-baseboard=ti,beaglebone-black - #slots=4\n[3.762237] bone_capemgr bone_capemgr: slot #0: 'cape-CBB-Serial,r01,Logic Supply,cape-CBB-Serial'\n[3.818178] bone_capemgr bone_capemgr: slot #1: No cape found\n[3.878171] bone_capemgr bone_capemgr: slot #2: No cape found\n[3.938165] bone_capemgr bone_capemgr: slot #3: No cape found\n[3.944194] bone_capemgr bone_capemgr: initialized OK.\n[3.963568] bone_capemgr bone_capemgr: slot #0: dtbo 'cape-CBB-Serial-r01.dtbo' loaded; overlay id #0\n\n... この出力は、ケープが検出され、対応するデバイスツリーオーバーレイがロードされたことを示しています。 " }, 
{ "title" : "CANインターフェースの構成とテスト ", 
"url" : "_rtsl_linux_bbb_configuring_can.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ BeagleBone \/ CAN \/シリアルケープの構成 \/ CANインターフェースの構成とテスト ", 
"snippet" : "CANのテスト コマンドラインから直接CANをテストするには、Debianパッケージに「can-utils」を使用できます。 Debianパッケージをインストールします。 sudo apt-get install can-utils CANメッセージを送信します。 cansend can0 5A1#ABCDABCD CANメッセージを受信します。 candump can0...", 
"body" : "CANのテスト コマンドラインから直接CANをテストするには、Debianパッケージに「can-utils」を使用できます。 Debianパッケージをインストールします。 sudo apt-get install can-utils CANメッセージを送信します。 cansend can0 5A1#ABCDABCD CANメッセージを受信します。 candump can0 " }, 
{ "title" : "CANの構成 ", 
"url" : "_rtsl_linux_bbb_configuring_can.html#UUID-efad06fa-f9d6-75e9-4a70-c5faf6598419_id_c96cb9d2e581efc0a86463263b6289-id-749f3d54d353c531c0a864631cb78ab4", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ BeagleBone \/ CAN \/シリアルケープの構成 \/ CANインターフェースの構成とテスト \/ CANの構成 ", 
"snippet" : "DCAN0 が BeagleBone Black の場合、I2C-2 機能と競合します。したがって、DCAN1 は通常、P9 ピン 24 (Rx) および P9 ピン 26 (Tx) とともに使用されます。 要件: に接続していること BeagleBone Black 「Putty」などの SSH クライアント経由。 CANを手動で設定およびテストするには、次のコマンドを使用します。 sudo modprobe can sudo modprobe can-dev sudo modprobe can-raw 次のコマンドは、カーネルモジュールをロードします（ハードウェアごとに異なるモジュールをロ...", 
"body" : "DCAN0 が BeagleBone Black の場合、I2C-2 機能と競合します。したがって、DCAN1 は通常、P9 ピン 24 (Rx) および P9 ピン 26 (Tx) とともに使用されます。 要件: に接続していること BeagleBone Black 「Putty」などの SSH クライアント経由。 CANを手動で設定およびテストするには、次のコマンドを使用します。 sudo modprobe can\nsudo modprobe can-dev\nsudo modprobe can-raw 次のコマンドは、カーネルモジュールをロードします（ハードウェアごとに異なるモジュールをロードする必要がある場合があります）。 sudo modprobe c_can_platform ハードウェアごとに異なるモジュールをロードする必要がある場合があります。 CANケープの操作に必要なすべてのドライバーをファイルに入力してください \" ..\/etc\/modules \"。 例： can\ncan-dev\ncan-raw Linuxの仕組み「socketcan」が使えるようになりました。デフォルトでは、これは次のようにサポートされています。 CODESYS Control for BeagleBone 。 カーネル モジュールは次の場合に自動的にロードされます。 BeagleBone Black が開始されます。 ボーレートを設定します。 sudo ip link set can0 up type can bitrate 125000 インターフェイスをアクティブ化します。 sudo ifconfig can0 up CANインターフェースが構成されます。 " }, 
{ "title" : "UARTの構成とテスト ", 
"url" : "_rtsl_linux_rbp_configuring_uarts.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ BeagleBone \/ CAN \/シリアルケープの構成 \/ UARTの構成とテスト ", 
"snippet" : "UARTのテスト インタラクティブなPythonシェルで次のPythonスニペットを実行するか、拡張子が.pyの小さなテキストファイルを作成して、Pythonインタープリターで実行します。 import serial import time uart2_file='\/dev\/ttyO2' baud=115200 ser = serial.Serial(uart2_file, baud) while True: ser.write(\"Testing\") time.sleep(1) ボーレート115200のUART2が開かれ、 Testing 毎秒文字列。 これで、シリアルケーブルを接続して、PC...", 
"body" : "UARTのテスト インタラクティブなPythonシェルで次のPythonスニペットを実行するか、拡張子が.pyの小さなテキストファイルを作成して、Pythonインタープリターで実行します。 import serial\nimport time\nuart2_file='\/dev\/ttyO2'\nbaud=115200\nser = serial.Serial(uart2_file, baud)\nwhile True:\n ser.write(\"Testing\")\n time.sleep(1) ボーレート115200のUART2が開かれ、 Testing 毎秒文字列。 これで、シリアルケーブルを接続して、PCで出力を確認できます（たとえば、Puttyを使用）。 " }, 
{ "title" : "UARTの構成 ", 
"url" : "_rtsl_linux_rbp_configuring_uarts.html#UUID-b5665400-7f51-ce43-e2ec-127a0725936a_id_be9f181d33627c4c0a8646366c6b2ff-id-4c119c87d346da4ec0a86463175a71c5", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ BeagleBone \/ CAN \/シリアルケープの構成 \/ UARTの構成とテスト \/ UARTの構成 ", 
"snippet" : "このケープ（UART2およびUART4）のシリアルインターフェイス（UARTとも呼ばれます）には、 \/dev\/ttyO2 と \/dev\/ttyO4 デバイス。 外部から自分でシリアルポートにアクセスしたい場合 CODESYS 、次に対応するLinuxのドキュメントを参照してください。 UArtsに以下からアクセスしたい場合 CODESYS そして、ファイルに SysCom の設定を指定してください。 CODESYSControl.cfg : [SysCom] Linux.Devicefile=\/dev\/ttyO 設定エントリにインデックスを付けることができます。 例: Linux.Device...", 
"body" : "このケープ（UART2およびUART4）のシリアルインターフェイス（UARTとも呼ばれます）には、 \/dev\/ttyO2 と \/dev\/ttyO4 デバイス。 外部から自分でシリアルポートにアクセスしたい場合 CODESYS 、次に対応するLinuxのドキュメントを参照してください。 UArtsに以下からアクセスしたい場合 CODESYS そして、ファイルに SysCom の設定を指定してください。 CODESYSControl.cfg : [SysCom]\nLinux.Devicefile=\/dev\/ttyO 設定エントリにインデックスを付けることができます。 例: Linux.Devicefile.7=\/dev\/usb0 これにより作成される \/dev\/usb0 COM7 にマップされました。 " }, 
{ "title" : "既知の問題 ", 
"url" : "_rtsl_linux_bbb_problems.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ BeagleBone \/ CAN \/シリアルケープの構成 \/ 既知の問題 ", 
"snippet" : "シリアルRS485 特定のCAN \/シリアルケープのRS485を使用する場合、RS485トランシーバーの使用に問題があります。 Linuxドライバーは送信モードと受信モードを切り替えることができないため、アプリケーションが期待どおりに動作しない場合があります。 詳細な説明：BeagleBone Black（OMAP）のシリアルドライバーは、RS-485に必要な送信\/受信切り替え（DE \/ REまたはRTS）をサポートしていません。代わりに、DE \/ REラインをチェックするために永続的に割り当てられたGPIOピンを使用するRS485モードがあり、シリアル標準ドライバーと比較して構造が変更されて...", 
"body" : "シリアルRS485 特定のCAN \/シリアルケープのRS485を使用する場合、RS485トランシーバーの使用に問題があります。 Linuxドライバーは送信モードと受信モードを切り替えることができないため、アプリケーションが期待どおりに動作しない場合があります。 詳細な説明：BeagleBone Black（OMAP）のシリアルドライバーは、RS-485に必要な送信\/受信切り替え（DE \/ REまたはRTS）をサポートしていません。代わりに、DE \/ REラインをチェックするために永続的に割り当てられたGPIOピンを使用するRS485モードがあり、シリアル標準ドライバーと比較して構造が変更されています（serial_rs485構造体）。シリアルドライバをRS-485モードにして、使用する必要のあるピンを指定するには、対応するdevttyファイルでioctlを使用する必要があります。さらに、GPIOモードでのピンの多重化に注意する必要があります。 " }, 
{ "title" : "GPIOとアナログ入力の使用 ", 
"url" : "_rtsl_linux_bbb_gpios_analog_inputs.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ BeagleBone \/ GPIOとアナログ入力の使用 ", 
"snippet" : "この章では、I\/O マッピングを使用する場合の制限について説明します。 BeagleBone Black GPIO とアナログ入力にアクセスします。...", 
"body" : "この章では、I\/O マッピングを使用する場合の制限について説明します。 BeagleBone Black GPIO とアナログ入力にアクセスします。 " }, 
{ "title" : "P8 \/ P9のアクセスピン ", 
"url" : "_rtsl_linux_bbb_access_pins.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ BeagleBone \/ GPIOとアナログ入力の使用 \/ P8 \/ P9のアクセスピン ", 
"snippet" : "P8およびP9プラグは、多くのGPIOおよびアナログ入力へのアクセスを可能にします。ただし、デフォルトですべてが自由に使用できるわけではありません。 HDMIおよびLinuxデバイスツリーの標準「スロット」は、HDMI、eMMC、およびMCASP0用のいくつかのピンを使用します。次のリストは、GPIOまたはアナログ入力として使用できるピンと、システムですでに使用されているピンを示しています。 入力と出力の許容電圧と電流の違いに注意してください。 プラグP9 ヘッダーピン ピン名 CODESYS サポート システムで使用 P9_01 GND いいえ いいえ P9_02 GND いいえ いいえ P...", 
"body" : "P8およびP9プラグは、多くのGPIOおよびアナログ入力へのアクセスを可能にします。ただし、デフォルトですべてが自由に使用できるわけではありません。 HDMIおよびLinuxデバイスツリーの標準「スロット」は、HDMI、eMMC、およびMCASP0用のいくつかのピンを使用します。次のリストは、GPIOまたはアナログ入力として使用できるピンと、システムですでに使用されているピンを示しています。 入力と出力の許容電圧と電流の違いに注意してください。 プラグP9 ヘッダーピン ピン名 CODESYS サポート システムで使用 P9_01 GND いいえ いいえ P9_02 GND いいえ いいえ P9_03 DC_3.3V いいえ いいえ P9_04 DC_3.3V いいえ いいえ P9_05 VDD_5V いいえ いいえ P9_06 VDD_5V いいえ いいえ P9_07 SYS_5V いいえ いいえ P9_08 SYS_5V いいえ いいえ P9_09 PWR_BUT いいえ いいえ P9_10 SYS_RESETn いいえ いいえ P9_11 UART4_RXD はい いいえ P9_12 GPIO1_28 はい いいえ P9_13 UART4_TXD はい いいえ P9_14 EHRPWM1A はい いいえ P9_15 GPIO1_16 はい いいえ P9_16 EHRPWM1B はい いいえ P9_17 I2C1_SCL いいえ PINMUX I 2 C P9_18 I2C1_SDA いいえ PINMUX I 2 C P9_19 I2C2_SCL いいえ PINMUX I 2 C P9_20 I2C2_SDA いいえ PINMUX I 2 C P9_21 UART2_TXD はい いいえ P9_22 UART2_RXD はい いいえ P9_23 GPIO1_17 はい いいえ P9_24 UART1_TXD はい いいえ P9_25 GPIO3_21 いいえ MCASPO P9_26 UART1_RXD はい いいえ P9_27 GPIO3_19 はい いいえ P9_28 SPI1_CS0 いいえ MCASP0 P9_29 SPI1_D0 いいえ MCASP0 P9_30 SPI1_D1 いいえ MCASP0 P9_31 SPI1_SCLK いいえ MCASP0 P9_32 VADC いいえ いいえ P9_33 AIN4 はい いいえ P9_34 AGND いいえ いいえ P9_35 AIN6 はい いいえ P9_36 AIN5 はい いいえ P9_37 AIN2 はい いいえ P9_38 AIN3 はい いいえ P9_39 AIN0 はい いいえ P9_40 AIN1 はい いいえ P9_41 GPIO0_20 はい いいえ P9_42 GPIO0_7 はい いいえ P9_43 GND いいえ いいえ P9_44 GND いいえ いいえ P9_45 GND いいえ いいえ P9_46 GND いいえ いいえ プラグP8 ヘッダーピン ピン名 CODESYS サポート システムで使用 P8_01 DGND いいえ いいえ P8_02 DGND いいえ いいえ P8_03 GPIO1_6 いいえ eMMC P8_04 GPIO1_7 いいえ eMMC P8_05 GPIO1_2 いいえ eMMC P8_06 GPIO1_3 いいえ eMMC P8_07 TIMER4 はい いいえ P8_08 TIMER7 はい いいえ P8_09 TIMER5 はい いいえ P8_10 TIMER6 はい いいえ P8_11 GPIO1_13 はい いいえ P8_12 GPIO1_12 はい いいえ P8_13 EHRPWM2B はい いいえ P8_14 GPIO0_26 はい いいえ P8_15 GPIO1_15 はい いいえ P8_16 GPIO1_14 はい いいえ P8_17 GPIO0_27 はい いいえ P8_18 GPIO2_1 はい いいえ P8_19 EHRPWM2A はい いいえ P8_20 GPIO1_31 いいえ eMMC P8_21 GPIO1_30 いいえ eMMC P8_22 GPIO1_5 いいえ eMMC P8_23 GPIO1_4 いいえ eMMC P8_24 GPIO1_1 いいえ eMMC P8_25 GPIO1_0 いいえ eMMC P8_26 GPIO1_29 はい いいえ P8_27 GPIO2_22 いいえ HDMI P8_28 GPIO2_24 いいえ HDMI P8_29 GPIO2_23 いいえ HDMI P8_30 GPIO2_25 いいえ HDMI P8_31 UART5_CTSN いいえ HDMI P8_32 UART5_RTSN いいえ HDMI P8_33 UART4_RTSN いいえ HDMI P8_34 UART3_RTSN いいえ HDMI P8_35 UART4_CTSN いいえ HDMI P8_36 UART3_CTSN いいえ HDMI P8_37 UART5_TXD いいえ HDMI P8_38 UART5_TXD いいえ HDMI P8_39 GPIO2_12 いいえ HDMI P8_40 GPIO2_13 いいえ HDMI P8_41 GPIO2_10 いいえ HDMI P8_42 GPIO2_11 いいえ HDMI P8_43 GPIO2_8 いいえ HDMI P8_44 GPIO2_9 いいえ HDMI P8_45 GPIO2_6 いいえ HDMI P8_46 GPIO2_7 いいえ HDMI " }, 
{ "title" : "外部ストレージデバイスを構成する ", 
"url" : "_rtsl_linux_bbb_external_storage.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ BeagleBone \/ 外部ストレージデバイスを構成する ", 
"snippet" : "設定できるのは、 BeagleBone Black USB ストレージ デバイスまたは µSD カードにアクセスするには CODESYS Control for BeagleBone 。特定の USB ストレージ デバイスまたは µSD カードの互換性はハードウェアによって異なります。ただし、理論的には、すべての USB ストレージ デバイスまたは µSD カードは、 BeagleBone Black 。 USBストレージデバイスまたはµSDカードへのアクセス 自動マウント用のLinuxの構成 Debian は、プラグ可能なストレージ メディアの自動マウントを処理するパッケージを提供します。こ...", 
"body" : "設定できるのは、 BeagleBone Black USB ストレージ デバイスまたは µSD カードにアクセスするには CODESYS Control for BeagleBone 。特定の USB ストレージ デバイスまたは µSD カードの互換性はハードウェアによって異なります。ただし、理論的には、すべての USB ストレージ デバイスまたは µSD カードは、 BeagleBone Black 。 USBストレージデバイスまたはµSDカードへのアクセス 自動マウント用のLinuxの構成 Debian は、プラグ可能なストレージ メディアの自動マウントを処理するパッケージを提供します。このパッケージは、次の場所にもインストールできます。 BeagleBone Black 。 Debianディレクトリからusbmountパッケージをインストールします。 command> sudo apt-get install usbmount デバイスはインターネットに接続され、Debianサーバーにアクセスできるように構成されている必要があります。 USBストレージデバイスへのアクセス USBストレージデバイスが接続されると、usbautomountは自動的に \/media\/usb USBメモリデバイス上のファイルにアクセスできるフォルダ。 The CODESYS コントロールランタイムシステムは、USBストレージデバイスが使用可能になったときに自動的に表示されるように構成されています。 USBストレージデバイスを接続すると、に追加されます \/media\/usb フォルダ。の CODESYS 、 $USB$ プレースホルダーを使用して、このフォルダーにアクセスできます。これを行うには2つの方法があります。 あなたはでファイル転送を使用することができます CODESYS Development System アクセスするには $USB$ プレースホルダー。 ライブラリCAA_Fileを使用して、IECアプリケーションからこれらの同じファイルにアクセスできます。 メディアはプラグイン可能であるため、ファイルにアクセスできない場合があることに注意してください。したがって、CAAFileOpenの結果を確認してください。 " }, 
{ "title" : "Raspberry Pi ", 
"url" : "_rtsl_linux_raspberry.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi ", 
"snippet" : "これを使って Raspberry Pi Raspbian オペレーティング システムを使用すると、次の場所から入手できます。 ラズベリーパイ財団 。 の Raspberry Pi テストと教育を目的として開発されました。工業目的での使用は推奨されません。 ラズベリーパイを始めよう マルチコア対応のランタイムは現在利用可能です Raspberry Pi バージョン2。...", 
"body" : "これを使って Raspberry Pi Raspbian オペレーティング システムを使用すると、次の場所から入手できます。 ラズベリーパイ財団 。 の Raspberry Pi テストと教育を目的として開発されました。工業目的での使用は推奨されません。 ラズベリーパイを始めよう マルチコア対応のランタイムは現在利用可能です Raspberry Pi バージョン2。 " }, 
{ "title" : "ドライバーの開発 ", 
"url" : "_rtsl_linux_rbp_driver_development.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi \/ ドライバーの開発 ", 
"snippet" : "接続できる機器はたくさんありますが、 Raspberry Pi 。 CODESYS Control for Raspberry Pi は、利用可能なハードウェアのごく一部のみをサポートします。サポートされていないデバイスを接続したい場合は、 Raspberry Pi 、その後、独自の I\/O ドライバーを作成できます。これを行うには、構成とプログラミングのスキルが必要です。 基本的に、次のアプローチを使用して、システムインターフェイスを介して追加のデバイスを接続および操作できます。 2 C、SPI（シリアルペリフェラルインターフェース）または1-Wire。 機能ブロック（FB）を実装する 関数...", 
"body" : "接続できる機器はたくさんありますが、 Raspberry Pi 。 CODESYS Control for Raspberry Pi は、利用可能なハードウェアのごく一部のみをサポートします。サポートされていないデバイスを接続したい場合は、 Raspberry Pi 、その後、独自の I\/O ドライバーを作成できます。これを行うには、構成とプログラミングのスキルが必要です。 基本的に、次のアプローチを使用して、システムインターフェイスを介して追加のデバイスを接続および操作できます。 2 C、SPI（シリアルペリフェラルインターフェース）または1-Wire。 機能ブロック（FB）を実装する 関数ブロックは、既存または新規の変数へのデータのマッピングを処理し、データのサイクルの一貫性を保証します。これを行うには、インターフェイスを手動で宣言し、プログラムでインスタンスを呼び出します。 デバイスの説明を含む機能ブロック（FB）を実装する 次に、特別なデバイスをに追加できます CODESYS デバイスツリーとそれを構成します。 I \/ Oドライバーを実装する これらおよびその他のアプローチは、オープンソースで説明されています CODESYSフォージ のプラットフォーム ドライバー→I \/ Oドライバー メニュー。 " }, 
{ "title" : "ランタイムの構成 ", 
"url" : "_rtsl_linux_rbp_configure_runtime.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi \/ ランタイムの構成 ", 
"snippet" : "CODESYS Control for Raspberry Pi バージョン V3.5 SP14 以降は、マルチコア対応ハードウェアもサポートしています ( Raspberry Pi 2と Raspberry Pi 3)。ランタイム システムは、次の 3 つの異なるモードで動作できます。 マルチコア 64 ビット (Aarch64): このモードは、64 ビット モードでマルチコア対応ランタイムを使用し、それに最適化されたデバイス記述で実行する必要があります。 マルチコア 32 ビット (ARMv7): このモードは、32 ビット モードでマルチコア対応ランタイムを使用し、それに最適化されたデ...", 
"body" : "CODESYS Control for Raspberry Pi バージョン V3.5 SP14 以降は、マルチコア対応ハードウェアもサポートしています ( Raspberry Pi 2と Raspberry Pi 3)。ランタイム システムは、次の 3 つの異なるモードで動作できます。 マルチコア 64 ビット (Aarch64): このモードは、64 ビット モードでマルチコア対応ランタイムを使用し、それに最適化されたデバイス記述で実行する必要があります。 マルチコア 32 ビット (ARMv7): このモードは、32 ビット モードでマルチコア対応ランタイムを使用し、それに最適化されたデバイス記述で実行する必要があります。 デフォルト: このモードはすべての場合に使用できます。 Raspberry Pi のバリアントであり、以前のバージョンと互換性があります CODESYS Control for Raspberry Pi (デバイスの説明を含む)。サポートしていません CODESYS マルチコア機能。 Raspberry Pi ランタイムシステムをインストールすると、モードが自動的に事前に選択されます。どのモードが選択されているかは、ログウィンドウで確認できます。モードを変更するには、まずサービスのリストから Raspberry Pi ランタイムシステムを選択します。しばらくロードすると、現在のランタイムアーキテクチャが右側に表示されます 目的のアーキテクチャは、次の方法で選択できます。 Runtime system architecture リストボックス。 [保存] 変更をデバイスに転送します。 使用できるモードは、使用されているオペレーティング システム イメージによっても異なります。純粋に 64 ビット イメージを使用する場合は、64 ビット モードのみを使用できます。純粋に 32 ビット イメージを使用する場合は、32 ビット モードのみを選択できます。使用するハードウェア (Raspberry PI 2B、PI 3、PI 4 など) に応じて、選択されたモードのみがサポートされます。 (ツールヒントを参照)。 モードを切り替える場合は、一致するデバイスの説明がプロジェクトで構成されていることを確認する必要があります。そうしないと、コントローラーとの通信ができなくなります。コントローラ上の既存のブートアプリケーションは、切り替え後にロードできなくなります。それらは、一致するデバイスの説明とともにコントローラーに再度ダウンロードする必要があります。 " }, 
{ "title" : "サンプルプロジェクト ", 
"url" : "_rtsl_linux_rbp_examples.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi \/ サンプルプロジェクト ", 
"snippet" : "次のサンプル プロジェクトはインストール ディレクトリにあります (例 C:\\Users\\<Name>\\ CODESYS Control for Raspberry Pi \\3.5.11.0\\Examples ）。...", 
"body" : "次のサンプル プロジェクトはインストール ディレクトリにあります (例 C:\\Users\\<Name>\\ CODESYS Control for Raspberry Pi \\3.5.11.0\\Examples ）。 " }, 
{ "title" : "WebVisuの構成 ", 
"url" : "_rtsl_linux_rbp_examples_webvisu.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi \/ サンプルプロジェクト \/ WebVisuの構成 ", 
"snippet" : "プロジェクト： WebVisu.project で作成されたユーザーインターフェイスを備えたアプリケーションが含まれています CODESYS Visualization 。 を開きます WebVisu.project 事業。 デバイスツリーで、ダブルクリックします 端末 。 の 通信設定 、 クリック スキャンネットワーク 。 デバイスが開発用PCと同じネットワーク上にある場合は、デバイスが表示されて選択できます。 接続線を選択してクリックします オンライン→ログイン 。 アプリケーションがRaspberryPiにダウンロードされます。 プログラムを開始します（例：を押します F5 鍵）。 任...", 
"body" : "プロジェクト： WebVisu.project で作成されたユーザーインターフェイスを備えたアプリケーションが含まれています CODESYS Visualization 。 を開きます WebVisu.project 事業。 デバイスツリーで、ダブルクリックします 端末 。 の 通信設定 、 クリック スキャンネットワーク 。 デバイスが開発用PCと同じネットワーク上にある場合は、デバイスが表示されて選択できます。 接続線を選択してクリックします オンライン→ログイン 。 アプリケーションがRaspberryPiにダウンロードされます。 プログラムを開始します（例：を押します F5 鍵）。 任意のブラウザ（おそらくスマートフォン）を開き、アドレスを指定します <network address>:8080\/webvisu.htm 。 ブラウザには、プロジェクトで作成されたときのユーザーインターフェイスが表示されます。 " }, 
{ "title" : "カメラモジュールの構成 ", 
"url" : "_rtsl_linux_rbp_examples_camera.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi \/ サンプルプロジェクト \/ カメラモジュールの構成 ", 
"snippet" : "カメラ画像の視覚化 The CameraStream.project プロジェクトには、カメラのライブストリームまたは単一の画像のみを表示するWebVisuユーザーインターフェイスを備えたアプリケーションが含まれています。 要件：Raspberry Pi Camera拡張ハードウェアが接続され、アクティブ化されている。 のバージョンに応じて RPi_Cam_Web_Interface 含まれているApacheインストールの場合、デフォルトの場所は次のようになります。 ..\/var\/www\/ また ..\/var\/www\/html\/ 。場所は、アプリケーションで使用されます PLC_PRG 3行目...", 
"body" : "カメラ画像の視覚化 The CameraStream.project プロジェクトには、カメラのライブストリームまたは単一の画像のみを表示するWebVisuユーザーインターフェイスを備えたアプリケーションが含まれています。 要件：Raspberry Pi Camera拡張ハードウェアが接続され、アクティブ化されている。 のバージョンに応じて RPi_Cam_Web_Interface 含まれているApacheインストールの場合、デフォルトの場所は次のようになります。 ..\/var\/www\/ また ..\/var\/www\/html\/ 。場所は、アプリケーションで使用されます PLC_PRG 3行目で、それに応じて調整する必要があります。 を開きます Camera.project プロジェクトして更新します。 デバイスツリーで、ダブルクリックします 端末 。 デバイスエディタが開きます。 の 通信設定 、 クリック スキャンネットワーク 。 Raspberry Piと開発システムが同じネットワーク上にある場合は、RaspberryPiが表示されて選択できます。 それを選択してクリックします オンライン→ログイン 。 アプリケーションがRaspberryPiにダウンロードされます。 プログラムを起動します（ F5 鍵）。 任意のブラウザ（おそらくスマートフォン）を開き、アドレスを指定します <network address>:8080\/webvisu.htm 。 プロジェクトのユーザーインターフェイスが開きます。上の部分はカメラのライブストリームを示し、その下には最後のフレームが表示されます。ボタンをクリックすると、フレームが更新されます。 " }, 
{ "title" : "カメラ画像の保存 ", 
"url" : "_rtsl_linux_rbp_examples_camera.html#UUID-7ae4b070-9730-d58c-9609-58bda5038aa4_id_fa1d2aa65ca341bec0a864637b1b4eb2-id-919df6bb9f68aed4c0a864630c86131d", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi \/ サンプルプロジェクト \/ カメラモジュールの構成 \/ カメラ画像の保存 ", 
"snippet" : "要件：Raspberry Pi Camera拡張ハードウェアが接続され、アクティブ化されている。 The Camera.project プロジェクトには、Raspberry Pi Cameraモジュールを制御し、個々の画像を取得してファイルとして保存するアプリケーションが含まれています。 一部のモデルでは、プリインストールされています RPi Cam Control アプリケーションを無効にする必要があります。これを行うには、ブラウザを開いて指定します http:\/\/<network address> 。設定ページが開きます。を実行します stop camera そこにコマンド。 を開きます ...", 
"body" : "要件：Raspberry Pi Camera拡張ハードウェアが接続され、アクティブ化されている。 The Camera.project プロジェクトには、Raspberry Pi Cameraモジュールを制御し、個々の画像を取得してファイルとして保存するアプリケーションが含まれています。 一部のモデルでは、プリインストールされています RPi Cam Control アプリケーションを無効にする必要があります。これを行うには、ブラウザを開いて指定します http:\/\/<network address> 。設定ページが開きます。を実行します stop camera そこにコマンド。 を開きます Camera.project プロジェクトして更新します。 デバイスツリーで、ダブルクリックします 端末 。 デバイスエディタが開きます。 の 通信設定 、 クリック スキャンネットワーク 。 Raspberry Piと開発システムが同じネットワーク上にある場合は、RaspberryPiが表示されて選択できます。 それを選択してクリックします オンライン→ログイン 。 アプリケーションがRaspberryPiにダウンロードされます。 プログラムを起動します（ F5 鍵）。 をセットする xTakePicture 変数 TRUE 。 カメラが写真を撮り、その名前でローカルファイルシステムに保存します Picture.jpg 。 下のデバイスエディタで画像ファイルをコピーできます ファイル あなたの開発システムに。クリック ファイルビューを更新するための記号。 " }, 
{ "title" : "GPIOの構成 ", 
"url" : "_rtsl_linux_rbp_examples_gpio.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi \/ サンプルプロジェクト \/ GPIOの構成 ", 
"snippet" : "The GPIO.project プロジェクトには、I \/ Oイメージが構成されているデバイスエディターを備えた無料のGPIOを備えたアプリケーションが含まれています。デジタル入力と出力もそこで定義されています。 デバイスエディタで、以下 GPIOのI \/ Oイメージ タブ、 DWORD 変数は、入力と出力のそれぞれに対して宣言されます。 The Bit<X> の値が含まれています GPIO<X> 。 例では、 GPIO18 出力として定義されました。点滅する信号が割り当てられています PLC_PRG プログラム。ビジュアライゼーションは入力の値を表示し、出力を設定できるようにします。 Ras...", 
"body" : "The GPIO.project プロジェクトには、I \/ Oイメージが構成されているデバイスエディターを備えた無料のGPIOを備えたアプリケーションが含まれています。デジタル入力と出力もそこで定義されています。 デバイスエディタで、以下 GPIOのI \/ Oイメージ タブ、 DWORD 変数は、入力と出力のそれぞれに対して宣言されます。 The Bit<X> の値が含まれています GPIO<X> 。 例では、 GPIO18 出力として定義されました。点滅する信号が割り当てられています PLC_PRG プログラム。ビジュアライゼーションは入力の値を表示し、出力を設定できるようにします。 Raspberry Pi B +モデルバリアントには、個別の拡張デバイスの説明があります。を使用するには GPIO B + \/ Pi2 の代わりにデバイスの説明 GPIO A \/ B 、 クリック デバイスの更新 コンテキストメニューで、 GPIO B + \/ Pi2 ダイアログのデバイスタイプ。 ロードされたドライバーによっては、一部のGPIOが他の機能に永続的に割り当てられているため、使用できない場合があります。 " }, 
{ "title" : "PiFaceDigitalの設定 ", 
"url" : "_rtsl_linux_rbp_examples_piface.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi \/ サンプルプロジェクト \/ PiFaceDigitalの設定 ", 
"snippet" : "PiFace Control andDisplayモジュールによる制御と操作 要件：PiFace Control andDisplay拡張ハードウェアが接続されている。 の PiFaceDisplayAndControl.project プロジェクトには、アプリケーション パラメータを設定するために、8 つのデジタル入力と出力を備えた Raspberry PiFace デジタル I\/O ハードウェアに加えて、2 行のテキスト ディスプレイを制御するアプリケーションが含まれています。 SPIポート1を介してPiFaceコントロールおよびディスプレイボードにアクセスできます \/dev\/spidev...", 
"body" : "PiFace Control andDisplayモジュールによる制御と操作 要件：PiFace Control andDisplay拡張ハードウェアが接続されている。 の PiFaceDisplayAndControl.project プロジェクトには、アプリケーション パラメータを設定するために、8 つのデジタル入力と出力を備えた Raspberry PiFace デジタル I\/O ハードウェアに加えて、2 行のテキスト ディスプレイを制御するアプリケーションが含まれています。 SPIポート1を介してPiFaceコントロールおよびディスプレイボードにアクセスできます \/dev\/spidev0.1 これはSPIマスターで構成されます。 デバイスがデバイスツリーに追加されると、デバイスを制御するためのさまざまなメソッドとプロパティを提供するFBインスタンスが作成されます。また、ボタンの状態が返されます。のビット0〜7 bySwitches 次のボタンの出力スタンド： サンプルプロジェクトでは、 PiFace_Control_Display FBはのインスタンスに渡されます ParamListPiFace パラメータエディタを実装するFB。表示モードでは、ナビゲーションボタン（6\/7）を使用してパラメータリストをスクロールできます。ナビゲーションボタン（5）を押すと、1行目のパラメータが詳細に表示されます。ボタン4を押して、詳細ビューを終了します。もう一度5を押して、編集モードに入ります。そこで、ボタン0と1を使用して、許可された範囲の値を変更できます。ボタン2を使用すると、値が保存されます。ボタン4を押して、編集モードを終了します。 " }, 
{ "title" : "PiFaceデジタルI \/ Oハードウェアの制御 ", 
"url" : "_rtsl_linux_rbp_examples_piface.html#UUID-c604b911-bae8-3ccf-0ad8-13b30c6d647a_id_a539525ca8913fc0a864630d69208b-id-9f45924d66a164bcc0a864631b646b6a", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi \/ サンプルプロジェクト \/ PiFaceDigitalの設定 \/ PiFaceデジタルI \/ Oハードウェアの制御 ", 
"snippet" : "要件：PiFaceDigital拡張ハードウェアが接続されている。 The PiFace.project プロジェクトには、8つのデジタル入力と出力を備えたRaspberryPiFaceデジタルI \/ Oハードウェアを制御するアプリケーションが含まれています。 を開きます PiFace.project プロジェクトして更新します。 デバイスツリーで、ダブルクリックします Device 。 デバイスエディタが開きます。 に 通信設定 タブをクリックします スキャンネットワーク 。 Raspberry Piと開発システムが同じネットワーク上にある場合は、RaspberryPiが表示されて選択できま...", 
"body" : "要件：PiFaceDigital拡張ハードウェアが接続されている。 The PiFace.project プロジェクトには、8つのデジタル入力と出力を備えたRaspberryPiFaceデジタルI \/ Oハードウェアを制御するアプリケーションが含まれています。 を開きます PiFace.project プロジェクトして更新します。 デバイスツリーで、ダブルクリックします Device 。 デバイスエディタが開きます。 に 通信設定 タブをクリックします スキャンネットワーク 。 Raspberry Piと開発システムが同じネットワーク上にある場合は、RaspberryPiが表示されて選択できます。 それを選択してクリックします オンライン→ログイン 。 アプリケーションがRaspberryPiにダウンロードされます。 プログラムを起動します（ F5 鍵）。 S1ボタンを押すと、K0リレー出力が1秒の遅延で切り替わります。 S2ボタンを押すと、すぐにK1が切り替わります。 K1は、S2が解放されてから0.5秒保持されます。 また、デバイスツリーのPiFaceデバイスのデバイスパラメータを適宜調整することで、複数のインスタンス（ジャンパーJP1、JP2を介して変更可能なハードウェアアドレス）を使用できることにも注意してください。 The Raspberry SPI_PiFace 接続を可能にするライブラリは、ソースコードとして利用できます。他の接続の例として使用できます。 The Raspberry Pi Peripherals ライブラリは、SPIを介した通信の基盤です。それらのインターフェースは、ヘルプとライブラリマネージャーの両方に文書化されています。 " }, 
{ "title" : "I \/ Oドライバーを介したPiFaceデジタルモジュールの制御 ", 
"url" : "_rtsl_linux_rbp_examples_piface.html#UUID-c604b911-bae8-3ccf-0ad8-13b30c6d647a_id_a539525ca8913fc0a864630d69208b-id-24768c9d66a164bcc0a864631df6fefb", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi \/ サンプルプロジェクト \/ PiFaceDigitalの設定 \/ I \/ Oドライバーを介したPiFaceデジタルモジュールの制御 ", 
"snippet" : "要件：PiFaceDigital拡張ハードウェアが接続されている。 の PiFaceIoDrv.project プロジェクトには、8 つのデジタル入出力を備えた Raspberry PiFace Digital I\/O ハードウェアを制御するアプリケーションが含まれています。ただし、暗黙的な FB インスタンスの代わりに I\/O ドライバーが使用されます。 I\/O ドライバは、プロセス イメージを使用して、コントローラの通常の方法で入力と出力の交換を実装します。 The IoDrvPiFace ライブラリには、ソースコードとしてI \/ Oドライバーが含まれています。...", 
"body" : "要件：PiFaceDigital拡張ハードウェアが接続されている。 の PiFaceIoDrv.project プロジェクトには、8 つのデジタル入出力を備えた Raspberry PiFace Digital I\/O ハードウェアを制御するアプリケーションが含まれています。ただし、暗黙的な FB インスタンスの代わりに I\/O ドライバーが使用されます。 I\/O ドライバは、プロセス イメージを使用して、コントローラの通常の方法で入力と出力の交換を実装します。 The IoDrvPiFace ライブラリには、ソースコードとしてI \/ Oドライバーが含まれています。 " }, 
{ "title" : "Iの構成 2 C ", 
"url" : "_rtsl_linux_rbp_examples_i2c.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi \/ サンプルプロジェクト \/ Iの構成 2 C ", 
"snippet" : "要件：特別なハードウェアがI²Cを介して接続されています。 The I2CExample.project プロジェクトには、I²Cを介して接続されたさまざまなチップとブレイクアウトを制御するアプリケーションが含まれています。 接続されたハードウェア： Adafruit16チャンネル\/ 12ビットPWM SRF02（超音波距離センサー） Drotek IMU 9DOF-MPU9150（ジャイロスコープ、加速度計、磁気スコープ） The Raspberry I2C <name> 接続を可能にするライブラリは、ソースコードとして利用できます。これらは、他の接続の例として使用できます。 The Ras...", 
"body" : "要件：特別なハードウェアがI²Cを介して接続されています。 The I2CExample.project プロジェクトには、I²Cを介して接続されたさまざまなチップとブレイクアウトを制御するアプリケーションが含まれています。 接続されたハードウェア： Adafruit16チャンネル\/ 12ビットPWM SRF02（超音波距離センサー） Drotek IMU 9DOF-MPU9150（ジャイロスコープ、加速度計、磁気スコープ） The Raspberry I2C <name> 接続を可能にするライブラリは、ソースコードとして利用できます。これらは、他の接続の例として使用できます。 The Raspberry Pi Peripherals ライブラリは、I²Cを介した通信の基盤です。それらのインターフェースは、ヘルプとライブラリマネージャーの両方に文書化されています。 " }, 
{ "title" : "A \/ DコンバータMPC3008の設定 ", 
"url" : "_rtsl_linux_rbp_examples_mcp3008.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi \/ サンプルプロジェクト \/ A \/ DコンバータMPC3008の設定 ", 
"snippet" : "要件：特別なハードウェアがSPIを介して接続されています。 The MCP3008_Temperature.project プロジェクトには、SPIを介してA \/ Dコンバータチップ（MCP3008）に接続されたアナログ温度センサー（LM35）を読み取るアプリケーションが含まれています。 MCP3008は8つのアナログチャネルを評価できますが、この例では1つだけが使用されています。 テスト構成： The SPI_MCP3008 接続を可能にするライブラリは、ソースコードとして利用できます。他の接続の例として使用できます。 The Raspberry Pi Peripherals ライブラリは、...", 
"body" : "要件：特別なハードウェアがSPIを介して接続されています。 The MCP3008_Temperature.project プロジェクトには、SPIを介してA \/ Dコンバータチップ（MCP3008）に接続されたアナログ温度センサー（LM35）を読み取るアプリケーションが含まれています。 MCP3008は8つのアナログチャネルを評価できますが、この例では1つだけが使用されています。 テスト構成： The SPI_MCP3008 接続を可能にするライブラリは、ソースコードとして利用できます。他の接続の例として使用できます。 The Raspberry Pi Peripherals ライブラリは、SPIを介した通信の基盤です。それらのインターフェースは、ヘルプとライブラリマネージャーの両方に文書化されています。 " }, 
{ "title" : "ポートエキスパンダーMCP23S17の構成 ", 
"url" : "_rtsl_linux_rbp_examples_mcp23s17.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi \/ サンプルプロジェクト \/ ポートエキスパンダーMCP23S17の構成 ", 
"snippet" : "要件：特別なハードウェアがSPIを介して接続されています。 The MCP23S17.project プロジェクトには、ポートエキスパンダーチップ（MCP23S17）がSPIを介して接続されているアプリケーションが含まれています。 デバイスエディタでは、どのGPIOピンを入力または出力として使用するかを構成できます。入力のプルアップ抵抗をアクティブにすることもできます。アドレスIOピンの割り当てに応じて、ハードウェアアドレスを適宜構成する必要があります。...", 
"body" : "要件：特別なハードウェアがSPIを介して接続されています。 The MCP23S17.project プロジェクトには、ポートエキスパンダーチップ（MCP23S17）がSPIを介して接続されているアプリケーションが含まれています。 デバイスエディタでは、どのGPIOピンを入力または出力として使用するかを構成できます。入力のプルアップ抵抗をアクティブにすることもできます。アドレスIOピンの割り当てに応じて、ハードウェアアドレスを適宜構成する必要があります。 " }, 
{ "title" : "1-Wireの設定 ", 
"url" : "_rtsl_linux_rbp_examples_1_wire.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi \/ サンプルプロジェクト \/ 1-Wireの設定 ", 
"snippet" : "要件：1線式温度センサーが接続されている。 The OneWire.project プロジェクトには、1-Wireを介して接続されたデバイスを検出するアプリケーションが含まれています。さらに、DS18B20タイプの温度センサーが制御されます。この場合、1-WireデータラインはGPIO4に接続されます。 ブートアプリケーションを使用してIDを検出できます。 サンプルアプリケーションの機能： ネットワークで1-Wireデバイスを検索し、検出されたデバイスのIDを視覚化して表示します 検出されたデバイスの中に正しく構成されたIDを持つDS18B20がある場合は、センサー温度を測定して表示します。 ...", 
"body" : "要件：1線式温度センサーが接続されている。 The OneWire.project プロジェクトには、1-Wireを介して接続されたデバイスを検出するアプリケーションが含まれています。さらに、DS18B20タイプの温度センサーが制御されます。この場合、1-WireデータラインはGPIO4に接続されます。 ブートアプリケーションを使用してIDを検出できます。 サンプルアプリケーションの機能： ネットワークで1-Wireデバイスを検索し、検出されたデバイスのIDを視覚化して表示します 検出されたデバイスの中に正しく構成されたIDを持つDS18B20がある場合は、センサー温度を測定して表示します。 1-Wireを介したデータ交換には非常に時間がかかります。その間、タスクはブロックされます。タイムクリティカルなアプリケーションの場合、1-Wireフィールドバスデバイスのアプリケーションを別のタスクに割り当てます。のデバイスエディタでタスクを割り当てることができます タスクリスト タブ。 " }, 
{ "title" : "サーボモーターの構成 ", 
"url" : "_rtsl_linux_rbp_examples_softmotion_servo.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi \/ サンプルプロジェクト \/ サーボモーターの構成 ", 
"snippet" : "要件：Adafruit16チャネル\/ 12ビットPWMボードがI²Cを介して接続され、モデルサーボが最初のPWMチャネルに配線されています。 The SoftMotion Servo Example.project プロジェクトには、次のようなアプリケーションが含まれています CODESYS SoftMotion モデルサーボモーターと組み合わせて使用されます。 I²Cを介して接続された拡張ボード（Adafruit ID 815）が通信インターフェースとして使用されます。 を開きます SoftMotion Servo Example.project プロジェクトして更新します。 デバイスツリー...", 
"body" : "要件：Adafruit16チャネル\/ 12ビットPWMボードがI²Cを介して接続され、モデルサーボが最初のPWMチャネルに配線されています。 The SoftMotion Servo Example.project プロジェクトには、次のようなアプリケーションが含まれています CODESYS SoftMotion モデルサーボモーターと組み合わせて使用されます。 I²Cを介して接続された拡張ボード（Adafruit ID 815）が通信インターフェースとして使用されます。 を開きます SoftMotion Servo Example.project プロジェクトして更新します。 デバイスツリーで、ダブルクリックします 端末 。 デバイスエディタが開きます。 の 通信設定 、 クリック スキャンネットワーク 。 Raspberry Piと開発システムが同じネットワーク上にある場合は、RaspberryPiが表示されて選択できます。 それを選択してクリックします オンライン→ログイン 。 アプリケーションがRaspberryPiにダウンロードされます。 プログラムを起動します（ F5 鍵）。 サーボモーターは左から右へと着実に回転し始めます。 The PLC_PRG SFCで実装されたプログラムがこれを担当します。軸をオンに切り替えてから、で終了位置として指定された-60と+60の位置の間を移動します。 SM_Drive_Servo 軸構成。 位置プリセットは、モデリング サーボで通常行われているように、PWM インターフェースを介して転送されます。 1 ～ 2 ミリ秒の長さの HIGH パルスが、固定周波数 (デフォルト: 50 Hz、Adafruit PWM SoftMotion デバイスのパラメーター) で送信されます。 1 ms は下端位置、2 ms は上端位置を表します。可動範囲はモーターの種類により異なります。モーターが角度で制御されている場合は、可動範囲を測定する必要があります。これを行うには、終了位置 (例では -60、+60) まで駆動し、構成画面で測定位置を入力します。 任意のブラウザ（おそらくスマートフォン）を開き、アドレスを指定します <network address>:8080\/webvisu.htm 。 ビジュアライゼーションが開き、生成された指定位置が表示されます。ベロシティをコントロールできます。 " }, 
{ "title" : "EtherCATの設定 ", 
"url" : "_rtsl_linux_rbp_examples_ethercat.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi \/ サンプルプロジェクト \/ EtherCATの設定 ", 
"snippet" : "要件：BeckhoffEL2008デバイスを搭載したBeckhoffEK1100がイーサネットアダプタに接続されている。 The EtherCAT.project プロジェクトには、EtherCATフィールドバスデバイスが制御されるアプリケーションが含まれています。使用可能な8つの出力がアクティブになります。 EtherCATフィールドバスにRaspberryPiのLANポートを使用する場合は、代替のプログラミングインターフェイスが必要です。 EdimaxN150などのUSBWifiアダプターを使用します。 を開きます EtherCAT.project プロジェクトして更新します。 デバイスツ...", 
"body" : "要件：BeckhoffEL2008デバイスを搭載したBeckhoffEK1100がイーサネットアダプタに接続されている。 The EtherCAT.project プロジェクトには、EtherCATフィールドバスデバイスが制御されるアプリケーションが含まれています。使用可能な8つの出力がアクティブになります。 EtherCATフィールドバスにRaspberryPiのLANポートを使用する場合は、代替のプログラミングインターフェイスが必要です。 EdimaxN150などのUSBWifiアダプターを使用します。 を開きます EtherCAT.project プロジェクトして更新します。 デバイスツリーで、ダブルクリックします 端末 。 デバイスエディタが開きます。 の 通信設定 、 クリック スキャンネットワーク 。 Raspberry Piと開発システムが同じネットワーク上にある場合は、RaspberryPiが表示されて選択できます。 それを選択してクリックします オンライン→ログイン 。 アプリケーションがRaspberryPiにダウンロードされます。 プログラムを起動します（ F5 鍵）。 その後、EL2008端子の出力は連続的に変化します。 " }, 
{ "title" : "OPCUAの構成 ", 
"url" : "_rtsl_linux_rbp_examples_opc_ua.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi \/ サンプルプロジェクト \/ OPCUAの構成 ", 
"snippet" : "The OPCUA.project プロジェクトには、OPCUAクライアントにアクセスするように変数が構成されているアプリケーションが含まれています。これを行うには、の2つの変数 PLC_PRG オブジェクトはで公開されています シンボル構成 物体。 Unified AutomationUaExpertなどの適切なOPCUAクライアントでは、URLを介してRaspberryPiに接続できます。 opc.tcp:\/\/<network address>:4840 。クライアントでは、そのシンボル（公開された変数）が表示され、現在の値が表示されます。シンボル構成で書き込み権限が付与されている場合は、...", 
"body" : "The OPCUA.project プロジェクトには、OPCUAクライアントにアクセスするように変数が構成されているアプリケーションが含まれています。これを行うには、の2つの変数 PLC_PRG オブジェクトはで公開されています シンボル構成 物体。 Unified AutomationUaExpertなどの適切なOPCUAクライアントでは、URLを介してRaspberryPiに接続できます。 opc.tcp:\/\/<network address>:4840 。クライアントでは、そのシンボル（公開された変数）が表示され、現在の値が表示されます。シンボル構成で書き込み権限が付与されている場合は、シンボルに書き込むことができます。 " }, 
{ "title" : "SenseHATの構成 ", 
"url" : "_rtsl_linux_rbp_examples_sense_hat.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ Raspberry Pi \/ サンプルプロジェクト \/ SenseHATの構成 ", 
"snippet" : "要件: Raspberry Pi Sense HAT アドオンボード。 あ Raspberry Pi Sense HAT アドオン ボードを接続すると、加速度、温度、気圧のセンサーに加え、ジャイロスコープと磁力計のセンサーが装備されます。したがって、たとえば気象観測所を作成できます。 プロジェクト SenseHat.project SenseHATアドオンボードを操作するためのアプリケーションを提供します。 サンプルアプリケーションの機能： センサーデータの測定と表示 センサーの制御 ジョイスティックによる制御 ユーザーインターフェース：...", 
"body" : "要件: Raspberry Pi Sense HAT アドオンボード。 あ Raspberry Pi Sense HAT アドオン ボードを接続すると、加速度、温度、気圧のセンサーに加え、ジャイロスコープと磁力計のセンサーが装備されます。したがって、たとえば気象観測所を作成できます。 プロジェクト SenseHat.project SenseHATアドオンボードを操作するためのアプリケーションを提供します。 サンプルアプリケーションの機能： センサーデータの測定と表示 センサーの制御 ジョイスティックによる制御 ユーザーインターフェース： " }, 
{ "title" : "PLCnext ", 
"url" : "_rtsl_plcnext.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ PLCnext ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "アプリケーション固有の注意事項 ", 
"url" : "_rtsl_plcnext_hints.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ PLCnext \/ アプリケーション固有の注意事項 ", 
"snippet" : "特別な使用例を最適化するには、次のアプリケーション\/構成設定をお勧めします。...", 
"body" : "特別な使用例を最適化するには、次のアプリケーション\/構成設定をお勧めします。 " }, 
{ "title" : "ユースケースの構成: PROFINET ", 
"url" : "_rtsl_plcnext_hints.html#UUID-1e21ef99-5642-2ae9-585e-0f712913f733_section-idm4605464568745633478907338798", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ PLCnext \/ アプリケーション固有の注意事項 \/ ユースケースの構成: PROFINET ", 
"snippet" : "使用時 PROFINET 、次の指示に従う必要があります。 可能な限り、マルチコア機能を使用してください CODESYS . その際、core 0 を使用してください。 PROFINET タスク。 可能であれば、別のネットワーク アダプターを使用してください。 PROFINET 繋がり。 アプリケーションが停止している場合でもフィールドバスがフレームの送受信を継続できるようにしたい場合は、 停止中のリフレッシュ I\/O PLC設定のオプション。...", 
"body" : "使用時 PROFINET 、次の指示に従う必要があります。 可能な限り、マルチコア機能を使用してください CODESYS . その際、core 0 を使用してください。 PROFINET タスク。 可能であれば、別のネットワーク アダプターを使用してください。 PROFINET 繋がり。 アプリケーションが停止している場合でもフィールドバスがフレームの送受信を継続できるようにしたい場合は、 停止中のリフレッシュ I\/O PLC設定のオプション。 " }, 
{ "title" : "ユーザーケースの構成: Axioline ", 
"url" : "_rtsl_plcnext_hints.html#UUID-1e21ef99-5642-2ae9-585e-0f712913f733_section-idm458155578255363347890799443", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ PLCnext \/ アプリケーション固有の注意事項 \/ ユーザーケースの構成: Axioline ", 
"snippet" : "Axioline を使用する際は、次の指示に従ってください。 可能な限り、マルチコア機能を使用してください CODESYS . その際、コア 1 を Axioline タスクとバス サイクル タスクに使用します。 PLCNext コントローラーの一部の Axioline モジュールには、「PDI オブジェクト」と呼ばれる追加情報があります。この情報には、次の方法でアクセスできます。 IoDrvPLCNextAxioLib.PdiRead と IoDrvPLCNextAxioLib.PdiWrite ....", 
"body" : "Axioline を使用する際は、次の指示に従ってください。 可能な限り、マルチコア機能を使用してください CODESYS . その際、コア 1 を Axioline タスクとバス サイクル タスクに使用します。 PLCNext コントローラーの一部の Axioline モジュールには、「PDI オブジェクト」と呼ばれる追加情報があります。この情報には、次の方法でアクセスできます。 IoDrvPLCNextAxioLib.PdiRead と IoDrvPLCNextAxioLib.PdiWrite . " }, 
{ "title" : "CODESYS Virtual Control for Linux SL ", 
"url" : "_rtsl_codesys_virtual_for_linux_control_sl.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ CODESYS Virtual Control for Linux SL ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "概要 ", 
"url" : "_rtsl_virtual_control_sl_overview.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ CODESYS Virtual Control for Linux SL \/ 概要 ", 
"snippet" : "の CODESYS Virtual Control for Linux SL アドオンを使用して、仮想ランタイムとゲートウェイ インスタンスを管理できます。 仮想ランタイム システムは、Docker または Podman コンテナー テクノロジーに基づいて構築されます。 たとえば、Docker はイメージとコンテナを区別します。イメージは、システムの残りの部分からカプセル化されたプロセスを実行するコンテナーのテンプレートです。カプセル化により、ハードウェアに関係なく、同じシステム上で複数のコンテナを同時に実行できるようになります。 CODESYS Virtual Control for Lin...", 
"body" : "の CODESYS Virtual Control for Linux SL アドオンを使用して、仮想ランタイムとゲートウェイ インスタンスを管理できます。 仮想ランタイム システムは、Docker または Podman コンテナー テクノロジーに基づいて構築されます。 たとえば、Docker はイメージとコンテナを区別します。イメージは、システムの残りの部分からカプセル化されたプロセスを実行するコンテナーのテンプレートです。カプセル化により、ハードウェアに関係なく、同じシステム上で複数のコンテナを同時に実行できるようになります。 CODESYS Virtual Control for Linux SL はこれらの機能を使用して、ハードウェアに依存しないコントローラーを提供します。 「Runtime Deploy」ツールを使用してイメージをターゲット システムに転送し、イメージからインスタンスを作成し、これらのインスタンスを管理する方法について説明します。 コンテナベースのコントローラーランタイム システムの起動インスタンスへの接続の確立 CODESYS Virtual Control SL " }, 
{ "title" : "インスタンスへの接続の確立 ", 
"url" : "_rtsl_extablish_connection_to_instance.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ CODESYS Virtual Control for Linux SL \/ インスタンスへの接続の確立 ", 
"snippet" : "ランタイムインスタンスへの直接接続の確立 ポート転送を使用すると、ランタイム インスタンスに直接接続できます。これには、ランタイム インスタンス以外のインスタンスは必要ありません。 要件 直接通信用のランタイム インスタンスのポート ( 11740 ）を転送する必要があります。 ノート： これはランタイム インスタンスのデフォルト構成ではありませんが、インスタンスは後で構成する必要があります。 同じターゲットデバイス上で同じポートを複数設定することはできません。ただし、次の空きポートを 2 番目のランタイム インスタンスに使用することは可能です。例： 11741:11740 構成済みの到達可能...", 
"body" : "ランタイムインスタンスへの直接接続の確立 ポート転送を使用すると、ランタイム インスタンスに直接接続できます。これには、ランタイム インスタンス以外のインスタンスは必要ありません。 要件 直接通信用のランタイム インスタンスのポート ( 11740 ）を転送する必要があります。 ノート： これはランタイム インスタンスのデフォルト構成ではありませんが、インスタンスは後で構成する必要があります。 同じターゲットデバイス上で同じポートを複数設定することはできません。ただし、次の空きポートを 2 番目のランタイム インスタンスに使用することは可能です。例： 11741:11740 構成済みの到達可能なゲートウェイが存在します。このゲートウェイは同じネットワーク上にある必要はありません。 で コミュニケーション タブで、アクティブなゲートウェイを選択します。 次に、接続するデバイスの側で、ランタイムインスタンスを実行しているホストシステムのIPアドレスを入力し、その後に転送されたポートを入力します。 タブ： コミュニケーション : ターゲットデバイス上のゲートウェイインスタンス ゲートウェイ インスタンスを使用して、 CODESYS ランタイムインスタンスへの接続。 要件： ゲートウェイ通信用のゲートウェイ インスタンス ポート ( 1217 ）を転送する必要があります。これは、ゲートウェイ インスタンスのデフォルト構成です。 ゲートウェイ インスタンスとランタイム インスタンスは同じコンテナ ネットワーク上に存在する必要があります。これはデフォルトの構成です。 ここで、実行中のインスタンスに接続するには、新しいインスタンスを作成します CODESYS とのプロジェクト CODESYS Virtual Control for Linux SL デバイス。 新しいゲートウェイを作成します。新しいゲートウェイには、ホスト コンピューターの IP アドレスを指定します。 CODESYS Virtual Control for Linux SL で実行されています IPアドレス のフィールド ゲートウェイ ダイアログ。 新しいゲートウェイを選択し、ネットワーク スキャンを実行します。 構成および開始されたランタイム インスタンスが表示されます。 " }, 
{ "title" : "構成: CODESYS Virtual Control for Linux SL ", 
"url" : "_rtsl_reference.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ CODESYS Virtual Control for Linux SL \/ 構成: CODESYS Virtual Control for Linux SL ", 
"snippet" : "インスタンスのオプションを設定する [構成] 価値 [説明] 自動起動 TRUE または FALSE ターゲットデバイスの起動\/起動時にインスタンスが自動的に起動します。依存関係は解決され、インスタンスは正しい順序で起動されます。 機能 コンマで区切られたリスト。例: cap_sys_admin, cap_sched, cap_chown, cap_ipc_lock ターゲットデバイス上のインスタンスの権限。 リアルタイムのコンプライアンスには事前選択が必要です。 Docker の設定については、以下を参照してください。 Docker ドキュメント:ランタイム権限と Linux 機能 依存関係...", 
"body" : "インスタンスのオプションを設定する [構成] 価値 [説明] 自動起動 TRUE または FALSE ターゲットデバイスの起動\/起動時にインスタンスが自動的に起動します。依存関係は解決され、インスタンスは正しい順序で起動されます。 機能 コンマで区切られたリスト。例: cap_sys_admin, cap_sched, cap_chown, cap_ipc_lock ターゲットデバイス上のインスタンスの権限。 リアルタイムのコンプライアンスには事前選択が必要です。 Docker の設定については、以下を参照してください。 Docker ドキュメント:ランタイム権限と Linux 機能 依存関係 ストリング 現在のインスタンスが依存するインスタンスのコンマ区切りリスト。そのため、ここに一覧表示されているインスタンスは、共有メモリを利用できるように事前に起動されます。指定したインスタンスが存在しない場合、エラーメッセージが表示されます。 Inst_B,Inst_C 現在のインスタンスの場合 (たとえば、 Inst_A ) は次のコマンドで起動されます。 [選択して開始] コマンドを入力すると、次のような警告が表示されます。 Inst_B と Inst_C また、起動する必要があります。これが確認されると、この 2 つのインスタンスが最初に起動し、次に Instance_A インスタンス。 ホスト名 ストリング インスタンスのネットワーク名 デフォルト値はインスタンス名です。 画像 ストリング インスタンスに使用されている画像 IPC ストリング 基本的に、以下でも指定されているすべての値 Docker ドキュメント フィールド用は許可されています。 フィールドが検証されるのは、フィールドに次の情報が含まれている場合のみです。 container: プレフィックス。Docker Docs によると、これは既存の共有メモリを使用する (「結合」) ために使われるそうです。この共有メモリは、にちなんで名付けられたインスタンスで作成する必要があります。 container: を使用する shareable キーワード。インスタンスの起動時に共有メモリが使用可能であることを確認するには、そのあとに入力されたインスタンスに対応する依存関係を定義する必要があります container: プレフィックス。 共有可能 なし container:Inst_first ライセンスサーバー ストリング ライセンスサーバーの IP アドレス コンマで区切られたリストで指定 例: 192.168.0.1,10.0.0.1,172.17.0.2 マウント カンマ区切りリスト インスタンスをホストにマウントします。 シンタックスで指定する Host path:Instance path メモ: 道は絶対的なものです。 ホストパスにはインスタンス名が含まれます。デフォルトマウント (data\/conf) では、このパスを変更しないでください [ネットワーク] ストリング インスタンスがホストにマウントされるネットワーク。 以下を参照してください。 Docker ドキュメント:ネットワーク設定 注:指定できるネットワークは 1 つだけです。 Docker networks allow containers to communicate with each other. If the configured Docker network does not exist yet, then a new one will be created. The IP address of the respective instance within this network can be configured via the Nic field. For more information about Docker networks, see the Docker documentation . ニック ストリング インスタンスに排他的に割り当てられるターゲットシステムのネットワークアダプターの構成。この構成は、イーサネットベースのフィールドバスを使用する場合に必要です 構成には次の形式が使用されます。 <Nic>\/<IP>\/<network mask>,<Nic2>\/<IP2>\/<network mask2>,... 複数のネットワークアダプタをカンマで区切ったリストで指定できます。 例: 必要な構成 「優しい」構成 NIC : eno1 IP : 192.168.0.100 マスク: 255.255.255.0 → \/24 eno1\/192.168.0.100\/24 NIC : eno1 IP :- マスク:- NIC2 : eno2 IP2 : 192.168.0.100 マスク 2: 255.255.248.0 → \/21 eno1,eno2\/102.168.0.100\/21 NIC : eno1 IP :- マスク:- NIC2 : いいえ 2 IP2 :- マスク2:- eno1,2eno2 メモ: 1 つのアダプタは 1 つのインスタンスにのみ割り当てることができます。 その結果、このアダプタはターゲットシステムでも使用できなくなります。 IP アドレスは、対応するネットワークマスクと一緒に指定する必要があります。 ネットワークマスクはサフィックスで指定されます (例:「\/24\" または「\/21\")。 1 つのアダプターに複数の IP アドレスを割り当てることはできません。 ポート コンマで区切られたリスト。例: 1217:1217, 8081:8080 ランタイムインスタンスが使用するポート シンタックスで指定する HostPort:InstancePort (カンマで区切られたリスト) 注:1 つのホストポートを複数回割り当てることはできません。 一般的なユースケースやポートについては、以下を参照してください。 CODESYS Control例: Gateway 1217. Webvisu (https) 443, OPC UA 4840 製品タイプ Runtime \/ Gateway 製品のタイプ:ランタイムまたはゲートウェイ この値は変更できません。 テクノロジー Docker \/ Podman ターゲットシステムで使用されるコンテナテクノロジー この値は変更できません。 次回メンテナンスモードで起動 TRUE または FALSE Only for CODESYS Virtual Edge Gateway for Linux and CODESYS Edge Gateway for Linux This setting determines whether or not the Edge Gateway is started in maintenance mode. In this mode, a connection between the Edge Gateway and the Automation Server can be configured using the CODESYS Automation Server Connector . このモードは安全な環境でのみ使用してください。 このモードは、30 分後、ゲートウェイが再起動されたとき、または設定が完了した後に無効になります。 " }, 
{ "title" : "CODESYS TargetVisu for Linux SL ", 
"url" : "_rtsl_target_visu_for_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ CODESYS TargetVisu for Linux SL ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "設定 CODESYS TargetVisu for Linux SL ", 
"url" : "_rtsl_target_visu_for_linux.html#UUID-016a8869-7c4e-0746-0a61-0b8ff307940e_section-idm234374412744104", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ CODESYS TargetVisu for Linux SL \/ 設定 CODESYS TargetVisu for Linux SL ", 
"snippet" : "デフォルトでは、ターゲットビジュアライゼーションは、コントローラーとの接続を確立するために必要な情報を取得するために、起動時にいくつかのダイアログを表示します。この情報は保存され、ターゲットビジュアライゼーションの設定によって後で変更または削除できます これらのパラメーターは、初めてビジュアライゼーションを開始する前に定義することもできます。その後、ビジュアライゼーションを開始してもダイアログは表示されなくなります [設定] [アプリケーション] ビジュアライゼーションが実行されているアプリケーションの名前 コーデシスパスワード のパスワード CODESYS ビジュアライゼーションがコントロー...", 
"body" : "デフォルトでは、ターゲットビジュアライゼーションは、コントローラーとの接続を確立するために必要な情報を取得するために、起動時にいくつかのダイアログを表示します。この情報は保存され、ターゲットビジュアライゼーションの設定によって後で変更または削除できます これらのパラメーターは、初めてビジュアライゼーションを開始する前に定義することもできます。その後、ビジュアライゼーションを開始してもダイアログは表示されなくなります [設定] [アプリケーション] ビジュアライゼーションが実行されているアプリケーションの名前 コーデシスパスワード のパスワード CODESYS ビジュアライゼーションがコントローラーにログインする際に使用するユーザー。 コーデシスユーザー ビジュアライゼーションがコントローラーにログインする際に使用するユーザー名。 ホスト名 ビジュアライゼーションが接続する PLC のホスト名。この名前は、ほとんどの Linux ディストリビューションでは以下を使用して決定できます hostname コマンド。現在のターゲットデバイスのコントローラーに接続するには、この PLC のホスト名をここで定義する必要があります。 次回起動時に設定をリクエスト 設定がリセットされ、ターゲットビジュアライゼーションは次回起動時に対応するダイアログのすべての情報を要求します。 " }, 
{ "title" : "自動スタート ", 
"url" : "_rtsl_target_visu_for_linux.html#UUID-016a8869-7c4e-0746-0a61-0b8ff307940e_section-idm234374413098957", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ CODESYS TargetVisu for Linux SL \/ 自動スタート ", 
"snippet" : "ターゲット デバイスを再起動すると、ターゲット ビジュアライゼーションが自動的に開きます。すべてのモジュールが読み込まれ、アプリケーションが表示されるまで、最大 1 分かかる場合があります。PLC との接続が初めて確立されるときは、ビジュアライゼーションで使用されるアセットを最初に転送する必要があるため、少し時間がかかる場合があります。...", 
"body" : "ターゲット デバイスを再起動すると、ターゲット ビジュアライゼーションが自動的に開きます。すべてのモジュールが読み込まれ、アプリケーションが表示されるまで、最大 1 分かかる場合があります。PLC との接続が初めて確立されるときは、ビジュアライゼーションで使用されるアセットを最初に転送する必要があるため、少し時間がかかる場合があります。 " }, 
{ "title" : "前に CODESYS TargetVisu for Linux SL バージョン 4.13.0.0 ", 
"url" : "_rtsl_target_visu_for_linux.html#UUID-016a8869-7c4e-0746-0a61-0b8ff307940e_section-idm234461986157731", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ CODESYS TargetVisu for Linux SL \/ 自動スタート \/ 前に CODESYS TargetVisu for Linux SL バージョン 4.13.0.0 ", 
"snippet" : "自動起動は、 .desktop ファイル。パッケージをインストールするには 2 つの方法があります。 保存する codesysvisualization.desktop ファイル \/etc\/xdg\/autostart\/ 起動スクリプトを添付する ~\/.xinitrc あるいは \/etc\/X11\/xinit これらのディレクトリがシステムに存在しない場合、またはこれらのディレクトリを使用していない場合は、自動起動を自分で設定する必要があります。起動スクリプトと停止スクリプトは次の場所にあります。 \/opt\/codesysvisualization\/scripts ディレクトリ構造の詳細については...", 
"body" : "自動起動は、 .desktop ファイル。パッケージをインストールするには 2 つの方法があります。 保存する codesysvisualization.desktop ファイル \/etc\/xdg\/autostart\/ 起動スクリプトを添付する ~\/.xinitrc あるいは \/etc\/X11\/xinit これらのディレクトリがシステムに存在しない場合、またはこれらのディレクトリを使用していない場合は、自動起動を自分で設定する必要があります。起動スクリプトと停止スクリプトは次の場所にあります。 \/opt\/codesysvisualization\/scripts ディレクトリ構造の詳細については、以下を参照してください。 https:\/\/content.helpme-codesys.com\/de\/CODESYS コントロール\/_rtsl_linux_installation_without_pm.html CODESYS TargetVisu for Linux SL 現在の Linux アカウントのログイン動作は変更されません。Linux アカウントで自動ログインが無効になっている場合でも、視覚化を開始するには認証が必要です。 " }, 
{ "title" : "で CODESYS TargetVisu for Linux SL バージョン 4.13.0.0 以上 ", 
"url" : "_rtsl_target_visu_for_linux.html#UUID-016a8869-7c4e-0746-0a61-0b8ff307940e_section-idm234461987255572", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ 製品固有の構成 \/ CODESYS TargetVisu for Linux SL \/ 自動スタート \/ で CODESYS TargetVisu for Linux SL バージョン 4.13.0.0 以上 ", 
"snippet" : "自動起動は次のように実装されます systemd ユニットファイルは以下にあります ~\/.config\/systemd\/user\/codesysvisualization.service 自動起動を自分で設定するには、次のようにしてサービスを永久に無効にすることができます。 systemctl --user disable codesysvisualization またはユニットファイルを変更して再ロードします systemctl --user daemon-reload 。...", 
"body" : "自動起動は次のように実装されます systemd ユニットファイルは以下にあります ~\/.config\/systemd\/user\/codesysvisualization.service 自動起動を自分で設定するには、次のようにしてサービスを永久に無効にすることができます。 systemctl --user disable codesysvisualization またはユニットファイルを変更して再ロードします systemctl --user daemon-reload 。 " }, 
{ "title" : "CODESYS Virtual Safe Control for Linux SL ", 
"url" : "_rtsl_codesys_virtual_for_linux_control_sl-1825956.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Virtual Safe Control for Linux SL ", 
"snippet" : "ザル CODESYS Virtual Safe Control for Linux SL は、ハードウェアに依存しない機能的に安全なコントローラで、独立したランタイムシステムとして機能的に並行して動作します。 CODESYS Virtual Control SL コントローラー。 このドキュメントは情報提供のみを目的としていることに注意してください。安全性と認証に関する制限事項や情報については、安全マニュアルを参照してください H1 – SafetyManual.pdf 。 操作する場合 CODESYS Virtual Safe Control for Linux SL セキュリティホワイトペ...", 
"body" : "ザル CODESYS Virtual Safe Control for Linux SL は、ハードウェアに依存しない機能的に安全なコントローラで、独立したランタイムシステムとして機能的に並行して動作します。 CODESYS Virtual Control SL コントローラー。 このドキュメントは情報提供のみを目的としていることに注意してください。安全性と認証に関する制限事項や情報については、安全マニュアルを参照してください H1 – SafetyManual.pdf 。 操作する場合 CODESYS Virtual Safe Control for Linux SL セキュリティホワイトペーパーのセキュリティ要件を遵守する必要があります。 詳細については、以下を参照してください。 CODESYS セキュリティホワイトペーパー セーフティクリティカルなアプリケーションの開発に関する詳細については CODESYS 以下を参照してください。 ディレクトリ ..\/<user>\/CODESYS Virtual Safe Control Linux SL\/Delivery\/Manuals に格納されている安全マニュアル H1 – SafetyManual.pdf CODESYS Safety Extension 初期設定方法の説明 CODESYS Virtual Safe Control for Linux SL はシナリオで説明されています。 「セーフハウス」シナリオ:vPLC + vSafe + ProfiSafe + タイムプロバイダー + ライセンスサーバー。 " }, 
{ "title" : "タイムスタンプ例外 ", 
"url" : "_rtsl_timestamp_exceptions.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Virtual Safe Control for Linux SL \/ タイムスタンプ例外 ", 
"snippet" : "次のセクションでは、セーフコントローラーの時間動作を検証する際に発生する可能性のあるエラーについて説明します。時間の動作を検証するには、独立したセカンドタイムベースが必要です...", 
"body" : "次のセクションでは、セーフコントローラーの時間動作を検証する際に発生する可能性のあるエラーについて説明します。時間の動作を検証するには、独立したセカンドタイムベースが必要です " }, 
{ "title" : "さまざまなタイムスタンプ ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm234959765203734", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Virtual Safe Control for Linux SL \/ タイムスタンプ例外 \/ さまざまなタイムスタンプ ", 
"snippet" : "3 つのタイムスタンプを使用して、セーフコントローラーの時間動作を検証します。 Remote Timestamp : タイムプロバイダーのコンピューターから取得したタイムスタンプ。 Sample Timestamp : 受信時にローカルで取得されたタイムスタンプ。 Local Timestamp : アプリケーション実行時にローカルで取得されたタイムスタンプ。...", 
"body" : "3 つのタイムスタンプを使用して、セーフコントローラーの時間動作を検証します。 Remote Timestamp : タイムプロバイダーのコンピューターから取得したタイムスタンプ。 Sample Timestamp : 受信時にローカルで取得されたタイムスタンプ。 Local Timestamp : アプリケーション実行時にローカルで取得されたタイムスタンプ。 " }, 
{ "title" : "発生する可能性のあるエラーメッセージ ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm234959951496687", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Virtual Safe Control for Linux SL \/ タイムスタンプ例外 \/ 発生する可能性のあるエラーメッセージ ", 
"snippet" : "タイムプロバイダーによるすべてのエラーは、4 つの 16 進数値を返します。これらはマイクロ秒単位の時間値です。これらには以下の意味があります。 値 1: 最後の 2 つの間の時間 Local Timestamps 値 2: 最後の 2 つの間の時間 Remote Timestamps 値 3: 最後の 2 つの間の時間 Sample Timestamps 値 4: 最後の受信までの時間 Remote Timestamps およびこのタイムスタンプの評価 値の順序は、エラーメッセージの順序に対応しています。 時間検証中に発生する可能性のあるエラーメッセージは 3 つあります。以下に、このエラー...", 
"body" : "タイムプロバイダーによるすべてのエラーは、4 つの 16 進数値を返します。これらはマイクロ秒単位の時間値です。これらには以下の意味があります。 値 1: 最後の 2 つの間の時間 Local Timestamps 値 2: 最後の 2 つの間の時間 Remote Timestamps 値 3: 最後の 2 つの間の時間 Sample Timestamps 値 4: 最後の受信までの時間 Remote Timestamps およびこのタイムスタンプの評価 値の順序は、エラーメッセージの順序に対応しています。 時間検証中に発生する可能性のあるエラーメッセージは 3 つあります。以下に、このエラーの原因となるチェック、発生したエラー、および考えられるエラーの原因について説明します。には、最初に発生したエラーだけが記録されます。 [ログ] タブ このエラーの発生後、IEC アプリケーションは既に停止しているためです。 エラーの原因をより詳細に分析するには、エラーメッセージとともに出力される4つの16進数値を表示できます。 " }, 
{ "title" : "メッセージ: Plausibility check of the local timestamp to the cycle time ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm43495995265356", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Virtual Safe Control for Linux SL \/ タイムスタンプ例外 \/ 発生する可能性のあるエラーメッセージ \/ メッセージ: Plausibility check of the local timestamp to the cycle time ", 
"snippet" : "チェック: 設定されたサイクルタイムと最後のサイクルからの実際の経過時間の比較。 Local Timestamp このために使用されます。 エラー: サイクルごとに行われる内部時間測定では、経過時間（コンピューターの内部時計による）が設定サイクルタイムから 5% 以上ずれていることがわかります。 一般的な原因: 安全なアプリケーションのスケジューリングに問題があります。...", 
"body" : "チェック: 設定されたサイクルタイムと最後のサイクルからの実際の経過時間の比較。 Local Timestamp このために使用されます。 エラー: サイクルごとに行われる内部時間測定では、経過時間（コンピューターの内部時計による）が設定サイクルタイムから 5% 以上ずれていることがわかります。 一般的な原因: 安全なアプリケーションのスケジューリングに問題があります。 " }, 
{ "title" : "メッセージ: Plausibility check of the remote timestamp to the cycle time ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm43495995331862", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Virtual Safe Control for Linux SL \/ タイムスタンプ例外 \/ 発生する可能性のあるエラーメッセージ \/ メッセージ: Plausibility check of the remote timestamp to the cycle time ", 
"snippet" : "チェック: 設定したサイクルタイムと直近の 2 つのサイクルタイムの比較 Sample Timestamps 。ザック Sample Timestamp が使用されています。 サイクル内で受信した最後の有効なタイムスタンプが常に使用されます。以前のものは破棄されます。つまり、タイムスタンプが無効であってもすぐにシステムエラーにはならないということです エラー: 新品なし Remote Timestamp 1 サイクル以上受信されている。 一般的な原因: タイムプロバイダーがダウンまたは停止しました コントローラとタイムプロバイダの間にネットワーク接続がありません ネットワーク障害 重大なスケジ...", 
"body" : "チェック: 設定したサイクルタイムと直近の 2 つのサイクルタイムの比較 Sample Timestamps 。ザック Sample Timestamp が使用されています。 サイクル内で受信した最後の有効なタイムスタンプが常に使用されます。以前のものは破棄されます。つまり、タイムスタンプが無効であってもすぐにシステムエラーにはならないということです エラー: 新品なし Remote Timestamp 1 サイクル以上受信されている。 一般的な原因: タイムプロバイダーがダウンまたは停止しました コントローラとタイムプロバイダの間にネットワーク接続がありません ネットワーク障害 重大なスケジューリング問題 " }, 
{ "title" : "メッセージ: Plausibility check of remote timestamp to local timestamp ", 
"url" : "_rtsl_timestamp_exceptions.html#UUID-2b00d10b-ddc3-549d-9da5-91b0a31c7221_section-idm43495995376508", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Virtual Safe Control for Linux SL \/ タイムスタンプ例外 \/ 発生する可能性のあるエラーメッセージ \/ メッセージ: Plausibility check of remote timestamp to local timestamp ", 
"snippet" : "チェック: 最後の 2 つの間隔の比較 Sample Timestamps 使用済みと最後の 2 つの間の間隔 Remote Timestamps 使用済み。ザック Sample Timestamp と Remote Timestamp が使用されています。 エラー: 最後の 2 つの間隔の差 Sample Timestamps と最後の 2 つの間の間隔 Remote Timestamps 許容値の 5% を超えています。 一般的な原因: タイムプロバイダーのスケジュールに関する問題 タイムスタンプを受信するためのスレッドのスケジューリング問題 伝送ネットワークの遅延（スイッチなど）...", 
"body" : "チェック: 最後の 2 つの間隔の比較 Sample Timestamps 使用済みと最後の 2 つの間の間隔 Remote Timestamps 使用済み。ザック Sample Timestamp と Remote Timestamp が使用されています。 エラー: 最後の 2 つの間隔の差 Sample Timestamps と最後の 2 つの間の間隔 Remote Timestamps 許容値の 5% を超えています。 一般的な原因: タイムプロバイダーのスケジュールに関する問題 タイムスタンプを受信するためのスレッドのスケジューリング問題 伝送ネットワークの遅延（スイッチなど） " }, 
{ "title" : "アプリケーション開始 ", 
"url" : "_rtsl_application_start.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Virtual Safe Control for Linux SL \/ アプリケーション開始 ", 
"snippet" : "の場合 CODESYS Virtual Safe Control SL では、ブートアプリケーションの起動をユーザーが確認する必要があります。 で CODESYS Safety Extension バージョン 4.3.0.0 以降では、新しいステータス ( waiting for confirmation ) がプロジェクトツリーとアクティブなアプリケーションのステータスに表示されます。 と CODESYS Safety Extension バージョン 4.3.0.0 より前のバージョンでは、デバイスツリーにもステータスにも表示されません。ただし、ステータスはセーフコントローラのログから取得で...", 
"body" : "の場合 CODESYS Virtual Safe Control SL では、ブートアプリケーションの起動をユーザーが確認する必要があります。 で CODESYS Safety Extension バージョン 4.3.0.0 以降では、新しいステータス ( waiting for confirmation ) がプロジェクトツリーとアクティブなアプリケーションのステータスに表示されます。 と CODESYS Safety Extension バージョン 4.3.0.0 より前のバージョンでは、デバイスツリーにもステータスにも表示されません。ただし、ステータスはセーフコントローラのログから取得できます。 ザ・ ブートアプリを起動する ファンクションブロックは、ダウンロードしたブートアプリケーションの起動を確認するために使用されます。 ブートアプリケーションを起動するための条件: FB 出力の現在の値 SafeApplication.BootAppConfirmation に転送する必要があります StartBootApp ファンクションブロック。 クライアント ID を指定する必要があります。ClientID はランタイムシステムの CFG ファイルで定義されます 標準アプリケーションのデフォルト設定: 16#ED387206 。 クライアントID、ファームウェアバージョン、AppID、および値 SafeApplication.BootAppConfirmtion コントローラーに送信する必要があります。これは以下のようにして行われます StartBootApp ファンクションブロック。 詳細については、以下を参照してください。 CODESYS セーフティエクステンション . " }, 
{ "title" : "CODESYS Virtual Safe Time Provider ", 
"url" : "_rtsl_virtual_safe_time_provider.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Virtual Safe Time Provider ", 
"snippet" : "その CODESYS Virtual Safe Time Provider ユーザーが秒と外部タイムベースを転送するために使用できる標準インターフェースです。 CODESYS Virtual Safe Control 。 実装はクライアントとして行われ、独立したタイムベースを持つ別のシステム上で実行する必要があります。...", 
"body" : "その CODESYS Virtual Safe Time Provider ユーザーが秒と外部タイムベースを転送するために使用できる標準インターフェースです。 CODESYS Virtual Safe Control 。 実装はクライアントとして行われ、独立したタイムベースを持つ別のシステム上で実行する必要があります。 " }, 
{ "title" : "インストール ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm234964887312564", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Virtual Safe Time Provider \/ インストール ", 
"snippet" : "その CODESYS Virtual Safe Time Provider SLは、 CODESYS Control SL Deploy Tool 詳細については、以下を参照してください。 「セーフハウス」シナリオ:vPLC + vSafe + ProfiSafe + タイムプロバイダー + ライセンスサーバー。 その CODESYS Virtual Safe Time Provider SLは、 CODESYS Virtual Safe Control SL。...", 
"body" : "その CODESYS Virtual Safe Time Provider SLは、 CODESYS Control SL Deploy Tool 詳細については、以下を参照してください。 「セーフハウス」シナリオ:vPLC + vSafe + ProfiSafe + タイムプロバイダー + ライセンスサーバー。 その CODESYS Virtual Safe Time Provider SLは、 CODESYS Virtual Safe Control SL。 " }, 
{ "title" : "機能性 ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm234964887538634", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Virtual Safe Time Provider \/ 機能性 ", 
"snippet" : "その Time Provider 2番目の時間情報源として機能します CODESYS Virtual Safe Control SL は、定義された間隔でネットワーク経由でタイムスタンプをメッセージとして送信します。 このメッセージは、さまざまな受信者によって受信され、評価されます（ CODESYS Virtual Safe Control l SL、冗長 Time Provider ）。 その CODESYS Virtual Safe Control SL は、外部タイマーからの少なくとも 1 つのタイムスタンプが到着する必要がある定義されたサイクル タイムでアプリケーションを実行します。 ...", 
"body" : "その Time Provider 2番目の時間情報源として機能します CODESYS Virtual Safe Control SL は、定義された間隔でネットワーク経由でタイムスタンプをメッセージとして送信します。 このメッセージは、さまざまな受信者によって受信され、評価されます（ CODESYS Virtual Safe Control l SL、冗長 Time Provider ）。 その CODESYS Virtual Safe Control SL は、外部タイマーからの少なくとも 1 つのタイムスタンプが到着する必要がある定義されたサイクル タイムでアプリケーションを実行します。 送信間隔は Time Provider アプリケーションのサイクルタイムの半分未満になるように構成する必要があります。 ネットワークやスケジュールの問題による安定性を高めるため Time Provider そして、 CODESYS Virtual Safe Control SL、 Time Provider 冗長的に実行できます。 2 つのタイプが区別されます。 " }, 
{ "title" : "Time Provider 冗長性 ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm43496653769816", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Virtual Safe Time Provider \/ 機能性 \/ Time Provider 冗長性 ", 
"snippet" : "の場合 Time Provider 冗長性、2 Time Provider インスタンスは2つの独立したホスト上で実行されます。1つのインスタンスはアクティブな送信者として機能し、もう1つのインスタンスはタイムスタンプの送信をパッシブに監視します。 機能を使用するには、2 つ Time Provider インスタンスを起動し、冗長パラメータを次のように設定する必要があります。 TRUE どちらの場合も。 アクティブインスタンスのタイムスタンプの送信が遅れたり、行われなかったりすると、パッシブインスタンスはアクティブインスタンスの最新の既知のオフセットを使用して送信を直ちに引き継ぎます。つまり、...", 
"body" : "の場合 Time Provider 冗長性、2 Time Provider インスタンスは2つの独立したホスト上で実行されます。1つのインスタンスはアクティブな送信者として機能し、もう1つのインスタンスはタイムスタンプの送信をパッシブに監視します。 機能を使用するには、2 つ Time Provider インスタンスを起動し、冗長パラメータを次のように設定する必要があります。 TRUE どちらの場合も。 アクティブインスタンスのタイムスタンプの送信が遅れたり、行われなかったりすると、パッシブインスタンスはアクティブインスタンスの最新の既知のオフセットを使用して送信を直ちに引き継ぎます。つまり、 CODESYS Virtual Safe Control SL。両方のインスタンスが同じネットワーク上で実行されることが重要です。そうすることで初めて、パッシブインスタンスはアクティブインスタンスから送信されたメッセージを監視できるようになります。 アクティブな Time Provider ネットワークがバス上で別のアクティブなインスタンスを検出すると、最も優先度の高い IP アドレスを持つインスタンスがアクティブなままになり、他のすべてのインスタンスはパッシブ モードになります。 " }, 
{ "title" : "ネットワークの冗長性 ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm43496653810142", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Virtual Safe Time Provider \/ 機能性 \/ ネットワークの冗長性 ", 
"snippet" : "ネットワーク冗長性の場合、 Time Provider インスタンスはそれぞれ独自のネットワークを使用する。 Time Provider 冗長性。しかし、受動的な Time Provider 遅延や障害が発生した場合に送信を引き継ぐために、アクティブなインスタンスからメッセージを受信するためのインスタンス。 ネットワーク冗長性はまだ実装されていません。...", 
"body" : "ネットワーク冗長性の場合、 Time Provider インスタンスはそれぞれ独自のネットワークを使用する。 Time Provider 冗長性。しかし、受動的な Time Provider 遅延や障害が発生した場合に送信を引き継ぐために、アクティブなインスタンスからメッセージを受信するためのインスタンス。 ネットワーク冗長性はまだ実装されていません。 " }, 
{ "title" : "構成 ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm234964888427036", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Virtual Safe Time Provider \/ 構成 ", 
"snippet" : "オプション 説明 デフォルト値 -a\/--address ターゲットIPアドレス 127.0.0.1 (ローカルホスト) -p\/--port ターゲットポート 60000 -c\/--cycletime 送信間隔 Time Provider タイムスタンプ（ミリ秒） 3 -P\/--priority SCHED_FIFO スケジューリング優先度 55 -C\/--cpu_pin CPUピンニング すべてのスレッドは、値 0 から始まる定義済みの CPU に固定されます。 0 -r\/--redundancy 冗長モード ディセーブルにすると、 Time Provider タイムスタンプを直ちに送信しま...", 
"body" : "オプション 説明 デフォルト値 -a\/--address ターゲットIPアドレス 127.0.0.1 (ローカルホスト) -p\/--port ターゲットポート 60000 -c\/--cycletime 送信間隔 Time Provider タイムスタンプ（ミリ秒） 3 -P\/--priority SCHED_FIFO スケジューリング優先度 55 -C\/--cpu_pin CPUピンニング すべてのスレッドは、値 0 から始まる定義済みの CPU に固定されます。 0 -r\/--redundancy 冗長モード ディセーブルにすると、 Time Provider タイムスタンプを直ちに送信します。 有効にすると、 Time Provider 他に優先順位の高いものがない場合にのみ送信します。 Time Provider 送信中です。 詳細については、以下を参照してください。 Time Provider無効 -s\/--syslog のログ記録 syslog に \/dev\/log 無効 --stat_print_time 診断間隔（秒） 60 IPアドレスのデフォルト値は127.0.0.1（localhost）です。この値は試運転とテストにのみ使用してください。 Time Provider 独立したタイムベースを提供するため、ローカルで操作することはできません。デフォルト値を使用する場合は、 Time Provider 警告を発します。 " }, 
{ "title" : "診断 ", 
"url" : "_rtsl_virtual_safe_time_provider.html#UUID-4c41c3df-d398-1f10-66f2-611a282e87ed_section-idm234964888678287", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Virtual Safe Time Provider \/ 診断 ", 
"snippet" : "ページのタイムスタンプを評価する際に発生する可能性のあるエラーは、 CODESYS Virtual Safe Control SL: 設定されたポートはすでに使用されています。 設定されたポートがすでに使用されており、開くことができない場合は、次のメッセージが発行されます。 Could not open port <Port number> it is already in use! アクティブインスタンスでのタイムスタンプの送信が遅延されるか、行われません。 アクティブ送信者のタイムスタンプが遅れたり送信されなかったりして、パッシブ Time Provider インスタンスが送信を引き継ぐと...", 
"body" : "ページのタイムスタンプを評価する際に発生する可能性のあるエラーは、 CODESYS Virtual Safe Control SL: 設定されたポートはすでに使用されています。 設定されたポートがすでに使用されており、開くことができない場合は、次のメッセージが発行されます。 Could not open port <Port number> it is already in use! アクティブインスタンスでのタイムスタンプの送信が遅延されるか、行われません。 アクティブ送信者のタイムスタンプが遅れたり送信されなかったりして、パッシブ Time Provider インスタンスが送信を引き継ぐと、次の診断メッセージが発行されます。 Started sending: take over from higher priority time provider <priority> 優先度の高い Time Provider インスタンスが再び利用可能になり、以前のパッシブ インスタンスから送信を引き継ぐと、次のメッセージが発行されます。 Stopped sending: higher priority time provider is active: <priority> タイムスタンプの周期的な統計（アクティブインスタンス\/送信者） 送信されたタイムスタンプの統計は、設定された間隔で発行されます（ -stat_print_time オプション）はマイクロ秒単位（us）で指定します。送信間隔の最小値と最大値、および設定された期間における平均値が出力されます。 Statistics: min: <minimum sending interval>, max: <maximum sending interval>, avg: <average sending interval> - send time interval タイムスタンプの周期的な統計（パッシブインスタンス\/レシーバー） パッシブ インスタンスはアクティブ インスタンスから送信されたタイムスタンプを受信するため、受信した情報を診断目的で評価できます。 統計は設定された間隔で発行されます（ -stat_print_time オプション）は、マイクロ秒[us]とパーセンテージ[%]の分解能で表示されます。最小間隔と最大間隔、および設定された期間の平均値が表示されます。 Statistics: min: <minimum deviation>, max: <maximum deviation>, avg: <average deviation> - remote to sample time deviation Statistics: min: <minimum sample interval>, max: <maximum sample interval>, avg: <average sample interval> - sample time interval Statistics: min: <minimum remote interval>, max: <maximum remote interval>, avg: <average remote interval> - remote time interval 失われたメッセージのカウンター アクティブインスタンスによってタイムスタンプが送信されない場合、カウンターが増分され、出力されます。 Statistics: lost messages: <number of lost messages> " }, 
{ "title" : "パフォーマンス最適化 ", 
"url" : "_rtsl_performance_optimization_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ パフォーマンス最適化 ", 
"snippet" : "このページでは、デバイスの設定方法を紹介します。 CODESYS Virtual Control SL そして、可能な限り最高のパフォーマンスを実現するためのアプリケーション。 システムの現在のステータスを確認および評価するために使用できるツールを提供します。 以下の手順をお勧めします。これらの手順を指定された順序で実行してください。現在のステップが必要なほど最適化されていない場合、次のステップに進むのは意味がありません。 ハードウェアのチェックLinuxのセットアップCODESYS ランタイム システムの構成IEC アプリケーションの構成各ステップの後で、最後の変更が前のステップの最適化に悪...", 
"body" : "このページでは、デバイスの設定方法を紹介します。 CODESYS Virtual Control SL そして、可能な限り最高のパフォーマンスを実現するためのアプリケーション。 システムの現在のステータスを確認および評価するために使用できるツールを提供します。 以下の手順をお勧めします。これらの手順を指定された順序で実行してください。現在のステップが必要なほど最適化されていない場合、次のステップに進むのは意味がありません。 ハードウェアのチェックLinuxのセットアップCODESYS ランタイム システムの構成IEC アプリケーションの構成各ステップの後で、最後の変更が前のステップの最適化に悪影響を与えていないことを確認してください。 通常の負荷で望ましいパフォーマンスを達成した後、オプションで高負荷でのテストを実行できます。 stress-ng または iperf 。 詳細については、次の Web サイトを参照してください。 Linux財団 リニュートロニクス " }, 
{ "title" : "ハードウェアのチェック ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm4640115908976034154363059654", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ パフォーマンス最適化 \/ ハードウェアのチェック ", 
"snippet" : "コントローラーのプロセッサ コアには共有キャッシュを使用しないでください。 ターゲットデバイスにイーサネットベースのフィールドバスを使用している場合は、それらに物理アダプタを使用してください。スイッチ アーキテクチャは使用しないでください。...", 
"body" : "コントローラーのプロセッサ コアには共有キャッシュを使用しないでください。 ターゲットデバイスにイーサネットベースのフィールドバスを使用している場合は、それらに物理アダプタを使用してください。スイッチ アーキテクチャは使用しないでください。 " }, 
{ "title" : "Linuxのセットアップ ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm43415437655754", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ パフォーマンス最適化 \/ Linuxのセットアップ ", 
"snippet" : "リアルタイム カーネルを使用します。 RT プリエンプト カーネルの使用をお勧めします ( https:\/\/rt.wiki.kernel.org ) Linux システム用。 Debian および Ubuntu ディストリビューションの場合、RT カーネルはパッケージとして提供されており、次のコマンドを使用して簡単にインストールできます。 apt 指示。詳細については、ディストリビューションのマニュアルを参照してください。 Debian システムの場合 sudo apt-get install linux-image-rt-amd64 使用しているカーネルを確認してください uname -a ...", 
"body" : "リアルタイム カーネルを使用します。 RT プリエンプト カーネルの使用をお勧めします ( https:\/\/rt.wiki.kernel.org ) Linux システム用。 Debian および Ubuntu ディストリビューションの場合、RT カーネルはパッケージとして提供されており、次のコマンドを使用して簡単にインストールできます。 apt 指示。詳細については、ディストリビューションのマニュアルを参照してください。 Debian システムの場合 sudo apt-get install linux-image-rt-amd64 使用しているカーネルを確認してください uname -a 指示。例えば。 システム上でウィンドウ マネージャー、GUI\/X サーバー、または類似のものを使用することは避けてください。 これらのツールを使用すると、システムのリアルタイム機能に影響を及ぼし、IEC アプリケーションで高いジッターが発生する可能性があります。 テスト 「rt-tools」の使用: 「rt-tools」のインストール: sudo apt install rt-tests 「cyclictest」を開始します。 sudo cyclictest -p 99 -t -m の man cyclictest コマンドでは、システムのより詳細な、または特定のパフォーマンス側面をより適切に測定するために使用できる、より多くのコマンド ライン オプションが表示されます。 「cyclictest」で求めた値が「良好」とみなせるかどうかはハードウェアに依存します。非常に強力なプロセッサ (Intel Core i7 など) を使用している場合は、最大値として 1 桁の低い数値を設定する必要があります。古い ARM プロセッサを使用している場合は、100 が適切な結果になる可能性があります。 最適化オプション 各設定または設定の組み合わせを変更したら、「サイクリックテスト」プログラムを実行して変更の有効性を検証する必要があります。 これらの設定は永続的ではないため、システムの起動または再起動後にリセットする必要があります。 CPU の省エネモードを無効にします。 ハイパースレッディングを無効にします。 次のコマンドを使用してハイパースレッディングを無効にできます (例)。 echo off | sudo tee \/sys\/devices\/system\/cpu\/smt\/control CPU 周波数のスケーリングと切り替えを可能な限り無効にします。 たとえば、CPU 周波数の最小値と最大値を同じ (固定) 値に設定します。 Linux カーネルのリアルタイムスロットリングメカニズムを無効にしてください。これにより、システムにジッターが発生する可能性があります。 詳細については、以下を参照してください。 Linux の基礎:スケジューリング — RT スロットリング 次のコマンドを使用してリアルタイムスロットリングを無効にできます (例)。 echo -1 > \/proc\/sys\/kernel\/sched_rt_runtime_us スケジューリング\/スケーリングガバナーを確認および変更します。 使用されているスケジューリング\/スケーリング ガバナーを確認します。 cat \/sys\/devices\/system\/cpu\/cpu0\/cpufreq\/scaling_governor 使用するスケジューリング\/スケーリングガバナーを変更します( root\/admin ） に Performance : echo \"performance\" > \/sys\/devices\/system\/cpu\/cpu0\/cpufreq\/scaling_governor\n# set it for all available cores:\necho \"performance\" > \/sys\/devices\/system\/cpu\/cpu1\/cpufreq\/scaling_governor\necho \"performance\" > \/sys\/devices\/system\/cpu\/cpu2\/cpufreq\/scaling_governor\necho \"performance\" > \/sys\/devices\/system\/cpu\/cpu3\/cpufreq\/scaling_governor システムを起動するたびにスケーリング ガバナをリセットする必要があることに注意してください。カーネル構成を使用して設定することもできます。 の intel_pstate カーネルドライバーにより、正しい設定がより困難になる場合があります。したがって、次を使用する必要があります。 cpufreq-info コマンドを使用して構成を確認します。 次のようなプログラムも使用できます。 cpu-freq-utils 。これにより、Intel psstate ドライバーが妨害される可能性があります。これらのドライバーは通常、CPU 周波数を設定するために別のアプローチを必要とします。 詳細については、以下を参照してください。 https:\/\/www.kernel.org\/doc\/Documentation\/cpu-freq\/governors.txt 無効にする HyperV BIOS 内 (利用可能な場合)。 " }, 
{ "title" : "CODESYS ランタイム システムの構成 ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm4554832147912034154456684842", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ パフォーマンス最適化 \/ CODESYS ランタイム システムの構成 ", 
"snippet" : "システムを最適化するアプリケーションを大まかに説明するテスト アプリケーションを作成します (必要なリソース、必要なパフォーマンス、プロジェクト サイズの観点から)。 これを繰り返し行うことができます。最初に非常に大まかな近似を作成し、それを拡張して実際のアプリケーションにどんどん近づけます。 テスト アプリケーションの実行中に、タスクの構成を確認します。を開きます。 タスクの構成 そして、 モニター タブ。 分。ジッタ (μs) \/ 最大ジッター (μs) 値は、「cycletest」プログラムによって決定された値にできるだけ近い必要があります。詳細はセクションで説明されています Linux...", 
"body" : "システムを最適化するアプリケーションを大まかに説明するテスト アプリケーションを作成します (必要なリソース、必要なパフォーマンス、プロジェクト サイズの観点から)。 これを繰り返し行うことができます。最初に非常に大まかな近似を作成し、それを拡張して実際のアプリケーションにどんどん近づけます。 テスト アプリケーションの実行中に、タスクの構成を確認します。を開きます。 タスクの構成 そして、 モニター タブ。 分。ジッタ (μs) \/ 最大ジッター (μs) 値は、「cycletest」プログラムによって決定された値にできるだけ近い必要があります。詳細はセクションで説明されています Linuxのセットアップ。 ジッターと遅延の詳細については、以下を参照してください。 ジッターとレイテンシーの定義 [監視] タブの詳細については、次を参照してください。 タブ: モニタリング 平均サイクル時間 (μs) \/ 最大サイクルタイム (μs) サイクルタイム (μs) 最大サイクルは、設定されたサイクル タイムに決して近づいてはなりません。これにより、システムに高負荷がかかるとすぐに問題が発生します。 サイクルタイムは常にできるだけ短くしてください。 最適化オプション 各設定または設定の組み合わせを変更した後、「cyclictest」プログラムを実行して変更の有効性を確認する必要があります。 長時間実行されるタスクを複数の小さなタスクに分割します。 実行中、最も優先度の高いタスクの最大サイクル タイムは、設定されたサイクル タイムに決して達してはなりません。これを回避できない場合は、設定されたサイクル タイムを増やして、一貫した実行時間を確保する必要があります。 フィールドバス システム (EtherCAT や PROFINET など) を開始する場合、開始サイクルにより CPU 負荷がわずかに高くなる可能性があります。この場合、アプリケーションの起動直後に CPU 負荷を監視することが合理的です。 次のオプションは変更できません CODESYS Virtual Control SL ただし、ホスト上で構成する必要があります。 の値を設定します DisableCpuDmaLatency 1に: [SysCpuHandling]\nLinux.DisableCpuDmaLatency=1 これはランタイム バージョン 4.11.0.0 のデフォルト設定であることに注意してください。 ランタイムのバージョンを確認するには、 エクストラ → Linuxをアップデートする → システム → システム情報 。 本当にリアルタイムカーネルが使用されているか確認してください。 バージョン 4.11.0.0 では、PLC シェル コマンドを使用できます。 rt-get kernelinfo これを確認するために。 古いバージョンをお使いの場合は、コマンドラインで次のコマンドを使用してこれを直接実行できます。 uname -a 。 リアルタイム カーネルが使用されていない場合は、最初からやり直す必要があります。 " }, 
{ "title" : "IEC アプリケーションの構成 ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm4633380190436834154474610871", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ パフォーマンス最適化 \/ IEC アプリケーションの構成 ", 
"snippet" : "このセクションでは、実際のアプリケーションについて説明します。 テスト 前のステップのテストを使用できます CODESYS ランタイム システムの構成 IEC アプリケーションをテストします。 最適化オプション 各設定または設定の組み合わせを変更した後、「cyclictest」プログラムを実行して変更の有効性を確認する必要があります。 使用できます マルチコア の特徴 CODESYS 。 タスクの正しい優先順位を決定します。重要なタスクは優先順位を高くする必要があります。 IEC タスクの優先順位と Linux スレッドの優先順位のマッピング: IEC タスクの優先順位 Linuxの優先順位 ...", 
"body" : "このセクションでは、実際のアプリケーションについて説明します。 テスト 前のステップのテストを使用できます CODESYS ランタイム システムの構成 IEC アプリケーションをテストします。 最適化オプション 各設定または設定の組み合わせを変更した後、「cyclictest」プログラムを実行して変更の有効性を確認する必要があります。 使用できます マルチコア の特徴 CODESYS 。 タスクの正しい優先順位を決定します。重要なタスクは優先順位を高くする必要があります。 IEC タスクの優先順位と Linux スレッドの優先順位のマッピング: IEC タスクの優先順位 Linuxの優先順位 -- 88 (SCHED_FIFO) -- 57 (SCHED_FIFO) 0 (リアルタイム優先度が最も高い) 56 (SCHED_FIFO) 15 (リアルタイム優先度が最も低い) 41 (SCHED_FIFO) 16 (リアルタイム優先ではない) 0 (SCHED_OTHER) 31 (リアルタイム優先ではない) 0 (SCHED_OTHER) -- 0 (SCHED_OTHER) 従来の Linux システムでは、ほとんどの割り込み (IRQ) とカーネルワーカーは Linux の優先度が 50 です。それを上回る優先順位 (高負荷) を使用すると、システム機能 (ネットワーク\/ストレージ) が期待どおりに動作しなくなる可能性があります タスクの優先度は、それぞれのタスク設定で設定できます。 ここで説明したすべての手順を実行しても望ましいパフォーマンスが得られない場合は、次のセクションを参照してください。 フィールドバス固有の情報[専門家向け] – 追加のツールとトピック" }, 
{ "title" : "フィールドバス固有の情報 ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm4494465964555234154489740927", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ パフォーマンス最適化 \/ フィールドバス固有の情報 ", 
"snippet" : "テスト チェックしてください Send Time \/ Recv Time EtherCAT ステータス ページの値。 Intel Core i7 プロセッサを搭載した x64 CPU と適切なアダプタでは、10µs 未満になるはずです。 チップが統合された ARM プロセッサでは、最大 50µs 以上の時間がかかります。 チェックしてください Send Time \/ Recv Time PROFINET ステータス ページの値。 Intel Core i7 プロセッサを搭載した x64 CPU と適切なアダプタでは、10µs 未満になるはずです。 チップが統合された ARM プロセッサでは、最...", 
"body" : "テスト チェックしてください Send Time \/ Recv Time EtherCAT ステータス ページの値。 Intel Core i7 プロセッサを搭載した x64 CPU と適切なアダプタでは、10µs 未満になるはずです。 チップが統合された ARM プロセッサでは、最大 50µs 以上の時間がかかります。 チェックしてください Send Time \/ Recv Time PROFINET ステータス ページの値。 Intel Core i7 プロセッサを搭載した x64 CPU と適切なアダプタでは、10µs 未満になるはずです。 チップが統合された ARM プロセッサでは、最大 50µs 以上の時間がかかります。 最適化オプション 優先順位と必要な IRQ を並べ替えるには、PLC シェル コマンドを使用できます。 irq-list そして irq-set-prio 。 これらのコマンドは、IEC 優先順位ではなく、通常の Linux 優先順位を使用します。 この最適化は次の場合には実行できません。 CODESYS Virtual Control SL 、むしろホストシステム上で。 デバイスには別のネットワーク アダプターを使用してください。 詳細については、以下を参照してください。 EtherCAT プロフィネット イーサネット\/IP CANbus、CANopen " }, 
{ "title" : "[専門家向け] – 追加のツールとトピック ", 
"url" : "_rtsl_performance_optimization_linux.html#UUID-0a752033-08e7-49dd-3978-a0f62b06eb2d_section-idm464011317245123415449146407", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ 構成と拡張 \/ パフォーマンス最適化 \/ [専門家向け] – 追加のツールとトピック ", 
"snippet" : "このセクションで説明するツールとオプションは上級ユーザーのみを対象としており、取るべき対策は問題のシステムに大きく依存するため、独自の調査が必要です。したがって、当社では具体的な解決策を提供することはできません。 KernelShark \/ カーネル トレース これは、パフォーマンスの問題の原因がスケジュールにあることが判明した場合に最適なプログラムです。 「カーネル トレース」を使用すると、タスクが別のタスク、別のサービス、または割り込みによって中断されているかどうかを確認できます。 trace-cmd record -p function KernelShark を使用して、生成された t...", 
"body" : "このセクションで説明するツールとオプションは上級ユーザーのみを対象としており、取るべき対策は問題のシステムに大きく依存するため、独自の調査が必要です。したがって、当社では具体的な解決策を提供することはできません。 KernelShark \/ カーネル トレース これは、パフォーマンスの問題の原因がスケジュールにあることが判明した場合に最適なプログラムです。 「カーネル トレース」を使用すると、タスクが別のタスク、別のサービス、または割り込みによって中断されているかどうかを確認できます。 trace-cmd record -p function KernelShark を使用して、生成された trace.dat ファイル。 一般に、スケジュールの問題は次の 2 つのカテゴリに分類できます。 スーパーセッション\/プリエンプション 実行を妨げる割り込みやタスクが不要な場合は、割り込みを禁止してください。 自分のタスクの優先度を上げるか、他のタスクの優先度を下げます。 別の CPU コアに切り替えます。 前の章で説明したプログラムを使用して、変更の有効性を確認します。 実行時間 以下の「カーネル関数トレース」を参照してください。 カーネル関数トレース コードの実行時間が長すぎると判断した場合は、このツールを使用して問題を特定できます。 実行時間が長すぎる関数が独自のコードにある場合は、それを最適化する必要があります。 実行時間が長すぎる関数がカーネル内にある場合は、別のカーネル関数を使用して目的の機能の実現を試みることができます。あるいは、実行時間を短縮するために、カーネル ドライバーに構成パラメーターを渡すこともできます。 これらのオプションのいずれも問題を解決しない場合は、おそらく、より強力なハードウェアを使用する必要があります。 次の点に注目して、それらがパフォーマンス目標を達成するための正しいツールであるかどうかを確認してください。 PREEMPT_FULL isolcpu rcu_nocbs rcu_nocb_poll ソフトロックアップなし irqbalance の無効化 kernel.sched_rt_runtime_us " }, 
{ "title" : "ユースケース ", 
"url" : "_rtsl_use_cases_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "公開鍵認証で接続する ", 
"url" : "_rtsl_linux_public_key_authentification.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ 公開鍵認証で接続する ", 
"snippet" : "SSHを使用すると、安全で暗号化され、認証されたコントローラーへの接続が可能になります。これにより、安全な設定でコントローラのリモート管理を実行できます。 認証は、認証情報 (ユーザー名とパスワード) を入力することで実行できます。鍵ベースの認証 (公開鍵認証) を使用すれば、より強力な方法を選択することもできます。ユーザーはキーを使用してコントローラーにログオンします。キーはパブリックキーとプライベートキーで構成されます。この種のキーペアは、パスワードよりも侵害がはるかに困難です ロギング操作は、コントローラーの公開鍵が開発システムの秘密鍵と一致するかどうかをチェックします。この場合、パスワ...", 
"body" : "SSHを使用すると、安全で暗号化され、認証されたコントローラーへの接続が可能になります。これにより、安全な設定でコントローラのリモート管理を実行できます。 認証は、認証情報 (ユーザー名とパスワード) を入力することで実行できます。鍵ベースの認証 (公開鍵認証) を使用すれば、より強力な方法を選択することもできます。ユーザーはキーを使用してコントローラーにログオンします。キーはパブリックキーとプライベートキーで構成されます。この種のキーペアは、パスワードよりも侵害がはるかに困難です ロギング操作は、コントローラーの公開鍵が開発システムの秘密鍵と一致するかどうかをチェックします。この場合、パスワードを使用せずにアクセスが許可されます。 で使用されるSSHキーを作成します CODESYS Windowsベースの開発システム。オプションでパスフレーズを指定して、公開鍵認証のセキュリティをさらに高めることができます。公開鍵を1つまたは複数のコントローラーにコピーできます。これは、たとえば、複数のコントローラーで構成されるマシンで望ましい場合があります。秘密鍵は常に開発システムに残り、いかなる状況でも共有してはなりません。 秘密鍵は絶対に共有しないでください。 " }, 
{ "title" : "SSHキーの作成 ", 
"url" : "_rtsl_linux_public_key_authentification.html#UUID-3411cc39-494f-56fd-579b-6a59fc3a254e_section-idm4635616815128032538919569496", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ 公開鍵認証で接続する \/ SSHキーの作成 ", 
"snippet" : "まず、秘密鍵と公開鍵で構成されるSSH鍵をWindowsで作成します。 オープンソースの「PuTTY」ツールをインストールします。 さまざまなアプリケーションがあります C:\\Program Files (x86)\\PuTTY 。 「PuTTYgen」ツールを開きます。 次のダイアログが開きます。 を選択 RSA オプションをクリックし、 生む ボタン。 キーの作成が始まります。 それまでの間、キーが作成されるまで、プログレスバーの下の空きスペースにマウスを移動します。 次のダイアログが開きます。 必要に応じて、で安全で一意のパスフレーズを指定できます キーパスフレーズ と パスフレーズを確認...", 
"body" : "まず、秘密鍵と公開鍵で構成されるSSH鍵をWindowsで作成します。 オープンソースの「PuTTY」ツールをインストールします。 さまざまなアプリケーションがあります C:\\Program Files (x86)\\PuTTY 。 「PuTTYgen」ツールを開きます。 次のダイアログが開きます。 を選択 RSA オプションをクリックし、 生む ボタン。 キーの作成が始まります。 それまでの間、キーが作成されるまで、プログレスバーの下の空きスペースにマウスを移動します。 次のダイアログが開きます。 必要に応じて、で安全で一意のパスフレーズを指定できます キーパスフレーズ と パスフレーズを確認する 。 パスフレーズを割り当てた場合、キーも保護されます。キーを使用してコントローラーにログインするたびに、パスフレーズが必要になります。 CODESYS 。パスフレーズを秘密にして、許可された人だけがそれを知っているようにします。 クリック 秘密鍵を保存する ボタンをクリックしてファイル名を指定します（例： serviceuser.ppk ）。 クリック 保存する 。 秘密のPPKキーが作成されます。 をクリックします コンバージョン → OpenSSH キーをエクスポートする コマンド。 ファイル名を指定します（例： serviceuser.openssh ）。 秘密のOPENSSHキーが作成されます。 の中に OpenSSHauthorized_keysファイルに貼り付けるための公開鍵 テキストフィールドで、文字列全体を選択します。 で コンテキストメニュー 、クリック コピー 文字列をクリップボードにコピーしてテキストファイルに貼り付けます。テキストファイルに名前を付けます (例: serviceuser.pub )。 秘密のPUBキーが作成されます。 キーを開発用コンピューターの適切な、場合によっては非表示の場所に移動します。または、開発システムに残っているUSBスティックにファイルを保存します。 たとえば、秘密鍵と公開鍵は現在、 D:\\PLCs\\BeagleBone\\Keys ディレクトリ。 秘密鍵が常に開発システムに残っていることを確認してください。秘密鍵は決して共有してはなりません。 " }, 
{ "title" : "公開鍵をコントローラーにコピーする ", 
"url" : "_rtsl_linux_public_key_authentification.html#UUID-3411cc39-494f-56fd-579b-6a59fc3a254e_section-idm4635616712388832538922040216", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ 公開鍵認証で接続する \/ 公開鍵をコントローラーにコピーする ", 
"snippet" : "公開鍵をコピーします（例： serviceuser.pub ）コントローラーに。ベンダー情報に注意してください。...", 
"body" : "公開鍵をコピーします（例： serviceuser.pub ）コントローラーに。ベンダー情報に注意してください。 " }, 
{ "title" : "秘密鍵のリンク CODESYS ", 
"url" : "_rtsl_linux_public_key_authentification.html#UUID-3411cc39-494f-56fd-579b-6a59fc3a254e_section-idm4570645292920032538924011205", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ 公開鍵認証で接続する \/ 秘密鍵のリンク CODESYS ", 
"snippet" : "[開く] CODESYS そして、をクリックします ツール → コントロール SL をデプロイ コマンド。 で コミュニケーション タブ、展開します。 キーベースログイン セクション。 をクリックします キーファイルを追加 ボタン。 ファイル選択ダイアログが開きます。 目的の秘密鍵（OPENSSHファイル）を選択します。 例： serviceuser.openssh クリック わかった ダイアログを確認します。 ダイアログが閉じます。今 CODESYS 秘密鍵を持っています。 また、オプションで秘密鍵をリンクすることもできます。 ランタイム・デプロイ・ツール カテゴリ。...", 
"body" : "[開く] CODESYS そして、をクリックします ツール → コントロール SL をデプロイ コマンド。 で コミュニケーション タブ、展開します。 キーベースログイン セクション。 をクリックします キーファイルを追加 ボタン。 ファイル選択ダイアログが開きます。 目的の秘密鍵（OPENSSHファイル）を選択します。 例： serviceuser.openssh クリック わかった ダイアログを確認します。 ダイアログが閉じます。今 CODESYS 秘密鍵を持っています。 また、オプションで秘密鍵をリンクすることもできます。 ランタイム・デプロイ・ツール カテゴリ。 " }, 
{ "title" : "SSHキーを使用したキーベースのログイン ", 
"url" : "_rtsl_linux_public_key_authentification.html#UUID-3411cc39-494f-56fd-579b-6a59fc3a254e_section-idm4570645233654432538931011655", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ 公開鍵認証で接続する \/ SSHキーを使用したキーベースのログイン ", 
"snippet" : "SSHキーを使用してコントローラーにログインします。 をクリックします ツール → コントロール SL をデプロイ コマンド。 の ランタイム デプロイ ツール 開きます。 を選択 キーに基づくSSHログイン オプション。 リストボックスには、で知られているすべてのキーが表示されます CODESYS 。 目的のキーを選択します serviceuser.openssh 。 ユーザー名とパスワードを指定し、必要に応じてパスフレーズをそれぞれの入力フィールドに入力します。 クリック スキャン ボタン。 ネットワークがスキャンされ、一致するコントローラーが検出されます。検索結果が表示されます。 コント...", 
"body" : "SSHキーを使用してコントローラーにログインします。 をクリックします ツール → コントロール SL をデプロイ コマンド。 の ランタイム デプロイ ツール 開きます。 を選択 キーに基づくSSHログイン オプション。 リストボックスには、で知られているすべてのキーが表示されます CODESYS 。 目的のキーを選択します serviceuser.openssh 。 ユーザー名とパスワードを指定し、必要に応じてパスフレーズをそれぞれの入力フィールドに入力します。 クリック スキャン ボタン。 ネットワークがスキャンされ、一致するコントローラーが検出されます。検索結果が表示されます。 コントローラのリストから目的のコントローラを選択します。 たとえば、 システム情報 。 コントローラのSSHサーバーは、秘密鍵が公開鍵と一致するかどうかを確認します。この場合、認証されてログインします。その後、コマンドが実行され、コントローラのシステム情報がに表示されます。 CODESYS 。 " }, 
{ "title" : "Package Manager を使用しない SL 製品のインストール ", 
"url" : "_rtsl_linux_installation_without_pm.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ Package Manager を使用しない SL 製品のインストール ", 
"snippet" : "SL製品の更新ツールは、インストールパッケージ（.debまたは.ipk）をバックグラウンドでターゲットデバイスにコピーし、インストールします。そのためには、ターゲットデバイスにパッケージマネージャー (dpkg または ipkg) をインストールする必要があります。パッケージマネージャーがインストールされていないと、更新ツールはランタイムシステムをインストールできません ただし、必要に応じてパッケージを手動でインストールすることもできます。ジェネリック製品については、以下を使用して説明します。 CODESYS Control​ for Linux 例として V4.7.0.0。 CODESYS ...", 
"body" : "SL製品の更新ツールは、インストールパッケージ（.debまたは.ipk）をバックグラウンドでターゲットデバイスにコピーし、インストールします。そのためには、ターゲットデバイスにパッケージマネージャー (dpkg または ipkg) をインストールする必要があります。パッケージマネージャーがインストールされていないと、更新ツールはランタイムシステムをインストールできません ただし、必要に応じてパッケージを手動でインストールすることもできます。ジェネリック製品については、以下を使用して説明します。 CODESYS Control​ for Linux 例として V4.7.0.0。 CODESYS Control は、ファイルシステムが (部分的に) 書き込み禁止になっているデバイスをサポートしていません。 デバイスに書き込み禁止のファイルシステムがあり、製品のインストールまたは起動時に問題が発生した場合は、書き込み保護を無効にした後も問題が引き続き発生するかどうかを確認してください。 " }, 
{ "title" : "ターゲット デバイスへのランタイム システムの手動インストール ", 
"url" : "_rtsl_linux_installation_without_pm.html#UUID-aa2a93d5-f31b-688e-1fbf-002f3f403c41_section-idm4590635748291233589649632523", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ Package Manager を使用しない SL 製品のインストール \/ ターゲット デバイスへのランタイム システムの手動インストール ", 
"snippet" : "のインストール後 CODESYS Control​ for Linux パッケージに必要なファイルは Windows PC にあります。 <user>\/CODESYS Control for Linux SL\/Delivery\/codesyscontrol_linux_4.7.0.0-b.trunk.39_amd64.deb また <user>\/CODESYS Control for Linux SL\/Delivery\/codesyscontrol_linux_4.7.0.0-b.trunk.39_amd64.ipk <user>\/CODESYS Control for Linux SL\/De...", 
"body" : "のインストール後 CODESYS Control​ for Linux パッケージに必要なファイルは Windows PC にあります。 <user>\/CODESYS Control for Linux SL\/Delivery\/codesyscontrol_linux_4.7.0.0-b.trunk.39_amd64.deb また <user>\/CODESYS Control for Linux SL\/Delivery\/codesyscontrol_linux_4.7.0.0-b.trunk.39_amd64.ipk <user>\/CODESYS Control for Linux SL\/Dependency\/codemeter-lite_<Version>.deb (ライセンス用) これらのファイルをターゲット デバイスにコピーします。 パッケージを解凍します。 $ ar -x codesyscontrol_linux_<Version> 次のファイルが作成されます。 control.tar.gz : インストールまたはアンインストールの前後にパッケージ マネージャーが実行するスクリプトが含まれます。これは、手動インストールには関係ありません。 data.tar.gz : ランタイム システム バイナリ、ライブラリ、起動スクリプト、および構成が含まれています。 debian-binary : .deb パッケージのバージョンを指定します。これは、手動インストールには関係ありません。 開梱 data.tar.gz ファイル。このための新しいフォルダーを事前に作成します。 $ mkdir data\n$ tar -xf data.tar.gz -C data の data\/ 、ランタイム システムの操作に重要なファイルを見つけることができます。 data\n├── etc\n│ ├── default\n│ │ └── codesyscontrol\n│ ├── init.d\n│ │ └── codesyscontrol\n│ └── codesyscontrol\n│ ├── 3S.dat\n│ ├── CODESYSControl.cfg\n│ └── CODESYSControl_User.cfg\n├── opt\n│ └── codesys\n│ ├── bin\n│ │ └── codesyscontrol.bin\n│ ├── lib\n│ │ ├── libCmpHilscherCIFX.so\n│ │ └── libSysPci.so\n│ └── scripts\n│ ├── init-functions\n│ ├── init-vars\n│ ├── PlcWink.sh\n│ └── rts_set_baud.sh\n├── usr\n│ └── share\n│ └── doc\n│ └── codesyscontrol\n│ └── copyright\n└── var\n └── opt\n └── codesys\n ├── bacstac.ini\n ├── cmact_licenses\n └── .SoftContainer_CmRuntime.wbb パッケージ マネージャー (dpkg または ipkg) は通常、このディレクトリ構造をシステムのルート ディレクトリにコピーします。これは、パッケージ マネージャーを使用せずに手動で行う必要があります。 に変更 data\/ ディレクトリ data.tar.gz ファイルが解凍されました: $ cd data\/ 個々のディレクトリをターゲットのそれぞれのルート ディレクトリにコピーします。 間違えた場合、この手順でターゲット デバイスが使用できなくなり、リセットする必要があります。 $ sudo cp -r etc\/* \/etc\n$ sudo cp -r opt\/* \/opt\n$ sudo cp -r usr\/* \/usr\n$ sudo cp -r var\/* \/var これで、パッケージ マネージャーは、インストールを完了するためにいくつかのインストール後の手順を実行します。次の手順を手動で実行します。 $ sudo chmod a+rw \/etc\/codesyscontrol\/CODESYSControl.cfg\n$ sudo chmod a+rw \/etc\/codesyscontrol\/CODESYSControl_User.cfg もし codesysuser グループがターゲットデバイスにまだ存在していない場合は追加してください。 $ groupadd codesysuser このグループは、拡張 API に使用されます。詳細については、次を参照してください。 セキュリティメカニズムランタイム システムがインストールされました。ただし、Codemeter ランタイム環境は引き続き必要です。 " }, 
{ "title" : "ターゲット デバイスへの Codemeter ランタイム環境の手動インストール ", 
"url" : "_rtsl_linux_installation_without_pm.html#UUID-aa2a93d5-f31b-688e-1fbf-002f3f403c41_section-idm4590635833291233589649827584", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ Package Manager を使用しない SL 製品のインストール \/ ターゲット デバイスへの Codemeter ランタイム環境の手動インストール ", 
"snippet" : "CODESYS Control SLパッケージのインストール後、.debパッケージは <User>\/CODESYS Control für Linux SL\/Dependency\/codemeter-lite_<Version>.deb に保存されます。 また、この .deb パッケージを、ターゲット システム上に新しく作成された空のフォルダーにコピーします。 Debian パッケージを解凍します。 $ ar -x codemeter-lite_<Version>.deb の control.tar.gz 、 data.tar.gz 、 debian-binary 、また _gpgorigin...", 
"body" : "CODESYS Control SLパッケージのインストール後、.debパッケージは <User>\/CODESYS Control für Linux SL\/Dependency\/codemeter-lite_<Version>.deb に保存されます。 また、この .deb パッケージを、ターゲット システム上に新しく作成された空のフォルダーにコピーします。 Debian パッケージを解凍します。 $ ar -x codemeter-lite_<Version>.deb の control.tar.gz 、 data.tar.gz 、 debian-binary 、また _gpgorigin ファイルが抽出されます。 開梱 data.tar.gz ファイルを新しく作成したフォルダーに入れます。 $ mkdir data\n$ tar -xf data.tar.gz -C data その後、バイナリと、ライブラリやスクリプトなどのその他のファイルは、次の場所にあります。 data\/ : data\n├── etc\n│ ├── init.d\n│ │ ├── codemeter\n│ │ └── codemeter-webadmin\n│ └── wibu\n│ └── CodeMeter\n│ └── Server.ini\n├── lib\n│ ├── systemd\n│ │ └── system\n│ │ ├── codemeter.service\n│ │ └── codemeter-webadmin.service\n│ └── udev\n│ └── rules.d\n│ └── 60-codemeter-lite.rules\n├── usr\n│ ├── bin\n│ │ ├── cmu\n│ │ └── codemeter-info\n│ ├── lib\n│ │ └── x86_64-linux-gnu\n│ │ ├── jni\n│ │ │ ├── libwibucmJNI64.so -> libwibucmJNI.so\n│ │ │ └── libwibucmJNI.so\n│ │ ├── libwibucmlin64-4.so -> libwibucm.so\n│ │ ├── libwibucmlin64.so -> libwibucm.so\n│ │ ├── libwibucmlin.so -> libwibucm.so\n│ │ └── libwibucm.so\n│ ├── sbin\n│ │ ├── CmWebAdmin\n│ │ └── CodeMeterLin\n│ └── share\n│ ├── bash-completion\n│ │ └── completions\n│ │ └── cmu\n│ ├── doc\n│ │ ├── CodeMeter\n│ │ │ ├── OpenSource_en.pdf\n│ │ │ └── README\n│ │ └── codemeter-lite\n│ │ ├── changelog.gz\n│ │ └── copyright\n│ └── man\n│ └── man1\n│ └── codemeter-info.1.gz\n└── var\n ├── lib\n │ └── CodeMeter\n │ ├── Backup\n │ ├── CmAct\n │ ├── CmCloud\n │ ├── NamedUser\n │ └── WebAdmin\n └── log\n └── CodeMeter に変更 data\/ ディレクトリ data.tar.gz ファイルが解凍されました: $ cd data\/ ディレクトリ全体をターゲット デバイスのルート ディレクトリにコピーします。 間違えた場合、この手順でターゲット デバイスが使用できなくなり、リセットする必要があります。 $ sudo cp -r etc\/* \/etc\n$ sudo cp -r lib\/* \/lib\n$ sudo cp -r usr\/* \/usr\n$ sudo cp -r var\/* \/var Codemeter パッケージは、インストールを完了するためにいくつかのインストール後の手順を実行します。次の手順を手動で実行します。 $ sudo udevadm trigger -vn --subsystem-match=usb --attr-match=idVendor=064f | xargs -rn1 -d\\\\n udevadm trigger -b\n$ sudo mkdir -p \"\/etc\/systemd\/system\/multi-user.target.wants\/\"\n$ sudo ln -sT \/lib\/systemd\/system\/codemeter.service \/etc\/systemd\/system\/multi-user.target.wants\/codemeter.service 次に、以下のコマンドでCodemeterサービスを設定する必要があります（ root ): CodemeterLin -x\n Codemeter Lite とランタイム システムのインストールが完了しました。 " }, 
{ "title" : "Edge ゲートウェイの手動インストール: ", 
"url" : "_rtsl_linux_installation_without_pm.html#UUID-aa2a93d5-f31b-688e-1fbf-002f3f403c41_section-idm4604985458336033589650100426", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ Package Manager を使用しない SL 製品のインストール \/ Edge ゲートウェイの手動インストール: ", 
"snippet" : "Edge ゲートウェイは、ランタイム システムおよび Codemeter と同じ方法でインストールできます。 Windows PC では、パッケージは次の場所に保存されます。 <user>\/CODESYS Edge Gateway for Linux\/Delivery\/codesysedge_edgeamd64_<Version>.deb . Debian パッケージをターゲット デバイスの新しい空のフォルダーにコピーします。 Debian パッケージを解凍します。 $ ar -x codesysedge_edgeamd64_<Version>.deb ファイル control.tar.gz ...", 
"body" : "Edge ゲートウェイは、ランタイム システムおよび Codemeter と同じ方法でインストールできます。 Windows PC では、パッケージは次の場所に保存されます。 <user>\/CODESYS Edge Gateway for Linux\/Delivery\/codesysedge_edgeamd64_<Version>.deb . Debian パッケージをターゲット デバイスの新しい空のフォルダーにコピーします。 Debian パッケージを解凍します。 $ ar -x codesysedge_edgeamd64_<Version>.deb ファイル control.tar.gz 、 data.tar.gz と debian-binary 抽出されます。 開梱 data.tar.gz ファイルを新しく作成したフォルダーに: $ mkdir data\n$ tar -xf data.tar.gz -C data その後、バイナリと、ライブラリやスクリプトなどのその他のファイルは、次の場所にあります。 data\/ : data\n├── etc\n│ ├── default\n│ │ └── codesysedge\n│ ├── init.d\n│ │ └── codesysedge\n│ └── codesysedge\n│ ├── Gateway.cfg\n│ ├── GatewayvControl.cfg\n│ └── Gateway_User.cfg\n├── opt\n│ └── codesysedge\n│ ├── bin\n│ │ └── codesysedge.bin\n│ ├── lib\n│ └── scripts\n│ ├── rts_set_baud.sh\n│ └── startup.sh\n├── usr\n│ └── share\n\n│ └── doc\n│ └── codesysedge\n│ └── copyright\n└── var\n └── opt\n └── codesysedge に変更 data\/ ディレクトリ data.tar.gz ファイルが解凍されました: $ cd data\/ ディレクトリ全体をターゲット デバイスのルート ディレクトリにコピーします。 間違えた場合、この手順でターゲット デバイスが使用できなくなり、リセットする必要があります。 $ sudo cp -r etc\/* \/etc\n$ sudo cp -r opt\/* \/opt\n$ sudo cp -r usr\/* \/usr\n$ sudo cp -r var\/* \/var パッケージ マネージャーの後処理手順を再度実行します。 $ chmod a+rw \/etc\/codesysedge\/Gateway.cfg\n$ chmod a+rw \/etc\/codesysedge\/Gateway_User.cfg Edge ゲートウェイがインストールされました。 " }, 
{ "title" : "Codemeter、ランタイム システム、エッジ ゲートウェイの起動 ", 
"url" : "_rtsl_linux_installation_without_pm.html#UUID-aa2a93d5-f31b-688e-1fbf-002f3f403c41_section-idm4554611316182433589650574679", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ Package Manager を使用しない SL 製品のインストール \/ Codemeter、ランタイム システム、エッジ ゲートウェイの起動 ", 
"snippet" : "インストールされたパッケージを開始できるようになりました。 Codemeter $ sudo \/usr\/sbin\/CodeMeterLin Codemeter を起動するには -v 拡張出力を取得するためのフラグ。 の入力で -Help 、より多くの機能についてのヘルプが表示されます。 ランタイム システムとエッジ ゲートウェイ $ sudo \/etc\/init.d\/codesyscontrol start $ sudo \/etc\/init.d\/codesysedge start...", 
"body" : "インストールされたパッケージを開始できるようになりました。 Codemeter $ sudo \/usr\/sbin\/CodeMeterLin Codemeter を起動するには -v 拡張出力を取得するためのフラグ。 の入力で -Help 、より多くの機能についてのヘルプが表示されます。 ランタイム システムとエッジ ゲートウェイ $ sudo \/etc\/init.d\/codesyscontrol start\n$ sudo \/etc\/init.d\/codesysedge start " }, 
{ "title" : "インストール中 CODESYS TargetVisu for Linux SL パッケージマネージャーを使用しない場合 ", 
"url" : "_rtsl_targetvisu_installation_without_pm.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ インストール中 CODESYS TargetVisu for Linux SL パッケージマネージャーを使用しない場合 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "ターゲット デバイスへのランタイム システムの手動インストール ", 
"url" : "_rtsl_targetvisu_installation_without_pm.html#UUID-b70db7d9-478d-5a8c-9e0b-7e2599f42fe7_section-idm4590635748291233589649632523", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ インストール中 CODESYS TargetVisu for Linux SL パッケージマネージャーを使用しない場合 \/ ターゲット デバイスへのランタイム システムの手動インストール ", 
"snippet" : "のインストール後 CODESYS Control​ for Linux パッケージに必要なファイルは Windows PC にあります。 <user>\/CODESYS TargetVisu for Linux SL\/Delivery\/visualization<architecture>\/codesysvisualization_visualizationamd64_4.13.0.0_amd64.deb これらのファイルをターゲット デバイスにコピーします。 パッケージを解凍します。 $ ar -x codesyscontrol_linux_<Version> 次のファイルが作成されます。 c...", 
"body" : "のインストール後 CODESYS Control​ for Linux パッケージに必要なファイルは Windows PC にあります。 <user>\/CODESYS TargetVisu for Linux SL\/Delivery\/visualization<architecture>\/codesysvisualization_visualizationamd64_4.13.0.0_amd64.deb これらのファイルをターゲット デバイスにコピーします。 パッケージを解凍します。 $ ar -x codesyscontrol_linux_<Version> 次のファイルが作成されます。 control.tar.gz : インストールまたはアンインストールの前後にパッケージ マネージャーが実行するスクリプトが含まれます。これは、手動インストールには関係ありません。 data.tar.gz : ランタイム システム バイナリ、ライブラリ、起動スクリプト、および構成が含まれています。 debian-binary : .deb パッケージのバージョンを指定します。これは、手動インストールには関係ありません。 開梱 data.tar.gz ファイル。このための新しいフォルダーを事前に作成します。 $ mkdir data\n$ tar -xf data.tar.gz -C data の data\/ 、ランタイム システムの操作に重要なファイルを見つけることができます。 data\n├── etc\n│ └── codesysvisualization\n│ ├── CODESYSVisualization.cfg\n│ ├── CODESYSVisualizationTV.cfg\n│ └── CODESYSVisualization_User.cfg\n├── opt\n│ └── codesysvisualization\n│ ├── bin\n│ │ └── codesysvisualization.bin\n│ └── codesysvisualization.service\n├── usr\n│ └── share\n│ └── doc\n│ └── codesysvisualization\n│ └── copyright\n└── var \n └── opt \n └── codesysvisualization\n これで、パッケージマネージャー (dpkg) は通常、このディレクトリ構造をシステムのルートディレクトリにコピーします。これはパッケージマネージャーを使わずに手動で行わなければなりません に変更 data\/ ディレクトリ data.tar.gz ファイルが解凍されました: $ cd data\/ 個々のディレクトリをターゲットのそれぞれのルート ディレクトリにコピーします。 間違えた場合、この手順でターゲット デバイスが使用できなくなり、リセットする必要があります。 $ sudo cp -r etc\/* \/etc\n$ sudo cp -r opt\/* \/opt\n$ sudo cp -r usr\/* \/usr\n$ sudo cp -r var\/* \/var これで、パッケージ マネージャーは、インストールを完了するためにいくつかのインストール後の手順を実行します。次の手順を手動で実行します。 $ sudo chmod a+rw \/etc\/codesysvisualization\/CODESYSVisualization.cfg\n$ sudo chmod a+rw \/etc\/codesysvisualization\/CODESYSVisualization_User.cfg もし codesysvisualization グループがターゲットデバイスにまだ存在していない場合は追加してください。 $ groupadd codesysvisualization 追加のフォルダを作成してサービスを準備します。 $ mkdir -p .config\/systemd\/user\/\n$ cp \/opt\/codesysvisualization\/codesysvisualization.service .config\/systemd\/user\/\n$ mkdir -p .config\/systemd\/user\/graphical.target.wants\/\n$ ln -s .config\/systemd\/user\/codesysvisualization.service .config\/systemd\/user\/graphical.target.wants\/. ディレクトリの権限とユーザーを設定します。 $ sudo chmod -R u+x \/etc\/codesysvisualization\/\n$ sudo chmod 740 \/opt\/codesysvisualization\/bin\/codesysvisualization.bin\n$ sudo chmod 640 ~\/.config\/systemd\/user\/codesysvisualization.service\n$ sudo chmod -R 640 \/var\/opt\/codesysvisualization\/\n$ sudo chmod -R u+X \/var\/opt\/codesysvisualization\/\n$ sudo chmod 640 \/usr\/share\/doc\/codesysvisualization\/copyright\n$ sudo chown --recursive <USER> \/var\/opt\/codesysvisualization\n$ sudo chown --recursive <USER> \/opt\/codesysvisualization\/\n$ sudo chown --recursive <USER> \/etc\/codesysvisualization\/\n$ sudo chown --recursive <USER> .config\/systemd\/ " }, 
{ "title" : "パッケージマネージャーを使用しないでライセンスサーバーをインストールする ", 
"url" : "_rtsl_licenseserver_installation_without_pm.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ パッケージマネージャーを使用しないでライセンスサーバーをインストールする ", 
"snippet" : "要件:Codemeter ランタイムがデバイスにインストールされている。 パッケージマネージャーなしで Codemeter をインストールする方法の詳細については、以下を参照してください。 ターゲット デバイスへの Codemeter ランタイム環境の手動インストールCODESYS WBMはコックピットでのみ使用できます。また、コンピューターはターゲットデバイスとインターネットに同時に接続されている必要があります...", 
"body" : "要件:Codemeter ランタイムがデバイスにインストールされている。 パッケージマネージャーなしで Codemeter をインストールする方法の詳細については、以下を参照してください。 ターゲット デバイスへの Codemeter ランタイム環境の手動インストールCODESYS WBMはコックピットでのみ使用できます。また、コンピューターはターゲットデバイスとインターネットに同時に接続されている必要があります " }, 
{ "title" : "Cockpit がインストールされていないか、インストールできない場合: ", 
"url" : "_rtsl_licenseserver_installation_without_pm.html#UUID-9309cb91-08d3-fde6-39f2-4317ba0b2561_section-idm234676479498753", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ パッケージマネージャーを使用しないでライセンスサーバーをインストールする \/ Cockpit がインストールされていないか、インストールできない場合: ", 
"snippet" : "ライセンスサーバーを手動で設定し、ソフトコンテナを作成し、ライセンスをインポートする必要があります。 ライセンスサーバーのセットアップ ストップコードメーター: sudo \/etc\/init.d\/codemeter stop ネットワークサーバーに切り替えます。 これを行うには、値を設定する必要があります IsNetworkServer 1 インチまで \/etc\/wibu\/CodeMeter\/Server.ini : IsNetworkServer=1 変更を保存してコードメーターを起動します。 sudo \/etc\/init.d\/codemeter start ソフトコンテナの作成 ソフトコン...", 
"body" : "ライセンスサーバーを手動で設定し、ソフトコンテナを作成し、ライセンスをインポートする必要があります。 ライセンスサーバーのセットアップ ストップコードメーター: sudo \/etc\/init.d\/codemeter stop ネットワークサーバーに切り替えます。 これを行うには、値を設定する必要があります IsNetworkServer 1 インチまで \/etc\/wibu\/CodeMeter\/Server.ini : IsNetworkServer=1 変更を保存してコードメーターを起動します。 sudo \/etc\/init.d\/codemeter start ソフトコンテナの作成 ソフトコンテナが既に存在するかどうかを確認します。 cmu -x | grep 'FC=6000437' エントリがリストされている場合は、ソフトコンテナがすでに存在するため、このセクションをスキップできます。 ライセンスサーバーの Debian パッケージを解凍します。 このパッケージは通常 CODESYS ライセンスサーバーのパッケージ。これにはファイルが含まれています。 .UFC_SoftContainer_CmRuntime.WibuCmLif in \/opt\/codesyslicenseserver\/bin 。これを、ライセンスサーバーが稼働するはずのデバイスに転送します。 ソフトコンテナの作成: cmu --import --file .UFC_SoftContainer_CmRuntime.WibuCmLif コマンドをチェックしてください cmu -x | grep 'FC=6000437' エントリを返します。 ライセンスをインポートする コマンドを使う cmu -x ライセンスをインポートすべきソフトコンテナのシリアル番号を検出します。 Create the context file: cmu -c 6000437 -s <serial number> --file <file name>.WibuCmRaC Transfer the context file to a device with Internet access. 住所を開く https:\/\/license.codesys.com\/ そして、ライセンスチケットの番号を入力します。 [次へ] そして ライセンスをアクティベート 次のページへ。 次に、目的のコンテナタイプを選択します。 をクリックします ファイルベースのライセンス転送 次のページの右側にあるリンク。 以前に生成されたコンテキストファイルをアップロードし、をクリックします 今すぐアクティベーションを開始 。 ライセンス更新ファイルをダウンロードし、ライセンスサーバーとして機能するデバイスにファイルを転送します。 Import the file: cmu --import --file <file name>.WibuCmRaU The license is now activated. " }, 
{ "title" : "If Cockpit is installed ", 
"url" : "_rtsl_licenseserver_installation_without_pm.html#UUID-9309cb91-08d3-fde6-39f2-4317ba0b2561_section-idm234676479776826", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ パッケージマネージャーを使用しないでライセンスサーバーをインストールする \/ If Cockpit is installed ", 
"snippet" : "のファイルをコピーします CODESYS WBM をシステムに: Debian パッケージを解凍してください codesyswbmbase そして、にあるファイルをコピーしてください \/usr\/share\/cockpit\/codesys_wbm システム上の同じパスにある同じ名前のディレクトリに。 Debian パッケージを解凍してください codesyswbmlicensing そして、にあるファイルをコピーしてください \/usr\/share\/cockpit\/codesys_wbm\/codesys_licensing システム上の同じパスにある同じ名前のディレクトリに。 コックピットの再起動...", 
"body" : "のファイルをコピーします CODESYS WBM をシステムに: Debian パッケージを解凍してください codesyswbmbase そして、にあるファイルをコピーしてください \/usr\/share\/cockpit\/codesys_wbm システム上の同じパスにある同じ名前のディレクトリに。 Debian パッケージを解凍してください codesyswbmlicensing そして、にあるファイルをコピーしてください \/usr\/share\/cockpit\/codesys_wbm\/codesys_licensing システム上の同じパスにある同じ名前のディレクトリに。 コックピットの再起動: systemctl restart cockpit.socket これで、ブラウザからポート 9090 の Cockpit インターフェイスにアクセスし、以下を使用してライセンスプロセスを実行できるようになります。 CODESYS WBM。 " }, 
{ "title" : "「仮想プレイグラウンド」シナリオ:vPLC + ライセンスサーバー + エッジゲートウェイ ", 
"url" : "_rtsl_scenario_virtual_playground.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ 「仮想プレイグラウンド」シナリオ:vPLC + ライセンスサーバー + エッジゲートウェイ ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "必要条件 ", 
"url" : "_rtsl_scenario_virtual_playground.html#UUID-135a713b-cb33-fd0c-80cc-22d356b14153_section-idm43465397081398", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ 「仮想プレイグラウンド」シナリオ:vPLC + ライセンスサーバー + エッジゲートウェイ \/ 必要条件 ", 
"snippet" : "ハードウェア 次のデバイスも必要です。 デスクトップ PC と CODESYS インストール済み Linux PC (Docker または Podman、Python3、および SSH アクセスがインストールされている)。ここでは「Linux ホスト PC」と呼びます。 次のアドオン製品をデスクトップ PC にインストールする必要があります ( CODESYS インストール済み): CODESYS Virtual Edge Gateway for Linux 。 CODESYS Virtual Control for Linux SL CODESYS License Server for Li...", 
"body" : "ハードウェア 次のデバイスも必要です。 デスクトップ PC と CODESYS インストール済み Linux PC (Docker または Podman、Python3、および SSH アクセスがインストールされている)。ここでは「Linux ホスト PC」と呼びます。 次のアドオン製品をデスクトップ PC にインストールする必要があります ( CODESYS インストール済み): CODESYS Virtual Edge Gateway for Linux 。 CODESYS Virtual Control for Linux SL CODESYS License Server for Linux SL " }, 
{ "title" : "リナックスホスト PC ", 
"url" : "_rtsl_scenario_virtual_playground.html#UUID-135a713b-cb33-fd0c-80cc-22d356b14153_section-idm43465397111438", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ 「仮想プレイグラウンド」シナリオ:vPLC + ライセンスサーバー + エッジゲートウェイ \/ リナックスホスト PC ", 
"snippet" : "コマンドを実行する [ツール] → コントロール SL をデプロイ そして Linux ホスト PC への接続を確立します ( コミュニケーション タブ)。 詳細については、以下を参照してください。 接続を確立する次のパッケージ\/イメージの最新バージョンをインストールします ( デプロイ タブ): CODESYS Virtual Edge Gateway for Linux CODESYS Virtual Control for Linux SL CODESYS License Server for Linux SL 詳細については、以下を参照してください。 Installing an ima...", 
"body" : "コマンドを実行する [ツール] → コントロール SL をデプロイ そして Linux ホスト PC への接続を確立します ( コミュニケーション タブ)。 詳細については、以下を参照してください。 接続を確立する次のパッケージ\/イメージの最新バージョンをインストールします ( デプロイ タブ): CODESYS Virtual Edge Gateway for Linux CODESYS Virtual Control for Linux SL CODESYS License Server for Linux SL 詳細については、以下を参照してください。 Installing an imageライセンスサーバーは、別のホストシステム (要件:Linux オペレーティングシステム) にインストールして実行することもできます。Linux ホスト PC からライセンスサーバーへの通信は TCP\/IP プロトコルを介して行われます 必要なインスタンスを作成して設定します。 Linux ホスト PC には、ゲートウェイと PLC のインスタンスが必要です。 オペレーション タブで、以下のようにインスタンスを作成します。 ゲートウェイのインスタンスのインストール で VPLC セクションで、をクリックします。 ボタン。 ザ・ 新しいインスタンスを追加 ダイアログが開きます。 で [名前] フィールドに、名前を指定します (例: vGateway )。 で [フィルタ] リストボックスで、 ゲートウェイ 値。 Linuxイメージ用CODESYSバーチャルエッジゲートウェイの最新バージョンを選択してください。 次にクリック OK 。 新しいインスタンスは、に一覧表示されます。 VPLC セクション。 vPLC のインスタンスのインストール で VPLC セクションで、をクリックします。 ボタン。 ザ・ 新しいインスタンスを追加 ダイアログが開きます。 で [名前] フィールドに、名前を指定します (例: vPLC1 )。 で [フィルタ] リストボックスで、 ランタイム 値。 の最新バージョンを選択してください CODESYS Virtual Control for Linux SL 画像。 次にクリック OK 。 新しいインスタンスは、に一覧表示されます。 VPLC セクション。 アンダー ライセンスサーバー で、ライセンスサーバーの IP アドレスを指定します。この例では、これは Linux ホスト PC の IP アドレスです。 クリック [保存] 変更を確定するため。 設定は Linux ホスト PC に適用されます。 オプション:追加の vPLC インスタンスでこれらの手順を繰り返します。 詳しい情報については、「インスタンスの作成」を参照してください。 仮想インスタンスを起動します。 で VPLC セクションで、をクリックします。 すべて開始 ボタンをクリックしてすべてのインスタンスを起動します。 で 状態 列では、すべての仮想インスタンスのステータスがに変わります。 実行中 。 これからは、実行中の仮想 PLC インスタンスに、通常の PLC と同じようにアクセスしてプログラムできます。 CODESYS 。接続は、設定されている「VGateway」を介して確立されます 有効なライセンスがないと、PLC はデモモード (実行時間 2 時間) で実行されます。 " }, 
{ "title" : "ライセンスをインストールする ", 
"url" : "_rtsl_scenario_virtual_playground.html#UUID-135a713b-cb33-fd0c-80cc-22d356b14153_section-idm234664177345706", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ 「仮想プレイグラウンド」シナリオ:vPLC + ライセンスサーバー + エッジゲートウェイ \/ リナックスホスト PC \/ ライセンスをインストールする ", 
"snippet" : "PLCを操作するためのライセンスは、以下から入手できます。 CODESYS Store International そして、ライセンスサーバーにインストールされます。 詳細については、以下を参照してください。 ネットワークライセンスの有効化...", 
"body" : "PLCを操作するためのライセンスは、以下から入手できます。 CODESYS Store International そして、ライセンスサーバーにインストールされます。 詳細については、以下を参照してください。 ネットワークライセンスの有効化" }, 
{ "title" : "シナリオ：VLAN による仮想制御 ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ シナリオ：VLAN による仮想制御 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "必要条件 ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm43465397081398", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ シナリオ：VLAN による仮想制御 \/ 必要条件 ", 
"snippet" : "シナリオ のセットアップが成功しました 「仮想プレイグラウンド」シナリオ:vPLC + ライセンスサーバー + エッジゲートウェイ少なくとも 2 つのインスタンス CODESYS Virtual Control for Linux SL (この例では、 vPLC1 と vPLC2 ) ハードウェア VLAN 対応のスイッチ Profinet などのフィールドバスデバイス (イーサネットベース)...", 
"body" : "シナリオ のセットアップが成功しました 「仮想プレイグラウンド」シナリオ:vPLC + ライセンスサーバー + エッジゲートウェイ少なくとも 2 つのインスタンス CODESYS Virtual Control for Linux SL (この例では、 vPLC1 と vPLC2 ) ハードウェア VLAN 対応のスイッチ Profinet などのフィールドバスデバイス (イーサネットベース) " }, 
{ "title" : "スイッチの設定 ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm43465397111438", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ シナリオ：VLAN による仮想制御 \/ スイッチの設定 ", 
"snippet" : "デバイスを正しく構成しないと、デバイスにアクセスできなくなる可能性があります。 アダプター（VLAN を定義する必要がある場所）をスイッチに接続します。この例では、2 つの VLAN インターフェースが次のアダプターに追加されています enp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000     link\/ether f0:b2:b9:11:b8:b3 brd ff:ff:ff:ff:ff:ff     inet 192.168.2.2\/24 brd 192.16...", 
"body" : "デバイスを正しく構成しないと、デバイスにアクセスできなくなる可能性があります。 アダプター（VLAN を定義する必要がある場所）をスイッチに接続します。この例では、2 つの VLAN インターフェースが次のアダプターに追加されています enp1s0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000\n    link\/ether f0:b2:b9:11:b8:b3 brd ff:ff:ff:ff:ff:ff\n    inet 192.168.2.2\/24 brd 192.168.2.255 scope global noprefixroute enp1s0\n       valid_lft forever preferred_lft forever\n    inet6 fe80::2e96:178c:586a:b97b\/64 scope link noprefixroute\n       valid_lft forever preferred_lft forever スイッチの設定インターフェイスを開きます。インターフェイスと認証情報を開く方法については、ベンダーの指示を参照してください。 ログインしたら、VLAN の設定ページを開きます。スイッチが別のプロトコルをサポートしている場合は、以下を選択してください 802.1Q VLAN 。 で Port Config ページで、を設定します。 Link Type 以前に接続したポートの Trunk 。 すべてのフィールドバスデバイスをスイッチに接続します。 で VLAN Config ページで、2 つの新しい VLAN を追加します。この例では、VLAN ID 100 と 200 を使用して作業しています。以前に接続したポートを追加し、次のように設定します。 Trunk 各 VLAN に。フィールドバスデバイスのポートを各 VLAN に追加します 次の設定例では、コントローラからスイッチへの接続がポート 14 で確立されています。 Link Type このポートは、次のように設定されています。 Trunk 。フィールドバスデバイスはポート 11 とポート 12 にそれぞれ接続されています VLAN ID [説明] ポート 100 VLAN 100 11, 14 200 VLAN 200 12, 14 " }, 
{ "title" : "VLAN インターフェースの設定 ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm234821994565272", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ シナリオ：VLAN による仮想制御 \/ VLAN インターフェースの設定 ", 
"snippet" : "ネットワーク構成に恒久的な変更を加える前に、設定をテストし、必要に応じて変更する必要があります。 タイプの新しいアダプタを作成 VLAN 。 コマンドの形式は次のとおりです。 sudo ip link add link <physical_adapter> name <virtual_adapter_name> type vlan id <vlan_id> 慣習では、仮想アダプタの名前に VLAN ID を追加します。上記のアダプタとスイッチの設定の場合、コマンドは次のようになります sudo ip link add link enp1s0 name enp1s0.100 type vlan ...", 
"body" : "ネットワーク構成に恒久的な変更を加える前に、設定をテストし、必要に応じて変更する必要があります。 タイプの新しいアダプタを作成 VLAN 。 コマンドの形式は次のとおりです。 sudo ip link add link <physical_adapter> name <virtual_adapter_name> type vlan id <vlan_id> 慣習では、仮想アダプタの名前に VLAN ID を追加します。上記のアダプタとスイッチの設定の場合、コマンドは次のようになります sudo ip link add link enp1s0 name enp1s0.100 type vlan id 100 置換 enp1s0 そして VLAN ID とシステム上の値を指定します。 今、あなたが走るとき ip a 、次のような出力が表示されるはずです。 enp1s0.100@enp1s0: <BROADCAST,MULTICAST,PROMISC> mtu 1500 qdisc noop state DOWN group default qlen 1000 このコマンドは 2 番目の VLAN に対しても実行します。 " }, 
{ "title" : "構成をテストする ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm234822002492998", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ シナリオ：VLAN による仮想制御 \/ 構成をテストする ", 
"snippet" : "を開きます CODESYS Control SL Deploy Tool そして、コントローラとの接続を確立します。 詳細については、以下を参照してください。 接続を確立する。 に切り替え オペレーション タブをクリックして選択します。 vPLC1 インスタンス。 右側の構成ビューで、をクリックします Nic と入力し、右端の [...] をクリックします。 ボタン。 Nic 設定ダイアログが開きます。 使用可能なアダプタのリストで、をクリックします。 enp1s0.100 そして選択してください [インスタンスにマッピング] オプション。 必要に応じて、IP アドレスとネットワークマスクを設...", 
"body" : "を開きます CODESYS Control SL Deploy Tool そして、コントローラとの接続を確立します。 詳細については、以下を参照してください。 接続を確立する。 に切り替え オペレーション タブをクリックして選択します。 vPLC1 インスタンス。 右側の構成ビューで、をクリックします Nic と入力し、右端の [...] をクリックします。 ボタン。 Nic 設定ダイアログが開きます。 使用可能なアダプタのリストで、をクリックします。 enp1s0.100 そして選択してください [インスタンスにマッピング] オプション。 必要に応じて、IP アドレスとネットワークマスクを設定します。ネットワークマスクは CIDR 表記の形式です (例 24 )。 詳細については、以下を参照してください。 https:\/\/en.wikipedia.org\/wiki\/Classless_Inter-Domain_Routing をクリックします OK そして [保存] ボタン。 選択してください vPLC2 インスタンスを作成し、ステップ 3 ～ 6 を実行します。 enp1s0.200 アダプター。 コントローラーのインスタンスとゲートウェイを起動します。 詳細については、以下を参照してください。 ランタイム システムの起動2 つのインスタンスのそれぞれに小さなアプリケーションをロードして、ネットワークの機能を確認します。詳細については、以下を参照してください。 のダウンロードと起動 " }, 
{ "title" : "アダプターの構成を永続化する ", 
"url" : "_rtsl_scenario_virtual_control_vlan.html#UUID-561f3966-6d44-ab84-c71a-f25748fda637_section-idm234821994914623", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ シナリオ：VLAN による仮想制御 \/ アダプターの構成を永続化する ", 
"snippet" : "設定が正しい場合でも、永続的に保存する必要があります。スイッチの設定を永続的に保存する方法については、ベンダーの指示を参照してください。2 つのインスタンスの設定 vPLC1 と vPLC2 すでに永続化されています。ここでは、以下を設定するだけで済みます オートスタート に設定 はい 。 次の手順では、コントローラの 2 つの VLAN アダプタを設定して、システムの起動時に使用できるようにする方法について説明します。 これらの設定は、システムに害を及ぼす可能性があります。 すべての重要なファイルのバックアップを作成します。 変更を簡単に元に戻すことができるように、事前に変更されたすべてのフ...", 
"body" : "設定が正しい場合でも、永続的に保存する必要があります。スイッチの設定を永続的に保存する方法については、ベンダーの指示を参照してください。2 つのインスタンスの設定 vPLC1 と vPLC2 すでに永続化されています。ここでは、以下を設定するだけで済みます オートスタート に設定 はい 。 次の手順では、コントローラの 2 つの VLAN アダプタを設定して、システムの起動時に使用できるようにする方法について説明します。 これらの設定は、システムに害を及ぼす可能性があります。 すべての重要なファイルのバックアップを作成します。 変更を簡単に元に戻すことができるように、事前に変更されたすべてのファイルのコピーを作成してください。 [開く] \/etc\/network\/interfaces エディターで (例: sudo nano \/etc\/network\/interfaces )。 次の行を追加します (コントローラのアダプタ名と VLAN ID を変更してください)。 # enp1s0.100 vlan (vPLC1)\nauto enp1s0.100\niface enp1s0.100 inet dhcp\n    vlan-raw-device enp1s0\n# enp1s0.200 vlan (vPLC2)\nauto enp1s0.200\niface enp1s0.200 inet dhcp\n    vlan-raw-device enp1s0 このファイルの詳細については、以下を参照してください。 https:\/\/wiki.debian.org\/NetworkConfiguration システムを再起動するか、コマンドを実行してください sudo systemctl restart networking 変更を適用するためのものです。 この設定方法は Debian 12 でテストされました。設定を永続的に保存するには、お使いのデバイスやオペレーティングシステムに合わせて別の方法を選択する必要があるかもしれません その他の例はネットプランです ( https:\/\/netplan.readthedocs.io\/en\/stable\/structure-id\/ ) またはネットワークマネージャ ( https:\/\/networkmanager.dev\/ )。コントローラーの適切な説明は、それぞれのマニュアルに記載されています。 " }, 
{ "title" : "「フィールドバスによる仮想」シナリオ:vPLC + ライセンスサーバ + エッジゲートウェイ + フィールドバス ", 
"url" : "_rtsl_scenario_virtual_fieldbus.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ 「フィールドバスによる仮想」シナリオ:vPLC + ライセンスサーバ + エッジゲートウェイ + フィールドバス ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "必要条件 ", 
"url" : "_rtsl_scenario_virtual_fieldbus.html#UUID-8d90cd73-67b3-e75d-2d43-8f604bccd457_section-idm43465397081398", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ 「フィールドバスによる仮想」シナリオ:vPLC + ライセンスサーバ + エッジゲートウェイ + フィールドバス \/ 必要条件 ", 
"snippet" : "シナリオ のセットアップが成功しました 「仮想プレイグラウンド」シナリオ:vPLC + ライセンスサーバー + エッジゲートウェイハードウェア 次のデバイスも必要です。 Profinetなどのフィールドバスデバイス（イーサネットベース）。...", 
"body" : "シナリオ のセットアップが成功しました 「仮想プレイグラウンド」シナリオ:vPLC + ライセンスサーバー + エッジゲートウェイハードウェア 次のデバイスも必要です。 Profinetなどのフィールドバスデバイス（イーサネットベース）。 " }, 
{ "title" : "フィールドバスの設定 ", 
"url" : "_rtsl_scenario_virtual_fieldbus.html#UUID-8d90cd73-67b3-e75d-2d43-8f604bccd457_section-idm43465397111438", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ 「フィールドバスによる仮想」シナリオ:vPLC + ライセンスサーバ + エッジゲートウェイ + フィールドバス \/ フィールドバスの設定 ", 
"snippet" : "フィールドバス接続用のイーサネットアダプタは、次のように仮想 PLC インスタンスに割り当てられます。 で VPLC セクションで、目的の vPLC インスタンスを選択してをクリックします。 [選択を停止] 。 PLC の状態が「停止」に変わります。対応する設定が下に表示されます [設定] 。 アンダー ニック で、フィールドバス接続に使用する Linux ホスト PC のネットワークアダプタを選択します。必要に応じて IP アドレスとネットワークマスクを割り当てます クリック [保存] 変更を確定するため。 設定は Linux ホスト PC に適用されます。 クリック [選択を開始] vPL...", 
"body" : "フィールドバス接続用のイーサネットアダプタは、次のように仮想 PLC インスタンスに割り当てられます。 で VPLC セクションで、目的の vPLC インスタンスを選択してをクリックします。 [選択を停止] 。 PLC の状態が「停止」に変わります。対応する設定が下に表示されます [設定] 。 アンダー ニック で、フィールドバス接続に使用する Linux ホスト PC のネットワークアダプタを選択します。必要に応じて IP アドレスとネットワークマスクを割り当てます クリック [保存] 変更を確定するため。 設定は Linux ホスト PC に適用されます。 クリック [選択を開始] vPLC インスタンスを起動します。 PLC の状態が「実行中」に変わります。 これで、ネットワークアダプタは設定済みの vPLC にのみ割り当てられ、Linux ホスト PC では使用できなくなります。これで、フィールドバスを次の方法で通常どおり設定して使用できるようになりました CODESYS 。 " }, 
{ "title" : "「セーフハウス」シナリオ:vPLC + vSafe + ProfiSafe + タイムプロバイダー + ライセンスサーバー ", 
"url" : "_rtsl_scenario_safe_house.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ 「セーフハウス」シナリオ:vPLC + vSafe + ProfiSafe + タイムプロバイダー + ライセンスサーバー ", 
"snippet" : "次のページのドキュメントは、情報提供のみを目的としています。制限事項および安全性または認証情報については、プログラミングするデバイスの製造元の安全に関する文書を参照してください...", 
"body" : "次のページのドキュメントは、情報提供のみを目的としています。制限事項および安全性または認証情報については、プログラミングするデバイスの製造元の安全に関する文書を参照してください " }, 
{ "title" : "必要条件 ", 
"url" : "_rtsl_scenario_safe_house.html#UUID-8c70494a-5eac-cd26-0994-8e503c1ca9ab_section-idm234653932399925", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ 「セーフハウス」シナリオ:vPLC + vSafe + ProfiSafe + タイムプロバイダー + ライセンスサーバー \/ 必要条件 ", 
"snippet" : "シナリオ: このシナリオの要件は、を正常にセットアップすることです。 「フィールドバスによる仮想」シナリオ:vPLC + ライセンスサーバ + エッジゲートウェイ + フィールドバス. ハードウェア 次のデバイスも必要です。 デスクトップ PC と CODESYS Development System インストール済み 仮想エッジゲートウェイ、仮想 PLC 1、ライセンスサーバーがインストールされている Linux ホスト PC 次の追加デバイスも必要です。 タイムプロバイダーのホスト。図では Linux Host PC 2 という名前です。このホストの要件:Linux オペレーティングシステ...", 
"body" : "シナリオ: このシナリオの要件は、を正常にセットアップすることです。 「フィールドバスによる仮想」シナリオ:vPLC + ライセンスサーバ + エッジゲートウェイ + フィールドバス. ハードウェア 次のデバイスも必要です。 デスクトップ PC と CODESYS Development System インストール済み 仮想エッジゲートウェイ、仮想 PLC 1、ライセンスサーバーがインストールされている Linux ホスト PC 次の追加デバイスも必要です。 タイムプロバイダーのホスト。図では Linux Host PC 2 という名前です。このホストの要件:Linux オペレーティングシステムと Docker をインストールし、SSH を設定する必要があります Real-time capable network to the Linux Host PC to ensure deterministic transmission of data packages. アドオン製品 CODESYS バーチャルセーフコントロール SL はデスクトップ PC にインストールする必要があります。 " }, 
{ "title" : "リナックスホスト PC 2 ", 
"url" : "_rtsl_scenario_safe_house.html#UUID-8c70494a-5eac-cd26-0994-8e503c1ca9ab_section-idm2346539369198", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ 「セーフハウス」シナリオ:vPLC + vSafe + ProfiSafe + タイムプロバイダー + ライセンスサーバー \/ リナックスホスト PC 2 ", 
"snippet" : "Linux ホスト PC 2 で、タイムプロバイダーを設定します。 タイムプロバイダーは、設定された宛先に現在の時刻を送信し、バーチャルセーフコントロールSLが必要とする2回目の時刻を提供するために使用できます。 コマンドを実行する [ツール] → コントロール SL をデプロイ そして、Linux ホスト PC 2 への接続を確立します ( コミュニケーション タブ)。 詳細については、以下を参照してください。 接続を確立する次のイメージの最新バージョンをインストールします ( デプロイ タブ): CODESYS バーチャルセーフタイムプロバイダー 詳細については、以下を参照してください。 ...", 
"body" : "Linux ホスト PC 2 で、タイムプロバイダーを設定します。 タイムプロバイダーは、設定された宛先に現在の時刻を送信し、バーチャルセーフコントロールSLが必要とする2回目の時刻を提供するために使用できます。 コマンドを実行する [ツール] → コントロール SL をデプロイ そして、Linux ホスト PC 2 への接続を確立します ( コミュニケーション タブ)。 詳細については、以下を参照してください。 接続を確立する次のイメージの最新バージョンをインストールします ( デプロイ タブ): CODESYS バーチャルセーフタイムプロバイダー 詳細については、以下を参照してください。 Installing an imageをクリックします デプロイ タブ。 で 製品 リストボックス、選択 CODESYS バーチャルセーフタイムプロバイダー SL 。 で バージョン リストボックスで、最新バージョンを選択します。 をクリックします インストール ボタン。 CODESYS バーチャルセーフタイムプロバイダー SL イメージがに表示されます インストール済みイメージ セクション。 必要なインスタンスを作成します。 Linux ホスト PC 2 では、タイムプロバイダーインスタンスが必要です。このインスタンスは、で次のように作成します。 操作 タブ: で VPLC セクションで、をクリックします。 ボタン。 ザ・ 新しいインスタンスを追加 ダイアログが開きます。 指定 timeprovider 名前として。 で [フィルタ] リストボックス、選択 Safety Timeprovider 。 の最新バージョンを選択してください CODESYS Virtual Safe Timeprovider SL イメージを作成してクリック OK 。 新しいインスタンスは、に一覧表示されます。 VPLC セクション。 インスタンスを設定します。 ターゲット IP アドレスとターゲットポートは、次のように設定する必要があります。 timeprovider インスタンス。ターゲットは vHost とポート 60000 デフォルトです。 汎用コマンド: -e ターゲット_IP= [Linux ホスト PC の IP アドレスまたはホスト名] -e ターゲットポート = 60000 60000は、バーチャルセーフコントロールSLがタイマーから外部タイムソースを受信するためのデフォルトポートです。 自動起動 はい いつ はい が選択されると、システムが起動するたびにインスタンスが自動的に起動します。 で VPLC セクションで、をクリックします。 timeprovider インスタンス。 の設定は timeprovider インスタンスが右側に表示されます。 TARGET_IP と TARGET_PORT ジェネリックコマンドではすでに次の値があらかじめ割り当てられています vSafePLC1 そして 60000 。 を変更 TARGET_IP Linux ホスト PC 1 のホスト名または IP アドレスに送信します。 詳細については、以下を参照してください。 ネットワークアドレスの検出で オートスタート リストボックス、値を次のように変更 はい 。 をクリックします [保存] ボタンをクリックして変更を保存します。 詳細については、以下を参照してください。 新しいインスタンスの作成と設定インスタンスを起動します。 を起動します timeprovider でインスタンスを選択して VPLC セクションを開いてから、をクリックします。 [選択を開始] ボタン。 で 状態 列では、すべてのインスタンスのステータスがに変わります 実行中 。 " }, 
{ "title" : "リナックスホスト PC ", 
"url" : "_rtsl_scenario_safe_house.html#UUID-8c70494a-5eac-cd26-0994-8e503c1ca9ab_section-idm234653987267355", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ 「セーフハウス」シナリオ:vPLC + vSafe + ProfiSafe + タイムプロバイダー + ライセンスサーバー \/ リナックスホスト PC ", 
"snippet" : "Linux ホスト PC で、をセットアップします。 CODESYS Virtual Safe Control for Linux SL . コマンドを実行する [ツール] → コントロール SL をデプロイ そして、Linux ホスト PC 2 への接続を確立します ( コミュニケーション タブ)。 に切り替え オペレーション タブ。 次のイメージの最新バージョンをインストールします ( デプロイ タブ): CODESYS バーチャルセーフコントロール SL 必要なインスタンスを作成します。 Linux ホスト PC 1 では、vSafePLC インスタンスが必要です。このインスタンスは、で...", 
"body" : "Linux ホスト PC で、をセットアップします。 CODESYS Virtual Safe Control for Linux SL . コマンドを実行する [ツール] → コントロール SL をデプロイ そして、Linux ホスト PC 2 への接続を確立します ( コミュニケーション タブ)。 に切り替え オペレーション タブ。 次のイメージの最新バージョンをインストールします ( デプロイ タブ): CODESYS バーチャルセーフコントロール SL 必要なインスタンスを作成します。 Linux ホスト PC 1 では、vSafePLC インスタンスが必要です。このインスタンスは、で次のように作成します。 オペレーション タブ: で VPLC セクションで、をクリックします。 ボタン。 ザ・ 新しいインスタンスを追加 ダイアログが開きます。 指定 vSafePLC 名前と同じように。 で [フィルタ] リストボックス、選択 セーフティ・ランタイム・システム 。 次に、の最新バージョンを選択します CODESYS Virtual Safe Control for Linux SL 画像。 次にクリック OK 。 新しいインスタンスは、に一覧表示されます。 VPLC セクション。 前のシナリオでこのデバイスで作成したインスタンスと合わせて、次のインスタンスが利用可能になるはずです VPLCs セクション: インスタンス 状態 [製品] Vゲートウェイ 停止しました ゲートウェイ vPLC 停止しました ランタイムシステム vSafe PLC 停止しました セーフティ・ランタイム・システム に次のエントリがあるかどうかを確認してください Services セクション: [製品] 状態 Linux SL 用コーデシスライセンスサーバー 実行中 再設定する前に、をクリックしてください [すべて停止] ボタンをクリックしてインスタンスを停止します。 すべてのインスタンスの状態が次のように変わります [停止] 。 で VPLC セクションで、をクリックします。 vSafePLC インスタンス。 の設定は vSafePLC インスタンスは右側に表示されます。 を設定します vSafePLC 次のようなインスタンス: ポート: 60000:60000 \/udp これは、Virtual Safe Control SLがタイムプロバイダーから外部タイムソースを受信するためのデフォルトポートです。 写真: コンテナ:液体クロマトグラフィー vPLC インスタンスの IPC 名前空間にアクセスして、これら 2 つのインスタンス間の通信を行います。 依存関係: vPLC vPLC を最初に起動する必要があります。これにより、このインスタンスが参加したい IPC 名前空間が作成されるためです。依存関係があると、正しい起動順序が保証されます で VPLC セクションで、をクリックします。 vPLC インスタンス。 vSafePLC インスタンスの設定が右側に表示されます。 を設定します vPLC 次のインスタンス: IPC: 共有可能 このコンテナ用に、他のコンテナで使用できる IPC 名前空間を作成します。この場合、vSafePLC インスタンスはこの 2 つのインスタンス間の通信に参加する必要があります インスタンスを起動します。 で VPLC セクションで、をクリックします。 すべて開始 ボタンをクリックしてすべてのインスタンスを起動します。 で 状態 列では、すべてのインスタンスのステータスがに変わります 実行中 。 構成を確認してください。 タイムプロバイダーの時刻が希望どおりに設定されたとおりに vSafePLC に到達していることを確認するには、インスタンスのログでこれを確認できます。 これを行うには、 vSafePLCs のインスタンス VPLC セクション。 で アクション 右上のセクションをクリックして [ログを表示] ボタン。 ザ・ ランタイムシステムログ ウィンドウが開きます。 メッセージ External Time Provider found ログに存在する。 これで、必要なすべてのデバイスの準備が整いました。プロジェクトを作成し、ProfiSafe を統合するための次のステップについては、以下で説明しています CODESYS セーフティエクステンション ドキュメンテーション。 " }, 
{ "title" : "シナリオ: 「仮想冗長性」: vPLC + vPLC + ライセンスサーバー + エッジゲートウェイを 1 つのシステムに ", 
"url" : "_rtsl_scenario_virtual_redundancy.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ シナリオ: 「仮想冗長性」: vPLC + vPLC + ライセンスサーバー + エッジゲートウェイを 1 つのシステムに ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "必要条件 ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm43465397081398", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ シナリオ: 「仮想冗長性」: vPLC + vPLC + ライセンスサーバー + エッジゲートウェイを 1 つのシステムに \/ 必要条件 ", 
"snippet" : "シナリオ セットアップに成功しました 「仮想プレイグラウンド」シナリオ:vPLC + ライセンスサーバー + エッジゲートウェイ少なくとも 2 つの vPLC を使用するシナリオ。...", 
"body" : "シナリオ セットアップに成功しました 「仮想プレイグラウンド」シナリオ:vPLC + ライセンスサーバー + エッジゲートウェイ少なくとも 2 つの vPLC を使用するシナリオ。 " }, 
{ "title" : "コンテナ ネットワークの構成: ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm43465397111438", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ シナリオ: 「仮想冗長性」: vPLC + vPLC + ライセンスサーバー + エッジゲートウェイを 1 つのシステムに \/ コンテナ ネットワークの構成: ", 
"snippet" : "冗長性の機能を確保するには、使用するコントローラーに静的IPアドレスを割り当てる必要があります。IPアドレスが変更されると、デバイスへの接続を自動的に再確立できなくなります。 ネットワークは、使用するコンテナエンジンを介して直接設定する必要があります。これを行うには、SSH経由でLinuxホストPCに接続します。 ターミナルで、以下のコマンドを入力します（IP アドレス、サブネット、ネットワーク名は自由に選択できます）。 docker network create --subnet=192.168.5.0\/24 mynetwork...", 
"body" : "冗長性の機能を確保するには、使用するコントローラーに静的IPアドレスを割り当てる必要があります。IPアドレスが変更されると、デバイスへの接続を自動的に再確立できなくなります。 ネットワークは、使用するコンテナエンジンを介して直接設定する必要があります。これを行うには、SSH経由でLinuxホストPCに接続します。 ターミナルで、以下のコマンドを入力します（IP アドレス、サブネット、ネットワーク名は自由に選択できます）。 docker network create --subnet=192.168.5.0\/24 mynetwork " }, 
{ "title" : "インスタンスの構成 ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm23496702624416", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ シナリオ: 「仮想冗長性」: vPLC + vPLC + ライセンスサーバー + エッジゲートウェイを 1 つのシステムに \/ インスタンスの構成 ", 
"snippet" : "ここで、vPLC インスタンスに個別の IP アドレスを指定し、ネットワークを割り当てる必要があります。 仮想PLC 1: 汎用コマンド --ip 192.168.5.1 インスタンスの静的IPアドレス。汎用コマンド --ip インスタンスが対応するサブネットを持つコンテナ ネットワーク内にある場合にのみ許可されます。 ネットワーク mynetwork 構成されたインスタンスのコンテナネットワーク 仮想PLC 2: 汎用コマンド: --ip 192.168.5。 2 インスタンスの静的IPアドレス。汎用コマンド --ip インスタンスが対応するサブネットを持つコンテナ ネットワーク内にある場合...", 
"body" : "ここで、vPLC インスタンスに個別の IP アドレスを指定し、ネットワークを割り当てる必要があります。 仮想PLC 1: 汎用コマンド --ip 192.168.5.1 インスタンスの静的IPアドレス。汎用コマンド --ip インスタンスが対応するサブネットを持つコンテナ ネットワーク内にある場合にのみ許可されます。 ネットワーク mynetwork 構成されたインスタンスのコンテナネットワーク 仮想PLC 2: 汎用コマンド: --ip 192.168.5。 2 インスタンスの静的IPアドレス。汎用コマンド --ip インスタンスが対応するサブネットを持つコンテナ ネットワーク内にある場合にのみ許可されます。 ネットワーク： mynetwork 構成されたインスタンスのコンテナネットワーク その後、仮想 Edge ゲートウェイもネットワークに追加する必要があります。 仮想エッジゲートウェイ: ネットワーク mynetwork 構成されたインスタンスのコンテナネットワーク " }, 
{ "title" : "仮想インスタンスの起動 ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm234967029997363", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ シナリオ: 「仮想冗長性」: vPLC + vPLC + ライセンスサーバー + エッジゲートウェイを 1 つのシステムに \/ 仮想インスタンスの起動 ", 
"snippet" : "の中で vPLC セクションで、 すべて開始 ボタンをクリックします。設定された仮想インスタンスのステータスが Running 。 冗長機能については、以下の手順に従ってください。 はじめに – 冗長システムの構成...", 
"body" : "の中で vPLC セクションで、 すべて開始 ボタンをクリックします。設定された仮想インスタンスのステータスが Running 。 冗長機能については、以下の手順に従ってください。 はじめに – 冗長システムの構成 " }, 
{ "title" : "シナリオ：「仮想冗長性」: 2つのシステム上のvPLC + vPLC + ライセンスサーバー + エッジゲートウェイ ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm234968298823991", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ シナリオ: 「仮想冗長性」: vPLC + vPLC + ライセンスサーバー + エッジゲートウェイを 1 つのシステムに \/ シナリオ：「仮想冗長性」: 2つのシステム上のvPLC + vPLC + ライセンスサーバー + エッジゲートウェイ ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "要件 ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm43496829968904", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ シナリオ: 「仮想冗長性」: vPLC + vPLC + ライセンスサーバー + エッジゲートウェイを 1 つのシステムに \/ シナリオ：「仮想冗長性」: 2つのシステム上のvPLC + vPLC + ライセンスサーバー + エッジゲートウェイ \/ 要件 ", 
"snippet" : "シナリオ のセットアップが成功しました シナリオ: 「仮想冗長性」: vPLC + vPLC + ライセンスサーバー + エッジゲートウェイを 1 つのシステムに シナリオ。 ハードウェア 以下のデバイスも必要です。 追加のvPLC用のホスト（図ではLinuxホストPC 2）です。このホストの要件 Linux オペレーティング システムと Docker をインストールし、SSH を構成する必要があります。 Linux ホスト PC へのリアルタイム対応ネットワークにより、時間に敏感なデータ パッケージの確定的な伝送を保証します。 両システムのインスタンスの追加構成。詳細については、以下を参照し...", 
"body" : "シナリオ のセットアップが成功しました シナリオ: 「仮想冗長性」: vPLC + vPLC + ライセンスサーバー + エッジゲートウェイを 1 つのシステムに シナリオ。 ハードウェア 以下のデバイスも必要です。 追加のvPLC用のホスト（図ではLinuxホストPC 2）です。このホストの要件 Linux オペレーティング システムと Docker をインストールし、SSH を構成する必要があります。 Linux ホスト PC へのリアルタイム対応ネットワークにより、時間に敏感なデータ パッケージの確定的な伝送を保証します。 両システムのインスタンスの追加構成。詳細については、以下を参照してください。 インスタンスの構成それぞれのホスト上の 2 つのインスタンスに対して以下を構成する必要があります。 ポート 1205:1205 これは冗長通信のデフォルトポートです。プロジェクトの冗長設定インターフェースでこのポートを変更することもできます。ただし、変更は対応するインスタンスの設定にも反映される必要があることに注意してください。 " }, 
{ "title" : "仮想インスタンスの起動 ", 
"url" : "_rtsl_scenario_virtual_redundancy.html#UUID-230fab4f-78cf-1223-12ae-6097369caf45_section-idm43496830001058", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ シナリオ: 「仮想冗長性」: vPLC + vPLC + ライセンスサーバー + エッジゲートウェイを 1 つのシステムに \/ シナリオ：「仮想冗長性」: 2つのシステム上のvPLC + vPLC + ライセンスサーバー + エッジゲートウェイ \/ 要件 \/ 仮想インスタンスの起動 ", 
"snippet" : "の中で vPLC セクションで、 すべて開始 ボタンをクリックします。設定された仮想インスタンスのステータスが Running 。 冗長機能については、以下の手順に従ってください。 はじめに – 冗長システムの構成...", 
"body" : "の中で vPLC セクションで、 すべて開始 ボタンをクリックします。設定された仮想インスタンスのステータスが Running 。 冗長機能については、以下の手順に従ってください。 はじめに – 冗長システムの構成 " }, 
{ "title" : "CODESYS TargetVisu for Linux SL ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ CODESYS TargetVisu for Linux SL ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "ユースケース ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374412002576", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ CODESYS TargetVisu for Linux SL \/ ユースケース ", 
"snippet" : "CODESYS TargetVisu for Linux SL 視覚化の表示を管理する、独立した小さなランタイム システムです。 CODESYS TargetVisu for Linux SL 以下のユースケースをカバーします。 CODESYS TargetVisu for Linux SL さまざまな方法で設定できます: 別のコントローラに接続するリモートTargetVisuとして コントローラ上で直接動作するローカルターゲット\/ビューとして このユースケースは、リアルタイム要求のあるコントローラーには適していません。 詳細については、以下を参照してください。 パフォーマンス最適化従来のター...", 
"body" : "CODESYS TargetVisu for Linux SL 視覚化の表示を管理する、独立した小さなランタイム システムです。 CODESYS TargetVisu for Linux SL 以下のユースケースをカバーします。 CODESYS TargetVisu for Linux SL さまざまな方法で設定できます: 別のコントローラに接続するリモートTargetVisuとして コントローラ上で直接動作するローカルターゲット\/ビューとして このユースケースは、リアルタイム要求のあるコントローラーには適していません。 詳細については、以下を参照してください。 パフォーマンス最適化従来のターゲット視覚化と比較して、 CODESYS TargetVisu for Linux SL 次のような利点があります。 プロセスは互いに分離されており、視覚化にエラーが発生しても、自動的にマシンが停止することはありません。 視覚化に必要なコンポーネントが少ないため、消費するリソースも少なくなります。 すべてのコミュニケーションは CODESYS 通信プロトコルなので安全です。 " }, 
{ "title" : "要件 ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374412127657", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ CODESYS TargetVisu for Linux SL \/ 要件 ", 
"snippet" : "使用できる CODESYS TargetVisu for Linux SL システムは次の要件を満たしている必要があります。 システムに次のライブラリをインストールする必要があります。 libqt6core6 libqt6gui6 libqt6widgets6 libqt6network6 libqt6svg6 libqt6webenginewidgets6 libqt6webenginecore6 libqt6webenginequick6 libqt6webview6 libqt6webviewquick6 libqt6qmlworkerscript6 libqt6quickshapes6...", 
"body" : "使用できる CODESYS TargetVisu for Linux SL システムは次の要件を満たしている必要があります。 システムに次のライブラリをインストールする必要があります。 libqt6core6 libqt6gui6 libqt6widgets6 libqt6network6 libqt6svg6 libqt6webenginewidgets6 libqt6webenginecore6 libqt6webenginequick6 libqt6webview6 libqt6webviewquick6 libqt6qmlworkerscript6 libqt6quickshapes6 libqt6quickcontrols2-6 libqt6quickcontrols2impl6 libqt6quicktemplates2-6 システムにデスクトップ環境をインストールする必要があります。次に例を示します。 Xfce KDE gnome lxde 物理ディスプレイをターゲット デバイスに接続する必要があります。 X-Forwarding または類似のものとの使用はテストされていません。 Qt バージョン 6.4.2 以上をインストールする必要があります (たとえば、少なくとも Debian 12 または Ubuntu 23.10)。 " }, 
{ "title" : "使用 CODESYS TargetVisu for Linux SL プロジェクトで ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374412333472", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ CODESYS TargetVisu for Linux SL \/ 使用 CODESYS TargetVisu for Linux SL プロジェクトで ", 
"snippet" : "使用するには CODESYS TargetVisu for Linux SL を無効にする必要があります クライアントアニメーションとネイティブ要素のオーバーレイをサポート Visualization Manager のオプション。 デバイス ツリーで、Visualization Manager を選択します。 挿入する リモートターゲットVisu その下のオブジェクト。 デバイス エディターでリモート TargetVisu を開き、そこで必要な開始視覚化を定義します。...", 
"body" : "使用するには CODESYS TargetVisu for Linux SL を無効にする必要があります クライアントアニメーションとネイティブ要素のオーバーレイをサポート Visualization Manager のオプション。 デバイス ツリーで、Visualization Manager を選択します。 挿入する リモートターゲットVisu その下のオブジェクト。 デバイス エディターでリモート TargetVisu を開き、そこで必要な開始視覚化を定義します。 " }, 
{ "title" : "インストール CODESYS TargetVisu for Linux SL 対象デバイス上 ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374412538107", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ CODESYS TargetVisu for Linux SL \/ インストール CODESYS TargetVisu for Linux SL 対象デバイス上 ", 
"snippet" : "をクリックします ツール → コントロール SL をデプロイ メニューコマンド。 ザル デプロイコントロール SL タブが開きます。 コントローラーとの接続を確立します。 詳細については、以下を参照してください。 ターゲットシステムへの接続をクリックします デプロイ タブ。 の中に 製品 リストボックスで、次の項目を選択します。 CODESYS TargetVisu for Linux SL 製品。 の中に バージョン リストボックスで、目的のバージョンを選択します。 をクリックします インストール ボタン。 インストールに使用するアカウント CODESYS TargetVisu for Li...", 
"body" : "をクリックします ツール → コントロール SL をデプロイ メニューコマンド。 ザル デプロイコントロール SL タブが開きます。 コントローラーとの接続を確立します。 詳細については、以下を参照してください。 ターゲットシステムへの接続をクリックします デプロイ タブ。 の中に 製品 リストボックスで、次の項目を選択します。 CODESYS TargetVisu for Linux SL 製品。 の中に バージョン リストボックスで、目的のバージョンを選択します。 をクリックします インストール ボタン。 インストールに使用するアカウント CODESYS TargetVisu for Linux SL デバイスにログインするために使用するアカウントと同じアカウントである必要があります。 CODESYS 必要なライブラリがすべてインストールされており、Qt が少なくとも上記で指定したバージョンで使用可能であることを確認します。ターゲットの視覚化を使用する前に、ターゲット デバイスを 1 回再起動する必要があります。 " }, 
{ "title" : "トラブルシューティング ", 
"url" : "_rtsl_target_visu_for_linux-1816437.html#UUID-cde56a67-38c5-a6ae-5bf7-541769269839_section-idm234374413199442", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ ユースケース \/ CODESYS TargetVisu for Linux SL \/ トラブルシューティング ", 
"snippet" : "前に CODESYS TargetVisu for Linux SL バージョン 4.13.0.0 ローカルログインに失敗する インストール後にログインしたときに黒い画面が表示され、その後ログイン画面が再び表示される場合は、エラーが発生している可能性があります DISPLAY 設定されている環境変数。これを確認するには、次の項目をクリアします。 ログイン時に X Display + User を設定 のターゲットビジュアライゼーションの設定ダイアログにあるオプション CODESYS 。後でターゲットデバイスにログインできたら、次の出力を確認してください echo $DISPLAY 。この値をに...", 
"body" : "前に CODESYS TargetVisu for Linux SL バージョン 4.13.0.0 ローカルログインに失敗する インストール後にログインしたときに黒い画面が表示され、その後ログイン画面が再び表示される場合は、エラーが発生している可能性があります DISPLAY 設定されている環境変数。これを確認するには、次の項目をクリアします。 ログイン時に X Display + User を設定 のターゲットビジュアライゼーションの設定ダイアログにあるオプション CODESYS 。後でターゲットデバイスにログインできたら、次の出力を確認してください echo $DISPLAY 。この値をに入力してください \/etc\/default\/codesysvisualization 値について XDISPLAY そしてやり直してください。 " }, 
{ "title" : "トラブルシューティング ", 
"url" : "_rtsl_troubleshooting.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "プログラミングシステム\/IDE\/ Deploy Tool ", 
"url" : "_rtsl_toubleshooting_deploytool.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ プログラミングシステム\/IDE\/ Deploy Tool ", 
"snippet" : "以下の章では、Linux ベースの SL 製品と CODESYS Development System または Deploy Tool 。ザ・ Deploy Tool Linux ベースの SL 製品を Linux システムにインストールするために使用できるプラグインです。...", 
"body" : "以下の章では、Linux ベースの SL 製品と CODESYS Development System または Deploy Tool 。ザ・ Deploy Tool Linux ベースの SL 製品を Linux システムにインストールするために使用できるプラグインです。 " }, 
{ "title" : "製品のインストールはエラーで終了します。 ", 
"url" : "_rtsl_toubleshooting_deploytool1.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ プログラミングシステム\/IDE\/ Deploy Tool \/ 製品のインストールはエラーで終了します。 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "必要条件 ", 
"url" : "_rtsl_toubleshooting_deploytool1.html#UUID-11b462c5-1f28-10cc-d2e1-e6130d87abc3_section-idm234790470711208", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ プログラミングシステム\/IDE\/ Deploy Tool \/ 製品のインストールはエラーで終了します。 \/ 必要条件 ", 
"snippet" : "ザ・ CODESYS インストールには製品固有のものが含まれます。 CODESYS パッケージ (およびその依存製品)インストールされている製品の概要は、で確認できます。 CODESYS Installer インストールされているアドオンのリストにあります。...", 
"body" : "ザ・ CODESYS インストールには製品固有のものが含まれます。 CODESYS パッケージ (およびその依存製品)インストールされている製品の概要は、で確認できます。 CODESYS Installer インストールされているアドオンのリストにあります。 " }, 
{ "title" : "トラブルシューティング ", 
"url" : "_rtsl_toubleshooting_deploytool1.html#UUID-11b462c5-1f28-10cc-d2e1-e6130d87abc3_section-idm234790470799509", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ プログラミングシステム\/IDE\/ Deploy Tool \/ 製品のインストールはエラーで終了します。 \/ トラブルシューティング ", 
"snippet" : "インストール中のエラーは、ターゲットデバイスによって発生する可能性があります。よくあるエラーは、読み取り専用のファイルシステム、古い依存関係や見つからない依存関係などです すべての商品は、パッケージを以下の場所に保管することを前提としています。 CODESYS Installer アドオンがインストールされたときにそれを保存しました。 ザ・ Deploy Tool インストールされている各製品に対して以下のステップを実行します。 ランタイムプロセスを停止します。 古い設定ファイルを保存します。 既存のパッケージを削除します。 新しいパッケージを転送します。 その他の製品固有のチェック項目は以下...", 
"body" : "インストール中のエラーは、ターゲットデバイスによって発生する可能性があります。よくあるエラーは、読み取り専用のファイルシステム、古い依存関係や見つからない依存関係などです すべての商品は、パッケージを以下の場所に保管することを前提としています。 CODESYS Installer アドオンがインストールされたときにそれを保存しました。 ザ・ Deploy Tool インストールされている各製品に対して以下のステップを実行します。 ランタイムプロセスを停止します。 古い設定ファイルを保存します。 既存のパッケージを削除します。 新しいパッケージを転送します。 その他の製品固有のチェック項目は以下のとおりです。 Deploy Tool 製品によって実行される。その後、パッケージマネージャーは新しく転送されたパッケージのインストールを試みます。 BeagleBoneBlack 追加の手順やチェックは実行されません。 Edge Gateway ザ・ Deploy Tool デバイスが armv4、armv5、または armv6 のアーキテクチャであるかどうかを確認します。この値は、コマンドを実行することで読み取られます uname -m 。 emPC 追加の手順やチェックは実行されません。 IOT2000 追加の手順やチェックは実行されません。 ライセンスサーバー ザ・ Deploy Tool Codemeter の最新バージョンをインストールしようとします。Codemeter または Codemeter Lite が、期待していたバージョンと同じか新しいバージョンでインストールされている場合 Deploy Tool この場合、システムには変更が加えられません。アップグレードや変更が必要な場合は、システムに変更を加える前に同意を求めるダイアログが開きます。同意すると、現在インストールされている Codemeter のバージョンが削除され、現在のバージョンがインストールされます。以下の点にご注意ください CODESYS Codemeter がシステムにインストールされていないと、Linux SL 用ライセンスサーバーは使用できません。 ザ・ Deploy Tool 「Cockpit」というオプションのプラグインをインストールすることもできます。これにより、 CODESYS WBM を使用できるため、ターゲットデバイスでのライセンスのアクティベーションが容易になります。このオプションを拒否してもインストールは続行されます。同意して Cockpit パッケージのインストール中にエラーが発生した場合、インストール処理は中止されます Linux SL LinuxARM SL LinuxARM64 SL ザ・ Deploy Tool Codemeter の最新バージョンをインストールしようとします。Codemeter または Codemeter Lite が、期待していたバージョンと同じか新しいバージョンでインストールされている場合 Deploy Tool この場合、システムには変更が加えられません。アップグレードや変更が必要な場合は、システムに変更を加える前に同意を求めるダイアログが開きます。同意すると、現在インストールされている Codemeter のバージョンが削除され、代わりに現在のバージョンがインストールされます Codemeterがシステムにインストールされていない場合、これらの製品は使用できませんのでご注意ください。 Safe Control 追加の手順やチェックは実行されません。 SafeTimeProvider 追加の手順やチェックは実行されません。 PFC100 PFC200 バージョン 4.15 より前: ザ・ Deploy Tool EntropyHelper パッケージをインストールしようとします。製品は、パッケージが次の場所に保存されていることを想定しています CODESYS Installer アドオンがインストールされたときにそれを保存しました。パッケージが一覧にない、見つからない、またはインストールに失敗した場合、製品はインストールされません TP600 追加の手順やチェックは実行されません。 PLCNext ザ・ Deploy Tool 次のコマンドでファームウェアのバージョンを読み取ろうとします。 cat \/etc\/plcnext\/arpversion | head -1 | cut -f2 -d' ' | cut -f-3 -d '.' バージョンを読み取れない場合、インストールは中止されます。 ザ・ Deploy Tool ローカルで次の内容を検索します。 codesys-arp PLCnext ファームウェアと一致するバージョンでパッケージ化してください。パッケージがインストールされます。パッケージが見つからなかったり、インストールが失敗したりすると、製品のインストールは中止されます Raspberry Pi パッケージをインストールすると、使用するランタイムタイプが定義されます。タイプはシステムで使用可能なローダーによって異なります。ローダーは、「」で説明されているように読み込まれます ユーザーランドアーキテクチャ「」の章。ローダーが見つからない場合は armv6l バリアントが使用されます。以下のリストは個々のバリアントを示しています。 マルチコア 64 ビット:aarch64 マルチコア 32 ビット:ARMv7 スタンダード (マルチコアなし): ARMv6 お使いのシステムによっては、この設定を変更することができます Deploy Tool 製品のインストール後。 TargetVisualization 追加の手順やチェックは実行されません。 Virtual Control Virtual Edge Virtual Safe Virtual SafeTimeProvider Python バージョン 3.9 以降で、Docker または Podman のいずれかがデバイスにインストールされている必要があります。 " }, 
{ "title" : "ターゲットデバイスへの接続が失敗します。 ", 
"url" : "_rtsl_toubleshooting_deploytool2.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ プログラミングシステム\/IDE\/ Deploy Tool \/ ターゲットデバイスへの接続が失敗します。 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "必要条件 ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790221847662", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ プログラミングシステム\/IDE\/ Deploy Tool \/ ターゲットデバイスへの接続が失敗します。 \/ 必要条件 ", 
"snippet" : "ターゲットデバイスのSSHサーバーは、既知のポート（ポート22など）で動作しています。 ターゲットデバイスの正しい IP アドレスがわかっています。IP アドレスを使用してターゲットデバイスに ping を送信できます...", 
"body" : "ターゲットデバイスのSSHサーバーは、既知のポート（ポート22など）で動作しています。 ターゲットデバイスの正しい IP アドレスがわかっています。IP アドレスを使用してターゲットデバイスに ping を送信できます " }, 
{ "title" : "トラブルシューティング ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790223645865", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ プログラミングシステム\/IDE\/ Deploy Tool \/ ターゲットデバイスへの接続が失敗します。 \/ トラブルシューティング ", 
"snippet" : "ネットワークが遅い、ネットワークエラーなどの他の問題によっても、接続が中断されることがあります。 ターゲットデバイスに接続すると、 Deploy Tool システムパラメータを読み取って、どのパッケージと機能が使用可能かを判断します。ターゲットデバイスの以下の点がチェックされます。...", 
"body" : "ネットワークが遅い、ネットワークエラーなどの他の問題によっても、接続が中断されることがあります。 ターゲットデバイスに接続すると、 Deploy Tool システムパラメータを読み取って、どのパッケージと機能が使用可能かを判断します。ターゲットデバイスの以下の点がチェックされます。 " }, 
{ "title" : "ユーザーランドアーキテクチャ ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790227601997", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ プログラミングシステム\/IDE\/ Deploy Tool \/ ターゲットデバイスへの接続が失敗します。 \/ トラブルシューティング \/ ユーザーランドアーキテクチャ ", 
"snippet" : "ザ・ Deploy Tool ターゲットデバイスで使用可能なローダーを検出します。使用可能なローダーによって、実行できるバイナリファイルが決まります。そのためには、 Deploy Tool 以下のコマンドを実行します。 ls -la \/lib*\/ld-linux* 出力に次の値のいずれかが含まれている場合、x86-64、i386、x32、armhf、aarch64 のそれぞれのアーキテクチャが使用可能であると見なされます。 バージョン 4.14.0.0 の場合: これらの値がいずれも見つからない場合、接続は切断されます。 バージョン 4.15.0.0 以降の場合: これらの値がいずれも見つから...", 
"body" : "ザ・ Deploy Tool ターゲットデバイスで使用可能なローダーを検出します。使用可能なローダーによって、実行できるバイナリファイルが決まります。そのためには、 Deploy Tool 以下のコマンドを実行します。 ls -la \/lib*\/ld-linux* 出力に次の値のいずれかが含まれている場合、x86-64、i386、x32、armhf、aarch64 のそれぞれのアーキテクチャが使用可能であると見なされます。 バージョン 4.14.0.0 の場合: これらの値がいずれも見つからない場合、接続は切断されます。 バージョン 4.15.0.0 以降の場合: これらの値がいずれも見つからない場合は、 Deploy Tool Userland アーキテクチャが検出されなかったことを示すログメッセージを出力します。次に、以下のパラメーターがチェックされます。ただし、これによって接続が切断されることはありません " }, 
{ "title" : "デバイスアーキテクチャ ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790234401598", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ プログラミングシステム\/IDE\/ Deploy Tool \/ ターゲットデバイスへの接続が失敗します。 \/ トラブルシューティング \/ デバイスアーキテクチャ ", 
"snippet" : "ザ・ Deploy Tool ターゲットデバイスで使用可能な CPU を確認します。そのためには、 Deploy Tool 以下のコマンドを実行します。 lscpu | grep ^Architecture: 出力に次の値のいずれかが含まれている場合は、x86_64、i686、aarch64、armv7l、armv6l のそれぞれのアーキテクチャが使用されます。 出力にこれらの値がまったく含まれていない場合、コマンド cat \/proc\/cpuinfo | grep '^model name' が実行されます。 cat \/proc\/cpuinfo | grep '^model name' 出力...", 
"body" : "ザ・ Deploy Tool ターゲットデバイスで使用可能な CPU を確認します。そのためには、 Deploy Tool 以下のコマンドを実行します。 lscpu | grep ^Architecture: 出力に次の値のいずれかが含まれている場合は、x86_64、i686、aarch64、armv7l、armv6l のそれぞれのアーキテクチャが使用されます。 出力にこれらの値がまったく含まれていない場合、コマンド cat \/proc\/cpuinfo | grep '^model name' が実行されます。 cat \/proc\/cpuinfo | grep '^model name' 出力に次の値のいずれかが含まれている場合は、x86_64、i686、aarch64、armv7l、armv6l のそれぞれのアーキテクチャが使用されます。 出力にこれらの値がまったく含まれていない場合は、ログメッセージが出力されます。 " }, 
{ "title" : "コンテナエンジン ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790244053777", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ プログラミングシステム\/IDE\/ Deploy Tool \/ ターゲットデバイスへの接続が失敗します。 \/ トラブルシューティング \/ コンテナエンジン ", 
"snippet" : "ザ・ Deploy Tool ターゲットデバイスで使用できるコンテナエンジンを確認します。そのためには、 Deploy Tool 以下のコマンドを実行します。 which docker 終了コードが 0 の場合、Docker はエンジンとして認識されます。 which podman 終了コードが 0 の場合、Podman はエンジンとして認識されます。 2 つのコンテナエンジンの同時使用はテストされておらず、完全にはサポートされていません。その結果、問題が発生する可能性があります。...", 
"body" : "ザ・ Deploy Tool ターゲットデバイスで使用できるコンテナエンジンを確認します。そのためには、 Deploy Tool 以下のコマンドを実行します。 which docker 終了コードが 0 の場合、Docker はエンジンとして認識されます。 which podman 終了コードが 0 の場合、Podman はエンジンとして認識されます。 2 つのコンテナエンジンの同時使用はテストされておらず、完全にはサポートされていません。その結果、問題が発生する可能性があります。 " }, 
{ "title" : "コンテナアーキテクチャ ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm2347902491793", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ プログラミングシステム\/IDE\/ Deploy Tool \/ ターゲットデバイスへの接続が失敗します。 \/ トラブルシューティング \/ コンテナアーキテクチャ ", 
"snippet" : "ザ・ Deploy Tool コンテナエンジンがどのアーキテクチャを実行できるかを確認します。そのためには、 Deploy Tool 検出されたエンジンに応じて、以下のコマンドを実行します。 docker info もし Architecture: 出力には次の値のいずれかが含まれている場合、x86_64、aarch64、armv7l、armv6l の各アーキテクチャが使用されます。 これらの値がいずれも見つからない場合は、ログメッセージが出力されます。 podman info もし arch: 出力には次の値のいずれかが含まれている場合、それぞれのアーキテクチャーが使用されます:amd64、...", 
"body" : "ザ・ Deploy Tool コンテナエンジンがどのアーキテクチャを実行できるかを確認します。そのためには、 Deploy Tool 検出されたエンジンに応じて、以下のコマンドを実行します。 docker info もし Architecture: 出力には次の値のいずれかが含まれている場合、x86_64、aarch64、armv7l、armv6l の各アーキテクチャが使用されます。 これらの値がいずれも見つからない場合は、ログメッセージが出力されます。 podman info もし arch: 出力には次の値のいずれかが含まれている場合、それぞれのアーキテクチャーが使用されます:amd64、aarch64、armv7l、armv6l。 これらの値がいずれも見つからない場合は、ログメッセージが出力されます。 " }, 
{ "title" : "初期化プロセス ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790249419828", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ プログラミングシステム\/IDE\/ Deploy Tool \/ ターゲットデバイスへの接続が失敗します。 \/ トラブルシューティング \/ 初期化プロセス ", 
"snippet" : "ザ・ Deploy Tool ターゲットデバイス上でどの init プロセスが使用可能かを確認します。そのためには、 Deploy Tool 以下のコマンドを実行します。 systemctl > \/dev\/null 2>&1 ; echo $? 終了コードが 0 で、出力に 0 が含まれている場合、 systemd 利用可能な init プロセスとして認識されます。 ls \/etc\/init.d > \/dev\/null 2>&1 ; echo $? 終了コードが 0 で、出力に 0 が含まれている場合、 initd 利用可能な init プロセスとして認識されます。...", 
"body" : "ザ・ Deploy Tool ターゲットデバイス上でどの init プロセスが使用可能かを確認します。そのためには、 Deploy Tool 以下のコマンドを実行します。 systemctl > \/dev\/null 2>&1 ; echo $? 終了コードが 0 で、出力に 0 が含まれている場合、 systemd 利用可能な init プロセスとして認識されます。 ls \/etc\/init.d > \/dev\/null 2>&1 ; echo $? 終了コードが 0 で、出力に 0 が含まれている場合、 initd 利用可能な init プロセスとして認識されます。 " }, 
{ "title" : "パッケージマネージャー ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790249681867", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ プログラミングシステム\/IDE\/ Deploy Tool \/ ターゲットデバイスへの接続が失敗します。 \/ トラブルシューティング \/ パッケージマネージャー ", 
"snippet" : "ザ・ Deploy Tool ターゲットデバイスでどのパッケージマネージャーが使用可能かを確認します。そのためには、 Deploy Tool 以下のコマンドを実行します。 which dpkg > \/dev\/null 2>&1; echo $? 終了コードが 0 で、出力に 0 が含まれている場合、 dpkg 利用可能なパッケージマネージャーとして登録されています。 which ipkg > \/dev\/null 2>&1; echo $? 終了コードが 0 で、出力に 0 が含まれている場合、 ipkg 利用可能なパッケージマネージャーとして登録されています。 which opkg > \/de...", 
"body" : "ザ・ Deploy Tool ターゲットデバイスでどのパッケージマネージャーが使用可能かを確認します。そのためには、 Deploy Tool 以下のコマンドを実行します。 which dpkg > \/dev\/null 2>&1; echo $? 終了コードが 0 で、出力に 0 が含まれている場合、 dpkg 利用可能なパッケージマネージャーとして登録されています。 which ipkg > \/dev\/null 2>&1; echo $? 終了コードが 0 で、出力に 0 が含まれている場合、 ipkg 利用可能なパッケージマネージャーとして登録されています。 which opkg > \/dev\/null 2>1; echo $? 終了コードが 0 で、出力に 0 が含まれている場合、 opkg 利用可能なパッケージマネージャーとして登録されています。 バージョン 4.15 以降の場合: which rpm > \/dev\/null 2>1; echo $? 終了コードが 0 で、出力に 0 が含まれている場合、 rpm 利用可能なパッケージマネージャーとして登録されています。 製品とシステムがサポートしている場合 dpkg と ipkg または opkg それから dpkg が使われています。 " }, 
{ "title" : "Python ", 
"url" : "_rtsl_toubleshooting_deploytool2.html#UUID-b83dc01e-8cff-c574-7efe-8615b95a51ed_section-idm234790250012792", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ プログラミングシステム\/IDE\/ Deploy Tool \/ ターゲットデバイスへの接続が失敗します。 \/ トラブルシューティング \/ Python ", 
"snippet" : "ザ・ Deploy Tool Python がターゲットデバイスで使用できるかどうかを確認します。そのためには、 Deploy Tool 以下のコマンドを実行します。 python3 -v 終了コードが 0 で、バージョンが 3.9 より大きい場合、Python はインストールされていると認識されます。...", 
"body" : "ザ・ Deploy Tool Python がターゲットデバイスで使用できるかどうかを確認します。そのためには、 Deploy Tool 以下のコマンドを実行します。 python3 -v 終了コードが 0 で、バージョンが 3.9 より大きい場合、Python はインストールされていると認識されます。 " }, 
{ "title" : "ターゲットデバイスにインストールする製品は選択できません。 ", 
"url" : "_rtsl_toubleshooting_deploytool3.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ プログラミングシステム\/IDE\/ Deploy Tool \/ ターゲットデバイスにインストールする製品は選択できません。 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "必要条件 ", 
"url" : "_rtsl_toubleshooting_deploytool3.html#UUID-492eba96-8c2f-b3cd-6935-f8dd7506d72f_section-idm23478724692167", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ プログラミングシステム\/IDE\/ Deploy Tool \/ ターゲットデバイスにインストールする製品は選択できません。 \/ 必要条件 ", 
"snippet" : "ザ・ CODESYS インストールには製品固有のものが含まれます。 CODESYS パッケージ (およびその依存製品)インストールされている製品の概要は、で確認できます。 CODESYS Installer インストールされているアドオンのリストにあります。...", 
"body" : "ザ・ CODESYS インストールには製品固有のものが含まれます。 CODESYS パッケージ (およびその依存製品)インストールされている製品の概要は、で確認できます。 CODESYS Installer インストールされているアドオンのリストにあります。 " }, 
{ "title" : "トラブルシューティング ", 
"url" : "_rtsl_toubleshooting_deploytool3.html#UUID-492eba96-8c2f-b3cd-6935-f8dd7506d72f_section-idm234787250012849", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ プログラミングシステム\/IDE\/ Deploy Tool \/ ターゲットデバイスにインストールする製品は選択できません。 \/ トラブルシューティング ", 
"snippet" : "で製品を選択できます Deploy Tool ターゲットデバイスがこの製品の要件 (使用可能なアーキテクチャ、パッケージマネージャー、init プロセスなど) を満たしている場合のみ。 各製品には、対応するユーザーランドアーキテクチャ、パッケージマネージャー、および init プロセスが必要です (特に指定がない限り、 initd は必須です)。 詳細については、以下を参照してください。 トラブルシューティング。 次のリストは、個々の製品がチェックする内容を示しています。 [製品] BeagleBoneBlack の出力 cat \/proc\/cpuinfo | grep '^model nam...", 
"body" : "で製品を選択できます Deploy Tool ターゲットデバイスがこの製品の要件 (使用可能なアーキテクチャ、パッケージマネージャー、init プロセスなど) を満たしている場合のみ。 各製品には、対応するユーザーランドアーキテクチャ、パッケージマネージャー、および init プロセスが必要です (特に指定がない限り、 initd は必須です)。 詳細については、以下を参照してください。 トラブルシューティング。 次のリストは、個々の製品がチェックする内容を示しています。 [製品] BeagleBoneBlack の出力 cat \/proc\/cpuinfo | grep '^model name\\|^Hardware' 以下を含まなければなりません ARMv7 そして Generic AM33XX 。 Edge Gateway PLCNextコントローラで使用する場合、PLCNextエッジゲートウェイアドオンがWindowsコンピュータで使用できる必要があります。(PLCNext ディレクトリにあるはずです コマンドの出力 uname -m 以下を含んではいけません uarmv4 、 uarmv5 、または uarmv6 。 emPC eth0 または eth1 で始まる MAC アドレスが必要です 00:90:E9 。 IOT2000 eth0 または eth1 で始まる MAC アドレスが必要です E0:DC:A0 。 License Server 追加チェックなし LinuxARM SL und LinuxARM64 SL 対応する Userland アーキテクチャが使用可能である必要があります ( armhf または aarch64 )。 Safe Control 32 ビットの AMD アーキテクチャ (i386) が必要です SafeTimeProvider 64 ビットの AMD アーキテクチャ (x86-64) と Python の可用性が必要です。 これを確認する方法の説明については、「」の「Python」セクションを参照してください。 ターゲットデバイスへの接続が失敗します。「」の章。 Linux SL 64 ビットの AMD アーキテクチャ (x86-64) が必要です PFC100 PFC200 TP600 必要な ipkg または opkg および 32 ビット ARM アーキテクチャ ( armhf ) PLCNext パスが必要 \/etc\/plcnext\/arpversion 存在する Raspberry Pi cat \/proc\/cpuinfo | grep ^Model | awk -F':' '{print $2}' 「ラズベリー」が含まれていなければなりません。 TargetVisualization 次のパッケージをインストールする必要があります。 libqt6core6 libqt6gui6 libqt6widgets6 libqt6network6 libqt6svg6 libqt6webenginewidgets6 libqt6webenginecore6 名前は正確に一致する必要があります。インストールされたパッケージは次のコマンドで決定されます コマンド dpkg -l <package> | awk '\/<package>\/ {print }' の出力には、すべてのパッケージの ii が含まれていなければならない。 libqt6core6 バージョン 6.4.2 以降でインストールする必要があります。バージョンは次のコマンドで決定されます dpkg -s libqt6core6 | grep '^Version:' | grep -o -E '\\b[0-9]+\\.[0-9]+\\.[0-9]+\\b' Virtual Control Virtual Edge Virtual Safe Virtual SafeTimeProvider Python が使用可能である必要があります。 これを確認する方法の説明については、「」の「Python」セクションを参照してください。 ターゲットデバイスへの接続が失敗します。「」の章。 Podman または Docker をインストールし、使用可能なコンテナアーキテクチャと一致するイメージを用意する必要があります。 Virtual SafeTimeProvider x86-64 ユーザーランドアーキテクチャと Python が利用可能である必要があります。 これを確認する方法の説明については、「」の「Python」セクションを参照してください。 ターゲットデバイスへの接続が失敗します。「」の章。 Virtual Safe i386 ユーザーランドアーキテクチャと Python が利用可能である必要があります。 これを確認する方法の説明については、「」の「Python」セクションを参照してください。 ターゲットデバイスへの接続が失敗します。「」の章。 Virtual Control Virtual Edge ユーザーランドアーキテクチャ x86-64、ARMHF または ARM64 のいずれかが必要で、Python が使用可能である必要があります。 これを確認する方法の説明については、「」の「Python」セクションを参照してください。 ターゲットデバイスへの接続が失敗します。「」の章。 " }, 
{ "title" : "リナックスターゲット ", 
"url" : "_rtsl_toubleshooting_linuxtarget.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ リナックスターゲット ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "IEC アプリケーションでの奇妙な動作 ", 
"url" : "_rtsl_toubleshooting_linuxtarget_stange.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ リナックスターゲット \/ IEC アプリケーションでの奇妙な動作 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "必要条件 ", 
"url" : "_rtsl_toubleshooting_linuxtarget_stange.html#UUID-15af7838-c568-6bc8-9b0d-6c5ba94f66cf_section-idm234790740254336", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ リナックスターゲット \/ IEC アプリケーションでの奇妙な動作 \/ 必要条件 ", 
"snippet" : "を使用しております CODESYS ランタイム。...", 
"body" : "を使用しております CODESYS ランタイム。 " }, 
{ "title" : "トラブルシューティング ", 
"url" : "_rtsl_toubleshooting_linuxtarget_stange.html#UUID-15af7838-c568-6bc8-9b0d-6c5ba94f66cf_section-idm234790740478094", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ リナックスターゲット \/ IEC アプリケーションでの奇妙な動作 \/ トラブルシューティング ", 
"snippet" : "奇妙な動作が見られる場合は、ランタイムロガーが貴重なヒントや情報を提供しているかどうかを確認する必要があります。は CODESYS ランタイムロガーには、メッセージをカテゴリ別にフィルタリングするメカニズムがあります。は デバッグ カテゴリはデフォルトでは有効になっていません。このカテゴリを有効にすると、異常な動作や予期しない症状の原因を調べることができます。 グローバルログフィルターとコンポーネント固有のログフィルターがあります。ランタイムのログファイルには、考えられるすべてのコンポーネント固有のフィルターの詳細なリストが表示されます。フィルターは以下の説明に従って使用してください に関連す...", 
"body" : "奇妙な動作が見られる場合は、ランタイムロガーが貴重なヒントや情報を提供しているかどうかを確認する必要があります。は CODESYS ランタイムロガーには、メッセージをカテゴリ別にフィルタリングするメカニズムがあります。は デバッグ カテゴリはデフォルトでは有効になっていません。このカテゴリを有効にすると、異常な動作や予期しない症状の原因を調べることができます。 グローバルログフィルターとコンポーネント固有のログフィルターがあります。ランタイムのログファイルには、考えられるすべてのコンポーネント固有のフィルターの詳細なリストが表示されます。フィルターは以下の説明に従って使用してください に関連する症状 可能なコンポーネントベースのログフィルター ライセンス CmpCodeMeter IEC タスク\/タイミング (上位レベル) CmpIecTask IEC タスク\/タイミング (低レベル) CmpSchedule 、 SysTask IEC アプリケーション (一般) CmpApp 、 CmpIecTask IEC アプリケーション (メモリ) SysMem ソケット通信 SysSocket イーサネット通信 SysEthernet ファイル\/フォルダー SysFile 、 SysDir すべてのデバッグカテゴリを同時に有効にしないでください。実際の問題を見つけるのが難しくなります。問題をより的確に把握できるように、段階的に進めて「無関係な」フィルターを無効にしてください を有効にする デバッグ PLC シェル経由のメッセージカテゴリ (ランタイムバージョンが SP20 以上の場合) を開く CODESYS プロジェクトを作成し、コントローラに接続します。 デバイスツリーのコントローラーをダブルクリックして PLC シェルを開きます。 「?」と入力します。シェルに「」を入力すると、使用可能なすべてのコマンドが表示されます。 を使う logsetfilter 、 loggetfilter 、および logdelfilter フィルターの書き込み、読み取り、削除を行うコマンド。ランタイム全体にグローバルデバッグフィルターを使用することも、特定のコンポーネントにフィルターを使用することもできます。 現在のログカテゴリをグローバルに読み込むには: loggetfilter 次の出力を返す可能性があります。 Logger.0.Filter : 0x0000000F 現在のログカテゴリをグローバルに設定するには: logsetfilter 0xffffffff 特定のコンポーネントの現在のログカテゴリを読み取るには (たとえば、 CmpCodeMeter ): loggetfilter CmpCodeMeter 特定のコンポーネント (CmpCodeMeter など) の現在のログカテゴリを設定するには: logsetfilter CmpCodeMeter 0xffffffff ランタイム設定ファイルによるロガーカテゴリの有効化 (古いランタイムバージョンの場合) 例:SSH 接続とテキストエディター経由 デプロイツールを使用してランタイムを停止します。 ターゲットシステムへの接続 (たとえば、 putty または別の SSH クライアント)。 ランタイム環境のユーザー固有の設定ファイルをテキストエディターで開きます (例: nano ): sudo nano \/etc\/codesyscontrol\/CODESYSControl_User.cfg 見つけて CmpLog セクションを作成し、フィルターを設定します。 グローバルフィルターを設定する 例: Logger.0.Filter=0xFFFFFFFFFF すべてのデバッグメッセージを有効にするには コンポーネント固有のフィルターを設定する [CmpLog]\nCmpCodeMeter.Filter=0xFFFFFFFF\nSysTask.Filter=0xFFFFFFFF ファイルを保存して閉じます。 デプロイツールを使用してランタイムを再起動します。 " }, 
{ "title" : "IEC アプリケーション ", 
"url" : "_rtsl_toubleshooting_iec.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ IEC アプリケーション ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "IEC アプリケーションはセマフォによって異なります。 ", 
"url" : "_rtsl_toubleshooting_iec_semaphores.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ IEC アプリケーション \/ IEC アプリケーションはセマフォによって異なります。 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "必要条件 ", 
"url" : "_rtsl_toubleshooting_iec_semaphores.html#UUID-0421c326-6af8-0336-eb1f-9f6120d597b5_section-idm234795575934472", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ IEC アプリケーション \/ IEC アプリケーションはセマフォによって異なります。 \/ 必要条件 ", 
"snippet" : "Linux または Windows ベースのランタイムバージョンが SP20 以上である。...", 
"body" : "Linux または Windows ベースのランタイムバージョンが SP20 以上である。 " }, 
{ "title" : "トラブルシューティング ", 
"url" : "_rtsl_toubleshooting_iec_semaphores.html#UUID-0421c326-6af8-0336-eb1f-9f6120d597b5_section-idm234795576141488", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ IEC アプリケーション \/ IEC アプリケーションはセマフォによって異なります。 \/ トラブルシューティング ", 
"snippet" : "IEC アプリケーションの実行中または操作中にデッドロックやセマフォのハングが発生する場合 CODESYS 実行時は、セマフォのロックまたはデッドロックが原因である可能性があります。 ランタイムバージョンSP20以降（LinuxおよびWindows）は、セマフォの診断機能に役立ちます。この診断は、セマフォを見つけたり、問題のあるセマフォを処理している関連タスク間の相互作用を見つけたりするのに役立ちます 設定ファイルでこの機能を有効にする必要があります。 [SysSem] SemEnterDiagnosis=1 これは、アプリケーション (およびランタイム) のパフォーマンスとタイミングに深刻な...", 
"body" : "IEC アプリケーションの実行中または操作中にデッドロックやセマフォのハングが発生する場合 CODESYS 実行時は、セマフォのロックまたはデッドロックが原因である可能性があります。 ランタイムバージョンSP20以降（LinuxおよびWindows）は、セマフォの診断機能に役立ちます。この診断は、セマフォを見つけたり、問題のあるセマフォを処理している関連タスク間の相互作用を見つけたりするのに役立ちます 設定ファイルでこの機能を有効にする必要があります。 [SysSem]\nSemEnterDiagnosis=1 これは、アプリケーション (およびランタイム) のパフォーマンスとタイミングに深刻な影響を与える可能性があります。 診断目的でのみ使用してください。 プロダクションシステムでは使用しないでください。 出力は次のようになります。 この例では、 MainTask_1 セマフォを数ミリ秒間保持し、 MainTask このセマフォにアクセスしようとします。 " }, 
{ "title" : "IEC アプリケーションはこれ以上ファイルハンドルを開くことができません。 ", 
"url" : "_rtsl_toubleshooting_iec_filehandles.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ IEC アプリケーション \/ IEC アプリケーションはこれ以上ファイルハンドルを開くことができません。 ", 
"snippet" : "システム上のファイルハンドルの制限を変更する前に、Linux システム上のすべてのサービスへの影響を早急に検討する必要があります。代わりに、リークの原因を突き止めることをお勧めします。...", 
"body" : "システム上のファイルハンドルの制限を変更する前に、Linux システム上のすべてのサービスへの影響を早急に検討する必要があります。代わりに、リークの原因を突き止めることをお勧めします。 " }, 
{ "title" : "トラブルシューティング ", 
"url" : "_rtsl_toubleshooting_iec_filehandles.html#UUID-4043602f-b92d-ba82-ffe1-5d6eea5cf6f5_section-idm234795576141488", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ IEC アプリケーション \/ IEC アプリケーションはこれ以上ファイルハンドルを開くことができません。 \/ トラブルシューティング ", 
"snippet" : "ファイルハンドルのリークにより、次のような影響が生じる可能性があります。 ライセンスステータスの喪失。WIBU ライセンスは一定期間が経過すると破棄されます 新しいファイルを開くことはできません。 Linux プロセスのデフォルトの動作では、オープンできるファイルハンドルの数が最大になります。プロセスがこの制限に達すると、それ以上新しいファイルを開くことができなくなります。 システムの制限値は、コンソールコマンドで確認できます。 ulimit -n Linuxの各プロセスにはプロセスIDがあり、カーネルはファイル\/フォルダシステム内の各プロセスに関する詳細情報を提供します。 procfs 。こ...", 
"body" : "ファイルハンドルのリークにより、次のような影響が生じる可能性があります。 ライセンスステータスの喪失。WIBU ライセンスは一定期間が経過すると破棄されます 新しいファイルを開くことはできません。 Linux プロセスのデフォルトの動作では、オープンできるファイルハンドルの数が最大になります。プロセスがこの制限に達すると、それ以上新しいファイルを開くことができなくなります。 システムの制限値は、コンソールコマンドで確認できます。 ulimit -n Linuxの各プロセスにはプロセスIDがあり、カーネルはファイル\/フォルダシステム内の各プロセスに関する詳細情報を提供します。 procfs 。これにより、1 つのプロセスに同時に割り当てられるファイルハンドルの数を簡単に判断できます。 ファイルハンドルリークの可能性を調査するには、次の手順を実行することをお勧めします。 のプロセス ID を検索する CODESYS ランタイム環境。 標準の Linux ツールを使用して、のプロセス ID を検索できます。 CODESYS ランタイム環境: htop 通常、プロセス ID は最初の列 (PID) に表示されます。 top 通常は、プロセス ID を最初の列 (PID) に表示します。 組み合わせることができます ps と grep クイック検索用のコマンド: ps aux | grep codesyscontrol プロセスIDをメモしておき、プレースホルダー <pid> が使用されている以下のコマンドで使用する。 ファイルハンドルを確認して監視してください。 次に、エントリを一覧表示します procfs ランタイムプロセスのファイルハンドルを表示します。 sudo ls -la \/proc\/<pid>\/fd\/ これは次のようになります ファイルハンドルが「実際の」ファイルの場合は、パスが表示されます。他のファイルハンドルはソケットなどでもかまいません このコマンドを連続して複数回実行すると、ファイルハンドルの数が増えているかどうか、およびどのファイルが開いているかを確認できます。 ザ・ watch コマンドは 2 秒ごとに更新されるビューを作成します。 watch sudo ls -la \/proc\/<pid>\/fd\/ これらのアクションは、開いているハンドルを監視し、どのファイルがファイルハンドルリークに関係している可能性があるかを調べるのに役立ちます。 " }, 
{ "title" : "IEC アプリケーションのメモリ消費量が増加しています。 ", 
"url" : "_rtsl_toubleshooting_iec_memory.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ IEC アプリケーション \/ IEC アプリケーションのメモリ消費量が増加しています。 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "準備: ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234795798419608", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ IEC アプリケーション \/ IEC アプリケーションのメモリ消費量が増加しています。 \/ 準備: ", 
"snippet" : "次のようなランタイムシステムが必要です CmpMemGC コンポーネントは有効でアクティブです。このコンポーネントがランタイムログに読み込まれているかどうかを確認できます。...", 
"body" : "次のようなランタイムシステムが必要です CmpMemGC コンポーネントは有効でアクティブです。このコンポーネントがランタイムログに読み込まれているかどうかを確認できます。 " }, 
{ "title" : "トラブルシューティング ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234795576141488", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ IEC アプリケーション \/ IEC アプリケーションのメモリ消費量が増加しています。 \/ トラブルシューティング ", 
"snippet" : "IEC アプリケーションを一定時間稼動させた後に異常な影響 (ライセンスステータスが失われたり、新しいメモリを割り当てられないなど) に気付いた場合は、メモリリークが原因である可能性があります。 これらの影響を調査し、問題の原因を突き止める必要があります。...", 
"body" : "IEC アプリケーションを一定時間稼動させた後に異常な影響 (ライセンスステータスが失われたり、新しいメモリを割り当てられないなど) に気付いた場合は、メモリリークが原因である可能性があります。 これらの影響を調査し、問題の原因を突き止める必要があります。 " }, 
{ "title" : "CODESYS メモリデバイストレース ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234796058905879", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ IEC アプリケーション \/ IEC アプリケーションのメモリ消費量が増加しています。 \/ トラブルシューティング \/ CODESYS メモリデバイストレース ", 
"snippet" : "この関数は、ランタイムシステムバージョン SP19 (SL バージョン 4.9.0.0) 以降で使用できます。これはとても簡単に使えます ランタイム環境で設定を有効にします。 を使用してランタイムを停止します Deploy Tool . 経由でターゲットシステムに接続します putty または別の SSH クライアント。 ランタイム環境の設定ファイルをテキストエディタ (nano など) で開きます。 sudo nano \/etc\/codesyscontrol\/CODESYSControl.cfg で CmpMemGC セクション、エントリを追加 EnableMemTrace=1 。 [Cmp...", 
"body" : "この関数は、ランタイムシステムバージョン SP19 (SL バージョン 4.9.0.0) 以降で使用できます。これはとても簡単に使えます ランタイム環境で設定を有効にします。 を使用してランタイムを停止します Deploy Tool . 経由でターゲットシステムに接続します putty または別の SSH クライアント。 ランタイム環境の設定ファイルをテキストエディタ (nano など) で開きます。 sudo nano \/etc\/codesyscontrol\/CODESYSControl.cfg で CmpMemGC セクション、エントリを追加 EnableMemTrace=1 。 [CmpMemGC]\nEnableMemTrace=1 ファイルを保存して閉じます。 を使用してランタイムを再起動します。 Deploy Tool . デバイストレースをあなたのデバイスに追加してください CODESYS プロジェクト (この問題が発生する場所)。 デバイスツリーで、デバイスを右クリックします。 クリック [オブジェクトを追加] → デバイストレース 。 ザ・ デバイストレース オブジェクトはコントローラーの下に挿入されます。 ザ・ デバイストレース タブが表示されます。 をクリックします トレース → トレースをアップロード コマンド。 ザ・ デバイス 'Codesys_Control_for_Linux_SL' のオンライントレース ダイアログが開きます。 見つからない場合 MemgcTrace と入力すると、手順 1 の設定が正しく設定されていません。コントローラがメカニズムをサポートしていない場合は、次の 2 つのオプションのいずれかを使用して診断してください。 選択してください MEMGC トレース 入力してクリック アップロードしてダイアログを閉じる 。 メモリトレース ( MemGCTrace ) がに追加されました DeviceTrace 。 詳細については、以下を参照してください。 コマンド:トレースをアップロード " }, 
{ "title" : "CODESYS ライブラリ:システムメム ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234796059265431", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ IEC アプリケーション \/ IEC アプリケーションのメモリ消費量が増加しています。 \/ トラブルシューティング \/ CODESYS ライブラリ:システムメム ", 
"snippet" : "プログラムから内部情報にアクセスすることもできます。IEC ライブラリ関数を使用して、割り当てられているすべての RAM\/ヒープメモリの現在の概要にアクセスできます SysMem.SysMemGetCurrentHeapSize() この値を使用して、現在のヒープサイズを確認できます。この値は確認することも、トレースに書き込むこともできます これは、割り当てられたメモリの増加が IEC アプリケーションの他の特定のイベントによって時間的に増加したかどうかを判断するのに役立ちます。...", 
"body" : "プログラムから内部情報にアクセスすることもできます。IEC ライブラリ関数を使用して、割り当てられているすべての RAM\/ヒープメモリの現在の概要にアクセスできます SysMem.SysMemGetCurrentHeapSize() この値を使用して、現在のヒープサイズを確認できます。この値は確認することも、トレースに書き込むこともできます これは、割り当てられたメモリの増加が IEC アプリケーションの他の特定のイベントによって時間的に増加したかどうかを判断するのに役立ちます。 " }, 
{ "title" : "Linux コマンドライン ", 
"url" : "_rtsl_toubleshooting_iec_memory.html#UUID-a1c55192-a887-c86e-7470-aa38da5105b2_section-idm234796059607787", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ IEC アプリケーション \/ IEC アプリケーションのメモリ消費量が増加しています。 \/ トラブルシューティング \/ Linux コマンドライン ", 
"snippet" : "Linux コンソールに (たとえば SSH クライアント経由で) アクセスできる場合は、メモリの動作を確認することもできます。 これを実現するためのさまざまなツールとコマンドがあります。 トップ\/トップ これらは Linux システム上のプロセス (およびスレッド) を分析するためのグラフィカルツールです。 ほとんどすべてのLinuxディストリビューションにこれらのツールが提供されているため、次の方法で簡単にインストールできます apt または dnf またはディストリビューションのパッケージ管理 htop  # or  top どちらのツールでも、ツリービューでスレッドを確認したり、ツリー...", 
"body" : "Linux コンソールに (たとえば SSH クライアント経由で) アクセスできる場合は、メモリの動作を確認することもできます。 これを実現するためのさまざまなツールとコマンドがあります。 トップ\/トップ これらは Linux システム上のプロセス (およびスレッド) を分析するためのグラフィカルツールです。 ほとんどすべてのLinuxディストリビューションにこれらのツールが提供されているため、次の方法で簡単にインストールできます apt または dnf またはディストリビューションのパッケージ管理 htop \n# or \ntop どちらのツールでも、ツリービューでスレッドを確認したり、ツリービューを分析したりできます。 CODESYS ランタイムプロセスとそのスレッド。各 IEC タスクは pthread ランタイムプロセス内。 htop ツールでは、次の方法でビューをカスタマイズできます F2 (セットアップメニュー): 有効にすることをお勧めします Tree view と Show custom thread names オプション。 上部では、キーの組み合わせでツリービューを有効にできます Shift + V したがって、スレッドごとの CPU 使用率\/メモリ使用量が表示されます。これは、割り当てられたメモリの増加が IEC アプリケーションの他の特定のイベントによって時間的に増加しているのか、それともメモリリークが発生しているのかを判断するのに役立ちます " }, 
{ "title" : "セーフティランタイムは、ログファイルにタイミングエラーを表示します。 ", 
"url" : "_rtsl_toubleshooting_iec_safety.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ IEC アプリケーション \/ セーフティランタイムは、ログファイルにタイミングエラーを表示します。 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "準備: ", 
"url" : "_rtsl_toubleshooting_iec_safety.html#UUID-fb433041-da54-96ca-38a9-082bdc100698_section-idm234795798419608", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ IEC アプリケーション \/ セーフティランタイムは、ログファイルにタイミングエラーを表示します。 \/ 準備: ", 
"snippet" : "実行しています CODESYS Safe Control SL または CODESYS Virtual Safe Control SL と組み合わされた CODESYS Safe Time Provider 。...", 
"body" : "実行しています CODESYS Safe Control SL または CODESYS Virtual Safe Control SL と組み合わされた CODESYS Safe Time Provider 。 " }, 
{ "title" : "トラブルシューティング ", 
"url" : "_rtsl_toubleshooting_iec_safety.html#UUID-fb433041-da54-96ca-38a9-082bdc100698_section-idm234795576141488", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ IEC アプリケーション \/ セーフティランタイムは、ログファイルにタイミングエラーを表示します。 \/ トラブルシューティング ", 
"snippet" : "から報告された問題が発生した場合 CODESYS Safe Control SL ランタイム環境とタイミングに関する問題 (から) CmpSIL3 component) の場合、セーフタイムネットワークでタイミングの問題が発生している可能性があり、調査する必要があります。 ログメッセージは次のようになります。 #### Exception: ID: 0x40000066 <p0>0xb633<\/p0> <p1>0xbcdd<\/p1> <p2>0xbce1<\/p2> <p3>0xb2fd<\/p3> <p4>0x0<\/p4> 例外エラーには以下の意味があります。 0x40000065 : 例外チャ...", 
"body" : "から報告された問題が発生した場合 CODESYS Safe Control SL ランタイム環境とタイミングに関する問題 (から) CmpSIL3 component) の場合、セーフタイムネットワークでタイミングの問題が発生している可能性があり、調査する必要があります。 ログメッセージは次のようになります。 #### Exception: ID: 0x40000066 <p0>0xb633<\/p0> <p1>0xbcdd<\/p1> <p2>0xbce1<\/p2> <p3>0xb2fd<\/p3> <p4>0x0<\/p4> 例外エラーには以下の意味があります。 0x40000065 : 例外チャネル x: サイクルタイムのローカルタイムスタンプの妥当性チェック 0x40000066 : 例外チャネル x: サイクルタイムまでのリモートタイムスタンプの妥当性チェック 0x40000067 : 例外チャネル x: リモートタイムスタンプとローカルタイムスタンプの妥当性チェック セーフタイムネットワーク（間 CODESYS Safe Time Provider と CODESYS Safe Control ランタイム環境) には、フィールドバスネットワーク (EtherCAT や Profinet など) と同じ高い安定性とリアルタイム性に対する要件があります。 " }, 
{ "title" : "によるトレース tcpdump ", 
"url" : "_rtsl_toubleshooting_iec_safety.html#UUID-fb433041-da54-96ca-38a9-082bdc100698_section-idm234795897227037", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ IEC アプリケーション \/ セーフティランタイムは、ログファイルにタイミングエラーを表示します。 \/ トラブルシューティング \/ によるトレース tcpdump ", 
"snippet" : "Linux コマンドラインでは、次の方法で簡単にトレースを作成できます。 tcpdump ツール。すでに Wireshark またはハードウェアトレースデバイスに慣れている場合は、これを使用してトレースを作成することもできます 従う必要のある基本的な手順: トレースするネットワークアダプタを決定します。 トレースを小さくするには、トレースしたい内容 (内容、パッケージタイプ、ログなど) を確認します。 便利なコマンド インストール tcpdump (お使いのディストリビューション\/ソフトウェアパッケージ管理によって異なります) 例えば、Debian\/Ubuntu の「apt」ベースの場合: s...", 
"body" : "Linux コマンドラインでは、次の方法で簡単にトレースを作成できます。 tcpdump ツール。すでに Wireshark またはハードウェアトレースデバイスに慣れている場合は、これを使用してトレースを作成することもできます 従う必要のある基本的な手順: トレースするネットワークアダプタを決定します。 トレースを小さくするには、トレースしたい内容 (内容、パッケージタイプ、ログなど) を確認します。 便利なコマンド インストール tcpdump (お使いのディストリビューション\/ソフトウェアパッケージ管理によって異なります) 例えば、Debian\/Ubuntu の「apt」ベースの場合: sudo apt install tcpdump レッドハット-「Yum\/DNF」ベース: sudo yum install tcpdump 使用可能なすべてのネットワークアダプタが表示されます。 tcpdump 監視可能: > tcpdump -D \n1.eno1 [Up, Running, Connected]\n2.any (Pseudo-device that captures on all interfaces) [Up, Running]\n3.lo [Up, Running, Loopback] 実行することは可能です tcpdump 通常のユーザーとして。これを実行したい場合は、以下をお読みください tcpdump 詳細については、ドキュメンテーションを参照してください。 tcpdump コマンドライン引数 で可能なすべてのコマンドの詳細 tcpdump 次の場所にあります tcpdump マニュアルページ: https:\/\/www.tcpdump.org\/manpages\/tcpdump.1.html または電話 tcpdump : > tcpdump --help \n\ntcpdump version 4.99.3\nlibpcap version 1.10.3 (with TPACKET_V3)\nOpenSSL 3.0.15 3 Sep 2024\nUsage: tcpdump [-AbdDefhHIJKlLnNOpqStuUvxX#] [ -B size ] [ -c count ] [--count]\n                [ -C file_size ] [ -E algo:secret ] [ -F file ] [ -G seconds ]\n                [ -i interface ] [ --immediate-mode ] [ -j tstamptype ]\n                [ -M secret ] [ --number ] [ --print ] [ -Q in|out|inout ]\n                [ -r file ] [ -s snaplen ] [ -T type ] [ --version ]\n                [ -V file ] [ -w file ] [ -W filecount ] [ -y datalinktype ]\n                [ --time-stamp-precision precision ] [ --micro ] [ --nano ]\n                [ -z postrotate-command ] [ -Z user ] [ expression ] 最も重要なフラグとフィルター: フラッグ (ショート\/ロング) [説明] -D --list-interfaces システム上で利用可能なネットワークインターフェースのリストを返します。ここで tcpdump コマンドでパケットをキャプチャできる -i <interface> --interface <interface> インターフェースに問い合わせて、次の情報を返します。 リンクレイヤータイプのリスト タイムスタンプタイプのリスト フィルター式をコンパイルした結果 -c <Count> <count> 個のパケットを受信または読み込んだ後、問い合わせを終了する。 -n アドレス (ホストアドレス、ポート番号など) が名前に変換されないようにします。 -A 各パケット (リンクレベルヘッダーを除く) を ASCII で出力します -x 解析時には、各パケットのヘッダーに加えて、各パケットのデータ (リンクレベルのヘッダーを除く) が 16 進数で出力されます。 -s <snaplen> --snapshot-length=<snaplen> デフォルト値の262144バイトではなく、各パケットから <snaplen> バイトのデータを使用する。 -w <file> 未処理のデータパケットを分析して印刷する代わりにファイルに書き込みます -t 各ダンプラインにタイムスタンプが出力されないようにします -tt 各ダンプラインのタイムスタンプを、1970 年 1 月 1 日 00:00:00 からの秒数、UTC、およびそれ以降の 1 秒の端数で返します。 -ttt 次に応じて、デルタ (マイクロ秒またはナノ秒) の解像度を出力します。 --time-stamp-precision オプション) 各ダンプラインの現在の行と前の行の間。デフォルト設定はマイクロ秒単位の解像度です -tttt 各ダンプラインに、午前 0 時からの時間、分、秒、および秒の端数でタイムスタンプを出力します。出力の前には日付が付きます -v 追加情報 (詳細) を出力します パッケージをトレースする コンソールでの簡単なキャプチャと出力: > sudo tcpdump -i <interfacename>\n\n# e.g. with interface \"eno1\":\n> sudo tcpdump -i eno1 Wireshark 互換ファイルとしてキャプチャして出力する > sudo tcpdump -i <interfacename> -w <file>\n \n# e.g.\n> sudo tcpdump -i eno1 -w myfirsttrace.pcap 次に、ファイル myfirsttrace.pcap Wireshark で開くことができます。( .pcap は Wireshark トレースファイルのデフォルトのファイル拡張子です。) 例 > sudo tcpdump -i eno1 -w myfirsttrace.cap -s 200 udp port 60000 " }, 
{ "title" : "調査\/分析 ", 
"url" : "_rtsl_toubleshooting_iec_safety.html#UUID-fb433041-da54-96ca-38a9-082bdc100698_section-idm234795898218432", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ トラブルシューティング \/ IEC アプリケーション \/ セーフティランタイムは、ログファイルにタイミングエラーを表示します。 \/ トラブルシューティング \/ 調査\/分析 ", 
"snippet" : "トレースを作成したら、それを分析する必要があります。これは tcpdump を使用して行うことも、Wireshark を使用してグラフィカルに実行することもできます 上の例のように、セーフコントロール SL のホスト (タイムプロバイダー通信の受信側) にトレースを記録します。 次に、Wireshark を使用して*.pcap ファイルを開きます。このようになっているはずです パッケージは通常、1 ミリ秒 (パッケージ間の時差) の間隔で送信されることがわかります。(パケット番号 58 以降を参照してください)。 典型的な問題のある状況 CODESYS Safe Control SL で例外が...", 
"body" : "トレースを作成したら、それを分析する必要があります。これは tcpdump を使用して行うことも、Wireshark を使用してグラフィカルに実行することもできます 上の例のように、セーフコントロール SL のホスト (タイムプロバイダー通信の受信側) にトレースを記録します。 次に、Wireshark を使用して*.pcap ファイルを開きます。このようになっているはずです パッケージは通常、1 ミリ秒 (パッケージ間の時差) の間隔で送信されることがわかります。(パケット番号 58 以降を参照してください)。 典型的な問題のある状況 CODESYS Safe Control SL で例外が発生する\/タイミングの問題はパケット番号 74 で確認できます。このパケットは前のパケットの 2 ミリ秒後に受信されるため、遅延は 1 ミリ秒程度です。このような状況は、次のような場合には受け入れられません CODESYS Safe Control 信頼性が高くリアルタイム対応のタイムスタンプとしての SL。 遅延を減らすためのアクション 問題が受信側と送信側のどちらで発生しているかを確認します。受信側の両方を考慮する必要があります ( CODESYS Safe Control ホスト) と送信側 ( CODESYS Safe Time Provider ホスト)。 このタイムスタンプ通信全般のリアルタイム機能と堅牢性を向上させてください。そのためには、他の干渉する通信や負荷をこのネットワークから取り除きます (タイムスタンプを安全にするためだけに使用) (ネットワークドライバの) 対応する IRQ の処理優先順位を設定することで、送受信のパフォーマンスを向上させます。 これ以上改善できず、安全プロセスで改善できる場合は、サイクルタイムを長くすることができます CODESYS Safe Time Provider (タイムスタンプの送信)。 " }, 
{ "title" : "リファレンス ", 
"url" : "_rtsl_reference_linux.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ リファレンス ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド:コントロール SL をデプロイ ", 
"url" : "_rtsl_cmd_deploy_control_sl.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ リファレンス \/ コマンド:コントロール SL をデプロイ ", 
"snippet" : "ファンクション : コマンドは、を開きます。 コミュニケーション 、 デプロイ 、および オペレーション タブ。 コール : ツール メニュー 詳細については、以下を参照してください。 タブ:デプロイタブ:コミュニケーションタブ:操作...", 
"body" : "ファンクション : コマンドは、を開きます。 コミュニケーション 、 デプロイ 、および オペレーション タブ。 コール : ツール メニュー 詳細については、以下を参照してください。 タブ:デプロイタブ:コミュニケーションタブ:操作" }, 
{ "title" : "タブ:デプロイ ", 
"url" : "_rtsl_dlg_deploy_deployment.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ リファレンス \/ タブ:デプロイ ", 
"snippet" : "製品のインストールとデプロイ [製品] インストールする製品 製品を選択すると、インストールされます CODESYS パッケージはタブの下部に表示されます。現在接続されているデバイスにインストールできるパッケージのみが表示されます。 [バージョン] インストールする選択した製品のバージョン。選択したバージョンの製品が既にインストールされている場合は、リストボックスの右側にメッセージが表示されます。 インストール インストールを開始します インストール済みパッケージ [製品] パッケージの製品名 [バージョン] パッケージのバージョン インストール済みイメージ [製品] 関連製品 (ランタイム、...", 
"body" : "製品のインストールとデプロイ [製品] インストールする製品 製品を選択すると、インストールされます CODESYS パッケージはタブの下部に表示されます。現在接続されているデバイスにインストールできるパッケージのみが表示されます。 [バージョン] インストールする選択した製品のバージョン。選択したバージョンの製品が既にインストールされている場合は、リストボックスの右側にメッセージが表示されます。 インストール インストールを開始します インストール済みパッケージ [製品] パッケージの製品名 [バージョン] パッケージのバージョン インストール済みイメージ [製品] 関連製品 (ランタイム、セープランタイム、Edge Gateway、タイムプロバイダー) イメージバージョン 画像のバージョン アーキテクチャ 画像のアーキテクチャ。これは、コントローラーとコンテナーエンジンが複数のアーキテクチャーをサポートしている場合に関係します 使用者 このイメージを使用するインスタンスのリスト " }, 
{ "title" : "タブ:コミュニケーション ", 
"url" : "_rtsl_dlg_deploy_communication.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ リファレンス \/ タブ:コミュニケーション ", 
"snippet" : "ログイン IP アドレス 接続しているコントローラーのIPアドレス。 あるいは、コントローラーのホスト名をここで使用することもできます。ホスト名も IP アドレスもわからない場合は、を使用して使用可能なデバイスを表示できます スキャン コマンド。これで、MAC アドレスを使用してデバイスを見つけることができます。 これらの情報がまったくわからない場合は、コントローラに直接接続してホスト名または IP アドレスを確認する必要があります。 ポート 接続に使用するポート スキャン を開きます 使用可能なデバイス ダイアログネットワーク上に表示されているデバイスが表示されます。 [ユーザー名] コント...", 
"body" : "ログイン IP アドレス 接続しているコントローラーのIPアドレス。 あるいは、コントローラーのホスト名をここで使用することもできます。ホスト名も IP アドレスもわからない場合は、を使用して使用可能なデバイスを表示できます スキャン コマンド。これで、MAC アドレスを使用してデバイスを見つけることができます。 これらの情報がまったくわからない場合は、コントローラに直接接続してホスト名または IP アドレスを確認する必要があります。 ポート 接続に使用するポート スキャン を開きます 使用可能なデバイス ダイアログネットワーク上に表示されているデバイスが表示されます。 [ユーザー名] コントローラーへのログインに使用するアカウント パスワード ログインに使用するアカウントのパスワード ステータス 現在の接続ステータス 接続 上記で指定したパラメータを使用してコントローラへの接続を確立します 接続解除 現在の接続を切断します キーベースのログイン キーに基づく SSH ログイン : 選択した SSH キーの使用を有効にします パスフレーズ オプション。選択した SSH キーのパスフレーズ キーファイル 設定済みの SSH キーを含むリストボックス キーファイルを追加 を開きます ランタイム・デプロイ・ツール¶ オプション。そこに SSH キーを追加できます。 デバイス情報 再起動 コントローラーを再起動します ダイアログ: 使用可能なデバイス トップ入力フィールド IP アドレスまたは MAC アドレスのフィルタ [キャンセル] ダイアログを閉じます 再スキャン スキャン処理を再び開始します OK 一覧からエントリを選択すると、その IP アドレスが IP アドレス 外部ダイアログのフィールド。 " }, 
{ "title" : "タブ:操作 ", 
"url" : "_rtsl_dlg_deploy_operation.html", 
"breadcrumbs" : "CODESYS Control \/ Linux ベースのランタイム システム \/ リファレンス \/ タブ:操作 ", 
"snippet" : "[サービス] すべて開始 リストされているすべてのサービスを開始します すべて停止 リストされているすべてのサービスを停止します [選択を開始] 選択したサービスを開始します 選択を停止 選択したサービスを停止します [製品] サービスの名前 状態 サービスの現在のステータス リフレッシュ すべての要素の最新の状態を取得し、テーブルを更新します 複製 現在選択されているサービスに基づいて新しいインスタンスを作成します [エクスポート] ZIP 形式のエクスポートファイルを作成します。これには現在選択されているインスタンスが含まれます。 [インポート] 以前に生成されたエクスポートファイルをイン...", 
"body" : "[サービス] すべて開始 リストされているすべてのサービスを開始します すべて停止 リストされているすべてのサービスを停止します [選択を開始] 選択したサービスを開始します 選択を停止 選択したサービスを停止します [製品] サービスの名前 状態 サービスの現在のステータス リフレッシュ すべての要素の最新の状態を取得し、テーブルを更新します 複製 現在選択されているサービスに基づいて新しいインスタンスを作成します [エクスポート] ZIP 形式のエクスポートファイルを作成します。これには現在選択されているインスタンスが含まれます。 [インポート] 以前に生成されたエクスポートファイルをインポートするためのダイアログを開きます VPLC すべて開始 リストされているすべての VPLC を起動します すべて停止 リストされているすべての VPLC を停止します [選択を開始] 選択した VPLC を起動します 選択を停止 選択した VPLC を停止します インスタンス VPLC の名前 状態 高性能液体クロマトグラフィーのステータス [製品] VPLC のタイプ (ランタイム、セープランタイム、エッジゲートウェイ、タイムプロバイダー) 依存関係 選択したインスタンスが依存する他のインスタンス。これらの他のインスタンスは、選択したインスタンスの前に起動され、選択したインスタンスの後に停止されます。 を開きます [新規インスタンスを追加] ダイアログ 個々のインスタンスまたはすべてのインスタンスを削除します。 実行中のインスタンスは削除できません。「Purge」はすべてのインスタンスとインストールされているイメージを削除します すべての要素の現在の状態を更新します [アクション] 選択した要素に応じて、異なるコマンドが表示されます。 ログを表示 各要素のログを表示します ブートアプリケーションを無効にする ランタイムのブートアプリケーションを無効にします WBM を開く 開きます CODESYS ブラウザでの Web ベースの管理 [設定] 選択した要素のすべてのオプションの動的リスト。各オプションの詳細な説明は、この章にあります 構成と拡張[保存] コマンドは、設定が変更され、構成でエラーが検出されなくなるとすぐに有効になります。 新しいインスタンスを追加 [名前] 新しいインスタンスの名前 [フィルター] 使用可能な画像のリストをフィルタリングする 画像 使用可能な画像のリスト OK 画像を選択し、有効な名前を指定すると有効になります。新しいインスタンスが作成され、表示されます。 [キャンセル] ダイアログを閉じます。変更は行われません。 NIC の設定 使用可能なアダプター 現在システムで使用可能なアダプター。アダプタが既にインスタンスにマップされている場合、このリストに短いメモが表示されます [インスタンスにマッピング] このアダプタが現在選択されているインスタンスにマップされているかどうかを判断します アダプター 変更できません。選択したアダプタの名前が表示されます。 IP コンテナ内のこのアダプタのIPアドレス。この値を指定する場合、マスクも指定する必要があります。 マスク コンテナ内のこのアダプターのネットワークマスク。この値を指定する場合、IP アドレスも指定する必要があります。 " }, 
{ "title" : "Windows ベースのランタイム システム ", 
"url" : "_rtsl_windows_runtime_systems.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "入門 ", 
"url" : "_rtsl_first_steps_win.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 ", 
"snippet" : "この章では、デバイスをコミッショニングする方法を学びます。 CODESYS SL ランタイムを制御し、小規模から開始する CODESYS アプリケーション、およびコントローラーのライセンスを取得します。...", 
"body" : "この章では、デバイスをコミッショニングする方法を学びます。 CODESYS SL ランタイムを制御し、小規模から開始する CODESYS アプリケーション、およびコントローラーのライセンスを取得します。 " }, 
{ "title" : "コントローラーへのランタイムのインストール ", 
"url" : "_rtsl_first_steps_win.html#UUID-965da881-e78f-71a0-a964-5d8b615dfdfc", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ コントローラーへのランタイムのインストール ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "の取り付け CODESYS Control RTE ", 
"url" : "_rtsl_first_steps_win.html#UUID-965da881-e78f-71a0-a964-5d8b615dfdfc_section-idm43305899023692", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ コントローラーへのランタイムのインストール \/ の取り付け CODESYS Control RTE ", 
"snippet" : "実行可能ファイル Setup_CODESYSControlRTE<32|64>V3.<version>setup.exe インストール パッケージ内の「セットアップ」は、以下で言及されています。セットアップにより、パッケージに含まれている使用可能なすべてのドライバーがインストールされます。セットアップは、インストールするプラットフォームのタイプを決定し、構成ファイルを変更します CODESYSControl.cfg 自動的に（確認後）。 デフォルトでは、の作業ディレクトリ CODESYS Control RTE は C:\\ProgramData\\CODESYS\\CODESYSControlRT...", 
"body" : "実行可能ファイル Setup_CODESYSControlRTE<32|64>V3.<version>setup.exe インストール パッケージ内の「セットアップ」は、以下で言及されています。セットアップにより、パッケージに含まれている使用可能なすべてのドライバーがインストールされます。セットアップは、インストールするプラットフォームのタイプを決定し、構成ファイルを変更します CODESYSControl.cfg 自動的に（確認後）。 デフォルトでは、の作業ディレクトリ CODESYS Control RTE は C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 . 要件： をインストールするシステムの CPU コアの数がわかっている。 CODESYS Control RTE .システムで上記の準備が完了していること。 (CPU の正確な指定は、Windows コントロール パネルの [システム] ダイアログに表示されます。その情報を使用して、インターネットを使用して物理 CPU コアの数を調べることができます。) ハードウェア構成に関する情報にも注意してください。 ハードウェア構成 — 推奨事項インストール パッケージをコンピュータにロードします。 CODESYS Control RTE で利用可能です CODESYS Store International シングルライセンス版として。 ファイルを実行してインストールを開始します CODESYS Control RTE <32|64> <version>.exe .デフォルト設定でウィザードに従います。 マルチコア CPU 使用率 ダイアログが表示されます。 結果： インストール ウィザードは、物理プロセッサ コアの総数を検出しようとします。 コアの合計 .この情報を確認し、必要に応じて修正してください。の コア RTE 、専用に予約するプロセッサ コアの数を定義します。 CODESYS Control RTE タスク。その結果、これらのコアは Windows (「AMP」モード) では使用できなくなりました。 注: すでに指定されている番号 (例: 6 ) は、セットアップの単なる提案です。通常、セットアップはシステムの物理 CPU コアの数を正しく検出できます。 Windows によって表示される CPU コアは、リアルタイム システムの操作に適していない \"論理\" CPU コア (\"ハイパースレッディング コア\") である場合もあります。また、次の指示に従ってください。 BIOS 設定でハイパースレッディングを無効にする必要があります。 .ハイパースレッディングなどの CPU 機能は、リアルタイムの動作に悪影響を及ぼします。 システムのブート構成を変更することにより、セットアップが RTE 用に CPU コアを予約する必要があることを、後でダイアログで確認する必要があります。これを行うとき、起動オプション numproc <物理プロセッサの数を引いた値に設定されています 1 >。クリック 次 指定されたコア数を確認します。 次に、 起動オプションが変更されます PC のブート構成への注目された変更に関する情報を含むダイアログ。 クリック 次 に続く 起動オプションを設定しますか? ダイアログ。 結果： の中に 起動オプションの設定 ダイアログで、セットアップがシステムの開始構成に次の変更を適用するかどうかを決定します。 Windows で使用できる CPU コア数の制限。起動オプションを使用して \" numproc \" に <number of physical cores> - 1 . プロセッサ機能「データ実行防止」の無効化。 プロセッサー機能「物理アドレス拡張 (PAE)」の無効化。 プロセッサ機能の「データ実行防止」および「PAE」は、必ずしも無効にする必要はありません。起動構成を手動で編集することにより、Windows のコア数のみを制限できます。ただし、この種の構成はテストされていません。 CODESYS . 起動オプション numproc この構成で RTE が機能するには、絶対に必要です。したがって、ここでセットアップでこのオプションを設定しないことにした場合は、オプションを手動で有効にする必要があります。 セットアップが今説明した変更を適用する必要がある場合は、 はい . これらの変更を後で手動で実行する場合は、 いいえ . クリック 次 に続く RTEのターゲットタイプ ダイアログ。 結果： バージョンあり CODESYS 3.5 SP17 では、「コントロール」と「ソフトモーション」のデバイス タイプを区別する必要がなくなりました。デバイス タイプ「コントロール」には、以前は SoftMotion デバイス用に予約されていたすべての機能も含まれています。この区別は、互換性の理由からのみ存在するようになりました。新しいプロジェクトでは、「コントロール」を使用することをお勧めします。 の中に RTEのターゲットタイプ ダイアログで、インストールする RTE タイプを選択します。 CODESYS コントロール RTE また CODESYS ソフトモーション RTE . インストールの種類は、アプリケーションとライセンスによって異なります。購入して使用したい場合のみ「SoftMotion」を選択してください。 CODESYS ソフトモーション RTE ライセンス。そうでない場合、RTE は時間制限付きのデモ モードで開始されます。次に、次で 機能を選択 ダイアログで、インストールする実際の機能の選択を変更できます。 CODESYS ソフトモーション RTE と CodeMeter® for Windows . 両方を手動で切り替えることができます CODESYS Control RTE 構成ファイルを編集して後でタイプする CODESYSControl.cfg .これを行うには、構成ファイルに次の行を入力します。 CODESYSControl.cfg : [SysTarget] TargetType=0x1006 DeviceName=CODESYS SoftmotionRTE V3 これらのエントリを削除する (またはセミコロンを前に付ける) と、 CODESYS Control RTE また。 の中に 機能を選択 ダイアログで、インストールする機能を選択します。 アクセスする場合は、ファイアウォールを開きます CODESYS Control RTE 他のコンピュータから。これは、たとえば、との通信に必要です。 CODESYS 、 CODESYS OPC、およびイーサネットベースのフィールドバスで作業する場合。 結果： 実行ステップの 1 つで、 CODESYS Control RTE ハードウェア プロファイルを作成してアクティブ化することで増加させる必要があります。これを確認すると、電源オプションの [高パフォーマンス] ([コントロール パネル] -> [電源オプション]) が選択され、CPU レートが 100% に設定されます。 インストールが正常に終了すると、 画面のステータスバーに記号が表示されます。開くことができます CODESYS Control RTE メニューを右クリックします。 構成ファイル CODESYSControl.cfg 自動的に適応されます。 の現在のデバイスの説明があるかどうかを確認します。 CODESYS Control RTE あなたの CODESYS Development System .このインストールは、使用するために必要です CODESYS Control RTE と CODESYS . (開発システムは、RTE が実行されているターゲット システム上にあるとは限りません。) 後で変更が必要になったなどの理由でデバイス記述を再インストールする必要がある場合は、 CODESYS デバイス リポジトリを開き、 インストール 指図。 RTE を適合させるための記述ファイル ( .devdesc.xml ) は、インストール ディレクトリにセットアップによって生成されます。 Others . インストールの最後に必要な再起動を必ず実行してください。 詳細については、次を参照してください。 デバイスのインストール " }, 
{ "title" : "の構成の適応 CODESYS Control RTE ", 
"url" : "_rtsl_first_steps_win.html#UUID-965da881-e78f-71a0-a964-5d8b615dfdfc_section-idm43305899148826", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ コントローラーへのランタイムのインストール \/ の取り付け CODESYS Control RTE \/ の構成の適応 CODESYS Control RTE ", 
"snippet" : "必要条件: 上記のようにインストールを実行済みであること。インストールしました CODESYS . 次のオプションが可能です。 インストール後に利用可能な構成でデバイスを使用します: 以下の手順に進みます。 CODESYS Control RTE \"。 ローカルにインストールされた CODESYS Control RTE ： クリック CODESYS Control RTE シンボル PCのシステムトレイに。クリック PLC 構成 の中に CODESYS Control RTE メニューをクリックして構成エディターを開きます。必要に応じて設定を編集します。 使用 CODESYS Control...", 
"body" : "必要条件: 上記のようにインストールを実行済みであること。インストールしました CODESYS . 次のオプションが可能です。 インストール後に利用可能な構成でデバイスを使用します: 以下の手順に進みます。 CODESYS Control RTE \"。 ローカルにインストールされた CODESYS Control RTE ： クリック CODESYS Control RTE シンボル PCのシステムトレイに。クリック PLC 構成 の中に CODESYS Control RTE メニューをクリックして構成エディターを開きます。必要に応じて設定を編集します。 使用 CODESYS Control RTE リモート PC にインストールされます。クリック CODESYS Control RTE シンボル PCのシステムトレイに。の中に CODESYS Control RTE メニュー、クリック リモートPLC .開くダイアログで、リモート PLC の接続設定を構成します。 設定は設定ファイルに保存されます CODESYSControl.cfg ディレクトリ内 C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 . " }, 
{ "title" : "の取り付け CODESYS Control Win ", 
"url" : "_rtsl_first_steps_win.html#UUID-965da881-e78f-71a0-a964-5d8b615dfdfc_section-idm4555504420804833058987427815", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ コントローラーへのランタイムのインストール \/ の取り付け CODESYS Control Win ", 
"snippet" : "インストールが成功したら、 CODESYS Control Win コンピューター上でサービスとして実行されます。次の方法でインストールを取得します。 をインストールしました CODESYS Development System .その結果、 CODESYS Control Win 期間限定のバージョンが PC にインストールされます。 ダウンロードしました CODESYS Control Win から CODESYS セットアップ ファイルを保存して実行し、インストールします。...", 
"body" : "インストールが成功したら、 CODESYS Control Win コンピューター上でサービスとして実行されます。次の方法でインストールを取得します。 をインストールしました CODESYS Development System .その結果、 CODESYS Control Win 期間限定のバージョンが PC にインストールされます。 ダウンロードしました CODESYS Control Win から CODESYS セットアップ ファイルを保存して実行し、インストールします。 " }, 
{ "title" : "ランタイム システムの起動 ", 
"url" : "_rtsl_start_runtime-1816376.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ ランタイム システムの起動 ", 
"snippet" : "ノート : ランタイム システムを操作するには、PC に有効なライセンスをインストールする必要があります。そうでない場合、コントローラは完全に機能しますが、時間制限のあるデモ モードで起動します。 ランタイム システムの場合、これらはデバイス ライセンスです。これらのライセンスは、License Manager でアクティブ化します。 詳細については、次を参照してください。 製品のライセンス...", 
"body" : "ノート : ランタイム システムを操作するには、PC に有効なライセンスをインストールする必要があります。そうでない場合、コントローラは完全に機能しますが、時間制限のあるデモ モードで起動します。 ランタイム システムの場合、これらはデバイス ライセンスです。これらのライセンスは、License Manager でアクティブ化します。 詳細については、次を参照してください。 製品のライセンス " }, 
{ "title" : "CODESYS Control RTE ", 
"url" : "_rtsl_start_runtime-1816376.html#UUID-065101d1-259a-9d21-37c7-74cc493827e0_section-idm43463171121528", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ ランタイム システムの起動 \/ CODESYS Control RTE ", 
"snippet" : "[開始] CODESYS Control RTE コマンドを使用して PLC を起動します。 で CODESYS Control RTE メニュー ( )。 システムトレイのシンボルが表示されない場合は、インストールが正しいことを確認してください。ファイルをダブルクリックして CODESYSControlRTESysTray.exe のインストールディレクトリにあります CODESYS Control RTE 、システムトレイでユーザーインターフェースの表示を手動で開始できます。 システムトレイのシンボルが次のように変わります 起動後 CODESYS Control RTE 。 次の手順では、...", 
"body" : "[開始] CODESYS Control RTE コマンドを使用して PLC を起動します。 で CODESYS Control RTE メニュー ( )。 システムトレイのシンボルが表示されない場合は、インストールが正しいことを確認してください。ファイルをダブルクリックして CODESYSControlRTESysTray.exe のインストールディレクトリにあります CODESYS Control RTE 、システムトレイでユーザーインターフェースの表示を手動で開始できます。 システムトレイのシンボルが次のように変わります 起動後 CODESYS Control RTE 。 次の手順では、簡単なものを作成する方法について説明します CODESYS 上で実行するアプリケーション CODESYS Control RTE 。 " }, 
{ "title" : "CODESYS Control Win ", 
"url" : "_rtsl_start_runtime-1816376.html#UUID-065101d1-259a-9d21-37c7-74cc493827e0_section-idm43463171151726", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ ランタイム システムの起動 \/ CODESYS Control Win ", 
"snippet" : "の場合 CODESYS Control Win これはデバイスライセンスです。このライセンスはライセンスマネージャでアクティベートします。 詳細については、以下を参照してください。 製品のライセンス 自動起動: もし CODESYS Control Win システムの起動時に自動的に起動するようになったら、以下のようにサービスを設定する必要があります。Windows を開きます。 サービス コンピューターのスタートメニューにあるシステムダイアログ。一覧からサービスを選択します。 CODESYS Control Win V3 そして、を開きます。 [プロパティ] コンテキストメニューのダイアログ...", 
"body" : "の場合 CODESYS Control Win これはデバイスライセンスです。このライセンスはライセンスマネージャでアクティベートします。 詳細については、以下を参照してください。 製品のライセンス 自動起動: もし CODESYS Control Win システムの起動時に自動的に起動するようになったら、以下のようにサービスを設定する必要があります。Windows を開きます。 サービス コンピューターのスタートメニューにあるシステムダイアログ。一覧からサービスを選択します。 CODESYS Control Win V3 そして、を開きます。 [プロパティ] コンテキストメニューのダイアログ。 将軍 タブ、設定 スタートタイプ へ 自動 。 手動起動: システムバーで、右クリックします シンボルまたは シンボルとクリック PLC を起動します。 メニューで。システムバーにシンボルが表示されない場合は、インストールが正しく行われ、システムバーの表示が開始されていることを確認してください。追記:ファイルをダブルクリックしてください。 CODESYSControlSysTray.exe のインストールディレクトリにあります GatewayPLC 、システムトレイでユーザーインターフェースの表示を手動で開始できます。 正常に起動すると、 CODESYS Control Win システムバーのシンボルが次のように変わります。 または 。 " }, 
{ "title" : "のダウンロードと起動 CODESYS コントローラ上のアプリケーション ", 
"url" : "_rtsl_load_and_start_application_win.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ のダウンロードと起動 CODESYS コントローラ上のアプリケーション ", 
"snippet" : "要件: コントローラーが開始されている。 の CODESYS 、標準プロジェクトを作成します: をクリックします ファイル→新規プロジェクト .の中に 新しい計画 ダイアログで、 標準プロジェクト テンプレートを作成し、名前と場所を指定します。次に、 標準プロジェクト ダイアログで、それぞれのコントローラーを選択します。 デバイス ツリー ( デバイス 新しいプロジェクトのビュー) には、コントローラー (コントローラー) のエントリがあります。 デバイス （...） )、その下に POU 付きのアプリケーション ( PLC_PRG (PRG) そしてタスク 主な任務 これは PLC_PRG ...", 
"body" : "要件: コントローラーが開始されている。 の CODESYS 、標準プロジェクトを作成します: をクリックします ファイル→新規プロジェクト .の中に 新しい計画 ダイアログで、 標準プロジェクト テンプレートを作成し、名前と場所を指定します。次に、 標準プロジェクト ダイアログで、それぞれのコントローラーを選択します。 デバイス ツリー ( デバイス 新しいプロジェクトのビュー) には、コントローラー (コントローラー) のエントリがあります。 デバイス （...） )、その下に POU 付きのアプリケーション ( PLC_PRG (PRG) そしてタスク 主な任務 これは PLC_PRG を呼び出します)。 の PLC_PRG 、簡単なプログラム (たとえば、カウンター) を作成します。 PROGRAM PLC_PRG\nVAR\n iCount: INT;\nEND_VAR\n\niCount := iCount+1; コントローラへの接続を確立します。これを行うには、 通信設定 デバイスエディタのタブ。をダブルクリックして開くことができます。 デバイス （...） デバイス ツリーのエントリ。 通常、ゲートウェイはすでにアクティブになっています。そうでない場合は、ステータスを確認し、必要に応じてゲートウェイを明示的に開始します。次に、をクリックします スキャンネットワーク に コミュニケーション タブ。 の デバイスを選択 ダイアログが開き、検出されたデバイスが表示されます。コントローラーが見つからない場合は、コントローラーが正しくインストールされ、開始されていることを確認してください。 検出されたコントローラを選択し、 わかった . コントローラが見つからない場合は、次のことを確認してください。 上で 通信設定 タブの デバイス → オプション メニューで、 ターゲット ID によるネットワーク スキャンのフィルタリング オプション。 デバイスが今表示されている場合は、間違っています TargetID 。コンポーネント SysTargetOEM 正しくロードされていない可能性があります。 デバイスはネットワークに接続されていますか？ デフォルトでは、UDPを介してデバイスとの通信が行われます。この通信方法を使用する場合、デバイスはホストと同じサブネットワークに存在する必要があります。どちらのデバイスにも、まったく同じ構成済みのネットワークマスクが必要です。 起動時に、ランタイムシステムのメッセージのネットワーク設定を確認できます。たとえば、次のようになります。 1287759127: Cmp=CmpBlkDrvUdp, Class=1, Error=0, Info=6, pszInfo=Network interface: <ipaddress>192.168.101.41<\/ipaddress> <subnetmask>255.255.252.0<\/subnetmask> CODESYS このターゲットシステムで自身を認証し、通信チャネルを取得しようとします。接続が確立されます。 クリック オンライン→ログイン 。 アプリケーションのダウンロードを確認するダイアログが開きます。 ダウンロードを実行し、アプリケーションを起動します。アプリケーションはデバイス上で処理されます。 の中に PLC_PRG プログラムで、カウンタが動作しているかどうかを確認します。 " }, 
{ "title" : "コントローラのライセンス ", 
"url" : "_rtsl_license_controller_win.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ コントローラのライセンス ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "ライセンスの取得 ", 
"url" : "_rtsl_license_controller_win.html#UUID-3805d9ea-0c7b-2463-7ef4-1d99d0c4e100_section-idm234389354567343", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ コントローラのライセンス \/ ライセンスの取得 ", 
"snippet" : "ダウンロードできます CODESYS Control 製品から CODESYSストアインターナショナル または CODESYSストア北米 。...", 
"body" : "ダウンロードできます CODESYS Control 製品から CODESYSストアインターナショナル または CODESYSストア北米 。 " }, 
{ "title" : "ローカルライセンス ", 
"url" : "_rtsl_license_controller_win.html#UUID-3805d9ea-0c7b-2463-7ef4-1d99d0c4e100_section-idm4588328499004833054120306755", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ コントローラのライセンス \/ ローカルライセンス ", 
"snippet" : "ライセンスは、USB ドングルまたはソフト コンテナにインストールできます。ソフト コンテナを使用する場合、ライセンスはアクティベーション中にデバイスにロックされ、このデバイスでのみアクティベートまたは復元できます。 要件: 開発システムには CODESYS Development System インターネットにアクセスでき、デバイスに接続されています。 開ける CODESYS 。 標準プロジェクトを作成します。 デバイスツリーでデバイスを更新します。 クリック ツール → ライセンスマネージャー 開く CODESYS ライセンス マネージャー。 選択する 端末 ウィザードで、を選択します ド...", 
"body" : "ライセンスは、USB ドングルまたはソフト コンテナにインストールできます。ソフト コンテナを使用する場合、ライセンスはアクティベーション中にデバイスにロックされ、このデバイスでのみアクティベートまたは復元できます。 要件: 開発システムには CODESYS Development System インターネットにアクセスでき、デバイスに接続されています。 開ける CODESYS 。 標準プロジェクトを作成します。 デバイスツリーでデバイスを更新します。 クリック ツール → ライセンスマネージャー 開く CODESYS ライセンス マネージャー。 選択する 端末 ウィザードで、を選択します ドングル また ソフトコンテナ 、デバイスによって異なります。 の デバイスを選択 ダイアログが開きます。 それぞれのデバイスを選択します。 の ライセンス マネージャー ダイアログが開きます。 容器 デバイス上のソフトコンテナまたはセキュリティキーの名前が表示されます。 製品 窓。 を選択 ライセンスのインストール 左下のアクション。 The <ターゲットデバイス> <コンテナ名>にライセンスをインストールする– [操作]を選択します ウィザードが起動します。 を選択 ライセンスのアクティベート オプション。指定する チケットID そしてクリック 次 . ライセンスがアクティブ化されます。 " }, 
{ "title" : "バックアップと復元 CODESYS ライセンス ", 
"url" : "_rtsl_backup_restore_wibu_win.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ バックアップと復元 CODESYS ライセンス ", 
"snippet" : "これらの指示は、 CODESYS 仮想制御製品ファミリ。...", 
"body" : "これらの指示は、 CODESYS 仮想制御製品ファミリ。 " }, 
{ "title" : "Codemeter Embedded のライセンス ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4622936815712034049201310732", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ バックアップと復元 CODESYS ライセンス \/ Codemeter Embedded のライセンス ", 
"snippet" : "CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ ライセンスのバックアップと復元...", 
"body" : "CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ ライセンスのバックアップと復元 " }, 
{ "title" : "ライセンスのバックアップ ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4641146992569634049209836102", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ バックアップと復元 CODESYS ライセンス \/ Codemeter Embedded のライセンス \/ ライセンスのバックアップ ", 
"snippet" : "から接続を確立します CODESYS コントローラーに。 デバイス ツリーでコントローラーを選択し、 ファイル タブ。 右側のウィンドウで、更新アイコン ( ）。 コントローラで利用可能なファイルが表示されます。 左側のウィンドウで、バックアップを保存するディレクトリを選択します。 右側のウィンドウで、 cmact_licenses ディレクトリをクリックし、 ボタン。 ライセンス ディレクトリのバックアップ コピーがコンピュータ上に作成されます。 バックアップ コピーが正常に作成されたことを確認します。...", 
"body" : "から接続を確立します CODESYS コントローラーに。 デバイス ツリーでコントローラーを選択し、 ファイル タブ。 右側のウィンドウで、更新アイコン ( ）。 コントローラで利用可能なファイルが表示されます。 左側のウィンドウで、バックアップを保存するディレクトリを選択します。 右側のウィンドウで、 cmact_licenses ディレクトリをクリックし、 ボタン。 ライセンス ディレクトリのバックアップ コピーがコンピュータ上に作成されます。 バックアップ コピーが正常に作成されたことを確認します。 " }, 
{ "title" : "ライセンスの復元 ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm451020213344483404921010438", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ バックアップと復元 CODESYS ライセンス \/ Codemeter Embedded のライセンス \/ ライセンスの復元 ", 
"snippet" : "次のステップ 6 の手順を実行すると、データが失われる可能性があることに注意してください。したがって、これらの手順をよく読んでください。 から接続を確立します CODESYS コントローラーに。 デバイス ツリーでコントローラーを選択し、 ファイル タブ。 右側のウィンドウで、更新アイコン ( ）。 コントローラで利用可能なファイルが表示されます。 右側のウィンドウで、ターゲット ディレクトリを選択します。これは最上位のディレクトリである必要があります ( ストレージの場所 : \/ ) 左側のウィンドウで、コンピュータ上に以前に作成したバックアップ コピーを選択し、 ボタン。 バックアップ コ...", 
"body" : "次のステップ 6 の手順を実行すると、データが失われる可能性があることに注意してください。したがって、これらの手順をよく読んでください。 から接続を確立します CODESYS コントローラーに。 デバイス ツリーでコントローラーを選択し、 ファイル タブ。 右側のウィンドウで、更新アイコン ( ）。 コントローラで利用可能なファイルが表示されます。 右側のウィンドウで、ターゲット ディレクトリを選択します。これは最上位のディレクトリである必要があります ( ストレージの場所 : \/ ) 左側のウィンドウで、コンピュータ上に以前に作成したバックアップ コピーを選択し、 ボタン。 バックアップ コピーがコントローラにコピーされます。 同じ名前のディレクトリがすでに存在する場合は、そこに含まれるファイルを上書きするように求めるメッセージが表示されます。 注意: 「はい」を選択すると、バックアップ ディレクトリ内と同じ名前のすべてのファイルが既存のディレクトリから削除されます。同じ名前であっても、内容が同じであるとは限りません。したがって、必要なファイルを誤って上書きしないように注意してください。 バックアップ コピーが正常に転送されたら、コントローラーを再起動します。 " }, 
{ "title" : "コードメーター ランタイムのライセンス ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4592433740225634049202010617", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ バックアップと復元 CODESYS ライセンス \/ コードメーター ランタイムのライセンス ", 
"snippet" : "CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control Win SL CODESYS Control RTE SL...", 
"body" : "CODESYS Control​ for Linux CODESYS Control for Linux ARM CODESYS Control for Linux ARM64 CODESYS Control Win SL CODESYS Control RTE SL " }, 
{ "title" : "ライセンスのバックアップ ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4582704430054434049230836628", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ バックアップと復元 CODESYS ライセンス \/ コードメーター ランタイムのライセンス \/ ライセンスのバックアップ ", 
"snippet" : "CodeMeter Runtime を使用する場合、バックアップを作成する必要はありません。...", 
"body" : "CodeMeter Runtime を使用する場合、バックアップを作成する必要はありません。 " }, 
{ "title" : "ライセンスの復元 ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4548752769854434049231197546", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ バックアップと復元 CODESYS ライセンス \/ コードメーター ランタイムのライセンス \/ ライセンスの復元 ", 
"snippet" : "ライセンスを復元する ライセンス要求ファイルの作成 で CODESYS 、ライセンスマネージャーを開きます。 次の 2 つのダイアログで、 デバイス そして ソフトコンテナ 。 から接続を確立します CODESYS ライセンスを復元するコントローラにコピーします。 クリック ライセンスのインストール 、 選択する ライセンスのリクエスト をクリックして、 次 。 もし ソフトウェアベンダー フィールドが空の場合は、ファームコードを使用できます。ファームコードの取得方法は「ファームコードの取得」で説明します。 ライセンスをインストールするコンテナを選択し、ライセンス要求ファイルをコンピュータ上で...", 
"body" : " ライセンスを復元する ライセンス要求ファイルの作成 で CODESYS 、ライセンスマネージャーを開きます。 次の 2 つのダイアログで、 デバイス そして ソフトコンテナ 。 から接続を確立します CODESYS ライセンスを復元するコントローラにコピーします。 クリック ライセンスのインストール 、 選択する ライセンスのリクエスト をクリックして、 次 。 もし ソフトウェアベンダー フィールドが空の場合は、ファームコードを使用できます。ファームコードの取得方法は「ファームコードの取得」で説明します。 ライセンスをインストールするコンテナを選択し、ライセンス要求ファイルをコンピュータ上で保存する場所を選択します。クリック 仕上げる 。 ライセンス更新ファイルのダウンロード を開きます。 ライセンスセントラル WebDepot 復元したいチケットIDを指定します。クリック 次 。 クリック ライセンスを復元する 。 右下にある をクリックします。 ファイルベースのライセンス転送 。 (ページに次のような記載がある場合 ライセンスの直接転送 場合は、すでに正しいページにアクセスしています)。 以前に作成したライセンス要求ファイルをアップロードし、クリックします。 リクエストをアップロードして今すぐ続行してください 。 クリック 今すぐライセンス更新ファイルをダウンロード ファイルをコンピュータに保存します。 ライセンスアップデートのインストール で CODESYS 、ライセンスマネージャーを開きます。 次の 2 つのダイアログで、 デバイス そして ソフトコンテナ 。 から接続を確立します CODESYS ライセンスを復元するコントローラにコピーします。 クリック ライセンスのインストール 、 選択する ライセンスのインストール をクリックして、 次 。 ライセンスをインストールするコンテナを選択し、以前にダウンロードしたアップデート ファイル (拡張子: .WibuCmRaU ）。 クリック 仕上げる 。 数秒後、ライセンスがライセンス マネージャーに表示されます。 " }, 
{ "title" : "確定コードの取得 ", 
"url" : "_rtsl_backup_restore_wibu_win.html#UUID-c2edf34f-2d6b-467f-a5e4-e83452e08138_section-idm4641146913656034049243306333", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 入門 \/ バックアップと復元 CODESYS ライセンス \/ コードメーター ランタイムのライセンス \/ 確定コードの取得 ", 
"snippet" : "を開きます。 ライセンスセントラル WebDepot 復元したいチケットIDを指定します。クリック 次 。 クリック ライセンスを復元する 。 右下にある をクリックします。 ファイルベースのライセンス転送 。 最初のポイントで指定した企業コードをコピーします。...", 
"body" : "を開きます。 ライセンスセントラル WebDepot 復元したいチケットIDを指定します。クリック 次 。 クリック ライセンスを復元する 。 右下にある をクリックします。 ファイルベースのライセンス転送 。 最初のポイントで指定した企業コードをコピーします。 " }, 
{ "title" : "構成と拡張 ", 
"url" : "_rtsl_configure_and_extend-1816377.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS Control Win V3 ", 
"url" : "_rtsl_windows_win_v3.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Win V3 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "動的コンポーネントの追加 ", 
"url" : "_rtsl_windows_win_v3_dynamic_components.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Win V3 \/ 動的コンポーネントの追加 ", 
"snippet" : "CODESYS Control Win 構成ファイルを使用して構成されます（ CODESYSControl.cfg ）。 インストールパスのcfgファイルには、実際の構成ファイルへの参照が含まれています CODESYSControl.cfg 作業ディレクトリ： [SysFile] Windows.WorkingDirectory=C:\\ProgramData\\CODESYS\\CODESYSControlWinV3x64\\801BFF8C 作業ディレクトリのcfgファイルに、必要な追加コンポーネント（ドライバ）を入力できます。次に、これらは常にロードされます CODESYS Control Wi...", 
"body" : "CODESYS Control Win 構成ファイルを使用して構成されます（ CODESYSControl.cfg ）。 インストールパスのcfgファイルには、実際の構成ファイルへの参照が含まれています CODESYSControl.cfg 作業ディレクトリ： [SysFile]\nWindows.WorkingDirectory=C:\\ProgramData\\CODESYS\\CODESYSControlWinV3x64\\801BFF8C 作業ディレクトリのcfgファイルに、必要な追加コンポーネント（ドライバ）を入力できます。次に、これらは常にロードされます CODESYS Control Win 再起動されます。 セクションに新しいコンポーネントを入力します [ComponentManager] 。すべてのコンポーネントエントリの数に欠落しているエントリがないことが重要です。 [ComponentManager]\n...\nComponent.6=SysCpuBreakpoints\nComponent.7=<Neue Komponente>\n... 追加できるコンポーネントを以下に示します。 " }, 
{ "title" : "オプションのフィールドバスアダプタのサポート ", 
"url" : "_rtsl_windows_win_v3_dynamic_components.html#UUID-8ec48f4e-4fbf-ff18-64cb-d07a65c567cc_id_e00e47aa45e147ec0a8646334522c52-id-035992cdebec2318c0a8646340efc345", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Win V3 \/ 動的コンポーネントの追加 \/ オプションのフィールドバスアダプタのサポート ", 
"snippet" : "CmpHilscherCIFX 運転者 このコンポーネントは、HilscherのNetXPCカードをサポートしています。このためには、の構成ファイルにコンポーネント「CmpHilscherCIFX」を入力するだけです。 CODESYS Control Win 次のように： [ComponentManager] Component.<n>=CmpHilscherCIFX 次に、アダプタをインストールした後、ドライバをインストールする必要があります SysDrv3S.sys オペレーティングシステムを起動するとき。これはにあります CODESYS のインストールディレクトリ $\\GatewayPL...", 
"body" : "CmpHilscherCIFX 運転者 このコンポーネントは、HilscherのNetXPCカードをサポートしています。このためには、の構成ファイルにコンポーネント「CmpHilscherCIFX」を入力するだけです。 CODESYS Control Win 次のように： [ComponentManager]\nComponent.<n>=CmpHilscherCIFX 次に、アダプタをインストールした後、ドライバをインストールする必要があります SysDrv3S.sys オペレーティングシステムを起動するとき。これはにあります CODESYS のインストールディレクトリ $\\GatewayPLC\\Driver 32ビットWindowsオペレーティングシステムの場合、または $\\GatewayPLC\\Driver\\x64 64ビットWindowsオペレーティングシステムの場合。 注：Hilscher configurator SyConまたはSYCON.netとHilscherドライバーは、 CODESYS 。 CmpSoftingProfibus 運転者 このコンポーネントは、Softing Industrial AutomationGmbHのPROFIBUSマスターUSBインターフェースアダプターを使用する場合に必要です。 CODESYS IECアプリケーションで。これは、ランタイムシステムと、ドライバーライブラリで使用されるSoftingの独自のドライバーとの間のインターフェイスを表します。 IoDrvSoftingPROFIusb 。の CODESYS 、デバイスを追加すると、このライブラリはライブラリマネージャーに自動的に統合されます PROFIusb デバイスツリー内。その結果、を使用および構成できます CODESYS PROFIBUSマスターとしてのWindowsPC上のランタイムシステム。詳細については、以下を参照してください。 PROFIBUS用のUSBインターフェースの追加 CmpBACnet 運転者 このコンポーネントは、のBACnetIPリンクを使用する場合に必要です。 CODESYS Control Win 。構成ファイルには、次のエントリが必要です。 [ComponentManager]\nComponent.<n>=CmpBACnet CmpPCANBasicDrv 運転者 このコンポーネントは、PCAN 基本 API を使用して Peak CAN ハードウェアのリンクを実装します。インストール手順については、オンライン ヘルプを参照してください。構成ファイルのエントリは必要ありません。 CmpCAACanL2 運転者 このコンポーネントは、CANメッセージを送受信するためのハードウェアに依存しないインターフェイスを提供します。オプションの構成ファイルエントリ： [CmpCAACanL2]\n;If setting PersistentBaudrate is enabled (0: disabled; 1: enabled)\n;the baudrate will be stored into Net.X.DefaultBaudrate (where X equals NetId) when opening the driver.\nPersistentBaudrate=1\n;Default baudrate for CAN network 0. This baudrate will be used when the network is opened (e.g from CmpBlkDrvCan or CANopen) with the baudrate set to 0.\nNet.0.DefaultBaudrate=1000 構成ファイルでは、CANネットワーク（物理CAN接続）ごとに標準のボーレートを保存できます。この標準ボーレートは、CL2機能の場合に常に使用されます DriverOpenH ボーレートで呼び出されます 0 ドライバーはまだ開いていません。この構成ファイルのエントリが欠落している場合、ボーレートが不明であるため、引用されたケースでエラーが発行されます。 このエントリは、関数に関連して特に役立ちます PersistenBaudrate これはデフォルトで無効になっています。もしも PersistentBaudrate=1 、 それから CODESYS 関数を使用します CmpSettings の呼び出しごとに特定のボーレートでこのボーレートを設定ファイルに書き込む DriverOpenH 。これには、たとえば、エントリが Net.0.DefaultBaudrate 変更されます。これは、コントローラーがCANブロックドライバーを介して通信する場合に特に便利です。ボーレートが 0 （（ 0.Baud rate = 0 ） の CmpBlkDrvCanServer 、次に、ユーザーは、プロジェクトのボーレートを変更し、アプリケーションをダウンロードして、コントローラーを再起動することにより、ブロックドライバー通信のボーレートを変更できます。 CmpCAASdoClient 運転者 このコンポーネントは、CANopenSDOクライアントプロトコルを実装します。オプションの構成エントリ： [CmpCAASdoClient]\nMaxSegmentsPerCycle=0 ; for block download: maximum of sent segments per cycle; 0 means infinity ここで、ブロック転送でサイクルごとに送信されるCANメッセージの数を減らすことができます。これは、コントローラーに同じIDの一連の多数のCANフレームに問題がある場合に必要です。ただし、これによりパフォーマンスも制限され、ブロック転送に時間がかかるようになります。 CmpCAASDOServer 運転者 このコンポーネントは、CANopenSDOサーバープロトコルを実装します。オプションの構成ファイルエントリ： [CmpCAASdoClient]\nMaxSegmentsPerCycle=0 ; for block download: maximum of sent segments per cycle; 0 means infinity ここでは、ブロック転送でサイクルごとに送信されるCANメッセージの数を減らすことができます。 CmpEL6751CanDrv 運転者 このコンポーネントは、ベッコフEL6751 CAN \/ EtherCATゲートウェイ端末のリンクを実装します。コンポーネントはCANミニドライバーを実装しているため、 CANL2 コンポーネントとすべて CODESYS CANベースのスタック。構成ファイルのエントリは必要ありません。 CmpNetXCanDlDrv 運転者 このコンポーネントは NetX CAN アダプター用の CAN ミニドライバーです。このドライバーでは、 CODESYS Control Win 次の CAN ライブラリを使用できます。 CODESYS GmbH NetX アダプター経由。 の設定ファイル内のコンポーネントの構成 CODESYS Control Win : [CmpNetXCanDlDrv]\nMaxNumberOfCanNetworks=0..n -> number of the CAN networks (number of the NetIds)\nNetId.0.Channel=0 -> mapping of the NetId onboard nad NetX channels (see CmpHilscherCIFX)\nNetId.0.Board=0\n\n[ComponentManager]\n...\nComponent.6=CmpHilscherCIFX\nComponent.7=CmpNetXCanDlDrv\n... " }, 
{ "title" : "オプションの通信チャネル ", 
"url" : "_rtsl_windows_win_v3_dynamic_components.html#UUID-8ec48f4e-4fbf-ff18-64cb-d07a65c567cc_id_e00e47aa45e147ec0a8646334522c52-id-8aa5b4ef9fc59bd9c0a8646351124931", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS Control Win V3 \/ 動的コンポーネントの追加 \/ オプションの通信チャネル ", 
"snippet" : "CmpBlkDrvCanClient 運転者 このコンポーネントは、 CODESYS 通信用のブロックドライバ CODESYS とのゲートウェイ CODESYS CAN（サービス通信）を介したコントローラー。通信は、CANopen SDOプロトコル（「セグメント化」または「ブロック転送」）によって確立されます。コンポーネント CmpBlkDrvCanClient ゲートウェイ側とPeakのCANハードウェア（たとえば、PCAN USBドングル）に必要です。 ゲートウェイ構成ファイルの一般的な構成は次のとおりです。 [ComponentManager] Component.1=CmpBlkDrv...", 
"body" : "CmpBlkDrvCanClient 運転者 このコンポーネントは、 CODESYS 通信用のブロックドライバ CODESYS とのゲートウェイ CODESYS CAN（サービス通信）を介したコントローラー。通信は、CANopen SDOプロトコル（「セグメント化」または「ブロック転送」）によって確立されます。コンポーネント CmpBlkDrvCanClient ゲートウェイ側とPeakのCANハードウェア（たとえば、PCAN USBドングル）に必要です。 ゲートウェイ構成ファイルの一般的な構成は次のとおりです。 [ComponentManager]\nComponent.1=CmpBlkDrvCANClient\nComponent.2=CmpCAASdoClient\nComponent.3=CmpCAACanL2\nComponent.4=CmpPCANBasicDrv\n\n[CmpBlkDrvCanClient]\nCycleTimeMs=1\nNumChannels=1 ; Number of block driver instances\n0.Name=BlkDrvCanClient\n0.NetId=0 ; CANbus Network Id (0..n)\n0.Baudrate=1000 ; CANbus Baudrate in kbit\/s\n0.NodeId=1 ; unique NodeId of Gateway\n0.BlockTransfer=1 ; Use block transfer for more performance\n\n[CmpCAASdoClient]\nMaxSegmentsPerCycle=0 ; for block download: maximum of sent segments per cycle; 0 means infinity\n[CmpBlkDrvCanClient]\nCycleTimeMs=1\nNumChannels=1 ; Number of block driver instances\n0.Name=BlkDrvCanClient\n0.NetId=0 ; CANbus Network Id (0..n)\n0.Baudrate=1000 ; CANbus Baudrate in kbit\/s\n0.NodeId=1 ; unique NodeId of Gateway\n0.BlockTransfer=1 ; Use block transfer for more performance\n\n[CmpCAASdoClient]\nMaxSegmentsPerCycle=0 ; for block download: maximum of sent segments per cycle; 0 means infinity CmpBlkDrvCanServer 運転者 このコンポーネントは、 CODESYS 通信用のブロックドライバ CODESYS とのゲートウェイ CODESYS CAN（サービス通信）を介したコントローラー。通信は、CANopen SDOプロトコル（「セグメント化」または「ブロック転送」）によって確立されます。コンポーネント CmpBlkDrvCanServer コントローラ側と対応するCANミニドライバに必要です。コントローラ構成ファイルの一般的な構成は次のとおりです。 [Components]\nComponent.1=CmpAnyCANMiniDriverComponent ; TODO: Replace component name by your CAN Mini driver component\nComponent.2=CmpBlkDrvCanServer\n[Components]\nComponent.1=CmpAnyCANMiniDriverComponent ; TODO: Replace component name by your CAN Mini driver component\nComponent.2=CmpBlkDrvCanServer\n\n[CmpCAACanL2]\n;If setting PersistentBaudrate is enabled (0: disabled; 1: enabled)\n;the baudrate will be stored into Net.X.DefaultBaudrate (where X equals NetId)\n;when opening the driver.\nPersistentBaudrate=1\n;Default baudrate for CAN network 0. This baudrate will be used when the network \n;is opened (e.g from CmpBlkDrvCan or CANopen) with the baudrate set to 0.\nNet.0.DefaultBaudrate=1000\n\n[CmpBlkDrvCanServer]\nCycleTimeMs=1\n0.NetId=0\n0.Baudrate=0 ; 0 means: use setting from CmpCAACanL2 section\n0.NodeId=10\n\n[CmpCAASdoServer]\nMaxSegmentsPerCycle=0 ;for block upload: maximum of sent segments per cycle\n;0 means infinity " }, 
{ "title" : "CODESYS コントロール RTE V3 ", 
"url" : "_rtsl_windows_rts_v3.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "TCP \/ UDPプロトコルハンドラー（SysSocketLwIP） ", 
"url" : "_rtsl_windows_rte_v3_tcp_udp-protocol_handler.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ TCP \/ UDPプロトコルハンドラー（SysSocketLwIP） ", 
"snippet" : "バージョン3.5.16.0以降、TCP \/ UDPスタックは CODESYS Control RTE 。 過去には、Windowsのプロトコルスタック（=プロトコルハンドラー）に基づくイーサネットベースのフィールドバス（例：EtherNet \/ IP、ModbusTCP）で繰り返し問題が発生していました。これらのフィールドバスは、リアルタイムシステムの期待に確実に応えることができませんでした。 内部プロトコル スタックの導入により、SysEthernet ネットワーク アダプタ ドライバ ( CmpEt100Drv 、 CmpEt1000Drv 、 CmpRTL813xMpd 、 CmpRTL...", 
"body" : "バージョン3.5.16.0以降、TCP \/ UDPスタックは CODESYS Control RTE 。 過去には、Windowsのプロトコルスタック（=プロトコルハンドラー）に基づくイーサネットベースのフィールドバス（例：EtherNet \/ IP、ModbusTCP）で繰り返し問題が発生していました。これらのフィールドバスは、リアルタイムシステムの期待に確実に応えることができませんでした。 内部プロトコル スタックの導入により、SysEthernet ネットワーク アダプタ ドライバ ( CmpEt100Drv 、 CmpEt1000Drv 、 CmpRTL813xMpd 、 CmpRTL8169Mpd 、 CmpCX5000Mpd ) によって排他的に対処されなくなりました。 SysEthernet (または IoDrvEtherCAT と IoDrvProfinet ）。現在、それらは、直接 IP 通信のプロトコル スタックである TCP\/UDP によっても処理されます。 " }, 
{ "title" : "構成 ", 
"url" : "_rtsl_windows_rte_v3_tcp_udp_configuration.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ TCP \/ UDPプロトコルハンドラー（SysSocketLwIP） \/ 構成 ", 
"snippet" : "統合された TCP\/UDP プロトコル スタックをランタイム システムで使用するには、対応するネットワーク アダプター ドライバーを RTE のコンポーネント リストで構成する必要があります。 RTE の構成ファイル内のドライバー CODESYSControl_User.cfg セグメントに入力する必要があります [ComponentManager] .ここで可能なすべてのエントリは、RTE のセットアップによってすでに事前設定されており、 PLC 設定 → コンポーネント マネージャ メニューまたは「;」を削除することによって行の先頭に。 (Intel のすべての 10\/100\/1000 M...", 
"body" : "統合された TCP\/UDP プロトコル スタックをランタイム システムで使用するには、対応するネットワーク アダプター ドライバーを RTE のコンポーネント リストで構成する必要があります。 RTE の構成ファイル内のドライバー CODESYSControl_User.cfg セグメントに入力する必要があります [ComponentManager] .ここで可能なすべてのエントリは、RTE のセットアップによってすでに事前設定されており、 PLC 設定 → コンポーネント マネージャ メニューまたは「;」を削除することによって行の先頭に。 (Intel のすべての 10\/100\/1000 Mbit ネットワーク アダプタの例: Component.xy=CmpEt1000Drv ) 追加の設定は不要です。ネットワークアダプターの構成は Windows によって取得され、使用されます。該当するアダプタについては、SysEthernet ネットワークアダプタドライバの 1 つを Windows デバイスマネージャにインストールする必要があります (「 利用可能な動的コンポーネント)。 ネットワークアダプタのドライバは、内部プロトコルスタックに登録し、実行時に、適用されたプロトコルに内部プロトコルスタックまたはWindowsのどちらを使用する必要があるかを決定します。 " }, 
{ "title" : "プロトコルスタックのログ出力 ", 
"url" : "_rtsl_windows_rte_v3_tcp_udp_log.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ TCP \/ UDPプロトコルハンドラー（SysSocketLwIP） \/ プロトコルスタックのログ出力 ", 
"snippet" : "ログ出力は、ユーザーが統合プロトコルスタックの動作を監視するための唯一の方法です。 ログフィルターを設定することにより、デフォルト設定で提供されるよりも多くの出力がロガーに書き込まれます。これを行うには、値 Logger.0.Filter に設定されています 0xFFFFFFFF RTEの構成ファイル内 CODESYSControl_User.cfg 、セグメント内 [CmpLog] 。 次のログ出力とその原因は、統合されたTCP \/ UDPプロトコルスタックに割り当てることができます。 *** SysSocketlwIP -> No network-adapter for LwIP avai...", 
"body" : "ログ出力は、ユーザーが統合プロトコルスタックの動作を監視するための唯一の方法です。 ログフィルターを設定することにより、デフォルト設定で提供されるよりも多くの出力がロガーに書き込まれます。これを行うには、値 Logger.0.Filter に設定されています 0xFFFFFFFF RTEの構成ファイル内 CODESYSControl_User.cfg 、セグメント内 [CmpLog] 。 次のログ出力とその原因は、統合されたTCP \/ UDPプロトコルスタックに割り当てることができます。 *** SysSocketlwIP -> No network-adapter for LwIP available! 構成（コンポーネントリスト）に存在しないか、Windowsデバイスマネージャーを使用して少なくとも1つのネットワークアダプターにインストールされていないため、ネットワークアダプタードライバーはロードされませんでした。 *** SysSocketlwIP -> x network-adapters for LwIP available. 統合プロトコルスタックで使用できるネットワークアダプタが少なくとも1つあります。 *** SysSocketlwIP -> Switched to Winsock, use of unknown adapter! Winsock: 0xxxxxxxx 。 さらに使用するためにコロンがWindowsのIPスタックに渡された後のハンドルアドレスを持つソケット。ほとんどの場合、原因は、SysSockBindまたはSysSockSendToから、127.0.0.1（localhost）や0.0.0.0（ANY_ADDR）などの内部プロトコルスタックに不明なアダプターアドレスへの呼び出しです。 OPC UAサーバー、Webサーバー、CmpBlkDrvTcpなどの内部コンポーネントがlocalhost \/ ANY_ADDRにリンクしているため、ランタイムシステムを起動すると、これらの種類のログの出力は正常になります。 *** Error: SysSocketlwIP driver -> local receive buffer overrun. ランタイム システムが非常にビジーである場合 (たとえば、利用可能な合計計算能力の 80 または 90 パーセント以上を消費する IEC タスクが原因で)、受信したイーサネット フレームが受信前にプロトコル スタックによって時間内に評価されないことがあります。バッファがいっぱいです。 UDP の場合、このデータは失われ、繰り返しは上位のプロトコルに依存します。 TCP 接続の場合、ブロックの繰り返しが提供されます。 他の *** Error… ログ出力は発生しないようにし、必要に応じてサポートチームに報告する必要があります。 " }, 
{ "title" : "プロトコルスタックの通信タスク ", 
"url" : "_rtsl_windows_rte_v3_tcp_udp_communication_task.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ TCP \/ UDPプロトコルハンドラー（SysSocketLwIP） \/ プロトコルスタックの通信タスク ", 
"snippet" : "内部プロトコルスタックには、多くのUDPおよびTCP \/ IPタスクを処理するための独自のタスクが必要です。このタスクは、ランタイムシステムが初期化されるとすぐに作成され、優先度55になります。これはIECタスクの優先度23に対応します。優先度の高いIECタスクはUDP \/ TCP通信の影響を受けません。状況によっては、優先度の低いIECタスクがUDP \/ TCP通信の影響を受けます。 優先度は、アプリケーション開発者に、優先度の低い時間のかかるタスクによって（フィールドバス）通信を中断しない可能性を与えるために意図的に設定されました。または、時間の正確なコミュニケーションよりも重要なタスクを...", 
"body" : "内部プロトコルスタックには、多くのUDPおよびTCP \/ IPタスクを処理するための独自のタスクが必要です。このタスクは、ランタイムシステムが初期化されるとすぐに作成され、優先度55になります。これはIECタスクの優先度23に対応します。優先度の高いIECタスクはUDP \/ TCP通信の影響を受けません。状況によっては、優先度の低いIECタスクがUDP \/ TCP通信の影響を受けます。 優先度は、アプリケーション開発者に、優先度の低い時間のかかるタスクによって（フィールドバス）通信を中断しない可能性を与えるために意図的に設定されました。または、時間の正確なコミュニケーションよりも重要なタスクを定義します。 " }, 
{ "title" : "時間の振る舞いをチェックする ", 
"url" : "_rtsl_windows_rte_v3_check_timing_rte.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ 時間の振る舞いをチェックする ", 
"snippet" : "で簡単な標準プロジェクトを作成します CODESYS 。 唯一のタスクを1msのサイクルタイムに設定します。 カウンター変数をタイプとしてプログラムする DWORD それはサイクルを数えます。 その結果、この場合に必要なように、1000位が1秒間に約1回インクリメントされるかどうかをすぐに検出できます。 オンラインモードで、 モニタリング のタブ タスク構成 。 RTE によって計算されたジッター時間が表示されます。通常のシステムでは、これらは±100 μs 変動します。 ハードウェアにシリアルポートまたはパラレルポートが装備されている場合は、次を使用できます。 SysPort.library...", 
"body" : "で簡単な標準プロジェクトを作成します CODESYS 。 唯一のタスクを1msのサイクルタイムに設定します。 カウンター変数をタイプとしてプログラムする DWORD それはサイクルを数えます。 その結果、この場合に必要なように、1000位が1秒間に約1回インクリメントされるかどうかをすぐに検出できます。 オンラインモードで、 モニタリング のタブ タスク構成 。 RTE によって計算されたジッター時間が表示されます。通常のシステムでは、これらは±100 μs 変動します。 ハードウェアにシリアルポートまたはパラレルポートが装備されている場合は、次を使用できます。 SysPort.library 上記のプロジェクトでこれらのポートの個々のピンで出力をプログラムします。次に、の時間の振る舞いを調べることができます CODESYS Control RTE オシロスコープを使用して非常に正確に。 デジタルI \/ Oを備えたEtherCATスレーブがある場合は、これらのI \/ Oを使用して、オシロスコープで非常に優れた測定を実行することもできます。 詳細については、以下を参照してください。 特別なプラットフォームでのリアルタイム動作の構成 と タブ：監視 " }, 
{ "title" : "特別なプラットフォームでのリアルタイム動作の構成 ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ 特別なプラットフォームでのリアルタイム動作の構成 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "のリアルタイム動作 CODESYS Control RTE 特別なプラットフォームで ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html#UUID-0de36483-e275-5115-ca6b-72e31d34cfa5_id_d0c967c50de44a45c0a864631c66299f-id-904131440f59a05ac0a864633beb1ad4", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ 特別なプラットフォームでのリアルタイム動作の構成 \/ のリアルタイム動作 CODESYS Control RTE 特別なプラットフォームで ", 
"snippet" : "の時間挙動 CODESYS Control RTE CPU クロックの一貫性とフロントサイド バスのサイクルに依存します。 BIOS と Windows で特定の設定を行うと、時間の動作をさまざまなプラットフォームの条件に合わせて変更できます。...", 
"body" : "の時間挙動 CODESYS Control RTE CPU クロックの一貫性とフロントサイド バスのサイクルに依存します。 BIOS と Windows で特定の設定を行うと、時間の動作をさまざまなプラットフォームの条件に合わせて変更できます。 " }, 
{ "title" : "BIOSの設定 ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html#UUID-0de36483-e275-5115-ca6b-72e31d34cfa5_id_d0c967c50de44a45c0a864631c66299f-id-24bd95e00f59a05ac0a8646332b0218d", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ 特別なプラットフォームでのリアルタイム動作の構成 \/ BIOSの設定 ", 
"snippet" : "の時間動作を最適化するために与えることができるのは、一般的な推奨事項のみです。 CODESYS Control RTE ほとんどのプラットフォームには異なるタイプのBIOSがあるためです。...", 
"body" : "の時間動作を最適化するために与えることができるのは、一般的な推奨事項のみです。 CODESYS Control RTE ほとんどのプラットフォームには異なるタイプのBIOSがあるためです。 " }, 
{ "title" : "Windowsでの設定 ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html#UUID-0de36483-e275-5115-ca6b-72e31d34cfa5_id_d0c967c50de44a45c0a864631c66299f-id-6c4e42d628502216c0a864630d4e6b2f", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ 特別なプラットフォームでのリアルタイム動作の構成 \/ Windowsでの設定 ", 
"snippet" : "推奨事項：電源方式は常に「」に設定する必要があります 常にオン \"。 自動的にアップデート ：PCはユーザープロンプトなしで自動メカニズムによって再起動される可能性があるため、産業用コントローラーの更新は常に手動で実行する必要があります。...", 
"body" : "推奨事項：電源方式は常に「」に設定する必要があります 常にオン \"。 自動的にアップデート ：PCはユーザープロンプトなしで自動メカニズムによって再起動される可能性があるため、産業用コントローラーの更新は常に手動で実行する必要があります。 " }, 
{ "title" : "「APIC」（シングルおよびマルチプロセッサ）および「AMP」（個々の CPU コアでの RTE の動作）の適応 ", 
"url" : "_rtsl_windows_rte_v3_configure_realtime.html#UUID-0de36483-e275-5115-ca6b-72e31d34cfa5_id_d0c967c50de44a45c0a864631c66299f-id-3cbaa0b1908b4745c0a86463315e2cd5", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ 特別なプラットフォームでのリアルタイム動作の構成 \/ 「APIC」（シングルおよびマルチプロセッサ）および「AMP」（個々の CPU コアでの RTE の動作）の適応 ", 
"snippet" : "プラットフォームの特定の特性への一般的な適応は、 CmpDrvSchedulerAMP と CmpDrvSchedulerAPIC コンポーネント (Windows 7 の廃止以来、関連性がなくなりました)。 デフォルトでは、 CmpDrvSchedulerAMP のセットアップからインストールされます。 CODESYS Control RTE . CmpDrvSchedulerAPIC 互換性の理由でのみ含まれており、古い Windows 7 PC にのみ手動でインストールできます。 一般に、 CODESYS Control RTE 複数のプロセッサ コアを搭載した PC でのみ実行できます...", 
"body" : "プラットフォームの特定の特性への一般的な適応は、 CmpDrvSchedulerAMP と CmpDrvSchedulerAPIC コンポーネント (Windows 7 の廃止以来、関連性がなくなりました)。 デフォルトでは、 CmpDrvSchedulerAMP のセットアップからインストールされます。 CODESYS Control RTE . CmpDrvSchedulerAPIC 互換性の理由でのみ含まれており、古い Windows 7 PC にのみ手動でインストールできます。 一般に、 CODESYS Control RTE 複数のプロセッサ コアを搭載した PC でのみ実行できます ( CmpDrvSchedulerAMP ）。唯一の例外は、Windows プラットフォーム「Windows 7 (32 ビット)」です。の CmpDrvSchedulerAPIC このプラットフォームでのみ引き続き使用できます。このコンポーネントにより、 CODESYS Control RTE タイム スライスを使用して、CPU コア 0 を Windows と共有できます。 起動時に複雑なテストが実行される CODESYS Control RTE クロック速度をマイクロ秒にスケーリングするために初めて。このメッセージの結果は、Windows レジストリに保存されます。 HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\CmpDrvSchedulerAMP\\Params また HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Services\\CmpDrvSchedulerAPIC\\Params 、値 SetClocksPerUS と SetCountsPerMS . 毎回 CODESYS Control RTE が開始された場合、最初の起動時に測定から取得された値がレジストリから読み取れる場合、測定は再度実行されません。システムで行われた調整（たとえば、BIOSの省電力設定）によってCPUクロックが測定値から変更された場合、これらの値をWindowsレジストリから削除する必要があります。その場合にのみ、クロックレートが再スケーリングされます。 CODESYS Control RTE 再開されます。 詳細については、次を参照してください。 ハードウェア構成 — 推奨事項" }, 
{ "title" : "ヒルシャーCIFXカードの試運転 ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ ヒルシャーCIFXカードの試運転 ", 
"snippet" : "Hilscher CIFX ネットワーク カードを取り付けるには、次の手順を実行します。 CODESYS Control RTE 。この手順は、適用されるフィールドバス システムから独立しています。 CIFX を備えた次のフィールドバスがサポートされています。 PROFINET コントローラーと PROFINET デバイス PROFIBUS マスターと PROFIBUS コントローラ netX-CAN EtherNet\/IP スキャナー...", 
"body" : "Hilscher CIFX ネットワーク カードを取り付けるには、次の手順を実行します。 CODESYS Control RTE 。この手順は、適用されるフィールドバス システムから独立しています。 CIFX を備えた次のフィールドバスがサポートされています。 PROFINET コントローラーと PROFINET デバイス PROFIBUS マスターと PROFIBUS コントローラ netX-CAN EtherNet\/IP スキャナー " }, 
{ "title" : "Windowsドライバーのインストール ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-3b8953bc0e40fc79c0a8646325dd6b8e", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ ヒルシャーCIFXカードの試運転 \/ Windowsドライバーのインストール ", 
"snippet" : "でヒルシャーカードを操作すると、 CODESYS Control RTE ランタイム システムの場合、ネットワーク アダプタに付属の Hilscher ドライバを使用しないでください。使用する場合 CODESYS Control RTE NetX を使用する場合は、インストールする必要があります SysDrv3s.sys ( SysDrv3S サブディレクトリ) は、RTE インストール パッケージで提供されます。...", 
"body" : "でヒルシャーカードを操作すると、 CODESYS Control RTE ランタイム システムの場合、ネットワーク アダプタに付属の Hilscher ドライバを使用しないでください。使用する場合 CODESYS Control RTE NetX を使用する場合は、インストールする必要があります SysDrv3s.sys ( SysDrv3S サブディレクトリ) は、RTE インストール パッケージで提供されます。 " }, 
{ "title" : "NetXファームウェアとNetXブートローダー ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-82e7a36597005e19c0a864632973a990", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ ヒルシャーCIFXカードの試運転 \/ NetXファームウェアとNetXブートローダー ", 
"snippet" : "NetXファームウェアおよびNetXブートローダーは、インストールパッケージと一緒に提供され、サブフォルダーにあります。 HilscherCIFX\\Firmware インストール後。...", 
"body" : "NetXファームウェアおよびNetXブートローダーは、インストールパッケージと一緒に提供され、サブフォルダーにあります。 HilscherCIFX\\Firmware インストール後。 " }, 
{ "title" : "コンポーネントの追加 ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-6d2a7e991eb48aa8c0a86463368630e2", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ ヒルシャーCIFXカードの試運転 \/ コンポーネントの追加 ", 
"snippet" : "の中に CODESYS Control RTE メニューをクリックします PLC構成 。 ダイアログで、に切り替えます コンポーネントマネージャー タブ。 オプションのコンポーネントを追加します CmpHilscherCIFX をクリックします わかった 確認するために。...", 
"body" : "の中に CODESYS Control RTE メニューをクリックします PLC構成 。 ダイアログで、に切り替えます コンポーネントマネージャー タブ。 オプションのコンポーネントを追加します CmpHilscherCIFX をクリックします わかった 確認するために。 " }, 
{ "title" : "「CODESYSControl.cfg」を使用したRTEの構成 ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-a4398f680e40fc88c0a864635dd4fc93", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ ヒルシャーCIFXカードの試運転 \/ 「CODESYSControl.cfg」を使用したRTEの構成 ", 
"snippet" : "構成ファイル CODESYSControl.cfg インストールディレクトリにあります。 コンポーネントを追加します CmpHilscherCifX ： [ComponentManager] ...Component.x=CmpHilscherCIFX ... セグメント内 CmpHilscherCIFX 、CIFXカードの数に応じて、対応する行をアクティブにします（行の先頭にある「;」を削除します）。 ... [CmpHilscherCIFX] ;TraceLevel=0xFFFFFFFF Device.0.BootloaderFilePath=... (see image) Device....", 
"body" : "構成ファイル CODESYSControl.cfg インストールディレクトリにあります。 コンポーネントを追加します CmpHilscherCifX ： [ComponentManager]\n...Component.x=CmpHilscherCIFX\n... セグメント内 CmpHilscherCIFX 、CIFXカードの数に応じて、対応する行をアクティブにします（行の先頭にある「;」を削除します）。 ...\n[CmpHilscherCIFX]\n;TraceLevel=0xFFFFFFFF\nDevice.0.BootloaderFilePath=... (see image)\nDevice.0.Channel.0.FirmwareFile=...\n\n TraceLevel ：CODESYSロガーで追加のデバッグタスクをアクティブ化する BootloaderFilePath ：各NetXコントローラーのNetXブートローダーのファイルパスとファイル名。相対パスはインストールディレクトリから始まります。絶対パスも使用できます。複数のNetXコントローラーを使用している場合は、複数のファイルパスを指定する必要があります。 ...\nDevice.0.BootloaderFilePath=NXCIF50-RTE.bin\nDevice.1.BootloaderFilePath=NXCIF50-RTE.bin\n... Device.X.Channel.X.FirmwareFile ：各アダプタおよび各チャネルのNetXファームウェアのファイルパスとファイル名。相対パスはインストールディレクトリから始まります。絶対パスも使用できます。何よりも「チャンネル0」のみが使用されます。複数のNetXチップを使用している場合は、複数のファイルパスを指定する必要があります。 ...\nDevice.0.Channel.0.FirmwareFile=cifxdpm.nxf\nDevice.1.Channel.0.FirmwareFile=cifxdpm.nxf\n... 結果： " }, 
{ "title" : "ランタイムシステムの起動 ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-b219f19c0e40fc88c0a864630469e13f", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ ヒルシャーCIFXカードの試運転 \/ ランタイムシステムの起動 ", 
"snippet" : "クリックしてランタイムシステムを起動します PLCを起動します のSysTrayメニューで CODESYS Control RTE 。 ランタイムシステムが実行されるとすぐに、 CmpHilscherCIFX ランタイムシステムロガーに表示されます。のエントリが表示されます ログ のデバイスエディタのダイアログ CODESYS 、および LogPLCxx.csv のファイル CODESYS Control RTE ディレクトリ。 以下を確認してください。 コンポーネント CmpHilscherCIFX ロードされている必要があります。 のツールキットバージョン CmpHilscherCIFX ...", 
"body" : "クリックしてランタイムシステムを起動します PLCを起動します のSysTrayメニューで CODESYS Control RTE 。 ランタイムシステムが実行されるとすぐに、 CmpHilscherCIFX ランタイムシステムロガーに表示されます。のエントリが表示されます ログ のデバイスエディタのダイアログ CODESYS 、および LogPLCxx.csv のファイル CODESYS Control RTE ディレクトリ。 以下を確認してください。 コンポーネント CmpHilscherCIFX ロードされている必要があります。 のツールキットバージョン CmpHilscherCIFX コンポーネントを表示する必要があります。 ファームウェアがロードされます。ロガーはファームウェアの名前とバージョンについて通知します。 設定した場合 TraceLevel に 0xFFFFFFFF 、その後、情報はから発行されます CmpHilscherCIFX 構成されたNetXチャネルごとに。 詳細については、以下を参照してください。 タブ：ログ " }, 
{ "title" : "の作成 CODESYS I \/ O構成のプロジェクト ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-1f474e4c0e40fc88c0a8646300249b0e", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ ヒルシャーCIFXカードの試運転 \/ の作成 CODESYS I \/ O構成のプロジェクト ", 
"snippet" : "今、あなたは簡単なものを作成することができます CODESYS 実行中のフィールドバスを使用したプロジェクト： で新しい標準プロジェクトを作成します CODESYS 。デバイスを選択します CODESYS Control RTE 作成するとき。 デバイスツリーにCIFX-PBフィールドバスマスターを追加します。 デバイスツリーのエントリをダブルクリックして、フィールドバスマスターの設定ダイアログを開きます。に切り替えます NetX構成 タブ。の値を設定します スロット と NetXcomチャネル 構成ファイルのデバイス番号と同じになるようにします CODESYSControl.cfg 。値をラ...", 
"body" : "今、あなたは簡単なものを作成することができます CODESYS 実行中のフィールドバスを使用したプロジェクト： で新しい標準プロジェクトを作成します CODESYS 。デバイスを選択します CODESYS Control RTE 作成するとき。 デバイスツリーにCIFX-PBフィールドバスマスターを追加します。 デバイスツリーのエントリをダブルクリックして、フィールドバスマスターの設定ダイアログを開きます。に切り替えます NetX構成 タブ。の値を設定します スロット と NetXcomチャネル 構成ファイルのデバイス番号と同じになるようにします CODESYSControl.cfg 。値をランタイムシステムのロガーエントリと比較します。 アプリケーションをビルドします。アプリケーションをコントローラーにダウンロードして起動します。 デバイスツリーのすべてのノードを緑色でマークする必要があります。 " }, 
{ "title" : "よくある質問 ", 
"url" : "_rtsl_windows_rte_v3_startup_cifx_hil.html#UUID-e6035788-7945-6a3c-1bfe-bcd82f89c135_id_b7b7a3b80de92407c0a8646374eecd04-id-d19e04ada023b398c0a8646370386558", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ ヒルシャーCIFXカードの試運転 \/ よくある質問 ", 
"snippet" : "デバイスツリーのフィールドバスマスターは緑色ではありません。どうすれば問題を見つけることができますか？ PLCの構成エディタを開きます（ 通信設定 このエディタにもあります）、に切り替えます ログ タブをクリックし、緑色の矢印をクリックします。 CODESYS PLCからすべてのロガーエントリをロードして表示します。次に、エラーと例外を検索できます。 未解決の参照があります。 未解決の参照がアプリケーションに存在する場合、ランタイムシステムコンポーネントがロードされていないか、正しくないバージョンがロードされています。チェックしてください CODESYS ロガー。コンポーネント CmpHils...", 
"body" : "デバイスツリーのフィールドバスマスターは緑色ではありません。どうすれば問題を見つけることができますか？ PLCの構成エディタを開きます（ 通信設定 このエディタにもあります）、に切り替えます ログ タブをクリックし、緑色の矢印をクリックします。 CODESYS PLCからすべてのロガーエントリをロードして表示します。次に、エラーと例外を検索できます。 未解決の参照があります。 未解決の参照がアプリケーションに存在する場合、ランタイムシステムコンポーネントがロードされていないか、正しくないバージョンがロードされています。チェックしてください CODESYS ロガー。コンポーネント CmpHilscherCIFX ロードされている必要があります。 もしも CmpHilscherCIFX ロードされていない場合は、コンポーネントを CODESYSControl.cfg ファイル。 もしも CmpHilscherCIFX がロードされた場合、廃止されたバージョンが使用されている可能性があります。この場合、RTE を再インストールして、ランタイム システム全体を更新します。 TraceLevel がアクティブ化されましたが、の新しいエントリが見つかりません CmpHilscherCIFX 成分。 これは、ランタイムがNetXアダプターまたはチップを検出しないことを意味します。アダプタが正しく挿入され、対応するドライバがインストールされていることを確認してください。詳細については、上記を参照してください。 Windowsドライバーのインストール。 " }, 
{ "title" : "ハードウェア構成 — 推奨事項 ", 
"url" : "_rtsl_windows_rte_v3_examples_hints.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ ハードウェア構成 — 推奨事項 ", 
"snippet" : "のためにBIOS設定を調整する必要があるかもしれません CODESYS Control RTE 最適に低いジッターでそれぞれのプラットフォームで実行します。適応については、次の例を参照してください。これは、推奨事項としてのみ考慮されるべきです。 次の BIOS 設定は常に無効にする必要があります。 HT (インテル CPU によるハイパースレッディング、AMD CPU による同時マルチスレッド) VT (インテル CPU の場合は仮想化テクノロジー、AMD CPU の場合は AMD-V) Windows 10 以降では、VT によって Windows 自体を仮想環境で起動させるため、Windo...", 
"body" : "のためにBIOS設定を調整する必要があるかもしれません CODESYS Control RTE 最適に低いジッターでそれぞれのプラットフォームで実行します。適応については、次の例を参照してください。これは、推奨事項としてのみ考慮されるべきです。 次の BIOS 設定は常に無効にする必要があります。 HT (インテル CPU によるハイパースレッディング、AMD CPU による同時マルチスレッド) VT (インテル CPU の場合は仮想化テクノロジー、AMD CPU の場合は AMD-V) Windows 10 以降では、VT によって Windows 自体を仮想環境で起動させるため、Windows で使用されていなくても RTE は CPU コアを起動できません。 したがって、この BIOS オプションを無効にする代わりに、Windows の「仮想マシンプラットフォーム」機能または「Windows ハイパーバイザープラットフォーム」機能を無効にすることもできます。最終的には、VT オプションを無効にするほうが BIOS のほうが適しています 定期的にSMIが発生するレガシーUSBまたはその他のBIOS機能 SMI は、数十マイクロ秒または数百マイクロ秒の間システム全体を停止させるシステム管理割り込みです。 周波数の変化につながるインテルまたはAMDプロセッサー向けの省エネオプション (インテルCPUの場合はEIST、AMD CPUの場合はクールアンドクワイエットなど) 定期的なセルフテストまたは記憶テスト 「スリープモード」は決定的な役割を果たします（ACPI用語では「Cステート」）。「C」の後の数字が大きいほど、スリープ状態は低いことを示します。スリープモードでは、プロセッサは電圧とクロック速度を低下させるだけでなく、キャッシュとサービス内の全領域を無効にします。BIOS では、この原因となるオプションは通常「Cステート」と呼ばれます インテルの「SpeedStep」またはAMDの「PowerNow」は「EIST」と呼ばれることがあり、この場合は無効にする必要があります。 プロセッサ設定のチェックまたは構成がBIOSでカバーされていない場合、またはオプションが利用できない場合は、インターネットで対応するツールを見つけることができます。例： RightMark CPU CPU-Z (CPUID) RM Clock 電源オプションなど 高速スタートアップ また 休止状態 いかなる状況でも許可してはなりません。 " }, 
{ "title" : "利用可能な動的コンポーネント ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ 利用可能な動的コンポーネント ", 
"snippet" : "オプションのコンポーネントは適応に使用されます CODESYS Control RTE 特定のハードウェアに。これらのコンポーネントを構成にロードすることもできます。 コンポーネントマネージャー のタブ PLC構成 ダイアログ。詳細については、次を参照してください。 ダイアログ：システム構成–コンポーネントマネージャー...", 
"body" : "オプションのコンポーネントは適応に使用されます CODESYS Control RTE 特定のハードウェアに。これらのコンポーネントを構成にロードすることもできます。 コンポーネントマネージャー のタブ PLC構成 ダイアログ。詳細については、次を参照してください。 ダイアログ：システム構成–コンポーネントマネージャー" }, 
{ "title" : "ハードウェアプラットフォームへの適応 ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html#UUID-02a278cf-2b50-1c37-599d-a5067a66fff9_id_fd05abe0de24135c0a8646368ec8e61-id-80961508ba9b6b22c0a8646354292cdd", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ 利用可能な動的コンポーネント \/ ハードウェアプラットフォームへの適応 ", 
"snippet" : "マルチコアプロセッサでは、 CmpDrvSchedulerAMP 常にセットアップによって初期化されます。これにより、RTEの実行がWindowsで使用されていないCPUコアにオフロードされます。 Windows 64ビットまたはWindowsバージョン> 7では、リアルタイム操作はこの方法でのみ可能です。その結果、セットアップは、ブートオプションを使用して、Windowsの実行を最初の<物理的に利用可能なコアの数-1>コアに制限します。 numproc 。ハイパースレッディングコアは完全に放棄する必要があります。セットアップはプラットフォームを認識し、RTEのcfgファイルの最初のコンポーネ...", 
"body" : "マルチコアプロセッサでは、 CmpDrvSchedulerAMP 常にセットアップによって初期化されます。これにより、RTEの実行がWindowsで使用されていないCPUコアにオフロードされます。 Windows 64ビットまたはWindowsバージョン> 7では、リアルタイム操作はこの方法でのみ可能です。その結果、セットアップは、ブートオプションを使用して、Windowsの実行を最初の<物理的に利用可能なコアの数-1>コアに制限します。 numproc 。ハイパースレッディングコアは完全に放棄する必要があります。セットアップはプラットフォームを認識し、RTEのcfgファイルの最初のコンポーネントとして必要なドライバーを自動的に入力します。これは決して変更してはなりません。 ドライバーは、適用されたハードウェアの速度が決定された最初の開始時に測定結果を保存します。これらは、システムサービスのパスに名前として保存されます HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Service キーで Params 。以降のすべてのシステム起動時に、決定された値がレジストリから読み取られます。値が欠落している場合は、測定が再度行われます。 " }, 
{ "title" : "オプションのフィールドバスアダプタのサポート ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html#UUID-02a278cf-2b50-1c37-599d-a5067a66fff9_id_fd05abe0de24135c0a8646368ec8e61-id-db3e9d0eba9b6b22c0a86463246ec925", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ 利用可能な動的コンポーネント \/ オプションのフィールドバスアダプタのサポート ", 
"snippet" : "CmpEt1000Drv 運転者 このドライバーは直接サポートします Pro1000 Intelの互換性のあるチップセット。コンポーネントを使用するには、WindowsのデバイスマネージャーでIntelの元のドライバーをこのドライバーに置き換える必要があります。次のように続けます。 Windowsのデバイスマネージャを開きます。 選択したものを右クリックします Pro1000 ネットワークアダプタとコマンドをクリックします ドライバーソフトウェアを更新する 。 ドライバーを手動で選択し、パスを次のように指定します <RTE installation directory>\\CmpET1000MP...", 
"body" : "CmpEt1000Drv 運転者 このドライバーは直接サポートします Pro1000 Intelの互換性のあるチップセット。コンポーネントを使用するには、WindowsのデバイスマネージャーでIntelの元のドライバーをこのドライバーに置き換える必要があります。次のように続けます。 Windowsのデバイスマネージャを開きます。 選択したものを右クリックします Pro1000 ネットワークアダプタとコマンドをクリックします ドライバーソフトウェアを更新する 。 ドライバーを手動で選択し、パスを次のように指定します <RTE installation directory>\\CmpET1000MPD 。 デバイスマネージャがドライバのインストールを拒否した場合は、Intelを押して元のドライバをアンインストールします。 <デル> キーを押して、対応するものを削除します inf と pnf ディレクトリ内のファイル <SystemRoot>\\inf 。ノート： SystemRoot 通常は \" C:Windows \"。 The inf ここで使用するファイルは広く名前が付けられています net557*.inf \/ pnf また net559*.inf \/ pnf 。注：参照されている場合 Pro1000 の中に inf ファイルの場合、通常は正しいファイルです。 The pnf ファイルは常にと同じ名前です inf ファイル。 その後、システムを再起動すると、Windowsはドライバーを自動的にインストールできなくなります。ハードウェアマネージャーが起動し、ドライバーが <RTE installation directory>\\CmpET1000MPD それに転送されます。 また、ファイルでランタイム コンポーネントを有効にする必要があります。 CODESYSControl_User.cfg : Component.<subsequent number>=CmpEt1000Drv CmpEt100Drv 運転者 注：このドライバーは、互換性の目的でのみ提供されています。ハードウェアは購入できなくなりました。 このドライバーは直接サポートします Pro100 Intelの互換性のあるチップセット。コンポーネントを使用するには、WindowsのデバイスマネージャーでIntelの元のドライバーをこのドライバーに置き換える必要があります。次のように続けます。 Windowsのデバイスマネージャを開きます。 選択したものを右クリックします Pro100 ネットワークアダプタとコマンドをクリックします ドライバーソフトウェアを更新する 。 ドライバーを手動で選択し、パスを次のように指定します <RTE installation directory>\\CmpET100MPD 。 デバイスマネージャがドライバのインストールを拒否した場合は、Intelを押して元のドライバをアンインストールします。 <デル> キーを押して、対応するものを削除します inf と pnf ディレクトリ内のファイル <SystemRoot>\\inf 。ノート： SystemRoot 通常は \" C:\\Windows \"。 The inf ここで使用するファイルは広く名前が付けられています net557*.inf \/ pnf また net559*.inf \/ pnf 。注：参照されている場合 Pro100 の中に inf ファイルの場合、通常は正しいファイルです。 The pnf ファイルは常にと同じ名前です inf ファイル。 その後、システムを再起動すると、Windowsはドライバーを自動的にインストールできなくなります。ハードウェアマネージャーが起動し、ドライバーが <RTE installation directory>\\CmpET100MPD それに転送されます。 また、ファイルでランタイム コンポーネントを有効にする必要があります。 CODESYSControl_User.cfg : Component.<subsequent number>=CmpEt100Drv CmpSJACanDrv 運転者 CmpSJACanDrv CANコントローラーに基づくCANハードウェア用の汎用ドライバーです SJA1000 または互換性のあるコントローラー。 Peak、Ixxat（パッシブCANアダプター）、およびAutomataのPCIアダプターは直接サポートされています。 アダプタをインストールした後、ディレクトリから対応するドライバを選択してインストールできます W2K_XP_Drivers （RTEインストールディレクトリ内）。これを行うには、真上に表示されるウィザードを使用します 新しいハードウェアが見つかりました 、またはWindowsのデバイスマネージャを使用します（コンテキストメニュー：コマンド ドライバーソフトウェアを更新する ）。上記のディレクトリの1つでドライバとナビゲーションを手動で選択して、目的のドライバをインストールします。デバイスはカテゴリ「 3S compatible devices \"。 注：製造元の元のドライバーをインストールしないでください。 ドライバ CmpSJACanDrv 対処することもできます SJA1000 コントローラはハードウェアに固定されています。これらの種類のオンボードCANコントローラーのプロパティは、の構成ファイルのエントリを使用してドライバーに転送できます。 CODESYS Control RTE セクションで [CmpSJACanDrv] 。可能なエントリ： NumDevices=1 <number of SJAs> ;Number of SJAs, that are configured in the following>\n;(optional: <DisableRetain=1> The driver is told that it should\n; not create any retain entry in the cfg file, even if a CAN adapter is equipped with NVRAM.)\n0.Address=<physical address of the SJA1000> \n0.Interrupt=<interrupt vector of the SJA1000>\n0.IntEdgeTrig=<0 or 1. 0 hardware dependent>\n0.XtalFrequency=<frequency> ;normally 16000000Hz, 24000000Hz is also a possible variant\n0.BusType=<bus type> ;depending on the type of switching of the SJA, \n;1 for ISA, 3 for PCI, 0 for memory\n0.Alignment=<alignment> ;normally 1, hardware dependent\n0.Name=<any name>\n.OutputCtrl=<valid values:e.g. 0xFE, 4C, 1A> ;Depends on the CAN switching\n0.PortAddress=<port address> ;This address is written one time for \n;initializing the CAN switching.\n0.PortValue=<vlaue> ;The value that is written for the initialization. CmpNetXCanDlDrv 運転者 このコンポーネントは、NetXCANアダプター用のCANミニドライバーです。このドライバーで、 CODESYS Control RTE からCANライブラリを使用できます CODESYS GmbH NetXアダプタを介して。 CmpNetXCanDlDrv でのみ使用できます CmpHilscherCIFX CANファームウェア（マスターまたはスレーブ）をロードする必要があります。マスターとスレーブのどちらを使用してもかまいません。 CmpNetXCanDlDrv アダプタのCANドライバインターフェイスのみを使用します。プロトコルは3SCANライブラリによって管理されます。 の構成ファイル内のコンポーネントの構成 CODESYS Control RTE ： [CmpNetXCanDlDrv]MaxNumberOfCanNetworks=0..n -> number of the CAN networks (number of the NetIds)\nNetId.0.Channel=0 -> mapping of the NetId onboard nad NetX channels (see CmpHilscherCIFX)\nNetId.0.Board=0 CmpRTL81x9Mpd 運転者 注：このドライバーは、互換性の目的でのみ提供されています。ハードウェアは購入できなくなりました。 このドライバーは直接サポートします Realtek RTL8139 （および互換性のある）イーサネットコントローラー。コンビネーションチップセット 8100 と 8110 互換性もあります。インストールも同様に実行されます CmpEt100Drv 。 CmpRTL8169Mpd 運転者 と同じように CmpRTL81x9Mpd ;上記のギガビットバリアントの場合 Realtek イーサネットコントローラ。 CmpSercos3Master 運転者 このドライバは、 SERCOS III PCI adapter 700353x0 Automataから。アダプタをインストールした後、からドライバをインストールします W2K_XP_Drivers\\Automata_SERCOS3 。 CmpHilscherCIFX 運転者 このドライバーは、HilscherのCifXカードをサポートしています。 カードをインストールした後、Hilscherまたは SysDrv3S 。 （の配信の範囲内で CODESYS Control Win からのWindows用ランタイムシステム CODESYS GmbH ）。 でコンポーネントを指定します cfg のファイル CODESYS Control RTE .これは、エディターまたは PLC 構成 ダイアログ。生成する [CmpHilscherCIFX] セクションも。ドライバーには、次のエントリが必要です (例)。 Device.0.BootloaderFilePath=NXCIF50-RTE.bin\nDevice.0.Channel.0.FirmwareFile=cifxdpm.nxf この例では、 0 の Device.0 複数が使用されている場合は、アダプターの0ベースのインデックスです。 Channel 常に続く 0 HilscherのすべてのPCIアダプターは1つのチャネルのみをサポートしているためです。 ブートローダーまたはファームウェアを含むファイルは、HilscherからCifXカードとともに提供されます。それらをのルートファイルディレクトリに配置する必要があります CODESYS Control RTE 。また、構成ファイルのファイル名またはエントリを調整する必要がある場合もあります。 詳細については、以下を参照してください。 ヒルシャーCIFXカードの試運転 " }, 
{ "title" : "NVRAMPCIプラグインアダプタ ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html#UUID-02a278cf-2b50-1c37-599d-a5067a66fff9_id_fd05abe0de24135c0a8646368ec8e61-id-70a6f7c2ba9b6b22c0a86463083c7758", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ 利用可能な動的コンポーネント \/ NVRAMPCIプラグインアダプタ ", 
"snippet" : "CmpPciRetain 運転者 このドライバを使用すると、PCIアダプタの保持メモリとしてNVRAMを使用できます。要件：NVRAMは、PCIレジスタの物理アドレスを介して直接到達可能であり、バイト、ワード、ダブルワードアクセスなどのすべての範囲のアクセスをサポートします。 構成ファイルの次のエントリを使用して、コンポーネントを構成できます。 CoDeSysControl.cfg の CODESYS Control RTE セクションで [CmpPciRetain] ： VendorID 、 DeviceID 、 SubDeviceID 、 SubVendorID ：PCIデバイスの識別。 ...", 
"body" : "CmpPciRetain 運転者 このドライバを使用すると、PCIアダプタの保持メモリとしてNVRAMを使用できます。要件：NVRAMは、PCIレジスタの物理アドレスを介して直接到達可能であり、バイト、ワード、ダブルワードアクセスなどのすべての範囲のアクセスをサポートします。 構成ファイルの次のエントリを使用して、コンポーネントを構成できます。 CoDeSysControl.cfg の CODESYS Control RTE セクションで [CmpPciRetain] ： VendorID 、 DeviceID 、 SubDeviceID 、 SubVendorID ：PCIデバイスの識別。 AddressIndex ：PCIアドレスレジスタ（ BAR0 – BAR5 ）NVRAMの物理ベースアドレスが含まれています。デフォルト値： 0 。 MemorySize ：使用可能なNVRAMのサイズ（バイト単位）。デフォルト値： 0x80000 （512KB）。 AddrOffset ：使用済みアドレスレジスタに対するNVRAMの移動。 の値については、使用されているPCIアダプターのドキュメントを参照してください。 AddressIndex 、 MemorySize 、 と AddrOffset 。 4つのIDのデフォルト値は、Siemens NanoBoxPCのMRAMデバイスを識別します。 " }, 
{ "title" : "ベッコフCX5xxx固有のコンポーネント ", 
"url" : "_rtsl_windows_rte_v3_dynamic_components.html#UUID-02a278cf-2b50-1c37-599d-a5067a66fff9_id_fd05abe0de24135c0a8646368ec8e61-id-821f92efba9b6b32c0a8646353736f59", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ 利用可能な動的コンポーネント \/ ベッコフCX5xxx固有のコンポーネント ", 
"snippet" : "CmpCX5000Mpd 運転者 これはWindowsネットワークドライバーです。でのみ使用できます CXxxxx ベッコフPCと CX5000 通信プロセッサ。 の設定の場合 CODESYS Control RTE で実行されます CXxxxx PC、次にドライバー CmpCX5000Mpd 自動的にインストールされ、コンポーネントのリスト（cfgファイル内）に追加されます。 追加情報と手動インストール：例外：CX-IPCはデフォルトで「Windows7組み込み標準」でインストールされました。これは、ハードウェアIDを持つPCIデバイス用のベッコフドライバーで構成されます VendorID ...", 
"body" : "CmpCX5000Mpd 運転者 これはWindowsネットワークドライバーです。でのみ使用できます CXxxxx ベッコフPCと CX5000 通信プロセッサ。 の設定の場合 CODESYS Control RTE で実行されます CXxxxx PC、次にドライバー CmpCX5000Mpd 自動的にインストールされ、コンポーネントのリスト（cfgファイル内）に追加されます。 追加情報と手動インストール：例外：CX-IPCはデフォルトで「Windows7組み込み標準」でインストールされました。これは、ハードウェアIDを持つPCIデバイス用のベッコフドライバーで構成されます VendorID = SubVendorID = 0x15ec と DeviceID = SubDeviceID = 0x5000 。のインストール後 CODESYS Control RTE 、このドライバーをドライバーに置き換えることができます CmpCX5000Mpd.sys 。この場合、関数を使用します ドライバーソフトウェアを更新する Windowsのコントロールパネル： Windows デバイス マネージャーを開きます。 Beckhoff からシステム デバイスを検索し、右クリックしてコマンドを実行します。 ドライバーソフトウェアの更新 . ウィザードで、 ドライバーソフトウェアを手動で検索する オプションをクリックしてクリックします ディスクを持っている 。 を選択 inf のインストールディレクトリにあるファイル CODESYS Control RTE （サブディレクトリ CmpCX5000Mpd ）。 ドライバをインストールする必要があるかどうかに関するプロンプトを確認します。 Windowsは、という名前のネットワークアダプタをインストールします CX5000 driver for CODESYS Ethernet 。 構成ファイルでドライバーを手動で指定します CoDeSysControl.cfg （のインストールディレクトリ CODESYS Control RTE ）： 例： Component.3=CmpCX5000Mpd 。 次に、のダウンロード CODESYS EtherCATを使用するプロジェクトでは、未解決の参照が表示されなくなります。 CmpCXSecUPS 運転者 このドライバは、ベッコフのCX5000またはCX5100シリーズの「組み込みPC」でのみ使用できます。 コンポーネントは、通信タスクの優先度の低い周期的な呼び出しで電源の状態を監視するピンを監視します。 停電が検出されると、アプリケーションが停止し、保持データがファイルに保存されます (通常は Application.ret ）。 注：保持データを保存する場合、次の制限があります。 PLCの現在の負荷によっては、停電の検出が遅れる場合があります。 PCの負荷によって、停電後のデータ保存に使用できる時間は異なります。 これらの制限により、完成したアプリケーションで保持データのストレージをテストする必要があります。さらに、アプリケーションの開始時に残留変数の有効性を確認することをお勧めします。 コンポーネントには構成オプションがありません。コントローラのコンポーネントリストにのみ追加する必要があります。 詳細については、以下を参照してください。 RTEのレジストリエントリ " }, 
{ "title" : "RTEのレジストリエントリ ", 
"url" : "_rtsl_windows_rte_v3_registry_entries.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ CODESYS コントロール RTE V3 \/ RTEのレジストリエントリ ", 
"snippet" : "の振る舞い CODESYS Control RTE Windowsレジストリエディタ（Windowsレジストリ）で部分的に構成できます。次の表に、値が欠落している場合に使用される値とそれぞれのデフォルト値に関する情報を示します。これらの値の一部のみを変更できます PLC構成 のダイアログ CODESYS Control RTE 。 すべての値は、レジストリのパスにあります HKEY_LOCAL_MACHINE\\SOFTWARE\\3S-Smart Software Solutions GmbH\\CODESYS SP\\3SRTE3 、またはテーブル内の名前の前にキーが指定されている場合は相対。 名...", 
"body" : "の振る舞い CODESYS Control RTE Windowsレジストリエディタ（Windowsレジストリ）で部分的に構成できます。次の表に、値が欠落している場合に使用される値とそれぞれのデフォルト値に関する情報を示します。これらの値の一部のみを変更できます PLC構成 のダイアログ CODESYS Control RTE 。 すべての値は、レジストリのパスにあります HKEY_LOCAL_MACHINE\\SOFTWARE\\3S-Smart Software Solutions GmbH\\CODESYS SP\\3SRTE3 、またはテーブル内の名前の前にキーが指定されている場合は相対。 名前 タイプ 意味 デフォルト値 AutoStartPLC DWORD 0 また 1 ： と 1 、PLCはシステムサービスによって自動的に開始されます。 0 AllowSetAppConfiguration DWORD 0 また 1 ：ユーザーがダイアログを使用しての値を設定できるかどうかを決定します 応用 構成ダイアログ。 1 AllowSetCMConfiguration DWORD 0 オーデル 1 ：<前のエントリと同じ方法> 1 AllowSetFileConfiguration DWORD 0 オーデル 1 ：<前のエントリと同じ方法> 1 AllowSetLoggerConfiguration DWORD 0 オーデル 1 ：<前のエントリと同じ方法> 1 AllowSetSchedConfiguration DWORD DWORD 0 オーデル 1 ：<前のエントリと同じ方法> 1 AllowSetTargetConfiguration DWORD 0 オーデル 1 ：<前のエントリと同じ方法> 1 CallBuffersize DWORD 非同期関数呼び出し（Windowsから実行されるすべての関数呼び出し（ファイルサービスやソケット関数など）のバッファーのサイズ）。アプリケーションが必要とする同時呼び出しが多いほど、パフォーマンス上の理由から、このバッファーを大きくする必要があります。 65536 CfgFile STRING この値は、の構成ファイルを直接指します。 CODESYS Control RTE 。 <のインストールパス CODESYS Control RTE >> DisablePlcAutoStart DWORD この値は、内部で使用されます PLC構成 ダイアログ。この変数は、たとえば構成ダイアログがクラッシュし、変数が書き込みを行わなくなった場合にのみ、手動で変更できます。 0 自動的。 0 ShowAppConfiguration DWORD 0 また 1 ：ユーザーが表示できるかどうかを決定します 応用 のタブ PLC構成 ダイアログ。 1 ShowCMConfiguration DWORD 0 オーデル 1 ：<前のエントリと同じ方法> 1 ShowFileConfiguration DWORD 0 オーデル 1 ：<前のエントリと同じ方法> 1 ShowLoggerConfiguration DWORD 0 オーデル 1 ：<前のエントリと同じ方法> 1 ShowSchedConfiguration DWORD 0 オーデル 1 ：<前のエントリと同じ方法> 1 ShowTargetConfiguration DWORD 0 オーデル 1 ：<前のエントリと同じ方法> 1 LastExit DWORD 0 また 1 RTEからの最後の終了が成功したかどうかを制御するため。 1 Path STRING この値は、のファイルシステムのルートパスであるディレクトリを指します。 CODESYS Control RTE 。 <のインストールパス CODESYS Control RTE >> SysTrayLocalPort DWORD 「SysTray」とのシステムサービス間でローカルに通信が行われるTCP \/ IPポート CODESYS Control RTE 。 15965 SysTrayRemoteAddr DWORD DWORD の「SysTray」で管理する必要のあるリモートシステムのIPアドレス CODESYS Control RTE 。 0 SysTrayRemotePort DWORD と同じ SysTrayLocalPort ;リモートシステム用。 15965 SysTrayUseRemotePLC DWORD 0 また 1 ：ローカルPCか CODESYS Control RTE 別のPC（リモートシステム）で対処する必要があります。 0 KernelVersion STRING のバージョン CODESYS Control RTE それはこのPCで前回開始されました。毎回書かれる CODESYS Control RTE 開始します。 <バージョンID> VersionSrv STRING のシステムサービスのバージョン CODESYS Control RTE 。テスト目的でカーネルまたはシステムサービスを別のバージョンに手動で置き換えた手動パッチを除いて、常にカーネルと同じバージョンである必要があります。 <バージョンID> IO Driverpool KEY このキーのすべてのサブキーは、で使用可能なコンポーネントのリストボックスに表示されます。 PLC構成 ダイアログ。 StackSizePerTask DWORD 必要な場合の各タスクのスタックのサイズ（複雑な関数呼び出しの原因不明のクラッシュ）。 0x6000 （24 KB） CreateBluescreenOnFirstException DWORD 発生する最初の例外は、死のブルースクリーンを生成する必要があります（したがって、診断目的で使用されるコアダンプです。 カーネルメモリ のWindowsシステム設定で選択する必要があります 開始して復元 。 0 詳細については、以下を参照してください。 特別なプラットフォームでのリアルタイム動作の構成 " }, 
{ "title" : "パフォーマンス最適化 ", 
"url" : "_rtsl_performance_realtime_windows.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ パフォーマンス最適化 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "「ソフトリアルタイム」動作 CODESYS Control Win ", 
"url" : "_rtsl_performance_realtime_windows.html#UUID-260b1b52-f206-9ca7-1cd0-920e224c4997_section-idm43415804467536", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ 構成と拡張 \/ パフォーマンス最適化 \/ 「ソフトリアルタイム」動作 CODESYS Control Win ", 
"snippet" : "の CODESYS Control Win は Windows 上で「リアルタイム」プロセスとして動作しますが、これは PLC のハード リアルタイム要件と同等ではありません。レイテンシーとジッター時間は数ミリ秒の範囲内です。例外的に、数 10 ミリ秒になることもあります。この遅延は、Windows カーネルの負荷、ネットワーク負荷、好ましくないドライバーや古いドライバーの使用、コンピューターのパフォーマンスなど、多くの要因によって決まります。 これらの遅延により、 CODESYS Control Win 一般的なモーションアプリケーションには適していません。 一般に、実際のアプリケーションの...", 
"body" : "の CODESYS Control Win は Windows 上で「リアルタイム」プロセスとして動作しますが、これは PLC のハード リアルタイム要件と同等ではありません。レイテンシーとジッター時間は数ミリ秒の範囲内です。例外的に、数 10 ミリ秒になることもあります。この遅延は、Windows カーネルの負荷、ネットワーク負荷、好ましくないドライバーや古いドライバーの使用、コンピューターのパフォーマンスなど、多くの要因によって決まります。 これらの遅延により、 CODESYS Control Win 一般的なモーションアプリケーションには適していません。 一般に、実際のアプリケーションの要件は、アプリケーションの機能と制限に照らして検証する必要があります。 CODESYS Control Win 特定の PC 上で。多くの境界条件があるため、予想される最大ジッター時間について一般的に述べるのは不可能です。 " }, 
{ "title" : "リファレンス ", 
"url" : "_rtsl_reference_windows.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ リファレンス ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "ダイアログ ", 
"url" : "_rtsl_reference_dialogs.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ リファレンス \/ ダイアログ ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "ダイアログ：オプション–ランタイムデプロイツール ", 
"url" : "_rtsl_dlg_options_runtime_deploy_tool.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ リファレンス \/ ダイアログ \/ ダイアログ：オプション–ランタイムデプロイツール ", 
"snippet" : "シンボル： 関数 ：ダイアログでは、SSH秘密鍵を管理するために開発システムのファイルシステムにアクセスできます。 電話 ： ツール→オプション メニュー、 ランタイムデプロイツール カテゴリー 要件 ：ダイアログは、少なくとも1つが存在する場合にのみ使用できます CODESYS SL製品がインストールされました。の ツール→パッケージマネージャー 、インストールされている製品を確認できます。 SSHキー 鍵 秘密鍵として機能するOPENSSHファイルの名前 例： serviceuser.openssh 注：正確性がチェックされたキーファイルのみが表示されます。 道 SSHキーの場所 例： D...", 
"body" : "シンボル： 関数 ：ダイアログでは、SSH秘密鍵を管理するために開発システムのファイルシステムにアクセスできます。 電話 ： ツール→オプション メニュー、 ランタイムデプロイツール カテゴリー 要件 ：ダイアログは、少なくとも1つが存在する場合にのみ使用できます CODESYS SL製品がインストールされました。の ツール→パッケージマネージャー 、インストールされている製品を確認できます。 SSHキー 鍵 秘密鍵として機能するOPENSSHファイルの名前 例： serviceuser.openssh 注：正確性がチェックされたキーファイルのみが表示されます。 道 SSHキーの場所 例： D:\\PLCs\\Keys\\serviceuser.openssh 追加 ファイル管理ダイアログを開きます そこで、秘密鍵を含む鍵ファイル（OPENSSHファイル）を選択します。ファイルはにリンクされています ランタイムデプロイツール 。 ヒント：開発用コンピューターの秘密鍵を適切な場所または秘密の場所に保存します。 注：秘密鍵は絶対に共有しないでください。 削除する 選択したキーファイルへのリンクを削除します わかった 設定を受け入れてダイアログを閉じます キャンセル ダイアログを閉じます " }, 
{ "title" : "ダイアログ：システム構成–診断 ", 
"url" : "_rtsl_dlg_system_config_diagnosis.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ リファレンス \/ ダイアログ \/ ダイアログ：システム構成–診断 ", 
"snippet" : "電話 ： CODESYS Control RTE ステータスバーのメニュー The システム構成 最初のダイアログが開きます 診断 タブ。これには、コントローラーからのさまざまな状態とIDに関する情報が含まれています。...", 
"body" : "電話 ： CODESYS Control RTE ステータスバーのメニュー The システム構成 最初のダイアログが開きます 診断 タブ。これには、コントローラーからのさまざまな状態とIDに関する情報が含まれています。 " }, 
{ "title" : "ダイアログ：システム構成–ターゲット ", 
"url" : "_rtsl_dlg_system_config_target.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ リファレンス \/ ダイアログ \/ ダイアログ：システム構成–ターゲット ", 
"snippet" : "電話： CODESYS Control RTE ステータスバーのメニュー、次に 目標 タブ インストールされたものの固定名 CODESYS Control RTE で指定できます ターゲット名 。デフォルトでは、PLCはそれが実行されているコンピュータの名前でレポートします。...", 
"body" : "電話： CODESYS Control RTE ステータスバーのメニュー、次に 目標 タブ インストールされたものの固定名 CODESYS Control RTE で指定できます ターゲット名 。デフォルトでは、PLCはそれが実行されているコンピュータの名前でレポートします。 " }, 
{ "title" : "ダイアログ：システム構成–ファイル ", 
"url" : "_rtsl_dlg_system_config_file.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ リファレンス \/ ダイアログ \/ ダイアログ：システム構成–ファイル ", 
"snippet" : "電話： CODESYS Control RTE ステータスバーのメニュー、次に ファイル タブ 上のさまざまなファイルタイプのデフォルトの場所 CODESYS Control RTE ここで構成できます。 ファイル 相対ファイルパス RTEの作業ディレクトリの相対パス（ C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 ）。 このファイルパスに保存するファイル（例：* .app、*。crc） ファイルパスに保存する必要のあるファイルの種類。カンマ区切りのリスト（例： *.app, *.crc ）。...", 
"body" : "電話： CODESYS Control RTE ステータスバーのメニュー、次に ファイル タブ 上のさまざまなファイルタイプのデフォルトの場所 CODESYS Control RTE ここで構成できます。 ファイル 相対ファイルパス RTEの作業ディレクトリの相対パス（ C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 ）。 このファイルパスに保存するファイル（例：* .app、*。crc） ファイルパスに保存する必要のあるファイルの種類。カンマ区切りのリスト（例： *.app, *.crc ）。 " }, 
{ "title" : "ダイアログ：システム構成–スケジューラー ", 
"url" : "_rtsl_dlg_system_config_scheduler.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ リファレンス \/ ダイアログ \/ ダイアログ：システム構成–スケジューラー ", 
"snippet" : "電話： CODESYS Control RTE ステータスバーのメニュー、次に スケジューラー タブ ランタイムシステムのタスクスケジューラの設定はここにあります。これらは、負荷監視の実行方法と、制限値違反の場合の動作に影響を与えます。これらの設定の変更は、特別な要求がある場合にのみ必要です。 プロセッサの負荷 最大。プロセッサの負荷 システムの負荷制限 このCPU負荷の時点で、例外がスローされるか、タイムスライシングが開始されます。 この設定を変更すると、コントローラーの障害（例外）が発生する可能性があります。 詳細については、以下を参照してください。 CODESYS Control V3 ...", 
"body" : "電話： CODESYS Control RTE ステータスバーのメニュー、次に スケジューラー タブ ランタイムシステムのタスクスケジューラの設定はここにあります。これらは、負荷監視の実行方法と、制限値違反の場合の動作に影響を与えます。これらの設定の変更は、特別な要求がある場合にのみ必要です。 プロセッサの負荷 最大。プロセッサの負荷 システムの負荷制限 このCPU負荷の時点で、例外がスローされるか、タイムスライシングが開始されます。 この設定を変更すると、コントローラーの障害（例外）が発生する可能性があります。 詳細については、以下を参照してください。 CODESYS Control V3 ランタイムシステムのドキュメント " }, 
{ "title" : "ダイアログ：システム構成–ロガー ", 
"url" : "_rtsl_dlg_system_config_logger.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ リファレンス \/ ダイアログ \/ ダイアログ：システム構成–ロガー ", 
"snippet" : "電話： CODESYS Control RTE ステータスバーのメニュー、次に ロガー タブ PLCからのログメッセージを1つまたは複数のファイルに保存するための設定がここにあります。 標準ロガー 有効 ：ブートアプリケーションはダウンロード時に暗黙的に生成されますが、プロジェクトはメモリにダウンロードされません。 バックエンドファイル 有効 ： ：ログメッセージを含む1つ以上のファイルが作業ディレクトリに作成されます（ C:\\ProgramData\\CODESYS\\CODESYSControlRTE ）。必要に応じて、最も古いファイルが上書きされます。 最大。ファイル ：ファイルの最大数。 ...", 
"body" : "電話： CODESYS Control RTE ステータスバーのメニュー、次に ロガー タブ PLCからのログメッセージを1つまたは複数のファイルに保存するための設定がここにあります。 標準ロガー 有効 ：ブートアプリケーションはダウンロード時に暗黙的に生成されますが、プロジェクトはメモリにダウンロードされません。 バックエンドファイル 有効 ： ：ログメッセージを含む1つ以上のファイルが作業ディレクトリに作成されます（ C:\\ProgramData\\CODESYS\\CODESYSControlRTE ）。必要に応じて、最も古いファイルが上書きされます。 最大。ファイル ：ファイルの最大数。 0 これは、ファイルが上書きされず、すべてのログエントリがアーカイブされることを意味します。 最大。ファイルサイズ ：ファイルの最大サイズ。 最大。エントリ ：ファイル内のログエントリの最大数。 詳細については、以下を参照してください。 タブ：ログ " }, 
{ "title" : "ダイアログ：システム構成–アプリケーション ", 
"url" : "_rtsl_dlg_system_config_application.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ リファレンス \/ ダイアログ \/ ダイアログ：システム構成–アプリケーション ", 
"snippet" : "電話： CODESYS Control RTE ステータスバーのメニュー、次に 応用 タブ ここでは、PLCのアプリケーションコンポーネントの設定を行います。 ブートアプリケーション ダウンロード時に作成 ：ブートアプリケーションは、ダウンロード時に暗黙的に生成されます。 ダウンロード時にのみ保存 ：ブートアプリケーションはダウンロード時に暗黙的に生成されますが、プロジェクトはメモリにダウンロードされません。 （特別なアプリケーションのみ） 不一致を保持する際の動作 破損した保持データの場合のPLCの動作のオプション： ロードしないでください ：ブートアプリケーションがロードされていません。 ...", 
"body" : "電話： CODESYS Control RTE ステータスバーのメニュー、次に 応用 タブ ここでは、PLCのアプリケーションコンポーネントの設定を行います。 ブートアプリケーション ダウンロード時に作成 ：ブートアプリケーションは、ダウンロード時に暗黙的に生成されます。 ダウンロード時にのみ保存 ：ブートアプリケーションはダウンロード時に暗黙的に生成されますが、プロジェクトはメモリにダウンロードされません。 （特別なアプリケーションのみ） 不一致を保持する際の動作 破損した保持データの場合のPLCの動作のオプション： ロードしないでください ：ブートアプリケーションがロードされていません。 例外を除いてロード ：ブートアプリケーションはロードされていますが、開始されていません。例外がスローされます。 保持をロードして初期化します ：ダウンロード後と同様に、ブートアプリケーションがロードおよび初期化されます。 ブートアプリケーションを無効にする コントローラが適切に終了しない場合のブートアプリケーションの無効化に関するオプション： 一度もない ：ブートアプリケーションが無効になることはありません。 設定することにより ：PLCの設定ファイルで起動アプリケーションが無効と宣言されています（ *.cfg ）。 名前を変更する ： *.app ブートアプリケーションのファイルの名前が変更され、ブートアプリケーションが無効になります。 タイプを保持 保持ファイルを保存するためのオプション CODESYS Control RTE ： なし ：データは保存されず、PLCは保持データを使用できません。 SRAM ：PLCは、データの保持に物理的な不揮発性メモリを使用できます。 停電時 ：コントローラのシャットダウン時にリテインデータをファイルに保存します。このために、システムには UPS が装備されている必要があります。その後、停電もカバーされます。 永続的な力 有効にすると、コントローラーの再起動後も強制値が保持されます。 詳細については、以下を参照してください。 ブートアプリケーションの作成 " }, 
{ "title" : "ダイアログ：システム構成–コンポーネントマネージャー ", 
"url" : "_rtsl_dlg_system_config_component_manager.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ リファレンス \/ ダイアログ \/ ダイアログ：システム構成–コンポーネントマネージャー ", 
"snippet" : "電話： CODESYS Control RTE ステータスバーのメニュー、次に コンポーネントマネージャー タブ デフォルトでPLCによってロードされない追加のコンポーネントがここで管理されます。 詳細については、以下を参照してください。 利用可能な動的コンポーネントコンポーネントマネージャー Plc構成パス PLCのファイルシステムのルートパス。例： C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 追加コンポーネント デフォルトでPLCによってダウンロードされないコンポーネントは、ここで入力\/選択できます。...", 
"body" : "電話： CODESYS Control RTE ステータスバーのメニュー、次に コンポーネントマネージャー タブ デフォルトでPLCによってロードされない追加のコンポーネントがここで管理されます。 詳細については、以下を参照してください。 利用可能な動的コンポーネントコンポーネントマネージャー Plc構成パス PLCのファイルシステムのルートパス。例： C:\\ProgramData\\CODESYS\\CODESYSControlRTEV3 追加コンポーネント デフォルトでPLCによってダウンロードされないコンポーネントは、ここで入力\/選択できます。 " }, 
{ "title" : "ダイアログ：システム構成–スタートアップ ", 
"url" : "_rtsl_dlg_system_config_startup.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ リファレンス \/ ダイアログ \/ ダイアログ：システム構成–スタートアップ ", 
"snippet" : "電話： CODESYS Control RTE ステータスバーのメニュー、次に 起動 タブ 開始に関するオプションの1つを選択します CODESYS Control RTE ： 起動 起動時にRTE基本システムサービスを開始します システムサービス（表示名 \" 3S RTE Service V3 \"）は、システムの起動時に自動的に開始されます。このようにして、ユーザーがログインする前にサービスを利用できます。 基本システムサービスでPLCを起動します PLCは、システムサービスの開始時に開始されます。最初のオプションとともに、PCが起動した直後にPLCが起動します。 ブートアプリケーションをロ...", 
"body" : "電話： CODESYS Control RTE ステータスバーのメニュー、次に 起動 タブ 開始に関するオプションの1つを選択します CODESYS Control RTE ： 起動 起動時にRTE基本システムサービスを開始します システムサービス（表示名 \" 3S RTE Service V3 \"）は、システムの起動時に自動的に開始されます。このようにして、ユーザーがログインする前にサービスを利用できます。 基本システムサービスでPLCを起動します PLCは、システムサービスの開始時に開始されます。最初のオプションとともに、PCが起動した直後にPLCが起動します。 ブートアプリケーションをロードしないでください PLCは、自動起動のためにブートアプリケーションをロードしません。 " }, 
{ "title" : "コマンド ", 
"url" : "_rtsl_commands.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ リファレンス \/ コマンド ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "システム トレイのメニュー ", 
"url" : "_rtsl_cmd_menu.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ リファレンス \/ コマンド \/ システム トレイのメニュー ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS Control ", 
"url" : "_rtsl_cmd_menu.html#UUID-dc0920ec-91e3-5d46-7959-a04fb4357af3_section-idm4616768769337633167655660684", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ リファレンス \/ コマンド \/ システム トレイのメニュー \/ CODESYS Control ", 
"snippet" : "のユーザー インターフェイスへのアクセス CODESYS Control Win によってあなたに付与されます お使いの PC のシステム トレイ (「システム トレイ」) の記号。 を右クリックします。 次のコマンドでメニューを開くための記号： PLCを起動 : PLC の電源を入れます。ステータス バーの記号が . 注: システムの起動時に PLC を自動的にオンにする必要がある場合は、サービスのプロパティで対応する起動オプションを設定する必要があります。詳細については、ヘルプ ページ「インストールと開始」を参照してください。 PLCを停止 : PLC の電源をオフにします。記号が に変わ...", 
"body" : "のユーザー インターフェイスへのアクセス CODESYS Control Win によってあなたに付与されます お使いの PC のシステム トレイ (「システム トレイ」) の記号。 を右クリックします。 次のコマンドでメニューを開くための記号： PLCを起動 : PLC の電源を入れます。ステータス バーの記号が . 注: システムの起動時に PLC を自動的にオンにする必要がある場合は、サービスのプロパティで対応する起動オプションを設定する必要があります。詳細については、ヘルプ ページ「インストールと開始」を参照してください。 PLCを停止 : PLC の電源をオフにします。記号が に変わります . PLC 制御を終了 : システム トレイでのユーザー メニューの使用を終了します。シンボルは削除されますが、PLC は引き続き実行されます。システム トレイの表示を担当する実行可能ファイルは次のとおりです。 CODESYSControlSysTray.exe .サブディレクトリのインストール ディレクトリにあります。 GatewayPLC の CODESYS Control Win . 約 : インストール済みのバージョン情報を表示します CODESYS Control Win " }, 
{ "title" : "CODESYS Control RTE ", 
"url" : "_rtsl_cmd_menu.html#UUID-dc0920ec-91e3-5d46-7959-a04fb4357af3_section-idm4544772591294433167656742159", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ リファレンス \/ コマンド \/ システム トレイのメニュー \/ CODESYS Control RTE ", 
"snippet" : "のユーザー インターフェイスへのアクセス CODESYS Control RTE は、PC のシステム トレイ (「システム トレイ」) のシンボルによって付与されます。 を右クリックします。 次のコマンドでメニューを開くための記号： PLCを起動 : PLC の電源を入れます。記号が に変わります . PLCを停止 : PLC の電源をオフにします。記号が に変わります . PLC 制御を終了 : の制御 CODESYS Control RTE システムトレイを使用することはできなくなりました。シンボルは削除されますが、PLC は引き続き実行されます。 PLC 構成 ：開く システム構成 ダ...", 
"body" : "のユーザー インターフェイスへのアクセス CODESYS Control RTE は、PC のシステム トレイ (「システム トレイ」) のシンボルによって付与されます。 を右クリックします。 次のコマンドでメニューを開くための記号： PLCを起動 : PLC の電源を入れます。記号が に変わります . PLCを停止 : PLC の電源をオフにします。記号が に変わります . PLC 制御を終了 : の制御 CODESYS Control RTE システムトレイを使用することはできなくなりました。シンボルは削除されますが、PLC は引き続き実行されます。 PLC 構成 ：開く システム構成 ダイアログ。さまざまなタブには、診断情報と構成設定が含まれています CODESYS Control RTE . リモートPLC ：開く リモート構成 ダイアログ。を有効または無効にすることにより、 ローカルではなく、リモート PC を制御する オプションで、リモート PC またはローカル PC のどちらにある PLC を使用するかを決定します。したがって、メニューコマンド PLCを起動 、 PLCを停止 、 と PLC 構成 ローカル PC またはネットワーク上に到達した PC を参照してください。リモート PC の場合は、 ターゲット PC アドレス 、 ポート番号 、および タイムアウト 接続の値 (ミリ秒単位) ( リモート タイムアウト [ミリ秒] ）。 約 : インストール済みのバージョン情報を表示します CODESYS Control RTE " }, 
{ "title" : "コマンド：EdgeGatewayを更新します ", 
"url" : "_rtsl_cmd_update_edge_gateway.html", 
"breadcrumbs" : "CODESYS Control \/ Windows ベースのランタイム システム \/ リファレンス \/ コマンド \/ コマンド：EdgeGatewayを更新します ", 
"snippet" : "関数 ：コマンドは エッジゲートウェイ 見る。ビューでは、Edge Gatewayパッケージ（DEBファイル）をインストール、開始、および停止できます。さらに、試運転とアプリケーション開発をサポートする機能がシステムおよびランタイムレベルで提供されます。 電話 ： ツール メニュー ログイン認証情報 ユーザー名 Linuxコンピューターのユーザー名とパスワード パスワード ターゲットを選択 IPアドレス ターゲットデバイスのIPアドレスまたは名前 例： 192.168.99.39 スキャン を開きます スキャンエッジゲートウェイ ダイアログ 現在ネットワークに接続されており、デバイス タイプに...", 
"body" : "関数 ：コマンドは エッジゲートウェイ 見る。ビューでは、Edge Gatewayパッケージ（DEBファイル）をインストール、開始、および停止できます。さらに、試運転とアプリケーション開発をサポートする機能がシステムおよびランタイムレベルで提供されます。 電話 ： ツール メニュー ログイン認証情報 ユーザー名 Linuxコンピューターのユーザー名とパスワード パスワード ターゲットを選択 IPアドレス ターゲットデバイスのIPアドレスまたは名前 例： 192.168.99.39 スキャン を開きます スキャンエッジゲートウェイ ダイアログ 現在ネットワークに接続されており、デバイス タイプに対応するすべてのデバイスが、IP アドレスとそれぞれの MAC アドレス (括弧内) とともにここに一覧表示されます。デバイス タイプは、MAC アドレスによって識別されます。 例： 192.168.123.123(BB:27:EB:FA:98:52) CODESYS Edge Gateway for Linux パッケージ バージョン インストールするEdgeGatewayのバージョンとアーキテクチャ 例： V3.5.15.0 (amd64) インストール 設定されたバージョンとアーキテクチャでEdgeGatewayパッケージのインストール操作を開始します。 削除する 現在実行中のインストールを削除します Linux 端末 その後、任意のバージョンをインストールできます。 パッケージディレクトリ Edge Gatewayがパッケージ化するフォルダー（ *.deb ）があります。 追加パッケージ インストール 追加のLinuxパッケージをPLCにインストールするか、既存のパッケージを更新します 例：WibuCodeMeterランタイムパッケージ。 Wibu Systemsホームページからパッケージをダウンロードし、このコマンドを使用してPLCにインストールまたは更新できます。 管理 インストールされているすべてのパッケージと追加情報を表示するダイアログを開きます このダイアログで個々のパッケージをアンインストールできます。 システム システム情報 を開きます システム情報<ユーザー名> @IPアドレス ダイアログ 例： システム情報root@192.168.123.123 ターゲットを再起動します PLCでシステムを再起動します Edge Gateway 始める エッジゲートウェイを開始します やめる エッジゲートウェイを停止します " }
]
$(document).trigger('search.ready');
});