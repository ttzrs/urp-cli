$(document).ready(function () {indexDict['ja'] = [{ "title" : "CODESYS String Libraries ", 
"url" : "_strlib_start_page.html", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "はじめに ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4664735744121633736389596078", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ はじめに ", 
"snippet" : "の図書館 CODESYS String Libraries パッケージは UTF-8 でエンコードされた文字列の処理に使用できます。基本は IString からのインターフェイス String Segments ライブラリ。このインターフェースを使うと、文字列をそれぞれの関数に参照渡すことができます。たとえば、を作成するには IString インスタンス、 GSB.UTF8String からのファンクションブロック Generic String Base ライブラリが提供されています。 パッケージには次のライブラリが付属しています。 String Segments の基本機能 IString ...", 
"body" : "の図書館 CODESYS String Libraries パッケージは UTF-8 でエンコードされた文字列の処理に使用できます。基本は IString からのインターフェイス String Segments ライブラリ。このインターフェースを使うと、文字列をそれぞれの関数に参照渡すことができます。たとえば、を作成するには IString インスタンス、 GSB.UTF8String からのファンクションブロック Generic String Base ライブラリが提供されています。 パッケージには次のライブラリが付属しています。 String Segments の基本機能 IString インスタンス 文字列セグメントライブラリのドキュメンテーション String Builder UTF-8 でエンコードされた文字列セグメントの効率的な管理 文字列ビルダーライブラリのドキュメント String Conversions 異なるエンコーディングの文字列のUTF-8への変換、またはUTF-8からの変換 文字列変換ライブラリドキュメンテーション String Functions 従来の標準ライブラリの例に従ってUTF-8でエンコードされた文字列を処理する関数。 文字列関数ライブラリドキュメンテーション Unicode Support Unicode 文字カテゴリを処理するための関数。 Unicode サポート関数ライブラリドキュメンテーション UTF-16 Encoding Support UTF-16 でエンコードされたメモリ領域を処理するための基本関数 UTF-16 エンコーディングサポートライブラリドキュメンテーション UTF-8 Encoding Support UTF-8 でエンコードされたメモリ領域を処理するための基本関数 UTF-8 エンコーディングサポート関数ライブラリドキュメンテーション Generic String Base メモリを静的に管理するUTF-8でエンコードされた文字列を処理するためのファンクションブロック GENERIC CONSTANT 。 汎用文字列ベース関数ライブラリドキュメンテーション " }, 
{ "title" : "新しい文字列ライブラリの利点 ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4563869800648033733012917566", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ 新しい文字列ライブラリの利点 ", 
"snippet" : "新しい文字列ライブラリは、使い慣れた古い文字列関数に取って代わるものではありません。 Standard と Standard64 ライブラリ。とはいえ、新しいプロジェクトには新しい文字列ライブラリを使用することをお勧めします。 新しい文字列ライブラリでは、大きな文字列も効率的に処理できます。文字列の長さはほぼ無制限です。そのため、ライブラリはサイズの大きいテキストファイルや Web コンテンツの編集にも適しています。 その他の利点: UTF-8は、すべての文字をUNICODEに従って表現できるエンコーディングです。 UTF-8 はインターネット上で広く使用されており、ワールド・ワイド・ウェブ・...", 
"body" : "新しい文字列ライブラリは、使い慣れた古い文字列関数に取って代わるものではありません。 Standard と Standard64 ライブラリ。とはいえ、新しいプロジェクトには新しい文字列ライブラリを使用することをお勧めします。 新しい文字列ライブラリでは、大きな文字列も効率的に処理できます。文字列の長さはほぼ無制限です。そのため、ライブラリはサイズの大きいテキストファイルや Web コンテンツの編集にも適しています。 その他の利点: UTF-8は、すべての文字をUNICODEに従って表現できるエンコーディングです。 UTF-8 はインターネット上で広く使用されており、ワールド・ワイド・ウェブ・コンソーシアム (W3C) によって推奨されています。 UTF-8 は ASCII 互換のため、レガシーシステムと互換性があります。 UTF-8 は高レベルの相互運用性を提供します。 UTF-8 はメモリの最適化に役立ちます。 新しい文字列ライブラリでは、他の高級言語と同じように、対応するメソッドを使用して以前に定義した文字列をクエリできます。 文字列メソッドの例: Len() udiStringLen := myString.Len();\nif udiStringLen = 22 THEN\n... 現在 CODESYS 3.5.18.0 では、型変数の内容を解釈するようにコンパイラーを設定できます。 STRING UTF-8 エンコーディングとして。を選択します。 文字列の UTF-8 エンコーディング の「オプション」 [プロジェクト設定] で コンパイルオプション カテゴリー。 すべてを治療したくない場合 STRING プロジェクト内の変数が UTF-8 でエンコードされている場合は、このオプションをオフにする必要があります。その後、の個々のリテラルに UTF-8 エンコーディングを適用できます STRING ケースバイケースで入力してください。 リテラルの UTF-8 エンコーディング {attribute 'monitoring_encoding' := 'UTF-8'}\nsValue : STRING(140) := UTF8#'Ðα ṧтℯ♄ ḯḉℌ ηuη, i¢ℌ αямℯґ 𝕋øґ‼ Ṳᾔⅾ ♭ḯη ＄☺ ḱℓυℊ αł＄ ωⅈ℮ ẕυ√◎ґ'; UTF-8 エンコーディングの機能のおかげで、UTF-8 エンコーディングを使用する必要はありません WSTRING データタイプ: CODESYS 拡張文字セットを使用すること。UCS-2 エンコーディング WSTRING をベースにしているため、アプリケーションによっては UTF-8 エンコーディングよりも多くのメモリが必要になる場合があります。UCS-2 エンコーディングでは常に WORD 1 文字あたり。1 文字のみを表すことができます。 U+0000 に U+D800 そして U+DFFF へ U+FFFD 。UTF-8 エンコーディングには、1 文字あたり 1 バイトから 4 バイトが必要です。その結果、すべての Unicode 文字を処理できます UTF-8 エンコーディングでは、特定のインデックスを使用して特定の文字を取得しようとすると、可変長が原因で予期しない結果になります。 可変長のエンコーディング {attribute 'monitoring_encoding' := 'UTF-8'}\nsValue : STRING(140) := UTF8#'Ðα ṧтℯ♄ ḯḉℌ ηuη, i¢ℌ αямℯґ 𝕋øґ‼ Ṳᾔⅾ ♭ḯη ＄☺ ḱℓυℊ αł＄ ωⅈ℮ ẕυ√◎ґ';\n\nbyValue := sValue[13]; \/\/ The 'u' is NOT the 13th character in the string\nxOk := byValue <> 16#75; 文字列を繰り返し処理して文字のインデックスを決定する必要があります。 UTF-8 でエンコードされた文字列の繰り返し VAR\t\n {attribute 'monitoring_encoding' := 'UTF-8'}\n sValue : STRING(140) := UTF8#'Ðα ṧтℯ♄ ḯḉℌ ηuη, i¢ℌ αямℯґ 𝕋øґ‼ Ṳᾔⅾ ♭ḯη ＄☺ ḱℓυℊ αł＄ ωⅈ℮ ẕυ√◎ґ';\n\n fbsValue : STR.UTF8Literal := (psValue:=ADR(sValue)); \n fbRange : STR.Range := (itfString:=fbsValue);\n diRune : STR.RUNE;\n udiIndex, udiLength : UDINT;\n xOk : BOOL;\nEND_VAR\n \nWHILE (diRune := fbRange.GetNextRune(udiLength=>udiLength)) <> 0 DO\n IF diRune = 16#75 (* 'u' *) THEN\n EXIT;\n END_IF\n udiIndex := udiIndex + udiLength;\nEND_WHILE\n \nxOk := sValue[udiIndex] = 16#75 (* 'u' *); " }, 
{ "title" : "確立された企業のデメリット STRING 関数 ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4613761597678433733013344138", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ 確立された企業のデメリット STRING 関数 ", 
"snippet" : "以前に設立された STRING 標準ライブラリの関数 (型のパラメーター) STRING 関数に渡されるときにコピーされます。戻り値も代入された変数にコピーされます。 確立されたSTRING関数に関する問題 VAR sValue : STRING; END_VAR sValue := CONCAT(CONCAT(CONCAT('Da steh ich nun,', ' ich armer Tor!'), ' Und bin so'), ' klug als wie zu vor'); \/\/ -> Copy, LEN -> Copy, LEN -> Copy, LEN -> Copy, LEN ...", 
"body" : "以前に設立された STRING 標準ライブラリの関数 (型のパラメーター) STRING 関数に渡されるときにコピーされます。戻り値も代入された変数にコピーされます。 確立されたSTRING関数に関する問題 VAR\n sValue : STRING;\nEND_VAR\n \nsValue := CONCAT(CONCAT(CONCAT('Da steh ich nun,', ' ich armer Tor!'), ' Und bin so'), ' klug als wie zu vor');\n\/\/ -> Copy, LEN -> Copy, LEN -> Copy, LEN -> Copy, LEN\n\/\/ -> 2xCopy, LEN\n\/\/ -> 2xCopy, LEN\n\/\/ -> 2xCopy, LEN タイプのパラメータを処理する前に STRING それぞれの関数では、その長さは終端の NULL 文字まで繰り返し処理して決定しなければならないことが多い。文字列が長い場合、このようなコピー操作や繰り返し操作を行うと、アプリケーションの処理時間が長くなります。これらの関数を適用する場合、文字列の長さは 255 文字に制限されています " }, 
{ "title" : "を使用する IString インターフェイス ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4598276788502433733013693363", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ を使用する IString インターフェイス ", 
"snippet" : "ザル STR.IString 文字列に関する情報を管理するデータ構造を参照渡しするためのインタフェースが導入されました。これは、これを実装していない以前に確立された STRING 関数との大きな違いです STR.IString インターフェイス。 さらに、文字列のサイズ (UTF-8 でエンコードされた文字に対応するメモリ) は、数値範囲内であってもかまいません。 UDINT 4 ≦ udiSize ≦ 16#FFFF_FF00 )。 前述のデータ構造では、以下の情報が最新の状態に保たれているため、処理ステップの前に毎回再計算する必要はありません。 それぞれのメモリセグメントへの参照 現在の容...", 
"body" : "ザル STR.IString 文字列に関する情報を管理するデータ構造を参照渡しするためのインタフェースが導入されました。これは、これを実装していない以前に確立された STRING 関数との大きな違いです STR.IString インターフェイス。 さらに、文字列のサイズ (UTF-8 でエンコードされた文字に対応するメモリ) は、数値範囲内であってもかまいません。 UDINT 4 ≦ udiSize ≦ 16#FFFF_FF00 )。 前述のデータ構造では、以下の情報が最新の状態に保たれているため、処理ステップの前に毎回再計算する必要はありません。 それぞれのメモリセグメントへの参照 現在の容量 (→ GetSegment ) 長さ (→ Len ) (バイト単位) 文字数 (→ RuneCount ) のプロパティ STR.IString VAR\n itfString : STR.IString;\n udiLength, udiSize, udiRuneCount : UDINT;\n pbySegment : POINTER TO BYTE;\n xValid : BOOL;\nEND_VAR\n \nudiLength := itfString.Len(); \/\/ Current length in byte\npbySegment := itfString.GetSegment(udiSize=>udiSize); \/\/ Address first byte, capacity of the segment in bytes\nudiRuneCount := STR.RuneCount(itfString); \/\/ Current number of \"characters\" in the segment\nxValid := itfString.IsValid(); \/\/ Indication that a valid UTF-8 encoding is present. 相関関係:「キャラクター」と「ルーン」 「ルーン」という用語は、ライブラリやソースコードに使われていますが、「Unicodeコードポイント」とまったく同じ意味ですが、興味深い追加点があります。 ライブラリでは、「ルーン」という単語をタイプのエイリアスとして定義しています DINT 。その結果、整数がいつコードポイントを表しているかがユーザーにはっきりとわかります。さらに、文字定数として想像できるものをルーン定数といいます 例:式のタイプと値 WSTRING#\"⌘\" は整数値を持つルーン文字です DINT#16#2318 。 " }, 
{ "title" : "専門家向け情報 ", 
"url" : "_strlib_expert_information.html", 
"breadcrumbs" : "CODESYS String Libraries \/ 専門家向け情報 ", 
"snippet" : "で CODESYS 3.5.18.0 より前のバージョンでは、UTF-8 でエンコードされたタイプの変数を使用することはできません。 STRING と、 Generic String Base ライブラリ。これはバージョン 3.5.19.50 以降でのみ可能です。の他のライブラリは引き続き使用できます。 CODESYS String Libraries パッケージ。ただし、UTF-8 でエンコードされたメモリ領域 (タイプなど) の処理 ARRAY OF BYTE ) はそこではやや複雑です。 SP18より前 VAR abyValue : ARRAY[0..33] OF BYTE := [ \/...", 
"body" : "で CODESYS 3.5.18.0 より前のバージョンでは、UTF-8 でエンコードされたタイプの変数を使用することはできません。 STRING と、 Generic String Base ライブラリ。これはバージョン 3.5.19.50 以降でのみ可能です。の他のライブラリは引き続き使用できます。 CODESYS String Libraries パッケージ。ただし、UTF-8 でエンコードされたメモリ領域 (タイプなど) の処理 ARRAY OF BYTE ) はそこではやや複雑です。 SP18より前 VAR\n abyValue : ARRAY[0..33] OF BYTE := [ \/\/ UTF-8 CØD€šŸŠ ïß värÿ çôõl\n 16#43, 16#C3, 16#98, 16#44, 16#E2, 16#82, 16#AC, 16#C5, 16#A1, 16#C5, 16#B8,\n 16#C5, 16#A0, 16#20, 16#C3, 16#AF, 16#C3, 16#9F, 16#20, 16#76, 16#C3, 16#A4,\n 16#72, 16#C3, 16#BF, 16#20, 16#C3, 16#A7, 16#C3, 16#B4, 16#C3, 16#B5, 16#6C, 0\n ];\n myString : STR.UTF8Literal := (psValue:=ADR(abyValue));\nEND_VAR UTF-8でエンコードされたタイプの変数が次第 STRING も使用できますが、上の例はさらに簡略化されています。 VAR\n myString : STR.UTF8Literal := (psValue:=ADR(UTF8#'CØD€šŸŠ ïß värÿ çôõl'));\nEND_VAR " }, 
{ "title" : "からの変換 STRING に IString ", 
"url" : "_strlib_expert_information.html#UUID-ab7f59ef-3fd1-9368-2073-8d15fffc313a_section-idm4670931916384033733014074571", 
"breadcrumbs" : "CODESYS String Libraries \/ 専門家向け情報 \/ からの変換 STRING に IString ", 
"snippet" : "文字列セグメントのプロパティを管理するためのデータ構造は、次の方法で実装されます。 STR._UTF8String ファンクションブロック。そのためには、このファンクションブロックのインスタンスと文字列セグメント自体にメモリを割り当てる必要があります ファンクションブロックインスタンスは、にアライメントされたメモリ領域に配置する必要があります __XWORD address 。 文字列からへの変換 IString VAR CONSTANT c_udiLength : UDINT := MAX(4, 512); \/\/ String segment capacity including termi...", 
"body" : "文字列セグメントのプロパティを管理するためのデータ構造は、次の方法で実装されます。 STR._UTF8String ファンクションブロック。そのためには、このファンクションブロックのインスタンスと文字列セグメント自体にメモリを割り当てる必要があります ファンクションブロックインスタンスは、にアライメントされたメモリ領域に配置する必要があります __XWORD address 。 文字列からへの変換 IString VAR CONSTANT\n c_udiLength : UDINT := MAX(4, 512); \/\/ String segment capacity including terminal NULL\n c_udiXWORD : UDINT := SIZEOF(__XWORD);\n    c_udiMaxIndex : UDINT := (SIZEOF(STR._UTF8String) + c_udiLength +  c_udiXWORD  - 1) \/ c_udiXWORD;\nEND_VAR\n \nVAR\n abyValue : ARRAY[0..33] OF BYTE := [ \/\/ UTF-8 CØD€šŸŠ ïß värÿ çôõl\n 16#43, 16#C3, 16#98, 16#44, 16#E2, 16#82, 16#AC, 16#C5, 16#A1, 16#C5, 16#B8,\n 16#C5, 16#A0, 16#20, 16#C3, 16#AF, 16#C3, 16#9F, 16#20, 16#76, 16#C3, 16#A4,\n 16#72, 16#C3, 16#BF, 16#20, 16#C3, 16#A7, 16#C3, 16#B4, 16#C3, 16#B5, 16#6C, 0\n\t];\n axwMemory : ARRAY[0..c_udiMaxIndex] OF __XWORD;\n udiSize : UDINT;\n itfString : STR.IString := STR.CreateString(\n ADR(axwMemory), SIZEOF(axwMemory),\n ADR(abyValue),\n udiStrSize=>udiSize\n );\n xOk : BOOL;\nEND_VAR\n \nxOk := (\n udiSize >= 512 AND\n itfString.Len() = 33 AND\n STR.RuneCount(itfString) = 20 AND\n itfString.IsValid() AND\n NOT itfString.IsASCII()\n); の助けを借りて Generic String Base ライブラリ。これらの要件の多くは対応する関数ブロックで考慮されるため、ユーザーは多くの作業から解放されます。とりわけ、メモリの正しい予約と配置は、対応するファンクションブロックにまとめられています " }, 
{ "title" : "例 ", 
"url" : "_strlib_examples.html", 
"breadcrumbs" : "CODESYS String Libraries \/ 例 ", 
"snippet" : "ザル Generic String Base 文字列処理をできるだけ簡単にするためのライブラリが提供されています。ただし、このライブラリが使用するのは VAR_GENERIC CONSTANT コンパイラ機能なので、以下の状態でのみ使用できます。 CODESYS V3.5 SP19 パッチ 5...", 
"body" : "ザル Generic String Base 文字列処理をできるだけ簡単にするためのライブラリが提供されています。ただし、このライブラリが使用するのは VAR_GENERIC CONSTANT コンパイラ機能なので、以下の状態でのみ使用できます。 CODESYS V3.5 SP19 パッチ 5 " }, 
{ "title" : "ライブラリ: Generic String Base ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4598276773272033733014529891", 
"breadcrumbs" : "CODESYS String Libraries \/ 例 \/ ライブラリ: Generic String Base ", 
"snippet" : "ここではインスタンス ( myString の) GSB.UTF8String 128 バイトの容量で作成され、STRING 変数 (ローマ数字 1968) の値を含む文字列セグメントが初期化されます。のメソッド STR.IString 利用可能です。 から STRING に IString VAR     myString : GSB.UTF8String<128> := (sValue := UTF8#'𝕄ＣMℒ✖Ⅷ'); \/\/ römisch 1968     psString : POINTER TO STRING;    udiSize, udiLength : UDINT;    ...", 
"body" : "ここではインスタンス ( myString の) GSB.UTF8String 128 バイトの容量で作成され、STRING 変数 (ローマ数字 1968) の値を含む文字列セグメントが初期化されます。のメソッド STR.IString 利用可能です。 から STRING に IString VAR\n    myString : GSB.UTF8String<128> := (sValue := UTF8#'𝕄ＣMℒ✖Ⅷ'); \/\/ römisch 1968    \n psString : POINTER TO STRING;    udiSize, udiLength : UDINT;    xASCII, xOk : BOOL;\nEND_VAR\n \n psString := myString.GetSegment(udiSize=>udiSize, udiLength=>udiLength, xASCII=>xASCII); \/\/ Conversion back to the STRING data type\n \nxOk := (\n myString.IsValid() AND \/\/ A valid UTF-8 encoding is present\n udiSize = 128 AND \/\/ The capacity of the string in bytes\n myString.Len() = 17 AND \/\/ The current length of the string in bytes\n STR.RuneCount(myString) = 6 \/\/ The current number of characters in the string\n); 文字列ビルダーの機能 VAR\n myString : GSB.UTF8String<20> := (sValue := UTF8#'𝕄ＣMℒ✖Ⅷ'); \/\/ roman 1968\n sValue : STRING := 'wurden in Mexico-Stadt die';\n wsValue : WSTRING := \"ⅩⅨ.\";\n diSpace : STR.RUNE := 32;\n myValue : GSB.UTF8String<128> := (sValue := UTF8#'Ѻℓƴμρ☤ṧḉнεη $$ρї℮łℯ α♭ℊεℌαʟ⊥℮ᾔ.');\n \n myBuilder : GSB.Builder<(*udiInitialCapacity*) 64, (*usiExtensionFactor*) 50> := (itfString:=myString);\n myResult : GSB.UTF8String<128>;\n \n {attribute 'monitoring_encoding' := 'UTF-8'}\n sResult : STRING(128) := UTF8#'𝕄ＣMℒ✖Ⅷ wurden in Mexico-Stadt die ⅩⅨ. Ѻℓƴμρ☤ṧḉнεη $$ρї℮łℯ α♭ℊεℌαʟ⊥℮ᾔ.';\n \n psResult : POINTER TO STRING;\n udiLength : UDINT;\n xOk : BOOL;\nEND_VAR\n \nmyBuilder.WriteRune(diSpace);\nmyBuilder.WriteString(sValue);\nmyBuilder.WriteRune(diSpace);\nmyBuilder.WriteWString(wsValue);\nmyBuilder.WriteRune(diSpace);\nmyBuilder.WriteIString(myValue);\n \nudiLength := myBuilder.Len(); \/\/ The number of bytes occupied in the builder.\nmyBuilder.ToIString(myResult); \/\/ The individual parts of the string are copied together to myResult.\n \npsResult := myResult.GetSegment(); \nxOk := (psResult^ = sResult); \/\/ Both memory areas should have the same content. 上記の例では、ビルダーのインスタンスは初期容量が 64 バイトで作成されています ( udiInitialCapacity ) と 50 のダイナミックファクター ( usiExtensionFactor )。上記で生成された文字列は引き続き宣言に渡され、その結果、ビルダーにはこの文字列が格納されます ( UTF8#'𝕄ＣMℒ✖Ⅷ' )。 usiExtensionFactor パラメーター。現在の容量が使い果たされると、ビルダーが 50% 増加します。 ビルダーでファイルを読み込む VAR\n sPath : STRING := 'myFilePath';\n hFile : RTS_IEC_HANDLE := RTS_INVALID_HANDLE;\n myBuilder : GSB.Builder<(*udiInitialCapacity*) 16#10000, (*usiExtensionFactor*) 50>;\n abyBuffer : ARRAY[0..4095] OF BYTE;\n pbyData : POINTER TO BYTE;\n udiSize : UDINT;\n udiCount : UDINT;\n eEncoding : SCV.ENCODING;\n eErrorID : SCV.ERROR;\n udiResult : RTS_IEC_RESULT;\nEND_VAR\n \nhFile := SysFileOpen(sPath, ACCESS_MODE.AM_READ, ADR(udiResult));\nIF udiResult <> ERRORS.ERR_OK THEN\n \/\/ handle error condition\n RETURN; \nEND_IF\n \nREPEAT \/\/ fake loop - We need the EXIT feature\n pbyData := ADR(abyBuffer);\n udiSize := TO_UDINT(SysFileRead(hFile, pbyData, XSIZEOF(abyBuffer), ADR(udiResult)));\n IF udiResult <> ERRORS.ERR_OK THEN\n \/\/ handle error condition\n EXIT; \n END_IF\n \n \/\/ Determination of the file encoding\n udiCount := SCV.DecodeBOM(pbyData, udiSize, eEncoding=>eEncoding, eErrorID=>eErrorID);\n IF eErrorID <> 0 THEN\n \/\/ handle error condition\n EXIT;\n END_IF\n \n pbyData := pbyData + udiCount;\n udiSize := udiSize - udiCount;\n \n WHILE udiSize > 0 DO\n \/\/ Convert file content to UTF-8 and copy to Builder-Content\n udiCount := myBuilder.WriteMemSegment(pbyData, udiSize, eEncoding, eErrorID=>eErrorID);\n IF eErrorID <> 0 THEN\n \/\/ handle error condition\n EXIT;\n END_IF\n pbyData := ADR(abyBuffer);\n udiSize := TO_UDINT(SysFileRead(hFile, pbyData, XSIZEOF(abyBuffer), ADR(udiResult)));\n IF udiResult <> ERRORS.ERR_OK THEN\n \/\/ handle error condition\n EXIT; \n END_IF\n END_WHILE\nUNTIL TRUE\nEND_REPEAT\n \nIF hFile <> RTS_INVALID_HANDLE THEN\n SysFileClose(hFile);\n hFile := RTS_INVALID_HANDLE;\n udiCount : UDINT;\nEND_IF ビルダーインスタンスの内容の分析 VAR\n myRange : SBD.Range := (itfBuilder := myBuilder);\n diRune : STR.RUNE;\n eError : STR.ERROR;\nEND_VAR\n \nmyRange.Reset();\nWHILE (diRune := myRange.GetNextRune(eErrorID=>eErrorID)) <> 0 AND_THEN eErrorID = 0 DO\n IF UC.IsSpace(diRune) THEN\n \/\/ The characters in the builder which are considered as spaces according to UNICODE are counted.\n udiCount := udiCount + 1;\n END_IF\nEND_WHILE UTF-8 でエンコードされたコンテンツを渡す場合、データはビルダーですでに UTF-8 でエンコードされているため、エンコーディングの変換にキャッシュは必要ありません。そのため、ビルダーのセグメントのコンテンツは、TCP\/IP 接続などを介して直接送信できます ビルダーのUTF-8でエンコードされたコンテンツをネットワーク経由で転送する VAR\n itfConnection : NBS.IConnection;\n pbySegment : POINTER TO BYTE;\n udiSize : UDINT;\n eError : NBS.ERROR;\nEND_VAR\n \n(* Provide an active itfConnection *)\n \npbySegment:= myBuilder.GetFirstSegment(udiSize=>udiSize, eErrorID=>eErrorID);\nWHILE pbySegment <> 0 AND eErrorID = 0 DO\n eError := itfConnection.Write(pbySegment, udiSize, udiCount=>udiCount);\n IF eError <> 0 OR udiCount <> udiSize THEN\n \/\/ Handle Error\n EXIT;\n END_IF\n pbySegment := myBuilder.GetNextSegment(pbySegment, udiSize=>udiSize, eErrorID=>eErrorID);\nEND_WHILE\n \n(* e.g. Close itfConnection *) " }, 
{ "title" : "での作業 StringPool と RangePool ファンクションブロック ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4670931838168033733015007444", 
"breadcrumbs" : "CODESYS String Libraries \/ 例 \/ での作業 StringPool と RangePool ファンクションブロック ", 
"snippet" : "次のコードは、ダイナミックの使用方法を示しています IString からのインスタンス StringPool 。 StringPool または RangePool プログラムの下位部分に渡すのに適しています。そうすれば、必要に応じてそれぞれのプールから対応するインスタンスを作成し、それらのインスタンスを処理して、それらのインスタンスをプールに戻すことができます での作業 StringPool と RangePool VAR myString : GSB.UTF8String<256> := (sValue:=UTF8#'Was du nicht willst, dass man dir tu’...", 
"body" : "次のコードは、ダイナミックの使用方法を示しています IString からのインスタンス StringPool 。 StringPool または RangePool プログラムの下位部分に渡すのに適しています。そうすれば、必要に応じてそれぞれのプールから対応するインスタンスを作成し、それらのインスタンスを処理して、それらのインスタンスをプールに戻すことができます での作業 StringPool と RangePool VAR\n myString : GSB.UTF8String<256> := (sValue:=UTF8#'Was du nicht willst, dass man dir tu’, das füg auch keinem andern zu.');\n myRange : STR.Range := (itfString:=myString);\n \n myStringPool : GSB.StringPool<(*udiStringSize*) 30, (*udiInitialCapacity*) 25, (*usiExtensionFactor*) 0>;\n myRangePool : GSB.RangePool<GSB.RANGE_TYPE.ISTRING, (*udiInitialCapacity*) 10, (*usiExtensionFactor*) 0>;\n \n diRune : STR.RUNE;\n eErrorID : STR.ERROR;\n itfSubString : STR.IString;\n liStart, liEnd : LINT;\n udiCount : UDINT;\nEND_VAR\n \nmyRange.Reset();\n\/\/ Decompose myString into substrings and analyze them via a subroutine.\nWHILE (diRune:=myRange.GetNextRune(eErrorID=>eErrorID)) <> 0 AND eErrorID = 0 DO\n IF diRune = 16#2C (*,*) OR diRune = 16#2E (*.*) THEN\n itfSubString := myStringPool.GetString();\n IF itfSubString = 0 THEN\n (* Handle Error *)\n EXIT;\n END_IF\n myString.ToIString(itfSubString, liStart+1, liEnd, eErrorID=>eErrorID);\n IF eErrorID <> 0 THEN\n (* Handle Error *)\n EXIT;\n END_IF\n \/\/ Analyse the substring and use pool's\n \/\/ Will release itfSubString\n udiCount := Analyse(itfSubString, myStringPool, myRangePool);\n (* ... Handle Result ... *)\n IF diRune = 16#2E (*.*) THEN\n EXIT;\n END_IF\n diRune:=myRange.GetNextRune(eErrorID=>eErrorID);\n IF diRune = 16#20 (* space *) AND eErrorID = 0 THEN\n liEnd := liEnd + 1;\n ELSE\n myRange.UngetLastRune();\n END_IF\n liStart := liEnd + 1;\n END_IF\n liEnd := liEnd + 1;\nEND_WHILE " }, 
{ "title" : "Unicode の文字カテゴリの操作 ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4613758488403233733015299155", 
"breadcrumbs" : "CODESYS String Libraries \/ 例 \/ Unicode の文字カテゴリの操作 ", 
"snippet" : "Unicode標準は、世界中のすべての文字をデジタルでキャプチャし、その特性を記述することを目的としています。そのためには、文字をグループ (カテゴリ) にまとめます。Unicode ライブラリには、文字がどのカテゴリに属しているかを調べる関数があります。これらの関数は戻ります TRUE 渡された文字がそれぞれのカテゴリに属していれば、そうでなければ FALSE が返されます。 [名前] ファンクション IsControl 一般的な制御文字を認識します IsLetter より広い意味での文字を認識します IsMark 発音区別符号などの組み合わせ文字を認識します IsDigit 10 進数を認...", 
"body" : "Unicode標準は、世界中のすべての文字をデジタルでキャプチャし、その特性を記述することを目的としています。そのためには、文字をグループ (カテゴリ) にまとめます。Unicode ライブラリには、文字がどのカテゴリに属しているかを調べる関数があります。これらの関数は戻ります TRUE 渡された文字がそれぞれのカテゴリに属していれば、そうでなければ FALSE が返されます。 [名前] ファンクション IsControl 一般的な制御文字を認識します IsLetter より広い意味での文字を認識します IsMark 発音区別符号などの組み合わせ文字を認識します IsDigit 10 進数を認識します IsLower 小文字を認識します IsNumber 数字に当てはまる数字と文字を認識します IsGraphic 印刷可能な文字 (さまざまな種類のスペース文字を含む) のみを認識します IsUpper 大文字を認識します IsPunct 句読点を認識します IsPrint 印刷可能な文字のみを認識します (認識されるのはそれだけです) 16#20 (スペース文字として) IsTitle ヘッダーの大文字を認識します IsSpace 幅の異なるスペース、改行などを検出します。 IsSymbol 数学記号や通貨記号など、より広い意味の記号を認識します。 の内容 IString または IBuilder インスタンスは、適切なタイプのファンクションブロックを使用して「1 文字ずつ」分析できます。 Range 。Unicode ライブラリの関数は解析に非常に役立ちます キャラクター分析 VAR\n myString : GSB.UTF8String<50> := (sValue:='Hello World!');\n myBuilder : GSB.Builder<100, 0> := (itfString:=myString);\n mySRange : STR.Range := (itfString:=myString);\n myBRange : SBD.Range := (itfBuilder:=myBuilder);\n diSRune, diBRune : STR.RUNE;\n eErrorID : STR.ERROR;\n udiCount : UDINT;\nEND_VAR\n \nWHILE (diSRune:=mySRange.GetNextRune(eErrorID=>eErrorID)) <> 0 AND eErrorID = 0 DO\n diBRune := myBRange.GetNextRune();\n IF diSRune <> diBRune THEN\n (* Solle nicht vorkommen *)\n END_IF\n IF UC.IsSpace(diSrune) THEN\n udiCount := udiCount + 1;\n END_IF\nEND_WHILE " }, 
{ "title" : "文字の変換 ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4613761628716833733015669185", 
"breadcrumbs" : "CODESYS String Libraries \/ 例 \/ 文字の変換 ", 
"snippet" : "文字を大文字に変換 ( UC.ToUpper ) 文字を小文字に変換 ( UC.ToLower ) コンバージョン VAR diRuneA, diRuneB : STR.RUNE; END_VAR diRuneA := 16#1F3; \/\/ U+01F3 = ǅ diRuneB := UC.ToUpper(diRuneA); \/\/ U+01F1 = Ǳ diRuneA := UC.ToLower(diRuneB); \/\/ U+01F3 = ǅ diRuneB := UC.ToTitle(diRuneA); \/\/ U+01F2 = ǲ...", 
"body" : "文字を大文字に変換 ( UC.ToUpper ) 文字を小文字に変換 ( UC.ToLower ) コンバージョン VAR\n diRuneA, diRuneB : STR.RUNE;\nEND_VAR\n \ndiRuneA := 16#1F3; \/\/ U+01F3 = ǅ\ndiRuneB := UC.ToUpper(diRuneA); \/\/ U+01F1 = Ǳ\ndiRuneA := UC.ToLower(diRuneB); \/\/ U+01F3 = ǅ\ndiRuneB := UC.ToTitle(diRuneA); \/\/ U+01F2 = ǲ " }, 
{ "title" : "文字列の比較 ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4563870076659233733015900115", 
"breadcrumbs" : "CODESYS String Libraries \/ 例 \/ 文字列の比較 ", 
"snippet" : "大文字と小文字を区別 ( STR.Compare ) 大文字と小文字は区別されません ( UC.EqualFold ) 文字列の比較 VAR myFirstString : GSB.UTF8String<50> := (sValue:='test'); mySecondString : GSB.UTF8String<50> := (sValue:='Test'); myThirdString : GSB.UTF8String<50> := (sValue:='CoDeSys'); myFourthString : GSB.UTF8String<50> := (sValue:='CODESYS'...", 
"body" : "大文字と小文字を区別 ( STR.Compare ) 大文字と小文字は区別されません ( UC.EqualFold ) 文字列の比較 VAR\n myFirstString : GSB.UTF8String<50> := (sValue:='test');\n mySecondString : GSB.UTF8String<50> := (sValue:='Test');\n \n myThirdString : GSB.UTF8String<50> := (sValue:='CoDeSys');\n myFourthString : GSB.UTF8String<50> := (sValue:='CODESYS');\n \n diResult : DINT;\n xEqual : BOOL;\nEND_VAR\n \n\/\/\/ Comparing two Strings lexicographically\n\/\/\/ diResult = 1 --> myFirstString > mySecondString\ndiResult := STR.Compare(myFirstString, mySecondString);\n \n\/\/\/ Unicode defined simple case folding\n\/\/\/ xEqual = TRUE --> myThirdString == myFourthString\nxEqual := UC.EqualFold(\n ADR(myThirdString.sValue), myThirdString.Len(),\n ADR(myFourthString.sValue), myFourthString.Len()\n); " }
]
$(document).trigger('search.ready');
});