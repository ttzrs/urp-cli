$(document).ready(function () {indexDict['ja'] = [{ "title" : "CODESYS Application Composer ", 
"url" : "_ac_start_page.html", 
"breadcrumbs" : "CODESYS Application Composer \/ CODESYS Application Composer ", 
"snippet" : "CODESYS Application Composer は、繰り返し発生するファンクションブロックで構成されるアプリケーションバリアントを効率的に作成するためのソフトウェアです。 モジュールに基づいて、マシンアプリケーションを作成し、それをパラメータ化します。PLC プログラムはここから自動的に生成されます アプリケーションパーツの再利用性と品質を向上させます 定義済みのモジュールからアプリケーションを自動生成することによる効率の向上 デジタルファクトリーやインダストリー4.0の分野のアプリケーションのシンプルなプロジェクトエンジニアリングに特に適しています デジタルファクトリーまたはインダ...", 
"body" : "CODESYS Application Composer は、繰り返し発生するファンクションブロックで構成されるアプリケーションバリアントを効率的に作成するためのソフトウェアです。 モジュールに基づいて、マシンアプリケーションを作成し、それをパラメータ化します。PLC プログラムはここから自動的に生成されます アプリケーションパーツの再利用性と品質を向上させます 定義済みのモジュールからアプリケーションを自動生成することによる効率の向上 デジタルファクトリーやインダストリー4.0の分野のアプリケーションのシンプルなプロジェクトエンジニアリングに特に適しています デジタルファクトリーまたはインダストリー4.0のアプリケーションをより簡単に計画できます 付属の発電機とアプリケーションコンセプトにより、すぐに使用可能 ビデオクリップ: によるビルディングオートメーション CODESYS Application Composer アドオン サンプルプロジェクト をインストールして更新できます CODESYS Application Composer のアドオン CODESYS Installer 。 " }, 
{ "title" : "概要 ", 
"url" : "ac_application_composer_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ 概要 ", 
"snippet" : "の CODESYS Application Composer 既存のモジュールに基づいてアプリケーションをアセンブルするために使用されます。ユーザーは必要なモジュールを組み合わせて構成し、それらを接続して完成したアプリケーションを完成させます。この構成には PLC プログラミングの知識は必要ないため、プログラミング経験のない技術者でも実行できます。内部ジェネレーターは、I\/O マッピングと視覚化を備えた、完全で適切に構造化された IEC 61131-3 アプリケーションを作成します。 Application Composer は、次の 2 つの主要コンポーネントで構成されます。 モジュールエデ...", 
"body" : "の CODESYS Application Composer 既存のモジュールに基づいてアプリケーションをアセンブルするために使用されます。ユーザーは必要なモジュールを組み合わせて構成し、それらを接続して完成したアプリケーションを完成させます。この構成には PLC プログラミングの知識は必要ないため、プログラミング経験のない技術者でも実行できます。内部ジェネレーターは、I\/O マッピングと視覚化を備えた、完全で適切に構造化された IEC 61131-3 アプリケーションを作成します。 Application Composer は、次の 2 つの主要コンポーネントで構成されます。 モジュールエディタ。モジュール宣言エディタで開発されたソフトウェアモジュールを構成するために使用できます。 モジュール開発用のモジュール宣言エディター CODESYS Application Composer モジュール ツリーと視覚化の例 モジュールエディタの詳細については、以下を参照してください。 モジュールエディタモジュール宣言エディターの詳細については、次を参照してください。 モジュール宣言エディター" }, 
{ "title" : "モジュールエディタ ", 
"url" : "ac_module_editor_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ ", 
"snippet" : "Application Composer のエディターを使用して、 モジュールツリー 構成およびパラメータ化できます。モジュール インスタンスの利用可能なエディタは、オブジェクトをダブルクリックするか、 オブジェクトの編集 コンテキスト メニューからコマンドを実行します。 導入 HMI パラメーター I\/O 情報 他の編集者: 拡張モジュールエディタ シーケンスエディター の プロジェクトの比較 コマンドは、Application Composer モジュール インスタンスにも使用できます。...", 
"body" : "Application Composer のエディターを使用して、 モジュールツリー 構成およびパラメータ化できます。モジュール インスタンスの利用可能なエディタは、オブジェクトをダブルクリックするか、 オブジェクトの編集 コンテキスト メニューからコマンドを実行します。 導入 HMI パラメーター I\/O 情報 他の編集者: 拡張モジュールエディタ シーケンスエディター の プロジェクトの比較 コマンドは、Application Composer モジュール インスタンスにも使用できます。 " }, 
{ "title" : "導入 ", 
"url" : "ac_toplevel.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 導入 ", 
"snippet" : "このダイアログはトップレベル モジュール インスタンスでのみ使用でき、アプリケーションとタスクの設定を提供します。 トップレベル設定のダイアログ 応用 : トップレベルのモジュールインスタンスに生成対象として入力されます。の ボタンを使用して、既存のアプリケーションを選択するか、名前を指定して新しいアプリケーションを作成できます。アプリケーションが POU プールに割り当てられている場合、 I\/Oマッピング 不可能である。親モジュールを持つ分離されたモジュールの場合、親アプリケーションが推奨されます ( 【親アプリを使用する】 ）。 標準タスク このセクションでは、最大 3 つの事前定義タスク...", 
"body" : "このダイアログはトップレベル モジュール インスタンスでのみ使用でき、アプリケーションとタスクの設定を提供します。 トップレベル設定のダイアログ 応用 : トップレベルのモジュールインスタンスに生成対象として入力されます。の ボタンを使用して、既存のアプリケーションを選択するか、名前を指定して新しいアプリケーションを作成できます。アプリケーションが POU プールに割り当てられている場合、 I\/Oマッピング 不可能である。親モジュールを持つ分離されたモジュールの場合、親アプリケーションが推奨されます ( 【親アプリを使用する】 ）。 標準タスク このセクションでは、最大 3 つの事前定義タスクが利用可能です。1 つは高優先度のタスク、1 つは中優先度のタスク、もう 1 つは低優先度のタスクです。タスクの名前と可用性はモジュール自体で定義されており、変更することはできません (上のダイアログでは次のようになります)。 フィールドバスタスク そして 標準タスク ）。事前定義されたタスクに加えて、ユーザーは名前を指定して新しいタスクを作成できます。 CREATE_IF_MISSING \" フラグはモジュール宣言で設定されます。新しいタスクのパラメータは 標準ジェネレーター設定 。 モジュール固有のタスク : このフィールドには、モジュール固有のタスクに関する情報が表示されます。 " }, 
{ "title" : "I\/O ", 
"url" : "ac_io.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ I\/O ", 
"snippet" : "このダイアログは、モジュールの入力と出力に関する情報を提供します。入力と出力はモジュールの I\/O 需要を表し、以下に接続できます。 デバイスの入力と出力 他のモジュール インスタンスの入力と出力 ST 式または定数 (例: シミュレーション目的の場合、ブール モジュール入力を接続できます) TRUE ) オンラインモードでは、 オンラインの価値 列が表示され、コントローラの現在値が表示されます。 モジュールインターフェースのI\/O概要 をクリックすると、 マッピング フィールドをクリックすると、I\/O マッピング ダイアログが開きます。 I\/Oマッピングのダイアログ I\/Oチャネル : をク...", 
"body" : "このダイアログは、モジュールの入力と出力に関する情報を提供します。入力と出力はモジュールの I\/O 需要を表し、以下に接続できます。 デバイスの入力と出力 他のモジュール インスタンスの入力と出力 ST 式または定数 (例: シミュレーション目的の場合、ブール モジュール入力を接続できます) TRUE ) オンラインモードでは、 オンラインの価値 列が表示され、コントローラの現在値が表示されます。 モジュールインターフェースのI\/O概要 をクリックすると、 マッピング フィールドをクリックすると、I\/O マッピング ダイアログが開きます。 I\/Oマッピングのダイアログ I\/Oチャネル : をクリックすると、 … ボタンをクリックすると、入出力をデバイス I\/O にマップするための別のダイアログが開きます。 ST式 : このオプションを使用すると、入力\/出力を ST 式にマッピングできます。をクリックすると、 ボタンをクリックすると、変数を選択するための入力アシスタントが開きます。 モジュールI\/Oに接続 : このオプションは、接続のない I\/O に入力\/出力をマップするために使用できます。をクリックすると、 ボタンをクリックすると、入力アシスタントが開き、モジュールを選択できます。 接続がありません : 入力\/出力のマッピングがありません。このオプションは次のようなものです 接続がありません ですが、警告メッセージは生成されません。 接続がありません : このオプションはデフォルトであり、プロジェクトの生成時にメッセージ ビューに警告が生成されます。 デバイス ジェネレーターによって自動的に接続される I\/O は、 で示されます。 (AUTO) IN\/OUT列に があり、無効になっています。マッピングがまだ手動で変更されている場合は、この操作により自動マッピングが上書きされるという警告が表示されます。 自動生成された接続が手動で設定された接続によって上書きされると、この I\/O チャネルはデバイス ジェネレーターの操作では考慮されなくなります。 " }, 
{ "title" : "HMI ", 
"url" : "ac_hmi.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ HMI ", 
"snippet" : "このダイアログでは、ページ テンプレートと、トップレベル ビジュアライゼーションに埋め込む必要があるモジュール ビジュアライゼーションを定義します。 トップレベルのタブを作成する : このモジュール インスタンスの視覚化に直接つながるタブを視覚化の最上位に作成します。 ホットキー : ここでショートカットを設定すると、このビジュアライゼーション ページに直接切り替えることができます。ショートカットのデフォルト設定は、 std.Visu セクション。 ページテンプレート : モジュールの視覚化のテンプレートをここで選択でき、視覚化の背景として使用されます。ドロップダウン リストには、モジュール宣...", 
"body" : "このダイアログでは、ページ テンプレートと、トップレベル ビジュアライゼーションに埋め込む必要があるモジュール ビジュアライゼーションを定義します。 トップレベルのタブを作成する : このモジュール インスタンスの視覚化に直接つながるタブを視覚化の最上位に作成します。 ホットキー : ここでショートカットを設定すると、このビジュアライゼーション ページに直接切り替えることができます。ショートカットのデフォルト設定は、 std.Visu セクション。 ページテンプレート : モジュールの視覚化のテンプレートをここで選択でき、視覚化の背景として使用されます。ドロップダウン リストには、モジュール宣言で定義されているすべてのビジュアライゼーションの選択が表示されます。モジュール宣言の最初のビジュアライゼーションがデフォルトで選択されます。もし いいえ 視覚化が定義されている場合、「なし」が表示されます。 視覚化を埋め込む : この関数を使用すると、モジュール インスタンスの視覚化を次の上位モジュールに埋め込むことができます ( 次の祖先 )、またはモジュール インスタンスの他の視覚化で使用できます。モジュール内で定義されている場合、 %PAGE_VISU% プレースホルダーを選択できます。この場合、モジュールインスタンスに対して生成された作成可視化画面が埋め込まれます。複数のエントリを定義できます。 視覚化画面の作成については、以下を参照してください。 視覚化画面の生成 " }, 
{ "title" : "パラメータ ", 
"url" : "ac_parameter.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ パラメータ ", 
"snippet" : "このダイアログには、パラメータ化できるモジュール インスタンスの使用可能なパラメータがすべて表示されます。のエントリ パラメータ 、 タイプ 、 説明 、 分 、 そして マックス 情報提供のみを目的としています。ダブルクリックすると、 価値 フィールドをクリックして編集します。 モジュールインスタンスのパラメータダイアログ パラメータ値が明示的に設定されている場合、パラメータ値は太字で表示されます。それ以外の場合、フォントは通常のままです。変更されたパラメータは、 デフォルトにリセット コンテキストメニューのコマンド。 赤いフォントのパラメータはユーザーが設定する必要があります。そうしないと...", 
"body" : "このダイアログには、パラメータ化できるモジュール インスタンスの使用可能なパラメータがすべて表示されます。のエントリ パラメータ 、 タイプ 、 説明 、 分 、 そして マックス 情報提供のみを目的としています。ダブルクリックすると、 価値 フィールドをクリックして編集します。 モジュールインスタンスのパラメータダイアログ パラメータ値が明示的に設定されている場合、パラメータ値は太字で表示されます。それ以外の場合、フォントは通常のままです。変更されたパラメータは、 デフォルトにリセット コンテキストメニューのコマンド。 赤いフォントのパラメータはユーザーが設定する必要があります。そうしないと作成時にエラーが表示されます。 オンラインモードでは、 オンラインの価値 列が表示され、現在の値が表示されます。パラメータの値を変更すると、 価値 列にある場合、コントローラの値も変更されます。使用 オンライン値を使用する 現在のオンライン値を 価値 列を編集し、その結果としてモジュール ツリー内のモジュール インスタンスのパラメータ値として使用します。 パラメータ値は常に IEC リテラルに定義された構文で表示および編集されます。たとえば、TIME 型のパラメータ値は次のように表示されます。 t#7s35ms 示されています。 パラメータが変更されると、 生成する プロジェクトを再度作成するにはコマンドを実行する必要があります。 オンライン モードでモジュール インスタンスのパラメータ値を変更した場合は、 パラメータ値の違い コマンドで変更されたパラメータのリストを取得します。 メッセージ ビュー。この種のメッセージをダブルクリックすると、影響を受けるモジュール インスタンスのパラメーター ダイアログが開き、変更されたパラメーター値が赤枠で示されます。 " }, 
{ "title" : "情報 ", 
"url" : "ac_information.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 情報 ", 
"snippet" : "この情報ダイアログには、 アイコン 、 名前 、 説明 、 ソース 、 バージョン 、 プロバイダー 、 そして カテゴリー モジュールインスタンスの。 オプションとして、複数のリンクを表示することもできます。リンクをクリックすると、それぞれのアプリケーションが開きます。最初の URL の内容が右側に表示されます。ここにリンクを表示するには、リンクを MetaData モジュール宣言のセクション。 信頼できるドメインとサイトはアプリケーションで定義されます 作曲者のオプション 。 「信頼できる」として定義されていない URL をクリックすると、右側のビューでダイアログが開きます。このビューでは...", 
"body" : "この情報ダイアログには、 アイコン 、 名前 、 説明 、 ソース 、 バージョン 、 プロバイダー 、 そして カテゴリー モジュールインスタンスの。 オプションとして、複数のリンクを表示することもできます。リンクをクリックすると、それぞれのアプリケーションが開きます。最初の URL の内容が右側に表示されます。ここにリンクを表示するには、リンクを MetaData モジュール宣言のセクション。 信頼できるドメインとサイトはアプリケーションで定義されます 作曲者のオプション 。 「信頼できる」として定義されていない URL をクリックすると、右側のビューでダイアログが開きます。このビューでは、信頼されたドメインまたはサイトに URL を追加できます。 " }, 
{ "title" : "ソーステンプレート ", 
"url" : "ac_copyfb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ ソーステンプレート ", 
"snippet" : "このダイアログは、POU プールのどの機能ブロックがアプリケーションにコピーされるかを定義します。 生成する コマンドが実行されます。関数ブロックをコピーするには、SourceTemplate ジェネレーターを有効にする必要があります。 発電機の構成 。 ダイアログには、 SourceTemplate モジュール宣言のセクション。 ソースFB : コピーするファンクションブロックの識別子 コピーすることです : TRUE\/FALSE: ファンクションブロックをコピーするかコピーしません。もし IsMandatory パラメータは次のように定義されます TRUE モジュール宣言内にある場合、ここ...", 
"body" : "このダイアログは、POU プールのどの機能ブロックがアプリケーションにコピーされるかを定義します。 生成する コマンドが実行されます。関数ブロックをコピーするには、SourceTemplate ジェネレーターを有効にする必要があります。 発電機の構成 。 ダイアログには、 SourceTemplate モジュール宣言のセクション。 ソースFB : コピーするファンクションブロックの識別子 コピーすることです : TRUE\/FALSE: ファンクションブロックをコピーするかコピーしません。もし IsMandatory パラメータは次のように定義されます TRUE モジュール宣言内にある場合、ここで値を変更することはできません。 ソースFBの種類 : コピーするファンクションブロック名 " }, 
{ "title" : "エディタ: エクスポートデバイス ", 
"url" : "ac_export_devices.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ エディタ: エクスポートデバイス ", 
"snippet" : "このエディタを使用すると、デバイス エクスポートによって生成されたファイルを選択できます。このデバイスは、プロジェクトの生成時にデバイス ツリーに追加されます。 これ 構成オプション 特別なプロパティを持つデバイスが追加される場合、およびデバイス ジェネレーターでデバイスを追加できない場合に必要です。 識別子 : モジュール宣言の識別子 エクスポートされたファイル : モジュール宣言で定義されているすべてのファイルの選択 モジュール宣言にファイルが 1 つだけ定義されている場合は、ここには表示されません。デバイスごとに複数の ExportDevices が存在する可能性があります。これらはモジ...", 
"body" : "このエディタを使用すると、デバイス エクスポートによって生成されたファイルを選択できます。このデバイスは、プロジェクトの生成時にデバイス ツリーに追加されます。 これ 構成オプション 特別なプロパティを持つデバイスが追加される場合、およびデバイス ジェネレーターでデバイスを追加できない場合に必要です。 識別子 : モジュール宣言の識別子 エクスポートされたファイル : モジュール宣言で定義されているすべてのファイルの選択 モジュール宣言にファイルが 1 つだけ定義されている場合は、ここには表示されません。デバイスごとに複数の ExportDevices が存在する可能性があります。これらはモジュール説明の識別子に従って区別され、ここに表示されます。 " }, 
{ "title" : "ダイアログ: オプション: Composer ", 
"url" : "ac_options.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ ダイアログ: オプション: Composer ", 
"snippet" : "このサブダイアログは、 CODESYS オプションダイアログには、 CODESYS Application Composer 設定。...", 
"body" : "このサブダイアログは、 CODESYS オプションダイアログには、 CODESYS Application Composer 設定。 " }, 
{ "title" : "タブ: 一般 ", 
"url" : "ac_options.html#UUID-f0422aff-2b78-70d6-5e11-24472852cab0_ce9930fe2eec0a8640e0080c1b5_id_71025f62d62f3d9cc0a8640e01589d60", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ ダイアログ: オプション: Composer \/ タブ: 一般 ", 
"snippet" : "一般的な 生成前にトップレベルの選択を表示 ：クリックできます 作曲家 → 生成 をクリックして、トップレベルのモジュールを選択するためのダイアログを開きます。変更されないモジュールの選択を解除すると、アプリケーションの生成時間を短縮できます。 編集者 パラメータエディタの種類 のプレゼンテーション パラメータ タブ内 パラメータ (モジュールエディター) ツリー表示 : パラメータ グループはエディタにツリー構造として表示されます。 タブビュー : パラメータ グループはエディタ内で単一のタブとして表示されます。 スキャン 自動スキャン (プロジェクトとともに保存) : の CODESYS ...", 
"body" : "一般的な 生成前にトップレベルの選択を表示 ：クリックできます 作曲家 → 生成 をクリックして、トップレベルのモジュールを選択するためのダイアログを開きます。変更されないモジュールの選択を解除すると、アプリケーションの生成時間を短縮できます。 編集者 パラメータエディタの種類 のプレゼンテーション パラメータ タブ内 パラメータ (モジュールエディター) ツリー表示 : パラメータ グループはエディタにツリー構造として表示されます。 タブビュー : パラメータ グループはエディタ内で単一のタブとして表示されます。 スキャン 自動スキャン (プロジェクトとともに保存) : の CODESYS Application Composer 新しいライブラリが POU ビューに挿入されると、既存のモジュールとモジュール インスタンスが自動的に検索されます。 : の CODESYS Application Composer 次の場合にのみ、既存のモジュールとモジュール インスタンスを検索します。 プロジェクトを開いた後 検索が実行されなかった場合、モジュール ツリーにモジュール インスタンスを挿入した後 注: この設定はプロジェクトとともに保存されます。 信頼できるドメイン 信頼できる Web サイト このリストの URL は、 情報 モジュールエディタのタブ。要件: URL はセクションで定義されています MetaData モジュール宣言の。 " }, 
{ "title" : "タブ: シーケンスエディター ", 
"url" : "ac_options.html#UUID-f0422aff-2b78-70d6-5e11-24472852cab0_ce9930fe2eec0a8640e0080c1b5_id_70cecd07d62f3d9fc0a8640e00b85eda", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ ダイアログ: オプション: Composer \/ タブ: シーケンスエディター ", 
"snippet" : "一般的な 参考資料を表示 パラメータを表示 I\/Oマッピングを表示 インスタンス名を表示する コメントを表示 オンライン変数を表示する : のステップにそれぞれの要素が表示されます。 シーケンスエディター 。 画面 ステップ幅 : タブヘッダーの幅 (ピクセル単位) 有効な値: 25 ～ 500。 歩幅（垂直） シーケンスステップ間の距離 (ピクセル単位) 有効な値: 10 ～ 100 標準繋がり 接続 B接続 シーケンスステップ間の接続線の色 の色 接続 そして B接続 分岐ステップの後に使用されます。 テキスト パラメーター 参考文献 I\/Oチャンネル テキスト、パラメータ、参照、および ...", 
"body" : "一般的な 参考資料を表示 パラメータを表示 I\/Oマッピングを表示 インスタンス名を表示する コメントを表示 オンライン変数を表示する : のステップにそれぞれの要素が表示されます。 シーケンスエディター 。 画面 ステップ幅 : タブヘッダーの幅 (ピクセル単位) 有効な値: 25 ～ 500。 歩幅（垂直） シーケンスステップ間の距離 (ピクセル単位) 有効な値: 10 ～ 100 標準繋がり 接続 B接続 シーケンスステップ間の接続線の色 の色 接続 そして B接続 分岐ステップの後に使用されます。 テキスト パラメーター 参考文献 I\/Oチャンネル テキスト、パラメータ、参照、および I\/O チャネルを表示するための色 テキストフォント このボタンをクリックすると、エディターでテキストのフォントを設定するためのデフォルトのダイアログが開きます。 リンクフォント このボタンをクリックすると、リンクのラベル付けのフォントを設定するためのデフォルトのダイアログが開きます。 " }, 
{ "title" : "シーケンスエディター ", 
"url" : "ac_sequenceeditor.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ シーケンスエディター ", 
"snippet" : "シーケンスエディターは、シーケンスを表示および編集するグラフィカルエディターです。 モジュールツリー フローチャートで。モジュールを追加および削除したり、そのプロパティを変更したりできます。エディターにはオンライン モードも用意されており、これはアクティブなモジュール ステップとモジュール ブレークポイントの追跡に使用されるため、デバッグに使用できます。 シーケンス フロー自体 (シーケンスの実行と順序) はエディターによって実装されません。モジュールツリーの表示と編集のみに使用します。モジュール ステップの機能またはロジックはすべて、モジュールの機能ブロックに IEC ( CODESYS )...", 
"body" : "シーケンスエディターは、シーケンスを表示および編集するグラフィカルエディターです。 モジュールツリー フローチャートで。モジュールを追加および削除したり、そのプロパティを変更したりできます。エディターにはオンライン モードも用意されており、これはアクティブなモジュール ステップとモジュール ブレークポイントの追跡に使用されるため、デバッグに使用できます。 シーケンス フロー自体 (シーケンスの実行と順序) はエディターによって実装されません。モジュールツリーの表示と編集のみに使用します。モジュール ステップの機能またはロジックはすべて、モジュールの機能ブロックに IEC ( CODESYS ) プログラムコード シーケンスエディター エディターは、次の定義を持つすべてのモジュールで使用できます。 根 セクションで mse.Sequence モジュール宣言の。エディタの内容はモジュールツリーに相当します。モジュール ツリー内の各変更によりシーケンス エディターが変更され、その逆も同様です。 「」の下に挿入されたモジュール インスタンスのみが表示されます。 Root \" インスタンス。表示される内容は、セクションの定義によって定義されます。 mse.Sequence モジュール宣言の。 ステップの外観は、モジュール宣言の定義によって異なります。定義のほかに Root 次の 3 つの定義が存在します。 ステップ： 平行： 支店： " }, 
{ "title" : "シーケンスボックス内の表示データ ", 
"url" : "ac_sequenceeditor.html#UUID-c7b42e58-c2ec-c00e-5692-55a5d60221bd_d125a077ca9f50ac0a8640e01732ee5_id_ad20551e9b6d77a9c0a865200163ff8b", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ シーケンスエディター \/ シーケンスボックス内の表示データ ", 
"snippet" : "各ステップのボックス内に、モジュール タイプの名前、モジュール インスタンスの名前 (オプション)、および定義されたアイコンが表示されます。後者は、メタデータで定義されたアイコンに対応します。 モジュール構成 。セクションで定義されている場合、モジュール インスタンスのパラメータと I\/O チャネルも表示されます。 mse.Sequence 。参照にも同じことが当てはまりますが、参照には 2 つの異なるタイプが区別されます。 モジュールインスタンスへの一般的な参照 ジャンプ参照。シーケンス内のジャンプを定義します。 参照されたモジュール インスタンスは、モジュール ツリー内の相対パスとともに表...", 
"body" : "各ステップのボックス内に、モジュール タイプの名前、モジュール インスタンスの名前 (オプション)、および定義されたアイコンが表示されます。後者は、メタデータで定義されたアイコンに対応します。 モジュール構成 。セクションで定義されている場合、モジュール インスタンスのパラメータと I\/O チャネルも表示されます。 mse.Sequence 。参照にも同じことが当てはまりますが、参照には 2 つの異なるタイプが区別されます。 モジュールインスタンスへの一般的な参照 ジャンプ参照。シーケンス内のジャンプを定義します。 参照されたモジュール インスタンスは、モジュール ツリー内の相対パスとともに表示されます (例: ..\/..\/WaitTime ）。発生しているのは ..\/ 短縮表記で書かれています (例: .\/..\/..\/ になる 3x[..\/] ）。 各ステップには行で区切って表示されるコメントを追加できます。これはステップ（モジュールインスタンス）ごとに個別に保存されます。 モジュール名、パラメータ、IO チャネル、または参照の表示テキストがステップ内の指定されたスペースに収まらない場合、テキストは 2 行目に折り返されます。必要に応じて文字をカットいたします。この場合、 … が追加されます。 要約すると、これは、プロセス ステップに対して最大 4 つの追加リスト\/テキスト フィールドが存在できることを意味します。 パラメータ: パラメータ名 + パラメータ値 I\/O チャネル: チャネル名 + チャネル宛先名 参照: 参照されるモジュール インスタンスのアイコン、パス、名前 ジャンプのリファレンスについては、次のとおりです。 >> + 参照されるモジュール インスタンスのアイコン、パス、名前 コメント: ハイフン + コメント シーケンスエディターの詳細については、ヘルプの章にある「 」を参照してください。 シーケンスエディターでの作業 そして オンラインモードのシーケンスエディター " }, 
{ "title" : "シーケンスエディターの操作 ", 
"url" : "ac_sequenceeditor_edit.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ シーケンスエディター \/ シーケンスエディターの操作 ", 
"snippet" : "マウス ポインタをステップ上に移動すると、そのステップがグレーで強調表示されます。ポインタを接続の空の端に移動すると、灰色の三角形が表示されます。クリックすると、選択したステップの色が赤に変わり、ステップを選択できます。ステップの複数選択も可能です。 ステップはドラッグ＆ドロップで移動できます。とき Ctrl キーを押すとステップがコピーされます。移動またはコピーされたステップの挿入可能な位置は、赤い点線でマークされます。 ドラッグ＆ドロップで要素を移動 現在のシーケンスでターゲットが使用可能なジャンプ要素上にマウス ポインタを移動すると、ジャンプ参照のテキスト フィールドも破線で指定されたタ...", 
"body" : "マウス ポインタをステップ上に移動すると、そのステップがグレーで強調表示されます。ポインタを接続の空の端に移動すると、灰色の三角形が表示されます。クリックすると、選択したステップの色が赤に変わり、ステップを選択できます。ステップの複数選択も可能です。 ステップはドラッグ＆ドロップで移動できます。とき Ctrl キーを押すとステップがコピーされます。移動またはコピーされたステップの挿入可能な位置は、赤い点線でマークされます。 ドラッグ＆ドロップで要素を移動 現在のシーケンスでターゲットが使用可能なジャンプ要素上にマウス ポインタを移動すると、ジャンプ参照のテキスト フィールドも破線で指定されたターゲット ステップに接続されます。ターゲットも破線の円でマークされます。 ジャンプ参照のジャンプ先 I\/Oチャンネルによる編集 I\/O チャネルをダブルクリックすると、I\/O マッピング ダイアログが開きます。このダイアログは、モジュール インスタンスの I\/O エディタでも使用されます。詳細については、以下を参照してください。 I\/O " }, 
{ "title" : "シーケンスエディタのコマンド ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_00bbee939046545bc0a8652000fd02ce", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ シーケンスエディター \/ シーケンスエディターの操作 \/ シーケンスエディタのコマンド ", 
"snippet" : "シーケンスまたは灰色の三角形 (空の並列ステップまたはブランチ) を右クリックすると、コンテキスト メニューのその位置で実行できるコマンドが表示されます。標準コマンドに加えて 切り取る 、 コピー そして 入れる これらは次のコマンドです。 後にステップを追加 後続のステップはすべて list コマンドで表示されます。その結果、この位置のモジュール スロットに適したステップとモジュールのみが追加されます。 閉じたサブシーケンスの後にステップを追加 このコマンドは、分岐のサブシーケンスおよび並列シーケンスを閉じる必要がある場合に使用できます。挿入されたステップは、サブシーケンス内ではなく、サブシ...", 
"body" : "シーケンスまたは灰色の三角形 (空の並列ステップまたはブランチ) を右クリックすると、コンテキスト メニューのその位置で実行できるコマンドが表示されます。標準コマンドに加えて 切り取る 、 コピー そして 入れる これらは次のコマンドです。 後にステップを追加 後続のステップはすべて list コマンドで表示されます。その結果、この位置のモジュール スロットに適したステップとモジュールのみが追加されます。 閉じたサブシーケンスの後にステップを追加 このコマンドは、分岐のサブシーケンスおよび並列シーケンスを閉じる必要がある場合に使用できます。挿入されたステップは、サブシーケンス内ではなく、サブシーケンスの後に追加されます。これは、クローズ可能なサブシーケンスを持つポジションでのみ使用できます。 コメントを追加 選択したステップにコメントを追加します。 ジャンプ基準を設定する このコマンドは、ジャンプ要素のコンテキスト メニューでのみ使用できます。マウスを使用して、ターゲットステップに赤い線を引くことができます。 選択したシーケンス要素のコンテキスト メニューは、 スペースキー 。 ブランチのコンテキスト メニュー 連続するステップは矢印で接続されます。ブランチ要素では、2 つのブランチに異なる色を定義できます。詳細については、以下を参照してください。 mse.シーケンス。色は次のように定義されています。 CODESYS オプション ( シーケンスエディター ）。 " }, 
{ "title" : "シーケンスステップ上の位置を変更する ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_74415e1a90465440c0a865200120cb10", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ シーケンスエディター \/ シーケンスエディターの操作 \/ シーケンスステップ上の位置を変更する ", 
"snippet" : "シーケンス要素の位置を変更するには、要素を選択し、マウスの中ボタンを使用してドラッグする必要があります。ステップ内のパラメータの配置も変更できます。 シーケンスステップの位置を変更する その結果、エディター内で移動できるのは要素の位置のみです。シーケンス内の位置を変更することはできないため、順序を変更することはできません。...", 
"body" : "シーケンス要素の位置を変更するには、要素を選択し、マウスの中ボタンを使用してドラッグする必要があります。ステップ内のパラメータの配置も変更できます。 シーケンスステップの位置を変更する その結果、エディター内で移動できるのは要素の位置のみです。シーケンス内の位置を変更することはできないため、順序を変更することはできません。 " }, 
{ "title" : "パラメータ\/コメント\/インスタンス名\/I\/Oチャネルの変更 ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_a585f36190465431c0a8652000ac8cda", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ シーケンスエディター \/ シーケンスエディターの操作 \/ パラメータ\/コメント\/インスタンス名\/I\/Oチャネルの変更 ", 
"snippet" : "を変更するには パラメータ 、ダブルクリックする必要があります。変数のデータ型に応じて、フィールドを編集したり、リスト ボックスから変数値を選択したりできます (例: TRUE または FALSE ）。 コメントやインスタンス名はダブルクリックでも変更できます。...", 
"body" : "を変更するには パラメータ 、ダブルクリックする必要があります。変数のデータ型に応じて、フィールドを編集したり、リスト ボックスから変数値を選択したりできます (例: TRUE または FALSE ）。 コメントやインスタンス名はダブルクリックでも変更できます。 " }, 
{ "title" : "参考文献の編集 ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_939c29699046541bc0a865200038e978", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ シーケンスエディター \/ シーケンスエディターの操作 \/ 参考文献の編集 ", 
"snippet" : "参照を右クリックすると編集できます。コンテキスト メニューには、この場所に挿入できる参照のリストが表示されます。 参照の設定 ジャンプ参照の場合、コンテキスト メニューには ジャンプリファレンスの設定 指示。このコマンドを実行すると、マウスを使用してジャンプ先を設定できるようになります。ターゲットに赤い点線が描画され、それをクリックして設定できます。既存のジャンプ参照は次のコマンドで削除できます。 消去 コンテキストメニューから。 ジャンプ基準を設定する...", 
"body" : "参照を右クリックすると編集できます。コンテキスト メニューには、この場所に挿入できる参照のリストが表示されます。 参照の設定 ジャンプ参照の場合、コンテキスト メニューには ジャンプリファレンスの設定 指示。このコマンドを実行すると、マウスを使用してジャンプ先を設定できるようになります。ターゲットに赤い点線が描画され、それをクリックして設定できます。既存のジャンプ参照は次のコマンドで削除できます。 消去 コンテキストメニューから。 ジャンプ基準を設定する " }, 
{ "title" : "オンラインモードのシーケンスエディター ", 
"url" : "ac_sequenceeditor_onlinemode.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ シーケンスエディター \/ オンラインモードのシーケンスエディター ", 
"snippet" : "アプリケーションがログインすると、シーケンス エディターはオンライン モードに切り替わります。オンライン モードでのモジュール ステップの外観は、オフライン モードと非常に似ています。すべてのステップが表示されますが、オフライン モードのように選択または変更することはできません。このモードでは、ステップ内の変数値を表示することもできます。 オンラインモードでのコマンド オンライン操作では、メニューからシーケンスエディターを使用できます。 作曲 さらに 2 つのコマンド: 次のステップへのアクティブなブレークポイント ビューをブレークポイントの中央に配置...", 
"body" : "アプリケーションがログインすると、シーケンス エディターはオンライン モードに切り替わります。オンライン モードでのモジュール ステップの外観は、オフライン モードと非常に似ています。すべてのステップが表示されますが、オフライン モードのように選択または変更することはできません。このモードでは、ステップ内の変数値を表示することもできます。 オンラインモードでのコマンド オンライン操作では、メニューからシーケンスエディターを使用できます。 作曲 さらに 2 つのコマンド: 次のステップへのアクティブなブレークポイント ビューをブレークポイントの中央に配置 " }, 
{ "title" : "アクティブなステップ ", 
"url" : "ac_sequenceeditor_onlinemode.html#UUID-2af85472-49e7-4d96-1c40-aacbe534fb38_cd6429848b1bdae2c0a8640e002e3857_id_e0ed25b7911507a5c0a8640e003e283b", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ シーケンスエディター \/ オンラインモードのシーケンスエディター \/ アクティブなステップ ", 
"snippet" : "で適切に宣言されていれば、 モジュール宣言 、アクティブなステップは黄色で表示されます。 オンラインモード - アクティブステップ...", 
"body" : "で適切に宣言されていれば、 モジュール宣言 、アクティブなステップは黄色で表示されます。 オンラインモード - アクティブステップ " }, 
{ "title" : "ブレークポイント ", 
"url" : "ac_sequenceeditor_onlinemode.html#UUID-2af85472-49e7-4d96-1c40-aacbe534fb38_cd6429848b1bdae2c0a8640e002e3857_id_e06ef3f19ba07a7bc0a8652001bdb8af", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ シーケンスエディター \/ オンラインモードのシーケンスエディター \/ ブレークポイント ", 
"snippet" : "モジュール宣言で適切に宣言されている場合、エディターでブレークポイントを設定できます。ステップのブレークポイントは、 ブレークポイントの切り替え ステップのコンテキスト メニューからコマンドを実行します。アクティブ化されたブレークポイントは赤い枠線で示されます。ブレークポイントがアクティブな場合 (シーケンスがブレークポイントで停止する)、ステップは赤色で表示されます。 オンライン モード – ブレークポイント 詳細については、以下を参照してください。 mse.シーケンス...", 
"body" : "モジュール宣言で適切に宣言されている場合、エディターでブレークポイントを設定できます。ステップのブレークポイントは、 ブレークポイントの切り替え ステップのコンテキスト メニューからコマンドを実行します。アクティブ化されたブレークポイントは赤い枠線で示されます。ブレークポイントがアクティブな場合 (シーケンスがブレークポイントで停止する)、ステップは赤色で表示されます。 オンライン モード – ブレークポイント 詳細については、以下を参照してください。 mse.シーケンス" }, 
{ "title" : "拡張モジュールエディタ ", 
"url" : "ac_editor_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 拡張モジュールエディタ ", 
"snippet" : "拡張モジュールのエディタは拡張を定義し、4 つの機能を提供します。 メタデータ 、 パラメータ、 I\/O、 そして HMI タブ。エディターは、関数ブロックをダブルクリックして開くことができます。 POU プール（拡張子の指定された名前に応じたディレクトリ内）。 エラー処理 エディターの表示を禁止する致命的なエラーの場合、エラー メッセージが画面に表示されます。 メタデータ ページ。エディター ページは無効になっているため、どの入力にも反応できません。この種のエラーの例としては、モジュールの機能ブロックが欠落していることが挙げられます。...", 
"body" : "拡張モジュールのエディタは拡張を定義し、4 つの機能を提供します。 メタデータ 、 パラメータ、 I\/O、 そして HMI タブ。エディターは、関数ブロックをダブルクリックして開くことができます。 POU プール（拡張子の指定された名前に応じたディレクトリ内）。 エラー処理 エディターの表示を禁止する致命的なエラーの場合、エラー メッセージが画面に表示されます。 メタデータ ページ。エディター ページは無効になっているため、どの入力にも反応できません。この種のエラーの例としては、モジュールの機能ブロックが欠落していることが挙げられます。 " }, 
{ "title" : "イベントの変更 ", 
"url" : "ac_editor_extension_module.html#UUID-91f9cff1-6f9e-ea6b-b3cd-d65abac7523b_ef0072b48b6aa7c0a8640e00080c11_id_4681e6c5b4a5a074c0a8640e01e5e429", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 拡張モジュールエディタ \/ イベントの変更 ", 
"snippet" : "対応する機能ブロック、テキスト リスト、イメージ プール、またはビジュアライゼーションが変更されると、エディターのコンテンツは自動的に更新されます。 (言及されたオブジェクトは、拡張モジュールと同じフォルダー内にある場合、「対応する」ものとみなされます。)...", 
"body" : "対応する機能ブロック、テキスト リスト、イメージ プール、またはビジュアライゼーションが変更されると、エディターのコンテンツは自動的に更新されます。 (言及されたオブジェクトは、拡張モジュールと同じフォルダー内にある場合、「対応する」ものとみなされます。) " }, 
{ "title" : "メタデータ ", 
"url" : "ac_metadata_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 拡張モジュールエディタ \/ メタデータ ", 
"snippet" : "このタブでは、 拡張モジュールエディタ 、説明とカテゴリが表示されます。表示されるテキスト（カテゴリを除く）はテキストリストから読み込まれます。これには、プログラミング システムで現在使用されている言語が適用されます。この言語で使用可能なテキストがない場合は、デフォルトのテキストが使用されます。テキスト入力がまったくない場合、テキストは表示されません。 テキスト リストと同様に、画像は画像プールから読み取られます。 拡張モジュールダイアログ メタデータ 表示された値の右側にあるボタンを使用すると、テキスト リストまたは画像プール内の対応する行が開き、その結果テキストを変更できるようになります。...", 
"body" : "このタブでは、 拡張モジュールエディタ 、説明とカテゴリが表示されます。表示されるテキスト（カテゴリを除く）はテキストリストから読み込まれます。これには、プログラミング システムで現在使用されている言語が適用されます。この言語で使用可能なテキストがない場合は、デフォルトのテキストが使用されます。テキスト入力がまったくない場合、テキストは表示されません。 テキスト リストと同様に、画像は画像プールから読み取られます。 拡張モジュールダイアログ メタデータ 表示された値の右側にあるボタンを使用すると、テキスト リストまたは画像プール内の対応する行が開き、その結果テキストを変更できるようになります。対応する ID を持つテキスト\/画像がない場合は、この ID を持つ新しい要素が作成されます。 " }, 
{ "title" : "パラメータ ", 
"url" : "ac_parameters_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 拡張モジュールエディタ \/ パラメータ ", 
"snippet" : "このタブでは、 拡張モジュールエディタ 拡張モジュールのパラメータを表に示します。 拡張モジュールダイアログ: パラメータ の ID 、 変数 、 タイプ 、 そして デフォルト 列は読み取り専用です。の中に 名前 そして 説明 列では、対応する行 (すでに選択されている場合) をクリックするか、 スペースキー をクリックすると、それぞれのテキスト リストの対応する行に直接ジャンプします。表示されるテキストは、プログラミング システムに現在設定されている言語を使用してテキスト リストから読み取られます。この言語がテキスト リストにない場合は、エントリのデフォルトのテキストが使用されます。コラム...", 
"body" : "このタブでは、 拡張モジュールエディタ 拡張モジュールのパラメータを表に示します。 拡張モジュールダイアログ: パラメータ の ID 、 変数 、 タイプ 、 そして デフォルト 列は読み取り専用です。の中に 名前 そして 説明 列では、対応する行 (すでに選択されている場合) をクリックするか、 スペースキー をクリックすると、それぞれのテキスト リストの対応する行に直接ジャンプします。表示されるテキストは、プログラミング システムに現在設定されている言語を使用してテキスト リストから読み取られます。この言語がテキスト リストにない場合は、エントリのデフォルトのテキストが使用されます。コラムでは デフォルト パラメータの初期値が表示されます。 このテーブルは、エントリの複数選択とマウスとキーボードによる標準的な処理をサポートしています。パラメータを変更するすべてのアクションは、標準の方法で元に戻すかやり直すことができます。 元に戻す そして やり直し コマンド。の カット 、 コピー 、 そして ペースト 機能はサポートされていません。 矢印ボタンまたは オルタナティブ + ↑ そして オルタナティブ + ↓ ショートカットを使用して、選択したパラメータを上下に移動して順序を変更します。 ボタンを使用すると、 バツ または標準 デル 選択したパラメータを削除するコマンド。 パラメータのエラーまたは警告は、メッセージ リストの下部に表示されます。メッセージを選択すると、上のパラメータ リストで対応するパラメータが選択されます。 アスタリスクの付いたボタンまたは オルタナティブ + n ショートカット (テーブルにフォーカスがある場合) を使用して、 新しいパラメータ ダイアログ： 拡張モジュールダイアログ: 新しいパラメータ ダイアログの上部には、機能ブロックのすべての互換性のある変数を含む階層テーブルが表示されます。 をアクティブにするには、 わかりました ボタン 変数は選択する必要があり、一意である必要があります ID を入力する必要があります。もし ID 一意ではない場合は、赤い感嘆符とエラー テキストが追加されます。 分野で 名前 そして 説明 標準テキストを入力すると、関連するテキスト リストに保存されます。次に、個々の言語のテキストをテキスト リストに追加する必要があります。 変数が汎用モジュールの入力変数または構造体のローカル変数の場合に表示されます。プリミティブ型の変数を選択できます。 " }, 
{ "title" : "I\/O ", 
"url" : "ac_io_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 拡張モジュールエディタ \/ I\/O ", 
"snippet" : "このタブ 拡張モジュールエディタ 新しい I\/O を作成するためのダイアログは、 パラメーター タブ。コラムの代わりに デフォルト 方向 イン\/アウト 入出力の状態が表示されます。 拡張モジュールダイアログ: I\/O...", 
"body" : "このタブ 拡張モジュールエディタ 新しい I\/O を作成するためのダイアログは、 パラメーター タブ。コラムの代わりに デフォルト 方向 イン\/アウト 入出力の状態が表示されます。 拡張モジュールダイアログ: I\/O " }, 
{ "title" : "HMI ", 
"url" : "ac_hmi_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 拡張モジュールエディタ \/ HMI ", 
"snippet" : "このタブ 拡張モジュールエディタ を定義できるようになります ページの視覚化 同様に 埋め込みビジュアライゼーション 。どちらのテキスト フィールドでも、カンマで区切って複数のビジュアライゼーション名を定義できます。 拡張モジュールダイアログ: HMI...", 
"body" : "このタブ 拡張モジュールエディタ を定義できるようになります ページの視覚化 同様に 埋め込みビジュアライゼーション 。どちらのテキスト フィールドでも、カンマで区切って複数のビジュアライゼーション名を定義できます。 拡張モジュールダイアログ: HMI " }, 
{ "title" : "視覚化画面 ", 
"url" : "f_application_composer_visualization_pages.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 視覚化画面 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "トップレベルのテンプレート ", 
"url" : "ac_toplevel_templates.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 視覚化画面 \/ トップレベルのテンプレート ", 
"snippet" : "トップレベル テンプレートは、生成されたビジュアライゼーションの開始ページのテンプレートです。これには、ユーザー固有のページと別のページに切り替えるためのタブのプレースホルダーとしてフレームが含まれています。オプションで、ページに移動するためのボタンと、ステータスとアドレスの行があります。トップレベルのテンプレートは、 視覚化ジェネレーター 。 図書館 AC_ModuleBase 、これは の標準インストールの一部です。 CODESYS Application Composer 3 つのトップレベルのテンプレートが含まれています。 AC.GenVisu_Toplevel_Template 、A...", 
"body" : "トップレベル テンプレートは、生成されたビジュアライゼーションの開始ページのテンプレートです。これには、ユーザー固有のページと別のページに切り替えるためのタブのプレースホルダーとしてフレームが含まれています。オプションで、ページに移動するためのボタンと、ステータスとアドレスの行があります。トップレベルのテンプレートは、 視覚化ジェネレーター 。 図書館 AC_ModuleBase 、これは の標準インストールの一部です。 CODESYS Application Composer 3 つのトップレベルのテンプレートが含まれています。 AC.GenVisu_Toplevel_Template 、AC.Toplevel_Vertical_Template、および AC.Toplevel_3S_Vertical_Template 。 標準のトップレベル テンプレート トップレベルのテンプレート: AC_Toplevel_3S_Vertical_Template 準備されたテンプレートの他に、ユーザー定義のトップレベル テンプレートを作成することもできます。 トップレベルテンプレートの要素 (1): ナビゲーション: 上\/戻る\/進む (2): ページを表示するフレーム (3): トップレベルのページに直接移動するためのタブ (4): ステータス行 (5): アドレス行: 表示されているモジュールインスタンスのインスタンスパス 視覚化テンプレートの要素は、要素名によって識別されます。以下のリストでは、要素の名前が括弧内に書かれています。 テンプレートの必須要素 [Frame] : ビジュアライゼーション ページを表示するメイン フレーム。最良の結果を得るには、フレームのスケール タイプを「等方性」に設定する必要があります。 [Tab_Template_1] 、 [Tab_Template_2] : すべてのタブの外観と配置に使用される 2 つの要素。 Tab_Template_1 は、最初のタブの位置とすべてのタブの外観を定義します。 Tab_Template_2 の位置から、タブの配置 (水平または垂直) とタブ間の間隔が計算されます。表示されているページの階層がタブで表されるインスタンスの下にある場合にアラームの色が設定されます。要素がボタンの場合、ボタンの状態変数も設定されます。要素がフレームの場合、アラームの色は使用されません。この代わりに、タブが選択されている場合、スイッチ フレーム変数は「1」に設定されます (デフォルトは 0)。 テンプレートのオプション要素 [Up] 、 [Back] 、 [Forward] : ボタンまたはフレームのナビゲーション用の要素。要素のタイプはボタンまたはフレームです。フレームの場合、フレームには 3 つのビジュアライゼーションが次の順序で含まれている必要があります: ニュートラル、押された、非アクティブ化。 [Address] : 表示されているモジュールインスタンスのインスタンスパスを出力するテキストフィールドです。 [Status] : グローバル文字列変数の内容を表示するテキストフィールド ac.g_stVisuStatusBar ライブラリ AC_ModuleBase から。この変数は、変数の状態を表示するために独自のモジュール実装で使用できます。 他のすべての要素は、視覚化ジェネレーターによって特に処理されません。生成のために、テンプレート視覚化はコピーをコピーし、そのコピーを変更します。オリジナルは変更されていません。 前述の視覚化要素を除き、視覚化ジェネレーターは手動で変更された要素を変更しないように努めます。最初の視覚化生成時に、記述された視覚化テンプレートがコピーされます。このコピーは、ユーザーによって削除されない限り、将来の世代の実行でのみ変更され、再コピーされません。これは、以前に実行されたジェネレーターのトップレベルのビジュアライゼーションを、コピーされませんが、あたかも新しいビジュアライゼーション テンプレートであるかのように扱うことによって行われます (元のテンプレートは決して変更されません)。したがって、追加のタブがある場合、これらのタブは既存のタブに追加されます。ユーザーが手動で追加したボタンやタブなどがその位置を維持できるように、他のすべてのプロパティと要素は可能な限り触れられません。 ナビゲーション ボタンなどを削除すると、それらのボタンが失われます。これらを生成するには、トップレベルの VISU を削除して再生成する必要があります。 " }, 
{ "title" : "タブの配置 ", 
"url" : "ac_toplevel_templates.html#UUID-b04a5efa-11da-0879-903b-e5e3a3f27499_ac_toplevel_templates0", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 視覚化画面 \/ トップレベルのテンプレート \/ タブの配置 ", 
"snippet" : "タブは左から右に水平に、または垂直に上から下に整列されます。テンプレート要素の相対位置 Tab_Template_1 そして Tab_Template_2 配置を定義します。要素の垂直方向の距離が水平方向の距離より大きい場合、要素は水平方向に配置され、それ以外の場合は垂直方向に配置されます。 垂直方向の配置の場合、すべてのタブは同じ幅になります。これは、すべてのタブ名を表示できる最小幅です。水平配置の場合、各タブはその名前を表示できる最小幅を取得します。どちらの場合も、タブの高さは最初のテンプレートの高さに設定されます( Tab_Template_1 ）。 配置には、最初のテンプレートがコピー...", 
"body" : "タブは左から右に水平に、または垂直に上から下に整列されます。テンプレート要素の相対位置 Tab_Template_1 そして Tab_Template_2 配置を定義します。要素の垂直方向の距離が水平方向の距離より大きい場合、要素は水平方向に配置され、それ以外の場合は垂直方向に配置されます。 垂直方向の配置の場合、すべてのタブは同じ幅になります。これは、すべてのタブ名を表示できる最小幅です。水平配置の場合、各タブはその名前を表示できる最小幅を取得します。どちらの場合も、タブの高さは最初のテンプレートの高さに設定されます( Tab_Template_1 ）。 配置には、最初のテンプレートがコピーされ、各タブに適応されます。 配置は最初のテンプレートの位置から開始されます。2 つのタブ間の距離は、2 つのテンプレート間の水平方向または垂直方向の距離によって決まります。この距離は負の値にすることもできます。その場合、次のタブが前方にあるため、次のタブが前のタブと重なり、その上にペイントされます。垂直方向の配置の場合、すべてのタブを収容するのに十分な下方向のスペースがない場合、生成はエラーで中止されます。タブの 2 番目の列は作成されません。水平方向の配置の場合、次のタブがビジュアリゼーション内で水平方向に収まらなくなると、新しい行が作成されます。行の最初のタブでこれが発生すると、生成はエラーで中止されます。 タブ用の十分なスペースがない場合があります。水平配置の場合、新しい行に折り返すときにこれが発生します。垂直方向に配置する場合、タブの幅がテンプレート内でタブに提供されているスペースよりも大きい場合にこの問題が発生します。このような場合、より多くのスペースを作成しようとします。この要素の自動配置により、タブを配置するには 4 つのケースが考えられます。 タブの水平方向の配置: すべてのタブが完全にフレームの上にある必要があります タブの水平方向の配置: すべてのタブが完全にフレームの下にある必要があります タブの垂直方向の配置: すべてのタブがフレームの左側に完全に配置されている必要があります タブの垂直方向の配置: すべてのタブがフレームの右側に完全に配置されている必要があります タブの配置が上記の制限と一致しない場合、エラー メッセージが作成されます。 タブに十分なスペースがない場合は、それに応じてフレームが縮小されます。タブとフレームの間のすべての要素が移動されます。要素の位置は、最初のタブ テンプレートの外側の制限の完全に外側にない場合、「タブとフレームの間」と解釈されます (以下の水平方向の配置の例を参照)。 フレームのサイズを変更すると負の値になる場合、ビジュアライゼーションの作成は中止されます。 タブとフレーム間の要素の例 タブとフレームの「外側」の要素の例 " }, 
{ "title" : "視覚化画面の生成 ", 
"url" : "ac_generating_visualization_pages.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 視覚化画面 \/ 視覚化画面の生成 ", 
"snippet" : "Application Composer の視覚化画面の場合、次のすべての要素 CODESYS V3 埋め込みの視覚化画面も使用できます。さらに、特別なプレースホルダーとしてマークされた visu 要素 (例: 長方形) を使用できます。 ビジュアライゼーション内のナビゲーション ビジュアライゼーション内のナビゲーションは、タブまたは 戻る 、 上 、 そして フォワード ナビゲーションボタン。タブ要素をマウスでクリックすると、対応する視覚化画面に直接切り替わります。の 戻る そして フォワード ボタンを使用して、表示された画面の履歴内を移動できます (インターネット ブラウザーのナビゲーショ...", 
"body" : "Application Composer の視覚化画面の場合、次のすべての要素 CODESYS V3 埋め込みの視覚化画面も使用できます。さらに、特別なプレースホルダーとしてマークされた visu 要素 (例: 長方形) を使用できます。 ビジュアライゼーション内のナビゲーション ビジュアライゼーション内のナビゲーションは、タブまたは 戻る 、 上 、 そして フォワード ナビゲーションボタン。タブ要素をマウスでクリックすると、対応する視覚化画面に直接切り替わります。の 戻る そして フォワード ボタンを使用して、表示された画面の履歴内を移動できます (インターネット ブラウザーのナビゲーションと同様)。の 上 ボタンを押すと、次の上位レベルに切り替わります。 " }, 
{ "title" : "視覚化画面のプレースホルダー要素 ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_1d3a1d9285970a30c0a8640e01de1c5b", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 視覚化画面 \/ 視覚化画面の生成 \/ 視覚化画面のプレースホルダー要素 ", 
"snippet" : "標準の視覚化要素 (例: 四角形、画像) をプレースホルダー要素として使用できます。ビジュアライゼーションを生成すると、割り当てられた埋め込みビジュアライゼーションがプレースホルダーの位置 (位置とサイズ) に配置されます。 仕様 プレースホルダー要素の定義は、要素のインスタンス名によって行われます。要素の名前は次のようにする必要があります PLACEHOLDER_<SUBPATH> 。の構文 <SUBPATH> : <SUBPATH> ::= <SLOTREF> | <SLOTREF>:<SUBPATH> <SLOTREF> ::= <SLOTNAME> | <SLOTNAME>[<idx>...", 
"body" : "標準の視覚化要素 (例: 四角形、画像) をプレースホルダー要素として使用できます。ビジュアライゼーションを生成すると、割り当てられた埋め込みビジュアライゼーションがプレースホルダーの位置 (位置とサイズ) に配置されます。 仕様 プレースホルダー要素の定義は、要素のインスタンス名によって行われます。要素の名前は次のようにする必要があります PLACEHOLDER_<SUBPATH> 。の構文 <SUBPATH> : <SUBPATH> ::= <SLOTREF> | <SLOTREF>:<SUBPATH> <SLOTREF> ::= <SLOTNAME> | <SLOTNAME>[<idx>] の <SLOTNAME> スロットのターゲット名です (大文字または小文字は関係ありません)。 <idx> マルチスロットにのみ使用できるゼロベースのインデックスです。マルチスロットのどのサブモジュール インスタンスを表示するかを定義します。 モジュール定義の読み取り中に、システムは視覚化画面内のプレースホルダー名が有効かどうかをチェックします。ビジュアライゼーション画面の要素が「」で始まる場合 PLACEHOLDER_ \" (大文字または小文字は関係ありません)、 <SUBPATH> 有効なスロット参照で開始する必要があります。インデックスが存在する場合は、スロット カーディナリティと互換性がある必要があります。パスのすべてのスロット名は有効な IEC 識別子である必要があります。複数のプレースホルダーがある場合は、すべてのパスが異なる必要があります。さらに、プレースホルダー要素には空の領域があってはなりません。 該当するモジュール インスタンスが存在しない場合、 <SUBPATH> プレースホルダー要素の場合、この要素にはビジュアライゼーションは割り当てられません。エラー メッセージは作成されません。 該当するモジュール インスタンスが存在する場合、 <SUBPATH> プレースホルダー要素の場合、この要素は、現在の画面の埋め込み画面視覚化として定義されている場合に埋め込まれます。 埋め込まれたビジュアライゼーションは元のアスペクト比を維持します。サイズは、プレースホルダーを超えてはみ出すことなく、可能な限り最適な方法でプレースホルダーに適合します。 プレースホルダー要素の例 プレースホルダーを使用して埋め込むことができるのは、サブモジュール インスタンスとそのサブモジュール インスタンスのみです。モジュール ツリーの他のブランチからビジュアライゼーションを埋め込むことはできません。 " }, 
{ "title" : "トップレベルのテンプレートを確認する ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_335369a685ed9d34c0a8652001ab0576", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 視覚化画面 \/ 視覚化画面の生成 \/ トップレベルのテンプレートを確認する ", 
"snippet" : "次のチェックがトップレベル画面で実行されます。 視覚化テンプレートが存在しない場合、またはそのインターフェイスに入力または出力が定義されている場合は、エラーが表示されます。 必須要素が欠落している場合は、エラーが表示されます。 トップレベル テンプレートの要素が定義されているが、その要素に空の領域があるか、間違った要素タイプがある場合、エラーが表示されます。 タブテンプレートとフレームが重なっている場合はエラーが表示されます。 2 番目のタブ テンプレートの位置が 1 番目のテンプレートと同じである場合、または 2 番目のタブ テンプレートの位置が最初のテンプレートの左側または上にある場合は、...", 
"body" : "次のチェックがトップレベル画面で実行されます。 視覚化テンプレートが存在しない場合、またはそのインターフェイスに入力または出力が定義されている場合は、エラーが表示されます。 必須要素が欠落している場合は、エラーが表示されます。 トップレベル テンプレートの要素が定義されているが、その要素に空の領域があるか、間違った要素タイプがある場合、エラーが表示されます。 タブテンプレートとフレームが重なっている場合はエラーが表示されます。 2 番目のタブ テンプレートの位置が 1 番目のテンプレートと同じである場合、または 2 番目のタブ テンプレートの位置が最初のテンプレートの左側または上にある場合は、エラーが表示されます。 タブを水平に配置する場合、タブが完全にフレームの上または下にない場合、エラーが発生します。 タブを垂直に配置する場合、タブがフレームの右側または左側に完全にない場合、エラーが発生します。 " }, 
{ "title" : "可視化画面の作成 ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_85c3e6868b643da6c0a8640e01a0782b", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 視覚化画面 \/ 視覚化画面の生成 \/ 可視化画面の作成 ", 
"snippet" : "すべての視覚化画面は、最初はコマンドによって作成されます。 生成する 。 2 回目のジェネレーターの実行では、モジュール ツリーの変更されたパラメーターのみが更新されます。 作成された視覚化画面には、視覚化のサイズを定義し、モジュールの対応する視覚化を保持するフレームが含まれています。このフレームは背景にあり、埋め込まれたすべてのビジュアライゼーションは次のように配置されます。 すべての埋め込み要素は要素 ID によって永続的に識別されます。既存の視覚化画面が新しいジェネレーターの実行によって更新される場合、システムは対応する ID を検索します。この要素 (ID) が存在する場合、モジュール...", 
"body" : "すべての視覚化画面は、最初はコマンドによって作成されます。 生成する 。 2 回目のジェネレーターの実行では、モジュール ツリーの変更されたパラメーターのみが更新されます。 作成された視覚化画面には、視覚化のサイズを定義し、モジュールの対応する視覚化を保持するフレームが含まれています。このフレームは背景にあり、埋め込まれたすべてのビジュアライゼーションは次のように配置されます。 すべての埋め込み要素は要素 ID によって永続的に識別されます。既存の視覚化画面が新しいジェネレーターの実行によって更新される場合、システムは対応する ID を検索します。この要素 (ID) が存在する場合、モジュール構成で変更されたパラメータのみが更新されます。たとえば、位置は変更されず、ビジュアライゼーション\/フレーム スイッチや表示に使用されるビジュアライゼーション オブジェクトが変更される可能性があります。 埋め込まれたビジュアライゼーションは、画面上で左から右、上から下の順に配置されます。一致するプレースホルダー要素の優先順位が高くなります。最後に、対応するフレームが存在する場合、両方のメカニズムは使用されません。 ElementID 生成中にすでに存在します。この場合、位置は変わりません。 前回のジェネレーターの実行で作成されたが、現在のジェネレーターの実行には存在しない視覚化画面は削除されます。 " }, 
{ "title" : "視覚化要素を埋め込む順序 ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_b67bb7c98bca4d3bc0a8640e01a07a7d", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 視覚化画面 \/ 視覚化画面の生成 \/ 視覚化要素を埋め込む順序 ", 
"snippet" : "最初のステップでは、によって埋め込まれたすべてのビジュアライゼーションが next Ancestor 手配されます。これらの要素は、モジュール ツリー内のモジュール インスタンスの優先順位に挿入されます。 (最初に最初の子、次にそのすべてのサブモジュール、次に 2 番目の子というように続きます) その後、インスタンスの定義によって埋め込まれたすべてのビジュアライゼーションが挿入されます。これは、モジュール インスタンスの事前注文でも行われます。...", 
"body" : "最初のステップでは、によって埋め込まれたすべてのビジュアライゼーションが next Ancestor 手配されます。これらの要素は、モジュール ツリー内のモジュール インスタンスの優先順位に挿入されます。 (最初に最初の子、次にそのすべてのサブモジュール、次に 2 番目の子というように続きます) その後、インスタンスの定義によって埋め込まれたすべてのビジュアライゼーションが挿入されます。これは、モジュール インスタンスの事前注文でも行われます。 " }, 
{ "title" : "永続化マネージャー ", 
"url" : "ac_pm_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー ", 
"snippet" : "Persistence Manager は、Application Composer の標準コンポーネントです。永続的な残留データを管理するために使用されます。このような変数を特定の方法で認識します。 属性 変数宣言で。それで、それは VAR PERSISTENT メカニズムの代替オプション 標準プログラミング システムの。特別なグローバル変数リストで永続変数を管理します ( 永続変数 ）。このメカニズムは、時間パフォーマンスと残留メモリ領域への保存を目的として設計されています。対照的に、永続性マネージャーは永続的な値を 外部ファイル したがって、コントローラーのメモリ リソースに対する要求が...", 
"body" : "Persistence Manager は、Application Composer の標準コンポーネントです。永続的な残留データを管理するために使用されます。このような変数を特定の方法で認識します。 属性 変数宣言で。それで、それは VAR PERSISTENT メカニズムの代替オプション 標準プログラミング システムの。特別なグローバル変数リストで永続変数を管理します ( 永続変数 ）。このメカニズムは、時間パフォーマンスと残留メモリ領域への保存を目的として設計されています。対照的に、永続性マネージャーは永続的な値を 外部ファイル したがって、コントローラーのメモリ リソースに対する要求が少なくなります。これにより、宣言が変更された場合でも値を保持できるようになり、外部からデータを編集できるようになります。ただし、この拡張機能にはパフォーマンスが犠牲になります。コントローラーによっては、読み取り、特に大量の永続変数の書き込みに時間がかかり、それぞれのタスクが非常に長くブロックされる可能性があります。 したがって、データの永続性を確立するためにどのメカニズムが推奨されるかは、ユースケースによって異なります。場合によっては、レシピの使用が最適な解決策となる場合もあります。意思決定を行うには、次を参照してください。 持続性 Persistence Manager はトップレベルのモジュールであり、次のコマンドを使用してモジュール ツリーに追加できます。 トップレベルのモジュールインスタンスを追加 。 Persistence Manager の下には、最大 64 個のチャネルを挿入できます。定義できるチャネルでは 永続化グループ パラメータによってストレージの動作を設定します。各チャネルはサブモジュールを取得する必要があります Data Storage 、永続データがファイルに書き込まれる形式を定義します。ここでは、永続データをファイルに保存する形式を定義します。このアーカイブ ファイルは外部に保存され、デフォルトではコントローラのインストール ディレクトリに保存されます。 ランタイム システム バージョン >= 3.5.8.0 の場合、アーカイブ ファイルの場所はプレースホルダーによって定義されます。 $ac_persistence$ 。すでに存在するアーカイブは、プレースホルダーで定義されたディレクトリ内で見つかった場合、この場所に移動されます。 $PLCLogic$ 。このディレクトリは、以前のランタイム システム バージョンではデフォルトの場所でした。両方の場所にあるアーカイブについては、ランタイム システム ログに警告が発行されます。 アプリケーションごとに 1 つの Persistence Manager のみをモジュール ツリーに追加できます。 Persistence Manager が POU プールに追加されている場合や、複数の永続化マネージャーがアプリケーションに追加されている場合は、エラー メッセージが作成されます。 Persistence Manager がモジュール ツリーに追加されました モジュール ツリーまたはモジュール インスタンスのパラメータが変更されている場合は、ジェネレータの実行を実行する必要があります。 （指示： 生成する) 「VAR PERSISTENCE」メカニズムとの違い 永続データは外部ファイルに保存されます。 永続データはプロジェクト間で交換できます。 永続変数はアプリケーションから削除できます。残りのデータを失うことなくアプリケーションに追加されます。 Persistence Manager によって作成されたデータは、外部エディタで変更できます。 (例: メモ帳)。 以下も参照してください。 持続性 " }, 
{ "title" : "永続性マネージャーモジュール ", 
"url" : "ac_pm_persistencemanager_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー \/ 永続性マネージャーモジュール ", 
"snippet" : "ダブルクリックすると、 永続化マネージャー モジュールツリー内のノード、または オブジェクトの編集 コマンドにより、関連するエディターが開きます。トップレベルモジュールの標準エディターに加えて (「 概要 ) 永続性マネージャーは、 持続性 タブ。 HMI Persistence Manager は、視覚化テンプレート ( VISU_PersistenceManager ) ビジュアライゼーションに追加できます。 HMI設定ダイアログ このページには、変数の読み取りと書き込みに関する統計情報が表示されます。 永続化データの視覚化ページ...", 
"body" : "ダブルクリックすると、 永続化マネージャー モジュールツリー内のノード、または オブジェクトの編集 コマンドにより、関連するエディターが開きます。トップレベルモジュールの標準エディターに加えて (「 概要 ) 永続性マネージャーは、 持続性 タブ。 HMI Persistence Manager は、視覚化テンプレート ( VISU_PersistenceManager ) ビジュアライゼーションに追加できます。 HMI設定ダイアログ このページには、変数の読み取りと書き込みに関する統計情報が表示されます。 永続化データの視覚化ページ " }, 
{ "title" : "持続性 ", 
"url" : "ac_pm_persistencemanager_module.html#UUID-87fcb435-c65b-2e65-6037-f61974f5b1d7_e4fa0ddccaa0cf0c0a8640e01493625_id_2bd57d34d6d13475c0a8640e0192d4cf", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー \/ 永続性マネージャーモジュール \/ 持続性 ", 
"snippet" : "ダイアログ： 持続性 の中に 持続性 ダイアログでは、1 つ以上のグループをストレージから除外できます。新しいグループを作成するには、一意の名前を入力し、 追加 ボタン。の 取り除く コマンドを使用すると、既存のグループを削除できます。 属性を使用して変数をストレージから除外できます。 ac_persist_exclude 。 詳細については、以下を参照してください。 「ac_persist_exclude」属性...", 
"body" : "ダイアログ： 持続性 の中に 持続性 ダイアログでは、1 つ以上のグループをストレージから除外できます。新しいグループを作成するには、一意の名前を入力し、 追加 ボタン。の 取り除く コマンドを使用すると、既存のグループを削除できます。 属性を使用して変数をストレージから除外できます。 ac_persist_exclude 。 詳細については、以下を参照してください。 「ac_persist_exclude」属性 " }, 
{ "title" : "永続チャネル ", 
"url" : "ac_pm_channel_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー \/ 永続チャネル ", 
"snippet" : "永続チャネルは、永続変数の 1 つ以上のグループのストレージ設定を定義します。コマンドを使用して Persistence Manager ノードに追加できます。 サブモジュールインスタンスの追加 。 Persistence Manager ノードの下には、最大 64 個のチャネルを作成できます。 HMI、情報 これらのダイアログの詳細については、以下を参照してください。 I\/O、 HMI と 情報。...", 
"body" : "永続チャネルは、永続変数の 1 つ以上のグループのストレージ設定を定義します。コマンドを使用して Persistence Manager ノードに追加できます。 サブモジュールインスタンスの追加 。 Persistence Manager ノードの下には、最大 64 個のチャネルを作成できます。 HMI、情報 これらのダイアログの詳細については、以下を参照してください。 I\/O、 HMI と 情報。 " }, 
{ "title" : "持続性 ", 
"url" : "ac_pm_channel_module.html#UUID-af8d821d-a61e-6db4-8c17-a9f12c86748c_dc660673ccac225bc0a8640e0116ede0_id_1c75f716cd06b00bc0a865200055fd43", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー \/ 永続チャネル \/ 持続性 ", 
"snippet" : "永続グループ このダイアログでは、このチャネルによって管理される 1 つ以上のグループを定義できます。デフォルトでは、チャネルモジュールインスタンスのインスタンス名がリストに表示されます。新しいグループを作成するには、一意の名前を入力し、 追加 ボタン。 取り除く 選択したグループを削除するために使用できます。 変数は属性を通じてグループに割り当てることができます。 ac_persist 。詳細については、以下を参照してください。 永続変数、属性の定義 'ac.persist' 永続化変数 : このリストには、上記の永続グループのいずれかに割り当てられたすべての永続変数が表示されます。...", 
"body" : "永続グループ このダイアログでは、このチャネルによって管理される 1 つ以上のグループを定義できます。デフォルトでは、チャネルモジュールインスタンスのインスタンス名がリストに表示されます。新しいグループを作成するには、一意の名前を入力し、 追加 ボタン。 取り除く 選択したグループを削除するために使用できます。 変数は属性を通じてグループに割り当てることができます。 ac_persist 。詳細については、以下を参照してください。 永続変数、属性の定義 'ac.persist' 永続化変数 : このリストには、上記の永続グループのいずれかに割り当てられたすべての永続変数が表示されます。 " }, 
{ "title" : "パラメータ ", 
"url" : "ac_pm_channel_module.html#UUID-af8d821d-a61e-6db4-8c17-a9f12c86748c_dc660673ccac225bc0a8640e0116ede0_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー \/ 永続チャネル \/ パラメータ ", 
"snippet" : "の パラメーター タブには、変数の保存に関するオプションのリストが表示されます。 永続チャネルのパラメータ t定期保存 : この間隔が経過すると、変数が保存されます。値の入力 t#0s この定期的な保存をオフにします。 xSaveOnChange : TRUE に設定すると、現在値と最後に保存された値が常に比較され、異なる場合は現在の値が保存されます。設定された永続チャネル xSaveOnChange=FALSE 、コントローラのシャットダウン時およびリセット時（ウォーム、コールド、原点）に保存されます。さらに、定期的な保存も可能です。 xReadVarsDuringInit : に設定されて...", 
"body" : "の パラメーター タブには、変数の保存に関するオプションのリストが表示されます。 永続チャネルのパラメータ t定期保存 : この間隔が経過すると、変数が保存されます。値の入力 t#0s この定期的な保存をオフにします。 xSaveOnChange : TRUE に設定すると、現在値と最後に保存された値が常に比較され、異なる場合は現在の値が保存されます。設定された永続チャネル xSaveOnChange=FALSE 、コントローラのシャットダウン時およびリセット時（ウォーム、コールド、原点）に保存されます。さらに、定期的な保存も可能です。 xReadVarsDuringInit : に設定されている場合 TRUE 、永続変数の値はアプリケーションの初期化中に読み取られます。それ以外の場合、それらは最初のアプリケーション サイクルでロードされます。 x圧縮タグ : に設定されている場合 TRUE 、変数のインスタンス パスは圧縮形式で保存されます。詳細については、以下を参照してください。 ストレージ形式、圧縮アーカイブ 。 xConsistentCopyInHighPrioTask : に設定されている場合 TRUE の場合、変数は優先度が最も高いタスクからコピーされ、優先度が低いタスクに保存されます。このオプションは、優先度の高いタスクで変数が変更された場合にデータの不整合を回避するために使用されます。 xConvertVarsWithDifferentType : に設定されている場合 TRUE 、永続化チャネルは、アーカイブから読み取られた値をターゲットのデータ型に変換しようとします (値のデータ型がターゲットのデータ型と異なる場合)。成功すると、アーカイブからの値が受け入れられます。そうでない場合、値は拒否されます。この関数は次の変換をサポートしています。 アーカイブ内のデータ型 対象のデータ型 説明 任意の整数 任意の整数 値が現在のデータ型でカバーされる範囲内にある場合のみ 任意の整数 本物 任意の整数 Lリアル すべてのデータ型 弦 本物 Lリアル 本物 ANY_INT アーカイブ値が正しい範囲の整数である場合のみ Lリアル 本物 値が REAL でカバーされる範囲内にある場合のみ Lリアル ANY_INT アーカイブ値が正しい範囲の整数である場合のみ xIntegrityCheckBeforeReading : に設定されている場合 TRUE 、データベースの整合性がチェックされます。 xSeparateArchivePerToplevelInstance : TRUE に設定すると、トップレベルインスタンスごとに個別のアーカイブが作成されます。アーカイブ名は、データストレージで設定されたアーカイブ名にトップレベルインスタンス名が付加されたものになります。つまり、トップレベルモジュールインスタンスの下位に存在しないすべてのインスタンス（例：アプリケーション変数）の場合は <archive name>_<instance name> 、そうでない場合は <archive name> となります。このオプションはデフォルトで無効になっています。 後でパラメータを変更する場合 ( TRUE <-> FALSE )、アーカイブ名が変更され、永続変数が失われる可能性があります。 xMakeDataCRCConsistencyCheck : に設定されている場合 TRUE 、CRC 値は保存操作の開始時と終了時に計算されます。保存操作を正常に完了するには、これら 2 つの値が同じである必要があります。 uiCRCConsistencyCheck が失敗した場合の保存再試行 : 保存を繰り返す回数を指定します。 xMakeDataCRCConsistencyCheckFails に設定されています TRUE CRC 値が一致しません。 xLogSaveTimeEnabled : に設定されている場合 TRUE 、書き込みに要した時間が記録されます。 e自動アクションオンライン変更 : オンライン変更中に変数の値が保存されるかどうか、およびその方法の動作。 なし : ストレージなし 保存 ：値が保存されます。したがって、構成への変更も永続メモリに引き継がれます (変数の追加や名前変更など)。 負荷 : 値は永続メモリからロードされます。したがって、可能な初期化（たとえば、 FB_INIT 、 IModule.Init 、モジュール パラメーター) は、永続化された値によって上書きされます。 ロードして保存 : 値は永続メモリからロードされるだけでなく、永続メモリから書き込まれます。 eAutomaticActionPlcStop : リセット中に変数の値を保存するかどうかを決定します。 なし : ストレージなし 保存 ：値が保存されます。 " }, 
{ "title" : "モジュール: データストレージ ", 
"url" : "ac_pm_storage_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー \/ モジュール: データストレージ ", 
"snippet" : "データストレージ サブモジュール データストレージ を定義します 保存形式 の 永続チャネル 。 次のストレージ形式のいずれかを選択します。 ASCIIFileStorage : 値を ASCII 形式でファイルに保存します。 の ASCIIFileStorage 形式を使用すると、テキスト エディタでアーカイブ ファイルを開いて値を変更できます。 ASCII ファイルアーカイブにコメントを追加できます。これらは、ファイルの読み取り時には無視されます。 BinaryFileStorage : 値をバイナリ形式でファイルに保存します。 BinaryMemoryStorage : 値をバイナリ形式...", 
"body" : "データストレージ サブモジュール データストレージ を定義します 保存形式 の 永続チャネル 。 次のストレージ形式のいずれかを選択します。 ASCIIFileStorage : 値を ASCII 形式でファイルに保存します。 の ASCIIFileStorage 形式を使用すると、テキスト エディタでアーカイブ ファイルを開いて値を変更できます。 ASCII ファイルアーカイブにコメントを追加できます。これらは、ファイルの読み取り時には無視されます。 BinaryFileStorage : 値をバイナリ形式でファイルに保存します。 BinaryMemoryStorage : 値をバイナリ形式でコンパイラまたは該当デバイスの「RETAIN」領域に保存します (例: 該当デバイスの NVRAM に)。 PersistentBinaryMemoryStorage : 値をバイナリ形式でコンパイラまたは該当するデバイスの「永続」領域に保存します (例: 当該デバイスの NVRAM に)。 永続チャネルの下に、 データストレージ 目的の形式のモジュール。必要に応じて、次の構成を変更します。 パラメータ タブ： ダイアログ: 情報 このダイアログの詳細については、次を参照してください。 情報 。 " }, 
{ "title" : "ダイアログ: パラメータ ", 
"url" : "ac_pm_storage_module.html#UUID-1d4190f0-4f49-535e-fe96-bf340f625ee5_aa44ae4cccad1068c0a8640e019d97f0_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー \/ モジュール: データストレージ \/ ダイアログ: パラメータ ", 
"snippet" : "sアーカイブ名 アーカイブファイルの名前 デフォルトはプレースホルダーです %CHANNEL_NAME% 定義されています。このプレースホルダーは、親永続チャネルのインスタンス名に置き換えられます。すべてのアーカイブ ファイルは同じディレクトリに保存されるため、アーカイブ名は一意である必要があります。 注: アーカイブ ファイルのデフォルトの保存場所は、ランタイム システムのバージョンによって異なります。見る： 永続化マネージャーの概要 xダブルストレージ 有効化されている場合 ( TRUE )、変数は 2 つの異なるアーカイブ ( sArchive1 、 sArchive2 ）。ファイルが破...", 
"body" : "sアーカイブ名 アーカイブファイルの名前 デフォルトはプレースホルダーです %CHANNEL_NAME% 定義されています。このプレースホルダーは、親永続チャネルのインスタンス名に置き換えられます。すべてのアーカイブ ファイルは同じディレクトリに保存されるため、アーカイブ名は一意である必要があります。 注: アーカイブ ファイルのデフォルトの保存場所は、ランタイム システムのバージョンによって異なります。見る： 永続化マネージャーの概要 xダブルストレージ 有効化されている場合 ( TRUE )、変数は 2 つの異なるアーカイブ ( sArchive1 、 sArchive2 ）。ファイルが破損した場合 (例: 変数の保存中にコントローラがシャットダウンしたことによる)、バックアップ ファイルが使用されます。ファイルが開かれると、永続化マネージャーは両方のアーカイブのタイムスタンプをチェックします。損傷がない場合は新しいアーカイブが使用され、損傷がない場合はもう一方のアーカイブが使用されます。 udi最大ファイルサイズ 最大ファイルサイズ（バイト単位） もし 0 が定義されている場合、制限は設定またはチェックされないため、ファイルのサイズは任意です。 byセパレーター 変数名と値の間の区切り文字の ASCII 値。 udiMemDataSize モジュール用に作成される「RETAIN」変数領域のメモリのサイズ。 この値は保存するデータのデータサイズと比較されます。値が明らかに小さすぎる場合は、コンパイラ エラーが発行されます。値が小さすぎる可能性がある場合は、メッセージ ウィンドウに警告メッセージが表示されます。 LineEnding ファイル内の行の終わりを示す文字 " }, 
{ "title" : "永続変数の定義 ", 
"url" : "ac_pm_definition_persistent_variables.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー \/ 永続変数の定義 ", 
"snippet" : "単一変数、構造体インスタンス、関数ブロック インスタンスは、属性を使用して「永続的」としてマークできます。インスタンスがマークされると、インスタンスのすべてのメンバーが VAR 、 VAR_INPUT 、 そして VAR_OUTPUT 永続的に保存されます。変数が VAR PERSISTENT セクションが「永続的」としてマークされている場合、警告が作成されます。 さらに、デフォルトのストレージ グループを定義したり、構造または関数ブロック インスタンスの永続ストレージから特定の変数を除外したりするための属性もあります。 永続変数の定義が変更されている場合 (追加、削除、名前変更、データ型の変...", 
"body" : "単一変数、構造体インスタンス、関数ブロック インスタンスは、属性を使用して「永続的」としてマークできます。インスタンスがマークされると、インスタンスのすべてのメンバーが VAR 、 VAR_INPUT 、 そして VAR_OUTPUT 永続的に保存されます。変数が VAR PERSISTENT セクションが「永続的」としてマークされている場合、警告が作成されます。 さらに、デフォルトのストレージ グループを定義したり、構造または関数ブロック インスタンスの永続ストレージから特定の変数を除外したりするための属性もあります。 永続変数の定義が変更されている場合 (追加、削除、名前変更、データ型の変更)、新しいコンポーザー コード生成 (Generate コマンド) を実行する必要はありません。これらの変更は、コンパイル中に Persistent Manager インスタンスで自動的に更新されます。 データ型定義が変更された場合に発生する可能性のある暗黙的な変換については、以下を参照してください。 パラメータ 属性: 'ac_persist_exclude' 属性 'ac_persist_exclude' 構造体または関数ブロック宣言内のメンバーが「永続的」として定義されているかどうかに関係なく、永続ストレージから変数を除外するために使用されます。宣言に永続メンバーが存在しない場合、コード生成中にエラーが発生します。 変数の除外例 PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist_exclude'}\n fb1 : FB;\nEND_VAR " }, 
{ "title" : "サポートされているデータ型 ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_beff9eaed151b190c0a8640e01016617", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー \/ 永続変数の定義 \/ サポートされているデータ型 ", 
"snippet" : "次のデータ型のインスタンスは永続的に保存できません。 少し ポインタ インターフェース 定数 非永続データ型の配列 他のすべてのデータ型がサポートされています。これには、列挙型、部分範囲データ型、配列の配列、および多次元配列が含まれます。 ARRAY[0..9] OF ARRAY[5..6, 7..8, 9..10] OF INT データ・タイプ： 連合 ユニオンのインスタンスを永続的に保存するには、最初にそのフィールドの 1 つをいわゆる「代表」として明確にマークする必要があります。これには 3 つのオプションがあります。 共用体の宣言内の 1 つのフィールドだけが属性でマークされます。 a...", 
"body" : "次のデータ型のインスタンスは永続的に保存できません。 少し ポインタ インターフェース 定数 非永続データ型の配列 他のすべてのデータ型がサポートされています。これには、列挙型、部分範囲データ型、配列の配列、および多次元配列が含まれます。 ARRAY[0..9] OF ARRAY[5..6, 7..8, 9..10] OF INT データ・タイプ： 連合 ユニオンのインスタンスを永続的に保存するには、最初にそのフィールドの 1 つをいわゆる「代表」として明確にマークする必要があります。これには 3 つのオプションがあります。 共用体の宣言内の 1 つのフィールドだけが属性でマークされます。 ac_persist_union_representant (属性値なし)。このフィールドは結合を「表します」。その値は、完全な結合を代表して保存およびロードされます。 共用体の宣言内の 1 つのフィールドだけが属性でマークされます。 ac_persist – これは同時に代表者を定義します。 ユニオンのインスタンスは属性でマークされます。 ac_persist_union_set_representant 属性値も含めて。属性値は、代表として使用される共用体フィールドの名前を記述します。この属性は既存の属性を上書きします。 ac_persist_union_representant 共用体の宣言内の属性。共用体の配列にもマークを付けて、配列の要素を参照することができます。 例 「ac_persist_union_representant」 TYPE UnionWithRep :\nUNION\n di : DINT ;\n {attribute 'ac_persist_union_representant'}\n dw : DWORD ;\nEND_UNION\nEND_TYPE 'ac_persist' TYPE UnionWithPersist :\nUNION\n di : DINT ;\n {attribute 'ac_persist' := 'TestUnion'}\n dw : DWORD ;\nEND_UNION\nEND_TYPE 「ac_persist_union_set_representant」 FUNCTION_BLOCK FBTestUnion\nVAR\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n u2 : UnionWithoutRep ;\nEND_VAR 和集合の配列 VAR\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n aElems ARRAY[0..7] OF SomeUnion ;\n\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n aaElems ARRAY[0..7] OF ARRAY[0..1] OF SomeUnion ;\nEND_VAR 代表者が有効であるためには、次のルールを満たす必要があります。 代表者は組合全体と同じ規模でなければなりません。そうしないと、完全なデータが保存されません。また、代表にはパディング領域 (ストレージ内のデータを整列させるためにコンパイラによって作成される空のデータ領域) があってはなりません。 プリミティブ データ型への代表の分解には、型のインスタンスが含まれない場合があります。 REAL または LREAL または型のインスタンス STRING または WSTRING 持っている。 さらに、代表はサポートされているタイプで構成されている必要があります (上記を参照)。たとえば、代表者は次のようなタイプになります。 Structure – ただし、構造体自体にポインタを含めることはできません。 " }, 
{ "title" : "属性: 'ac_persist' ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_e844aaa8d151b192c0a8640e01722fe3", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー \/ 永続変数の定義 \/ 属性: 'ac_persist' ", 
"snippet" : "属性「 ac_persist ' に使用できます 変数 構造体のインスタンス ファンクションブロックのインスタンス 構造体のメンバー ファンクションブロックのメンバー {attribute 'ac_persist' [ := '<PERSISTENCE_GROUP>']} PERSISTENCE_GROUP の名前です 永続化グループ 宣言を割り当てるべき場所。有効な IEC 識別子である必要があります。ここで永続グループの名前が指定されていない場合、割り当ては属性に従って行われます。 'ac_persist_set_default_group' 、この場合は定義する必要があります。 構造体イ...", 
"body" : "属性「 ac_persist ' に使用できます 変数 構造体のインスタンス ファンクションブロックのインスタンス 構造体のメンバー ファンクションブロックのメンバー {attribute 'ac_persist' [ := '<PERSISTENCE_GROUP>']} PERSISTENCE_GROUP の名前です 永続化グループ 宣言を割り当てるべき場所。有効な IEC 識別子である必要があります。ここで永続グループの名前が指定されていない場合、割り当ては属性に従って行われます。 'ac_persist_set_default_group' 、この場合は定義する必要があります。 構造体インスタンスまたは関数ブロック インスタンスが「永続的」としてマークされており、宣言内の少なくとも 1 つのメンバーも「永続的」としてマークされている場合、エラー メッセージが作成されます。 永続インスタンスの例 変数 t 永続化グループに割り当てられます PROCESS 。すべてのメンバーは永続的に保存されます。 PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist' := 'PROCESS'}\n t : TON;\nEND_VAR 関数ブロックの永続メンバーの例 メンバー iNumIOs 永続化グループに割り当てられます CONFIG 。このメンバーは、関数ブロックのすべてのインスタンスに対して永続的に保存されます (属性によって明示的に抑制されていない場合) 'ac_persist_exclude' ）。 FUNCTION_BLOCK FB\nVAR\n {attribute 'ac_persist' := 'CONFIG'}\n iNumIOs : INT := 0;\nEND_VAR " }, 
{ "title" : "属性: 'ac_persist_set_default_group' ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_4130a661d151b192c0a8640e00b1a163", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー \/ 永続変数の定義 \/ 属性: 'ac_persist_set_default_group' ", 
"snippet" : "属性にグループ名が欠落している場合 'ac_persist' 、 デフォルトグループ それぞれの変数を直接的または間接的に含む関数ブロック インスタンスまたは構造体インスタンスで定義する必要があります。これは属性で可能です 'ac_persist_set_default_group' 。この属性は、ファンクション ブロックのメンバーにも設定できます。最も内側に見つかった定義は、 'ac_persist_set_default_group' 変数のデフォルトのグループとして使用されます。 使用は許可されていません 'ac_persist_set_default_group' 一緒に 'ac_pe...", 
"body" : "属性にグループ名が欠落している場合 'ac_persist' 、 デフォルトグループ それぞれの変数を直接的または間接的に含む関数ブロック インスタンスまたは構造体インスタンスで定義する必要があります。これは属性で可能です 'ac_persist_set_default_group' 。この属性は、ファンクション ブロックのメンバーにも設定できます。最も内側に見つかった定義は、 'ac_persist_set_default_group' 変数のデフォルトのグループとして使用されます。 使用は許可されていません 'ac_persist_set_default_group' 一緒に 'ac_persist' または 'ac_persist_exclude' 。この場合、コード生成中にエラー メッセージが作成されます。 デフォルトグループの例 FUNCTION_BLOCK FB_Util\nVAR\n {attribute 'ac_persist'} \/\/ no group\n \/\/'ac_persist_set_default_group‘ and 'ac_persist_exclude' not allowed here\n i : INT := 0;\nEND_VAR PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist_set_default_group' := 'PROCESS'}\n fbu1 : FB_Util;\n\n {attribute 'ac_persist_set_default_group'´ := 'CONFIG'}\n fbu2 : FB_Util;\nEND_VAR " }, 
{ "title" : "データストレージ ", 
"url" : "ac_pm_data_storage.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー \/ データストレージ ", 
"snippet" : "永続変数の保存は、さまざまな方法でトリガーできます。 それぞれ 永続チャネル アプリケーションがストレージをトリガーするために使用できるアプリケーション インターフェイスを提供します (「 データアクセス ）。 永続チャネルのパラメータには時間間隔 ( t定期保存 ) 自動ストレージ用に定義できます。 永続チャネルは、値が変更されるたびに変数を保存するように構成できます。このために、以前の値と現在の値が比較されます。それらが異なる場合、ストレージがトリガーされます。 さまざまなストレージ方法を並行して使用でき、相互に排他的ではありません。 コントローラのシャットダウンの場合、または「リセット」...", 
"body" : "永続変数の保存は、さまざまな方法でトリガーできます。 それぞれ 永続チャネル アプリケーションがストレージをトリガーするために使用できるアプリケーション インターフェイスを提供します (「 データアクセス ）。 永続チャネルのパラメータには時間間隔 ( t定期保存 ) 自動ストレージ用に定義できます。 永続チャネルは、値が変更されるたびに変数を保存するように構成できます。このために、以前の値と現在の値が比較されます。それらが異なる場合、ストレージがトリガーされます。 さまざまなストレージ方法を並行して使用でき、相互に排他的ではありません。 コントローラのシャットダウンの場合、または「リセット」（ウォーム\/コールド\/原点）後、パラメータが設定されている場合、データは自動的に保存されます。 xSaveOnChange は設定されていません。 詳細については、以下も参照してください。 データストレージモジュール " }, 
{ "title" : "保存形式 ", 
"url" : "ac_pm_storage_format.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー \/ 保存形式 ", 
"snippet" : "インターフェースには 2 つの実装があります IDataStorage 利用可能： ASCIIDataStorage そして BinaryDataStorage 。 どちらの形式でも、最初に保存される変数は予約変数です。 ___xCompressTags タイプの BOOL 。その値によって、インスタンス パスが圧縮されて保存されるかどうかが決まります。整合性オブジェクトが書き込まれる場合、それは という名前の最後の変数として書き込まれます。 ___Integrity タイプの BOOL 価値のあるもの TRUE 。これらの予約変数を除くすべての永続変数は、順番に保存され、完全なインスタンス ...", 
"body" : "インターフェースには 2 つの実装があります IDataStorage 利用可能： ASCIIDataStorage そして BinaryDataStorage 。 どちらの形式でも、最初に保存される変数は予約変数です。 ___xCompressTags タイプの BOOL 。その値によって、インスタンス パスが圧縮されて保存されるかどうかが決まります。整合性オブジェクトが書き込まれる場合、それは という名前の最後の変数として書き込まれます。 ___Integrity タイプの BOOL 価値のあるもの TRUE 。これらの予約変数を除くすべての永続変数は、順番に保存され、完全なインスタンス パスによって並べ替えられます。インスタンスのパスが圧縮されているかどうかは関係ありません。 データがユーザーによって変更された場合、ユーザーは正しい並べ替え順序が維持されることを確認する必要があります。 圧縮アーカイブ 変数値は、リソースと時間を節約するために、コンパクトなスペルのパスと名前 (パスにはアプリケーション名もデバイス名も含まれません) とともに保存されます。 いずれの場合も (圧縮されているかどうかに関係なく)、インスタンス パスは完全なインスタンス パスの順序で並べ替える必要があります。この並べ替え順序はアルファベット順であるため、配列インデックスは数値順に並べ替えられます。 例 オブジェクト 圧縮フォーマット Fb1.fb2.fb3.a Fb1.fb2.fb3.a Fb1.fb2.fb3.b <b Fb1.fb2.d <<d Fb4 FB4 " }, 
{ "title" : "ASCII形式 ", 
"url" : "ac_pm_storage_format.html#UUID-fdd959e2-aa65-d5fc-5e9f-c1b6b7e12d4a_d165b0fbc0a8640e003c31fa_id_7b30973fd16738e7c0a8640e01455e29", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー \/ 保存形式 \/ ASCII形式 ", 
"snippet" : "ASCIIDataStorage 永続変数 (パックされている可能性がある) のインスタンス パス、型、および値を文字列としてファイルに書き込みます。名前と残りの日付はタブ文字で区切られます（パラメータを使用して変更可能） codbySeparator ）。読み出し時に変換が行われます。したがって、ファイルは外部から編集することもできます。行は「\\r\\n」で区切る必要があります (Windows の規則)。セミコロンで始まる行は、読み取り時に無視され、再保存時に再度挿入されません。 ASCII ファイルの形式: {timestamp}\\r\\n {instance path}{bySeparat...", 
"body" : "ASCIIDataStorage 永続変数 (パックされている可能性がある) のインスタンス パス、型、および値を文字列としてファイルに書き込みます。名前と残りの日付はタブ文字で区切られます（パラメータを使用して変更可能） codbySeparator ）。読み出し時に変換が行われます。したがって、ファイルは外部から編集することもできます。行は「\\r\\n」で区切る必要があります (Windows の規則)。セミコロンで始まる行は、読み取り時に無視され、再保存時に再度挿入されません。 ASCII ファイルの形式: {timestamp}\\r\\n\n{instance path}{bySeparator}{Typ}:{value}\\r\\n\n…\n{instance path}{bySeparator}{Typ}:{value}\\r\\n タイムスタンプによって、ストレージがトリガーされた時間が決まります。 DATE_AND_TIME リテラルとして記述されます (例: DT#2012-01-11-15:11:09 ) ASCII ファイルの例 の治療 REAL そして LREAL 変数: 変数の値は ST リテラルとして記述されます。 REAL そして LREAL 精度を損なうことなく小数への変換と小数からの変換が実装されるため、値は別の方法で処理されます。ただし、精度の低下を避け、可読性と ASCII ファイルの変更可能性を維持するために、これらの値は 16 進数形式で保存されます。 (不正確な) 小数部が 16 進値の後ろにコメントとして追加されます。ファイルの読み取り中は、ST 10 進形式だけでなく 16 進形式もサポートされます。これにより、ユーザーは小数を変更できるようになります。 16 進形式は次のように定義されます。 F16#{Mantissa}H{Exp} | F16#NaN | F16#+Inf | F16#-Inf\n{Mantissa} ::= {HexNumeral}\n{Exp} ::= {HexNumeral}\n{HexNumeral} ::= [+-]?[1-9A-F][0-9A-F]* もし m は仮数部の値であり、 e 数値の値よりも指数の値が m * 16^e 。 格納された REAL 値の例 lr1 LREAL:F16#F0H-3 0.05859375 " }, 
{ "title" : "バイナリ形式 ", 
"url" : "ac_pm_storage_format.html#UUID-fdd959e2-aa65-d5fc-5e9f-c1b6b7e12d4a_d165b0fbc0a8640e003c31fa_id_602fd614d22a5f95c0a8640e0110d837", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー \/ 保存形式 \/ バイナリ形式 ", 
"snippet" : "BinaryDataStorage データをバイナリ形式で保存します。タイムスタンプはそれに続きます (タイプ DATE_AND_TIME ）。その後、変数がリストされます。...", 
"body" : "BinaryDataStorage データをバイナリ形式で保存します。タイムスタンプはそれに続きます (タイプ DATE_AND_TIME ）。その後、変数がリストされます。 " }, 
{ "title" : "データアクセス ", 
"url" : "ac_pm_data_access.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー \/ データアクセス ", 
"snippet" : "Persistence Manager は、PersistenceChannel タイプのサブモジュール インスタンスを最大 10 個提供します。各永続チャネルは、次のタイプのサブモジュール インスタンスを提供します。 DataStorage データアクセスを担当します。このインスタンスはインターフェイスを実装します IDataStorage :...", 
"body" : "Persistence Manager は、PersistenceChannel タイプのサブモジュール インスタンスを最大 10 個提供します。各永続チャネルは、次のタイプのサブモジュール インスタンスを提供します。 DataStorage データアクセスを担当します。このインスタンスはインターフェイスを実装します IDataStorage : " }, 
{ "title" : "診断 ", 
"url" : "ac_pm_diagnosis.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー \/ 診断 ", 
"snippet" : "それぞれ 永続チャネル データアクセスを可能にするサブモジュールがあります（インターフェース IDataStorage ）。次の出力は診断情報を提供します。 出力 データ・タイプ 説明 xActionOngoing BOOL TRUE Persistence Manager がデータの読み取りまたは書き込みを行うかどうか udiDataMemSize UDINT 永続データのデータ サイズ (バイト単位) xReadingDone BOOL 永続データの読み取りが完了しました dtLastReading DT 最後に読み取りを行った日時 uiNumberVarsNotOk UINT 正しく読み...", 
"body" : "それぞれ 永続チャネル データアクセスを可能にするサブモジュールがあります（インターフェース IDataStorage ）。次の出力は診断情報を提供します。 出力 データ・タイプ 説明 xActionOngoing BOOL TRUE Persistence Manager がデータの読み取りまたは書き込みを行うかどうか udiDataMemSize UDINT 永続データのデータ サイズ (バイト単位) xReadingDone BOOL 永続データの読み取りが完了しました dtLastReading DT 最後に読み取りを行った日時 uiNumberVarsNotOk UINT 正しく読み取れなかった変数の数 uiNumberVarsOk UINT 正しく読み取られた変数の数 tTimeForReading TIME 読書にかかる時間 dtLastSaving DT 最後に読み取りを行った日時 tTimeForWriting TIME 書き込み時間 uiWritingCycles UINT 申請開始までの保管数 読み取られた変数の数と保存の成功に関する情報も PLC ロガーに表示されます。 PLCロギング¶ " }, 
{ "title" : "エラー処理 ", 
"url" : "ac_pm_error_handling.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ 永続化マネージャー \/ エラー処理 ", 
"snippet" : "エラー番号と関連する文字列は、標準モジュール インターフェイス ( ClearErrors 、 FirstErrorNumber 、 GetFirstErrorMessage 、 LastErrorNumber 、 GetLastErrorMessage ）。 エラー番号 説明 100 永続データのリストが変更され、初期サイズと一致しません 110 メモリ (比較または一貫性のあるコピー用) を作成できません。 <ErrorCode SysMemAllocData> 。機能はオフになっています。 120 比較ストレージ用にデータ ストレージを作成できません。機能はオフになっています。 130 ...", 
"body" : "エラー番号と関連する文字列は、標準モジュール インターフェイス ( ClearErrors 、 FirstErrorNumber 、 GetFirstErrorMessage 、 LastErrorNumber 、 GetLastErrorMessage ）。 エラー番号 説明 100 永続データのリストが変更され、初期サイズと一致しません 110 メモリ (比較または一貫性のあるコピー用) を作成できません。 <ErrorCode SysMemAllocData> 。機能はオフになっています。 120 比較ストレージ用にデータ ストレージを作成できません。機能はオフになっています。 130 一貫性のあるコピー用にデータ ストレージが作成されていません 140 型の永続変数 String 無効なサイズがあります: <変数名> 150 永続変数はサポートされているタイプではありません: <変数の名前> 160 データベースを開けません。読み取りが中止されました: <データベース オブジェクトのエラーの詳細な説明> 170 データベースを閉じることができません。読み取りが中止されました: <データベース オブジェクトのエラーの詳細な説明> 190 データベースを作成できません。保存が中止されました。 <データベース オブジェクトのエラーの詳細な説明> 200 データベースを開けません。保存が中止されました。 <データベース オブジェクトのエラーの詳細な説明> 210 データベースを閉じることができません。 <データベース オブジェクトのエラーの詳細な説明> 220 エントリの書き込み中にエラーが発生しました: <データベース オブジェクトのエラーの詳細な説明> 230 システム時刻の読み取り中にエラーが発生しました " }, 
{ "title" : "データログマネージャー ", 
"url" : "ac_dlm_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ データログマネージャー ", 
"snippet" : "DataLog Manager は、Application Composer の標準コンポーネントです。これは、変数値をファイルに周期的に保存するために機能します。これらの変数には特別なフラグが付けられます 属性 変数宣言で。 モジュールを利用可能にするには、 AC_DataLog 図書館を図書館管理者に。 モジュール ツリーに追加できる DataLog Manager は、アプリケーションごとに 1 つだけです。 DataLog Manager はトップレベルのモジュールであり、次のコマンドを使用してモジュール ツリーに追加できます。 トップレベルのモジュールインスタンスを追加 指示。 Da...", 
"body" : "DataLog Manager は、Application Composer の標準コンポーネントです。これは、変数値をファイルに周期的に保存するために機能します。これらの変数には特別なフラグが付けられます 属性 変数宣言で。 モジュールを利用可能にするには、 AC_DataLog 図書館を図書館管理者に。 モジュール ツリーに追加できる DataLog Manager は、アプリケーションごとに 1 つだけです。 DataLog Manager はトップレベルのモジュールであり、次のコマンドを使用してモジュール ツリーに追加できます。 トップレベルのモジュールインスタンスを追加 指示。 DataLog Manager の下には、最大 64 個のチャネルを挿入できます。チャネルでは、グループを定義し、パラメータによってそのストレージ動作を構成できます。各チャネルはサブモジュール DataLog ストレージを取得する必要があります。 DataLog Manager をモジュール ツリーに追加する モジュール ツリーまたはモジュール インスタンスのパラメータが変更されている場合は、ジェネレータの実行を実行する必要があります。 （指示： 生成する ）。この目的のために、 ジェネレーターの構成 をアクティブ化する必要があります。 " }, 
{ "title" : "モジュール: DataLog Manager ", 
"url" : "ac_dlm_datalogmanager_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ データログマネージャー \/ モジュール: DataLog Manager ", 
"snippet" : "DataLog Manager の データログマネージャー 変数のデータログを管理します。これは、最上位のオブジェクトの下のモジュール ツリーに追加できます。これは、 トップレベルインスタンスの追加 コマンドとその選択 データログマネージャー モジュール。アプリケーションごとに追加できる DataLog Manager は 1 つだけです。 ダイアログ：HMI DataLog Manager は、視覚化テンプレート ( VISU_DataLogManager ) ビジュアライゼーションに追加できます。詳細については、以下を参照してください。 HMIオンライン モードでは、このページには変数の読...", 
"body" : "DataLog Manager の データログマネージャー 変数のデータログを管理します。これは、最上位のオブジェクトの下のモジュール ツリーに追加できます。これは、 トップレベルインスタンスの追加 コマンドとその選択 データログマネージャー モジュール。アプリケーションごとに追加できる DataLog Manager は 1 つだけです。 ダイアログ：HMI DataLog Manager は、視覚化テンプレート ( VISU_DataLogManager ) ビジュアライゼーションに追加できます。詳細については、以下を参照してください。 HMIオンライン モードでは、このページには変数の読み取りと書き込みに関する統計情報が表示されます。 " }, 
{ "title" : "ダイアログ: データロギング ", 
"url" : "ac_dlm_datalogmanager_module.html#UUID-5158e4eb-39c1-2002-c9f6-d4d4a1d20765_f45d0fbcc9eecefdc0a8646307e5e8bf_id_2bd57d34d6d13475c0a8640e0192d4cf", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ データログマネージャー \/ モジュール: DataLog Manager \/ ダイアログ: データロギング ", 
"snippet" : "このダイアログでは、1 つ以上のグループをストレージから除外できます。デフォルトでは、 データログマネージャー グループが作成されます。 追加 ストレージから除外されるグループの追加と削除。 取り除く...", 
"body" : "このダイアログでは、1 つ以上のグループをストレージから除外できます。デフォルトでは、 データログマネージャー グループが作成されます。 追加 ストレージから除外されるグループの追加と削除。 取り除く " }, 
{ "title" : "モジュール: DataLog チャネル ", 
"url" : "ac_dlm_channel_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ データログマネージャー \/ モジュール: DataLog チャネル ", 
"snippet" : "データログチャネル 1つのモジュールで データログチャネル 変数を格納するためのグループが定義されます。彼はそれ以下にできる データログマネージャー ノードを追加することができます。これはコマンドを通じて行われます サブモジュールインスタンスの追加 そしてモジュールの選択 データログチャネル 。最大 64 個の DataLog チャネルを挿入できます。 対話：HMI、情報 これらのダイアログの詳細な説明は、次の場所にあります。 HMI そして 情報 。...", 
"body" : "データログチャネル 1つのモジュールで データログチャネル 変数を格納するためのグループが定義されます。彼はそれ以下にできる データログマネージャー ノードを追加することができます。これはコマンドを通じて行われます サブモジュールインスタンスの追加 そしてモジュールの選択 データログチャネル 。最大 64 個の DataLog チャネルを挿入できます。 対話：HMI、情報 これらのダイアログの詳細な説明は、次の場所にあります。 HMI そして 情報 。 " }, 
{ "title" : "ダイアログ: データロギング ", 
"url" : "ac_dlm_channel_module.html#UUID-e506780f-95c5-ee2b-f5d3-9586237393e3_a5d87b34c9f11a67c0a8646314ce243b_id_1c75f716cd06b00bc0a865200055fd43", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ データログマネージャー \/ モジュール: DataLog チャネル \/ ダイアログ: データロギング ", 
"snippet" : "このダイアログでは、このチャネルによって管理される 1 つ以上のグループが定義されます。デフォルトでは、チャネルモジュールのインスタンス名がリストに表示されます。 このチャネルを通じてログに記録されたグループ 新しい グループの定義 エントリが含まれています 追加 リストに追加されました。 インスタンスパスを圧縮する : エントリの保存は、完全なインスタンス パスではなく、メモリを節約するためにこの文字列のハッシュ値を使用して行われます。ハッシュとインスタンス パス間のマッピングは別のファイルに保存されます。 取り除く 選択したグループをリストから削除します ログに記録された変数 グループに関...", 
"body" : "このダイアログでは、このチャネルによって管理される 1 つ以上のグループが定義されます。デフォルトでは、チャネルモジュールのインスタンス名がリストに表示されます。 このチャネルを通じてログに記録されたグループ 新しい グループの定義 エントリが含まれています 追加 リストに追加されました。 インスタンスパスを圧縮する : エントリの保存は、完全なインスタンス パスではなく、メモリを節約するためにこの文字列のハッシュ値を使用して行われます。ハッシュとインスタンス パス間のマッピングは別のファイルに保存されます。 取り除く 選択したグループをリストから削除します ログに記録された変数 グループに関連付けられた変数のリスト これらの変数には次の属性があります {attribute 'ac_datalog' := '<group name>'} 。 更新するには ログに記録された変数のリストを更新します 注: リストは、DataLog ジェネレーターがアクティブ化されている場合にのみ更新できます。 変数には属性経由でアクセスできます。 ac_datalog グループに割り当てられます。属性 ac_datalo g_hysteresis 変数が記録される前に超える必要があるヒステリシスを定義します。 例 VAR\n {attribute 'ac_datalog' := 'DataLogChannel'}\n {attribute 'ac_datalog_hysteresis' := '0.745'}\n rLogVar : REAL;\nEND_VAR " }, 
{ "title" : "ダイアログ: パラメータ ", 
"url" : "ac_dlm_channel_module.html#UUID-e506780f-95c5-ee2b-f5d3-9586237393e3_a5d87b34c9f11a67c0a8646314ce243b_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ データログマネージャー \/ モジュール: DataLog チャネル \/ ダイアログ: パラメータ ", 
"snippet" : "DataLog 変数を保存するためのパラメーターは、このダイアログで設定します。 活性化 FALSE : このチャネルからはエントリは作成されません。 最初のサイクルで保存する TRUE : 最初のサイクルで、このチャネルの変数ごとにエントリが作成されます。 循環ストレージ データ・タイプ TIME : このチャネルのすべての変数の値は定期的に保存されます。値 T#0s ロギングを無効にします。...", 
"body" : "DataLog 変数を保存するためのパラメーターは、このダイアログで設定します。 活性化 FALSE : このチャネルからはエントリは作成されません。 最初のサイクルで保存する TRUE : 最初のサイクルで、このチャネルの変数ごとにエントリが作成されます。 循環ストレージ データ・タイプ TIME : このチャネルのすべての変数の値は定期的に保存されます。値 T#0s ロギングを無効にします。 " }, 
{ "title" : "モジュール: DataLog Storage CSV ", 
"url" : "ac_dlm_storage_csv_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ データログマネージャー \/ モジュール: DataLog Storage CSV ", 
"snippet" : "DataLog Storage CSV サブモジュール DataLog_Storage_CSV のストレージフォーマットを定義します。 データログチャネル CSV ファイルとして。DataLog チャネルノードの下に追加できます これはコマンドで行います サブモジュールインスタンスを追加します。 とモジュールの選択。 DataLogStorage_CSV 。 ダイアログ:情報 これらのダイアログの詳細については、のヘルプページを参照してください。 情報 。...", 
"body" : "DataLog Storage CSV サブモジュール DataLog_Storage_CSV のストレージフォーマットを定義します。 データログチャネル CSV ファイルとして。DataLog チャネルノードの下に追加できます これはコマンドで行います サブモジュールインスタンスを追加します。 とモジュールの選択。 DataLogStorage_CSV 。 ダイアログ:情報 これらのダイアログの詳細については、のヘルプページを参照してください。 情報 。 " }, 
{ "title" : "ダイアログ:パラメータ ", 
"url" : "ac_dlm_storage_csv_module.html#UUID-77b82c47-16c6-5f2f-5d4f-34b67bccf3d3_d1edd6c9f1f1a7c0a864637755e4ae_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ データログマネージャー \/ モジュール: DataLog Storage CSV \/ ダイアログ:パラメータ ", 
"snippet" : "ストレージ名 ストレージファイルの名前 デフォルトでは、プレースホルダー %CHANNEL_NAME% が定義されています。このプレースホルダーは、上位の DataLog チャンネルのインスタンス名に置き換えられます。デフォルトでは、すべてのストレージファイルは同じディレクトリに保存されるため、ストレージファイル名は一意である必要があります オプションでプレースホルダー %DATE% 保存日に追加できます。解像度はパラメーターで定義されます。 %DATE% を置き換えるためのフォーマット文字列 (下記参照)。 例: 名前仕様付き '%CHANNEL_NAME%_AT_%DATE%' 、次のファ...", 
"body" : "ストレージ名 ストレージファイルの名前 デフォルトでは、プレースホルダー %CHANNEL_NAME% が定義されています。このプレースホルダーは、上位の DataLog チャンネルのインスタンス名に置き換えられます。デフォルトでは、すべてのストレージファイルは同じディレクトリに保存されるため、ストレージファイル名は一意である必要があります オプションでプレースホルダー %DATE% 保存日に追加できます。解像度はパラメーターで定義されます。 %DATE% を置き換えるためのフォーマット文字列 (下記参照)。 例: 名前仕様付き '%CHANNEL_NAME%_AT_%DATE%' 、次のファイル名は次のようになります。 DataLogChannel_1 チャネル: Application_DataLogChannel_1_AT_20191211_02-10-30.csv セパレーター : 変数名と値の間の区切り文字の ASCII 値。 例: ',' バッファサイズ : エントリを一時的に保存するための内部バッファのサイズ。 例: 2000 バッファフィルレベル パーセンテージ単位の値。 バッファがこの値までいっぱいになると、バッファの内容が CSV ファイルに書き込まれます。指定する 0 バッファリングを無効にします。 ファイル内のエントリの形式は次のとおりです (と | セパレータとして): <TimeStamp>|<InstancePath\/Hash>|<Value>[|<TypeClass>] ストレージがハッシュパスで実行される場合、データ型はすべてのエントリと共に保存されるのではなく、代入ハッシュ ↔ インスタンスパスが格納されている別のファイルに一度だけ保存されます。 このファイルのエントリの形式は次のとおりです。 <InstancePath>|<TypeClass>|<Hash> オンラインで変更した場合、ファイルは削除されません。新しいエントリが追加されます。ハッシュファイルでは、オンラインでの変更にはタイムスタンプが付きます。したがって、オンライン変更の前にエントリにハッシュ ↔ インスタンスパスを割り当てることは引き続き可能です ダウンロード後の初期化中 (オンラインでの変更なし)、データファイルとハッシュファイルは削除されます。 文字を囲む 囲み文字を追加 TRUE : 文字列エントリは周囲と一緒に保存されます。 例:変数値: File1 、ファイルエントリ: -File1- 。 FALSE : 文字列エントリは文字を囲まずに保存されます。 文字を囲む 囲むのに使われる文字。 例: '-' %DATE% を置き換えるためのフォーマット文字列 の置き換えに使用した日付形式 %DATE% これはパラメータで指定できます。 ストレージ名 (上記参照)。 例: 'yyyyMMdd' 、 'yyyyMMdd_hh-mm-ss' LineEnding ファイル内の行の終わりを示す文字 " }, 
{ "title" : "モジュール:DataLog Storage SQLite ", 
"url" : "ac_dlm_storage_sqlite_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ データログマネージャー \/ モジュール:DataLog Storage SQLite ", 
"snippet" : "DataLog Storage SQLite サブモジュール DataLog ストレージ SQLite の保存形式を定義します データログチャネル SQ Lite データベースの場合。 DataLog Channel ノードの下に追加できます。これはコマンドを通じて行われます サブモジュールインスタンスの追加 そしてモジュールの選択 DataLogStorage_SQLite 。 対話: 情報 このダイアログの詳細については、次のサイトを参照してください。 情報 。...", 
"body" : "DataLog Storage SQLite サブモジュール DataLog ストレージ SQLite の保存形式を定義します データログチャネル SQ Lite データベースの場合。 DataLog Channel ノードの下に追加できます。これはコマンドを通じて行われます サブモジュールインスタンスの追加 そしてモジュールの選択 DataLogStorage_SQLite 。 対話: 情報 このダイアログの詳細については、次のサイトを参照してください。 情報 。 " }, 
{ "title" : "ダイアログ: パラメータ ", 
"url" : "ac_dlm_storage_sqlite_module.html#UUID-63e71af3-388f-498c-6553-5ab20ff603a1_accbd5f8d8b6d029c0a86463569e125f_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ データログマネージャー \/ モジュール:DataLog Storage SQLite \/ ダイアログ: パラメータ ", 
"snippet" : "ストレージ名 : アーカイブファイル名 デフォルトはプレースホルダーです %CHANNEL_NAME% 定義されています。このプレースホルダーは、親 DataLog チャネルのインスタンス名に置き換えられます。すべてのアーカイブ ファイルは同じディレクトリに保存されるため、アーカイブ名は一意である必要があります。 アプリケーションのこのモジュールのすべてのインスタンスはファイルを共有します。このファイルは、最初はメモリ モジュールの 1 つによって作成されます。ファイル名は常に <ApplicationName>_DataLog.sqlite 。 最大エントリ数 : このモジュール インスタン...", 
"body" : "ストレージ名 : アーカイブファイル名 デフォルトはプレースホルダーです %CHANNEL_NAME% 定義されています。このプレースホルダーは、親 DataLog チャネルのインスタンス名に置き換えられます。すべてのアーカイブ ファイルは同じディレクトリに保存されるため、アーカイブ名は一意である必要があります。 アプリケーションのこのモジュールのすべてのインスタンスはファイルを共有します。このファイルは、最初はメモリ モジュールの 1 つによって作成されます。ファイル名は常に <ApplicationName>_DataLog.sqlite 。 最大エントリ数 : このモジュール インスタンスのデータベースのエントリの最大数 価値 0 機能を無効にします。この数を超えると、テーブルはリング バッファのように動作し、最初のエントリが上書きされます。 " }, 
{ "title" : "ロギング変数の定義 ", 
"url" : "ac_dlm_definition_logging_variables.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ データログマネージャー \/ ロギング変数の定義 ", 
"snippet" : "変数は属性を介して定義されます。 データロギング マークされた。 ac_datalog [:= Gruppenname] : この属性は、変数をログ グループに割り当てます。この変数が構造化変数の場合、ログに記録でき、除外されないすべてのメンバーがログに記録されます。グループ名が設定されていない場合は、構造化変数のインスタンスごとに個別にこれを行う必要があります。 ac_datalog_set_default_group : 明示的なグループに割り当てられていない、構造化タイプのインスタンスのすべてのメンバーのグループを設定します。 ac_datalog_exclude : この属性は、構造化...", 
"body" : "変数は属性を介して定義されます。 データロギング マークされた。 ac_datalog [:= Gruppenname] : この属性は、変数をログ グループに割り当てます。この変数が構造化変数の場合、ログに記録でき、除外されないすべてのメンバーがログに記録されます。グループ名が設定されていない場合は、構造化変数のインスタンスごとに個別にこれを行う必要があります。 ac_datalog_set_default_group : 明示的なグループに割り当てられていない、構造化タイプのインスタンスのすべてのメンバーのグループを設定します。 ac_datalog_exclude : この属性は、構造化データ型の変数をデータ ログから除外します。 ac_datalog_union_representant : この属性は、データ ログに使用する UNION 内の代表を定義します。 ac_datalog_hysteresis := ‘Wert‘ : この属性は、変数をログに記録するために超える必要があるヒステリシスを設定します。この属性は、数値データ型に対してのみ考慮されます。数値以外のデータ型で使用すると、警告が発行され、値は無視されます。 詳しい説明とプログラミング例は、属性の説明にあります。 永続化マネージャー 。 " }, 
{ "title" : "デバイス診断ジェネレーター ", 
"url" : "ac_device_diagnose_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ デバイス診断ジェネレーター ", 
"snippet" : "デバイス診断モジュールは、ライブラリにある Application Composer の標準コンポーネントです。 AC_DeviceDiagnosis 含まれています。このモジュールはトップレベルのモジュールであり、次のコマンドを使用してアクセスできます。 最上位インスタンスを追加する モジュールツリーに追加されます。 モジュールツリー内のデバイス診断モジュール デバイス診断モジュールの助けを借りて、既存のデバイス構成に基づいて視覚化イメージが作成され、PLC と接続されたフィールドバス デバイスがツリー構造の形式で表示されます。個々のコンポーネントのステータスがこのツリー構造で表示されます。...", 
"body" : "デバイス診断モジュールは、ライブラリにある Application Composer の標準コンポーネントです。 AC_DeviceDiagnosis 含まれています。このモジュールはトップレベルのモジュールであり、次のコマンドを使用してアクセスできます。 最上位インスタンスを追加する モジュールツリーに追加されます。 モジュールツリー内のデバイス診断モジュール デバイス診断モジュールの助けを借りて、既存のデバイス構成に基づいて視覚化イメージが作成され、PLC と接続されたフィールドバス デバイスがツリー構造の形式で表示されます。個々のコンポーネントのステータスがこのツリー構造で表示されます。必要に応じて、詳細情報を呼び出したり、各コンポーネントの動作モードを変更したりすることができます。 デバイス診断用に生成された視覚化画像 オンライン操作でのデバイス診断 オンライン操作時は、デバイス名、ステータス、エラーコードが表示されます。 デバイスのステータスは色で表示されます。 緑: デバイスは「実行中」ステータスです 赤: デバイスは「実行中」ステータスではありません ステータス変更ダイアログ デバイスをクリックすると、デバイスが停止しているウィンドウが開きます ( 停止 )、リセット( リセット ) そして始めました ( 始める） できる。初めてダイアログを開くと、すべての機能が表示されます。ハードウェアがサポートしていない機能は、初めて使用するときは非表示になります。 " }, 
{ "title" : "要件 ", 
"url" : "ac_device_diagnose_overview.html#UUID-fd01086a-c692-d615-c1cf-d5963632aa4b_ac778b834d585cc0a8640e01a520c3_id_be299b7583c984f0c0a86520016ce88a", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ デバイス診断ジェネレーター \/ 要件 ", 
"snippet" : "表示される診断の詳細は、デバイスで作成された CAA デバイス診断 FB (デバイス FB) から取得されます。これらのブロックを作成するには、PLC 設定でオプションを設定する必要があります デバイスの診断を有効にする 悩ませる。これらの FB は、(上記の) 概要に表示される通常のステータス情報を提供する一方で、追加の表示に表示される詳細情報も提供します。生成時のオプションです デバイスの診断を有効にする まだ設定されていない場合、生成の実行は中止され、次の世代の実行で目的のビジュアライゼーションが生成されるようにオプションが自動的に設定されます。 この視覚化イメージを生成するには、デバイ...", 
"body" : "表示される診断の詳細は、デバイスで作成された CAA デバイス診断 FB (デバイス FB) から取得されます。これらのブロックを作成するには、PLC 設定でオプションを設定する必要があります デバイスの診断を有効にする 悩ませる。これらの FB は、(上記の) 概要に表示される通常のステータス情報を提供する一方で、追加の表示に表示される詳細情報も提供します。生成時のオプションです デバイスの診断を有効にする まだ設定されていない場合、生成の実行は中止され、次の世代の実行で目的のビジュアライゼーションが生成されるようにオプションが自動的に設定されます。 この視覚化イメージを生成するには、デバイス診断ジェネレーターが 発電機の構成 活性化される。 " }, 
{ "title" : "コマンド ", 
"url" : "core_applicationcomposer_composer_home.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド ", 
"snippet" : "コマンドカテゴリのコマンド 作曲 それでいいでしょう CODESYS Application Composer 提供された。 これらのコマンドは主に Composer オブジェクトを作成するために使用されます。 モジュールツリー をクリックして追加または変更します。 I\/O 構成に変数を割り当てたり、変数を作成したりするための関数もあります。 CODESYS -利用可能なアプリケーション。コマンドを使用できるかどうかは、モジュール ツリーで選択したオブジェクトによって異なります。現在の位置で許可されているコマンドのみを選択できます。...", 
"body" : "コマンドカテゴリのコマンド 作曲 それでいいでしょう CODESYS Application Composer 提供された。 これらのコマンドは主に Composer オブジェクトを作成するために使用されます。 モジュールツリー をクリックして追加または変更します。 I\/O 構成に変数を割り当てたり、変数を作成したりするための関数もあります。 CODESYS -利用可能なアプリケーション。コマンドを使用できるかどうかは、モジュール ツリーで選択したオブジェクトによって異なります。現在の位置で許可されているコマンドのみを選択できます。 " }, 
{ "title" : "Application Composer 固有のビュー ", 
"url" : "ac_dedicated_view.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ Application Composer 固有のビュー ", 
"snippet" : "Application Composer は、完全なアプリケーションを作成して開始するための非常に簡単な方法を提供します。この簡単な操作に基づいて、 CODESYS ユーザーインターフェイスの縮小表示。 このビューは、「Application Composer 固有」プロファイルを選択するか、関連するコマンドを使用して作成されます。 CODESYS ・スタートメニューが起動しました。その後、縮小されたビュー CODESYS 表示されます。これにより、アプリケーションを作成するために絶対に必要なウィンドウとコマンドへのアクセスのみが提供されます。 CODESYS Application Comp...", 
"body" : "Application Composer は、完全なアプリケーションを作成して開始するための非常に簡単な方法を提供します。この簡単な操作に基づいて、 CODESYS ユーザーインターフェイスの縮小表示。 このビューは、「Application Composer 固有」プロファイルを選択するか、関連するコマンドを使用して作成されます。 CODESYS ・スタートメニューが起動しました。その後、縮小されたビュー CODESYS 表示されます。これにより、アプリケーションを作成するために絶対に必要なウィンドウとコマンドへのアクセスのみが提供されます。 CODESYS Application Composer 提供します。 Application Composer 固有のビュー このビューには、モジュール ツリー、デバイス ツリー、およびメッセージ出力ウィンドウと、オンライン コマンドのログイン\/ログアウト\/実行および停止、およびコンポーザー コマンドのみが表示されます。次の 2 つのコマンドは、特に簡易ビューで使用できます。 作成、翻訳、ログイン : コードの生成と変換、デバイスへの接続、デバイス上でのアプリケーションの起動 モジュールライブラリをプロジェクトに追加する : POU プール ライブラリ マネージャーにライブラリを追加します。これは通常、Application Composer 固有のビューでは使用できません。 ライブラリにモジュールが含まれている場合は、モジュール ツリー内の適切な場所にモジュールを追加できます。 " }, 
{ "title" : "モジュールツリー ", 
"url" : "ac_module_tree.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ モジュールツリー ", 
"snippet" : "デバイス ツリーと POU ツリーに加えて、Application Composer はモジュール ツリーを提供します。ツリーは、事前に作成されたモジュールを使用してアプリケーションを作成または変更するために使用されます。 Application Composer コマンドを使用すると、モジュール ツリーに対してモジュールを追加、変更、または削除できます。ツリー構造は展開または最小化できます。 モジュールツリーの例 選択したオブジェクトに応じて、適切なモジュールをモジュール ツリーに追加できます。これは次の助けを借りて行うことができます コマンド メニュー項目「Composer」またはコンテキ...", 
"body" : "デバイス ツリーと POU ツリーに加えて、Application Composer はモジュール ツリーを提供します。ツリーは、事前に作成されたモジュールを使用してアプリケーションを作成または変更するために使用されます。 Application Composer コマンドを使用すると、モジュール ツリーに対してモジュールを追加、変更、または削除できます。ツリー構造は展開または最小化できます。 モジュールツリーの例 選択したオブジェクトに応じて、適切なモジュールをモジュール ツリーに追加できます。これは次の助けを借りて行うことができます コマンド メニュー項目「Composer」またはコンテキスト メニューで実行できます。 要素のアイコンはモジュール宣言で定義できます。 " }, 
{ "title" : "モジュールツリーの要素 ", 
"url" : "ac_module_tree.html#UUID-e2887a12-08dd-106a-0027-83341681c6bc_e38a4aaee73c0a8640e01c263f8_id_a88610fbb413e565c0a8640e00f61f5a", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ モジュールツリー \/ モジュールツリーの要素 ", 
"snippet" : "(1): アプリケーションとタスクの設定を含むトップレベルのモジュール (2): サブモジュール (3): サブモジュールを参照するインスタンス参照。インスタンス参照には、独自のパラメータや I\/O がありません。 (4): Application Composer を使用せずに作成することもできる拡張機能。これを使用すると、アプリケーションをマシンに適合させることができます。 (5): スロット (単一または複数)。これは必須またはオプションです。...", 
"body" : "(1): アプリケーションとタスクの設定を含むトップレベルのモジュール (2): サブモジュール (3): サブモジュールを参照するインスタンス参照。インスタンス参照には、独自のパラメータや I\/O がありません。 (4): Application Composer を使用せずに作成することもできる拡張機能。これを使用すると、アプリケーションをマシンに適合させることができます。 (5): スロット (単一または複数)。これは必須またはオプションです。 " }, 
{ "title" : "ツリー構造を表示する ", 
"url" : "ac_module_tree.html#UUID-e2887a12-08dd-106a-0027-83341681c6bc_e38a4aaee73c0a8640e01c263f8_id_8a0710cab44f1a9bc0a8640e00ddf9a1", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ モジュールツリー \/ ツリー構造を表示する ", 
"snippet" : "展開されたモジュール インスタンスの下に表示される子ノードは、次のルールによって決定されます。これにより、占有されているスロットと占有されていないすべてのスロットの順序は、常にモジュール内の宣言の順序に対応します。 この時点でモジュール インスタンスが参照されるだけの場合、そのインスタンスには子はありません。 明示的に非表示になっているオプションのスロットを除き、すべての未使用のスロットが表示されます。スロットの場合、ロール名とタイプが表示されます。 上位桁が 1 の占有スロットは表示されません。接続されたサブモジュール インスタンスがスロットを視覚的に置き換えます。 スロットが以前に表示され...", 
"body" : "展開されたモジュール インスタンスの下に表示される子ノードは、次のルールによって決定されます。これにより、占有されているスロットと占有されていないすべてのスロットの順序は、常にモジュール内の宣言の順序に対応します。 この時点でモジュール インスタンスが参照されるだけの場合、そのインスタンスには子はありません。 明示的に非表示になっているオプションのスロットを除き、すべての未使用のスロットが表示されます。スロットの場合、ロール名とタイプが表示されます。 上位桁が 1 の占有スロットは表示されません。接続されたサブモジュール インスタンスがスロットを視覚的に置き換えます。 スロットが以前に表示されていた場所に、オプションおよび必須のサブモジュール インスタンスが表示されます。ロール名は、モジュール インスタンス名の後の角括弧内に表示されます。 複数のスロットのサブモジュール インスタンスは、それぞれのスロットの下に表示されます。ロール名は親ノードから明らかであるため、ここでは表示されません。 スロットの次のプロパティが追加のアイコンとともに表示されます。 オプションのスロット 必須スロット 複数のスロット サブモジュールインスタンスへの参照 モジュール インスタンスが削除されると、このモジュールへのすべての参照がエラー アイコンとともに表示されます。 モジュール インスタンスのタイプが変更されると、間違ったタイプを持つそのモジュールへのすべての参照がエラー アイコンとともに表示されます。 モジュール ツリー内の位置に応じて、コマンドは次のことができます。 切り取る \/ コピー \/ 入れる コンテキストメニューから。モジュールツリー上の要素は「ドラッグ＆ドロップ」で移動できます。「ドラッグ＆ドロップ」実行中にボタンを押すと、 Ctrl を押すと要素がコピーされます。 モジュール ツリーの要素は、他のオブジェクトと同様に使用できます。 CODESYS エクスポートおよびインポートできます。 " }, 
{ "title" : "モジュールダイアログ ", 
"url" : "ac_module_dialog.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ モジュールダイアログ ", 
"snippet" : "コマンドを使用して トップレベルのインスタンスを追加する 、 サブモジュールインスタンスの追加 、 参照インスタンス 、 そして アップデートモジュール をクリックすると、非モーダル ダイアログが開きます。 モジュール ツリー内の位置に応じて、互換性のあるすべてのモジュールが表示されます。モジュールをダブルクリックするか、 ボタンを使用します。 モジュールの追加 それぞれ サブモジュールインスタンスの追加 選択したモジュールがモジュール ツリーにコピーされます。 ボタン モジュールの追加 （ または リファレンスモジュール ) は、互換性のあるモジュールが選択されており、モジュール ツリーで選...", 
"body" : "コマンドを使用して トップレベルのインスタンスを追加する 、 サブモジュールインスタンスの追加 、 参照インスタンス 、 そして アップデートモジュール をクリックすると、非モーダル ダイアログが開きます。 モジュール ツリー内の位置に応じて、互換性のあるすべてのモジュールが表示されます。モジュールをダブルクリックするか、 ボタンを使用します。 モジュールの追加 それぞれ サブモジュールインスタンスの追加 選択したモジュールがモジュール ツリーにコピーされます。 ボタン モジュールの追加 （ または リファレンスモジュール ) は、互換性のあるモジュールが選択されており、モジュール ツリーで選択されたスロットがいっぱいではない場合にのみ有効になります。さらに、有効な名前 (有効な IEC 識別子を含む) を入力する必要があります。 オブジェクトの名前は、新しいモジュール インスタンスに対してのみ定義できます。のダイアログで、 アップデートモジュール コマンドの場合、名前は変更できません。 互換性のあるインスタンスのみを表示する : このオプションを有効にすると、表示されるインスタンスがフィルタリングされ、互換性のあるインスタンスのみが表示されます。非アクティブ化すると、すべてのインスタンスが表示され、互換性のあるインスタンスが太字で強調表示されます。 応用 : このアプリケーションの下にトップレベルのモジュール インスタンスが生成されます。クリック 既存のアプリケーションを選択します。 モジュールインスタンスを追加するダイアログ ダイアログは非モーダルです。これにより、ダイアログを閉じずにツリー内の他のオブジェクトを選択できるようになります。ダイアログにリストされている要素と実行可能なアクションは、自動的に調整されます。このダイアログの動作は、 デバイスを追加 ダイアログ。 " }, 
{ "title" : "コマンド: 生成 ", 
"url" : "ac_generate.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: 生成 ", 
"snippet" : "生成する シンボル： このコマンド (カテゴリ「Composer」) は、ビルド プロセスを開始し、 CODESYS モジュールツリーからアプリケーションを選択し、 発電機の構成 。 メッセージとエラーはメッセージ ビューに表示されます。 標準ジェネレーターによって作成されたすべてのオブジェクト (タスク オブジェクトとアプリケーションを除く) は、それぞれのアプリケーションのサブフォルダーに保存されます。 POU プールの名前 AC_Std そして AC_FBs 。同じ名前のフォルダーがすでに存在する場合は、サフィックスを追加して一意の名前が作成されます _0 。 生成されたファンクションブ...", 
"body" : "生成する シンボル： このコマンド (カテゴリ「Composer」) は、ビルド プロセスを開始し、 CODESYS モジュールツリーからアプリケーションを選択し、 発電機の構成 。 メッセージとエラーはメッセージ ビューに表示されます。 標準ジェネレーターによって作成されたすべてのオブジェクト (タスク オブジェクトとアプリケーションを除く) は、それぞれのアプリケーションのサブフォルダーに保存されます。 POU プールの名前 AC_Std そして AC_FBs 。同じ名前のフォルダーがすでに存在する場合は、サフィックスを追加して一意の名前が作成されます _0 。 生成されたファンクションブロック によって作成されたすべてのオブジェクト 生成する コマンドには青いオーバーレイ アイコンが付いています。ユーザーがこれらのオブジェクトの 1 つを削除、移動、または変更しようとすると、この操作によりコンパイルの問題が発生する可能性があることを示すダイアログが開きます。ユーザーが続行すると、オーバーレイ アイコンの色が赤に変わります (機能ブロックを参照) AC_PRG_RMP (PRG) 上のスクリーンショットで）。 Application Composer を併用する場合 CODESYS SVN : Composer で生成されたすべてのオブジェクトには、 Ignore on Commit SVNの場合。さらに、Build コマンドの実行中の SVN ロックを回避するために、SVN はオフライン モードに切り替えられます。 通信インフラの整備 定義: 次の説明では、次の条件が満たされた場合に、アプリケーション A1 がアプリケーション A2 に送信します (または A2 が A1 から受信します)。 アプリケーション A1 に割り当てられたモジュール インスタンスは、アプリケーション A2 に割り当てられたモジュール インスタンスを参照します。また、その逆も同様です。 A1 に割り当てられたモジュール インスタンスの出力は、直接モジュール I\/O 接続を使用して、A2 に割り当てられたモジュール インスタンスに接続されます。 以下に示すすべてのオブジェクトがフォルダー内に作成されます AC_RMP ジェネレーターによって作成されたアプリケーションごとに。 通信タスクが作成されます。 (サイクル時間と優先度はジェネレーター構成の設定に応じます)。このタスクでは、プロキシ インスタンスが呼び出され、ミラーリングされたモジュールのプロキシ FB 変数がそれぞれ読み取られます。書かれた。 現在のアプリケーションに送信するアプリケーションごとに、(送信) GVL が作成され、ネットワーク設定が定義されます。 (プロトコル「UDP」、サイクリック送信、チェックサム、設定によるサイクルタイム、通信タスク)。 「リスト識別子」は 1 から 2^15-1 までの整数値である必要があり、生成の開始時にランダムに決定され、GVL を送信するたびに 1 ずつ増加します。この値は少なくとも 128 であり、有効範囲内です。アプリケーション間にモジュール参照がある場合、次の型の変数 RMPExchangeData GVL 内に作成されます。変数の名前には、ソース アプリケーションとターゲット アプリケーションの名前が含まれます。モジュール インスタンスがプロキシ定義でミラーリングされる変数を定義している場合 ( MirrorVar ) であり、他のモジュール インスタンスから参照されている場合、この MirrorVar ごとに、参照されたモジュール インスタンスの (送信) GVL に変数が作成されます。その名前には、モジュール インスタンスのインスタンス パスと、対応する「MirrorVar」定義の TargetID が含まれます。 現在のアプリケーションが送信するアプリケーション A2 ごとに、(受信) NVL が作成され、A2 の対応する送信 GVL および通信タスクに接続されます。 タイプの関数ブロック RMPService でインスタンス化されます GVL AC_RMP 宣言内で初期化されます（属性付き） init_on_onlchange ）。型の 2 つの配列 RMPConnection 作成されたタイプの変数を参照するものが作成されます。 RMPExchangeData GVL と NVL 内。 プログラム AC_PRG_RMP タイプの関数ブロックを呼び出すものが作成されます。 RMPService 。このプログラムは通信タスクに追加されます。さらに、ミラーリングされた変数 (「MirrorVars」) の値が設定され、 AC_PRG_RMP プログラム。これは、プロキシ「MirrorVars」が (受信) GVL の対応する変数に割り当てられることを意味します。そうして Main プロキシ インスタンスのメソッドが呼び出され、最後に「MirrorVars」モジュールの (送信側) GVL の対応する変数が呼び出されます。これは、モジュール インスタンスのプロキシへの送信方向に従って発生します。 " }, 
{ "title" : "標準ジェネレーターによるファンクションブロックインスタンスの作成 ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_65e9c9d2b9a5b65fc0a8640e0003897d", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: 生成 \/ 標準ジェネレーターによるファンクションブロックインスタンスの作成 ", 
"snippet" : "モジュール インスタンスごとに、関数ブロックが (フォルダー内に) 作成されます。 AC_FBs ）。この機能ブロックはモジュール機能ブロックから派生します。 関数ブロックには、次の (入力) 変数が含まれています。 サブモジュールインスタンス 構成可能なサイズの配列 ダイレクト I\/O 接続のバッファ変数 マルチスロットの配列とインスタンス参照 それぞれの配列変数の名前は接頭辞によって作成されます。 AC_ARRAY_ それぞれのポインター変数の変数名が続きます。可変インデックス サイズを持つ配列 (VarArrays) の場合、名前はパラメーターによって上書きできます。 VarArray....", 
"body" : "モジュール インスタンスごとに、関数ブロックが (フォルダー内に) 作成されます。 AC_FBs ）。この機能ブロックはモジュール機能ブロックから派生します。 関数ブロックには、次の (入力) 変数が含まれています。 サブモジュールインスタンス 構成可能なサイズの配列 ダイレクト I\/O 接続のバッファ変数 マルチスロットの配列とインスタンス参照 それぞれの配列変数の名前は接頭辞によって作成されます。 AC_ARRAY_ それぞれのポインター変数の変数名が続きます。可変インデックス サイズを持つ配列 (VarArrays) の場合、名前はパラメーターによって上書きできます。 VarArray.InstName 。 関数ブロックの実装部分には次のコマンドが含まれます。 SUPER^(); これはモジュール関数ブロックの実装部分を呼び出します。 例 モジュールインスタンス ModuleInstanceA タイプです ModuleA および関連する機能ブロック ModuleA_FB 。このインスタンスには、次のタイプのサブモジュール インスタンスがあります。 ModuleB 。 モジュールインスタンス ModuleInstanceA タイプです ModuleA および関連する機能ブロック ModuleA_FB 。このインスタンスには、次のタイプのサブモジュール インスタンスがあります。 ModuleB 。 FUNCTION_BLOCK AC_ModuleInstanceA EXTENDS ModuleA_FB\n\nVAR_INPUT\n Inst_Sub1 : AC_ModuleInstanceB ;\nEND_VAR 関数ブロックの名前は、モジュール インスタンスのパスとプレフィックスから作成されます。 AC_ 。 サブモジュール インスタンスの変数の名前は、それぞれのサブモジュール インスタンスの名前が続くプレフィックスから作成されます。 各関数ブロックは 1 回インスタンス化され、トップレベル モジュールの FB インスタンスは GVL 内で直接インスタンス化され、残りは親インスタンスの対応する関数ブロック内にインスタンス化されます。 別のアプリケーションにある参照されるモジュール インスタンスごとに、プロキシ FB の機能ブロック インスタンスが 1 つだけ、参照するモジュール インスタンスの 1 つの GVL に作成されます。プロキシ インスタンスの名前は次のとおりです。 AC_PROXY_<InstanceName> <InstanceName> は、他のアプリケーションのターゲット インスタンスの名前です。 すべてのモジュール インスタンスには一意のアドレスが割り当てられます。プロキシ FB インスタンスは、リモート アプリケーションのモジュール インスタンスのアドレスによって割り当てられます。 方法 IBaseInstance.Main プロキシ インスタンスの は、通信タスク内で周期的に呼び出されます。 " }, 
{ "title" : "アプリケーションとタスクの呼び出しの作成 ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_c88cdc4bba310f0dc0a8640e0094f683", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: 生成 \/ アプリケーションとタスクの呼び出しの作成 ", 
"snippet" : "存在しないアプリケーションにモジュールが割り当てられている場合、このアプリケーションが作成されます。 存在しない標準タスクの作成 TASK_MODULE_HIGH TASK_MODULE_MEDIUM TASK_MODULE_LOW タスクの優先度とサイクル タイムは、ジェネレーターの設定に従って設定されます。さらに、指定された設定を持つモジュール固有のタスクが作成されます。 トップレベルごとに 1 つのグローバル変数リストを作成します。この GVL では、同じアプリケーションの最上位モジュール インスタンスの下に位置するモジュール インスタンスが作成されます。グローバル変数リストにはモジュー...", 
"body" : "存在しないアプリケーションにモジュールが割り当てられている場合、このアプリケーションが作成されます。 存在しない標準タスクの作成 TASK_MODULE_HIGH TASK_MODULE_MEDIUM TASK_MODULE_LOW タスクの優先度とサイクル タイムは、ジェネレーターの設定に従って設定されます。さらに、指定された設定を持つモジュール固有のタスクが作成されます。 トップレベルごとに 1 つのグローバル変数リストを作成します。この GVL では、同じアプリケーションの最上位モジュール インスタンスの下に位置するモジュール インスタンスが作成されます。グローバル変数リストにはモジュールで定義された名前が付いています。名前が定義されていない場合は、その名前が取得されます。 GVL_MODULE 。 GVL は、選択したアプリケーションの下、またはグローバル POU ツリー内にあります。 次の名前の GVL を 1 つ作成する GVL_ MODULE_TREE アプリケーションごとに。このリストには、モジュール ツリーを管理するための変数が含まれています。 GVL はフォルダー内に作成されます AC_Std 。 ダウンロードおよびオンライン変更時に自動的に呼び出される初期化コードの作成: ツリー構造が作成されます。 パラメータ値が設定されます。 参照とサブモジュールのインスタンスが割り当てられます。 可変サイズの配列は埋められます。 インスタンス参照が設定されます。 ダウンロード時のみ、デフォルト値に設定されていないパラメータが設定されます。オンライン変更では、すべてのパラメータが設定されます。 POU はフォルダー内に作成されます AC_Std 。 定義されたエントリ ポイントごとに、 PROGRAM 最上位モジュールの呼び出しを含む POU (言語 ST) が作成されます。この新しい POU の呼び出しはタスクの下に追加されます。標準タスクの場合、POU 名は次のとおりです。 MODULE_CALL_<TASKNAME>_START MODULE_CALL_<TASKNAME>_END POU はフォルダー内に作成されます AC_Std 。 最上位モジュールの場合、 POU タスク呼び出しのプールはすべてのアプリケーションで作成されます。 " }, 
{ "title" : "I\/O割り当ての作成 ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_bf24656dba310f0fc0a8640e01fdf5a6", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: 生成 \/ I\/O割り当ての作成 ", 
"snippet" : "I\/O 割り当てのタイプに応じて、次のアクションが実行されます。 [I\/Oチャネル]: 対応するデバイスチャネルに、モジュールインスタンスのI\/Oのインスタンス名が追加されます。 [ST 式]: 式の入力への割り当て、または式への出力の割り当ては、同じトップレベル インスタンスの下にあるすべてのモジュール インスタンスに対して行われます。対応する割り当てがある場合、トップレベルのインスタンスごとに、という名前の関数が作成されます。 AC_Io_SetInputs_<instance name> または AC_Io_SetOutputs_<instance name> が作成されます。 入力と出...", 
"body" : "I\/O 割り当てのタイプに応じて、次のアクションが実行されます。 [I\/Oチャネル]: 対応するデバイスチャネルに、モジュールインスタンスのI\/Oのインスタンス名が追加されます。 [ST 式]: 式の入力への割り当て、または式への出力の割り当ては、同じトップレベル インスタンスの下にあるすべてのモジュール インスタンスに対して行われます。対応する割り当てがある場合、トップレベルのインスタンスごとに、という名前の関数が作成されます。 AC_Io_SetInputs_<instance name> または AC_Io_SetOutputs_<instance name> が作成されます。 入力と出力を定義するタスクはフラグによって識別されます。 UPDATE-IOS モジュールの説明にあります。以下、このタスクを「Ｉ／Ｏタスク」と呼ぶ。 入力の関数は、モジュール インスタンスのタスク メソッドが呼び出される前に、I\/O タスクで呼び出されます。 (I\/O タスクが標準タスクの場合、start メソッドの前。) 出力の関数は、モジュール インスタンスのタスク メソッドの後の I\/O タスク内で呼び出されます。 (I\/Oタスクが標準タスクの場合、endメソッド以降) [モジュール I\/O への直接接続、ローカル]: 互換性のある型のバッファ変数が入力のインスタンスのファンクション ブロック内に作成されます。バッファ変数の名前は接頭辞で始まります。 AC_Io_Buffer_ 。 バッファ変数は、アプリケーションの初期化中に、接続された出力の現在の値に初期化されます。ジェネレーターは、このバッファー変数への ST 割り当てと同様に、入力および出力の割り当てを処理します ([ST 式] を参照)。 [モジュール I\/O への直接接続、リモート]: 別のアプリケーションからのモジュール インスタンスの入力に接続されている出力ごとに、互換性のあるタイプのバッファ変数が対応する送信ネットワーク GVL に作成されます。バッファ変数の名前は接頭辞で始まります AC_RemoteIo_Buffer_ 出力のインスタンス パスと変数パスから構築されます。バッファ変数は、出力変数が存在する場合、その初期化式を使用して初期化されます。この初期化式の値がプリコンパイル情報に含まれていない場合 (式では変数、関数、定数の例が使用されているため)、エラーが作成されます。 ジェネレーターは、このバッファー変数への代入と同様に、出力の代入を処理します。他のアプリケーションでの入力割り当ては、受信側 NVL の対応する変数からの割り当てと同様に処理されます ([ST 式] を参照)。 注: ネットワーク変数が更新されるタスクとモジュールの I\/O タスク間の同期はまだ実現されていません。したがって、I\/O タスクが値を読み取るときに値が不完全に書き込まれている可能性があります。 " }, 
{ "title" : "コマンド: ジェネレータ設定 ", 
"url" : "ac_generator_configuration.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: ジェネレータ設定 ", 
"snippet" : "発電機の構成 このコマンド (カテゴリ「Composer」) は、使用可能なすべてのジェネレーターを含むダイアログを開きます。 このダイアログでは、単一のジェネレーターをそれぞれ有効または無効にできます。 「ツール」アイコンをクリックすると、現在選択され有効になっているジェネレーターの特定の設定を含む詳細なダイアログが開きます。...", 
"body" : "発電機の構成 このコマンド (カテゴリ「Composer」) は、使用可能なすべてのジェネレーターを含むダイアログを開きます。 このダイアログでは、単一のジェネレーターをそれぞれ有効または無効にできます。 「ツール」アイコンをクリックすると、現在選択され有効になっているジェネレーターの特定の設定を含む詳細なダイアログが開きます。 " }, 
{ "title" : "デバイスジェネレータ ", 
"url" : "ac_generator_configuration.html#UUID-808f4cf5-ae70-df89-d868-14922e672101", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: ジェネレータ設定 \/ デバイスジェネレータ ", 
"snippet" : "このジェネレーターは、必要なデバイスを生成し、可能であればそれらをモジュール IO に接続しようとします。 Application Composer プラグインの現在のリリースでは、デバイス ジェネレーターで使用できる構成ダイアログはありません。...", 
"body" : "このジェネレーターは、必要なデバイスを生成し、可能であればそれらをモジュール IO に接続しようとします。 Application Composer プラグインの現在のリリースでは、デバイス ジェネレーターで使用できる構成ダイアログはありません。 " }, 
{ "title" : "ソーステンプレートジェネレーター ", 
"url" : "ac_generator_configuration.html#UUID-dcd74dd8-c2bf-daf3-03d2-c4b54ecf55a8", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: ジェネレータ設定 \/ ソーステンプレートジェネレーター ", 
"snippet" : "このジェネレータは、既存の機能ブロックを POU - アプリケーション内のプール。コピーしたブロックはフォルダー内にあります AC_SourceTemplate 提出した。このフォルダーには関数も含まれています AC_SourceTemplateInit 作成した。この関数はコピーしたファンクションブロックを初期化します。一度生成されたファンクション ブロックは編集可能で、新しい生成の実行中に上書きされることはありません。使用されなくなったファンクション ブロックは名前が変更され、サブフォルダーに保存されます。 UnusedSourceTemplate 遅れ。拡張子は次のようになります _un...", 
"body" : "このジェネレータは、既存の機能ブロックを POU - アプリケーション内のプール。コピーしたブロックはフォルダー内にあります AC_SourceTemplate 提出した。このフォルダーには関数も含まれています AC_SourceTemplateInit 作成した。この関数はコピーしたファンクションブロックを初期化します。一度生成されたファンクション ブロックは編集可能で、新しい生成の実行中に上書きされることはありません。使用されなくなったファンクション ブロックは名前が変更され、サブフォルダーに保存されます。 UnusedSourceTemplate 遅れ。拡張子は次のようになります _unused 添付。要件: 標準ジェネレーターがアクティブ化されている必要があります。 " }, 
{ "title" : "デフォルトのジェネレーター ", 
"url" : "ac_generator_configuration.html#UUID-a3c9c7e9-e567-6ffc-3f6c-ae4016d57a70", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: ジェネレータ設定 \/ デフォルトのジェネレーター ", 
"snippet" : "デフォルトのタスク設定 優先度の高いタスク ユーザー定義タスクの優先度と間隔の定義 ユーザー定義タスクは、最上位モジュールのエディターで設定できます (「使用法」を参照)。 中優先度のタスク 優先度の低いタスク 通信設定 RMP通信を有効にする ：RMP通信に必要な要素が作成されます。 タスクの優先度 RMP タスクの優先順位 タスク間隔 RMPタスクのタスク間隔 コンパイラプラグマ GVL コンパイラプラグマの定義 このプラグマのリストは、生成された GVL または汎用モジュールの前に挿入されます。 機能ブロック シンボル構成 シンボル構成を生成する : シンボル設定オブジェクトがアプリケー...", 
"body" : "デフォルトのタスク設定 優先度の高いタスク ユーザー定義タスクの優先度と間隔の定義 ユーザー定義タスクは、最上位モジュールのエディターで設定できます (「使用法」を参照)。 中優先度のタスク 優先度の低いタスク 通信設定 RMP通信を有効にする ：RMP通信に必要な要素が作成されます。 タスクの優先度 RMP タスクの優先順位 タスク間隔 RMPタスクのタスク間隔 コンパイラプラグマ GVL コンパイラプラグマの定義 このプラグマのリストは、生成された GVL または汎用モジュールの前に挿入されます。 機能ブロック シンボル構成 シンボル構成を生成する : シンボル設定オブジェクトがアプリケーションに追加されます。 " }, 
{ "title" : "永続化ジェネレーター ", 
"url" : "ac_generator_configuration.html#UUID-e4484f57-2155-dad9-990f-264462e75e1e", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: ジェネレータ設定 \/ 永続化ジェネレーター ", 
"snippet" : "永続性ジェネレーターは、モジュール ツリーから永続性構成を読み取り、永続性を使用する各アプリケーションの下に永続性構成オブジェクトを作成します。 詳細については、以下も参照してください。 永続化マネージャーPersistence Manager のインスタンスがこのアプリケーションにマップされている場合、アプリケーションは Application Composer の永続化機能のみを使用します。...", 
"body" : "永続性ジェネレーターは、モジュール ツリーから永続性構成を読み取り、永続性を使用する各アプリケーションの下に永続性構成オブジェクトを作成します。 詳細については、以下も参照してください。 永続化マネージャーPersistence Manager のインスタンスがこのアプリケーションにマップされている場合、アプリケーションは Application Composer の永続化機能のみを使用します。 " }, 
{ "title" : "データログジェネレーター ", 
"url" : "ac_generator_configuration.html#UUID-0a4d1c9e-c363-489e-e742-4b6d5c1afaa4", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: ジェネレータ設定 \/ データログジェネレーター ", 
"snippet" : "DataLog Generator は、モジュール ツリーの構成から DataLog 構成オブジェクトを作成します。このオブジェクトは、のインスタンスが配置されるアプリケーションの下に挿入されます。 データログマネージャー マッピングされています。現在のバージョンでは、 CODESYS Application Composer DataLog ジェネレーターの構成は使用できません。...", 
"body" : "DataLog Generator は、モジュール ツリーの構成から DataLog 構成オブジェクトを作成します。このオブジェクトは、のインスタンスが配置されるアプリケーションの下に挿入されます。 データログマネージャー マッピングされています。現在のバージョンでは、 CODESYS Application Composer DataLog ジェネレーターの構成は使用できません。 " }, 
{ "title" : "トレンドジェネレーター ", 
"url" : "ac_generator_configuration.html#UUID-b0155d06-1fc0-2914-55ee-2233ae0d22ee", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: ジェネレータ設定 \/ トレンドジェネレーター ", 
"snippet" : "トレンド ジェネレーターは、モジュールの説明からトレンド定義を読み取り、それらを使用してトレンド構成と関連する視覚化を作成します。これらのビジュアライゼーションは、既存のビジュアライゼーションに埋め込まれます。...", 
"body" : "トレンド ジェネレーターは、モジュールの説明からトレンド定義を読み取り、それらを使用してトレンド構成と関連する視覚化を作成します。これらのビジュアライゼーションは、既存のビジュアライゼーションに埋め込まれます。 " }, 
{ "title" : "アラーム発生器 ", 
"url" : "ac_generator_configuration.html#UUID-62c4fd14-9eaa-46b5-f370-4e36a88614fe", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: ジェネレータ設定 \/ アラーム発生器 ", 
"snippet" : "アラーム ジェネレータは、モジュールの説明からアラーム定義を読み取り、関連するアラーム管理コンポーネントを作成または拡張します。さらに、アラーム テーブルが挿入されたテンプレートからビジュアライゼーションが作成されます。この視覚化は次のように呼ばれます トップレベルの視覚化 視覚化ジェネレーターの残りの視覚化イメージに追加されます。 テンプレート ページの視覚化に使用されるテンプレート。 注: ビジュアライゼーションをテンプレートとして使用するには、次の要件を満たしている必要があります。 名前の入った四角形 Placeholder_AlarmTable 変数 bAckVisible 、 bAc...", 
"body" : "アラーム ジェネレータは、モジュールの説明からアラーム定義を読み取り、関連するアラーム管理コンポーネントを作成または拡張します。さらに、アラーム テーブルが挿入されたテンプレートからビジュアライゼーションが作成されます。この視覚化は次のように呼ばれます トップレベルの視覚化 視覚化ジェネレーターの残りの視覚化イメージに追加されます。 テンプレート ページの視覚化に使用されるテンプレート。 注: ビジュアライゼーションをテンプレートとして使用するには、次の要件を満たしている必要があります。 名前の入った四角形 Placeholder_AlarmTable 変数 bAckVisible 、 bAckSel 、 bHistory 、 bFreezeScrlPos タイプの BOOL アラーム保存テンプレート タイプのオブジェクト AlarmStorageTemplate 、現在のプロジェクトと参照されるライブラリにあります。 選択したテンプレートは、生成されたすべてのアラーム設定に使用されます。 トップレベルのライダーを作成する : 生成されたアラームの視覚化用に最上位のタブが作成されます。 指定した名前がこの最上位タブに表示されます。 " }, 
{ "title" : "デバイス診断ジェネレーター ", 
"url" : "ac_generator_configuration.html#UUID-eacb5fd7-1329-2790-9483-fe45edbe632a", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: ジェネレータ設定 \/ デバイス診断ジェネレーター ", 
"snippet" : "このジェネレーターは、デバイス診断用の視覚化イメージを作成します。設定では、次のことができます 視覚化テンプレート そして視覚化画像のレイアウトを決定することができます。 ダイアログ デバイス診断ジェネレーターの設定 基本的なビジュアライゼーション、PLC、フィールドバス、バス カプラー、端子のテンプレートは、このダイアログで設定されます。それぞれのテンプレート タイプに一致する、プロジェクトで使用可能なすべてのビジュアライゼーションが、テンプレートの選択に使用されるコンボ ボックスに表示されます。 ダイアログの下部では、可視化画像の最小サイズと配置されたデバイス間の距離を設定します。...", 
"body" : "このジェネレーターは、デバイス診断用の視覚化イメージを作成します。設定では、次のことができます 視覚化テンプレート そして視覚化画像のレイアウトを決定することができます。 ダイアログ デバイス診断ジェネレーターの設定 基本的なビジュアライゼーション、PLC、フィールドバス、バス カプラー、端子のテンプレートは、このダイアログで設定されます。それぞれのテンプレート タイプに一致する、プロジェクトで使用可能なすべてのビジュアライゼーションが、テンプレートの選択に使用されるコンボ ボックスに表示されます。 ダイアログの下部では、可視化画像の最小サイズと配置されたデバイス間の距離を設定します。 " }, 
{ "title" : "CFCプログラムジェネレータ ", 
"url" : "ac_generator_configuration.html#UUID-fdaff0f3-814e-b71a-bcac-a2994393c9ed", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: ジェネレータ設定 \/ CFCプログラムジェネレータ ", 
"snippet" : "CFC ジェネレーターは、CFC プログラムを生成するために使用されます。 すべての CFC ピンを常に再生成する : : モジュール インスタンスの FB 呼び出しでは、常にモジュール FB のすべての I\/O を生成する試みが行われます。...", 
"body" : "CFC ジェネレーターは、CFC プログラムを生成するために使用されます。 すべての CFC ピンを常に再生成する : : モジュール インスタンスの FB 呼び出しでは、常にモジュール FB のすべての I\/O を生成する試みが行われます。 " }, 
{ "title" : "視覚化ジェネレーター ", 
"url" : "ac_generator_configuration.html#UUID-a364420f-f798-9fe6-3c1a-b98bc7c07391", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: ジェネレータ設定 \/ 視覚化ジェネレーター ", 
"snippet" : "このジェネレータは im から生成します CODESYS -プロジェクトで利用可能なビジュアライゼーション画像 CODESYS Application Composer 。 最上位の名前 : のシンボル名を入力します。 テンプレート 選択された視覚化テンプレート (「トップレベルテンプレート」)。 テンプレート : 選択リストには、(プロジェクトおよびロードされたライブラリから) 利用可能なすべての互換性のあるビジュアライゼーションが含まれています。もし、あんたが デフォルト 設定すると、ライブラリのデフォルトのテンプレートが使用されます AC_Module 使用済み。このダイアログで構成され...", 
"body" : "このジェネレータは im から生成します CODESYS -プロジェクトで利用可能なビジュアライゼーション画像 CODESYS Application Composer 。 最上位の名前 : のシンボル名を入力します。 テンプレート 選択された視覚化テンプレート (「トップレベルテンプレート」)。 テンプレート : 選択リストには、(プロジェクトおよびロードされたライブラリから) 利用可能なすべての互換性のあるビジュアライゼーションが含まれています。もし、あんたが デフォルト 設定すると、ライブラリのデフォルトのテンプレートが使用されます AC_Module 使用済み。このダイアログで構成されたテンプレートが後でプロジェクトまたはライブラリから削除された場合でも、このダイアログでは引き続き使用できます。 TargetVisu 、 ウェブビジュアル : 選択したテンプレートをこの表示バリアントに使用する必要がある場合は、それぞれのオプションをアクティブにします。 幅 : 生成されたビジュアライゼーションの幅 (ピクセル単位) (デフォルト値: 640、最小 100、最大 10000) 身長 : 生成されたビジュアライゼーションの高さ (ピクセル単位) (デフォルト値: 640、最小 100、最大 10000) 最上位タブの最小幅 : 作成された最上位タブの最小幅 (ピクセル単位)。ここに0を入力すると設定は反映されません。 最上位タブの最大幅 : 作成された最上位タブの最大幅 (ピクセル単位)。ここに0を入力すると設定は反映されません。 最上位のテンプレートの詳細については、以下を参照してください。 トップレベルのテンプレート最大クライアント数 : 同時に使用されるサポートされる表示バリアントの最大数 (デフォルト値 8、最小 1、最大 128)。 SVN が使用可能な場合は、生成されたビジュアルを無視します : プロジェクトが SVN で管理されている場合は、このオプションを有効にする必要があります。 : CODESYS 生成されたビジュアライゼーションが SVN で無視されるようにします。そうしないと問題が発生する可能性があります。 再生すると視力も回復する : : コードが生成されるたびに、すべてのビジュアライゼーションが再作成され、既存のビジュアライゼーションが上書きされます。生成後にモジュール ユーザーが生成されたビジュアルに変更を加えたくない場合は、このオプションを選択する必要があります。ただし、生成後にビジュアライゼーションへの変更が必要な場合は、オプションを無効にする必要があります。それから試してみました CODESYS その後の変更は新しい世代にも保持されます。 最上位タブのデフォルトとしてインスタンス名を使用する : : 完全なインスタンス パスの代わりに、インスタンス名のみが最上位タブに表示されます。 構成にエラーがある場合は、エラー プロバイダー アイコンとボタンによって表示されます。 わかりました 無効化されています。 " }, 
{ "title" : "コマンド: スキャン ", 
"url" : "ac_scan.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: スキャン ", 
"snippet" : "読み込む シンボル： このコマンド (カテゴリ「Composer」) は、プロジェクト全体をスキャンしてモジュール宣言を探します。通常、このコマンドは必要ありません。 CODESYS 必要なときにいつでもシステムを自動的にスキャンします (例: 新しいライブラリのインストール後)。...", 
"body" : "読み込む シンボル： このコマンド (カテゴリ「Composer」) は、プロジェクト全体をスキャンしてモジュール宣言を探します。通常、このコマンドは必要ありません。 CODESYS 必要なときにいつでもシステムを自動的にスキャンします (例: 新しいライブラリのインストール後)。 " }, 
{ "title" : "コマンド: すべてのプール オブジェクトを確認して検索します ", 
"url" : "_ac_cmd_check_and_scan_all_pool_objects.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: すべてのプール オブジェクトを確認して検索します ", 
"snippet" : "すべてのプール オブジェクトを確認して検索します 関数 : コマンドが呼び出されると、最初にライブラリの IEC コードがチェックされ、次にモジュール宣言が検索されます。テスト実行はコマンドに対応します Lすべてのプールオブジェクトをチェックする 。検索はコマンドに対応します 読み込む。 電話 : メニュー 作曲 要件 : このコマンドは、ライブラリ プロジェクトが開いている場合にのみ表示されます。...", 
"body" : "すべてのプール オブジェクトを確認して検索します 関数 : コマンドが呼び出されると、最初にライブラリの IEC コードがチェックされ、次にモジュール宣言が検索されます。テスト実行はコマンドに対応します Lすべてのプールオブジェクトをチェックする 。検索はコマンドに対応します 読み込む。 電話 : メニュー 作曲 要件 : このコマンドは、ライブラリ プロジェクトが開いている場合にのみ表示されます。 " }, 
{ "title" : "コマンド: I\/O のマップ ", 
"url" : "ac_map_channels_for_ioconfig.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: I\/O のマップ ", 
"snippet" : "I\/Oを接続する シンボル： このコマンド (カテゴリ「Composer」) は、モジュールとモジュール間のマッピングを定義するダイアログを開きます。 I\/O 構成。 ダイアログ： I\/Oマッピング ダイアログの左側には、モジュールのすべての入力と出力がツリー構造で表示されます。 モジュールツリー 。右側にはデバイスツリーの構造があります。 トップレベル モジュールのアプリケーションへの接続は、トップレベル モジュールの設定に従って描画されます。この接続は、このダイアログでは変更できません。 入力は緑色の接続と緑色の矢印で表示され、出力は赤色で表示されます。 オープン入力または出力 (接続され...", 
"body" : "I\/Oを接続する シンボル： このコマンド (カテゴリ「Composer」) は、モジュールとモジュール間のマッピングを定義するダイアログを開きます。 I\/O 構成。 ダイアログ： I\/Oマッピング ダイアログの左側には、モジュールのすべての入力と出力がツリー構造で表示されます。 モジュールツリー 。右側にはデバイスツリーの構造があります。 トップレベル モジュールのアプリケーションへの接続は、トップレベル モジュールの設定に従って描画されます。この接続は、このダイアログでは変更できません。 入力は緑色の接続と緑色の矢印で表示され、出力は赤色で表示されます。 オープン入力または出力 (接続されていない) は点線で表示されます。 ST 式が入力それぞれにマッピングされている場合。出力すると、接続は「ST」で表示されます。 モジュールとデバイス間の接続は、入力から入力、または出力から出力へのみ可能です。さらに、両方の接続に互換性のあるデータ型が必要です。モジュール間の接続は、入力から出力へ、またはその逆のみ可能です。機器間接続はできません。 接続を作成するには、オープン入力または出力を選択する必要があります。選択したピンは青色の背景で表示されます。入力と出力はドラッグ アンド ドロップで接続されます。接続ターゲットの有効または無効は、異なるマウス ポインタで示されます。入力または出力が占有されている場合、既存の接続は削除されます。 デバイスまたはモジュールが折りたたまれている場合、データの方向を決定できない可能性があるため、接続は黒で描画されます。 さらに折りたたむと (上位デバイスなど)、接続も非表示になります。これは、中央領域の線の太さを減らすことができるため、概要を改善するために行われます。 左側または右側の接続が選択されている場合、対応するデバイスは折りたたまれていても展開されます。 矢印はデータの方向を示します。デバイスが入力と出力を使用している場合、折りたたまれたデバイスには緑と赤の両方の矢印が表示されます。入力のみか出力のみか、データの方向も表示されます。 オンライン モードでは、パラメータの値が左側に表示されます。このビューでは値を変更できません。 モジュールまたはデバイスをダブルクリックすると、それぞれのオブジェクトがエディタで開きます。 アプリケーションの境界を越えて接続を設定することもできます。 モジュール インスタンスが POU プールにマッピングされている場合、接続線はグレー表示されます。この状況では、IO マッピングは作成できませんが、既存のマッピングは削除できます。 印刷する : このコマンドを使用すると、設定されている I\/O マッピングを概要形式で印刷できます。 " }, 
{ "title" : "コマンド: ワイルドカード選択 ", 
"url" : "ac_wildcard_selection.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: ワイルドカード選択 ", 
"snippet" : "ワイルドカードの割り当て このコマンド (カテゴリ「Composer」) は、ダイアログを開きます。 ワイルドカードの割り当て 。 ダイアログの上部には、現在構成されているワイルドカードと割り当てられているデバイス タイプが表示されます。ダイアログの下部にはデバイス リポジトリが表示され、インストールされているデバイスが選択可能になります。ダイアログ内で割り当てを編集できます。この目的のため、ワイルドカードをデバイス タイプに自動的に割り当てることができず、手動での割り当てが必要な場合は、デバイス生成中にダイアログも表示されます。 デバイス タイプへのワイルドカードの割り当ては、プロジェクト内...", 
"body" : "ワイルドカードの割り当て このコマンド (カテゴリ「Composer」) は、ダイアログを開きます。 ワイルドカードの割り当て 。 ダイアログの上部には、現在構成されているワイルドカードと割り当てられているデバイス タイプが表示されます。ダイアログの下部にはデバイス リポジトリが表示され、インストールされているデバイスが選択可能になります。ダイアログ内で割り当てを編集できます。この目的のため、ワイルドカードをデバイス タイプに自動的に割り当てることができず、手動での割り当てが必要な場合は、デバイス生成中にダイアログも表示されます。 デバイス タイプへのワイルドカードの割り当ては、プロジェクト内に保存されます。ただし、XML ファイルを使用して割り当てを外部に保存し、そこから再ロードすることもできます。ファイルとこのファイルのパスがダイアログの上部に表示されます。 ダイアログ： ワイルドカードの割り当て 新しい : このコマンドを使用すると、新しい (空の) ワイルドカード割り当て XML ファイルを作成できます。ファイル名と保存ディレクトリを定義します。 保存 : このコマンドは、現在定義されているワイルドカード デバイス割り当てを、手動で選択したファイルに明示的に保存します。これとは別に、ダイアログを使用してダイアログを閉じると、割り当ては現在指定されているファイルに自動的に保存されます。 わかりました ボタン。 負荷 : このコマンドを使用すると、既存のワイルドカード割り当てファイル (XML) をロードできます。 ハイライト表示されたツリー ビューでは、 デバイスID（モジュール名） 列には、デバイスの ID が表示されます。 デバイスジェネレータ ワイルドカードを使用します。このデバイスをもたらすモジュール インスタンスの名前が括弧内に表示されます。静的に挿入されたデバイスジェネレータデバイスの場合（モジュール宣言で定義） Identification そしてそうではありません Wildcard \/ FlexibleWildcard ) 標準ノード 静的 静的に挿入されたすべてのデバイスを含むファイルが作成されます。静的デバイスは変更できません。の 関係 列は、デバイス ジェネレーターの親デバイスと子デバイスの関係を示します。太線は固定された関係を示し、破線は関係の提案として機能します。この提案は次の定義に基づいています。 ParentID の中に Device セクション。 ワイルドカードを選択してキーを押すだけで、ワイルドカードを空としてマークすることもできます。 デル 鍵。たとえば、このような空のワイルドカードは、提案された親子関係を変更するのに役立つ可能性があります。 割り当てられたワイルドカードは緑色の背景色で表示されます。背景色が赤の未割り当てのワイルドカード。 考えられる親デバイスの第 1 世代との互換性のみを表示します : このオプションがアクティブ化されている場合、デバイス リポジトリ ビューのデバイスの品揃えは、最初のデバイスの親のみの互換性のある子であるデバイスにさらに制限されます。これは次のように定義されます。 モジュール構成 。アクティブ化されていない場合、第 2 世代、第 3 世代、…、第 n 世代のデバイスの親も可能な親として扱われ、デバイス リポジトリ ビューに表示されるデバイスの品揃えが拡大されます。 プロパティの割り当てのルール デバイス、IO チャネル、または FB インスタンスが左側で選択されている場合、すでに割り当てられているこのデバイス、IO チャネル、または FB インスタンスのすべてのプロパティが右側のチェックボックスでマークされます。 IO チャネルまたは FB インスタンスのプロパティが割り当てられていない左側のデバイスは赤い背景で表示され、関連する IO チャネルまたは FB インスタンスはそれぞれ赤い背景で表示されます。すべての I\/O チャネルと FB インスタンスが割り当てられているデバイスは、既知の I\/O チャネルと FB インスタンスと同様に緑色で強調表示されます。割り当てには、「要求の厳しい」プロパティを割り当てないことも含まれます。後者は、すべての I\/O チャネルと FB インスタンスを含むデバイス全体のデバイス ノードをダブルクリックすることで、デバイス全体に対して実現できます。 右側のプロパティは、ボックスをチェックすることで、左側で選択したデバイス、I\/O チャネル、または FB インスタンスの「オファリング」プロパティに追加できます。デバイス、I\/O チャネル、または FB インスタンスには、任意の数のプロパティを割り当てることも、何も割り当てることもできません。 「要求の高い」I\/O プロパティがデバイス ノードに割り当てられている場合、このプロパティはこのデバイス ノードのすべての子 I\/O チャネル ノードに割り当てられますが、FB インスタンスには割り当てられません。同様に、デバイスに「要求の厳しい」InstRef プロパティが割り当てられている場合、そのデバイスの子 FB インスタンスのみがそのプロパティに割り当てられます。複数のデバイス、I\/O チャネル、または FB インスタンスを同時に選択でき、選択したプロパティがそれぞれに可能な限り割り当てられます。 左側の少なくとも 1 つのデバイスによって提供される、右側の「要求の厳しい」プロパティは、緑色の背景で表示されます。左側の提供物件と一致しない「要求の厳しい」物件は、背景が赤で表示されます。 " }, 
{ "title" : "ワイルドカードの割り当て ", 
"url" : "ac_wildcard_selection.html#UUID-ceaa9faa-d44c-71c5-eba0-b0e56ec22feb_e2fe68ddbc7dc0a8640e014c3c31_id_342a92346a13602cc0a8640e00a6970a", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: ワイルドカード選択 \/ ワイルドカードの割り当て ", 
"snippet" : "ワイルドカードを割り当てる方法は 2 つあります。 ダイアログの上部で、割り当てるワイルドカードの行の列のフィールドをクリックします。 選択したデバイス 。次に、ダイアログの下部にあるデバイス リポジトリ ツリーで、目的のデバイスをダブルクリックします。 ダイアログの下部にあるデバイス リポジトリ ツリーで、目的のデバイスを選択します。次に、ダイアログの上部にある、割り当てるワイルドカードの行で、列のフィールドをダブルクリックします。 選択したデバイス 。...", 
"body" : "ワイルドカードを割り当てる方法は 2 つあります。 ダイアログの上部で、割り当てるワイルドカードの行の列のフィールドをクリックします。 選択したデバイス 。次に、ダイアログの下部にあるデバイス リポジトリ ツリーで、目的のデバイスをダブルクリックします。 ダイアログの下部にあるデバイス リポジトリ ツリーで、目的のデバイスを選択します。次に、ダイアログの上部にある、割り当てるワイルドカードの行で、列のフィールドをダブルクリックします。 選択したデバイス 。 " }, 
{ "title" : "デバイスプロパティの割り当て ", 
"url" : "ac_wildcard_selection.html#UUID-ceaa9faa-d44c-71c5-eba0-b0e56ec22feb_e2fe68ddbc7dc0a8640e014c3c31_id_4703909473b5f037c0a8640e01022fbe", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: ワイルドカード選択 \/ デバイスプロパティの割り当て ", 
"snippet" : "コマンド デバイスプロパティの割り当て それぞれのダイアログが開きます。 募集 デバイスのプロパティ。 ダイアログ： デバイスプロパティの割り当て ダイアログの左側には、プロジェクトで使用される生成されたすべてのデバイスがリストされます。これらのデバイスの子ノードには、対応するデバイス タイプのすべての入力、出力 (太字ではない)、および作成された機能ブロック (太字) が表示されます。 右側の表示には、使用されるモジュールのモジュール宣言で次のように定義されているすべての「要求の高い」プロパティがリストされます。 要求が厳しい IO。これらの「要求」の子ノードは、親ノードの要求を必要とするす...", 
"body" : "コマンド デバイスプロパティの割り当て それぞれのダイアログが開きます。 募集 デバイスのプロパティ。 ダイアログ： デバイスプロパティの割り当て ダイアログの左側には、プロジェクトで使用される生成されたすべてのデバイスがリストされます。これらのデバイスの子ノードには、対応するデバイス タイプのすべての入力、出力 (太字ではない)、および作成された機能ブロック (太字) が表示されます。 右側の表示には、使用されるモジュールのモジュール宣言で次のように定義されているすべての「要求の高い」プロパティがリストされます。 要求が厳しい IO。これらの「要求」の子ノードは、親ノードの要求を必要とするすべてのモジュール IO に対応します。 プロパティ割り当てダイアログは、右側のプロパティをデバイスとその IO チャネルに割り当てるために使用されます。この割り当ては、デバイスのデバイス説明の隣にある追加ファイルに保存され、追加ファイルへの参照が取得されます。モジュール IO のすべての「要求の高い」プロパティが、これらのプロパティを提供するデバイスへの少なくとも 1 つの割り当てで満たされていない場合、ダイアログはコード生成中に自動的に開きます。 " }, 
{ "title" : "コマンド: I\/O マッピングの削除 ", 
"url" : "ac_remove_connections_to_ios.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: I\/O マッピングの削除 ", 
"snippet" : "I\/O への接続を削除する このコマンド (カテゴリ「Composer」) は、I\/O マッピングを削除します。 次のサブコマンドが利用可能です。 すべて生成された : 自動生成されたマッピングを削除します。手動で追加されたマッピングは残ります。 全て : すべてのマッピング (自動生成されたマッピングと手動で追加されたマッピング) を削除します。 モジュール インスタンスのすべての生成 : モジュール ツリーでモジュール インスタンスが選択されている場合、このコマンドを実行できます。このコマンドは、このインスタンスの自動生成されたマッピングを削除します。手動で追加されたマッピングは残ります。...", 
"body" : "I\/O への接続を削除する このコマンド (カテゴリ「Composer」) は、I\/O マッピングを削除します。 次のサブコマンドが利用可能です。 すべて生成された : 自動生成されたマッピングを削除します。手動で追加されたマッピングは残ります。 全て : すべてのマッピング (自動生成されたマッピングと手動で追加されたマッピング) を削除します。 モジュール インスタンスのすべての生成 : モジュール ツリーでモジュール インスタンスが選択されている場合、このコマンドを実行できます。このコマンドは、このインスタンスの自動生成されたマッピングを削除します。手動で追加されたマッピングは残ります。 モジュールインスタンスのすべて : モジュール ツリーでモジュール インスタンスが選択されている場合、このコマンドを実行できます。このコマンドは、このインスタンスのすべてのマッピング (自動生成されたマッピングと手動で追加されたマッピング) を削除します。 " }, 
{ "title" : "コマンド: トップレベルモジュールインスタンスの追加 ", 
"url" : "ac_add_toplevel_module_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: トップレベルモジュールインスタンスの追加 ", 
"snippet" : "最上位インスタンスを追加する このコマンド (カテゴリ「Composer」) は、 モジュールダイアログ これは、モジュール ツリーに追加できるすべてのトップレベル モジュールを提供します。 アプリケーションに追加できるトップレベル モジュールの数に制限はありません。...", 
"body" : "最上位インスタンスを追加する このコマンド (カテゴリ「Composer」) は、 モジュールダイアログ これは、モジュール ツリーに追加できるすべてのトップレベル モジュールを提供します。 アプリケーションに追加できるトップレベル モジュールの数に制限はありません。 " }, 
{ "title" : "コマンド: サブモジュールインスタンスの追加 ", 
"url" : "ac_add_submodule_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: サブモジュールインスタンスの追加 ", 
"snippet" : "サブモジュールインスタンスの追加 このコマンド (カテゴリ「Composer」) は、 モジュールダイアログ これにより、モジュール ツリー内の選択した位置に追加できるすべてのサブモジュールが提供されます。 必須の参照スロットを提供するサブモジュールにより、すべての明確な参照スロットを自動的に埋めることができます。この状況では、モジュールを自動的に参照するかどうかをダイアログでユーザーに尋ねます。...", 
"body" : "サブモジュールインスタンスの追加 このコマンド (カテゴリ「Composer」) は、 モジュールダイアログ これにより、モジュール ツリー内の選択した位置に追加できるすべてのサブモジュールが提供されます。 必須の参照スロットを提供するサブモジュールにより、すべての明確な参照スロットを自動的に埋めることができます。この状況では、モジュールを自動的に参照するかどうかをダイアログでユーザーに尋ねます。 " }, 
{ "title" : "コマンド: 参照モジュールインスタンス ", 
"url" : "ac_reference_module_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: 参照モジュールインスタンス ", 
"snippet" : "参照モジュールインスタンス このコマンド (カテゴリ「Composer」) は、 モジュールダイアログ これにより、モジュール ツリー内の選択した位置で参照できるすべてのモジュールが提供されます。...", 
"body" : "参照モジュールインスタンス このコマンド (カテゴリ「Composer」) は、 モジュールダイアログ これにより、モジュール ツリー内の選択した位置で参照できるすべてのモジュールが提供されます。 " }, 
{ "title" : "コマンド: モジュール参照ビューを表示 ", 
"url" : "ac_module_references_editor.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: モジュール参照ビューを表示 ", 
"snippet" : "モジュール参照ビューを表示 このコマンド (カテゴリ「Composer」) は、 モジュールリファレンス ビューを表示し、プロジェクト内のモジュール インスタンスの使用法の概要を提供します。モジュール ツリーでモジュール インスタンスが選択されている場合、このコマンドはコンテキスト メニューで使用できます。 別のモジュール インスタンスが選択された場合、または現在選択されているインスタンスの参照が変更された場合、ビューは自動的に更新されます。...", 
"body" : "モジュール参照ビューを表示 このコマンド (カテゴリ「Composer」) は、 モジュールリファレンス ビューを表示し、プロジェクト内のモジュール インスタンスの使用法の概要を提供します。モジュール ツリーでモジュール インスタンスが選択されている場合、このコマンドはコンテキスト メニューで使用できます。 別のモジュール インスタンスが選択された場合、または現在選択されているインスタンスの参照が変更された場合、ビューは自動的に更新されます。 " }, 
{ "title" : "表示: モジュールリファレンス ", 
"url" : "ac_module_references_editor.html#UUID-7a9e7bcf-5b4a-4286-24df-e6cd7795a03a_c2a0935773056bc0a86463423a2ab0_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: モジュール参照ビューを表示 \/ 表示: モジュールリファレンス ", 
"snippet" : "アプリ \/ 参考ソース 参考資料はアプリケーションごとに並べられています。 ターゲットにおける参照の役割 ターゲットにおける参照の役割...", 
"body" : "アプリ \/ 参考ソース 参考資料はアプリケーションごとに並べられています。 ターゲットにおける参照の役割 ターゲットにおける参照の役割 " }, 
{ "title" : "コマンド: モジュールの更新 ", 
"url" : "ac_update_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: モジュールの更新 ", 
"snippet" : "モジュールを更新する このコマンド (カテゴリ「Composer」) は、 モジュールダイアログ 。モジュール ツリーは、モジュール ツリー内で選択されたモジュール インスタンスと互換性のあるすべてのモジュールを提供します。このコマンドを使用すると、モジュール インスタンスを新しいモジュール タイプに更新できます。これは、同じモジュールの新しいバージョンである場合もあります。 更新中、インスタンスの構成データは可能な限り保存されます。 現在の値が新しいパラメータ タイプと互換性がない場合でも、新しいバージョンに存在するパラメータ値が採用されます。パラメータ値がインスタンスで明示的に設定されてい...", 
"body" : "モジュールを更新する このコマンド (カテゴリ「Composer」) は、 モジュールダイアログ 。モジュール ツリーは、モジュール ツリー内で選択されたモジュール インスタンスと互換性のあるすべてのモジュールを提供します。このコマンドを使用すると、モジュール インスタンスを新しいモジュール タイプに更新できます。これは、同じモジュールの新しいバージョンである場合もあります。 更新中、インスタンスの構成データは可能な限り保存されます。 現在の値が新しいパラメータ タイプと互換性がない場合でも、新しいバージョンに存在するパラメータ値が採用されます。パラメータ値がインスタンスで明示的に設定されていない場合は、新しいモジュールのデフォルト値が使用されます。 新しいバージョンに存在し、インスタンス内の割り当てと同じ方向 (入力と出力) を持つ I\/O マッピングが採用されます。割り当ては、採用される新しい I\/O と同じタイプである必要はありません。 両方のバージョンに存在するタスクの割り当てが採用されます。 新しいモジュール内で同じスロット ID を持つスロットのサブインスタンスまたは参照は、すべてのサブインスタンスおよび参照とともに維持されます。これは、サブインスタンスまたは参照のタイプが新しいスロットと一致しない場合、または新しいスロットの基数がすべてのサブインスタンスまたは参照を許可しない場合にも当てはまります。 新しいモジュールに存在しないスロットのサブインスタンスまたは参照は、「孤立したインスタンス」または「孤立した参照」という名前の新しいスロットの下に挿入されます。これらのスロットは、通常のスロットでは発生できない特別な識別子によって識別されます。孤立した要素を含むスロットがすでに存在する場合、このスロットが使用されます。 新しいモジュール内に存在するが、参照 (サブインスタンスの場合) またはサブインスタンス (参照の場合) を期待しているスロットのサブインスタンスまたは参照は、それぞれサブインスタンスとして処理されます。新しいモジュールで使用できないスロットを参照します。 トップレベルではないモジュールに更新があった場合、インスタンス内に存在するトップレベルの情報は削除されます。インスタンスにトップレベル情報が存在しない場合、モジュールがトップレベル モジュールに更新されると情報が作成されます。 拡張機能によって定義されたインスタンス データ: それぞれの拡張機能によって、どのデータが保持され、どのデータが削除されるかが決まります。できるだけ多くのデータを取得するという原則に従う必要があります。 新しいモジュールのスロットの順序が変更された場合、インスタンスの下のスロットの順序もそれに応じて調整されます。 更新によりデータ (パラメータ値、I\/O 割り当て、空でないスロット、拡張インスタンス データなど) が削除される場合は、削除されるオブジェクトを説明するメッセージが表示され、ユーザーは更新をキャンセルできます。 インスタンスの更新は、モジュール ツリーで 1 回の元に戻す手順で元に戻すことができます。 " }, 
{ "title" : "コマンド: すべてのインスタンスを更新 ", 
"url" : "ac_update_all_instances.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: すべてのインスタンスを更新 ", 
"snippet" : "すべてのインスタンスを更新する このコマンド (カテゴリ「Composer」) を使用すると、1 つのコマンドですべてのモジュール インスタンスをモジュールの新しいバージョンに更新できます。このコマンドはコンテキスト メニューでは使用できません。コマンドの動作は、 アップデートモジュール ただし、別のモジュールへの更新はできません。...", 
"body" : "すべてのインスタンスを更新する このコマンド (カテゴリ「Composer」) を使用すると、1 つのコマンドですべてのモジュール インスタンスをモジュールの新しいバージョンに更新できます。このコマンドはコンテキスト メニューでは使用できません。コマンドの動作は、 アップデートモジュール ただし、別のモジュールへの更新はできません。 " }, 
{ "title" : "コマンド: 空のオプションスロットを非表示: すべて\/選択したスロットのみ ", 
"url" : "ac_hide_empty_optional_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: 空のオプションスロットを非表示: すべて\/選択したスロットのみ ", 
"snippet" : "空のオプションスロットを非表示にする: すべて\/選択したスロットのみ これらのコマンド (カテゴリ「Composer」) を使用すると、モジュール ツリー内の空のオプション スロットを非表示にすることができます。現在のフォーカスに応じて、これはすべてのサブモジュール、または現在選択されているサブモジュールのみを指します。必須スロットを非表示にすることはできません。 空のオプションスロットの例 隠しスロットを表示するには、 隠しスロットを表示 – すべて\/選択したスロットのみ 指示。...", 
"body" : "空のオプションスロットを非表示にする: すべて\/選択したスロットのみ これらのコマンド (カテゴリ「Composer」) を使用すると、モジュール ツリー内の空のオプション スロットを非表示にすることができます。現在のフォーカスに応じて、これはすべてのサブモジュール、または現在選択されているサブモジュールのみを指します。必須スロットを非表示にすることはできません。 空のオプションスロットの例 隠しスロットを表示するには、 隠しスロットを表示 – すべて\/選択したスロットのみ 指示。 " }, 
{ "title" : "コマンド: 隠しスロットを表示: すべて\/選択したスロットのみ ", 
"url" : "ac_show_hidden_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: 隠しスロットを表示: すべて\/選択したスロットのみ ", 
"snippet" : "隠しスロットを表示: すべて\/選択したスロットのみ モジュール ツリー内のこれらのコマンド (カテゴリ「Composer」) を使用すると、以前は非表示になっていたスロットを再び表示することができます。現在のフォーカスに応じて、これはすべてのサブモジュール、または現在選択されているサブモジュールのみを指します。 スロットを非表示にする場合は、 空のオプションスロットを非表示 – すべて\/選択したスロットのみ 指示。...", 
"body" : "隠しスロットを表示: すべて\/選択したスロットのみ モジュール ツリー内のこれらのコマンド (カテゴリ「Composer」) を使用すると、以前は非表示になっていたスロットを再び表示することができます。現在のフォーカスに応じて、これはすべてのサブモジュール、または現在選択されているサブモジュールのみを指します。 スロットを非表示にする場合は、 空のオプションスロットを非表示 – すべて\/選択したスロットのみ 指示。 " }, 
{ "title" : "コマンド: ターゲットに移動 ", 
"url" : "ac_go_to_target.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: ターゲットに移動 ", 
"snippet" : "ターゲットに移動 このコマンド (カテゴリ「Composer」) は、モジュール参照が選択されている場合にのみ使用できます。 モジュールツリー 。このコマンドを実行すると、モジュールツリー上で参照先が選択されます。...", 
"body" : "ターゲットに移動 このコマンド (カテゴリ「Composer」) は、モジュール参照が選択されている場合にのみ使用できます。 モジュールツリー 。このコマンドを実行すると、モジュールツリー上で参照先が選択されます。 " }, 
{ "title" : "コマンド: 拡張モジュールの作成 ", 
"url" : "_ac_cmd_create_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: 拡張モジュールの作成 ", 
"snippet" : "拡張モジュールの作成 シンボル： コマンドにより生成されるのは、 拡張モジュール サブモジュールスロットにあります。これは、モジュール ツリーで空のモジュール スロットまたはサブモジュール スロットが選択されている場合にのみ使用できます。 このコマンドによりダイアログが開き、拡張機能を新しいモジュール (「バリエーションなし」) として作成するか、既存のモジュールのバリエーションとして作成するかを指定します。スロットに適合するすべてのモジュールが選択リストで提供されます。 次の 2 つのオプションが利用可能です。 バリエーションの導出 拡張モジュールは以下から提供されます。 のバリエーション ...", 
"body" : "拡張モジュールの作成 シンボル： コマンドにより生成されるのは、 拡張モジュール サブモジュールスロットにあります。これは、モジュール ツリーで空のモジュール スロットまたはサブモジュール スロットが選択されている場合にのみ使用できます。 このコマンドによりダイアログが開き、拡張機能を新しいモジュール (「バリエーションなし」) として作成するか、既存のモジュールのバリエーションとして作成するかを指定します。スロットに適合するすべてのモジュールが選択リストで提供されます。 次の 2 つのオプションが利用可能です。 バリエーションの導出 拡張モジュールは以下から提供されます。 のバリエーション 選択したモジュールが派生します。選択したモジュールが表示されます IMPORTS 」が拡張モジュールにインポートされ、新しいモジュールの機能ブロックがモジュール テンプレートの機能ブロックから派生されます。 バリエーションのソースをコピーする 拡張モジュールは、以下の汎用モジュールと関連するビジュアライゼーションを含むモジュール宣言全体を取得して作成されます。 のバリエーション 選択したモジュールがコピーされます（ソースコードを含む）。これは以下の場合にのみ可能です のバリエーション 選択したモジュールは、コンパイルされたライブラリ内のモジュールとしてだけでなく、ソース コード内に存在します。 拡張モジュールは、既存の定義済みモジュールまたはモジュール インスタンスにアプリケーション固有の変更または拡張機能を追加するために使用されます。 次のコマンドでダイアログを閉じた後、 わかりました 拡張モジュールの名前が付いた新しいフォルダーが作成されます POU - プールが作成されました。 次のオブジェクトがこのフォルダーに作成されます (<name> は拡張モジュールの名前です)。 標準の場合: 名前付きのファンクション ブロック < name> は、「Module」クラスを拡張し、スロットに必要なインターフェイスを実装します。実装されたインターフェイス内に存在するが、どの基本クラスにも実装されていないすべてのメソッドとプロパティは、FB の下に作成されます。 バリエーションケース: 標準ケースと同様に、対応する汎用モジュールが登録されます。この機能ブロックは、選択したモジュール テンプレートの機能ブロック ( バリエーションの導出 ) またはコピー ( ソースからバリエーションをコピー ）。 画像プールとテキストリスト(名前) IP_<Name> または TL_<Name> ）。画像プールには識別子が付いた 2 つのアイコンが含まれています Icon_16 そして Icon_32 。テキストリストには次のエントリが含まれています Desc (で占められている <name> ) 列以外のテキストリストにあります デフォルト 言語はありません。 名前が付いた空の埋め込みビジュアライゼーション Visu_M_<name> 、必要なインターフェイスを実装します。もし ソースからバリエーションをコピー が選択された場合は、代わりにソース モジュールのビジュアライゼーションがコピーされます。 パラメーターと I\/O を持たず、上で作成した画像、テキスト、視覚エフェクトをメタデータとして使用する拡張モジュールが作成されます。カテゴリは「拡張」で、「派生」バリエーションの場合は参照されます。 IMPORTS さらにモジュール テンプレート宣言をインポートします。それが「コピーされた」バリエーションである場合、モジュール テンプレート宣言はコピーされ、拡張モジュールの対応するテキスト リストとイメージ コレクションを使用するように適合されます。 " }, 
{ "title" : "コマンド: 欠落しているテキスト リスト エントリを作成する ", 
"url" : "ac_create_missing_textlist_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: 欠落しているテキスト リスト エントリを作成する ", 
"snippet" : "欠落しているテキスト リスト エントリを生成する このコマンド (カテゴリ「Composer」) は、モジュール宣言による参照で存在しないすべてのテキスト リストとテキスト リスト エントリを自動的に作成します。このコマンドは、次の場合にのみ使用できます。 モジュール宣言エディタ がフォーカスされて開かれ、オブジェクトはプライマリ プロジェクトに存在します。この関数は、構文エラーがない場合にのみ機能します。テキスト リストは、エディタ内のオブジェクトと同じ親オブジェクトの下に作成されます。新しく作成されたエントリでは、「デフォルト」テキストのみが (ID とともに) 入力されます。...", 
"body" : "欠落しているテキスト リスト エントリを生成する このコマンド (カテゴリ「Composer」) は、モジュール宣言による参照で存在しないすべてのテキスト リストとテキスト リスト エントリを自動的に作成します。このコマンドは、次の場合にのみ使用できます。 モジュール宣言エディタ がフォーカスされて開かれ、オブジェクトはプライマリ プロジェクトに存在します。この関数は、構文エラーがない場合にのみ機能します。テキスト リストは、エディタ内のオブジェクトと同じ親オブジェクトの下に作成されます。新しく作成されたエントリでは、「デフォルト」テキストのみが (ID とともに) 入力されます。 " }, 
{ "title" : "コマンド: イメージ プールで欠落しているエントリを生成する ", 
"url" : "ac_create_missing_image_pool_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: イメージ プールで欠落しているエントリを生成する ", 
"snippet" : "画像コレクションに欠落しているエントリを作成する このコマンドは、モジュール記述で定義されているものの、プロジェクトのイメージ プールにまだ存在していないエントリのイメージ プールを生成します。イメージ プールがまだ存在しない場合、イメージ プールは POU まず見てください。 デフォルトでは、このコマンドは 作曲 メニュー。あなたが使用するのは、 ツール → カスタマイズ ダイアログから追加します 作曲 コマンドカテゴリへ 作曲 メニュー。 コマンドがメニューに表示されます 作曲 モジュールがエディターで開かれており、フォーカスがあるときに表示されます。...", 
"body" : "画像コレクションに欠落しているエントリを作成する このコマンドは、モジュール記述で定義されているものの、プロジェクトのイメージ プールにまだ存在していないエントリのイメージ プールを生成します。イメージ プールがまだ存在しない場合、イメージ プールは POU まず見てください。 デフォルトでは、このコマンドは 作曲 メニュー。あなたが使用するのは、 ツール → カスタマイズ ダイアログから追加します 作曲 コマンドカテゴリへ 作曲 メニュー。 コマンドがメニューに表示されます 作曲 モジュールがエディターで開かれており、フォーカスがあるときに表示されます。 " }, 
{ "title" : "コマンド: 上に移動 ", 
"url" : "ac_move_up.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: 上に移動 ", 
"snippet" : "上 このコマンド (カテゴリ「Composer」) は、モジュール内のモジュールの位置を変更するために使用できます。 モジュールツリー 。このコマンドは、マルチスロット要素 (モジュール インスタンスと参照) に対して、選択した要素がマルチスロットの最初の要素ではない場合にのみ使用できます。...", 
"body" : "上 このコマンド (カテゴリ「Composer」) は、モジュール内のモジュールの位置を変更するために使用できます。 モジュールツリー 。このコマンドは、マルチスロット要素 (モジュール インスタンスと参照) に対して、選択した要素がマルチスロットの最初の要素ではない場合にのみ使用できます。 " }, 
{ "title" : "コマンド: 下に移動 ", 
"url" : "ac_move_down.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: 下に移動 ", 
"snippet" : "下向き このコマンド (カテゴリ「Composer」) は、モジュール内のモジュールの位置を変更するために使用できます。 モジュールツリー 。このコマンドは、マルチスロット要素 (モジュール インスタンスと参照) で、選択した要素がマルチスロットの最後の要素ではない場合にのみ使用できます。...", 
"body" : "下向き このコマンド (カテゴリ「Composer」) は、モジュール内のモジュールの位置を変更するために使用できます。 モジュールツリー 。このコマンドは、マルチスロット要素 (モジュール インスタンスと参照) で、選択した要素がマルチスロットの最後の要素ではない場合にのみ使用できます。 " }, 
{ "title" : "コマンド: 不明なエントリのチェック ", 
"url" : "ac_check_for_unknown_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: 不明なエントリのチェック ", 
"snippet" : "不明なエントリをチェックする このコマンド (カテゴリ「Composer」) は、不明なセクション定義がないかモジュール宣言をチェックします。サブコマンド 全て は常に利用可能で、プロジェクトのすべてのモジュール宣言をチェックします。モジュール宣言がエディターで開かれている場合、追加のサブコマンド 現在のエディタ内 現在開かれているモジュール宣言に不明なセクション定義がないかどうかをチェックします。...", 
"body" : "不明なエントリをチェックする このコマンド (カテゴリ「Composer」) は、不明なセクション定義がないかモジュール宣言をチェックします。サブコマンド 全て は常に利用可能で、プロジェクトのすべてのモジュール宣言をチェックします。モジュール宣言がエディターで開かれている場合、追加のサブコマンド 現在のエディタ内 現在開かれているモジュール宣言に不明なセクション定義がないかどうかをチェックします。 " }, 
{ "title" : "コマンド: 生成、コンパイル、ログイン ", 
"url" : "ac_generate_compile_login.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: 生成、コンパイル、ログイン ", 
"snippet" : "作成、翻訳、ログイン シンボル： このコマンド (カテゴリ「Composer」) は、マウスを 1 回クリックするだけで複数のコマンドを実行します。まず、コードが作成され、コンパイルされます。可能であれば、アプリケーションはコントローラにログインして起動されます。...", 
"body" : "作成、翻訳、ログイン シンボル： このコマンド (カテゴリ「Composer」) は、マウスを 1 回クリックするだけで複数のコマンドを実行します。まず、コードが作成され、コンパイルされます。可能であれば、アプリケーションはコントローラにログインして起動されます。 " }, 
{ "title" : "コマンド: モジュール ライブラリをプロジェクトに追加 ", 
"url" : "ac_add_libraries_to_pou.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: モジュール ライブラリをプロジェクトに追加 ", 
"snippet" : "モジュールライブラリをプロジェクトに追加する シンボル： このコマンド (カテゴリ「Composer」) は、ライブラリを含むモジュールを含むダイアログを開きます。とともに わかりました ボタンをクリックすると、選択したライブラリが POU プールのライブラリ マネージャーに追加されます。標準の Composer ライブラリの場合 AC_ModlueBase が欠落している場合は、これも自動的に追加されます。 Application Composer ライブラリを追加するダイアログ ダイアログにはボタンがあります POU ライブラリ マネージャーを開く これにより、ライブラリマネージャーを開く...", 
"body" : "モジュールライブラリをプロジェクトに追加する シンボル： このコマンド (カテゴリ「Composer」) は、ライブラリを含むモジュールを含むダイアログを開きます。とともに わかりました ボタンをクリックすると、選択したライブラリが POU プールのライブラリ マネージャーに追加されます。標準の Composer ライブラリの場合 AC_ModlueBase が欠落している場合は、これも自動的に追加されます。 Application Composer ライブラリを追加するダイアログ ダイアログにはボタンがあります POU ライブラリ マネージャーを開く これにより、ライブラリマネージャーを開くことができます。 POU プールにもあります Composer Dedicated ビュー。 " }, 
{ "title" : "コマンド: 次のステップへのアクティブなブレークポイント ", 
"url" : "ac_active_breakpoints_to_next_step.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: 次のステップへのアクティブなブレークポイント ", 
"snippet" : "次のステップへのアクティブなブレークポイント このコマンド (カテゴリ「Composer」) は、オンライン モードで、シーケンスがブレークポイントで停止している場合にのみ使用できます。現在アクティブなブレークポイントを削除し、次のステップに新しいブレークポイントを追加します。...", 
"body" : "次のステップへのアクティブなブレークポイント このコマンド (カテゴリ「Composer」) は、オンライン モードで、シーケンスがブレークポイントで停止している場合にのみ使用できます。現在アクティブなブレークポイントを削除し、次のステップに新しいブレークポイントを追加します。 " }, 
{ "title" : "コマンド: ビューをブレークポイントの中央に配置 ", 
"url" : "ac_center_view_to_breakpoints.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: ビューをブレークポイントの中央に配置 ", 
"snippet" : "ブレークポイントを中心にビューを表示 このコマンド (カテゴリ「Composer」) は、オンライン モードで、シーケンスがブレークポイントで停止している場合にのみ使用できます。シーケンス エディターのビューが現在アクティブなブレークポイントの中心に配置されます。...", 
"body" : "ブレークポイントを中心にビューを表示 このコマンド (カテゴリ「Composer」) は、オンライン モードで、シーケンスがブレークポイントで停止している場合にのみ使用できます。シーケンス エディターのビューが現在アクティブなブレークポイントの中心に配置されます。 " }, 
{ "title" : "コマンド: マクロ モジュールの作成 ", 
"url" : "ac_create_macro_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: マクロ モジュールの作成 ", 
"snippet" : "マクロモジュールの作成 シンボル： このコマンド (「コンポーザー」カテゴリ内) は、マクロ モジュールを生成するためのダイアログを開きます。 このコマンドを使用するには、作成用の有効なライセンスが必要です。 モジュール宣言 。 このコマンドは、モジュール ツリーでサブツリーを選択した場合に使用できます。このコマンドを使用して、サブツリーのモジュールからマクロ モジュールを生成できます。このようにして、サブモジュールのどのスロット、I\/O、およびパラメータを新しいマクロ モジュールで使用できるかを定義できます。 メタデータ 名前 これはマクロ モジュールの一意の名前です。 マクロの説明 説明は...", 
"body" : "マクロモジュールの作成 シンボル： このコマンド (「コンポーザー」カテゴリ内) は、マクロ モジュールを生成するためのダイアログを開きます。 このコマンドを使用するには、作成用の有効なライセンスが必要です。 モジュール宣言 。 このコマンドは、モジュール ツリーでサブツリーを選択した場合に使用できます。このコマンドを使用して、サブツリーのモジュールからマクロ モジュールを生成できます。このようにして、サブモジュールのどのスロット、I\/O、およびパラメータを新しいマクロ モジュールで使用できるかを定義できます。 メタデータ 名前 これはマクロ モジュールの一意の名前です。 マクロの説明 説明はテキストリストとして作成されます。 マクロカテゴリ カテゴリは、モジュールの挿入ダイアログ ボックスでモジュールを細分するために使用されます。 スロット\/IO\/パラメータ マクロモジュールサブツリー サブツリーのすべてのオブジェクトのツリー ビュー この構造には、それぞれのサブモジュール インスタンスのすべてのスロット、すべての IO、およびすべてのパラメータも子として表示されます (太字)。 マクロモジュールスロット これにより、マクロ モジュール タイプに含める必要があるすべてのスロット、I\/O、およびパラメータが表示されます。 これらの要素は、左側のツリー ビューから直接取得されます。 マクロモジュール IO マクロモジュールパラメータ マクロに追加 これは、左側のツリー ビューでスロット、I\/O、またはパラメータを選択するとアクティブになります。 このボタンをクリックすると、要素がマクロ モジュールに追加されます。 マクロから削除 これは、右側のツリー ビューからスロット、I\/O、またはパラメータを選択するとアクティブになります。 このボタンをクリックすると、マクロ モジュールから要素が削除されます。 をクリックしてダイアログを閉じると、 わかりました 、 CODESYS Application Composer このマクロ モジュールのモジュール宣言、テキスト リスト、およびイメージ プールを生成します。オブジェクトはマクロ名の付いたフォルダーに保存されます。生成されたオブジェクトを制限なしで、世代に関係なく編集できるようになりました。このようにして、たとえば、イメージ プール内のマクロ アイコンを交換できます。 " }, 
{ "title" : "コマンド: すべてのモジュールに署名する ", 
"url" : "ac_sign_all_modules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: すべてのモジュールに署名する ", 
"snippet" : "すべてのモジュールに署名する このコマンド (カテゴリ「Composer」) は、POU プールのすべてのモジュールの (更新された) サインを許可します。このコマンドを使用すると、次のすべてのモジュールに再署名できます。 POU プール。有効なライセンスを使用して開発されたモジュールは、自動的に署名されます。このコマンドは、Application Composer の前のバージョンの既存の署名されていないモジュールを引き継ぐことを目的としています。...", 
"body" : "すべてのモジュールに署名する このコマンド (カテゴリ「Composer」) は、POU プールのすべてのモジュールの (更新された) サインを許可します。このコマンドを使用すると、次のすべてのモジュールに再署名できます。 POU プール。有効なライセンスを使用して開発されたモジュールは、自動的に署名されます。このコマンドは、Application Composer の前のバージョンの既存の署名されていないモジュールを引き継ぐことを目的としています。 " }, 
{ "title" : "コマンド: モジュール FB へ移動 ", 
"url" : "ac_goto_modul_fb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: モジュール FB へ移動 ", 
"snippet" : "モジュールFBに移動 コマンド (カテゴリ「Composer」) を使用して、モジュールの機能ブロックまたはそのメソッドをエディターで開くことができます。このコマンドを使用できるようにするには、モジュール ツリーでモジュールを選択する必要があります。 オフライン モードでは、ファンクション ブロック タイプまたはファンクション ブロック メソッドの宣言がエディタで開かれます。オンライン モードでは、関数ブロック インスタンスまたはモジュール インスタンスのメソッドがエディターで開きます。...", 
"body" : "モジュールFBに移動 コマンド (カテゴリ「Composer」) を使用して、モジュールの機能ブロックまたはそのメソッドをエディターで開くことができます。このコマンドを使用できるようにするには、モジュール ツリーでモジュールを選択する必要があります。 オフライン モードでは、ファンクション ブロック タイプまたはファンクション ブロック メソッドの宣言がエディタで開かれます。オンライン モードでは、関数ブロック インスタンスまたはモジュール インスタンスのメソッドがエディターで開きます。 " }, 
{ "title" : "コマンド: 異なるパラメータ値 ", 
"url" : "ac_differing_parameter_values.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: 異なるパラメータ値 ", 
"snippet" : "異なるパラメータ値 このコマンドをオンライン モードで使用して、モジュール ツリーで使用されているモジュール インスタンスのパラメータ値がモジュール機能ブロックで変更されているかどうかを確認します。この場合、変更されたもののリストが取得されます。 パラメーター および関連するモジュール インスタンスの メッセージ ビュー。メッセージをダブルクリックすると、関連するモジュール インスタンスのパラメータ エディタが開きます。アプリケーションのオンライン モードとオフライン モードで値が異なるすべてのパラメータは、列内の赤枠のセルで示されます。 価値 そして オンラインの価値 。...", 
"body" : "異なるパラメータ値 このコマンドをオンライン モードで使用して、モジュール ツリーで使用されているモジュール インスタンスのパラメータ値がモジュール機能ブロックで変更されているかどうかを確認します。この場合、変更されたもののリストが取得されます。 パラメーター および関連するモジュール インスタンスの メッセージ ビュー。メッセージをダブルクリックすると、関連するモジュール インスタンスのパラメータ エディタが開きます。アプリケーションのオンライン モードとオフライン モードで値が異なるすべてのパラメータは、列内の赤枠のセルで示されます。 価値 そして オンラインの価値 。 " }, 
{ "title" : "コマンド: 最上位タブのテキストをリセット ", 
"url" : "ac_reset_text_of_toplevel_tabs.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: 最上位タブのテキストをリセット ", 
"snippet" : "最上位タブのテキストをリセット 関数 : このコマンドは、テキストをデフォルト設定にリセットします。 トップレベルのタブ のモジュールエディタで定義されたもの HMI タブ。クリックする Composer → 最上位タブのテキストをリセット → すべて すべてのトップレベルのタブのテキストをリセットします。クリックする Composer → 最上位タブのテキストをリセット → 選択のみ 選択したモジュールのテキストのみをリセットします ( モジュール ビュー）。クリック 作曲家 → 作成 アプリケーションを更新します。 電話 : 作曲 メニュー 要件 : トップレベルのタブ用に特別に構成された...", 
"body" : "最上位タブのテキストをリセット 関数 : このコマンドは、テキストをデフォルト設定にリセットします。 トップレベルのタブ のモジュールエディタで定義されたもの HMI タブ。クリックする Composer → 最上位タブのテキストをリセット → すべて すべてのトップレベルのタブのテキストをリセットします。クリックする Composer → 最上位タブのテキストをリセット → 選択のみ 選択したモジュールのテキストのみをリセットします ( モジュール ビュー）。クリック 作曲家 → 作成 アプリケーションを更新します。 電話 : 作曲 メニュー 要件 : トップレベルのタブ用に特別に構成されたテキストを含むモジュールは、 モジュール ビュー。 サンプルモジュール 次の手順では、トップレベルのタブのテキストを設定してリセットする方法について説明します。 プロジェクトにはモジュールが含まれています Building 。 ビュー内をダブルクリックします モジュール モジュール上で Building 。 モジュールエディタ（モジュールコンフィギュレータ）が開きます。 オプションを有効にする トップレベルのライダーを作成する 。 プリセットされた最上位テキストを含む入力フィールドがその隣に表示されます Building 。 そこに入ってください City hall ａ． コマンドを選択してください 作曲 → 作成 。 モジュールの視覚化と視覚化 Toplevel 作成され、ビュー内に表示されます デバイス 提出した。 ビュー内をダブルクリックします デバイス 視覚化 Toplevel 。 → プロジェクトを保存します。 ビュー内をダブルクリックします モジュール モジュール上で Building 。 メニューコマンド 作曲 をご利用いただけます。 モジュールを選択してください Building 。 コマンドを選択してください Composer → 最上位タブのテキストをリセット → 選択されたタブのみ 。 モジュールエディターのオプションの隣の入力フィールド トップレベルのライダーを作成する テキストはデフォルトに戻ります Building リセット。 コマンドを選択してください 作曲 → 作成 。 モジュールの視覚化と視覚化 Toplevel 更新され、ビューに表示されます デバイス 提出した。 ビューで開く デバイス 視覚化 Toplevel 。 → サブモジュールの例 次の手順では、モジュールとサブモジュールのモジュール構造内の最上位タブのテキストを設定してリセットする方法について説明します。 プロジェクトにはモジュールが含まれています Building そしてその下にサブモジュールがあります Bathroom 。 ビュー内をダブルクリックします モジュール モジュール上で Building 。 モジュールエディタ（モジュールコンフィギュレータ）が開きます。 オプションを有効にする トップレベルのライダーを作成する 。 プリセットされた最上位テキストを含む入力フィールドがその隣に表示されます Building 。 そこに入ってください City hall ａ． ビュー内をダブルクリックします モジュール モジュール上で Bathroom 。 モジュールエディタ（モジュールコンフィギュレータ）が開きます。 オプションを有効にする トップレベルのライダーを作成する 。 プリセットされた最上位テキストを含む入力フィールドがその隣に表示されます Building.Bathroom 。 そこに入ってください WC ａ． コマンドを選択してください 作曲 → 作成 。 モジュールの視覚化と視覚化 Toplevel 作成され、ビュー内に表示されます デバイス 提出した。 ビュー内をダブルクリックします デバイス 視覚化 Toplevel 。 → プロジェクトを保存します。 ビュー内をダブルクリックします モジュール モジュール上で Building 。 メニューコマンド 作曲 をご利用いただけます。 モジュールを選択してください Building 。 コマンドを選択してください Composer → 最上位タブのテキストをリセット → すべて 。 コマンドを選択してください 作曲家 → 作成 。 モジュールの視覚化と視覚化 Toplevel 更新され、ビューに表示されます デバイス 提出した。 ビューで開く デバイス 視覚化 Toplevel 。 → " }, 
{ "title" : "コマンド: FB からモジュールを作成 ", 
"url" : "ac_create_module_from_fb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: FB からモジュールを作成 ", 
"snippet" : "FBからモジュールを作成 このコマンド (「Composer」カテゴリ) は、機能ブロックからモジュール記述を作成します。 次のオブジェクトが作成されます。 名前付きモジュールの説明 <NameOfTheFB> 名前を含む画像のコレクション IP_<NameOfTheFB> 名前を含むテキストリスト TL_<NameOfTheFB> 名前付きのインターフェース I<NameOfTheFB> 。 このインターフェースは展開されます AC.IModule 。 モジュールの説明は、次のルールに基づいて作成されます。 すべての変数 var_input constant モジュールパラメータとして定義さ...", 
"body" : "FBからモジュールを作成 このコマンド (「Composer」カテゴリ) は、機能ブロックからモジュール記述を作成します。 次のオブジェクトが作成されます。 名前付きモジュールの説明 <NameOfTheFB> 名前を含む画像のコレクション IP_<NameOfTheFB> 名前を含むテキストリスト TL_<NameOfTheFB> 名前付きのインターフェース I<NameOfTheFB> 。 このインターフェースは展開されます AC.IModule 。 モジュールの説明は、次のルールに基づいて作成されます。 すべての変数 var_input constant モジュールパラメータとして定義されます。属性でできることは、 parameterCategory 、 parameterMinValue そして parameterMaxValuehere カテゴリと最小値\/最大値を設定するために使用できます。 すべての数値変数 var_output モジュール出力として定義されます すべての数値変数 var_input マルチスロットの一部としてマークされていない限り、モジュール入力として定義されます。 すべての変数 var_input タイプの Interface 属性装備時は単一スロットとなる ac_single_slot マークが付いています。 マルチスロットを作成するには、 var_input 必要なものは 1 つで構成されます Pointer to Interface そして整数変数。両方とも属性を持つ必要があります 'ac_multi_slot' := '<ID>' マークされることにより、 <ID> 2 つのうち一致する必要があります。 " }, 
{ "title" : "コマンド: 永続性マネージャーの作成 ", 
"url" : "ac_create_persistence_manager.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: 永続性マネージャーの作成 ", 
"snippet" : "永続化マネージャーの作成 このコマンド (「Composer」カテゴリ) は、完全なファイルを作成します。 永続化マネージャー 標準設定でモジュール ツリーに挿入されます。 Persistence Manager の下にモジュールがあります 永続チャネル そしてその下にモジュール データストレージ 挿入されました。 作成された構造は、必要に応じて変更および拡張できます。これはモジュールのパラメータで発生します 永続チャネル そして データストレージモジュール 。最上位モジュールのインスタンスでは、 永続性マネージャーモジュール 少なくとも対象アプリケーションを設定する必要があります。アプリケー...", 
"body" : "永続化マネージャーの作成 このコマンド (「Composer」カテゴリ) は、完全なファイルを作成します。 永続化マネージャー 標準設定でモジュール ツリーに挿入されます。 Persistence Manager の下にモジュールがあります 永続チャネル そしてその下にモジュール データストレージ 挿入されました。 作成された構造は、必要に応じて変更および拡張できます。これはモジュールのパラメータで発生します 永続チャネル そして データストレージモジュール 。最上位モジュールのインスタンスでは、 永続性マネージャーモジュール 少なくとも対象アプリケーションを設定する必要があります。アプリケーションがコントローラーにロードされる前に、コマンドも発行する必要があります 生成する 処刑される。 このコマンドはさらに、必要なすべてのライブラリをライブラリ マネージャーに追加し、関連するジェネレーターをアクティブにします。 " }, 
{ "title" : "コマンド: DataLog マネージャーの作成 ", 
"url" : "ac_create_datalog_manager.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド: DataLog マネージャーの作成 ", 
"snippet" : "データログマネージャーの作成 このコマンド (「Composer」カテゴリ) は、完全なファイルを作成します。 データログマネージャー 標準設定でモジュール ツリーに挿入されます。 DataLog Manager の下にモジュールがあります データログチャネル そしてその下にモジュール データログストレージ 挿入されました。 作成された構造は、必要に応じて変更および拡張できます。これはパラメータで発生します。 「データログチャネル」モジュール そして 「DataLog ストレージ CSV」モジュール 。最上位モジュールのインスタンスでは、 「データログマネージャー」モジュール 少なくとも対象ア...", 
"body" : "データログマネージャーの作成 このコマンド (「Composer」カテゴリ) は、完全なファイルを作成します。 データログマネージャー 標準設定でモジュール ツリーに挿入されます。 DataLog Manager の下にモジュールがあります データログチャネル そしてその下にモジュール データログストレージ 挿入されました。 作成された構造は、必要に応じて変更および拡張できます。これはパラメータで発生します。 「データログチャネル」モジュール そして 「DataLog ストレージ CSV」モジュール 。最上位モジュールのインスタンスでは、 「データログマネージャー」モジュール 少なくとも対象アプリケーションを設定する必要があります。アプリケーションがコントローラーにロードされる前に、コマンドも発行する必要があります 生成する 処刑される。 このコマンドはさらに、必要なすべてのライブラリをライブラリ マネージャーに追加し、関連するジェネレーターをアクティブにします。 " }, 
{ "title" : "コマンド:ライセンス情報を取得 ", 
"url" : "ac_cmd_get_license_information.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ コマンド \/ コマンド:ライセンス情報を取得 ", 
"snippet" : "ライセンス情報を取得 このコマンド (「Composer」カテゴリ) では、 CODESYS モジュールツリーで使用されているモジュールインスタンスの数を取得します。現在のライセンスの最大許容インスタンス数も照会されます。結果はに表示されます。 メッセージ 表示。 詳細については、「」を参照してください。 ???...", 
"body" : "ライセンス情報を取得 このコマンド (「Composer」カテゴリ) では、 CODESYS モジュールツリーで使用されているモジュールインスタンスの数を取得します。現在のライセンスの最大許容インスタンス数も照会されます。結果はに表示されます。 メッセージ 表示。 詳細については、「」を参照してください。 ???" }, 
{ "title" : "チュートリアル ", 
"url" : "f_application_composer_example.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ チュートリアル ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "例: 最初のステップ ", 
"url" : "f_application_composer_first_steps.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ チュートリアル \/ 例: 最初のステップ ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "アプリケーションコンポーザの例 ", 
"url" : "ac_example_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ チュートリアル \/ 例: 最初のステップ \/ アプリケーションコンポーザの例 ", 
"snippet" : "このガイドでは、小さなサンプル プロジェクトに基づいて、Application Composer のモジュールを作成する方法を説明します。 このガイドの一部の URL は、Application Composer の一部であるページにリンクしています。このパッケージがインストールされていない場合、これらのリンクは機能しません。 この例では、照明とスイッチのある部屋について説明します。スイッチは簡易スイッチまたは調光器として使用できます。長く押すとライトが暗くなり、短く押すとオンまたはオフになります。調光機能の速度と光の最大値はユーザーが設定できます。スイッチを設定時間以上押すと調光機能が作動し...", 
"body" : "このガイドでは、小さなサンプル プロジェクトに基づいて、Application Composer のモジュールを作成する方法を説明します。 このガイドの一部の URL は、Application Composer の一部であるページにリンクしています。このパッケージがインストールされていない場合、これらのリンクは機能しません。 この例では、照明とスイッチのある部屋について説明します。スイッチは簡易スイッチまたは調光器として使用できます。長く押すとライトが暗くなり、短く押すとオンまたはオフになります。調光機能の速度と光の最大値はユーザーが設定できます。スイッチを設定時間以上押すと調光機能が作動します。光の出力が明るさになります。 2つ目のライトがありますが、簡単なスイッチでのみオン\/オフを切り替えることができます。 プロジェクト例 ステップ0: 準備作業 " }, 
{ "title" : "ステップ0: 準備作業 ", 
"url" : "ac_example_s0_preliminaries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ チュートリアル \/ 例: 最初のステップ \/ ステップ0: 準備作業 ", 
"snippet" : "まず、新しいプロジェクトを作成する必要があります。これがコマンドの目的です 新しいプロジェクト 「メニューから」 ファイル を選択し、新しいプロジェクトを保存しました。ビューで POU ライブラリマネージャーを追加する必要があります。そうすれば、図書館は、 AC_ModuleBase 、パッケージの一部です CODESYS Application Composer ライブラリマネージャーに追加されます。 ライブラリ「AC_ModulBase」を追加 ステップ 1: 最上位モジュール「Room」の作成...", 
"body" : "まず、新しいプロジェクトを作成する必要があります。これがコマンドの目的です 新しいプロジェクト 「メニューから」 ファイル を選択し、新しいプロジェクトを保存しました。ビューで POU ライブラリマネージャーを追加する必要があります。そうすれば、図書館は、 AC_ModuleBase 、パッケージの一部です CODESYS Application Composer ライブラリマネージャーに追加されます。 ライブラリ「AC_ModulBase」を追加 ステップ 1: 最上位モジュール「Room」の作成 " }, 
{ "title" : "ステップ 1: 最上位モジュール「Room」の作成 ", 
"url" : "ac_example_s1_create_toplevel_room.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ チュートリアル \/ 例: 最初のステップ \/ ステップ 1: 最上位モジュール「Room」の作成 ", 
"snippet" : "の中に POU プール、モジュール宣言、ファンクションブロックが追加されます。ファンクションブロックは、モジュールの実装（機能プログラム）に使用されます。この例では、モジュールとファンクション ブロックに次の名前が付けられます。 Room 。さらに、ファンクションブロックは基本タイプでなければなりません。 AC.Module ライブラリの一部を展開します AC_ModuleBase 広範なプロパティとメソッドを提供します。 Function ブロックで作成されたすべてのプロパティと関数はこの例には必要ないため、削除できます。 ファンクションブロックとモジュールを追加する 宣言はキーワードで始ま...", 
"body" : "の中に POU プール、モジュール宣言、ファンクションブロックが追加されます。ファンクションブロックは、モジュールの実装（機能プログラム）に使用されます。この例では、モジュールとファンクション ブロックに次の名前が付けられます。 Room 。さらに、ファンクションブロックは基本タイプでなければなりません。 AC.Module ライブラリの一部を展開します AC_ModuleBase 広範なプロパティとメソッドを提供します。 Function ブロックで作成されたすべてのプロパティと関数はこの例には必要ないため、削除できます。 ファンクションブロックとモジュールを追加する 宣言はキーワードで始まります MODULE その後にモジュール名と IMPLEMENTED_BY およびモジュールを実装する機能ブロック。この特定のケースでは、これは汎用モジュールです。 Room 。ほとんどの場合、これがこのセクションになります MetaData と宣言した。すべてのパラメータとセクションに関する詳細情報は、次の場所にあります。 モジュール宣言 。 そこには 部屋 この例ではトップレベルのモジュールで、次はセクションです。 Toplevel と宣言した。ここには、グローバル変数リストの名前が入力されています( GVL_name ) 生成後のトップレベル関数ブロックのインスタンス名が含まれます。その後、最上位セクションで少なくとも 1 つのタスクを定義する必要があります。この例ではこれです Standart_Task 、これは MEDIUM - タスクが定義され、フラグが設定される CREATE_IF_MISSING そして UPDATE_IOS が含まれています。 モジュールの宣言 Room 説明とアイコン (パラメータ) のプレースホルダーとして使用されるすべてのアイコンとテキスト Desc 、 Icon_16 そして Icon_32 )、テキスト リストと画像コレクションに保存する必要があります。したがって、対応するテキストリストが作成されます TL そして画像集 IP の中に POU 参照されたアイコンとテキストを含むプールが作成されました テキストリストと画像コレクションを追加 ステップ 2: 「Switch」サブモジュールの作成 " }, 
{ "title" : "ステップ 2: 「Switch」サブモジュールの作成 ", 
"url" : "ac_example_s2_create_sublevel_switch.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ チュートリアル \/ 例: 最初のステップ \/ ステップ 2: 「Switch」サブモジュールの作成 ", 
"snippet" : "次のステップは、部屋のスイッチ用のモジュールを作成することです。これを行うには、モジュール宣言とファンクション ブロックを再度作成する必要があります。どちらもそうします Switch が呼び出され、その宣言は関数ブロックによって実装される必要があります。のモジュール宣言 Switch モジュールの下にあるため、トップレベルのセクションは必要ありません Light (後述) は最上位の位置には追加されません。モジュールを実装するすべての関数ブロックと同様に、関数ブロックも次のことを行う必要があります。 Switch の AC.Module 拡大する。この例では、関数ブロックはインターフェイスも実...", 
"body" : "次のステップは、部屋のスイッチ用のモジュールを作成することです。これを行うには、モジュール宣言とファンクション ブロックを再度作成する必要があります。どちらもそうします Switch が呼び出され、その宣言は関数ブロックによって実装される必要があります。のモジュール宣言 Switch モジュールの下にあるため、トップレベルのセクションは必要ありません Light (後述) は最上位の位置には追加されません。モジュールを実装するすべての関数ブロックと同様に、関数ブロックも次のことを行う必要があります。 Switch の AC.Module 拡大する。この例では、関数ブロックはインターフェイスも実装します。 ISwitch 、まだ作成する必要があります。このインターフェイス自体がインターフェイスである必要があります IModule ライブラリからどれを実装するか AC_ModuleBase 供給される。インターフェース ISwitch ただし、プロパティや関数は宣言されていないため、「空」のままです。 さらに、スイッチが押されたことを検出するには、入力信号 (通常は外部信号\/物理スイッチから) が必要です。この信号はセクションにあります IO 変数が宣言されている場合、 xIn このモジュールを実装するファンクションブロックの機能が使用されます。さらに、スイッチの 2 つの機能を区別するには基準時間が必要です。 スイッチを押し続ける時間 tTimer 調光機能が開始されます。短く押すとライトがオンまたはオフになります。変数 tTimer (モジュール実装関数ブロックからも) モジュールのパラメータとして使用されます (セクション Parameter ) が定義されており、後でモジュールを使用するときに簡単に編集できます。 サブモジュールの宣言 Switch 参照される変数 xIn そして tTimer 両方とも機能ブロックの入力です Switch 宣言されているため、パラメータは tTimer 500 ミリ秒の初期化値が定義されています。したがって、ファンクションブロックの入力が Switch 500ms以上押すとランプが暗くなります。 ファンクションブロックでの宣言 Switch‘ 入力とパラメータの必要な説明を指定するには、テキスト リストと画像コレクションも展開する必要があります。 テキストリストと画像コレクションのエントリ ステップ 3: 「Switch simple」サブモジュールの作成 " }, 
{ "title" : "ステップ 3: 「Switch simple」サブモジュールの作成 ", 
"url" : "ac_example_s3_create_sublevel_switchsimple.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ チュートリアル \/ 例: 最初のステップ \/ ステップ 3: 「Switch simple」サブモジュールの作成 ", 
"snippet" : "2 番目に作成するスイッチ モジュールは、オンとオフの 2 つの状態を持つ単純なスイッチです。これを行うには、モジュール宣言と関数ブロックを作成する必要があります。これらは調光スイッチで調整できます。ファンクションブロック用に新しいインターフェースが作成されます ISwitchSimple 使用済み。もう 1 つの違いは、変数 xIn BOOL およびパラメータとして宣言する必要があります tTimer は必要ありません。 ステップ 4: 「ライト」サブモジュールの作成...", 
"body" : "2 番目に作成するスイッチ モジュールは、オンとオフの 2 つの状態を持つ単純なスイッチです。これを行うには、モジュール宣言と関数ブロックを作成する必要があります。これらは調光スイッチで調整できます。ファンクションブロック用に新しいインターフェースが作成されます ISwitchSimple 使用済み。もう 1 つの違いは、変数 xIn BOOL およびパラメータとして宣言する必要があります tTimer は必要ありません。 ステップ 4: 「ライト」サブモジュールの作成 " }, 
{ "title" : "ステップ 4: 「ライト」サブモジュールの作成 ", 
"url" : "ac_example_s4_create_sublevel_light.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ チュートリアル \/ 例: 最初のステップ \/ ステップ 4: 「ライト」サブモジュールの作成 ", 
"snippet" : "スイッチの場合と同様に ( Switch ) とシンプルなスイッチ ( SwitchSimple ) モジュールには必須です Light 「モジュール宣言」 Light 、ファンクションブロック Light そしてインターフェース ILight 作成されます。モジュールはファンクション ブロックによって実装され、ファンクション ブロックによってインターフェイスが作成されます。 ILight 実装されました。 モジュールへ Light モジュールの下にある Room 追加できるようにするには、次のモジュール宣言を追加します。 Room セクション付き Slots 拡大される。このセクションはサブ...", 
"body" : "スイッチの場合と同様に ( Switch ) とシンプルなスイッチ ( SwitchSimple ) モジュールには必須です Light 「モジュール宣言」 Light 、ファンクションブロック Light そしてインターフェース ILight 作成されます。モジュールはファンクション ブロックによって実装され、ファンクション ブロックによってインターフェイスが作成されます。 ILight 実装されました。 モジュールへ Light モジュールの下にある Room 追加できるようにするには、次のモジュール宣言を追加します。 Room セクション付き Slots 拡大される。このセクションはサブセクションになります Slot_Multi どちらかを宣言します Lights 呼び出されるモジュールとそのタイプのモジュール Light 対応できます。部屋に追加する必要がある、または追加できるライトの数は、パラメータによって決まります。 Cardinality 定義されています（この例ではライトが 1 ～ 3 つの間）。さらに、次の 2 つの変数を定義する必要があります。 Variable ( pLights 、部屋の照明モジュールの機能ブロック インスタンスを記述します)、および Var_Count ( uiNumberOfLights 、部屋の照明の数を表します)。 セクションの定義 Slots 変数 pLights そして uiNumberOfLights 「Lights」モジュールの機能ブロックに追加する必要があります。 uiNumberOfLights ある UINT そして pLights タイプの POINTER TO ILight は。この定義では、モジュールのみをスロットに挿入できます。 Lights 追加される機能ブロックにはインターフェースも含まれます ILight 実装する。 ファンクションブロックでの宣言 Room モジュールと同じスロットコンセプト Room 「使用されていたものはモジュールに使用されるようになりました」 Light 使用済み。したがって、次の宣言は、 Light 1つのスロット Switch , そのため、このスロットはマルチスロットではなく、シンプルなスロットです。モジュールの追加パラメータ Light 調光器の速度です rSpeed そして最大の明るさ uiMaxValue 。最後に、関連する光の明るさを表す出力を定義する必要があります。すべてのパラメータ、スロット、出力もモジュールの機能ブロックに変数として含める必要があります。 Light 追加されます。 モジュールの宣言 Light ファンクションブロックの宣言 Light テストリストと画像集 ステップ 5: 「Light simple」サブモジュールの作成 " }, 
{ "title" : "ステップ 5: 「Light simple」サブモジュールの作成 ", 
"url" : "ac_example_s5_create_sublevel_lightsimple.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ チュートリアル \/ 例: 最初のステップ \/ ステップ 5: 「Light simple」サブモジュールの作成 ", 
"snippet" : "現在生成されている簡易ライトは簡易スイッチと連動していますが、 Light 採用され、適応されました。これには、新しいモジュール宣言と新しい関数ブロックが必要です。 LightSimple 生成される。ファンクションブロックがインターフェースなので ILight 実装すると、後でさまざまなタイプのライトを部屋に追加できます。主な違いは、 Light スロットの変数が次のタイプであることです。 ISwitchSimple モジュールへの誤った切り替えがないようにする必要があります LightSimple を追加することができます。さらに、の出力は、 LightSimple タイプの BOOL 彼...", 
"body" : "現在生成されている簡易ライトは簡易スイッチと連動していますが、 Light 採用され、適応されました。これには、新しいモジュール宣言と新しい関数ブロックが必要です。 LightSimple 生成される。ファンクションブロックがインターフェースなので ILight 実装すると、後でさまざまなタイプのライトを部屋に追加できます。主な違いは、 Light スロットの変数が次のタイプであることです。 ISwitchSimple モジュールへの誤った切り替えがないようにする必要があります LightSimple を追加することができます。さらに、の出力は、 LightSimple タイプの BOOL 彼と名前 xSwitchedOn 持っている。 ステップ 6: 実装 " }, 
{ "title" : "ステップ 6: 実装 ", 
"url" : "ac_example_s6_implementation.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ チュートリアル \/ 例: 最初のステップ \/ ステップ 6: 実装 ", 
"snippet" : "スイッチ モジュールの機能実装用 Switch 方法になります CallPrioMediumStart から Module 使用され、独自の実装で上書きされます。この関数が選択される理由は、モジュール Room 仕事 MEDIUM と宣言されています。つまり、これはメソッドが CallPrioMediumStart ファンクションブロックの Switch 中間タスクのサイクルごとに自動的に呼び出されます。より詳細な情報は、サンプル プロジェクト自体に記載されています。スイッチの主な機能は、スイッチングと調光を区別することです。スイッチを押すと、ユーザーパラメータで指定できる時間でタイマーが開始...", 
"body" : "スイッチ モジュールの機能実装用 Switch 方法になります CallPrioMediumStart から Module 使用され、独自の実装で上書きされます。この関数が選択される理由は、モジュール Room 仕事 MEDIUM と宣言されています。つまり、これはメソッドが CallPrioMediumStart ファンクションブロックの Switch 中間タスクのサイクルごとに自動的に呼び出されます。より詳細な情報は、サンプル プロジェクト自体に記載されています。スイッチの主な機能は、スイッチングと調光を区別することです。スイッチを押すと、ユーザーパラメータで指定できる時間でタイマーが開始されます。タイマーが期限切れになり、スイッチがまだ押されている場合、調光機能が使用されます。これは変数によっても示されます。 XPushLong 示されています。変数 xPush になる TRUE スイッチを短く押しただけの場合。両方の変数について xPushLong そして xPush どちらも機能ブロック内にあります Switch インターフェースでも同様に ISwitch 親ライト機能ブロックで使用できるようにプロパティを追加しました。 ライト ファンクションブロックも Light メソッドをオーバーライドします CallPrioMediumStart 。関連付けられた変数の入力変数に応じて、ライトは「オン」または「オフ」に減光されるか、単に切り替えられます。調光器の場合、宣言されたパラメータの速度値 rSpeed 使用済み。調光値の最大値または最小値に達すると、調光は終了します。ライトが暗い状態でスイッチを押すとライトが消えます。 (完全な実装はサンプル プロジェクトで確認できます) プログラムコードをチェックする 実装したら、次のコマンドを実行して宣言を行う必要があります。 翻訳する チェックされる。エラーが表示されなければ、宣言はOKです。 ステップ 7: モジュールを組み立てる " }, 
{ "title" : "ステップ 7: モジュールを組み立てる ", 
"url" : "ac_example_s7_composing_modules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ チュートリアル \/ 例: 最初のステップ \/ ステップ 7: モジュールを組み立てる ", 
"snippet" : "すべての宣言のチェックが成功すると、すべてのモジュールをさらに使用できるようになり、サンプル アプリケーションをアセンブルできるようになります。これを行うには、モジュールをプロジェクトのモジュール ツリーに追加します。これにはビューが必要です モジュール 開かれる。 最初のステップはトップレベルのモジュールです Room モジュールツリーに追加されました。 最上位モジュールをモジュール ツリーに追加する それから開きます モジュールダイアログ すべてのトップレベルのモジュールを提供します。このダイアログには、画像コレクションで定義された関連アイコンとテキスト リストのテキストが表示されます。こ...", 
"body" : "すべての宣言のチェックが成功すると、すべてのモジュールをさらに使用できるようになり、サンプル アプリケーションをアセンブルできるようになります。これを行うには、モジュールをプロジェクトのモジュール ツリーに追加します。これにはビューが必要です モジュール 開かれる。 最初のステップはトップレベルのモジュールです Room モジュールツリーに追加されました。 最上位モジュールをモジュール ツリーに追加する それから開きます モジュールダイアログ すべてのトップレベルのモジュールを提供します。このダイアログには、画像コレクションで定義された関連アイコンとテキスト リストのテキストが表示されます。これで、「Room」モジュールを選択してモジュール ツリーに追加できるようになります。 「モジュールの追加」ダイアログ ダブルクリックできるようになりました Room 最上位モジュールのエディタはモジュール ツリーで開くことができます。レジスター内 Toplevel コード生成にはターゲット アプリケーションを選択する必要があります。現場で 標準タスク モジュール宣言で定義されたタスクが表示されます。 「ルーム」モジュールの設定 上記の手順と同様に、サブモジュールを使用できるようになります。 Light モジュールツリーに追加されます。ルームのモジュール宣言のマルチスロット定義により、最大 3 つのライトを追加できます。レジスター内 Parameter モジュールの編集者 Light の値はできますか maxLightValue そして Speed パラメータ化される。 I\/O エディタでは、出力が例に使用されます。 Brightness ローカル変数 uiBrightness 割り当てられました。 「ライト」モジュールの設定 新しく追加された以下 Light これでモジュールになります Switch 追加した。モジュールエディターで Switch モジュール宣言で指定されたすべてのパラメータと I\/O が使用可能です。この例では、ローカル変数 xPushSwitch 入力変数 xIn 割り当てられました。単純なライトの出力はローカル変数になります xSimpleOn 一緒に結ばれた。 「Switch」モジュールの設定 例の最後のステップでは、単純なライト ( LightSimple ) とシンプルなスイッチ ( SwitchSimple ) モジュールツリーに追加されました。単純なライトの出力はローカル変数を使用します xSimpleOn 変数を使用した単純なスイッチの入力 xPushSimpleSwitch 一緒に結ばれた。 モジュールツリーの構造例 最後にコマンドでプロジェクトが完了します 生成する 生成された。デバイスにダウンロードした後、次の値を変更することで例を変更できます。 xPushSwitch テストされる。調光中の値は、 ui明るさ ゆっくりと変化して切り替えると、値は直接 0 または最大値に設定されます。の変化 xPushSimpleSwitch 関連するライトの出力を直接切り替えます。 最後のステップであるモジュールのアセンブルは、生成されたコードの機能を失うことなく、任意の組み合わせで実行できることにも注意してください。 " }, 
{ "title" : "ライブラリ: メカトロニクス ", 
"url" : "ac_mechatronics_example.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュールエディタ \/ チュートリアル \/ ライブラリ: メカトロニクス ", 
"snippet" : "図書館 Mechatronics これは、逐次プロセスを使用したメカトロニクス ユニットの単純な (完全ではない) 実装の例として意図されています。完全なメカトロニクス アプリケーションに必要なすべての要件を満たしているわけではありません。むしろ、このタイプのアプリケーションの導入または基礎となることを目的としています。 提示されたメカトロニクス モデルの中核は、次のモジュール構造に基づいています。 アプリケーションコンポーザの例 Mechatronics 各マシンは、たとえばそれぞれがグリッパーを表す複数のメカトロニクス サブアセンブリで構成されていると想定されます。サブアセンブリは、アクチ...", 
"body" : "図書館 Mechatronics これは、逐次プロセスを使用したメカトロニクス ユニットの単純な (完全ではない) 実装の例として意図されています。完全なメカトロニクス アプリケーションに必要なすべての要件を満たしているわけではありません。むしろ、このタイプのアプリケーションの導入または基礎となることを目的としています。 提示されたメカトロニクス モデルの中核は、次のモジュール構造に基づいています。 アプリケーションコンポーザの例 Mechatronics 各マシンは、たとえばそれぞれがグリッパーを表す複数のメカトロニクス サブアセンブリで構成されていると想定されます。サブアセンブリは、アクチュエータ (メカトロニクス ユニット自体で構成されますが、その機能実装や I\/O 管理も含みます) とプログラム マネージャーに分割されます。プログラム マネージャーは、メカトロニクス サブアセンブリのさまざまな状態を管理することを目的としています。 Idle - または Execute -状態。最終的に、これらの状態は、アクチュエータを動かしたり、その他の必要な機能を実行したりするプログラム シーケンスによってライブラリ内で表現されます。 この時点で、さまざまな部分について簡単に詳細に説明します。ライブラリを使用する場合、多くの場合、独自のアクチュエータ、プロセス ステップ、またはプログラム シーケンスを実装する必要がありますが、これについてもここで説明します。 俳優 アクチュエーターであると考えられるすべてのモジュールは、インターフェースとなる機能ブロックによって実装する必要があります。 IActuator 実装されました。このインターフェイスにはメソッドやプロパティがなく、モジュールの互換性の理由でのみ使用されます (ドキュメントを参照してください) IActuator 図書館で）。アクチュエーターの実装にはルールや制限がないため、そのようなアクチュエーターの移動またはアクティブ化は個別に行う必要があります。これは通常、アクチュエータを基準スロットに収容し、シーケンスの一部として望ましい方法でアクチュエータを移動できるシーケンス ステップ モジュールを実装することによって実現されます（たとえば、追加のインターフェイスを使用して実装されます）。 プロセスのステップ プロセスステップを関数ブロックの派生クラスとして実装することを強くお勧めします。 StepBase 実行する。これにより、インターフェイスの必要な基本実装がすべて提供されます。 IProgramSequenceStep 利用可能。次のドキュメントを参照してください。 IActuator 図書館で。基本クラスを使用する場合 StepBase 必要なのはメソッドだけです Execute 実装する。後者は、変数が終了するまでプログラム フローによって周期的に呼び出されます。 xDone 基本クラス TRUE が設定されています。さらに、それぞれのプロセスステップがアクティブである限り、フラグは xActive の上 TRUE 悩ませる。アクチュエータへの接続は、任意の方法で実装できます (たとえば、推奨されるリファレンス スロットを介して (1 を参照))。 プログラムシーケンス \/ プログラムマネージャー プログラム シーケンスは、状態を表すプログラム マネージャーのサブモジュールです。これらの状態は、OMAC ステート マシンの形式で管理されます。これらの実装もやはり「Execute」メソッドに基づいています (詳細については、ライブラリの実装を参照してください)。ただし、ほとんどの場合、ユーザーがそのようなプログラム フローを実装する必要はありません。ただし、ステート マシンの動作がプログラム マネージャーに実装され、それによってプログラム シーケンスが実行される方法については、ここで簡単に説明します。 状態には、実行状態 (「ing」で終わる) と待機\/デュアル状態 (残り) の 2 種類があります。待機状態は外部コマンドによって終了しますが、実行状態は実行後に終了します。使用可能なコマンドは、プログラム マネージャーの現在のステータスによって異なります。 OMAC ステータス図は、簡単な概要を示しています。 OMAC図 モジュール MovableBarrier モジュール MovableBarrier 関連する機能ブロックは次のように実装されます。 MovableBarrier 作成したインターフェースを実装します IMovableBarrier 。このインターフェースは、(比喩的な) 保護フードを移動するためのメソッドを定義します。 IMovableBarrier 今度はインターフェース IActuator モジュールが MovableBarrier メカトロニクス アセンブリの下のモジュール ツリーでアクチュエータとして使用できます。 モジュールの実装 MovableBarrier このアクチュエータ「MovableBarrier」はフローステップモジュールによって作成されます MoveBarrierForTime 移動は次の方法で実装されます。 モジュールの実装 MoveBarrierForTime モジュールを実装する機能ブロック MoveBarrierForTime 基本的な機能ブロックから単純に派生します AC_MEC.StepBase それはライブラリに含まれています。これは関数ブロックを実装します MoveBarrierForTime すでにインターフェース IProgramSequenceStep 。その結果、モジュールは次のことが可能になります。 MoveBarrierForTime プログラムシーケンスの下にプロセスステップとして挿入できます。ファンクションブロックの機能実装 MoveBarrierForTime モジュールの参照スロットを定義することにより、 MoveBarrierForTime 、インターフェースが実装されたアクチュエーターを備えています。 IMovableBarrier 対応できる場合は、既存の「MovableBarrier」アクチュエーターに接続します。このアクチュエータの動きは最終的には機能で行われます。 Execute ファンクションブロックの MoveBarrierForTime 、これは単に保護フードを（比喩的に）移動するためのメソッドを呼び出します。このメソッドは参照アクチュエータによって使用されます。 IMovableBarrier 実装され、利用可能になります。なお、物件は、 Done そして変数 xActive TONEと組み合わせることで「動き」の機能ブロックを実現 IMovableBarrier 指定された時間 (TON) が経過するまで周期的に呼び出され、その後 Done TRUEに設定し、 xActive は FALSE に設定されます。物件 Done インターフェースの一部です IProgramSequenceStep したがって、プロセスの次のステップを実行する必要があることを上位レベルのプログラム フローに報告します。 プロセスステップの独自の実装とは別に、 AC_Mechatronics.library 一般的な論理演算に使用できる、事前に実装されたいくつかのステップが利用可能です。例えばステップになります BranchOnBool これには 2 つのサブステップ\/分岐が含まれます。これらのサブステップは、ブール変数の値に応じて実行されます。図書館にもあります AC_Mechatronics.library 並列プロセスのプロセス ステップ、条件付きジャンプや単純な待機ステップ、その他多くのタスクが利用可能です。 " }, 
{ "title" : "モジュール宣言エディター ", 
"url" : "ac_module_declaration_editor_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター ", 
"snippet" : "モジュールは通常、メカトロニクス コンポーネントを表しますが、純粋なソフトウェア機能である場合もあります。これには、 CODESYS カバーされる。 モジュールにはインターフェースとなる機能ブロックがあります。 IModule 図書館から AC_ModuleBase 実装されました。モジュールには、サブモジュール、パラメータ化、I\/O 要件、タスクの割り当て、視覚化に関する情報が含まれています。モジュールは、 CODESYS Application Composer を表します。 の CODESYS Application Composer ダイアログ内のテンプレート プロジェクトを提供します...", 
"body" : "モジュールは通常、メカトロニクス コンポーネントを表しますが、純粋なソフトウェア機能である場合もあります。これには、 CODESYS カバーされる。 モジュールにはインターフェースとなる機能ブロックがあります。 IModule 図書館から AC_ModuleBase 実装されました。モジュールには、サブモジュール、パラメータ化、I\/O 要件、タスクの割り当て、視覚化に関する情報が含まれています。モジュールは、 CODESYS Application Composer を表します。 の CODESYS Application Composer ダイアログ内のテンプレート プロジェクトを提供します 新しいプロジェクト を選択することができます。このテンプレートは、POU プールにデバイス、アプリケーション、ライブラリ マネージャーを含むプロジェクトを作成します。このライブラリ マネージャーにはライブラリが含まれています AC_ModuleBase そして AC_Persistence 。プロジェクトに参加している人たち ComposerProject.project ベースのテンプレートは必要に応じて変更できます。 「Templates」サブフォルダー内にあります CODESYS インストールディレクトリ。 既存の機能ブロックからモジュールを自動的に作成できます。可能な限り、既存の宣言がモジュール宣言に含まれます。詳細については、コマンドの説明を参照してください FBからモジュールを作成 。 その章では モジュール宣言 モジュールの開発方法について詳しく説明します。 異なるアプリケーション間のデータ交換に関する情報は、次の章に記載されています。 IRMPサービス 。 " }, 
{ "title" : "モジュール宣言 ", 
"url" : "ac_module_declaration.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 ", 
"snippet" : "モジュールの宣言は、構造化テキスト (ST) コードでの変数の宣言に似た独自の記述言語を使用して行われます。 モジュール宣言のセクション セクション: メタデータ セクション: トップレベル セクション: IO セクション: パラメータ セクション: スロット セクション: ビジュアル セクション: プロキシ セクション: VarArray セクション: 制約 セクション: InstRef セクション: mse.Sequence デバイスジェネレーターアラームアラーム...", 
"body" : "モジュールの宣言は、構造化テキスト (ST) コードでの変数の宣言に似た独自の記述言語を使用して行われます。 モジュール宣言のセクション セクション: メタデータ セクション: トップレベル セクション: IO セクション: パラメータ セクション: スロット セクション: ビジュアル セクション: プロキシ セクション: VarArray セクション: 制約 セクション: InstRef セクション: mse.Sequence デバイスジェネレーターアラームアラーム" }, 
{ "title" : "モジュール宣言の形式 ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_48fab9ed86f6686ac0a8640e00dcb86d", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ モジュール宣言の形式 ", 
"snippet" : "フォームのヘッダー MODULE<name> 宣言が始まります。これに「セクション」のリストが続きます。 各セクションをキーワードで紹介 SEC (「セクション」の場合) および一意の名前。キーワード END_SEC セクションを閉じます。セクションの内容には、さらなるセクションまたはいわゆる定義で構成されるエントリのリストが含まれています。 定義は名前とオプションの値で構成され、セミコロンで終わります。 コメントは ST コードと同様に使用できます。単一行コメントの場合は「\/\/」、複数行コメントの場合は「(*」および「*)」です。各部分の区切りには空白 (タブとスペース) と改行\/改行を使用...", 
"body" : "フォームのヘッダー MODULE<name> 宣言が始まります。これに「セクション」のリストが続きます。 各セクションをキーワードで紹介 SEC (「セクション」の場合) および一意の名前。キーワード END_SEC セクションを閉じます。セクションの内容には、さらなるセクションまたはいわゆる定義で構成されるエントリのリストが含まれています。 定義は名前とオプションの値で構成され、セミコロンで終わります。 コメントは ST コードと同様に使用できます。単一行コメントの場合は「\/\/」、複数行コメントの場合は「(*」および「*)」です。各部分の区切りには空白 (タブとスペース) と改行\/改行を使用できます。それ以外の場合は、以降の処理中に無視されます。 ST コードと同様、大文字と小文字の区別は関係ありません。 次の例では、モジュール宣言の要素について説明します。 01 MODULE Persistence IMPLEMENTED_BY PersistenceFB\n02 SEC MetaData\n03 NAME := TL.ChannelName ;\n04 DESC := TL.ChannelDesc ;\n05 COLLECTION CATEGORY := ’Persistence’TL.Collection ;\n06 ICON_16 := IP.Channel16 ;\n07 ICON_32 := IP.Channel32 ;\n08 END_SEC\n09 SEC Toplevel\n10 SEC STANDARD_TASK : LOW\n11 NAME := LOW ;\n12 DESC := TL.TaskLow ;\n13 FLAGS := CREATE_IF_MISSING | READONLY ;\n14 END_SEC\n15 GVL_NAME := 'GVL_%InstanceName%' ;\n16 END_SEC 01行目にはモジュール名「Persistence」の定義があります。 IMPLEMENTED_BY モジュールのロジックを含む関数ブロック「PersitenceFB」を定義します。この関数ブロックは次から派生する必要があります。 IModule 。 02 行目のセクション MetaData このセクションには 5 つの定義が含まれています。ネストされたセクションの可能性は、セクションに示されています。 Toplevel (行 09 ～ 16) にはサブセクションが含まれています STANDARD_TASK (10行目)。 " }, 
{ "title" : "モジュール宣言の構文 ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_819a1c8e627d0b32c0a8640e01623943", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ モジュール宣言の構文 ", 
"snippet" : "このセクションでは、モジュール宣言の構文と許可される構文構造について説明します。 次のスキャナーでは、トークンは大文字で書かれます (例: ID ）。文法の非終端は中括弧で書かれます (例: {Entry} ）。 字句解析（スキャナー） 最初のステップでは、いわゆるトークン (または語彙素) がモジュール宣言の文字 (例: キーワード、定数、識別子) から作成されます。 空白文字と改行\/改行文字はトークンを区切りますが、それ以外の場合は無視されます。コメントも、宣言の今後の処理では無視されます。 (コメントは一行で記述できます( \/\/ \") または複数行のコメント ( (* そして *) ) ...", 
"body" : "このセクションでは、モジュール宣言の構文と許可される構文構造について説明します。 次のスキャナーでは、トークンは大文字で書かれます (例: ID ）。文法の非終端は中括弧で書かれます (例: {Entry} ）。 字句解析（スキャナー） 最初のステップでは、いわゆるトークン (または語彙素) がモジュール宣言の文字 (例: キーワード、定数、識別子) から作成されます。 空白文字と改行\/改行文字はトークンを区切りますが、それ以外の場合は無視されます。コメントも、宣言の今後の処理では無視されます。 (コメントは一行で記述できます( \/\/ \") または複数行のコメント ( (* そして *) ) ST 言語と同様です。複数行のコメントは入れ子にすることができます。 基本的に、トークンには常に最大長があります。例えば a123 識別子としてではなく識別子として解釈されます a 続いてリテラル 123 。 以下のリスト内のトークンの順序は、その優先度を示しています。たとえば入力 MODULE は識別子ではなくキーワードとして理解されます。 利用可能なすべてのトークンのリスト: キーワード: MODULE 、 SEC 、 END_SEC 、 IMPORTS 、 そして IMPLEMENTED_BY OP: 次の文字の空でないシーケンス: .:,%()[]{}<>|+-*\/@!?^°=\\~ 注: コメント マーカー \/\/ 、 (* そして *) 演算子よりも優先度が高くなります。一方、コメントは演算子内で始めることはできません。たとえば、 +\/\/+ 、最大長のルールに従って、演算子としてではなく演算子として読み込まれます。 + コメントが続きます。 LIT: ST で使用される IEC リテラル。例: 1.4 、 tod#12:13:14 。これにはブール値リテラルが含まれます TRUE そして FALSE (大文字または小文字は関係ありません)。 注: 型なしリテラルの前に負符号 ( -1 、 -3.2 ) は 2 つのトークン、つまり演算子として読み込まれます。 - その後に型なしリテラルが続きます。したがって、型なしの数値リテラルは決して負になりません。型付きリテラル ( INT#-34 ) は常にトークンとして読み取られます。 ID: 有効な IEC 識別子 ( [a-zA-Z_][a-zA-Z0-9_]* )、2 つの連続した下線は許可されません。これには、ST とは対照的に、ST のキーワードも含まれます (つまり: FUNCTION 、 INT 、 EXTENDS 、…） セミコロン: 文字 ; 構文 (パーサー) モジュール宣言の構文は次の文法で定義されます。 µ は空のシーケンスです。 {MDecl} ::= MODULE {QID} {ImplSpec} {ImportsSpec} {MBody}\n{ImplSpec} ::= IMPLEMENTED_BY {QID} | µ\n{ImportsSpec} ::= IMPORTS {QID} | µ\n{MBody} ::= {SecList}\n{SecList} ::= {Modifiers} {Sec} {SecList} | µ\n{Sec} ::= SEC {QID} {SecTarget} {EntryList} END_SEC\n{SecTarget} ::= OP(\":\") {QID} | µ\n{Modifiers} ::= OP(\"[\") {ModifierList} OP(\"]\") | µ\n{ModifierList} ::= {QID} OP(\",\") {ModifierList} | {QID}\n{EntryList} ::= {Modifiers} {Entry} {EntryList}\n{Entry} ::= {Sec} | {Def}\n{Def} ::= {QID} OP(\":=\") {ValList} SEMICOLON |\n {QID} SEMICOLON\n{ValList} ::= {Val} {ValList} | {Val}\n{Val} ::= ID | LIT | OP\n{QID} ::= ID | ID OP(\".\") {QID} 定義値のリスト ( {ValList} ) はセミコロンで完了する必要があります。これにより、文法が簡素化され、曖昧さが回避されます。これは、セミコロンを値の一部にすることができないためです ( {VAL} )、文字列リテラル内を除く。 代入演算子 ( := ) の定義 ( {Def} ) 曖昧さを避けるのにも役立ちます ( {QID} ) の定義名と値。 定義の定義済みタイプ テキスト: ID.ID (テキスト リスト名およびテキスト リスト識別子) - を参照してください。 テキストリスト文字列のローカライズ 画像：ID.ID（イメージプール名とイメージプール識別子） ID（IEC識別子） QID (修飾された識別子): {QID} ::= ID | ID.ID CategoryPath ::= {StringLiteral} | {CategoryPath} カーディナリティ: [{MIN} .. {MAX}] | [ {MIN} .. INF [ {MIN} 、 そして {MAX} は整数の非負のリテラルです。もし {MAX} != INF 、 それから {MIN} <= {MAX} 申請しなければなりません。 StringLiteral: IEC 文字列リテラルには改行が含まれる場合があります。 StdTaskFlags ::= {StdTaskFlag} | {StdTaskFlags} StdTaskFlag ::= NONE | CREATE_IF_MISSING | READONLY リテラル: 任意の IEC リテラルまたは QID (Enum 定数の場合) DTBoolフラグ: µ (空のシーケンス) | TRUE | FALSE スロットタイプ: SUBMODULE | REFERENCE プラグマ: [ {PragmaList} ] {PragmaList} ::= {Pragma} | {Pragma} , {PragmaList} {Pragma} ::= { ( ID | {StringLiteral} | {OP2} )+ } {OP2} : を除くすべての演算子 {, }, [, ] そして , 。 インスタンスパス: InstancePath ::= {IComp} | {IComp} . {IComp} ミット {IComp} ::= ID {ArrayAccess}* と {ArrayAccess} ::= [ {IntList} ] と {IntList} ::= Int | Int , {IntList} タスク参照: Standard_Task。 ( Low | Medium | High ) | Custom_Task.ID " }, 
{ "title" : "インスタンスパス ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_e00dd4f26a1882aec0a8652000c0a4ae", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ インスタンスパス ", 
"snippet" : "モジュール宣言の一部の位置では、関数ブロックの変数をアドレス指定するためにインスタンス パスを定義できます。パラメータ、スロット、I\/O、可変サイズの配列、およびインスタンス参照の場合です。 インスタンス パスは、ドットで区切られた空でないコンポーネントのシーケンスとして定義されます。 C1.C2…CN 。コンポーネントは、IEC 識別子、またはその後にインデックス式が続くコンポーネントである必要があります。 [i1, …, iN] 、 どこ i1 に iN は整数値です。 インスタンス パスは常に、モジュール ロジックを実装する関数ブロックに対して相対的です。インスタンス パスの最初のコンポ...", 
"body" : "モジュール宣言の一部の位置では、関数ブロックの変数をアドレス指定するためにインスタンス パスを定義できます。パラメータ、スロット、I\/O、可変サイズの配列、およびインスタンス参照の場合です。 インスタンス パスは、ドットで区切られた空でないコンポーネントのシーケンスとして定義されます。 C1.C2…CN 。コンポーネントは、IEC 識別子、またはその後にインデックス式が続くコンポーネントである必要があります。 [i1, …, iN] 、 どこ i1 に iN は整数値です。 インスタンス パスは常に、モジュール ロジックを実装する関数ブロックに対して相対的です。インスタンス パスの最初のコンポーネントはメンバー ( VAR_INPUT または VAR_OUTPUT 、ユースケースに応じて）機能ブロックの。インスタンス パスに追加コンポーネントがある場合、これらのコンポーネントはメンバー内の変数に対応します。それ以外の場合は、メンバー自体がアドレス指定されます。インスタンス パスは、入力変数または出力変数に制限できます (例: I\/O の場合)。構造体の場合、これらの制限は無効です。この種のインスタンス パスは、それぞれ入力インスタンス パスと呼ばれます。インスタンスのパスを出力します。 " }, 
{ "title" : "テキストリスト文字列のローカライズ ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_497561d55e22d540c0a8640e01561e3c", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ テキストリスト文字列のローカライズ ", 
"snippet" : "モジュール内のテキスト (例: モジュールの説明、名前、パラメータの説明) をさまざまな言語で表示できます。これらのテキストはテキストリストで管理されます。 言語名の仕様: 言語の名前は次の形式です <LanguageCode>[-<Country\/Region>] （例： en-US 、 de-DE ）。 <LanguageCode> ISO 639-1 に基づく言語の名前です (例: de または en ）。 <Country\/Region> ISO 3166 に準拠した国コードです。 テキスト リスト エントリを取得するとき、システムは最初に言語名全体を検索します。何も見つからない場合は...", 
"body" : "モジュール内のテキスト (例: モジュールの説明、名前、パラメータの説明) をさまざまな言語で表示できます。これらのテキストはテキストリストで管理されます。 言語名の仕様: 言語の名前は次の形式です <LanguageCode>[-<Country\/Region>] （例： en-US 、 de-DE ）。 <LanguageCode> ISO 639-1 に基づく言語の名前です (例: de または en ）。 <Country\/Region> ISO 3166 に準拠した国コードです。 テキスト リスト エントリを取得するとき、システムは最初に言語名全体を検索します。何も見つからない場合は、 <LanguageCode> 。この検索も失敗した場合は、デフォルトのテキストが使用されます。 テキストリスト内の言語名の例 言語 言語の名前 中国語 zh-CHS 英語 en-US フランス語 フランス-フランス ドイツ人 脱DE イタリアの IT-IT 日本語 日本 ポルトガル語 pt-PT ロシア るる スペイン語 エスエス " }, 
{ "title" : "モジュール宣言の導出 ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_a596cccf5e22d542c0a8640e019ddff8", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ モジュール宣言の導出 ", 
"snippet" : "ファンクション ブロック B からのファンクション ブロック A のオブジェクト指向継承 (「EXTENDS」) と同様に、 IMPORTS キーワード。修飾子 UPDATE そして HIDE 特別扱いされている。 次のルールが使用されます。 このモジュールが別のライブラリで定義されている場合は、インポートされたモジュールの名前を名前空間で指定する必要があります。 周期的なインポートは許可されていません。特に、モジュール自体をインポートしてはなりません。 (循環インポートの例: モジュール M_1 がモジュール M_2 をインポートし、M_2 が M_3 をインポートし、…、M_N が M_1...", 
"body" : "ファンクション ブロック B からのファンクション ブロック A のオブジェクト指向継承 (「EXTENDS」) と同様に、 IMPORTS キーワード。修飾子 UPDATE そして HIDE 特別扱いされている。 次のルールが使用されます。 このモジュールが別のライブラリで定義されている場合は、インポートされたモジュールの名前を名前空間で指定する必要があります。 周期的なインポートは許可されていません。特に、モジュール自体をインポートしてはなりません。 (循環インポートの例: モジュール M_1 がモジュール M_2 をインポートし、M_2 が M_3 をインポートし、…、M_N が M_1 を再度インポートします。) 派生モジュールは、 IMPLEMENTED_BY 指令。この場合、基本モジュールの機能ブロックが使用されます。 派生モジュールが関数ブロックを指定している場合 ( MPLEMENTED_BY )、この機能ブロックは基本モジュールの機能ブロックから派生するか、それと同一である必要があります。 派生モジュールは、基本モジュールのすべてのセクションを継承します。新しいセクションを追加したり、既存のセクションを変更したりできます。 派生モジュール内のセクションは、修飾子で拡張された同じ名前とターゲットを使用して変更できます。 UPDATE 。この場合、そのエントリは変更されます。派生モジュール内のセクションの欠落している定義はすべて、基本モジュールから引き継がれます。 修飾子 UPDATE そして HIDE それぞれのセクション (名前とターゲット) が基本モジュールで定義されている場合にのみ使用できます。逆に、ベースモジュールで定義されたセクションは、派生モジュールでのみ使用できます。 HIDE または UPDATE 修飾子。だけあれば HIDE セクション内の修飾子とそうでないもの UPDATE の場合、定義は許可されません。 一部のエントリは派生モジュールで変更する必要があります (例: 説明)。 例： MODULE MBase IMPLEMENTED_BY FBBase\nSEC MetaData\n DESC := TL.Desc_Base ;\nEND_SEC\nSEC Parameters\n SEC Param : paramxIn\n Variable := xIn ;\n Name := TL.Param1_Name ;\n Desc := TL.Param1_Desc ;\n END_SEC\nEND_SEC\n\nMODULE MDerived IMPORTS MBase\n[UPDATE] SEC MetaData\n DESC := TL.Desc_Derived ;\nEND_SEC\n[UPDATE] SEC Parameters\n [UPDATE,HIDE] SEC Param : paramIn\n Variable := xIn ;\n DEFAULT := TRUE ;\n END_SEC\nEND_SEC 上記の例では、パラメータ paramIn モジュールの MBase 派生モジュールに隠されています MDerived (を使用して HIDE 修飾子)、同時に新しいデフォルト値 ( TRUE ）が設定されています。 " }, 
{ "title" : "セクションと定義の順序に関する注意 ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_87237560fda311e1967bf6fe1c17b04f", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクションと定義の順序に関する注意 ", 
"snippet" : "モジュールヘッダーの直後のセクションの順序は関係ありません。セクション内では順序が非常に重要になる場合があります。たとえば、スロット宣言の順序によって、モジュール ツリー内のモジュールの順序が定義されます。 定義の順序は常に無関係です。 順序に関連する派生モジュールのルール: 基本モジュールのセクションは、常にモジュール自体のセクションの前に定義されます。 基本モジュールのセクションが以下を使用して変更された場合 UPDATE または HIDE 、その順序は影響を受けません。 派生モジュールが、基本モジュールで定義されている順序を変更することはできません。...", 
"body" : "モジュールヘッダーの直後のセクションの順序は関係ありません。セクション内では順序が非常に重要になる場合があります。たとえば、スロット宣言の順序によって、モジュール ツリー内のモジュールの順序が定義されます。 定義の順序は常に無関係です。 順序に関連する派生モジュールのルール: 基本モジュールのセクションは、常にモジュール自体のセクションの前に定義されます。 基本モジュールのセクションが以下を使用して変更された場合 UPDATE または HIDE 、その順序は影響を受けません。 派生モジュールが、基本モジュールで定義されている順序を変更することはできません。 " }, 
{ "title" : "オートコンプリートと「コンポーネントのリスト」 ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_23e0e10e3a0c71c9c0a8640e0040f55b", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ オートコンプリートと「コンポーネントのリスト」 ", 
"snippet" : "モジュールエディターで入力を開始すると、使用可能なすべてのセクション定義が「コンポーネントのリスト」メニューに表示されます。現在の位置の意味のあるセクションと定義のみが表示されます。一部のサブセクション エントリが他のセクションのサブセクション エントリと同じ名前である場合でも、一致するセクション定義のみを表示しようとします。 もし 戻る セクションの最初の行を完了した後に を押すと、セクションは必要なすべての定義\/セクションで完了し、 END_SEC 。 変数定義の後、入力\/出力変数は「リスト コンポーネント」定義によって表示されます。フラグまたは事前定義された値は、「リスト コンポーネント...", 
"body" : "モジュールエディターで入力を開始すると、使用可能なすべてのセクション定義が「コンポーネントのリスト」メニューに表示されます。現在の位置の意味のあるセクションと定義のみが表示されます。一部のサブセクション エントリが他のセクションのサブセクション エントリと同じ名前である場合でも、一致するセクション定義のみを表示しようとします。 もし 戻る セクションの最初の行を完了した後に を押すと、セクションは必要なすべての定義\/セクションで完了し、 END_SEC 。 変数定義の後、入力\/出力変数は「リスト コンポーネント」定義によって表示されます。フラグまたは事前定義された値は、「リスト コンポーネント」の選択にも表示され、可能なフラグ\/値が示されます。 テキスト リスト エントリまたはイメージ プール エントリを使用する定義後 (例: ほとんどの場合 Desc := )、すべての利用可能な表示可能なテキスト リストまたは画像プールとそのエントリを含む「リスト コンポーネント」メニューが表示されます。 押すことで F2 、対応する入力サポートを開くことができます。 " }, 
{ "title" : "モジュールインスタンスの初期化（オンライン変更） ", 
"url" : "ac_initialization_of_module_instances.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ モジュールインスタンスの初期化（オンライン変更） ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "モジュールインスタンスとプロキシインスタンスの初期化と再初期化（オンライン変更） ", 
"url" : "ac_initialization_of_module_instances.html#UUID-d33dd918-6f7b-5e75-6686-b9d605273b58_index_2", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ モジュールインスタンスの初期化（オンライン変更） \/ モジュールインスタンスとプロキシインスタンスの初期化と再初期化（オンライン変更） ", 
"snippet" : "方法 IBaseInstance.Init(bOnlineChange : BOOL) ) は、すべてのトップレベル モジュール インスタンスおよびすべてのプロキシ インスタンスのダウンロードまたはオンライン変更の後に呼び出されます。モジュールは、必要に応じて、すべての管理対象モジュール インスタンスを呼び出す役割を果たします。 Init すべてのパラメータ値、管理対象および参照されるモジュール インスタンスが設定され、モジュール インスタンスがモジュール ツリーにマウントされるとすぐに呼び出されますが、タスクが開始または続行される前です。 ファンクションブロックでの標準実装 Module す...", 
"body" : "方法 IBaseInstance.Init(bOnlineChange : BOOL) ) は、すべてのトップレベル モジュール インスタンスおよびすべてのプロキシ インスタンスのダウンロードまたはオンライン変更の後に呼び出されます。モジュールは、必要に応じて、すべての管理対象モジュール インスタンスを呼び出す役割を果たします。 Init すべてのパラメータ値、管理対象および参照されるモジュール インスタンスが設定され、モジュール インスタンスがモジュール ツリーにマウントされるとすぐに呼び出されますが、タスクが開始または続行される前です。 ファンクションブロックでの標準実装 Module すべてのサブモジュールを呼び出します。 方法 IBaseInstance.OnBeforeOnlineChange そして IBaseInstance.OnAfterOnlineChange は、モジュール ツリーの構造が再作成され、パラメーター値が変更される前後に呼び出されます。さらに、メソッドはすべてのサブモジュールと参照モジュールが再割り当てされる前後、ただしタスクが (再) 開始される前に呼び出されます。 対照的に、 FB_Init 、このメソッドは、オンライン変更のたびに呼び出されます。 FB_Exit 以前に古いインスタンスで呼び出されたことがあります。 " }, 
{ "title" : "セクション: メタデータ ", 
"url" : "ac_module_fb_sec_metadata.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: メタデータ ", 
"snippet" : "MetaData セクション MetaData 説明、カテゴリ、アイコン (サイズは 16x16 ピクセルおよび 32x32 ピクセル) が含まれます。 SEC MetaData \/\/optional: yes, modifier: [UPDATE]] Desc := <description>; \/\/optional: no, type: text Category := <category name>; \/\/optional: no, type: CategoryPath Icon_16 := <icon16 name>; \/\/optional: no, type: image Icon_...", 
"body" : "MetaData セクション MetaData 説明、カテゴリ、アイコン (サイズは 16x16 ピクセルおよび 32x32 ピクセル) が含まれます。 SEC MetaData \/\/optional: yes, modifier: [UPDATE]]\n Desc := <description>; \/\/optional: no, type: text\n Category := <category name>; \/\/optional: no, type: CategoryPath\n Icon_16 := <icon16 name>; \/\/optional: no, type: image\n Icon_32 := <icon32 name>; \/\/optional: no, type: image\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: IDOrNothing\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n Links := ['<link1>','<link2>',...] \/\/optional: Yes, type: UriCollection\nEND_SEC 定義タイプの構文に関する詳細は、セクションで説明されています。 モジュール宣言 。 仕様： セクションの場合 MetaData が見つからない場合、このモジュールはインスタンス化できないベース モジュールとして使用されます。 Category 同じ主題に属するモジュールのトピックを定義します。キャラクター | 「モジュールの追加」ダイアログに要素の階層構造を作成します。キャラクター | そして newline または carriage return 構造名には使用できません。 Icon_16 解像度 16 x 16 ピクセルのアイコンの名前を定義します。アイコンのイメージはイメージ プールで定義する必要があります。アイコン Icon_16 モジュールツリーとアイコンに使用されます Icon_32 情報ダイアログ用。 Inst_Prefix 生成された FB インスタンスとサブモジュール インスタンスの名前のデフォルトのプレフィックスを定義します。空のプレフィックス ( Inst_Prefix := ) も可能ですが、機能ブロックの他の変数名と重複する可能性があります。このプリ設定はセクションで上書きできます。 Slot 。 モジュールクラスから派生する場合 IMPORTS 、 セクション MetaData このセクションが基本モジュールに存在する場合は更新する必要があります。これを行うには、セクションを修飾子で宣言する必要があります。 UPDATE そして説明を再定義する必要があります。 Default_Inst_Name このスロットの子であるモジュール インスタンスのデフォルト名を定義するために使用できます。追加された各モジュールは、「Default_Inst_Name」で定義されたテキスト リスト エントリを使用して、デフォルトでこの名前を取得します。親スロットのデフォルト名がある場合は、モジュールのメタデータ内の名前よりもこの名前が優先されます。 Links リンクのリストを定義します。リンクはモジュール エディターに表示されます。 情報 タブ。リンクリストの先頭URLの内容が表示されます。 情報 タブ。 例 SEC MetaData\n Desc := TL.Desc_Drives ;\n Category := 'Mechatronics'|'Drives' ;\n Icon_16 := IP.Drive_Icon_16 ;\n Icon_32 := IP.Drive_Icon_32 ;\n Default_Inst_Name := IDrive ;\n Links := ['file:\/\/\/d:\\Document1.pdf', 'https:\/\/www.codesys.com', 'mailto:info@codesys.com'];\nEND_SEC Category := 'Mechatronics'|'Drives 次の構造を作成します。 " }, 
{ "title" : "セクション: トップレベル ", 
"url" : "ac_module_fb_sec_toplevel.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: トップレベル ", 
"snippet" : "トップレベル モジュール ツリーの最初のレベルにあるモジュールは、トップレベル モジュールと呼ばれます。他のモジュールとは対照的に、1 つまたは複数のタスクから直接呼び出すことができるメソッドがあります。トップレベルのモジュールには次のセクションが含まれます Toplevel 。 SEC Toplevel \/\/optional: yes, modifier: [UPDATE] GVL_Name := <GVL name>; \/\/optional: yes, type: literal Default_Application := <default application>; \/\/optiona...", 
"body" : "トップレベル モジュール ツリーの最初のレベルにあるモジュールは、トップレベル モジュールと呼ばれます。他のモジュールとは対照的に、1 つまたは複数のタスクから直接呼び出すことができるメソッドがあります。トップレベルのモジュールには次のセクションが含まれます Toplevel 。 SEC Toplevel \/\/optional: yes, modifier: [UPDATE]\n GVL_Name := <GVL name>; \/\/optional: yes, type: literal\n Default_Application := <default application>; \/\/optional: yes, type: QID\n Default_POUPool := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n SEC Standard_Task : <task name> \/\/optional: yes, modifier: [HIDE,UPDATE]\n Name := <task name>; \/\/optional: no, type: ID\n Desc := <task description>; \/\/(optional: no, type: Text)\n Flags:= <flag>; \/\/(optional: no, type: StdTaskFlags)\n END_SEC\n SEC Custom_Task : <task name> \/\/optional: yes, modifier: [UPDATE]\n Priority := <priority>; \/\/optional: no, type: Subrange(0 .. 31)\n Interval := <interval>; \/\/optional: no, type: TimeLiteral)\n Flags:= <flag>; \/\/optional: no, type: CustomTaskFlags)\n END_SEC\nEND_SEC 定義タイプの構文に関する詳細は、セクションで説明されています。 モジュール宣言 。 仕様： GVL_Name モジュールのインスタンスとそのすべてのサブインスタンスが宣言される GVL の名前を定義します。プレースホルダー %Instancename% (大文字または小文字のスペルは関係ありません)、モジュール インスタンスのインスタンス名に置き換えられます。 パラメータ Default_Application このモジュールのすべてのインスタンスの特定のアプリケーションへのアプリケーション割り当てを定義します。デフォルトのアプリケーションが定義されている場合は、 Default_POUPool 不可能である。 パラメータ Default_POUPool このモジュールのすべてのインスタンスの POU プールへのアプリケーション割り当てを定義します。デフォルトの POU プールが定義されている場合は、 Default_Application 不可能である。 パラメータ Pragmas コンパイラ プラグマのリストが含まれており、モジュールの FB インスタンスの宣言の前に挿入されます。 セクション Standard_Task 呼び出しが実行されるタスクを定義します。このために、次の 3 つの標準タスクを使用できます。 LOW 、 MEDIUM 、 そして HIGH 。の定義 Standard_Task は： Name : モジュールインスタンス作成後にタスク割り当てとして定義されるデフォルトのタスク名。 Desc : タスク呼び出しの識別子。これは短くて意味のあるものにする必要があります (例: I\/O task ）。 Flags : 以下の値を組み合わせることができます。 | キャラクター： CREATE_IF_MISSING : タスクが存在しない場合は作成されます。 READONLY : タスクの割り当ては読み取り専用であり、ユーザーは変更できません。 UPDATE_IOS : タスクは I\/O を更新するために使用されます。各 I\/O は、 UpdateInTask のパラメータ IO セクション。 NONE : フラグは設定されていません。 例 SEC Standard_Task : MEDIUM\n Name := MainTask ;\n Desc := TL.TaskMedium_Desc ;\n Flags := READONLY | CREATE_IF_MISSING ;\nEND_SEC セクションを利用することで Custom_Task モジュールは 1 つ以上のカスタム タスクを定義できます。セクションのターゲットは、モジュール関数ブロックのメソッドの名前である必要があります。メソッドには引数があってはなりません（引数も INPUT 、 OUTPUT 、 または INOUT ）。 Priority : タスクの優先度を定義します。 Interval : タスク間隔(データ型「TIME」または「LTIME」の定数)を定義します。 Flags : 以下の値を組み合わせることができます。 | キャラクター： SHARED 注: 互換性上の理由から、このフラグはまだ存在しますが、常に暗黙的に設定されているものとみなされます。これは基本的に、タスクが指定されたプロパティを持つ場合、 Custom_Task セクションがすでに存在する場合、このタスクが使用されます。ただし、一致するプロパティを持つ既存のタスクがない場合は新しいタスクが作成されるため、このフラグは廃止されます。作成したタスクの名前は、 TASK_<ModuleInstanceName>_<MethodName> 。 UPDATE_IOS : タスクは、ST 式またはモジュール I\/O に直接接続されている I\/O を更新するために使用されます。 NONE : フラグは設定されていません。 指定されたメソッドのモジュール クラスにはデフォルトの実装がありません。 例 SEC Custom_Task : Method1\n Priority := 7 ;\n CycleTime := t#14ms ;\n Flags := NONE ;\nEND_SEC まさに 1 つの標準タスクまたは特定のタスクに、 UPDATE_IOS フラグセット。 ここでは、いくつかの基本的なルール、タスクの生成方法について説明します。 標準タスクが存在する場合、 CREATE_IF_MISSING フラグが設定されている場合、指定された名前とジェネレーター設定のプロパティを持つタスクが存在する必要があります。プロパティが指定されたものと一致しない場合は、警告メッセージが表示されます。 標準タスクが存在する場合、 CREATE_IF_MISSING フラグが設定されると、まず指定されたプロパティを持つタスクが生成されます。これで、このタスクのジェネレーター設定が変更されるたびに、警告メッセージが表示されずにタスクが適応されるようになります。 同じタスク名を参照する、異なるタイプの標準タスクは許可されません。この場合、エラーは発行されません。 構成された標準に応じて、各トップレベル インスタンスの定義されたタスクの最初と最後に次のメソッドが呼び出されます。 METHOD CallPrioHighStart: BOOL\nMETHOD CallPrioHighEnd: BOOL\nMETHOD CallPrioMediumStart: BOOL\nMETHOD CallPrioMediumEnd: BOOL\nMETHOD CallPrioLowStart: BOOL\nMETHOD CallPrioLowEnd: BOOL 各モジュールはそのサブモジュール インスタンスを呼び出す必要があります。サブモジュール参照を呼び出すことはできません。 FB のデフォルト実装 Module すべてのサブモジュール インスタンスのそれぞれのメソッドを、モジュール ツリー内の位置の順序で呼び出します。 SUPER ポインターは、基本関数ブロックのインスタンスへのアクセスを提供します。したがって、たとえば呼び出し SUPER^.CallPrioHighStart() メソッドを呼び出すために使用できます Module.CallPrioHighStart() ファンクションブロックが拡張した場合 Module 。このようにして、 Module すべてのサブモジュールが呼び出されることを確認します。 " }, 
{ "title" : "セクション: IO ", 
"url" : "ac_module_fb_sec_io.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: IO ", 
"snippet" : "IO このセクションでは入力と出力の定義を行うことができます。定義されたすべての入力と出力は、 マップ I\/O 。 SEC IO \/\/optional: yes, modifier: [UPDATE] SEC Input : <input identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/optional: no, type: InstancePath Name := <name>; \/\/optional: no, type: text Desc := <description>...", 
"body" : "IO このセクションでは入力と出力の定義を行うことができます。定義されたすべての入力と出力は、 マップ I\/O 。 SEC IO \/\/optional: yes, modifier: [UPDATE]\n SEC Input : <input identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Name := <name>; \/\/optional: no, type: text\n Desc := <description>; \/\/optional: no, type: text\n UpdateInTask := <task name>; \/\/optional: yes, type: TaskRef\n END_SEC\n SEC Output : <output identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Name := <name>; \/\/optional: no, type: text\n Desc := <description>; \/\/optional: no, type: text\n UpdateInTask := <task name>; \/\/optional: yes, type: TaskRef\n END_SEC\nEND_SEC 定義タイプの構文の詳細については、次の説明を参照してください。 モジュール宣言の構文 。 仕様： パラメータ Variable 入力変数または出力変数のインスタンス パスを定義します。 入力のパスのすべてのコンポーネントは入力変数 (または構造体のローカル変数) である必要があります。出力のパスのすべてのコンポーネントも出力変数 (または構造体のローカル変数) である必要があります。変数はプリミティブ データ型または列挙型データ型である必要があります。 変数はパラメータと入出力を同時に行うことができます。変数を 2 つの異なる I\/O で使用してはなりません。 のターゲット input または output セクションは入力または出力を一意に識別する必要があります。大文字と小文字は区別されません。 パラメータ UpdateInTask I\/O を更新するタスクを決定します。このパラメータが欠落している場合は、フラグ付きのタスクが必要です UPDATE_IOS 使用されます。トップレベルモジュールの場合、タスクが指定されている場合、エラーが作成されます。 UpdateInTask モジュールには定義されていません。 例 SEC Io\n SEC Input : uiTemperature\n Variable := uiTemperature ;\n Name := TL_WeatherStation.NAME_iTemperature ;\n Desc := TL_WeatherStation.DESC_iTemperature ;\n UpdateInTask := Standard_Task : Medium;\n END_SEC\n SEC Output : uiLigh\n Variable := uiLightnessSouth ;\n Name := TL_WeatherStation.NAME_uiLightnessSouth ;\n Desc := TL_WeatherStation.DESC_uiLightnessSouth ;\n UpdateInTask := Standard_Task : Medium;\n END_SEC\nEND_S " }, 
{ "title" : "セクション: パラメータ ", 
"url" : "ac_module_fb_sec_parameters.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: パラメータ ", 
"snippet" : "パラメーター このセクションでは、パラメータ化に使用できる必要があるすべてのパラメータを定義できます。 パラメーター モジュールインスタンスの。 SEC Parameters \/\/optional: yes, modifier: [UPDATE] SEC Param : <parameter identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/optional: yes, type: InstancePath VariableType := <data type> \/\/option...", 
"body" : "パラメーター このセクションでは、パラメータ化に使用できる必要があるすべてのパラメータを定義できます。 パラメーター モジュールインスタンスの。 SEC Parameters \/\/optional: yes, modifier: [UPDATE]\n SEC Param : <parameter identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: yes, type: InstancePath\n VariableType := <data type> \/\/optional: yes, type: @JG???IEC-Typ\n Name := <parameter name>; \/\/optional: no, type: text\n Desc := <parameter description>; \/\/optional: no, type: text\n Group := <parameter group name> \/\/optional: yes, type: text\n MustBeSet := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n Default := <default value>; \/\/optional: yes, type: LiteralOrConstant\n Max := <max value>; \/\/Optional: yes, type: LiteralOrConstant\n Min := <min value>; \/\/Optional: yes, type: LiteralOrConstant\n END_SEC\nEND_SEC 定義タイプの構文に関する詳細は、セクションで説明されています。 モジュール宣言 。 仕様： セクションのターゲット Param パラメータを一意に識別する必要があります。 定義 Variable モジュール関数ブロックに対する相対的な入力インスタンス パスです。この変数にはパラメータ値が格納され、その型によってパラメータの型が定義されます。もし Variable 宣言されている場合、パラメータは VariableType 定義する必要はなく、無視されます。 パラメータ VariableType 変数の IEC タイプを定義します。もし VariableType 宣言されていますが、実際の既存の FB 変数が指定されていません。 Variable 定義、 Default 定義が存在する必要があります。この値は、 VariableType 。 パラメータ Name そして Desc は文字列であり、テキスト リストで定義する必要があります。 モジュール パラメーターには基本的な型と列挙を使用できますが、構造体や配列のインスタンスは使用できません。 パラメータ変数には次のものが必要です 初期化値 、関数ブロックの宣言で定義されます。 オプションのパラメータ Default 初期化値を上書きできます。初期化式とデフォルト値には、正しい型のリテラルと定数が許可されます。これにはライブラリパラメータが含まれます。 オプションのパラメータ Group パラメータをグループに分割できます。各グループは、モジュール エディターの別のタブとして表示されます。 パラメーター 。 オプションのパラメータを使用する場合 MustBeSet ユーザーはモジュールエディタでパラメータを設定するよう強制できます。パラメータが設定されていない場合は、エラー メッセージが表示されます。 定義 分 そして マックス パラメータ値の制限を設定できます。これらの制限のチェックは、数値型または時間の変数に対してのみ可能です。他のすべての変数タイプは許可されていないため、エラーが発生します。 例 SEC Parameters\n SEC Param : InParam1\n Variable := xIn1;\n VariableTyp := BOOL;\n Name := TL.Input1_Name;\n Desc := TL.Input1_Desc;\n END_SEC\nEND_SEC 変数 xIn1 関数ブロックの宣言部分で定義する必要があります。 xIn1 : BOOL := FALSE ; " }, 
{ "title" : "初期化値 ", 
"url" : "ac_module_fb_sec_parameters.html#UUID-1cddf7ea-faa7-0b82-e29a-04e9f27653b0_ac_module_fb_sec_parameters0", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: パラメータ \/ 初期化値 ", 
"snippet" : "初期化値は、初期化で定義される変数の値です。 FB の単純な変数では、この値は常に変数宣言の右側にあります。 iVar : INT := 17 ; \/\/ Initialisierungswert: 17 構造体内で変数を定義する場合、構造体の初期化が不可欠です。 TYPE s : STRUCT i1 : INT := 7 ; r1 : REAL := 5 ; END_STRUCT END_TYPE モジュール FB での宣言: structVar : s := (i1 := 2, r1 := 0.0) ; この場合、次の値を定義する初期化値 structVar.i1 は 2 (そうではない 7...", 
"body" : "初期化値は、初期化で定義される変数の値です。 FB の単純な変数では、この値は常に変数宣言の右側にあります。 iVar : INT := 17 ; \/\/ Initialisierungswert: 17 構造体内で変数を定義する場合、構造体の初期化が不可欠です。 TYPE s : STRUCT\n i1 : INT := 7 ;\n r1 : REAL := 5 ;\nEND_STRUCT END_TYPE モジュール FB での宣言: structVar : s := (i1 := 2, r1 := 0.0) ; この場合、次の値を定義する初期化値 structVar.i1 は 2 (そうではない 7 ）。 ネストされた構造では、モジュール FB から変数までのパス内のすべての初期化を考慮する必要があります。変数の最も外側の初期化によって値が決まります。 " }, 
{ "title" : "セクション: スロット ", 
"url" : "ac_module_fb_sec_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: スロット ", 
"snippet" : "スロット このセクションでは、モジュール ツリー内のモジュールの可用性とスロットのタイプを定義します。 2 つの異なるタイプのスロットを定義できます。 スロット SEC Slots \/\/optional: yes, modifier: [UPDATE]] SEC Slot : <slot identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/optional: no, type: InstancePath Role := <role name>; \/\/optional: no, ty...", 
"body" : "スロット このセクションでは、モジュール ツリー内のモジュールの可用性とスロットのタイプを定義します。 2 つの異なるタイプのスロットを定義できます。 スロット SEC Slots \/\/optional: yes, modifier: [UPDATE]]\n SEC Slot : <slot identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Role := <role name>; \/\/optional: no, type: text\n Type := <slot type>; \/\/optional: no, type: SlotType\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: ID\n Optional := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n RegularExpressionParameterId := <RegEx param ID> \/\/optional: yes, type: text\n SEC Default_Allocation : \/\/optional: yes, modifier [UPDATE]\n Module_Name := <default module ID>; \/\/optional: yes, type: ID\n Instance_Name := <default name>; \/\/optional: yes, type: ID\n NotDeletable := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n SEC VisuEmbeddings \/\/optional: yes, modifier [UPDATE]\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <visu identigier> \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: ID\n Target := <target name>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: yes, type: ID\n TopLevelTap := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n SEC IOMappings \/\/optional: yes, modifier [UPDATE]\n SEC Mapping : <mapping identifier> \/\/optional: yes, modifier [UPDATE]\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, tye: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier [UPDATE]\n SEC Param : <param identifier> \/\/optional: yes, modifier [UPDATE]\n Value := <value>; \/\/optional: no, type: ID)\n END_SEC\n END_SEC\n END_SEC\n END_SEC\nEND_SEC 定義タイプの構文に関する詳細は、セクションで説明されています。 モジュール宣言 。 仕様： セクション Slot 0 接続または 1 接続を許可するスロットを定義します。 セクションのターゲット Slot パラメータを一意に識別する必要があります。結果として、2 つの異なるスロットがあってはなりません ( Slot または Slot_Multi ）同じターゲットを持つもの。 (大文字\/小文字は関係ありません。) 定義 Variable モジュール関数ブロックに対する相対的な入力インスタンス パスです。インスタンス パスは、そのすべてのコンポーネントで入力変数のみを参照できます (構造体インスタンスの場合はローカル変数も)。アドレス指定される変数の型は、インターフェイスまたは FB 型である必要があります。 2 つの異なるスロットで同じ変数を使用してはなりません。 Role スロットの役割の説明を定義します。 Type スロットのタイプを定義します。接続タイプには次の値を指定できます。 SUBMODULE : サブモジュール インスタンス用のスロット。 REFERENCE : 参照されるサブモジュール インスタンスのスロット。 DECOUPLED : 「分離された」モジュール インスタンス用のスロット。 以下も参照してください。 セクション: デカップリング Inst_Prefix は、生成される FB 変数の名前に使用されるプレフィックスです。空のプレフィックス ( Inst_Prefix := ; ) も可能ですが、関数ブロックの他の変数名と競合する可能性があります。にのみ指定できます SUBMODULE タイプのスロット。 Optional スロットを開いたままにしておくことが許可されるか、それとも接続する必要があるかを定義します。 Default_Inst_Name このスロットの子であるモジュール インスタンスのデフォルト名を定義するために使用できます。追加された各モジュールは、「Default_Inst_Name」で定義されたテキスト リスト エントリを使用して、デフォルトでこの名前を取得します。スロットのデフォルト名は、モジュールのメタデータの 1 つよりも優先されます。 Pragmas サブモジュールの FB インスタンスの前に挿入されるコンパイラ プラグマのリストが含まれています。プラグマは管理対象スロットにのみ使用できます。 RegularExpressionParameterId このスロットの STRING\/WSTRING タイプのパラメータを定義します。このパラメータの値は正規表現として解釈され、挿入されたサブモジュールの名前と一致する必要があります。 セクション Slot.Default_Allocation そして Slot_Multi.Default_Allocation 可変数の要素を持つスロット (Multi_Slots および Slots) のデフォルト設定を定義できます。のために Slots.Multi_Slot それらは一意のターゲットによって識別される必要がありますが、 Slots.Slot ターゲットがありません。1 つだけを持つことができます Default_Allocation セクション。インスタンスはセクション内の位置に応じて追加されます。モジュール名とインスタンス名は次の定義に従います。 Slot.DefaultModule そして Slot.DefaultName 。この定義が利用できない場合は、 Default_Allocation.Module_Name そして Default_Allocation.Instance_Name 使用されます。使用することをお勧めします Default_Allocation.* スロットの代わりに DefaultModule そして DefaultName これは互換性の理由からのみ存在します。デフォルトのモジュール インスタンスの設定は、次のサブセクションで定義できます。 Default_Allocation : Module_Name インスタンスが自動的に作成されるモジュールの名前を定義します。モジュールがライブラリからのものである場合は、モジュール名を名前空間で修飾する必要があります。このパラメータは、次のタイプのスロットにのみ許可されます。 SUBMODULE 。 無限呼び出しは許可されておらず、エラー メッセージが作成されます (例: モジュール \"A\" の宣言にはデフォルト モジュール \"B\" が含まれており、モジュール \"B\" の宣言にはデフォルト モジュール \"A\" が含まれています)。 Instance_Name 常に指定する必要があります DefaultModule が指定されており、それ以外の場合は決して指定されません。デフォルトのモジュール インスタンスの名前として使用される有効な IEC 識別子である必要があります。名前の先頭または末尾に下線 ( _ ）。宣言のすべてのスロットのデフォルト名は一意である必要があります。 (大文字と小文字は区別されません。) NotDeletable ユーザーがモジュールを削除できるかどうかを指定します。もし TRUE の場合、モジュールは削除できません。エラーメッセージが表示されます。パラメータが FALSE または省略した場合は、モジュールを削除できます。 VisuEmbeddings : の場合 Empty パラメータは次のように設定されています TRUE 、その後、このモジュール インスタンスに対して埋め込みヴィサスの空のリストが作成されます。値が FALSE 、その後、必要な埋め込みビジュアライゼーションのリストを介してモジュール インスタンスに対して埋め込みビジュアライゼーションの希望のリストを生成できます。 Embedding サブセクション。それぞれ Embedding セクションで名前を定義する必要があります VisuName この目的に必要な埋め込み VISU を指定し、次のような追加のプロパティを指定できます。 Target または LinkId この埋め込まれたビジュアルの。 PageVisu : このセクションでは、モジュール インスタンスの PageVisu を選択できます ( VisuName ）。さらに、このビジュアルが作成するかどうかを定義できます。 TopLevelTap 。パラメータ TopLevelTap 値を指定する必要があります TRUE そして FALSE 。 IOMappings : サブセクション内 Mapping I\/O チャネルを定義できます。各セクションの対象 Mapping ターゲット I\/O チャネルを記述します。デフォルトは次のように設定できます。 NoMapping または STExpression 。 Parameters : サブセクション内 Param 値 Value セクションのターゲットに定義されている各パラメータの定義が可能です。 スロットマルチ セクションを利用することで Slot_Multi サブインスタンスと参照のリストを作成できます。 SEC Slots \/\/optional: yes, modifier: [UPDATE]]\n SEC Slot_Multi : <slot name> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable for count>; \/\/optional: no, type: InstancePath\n Role := <name role>; \/\/optional: no, type: text\n Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\n Type := <slot type>; \/\/optional: no, type: SlotType\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: ID\n Pragmas := <pragma list>; \/\/optional: yes, type: Pragmalist\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n RegularExpressionParameterId := <RegEx param ID> \/\/optional: yes, type: text\n SEC Default_Allocation : \/\/optional: yes, modifier [UPDATE]\n Module_Name := <default module ID>; \/\/optional: yes, type: ID\n Instance_Name := <default name>; \/\/optional: yes, type: ID\n NotDeletable := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n SEC VisuEmbeddings \/\/optional: yes, modifier [UPDATE]\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <visu identifier> \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: ID\n Target := <target name>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: yes, type: ID\n TopLevelTap := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n SEC IOMappings \/\/optional: yes, modifier [UPDATE]\n SEC Mapping : <mapping identifier>; \/\/optional: yes, modifier [UPDATE]\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, tye: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier [UPDATE]\n SEC Param : <param identifier> \/\/optional: yes, modifier [UPDATE]\n Value := <value>; \/\/optional: no, type: ID)\n END_SEC\n END_SEC\n END_SEC\n END_SEC\nEND_SEC 追加仕様: Var_Count モジュール関数ブロックの入力インスタンス パスを定義します。この変数 (整数型) は、スロットに接続されているインスタンスの数に関する情報を保存します。 Cardinality インスタンスの最小数と最大数を定義します。 の Slot_Multi.Default_Allocation セクションを使用して、可変数の要素を持つスロットのデフォルトの割り当てを定義できます。それらは一意のターゲットを介して識別される必要があります。インスタンスはセクションの順序で挿入されます。モジュール名とインスタンス名については、 Slot.DefaultModule または Slot.DefaultName 適用する。デフォルト割り当ての数は、上位の桁を超えてはなりません。 によってアドレス指定される変数 Slot_Multi セクションは次のタイプである必要があります POINTER TO <INTERFACE> 。 整数型の各入力変数は次のようにアドレス指定できます。 Var_Count 1回だけ。 (これには、 InstRef_Multi.Var_Count そして VarArray.Var_Count ）。 例 SEC Slot\n SEC Slot_Multi : subs\n Variable := pSubs;\n Var_Count := uiArraySize;\n Role := TL.Role;\n Cardinality := [2 .. 17];\n Type := SUBMODULE;\n RegularExpressionParameterId := Param_RegEx_Ref;\n SEC Default_Allocation : def1\n Module_Name := Sub1;\n Instance_Name := Submodule;\n END_SEC\n Name := TL.Input1_Name;\n Desc := TL.Input1_Desc;\n END_SEC\nEND_SEC 他の宣言の中でも、関数ブロックの宣言部分には以下を含める必要があります。 uiArraySize: UINT; pSubs: POINTER TO ITestModule 。 この例では、少なくとも 2 個、最大 17 個のサブインスタンスを保持するスロットが定義されています。サブインスタンスの配列が作成され、 pSubs それを指します。インスタンスを追加するときは、名前付きのサブモジュール Submodule タイプの Sub1 スロットに自動的に追加されます。 " }, 
{ "title" : "セクション: ソーステンプレート ", 
"url" : "ac_module_fb_sec_copyfb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: ソーステンプレート ", 
"snippet" : "ソーステンプレート セクションのサブセクション SourceTemplate プロジェクトにコピーされる機能ブロックを定義します。 モジュールエディタでは、ここで定義された関数ブロックがリストされます。そこでコピーを有効または無効にすることができます。 こちらも参照 ソーステンプレート SEC std.SourceTemplate SEC SourceFB : <Identifier> \/\/ optional: no SourceType := <FunctionBlock>; \/\/ optional: no, type: InstancePath Variable := <variable ...", 
"body" : "ソーステンプレート セクションのサブセクション SourceTemplate プロジェクトにコピーされる機能ブロックを定義します。 モジュールエディタでは、ここで定義された関数ブロックがリストされます。そこでコピーを有効または無効にすることができます。 こちらも参照 ソーステンプレート SEC std.SourceTemplate\n SEC SourceFB : <Identifier> \/\/ optional: no\n SourceType := <FunctionBlock>; \/\/ optional: no, type: InstancePath\n Variable := <variable name>; \/\/ optional: no, type: InstancePath\n Default := TRUE\/FALSE; \/\/ optional: yes, type: Bool Flag\n IsMandatory := TRUE\/FALSE; \/\/ optional: yes, type: Bool Flag\n FBVariable := <variable name>; \/\/ optional: yes, type: InstancePath\n DestinationType := <default name>; \/\/ optional: yes, Type: String\/Literal\n END_SEC\nEND_SEC 定義タイプの構文に関する詳細は、セクションで説明されています。 モジュール宣言 。 仕様： の Identifier モジュールエディターで使用されます。コピーされたファンクション ブロックの名前を定義します。 DestinationType 定義されていません。 SourceType コピーする機能ブロックを定義します。 Variable モジュール機能ブロックの入力変数を定義します。これは、コピーされる関数の基本クラスまたはコピーされる関数ブロックによって実装されるインターフェイスへのポインターである必要があります。 Default このモジュールのデフォルトで関数ブロックがコピーされるかどうかを定義します。定義が欠落している場合は、 TRUE が設定されています。このオプションはモジュールエディタで調整できます。 もし IsMandatory の上 TRUE が設定されている場合、プロジェクト エンジニアはオプションを使用できます。 IsToCopy エディターでは変更しないでください。 と FBVariable コピーされた関数ブロックの入力変数が指定され、モジュール インスタンスが設定されます。それらの型は、モジュール FB の基本型へのポインタまたはモジュール FB のインターフェイスへのポインタにすることができます。 で DestinationType コピーされたファンクションブロックには標準名が指定されます。この定義が欠落している場合は、次の命名規則が適用されます。 <Name der Modulinstanz>_<Identifier>[_<fortlaufendeNummer>] 。 指定された SourceTemplate はフォルダー内にあります AC_SourceTemplate 関連するモジュール FB によってコピーされ、インスタンス化され、初期化されます。一度作成した SourceTemplate は編集でき、新しい世代の実行中に上書きされません。使用されなくなった SourceTemplate は名前が変更されます (追加 <_unused >) そしてサブフォルダーに <UnusedSourceTemplates> 遅れ。 例 SEC std.SourceTemplate\n SEC SourceFB : ID_ConnectSwitches\n SourceType := ConnectSwitches;\n Variable := itfConnect;\n FBVariable := pBuilding;\n Default := TRUE;\n IsMandatory := FALSE;\n DestinationType := 'TypeInModuleDescription';\n END_SEC\nEND_SEC " }, 
{ "title" : "セクション: ビジュアル ", 
"url" : "ac_module_fb_sec_visu.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: ビジュアル ", 
"snippet" : "ビジュアル SEC Visu \/\/optional: yes, modifier: [UPDATE] Toplevel_Tab; \/\/optional: yes, type: bool Embedded := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList Embedded_Proxy := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList Page =: [<visu1>, <visu2>,...]; \/\/optional: yes, type: Vi...", 
"body" : "ビジュアル SEC Visu \/\/optional: yes, modifier: [UPDATE]\n Toplevel_Tab; \/\/optional: yes, type: bool\n Embedded := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList\n Embedded_Proxy := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList\n Page =: [<visu1>, <visu2>,...]; \/\/optional: yes, type: VisuList\n\n SEC DefaultEmbeddings \/\/optional: yes\n SEC Embedding : <visu identifier> \/\/optional: yes, modifier: [HIDE, UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: literal\n Target := <target name>; \/\/optional: yes, type: literal\n ProxyVisuName := <visu name>; \/\/optional: yes, type: literal\n LinkId := <linkID>; \/\/optional: yes, type: literal\n END_SEC\n END_SEC\n\n SEC Toplevel_Tab_Hotkey \/\/optional: yes\n Hotkey := <keycode>; \/\/optional: no, type: literal\n Modifiers := <modifier>; \/\/optional: yes, modifier: [SHIFT, CONTROL, ALT]\n END_SEC\n\nEND_SEC 定義タイプの構文の詳細については、次の章を参照してください。 モジュール宣言の構文 説明された。 仕様： Toplevel_Tab チェックボックスが トップレベルのライダーを作成する HMI エディタでデフォルトでアクティブになるかどうか。 Page サブモジュールの使用可能な視覚化オブジェクトのリストを定義します。 Embedded サブモジュールの利用可能な視覚化オブジェクトの具体的なリストを定義します。これらのオブジェクトは、他の視覚化イメージに埋め込まれます。 プレースホルダー %PAGE_VISU% ビジュアライゼーション名の代わりに、生成されたビジュアライゼーション イメージをオプションで他のページに埋め込むことができます。 Embedded_Proxy モジュールの使用可能な視覚化オブジェクトのリストを定義します。このリストは、次の場合にのみ使用されます。 Decoupled-Modul で Decoupled-Slot が挿入され、親モジュール インスタンスと同じ制御下 (つまりプロキシとして) に作成されません。 別のモジュールをインポートするモジュールの場合、ビジュアライゼーション名の代わりにプレースホルダーを使用できます。 %NONE% 利用される。これにより、インポートされたビジュアライゼーションが非表示になります。この手順は、視覚化イメージのリストと埋め込み (プロキシ) 視覚化イメージの両方に対して可能です。 セクション DefaultEmbeddings : このセクションは、タブに表示される標準の埋め込みを指定するために使用されます。 HMI サブモジュールの部分は事前に設定されているように見えます (セクションと同様) Default_Allocation 、 ご参照ください スロットセクション ）。必要な標準埋め込みはサブセクションに保存されます Embedding 説明された。 要件: 指定された視覚化オブジェクトとプロキシは、このモジュールの可能な埋め込みのリストに含まれている必要があります (上記を参照)。 Embedded そして Embedded_Proxy ）。 セクション Toplevel_Tab_Hotkey : このセクションでは、トップレベル ページのデフォルト設定としてキーボード ショートカットを定義します。キーボード ショートカットは複数回使用することはできません。この設定は、タブのモジュールエディターで行うことができます。 HMI 調整される。 例 SEC Visu\n Toplevel_Tab ;\n Page := [VISU_CNC_Machine_1, VISU_CNC_Machine_2];\n Embedded := [%PAGE_VISU%];\n SEC DefaultEmbeddings\n SEC Embedding : No1\n VisuName := SubModule_Emb;\n Target := '..\/..\/TopLevel_2';\n END_SEC\n SEC Embedding : No2\n VisuName := SubModule_Emb_2;\n \/\/ProxyVisuName := SubModule_Emb_1;\n Target := '';\/\/ leave empty for next ancestor\n END_SEC\n END_SEC\n SEC Toplevel_Tab_Hotkey\n Hotkey := T;\n Modifiers := SHIFT | CONTROL;\n END_SEC\nEND_SEC ビジュアライゼーション名は、対応するビジュアライゼーション オブジェクトの名前であり、大文字と小文字は区別されません。視覚化オブジェクトは、モジュールの機能ブロックと同じ階層レベルにある必要があります。 次のルールが視覚化オブジェクトのインターフェイスに適用されます。 すべての視覚化オブジェクトと埋め込み視覚化オブジェクトは、名前付きの VAR_IN_OUT 変数を持つことができます。 inst モジュールの関数ブロックまたは基本クラスの型 (変数名の大文字と小文字は関係ありません)。 VAR_IN_OUT   inst : <MODULE_FB> ; END_VAR ここで説明した VAR_IN_OUT オプションの代わりに、VAR_INPUT 変数を使用することもできます。この変数は次の要件を満たしている必要があります。 姓： inst タイプ: モジュール機能ブロックが実装するインターフェイス 埋め込みビジュアライゼーション オブジェクトには、次の 2 つの追加変数を含めることもできます (パラメーター名は大文字と小文字が区別されません)。 VAR_INPUT paVisuFB : POINTER TO POINTER TO AC_Visu_Base ; iOwnFrameIndex : INT ; END_VAR これらの変数の両方が存在するか、どちらも存在しない必要があります。これら 2 つの変数により、埋め込みビジュアライゼーションに、トップレベルのビジュアライゼーションの中央フレームを切り替える機能が与えられます。 paVisuFB へのポインタの配列です AC_Visu_Base -インスタンス。グローバル視覚化変数について CURRENTCLIENTID 現在のクライアントの正しいインスタンスにアクセスできます。フレームの切り替えは、次の形式の ST アクションを介して発生します。 paVisuFB[CURRENTCLIENTID]^.uiFrameIdx := iOwnFrameIndex ; iOwnFrameIndex は、独自のモジュールの視覚化イメージがこの最上位フレーム内に持つインデックスです。 (独自のモジュールが視覚化イメージを定義していない場合、このインデックスは -1 になります。) 上記の変数とは別に、インターフェイスには他の VAR_INPUT、VAR_OUTPUT、または VAR_INOUT 変数を含めることはできません。 の AC_Visu_Base -インスタンスでも機能を提供 GetModuleFrameIndex 、任意のモジュール インスタンスに使用できます (「 IModule で AC_Module_Base.library) 最上位のビジュアライゼーション内のビジュアライゼーション イメージのインデックスを返します (ビジュアライゼーション イメージが存在する場合)。これにより、モジュール インスタンス ツリー内の任意の視覚化イメージにジャンプできるようになります。モジュールのコード内でのナビゲーションを可能にするために、モジュールの環境 (「 IModule で AC_Module_Base.library ） メンバー Environment.visus 、 上記 paVisuFB ポインタが対応します。 変数について CURRENTCLIENTID 使用するには、ライブラリが利用可能である必要があります VisuGlobalClientManager 統合されます (カテゴリ「内部|Visu」)。 最初のビジュアライゼーションがデフォルトとして使用されます。 " }, 
{ "title" : "セクション: トレンド ", 
"url" : "ac_module_fb_sec_trend.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: トレンド ", 
"snippet" : "傾向 SEC tre.Trend \/\/optional: yes, modifier: [UPDATE] SEC TrendRecording : <CFC trend identifier> \/\/optional: yes, modifier: [UPDATE] Task := <trend task> \/\/optional: yes, type: TimeLiteral CycleTime := <time value> \/\/optional: yes, type: TimeLiteral LimitType := <limit type> \/\/optional: yes, type: F...", 
"body" : "傾向 SEC tre.Trend \/\/optional: yes, modifier: [UPDATE]\n SEC TrendRecording : <CFC trend identifier> \/\/optional: yes, modifier: [UPDATE]\n Task := <trend task> \/\/optional: yes, type: TimeLiteral\n CycleTime := <time value> \/\/optional: yes, type: TimeLiteral\n LimitType := <limit type> \/\/optional: yes, type: FileLimitType\n LimitMaximum := <max bytes> \/\/optional: yes, type: Literal\n RecordCondition \/\/optional: yes, type: InstanceAccess\n SEC Visu \/\/optional: yes, modifier: [UPDATE]\n VisuPlaceholder \/\/optional: yes, type: StringLiteral\n VisuTemplate := <visu template> \/\/optional: yes, type: StringLiteral\n Target := <path module instance \/\/optional: yes, type: StringLiteral\n END_SEC\n END_SEC\n\n SEC TrendVariable : <variable identifier> \/\/optional: yes, modifier: [UPDATE]\n Variable := <variable name> \/\/optional: yes, type: InstanceAccess\n TrendRecording := <recording name> \/\/optional: no, type: : Id)\n Description := <tooltip> \/\/optional: yes, type: TextRef\n Color := <graph color> \/\/optional: yes, type: Literal\n GraphType := <graph type> \/\/optional: yes, type: GraphType\n LineWidth := <width> \/\/optional: yes, type: Literal\n LineStyle := <line style> \/\/optional: yes, type: LineStyle\n SEC Warning : MIN\/MAX \/\/optional: yes, modifier: [UPDATE]\n Limit := <limit value> \/\/optional: no, type: Literal\n Color := <limit color> \/\/optional: yes, type: Literal\n END_SEC\n END_SEC\nEND_SEC 定義タイプの構文の詳細については、次の章を参照してください。 モジュール宣言の構文 説明された。 仕様： Task : トレンド記録を実行するタスクを指定します。タスクが指定されていない場合は、Visu-Trend によって自動的に作成されたタスクが使用されます。 CycleTime : トレンド記録サイクル時間。 LimitType : 記録されたトレンドの制限の種類。 LimitMaximum : トレンド ストレージの最大サイズ (KB 単位) ( LimitType ==FileLimit ）。 RecordCondition ：録音状態。参照される変数は BOOL 型である必要があります。 VisuPlaceholder : 生成された傾向視覚エフェクトに置き換えられるプレースホルダー。 VisuTemplate : 作成するビジュアルのテンプレート。テンプレートにはプレースホルダーが必要です Trend_Placeholder 持っている。次の識別子を持つコントロールを含めることができます。 TrendLegend -> タイプ: 凡例 TrendTimeRangeSelector -> タイプ: 時間範囲の選択 TrendDateRangeSelector -> タイプ: 日付範囲ピッカー Target : ビジュアライゼーションを埋め込むモジュール インスタンスへの相対パス。 Variable ：記録する変数。 TrendRecording : 変数が属する TrendRecording オブジェクト。 Description : 変数のツールチップとして表示されるテキスト リスト エントリ。 Color : ARGB カラーコードとしての変数のグラフの色 GraphType ：グラフの種類 LineWithPoints : 点のある線 Cross : 十字架 StepWithPoints : ポイント付きレベル Point ：ポイント Lines : 行 Step : ステージ LinesWithCrosses : 十字の線 \\\\ StepWithCrosses : 十字のステップ LineWidth ：描いた線の太さ。 1 ～ 255 の値。 LineStyle : 線のスタイル Solid : 抜けた Dashed : 破線 Dotted ：点線 DashDotted : 二点鎖線 DashDotDotted : 二点鎖線 Warning : このサブセクションがターゲットである必要があります MAX または MIN 自分の。目標を超えるか下回る場合、警告がトリガーされます。 Limit : クリティカルエリアの開始。 Color : クリティカルエリアを ARGB カラーコードで表示するための色 例 SEC tre.Trend\n SEC TrendRecording : TrendSensor\n SEC Visu\n VisuPlaceholder := 'TrendPlaceholder_TrendSensor';\n VisuTemplate := 'AC_Trend.GenTrend_VisuTemplate';\n END_SEC\n CycleTime := t#5s;\n LimitType := Records;\n LimitMaximum := 452;\n END_SEC\n SEC TrendVariable : Value\n Variable := value;\n TrendRecording := TrendSensor;\n Color := 16#FF00FF00;\n SEC Warning : MIN\n Limit := -5;\n Color := 16#FF101020;\n END_SEC\n GraphType := LinesWithCrosses;\n LineWidth := 3;\n END_SEC\nEND_SEC " }, 
{ "title" : "セクション: プロキシ ", 
"url" : "ac_module_fb_sec_proxies.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: プロキシ ", 
"snippet" : "プロキシ セクション Proxies プロキシを実装する機能ブロックを定義します。 プロキシは、異なるアプリケーションのモジュール間でデータを交換するために使用されます。プロキシ FB のインスタンスは、他のアプリケーションのモジュール インスタンスを表します。 SEC Proxies \/\/optional: yes, modifier: [UPDATE] SEC Proxy : <identifier> \/\/optional: yes, modifier [UPDATE] FB := <FB name>; \/\/optional: no, type: QID SEC MirrorVar : <...", 
"body" : "プロキシ セクション Proxies プロキシを実装する機能ブロックを定義します。 プロキシは、異なるアプリケーションのモジュール間でデータを交換するために使用されます。プロキシ FB のインスタンスは、他のアプリケーションのモジュール インスタンスを表します。 SEC Proxies \/\/optional: yes, modifier: [UPDATE]\n SEC Proxy : <identifier> \/\/optional: yes, modifier [UPDATE]\n FB := <FB name>; \/\/optional: no, type: QID\n SEC MirrorVar : <identifier> \/\/optional: yes, modifier [UPDATE])\n Variable := <variable name>; \/\/optional: no, type: VarPath\n END_SEC\n SEC ProxyParameter : <target> \/\/ optional: yes, modifier [UPDATE]\n Variable := <InstancePath>; \/\/ optional: no, type: VarPath\n END_SEC\n END_SEC\nEND_SEC 定義タイプの構文の詳細については、「 モジュール宣言の構文 説明された。 仕様： 関数ブロックは次のものでなければなりません IBaseInstance 派生する。 関数ブロックにはメソッドが必要です SetProxyIdentification 次の署名が付いていますが、これはインターフェイスにはありません IBaseInstance 含まれるもの: SetProxyIdentification(pbyName : POINTER TO BYTE, udiComAddr : UDINT, udiLocalComAddr : UDINT, pEnvironment : MEnv) 渡されたインスタンス名と設定されたアドレスはプロパティによって決定される必要があります InstanceName 、 ComAddress そして LocalComAddress 返される.. ファンクション ブロックは次のユーザーには使用できません。 IModule 派生する。 セクション付き MirrorVar モジュール インスタンスの変数はプロキシ インスタンスにミラーリングできます。これを行うには、変数のインスタンス パスが (モジュール インスタンスの FB への) 相対パスの形式である必要があります。 Variable 宣言される。モジュール インスタンス FB の指定された変数には、次のルールが適用されます。 変数は、モジュール インスタンス FB の vars、入力または出力の一部である必要があります。 モジュール FB とプロキシ FB の両方で定義する必要があります 両方の FB で同じタイプでなければなりません プリミティブ型でなければなりません。したがって、ポインタ、インターフェイス、構造体全体はミラーリングに許可されず、単純な型 (数値、STRING、TIME など) のみが許可されます。 指定された変数がこれらの条件を満たしている場合、それらは RMP の一部として自動的に転送され、ユーザーは転送について心配する必要はありません。 セクション付き ProxyParameter プロキシのパラメータを定義できます。次の点を考慮する必要があります。 のターゲットは、 ProxyParameters モジュールのパラメータターゲットに対応する必要があります。 の Variable プロキシ モジュールのは、モジュール パラメータに使用される変数の型と一致する必要があります。ここではプリミティブ型と列挙型のみが許可されます。 プロキシ パラメータは、各アプリケーションの初期化フェーズで、モジュール インスタンスで構成された値に 1 回設定されます。アプリケーションの実行中は、これらの変数はプロキシに反映されません。 関数ブロックの名前は、名前空間パスで修飾できます。 例 SEC Proxies\n SEC Proxy ProxyFB1\n FB := ProxyModule1;\n SEC MirrorVar : diInput\n Variable := diInput;\n END_SEC\n SEC ProxyParameter : InParam1\n Variable := TL.Input1_Name;\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "セクション: VarArray ", 
"url" : "ac_module_fb_sec_vararray.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: VarArray ", 
"snippet" : "VarArrays パラメータ VarArrays 構成可能なサイズで配列を作成できます。 SEC VarArrays \/\/optional: yes, modifier: [UPDATE]] SEC VarArray : <slot identifier> \/\/optional: yes, modifier [] Variable := <variable name>; \/\/optional: no, type: InstancePath Var_Count := <variable count>; \/\/optional: no, type: InstancePath Inst_Name :...", 
"body" : "VarArrays パラメータ VarArrays 構成可能なサイズで配列を作成できます。 SEC VarArrays \/\/optional: yes, modifier: [UPDATE]]\n SEC VarArray : <slot identifier> \/\/optional: yes, modifier []\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable count>; \/\/optional: no, type: InstancePath\n Inst_Name := <instance name>; \/\/optional: yes, type: StringLiteral\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n Var_Decl_Flags := <Flag1> | <Flag2> | ... ; \/\/optional: yes, type: Flags\n END_SEC\nEND_SEC 定義タイプの構文の詳細については、「 モジュール宣言の構文 説明された。 仕様： 定義 Variable モジュール関数ブロックに対する相対的な入力インスタンス パスです。その男は POINTER TO <ELEMTYPE> 。 <ELEMTYPE> 任意のタイプにすることができます。 セクションのターゲット VarArray 構成可能なサイズの配列を一意に識別する必要があります。 Var_Count 整数入力変数の入力インスタンス パスです。 Variable ファンクションブロックの。この変数を構成用にエディターに表示するには、パラメーターとして宣言する必要があります。あるいは、次のこともできます Var_Count マルチスロットまたはマルチinstRefの変数が使用可能です。複数の VarArray が同じである可能性があります Var_Count -変数を使用します。配列のサイズが 0 の場合、配列は作成されませんが、配列ポインターは 0 に設定されます。 Inst_Name 作成する配列変数の名前を指定します。プレースホルダー %Instancename% そして %VariablePath% (大文字\/小文字は関係ありません) は、モジュール インスタンスのインスタンス名またはポインター変数のインスタンス パス (ドットはアンダースコアに置き換えられます) に置き換えられます。定義を省略した場合はデフォルト値が適用されます。 AC_ARRAY_%VariablePath% 。 モジュールの 2 つの異なる VarArray に同一の VarArray がある場合、エラーになります。 Inst_Name それはプレースホルダーではありません %VariablePath% が含まれています。 Pragmas コンパイラ プラグマのリストが含まれており、生成された配列変数の前に挿入されます。 Var_Decl_Flags 作成された配列の変数の型をより正確に指定できるようになります。許可されるフラグは次のとおりです。 NONE 、 RETAIN そして PERSISTENT 。これらのフラグにより、セクションに移動します。 VAR_INPUT 、配列が作成される場所を追加できます（たとえば、フラグ用） RETAIN 、 VAR_INPUT RETAIN ）。 例 SEC VAR_ARRAYS\n SEC VAR_ARRAY : NameList\n Variable := psNameList;\n Var_Count := uiArraySize;\n END_SEC\n ...\n SEC PARAM : ArraySize\n Variable := uiArraySize;\n Name := TL.ArraySize_Name;\n Desc := TL.ArraySize_Desc;\n END_SEC\nEND_SEC 関数ブロックの宣言部分には次の宣言が含まれている必要があります。 uiArraySize: UINT := 7; psNameList: POINTER TO STRING; 。 " }, 
{ "title" : "セクション: 制約 ", 
"url" : "ac_module_fb_sec_constraints.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: 制約 ", 
"snippet" : "制約 この特別なセクションでは、各モジュール インスタンスが別のモジュール インスタンスによって少なくとも 1 回参照されているかどうかをチェックします。 SEC Constraints \/\/optional: yes, modifier: [UPDATE] Referenced_By := <interface name>; \/\/optional: yes, type: QID) Referenced_Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality END_SEC 定義タイプの構文の詳細につ...", 
"body" : "制約 この特別なセクションでは、各モジュール インスタンスが別のモジュール インスタンスによって少なくとも 1 回参照されているかどうかをチェックします。 SEC Constraints \/\/optional: yes, modifier: [UPDATE]\n Referenced_By := <interface name>; \/\/optional: yes, type: QID)\n Referenced_Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\nEND_SEC 定義タイプの構文の詳細については、次の章を参照してください。 モジュール宣言の構文 説明された。 仕様： と Referenced_By モジュールは、その各モジュール インスタンスが別のモジュール インスタンスによって少なくとも 1 回参照される必要があることを指定できます。の値 ReferencedBy によって提供されるインターフェイスである必要があります IModule 派生します。参照しているインスタンスの型が問題でない場合は、ここで行うことができます IModule 指定されること。 Referenced_Cardinality このモジュールを参照する必要がある頻度の範囲を定義します。参照数がこの範囲外の場合、標準ジェネレータで読み込むとエラーとなります。 例 SEC Constraints\n Referenced_By := ISpecificModule;\n Referenced_Cardinality := [1 .. 3];\nEND_SEC " }, 
{ "title" : "セクション: InstRef ", 
"url" : "ac_module_fb_sec_instrefs.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: InstRef ", 
"snippet" : "InstRef セクション InstRefs FB インスタンスまたは構造体インスタンスの参照を定義します。 SEC InstRefs \/\/optional: yes, modifier: [UPDATE] SEC InstRef : <identifier> \/\/target: yes, optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/optional: no, type: InstancePath Desc := <description>; \/\/optional: no, type: text Op...", 
"body" : "InstRef セクション InstRefs FB インスタンスまたは構造体インスタンスの参照を定義します。 SEC InstRefs \/\/optional: yes, modifier: [UPDATE]\n SEC InstRef : <identifier> \/\/target: yes, optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Desc := <description>; \/\/optional: no, type: text\n Optional := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n...\n SEC InstRef_Multi : <identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable for count>; \/\/optional: no, type: InstancePath\n Desc := <description>; \/\/optional: no, type: text\n Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\n END_SEC\nEND_SEC 定義タイプの構文の詳細については、次の章を参照してください。 モジュール宣言の構文 説明された。 仕様： Inst_Ref.Variable 型の変数の入力インスタンス パスを定義します。 POINTER TO <T> またはタイプの <Interface> 。 ( <T> 任意の構造体または FB タイプです。) InstRef_Multi.Variable タイプの入力インスタンスのパスを定義します POINTER TO POINTER TO <T> またはタイプの POINTER TO <Interface> 。 ( <T> 任意の構造体または FB タイプです。) 2 つの異なる InstRef または InstRef-Multi エントリで同じ変数を使用することはできません。 ターゲットはインスタンス参照を一意に識別する必要があります。つまり、2 つの異なるインスタンス参照宣言が存在することはできません (セクション InstRef そして InstRef_Multi ) ターゲットは大文字と小文字を除いて一致します。 による Var_Count アドレス指定された (整数) 入力変数は、全体で 1 回だけ使用できます VarCounts の Slot_Multi または InstRef_Multi 利用される。によって定義される整数変数 Var_Count から VarArray と平行することができます Var_Counts から Slot_Multi または InstRef_Multi 利用される。 例 SEC InstRef_Multi : Elements\n Variable := piElems ;\n Var_Count := uiArraySize ;\n Desc := TL.Elems_Desc ;\n Cardinality := [1 .. 10] ;\nEND_SEC 次の宣言は、関数ブロックの宣言部分になければなりません。 uiArraySize : UINT; piElems : POINTER TO Interface; piElems グローバルに作成され、正しく初期化されたものを指します ARRAY[0..uiArraySize-1] OF Interface または。 OF POINTER TO <T> 、各インスタンスを指します。これは次を使用して実行できます piElems[i] i 番目のオブジェクトにアクセスできます。 " }, 
{ "title" : "セクション: mse.Sequence ", 
"url" : "ac_module_fb_sec_sequence.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: mse.Sequence ", 
"snippet" : "mse.シーケンス フローエディタの定義はこのセクションで定義されます。モジュールエディタが追加タブを使用できるように、このセクションはモジュール宣言に存在する必要があります。 フローエディタ 提供します。 SEC mse.Sequence \/\/optional: yes, modifier: [UPDATE] Root := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag Step := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag Parallel := TRUE\/FALSE; \/\/optional: yes...", 
"body" : "mse.シーケンス フローエディタの定義はこのセクションで定義されます。モジュールエディタが追加タブを使用できるように、このセクションはモジュール宣言に存在する必要があります。 フローエディタ 提供します。 SEC mse.Sequence \/\/optional: yes, modifier: [UPDATE]\n Root := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Step := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Parallel := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Branch := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n VisibleParams := [<visparam1>, <visparam2>,...]; \/\/optional: yes, type: ID-list\n VisibleIOs := [<visIO1>, <visIO2>,...]; \/\/optional: yes, type: ID-list\n VisibleRefs := [<visref1>, <visref2>,...]; \/\/optional: yes, type: ID-list\n AConnectionColor := [<itfname>]; \/\/optional: yes, type: ID-list\n BConnectionColor := [<itfname>]; \/\/optional: yes, type: ID-list\n OnlineActiveVar := <xActive>; \/\/optional: yes, type: ID\n OnlineBreakpointVar := <xBreakpoint>; \/\/optional: yes, type: ID\n OnlineBreakpointActiveVar := <xAvtiveBreakpoint>; \/\/optional: yes, type: ID\n OnlineWatchVars := [<variable1>, <variable2>,...]; \/\/optional: yes\nEND_SEC 定義タイプの構文の詳細については、「 モジュール宣言の構文 説明された。 仕様： モジュールに使用できる定義は 1 つだけです Root 、 Step 、 Parallel または Branch 決意すること。この定義に応じて、モジュールはフロー エディターで次のフロー要素のいずれかによって表されます。 根： のようなシーケンスになります Root マークを付けると、モジュール インスタンスのエディターに追加のタブが表示されます フローエディタ 利用可能。他のすべてのシーケンスの場合、シーケンス エディターは表示されません。長方形の幅はオプションで設定できます。 ステップ： この商品はそれと似ています Root 要素ですが、追加のタブが表示されます フローエディタ 無料ではありません。この要素は、そのセクションに含まれるモジュールの特定のプロパティを指定するために使用されます。 mse.Sequence を表示および調整するように設定されています。 平行： 分岐ステップは、長方形の下の円で表されます。長方形は、そのセクションに含まれるモジュールの特定のプロパティを示すために使用されます。 mse.Sequence を表示および調整するように設定されています。 支店： 決定ステップは、長方形の下のひし形で表されます。長方形は、そのセクションに含まれるモジュールの特定のプロパティを示すために使用されます。 mse.Sequence を表示および調整するように設定されています。 VisibleParams フロー要素の四角形で使用可能なパラメータを設定します。 VisibleIOs フロー要素の四角形で利用可能な EA を指定します。 VisibleRefs フロー要素の四角形で使用可能な参照を設定します。 AConnectionColor ：割り当てられたスロットのモジュールインスタンス間の接続線が の色で表示されます。 接続 描かれた。フローエディタのオプションで設定できます。 BConnectionColor ：割り当てられたスロットのモジュールインスタンス間の接続線が の色で表示されます。 B接続 描かれた。フローエディタのオプションで設定できます。 OnlineActiveVar : このパラメータは、関連するファンクション ブロックまたはそのベース FB の 1 つで宣言する必要があるブール変数に割り当てることができます。オンライン操作では、この変数が設定されている場合、プロセス ステップが黄色で表示されます。 TRUE が設定されています。 OnlineBreakpointVar : このパラメータは、関連するファンクション ブロックまたはそのベース FB の 1 つで宣言する必要があるブール変数に割り当てることができます。オンライン操作では、コマンドは設定またはリセットを行います。 ブレークポイントのオン\/オフを切り替える コンテキスト メニューからブレークポイントを選択します。さらに、代入された変数が表示されます TRUE または。 FALSE セット。オンの場合 TRUE を設定すると、フローエディタ上でステップが赤枠で表示されます。 OnlineBreakpointActiveVar : このパラメータは、関連するファンクション ブロックまたはそのベース FB の 1 つで宣言する必要があるブール変数に割り当てることができます。オンライン操作では、この変数が設定されている場合、プロセスステップが赤色で表示されます。 TRUE が設定されています。 OnlineWatchVars : 以下にリストされているすべての変数 (単純なデータ型) は、ここで変数として使用できます。 VAR_INPUT 、 VAR_OUTPUT 、 VAR または VAR_IN_OUT の FB (またはその基本 FB) を使用できます。複雑な変数タイプ (次の形式) を作成することはできません。 FBInst.xVariable 、など）。変数はカンマで区切られたリストで指定されます。 例 SEC mse.Sequence\n Branch;\n VisibleIOs := [xIn];\n AConnectionColor := [itfSequenceTrue];\n BConnectionColor := [itfSequenceFalse];\n OnlineActiveVar := xActive;\n OnlineBreakpointVar := xBreakpoint;\n OnlineBreakpointActiveVar := xBreakpointActive;\n OnlineWatchVars := [iPartTimeElapsed];\nEND_SEC " }, 
{ "title" : "セクション: デカップリング ", 
"url" : "ac_module_fb_sec_decoupled.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: デカップリング ", 
"snippet" : "分離された このセクションでは、いわゆる「分離されたモジュール」を定義します。これらはトップレベル モジュールのプロパティを持つモジュールですが、特別なスロットのサブモジュールとしても機能します ( Type:= DECOUPLED ) の他のモジュールを挿入することができます。モジュールを「トップレベル」にすることと「分離」することを同時に行うことはできません。 「分離されたモジュール」はセクションを使用して作成されます。 Decoupled モジュール宣言で作成されます。セクション Decoupled セクションとほぼ同じです Toplevel 、モジュール宣言ではこれら 2 つのセクショ...", 
"body" : "分離された このセクションでは、いわゆる「分離されたモジュール」を定義します。これらはトップレベル モジュールのプロパティを持つモジュールですが、特別なスロットのサブモジュールとしても機能します ( Type:= DECOUPLED ) の他のモジュールを挿入することができます。モジュールを「トップレベル」にすることと「分離」することを同時に行うことはできません。 「分離されたモジュール」はセクションを使用して作成されます。 Decoupled モジュール宣言で作成されます。セクション Decoupled セクションとほぼ同じです Toplevel 、モジュール宣言ではこれら 2 つのセクションのうち 1 つだけが許可されます。 SEC Decoupled \/\/optional: yes, modifier: [UPDATE]\n GVL_Name := <GVL name>; \/\/optional: yes, type: literal\n Default_Application := <default application>; \/\/optional: yes, type: QID\n Default_POUPool := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n Toplevel_Insertable := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n SEC Standard_Task : <task name> \/\/optional: yes, modifier: [HIDE,UPDATE]\n Name := <task name>; \/\/optional: no, type: ID\n Desc := <task description>; \/\/optional: no, type: Text)\n Flags:= <flag>; \/\/optional: no, type: StdTaskFlags)\n END_SEC\n SEC Custom_Task : <task name> \/\/optional: yes, modifier: [UPDATE]\n Priority := <priority>; \/\/optional: no, type: Subrange(0 .. 31)\n Interval := <interval>; \/\/optional: no, type: TimeLiteral)\n Flags:= <flag>; \/\/optional: no, type: CustomTaskFlags)\n END_SEC\nEND_SEC 定義タイプの構文の詳細については、「モジュール宣言」の章で説明します。 仕様: セクションの仕様 Decoupled セクションの説明に対応します Toplevel 。さらに、次のパラメータを定義できます。 Toplevel_Insertable 「分離されたサブモジュール」もトップレベル、つまりトップレベルモジュールのように挿入できるかどうかを定義します。 注: 「分離」モジュールは、それに対応するプロキシ代表を定義および実装する必要があります。プロキシは、「分離」モジュール自体と同じインターフェイスを実装する必要があります。親モジュール インスタンスが「分離」モジュール インスタンスとは異なるコントローラーの下にある場合場合でも、「分離された」モジュール インスタンスは、プロキシ代表を介してこのスロットに挿入できます。 こちらも参照 モジュール宣言 最上位セクション " }, 
{ "title" : "セクション: マクロモジュール ", 
"url" : "ac_module_fb_sec_macromodule.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: マクロモジュール ", 
"snippet" : "マクロモジュール このセクションでは、マクロ モジュールのパラメータについて説明します。このセクションは、マクロ モジュールを作成すると自動的に作成されます。セクションをモジュール宣言に手動で挿入したり、自動的に作成されたセクションを編集したりすることもできます。 SEC MacroModule \/\/optional: yes, modifier: None SEC Rootmodule : <identifier> \/\/optional: no, modifier: None SEC MacroParameter : <identifier> \/\/optional: yes, modifie...", 
"body" : "マクロモジュール このセクションでは、マクロ モジュールのパラメータについて説明します。このセクションは、マクロ モジュールを作成すると自動的に作成されます。セクションをモジュール宣言に手動で挿入したり、自動的に作成されたセクションを編集したりすることもできます。 SEC MacroModule \/\/optional: yes, modifier: None\n SEC Rootmodule : <identifier> \/\/optional: no, modifier: None\n SEC MacroParameter : <identifier> \/\/optional: yes, modifier: None\n Local_ParameterID := <parameter ID>; \/\/optional: no, type: ID\n New_Name := <parameter name>; \/\/optional: no, type: text\n New_Desc := <parameter description>; \/\/optional: no, type: text\n END_SEC\n SEC MacroIO : <identifier> \/\/optional: yes, modifier: None\n Local_IOID := <IO ID>; \/\/optional: no, type: ID\n New_Name := <IO name>; \/\/optional: yes, type: text\n New_Desc := <IO description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroSlot : <identifier> \/\/optional: yes, modifier: None\n Local_SlotID := <slot ID>; \/\/optional: no, type: ID\n New_Role := <role name>; \/\/optional: yes, type: text\n END_SEC\n SEC Default_Allocation \/\/optional: no, modifier: None\n Module_Name := <module name>; \/\/optional: no, type: QID\n SEC VisuEmbeddings \/\/optional: yes, modifier: None\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <identifier> \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: no, type: ID\n ProxyVisuName := <proxy visu ID>; \/\/optional: no, type: ID\n Target := <target ID>; \/\/optional: yes, type: ID\n LinkId := <linke ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: yes, type: ID\n TopLevelTab := <top level tab>; \/\/optional: yes, type: ID\/Bool\n END_SEC\n SEC IOMappings : <identifier> \/\/optional: no, modifier: None\n SEC Mapping : <identifier> \/\/optional: yes, modifier: None\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, type: ID\/ST expression\n ModuleConnection := <module connection>; \/\/optional: yes, type: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters : <identifier> \/\/optional: yes, modifier: None\n SEC Param : <identifier> \/\/optional: yes, modifier: None\n Value := <value ID>; \/\/optional: no, type: ID\n END_SEC\n END_SEC\n END_SEC\n END_SEC\n SEC Submodule : <identifier> \/\/optional: yes, modifier: None\n Parent_Instance := <instance ID>; \/\/optional: no, type: ID\n Parent_Slot := <slot ID>; \/\/optional: no, type: ID\n SEC MacroParameter : <identifier> \/\/optional: yes, modifier: None\n Local_ParameterID := <parameter ID>; \/\/optional: no, type: ID\n New_Name := <parameter name>; \/\/optional: yes, type: text\n New_Desc := <parameter description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroIO : <identifier> \/\/optional: yes, modifier: None\n Local_IOID := <IO Id>; \/\/optional: no, type: ID\n New_Name := <IO name>; \/\/optional: yes, type: text\n New_Desc := <IO description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroSlot : <identifier> \/\/optional: yes, modifier: None\n Local_SlotID := <slot ID>; \/\/optional: no, type: ID\n New_Role := <role name>; \/\/optional: yes, type: text\n END_SEC\n SEC Default_Allocation \/\/optional: no, modifier: None\n Module_Name := <module name>; \/\/optional: no, type: QID\n Instance_Name := <instance name>; \/\/optional: no, type: ID\n SEC VisuEmbeddings \/\/optional: no, modifier: None\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <identifier> \/\/optional: yes, modifier: None\n VisuName := <visu ID> \/\/optional: no, type: ID\n ProxyVisuName := <proxy visu ID> \/\/optional: no, type: ID\n Target := <target ID>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: yes, type: ID\n TopLevelTap := <top level tab>; \/\/optional: yes, type: ID\/Bool\n END_SEC\n SEC IOMappings : <identifier> \/\/optional: yes, modifier: None\n SEC Mapping : <identifier> \/\/optional: yes, modifier: None\n NoMapping := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression> \/\/optional: yes, type: ID\/ST expression\n ModuleConnection := <module connection> \/\/optional: yes, type: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier: None\n SEC Param : <identifier> \/\/optional: yes, modifier: None\n Value := <value>; \/\/optional: no, type: ID\n END_SEC\n END_SEC\n END_SEC\n END_SEC\n SEC Reference : <identifier> \/\/optional: yes, modifier: None\n Parent_Instance := <instance ID>; \/\/optional: no, type: ID\n Parent_Slot := <slot ID>; \/\/optional: no, type: ID\n Referenced_Instance := <instance ID>; \/\/optional: no, type: ID\n END_SEC\nEND_SEC 定義タイプの構文の詳細については、「 モジュール宣言の構文 説明された。 仕様： Macro_Module : このセクションが定義されている場合、モジュール宣言全体内でセクション以外の他のセクションは許可されません。 MetaData 利用できるようになります。このセクションの各モジュール宣言は、マクロ モジュール タイプとして明確にマークされています。これ以上のセクションはないかもしれません MacroModule モジュール宣言内で。 Rootmodule : 次のサブセクションで、このマクロ モジュール タイプのルートとなるルート サブモジュールについて説明し、マクロ モジュール タイプの他のすべてのサブモジュールの親として先頭に挿入する必要があることを示します。 Submodule : 次のサブセクションで、マクロ モジュール タイプのルート サブモジュールの下のサブツリー内のどこかに挿入されるサブモジュールについて説明することを示します。 MacroParameter : セクション内のこのようなセクションになります Submodule または Root 使用すると、定義されたサブモジュール (またはルート) の特定のパラメーターがマクロ モジュール自体のパラメーターとして表示されるように指定できます。これがセクションのターゲットになります MacroParameter マクロ モジュール パラメータの新しいパラメータ ID として使用されます。指定されたサブモジュール (またはルート) のパラメーターは、定義を通じて使用されます。 Local_ParameterID 指定された。さらに、定義を使用することもできます New_Name そして New_Desc テキストリストのエントリを指定できます。これらのエントリは、サブモジュールまたはルート パラメータの代わりに、新しいマクロ モジュール パラメータの名前と説明に使用されます。すべてのセクションの指定されたすべてのターゲット MacroParameter すべてのマクロ モジュール パラメータが一意のパラメータ ID を持つように、マクロ モジュール全体内で一意である必要があります。 MacroIO : セクション内にそのようなセクションがある場合 Submodule または Root を使用すると、定義されたサブモジュール (またはルート) の特定の IO がマクロ モジュール自体の IO として表示されるように指定できます。これがセクションのターゲットになります MacroIO マクロ モジュール IO の新しい IO ID として使用されます。指定されたサブモジュール (またはルート) の IO は、定義によって決定されます。 Local_IOID 指定された。さらに、定義を使用することもできます New_Name そして New_Desc テキストリストのエントリを指定できます。これらのエントリは、サブモジュールまたはルート IO の代わりに、新しいマクロ モジュール IO の名前と説明に使用されます。すべてのセクションの指定されたすべてのターゲット MacroIO すべてのマクロ モジュール IO が一意の IO ID を持つように、マクロ モジュール全体内で一意である必要があります。 MacroSlot : セクション内のこのセクションになります Submodule または Root 使用すると、定義されたサブモジュール (またはルート) の特定のスロットがマクロ モジュール自体のスロットとして表示されるように指定できます。これは、追加のモジュール インスタンスをマクロ モジュール インスタンスのこのスロットの下に挿入できることを意味します。これがセクションのターゲットになります MacroSlot マクロ モジュール スロットの新しい SlotID として使用されます。指定されたサブモジュール (またはルート) のスロットは、定義によって決定されます。 Local_SlotID 指定された。さらに、定義を使用することもできます New_Role テキストリストエントリを指定できます。このエントリは、サブモジュールまたはルート スロットの代わりに、新しいマクロ モジュール スロットの「役割」に使用されます。すべてのセクションの指定されたすべてのターゲット MacroSlot すべてのマクロ モジュール スロットが一意のスロット ID を持つように、マクロ モジュール全体内で一意である必要があります。 Parent_Instance : セクションの対象IDとなるIDを指定します Rootmodule または Submodule 周囲のセクション MacroModule 対応します。この定義はセクション内にのみ存在します。 Submodule 。親モジュールのインスタンスを定義し、その下にそれぞれのセクションが配置されます。 Submodule マクロモジュールタイプの説明されたサブモジュールは「挿入」される必要があります。これが定義です Parent_Slot さらに必須です。 Parent_Slot ：スルー以下のスロットのIDに対応するIDを指定します。 Parent_Module 識別されたサブモジュール タイプを見つけることができます。このスロットの下のセクションは次のとおりです Submodule 記述されたマクロモジュールタイプのサブモジュールが挿入されます。 Default_Allocation : スロット宣言の下の同名のセクションと同一です ( Slot そして Slot_Multi ）。このセクションでは、「ルート モジュール」と「サブモジュール」の両方について、マクロ モジュール タイプのどのサブモジュールをどのインスタンス構成で挿入するかを指定します。唯一の違いは、 Default_Allocation セクションの下 Rootmodule いいえ Instance_Name 指定できますが、セクションの下にあります Submodule すでに。その理由は、「ルート モジュール」として挿入されたモジュール インスタンスはマクロ モジュール インスタンスから名前を取得するため、「デフォルト」として指定できないためです。 Reference : 次のサブセクションがモジュール参照について説明していることを示します。これにより、モジュール インスタンスの下に参照が作成されます Parent_Instance スロットの下に Parent_Slot サブモジュールが生成されます。 Referenced_Instance 参照されています。この参照されるインスタンスは次のようにする必要があります Parent_Instance 同じセクションにあるサブモジュールまたはルート モジュール インスタンスのセットから Makro_Module 来る。 マクロモジュールタイプのモジュール宣言は、次の条件を満たす必要があります。 彼女も許されない IMPLEMENTED_BY まだ IMPORTS モジュール宣言で使用します。 彼女にはセクションがあるはずです MetaData そして MacroModule 含む。そうしないと、それ以上のセクションが存在しない可能性があります。 セクションの下 Macro_Modul 少なくとも 1 つのセクションが必要です Rootmodule 利用できるようになります。第二部も無いかもしれない Rootmodule 存在する。 それぞれについて Submodule 以内でなければなりません MacroModule それら両方 Parent_Instance 同様にそのように Parent_Slot 定義される。これは次のように使用する必要があります Local_SlotID 内で MacroSlot の Parent_Instance 定義される。 " }, 
{ "title" : "セクション: デバイスジェネレーター ", 
"url" : "ac_module_fb_sec_devicegenerator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: デバイスジェネレーター ", 
"snippet" : "デバイスジェネレーター 最上位セクション DeviceGenerator デバイス ジェネレーターに関連するすべての定義が含まれています。これには次のサブセクションが含まれます。 サブセクション Device : デバイスをデバイスツリーに追加するための定義 サブセクション Parameter : デバイスパラメータを追加または変更するための定義 接続サブセクション: モジュール I\/O をデバイス I\/O に接続するための定義 サブセクション Wildcards : 「ワイルドカード」デバイスを作成するための定義 サブセクション Demand : 「需要」プロパティを指定するための定義 サブ...", 
"body" : "デバイスジェネレーター 最上位セクション DeviceGenerator デバイス ジェネレーターに関連するすべての定義が含まれています。これには次のサブセクションが含まれます。 サブセクション Device : デバイスをデバイスツリーに追加するための定義 サブセクション Parameter : デバイスパラメータを追加または変更するための定義 接続サブセクション: モジュール I\/O をデバイス I\/O に接続するための定義 サブセクション Wildcards : 「ワイルドカード」デバイスを作成するための定義 サブセクション Demand : 「需要」プロパティを指定するための定義 サブセクション InstRefMapping : 作成したデバイスとモジュールのInstRefを接続するための定義 定義タイプの構文の詳細については、「 モジュール宣言の構文 説明された。 " }, 
{ "title" : "サブセクション: デバイス ", 
"url" : "ac_module_fb_sec_devicegenerator_device.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: デバイスジェネレーター \/ サブセクション: デバイス ", 
"snippet" : "サブセクション Device デバイス ジェネレーターによって追加されるデバイスを定義します。生成されたデバイスにはいくつかのタイプがあり、それぞれに異なるサブセクションがあります。 Identification 、 Wildcard そして FlexibleWildcard 決意すること。 構文： SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC Device : <target ID> \/\/optional: yes, modifier [UPDATE] Parent := <target ID>; \/\/optional...", 
"body" : "サブセクション Device デバイス ジェネレーターによって追加されるデバイスを定義します。生成されたデバイスにはいくつかのタイプがあり、それぞれに異なるサブセクションがあります。 Identification 、 Wildcard そして FlexibleWildcard 決意すること。 構文： SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC Device : <target ID> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n ParentSlotIndex := <slot number>; \/\/optional: yes, type: literal\/integer\n SEC Identification \/\/optional: yes, modifier: [UPDATE]\n Type := <type number>; \/\/optional: no, type: literal\/string\n ID := <ID mumber>; \/\/optional: no, type: literal\/string\n ModuleID := <module ID>; \/\/optional: yes, type: literal\/string\n Version := <version mumber>; \/\/optional: no, type: literal\/string\n SEC SetChildName \/\/optional: yes, modifier: [UPDATE]\n Value := <child name>; \/\/optional: no, type: literal\/string\n ChildIndex := <index number>; \/\/optional: no, type: literal\/string\n END_SEC\n END_SEC\n END_SEC\n SEC ExportDevice \/\/optional: yes, modifier: [UPDATE, HIDE]\n Files :=[<filename1>, <filename2>, ...]; \/\/optional: no, type: string\n END_SEC\nEND_SEC 仕様： セクション Device には、モジュール内で生成された他のデバイス間でそれを一意に識別するターゲット ID があります。この ID を使用してこのデバイスを参照できます。これは主に定義で行われます Parent 他の生成されたデバイスまたは接続された I\/O。 定義 Parent 作成されたデバイスをマウントする必要がある親デバイスを指定します。 親デバイスは、その ID またはパラメータによってまったく識別できません (定義はオプションです)。 親デバイスは、次の方法で詳細に決定されます。 全然そんなことないよ Parent 定義されている場合、利用可能な最初の適切な親デバイスが常に使用され、空の親デバイスが使用されます。 Parent -定義は最初の親モジュールからのみ検索されます。直接の親モジュール自体にデバイスが定義されていない場合、最終的に適合するデバイスが見つかるか、最上位モジュールに到達するまで、親モジュールの履歴が追跡されます。この場合、可能であればその応用機器が使用されます。 デバイス ID またはパラメータでもあります Parent 指定すると、親デバイスの履歴も同様に検索され、出力モジュール自体のデバイスも考慮され、考えられる親デバイスも対応する ID を持っている必要があります。 上記のルールに従って、親デバイスとなる可能性のあるデバイスが見つからない場合は、世代チェック中にエラーが出力されます。 ParentSlotIndex : デバイスが挿入される親デバイスのスロットのインデックス (スロット番号) を指定します。これは、プラグ接続が必要な場合に役立ちます。 サブセクション Identifikation には、追加するデバイスの一意の説明が含まれます。これにより、このタイプへの明確な参照が作成されます Device 製造された。 定義 Type 、 ID 、 ModuleID そして Version セクション Identification 特定のバージョンのデバイス タイプを一意に識別します。たとえば、EtherCAT マスターには次の定義があります。 Type := '64'; ID := '000 0001'; Version := '3.5.1.0'; バージョンとしては * が定義されている場合、デバイスの最新バージョンが常に使用されます。定義の場合 ModuleID が使用されない場合、システムは DeviceIdentification を使用してデバイスを検索します。それ以外の場合は、ModuleIdentification を使用してデバイスを検索します。 定義されたデバイスがデバイス リポジトリに存在しない場合、スキャン プロセス中に対応するエラー メッセージが出力されます。 サブセクション SetChildName 定義とともに Value そして ChildIndex これらのオプションを使用すると、自動的に挿入されたデバイスに付ける名前を指定できます。同じ名前が複数回使用される場合、結果の名前はアンダースコアと数字を追加することによって一意になります。 Value ：デバイスの任意の名前 ChildIndex : 名前を変更する自動挿入デバイスのインデックス このセクションでは、入力ウィザードを使用してフィールドに入力するオプションが提供されます。これを行うには、カーソルを行の末尾に置きます。 Identification セットして 戻る 押されました。次に、アシスタントが開き、利用可能なデバイスが表示されます。デバイスを選択すると、対応するパラメータがモジュール宣言に組み込まれます。この機能はサブセクションの終わり（ END_SEC ）はまだ入力されていません。 定義 ファイル プロジェクトに追加されるデバイスのリストが含まれています。これらのデバイスは手動で構成され、ライブラリにエクスポートされました。 例 SEC Device : Buskoppler2\n SEC Identification\n Type := '65';\n ID := '2_044C2C5200110000';\n Version := '*';\n END_SEC\nEND_SEC\nSEC Device : KlemmeDigitalOutput\n Parent := Buskoppler2;\n SEC Wildcard : KlemmeTyp\n Desc := TL.WildDesc;\n END_SEC\n SEC ExportDevices\n Files := [ExtFile.BK5120_1SDO, ExtFile.BK5120_2SDO];\n END_SEC\nEND_SEC パラメータを使用した例 SEC std.DeviceGenerator\n SEC Device : CANopen_Manager\n Parent := CurrentCAN;\n SEC FlexibleIdentification\n Type := '16';\n ID := '181016';\n Version := '*';\n Maximum := 1;\n END_SEC\n END_SEC\nEND_SEC\nSEC std.Parameters\n SEC Param : CurrentCAN\n Name := TL.CurrentCAN_Name;\n Desc := TL.CurrentCAN_Desc;\n VariableType := wSTRING;\n Default := 'CANBus_0';\n END_SEC\nEND_SEC デバイス名の設定例 SEC std.DeviceGenerator\n\tSEC Device : EcoVario\n\t Parent := CanManager;\n\t\tSEC Identification\n\t\t Type := '18';\n\t\t ID := '1619 0001';\n\t\t Version := '*';\n\t\t SEC SetChildName : ChildDevice\n\t\t\t Value := 'ChildName';\n\t\t\t ChildIndex := 0;\n\t\t END_SEC\n\t END_SEC\n END_SEC\n SEC Parameters : EcoVario\n\t SEC AddParameter : BoolParamAdd\n\t\t ParameterID := '150';\n\t\t ParameterName := 'BoolParam';\n\t \tParameterType := 'std:BOOL';\n\t\t ChildIndex := 0;\n\t END_SEC\n\t SEC SetParameter : BoolParamAdd\n\t\t ParameterID := '150';\n\t\t\tElemPath := '';\n\t\t\tValue := 'TRUE';\n\t\t\tChildIndex := 0;\n\t\tEND_SEC\n\t\tSEC SetParameter : bVirtual\n\t\t\tParameterID := '1040';\n\t\t\tElemPath := '';\n\t\t\tConnectorID := '0';\n\t\t\tValue := 'TRUE';\n\t\t\tChildIndex := 0;\n\t\tEND_SEC\n\tEND_SEC\n SEC InstRefMapping : Axis\n\t SEC Demand\n\t Desc := TL.DescAxis;\n\t\t\tProperties := [SM_DRIVE_CAN];\n\t\tEND_SEC\n\tEND_SEC\nEND_SEC\n " }, 
{ "title" : "サブセクション: 接続 ", 
"url" : "ac_module_fb_sec_devicegenerator_connect.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: デバイスジェネレーター \/ サブセクション: 接続 ", 
"snippet" : "このセクションのこのサブセクション IOMapping モジュール I\/O を指定されたデバイス I\/O に接続します。割り当ては、デバイスの正確な I\/O 分散を知らずに直接行われます。直接接続は、モジュール I\/O と指定されたデバイス I\/O に互換性があることを前提としています。 SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC IOMapping : <mapping identifier> \/\/optional: yes, modifier: [UPDATE] Parent := <target ID>; \/\/o...", 
"body" : "このセクションのこのサブセクション IOMapping モジュール I\/O を指定されたデバイス I\/O に接続します。割り当ては、デバイスの正確な I\/O 分散を知らずに直接行われます。直接接続は、モジュール I\/O と指定されたデバイス I\/O に互換性があることを前提としています。 SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC IOMapping : <mapping identifier> \/\/optional: yes, modifier: [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Connect \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ElemPath := <elempath name>; \/\/optional: no, type: literal\/string\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n END_SEC\n END_SEC\nEND_SEC 仕様： セクション IO 接続されるモジュール I\/O のターゲット ID に対応するターゲットがあります。後者は、デバイス接続が行われるモジュール内で検索されます。適切なモジュール IO が見つからない場合は、スキャン中に対応するエラー メッセージが出力されます。 Parent オプションで、指定したデバイス I\/O (ParamaterID) を検索するデバイスのターゲット ID を指定します。独自のモジュールから開始して、対応する I\/O チャネル\/パラメータを持つ対応するデバイスが見つかるまで、親デバイスの履歴が追跡されます。デバイスが見つからない場合は、世代チェック時にエラーメッセージが出力されます。 セクション Connect モジュール I\/O をデバイス I\/O に直接接続するために必要なすべての定義が含まれています。 ParameterID を与える ParameterID 接続先のデバイスの I\/O チャネルの。モジュール自体によって指定されたデバイス内でこのパラメータを検索しようとします。デバイスが指定されていない場合は、次に考えられる親デバイスでパラメータを検索しようとします。次に、パラメータはモジュール I\/O に接続されます。モジュール階層の作成されたデバイスに、指定されたパラメータを持つ指定されたデバイスがない場合、 ParameterID オファーがある場合、エラーが出力されます。 ElemPath モジュールI\/Oに接続するパラメータのI\/Oチャネル(I\/Oチャネル)の要素を指定します。パスなどを指定することも可能です。 ConnectorID オプションで、その下にあるデバイスのコネクタを指定します。 HostParameterSet の ParameterID 求められることです。いいえの場合 ConnectorID が指定されている場合、 ParameterID 下 DeviceParameterSet 欲しかった。 このセクションでは、入力アシスタントを使用してフィールドに入力するオプションが提供されます。これを行うには、カーソルを行の末尾に置きます。 Connect セットして 戻る 押されました。次に、アシスタントが開いて、利用可能なチャネルを提供します。チャネルを選択すると、対応するパラメータがモジュール宣言に含まれます。この機能はサブセクションの終わり（ END_SEC ）はまだ入力されていません。 例 SEC IOMapping: xIn\n SEC Connect\n ParameterID := '33554434';\n ElemPath := '';\n ConnectorID := '1';\n END_SEC\nEND_SEC " }, 
{ "title" : "サブセクション: 需要 ", 
"url" : "ac_module_fb_sec_devicegenerator_demand.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: デバイスジェネレーター \/ サブセクション: 需要 ", 
"snippet" : "このサブセクションは、 IOMapping デバイス I\/O によって提供される必要があるモジュール I\/O (例: 230V ではなく 24V) の特定のプロパティを定義するために使用されます。 「デマンディング」は、生成時に「オファリング」プロパティとしてデバイスに割り当てることができます。この割り当ては、デバイスの説明に加えて保存されます。 デバイス ジェネレーターの自動 I\/O 接続の場合、これは、「要求された」プロパティを持つ各モジュール I\/O が、デバイスが見つかるまで、その親モジュールでデバイスまたはワイルドカード デバイスを検索することを意味します。 「提供」仕様による。 S...", 
"body" : "このサブセクションは、 IOMapping デバイス I\/O によって提供される必要があるモジュール I\/O (例: 230V ではなく 24V) の特定のプロパティを定義するために使用されます。 「デマンディング」は、生成時に「オファリング」プロパティとしてデバイスに割り当てることができます。この割り当ては、デバイスの説明に加えて保存されます。 デバイス ジェネレーターの自動 I\/O 接続の場合、これは、「要求された」プロパティを持つ各モジュール I\/O が、デバイスが見つかるまで、その親モジュールでデバイスまたはワイルドカード デバイスを検索することを意味します。 「提供」仕様による。 SEC IOMapping : <target> \/\/optional: yes, modifier: [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Demand \/\/optional: yes, modifier: [UPDATE]\n Desc := <description>; \/\/optional: no, type: text\n Properties := [<property1>,<property2>,...]; \/\/optional: no, type: IDList\n END_SEC\nEND_SEC 仕様： サブセクション Demand そして Connect 同時に指定することはできません。 定義 Desc 要求された接続の (ローカライズされた) 説明を (テキスト リストで) 提供します。 Properties モジュール I\/O に必要なプロパティを説明するプロパティのリストを指定します ([Input24V, Digital] など)。複数のプロパティを指定して、個々のモジュール I\/O を分類できます (たとえば、「Property1」のみが必要なモジュール I\/O と、「Property1、Property2」が必要なモジュール I\/O など)。 Parent チャネルを接続する必要があるデバイスの ID を指定します。 「要求の厳しい」I\/O の場合、これらはワイルドカード デバイスになることもあります。 SEC std.DeviceGenerator\n SEC IOMapping : xOn\n SEC Demand\n Desc := TL_Rooms.Role_RoomStandard_Lights;\n Properties := [V24Output];\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "サブセクション: ワイルドカード ", 
"url" : "ac_module_fb_sec_devicegenerator_wildcard.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: デバイスジェネレーター \/ サブセクション: ワイルドカード ", 
"snippet" : "サブセクション Wildcard モジュールの作成時にまだ不明なモジュールのワイルドカード デバイスを作成するために使用されます。デバイスは、生成前または生成中にユーザーが柔軟に指定できる必要があります。 SEC Device : <target> \/\/optional: yes, modifier [UPDATE] Parent := <target ID>; \/\/optional: yes, type: ID SEC Wildcard : <target> \/\/optional: yes, modifier: [UPDATE] Desc := <description>; \/\/option...", 
"body" : "サブセクション Wildcard モジュールの作成時にまだ不明なモジュールのワイルドカード デバイスを作成するために使用されます。デバイスは、生成前または生成中にユーザーが柔軟に指定できる必要があります。 SEC Device : <target> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Wildcard : <target> \/\/optional: yes, modifier: [UPDATE]\n Desc := <description>; \/\/optional: no, type: text\n END_SEC\nEND_SEC 仕様： サブセクション Identification 、 Wildcard そして FlexibleWildcard 同時に使用することはできません。 セクションのターゲット Wildcard ワイルドカードデバイスのタイプを指定します。異なるモジュールは同じタイプのワイルドカード デバイスを持つことができます (例: 「8Inputs」)。同じタイプのすべてのワイルドカード デバイスは、同じデバイスに割り当てられます。 Desc ワイルドカード デバイスの (ローカライズされた) 説明を (テキスト リストで) 提供します。 Parent 前と同様に、目的の親デバイスを指定します。すでにデバイスに割り当てられている場合は、ワイルドカード デバイスもここで使用できます。ワイルドカードデバイスに設定したデバイスが互換性のある親デバイスではない場合、生成時にエラーが出力されます。 例 SEC Device : KlemmeAnalogOutput\n Parent := Buskoppler2;\n SEC Wildcard : KlemmeTyp\n Desc := TL.WildDesc;\n END_SEC\nEND_SEC " }, 
{ "title" : "サブセクション: パラメータ ", 
"url" : "ac_module_fb_sec_devicegenerator_parameter.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: デバイスジェネレーター \/ サブセクション: パラメータ ", 
"snippet" : "セクション Parameter サブセクション付き SetParameter そして AddParameter デバイスのパラメータを編集または追加するために使用されます。これは、デバイス ジェネレーターを通じて特定のデバイス設定 (サイクル タイムなど) を生成できるようにすることを目的としています。 SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC Parameters : <parameter name> \/\/optional: yes, modifier: [UPDATE] SEC SetParameter : <p...", 
"body" : "セクション Parameter サブセクション付き SetParameter そして AddParameter デバイスのパラメータを編集または追加するために使用されます。これは、デバイス ジェネレーターを通じて特定のデバイス設定 (サイクル タイムなど) を生成できるようにすることを目的としています。 SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC Parameters : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n SEC SetParameter : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ElemPath := <elempath name>; \/\/optional: no, type: literal\/string\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n Value := <value name>; \/\/optional: no, type: literal\/string\n ChildIndex := <device ID>;\n Download := <boolean value> \/\/ opional: yes, type: boolean\n END_SEC\n SEC AddParameter : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ParameterName := <parameter name>; \/\/optional: no, type: literal\/string\n ParameterType := <parameter type>; \/\/optional: no, type: literal\/string\n ChannelType := <channel type>; \/\/optional: yes, type: enum\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n ChildIndex := <device ID>;\n END_SEC\n END_SEC\nEND_SEC 仕様： セクション Parameters 目標を持っています DeviceID パラメータを編集するターゲットデバイスの。ターゲット デバイスは、まずモジュール自体のデバイス内で検索され、次にその親履歴内で検索されます。ターゲットは、ワイルドカード デバイスまたは他のデバイスであってもよく、これらに対応するパラメータがあり、対応するパラメータを追加できることが前提となります。ターゲットが見つからない場合は、世代チェック中に警告が発行されます。 各セクションの対象 SetParameter そして AddParameter それぞれのセクションの ID を示しますが、それ以外の用途はありません。 仕様セクション SetParameter : ParameterID を与える ParameterID 変更するデバイスパラメータの値。 ElemPath 実際に変更されるパラメータの正確な要素を指定します。 ConnectorID オプションで、HostParameterSet の下でパラメータ ID を検索するデバイスのコネクタを指定します。いいえの場合 ConnectorID が指定されている場合、 ParameterID DeviceParameterSet の下で検索されました。 Value 指定されたパラメータの要素に割り当てられる値を指定します。この値は要素のタイプと一致する必要があります。この値は、次の形式の式にすることもできます。 [paramID] + 2*MODULE_SLOT_INDEX なれ。これは対応します [paramID] パラメータのターゲット ID。 [paramID] はパラメータの値に置き換えられます。キーワード MODULE_SLOT_INDEX は、定義されたモジュール タイプのモジュール インスタンスが挿入後に持つスロット インデックスに置き換えられます。 対応するターゲット デバイスでパラメータが見つからない場合、生成チェック中に対応する警告が発行されます。 ChildIndex パラメータが追加または設定される子デバイスを定義します。特定のインデックスを持つこの従属デバイスが存在しない場合、ジェネレーターの実行中に警告が生成されます。 Download : オプションのエントリ。このエントリに値がある場合 FALSE パラメータはデバイスにダウンロードされません。これはたとえば非アクティブ化するためのものです CheckVendorId CAN デバイスに役立ちます。 仕様セクション AddParameter : ParameterID 追加するパラメータの新しい ID が含まれます。これは、ターゲット デバイスの他の ParameterID の中で一意である必要があります。 ConnectorID オプションで、HostParameterSet の下にパラメータ ID を追加するデバイスのコネクタを指定します。コネクタ ID が指定されていない場合、パラメータ ID は DeviceParameterSet の下に追加されます。 ParameterName パラメータをターゲットデバイスに追加するときの名前を指定します。 ParameterType ターゲットデバイスに追加されるパラメータのタイプを定義します。このタイプは、タイプ接頭辞が付いた IEC タイプ指定として指定されるため、たとえば std:bool ブール値パラメータが生成されます。 パラメータを追加できない場合は、生成チェック中に対応する警告が発行されます。 ChannelType チャネルのタイプを定義します。可能な値は次のとおりです NONE 、 INPUT 、 OUTPUT そして OUTPUTREADONLY 。 ChildIndex パラメータが追加または設定される子デバイスを定義します。特定のインデックスを持つこの従属デバイスが存在しない場合、ジェネレーターの実行中に警告が生成されます。 2 つのセクション AddParameter そして SetParameter これらを組み合わせて、たとえばデバイスにパラメータを追加し、同時に値を割り当てることができます。 例 SEC Parameters : Buskoppler1\n SEC AddParameter : ExpertSettings\n ParameterID := '805306368';\n ConnectorID := '1';\n ParameterName := 'ExpertSettings';\n ParameterType := 'std:int';\n ChannelType := OUTPUT;\n END_SEC\n SEC SetParameter : ExpertSettings\n ParameterID := '805306368';\n ElemPath := '';\n ConnectorID := '1';\n Value := dwParameterOffset + 2 * MODULE_SLOT_INDEX;\n END_SEC\n END_SEC " }, 
{ "title" : "サブセクション: InstRefMapping ", 
"url" : "ac_module_fb_sec_devicegenerator_instrefmapping.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: デバイスジェネレーター \/ サブセクション: InstRefMapping ", 
"snippet" : "セクション内 InstRefMapping サブセクション付き Demand モジュールの InstRef には、デバイスによって作成された FB インスタンスを自動的に入力できます。 SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC InstRefMapping : <target ID> \/\/optional: yes, modifier [UPDATE] Parent := <target ID>; \/\/optional: yes, type: ID SEC Demand \/\/optional: yes, modifi...", 
"body" : "セクション内 InstRefMapping サブセクション付き Demand モジュールの InstRef には、デバイスによって作成された FB インスタンスを自動的に入力できます。 SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC InstRefMapping : <target ID> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Demand \/\/optional: yes, modifier: [UPDATE]\n Desc := <...>; \/\/optional: no, type: text\n Properties := <...>; \/\/optional: no, type: IDList\n END_SEC\n END_SEC\nEND_SEC 仕様： 上部セクション InstRefMapping 追加のオプションのセクションで提供されます Demand 追加した。上段のターゲット InstRefMapping FB インスタンスが入力されるモジュール内の InstRef 定義の ID を定義します。個々の FB インスタンスのみが個々のデバイスによって作成されるため、個々の InstRef (InstRef_Multi ではない) のみがサポートされます。 定義 Desc 接続のローカライズされた説明を提供します。 定義 Properties たとえば、モジュール InstRef が必要とする FB タイプを記述するプロパティのリストを指定します。複数のプロパティを指定して、個々のモジュール InstRef をモジュール IO と同様に分類することができます。 構文 [<Property1>, <Property2>,...] 、例えば [SoftMotionVirtualDrive, Eigenschaft2] 。 定義 Parent 可能であれば、生成された FB インスタンスを使用して Module InstRef を埋める必要があるデバイスの ID を指定します。要求の厳しい InstRef の場合、ワイルドカード デバイスとハード挿入されたデバイスの両方を使用できます。 例 SEC std.InstRefs\n SEC InstRef : axisRef\n Variable := axis_ref;\n Desc := TL.axisref_Desc ;\n END_SEC\nEND_SEC\n\nSEC std.DeviceGenerator\n SEC Device : virtAxis\n SEC Identification\n Type := '1024';\n ID := 'FFFF 0001';\n Version := '*';\n END_SEC\n END_SEC\n SEC InstRefMapping : axisRef\n SEC Demand\n Desc := TL.axisref_Desc;\n Properties := [VirtualAxis];\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "ジェネレーターのルール ", 
"url" : "ac_module_fb_sec_devicegenerator_generating_rules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ セクション: デバイスジェネレーター \/ ジェネレーターのルール ", 
"snippet" : "デバイス生成ルール 最上位モジュールで指定されたデバイスは、生成されたアプリケーションを含む親デバイスの下にマウントされます。最上位のデバイスは作成されません。 親デバイス ID が指定されていない場合は、一致する最も若い親デバイスが新しい親オブジェクトとして使用されます。子モジュールがデバイスを作成する場合、可能であれば、そのデバイスは親モジュールのデバイス内に作成されます。直接の親モジュールにデバイスがまったくない場合、または子デバイスの下に適合するデバイスを作成しない場合は、親-親モジュールのデバイスが使用されます。作成された使用可能な親デバイスがそれ以上ない場合は、試行が行われます。ト...", 
"body" : "デバイス生成ルール 最上位モジュールで指定されたデバイスは、生成されたアプリケーションを含む親デバイスの下にマウントされます。最上位のデバイスは作成されません。 親デバイス ID が指定されていない場合は、一致する最も若い親デバイスが新しい親オブジェクトとして使用されます。子モジュールがデバイスを作成する場合、可能であれば、そのデバイスは親モジュールのデバイス内に作成されます。直接の親モジュールにデバイスがまったくない場合、または子デバイスの下に適合するデバイスを作成しない場合は、親-親モジュールのデバイスが使用されます。作成された使用可能な親デバイスがそれ以上ない場合は、試行が行われます。トップレベルに入るには、それぞれのトップレベルモジュールのデバイスを生成します。親モジュール オブジェクトによって複数のデバイスが提供される場合、作成されるデバイスが適合する最初のデバイスが使用されます。 こちらも参照 サブセクション: デバイス作成したデバイスの名前は「デバイスID + モジュール名 + デバイス」となります。この名前がすでにデバイスで使用されている場合は、昇順の番号が追加されます。 すでに作成されているデバイスは、再生成時に削除されずに保持されるため、デバイスに設定した内容は可能な限り保持されます。 さらに、モジュール宣言を使用して追加または変更されたパラメータは、生成実行ごとに生成中に対応するデバイスに割り当てられます。 Composer によって作成されたすべてのオブジェクトと同様に、作成されたデバイスもデバイス ツリー内でマークされます。このようなデバイスを変更または削除しようとすると、警告が表示されます。この警告は、たとえば、変更後にモジュール構造が再生成された場合、デバイス設定への変更が失われる可能性があるという事実に注意を促します。 追加のデバイス生成ルール デバイスの挿入時に子デバイスとして自動的に作成されるデバイスは、実際に挿入されたデバイスのモジュール インスタンスの下に分類されます。これらは、モジュール宣言に現れ、挿入されたデバイスの子としてモジュール宣言に登録されたかのように扱われます。子デバイスは再作成も削除もされませんが、親デバイスに関連してのみ表示されます。 デバイスに明示的なコネクタがある場合、別のデバイスとの互換性チェック中に暗黙的なコネクタであるかのように扱われます。これは、最初にすべてのコネクタ (明示的および暗黙的) がデバイスへの接続の対象として考慮され、次に適合するコネクタが接続に使用されることを意味します。デバイス オブジェクトの下で暗黙的に、または独自の親オブジェクトとして明示的に。 " }, 
{ "title" : "アラーム発生器 ", 
"url" : "ac_alarmgenerator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ アラーム発生器 ", 
"snippet" : "アラーム ジェネレーターは、モジュール開発者に、次の機能を備えたモジュールを簡単に作成する方法を提供します。 CODESYS 既存のアラーム管理を装備します。完全なアラーム管理のための機能と、対応する視覚化が作成されます。 この機能は、新しいモジュール宣言を通じて実装されます。 アラームアラーム。これには、アラーム管理に必要なすべての定義が含まれています。 ビジュアライゼーションの作成 生成中に、プロジェクト内のアラームの概要視覚化 (アラーム テーブル) の提案を表すアラーム視覚化イメージが作成されます。このビジュアライゼーションのテンプレートは、アラーム ジェネレーターの設定で選択されます...", 
"body" : "アラーム ジェネレーターは、モジュール開発者に、次の機能を備えたモジュールを簡単に作成する方法を提供します。 CODESYS 既存のアラーム管理を装備します。完全なアラーム管理のための機能と、対応する視覚化が作成されます。 この機能は、新しいモジュール宣言を通じて実装されます。 アラームアラーム。これには、アラーム管理に必要なすべての定義が含まれています。 ビジュアライゼーションの作成 生成中に、プロジェクト内のアラームの概要視覚化 (アラーム テーブル) の提案を表すアラーム視覚化イメージが作成されます。このビジュアライゼーションのテンプレートは、アラーム ジェネレーターの設定で選択されます。 視覚化ジェネレーターがアクティブな場合、作成または再利用された視覚化オブジェクトはタブとしてトップレベルの視覚化に統合されます。 " }, 
{ "title" : "アラームの発生 ", 
"url" : "ac_alarmgenerator.html#UUID-dd47c9b0-4cb3-6491-d721-bbb6aed14278_a4ecc0cda058afc0a8640e004fda36_id_4e1d8099cdf16f9cc0a8640e0073d212", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ アラーム発生器 \/ アラームの発生 ", 
"snippet" : "のすべてのジェネレーターと同様に、 CODESYS Application Composer この発電機は 発電機の構成 アクティブ化または非アクティブ化されます。 ジェネレーターは次の手順を実行します。 アラーム設定オブジェクトは、次の世代で使用するために検索されます。アラーム設定オブジェクトが存在しない場合は、新しいアラーム設定オブジェクトが作成されます。 アラーム保存オブジェクトは、アラーム設定オブジェクトの下で検索されます。アラーム ストレージ オブジェクトがない場合は、アラーム ストレージ テンプレートが使用されます。このテンプレートは、アラーム ジェネレータのジェネレータ設定で設定...", 
"body" : "のすべてのジェネレーターと同様に、 CODESYS Application Composer この発電機は 発電機の構成 アクティブ化または非アクティブ化されます。 ジェネレーターは次の手順を実行します。 アラーム設定オブジェクトは、次の世代で使用するために検索されます。アラーム設定オブジェクトが存在しない場合は、新しいアラーム設定オブジェクトが作成されます。 アラーム保存オブジェクトは、アラーム設定オブジェクトの下で検索されます。アラーム ストレージ オブジェクトがない場合は、アラーム ストレージ テンプレートが使用されます。このテンプレートは、アラーム ジェネレータのジェネレータ設定で設定されます。選択肢があれば ストレージがありません が選択されている場合、アラーム ストレージ テンプレートは使用されず、アラーム ストレージなしで続行されます。スキャン中に複数のアラーム ストレージ オブジェクトが見つかった場合、エラー メッセージが発行されます。 アラーム設定オブジェクトの下で、定義内のモジュールの説明で指定された名前を持つアラーム クラス オブジェクトが検索されます。 alg.Alarm.SetAlarm.Class 定義されています。対応するアラーム クラス オブジェクトが見つかった場合は、それらが使用されます。対応するアラーム クラスが見つからない場合は、新しいアラーム クラスの作成が試行されます。ここでの前提条件は、アラーム クラス テンプレートとして使用できるように、適切な名前のアラーム クラス テンプレート オブジェクトがプロジェクトの POU プールまたは参照ライブラリにテンプレートとして存在することです。一致するアラーム クラス テンプレート オブジェクトがない場合は、エラーがスローされます。 " }, 
{ "title" : "セクション: alg.アラーム ", 
"url" : "ac_module_fb_sec_alarm.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ アラーム発生器 \/ セクション: alg.アラーム ", 
"snippet" : "アラームアラーム セクション SEC alg.Alarm モジュールアラームを定義します。モジュール アラームは基本的に、モジュールからのアラームに対応します。 CODESYS - アラームグループで設定されたアラーム管理。ただし、モジュール アラームにはモジュール固有の追加が含まれています。 詳細については、次の章を参照してください モジュール宣言の構文 そして オブジェクト: アラームグループ...", 
"body" : "アラームアラーム セクション SEC alg.Alarm モジュールアラームを定義します。モジュール アラームは基本的に、モジュールからのアラームに対応します。 CODESYS - アラームグループで設定されたアラーム管理。ただし、モジュール アラームにはモジュール固有の追加が含まれています。 詳細については、次の章を参照してください モジュール宣言の構文 そして オブジェクト: アラームグループ " }, 
{ "title" : "仕様 ", 
"url" : "ac_module_fb_sec_alarm.html#UUID-e8936893-7db9-1fda-4737-bf3cf49fe064_aa4c0cec89085aac0a8640e01a3c6fe_id_355d83fb191b4801c0a864637767cb78", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ アラーム発生器 \/ セクション: alg.アラーム \/ 仕様 ", 
"snippet" : "SEC alg.Alarm \/\/optional: yes, modifier: [UPDATE] SEC SetAlarm <alarm identifier> \/\/optional: yes, modifier [UPDATE] Class := <class name>; \/\/optional: no, type: ID Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry LatchVar1 := <LatchVariable1>; \/\/optional: yes, type: InstancePath Latc...", 
"body" : "SEC alg.Alarm \/\/optional: yes, modifier: [UPDATE]\n SEC SetAlarm <alarm identifier> \/\/optional: yes, modifier [UPDATE]\n Class := <class name>; \/\/optional: no, type: ID\n Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry\n LatchVar1 := <LatchVariable1>; \/\/optional: yes, type: InstancePath\n LatchVar2 := <LatchVariable2>; \/\/optional: yes, type: InstancePath\n Deactivation := <DeactivationVariable>; \/\/optional: yes, type: InstancePath\n PendingTime := <PendingTime>; \/\/optional: yes, type: LiteralOrConstant\n PendingTimeParameter := <string> \/\/optional: no, type: literal\/string\n HigherPrioAlarm := <HigherPrioAlarm_ID>; \/\/optional: yes, type: ID\n ModuleCalls := <ModuleCallFlags>; \/\/optional: yes, type: ModuleCallFlag\n SEC Messages : <alarm identifier> \/\/optional: yes, modifier: [UPDATE]\n Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry\n Number := <ColumnNumber>; \/\/optional: no, type: Literal\n END_SEC\n SEC LatchVar <latch var identifier> \/\/optional: yes, modifier [UPDATE]\n LatchVar := <LatchVariable>; \/\/optional: no, type: InstancePath\n Number := <LatchVarNumber> \/\/optional: no, type: LiteralOrConstant\n END_SEC\n SEC UpperLimit \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n IncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n UpperExpression := <UpperExpression>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC LowerLimit \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n IncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n LowerExpression := <LowerExpression>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC InsideRange \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n AreaLow := <AreaLowValue>; \/\/optional: no, type: Literal\/String\n LowIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n HighIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n AreaHigh := <AreaHighValue>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC OutsideRange \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n AreaLow := <AreaLowValue>; \/\/optional: no, type: Literal\/String\n LowIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n HighIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n AreaHigh := <AreaHighValue>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC Digital \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n Equal := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n EqualsExpression := <Expression>; \/\/optional: no, type: Literal\/String\n END_SEC\n SEC Change \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n END_SEC\n SEC Event \/\/optional: yes, modifier: [UPDATE]\n END_SEC\n END_SEC\nEND_SEC SEC SetAlarm のサブセクション SetAlarm アラームに必要な、またはアラームに可能なすべてのプロパティを定義します。の目標 SetAlarm モジュールの他のアラームの中からアラームを識別し、後者を参照するために使用されます（主に定義内） HigherPrioAlarm ）。 Class アラームが存在するアラーム クラス名。 アラーム クラスがアプリケーションにすでに存在する場合、アラームはこのクラスの下に自動的に作成されます。クラスが存在しない場合は、ビュー内にあるアラーム クラス テンプレート オブジェクトを検索します。 POU 嘘をつかなければなりません。対応するアラーム クラス テンプレート オブジェクトが見つからない場合、モジュール スキャンはエラーを返します。 Message ID (フォームの TextListenName.TextListenEintragID ) アラームテキストのテキストリストエントリの アラーム グループ設定内のテキストにワイルドカードを含めることができるのと同様に、ID によって参照されるメッセージにはワイルドカードを含めることができます。たとえば、次のようなワイルドカード LATCH1 または LATCH2 利用される。 指定されたテキスト リスト エントリが見つからない場合、スキャンによって警告が発行されます。 設定に対応 ニュース オブジェクトの中で アラームグループ 。 LatchVar1 LatchVar2 プレースホルダー変数 モジュール固有のアラームの現在のケースでは、モジュール FB から変数のみを直接指定できます (パラメータの変数がモジュール宣言で指定されるのと同様)。 設定に対応 ラッチ変数1 \/ ラッチ変数2 プレースホルダー用 <LATCH1> \/ <LATCH2> オブジェクトの中で アラームグループ 。 Deactivation 非アクティブ化変数 ( BOOL ）。 TRUE : 定義されたアラームを無効にします。やはりモジュール FB 変数のみを指定できます。 以外の型の変数の場合 BOOL が指定されている場合、スキャン中にエラーが返されます。 設定に対応 非アクティブ化 オブジェクトの中で アラームグループ」 。 PendingTime 最小限の待ち時間。アラームが限界に達してから実際にトリガーされるまでの時間を指定します。 例： TIME#5S 設定に対応 最小待ち時間 オブジェクトの中で アラームグループ 。 PendingTimeParameter 最小待ち時間を設定するパラメータ パラメータに割り当てられる値は、時間として解釈できる文字列です。または、モジュール パラメーターと時間リテラルで構成される式として。 例： TIME#5S 'NoVar' 'WithVar' 'WithVar - NoVar + TIME#5S' HigherPrioAlarm 優先度の高いアラームのID 現在のアラームが分類されるアラームを識別するために、現在のモジュールのアラームにはターゲット ID が使用されます。 SetAlarm セクションが指定されています。の周辺 SetAlarm - 対応するターゲット ID を持つセクションは、親モジュール インスタンス内で独自のモジュールから上位に階層的に検索され、アラーム宣言の下で適切な ID が検索されます。対応する親アラームが見つからない場合、ジェネレーターのチェック中にエラーが発行されます。 設定に対応 優先度の高いアラーム オブジェクトの中で アラームグループ 。 ModuleCalls モジュール固有のアラーム管理の場合、モジュール FB は、モジュール アラームがトリガーされたときに呼び出すことができる特定のインターフェイスを提供できます。フラグによって、どのような場合にこれが発生するかが決まります。 ModuleCallFlags 利用可能なもの: NONE ：通話は発生しません。 THIS : 呼び出しは、独自のモジュール アラームに対してのみ発生します。 PARENTS : このモジュールのすべての親モジュールで呼び出しが発生します。 ALL : 呼び出しはすべてのモジュールで発生します。 このフラグを介して呼び出されるモジュール FB には、インターフェイスが必要です。 IModuleAlarming 実装する。その後、関数を介して呼び出しが行われます ConsumeModuleAlarm このインターフェース。 最上位モジュールの場合、フラグ PARENTS が指定されている場合、スキャン中に警告が発行されます (このフラグはトップレベルモジュールには設定できないため)。 SEC Messages サブセクションはパラメータと同じタスクを実行します。 Message ただし、アラームごとに複数のメッセージを許可します。 (古い) パラメータ Message 互換性上の理由から、引き続き有効です。メッセージには、アラーム グループ設定内の実際のテキストと同じプレースホルダを含めることができます。つまりなどのプレースホルダーも <LATCH1> または <LATCH2> に使える。指定されたテキスト リスト エントリが見つからない場合、スキャンによって警告が発行されます。 Messages : テキスト リスト エントリ形式のアラーム テキスト (形式 TextListenName.TextListenEintragID ) Number : 出力が発生するアラーム テーブルの列。 SEC LatchVar ラッチ変数。このセクションでは、最大 10 個のラッチ変数を定義できます。 このセクションに加えてエントリがある場合、 LatchVar1 または LatchVar2 が定義されている場合は、このセクションの変数が使用されます。 LatchVar : ラッチ変数 Number ：ラッチ変数を識別する番号 SEC UpperLimit SEC LowerLimit 上限または下限を超えたときにトリガーされるアラームのアラーム条件を指定します。 セクションの下で 1 回のみ使用できます SEC SetAlarm 現れる。そうでない場合、スキャンはエラーをスローします。 Expression : チェック中の IEC 式または値。モジュールFBのローカル変数とグローバル定数を式で使用できます。 IncludeBorder : TRUE 対応する <= ( UpperLimit ） または >= ( LowerLimit ）。 FALSE 対応する < ( UpperLimit ） または > ( LowerLimit ）。 UpperExpresssion 、 LowerExpresssion : IEC 式またはそれに対する値 表現 にチェックが入っています。モジュールFBのローカル変数とグローバル定数を式で使用できます。 Hysteresis : アラームのヒステリシス (%)。 設定に対応 上限 \/ 下限 オブジェクト内の監視タイプの場合 アラームグループ 。 SEC InsideRange SEC OutsideRange 式が特定の値の範囲内または範囲外になったときにトリガーされるアラームを定義するアラーム条件。 セクションの下で 1 回のみ使用できます SEC SetAlarm 現れる。そうでない場合、スキャンはエラーをスローします。 Hysteresis : アラームヒステリシス (%) Expression : IEC 式または値がチェックされています。モジュールFBのローカル変数とグローバル定数を式で使用できます。 AreaLow ：範囲の下限値（値またはIEC式）。モジュールFBのローカル変数とグローバル定数を式で使用できます。 LowIncludeBorder : ブール値フラグは、下限値自体を比較範囲にカウントするかどうかを決定します ( <= ) HighIncludeBorder : ブール値フラグは、上限値自体を比較範囲にカウントするかどうかを決定します ( >= ) AreaHigh ：範囲（数値またはIEC式）の上限。モジュールFBのローカル変数とグローバル定数を式で使用できます。 設定に対応 範囲内 \/ 範囲外 オブジェクト内の監視タイプの場合 アラームグループ 。 SEC Digital 2 つの式が相互に比較されたときにトリガーされるアラームのアラーム条件。 セクションの下で 1 回のみ使用できます SEC SetAlarm 現れる。そうでない場合、スキャンはエラーをスローします。 Expression : チェック中の IEC 式または値。モジュールFBのローカル変数とグローバル定数を式で使用できます。 Equal : TRUE \/ FALSE : 式 (値または IEC 式) が等しいかどうかがチェックされます。 EqualsExpression : IEC 式またはそれに対する値 Expression にチェックが入っています。モジュールFBのローカル変数とグローバル定数を式で使用できます。 設定に対応 デジタル オブジェクト内の監視タイプの場合 アラームグループ 。 SEC Change 式の値が変更されたときにトリガーされるアラーム。 セクションの下で 1 回のみ使用できます SEC SetAlarm 現れる。そうでない場合、スキャンはエラーをスローします。 Expression : 変更がチェックされる IEC 式または値。モジュールFBのローカル変数とグローバル定数を式で使用できます。 設定に対応 変化 オブジェクト内の監視タイプの場合 アラームグループ 。 SEC Event 現在のアラーム セクションがイベント アラームを生成していることを示します。これは関数で実現できます RaiseModuleEvent() 図書館から AC_Alarming 引き起こされること。 " }, 
{ "title" : "例 ", 
"url" : "ac_module_fb_sec_alarm.html#UUID-e8936893-7db9-1fda-4737-bf3cf49fe064_aa4c0cec89085aac0a8640e01a3c6fe_id_00a4549e191b4801c0a8646366566922", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ アラーム発生器 \/ セクション: alg.アラーム \/ 例 ", 
"snippet" : "値の範囲 SEC SetAlarm : ValueRange Class := Error; Message := TL.Alarm_Temperature; LatchVar1 := rAlarmValueLow; LatchVar2 := rAlarmValueHigh; ModuleCalls := THIS | PARENTS; SEC Messages : msg2 Message := TL.msg5_Message; Number := 5; END_SEC SEC OutsideRange Expression := 'rValue'; AreaLow := 'rAlarmVa...", 
"body" : "値の範囲 SEC SetAlarm : ValueRange\n Class := Error;\n Message := TL.Alarm_Temperature;\n LatchVar1 := rAlarmValueLow;\n LatchVar2 := rAlarmValueHigh;\n ModuleCalls := THIS | PARENTS;\n SEC Messages : msg2\n Message := TL.msg5_Message;\n Number := 5;\n END_SEC\n SEC OutsideRange\n Expression := 'rValue';\n AreaLow := 'rAlarmValueLow';\n LowIncludeBorder := TRUE;\n HighIncludeBorder := TRUE;\n AreaHigh := 'rAlarmValueHigh';\n END_SEC\nEND_SEC セクション PendingTime SEC alg.Alarm\n\tSEC SetAlarm : NoVar\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'NoVar';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\n\tSEC SetAlarm : WithVar\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'WithVar';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\n\tSEC SetAlarm : SimpleMath\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'WithVar - NoVar + TIME#5S';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\t\n\tSEC SetAlarm : NoParam\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTime := TIME#5S;\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\nEND_SEC " }, 
{ "title" : "フロン発生器 ", 
"url" : "ac_cfc_generator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ フロン発生器 ", 
"snippet" : "CFC ジェネレーターは、モジュール FB インスタンスへの呼び出しを含むことができる CFC プログラムを自動的に作成します。生成された CFC プログラムはカスタマイズ可能です。プログラムへの変更は、ジェネレーターが再度実行されても保持されます。...", 
"body" : "CFC ジェネレーターは、モジュール FB インスタンスへの呼び出しを含むことができる CFC プログラムを自動的に作成します。生成された CFC プログラムはカスタマイズ可能です。プログラムへの変更は、ジェネレーターが再度実行されても保持されます。 " }, 
{ "title" : "セクション: CFC作成 ", 
"url" : "ac_module_fb_sec_cfccreation.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ フロン発生器 \/ セクション: CFC作成 ", 
"snippet" : "CFC作成 このセクションには、CFC ジェネレーターによって解釈されるすべてのサブセクションが含まれています。 SEC cfc.CFCCreation SEC CreateCFCProgram : <CFC program identifier> \/\/optional: yes, modifier [UPDATE] StandardCallTask := <Task type>; \/\/optional: yes, type: ID CustomCallTask := <Task type>; \/\/optional: yes, type: ID ParentFolder := <create ...", 
"body" : "CFC作成 このセクションには、CFC ジェネレーターによって解釈されるすべてのサブセクションが含まれています。 SEC cfc.CFCCreation\n\n SEC CreateCFCProgram : <CFC program identifier> \/\/optional: yes, modifier [UPDATE]\n StandardCallTask := <Task type>; \/\/optional: yes, type: ID\n CustomCallTask := <Task type>; \/\/optional: yes, type: ID\n ParentFolder := <create folder ID; \/\/optional: yes, type: ID\n END_SEC\n\n SEC CreateCFCModuleCall \/\/optional: yes, modifier [UPDATE]\n PreferredCFCProgram := <CFC program> \/\/optional: yes; type: FB type\n END_SEC\n\n SEC CreateCFCIOCall : <CFC IO call ID> \/\/ optional: yes; modifier [UPDATE]\n FB := <FB name>; \/\/ optional: no; type: FB type\n PreferredCFCProgram := <CFC program> \/\/ optional: yes; type: FB type\n FBInstanceBaseName := AInput; \/\/ optional: yes; type: identifier\n END_SEC\n\n SEC CreateFolder : <folder ID> \/\/optional: yes, modifier [UPDATE]\n ParentFolder := <folder name>; \/\/optional: yes, type: ID\n END_SEC\n\nEND_SEC 定義タイプの構文の詳細については、「 モジュール宣言の構文 説明された。 " }, 
{ "title" : "サブセクション:CFCプログラムの作成 ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_bddcc1eb1403f77cc0a8640e01907eda", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ フロン発生器 \/ セクション: CFC作成 \/ サブセクション:CFCプログラムの作成 ", 
"snippet" : "モジュール宣言がセクションの場合 cfc.CFCCreation サブセクションも含めて CreateCFCProgram CFC プログラムは、関連付けられたモジュール タイプに対して作成されます。 CFC プログラムは、次に上位のトップレベル\/分離された親モジュール インスタンスのターゲット アプリケーションの下に作成されます。定義の助けを借りて CustomCallTask または StandardCallTask 結果の CFC プログラムを呼び出すためにどのタスクを使用するかを指定できます。 仕様： セクションのターゲット CreateCFCProgram このモジュール タイプの ...", 
"body" : "モジュール宣言がセクションの場合 cfc.CFCCreation サブセクションも含めて CreateCFCProgram CFC プログラムは、関連付けられたモジュール タイプに対して作成されます。 CFC プログラムは、次に上位のトップレベル\/分離された親モジュール インスタンスのターゲット アプリケーションの下に作成されます。定義の助けを借りて CustomCallTask または StandardCallTask 結果の CFC プログラムを呼び出すためにどのタスクを使用するかを指定できます。 仕様： セクションのターゲット CreateCFCProgram このモジュール タイプの CFC プログラムを識別します。モジュール タイプには、そのモジュール インスタンス用に定義および作成された複数の CFC プログラムが含まれる可能性があります。 定義の一つが StandardCallTask または CustomCallTask 必ず存在する必要がありますが、両方を存在させることはできません。 のために StandardCallTask 3つのIDです LOW 、 MEDIUM そして HIGH 次に上位のトップレベル\/分離された親モジュールインスタンス内のそれぞれのタスクを指定するものを利用できます。 のために CustomCallTask 1 つ上のトップレベル\/分離された親モジュール インスタンスのそれぞれのカスタム タスクに使用されたすべてのターゲット ID が利用可能です。 で ParentFolder セクションのターゲット ID を指定できます CreateFolder 入力される。これにより、生成された CFC プログラムがこのサブフォルダー ( CreateFolder ） 作成した。 " }, 
{ "title" : "サブセクション: CreateCFCModuleCall ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_4225fb301403f77dc0a8640e01bbc228", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ フロン発生器 \/ セクション: CFC作成 \/ サブセクション: CreateCFCModuleCall ", 
"snippet" : "モジュール宣言がセクションの場合 cfc.CFCCreation サブセクションも含めて CreateCFCModuleCall モジュール インスタンス FB への呼び出しは、次に上位の親モジュール インスタンスの CFC プログラム内の関連するモジュール タイプに対して生成されます。 仕様： PreferredCFCProgram 複数の CFC プログラムが利用可能な場合に、どの CFC プログラムを使用するかを指定します。...", 
"body" : "モジュール宣言がセクションの場合 cfc.CFCCreation サブセクションも含めて CreateCFCModuleCall モジュール インスタンス FB への呼び出しは、次に上位の親モジュール インスタンスの CFC プログラム内の関連するモジュール タイプに対して生成されます。 仕様： PreferredCFCProgram 複数の CFC プログラムが利用可能な場合に、どの CFC プログラムを使用するかを指定します。 " }, 
{ "title" : "サブセクション: CreateCFCIOCall ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_72ec1fc41403f77ec0a8640e00114156", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ フロン発生器 \/ セクション: CFC作成 \/ サブセクション: CreateCFCIOCall ", 
"snippet" : "このセクションは、モジュール タイプまたはモジュール宣言の I\/O を識別するために使用されます。指定されたタイプの FB インスタンスがこれらの I\/O に対して作成され、CFC プログラム内でその呼び出しが生成されます。 仕様： セクションの目標とは CreateCFCIOCall I\/O FB がグローバルに作成され、CFC プログラム内で呼び出されるモジュール I\/O ID が指定されます。 FB グローバルにインスタンス化され、上記の I\/O FB に対して呼び出される関数ブロックのタイプを指定します。 PreferredCFCProgram 複数の CFC プログラムが利用可能な場...", 
"body" : "このセクションは、モジュール タイプまたはモジュール宣言の I\/O を識別するために使用されます。指定されたタイプの FB インスタンスがこれらの I\/O に対して作成され、CFC プログラム内でその呼び出しが生成されます。 仕様： セクションの目標とは CreateCFCIOCall I\/O FB がグローバルに作成され、CFC プログラム内で呼び出されるモジュール I\/O ID が指定されます。 FB グローバルにインスタンス化され、上記の I\/O FB に対して呼び出される関数ブロックのタイプを指定します。 PreferredCFCProgram 複数の CFC プログラムが利用可能な場合に、どの CFC プログラムを使用するかを指定します。 FBInstanceBaseName 作成された I\/O FB の名前を付けるために使用される「ベース名」を定義できます。この定義が存在しない場合は、モジュール インスタンスの名前が「ベース名」として使用されます。 " }, 
{ "title" : "サブセクション: フォルダーの作成 ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_a2dd1e181403f77ec0a8640e013c4468", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ モジュール宣言 \/ フロン発生器 \/ セクション: CFC作成 \/ サブセクション: フォルダーの作成 ", 
"snippet" : "このセクションは、フォルダーの下にサブフォルダーを作成するために使用されます。 AC_CFC_Programs 作成します。したがって、セクションでは、 CreateCFCProgram ある ParentFolder 指定されること。その後、CFC プログラムは、 CreateFolder セクションが作成されます。ディレクトリには独自のディレクトリを持つことができます ParentFolder 追加のサブディレクトリとサブサブディレクトリを指定します。 仕様： で ParentFolder セクションのターゲット ID を指定できます CreateFolder 入力される。これにより、作成...", 
"body" : "このセクションは、フォルダーの下にサブフォルダーを作成するために使用されます。 AC_CFC_Programs 作成します。したがって、セクションでは、 CreateCFCProgram ある ParentFolder 指定されること。その後、CFC プログラムは、 CreateFolder セクションが作成されます。ディレクトリには独自のディレクトリを持つことができます ParentFolder 追加のサブディレクトリとサブサブディレクトリを指定します。 仕様： で ParentFolder セクションのターゲット ID を指定できます CreateFolder 入力される。これにより、作成されたディレクトリがこのサブフォルダーに配置されます ( CreateFolder ） 作成した。 例 SEC cfc.CFCCreation\n SEC CreateCFCProgram : Standard\n StandardCallTask := MEDIUM;\n ParentFolder := SubFolderUnderFolder;\n END_SEC\n SEC CreateFolder : SubFolderUnderFolder\n ParentFolder := SubFolder;\n END_SEC\nEND_SEC " }, 
{ "title" : "ライブラリ: AC_ModuleBase ", 
"url" : "ac_library.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ ライブラリ: AC_ModuleBase ", 
"snippet" : "モジュールベースライブラリはモジュールコンセプトの一部です CODESYS Application Composer 。モジュール ツリー コンフィギュレータでユーザーが使用できるすべてのモジュールは、この基本ライブラリから派生する必要があります。 トップレベルへのナビゲーション 機能付き GetToplevelRange 範囲ブロックが返されます (タイプ SiblingRange ) すべてのトップレベルのインスタンスにアクセスできます。 GetToplevelInstance 、指定されたインスタンスが関連付けられているトップレベルのモジュールを返します。...", 
"body" : "モジュールベースライブラリはモジュールコンセプトの一部です CODESYS Application Composer 。モジュール ツリー コンフィギュレータでユーザーが使用できるすべてのモジュールは、この基本ライブラリから派生する必要があります。 トップレベルへのナビゲーション 機能付き GetToplevelRange 範囲ブロックが返されます (タイプ SiblingRange ) すべてのトップレベルのインスタンスにアクセスできます。 GetToplevelInstance 、指定されたインスタンスが関連付けられているトップレベルのモジュールを返します。 " }, 
{ "title" : "インスタンス名 ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_f44958df1c1aa580c0a8640e00033aeb", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ ライブラリ: AC_ModuleBase \/ インスタンス名 ", 
"snippet" : "モジュールの基本クラスにはプロパティ (get) があります。 InstanceName 、インスタンス名を文字列として返します。 のプロパティ IInstanceBase : PROPERTY InstanceName : STRING(255) 戻り値: モジュールインスタンスのインスタンス名 プロキシ インスタンスは、他のアプリケーションのモジュール インスタンスのインスタンス名を提供します。...", 
"body" : "モジュールの基本クラスにはプロパティ (get) があります。 InstanceName 、インスタンス名を文字列として返します。 のプロパティ IInstanceBase : PROPERTY InstanceName : STRING(255) 戻り値: モジュールインスタンスのインスタンス名 プロキシ インスタンスは、他のアプリケーションのモジュール インスタンスのインスタンス名を提供します。 " }, 
{ "title" : "モジュール情報 ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_a581c7b51c1aa580c0a8640e012cbe1e", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ ライブラリ: AC_ModuleBase \/ モジュール情報 ", 
"snippet" : "PROPERTY ModuleInfo : POINTER TO ModuleInfo : このプロパティは、メソッドを使用して ModuleInfo 関数ブロックへのポインタを与えます。 PROPERTY ModuleType : STRING(255) 戻る。 PROPERTY ModuleType : STRING(255) : このプロパティは、含まれるライブラリの名前空間で修飾されたモジュールの修飾モジュール名を返します。 (名前空間はプライマリ プロジェクトに関連しています。)...", 
"body" : "PROPERTY ModuleInfo : POINTER TO ModuleInfo : このプロパティは、メソッドを使用して ModuleInfo 関数ブロックへのポインタを与えます。 PROPERTY ModuleType : STRING(255) 戻る。 PROPERTY ModuleType : STRING(255) : このプロパティは、含まれるライブラリの名前空間で修飾されたモジュールの修飾モジュール名を返します。 (名前空間はプライマリ プロジェクトに関連しています。) " }, 
{ "title" : "インスタンスパス ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_247de8bc1c1aa581c0a8640e00b26998", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ ライブラリ: AC_ModuleBase \/ インスタンスパス ", 
"snippet" : "関数 GetInstancePath(IModule) モジュール インスタンスのインスタンス パスを返します。インスタンス パスは、最上位モジュールから指定されたインスタンスまで、すべての祖先のインスタンス名を連結することによって形成されます。インスタンス名はドットで区切られます。結果のインスタンス名が 255 文字を超える場合は、空の文字列が返されます。 PROPERTY InstancePath : STRING(255)...", 
"body" : "関数 GetInstancePath(IModule) モジュール インスタンスのインスタンス パスを返します。インスタンス パスは、最上位モジュールから指定されたインスタンスまで、すべての祖先のインスタンス名を連結することによって形成されます。インスタンス名はドットで区切られます。結果のインスタンス名が 255 文字を超える場合は、空の文字列が返されます。 PROPERTY InstancePath : STRING(255) " }, 
{ "title" : "フラットナビゲーション ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_acbf32a81c1aa581c0a8640e0039f1c2", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ ライブラリ: AC_ModuleBase \/ フラットナビゲーション ", 
"snippet" : "機能付き GetPrevModule(IModule) そして GetNextModule(IModule) ツリーをフラットなモジュール インスタンス リストとして解釈すると、前または次の要素にジャンプできます。モジュールは深さ優先の事前順序で返されます。前または次の要素がない場合、モジュール参照はスキップされます。 あるいは、ファンクションブロックも使用できます。 DepthFirstRange 指定されたインスタンスから始まるすべてのインスタンスを列挙する関数を使用できます。 GetDepthFirstRange 範囲ブロック（タイプ DepthFirstRange ) は、指定されたイ...", 
"body" : "機能付き GetPrevModule(IModule) そして GetNextModule(IModule) ツリーをフラットなモジュール インスタンス リストとして解釈すると、前または次の要素にジャンプできます。モジュールは深さ優先の事前順序で返されます。前または次の要素がない場合、モジュール参照はスキップされます。 あるいは、ファンクションブロックも使用できます。 DepthFirstRange 指定されたインスタンスから始まるすべてのインスタンスを列挙する関数を使用できます。 GetDepthFirstRange 範囲ブロック（タイプ DepthFirstRange ) は、指定されたインスタンスから始まるツリー全体を列挙します。 " }, 
{ "title" : "階層ナビゲーション ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_1e4f5ff21c1aa58ec0a8640e0059614e", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ ライブラリ: AC_ModuleBase \/ 階層ナビゲーション ", 
"snippet" : "インターフェイスについて IModuleTree モジュールツリーをナビゲートできます。このインターフェイスからのオブジェクトは、次の型のインスタンスへのポインタを介して各モジュールに与えられます。 MEnv 利用可能になりました。このポインタは関数で使用されます SetIdentification パスされました。ナビゲーション中に参照がスキップされることに注意してください。子ノードの順序は、モジュール ツリー内のモジュール インスタンスの順序に対応します。 GetParent(itfM : IModule) : IModule : 指定されたモジュール インスタンスの親インスタンスを返しま...", 
"body" : "インターフェイスについて IModuleTree モジュールツリーをナビゲートできます。このインターフェイスからのオブジェクトは、次の型のインスタンスへのポインタを介して各モジュールに与えられます。 MEnv 利用可能になりました。このポインタは関数で使用されます SetIdentification パスされました。ナビゲーション中に参照がスキップされることに注意してください。子ノードの順序は、モジュール ツリー内のモジュール インスタンスの順序に対応します。 GetParent(itfM : IModule) : IModule : 指定されたモジュール インスタンスの親インスタンスを返します。最初の最上位モジュール ノードの場合、戻り値は 0 です。 GetFirstChild(itfM : IModule) : IModule : 指定されたモジュール インスタンスの子インスタンスを返します。子のないモジュール インスタンス ノードの場合、値 0 が返されます。 NextSibling(itfM : IModule) : IModule : 指定されたモジュール インスタンスの次の兄弟インスタンスを返します。兄弟が追加されていないモジュール インスタンスの場合は、0 が返されます。最上位のインスタンスでも呼び出すことができます。 PrevSibling(itfM : IModule) : IModule : 指定されたモジュール インスタンスの前の兄弟インスタンスを返します。以前に兄弟が存在しないモジュール インスタンスの場合は、0 が返されます。最上位のインスタンスでも呼び出すことができます。 GetFirstToplevelInstance() : IModule : ツリー内の最初の最上位インスタンスを返します。ツリーが空の場合は 0 が返されます。 " }, 
{ "title" : "祖先\/兄弟\/子へのナビゲーション ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_f30cbdfc1c1aa58fc0a8640e0098179e", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ ライブラリ: AC_ModuleBase \/ 祖先\/兄弟\/子へのナビゲーション ", 
"snippet" : "ファンクションブロックを使うと AncestorRange インスタンス自体から始めて、インスタンスのすべての先祖にアクセスできます。 SiblingRange インスタンス自体から始めて、ツリー内のインスタンスのすべての兄弟にアクセスできます。 GetChildRange 範囲ブロックを提供します (タイプ SiblingRange ) インスタンスのすべての子について。...", 
"body" : "ファンクションブロックを使うと AncestorRange インスタンス自体から始めて、インスタンスのすべての先祖にアクセスできます。 SiblingRange インスタンス自体から始めて、ツリー内のインスタンスのすべての兄弟にアクセスできます。 GetChildRange 範囲ブロックを提供します (タイプ SiblingRange ) インスタンスのすべての子について。 " }, 
{ "title" : "高信頼性メッセージ プロトコル (RMP) ", 
"url" : "ac_reliable_message_protocol.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ ライブラリ: AC_ModuleBase \/ 高信頼性メッセージ プロトコル (RMP) ", 
"snippet" : "RMP プロトコルは、アプリケーションの境界を越えて、あるモジュールから別のモジュールにメッセージを転送するために使用されます。 RMP ハンドラーのインスタンスは、モジュールがアクセスできるアプリケーションごとに作成されます。 アドレス指定の説明: 各参加者は一意の 32 ビット ID を持ち、その上位ワード (ビット 16 ～ 31) にはアプリケーション ID が含まれ、下位ワード (ビット 0 ～ 15) にはローカル ID が含まれます。 各 ID (32 ビット) は一意である必要があります。これは、ID の一部 (下位ワードなど) には適用されません。 各インスタンスには、上位ワ...", 
"body" : "RMP プロトコルは、アプリケーションの境界を越えて、あるモジュールから別のモジュールにメッセージを転送するために使用されます。 RMP ハンドラーのインスタンスは、モジュールがアクセスできるアプリケーションごとに作成されます。 アドレス指定の説明: 各参加者は一意の 32 ビット ID を持ち、その上位ワード (ビット 16 ～ 31) にはアプリケーション ID が含まれ、下位ワード (ビット 0 ～ 15) にはローカル ID が含まれます。 各 ID (32 ビット) は一意である必要があります。これは、ID の一部 (下位ワードなど) には適用されません。 各インスタンスには、上位ワードで呼び出されるアプリケーションの ID が含まれている必要があります。 変数の命名規則: udi<xxx>ID : アプリケーションとローカルモジュールIDから構成されるモジュールの完全なID ui<xxx>AppID : アプリケーション ID (16 ビット)、完全な ID の上位ワード ui<xxx>ModuleID ：ローカルモジュールID（16ビット）、フルIDの下位ワード " }, 
{ "title" : "IRMPService ", 
"url" : "ac_rmp_irmpservice.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ ライブラリ: AC_ModuleBase \/ IRMPService ", 
"snippet" : "インターフェースのメソッドとプロパティ IRMPService 。 プロパティ: LocalAppID PROPERTY LocalAppID : UINT (get) このプロパティは、ローカル アプリケーションのアドレス、つまり、このアプリケーション内のすべてのモジュール インスタンスの通信アドレスの上位 16 ビットを記述します。...", 
"body" : "インターフェースのメソッドとプロパティ IRMPService 。 プロパティ: LocalAppID PROPERTY LocalAppID : UINT (get) このプロパティは、ローカル アプリケーションのアドレス、つまり、このアプリケーション内のすべてのモジュール インスタンスの通信アドレスの上位 16 ビットを記述します。 " }, 
{ "title" : "メソッド: IsMessageSent ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_538e8d066de1851ec0a8652001725d6d", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ ライブラリ: AC_ModuleBase \/ IRMPService \/ メソッド: IsMessageSent ", 
"snippet" : "METHOD IsMessageSent : BOOL VAR_INPUT uiHandle: UINT; END_VAR このメソッドは、メッセージに次の内容が含まれているかどうかを確認します。 QueueSendMessage 送信キューに書き込まれ、送信され、確認応答されました。 uiHandle から来たハンドルです QueueSendMessage 返されました。このチェックにはファンクション ブロックを使用する必要があります RMPSendメッセージ 標準化されたコマンド インターフェイスがあるため、使用できます。...", 
"body" : "METHOD IsMessageSent : BOOL\nVAR_INPUT\n uiHandle: UINT;\nEND_VAR このメソッドは、メッセージに次の内容が含まれているかどうかを確認します。 QueueSendMessage 送信キューに書き込まれ、送信され、確認応答されました。 uiHandle から来たハンドルです QueueSendMessage 返されました。このチェックにはファンクション ブロックを使用する必要があります RMPSendメッセージ 標準化されたコマンド インターフェイスがあるため、使用できます。 " }, 
{ "title" : "メソッド: QueueSendMessage ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_b6b7ed9d6de18513c0a8652000b31074", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ ライブラリ: AC_ModuleBase \/ IRMPService \/ メソッド: QueueSendMessage ", 
"snippet" : "METHOD QueueSendMessage : UINT VAR_INPUT udiSenderID: UDINT; udiReceiverID: UDINT; tValidity: TIME; pmdData: POINTER TO ARRAY[0..63] OF BYTE; END_VAR このメソッドは、送信するメッセージを送信キューに追加し、ハンドルを返します。このハンドルは、転送が成功したかどうかを確認するために使用できます。 戻り値 16#FFFF バッファがいっぱいでメッセージが送信されなかったことを示します。戻り値 16#FFFE 受信モジュールが同じアプリケーション内にあ...", 
"body" : "METHOD QueueSendMessage : UINT\nVAR_INPUT\n udiSenderID: UDINT;\n udiReceiverID: UDINT;\n tValidity: TIME;\n pmdData: POINTER TO ARRAY[0..63] OF BYTE;\nEND_VAR このメソッドは、送信するメッセージを送信キューに追加し、ハンドルを返します。このハンドルは、転送が成功したかどうかを確認するために使用できます。 戻り値 16#FFFF バッファがいっぱいでメッセージが送信されなかったことを示します。戻り値 16#FFFE 受信モジュールが同じアプリケーション内にあり、送信が成功したことを示します。 送信キューにメッセージを追加するには、ファンクション ブロックを使用する必要があります。 RMPSendメッセージ 標準化されたコマンド インターフェイスがあるため、使用できます。 " }, 
{ "title" : "方法: 受信 ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_385683a56de1850cc0a8652000d330da", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ ライブラリ: AC_ModuleBase \/ IRMPService \/ 方法: 受信 ", 
"snippet" : "METHOD Receive : UDINT VAR_INPUT uiReceiverModuleID: UINT; pmd: POINTER TO ARRAY[0..63] OF BYTE; END_VAR このメソッドは、メッセージを受信できる任意のモジュールから呼び出すことができます。のために uiReceiverID 受信した最も古いメッセージが使用されます。メッセージがない場合は、 16#FFFFFFFF 戻ってきた。メッセージが少なくとも 1 つあるが、別のタスクからの同時アクセスにより最も古いメッセージがロックされている場合 16#FFFFFFFE 戻ってきた。それ以外の場合は、...", 
"body" : "METHOD Receive : UDINT\nVAR_INPUT\n uiReceiverModuleID: UINT;\n pmd: POINTER TO ARRAY[0..63] OF BYTE;\nEND_VAR このメソッドは、メッセージを受信できる任意のモジュールから呼び出すことができます。のために uiReceiverID 受信した最も古いメッセージが使用されます。メッセージがない場合は、 16#FFFFFFFF 戻ってきた。メッセージが少なくとも 1 つあるが、別のタスクからの同時アクセスにより最も古いメッセージがロックされている場合 16#FFFFFFFE 戻ってきた。それ以外の場合は、送信者のアドレスが返されます。 " }, 
{ "title" : "RMPSendメッセージ ", 
"url" : "ac_rmp_sendmessage.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ ライブラリ: AC_ModuleBase \/ RMPSendメッセージ ", 
"snippet" : "このブロックは、任意のモジュール インスタンス (ただしその ID によって知られる) にメッセージを送信するために使用されます。 変数の動作 xExecute 、 xDone 、 xBusy そして xError 「ライブラリ設計ガイドライン」に準拠しています。この文書は、 CODESYS -標準インストール。...", 
"body" : "このブロックは、任意のモジュール インスタンス (ただしその ID によって知られる) にメッセージを送信するために使用されます。 変数の動作 xExecute 、 xDone 、 xBusy そして xError 「ライブラリ設計ガイドライン」に準拠しています。この文書は、 CODESYS -標準インストール。 " }, 
{ "title" : "FUNCTION_BLOCK: RMPSendMessage ", 
"url" : "ac_rmp_sendmessage.html#UUID-2d1f2b05-610c-bf06-e2fe-18d7e3819bbc_ac_rmp_sendmessage0", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ ライブラリ: AC_ModuleBase \/ RMPSendメッセージ \/ FUNCTION_BLOCK: RMPSendMessage ", 
"snippet" : "FUNCTION_BLOCK RMPSendMessage EXTENDS CBM.ETRIG VAR_IN_OUT mdData: ARRAY[0..63] OF BYTE; END_VAR VAR_INPUT itfrmp: IRMPService; xExecute: BOOL; udiReceiverID: UDINT; uiSenderModuleID: UINT; tValidity: TIME := t#1s; END_VAR VAR_OUTPUT xDone: BOOL; xBusy: BOOL; xError: BOOL; uiErrorID: UINT; END_VAR 相...", 
"body" : "FUNCTION_BLOCK RMPSendMessage EXTENDS CBM.ETRIG\nVAR_IN_OUT\n mdData: ARRAY[0..63] OF BYTE;\nEND_VAR\nVAR_INPUT\n itfrmp: IRMPService;\n xExecute: BOOL;\n udiReceiverID: UDINT;\n uiSenderModuleID: UINT;\n tValidity: TIME := t#1s;\nEND_VAR\nVAR_OUTPUT\n xDone: BOOL;\n xBusy: BOOL;\n xError: BOOL;\n uiErrorID: UINT;\nEND_VAR 相手側の RMP サービスでメッセージの受信が確認され次第、ブロックの機能は正常に完了しますのでご注意ください。ただし、これはメッセージが実際の受信者に届いたことを意味する必要はありません。 で mdData 送信するデータが転送されます。で udiReceiverID 受信者であり、 rmp ローカルの RMPService インスタンスが含まれます。 tValidity は、メッセージの有効期間を示します。これにより、次のことがチェックされます。 メッセージが送信されるまでの時間は、 tValidity を超えることはできません (超えない場合は、エラー メッセージが生成されます)。 相手側の受信者がメッセージを受け取るまでの時間が許容されます tValidity 超えないでください。超えない場合、メッセージは削除されます。 エラーが発生する原因は次のとおりです。 uiErrorID 戻ってきた： 送信バッファがいっぱいです。後でもう一度送信してみることをお勧めします。 メッセージは送信バッファから削除されません。この原因としては、送信が遅すぎる、接続が乱れている、または相手側の受信バッファがいっぱいであることが考えられます。 メッセージの宛先となっているアプリケーションは、このアプリケーションに接続されていません。つまり譲渡は基本的に不可能ということになります。 " }, 
{ "title" : "デバッグ ", 
"url" : "ac_rmp_debugging.html", 
"breadcrumbs" : "CODESYS Application Composer \/ モジュール宣言エディター \/ ライブラリ: AC_ModuleBase \/ デバッグ ", 
"snippet" : "グローバル変数について g_AC_RMP_xDiagLog ロギングメカニズムをオンにすることができます。これにより、すべての送受信イベントが記録され、キュー内のメッセージの設定または削除がランタイム システムの標準ログに記録されます。 また、発生した予期せぬイベントやエラーはすべて標準ログに出力されます。...", 
"body" : "グローバル変数について g_AC_RMP_xDiagLog ロギングメカニズムをオンにすることができます。これにより、すべての送受信イベントが記録され、キュー内のメッセージの設定または削除がランタイム システムの標準ログに記録されます。 また、発生した予期せぬイベントやエラーはすべて標準ログに出力されます。 " }
]
$(document).trigger('search.ready');
});