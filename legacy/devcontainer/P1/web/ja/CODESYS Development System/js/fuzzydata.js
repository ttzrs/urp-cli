$(document).ready(function () {indexDict['ja'] = [{ "title" : "CODESYS Development System ", 
"url" : "_cds_start_page.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS Development System ", 
"snippet" : "の CODESYS Development System は、コントローラおよび自動化テクノロジ用の IEC 61131-3 プログラミング ツールです。プログラミング システムには、32 ビット バージョンと 64 ビット バージョンがあります。 ダウンロードできます CODESYS Development System から CODESYS Store International  またはから CODESYS Store North America そこには、製品のデータシートもあります。...", 
"body" : "の CODESYS Development System は、コントローラおよび自動化テクノロジ用の IEC 61131-3 プログラミング ツールです。プログラミング システムには、32 ビット バージョンと 64 ビット バージョンがあります。 ダウンロードできます CODESYS Development System から CODESYS Store International  またはから CODESYS Store North America そこには、製品のデータシートもあります。 " }, 
{ "title" : "概要 ", 
"url" : "_cds_development_system.html", 
"breadcrumbs" : "CODESYS Essentials \/ 概要 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS -ヘルプを使用する ", 
"url" : "_cds_development_system.html#UUID-0b219bde-e54a-015d-5b0c-50827cb3788f_section-idm4562692390587232647961086548", 
"breadcrumbs" : "CODESYS Essentials \/ 概要 \/ CODESYS -ヘルプを使用する ", 
"snippet" : "the CODESYS -ヘルプはあなたを助けるべきです CODESYS Development System 使いやすく効果的です。ここでは、質問に対する回答と問題の解決策をすばやく見つけることができます。 各ヘルプコンポーネントは、概念と参照部分で構成されています。 コンセプトセクションでは、作成に関連するすべての問題について詳しく説明します。 CODESYS -プロジェクトが関連しています。概念は、目的の結果にステップバイステップでガイドされる指示によって補足されます。 リファレンスパーツは、完全なユーザーインターフェイスとプログラミングリファレンスガイドです。 CODESYS 。 の中...", 
"body" : "the CODESYS -ヘルプはあなたを助けるべきです CODESYS Development System 使いやすく効果的です。ここでは、質問に対する回答と問題の解決策をすばやく見つけることができます。 各ヘルプコンポーネントは、概念と参照部分で構成されています。 コンセプトセクションでは、作成に関連するすべての問題について詳しく説明します。 CODESYS -プロジェクトが関連しています。概念は、目的の結果にステップバイステップでガイドされる指示によって補足されます。 リファレンスパーツは、完全なユーザーインターフェイスとプログラミングリファレンスガイドです。 CODESYS 。 の中に CODESYS -オプションは、必要かどうかを決定します CODESYS -オフラインヘルプまたは CODESYS -オンラインヘルプを使用したい。 ユーザーインターフェイスから直接状況依存ヘルプにアクセスできます CODESYS Development System 電話。あなたがいるとき CODESYS オブジェクト、メニューコマンド、またはプログラミング要素とキーにカーソルを置きます F1 を押すと、関連するヘルプページが表示されます。または、メニューコマンドを使用することもできます ヘルプ 使用する。検索は全文検索です。インデックス検索は、 CODESYS -オフラインヘルプが可能です。 オフラインヘルプのオペレーターを検索 AND たとえば、自動的に使用すると、検索語を入力することになります Device Diagnosis 入力と同じ検索結果に Device AND Diagnosis プレースホルダー * 自動的に使用されます。記号 * この場合、文字の直後にあるため、ワイルドカードとして入力しないでください。 * が検索されます。 " }, 
{ "title" : "CODESYSシステムの概要 ", 
"url" : "_cds_development_system.html#UUID-0b219bde-e54a-015d-5b0c-50827cb3788f_section-idm4564593995971232647965283006", 
"breadcrumbs" : "CODESYS Essentials \/ 概要 \/ CODESYSシステムの概要 ", 
"snippet" : "IEC61131-3プログラミングツール CODESYS Development System のコアを形成します CODESYS -産業用自動化技術のタスクのためのソフトウェアプラットフォーム。たとえば、モーションコントロール、視覚化、フィールドバス接続などの追加の統合ソリューションにより、通常の実用的な要件が1つのシステムでカバーされます。...", 
"body" : "IEC61131-3プログラミングツール CODESYS Development System のコアを形成します CODESYS -産業用自動化技術のタスクのためのソフトウェアプラットフォーム。たとえば、モーションコントロール、視覚化、フィールドバス接続などの追加の統合ソリューションにより、通常の実用的な要件が1つのシステムでカバーされます。 " }, 
{ "title" : "機能性 ", 
"url" : "_cds_development_system.html#UUID-0b219bde-e54a-015d-5b0c-50827cb3788f_section-idm4564593977048032647968557534", 
"breadcrumbs" : "CODESYS Essentials \/ 概要 \/ 機能性 ", 
"snippet" : "無料のもの CODESYS Development System は、制御タスクを備えた自動化デバイス用のIEC61131-3プログラミングプラットフォームです。それはあなたの開発作業のための多様で便利なエンジニアリング機能をあなたに提供します： このオンラインヘルプを参照してください。 アシスタント（ウィザード）を使用したプロジェクト構成 プロジェクトの作成と構成インターフェースのカスタマイズ インターフェイスをカスタマイズする多くの標準機能を備えたIEC61131-3に準拠した専門的な制御アプリケーションの作成 アプリケーションのプログラミングすべてのIEC61131-3言語でのマウスとキ...", 
"body" : "無料のもの CODESYS Development System は、制御タスクを備えた自動化デバイス用のIEC61131-3プログラミングプラットフォームです。それはあなたの開発作業のための多様で便利なエンジニアリング機能をあなたに提供します： このオンラインヘルプを参照してください。 アシスタント（ウィザード）を使用したプロジェクト構成 プロジェクトの作成と構成インターフェースのカスタマイズ インターフェイスをカスタマイズする多くの標準機能を備えたIEC61131-3に準拠した専門的な制御アプリケーションの作成 アプリケーションのプログラミングすべてのIEC61131-3言語でのマウスとキーボードによる便利なプログラミング FBD、KOP、STL、ST、ASに対応するエディター、およびバリアントCFCと拡張CFC プログラミング言語とエディターさまざまなデータを入力および構成するための入力サポート 入力アシスタンスを使用するオブジェクト指向プログラミングのサポート 追加のツールなしで可能なすべてのIEC61131-3言語での61131-33rdEditionに準拠した実際のオブジェクト指向プログラミング 開発時間とエラーを削減するための同様のアプリケーションパーツへのプログラムモジュールの継承 オブジェクト指向プログラミングは必須ではありません。関数型プログラミングまたはオブジェクト指向プログラミングは、必要に応じて使用および混合できます。 オブジェクト指向プログラミンググラフィック編集者向けの包括的なプロジェクト比較 プロジェクトの比較アプリケーションコードを簡単に再利用するためのライブラリの概念 ライブラリの使用アプリケーションコードを最適化し、テストと試運転を高速化するためのデバッグとオンラインプロパティ テストとトラブルシューティングコントローラのパフォーマンスを最適化するための多くのCPUプラットフォーム用の統合コンパイラ コンパイラバージョンコンパイルオプションソースコードとコントローラの動作を保護するためのセキュリティプロパティ プロジェクトの保護と保存アプリケーションの保護デバイスユーザー管理の処理パッケージとライセンスの管理さまざまなメーカーのデバイスのフィールドバスサポートとプログラミング I \/ Oリンクの構成製品フレームワークを離れることなく拡張性とカスタマイズ パッケージとライセンスの管理それに加えて： たとえば、さらなる自動化タスクのためのシームレスに統合されたツール CODESYS Visualization 、 CODESYS SoftMotion と CODESYS Application Composer また、アドオンパッケージを使用して機能を拡張する可能性にも注意してください。アドオンパッケージには、 CODESYS Store International 準備。 " }, 
{ "title" : "ユーザーインターフェイスの言語を設定する ", 
"url" : "_cds_development_system.html#UUID-0b219bde-e54a-015d-5b0c-50827cb3788f_section-idm4562692385747232647971307357", 
"breadcrumbs" : "CODESYS Essentials \/ 概要 \/ ユーザーインターフェイスの言語を設定する ", 
"snippet" : "対話中 オプション→国際設定 開発システムのユーザーインターフェイスが次に起動するときに表示される国語を設定できます。ヘルプの各国語を個別に指定できます。 もし、あんたが CODESYS コマンドラインから、パラメータを介してインターフェイスの言語を指定できます。...", 
"body" : "対話中 オプション→国際設定 開発システムのユーザーインターフェイスが次に起動するときに表示される国語を設定できます。ヘルプの各国語を個別に指定できます。 もし、あんたが CODESYS コマンドラインから、パラメータを介してインターフェイスの言語を指定できます。 " }, 
{ "title" : "著作権および商標 ", 
"url" : "_cds_development_system.html#UUID-0b219bde-e54a-015d-5b0c-50827cb3788f_section-idm456459407124003264797233218", 
"breadcrumbs" : "CODESYS Essentials \/ 概要 \/ 著作権および商標 ", 
"snippet" : "これにおけるすべての権利 CODESYS -言及された会社と会社名、および商品と製品名はそれぞれの会社にあります。技術的な変更は予約済みです。このヘルプまたはその一部は、 CODESYS GmbH コピーまたは再利用。...", 
"body" : "これにおけるすべての権利 CODESYS -言及された会社と会社名、および商品と製品名はそれぞれの会社にあります。技術的な変更は予約済みです。このヘルプまたはその一部は、 CODESYS GmbH コピーまたは再利用。 " }, 
{ "title" : "ホワイトペーパー：ユーザーの観点からのモジュール化 ", 
"url" : "_cds_codesys_modularization.html", 
"breadcrumbs" : "CODESYS Essentials \/ ホワイトペーパー：ユーザーの観点からのモジュール化 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "印心 ", 
"url" : "_cds_codesys_modularization.html#UUID-5c384bff-d9da-6867-04ee-1ecd44a1c396_id_f94aeb495b85ce36c0a86463409947a4_id_66e987b85bec06a3c0a864633232042b", 
"breadcrumbs" : "CODESYS Essentials \/ ホワイトペーパー：ユーザーの観点からのモジュール化 \/ 印心 ", 
"snippet" : "の CODESYS 3.5 SP17は、主要なアーキテクチャの変換を実行しました。以前は、プログラミングシステムの機能のほとんどが単一のまとまりのあるセットアップにバンドルされていました。それだけ CODESYS SoftMotion だけでなく、の有料アドオン CODESYS Professional Developer Edition 別々でした。変換の過程で、このモジュール化をコア機能まで継続しました。現在、プログラミング言語エディター、フィールドバスコンフィギュレーター、およびコードジェネレーターのほとんどは、独自のアドオンにアウトソーシングされています。 2つの例を挙げると、視覚化や...", 
"body" : "の CODESYS 3.5 SP17は、主要なアーキテクチャの変換を実行しました。以前は、プログラミングシステムの機能のほとんどが単一のまとまりのあるセットアップにバンドルされていました。それだけ CODESYS SoftMotion だけでなく、の有料アドオン CODESYS Professional Developer Edition 別々でした。変換の過程で、このモジュール化をコア機能まで継続しました。現在、プログラミング言語エディター、フィールドバスコンフィギュレーター、およびコードジェネレーターのほとんどは、独自のアドオンにアウトソーシングされています。 2つの例を挙げると、視覚化やアイコン構成などの大きな機能についても同じことが言えます。ユーザーインターフェイス構造（メニューシステム、ナビゲーター、メッセージウィンドウなど）、コンパイラフロントエンド、プロジェクト処理およびコントローラとの通信用のコンポーネントなどの重要なインフラストラクチャ機能は、コアのままです。コアのより多くの部分が将来、別々のアドオンに移動される可能性があることに注意してください。 主にこのモジュール化を使用して、個々のコンポーネントのバージョンサイクルを均等化します。過去には、 CODESYS -新機能と改善に関する開発を1年に1回に統合します。つまり、サービスパックのリリース日です。まだ完成していない機能は、通常、サービスパックの延期につながりました。明らかにスケジュール外だった機能は、1年間延期されました。私たちは、私たち自身の利益とすべての人の利益の両方でこれを連動させたいと思っています CODESYS -ユーザーを解決し、将来的に各アドオンを個別にバージョン管理してリリースします。 にとって CODESYS ユーザーには、明らかで重要な利点がいくつかあります。 機能は完了後すぐにリリースされ、できるだけ早く利用可能になります。 アドオンのベータ版は、フィードバックのタイムリーな機会を得るために、関心のあるユーザーに配信できます。このようなベータ版は、他の点では安定した環境で操作できます。 不要なアドオンを削除できるため、スペース要件と全体的なパフォーマンスの両方にメリットがあります。 もちろん、この柔軟性は複雑さの増大によって相殺されます。このホワイトペーパーでは、 どのような制限がありますか 複雑さを管理しやすくするためにどのような対策を講じたか 一般的なアプリケーションに推奨する手順 " }, 
{ "title" : "セットアップ ", 
"url" : "_cds_codesys_modularization.html#UUID-5c384bff-d9da-6867-04ee-1ecd44a1c396_id_f94aeb495b85ce36c0a86463409947a4_id_3ce1a2b05bec06a3c0a8646354ca4853", 
"breadcrumbs" : "CODESYS Essentials \/ ホワイトペーパー：ユーザーの観点からのモジュール化 \/ セットアップ ", 
"snippet" : "セットアップは、まだ CODESYS Store International ダウンロードが完了しました。すでに一部になっているすべてのコンポーネント CODESYS 3.5 SP16以前も現在のセットアップに含まれています。つまり、インストール後、ユーザーは機能を損なうことなく、使い慣れたシステム全体を受け取ることができます。 ユーザーは、コアシステムとアドオンバージョンを個別にコンパイルする必要があり、最初から対処する必要はないと考えています。また、多くのユーザーがパッケージ全体に不満を持っておらず、カスタムビルドを作成したくない場合があることも認識しています。これは、ツールが邪魔になるこ...", 
"body" : "セットアップは、まだ CODESYS Store International ダウンロードが完了しました。すでに一部になっているすべてのコンポーネント CODESYS 3.5 SP16以前も現在のセットアップに含まれています。つまり、インストール後、ユーザーは機能を損なうことなく、使い慣れたシステム全体を受け取ることができます。 ユーザーは、コアシステムとアドオンバージョンを個別にコンパイルする必要があり、最初から対処する必要はないと考えています。また、多くのユーザーがパッケージ全体に不満を持っておらず、カスタムビルドを作成したくない場合があることも認識しています。これは、ツールが邪魔になることを意図していない完全に正当なアプローチです。 " }, 
{ "title" : "インストーラー ", 
"url" : "_cds_codesys_modularization.html#UUID-5c384bff-d9da-6867-04ee-1ecd44a1c396_id_f94aeb495b85ce36c0a86463409947a4_id_ac5f82f95bec06a3c0a86463303421a1", 
"breadcrumbs" : "CODESYS Essentials \/ ホワイトペーパー：ユーザーの観点からのモジュール化 \/ インストーラー ", 
"snippet" : "セットアップにより、と呼ばれる新しいグローバルツールが自動的にインストールされます CODESYS Installer 名前。それで誰もができる CODESYS -インストールおよび関連するアドオンが管理されます。これは、モジュール化の利点を積極的に活用したいユーザーにとっての要です。 とともに CODESYS Installer 任意の数の独立したインストールを管理できます。個々のインストール内で、どのアドオンをその一部にするかを正確に指定できます。わかりやすくするために、各インストールにはわかりやすい名前を付けることができます。インストールごとに、報告する更新を設定できます。デフォルトでは...", 
"body" : "セットアップにより、と呼ばれる新しいグローバルツールが自動的にインストールされます CODESYS Installer 名前。それで誰もができる CODESYS -インストールおよび関連するアドオンが管理されます。これは、モジュール化の利点を積極的に活用したいユーザーにとっての要です。 とともに CODESYS Installer 任意の数の独立したインストールを管理できます。個々のインストール内で、どのアドオンをその一部にするかを正確に指定できます。わかりやすくするために、各インストールにはわかりやすい名前を付けることができます。インストールごとに、報告する更新を設定できます。デフォルトでは、これは「リリース済みバージョンのみ」に設定されていますが、プレリリースバージョンに切り替えたり、インストールの状態でロックするためにオフに切り替えたりすることもできます。 の便利な機能に関する詳細情報 CODESYS Installer 以下の推奨事項に記載されています。 以内に CODESYS 通知センターがあります CODESYS Installer 接続されています。適切な更新に関するメッセージがここに表示されます。だからあなたはいつもする必要はありません CODESYS Installer 更新の通知を受け取るために実行します。 " }, 
{ "title" : "互換性 ", 
"url" : "_cds_codesys_modularization.html#UUID-5c384bff-d9da-6867-04ee-1ecd44a1c396_id_f94aeb495b85ce36c0a86463409947a4_id_0259f7295bec06a3c0a86463648ba988", 
"breadcrumbs" : "CODESYS Essentials \/ ホワイトペーパー：ユーザーの観点からのモジュール化 \/ 互換性 ", 
"snippet" : "キーワードの互換性は、モジュール化に起因する複雑さの最大の増加を隠します。従来は直線的な進歩があったため、互換性の問題は単純でした（「新しい CODESYS 古いプロジェクトを読むことができます」）、高度にモジュール化された環境では問題ははるかに困難です。 私たちが下した決定と、次のセクションでより詳細に説明する決定は、技術的に実現可能なものではなく、合理的に管理可能なものに基づいて意図的に行われました。 プロジェクトの互換性 ここでの問題は、どの程度 CODESYS -インストールにより、別のプロジェクトまたはライブラリを開くことができます CODESYS -インストールが作成されました。 ...", 
"body" : "キーワードの互換性は、モジュール化に起因する複雑さの最大の増加を隠します。従来は直線的な進歩があったため、互換性の問題は単純でした（「新しい CODESYS 古いプロジェクトを読むことができます」）、高度にモジュール化された環境では問題ははるかに困難です。 私たちが下した決定と、次のセクションでより詳細に説明する決定は、技術的に実現可能なものではなく、合理的に管理可能なものに基づいて意図的に行われました。 プロジェクトの互換性 ここでの問題は、どの程度 CODESYS -インストールにより、別のプロジェクトまたはライブラリを開くことができます CODESYS -インストールが作成されました。 このメカニズムは変更していません。動作は、 CODESYS -モジュール化前のバージョン。新しい環境から作成されたために現在のバージョンで読み取ったり解釈したりできないデータがプロジェクトにある場合、影響を受けるオブジェクトはナビゲーターで赤い十字でマークされ、 [不完全な] （→エディタは引き続き開くことができます）または [わからない] （→エディタを開くことができなくなりました）。どちらの場合も、プロジェクトをコントローラーにロードすることはできず（未定義のプログラムの動作が発生する可能性があるため）、そのままの状態になります。 名前を付けて保存 利用可能（元のプロジェクトの偶発的な上書き、したがってデータの損失を防ぐため）。 この振る舞いは何年にもわたって証明されています。 コードの互換性 これは、 CODESYS -プロジェクトのインストールでは、常に別のプロジェクトと同じバイナリ制御コードを生成できます CODESYS -インストール。簡単に言うと、次のようなプロジェクトを開始できますか？ CODESYS -インストールを開き、オンラインで変更またはダウンロードせずにコントローラーにログインしますか？ この目的のために、 CODESYS 3.5SP17コンパイラバージョンの概念。コンパイラバージョンを起動します CODESYS 3.5SP18を取り外します。オンラインで変更またはダウンロードせずにプロジェクトでコントローラーにログインできることに依存している場合は、完全に一致するプロジェクトを開始する必要があります CODESYS -インストールを開きます。 コンパイラバージョンの概念を放棄する決定には、いくつかの重要な議論があります。 生成されたコードは、コンパイラだけでなく、関連するプログラミング言語エディタとフィールドバスコンフィギュレータが担当します。これらは現在、独立してバージョン管理されたアドオンにアウトソーシングされているため、原則として、統一された包括的なコンパイラバージョンは存在しません。ユーザーの観点からは、アドオン固有のさまざまなコンパイラバージョンの組み合わせを組み合わせて、非常に複雑な一種のコンパイラバージョンプロファイルを作成しようとしていることがわかります。で CODESYS UML （一部の CODESYS Professional Developer Edition ）何年もの間、別の言語モデル生成バージョンがありましたが、この1つのアドオンを使用しても、現在の多数のアドオンは言うまでもなく、この概念は実際には証明されていません。 単純な形式であっても、コンパイラバージョンにはユーザーからの詳細な知識が必要でした。遅くとも、誤って誤って設定されたバージョンの修正はしばしば問題がありました。経験が浅い、またはこの概念に根本的に納得していないユーザーは、メンテナンス時に実行中のコントローラーに安全にログオンできるようにするために、過去にいくつかのメンテナンスインストールを実行しました。以下に示すように、このケースに対して堅牢なインタラクティブサポートを提供します。 新しいコンパイラバージョンはそれぞれ、内部コードベースを肥大化します。一方では、これはパフォーマンスとインストールのサイズに悪影響を及ぼします。一方、このコードベースのすべての組み合わせをテストすることはできません。コンパイラのバージョンの保守もある程度エラーが発生しやすいため、これは私たちの絶えず増加する品質基準と直接矛盾しています。言い換えると、以前のコンパイラバージョンの概念がすべての場合に確実に機能することを保証することはできません。また、モジュール化のためにこの概念をさらに複雑にする必要がある場合は、確かに保証できません。 前の2つの引数は、次のように要約できます。ユーザーの観点からは、コンパイラバージョンをまったく処理しなくても、メンテナンスケースのツールサポートを使用して適切なバージョンを作成できることは魅力的です。 ランタイムシステムの互換性 ここでの問題は、どの程度 CODESYS -インストールは、ランタイムシステムバージョンと互換性があります。言い換えれば、あなたは新しいものを思い付くことができますか？ CODESYS -古いコントローラーにログインして、利用可能なオンライン機能を使用しますか？ 関連するメカニズムは変更していません。原則として、プログラミングシステムとランタイムシステムのバージョンは、次の制限付きで、必要に応じて組み合わせることができます。 新しいプログラミングシステムバージョンは、古いランタイムシステムバージョンがまだサポートしていない機能を提供する場合があります。この場合、この機能は使用できません。 セキュリティ拡張機能でこれが禁止されている場合（たとえば、強制的なユーザー管理や新しいタイプの暗号化アルゴリズム）、古いプログラミングシステムバージョンは新しいランタイムシステムバージョンで動作できない可能性があります。 " }, 
{ "title" : "ユーザーへの推奨事項 ", 
"url" : "_cds_codesys_modularization.html#UUID-5c384bff-d9da-6867-04ee-1ecd44a1c396_id_f94aeb495b85ce36c0a86463409947a4_id_6e10313e5bec06a3c0a86463310bf8d6", 
"breadcrumbs" : "CODESYS Essentials \/ ホワイトペーパー：ユーザーの観点からのモジュール化 \/ ユーザーへの推奨事項 ", 
"snippet" : "もちろん、このセクションで説明するシナリオを組み合わせて使用することもできます。これは、実践に関連するケースの大部分をカバーしていると信じており、ツールを使用して可能な限りそれらをサポートしたいと考えています。今後も、これらのユースケースに沿ってソフトウェアを最適化していきたいと考えています。 シナリオ おすすめ ツールサポート 進行中のプロジェクトの日々の開発 the CODESYS バージョンと関連するアドオンは常に最新の状態に保つ必要があります。私たちは常に大小の改善、バグ修正、セキュリティ更新に取り組んでいるため、最新バージョンは常にこれまでで最高のバージョンです。古いバージョンに固執...", 
"body" : "もちろん、このセクションで説明するシナリオを組み合わせて使用することもできます。これは、実践に関連するケースの大部分をカバーしていると信じており、ツールを使用して可能な限りそれらをサポートしたいと考えています。今後も、これらのユースケースに沿ってソフトウェアを最適化していきたいと考えています。 シナリオ おすすめ ツールサポート 進行中のプロジェクトの日々の開発 the CODESYS バージョンと関連するアドオンは常に最新の状態に保つ必要があります。私たちは常に大小の改善、バグ修正、セキュリティ更新に取り組んでいるため、最新バージョンは常にこれまでで最高のバージョンです。古いバージョンに固執する理由はほとんどありません。 the CODESYS Installer インストールに関連する利用可能なすべての更新を表示します。これらのアップデートは、マウスを数回クリックするだけでダウンロードおよびインストールできます。 さらに、にある通知センターを介して CODESYS はドッキング可能なウィンドウとして統合されており、利用可能な更新（現在のインストールと完全に一致）も表示されます。ここから直接行くことができます CODESYS Installer ジャンプするので、常にアクティブである必要はありません。 私たちが提供するすべてのセットアップとアドオンは署名されているため、インターネット経由でダウンロードしても安全です。 PackageManagerを、対応する（部分的にインタラクティブな）テストメソッドで拡張しました。 チーム内の複数の人が均一なインストールを使用する必要があるという条件の下で進行中のプロジェクトの毎日の開発 上記のように。 チームの1人が、利用可能な更新をインストールしてテストします。リリースが成功すると、新しいリファレンスインストールがチームに配布されます。 の中に CODESYS Installer 既存のインストールは、説明ファイルとしてエクスポートできます。このファイルを使用して、別のマシンに同一のインストールを作成できます。このメカニズムはコマンドラインからも利用できるため、自動化された環境に特に適しています。 保護された環境で最新のアドオン機能を試す 既存の生産的に使用される CODESYS -インストールが重複しています。この場合、アドオンのベータ版がインストールされ、必要に応じて更新されます。 生産的に使用されたもの CODESYS -インストールは完全に影響を受けません。プロジェクトの通常の作業は影響を受けません。 the CODESYS Installer 既存のインストールのコピーを簡単に作成できます。インストールごとに、リリースされたアップデートのみを提供するか、実験的なベータアップデートを提供してインストールするかを選択できます。 以前は、特定のサービスパックまたはパッチはマシンごとに1回しかインストールできませんでした。インストーラーの導入以来、この制限は解除されました。 関連するインベントリプロジェクトを変更せずに、既存のコントローラをメンテナンスします。オンラインで変更したりダウンロードしたりせずにコントローラーにログインできることを保証する必要があります。 プロジェクトにぴったり合うものになります CODESYS -インストールが作成されました。コンパイラのバージョンを処理する必要がなく、バイナリに等しい制御コードの生成が保証されます。 プロジェクトをロードするとき、現在の違い CODESYS インストールと作成バージョンでは、プロジェクトに正確に適合するインストールをダウンロードしてインストールする機会が得られます。プロジェクトは、この新しく作成されたバージョンで自動的に開かれます。 さらに、ロード時に、マシンにすでに存在する適切なインストールを選択することもできます。 でインストールを取得します CODESYS Installer カスタム名。このようにして、より多くのインストールを管理する必要がある場合でも、概要を失うことはありません。 このような特別な互換性インストールの更新提案を常に受け取らないようにするために、これらはデフォルトで更新チャネルから分離されています。 古い既存のプロジェクトのさらなる開発 プロジェクトは現在進行中です CODESYS -インストールはさらに開発されました。とにかくコードに変更が加えられるので、予定されているオンラインの変更やダウンロードは関係ありません。 CODESYS 古いプロジェクトをロスレスでロードできます。必要なアドオンが不足している場合は、プロジェクトの読み込みプロセスから直接ダウンロードしてインストールすることができます。それ以外の場合は、プロジェクト自体とコントローラーの両方が書き込みおよびダウンロード保護によって保護されます。 " }, 
{ "title" : "互換性 ", 
"url" : "_rtsl_compatibility.html", 
"breadcrumbs" : "CODESYS Essentials \/ 互換性 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "の互換性 CODESYS プロジェクト ", 
"url" : "_rtsl_compatibility.html#UUID-cc9ab11e-6c8d-25ef-88ec-9f65124bdb95_section-idm43404583559002", 
"breadcrumbs" : "CODESYS Essentials \/ 互換性 \/ の互換性 CODESYS プロジェクト ", 
"snippet" : "保存形式 使用事例 サポート 新しいプロジェクトにプロジェクトをロードしています CODESYS データ損失のないバージョン ✓ 古い人のためにプロジェクトを保存する CODESYS バージョン ✓ 古いプロジェクトで新しいプロジェクトを開く CODESYS バージョン -- 新しいプロジェクトで開かれる既存のプロジェクト CODESYS バージョンは可能な限り「互換モード」に維持されます。新しい機能を必要としない変更のみをプロジェクトに加える限り、保存形式は変わりません。だからこそオリジナルは CODESYS このバージョンでは、データを失うことなくプロジェクトを開いて編集し続けることができ...", 
"body" : "保存形式 使用事例 サポート 新しいプロジェクトにプロジェクトをロードしています CODESYS データ損失のないバージョン ✓ 古い人のためにプロジェクトを保存する CODESYS バージョン ✓ 古いプロジェクトで新しいプロジェクトを開く CODESYS バージョン -- 新しいプロジェクトで開かれる既存のプロジェクト CODESYS バージョンは可能な限り「互換モード」に維持されます。新しい機能を必要としない変更のみをプロジェクトに加える限り、保存形式は変わりません。だからこそオリジナルは CODESYS このバージョンでは、データを失うことなくプロジェクトを開いて編集し続けることができます。新しいデータをプロジェクトに保存する必要がある変更を行った場合、この状況について対話形式で通知されます。互換性違反が許容できない場合は、最後の変更を元に戻すオプションがあります。 多くの場合、新しいメモリ バージョンのプロジェクトを古いバージョンで開くことができます。 CODESYS ただし、これは強くお勧めしません。プロジェクトを開くことができるかどうかは、古いバージョンで利用できるプラグインの種類によって異なります。このようなプロジェクトをロードすると、対応するメッセージが表示されます。 古いバージョンのプロジェクトを保存するオプションもあります。 CODESYS を実行することで ファイル → 名前を付けて保存 指示。この場合、どのオブジェクトがデータ損失の影響を受けるかに関する情報が、 メッセージ ビュー。ただし、古いバージョンのプロジェクトを保存すると、明示的にのみストレージ形式に影響します。コンパイラのバージョンまたは同様の設定が古いバージョンと一致するように調整される、プロジェクトの完全な変換はありません。 オンラインでの行動 使用事例 サポート 古いバージョンで作成されたプロジェクトをコンパイルする CODESYS 新しいバージョンの CODESYS バージョン ✓ 新しいバージョンではオンライン変更なしでログインします。 -- 新しい CODESYS 既存のプロジェクトに対して、プロジェクトを作成した古いバージョンと同じコードを生成することはできません。オンラインで変更またはダウンロードせずに実行中のアプリケーションにログインする必要がある場合は、コントローラに最後にロードされたバージョンでプロジェクトを開く必要があります。の CODESYS Installer また、プロジェクト分析は、元のバージョンが存在しない場合にそれを復元するのに役立ちます。 その結果、新しいバージョンまたは異なるバージョンでプロジェクトを開くには、プロジェクトを更新する必要があることを意味します。これには、ランタイム環境を新たにダウンロードする必要がある可能性があります。また、コンパイラまたはグラフィカル エディタの新しい関数やバグ修正によって生じる動作の変化の可能性についてアプリケーションをテストする必要があります。一般に、新しいバージョンに更新する労力を最小限に抑えるために、新しいコンパイラ エラーや既存のプロジェクトの動作の変更を最小限に抑える試みが行われます。 既存のランタイムとの互換性のために、次の点に注意する必要があります。 の新機能 CODESYS 通常、デバイスの説明で有効になります。その結果、古いランタイム システムまたは古いデバイス記述に対しては無効になります。 すべての外部ライブラリのバージョンは、デバイス記述によって解決されます。その結果、それらは対応するランタイム システムに一致します。 内部ライブラリは次のように解決されます。 CODESYS ランタイム システムのバージョンに関係なく、バージョンが異なります。 通信サービスはタグ付きの共有フォーマットに従って構築されます。不明なタグはランタイム システムによって無視されます。その結果、通信サービスを変更することは可能ですが、プログラミング システムはランタイム システムが新しい情報を解釈することを期待しません。 " }, 
{ "title" : "の互換性 CODESYS 図書館 ", 
"url" : "_rtsl_compatibility.html#UUID-cc9ab11e-6c8d-25ef-88ec-9f65124bdb95_section-idm43404583586258", 
"breadcrumbs" : "CODESYS Essentials \/ 互換性 \/ の互換性 CODESYS 図書館 ", 
"snippet" : "使用事例 サポート 古いバージョンで作成されたコンパイル済みライブラリの使用 CODESYS 新しいバージョンの CODESYS バージョン。 ✓ 新しいバージョンで作成されたコンパイル済みライブラリの使用 CODESYS 古いバージョンの CODESYS バージョン。 -- コンパイルされたライブラリは常に最低レベルで作成する必要があります。 CODESYS 互換性が必要なバージョン。古い CODESYS バージョンは、新しいバージョンで作成されたライブラリを認識し、プロジェクトでの使用を拒否します。チェックは、ライブラリに設定されているコンパイラのバージョンに基づいて行われます。ライブラリ...", 
"body" : "使用事例 サポート 古いバージョンで作成されたコンパイル済みライブラリの使用 CODESYS 新しいバージョンの CODESYS バージョン。 ✓ 新しいバージョンで作成されたコンパイル済みライブラリの使用 CODESYS 古いバージョンの CODESYS バージョン。 -- コンパイルされたライブラリは常に最低レベルで作成する必要があります。 CODESYS 互換性が必要なバージョン。古い CODESYS バージョンは、新しいバージョンで作成されたライブラリを認識し、プロジェクトでの使用を拒否します。チェックは、ライブラリに設定されているコンパイラのバージョンに基づいて行われます。ライブラリの内容によっては、保存形式も影響することがあります。 同じルール CODESYS プロジェクトはソース ライブラリにも適用されます。 " }, 
{ "title" : "の互換性 CODESYS ランタイムシステム ", 
"url" : "_rtsl_compatibility.html#UUID-cc9ab11e-6c8d-25ef-88ec-9f65124bdb95_section-idm4591711893675234040560644037", 
"breadcrumbs" : "CODESYS Essentials \/ 互換性 \/ の互換性 CODESYS ランタイムシステム ", 
"snippet" : "ただし、古いバージョンの使用はお勧めしません。 CODESYS ランタイム システムの新しいバージョン。この互換性は明示的にテストされていません。新しいランタイム システムのセキュリティ修正により、古いランタイム システムとの互換性がなくなる可能性があります。 CODESYS バージョン。 既存のランタイム バージョンとの互換性については、次の点に注意する必要があります。 の新機能 CODESYS 通常、デバイスの説明で有効になります。その結果、これらのバージョンは、古いランタイム システムまたは古いデバイス記述に対しては無効になります。 すべての外部ライブラリのバージョンは、デバイス記述によ...", 
"body" : "ただし、古いバージョンの使用はお勧めしません。 CODESYS ランタイム システムの新しいバージョン。この互換性は明示的にテストされていません。新しいランタイム システムのセキュリティ修正により、古いランタイム システムとの互換性がなくなる可能性があります。 CODESYS バージョン。 既存のランタイム バージョンとの互換性については、次の点に注意する必要があります。 の新機能 CODESYS 通常、デバイスの説明で有効になります。その結果、これらのバージョンは、古いランタイム システムまたは古いデバイス記述に対しては無効になります。 すべての外部ライブラリのバージョンは、デバイス記述によって解決されます。その結果、それらは対応するランタイム システムに一致します。 内部ライブラリは次のように解決されます。 CODESYS ランタイム システムのバージョンに関係なく、バージョンが異なります。 通信サービスはタグ付きの共有フォーマットに従って構築されます。不明なタグはランタイム システムによって無視されます。その結果、通信サービスを変更することは可能ですが、プログラミング システムはランタイム システムが新しい情報を解釈することを期待しません。 " }, 
{ "title" : "デバイス記述の互換性 – ランタイムシステム ", 
"url" : "_rtsl_compatibility.html#UUID-cc9ab11e-6c8d-25ef-88ec-9f65124bdb95_section-idm4622937043899234045846685577", 
"breadcrumbs" : "CODESYS Essentials \/ 互換性 \/ デバイス記述の互換性 – ランタイムシステム ", 
"snippet" : "使用事例 サポート 古いバージョンのデバイス記述と新しいランタイム システムがログイン時に受け入れられます。 ✓ 新しいバージョンのデバイス記述と古いランタイム システムは受け入れられないため、ログインは拒否されます。 -- 既存のプロジェクトは、新しいランタイム システムであっても、既存のランタイム システム上で実行する必要があります。 CODESYS バージョン。これは、プロジェクト内のデバイスの説明を変更せず、ランタイム システムのバージョンと一致する既存のバージョンを使用することで実現できます。デバイス記述とランタイム システムのバージョンがそれほど異なっていないか、互換性がない場合は...", 
"body" : "使用事例 サポート 古いバージョンのデバイス記述と新しいランタイム システムがログイン時に受け入れられます。 ✓ 新しいバージョンのデバイス記述と古いランタイム システムは受け入れられないため、ログインは拒否されます。 -- 既存のプロジェクトは、新しいランタイム システムであっても、既存のランタイム システム上で実行する必要があります。 CODESYS バージョン。これは、プロジェクト内のデバイスの説明を変更せず、ランタイム システムのバージョンと一致する既存のバージョンを使用することで実現できます。デバイス記述とランタイム システムのバージョンがそれほど異なっていないか、互換性がない場合は、ランタイム システムにログインすることもできます。 デバイス記述には、ランタイム システムに外部関数が実装されている外部ライブラリのリストが含まれています。ライブラリの対応するバージョンは、ライブラリ プレースホルダ リストで指定されます。このリストはデバイスの製造元によって定義されます。 プレースホルダー リストには、対応するランタイム コンポーネントがランタイム システムで使用できるライブラリのみを含める必要があります。 デバイス記述とランタイムシステム間の互換性範囲を設定することができます。これは、バージョンが一致しない場合、コントローラーにログインできないことを意味します。この範囲は、ランタイム システムの次の設定を使用してデバイス メーカーによって選択できます (「 SysTargetItf.h ランタイム システムの): SYSTARGETKEY_INT_TARGET_VERSION_MASK 「TargetVersionMask」：ターゲットバージョンとデバイス記述との互換性をチェックするためのマスクを指定する設定。マスクでは有効数字のみがチェックされます。 SYSTARGETKEY_INT_TARGET_VERSION_COMPATIBILITY_MASK 「TargetVersionCompatibilityMask」: ターゲット バージョンとデバイスの説明との互換性をチェックするための互換性マスクを指定する設定。ターゲット バージョンよりも低いデバイス記述、またはターゲット バージョンと同じデバイス記述が受け入れられます。デバイス記述の上位バージョンは拒否されます。 電流例 CODESYS CODESYS バージョン CODESYS コントロールバージョン デバイスの説明のバージョン 推奨 制限 コメント 3.5.19.0 3.5.19.0 3.5.19.0 はい、最適です -- これが最適な組み合わせです。 3.5.19.0 3.5.12.0 3.5.12.0 はい -- これは典型的な互換性のケースです。 3.5.19.0 3.5.12.0 3.5.10.0 いいえ、しかし可能です コントローラにログインするときに DevDesc が一致しないという警告が表示される これが可能なのは、 DevDesc コントローラのバージョンよりも古いです。 3.5.19.0 3.5.12.0 3.5.19.0 いいえ コントローラーにアクセスできません デフォルトでは、これは拒否されます。 DevDesc とランタイム システムには互換性がありません。 3.5.19.0 3.5.10.0 3.5.10.30 いいえ コントローラーにアクセスできません これが可能なのは、 DevDesc 3.5.10.x の互換範囲内です。 古い人の例 CODESYS CODESYS バージョン CODESYS コントロールバージョン デバイスの説明のバージョン 推奨 制限 コメント 3.5.17.0 3.5.19.0 3.5.19.0 いいえ ランタイム システムのセキュリティ修正により、互換性がなくなる可能性があります。 すべての外部ライブラリのセットは、 CODESYS 。外部ライブラリでは、コンパイル エラーにつながる新しい IEC 言語リソースが使用されている可能性があります。 3.5.17.0 3.5.19.0 3.5.17.0 いいえ、しかし可能です ランタイム システムのセキュリティ修正により、互換性がなくなる可能性があります。 " }, 
{ "title" : "ブートプロジェクトの互換性 + 保持 - ランタイムシステム ", 
"url" : "_rtsl_compatibility.html#UUID-cc9ab11e-6c8d-25ef-88ec-9f65124bdb95_section-idm4482671035296034045851594374", 
"breadcrumbs" : "CODESYS Essentials \/ 互換性 \/ ブートプロジェクトの互換性 + 保持 - ランタイムシステム ", 
"snippet" : "使用事例 サポート 新しいランタイム システムは古いブート プロジェクトをロードします。 ✓ 古いランタイム システムは新しいブート プロジェクトを読み込みます。 -- メイン バージョン内のランタイム システムから既存のブート プロジェクトをロードできる必要があります。既存のブート プロジェクトは、ターゲットのタイプ指定と照合してチェックされます ( VendorID 、 DeviceID 、 そしてその DeviceVersion V3.5.8.0 以降) をロードする前に。 保存された保持ファイルから変数を保持します ( <application>.ret ) または SRAM からのも...", 
"body" : "使用事例 サポート 新しいランタイム システムは古いブート プロジェクトをロードします。 ✓ 古いランタイム システムは新しいブート プロジェクトを読み込みます。 -- メイン バージョン内のランタイム システムから既存のブート プロジェクトをロードできる必要があります。既存のブート プロジェクトは、ターゲットのタイプ指定と照合してチェックされます ( VendorID 、 DeviceID 、 そしてその DeviceVersion V3.5.8.0 以降) をロードする前に。 保存された保持ファイルから変数を保持します ( <application>.ret ) または SRAM からのものは常に互換性がある必要があります。チェックサムは保持領域ごとに別のファイルに保存されます。同じチェックサムがブート プロジェクトに保存されます。このチェックサムは、保持データからコンパイラによって生成され、保持領域内のすべての変数をそれぞれの型で識別します。保持データのチェックサムとブート プロジェクトのチェックサムが一致しない場合、ランタイム システムには動作を選択するためのオプションがいくつかあります。これらのオプションは [CmpApp] のセクション cfg ファイル： Bootproject.RetainMismatch.Init = 1 : ブート プロジェクトがロードされ、初期化されます。 Bootproject.RetainMismatch.Exception = 1 : ブート プロジェクトはロードされますが、アプリケーションは停止状態のままで、例外状態に設定されます。この状態は手動リセットで修正できます。 設定なし [DEFAULT] : ブート プロジェクトがロードされず、エラー メッセージがロガーに追加されます。 ランタイム システム バージョン 3.5.7.0 以前では、チェックサムはアプリケーションのデータ全体から計算されていました。新しいバージョンでは、チェックサムは保持領域内のデータのみから計算されます。これは、プロジェクトが変更された場合でも、その変更に保持データへの変更が含まれない限り、保持データを新しいバージョンのブート プロジェクトにロードできることを意味します。 " }, 
{ "title" : "CODESYS 構成、設定 ", 
"url" : "_cds_struct_configuring_development_system.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 ", 
"snippet" : "の動作、外観、メニュー構成、およびウィンドウレイアウトをカスタマイズできます。 CODESYS Development System 個別に構成します。メニューで ツール インターフェイスをカスタマイズし、設定するためのダイアログがあります CODESYS -オプション。 詳細については、以下を参照してください。 カスタマイズ と オプション...", 
"body" : "の動作、外観、メニュー構成、およびウィンドウレイアウトをカスタマイズできます。 CODESYS Development System 個別に構成します。メニューで ツール インターフェイスをカスタマイズし、設定するためのダイアログがあります CODESYS -オプション。 詳細については、以下を参照してください。 カスタマイズ と オプション" }, 
{ "title" : "CODESYS -オプションを設定します ", 
"url" : "_cds_configuring_dev_sys_options.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ CODESYS -オプションを設定します ", 
"snippet" : "の動作と外観を変更できます CODESYS Development System ダイアログのさまざまなタブで オプション 構成、設定。コマンドを選択するとダイアログが開きます ツール→オプション 。ここでは、さまざまなエディターと機能のデフォルト設定を行うことができます。これらの設定は CODESYS -ワイド有効。 設定は、ローカルシステムの現在のユーザープロファイルに保存されます。ユーザーまたはマシン（コンピューター）関連のオプション設定をxmlファイルにエクスポートして、他のシステムに転送できます。 V3.5SP13からチェック CODESYS 開発システムを初めて起動するとき、古いバ...", 
"body" : "の動作と外観を変更できます CODESYS Development System ダイアログのさまざまなタブで オプション 構成、設定。コマンドを選択するとダイアログが開きます ツール→オプション 。ここでは、さまざまなエディターと機能のデフォルト設定を行うことができます。これらの設定は CODESYS -ワイド有効。 設定は、ローカルシステムの現在のユーザープロファイルに保存されます。ユーザーまたはマシン（コンピューター）関連のオプション設定をxmlファイルにエクスポートして、他のシステムに転送できます。 V3.5SP13からチェック CODESYS 開発システムを初めて起動するとき、古いバージョンがすでにインストールされているかどうか。その場合、ダイアログが表示されます インポートウィザード 古いバージョンで設定されたものを採用する CODESYS -オプション。 " }, 
{ "title" : "インターフェイスをカスタマイズする ", 
"url" : "_cds_struct_userinterface_usage.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ インターフェイスをカスタマイズする ", 
"snippet" : "CODESYS ユーザーインターフェイスをニーズに合わせて個別に調整する可能性を提供します。ウィンドウやメニューやコマンドの表示を自由に配置できます。...", 
"body" : "CODESYS ユーザーインターフェイスをニーズに合わせて個別に調整する可能性を提供します。ウィンドウやメニューやコマンドの表示を自由に配置できます。 " }, 
{ "title" : "メニューをカスタマイズする ", 
"url" : "_cds_customizing_menu.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ インターフェイスをカスタマイズする \/ メニューをカスタマイズする ", 
"snippet" : "メニューコマンドは、 CODESYS 必要に応じてユーザーインターフェイスを調整します。構成ダイアログを介してメニューを非表示または追加できます。 コマンドの追加 コマンドを選択します ツール→カスタマイズ 。 ダイアログが開きます 調整 。タブ メニュー が表示されます。 新しいコマンドを追加するメニューのメニューツリーを開きます。 空のアイコンを選択します 。 ボタンをクリックします コマンドを追加 。 対話 コマンドを追加 開きます。 ダイアログでは、すべてのコマンドがカテゴリにグループ化されています。 追加するコマンドを選択します。クリック わかった 。 新しいコマンドがメニューツリー...", 
"body" : "メニューコマンドは、 CODESYS 必要に応じてユーザーインターフェイスを調整します。構成ダイアログを介してメニューを非表示または追加できます。 コマンドの追加 コマンドを選択します ツール→カスタマイズ 。 ダイアログが開きます 調整 。タブ メニュー が表示されます。 新しいコマンドを追加するメニューのメニューツリーを開きます。 空のアイコンを選択します 。 ボタンをクリックします コマンドを追加 。 対話 コマンドを追加 開きます。 ダイアログでは、すべてのコマンドがカテゴリにグループ化されています。 追加するコマンドを選択します。クリック わかった 。 新しいコマンドがメニューツリーに追加されます。 ボタンでメニューの順序を変更します 上 と 下向き 。クリック ハイフンを追加 、個々のコマンドをハイフンで区切る場合。クリック OK 対話について 調整 選ぶ。 これで、新しいコマンドがメニューで使用できるようになります。 " }, 
{ "title" : "メニュー\/コマンドを削除する ", 
"url" : "_cds_customizing_menu.html#UUID-656ba63d-6853-57f4-0629-dca5d51e2842_id_a7314d76c3527bdc0a8640e005fa62d_id_0da504cb13c911e4a98d91f1d473d70d", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ インターフェイスをカスタマイズする \/ メニューをカスタマイズする \/ メニュー\/コマンドを削除する ", 
"snippet" : "コマンドを選択します ツール→カスタマイズ 。 ダイアログが開きます 調整 。タブ メニュー が表示されます。 メニューツリーでメニューを選択するか、メニューの下のコマンドを選択します。 クリック 削除する 。 メニューまたはコマンドがメニューツリーから削除されます。 ボタンをクリックします わかった 。 ダイアログが閉じ、メニューが調整されます。...", 
"body" : "コマンドを選択します ツール→カスタマイズ 。 ダイアログが開きます 調整 。タブ メニュー が表示されます。 メニューツリーでメニューを選択するか、メニューの下のコマンドを選択します。 クリック 削除する 。 メニューまたはコマンドがメニューツリーから削除されます。 ボタンをクリックします わかった 。 ダイアログが閉じ、メニューが調整されます。 " }, 
{ "title" : "メニューの追加 ", 
"url" : "_cds_customizing_menu.html#UUID-656ba63d-6853-57f4-0629-dca5d51e2842_id_a7314d76c3527bdc0a8640e005fa62d_id_4406632d13cd11e4a98d91f1d473d70d", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ インターフェイスをカスタマイズする \/ メニューをカスタマイズする \/ メニューの追加 ", 
"snippet" : "コマンドを選択します ツール→カスタマイズ 。 ダイアログが開きます 調整 。タブ メニュー が表示されます。 メニューツリーの一番下までスクロールします。 空のアイコンを選択します 。 クリック ポップアップメニューを追加 。 対話 ポップアップメニューを追加 開きます。 ボックスに入力します デフォルトのテキスト 新しいメニューの名前を入力します。 ローカリゼーションが必要ない場合は、手順9に進みます。 クリック 言語を追加する 。 利用可能なすべての言語の選択が開きます。 必要な言語を選択してください。 言語が言語のリストに追加されます。 フィールドをクリックします 文章 そこに言語依存...", 
"body" : "コマンドを選択します ツール→カスタマイズ 。 ダイアログが開きます 調整 。タブ メニュー が表示されます。 メニューツリーの一番下までスクロールします。 空のアイコンを選択します 。 クリック ポップアップメニューを追加 。 対話 ポップアップメニューを追加 開きます。 ボックスに入力します デフォルトのテキスト 新しいメニューの名前を入力します。 ローカリゼーションが必要ない場合は、手順9に進みます。 クリック 言語を追加する 。 利用可能なすべての言語の選択が開きます。 必要な言語を選択してください。 言語が言語のリストに追加されます。 フィールドをクリックします 文章 そこに言語依存のテキストを入力します。 クリック わかった 。 メニューツリーの最後に新しいメニューが追加されます。 ボタンでメニューの順序を変更します 上 と 下向き 。ボタンをクリックします わかった 対話について 調整 選ぶ。 メニュー内でコマンドが使用可能になるまで、新しいメニューは表示されません。 " }, 
{ "title" : "ツールバーをカスタマイズする ", 
"url" : "_cds_customizing_toolbar.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ インターフェイスをカスタマイズする \/ ツールバーをカスタマイズする ", 
"snippet" : "のツールバーを使用できます CODESYS 必要に応じてユーザーインターフェイスを調整します。構成ダイアログを介してツールバーを非表示または追加できます。 コマンドの追加 コマンドを選択します ツール→カスタマイズ 。 ダイアログが開きます 調整 。 タブを選択します ツールバー 。 新しいコマンドを追加するツールバーを開きます。 空のアイコンを選択します 。 ボタンをクリックします コマンドを追加 。 対話 コマンドを追加 開きます。 ダイアログでは、すべてのコマンドがカテゴリにグループ化されています。 追加するコマンドを選択します。クリック わかった 。 新しいコマンドがツールバーの下に追...", 
"body" : "のツールバーを使用できます CODESYS 必要に応じてユーザーインターフェイスを調整します。構成ダイアログを介してツールバーを非表示または追加できます。 コマンドの追加 コマンドを選択します ツール→カスタマイズ 。 ダイアログが開きます 調整 。 タブを選択します ツールバー 。 新しいコマンドを追加するツールバーを開きます。 空のアイコンを選択します 。 ボタンをクリックします コマンドを追加 。 対話 コマンドを追加 開きます。 ダイアログでは、すべてのコマンドがカテゴリにグループ化されています。 追加するコマンドを選択します。クリック わかった 。 新しいコマンドがツールバーの下に追加されます。 ボタンを使用して、ツールバー内の位置を変更します 上 と 下向き 。ボタンをクリックします ハイフンを追加 、個々のコマンドをハイフンで区切る場合。ボタンをクリックします わかった 対話について 調整 選ぶ。 新しいコマンドはツールバーで使用できます。 " }, 
{ "title" : "ツールバー\/コマンドの削除 ", 
"url" : "_cds_customizing_toolbar.html#UUID-91e60a2c-10a6-5255-018c-837339d7f7f0_id_e1e156c804c48c0a8640e01354a59_id_0da504cb13c911e4a98d91f1d473d70d", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ インターフェイスをカスタマイズする \/ ツールバーをカスタマイズする \/ ツールバー\/コマンドの削除 ", 
"snippet" : "コマンドを選択します ツール→カスタマイズ 。 ダイアログが開きます 調整 。 タブを選択します ツールバー 。 ツールバーまたはツールバーの下のコマンドを選択します。 ボタンをクリックします 削除する 。 ツールバーまたはコマンドが削除されます。 ボタンをクリックします わかった 。 ダイアログが閉じ、ツールバーまたはコマンドが削除されます。...", 
"body" : "コマンドを選択します ツール→カスタマイズ 。 ダイアログが開きます 調整 。 タブを選択します ツールバー 。 ツールバーまたはツールバーの下のコマンドを選択します。 ボタンをクリックします 削除する 。 ツールバーまたはコマンドが削除されます。 ボタンをクリックします わかった 。 ダイアログが閉じ、ツールバーまたはコマンドが削除されます。 " }, 
{ "title" : "ツールバーの追加 ", 
"url" : "_cds_customizing_toolbar.html#UUID-91e60a2c-10a6-5255-018c-837339d7f7f0_id_e1e156c804c48c0a8640e01354a59_id_4406632d13cd11e4a98d91f1d473d70d", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ インターフェイスをカスタマイズする \/ ツールバーをカスタマイズする \/ ツールバーの追加 ", 
"snippet" : "コマンドを選択します ツール→カスタマイズ 。 ダイアログが開きます 調整 。 タブを選択します ツールバー 。 最後の（空の）ツールバーを選択します。 ボタンをクリックします ツールバーを追加 。 空のツールバーでカーソルが点滅します。 名前を入力します。 ボタンを使用して、ツールバーの順序を変更します 上 と 下向き 。ボタンをクリックします わかった 対話について 調整 選ぶ。 CODESYS ツールバー内でコマンドが使用可能になるまで、新しいツールバーは表示されません。...", 
"body" : "コマンドを選択します ツール→カスタマイズ 。 ダイアログが開きます 調整 。 タブを選択します ツールバー 。 最後の（空の）ツールバーを選択します。 ボタンをクリックします ツールバーを追加 。 空のツールバーでカーソルが点滅します。 名前を入力します。 ボタンを使用して、ツールバーの順序を変更します 上 と 下向き 。ボタンをクリックします わかった 対話について 調整 選ぶ。 CODESYS ツールバー内でコマンドが使用可能になるまで、新しいツールバーは表示されません。 " }, 
{ "title" : "コマンドアイコンのカスタマイズ ", 
"url" : "_cds_customizing_command_icons.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ インターフェイスをカスタマイズする \/ コマンドアイコンのカスタマイズ ", 
"snippet" : "CODESYS コマンドにカスタムアイコンを割り当てることができます。 コマンドを選択します ツール→カスタマイズ 。 ダイアログが開きます 調整 。 タブを選択します コマンドアイコン 。 左側の概要でカテゴリを選択します ヘルプ 。 このカテゴリのすべてのコマンドは右半分に表示されます。 コマンドを選択します 情報 。 ボタンをクリックします 割り当てるには 。 アイコンファイル（* .ico）を選択するためのダイアログが開きます。 アイコンファイルを選択します。 ボタンをクリックします 開ける 。 選択したコマンドにアイコンが割り当てられます。 クリック わかった 。...", 
"body" : "CODESYS コマンドにカスタムアイコンを割り当てることができます。 コマンドを選択します ツール→カスタマイズ 。 ダイアログが開きます 調整 。 タブを選択します コマンドアイコン 。 左側の概要でカテゴリを選択します ヘルプ 。 このカテゴリのすべてのコマンドは右半分に表示されます。 コマンドを選択します 情報 。 ボタンをクリックします 割り当てるには 。 アイコンファイル（* .ico）を選択するためのダイアログが開きます。 アイコンファイルを選択します。 ボタンをクリックします 開ける 。 選択したコマンドにアイコンが割り当てられます。 クリック わかった 。 " }, 
{ "title" : "キーボードショートカットのカスタマイズ ", 
"url" : "_cds_customizing_keyboard_shortcuts.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ インターフェイスをカスタマイズする \/ キーボードショートカットのカスタマイズ ", 
"snippet" : "CODESYS キーボードショートカットを使用してコマンドを直接呼び出すことができます。事前定義されたキーボードショートカットをカスタマイズまたは拡張できます。 キーボードショートカットのカスタマイズ コマンドを選択します ツール→カスタマイズ 。 ダイアログが開きます 調整 。 タブを選択します キーボード 。 左側の概要でカテゴリを選択します ヘルプ 。 このカテゴリのすべてのコマンドは右半分に表示されます。 コマンドを選択します 検索 。 フィールドをクリックします キーボードショートカットのキーを押す 。 押す ctrl + トグル + S 。 CODESYS キーボードショートカット...", 
"body" : "CODESYS キーボードショートカットを使用してコマンドを直接呼び出すことができます。事前定義されたキーボードショートカットをカスタマイズまたは拡張できます。 キーボードショートカットのカスタマイズ コマンドを選択します ツール→カスタマイズ 。 ダイアログが開きます 調整 。 タブを選択します キーボード 。 左側の概要でカテゴリを選択します ヘルプ 。 このカテゴリのすべてのコマンドは右半分に表示されます。 コマンドを選択します 検索 。 フィールドをクリックします キーボードショートカットのキーを押す 。 押す ctrl + トグル + S 。 CODESYS キーボードショートカットをフィールドに挿入します。 ボタンをクリックします 割り当てるには 。 キーボードショートカットがコマンドに割り当てられます。 クリック わかった 。 あなたは命令することができます 検索 キーボードショートカットを使用するようになりました ctrl + トグル + S 電話。 詳細なヘルプについては、以下を参照してください。 キーボードショートカット、 ウィンドウズ™ ショートカット" }, 
{ "title" : "ウィンドウの配置を変更する ", 
"url" : "_cds_changing_window_layout.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ インターフェイスをカスタマイズする \/ ウィンドウの配置を変更する ", 
"snippet" : "でさまざまなウィンドウの配置を変更できます CODESYS 個々のニーズに簡単に適応します。 ウィンドウをタイトルバーまたはタブでドラッグします。 可能な位置を示す矢印記号が表示されます。例： マウスを使用して、ウィンドウを矢印記号の1つにドラッグします。 目標位置は青い網掛け部分で表示されます。 マウスの左ボタンを放します。 選択したターゲット領域にウィンドウが挿入されます。 の外でウィンドウを開くこともできます CODESYS -プログラミングインターフェイスを配置します。 詳細については、以下を参照してください。 ウィンドウサイズを変更する...", 
"body" : "でさまざまなウィンドウの配置を変更できます CODESYS 個々のニーズに簡単に適応します。 ウィンドウをタイトルバーまたはタブでドラッグします。 可能な位置を示す矢印記号が表示されます。例： マウスを使用して、ウィンドウを矢印記号の1つにドラッグします。 目標位置は青い網掛け部分で表示されます。 マウスの左ボタンを放します。 選択したターゲット領域にウィンドウが挿入されます。 の外でウィンドウを開くこともできます CODESYS -プログラミングインターフェイスを配置します。 詳細については、以下を参照してください。 ウィンドウサイズを変更する" }, 
{ "title" : "ウィンドウサイズを変更する ", 
"url" : "_cds_changing_window_size.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ インターフェイスをカスタマイズする \/ ウィンドウサイズを変更する ", 
"snippet" : "2つのウィンドウまたはビューの境界線にマウスを合わせます。 カーソルが両端矢印になります。 マウスを使用して、分割線を必要な位置にドラッグします。 境界線をドラッグすると、切り離されたウィンドウのサイズを変更できます。 詳細については、以下を参照してください。 ウィンドウの配置を変更する...", 
"body" : "2つのウィンドウまたはビューの境界線にマウスを合わせます。 カーソルが両端矢印になります。 マウスを使用して、分割線を必要な位置にドラッグします。 境界線をドラッグすると、切り離されたウィンドウのサイズを変更できます。 詳細については、以下を参照してください。 ウィンドウの配置を変更する" }, 
{ "title" : "ウィンドウの表示\/非表示 ", 
"url" : "_cds_autohiding_windows.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ インターフェイスをカスタマイズする \/ ウィンドウの表示\/非表示 ", 
"snippet" : "ウィンドウを再表示 非表示のウィンドウのタブをクリックします。 オプションを無効にする ウィンドウ→非表示 。 または、ボタンをクリックしてください ビューの右上隅にあります。 ウィンドウは永続的に表示されます。...", 
"body" : "ウィンドウを再表示 非表示のウィンドウのタブをクリックします。 オプションを無効にする ウィンドウ→非表示 。 または、ボタンをクリックしてください ビューの右上隅にあります。 ウィンドウは永続的に表示されます。 " }, 
{ "title" : "ウィンドウを非表示 ", 
"url" : "_cds_autohiding_windows.html#UUID-71d9107d-d831-5182-3e56-78ee9398c5e6_id_c1fb11d67be31b3fc0a8640e016f13ae_id_1657629d7c432017c0a8640e00b2156d", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ インターフェイスをカスタマイズする \/ ウィンドウの表示\/非表示 \/ ウィンドウを非表示 ", 
"snippet" : "ウィンドウを非表示にすると、ユーザーインターフェイスではタブとしてのみ表示されます。このタブの上にマウスを移動すると、ウィンドウが自動的に表示されます。 非表示にするウィンドウをクリックします。 オプションを有効にする ウィンドウ→非表示 。 または、ボタンをクリックしてください ビューの右上隅にあります。 ウィンドウは非表示になっており、メインウィンドウの側端にある小さなタブからのみ表示されます。 タブの上にマウスポインタを置きます。 マウスポインタがタブ上にある限り、ウィンドウが表示されます。...", 
"body" : "ウィンドウを非表示にすると、ユーザーインターフェイスではタブとしてのみ表示されます。このタブの上にマウスを移動すると、ウィンドウが自動的に表示されます。 非表示にするウィンドウをクリックします。 オプションを有効にする ウィンドウ→非表示 。 または、ボタンをクリックしてください ビューの右上隅にあります。 ウィンドウは非表示になっており、メインウィンドウの側端にある小さなタブからのみ表示されます。 タブの上にマウスポインタを置きます。 マウスポインタがタブ上にある限り、ウィンドウが表示されます。 " }, 
{ "title" : "ウィンドウを切り替える ", 
"url" : "_cds_switching_windows.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ インターフェイスをカスタマイズする \/ ウィンドウを切り替える ", 
"snippet" : "現在開いているビューとエディタウィンドウを直接切り替えることができます。 同時にボタンを押す ctrl と タブ 。を保持します ctrl ボタンが押されました。 すべてのアクティブなビューとエディターの概要が開きます。 を保持します ctrl 矢印キーを使用してウィンドウを選択しているときにキーを押しました。 それらをしましょう ctrl ボタンを離します。 選択したビューまたは選択したエディターがアクティブになります。...", 
"body" : "現在開いているビューとエディタウィンドウを直接切り替えることができます。 同時にボタンを押す ctrl と タブ 。を保持します ctrl ボタンが押されました。 すべてのアクティブなビューとエディターの概要が開きます。 を保持します ctrl 矢印キーを使用してウィンドウを選択しているときにキーを押しました。 それらをしましょう ctrl ボタンを離します。 選択したビューまたは選択したエディターがアクティブになります。 " }, 
{ "title" : "CODESYS オフラインヘルプのインストール ", 
"url" : "_cds_installing_offlinehelp.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ CODESYS オフラインヘルプのインストール ", 
"snippet" : "ザル CODESYS Development System オンラインヘルプはオフラインヘルプとしてインストールできます。オフラインヘルプには、次の出版物を除き、オンラインヘルプのすべてのヘルプコンテンツが含まれています すべてのライブラリドキュメンテーション これらはライブラリマネージャーでオフラインで読むことができます。 LibDev サマリー CODESYS Development System スクリプティング API オフラインヘルプは、ヘルプポータルのスタートページからインストールすることも、次の方法で直接インストールすることもできます。 CODESYS Installer 。 を...", 
"body" : "ザル CODESYS Development System オンラインヘルプはオフラインヘルプとしてインストールできます。オフラインヘルプには、次の出版物を除き、オンラインヘルプのすべてのヘルプコンテンツが含まれています すべてのライブラリドキュメンテーション これらはライブラリマネージャーでオフラインで読むことができます。 LibDev サマリー CODESYS Development System スクリプティング API オフラインヘルプは、ヘルプポータルのスタートページからインストールすることも、次の方法で直接インストールすることもできます。 CODESYS Installer 。 を使用してオフラインヘルプをアクティブ化します。 オンラインヘルプの代わりにオフラインヘルプを使用する の「オプション」 [ツール] → オプション → ヘルプ メニュー。 詳細については、以下を参照してください。 独自のコンテンツでCODESYSオフラインヘルプを拡張。 " }, 
{ "title" : "独自のコンテンツでCODESYSオフラインヘルプを拡張 ", 
"url" : "_cds_extending_offlinehelp.html", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ CODESYS オフラインヘルプのインストール \/ 独自のコンテンツでCODESYSオフラインヘルプを拡張 ", 
"snippet" : "ザル CODESYS Development System には、独自のヘルプページでオフラインヘルプを拡張する機能があります。新しいヘルプページは、どのような構造でも、目次のどの位置にも追加できます。 さらに、追加されたヘルプページに目次全体を表示することもできます。言語の切り替えや内容の検索もサポートされています HTML ページを統合するための要件は、のインストールです。 CODESYS オフラインヘルプ。ザブ CODESYS オフラインヘルプはからインストールできます。 ヘルプポータル または CODESYS Installer 。 拡張には次のファイルが必要です HTML 形式のヘル...", 
"body" : "ザル CODESYS Development System には、独自のヘルプページでオフラインヘルプを拡張する機能があります。新しいヘルプページは、どのような構造でも、目次のどの位置にも追加できます。 さらに、追加されたヘルプページに目次全体を表示することもできます。言語の切り替えや内容の検索もサポートされています HTML ページを統合するための要件は、のインストールです。 CODESYS オフラインヘルプ。ザブ CODESYS オフラインヘルプはからインストールできます。 ヘルプポータル または CODESYS Installer 。 拡張には次のファイルが必要です HTML 形式のヘルプページ ヘルプページは、ディレクトリ C:\\ProgramData\\CODESYS\\Offline Help\\<language> . 設定ファイル: <name>-productinfo.json 製品ヘルプの概要 設定ファイルはディレクトリに保存されます。 C:\\ProgramData\\CODESYS\\Offline Help\\de\\js 。 設定ファイル: <name>-toc.json 新しいページの挿入位置 設定ファイルはディレクトリに保存されます。 C:\\ProgramData\\CODESYS\\Offline Help\\de\\js 。 設定ファイル: <name>-search.json 新しいコンテンツを検索に含める 設定ファイルはディレクトリに保存されます。 C:\\ProgramData\\CODESYS\\Offline Help\\de\\js 。 このファイルはオプションです。 3つのコンフィギュレーション・ファイルの接頭辞 <name> は同一でなければならない。 ザ・ファイル fuzzydata.js 、 productsinfo.js 、および toc.js はオフラインヘルプの標準設定ファイルです。起動後 CODESYS json ファイルの内容は標準設定ファイル (*.js) に統合されます。元の設定ファイルは、に保存されます backup ディレクトリ。 " }, 
{ "title" : "設定ファイルの作成 ", 
"url" : "_cds_extending_offlinehelp.html#UUID-6d26fb44-e1b7-57a4-fd2b-a0110ae412ec_section-idm43473870969756", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ CODESYS オフラインヘルプのインストール \/ 独自のコンテンツでCODESYSオフラインヘルプを拡張 \/ 設定ファイルの作成 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "製品ヘルプ概要の設定ファイル  <name>-productinfo.json ", 
"url" : "_cds_extending_offlinehelp.html#UUID-6d26fb44-e1b7-57a4-fd2b-a0110ae412ec_section-idm450371129061464", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ CODESYS オフラインヘルプのインストール \/ 独自のコンテンツでCODESYSオフラインヘルプを拡張 \/ 設定ファイルの作成 \/ 製品ヘルプ概要の設定ファイル  <name>-productinfo.json ", 
"snippet" : "このファイルにより、製品ヘルプの概要ページにエントリが作成されます。 title 表示されている製品名とバージョン url リンク先のページ children 重要性なし、評価なし 例 [ { \"title\": \"3rd Party, V1.2.3.4\", \"url\": \"3rd_new_pub.html\", \"children\": [] } ]...", 
"body" : "このファイルにより、製品ヘルプの概要ページにエントリが作成されます。 title 表示されている製品名とバージョン url リンク先のページ children 重要性なし、評価なし 例 [\n {\n \"title\": \"3rd Party, V1.2.3.4\",\n \"url\": \"3rd_new_pub.html\",\n \"children\": []\n }\n] " }, 
{ "title" : "新しいヘルプページの挿入位置の設定ファイル <name>-toc.json ", 
"url" : "_cds_extending_offlinehelp.html#UUID-6d26fb44-e1b7-57a4-fd2b-a0110ae412ec_section-idm471214354880041", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ CODESYS オフラインヘルプのインストール \/ 独自のコンテンツでCODESYSオフラインヘルプを拡張 \/ 設定ファイルの作成 \/ 新しいヘルプページの挿入位置の設定ファイル <name>-toc.json ", 
"snippet" : "このファイルは、新しいページがヘルプに統合される位置を定義します。 url 挿入するページの HTML 名 text 挿入するページの名前。この名前は目次に表示されます。 insert_after 指定されたヘルプページと同じレベルに新しいページを挿入します append_below 指定されたヘルプページの下の最後の子ページとして新しいページを挿入します。 もし \/ HTML 名の代わりに文字が割り当てられ、新しいページが目次の最上位に追加されます。 children 子ページを追加します プレースホルダー: * 製品のスタートページの HTML 名には内部 ID がありますが、これは変更さ...", 
"body" : "このファイルは、新しいページがヘルプに統合される位置を定義します。 url 挿入するページの HTML 名 text 挿入するページの名前。この名前は目次に表示されます。 insert_after 指定されたヘルプページと同じレベルに新しいページを挿入します append_below 指定されたヘルプページの下の最後の子ページとして新しいページを挿入します。 もし \/ HTML 名の代わりに文字が割り当てられ、新しいページが目次の最上位に追加されます。 children 子ページを追加します プレースホルダー: * 製品のスタートページの HTML 名には内部 ID がありますが、これは変更される可能性があります。変更後もこれらのページが見つけられるようにするには、プレースホルダーを使用します * このような場合は ID に使用してください。 サンプル 1 ヘルプページ 3rd_new_pub.html ヘルプページの後に兄弟ページとして挿入されます 1064796-311627-codesys-redundancy.html 。 [\n { \"url\": \"3rd_new_pub.html\",\n \"text\": \"New Publication\",\n \"insert_after\": \"1064796-311627-codesys-redundancy.html\"\n }\n] サンプル 2 例 1 に加えて、下に 2 つの子ページが挿入されています New Publication ページ。 [\n { \"url\": \"3rd_new_pub.html\",\n \"text\": \"New Publication\",\n \"children\": [\n {\n \"url\": \"3rd_new_pub_topic1.html\",\n \"text\": \"New Publication - Chapter 1\"\n },\n {\n \"url\": \"3rd_new_pub_topic2.html\",\n \"text\": \"New Publication - Chapter 2\"\n }\n ],\n \"insert_after\": \"1064796-311627-codesys-redundancy.html\"\n }\n] サンプル 3 製品のスタートページの HTML 名には内部 ID がありますが、これは変更される可能性があります。変更後もこれらのページが見つけられるようにするには、プレースホルダーを使用します * このような場合は ID に使用してください。 例 2 と似ていますが、プレースホルダーが使われています。 Insert_after ページ。 [\n { \"url\": \"3rd_new_pub.html\",\n \"text\": \"New Publication\",\n \"children\": [\n {\n \"url\": \"3rd_new_pub_topic1.html\",\n \"text\": \"New Publication - Chapter 1\"\n },\n {\n \"url\": \"3rd_new_pub_topic2.html\",\n \"text\": \"New Publication - Chapter 2\"\n }\n ],\n \"insert_after\": \"*-codesys-redundancy.html\"\n }\n] サンプル 4 ヘルプページ 3rd_new_pub.html そして、ヘルプページの下の最後の子ページとして 2 つのサブページが挿入されます。 *-codesys-softmotion.html 。 [\n { \"url\": \"3rd_new_pub.html\",\n \"text\": \"New Publication\",\n \"children\": [\n {\n \"url\": \"3rd_new_pub_topic1.html\",\n \"text\": \"New Publication - Chapter 1\"\n },\n {\n \"url\": \"3rd_new_pub_topic2.html\",\n \"text\": \"New Publication - Chapter 2\"\n }\n ],\n \"append_below\": \"*-codesys-softmotion.html\"\n }\n] サンプル 5 この設定により、ヘルプページが追加されます。 3rd_toplevel.html 目次の最後にあるトップレベル。 [\n {\n \"url\": \"3rd_toplevel.html\",\n \"text\": \"Kapitel Toplevel\",\n \"append_below\": \"\/\"\n }\n] サンプル 6 この例は、挿入位置が異なる構成を示しています。 [\n {\n \"url\": \"3rd_new_pub.html\"\n, \"text\": \"New Publication\",\n \"children\": [\n {\n \"url\": \"3rd_new_pub_topic1.html\",\n \"text\": \"New Publication - Chapter 1\"\n },\n {\n \"url\": \"3rd_new_pub_topic2.html\",\n \"text\": \"New Publication - Chapter 2\"\n }\n ],\n \"insert_after\": \"*-codesys-git.html\"\n },\n {\n \"url\": \"3rd_add_child.html\",\n \"text\": \"Kapitel Geschwister\",\n \"insert_after\": \"_pbdp_cmd_scan_devices.html\"\n },\n {\n \"url\": \"3rd_toplevel.html\",\n \"text\": \"Chapter Toplevel\",\n \"append_below\": \"\/\"\n }\n] " }, 
{ "title" : "検索用設定ファイル <name>-search.json ", 
"url" : "_cds_extending_offlinehelp.html#UUID-6d26fb44-e1b7-57a4-fd2b-a0110ae412ec_section-idm4251855645307457", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ CODESYS オフラインヘルプのインストール \/ 独自のコンテンツでCODESYSオフラインヘルプを拡張 \/ 設定ファイルの作成 \/ 検索用設定ファイル <name>-search.json ", 
"snippet" : "この設定には、ページの完全なヘルプテキストが含まれています。 title チャプターのタイトル。検索ヒットとして表示されます url 見つかったページの HTML 名 breadcrumbs ページのブレッドクラムが見つかりました。検索ヒットに表示されます。 snippet ページが見つかったショートテキスト。検索ヒットに表示されます body 見出しを含むヘルプページの全文 [ { \"title\": \"Chapter 1, \"url\": \"3rd_chapter1.html\", \"breadcrumbs\": \"3rdParty - Offline help \/ Chapter 1\", \"sn...", 
"body" : "この設定には、ページの完全なヘルプテキストが含まれています。 title チャプターのタイトル。検索ヒットとして表示されます url 見つかったページの HTML 名 breadcrumbs ページのブレッドクラムが見つかりました。検索ヒットに表示されます。 snippet ページが見つかったショートテキスト。検索ヒットに表示されます body 見出しを含むヘルプページの全文 [\n {\n \"title\": \"Chapter 1,\n \"url\": \"3rd_chapter1.html\",\n \"breadcrumbs\": \"3rdParty - Offline help \/ Chapter 1\",\n \"snippet\": \"Lorem ipsum dolor sit amet...\",\n \"body\": \"Chapter 1. Lorem ipsum dolor sit amet, consetetur sadipscing elitr,\n sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam \n erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. \n Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor \n sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam \n nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam \n voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita \n kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet\"\n },\n {\n \"title\": \"Chapter 2\",\n \"url\": \"3rd_chapter2.html\",\n \"breadcrumbs\": \"3rdParty - Offline help \/ Chapter 2\",\n \"snippet\": \"Lorem ipsum dolor sit amet...\",\n \"body\": \"Chapter 2. Lorem ipsum dolor sit amet, consetetur sadipscing elitr,\n sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam \n erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. \n Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor \n sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam \n nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam \n voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita \n kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet\"\n }\n] " }, 
{ "title" : "HTML ページのカスタマイズ ", 
"url" : "_cds_extending_offlinehelp.html#UUID-6d26fb44-e1b7-57a4-fd2b-a0110ae412ec_section-idm234730211407826", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ CODESYS オフラインヘルプのインストール \/ 独自のコンテンツでCODESYSオフラインヘルプを拡張 \/ HTML ページのカスタマイズ ", 
"snippet" : "追加のヘルプページは HTML 形式である必要があります。新しく追加したページに目次、言語切り替え、検索フィールドも確実に表示されるようにするには、新しいページを HTML フレームに埋め込む必要があります テンプレートファイル TemplateOfflineHelp_Simple.html サブディレクトリにあります。 C:\\ProgramData\\CODESYS\\Offline Help\\Templates オフラインヘルプをインストールした後。このテンプレートは他の HTML ページのフレームワークとして使用されます。 以下の変更が必要です。 ブラウザ内のプレースホルダーへのタブ名の挿入...", 
"body" : "追加のヘルプページは HTML 形式である必要があります。新しく追加したページに目次、言語切り替え、検索フィールドも確実に表示されるようにするには、新しいページを HTML フレームに埋め込む必要があります テンプレートファイル TemplateOfflineHelp_Simple.html サブディレクトリにあります。 C:\\ProgramData\\CODESYS\\Offline Help\\Templates オフラインヘルプをインストールした後。このテンプレートは他の HTML ページのフレームワークとして使用されます。 以下の変更が必要です。 ブラウザ内のプレースホルダーへのタブ名の挿入 {{TITLE}} 。これは通常、ヘルプページの見出しです。 <title>{{TITLE}}<\/title> \n 追加ヘルプページの内容全体をプレースホルダーに挿入 {{CONTENT}} 。 <!-- Place main content here -->\n{{CONTENT}} \n 新しいページのデザインが次のようになっている場合 CODESYS ヘルプ、次に既存のスタイルシートクラス CODESYS オフラインヘルプを使用する必要があります。 TemplateOfflineHelp_Full.html は、これらの変更の例を示しています。 " }, 
{ "title" : "パッケージによるヘルプページのインストール ", 
"url" : "_cds_extending_offlinehelp.html#UUID-6d26fb44-e1b7-57a4-fd2b-a0110ae412ec_section-idm234730226436619", 
"breadcrumbs" : "CODESYS Essentials \/ CODESYS 構成、設定 \/ CODESYS オフラインヘルプのインストール \/ 独自のコンテンツでCODESYSオフラインヘルプを拡張 \/ パッケージによるヘルプページのインストール ", 
"snippet" : "通常、パッケージはオフラインヘルプの拡張に使用されます。 例:パッケージへのデータの保存 のサンプルエントリ package.manifest ファイル <Component> <General> <Id>1<\/Id> <Name>Offline Help Files<\/Name> <Description>Offline help files for 3rd party product<\/Description> <Selectable>false<\/Selectable> <SelectedByDefault>true<\/SelectedByDefault> <\/General> <Ite...", 
"body" : "通常、パッケージはオフラインヘルプの拡張に使用されます。 例:パッケージへのデータの保存 のサンプルエントリ package.manifest ファイル <Component>\n <General>\n <Id>1<\/Id>\n <Name>Offline Help Files<\/Name>\n <Description>Offline help files for 3rd party product<\/Description>\n <Selectable>false<\/Selectable>\n <SelectedByDefault>true<\/SelectedByDefault>\n <\/General>\n <Items>\n <Folder>\n <TargetFolder>%REPOSITORY_LOCATION%<\/TargetFolder>\n <Path>Offline Help<\/Path>\n <\/Folder>\n <\/Items>\n<\/Component>\n " }, 
{ "title" : "最初のCODESYSプログラム ", 
"url" : "_cds_tutorial_refrigerator_control.html", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "準備 ", 
"url" : "_cds_tutorial_refrigerator_control-1852840.html", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ 準備 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "始める前に ", 
"url" : "_cds_tutorial_refrigerator_control-1852840.html#UUID-37040273-01ac-3f6e-080f-c300763700a5_id_ad860c2982c38315c0a8640e0192efdf_id_1acf960483fd46f8c0a8640e01c47574", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ 準備 \/ 始める前に ", 
"snippet" : "データセキュリティ: データセキュリティ侵害のリスクを最小限に抑えるため、以下の組織的および技術的対策を講じることをお勧めします。 オープンネットワークやインターネットからPLCや制御ネットワークにアクセスすることは避けてください。 リモートアクセスには VPN を使用してください。 ファイアウォールをインストールします。 ビジュアライゼーションをウェブ上に公開する場合は、不正アクセスを防ぐためにパスワードを設定してください。 最新バージョンのゲートウェイサーバーと Web サーバーを使用してください。 インストール中 CODESYS インストールには、開発システムと CODESYS ゲートウ...", 
"body" : "データセキュリティ: データセキュリティ侵害のリスクを最小限に抑えるため、以下の組織的および技術的対策を講じることをお勧めします。 オープンネットワークやインターネットからPLCや制御ネットワークにアクセスすることは避けてください。 リモートアクセスには VPN を使用してください。 ファイアウォールをインストールします。 ビジュアライゼーションをウェブ上に公開する場合は、不正アクセスを防ぐためにパスワードを設定してください。 最新バージョンのゲートウェイサーバーと Web サーバーを使用してください。 インストール中 CODESYS インストールには、開発システムと CODESYS ゲートウェイと CODESYS Control Win 、そのサービスには Windows タスクバーからアクセスできます。これら 3 つのプログラムは、コンピューター上のコントローラーをシミュレートするために必要です " }, 
{ "title" : "初めてのプロジェクトの内容 ", 
"url" : "_cds_tutorial_refrigerator_control-1852840.html#UUID-37040273-01ac-3f6e-080f-c300763700a5_id_ad860c2982c38315c0a8640e0192efdf_id_95ee254f8863349ec0a8640e00ddaa4f", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ 準備 \/ 初めてのプロジェクトの内容 ", 
"snippet" : "このチュートリアルでは、簡単な冷蔵庫コントローラーをプログラムします。ここで手順を追って作成するサンプルプロジェクトの他に、完成したプロジェクトには操作と診断を含む完全なビジュアライゼーションが含まれています。これで完成です RefrigeratorControl.projectarchive プロジェクトは次の場所にあります CODESYS のインストールディレクトリ Projects ディレクトリ。 従来の冷蔵庫と同様に、温度はユーザーがロータリーコントロールを介して指定できます。 冷蔵庫はセンサーを使用して実際の温度を測定します。温度が高すぎると、冷蔵庫は調整可能な遅延時間でコンプレッサ...", 
"body" : "このチュートリアルでは、簡単な冷蔵庫コントローラーをプログラムします。ここで手順を追って作成するサンプルプロジェクトの他に、完成したプロジェクトには操作と診断を含む完全なビジュアライゼーションが含まれています。これで完成です RefrigeratorControl.projectarchive プロジェクトは次の場所にあります CODESYS のインストールディレクトリ Projects ディレクトリ。 従来の冷蔵庫と同様に、温度はユーザーがロータリーコントロールを介して指定できます。 冷蔵庫はセンサーを使用して実際の温度を測定します。温度が高すぎると、冷蔵庫は調整可能な遅延時間でコンプレッサーを始動します。 コンプレッサは、ヒステリシスを1度引いた所望の温度に達するまで冷却されます。ヒステリシスは、設定温度付近で実際の温度が大きく変動し、コンプレッサの電源が絶えず切れたりオンになったりするのを防ぐためのものです ドアを開けると、冷蔵庫の中のランプが点灯します。ドアを長く開けすぎると、ビープ音が鳴ります モーターが長時間作動しているにもかかわらずコンプレッサーが設定温度に達しない場合、ブザーは安定した可聴信号を発します。 エンジニアリング: 冷却アクティビティは、アプリケーションのメインプログラムで制御されます。信号管理は別の POU で制御されます。必要な標準ファンクションブロックは、以下にあります。 Standard ライブラリ。このサンプルプロジェクトでは物理的な温度センサーも物理的なアクチュエーターも接続されていないため、温度の上昇と下降をシミュレートするプログラムも作成します。これにより、後で冷蔵庫コントローラーの動作をオンラインモードで監視できます すべての POU が使用する変数は、グローバル変数リストで定義する必要があります。 " }, 
{ "title" : "起動 CODESYS Development System ", 
"url" : "_cds_tutorial_refrigerator_control-1852840.html#UUID-37040273-01ac-3f6e-080f-c300763700a5_id_ad860c2982c38315c0a8640e0192efdf_id_17e8e10183fd46f9c0a8640e017b2032", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ 準備 \/ 起動 CODESYS Development System ", 
"snippet" : "インストールが完了しました CODESYS Development System で起動しました CODESYS <current version>「デフォルトプロファイル。開発システムのフレームウィンドウが開き、標準メニューバーが表示されます。プロジェクトはまだ開いていません。...", 
"body" : "インストールが完了しました CODESYS Development System で起動しました CODESYS <current version>「デフォルトプロファイル。開発システムのフレームウィンドウが開き、標準メニューバーが表示されます。プロジェクトはまだ開いていません。 " }, 
{ "title" : "プロジェクトの作成とPLCデバイスの選択 ", 
"url" : "_cds_tutorial_refrigerator_create.html", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ プロジェクトの作成とPLCデバイスの選択 ", 
"snippet" : "コマンドを選択します ファイル→新規プロジェクト 。 ウィンドウで選択 テンプレート テンプレート デフォルトプロジェクト 。 プロジェクトの名前と場所を入力し、ボタンをクリックします わかった 。 対話 デフォルトプロジェクト メインプログラムのデバイスタイプと実装言語を入力するために表示されます。 リストから選択 端末 エントリ CODESYS Control Win 。 リストから選択 PLC_PRGの エントリ Continuos機能チャート（CFC） ボタンをクリックします わかった 。 プロジェクトはになります CODESYS -フレームウィンドウが開きます。 フレームウィンドウの...", 
"body" : "コマンドを選択します ファイル→新規プロジェクト 。 ウィンドウで選択 テンプレート テンプレート デフォルトプロジェクト 。 プロジェクトの名前と場所を入力し、ボタンをクリックします わかった 。 対話 デフォルトプロジェクト メインプログラムのデバイスタイプと実装言語を入力するために表示されます。 リストから選択 端末 エントリ CODESYS Control Win 。 リストから選択 PLC_PRGの エントリ Continuos機能チャート（CFC） ボタンをクリックします わかった 。 プロジェクトはになります CODESYS -フレームウィンドウが開きます。 フレームウィンドウの左側、ビュー内 装置 、「デバイスツリー」というタイトルのビューが表示されます 装置 。以前に選択したPLCデバイスはデフォルト名です 端末 マウントされています。 オブジェクトの下 PLCロジック すでにオブジェクトをハングアップしています 応用 アプリケーションをあなたがプログラムするために。 応用 メインプログラムのオブジェクトがすでに含まれています PLC_PRG そしてその ライブラリマネージャー 。 the ライブラリマネージャー すでにライブラリが含まれています IoStandard と Standard 。 IoStandard I \/ O構成にはが必要です。図書館 Standard IEC61131-3規格で説明されているすべての機能と機能ブロックが含まれています。 オブジェクトはデバイスツリーの最後にぶら下がっています タスク構成 とともに MainTask 、の処理 PLC_PRG コントロール。下 タスク構成 たとえば、後で視覚化のためにオブジェクトを挿入できます。 ライブラリに加えて IoStandard と Standard このサンプルプロジェクトにはライブラリが必要です Util ： オブジェクトをダブルクリックします ライブラリマネージャー デバイスツリー内。 ライブラリマネージャーがエディターで開きます。 エディターヘッダーをクリックします ライブラリを追加 全文検索ボックスに「Util」と入力します。 検索結果からライブラリを選択します Util で選択を確認します わかった 。 図書館 Util がライブラリマネージャに追加され、プロジェクトでライブラリのブロックを使用できるようになります。 " }, 
{ "title" : "プロジェクトでのコントローラーアプリケーションのプログラミング ", 
"url" : "_cds_tutorial_refrigerator_program.html", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ プロジェクトでのコントローラーアプリケーションのプログラミング ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "グローバル変数の宣言 ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_a9dca56f886334a3c0a8640e00c68270", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ プロジェクトでのコントローラーアプリケーションのプログラミング \/ グローバル変数の宣言 ", 
"snippet" : "まず、アプリケーション全体で使用する変数を宣言します。そのためには、以下にグローバル変数リストを作成します [アプリケーション] : 選択してください Application 入力してクリック オブジェクトの追加 → グローバル変数リスト コンテキストメニューで、デフォルト名を変更する GVL に Glob_Var クリック 追加 確認します。 ザル Glob_Var オブジェクトは下に表示されます Application 。GVL エディタがデバイスツリーの右側に表示されます テキストビューが開くと、キーワードがすでに含まれています VAR_GLOBAL そして END_VAR 例では、 エ...", 
"body" : "まず、アプリケーション全体で使用する変数を宣言します。そのためには、以下にグローバル変数リストを作成します [アプリケーション] : 選択してください Application 入力してクリック オブジェクトの追加 → グローバル変数リスト コンテキストメニューで、デフォルト名を変更する GVL に Glob_Var クリック 追加 確認します。 ザル Glob_Var オブジェクトは下に表示されます Application 。GVL エディタがデバイスツリーの右側に表示されます テキストビューが開くと、キーワードがすでに含まれています VAR_GLOBAL そして END_VAR 例では、 エディターの右側のサイドバーにあるボタンをクリックすると、表形式のビューがアクティブになります。 空の行が表示されます。カーソルは [名前] カラム。 コンテキストメニューで、 挿入 。 入力フィールドが開きます。同時に、 スコープ VAR_GLOBAL と データタイプ BOOL 行に自動的に入力されます。 指定 rTempActual で 名前 フィールド。 フィールドをダブルクリックします データタイプ カラム。 これでフィールドを編集できるようになり、 ボタンが表示されます。 クリック ボタンを押して選択 入力アシスタント 。 ザル 入力アシスタント ダイアログが開きます。 データ型を選択 REAL クリック わかりました 。 に数値を入力します [初期化] カラム (例: 8.0 )。 以下の変数を同じ方法で宣言します。 姓 データタイプ 初期化 コメント rTempActual REAL 8.0 実際の温度 rTempSet REAL 8.0 温度を設定 xDoorOpen BOOL FALSE ドアの状態 timAlarmThreshold TIME T#30S コンプレッサーが作動してから信号が鳴るまでの時間 timDoorOpenThreshold TIME T#10S ドアを開けてから信号が鳴る時間 xCompressor BOOL FALSE 制御信号 xSignal BOOL FALSE 制御信号 xLamp BOOL FALSE ステータスメッセージ " }, 
{ "title" : "CFC エディタでの冷却制御のメインプログラムの作成 ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_d0ec117487fb0b44c0a8640e01a8d70a", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ プロジェクトでのコントローラーアプリケーションのプログラミング \/ CFC エディタでの冷却制御のメインプログラムの作成 ", 
"snippet" : "次に、メインでアプリケーションプログラムの主な機能を説明します。 PLC_PRG POU。デフォルトで作成されます。実際の温度が設定温度とヒステリシスを加えた温度よりも高くなると、コンプレッサが作動して冷却されます。実際の温度が設定温度からヒステリシスを引いた値を下回ると、コンプレッサはオフになります この機能を CFC 実装言語で説明するには、以下の手順に従ってください。 デバイスツリーで、ダブルクリック PLC_PRG 。 で CFC エディタが開きます。 PLC_PRG タブ。デクラレーションエディターは、グラフィカルエディター領域の上部にテキスト形式または表形式で表示されます。 ツール...", 
"body" : "次に、メインでアプリケーションプログラムの主な機能を説明します。 PLC_PRG POU。デフォルトで作成されます。実際の温度が設定温度とヒステリシスを加えた温度よりも高くなると、コンプレッサが作動して冷却されます。実際の温度が設定温度からヒステリシスを引いた値を下回ると、コンプレッサはオフになります この機能を CFC 実装言語で説明するには、以下の手順に従ってください。 デバイスツリーで、ダブルクリック PLC_PRG 。 で CFC エディタが開きます。 PLC_PRG タブ。デクラレーションエディターは、グラフィカルエディター領域の上部にテキスト形式または表形式で表示されます。 ツールボックス ビューは右側にあります。 で ツールボックス 表示、選択 入力 要素を選択し、下の CFC エディタにドラッグします。 PLC_PRG タブ。 名もなきエントリー ??? が挿入されました。 CFC エディターで、をクリックします。 ??? 入力画面で、クリックします 入力アシスタントを開きます。 変数 カテゴリを選択し、 rTempActual 以下の変数 アプリケーション → Glob_Var 。これがグローバル変数を参照する方法です rTempActual ここ。 入力された名前は Glob_Var.rTempActual 。 ステップ 3 と同様に、グローバル変数の名前を使用して別の入力を作成します。 Glob_Var.rTempSet 。 別の入力を作成してクリック ??? そしてそれらを名前に置き換えてください rHysteresis 。 これは既知の変数の名前ではないため、 自動宣言 ダイアログが開きます。その名前はダイアログですでに使用されています。 の中に 自動宣言 ダイアログで、以下を指定します。 タイプ として REAL そして 初期化 として 1 。をクリックします。 OK ボタン。 変数 rHysteresis デクラレーションエディターに表示されます。 の中に ツールボックス 表示、選択 [ブロック] エレメントを作成し、下の CFC エディタにドラッグします。 PLC_PRG タブ。 POU が CFC エディタで開きます。 置換 ??? と ADD 。 POU は、接続されているすべての入力を追加します。 接続する Glob_Var.rTempSet への入力 ADD POU。これを行うには、入力の出力ピンをクリックし、上の入力ピンにドラッグします ADD POU。 同様に、入力を接続します rHysteresis の入力値が低い場合 ADD POU。 2 つの入力 rHysteresis と Glob_Var.rTempSet 次の人によって追加されました ADD 。 エディターで要素を移動するには、要素内の空白部分をクリックするか、フレームをクリックして、要素を選択します (赤い枠線、赤いハイライト)。エレメントを目的の位置にドラッグします。 の右に別の POU を作成 ADD POU。その目的は比較することです。 Glob_Var.rTempActual の合計で Glob_Var.rTempSet と rHysteresis 。を割り当てます。 GT POU への関数 (より大きい)。 ザル GT POU は次のように機能します。 IF (upper input > lower input) THEN output := TRUE; 入力を接続する Glob_Var.rTempActual の上位入力に GT POU。 の出力を接続します ADD POU を以下の入力の下位に入力します。 GT POU。 次に、ブロック要素を使用して、の右側に関数ブロックを作成します GT 入力条件に応じてコンプレッサーを起動および停止するPOU (Set — Reset)。名前を指定してください。 SR に ??? フィールド。Enter キーを押して POU の上にある開いている入力フィールドを閉じます SR_0 )。 ザル 自動宣言 ダイアログが開きます。 変数を次の名前で宣言します。 SR_0 そしてデータタイプ SR 。をクリックします。 OK ボタン。 ザル SR からの POU Standard ライブラリはインスタンス化されます。 SR の定義には以下のように使用されます。 THEN GT POU のアウトプットで。 SET1 と RESET 現れる。 の右側の出力ピンを接続します GT への POU SET1 の入力 SR_0 POU。 SR 以下から Boolean 変数を設定できます。 FALSE に TRUE そしてまた戻って。入力時の条件の場合 SET1 が満たされると、Boolean 変数は次のように設定されます。 TRUE 。条件が次の場合、変数は再びリセットされます RESET 満足しています。この例の Boolean (グローバル) 変数は Glob_Var.xCompressor 。 を作成 出力 要素を作成してグローバル変数に代入します。 Glob_Var.xCompressor 。間に接続線をドラッグします Glob_Var.xCompressor そして出力ピン Q1 の SR 。 次に、コンプレッサーが再びオフになる条件を指定します (この場合は RESET SR POU の入力は TRUE シグナル)。そのためには、上記とは逆の条件を定式化します。以下を使用してください SUB (減算) と LT これを行うにはPOUが (未満) 結果は次のCFCチャートです。 " }, 
{ "title" : "ラダーダイアグラムエディターでのシグナル管理用 POU の作成 ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_43984f578f71eb8bc0a8640e0046480b", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ プロジェクトでのコントローラーアプリケーションのプログラミング \/ ラダーダイアグラムエディターでのシグナル管理用 POU の作成 ", 
"snippet" : "別の POU では、アラームブザーとランプのオン\/オフの切り替えの信号管理を実装します。これには、ラダーダイアグラム (LD) 実装言語が適しています 次の各信号をそれぞれのネットワークで処理します。 温度が高すぎるためにコンプレッサーが長時間作動すると、連続した音声信号が鳴ります。 ドアを長く開けすぎると、断続的に信号が鳴ります。 ドアが開いている間は明かりがついている。 デバイスツリーの Application オブジェクト、タイプのPOUオブジェクトを作成します プログラム 使用して ラダー（LD2） 実装言語。 プログラムに次の名前を付けます。 Signals 。 ザック Signal...", 
"body" : "別の POU では、アラームブザーとランプのオン\/オフの切り替えの信号管理を実装します。これには、ラダーダイアグラム (LD) 実装言語が適しています 次の各信号をそれぞれのネットワークで処理します。 温度が高すぎるためにコンプレッサーが長時間作動すると、連続した音声信号が鳴ります。 ドアを長く開けすぎると、断続的に信号が鳴ります。 ドアが開いている間は明かりがついている。 デバイスツリーの Application オブジェクト、タイプのPOUオブジェクトを作成します プログラム 使用して ラダー（LD2） 実装言語。 プログラムに次の名前を付けます。 Signals 。 ザック Signals プログラムはデバイスツリーの横に一覧表示されます。 PLC_PRG 。ラダーダイアグラムエディタがで開きます。 Signals タブ。デクラレーションエディターが上部に表示されます。 ツールボックス 右を見る。ラダー図には空のネットワークが含まれています コンプレッサーが指定された温度に達せずに長時間稼働したときに可聴信号が鳴るように、ネットワークにプログラムを作成します。そのためには、を挿入します TON 次のステップではタイマー POU。Boolean 信号を次のように切り替えます TRUE 指定した時間が経過すると。 で ツールボックス 表示、ドラッグ [ブロック] エレメントを作成し、空のネットワーク内の空いている挿入位置にドロップします。 ブロックは、入力と出力を含むボックスとして表示されます。 3 つの疑問符をダブルクリックします ( ??? ) ブロック内で [] をクリックし、 ラインエディターのシンボル。 ザック 入力アシスタント ダイアログが開きます。 で 入力アシスタント ダイアログ、 標準ファンクションブロック カテゴリ、 スタンダード ライブラリ、選択してください TON タイマー そしてクリック OK 。 これで、ブロックのラインエディターに、関数ブロック名が表示されます TON 、Enter キーを押してください。 ザック TON POU はその入力と出力とともに表示されます。 を削除するには EN 入力と ENO 出力、ブロックを選択してクリック 英語\/いいえ → EN コンテキストメニューで。 これで、ブロックには IN と PT 入力と Q そして ET 出力。 ブロックの上にある3つの疑問符[???]をダブルクリックし、 TON_0 インスタンス名として「」と入力し、Enter キーを押します。 インスタンス名を確認しました。 自動宣言 ダイアログが開きます。 クリック OK ダイアログを確認するため。 挿入された TON POUは名前でインスタンス化されます TON_0 。 コンプレッサーが起動したらすぐに起動するようにブロックをプログラムします。まず、をドラッグします。 Contact のラダーエレメント ツールボックス 正面からの眺め IN ブロックの入力。3 つの疑問符をダブルクリックし、ラインエディターのアイコンをクリックします ( )。入力アシスタントで、すでに宣言されているグローバル変数を選択します コンプレッサー そしてクリック OK 。 変数名 Glob_Var.xCompressor 連絡先の上に表示されます。 入力位置で変数名を入力し始めると、入力した文字で始まる名前を持つすべての変数のリストが自動的に表示され、この時点で使用できます。このアシストは、のデフォルト設定です。 CODESYS スマートコーディングのオプション。 アクティブにする信号を挿入します。これを行うには、 コイル から ツールボックス ビュー、 ラダー カテゴリー、 Q の出力 TON ブロック。名前を指定 Glob_Var.xSignal コイル用。 POU のアクティベーションからの期間を定義します TON_0 信号が鳴るまで。この定義は変数を介して行われます Glob_Var.timAlarmThreshold 、これをこの目的で入力に挿入します。 PT の TON_0 。これを行うには、マウスポインタを入力の入力ピンの左端に移動します PT 。入力ピンの左側に表示されているエッジの細かいボックスをクリックし、変数名を指定します Enter キーを押します。 ザック 自動宣言 ダイアログが開きます。 クリック OK ダイアログを確定するため。 新しく宣言された変数は宣言部分に表示されます。 選択してください TON POUをクリックして 未使用のピンを削除する コンテキスト メニューで。 未使用の出力 ET が削除されました。 LDの2番目のネットワークでは、ドアを長く開けすぎたときに信号が断続的に鳴るようにプログラムします。 マウスを使用してドラッグします [ネットワーク] からの要素 ツールボックス ネットワーク 1 の下の挿入ポイントを見てください。 番号の付いた空のネットワーク 2. 現れる。 最初のネットワークと同様に、 TON 信号を時間制御で起動するためのPOU。今回はグローバル変数によってトリガーされます。 Glob_Var.xDoorOpen 入力時 IN 。入力時 PT 、グローバル変数を追加します。 Glob_Var.timDoorOpenThreshold 。 から Util ライブラリ、追加 BLINK 出力側の POU Q の TON このネットワーク内の POU を次の名前でインスタンス化します。 Blink_0 。 ザル BLINK_0 POU はシグナル転送をクロックします。 Q それゆえ Glob_Var.xSignal 。 まず、2 つドラッグ 連絡 からの要素 ツールボックス を見る OUT POU の出力。変数を割り当てます。 TON_1.Q 出力後すぐに連絡先に送信 Q とグローバル変数 Glob_Var.xDoorOpen 2 番目の連絡先へ。 を挿入 コイル 2 つの接点の後に要素を追加し、グローバル変数を割り当てます。 Glob_Var.xSignal それに。 ローカル変数を宣言する timSignalTime : TIME := T#1S; そして、この変数を入力部に挿入します。 TIMELOW と TIMEHIGH 。のサイクルタイムは 1 秒です。 TRUE そして 1 秒は FALSE 。 選択してください TON POUをクリックして 未使用のピンを削除する コンテキスト メニューで。 未使用の出力 ET 削除されます。 3番目のネットワークでは、ドアが開いている間はランプが点灯するようにプログラムします。追加のネットワークと接点を追加します。変数を割り当てます。 GlobVar.xDoorOpen 連絡先へ。 挿入された接点はコイルに直接つながります。接点の右側にコイルを追加し、グローバル変数を割り当てます Glob_Var.xLamp コイルに。 CODESYS LD のネットワークを 1 つずつ処理します。次に、ネットワーク 1 の最後にネットワーク 3 へのジャンプをインストールして、ネットワーク 1 のみ、またはネットワーク 2 のみが実行されるようにします。 ネットワークの左上端の3番目の線にマウスポインターを合わせると、情報が表示されます。 <ここにジャンプを挿入> が表示されます。この位置をダブルクリックして入力してください ドアは開いています: 行エディタのジャンプ ラベルとして。 ネットワーク1を選択します。 ツールボックス ビュー、 ラダー図 カテゴリをドラッグして ジャンプ 要素を、その前に三角形でマークされた挿入位置に移動します。 Glob_Var.xSignal コイル。 ジャンプ要素が表示されます。ジャンプ先は引き続き次のように指定されています。 ??? 。 3つの疑問符[???]をダブルクリックし、行エディタのアイコンをクリックします（ ）。 入力アシスタント ダイアログで選択 DoorIsOpen ラベル識別子の候補から選択してクリック わかりました 確認します。 ネットワーク 3 へのラベルが実装されます。 LD プログラムは次のようになりました。 " }, 
{ "title" : "メインプログラムの「Signals」プログラムの呼び出し ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_8af1792b87fb0b44c0a8640e0066c163", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ プロジェクトでのコントローラーアプリケーションのプログラミング \/ メインプログラムの「Signals」プログラムの呼び出し ", 
"snippet" : "今回のプログラムサンプルでは、メインプログラムが PLC_PRG を呼び出す必要があります Signals 信号処理プログラム。 デバイスツリーで、ダブルクリック PLC_PRG 。 ザル PLC_PRG プログラムがエディタで開きます。 の中に ツールボックス 表示、ドラッグ [ブロック] エレメントのエディターへ PLC_PRG 。 3 つの疑問符 [???] をダブルクリックしますそして、をクリックします ラインエディターのシンボル。 入力アシスタント ダイアログ、 POU\/プログラムコールとファンクションコール カテゴリを選択し、 Signals プログラムしてクリック OK 確認のた...", 
"body" : "今回のプログラムサンプルでは、メインプログラムが PLC_PRG を呼び出す必要があります Signals 信号処理プログラム。 デバイスツリーで、ダブルクリック PLC_PRG 。 ザル PLC_PRG プログラムがエディタで開きます。 の中に ツールボックス 表示、ドラッグ [ブロック] エレメントのエディターへ PLC_PRG 。 3 つの疑問符 [???] をダブルクリックしますそして、をクリックします ラインエディターのシンボル。 入力アシスタント ダイアログ、 POU\/プログラムコールとファンクションコール カテゴリを選択し、 Signals プログラムしてクリック OK 確認のため。 " }, 
{ "title" : "シミュレーション用の ST POU の作成 ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_9629e45ee440acc7c0a8640e0130c013", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ プロジェクトでのコントローラーアプリケーションのプログラミング \/ シミュレーション用の ST POU の作成 ", 
"snippet" : "このサンプルプロジェクトのアプリケーションは物理的なセンサーやアクチュエーターにはリンクされていないため、温度の上昇と下降をシミュレーションするプログラムも作成する必要があります。これにより、後で冷蔵庫コントローラーの動作をオンラインモードで監視できるようになります シミュレーションプログラムは構造化テキストで作成します。 プログラムはメインプログラムまで温度を上げます PLC_PRG 設定温度を超えていると判断します。その後、プログラムはコンプレッサーを起動します。その後、メインプログラムがコンプレッサーを再び無効にするまで、シミュレーションプログラムは温度を下げます。 デバイスツリーで、右...", 
"body" : "このサンプルプロジェクトのアプリケーションは物理的なセンサーやアクチュエーターにはリンクされていないため、温度の上昇と下降をシミュレーションするプログラムも作成する必要があります。これにより、後で冷蔵庫コントローラーの動作をオンラインモードで監視できるようになります シミュレーションプログラムは構造化テキストで作成します。 プログラムはメインプログラムまで温度を上げます PLC_PRG 設定温度を超えていると判断します。その後、プログラムはコンプレッサーを起動します。その後、メインプログラムがコンプレッサーを再び無効にするまで、シミュレーションプログラムは温度を下げます。 デバイスツリーで、右クリックします [アプリケーション] オブジェクトを作成し、タイプの POU オブジェクトを追加します。 プログラム と 構造化テキスト (ST) 実装言語。POU には、という名前を付けます Simulation 。 ST エディターで次のコードを実装します。 宣言部分: PROGRAM Simulation\nVAR\n TON_1: TON; \/\/The temperature is decreased on a time delay, when the comepressor has been activated\n P_Cooling: TIME:=T#500MS;\n xReduceTemp: BOOL; \/\/Signal for dereasing the temperature\n TON_2: TON; \/\/The temperature is increased on a time delay\n P_Environment: TIME:=T#2S; \/\/Delay time when the door is closed\n P_EnvironmentDoorOpen: TIME:=T#1S; \/\/Delay time when the door is open\n xRaiseTemp: BOOL; \/\/Signal for increasing the temperature\n timTemp: TIME; \/\/Delay time\n iCounter: INT;\nEND_VAR\n\n 実装部分: iCounter := iCounter + 1; \/\/ No function, just for demonstration purposes.\n\n\/\/ After the compressor has been activated due to TempActual being too high, the temperature decreases.\n\/\/ The temperature is decremented by 0.1°C per cycle after a delay of P_Cooling\nIF Glob_VAR.xCompressor THEN\n TON_1(IN:= Glob_Var.xCompressor, PT:= P_Cooling, Q=>xReduceTemp);\n IF xReduceTemp THEN\n Glob_Var.rTempActual := Glob_Var.rTempActual-0.1;\n TON_1(IN:=FALSE);\n END_IF\nEND_IF\n\n\/\/If the door is open, the warming occurs faster; SEL selects P_EnvironmentDoorOpen\ntimTemp:=SEL(Glob_Var.xDoorOpen, P_Environment, P_EnvironmentDoorOpen);\n\n\/\/If the compressor is not in operation, then the cooling chamber becomes warmer.\n\/\/The temperature is incremented by 0.1°C per cycle after a delay of tTemp\nTON_2(IN:= TRUE, PT:= timTemp, Q=>xRaiseTemp);\nIF xRaiseTemp THEN\n Glob_Var.rTempActual := Glob_Var.rTempActual + 0.1;\n TON_2(IN:=FALSE);\nEND_IF コントローラープログラム全体の操作と監視を便利にするために、ビジュアライゼーションを使用することをお勧めします。で作成したビジュアライゼーションです CODESYS ビジュアライゼーションは、このチュートリアル用に完成したサンプルプロジェクトにインストールされます。このサンプルプロジェクトには、 CODESYS 標準インストール ( Projects ディレクトリ)。このプロジェクトをコントローラーにダウンロードして起動すると、ビジュアライゼーションと連携して動作することを確認できます。開始すると、 Live_Visu 、データを入力しなくてもシミュレーションプログラムの動作を再現する冷蔵庫の表現から始めます。ただし、オン\/オフスイッチをクリックするとドアを開閉できます。ロータリーコントロールの針を使ってデフォルトの温度を調整することができます。このチュートリアルでは、ビジュアライゼーションの作成については説明しません。対応するチュートリアルは、のヘルプで予定されています。 CODESYS 視覚化。 " }, 
{ "title" : "タスク設定で実行するプログラムの定義 ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_d442fec087abb4e8c0a8640e01bf3087", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ プロジェクトでのコントローラーアプリケーションのプログラミング \/ タスク設定で実行するプログラムの定義 ", 
"snippet" : "デフォルトのタスク設定には、メインプログラムの呼び出しが含まれています。 PLC_PRG 。このサンプルプロジェクトでは、の呼び出しも追加する必要があります Simulation プログラム。 デバイスツリーで、ドラッグします Simulation へのエントリー MainTask 下に タスク設定 。 ザル Simulation プログラムがタスク構成に挿入されます。 タスク設定を表示するには、をダブルクリックします MainTask エディタを開くためのエントリ。 エディターの下部にある表には、タスクによって呼び出される POU が表示されます。 PLC_PRG (デフォルトで入力) と ...", 
"body" : "デフォルトのタスク設定には、メインプログラムの呼び出しが含まれています。 PLC_PRG 。このサンプルプロジェクトでは、の呼び出しも追加する必要があります Simulation プログラム。 デバイスツリーで、ドラッグします Simulation へのエントリー MainTask 下に タスク設定 。 ザル Simulation プログラムがタスク構成に挿入されます。 タスク設定を表示するには、をダブルクリックします MainTask エディタを開くためのエントリ。 エディターの下部にある表には、タスクによって呼び出される POU が表示されます。 PLC_PRG (デフォルトで入力) と Simulation 。タスクのコールタイプは サイクリック 20 ミリ秒間隔で。オンラインモードでは、タスクが 2 つの POU を 1 サイクルに 1 回実行します " }, 
{ "title" : "PLCとの通信用の「アクティブアプリケーション」の定義 ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_id_ad860c2982c38315c0a8640e0192efdf_id_6e4db14b8d0ab976c0a8640e01f0c733", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ プロジェクトでのコントローラーアプリケーションのプログラミング \/ PLCとの通信用の「アクティブアプリケーション」の定義 ", 
"snippet" : "の名前 Application には太字で表示されています。 デバイス 表示。これは、このアプリケーションが「アクティブなアプリケーション」として設定されていることを意味します。その後、コントローラーとの通信はこのアプリケーションを参照します。 プロジェクトにアプリケーションが 1 つしかない場合は、そのアプリケーションが自動的にアクティブなアプリケーションになります。アプリケーションがまだアクティブになっていない場合は、次のようにアクティブにします のコンテキストメニューで Application 、クリック アクティブアプリケーションを設定 。 [アプリケーション] が太字で表示されるよう...", 
"body" : "の名前 Application には太字で表示されています。 デバイス 表示。これは、このアプリケーションが「アクティブなアプリケーション」として設定されていることを意味します。その後、コントローラーとの通信はこのアプリケーションを参照します。 プロジェクトにアプリケーションが 1 つしかない場合は、そのアプリケーションが自動的にアクティブなアプリケーションになります。アプリケーションがまだアクティブになっていない場合は、次のようにアクティブにします のコンテキストメニューで Application 、クリック アクティブアプリケーションを設定 。 [アプリケーション] が太字で表示されるようになりました デバイス 表示。 " }, 
{ "title" : "アプリケーションプログラムのデバッグ ", 
"url" : "_cds_tutorial_refrigerator_program.html#UUID-733ca63c-63a6-4a48-12b2-7953dfdd991f_section-idm43264932442274", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ プロジェクトでのコントローラーアプリケーションのプログラミング \/ アプリケーションプログラムのデバッグ ", 
"snippet" : "コードを入力する際、 CODESYS 問題のテキストの下に赤い波線の下線が表示され、構文エラーがすぐに通知されます。チェックの結果はメッセージビューにも表示されます。必要な場合は、をクリックします 表示 → メッセージ メッセージビューを開きます。メッセージは、に表示されます。 プリコンパイル メッセージカテゴリ。メッセージを選択して [] を押すことができます。 F4 キーを押すと、コード内の対応するポイントにジャンプします。アプリケーションがコントローラにダウンロードされると、アプリケーションプログラムのテストがさらに実行されます。 その後、エラーのないアプリケーションのみをコントローラー...", 
"body" : "コードを入力する際、 CODESYS 問題のテキストの下に赤い波線の下線が表示され、構文エラーがすぐに通知されます。チェックの結果はメッセージビューにも表示されます。必要な場合は、をクリックします 表示 → メッセージ メッセージビューを開きます。メッセージは、に表示されます。 プリコンパイル メッセージカテゴリ。メッセージを選択して [] を押すことができます。 F4 キーを押すと、コード内の対応するポイントにジャンプします。アプリケーションがコントローラにダウンロードされると、アプリケーションプログラムのテストがさらに実行されます。 その後、エラーのないアプリケーションのみをコントローラーにダウンロードできます。 " }, 
{ "title" : "PLCへの接続を確立する ", 
"url" : "_cds_tutorial_refrigerator_connect.html", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ PLCへの接続を確立する ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "ゲートウェイサーバーとPLCを起動しています ", 
"url" : "_cds_tutorial_refrigerator_connect.html#UUID-959c9499-66d7-f48b-def1-3422e79004c0_id_ad860c2982c38315c0a8640e0192efdf_id_98135acc87abb4e9c0a8640e0103f1cb", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ PLCへの接続を確立する \/ ゲートウェイサーバーとPLCを起動しています ", 
"snippet" : "制御するアクセスオプションを確認してください いかなる状況においても、インターネットや信頼できないネットワークからコントロールにアクセスしてはなりません。特に、コントローラーのプログラミングポートは、いかなる状況でもインターネットから保護されてはなりません（通常、UDPポート1740..1743およびTCPポート1217 + 11740またはコントローラー固有のポート）。ただし、インターネットからのアクセスを有効にする必要がある場合は、コントローラーに接続するために安全な方法を選択する必要があります（VPNなど）。 詳細については、以下も参照してください。 デバイスユーザー管理の処理ゲートウェ...", 
"body" : "制御するアクセスオプションを確認してください いかなる状況においても、インターネットや信頼できないネットワークからコントロールにアクセスしてはなりません。特に、コントローラーのプログラミングポートは、いかなる状況でもインターネットから保護されてはなりません（通常、UDPポート1740..1743およびTCPポート1217 + 11740またはコントローラー固有のポート）。ただし、インターネットからのアクセスを有効にする必要がある場合は、コントローラーに接続するために安全な方法を選択する必要があります（VPNなど）。 詳細については、以下も参照してください。 デバイスユーザー管理の処理ゲートウェイサーバーを起動します。 デフォルトでは、 CODESYS プログラムも GatewaySysTray インストールされています。このプログラムを使用して、ゲートウェイサーバーと通信できます。ゲートウェイサーバーは、システムの起動時にサービスとして自動的に開始されます。 Windowsタスクバーにプログラムアイコンがあるかどうかを確認します が含まれています。ゲートウェイサーバーが実行されていない場合、アイコンは次のようになります。 。この場合、シンボルとコマンドをクリックしてゲートウェイメニューを開くことができます ゲートウェイを開始 選択する。 PLCを起動します。 デフォルトでは、 CODESYS プログラムも CODESYS ControlSysTray インストールされています。このプログラムを通じて、あなたは使用することができます CODESYS 通信制御サービス。不正アクセスから保護するために、 CODESYS V3.5 SP2は、システムの起動時に制御サービスが自動的に開始されなくなりました。次のようにPLCを起動します。マウスをクリックして開きます。 WindowsタスクバーのPLCメニューで、コマンドを選択します StartPLC 。 PLCの実行中、アイコンは次のように変わります。 。起動時に表示されるダイアログは、起動したPLCがプログラミングアクセスを許可していることを通知します。上記の安全上の注意事項を必ず守ってください。 " }, 
{ "title" : "最初の通信構成の場合：ゲートウェイの追加 ", 
"url" : "_cds_tutorial_refrigerator_connect.html#UUID-959c9499-66d7-f48b-def1-3422e79004c0_id_ad860c2982c38315c0a8640e0192efdf_id_0617e29387abb4ebc0a8640e01437431", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ PLCへの接続を確立する \/ 最初の通信構成の場合：ゲートウェイの追加 ", 
"snippet" : "エントリをダブルクリックします Device ( CODESYS Control Win ) ビューで 装置 。 メモ帳で Device タブが表示されます コミュニケーション 。 これが初めての通信構成である場合 CODESYS V3では、ローカルゲートウェイサーバーを定義する必要があります。以前にゲートウェイサーバーを定義したことがある場合は、タブに表示されます コミュニケーション 表示されます。その場合、あなたは今、 通信チャネルの指定 立ち止まるな。 ゲートウェイサーバーは CODESYS -インストールが提供されます。 コマンドを選択します ゲートウェイ→新しいゲートウェイの追加 。...", 
"body" : "エントリをダブルクリックします Device ( CODESYS Control Win ) ビューで 装置 。 メモ帳で Device タブが表示されます コミュニケーション 。 これが初めての通信構成である場合 CODESYS V3では、ローカルゲートウェイサーバーを定義する必要があります。以前にゲートウェイサーバーを定義したことがある場合は、タブに表示されます コミュニケーション 表示されます。その場合、あなたは今、 通信チャネルの指定 立ち止まるな。 ゲートウェイサーバーは CODESYS -インストールが提供されます。 コマンドを選択します ゲートウェイ→新しいゲートウェイの追加 。 対話 ゲートウェイ が表示されます。 入力フィールドに入力します 姓 ゲートウェイの記号名を入力します。 リストから選択 運転者 エントリ TCP \/ IP アウト。 行の右側の列をダブルクリックします IPアドレス 入力フィールドに入力します localhost 1。 ボタンをクリックします わかった 。 ゲートウェイがタブに表示されます コミュニケーション （1）デバイスエディタの。ゲートウェイが正しく実行されている場合、緑色の塗りつぶされた円がゲートウェイグラフに表示されます。 " }, 
{ "title" : "通信チャネルの指定 ", 
"url" : "_cds_tutorial_refrigerator_connect.html#UUID-959c9499-66d7-f48b-def1-3422e79004c0_id_ad860c2982c38315c0a8640e0192efdf_id_50186f59d1ccca7dc0a8640e0152059e", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ PLCへの接続を確立する \/ 通信チャネルの指定 ", 
"snippet" : "次に、デバイスへの通信チャネルを定義します。これは、設定されたゲートウェイを介して使用されます。これを行うには、タブを開きます コミュニケーション エントリをダブルクリックしてデバイスエディタの 端末 デバイスツリー内。 ボタンをクリックします ネットワークを閲覧する ローカルネットワークで利用可能なすべてのデバイスを検索します。 対話 デバイスを選択 （1）は、接続を設定できるすべてのデバイスのリストとともに表示されます。 ツリーでコンピュータの名前のエントリを選択します。 クリック わかった 。 チャンネルがアクティブになり、タブに表示されます コミュニケーション 関連情報は、デバイスのグ...", 
"body" : "次に、デバイスへの通信チャネルを定義します。これは、設定されたゲートウェイを介して使用されます。これを行うには、タブを開きます コミュニケーション エントリをダブルクリックしてデバイスエディタの 端末 デバイスツリー内。 ボタンをクリックします ネットワークを閲覧する ローカルネットワークで利用可能なすべてのデバイスを検索します。 対話 デバイスを選択 （1）は、接続を設定できるすべてのデバイスのリストとともに表示されます。 ツリーでコンピュータの名前のエントリを選択します。 クリック わかった 。 チャンネルがアクティブになり、タブに表示されます コミュニケーション 関連情報は、デバイスのグラフィックの下に表示されます。 目的のデバイスを選択して、をクリックします わかった 。 デバイスにはユーザー管理が必須であるが、まだアクティブ化されていないという情報が記載されたメッセージボックスが表示されます。今すぐユーザー管理を有効にするかどうかを尋ねられます。この場合、新しい管理者ユーザーを作成してから、このユーザーとしてログインする必要があることが通知されます。 でクエリを閉じます はい 。 対話 デバイスユーザーを追加 を開いて、初期デバイス管理者を作成します。 デバイス管理者の資格情報を定義します。 姓 と パスワード 。オプションを有効にする パスワードはユーザーが変更できます 。参加しませんか わかった あちらへ。 対話 デバイスユーザーログイン 開きます。 前の手順で定義したデバイス管理者の資格情報を入力します。 コントローラへの接続パスを設定します。 すべての通信アクションは、このチャネルを正確に参照するようになりました。プロジェクトに複数の通信チャネルがある場合は、後でこのことを覚えておいてください。 " }, 
{ "title" : "PLCでのアプリケーション ", 
"url" : "_cds_tutorial_refrigerator_app.html", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ PLCでのアプリケーション ", 
"snippet" : "実行時に単一サイクルを実行する 要件：アプリケーションがコントローラーにロードされ、実行されている。 上記の手順と同様に、線をもう一度観察します iCounter := iCounter + 1; プログラムで Simulation 。 押す ctrl + F5 またはコマンドを選択します デバッグ→シングルサイクル 単一のサイクルを実行します。 処理は1サイクル実行され、ブレークポイントで再び停止します。 iCounter 1ずつインクリメントされました。 さらに押す ctrl + F5 単一のサイクルを確認します。次にもう一度押します F5 。 プログラムは、停止せず、強制値なしで再度実行...", 
"body" : "実行時に単一サイクルを実行する 要件：アプリケーションがコントローラーにロードされ、実行されている。 上記の手順と同様に、線をもう一度観察します iCounter := iCounter + 1; プログラムで Simulation 。 押す ctrl + F5 またはコマンドを選択します デバッグ→シングルサイクル 単一のサイクルを実行します。 処理は1サイクル実行され、ブレークポイントで再び停止します。 iCounter 1ずつインクリメントされました。 さらに押す ctrl + F5 単一のサイクルを確認します。次にもう一度押します F5 。 プログラムは、停止せず、強制値なしで再度実行されます。変数 temp 再び価値がある 1s 。ステータスバーに再び表示されます 。 " }, 
{ "title" : "PLCへのアプリケーションのロード ", 
"url" : "_cds_tutorial_refrigerator_app.html#UUID-2ce2cf20-ee9b-44c0-e254-1b4cf5ee6953_id_ad860c2982c38315c0a8640e0192efdf_id_ac03476587abb4eec0a8640e0119358c", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ PLCでのアプリケーション \/ PLCへのアプリケーションのロード ", 
"snippet" : "要件：アプリケーションはエラーなしでコンパイルされました。 詳細については、以下を参照してください。 アプリケーションプログラムにエラーがないか確認する コマンドを選択します オンライン→ログイン 。 アプリケーションをコントローラにロードするかどうかを尋ねるダイアログボックスが表示されます。 クリック はい 。 アプリケーションがコントローラーにロードされます。ウィンドウ内のコントローラーとアプリケーションのエントリ 装置 緑色で強調表示されます。オブジェクトの後ろ 応用 スタンド Stop 。コントローラの現在のステータスがタスクバーに表示されます。 。...", 
"body" : "要件：アプリケーションはエラーなしでコンパイルされました。 詳細については、以下を参照してください。 アプリケーションプログラムにエラーがないか確認する コマンドを選択します オンライン→ログイン 。 アプリケーションをコントローラにロードするかどうかを尋ねるダイアログボックスが表示されます。 クリック はい 。 アプリケーションがコントローラーにロードされます。ウィンドウ内のコントローラーとアプリケーションのエントリ 装置 緑色で強調表示されます。オブジェクトの後ろ 応用 スタンド Stop 。コントローラの現在のステータスがタスクバーに表示されます。 。 " }, 
{ "title" : "アプリケーションを起動します ", 
"url" : "_cds_tutorial_refrigerator_app.html#UUID-2ce2cf20-ee9b-44c0-e254-1b4cf5ee6953_id_ad860c2982c38315c0a8640e0192efdf_id_9709c503975dfa4dc0a8640e0120e452", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ PLCでのアプリケーション \/ アプリケーションを起動します ", 
"snippet" : "この時点までチュートリアルを完全に実行した場合は、アプリケーションを起動できます。 応用 PLCで 端末 （ CODESYS Control Win ） 使用する。 ウィンドウを右クリック 装置 オブジェクト上 応用 コンテキストメニューでコマンドを選択します 始める アウト。 プログラムは実行中です。ウィンドウ内のコントローラーとアプリケーションのエントリ 装置 緑色で強調表示されます。オブジェクトの後ろ 応用 スタンド run 。コントローラの現在のステータスがタスクバーに表示されます。 。...", 
"body" : "この時点までチュートリアルを完全に実行した場合は、アプリケーションを起動できます。 応用 PLCで 端末 （ CODESYS Control Win ） 使用する。 ウィンドウを右クリック 装置 オブジェクト上 応用 コンテキストメニューでコマンドを選択します 始める アウト。 プログラムは実行中です。ウィンドウ内のコントローラーとアプリケーションのエントリ 装置 緑色で強調表示されます。オブジェクトの後ろ 応用 スタンド run 。コントローラの現在のステータスがタスクバーに表示されます。 。 " }, 
{ "title" : "実行時の変数値の監視と1回限りの書き込み ", 
"url" : "_cds_tutorial_refrigerator_app.html#UUID-2ce2cf20-ee9b-44c0-e254-1b4cf5ee6953_id_ad860c2982c38315c0a8640e0192efdf_id_2af116343d0211e59bd5bc6c9609cd9d", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ PLCでのアプリケーション \/ 実行時の変数値の監視と1回限りの書き込み ", 
"snippet" : "以下では、さまざまなプログラムブロックの変数値の「監視」を見て、一時停止します CODESYS コントローラの特定の変数値を1回出力します。 アプリケーション変数の実際の値は、ブロックエディターのオンラインビューまたは監視リストで確認できます。ここでの例では、ブロックエディタでの監視に限定しています。 要件：アプリケーションはコントローラーで実行されています。 ダブルクリックしてオブジェクトを開きます PLC_PRG 、 Signals 、 Simulation と Glob_Var デバイスツリー内のエディターのオンラインビュー。 各ビューの宣言部分は、列の式のテーブルに表示されます 価値 ...", 
"body" : "以下では、さまざまなプログラムブロックの変数値の「監視」を見て、一時停止します CODESYS コントローラの特定の変数値を1回出力します。 アプリケーション変数の実際の値は、ブロックエディターのオンラインビューまたは監視リストで確認できます。ここでの例では、ブロックエディタでの監視に限定しています。 要件：アプリケーションはコントローラーで実行されています。 ダブルクリックしてオブジェクトを開きます PLC_PRG 、 Signals 、 Simulation と Glob_Var デバイスツリー内のエディターのオンラインビュー。 各ビューの宣言部分は、列の式のテーブルに表示されます 価値 （3）コントローラー上の変数（1）の実際の値（図を参照）。 実装部分での監視は、実装言語によって異なります。非ブール変数の場合、値は常に識別子の右側の長方形のフィールドにあります。 STエディターでは、これはブール変数にも適用されます。この表示を「インラインモニタリング」と呼びます。グラフィカルエディタでは、ブール変数の値は、出力接続線の色で示されます。 FALSE 、青 TRUE ： さまざまなビルディングブロックの変数値を変更することを検討してください。たとえば、GVLを参照してください Glob_Var 、シミュレーションプログラムの処理がの値をどのように変更するか rTempActual と xCompressor 変更します。 コントローラでのタグ値の1回限りの設定： GVLのオンラインビューに焦点を当てる Glob_Var 。 新しい目標値を指定するには、プリントアウトをダブルクリックします rTempSet 列に 準備された価値 （2）。 入力フィールドが開きます。 価値を身につける 9 入力フィールドを離れます。 ドアが開いていることを示すには、[式]をクリックします xDoorOpen フィールドで1倍 準備された価値 。値 TRUE 入力されます。さらに3回クリックして、準備された値があることを確認します FALSE 、次に空白に戻り、次にに戻る TRUE 切り替えることができます。 用意した値に TRUE 変数に1回書き込むには、を押します ctrl + F7 。 2つの値はそれぞれ列にあります 価値 （3）転送されました。変数 xDoorOpen これで値が変更されなくなり、目標温度は9度になります。変数 timTemp 値に変更 1s 、冷蔵庫のドアが「開いて」おり、加熱が完了しているため Simulation 以前よりも速く（ 2s ）が行われる必要があります。 " }, 
{ "title" : "ブレークポイントの設定と実行時のステップスルー ", 
"url" : "_cds_tutorial_refrigerator_app.html#UUID-2ce2cf20-ee9b-44c0-e254-1b4cf5ee6953_id_ad860c2982c38315c0a8640e0192efdf_id_79bd3dd53f6511e58d96f7ece25b7bb8", 
"breadcrumbs" : "CODESYS Essentials \/ 最初のCODESYSプログラム \/ PLCでのアプリケーション \/ ブレークポイントの設定と実行時のステップスルー ", 
"snippet" : "「デバッグ」：トラブルシューティングのために、特定のコードポイントで変数値を確認する必要があります。これを行うには、処理用のブレークポイントを定義し、命令の段階的な実行を開始できます。 要件：アプリケーションがコントローラーにロードされ、実行されている。 ダブルクリックして開く Simulation エディター内のプログラム。 コード行にカーソルを置きます iCounter := iCoutner + 1; を押して F9 記号はコード行の前に表示されます 。その行にブレークポイントが設定されていることを示します。アイコンがすぐに変わります 。黄色の矢印は常に、処理される次の命令を指しています...", 
"body" : "「デバッグ」：トラブルシューティングのために、特定のコードポイントで変数値を確認する必要があります。これを行うには、処理用のブレークポイントを定義し、命令の段階的な実行を開始できます。 要件：アプリケーションがコントローラーにロードされ、実行されている。 ダブルクリックして開く Simulation エディター内のプログラム。 コード行にカーソルを置きます iCounter := iCoutner + 1; を押して F9 記号はコード行の前に表示されます 。その行にブレークポイントが設定されていることを示します。アイコンがすぐに変わります 。黄色の矢印は常に、処理される次の命令を指しています。タスクバーに表示されます それ以外の 。 変数の値を見てください iCounter インラインモニタリングまたはプログラムの宣言部分で Simulation 。 変数値は変更されなくなりました。ブレークポイントで処理が停止しました。 押す F5 、処理を再開します。 プログラムは、1サイクル後にブレークポイントで再び停止します。 iCounter 1ずつインクリメントされました。 押す F8 次の処理ステップを実行します。 戻る 行の終わりに iCounter := iCounter + 1; 指示は黄色で強調表示されます。 もう一度押す F8 次の処理ステップを実行します。 処理はのエディタにジャンプします PLC_PRG 。繰り返し押す F8 プログラムを段階的に実行する方法を示します。実行されるステートメントは、黄色の矢印で再びマークされます。 ブレークポイントを無効にして通常の処理に戻るには、コード行にカーソルを置き、を押します。 F9 。次にを押します F5 アプリケーションをモードに戻すには に持ってきてください。 " }, 
{ "title" : "プロジェクトの作成と構成 ", 
"url" : "_cds_struct_project_creation.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "プロジェクトとは何ですか？ ", 
"url" : "_cds_struct_project_creation.html#UUID-642975ca-6900-fd18-91a2-987103ac341d_section-idm4534107013289632649624131016", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ プロジェクトとは何ですか？ ", 
"snippet" : "プロジェクトとは何ですか？ プロジェクトには、コントローラプログラム（「アプリケーション」）を作成するために必要なオブジェクトが含まれています。 純粋なPOU 例：プログラム、関数ブロック、関数、およびGVL PLCでアプリケーションを実行できるようにするためにも必要なオブジェクト 例：タスク構成、ライブラリマネージャー、シンボル構成、デバイス構成、視覚化、および外部ファイル プロジェクトでは、複数のアプリケーションをプログラムし、複数のコントローラーデバイスを接続できます。 CODESYS デバイス固有およびアプリケーション固有のPOUを管理します デバイス 見る （\" デバイスツリー \"）...", 
"body" : "プロジェクトとは何ですか？ プロジェクトには、コントローラプログラム（「アプリケーション」）を作成するために必要なオブジェクトが含まれています。 純粋なPOU 例：プログラム、関数ブロック、関数、およびGVL PLCでアプリケーションを実行できるようにするためにも必要なオブジェクト 例：タスク構成、ライブラリマネージャー、シンボル構成、デバイス構成、視覚化、および外部ファイル プロジェクトでは、複数のアプリケーションをプログラムし、複数のコントローラーデバイスを接続できます。 CODESYS デバイス固有およびアプリケーション固有のPOUを管理します デバイス 見る （\" デバイスツリー \"）、およびプロジェクト全体のPOU POU 見る。 プロジェクトを作成するために、特定のオブジェクトがすでに含まれているテンプレートがあります。 プロジェクトの基本的な構成と情報は、 プロジェクト設定 と プロジェクト情報 。例えば： コンパイラ設定 ユーザー管理 著者 プロジェクトファイルに関するデータ The プロジェクト環境 プロジェクトのバージョン互換性のための構成ダイアログを提供します。 プロジェクトをファイルシステムにファイルとして保存します。オプションで、プロジェクト関連のファイルや情報と組み合わせてプロジェクトアーカイブを作成できます。 SVNなどのソース管理システムにファイルを保存することも可能です。 各プロジェクトには、 CODESYS それが作成されたバージョン。別のバージョンで開くと、 CODESYS ファイル形式、ライブラリバージョンなどに関する更新の可能性または必要性について通知します。 プロジェクトを比較、インポート\/エクスポートし、それらのドキュメントを作成できます。 プロジェクトが変更されないように保護したり、プロジェクトが読み取られないように完全に保護したりすることもできます。ユーザー管理を使用すると、プロジェクトへのアクセス、さらにはプロジェクト内の個々のオブジェクトへのアクセスを選択的に制御できます。詳細については、以下を参照してください。 プロジェクトの保護と保存" }, 
{ "title" : "標準プロジェクトの作成 ", 
"url" : "_cds_creating_standard_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ 標準プロジェクトの作成 ", 
"snippet" : "クリック ファイル→新規プロジェクト 、そして プロジェクト→標準プロジェクト レンプレート。名前を指定します（例： myProject ）およびファイルシステム内の場所。 The 標準プロジェクト ダイアログが開きます。 のいずれかを選択します CODESYS Control Win からの標準デバイス 端末 リストし、選択します 構造化テキスト（ST） から PLC_PRGの リスト。次に、をクリックします わかった 。 プロジェクト名 myProject 開発システムのメインウィンドウのタイトルバーに表示されます。次の構造がデバイスツリーに作成されます（ デバイス 見る）。 選択したPL...", 
"body" : "クリック ファイル→新規プロジェクト 、そして プロジェクト→標準プロジェクト レンプレート。名前を指定します（例： myProject ）およびファイルシステム内の場所。 The 標準プロジェクト ダイアログが開きます。 のいずれかを選択します CODESYS Control Win からの標準デバイス 端末 リストし、選択します 構造化テキスト（ST） から PLC_PRGの リスト。次に、をクリックします わかった 。 プロジェクト名 myProject 開発システムのメインウィンドウのタイトルバーに表示されます。次の構造がデバイスツリーに作成されます（ デバイス 見る）。 選択したPLCによっては、追加のデバイスノードも表示される場合があります。 PLCは常に自動的に表示されます PLCロジック サブノード。その下の基本オブジェクトは次のとおりです。 ライブラリマネージャー と タスク構成 。タスク構成は、 MainTask 標準のPOUを処理するため PLC_PRG 。 ライブラリマネージャーにはすでに Standard.library 後でプログラミング時に使用できるベースPOU（たとえば、カウンター、タイマー、文字列関数）を使用します。 今あなたが満たすとき PLC_PRG エラーのないコードを使用すると、それをコントローラーにダウンロードして、プログラミングオブジェクトを追加することなく実行できます。 SP13以降では、 整合性チェック のプロジェクト設定 プロジェクト→プロジェクト設定→セキュリティ 新しい標準プロジェクトに対して自動的にアクティブ化されます。プロジェクトを保護する方法の詳細については、「プロジェクトの保護と保存」の章を参照してください。 詳細については、以下を参照してください。 あなたの最初のCODESYSプログラム " }, 
{ "title" : "オブジェクトの追加 ", 
"url" : "_cds_adding_objects.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ オブジェクトの追加 ", 
"snippet" : "要件：プロジェクトが開いています。少なくともトップ <プロジェクト名> ノードはに存在します デバイス ビュー（「デバイスツリー」）および POU 見る。 次の手順は、プロジェクトでオブジェクトを作成する方法に関するいくつかのオプションを示しています。 デバイスツリーまたはPOUツリーで、エントリを選択します。たとえば、 応用 物体。 クリック プロジェクト→オブジェクトの追加 。 選択したエントリに応じて、 CODESYS 選択できる適切なオブジェクトを提供します。 たとえば、 POU オブジェクトと POUを追加する 開いたら、を選択します プログラム と入力する 構造化テキスト（ST） ...", 
"body" : "要件：プロジェクトが開いています。少なくともトップ <プロジェクト名> ノードはに存在します デバイス ビュー（「デバイスツリー」）および POU 見る。 次の手順は、プロジェクトでオブジェクトを作成する方法に関するいくつかのオプションを示しています。 デバイスツリーまたはPOUツリーで、エントリを選択します。たとえば、 応用 物体。 クリック プロジェクト→オブジェクトの追加 。 選択したエントリに応じて、 CODESYS 選択できる適切なオブジェクトを提供します。 たとえば、 POU オブジェクトと POUを追加する 開いたら、を選択します プログラム と入力する 構造化テキスト（ST） 実装言語として、 prog 「名前として。 クリックした後 追加 、 CODESYS を挿入します prog 以下のプログラムオブジェクト 応用 デバイスツリー内。 ツリーで、オブジェクトを選択してクリックします プロパティ コンテキストメニューで。 The プロパティ ダイアログが開き、オブジェクト関連のカテゴリが表示されます。ユーザー管理を使用する場合は、たとえば、ここでオブジェクトへのアクセスを制限できます。 ツリーで、特定のオブジェクトを保持するフォルダーを作成するエントリを選択します。 注：デバイスノードとデバイスオブジェクトのレイアウトを構造化するために独自のフォルダーを作成することはできません。 コンテキストメニューで、をクリックします フォルダーを追加 開いたダイアログで新しいフォルダの名前を定義します。クリック わかった 。 フォルダがツリーに表示されます。 ツリーで、オブジェクトを選択し、ツリー内の別の場所（フォルダーなど）にドラッグします。 デバイスツリーでオブジェクトを選択しないでください。ただし、 CODESYS ユーザーインターフェース。クリック プロジェクト→オブジェクトの追加 次に、たとえば、 テキストリスト 物体。 The テキストリスト オブジェクトがに挿入されます POU 見る。 " }, 
{ "title" : "コンパイラバージョンの変更 ", 
"url" : "_cds_changing_compiler_version.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ コンパイラバージョンの変更 ", 
"snippet" : "現在のプロジェクトでターゲットデバイスで使用するコードを生成するために使用されるコンパイラバージョンは、プロジェクト設定で定義されます。 コンパイラのバージョンは、 CODESYS バージョン。したがって、一定のアプリケーションコードは、異なるコンパイラバージョンから実行された場合でも、同じセットコンパイラバージョンのソースコードから生成されます。 CODESYS バージョン。 に注意してください 更新しないでください の設定 コンパイラバージョン のタブ プロジェクト環境 ダイアログ：これが選択されていて、古いプロジェクトを開いた場合 最新 コンパイラバージョンは引き続き使用され、その後 C...", 
"body" : "現在のプロジェクトでターゲットデバイスで使用するコードを生成するために使用されるコンパイラバージョンは、プロジェクト設定で定義されます。 コンパイラのバージョンは、 CODESYS バージョン。したがって、一定のアプリケーションコードは、異なるコンパイラバージョンから実行された場合でも、同じセットコンパイラバージョンのソースコードから生成されます。 CODESYS バージョン。 に注意してください 更新しないでください の設定 コンパイラバージョン のタブ プロジェクト環境 ダイアログ：これが選択されていて、古いプロジェクトを開いた場合 最新 コンパイラバージョンは引き続き使用され、その後 CODESYS プロジェクトで最後に使用されたコンパイラバージョンを引き続き使用します。これは、別の「現在の」バージョンが新しい環境で定義されている場合にも当てはまります。 最新のコンパイラバージョンが設定されていないプロジェクトを開くと、 プロジェクト環境 ダイアログが開き、対応する通知と直接更新するオプションが表示されます。 要件：プロジェクトが開いています。 クリック プロジェクト→プロジェクト設定 そして コンパイルオプション タブ。 希望するものを選択してください 修正バージョン をクリックします わかった 。 変更はすぐに有効になります。 詳細については、以下を参照してください。 アプリケーションコードの生成" }, 
{ "title" : "開く V3 計画 ", 
"url" : "_cds_opening_project_v3.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ 開く V3 計画 ", 
"snippet" : "の CODESYS 、さまざまなインストールで作成されたプロジェクト、ライブラリプロジェクト、またはプロジェクトアーカイブを開くことができます。プロジェクトを開くと、アクティブなインストールがプロジェクトのロードに適しているかどうかが自動的にチェックされます。現時点では、アドオンの欠落や非推奨のインストールなどの欠陥を検出できます。これらの欠陥を修正することができます。次に、適切なインストールでプロジェクトをロードできます。 欠陥を修正するには、次のアクションが可能です。 既存のアドオンを更新し、不足しているアドオンをインストールします プロジェクトに適した別のインストールを開始します 追加の...", 
"body" : "の CODESYS 、さまざまなインストールで作成されたプロジェクト、ライブラリプロジェクト、またはプロジェクトアーカイブを開くことができます。プロジェクトを開くと、アクティブなインストールがプロジェクトのロードに適しているかどうかが自動的にチェックされます。現時点では、アドオンの欠落や非推奨のインストールなどの欠陥を検出できます。これらの欠陥を修正することができます。次に、適切なインストールでプロジェクトをロードできます。 欠陥を修正するには、次のアクションが可能です。 既存のアドオンを更新し、不足しているアドオンをインストールします プロジェクトに適した別のインストールを開始します 追加のインストール CODESYS 適切な状態のバージョン " }, 
{ "title" : "適切なインストールでプロジェクトをロードする ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_a6d2d494801711eba011b160aaf68d97", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ 開く V3 計画 \/ 適切なインストールでプロジェクトをロードする ", 
"snippet" : "要件：開発システムでは、 CODESYS 同じまたは同様のインストールで保存されたプロジェクトが存在します。 クリック ファイル→プロジェクトを開く 。 The プロジェクトを開く ダイアログが開き、開発システムのファイルシステムからファイルを選択します。 ファイルフィルターを設定し、目的のプロジェクト、プロジェクトアーカイブ、またはライブラリプロジェクトを選択します。 プロジェクトを開く ダイアログ。 クリック わかった ダイアログを確認します。 プロジェクトがロードされ、 デバイスツリー 見る。...", 
"body" : "要件：開発システムでは、 CODESYS 同じまたは同様のインストールで保存されたプロジェクトが存在します。 クリック ファイル→プロジェクトを開く 。 The プロジェクトを開く ダイアログが開き、開発システムのファイルシステムからファイルを選択します。 ファイルフィルターを設定し、目的のプロジェクト、プロジェクトアーカイブ、またはライブラリプロジェクトを選択します。 プロジェクトを開く ダイアログ。 クリック わかった ダイアログを確認します。 プロジェクトがロードされ、 デバイスツリー 見る。 " }, 
{ "title" : "適切なインストールでプロジェクトをロードする ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_8aa0891b801411eba011b160aaf68d97", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ 開く V3 計画 \/ 適切なインストールでプロジェクトをロードする ", 
"snippet" : "この場合、 プロジェクト検査 ウィザードが可能なアクションを案内します。 あなたの現在では CODESYS インストール、別のインストール (別のバージョンおよび\/または複数のアドオン) で最後に保存されたプロジェクトを開きます。 CODESYS ロード操作を中断し、Project Inspection ウィザードに情報と適切なオプションを提供します ( プロジェクト検査 - 概要 ダイアログ) ロードできるようにします。 プロジェクトがで保存された場合 CODESYS バージョン 3.5.19.0 以降の場合、 詳細 開くためのボタンが表示されます。 違い ダイアログ。ここでは、プロジェクト...", 
"body" : "この場合、 プロジェクト検査 ウィザードが可能なアクションを案内します。 あなたの現在では CODESYS インストール、別のインストール (別のバージョンおよび\/または複数のアドオン) で最後に保存されたプロジェクトを開きます。 CODESYS ロード操作を中断し、Project Inspection ウィザードに情報と適切なオプションを提供します ( プロジェクト検査 - 概要 ダイアログ) ロードできるようにします。 プロジェクトがで保存された場合 CODESYS バージョン 3.5.19.0 以降の場合、 詳細 開くためのボタンが表示されます。 違い ダイアログ。ここでは、プロジェクトを保存したときにインストールされたアドオンと、現在のインストールで利用できるかどうか、およびどのように利用できるかを確認できます。 次の 2 つの基本オプションのいずれかを選択します。 オプション1： このプロジェクトはまだ開発段階にあります。このバージョンで開きたいのですが、別のコードが生成される可能性があります。 不適切なバージョンでプロジェクトをロードし、欠落しているコンポーネントによるコードの変更または損失の可能性を受け入れます。これは、まだ開発段階にあるプロジェクトでは受け入れられるオプションです。 オプション 2: このプロジェクトは、すでにマシン\/プラントに展開されています。まったく同じコードを生成したいので、変更せずにログインできるようにする必要があります。 このオプションは、プロジェクトのコードをいかなる状況でも変更してはならない場合に必要です。ウィザードは、インストールが適切であることを確認する必要があります。 したがって、ウィザードは最初にコンピュータをスキャンして、適切な他の既存のインストールを探します。適切なインストールが見つかった場合は、そのうちの 1 つを選択して、現在開いているインストールの代わりに開始できます。 ウィザードで適切なインストールが見つからない場合は、適切なセットアップをダウンロードして実行するよう提案されます。必須およびオプションのアドオンが一覧表示されます。それに応じてダウンロードを構成してから、 CODESYS Installer . オプション 1 を選択した場合: 後 次 、プロジェクトのすべてのオブジェクトを編集するために、不足しているアドオンを後でインストールするオプションがまだあります。この場合、ウィザードは、必要なアドオン セットアップが利用可能かどうかを確認し、 CODESYS Installer 次のステップで。 このポストインストールなしでプロジェクトを開くと、見つからないアドオンの影響を受けるオブジェクトを編集できません。不足しているアドオンの数は、プロジェクトのステータス バーに表示されます。 オプション 2 を選択した場合: 後 次 、 プロジェクトの検査 – 選択 ダイアログが開きます。下 別のインストールを使用する 、ウィザードは、プロジェクトの継続的な使用に適した、コンピューター上で利用可能な他のインストールを表示します。適切なインストールが見つからない場合は、代替手段があります 新しいインストールのダウンロードとセットアップ . どちらのオプションでも、 CODESYS Installer 次のステップで必要なインストールを実行します。 詳細については、次を参照してください。 プロジェクトを開く" }, 
{ "title" : "書き込み保護されたプロジェクトのロード ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_d7efcbbf801411eba011b160aaf68d97", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ 開く V3 計画 \/ 書き込み保護されたプロジェクトのロード ", 
"snippet" : "さらに、書き込み保護されたプロジェクトをロードして読み取ることができます。ファイルを保存するときにのみ、必要な書き込み権限がある適切な場所を指定する必要があります。...", 
"body" : "さらに、書き込み保護されたプロジェクトをロードして読み取ることができます。ファイルを保存するときにのみ、必要な書き込み権限がある適切な場所を指定する必要があります。 " }, 
{ "title" : "アクセス制限のあるプロジェクトのロード ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_43f091b9801511eba011b160aaf68d97", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ 開く V3 計画 \/ アクセス制限のあるプロジェクトのロード ", 
"snippet" : "制限されたプロジェクトをロードできるのは、ユーザー名やパスワードなどのアクセス資格がある場合のみです。...", 
"body" : "制限されたプロジェクトをロードできるのは、ユーザー名やパスワードなどのアクセス資格がある場合のみです。 " }, 
{ "title" : "セキュリティキーを使用してプロジェクトをロードする ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_364abf3a125f0850c0a864632cca4d5c", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ 開く V3 計画 \/ セキュリティキーを使用してプロジェクトをロードする ", 
"snippet" : "セキュリティキーで保護されているプロジェクトを選択しました。セキュリティキーがコンピュータに接続されていない場合は、接続するように求められます。それ以外の場合は、接続するように求められます。 CODESYS 保護に関する情報なしでプロジェクトを開きます。...", 
"body" : "セキュリティキーで保護されているプロジェクトを選択しました。セキュリティキーがコンピュータに接続されていない場合は、接続するように求められます。それ以外の場合は、接続するように求められます。 CODESYS 保護に関する情報なしでプロジェクトを開きます。 " }, 
{ "title" : "プロジェクトのバックアップをロードする ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_8a9d06a8801411eba011b160aaf68d97", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ 開く V3 計画 \/ プロジェクトのバックアップをロードする ", 
"snippet" : "バックアップは、 自動的に保存 プロジェクトオプションが選択されています。いつ CODESYS 変更後に正しく終了しない場合、プロジェクトはバックアップとして保存されます。 プロジェクトを選択すると、 自動保存バックアップ ロード時に最初にダイアログが開きます。そこでバックアップを処理できます。...", 
"body" : "バックアップは、 自動的に保存 プロジェクトオプションが選択されています。いつ CODESYS 変更後に正しく終了しない場合、プロジェクトはバックアップとして保存されます。 プロジェクトを選択すると、 自動保存バックアップ ロード時に最初にダイアログが開きます。そこでバックアップを処理できます。 " }, 
{ "title" : "プロジェクト環境の更新 ", 
"url" : "_cds_opening_project_v3.html#UUID-2cbe41d8-fd0b-ccdf-4f8f-e3595d6f25df_id_f4e6ecedff00afe0c0a8640e0045d984_id_8a9a6e94801411eba011b160aaf68d97", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ 開く V3 計画 \/ プロジェクト環境の更新 ", 
"snippet" : "The プロジェクト環境 新しいコンパイラバージョン、視覚化プロファイル、またはSoftMotionバージョンが利用可能になると、ダイアログが開きます。ダイアログは現在の状態について通知し、更新のオプションを提供します。 たとえば、非常に古いバージョンの V3 、プロジェクトを継続して使用するために特定のオブジェクトを置き換える方法に関する情報が表示されます。プロジェクトをそのままにするか、最新の状態で開発を継続するかによって、更新を実行するか、実行しないかによって異なります。 プロジェクト環境の更新は、ログインのみを実行できるという効果があります と ダウンロードまたは と オンライン変更。...", 
"body" : "The プロジェクト環境 新しいコンパイラバージョン、視覚化プロファイル、またはSoftMotionバージョンが利用可能になると、ダイアログが開きます。ダイアログは現在の状態について通知し、更新のオプションを提供します。 たとえば、非常に古いバージョンの V3 、プロジェクトを継続して使用するために特定のオブジェクトを置き換える方法に関する情報が表示されます。プロジェクトをそのままにするか、最新の状態で開発を継続するかによって、更新を実行するか、実行しないかによって異なります。 プロジェクト環境の更新は、ログインのみを実行できるという効果があります と ダウンロードまたは と オンライン変更。 詳細については、以下を参照してください。 ロードして保存 と プロジェクトを開く" }, 
{ "title" : "V2.3プロジェクトを開く ", 
"url" : "_cds_opening_project_v23.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ V2.3プロジェクトを開く ", 
"snippet" : "あ CoDeSys V2.3 プロジェクトは 32 ビット バージョンの場合のみ変換できます。 CODESYS V3 。これを行うには、 CODESYS V2.3 Converter パッケージはにインストールする必要があります CODESYS V3 。パッケージは次の場所で入手できます。 CODESYS Store International 。 64 ビット バージョンを使用している場合は、 CODESYS V3 の場合、変換のために 32 ビット バージョンもインストールする必要があります。変換後、プロジェクトを次の場所で開くことができます。 CODESYS 64ビット。 要件: インス...", 
"body" : "あ CoDeSys V2.3 プロジェクトは 32 ビット バージョンの場合のみ変換できます。 CODESYS V3 。これを行うには、 CODESYS V2.3 Converter パッケージはにインストールする必要があります CODESYS V3 。パッケージは次の場所で入手できます。 CODESYS Store International 。 64 ビット バージョンを使用している場合は、 CODESYS V3 の場合、変換のために 32 ビット バージョンもインストールする必要があります。変換後、プロジェクトを次の場所で開くことができます。 CODESYS 64ビット。 要件: インストールして起動していること CODESYS V3 。の CODESYS V2.3 Converter アドオンがインストールされています。 クリック ファイル→プロジェクトを開く 。 の中に プロジェクトを開く ダイアログ、任意をクリックします CoDeSys V2.3 ファイルシステム内のプロジェクトまたはプロジェクトアーカイブ。検索の場合は、ダイアログの右下隅にあるファイルフィルターを設定できます。 別のプロジェクトがまだ開いている場合は、 CODESYS それに応じて閉じるように指示します。その後、 CoDeSys V2.3 コンバーターが自動的に起動します。 V2.3コンバーターは、プロジェクトがエラーなしでコンパイルできることを確認します。その場合、プロジェクトは自動的に処理されます。 ノート： プロジェクトに、コンバーターが解決できないプレースホルダー変数を持つ視覚化オブジェクトが含まれている場合、それぞれの視覚化は、視覚化参照の代わりにグループとして表示されます。 デバイス変換：開くプロジェクトでデバイス（ターゲットシステム）が参照され、デバイスに変換ルールが定義されていない場合、 デバイス変換 ダイアログが開きます。ここで、コンバーターが以前のデバイス参照を現在のデバイス参照に置き換えるかどうか、およびどのように置き換えるかを指定します。 交換のために、コンバーターは、変換されたプロジェクトのデバイスツリーの古いデバイスの代わりに新しいデバイスを追加しました。 ライブラリ変換：これまで変換ルールが定義されていないライブラリが、開かれるプロジェクトで参照されている場合、 ライブラリ参照の変換 ダイアログが開きます。ここで、コンバーターが既存のライブラリ参照を現在のライブラリ参照に置き換えるかどうか、およびどのように置き換えるかを指定します。 プロジェクト情報が欠落しているライブラリを選択した場合、 プロジェクト情報を入力する この情報を指定するためのダイアログが開きます。 コンバーターは、適合されたプロジェクトをロードします。注：最近定義されたライブラリ参照は、POUビューにあるグローバルライブラリマネージャーにあります。 " }, 
{ "title" : "再利用時の制限 CoDeSys V2.3 のプロジェクト CODESYS ", 
"url" : "_cds_opening_project_v23.html#UUID-4e701e8c-8cef-c597-c237-6d5f8cdd2ba8_id_cd2852f2ff014e88c0a8640e006c37ac_id_1347abe6017bb94ac0a8640e0130ddc2", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ V2.3プロジェクトを開く \/ 再利用時の制限 CoDeSys V2.3 のプロジェクト CODESYS ", 
"snippet" : "コンパイル プロジェクトは、エラーなしでコンパイル可能である必要があります CoDeSys V2.3 。ノート： CODESYS 静止画はで警告を発行します V3 コンパイルするとき。これらは暗黙の変換によって引き起こされ、情報の損失につながる可能性があります（たとえば、符号の変更による）。 CODESYS V3は、switch変数に対して「case」ステートメントをチェックします。 CASE USINT OF INT チェックインされていません CoDeSys V2.3 、ただし、にインポートするとエラーメッセージが表示されます V3 。 コントローラー構成 The コントローラの構成 の ...", 
"body" : "コンパイル プロジェクトは、エラーなしでコンパイル可能である必要があります CoDeSys V2.3 。ノート： CODESYS 静止画はで警告を発行します V3 コンパイルするとき。これらは暗黙の変換によって引き起こされ、情報の損失につながる可能性があります（たとえば、符号の変更による）。 CODESYS V3は、switch変数に対して「case」ステートメントをチェックします。 CASE USINT OF INT チェックインされていません CoDeSys V2.3 、ただし、にインポートするとエラーメッセージが表示されます V3 。 コントローラー構成 The コントローラの構成 の CoDeSys V2.3 プロジェクトをにインポートできません V3 。デバイス構成を再作成し、コントローラー構成で使用される変数を再宣言する必要があります。 ネットワーク変数 ネットワーク変数の場合、 CODESYS 作成します V3 GVLは、変数宣言をオブジェクト化してインポートします。ただし、ネットワークプロパティはインポートされません。これについては、ネットワーク変数交換の説明を参照してください。 ライブラリ ライブラリで使用されるすべての変数と定数も、ライブラリで宣言する必要があります。ライブラリをでコンパイルできる必要があります CoDeSys V2.3 エラーなし。 以来の構文的および意味的制限 CoDeSys V2.3 FUNCTIONBLOCK の代わりに有効なキーワードではありません FUNCTION_BLOCK 。 TYPE （構造体の宣言）の後には「：」を付ける必要があります。 ARRAY 初期化**には括弧が必要です。 INI はサポートされなくなりました（コード内でこれをInitメソッドに置き換える必要があります）。 関数呼び出しでは、明示的なパラメーター割り当てと暗黙的なパラメーター割り当てを混在させることはできなくなりました。したがって、パラメータ入力の割り当ての順序を変更できます。 fun(formal1 := actual1, actual2); \/\/ -> error message fun(formal2 := actual2, formal1 := actual1); \/\/ same semantics as the following line: fun(formal1 := actual1, formal2 := actual2); CoDeSys V2.3 プラグマは変換されません。彼らはで警告を生成します V3 。 The TRUNC 演算子がデータ型に変換されるようになりました DINT それ以外の INT 。 CODESYS 対応する型変換を自動的に追加します CoDeSys V2.3 輸入。 視覚化 プレースホルダーとその置換 プレースホルダー: PLC_PRG.$LocalVar$.aArr[0] VAR_INPUT: localVar: MyStruct; 使用法： localVar.aArr[0] 置換: localVar := PLC_PRG.myStructVar プレースホルダー: $Var$.aArr[0] VAR_INPUT: Var : MyStruct; 使用法： Var.aArr[0] 置換: Var := PLC_PRG.myStructVar プレースホルダー: PLC_PRG.myStructVar.aArr[$Index$] VAR_INPUT: Index : INT; 使用法： PLC_PRG.myStructVar.aArr[Index] 置換: Index := 0 問題のあるプレースホルダー テキスト内のプレースホルダー 文章： $axle$-Axis 修正： localVar : STRING; 文章： %s-Axis テキスト変数： localVar プレースホルダーは、変数名の一部のみを記述します axis$axis$spur$spur$.fActPosition 修正： のプレースホルダーを1つだけ定義します axis$axis$spur$spur$ プレースホルダー。 axis_spur : MyFunctionBlock; 次に、機能ブロックの対応するインスタンスを直接転送します。 axis_spur := PLC_PRG.axis1spur2; プレースホルダーは式に置き換えられます $Expression$ -> PLC_PRG.var1 + PLC_PRG.var2 修正： 式を補助変数に転送してから、この補助変数をインスタンスとして転送する必要があります。 プレースホルダーはプログラム名を記述します：$ Program $ .bToggle --PLC_PRG.bToggle D コンバーターは、この形式の設定プレースホルダーをに転送できません V3 。ただし、実際に使用することはめったにありません。 プレースホルダーはさまざまなタイプに置き換えられます。 $Var$ ->交換1： PLC_PRG.n （INT） ->交換2： PLC_PRG.st （ストリング） 修正： このためのインターフェースで2つの異なるプレースホルダーを定義します。 ビジュアライゼーションはライブラリにあります。後でビジュアライゼーションを使用するときに、任意のプロジェクトからプレースホルダーを置き換えます。 修正： ここで交換する必要があります TYPE_NONE 手動でデータ型。ただし、ライブラリをプロジェクトに統合して、プレースホルダーが正しく置き換えられる可能性もあります。このプロジェクトをインポートすると、データ型もライブラリで正しく決定されます。 インポートできない要素 トレンド、ActiveX：実装が大幅に異なるため、インポートはできません。の V3 、対応する警告が発行され、対応する手動での複製が必要です。 プログラミング言語: ST、IL、FBD 制限なし プログラミング言語: LD CODESYS ブランチの前の部分がブランチごとに繰り返されるように、並列ブランチを持つ関数ブロックをインポートします。これは、生成されたコードに対応します。 CoDeSys V2.3 並列ブランチ用に作成します。 プログラミング言語：SFC ユーザーによって明示的に宣言されたステップ変数は、SFCエディターでローカルに宣言する必要があります。それらをVAR_INPUT、VAR_OUTPUT、またはVAR_INOUTとして宣言することはできません。 CODESYS 呼び出しを自動的に適応させることはできません。説明：ステップは、の内部状態の管理にブール変数を使用しなくなりました V3 、だけでなく、タイプの構造 SFCStepType 。 識別子：次の識別子はアンダースコア文字で始まらない場合があります： ツリー内のIECアクションの名前 IECアソシエーションリストで呼び出される変数 プログラムされたトランジションの名前 説明：で V3 、暗黙の変数 CODESYS アクションの作成には、プレフィックスとしてアンダースコア文字が付けられます。二重下線文字を含む無効な識別子が発生します。 プログラミング言語: CFC 大きな箱：大きな箱のレイアウトは、輸入により品質が低下する可能性があります。ボックスが重なりすぎている可能性があります。 （修正予定です。） マクロ：マクロはインポートできません。 （修正予定です。） " }, 
{ "title" : "プロジェクトの構成 ", 
"url" : "_cds_struct_configuring_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ プロジェクトの構成 ", 
"snippet" : "あなたはあなたを設定することができます CODESYS 次のダイアログでプロジェクトします。 プロジェクト設定 ：エディターの動作、コンパイラー、ユーザー管理などの一般設定。 プロジェクト情報 ：パーソナライズされた固有の情報を使用したプロジェクトの識別設定 プロジェクト環境 ：最新で相互に互換性があることを目的として、使用する外部モジュールと内部モジュールのバージョンを定義します...", 
"body" : "あなたはあなたを設定することができます CODESYS 次のダイアログでプロジェクトします。 プロジェクト設定 ：エディターの動作、コンパイラー、ユーザー管理などの一般設定。 プロジェクト情報 ：パーソナライズされた固有の情報を使用したプロジェクトの識別設定 プロジェクト環境 ：最新で相互に互換性があることを目的として、使用する外部モジュールと内部モジュールのバージョンを定義します " }, 
{ "title" : "プロジェクト情報の取得と編集 ", 
"url" : "_cds_querying_and_editing_project_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ プロジェクトの構成 \/ プロジェクト情報の取得と編集 ", 
"snippet" : "あなたは使用することができます プロジェクト情報 プロジェクトと関連ファイルに関する情報を取得し、特定の情報を編集するためのオブジェクト。 オブジェクトには、に関する情報が含まれています ファイル属性 ベンダー、タイトル、作成者などのメタ情報 キーを持つプロパティ 統計学 ライセンス 署名：翻訳されたライブラリに署名するこの方法は非推奨であり、セキュリティ上の理由から、古いバージョンとの互換性が必要な場合にのみ使用する必要があります。この方法を使用する場合は、後で公開鍵トークンを使用して、ライブラリがライブラリベンダーによって最後に署名されたことを確認できます。したがって、図書館のベンダーとし...", 
"body" : "あなたは使用することができます プロジェクト情報 プロジェクトと関連ファイルに関する情報を取得し、特定の情報を編集するためのオブジェクト。 オブジェクトには、に関する情報が含まれています ファイル属性 ベンダー、タイトル、作成者などのメタ情報 キーを持つプロパティ 統計学 ライセンス 署名：翻訳されたライブラリに署名するこの方法は非推奨であり、セキュリティ上の理由から、古いバージョンとの互換性が必要な場合にのみ使用する必要があります。この方法を使用する場合は、後で公開鍵トークンを使用して、ライブラリがライブラリベンダーによって最後に署名されたことを確認できます。したがって、図書館のベンダーとして、たとえばドキュメントで使用されている公開鍵を顧客が利用できるようにすることが重要です。 CODESYS プロジェクト情報をプロジェクト内のオブジェクトとして保存します。プロジェクトを別のシステムに転送すると、 プロジェクト情報 オブジェクトはそれと一緒に転送されます。プロジェクトアーカイブは必要ありません。 プロパティキーを使用して、汎用ブロックを介して外部からプロジェクト情報にアクセスすることができます。ライブラリプロジェクトの場合、ライセンスに関する情報を照会することもできます。 " }, 
{ "title" : "メタ情報の編集 ", 
"url" : "_cds_querying_and_editing_project_information.html#UUID-597f8ad3-4a38-643c-f948-f1540f9dff94_id_c567cbe2bd6ab5ac0a8640e00176406_id_a57d0cffe98711e48c1bfcee0714ea73", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ プロジェクトの構成 \/ プロジェクト情報の取得と編集 \/ メタ情報の編集 ", 
"snippet" : "クリック プロジェクト→プロジェクト情報 。 The プロジェクト情報 ダイアログが開きます。 クリック 概要 タブ。 入力フィールドにデータを指定します（例： 0.0.0.1 の中に バージョン 入力フィールド）。 CODESYS 与えられた値ごとにキーを持つプロパティを作成し、それらを管理します プロパティ タブ。図書館プロジェクトの場合、 CODESYS 引き続きプロパティを使用し、後でライブラリリポジトリで並べ替えます。 のオプションを選択した場合 CODESYS これらのプロパティの関数ブロックを作成するには、プログラムでプロパティにアクセスできます。...", 
"body" : "クリック プロジェクト→プロジェクト情報 。 The プロジェクト情報 ダイアログが開きます。 クリック 概要 タブ。 入力フィールドにデータを指定します（例： 0.0.0.1 の中に バージョン 入力フィールド）。 CODESYS 与えられた値ごとにキーを持つプロパティを作成し、それらを管理します プロパティ タブ。図書館プロジェクトの場合、 CODESYS 引き続きプロパティを使用し、後でライブラリリポジトリで並べ替えます。 のオプションを選択した場合 CODESYS これらのプロパティの関数ブロックを作成するには、プログラムでプロパティにアクセスできます。 " }, 
{ "title" : "プロパティにアクセスするための関数の作成 ", 
"url" : "_cds_querying_and_editing_project_information.html#UUID-597f8ad3-4a38-643c-f948-f1540f9dff94_id_c567cbe2bd6ab5ac0a8640e00176406_id_036ad17de80511e4ab86a4571214df94", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ プロジェクトの構成 \/ プロジェクト情報の取得と編集 \/ プロパティにアクセスするための関数の作成 ", 
"snippet" : "クリック プロジェクト→プロジェクト情報 。 The プロジェクト情報 ダイアログが開きます。 を選択 「プロジェクト情報」POUを自動的に生成する オプション。 例 要件：次のプロパティが定義されています。 Schlüssel = nProp1 Typ= Zahl Wert= 333 を選択 「プロジェクト情報」POUを自動的に生成する オプション。 宣言する DINT 型変数。 例： showprop : DINT; 関数を呼び出す GetNumberProperty ： showprop := GetNumberProperty(\"nProp1\"); アプリケーションの値へのアクセスが許...", 
"body" : "クリック プロジェクト→プロジェクト情報 。 The プロジェクト情報 ダイアログが開きます。 を選択 「プロジェクト情報」POUを自動的に生成する オプション。 例 要件：次のプロパティが定義されています。 Schlüssel = nProp1\nTyp= Zahl\nWert= 333 を選択 「プロジェクト情報」POUを自動的に生成する オプション。 宣言する DINT 型変数。 例： showprop : DINT; 関数を呼び出す GetNumberProperty ： showprop := GetNumberProperty(\"nProp1\"); アプリケーションの値へのアクセスが許可されます。 注：で作成される関数 「プロジェクト情報」POUを自動的に生成する オプションは、ランタイムがをサポートしている場合にのみ使用できます WSTRING データ・タイプ。そうでない場合は、代わりに 「ライブラリ情報」POUを自動的に生成する オプション。この方法で作成された関数を、少なくともアプリケーションで使用して、プロパティにアクセスできます。これらの関数はランタイムに登録されていません。 " }, 
{ "title" : "ライブラリプロジェクトのライセンス ", 
"url" : "_cds_querying_and_editing_project_information.html#UUID-597f8ad3-4a38-643c-f948-f1540f9dff94_id_c567cbe2bd6ab5ac0a8640e00176406_id_cded5ad3e81111e4ab86a4571214df94", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ プロジェクトの構成 \/ プロジェクト情報の取得と編集 \/ ライブラリプロジェクトのライセンス ", 
"snippet" : "プロジェクトがライブラリプロジェクトの場合は、ここで使用中のライブラリライセンスをアクティブ化できます。 「 CODESYS 「セキュリティキー」はドングルとして使用されます。 要件：プロジェクトはライブラリプロジェクトです。 クリック プロジェクト→プロジェクト情報 。 The プロジェクト情報 ダイアログが開きます。 クリック ライセンス タブ。 を選択 ドングルライセンスを有効にする オプション。 ドングルデータをで指定します 会社コード 、 製品コード 、 アクティベーションURL 、 と アクティベーションメール 。 ライブラリはライセンスされています。...", 
"body" : "プロジェクトがライブラリプロジェクトの場合は、ここで使用中のライブラリライセンスをアクティブ化できます。 「 CODESYS 「セキュリティキー」はドングルとして使用されます。 要件：プロジェクトはライブラリプロジェクトです。 クリック プロジェクト→プロジェクト情報 。 The プロジェクト情報 ダイアログが開きます。 クリック ライセンス タブ。 を選択 ドングルライセンスを有効にする オプション。 ドングルデータをで指定します 会社コード 、 製品コード 、 アクティベーションURL 、 と アクティベーションメール 。 ライブラリはライセンスされています。 " }, 
{ "title" : "非推奨：ライブラリプロジェクトへの署名–バージョンとの互換性のためのみ CODESYS < 3.5 SP15 –バージョン内 CODESYS V3 SP17以降、で作成された非推奨の署名を持つ既存のライブラリのみ プロジェクト情報–署名 ダイアログ ", 
"url" : "_cds_querying_and_editing_project_information.html#UUID-597f8ad3-4a38-643c-f948-f1540f9dff94_id_c567cbe2bd6ab5ac0a8640e00176406_id_4f7ee481fe1211e49fce83667d100c0a", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ プロジェクトの構成 \/ プロジェクト情報の取得と編集 \/ 非推奨：ライブラリプロジェクトへの署名–バージョンとの互換性のためのみ CODESYS < 3.5 SP15 –バージョン内 CODESYS V3 SP17以降、で作成された非推奨の署名を持つ既存のライブラリのみ プロジェクト情報–署名 ダイアログ ", 
"snippet" : "現在 CODESYS V3 SP15 、ライブラリの署名は常に証明書に基づいています。この種の署名を実行するには、に関するヘルプページを参照してください。 プロジェクトをコンパイル済みライブラリとして保存 指図。の設定を使用した非推奨の署名とは対照的に プロジェクト情報 – 署名 ダイアログでは、ライブラリ全体が証明書で署名されています。 それでも図書館プロジェクトに署名する必要がある場合は CODESYS バージョン< V3 SP15 互換性の理由から、次のように進めます。 要件：トークンが関連付けられた使用可能な秘密鍵ファイルがあります。ライブラリプロジェクトのプロジェクト情報で、ライブラ...", 
"body" : "現在 CODESYS V3 SP15 、ライブラリの署名は常に証明書に基づいています。この種の署名を実行するには、に関するヘルプページを参照してください。 プロジェクトをコンパイル済みライブラリとして保存 指図。の設定を使用した非推奨の署名とは対照的に プロジェクト情報 – 署名 ダイアログでは、ライブラリ全体が証明書で署名されています。 それでも図書館プロジェクトに署名する必要がある場合は CODESYS バージョン< V3 SP15 互換性の理由から、次のように進めます。 要件：トークンが関連付けられた使用可能な秘密鍵ファイルがあります。ライブラリプロジェクトのプロジェクト情報で、ライブラリとの互換性 CODESYS バージョン< V3 SP15 に設定されています 概要 タブ。 クリック プロジェクト→プロジェクト情報 。 The プロジェクト情報 ダイアログが開きます。 クリック 署名 タブ。 を選択 署名を有効にする オプション。 秘密鍵ファイルのメモリ位置を指定します。 CODESYS トークンを自動的に入力します 公開鍵トークン 。 例： 427A5701DA3CF3CF クリック ファイル→ プロジェクトをコンパイル済みライブラリとして保存 。 ライブラリプロジェクトは、拡張子が付いたファイルとして保存されます *.library 。ライブラリリポジトリまたはライブラリマネージャのライブラリ詳細にトークンが表示され、ライブラリベンダーから公開されたトークンと比較できます。このようにして、ライブラリが実際に目的のベンダーからのものであるかどうかを確認できます。 " }, 
{ "title" : "秘密鍵ファイルの作成 ", 
"url" : "_cds_querying_and_editing_project_information.html#UUID-597f8ad3-4a38-643c-f948-f1540f9dff94_id_c567cbe2bd6ab5ac0a8640e00176406_id_62a1c2fde5fb82e1c0a8640e0154acb5", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ プロジェクトの構成 \/ プロジェクト情報の取得と編集 \/ 秘密鍵ファイルの作成 ", 
"snippet" : "クリック プロジェクト→ プロジェクト情報 。 クリック 署名 タブ。 クリック 秘密鍵ファイルを作成する ボタン。 The 秘密鍵ファイルを作成する ダイアログが開きます。 安全な場所を選択してください。 D:\\for lib developers only\\mycomp_libkey.libpk とダイアログを終了します 保存する 。...", 
"body" : "クリック プロジェクト→ プロジェクト情報 。 クリック 署名 タブ。 クリック 秘密鍵ファイルを作成する ボタン。 The 秘密鍵ファイルを作成する ダイアログが開きます。 安全な場所を選択してください。 D:\\for lib developers only\\mycomp_libkey.libpk とダイアログを終了します 保存する 。 " }, 
{ "title" : "プロジェクト設定の構成 ", 
"url" : "_cds_struct_setting_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの作成と構成 \/ プロジェクトの構成 \/ プロジェクト設定の構成 ", 
"snippet" : "の動作に影響を与える設定を構成できます CODESYS との特定の編集者のそれ プロジェクト設定 物体。設定はプロジェクト全体で有効であり、アクティブなエディターにすぐに適用されます。また、使用することができます プロジェクト→プロジェクト設定 オブジェクトのダイアログにアクセスするコマンド。 CODESYS プロジェクト設定をプロジェクト内のオブジェクトとして保存します。次に、プロジェクトを別のシステムに転送すると、 プロジェクト設定 オブジェクトはそれと一緒に転送されます。プロジェクトアーカイブは必要ありません。...", 
"body" : "の動作に影響を与える設定を構成できます CODESYS との特定の編集者のそれ プロジェクト設定 物体。設定はプロジェクト全体で有効であり、アクティブなエディターにすぐに適用されます。また、使用することができます プロジェクト→プロジェクト設定 オブジェクトのダイアログにアクセスするコマンド。 CODESYS プロジェクト設定をプロジェクト内のオブジェクトとして保存します。次に、プロジェクトを別のシステムに転送すると、 プロジェクト設定 オブジェクトはそれと一緒に転送されます。プロジェクトアーカイブは必要ありません。 " }, 
{ "title" : "プロジェクトのエクスポートと転送 ", 
"url" : "_cds_struct_project_export_transfer.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトのエクスポートと転送 ", 
"snippet" : "のデータ交換には、エクスポートおよびインポート機能を使用できます。 CODESYS 他のプログラムとのプロジェクト。 プロジェクトファイル（* .project）またはプロジェクトアーカイブ（* .projectarchive）のコピーを使用して交換します CODESYS プロジェクト-間 CODESYS 開発システム。...", 
"body" : "のデータ交換には、エクスポートおよびインポート機能を使用できます。 CODESYS 他のプログラムとのプロジェクト。 プロジェクトファイル（* .project）またはプロジェクトアーカイブ（* .projectarchive）のコピーを使用して交換します CODESYS プロジェクト-間 CODESYS 開発システム。 " }, 
{ "title" : "プロジェクトのエクスポートとインポート ", 
"url" : "_cds_project_export_import.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトのエクスポートと転送 \/ プロジェクトのエクスポートとインポート ", 
"snippet" : "CODESYS ファイルとの間でオブジェクトをエクスポートおよびインポートするためのコマンドを提供します。これを行うには2つの方法があります。 にエクスポートおよびインポート CODESYS XMLファイル（* .export） このフォーマットは、 CODESYS プロジェクト形式。オブジェクトは、マシン解析可能なXML形式で保存されます。 PLCopen形式（* .xml）のXMLファイルへのエクスポートおよびXMLファイルからのインポート この形式を使用して、プログラムエディタやドキュメントツールなどのプログラム間で情報を交換できます。 PLCopen XMLは、要素のサブセットを定義し...", 
"body" : "CODESYS ファイルとの間でオブジェクトをエクスポートおよびインポートするためのコマンドを提供します。これを行うには2つの方法があります。 にエクスポートおよびインポート CODESYS XMLファイル（* .export） このフォーマットは、 CODESYS プロジェクト形式。オブジェクトは、マシン解析可能なXML形式で保存されます。 PLCopen形式（* .xml）のXMLファイルへのエクスポートおよびXMLファイルからのインポート この形式を使用して、プログラムエディタやドキュメントツールなどのプログラム間で情報を交換できます。 PLCopen XMLは、要素のサブセットを定義しました。 CODESYS 認識します。したがって、100％の互換性は保証できません。 " }, 
{ "title" : "プロジェクトのエクスポート ", 
"url" : "_cds_project_export_import.html#UUID-4276a4a2-07e1-df8e-2521-15e4d85eb49f_id_a282cbda3e76d3c0a8640e001b04d0_id_6b64e742dada2534c0a8640e0069c11e", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトのエクスポートと転送 \/ プロジェクトのエクスポートとインポート \/ プロジェクトのエクスポート ", 
"snippet" : "要件：プロジェクトはで開かれています CODESYS 。 クリック プロジェクト->エクスポート また プロジェクト-> PLCopenXMLのエクスポート 。 でエクスポートオブジェクトを選択します 輸出 ダイアログまたは PLCopenXMLをエクスポートする ダイアログ。 クリック わかった 。 ファイル名と場所を指定します。クリック 保存する 。...", 
"body" : "要件：プロジェクトはで開かれています CODESYS 。 クリック プロジェクト->エクスポート また プロジェクト-> PLCopenXMLのエクスポート 。 でエクスポートオブジェクトを選択します 輸出 ダイアログまたは PLCopenXMLをエクスポートする ダイアログ。 クリック わかった 。 ファイル名と場所を指定します。クリック 保存する 。 " }, 
{ "title" : "プロジェクトのインポート ", 
"url" : "_cds_project_export_import.html#UUID-4276a4a2-07e1-df8e-2521-15e4d85eb49f_id_a282cbda3e76d3c0a8640e001b04d0_id_243afeac184815f7c0a8640e00616fed", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトのエクスポートと転送 \/ プロジェクトのエクスポートとインポート \/ プロジェクトのインポート ", 
"snippet" : "要件：プロジェクトはで開かれています CODESYS 。 クリック プロジェクト->インポート また プロジェクト-> PLCopenXMLのインポート 。 でインポートオブジェクトを選択します 輸入 ダイアログまたは PLCopenXMLをインポートする ダイアログ。 ダイアログが開き、この場所に挿入できるオブジェクトのツリー構造が表示されます。 オブジェクトをインポートできるツリー構造内のオブジェクトを選択します。 オブジェクトを選択してクリックします わかった 。 オブジェクトは既存のオブジェクトツリーに追加されます。 詳細については、以下を参照してください。 PLCopenXML...", 
"body" : "要件：プロジェクトはで開かれています CODESYS 。 クリック プロジェクト->インポート また プロジェクト-> PLCopenXMLのインポート 。 でインポートオブジェクトを選択します 輸入 ダイアログまたは PLCopenXMLをインポートする ダイアログ。 ダイアログが開き、この場所に挿入できるオブジェクトのツリー構造が表示されます。 オブジェクトをインポートできるツリー構造内のオブジェクトを選択します。 オブジェクトを選択してクリックします わかった 。 オブジェクトは既存のオブジェクトツリーに追加されます。 詳細については、以下を参照してください。 PLCopenXML" }, 
{ "title" : "プロジェクトの転送 ", 
"url" : "_cds_project_transfer.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトのエクスポートと転送 \/ プロジェクトの転送 ", 
"snippet" : "プロジェクトを別のコンピュータに転送し、オンラインでの変更やダウンロードを必要とせずにそこから同じPLCに接続する場合は、次の点に注意してください。 プロジェクトに必要なのは、修正バージョンのライブラリ（例外：インターフェイスライブラリ）、視覚化プロファイル、およびコンパイラのみであることを確認してください。 ブートアプリケーションが最新であることを確認してください。 次に、他のコンピューターで解凍するリポジトリを作成します。...", 
"body" : "プロジェクトを別のコンピュータに転送し、オンラインでの変更やダウンロードを必要とせずにそこから同じPLCに接続する場合は、次の点に注意してください。 プロジェクトに必要なのは、修正バージョンのライブラリ（例外：インターフェイスライブラリ）、視覚化プロファイル、およびコンパイラのみであることを確認してください。 ブートアプリケーションが最新であることを確認してください。 次に、他のコンピューターで解凍するリポジトリを作成します。 " }, 
{ "title" : "プロジェクトを別のシステムに転送する ", 
"url" : "_cds_project_transfer.html#UUID-ed2bc292-0880-13a7-2fde-3d254ec1acb6_id_a747b06714334ffc0a8640e011c1820_id_3621759901828743c0a8640e00ee49c5", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトのエクスポートと転送 \/ プロジェクトの転送 \/ プロジェクトを別のシステムに転送する ", 
"snippet" : "要件：プロジェクトは、別のコンピューター「PC2」に転送するコンピューター「PC1」で開かれ、そこから同じコントローラーに再度接続します。 修正バージョンのライブラリのみがプロジェクトに含まれていることを確認してください（例外：純粋なインターフェイスライブラリ）。これを行うには、 ライブラリマネージャー 修正バージョン番号の代わりに「*」が付いているすべてのエントリをチェックします。 コンパイラ バージョン 3.5.18.0 以降では、プレースホルダーの解決でライブラリ プロファイルが無視されます。プロファイルに含まれるライブラリは、自動的に無料のプレースホルダーになります。ライブラリ プロフ...", 
"body" : "要件：プロジェクトは、別のコンピューター「PC2」に転送するコンピューター「PC1」で開かれ、そこから同じコントローラーに再度接続します。 修正バージョンのライブラリのみがプロジェクトに含まれていることを確認してください（例外：純粋なインターフェイスライブラリ）。これを行うには、 ライブラリマネージャー 修正バージョン番号の代わりに「*」が付いているすべてのエントリをチェックします。 コンパイラ バージョン 3.5.18.0 以降では、プレースホルダーの解決でライブラリ プロファイルが無視されます。プロファイルに含まれるライブラリは、自動的に無料のプレースホルダーになります。ライブラリ プロファイルをリポジトリに含めるオプションは使用できなくなりました。 プロジェクト設定で修正コンパイラバージョンが設定されていることを確認してください。これを確認するには、をクリックします プロジェクト→プロジェクト設定 そして コンパイラオプション カテゴリー。 プロジェクト設定で修正視覚化プロファイルが定義されていることを確認してください。これを確認するには、をクリックします プロジェクト→プロジェクト設定 そして 視覚化プロファイル カテゴリー。 現在開いているアプリケーションが、PLCで現在使用されているアプリケーションと同じであることを確認してください。これは、「ブートアプリケーション」がプログラミングシステムのプロジェクトと同一である必要があることを意味します。これを行うには、プログラミングシステムウィンドウのタイトルバーでプロジェクト名を確認します。名前の後にアスタリスクが表示されている場合、プロジェクトは変更されていますが、まだ保存されていません。その場合、アプリケーションとブートアプリケーションが一致しない可能性があります。 この場合、最初に（新しい）ブートアプリケーションを作成します。アプリケーションのロード（ダウンロード）時にこれが自動的に行われるかどうかは、PLCとアプリケーションのプロパティによって異なります。明示的に作成するには、をクリックします オンライン→ブートアプリケーションの作成 。次に、をクリックします オンライン→ログイン と オンライン→ダウンロード ダウンロードを実行します。 その後、をクリックします デバッグ→開始 コントローラでアプリケーションを起動します。 これで、同じプロジェクトのPC2で後で再度接続するPLCで目的のアプリケーションが実行されます。 プロジェクトアーカイブを作成する：をクリックします ファイル→プロジェクトアーカイブ→アーカイブの保存\/送信 。の中に プロジェクトアーカイブ ダイアログで、次の情報も選択します。 情報ファイルをダウンロードする ライブラリプロファイル 参照デバイス 参照ライブラリ 視覚化プロファイル PC2からアクセスできる場所にプロジェクトアーカイブを保存します。 コントローラからログアウトします。これを行うには、をクリックします オンライン→ログアウト 。 PC2から再接続する前に、ためらうことなくPLCを停止して再起動できます。 リポジトリをPC2に抽出します。をクリックします。 ファイル→プロジェクトアーカイブ→アーカイブの抽出 上に保存したアーカイブを開きます。の中に プロジェクトアーカイブの抽出 ダイアログで、アーカイブを作成するときに上記と同じ情報を選択します。 プロジェクトを開き、PLC「xy」に再度ログインします。 CODESYS オンラインでの変更やダウンロードは必要ありません。プロジェクトが実行されています。 " }, 
{ "title" : "プロジェクトの比較 ", 
"url" : "_cds_struct_project_comparison.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの比較 ", 
"snippet" : "現在開いているプロジェクトを別のプロジェクト（参照プロジェクト）と比較できます。コンテンツ、プロパティ、またはアクセス権の違いが検出され、比較ビューに表示されます。 クリックする プロジェクト→比較 を開きます プロジェクトの比較 比較を構成して実行するためのダイアログ。次に、結果がに表示されます プロジェクトの比較–違い オブジェクトがツリー構造で整列されている場所を表示します。それぞれの参照オブジェクトとの違いを示すオブジェクトは、色と記号で識別されます。これは、コンテンツ、プロパティ、またはアクセス権が異なるかどうかを検出する方法です。 内容の違いについては、詳細を開くこともできます プ...", 
"body" : "現在開いているプロジェクトを別のプロジェクト（参照プロジェクト）と比較できます。コンテンツ、プロパティ、またはアクセス権の違いが検出され、比較ビューに表示されます。 クリックする プロジェクト→比較 を開きます プロジェクトの比較 比較を構成して実行するためのダイアログ。次に、結果がに表示されます プロジェクトの比較–違い オブジェクトがツリー構造で整列されている場所を表示します。それぞれの参照オブジェクトとの違いを示すオブジェクトは、色と記号で識別されます。これは、コンテンツ、プロパティ、またはアクセス権が異なるかどうかを検出する方法です。 内容の違いについては、詳細を開くこともできます プロジェクトの比較 – <オブジェクト名> の違い オブジェクトを拡大するために表示します。詳細比較ビューでは、オブジェクトのソース コードが参照オブジェクトのソース コードと比較されます。検出された相違点にはフラグが立てられます。以前に開いていたビューは閉じられません。このようにして、プロジェクト比較ビューに加えて、任意の数の比較ビューを開いて読み取ることができます。 検出された相違点を解決するために、参照プロジェクトの状態を現在のプロジェクトに受け入れるかどうかを決定できます。現在のプロジェクトから参照プロジェクトに状態を受け入れることはできません。アクティブな比較ビューでは、たとえば、異なるコード行またはブロックの受け入れを有効にすることができます。 、 、 また コマンド。これらの位置は黄色で強調表示されます。他の開いている比較ビューは非アクティブ (書き込み保護、読み取り専用) であることに注意してください。したがって、差異を有効化して、1 つの比較ビューのみで受け入れることができます。エディターでサポートされている場合は、3 番目の比較ビューを追加できます。この 3 番目のビューには、差異の解決アクションの結果が表示されます。 アクティブな比較ビューを終了するときに、受け入れのためにアクティブ化された差異が実際に現在のプロジェクトに受け入れられていることを確認すると、現在のプロジェクトが変更されます。 プロジェクト比較を完全に終了するには、プロジェクト比較ビューを閉じます。 " }, 
{ "title" : "比較ビューの作成 ", 
"url" : "_cds_creating_project_differences.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの比較 \/ 比較ビューの作成 ", 
"snippet" : "要件：現在のプロジェクトに変更を加え、たとえば、最後に保存したバージョンと比較したい。その間に、たとえば、POUを追加したり、POUを削除したり、POUのコード行を変更したり、オブジェクトのプロパティを変更したりしました。 クリック プロジェクト→比較 The プロジェクトの比較 ダイアログが開きます。 参照プロジェクトのパスを指定します。たとえば、現在のプロジェクトの最後に保存されたバージョンのパスを指定します。 出て 空白を無視する 比較オプションが有効になっています。 クリック わかった 。 CODESYS 比較ビューを開きます。 タイトル： プロジェクトの比較–違い 現在のプロジェクト...", 
"body" : "要件：現在のプロジェクトに変更を加え、たとえば、最後に保存したバージョンと比較したい。その間に、たとえば、POUを追加したり、POUを削除したり、POUのコード行を変更したり、オブジェクトのプロパティを変更したりしました。 クリック プロジェクト→比較 The プロジェクトの比較 ダイアログが開きます。 参照プロジェクトのパスを指定します。たとえば、現在のプロジェクトの最後に保存されたバージョンのパスを指定します。 出て 空白を無視する 比較オプションが有効になっています。 クリック わかった 。 CODESYS 比較ビューを開きます。 タイトル： プロジェクトの比較–違い 現在のプロジェクトと参照プロジェクトのデバイスツリーが比較され、変更されたオブジェクトが色で強調表示されます。 参照プロジェクトツリー（右）で、青色で強調表示されているオブジェクトを選択します。このオブジェクトは、現在のプロジェクトに含まれなくなりました。 クリック シングルを受け入れる 。 CODESYS 現在のプロジェクトのツリーにオブジェクトを追加します（左）。線は黄色で強調表示されます。 The 中央の列に記号が表示されます。 現在のプロジェクトツリー（左）で、緑色で強調表示されているオブジェクトを選択します。このオブジェクトは参照プロジェクトに含まれていません。 クリック シングルを受け入れる 。 CODESYS 現在のプロジェクトのツリーからオブジェクトを再度削除します（左）。線は黄色で強調表示されます。 The 中央の列に記号が表示されます。 もしも CODESYS 現在のプロジェクトと参照プロジェクトに含まれているオブジェクトの内容の変更を検出した場合、これは赤いテキストで示されます。次に、オブジェクトをダブルクリックして、オブジェクトの詳細な比較ビューに切り替えることができます。 比較ビューを閉じて答えます はい 加えられた変更を保存する必要があるかどうかという質問に。 変更はプロジェクトで有効になります。 詳細については、以下を参照してください。 詳細比較ビューを開く" }, 
{ "title" : "詳細比較ビューを開く ", 
"url" : "_cds_creating_editing_detail_differences.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの比較 \/ 詳細比較ビューを開く ", 
"snippet" : "要件: たとえば、ユーザーが現在のプロジェクトの POU でコードを変更しました。をクリックして、プロジェクトの比較を実行しました。 プロジェクト → 比較 .プロジェクト比較ビューでは、この POU が現在のプロジェクトと参照プロジェクトのプロジェクト ツリーに合わせて赤色で強調表示されます。 整列されたPOUバージョンの行をダブルクリックします。 比較ビューは、POUの詳細な比較ビューに切り替わります。変更されたコード行は灰色で強調表示され、赤で書かれています。 クリック 。 変更のあるコード行（赤）は、挿入のある行（左、緑）と削除のある行（右、青）の2行延長されます。 クリック また。 ...", 
"body" : "要件: たとえば、ユーザーが現在のプロジェクトの POU でコードを変更しました。をクリックして、プロジェクトの比較を実行しました。 プロジェクト → 比較 .プロジェクト比較ビューでは、この POU が現在のプロジェクトと参照プロジェクトのプロジェクト ツリーに合わせて赤色で強調表示されます。 整列されたPOUバージョンの行をダブルクリックします。 比較ビューは、POUの詳細な比較ビューに切り替わります。変更されたコード行は灰色で強調表示され、赤で書かれています。 クリック 。 変更のあるコード行（赤）は、挿入のある行（左、緑）と削除のある行（右、青）の2行延長されます。 クリック また。 コード行は、変更済みとして再度マークされます。 変更済みとしてマークされたコード行にマウスポインタを移動し、クリックします シングルを受け入れる 。 参照プロジェクトのコード行は、現在のプロジェクトに受け入れるためにアクティブ化されます。 利用可能な場合は、 3 番目のビューを追加します。 現在のオブジェクトと参照オブジェクトのコードを対比する 2 つのビューの下に、3 番目のビューが表示されます。これは、現在のオブジェクトと参照オブジェクトの違いを解決するために実行したアクションの結果を示しています。これらのアクションでは、詳細な比較ビューのタスクバーで追加のボタンを使用できます。詳細については、次を参照してください。 ビュー：プロジェクトの比較-<オブジェクト名>の違い. クリック 。 プロジェクト全体のプロジェクト比較ビューが開きます。違いを受け入れのためにアクティブ化することを防ぐために、書き込み保護（読み取り専用）されています。ツリービューの上に黄色で強調表示されているリンクもこれを示しています。 リンクをクリックします。 別のビューにコミットされていない変更があるため、プロジェクト比較ビューは読み取り専用です。変更されたビューに切り替えるには、ここをクリックしてください。 詳細比較ビューが再び開きます。未確認の変更は黄色で強調表示されます。 クリック ビューのタブで、変更を保存する必要があることを確認します。 詳細プロジェクトビューが閉じられ、POUが上書きされます。これで、参照プロジェクトのPOUに対応します。プロジェクトビューが再びアクティブになるため、プロジェクト比較の作業を続行できます。 リンク (手順 7) をクリックせずに、 プロジェクト比較ビューのエディターを閉じる代わりに、現在のプロジェクトへの変更の受け入れも確認します。詳細な変更が受け入れられ、プロジェクトの比較が完全に終了します。 詳細については、以下を参照してください。 比較ビューの作成" }, 
{ "title" : "プロジェクトの保護と保存 ", 
"url" : "_cds_struct_project_protection_storage.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの保護と保存 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "プロジェクト保護 ", 
"url" : "_cds_struct_project_protection_storage.html#UUID-d82983fe-0a1b-1735-b6e6-87e3d8fe682b_section-idm234759364725429", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの保護と保存 \/ プロジェクト保護 ", 
"snippet" : "プロジェクトの保護については、以下のヘルプページをご覧ください。 ソースコードの保護...", 
"body" : "プロジェクトの保護については、以下のヘルプページをご覧ください。 ソースコードの保護 " }, 
{ "title" : "ファイリング、保存 ", 
"url" : "_cds_struct_project_protection_storage.html#UUID-d82983fe-0a1b-1735-b6e6-87e3d8fe682b_section-idm4654689522251232654637501867", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの保護と保存 \/ ファイリング、保存 ", 
"snippet" : "プロジェクトファイルをファイルシステムに保存する前に、必要な保護をプロジェクトファイルに提供します。上記を参照。読み取り専用プロジェクトファイルの場合、書き込み保護の種類に応じて、ファイルを保存できるようにさまざまなオプションが提供されます。 プロジェクトを後で開く必要がある場合 CODESYS バージョンの場合、このバージョンのプロジェクトを保存するのは理にかなっています。 CODESYS その後、データ損失の可能性についてすぐに通知します。 ライブラリプロジェクトを保存する場合は、を参照してください。 ライブラリを作成するためのガイドライン 。また、ライブラリをライブラリリポジトリに直接イ...", 
"body" : "プロジェクトファイルをファイルシステムに保存する前に、必要な保護をプロジェクトファイルに提供します。上記を参照。読み取り専用プロジェクトファイルの場合、書き込み保護の種類に応じて、ファイルを保存できるようにさまざまなオプションが提供されます。 プロジェクトを後で開く必要がある場合 CODESYS バージョンの場合、このバージョンのプロジェクトを保存するのは理にかなっています。 CODESYS その後、データ損失の可能性についてすぐに通知します。 ライブラリプロジェクトを保存する場合は、を参照してください。 ライブラリを作成するためのガイドライン 。また、ライブラリをライブラリリポジトリに直接インストールする可能性も検討してください。 別のコンピューターでプロジェクトを引き続き使用する場合は、プロジェクトファイルを保存するだけでなく、 プロジェクトアーカイブ 関連するすべての補助ファイルから。 プロジェクトを保存するたびに、このプロジェクトのバックアップコピーが作成されるように設定できます。さらに、プロジェクトが通常特定の時間間隔で自動的に保存されるようにCODESYSを構成できます。詳細については、以下を参照してください。 ロードして保存プロジェクトを維持したい場合 ソースコード管理システム 、対応するアドオンを検討してください CODESYS 。たとえば、SVNへのリンクがサポートされています。 " }, 
{ "title" : "プロジェクトの保存 ", 
"url" : "_cds_saving_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの保護と保存 \/ プロジェクトの保存 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "同じ名前でプロジェクトを保存する ", 
"url" : "_cds_saving_project.html#UUID-1bc9d9ae-6670-3dc0-ea69-bcf82769aa81_id_dcaaa6487a164c0a8640e003a1189_id_1d675998b906498cc0a8640e01be26b4", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの保護と保存 \/ プロジェクトの保存 \/ 同じ名前でプロジェクトを保存する ", 
"snippet" : "要件：プロジェクトは開いています。プロジェクトファイルは書き込み保護されていません。 クリック ファイル → プロジェクトを保存 。 CODESYS メインウィンドウのタイトルバーに表示される現在のプロジェクト名でプロジェクトファイルを保存します。プロジェクトが最後に保存されてから変更されている場合は、プロジェクト名にアスタリスクが付いています。これがに設定されている場合 CODESYS のオプション ロードして保存 カテゴリの場合、バックアップコピーも作成されます。 保存形式 プロジェクトの保存形式は、 CODESYS Development System これは、プロジェクトの作成後または...", 
"body" : "要件：プロジェクトは開いています。プロジェクトファイルは書き込み保護されていません。 クリック ファイル → プロジェクトを保存 。 CODESYS メインウィンドウのタイトルバーに表示される現在のプロジェクト名でプロジェクトファイルを保存します。プロジェクトが最後に保存されてから変更されている場合は、プロジェクト名にアスタリスクが付いています。これがに設定されている場合 CODESYS のオプション ロードして保存 カテゴリの場合、バックアップコピーも作成されます。 保存形式 プロジェクトの保存形式は、 CODESYS Development System これは、プロジェクトの作成後または後で変更した後にプロジェクトを保存するために使用されます。このプロファイルには、このプラグインのすべてのバージョン情報が含まれています CODESYS インストールと、これに含まれるすべてのアドオンのインストールも同様です CODESYS インストール。 を使用してプロジェクトを保存すると、 プロジェクトの保存 コマンドを実行しても、ストレージ形式は自動的に更新されません。 保存形式は次の場合にのみ更新されます。 プロジェクトを保存するには、 プロジェクトに名前を付けて保存 コマンドで別のストレージ形式を選択すると、 ファイルの種類として保存 リストボックス。 プロジェクトが開かれています CODESYS プロジェクトとは異なるストレージ形式を持つインストール: もしそうなら、 プロジェクトの保存形式を <保存形式> に更新しますか? このプロジェクトを編集しているときにダイアログが表示されるので、 はい 続行してクリックしてください プロジェクトの保存 をクリックしてプロジェクトを保存します。 プロジェクトの保存形式が表示されます。 プロジェクト → プロジェクト情報 、上で ファイル タブ。 " }, 
{ "title" : "プロジェクトを別の名前または保存形式で保存する ", 
"url" : "_cds_saving_project.html#UUID-1bc9d9ae-6670-3dc0-ea69-bcf82769aa81_id_dcaaa6487a164c0a8640e003a1189_id_e0e08580b906498dc0a8640e00285d64", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの保護と保存 \/ プロジェクトの保存 \/ プロジェクトを別の名前または保存形式で保存する ", 
"snippet" : "要件：プロジェクトは開いています。 クリック ファイル → プロジェクトに名前を付けて保存 。 The プロジェクトを保存 ダイアログが開きます。 ファイルシステム内の場所と目的の場所を選択します ファイルの種類 （プロジェクトファイルまたはライブラリファイル）および目的のストレージバージョン。後で古いバージョンでプロジェクトを開きたい場合は、このバージョンを正確に保存することをお勧めします。これにより、データ損失の可能性についてメッセージビューですぐに通知されます。 プロジェクトファイルが書き込み保護されていない場合は、 CODESYS 選択したパスに保存します。それ以外の場合は、続行する方...", 
"body" : "要件：プロジェクトは開いています。 クリック ファイル → プロジェクトに名前を付けて保存 。 The プロジェクトを保存 ダイアログが開きます。 ファイルシステム内の場所と目的の場所を選択します ファイルの種類 （プロジェクトファイルまたはライブラリファイル）および目的のストレージバージョン。後で古いバージョンでプロジェクトを開きたい場合は、このバージョンを正確に保存することをお勧めします。これにより、データ損失の可能性についてメッセージビューですぐに通知されます。 プロジェクトファイルが書き込み保護されていない場合は、 CODESYS 選択したパスに保存します。それ以外の場合は、続行する方法が通知されます。 現在のプロジェクトに、目的のメモリ形式に含まれていないアドオンが含まれている場合、 プロファイルの拡張 ダイアログが開きます。 アドオンデータを保存するために、メモリ形式を拡張するアドオンを選択します。 メモリ形式を永続的に保存するには、 プロファイルを保存 で名前を指定します プロファイル名を入力してください ダイアログ。 の中に プロファイルを拡張する ダイアログで、 保存したプロファイルを使用する オプションをクリックしてクリックします はい 。 CODESYS 保存されたプロファイルと新しいストレージ形式でプロジェクトを保存します。新しいストレージ形式が表示されます プロジェクト → プロジェクト情報 、 ファイル タブ。 " }, 
{ "title" : "読み取り専用プロジェクトの保存 ", 
"url" : "_cds_saving_project.html#UUID-1bc9d9ae-6670-3dc0-ea69-bcf82769aa81_id_dcaaa6487a164c0a8640e003a1189_id_00663280b906498fc0a8640e01c6ebb3", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの保護と保存 \/ プロジェクトの保存 \/ 読み取り専用プロジェクトの保存 ", 
"snippet" : "要件：読み取り専用プロジェクトが開いています。 クリック ファイル → プロジェクトを保存 。 書き込み保護がで割り当てられた場合 CODESYS 、メインウィンドウの右上隅に線で表示されます。現在の状況に応じて、プロジェクトを保存できるように、次の1つ以上のアクションが提供されます。 プロジェクトを別のファイル名でディスクに保存します : 常に表示され、継続します。 プロジェクトの保存 ダイアログについては、 プロジェクトに名前を付けて保存 指示 読み取り専用モードを終了します ：次の場合に表示されます 読み取り専用で開く プロジェクトを開くときにオプションが選択されている ディスク上のプロ...", 
"body" : "要件：読み取り専用プロジェクトが開いています。 クリック ファイル → プロジェクトを保存 。 書き込み保護がで割り当てられた場合 CODESYS 、メインウィンドウの右上隅に線で表示されます。現在の状況に応じて、プロジェクトを保存できるように、次の1つ以上のアクションが提供されます。 プロジェクトを別のファイル名でディスクに保存します : 常に表示され、継続します。 プロジェクトの保存 ダイアログについては、 プロジェクトに名前を付けて保存 指示 読み取り専用モードを終了します ：次の場合に表示されます 読み取り専用で開く プロジェクトを開くときにオプションが選択されている ディスク上のプロジェクトから読み取り専用属性を削除します ：プロジェクトファイルがローカルファイルシステムで開かれたときに「読み取り専用」プロパティが提供されていた場合に表示されます プロジェクト情報の「リリース済み」のIDを削除します ：この属性が現在設定されている場合にのみ表示されます 書き込み保護が外部に割り当てられた場合 CODESYS ファイルシステムのプロジェクトファイルのプロパティで、同じ名前とパスで保存しようとすると、次のオプションが表示されます。 名前を付けて保存 ：と同じように別の名前で保存できます プロジェクトを名前を付けて保存 指図。 上書きする ：書き込み保護がプロジェクトファイルから削除され、ファイルは既存の名前で保存されます。 メインウィンドウの右上隅にある、書き込み保護を示す線をクリックします。 プロジェクトを保存できる現在のオプションは、選択メニューに表示されます。 提供されているオプションの1つを選択し、必要なアクションを実行します。 クリック ファイル → プロジェクトを保存 または ファイル → プロジェクトに名前を付けて保存 。 プロジェクトを保存できます。 " }, 
{ "title" : "プロジェクトを自動的に保存します。バックアップコピーの作成 ", 
"url" : "_cds_saving_project.html#UUID-1bc9d9ae-6670-3dc0-ea69-bcf82769aa81_id_dcaaa6487a164c0a8640e003a1189_id_87e64193d38533efc0a8640e01f1fc6f", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの保護と保存 \/ プロジェクトの保存 \/ プロジェクトを自動的に保存します。バックアップコピーの作成 ", 
"snippet" : "要件：プロジェクトは開いています。 クリック ツール → オプション そしてその ロードして保存する カテゴリー。 The ロードして保存 ダイアログが開きます。 をアクティブにします バックアップコピーを作成する オプション。 を選択 …分ごとに自動的に保存 オプションを選択し、時間間隔を選択します。 クリック わかった を閉じるには オプション ダイアログ。 プロジェクトが保存されるたびに、 CODESYS また、という名前のバックアップコピーを作成します <project name>.backup 。 CODESYS 指定された時間間隔でプロジェクトをファイルに自動的に保存します <pr...", 
"body" : "要件：プロジェクトは開いています。 クリック ツール → オプション そしてその ロードして保存する カテゴリー。 The ロードして保存 ダイアログが開きます。 をアクティブにします バックアップコピーを作成する オプション。 を選択 …分ごとに自動的に保存 オプションを選択し、時間間隔を選択します。 クリック わかった を閉じるには オプション ダイアログ。 プロジェクトが保存されるたびに、 CODESYS また、という名前のバックアップコピーを作成します <project name>.backup 。 CODESYS 指定された時間間隔でプロジェクトをファイルに自動的に保存します <project name>.autosave プロジェクトディレクトリにあります。開発システムが不定期に閉じられた後にプロジェクトを再度開くと、このファイルは、ユーザーが最後に保存したファイルの代わりに提供されます。 詳細については、以下を参照してください。 ダイアログ：オプション–ロードして保存 と プロジェクトの保護と保存" }, 
{ "title" : "プロジェクトアーカイブの保存\/送信 ", 
"url" : "_cds_saving_project_archive.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの保護と保存 \/ プロジェクトアーカイブの保存\/送信 ", 
"snippet" : "プロジェクトアーカイブを構成してファイルシステムに保存するか、電子メールで直接送信することができます。 送信するには、ポイント9まで以下のガイドに従ってください。そこでクリックします。 送信 代わりにボタン 保存する そこからデフォルトの電子メールプログラムを開きます。添付ファイルにプロジェクトアーカイブが含まれる新しいメールが自動的に作成されます。 要件：プロジェクトが開いています。 クリック ファイル→プロジェクトアーカイブ→アーカイブの保存\/送信 。 The プロジェクトアーカイブ ダイアログが開きます。 アーカイブに保存する各オブジェクトの横にあるチェックボックスを選択します。 ノウハ...", 
"body" : "プロジェクトアーカイブを構成してファイルシステムに保存するか、電子メールで直接送信することができます。 送信するには、ポイント9まで以下のガイドに従ってください。そこでクリックします。 送信 代わりにボタン 保存する そこからデフォルトの電子メールプログラムを開きます。添付ファイルにプロジェクトアーカイブが含まれる新しいメールが自動的に作成されます。 要件：プロジェクトが開いています。 クリック ファイル→プロジェクトアーカイブ→アーカイブの保存\/送信 。 The プロジェクトアーカイブ ダイアログが開きます。 アーカイブに保存する各オブジェクトの横にあるチェックボックスを選択します。 ノウハウ保護により、 CODESYS 保護されていない（つまり、「コンパイル済みライブラリ」ほど存在しない）ライブラリをプロジェクトアーカイブに自動的に受け入れません。含める情報のリストでこの種類のライブラリを明示的に選択すると、それぞれの警告が表示されます。 アーカイブにファイルを追加するには、をクリックします 追加ファイル 。 The 追加ファイル ダイアログが開きます。 クリック 追加 。 ファイルを選択してクリックします 開ける 。 ファイルは追加ファイルのリストに追加されます。 クリック わかった 。 クリック コメント 。 ダイアログ コメント 開きます。 コメントを入力してクリック わかった 。 クリック 保存する ボタン。 場所とファイル名を選択して、をクリックします 保存する 。 プロジェクトアーカイブはファイルディレクトリに保存されます。 詳細については、以下を参照してください。 コマンド：プロジェクトを名前を付けて保存 と プロジェクトの保存" }, 
{ "title" : "プロジェクトをソース管理システムにリンクする ", 
"url" : "_cds_keeping_project_in_sourcecode_management.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトの保護と保存 \/ プロジェクトをソース管理システムにリンクする ", 
"snippet" : "あなたをリンクするには CODESYS ソース管理システムへのプロジェクトでは、次のオプションを検討してください。 The CODESYS SVN アドオンは、SVNデータベースに直接リンクする機能を提供します。あなたはでパッケージを得ることができます CODESYS Store International パッケージマネージャーを使用してインストールします。 使用する場合は、対応するヘルプを参照してください CODESYS SVN 。...", 
"body" : "あなたをリンクするには CODESYS ソース管理システムへのプロジェクトでは、次のオプションを検討してください。 The CODESYS SVN アドオンは、SVNデータベースに直接リンクする機能を提供します。あなたはでパッケージを得ることができます CODESYS Store International パッケージマネージャーを使用してインストールします。 使用する場合は、対応するヘルプを参照してください CODESYS SVN 。 " }, 
{ "title" : "プロジェクトのローカライズ ", 
"url" : "_cds_struct_project_localization.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトのローカライズ ", 
"snippet" : "ローカリゼーションファイルを作成してリンクするときに、プロジェクトをさまざまな言語で表示できます。ローカリゼーションファイルは、 GNU gettext システム。ローカリゼーションテンプレートファイルの形式は* .pot（ポータブルオブジェクトテンプレート）であり、そこからローカリゼーションファイルが作成されます。 *.po （ポータブルオブジェクト）は、変換後に生成されます。 プロジェクトはさまざまな言語でローカライズできます。ただし、編集は元のバージョンでのみ可能です。 プロジェクトでローカライズされるテキスト情報のカテゴリを構成します。次に、これらのテキストを翻訳テンプレートにエクスポ...", 
"body" : "ローカリゼーションファイルを作成してリンクするときに、プロジェクトをさまざまな言語で表示できます。ローカリゼーションファイルは、 GNU gettext システム。ローカリゼーションテンプレートファイルの形式は* .pot（ポータブルオブジェクトテンプレート）であり、そこからローカリゼーションファイルが作成されます。 *.po （ポータブルオブジェクト）は、変換後に生成されます。 プロジェクトはさまざまな言語でローカライズできます。ただし、編集は元のバージョンでのみ可能です。 プロジェクトでローカライズされるテキスト情報のカテゴリを構成します。次に、これらのテキストを翻訳テンプレートにエクスポートします。このテンプレートは、ポット形式のファイルです（例： project_1.pot ）。ローカリゼーションファイルを次の形式で作成します *.po （例： de.po, en.po, es.po ）、対応する外部翻訳ツールを使用して自動的に、またはニュートラルテキストエディタを使用して手動で。 * .poファイルをにインポートして戻すことができます CODESYS ローカリゼーションに使用します。 プロジェクトのローカリゼーションを使用するためのコマンドは、 計画 → プロジェクトのローカリゼーション メニュー。 ローカリゼーションの切り替え、ローカリゼーションファイルの追加と削除 要件：必要なすべての言語は、対応するものをインポートすることによってプロジェクトに保存されます *.po ファイル。プロジェクトは開いています。 クリック プロジェクト→プロジェクトのローカリゼーション→ローカリゼーションの管理 。 The ローカリゼーションの管理 ダイアログが開きます。保存されているすべてのローカリゼーションファイル *-<language>.po に表示されます ファイル 、およびエントリ <オリジナルバージョン> 。 目的の言語を選択して、 スイッチのローカリゼーション ボタン。 プロジェクトは選択した言語で表示されます。選択した場合 <オリジナルバージョン> 、プロジェクトは元のローカライズされていないバージョンで表示され、編集できません。 オプション：デフォルトのローカリゼーションの定義、ローカリゼーションの切り替え 利用可能なローカリゼーションの1つを選択し、 デフォルトのローカリゼーション オプション。 クリック プロジェクト→プロジェクトのローカリゼーション→ローカリゼーションの切り替え ローカリゼーションをデフォルトのローカリゼーションと元のバージョンの間で切り替えます。デフォルトでは、このコマンドは次の方法でも使用できます。 ツールバーのボタン。 詳細については、以下を参照してください。 コマンド：ローカリゼーションを切り替えます と コマンド：ローカリゼーションを管理する " }, 
{ "title" : "ローカリゼーションテンプレートを作成する ", 
"url" : "_cds_struct_project_localization.html#UUID-994c8b2e-49d4-9de2-c694-8c1b4b85461a_id_b853c50bc4d5ff73c0a8640e009b2d8a_id_4fc598d1c536a795c0a8640e00012b41", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトのローカライズ \/ ローカリゼーションテンプレートを作成する ", 
"snippet" : "要件：プロジェクトが開いています。 クリック プロジェクト→プロジェクトのローカリゼーション→ローカリゼーションテンプレートの作成 。 The ローカリゼーションテンプレートの作成 ダイアログが開きます。 ローカリゼーションテンプレートに含める必要のあるテキスト情報のカテゴリをアクティブにします。 位置情報 テンプレートに含めることもできます。翻訳するテキストごとに、プロジェクト内でのテキストの場所を指定します。翻訳テンプレートに表示する位置を選択します。最初に見つかった位置のみ、見つかったすべての位置、またはなし。 クリック 生む ボタン。 保存するためのダイアログが開きます *.pot フ...", 
"body" : "要件：プロジェクトが開いています。 クリック プロジェクト→プロジェクトのローカリゼーション→ローカリゼーションテンプレートの作成 。 The ローカリゼーションテンプレートの作成 ダイアログが開きます。 ローカリゼーションテンプレートに含める必要のあるテキスト情報のカテゴリをアクティブにします。 位置情報 テンプレートに含めることもできます。翻訳するテキストごとに、プロジェクト内でのテキストの場所を指定します。翻訳テンプレートに表示する位置を選択します。最初に見つかった位置のみ、見つかったすべての位置、またはなし。 クリック 生む ボタン。 保存するためのダイアログが開きます *.pot ファイルシステムにファイルします。ローカリゼーションテンプレートを保存します。次に、翻訳ツールでファイルを処理し、ローカリゼーションファイルを生成できます <language>.po 必要な言語で。 " }, 
{ "title" : "ローカリゼーションテンプレートの形式：ファイル *.pot ", 
"url" : "_cds_struct_project_localization.html#UUID-994c8b2e-49d4-9de2-c694-8c1b4b85461a_id_b853c50bc4d5ff73c0a8640e009b2d8a_id_653b77f4c56ecbd9c0a8640e01a43f78", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトのローカライズ \/ ローカリゼーションテンプレートの形式：ファイル *.pot ", 
"snippet" : "最初の行では、テンプレートの生成時に翻訳用に選択されたテキストカテゴリが指定されています。 例：4つのカテゴリすべてが選択されました： #: Content:Comments|Identifiers|Names|Strings 次に、翻訳される各テキストは、次の例のような形式でセグメント化されます。 例 #: D:\\Projects\\p1.project\\Project_Settings:1 msgid \"Project Settings\" msgstr \"\" 1行目：ソースコード参照として表示される位置情報。翻訳ファイルの生成時にこれが構成されている場合にのみ表示されます。 2行目：未翻訳の...", 
"body" : "最初の行では、テンプレートの生成時に翻訳用に選択されたテキストカテゴリが指定されています。 例：4つのカテゴリすべてが選択されました： #: Content:Comments|Identifiers|Names|Strings 次に、翻訳される各テキストは、次の例のような形式でセグメント化されます。 例 #: D:\\Projects\\p1.project\\Project_Settings:1\nmsgid \"Project Settings\"\nmsgstr \"\" 1行目：ソースコード参照として表示される位置情報。翻訳ファイルの生成時にこれが構成されている場合にのみ表示されます。 2行目：未翻訳のテキストをエントリとして msgid （例： msgid \"Project Settings\" ）。 3行目：翻訳のプレースホルダー： msgstr \"\" 。一重引用符の間で、 *.po ファイルはそれぞれの言語で挿入する必要があります。 " }, 
{ "title" : "ローカリゼーションファイルの形式： *-<language>.po ", 
"url" : "_cds_struct_project_localization.html#UUID-994c8b2e-49d4-9de2-c694-8c1b4b85461a_id_b853c50bc4d5ff73c0a8640e009b2d8a_id_659fed17c536a796c0a8640e017333a5", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトのローカライズ \/ ローカリゼーションファイルの形式： *-<language>.po ", 
"snippet" : "あなたは生成することができます *.po 翻訳ツールを使用してファイルを作成するか、に基づいてニュートラルテキストエディタを使用してファイルを作成します。 *.pot ファイル。この目的のために、ファイル拡張子をから変更することができます *.pot に *.po に従って編集します *.po 標準フォーマット。 ファイルのメタデータで通常のロケールコードの形式で言語を指定することが不可欠です（例： \"Language: de\" ドイツ語の場合。次に、個々のテキストの翻訳を、の直線引用符の間に挿入します。 msgstr \"\" エントリ。 例 \"Language: de\\n\" #: Conten...", 
"body" : "あなたは生成することができます *.po 翻訳ツールを使用してファイルを作成するか、に基づいてニュートラルテキストエディタを使用してファイルを作成します。 *.pot ファイル。この目的のために、ファイル拡張子をから変更することができます *.pot に *.po に従って編集します *.po 標準フォーマット。 ファイルのメタデータで通常のロケールコードの形式で言語を指定することが不可欠です（例： \"Language: de\" ドイツ語の場合。次に、個々のテキストの翻訳を、の直線引用符の間に挿入します。 msgstr \"\" エントリ。 例 \"Language: de\\n\"\n#: Content:Names\n#: D:\\projects\\p1.project\\Project_Settings:1\nmsgid \"Project Settings\"\nmsgstr \"Projekteinstellungen\" " }, 
{ "title" : "ローカリゼーションファイルのインポート\/プロジェクトのローカライズ ", 
"url" : "_cds_struct_project_localization.html#UUID-994c8b2e-49d4-9de2-c694-8c1b4b85461a_id_b853c50bc4d5ff73c0a8640e009b2d8a_id_aa02f6d3c536a798c0a8640e01fb3258", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトのローカライズ \/ ローカリゼーションファイルのインポート\/プロジェクトのローカライズ ", 
"snippet" : "要件：プロジェクトの場合、ローカリゼーションファイル（ <language>.po ）翻訳テンプレートに基づいて生成されました *.pot 。プロジェクトは開いています。 クリック プロジェクト→プロジェクトのローカリゼーション→ローカリゼーションの管理 。 クリック 追加 ボタン。 The ローカリゼーションファイルを開く を選択するためのダイアログが表示されます *.po ファイルシステムからのファイル。 ローカリゼーションファイルの1つを選択します（例： <project name>-de.po ）。 ダイアログが閉じ、影響を受けるテキストがそれぞれの言語でプロジェクトに表示されます。た...", 
"body" : "要件：プロジェクトの場合、ローカリゼーションファイル（ <language>.po ）翻訳テンプレートに基づいて生成されました *.pot 。プロジェクトは開いています。 クリック プロジェクト→プロジェクトのローカリゼーション→ローカリゼーションの管理 。 クリック 追加 ボタン。 The ローカリゼーションファイルを開く を選択するためのダイアログが表示されます *.po ファイルシステムからのファイル。 ローカリゼーションファイルの1つを選択します（例： <project name>-de.po ）。 ダイアログが閉じ、影響を受けるテキストがそれぞれの言語でプロジェクトに表示されます。たとえば、翻訳を指定した場合 msgstr \"Main program\" 英語のローカリゼーションファイルのPOU名「PLC_PRG」の場合、オブジェクト名「メインプログラム」がデバイスツリーに表示されます。 同様に、他の言語ターゲットのローカリゼーションファイルをインポートします。 " }, 
{ "title" : "プロジェクトテンプレートの作成 ", 
"url" : "_cds_create_project_template.html", 
"breadcrumbs" : "CODESYS Essentials \/ プロジェクトテンプレートの作成 ", 
"snippet" : "独自のプロジェクトテンプレートを作成することができます。 テンプレート の面積 新しいプロジェクト 新しいプロジェクトを作成するときのダイアログ（ *.project または *.library ）。プロジェクトテンプレートを以下のどれかに含めるかどうかも定義できます。 プロジェクト そして 図書館 ダイアログにデフォルトで表示されるフォルダ、または自分で作成したフォルダ。これらのフォルダは 新しいプロジェクト ダイアログの カテゴリー エリア。 で CODESYS Development System 他のプロジェクトのテンプレートとして使用するプロジェクトを作成します。 プロジェクトを T...", 
"body" : "独自のプロジェクトテンプレートを作成することができます。 テンプレート の面積 新しいプロジェクト 新しいプロジェクトを作成するときのダイアログ（ *.project または *.library ）。プロジェクトテンプレートを以下のどれかに含めるかどうかも定義できます。 プロジェクト そして 図書館 ダイアログにデフォルトで表示されるフォルダ、または自分で作成したフォルダ。これらのフォルダは 新しいプロジェクト ダイアログの カテゴリー エリア。 で CODESYS Development System 他のプロジェクトのテンプレートとして使用するプロジェクトを作成します。 プロジェクトを Templates インストールディレクトリのフォルダ CODESYS 。 テキストエディタで新しいテンプレートファイルを作成します <template name>.template 。 次のサンプル ファイルに従ってこのファイルを編集します。 <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<ProjectTemplate>\t\n <Name>\t\n <DefaultString>Test_Project_Template<\/DefaultString>\t\n <LocalizedString Culture=\"de\">Test_Projekttemplate<\/LocalizedString>\t\n <\/Name>\t\n\n <Folder>\t\t\n <DefaultString>Projects<\/DefaultString>\t\t\n <LocalizedString Culture=\"de\">Projekte<\/LocalizedString>\t\n <\/Folder>\t\n\n <Description>\n\t<DefaultString>A project with a GVL<\/DefaultString>\t\n\t<LocalizedString Culture=\"de\">Ein Projekt mit einer GVL<\/LocalizedString>\t\n <\/Description>\t\n\n <DefaultFileName>\t\t\n <DefaultString>Test Project<\/DefaultString>\t\t\n <LocalizedString Culture=\"de\">Testprojekt<\/LocalizedString>\t\n <\/DefaultFileName>\t\n\n <Extension>.project<\/Extension>\t\n <TemplatePath>TemplateTest.project<\/TemplatePath>\n<\/ProjectTemplate> さまざまなタグの内容: Name : プロジェクトテンプレートの名前。 テンプレート の面積 新しいプロジェクト ダイアログ。 Folder : プロジェクトテンプレートが保存されているフォルダの名前。 カテゴリー の面積 新しいプロジェクト ダイアログ。 存在しないフォルダーの名前を指定すると、その名前の新しいフォルダーが作成されます。 Description : プロジェクトテンプレートの説明 説明は 新しいプロジェクト テンプレートが選択されたときのダイアログ。 DefaultFileName : 新しいプロジェクトのデフォルト名。名前は 名前 の分野 新しいプロジェクト ダイアログが表示され、そこで編集できます。 Extension : .project : このテンプレートは、 CODESYS プロジェクト .project 。 .library : このテンプレートはライブラリプロジェクトを作成するために使用されます .library 。 TemplatePath : テンプレートプロジェクトのファイルパス ..\/Templates のインストールディレクトリの CODESYS 例: TemplateTest.project : の TemplateTest.project テンプレートプロジェクトは ..\/Templates ディレクトリ。 Library_Template\/CODESYS_Template.library : の CODESYS_Template.library テンプレートプロジェクトは ..\/Templates\/Library_Template ディレクトリ。 のテキストが CODESYS の言語で表示される必要があります CODESYS インターフェースで翻訳をタグに追加し、 LocalizedString (上記の例を参照)。 作成したテンプレートファイルを保存します（ .template ）に保存し、 ..\/Templates インストールディレクトリのフォルダー。 開くと CODESYS クリック ファイル → 新しいプロジェクト 作成したプロジェクトテンプレートは、 新しいプロジェクト 新しいプロジェクトのダイアログ。 " }, 
{ "title" : "I \/ Oリンクの構成 ", 
"url" : "_cds_struct_io_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 ", 
"snippet" : "デバイスオブジェクトの助けを借りて、ハードウェアをマップして、のツリー構造で制御することができます。 CODESYS 事業。これにより、ハードウェアとアプリケーションのリンクが扱いやすくなります。 デバイスオブジェクトの設定エディタで、間の通信の設定を構成できます CODESYS とコントローラー、そしてとりわけI \/ Oマッピング用。 I \/ Oマッピングは、コントローラーの入力と出力をアプリケーションの変数にリンクすることです。 実行時の制御オブジェクトへのアクセスは、デバイスに応じて、「オンラインユーザー管理」を介して制御できます。これは、デバイスに応じて、で編集できます。 CODESY...", 
"body" : "デバイスオブジェクトの助けを借りて、ハードウェアをマップして、のツリー構造で制御することができます。 CODESYS 事業。これにより、ハードウェアとアプリケーションのリンクが扱いやすくなります。 デバイスオブジェクトの設定エディタで、間の通信の設定を構成できます CODESYS とコントローラー、そしてとりわけI \/ Oマッピング用。 I \/ Oマッピングは、コントローラーの入力と出力をアプリケーションの変数にリンクすることです。 実行時の制御オブジェクトへのアクセスは、デバイスに応じて、「オンラインユーザー管理」を介して制御できます。これは、デバイスに応じて、で編集できます。 CODESYS Development System 。また、コントローラーとの通信は、現在の「セキュリティ設定」に依存します。 " }, 
{ "title" : "デバイスツリーとデバイスエディタ ", 
"url" : "_cds_device_tree_device_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスツリーとデバイスエディタ ", 
"snippet" : "デバイスエディタ 間の通信の設定を行うことができます CODESYS およびのタブにあるターゲットデバイス デバイスエディタ 。デバイスツリーでデバイスオブジェクトをダブルクリックして、エディタを開きます。 エディターには、一般的なタブと特定のタブが含まれています。そのタイトルにはデバイス名が含まれています。 詳細については、以下を参照してください。 デバイスとI \/ Oマッピングの構成...", 
"body" : "デバイスエディタ 間の通信の設定を行うことができます CODESYS およびのタブにあるターゲットデバイス デバイスエディタ 。デバイスツリーでデバイスオブジェクトをダブルクリックして、エディタを開きます。 エディターには、一般的なタブと特定のタブが含まれています。そのタイトルにはデバイス名が含まれています。 詳細については、以下を参照してください。 デバイスとI \/ Oマッピングの構成" }, 
{ "title" : "デバイスツリー ", 
"url" : "_cds_device_tree_device_editor.html#UUID-7bc193e4-b97a-a4e3-f11d-5776c956d246_id_e039ebc3920863bc0a8640e01ade420_id_855d3ce2ce443b2fc0a8640e00ffb1ef", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスツリーとデバイスエディタ \/ デバイスツリー ", 
"snippet" : "の中に デバイス ビュー（「デバイスツリー」とも呼ばれます）では、ターゲットデバイスに従ってアプリケーションを整理します。このビューでは、PLCハードウェアおよびフィールドバスシステムを確認し、ハードウェア通信を構成し、アプリケーションを割り当てることができます。 デバイスツリーのルートノードは、シンボリックノードエントリです。 <プロジェクト名> 。 「ターゲットシステム」とも呼ばれる1つまたは複数のPLCの場合、このノードの下にデバイスオブジェクトを挿入します。各デバイスオブジェクトは、特定のハードウェアコンポーネント（コントローラー、フィールドバス、バスカプラー、ドライブ、I \/ Oモジ...", 
"body" : "の中に デバイス ビュー（「デバイスツリー」とも呼ばれます）では、ターゲットデバイスに従ってアプリケーションを整理します。このビューでは、PLCハードウェアおよびフィールドバスシステムを確認し、ハードウェア通信を構成し、アプリケーションを割り当てることができます。 デバイスツリーのルートノードは、シンボリックノードエントリです。 <プロジェクト名> 。 「ターゲットシステム」とも呼ばれる1つまたは複数のPLCの場合、このノードの下にデバイスオブジェクトを挿入します。各デバイスオブジェクトは、特定のハードウェアコンポーネント（コントローラー、フィールドバス、バスカプラー、ドライブ、I \/ Oモジュール、モニターなど）を表します。オブジェクトを追加する場合、追加アシスタントは、ローカルデバイスリポジトリから可能なすべてのデバイスを提供することで役立ちます。 すでにコントローラーネットワークに接続している場合は、ハードウェアをスキャンして使用可能なデバイスを探し、現在の構成のデバイスツリーに保存できます。 デバイスツリーにデバイスオブジェクトを作成する（制御ハードウェア環境にマッピングする）には、特定のルールが適用されます（以下を参照）。アプリケーションオブジェクトとデバイスオブジェクトの階層レイアウトは、ライブラリやGVLなどの他のオブジェクトのスコープを定義しました。 プログラマブルデバイスと厳密にパラメータ化可能なデバイスがあります。デバイスタイプは、デバイスツリーで可能な挿入ポイントと、デバイスの下に挿入できるオブジェクトの選択を定義します。プログラマブルデバイスは自動的に追加を取得します PLCロジック デバイスオブジェクトの下のノード。これは厳密に組織的な目的のためです。このノードの下に、デバイスのプログラミングに必要なオブジェクトを挿入します（これは、たとえば、アプリケーションとGVLまたはテキストリストを意味します）。 各デバイスはデバイスの説明によって定義され、デバイスツリーに挿入するにはローカルシステムにインストールする必要があります。デバイス記述ファイルは、構成可能性、プログラム可能性、および他のデバイスへの可能な接続のためのデバイスプロパティを定義します。 The POU ビューには、プロジェクト全体で使用できるオブジェクトが含まれています。特定のアプリケーションを対象としたプログラミングオブジェクトは、アプリケーションオブジェクトの下に挿入する必要があります。 デバイス ビュー（デバイスツリー）。 アクティブなアプリケーションを「シミュレートされたデバイス」で実行させるオプションに注意してください。これは、開発システム内でデフォルトで提供されます。現在、このシミュレーションオプションは CODESYS Control Win ターゲットシステム。シミュレーションモードでは、ハードウェアなしでアプリケーションのオンライン機能をテストすることもできます。クリック オンライン→シミュレーション シミュレーションモードを有効にします。 を使用してデバイスへの接続を確立するオプションに注意してください オンライン構成モード 事前にアプリケーションをロードしなくても、アプリケーションのコマンド。これは、実際のアプリケーションをプログラムしてダウンロードする前に、PLC構成でI \/ Oを参照およびテストできるため、I \/ Oシステムの初期試運転に役立ちます。 デバイスツリーの例： (1) プログラマブルデバイス（アプリケーション付き） (2) シンボリックデバイス名 (3) デバイスの種類 (デバイスの説明で定義) (4) 純粋にパラメータ化可能なデバイス デバイスツリーのデバイスエントリは、シンボル、ツリーで編集可能なシンボルデバイス名、およびデバイスタイプ (デバイスの説明で定義されているデバイス名) で構成されます。 バスサイクル設定のあるすべてのデバイスと、任意の数のバスサイクルタスクに使用されるタスクには、次のマークも付いています。 シンボル。この記号の付いたタスクとデバイスのツールチップも表示されます。タスクの場合、ツールチップには使用されているデバイスが表示されます。デバイスの場合、ツールチップにはタスクが表示されます。 デバイスの通信、パラメータ、およびIOマッピングは、のダイアログで構成します。 デバイスエディタ 。デバイスオブジェクトをダブルクリックして、このエディタを開きます。 " }, 
{ "title" : "デバイスツリーでオブジェクトを配置および構成するためのルールと手順 ", 
"url" : "_cds_device_tree_device_editor.html#UUID-7bc193e4-b97a-a4e3-f11d-5776c956d246_id_e039ebc3920863bc0a8640e01ade420_id_67d7c878777219b2c0a8640e01e97928", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスツリーとデバイスエディタ \/ デバイスツリーでオブジェクトを配置および構成するためのルールと手順 ", 
"snippet" : "デバイスツリーでオブジェクトを配置および構成するためのルールと手順 オブジェクトの挿入 デバイスオブジェクトを挿入するには、をクリックします デバイスを追加 また デバイスを挿入 デバイスツリーを右クリックします。その他のオブジェクトについては、 オブジェクトの追加 。 CODESYS ツリー内で現在選択されている位置に適切なオブジェクトを常に提供します。例：PROFIBUS DPスレーブのモジュールは、それぞれのスレーブオブジェクトの下にのみ挿入でき、アプリケーションはプログラマブルデバイスの下にのみ挿入できます。デバイスオブジェクトの選択は、デバイスリポジトリにインストールされているデバイ...", 
"body" : "デバイスツリーでオブジェクトを配置および構成するためのルールと手順 オブジェクトの挿入 デバイスオブジェクトを挿入するには、をクリックします デバイスを追加 また デバイスを挿入 デバイスツリーを右クリックします。その他のオブジェクトについては、 オブジェクトの追加 。 CODESYS ツリー内で現在選択されている位置に適切なオブジェクトを常に提供します。例：PROFIBUS DPスレーブのモジュールは、それぞれのスレーブオブジェクトの下にのみ挿入でき、アプリケーションはプログラマブルデバイスの下にのみ挿入できます。デバイスオブジェクトの選択は、デバイスリポジトリにインストールされているデバイスにも依存します。 オブジェクトの名前には、次の推奨事項とルールが適用されます。 80 文字のサイズを超えないようにしてください。80 文字を超えるとコンパイラの警告が生成されます。 英数字とアンダースコアのみが許可されます。 最初の文字は文字またはアンダースコアである必要があります。 だけ可能です デバイスオブジェクトを挿入します 真下のレベルで <プロジェクト名> ルートノード。テキストリストなどの別のオブジェクトタイプを選択した場合は、 CODESYS これを自動的にに挿入します POU ビュー（プロジェクト-グローバルプール）。 アプリケーションの挿入 あなたは挿入することができます 応用 下のオブジェクトのみ PLCロジック ノード（プログラム可能なデバイス）。すべてのアプリケーションには、デバイスごとに一意の名前を付ける必要があります。各アプリケーションの下に、POU、DUT、GVL、視覚化など、プログラミングに必要なオブジェクトをさらに挿入できます。 各アプリケーションの下に、タスク構成を挿入し、それぞれのプログラム呼び出しを構成する必要があります（アプリケーション固有のPOU、またはからのPOU「インスタンス」から） POU 見る）。 デバイスのすぐ下に複数のアプリケーションが存在する場合は、デバイスのI \/ O処理の設定を定義する必要があります。これには、アプリケーションの変数が含まれます。 CODESYS ターゲットシステムとの通信に使用します。設定はで構成されます PLC設定 デバイスエディタのタブ。 アプリケーションとスコープの階層レイアウト：別のアプリケーションの下にアプリケーションを追加できます。結果の構成に「親アプリケーション」–「子アプリケーション」という名前を付けます。この場合、以下が適用されます。子アプリケーションは親アプリケーションのオブジェクトにアクセスできますが、他の方向にはアクセスできません。この理由は、子アプリケーションは、親アプリケーションに影響を与えることなく、常にリムーバブルまたは交換可能である必要があるためです。 ノート 親アプリケーションが変更された後、オンライン変更が実行されると、子アプリケーションがコントローラーから削除されます。 デバイスを挿入します CODESYS デバイスオブジェクトをノードとしてツリーに挿入します。デバイスの説明でノードが定義されている場合、ノードは自動的に挿入されます。サブノードは、プログラム可能なデバイスを表すこともできます。ツリー内のデバイスオブジェクトの順序（上から下へ）：各レベルについて、プログラマブルデバイス（PLCロジック）が最初にリストされ、次に他のタイプがアルファベット順にリストされます。 デバイスを更新する デバイスツリーに挿入されたデバイスは、同じデバイスの別のバージョンまたは別のタイプのデバイスに置き換えることができます（ デバイスを更新する ）。可能な場合は、デバイスの下の構成ツリーを使用できます。 オブジェクトの移動と削除 標準コマンドを使用できます 切る 、 コピー 、 ペースト 、 と 消去 オブジェクト上で、またはオブジェクトを別の位置にドラッグします。オブジェクトをコピーすると、新しいオブジェクトは同じ名前になり、番号が増加します。 （現在のハードウェアの）ネットワークスキャン デフォルトでは、デバイスツリーでのPLC構成の作成は、スキャン機能を備えたデバイスエディタでサポートされています。現在のハードウェア環境がスキャンされ、検出されたモジュールがダイアログに表示されます。そこから、必要なデバイスをデバイスツリーに直接保存できます。を参照してください スキャンデバイス 指図。 詳細については、以下を参照してください。 デバイスツリーでのハードウェア構造のマッピング" }, 
{ "title" : "オンラインモードのデバイスツリー ", 
"url" : "_cds_device_tree_device_editor.html#UUID-7bc193e4-b97a-a4e3-f11d-5776c956d246_id_e039ebc3920863bc0a8640e01ade420_id_1bf1cadc777219b4c0a8640e00127639", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスツリーとデバイスエディタ \/ オンラインモードのデバイスツリー ", 
"snippet" : "オンラインモードでは、デバイスエントリの前の記号はデバイスのステータスを示します。 ：PLCが接続され、アプリケーションが実行され、デバイスが動作しており、データが交換されています。 The 停止中のI \/ Oを更新 のチェックボックス PLC設定 タブを選択またはクリアできます。 ：PLCが接続され、 止まる ;そしてその 停止中のI \/ Oを更新 のチェックボックス PLC設定 タブがクリアされます。 ：デバイスはデータを交換していません。バスエラー、構成なし、またはシミュレーションモード。 ：デバイスはトライアルモードで30分間実行されています。この時間が経過すると、トライアルモードは終...", 
"body" : "オンラインモードでは、デバイスエントリの前の記号はデバイスのステータスを示します。 ：PLCが接続され、アプリケーションが実行され、デバイスが動作しており、データが交換されています。 The 停止中のI \/ Oを更新 のチェックボックス PLC設定 タブを選択またはクリアできます。 ：PLCが接続され、 止まる ;そしてその 停止中のI \/ Oを更新 のチェックボックス PLC設定 タブがクリアされます。 ：デバイスはデータを交換していません。バスエラー、構成なし、またはシミュレーションモード。 ：デバイスはトライアルモードで30分間実行されています。この時間が経過すると、トライアルモードは終了し、フィールドバスはデータ交換を終了します。 ：デバイスは構成されていますが、完全には機能していません。データは交換されません。例：起動時および術前モードのCANopenデバイス。 ：冗長モードがアクティブです。別のマスターがアクティブであるため、フィールドバスマスターはデータを送信していません。 ：デバイスの説明がデバイスリポジトリに見つかりませんでした。 ：デバイス自体は実行されていますが、子デバイスが実行されていないか、診断メッセージがあります。デバイスツリーが折りたたまれているため、子デバイスは表示されません。 ：灰色の感嘆符：診断は保留中です。ただし、エラーの原因は存在しないか、解決されています。この記号は、このリストの他のさまざまな記号と関連して表示される場合があります。 ：赤い感嘆符：デバイスが実行されていないか、診断が保留中です。エラーの原因はまだ存在します。この記号は、このリストの他のさまざまな記号と関連して表示される場合があります。 接続されているすべてのデバイスとアプリケーションの名前が緑色で強調表示されます。 シミュレーションモードで実行されているデバイスの名前は、イタリック体で表示されます。 。 追加の診断情報は、 状態 それぞれのデバイスエディタのタブ。 ターゲットデバイスのデバイスの説明がプロジェクトよりも新しいときにログインすると、警告プロンプトが開き、プロセスをキャンセルする可能性があります。 詳細については、以下を参照してください。 コマンド：診断の確認、サブツリーの診断の確認 と PLCへのアプリケーションのダウンロード" }, 
{ "title" : "POU の色の意味 ", 
"url" : "_cds_device_tree_device_editor.html#UUID-7bc193e4-b97a-a4e3-f11d-5776c956d246_section-idm234735523635194", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスツリーとデバイスエディタ \/ POU の色の意味 ", 
"snippet" : "デバイスツリーの POU の名前は、異なる色で表示されることがあります。 色には以下の意味があります。 黒:既定の色。特に意味はありません。 グレー:コード生成後に表示され、POU がプロジェクトで使用されていないことを示します 青:コード生成後、およびプロジェクトがすでに 1 回ダウンロードされた場合に表示されます。POU はコントローラの POU と比べて変わっており、次回のダウンロードに含まれます 青緑:POU には ビルドから除外 プロパティセット。...", 
"body" : "デバイスツリーの POU の名前は、異なる色で表示されることがあります。 色には以下の意味があります。 黒:既定の色。特に意味はありません。 グレー:コード生成後に表示され、POU がプロジェクトで使用されていないことを示します 青:コード生成後、およびプロジェクトがすでに 1 回ダウンロードされた場合に表示されます。POU はコントローラの POU と比べて変わっており、次回のダウンロードに含まれます 青緑:POU には ビルドから除外 プロパティセット。 " }, 
{ "title" : "デバイスツリーでのハードウェア構造のマッピング ", 
"url" : "_cds_mapping_hardware_in_device_tree.html", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスツリーでのハードウェア構造のマッピング ", 
"snippet" : "制御するハードウェアをアプリケーションでマッピングします。 デバイス ビュー（デバイスツリー）。これを行うには、階層がコントローラーネットワークを反映するまで、ネットワーク内の物理デバイスを表すデバイスオブジェクトをこのツリー構造に挿入します。デバイスオブジェクトは、たとえば、PLCオブジェクト、フィールドバスオブジェクト、または論理デバイスです。...", 
"body" : "制御するハードウェアをアプリケーションでマッピングします。 デバイス ビュー（デバイスツリー）。これを行うには、階層がコントローラーネットワークを反映するまで、ネットワーク内の物理デバイスを表すデバイスオブジェクトをこのツリー構造に挿入します。デバイスオブジェクトは、たとえば、PLCオブジェクト、フィールドバスオブジェクト、または論理デバイスです。 " }, 
{ "title" : "デバイスツリーのフィールドバスを使用した標準コントローラのマッピング ", 
"url" : "_cds_mapping_hardware_in_device_tree.html#UUID-ae97416f-7f9b-10e7-4389-bfe2604cc6e5_id_f9c9ce5177757233c0a8640e003c07f9_id_b09bd7f45a802de8c0a8640e0116665b", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスツリーでのハードウェア構造のマッピング \/ デバイスツリーのフィールドバスを使用した標準コントローラのマッピング ", 
"snippet" : "以下に、標準のPLCと標準のフィールドバスを含むハードウェアをマップします。 クリック ファイル→新規プロジェクト 。 の中に 新しいプロジェクト ダイアログで、 標準プロジェクト レンプレート。 の中に 標準プロジェクト ダイアログで、 CODESYS Control Win 端末。 CODESYS を挿入します Device （（ CODESYS Control Win ）ルートノードの下とその下のデバイスツリー内のオブジェクト PLCロジック ノード。常にプログラム可能なデバイスオブジェクトを提供します。アン 応用 その下にオブジェクトが存在し、 ライブラリマネージャー 、 PLC_PR...", 
"body" : "以下に、標準のPLCと標準のフィールドバスを含むハードウェアをマップします。 クリック ファイル→新規プロジェクト 。 の中に 新しいプロジェクト ダイアログで、 標準プロジェクト レンプレート。 の中に 標準プロジェクト ダイアログで、 CODESYS Control Win 端末。 CODESYS を挿入します Device （（ CODESYS Control Win ）ルートノードの下とその下のデバイスツリー内のオブジェクト PLCロジック ノード。常にプログラム可能なデバイスオブジェクトを提供します。アン 応用 その下にオブジェクトが存在し、 ライブラリマネージャー 、 PLC_PRG 、 と タスク構成 その下にオブジェクトが存在します。 を選択 Device 入力してクリックします デバイスを追加 コンテキストメニューで。 The デバイスを追加 ダイアログは、システムにインストールされているデバイスの選択を提供します。 「システムにインストールされている」とは、 CODESYS それぞれのハードウェアのデバイスの説明を受け取りました。その結果、プロジェクトでデバイスオブジェクトと関連する構成エディターを使用できます。 提供されているPLCの1つを選択します（例： CANバス ）をクリックし、 デバイスを追加 ボタン。 The CANバス オブジェクトは、下にインデントされたデバイスツリーに表示されます Device （（ CODESYS ）。 The デバイスを追加 ダイアログは開いたままです。今、あなたが新しいを選択すると CANバス エントリ、それは自動的にその下に挿入可能なオブジェクトを提供します。 たとえば、 CANopenデバイス から ローカルデバイス カテゴリー。 CANopen_Device 下にインデントされて挿入されます CANバス デバイスツリー内。 以前に追加したデバイスに別のデバイスを追加しますか？デバイスエントリを選択して、をクリックします デバイスの更新 コンテキストメニューで。 The デバイスの更新 ダイアログが開きます。に対応します デバイスを追加 以前に使用したダイアログ。別のデバイスを選択すると、前のデバイスの代わりにツリーに挿入されます。 " }, 
{ "title" : "現在のハードウェアをスキャンし、デバイスをプロジェクトに適用する ", 
"url" : "_cds_mapping_hardware_in_device_tree.html#UUID-ae97416f-7f9b-10e7-4389-bfe2604cc6e5_id_f9c9ce5177757233c0a8640e003c07f9_id_00318a175a802de8c0a8640e017d9869", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスツリーでのハードウェア構造のマッピング \/ 現在のハードウェアをスキャンし、デバイスをプロジェクトに適用する ", 
"snippet" : "ハードウェア環境のネットワーク内のデバイスを特定（スキャン）し、見つかったデバイスをプロジェクトのデバイスツリーに適用できます。 スキャン機能がPLCに恒久的に実装されている場合は、追加の準備なしでスキャンを実行できます。この目的のために、 CODESYS コントローラへの一時的な接続を確立します。ライブラリにスキャン機能がある場合は、ライブラリを含むデバイスをデバイスツリーに挿入し、コントローラへのログインを実行する必要があります。その後、ライブラリをコントローラに配置して、スキャンを可能にします。 スキャンは、 デバイスをスキャンする 指図。これは、デバイスツリーで現在選択され、プロジェク...", 
"body" : "ハードウェア環境のネットワーク内のデバイスを特定（スキャン）し、見つかったデバイスをプロジェクトのデバイスツリーに適用できます。 スキャン機能がPLCに恒久的に実装されている場合は、追加の準備なしでスキャンを実行できます。この目的のために、 CODESYS コントローラへの一時的な接続を確立します。ライブラリにスキャン機能がある場合は、ライブラリを含むデバイスをデバイスツリーに挿入し、コントローラへのログインを実行する必要があります。その後、ライブラリをコントローラに配置して、スキャンを可能にします。 スキャンは、 デバイスをスキャンする 指図。これは、デバイスツリーで現在選択され、プロジェクトにリンクされているコントローラーを指します。たとえば、挿入されたPROFINET IOコントローラを選択し、コマンドを使用して、それに割り当てられているI \/ OデバイスとI \/ Oモジュールを決定できます。 要件：プロジェクトにデバイス構成があります。通信設定は正しいです。ゲートウェイとハードウェアが実行されています。 デバイスツリーでコントローラーオブジェクトを選択します。 コンテキストメニューで、をクリックします デバイスをスキャンする 。 CODESYS ハードウェアへの接続を確立します。 The デバイスをスキャンする ダイアログが開きます。デバイスの種類に応じて、さまざまな機能を提供します。ただし、ハードウェアで検出されたデバイス（デバイス名、デバイスのタイプ、ステーション名など）を示すテーブルが常に表示されます。これについて詳しくは、それぞれのデバイスエディターのヘルプを参照してください。 プロジェクトのデバイス構成にまだ含まれていない、見つかったデバイスのみがリストに表示されるようにするには、[ プロジェクトとの違いを示す オプション。 プロジェクトのデバイスツリーにデバイスを適用するには、テーブルのエントリを選択して、[ プロジェクトにコピー ボタン。エントリを選択しない場合、見つかったすべてのデバイスが適用されます。 対応するエントリがデバイスツリーに挿入されます。 " }, 
{ "title" : "の助けを借りてコントローラ構成をチェックする オンライン構成モード 指図 ", 
"url" : "_cds_mapping_hardware_in_device_tree.html#UUID-ae97416f-7f9b-10e7-4389-bfe2604cc6e5_section-idm53263079816560", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスツリーでのハードウェア構造のマッピング \/ の助けを借りてコントローラ構成をチェックする オンライン構成モード 指図 ", 
"snippet" : "と CODESYS コントローラの実際のアプリケーションを開発して事前にコントローラにロードしなくても、ターゲットシステムのI \/ Oとフィールドバスの正しい配線をテストできます。これは、最初の試運転段階では興味深いものです。これには「シンプルオンライン設定モード」を使用します。アプリケーションがコントローラーにすでに存在する場合、デバイスがこれをサポートしていれば、オプションとして「高度なオンライン構成モード」を使用することもできます。これにより、影響を受けるアプリケーションにログインしなくても、デバイスパラメータを読み取ることができます。 CODESYS 。 シンプルなオンライン設定モード...", 
"body" : "と CODESYS コントローラの実際のアプリケーションを開発して事前にコントローラにロードしなくても、ターゲットシステムのI \/ Oとフィールドバスの正しい配線をテストできます。これは、最初の試運転段階では興味深いものです。これには「シンプルオンライン設定モード」を使用します。アプリケーションがコントローラーにすでに存在する場合、デバイスがこれをサポートしていれば、オプションとして「高度なオンライン構成モード」を使用することもできます。これにより、影響を受けるアプリケーションにログインしなくても、デバイスパラメータを読み取ることができます。 CODESYS 。 シンプルなオンライン設定モード あなたは使用することができます オンライン構成モード 暗黙的なアプリケーションを作成するために、デバイスツリーのPLCオブジェクトのコンテキストメニューでコマンドを実行します。 CODESYS アプリケーションをPLCに自動的にダウンロードし、アプリケーションを使用してすべてのI \/ Oを一度に自動的に初期化します。アプリケーションの名前は HiddenOnlineConfigModeApp 。 PLCのデバイスエディタに表示されます。 アプリケーション タブ。これを使用して、通常のオンラインモードと同様に次の機能でI \/ Oを操作できます。 I \/ Oを読む 出力を書き込む 診断（ツリーおよびステータスページ） （現在のハードウェアの）スキャン サポートされている場合は、インタラクティブなオンライン機能（たとえば、非同期メッセージの書き込み） I \/ Oマッピングでの書き込みと強制 オンライン構成モードでは、値の書き込みと強制 I \/ Oマッピング ダイアログの動作は、実際のオンラインモードでの動作とは異なります。 CODESYS 挿入された直後に出力をI \/ Oマッピングテーブルに書き込みます。ありません 準備された価値 桁。代わりに、ダブルクリックした直後に初期値を変更します。 現在の価値 桁。 シンプルなオンライン構成モードを使用してI \/ Oアクセスをテストする 要件：I \/ Oマッピングを構成したデバイス構成で標準プロジェクトを作成している。プログラムPOUでは、ハードウェアの配線をチェックするために、ハードウェアの入力または出力に読み取りまたは書き込みアクセスを行います。ハードウェアのPLCへの接続は通信設定で構成されます。 PLCが稼働しています。 デバイスツリーでPLCオブジェクトを選択します。 たとえば、 CODESYS Control Win デバイスがデバイスツリーで選択されています。 コンテキストメニューで、をクリックします オンライン構成モード 。 CODESYS コントローラに接続し、ツリー内のPLCオブジェクトに緑色の背景が表示されます。 デバイスツリーで、PLCオブジェクトをダブルクリックしてデバイスエディタを開きます。を選択 アプリケーション タブ。 クリック リストを更新 ボタン。 The HiddenOnlineConfigModeApp アプリケーションはに表示されます PLC上のアプリケーション 窓。 プログラムを起動し、入力と出力の動作を確認します。 高度なオンライン設定モード（パラメータモード） 実際のアプリケーションがすでにコントローラーに存在し、デバイスが「高度なオンライン構成モード」をサポートしている場合は、オプションとして、「パラメーターモード」の後に「パラメーターモード」を選択することもできます。 オンライン構成モード 指図。次に、標準のログインを実行せずに、コントローラー上の実際のアプリケーションのパラメーターを読み取ることができます。コンパイル情報が欠落している場合は、このアプリケーションを再度ダウンロードする必要があります。あなたは上のパラメータを見ることができます 構成 デバイスエディタのタブ。パラメーターモードは、コントローラー上のデータを誤って変更することを防ぎます。アプリケーションはそのままです。パラメータの書き込みは、ドライバがサポートしている場合にのみ可能です。 デバイスパラメータを読み取るためのパラメータモードの設定 要件：ターゲットデバイスにはすでに1つ以上のアプリケーションがあります。ターゲットデバイスは、高度なオンライン構成モードをサポートしています。これらのアプリケーションを含むプロジェクトを開きました。コントローラにログインせずにデバイスパラメータを確認したい。ハードウェアのPLCへの接続は通信設定で構成されます。 PLCが稼働しています。 デバイスツリーでPLCオブジェクトを選択します。 コンテキストメニューで、をクリックします オンライン構成モード 。 CODESYS コントローラに接続し、ツリー内のPLCオブジェクトに緑色の背景が表示されます。 The 構成モードを選択します ダイアログが開き、PLC上のアプリケーションが表示されます。 目的のアプリケーションを選択し、をクリックします パラメータモード ボタン。 CODESYS プロジェクト内のアプリケーションがPLC上のアプリケーションに対応しているかどうかを確認します。 もしも CODESYS アプリケーションが一致しないというエラーを報告しない場合は、 構成 PLCデバイスエディタのタブ。 デバイスパラメータを読み取ることができます。 " }, 
{ "title" : "デバイスとI \/ Oマッピングの構成 ", 
"url" : "_cds_configuring_devices_mapping_ios.html", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスとI \/ Oマッピングの構成 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "デバイスの構成 ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_UUID-d1d98d5b-c218-8b08-a4d5-9eb8af6cbbe3", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスとI \/ Oマッピングの構成 \/ デバイスの構成 ", 
"snippet" : "関連するデバイスエディタで、デバイスツリーに挿入されるデバイスオブジェクトを設定できます。可能性はデバイスの説明によって異なります。 「 汎用デバイスエディタ \"は、デバイス固有のタブによって必要に応じて補足されるタブを提供します。 要件：デバイスツリーに標準PLCがあり、その下にフィールドバスデバイスオブジェクトが挿入されている標準プロジェクトを開いている必要があります。 プロジェクトのデバイスツリーで、標準PLCのデバイスオブジェクトをダブルクリックします。 The <デバイス名> エディターがメインで開きます CODESYS 窓。 The 通信設定 タブがフォアグラウンドにあります。コン...", 
"body" : "関連するデバイスエディタで、デバイスツリーに挿入されるデバイスオブジェクトを設定できます。可能性はデバイスの説明によって異なります。 「 汎用デバイスエディタ \"は、デバイス固有のタブによって必要に応じて補足されるタブを提供します。 要件：デバイスツリーに標準PLCがあり、その下にフィールドバスデバイスオブジェクトが挿入されている標準プロジェクトを開いている必要があります。 プロジェクトのデバイスツリーで、標準PLCのデバイスオブジェクトをダブルクリックします。 The <デバイス名> エディターがメインで開きます CODESYS 窓。 The 通信設定 タブがフォアグラウンドにあります。コントローラの設定を行うには、他のタブに変更してください。汎用デバイスエディタのヘルプページを参照してください。 プロジェクトのデバイスツリーでフィールドバスデバイスオブジェクトをダブルクリックします。 The <フィールドバスデバイス名> エディターがメインで開きます CODESYS 窓。デバイスに応じて、特定のタブを使用できます。構成オプションについては、それぞれのデバイスエディターのヘルプページを参照してください。の場合 一般的なデバイス構成ビューを表示する オプションはで選択されています ツール→オプション 、 の中に デバイスエディタ カテゴリについては、汎用デバイスエディタによって提供されるタブも参照してください。 " }, 
{ "title" : "PLCパラメータファイルを構成に読み込みます ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_6d2a082e744f3da1c0a8640e00aa0acb", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスとI \/ Oマッピングの構成 \/ PLCパラメータファイルを構成に読み込みます ", 
"snippet" : "PLCの構成パラメータが、視覚化などを介して別のデバイスによって変更された場合は、構成ファイル IoConfig.par コントローラ上に作成されます。デバイスによっては、現在のパラメータをそのようなファイルに書き込むためのボタンが、オンラインモードのデバイスエディタのパラメータダイアログにある場合があります。プロジェクト内の変更されたパラメータも更新するために、オンラインモードでパラメータファイルを読み込むことができます。 要件: ハードウェア環境がデバイス ツリー内の PLC およびパラメータ化可能なデバイスにマッピングされている、デバイス ツリーを含む標準プロジェクトがあります。コントロ...", 
"body" : "PLCの構成パラメータが、視覚化などを介して別のデバイスによって変更された場合は、構成ファイル IoConfig.par コントローラ上に作成されます。デバイスによっては、現在のパラメータをそのようなファイルに書き込むためのボタンが、オンラインモードのデバイスエディタのパラメータダイアログにある場合があります。プロジェクト内の変更されたパラメータも更新するために、オンラインモードでパラメータファイルを読み込むことができます。 要件: ハードウェア環境がデバイス ツリー内の PLC およびパラメータ化可能なデバイスにマッピングされている、デバイス ツリーを含む標準プロジェクトがあります。コントローラにはファイルがあります IoConfig.par で、デバイス パラメータが現在の値で以前に保存されました。 追加します PLCパラメータファイルを設定に読み込む からインターフェイスメニューへのコマンド デバイス のカテゴリ ツール→カスタマイズ ダイアログ。 デバイスツリーでPLCデバイスオブジェクトを選択し、コンテキストメニューを開きます。 クリック PLCパラメータファイルを設定に読み込む 。 CODESYS コントローラへの接続を自動的に確立し、パーファイルからパラメータを読み込みます。これらは、デバイスパラメータを使用してタブで適宜更新されます。 " }, 
{ "title" : "I \/ Oマッピングに関する一般情報 ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_UUID-38bf2ccb-2c3b-2bd8-ca28-36065308260f", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスとI \/ Oマッピングの構成 \/ I \/ Oマッピングに関する一般情報 ", 
"snippet" : "I \/ Oマッピングをプロジェクト変数、または機能ブロック全体に構成できるかどうかは、デバイスのタイプによって異なります。 I \/ Oマップの構成とは、デバイスの入力チャネルと出力チャネルをプロジェクトの変数にリンクすることを意味します。 「」という用語も使用します マッピング \" このため。 デバイスの入力と出力の変数へのマッピングについては、一般的に次の点に注意してください。 CODESYS ： 入力にマップされている変数への書き込みアクセス権がありません。 既存の変数を1つの入力にのみマップできます。 I \/ Oマップで新しいグローバル暗黙変数を直接生成し、それらをデバイスチャネルにマッ...", 
"body" : "I \/ Oマッピングをプロジェクト変数、または機能ブロック全体に構成できるかどうかは、デバイスのタイプによって異なります。 I \/ Oマップの構成とは、デバイスの入力チャネルと出力チャネルをプロジェクトの変数にリンクすることを意味します。 「」という用語も使用します マッピング \" このため。 デバイスの入力と出力の変数へのマッピングについては、一般的に次の点に注意してください。 CODESYS ： 入力にマップされている変数への書き込みアクセス権がありません。 既存の変数を1つの入力にのみマップできます。 I \/ Oマップで新しいグローバル暗黙変数を直接生成し、それらをデバイスチャネルにマップできます。 構造体のメモリレイアウトは、デバイスによって指定されます。 I \/ Oマップでアドレスを変更したり値を修正したりできます。 のI \/ Oチャネルに割り当てられている変数ごとに I \/ Oマッピング ダイアログでは、アプリケーションのコンパイル中に「強制変数」を生成させることができます（以下を参照）。これらの変数を使用すると、たとえばプラントの試運転中に、視覚化\/ HMIを介して入力または出力に値を強制することができます。 I \/ Oマップの変更は、オンライン変更でコントローラーに転送できます。 デバイス入力へのポインタが使用されている場合、そのアクセスは書き込みアクセスと見なされます。たとえば、 pTest := ADR(input); 。コードが生成されると、コンパイラの警告が発生します： \" ...invalid assignment target \"。この種の構成が必要な場合は、最初に入力値をコピーする必要があります input 書き込みアクセス権を持つ変数に。 I \/ Oアドレスは、IECコードの「AT宣言」を介して変数とリンクすることもできます。ただし、デバイス構成は頻繁に変更されるため、デバイスエディターでのみ割り当てを行うことをお勧めします。 AT宣言を使用する場合は、次の点に注意してください。 AT宣言は、ローカル変数またはグローバル変数でのみ許可され、ファンクションブロックの入力変数または出力変数では許可されません。 I \/ Oの暗黙的な「強制変数」（以下を参照）は、AT宣言では生成できません。 構造体変数または関数ブロック変数でAT宣言を使用する場合、すべてのインスタンスが同じメモリ位置にアクセスします。これは、「C」などの従来のプログラミング言語での「静的変数」の使用に対応します。 デバイス入力へのポインタが使用されている場合、アクセス（たとえば、 pTest := ADR(input); ）書き込みアクセスとして適用されます。コードが生成されると、コンパイラの警告が発生します： \" ...invalid assignment target \"。 この種の構成が必要な場合は、最初に入力値をコピーする必要があります（ input ）書き込みアクセス権を持つ変数に。 別の方法として、AT宣言を使用してプログラミングコードのアドレスに変数を割り当てることができます。ただし、デバイス構成の変更の可能性を考慮して、デバイスエディターでのみ割り当てを行うことをお勧めします。 デバイスのI \/ Oマッピング構成をにエクスポートできます。 csv ファイルするか、そのようなファイルからインポートします。 詳細については、以下を参照してください。 I \/ O画像をCSVにエクスポート詳細については、以下を参照してください。 I \/ Oを強制するための暗黙的な変数の生成" }, 
{ "title" : "デバイス入力を既存のプロジェクト変数にリンクする（「マッピング」） ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_999010aa744f3da6c0a8640e0038614a", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスとI \/ Oマッピングの構成 \/ デバイス入力を既存のプロジェクト変数にリンクする（「マッピング」） ", 
"snippet" : "要件：でI \/ Oマッピング構成をサポートするデバイス CODESYS プロジェクトのデバイスツリーに挿入されます。に I \/ Oマッピング したがって、デバイスエディタのタブを使用すると、アドレスとデータタイプを指定して、デバイスの入力チャネルと出力チャネルを表形式で表示できます。 「大きすぎる」データ型のマッピング バイトより大きいデータ型の変数がバイトアドレスにマップされている場合、変数の値はそこでバイトサイズに切り捨てられます。の変数値を監視するため I \/ Oマッピング ダイアログでは、これは、アドレスの「ルート」要素に、変数が現在プロジェクトに持っている値が表示されることを意味しま...", 
"body" : "要件：でI \/ Oマッピング構成をサポートするデバイス CODESYS プロジェクトのデバイスツリーに挿入されます。に I \/ Oマッピング したがって、デバイスエディタのタブを使用すると、アドレスとデータタイプを指定して、デバイスの入力チャネルと出力チャネルを表形式で表示できます。 「大きすぎる」データ型のマッピング バイトより大きいデータ型の変数がバイトアドレスにマップされている場合、変数の値はそこでバイトサイズに切り捨てられます。の変数値を監視するため I \/ Oマッピング ダイアログでは、これは、アドレスの「ルート」要素に、変数が現在プロジェクトに持っている値が表示されることを意味します。バイトの現在の個々のビット値は、その下のビット要素に連続して表示されますが、これは変数値全体に対して十分ではない場合があります。 UNIONがマッピングダイアログでI \/ Oチャネルによって表される場合、「ルート」要素へのマッピングも可能かどうかはデバイスによって異なります。 POUで、たとえば変数を宣言します xBool4 タイプの BOOL アプリケーションからターゲットデバイスの入力にアクセスするために使用します。 デバイスエディタを開くには、デバイスツリーでデバイスオブジェクトをダブルクリックしてから、 <デバイス名> I \/ Oマッピング タブ。 観察する 変数 デバイス入力の表示を含む列 チャネルとデバイス出力 チャネル、組織ごとに並べ替えることができます デバイスに応じて、ノード。タイプのデバイス入力があると仮定します BYTE 。個々のビットアドレス（ビットチャネル）が下に表示されます。 BYTE ノード。 注：構造化変数をマッピングする場合、エディターは両方の構造変数を入力できないようにします（例： %QB0 ）および個々の構造要素（例： %QB0.1 と QB0.2 ）。したがって、マッピングテーブルにビットチャネルエントリのサブツリーを持つメインエントリがある場合は、次のようになります。次に、メインエントリの行、またはサブ要素（ビットチャネル）の行に変数を指定できます。 ）、ただし両方にはなりません。 これで、チャネル全体を適切なタイプの変数で占有するか、その個々のビットチャネルアドレスを適切なタイプの変数で占有することができます。 BOOL また BIT 。まず、ビット入力チャンネルをダブルクリックします。 変数 桁。 入力フィールドが開きます。 チャネルに既存の変数を配置するには、完全なパスを使用して目的のプロジェクト変数を入力する必要があります。押す 入力アシスタントを開きます。たとえば、変数を選択します Application.PLC_PRG.xBool4 で宣言 PLC_PRG 。 変数が挿入されます。 The 記号はに表示されます マッピング 桁。これで、アドレスが削除されました。これは、既存の変数の値が別のメモリスペースで管理されているため、アドレスが使用できなくなったことを意味するものではありません。ただし、値を書き込む際のあいまいさを回避するために、それでも、特に出力の場合は、アドレスを別の変数で占有しないようにする必要があります。 注：コンパイラバージョンV3.5 SP11以降では、既存の変数にマッピングするときに、変数の初期化値がデフォルト値として自動的に使用されます。あなたは編集することができます デフォルト値 新しく作成された変数にマップする場合、またはマッピングが指定されていない場合にのみフィールド。古いバージョンでは、ユーザーはデフォルト値と初期化値が同一であることを明示的に指定する必要がありました。 変数の割り当てを再度削除します。チャネルのルートをクリックします。 BYTE ノード。入力アシスタントを再度使用して、変数を選択します Application.PLC_PRG.byte_gotodevice 。 変数が挿入され、メインチャネルのすべてのビットアドレスがストライキされます。追加でそれらを占有しないでください。 " }, 
{ "title" : "最近作成されたプロジェクト変数へのデバイス入力のマッピング ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_4032bba9628111e8accba0875c639f65", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスとI \/ Oマッピングの構成 \/ 最近作成されたプロジェクト変数へのデバイス入力のマッピング ", 
"snippet" : "以下では、デバイス出力をグローバル暗黙変数にマップします。これは、この目的のために最近作成したものです。 I \/ Oマッピング ダイアログ。 The I \/ Oマッピング したがって、ダイアログはグローバル変数を宣言するためのさらなる場所です。 要件：でI \/ Oマッピング構成をサポートするデバイス CODESYS プロジェクトのデバイスツリーに挿入されます。に I \/ Oマッピング したがって、デバイスエディタのタブには、アドレスとデータタイプを指定したデバイスの入力チャネルと出力チャネルの表形式の表示が表示されます。 デバイスエディタを開くには、デバイスツリーでデバイスオブジェクトをダブル...", 
"body" : "以下では、デバイス出力をグローバル暗黙変数にマップします。これは、この目的のために最近作成したものです。 I \/ Oマッピング ダイアログ。 The I \/ Oマッピング したがって、ダイアログはグローバル変数を宣言するためのさらなる場所です。 要件：でI \/ Oマッピング構成をサポートするデバイス CODESYS プロジェクトのデバイスツリーに挿入されます。に I \/ Oマッピング したがって、デバイスエディタのタブには、アドレスとデータタイプを指定したデバイスの入力チャネルと出力チャネルの表形式の表示が表示されます。 デバイスエディタを開くには、デバイスツリーでデバイスオブジェクトをダブルクリックしてから、 <デバイス名> I \/ Oマッピング タブ。 のチャネルエントリのマッピングテーブルをクリックします。 変数 入力フィールドを開くための列。 単純な名前を指定します（「 . \"）新しい変数の場合（例： myBool ）。 CODESYS プロジェクト内に暗黙のグローバル変数として変数を作成し、それをチャネルアドレスに直接割り当てます。したがって、この場合、既存の変数へのマッピングの場合のように、アドレスが突き刺さったようには見えません。 。 " }, 
{ "title" : "デバイスと機能ブロックインスタンスのリンク ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_4bb85fcf744f3da7c0a8640e01facbb6", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスとI \/ Oマッピングの構成 \/ デバイスと機能ブロックインスタンスのリンク ", 
"snippet" : "デバイスでサポートされている場合は、機能ブロック全体を入力チャネルまたは出力チャネルにマッピングできます。これにより、たとえば、信号の変化の頻度をカウントしたり、メンテナンスの目的でチャネル値をスケーリングしたりできます。 ここでは、デバイス出力チャネルを機能ブロックにマッピングします。この例では、ブロックはチャネル出力値をスケーリングします。 要件：FBマッピングをサポートするデジタル出力を備えたデバイスがプロジェクトにリンクされています。ファンクションブロックがあります Scale_Output_Int 次の実装で。機能ブロック自体の属性、およびチャネル出力が処理される出力パラメータの前の...", 
"body" : "デバイスでサポートされている場合は、機能ブロック全体を入力チャネルまたは出力チャネルにマッピングできます。これにより、たとえば、信号の変化の頻度をカウントしたり、メンテナンスの目的でチャネル値をスケーリングしたりできます。 ここでは、デバイス出力チャネルを機能ブロックにマッピングします。この例では、ブロックはチャネル出力値をスケーリングします。 要件：FBマッピングをサポートするデジタル出力を備えたデバイスがプロジェクトにリンクされています。ファンクションブロックがあります Scale_Output_Int 次の実装で。機能ブロック自体の属性、およびチャネル出力が処理される出力パラメータの前の属性は重要です。 {attribute 'io_function_block'}\nFUNCTION_BLOCK Scale_Output_Int\nVAR_INPUT\n iInput : INT;\n iNumerator : INT;\n iDenominator : INT :=1;\n iOffset : INT := 0;\nEND_VAR\nVAR_OUTPUT\n {attribute 'io_function_block_mapping'}\n iOutput : INT;\nEND_VAR\nVAR\nEND_VAR\nIF iDenominator <> 0 THEN\n iOutput := TO_INT(TO_DINT(iInput) * TO_DINT(iNumerator) \/ TO_DINT(iDenominator)) + iOffset; を開きます I \/ Oマッピング デバイスモジュールのタブ。機能ブロックに接続する必要のある出力をダブルクリックします。クリック IOチャネルにFBを追加します ボタン。 The 機能ブロックを選択 ダイアログが開きます。左側には、少なくとも機能ブロックが表示されます Scale_Output_int 下 応用 ノード。対応する機能ブロックを含むプロジェクトでリンクされたライブラリも選択のために表示されます。 POUを選択します myScaleOutputInt 。 クリックした後 わかった 、機能ブロックパラメータのパス iOutput の中に 変数 マッピングダイアログに入力されます。パスは、アプリケーション名、デバイスチャネル名、および選択されたFB出力で構成されます（例： App1.Out_4_Int_myScale_Output_Int_1.iOutput ）。 チャネルを選択し、をクリックします インスタンスに移動 ボタン。 フォーカスがに切り替わります <デバイス名> IECオブジェクト タブと新しいIECオブジェクト用に作成されたエントリ Out_4_Int_myScale_Output_Int_1 。オンラインモードのこのビューでは、パラメータの現在の値が表示されます iOutput チャネル用 Out_4_Int FBによってスケーリングされます。他の監視ビューと同様に、値を書き込んで強制することもできます。 詳細については、以下を参照してください。 タブ： '<デバイス名> IECオブジェクト と io_function_block、io_function_block_mapping" }, 
{ "title" : "I \/ Oマップのアドレス値の変更と修正 ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_0f670058744f3da8c0a8640e01f6b4b2", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスとI \/ Oマッピングの構成 \/ I \/ Oマップのアドレス値の変更と修正 ", 
"snippet" : "のマッピングテーブルで、チャネル全体のアドレス値を変更できます（ただし、チャネルの個々のサブ要素のアドレス値は変更できません）。 <デバイス名> I \/ Oマッピング タブ。これにより、アドレス指定を指定されたマシン構成に適合させ、モジュールのレイアウトが変更された場合でもアドレス値を保持できます。デフォルトでは、レイアウトを変更すると、アドレス値が自動的に調整されます。 要件：プロジェクトにI \/ Oマッピングがあります。上記のヘルプページの対応するセクションを参照してください。 デバイスエディタを開くには、デバイスツリーでデバイスオブジェクトをダブルクリックしてから、 <デバイス名> I ...", 
"body" : "のマッピングテーブルで、チャネル全体のアドレス値を変更できます（ただし、チャネルの個々のサブ要素のアドレス値は変更できません）。 <デバイス名> I \/ Oマッピング タブ。これにより、アドレス指定を指定されたマシン構成に適合させ、モジュールのレイアウトが変更された場合でもアドレス値を保持できます。デフォルトでは、レイアウトを変更すると、アドレス値が自動的に調整されます。 要件：プロジェクトにI \/ Oマッピングがあります。上記のヘルプページの対応するセクションを参照してください。 デバイスエディタを開くには、デバイスツリーでデバイスオブジェクトをダブルクリックしてから、 <デバイス名> I \/ Oマッピング タブ。 のチャネルエントリのマッピングテーブルをクリックします。 住所 入力フィールドを開くための列。これは、チャネルの「ルート」アドレスに対してのみ可能であり、そのサブ要素の特定の1つに対しては可能ではありません。 したがって、テーブル内のチャネルの先頭アドレスエントリを次のように変更します。 QB0 に QB1 。入力フィールドを終了します。 アドレス値が変更されます。 The アドレスの前に記号が表示されます。アドレスが固定されていることを示します。チャネルのサブ要素のアドレスもそれに応じて変更されます。ここで、デバイスツリーの入力\/出力チャネルを持つ他のデバイスオブジェクト内のデバイスオブジェクトの位置を変更すると、 CODESYS 修正しない場合のように、これらのアドレスを新しい順序に適合させません。 手動変更または修正を元に戻すには、アドレス値の入力フィールドを再度開き、アドレスエントリを削除してEnterキーを押します。 CODESYS アドレスと関連する後続のアドレスを変更前の値にリセットし、 シンボル。 詳細については、以下を参照してください。 住所" }, 
{ "title" : "I \/ O変数の更新の構成 ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_1bb5439b6f5b4e88c0a8640e00b2518b", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスとI \/ Oマッピングの構成 \/ I \/ O変数の更新の構成 ", 
"snippet" : "プロジェクトで接続するデバイスに応じて、 CODESYS 入力と出力に適用される変数をさまざまな方法で更新します。この設定は、で明示的に変更できます。 I \/ Oマッピング ダイアログ。...", 
"body" : "プロジェクトで接続するデバイスに応じて、 CODESYS 入力と出力に適用される変数をさまざまな方法で更新します。この設定は、で明示的に変更できます。 I \/ Oマッピング ダイアログ。 " }, 
{ "title" : "オンラインモードでのI \/ Oマップの変数の監視 ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_e1f8bef86f5b4e89c0a8640e00daea27", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスとI \/ Oマッピングの構成 \/ オンラインモードでのI \/ Oマップの変数の監視 ", 
"snippet" : "要件：I \/ Oマップを含むデバイス構成でアプリケーションをエラーなしでコンパイルしました。関連するハードウェアとバスシステムが実行されています。を使用してコントローラーに接続しました オンライン→ログイン コマンドを実行し、アプリケーションをロードして開始しました。 を開きます I \/ Oマッピング デバイスエディタのPLCのタブ。エディタを開くには、デバイスツリーでデバイスオブジェクトをダブルクリックします。 マッピングテーブルに追加で 現在の価値 と 新しい価値 列。 構造体変数がアドレスの「ルート」要素にマップされている場合 1 、 CODESYS オンラインモードでは、この行に値は表...", 
"body" : "要件：I \/ Oマップを含むデバイス構成でアプリケーションをエラーなしでコンパイルしました。関連するハードウェアとバスシステムが実行されています。を使用してコントローラーに接続しました オンライン→ログイン コマンドを実行し、アプリケーションをロードして開始しました。 を開きます I \/ Oマッピング デバイスエディタのPLCのタブ。エディタを開くには、デバイスツリーでデバイスオブジェクトをダブルクリックします。 マッピングテーブルに追加で 現在の価値 と 新しい価値 列。 構造体変数がアドレスの「ルート」要素にマップされている場合 1 、 CODESYS オンラインモードでは、この行に値は表示されません。たとえば、 DWORD 変数はアドレスにマップされますが、それぞれの値は「ルート」行とその下のインデントされたビットチャネル行の両方で監視されます。 原則として、値が複数のサブ要素で構成される場合、「ルート」行のフィールドは常に空のままになります。 1 \"root\" =マッピングダイアログのこのアドレスの最上位要素 列のエントリに特定の変数値を入力します 新しい価値 を押して F7 強制するか Ctrl + F7 値を書き込みます。 宣言エディタまたはウォッチリストでの監視の場合と同様に、強制変数値が列に表示されます 現在の価値 接頭辞付きの赤いF記号または書き込まれた値。 PLCコードが使用しない入出力は、オンラインモードのPLCで読み取られないため、表示値が正しくない場合があります。 The 現在の価値 関連する変数の一部が灰色の背景で表示されます。 " }, 
{ "title" : "I \/ Oを強制するための暗黙的な変数の生成 ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_ce4284c4e5326dc0a8640e0112de4e_id_3a1310c2796cb504c0a8640e01d0e08f", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスとI \/ Oマッピングの構成 \/ I \/ Oを強制するための暗黙的な変数の生成 ", 
"snippet" : "プラントまたは機械の試運転中に、入力と出力に適用される値を「強制」する必要がある場合があります。デバイスがこれをサポートしている場合は、この目的のために特別な「力変数」を生成して、たとえばHMIビジュアライゼーションで使用できます。 要件：デバイスは機能をサポートしています。デバイスにI \/ Oマップが構成されており、プログラムオブジェクトが含まれているプロジェクトがあります。 PLC_PRG 。 デバイスエディタを開き、 PLC設定 タブをクリックし、デバイスツリーでデバイスオブジェクトをダブルクリックします。 オプションを有効にする IOマッピング用の力変数を生成する 。 押す F11 ア...", 
"body" : "プラントまたは機械の試運転中に、入力と出力に適用される値を「強制」する必要がある場合があります。デバイスがこれをサポートしている場合は、この目的のために特別な「力変数」を生成して、たとえばHMIビジュアライゼーションで使用できます。 要件：デバイスは機能をサポートしています。デバイスにI \/ Oマップが構成されており、プログラムオブジェクトが含まれているプロジェクトがあります。 PLC_PRG 。 デバイスエディタを開き、 PLC設定 タブをクリックし、デバイスツリーでデバイスオブジェクトをダブルクリックします。 オプションを有効にする IOマッピング用の力変数を生成する 。 押す F11 アプリケーションをコンパイルします。 次の構文に従って、I \/ Oチャネルごとに2つの変数が作成されます。その過程で、チャネル名のスペースがアンダースコアに置き換えられます。 <device name>_<channel name>_<IECaddress>_force タイプの BOOL 強制のアクティブ化と非アクティブ化 <device name>_<channel name>_<IECaddress>_value チャネルに強制する値を定義するためのチャネルのデータ型の これらの変数は、カテゴリの入力アシスタントで使用できます 変数 \/ IoConfig_Globals_Force_Variables。 あなたはそれらを使用することができます CODESYS オブジェクトのプログラミング、視覚化、シンボル構成などで。 機能ブロックを開く PLC_PRG 、実装部分にフォーカスを設定し、を押します F2 。 入力アシスタントが開きます。変数はカテゴリで利用可能です 変数 \/ IoConfig_Globals_Force_Variables 上記のように。 「Forcevariable」入力の立ち上がりエッジは、「Valuevariable」で指定された値でそれぞれの入力または出力の強制をアクティブにします。立ち下がりエッジは強制を無効にします。 「Force」変数をにリセットして非アクティブ化 FALSE 新しい値を強制できるようにするための要件です。 次の制限に注意してください。 暗黙の力変数を介した強制は、にマップされているチャネルでのみ可能です。 I \/ Oマッピング 既存または最近作成された変数へのデバイスの。 暗黙の強制変数を介した強制は、未使用の入力と出力、またはアプリケーションプログラムのAT宣言を介して変数にマップされたものには使用できません。 メカニズムを介して強制するI \/ Oチャネルは、 CODESYS 少なくとも1つのタスクで。 CODESYS 監視の強制入力を赤い強制記号で識別しますが、強制入力\/出力は識別しません。強制値は、デバイスへの書き込みのためにI \/ Oドライバーによって暗黙的にのみ使用されます。 詳細については、以下を参照してください。 変数の強制と書き込み" }, 
{ "title" : "複数のデバイスの1つのダイアログでのI \/ Oマッピング ", 
"url" : "_cds_configuring_devices_mapping_ios.html#UUID-e4ed6bd2-7f4a-0d43-7622-c51976caa7d8_id_index_21", 
"breadcrumbs" : "CODESYS Essentials \/ I \/ Oリンクの構成 \/ デバイスとI \/ Oマッピングの構成 \/ 複数のデバイスの1つのダイアログでのI \/ Oマッピング ", 
"snippet" : "デバイスのI \/ Oマップと、デバイスツリーでその下に挿入されたすべてのサブ要素のI \/ Oマップを表示するテーブルがあります。そこでは、それぞれのデバイスエディタの個々のマッピングテーブルとまったく同じ方法でI \/ Oマップを編集できます。 要件：プロジェクトのデバイスツリーには、それぞれがI \/ Oマッピング構成を有効にする複数のPLCが挿入されています。 デバイスツリーのルートノードを選択し、をクリックします I \/ Oマッピングの編集 コンテキストメニューで。 The I \/ Oマッピングの編集 ダイアログが開き、プロジェクトに挿入されたすべてのデバイスのI \/ Oマッピング構成がテー...", 
"body" : "デバイスのI \/ Oマップと、デバイスツリーでその下に挿入されたすべてのサブ要素のI \/ Oマップを表示するテーブルがあります。そこでは、それぞれのデバイスエディタの個々のマッピングテーブルとまったく同じ方法でI \/ Oマップを編集できます。 要件：プロジェクトのデバイスツリーには、それぞれがI \/ Oマッピング構成を有効にする複数のPLCが挿入されています。 デバイスツリーのルートノードを選択し、をクリックします I \/ Oマッピングの編集 コンテキストメニューで。 The I \/ Oマッピングの編集 ダイアログが開き、プロジェクトに挿入されたすべてのデバイスのI \/ Oマッピング構成がテーブルに表示されます。エントリは、と同じ方法で編集できます。 I \/ Oマッピング 関連するデバイスエディタのダイアログ。 次に、デバイスツリーでコントロールオブジェクトの1つを選択し、 I \/ Oマッピングの編集 コンテキストメニューでもう一度コマンドを実行します。 The I \/ Oマッピングの編集 ダイアログには、選択したオブジェクト内およびその下にあるI \/ Oマッピング構成のI \/ Oテーブルのみが表示されるようになりました。 希望の設定 フィルター テーブルの上のバーに入力するか、変数名を入力します 変数を検索する マッピングでのこの変数の使用を確認するためのフィールド。 このウィンドウでの作業方法は、 <デバイス名> I \/ Oマッピング タブ。 " }, 
{ "title" : "アプリケーションのプログラミング ", 
"url" : "_cds_struct_application_programming.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング ", 
"snippet" : "コントローラ上で実行できるアプリケーション プログラムを作成するには、POU に宣言と実装コード (ソース コード) を入力し、コントローラ I\/O からアプリケーション変数へのリンクを確立し、タスクの割り当てを構成します。確認とデバッグを行った後、 CODESYS コンパイラは、コントローラにダウンロードできるアプリケーション コードを作成します。 アプリケーションPOUのプログラミングは、プログラミング言語エディタやその他の機能（次のようなもの）によってサポートされています。 テキストリスト 、 画像コレクション 、 アラーム設定 、 プラグマ 、リファクタリング、すぐに使用できる POU...", 
"body" : "コントローラ上で実行できるアプリケーション プログラムを作成するには、POU に宣言と実装コード (ソース コード) を入力し、コントローラ I\/O からアプリケーション変数へのリンクを確立し、タスクの割り当てを構成します。確認とデバッグを行った後、 CODESYS コンパイラは、コントローラにダウンロードできるアプリケーション コードを作成します。 アプリケーションPOUのプログラミングは、プログラミング言語エディタやその他の機能（次のようなもの）によってサポートされています。 テキストリスト 、 画像コレクション 、 アラーム設定 、 プラグマ 、リファクタリング、すぐに使用できる POU から CODESYS Development System またはライブラリ。 構文チェックとコード分析、データ永続性の実現、コントローラーにダウンロードされるアプリケーション コードの暗号化などの機能があります。 " }, 
{ "title" : "識別子を割り当てる ", 
"url" : "_cds_naming_identifiers.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 識別子を割り当てる ", 
"snippet" : "識別子は、プログラム、関数ブロック、メソッドなどの変数とプログラミングオブジェクトの名前、およびアプリケーションとプロジェクトの他のオブジェクトの名前です。識別子を割り当てるときに従わなければならない規則があります。さらに、識別子を統一して意味のあるものにするための推奨事項があります。 変数宣言で変数の識別子を割り当てます。これらの識別子は、プログラミングオブジェクトの宣言部分で変更できます。それぞれのオブジェクトを追加するときに、ダイアログでプログラミングオブジェクトおよびその他のオブジェクトの識別子を割り当てます。アプリケーションまたはプロジェクトの既存のオブジェクトの識別子は、オブジェク...", 
"body" : "識別子は、プログラム、関数ブロック、メソッドなどの変数とプログラミングオブジェクトの名前、およびアプリケーションとプロジェクトの他のオブジェクトの名前です。識別子を割り当てるときに従わなければならない規則があります。さらに、識別子を統一して意味のあるものにするための推奨事項があります。 変数宣言で変数の識別子を割り当てます。これらの識別子は、プログラミングオブジェクトの宣言部分で変更できます。それぞれのオブジェクトを追加するときに、ダイアログでプログラミングオブジェクトおよびその他のオブジェクトの識別子を割り当てます。アプリケーションまたはプロジェクトの既存のオブジェクトの識別子は、オブジェクトのプロパティダイアログで変更できます。ただし、アプリケーションごとに1回だけ、またはプロジェクトごとに1回だけ存在できるオブジェクトの識別子（たとえば、識別子）を変更することはできません。 ライブラリマネージャー と 画像プール 。 詳細については、以下を参照してください。 識別子の指定" }, 
{ "title" : "UTF-8エンコーディング ", 
"url" : "_cds_utf8_encoding.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ UTF-8エンコーディング ", 
"snippet" : "基本 のアプリケーション CODESYS たとえば、さまざまな言語でエラーメッセージを出力するために、さまざまな文字を処理できます。または、さまざまな言語、文字、または記号でのユーザー入力を受け入れる、ユーザーが選択した言語で視覚化を表示します。 包括的な文字セットが必要ない場合、またはプロジェクトを変更する必要がない場合でも、Latin-1形式でエンコードされた文字列を使用できます。 文字セットテーブル キャラクターセット コードページ番号 説明 文字コード ASCII 20127 128文字 英語のテキストに適しています 7ビットでエンコードされた文字 DOS-Latin-1 819, 8...", 
"body" : "基本 のアプリケーション CODESYS たとえば、さまざまな言語でエラーメッセージを出力するために、さまざまな文字を処理できます。または、さまざまな言語、文字、または記号でのユーザー入力を受け入れる、ユーザーが選択した言語で視覚化を表示します。 包括的な文字セットが必要ない場合、またはプロジェクトを変更する必要がない場合でも、Latin-1形式でエンコードされた文字列を使用できます。 文字セットテーブル キャラクターセット コードページ番号 説明 文字コード ASCII 20127 128文字 英語のテキストに適しています 7ビットでエンコードされた文字 DOS-Latin-1 819, 850 ISO8859に準拠 Windowsコマンドラインウィンドウの西ヨーロッパ言語に適しています 8ビットエンコード文字 ラテン-1 28591 ISO-8859-1に準拠 多くの場合、äöüßは含まれているが€は含まれていない、またはたとえば特殊なフランス語文字が含まれていないHTMLページに使用されます 8ビットエンコード文字 Windows1252エンコーディング 1252 西ヨーロッパ諸国のデフォルトのWindows文字セット Windowsは内部でUTF-16形式を使用します ISO8859-1およびISO8859-15のすべての文字が含まれていますが、エンコーディングが部分的に異なります 8ビットエンコード文字 Unicode 歴史的な言語、点字、音楽、絵文字など、考えられるすべての言語のユニバーサル文字セット 100,000文字以上を表示できます。 各文字には数値コードがあります。 ASCIIとは対照的に、文字へのコードポイントの割り当てと文字のエンコードは分離されます。 128未満の数値コードはASCII互換です 256未満の数値コードはISO8859-1と互換性があります 詳細については、以下を参照してください。 https:\/\/home.unicode.org\/ Unicode 14.0 144,697文字 UTF-16 1200 特別なUnicode 一部のオペレーティングシステム（Windows、OS X）およびプログラミング言語（Java、.NET）で内部文字表現に使用されます コンピュータアーキテクチャが異なれば、4バイト文字のエンコードも異なることに注意してください。 UTF-16LEのリトルエンディアンバイトオーダー 16ビットエンコード文字 文字は2バイトまたは4バイトでエンコードされます。 UTF-8 65001 Unicode文字のバイト指向のエンコード形式 最も普及している GNU \/ LinuxおよびUnixオペレーティングシステム、およびさまざまなインターネットサービス（電子メール、Web、ブラウザ）で使用されます 最初の128文字（0〜127）のASCII文字と互換性があります 1文字あたり8ビットワードのタプル 文字は、1〜4バイトのさまざまな長さでエンコードされます。 " }, 
{ "title" : "UTF-8で CODESYS ", 
"url" : "_cds_utf8_encoding.html#UUID-7e4361ae-d07f-2866-46cf-cabba3de11bf_section-idm4579545478443232896837520979", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ UTF-8エンコーディング \/ UTF-8で CODESYS ", 
"snippet" : "UTF-8エンコーディングは、最も包括的な文字セットを使用したエンコーディングです。したがって、新しいプロジェクトおよび既存のプロジェクトでUTF-8エンコーディングを有効にして、新しいコンテキストで使用することをお勧めします。 プロジェクト全体のエンコーディング CODESYS データ・タイプ コンパイルオプション：STRINGのUTF8エンコーディング プロジェクト全体でどのエンコーディングが使用されていますか？ STRING 有効 UTF-8 無効 Windows 1252エンコーディング（デフォルトのWindowsエンコーディング） ラテン-1 WSTRING 有効 UTF-16 無効...", 
"body" : "UTF-8エンコーディングは、最も包括的な文字セットを使用したエンコーディングです。したがって、新しいプロジェクトおよび既存のプロジェクトでUTF-8エンコーディングを有効にして、新しいコンテキストで使用することをお勧めします。 プロジェクト全体のエンコーディング CODESYS データ・タイプ コンパイルオプション：STRINGのUTF8エンコーディング プロジェクト全体でどのエンコーディングが使用されていますか？ STRING 有効 UTF-8 無効 Windows 1252エンコーディング（デフォルトのWindowsエンコーディング） ラテン-1 WSTRING 有効 UTF-16 無効 UTF-16 の CODESYS 、 STRING データ型は、Latin-1またはUTF-8形式でエンコードできます。 The WSTRING データ型は、UTF-16では常にその文字をUnicodeとしてエンコードします。 " }, 
{ "title" : "単一の文字列リテラルをUTF-8形式でエンコードする ", 
"url" : "_cds_utf8_encoding.html#UUID-7e4361ae-d07f-2866-46cf-cabba3de11bf_section-idm4663754559772832898653408592", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ UTF-8エンコーディング \/ UTF-8で CODESYS \/ 単一の文字列リテラルをUTF-8形式でエンコードする ", 
"snippet" : "プロジェクト全体のエンコード形式がLatin-1に設定されている場合でも、単一のリテラルをUTF-8形式でエンコードできます。これを行うには、を追加します UTF8# リテラルのプレフィックスを入力します。 {attribute 'monitoring_encoding' := 'UTF-8'} strVarUtf8: STRING := UTF8#'你好,世界!ÜüÄäÖö'; 詳細については、以下を参照してください。定数： UTF8＃文字列;プラグマ属性： monitoring_encoding...", 
"body" : "プロジェクト全体のエンコード形式がLatin-1に設定されている場合でも、単一のリテラルをUTF-8形式でエンコードできます。これを行うには、を追加します UTF8# リテラルのプレフィックスを入力します。 {attribute 'monitoring_encoding' := 'UTF-8'}\nstrVarUtf8: STRING := UTF8#'你好,世界!ÜüÄäÖö'; 詳細については、以下を参照してください。定数： UTF8＃文字列;プラグマ属性： monitoring_encoding" }, 
{ "title" : "UTF-8エンコーディングの文字列変換 ", 
"url" : "_cds_utf8_encoding.html#UUID-7e4361ae-d07f-2866-46cf-cabba3de11bf_section-idm4525865800604832898698002139", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ UTF-8エンコーディング \/ UTF-8で CODESYS \/ UTF-8エンコーディングの文字列変換 ", 
"snippet" : "プロジェクト全体でUTF-8エンコーディングを有効にしている場合は、通常どおり文字列変換関数を使用できます。...", 
"body" : "プロジェクト全体でUTF-8エンコーディングを有効にしている場合は、通常どおり文字列変換関数を使用できます。 " }, 
{ "title" : "文字列操作 ", 
"url" : "_cds_utf8_encoding.html#UUID-7e4361ae-d07f-2866-46cf-cabba3de11bf_section-idm4524271435323232898709825848", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ UTF-8エンコーディング \/ UTF-8で CODESYS \/ 文字列操作 ", 
"snippet" : "ライブラリ関数を使用して文字列を操作します。 もしも STRING 変数を操作する必要があります。そうすると、ASCII形式の変数へのインデックスアクセスにより、多くの場合、目的の結果が得られます。この構成は使用しない方がよいでしょう。それは単に悪いプログラミングスタイルではありません。さらに悪いことに、UTF-8エンコーディングでは、インデックスアクセスによって不要な文字列操作が発生します。 プロジェクト全体の構成専用のUTF-8エンコーディング プロジェクト全体のコンパイルオプションの場合、UTF-8エンコーディングが使用されます STRINGのUTF8エンコーディング 有効になっています...", 
"body" : "ライブラリ関数を使用して文字列を操作します。 もしも STRING 変数を操作する必要があります。そうすると、ASCII形式の変数へのインデックスアクセスにより、多くの場合、目的の結果が得られます。この構成は使用しない方がよいでしょう。それは単に悪いプログラミングスタイルではありません。さらに悪いことに、UTF-8エンコーディングでは、インデックスアクセスによって不要な文字列操作が発生します。 プロジェクト全体の構成専用のUTF-8エンコーディング プロジェクト全体のコンパイルオプションの場合、UTF-8エンコーディングが使用されます STRINGのUTF8エンコーディング 有効になっています。ライブラリ関数とアドオンも、この設定に従って方向付けられます。 単一のUTF-8エンコード文字列を使用する場合は、それらが使用される場所で正しく解釈されることを確認する必要があります。たとえば、設定が選択されていない場合、OPCサーバーの文字列変数はクライアントに転送される前にUTF-8に変換されます。次のような値 UTF8#'äöü' その後、誤解されます。ビジュアライゼーションで文字列を出力するときにも、同様の問題が発生する可能性があります。 " }, 
{ "title" : "変数宣言 ", 
"url" : "_cds_f_declaring_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 ", 
"snippet" : "変数宣言:どこでどのように? 変数は以下の場所で宣言できます。 POU のデクラレーション部分 ザル 変数を宣言する これにはダイアログが役立ちます。 変数リスト (GVL エディター、NVL エディター) I\/O デバイスオブジェクトの I\/O マッピング設定 詳細については、以下を参照してください。 デバイスとI \/ Oマッピングの構成詳細については、以下を参照してください。 変数宣言のショートカット...", 
"body" : "変数宣言:どこでどのように? 変数は以下の場所で宣言できます。 POU のデクラレーション部分 ザル 変数を宣言する これにはダイアログが役立ちます。 変数リスト (GVL エディター、NVL エディター) I\/O デバイスオブジェクトの I\/O マッピング設定 詳細については、以下を参照してください。 デバイスとI \/ Oマッピングの構成詳細については、以下を参照してください。 変数宣言のショートカット" }, 
{ "title" : "構文 ", 
"url" : "_cds_f_declaring_variables.html#UUID-ef4aa32b-23c7-a688-0472-86ee8eb95613_section-idm2347730964863", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 \/ 構文 ", 
"snippet" : "<pragma> <scope> <type qualifier>     <identifier> AT <address> : <data type> := <initial value> ; END_VAR <pragma> 繰り返し（任意）（なし、1回、または複数回） プラグマ プラグマはコンパイラステートメントです（たとえば、メモリ要件やランタイムの改善などの最適化を行うための）。 プラグマの使用プラグマ<scope> 必須 スコープ VAR VAR_CONFIG メモ:アドレス情報が不完全な変数が関数ブロックで宣言されている場合 (たとえば、 AT %I* )、次に変数宣言内の変数...", 
"body" : "<pragma> <scope> <type qualifier>     <identifier> AT <address> : <data type> := <initial value> ; END_VAR <pragma> 繰り返し（任意）（なし、1回、または複数回） プラグマ プラグマはコンパイラステートメントです（たとえば、メモリ要件やランタイムの改善などの最適化を行うための）。 プラグマの使用プラグマ<scope> 必須 スコープ VAR VAR_CONFIG メモ:アドレス情報が不完全な変数が関数ブロックで宣言されている場合 (たとえば、 AT %I* )、次に変数宣言内の変数 VAR_CONFIG 完全に宣言されている必要があります。ローカルインスタンスでこれらの変数にアクセスできるのは、これが完了した場合だけです。 VAR_EXTERNAL VAR_GLOBAL VAR_INPUT VAR_INST VAR_IN_OUT VAR_OUTPUT VAR_STAT VAR_TEMP VARVAR_CONFIGVAR_EXTERNALVAR_GLOBALGVLVAR_INPUTVAR_INSTVAR_IN_OUTVAR_OUTPUTVAR_STATVAR_TEMP<type qualifier> [オプション] タイプ修飾子 CONSTANT RETAIN PERSISTENT CONSTANTRETAINPERSISTENT<identifier> 必須 識別子、変数名 注:識別子を割り当てるときは、「識別子の指定」の章に記載されている規則に例外なく従う必要があります。さらに、統一命名に関する推奨事項も記載されています 識別子の指定AT %<address> [オプション] アドレスは次のように構成されています。 <メモリ領域> <任意サイズの接頭辞> <メモリ位置> メモリ領域は、入力メモリ領域、出力メモリ領域、またはフラグメモリ領域に細分されます ( I 、 Q または M )。 例 AT %I* \/\/ Incomplete address AT %I7.5 AT %IW0 AT %QX7.5 AT %MD48 デバイスとI \/ Oマッピングの構成AT宣言住所<data type> 必須 データタイプ 基本データ型 カスタムデータタイプ ファンクションブロック データ型DUTファンクションブロック<initial value> [オプション] 初期値、リテラル、変数、または式としての初期化 定数とリテラル ST 式例 グローバル変数リスト GVL {attribute 'qualified_only'}\n{attribute 'linkalways'}\nVAR_GLOBAL CONSTANT\n g_ciMAX_A : INT := 100;\n g_ciSPECIAL : INT := g_ciMAX_A - 10;\nEND_VAR 設定変数 GVL_CONFIG {attribute 'qualified_only'}\nVAR_CONFIG\n \/\/ Generated instance path of variable at incomplete address\n PLC_PRG.fbDoItNow.XLOCINPUT AT %I*: BOOL := TRUE;\nEND_VAR ファンクションブロック FB_DoIt METHOD METH_Last : INT\nVAR_INPUT\n iVar : INT;\nEND_VAR\nVAR_INST\n iLast : INT := 0;\nEND_VAR\n\nMETH_Last := iLast;\niLast := iVar;\n\nFUNCTION_BLOCK FB_DoIt\nVAR_INPUT\n wInput AT %IW0 : WORD; (* Input variable *)\nEND_VAR\nVAR_OUTPUT\n wOutput AT %QW0 : WORD; (* Output variable *)\nEND_VAR\nVAR_IN_OUT\n aData_A : ARRAY[0..1] OF DATA_A; \/\/ Formal variable\nEND_VAR\nVAR_EXTERNAL\n GVL.g_ciMAX_A : INT; \/\/ Declared in object GVL\nEND_VAR\nVAR_STAT\n iNumberFBCalls : INT;\nEND_VAR\nVAR\n iCounter: INT;\n xLocInput AT %I* : BOOL := TRUE; \/\/ VAR_CONFIG\nEND_VAR\n\niNumberFBCalls := iNumberFBCalls + 1; IEC プログラム PLC_PRG PROGRAM PLC_PRG\nVAR\n iLoop: INT;\n iTest: INT;\n fbDoItNow : FB_DoIt;\n iTest_200: INT;\n aData_Now : ARRAY[0..1] OF DATA_A := [(iA_1 := 1, iA_2 := 10, dwA_3 := 16#00FF),(iA_1 := 2, iA_2 := 20, dwA_3 := 16#FF00)];\nEND_VAR\n\niTest := GVL.g_ciMAX_A;\niTest_200 := 2 * GVL.g_ciMAX_A;\nfbDoItNow(aData_A := aData_Now);\nFOR iLoop := 0 TO GVL.g_ciSPECIAL DO\n ;\nEND_FOR " }, 
{ "title" : "変数初期化 ", 
"url" : "_cds_variables_initialization.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 \/ 変数初期化 ", 
"snippet" : "すべての宣言の標準初期化値は 0 。宣言部分では、変数やデータ型ごとにユーザー定義の初期化値を指定することもできます ユーザー定義の初期化は代入演算子から始まります := プログラミング言語 ST (構造化テキスト) の任意の有効な表現で構成されます。したがって、初期化値は定数、その他の変数、または関数を使用して定義します。変数を使用する場合は、その変数も初期化する必要があります デフォルト初期化値 データタイプ [初期化] 任意の数値データ型 0 すべてのポインタ 0 BOOL FALSE ARRAY OF 各要素のデフォルト初期化値 構造 宣言の個々の要素に明示的な値が定義されていない場合...", 
"body" : "すべての宣言の標準初期化値は 0 。宣言部分では、変数やデータ型ごとにユーザー定義の初期化値を指定することもできます ユーザー定義の初期化は代入演算子から始まります := プログラミング言語 ST (構造化テキスト) の任意の有効な表現で構成されます。したがって、初期化値は定数、その他の変数、または関数を使用して定義します。変数を使用する場合は、その変数も初期化する必要があります デフォルト初期化値 データタイプ [初期化] 任意の数値データ型 0 すべてのポインタ 0 BOOL FALSE ARRAY OF 各要素のデフォルト初期化値 構造 宣言の個々の要素に明示的な値が定義されていない場合、データ型のデフォルト値は初期化値です。 例 VAR\n var1:INT := 12; \/\/initialization value 12\n x : INT := 13 + 8; \/\/initalization value defined by an expression of constants\n y : INT := x + fun(4); \/\/initialization value defined by an expression,\n \/\/that contains a function call; notice the order!\n z : POINTER TO INT := ADR(y); \/\/not described in the standard IEC61131-3:\n \/\/ initialization value defined by an adress function;\n \/\/ Notice: In this case the pointer will not be initialized\n \/\/ during an Online Change *)\nEND_VAR 初期化の順序に関する注意事項 まず、定数 コンパイラバージョン3.5.3.40以降、関数ブロック内の変数は次の順序で初期化されます。まず、すべての定数は宣言の順序に従って初期化され、次に他のすべての変数は宣言の順序に従って初期化されます。 ローカル変数の前のグローバル変数 コンパイラバージョン 3.3.2.0 以降では、グローバル変数リストの変数は常に POU のローカル変数の前に初期化されます。 詳細については、以下を参照してください。 構造変数の宣言と初期化 とプラグマ global_init_slot。 " }, 
{ "title" : "デクラレーションエディタの使用 ", 
"url" : "_cds_declaration_editor_basics.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 \/ デクラレーションエディタの使用 ", 
"snippet" : "宣言エディタは、変数リストと POU 内の変数を宣言するために使用されます。 デクラレーションエディターには 2 つのビューがあります。 : 表形式ビュー : テキストビュー で ツール → オプション → デクラレーションエディター ダイアログでは、テキストビューのみを表示するか、表形式ビューのみを表示するかを設定できます。または、エディタビューの右端にあるボタンを使って 2 つのビューを切り替えることができるかどうか デクラレーションエディタをプログラミング言語エディタと組み合わせて使用すると、POUのウィンドウ上部にデクラレーション部分として表示されます。...", 
"body" : "宣言エディタは、変数リストと POU 内の変数を宣言するために使用されます。 デクラレーションエディターには 2 つのビューがあります。 : 表形式ビュー : テキストビュー で ツール → オプション → デクラレーションエディター ダイアログでは、テキストビューのみを表示するか、表形式ビューのみを表示するかを設定できます。または、エディタビューの右端にあるボタンを使って 2 つのビューを切り替えることができるかどうか デクラレーションエディタをプログラミング言語エディタと組み合わせて使用すると、POUのウィンドウ上部にデクラレーション部分として表示されます。 " }, 
{ "title" : "表形式の宣言エディタでの宣言 ", 
"url" : "_cds_declaration_editor_basics.html#UUID-c2687aff-7cd6-bd33-2c3c-16ea3266af11_id_c44c3e624d92f81c0a8640e01901bfe_id_5e92db7bc6203aeec0a8640e00c25a63", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 \/ デクラレーションエディタの使用 \/ 表形式の宣言エディタでの宣言 ", 
"snippet" : "表形式宣言エディターでは、次の列を含むテーブルに変数宣言を追加します。 スコープ 、 名前 、 住所 、 データタイプ 、 初期化 、 コメント 、および 属性 (プラグマ)。 表形式のビューでは、構文に関する詳細な知識は必要ありません。 要件:プロジェクトのプログラミングオブジェクト (POU または GVL) が開いている。表形式の宣言エディターに焦点が当てられています をクリックします デクラレーションヘッダーのボタンをクリックするか、をクリックします 挿入 コンテキストメニューで。 変数宣言の新しい行が挿入され、変数名の入力フィールドが開きます。 有効な変数名を指定してください。 必要...", 
"body" : "表形式宣言エディターでは、次の列を含むテーブルに変数宣言を追加します。 スコープ 、 名前 、 住所 、 データタイプ 、 初期化 、 コメント 、および 属性 (プラグマ)。 表形式のビューでは、構文に関する詳細な知識は必要ありません。 要件:プロジェクトのプログラミングオブジェクト (POU または GVL) が開いている。表形式の宣言エディターに焦点が当てられています をクリックします デクラレーションヘッダーのボタンをクリックするか、をクリックします 挿入 コンテキストメニューで。 変数宣言の新しい行が挿入され、変数名の入力フィールドが開きます。 有効な変数名を指定してください。 必要に応じて宣言行の他のフィールドをダブルクリックして開き、リストボックスまたは開いたダイアログから目的の仕様を選択します。 詳細については、以下を参照してください。 変数を宣言する" }, 
{ "title" : "テキスト宣言エディタでの宣言 ", 
"url" : "_cds_declaration_editor_basics.html#UUID-c2687aff-7cd6-bd33-2c3c-16ea3266af11_id_c44c3e624d92f81c0a8640e01901bfe_id_e87b1f3952a211e4ac52fce4405945f5", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 \/ デクラレーションエディタの使用 \/ テキスト宣言エディタでの宣言 ", 
"snippet" : "テキストエディタの動作と外観は、の設定で設定します。 [ツール] → オプション → テキストエディター 。設定は色、行番号、タブ幅、インデントなどに関するもので、通常のWindows機能に加えて、必要に応じてIntelliMouse機能も使用できます。 POU、GVL、または NVL を開き、テキスト宣言エディタにフォーカスを設定した場合は、変数宣言を指定します。構文に注意してください。を押します F2 サポート用、および入力アシスタントを使用してデータ型またはキーワードを選択するため。 スコープまたは変数タイプのショートカットを使用すると、入力の手間を省くことができます。 詳細については、...", 
"body" : "テキストエディタの動作と外観は、の設定で設定します。 [ツール] → オプション → テキストエディター 。設定は色、行番号、タブ幅、インデントなどに関するもので、通常のWindows機能に加えて、必要に応じてIntelliMouse機能も使用できます。 POU、GVL、または NVL を開き、テキスト宣言エディタにフォーカスを設定した場合は、変数宣言を指定します。構文に注意してください。を押します F2 サポート用、および入力アシスタントを使用してデータ型またはキーワードを選択するため。 スコープまたは変数タイプのショートカットを使用すると、入力の手間を省くことができます。 詳細については、以下を参照してください。 変数宣言のショートカット" }, 
{ "title" : "によるサポート 自動宣言 コマンド ", 
"url" : "_cds_declaring_variable.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 \/ によるサポート 自動宣言 コマンド ", 
"snippet" : "要件:プロジェクトの POU または GVL が開いている。 をクリックします [編集] → 自動宣言 コマンド。 ダイアログが開きます。 リストボックスから変数の目的のスコープを選択します。 スコープ 。 入力フィールドに変数名を指定します [名前] 。 から目的のデータタイプを選択します。 データタイプ リストボックス。 初期化値が標準の初期化値と異なる場合は、変数の初期化値を入力します。 クリック OK 入力内容を確認するため。 新しく宣言された変数は、POU の宣言部分に一覧表示されます。 宣言部分のプラグマの助けを借りて、コンパイラによる宣言の処理に影響を与えることができます。 詳細...", 
"body" : "要件:プロジェクトの POU または GVL が開いている。 をクリックします [編集] → 自動宣言 コマンド。 ダイアログが開きます。 リストボックスから変数の目的のスコープを選択します。 スコープ 。 入力フィールドに変数名を指定します [名前] 。 から目的のデータタイプを選択します。 データタイプ リストボックス。 初期化値が標準の初期化値と異なる場合は、変数の初期化値を入力します。 クリック OK 入力内容を確認するため。 新しく宣言された変数は、POU の宣言部分に一覧表示されます。 宣言部分のプラグマの助けを借りて、コンパイラによる宣言の処理に影響を与えることができます。 詳細については、以下を参照してください。 属性プラグマ、コマンド 変数を宣言する" }, 
{ "title" : "配列を宣言する ", 
"url" : "_cds_declaring_array.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 \/ 配列を宣言する ", 
"snippet" : "要件:プロジェクトの POU または GVL が開いている。 をクリックします 編集 → 自動宣言 コマンド。 ザル 自動宣言 ダイアログが開きます。 アレイの希望のスコープを以下から選択します。 スコープ リストボックス。 に配列の識別子を指定します。 [名前] 入力フィールド。 をクリックします の横にあるボタン データタイプ フィールドを入力して選択 配列アシスタント 選択メニューからの入力。 入力フィールドに ディメンション 1 、配列の 1 番目の次元の下限と上限を入力します (例: 1 と 3 )。 フィールド 結果 配列の 1 次元を表示します (例: ARRAY [1..3] ...", 
"body" : "要件:プロジェクトの POU または GVL が開いている。 をクリックします 編集 → 自動宣言 コマンド。 ザル 自動宣言 ダイアログが開きます。 アレイの希望のスコープを以下から選択します。 スコープ リストボックス。 に配列の識別子を指定します。 [名前] 入力フィールド。 をクリックします の横にあるボタン データタイプ フィールドを入力して選択 配列アシスタント 選択メニューからの入力。 入力フィールドに ディメンション 1 、配列の 1 番目の次元の下限と上限を入力します (例: 1 と 3 )。 フィールド 結果 配列の 1 次元を表示します (例: ARRAY [1..3] OF ? )。 入力フィールドに ベーシックタイプ。 、配列のデータ型を入力するか、 入力アシスタント または アレイアシスタント (例: DINT )。 ザル 結果 フィールドには現在の配列のデータ型が表示されます (例: ARRAY [1..3] OF DINT )。 ステップ 5 と 6 に従って配列の 2 番目と 3 番目の次元を定義します (例:次元 2: 1 と 4 、ディメンション 3: 1 と 2 )。 ザル 結果 フィールドには、定義された次元の配列が表示されます。 ARRAY [1..3, 1..4, 1..2] OF DINT 。この配列は 3 * 4 * 2 = 24 個の要素で構成されています。 可変長の配列では、アスタリスクプレースホルダー () を使用して次元の制限を宣言します。 * )。可変長の配列は、関数ブロック、メソッド、または関数の VAR_IN_OUT 宣言でのみ使用できます 可変長の2次元配列の例: aiUnknownLengthData : ARRAY [*,*] OF INT; クリック OK 。 で 自動宣言 ダイアログ、 データタイプ フィールドには配列が表示されます。 配列の初期化値を変更するには、をクリックします。 の横にあるボタン 初期化値 入力フィールド。 ザル 初期化値 ダイアログが開きます。 初期化値を変更したい配列要素の行を選択します。例:配列コンポーネント [1, 1, 1] を選択します リストの下の入力フィールドに目的の初期化値を指定し、ボタンをクリックします 選択した行に値を使う (例:値) 4 )。 CODESYS 選択した行の変更された初期化値を表示します。 クリック OK 。 現場で 初期化値 対話の 変数を宣言する を示します CODESYS 配列の初期化値、例： [4, 23(0)] 。 オプションを指定します [コメント] 入力フィールドに。 クリック OK 配列の宣言を締めくくるためです。 CODESYS 配列の宣言をプログラミングオブジェクトの宣言部分に追加します。 詳細については、「データタイプ」を参照してください。 ARRAY OF" }, 
{ "title" : "グローバル変数を宣言する ", 
"url" : "_cds_defining_global_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 \/ グローバル変数を宣言する ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "アプリケーション内で使用可能なグローバル変数を定義します ", 
"url" : "_cds_defining_global_variables.html#UUID-73312950-d699-07b8-bbc0-46660b31cccc_id_a1822005ba31dc0a8640e004a22fb_id_e022761b24c9bb1bc0a8640e00b1b070", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 \/ グローバル変数を宣言する \/ アプリケーション内で使用可能なグローバル変数を定義します ", 
"snippet" : "要件：プロジェクトが開いています。 プロジェクトのデバイスツリーで、グローバル変数を有効にするアプリケーションを選択します。 コンテキストメニューコマンドを選択します オブジェクトの追加→グローバル変数リスト 。 CODESYS 追加します GVL アプリケーションの下のデバイスツリーで、エディターで開きます。 メニューコマンドを選択します 編集→変数の宣言 。 対話 変数を宣言する 開きます。 選択リストから選択 範囲 エントリ VAR_GLOBAL 。 ボックスに入力します 姓 グローバル変数の名前を入力します。 選択リストから選択 データ・タイプ データ型。 変数にデフォルトの初期化値と...", 
"body" : "要件：プロジェクトが開いています。 プロジェクトのデバイスツリーで、グローバル変数を有効にするアプリケーションを選択します。 コンテキストメニューコマンドを選択します オブジェクトの追加→グローバル変数リスト 。 CODESYS 追加します GVL アプリケーションの下のデバイスツリーで、エディターで開きます。 メニューコマンドを選択します 編集→変数の宣言 。 対話 変数を宣言する 開きます。 選択リストから選択 範囲 エントリ VAR_GLOBAL 。 ボックスに入力します 姓 グローバル変数の名前を入力します。 選択リストから選択 データ・タイプ データ型。 変数にデフォルトの初期化値とは異なる初期化値を設定する場合は、をクリックします。 フィールドの横 初期化値 。 対話 初期化値 開きます。 セルをダブルクリックします 初期化値 変数の値を入力し、目的の有効な値を入力します。 クリック わかった 。 初期化値がダイアログに表示されます 変数を宣言する 表示されます。 必要に応じて、 フラグ 。 ボタンをクリックしてエントリを確認します わかった 。 CODESYS 宣言された変数をGVLに挿入します。 グローバル変数は、プロジェクトのアプリケーション全体で使用できます。 " }, 
{ "title" : "プロジェクト全体で利用可能なグローバル変数を定義する ", 
"url" : "_cds_defining_global_variables.html#UUID-73312950-d699-07b8-bbc0-46660b31cccc_id_a1822005ba31dc0a8640e004a22fb_id_b297ff7624c9bb1cc0a8640e01b4eaa9", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 \/ グローバル変数を宣言する \/ プロジェクト全体で利用可能なグローバル変数を定義する ", 
"snippet" : "メニューコマンドを選択します 表示→POU 。 景色 POU 開きます。 ビューで選択 POU プロジェクト名の最上位ノードを選択し、コンテキストメニューコマンドを選択します オブジェクトの追加→グローバル変数リスト 。 CODESYS 追加します GVL ビューで POU メモ帳で開きます。 メニューコマンドを選択します 編集→変数の宣言 。 対話 変数を宣言する 開きます。 選択リストから選択 範囲 エントリ VAR_GLOBAL 。 ボックスに入力します 姓 グローバル変数の名前を入力します。 選択リストから選択 データ・タイプ データ型。 変数の初期化値をデフォルトの初期化値とは異なる...", 
"body" : "メニューコマンドを選択します 表示→POU 。 景色 POU 開きます。 ビューで選択 POU プロジェクト名の最上位ノードを選択し、コンテキストメニューコマンドを選択します オブジェクトの追加→グローバル変数リスト 。 CODESYS 追加します GVL ビューで POU メモ帳で開きます。 メニューコマンドを選択します 編集→変数の宣言 。 対話 変数を宣言する 開きます。 選択リストから選択 範囲 エントリ VAR_GLOBAL 。 ボックスに入力します 姓 グローバル変数の名前を入力します。 選択リストから選択 データ・タイプ データ型。 変数の初期化値をデフォルトの初期化値とは異なるものにする場合は、それを列に入力します 初期化 1。 必要に応じて、 フラグ 。 ボタンをクリックしてエントリを確認します わかった 。 CODESYS 宣言された変数をGVLに挿入します。 これで、プロジェクト全体でグローバル変数を使用できます。 " }, 
{ "title" : "タスクローカル変数を使用する ", 
"url" : "_cds_define_task_local_global_variable_list.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 \/ タスクローカル変数を使用する ", 
"snippet" : "タスクローカル変数はサイクル整合性があります。これらは、タスクサイクル内の1つの定義されたタスクによってのみ書き込まれますが、他のすべてのタスクはそれらに読み取りアクセスすることしかできません。タスクが他のタスクによって中断されたり、同時に実行されたりする可能性があることを考慮に入れています。サイクルの一貫性は、アプリケーションがマルチコアプロセッサを搭載したシステムで実行されている場合にも特に当てはまります。 したがって、タスクローカルグローバル変数リストを使用すると、複数のタスクが同じ変数を編集するときに、（コンパイラによって）自動的に同期を取得できます。これは、通常のGVLを使用する場合...", 
"body" : "タスクローカル変数はサイクル整合性があります。これらは、タスクサイクル内の1つの定義されたタスクによってのみ書き込まれますが、他のすべてのタスクはそれらに読み取りアクセスすることしかできません。タスクが他のタスクによって中断されたり、同時に実行されたりする可能性があることを考慮に入れています。サイクルの一貫性は、アプリケーションがマルチコアプロセッサを搭載したシステムで実行されている場合にも特に当てはまります。 したがって、タスクローカルグローバル変数リストを使用すると、複数のタスクが同じ変数を編集するときに、（コンパイラによって）自動的に同期を取得できます。これは、通常のGVLを使用する場合には当てはまりません。複数のタスクが、1サイクル中に通常のGVL変数に同時に書き込むことができます。 ただし、タスクローカル変数の同期は比較的時間がかかり、メモリを大量に消費するため、すべてのアプリケーションで適切な手段ではないことに注意してください。決定に役立つ詳細な技術情報とベストプラクティスのアドバイスについては、以下を参照してください。 の中に CODESYS プロジェクト、 グローバル変数リスト (tasklocal) オブジェクトは、タスクローカル変数を定義するために使用できます。構文的には、通常の GVL に対応しますが、変数への書き込みアクセス権を持つタスクの情報も含まれています。そのため、このような GVL 内のすべての変数は、タスクのサイクル中に別のタスクによって変更されることはありません。 タスクローカル変数は、オンラインモードでは値を変更できない複雑な変数です。 値を書き込む 指示。 次のセクションでは、タスクローカル変数の原理と機能を示す簡単な例を示します。書き込みプログラムと読み取りプログラムがあります。プログラムは異なるタスクで実行されますが、タスクローカルグローバル変数リストにある同じデータにアクセスして、サイクル一貫して処理されるようにします。 " }, 
{ "title" : "例に示されている機能 ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_1bdc324663bd9d69c0a8646318878847", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 \/ タスクローカル変数を使用する \/ 例に示されている機能 ", 
"snippet" : "このサンプルアプリケーションを再プログラミングする手順は、以下にあります。 サンプルアプリケーション (* task-local GVL, object name: \"Tasklocals\" *) VAR_GLOBAL g_diaData : ARRAY [0..99] OF DINT; END_VAR PROGRAM ReadData VAR diIndex : DINT; bTest : BOOL; diValue : DINT; END_VAR bTest := TRUE; diValue := TaskLocals.g_diaData[0]; FOR diIndex := 0 TO 9...", 
"body" : "このサンプルアプリケーションを再プログラミングする手順は、以下にあります。 サンプルアプリケーション (* task-local GVL, object name: \"Tasklocals\" *)\nVAR_GLOBAL\n g_diaData : ARRAY [0..99] OF DINT;\nEND_VAR\n\nPROGRAM ReadData\nVAR\n diIndex : DINT;\n bTest : BOOL;\n diValue : DINT;\nEND_VAR\nbTest := TRUE;\ndiValue := TaskLocals.g_diaData[0];\nFOR diIndex := 0 TO 99 DO\n bTest := bTest AND (diValue = Tasklocals.g_diaData[diIndex]);\nEND_FOR\n\nPROGRAM WriteData\nVAR\n diIndex : DINT;\n diCounter : DINT;\nEND_VAR\ndiCounter := diCounter + 1;\nFOR diIndex := 0 TO 99 DO\n Tasklocals.g_diaData[diIndex] := diCounter;\nEND_FOR プログラム WriteData と ReadData さまざまなタスクによって呼び出されます。 プログラム中 WriteData 配列になります g_diaData 値でいっぱい。プログラム ReadData 配列の値が期待どおりかどうかをテストします。この場合、変数は次のようになります。 bTest 結果として TRUE 。 テストされている配列データは変数に関するものです g_diaData オブジェクト内 Tasklocals タイプの Globale Variablenliste (tasklokal) 宣言した。これにより、コンパイラーでのデータアクセスが同期され、アクセスするプログラムが異なるタスクから呼び出された場合でも、データはサイクル整合性が保証されます。サンプルプログラムでは、これは具体的には変数が test プログラムで ReadData いつも TRUE は。 変数の場合 g_diaData この例では、グローバル変数リストとしてのみ宣言されています。テスト、つまり変数 test プログラムで ReadData 、より頻繁に FALSE 配達。この場合、 FOR -ループは他のタスクによって中断される可能性があります。または、両方のタスクが同時に実行される可能性があります（マルチコアコントローラー）。したがって、リーダーがリストを読んでいる間に、ライターが値を変更する可能性があります。 " }, 
{ "title" : "宣言の制限 ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_61f1e5de6a954123c0a86463531788fb", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 \/ タスクローカル変数を使用する \/ 宣言の制限 ", 
"snippet" : "タスクローカル変数のリストの宣言に変更が加えられた後は、アプリケーションをオンラインで変更することはできません。 グローバルタスクローカル変数リストを宣言するときは、次の点に注意してください。 AT宣言を介して直接アドレスを割り当てないでください。 PLC構成のローカルタスク変数にマップしないでください。 ポインタを宣言しないでください。 参照を宣言しないでください。 機能ブロックをインスタンス化しないでください。 タスクローカル変数を同時に宣言しないでください PERSISTENT と RETAIN 。 書き込み許可のないタスクでの書き込みアクセスは、コンパイラーによってエラーとして報告され...", 
"body" : "タスクローカル変数のリストの宣言に変更が加えられた後は、アプリケーションをオンラインで変更することはできません。 グローバルタスクローカル変数リストを宣言するときは、次の点に注意してください。 AT宣言を介して直接アドレスを割り当てないでください。 PLC構成のローカルタスク変数にマップしないでください。 ポインタを宣言しないでください。 参照を宣言しないでください。 機能ブロックをインスタンス化しないでください。 タスクローカル変数を同時に宣言しないでください PERSISTENT と RETAIN 。 書き込み許可のないタスクでの書き込みアクセスは、コンパイラーによってエラーとして報告されます。ただし、書き込み権が侵害されている場所をすべて特定することはできません。コンパイラーは、静的呼び出しのみをタスクに割り当てることができます。ただし、たとえば、ポインタまたはインタフェースを介して機能ブロックを呼び出すことは、タスクに割り当てられません。これは、書き込みアクセスもそこに記録されないことを意味します。さらに、ポインターはタスクローカル変数を指すことができます。このようにして、データは読み取りタスクで操作できます。この場合、ランタイムエラーも発行されません。ただし、ポインタを介してアクセスするときに変更された値は、変数の共通参照にコピーされません。 " }, 
{ "title" : "タスクのプロパティ-ローカルグローバル変数と考えられる動作 ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_6eb169fa44f608dfc0a864631eeb1091", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 \/ タスクローカル変数を使用する \/ タスクのプロパティ-ローカルグローバル変数と考えられる動作 ", 
"snippet" : "変数は、異なるアドレスの各タスクのリストにあります。つまり、読み取りアクセスの場合： ADR(variable name) タスクごとに異なるアドレスを返します。 同期メカニズムは、次のことを保証します。 サイクルの一貫性 ロック状態からの解放：タスクが別のタスクによるアクションを待機することはありません。 ただし、この方法を使用して、読み取りタスクが書き込みタスクのコピーを確実に受信する時点を決定することはできません。原則として、コピーは発散する可能性があります。上記の例では、書き込まれたすべてのコピーがリーダーによって一度編集されるとは限りません。たとえば、読み取りタスクは同じ配列を数サイ...", 
"body" : "変数は、異なるアドレスの各タスクのリストにあります。つまり、読み取りアクセスの場合： ADR(variable name) タスクごとに異なるアドレスを返します。 同期メカニズムは、次のことを保証します。 サイクルの一貫性 ロック状態からの解放：タスクが別のタスクによるアクションを待機することはありません。 ただし、この方法を使用して、読み取りタスクが書き込みタスクのコピーを確実に受信する時点を決定することはできません。原則として、コピーは発散する可能性があります。上記の例では、書き込まれたすべてのコピーがリーダーによって一度編集されるとは限りません。たとえば、読み取りタスクは同じ配列を数サイクル処理したり、配列の内容は2サイクルの間で1つ以上の値を「スキップ」したりできます。両方が発生する可能性があり、考慮する必要があります。 書き込みタスクは、各読み取りタスクによる共通参照への2つのアクセス間の1サイクルの間保持できます。つまり、 n 読み取りタスクが存在し、書き込みタスク n サイクルは、共有参照の次の更新まで遅延されます。 読み取りタスクは、書き込みタスクによって各サイクルで読み取りコピーを取得することを防ぐことができます。したがって、読み取りタスクが確実にコピーを受け取るまでの最大サイクル数を指定することはできません。 特に、実行速度が非常に遅いタスクが含まれる場合、これは問題になる可能性があります。タスクが1時間ごとにのみ実行され、タスクローカル変数にアクセスできないと仮定すると、タスクはリストの非常に古いコピーで動作しています。したがって、タスクローカル変数にタイムスタンプを挿入することは理にかなっています。これは、読み取りタスクが少なくともリストが最新であるかどうかを判断するために使用できます。次のようにタイムスタンプを追加できます。タスクローカル変数のリストにタイプの変数を追加します。 LTIME たとえば、書き込みタスクでは、次のコードを使用します。 tasklocal.g_timestamp := LTIME(); 。 " }, 
{ "title" : "ベストプラクティス ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_201eb4c744f608dfc0a86463690c31a3", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 \/ タスクローカル変数を使用する \/ ベストプラクティス ", 
"snippet" : "タスクローカル変数は、「単一のライター-複数のリーダー」のユースケース向けに設計されています。さまざまなタスクによって呼び出されるコードを実装する場合、タスクローカル変数を使用すると非常に便利です。たとえば、これは上記のサンプルアプリケーションの場合です。 appTasklocal すべてが同じ配列にアクセスし、同じ関数を使用する複数の読み取りタスクによって拡張される場合。 タスクローカル変数は、マルチコアプロセッサを搭載したシステムで特に役立ちます。これらのシステムでは、優先度によってタスクを同期することはできません。次に、他の同期メカニズムが必要になります。 読み取りタスクが常に変数の最新...", 
"body" : "タスクローカル変数は、「単一のライター-複数のリーダー」のユースケース向けに設計されています。さまざまなタスクによって呼び出されるコードを実装する場合、タスクローカル変数を使用すると非常に便利です。たとえば、これは上記のサンプルアプリケーションの場合です。 appTasklocal すべてが同じ配列にアクセスし、同じ関数を使用する複数の読み取りタスクによって拡張される場合。 タスクローカル変数は、マルチコアプロセッサを搭載したシステムで特に役立ちます。これらのシステムでは、優先度によってタスクを同期することはできません。次に、他の同期メカニズムが必要になります。 読み取りタスクが常に変数の最新のコピーで機能する必要がある場合は、タスクローカル変数を使用しないでください。ローカルタスク変数はこれには適していません。 同様の問題は「生産者-消費者」問題です。これは、タスクがデータを生成し、2番目のタスクがそれを処理する場合です。このコンステレーションでは、別のタイプの同期を優先します。たとえば、プロデューサーはフラグを使用して、新しい日付が利用可能であることを示すことができます。コンシューマーは、2番目のフラグを使用して、データを処理し、新しい入力を待機していることを示すことができます。どちらも同じデータで機能します。データの循環コピーのオーバーヘッドはなく、コンシューマーはプロデューサーによって生成されたデータを失うことはありません。 " }, 
{ "title" : "モニタリング ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_ce0845ad44f608dfc0a8646329c0a4d8", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 \/ タスクローカル変数を使用する \/ モニタリング ", 
"snippet" : "実行時に、メモリ内にタスクローカル変数リストのいくつかの、場合によっては異なるコピーがあります。ただし、位置を監視するときにすべての値を表示できるわけではありません。このため、共通参照からの値は、インラインモニタリング、モニタリングリスト、および視覚化でタスクローカル変数に表示されます。 ブレークポイントを設定すると、ブレークポイントに到達して停止したタスクのデータが表示されます。その間、他のタスクは実行を続けます。特定の状況下では、共通コピーを変更できます。ただし、停止したタスクのコンテキストでは、値は変更されないままであり、そのように表示されます。これに注意する必要があります。...", 
"body" : "実行時に、メモリ内にタスクローカル変数リストのいくつかの、場合によっては異なるコピーがあります。ただし、位置を監視するときにすべての値を表示できるわけではありません。このため、共通参照からの値は、インラインモニタリング、モニタリングリスト、および視覚化でタスクローカル変数に表示されます。 ブレークポイントを設定すると、ブレークポイントに到達して停止したタスクのデータが表示されます。その間、他のタスクは実行を続けます。特定の状況下では、共通コピーを変更できます。ただし、停止したタスクのコンテキストでは、値は変更されないままであり、そのように表示されます。これに注意する必要があります。 " }, 
{ "title" : "背景：技術的な実装 ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_0d2b15ad44f608dfc0a864634268e60b", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 \/ タスクローカル変数を使用する \/ 背景：技術的な実装 ", 
"snippet" : "タスクローカル変数のリストについては、コンパイラーは各タスクのコピーとすべてのタスクの共通参照コピーを作成します。タスクローカル変数のリストと同じ変数を含む構造が作成されます。この構造の配列も作成され、タスクごとに配列の次元が作成されます。したがって、配列要素はタスクごとにインデックスが付けられます。リストの変数がコードでアクセスされるようになった場合、リストのタスクローカルコピーが実際にアクセスされます。さらに、ブロックが現在実行されているタスクが判別され、それに応じてアクセスにインデックスが付けられます。 たとえば、コード行 diValue := TaskLocals.g_diaData[...", 
"body" : "タスクローカル変数のリストについては、コンパイラーは各タスクのコピーとすべてのタスクの共通参照コピーを作成します。タスクローカル変数のリストと同じ変数を含む構造が作成されます。この構造の配列も作成され、タスクごとに配列の次元が作成されます。したがって、配列要素はタスクごとにインデックスが付けられます。リストの変数がコードでアクセスされるようになった場合、リストのタスクローカルコピーが実際にアクセスされます。さらに、ブロックが現在実行されているタスクが判別され、それに応じてアクセスにインデックスが付けられます。 たとえば、コード行 diValue := TaskLocals.g_diaData[0]; 上記の例から置き換えられました： diValue := __TaskLocalVarsArray[__CURRENTTASK.TaskIndex].__g_diarr[0]; __CURRENTTASK abの演算子です CODESYS V3.5 SP13は、現在のタスクインデックスをすばやく決定するために使用できます。 実行時に、タスクローカルリストのコンテンツは、書き込みタスクの最後に共通参照にコピーされます。読み取りタスクの場合、共通参照の内容は最初にタスクローカルコピーにコピーされます。したがって、n個のタスクのリストのn + 1個のコピーがあります。リストは共通の参照として機能し、さらに各タスクには独自のリストのコピーがあります。 スケジューラーは、複数のタスクのタイムリーな実行、つまりタスクの切り替えを制御します。実行時間の割り当てを制御するためにスケジューラーが従う戦略は、タスクのブロックを回避することを目的としています。したがって、同期メカニズムはタスクローカル変数のプロパティに対して最適化されているため、ブロッキング状態（ロック状態）が回避され、タスクは別のタスクのアクションを待機しません。 同期戦略： 書き込みタスクが共有参照にコピーを書き戻す限り、読み取りタスクはいずれもコピーを取得しません。 読み取りタスクが共有参照からコピーをフェッチする限り、書き込みタスクはコピーを書き戻しません。 " }, 
{ "title" : "上記のサンプルアプリケーションを作成するための手順 ", 
"url" : "_cds_define_task_local_global_variable_list.html#UUID-f67e2acf-c661-2bd7-14ce-4f09dd707187_id_d18e01b449f3a86c0a864630f790f9e_id_b297ff7624c9bb1cc0a8640e01b4eaa9", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 変数宣言 \/ タスクローカル変数を使用する \/ 上記のサンプルアプリケーションを作成するための手順 ", 
"snippet" : "目的：プログラムから始めたい ReadData プログラムがアクセスするのと同じデータにアクセスする WriteData 書かれる。 2つのプログラムは異なるタスクで実行する必要があります。データをタスクローカル変数リストに指定して、サイクル一貫して自動的に処理されるようにします。 要件：標準プロジェクトが新たに作成され、エディターで開かれます。 アプリケーションの名前を Application の appTasklocal その周り。 以下に追加 appTasklocal 名前によるSTのプログラム ReadData 追加した。 以下に追加 appTasklocal 名前によるSTの別のプロ...", 
"body" : "目的：プログラムから始めたい ReadData プログラムがアクセスするのと同じデータにアクセスする WriteData 書かれる。 2つのプログラムは異なるタスクで実行する必要があります。データをタスクローカル変数リストに指定して、サイクル一貫して自動的に処理されるようにします。 要件：標準プロジェクトが新たに作成され、エディターで開かれます。 アプリケーションの名前を Application の appTasklocal その周り。 以下に追加 appTasklocal 名前によるSTのプログラム ReadData 追加した。 以下に追加 appTasklocal 名前によるSTの別のプログラム WriteData 追加した。 デフォルトのタスクに名前を付ける MainTask オブジェクトの下 Taskkonfiguration の Read その周り。 対話を追加する 構成 タスク Read ボタン経由 通話を追加 プログラムを呼び出す ReadData 追加した。 オブジェクトの下に貼り付けます タスク構成 で名前が付けられた別のタスクを追加しました Write このタスクにプログラム呼び出しを追加します Write 追加した。 タスク構成に2つのタスクがあります Write と Read 誰がプログラム WriteData それぞれ ReadData 電話。 アプリケーションを選択します appTasklocal タイプのオブジェクトを追加します グローバル変数リスト（タスクローカル） 追加した。 対話 グローバル変数リスト（タスクローカル）を追加します。 開きます。 名前として入力 Tasklocals 1。 ドロップダウンリストから選択します 書き込みアクセス権のあるタスク タスク Write 。 アプリケーション内でローカルタスク変数を使用するためのオブジェクト構造が完成しました。これで、上記の例の説明に示されているようにオブジェクトをコーディングできます。 " }, 
{ "title" : "IECでソースコードを作成する ", 
"url" : "_cds_f_programming_pous.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ IECでソースコードを作成する ", 
"snippet" : "ソースコード： 「ソースコード」とは、適切なプログラミング言語エディタを使用してプログラミングブロックに挿入する実装コードを意味します。次のブロックタイプを使用できます：POU（プログラム、機能、機能ブロック）、アクション、メソッド、プロパティ、インターフェイス。 プログラミング言語： プログラミングモジュールを作成するときは、プログラミングする実装言語を決定します。 IEC言語に加えて、CFCも利用できます。 プログラミング言語エディター： デバイスツリーまたは POU ツリーでオブジェクトをダブルクリックすると、POU が開き、それぞれのプログラミング言語エディタで編集できます。すると、P...", 
"body" : "ソースコード： 「ソースコード」とは、適切なプログラミング言語エディタを使用してプログラミングブロックに挿入する実装コードを意味します。次のブロックタイプを使用できます：POU（プログラム、機能、機能ブロック）、アクション、メソッド、プロパティ、インターフェイス。 プログラミング言語： プログラミングモジュールを作成するときは、プログラミングする実装言語を決定します。 IEC言語に加えて、CFCも利用できます。 プログラミング言語エディター： デバイスツリーまたは POU ツリーでオブジェクトをダブルクリックすると、POU が開き、それぞれのプログラミング言語エディタで編集できます。すると、POU がテキスト ST エディタ、または FBD\/LD、SFC、CFC のグラフィカルエディタのいずれかに表示されます。各エディタは 2 つのウィンドウで構成されています。上のウィンドウでは、テキスト形式または表形式の設定に応じて、宣言を行います。下のウィンドウに、実装コードを挿入します。プロジェクト全体の各エディタの外観と動作は、の対応するタブで設定できます CODESYS オプション。 詳細については、以下を参照してください。 プログラミング言語とエディターCODESYS LD FBD CODESYS SFC CODESYS CFC " }, 
{ "title" : "構造化テキスト（ST）、拡張構造化テキスト（ExST） ", 
"url" : "_cds_f_programming_language_st.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ IECでソースコードを作成する \/ 構造化テキスト（ST）、拡張構造化テキスト（ExST） ", 
"snippet" : "STエディタは、IEC-61131-3プログラミング言語の構造化テキスト（ST）および拡張構造化テキストでPOUをプログラムするために使用されます。拡張構造化テキストは、IEC-61131-3規格に関していくつかの追加機能を提供します。 構造化テキストはプログラミング言語であり、CやPASCALなどの他の高級言語に匹敵し、複雑なアルゴリズムの開発を可能にします。プログラムコードは、 表現するために と 手順 、条件付き（IF ... THEN ... ELSE）またはループ（WHILE ... DO）で実行することもできます。 式は、評価された後に値を返す構造です。式は、演算子であり、オペラン...", 
"body" : "STエディタは、IEC-61131-3プログラミング言語の構造化テキスト（ST）および拡張構造化テキストでPOUをプログラムするために使用されます。拡張構造化テキストは、IEC-61131-3規格に関していくつかの追加機能を提供します。 構造化テキストはプログラミング言語であり、CやPASCALなどの他の高級言語に匹敵し、複雑なアルゴリズムの開発を可能にします。プログラムコードは、 表現するために と 手順 、条件付き（IF ... THEN ... ELSE）またはループ（WHILE ... DO）で実行することもできます。 式は、評価された後に値を返す構造です。式は、演算子であり、オペランドでもあります。割り当てを式として使用することもできます。オペランドは、定数、変数、関数呼び出し、または別の式にすることができます。 ステートメントは、式の処理方法を制御します。 このテキストエディタでは、ダイアログで次のことができます オプション と 調整 メニューの ツール 動作、外観、メニューに関するさまざまな設定を行います。このエディターでは、よく知られているWindows機能も利用できます（IntelliMouseなど）。 詳細については、以下を参照してください。 構造化テキスト（ST）でのプログラミング" }, 
{ "title" : "ExST-拡張構造化テキスト ", 
"url" : "_cds_f_programming_language_st.html#UUID-c0b48aaa-9e6c-d5d3-e0a2-ddaf98d1688a_section-idm4538086976966432654794828895", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ IECでソースコードを作成する \/ 構造化テキスト（ST）、拡張構造化テキスト（ExST） \/ ExST-拡張構造化テキスト ", 
"snippet" : "拡張構造化テキスト（ExST）は CODESYS -構造化テキスト（ST）のIEC61131-3標準に関する特定の拡張。 詳細については、以下を参照してください。 課題...", 
"body" : "拡張構造化テキスト（ExST）は CODESYS -構造化テキスト（ST）のIEC61131-3標準に関する特定の拡張。 詳細については、以下を参照してください。 課題" }, 
{ "title" : "構造化テキスト（ST）でのプログラミング ", 
"url" : "_cds_programming_in_st.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ IECでソースコードを作成する \/ 構造化テキスト（ST）、拡張構造化テキスト（ExST） \/ 構造化テキスト（ST）でのプログラミング ", 
"snippet" : "構造化テキスト（ST）実装言語でのPOUの作成 デバイスツリーでアプリケーションを選択します。 コマンドを選択します プロジェクト→オブジェクトの追加→POU 。 対話 POUを追加する 開きます。 名前を入力して、 実装言語 構造化テキスト（ST） 。 クリック 追加 。 POUがデバイスツリーに追加され、エディターで開かれます。 次に、POUの上部に変数宣言を挿入し、POUの下部にSTプログラムコードを入力します。...", 
"body" : "構造化テキスト（ST）実装言語でのPOUの作成 デバイスツリーでアプリケーションを選択します。 コマンドを選択します プロジェクト→オブジェクトの追加→POU 。 対話 POUを追加する 開きます。 名前を入力して、 実装言語 構造化テキスト（ST） 。 クリック 追加 。 POUがデバイスツリーに追加され、エディターで開かれます。 次に、POUの上部に変数宣言を挿入し、POUの下部にSTプログラムコードを入力します。 " }, 
{ "title" : "原理 ", 
"url" : "_cds_programming_in_st.html#UUID-2076ef08-fb89-b7e5-586c-5a99b07f8d18_id_a941afccf6c2c2c0a8640e010636b9_id_dc652380fd1509c7c0a8640e015d35d3", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ IECでソースコードを作成する \/ 構造化テキスト（ST）、拡張構造化テキスト（ExST） \/ 構造化テキスト（ST）でのプログラミング \/ 原理 ", 
"snippet" : "STエディタでプログラミング言語「StructuredText」と「ExtendedStructuredText」をプログラムします。プログラムコードは、条件付きまたはループで実行することもできる式とステートメントの組み合わせで構成されています。あなたが1つで必要なすべての指示 ; 施錠する。 変数は宣言エディターで宣言されます。...", 
"body" : "STエディタでプログラミング言語「StructuredText」と「ExtendedStructuredText」をプログラムします。プログラムコードは、条件付きまたはループで実行することもできる式とステートメントの組み合わせで構成されています。あなたが1つで必要なすべての指示 ; 施錠する。 変数は宣言エディターで宣言されます。 " }, 
{ "title" : "オンライン変更用のメモリリザーブを構成する ", 
"url" : "_cds_configuring_memory_reserve.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オンライン変更用のメモリリザーブを構成する ", 
"snippet" : "オンライン変更中に機能ブロックインスタンスを新しいメモリ位置にコピーする必要をなくすために、メモリリザーブを使用して機能ブロックを構成できます。これは、関数ブロックへの変数の追加など、宣言を変更したときに発生する可能性があります。メモリリザーブを使用すると、このようなオンライン変更の実行が速くなり、問題の発生が少なくなります。メモリリザーブが使い果たされると、オンライン変更が実行される前にメッセージが表示されます。 アプリケーションを初めてコントローラにダウンロードする前に、機能ブロックのメモリリザーブを設定することをお勧めします。アプリケーションがすでにコントローラ上にあるときにのみメモリリ...", 
"body" : "オンライン変更中に機能ブロックインスタンスを新しいメモリ位置にコピーする必要をなくすために、メモリリザーブを使用して機能ブロックを構成できます。これは、関数ブロックへの変数の追加など、宣言を変更したときに発生する可能性があります。メモリリザーブを使用すると、このようなオンライン変更の実行が速くなり、問題の発生が少なくなります。メモリリザーブが使い果たされると、オンライン変更が実行される前にメッセージが表示されます。 アプリケーションを初めてコントローラにダウンロードする前に、機能ブロックのメモリリザーブを設定することをお勧めします。アプリケーションがすでにコントローラ上にあるときにのみメモリリザーブを設定する場合は、時間のかかるオンライン変更が必要です。 " }, 
{ "title" : "機能ブロックのオンライン変更用のメモリリザーブを設定します ", 
"url" : "_cds_configuring_memory_reserve.html#UUID-37b7c569-d1f3-f5d0-0328-3e84514c76a6_id_e907096bc90bbc0a8646334d3dfea_id_6b7a234396c8490fc0a86463751c1541", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オンライン変更用のメモリリザーブを構成する \/ 機能ブロックのオンライン変更用のメモリリザーブを設定します ", 
"snippet" : "将来、プロジェクトの機能ブロックに大きな変更が加えられ、オンライン変更中に機能ブロックインスタンスが他の保存場所にコピーされる可能性があります。 要件：理想的には、開いているプロジェクトはまだコントローラー上にありません。 コマンドを選択します 表示→ オンライン変更のためのメモリリザーブの設定 。 景色 オンライン変更のためのメモリリザーブ 開きます。 選択リストからプロジェクトのアプリケーションを選択します。 コマンドを選択します 作成→翻訳 。 ボタンをクリックします 検索アプリケーション 。 エリアで選択 ファンクションブロック エントリ 全て 。 アプリケーションのすべての機能ブロッ...", 
"body" : "将来、プロジェクトの機能ブロックに大きな変更が加えられ、オンライン変更中に機能ブロックインスタンスが他の保存場所にコピーされる可能性があります。 要件：理想的には、開いているプロジェクトはまだコントローラー上にありません。 コマンドを選択します 表示→ オンライン変更のためのメモリリザーブの設定 。 景色 オンライン変更のためのメモリリザーブ 開きます。 選択リストからプロジェクトのアプリケーションを選択します。 コマンドを選択します 作成→翻訳 。 ボタンをクリックします 検索アプリケーション 。 エリアで選択 ファンクションブロック エントリ 全て 。 アプリケーションのすべての機能ブロックがビューに表示されます。 メモリリザーブを設定する適切な機能ブロックを選択します。 アプリケーションがまだコントローラー上にない場合、入力フィールドは次のようになります。 メモリリザーブ （バイト単位）編集可能。 アプリケーションがすでにコントローラー上にある場合は、ボタンをクリックします 編集するには エリア内 編集を許可する 。 すでにコントローラ上にあるアプリケーションのメモリリザーブを変更する場合は、影響を受けるすべての機能ブロックのインスタンスをメモリにコピーする必要があることに注意してください。 メモリリザーブのサイズをバイト単位で入力し、をクリックします 選択に適用 。 入力したバイト数がテーブルのフィールドに表示されます メモリリザーブ 表示されます。 コマンドを選択します 作成→翻訳 次にボタンをクリックします 検索アプリケーション 。 設定された機能ブロックの機能ブロックリストで、情報 サイズ 、 インスタンス数 、 すべてのインスタンスの追加メモリ と ストレージリザーブの残り量 更新しました。 ここでアプリケーションをコントローラーにロードすると、機能ブロックインスタンスが必要なメモリとメモリリザーブを占有します。したがって、機能ブロックに対する将来の主要な変更は、メモリ内の機能ブロックのすべてのインスタンスをコピーする必要なしに、オンライン変更を介してコントローラにロードできます。 " }, 
{ "title" : "外部実装を使用して汎用モジュール、関数、またはメソッドを呼び出します ", 
"url" : "_cds_calling_fb_function_method_with_external_implementation.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 外部実装を使用して汎用モジュール、関数、またはメソッドを呼び出します ", 
"snippet" : "ランタイムシステムには、たとえばライブラリからの関数ブロック、関数、またはメソッドの実装を含めることができます。アプリケーションで同じ名前のPOUをプロパティとともに使用する場合 外部実装 実装を作成せずに、既存の実装を実行できます。外部関数ブロックでのみローカル変数を宣言することに注意してください。外部関数またはメソッドにローカル変数を含めることはできません。 アプリケーションのダウンロード中に検索 CODESYS 外部POUごとに、ランタイムシステムの関連する実装とリンクします。 プロパティを持つオブジェクト 外部実装 表示されています 装置 また POU 追加を通じて (EXT) オブジ...", 
"body" : "ランタイムシステムには、たとえばライブラリからの関数ブロック、関数、またはメソッドの実装を含めることができます。アプリケーションで同じ名前のPOUをプロパティとともに使用する場合 外部実装 実装を作成せずに、既存の実装を実行できます。外部関数ブロックでのみローカル変数を宣言することに注意してください。外部関数またはメソッドにローカル変数を含めることはできません。 アプリケーションのダウンロード中に検索 CODESYS 外部POUごとに、ランタイムシステムの関連する実装とリンクします。 プロパティを持つオブジェクト 外部実装 表示されています 装置 また POU 追加を通じて (EXT) オブジェクト名の後にマークされています。 詳細については、以下を参照してください。 建てる外部実装でメソッドを作成する デバイスツリーまたはPOUビューで機能ブロックを選択します。 選ぶ オブジェクトの追加→メソッド ランタイムシステムの関連する実装の名前を名前として入力します。でダイアログを終了します 追加 。 メソッドが作成されます。 メソッドを選択し、コンテキストメニューでアクティブにします プロパティ 。 ダイアログが開きます。 タブを選択します 翻訳すること 。 オプションを有効にする 外部実装（ランタイムシステムでの遅延リンク） 。 メソッドが宣言され、メソッドの呼び出しを実装できます。ビューのメソッド名 装置 またはビューで POU 追加であります (EXT) 間違い。 " }, 
{ "title" : "外部実装でPOUを作成する ", 
"url" : "_cds_calling_fb_function_method_with_external_implementation.html#UUID-fff6ac80-1b8a-7912-4b20-ed87a85fdbb5_id_c98ff0280307e532c0a8640e0065769d_id_3b8dd10723c74a66c0a8640e01935197", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 外部実装を使用して汎用モジュール、関数、またはメソッドを呼び出します \/ 外部実装でPOUを作成する ", 
"snippet" : "選ぶ プロジェクト→オブジェクトの追加→POU 。 活性化 汎用モジュール 、メソッドまたは 関数 ランタイムシステムの関連する実装の名前を名前として入力します。ダイアログを終了します。 追加 。 ランタイムシステムPOUの名前を持つPOUがビューに表示されます POU 作成した。名前は追加であります (EXT) 間違い。 POUを選択し、コンテキストメニューでアクティブ化します プロパティ 。 ダイアログが開きます。 タブを選択します 翻訳すること 。 オプションを有効にする 外部実装（ランタイムシステムでの遅延リンク） 。 POUが宣言され、POUへの呼び出しを実装できます。...", 
"body" : "選ぶ プロジェクト→オブジェクトの追加→POU 。 活性化 汎用モジュール 、メソッドまたは 関数 ランタイムシステムの関連する実装の名前を名前として入力します。ダイアログを終了します。 追加 。 ランタイムシステムPOUの名前を持つPOUがビューに表示されます POU 作成した。名前は追加であります (EXT) 間違い。 POUを選択し、コンテキストメニューでアクティブ化します プロパティ 。 ダイアログが開きます。 タブを選択します 翻訳すること 。 オプションを有効にする 外部実装（ランタイムシステムでの遅延リンク） 。 POUが宣言され、POUへの呼び出しを実装できます。 " }, 
{ "title" : "入力アシスタンスを使用する ", 
"url" : "_cds_using_input_assistants.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 入力アシスタンスを使用する ", 
"snippet" : "CODESYS には、プログラム作成時のコーディングに役立つツールと機能が用意されています。 スマートタグ機能 スマートタグを使用すると、適切なコマンドをプログラミング要素に直接提案できるため、プログラムコードを簡単に記述できます。スマートタグ機能を持つプログラミング要素の上にカーソルを置くと、 シンボルが表示されます。 記号をクリックすると、選択できるコマンドが表示されます。使用可能なスマートタグ: スマートタグ機能により、 自動宣言 ST エディタの実装部分にある宣言されていない変数用のコマンド。...", 
"body" : "CODESYS には、プログラム作成時のコーディングに役立つツールと機能が用意されています。 スマートタグ機能 スマートタグを使用すると、適切なコマンドをプログラミング要素に直接提案できるため、プログラムコードを簡単に記述できます。スマートタグ機能を持つプログラミング要素の上にカーソルを置くと、 シンボルが表示されます。 記号をクリックすると、選択できるコマンドが表示されます。使用可能なスマートタグ: スマートタグ機能により、 自動宣言 ST エディタの実装部分にある宣言されていない変数用のコマンド。 " }, 
{ "title" : "入力アシスタント ", 
"url" : "_cds_using_input_assistants.html#UUID-c64e3633-b2dc-8e9f-0533-6676df90609a_id_fbe6a158721888c0a8640e00a479cd_id_10730b9a8290a9e9c0a8640e006261df", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 入力アシスタンスを使用する \/ 入力アシスタント ", 
"snippet" : "入力アシスタントは、現在のカーソル位置に挿入できるすべてのプログラム要素を提供します。を開きます。 入力アシスタント クリックによるダイアログ 編集 → 入力アシスタント または、を押して F2 キー。...", 
"body" : "入力アシスタントは、現在のカーソル位置に挿入できるすべてのプログラム要素を提供します。を開きます。 入力アシスタント クリックによるダイアログ 編集 → 入力アシスタント または、を押して F2 キー。 " }, 
{ "title" : "ダイアログ:自動宣言 ", 
"url" : "_cds_using_input_assistants.html#UUID-c64e3633-b2dc-8e9f-0533-6676df90609a_id_fbe6a158721888c0a8640e00a479cd_id_3879e6752bd7ab84c0a8640e015b3239", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 入力アシスタンスを使用する \/ ダイアログ:自動宣言 ", 
"snippet" : "このダイアログは変数の宣言をサポートします。 詳細については、以下を参照してください。 変数を宣言する...", 
"body" : "このダイアログは変数の宣言をサポートします。 詳細については、以下を参照してください。 変数を宣言する" }, 
{ "title" : "コンポーネントを一覧表示する ", 
"url" : "_cds_using_input_assistants.html#UUID-c64e3633-b2dc-8e9f-0533-6676df90609a_id_fbe6a158721888c0a8640e00a479cd_id_028146f939ae1e35c0a8640e013e8fd8", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 入力アシスタンスを使用する \/ コンポーネントを一覧表示する ", 
"snippet" : "「コンポーネントのリスト」機能は、有効な識別子の入力に役立つテキストエディターの入力ツールです。この機能を有効にするには、をクリックします ツール → オプション そして、 スマートコーディング カテゴリー。を選択します。 ドット (.) を入力した後にコンポーネントを一覧表示する オプション。 ドットを入力した場合 ( . ) グローバル変数の代わりに、使用可能なすべてのグローバル変数を含むリストボックスが開きます。リストボックス内の変数をダブルクリックするか、を押して、選択した変数をドットの後に挿入します Enter 。 ファンクションブロックインスタンス変数または構造体変数の後にグローバ...", 
"body" : "「コンポーネントのリスト」機能は、有効な識別子の入力に役立つテキストエディターの入力ツールです。この機能を有効にするには、をクリックします ツール → オプション そして、 スマートコーディング カテゴリー。を選択します。 ドット (.) を入力した後にコンポーネントを一覧表示する オプション。 ドットを入力した場合 ( . ) グローバル変数の代わりに、使用可能なすべてのグローバル変数を含むリストボックスが開きます。リストボックス内の変数をダブルクリックするか、を押して、選択した変数をドットの後に挿入します Enter 。 ファンクションブロックインスタンス変数または構造体変数の後にグローバル変数の代わりにドット (.) を入力すると、 CODESYS すべてのグローバル変数、関数ブロックのすべての入力変数と出力変数、またはすべての構造体メンバーを含むリストボックスを開きます。 リストボックス内の変数をダブルクリックするか、を押して、選択した変数をドットの後に挿入します。 Enter 。 注:ファンクションブロックインスタンスのローカル変数からも選択する場合は、 入力アシスタントにすべてのインスタンス変数を表示 の「オプション」 CODESYS 「スマートコーディング」カテゴリのオプション。 リストボックスへのコンポーネントアクセス (ドット付き) がすでに行われている場合は、最後に選択したエントリが次のコンポーネントアクセスで事前に選択されます。 任意の文字シーケンスを入力してキーを押すと Ctrl + スペース リストボックスが開き、使用可能なすべての POU とグローバル変数が表示されます。このリストの最初の要素のうち、文字の並びで始まるものがデフォルトで選択され、ダブルクリックするかキーを押すことで挿入できます Enter 。 入力した文字列と一致する文字列は、リストボックスで黄色で強調表示されます。 入力した文字列が変更されると、表示されているリストボックスが更新されます。 ST エディタでは、表示されるリストボックスをスコープでフィルタリングできます。 表示されるリストボックスによっては、次のものを使用できます。 右矢印 そして 左矢印 以下のリストボックスを切り替えるためのキー: すべてのアイテム キーワード グローバル宣言 ローカル宣言 CODESYS 関数ブロック、メソッド、または関数を呼び出すときに POU パラメータの開き括弧を入力すると、ツールチップが表示されます。このツールチップには、POU で宣言されているパラメータに関する情報が含まれています。ツールチップは、クリックして閉じるか、現在のビューからフォーカスを移動するまで開いたままになります。誤ってツールチップを閉じてしまった場合は、を押すと再び開くことができます Ctrl + シフト + スペース 。 pragma 属性を使用できます 隠す 「コンポーネント一覧」機能から変数を除外するため。 例 構造変数の入力: ファンクションブロックを呼び出す: 詳細については、以下を参照してください。 SmartCoding" }, 
{ "title" : "ショートフォーム機能 ", 
"url" : "_cds_using_input_assistants.html#UUID-c64e3633-b2dc-8e9f-0533-6676df90609a_id_fbe6a158721888c0a8640e00a479cd_id_cebde498c37bd547c0a864634120c4e4", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 入力アシスタンスを使用する \/ ショートフォーム機能 ", 
"snippet" : "ショートフォーム機能を使用すると、宣言エディターや変数宣言が可能なテキストエディターで、変数宣言のショートフォームを入力できます。この機能を使用するには、を押してください Ctrl + 入力してください 宣言行の終わりにする。 詳細については、以下を参照してください。 変数宣言のショートカットCODESYS 以下の短縮形式をサポートしています。 行の最後の識別子を除くすべての識別子が変数識別子になります。 宣言のデータ型は、行の最後の識別子によって決まります。以下が適用されます。 b になる : BOOL d になる : DINT 私 になる : INT l になる : LINT r になる ...", 
"body" : "ショートフォーム機能を使用すると、宣言エディターや変数宣言が可能なテキストエディターで、変数宣言のショートフォームを入力できます。この機能を使用するには、を押してください Ctrl + 入力してください 宣言行の終わりにする。 詳細については、以下を参照してください。 変数宣言のショートカットCODESYS 以下の短縮形式をサポートしています。 行の最後の識別子を除くすべての識別子が変数識別子になります。 宣言のデータ型は、行の最後の識別子によって決まります。以下が適用されます。 b になる : BOOL d になる : DINT 私 になる : INT l になる : LINT r になる : REAL s になる : STRING S 8 になる : STRING(8) 文字列長付き t になります : TIME あなた になる : UINT w になる : WORD このルールを使用してデータ型が定義されていない場合、データ型は自動的に BOOL 、最後の識別子はデータ型としては使用されません (例 1 を参照)。 宣言のタイプに応じて、定義されたすべての定数は初期化定義または文字列長の定義になります (例 2 と 3 を参照)。 住所 (例: %MD12 は AT 属性で自動的に拡張されます (例 4 を参照)。 セミコロンの後の任意のテキスト ( ; ) はコメントに変換されます (例 3 を参照)。 行内の他のすべての文字は無視されます (例 5 の感嘆符を参照)。 例 ショートフォーム 結果の宣言 1 A A: BOOL; 2 A B I 2 A, B: INT := 2; 3 ST S 2; A string ST:STRING(2); (* A string *) 4 X %MD12 R 5 Real Number X AT %MD12: REAL := 5.0;(* Real Number *) 5 B ! B: BOOL; " }, 
{ "title" : "プラグマの使用 ", 
"url" : "_cds_using_pragmas.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ プラグマの使用 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "プラグマイン CODESYS ", 
"url" : "_cds_using_pragmas.html#UUID-7a6cff73-fd46-0ee8-105d-673d8223ef56_id_f9a5d357efac0a8640e0137aceb_id_83e9bccc5e33ab49c0a8640e01f6b4a9", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ プラグマの使用 \/ プラグマイン CODESYS ", 
"snippet" : "プラグマとは、アプリケーションのソースコード内で中括弧で囲まれたテキストです。プラグマは、コンパイラが評価できる特別な文をコード内に挿入するために使用されます。これにより、プラグマはプリコンパイルまたはコンパイル（コード生成）において、1つまたは複数の変数のプロパティに影響を与えることができます。コンパイラが認識しないプラグマは、コメントとして無視されます。 プラグマのステートメント文字列は、複数の行にまたがることもできます。 構文の詳細については、個々の説明を参照してください。 CODESYS プラグマ。 目的に応じて異なるプラグマがあります (例: 変数の初期化、変数の監視、シンボル構成へ...", 
"body" : "プラグマとは、アプリケーションのソースコード内で中括弧で囲まれたテキストです。プラグマは、コンパイラが評価できる特別な文をコード内に挿入するために使用されます。これにより、プラグマはプリコンパイルまたはコンパイル（コード生成）において、1つまたは複数の変数のプロパティに影響を与えることができます。コンパイラが認識しないプラグマは、コメントとして無視されます。 プラグマのステートメント文字列は、複数の行にまたがることもできます。 構文の詳細については、個々の説明を参照してください。 CODESYS プラグマ。 目的に応じて異なるプラグマがあります (例: 変数の初期化、変数の監視、シンボル構成への変数の追加、コンパイル プロセス中のメッセージの強制表示、特定の条件下での変数の動作)。 大文字と小文字を区別する必要があります。 " }, 
{ "title" : "プラグマカテゴリ ", 
"url" : "_cds_using_pragmas.html#UUID-7a6cff73-fd46-0ee8-105d-673d8223ef56_id_f9a5d357efac0a8640e0137aceb_id_3296509035ae4c0cc0a8640e000e65d2", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ プラグマの使用 \/ プラグマカテゴリ ", 
"snippet" : "その CODESYS プラグマは次のカテゴリに分類されます。 メッセージプラグマ コンパイル プロセス中にカスタム メッセージを表示できます。 属性プラグマ コンパイルとプリコンパイルに影響を与えることができます。そのためには、初期化、監視、シンボル設定への変数の追加など、様々な目的に応じたプラグマを使用できます。 条件付きプラグマコード生成は条件文によって制御できます。例えば、特定の条件下では変数の動作が異なる場合があります。 リージョンプラグマ テスト POU のプラグマ ユーザー定義プラグマ の中で プロパティ ダイアログ（ コンパイル カテゴリ) では、プラグマで照会できるコンパイラの...", 
"body" : "その CODESYS プラグマは次のカテゴリに分類されます。 メッセージプラグマ コンパイル プロセス中にカスタム メッセージを表示できます。 属性プラグマ コンパイルとプリコンパイルに影響を与えることができます。そのためには、初期化、監視、シンボル設定への変数の追加など、様々な目的に応じたプラグマを使用できます。 条件付きプラグマコード生成は条件文によって制御できます。例えば、特定の条件下では変数の動作が異なる場合があります。 リージョンプラグマ テスト POU のプラグマ ユーザー定義プラグマ の中で プロパティ ダイアログ（ コンパイル カテゴリ) では、プラグマで照会できるコンパイラの「定義」を宣言できます。 " }, 
{ "title" : "挿入可能な位置 ", 
"url" : "_cds_using_pragmas.html#UUID-7a6cff73-fd46-0ee8-105d-673d8223ef56_id_f9a5d357efac0a8640e0137aceb_id_ed58008b2a97bd5ec0a8640e002167c3", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ プラグマの使用 \/ 挿入可能な位置 ", 
"snippet" : "プラグマ CODESYS Cプリプロセッサディレクティブの1対1の実装ではありません。プラグマは通常の文と同様に配置する必要があります。式の中でプラグマを使用することはできません。 コンパイラがさまざまな位置で評価するためのプラグマを挿入できます。 宣言の中で POUの宣言ヘッダー 必要なプラグマを、POU の最初の行または変数宣言の前に、別の行としてテキスト エディターに直接入力できます。 表形式ビューでは、プラグマを入力するとサポートが表示されます。 宣言ヘッダーの編集 コマンドを実行します。ダイアログで、 属性 ボタンをクリックし、入力フィールドに必要なプラグマを入力します。 グローバル...", 
"body" : "プラグマ CODESYS Cプリプロセッサディレクティブの1対1の実装ではありません。プラグマは通常の文と同様に配置する必要があります。式の中でプラグマを使用することはできません。 コンパイラがさまざまな位置で評価するためのプラグマを挿入できます。 宣言の中で POUの宣言ヘッダー 必要なプラグマを、POU の最初の行または変数宣言の前に、別の行としてテキスト エディターに直接入力できます。 表形式ビューでは、プラグマを入力するとサポートが表示されます。 宣言ヘッダーの編集 コマンドを実行します。ダイアログで、 属性 ボタンをクリックし、入力フィールドに必要なプラグマを入力します。 グローバル変数リスト内 条件付きプラグマの場合の制限 条件付きコンパイル用のプラグマは、POU の実装でのみ使用してください。宣言では、これらのプラグマは無視され、評価されません。 次の例外に注意してください:IFプラグマは project_defined 演算子を宣言に挿入できます。詳細については、以下を参照してください。IFプラグマと project_defined (<global define>)POUの実装では 構造化テキスト（ST） ST実装言語では、プラグマは「文の位置」に属します。有効な位置は、実装の先頭の別の行です。もう1つの有効な位置は、セミコロンで終わる文の後にラベルが付けられています。 ; または次のようなキーワードで END_VAR 、 END_IF 、 または END_WHILE 。 ファンクションブロックダイアグラム（FBD）またはラダーダイアグラム（LD） FBD\/LD\/ILエディタの実装言語では、プラグマはラベルにも適した位置に配置します。プラグマはラベルと同じように入力できます。これを行うには、コマンド FBD\/LD\/IL → ラベルを挿入 次に、ラベルのテキストフィールドで、デフォルトのテキストを置き換えます。 Label: 必要なプラグマを使用します。ラベルに加えてプラグマを使用するには、最初にプラグマを指定し、次にラベルを指定します。 例 条件付きプラグマの誤った位置と正しい位置について PROGRAM PRG_ConditionalPragma\nVAR\n strTest : STRING := 'b';\n iResult : INT := 0;\nEND_VAR\n 正しくない {IF defined(DEFINE_A)}\nIF strTest = 'a' THEN\n{ELSE}\nIF strTest = 'b' THEN\n{END_IF}\n iResult := {IF defined(DEFINE_B)} 12; {ELSE} 13; {END_IF}\nEND_IF\n 正しい {IF defined(DEFINE_A)}\nIF strTest = 'a' THEN\n {IF defined(DEFINE_B)}\n iResult := 16#A;\n {ELSE}\n iResult := 16#AA;\n {END_IF}\nEND_IF\n{ELSE}\nIF strTest = 'b' THEN\n {IF defined(DEFINE_B)}\n iResult := 16#B;\n {ELSE}\n iResult := 16#BB;\n {END_IF}\nEND_IF\n{END_IF} " }, 
{ "title" : "範囲 ", 
"url" : "_cds_using_pragmas.html#UUID-7a6cff73-fd46-0ee8-105d-673d8223ef56_section-id235127926588889", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ プラグマの使用 \/ 範囲 ", 
"snippet" : "プラグマのタイプと内容に応じて、次のような影響が出る可能性があります。 その後の宣言 まさに次の発言 対応するプラグマによってキャンセルされるまでのすべての後続のステートメント 同じプラグマが他のパラメータ付きで実行されるか、コードの末尾に到達するまで、後続のすべてのステートメント。ここでの「コード」とは、宣言部、実装部、グローバル変数リスト、および型宣言を指します。したがって、プラグマが宣言部の最初の行に単独で存在し、他のプラグマによって置き換えられたりキャンセルされたりしていない場合、プラグマはオブジェクト全体に影響を及ぼします。...", 
"body" : "プラグマのタイプと内容に応じて、次のような影響が出る可能性があります。 その後の宣言 まさに次の発言 対応するプラグマによってキャンセルされるまでのすべての後続のステートメント 同じプラグマが他のパラメータ付きで実行されるか、コードの末尾に到達するまで、後続のすべてのステートメント。ここでの「コード」とは、宣言部、実装部、グローバル変数リスト、および型宣言を指します。したがって、プラグマが宣言部の最初の行に単独で存在し、他のプラグマによって置き換えられたりキャンセルされたりしていない場合、プラグマはオブジェクト全体に影響を及ぼします。 " }, 
{ "title" : "ライブラリブロックを使用する ", 
"url" : "_cds_using_libraries.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ ライブラリブロックを使用する ", 
"snippet" : "ライブラリは、アプリケーションに含めることができるオブジェクトのコレクションです。プロジェクトでライブラリに含まれているオブジェクトは、プロジェクトで直接定義したオブジェクトとまったく同じ方法で使用できます。 ライブラリには、次のオブジェクトを含めることができます。 機能ブロックや機能などのPOU インターフェイスとそのメソッドおよびプロパティ 列挙型、構造体、エイリアス、ユニオンなどのデータ型 グローバル変数、定数、パラメーターリスト テキストリスト、画像コレクション、視覚化、視覚化要素 外部ファイル（ドキュメントなど） カムテーブル プロジェクト内のライブラリは、ライブラリマネージャで管理...", 
"body" : "ライブラリは、アプリケーションに含めることができるオブジェクトのコレクションです。プロジェクトでライブラリに含まれているオブジェクトは、プロジェクトで直接定義したオブジェクトとまったく同じ方法で使用できます。 ライブラリには、次のオブジェクトを含めることができます。 機能ブロックや機能などのPOU インターフェイスとそのメソッドおよびプロパティ 列挙型、構造体、エイリアス、ユニオンなどのデータ型 グローバル変数、定数、パラメーターリスト テキストリスト、画像コレクション、視覚化、視覚化要素 外部ファイル（ドキュメントなど） カムテーブル プロジェクト内のライブラリは、ライブラリマネージャで管理されます。ライブラリリポジトリのダイアログを介して、システムへのライブラリの以前のインストールを実行します。 ライブラリビルディングブロックとライブラリ名前空間の「可視性」の詳細については、以下を参照してください。 ライブラリプロパティのヘルプページ ライブラリビルディングブロックの使用 次の手順では、カウンタブロックの使用方法を例として説明します。 CTUD 図書館から Standard プログラムに挿入します。 エディターでPOUを開き、宣言部分にカーソルを置きます。 機能ブロックインスタンスの名前に続けてコロンを入力します（たとえば、 iCounter1: ）。 で開く F2 入力ヘルプ。 カテゴリで選択 構造化タイプ 機能ブロック CTUD 図書館から Standard （カウンターサブフォルダー）。 オプションを有効にする 名前空間プレフィックスを付けて貼り付けます 。 とのダイアログを閉じる わかった 。 関数ブロックは、名前空間プレフィックスを付けて宣言部分に挿入されます。 iCounter1:Standard.CTUD 。 詳細については、以下を参照してください。 ライブラリの使用" }, 
{ "title" : "C モジュールの統合 ", 
"url" : "_cds_integrating_c_code.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ C モジュールの統合 ", 
"snippet" : "とともに CODESYS C コードの統合。C で開発されたモジュールは、ライブラリとして CODESYS 計画。このモジュールは、ライブラリに実装されている IEC インターフェイスとともに動的ランタイム モジュールとしてライブラリに格納されます。さらに、異なるターゲットシステム用のモジュールの複数のバリアントをライブラリに格納することもできます。 ライブラリは、他の IEC 61131-3 ライブラリと同様にユーザーに表示されます。ライブラリがアプリケーションで使用される場合、 CODESYS ライブラリから適切なモジュールをコントローラに自動的にダウンロードし、 CODESYS Cont...", 
"body" : "とともに CODESYS C コードの統合。C で開発されたモジュールは、ライブラリとして CODESYS 計画。このモジュールは、ライブラリに実装されている IEC インターフェイスとともに動的ランタイム モジュールとしてライブラリに格納されます。さらに、異なるターゲットシステム用のモジュールの複数のバリアントをライブラリに格納することもできます。 ライブラリは、他の IEC 61131-3 ライブラリと同様にユーザーに表示されます。ライブラリがアプリケーションで使用される場合、 CODESYS ライブラリから適切なモジュールをコントローラに自動的にダウンロードし、 CODESYS Control ランタイムシステム。 アプリケーション例: 既存の C コードの再利用 Matlab®\/Simulink® などのモデリング ツールによって生成されたコードの統合 C コードで作成されたデバイス固有の関数の動的統合 アプリケーションのすべての動的モジュールは、ダウンロード中にランタイム システムに転送されてロードされます。ランタイム システムは、このために動的リンクをサポートする必要があります。 ランタイム システムのライセンス ランタイム システムには、C モジュールのロードを許可するライセンスが必要です。このライセンスがないと、ダウンロード中に動的モジュールをリンクできないため、ダウンロードは中止されます。 動的モジュールはブート アプリケーションの一部であり、コントローラの再起動時に再ロードされてアクティブ化されます。の 原点をリセット コマンドは、アプリケーション内のすべての C コード モジュールをアンロードします。の リセットコールド と ウォームリセット コマンドによって、C コード モジュールの初期化が繰り返されることはありません。 CODESYS は、C コード ファイル内の変数の監視、または C ソース コード内のブレークポイントの設定をサポートしていません。 プリコンパイル済みランタイム モジュールをデバイスに割り当て、ライブラリに保存する 要件: ライブラリ ( *.library ) で開いています CODESYS . クリック 表示 → POU . の POU ビューが開き、ライブラリ プロジェクトとそのオブジェクトが表示されます。 ライブラリ プロジェクトを選択し、 プロジェクト → オブジェクトの追加 → C で実装されたライブラリ . クリック 追加 の中に C で実装されたライブラリを追加 ダイアログ。 CODESYS オブジェクトを追加します C実装ライブラリ ビューで POU 1。 オブジェクトをダブルクリックします C実装ライブラリ 。 オブジェクトがエディタで開きます クリック 追加 このエディタで。 の デバイスを選択 ダイアログが開きます。 の中に オブジェクトファイル 入力フィールドに、動的にロード可能なモジュールの名前を次の形式で指定します *.dll また *.so . の *.dll ファイルの名前には、ライブラリ プロジェクトのタイトルが含まれている必要があります。例: ライブラリ プロジェクトに名前が付けられている場合 XYlib 、 そうして オブジェクトファイル 名前を付ける必要があります: <name>_XYlib.dll の中に デバイス ウィンドウで、割り当てるデバイスを選択します。 オブジェクトファイル . クリック デバイスを選択 . CODESYS 作成されたデバイス ファイルの割り当てを コンパイル済みコンポーネント タブ。 ライブラリ プロジェクトを保存します。 詳細については、次を参照してください。 C実装ライブラリ" }, 
{ "title" : "I \/ Oへのプログラムによるアクセス ", 
"url" : "_cds_f_assigning_ios.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ I \/ Oへのプログラムによるアクセス ", 
"snippet" : "CODESYS プロジェクト変数を入力、出力、およびメモリアドレスにマッピングするための次の機能を提供します。 タブ内の入力、出力、およびメモリアドレスへのプロジェクト変数の割り当て I \/ Oマッピング デバイスの編集者の I \/ Oへのプログラムによるアクセス 可変構成 AT宣言 タブでプロジェクト変数を入力、出力、およびメモリアドレスにマップすることをお勧めします I \/ Oマッピング それぞれのデバイスのエディタの。...", 
"body" : "CODESYS プロジェクト変数を入力、出力、およびメモリアドレスにマッピングするための次の機能を提供します。 タブ内の入力、出力、およびメモリアドレスへのプロジェクト変数の割り当て I \/ Oマッピング デバイスの編集者の I \/ Oへのプログラムによるアクセス 可変構成 AT宣言 タブでプロジェクト変数を入力、出力、およびメモリアドレスにマップすることをお勧めします I \/ Oマッピング それぞれのデバイスのエディタの。 " }, 
{ "title" : "可変構成-VAR_CONFIG ", 
"url" : "_cds_variables_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ I \/ Oへのプログラムによるアクセス \/ 可変構成-VAR_CONFIG ", 
"snippet" : "「タグ設定」を使用して、機能ブロックからプロセスイメージにタグをマッピングします。ファンクションブロックで宣言するときは、完全なアドレスを指定せずに、デバイスの入力\/出力に変数を割り当てます。正確なアドレスは、後でグローバル変数リスト内のアプリケーションのすべての機能ブロックインスタンスに対して一元的に指定されます VAR_CONFIG -宣言。このグローバル変数リストには、 VAR_CONFIG 宣言は変数構成と呼ばれます。 I \/ Oアドレスに直接割り当てられた変数の変更が表示されます CODESYS プロセスイメージに直接。変数構成を介してマップされた変数の変更を表示します CODESY...", 
"body" : "「タグ設定」を使用して、機能ブロックからプロセスイメージにタグをマッピングします。ファンクションブロックで宣言するときは、完全なアドレスを指定せずに、デバイスの入力\/出力に変数を割り当てます。正確なアドレスは、後でグローバル変数リスト内のアプリケーションのすべての機能ブロックインスタンスに対して一元的に指定されます VAR_CONFIG -宣言。このグローバル変数リストには、 VAR_CONFIG 宣言は変数構成と呼ばれます。 I \/ Oアドレスに直接割り当てられた変数の変更が表示されます CODESYS プロセスイメージに直接。変数構成を介してマップされた変数の変更を表示します CODESYS 関連するタスクの最後にのみ。 関数ブロック内の変数の宣言 関数ブロックで変数を宣言するときは、キーワード間の変数を宣言します VAR と END_VAR 。その際、変数に不完全なアドレスを割り当てます。これらの不完全なアドレスを * 。 構文： <Bezeichner> AT %<I\\|Q>*:<Datentyp>; 例 2つのローカルI \/ O変数が定義されています：入力変数 xLocIn および出力変数 xLocOut 。 FUNCTION_BLOCK locio\nVAR\n xLocIn AT %I*: BOOL := TRUE;\n xLocOut AT %Q*: BOOL;\nEND_VAR アドレスは、グローバル変数リストの変数構成で最終的に定義されます。 変数構成として使用するグローバル変数リストに、キーワード間の正確なアドレスを使用して変数の宣言を入力します VAR_CONFIG と END_VAR 1。 the VAR_CONFIG -変数は、各POUとインスタンス名をピリオドで区切って、フルインスタンスパスで指定する必要があります。宣言には、クラス（入出力）が機能ブロックで不完全に指定されたアドレス（％I *、％Q *）のクラスと一致するアドレスが含まれている必要があります。データ型も一致する必要があります。 構文： <instance variable path> AT %<I\\|Q><location>: <data type>; パスのインスタンスが存在しない場合、エラーメッセージが表示されます。 CODESYS また、不完全なアドレスで宣言した変数のアドレス構成がない場合もエラーをスローします。 例 以下の汎用モジュールの使用 locio 上記の例の例はプログラム内にあります。 PROGRAM PLC_PRG\nVAR\n locioVar1: locio;\n locioVar2: locio;\nEND_VAR グローバル変数リストの正しい変数構成は、次のようになります。 VAR_CONFIG\n PLC_PRG.locioVar1.xLocIn AT %IX1.0 : BOOL;\n PLC_PRG.locioVar1.xLocOut AT %QX0.0 : BOOL;\n PLC_PRG.locioVar2.xLocIn AT %IX1.0 : BOOL;\n PLC_PRG.locioVar2.xLocOut AT %QX0.3 : BOOL;\nEND_VAR " }, 
{ "title" : "可変構成の作成 ", 
"url" : "_cds_variables_configuration.html#UUID-6adb8712-3824-d906-67c2-beabb384488e_section-idm4501210518364832656274674828", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ I \/ Oへのプログラムによるアクセス \/ 可変構成-VAR_CONFIG \/ 可変構成の作成 ", 
"snippet" : "要件：フィールドデバイスを使用した制御構成を持つプロジェクトを開いている必要があります。プロジェクトには、たとえばプログラムが含まれています PLC_PRG 、および機能ブロック、たとえば func1 。フィールドデバイスには入力と出力があります。テキストビューは、宣言エディタのオプションで選択されます。 機能ブロック内のアドレスが不完全なデバイスI \/ Oに変数を割り当ててから、変数構成を作成します。 デバイスツリーで、たとえば機能ブロックをダブルクリックします。 func1 。 ブロックエディタが開きます。 宣言部分で、キーワードの間に入力します VAR と END_VAR 1： xLoc...", 
"body" : "要件：フィールドデバイスを使用した制御構成を持つプロジェクトを開いている必要があります。プロジェクトには、たとえばプログラムが含まれています PLC_PRG 、および機能ブロック、たとえば func1 。フィールドデバイスには入力と出力があります。テキストビューは、宣言エディタのオプションで選択されます。 機能ブロック内のアドレスが不完全なデバイスI \/ Oに変数を割り当ててから、変数構成を作成します。 デバイスツリーで、たとえば機能ブロックをダブルクリックします。 func1 。 ブロックエディタが開きます。 宣言部分で、キーワードの間に入力します VAR と END_VAR 1： xLocIn AT %I*: BOOL := TRUE; そして次の行へ XLocOut AT %Q*:BOOL; 入力変数があります xLocIn 宣言され、これは不完全な入力アドレスに送信されます %I* フィールドデバイスに割り当てられます。宣言された出力変数の出力アドレスが不完全です %Q* 割り当てられました。 オブジェクトをクリックします PLC_PRG デバイスツリーに挿入し、プログラムの宣言部分に挿入します VAR と END_VAR たとえば、次の宣言を入力します。 locioVar1: func; locioVar2: func; オブジェクトを選択します 応用 デバイスツリーで、コンテキストメニューコマンドを選択します オブジェクトの追加→グローバル変数リスト ダイアログをクリックします グローバル変数リストを追加 ボタンに 追加 。 グローバル変数リストがデバイスツリーに追加され、そのエディターが開きます。 キーワードを変更する VAR_GLOBAL の VAR_CONFIG その周り。 コマンドを選択します 宣言→すべてのインスタンスパスを追加 。 次のインスタンスパスが追加されます。 PLC_PRG.logioVar1.xLocIn AT %I*;\nPLC_PRG.logioVar2.xLocIN AT %I*;\nPLC_PRG.logioVar1.xLocOut AT %Q*;\nPLC_PRG.logioVar2.xLocOut AT %Q*; 次に、不完全な住所の詳細を置き換えます %I* と %Q* 正確な完全なアドレスで。 " }, 
{ "title" : "AT宣言 ", 
"url" : "_cds_at_declaration.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ I \/ Oへのプログラムによるアクセス \/ AT宣言 ", 
"snippet" : "I\/O マッピング用の明確な設定エディタの使用 ここで説明したようにメモリアドレスを割り当てると、明確さが失われる可能性があるため、お勧めしません。 設定エディターで変数にメモリアドレスを割り当てることをお勧めします。 I \/ O画像を編集する デバイスの。 ザック AT 変数宣言のキーワードは、デバイスツリーで設定されているコントローラーの特定の入力アドレス、出力アドレス、またはメモリアドレスをプロジェクト変数に割り当てます。 AT宣言により、アドレスに意味のある名前を付けることができます。着信信号または発信信号に必要な変更を加えることができるのは、宣言などの1か所のみです。 入力信号または...", 
"body" : "I\/O マッピング用の明確な設定エディタの使用 ここで説明したようにメモリアドレスを割り当てると、明確さが失われる可能性があるため、お勧めしません。 設定エディターで変数にメモリアドレスを割り当てることをお勧めします。 I \/ O画像を編集する デバイスの。 ザック AT 変数宣言のキーワードは、デバイスツリーで設定されているコントローラーの特定の入力アドレス、出力アドレス、またはメモリアドレスをプロジェクト変数に割り当てます。 AT宣言により、アドレスに意味のある名前を付けることができます。着信信号または発信信号に必要な変更を加えることができるのは、宣言などの1か所のみです。 入力信号または出力信号に必要な変更は、1 つの場所 (たとえば宣言内) で行うことができます。 詳細については、以下を参照してください。 住所変数宣言可変構成-VAR_CONFIGすべてのインスタンスパスを追加しますADR, REFERENCE TO, VAR_IN_OUT" }, 
{ "title" : "構文 ", 
"url" : "_cds_at_declaration.html#UUID-bb5c2ea2-9f57-c62c-fc21-e0a94e35bcb0_section-idm234773736203646", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ I \/ Oへのプログラムによるアクセス \/ AT宣言 \/ 構文 ", 
"snippet" : "<変数名> AT % <アドレス> : <データ型> ; <変数名> 必須 % <アドレス> 必須 メモリ領域内のアドレス % <メモリ領域番号> <サイズプレフィックス> <メモリ位置> <メモリ領域プレフィックス> 必須 I : 入力メモリ領域 入力信号と入力用のメモリ領域 入力ドライバとセンサーによる物理入力用 Q : 出力メモリ領域 出力信号と出力用のメモリ領域 出力ドライバとアクチュエータによる物理出力用 M : フラグメモリ領域 <サイズプレフィックス> [オプション] サイズプレフィックスなし:ビット シングルビット X : ビット シングルビット B : バイト 8 ビットデー...", 
"body" : "<変数名> AT % <アドレス> : <データ型> ; <変数名> 必須 % <アドレス> 必須 メモリ領域内のアドレス % <メモリ領域番号> <サイズプレフィックス> <メモリ位置> <メモリ領域プレフィックス> 必須 I : 入力メモリ領域 入力信号と入力用のメモリ領域 入力ドライバとセンサーによる物理入力用 Q : 出力メモリ領域 出力信号と出力用のメモリ領域 出力ドライバとアクチュエータによる物理出力用 M : フラグメモリ領域 <サイズプレフィックス> [オプション] サイズプレフィックスなし:ビット シングルビット X : ビット シングルビット B : バイト 8 ビットデータ幅 W : ワード 16 ビットデータ幅 D : 剣 32 ビットデータ幅 <メモリ位置> <ポジション番号 > . <ビット位置番号> 例: %IB2.4 3 番目のバイトの 5 番目のビットを表します。 <ポジション番号 > 必須 番号はターゲットシステムによって異なり、0 から始まります。 . <ビット位置番号> [オプション] 1 バイトの場合は 0.7 <データ型> [オプション] データ型はサイズプレフィックスと一致する必要があります。 例 VAR \n wInput AT %IW0 : WORD; \nEND_VAR 入力ワードのアドレス指定による変数宣言 VAR \n xActuator AT %QW0 : BOOL; \nEND_VAR ブール変数宣言 注：シングルビットアドレスが指定されていない場合、1バイトはブール変数に内部的に割り当てられます。の値の変化 xActuator したがって、の領域に影響を与えます QX0.0 それまで QX0.7 。 VAR\n xSensor AT %IX7.5 : BOOL; \nEND_VAR シングルビットアドレスを明示的に指定したブール変数宣言 アクセス時には、入力ビット7.5のみが読み取られます。 VAR \n xSensor AT %IX* : BOOL; \nEND_VAR アドレスを指定する場合、保存位置の代わりにプレースホルダーが使用されます * 指定。最終的なアドレス指定は、変数構成で行われます。 注：これは機能ブロックで可能です。 " }, 
{ "title" : "役に立つヒント ", 
"url" : "_cds_at_declaration.html#UUID-bb5c2ea2-9f57-c62c-fc21-e0a94e35bcb0_section-idm234773751522904", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ I \/ Oへのプログラムによるアクセス \/ AT宣言 \/ 役に立つヒント ", 
"snippet" : "シングルビットアドレスを明示的に指定しない限り、ブール変数はバイトごとに割り当てられます。 Boolean 変数にマップされる個々のビットアドレスには制限があります。これらの変数を一緒に使用することはできません VAR_IN_OUT 、 REFERENCE TO 、または ADR オペレーター。 アドレスに変数を割り当てるときは、次のことを考慮する必要があります。 入力に割り当てられている変数に書き込むことはできません。これにより、コンパイラエラーが発生します。 あなたが作ることができます AT 宣言はローカル変数とグローバル変数のみで、POU の入力変数と出力変数の宣言は行いません。 使って...", 
"body" : "シングルビットアドレスを明示的に指定しない限り、ブール変数はバイトごとに割り当てられます。 Boolean 変数にマップされる個々のビットアドレスには制限があります。これらの変数を一緒に使用することはできません VAR_IN_OUT 、 REFERENCE TO 、または ADR オペレーター。 アドレスに変数を割り当てるときは、次のことを考慮する必要があります。 入力に割り当てられている変数に書き込むことはできません。これにより、コンパイラエラーが発生します。 あなたが作ることができます AT 宣言はローカル変数とグローバル変数のみで、POU の入力変数と出力変数の宣言は行いません。 使ってはいけません AT 永続変数リスト内の宣言。 使用する場合 AT 構造体メンバーまたは関数ブロック変数の宣言では、すべてのインスタンスが同じメモリを使用します。これは、「C」などの従来のプログラミング言語での「静的変数」の使用に相当します 構造体のメモリレイアウトもターゲットシステムによって異なります。 " }, 
{ "title" : "例 ", 
"url" : "_cds_at_declaration.html#UUID-bb5c2ea2-9f57-c62c-fc21-e0a94e35bcb0_section-idm234773752144233", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ I \/ Oへのプログラムによるアクセス \/ AT宣言 \/ 例 ", 
"snippet" : "PROGRAM PLC_PRG VAR xVar AT %QW0 : BOOL; END_VAR xVar := TRUE; 変数を書くとき xVar の開始メモリ領域です QX0.0 それまで QX0.7 影響を受ける。...", 
"body" : "PROGRAM PLC_PRG\nVAR\n xVar AT %QW0 : BOOL;\nEND_VAR\nxVar := TRUE; 変数を書くとき xVar の開始メモリ領域です QX0.0 それまで QX0.7 影響を受ける。 " }, 
{ "title" : "構文を確認してコードを分析する ", 
"url" : "_cds_f_checking_syntax_and_code.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 構文を確認してコードを分析する ", 
"snippet" : "CODESYS エラー検出やプログラム作成に役立つ便利な機能を提供します。の 構文チェック プログラミング段階の早い段階でエラーをマークし、メッセージ ビューに出力します。 the 静的コード分析 の CODESYS 追加のコーディングガイドラインに準拠し、エラーが発生しやすい構造を認識するのに役立ちます。...", 
"body" : "CODESYS エラー検出やプログラム作成に役立つ便利な機能を提供します。の 構文チェック プログラミング段階の早い段階でエラーをマークし、メッセージ ビューに出力します。 the 静的コード分析 の CODESYS 追加のコーディングガイドラインに準拠し、エラーが発生しやすい構造を認識するのに役立ちます。 " }, 
{ "title" : "構文を確認する ", 
"url" : "_cds_checking_syntax.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 構文を確認してコードを分析する \/ 構文を確認する ", 
"snippet" : "コードを入力すると、プリコンパイルが実行されます CODESYS すでにいくつかの基本的なチェックを行っています。エディターではエラーが赤で囲まれ、メッセージビューにエラーメッセージが表示されます。 CODESYS アプリケーションをコントローラにダウンロードする前に、開発システムで記述されたソースコードからアプリケーションコードを自動的に生成します。アプリケーションコードが生成される前に、割り当て、データ型、およびライブラリの可用性がチェックされます。メモリアドレスは、アプリケーションコードの生成時にも割り当てられます。コマンドを使用してこの操作を明示的に行うこともできます ビルド→コードの...", 
"body" : "コードを入力すると、プリコンパイルが実行されます CODESYS すでにいくつかの基本的なチェックを行っています。エディターではエラーが赤で囲まれ、メッセージビューにエラーメッセージが表示されます。 CODESYS アプリケーションをコントローラにダウンロードする前に、開発システムで記述されたソースコードからアプリケーションコードを自動的に生成します。アプリケーションコードが生成される前に、割り当て、データ型、およびライブラリの可用性がチェックされます。メモリアドレスは、アプリケーションコードの生成時にも割り当てられます。コマンドを使用してこの操作を明示的に行うこともできます ビルド→コードの生成 またはボタンで F11 走る。これにより、コントローラーがまだ接続されていない場合でも、ソースコードで発生する可能性のあるエラーを見つけることができます。 CODESYS カテゴリのメッセージビューにすべてのエラーと警告を表示します 翻訳すること アウト。エラーメッセージをダブルクリックして、影響を受けるPOUをエディタで開きます。障害のあるスポットがマークされます。または、エラーメッセージのコンテキストメニューを使用して、間違った場所にジャンプすることもできます。 また、 アイデア の中に CODESYS -オプション。 " }, 
{ "title" : "コードを静的に分析する ", 
"url" : "_cds_using_static_analysis.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 構文を確認してコードを分析する \/ コードを静的に分析する ", 
"snippet" : "コード生成中にソースコードを静的に分析（「linten」）することもできます。これは、ソースコードが「lint」分析ツールの方針に沿って設定したコーディングガイドラインに従っているかどうかを判断します。 対話中 プロジェクト設定 カテゴリの下で 静的分析ライト チェックされるルールを有効にします。その後、チェック自体は、コード生成ごとに自動的に実行されます。たとえば、コマンドを実行した場合などです。 ビルド→コードの生成 選択する。ルールからの逸脱が検出された場合、これらはカテゴリのエラーメッセージとして分類されます 翻訳すること メッセージウィンドウに表示されます。報告されたエラーにはプレフ...", 
"body" : "コード生成中にソースコードを静的に分析（「linten」）することもできます。これは、ソースコードが「lint」分析ツールの方針に沿って設定したコーディングガイドラインに従っているかどうかを判断します。 対話中 プロジェクト設定 カテゴリの下で 静的分析ライト チェックされるルールを有効にします。その後、チェック自体は、コード生成ごとに自動的に実行されます。たとえば、コマンドを実行した場合などです。 ビルド→コードの生成 選択する。ルールからの逸脱が検出された場合、これらはカテゴリのエラーメッセージとして分類されます 翻訳すること メッセージウィンドウに表示されます。報告されたエラーにはプレフィックスが付いています： SA<Zahl> 。 静的コード分析用 静的分析ライト プロジェクトのアプリケーションコードのみがチェックされます。図書館は試験から除外されます。 ビュー内のGVLの変数 POU 必ずしもチェックされない：複数のアプリケーションを含むプロジェクトがある場合、現在アクティブなアプリケーションの下にあるオブジェクトのみがチェックされます。アプリケーションが1つしかない場合は、一般的なPOUプール内のオブジェクトもチェックされます。 静的分析ライト 標準の開発システムでは、ルールの削減されたセットにのみ含まれています。アドオンをインストールすると、拡張された一連のルール、追加の命名規則、およびメトリックが利用可能になります CODESYS Static Analysis インストールします。 " }, 
{ "title" : "プラグマを使用した実装のコード行を静的分析から除外します ", 
"url" : "_cds_using_static_analysis.html#UUID-588186d4-486d-aeee-8a39-77c869f6f9a5_id_fc5b65969af34c0a8640e00fb3e7b_id_07681190e3f611e7be4ba1d6d93507bc", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 構文を確認してコードを分析する \/ コードを静的に分析する \/ プラグマを使用した実装のコード行を静的分析から除外します ", 
"snippet" : "プラグマの助けを借りてできます {analysis ...} 指定されたルールがチェックされないようにコードをマークします。したがって、このようにマークされたコード行は静的に分析されません。テスト中、マークされたコードは無視されます。 構文： {analysis <Vorzeichen><Regelnummer>|,<weitere Kombinationen von Vorzeichen und Regelnummern, kommasepariert>} -<Regelnummer> ：ルールSA <ルール番号>のチェックをオフにします。 +<Regelnummer> ：ルールSA <ルー...", 
"body" : "プラグマの助けを借りてできます {analysis ...} 指定されたルールがチェックされないようにコードをマークします。したがって、このようにマークされたコード行は静的に分析されません。テスト中、マークされたコードは無視されます。 構文： {analysis <Vorzeichen><Regelnummer>|,<weitere Kombinationen von Vorzeichen und Regelnummern, kommasepariert>} -<Regelnummer> ：ルールSA <ルール番号>のチェックをオフにします。 +<Regelnummer> ：ルールSA <ルール番号>のチェックを有効化します。 実装コードを除外する 要件：ダイアログがあります プロジェクト設定 ルールが有効になっています。 プラグマを追加する {analysis -<number>} 初めてチェックしたくないコードを含むコード行の上。たとえば、ルールSA0024の場合 コード行は、ルール24に対してチェックされないコードスニペットの最初の行です。 プラグマを追加する {analysis +<number>} 初めてチェックされないコードを含むコード行の下。 例：ルールSA0024の場合 上記のコード行は、ルール24に対してチェックされないコードスニペットの最後の行です。 例：型指定されていないリテラルを無視する {analysis -24}\nnTest := 99;\niVar := INT#2;\n{analysis +24} ルール SA0024：型指定されていないリテラル 2行は無効になっています。コードは次のように修正されていませんが、エラーはスローされません。 nTest := DINT#99; 例：複数のルールを無視する {analysis -10, -24, -18}\n...\n{analysis +10, +24, +18} SA0010：コンポーネントが1つしかないアレイ SA0018：異常なビットアクセス SA0024：型指定されていないリテラル しかし、あなたは支配することができます SA0004 ： 出力への複数の書き込みアクセス プラグマを介して無効にしないでください。 " }, 
{ "title" : "プラグマを使用した静的分析からプログラミングオブジェクトを除外する ", 
"url" : "_cds_using_static_analysis.html#UUID-588186d4-486d-aeee-8a39-77c869f6f9a5_id_fc5b65969af34c0a8640e00fb3e7b_id_0765044be3f611e7be4ba1d6d93507bc", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 構文を確認してコードを分析する \/ コードを静的に分析する \/ プラグマを使用した静的分析からプログラミングオブジェクトを除外する ", 
"snippet" : "構文： {attribute 'analysis' := '-<rule number>[,<other negative rule numbers, comma-separated>]'} プログラミングオブジェクトの宣言部分に属性プラグマを含めると、指定されたルールはプログラミングオブジェクト全体から除外されます。複数のルールを除外する場合は、ルールをマイナス記号と数字の付いたコンマで区切る必要があります。電源投入のプラグマステートメントは必要ありません。 例 {attribute 'analysis' := '-33, -31'} TYPE LocalData : STRUCT iLoc...", 
"body" : "構文： {attribute 'analysis' := '-<rule number>[,<other negative rule numbers, comma-separated>]'} プログラミングオブジェクトの宣言部分に属性プラグマを含めると、指定されたルールはプログラミングオブジェクト全体から除外されます。複数のルールを除外する場合は、ルールをマイナス記号と数字の付いたコンマで区切る必要があります。電源投入のプラグマステートメントは必要ありません。 例 {attribute 'analysis' := '-33, -31'}\nTYPE LocalData :\nSTRUCT\n iLocal : INT;\n uiLocal : UINT;\n udiLocal : UDINT;\nEND_STRUCT\nEND_TYPE ルールSA0033およびSA0031が構造で使用されます LocalData 無視されます。 {attribute 'analysis' := '-100'}\nbig: ARRAY[1..10000] OF DWORD; ルールSA0100がアレイに適用されます big 無視されます。 " }, 
{ "title" : "オリエンテーションとナビゲーション ", 
"url" : "_cds_f_orientating_navigating.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オリエンテーションとナビゲーション ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "相互参照リストで使用場所を見つける ", 
"url" : "_cds_working_with_the_cross_reference_list.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オリエンテーションとナビゲーション \/ 相互参照リストで使用場所を見つける ", 
"snippet" : "シンボルが使用されている場所、つまり変数、POU（プログラム、機能ブロック、機能）、またはDUTを、いわゆる「相互参照リスト」に表示できます。リストから、プロジェクトのそれぞれの位置に直接ジャンプできます。 シンボル使用法検索には2つのタイプがあります。 純粋なテキスト検索：これをビューに入力します 相互参照リスト テキスト（シンボル名、プレースホルダー）を手動で入力します。 具体的な宣言を検索します。 あなたはビューにいます 相互参照リスト 入力ヘルプから宣言を選択します。 ブロックのエディタのシンボル名に焦点が当てられ、コンテキストメニューコマンドを使用して相互参照検索を開始します。 フォ...", 
"body" : "シンボルが使用されている場所、つまり変数、POU（プログラム、機能ブロック、機能）、またはDUTを、いわゆる「相互参照リスト」に表示できます。リストから、プロジェクトのそれぞれの位置に直接ジャンプできます。 シンボル使用法検索には2つのタイプがあります。 純粋なテキスト検索：これをビューに入力します 相互参照リスト テキスト（シンボル名、プレースホルダー）を手動で入力します。 具体的な宣言を検索します。 あなたはビューにいます 相互参照リスト 入力ヘルプから宣言を選択します。 ブロックのエディタのシンボル名に焦点が当てられ、コンテキストメニューコマンドを使用して相互参照検索を開始します。 フォーカスは、シンボル名、ビューのブロックのエディターにあります 相互参照リスト は開いており、相互参照検索は自動的に実行されます。 あなたはビューにいます 相互参照リスト 、複数の宣言の使用場所がすでにリストされており、それらの結果を特定の宣言に制限します。 具体的なシンボル宣言の相互参照 要件：ブロックがエディターで開かれています。 ブロックエディタから、メニューコマンドを使用 宣言または実装のシンボルの識別子（変数、ブロック名）にカーソルを置きます。 コマンドを選択します シンボルの検索→相互参照の出力 コンテキストメニューまたはメニュー 編集するには 。 景色 相互参照リスト 開いて、変数またはPOUが使用されている場所を示します。 ビューの場合 相互参照リスト はすでに開いているので、次のように特定の使用場所を検索することもできます。 ブロックエディタから、自動的に オプションを有効にする 選択を変更するときに相互参照を自動的に更新します の ツール→オプション カテゴリ内 スマートコーディング 。次に、ブロックのエディタウィンドウでシンボルの名前を選択するか、名前にカーソルを置きます。 選択\/カーソルの位置に応じて、相互参照リストにそれぞれのシンボルの使用場所が自動的に表示されます。 相互参照リストビューで、入力ヘルプ付き ビューに入力します 相互参照リスト 入力ヘルプを介して 次のフィールドのシンボル名 宣言後 1。 相互参照リストは、記号が使用されている場所を示しています。 相互参照リストビューで、特定の宣言に制限します ビューにあるとき 相互参照リスト たとえばテキスト検索後など、シンボルに対して複数の宣言がリストされている場合は、表示をそのうちの1つに減らすことができます。目的の宣言のある行を選択し、ボタンをクリックします。 またはコンテキストメニューコマンドを選択します 結果を現在の宣言に制限する 。 相互参照リストには、選択した宣言の使用場所のみが含まれています。 " }, 
{ "title" : "シンボル名のテキスト検索による相互参照 ", 
"url" : "_cds_working_with_the_cross_reference_list.html#UUID-dc873ea4-cf05-2187-4fed-044a9516d887_id_a4b8449208f4c0a8640e01b561a2_id_23a4d649623b8717c0a86463442f97c6", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オリエンテーションとナビゲーション \/ 相互参照リストで使用場所を見つける \/ シンボル名のテキスト検索による相互参照 ", 
"snippet" : "前提条件：ビュー 相互参照リスト が開かれます。 [名前]の横のフィールドに文字列を入力します。たとえば、プロジェクトで使用する場所を検索する変数の識別子を入力します。 例： \" iCounter 「」 ワイルドカードを使用できます \" * \"（任意の数の文字）または\" ? 「（正確に任意の文字）変数識別子のサブストリングとの組み合わせ。 つかいます \" % 'IECアドレスを検索する場合。 例： \" %MW8 \"、\" %M *」 ボタンをクリックします プロジェクトでテキスト検索を開始します。 景色 相互参照リスト 開いて、変数が使用されている場所を示します iCounter 。プロジェクト...", 
"body" : "前提条件：ビュー 相互参照リスト が開かれます。 [名前]の横のフィールドに文字列を入力します。たとえば、プロジェクトで使用する場所を検索する変数の識別子を入力します。 例： \" iCounter 「」 ワイルドカードを使用できます \" * \"（任意の数の文字）または\" ? 「（正確に任意の文字）変数識別子のサブストリングとの組み合わせ。 つかいます \" % 'IECアドレスを検索する場合。 例： \" %MW8 \"、\" %M *」 ボタンをクリックします プロジェクトでテキスト検索を開始します。 景色 相互参照リスト 開いて、変数が使用されている場所を示します iCounter 。プロジェクトでの宣言ポイントと使用ポイントは、下にインデントされて常に表示されます。 相互参照リストで使用場所をダブルクリックします。 対応するオブジェクトがエディタで開かれ、使用場所がマークされます。 " }, 
{ "title" : "宣言を見つける ", 
"url" : "_cds_goto_definition.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オリエンテーションとナビゲーション \/ 宣言を見つける ", 
"snippet" : "CODESYS プロジェクト全体で変数または関数の定義ポイントを検索する可能性を提供します。定義を含むブロックがエディターで開かれ、宣言がマークされます。 変数の宣言を見つける 要件：POUがエディターで開かれている。 実装の識別子にカーソルを置きます。 コマンドを選択します 編集→アイコンの検索→ 定義に移動 。 宣言のあるPOUがエディターで開かれ、変数の定義が強調表示されます。定義が「変換された」ライブラリにある場合、対応するブロックがライブラリマネージャで開かれます。 このコマンドは、オフラインモードとオンラインモードで使用できます。 例 次のブロックには、機能ブロックの定義が含まれて...", 
"body" : "CODESYS プロジェクト全体で変数または関数の定義ポイントを検索する可能性を提供します。定義を含むブロックがエディターで開かれ、宣言がマークされます。 変数の宣言を見つける 要件：POUがエディターで開かれている。 実装の識別子にカーソルを置きます。 コマンドを選択します 編集→アイコンの検索→ 定義に移動 。 宣言のあるPOUがエディターで開かれ、変数の定義が強調表示されます。定義が「変換された」ライブラリにある場合、対応するブロックがライブラリマネージャで開かれます。 このコマンドは、オフラインモードとオンラインモードで使用できます。 例 次のブロックには、機能ブロックの定義が含まれています（ fbinst ）、プログラム呼び出し（ prog_y() ）および汎用モジュール呼び出し（ fbinst.out ）： VAR\n fbinst:fb1;\n ivar:INT;\nEND_VAR\n\nprog_y();\nivar:=prog_y.y;\nres1:=fbinst.out; カーソルを合わせると prog_y set、コマンドはプログラムを開きます prog_y 彼の編集者で。 カーソルを合わせると fbinst place、コマンドは、行の宣言ウィンドウにフォーカスを設定します fbinst:fb1; カーソルを合わせると out set、コマンドは機能ブロックを開きます fb1 彼の編集者で。 " }, 
{ "title" : "ブックマークを設定して使用する ", 
"url" : "_cds_navigating_with_bookmarks.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オリエンテーションとナビゲーション \/ ブックマークを設定して使用する ", 
"snippet" : "ブックマークを使用すると、長いプログラムを簡単にナビゲートできます。ブックマークは、AS（シーケンシャルファンクションチャート）を除くすべてのプログラミング言語エディターで使用できます。コマンドを使用して、マークされたプログラムの場所に直接移動できます。 プロジェクトのさまざまなPOUのブックマークにジャンプします 複数のPOUを持つプロジェクトが開いています。いくつかのブックマークが異なるPOUに設定されています。 コマンドを選択します 表示→ブックマーク 。 景色 ブックマーク 開きます。 プロジェクトのすべてのブックマークは、ビューに表形式で一覧表示されます。 ボタンをクリックします 次...", 
"body" : "ブックマークを使用すると、長いプログラムを簡単にナビゲートできます。ブックマークは、AS（シーケンシャルファンクションチャート）を除くすべてのプログラミング言語エディターで使用できます。コマンドを使用して、マークされたプログラムの場所に直接移動できます。 プロジェクトのさまざまなPOUのブックマークにジャンプします 複数のPOUを持つプロジェクトが開いています。いくつかのブックマークが異なるPOUに設定されています。 コマンドを選択します 表示→ブックマーク 。 景色 ブックマーク 開きます。 プロジェクトのすべてのブックマークは、ビューに表形式で一覧表示されます。 ボタンをクリックします 次のブックマーク 。 ビューで ブックマーク 現在選択されているブックマークの下の行のブックマークが選択されます。 テーブルのブックマークが新しく選択されたPOUがエディターで開き、ブックマークのある行がPOUで選択されます。 ステップ2それに応じてボタンを使用できます 前のブックマーク ビューにあるプロジェクトのブックマークにジャンプします ブックマーク 上の行にが表示されます。 " }, 
{ "title" : "ブックマークの設定\/削除 ", 
"url" : "_cds_navigating_with_bookmarks.html#UUID-0202ce58-db18-3a3e-3f81-14fcd1a390a5_id_d6f70c1e435e81b4c0a8640e0052ef4f_id_8490bbe5442daf0ac0a8640e00d30cae", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オリエンテーションとナビゲーション \/ ブックマークを設定して使用する \/ ブックマークの設定\/削除 ", 
"snippet" : "要件：POUはエディターで開いています。 プログラム行にカーソルを置きます。 コマンドを選択します 編集→ブックマーク→ ブックマークのオン\/オフを切り替える 。 プログラムのこの時点でブックマークが設定されます。これはブックマークアイコンで示されます マークされた。 プログラムのさまざまな場所にいくつかのブックマークを設定します。 ブックマークしたプログラム行にカーソルを置きます。 コマンドを選択します 編集→ブックマーク→ブックマークの切り替え 。 ブックマークが再び削除されます。ブックマークアイコン 削除されます。 または、ビューで ブックマーク ボタンを介した1つ以上のブックマーク ク...", 
"body" : "要件：POUはエディターで開いています。 プログラム行にカーソルを置きます。 コマンドを選択します 編集→ブックマーク→ ブックマークのオン\/オフを切り替える 。 プログラムのこの時点でブックマークが設定されます。これはブックマークアイコンで示されます マークされた。 プログラムのさまざまな場所にいくつかのブックマークを設定します。 ブックマークしたプログラム行にカーソルを置きます。 コマンドを選択します 編集→ブックマーク→ブックマークの切り替え 。 ブックマークが再び削除されます。ブックマークアイコン 削除されます。 または、ビューで ブックマーク ボタンを介した1つ以上のブックマーク クリア。このためには、対応するブックマークがビューに含まれている必要があります ブックマーク 選択されます。 コマンドを選択します 編集→ブックマーク→すべてのブックマークをクリア（アクティブエディタ） アクティブなPOUのすべてのブックマークを削除します。 プロジェクトからすべてのブックマークを削除するには、コマンドを選択します すべてのブックマークを削除する 。ただし、最初にこのコマンドをコマンドで使用する必要があります ツール→カスタマイズ メニューに貼り付けて利用できるようにします。 " }, 
{ "title" : "POU内のブックマークにジャンプします ", 
"url" : "_cds_navigating_with_bookmarks.html#UUID-0202ce58-db18-3a3e-3f81-14fcd1a390a5_id_d6f70c1e435e81b4c0a8640e0052ef4f_id_d7337afc868e9a56c0a8646360d42081", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オリエンテーションとナビゲーション \/ ブックマークを設定して使用する \/ POU内のブックマークにジャンプします ", 
"snippet" : "要件：POUはエディターで開いています。いくつかのブックマークが設定されています。 コマンドを選択します 編集→ブックマーク→次のブックマーク（アクティブエディタ） 。 現在のカーソル位置に応じて、カーソルは次のブックマーク（下）にジャンプします。 コマンドを選択します 編集→ブックマーク→前のブックマーク（アクティブエディタ） 。 現在のカーソル位置に応じて、カーソルは前のブックマーク（上）にジャンプします。...", 
"body" : "要件：POUはエディターで開いています。いくつかのブックマークが設定されています。 コマンドを選択します 編集→ブックマーク→次のブックマーク（アクティブエディタ） 。 現在のカーソル位置に応じて、カーソルは次のブックマーク（下）にジャンプします。 コマンドを選択します 編集→ブックマーク→前のブックマーク（アクティブエディタ） 。 現在のカーソル位置に応じて、カーソルは前のブックマーク（上）にジャンプします。 " }, 
{ "title" : "プロジェクト全体の検索と置換 ", 
"url" : "_cds_searching_for_strings.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ プロジェクト全体の検索と置換 ", 
"snippet" : "の Basic Level 個々のオブジェクトまたはプロジェクト全体で文字列を検索し、必要に応じて別の文字列に置き換えることができます。 メニューでアクティブ化 編集→検索置換 コマンド 検索 。 ダイアログが開きます 検索 。 ボックスに入力します 検索する 検索する文字列を入力します。 検索オプションを選択します。 ピックリストに入れる で検索 検索を実行するオブジェクトを決定します。 ボタンをクリックします 見続ける 。 最初のヒットが表示されます。 ボタンをクリックします 代わりの 、検索した用語を別の用語に置き換えたい場合。 クリック 全員を検索 、すべてのヒットの概要を取得したい場...", 
"body" : "の Basic Level 個々のオブジェクトまたはプロジェクト全体で文字列を検索し、必要に応じて別の文字列に置き換えることができます。 メニューでアクティブ化 編集→検索置換 コマンド 検索 。 ダイアログが開きます 検索 。 ボックスに入力します 検索する 検索する文字列を入力します。 検索オプションを選択します。 ピックリストに入れる で検索 検索を実行するオブジェクトを決定します。 ボタンをクリックします 見続ける 。 最初のヒットが表示されます。 ボタンをクリックします 代わりの 、検索した用語を別の用語に置き換えたい場合。 クリック 全員を検索 、すべてのヒットの概要を取得したい場合。 " }, 
{ "title" : "リファクタリング ", 
"url" : "_cds_refactoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ リファクタリング ", 
"snippet" : "一般に、リファクタリングは、動作を変更せずに、すでに作成されたソフトウェアの設計を改善する方法です。 リファクタリング CODESYS オブジェクト名と変数名の名前を変更したり、ブロックI \/ Oを更新したりするための機能を提供します。名前が変更されたオブジェクトと変数が使用されているすべての場所を表示してから、それらを全体として、または個別に選択して名前を変更できます。さらに、あなたはすることができます ツール→オプション かどうか、どの時点で設定するか CODESYS リファクタリングを自動的に促します。...", 
"body" : "一般に、リファクタリングは、動作を変更せずに、すでに作成されたソフトウェアの設計を改善する方法です。 リファクタリング CODESYS オブジェクト名と変数名の名前を変更したり、ブロックI \/ Oを更新したりするための機能を提供します。名前が変更されたオブジェクトと変数が使用されているすべての場所を表示してから、それらを全体として、または個別に選択して名前を変更できます。さらに、あなたはすることができます ツール→オプション かどうか、どの時点で設定するか CODESYS リファクタリングを自動的に促します。 " }, 
{ "title" : "グローバル変数の名前を変更する ", 
"url" : "_cds_refactoring.html#UUID-3adbd988-b291-6a98-0f3c-4708bc43fe33_id_adee5e3a92356c0a8640e0027b4e2_id_9f3bc4e7ebcfe0c6c0a8640e00160c38", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ リファクタリング \/ グローバル変数の名前を変更する ", 
"snippet" : "要件：少なくとも1つの機能ブロックを含むプロジェクトを開いている FB およびグローバル変数リスト。グローバル変数リスト GVL はエディターで開いており、変数の宣言が含まれています。たとえば、 iGlobal 。 FB 使用済み iGlobal 。 プロジェクト全体でグローバル変数の名前を変更 たとえば、グローバル変数の名前を選択します iGlobal 。 コンテキストメニューでコマンドを選択します リファクタリング→iGlobalの名前を変更 。 対話に入る 名前を変更 入力フィールドに 新しい名前 たとえば、新しい名前を入力します iGlobalOK をクリックします わかった 。 対話...", 
"body" : "要件：少なくとも1つの機能ブロックを含むプロジェクトを開いている FB およびグローバル変数リスト。グローバル変数リスト GVL はエディターで開いており、変数の宣言が含まれています。たとえば、 iGlobal 。 FB 使用済み iGlobal 。 プロジェクト全体でグローバル変数の名前を変更 たとえば、グローバル変数の名前を選択します iGlobal 。 コンテキストメニューでコマンドを選択します リファクタリング→iGlobalの名前を変更 。 対話に入る 名前を変更 入力フィールドに 新しい名前 たとえば、新しい名前を入力します iGlobalOK をクリックします わかった 。 対話 リファクタリング 開きます。左側のウィンドウのデバイスツリーには、オブジェクトがあります GVL と FB 赤でマークされ、黄色で強調表示されます。右側のウィンドウには FB そのエディターで開き、 iGlobal すでに iGlobalOK 名前を変更しました。 クリック わかった 。 プロジェクトにグローバル変数はありません iGlobal 。どこにでもある iGlobalOK 。 プロジェクト全体でグローバル変数の名前を変更します（POUを除く） たとえば、グローバル変数の名前を選択します iGlobal 。 コンテキストメニューでコマンドを選択します リファクタリング→iGlobalの名前を変更 。 対話に入る 名前を変更 入力フィールドに 新しい名前 たとえば、新しい名前を入力します iGlobalTest をクリックします わかった 。 対話 リファクタリング 開きます。左側のウィンドウのデバイスツリーには、オブジェクトがあります GVL と FB 赤でマークされ、黄色で強調表示されます。汎用モジュールは右側のウィンドウにあります FB そのエディターで開きます。それ以外の iGlobal は iGlobalTest リストされています。 カーソルを右側のウィンドウに置き、コンテキストメニューを開きます。 コマンドを選択します このオブジェクトを破棄します をクリックします わかった 。 プロジェクトにはグローバル変数があります iGlobal の FB 現在。これで、変数は、他の方法で変数が発生したオブジェクトに含まれます。 iGlobalTest 指定。 エラーメッセージは、識別子がメッセージウィンドウに表示されます iGlobal 定義されていません。 " }, 
{ "title" : "入力変数の追加と削除 ", 
"url" : "_cds_refactoring.html#UUID-3adbd988-b291-6a98-0f3c-4708bc43fe33_id_adee5e3a92356c0a8640e0027b4e2_id_f328830b85d9e6dcc0a8640e0146b3c8", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ リファクタリング \/ 入力変数の追加と削除 ", 
"snippet" : "リファクタリングコマンドを使用して、POUの宣言部分で入力変数または出力変数を追加または削除できます。ブロックの使用ポイント\/呼び出しポイントで更新 CODESYS したがって、使用ポイントごとにこれを受け入れるか拒否することができます。このためのダイアログが表示されます リファクタリング 。 要件：あなたはPOUを持っています FCT タイプの関数がエディターで開かれました。関数にはすでに入力変数があります input1 と input2 と inputx 。彼女はプログラムに参加します PLC_PRG と POU と呼ばれる。 FCT関数の宣言部分に焦点を当てます。 コマンドを選択 リファ...", 
"body" : "リファクタリングコマンドを使用して、POUの宣言部分で入力変数または出力変数を追加または削除できます。ブロックの使用ポイント\/呼び出しポイントで更新 CODESYS したがって、使用ポイントごとにこれを受け入れるか拒否することができます。このためのダイアログが表示されます リファクタリング 。 要件：あなたはPOUを持っています FCT タイプの関数がエディターで開かれました。関数にはすでに入力変数があります input1 と input2 と inputx 。彼女はプログラムに参加します PLC_PRG と POU と呼ばれる。 FCT関数の宣言部分に焦点を当てます。 コマンドを選択 リファクタリング→変数の追加 。 変数を宣言するための標準ダイアログが表示されます。 変数を宣言する input_3 スコープ付き VAR_INPUT およびデータ型 INT 。とのダイアログを閉じる わかった 。 対話 リファクタリング が表示されます（下の図を参照）。影響を受ける領域は黄色でマークされています。 （1）+（2） 右上のオプションを選択します プレースホルダーテキストを使用して入力を追加する 。 （3） 左側のウィンドウで、背景が黄色のオブジェクトの1つにカーソルを置きます。 PLC_PRG 。コンテキストメニューでコマンドを選択します プロジェクト全体を受け入れる 新しい変数をの使用ポイントに追加するには FCT プロジェクト全体に追加します。 右側のウィンドウで、の実装部分の変更を確認できます。 PLC_PRG ：プレースホルダー _REFACTOR_ 新しい変数が挿入されたポイントにが表示されます。 ダイアログを閉じる リファクタリング と わかった 。 コマンドを選択 編集→検索 。プロジェクトで「_REFACTOR_」を検索して、影響を受ける場所を確認し、それに応じて編集します。 注：または、最初にプレースホルダーを操作せずに、目的の初期化値を使用して新しい変数を直接挿入することもできます。この場合、手順4でオプション「：。add with the following value」を選択し、その右側に値を入力します。 CFCブロックにプレースホルダーテキストを含む新しい変数の例 また、リファクタリングを介して変数を削除する機能にも注意してください。 " }, 
{ "title" : "宣言内の変数を並べ替えます ", 
"url" : "_cds_refactoring.html#UUID-3adbd988-b291-6a98-0f3c-4708bc43fe33_id_adee5e3a92356c0a8640e0027b4e2_id_ad60738bbfd811e7ad23a43badec1aad", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ リファクタリング \/ 宣言内の変数を並べ替えます ", 
"snippet" : "ブロックの宣言部分では、リファクタリングを使用して宣言の順序を変更できます。これはスコープの宣言で可能です VAR_INPUT 、 VAR_OUTPUT また VAR_IN_OUT 。 要件：次の宣言を含むPOUの宣言部分を開いている必要があります。次に例を示します。 VAR_INPUT invar2 : INT; invar1 : INT; in : DUT; bvar : BOOL; invar3 : INT; END_VAR この宣言ブロックにカーソルを置き、マウスの右ボタンを押してコンテキストメニューを開きます。 コマンドを選択します リファクタリング→変数の並べ替え 。 対話 再配置...", 
"body" : "ブロックの宣言部分では、リファクタリングを使用して宣言の順序を変更できます。これはスコープの宣言で可能です VAR_INPUT 、 VAR_OUTPUT また VAR_IN_OUT 。 要件：次の宣言を含むPOUの宣言部分を開いている必要があります。次に例を示します。 VAR_INPUT\n invar2 : INT;\n invar1 : INT;\n in : DUT;\n bvar : BOOL;\n invar3 : INT;\nEND_VAR この宣言ブロックにカーソルを置き、マウスの右ボタンを押してコンテキストメニューを開きます。 コマンドを選択します リファクタリング→変数の並べ替え 。 対話 再配置 のリストとともに表示されます VAR_INPUT -変数。 たとえば、エントリを選択します invar1：INT; マウスでエントリの前にドラッグします invar2。 。 の宣言 invar1 現在、最優先事項です。 とのダイアログを閉じる わかった 。 対話 リファクタリング が表示されます。影響を受ける領域は黄色でマークされています。 （上の画像を参照） で確認する わかった 新しい注文をブロックに適用します。 " }, 
{ "title" : "変数宣言を変更し、リファクタリングを自動的に適用します ", 
"url" : "_cds_refactoring.html#UUID-3adbd988-b291-6a98-0f3c-4708bc43fe33_id_adee5e3a92356c0a8640e0027b4e2_id_86f1778c7d5106b7c0a8646345d4e9bf", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ リファクタリング \/ 変数宣言を変更し、リファクタリングを自動的に適用します ", 
"snippet" : "変数の名前を変更するときに宣言をリファクタリングすることでサポートされます（自動宣言を使用）。 要件：汎用モジュール fb_A 。 コマンドを選択します ツール→オプション 。 ダイアログ オプション 開きます。 カテゴリを選択してください リファクタリング 。 以下でアクティブ化 自動宣言 オプション 変数の名前を変更する場合 と 変数の追加または削除、または名前空間の変更用 。 汎用モジュールをダブルクリックします fb_A 。 の宣言で選択 fb_A たとえば変数 iA 。または、変数の前または変数の中にカーソルを置くこともできます。 与える 編集→変数の宣言 1 （ トグル + F2 ...", 
"body" : "変数の名前を変更するときに宣言をリファクタリングすることでサポートされます（自動宣言を使用）。 要件：汎用モジュール fb_A 。 コマンドを選択します ツール→オプション 。 ダイアログ オプション 開きます。 カテゴリを選択してください リファクタリング 。 以下でアクティブ化 自動宣言 オプション 変数の名前を変更する場合 と 変数の追加または削除、または名前空間の変更用 。 汎用モジュールをダブルクリックします fb_A 。 の宣言で選択 fb_A たとえば変数 iA 。または、変数の前または変数の中にカーソルを置くこともできます。 与える 編集→変数の宣言 1 （ トグル + F2 ）。 対話 変数を宣言する 開きます。ダイアログには、の設定が含まれています iA 。 の名前を変更します iA 後 iCounter_A 。 オプション リファクタリングを使用した変更 が表示され、アクティブになります。 クリック わかった 。 対話 リファクタリング iAの名前をiCounterAに変更します 開きます。変数の名前変更の影響を受けるすべての位置がそこにマークされています。 でダイアログを終了します わかった 。 変更は受け入れられます。 " }, 
{ "title" : "タスク構成 ", 
"url" : "_cds_f_task_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ タスク構成 ", 
"snippet" : "タスク構成では、プログラム (POU オブジェクト) のフローを制御するタスクを 1 つ以上定義します。 プログラム ) と入力し、そこから呼び出された POU をデバイス上で実行します。A タスク設定 オブジェクトは各アプリケーションに必要です。ここで、プログラムを呼び出す順番を時系列で定義します タスクは IEC プログラムの時系列フロー単位です。タスクはPOUのコールチェーン (コール階層) を定義します 各タスクには一意の名前が必要です。タスク設定エディターで、呼び出すプログラムのリストを指定します。プログラムはアプリケーション固有のものでもかまいません。その場合、プログラムは次の場所...", 
"body" : "タスク構成では、プログラム (POU オブジェクト) のフローを制御するタスクを 1 つ以上定義します。 プログラム ) と入力し、そこから呼び出された POU をデバイス上で実行します。A タスク設定 オブジェクトは各アプリケーションに必要です。ここで、プログラムを呼び出す順番を時系列で定義します タスクは IEC プログラムの時系列フロー単位です。タスクはPOUのコールチェーン (コール階層) を定義します 各タスクには一意の名前が必要です。タスク設定エディターで、呼び出すプログラムのリストを指定します。プログラムはアプリケーション固有のものでもかまいません。その場合、プログラムは次の場所にあります デバイス 表示。または、プログラムがプロジェクト全体を通して有効である場合もあります。その場合、プログラムは POU 見る。これらの POU はプロジェクト全体でインスタンス化されます。 タスクに優先順位を付けることは可能です。優先順位付けはタスクタイプと組み合わせて機能します。 タスクタイプを設定します。 周期的。サイクル間隔を使用して時間制御された流れの場合。プログラムコールはサイクル間隔 (タスクサイクルタイム) 内に実行されます フリーホイーリング:独自のタスクサイクルタイムのないタスク用 イベント開始条件（エッジトリガー）によるイベントトリガー（内部または外部）。 イベントの例としては、グローバルプロジェクト変数の上昇や中断などがあります。 ステータス・トリガー・ビア・コンディション 開始、停止、リセットをプロジェクト POU の実行と直接組み合わせることができます。 ウォッチドッグをアクティブにすることもできます。 コールスタックは、タスク設定のこれらの設定に基づいて作成および実行されます。 考えられるさまざまなコールスタックに基づいて、どれが最も長く、メモリ要件が最も高いか（最大コールスタック）が決定されます。この詳細については、を参照してください スタック使用量 タブ。 " }, 
{ "title" : "ルール ", 
"url" : "_cds_f_task_configuration.html#UUID-36274da0-33e1-95eb-0678-9986502699b8_section-idm234764921910388", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ タスク構成 \/ ルール ", 
"snippet" : "設定したタスクの処理順序のルール タスク条件が満たされると、タスクが開始され、処理されます。 複数のタスクが同時に処理条件を満たす場合、優先度が最も高いタスクが最初に処理されます。 同じ優先度レベルの複数のタスクが同時に処理条件を満たす場合、キューに長く入っているタスクが最初に処理されます。 プログラム呼び出しは、タスクの設定ダイアログに表示されている順序で処理されます。 アプリケーションのデバイスツリー、ライブラリ、またはプロジェクト全体の POU ビューに同じ名前のプログラムが存在するためにプログラム呼び出しが一意でない場合は、アプリケーションオブジェクトの下にあるプログラムが使用されます...", 
"body" : "設定したタスクの処理順序のルール タスク条件が満たされると、タスクが開始され、処理されます。 複数のタスクが同時に処理条件を満たす場合、優先度が最も高いタスクが最初に処理されます。 同じ優先度レベルの複数のタスクが同時に処理条件を満たす場合、キューに長く入っているタスクが最初に処理されます。 プログラム呼び出しは、タスクの設定ダイアログに表示されている順序で処理されます。 アプリケーションのデバイスツリー、ライブラリ、またはプロジェクト全体の POU ビューに同じ名前のプログラムが存在するためにプログラム呼び出しが一意でない場合は、アプリケーションオブジェクトの下にあるプログラムが使用されます。 詳細については、以下を参照してください。 バスサイクルタスク" }, 
{ "title" : "役に立つヒント ", 
"url" : "_cds_interesting_facts_task_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ タスク構成 \/ 役に立つヒント ", 
"snippet" : "すべてのタスクが 1 つのプロセスイメージを共有します。 これは、タスクごとに個別のプロセスイメージを使用するとパフォーマンスが低下するためです。 さらに、プロセスイメージの一貫性を保つことができるのは 1 つのタスクだけです。これにより、すべてのタスクが 1 つのプロセスイメージを共有している場合に矛盾が生じるのを防ぐことができます プロジェクトを開発するときは、入力データが次のことを確認する必要があります ( VAR_INPUT ) は、コンフリクトが発生した場合に安全な場所にコピーされます。これは出力データ () にも当てはまります VAR_OUTPUT )。 POU (次のような) S...", 
"body" : "すべてのタスクが 1 つのプロセスイメージを共有します。 これは、タスクごとに個別のプロセスイメージを使用するとパフォーマンスが低下するためです。 さらに、プロセスイメージの一貫性を保つことができるのは 1 つのタスクだけです。これにより、すべてのタスクが 1 つのプロセスイメージを共有している場合に矛盾が生じるのを防ぐことができます プロジェクトを開発するときは、入力データが次のことを確認する必要があります ( VAR_INPUT ) は、コンフリクトが発生した場合に安全な場所にコピーされます。これは出力データ () にも当てはまります VAR_OUTPUT )。 POU (次のような) SysSem ライブラリ。整合性と同期の問題を解決する機能を提供します。整合性の問題は、他のグローバルオブジェクト (グローバル変数または POU) にアクセスするときにも発生する可能性があります。1 つの変数に対して複数の読み取りと書き込みを行うと、常に整合性の問題が発生します。の POU SysSem ライブラリはこのようなコンフリクトの解決にも役立ちます。 詳細については、以下を参照してください。 ライブラリドキュメンテーション 用 SysSem " }, 
{ "title" : "タスクの設定 ", 
"url" : "_cds_creating_task_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ タスク構成 \/ タスクの設定 ", 
"snippet" : "以下のタスクの設定を変更できます タスク設定 上のタスクオブジェクトのエディター内のオブジェクト コンフィギュレーション タブ。 を使用して新しいプロジェクトを作成した場合 標準プロジェクト テンプレート、簡単なタスク設定が用意され、 MainTask タスクは既に存在しています。 タスクを変更する 要件:オープンプロジェクトには、次のタイプの POU が含まれている PROGRAM そして、タスクオブジェクトを含むタスク設定がデバイスツリーのアプリケーションの下に挿入されました。 デバイスツリーで、以下のタスクオブジェクトをダブルクリックします。 タスク設定 。 の 構成 タスクオブジェクト...", 
"body" : "以下のタスクの設定を変更できます タスク設定 上のタスクオブジェクトのエディター内のオブジェクト コンフィギュレーション タブ。 を使用して新しいプロジェクトを作成した場合 標準プロジェクト テンプレート、簡単なタスク設定が用意され、 MainTask タスクは既に存在しています。 タスクを変更する 要件:オープンプロジェクトには、次のタイプの POU が含まれている PROGRAM そして、タスクオブジェクトを含むタスク設定がデバイスツリーのアプリケーションの下に挿入されました。 デバイスツリーで、以下のタスクオブジェクトをダブルクリックします。 タスク設定 。 の 構成 タスクオブジェクトのタブが開きます。 の中に タイプ リストボックスで、 サイクリック エントリー。 ザル インターバル (例:t #200ms) 入力フィールドが表示されます。 の中に インターバル (例:t #200ms) フィールドに値を入力します。 t#300ms 。 をクリックします 通話を追加 ボタン。 入力アシスタントが開きます。 の中に 入力アシスタント ダイアログ、 プログラム カテゴリ、目的の POU を選択し、をクリックします。 OK ダイアログを閉じます。 選択した POU は、のコールスタックに一覧表示されます [構成] タブとデバイスツリーのタスクオブジェクトの下にあります。 PLCからアプリケーションを実行すると、タスクオブジェクトで選択されたPOUは、次の間隔で周期的に実行されます 300 ms 。 " }, 
{ "title" : "フリーホイーリング IEC タスク ", 
"url" : "_cds_freewheeling_iec_task.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ タスク構成 \/ フリーホイーリング IEC タスク ", 
"snippet" : "自由奔放なタスクは周期的に実行されますが、タスクサイクルは固定されません。これは PLC の古典的意味での繰り返しのタスクです。 実行はできるだけ頻繁に行われます。ただし、処理は決まったサイクルでは行われません。この種のタスクにはタスクサイクルタイムを定義できません。時間動作は自動的に選択され、システム全体にかかる負荷ができるだけ少なくなるように実行されます。 さらに、実行の終了後、タスクが再度実行されるまで、一定時間待機します。この期間は、最後のサイクル期間のパーセンテージです 自由奔放なタスクでは、固定のタスクサイクルタイムや固定時間の動作は保証されません。 ウォッチドッグをフリーホイーリ...", 
"body" : "自由奔放なタスクは周期的に実行されますが、タスクサイクルは固定されません。これは PLC の古典的意味での繰り返しのタスクです。 実行はできるだけ頻繁に行われます。ただし、処理は決まったサイクルでは行われません。この種のタスクにはタスクサイクルタイムを定義できません。時間動作は自動的に選択され、システム全体にかかる負荷ができるだけ少なくなるように実行されます。 さらに、実行の終了後、タスクが再度実行されるまで、一定時間待機します。この期間は、最後のサイクル期間のパーセンテージです 自由奔放なタスクでは、固定のタスクサイクルタイムや固定時間の動作は保証されません。 ウォッチドッグをフリーホイーリングタスク用に設定できます。 " }, 
{ "title" : "論理 ", 
"url" : "_cds_freewheeling_iec_task.html#UUID-93812248-fffe-e248-6e0b-fbebee0f762c_section-idm234752771243877", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ タスク構成 \/ フリーホイーリング IEC タスク \/ 論理 ", 
"snippet" : "すべての自由な IEC タスクの負荷は、設定された最大プロセッサ負荷の半分を超えないように、ランタイムシステムによって決定されます。 MaxCpuLoadFreewheeling = ((MIN( 100, MaxProcessorload) \/ 2) \/ NumOfFreeWheelingTasks); SleeptimeAfterCycle = CycleTimeFreewheelingTask * ((100 - MaxCpuLoadFreewheeling) \/ 100) if (SleeptimeAfterCycle < 1000) \/\/ Minimum sleeptime of 1...", 
"body" : "すべての自由な IEC タスクの負荷は、設定された最大プロセッサ負荷の半分を超えないように、ランタイムシステムによって決定されます。 MaxCpuLoadFreewheeling = ((MIN( 100, MaxProcessorload) \/ 2) \/ NumOfFreeWheelingTasks);\nSleeptimeAfterCycle = CycleTimeFreewheelingTask * ((100 - MaxCpuLoadFreewheeling) \/ 100)\nif (SleeptimeAfterCycle < 1000) \/\/ Minimum sleeptime of 1ms is mandatory!   \nSleeptimeAfterCycle = 1000; 例 アプリケーションのランタイムシステムは次のように実行されます。 MaxProcessorload = 80 CycleTime = 20 ミリ秒 1 自由奔放なタスク エフェクト MaxCpuLoadFreewheeling = 40% SleeptimeAfterCycle = 30 ミリ秒 フリーホイールタスクの合計サイクルタイム = 50 ms ⇒ 残りのシステムでは、合計で 60% の CPU 負荷が達成されます。 " }, 
{ "title" : "ジッターとレイテンシーの定義 ", 
"url" : "_cds_task_configuration_jitter_definitions.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ タスク構成 \/ ジッターとレイテンシーの定義 ", 
"snippet" : "の中に タスク設定 オブジェクト、 モニター タブでは、実行時に個々のタスクの周期的なジッター値を監視できます。周期的ジッターはレイテンシーベースのリリースジッターとは区別されます 以下の定義を参照してください。...", 
"body" : "の中に タスク設定 オブジェクト、 モニター タブでは、実行時に個々のタスクの周期的なジッター値を監視できます。周期的ジッターはレイテンシーベースのリリースジッターとは区別されます 以下の定義を参照してください。 " }, 
{ "title" : "周期的ジッター ", 
"url" : "_cds_task_configuration_jitter_definitions.html#UUID-9d6853f6-7ed8-8e80-75a4-2a1962e8fe38_id_f981b089a35bd38cc0a864636d261073_id_af58c92ba43a965cc0a8646374364889", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ タスク構成 \/ ジッターとレイテンシーの定義 \/ 周期的ジッター ", 
"snippet" : "周期的ジッター J あたり はタスクサイクルタイム T の偏差 あたり 目的のタスクサイクルタイム T から 0 。 J p e r = T p e r − T 0 J_{per}=T_{per}−T_0 希望の (理想的な) サイクルタイム T 0 タスクの設定では次のように指定されています。 間隔 。 の中に タスク設定 エディター、上 モニター タブでは、実行時の周期的ジッターの現在の値だけでなく、最大値と最小値を監視できます。 すべての負の値の合計が J の場合 あたり すべての正の値 J の合計と等しくない あたり 、ドリフトが発生します。...", 
"body" : "周期的ジッター J あたり はタスクサイクルタイム T の偏差 あたり 目的のタスクサイクルタイム T から 0 。 J p e r = T p e r − T 0 J_{per}=T_{per}−T_0 希望の (理想的な) サイクルタイム T 0 タスクの設定では次のように指定されています。 間隔 。 の中に タスク設定 エディター、上 モニター タブでは、実行時の周期的ジッターの現在の値だけでなく、最大値と最小値を監視できます。 すべての負の値の合計が J の場合 あたり すべての正の値 J の合計と等しくない あたり 、ドリフトが発生します。 " }, 
{ "title" : "レイテンシー ", 
"url" : "_cds_task_configuration_jitter_definitions.html#UUID-9d6853f6-7ed8-8e80-75a4-2a1962e8fe38_id_f981b089a35bd38cc0a864636d261073_id_fb5ffa33a43a965cc0a8646345523b0d", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ タスク構成 \/ ジッターとレイテンシーの定義 \/ レイテンシー ", 
"snippet" : "レイテンシーは、間の遅延です 呼び出し タスクと実際のタスク リリース 。...", 
"body" : "レイテンシーは、間の遅延です 呼び出し タスクと実際のタスク リリース 。 " }, 
{ "title" : "リリースジッター ", 
"url" : "_cds_task_configuration_jitter_definitions.html#UUID-9d6853f6-7ed8-8e80-75a4-2a1962e8fe38_id_f981b089a35bd38cc0a864636d261073_id_533c636ea43a965cc0a864633ee70d81", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ タスク構成 \/ ジッターとレイテンシーの定義 \/ リリースジッター ", 
"snippet" : "リリースジッター J r は、これまでに発生した最大レイテンシー (L) と最小レイテンシー (L) の差です。 J r = L max - L min J_r=L_{\\max}-L_{\\min} L の場合 マックス = L 最小 、リリースジッター J r 0 件の結果これは厳密なオフセットシフトに相当します。...", 
"body" : "リリースジッター J r は、これまでに発生した最大レイテンシー (L) と最小レイテンシー (L) の差です。 J r = L max - L min J_r=L_{\\max}-L_{\\min} L の場合 マックス = L 最小 、リリースジッター J r 0 件の結果これは厳密なオフセットシフトに相当します。 " }, 
{ "title" : "スタック使用量の計算 ", 
"url" : "_cds_calculate_stack_usage.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ タスク構成 \/ スタック使用量の計算 ", 
"snippet" : "POU ごとのスタック使用状況は、に表示されます。 タスク設定 上のオブジェクト スタック使用量 タブ。 スタック使用量は次によって静的に計算されます。 CODESYS 静的コールスタックを使用する。 計算には以下が含まれます。 計算は、タスクエントリの暗黙的なPOUから始まります。 各 IEC プログラムコールについて (例: PLC_PRG ) の場合、呼び出された各 IEC POU のスタック使用量が再帰的に計算されます。POU の最大スタック使用量を決定するために、POU の最大スタック使用量がそれ自体のローカルスタック使用量に加算されます 動的呼び出しの場合、スタック使用量は次のよう...", 
"body" : "POU ごとのスタック使用状況は、に表示されます。 タスク設定 上のオブジェクト スタック使用量 タブ。 スタック使用量は次によって静的に計算されます。 CODESYS 静的コールスタックを使用する。 計算には以下が含まれます。 計算は、タスクエントリの暗黙的なPOUから始まります。 各 IEC プログラムコールについて (例: PLC_PRG ) の場合、呼び出された各 IEC POU のスタック使用量が再帰的に計算されます。POU の最大スタック使用量を決定するために、POU の最大スタック使用量がそれ自体のローカルスタック使用量に加算されます 動的呼び出しの場合、スタック使用量は次のように計算されます。考えられるすべての実装のスタック使用量が決定され、最大のスタック使用量が想定されます。つまり、インターフェイスメソッドでは考えられるすべての実装と、ファンクションブロックメソッドでは考えられるすべてのオーバーライドが考慮されます 外部通話では、ターゲットデバイスで指定された値が想定されます。デバイスが値を指定していない場合は 0 と見なされます。 再帰の場合、計算は中止されます。タイプ属性プラグマの値 estimated-stack-usage 再帰的に呼び出されるコードに適用されます。値が指定されていない場合は 0 とみなされます したがって、スタック使用量は推定値に過ぎません。想定される最下位コールパスが実行時に実行されないため、この値が高すぎる可能性があります。ただし、再帰や外部呼び出しの見積もりが不適切になるため、この値が低すぎる場合もあります 例 " }, 
{ "title" : "スタック使用量の表示 ", 
"url" : "_cds_calculate_stack_usage.html#UUID-565541ba-1a57-4d6d-52b6-33ca85bebcdf", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ タスク構成 \/ スタック使用量の計算 \/ スタック使用量の表示 ", 
"snippet" : "をダブルクリック タスク設定 オブジェクト。 タスク設定エディターが開きます。 クリック ビルド → コードを生成 コマンド。 をクリックします スタック使用量 タブ。 タブの情報が更新されます。 アンダー タスク\/最大コールスタック この場合、順番に呼び出された POU は、想定どおりに最大コールスタックに表示されます。POU の計算されたスタックサイズは、に表示されます スタックサイズ カラム。 例 スタックサイズが赤で表示されている場合は、それぞれの POU でスタックオーバーフローが発生している可能性があります。変更が必要な POU がわかります。これはコールスタックで赤でマークされた...", 
"body" : "をダブルクリック タスク設定 オブジェクト。 タスク設定エディターが開きます。 クリック ビルド → コードを生成 コマンド。 をクリックします スタック使用量 タブ。 タブの情報が更新されます。 アンダー タスク\/最大コールスタック この場合、順番に呼び出された POU は、想定どおりに最大コールスタックに表示されます。POU の計算されたスタックサイズは、に表示されます スタックサイズ カラム。 例 スタックサイズが赤で表示されている場合は、それぞれの POU でスタックオーバーフローが発生している可能性があります。変更が必要な POU がわかります。これはコールスタックで赤でマークされた最初の POU " }, 
{ "title" : "マルチコア ", 
"url" : "_cds_multi_core.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ タスク構成 \/ マルチコア ", 
"snippet" : "タスクと CPU コアの割り当ては タスク設定 上のオブジェクト タブ:タスクグループ タブ。 今日のコントローラーの多くには、複数のCPUコアを搭載したプロセッサーが搭載されています。 もし CODESYS をマルチコア機能を使用せずにマルチコアコントローラで実行すると、タスクの分散はオペレーティングシステムのスケジューラによって処理されます。これは、アプリケーションが複数のタスクで実行される場合に当てはまります。この場合、タスクの配分には直接影響しません。負荷分散によっては、タスクを異なる CPU コアで実行することもできます と CODESYS マルチコア機能を使用すると、取得した CP...", 
"body" : "タスクと CPU コアの割り当ては タスク設定 上のオブジェクト タブ:タスクグループ タブ。 今日のコントローラーの多くには、複数のCPUコアを搭載したプロセッサーが搭載されています。 もし CODESYS をマルチコア機能を使用せずにマルチコアコントローラで実行すると、タスクの分散はオペレーティングシステムのスケジューラによって処理されます。これは、アプリケーションが複数のタスクで実行される場合に当てはまります。この場合、タスクの配分には直接影響しません。負荷分散によっては、タスクを異なる CPU コアで実行することもできます と CODESYS マルチコア機能を使用すると、取得した CPU コアの数を考慮して、IEC タスク自体を専用の CPU コアに割り当てることができます。これにより、パフォーマンスが向上します。この目的のために、IEC プログラムを複数のタスクに分割する必要があります。 には 2 つの基本的な異なる戦略があります CODESYS IEC タスクを CPU コアに分散するには: CPU コアにリンクされて固定されている IEC タスク: タスクは常にこの特定の CPU コアで実行されます。複数のタスクをグループ化することで、1 つの CPU コアにリンクできます。これは、IEC プログラムがまだ複数の CPU コアで同時に実行できない場合などに便利です IEC タスクはすべての CPU コアで実行されます。 オペレーティング システムは、CPU コア上のグループの 1 つ以上のタスクの分散を制御します。 IEC タスクが複数の CPU コアに分散されると、IEC プログラムの動作に一部の変更が生じるため、それを考慮する必要があります。 IEC タスクを優先的に処理することはもはや当たり前のことではありません。タスクが優先度順に処理されるのは、タスクが 1 つの CPU コアにまとめられている場合だけです 最高優先度の IEC タスクのデータのサイクル一貫性は保証されなくなりました。したがって、サイクル中に値を変更しない場合は、IEC タスク サイクルの開始時にデータをローカルにコピーする必要があります。 すべてのタスクには、タスクが動作する共有プロセスイメージがあります。 ReadInputs() 関数は各タスクの開始時に呼び出され、 WriteOutputs() 関数は最後に呼び出されます。その結果、IPOモデルは各タスクに個別に適用されます。これらの関数は共有プロセスイメージを読み書きします。プロセスイメージも物理的に書き込まれ、パケットはバスサイクルタスクが呼び出されたときにのみ送信されます。ただし、バスサイクルタスクは各呼び出しを待機します。 WriteOutputs そして ReadInputs タスクの。これにより、バス サイクル タスク内でのデータの一貫性が確保されます。 出力は 1 つのタスクにのみ割り当てることができます。 入力は複数のタスクに割り当てることができますが、直接アクセスすることは避けてください。入力は、アトミック操作によってタスクのローカル変数に書き込む必要があります。 2 つ目のタスク。以下のようにプロセスイメージを更新します。 ReadInputs() 最初のタスクと並行して、実行中の最初のタスクの入力も更新します。 その結果、タスクのデータの一貫性は、最も優先度の高いタスクのシングルコアでのみ保証されます。 バスサイクルタスクを設定できます。 PLCの設定 タブ。 I\/O アクセスを表示できます。 タブ: タスクの展開 タブ。 詳細については、以下を参照してください。 バスサイクルタスクコンシステントカウンタ (インクリメンタ、デクリメンタ) の場合、アトミック外部ライブラリ関数 SysCpuAtomicAdd() 常に使用してください (詳細については、を参照してください) SysCpuHandling.library )。 データの一貫性 ビットアクセス (データ型) BIT ) が IEC プログラムのマルチコア CPU で一貫して (アトミックに) 処理されない。そのためには、外部ライブラリ関数を使用することをおすすめします SysCpuTestAndSetBit() 。(詳細については、以下を参照してください。 SysCpuHandling.library ) 32 ビット幅までの単純なデータ型 ( BOOL 、 BYTE 、 WORD \/ INT 、 DWORD \/ DINT など) は、マルチコア CPU 上の IEC プログラムでも一貫して (アトミックに) 処理されます。 64 ビットのデータ型 ( LINT, LWORD, LREAL) 64 ビット システムおよびマルチコア システムのみの IEC プログラムで一貫して (アトミックに) 処理されます。これを行うために、特別な予防措置を講じる必要はありません。 複雑なデータ型にアクセスするには ( STRING 、 FB 、 STRUCT 、および ARRAY )、同期\/整合性の調整は自分で行う必要があります。 タスク設定で、 変数の使用法 タブでは、IEC タスク内の変数に読み取りアクセス権と書き込みアクセス権のどちらを与えるかを定義できます。 マルチコア システムでは、「メモリの並べ替え効果」が発生する可能性があります。詳細については、「IEC オペレータ」を参照してください。 __MemoryBarrier() 。 トレース内のプロセッサコアあたりのプロセッサ負荷の表示 で CODESYS では、プロセッサの負荷をビジュアライゼーションで表示できます。 デバイストレース オブジェクト。 プロジェクト内でデバイス トレースが表示される方法の詳細については、次を参照してください。 コントローラーのすべてのトレースへのアクセス " }, 
{ "title" : "複数のプロセッサコアへのタスクの分散 ", 
"url" : "_cds_multi_core.html#UUID-3fe3ae5a-9846-6716-c62e-acb89f2bb794_id_bd03ce9b9d30cbc0a864631d9f12af_id_7f76aece9c289dffc0a86463409eb0c2", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ タスク構成 \/ マルチコア \/ 複数のプロセッサコアへのタスクの分散 ", 
"snippet" : "要件:アプリケーションには少なくとも 2 つのタスクが定義されています。次に例を示します。 MainTask (IEC タスク) と LowTask (IEC タスク)。 を開く タスク設定 エディター内のオブジェクト。 に切り替える タスクグループ タブ。 概要にはデフォルトが表示されます IEC-タスク タスクグループ。 クリック [グループを追加] 新しいタスクグループを追加します。 ザル NewGroup グループが追加されました。 グループ名をダブルクリックします NewGroup そして、次のように変更します。 LowGroup 。 で コア 、課題を選択してください (例 1 )...", 
"body" : "要件:アプリケーションには少なくとも 2 つのタスクが定義されています。次に例を示します。 MainTask (IEC タスク) と LowTask (IEC タスク)。 を開く タスク設定 エディター内のオブジェクト。 に切り替える タスクグループ タブ。 概要にはデフォルトが表示されます IEC-タスク タスクグループ。 クリック [グループを追加] 新しいタスクグループを追加します。 ザル NewGroup グループが追加されました。 グループ名をダブルクリックします NewGroup そして、次のように変更します。 LowGroup 。 で コア 、課題を選択してください (例 1 )。 タスクを開く LowTask (IEC タスク) がエディタに表示されます。 で タスクグループ 、新しいグループを選択します。 LowGroup 。 ザル LowTask このタスクはプロセッサコア 1 のグループメンバシップにより、現在プロセッサコア 1 によって処理されています。 LowGroup 。 " }, 
{ "title" : "アプリケーションの保護 ", 
"url" : "_cds_encrypting_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ アプリケーションの保護 ", 
"snippet" : "PLC固有のライセンス管理と、アプリケーションのオブジェクトプロパティでの設定を使用して、ブートアプリケーションのノウハウ保護とコピー防止を実現します。ダウンロードコードとブートアプリケーションは暗号化して署名することができます。 詳細については、以下を参照してください。 ブートアプリケーションをロックしたり、署名したりする 。...", 
"body" : "PLC固有のライセンス管理と、アプリケーションのオブジェクトプロパティでの設定を使用して、ブートアプリケーションのノウハウ保護とコピー防止を実現します。ダウンロードコードとブートアプリケーションは暗号化して署名することができます。 詳細については、以下を参照してください。 ブートアプリケーションをロックしたり、署名したりする 。 " }, 
{ "title" : "データの永続性 ", 
"url" : "_cds_f_setting_data_persistence.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 ", 
"snippet" : "変数とそのデータの有効期間は、変数が作成されてから削除され、メモリスペースが再び解放されるまで延長されます。変数の作成、初期化、またはインスタンス化のタイミングは、宣言されたスコープによって異なります。通常、メモリ解放の時間も。たとえば、グローバル変数のメモリは、アプリケーションの終了時に解放されます。 通常よりも長くデータを保持できます。の次のメカニズム CODESYS この目的のために提供されます。 データ保存メカニズム （A）： 永続的なグローバル変数リスト キーワードで PERSISTENT RETAIN 永続変数は、アプリケーションがリロードされたときにその値を保持します。値は、ダウ...", 
"body" : "変数とそのデータの有効期間は、変数が作成されてから削除され、メモリスペースが再び解放されるまで延長されます。変数の作成、初期化、またはインスタンス化のタイミングは、宣言されたスコープによって異なります。通常、メモリ解放の時間も。たとえば、グローバル変数のメモリは、アプリケーションの終了時に解放されます。 通常よりも長くデータを保持できます。の次のメカニズム CODESYS この目的のために提供されます。 データ保存メカニズム （A）： 永続的なグローバル変数リスト キーワードで PERSISTENT RETAIN 永続変数は、アプリケーションがリロードされたときにその値を保持します。値は、ダウンロード、ウォームスタート、またはコールドスタート後にも復元されます。 （B）： 変数を保持する キーワードで RETAIN 保持変数は、ウォームスタート後も値を保持しますが、アプリケーションが再度ロードされたとき、ダウンロードまたはコールドスタートしたときは保持しません。 （C）： 永続性マネージャー変数 の CODESYS Application Composer PersistenceManager変数は外部ファイルに保存されます。 （D）： レシピ変数 レシピ変数とその値はレシピファイルに保存されます。 " }, 
{ "title" : "比較のメカニズム ", 
"url" : "_cds_f_setting_data_persistence.html#UUID-b0f99df2-e083-4576-131a-474b581d2136_section-idm4538086982022432656530449314", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ 比較のメカニズム ", 
"snippet" : "どのメカニズムがどのアプリケーションに適していますか？この表では、いくつかの一般的な使用例を検討しています。具体的な例は、ハウスコントロールを参照しています。 メカニズムとユースケースの比較 使用事例 （A）永続変数 （B）変数を保持する （c）永続性マネージャーの変数 （D）レシピ変数 1 アプリケーションはデバイス設定を受信する必要があります。 例：停電後、ハウスコントロールには、ブラインドを上げる必要がある時間に関する情報が必要です。 適切 1 推奨されるユースケース この場合、永続変数の代わりに保持変数を使用することもできます。これは、宣言が頻繁に変更される変数に有利です。 適切 推奨...", 
"body" : "どのメカニズムがどのアプリケーションに適していますか？この表では、いくつかの一般的な使用例を検討しています。具体的な例は、ハウスコントロールを参照しています。 メカニズムとユースケースの比較 使用事例 （A）永続変数 （B）変数を保持する （c）永続性マネージャーの変数 （D）レシピ変数 1 アプリケーションはデバイス設定を受信する必要があります。 例：停電後、ハウスコントロールには、ブラインドを上げる必要がある時間に関する情報が必要です。 適切 1 推奨されるユースケース この場合、永続変数の代わりに保持変数を使用することもできます。これは、宣言が頻繁に変更される変数に有利です。 適切 推奨されるユースケース 保持変数は、宣言が頻繁に変更される場合に有利です。 適切 2 ハードウェアをサポートしていないコントローラーに有利 これは、ダブルファイルバッファリングなどの特別な機能によって可能になります。 可能ですが、非常に面倒なのでお勧めしません 2 アプリケーションは、プログラムの変更または拡張後に値を受け取る必要もあります。 2a：まれな拡張 例：アプリケーションプログラマーは、プログラムに新しいスイッチを追加し、新しいライトをインストールします。その場合、ハウスコントロールには、その時点までに保存された値がまだ含まれている必要があります。 適切 1 推奨されるユースケース 適切 適切 2 可能ですが面倒です 2b：変数のデータ型の削除または変更を含む、より自由な変更 ハウスコントロールは実行され、永続化されています。アプリケーションプログラマーが新しい機能でコントロールを拡張し、したがって関数ブロックにさらに永続的な変数を追加する場合、その時点までに保存された値を保持する必要があります。たとえば、プログラムは、特定の時間の後に以前は制御されていなかったランプの自動スイッチオフを制御する変数によってFBで展開されます。拡張後、ハウスコントロールはすべての制御されたランプの時間を利用可能にする必要があります。 適切ではありません 適切 保持変数からのデータは、オンライン変更後も可能な限り保持されます。 適切 、可能な限り 2 推奨されるユースケース テキストの場合は可能ですが、扱いにくい 2c：アプリケーションはダウンロード後に値を受け取る必要があります。 適切 適切ではありません 適切 適切 3 アプリケーションは、さまざまな値セットを使用できる必要があります。 例：夏、冬、休暇の操作設定を保存し、必要に応じて再度インポートする必要があります。 適切ではありません 適切ではありません 適切ではありません 適切 推奨されるユースケース 4 アプリケーションは、別のシステムの設定を使用できる必要があります。 同様の変数を使用する別のシステムに設定を転送できる必要があります。 適切ではありません 適切ではありません 適切 2 適切 3 5 アプリケーションは、人間が読める形式のデータを提供する必要があります。 ユーザーは、データの読み取り、比較、および編集ができる必要があります。 適切ではありません 適切ではありません 適切 2 適切 3 1 短所：ランタイムシステムがこのメカニズムをサポートし、NVRamメモリまたはUPSが使用可能な場合にのみ可能です。利点：速度;推奨される使用例：1および2a 2 短所：変数の数が多い場合（> 10000）、初期化とシャットダウンに長い待機時間が予想されます。利点：特別なメモリ機器は必要ありません。値の保持は、変更、拡張、または削除にも適用されます。 3 利点：外部で編集可能、転送可能。短所：厄介 " }, 
{ "title" : "オンラインコマンドが呼び出されたときの変数の有効期間 ", 
"url" : "_cds_f_setting_data_persistence.html#UUID-b0f99df2-e083-4576-131a-474b581d2136_section-idm4654689529028832656531875814", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ オンラインコマンドが呼び出されたときの変数の有効期間 ", 
"snippet" : "メニューへのユーザー入力 オンライン 通常の寿命で可変 ない RETAIN まだ PERSISTENT RETAIN PERSISTENT RETAIN PERSISTENT PERSISTENT RETAIN 指図 オンライン変更 x x x 指図 ウォームリセット i x x 指図 コールドリセット i i x 指図 ロード i i バツ 1 指図 原点をリセット i i i x：変数はその値を保持します。 i：変数が初期化されます。 1 注：永続データの構造については、「ダウンロードメカニズム」の情報に注意してください。...", 
"body" : "メニューへのユーザー入力 オンライン 通常の寿命で可変 ない RETAIN まだ PERSISTENT RETAIN PERSISTENT RETAIN PERSISTENT PERSISTENT RETAIN 指図 オンライン変更 x x x 指図 ウォームリセット i x x 指図 コールドリセット i i x 指図 ロード i i バツ 1 指図 原点をリセット i i i x：変数はその値を保持します。 i：変数が初期化されます。 1 注：永続データの構造については、「ダウンロードメカニズム」の情報に注意してください。 " }, 
{ "title" : "ブート アプリケーションをロードするときの変数の寿命 ", 
"url" : "_cds_f_setting_data_persistence.html#UUID-b0f99df2-e083-4576-131a-474b581d2136_section-idm4501210508424032656532565093", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ ブート アプリケーションをロードするときの変数の寿命 ", 
"snippet" : "通常の変数の値は値を失い、再初期化されます。 永続変数の値は保護されています メモリ内の永続変数の構造が永続データ リスト内の構造と一致する場合。 永続データが拡張されただけの場合。この場合、最近追加された変数のみがデフォルト値で設定されます。 保持変数の値は保護されています メモリ内の保持変数の構造が永続データ リスト内の構造と一致する場合。 保持変数がアプリケーションと一致する場合 (GUID が一致する必要があります)。 アプリケーションの起動時に保持変数と永続変数の値を復元するための要件が満たされていない場合、「保持の不一致」が発生します。この不一致に対する反応は、ハードウェアメーカー...", 
"body" : "通常の変数の値は値を失い、再初期化されます。 永続変数の値は保護されています メモリ内の永続変数の構造が永続データ リスト内の構造と一致する場合。 永続データが拡張されただけの場合。この場合、最近追加された変数のみがデフォルト値で設定されます。 保持変数の値は保護されています メモリ内の保持変数の構造が永続データ リスト内の構造と一致する場合。 保持変数がアプリケーションと一致する場合 (GUID が一致する必要があります)。 アプリケーションの起動時に保持変数と永続変数の値を復元するための要件が満たされていない場合、「保持の不一致」が発生します。この不一致に対する反応は、ハードウェアメーカーのドキュメントに記載されています。 詳細については、次を参照してください。 永続変数でデータを保存する" }, 
{ "title" : "永続変数でデータを保存する ", 
"url" : "_cds_preserve_data_with_persistent_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ 永続変数でデータを保存する ", 
"snippet" : "永続変数は、ダウンロード、ウォームスタート、またはコールドスタートの後、アプリケーションがリロードされたときにその値を保持します。 NVRAMやUPSなどの耐用年数を延ばすには、コントローラに特別な不揮発性メモリ領域が必要です。このようなストレージへのデータのバックアップには追加の時間が必要ありません。これは、PersistenceManagerを使用したデータ保持よりも優れています。コントローラがハードウェアサポートを提供しない場合、データは通常ファイルに保存されます。コントローラを正しくシャットダウンすると、データが保持されます。ただし、停電や「プラグを抜く」とデータが失われます。...", 
"body" : "永続変数は、ダウンロード、ウォームスタート、またはコールドスタートの後、アプリケーションがリロードされたときにその値を保持します。 NVRAMやUPSなどの耐用年数を延ばすには、コントローラに特別な不揮発性メモリ領域が必要です。このようなストレージへのデータのバックアップには追加の時間が必要ありません。これは、PersistenceManagerを使用したデータ保持よりも優れています。コントローラがハードウェアサポートを提供しない場合、データは通常ファイルに保存されます。コントローラを正しくシャットダウンすると、データが保持されます。ただし、停電や「プラグを抜く」とデータが失われます。 " }, 
{ "title" : "行動 ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_id_cfd8277ed14d9477c0a86463695b061a_id_e6bc7e4a5dd83963c0a8652d0077df17", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ 永続変数でデータを保存する \/ 行動 ", 
"snippet" : "価値の保持 制御されていない終了 コマンドを呼び出してウォームスタート ウォームリセット コマンドを呼び出してコールドスタート コールドリセット アプリケーションを再度ダウンロードします 起動アプリケーションのロード での再初期化 コマンドを呼び出す 原点をリセット 永続変数は、コントローラーを配信ステータスにリセットした場合にのみ再初期化されます。たとえば、コマンドを使用した場合などです。 オンライン→原点リセット 選択する。 一方、アプリケーションを再度ロードすると、永続化されたデータは可能な限り保持されます。それは、変化がどれほど深遠であったかによって異なります。アプリケーション名を変更...", 
"body" : "価値の保持 制御されていない終了 コマンドを呼び出してウォームスタート ウォームリセット コマンドを呼び出してコールドスタート コールドリセット アプリケーションを再度ダウンロードします 起動アプリケーションのロード での再初期化 コマンドを呼び出す 原点をリセット 永続変数は、コントローラーを配信ステータスにリセットした場合にのみ再初期化されます。たとえば、コマンドを使用した場合などです。 オンライン→原点リセット 選択する。 一方、アプリケーションを再度ロードすると、永続化されたデータは可能な限り保持されます。それは、変化がどれほど深遠であったかによって異なります。アプリケーション名を変更すると、常に完全な再初期化が行われます。実装を変更しても、再初期化が発生することはありません。データの永続性は完全に保持されます。宣言を変更すると、既存の変数が永続的である場合にのみ、新しい変数が初期化されます。宣言を変更して、永続的な変数リストの一貫性を保つようにする必要があります。これは、新しい変数を追加するか、既存の変数を削除する場合です。以前に宣言された永続変数の識別子またはデータ型を編集および変更すると、不整合が発生する可能性があります。 " }, 
{ "title" : "アプリのダウンロード時や起動アプリのロード時の仕組み ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_id_cfd8277ed14d9477c0a86463695b061a_id_026b80bfdb38eee2c0a8646329d5dfb6", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ 永続変数でデータを保存する \/ アプリのダウンロード時や起動アプリのロード時の仕組み ", 
"snippet" : "永続性エディターで変数リストを編集すると、エディターに表示されるように変数リストが保存されず、保存される前に自動的に後編集されます。 後処理では、削除した変数が同じメモリフットプリントのプレースホルダー変数に置き換えられます。これは、次の変数がプロセスイメージ内のアドレスを保持することを意味します。また、追加した変数はすべてリストの最後に移動します。後処理により、永続性の喪失につながる変更を無効にすることができます。ただし、追加のメモリを消費するギャップが作成されます。 アプリケーションをロードすると、変数リストの CRC 値とリストの長さ (変数の数) がコントローラに保存されます。アプリケ...", 
"body" : "永続性エディターで変数リストを編集すると、エディターに表示されるように変数リストが保存されず、保存される前に自動的に後編集されます。 後処理では、削除した変数が同じメモリフットプリントのプレースホルダー変数に置き換えられます。これは、次の変数がプロセスイメージ内のアドレスを保持することを意味します。また、追加した変数はすべてリストの最後に移動します。後処理により、永続性の喪失につながる変更を無効にすることができます。ただし、追加のメモリを消費するギャップが作成されます。 アプリケーションをロードすると、変数リストの CRC 値とリストの長さ (変数の数) がコントローラに保存されます。アプリケーションを再度ロードすると、新しいテスト値が現在コントローラにあるテスト値と比較されます。次に、変数リストは、指定された長さまで連続して比較されます。宣言 (名前やデータ型など) を編集した場合、変数は再初期化されます。それ以外の場合、その値は保持されます。アプリケーションが再度読み込まれると、 CODESYS 永続性エディターで宣言された変数リストが、コントローラーに既にある変数リストとまだ整合性があるかどうかを確認します。 このメカニズムは、変数自体が大幅に変更されていない場合にうまく機能します。識別子とデータ型を過度に変更すると、再初期化と永続性の喪失につながり続けます。したがって、アプリケーションのニーズに基づいて頻繁に変更されることが予想される場合は、通常、このようなリストはお勧めしません。さらに、データ型の変更後にオンラインで変更が発生した場合、永続変数は通常の有効期間を持つ変数よりも堅牢性が低くなります。 基本的に、しばらくすると、ギャップの変数リストとコマンドをクリーンアップする必要があります リストを並べ替えてギャップをクリーンアップします 走る。ただし、クリーニング後、リストはコントローラー上のリストと一致しなくなり、すべての永続変数の初期化がトリガーされました。すべての変数の永続性が失われます。 V3.5 SP1より前のバージョンでは、永続性エディターでの変更により、常に再初期化が行われます。 " }, 
{ "title" : "レシピマネージャーを介してデータを保存する ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_section-idm454453384126563278957291646", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ 永続変数でデータを保存する \/ レシピマネージャーを介してデータを保存する ", 
"snippet" : "永続性を失うことなくグローバル永続変数リストをクリーンアップするために、レシピマネージャーを使用してレシピにデータを保存できます。永続変数リストのすべての変数のリストがレシピマネージャーで生成されると同時に、それらの現在の値がコントローラーによってレシピとして保存されます。次に、コマンドを選択します リストを並べ替えてギャップをクリーンアップします その後、再度ダウンロードします。あなたが今コマンドなら レシピから値を復元する を選択すると、レシピに保存されている値が復元されます。...", 
"body" : "永続性を失うことなくグローバル永続変数リストをクリーンアップするために、レシピマネージャーを使用してレシピにデータを保存できます。永続変数リストのすべての変数のリストがレシピマネージャーで生成されると同時に、それらの現在の値がコントローラーによってレシピとして保存されます。次に、コマンドを選択します リストを並べ替えてギャップをクリーンアップします その後、再度ダウンロードします。あなたが今コマンドなら レシピから値を復元する を選択すると、レシピに保存されている値が復元されます。 " }, 
{ "title" : "永続変数リストの既存の宣言を変更する ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_id_cfd8277ed14d9477c0a86463695b061a_id_adb14f80ef92a200c0a8646350a7e5b5", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ 永続変数でデータを保存する \/ 永続変数リストの既存の宣言を変更する ", 
"snippet" : "変数の名前またはデータ型を変更すると、これは新しい宣言として解釈され、次回のオンライン変更またはアプリケーションのロード時に変数が再初期化されます。複雑なデータ型の場合、新しいコンポーネントが追加されたとき、または変数の型を変更したときに変更が発生します。 INT に UINT 例えば、使用された構造の深さにおいて。 基本的に、複雑なユーザー定義データ型は、永続変数リストでの管理には適していません。小さな変更でも、変数がすべてのコンポーネントで初期化されるためです。...", 
"body" : "変数の名前またはデータ型を変更すると、これは新しい宣言として解釈され、次回のオンライン変更またはアプリケーションのロード時に変数が再初期化されます。複雑なデータ型の場合、新しいコンポーネントが追加されたとき、または変数の型を変更したときに変更が発生します。 INT に UINT 例えば、使用された構造の深さにおいて。 基本的に、複雑なユーザー定義データ型は、永続変数リストでの管理には適していません。小さな変更でも、変数がすべてのコンポーネントで初期化されるためです。 " }, 
{ "title" : "インスタンスパスでのメモリの二重割り当て ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_id_cfd8277ed14d9477c0a86463695b061a_id_91675dcb1796868bc0a864635066dcfe", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ 永続変数でデータを保存する \/ インスタンスパスでのメモリの二重割り当て ", 
"snippet" : "グローバル変数またはローカルで宣言された変数を関数ブロックまたはプログラムに永続化できます。これを行うには、宣言にキーワードを追加します PERSISTENT 。さらに、永続グローバル変数リストのこの変数にインスタンスパスを追加します。これを行うには、永続性エディターでコマンドを選択します すべてのインスタンスパスを追加します 。 永続性は、次のメカニズムによって保証されます。 変数にアクセスする循環タスクが決定されます。 （各サイクルの）最初の循環タスクの終了時に、変数が永続グローバル変数リストにコピーされます。 コントローラを再起動すると、値が永続変数から通常の変数にコピーされます。 この...", 
"body" : "グローバル変数またはローカルで宣言された変数を関数ブロックまたはプログラムに永続化できます。これを行うには、宣言にキーワードを追加します PERSISTENT 。さらに、永続グローバル変数リストのこの変数にインスタンスパスを追加します。これを行うには、永続性エディターでコマンドを選択します すべてのインスタンスパスを追加します 。 永続性は、次のメカニズムによって保証されます。 変数にアクセスする循環タスクが決定されます。 （各サイクルの）最初の循環タスクの終了時に、変数が永続グローバル変数リストにコピーされます。 コントローラを再起動すると、値が永続変数から通常の変数にコピーされます。 このメカニズムの欠点は、宣言のポイントとインスタンスパスのポイントの両方でメモリが割り当てられることです。この永続変数は占有します ダブル 収納スペース。さらに、データは各サイクルで両方の場所にコピーされます。これは、特に大きな構造化された値になると、時間がかかる可能性があります。 " }, 
{ "title" : "永続機能ブロックインスタンスのメモリ位置 ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_id_cfd8277ed14d9477c0a86463695b061a_id_cccc8c251cf2cccdc0a8646315994b40", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ 永続変数でデータを保存する \/ 永続機能ブロックインスタンスのメモリ位置 ", 
"snippet" : "機能ブロックインスタンスは常に完全にメモリ内にあります。これは、同じコードが異なるインスタンスで機能できるようにするために必要です。今なら、関数ブロック内の1つの変数のみ PERSISTENT がマークされている場合、関数ブロックインスタンスはすべての変数とともに完全に残留メモリに格納されますが、1つの変数のみが永続として扱われます。ただし、不揮発性メモリはメインメモリと同程度には使用できません。 変数としてSRAM内のインスタンスへのポインタを持つ機能ブロックは、保護されたメモリに格納されません。...", 
"body" : "機能ブロックインスタンスは常に完全にメモリ内にあります。これは、同じコードが異なるインスタンスで機能できるようにするために必要です。今なら、関数ブロック内の1つの変数のみ PERSISTENT がマークされている場合、関数ブロックインスタンスはすべての変数とともに完全に残留メモリに格納されますが、1つの変数のみが永続として扱われます。ただし、不揮発性メモリはメインメモリと同程度には使用できません。 変数としてSRAM内のインスタンスへのポインタを持つ機能ブロックは、保護されたメモリに格納されません。 " }, 
{ "title" : "からのインポート CoDeSys V2.3 -プロジェクト ", 
"url" : "_cds_preserve_data_with_persistent_variables.html#UUID-bcc57e65-52de-da87-eb3f-44eb3906544b_id_cfd8277ed14d9477c0a86463695b061a_id_574bae341796868bc0a86463467e40bc", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ 永続変数でデータを保存する \/ からのインポート CoDeSys V2.3 -プロジェクト ", 
"snippet" : "開くと CoDeSys V2.3 インポートするプロジェクト CODESYS V3 では、永続変数の宣言は保持されません。宣言を修正し、別の永続グローバル変数リストに再度作成する必要があります。...", 
"body" : "開くと CoDeSys V2.3 インポートするプロジェクト CODESYS V3 では、永続変数の宣言は保持されません。宣言を修正し、別の永続グローバル変数リストに再度作成する必要があります。 " }, 
{ "title" : "保持変数を使用してデータを取得する ", 
"url" : "_cds_preserve_data_with_retain_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ 保持変数を使用してデータを取得する ", 
"snippet" : "保持変数は、ウォームスタート後もその値を保持します。ただし、値の保持の程度は、永続変数の方が高くなります。 NVRAMやUPSなどの耐用年数を延ばすには、コントローラに特別な不揮発性メモリ領域が必要です。このようなメモリに保持変数を保存する場合、追加の時間は必要ありません。これは、PersistenceManagerを使用したデータ保持よりも優れています。コントローラがハードウェアサポートを提供しない場合、データは通常ファイルに保存されます。コントローラを正しくシャットダウンすると、データが保持されます。ただし、停電や「プラグを抜く」とデータが失われます。...", 
"body" : "保持変数は、ウォームスタート後もその値を保持します。ただし、値の保持の程度は、永続変数の方が高くなります。 NVRAMやUPSなどの耐用年数を延ばすには、コントローラに特別な不揮発性メモリ領域が必要です。このようなメモリに保持変数を保存する場合、追加の時間は必要ありません。これは、PersistenceManagerを使用したデータ保持よりも優れています。コントローラがハードウェアサポートを提供しない場合、データは通常ファイルに保存されます。コントローラを正しくシャットダウンすると、データが保持されます。ただし、停電や「プラグを抜く」とデータが失われます。 " }, 
{ "title" : "宣言 ", 
"url" : "_cds_preserve_data_with_retain_variables.html#UUID-2a4bd8c7-3a50-60c2-6dd4-d05d5cf2d578_id_f24d7503d14dee35c0a8646344406010_id_803fd478db437037c0a8646355c3075d", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ 保持変数を使用してデータを取得する \/ 宣言 ", 
"snippet" : "保持変数を宣言するには、変数宣言にキーワードを追加します RETAIN 追加した。...", 
"body" : "保持変数を宣言するには、変数宣言にキーワードを追加します RETAIN 追加した。 " }, 
{ "title" : "行動 ", 
"url" : "_cds_preserve_data_with_retain_variables.html#UUID-2a4bd8c7-3a50-60c2-6dd4-d05d5cf2d578_id_f24d7503d14dee35c0a8646344406010_id_91675dcb1796868bc0a864635066dcfe", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ 保持変数を使用してデータを取得する \/ 行動 ", 
"snippet" : "価値の保持 コントローラーの再起動 制御されない終了 (NvRAM などのハードウェア サポートでのみ利用可能) コマンドを呼び出す ウォームリセット での再初期化 アプリケーションを再度ダウンロードします コマンドを呼び出す コールドリセット （永続変数とは対照的に） コマンドを呼び出す 原点をリセット アプリケーションを再起動すると、その変数は通常、明示的に指定された初期値またはデフォルト値で初期化されます。キーワードでタグ付けされた変数 RETAIN マークは、ターゲットシステムに応じて別のメモリ領域で管理され、その値を保持します。たとえば、変数は電源障害から保護されています。そのため、...", 
"body" : "価値の保持 コントローラーの再起動 制御されない終了 (NvRAM などのハードウェア サポートでのみ利用可能) コマンドを呼び出す ウォームリセット での再初期化 アプリケーションを再度ダウンロードします コマンドを呼び出す コールドリセット （永続変数とは対照的に） コマンドを呼び出す 原点をリセット アプリケーションを再起動すると、その変数は通常、明示的に指定された初期値またはデフォルト値で初期化されます。キーワードでタグ付けされた変数 RETAIN マークは、ターゲットシステムに応じて別のメモリ領域で管理され、その値を保持します。たとえば、変数は電源障害から保護されています。そのため、製造施設のピースカウンターで保持変数を使用して、停電後もカウントを継続できます。 " }, 
{ "title" : "ファンクションブロックインスタンスを保持するメモリの場所 ", 
"url" : "_cds_preserve_data_with_retain_variables.html#UUID-2a4bd8c7-3a50-60c2-6dd4-d05d5cf2d578_id_f24d7503d14dee35c0a8646344406010_id_cccc8c251cf2cccdc0a8646315994b40", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ 保持変数を使用してデータを取得する \/ ファンクションブロックインスタンスを保持するメモリの場所 ", 
"snippet" : "ファンクションブロックインスタンスは、メモリ内の1つのピースにあります。これは、同じコードが異なるインスタンスで機能できるようにするために必要です。今なら、関数ブロック内の変数は RETAIN マークを付けると、機能ブロックの各インスタンスがすべての変数とともに保存されます。また、このようにマークされていない機能ブロックの変数。ただし、不揮発性メモリはメインメモリと同程度には使用できません。 変数としてSRAM内のインスタンスへのポインタを持つ機能ブロックは、保護されたメモリに格納されません。...", 
"body" : "ファンクションブロックインスタンスは、メモリ内の1つのピースにあります。これは、同じコードが異なるインスタンスで機能できるようにするために必要です。今なら、関数ブロック内の変数は RETAIN マークを付けると、機能ブロックの各インスタンスがすべての変数とともに保存されます。また、このようにマークされていない機能ブロックの変数。ただし、不揮発性メモリはメインメモリと同程度には使用できません。 変数としてSRAM内のインスタンスへのポインタを持つ機能ブロックは、保護されたメモリに格納されません。 " }, 
{ "title" : "からのインポート CoDeSys V2.3 -プロジェクト ", 
"url" : "_cds_preserve_data_with_retain_variables.html#UUID-2a4bd8c7-3a50-60c2-6dd4-d05d5cf2d578_id_f24d7503d14dee35c0a8646344406010_id_574bae341796868bc0a86463467e40bc", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ 保持変数を使用してデータを取得する \/ からのインポート CoDeSys V2.3 -プロジェクト ", 
"snippet" : "あなたが CoDeSys V2.3 -プロジェクトを開いて配置します CODESYS V3をインポートすると、保持変数の宣言は保持され、変更されずに有効になります。 詳細については、を参照してください。 RETAIN と V2.3プロジェクトを開く...", 
"body" : "あなたが CoDeSys V2.3 -プロジェクトを開いて配置します CODESYS V3をインポートすると、保持変数の宣言は保持され、変更されずに有効になります。 詳細については、を参照してください。 RETAIN と V2.3プロジェクトを開く" }, 
{ "title" : "PersistenceManager変数を使用してデータを保持する ", 
"url" : "_cds_preserve_data_ac.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ PersistenceManager変数を使用してデータを保持する ", 
"snippet" : "の中に 永続性マネージャー Application Composerの場合、変数は永続的に管理されます。の機能 永続性マネージャー 値とデータを受信するためにコントローラーに特別なメモリは必要ありません。...", 
"body" : "の中に 永続性マネージャー Application Composerの場合、変数は永続的に管理されます。の機能 永続性マネージャー 値とデータを受信するためにコントローラーに特別なメモリは必要ありません。 " }, 
{ "title" : "宣言 ", 
"url" : "_cds_preserve_data_ac.html#UUID-bbc6d774-55f9-b4d3-e6de-af462b9c94be_id_a536c64d14eb304c0a864635f20c358_id_4041284cefc6aceec0a864630792390d", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ PersistenceManager変数を使用してデータを保持する \/ 宣言 ", 
"snippet" : "Persistence Managerで管理される変数は、プラグマを使用した宣言に含まれています {attribute 'ac_persist'} マークされた。 プラグマにより、そのように属性付けられた変数がApplicationComposerのPersistenceManagerで管理されます。変数の宣言を変更したり、アプリケーションから変数を削除したり、新しい変数を追加したりしても、変数の値は保持されます。適切な変換を使用してデータ型を変更しても、値は保持されます。...", 
"body" : "Persistence Managerで管理される変数は、プラグマを使用した宣言に含まれています {attribute 'ac_persist'} マークされた。 プラグマにより、そのように属性付けられた変数がApplicationComposerのPersistenceManagerで管理されます。変数の宣言を変更したり、アプリケーションから変数を削除したり、新しい変数を追加したりしても、変数の値は保持されます。適切な変換を使用してデータ型を変更しても、値は保持されます。 " }, 
{ "title" : "機構 ", 
"url" : "_cds_preserve_data_ac.html#UUID-bbc6d774-55f9-b4d3-e6de-af462b9c94be_id_a536c64d14eb304c0a864635f20c358_id_c56775d6efc6aceec0a86463532fbcfd", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ PersistenceManager変数を使用してデータを保持する \/ 機構 ", 
"snippet" : "Persistence Manager変数は、それらの値と一緒にTXT形式の外部アーカイブファイルに保存されます。 アプリケーションコードは、永続性マネージャのコードによって拡張されます。これにより、より大きなメモリ要件が発生します。これはパフォーマンスを犠牲にします。また、大量の永続変数の読み取り、特に書き込みには長い時間がかかる場合があります。その結果、実行中のタスクはそれに応じて長時間実行をブロックします。...", 
"body" : "Persistence Manager変数は、それらの値と一緒にTXT形式の外部アーカイブファイルに保存されます。 アプリケーションコードは、永続性マネージャのコードによって拡張されます。これにより、より大きなメモリ要件が発生します。これはパフォーマンスを犠牲にします。また、大量の永続変数の読み取り、特に書き込みには長い時間がかかる場合があります。その結果、実行中のタスクはそれに応じて長時間実行をブロックします。 " }, 
{ "title" : "機能性 ", 
"url" : "_cds_preserve_data_ac.html#UUID-bbc6d774-55f9-b4d3-e6de-af462b9c94be_id_a536c64d14eb304c0a864635f20c358_id_3a850974d202a5e6c0a8646366306c87", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ PersistenceManager変数を使用してデータを保持する \/ 機能性 ", 
"snippet" : "TXTファイルは、Notepad ++などの外部エディタでロードおよび編集できます。 ファイルの永続変数を別のアプリケーションで使用できます。 永続グループを定義し、それらを変数に割り当て、独自のストレージおよび読み取り動作でグループを構成することにより、永続変数の動作を構成できます。...", 
"body" : "TXTファイルは、Notepad ++などの外部エディタでロードおよび編集できます。 ファイルの永続変数を別のアプリケーションで使用できます。 永続グループを定義し、それらを変数に割り当て、独自のストレージおよび読み取り動作でグループを構成することにより、永続変数の動作を構成できます。 " }, 
{ "title" : "レシピでデータを取得する ", 
"url" : "_cds_preserve_data_with_recipes.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ レシピでデータを取得する ", 
"snippet" : "変数はレシピマネージャーで永続的に管理されます。レシピマネージャーは、値とデータを受信するためにコントローラーに特別なメモリを必要としません。...", 
"body" : "変数はレシピマネージャーで永続的に管理されます。レシピマネージャーは、値とデータを受信するためにコントローラーに特別なメモリを必要としません。 " }, 
{ "title" : "宣言 ", 
"url" : "_cds_preserve_data_with_recipes.html#UUID-1dbefc8c-9b39-17e5-c1e5-8a6df87d0498_id_b66a4132d14f2b7fc0a864630fe45862_id_c56775d6efc6aceec0a86463532fbcfd", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ レシピでデータを取得する \/ 宣言 ", 
"snippet" : "レシピ定義は、値を持つ変数のセットで構成され、オブジェクトで定義されます レシピマネージャー 作成、編集、ファイルとして保存。...", 
"body" : "レシピ定義は、値を持つ変数のセットで構成され、オブジェクトで定義されます レシピマネージャー 作成、編集、ファイルとして保存。 " }, 
{ "title" : "機能性 ", 
"url" : "_cds_preserve_data_with_recipes.html#UUID-1dbefc8c-9b39-17e5-c1e5-8a6df87d0498_id_b66a4132d14f2b7fc0a864630fe45862_id_53bd4e7cd202a692c0a8646369dae647", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ レシピでデータを取得する \/ 機能性 ", 
"snippet" : "それぞれ異なる値を持ついくつかのレシピに変数を含めることができます。 オンラインモードでは、コントローラーから変数の実際の値を読み取り、レシピ値（セットポイント）として保存できます。 ライブラリを利用できます Recipe Management レシピの作成と処理をプログラムで実装します。 レシピをレシピファイルとして保存および保存できます。...", 
"body" : "それぞれ異なる値を持ついくつかのレシピに変数を含めることができます。 オンラインモードでは、コントローラーから変数の実際の値を読み取り、レシピ値（セットポイント）として保存できます。 ライブラリを利用できます Recipe Management レシピの作成と処理をプログラムで実装します。 レシピをレシピファイルとして保存および保存できます。 " }, 
{ "title" : "VAR_PERSISTENT変数を宣言します ", 
"url" : "_cds_setting_up_persistence.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ VAR_PERSISTENT変数を宣言します ", 
"snippet" : "以下では、永続変数リストとPOUで永続変数を宣言します。 要件：プロジェクトが開いており、プログラムPOUが含まれています。オプション（メニューコマンド ツール→オプション ）あなたはそのカテゴリーにいます 宣言エディタ テキストビューのオプションがアクティブになります。 メニューコマンドを使用してアップリケオブジェクトを追加します プロジェクト→オブジェクトの追加 オブジェクト 永続変数 追加した。 CODESYS 永続変数リストを追加します PersistentVars デバイスツリーのアプリケーションオブジェクトの下にあり、エディタが開きます。 メモ帳に入力します VAR_GLOBAL ...", 
"body" : "以下では、永続変数リストとPOUで永続変数を宣言します。 要件：プロジェクトが開いており、プログラムPOUが含まれています。オプション（メニューコマンド ツール→オプション ）あなたはそのカテゴリーにいます 宣言エディタ テキストビューのオプションがアクティブになります。 メニューコマンドを使用してアップリケオブジェクトを追加します プロジェクト→オブジェクトの追加 オブジェクト 永続変数 追加した。 CODESYS 永続変数リストを追加します PersistentVars デバイスツリーのアプリケーションオブジェクトの下にあり、エディタが開きます。 メモ帳に入力します VAR_GLOBAL PERSISTENT RETAIN と END_VAR たとえば、変数宣言 ivarpersist1 : INT; 。 デバイスツリーでPOUをダブルクリックします。 POUのエディターが開きます。 宣言部分に、次の宣言を入力します。 VAR PERSISTENT RETAIN ivarpersist2 ：INT; END_VAR メニューコマンドを選択します 作成→翻訳 。 メッセージウィンドウが開きます。いつ CODESYS アプリケーションはエラーなしでコンパイルされました。メッセージウィンドウを閉じて、次の手順に進みます。それ以外の場合は、エラーを修正して、メニューコマンドを再度選択してください 作成→翻訳 。 エディターにフォーカスを置く PersistentVars 。メニューコマンドを選択します 宣言→ すべてのインスタンスパスを追加します 。 CODESYS 永続変数を永続変数リストに追加します PersistentVars POUに追加： \/\/ Instanzpfad der persistenten Variablen erzeugt POU.IVARPERSIST2 : INT " }, 
{ "title" : "永続変数リストの値をレシピに保存する ", 
"url" : "_cds_saving_persistent_list.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ データの永続性 \/ 永続変数リストの値をレシピに保存する ", 
"snippet" : "要件：プロジェクトが開いていて、アプリケーションオブジェクトの下に、永続変数の宣言を含む永続変数リストがあります。 デバイスツリーでコントローラーをダブルクリックし、タブを選択します コミュニケーション 。 ゲートウェイを選択し、ボタンをクリックします ネットワークを閲覧する 。 デバイスは、ゲートウェイツリービューに太字で表示されます。 デバイスを選択してボタンをクリックします アクティブパスを設定する 。 デバイスツリーでアプリケーションオブジェクトを選択し、コンテキストメニューコマンドを選択します アクティブなアプリケーションを設定する 。 アプリケーションオブジェクトは太字で示されてい...", 
"body" : "要件：プロジェクトが開いていて、アプリケーションオブジェクトの下に、永続変数の宣言を含む永続変数リストがあります。 デバイスツリーでコントローラーをダブルクリックし、タブを選択します コミュニケーション 。 ゲートウェイを選択し、ボタンをクリックします ネットワークを閲覧する 。 デバイスは、ゲートウェイツリービューに太字で表示されます。 デバイスを選択してボタンをクリックします アクティブパスを設定する 。 デバイスツリーでアプリケーションオブジェクトを選択し、コンテキストメニューコマンドを選択します アクティブなアプリケーションを設定する 。 アプリケーションオブジェクトは太字で示されています。 メニューコマンドを選択します オンライン→ログイン 。 アプリケーションはコントローラーにログインしており、デバイスツリーのコントローラーとアプリケーションオブジェクトの背景は緑色です。 永続変数リストをダブルクリックして、コマンドを選択します 宣言→ レシピに現在の値を保存する 。 CODESYS アプリケーションオブジェクトの下にオブジェクトを作成します レシピマネージャー と PersistentVariables 。 メニューコマンドを選択します オンライン→ログアウト 。 アプリケーションはコントローラーからログアウトされます。 " }, 
{ "title" : "暗黙のチェックにビルディングブロックを使用する ", 
"url" : "_cds_using_pous_for_implicit_check.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ 暗黙のチェックにビルディングブロックを使用する ", 
"snippet" : "CODESYS 暗黙の監視機能を実装する特別なPOUを提供します。これらの関数は、配列またはサブ範囲タイプの境界、ポインターアドレスの有効性、または実行時にゼロによる除算をチェックします。 オブジェクトを選択します 応用 デバイスツリー内。 コマンドを選択します プロジェクト→オブジェクトの追加→暗黙的なチェックのためのPOU 。 ダイアログが表示されます 暗黙のチェックのためにPOUを追加する 。 目的の機能をアクティブにします。 ボタンをクリックします 追加 。 選択したPOUが下に表示されます 応用 デバイスツリーに挿入されます。 エディターでPOUを開きます。 実装提案を要件に適合させ...", 
"body" : "CODESYS 暗黙の監視機能を実装する特別なPOUを提供します。これらの関数は、配列またはサブ範囲タイプの境界、ポインターアドレスの有効性、または実行時にゼロによる除算をチェックします。 オブジェクトを選択します 応用 デバイスツリー内。 コマンドを選択します プロジェクト→オブジェクトの追加→暗黙的なチェックのためのPOU 。 ダイアログが表示されます 暗黙のチェックのためにPOUを追加する 。 目的の機能をアクティブにします。 ボタンをクリックします 追加 。 選択したPOUが下に表示されます 応用 デバイスツリーに挿入されます。 エディターでPOUを開きます。 実装提案を要件に適合させます。 監視機能の機能を維持するために、宣言部分を変更してはなりません。唯一の例外は、ローカル変数を追加できることです。 " }, 
{ "title" : "オブジェクト指向プログラミング ", 
"url" : "_cds_f_object_oriented_programming.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オブジェクト指向プログラミング ", 
"snippet" : "CODESYS 関数ブロックを使用したオブジェクト指向プログラミングをサポートし、このために次の機能とオブジェクトを提供します。 メソッド インターフェイス プロパティ 継承 メソッド呼び出し、仮想関数呼び出し 他の機能ブロックの拡張としての機能ブロックの定義...", 
"body" : "CODESYS 関数ブロックを使用したオブジェクト指向プログラミングをサポートし、このために次の機能とオブジェクトを提供します。 メソッド インターフェイス プロパティ 継承 メソッド呼び出し、仮想関数呼び出し 他の機能ブロックの拡張としての機能ブロックの定義 " }, 
{ "title" : "機能ブロックの拡張 ", 
"url" : "_cds_extending_function_block.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オブジェクト指向プログラミング \/ 機能ブロックの拡張 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "全般的 ", 
"url" : "_cds_extending_function_block.html#UUID-9227be4c-31f9-73e0-19cf-95ca7326aa82_section-idm4538086976649632656586029339", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オブジェクト指向プログラミング \/ 機能ブロックの拡張 \/ 全般的 ", 
"snippet" : "関数ブロックの拡張は、オブジェクト指向プログラミングにおける継承の概念に基づいています。この目的のために、派生関数ブロックは基本関数ブロックを「拡張」し、それ自体のプロパティに加えて基本関数ブロックのプロパティを受け取ります。 機能ブロックの拡張とは、次のことを意味します。 派生関数ブロックには、基本関数ブロックによって定義されたすべてのデータとメソッドが含まれています。基本機能ブロックのインスタンスは、次のようなコンテキストで使用できます。 CODESYS 基本機能ブロックタイプの機能ブロックが必要です。 派生汎用モジュールは、基本汎用モジュールで定義したメソッドを上書きすることができます。...", 
"body" : "関数ブロックの拡張は、オブジェクト指向プログラミングにおける継承の概念に基づいています。この目的のために、派生関数ブロックは基本関数ブロックを「拡張」し、それ自体のプロパティに加えて基本関数ブロックのプロパティを受け取ります。 機能ブロックの拡張とは、次のことを意味します。 派生関数ブロックには、基本関数ブロックによって定義されたすべてのデータとメソッドが含まれています。基本機能ブロックのインスタンスは、次のようなコンテキストで使用できます。 CODESYS 基本機能ブロックタイプの機能ブロックが必要です。 派生汎用モジュールは、基本汎用モジュールで定義したメソッドを上書きすることができます。つまり、派生関数ブロックは、基本関数ブロックで定義されているのと同じ名前、入力、および出力でメソッドを定義できます。 ヒント：基本ブロックから継承されたメソッド、アクション、プロパティ、および遷移のこの上書きに対して、次のサポートが提供されます。派生したビルディングブロックの下にメソッドやアクションなどを挿入すると、ダイアログが表示されます オブジェクトを追加 基本モジュールで使用されるメソッド、アクションなどを選択したコンボボックスであり、それらを受け入れることができますが、それに応じてそれらを適応させる必要があります。 派生関数ブロックには、基本関数ブロックが使用するのと同じ名前の関数ブロック変数を含めることはできません。コンパイラはこれをエラーとして報告します。 唯一の例外：基本機能ブロックで変数を次のように使用する場合 VAR_TEMP 宣言された場合、派生関数ブロックは同じ名前の変数を定義できます。この場合、派生機能ブロックは基本機能ブロックの変数にアクセスできなくなります。 派生関数ブロックのスコープ内で基本関数ブロックの変数とメソッドを使用するには、 SUPER -ポインタを直接アドレス指定します。 多重継承は許可されていません。 例外：機能ブロックは複数のインターフェースを実装でき、インターフェースは他のインターフェースを拡張できます。 " }, 
{ "title" : "新しい機能ブロックによる基本機能ブロックの拡張 ", 
"url" : "_cds_extending_function_block.html#UUID-9227be4c-31f9-73e0-19cf-95ca7326aa82_id_bc846ea1a9450c0a8640e0123a187_id_a8817c8cf42e9706c0a8640e013e9a51", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オブジェクト指向プログラミング \/ 機能ブロックの拡張 \/ 新しい機能ブロックによる基本機能ブロックの拡張 ", 
"snippet" : "要件：現在開いているプロジェクトには、たとえば基本的な機能ブロックがあります POU_1（FB） 、これは新しい汎用モジュールによって拡張されます。 オブジェクトを選択します 応用 デバイスツリーで、メニューコマンドを選択します プロジェクト→オブジェクトの追加→POU 。 対話 POUを追加する 開きます。 入力項目に新しい汎用モジュールの名称を入力します 姓 たとえば、 POU_Ex 。 選ぶ 汎用モジュール 。 選ぶ 高度 ボタンをクリックします 。 エントリヘルパーで、カテゴリから選択します ファンクションブロック 下 応用 たとえば、基本機能ブロックとして機能するPOU（FB） PO...", 
"body" : "要件：現在開いているプロジェクトには、たとえば基本的な機能ブロックがあります POU_1（FB） 、これは新しい汎用モジュールによって拡張されます。 オブジェクトを選択します 応用 デバイスツリーで、メニューコマンドを選択します プロジェクト→オブジェクトの追加→POU 。 対話 POUを追加する 開きます。 入力項目に新しい汎用モジュールの名称を入力します 姓 たとえば、 POU_Ex 。 選ぶ 汎用モジュール 。 選ぶ 高度 ボタンをクリックします 。 エントリヘルパーで、カテゴリから選択します ファンクションブロック 下 応用 たとえば、基本機能ブロックとして機能するPOU（FB） POU_1 をクリックします わかった 。 オプションであなたは1つを持つことができます アクセス修飾子 コンボボックスからの新しい機能ブロック用。 コンボボックスから選択 実装言語 例えば 構造化テキスト（ST） アウト。 クリック 追加 。 CODESYS 機能ブロックを追加します POU_Ex デバイスツリーに移動すると、エディターが開きます。最初の行は次のように述べています。 FUNCTION_BLOCK POU_Ex EXTENDS POU_1 機能ブロック POU_Ex 基本機能ブロックを拡張します POU_1 。 " }, 
{ "title" : "基本機能ブロックを既存の機能ブロックで拡張する ", 
"url" : "_cds_extending_function_block.html#UUID-9227be4c-31f9-73e0-19cf-95ca7326aa82_id_bc846ea1a9450c0a8640e0123a187_id_630b9b97941a86bac0a864632a5ce350", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オブジェクト指向プログラミング \/ 機能ブロックの拡張 \/ 基本機能ブロックを既存の機能ブロックで拡張する ", 
"snippet" : "要件：現在開いているプロジェクトには、たとえば基本的な機能ブロックがあります POU_1(FB) 、および別の機能ブロック、たとえば POU_Ex(FB) 。機能ブロック POU_Ex(FB) 基本機能ブロックのプロパティも必要です。つまり、次のことを意味します。 POU_Ex(FB) 目標 POU_1(FB) 拡大。 デバイスツリーの機能ブロックをダブルクリックします POU_Ex(FB) 。 機能ブロックのエディタが開きます。 既存の一番上の行のエントリを展開します FUNCTION_BLOCK POU_Ex と EXTENDS POU_1 。 機能ブロックPOU_Exは、基本機能ブロック...", 
"body" : "要件：現在開いているプロジェクトには、たとえば基本的な機能ブロックがあります POU_1(FB) 、および別の機能ブロック、たとえば POU_Ex(FB) 。機能ブロック POU_Ex(FB) 基本機能ブロックのプロパティも必要です。つまり、次のことを意味します。 POU_Ex(FB) 目標 POU_1(FB) 拡大。 デバイスツリーの機能ブロックをダブルクリックします POU_Ex(FB) 。 機能ブロックのエディタが開きます。 既存の一番上の行のエントリを展開します FUNCTION_BLOCK POU_Ex と EXTENDS POU_1 。 機能ブロックPOU_Exは、基本機能ブロックを拡張します POU_1 。 詳細については、以下を参照してください。 インターフェイスを実装する と インターフェイスを拡張する" }, 
{ "title" : "継承POUを生成する際の入力サポート ", 
"url" : "_cds_extending_function_block.html#UUID-1d94a1a9-161e-c24e-9497-750a39f396c9", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オブジェクト指向プログラミング \/ 機能ブロックの拡張 \/ 継承POUを生成する際の入力サポート ", 
"snippet" : "オブジェクト指向プログラミングを行い、継承を使用する場合（ EXTENDS  キーワード）POUの場合、次のようにサポートを受けることができます。 ベースPOUから派生したPOUの下にアクション、プロパティ、メソッド、またはトランジションを挿入すると、 追加 … ダイアログが開きます。次に、名前の入力フィールドがリストボックスに拡張されます。リストボックスには、ベースPOUで使用可能なアクション、プロパティ、メソッド、またはトランジションからの有効な選択が含まれています。これで、たとえば、ベースPOUのメソッドを簡単に受け入れて、それをPOUの派生関数に適合させることができます。 アクセス修飾...", 
"body" : "オブジェクト指向プログラミングを行い、継承を使用する場合（ EXTENDS  キーワード）POUの場合、次のようにサポートを受けることができます。 ベースPOUから派生したPOUの下にアクション、プロパティ、メソッド、またはトランジションを挿入すると、 追加 … ダイアログが開きます。次に、名前の入力フィールドがリストボックスに拡張されます。リストボックスには、ベースPOUで使用可能なアクション、プロパティ、メソッド、またはトランジションからの有効な選択が含まれています。これで、たとえば、ベースPOUのメソッドを簡単に受け入れて、それをPOUの派生関数に適合させることができます。 アクセス修飾子を使用したメソッドとプロパティ PRIVATE それらも継承されないため、ここにはリストされていません。アクセス修飾子を使用したメソッドとプロパティ PUBLIC 派生したPOUに受け入れると、自動的に空白のアクセス修飾子フィールドを取得します。これは、機能的には同じことを意味します。 詳細については、以下を参照してください。 財産、 方法、 遷移、 アクション、 例 " }, 
{ "title" : "インターフェイスを実装する ", 
"url" : "_cds_implementing_interface.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オブジェクト指向プログラミング \/ インターフェイスを実装する ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "インターフェイスを実装する ", 
"url" : "_cds_implementing_interface.html#UUID-4357ee1b-de95-b6cf-0c34-d4c867466ac7_section-idm4538086982283232656593653643", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オブジェクト指向プログラミング \/ インターフェイスを実装する \/ インターフェイスを実装する ", 
"snippet" : "インターフェイスの実装は、オブジェクト指向プログラミングの概念に基づいています。共通のインタフェースを介して、異なるが類似した機能ブロックを同じ方法で使用することもできます。 インターフェイスを実装する機能ブロックには、このインターフェイスで定義されているすべてのメソッドとプロパティ（インターフェイスメソッドとインターフェイスプロパティ）が含まれている必要があります。つまり、それぞれのメソッドまたはプロパティの名前、入力、および出力は完全に同じである必要があります。 インタフェースを実装する新しい汎用モジュールを登録すると、以下が追加されます。 CODESYS ツリーの新しい汎用モジュールの下...", 
"body" : "インターフェイスの実装は、オブジェクト指向プログラミングの概念に基づいています。共通のインタフェースを介して、異なるが類似した機能ブロックを同じ方法で使用することもできます。 インターフェイスを実装する機能ブロックには、このインターフェイスで定義されているすべてのメソッドとプロパティ（インターフェイスメソッドとインターフェイスプロパティ）が含まれている必要があります。つまり、それぞれのメソッドまたはプロパティの名前、入力、および出力は完全に同じである必要があります。 インタフェースを実装する新しい汎用モジュールを登録すると、以下が追加されます。 CODESYS ツリーの新しい汎用モジュールの下に、このインタフェースのすべてのメソッドとプロパティが自動的に入力されます。 その後、インターフェースにメソッドを追加すると、 CODESYS これらのメソッドは、関連する汎用モジュールに自動的に追加されません。更新するには、コマンドを明示的に使用する必要があります インターフェイスを実装する 選ぶ。 派生関数ブロックの場合、インターフェースからの「継承」によって採用されたメソッドまたはプロパティが目的の実装を受け取るか、基本の実装を使用する場合は削除されるようにする必要があります。自動的に挿入されたプラグマ属性によって引き起こされる、対応する翻訳エラーメッセージまたは警告を受け取ります。コマンドのヘルプページを参照してください インターフェイスを実装する 。 変数を介してメソッドを呼び出す前に、機能ブロックのインタフェースをインタフェースタイプの変数に割り当てる必要があります。 インターフェイスタイプの変数は、常に割り当てられた機能ブロックインスタンスの参照です。 インターフェイス型変数は、ファンクションブロックのインスタンスへの参照です。このような変数は、インターフェースを実装する任意の機能ブロックを参照できます。変数に割り当てが行われていない場合、変数にはオンラインモードの値が含まれます 0 。 例 インターフェイス I1 メソッドが含まれています GetName 。 METHOD GetName : STRING 機能ブロック A と B それぞれがインターフェースを実装します I1 ： FUNCTION_BLOCK A IMPLEMENTS I1\nFUNCTION_BLOCK B IMPLEMENTS I1 したがって、両方の汎用モジュールには、次の名前のメソッドが必要です。 GetName とリターンタイプ STRING 含む。それ以外の場合、コンパイラはエラーを報告します。 関数には、インターフェイスタイプの変数の宣言が含まれています I1 。 FUNCTION DeliverName : STRING\nVAR_INPUT\n l_i : I1;\nEND_VAR インターフェースがブロックする機能 I1 実装、この入力変数に割り当てることができます。 関数呼び出しの例： DeliverName(l_i := A_instance); \/\/ call with instance of type A\nDeliverName(l_i := B_instance); \/\/ call with instance of type B インターフェイスメソッドの呼び出し： この場合、それは実際のタイプに依存します l_i アプリケーションかどうかから A.GetName また B.GetName 呼び出します。 DeliverName := l_i.GetName(); " }, 
{ "title" : "新しい汎用モジュールでのインタフェースの実装 ", 
"url" : "_cds_implementing_interface.html#UUID-4357ee1b-de95-b6cf-0c34-d4c867466ac7_id_de36840f50d462dc0a8640e016628e4_id_c92d2957f9591e5dc0a8640e00619caf", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オブジェクト指向プログラミング \/ インターフェイスを実装する \/ 新しい汎用モジュールでのインタフェースの実装 ", 
"snippet" : "要件：現在開いているプロジェクトには、少なくとも1つのインターフェイスオブジェクトがあります。 選択する 応用 デバイスツリーで、メニューコマンドを選択します プロジェクト→オブジェクトの追加→POU 。 対話 POUを追加する 開きます。 入力項目に新しい汎用モジュールの名称を入力します 姓 1つ、例えば POU_Im 。 選ぶ ファンクションブロック 。 選ぶ 実装 ボタンをクリックします 。 エントリヘルパーで、カテゴリから選択します インターフェイス たとえばインターフェース ITF1 をクリックします わかった 。 別のインターフェースを追加するには、もう一度クリックします 別のイン...", 
"body" : "要件：現在開いているプロジェクトには、少なくとも1つのインターフェイスオブジェクトがあります。 選択する 応用 デバイスツリーで、メニューコマンドを選択します プロジェクト→オブジェクトの追加→POU 。 対話 POUを追加する 開きます。 入力項目に新しい汎用モジュールの名称を入力します 姓 1つ、例えば POU_Im 。 選ぶ ファンクションブロック 。 選ぶ 実装 ボタンをクリックします 。 エントリヘルパーで、カテゴリから選択します インターフェイス たとえばインターフェース ITF1 をクリックします わかった 。 別のインターフェースを追加するには、もう一度クリックします 別のインターフェースを選択します。 オプションであなたは1つを持つことができます アクセス修飾子 選択リストからの新しい汎用モジュールの場合。 ドロップダウンリストから選択します 実装言語 例えば 構造化テキスト（ST） アウト。 クリック 追加 。 CODESYS 機能ブロックを追加します POU_Ex デバイスツリーに移動すると、エディターが開きます。最初の行は次のように述べています。 FUNCTION_BLOCK POU_Im IMPLEMENTS ITF1 これで、インターフェイスとそのメソッドおよびプロパティが関数ブロックの下のデバイスツリーに挿入され、インターフェイスとそのメソッドの実装部分にプログラムコードを入力できるようになりました。 " }, 
{ "title" : "既存の機能ブロックにインターフェースを実装する ", 
"url" : "_cds_implementing_interface.html#UUID-4357ee1b-de95-b6cf-0c34-d4c867466ac7_id_de36840f50d462dc0a8640e016628e4_id_dce21526b91b0bfbc0a8640e001af42d", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オブジェクト指向プログラミング \/ インターフェイスを実装する \/ 既存の機能ブロックにインターフェースを実装する ", 
"snippet" : "要件：現在開いているプロジェクトには、たとえば機能ブロックがあります POU_Im たとえば、少なくとも1つのインターフェイスオブジェクト ITF1 。 デバイスツリーでPOUをダブルクリックします POU_Ex（FB） 。 POUのエディターが開きます。 既存の一番上の行のエントリを展開します FUNCTION_BLOCK POU_Im と IMPLEMENTS ITF1 。 機能ブロック POU_Im インターフェイスを実装します ITF1 。...", 
"body" : "要件：現在開いているプロジェクトには、たとえば機能ブロックがあります POU_Im たとえば、少なくとも1つのインターフェイスオブジェクト ITF1 。 デバイスツリーでPOUをダブルクリックします POU_Ex（FB） 。 POUのエディターが開きます。 既存の一番上の行のエントリを展開します FUNCTION_BLOCK POU_Im と IMPLEMENTS ITF1 。 機能ブロック POU_Im インターフェイスを実装します ITF1 。 " }, 
{ "title" : "インターフェイスを拡張する ", 
"url" : "_cds_extending_interface.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オブジェクト指向プログラミング \/ インターフェイスを拡張する ", 
"snippet" : "汎用モジュールだけでなくインタフェースも拡張することができます。次に、インターフェイスは、独自のインターフェイスに加えて、ベースインターフェイスのインターフェイスメソッドとインターフェイスプロパティも取得します。 別のインターフェースを拡張するインターフェースを作成します。 オブジェクトを選択します 応用 デバイスツリー内。 コマンドを選択します プロジェクト→オブジェクトの追加→ インターフェース 。 対話 インターフェイスを追加 開きます。 新しいインターフェイスの名前を入力します。 オプションを有効にする 高度 ボタンをクリックします 。 入力ヘルプが開きます。 カテゴリから選択 インタ...", 
"body" : "汎用モジュールだけでなくインタフェースも拡張することができます。次に、インターフェイスは、独自のインターフェイスに加えて、ベースインターフェイスのインターフェイスメソッドとインターフェイスプロパティも取得します。 別のインターフェースを拡張するインターフェースを作成します。 オブジェクトを選択します 応用 デバイスツリー内。 コマンドを選択します プロジェクト→オブジェクトの追加→ インターフェース 。 対話 インターフェイスを追加 開きます。 新しいインターフェイスの名前を入力します。 オプションを有効にする 高度 ボタンをクリックします 。 入力ヘルプが開きます。 カテゴリから選択 インターフェイス 新しいインターフェースによって拡張されるインターフェース。 " }, 
{ "title" : "メソッド呼び出し ", 
"url" : "_cds_method_call.html", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オブジェクト指向プログラミング \/ メソッド呼び出し ", 
"snippet" : "メソッド呼び出しを実装するために、実際のパラメーター（引数）がインターフェース変数に渡されます。または、パラメーター名を省略できます。 宣言されたアクセス修飾子に応じて、メソッドはそれ自体の名前空間内でのみ使用できます（ INTERNAL ）、独自のプログラミングブロックとその派生物内でのみ（ PROTECTED ）または独自のプログラミングブロック内のみ（ PRIVATE ）呼び出されます。で PUBLIC メソッドはどこからでも呼び出すことができます。 実装内では、メソッドはそれ自体を再帰的に呼び出すことができます。メソッドは、 これ ポインタ、または割り当てられた機能ブロックのローカル変...", 
"body" : "メソッド呼び出しを実装するために、実際のパラメーター（引数）がインターフェース変数に渡されます。または、パラメーター名を省略できます。 宣言されたアクセス修飾子に応じて、メソッドはそれ自体の名前空間内でのみ使用できます（ INTERNAL ）、独自のプログラミングブロックとその派生物内でのみ（ PROTECTED ）または独自のプログラミングブロック内のみ（ PRIVATE ）呼び出されます。で PUBLIC メソッドはどこからでも呼び出すことができます。 実装内では、メソッドはそれ自体を再帰的に呼び出すことができます。メソッドは、 これ ポインタ、または割り当てられた機能ブロックのローカル変数を使用します。 " }, 
{ "title" : "仮想関数呼び出しとしてのメソッド呼び出し ", 
"url" : "_cds_method_call.html#UUID-1140c736-2d89-bf68-7fec-9630a34558d8_id_d5035cf9d32eddc0a8640e0188f0bb_id_933ec828942a17e2c0a86463080c36ba", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オブジェクト指向プログラミング \/ メソッド呼び出し \/ 仮想関数呼び出しとしてのメソッド呼び出し ", 
"snippet" : "継承は仮想関数呼び出しにつながる可能性があります。 仮想関数呼び出しを使用すると、プログラムのソースコードで同じ呼び出しを実行すると、実行時に異なるメソッドを呼び出すことができます。 メソッド呼び出しは、次の場合に動的にバインドされます。 汎用モジュールへのポインタを使用してメソッドを呼び出します。 例： pfub^.method この状況では、ポインタは機能ブロックタイプのインスタンスとすべての派生機能ブロックのインスタンスを指すことができます。 インターフェイス変数のメソッドを呼び出します。 例： interface1.method インターフェイスは、このインターフェイスを実装するファン...", 
"body" : "継承は仮想関数呼び出しにつながる可能性があります。 仮想関数呼び出しを使用すると、プログラムのソースコードで同じ呼び出しを実行すると、実行時に異なるメソッドを呼び出すことができます。 メソッド呼び出しは、次の場合に動的にバインドされます。 汎用モジュールへのポインタを使用してメソッドを呼び出します。 例： pfub^.method この状況では、ポインタは機能ブロックタイプのインスタンスとすべての派生機能ブロックのインスタンスを指すことができます。 インターフェイス変数のメソッドを呼び出します。 例： interface1.method インターフェイスは、このインターフェイスを実装するファンクションブロックのすべてのインスタンスを参照できます。 メソッドは、同じ汎用モジュールの別のメソッドを呼び出します。この場合、メソッドは同じ名前の派生関数ブロックのメソッドを呼び出すこともできます。 メソッドは、汎用モジュールへの参照を使用して呼び出されます。この状況では、参照は機能ブロックタイプのインスタンスとすべての派生機能ブロックのインスタンスを指すことができます。 あなたが指す VAR_IN_OUT -基本機能ブロックタイプから派生FBタイプのインスタンスへの変数。 この状況では、変数は関数ブロックのタイプのインスタンスとすべての派生関数ブロックのインスタンスを指すことができます。 " }, 
{ "title" : "例 ", 
"url" : "_cds_method_call.html#UUID-1140c736-2d89-bf68-7fec-9630a34558d8_id_d5035cf9d32eddc0a8640e0188f0bb_id_e72629c73f4956dbc0a864635fb6e156", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オブジェクト指向プログラミング \/ メソッド呼び出し \/ 例 ", 
"snippet" : "メソッドが過負荷 機能ブロック fub1 と fub2 機能ブロックを展開します fubbase インターフェースを実装します interface1 。方法があります method1 と method2 。 PROGRAM PLC_PRG VAR_INPUT b : BOOL; END_VAR VAR pInst : POINTER TO fubbase; instBase : fubbase; inst1 : fub1; inst2 : fub2; instRef : REFERENCE to fubbase; END_VAR IF b THEN instRef REF= inst1; (*...", 
"body" : "メソッドが過負荷 機能ブロック fub1 と fub2 機能ブロックを展開します fubbase インターフェースを実装します interface1 。方法があります method1 と method2 。 PROGRAM PLC_PRG\nVAR_INPUT\n b : BOOL;\nEND_VAR\n\nVAR pInst : POINTER TO fubbase;\n instBase : fubbase;\n inst1 : fub1;\n inst2 : fub2;\n instRef : REFERENCE to fubbase;\nEND_VAR\n\nIF b THEN\n instRef REF= inst1; (* reference to fub1 *)\n pInst := ADR(instBase);\nELSE\n instRef REF= inst2; (* reference to fub2 *)\n pInst := ADR(inst1);\nEND_IF\npInst^.method1(); (* If b is TRUE, fubbase.method1 will be called, otherwise fub1.method1 is called *)\ninstRef.method1(); (* If b ist TRUE, fub1.method1 will be called, otherwise fub2.method1 is called*) 仮定して fubbase 上記の例の2つの方法 method1 と method2 含む、上書きする fub1 method2 、 だがしかし method1 。の呼び出し method1 次のように行われます。 pInst^.method1(); いつ b TRUE は、呼び出し CODESYS fubbase.method1 それ以外の場合 fub1.method1 。 " }, 
{ "title" : "追加の出口 ", 
"url" : "_cds_method_call.html#UUID-1140c736-2d89-bf68-7fec-9630a34558d8_id_d5035cf9d32eddc0a8640e0188f0bb_id_72802afb093e52c0c0a8640e0111714b", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オブジェクト指向プログラミング \/ メソッド呼び出し \/ 追加の出口 ", 
"snippet" : "IEC 61131-3規格によれば、通常の関数と同様に、メソッドは追加の出力を宣言できます。メソッドを呼び出すときは、追加の出力に変数を割り当てます。 詳細については、「機能」のトピックを参照してください。 呼び出されたときの構文 <function block name>.<method name>(<first input name> := <value> (, <further input assignments>)+ , <first output name> => <first output variable name> (,<further output assignments>)...", 
"body" : "IEC 61131-3規格によれば、通常の関数と同様に、メソッドは追加の出力を宣言できます。メソッドを呼び出すときは、追加の出力に変数を割り当てます。 詳細については、「機能」のトピックを参照してください。 呼び出されたときの構文 <function block name>.<method name>(<first input name> := <value> (, <further input assignments>)+ , <first output name> => <first output variable name> (,<further output assignments>)+ ); 例 宣言 METHOD PUBLIC DoIt : BOOL\nVAR_INPUT\n iInput_1 : DWORD;\n iInput_2 : DWORD;\nEND_VAR\nVAR_OUTPUT\n iOutput_1 : INT;\n sOutput_2 : STRING;\nENDVAR 電話 fbInstance.DoIt(iInput_1 := 1, iInput_2 := 2, iOutput_1 => iLocal_1, sOUtput_2 => sLocal_2); メソッドが呼び出されると、メソッド出力の値がローカルで宣言された出力変数に書き込まれます。 " }, 
{ "title" : "アプリケーションがSTOPステータスの場合でもメソッドを呼び出す ", 
"url" : "_cds_method_call.html#UUID-1140c736-2d89-bf68-7fec-9630a34558d8_id_d5035cf9d32eddc0a8640e0188f0bb_id_7f4f002a7a7c22c7c0a864630de7909a", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オブジェクト指向プログラミング \/ メソッド呼び出し \/ アプリケーションがSTOPステータスの場合でもメソッドを呼び出す ", 
"snippet" : "（ライブラリブロックの）特定の関数ブロックインスタンスがタスクサイクルで常に特定のメソッドを呼び出すことは、デバイスの説明で定義できます。メソッドが次の例の入力パラメーターを受け取る場合、それは機能します CODESYS このメソッドは、アクティブなアプリケーションが現在STOPステータスにあるときにも開始されます。 例 VAR_INPUT pTaskInfo : POINTER TO DWORD; pApplicationInfo: POINTER TO _IMPLICIT_APPLICATION_INFO; END_VAR (*Now the status of the applicati...", 
"body" : "（ライブラリブロックの）特定の関数ブロックインスタンスがタスクサイクルで常に特定のメソッドを呼び出すことは、デバイスの説明で定義できます。メソッドが次の例の入力パラメーターを受け取る場合、それは機能します CODESYS このメソッドは、アクティブなアプリケーションが現在STOPステータスにあるときにも開始されます。 例 VAR_INPUT\n pTaskInfo : POINTER TO DWORD;\n pApplicationInfo: POINTER TO _IMPLICIT_APPLICATION_INFO;\nEND_VAR\n\n(*Now the status of the application can be queried via pApplicationInfo and the instructions can be implemented: *)\n\nIF pApplicationInfo^.udState = 1 THEN <instructions> END_IF; " }, 
{ "title" : "メソッドを再帰的に呼び出す ", 
"url" : "_cds_method_call.html#UUID-1140c736-2d89-bf68-7fec-9630a34558d8_id_d5035cf9d32eddc0a8640e0188f0bb_id_18143ba7942a17e2c0a8646355ab3f2a", 
"breadcrumbs" : "CODESYS Essentials \/ アプリケーションのプログラミング \/ オブジェクト指向プログラミング \/ メソッド呼び出し \/ メソッドを再帰的に呼び出す ", 
"snippet" : "主に再帰を使用して、リンクリストなどの再帰データ型を操作します。一般に、再帰を使用するときは注意することをお勧めします。予想外に深い再帰が発生すると、スタックオーバーフローが発生し、マシンが停止する可能性があります。 その実装内で、メソッドはそれ自体を呼び出すことができます。 を介して直接、 これ ポインタ 基本機能ブロックのローカル機能ブロックインスタンスを間接的に使用する コンパイラの警告は通常、このような再帰呼び出しで発行されます。プラグマを使用したメソッドの場合 {attribute 'estimated-stack-usage' := '<estimated stack size i...", 
"body" : "主に再帰を使用して、リンクリストなどの再帰データ型を操作します。一般に、再帰を使用するときは注意することをお勧めします。予想外に深い再帰が発生すると、スタックオーバーフローが発生し、マシンが停止する可能性があります。 その実装内で、メソッドはそれ自体を呼び出すことができます。 を介して直接、 これ ポインタ 基本機能ブロックのローカル機能ブロックインスタンスを間接的に使用する コンパイラの警告は通常、このような再帰呼び出しで発行されます。プラグマを使用したメソッドの場合 {attribute 'estimated-stack-usage' := '<estimated stack size in bytes>'} が提供されている場合、コンパイラの警告は抑制されます。章で 属性 '推定スタック使用量 実装例を参照してください。 " }, 
{ "title" : "コントローラネットワークの操作 ", 
"url" : "_cds_struct_dataexchange.html", 
"breadcrumbs" : "CODESYS Essentials \/ コントローラネットワークの操作 ", 
"snippet" : "以下の機能で、 CODESYS コントローラ間の通信（PLC）とPLCの下への安全コントローラの挿入をサポートします。 シンボル構成 ： CODESYS アプリケーション内の変数に対する特定のアクセス権を持つシンボルを作成します。これらの記号を使用すると、外部から、たとえばOPCサーバーから変数にアクセスできます。 データソースマネージャー ：接続設定とリモートデバイス（データソース）へのデータ送信を管理します 送信されたデータは、ビジュアライゼーションまたはローカルアプリケーションでアクセスされるデータソース変数にマッピングされます。この例は、リモートデバイスを制御し、デバイスの状態をHMI...", 
"body" : "以下の機能で、 CODESYS コントローラ間の通信（PLC）とPLCの下への安全コントローラの挿入をサポートします。 シンボル構成 ： CODESYS アプリケーション内の変数に対する特定のアクセス権を持つシンボルを作成します。これらの記号を使用すると、外部から、たとえばOPCサーバーから変数にアクセスできます。 データソースマネージャー ：接続設定とリモートデバイス（データソース）へのデータ送信を管理します 送信されたデータは、ビジュアライゼーションまたはローカルアプリケーションでアクセスされるデータソース変数にマッピングされます。この例は、リモートデバイスを制御し、デバイスの状態をHMIアプリケーションとして表示するコントロールパネルです。 ネットワーク変数 ：ネットワーク変数は、ネットワーク内のさまざまなコントローラーが値にアクセスできる変数です。変数は、送信機デバイスと受信機デバイスの両方で、厳密で同一のリストで定義する必要があります。これらのリストはアプリケーションに割り当てられていますが、さまざまなプロジェクトに配置できます。 A 安全コントローラー デバイスツリーのPLCの下に挿入できます。安全コントローラからフィールドデバイス、コントローラネットワーク、および開発システムへの通信リンクは、このコントローラを介してルーティングされます。詳細については、以下を参照してください。 従属安全コントローラThe DataServer オブジェクトは廃止されました。 とのデータリンク CODESYS DataServerは、SP10以降のデータソースとのデータリンクにすでに取って代わられています。機能は完全に削除されました CODESYS 3.5SP17以降。 既存のプロジェクトを DataServer オブジェクトの場合、次の操作を実行できます。で既存のプロジェクトを開く CODESYS V3.5 SP16、データサーバーオブジェクトを選択し、をクリックします データサーバーをデータソースマネージャーに変換する コンテキストメニューで。データリンクをデータソース接続に変換した後、現在のプロジェクトを開くことができます CODESYS バージョン。 詳細については、以下を参照してください。 アドレス構造 と アドレス指定とルーティング" }, 
{ "title" : "ネットワークとアドレス指定 ", 
"url" : "_cds_f_networktopology_addressing.html", 
"breadcrumbs" : "CODESYS Essentials \/ コントローラネットワークの操作 \/ ネットワークとアドレス指定 ", 
"snippet" : "制御ネットワークを階層的に構築することで、広範な自己構成が可能になります。 の CODESYS 、ネットワークトポロジは一意のアドレスにマップされ、ルーティングアルゴリズムは構造化されたアドレスによって単純に保たれます。システムの起動中に、直接および相対アドレス指定と自動アドレス決定があります。...", 
"body" : "制御ネットワークを階層的に構築することで、広範な自己構成が可能になります。 の CODESYS 、ネットワークトポロジは一意のアドレスにマップされ、ルーティングアルゴリズムは構造化されたアドレスによって単純に保たれます。システムの起動中に、直接および相対アドレス指定と自動アドレス決定があります。 " }, 
{ "title" : "ネットワークトポロジー ", 
"url" : "_cds_networktopology.html", 
"breadcrumbs" : "CODESYS Essentials \/ コントローラネットワークの操作 \/ ネットワークとアドレス指定 \/ ネットワークトポロジー ", 
"snippet" : "制御ネットワークのトポロジーに関する情報と推奨事項 次のことが可能なようにネットワークシステムを設定することをお勧めします。 広範な自己構成（アドレス割り当て） すべての通信媒体に対する透過的なサポート 異なるネットワーク間のデータパッケージの転送 ルーティングメカニズムは、メモリ容量が少ない場合でも、各ネットワークノードがデータパッケージを再ルーティングできるように単純にする必要があります。したがって、実行時に大規模なルーティングテーブル、複雑な計算、またはクエリを回避します。 制御ネットワークを階層的に構築します。各ノードは、親ノードと任意の数の子ノードを所有できます。親のないノードは「ト...", 
"body" : "制御ネットワークのトポロジーに関する情報と推奨事項 次のことが可能なようにネットワークシステムを設定することをお勧めします。 広範な自己構成（アドレス割り当て） すべての通信媒体に対する透過的なサポート 異なるネットワーク間のデータパッケージの転送 ルーティングメカニズムは、メモリ容量が少ない場合でも、各ネットワークノードがデータパッケージを再ルーティングできるように単純にする必要があります。したがって、実行時に大規模なルーティングテーブル、複雑な計算、またはクエリを回避します。 制御ネットワークを階層的に構築します。各ノードは、親ノードと任意の数の子ノードを所有できます。親のないノードは「トップレベル」ノードです。サイクルは許可されていません。つまり、各制御ネットワークはツリーの構造になっています。 親子関係は、特定のネットワーク領域の指定から生じます。ネットワークエリアは、たとえば、ローカルイーサネットまたはシリアルポイントツーポイント接続にすることができます。メインネットワーク（メインネット）とサブネットワーク（サブネット）を区別します。各ノードは最大で1つのメインネットワークに属し、その親ノードが存在する場合はそのネットワークにも属します。ノードごとに、任意の数のサブネットを構成できます。そのため、ノードはそれぞれの場合に親として機能します。 ネットワークエリアには、親ノードが1つしかない場合があります。したがって、ネットワークエリアが複数のノードのサブネットと同時に定義される構成は無効です。 " }, 
{ "title" : "アドレス指定とルーティング ", 
"url" : "_cds_addressing_routing.html", 
"breadcrumbs" : "CODESYS Essentials \/ コントローラネットワークの操作 \/ ネットワークとアドレス指定 \/ アドレス指定とルーティング ", 
"snippet" : "アドレス指定とは、制御ネットワークのトポロジが一意のアドレスにマップされることを意味します。 ノードアドレスは階層的に構成されています。 ネットワーク接続ごとに、関連付けられたブロックドライバーがローカルアドレスを決定します。これにより、ローカルネットワーク内のノードが一意に識別されます。完全なノードアドレスは次のように形成されます。ローカルアドレスは、親によって割り当てられたローカルネットワークのサブネットインデックスの前に付加されます。次に、サブネットインデックスは、親のノードアドレスの前に配置されます。 これにより、サブネットインデックスの長さ（ビット単位）がデバイスによって決定されます...", 
"body" : "アドレス指定とは、制御ネットワークのトポロジが一意のアドレスにマップされることを意味します。 ノードアドレスは階層的に構成されています。 ネットワーク接続ごとに、関連付けられたブロックドライバーがローカルアドレスを決定します。これにより、ローカルネットワーク内のノードが一意に識別されます。完全なノードアドレスは次のように形成されます。ローカルアドレスは、親によって割り当てられたローカルネットワークのサブネットインデックスの前に付加されます。次に、サブネットインデックスは、親のノードアドレスの前に配置されます。 これにより、サブネットインデックスの長さ（ビット単位）がデバイスによって決定されます。逆に、ローカルアドレスの長さは、ネットワークのタイプによって決まります。 メインネットワークのないノードは、アドレス0のトップレベルノードです。親を含まないメインネットワークのあるノードも、同様にトップレベルノードです。メインネットワークのローカルアドレスが与えられます。 ここで制御ネットワークの例を参照してください。 この例では、ノードのアドレスは16進表記で表されています。最初の4桁は、メインネットワーク内のそれぞれの親のアドレスを表します。たとえば、 0x007A=122 にとって PLC1 。次のバイト（青色のフォント）はサブネットインデックス用に予約されており、その後にローカルアドレスが続きます（例： C=12 ノードIDの場合 12 ）。アドレスの構造化により、無駄のないルーティングアルゴリズムが可能になります。したがって、たとえばルーティングテーブルは不要です。情報はローカルでのみ照会されます。つまり、独自のアドレスと親ノードのアドレスを介して照会されます。これに基づいて、ノードはデータパッケージを正しく処理できます。 宛先アドレスが現在のノードのアドレスに対応している場合、これは受信者であることを意味します。 宛先アドレスが現在のノードのアドレスで始まる場合、データパッケージはノードの子または子孫を直接対象としているため、転送する必要があります。 他のすべての場合、レシーバーは現在のノードの子孫ではなく、データパッケージはそれ自体の親に転送される必要があります。 相対アドレス指定 は特殊なケースです。相対アドレスには受信者のノード番号は含まれていませんが、送信者から受信者へのパスを直接記述しています。原則は、ファイルシステムの相対パスに似ています。アドレスは、パッケージを上向きに転送する必要のあるステップ数で構成されます。これらは、対応する親へのステップであり、後続のパスから宛先ノードまでのステップです。 相対アドレス指定の利点は、サブツリー全体がネットワーク全体の別の場所に移動された場合でも、同じサブツリー内の2つのノードが通信を継続できることです。このシフトのために絶対ノードアドレス指定を変更する必要がありますが、相対アドレス指定は引き続き有効です。 アドレス決定 ノードが自身のアドレスを知るには、その親ノードのアドレスを知っているか、それが最上位ノードであることを知っている必要があります。この目的のために、ノードは起動中にアドレス決定のためにすべてのネットワークデバイスにメッセージをディスパッチします。このメッセージへの応答を受信しない限り、ノードはそれ自体を最上位ノードと見なしますが、可能な親の検索を続行します。親ノードは、そのアドレスをアナウンスすることで応答します。したがって、ノードは独立してそのアドレスを完成させ、サブネットにアナウンスします。 アドレスの決定は、起動中またはプログラミングに使用されるPCの要求に応じて実行できます。 " }, 
{ "title" : "アドレス構造 ", 
"url" : "_cds_address_structures.html", 
"breadcrumbs" : "CODESYS Essentials \/ コントローラネットワークの操作 \/ ネットワークとアドレス指定 \/ アドレス構造 ", 
"snippet" : "ブロードキャストアドレス ブロードキャストには、グローバルとローカルの2種類があります。グローバルブロードキャストは、ネットワーク内のすべてのノードに送信されます。長さが0の空のノードアドレスは、この目的のために予約されています。 ローカルブロードキャストは、ネットワークエリア内のすべてのデバイスに送信されます。この目的のために、ネットワークアドレスのすべてのビットが1に設定されます。これは、相対アドレスと絶対アドレスの両方で許可されます。 ブロックドライバは、両方の種類のブロードキャストアドレスを処理できる必要があります。つまり、空のネットワークアドレスと、ビットがすべて1に設定されているネ...", 
"body" : "ブロードキャストアドレス ブロードキャストには、グローバルとローカルの2種類があります。グローバルブロードキャストは、ネットワーク内のすべてのノードに送信されます。長さが0の空のノードアドレスは、この目的のために予約されています。 ローカルブロードキャストは、ネットワークエリア内のすべてのデバイスに送信されます。この目的のために、ネットワークアドレスのすべてのビットが1に設定されます。これは、相対アドレスと絶対アドレスの両方で許可されます。 ブロックドライバは、両方の種類のブロードキャストアドレスを処理できる必要があります。つまり、空のネットワークアドレスと、ビットがすべて1に設定されているネットワークアドレスを解釈して、関連するすべての参加者に送信する必要があります。 " }, 
{ "title" : "ネットワークアドレス ", 
"url" : "_cds_address_structures.html#UUID-1f5ea387-c992-0bd7-9dee-0f8dc5aae773_id_ea3da72c61131dc0a8640e000e39f6_id_da141d38484f787cc0a8640e00d982a5", 
"breadcrumbs" : "CODESYS Essentials \/ コントローラネットワークの操作 \/ ネットワークとアドレス指定 \/ アドレス構造 \/ ネットワークアドレス ", 
"snippet" : "ネットワークアドレスは、ネットワークタイプ（IPなど）のアドレスを制御ネットワーク内の論理アドレスにマッピングすることを表します。このマッピングは、対応するブロックドライバーによって実行されます。 IPアドレスの最初の3バイトは、「クラスC」IPアドレスを持つイーサネットネットワーク内のすべてのネットワークデバイスで同一です。したがって、IPアドレスの最後の8ビットは、ブロックドライバー上の2つのアドレス間の明確なマッピングを可能にするため、ネットワークアドレスとして十分です。 ノードには、ネットワーク接続ごとに異なるネットワークアドレスがあります。各アドレスはローカルで一意である必要があるだ...", 
"body" : "ネットワークアドレスは、ネットワークタイプ（IPなど）のアドレスを制御ネットワーク内の論理アドレスにマッピングすることを表します。このマッピングは、対応するブロックドライバーによって実行されます。 IPアドレスの最初の3バイトは、「クラスC」IPアドレスを持つイーサネットネットワーク内のすべてのネットワークデバイスで同一です。したがって、IPアドレスの最後の8ビットは、ブロックドライバー上の2つのアドレス間の明確なマッピングを可能にするため、ネットワークアドレスとして十分です。 ノードには、ネットワーク接続ごとに異なるネットワークアドレスがあります。各アドレスはローカルで一意である必要があるだけなので、異なるネットワーク接続が同じネットワークアドレスを持つことができます。 用語：メインネットワークのネットワークアドレスは通常、ネットワーク接続の指定がないノードのネットワークアドレスとして指定されます。 ネットワークアドレスの長さはビット単位で指定され、必要に応じてブロックドライバで選択できます。ネットワークエリア内のすべてのノードに同じ長さを使用する必要があります。ネットワークアドレスは、次のコーディングに従ってバイトの配列で表されます。 ネットワークアドレスの長さ：nビット 必要なバイト数：b =（n + 7）DIV 8 ネットワークアドレスには、最初のバイトの最下位ランクの（n MOD 8）ビットと他のすべての（n DIV 8）ビットが使用されます。 ネットワークアドレスのコーディング例 長さ：11ビット 住所：111 1000 1100 " }, 
{ "title" : "ノードアドレス ", 
"url" : "_cds_address_structures.html#UUID-1f5ea387-c992-0bd7-9dee-0f8dc5aae773_id_ea3da72c61131dc0a8640e000e39f6_id_b9feccb2484f787fc0a8640e00b13107", 
"breadcrumbs" : "CODESYS Essentials \/ コントローラネットワークの操作 \/ ネットワークとアドレス指定 \/ アドレス構造 \/ ノードアドレス ", 
"snippet" : "ノードアドレスは、制御ネットワーク内のノードの絶対アドレスを示しているため、「ネットワークツリー」全体で一意です。アドレスは最大15個のアドレスコンポーネントで構成され、各コンポーネントは2バイトを占有します。ノードがネットワーク階層内の下位にあるほど、そのアドレスは長くなります。 完全なノードアドレスは、先行するすべてのノードの部分アドレスとノード自体の部分アドレスで構成されます。各部分アドレスは、1つ以上のアドレスコンポーネントで構成されます。したがって、長さは常に2バイトの倍数になります。ノードの部分アドレスは、メインネットワーク内のノードのネットワークアドレスと、親ノードの場合はメイン...", 
"body" : "ノードアドレスは、制御ネットワーク内のノードの絶対アドレスを示しているため、「ネットワークツリー」全体で一意です。アドレスは最大15個のアドレスコンポーネントで構成され、各コンポーネントは2バイトを占有します。ノードがネットワーク階層内の下位にあるほど、そのアドレスは長くなります。 完全なノードアドレスは、先行するすべてのノードの部分アドレスとノード自体の部分アドレスで構成されます。各部分アドレスは、1つ以上のアドレスコンポーネントで構成されます。したがって、長さは常に2バイトの倍数になります。ノードの部分アドレスは、メインネットワーク内のノードのネットワークアドレスと、親ノードの場合はメインネットワークのサブネットインデックスから形成されます。サブインデックスに必要なビットは、親ノードのルーターによって決定されます。部分アドレスの長さが2バイトの倍数になるように、サブネットインデックスとネットワークアドレスの間にフィラービットを挿入できます。 特殊なケース： ネットワークのないノード：これは、メインネットワークにサブネットインデックスもネットワークアドレスもないことを意味します。この場合、アドレスは0x0000に設定されます。 親のないメインネットワーク内のノード：この場合、長さが0のサブネットインデックスが想定されます。部分アドレスは、必要に応じてフィラービットによって拡張されたネットワークアドレスに対応します。 ノードアドレスの例 ノードアドレスは常に16進数で指定されます。個々のアドレスコンポーネント（それぞれ2バイト）はコロン「：」で区切られます。これは16ビット値ではなくバイトの配列を表すため、コンポーネントはIntel形式で表示されません。手動でアドレスを入力する場合、アドレスコンポーネントの欠落している部分は、先行ゼロで補足されます。 274 \"=\" = \" 0274 \"。読みやすさを向上させるために、ディスプレイには常に先行ゼロを含める必要があります。 絶対アドレスと相対アドレス 2つのノード間の通信は、相対アドレスまたは絶対アドレスに基づくことができます。絶対アドレスはノードアドレスと同じです。相対アドレスは、送信者から受信者へのパスを指定します。これらは、アドレスオフセットとレシーバーへの下降パスで構成されます。 （負の）アドレスオフセットは、パッケージが共通の親ノードによって受け渡される前に、ツリー内でパッケージが上向きに渡される必要があるアドレスコンポーネントの数を表します。ノードは複数のコンポーネントで構成される部分アドレスを使用できるため、渡される親コンポーネントの数は常にアドレスオフセットに等しくなります。これは、親ノード間の境界が明確ではなくなったことを意味します。そのため、通信パートナーのアドレスの共通の開始が親アドレスとして使用されます。各アドレスコンポーネントは、現在の親ノードとは関係なく、上向きのステップとしてカウントされます。この仮定に起因する各エラーは、対応する親ノードで検出でき、それに応じて処理する必要があります。 共通の親ノードに到達した後、アドレスコンポーネントの配列としての相対パスは、通常どおり下向きにたどられます。正式：受信者のノードアドレスは、送信者のノードアドレスから最後のアドレスオフセットコンポーネントを削除し、残りのアドレスに相対パスを追加することによって形成されます。 ノードアドレスの形成例 次の例では、各アドレスコンポーネントは文字で表されています。いずれの場合も、ドットはノードを互いに分離します。ノードは複数のアドレスコンポーネントを運ぶことができるため、例にはいくつかの文字で表されるものがあります。 ノードA： a.bc.d.ef.g ノードB： a.bc.i.j.kl.m 最も一般的でない親のアドレス： a.bc AからBへの相対アドレス： -4\/i.j.kl.m 数字の4は、4つのコンポーネントの結果です– d 、 e 、 f と g –データパッケージを上向きに転送する必要があります。 ルーティングの正しい動作を保証するために、相対アドレスは、中間ノードを通過するたびに適合させる必要があります。アドレスオフセットを調整するだけで十分です。これは常に親ノードによって行われます。ノードがそのサブネットの1つからデータパッケージを受信した場合、アドレスオフセットはこのサブネットのアドレスコンポーネントの長さだけ増加します。 新しいアドレスオフセットが0未満の場合、データパッケージをさらに上に渡す必要があります。 アドレスオフセットが> = 0の場合、データパッケージは、アドレスオフセットから開始して、ローカルアドレスが相対パスに対応する子ノードに渡される必要があります。ただし、最初に、子ノードが正しいアドレスを認識できるように、アドレスオフセットを子ノードのローカルアドレスの長さだけ増やす必要があります。 共通の親ノードの決定中に上記のエラーが発生した場合、特別な状況が発生します。この場合、実際の親ノードのアドレスオフセットは負ですが、この値は、パッケージが発信されたサブネットの部分アドレスの長さよりも大きくなります。この場合、次のノードが正しい相対アドレスを認識できるように、関連するノードは次のことを行う必要があります。エラーを検出し、先行ノードのアドレスと長さの差に基づいて子ノードのローカルアドレスを計算します。それに応じてアドレスオフセットを調整します。この場合も、アドレスコンポーネント自体は変更されません。オフセットのみが変更されます。 " }, 
{ "title" : "ネットワーク変数 ", 
"url" : "_cds_f_networkvariables.html", 
"breadcrumbs" : "CODESYS Essentials \/ コントローラネットワークの操作 \/ ネットワーク変数 ", 
"snippet" : "ネットワーク変数の値は、ネットワーク内の異なるPLC間で交換できます。変数は、送信機デバイスと受信機デバイスの両方で厳密な同一のリストで定義する必要があります。この場合、デバイスの1つのアプリケーションのみがネットワーク変数を定義できます。リストは1つ以上のプロジェクトに含めることができます。 送信側のネットワーク変数リストは、特定のログおよび転送パラメータがオブジェクトプロパティで定義されているグローバル変数リストです。これらのプロパティを追加することで、通常の「ネットワーク変数リスト（送信者）」を作成します GVL 。を挿入することもできます ネットワーク変数リスト（送信者） このオブジェ...", 
"body" : "ネットワーク変数の値は、ネットワーク内の異なるPLC間で交換できます。変数は、送信機デバイスと受信機デバイスの両方で厳密な同一のリストで定義する必要があります。この場合、デバイスの1つのアプリケーションのみがネットワーク変数を定義できます。リストは1つ以上のプロジェクトに含めることができます。 送信側のネットワーク変数リストは、特定のログおよび転送パラメータがオブジェクトプロパティで定義されているグローバル変数リストです。これらのプロパティを追加することで、通常の「ネットワーク変数リスト（送信者）」を作成します GVL 。を挿入することもできます ネットワーク変数リスト（送信者） このオブジェクトにすでにこれらのパラメータが設定されている場合は、オブジェクトをデバイスツリーに直接挿入します。 受信機のネットワーク変数リストは ネットワーク変数リスト（受信者） タイプ。作成するときは、サーバーのそれぞれのネットワーク変数リストを選択します。別の方法として、送信者リストから生成されたエクスポートファイルからこの変数リストを読み取ることができます。別のプロジェクトで送信者リストを定義するには、とにかくエクスポートファイルが必要です。 ネットワーク変数は、送信者から受信者への一方向にのみブロードキャストとして送信されます。ただし、デバイスに送信者リストと受信者リストの両方を含めることもできます。 のために NetVarUdp ライブラリバージョン3.5.7.0以降では、確認済み転送が選択されていない場合、受信者チャネルは割り当てられなくなりました。その結果、1つのハードウェアデバイス上の2つのコントローラー間でネットワーク変数の交換も可能です。 交換デバイスが送信者と受信者である必要がある場合、異常な動作を防ぐために、変数リスト識別子は一意である必要があります。変数リスト識別子は、 プロパティ のダイアログ GVL 物体。 次の場合、ネットワーク変数を介したデータ交換はできません。 デバイス（ターゲットシステム）がサポートしていない場合 ファイアウォールが通信をブロックします。 別のクライアントまたはアプリケーションがネットワーク変数リストのプロパティで設定されているUDPポートを使用している場合 送信側デバイスと受信側デバイスごとに複数のアプリケーションがネットワーク変数リストを使用する場合 リテラルまたは定数で定義された制限を持つ配列のみがレシーバーアプリケーションに送信されます。この目的のために定数式は許可されていません。 例： \" arrVar : ARRAY[0..g_iArraySize-1] OF INT ; 「送信されませんが、」 arrVar : ARRAY[0..10] OF INT ; \"が送信されます。 ネットワーク変数の最大サイズは255バイトです。ネットワーク変数の可能な数は無制限です。 GVLのサイズがネットワークテレグラムの最大長を超える場合、データは複数のテレグラムに分割されます。構成によっては、これによりデータの不整合が発生する可能性があります。 送信者から受信者への UDP 経由のデータ送信中に、各サイクルで次の位置またはイベントでデータが失われる可能性があります。 送信者（ネットワーク ドライバー、スタック） ルーター スイッチ ネットワーク衝突 受信機（ネットワーク ドライバー、スタック） これは、受信側がサイクル内で受信したデータが最新ではなく、古い可能性があることを意味します。 PLCが異なるバージョンの開発システム（V2.3、 V3 ）。ただし、この場合、送信者プロジェクトと受信者プロジェクトで変数リストを正確に照合するためにエクスポート\/インポートメカニズムを使用することはできません。その理由は、可変エクスポートファイル（ *.exp ）V2.3から生成されたものには、受信NVLを作成するために必要な量の情報が含まれていません。 V3 。以前に送信者からエクスポートしたGVLファイルとしてのそれぞれのネットワークパラメータ設定はありません。このファイルを取得するには、でV2.3NVLを再作成する必要があります。 V3 初め。次に、エクスポートファイルを生成し、で受信NVLを作成できます。 V3 これに基づいて。 PLC間のデータ交換の代替手段は、データソースの使用です。ネットワーク変数を交換するためのブロードキャスト方式とは対照的に、定義されたポイントツーポイント接続は、1つのアプリケーションとリモートデータソースの間に作成されます。 詳細については、以下を参照してください。 ネットワーク変数" }, 
{ "title" : "ネットワーク変数交換の構成 ", 
"url" : "_cds_configuring_network_variables_exchange.html", 
"breadcrumbs" : "CODESYS Essentials \/ コントローラネットワークの操作 \/ ネットワーク変数 \/ ネットワーク変数交換の構成 ", 
"snippet" : "送信側デバイスと受信側デバイスの間でネットワーク変数を交換するには、次の手順が必要です。...", 
"body" : "送信側デバイスと受信側デバイスの間でネットワーク変数を交換するには、次の手順が必要です。 " }, 
{ "title" : "1.送信側デバイスでネットワーク変数リストを作成し、エクスポートファイルを生成します ", 
"url" : "_cds_configuring_network_variables_exchange.html#UUID-4b2d41ce-8a83-dfc2-9447-e0ddcf072e25_id_e2da966febc27c7c0a8640e00b3ea15_id_31c0f718b4d8cb98c0a8640e01ec7ade", 
"breadcrumbs" : "CODESYS Essentials \/ コントローラネットワークの操作 \/ ネットワーク変数 \/ ネットワーク変数交換の構成 \/ 1.送信側デバイスでネットワーク変数リストを作成し、エクスポートファイルを生成します ", 
"snippet" : "要件：アプリケーションは、送信側デバイスとして使用されているPLCのデバイスツリーに挿入されます。 アプリケーションを選択し、 ネットワーク変数リスト（送信者） 物体。の中に ネットワーク変数リストの追加（送信者） ダイアログで、次の設定を構成します。ネットワークタイプ： UDP （例： 「」 NVL_Sender \"）。 NVLオブジェクトをダブルクリックしてそれぞれのエディターを開き、ネットワーク変数の宣言を入力します。例： VAR_GLOBAL iglobvar:INT; bglobvar:BOOL; strglobvar:STRING; END_VAR デバイスツリーでNVLオブジェク...", 
"body" : "要件：アプリケーションは、送信側デバイスとして使用されているPLCのデバイスツリーに挿入されます。 アプリケーションを選択し、 ネットワーク変数リスト（送信者） 物体。の中に ネットワーク変数リストの追加（送信者） ダイアログで、次の設定を構成します。ネットワークタイプ： UDP （例： 「」 NVL_Sender \"）。 NVLオブジェクトをダブルクリックしてそれぞれのエディターを開き、ネットワーク変数の宣言を入力します。例： VAR_GLOBAL iglobvar:INT; bglobvar:BOOL; strglobvar:STRING; END_VAR デバイスツリーでNVLオブジェクトを右クリックして、 プロパティ 。の中に プロパティ ダイアログを開き、 ネットワーク変数 タブ。これにより、次の設定が表示されます。ネットワークタイプ：UDP;リスト識別子：1;変数をパックします。周期的送信：50ミリ秒ごと。 注：ネットワーク変数のプロパティを構成することにより、既存のGVLをネットワーク変数リストに変換することもできます。 の中に プロパティ のダイアログ NVL_Sender 、 クリック ファイルへのリンク タブ。ファイル名を定義する <export>.gvl GVLのエクスポートファイルのファイルシステム内の場所。を選択 コンパイルする前にエクスポートする オプション。 クリック ビルド→ビルド アプリケーションをコンパイルします。 これで、ネットワーク変数リストのエクスポートファイルが定義済みのフォルダーに配置されました。 " }, 
{ "title" : "2.受信側デバイスに関連するネットワーク変数リストを作成する ", 
"url" : "_cds_configuring_network_variables_exchange.html#UUID-4b2d41ce-8a83-dfc2-9447-e0ddcf072e25_id_e2da966febc27c7c0a8640e00b3ea15_id_47ffe3b7829f11e3b1f793b077791a22", 
"breadcrumbs" : "CODESYS Essentials \/ コントローラネットワークの操作 \/ ネットワーク変数 \/ ネットワーク変数交換の構成 \/ 2.受信側デバイスに関連するネットワーク変数リストを作成する ", 
"snippet" : "要件：送信側デバイスと受信側デバイスがデバイスツリーに存在します。タスク構成のアプリケーションがデバイスの下に挿入されます。 NVLまたはGVLは、送信されるネットワーク変数リストとして送信側デバイスの下に作成されます。 デバイスツリーで受信機のアプリケーションを選択し、をクリックします オブジェクトの追加→ネットワーク変数リスト（受信者） 。 The ネットワーク変数リストの追加（受信者） ダイアログが開きます。 ダイアログで、送信者デバイスの以前に作成されたNVLを選択し、名前を指定します（例： 「NVL_Receiver」）。 CODESYS この受信者リストに、送信者リストからの変数宣...", 
"body" : "要件：送信側デバイスと受信側デバイスがデバイスツリーに存在します。タスク構成のアプリケーションがデバイスの下に挿入されます。 NVLまたはGVLは、送信されるネットワーク変数リストとして送信側デバイスの下に作成されます。 デバイスツリーで受信機のアプリケーションを選択し、をクリックします オブジェクトの追加→ネットワーク変数リスト（受信者） 。 The ネットワーク変数リストの追加（受信者） ダイアログが開きます。 ダイアログで、送信者デバイスの以前に作成されたNVLを選択し、名前を指定します（例： 「NVL_Receiver」）。 CODESYS この受信者リストに、送信者リストからの変数宣言が自動的に入力されます。 注：別の方法として、 ファイルからインポート オプションを選択し、送信者リストから以前に生成されたエクスポートファイルをロードします。 " }, 
{ "title" : "3.ネットワーク変数交換のテスト ", 
"url" : "_cds_configuring_network_variables_exchange.html#UUID-4b2d41ce-8a83-dfc2-9447-e0ddcf072e25_id_e2da966febc27c7c0a8640e00b3ea15_id_2f77f1a6b4d8cb98c0a8640e01956f55", 
"breadcrumbs" : "CODESYS Essentials \/ コントローラネットワークの操作 \/ ネットワーク変数 \/ ネットワーク変数交換の構成 \/ 3.ネットワーク変数交換のテスト ", 
"snippet" : "要件：ネットワーク変数リスト（送信者）が送信側デバイスに存在し、ネットワーク変数リスト（受信側）が受信側デバイスに存在し、両方のリストに同一の変数宣言があります。 送信側デバイスのアプリケーションの下に、ネットワーク変数をインクリメントするプログラムを作成します。 例： iglobvar:=iglobvar+1; このプログラムが呼び出すようにアプリケーションタスクを設定します。 受信側デバイスのアプリケーションの下に、このネットワーク変数の値をローカル変数に書き込むプログラムを作成します。 例： ilocalvar:=iglobvar; このプログラムが呼び出すようにアプリケーションタスクを...", 
"body" : "要件：ネットワーク変数リスト（送信者）が送信側デバイスに存在し、ネットワーク変数リスト（受信側）が受信側デバイスに存在し、両方のリストに同一の変数宣言があります。 送信側デバイスのアプリケーションの下に、ネットワーク変数をインクリメントするプログラムを作成します。 例： iglobvar:=iglobvar+1; このプログラムが呼び出すようにアプリケーションタスクを設定します。 受信側デバイスのアプリケーションの下に、このネットワーク変数の値をローカル変数に書き込むプログラムを作成します。 例： ilocalvar:=iglobvar; このプログラムが呼び出すようにアプリケーションタスクを設定します。 両方のアプリケーションをコントローラーにダウンロードして起動します。 （アプリケーションをアクティブに設定し、ログイン、ダウンロード、および開始します） 両方のプログラムの編集者のオンラインビューで、 iglobvar 受信者と送信者で一致します。 " }, 
{ "title" : "V2.3とV3のPLC間のネットワーク可変通信の構成 ", 
"url" : "_cds_configuring_network_variables_exchange.html#UUID-4b2d41ce-8a83-dfc2-9447-e0ddcf072e25_id_e2da966febc27c7c0a8640e00b3ea15_id_ccea919a24784530c0a8640e014650de", 
"breadcrumbs" : "CODESYS Essentials \/ コントローラネットワークの操作 \/ ネットワーク変数 \/ ネットワーク変数交換の構成 \/ V2.3とV3のPLC間のネットワーク可変通信の構成 ", 
"snippet" : "要件：グローバル変数リストがV2.3プロジェクトに存在し、ネットワーク変数を読み込みます。 V3 事業。の中に V3 プロジェクト、デバイスツリーのPLCの下に、変数を使用するプログラムを備えたアプリケーションがあります。 を開きます プロパティ V2.3プロジェクト（送信者）のGVLのダイアログ。 アプリケーションとタスクを含むダミーとして、別のPLCをプロジェクトに挿入します。次に、その下に次のようにV2.3GVLを作成します。 を挿入します ネットワーク変数リスト（送信者） ダミーアプリケーションの下にある「dummy23」という名前のオブジェクト。 右クリック ダミー23 開くには プ...", 
"body" : "要件：グローバル変数リストがV2.3プロジェクトに存在し、ネットワーク変数を読み込みます。 V3 事業。の中に V3 プロジェクト、デバイスツリーのPLCの下に、変数を使用するプログラムを備えたアプリケーションがあります。 を開きます プロパティ V2.3プロジェクト（送信者）のGVLのダイアログ。 アプリケーションとタスクを含むダミーとして、別のPLCをプロジェクトに挿入します。次に、その下に次のようにV2.3GVLを作成します。 を挿入します ネットワーク変数リスト（送信者） ダミーアプリケーションの下にある「dummy23」という名前のオブジェクト。 右クリック ダミー23 開くには プロパティ ダイアログ。クリック ネットワークプロパティ タブ。 V2.3プロジェクトのGVLと同じネットワークプロパティを入力します。 塗りつぶし ダミー23 V2.3GVLと同じ変数宣言を使用します。 にエクスポートファイル「dummy23.gvl」の場所を定義します ファイルへのリンク のタブ プロパティ にとって ダミー23 。 ダミーコントローラのアプリケーションをアクティブに設定し、をクリックします ビルド→コードの生成 （（ F11 ）。 アプリケーションが正常にコンパイルされると、 CODESYS 自動的に作成します dummy23.gvl エクスポートファイル。 物理PLCのアプリケーションをアクティブに設定し、右クリックして開きます オブジェクトの追加 ダイアログ。 選択する ネットワーク変数リスト（受信者） 名前を指定します（例： \"NVL_from_23\"）。 を選択 ファイルからインポート オプションを選択し、 dummy23.gvl 、以前に生成されました。 チェック NVL_from_23 、作成されたばかりです。 V2.3プロジェクトの送信側GVLと同じ変数宣言を取得する必要があります。 詳細については、以下を参照してください。 ネットワーク変数リスト（送信者） と ネットワーク変数リスト（受信者）" }, 
{ "title" : "従属安全コントローラ ", 
"url" : "_cds_safety_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ コントローラネットワークの操作 \/ 従属安全コントローラ ", 
"snippet" : "安全コントローラが標準コントローラより下にある場合、開発システムとの通信およびデータ交換は標準コントローラを介して実行されます。安全コントローラの通信リンクは、標準コントローラに影響を与えるコマンドの実行を中断する可能性があります。これらのコマンドごとに、これに関する通知があります。 中断の可能性 一時的な中断：コマンドの実行中（例：ダウンロード）、安全コントローラーとの接続が最初に中断され、その後自動的に再び利用可能になります。中断時間が長すぎると、出力デバイスおよび接続されたネットワーク可変受信機の安全コントローラで安全指向の反応が発生する可能性があります。次に、安全コントローラで、安全指...", 
"body" : "安全コントローラが標準コントローラより下にある場合、開発システムとの通信およびデータ交換は標準コントローラを介して実行されます。安全コントローラの通信リンクは、標準コントローラに影響を与えるコマンドの実行を中断する可能性があります。これらのコマンドごとに、これに関する通知があります。 中断の可能性 一時的な中断：コマンドの実行中（例：ダウンロード）、安全コントローラーとの接続が最初に中断され、その後自動的に再び利用可能になります。中断時間が長すぎると、出力デバイスおよび接続されたネットワーク可変受信機の安全コントローラで安全指向の反応が発生する可能性があります。次に、安全コントローラで、安全指向の反応を終了するために、対応する通信エラーを確認する必要があります（自動的に行われない場合）。これは、フィールドデバイスへの接続、および他の送信機安全コントローラへのネットワーク可変受信機接続に影響します。ネットワーク変数の送信者と接続された安全コントローラの場合、通信エラーは他の安全コントローラで確認する必要があります。 永続的な中断：コマンド（例：削除）の実行により中断が発生し、別のアクション（例：ダウンロード）によって再び終了します。中断の結果として、安全指向の反応が出力デバイスおよび接続されたネットワーク可変受信機安全コントローラーで発生する可能性があります。中断を終了した後、安全指向の反応を終了するために、対応する通信エラーを安全コントローラーで確認する必要があります（自動的に行われない場合）。 詳細については、以下を参照してください。 コントローラネットワークの操作" }, 
{ "title" : "PLCへのアプリケーションのダウンロード ", 
"url" : "_cds_struct_application_transfer_to_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ PLCへのアプリケーションのダウンロード ", 
"snippet" : "アプリケーションをPLCに転送するには、プログラムをエラーなしでコンパイルし、PLCの接続設定を設定する必要があります。 コントローラとの通信が暗号化されているか、特定のユーザーに制限されている場合は、それぞれの証明書と権限が必要です。こちらをご覧ください デバイスユーザー管理の処理アプリケーションの保護デバイスとの通信に関する基本的なセキュリティポリシーは、次のダイアログで編集できます。 通信設定 デバイスエディタのタブ。ここを参照してください： 通信の暗号化、セキュリティ設定の変更これらの要件が満たされると、アプリケーションはログイン時にPLCにダウンロードされます。...", 
"body" : "アプリケーションをPLCに転送するには、プログラムをエラーなしでコンパイルし、PLCの接続設定を設定する必要があります。 コントローラとの通信が暗号化されているか、特定のユーザーに制限されている場合は、それぞれの証明書と権限が必要です。こちらをご覧ください デバイスユーザー管理の処理アプリケーションの保護デバイスとの通信に関する基本的なセキュリティポリシーは、次のダイアログで編集できます。 通信設定 デバイスエディタのタブ。ここを参照してください： 通信の暗号化、セキュリティ設定の変更これらの要件が満たされると、アプリケーションはログイン時にPLCにダウンロードされます。 " }, 
{ "title" : "PLCへの接続の構成 ", 
"url" : "_cds_configuring_connection_to_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ PLCへのアプリケーションのダウンロード \/ PLCへの接続の構成 ", 
"snippet" : "コントローラへの接続は、ゲートウェイを使用して確立されます。このゲートウェイは、開発用コンピューターまたはコントローラーに接続された別のネットワークコンピューターにすることができます。 The 通信設定 接続パスを設定するためのダイアログが利用可能です。ログインしようとするとこのダイアログが自動的に開きますが、通信設定はまだ構成されていません。 コントローラとの通信が暗号化され、ユーザー管理によって保護されている場合は、コントローラへの接続を確立するために、対応する証明書と資格情報が必要です。この場合は、「通信の暗号化とセキュリティ設定の変更」ヘルプページの関連する手順を参照してください。 要...", 
"body" : "コントローラへの接続は、ゲートウェイを使用して確立されます。このゲートウェイは、開発用コンピューターまたはコントローラーに接続された別のネットワークコンピューターにすることができます。 The 通信設定 接続パスを設定するためのダイアログが利用可能です。ログインしようとするとこのダイアログが自動的に開きますが、通信設定はまだ構成されていません。 コントローラとの通信が暗号化され、ユーザー管理によって保護されている場合は、コントローラへの接続を確立するために、対応する証明書と資格情報が必要です。この場合は、「通信の暗号化とセキュリティ設定の変更」ヘルプページの関連する手順を参照してください。 要件：プロジェクトはエラーなしでコンパイルできます。プログラマブルロジックコントローラ（PLC）がデバイスツリーに挿入されます。デバイスにはユーザー管理の使用が必要ですが、有効になっていません。 デバイスツリーで、PLCを選択し、をクリックします プロジェクト→オブジェクトの編集 。 PLCがエディタで開きます。 クリック 通信設定 タブ。 メニューバーで、をクリックします スキャンネットワーク 。 The デバイスを選択 ダイアログが開きます。ネットワークで使用可能なすべてのデバイスが左側に表示されます。 目的のデバイスを選択して、 わかった 。 デバイスにユーザー管理が必要であるという通知とともにダイアログプロンプトが開きますが、まだ有効になっていません。必要に応じて、ユーザー管理を有効にするように求められます。この場合、新しい管理者アカウントを作成してから、このユーザーとしてログインする必要があるという通知が表示されます。 クリック はい ダイアログプロンプトを閉じます。 The デバイスユーザーの追加 ダイアログが開き、初期デバイス管理者を作成します。 クレデンシャルを定義します（ 名前 と パスワード ）デバイス管理者用。を選択 パスワードはユーザーが変更できます オプション。 パスワードの重大度を考慮することが不可欠です。開発システム内から、パスワードを忘れた場合にコントローラーに再度アクセスする方法はありません。 クリック わかった ダイアログを閉じます。 The デバイスユーザーのログオン ダイアログが開きます。 前の手順で定義したデバイス管理者の資格情報を指定します。 PLCの接続経路を設定します。 通信設定ビューを元のビューにリセットできます。 CODESYS デバイスエディタのオプション 。 詳細については、以下を参照してください。 通信の暗号化、セキュリティ設定の変更" }, 
{ "title" : "通信の暗号化、セキュリティ設定の変更 ", 
"url" : "_cds_encrypting_communication_changing_security_policy.html", 
"breadcrumbs" : "CODESYS Essentials \/ PLCへのアプリケーションのダウンロード \/ 通信の暗号化、セキュリティ設定の変更 ", 
"snippet" : "データ保護に関する推奨事項 データセキュリティ違反のリスクを最小限に抑えるために、アプリケーションが実行されているシステムに対して、次の組織的および技術的なアクションを実行することをお勧めします。可能な限り、PLCと制御ネットワークをオープンネットワークとインターネットにさらすことは避けてください。リモートアクセス用のVPNなど、保護のために追加のデータリンク層を使用します。ファイアウォールメカニズムをインストールします。許可された人へのアクセスを制限します。強力なパスワードを使用してください。試運転時に、既存のデフォルトのパスワードを変更し、定期的に変更します。 でサポートされているセキュリ...", 
"body" : "データ保護に関する推奨事項 データセキュリティ違反のリスクを最小限に抑えるために、アプリケーションが実行されているシステムに対して、次の組織的および技術的なアクションを実行することをお勧めします。可能な限り、PLCと制御ネットワークをオープンネットワークとインターネットにさらすことは避けてください。リモートアクセス用のVPNなど、保護のために追加のデータリンク層を使用します。ファイアウォールメカニズムをインストールします。許可された人へのアクセスを制限します。強力なパスワードを使用してください。試運転時に、既存のデフォルトのパスワードを変更し、定期的に変更します。 でサポートされているセキュリティ機能を使用する CODESYS コントローラとの通信の暗号化や意図的に制限されたユーザーアクセスなど、それぞれのコントローラ。 デバイスとの通信は、デバイスの暗号化とユーザー管理によって保護できます。現在のセキュリティプリセットは、 通信設定 デバイスエディタのタブ。 詳細と手順については、以下を参照してください。 証明書による通信の暗号化、セキュリティポリシーの変更 SPS ユーザー管理 " }, 
{ "title" : "デバイスユーザー管理の処理 ", 
"url" : "_cds_handling_user_management_on_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ PLCへのアプリケーションのダウンロード \/ デバイスユーザー管理の処理 ", 
"snippet" : "これについては、以下を参照してください。 CODESYS セキュリティ-ユーザー管理\/デバイスのアクセス権管理 パスワード、パスワードポリシー、ログインロックを使用する...", 
"body" : "これについては、以下を参照してください。 CODESYS セキュリティ-ユーザー管理\/デバイスのアクセス権管理 パスワード、パスワードポリシー、ログインロックを使用する " }, 
{ "title" : "アプリケーションコードの生成 ", 
"url" : "_cds_creating_application_code_for_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ PLCへのアプリケーションのダウンロード \/ アプリケーションコードの生成 ", 
"snippet" : "アプリケーションコードは、アプリケーションの起動時にPLCが実行するマシンコードです。 CODESYS 開発システムで記述されたソースコードからアプリケーションコードを自動的に生成します。これは、アプリケーションをコントローラーにダウンロードする前に自動的に実行されます。アプリケーションコードが生成される前に、割り当て、データ型、およびライブラリの可用性を確認するためのテストが実行されます。さらに、メモリアドレスはアプリケーションコードの生成時に割り当てられます。 クリックできます ビルド→コードの生成 このコマンドを明示的に実行します。これは、PLCがまだ接続されていない場合でも、ソースコー...", 
"body" : "アプリケーションコードは、アプリケーションの起動時にPLCが実行するマシンコードです。 CODESYS 開発システムで記述されたソースコードからアプリケーションコードを自動的に生成します。これは、アプリケーションをコントローラーにダウンロードする前に自動的に実行されます。アプリケーションコードが生成される前に、割り当て、データ型、およびライブラリの可用性を確認するためのテストが実行されます。さらに、メモリアドレスはアプリケーションコードの生成時に割り当てられます。 クリックできます ビルド→コードの生成 このコマンドを明示的に実行します。これは、PLCがまだ接続されていない場合でも、ソースコードのエラーを検出するのに役立ちます。エラーは、「ビルド」カテゴリのメッセージビューに出力されます。 アプリケーションを暗号化した場合は、次の情報を考慮してください。オンライン変更後に要求に応じて（新しい）ブートアプリケーションが生成された場合、ブートアプリケーションは暗号化されていない現在のコードでRAMに形成されます。 アプリケーションコードの暗号化 詳細については、以下を参照してください。 アプリケーションの保護" }, 
{ "title" : "アプリケーションコードを明示的に生成する ", 
"url" : "_cds_creating_application_code_for_plc.html#UUID-5c7fdea2-b927-dd81-e489-7c93454d6804_id_c4ec88dacce7d11bc0a8640e01d44e7d_id_0b4f2b8f2cd5acc8c0a8640e009372af", 
"breadcrumbs" : "CODESYS Essentials \/ PLCへのアプリケーションのダウンロード \/ アプリケーションコードの生成 \/ アプリケーションコードを明示的に生成する ", 
"snippet" : "要件：アプリケーションはエラーなしでコンパイルできます。 クリック ビルド→ コードを生成する 。 アプリケーションコードが生成されます。メモリ割り当てに関する詳細情報は、メッセージビューに出力されます。 詳細については、以下を参照してください。 ブートアプリケーションの作成...", 
"body" : "要件：アプリケーションはエラーなしでコンパイルできます。 クリック ビルド→ コードを生成する 。 アプリケーションコードが生成されます。メモリ割り当てに関する詳細情報は、メッセージビューに出力されます。 詳細については、以下を参照してください。 ブートアプリケーションの作成" }, 
{ "title" : "アプリケーションコード生成時のメッセージ ", 
"url" : "_cds_creating_application_code_for_plc.html#UUID-5c7fdea2-b927-dd81-e489-7c93454d6804_id_c4ec88dacce7d11bc0a8640e01d44e7d_id_624175cd2d47e684c0a8640e00e57d65", 
"breadcrumbs" : "CODESYS Essentials \/ PLCへのアプリケーションのダウンロード \/ アプリケーションコードの生成 \/ アプリケーションコード生成時のメッセージ ", 
"snippet" : "アプリケーションコードを生成するとき、 CODESYS メッセージビューにメモリ割り当てに関する情報を出力します。再割り当ては、メモリの増分ビルドのために新規および変更されたPOUと変数に対してのみ行われるため、メモリにギャップが生じます。オンラインでの変更も同じ効果があります。この断片化により、使用可能なメモリの量が減少します。ただし、クリックするとメモリを完全に再割り当てできます 綺麗 したがって、空きメモリの量を増やします。 構文エラーとバグ CODESYS コード生成中の検出とメモリ割り当てもメッセージビューに出力されます（ 建てる カテゴリー）。 メモリ割り当てに関する出力情報： 生...", 
"body" : "アプリケーションコードを生成するとき、 CODESYS メッセージビューにメモリ割り当てに関する情報を出力します。再割り当ては、メモリの増分ビルドのために新規および変更されたPOUと変数に対してのみ行われるため、メモリにギャップが生じます。オンラインでの変更も同じ効果があります。この断片化により、使用可能なメモリの量が減少します。ただし、クリックするとメモリを完全に再割り当てできます 綺麗 したがって、空きメモリの量を増やします。 構文エラーとバグ CODESYS コード生成中の検出とメモリ割り当てもメッセージビューに出力されます（ 建てる カテゴリー）。 メモリ割り当てに関する出力情報： 生成されたコードのサイズ （バイト単位）：すべてのコードセグメントの合計 グローバルデータのサイズ （バイト単位）：グローバル変数によって使用される合計メモリ。入力または出力がグローバル変数の領域にマップされていない限り、入力と出力は含まれません。 コードとデータに割り当てられた合計メモリサイズ （バイト単位）：割り当てられたメモリの合計は、すでに使用されているメモリ領域と、増分ビルドおよびオンライン変更用に予約されているがまだ使用されていないメモリで構成されます。最初のビルド後、すでに使用されているメモリは、使用されている最大のアドレスとほぼ同じです（以下を参照）。最大の連続メモリギャップ（以下を参照）は、割り当てられたメモリの合計との差にほぼ対応します。ただし、増分ビルドとオンライン変更の数が増えると、メモリギャップの数も増え、連続する最大のメモリギャップは小さくなります。 メモリ領域<n> ：個々の予約済みメモリ領域の内容： 背景：どのデータとコードがどのメモリ領域に保存されているかは、PLCによって異なります。たとえば、コードとデータは、 CODESYS Control Win 。住所について %I 、 %M 、 と %Q 、変数がアドレスに割り当てられていない場合でも、メモリは常に予約されています。アプリケーションを「クリーンアップ」した後、メモリは完全に再割り当てされます。この場合、事前定義された「配置」（通常は8）によって小さなギャップが生じる可能性があります。ギャップが大きくなるのは、たとえば配列領域を増やすなどして、「クリーニング」せずに日付を変更した場合です。この場合、影響を受けるPOUのみが再コンパイルされます。さらに、オンライン変更の場合、メモリは新しい変数と新しいコードにのみ使用されます。以前に削除された変数とコードによって予約されていたメモリが再び使用可能になります。その結果、メモリの断片化は、多くの増分ビルドとオンライン変更の後に発生する可能性があります。これにより、場合によってはまったく使用できない可能性のある多くの小さなギャップが作成されます。安全に使用できるメモリの量を明確にするために、コード生成中にメモリ領域の「最大の連続メモリギャップ」が出力されます。 使用された最高のアドレス （バイト）：これは、割り当てられたメモリ領域全体で最も高い予約アドレスです。 「クリーニング」操作後の最初のビルド中に、メモリアドレスは、アラインメント（通常は8バイト）を考慮して、昇順で変数に出力されます。その結果、この時点で使用される最大のアドレスは、使用されるメモリの量にほぼ対応します。割り当てられたメモリ領域の残りの部分は、インクリメンタルビルドおよびオンライン変更に引き続き完全に使用できます。 最大の連続メモリギャップ （バイト単位）：これは、バックアップに使用できるメモリサイズです。 割り当てられたメモリに生じたギャップは、他の変更のために可能な限り再利用されます。たとえば、タイプのグローバル変数の場合 Byte が追加されると、メモリの最初の空きバイトに配置されます。これには、わずかなギャップでも十分です。ただし、FBインスタンス、構造体または配列の型の変数、またはPOUのコードは連続して格納する必要があるため、それに応じてより多くのメモリを占有します。結果として、それらは最大の連続したメモリ領域にのみ割り当てることができます。これが、コード生成中に、安全に使用できる「最大の連続メモリギャップ」が出力（バイト単位）と、合計メモリのパーセンテージである理由です。 これについては、以下も参照してください。 アプリケーションを生成するためのオプション " }, 
{ "title" : "アプリケーションコードのダウンロード、ログイン、およびPLCの起動 ", 
"url" : "_cds_loading_application_login_starting.html", 
"breadcrumbs" : "CODESYS Essentials \/ PLCへのアプリケーションのダウンロード \/ アプリケーションコードのダウンロード、ログイン、およびPLCの起動 ", 
"snippet" : "アプリケーションのソースコードをPLCにダウンロードするには、アプリケーションを使用してPLCにログインする必要があります。プロジェクトに複数のアプリケーションがある場合は、最初に正しいアプリケーションに明示的に切り替える必要があります。 アプリケーションをコントローラーにダウンロードすると、 CODESYS 次のチェックを実行します。 PLC上のアプリケーションのリストは、プロジェクトで使用可能なアプリケーションと比較されます。一致しない場合は、PLCにまだインストールされていないアプリケーションをダウンロードするか、既存のアプリケーションを削除するように求められます。 ダウンロードするアプ...", 
"body" : "アプリケーションのソースコードをPLCにダウンロードするには、アプリケーションを使用してPLCにログインする必要があります。プロジェクトに複数のアプリケーションがある場合は、最初に正しいアプリケーションに明示的に切り替える必要があります。 アプリケーションをコントローラーにダウンロードすると、 CODESYS 次のチェックを実行します。 PLC上のアプリケーションのリストは、プロジェクトで使用可能なアプリケーションと比較されます。一致しない場合は、PLCにまだインストールされていないアプリケーションをダウンロードするか、既存のアプリケーションを削除するように求められます。 ダウンロードするアプリケーションの「外部実装」ブロックの場合、 CODESYS これらがPLCで使用可能かどうかを確認します。それらが使用できない場合は、「未解決の参照」というメッセージがダイアログプロンプトとメッセージビューに出力されます。それで CODESYS ダウンロードするアプリケーションのブロックのパラメータ（変数）と、PLCに存在するアプリケーションの同じ名前のブロックのパラメータを比較します（署名チェック）。不一致がある場合は、「無効な署名」というメッセージがダイアログプロンプトとメッセージビューに出力されます。 アプリケーションのプロパティで[アプリケーション情報のダウンロード]オプションが選択されている場合、アプリケーションの内容に関する追加情報がPLCにダウンロードされます。 同じデバイスに複数のアプリケーションが存在する場合は、 I \/ Oマッピング ダイアログには、デバイスのI \/ Oマッピングに使用されるアプリケーションの定義が含まれています。 注: から接続が確立された場合、 CODESYS PLC と CODESYS Automation Server エッジ ゲートウェイを介して PLC に接続されている場合、 CODESYS Automation Server PLC 上のローカルの変更を上書きする可能性があります。この目的のために、メッセージがメッセージ ビューに表示されます。 CODESYS でプロジェクトを開いた後、PLC への接続が確立されたとき CODESYS 初めて。 詳細については、以下を参照してください。 アプリケーションアプリケーションの転送とプログラムの開始 要件：アプリケーションにエラーがなく、PLCの通信設定が正しいこと。アプリケーションはPLCにまだ存在していません。アプリケーションとコントローラーとの通信は暗号化されていません。 デバイスツリーで目的のアプリケーションを選択します。アプリケーションが1つしかない場合は、ステップ3にスキップしてください。 クリック アクティブなアプリケーションを設定する 。 アプリケーション名は太字で表示されます。 クリック オンライン→ログイン 。 PLCでアプリケーションを作成するかどうかを確認するダイアログが表示されます。 クリック はい ダイアログを確認します。 アプリケーションがコントローラーにダウンロードされます。 クリック デバッグ→開始 またはを押します F5 鍵。 アプリケーションはコントローラー上で実行されています。 " }, 
{ "title" : "ブートアプリケーションの作成 ", 
"url" : "_cds_creating_a_boot_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ PLCへのアプリケーションのダウンロード \/ ブートアプリケーションの作成 ", 
"snippet" : "ブートアプリケーションは、コントローラーの電源を入れたり起動したりすると自動的に起動するアプリケーションバージョンです。これを行うには、PLC上のアプリケーションが次のように存在する必要があります。 <application name>.app ファイル。 PLCで実行されているアプリケーションごとに、ブートアプリケーションをそこに保存することもできます。 デフォルトでは、 CODESYS アプリケーションがダウンロードされると自動的にブートアプリケーションを生成し、PLCに転送します。自動生成のデフォルト設定は、 プロパティ のアプリケーションオブジェクトの ブートアプリケーション カテゴリ...", 
"body" : "ブートアプリケーションは、コントローラーの電源を入れたり起動したりすると自動的に起動するアプリケーションバージョンです。これを行うには、PLC上のアプリケーションが次のように存在する必要があります。 <application name>.app ファイル。 PLCで実行されているアプリケーションごとに、ブートアプリケーションをそこに保存することもできます。 デフォルトでは、 CODESYS アプリケーションがダウンロードされると自動的にブートアプリケーションを生成し、PLCに転送します。自動生成のデフォルト設定は、 プロパティ のアプリケーションオブジェクトの ブートアプリケーション カテゴリー。変更したアプリケーションでログインする場合でも、新しいブートアプリケーションを生成するかどうかを確認するメッセージが表示されます。 また、クリックすることができます オンライン→ブートアプリケーションの作成 オンラインモードでいつでも新しいブートアプリケーションを作成できます。 オフラインモードでブートアプリケーションのローカルコピーを作成して保存することもできます。次に、外部ツールを使用してこのアプリケーションをPLCにコピーできます。その結果、に接続されていない場合でも、アプリケーションをPLCに転送できます。 CODESYS 。 で使用するための注意 CODESYS Control Win 使用する場合 CODESYS Control Win 、アプリケーション名も構成ファイルに含める必要があります（ *.cfg ）。 [CmpApp]\nApplication.1=MyApplication " }, 
{ "title" : "PLCでブートアプリケーションを自動的かつ明示的に生成する ", 
"url" : "_cds_creating_a_boot_application.html#UUID-c54f0d29-44ff-6993-adb8-9af7e6d0bdf6_id_a0805999879591e6c0a8640e017feaf9_id_8d4ef86a2876f271c0a8640e01324013", 
"breadcrumbs" : "CODESYS Essentials \/ PLCへのアプリケーションのダウンロード \/ ブートアプリケーションの作成 \/ PLCでブートアプリケーションを自動的かつ明示的に生成する ", 
"snippet" : "要件：オフラインモードで、アプリケーションはエラーなしでコンパイルされます。 PLCへの接続が構成され、PLCが実行されています。アプリケーションはアクティブです。次の手順は、オプションを示しています。 クリック オンライン→ログイン 。 The <application name>.app ブートアプリケーションファイルは、PLC上にCRCを使用して作成されます。 <application name>.crc アプリケーションを起動します。 明示的にクリック オンライン→ ブートアプリケーションの作成 。 PLC上のファイルは新しいファイルに置き換えられます。 ログアウト。 アプリケーション...", 
"body" : "要件：オフラインモードで、アプリケーションはエラーなしでコンパイルされます。 PLCへの接続が構成され、PLCが実行されています。アプリケーションはアクティブです。次の手順は、オプションを示しています。 クリック オンライン→ログイン 。 The <application name>.app ブートアプリケーションファイルは、PLC上にCRCを使用して作成されます。 <application name>.crc アプリケーションを起動します。 明示的にクリック オンライン→ ブートアプリケーションの作成 。 PLC上のファイルは新しいファイルに置き換えられます。 ログアウト。 アプリケーションを変更します。コントローラに再度ログインします。 オンライン変更を実行するように求められます。あなたは ブートアプリケーションを更新する 同じダイアログのオプション。デフォルトでは無効になっています。デフォルト設定はで変更できます プロパティ のアプリケーションオブジェクトの ブートアプリケーション カテゴリー。 オプションをオフのままにして、ログインを続行します。 新しいブートアプリケーションファイルは作成されません。 再度ログアウトします。プロジェクトを閉じます。 PLCを停止します。コントローラを再起動します。 上で作成したブートアプリケーションがPLCで実行されています。 暗号化されたブートアプリケーションをPLCに保存できます。アプリケーションオブジェクトのこれらの設定は、 プロパティ の中に アプリケーションビルドオプション カテゴリー。 詳細については、以下を参照してください。 オンライン変更を実行する" }, 
{ "title" : "オフラインモードでのブートアプリケーションの作成 ", 
"url" : "_cds_creating_a_boot_application.html#UUID-c54f0d29-44ff-6993-adb8-9af7e6d0bdf6_id_a0805999879591e6c0a8640e017feaf9_id_ed59e5272876f272c0a8640e0179f8b8", 
"breadcrumbs" : "CODESYS Essentials \/ PLCへのアプリケーションのダウンロード \/ ブートアプリケーションの作成 \/ オフラインモードでのブートアプリケーションの作成 ", 
"snippet" : "要件：オフラインモードで、アプリケーションはエラーなしでコンパイルされます。アプリケーションのブートアプリケーションを生成し、ファイルディレクトリに保存して、後で外部ツールを使用してPLCにコピーできるようにします（ CODESYS ）。 クリック オンライン→ ブートアプリケーションの作成 。 ローカルファイルシステム内の場所を指定するためのダイアログが開きます。 保存パスをクリックしてから、 保存する 。 最後のブートアプリケーションが生成されてからアプリケーションが変更された場合は、ブートアプリケーションに新しいコードを使用するように求められます。この場合、をクリックします はい 。 T...", 
"body" : "要件：オフラインモードで、アプリケーションはエラーなしでコンパイルされます。アプリケーションのブートアプリケーションを生成し、ファイルディレクトリに保存して、後で外部ツールを使用してPLCにコピーできるようにします（ CODESYS ）。 クリック オンライン→ ブートアプリケーションの作成 。 ローカルファイルシステム内の場所を指定するためのダイアログが開きます。 保存パスをクリックしてから、 保存する 。 最後のブートアプリケーションが生成されてからアプリケーションが変更された場合は、ブートアプリケーションに新しいコードを使用するように求められます。この場合、をクリックします はい 。 The 名前を付けて保存 ダイアログが開きます。 ディレクトリを選択してクリックします 保存する 。 <application name.app>ブートアプリケーションファイルは、指定されたパスに作成されます。 ブートアプリケーションのコンパイル情報を保存するかどうかを確認するメッセージが表示されます。 クリック はい 。 コンパイル情報は、という名前のファイルとしてプロジェクトディレクトリに保存されます <application name>.compileinfo 。これは、次にアプリケーションが更新されたときにオンラインで変更される可能性があるための要件です。注： ビルド→クリーン コマンドはこのファイルを削除します。 " }, 
{ "title" : "PLCとの間でソースコードをダウンロードする ", 
"url" : "_cds_loading_sourcecode_to_from_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ PLCへのアプリケーションのダウンロード \/ PLCとの間でソースコードをダウンロードする ", 
"snippet" : "CODESYS プロジェクトソースコードをプロジェクトアーカイブとしてPLCにロードする機能を提供します。その後、必要に応じて、このプロジェクトアーカイブをPLCから開発システムに転送して戻すことができます。 要件：影響を受けるコントローラーの接続設定が構成されている。 PLCからのソースコードのロード クリック ファイル → ソースのアップロード . The デバイスを選択 ダイアログが開きます。 PLCを選択してソースコードを送信します。クリック わかった 。 The プロジェクトの抽出 ダイアログが開きます。 プロジェクトアーカイブを抽出する宛先ディレクトリを選択します。クリック エキス...", 
"body" : "CODESYS プロジェクトソースコードをプロジェクトアーカイブとしてPLCにロードする機能を提供します。その後、必要に応じて、このプロジェクトアーカイブをPLCから開発システムに転送して戻すことができます。 要件：影響を受けるコントローラーの接続設定が構成されている。 PLCからのソースコードのロード クリック ファイル → ソースのアップロード . The デバイスを選択 ダイアログが開きます。 PLCを選択してソースコードを送信します。クリック わかった 。 The プロジェクトの抽出 ダイアログが開きます。 プロジェクトアーカイブを抽出する宛先ディレクトリを選択します。クリック エキス 。 CODESYS プロジェクトアーカイブをディレクトリに抽出します。 次に、プロジェクトアーカイブを開くように求められます。クリック はい 。 プロジェクトが開きます。 " }, 
{ "title" : "PLCへのソースコードのダウンロード ", 
"url" : "_cds_loading_sourcecode_to_from_plc.html#UUID-0ad360c5-6f3b-72f6-1bf4-e13ee462c493_id_b468660460c0a8640e01de1e14_id_07ca0313689602ffc0a8640e010017e8", 
"breadcrumbs" : "CODESYS Essentials \/ PLCへのアプリケーションのダウンロード \/ PLCとの間でソースコードをダウンロードする \/ PLCへのソースコードのダウンロード ", 
"snippet" : "クリック ファイル → ソースのダウンロード . The デバイスを選択 ダイアログが開きます。 ソースコードを受信するPLCを選択します。クリック わかった 。 CODESYS 書き込みます Archive.prj コントローラにファイルをアーカイブします。 クリックできます オンライン→ 接続されたデバイスへのソースのダウンロード 接続されたデバイスにソースコードを直接ダウンロードします。 詳細については、以下を参照してください。 ソースのダウンロード...", 
"body" : "クリック ファイル → ソースのダウンロード . The デバイスを選択 ダイアログが開きます。 ソースコードを受信するPLCを選択します。クリック わかった 。 CODESYS 書き込みます Archive.prj コントローラにファイルをアーカイブします。 クリックできます オンライン→ 接続されたデバイスへのソースのダウンロード 接続されたデバイスにソースコードを直接ダウンロードします。 詳細については、以下を参照してください。 ソースのダウンロード" }, 
{ "title" : "さまざまなメモリ領域へのアプリケーションコードの配布 ", 
"url" : "_cds_mapping_code_in_different_areas.html", 
"breadcrumbs" : "CODESYS Essentials \/ PLCへのアプリケーションのダウンロード \/ さまざまなメモリ領域へのアプリケーションコードの配布 ", 
"snippet" : "CODESYS コントローラのさまざまなメモリ領域にアプリケーションのコードを保存する可能性を提供します。このための前提条件は、この機能をサポートするコントローラーを使用することです。これらの特別なコントローラーを使用すると、アプリケーションにオブジェクトが自動的に含まれます POUの場所 、これを使用して、個々のプログラムブロックに異なるメモリ領域を割り当てます。 また、メーカー固有またはコントローラー固有の仕様またはこの機能に関する情報にも注意してください。 要件：アプリケーションにコンパイルエラーが含まれていません。 の中に デバイス 表示、ダブルクリック POUの場所 物体。 開いてい...", 
"body" : "CODESYS コントローラのさまざまなメモリ領域にアプリケーションのコードを保存する可能性を提供します。このための前提条件は、この機能をサポートするコントローラーを使用することです。これらの特別なコントローラーを使用すると、アプリケーションにオブジェクトが自動的に含まれます POUの場所 、これを使用して、個々のプログラムブロックに異なるメモリ領域を割り当てます。 また、メーカー固有またはコントローラー固有の仕様またはこの機能に関する情報にも注意してください。 要件：アプリケーションにコンパイルエラーが含まれていません。 の中に デバイス 表示、ダブルクリック POUの場所 物体。 開いているオブジェクトで、をクリックします Generate Code ボタン。 アプリケーションのすべてのプログラムブロックは、それぞれのオブジェクトタイプ、メモリ内の現在の場所、およびコードサイズとともに表示されます。 のエントリをダブルクリックします 構成された場所 別のメモリ領域に保存するPOUの列。 リストボックスが開きます。 リストボックスからメモリ領域を選択します。 クリック 綺麗 その後 コードを生成する 。 POUは、再構成されたメモリ位置に保存されます。 " }, 
{ "title" : "テストとトラブルシューティング ", 
"url" : "_cds_struct_test_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング ", 
"snippet" : "CODESYS アプリケーションをテストしてエラーを見つけるためのさまざまなオプションを提供します。このようにして、ハードウェアが接続されていなくても、シミュレーションモードでアプリケーションを起動できます。プログラムを段階的に実行するためのブレークポイントとコマンドを使用すると、プログラムの特定の部分を非常に的を絞った方法で調べることができます。変数値を書き込むことにより、実行中のプログラムに影響を与えることができます。 アプリケーションをさまざまな程度にリセットするコマンドを使用できます。これは、非永続変数のみをリセットすることから、コントローラーを配信ステータスに完全にリセットすることま...", 
"body" : "CODESYS アプリケーションをテストしてエラーを見つけるためのさまざまなオプションを提供します。このようにして、ハードウェアが接続されていなくても、シミュレーションモードでアプリケーションを起動できます。プログラムを段階的に実行するためのブレークポイントとコマンドを使用すると、プログラムの特定の部分を非常に的を絞った方法で調べることができます。変数値を書き込むことにより、実行中のプログラムに影響を与えることができます。 アプリケーションをさまざまな程度にリセットするコマンドを使用できます。これは、非永続変数のみをリセットすることから、コントローラーを配信ステータスに完全にリセットすることまでの範囲です。 " }, 
{ "title" : "シミュレーションモードでのテスト ", 
"url" : "_cds_testing_in_simulation_mode.html", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ シミュレーションモードでのテスト ", 
"snippet" : "実際のターゲットデバイスが利用できない場合は、シミュレーションモードを使用してプログラムをテストおよびデバッグします。このモードでは、アプリケーションはシミュレートされたターゲットデバイスで開始されます。 このコマンドは、ログアウトしている場合にのみ使用できます。 要件：エラーのないプログラム（コンパイラエラーメッセージまたは変換エラー）があり、ログインしていません。 シミュレーションモードをアクティブにします。 メニューコマンドを選択します オンライン→ シミュレーション また デバイスツリーでコントローラーを選択し、コンテキストメニューからコマンドを選択します シミュレーション 。 デバイ...", 
"body" : "実際のターゲットデバイスが利用できない場合は、シミュレーションモードを使用してプログラムをテストおよびデバッグします。このモードでは、アプリケーションはシミュレートされたターゲットデバイスで開始されます。 このコマンドは、ログアウトしている場合にのみ使用できます。 要件：エラーのないプログラム（コンパイラエラーメッセージまたは変換エラー）があり、ログインしていません。 シミュレーションモードをアクティブにします。 メニューコマンドを選択します オンライン→ シミュレーション また デバイスツリーでコントローラーを選択し、コンテキストメニューからコマンドを選択します シミュレーション 。 デバイスツリー内のコントローラーの名前はイタリック体で示されています。ステータス行に「シミュレーション」が赤い背景で表示されます。メニューコマンド シミュレーション チェックされます。 コマンドを選択します オンライン→ログイン 。 アクティブなアプリケーションで初めてログインするときに、アプリケーション「Sim。<devicename>。<applicationname>」を作成してロードするかどうかを尋ねられます。で確認する はい 。 アプリケーションがコントローラーにログインします。これは、デバイスツリーでアイコンで示されます コントローラの前で信号を送ります。 これで、プログラムフローを確認して修正できます。この目的のために、対応するコマンドがメニューで利用可能です デバッグ 処分する。 コントローラからログアウトし、シミュレーションモードを終了します。 " }, 
{ "title" : "ブレークポイントの使用 ", 
"url" : "_cds_using_breakpoints.html", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ ブレークポイントの使用 ", 
"snippet" : "ブレークポイントは通常、プログラムのデバッグに使用されます。 CODESYS すべてのIECエディタでブレークポイントをサポートします。 プログラムの特定の位置にブレークポイントを設定して、実行を強制的に停止し、変数値を監視することができます。特定の変数の値が変更されたときにプログラムの実行を停止するために、特別な「データブレークポイント」を設定できます。 ブレークポイントまたはデータブレークポイントでの停止は、追加の条件の対象となる可能性があります。ブレークポイントとデータブレークポイントを、プログラムが停止せずに特定のコードを実行する「実行ポイント」として再定義することもできます。 景色 ...", 
"body" : "ブレークポイントは通常、プログラムのデバッグに使用されます。 CODESYS すべてのIECエディタでブレークポイントをサポートします。 プログラムの特定の位置にブレークポイントを設定して、実行を強制的に停止し、変数値を監視することができます。特定の変数の値が変更されたときにプログラムの実行を停止するために、特別な「データブレークポイント」を設定できます。 ブレークポイントまたはデータブレークポイントでの停止は、追加の条件の対象となる可能性があります。ブレークポイントとデータブレークポイントを、プログラムが停止せずに特定のコードを実行する「実行ポイント」として再定義することもできます。 景色 ブレークポイント 定義されたすべてのブレークポイントの概要を示します。複数のブレークポイントを一度に変更するための追加のコマンドを提供します。 エディターでは、ブレークポイントと実行ポイントのステータスが次のアイコンでマークされます。 ：ブレークポイントが有効になっています。 ：ブレークポイントは無効です。 ：ブレークポイントは、エディターで現在開いているブロックの別のインスタンスに設定されます。 ：プログラムはブレークポイントで停止します。 ：条件付きブレークポイントが有効になっています。 ：条件付きブレークポイントは無効です。 ：実行ポイントがアクティブになります。 ：実行ポイントは無効になっています。 ：条件付き実行ポイントが有効になります。 ：条件付き実行ポイントは無効になっています。 ：データブレークポイントが有効になっています。 ：データブレークポイントは無効になっています。 ：プログラムはデータブレークポイントで停止します。 ：データ実行ポイントが有効になります。 ：データ実行ポイントが無効になります。 ：プログラムはデータ実行ポイントで停止します。 ：条件付きデータ実行ポイントが有効になります。 ：条件付きデータブレークポイントが有効になります。 詳細については、以下を参照してください。 ブレークポイントデータブレークポイントを設定する 要件：アプリケーションはオンラインで実行されています。 コマンドを選択します 表示→ブレークポイント 。 コマンドを選択します デバッグ→新しいデータブレークポイント 。 ダイアログをクリックします 新しいブレークポイント タブ内 データ ボタンに 。 ダイアログで選択 入力ヘルプ タブ内 変数を監視する 値がプログラムを変更する変数は停止する必要があります。 または、タブに入力します データ 変数の修飾名を入力行に直接入力します。例： PLC_PRG.iNumber 。監視する正確なバイト数は呼び出されます サイズ 指定。ここでは、データ型に対応する値が自動的に指定されますが、監視するバイト数を減らすこともできます。 ビューで選択 ブレークポイント データブレークポイントのある行をクリックしてボタンをクリックします 。 線はマークされ、アイコンが付いています （データブレークポイントが有効）。プログラムがデータブレークポイントに到達すると、つまり選択した変数の値が変化すると、プログラムの実行が停止します。ブロックの実装部分では、次の行が矢印でマークされています マークされた。これはステータスバーに表示され、ステータスは赤で強調表示されます HALT AUF BP 信号。 コマンドを選択します デバッグ→起動 またはボタンを押します F5 。 プログラムは実行を継続し、変数の値が再び変更されると再び停止します。 " }, 
{ "title" : "データブレークポイント ", 
"url" : "_cds_using_breakpoints.html#UUID-eb91dc52-07a4-5e25-16b5-ccbb7bda59cd_id_a29163617e8e0b7c0a8640e01803c00_id_2d628f59bea511e09bc3d16902ba108f", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ ブレークポイントの使用 \/ データブレークポイント ", 
"snippet" : "データブレークポイントの機能は、ターゲットシステムによって異なります。現在、データブレークポイントは CODESYS Control Win 可能。 データブレークポイントは、特定の変数またはメモリアドレスの値が変更されると、プログラムの実行を停止します。 「通常の」ブレークポイントと同様に、停止を追加の条件にリンクしたり、停止の代わりに特定のコードを処理したりできます（データ実行ポイントへの変換）。 コマンドでデータブレークポイントを設定します 新しいデータブレークポイント メニューから デバッグ 、またはビューで ブレークポイント ボタン経由 新しい 。その際、修飾変数名を指定するか、値の...", 
"body" : "データブレークポイントの機能は、ターゲットシステムによって異なります。現在、データブレークポイントは CODESYS Control Win 可能。 データブレークポイントは、特定の変数またはメモリアドレスの値が変更されると、プログラムの実行を停止します。 「通常の」ブレークポイントと同様に、停止を追加の条件にリンクしたり、停止の代わりに特定のコードを処理したりできます（データ実行ポイントへの変換）。 コマンドでデータブレークポイントを設定します 新しいデータブレークポイント メニューから デバッグ 、またはビューで ブレークポイント ボタン経由 新しい 。その際、修飾変数名を指定するか、値の変更を監視するメモリアドレスを直接指定します。 例 次のサンプルコードでは、Variableのメモリスペース iNumber 意図せずに上書きされました。変数にデータブレークポイントがある iNumber ただし、値が変わると通知されます。次に、配列アクセスで対応するメッセージが表示されて処理が停止し、変数値が上書きされます。 Idx = 7 。 以下も参照してください：「データブレークポイントの設定」 PROGRAM PLC_PRG\nVAR\n Idx : INT;\n Ary : ARRAY[0..3] OF BYTE;\n iNumber : INT := 55;\nEND_VAR\nFOR idx := 0 TO 6 DO\n Ary[idx] := 0;\nEND_FOR " }, 
{ "title" : "マルチタスクアプリケーションのブレークポイント ", 
"url" : "_cds_using_breakpoints.html#UUID-eb91dc52-07a4-5e25-16b5-ccbb7bda59cd_id_a29163617e8e0b7c0a8640e01803c00_id_fc3cb2351b73b0bcc0a8640e006f44cc", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ ブレークポイントの使用 \/ マルチタスクアプリケーションのブレークポイント ", 
"snippet" : "基本的に、同時に複数のタスクでデバッグすることはできません。ブレークポイントまたはステップスルーのあるタスクで作業している限り、他のタスクのブレークポイントは無視されます。 ブレークポイントが設定されているブロックが複数のタスクで使用されている場合、最初にブレークポイントに到達したタスク（「デバッグタスク」）のみが停止されます。他のすべてのタスクは引き続き実行されます。対話中 コールスタック 現在中断されているタスクを確認します。 特定のタスクのみがブレークポイントの影響を受けるようにする場合は、ブレークポイントのプロパティでこれを指定できます。 ブレークポイントはアプリケーションごとに個別に...", 
"body" : "基本的に、同時に複数のタスクでデバッグすることはできません。ブレークポイントまたはステップスルーのあるタスクで作業している限り、他のタスクのブレークポイントは無視されます。 ブレークポイントが設定されているブロックが複数のタスクで使用されている場合、最初にブレークポイントに到達したタスク（「デバッグタスク」）のみが停止されます。他のすべてのタスクは引き続き実行されます。対話中 コールスタック 現在中断されているタスクを確認します。 特定のタスクのみがブレークポイントの影響を受けるようにする場合は、ブレークポイントのプロパティでこれを指定できます。 ブレークポイントはアプリケーションごとに個別に機能するため、「BPでのブレーク」は他のアプリケーションに影響を与えません。これは、複数のアプリケーションで使用され、コードがPLCに1回だけ存在するブロックにブレークポイントが設定されている場合でも、親\/子アプリケーションにも当てはまります。 「デバッグタスク」によって提供されるI \/ Oは、オプションを選択した場合でも、ブレークポイントでの停止時に更新されません。 停止中のI \/ Oの更新 PLC設定で有効になります。 PLC上のアプリケーションがブレークポイントにある場合、オンラインで変更またはダウンロードすると、すべてのタスクが停止します。つまり、PLCが停止します。この場合は CODESYS 対応するメッセージが表示され、ログインを続行するかどうかを決定できます。 " }, 
{ "title" : "単純なブレークポイントの設定（STエディターの例） ", 
"url" : "_cds_using_breakpoints.html#UUID-eb91dc52-07a4-5e25-16b5-ccbb7bda59cd_id_a29163617e8e0b7c0a8640e01803c00_id_976c066b2e8311e482de899d4a6249d6", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ ブレークポイントの使用 \/ 単純なブレークポイントの設定（STエディターの例） ", 
"snippet" : "要件：アプリケーションはオンラインで実行されています。動作モードは デバッグ 。 メモ帳でST言語のPOUを開きます。 ブレークポイントを設定する行にカーソルを置きます。 コマンドを選択します デバッグ→ブレークポイントの切り替え またはボタンを押します F9 。 線は赤でマークされ、アイコンが付いています （ブレークポイントがアクティブ化）マークされています。プログラムがブレークポイントにあるとき、アイコンのある行 （ブレークポイントで停止）マーク。プログラムの処理が停止します。これはステータスバーに表示され、ステータスは赤で強調表示されます HALT AUF BP 信号。 コマンドを選択し...", 
"body" : "要件：アプリケーションはオンラインで実行されています。動作モードは デバッグ 。 メモ帳でST言語のPOUを開きます。 ブレークポイントを設定する行にカーソルを置きます。 コマンドを選択します デバッグ→ブレークポイントの切り替え またはボタンを押します F9 。 線は赤でマークされ、アイコンが付いています （ブレークポイントがアクティブ化）マークされています。プログラムがブレークポイントにあるとき、アイコンのある行 （ブレークポイントで停止）マーク。プログラムの処理が停止します。これはステータスバーに表示され、ステータスは赤で強調表示されます HALT AUF BP 信号。 コマンドを選択します デバッグ→起動 またはボタンを押します F5 。 プログラムは続行されます。 より多くのブレークポイントを設定し、ブレークポイントで変数の値を確認します。 ブレークポイントを削除する行にカーソルを置きます。 コマンドを選択します デバッグ→ ブレークポイントを切り替えます またはボタンを押します F9 。 マークが消えます。ブレークポイントが削除されます。 " }, 
{ "title" : "ブレークポイント条件の定義（STエディターの例） ", 
"url" : "_cds_using_breakpoints.html#UUID-eb91dc52-07a4-5e25-16b5-ccbb7bda59cd_id_a29163617e8e0b7c0a8640e01803c00_id_aae846be2e8311e482de899d4a6249d6", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ ブレークポイントの使用 \/ ブレークポイント条件の定義（STエディターの例） ", 
"snippet" : "メモ帳でST言語のPOUを開きます。 ブレークポイントを設定する行にカーソルを置きます。 コマンドを選択します デバッグ→新しいブレークポイント 。 ダイアログが開きます 新しいブレークポイント 。 タブを選択します 調子 。 セクションで選択 ヒット数 オプション ヒット数がの倍数になったときに停止します 。 右側のフィールドに値5を入力します。 さらに、ブレークポイントをアクティブにする必要がある場合のブール条件を定義します。これを行うには、オプションをアクティブにします trueの場合は停止 。右側のフィールドにブール変数を入力します。 オプションを有効にする ブレークポイントをすぐに有...", 
"body" : "メモ帳でST言語のPOUを開きます。 ブレークポイントを設定する行にカーソルを置きます。 コマンドを選択します デバッグ→新しいブレークポイント 。 ダイアログが開きます 新しいブレークポイント 。 タブを選択します 調子 。 セクションで選択 ヒット数 オプション ヒット数がの倍数になったときに停止します 。 右側のフィールドに値5を入力します。 さらに、ブレークポイントをアクティブにする必要がある場合のブール条件を定義します。これを行うには、オプションをアクティブにします trueの場合は停止 。右側のフィールドにブール変数を入力します。 オプションを有効にする ブレークポイントをすぐに有効にする 。 ダイアログを閉じます。 線は赤でマークされ、アイコンが付いています マークされた。 次に、実行中のプログラムを監視します。条件のブール変数である限り FALSE 、ブレークポイントの条件が満たされていないため、プログラムが実行されます。変数をに設定した場合 TRUE 設定すると、条件が満たされ、プログラムは5回の実行ごとにこのブレークポイントで停止します。 " }, 
{ "title" : "実行ポイントの指定（STエディターの例） ", 
"url" : "_cds_using_breakpoints.html#UUID-eb91dc52-07a4-5e25-16b5-ccbb7bda59cd_id_a29163617e8e0b7c0a8640e01803c00_id_fb223006da6101d6c0a864630d894b56", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ ブレークポイントの使用 \/ 実行ポイントの指定（STエディターの例） ", 
"snippet" : "メモ帳でST言語のPOUを開きます。 実行ポイントを設定する行にカーソルを置きます。 コマンドを選択します デバッグ→新しいブレークポイント 。 ダイアログが開きます 新しいブレークポイント 。 タブを選択します 実行ポイントの設定 。 オプションを有効にする 実行ポイント 。 ボックスに入力します 次のコードを実行します 次のステートメントを入力します。 iCounter := iCounter + 1; ボックスに入力します デバイスログにメッセージを出力します 次のテキストを入力します。 Ausführungspunkt erreicht {iCounter} ダイアログを閉じます。 プ...", 
"body" : "メモ帳でST言語のPOUを開きます。 実行ポイントを設定する行にカーソルを置きます。 コマンドを選択します デバッグ→新しいブレークポイント 。 ダイアログが開きます 新しいブレークポイント 。 タブを選択します 実行ポイントの設定 。 オプションを有効にする 実行ポイント 。 ボックスに入力します 次のコードを実行します 次のステートメントを入力します。 iCounter := iCounter + 1; ボックスに入力します デバイスログにメッセージを出力します 次のテキストを入力します。 Ausführungspunkt erreicht {iCounter} ダイアログを閉じます。 プログラムが実行ポイントに到達すると、プログラムは停止せず、代わりに上記で定義されたコードを実行します。デバイスログにもメッセージが出力されます。 " }, 
{ "title" : "プログラムの段階的な処理（ステップ） ", 
"url" : "_cds_stepping.html", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ プログラムの段階的な処理（ステップ） ", 
"snippet" : "コード内を移動しながら、アプリケーションを段階的に実行できます。これは、実行時にコードの状態を判断するのに役立ちます。コールフローを調べたり、変数値をトレースしたり、エラーを特定したりできます。 これはあなたがメニューに持っているものです デバッグ 使用可能なステップコマンド。オンライン中にブレークポイントを設定し、ブレークポイントで実行を停止すると、コマンドが使用可能になります。アプリケーションは状態にあります。 血圧を下げる （デバッグモード）。デバッグ中、現在の停止位置は黄色で強調表示され、テキストエディタでは記号で強調表示されます マークされた。 デバッグモードに切り替えます アプリケ...", 
"body" : "コード内を移動しながら、アプリケーションを段階的に実行できます。これは、実行時にコードの状態を判断するのに役立ちます。コールフローを調べたり、変数値をトレースしたり、エラーを特定したりできます。 これはあなたがメニューに持っているものです デバッグ 使用可能なステップコマンド。オンライン中にブレークポイントを設定し、ブレークポイントで実行を停止すると、コマンドが使用可能になります。アプリケーションは状態にあります。 血圧を下げる （デバッグモード）。デバッグ中、現在の停止位置は黄色で強調表示され、テキストエディタでは記号で強調表示されます マークされた。 デバッグモードに切り替えます アプリケーションをコントローラーにロードします。 アプリケーションは緑色でマークされています。 CODESYS プログラミングブロックのエディタはオンラインモードです。 調べたいコードの場所にあるプログラミングブロックにブレークポイントを設定します。 ビューで ブレークポイント すべてリストされています。 アプリケーションを起動します。 アプリケーションが起動し、コードは最初のブレークポイントまで処理されます。 これで、アプリケーションはデバッグモードになります。アプリケーションはデバイスツリーにあります [ブレークポイントで停止] マークされた。ステータス行には、動作ステータスに関する情報が表示されます。 現在の停止位置のエディタが開かれました。プログラムの実行が停止されたアクティブなブレークポイントのあるコード行は、背景が黄色で、アイコンでマークされています マークされた。黄色でマークされたこのステートメントはまだ実行されていません。 これで、さまざまなステップコマンドを選択したり、コールツリーを表示したりできます。 または、最初にアプリケーションを起動してから、ブレークポイントを設定することもできます。 " }, 
{ "title" : "デバッグメニューのステップコマンドの動作 ", 
"url" : "_cds_stepping.html#UUID-a130cd52-c46f-0c6f-6bf8-905f62d6add1_id_b4ea395b460596ffc0a8640e000aa41c_id_228de625e3b1eca0c0a864630c398ee9", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ プログラムの段階的な処理（ステップ） \/ デバッグメニューのステップコマンドの動作 ", 
"snippet" : "デバッグメニューのステップコマンドの動作 指図 手順ステップ （「ステップオーバー」） ホールド位置のステートメントが実行されます。プログラミングブロックの次のステートメントの前に停止があります。 ステートメントに（プログラム、関数ブロックインスタンス、関数、メソッド、またはアクションからの）呼び出しがある場合、従属プログラミングブロックは1つのステップで完全に実行されます。 指図 単一段階 （「ステップイン」） ホールド位置のステートメントが実行されます。次のステートメントの前に停止します。 ステートメントに（プログラム、関数ブロックインスタンス、関数、メソッド、またはアクションからの）呼び...", 
"body" : "デバッグメニューのステップコマンドの動作 指図 手順ステップ （「ステップオーバー」） ホールド位置のステートメントが実行されます。プログラミングブロックの次のステートメントの前に停止があります。 ステートメントに（プログラム、関数ブロックインスタンス、関数、メソッド、またはアクションからの）呼び出しがある場合、従属プログラミングブロックは1つのステップで完全に実行されます。 指図 単一段階 （「ステップイン」） ホールド位置のステートメントが実行されます。次のステートメントの前に停止します。 ステートメントに（プログラム、関数ブロックインスタンス、関数、メソッド、またはアクションからの）呼び出しがある場合、この従属プログラミングブロックにジャンプします。そこで最初の命令が実行され、次の命令の前に停止されます。新しい現在の停止位置は、呼び出されたプログラミングブロックにあります。 指図 実行して戻る （\"踏みでる\"） このコマンドは、プログラミングブロックを現在の停止位置からブロックの終わりまで実行してから、呼び出し元のプログラミングブロックにジャンプして戻ります。通話のポイントで停止します（通話に沿って）。 現在の停止位置がメインプログラムにある場合、プログラミングブロックは最後まで実行されます。次に、最初にジャンプして（プログラミングブロックのコードの最初の行にあるプログラムの最初に）、そこで停止します。 指図 カーソルまで実行 （「カーソルまで実行」） 最初にカーソルをコードの任意の行に置き、次にコマンドを選択します。プログラムは現在のブレークポイントから実行され、その行のコードを実行せずに現在のカーソル位置で停止します。 指図 次のステートメントを設定 （「次のステートメントを設定」） 最初に（現在の停止位置の前であっても）コードの任意の行にカーソルを置き、次にコマンドを選択します。次に、カーソルでマークされたステートメントが実行されます。間にあるすべてのステートメントは無視され、スキップされます。 指図 次のステートメントを表示 （「次のステートメントを表示」） 現在のホールド位置が表示されない場合は、コマンドを選択してください。次に、現在の停止位置のウィンドウがアクティブになり、停止位置が表示されます。 コマンドを選択します 表示→コールスタック 、プログラム処理で現在到達している停止位置の以前の呼び出しツリーを完全に表示します。 景色 コールスタック 常に表示されます。つまり、アプリケーションがコンパイル（コンパイル）される前に、ブロックはプログラムの呼び出し構造内にあります。 " }, 
{ "title" : "変数の強制と書き込み ", 
"url" : "_cds_forcing_values.html", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ 変数の強制と書き込み ", 
"snippet" : "コントローラ上で実行されているアプリケーションで変数値が異常に変化すると、制御対象システムの望ましくない動作が発生する可能性があります。 変数値を強制する前に潜在的な危険性を評価し、適切なセキュリティ対策を講じてください。制御するシステムによっては、システムやワークピースに損傷を与えたり、人の健康や生命を危険にさらしたりする可能性があります。 あなたができる CODESYS オンラインモードでコントローラーの変数の値を変更します。以前に準備された値を強制することと書き込むことは区別されます。 コマンドで書き込みを行います 値を書き込む 、 ctrl + F7 変数を1回準備された値に設定します...", 
"body" : "コントローラ上で実行されているアプリケーションで変数値が異常に変化すると、制御対象システムの望ましくない動作が発生する可能性があります。 変数値を強制する前に潜在的な危険性を評価し、適切なセキュリティ対策を講じてください。制御するシステムによっては、システムやワークピースに損傷を与えたり、人の健康や生命を危険にさらしたりする可能性があります。 あなたができる CODESYS オンラインモードでコントローラーの変数の値を変更します。以前に準備された値を強制することと書き込むことは区別されます。 コマンドで書き込みを行います 値を書き込む 、 ctrl + F7 変数を1回準備された値に設定します。したがって、値はいつでもプログラムによって上書きされる可能性があります。 強制はコマンドで行われます 力の値 、 F7 準備された値を永続的に設定します。詳細については、以下を参照してください。 強制または書き込み用の値の準備は、いくつかの場所で可能です。 宣言部分：フィールド 準備された価値 FBD \/ KOP \/ STLエディターの実装部分：インライン監視フィールド 監視ウィンドウ：フィールド 準備された価値 これを行う方法については、以下を参照してください。すでに強制されている変数の新しい値を準備する場合は、このためのダイアログが開きます 価値を準備する 現在の力の値を処理するためのオプションがあります。 " }, 
{ "title" : "強制の仕組み ", 
"url" : "_cds_forcing_values.html#UUID-59ed096f-57a2-aabb-ce2b-c94426aecfad_id_f9bd4aae088931a8c0a8640e00cc2de4_id_0e7fdcf008c517edc0a8652001320ebf", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ 変数の強制と書き込み \/ 強制の仕組み ", 
"snippet" : "準備された値は、タスクサイクル（または他のタスクタイプの場合は処理ループ）の開始時と終了時に関連する変数に設定されます。 タスクの各サイクルの処理シーケンスは次のとおりです。 入力の読み取り 強制：最初のプログラム呼び出しの前に、準備されたすべての値は、タスクで使用されているかどうかに関係なく、ランタイムシステムによって変数に書き込まれます。 IECコードの処理 強制：最後のプログラム呼び出しの後、タスクで使用されているかどうかに関係なく、準備されたすべての値がランタイムシステムによって変数に書き込まれます。 出力の書き込み 注意：IECコードが割り当てを行っているため、強制変数がサイクルのコ...", 
"body" : "準備された値は、タスクサイクル（または他のタスクタイプの場合は処理ループ）の開始時と終了時に関連する変数に設定されます。 タスクの各サイクルの処理シーケンスは次のとおりです。 入力の読み取り 強制：最初のプログラム呼び出しの前に、準備されたすべての値は、タスクで使用されているかどうかに関係なく、ランタイムシステムによって変数に書き込まれます。 IECコードの処理 強制：最後のプログラム呼び出しの後、タスクで使用されているかどうかに関係なく、準備されたすべての値がランタイムシステムによって変数に書き込まれます。 出力の書き込み 注意：IECコードが割り当てを行っているため、強制変数がサイクルのコード処理中に一時的に異なる値を取得する可能性があります。その後、変数はサイクルの最後にのみ強制値を受け取ります。変数値は、クライアントがアプリケーションのシンボルに書き込むときに、サイクルの途中で上書きすることもできます。この場合、オプションを参照してください IECタスクに同期した可変アクセス の中に プロパティ デバイスオブジェクトの、または設定 IECタスクとの同期を構成する シンボル構成で。これにより、クライアントによる書き込みアクセスと、PLCHandlerでサポートされているタスクサイクルとの同期が可能になります。 強制値は記号でマークされています マークされた。 CODESYS 次のいずれかのアクションを通じて、ユーザーによって明示的に強制が解除されるまで強制を実行します。 コマンドの実行 すべての値を強制解除します ダイアログによる力のキャンセル 価値を準備する アプリケーションからログアウトします ログアウト時に強制変数がまだ存在する場合は、すべての変数の強制をキャンセルするかどうかを尋ねるダイアログが開きます。これを使用する場合 いいえ 答え、次にログインしたときに強制値が再度適用されます。 " }, 
{ "title" : "宣言部分の強制 ", 
"url" : "_cds_forcing_values.html#UUID-59ed096f-57a2-aabb-ce2b-c94426aecfad_id_f9bd4aae088931a8c0a8640e00cc2de4_id_bf7e22b408c5163cc0a865200081e4a1", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ 変数の強制と書き込み \/ 宣言部分の強制 ", 
"snippet" : "要件：アプリケーションに宣言付きのブロックが含まれています。アプリケーションはオンラインモードです。 コマンドを使用してエディターでブロックを開きます プロジェクト→オブジェクトの編集 。 エディターの宣言部分で、列（1）をダブルクリックします。 準備された価値 変数。 フィールドが編集可能になり、値を入力できます。ブール変数の場合は、フィールドをクリックして値を変更します。 その他の変数については、手順2を実行してください。 コマンドを選択します デバッグ→値を強制する 。 変数の値は、準備された値で上書きされます。値は記号付きです マークされた。 ビューで変数の値を表示することもできます ...", 
"body" : "要件：アプリケーションに宣言付きのブロックが含まれています。アプリケーションはオンラインモードです。 コマンドを使用してエディターでブロックを開きます プロジェクト→オブジェクトの編集 。 エディターの宣言部分で、列（1）をダブルクリックします。 準備された価値 変数。 フィールドが編集可能になり、値を入力できます。ブール変数の場合は、フィールドをクリックして値を変更します。 その他の変数については、手順2を実行してください。 コマンドを選択します デバッグ→値を強制する 。 変数の値は、準備された値で上書きされます。値は記号付きです マークされた。 ビューで変数の値を表示することもできます モニター 力 " }, 
{ "title" : "実装部分での強制 ", 
"url" : "_cds_forcing_values.html#UUID-59ed096f-57a2-aabb-ce2b-c94426aecfad_id_f9bd4aae088931a8c0a8640e00cc2de4_id_2f736e9005a0d09ec0a8640e0030151c", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ 変数の強制と書き込み \/ 実装部分での強制 ", 
"snippet" : "要件：アプリケーションはオンラインモードです。 コマンドを使用してエディターでブロックを開きます プロジェクト→オブジェクトの編集 。 エディターの実装部分で、インライン監視フィールド（1）をダブルクリックします。 ダイアログが開きます 値を準備する 。 ボックスに入力します 次の書き込みまたは強制操作のために新しい値を準備します 新しい値を入力します。 準備した値がインラインモニタリングフィールドに表示されます。 コマンドを選択します デバッグ→値を強制する 。 変数の値は、準備された値で上書きされます。値は記号付きです マークされた。...", 
"body" : "要件：アプリケーションはオンラインモードです。 コマンドを使用してエディターでブロックを開きます プロジェクト→オブジェクトの編集 。 エディターの実装部分で、インライン監視フィールド（1）をダブルクリックします。 ダイアログが開きます 値を準備する 。 ボックスに入力します 次の書き込みまたは強制操作のために新しい値を準備します 新しい値を入力します。 準備した値がインラインモニタリングフィールドに表示されます。 コマンドを選択します デバッグ→値を強制する 。 変数の値は、準備された値で上書きされます。値は記号付きです マークされた。 " }, 
{ "title" : "リスト内のすべての強制変数を表示および編集します ", 
"url" : "_cds_forcing_values.html#UUID-59ed096f-57a2-aabb-ce2b-c94426aecfad_id_f9bd4aae088931a8c0a8640e00cc2de4_id_0cd4e3c8f807c8cbc0a8646346df5261", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ 変数の強制と書き込み \/ リスト内のすべての強制変数を表示および編集します ", 
"snippet" : "要件：アプリケーションはオンラインモードです。いくつかの変数が強制状態になっています。 コマンドを選択 表示→監視→すべての力を表示 。 景色 すべての力を表示 が表示されます。これには、現在強制されているアプリケーションのすべての変数がモニターリストの形式で含まれています。 リスト内のすべての行を選択し、ビューの左上にある選択リストから選択します 強制解除→選択したすべての値を強制解除して保持します 。 変数は強制されておらず、強制される前の値が与えられています。...", 
"body" : "要件：アプリケーションはオンラインモードです。いくつかの変数が強制状態になっています。 コマンドを選択 表示→監視→すべての力を表示 。 景色 すべての力を表示 が表示されます。これには、現在強制されているアプリケーションのすべての変数がモニターリストの形式で含まれています。 リスト内のすべての行を選択し、ビューの左上にある選択リストから選択します 強制解除→選択したすべての値を強制解除して保持します 。 変数は強制されておらず、強制される前の値が与えられています。 " }, 
{ "title" : "CFCに機能ブロック入力を強制する ", 
"url" : "_cds_forcing_values.html#UUID-59ed096f-57a2-aabb-ce2b-c94426aecfad_id_f9bd4aae088931a8c0a8640e00cc2de4_id_94214d0432e61124c0a8640e01320552", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ 変数の強制と書き込み \/ CFCに機能ブロック入力を強制する ", 
"snippet" : "要件：CFCプログラムブロックを備えたアプリケーションは、機能ブロックを含み、オフラインモードになっています。 このタイプの強制は、内部でデータブレークポイントを使用し、命令による強制とは異なります。 力の値 また。 F7 区別するために！ コマンドに関する値 FB入力を強制する コマンドに応答しないように強制された すべての力を表示 また すべての値を強制解除します 。 ツリー内のオブジェクトをダブルクリックして、CFCプログラムブロックのエディタを開きます。 ターゲットデバイス上のアプリケーションでログインします。 コンパイラバージョン3.5.11.xまたは3.5.12.xを使用している場...", 
"body" : "要件：CFCプログラムブロックを備えたアプリケーションは、機能ブロックを含み、オフラインモードになっています。 このタイプの強制は、内部でデータブレークポイントを使用し、命令による強制とは異なります。 力の値 また。 F7 区別するために！ コマンドに関する値 FB入力を強制する コマンドに応答しないように強制された すべての力を表示 また すべての値を強制解除します 。 ツリー内のオブジェクトをダブルクリックして、CFCプログラムブロックのエディタを開きます。 ターゲットデバイス上のアプリケーションでログインします。 コンパイラバージョン3.5.11.xまたは3.5.12.xを使用している場合：目的の機能ブロックに対して「強制可能性」をアクティブにします。これを行うには、CFCでブロック要素を選択し、コマンドを選択します CFC→強制用のブロック要素を準備する 。 CFCで、機能ブロックの入力を選択し、コンテキストメニューでコマンドを選択します FB入力を強制する 。 対話 力の値 が表示されます。 入力に新しい値を設定します。 1つの場合の例 TON -ブロック： FALSE ブール入力の場合 IN 、 また t#4s 入り口用 PT （時間）。で確認する わかった 。 設定値はすぐに強制されます。ブロック要素には左上に緑色の円が表示され、要素内の入力の名前は緑色で強調表示されます。ブール値の場合、値を指定した小さな監視ウィンドウも入力に表示されます。宣言部分などの監視ビューでは、強制値が列に表示されます 価値 。 強制値を削除するには、コマンドをもう一度選択してください FB入力を強制する 。対話中 力の値 ここでオプションを選択します 値を削除 。 強制は撤回されます。入力は再びコントローラーから現在の値を受け取ります。 詳細については、以下を参照してください。 力の値 と 値を書き込む" }, 
{ "title" : "アプリケーションのリセットを実行します ", 
"url" : "_cds_reset_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ アプリケーションのリセットを実行します ", 
"snippet" : "アプリケーションをリセットすると、プログラムが停止し、変数が初期化値にリセットされます。リセットのタイプに応じて、保持変数と永続変数もリセットされます。 ウォームリセット：を除くすべての変数 RETAIN - と PERSISTENT -変数がリセットされます。 コールドリセット：を除くすべての変数 PERSISTENT -変数がリセットされます。 原点のリセット：すべての変数がリセットされます。 ソースデバイスのリセット：すべての変数がリセットされ、すべてのアプリケーションが削除されます。 小さなサンプルプログラムと次の手順では、さまざまなリセットの動作について説明しています。 サンプルプロ...", 
"body" : "アプリケーションをリセットすると、プログラムが停止し、変数が初期化値にリセットされます。リセットのタイプに応じて、保持変数と永続変数もリセットされます。 ウォームリセット：を除くすべての変数 RETAIN - と PERSISTENT -変数がリセットされます。 コールドリセット：を除くすべての変数 PERSISTENT -変数がリセットされます。 原点のリセット：すべての変数がリセットされます。 ソースデバイスのリセット：すべての変数がリセットされ、すべてのアプリケーションが削除されます。 小さなサンプルプログラムと次の手順では、さまざまなリセットの動作について説明しています。 サンプルプログラム 宣言 VAR\n iVar: INT := 0;\nEND_VAR\nVAR RETAIN\n iVarRetain: INT :=0;\nEND_VAR\nVAR PERSISTENT\n iVarPersistent : INT:= 0;\nEND_VAR 実装 iVar := 100;\niVarRetain := 200;\niVarPersistent :=300; オブジェクトを貼り付けます 永続変数 アプリケーションの下にあり、エディターで開きます。 コマンドを実行します 作成→翻訳 アウト。 コマンドを実行します 宣言→すべてのインスタンスパスを追加 アウト。 永続変数のインスタンスパスが追加されます。 アプリケーションをコントローラーにロードします。 ウォームリセット、コールドリセット、原点リセットを実行します 要件：サンプルプログラムはコントローラー上で実行されます。 コマンドを選択します オンライン→ログイン オンラインになります。 変数を見る iVar 、 iVarRetain と iVarPersistent 。 の中に オンライン メニュー、クリック リセットウォーム 。 コマンドを本当に実行するかどうかを尋ねるクエリが表示されます。 とのダイアログを確認します はい 。 アプリケーションがリセットされます。変数 iVar 初期化値0に設定されます。他の2つの変数は、それらの値を保持します。 の中に オンライン メニュー、クリック コールドリセット。 コマンドを本当に実行するかどうかを尋ねるクエリが表示されます。 とのダイアログを確認します はい 。 アプリケーションがリセットされます。変数 iVar と iVarRetain 初期化値0に設定されます。変数 iVarPersistent その値を保持します。 の中に オンライン メニュー、クリック 原点をリセット 。 コマンドを本当に実行するかどうかを尋ねるクエリが表示されます。 とのダイアログを確認します はい 。 アプリケーションがリセットされます。すべての変数は初期化値に設定されます。 " }, 
{ "title" : "プロセス制御 ", 
"url" : "_cds_flowcontrol.html", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ プロセス制御 ", 
"snippet" : "フロー制御を使用して、アプリケーションプログラムの処理を追跡できます。フロー制御は、言語エディターST、FUP、KOP、およびCFCで使用できます。 フロー制御がアクティブになっている CODESYS 変数の値は、それぞれの処理位置とそれぞれの処理時間での関数呼び出しと操作の結果を表します。現在のサイクルで実行されるコード行またはネットワークは、正確に色でマークされています。比較のために：標準の監視は CODESYS 2つの処理サイクルの間に変数が持つ値のみ。 フロー制御は、現在開いているエディターウィンドウの現在表示されているすべての部分で機能します。そうすることで プロセス制御がアクティブ...", 
"body" : "フロー制御を使用して、アプリケーションプログラムの処理を追跡できます。フロー制御は、言語エディターST、FUP、KOP、およびCFCで使用できます。 フロー制御がアクティブになっている CODESYS 変数の値は、それぞれの処理位置とそれぞれの処理時間での関数呼び出しと操作の結果を表します。現在のサイクルで実行されるコード行またはネットワークは、正確に色でマークされています。比較のために：標準の監視は CODESYS 2つの処理サイクルの間に変数が持つ値のみ。 フロー制御は、現在開いているエディターウィンドウの現在表示されているすべての部分で機能します。そうすることで プロセス制御がアクティブ化されました 関数がアクティブで、フロー制御位置（コードの渡された部分）がエディターウィンドウに表示されている限り、ステータスバーに表示されます。 宣言部分と実装部分に値を書き込むことができますが、強制することはできません。 値は、現在のサイクルの最後に書き込まれます。 あなたが死んだら プロセス制御 有効にすると、アプリケーションの実行時間が延長されます。 オプションがある場合 オンライン操作の確認 通信設定で有効にすると、プロセス制御をオンにしたときにメッセージボックスが表示され、プロセスをキャンセルするために使用できます。 フロー制御がアクティブになっている場合、ブレークポイントの使用とプログラムの段階的な処理はできません。 さまざまな言語エディターでのプロセス制御の表現： デフォルトでは CODESYS 実行されたコード部分のシーケンス制御位置を緑色のフィールドで表示します。実行されていないコード部分は白で表示されます。 トラバースされていないコード位置の表示値は、「通常の」監視値であることに注意してください。これは、2つのタスクサイクル間の値です。 ネットワークエディタでマーク CODESYS 「フロー制御色」のバーによって左端でトラバースされたネットワーク。 KOPで CODESYS 現在通過している接続線は緑色で表示され、他の接続線は灰色で表示されます。接続の実際の値も表示されます。 TRUE 大胆な青を通して、 FALSE 太字の黒い線、不明な値またはアナログ値、細い黒い線。これは、それぞれの情報を組み合わせることにより、破線につながる可能性があります。 ILで使用 CODESYS 各命令の実際の値を表示するための2つのフィールド。 1つは現在のアキュムレータ値を持つ演算子の左側、もう1つはオペランド値を持つオペランドの右側です。 " }, 
{ "title" : "コールリストを使用して現在の処理位置を特定します ", 
"url" : "_cds_call_stack.html", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ コールリストを使用して現在の処理位置を特定します ", 
"snippet" : "コールリストを使用すると、プログラム実行の現在の位置を判別できます。この関数は、プログラムをステップ実行するときに非常に便利です。 要件：アプリケーションはオンラインモードです。プログラムがブレークポイントにあるか、ステップバイステップで実行しています。 コマンドでコールスタックを開きます 表示→ コールスタック 。 呼び出しスタックが開きます。リストには、完全なコールパスとともに現在到達している位置が表示されます。 コールスタックは、オフラインモードまたは通常のオンラインモード（実際にはデバッグ機能を使用しない）でも使用できます。この場合、ステップ中に表示された最後の位置が含まれますが、「グ...", 
"body" : "コールリストを使用すると、プログラム実行の現在の位置を判別できます。この関数は、プログラムをステップ実行するときに非常に便利です。 要件：アプリケーションはオンラインモードです。プログラムがブレークポイントにあるか、ステップバイステップで実行しています。 コマンドでコールスタックを開きます 表示→ コールスタック 。 呼び出しスタックが開きます。リストには、完全なコールパスとともに現在到達している位置が表示されます。 コールスタックは、オフラインモードまたは通常のオンラインモード（実際にはデバッグ機能を使用しない）でも使用できます。この場合、ステップ中に表示された最後の位置が含まれますが、「グレー表示」フォントで表示されます。 " }, 
{ "title" : "タスクラインナップを確認する ", 
"url" : "_cds_check_task_deployment.html", 
"breadcrumbs" : "CODESYS Essentials \/ テストとトラブルシューティング \/ タスクラインナップを確認する ", 
"snippet" : "タブ タスクラインナップ デバイスエディタの図には、アプリケーションのI \/ Oイメージの個々の入力と出力を処理するタスクの概要と、優先度が表示されます。ここで、意図しない値の上書きが発生していないかどうかを確認できます。これにより、値が未定義になる可能性があります。 アプリケーションのコードを生成します。たとえば、コマンドを選択します ビルド→コードの生成 。 デバイスツリーでデバイスオブジェクトをダブルクリックして、デバイスエディタを開きます。タブを選択します タスクラインナップ 。 アプリケーションの入力と出力、およびタスクとその優先順位の割り当ての表現を取得します。詳細については、タブ...", 
"body" : "タブ タスクラインナップ デバイスエディタの図には、アプリケーションのI \/ Oイメージの個々の入力と出力を処理するタスクの概要と、優先度が表示されます。ここで、意図しない値の上書きが発生していないかどうかを確認できます。これにより、値が未定義になる可能性があります。 アプリケーションのコードを生成します。たとえば、コマンドを選択します ビルド→コードの生成 。 デバイスツリーでデバイスオブジェクトをダブルクリックして、デバイスエディタを開きます。タブを選択します タスクラインナップ 。 アプリケーションの入力と出力、およびタスクとその優先順位の割り当ての表現を取得します。詳細については、タブの説明を参照してください タスクラインナップ 。 " }, 
{ "title" : "実行時のアプリケーション ", 
"url" : "_cds_struct_application_in_operation.html", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション ", 
"snippet" : "アプリケーションがPLCで実行されている場合、 CODESYS -変数値を監視および変更し、それらの履歴を記録および保存するための開発システム機能。 PLCから特定の情報を呼び出したり、PLCログブックを表示したり、コアダンプを表示したり、タスクのタイミングを監視したりするためのオプションもあります。 また、重要なマシン状態で開発システムからのオンラインコマンドを介して実行中のアプリケーションへのアクセスを制限する可能性にも注意してください。これには、ComponentManagerライブラリのブロックを介して特定のシステム変数を使用できます。...", 
"body" : "アプリケーションがPLCで実行されている場合、 CODESYS -変数値を監視および変更し、それらの履歴を記録および保存するための開発システム機能。 PLCから特定の情報を呼び出したり、PLCログブックを表示したり、コアダンプを表示したり、タスクのタイミングを監視したりするためのオプションもあります。 また、重要なマシン状態で開発システムからのオンラインコマンドを介して実行中のアプリケーションへのアクセスを制限する可能性にも注意してください。これには、ComponentManagerライブラリのブロックを介して特定のシステム変数を使用できます。 " }, 
{ "title" : "価値の監視 ", 
"url" : "_cds_f_monitoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ 価値の監視 ", 
"snippet" : "実行時に、プロジェクトのさまざまなポイントでプログラミングオブジェクトの変数の現在の値を監視できます。これを「監視」と呼びます。 オブジェクトのプログラミングエディタのオンラインビュー：「インラインモニタリング」 オブジェクトの宣言エディターのオンラインビュー オブジェクトに依存せず、構成可能 ウォッチリスト 次の場合は、関数呼び出しの結果とプロパティタイプオブジェクトの変数の現在の値を監視できます プラグマ{属性 '監視' ...} 配備。 現在の変数値をキャプチャする追加の方法： からの読み取りと保存 レシピ タイムライン上で値を記録し、すぐにまたは後で履歴を表示します。 トレースとトレン...", 
"body" : "実行時に、プロジェクトのさまざまなポイントでプログラミングオブジェクトの変数の現在の値を監視できます。これを「監視」と呼びます。 オブジェクトのプログラミングエディタのオンラインビュー：「インラインモニタリング」 オブジェクトの宣言エディターのオンラインビュー オブジェクトに依存せず、構成可能 ウォッチリスト 次の場合は、関数呼び出しの結果とプロパティタイプオブジェクトの変数の現在の値を監視できます プラグマ{属性 '監視' ...} 配備。 現在の変数値をキャプチャする追加の方法： からの読み取りと保存 レシピ タイムライン上で値を記録し、すぐにまたは後で履歴を表示します。 トレースとトレンド " }, 
{ "title" : "プログラミングオブジェクトでのコールモニタリング ", 
"url" : "_cds_using_monitoring_in_pous.html", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ 価値の監視 \/ プログラミングオブジェクトでのコールモニタリング ", 
"snippet" : "アプリケーションがコントローラーで実行されている場合、プログラミングブロックのエディターに変数の実際の値が表示されます。これにより、タグ値を監視できます。 要件：で ツール→オプション カテゴリの下で テキストエディタ タブ内 モニタリング オプションです インラインモニタリングを有効にする 起動しました。 コントローラにアプリケーションをロードし、アプリケーションを起動します。 コマンドを選択します デバッグ→外観→10進数 。 実際の値の表示形式が設定されます。 ビューのプログラミングオブジェクトをクリックします 装置 また POU 。 関連するエディターが開きます。変数の実際の値は、宣言...", 
"body" : "アプリケーションがコントローラーで実行されている場合、プログラミングブロックのエディターに変数の実際の値が表示されます。これにより、タグ値を監視できます。 要件：で ツール→オプション カテゴリの下で テキストエディタ タブ内 モニタリング オプションです インラインモニタリングを有効にする 起動しました。 コントローラにアプリケーションをロードし、アプリケーションを起動します。 コマンドを選択します デバッグ→外観→10進数 。 実際の値の表示形式が設定されます。 ビューのプログラミングオブジェクトをクリックします 装置 また POU 。 関連するエディターが開きます。変数の実際の値は、宣言と実装の両方で常に更新されます。 関数呼び出しの戻り値を監視する POUのSTエディターでは、関数が呼び出された時点で、現在の戻り値がインラインモニタリングとして表示されます。 このためには、次の条件を満たす必要があります。 これは、4バイトの数値として解釈できる値です。例えば INT 、 SINT また LINT 。 関数にはプラグマがあります {attribute 'monitoring' := 'call'} 挿入されました。 " }, 
{ "title" : "宣言エディタで監視する ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_da1e73000e6d11e49893a65c94288ced", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ 価値の監視 \/ プログラミングオブジェクトでのコールモニタリング \/ 宣言エディタで監視する ", 
"snippet" : "式（1）の実際の値は、列に示されています。 価値 （3）が表示されます。 変数に関するコメントは、に表示されます [コメント] コラム (6)。 表示されるコメントのロジックと優先順位の詳細については、以下を参照してください。 STコメントあなたはコラムでそれを見つけることができます 準備された価値 （4）入力した値を書き込んで強制します。強制中、実際の値は赤い記号でマークされます 飾られた。 インターフェイス参照のプリントアウトは拡張できます。インターフェイスがグローバルインスタンスを指している場合、そのグローバルインスタンスは参照の下の最初のエントリとして表示されます。その後、インターフェ...", 
"body" : "式（1）の実際の値は、列に示されています。 価値 （3）が表示されます。 変数に関するコメントは、に表示されます [コメント] コラム (6)。 表示されるコメントのロジックと優先順位の詳細については、以下を参照してください。 STコメントあなたはコラムでそれを見つけることができます 準備された価値 （4）入力した値を書き込んで強制します。強制中、実際の値は赤い記号でマークされます 飾られた。 インターフェイス参照のプリントアウトは拡張できます。インターフェイスがグローバルインスタンスを指している場合、そのグローバルインスタンスは参照の下の最初のエントリとして表示されます。その後、インターフェイス参照が変更されると、表示されている参照が折りたたまれます。 " }, 
{ "title" : "実装の監視（インライン監視） ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_cf62c2c62f969db9c0a8646339d800c9", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ 価値の監視 \/ プログラミングオブジェクトでのコールモニタリング \/ 実装の監視（インライン監視） ", 
"snippet" : "実装における現在の変数値の表現は、インライン監視と呼ばれます。 プログラミング言語に応じて、実装部分には次の表現があります。 変数には、名前の後ろに現在の値が表示されたウィンドウがあります 表示されます。 変数の強制または書き込み用の値を準備している場合、これらはインライン監視ウィンドウ内の現在の値の後に山かっこで囲まれて表示されます。 強制した後、影響を受ける値は記号でマークされます マークされた。 ネットワークエディタとCFCエディタ 接続線（信号線）は、実際のブール値に従って色分けされています。青は TRUE 、は黒を意味します FALSE 。 ラダーエディタ さらに、接点要素とコイル要...", 
"body" : "実装における現在の変数値の表現は、インライン監視と呼ばれます。 プログラミング言語に応じて、実装部分には次の表現があります。 変数には、名前の後ろに現在の値が表示されたウィンドウがあります 表示されます。 変数の強制または書き込み用の値を準備している場合、これらはインライン監視ウィンドウ内の現在の値の後に山かっこで囲まれて表示されます。 強制した後、影響を受ける値は記号でマークされます マークされた。 ネットワークエディタとCFCエディタ 接続線（信号線）は、実際のブール値に従って色分けされています。青は TRUE 、は黒を意味します FALSE 。 ラダーエディタ さらに、接点要素とコイル要素がマークされています。 接点またはコイルの場合、準備された値（ TRUE また FALSE ）アイテムの横にある小さなウィンドウ。 ASエディター 値のある遷移 TRUE ブール値の実際の値に従って色分けされています：青は TRUE 、は黒を意味します FALSE 。 アクティブなステップは青色でマークされています。 実装では、強制遷移値は赤でマークされています。 ILテーブルエディタ 現在の値は別の列に表示されます。 STエディターでの監視 LDエディターでの監視 ASエディターでの監視 ここでインライン監視機能を無効にできます。 ツール→オプション 、 カテゴリー テキストエディタ 、 タブ モニタリング 。 " }, 
{ "title" : "アレイを部分的に監視する ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_17c4ba57134411e497a3a811bc4d899a", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ 価値の監視 \/ プログラミングオブジェクトでのコールモニタリング \/ アレイを部分的に監視する ", 
"snippet" : "展開された配列は、最大1000要素の実際の値を示します。ただし、これは混乱を招く可能性があります。また、配列には1000を超える要素を含めることができます。次に、表示されるアイテムの範囲を制限すると便利です。これは、オンライン中に次の方法で実行できます。 監視エリアを制限する 要件：アプリケーションが実行されている。 1000を超える要素を持つ多次元配列変数が宣言されています。 例： arrBig : ARRAY [0..100, -9..10, -19..20] OF INT; 変数をクリックします arrBig 列のフィールドで データ・タイプ 。 対話 監視エリア 開きます。 送信 始め...", 
"body" : "展開された配列は、最大1000要素の実際の値を示します。ただし、これは混乱を招く可能性があります。また、配列には1000を超える要素を含めることができます。次に、表示されるアイテムの範囲を制限すると便利です。これは、オンライン中に次の方法で実行できます。 監視エリアを制限する 要件：アプリケーションが実行されている。 1000を超える要素を持つ多次元配列変数が宣言されています。 例： arrBig : ARRAY [0..100, -9..10, -19..20] OF INT; 変数をクリックします arrBig 列のフィールドで データ・タイプ 。 対話 監視エリア 開きます。 送信 始める 値 [1, -9, -19] 1。 送信 終わり 値 [1, 10, 20] 1。 800個の配列要素の実際の値が宣言エディターに表示されます。スコープはインデックスの要素に限定されます [1, <i>, <j>] iは-9から10、jは-19から20です。 " }, 
{ "title" : "モニタ汎用モジュール ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_cc4f35463a9211e9a9a6d1f408c21742", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ 価値の監視 \/ プログラミングオブジェクトでのコールモニタリング \/ モニタ汎用モジュール ", 
"snippet" : "オンライン操作中に汎用ブロックのエディタビューをダブルクリックすると、基本実装のビューまたは特定のインスタンスのいずれかを選択できるダイアログが表示されます。 基本的な実装を選択した場合、コードは現在の値が表示されずにエディターに表示されます。次に、基本実装にブレークポイントを設定します。そこで実行が停止すると、プログラムフローで最初に処理されたインスタンスの現在の値が表示されます。これで、すべてのインスタンスを連続してステップスルーできます。 インスタンスの1つを選択すると、汎用ブロックインスタンスのコードでエディタが開きます。現在の値は、宣言と、必要に応じて実装に表示され、常に更新されます...", 
"body" : "オンライン操作中に汎用ブロックのエディタビューをダブルクリックすると、基本実装のビューまたは特定のインスタンスのいずれかを選択できるダイアログが表示されます。 基本的な実装を選択した場合、コードは現在の値が表示されずにエディターに表示されます。次に、基本実装にブレークポイントを設定します。そこで実行が停止すると、プログラムフローで最初に処理されたインスタンスの現在の値が表示されます。これで、すべてのインスタンスを連続してステップスルーできます。 インスタンスの1つを選択すると、汎用ブロックインスタンスのコードでエディタが開きます。現在の値は、宣言と、必要に応じて実装に表示され、常に更新されます。 " }, 
{ "title" : "プロパティを監視する ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_089ce320132311e497a3a811bc4d899a", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ 価値の監視 \/ プログラミングオブジェクトでのコールモニタリング \/ プロパティを監視する ", 
"snippet" : "プロパティオブジェクトでできます オンライン中に関数にブレークポイントを設定するときに変数を監視します。そこで停止すると、現在の値が表示されます。 独自の値に加えて、上位レベルのインスタンスの変数の値が自動的に表示されます。プロパティの宣言部分の最初の行にポインタが表示されます THIS 、現在のデータ型の仕様と値を持つ親インスタンスを指します。 例 コード FUNCTION_BLOCK FB_BaseAlfa VAR iBaseLocal : INT; sBaseLocal : STRING; END_VAR iBaseLocal := iBaseLocal + 1; sBaseLocal ...", 
"body" : "プロパティオブジェクトでできます オンライン中に関数にブレークポイントを設定するときに変数を監視します。そこで停止すると、現在の値が表示されます。 独自の値に加えて、上位レベルのインスタンスの変数の値が自動的に表示されます。プロパティの宣言部分の最初の行にポインタが表示されます THIS 、現在のデータ型の仕様と値を持つ親インスタンスを指します。 例 コード FUNCTION_BLOCK FB_BaseAlfa\nVAR\n iBaseLocal : INT;\n sBaseLocal : STRING;\nEND_VAR\niBaseLocal := iBaseLocal + 1;\nsBaseLocal := 'Testing Text';\n\nFB_BaseAlfa.PorpBeta.Get\niBaseLocal := iBaseLocal + 1;\nIF iBaseLocal > 0 THEN\n PropBeta := TRUE;\nEND_IF\n\nFB_BaseAlfa.PorpBeta.Set\nIF PropBeta = TRUE THEN\n iBaseLocal := 0;\n sBaseLocal := 'Tested IF';\nEND_IF\n\n\nPROGRAM PLC_PRG\nVAR\n fb_BaseAlfa : FB_BaseAlfa;\nEND_VAR\n\nfb_BaseAlfa();\n\nIF fb_BaseAlfa.PropBeta = TRUE THEN\n xResult := TRUE;\nEND_IF\nIF xReset THEN\n fb_BaseAlfa.PropBeta := TRUE;\n xReset := FALSE;\nEND_IF " }, 
{ "title" : "親プログラミングオブジェクトのプロパティアクセスを監視する ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_4c0f3a123aa211e9a9a6d1f408c21742", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ 価値の監視 \/ プログラミングオブジェクトでのコールモニタリング \/ 親プログラミングオブジェクトのプロパティアクセスを監視する ", 
"snippet" : "変数値に加えて、機能ブロックまたはプログラムで従属プロパティの値を使用することもできます モニター。 これを行うには、宣言の子プロパティオブジェクトに、いずれかのプラグマを追加します {attribute 'monitoring' = 'variable'} またはプラグマ {attribute 'monitoring' = 'call'} 1。実行時に上位レベルのプログラムインスタンスまたは上位レベルの関数ブロックインスタンスを開くと、現在のタグ値に加えて、現在のプロパティ値がエディターに表示されます。...", 
"body" : "変数値に加えて、機能ブロックまたはプログラムで従属プロパティの値を使用することもできます モニター。 これを行うには、宣言の子プロパティオブジェクトに、いずれかのプラグマを追加します {attribute 'monitoring' = 'variable'} またはプラグマ {attribute 'monitoring' = 'call'} 1。実行時に上位レベルのプログラムインスタンスまたは上位レベルの関数ブロックインスタンスを開くと、現在のタグ値に加えて、現在のプロパティ値がエディターに表示されます。 " }, 
{ "title" : "監視方法 ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_86a261815e598a34c0a8640e0001140c", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ 価値の監視 \/ プログラミングオブジェクトでのコールモニタリング \/ 監視方法 ", 
"snippet" : "メソッドオブジェクトでできます オンライン中にメソッドにブレークポイントを設定するときに変数を監視します。そこで停止すると、現在の値が表示されます。 独自の値に加えて、上位レベルのインスタンスの変数の値が自動的に表示されます。メソッドの宣言部分の最初の行にポインタが表示されます THIS 、現在のデータ型の仕様と値を持つ親インスタンスを指します。 例 コード FUNCTION_BLOCK FB_BaseAlfa VAR iBaseLocal : INT; sBaseLocal : STRING; END_VAR iBaseLocal := iBaseLocal + 1; sBaseLocal ...", 
"body" : "メソッドオブジェクトでできます オンライン中にメソッドにブレークポイントを設定するときに変数を監視します。そこで停止すると、現在の値が表示されます。 独自の値に加えて、上位レベルのインスタンスの変数の値が自動的に表示されます。メソッドの宣言部分の最初の行にポインタが表示されます THIS 、現在のデータ型の仕様と値を持つ親インスタンスを指します。 例 コード FUNCTION_BLOCK FB_BaseAlfa\nVAR\n iBaseLocal : INT;\n sBaseLocal : STRING;\nEND_VAR\niBaseLocal := iBaseLocal + 1;\nsBaseLocal := 'Testing Text';\n\nMETHOD MethBaseAlfa : BOOL \/\/ Method of FB_BaseAlfa\nVAR_INPUT\nEND_VAR\nVAR\n iMethLocal : INT;\nEND_VAR\niMethLocal := iMethLocal + 1;\n\n\nPROGRAM PLC_PRG\nVAR\n fb_BaseAlfa : FB_BaseAlfa;\nEND_VAR\nfb_BaseAlfa();\nfb_BaseAlfa.MethBaseAlfa(); " }, 
{ "title" : "モニター機能 ", 
"url" : "_cds_using_monitoring_in_pous.html#UUID-3a1a82bb-5504-b24e-e93d-229945836c51_id_d1abe86e9b7ec4c0a8640e00062d91_id_ae89ec4d3f3d11e9beb58b29d367590b", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ 価値の監視 \/ プログラミングオブジェクトでのコールモニタリング \/ モニター機能 ", 
"snippet" : "オンライン中に関数にブレークポイントを設定すると、関数オブジェクトの変数を監視できます。そこで停止すると、現在の値が表示されます。...", 
"body" : "オンライン中に関数にブレークポイントを設定すると、関数オブジェクトの変数を監視できます。そこで停止すると、現在の値が表示されます。 " }, 
{ "title" : "ウォッチリストを使用する ", 
"url" : "_cds_using_watchlists.html", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ 価値の監視 \/ ウォッチリストを使用する ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "ウォッチリストとは何ですか？ ", 
"url" : "_cds_using_watchlists.html#UUID-aa48d044-1dcc-85b4-3abf-5972dd8036a1_id_a81a96006e9d8726c0a8640e01e78912_id_952107db6cf010acc0a8640e01262d4f", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ 価値の監視 \/ ウォッチリストを使用する \/ ウォッチリストとは何ですか？ ", 
"snippet" : "ウォッチリストは、値を監視する目的で1つのビューに結合されるプロジェクト変数のユーザー定義リストです。オンラインの場合、ウォッチリストに変数値を書き込んで強制することができます。監視、書き込み、および強制は次のとおりです。 申告エディタのオンライン操作 処理する。浮動小数点値の表現の形式を変更することができます 監視オプション 調整。 プロジェクトには4つの監視リストがあります Überwachen <n> メニューで 表示→監視 充填の準備ができました。 式がインターフェイス参照の場合、折りたたみ可能です。インターフェイスがグローバルインスタンスを指している場合、このグローバルインスタンスは...", 
"body" : "ウォッチリストは、値を監視する目的で1つのビューに結合されるプロジェクト変数のユーザー定義リストです。オンラインの場合、ウォッチリストに変数値を書き込んで強制することができます。監視、書き込み、および強制は次のとおりです。 申告エディタのオンライン操作 処理する。浮動小数点値の表現の形式を変更することができます 監視オプション 調整。 プロジェクトには4つの監視リストがあります Überwachen <n> メニューで 表示→監視 充填の準備ができました。 式がインターフェイス参照の場合、折りたたみ可能です。インターフェイスがグローバルインスタンスを指している場合、このグローバルインスタンスは参照の下の最初のエントリとして表示されます。インターフェイス参照が変更されると、表示されている参照は折りたたまれます。 " }, 
{ "title" : "監視リストの作成と編集（オフラインまたはオンライン操作） ", 
"url" : "_cds_using_watchlists.html#UUID-aa48d044-1dcc-85b4-3abf-5972dd8036a1_id_a81a96006e9d8726c0a8640e01e78912_id_706184106cf010aec0a8640e01576f72", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ 価値の監視 \/ ウォッチリストを使用する \/ 監視リストの作成と編集（オフラインまたはオンライン操作） ", 
"snippet" : "要件：プロジェクトはオフラインモードまたはオンラインモードで開かれています。これには、4つの可能なウォッチリストのいずれかで必要な変数を宣言するアプリケーションが含まれています。 コマンドを選択します 表示→モニター→モニター<n> 。 景色 Überwachen <n> が表示されます。空のテーブル行が含まれています。 フィールドをダブルクリックした後、列を入力します 表現 手動または入力ヘルプを使用して監視する変数。 構文：<デバイス名>。<アプリケーション名>。<オブジェクト名>。<変数名> 例： \" Dev1.App1.PLC_PRG.ivar 「」 構造化変数の名前を入力すると、個々...", 
"body" : "要件：プロジェクトはオフラインモードまたはオンラインモードで開かれています。これには、4つの可能なウォッチリストのいずれかで必要な変数を宣言するアプリケーションが含まれています。 コマンドを選択します 表示→モニター→モニター<n> 。 景色 Überwachen <n> が表示されます。空のテーブル行が含まれています。 フィールドをダブルクリックした後、列を入力します 表現 手動または入力ヘルプを使用して監視する変数。 構文：<デバイス名>。<アプリケーション名>。<オブジェクト名>。<変数名> 例： \" Dev1.App1.PLC_PRG.ivar 「」 構造化変数の名前を入力すると、個々のコンポーネントがオンラインモードで追加の行に自動的に表示されます。 このリストで監視するすべての変数を1つずつ定義します。ドラッグアンドドロップで順序を変更できます。 フィールド 実行時間 、 データ・タイプ 、 住所 、 コメント 変数宣言に従って自動的に入力されます。印刷物の前の記号は、それが 入力変数、 出力変数または 「通常の」変数が機能します。 オンラインモードでは、コンテキストメニューコマンドを使用して監視リストを開くこともできます 気に入ったリストに追加する 新しいものを作成するか、既存のものを編集します。 " }, 
{ "title" : "[ウォッチリストに追加]コマンドを使用した変数の追加（オンライン操作） ", 
"url" : "_cds_using_watchlists.html#UUID-aa48d044-1dcc-85b4-3abf-5972dd8036a1_id_a81a96006e9d8726c0a8640e01e78912_id_efc074136cf010afc0a8640e01cc70f3", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ 価値の監視 \/ ウォッチリストを使用する \/ [ウォッチリストに追加]コマンドを使用した変数の追加（オンライン操作） ", 
"snippet" : "要件：プロジェクトは運用中に開いています。これには、ウォッチリストに含めることを宣言した変数がすでにあるアプリケーションが含まれています。 コマンドで目的のウォッチリストを開く 表示→モニター<n> 。 POUの宣言または実装部分の変数にカーソルを置き、コンテキストメニューからコマンドを選択します 気に入ったリストに追加する 。 選択した変数のエントリがリストに追加されます。 この方法で、またはフィールドのリストに変数を入力することにより、変数をさらに追加できます。 表現 、上記のように（「作成および編集...」）。 ウォッチリストはすぐに更新されます。 コマンドの実行中にウォッチリストが開い...", 
"body" : "要件：プロジェクトは運用中に開いています。これには、ウォッチリストに含めることを宣言した変数がすでにあるアプリケーションが含まれています。 コマンドで目的のウォッチリストを開く 表示→モニター<n> 。 POUの宣言または実装部分の変数にカーソルを置き、コンテキストメニューからコマンドを選択します 気に入ったリストに追加する 。 選択した変数のエントリがリストに追加されます。 この方法で、またはフィールドのリストに変数を入力することにより、変数をさらに追加できます。 表現 、上記のように（「作成および編集...」）。 ウォッチリストはすぐに更新されます。 コマンドの実行中にウォッチリストが開いていない場合 気に入ったリストに追加する 変数に適用すると、自動的にリストに追加されます モニター1 追加した。 変数値の書き込みと強制は、監視リストでも可能です。この列はオンラインモードで表示されます 準備された価値 。 " }, 
{ "title" : "トレースによるデータ取得 ", 
"url" : "_cds_f_data_acquiring_with_trace.html", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ トレースによるデータ取得 ", 
"snippet" : "要件: CODESYS Trace パッケージがインストールされています。 を使用できます 痕跡 デジタル サンプリング オシロスコープと同様の方法で、コントローラー上の変数の値曲線を追跡します。データとその履歴はトレースエディタに表示できます。 詳細については、以下を参照してください。 CODESYS トレース...", 
"body" : "要件: CODESYS Trace パッケージがインストールされています。 を使用できます 痕跡 デジタル サンプリング オシロスコープと同様の方法で、コントローラー上の変数の値曲線を追跡します。データとその履歴はトレースエディタに表示できます。 詳細については、以下を参照してください。 CODESYS トレース " }, 
{ "title" : "タスクを監視する ", 
"url" : "_cds_monitoring_running_tasks.html", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ タスクを監視する ", 
"snippet" : "オンラインモードでは、ランタイムシステムのタスクのいくつかの統計値を表示できます。この情報は、サイクルタイムやタイミングの問題を調査するときに非常に役立ちます。 オンライン化する。 を選択 タスク構成 デバイスツリー内。 コマンドを選択します プロジェクト→オブジェクトの編集 。 タスク構成がエディターで開かれます。 タブを選択 モニタリング ....", 
"body" : "オンラインモードでは、ランタイムシステムのタスクのいくつかの統計値を表示できます。この情報は、サイクルタイムやタイミングの問題を調査するときに非常に役立ちます。 オンライン化する。 を選択 タスク構成 デバイスツリー内。 コマンドを選択します プロジェクト→オブジェクトの編集 。 タスク構成がエディターで開かれます。 タブを選択 モニタリング . " }, 
{ "title" : "PLCのログを読む ", 
"url" : "_cds_reading_plc_log.html", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ PLCのログを読む ", 
"snippet" : "CODESYS コントローラに記録されたイベントとエラーメッセージを表示するオプションを提供します。 航海日誌を読む 要件：コントローラーが実行されている。 デバイスツリーでコントローラーを選択します。 コマンドを選択します プロジェクト→オブジェクトの編集 。 デバイスエディタが開きます。 タブを選択します ログ 。 クリック ボタンを押してビューを更新します。 コントローラへの接続が確立されます。コントローラーのデバイスツリーの背景は緑色です。 コントローラのすべてのログイベントが表示されます。付加されたアイコンは、ログイベントの重大度を示します。 ： 警告 ： エラー ： 例外 ： 情報...", 
"body" : "CODESYS コントローラに記録されたイベントとエラーメッセージを表示するオプションを提供します。 航海日誌を読む 要件：コントローラーが実行されている。 デバイスツリーでコントローラーを選択します。 コマンドを選択します プロジェクト→オブジェクトの編集 。 デバイスエディタが開きます。 タブを選択します ログ 。 クリック ボタンを押してビューを更新します。 コントローラへの接続が確立されます。コントローラーのデバイスツリーの背景は緑色です。 コントローラのすべてのログイベントが表示されます。付加されたアイコンは、ログイベントの重大度を示します。 ： 警告 ： エラー ： 例外 ： 情報 ：デバッグ 特定の重大度のイベントを表示したくない場合は、メニューバーの対応するアイコンをクリックします。このアイコンをもう一度クリックすると、これらのログイベントが再度表示されます。たとえば、 「エラー」の重大度のログイベントを表示したくない場合は、メニューバーのアイコン。 の中に メッセージを検索する 入力フィールドで、リスト内の特定のイベントを検索するための検索語を指定します。次に、を使用できます と 色分けされた検索結果にジャンプするボタン。 イベントをフィルタリングするには 重大度 、 タイムスタンプ 、 説明 、 また 成分 、それぞれの列のタイトルをクリックします。 クリック 表示されたログイベントをファイルに保存するためのボタン。 " }, 
{ "title" : "SPSシェルを使用して情報を照会する ", 
"url" : "_cds_querying_information_via_plc_shell.html", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ SPSシェルを使用して情報を照会する ", 
"snippet" : "の「SPSシェル」 CODESYS デバイスエディタタブのテキストベースのコントロールモニターです。ここでコマンドを入力して、特定の情報を照会し、アプリケーションの開始、停止、ロードなどのアクションを実行できます。 PLCシェルから直接可能なコマンドの意味と構文の説明を呼び出すこともできます。 可能なコマンドはメーカーによって異なります。コマンドの範囲は、いわゆる SPS Shell Command Handler ランタイムシステムのCコンポーネント、またはIECライブラリまたはプロジェクトの機能ブロックとして。 PLCからの応答は、結果ウィンドウの文字列としてタブに表示されます。 コントロ...", 
"body" : "の「SPSシェル」 CODESYS デバイスエディタタブのテキストベースのコントロールモニターです。ここでコマンドを入力して、特定の情報を照会し、アプリケーションの開始、停止、ロードなどのアクションを実行できます。 PLCシェルから直接可能なコマンドの意味と構文の説明を呼び出すこともできます。 可能なコマンドはメーカーによって異なります。コマンドの範囲は、いわゆる SPS Shell Command Handler ランタイムシステムのCコンポーネント、またはIECライブラリまたはプロジェクトの機能ブロックとして。 PLCからの応答は、結果ウィンドウの文字列としてタブに表示されます。 コントローラ上のアプリケーションに関する情報のクエリ 要件：プロジェクトがコントローラーに接続されている。例 CODESYS Control Win 、その上でアプリケーション App1 ランニング。 オブジェクトをダブルクリックしてデバイスエディタを開きます CODESYS Control Win デバイスツリーでタブを選択します SPSシェル 。 タブが空白の表示ウィンドウで表示されます。以下に、コマンドの入力行があります。 ボタンをクリックします 。 対話 標準コマンドを入力してください コマンドのリストとともに表示されます。 コマンドを選択します ？ ボタンをクリックします 走る 。 ダイアログが閉じ、使用可能なコマンドと可能なパラメーターのリストが出力ウィンドウに表示されます。コマンド入力の構文を示しています。 もう一度クリック コマンドを選択します pid 。入力行に以下を追加します。 pid App1 。 Enterキーを押します。 出力ウィンドウに次のように表示されます（例としてのみGUID）。 pid App1 Project Identification Applikation: App1 Code GUID:0x08a893c0 Data GUID:0x762d0e90 ボタンを押す コマンドラインで。 コマンド pid App1 入力したコマンドの履歴に記録されます。 " }, 
{ "title" : "システム変数によるPLC動作制御 ", 
"url" : "_cds_operation_control_via_system_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ システム変数によるPLC動作制御 ", 
"snippet" : "ランタイムシステムサービスが安全なアプリケーション状態でアクティブ化され、重要な状態でのみ非アクティブ化されるようにするのはユーザーの責任です。 システムまたはアプリケーションは、実行時に機密性の高い状態に入る可能性があり、その場合、妨害行為がマシンまたはシステム全体を危険にさらす可能性があります。ただし、この状態では、特定のコマンドを抑制し、危険なアクションを防ぐことができます。汎用モジュールはこのために利用可能です PlcOperationControl 図書館 コンポーネントマネージャー 処分する。 の例 CODESYS -実行を抑制できるコマンド： オンライン変更 、 ダウンロード ブ...", 
"body" : "ランタイムシステムサービスが安全なアプリケーション状態でアクティブ化され、重要な状態でのみ非アクティブ化されるようにするのはユーザーの責任です。 システムまたはアプリケーションは、実行時に機密性の高い状態に入る可能性があり、その場合、妨害行為がマシンまたはシステム全体を危険にさらす可能性があります。ただし、この状態では、特定のコマンドを抑制し、危険なアクションを防ぐことができます。汎用モジュールはこのために利用可能です PlcOperationControl 図書館 コンポーネントマネージャー 処分する。 の例 CODESYS -実行を抑制できるコマンド： オンライン変更 、 ダウンロード ブレークポイントを有効にする アプリケーションのリセット 、 アプリケーション停止 ファイル転送 力の値 、 値を書き込む ザル オリジンデバイスをリセット コマンドを非アクティブ化できないため、ランタイムシステムから完全にロックアウトすることはできません。このコマンドは、重要な操作がすべて無効になっている完全にロックされたランタイムシステムを開くための最後の選択肢です。このコマンドにはデバイスユーザー管理における拡張権限が必要なため、通常はこの方法でも問題ありません アプリケーションの実行時にランタイムシステムサービスが要求されたが、現在非アクティブ化されている場合は、 CODESYS それについてのメッセージ。その後、適切な対策を講じることができます。 " }, 
{ "title" : "運転制御用機能ブロックPlcOperationControl ", 
"url" : "_cds_operation_control_via_system_variables.html#UUID-b0a8d090-cd03-6673-0ff7-b90ce6118e6a_id_cf02989893c0a8640e0164e374_id_0f29fd87c71811e4be8af5413b027a7b", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ システム変数によるPLC動作制御 \/ 運転制御用機能ブロックPlcOperationControl ", 
"snippet" : "機能ブロックは、操作を有効化および無効化するために使用されます。 財産 姓 データ・タイプ 初期値 説明 xDisableApplicationOnlineChange BOOL FALSE TRUE ：オンライン変更は抑制されます xDisableApplicationDownload BOOL FALSE TRUE ：ダウンロードが抑制されます xDisableApplicationStop BOOL FALSE TRUE ：アプリケーション停止が抑制されます xDisableApplicationBP BOOL FALSE TRUE ：ブレークポイントの設定は抑制されます xDisabl...", 
"body" : "機能ブロックは、操作を有効化および無効化するために使用されます。 財産 姓 データ・タイプ 初期値 説明 xDisableApplicationOnlineChange BOOL FALSE TRUE ：オンライン変更は抑制されます xDisableApplicationDownload BOOL FALSE TRUE ：ダウンロードが抑制されます xDisableApplicationStop BOOL FALSE TRUE ：アプリケーション停止が抑制されます xDisableApplicationBP BOOL FALSE TRUE ：ブレークポイントの設定は抑制されます xDisableApplicationWrite BOOL FALSE TRUE ：変数の書き込みが抑制されます PLCHandler \/ IecVarAccessを介して抑制することもできます。 xDisableApplicationForce BOOL FALSE TRUE ：変数の強制が抑制されます xDisableApplicationReset BOOL FALSE TRUE ：アプリケーションのリセット（「原点のリセット」ではありません！）が抑制されます xDisableAll BOOL FALSE TRUE ：すべての操作が抑制されます " }, 
{ "title" : "運用管理の実施 ", 
"url" : "_cds_operation_control_via_system_variables.html#UUID-b0a8d090-cd03-6673-0ff7-b90ce6118e6a_id_cf02989893c0a8640e0164e374_id_695396c9235ca019c0a8640e003317ec", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ システム変数によるPLC動作制御 \/ 運用管理の実施 ", 
"snippet" : "要件 コンパイラバージョン 3.4.3.0 システム変数によるPLC動作制御は、デバイスの説明でアクティブになります。 関数ブロックのインスタンスを宣言します PlcOperationControl 、 例えば PlcOpCtrl_Inst 。 PlcOpCtrl_Inst : PlcOperationControl; プロパティを使用してコマンドを抑制します TRUE たとえば、「アプリケーションの停止」を割り当てます。 PlcOpCtrl_Inst.xDIsableApplicationStop := TRUE;...", 
"body" : "要件 コンパイラバージョン 3.4.3.0 システム変数によるPLC動作制御は、デバイスの説明でアクティブになります。 関数ブロックのインスタンスを宣言します PlcOperationControl 、 例えば PlcOpCtrl_Inst 。 PlcOpCtrl_Inst : PlcOperationControl; プロパティを使用してコマンドを抑制します TRUE たとえば、「アプリケーションの停止」を割り当てます。 PlcOpCtrl_Inst.xDIsableApplicationStop := TRUE; " }, 
{ "title" : "保存して回復する ", 
"url" : "_cds_restoring_applications_and_rts.html", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ 保存して回復する ", 
"snippet" : "CODESYS そしてその CODESYS -バージョン3.5.8.0以降の標準ランタイムシステムは、PLC上のアプリケーション固有のファイルの「バックアップ」をサポートします。タブで必要なアクションを実行できます 保存して回復する 汎用デバイスエディタの。 保存とは、アプリケーション関連のファイルと情報ファイルを含むZIP形式のファイルを作成して保存することです。 meta.info が含まれています。このバックアップファイルの拡張子は TBF （= \"ターゲットバックアップファイル\"）そしてローカルファイルシステムまたはPLCに保存することができます。 バックアップファイルからソフトウェア...", 
"body" : "CODESYS そしてその CODESYS -バージョン3.5.8.0以降の標準ランタイムシステムは、PLC上のアプリケーション固有のファイルの「バックアップ」をサポートします。タブで必要なアクションを実行できます 保存して回復する 汎用デバイスエディタの。 保存とは、アプリケーション関連のファイルと情報ファイルを含むZIP形式のファイルを作成して保存することです。 meta.info が含まれています。このバックアップファイルの拡張子は TBF （= \"ターゲットバックアップファイル\"）そしてローカルファイルシステムまたはPLCに保存することができます。 バックアップファイルからソフトウェアステータスを復元する場合は、次のようになります。 SPSで影響を受けるファイルのリストを取得し、オプションのコンポーネントを無効にすることができます。 バックアップまたは復元のためにアプリケーションをSTOP状態にする必要がある場合は、そのことが通知されます。非互換性がある場合にもメッセージが表示されます。 PLCでの復元中、ユーザーインターフェイスはロックされます。 既存のファイルは確認なしで上書きされます。 少なくとも1つの新しいブートアプリケーションがリカバリの一部になるとすぐに、既存のブートアプリケーションは無効になります。 バックアップファイルから復元する 要件：使用するデバイスで実行されるアプリケーションを使用してプロジェクトを開いている必要があります。上記のように、バックアップファイルをローカルファイルシステムに保存しました。 デバイスツリーのデバイスエントリをダブルクリックして、デバイスエディタを開きます。タブを選択します 保存して復元 。 コマンドを選択します 復元→ディスクからバックアップファイルをロード 。 を選択するためのデフォルトのブラウザ tbf -バックアップファイルがローカルファイルシステムに表示されます。 バックアップファイルを選択し、で確認します 開ける 。 ファイルはバックアップファイルから読み取られ、ダイアログの次の表に表示されます。バックアップ中に除外されたファイルが欠落しています $PlcLogic$\/Application\/myExternalFile.txt 。 コマンドを選択します 復元→デバイスに復元 。 復元アクションに関する情報を示すプロンプトが表示されます。 で確認する わかった SPSファイルシステム内のファイルの復元を開始します。 復元が完了すると、新しくインポートされたアプリケーションをアクティブ化するためにPLCを再起動するように求められます。 " }, 
{ "title" : "バックアップファイルを作成する ", 
"url" : "_cds_restoring_applications_and_rts.html#UUID-a5724295-15a5-2a21-ffa4-030d2000b46b_id_adae4542f3ceafacc0a8640e00a417a9_id_6dc6a99862ca11e5ba2e95faa584c1c4", 
"breadcrumbs" : "CODESYS Essentials \/ 実行時のアプリケーション \/ 保存して回復する \/ バックアップファイルを作成する ", 
"snippet" : "要件：使用するデバイスで実行されるアプリケーションを使用してプロジェクトを開いている必要があります。この例では、アプリケーションの下に外部ファイルもあります myExternalFile.txt アプリケーションのダウンロード時にPLCに暗黙的にロードされるオブジェクトとして追加されます。 デバイスツリーのデバイスエントリをダブルクリックして、デバイスエディタを開きます。タブを選択します 保存して復元 。 タブが表示されます。メニュー付きのメニューバーが含まれています バックアップするには と 戻す 。 メニューから選択 バックアップするには コマンド デバイスからバックアップ情報を読み取る ...", 
"body" : "要件：使用するデバイスで実行されるアプリケーションを使用してプロジェクトを開いている必要があります。この例では、アプリケーションの下に外部ファイルもあります myExternalFile.txt アプリケーションのダウンロード時にPLCに暗黙的にロードされるオブジェクトとして追加されます。 デバイスツリーのデバイスエントリをダブルクリックして、デバイスエディタを開きます。タブを選択します 保存して復元 。 タブが表示されます。メニュー付きのメニューバーが含まれています バックアップするには と 戻す 。 メニューから選択 バックアップするには コマンド デバイスからバックアップ情報を読み取る 。 現在PLCに接続していない場合は、 CODESYS デバイスに簡単に接続し、から関連ファイルを読み取ります $PlcLogic$ -タブ下部の表にあるPLCのディレクトリ。少なくともこの例では、ここにファイルがあります $PlcLogic$\/Application\/Application.app 、 $PlcLogic$\/Application\/Application.crc と $PlcLogic$\/Application\/myExternalFile.txt 受け取る。プロジェクトによっては、デバイスツリーのアプリケーションの下に添付されている他の外部ファイルも表示されます。また、ソースコードアーカイブファイル $PlcLogic$\/Archive.prj 、このためにプロジェクト設定を変更した場合 プログラムのダウンロードとオンライン変更に暗黙的に含まれる 読み込み時間として設定されています。 列のチェックボックスを使用して、テーブルで非アクティブ化します アクティブ ファイル $PlcLogic$\/Application\/\/myExternalFile.txt 。 メニューから選択 バックアップするには コマンド バックアップファイルを作成してディスクに保存する 。 対話 名前を付けて保存 が表示されます。ファイルタイプは バックアップファイル（* .tbf） あらかじめ決められています。 バックアップファイルの場所を選択し、ボタンで閉じます コンピューターに保存 あちらへ。 " }, 
{ "title" : "PLCのアプリケーションを更新します ", 
"url" : "_cds_struct_update_application_on_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ PLCのアプリケーションを更新します ", 
"snippet" : "CODESYS 基本的に、変更されたアプリケーションをコントローラに転送するには、ダウンロードとオンライン変更の 2 つのオプションがあります。 ダウンロードすると、アプリケーションが再コンパイルされます。その際、構文チェックが実行され、アプリケーションコードも作成されてコントローラにダウンロードされます。これにより、実行中のプログラムが停止します。プログラムの停止と再初期化により、必ず定義済みの開始状態が作成されるため、データ転送にはダウンロードが推奨されます オンライン変更の場合、変更されたパーツのみがコントローラに再度ダウンロードされます。これによって実行中のプログラムは停止しません。オ...", 
"body" : "CODESYS 基本的に、変更されたアプリケーションをコントローラに転送するには、ダウンロードとオンライン変更の 2 つのオプションがあります。 ダウンロードすると、アプリケーションが再コンパイルされます。その際、構文チェックが実行され、アプリケーションコードも作成されてコントローラにダウンロードされます。これにより、実行中のプログラムが停止します。プログラムの停止と再初期化により、必ず定義済みの開始状態が作成されるため、データ転送にはダウンロードが推奨されます オンライン変更の場合、変更されたパーツのみがコントローラに再度ダウンロードされます。これによって実行中のプログラムは停止しません。オンラインでの変更は、アプリケーションに軽微な変更を加えた場合にのみ行ってください。大幅な変更を行うと、プログラムの動作を安全に予測することはできません。詳細については、の説明にある注記を参照してください オンライン変更 コマンド。 コントローラーにログインしたり、オフラインでオブジェクトを編集したりする場合、 CODESYS コントローラー上の既存のプロジェクトと照らし合わせて変更を確認し、その結果をステータスバーに表示します。 プログラムの変更 (完全ダウンロード) : プロジェクトの変更はダウンロードでのみ転送できます。 プログラムの変更 (オンライン変更) : プロジェクトの変更は、オンラインでの変更と一緒に転送することもできます。 " }, 
{ "title" : "オンライン変更を実行する ", 
"url" : "_cds_performing_an_online_change.html", 
"breadcrumbs" : "CODESYS Essentials \/ PLCのアプリケーションを更新します \/ オンライン変更を実行する ", 
"snippet" : "CODESYS コントローラにすでに存在しているが、最後のダウンロード以降にプログラミングシステムで変更されたアプリケーションでログインすると、オンラインでの変更が自動的に提供されます。このプロセス中、変更されたパーツのみがコントローラーにリロードされます。コントローラで実行中のプログラムは、オンライン変更で停止しません。 ビューで オンライン変更のためのメモリリザーブ プロジェクトの機能ブロックのオンライン変更用にメモリリザーブを設定できます。これは、オンライン変更中に機能ブロックを変更した後、メモリ内のインスタンス変数を移動する必要がないことを意味します。 オンライン変更については、コマン...", 
"body" : "CODESYS コントローラにすでに存在しているが、最後のダウンロード以降にプログラミングシステムで変更されたアプリケーションでログインすると、オンラインでの変更が自動的に提供されます。このプロセス中、変更されたパーツのみがコントローラーにリロードされます。コントローラで実行中のプログラムは、オンライン変更で停止しません。 ビューで オンライン変更のためのメモリリザーブ プロジェクトの機能ブロックのオンライン変更用にメモリリザーブを設定できます。これは、オンライン変更中に機能ブロックを変更した後、メモリ内のインスタンス変数を移動する必要がないことを意味します。 オンライン変更については、コマンドの説明の情報に注意してください オンライン変更 。 ログイン時にオンライン変更を実行します（オンライン操作）。 要件：コントローラーの接続設定が正しく設定されている。プロジェクトとコントローラーのアプリケーションは同じです。コントローラのプログラムが実行されています。アプリケーションがログインしています。 デバイスツリーでオブジェクトを選択します。ここでPOUまたはGVLを選択するのが最善です。 コマンドを選択します プロジェクト→オブジェクトの編集（オフライン）。 。 オブジェクトがエディターで開きます。 オブジェクトを変更します。ここでは、たとえば、新しい変数を宣言したり、値の割り当てを変更したりできます。 コマンドを選択します オンライン→オンライン変更 。 本当にオンライン変更を実行するかどうかを尋ねられます。 とのダイアログを確認します はい 。 変更がコントローラーにダウンロードされます。 " }, 
{ "title" : "ログイン時にオンライン変更を実行する ", 
"url" : "_cds_performing_an_online_change.html#UUID-217fb929-5892-40cb-4dbf-ec7a5f6cf6bd_id_bfc346a7689da61c0a8640e01ee8549_id_89839d86b2bb11e4a177fe5cc7c27ae9", 
"breadcrumbs" : "CODESYS Essentials \/ PLCのアプリケーションを更新します \/ オンライン変更を実行する \/ ログイン時にオンライン変更を実行する ", 
"snippet" : "要件：コントローラーの接続設定が正しく設定されている。プロジェクトとコントローラーのアプリケーションは同じです。コントローラのプログラムが実行されています。アプリケーションはログアウトされています。 アプリケーションを変更します。 コマンドを選択します オンライン→ログイン 。 最後のダウンロード以降にアプリケーションが変更されたことを示すダイアログが表示されます。 ボタンをクリックします 詳細 。 タブの情報を確認してください アプリケーション情報 。 最後の変更以降にコードを生成していない場合、コマンドは次のようになります。 アプリケーションが最新ではありません。今すぐコードを生成しますか...", 
"body" : "要件：コントローラーの接続設定が正しく設定されている。プロジェクトとコントローラーのアプリケーションは同じです。コントローラのプログラムが実行されています。アプリケーションはログアウトされています。 アプリケーションを変更します。 コマンドを選択します オンライン→ログイン 。 最後のダウンロード以降にアプリケーションが変更されたことを示すダイアログが表示されます。 ボタンをクリックします 詳細 。 タブの情報を確認してください アプリケーション情報 。 最後の変更以降にコードを生成していない場合、コマンドは次のようになります。 アプリケーションが最新ではありません。今すぐコードを生成しますか？ ダイアログの下部に表示されます。この場合、このコマンドをクリックします。 あなたは1つを受け取ります 比較ビュー オブジェクトの-赤でマークされたオブジェクトは異なります。 ダイアログを閉じます。 オプションを選択してください オンライン変更でログイン をクリックします わかった 。 変更がコントローラーにダウンロードされます。コントローラで実行中のプログラムは停止しません。アプリケーションがログインしています。 " }, 
{ "title" : "ダウンロードの実行 ", 
"url" : "_cds_performing_a_download.html", 
"breadcrumbs" : "CODESYS Essentials \/ PLCのアプリケーションを更新します \/ ダウンロードの実行 ", 
"snippet" : "アプリケーションをダウンロードすると、アクティブなアプリケーションがコンパイルされます。構文チェックに加えて、アプリケーションコードも生成され、コントローラーにロードされます。ダウンロード中、コントローラーで実行中のプログラムが停止します。 ダウンロードするときは、コマンドの説明の情報に注意してください ダウンロード 。 ログイン時にダウンロード（オンライン操作） 要件：コントローラーの接続設定が正しく設定されている。プロジェクトとコントローラーのアプリケーションは同じです。コントローラのプログラムが実行されています。アプリケーションがログインしています。 デバイスツリーでオブジェクトを選択し...", 
"body" : "アプリケーションをダウンロードすると、アクティブなアプリケーションがコンパイルされます。構文チェックに加えて、アプリケーションコードも生成され、コントローラーにロードされます。ダウンロード中、コントローラーで実行中のプログラムが停止します。 ダウンロードするときは、コマンドの説明の情報に注意してください ダウンロード 。 ログイン時にダウンロード（オンライン操作） 要件：コントローラーの接続設定が正しく設定されている。プロジェクトとコントローラーのアプリケーションは同じです。コントローラのプログラムが実行されています。アプリケーションがログインしています。 デバイスツリーでオブジェクトを選択します。ここでPOUまたはGVLを選択するのが最善です。 コマンドを選択します プロジェクト→オブジェクトの編集（オフライン）。 。 オブジェクトがエディターで開きます。 オブジェクトを変更します。ここでは、たとえば、新しい変数を宣言したり、値の割り当てを変更したりできます。 コマンドを選択します オンライン→ダウンロード 。 本当にダウンロードを実行するかどうかを尋ねられます。 とのダイアログを確認します はい 。 コントローラで実行中のプログラムが停止し、変更がコントローラにロードされます。 " }, 
{ "title" : "ログイン時にダウンロード ", 
"url" : "_cds_performing_a_download.html#UUID-60110cce-40f4-7c41-696d-4ce2dcaf51dd_id_c7d078ef768b6539c0a8640e006bdc72_id_89839d86b2bb11e4a177fe5cc7c27ae9", 
"breadcrumbs" : "CODESYS Essentials \/ PLCのアプリケーションを更新します \/ ダウンロードの実行 \/ ログイン時にダウンロード ", 
"snippet" : "要件：コントローラーの接続設定が正しく設定されている。プロジェクトとコントローラーのアプリケーションは同じです。コントローラのプログラムが実行されています。アプリケーションはログアウトされます。 アプリケーションを変更します。 コマンドを選択します オンライン→ログイン 。 最後のダウンロード以降にアプリケーションが変更されたことを示すダイアログが表示されます。 オプションを選択してください ダウンロードしてログイン をクリックします わかった 。 コントローラで実行中のプログラムが停止し、変更がコントローラにロードされます。アプリケーションがログインしています。...", 
"body" : "要件：コントローラーの接続設定が正しく設定されている。プロジェクトとコントローラーのアプリケーションは同じです。コントローラのプログラムが実行されています。アプリケーションはログアウトされます。 アプリケーションを変更します。 コマンドを選択します オンライン→ログイン 。 最後のダウンロード以降にアプリケーションが変更されたことを示すダイアログが表示されます。 オプションを選択してください ダウンロードしてログイン をクリックします わかった 。 コントローラで実行中のプログラムが停止し、変更がコントローラにロードされます。アプリケーションがログインしています。 " }, 
{ "title" : "PLCとの間でファイルをコピーする ", 
"url" : "_cds_copy_files_from_to_plc.html", 
"breadcrumbs" : "CODESYS Essentials \/ PLCとの間でファイルをコピーする ", 
"snippet" : "[汎用]タブ ファイル デバイスエディタを使用すると、ローカルファイルシステムとコントローラの間で双方向にファイルをコピーできます。 要件：タブはメーカーによって有効にされています。制御デバイスへの接続は、プロジェクトのデバイスツリーで構成されます。デバイスは実行中です。 デバイスツリーでPLCデバイスオブジェクトをダブルクリックして、デバイスエディタを開きます。 クリック タブ：ファイル タブ。 ダイアログの左半分（ ホスト ） で 位置 ローカルファイルシステムでファイルのコピー元またはコピー先のパスを入力します。 例： D:\\FileTransferWithPLC 必要に応じて、ボタンの...", 
"body" : "[汎用]タブ ファイル デバイスエディタを使用すると、ローカルファイルシステムとコントローラの間で双方向にファイルをコピーできます。 要件：タブはメーカーによって有効にされています。制御デバイスへの接続は、プロジェクトのデバイスツリーで構成されます。デバイスは実行中です。 デバイスツリーでPLCデバイスオブジェクトをダブルクリックして、デバイスエディタを開きます。 クリック タブ：ファイル タブ。 ダイアログの左半分（ ホスト ） で 位置 ローカルファイルシステムでファイルのコピー元またはコピー先のパスを入力します。 例： D:\\FileTransferWithPLC 必要に応じて、ボタンの上に置きます 新しいディレクトリに直接移動します。 ディレクトリとファイルは、ファイルマネージャから認識されているとおりに表示されます。ボタン付き 表示を更新できます。 同様に、ダイアログの右半分（ 間隔 ）ファイル転送に必要なディレクトリ。 CODESYS コントロールに存在するファイルを示します。 次に、それぞれのファイルシステムツリーでファイル転送に必要なファイルを選択します。複数選択が可能です。含まれているすべてのファイルを転送する場合は、ディレクトリを選択することもできます。 ボタンを押す それぞれ 対話の半分の間。 CODESYS 選択したファイルをすぐに他のファイルシステムにコピーします。ターゲットディレクトリにファイルがまだ存在しない場合は、そこに作成されます。すでに存在する場合は、読み取り専用でない限り上書きされます。対応するメッセージが表示されます。 " }, 
{ "title" : "コマンドラインインターフェイスを使用する ", 
"url" : "_cds_commandline.html", 
"breadcrumbs" : "CODESYS Essentials \/ コマンドラインインターフェイスを使用する ", 
"snippet" : "あなたはできる CODESYS コマンドラインから.exeを実行し、以下で説明するオプションと引数を指定します。 構文： <installation folder>CODESYS.exe --<Option> を使用したことがある場合は、 CODESYS Installer 複数インストールするには CODESYS コンピュータ上にインスタンスがある場合は、 --additionalfolder 起動するインスタンスを指定するオプション。 スペース、マイナス記号、またはスラッシュを含むパスまたはオプションパラメータは、一重引用符で囲む必要があります。...", 
"body" : "あなたはできる CODESYS コマンドラインから.exeを実行し、以下で説明するオプションと引数を指定します。 構文： <installation folder>CODESYS.exe --<Option> を使用したことがある場合は、 CODESYS Installer 複数インストールするには CODESYS コンピュータ上にインスタンスがある場合は、 --additionalfolder 起動するインスタンスを指定するオプション。 スペース、マイナス記号、またはスラッシュを含むパスまたはオプションパラメータは、一重引用符で囲む必要があります。 " }, 
{ "title" : "オプション: --Additionalfolder ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-11c2da71-d4f5-749d-04bf-eeab75652c7e", 
"breadcrumbs" : "CODESYS Essentials \/ コマンドラインインターフェイスを使用する \/ オプション: --Additionalfolder ", 
"snippet" : "を使用して作成されたインストールにのみ適用されます。 CODESYS Installer : の複数のインスタンスをインストールしている場合、 CODESYS バージョンを確認し、コマンド ラインからインスタンスの 1 つを起動したい場合は、次のことが適用されます。プロファイルに加えて、その絶対パスも指定する必要があります。 AddionalFolder\/<instance name> とともに --additionalfolder オプション。 背景: CODESYS Installer を作成します AdditionalFolders のインストールディレクトリ内のサブフォルダー CODE...", 
"body" : "を使用して作成されたインストールにのみ適用されます。 CODESYS Installer : の複数のインスタンスをインストールしている場合、 CODESYS バージョンを確認し、コマンド ラインからインスタンスの 1 つを起動したい場合は、次のことが適用されます。プロファイルに加えて、その絶対パスも指定する必要があります。 AddionalFolder\/<instance name> とともに --additionalfolder オプション。 背景: CODESYS Installer を作成します AdditionalFolders のインストールディレクトリ内のサブフォルダー CODESYS フォルダ。このフォルダーには、それぞれに個別のサブフォルダーがあります。 CODESYS インスタンスとプロファイル、PlugIns、および PackageDB の個別のファイル。最初にインストールされたインスタンスの場合、サブフォルダーの名前は次のとおりです。 Default 。追加のインスタンスには、インストール中に割り当てられたインストール名が付けられます。 指定する絶対パスが確認できます。 --additionalfolder で CODESYS Installer をクリックすると、 変化 関連するインスタンスのタイルにあるボタン。として登録されています 位置 。 構文： --additionalfolder=<AdditionalFolders\\<instance installation name>> 例 の 2 つの例 CODESYS 3.5.18.20 がコンピュータにインストールされています。 CODESYS Installer : 1 つはサービス技術者用、もう 1 つは開発者用です。実行したいのは、 Service 経由のインスタンス StartServiceScript.py コマンドラインからスクリプトを作成します。これを行うには、次のようにコマンド ラインで --profile オプションの後に --Additionalfolder オプションを指定します。 \"C:\\Program Files (x86)\\CODESYS3.5.18.20\\CODESYS\\Common\\CODESYS.exe\" --profile=\"CODESYS V3.5 SP18 --additionalfolder=\"C:\\Program Files\\CODESYS 3.5.18.20\\CODESYS\\AdditionalFolders\\Service\" --runscript=\"D:\\Dokumente\\Scripting\\StartServiceScript.py\"--scriptargs:'username password 3.14 \"path=\\\"C:\\temp\\\\\\\"\"'–noUI " }, 
{ "title" : "オプション: --culture (ユーザー インターフェイスの言語) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_6bc8917312a6e013c0a8640e003e6f2f", 
"breadcrumbs" : "CODESYS Essentials \/ コマンドラインインターフェイスを使用する \/ オプション: --culture (ユーザー インターフェイスの言語) ", 
"snippet" : "CODESYS 指定された国語で開始されます。 構文： --culture=<Culture> <Culture> ：目的の国語の通常の言語の略語。たとえば、de、en、fr、it、es、zh-CHS。 例 から始まる CODESYS 英語のユーザーインターフェイスを使用： CODESYS.exe --culture=en...", 
"body" : "CODESYS 指定された国語で開始されます。 構文： --culture=<Culture> <Culture> ：目的の国語の通常の言語の略語。たとえば、de、en、fr、it、es、zh-CHS。 例 から始まる CODESYS 英語のユーザーインターフェイスを使用： CODESYS.exe --culture=en " }, 
{ "title" : "オプション--profile（ CODESYS -プロフィール） ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_30cad0c546e2dc0cc0a8640e00a03b89", 
"breadcrumbs" : "CODESYS Essentials \/ コマンドラインインターフェイスを使用する \/ オプション--profile（ CODESYS -プロフィール） ", 
"snippet" : "CODESYS 指定されたプロファイルで直接開始されます。もし、あんたが CODESYS この指定なしで開始すると、ダイアログが表示されます プロファイルを選択 。 構文： --profile=\"<profile name>\" <profile name> ：ダイアログに表示されるプロファイル名を正確に指定する必要があります ヘルプ→情報 開発システムまたはコンピュータのスタートメニューにあります。 例 CODESYS.exe --culture=de --profile=\"CODESYS V3.6\"...", 
"body" : "CODESYS 指定されたプロファイルで直接開始されます。もし、あんたが CODESYS この指定なしで開始すると、ダイアログが表示されます プロファイルを選択 。 構文： --profile=\"<profile name>\" <profile name> ：ダイアログに表示されるプロファイル名を正確に指定する必要があります ヘルプ→情報 開発システムまたはコンピュータのスタートメニューにあります。 例 CODESYS.exe --culture=de --profile=\"CODESYS V3.6\" " }, 
{ "title" : "オプション--compare（トリガープロジェクト比較） ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_2d8f4b0c12a6e014c0a8640e00f5a2e5", 
"breadcrumbs" : "CODESYS Essentials \/ コマンドラインインターフェイスを使用する \/ オプション--compare（トリガープロジェクト比較） ", 
"snippet" : "から始めた後 CODESYS すぐに2つの比較になります CODESYS -もたらされたプロジェクト。オプションの背後にある引数として、最初に「現在のプロジェクト」を入力し、次に「比較プロジェクト」を入力します。 CODESYS ビューを開始して開きます プロジェクトの比較-違い 。 構文： --compare=\"<path of project file>\" \"<path of reference project file>\" 例 CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.project\"...", 
"body" : "から始めた後 CODESYS すぐに2つの比較になります CODESYS -もたらされたプロジェクト。オプションの背後にある引数として、最初に「現在のプロジェクト」を入力し、次に「比較プロジェクト」を入力します。 CODESYS ビューを開始して開きます プロジェクトの比較-違い 。 構文： --compare=\"<path of project file>\" \"<path of reference project file>\" 例 CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.project\" " }, 
{ "title" : "オプション: --project (開く CODESYS 計画） ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_440832e712a6e015c0a8640e0099773d", 
"breadcrumbs" : "CODESYS Essentials \/ コマンドラインインターフェイスを使用する \/ オプション: --project (開く CODESYS 計画） ", 
"snippet" : "CODESYS が開始され、指定されたプロジェクトが開かれます。 構文： --project=\"<path of project file>\" <path of project file> ：プロジェクトのファイルパス 例 プロジェクトを開く test ： CODESYS.exe --culture=de --project=\"D:\\projects\\test.project\"...", 
"body" : "CODESYS が開始され、指定されたプロジェクトが開かれます。 構文： --project=\"<path of project file>\" <path of project file> ：プロジェクトのファイルパス 例 プロジェクトを開く test ： CODESYS.exe --culture=de --project=\"D:\\projects\\test.project\" " }, 
{ "title" : "オプション--projectarchive（ CODESYS -プロジェクトアーカイブを開く） ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_33a5dfa012a6e016c0a8640e016367f3", 
"breadcrumbs" : "CODESYS Essentials \/ コマンドラインインターフェイスを使用する \/ オプション--projectarchive（ CODESYS -プロジェクトアーカイブを開く） ", 
"snippet" : "CODESYS を開始し、指定されたリポジトリを抽出して、プロジェクトを開きます。 構文： --projectarchive=\"<path of projectarchive file>\" <path of project archive file> ：リポジトリファイルパス 例 プロジェクトアーカイブの抽出 test.projectarchive プログラミングシステムでプロジェクトを開きます。 CODESYS.exe --projectarchive=\"D:\\projects\\test.projectarchive\"...", 
"body" : "CODESYS を開始し、指定されたリポジトリを抽出して、プロジェクトを開きます。 構文： --projectarchive=\"<path of projectarchive file>\" <path of project archive file> ：リポジトリファイルパス 例 プロジェクトアーカイブの抽出 test.projectarchive プログラミングシステムでプロジェクトを開きます。 CODESYS.exe --projectarchive=\"D:\\projects\\test.projectarchive\" " }, 
{ "title" : "オプション: --runscript (スクリプトの実行) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_878d053246e2dc13c0a8640e0077c63b", 
"breadcrumbs" : "CODESYS Essentials \/ コマンドラインインターフェイスを使用する \/ オプション: --runscript (スクリプトの実行) ", 
"snippet" : "指定されたスクリプトファイルはによって実行されます CODESYS 実行されました。 --runscriptのコマンドラインオプション --runscript=\"<scriptfile>.py\" CODESYS スクリプトファイルを実行します <scriptfile>.py 起動時にオフにします。 スクリプトファイルのフルパスを指定する必要があります。 --scriptargs:'<arg1> <arg2> ... <argn>' オプションと一緒にオプションを使用する --runscript 。これにより、引数<arg1>…<argn>がスクリプトに渡されます。引数はPython変数に渡され...", 
"body" : "指定されたスクリプトファイルはによって実行されます CODESYS 実行されました。 --runscriptのコマンドラインオプション --runscript=\"<scriptfile>.py\" CODESYS スクリプトファイルを実行します <scriptfile>.py 起動時にオフにします。 スクリプトファイルのフルパスを指定する必要があります。 --scriptargs:'<arg1> <arg2> ... <argn>' オプションと一緒にオプションを使用する --runscript 。これにより、引数<arg1>…<argn>がスクリプトに渡されます。引数はPython変数に渡されます sys.argv 受け継がれました。 --noUI オプションと一緒にオプションを使用する --runscript 。 the CODESYS ユーザーインターフェイスが開きません。 CODESYS すべてのエラー、警告、コンパイラメッセージ、およびスクリプトによって生成されたメッセージをコマンドラインに出力します。スクリプトメッセージ（1：重大度テキスト）は、オペレーターを使用して他のメッセージ（2：重大度FatalError、エラー、警告、情報）から分離できます。 > 分離されます。 --enablescripttracing オプションと一緒にオプションを使用する --runscript 。これにより、スクリプトファイルの各コマンドが出力に表示されます。 --textPrompts オプションと一緒にオプションを使用する --noUI 。これにより、メッセージサービスメソッドと標準ダイアログがコマンドラインに出力され、ユーザー入力を実行できるようになります。 もし、あんたが --textPrompts 指定しない場合、すべてのメッセージサービスプロンプトはデフォルト値で自動的に応答されます。 sys.argvを使用してスクリプトファイルで転送パラメータを使用する例 start \/b \/wait CODESYS.exe\n--runscript=\"D:\\Script\\ArgvAnd__main__Test.py\"\n--scriptargs:'username password 3.14 \"path=\\\"C:\\temp\\\\\"' スクリプトファイル ArgvAnd__main__Test.py from __future__ import print_function\nimport sys\nprint(\"sys.argv: \", len(sys.argv), \" elements:\")\n\nfor arg in sys.argv:\n print(\" - \", arg)\nprint()\nprint(\"__name__: \", __name__) 出力結果 stdout ： sys.argv: 6 elements:\n- D:\\TestScripts\\ArgvAnd__main__Test.py\n- username\n- password\n- 3.14\n- path= \"C:temp\"\n__name__: __main__ グローバル変数の詳細 __name__ Pythonのドキュメントを参照してください。 メッセージ出力の例 start \/b \/wait CODESYS.exe --runscript=\"D:\\Script\\AmpelTest.py\" --noUI 1>ScriptMessages.txt スクリプトによって生成されたすべての通知はルーティングされます CODESYS ファイルに ScriptMessages.txt その周り。その他のメッセージはコマンドラインに出力されます。 start \/b \/wait CODESYS.exe --runscript=\"D:\\Script\\AmpelTest.py\" --noUI 2>NUL CODESYS スクリプトメッセージを除くすべてのメッセージを抑制します。スクリプトメッセージはコマンドラインに出力されます。 –scriptdebuggerオプションの使用例 次のスクリプト initdebug.py で成功しました pydevd PyDev \/ LiClipseやPyCharmのようなベースのデバッガー。このスクリプトを使用するには、 CODESYS 次のコマンドラインを使用します。 --profile=\"Fanta Development Build\" --scriptdebugger=\"D:\\test\\charmdebug\\initdebug.py\" ファイル initdebug.py ： from _future_ import print_function\nfrom _future_ import unicode_literals\nimport sys\nsys.path.append(r\"D:\\test\\Env2\\Lib\\site-packages\\pycharm-debug.egg\")\nimport pydevd\ndef scriptdebuggersetup():\npydevd.settrace('localhost', port=51234, stdoutToServer=True, stderrToServer=True)\ndef scriptdebuggershutdown():\npydevd.stoptrace() 詳細については、次を参照してください。 スクリプトの使用 と http:\/\/docs.python.org\/tutorial\/modules.html " }, 
{ "title" : "オプション: --ignorewhitespace (プロジェクト比較で空白を無視します) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_6bfa2ec346e2dc14c0a8640e0164e212", 
"breadcrumbs" : "CODESYS Essentials \/ コマンドラインインターフェイスを使用する \/ オプション: --ignorewhitespace (プロジェクト比較で空白を無視します) ", 
"snippet" : "このオプションをオプションの後ろに置くと --compare <project1> <project2> さらに、プロジェクトの比較ではスペースは考慮されません。注：次のような意味的に関連するスペース STRING -どのような場合でも、リテラルは引き続き考慮されます。 構文 --compare=\"<path of project file>\" \"<path of reference project file>\" --ignorewhitespace=\"true\"|\"false\" 例 CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\pr...", 
"body" : "このオプションをオプションの後ろに置くと --compare <project1> <project2> さらに、プロジェクトの比較ではスペースは考慮されません。注：次のような意味的に関連するスペース STRING -どのような場合でも、リテラルは引き続き考慮されます。 構文 --compare=\"<path of project file>\" \"<path of reference project file>\" --ignorewhitespace=\"true\"|\"false\" 例 CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.project\" --ignorewhitespace=\"true\" " }, 
{ "title" : "オプション: --ignorecomments (プロジェクト比較でコメントを無視) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_38d685e446e2dc15c0a8640e00aa5b6e", 
"breadcrumbs" : "CODESYS Essentials \/ コマンドラインインターフェイスを使用する \/ オプション: --ignorecomments (プロジェクト比較でコメントを無視) ", 
"snippet" : "このオプションをオプションの後ろに置くと --compare <project1> <project2> さらに、プロジェクトの比較ではコメントは考慮されません。 構文： --compare=\"<path of project file>\" \"<path of reference project file>\" --ignorecomments=\"true\"|\"false\" 例 CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.project\" --ignorecomments=\"true\"...", 
"body" : "このオプションをオプションの後ろに置くと --compare <project1> <project2> さらに、プロジェクトの比較ではコメントは考慮されません。 構文： --compare=\"<path of project file>\" \"<path of reference project file>\" --ignorecomments=\"true\"|\"false\" 例 CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.project\" --ignorecomments=\"true\" " }, 
{ "title" : "オプション: --ignoreproperties (プロジェクト比較でオブジェクト プロパティを無視) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-ca064d81-741b-2021-8cb8-470e0cb751f2", 
"breadcrumbs" : "CODESYS Essentials \/ コマンドラインインターフェイスを使用する \/ オプション: --ignoreproperties (プロジェクト比較でオブジェクト プロパティを無視) ", 
"snippet" : "このオプションをオプションの後ろに置くと --compare <project1> <project2> 追加、オブジェクトのプロパティ（アクセス権、変換設定、ディレクトリ、ビットマップなど）は、プロジェクトの比較では考慮されません。 構文： --compare=\"<path of project file>\" \"<path of reference project file>\" --ignoreproperties=\"true\"|\"false\" 例 CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.proje...", 
"body" : "このオプションをオプションの後ろに置くと --compare <project1> <project2> 追加、オブジェクトのプロパティ（アクセス権、変換設定、ディレクトリ、ビットマップなど）は、プロジェクトの比較では考慮されません。 構文： --compare=\"<path of project file>\" \"<path of reference project file>\" --ignoreproperties=\"true\"|\"false\" 例 CODESYS.exe --compare \"D:\\proj\\project1.project\" \"D:\\proj\\project2.project\" --ignoreproperties=\"true\" " }, 
{ "title" : "オプション: --skipunlicensedplugins (ライセンスなしでコンポーネントをロードしないでください) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_id_debf72be004b5c0a8640e004cfb06_id_dcd35d41076c4576c0a86463067eecc3", 
"breadcrumbs" : "CODESYS Essentials \/ コマンドラインインターフェイスを使用する \/ オプション: --skipunlicensedplugins (ライセンスなしでコンポーネントをロードしないでください) ", 
"snippet" : "CODESYS が開始されます。ライセンスされていないコンポーネントをロードする必要があるかどうかに関するクエリはスキップされます。この場合、 CODESYS これらのコンポーネントは暗黙的に いいえ 。 例 CODESYS.exe –skipunlicensedplugins...", 
"body" : "CODESYS が開始されます。ライセンスされていないコンポーネントをロードする必要があるかどうかに関するクエリはスキップされます。この場合、 CODESYS これらのコンポーネントは暗黙的に いいえ 。 例 CODESYS.exe –skipunlicensedplugins " }, 
{ "title" : "オプション: --signaturethumbprint (コンパイル済みライブラリの署名に使用される証明書の拇印) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-caedc225-0247-831c-1ac2-1bc63dca068c", 
"breadcrumbs" : "CODESYS Essentials \/ コマンドラインインターフェイスを使用する \/ オプション: --signaturethumbprint (コンパイル済みライブラリの署名に使用される証明書の拇印) ", 
"snippet" : "このオプションをオプションの後ろに置くと --project=\"<path of project file>\" さらに、翻訳されたライブラリに署名するための証明書の拇印を渡してプロジェクトが開かれます。 構文： --signaturethumbprint=\"<thumbprint of digital signature>\" 例 CODESYS.exe --project=\"D:\\projects\\test.project\" signaturethumbprint=\"3E96C9B61010CBDC3186021A1CAA64946DDCAAF3\"...", 
"body" : "このオプションをオプションの後ろに置くと --project=\"<path of project file>\" さらに、翻訳されたライブラリに署名するための証明書の拇印を渡してプロジェクトが開かれます。 構文： --signaturethumbprint=\"<thumbprint of digital signature>\" 例 CODESYS.exe --project=\"D:\\projects\\test.project\" signaturethumbprint=\"3E96C9B61010CBDC3186021A1CAA64946DDCAAF3\" " }, 
{ "title" : "オプション: --enforcesignedcompiledlibraries (コンパイル済みライブラリの署名を強制) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-347f5ad2-49b1-cd80-5021-7561cc675234", 
"breadcrumbs" : "CODESYS Essentials \/ コマンドラインインターフェイスを使用する \/ オプション: --enforcesignedcompiledlibraries (コンパイル済みライブラリの署名を強制) ", 
"snippet" : "このオプションをオプションの後ろに置くと --project=\"<path of project file>\" 追加は、のプロジェクトに表示されます セキュリティ画面 タブ上 ユーザー オプション 翻訳されたライブラリの署名を強制する 起動しました。 の場合 セキュリティ画面 を開いたり閉じたりすると、アクティブな変更が行われていなくても、現在の設定がユーザーオプションに適用されます。 構文： --enforcesignedcompiledlibraries 例 CODESYS.exe --project=\"D:\\projects\\test.library\" --enforcesignedco...", 
"body" : "このオプションをオプションの後ろに置くと --project=\"<path of project file>\" 追加は、のプロジェクトに表示されます セキュリティ画面 タブ上 ユーザー オプション 翻訳されたライブラリの署名を強制する 起動しました。 の場合 セキュリティ画面 を開いたり閉じたりすると、アクティブな変更が行われていなくても、現在の設定がユーザーオプションに適用されます。 構文： --enforcesignedcompiledlibraries 例 CODESYS.exe --project=\"D:\\projects\\test.library\" --enforcesignedcompiledlibraries " }, 
{ "title" : "オプション: --timestampingserverurl (タイムスタンプ サーバー アドレスを設定) ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-2fb9f8ee-c520-7f05-fecd-b242c30821ee", 
"breadcrumbs" : "CODESYS Essentials \/ コマンドラインインターフェイスを使用する \/ オプション: --timestampingserverurl (タイムスタンプ サーバー アドレスを設定) ", 
"snippet" : "このオプションをオプションの後ろに置くと --project=\"<path of project file>\" 追加は、のプロジェクトに表示されます セキュリティ画面 タブ上 ユーザー RFC-3161タイムスタンプサーバーのインターネットアドレス（ タイムスタンプサーバー ） セットする。 の場合 セキュリティ画面 を開いたり閉じたりすると、アクティブな変更が行われていなくても、現在の設定がユーザーオプションに適用されます。 構文： --timestampingserverurl=\"<URL of RFC-3161 timestamping server>\" 例 CODESYS.exe --...", 
"body" : "このオプションをオプションの後ろに置くと --project=\"<path of project file>\" 追加は、のプロジェクトに表示されます セキュリティ画面 タブ上 ユーザー RFC-3161タイムスタンプサーバーのインターネットアドレス（ タイムスタンプサーバー ） セットする。 の場合 セキュリティ画面 を開いたり閉じたりすると、アクティブな変更が行われていなくても、現在の設定がユーザーオプションに適用されます。 構文： --timestampingserverurl=\"<URL of RFC-3161 timestamping server>\" 例 CODESYS.exe --timestampingserverurl=\"http:\/\/timestamp.comodoca.com\/rfc3161\" " }, 
{ "title" : "オプション: --enableEventLog ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-6910bbcd-f37f-036c-b800-832c97c5578e", 
"breadcrumbs" : "CODESYS Essentials \/ コマンドラインインターフェイスを使用する \/ オプション: --enableEventLog ", 
"snippet" : "CODESYS が開始され、すべてのコマンドの実行が Windows イベント ログに記録されます。レコードは Windows にあります。 イベントビューア 下 アプリケーションとサービスのログ → AP . このオプションを初めて使用する場合は、 CODESYS 管理者権限で開始する必要があります。 構文： --enableEventLog=\"CommandManager\"...", 
"body" : "CODESYS が開始され、すべてのコマンドの実行が Windows イベント ログに記録されます。レコードは Windows にあります。 イベントビューア 下 アプリケーションとサービスのログ → AP . このオプションを初めて使用する場合は、 CODESYS 管理者権限で開始する必要があります。 構文： --enableEventLog=\"CommandManager\" " }, 
{ "title" : "オプション: --ForceDisconnectAfterInactivity ", 
"url" : "_cds_commandline.html#UUID-8714bafe-d413-17ca-578e-918ea442e3c2_UUID-6f3de5bf-ac76-9e2f-50b4-e5265686a252", 
"breadcrumbs" : "CODESYS Essentials \/ コマンドラインインターフェイスを使用する \/ オプション: --ForceDisconnectAfterInactivity ", 
"snippet" : "このために CODESYS セッション中に、コントローラへの接続が自動的に終了するまでの非アクティブな時間が、指定された時間 (秒単位) に設定されます。このオプションで指定された値は、 CODESYS のオプション オンライン このカテゴリ CODESYS セッション。 値が 0 に設定されている場合、非アクティブ状態が一定時間続いた後でも、コントローラへの接続は自動的に終了しません。このために CODESYS セッションの切断オプションが無効になります。 CODESYS オプション。 構文： --ForceDisconnectAfterInactivity=\"<value in secon...", 
"body" : "このために CODESYS セッション中に、コントローラへの接続が自動的に終了するまでの非アクティブな時間が、指定された時間 (秒単位) に設定されます。このオプションで指定された値は、 CODESYS のオプション オンライン このカテゴリ CODESYS セッション。 値が 0 に設定されている場合、非アクティブ状態が一定時間続いた後でも、コントローラへの接続は自動的に終了しません。このために CODESYS セッションの切断オプションが無効になります。 CODESYS オプション。 構文： --ForceDisconnectAfterInactivity=\"<value in seconds>\" \n <value in seconds> : [10, 10800] | 0 例 非アクティブ状態が 300 秒続くと、コントローラーへの接続は自動的に終了します。 --ForceDisconnectAfterInactivity=\"300\" " }, 
{ "title" : "ライブラリの使用 ", 
"url" : "_cds_struct_installing_libraries.html", 
"breadcrumbs" : "CODESYS Essentials \/ ライブラリの使用 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "ライブラリリポジトリ ", 
"url" : "_cds_struct_installing_libraries.html#UUID-9b7dfd17-ac20-bbba-303e-1ac0ef3a80c0_section-idm4531453287164832668319668401", 
"breadcrumbs" : "CODESYS Essentials \/ ライブラリの使用 \/ ライブラリリポジトリ ", 
"snippet" : "The ライブラリリポジトリ ライブラリおよび関連するメタデータの開発システム上の場所です。ライブラリマネージャーを使用して、インストールされているライブラリをプロジェクトにリンクできます。さらに、ライブラリはバージョン管理とともにインストールされ、ライブラリを簡単に更新できます。 プレインストールされているものに加えて、さらに多くのリポジトリを作成および編集できます System リポジトリ。...", 
"body" : "The ライブラリリポジトリ ライブラリおよび関連するメタデータの開発システム上の場所です。ライブラリマネージャーを使用して、インストールされているライブラリをプロジェクトにリンクできます。さらに、ライブラリはバージョン管理とともにインストールされ、ライブラリを簡単に更新できます。 プレインストールされているものに加えて、さらに多くのリポジトリを作成および編集できます System リポジトリ。 " }, 
{ "title" : "ライブラリマネージャー ", 
"url" : "_cds_struct_installing_libraries.html#UUID-9b7dfd17-ac20-bbba-303e-1ac0ef3a80c0_section-idm4531453400737632668320099362", 
"breadcrumbs" : "CODESYS Essentials \/ ライブラリの使用 \/ ライブラリマネージャー ", 
"snippet" : "ライブラリPOUで提供されるPOUをアプリケーションで使用できるようにするには、ライブラリをアプリケーションに統合する必要があります。 ライブラリマネージャー プロジェクトで。このための要件は、ライブラリリポジトリにライブラリをインストールすることです。 ライブラリマネージャは、ライブラリタイプとそれぞれのプロパティに従って、すべての統合ライブラリを表示します。ライブラリマネージャーでは、ライブラリリポジトリからライブラリを追加したり、ライブラリを削除したり、ライブラリのプロパティを編集したりできます。 ライブラリマネージャーは、に挿入できます。 POU ビューまたは デバイス 見る。その結果...", 
"body" : "ライブラリPOUで提供されるPOUをアプリケーションで使用できるようにするには、ライブラリをアプリケーションに統合する必要があります。 ライブラリマネージャー プロジェクトで。このための要件は、ライブラリリポジトリにライブラリをインストールすることです。 ライブラリマネージャは、ライブラリタイプとそれぞれのプロパティに従って、すべての統合ライブラリを表示します。ライブラリマネージャーでは、ライブラリリポジトリからライブラリを追加したり、ライブラリを削除したり、ライブラリのプロパティを編集したりできます。 ライブラリマネージャーは、に挿入できます。 POU ビューまたは デバイス 見る。その結果、プロジェクトには、アプリケーションごとにライブラリマネージャーを含めることができます。また、 POU すべてのアプリケーションで使用するためのビュー。の統合ライブラリのライブラリPOU POU ビューは、アプリケーションに関係なく呼び出すことができます。の統合ライブラリのライブラリPOU デバイス ビューは、それぞれのアプリケーションコードでのみ呼び出すことができます。さらに、プレースホルダーライブラリは、その位置に応じてダウンロード時の動作が異なります。 プロジェクト内の特定のバージョンに統合されているライブラリには、そのバージョンのプレースホルダー（プレースホルダーライブラリ）もあります。特別なプレースホルダーの解像度を定義できます。デバイスの説明でデバイスに対して定義されている、またはライブラリのライブラリリポジトリに保存されているプレースホルダー解決を使用することもできます。ライブラリマネージャーは、実際のプレースホルダーの解決について通知し、アプリケーションのダウンロード時に読み込まれるバージョン（有効なバージョン）を表示します。 のライブラリマネージャーが POU ビューはすべてのアプリケーションに統合されており、そのコンテンツにグローバルにアクセスできます。プレースホルダーライブラリが統合されている場合は、デバイスの説明またはライブラリリポジトリ内のプレースホルダーの解決のみがチェックされます。 ライブラリマネージャーは通常、 デバイス 見る。次に、その下のアプリケーションコードのみがライブラリPOUを呼び出します。さらに、プレースホルダーライブラリの特別なプレースホルダー解決が最初にチェックされます。その後にのみ、デバイスの説明にある、またはライブラリリポジトリに由来するプレースホルダーの解決がチェックされます。 " }, 
{ "title" : "ライブラリ開発者向けの情報 ", 
"url" : "_cds_library_development_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ ライブラリの使用 \/ ライブラリ開発者向けの情報 ", 
"snippet" : "一貫性の問題を回避し、ユーザーを適切にサポートするために、ライブラリの作成、参照、暗号化、保護、および文書化に関する特定の規則を必ず遵守してください。 以下の説明は、ライブラリ開発の可能性の概要のみを提供します。これらのトピックの詳細については、ライブラリ開発の「LibDevSummary」ガイドラインを参照してください。 詳細については、以下を参照してください。 ライブラリの使用全般的 ライブラリのカテゴリを定義できます。ライブラリは、これらのカテゴリの下のライブラリリポジトリに表示されます。 ライブラリ カテゴリの作成の詳細については、次を参照してください。 図書館のカテゴリー 統合オブジ...", 
"body" : "一貫性の問題を回避し、ユーザーを適切にサポートするために、ライブラリの作成、参照、暗号化、保護、および文書化に関する特定の規則を必ず遵守してください。 以下の説明は、ライブラリ開発の可能性の概要のみを提供します。これらのトピックの詳細については、ライブラリ開発の「LibDevSummary」ガイドラインを参照してください。 詳細については、以下を参照してください。 ライブラリの使用全般的 ライブラリのカテゴリを定義できます。ライブラリは、これらのカテゴリの下のライブラリリポジトリに表示されます。 ライブラリ カテゴリの作成の詳細については、次を参照してください。 図書館のカテゴリー 統合オブジェクトへの明確なアクセスを可能にするために、ライブラリーの名前空間を定義できます。 POU名の前に名前空間を追加することで、アクセスが明確になります。 <名前空間>。<変数名> 例： AC.Module 暗号化されていないライブラリのPOUを開くことができます（ *.library ）ライブラリマネージャでそれぞれのエントリをダブルクリックします。 次のライブラリタイプを作成できます。 *.library ：実装ライブラリ（ライブラリのソースコード） * .compiled-library 、 *.compiled-library-v3 ：保護されたライブラリ ソースコードにアクセスできなくなりました。 *_Itfs.library ：インターフェースライブラリ コンポーネントのインターフェース定義に使用されるオブジェクト（定数、構造、インターフェースなど）のみが含まれ、コードは生成されません。 *_Cnt.library ：コンテナライブラリ POUは含まれていませんが、他のライブラリのみが含まれています したがって、POUがコンテナライブラリのトップレベルで公開されているライブラリのセット全体を便利に統合するために使用されます 外部ライブラリをアプリケーションに統合できます。外部ライブラリは外部でプログラムされます CODESYS 別のプログラミング言語（例：C）。 ライブラリの保護 ソースコードの保護 ライブラリが「コンパイル済みライブラリ」形式で準備されている場合、ライブラリがプロジェクトに統合された後、ライブラリPOUのソースコードは表示されなくなります。 署名 の CODESYS V3 SP15以降では、ライブラリプロジェクトの署名に常に証明書が使用されます（ *.compiled-library-v3 ）。署名は、セキュリティ画面の設定によって実施できます。次に、コンパイルされたライブラリを生成するには、ユーザープロファイルでのコード署名に適した証明書が必要です。 と互換性がなければならないライブラリプロジェクトの場合 CODESYS <V3 SP15（ *.compiled-library ）、秘密鍵と対応するトークンを使用して、安全性の低い署名のみが可能です。これらの非推奨のメソッドは、互換性の理由でのみ使用する必要があります。設定はで構成されます プロジェクト情報 に 署名 タブ。 注：ライブラリーに署名する場合は、より優れたストレージ形式が使用されるため、コンパイラー・バージョン3.5.15.0以降を使用する必要があります。 ライセンス ライセンス（ドングルまたはソフトコンテナ）を使用してライブラリを保護できます。ライセンスで保護されたライブラリは、ライブラリリポジトリにインストールできます。ただし、プロジェクトで使用するには、有効なライセンスがコンピューターに存在している必要があります。ライセンスは、ライセンスマネージャーで管理されます。 ライブラリバージョン システムに複数のバージョンのライブラリを同時にインストールすることができます。 ライブラリの複数のバージョンを同時にプロジェクトに統合することができます。ただし、これを行うことはお勧めしません。この場合、各ライブラリ しなければならない 一意の名前空間とシンボルへのアクセスが割り当てられます しなければならない 資格を得る。 例： V1.SendBlob 、 V2.SendBlob 参照ライブラリ ライブラリを他のライブラリ（参照ライブラリ）に統合できます。入れ子の深さは任意です。 参照されているライブラリをライブラリマネージャに表示するかどうかを定義できます。 ライブラリプレースホルダーを介して参照ライブラリを統合できます。このようにして、バージョンの依存関係やベンダー固有のライブラリを使用する必要性が原因で発生する可能性のある問題を回避できます。 " }, 
{ "title" : "アプリケーションへのライブラリの追加 ", 
"url" : "_cds_adding_libraries_to_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ ライブラリの使用 \/ アプリケーションへのライブラリの追加 ", 
"snippet" : "次の手順では、たとえばライブラリを統合する方法について説明します。 Util ライブラリPOUを使用するためにアプリケーションに追加します。 ライブラリマネージャーを選択し、をクリックします プロジェクト→オブジェクトの編集 エディターで開きます。 ライブラリマネージャーがエディターで開きます。 クリック ライブラリ→ ライブラリを追加 。 The ライブラリを追加 ダイアログが開きます。 ライブラリを検索するには、上記の入力フィールドに文字列として「util」を指定します。 図書館 Util ライブラリビューに表示されます。 ライブラリを選択します Util をクリックします わかった ダイ...", 
"body" : "次の手順では、たとえばライブラリを統合する方法について説明します。 Util ライブラリPOUを使用するためにアプリケーションに追加します。 ライブラリマネージャーを選択し、をクリックします プロジェクト→オブジェクトの編集 エディターで開きます。 ライブラリマネージャーがエディターで開きます。 クリック ライブラリ→ ライブラリを追加 。 The ライブラリを追加 ダイアログが開きます。 ライブラリを検索するには、上記の入力フィールドに文字列として「util」を指定します。 図書館 Util ライブラリビューに表示されます。 ライブラリを選択します Util をクリックします わかった ダイアログを閉じます。 図書館 Util ライブラリマネージャーに追加されます。 詳細については、以下を参照してください。 ライブラリブロックを使用する" }, 
{ "title" : "リポジトリへのライブラリの追加 ", 
"url" : "_cds_adding_libraries_to_repository.html", 
"breadcrumbs" : "CODESYS Essentials \/ ライブラリの使用 \/ リポジトリへのライブラリの追加 ", 
"snippet" : "次の手順では、ライブラリリポジトリにライブラリをインストールする方法について説明します。 クリック ツール→ ライブラリリポジトリ 。 The ライブラリリポジトリ ダイアログが開きます。 クリック インストール ボタン。 インストールするライブラリを選択します。ここでファイルフィルターを設定できます。 クリック 開ける 。 ライブラリがリポジトリに追加されます。これで、ライブラリをライブラリマネージャーに追加できます。...", 
"body" : "次の手順では、ライブラリリポジトリにライブラリをインストールする方法について説明します。 クリック ツール→ ライブラリリポジトリ 。 The ライブラリリポジトリ ダイアログが開きます。 クリック インストール ボタン。 インストールするライブラリを選択します。ここでファイルフィルターを設定できます。 クリック 開ける 。 ライブラリがリポジトリに追加されます。これで、ライブラリをライブラリマネージャーに追加できます。 " }, 
{ "title" : "ライブラリファイルのエクスポート ", 
"url" : "_cds_exporting_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ ライブラリの使用 \/ ライブラリファイルのエクスポート ", 
"snippet" : "プロジェクトのライブラリマネージャーまたはライブラリリポジトリからライブラリをエクスポートして、ファイルとしてハードディスクに保存できます。 ライブラリマネージャーからエクスポート プロジェクトで、 ライブラリマネージャー アプリケーションの。 ライブラリマネージャーでライブラリを選択します。 コンテキストメニューで、[エクスポート]をクリックします。 The ライブラリのエクスポート ダイアログが開きます。 選択したライブラリがコンパイル済みライブラリとしてだけでなく「ソース」形式でもプロジェクトにリンクされている場合、両方のファイルタイプが次のリストボックスに表示されます。 ファイルの種類...", 
"body" : "プロジェクトのライブラリマネージャーまたはライブラリリポジトリからライブラリをエクスポートして、ファイルとしてハードディスクに保存できます。 ライブラリマネージャーからエクスポート プロジェクトで、 ライブラリマネージャー アプリケーションの。 ライブラリマネージャーでライブラリを選択します。 コンテキストメニューで、[エクスポート]をクリックします。 The ライブラリのエクスポート ダイアログが開きます。 選択したライブラリがコンパイル済みライブラリとしてだけでなく「ソース」形式でもプロジェクトにリンクされている場合、両方のファイルタイプが次のリストボックスに表示されます。 ファイルの種類 。それ以外の場合、フィルターは自動的に使用可能なタイプを表示します。 *.library また *.compiled-library 。 ファイルの種類と場所を選択し、をクリックします 保存する 。 ライブラリリポジトリからエクスポートする の中に ツール メニューを開き、 CODESYS ライブラリリポジトリ 。 インストールされているライブラリのウィンドウでライブラリのバージョンを選択します。 クリック 輸出 ボタン。 The ライブラリのエクスポート ダイアログが開きます。 「ライブラリマネージャからのエクスポート」の手順4および5と同様 " }, 
{ "title" : "ライブラリ プレースホルダーの更新 ", 
"url" : "_cds_update_library_placeholders.html", 
"breadcrumbs" : "CODESYS Essentials \/ ライブラリの使用 \/ ライブラリ プレースホルダーの更新 ", 
"snippet" : "プロジェクトがプレースホルダー ライブラリを使用している場合、プレースホルダーが後で読み込まれたときに自動的に解決されなくなる可能性があります。その結果、ロード操作はエラーで終了します。メッセージウィンドウで詳細が通知されます。関連するライブラリと影響を受けるアプリケーションが一覧表示されます。さらに、メッセージには、役立つコマンドを含むクイックフィックス ボタンが用意されています。 指示： プレースホルダー <ライブラリ名> を最新バージョンに更新します : ライブラリの修正済みバージョンを最新バージョンに更新します 指示： ライブラリマネージャーの「プレースホルダー」ダイアログを開く : ...", 
"body" : "プロジェクトがプレースホルダー ライブラリを使用している場合、プレースホルダーが後で読み込まれたときに自動的に解決されなくなる可能性があります。その結果、ロード操作はエラーで終了します。メッセージウィンドウで詳細が通知されます。関連するライブラリと影響を受けるアプリケーションが一覧表示されます。さらに、メッセージには、役立つコマンドを含むクイックフィックス ボタンが用意されています。 指示： プレースホルダー <ライブラリ名> を最新バージョンに更新します : ライブラリの修正済みバージョンを最新バージョンに更新します 指示： ライブラリマネージャーの「プレースホルダー」ダイアログを開く : このダイアログでは、プレースホルダーの解像度を編集できます。詳細については、次を参照してください。 プレースホルダー例 未解決のライブラリ プレースホルダーを含むプロジェクト " }, 
{ "title" : "デバイスの管理 ", 
"url" : "_cds_struct_managing_devices.html", 
"breadcrumbs" : "CODESYS Essentials \/ デバイスの管理 ", 
"snippet" : "CODESYS にインストールされているデバイスを管理します デバイスリポジトリ 。デバイスリポジトリは、ファイルシステム内で定義された場所であり、デフォルトでは、 CODESYS 絶対パスを使用したインストール。でデバイスをインストールまたはアンインストールします デバイスリポジトリ ダイアログ。システムは、デバイス記述ファイルを読み取ることによってデバイスをインストールします。デバイスのプロパティは、構成可能性、プログラム可能性、および他のデバイスへの可能な接続に関して、これらのファイルで定義されています。 プロジェクトのデバイスツリーにデバイスを追加することで、デバイスリポジトリで提供さ...", 
"body" : "CODESYS にインストールされているデバイスを管理します デバイスリポジトリ 。デバイスリポジトリは、ファイルシステム内で定義された場所であり、デフォルトでは、 CODESYS 絶対パスを使用したインストール。でデバイスをインストールまたはアンインストールします デバイスリポジトリ ダイアログ。システムは、デバイス記述ファイルを読み取ることによってデバイスをインストールします。デバイスのプロパティは、構成可能性、プログラム可能性、および他のデバイスへの可能な接続に関して、これらのファイルで定義されています。 プロジェクトのデバイスツリーにデバイスを追加することで、デバイスリポジトリで提供されているデバイスを使用できます。 " }, 
{ "title" : "デバイスのインストール ", 
"url" : "_cds_installing_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ デバイスの管理 \/ デバイスのインストール ", 
"snippet" : "にデバイスをインストールします デバイスリポジトリ それをあなたのプロジェクトに含めるために。 クリック ツール→デバイスリポジトリ 。 The デバイスリポジトリ ダイアログが開きます。 インストール場所を選択します。 システムリポジトリ デフォルトで設定されています。 クリック インストール ボタン。 The インストールデバイスの説明 ダイアログが開きます。 デバイス記述のファイルパスを選択します。 必要なデバイスの説明のファイルタイプフィルターを選択します。 選択したファイルタイプのすべてのデバイスの説明が一覧表示されます。 必要なデバイスの説明を選択して、 開ける 。 CODESYS...", 
"body" : "にデバイスをインストールします デバイスリポジトリ それをあなたのプロジェクトに含めるために。 クリック ツール→デバイスリポジトリ 。 The デバイスリポジトリ ダイアログが開きます。 インストール場所を選択します。 システムリポジトリ デフォルトで設定されています。 クリック インストール ボタン。 The インストールデバイスの説明 ダイアログが開きます。 デバイス記述のファイルパスを選択します。 必要なデバイスの説明のファイルタイプフィルターを選択します。 選択したファイルタイプのすべてのデバイスの説明が一覧表示されます。 必要なデバイスの説明を選択して、 開ける 。 CODESYS デバイスの説明をデバイスリポジトリの一致するカテゴリに追加します。 インストール中にエラーが発生した場合（たとえば、デバイスの説明で参照されているファイルが見つからない場合）、 CODESYS デバイスリポジトリダイアログの下部にそれらを表示します。 " }, 
{ "title" : "パッケージとライセンスの管理 ", 
"url" : "_cds_struct_managing_packages_and_licenses.html", 
"breadcrumbs" : "CODESYS Essentials \/ パッケージとライセンスの管理 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "でのライセンス CODESYS ", 
"url" : "_cds_struct_managing_packages_and_licenses.html#UUID-68845ac9-5153-8336-6398-73964f8ffc47_section-idm4593467822192032668684730962", 
"breadcrumbs" : "CODESYS Essentials \/ パッケージとライセンスの管理 \/ でのライセンス CODESYS ", 
"snippet" : "の標準インストールに加えて CODESYS 、アドオンも利用可能で、料金とライセンスが必要です。これらの製品のライセンスは、 CODESYS GmbH チケット番号の形式で、を使用してインストールできます CODESYS ライセンスマネージャー。 の ライセンスマネージャー ライセンス情報をUSBハードウェアドングルに保存します（ CODESYS ドングル）またはローカルに保存されているソフトコンテナ CodeMeterコントロールセンター 登録されています。ドングルはローカルPCに接続する必要があります。 の中に ライセンスリポジトリ 、中央ライセンスサーバーから各チケット番号の現在の情報を...", 
"body" : "の標準インストールに加えて CODESYS 、アドオンも利用可能で、料金とライセンスが必要です。これらの製品のライセンスは、 CODESYS GmbH チケット番号の形式で、を使用してインストールできます CODESYS ライセンスマネージャー。 の ライセンスマネージャー ライセンス情報をUSBハードウェアドングルに保存します（ CODESYS ドングル）またはローカルに保存されているソフトコンテナ CodeMeterコントロールセンター 登録されています。ドングルはローカルPCに接続する必要があります。 の中に ライセンスリポジトリ 、中央ライセンスサーバーから各チケット番号の現在の情報を取得できます。ライセンスをまだアクティブ化できるかどうか、またはライセンスを返却する必要があるかどうかなど、その他の情報も提供されます。 ライセンスが必要なプラグインもありますが、機能が制限されたライセンスなしで使用することもできます。このような場合、不足しているライセンスに関するメッセージがプラグイン固有の場所に表示されます。このようなプラグイン（アドオン）の例： CODESYS Git 、 CODESYS SVN 、 CODESYS UML ProfessionalDeveloperEditionから。 ネットワークライセンス ：ローカルで登録されたライセンス CodeMeterコントロールセンター ネットワークライセンスとして提供できます。これを行うために、ローカルコンピューターは、許可されたユーザーがライセンスにアクセスして使用できるネットワークサーバーとして構成されます。この構成を使用する必要がある場合は、最初に CodeMeterコントロールセンター そこをクリックします ファイル – WebAdmin CodeMeterWebAdminブラウザを開きます。ブラウザで、現在インストールされているドングルまたはソフトコンテナが下に表示されます 容器 。の 設定 – ベース 、ローカルコンピュータをベースサーバーとして設定できます。 WIBU CodeMeterの現在のヘルプも参照してください。たとえば、 ライセンスへのネットワークサーバーアクセス用のCodeMeterの設定 。 CodeMeter の詳細については、次を参照してください。 Wibu-Systemsのホームページ . 開始時のライセンスチェック CODESYS それが始まるとき、 CODESYS 選択したプロファイルで、ライセンスの対象となるプラグインを確認します。 プロファイルにライセンスの対象となるプラグインが含まれていない場合は、 CODESYS メッセージなしで通常どおりに開始します。 プロファイルにライセンスの対象となるプラグインが含まれている場合は、 CODESYS また、必要なライセンスのドングルがコンピューターのUSBポートに接続されているか、ライセンスのあるソフトコンテナーが登録されている場合も、メッセージなしで起動します。 プロファイルにライセンスが必要なプラグインが含まれているが、ドングル\/ソフトコンテナがない場合、または必要なライセンスが見つからない場合は、起動時に表示されます CODESYS 対話 ライセンスがありません 。あなたはかどうかを決めることができます CODESYS 影響を受けるプラグインなしで開始する必要があります。 注：コマンドラインから開始するときに、を指定すると、このダイアログはスキップされます。 --skipunlicensedplugins コマンドのオプション。この場合、必要なライセンスのないプラグインは自動的にロードされません。 ランタイムモードでのライセンスチェック その間 CODESYS が実行されている場合、必要なライセンスは5分ごとにチェックされます。その間にドングルが取り外されたなどの理由でライセンスが欠落している場合は、 ライセンスがありません ダイアログが開きます。ライセンスなしでも使用できるアドオンの場合、機能範囲は既存または欠落しているライセンスに応じて調整されます。 ドングルが切断されている場合、次のオプションがあります。 ドングルをもう一度挿入してを押します リトライ ：ドングルに不足しているライセンスが含まれている場合は、通常どおり作業を続行できます。 現在のプロジェクトを保存して終了 ： CODESYS プロジェクトを保存して閉じます。 選ぶ ： CODESYS プロジェクトを保存せずに閉じます。 ライセンスドングルを削除した場合 CODESYS プラグインがロードされると、エラーメッセージが表示されます。 この問題を解決するには、ドングルをもう一度挿入して、 Retry ボタン。ドングルに有効なライセンスが含まれている場合、ダイアログが閉じ、通常どおり作業を続行できます。クリック キャンセル 出る CODESYS 。 " }, 
{ "title" : "ライセンスマネージャー ", 
"url" : "_cds_struct_managing_packages_and_licenses.html#UUID-68845ac9-5153-8336-6398-73964f8ffc47_section-idm459346742314563266868591645", 
"breadcrumbs" : "CODESYS Essentials \/ パッケージとライセンスの管理 \/ ライセンスマネージャー ", 
"snippet" : "を使用して ライセンスマネージャー の CODESYS 、アドオン製品のライセンスを管理できます CODESYS ドングルまたは柔らかい容器。ソフトコンテナは、セキュリティキー（ドングル）のソフトウェア版です。その結果、セキュリティキーを使用しなくても、ハードウェアライセンスを個々のPCにリンクできます。 ライセンスマネージャで、 ワークステーション ワークステーションのライセンスを取得し、 デバイス デバイスでライセンスをアクティブ化する場合。...", 
"body" : "を使用して ライセンスマネージャー の CODESYS 、アドオン製品のライセンスを管理できます CODESYS ドングルまたは柔らかい容器。ソフトコンテナは、セキュリティキー（ドングル）のソフトウェア版です。その結果、セキュリティキーを使用しなくても、ハードウェアライセンスを個々のPCにリンクできます。 ライセンスマネージャで、 ワークステーション ワークステーションのライセンスを取得し、 デバイス デバイスでライセンスをアクティブ化する場合。 " }, 
{ "title" : "パッケージマネージャー ", 
"url" : "_cds_struct_managing_packages_and_licenses.html#UUID-68845ac9-5153-8336-6398-73964f8ffc47_section-idm4531453328910432668687302335", 
"breadcrumbs" : "CODESYS Essentials \/ パッケージとライセンスの管理 \/ パッケージマネージャー ", 
"snippet" : "CODESYS を提供します パッケージマネージャー その機能は、の標準インストールを拡張します CODESYS 追加機能と構成設定を備えています。パッケージマネージャーの背後にある概念は、一般的なWindowsインストールメカニズムの概念に似ています。 パッケージは、拡張子が* .packageのZIPファイルです。 可能なパッケージコンポーネント プラグイン ライブラリ デバイスの説明 サプライヤーの説明 プロファイル 情報プロファイル プロファイルの変更 ファイル メニュー、ツールバー、キーボードショートカット、およびビューを構成するための拡張機能 ヘルプモジュール 特別なプロファイルの...", 
"body" : "CODESYS を提供します パッケージマネージャー その機能は、の標準インストールを拡張します CODESYS 追加機能と構成設定を備えています。パッケージマネージャーの背後にある概念は、一般的なWindowsインストールメカニズムの概念に似ています。 パッケージは、拡張子が* .packageのZIPファイルです。 可能なパッケージコンポーネント プラグイン ライブラリ デバイスの説明 サプライヤーの説明 プロファイル 情報プロファイル プロファイルの変更 ファイル メニュー、ツールバー、キーボードショートカット、およびビューを構成するための拡張機能 ヘルプモジュール 特別なプロファイルの完全なメニュー構成 特別なプロファイルの完全なツールバー構成 特別なプロファイル用の完全なキーボード構成 オプション ライブラリプロファイル あなたは比較することができます チェックサム パッケージベンダーからのパッケージチェックサムを使用します。 CODESYS このチェックサムをに表示します 詳細 パッケージマネージャーのダイアログと インストール–ライセンス契約 インストールウィザードのダイアログ。これは、元のパッケージがインストールされていることを確認するために行います。 V3.5 SP13以降では、 CODESYS 開発システムのインストール時に、古いバージョンがすでにインストールされているかどうかを確認します。この場合、開発システムを初めて起動すると、次のように表示されます。 インポートアシスタント 古いバージョンで利用可能なパッケージインストールをインポートするためのダイアログ。 " }, 
{ "title" : "パッケージのインストールとアンインストール ", 
"url" : "_cds_installing_package.html", 
"breadcrumbs" : "CODESYS Essentials \/ パッケージとライセンスの管理 \/ パッケージのインストールとアンインストール ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "使用する CODESYS Installer （デフォルト） ", 
"url" : "_cds_installing_package.html#UUID-98af030d-c9df-9805-ad81-f774bb1247ba_section-idm4675118379435233494746701215", 
"breadcrumbs" : "CODESYS Essentials \/ パッケージとライセンスの管理 \/ パッケージのインストールとアンインストール \/ 使用する CODESYS Installer （デフォルト） ", 
"snippet" : "もし CODESYS Installer がコンピューターにインストールされると、パッケージとアドオンのインストールとアンインストールに使用されます。たとえば、この場合は、 プロジェクト検査ウィザード 、 必要であれば。 インストーラーの詳細については、次を参照してください。 CODESYSインストーラー さらにアドオンのインストールが必要なオブジェクトがプロジェクトに追加されると、 CODESYS 次のように応答します。 対応するメッセージがメッセージ ビューに表示されます。 必要なアドオン メッセージカテゴリ。 テキストを含む黄色で強調表示されたフィールド <n> 個のアドオンがありません...", 
"body" : "もし CODESYS Installer がコンピューターにインストールされると、パッケージとアドオンのインストールとアンインストールに使用されます。たとえば、この場合は、 プロジェクト検査ウィザード 、 必要であれば。 インストーラーの詳細については、次を参照してください。 CODESYSインストーラー さらにアドオンのインストールが必要なオブジェクトがプロジェクトに追加されると、 CODESYS 次のように応答します。 対応するメッセージがメッセージ ビューに表示されます。 必要なアドオン メッセージカテゴリ。 テキストを含む黄色で強調表示されたフィールド <n> 個のアドオンがありません ステータスバーに表示されます。このフィールドをダブルクリックすると、 必要なアドオン ダイアログには、不足しているアドオンが一覧表示されます。インストール後のパッケージを選択して、 インストール を開始するボタン CODESYS Installer . " }, 
{ "title" : "次の場合は、パッケージ マネージャーを使用します。 CODESYS Installer 利用できません ", 
"url" : "_cds_installing_package.html#UUID-98af030d-c9df-9805-ad81-f774bb1247ba_section-idm467511829340963349474202387", 
"breadcrumbs" : "CODESYS Essentials \/ パッケージとライセンスの管理 \/ パッケージのインストールとアンインストール \/ 次の場合は、パッケージ マネージャーを使用します。 CODESYS Installer 利用できません ", 
"snippet" : "もし CODESYS Installer がコンピュータにインストールされていない場合、 パッケージマネージャー 直接ご利用いただけます。これについては、次の手順を参照してください。 要件: を選択しました ツール → パッケージマネージャー 指図。の パッケージマネージャー ダイアログが開いています。 パッケージのインストール クリック インストール 。 の中に 開ける ダイアログで、ファイルディレクトリからパッケージを選択し、をクリックします 開ける 。 The パッケージの署名を確認する ダイアログが開きます。 ダイアログには、選択したパッケージが署名されているかどうか、および署名されて...", 
"body" : "もし CODESYS Installer がコンピュータにインストールされていない場合、 パッケージマネージャー 直接ご利用いただけます。これについては、次の手順を参照してください。 要件: を選択しました ツール → パッケージマネージャー 指図。の パッケージマネージャー ダイアログが開いています。 パッケージのインストール クリック インストール 。 の中に 開ける ダイアログで、ファイルディレクトリからパッケージを選択し、をクリックします 開ける 。 The パッケージの署名を確認する ダイアログが開きます。 ダイアログには、選択したパッケージが署名されているかどうか、および署名されている方法に関する情報が表示されます。パッケージへの署名の詳細については、ツールチップを参照してください。パッケージをダブルクリックすると、パッケージの署名に関するさらに詳細な情報がダイアログに表示されます。 パッケージが自己署名または署名されていない場合は、を選択する必要があります 署名されていないパッケージと自己署名されたパッケージを許可する そのパッケージのインストールを明示的に許可するオプション。 表示された署名に同意する場合は、をクリックします わかった 。 インストールウィザードが開きます。の中に インストール–ライセンス契約 ダイアログ、 CODESYS また、 チェックサム パッケージの。 クリックすると 終了 インストールウィザードの最後のダイアログで、 1つの保留中のインストール パッケージマネージャーの下部に表示されます。パッケージには、 シンボル。 これで、パッケージがコンピューターに解凍され、インストールの準備が整いました。 すべて閉じる CODESYS インスタンス。 パッケージマネージャーは、でパッケージのインストールを実行します CODESYS 。 インストールが完了する前にインストールの概要を表示する場合は、をクリックします。 次 の中に インストール–セットアップが完了しました ダイアログ。インストールを完了するには、をクリックします 終了 の中に インストールの概要 ダイアログ。 概要を見ずにインストールを完了したい場合は、をクリックしてください 終了 の中に インストール–インストールが完了しました ダイアログ。 の場合 CODESYS Package Designer パッケージがインストールされ、インストールするパッケージに新しいバージョンのパッケージマネージャーが必要な場合、インストールウィザードはこれを報告します。パッケージマネージャーの必要なバージョンは、 CODESYS Store International 。 パッケージのアンインストール パッケージを選択します。 クリック アンインストール 。 ウィザードが開き、パッケージをアンインストールするプロセスをガイドします。 クリックしたとき 終了 インストールウィザードの最後のダイアログで、 1つの保留中のインストール パッケージマネージャーの下部に表示されます。パッケージには、 シンボル。 すべて閉じる CODESYS インスタンス。 パッケージマネージャーは、のアンインストールを実行します CODESYS パッケージ。 の中に アンインストール ダイアログをクリックし、をクリックします 終了 アンインストールを完了します。 要件: クリックしました ツール → パッケージマネージャー そしてその パッケージマネージャー ダイアログが開いています。 " }, 
{ "title" : "製品のライセンス ", 
"url" : "_cds_installing_license.html", 
"breadcrumbs" : "CODESYS Essentials \/ パッケージとライセンスの管理 \/ 製品のライセンス ", 
"snippet" : "多くの CODESYS 製品はライセンスで保護されているため、製品を起動する前に製品をアクティブ化する必要があります。の機能を拡張するアドオン製品 CODESYS Development System 通常、ワークステーションライセンスでアクティブ化されます。ライセンスは、 CODESYS Development System ワークステーションのすべてのライセンスを管理するセキュリティキー（ドングル）。別の方法として、一部の製品はまもなくソフトコンテナのライセンスをサポートする予定です。 さらに、の範囲を拡張するSL製品があります CODESYS SoftPLCシステムを制御します。これらの...", 
"body" : "多くの CODESYS 製品はライセンスで保護されているため、製品を起動する前に製品をアクティブ化する必要があります。の機能を拡張するアドオン製品 CODESYS Development System 通常、ワークステーションライセンスでアクティブ化されます。ライセンスは、 CODESYS Development System ワークステーションのすべてのライセンスを管理するセキュリティキー（ドングル）。別の方法として、一部の製品はまもなくソフトコンテナのライセンスをサポートする予定です。 さらに、の範囲を拡張するSL製品があります CODESYS SoftPLCシステムを制御します。これらのシステムは、単一のデバイスライセンスでアクティブ化されます。ライセンスアクティベーションファイルとして提供されるアクティベーションコードは、ターゲットに直接インストールされます。デバイスのライセンス管理も、デバイス内のソフトコンテナ（サポートされている場合）、またはデバイスに接続されたドングルを使用して行われます。 の CODESYS V3.5 SP13以降、ローカルコンピューター上のアドオン製品のライセンス、および単一デバイスライセンスは、 CODESYS ライセンスマネージャー。一意のシリアル番号を持つデバイスの場合、デバイスのライセンス情報が失われた場合、LicenseManagerは自動的に保存されたライセンスバックアップファイルからライセンスを再アクティブ化できます。 可能であれば、オフラインアクティベーションではなくオンラインアクティベーションを介して製品のライセンスを取得してください。 製品サブスクリプションのライセンス更新は自動的に行われます。現在のライセンスステータスは、 ライセンスマネージャー 。 " }, 
{ "title" : "オンラインアクティベーション ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_52e8998a938fd111c0a8646342ceb317", 
"breadcrumbs" : "CODESYS Essentials \/ パッケージとライセンスの管理 \/ 製品のライセンス \/ オンラインアクティベーション ", 
"snippet" : "でアクティベーションが可能です CODESYS Development System の中に ライセンスマネージャー ダイアログ。このための要件は、開発システムがインターネットにアクセスできることです。ターゲットシステム自体はインターネットアクセスを必要としません。 あるいは、次の Web デポでライセンスをアクティベートすることもできます。 https:\/\/license.codesys.com\/index.php 。 WebDepotでのオンラインアクティベーション...", 
"body" : "でアクティベーションが可能です CODESYS Development System の中に ライセンスマネージャー ダイアログ。このための要件は、開発システムがインターネットにアクセスできることです。ターゲットシステム自体はインターネットアクセスを必要としません。 あるいは、次の Web デポでライセンスをアクティベートすることもできます。 https:\/\/license.codesys.com\/index.php 。 WebDepotでのオンラインアクティベーション " }, 
{ "title" : "容器の選択 ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_section-idm4533120839552033964699368144", 
"breadcrumbs" : "CODESYS Essentials \/ パッケージとライセンスの管理 \/ 製品のライセンス \/ 容器の選択 ", 
"snippet" : "これまで、ハードウェア ベースのアクティベーション (CmDongles) には 100,000 以上のファーム コードが使用され、ソフトウェア ベースのアクティベーション (CmActLicenses および CmSoftLicenses) には 5,000,000 以上のファーム コードが使用されてきました。現在、6,000,000以上の範囲で使用できる新しい「ユニバーサルファームコード」が存在します。 「ユニバーサル ファーム コード」は、ハードウェア ベースのコンテナとソフトウェア ベースのコンテナの両方でプログラムできます。 さまざまなコンテナタイプの会社コード: 容器の種類 128...", 
"body" : "これまで、ハードウェア ベースのアクティベーション (CmDongles) には 100,000 以上のファーム コードが使用され、ソフトウェア ベースのアクティベーション (CmActLicenses および CmSoftLicenses) には 5,000,000 以上のファーム コードが使用されてきました。現在、6,000,000以上の範囲で使用できる新しい「ユニバーサルファームコード」が存在します。 「ユニバーサル ファーム コード」は、ハードウェア ベースのコンテナとソフトウェア ベースのコンテナの両方でプログラムできます。 さまざまなコンテナタイプの会社コード: 容器の種類 128-xxx 1xx.xxx = CmDongle Firm Code: CmDongle (ハードウェア) でのみインポート可能 5.xxx.xxx = CmActLicense 会社コード: CmActLicenses (ソフトウェア) としてのみ可能 容器の種類 130-xxx 6.xxx.xxx = ユニバーサル ファーム コード: CmDongle、CmActLicenses、および CmSoftLicenses 用 このファーム コードは新機能をサポートしているため、可能であれば新しい「ユニバーサル ファーム コード」を使用することをお勧めします。 " }, 
{ "title" : "オフラインアクティベーション ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_8604f60bf98a3916c0a8652d01741064", 
"breadcrumbs" : "CODESYS Essentials \/ パッケージとライセンスの管理 \/ 製品のライセンス \/ オフラインアクティベーション ", 
"snippet" : "ワークステーションコンピュータにインターネットアクセスがない場合は、ライセンスアクティベーションファイルを使用して製品をアクティベートできます。あなたはからファイルを取得します CODESYS ライセンスサーバー。これを行うには、インターネットにアクセスできる任意のコンピューターからサーバーに接続し、ファイルを要求します。次に、任意の記憶媒体上のファイルを作業中のコンピューターに転送します。製品は通常どおりそこでアクティブ化されます CODESYS Development System 、ワークステーションライセンスとシングルデバイスライセンスの両方。 インターネットにアクセスできるコンピュー...", 
"body" : "ワークステーションコンピュータにインターネットアクセスがない場合は、ライセンスアクティベーションファイルを使用して製品をアクティベートできます。あなたはからファイルを取得します CODESYS ライセンスサーバー。これを行うには、インターネットにアクセスできる任意のコンピューターからサーバーに接続し、ファイルを要求します。次に、任意の記憶媒体上のファイルを作業中のコンピューターに転送します。製品は通常どおりそこでアクティブ化されます CODESYS Development System 、ワークステーションライセンスとシングルデバイスライセンスの両方。 インターネットにアクセスできるコンピューターをお持ちの場合 CODESYS Development System インストールされていない場合は、開くこともできます CodeMeterコントロールセンター WibuSystemsがライセンスをアクティブ化します。 さらに、に基づくターゲットシステムの場合 CODESYS Control Win また CODESYS Control RTE 、ターゲットで直接単一のデバイスライセンスをアクティブ化できます。これは、次のような開発システムがない場合に役立ちます。 CODESYS Development System 。次に、からライセンスを行うことができます CodeMeterコントロールセンター 、またはブラウザからライセンスをアクティブ化できます。 CodeMeterは、Windowsベースのターゲットシステムにインストールされます。 The CodeMeterコントロールセンター CodeMeterサービスを管理し、 CODESYS 設定。 " }, 
{ "title" : "ローカルコンピューターでのアドオンライセンスのオンラインアクティベーション ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_a896b93ef98a374cc0a8652d00afc374", 
"breadcrumbs" : "CODESYS Essentials \/ パッケージとライセンスの管理 \/ 製品のライセンス \/ ローカルコンピューターでのアドオンライセンスのオンラインアクティベーション ", 
"snippet" : "次の手順では、ドングルを使用してライセンスを実行する方法について説明します。ソフトコンテナによるライセンス供与も同様に行われます。 要件：インターネットにアクセスでき、 CODESYS Development System ライセンスをインストールするコンピューターにインストールされます。ドングルがコンピュータに接続されています。 クリック ツール→ライセンスマネージャー 。 ウィザードは、 License Manager –ターゲットを選択 ダイアログ。 選択する ワークステーション ターゲットとしてクリックします 次 。の中に License Manager –コンテナを選択 ダイアログで...", 
"body" : "次の手順では、ドングルを使用してライセンスを実行する方法について説明します。ソフトコンテナによるライセンス供与も同様に行われます。 要件：インターネットにアクセスでき、 CODESYS Development System ライセンスをインストールするコンピューターにインストールされます。ドングルがコンピュータに接続されています。 クリック ツール→ライセンスマネージャー 。 ウィザードは、 License Manager –ターゲットを選択 ダイアログ。 選択する ワークステーション ターゲットとしてクリックします 次 。の中に License Manager –コンテナを選択 ダイアログで、 ドングル オプションをクリックしてクリックします 次 。 The ライセンスマネージャー ダイアログが開き、ライセンス対象の製品が表示されます。 製品 ライセンスされていないウィンドウ。 製品を選択し、をクリックします ライセンスのインストール 左下のボタン。 The ワークステーションドングルにライセンスをインストールする<ドングルID> – [操作]を選択します ウィザードが開きます。 を選択 ライセンスをアクティブ化する 操作してクリック 次 。 The ワークステーションドングル<ドングルID>にライセンスをインストール–ライセンスをアクティブ化 ダイアログが開きます。 指定します チケットID ソフトウェアベンダーから受け取ったもの。 IDは5つのブロックで構成され、各ブロックには5文字の英数字が含まれています。 を選択 ライセンスサーバー 製品をアクティベートするためのライセンスを提供します。サーバーのURLはソフトウェアベンダーから入手します。 クリック 次 ボタン。 ライセンスサーバーへの接続（ http:\/\/license.codesys.com ） 確立されています。 指定されたチケットにライセンスが1つしかない場合は、サーバーアクションが正常に完了した後、アクティブ化を確認するためのダイアログが開きます。 指定されたチケットに複数のライセンスが含まれている場合、ダイアログ ライセンスのインストール–ライセンスを選択します チケットで管理されているライセンスのリストが表示されます。 有効化する必要のあるライセンスを選択し、をクリックします 次 。 サーバーアクションが正常に完了すると、アクティブ化の確認を示すダイアログが開きます。 別 ブラウザを開き、 ライセンスセントラル インターネットページ。 The ライセンスマネージャー ダイアログが開きます。 ライセンス番号を入力します。 クリック 検索 。 クリック 次 。 ライセンスサーバーへの接続（ http:\/\/license.codesys.com ） 確立されています。 " }, 
{ "title" : "ローカルコンピューターでのアドオンライセンスのオフラインアクティベーション ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_9c3355c9d43311e7a0b8a97e058b4068", 
"breadcrumbs" : "CODESYS Essentials \/ パッケージとライセンスの管理 \/ 製品のライセンス \/ ローカルコンピューターでのアドオンライセンスのオフラインアクティベーション ", 
"snippet" : "要件：アドオンパッケージのライセンスをインストールする必要があります。 The CODESYS Development System ライセンスをインストールするコンピューターにインストールされます。コンピューターにインターネットアクセスがありません。 この方法では、最初に、ターゲットコンピューター上にライセンス要求ファイルを作成します。 CODESYS 。次に、このファイルをインターネットにアクセスできるコンピューターにコピーします。 The CodeMeterコントロールセンター このコンピュータにインストールする必要があります。あなたは CODESYS ターゲットコンピューターでアクティ...", 
"body" : "要件：アドオンパッケージのライセンスをインストールする必要があります。 The CODESYS Development System ライセンスをインストールするコンピューターにインストールされます。コンピューターにインターネットアクセスがありません。 この方法では、最初に、ターゲットコンピューター上にライセンス要求ファイルを作成します。 CODESYS 。次に、このファイルをインターネットにアクセスできるコンピューターにコピーします。 The CodeMeterコントロールセンター このコンピュータにインストールする必要があります。あなたは CODESYS ターゲットコンピューターでアクティベーションするためのライセンスアクティベーションファイルを生成するライセンスサーバー。 次の手順では、ドングルを使用してライセンスを実行する方法について説明します。ソフトコンテナによるライセンス供与も同様に行われます。 クリック ツール→ライセンスマネージャー 。 The ライセンスマネージャー ウィザードが起動します。 選択する ワークステーション ターゲットとして。クリック 次 を選択します ドングル コンテナとして。クリック 次 また。 製品とコンテナを選択するためのダイアログが開きます。 ライセンスをインストールするドングルを選択します。 例： ローカル：CmStick [2-2404696] クリック ライセンスのインストール 。 The ワークステーションドングル<ドングルID>にライセンスをインストール– [操作]を選択します ウィザードが開きます。 を選択 ライセンスをリクエストする オプションをクリックしてクリックします 次 。 The <コンピューター>にライセンスをインストールする–ライセンスを要求する ウィザードが開きます。 の中に ソフトウェアベンダー 入力フィールドに、製品をアクティブ化するためのライセンスを提供したソフトウェアベンダーからの会社コードを指定します。リストボックスからソフトウェアベンダーの名前を選択することもできます。 の場所とファイル名を指定します コンテキストファイル 、 例えば CmStick [2-2404696].WibuCmRaC 。 クリック 終了 。 コンテキストファイル（ *.WibuCmRaC ） 創造された。 このライセンス要求ファイルをインターネットにアクセスできるコンピューターにコピーします。 このコンピューターで、 CODESYS ブラウザのライセンスサーバー（ http:\/\/license.codesys.com ）。 CODESYS ライセンスサーバー： ライセンスチケットの番号を入力して、をクリックします 次 。 次のダイアログで、をクリックします ライセンスをアクティブ化する 。 次のダイアログで、ライセンスのバインディングを選択します。グラフィックをクリックします CODESYS ランタイムキー（ドングル）。 次のダイアログが開きます。 ダイアログで、たとえばライセンスコンテナを選択します 2-2404696 。選択する オフラインライセンス転送 。 次のダイアログが開きます。 他のコンピューターで作成したライセンス要求ファイルを選択し、をクリックします リクエストをアップロードして今すぐ続行 。 次のダイアログが開きます。 ライセンス更新ファイルをコンピューターにロードします。選択する 今すぐライセンス更新ファイルをダウンロード 。 ライセンス更新ファイルをターゲットコンピューターにコピーします。 の中に ライセンスマネージャー ダイアログで、をクリックします ライセンスのインストール ボタンをクリックして選択します ライセンスのインストール オプション。 The ワークステーションドングル<ドングルID>にライセンスをインストール–ライセンスをインストール ダイアログが開きます。 入力フィールドにファイルパスを指定します。 例： D:\\Lic\\CmStick [2-2404696].WibuCmRaU クリック 終了 。 選択したドングルにライセンス更新ファイルがインストールされます。 " }, 
{ "title" : "Windowsベースのランタイムのオフラインアクティベーション ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_bbe1a04a10ae11e897c3e7cd79b8a53c", 
"breadcrumbs" : "CODESYS Essentials \/ パッケージとライセンスの管理 \/ 製品のライセンス \/ Windowsベースのランタイムのオフラインアクティベーション ", 
"snippet" : "Windowsベースのランタイムのライセンスをインストールする必要があります。 この方法では、最初に、ターゲットコンピューター上にライセンス要求ファイルを作成します。 CodeMeterコントロールセンター 。次に、このファイルをインターネットにアクセスできるコンピューターにコピーします。 The CodeMeterコントロールセンター このコンピュータにインストールする必要があります。あなたは CODESYS ライセンスサーバーは、ターゲットコンピューターでアクティブ化するライセンスアクティブ化ファイルを生成します。 初期状況： CODESYS Development System ライセン...", 
"body" : "Windowsベースのランタイムのライセンスをインストールする必要があります。 この方法では、最初に、ターゲットコンピューター上にライセンス要求ファイルを作成します。 CodeMeterコントロールセンター 。次に、このファイルをインターネットにアクセスできるコンピューターにコピーします。 The CodeMeterコントロールセンター このコンピュータにインストールする必要があります。あなたは CODESYS ライセンスサーバーは、ターゲットコンピューターでアクティブ化するライセンスアクティブ化ファイルを生成します。 初期状況： CODESYS Development System ライセンスをインストールするコンピューターにインストールされていません。コンピューターにインターネットアクセスがありません。 を開きます CodeMeterコントロールセンター 。ツールバーで、をダブルクリックします。 システムトレイ（通知領域）のアイコン。 ライセンスメモリを選択します 3S-スマートソフトウェアソリューションソフトライセンス ライセンスの概要で。 クリック ライセンスのアクティブ化 ボタン。 The CmFAS ウィザードが開きます。 クリック 次 。 可能なアクションのリストが表示されます。 選択する ライセンスリクエストの作成 をクリックします 次 。 ライセンス要求ファイルの名前を指定し、をクリックして保存します 申し込み 。ダイアログを閉じます。 ライセンス要求ファイルが生成されます。 例： 32767-4241603201.WibuCmRaC このライセンス要求ファイルをインターネットにアクセスできるコンピューターにコピーします。 このコンピューターで、 CODESYS ブラウザのライセンスサーバー。 CODESYS ライセンスサーバー： ライセンスチケットの番号を入力して、をクリックします 次 。 次のダイアログで、をクリックします ライセンスをアクティブ化する 。 次のダイアログで、ライセンスのバインディングを選択します。グラフィックをクリックします CODESYS ソフトウェアキー（ソフトコンテナ）。 次のダイアログが開きます。 ダイアログで、ライセンスコンテナを選択します。 例： 32767-4241603201（3S-スマートソフトウェアソリューションソフトライセンス クリック オフラインライセンス転送 。 次のダイアログが開きます。 他のコンピューターで作成したライセンス要求ファイルを選択し、をクリックします リクエストをアップロードして今すぐ続行 。 次のダイアログが開きます。 ライセンス更新ファイルをコンピューターにロードします。クリック 今すぐライセンス更新ファイルをダウンロード 。 ファイルを保存するためのダイアログが開きます。 ライセンス更新ファイルを保存し、ターゲットコンピューターにコピーします。 を開きます CodeMeterコントロールセンター 。 ライセンスメモリを選択します 3S-スマートソフトウェアソリューションソフトライセンス ライセンスの概要で。 クリック ライセンスのアクティブ化 ボタン。 The CmFAS ウィザードが開きます。 クリック 次 。 可能なアクションのリストが表示されます。 選択する ライセンスアップデートのインポート をクリックします 次 。 たとえば、ライセンス更新ファイルを選択します 128-9754375.WibuCmRaU 、をクリックします 申し込み 。 選択したドングルにライセンス更新ファイルがインストールされます。 " }, 
{ "title" : "Linuxベースのシステムのオフラインアクティベーション ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_e15f5a8067cfa551c0a864632160e725", 
"breadcrumbs" : "CODESYS Essentials \/ パッケージとライセンスの管理 \/ 製品のライセンス \/ Linuxベースのシステムのオフラインアクティベーション ", 
"snippet" : "Linuxベースのランタイムに単一のライセンスをインストールしたいとします。 要件：開発システムと CODESYS Development System インターネットにアクセスできませんが、デバイスに接続されています。 開ける CODESYS 。 標準プロジェクトを作成します。 デバイスを更新します。 の CODESYS 、 クリック ツール→ライセンスマネージャー 。 ウィザードは、 License Manager –ターゲットを選択 ダイアログ。 選択する 端末 ターゲットとしてクリックします 次 。の中に License Manager –コンテナを選択 ダイアログで、 ソフトコンテナ...", 
"body" : "Linuxベースのランタイムに単一のライセンスをインストールしたいとします。 要件：開発システムと CODESYS Development System インターネットにアクセスできませんが、デバイスに接続されています。 開ける CODESYS 。 標準プロジェクトを作成します。 デバイスを更新します。 の CODESYS 、 クリック ツール→ライセンスマネージャー 。 ウィザードは、 License Manager –ターゲットを選択 ダイアログ。 選択する 端末 ターゲットとしてクリックします 次 。の中に License Manager –コンテナを選択 ダイアログで、 ソフトコンテナ また ドングル オプションをクリックしてクリックします 次 。 The ライセンスマネージャー ダイアログが開きます。ライセンス対象の製品は、 製品 見る。 クリック ライセンスのインストール ボタン。の中に <デバイス>にライセンスをインストールする– [操作]を選択します ダイアログで、 ライセンスをリクエストする オプションをクリックしてクリックします 次 。 The <デバイス>にライセンスをインストールする–ライセンスをリクエストする ダイアログが開きます。 の中に ソフトウェアベンダー 入力フィールドに、製品をアクティブ化するためのライセンスを提供したソフトウェアベンダーからの会社コードを指定します。リストボックスからソフトウェアベンダーの名前を選択することもできます。 の場所とファイル名を指定します コンテキストファイル 。 例： CmStick [2-2404696].WibuCmRaC クリック 終了 。 コンテキストファイル（ *.WibuCmRaC ） 創造された。 更新ファイルを生成します（ *.WibuCmRaU ）ブラウザで。 このライセンス要求ファイルをインターネットにアクセスできるコンピューターにコピーします。 The CodeMeterコントロールセンター このコンピュータにインストールする必要があります。 このコンピューターで、 CODESYS ブラウザのライセンスサーバー（ http:\/\/license.codesys.com ）。 CODESYS ライセンスサーバー： ライセンスチケットの番号を入力して、をクリックします 次 。 次のダイアログで、をクリックします ライセンスをアクティブ化する 。 次のダイアログで、ライセンスのバインディングを選択します。グラフィックをクリックします CODESYS ランタイムキー（ドングル）。 次のダイアログが開きます。 次のダイアログで、ライセンスコンテナを選択します。 例： 2-2404696 クリック オフラインライセンス転送 。 次のダイアログが開きます。 他のコンピューターで作成したライセンス要求ファイルを選択し、をクリックします リクエストをアップロードして今すぐ続行 。 次のダイアログが開きます。 ライセンス更新ファイルをコンピューターにロードします。クリック 今すぐライセンス更新ファイルをダウンロード 。 ライセンス更新ファイルをターゲットコンピューターにコピーします。 の中に ライセンスマネージャー ダイアログで、をクリックします ライセンスのインストール ボタン。 The <デバイス>にライセンスをインストールする– [操作]を選択します ウィザードが開きます。 を選択 ライセンスのインストール オプションをクリックしてクリックします 次 。 入力フィールドで、ライセンスアクティベーションファイルのファイルパスを指定します。 クリック 終了 ライセンスをソフトウェアキー（ソフトコンテナ）に転送します。 ライセンスはアクティブです。 " }, 
{ "title" : "ライセンスの復元 ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_7f6761c2468b3986c0a8646345ba6917", 
"breadcrumbs" : "CODESYS Essentials \/ パッケージとライセンスの管理 \/ 製品のライセンス \/ ライセンスの復元 ", 
"snippet" : "の CODESYS V3.5 SP13以降、ライセンスバックアップファイル（ *.WibuCmRau ）は、一意のシリアル番号を持つデバイスのワークステーションライセンスをアクティブ化するときに自動的に作成されます。ファイルはコンピュータとライセンスサーバーに保存されます。デバイス上のライセンスファイルが失われた場合は、ライセンスマネージャーを使用してこのファイルからライセンスを復元できます。 デバイスライセンスをアクティブ化しました。 の CODESYS 、 クリック ツール→ライセンスマネージャー 。ウィザードに従って、ターゲットに対応するエントリ（デバイスとコンテナ（ソフトコンテナまたは...", 
"body" : "の CODESYS V3.5 SP13以降、ライセンスバックアップファイル（ *.WibuCmRau ）は、一意のシリアル番号を持つデバイスのワークステーションライセンスをアクティブ化するときに自動的に作成されます。ファイルはコンピュータとライセンスサーバーに保存されます。デバイス上のライセンスファイルが失われた場合は、ライセンスマネージャーを使用してこのファイルからライセンスを復元できます。 デバイスライセンスをアクティブ化しました。 の CODESYS 、 クリック ツール→ライセンスマネージャー 。ウィザードに従って、ターゲットに対応するエントリ（デバイスとコンテナ（ソフトコンテナまたはドングル）、および対応するデバイスの選択）を入力します。 の中に ライセンスマネージャー ダイアログで、をクリックします 追加機能 ボタンをクリックして選択します ライセンスの復元 指図。 The ライセンスの復元 ダイアログが開きます。 入力します チケットID デバイスライセンスについては、をクリックしてください 戻す 。 CODESYS 保存されたライセンスバックアップファイルを、最初にローカルコンピューターで検索し、次にLicenseCentralサーバーで検索します。デバイスに一致するファイルが見つかった場合、ライセンスが復元され、アクティブ化されます。 " }, 
{ "title" : "コントローラの製品およびデバイス機能のライセンス情報のリスト ", 
"url" : "_cds_installing_license.html#UUID-5243e462-9b10-b9a1-37f1-2f5405487288_id_f9d93fbf89a6416c0a8640e019e3c97_id_0de8d32402b86f11c0a8646319093e62", 
"breadcrumbs" : "CODESYS Essentials \/ パッケージとライセンスの管理 \/ 製品のライセンス \/ コントローラの製品およびデバイス機能のライセンス情報のリスト ", 
"snippet" : "要件： The CODESYS Development System （V3.5 SP15以降）が開いています。 情報を読み取る必要のあるゲートウェイとコントローラーが実行されています。 コントローラにアプリケーションは存在しません。 クリック ツール → デバイスライセンスリーダー 。 The デバイスを選択 ダイアログが開きます。 目的のゲートウェイをダブルクリックして、ネットワークをスキャンします。 ゲートウェイが表示されていない場合は、 新しいゲートウェイ で目的のゲートウェイを選択します ゲートウェイ ダイアログ。 コントローラを選択します。 クリック わかった 選択を確認します。 ...", 
"body" : "要件： The CODESYS Development System （V3.5 SP15以降）が開いています。 情報を読み取る必要のあるゲートウェイとコントローラーが実行されています。 コントローラにアプリケーションは存在しません。 クリック ツール → デバイスライセンスリーダー 。 The デバイスを選択 ダイアログが開きます。 目的のゲートウェイをダブルクリックして、ネットワークをスキャンします。 ゲートウェイが表示されていない場合は、 新しいゲートウェイ で目的のゲートウェイを選択します ゲートウェイ ダイアログ。 コントローラを選択します。 クリック わかった 選択を確認します。 注：アプリケーションがコントローラーに存在する場合は、すべてのアプリケーションをコントローラーから削除するかどうかを確認するダイアログが開きます。クリックすると 番号 このダイアログでは、コントローラのライセンス情報を読み取ることができません。 The デバイスリーダー コマンドは中止されます。 CODESYS 選択したコントローラーの製品およびデバイス機能のライセンス情報を含むリストを作成し、その情報を デバイスリーダー ダイアログ。 " }, 
{ "title" : "スクリプトの使用 ", 
"url" : "_cds_struct_using_scripts.html", 
"breadcrumbs" : "CODESYS Essentials \/ スクリプトの使用 ", 
"snippet" : "のスクリプト機能を使用 CODESYS 、マウスクリックとテキスト入力を使用して手動で実行する必要があるコマンドや複雑なプログラム操作を自動化できます。 CODESYS ユーザーインターフェース。これらのスクリプトは、 CODESYS ユーザーインターフェイス（コマンドまたは構成済みツールバー）またはWindowsコマンドラインから。 これについてはヘルプを参照してください CODESYS Scripting....", 
"body" : "のスクリプト機能を使用 CODESYS 、マウスクリックとテキスト入力を使用して手動で実行する必要があるコマンドや複雑なプログラム操作を自動化できます。 CODESYS ユーザーインターフェース。これらのスクリプトは、 CODESYS ユーザーインターフェイス（コマンドまたは構成済みツールバー）またはWindowsコマンドラインから。 これについてはヘルプを参照してください CODESYS Scripting. " }, 
{ "title" : "安全 ", 
"url" : "_cds_struct_security.html", 
"breadcrumbs" : "CODESYS Essentials \/ 安全 ", 
"snippet" : "コントローラとプラントのネットワークが増加しているため、潜在的な脅威も急速に高まっています。したがって、考えられるすべての安全対策を慎重に検討する必要があります。 データと通信チャネルを不正アクセスから保護するには、セキュリティ対策が絶対に必要です。 のセキュリティ機能に関する情報と手順については CODESYS 開発環境とコントローラー上: セキュリティー...", 
"body" : "コントローラとプラントのネットワークが増加しているため、潜在的な脅威も急速に高まっています。したがって、考えられるすべての安全対策を慎重に検討する必要があります。 データと通信チャネルを不正アクセスから保護するには、セキュリティ対策が絶対に必要です。 のセキュリティ機能に関する情報と手順については CODESYS 開発環境とコントローラー上: セキュリティー " }, 
{ "title" : "参照：プログラミング ", 
"url" : "_cds_f_reference_programming.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "変換: BOOL ", 
"url" : "_cds_operator_bool_to.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変換: BOOL ", 
"snippet" : "BOOL 演算子 BOOL_TO_<type> は、ブール値を指定されたデータ型に変換し、型変換された値を返します。 呼び出し構文 : < BOOL_TO_<型> ( <オペランド> ) オペランド データタイプ 説明 変数、リテラル BOOL 演算子: BOOL_TO_<type> オペレーター 例 戻り値 説明 BOOL_TO___UXINT BOOL_TO___UXINT(TRUE) 1 __UXINT、__ XINT、__ XWORD BOOL_TO___XINT BOOL_TO___XINT(TRUE) 1 __UXINT、__ XINT、__ XWORD BOOL_TO___XWO...", 
"body" : "BOOL 演算子 BOOL_TO_<type> は、ブール値を指定されたデータ型に変換し、型変換された値を返します。 呼び出し構文 : < BOOL_TO_<型> ( <オペランド> ) オペランド データタイプ 説明 変数、リテラル BOOL 演算子: BOOL_TO_<type> オペレーター 例 戻り値 説明 BOOL_TO___UXINT BOOL_TO___UXINT(TRUE) 1 __UXINT、__ XINT、__ XWORD BOOL_TO___XINT BOOL_TO___XINT(TRUE) 1 __UXINT、__ XINT、__ XWORD BOOL_TO___XWORD BOOL_TO___XWINT(TRUE) 1 __UXINT、__ XINT、__ XWORD BOOL_TO_BIT BOOL_TO___BIT(TRUE) TRUE BIT BOOL_TO_BYTE BOOL_TO_BYTE(TRUE) 1 Integer BOOL_TO_DATE BOOL_TO_DATE(TRUE) D#1970-1-1 0 番目のビットは設定されていますが、表示には影響しません。 データ型: DATE BOOL_TO_DINT BOOL_TO_DINT(TRUE) 1 Integer BOOL_TO_DT BOOL_TO_DT(TRUE) DT#1970-01-01-0:0:1 データ型: DATE BOOL_TO_DWORD BOOL_TO_DWORD(TRUE) 1 Integer BOOL_TO_INT BOOL_TO_INT(TRUE) 1 Integer BOOL_TO_LDATE BOOL_TO_LDATE(TRUE) LD#1970-01-01 0 番目のビットは設定されていますが、表示には影響しません。 データ型: DATE BOOL_TO_LDT BOOL_TO_LD(TRUE) DT#1970-01-01-0:0:1 データ型: DATE BOOL_TO_LINT BOOL_TO_LINT(TRUE) 1 Integer BOOL_TO_LREAL BOOL_TO_LREAL(TRUE) 1 REAL、LREAL BOOL_TO_LTIME BOOL_TO_LTIME(TRUE) LTIME#1NS データ型: DATE BOOL_TO_LTOD BOOL_TO_LTOD(TRUE) LTOD#0:0:0.000000001 データ型: DATE BOOL_TO_LWORD BOOL_TO_LWORD(TRUE) 1 Integer BOOL_TO_REAL BOOL_TO_REAL(TRUE) 1 REAL、LREAL BOOL_TO_SINT BOOL_TO_SINT(TRUE) 1 Integer BOOL_TO_STRING BOOL_TO_STRING(TRUE) 'TRUE' STRING BOOL_TO_TIME BOOL_TO_TIME(TRUE) T#1ms データ型: DATE BOOL_TO_TOD BOOL_TO_TOD(TRUE) TOD#0:0:0.001 データ型: DATE BOOL_TO_UDINT BOOL_TO_UDINT(TRUE) 1 Integer BOOL_TO_UINT BOOL_TO_UINT(TRUE) 1 Integer BOOL_TO_ULINT BOOL_TO_ULINT(TRUE) 1 Integer BOOL_TO_USINT BOOL_TO_ULSINT(TRUE) 1 Integer BOOL_TO_WORD BOOL_TO_WORD(TRUE) 1 Integer BOOL_TO_WSTRING BOOL_TO_WSTRING(TRUE) \"TRUE\" WSTRING" }, 
{ "title" : "例 ", 
"url" : "_cds_operator_bool_to.html#UUID-2a346bdb-4e90-93fe-7336-6fbb8a8d690a_UUID-7cb488ce-e3ad-80d5-81d9-c44c2ef838fa_id_a353abc1de5f9c0a8640e006e95fc_id_a764924bfc35ef1cc0a8646370e2d8a1", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変換: BOOL \/ 例 ", 
"snippet" : "FB_ConvertFromBool STでの宣言 FUNCTION_BLOCK FB_ConvertFromBool VAR uxiReturn_1: __UXINT; uxiReturn_10: __UXINT; iReturn_2: __XINT; iReturn_20: __XINT; xwReturn_3: __XWORD; xwReturn_30: __XWORD; bitReturn_4: BOOL; bitReturn_40: BOOL; bReturn_6: BYTE; bReturn_60: BYTE; dateReturn_7: DATE; dateReturn_70: ...", 
"body" : "FB_ConvertFromBool STでの宣言 FUNCTION_BLOCK FB_ConvertFromBool\nVAR\n uxiReturn_1: __UXINT;\n uxiReturn_10: __UXINT;\n iReturn_2: __XINT;\n iReturn_20: __XINT;\n xwReturn_3: __XWORD;\n xwReturn_30: __XWORD;\n bitReturn_4: BOOL;\n bitReturn_40: BOOL;\n bReturn_6: BYTE;\n bReturn_60: BYTE;\n dateReturn_7: DATE;\n dateReturn_70: DATE;\n dtReturn_8: DATE_AND_TIME;\n dtReturn_80: DATE_AND_TIME;\n diReturn_9: DINT;\n diReturn_90: DINT;\n dtReturn_10: DATE_AND_TIME;\n dtReturn_100: DATE_AND_TIME;\n dwReturn_11: DWORD;\n dwReturn_110: DWORD;\n iReturn_12: INT;\n iReturn_120: INT;\n liReturn_13: LINT;\n liReturn_130: LINT;\n lrReturn_14: LREAL;\n lrReturn_140: LREAL;\n lwReturn_15: LWORD;\n lwReturn_150: LWORD;\n rReturn_16: REAL;\n rReturn_160: REAL;\n siReturn_17: SINT;\n siReturn_170: SINT;\n sReturn_18: STRING;\n sReturn_180: STRING;\n todReturn_19: TIME_OF_DAY;\n todReturn_190: TIME_OF_DAY;\n timReturn_20: TIME;\n timReturn_200: TIME;\n todReturn_21: TIME_OF_DAY;\n todReturn_210: TIME_OF_DAY;\n udiReturn_22: UDINT;\n udiReturn_220: UDINT;\n uiReturn_23: UINT;\n uiReturn_230: UINT;\n uliReturn_24: ULINT;\n uliReturn_240: ULINT;\n usiReturn_25: USINT;\n usiReturn_250: USINT;\n wReturn_26: WORD;\n wReturn_260: WORD;\n wsReturn_27: WSTRING;\n wsReturn_270: WSTRING;\nEND_VAR\n STでの実装 FUNCTION_BLOCK FB_ConvertFromBool\nVAR\nVAR\n uxiReturn_1: __UXINT;\n uxiReturn_10: __UXINT;\n iReturn_2: __XINT;\n iReturn_20: __XINT;\n xwReturn_3: __XWORD;\n xwReturn_30: __XWORD;\n bitReturn_4: BOOL;\n bitReturn_40: BOOL;\n bReturn_6: BYTE;\n bReturn_60: BYTE;\n dateReturn_7: DATE;\n dateReturn_70: DATE;\n dtReturn_8: DATE_AND_TIME;\n dtReturn_80: DATE_AND_TIME;\n diReturn_9: DINT;\n diReturn_90: DINT;\n dtReturn_10: DATE_AND_TIME;\n dtReturn_100: DATE_AND_TIME;\n dwReturn_11: DWORD;\n dwReturn_110: DWORD;\n iReturn_12: INT;\n iReturn_120: INT;\n liReturn_13: LINT;\n liReturn_130: LINT;\n lrReturn_14: LREAL;\n lrReturn_140: LREAL;\n lwReturn_15: LWORD;\n lwReturn_150: LWORD;\n rReturn_16: REAL;\n rReturn_160: REAL;\n siReturn_17: SINT;\n siReturn_170: SINT;\n sReturn_18: STRING;\n sReturn_180: STRING;\n todReturn_19: TIME_OF_DAY;\n todReturn_190: TIME_OF_DAY;\n timReturn_20: TIME;\n timReturn_200: TIME;\n todReturn_21: TIME_OF_DAY;\n todReturn_210: TIME_OF_DAY;\n udiReturn_22: UDINT;\n udiReturn_220: UDINT;\n uiReturn_23: UINT;\n uiReturn_230: UINT;\n uliReturn_24: ULINT;\n uliReturn_240: ULINT;\n usiReturn_25: USINT;\n usiReturn_250: USINT;\n wReturn_26: WORD;\n wReturn_260: WORD;\n wsReturn_27: WSTRING;\n wsReturn_270: WSTRING;\nEND_VAR\n\n\/\/ Return value of operand = TRUE or FALSE\nuxiReturn_1 := BOOL_TO___UXINT(TRUE);\nuxiReturn_10 := BOOL_TO___UXINT(FALSE);\n\niReturn_2 := BOOL_TO___XINT(TRUE);\niReturn_20 := BOOL_TO___XINT(FALSE);\n\nxwReturn_3 := BOOL_TO___XWORD(TRUE);\nxwReturn_30 := BOOL_TO___XWORD(FALSE);\n\nbitReturn_4 := BOOL_TO_BIT(TRUE);\nbitReturn_40 := BOOL_TO_BIT(FALSE);\n\nbReturn_6 := BOOL_TO_BYTE(TRUE);\nbReturn_60 := BOOL_TO_BYTE(FALSE);\n\ndateReturn_7 := BOOL_TO_DATE(TRUE);\ndateReturn_70 := BOOL_TO_DATE(FALSE);\n\ndtReturn_8 := BOOL_TO_DT(TRUE);\ndtReturn_80 := BOOL_TO_DT(FALSE);\n\ndiReturn_9 := BOOL_TO_DINT(TRUE);\ndiReturn_90 := BOOL_TO_DINT(FALSE);\n\ndwReturn_11 := BOOL_TO_DWORD(TRUE);\ndwReturn_110 := BOOL_TO_DWORD(FALSE);\n\niReturn_12 := BOOL_TO_INT(TRUE);\niReturn_120 := BOOL_TO_INT(FALSE);\n\nliReturn_13 := BOOL_TO_LINT(TRUE);\nliReturn_130 := BOOL_TO_LINT(FALSE);\n\nlrReturn_14 := BOOL_TO_LREAL(TRUE);\nlrReturn_140 := BOOL_TO_LREAL(FALSE);\n\nlwReturn_15 := BOOL_TO_LWORD(TRUE);\nlwReturn_150 := BOOL_TO_LWORD(FALSE);\n\nrReturn_16 := BOOL_TO_REAL(TRUE);\nrReturn_160 := BOOL_TO_REAL(FALSE);\n\nsiReturn_17 := BOOL_TO_SINT(TRUE);\nsiReturn_170 := BOOL_TO_SINT(FALSE);\n\nsReturn_18 := BOOL_TO_STRING(TRUE);\nsReturn_180 := BOOL_TO_STRING(FALSE);\n\ntimReturn_20 := BOOL_TO_TIME(TRUE);\ntimReturn_200 := BOOL_TO_TIME(FALSE);\n\ntodReturn_21 := BOOL_TO_TOD(TRUE);\ntodReturn_210 := BOOL_TO_TOD(FALSE);\n\nudiReturn_22 := BOOL_TO_UDINT(TRUE);\nudiReturn_220 := BOOL_TO_UDINT(FALSE);\n\nuiReturn_23 := BOOL_TO_UINT(TRUE);\nuiReturn_230 := BOOL_TO_UINT(FALSE);\n\nuliReturn_24 := BOOL_TO_ULINT(TRUE);\nuliReturn_240 := BOOL_TO_ULINT(FALSE);\n\nusiReturn_25 := BOOL_TO_USINT(TRUE);\nusiReturn_250 := BOOL_TO_USINT(FALSE);\n\nwReturn_26 := BOOL_TO_WORD(TRUE);\nwReturn_260 := BOOL_TO_WORD(FALSE);\n\nwsReturn_27 := BOOL_TO_WSTRING(TRUE);\nwsReturn_270 := BOOL_TO_WSTRING(FALSE); FB_FbdConvertBool FBD実装言語 " }, 
{ "title" : "プログラミング言語とエディター ", 
"url" : "_cds_struct_reference_programming_languages_and_editors.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター ", 
"snippet" : "いずれの場合も、POUの作成時に選択した実装言語のエディターでPOUをプログラムします。 CODESYSは、ST用のテキストエディタとSFC、FBD \/ LD \/ IL、およびCFC用のグラフィックエディタを提供します。 デバイスツリーまたはでPOUをダブルクリックして、エディターを開きます。 POU 見る。 各実装言語エディターは、2つのサブウィンドウで構成されています。 上部では、テキスト形式または表形式の設定に応じて、「宣言エディタ」で宣言を定義します。 下部に、それぞれの言語で実装コードを挿入します。 プロジェクト全体の各エディターの外観と動作は、の対応するタブで構成できます。 COD...", 
"body" : "いずれの場合も、POUの作成時に選択した実装言語のエディターでPOUをプログラムします。 CODESYSは、ST用のテキストエディタとSFC、FBD \/ LD \/ IL、およびCFC用のグラフィックエディタを提供します。 デバイスツリーまたはでPOUをダブルクリックして、エディターを開きます。 POU 見る。 各実装言語エディターは、2つのサブウィンドウで構成されています。 上部では、テキスト形式または表形式の設定に応じて、「宣言エディタ」で宣言を定義します。 下部に、それぞれの言語で実装コードを挿入します。 プロジェクト全体の各エディターの外観と動作は、の対応するタブで構成できます。 CODESYS オプション。 " }, 
{ "title" : "宣言エディター ", 
"url" : "_cds_edt_declaration_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 宣言エディター ", 
"snippet" : "宣言エディタでは、 宣言する 変数リストおよびPOU内の変数。 宣言エディタを使用する場合 実装言語エディター 、次に、実装言語エディタの上のビューで開きます。 宣言エディタは、2つの可能なビューを提供します：テキスト ビューと表形式 見る。 で 宣言エディタでは、テキスト ビューのみを使用できるか、表形式ビューのみを使用できるか、またはエディタ ビューの右側にあるボタンを使用して両方のビューを切り替えることができるかどうかを定義します。 テキスト行が長いためにエディター ウィンドウにスクロール バーが表示される場合は、ボタンを押しながらマウス ホイールを回すとスクロールできます。 シフト 鍵...", 
"body" : "宣言エディタでは、 宣言する 変数リストおよびPOU内の変数。 宣言エディタを使用する場合 実装言語エディター 、次に、実装言語エディタの上のビューで開きます。 宣言エディタは、2つの可能なビューを提供します：テキスト ビューと表形式 見る。 で 宣言エディタでは、テキスト ビューのみを使用できるか、表形式ビューのみを使用できるか、またはエディタ ビューの右側にあるボタンを使用して両方のビューを切り替えることができるかどうかを定義します。 テキスト行が長いためにエディター ウィンドウにスクロール バーが表示される場合は、ボタンを押しながらマウス ホイールを回すとスクロールできます。 シフト 鍵。エディタウィンドウを拡大するには、マウスホイールを押しながらマウスホイールを回転させます。 Ctrl 鍵。 オンラインモードの宣言エディタ オンラインモードでは、エディターの表形式のビューが表示されます。ヘッダーには常に現在のオブジェクトパスが含まれます。 <device name>.<application name>.<object name> 。オフラインモードとは対照的に、テーブルには 価値 と 準備された価値 列。 The 価値 列は、監視機能を提供するPLCの実際の値を示しています。式が1,000を超える要素を持つ配列である場合は、監視する配列インデックスの範囲を定義できます。これを行うには、をダブルクリックします データ・タイプ 開く列 モニタリングエリア ダイアログ。このダイアログでは、宣言された配列範囲は次のように指定されます。 有効な領域 監視用。アレイごとに最大20,000個の要素を監視できます。監視する配列インデックスの範囲を定義するには、 始める と 終わり インデックス。同じサイズを維持しながらこの領域をより簡単に移動するために、使用可能なスクロールバーを組み合わせて使用できます。切り替えるには 結合され、 結合されていない場合は、バーの右側にある記号をクリックします。非結合状態では、必要に応じて、監視する領域のサイズを拡大または縮小できます。 の 準備された値 列には、次の値が含まれます 準備した のために 強制または書き込み 。 ダブルクリックすると 準備された価値 フィールドに入力すると、書き込みまたは強制の値を明示的に指定できます。列挙の場合、コンボボックスが開き、そこから値を選択できます。ブール変数の場合、準備された値を 入力 キーまたは 空 バー。 式（変数）が構造化データ型である場合、たとえば、関数ブロックや配列変数のインスタンスの場合、プラス記号またはマイナス記号が前に配置されます。 浮動小数点値の表現の形式をカスタマイズできます。 オプション 監視用。 " }, 
{ "title" : "グラフィックエディタの一般的な機能 ", 
"url" : "_cds_common_functionalities_in_grafic_editors.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ グラフィックエディタの一般的な機能 ", 
"snippet" : "FBD、LD、CFC、およびSFCのグラフィカルエディタの実装部分には、右下隅にツールバーが含まれています。 通常の編集モードに戻ります マウスポインタがデフォルトの矢印の形に戻ります。エディタービューで要素を選択および編集できます。 パンツール マウスポインタが2つの交差した矢印の形に変わります。エディタービューの任意の場所をクリックしてドラッグし、FBD \/ LD \/ ILエディターの表示領域を移動したり、CFCチャートをピボットしたりできます。 倍率ツール 拡大されたウィンドウがエディタービューの右下隅に開き、マウスポインターが十字の形に変わります。ダイアグラム上でマウスポインタを動かす...", 
"body" : "FBD、LD、CFC、およびSFCのグラフィカルエディタの実装部分には、右下隅にツールバーが含まれています。 通常の編集モードに戻ります マウスポインタがデフォルトの矢印の形に戻ります。エディタービューで要素を選択および編集できます。 パンツール マウスポインタが2つの交差した矢印の形に変わります。エディタービューの任意の場所をクリックしてドラッグし、FBD \/ LD \/ ILエディターの表示領域を移動したり、CFCチャートをピボットしたりできます。 倍率ツール 拡大されたウィンドウがエディタービューの右下隅に開き、マウスポインターが十字の形に変わります。ダイアグラム上でマウスポインタを動かすと、拡大ツールは、100％の倍率で十字の下のダイアグラムの領域を表示します。注：ビューをクリックすると、拡大ツールが閉じ、ツールに含まれている図の一部が100％の倍率で表示されます。設定したズーム率を維持したい場合は、 デフォルトの編集モードに戻ります。 ズームツール これにより、ズーム率を選択したリストボックスが開きます。その他の選択肢をクリックする（ ... ）を開きます ズーム 他の値を入力するためのダイアログ。現在のズーム率は常に記号の左側に表示されます。 スクロールホイールによるズーム： Ctrl キーを押してスクロールホイールを動かすと、ズーム率を10％刻みで変更できます。 すべてのグラフィカルエディタには独自の ツールボックス デフォルトでは、エディタービューの右側にあるビュー。ツールボックスには、エディタビューの挿入ポイントにドラッグできる要素が含まれています。 CODESYS ダイヤモンド、三角形、または矢印の形をした灰色の位置フラグで挿入ポイントを強調表示します。これらのフラグの上にマウスポインタを移動すると、これらのフラグは緑色になります。マウスボタンを離すと、 CODESYS 選択した位置に要素を挿入します。 エディターで要素を移動するためにマウスを使用することもできます。 FBD、LD、およびCFCグラフィカルエディタの機能ブロック宣言をエディタビューにドラッグできます。これを行うには、完全な宣言（変数名とデータ型）を選択し、エディタービューの適切な位置にドラッグします。ラダー図では、ブール宣言をエディタにドラッグして、連絡先として挿入することもできます。 " }, 
{ "title" : "構造化テキストおよび拡張構造化テキスト（ExST） ", 
"url" : "_cds_st_f_language.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "STエディター ", 
"url" : "_cds_edt_st_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ STエディター ", 
"snippet" : "STエディターは、 実装 構造化テキスト（ST）および拡張構造化テキスト（ExST）のコードの例。 エディターの左側に行番号が表示されます。プログラミング要素を入力するとき、「コンポーネントのリスト」機能（ CODESYS オプション、 SmartCoding カテゴリ）および入力アシスタント（ F2 ）も便利です。カーソルを変数の上に置くと、 CODESYS は、変数を宣言するための情報を含むツールチップを示しています。 ボックスの選択は、次のキーの組み合わせで行うことができます。 シフト + Alt + 右矢印 ：選択した領域が1つ右に拡張されます。 シフト + Alt + 左矢印 ：選択...", 
"body" : "STエディターは、 実装 構造化テキスト（ST）および拡張構造化テキスト（ExST）のコードの例。 エディターの左側に行番号が表示されます。プログラミング要素を入力するとき、「コンポーネントのリスト」機能（ CODESYS オプション、 SmartCoding カテゴリ）および入力アシスタント（ F2 ）も便利です。カーソルを変数の上に置くと、 CODESYS は、変数を宣言するための情報を含むツールチップを示しています。 ボックスの選択は、次のキーの組み合わせで行うことができます。 シフト + Alt + 右矢印 ：選択した領域が1つ右に拡張されます。 シフト + Alt + 左矢印 ：選択した領域が1つ左に拡張されます。 シフト + Alt + 上矢印 ：選択した領域が1つ上に拡張されます。 シフト + Alt + 下矢印 ：選択した領域が1つ下に拡張されます。 テキスト行が長くてエディタ ウィンドウにスクロール バーが表示される場合は、 シフト 鍵。 を押しながらマウスホイールを回すと、エディタウィンドウのズームインが可能です。 コントロール 鍵。 エディターの動作（括弧、マウスアクション、タブなど）と外観は、 CODESYS のオプション テキストエディタ カテゴリー。 エディターで文字列を段階的に検索するには、キーの組み合わせを使用して、エディターの下端にある入力フィールドを開きます。 Ctrl + シフト + 私 。文字の入力を開始するとすぐに、対応する検索場所がエディターで色で強調表示されます。見つかった一致の数は、入力フィールドの右側に表示されます。矢印キーまたはキーの組み合わせを使用して、検索位置にカーソルを設定できます Alt + ページアップ また Alt + ページダウン 。 シンボル名にカーソルを合わせると、エディター内のシンボルのすべての出現位置が色で強調表示されます。検索場所は、のヒットに対応します 相互参照リスト 。非常に大規模なプロジェクトの場合、これにより入力遅延が発生する可能性があります。この場合、テキストエディタのオプションで機能を無効にすることができます。 CODESYS エディターに入力するときにすでに構文エラーを識別し、対応するメッセージを メッセージビュー （（ プリコンパイル カテゴリー）。対応するオプションがで選択されている場合 CODESYS オプション（ SmartCoding カテゴリ）の場合、テキスト内のエラーの場所にも波状の赤い線で下線が引かれます。 " }, 
{ "title" : "オンラインモードのSTエディタ ", 
"url" : "_cds_st_editor_in_online_mode.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ オンラインモードのSTエディタ ", 
"snippet" : "オンラインモードでは、 CODESYS STエディタで変数と式を表示します（ 価値の監視）。 書くことと強制すること 変数と式だけでなく デバッグ 機能（ブレークポイント、シングルステップ処理）と フロー制御 も可能です。 割り当てを 表現 ST プログラミングでは、行内にブレーク位置は作成されません。...", 
"body" : "オンラインモードでは、 CODESYS STエディタで変数と式を表示します（ 価値の監視）。 書くことと強制すること 変数と式だけでなく デバッグ 機能（ブレークポイント、シングルステップ処理）と フロー制御 も可能です。 割り当てを 表現 ST プログラミングでは、行内にブレーク位置は作成されません。 " }, 
{ "title" : "ST 式 ", 
"url" : "_cds_st_expressions.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ ST 式 ", 
"snippet" : "式は、評価後に値を返す構造です。 式は演算子とオペランドで構成されます。で 拡張構造化テキスト (ExST) 、代入を式として使用することもできます。 オペランドには、定数、変数、関数呼び出し、または別の式を指定できます。 特別な ST 式には次のようなものもあります。 アクセス に 配列変数の要素 構造体変数の構成要素 ファンクションブロックインスタンスまたはプログラムの変数 メソッド呼び出し 例 2014 定数、リテラル ivar 変数 fct(a,b) 関数呼び出し (x*y)\/z 表現 real_var2 := int.var; ExST: 割り当て...", 
"body" : "式は、評価後に値を返す構造です。 式は演算子とオペランドで構成されます。で 拡張構造化テキスト (ExST) 、代入を式として使用することもできます。 オペランドには、定数、変数、関数呼び出し、または別の式を指定できます。 特別な ST 式には次のようなものもあります。 アクセス に 配列変数の要素 構造体変数の構成要素 ファンクションブロックインスタンスまたはプログラムの変数 メソッド呼び出し 例 2014 定数、リテラル ivar 変数 fct(a,b) 関数呼び出し (x*y)\/z 表現 real_var2 := int.var; ExST: 割り当て " }, 
{ "title" : "式の評価 ", 
"url" : "_cds_st_expressions.html#UUID-60e5105f-e6ee-c431-74b7-012ca1a132d4_id_d5c8c87f0b362c0a8640e007534c3_id_e52a54881e8f8d57c0a8640e01163600", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ ST 式 \/ 式の評価 ", 
"snippet" : "式は、 演算子 特定の拘束ルールに従って。 CODESYS 最初に、最も強いバインディングを持つ演算子を処理します。同じ結合強度を持つ演算子は左から右に処理されます。 手術 シンボル 結合強度 ブラケット ( <式> ) 最強の結合力 関数呼び出し <関数名> ( <パラメータリスト> ) すべての演算子の構文は次のとおりです。 <演算子> () べき乗 EXPT 否定する 補完 - NOT 乗算 分割 モジュロ * \/ MOD 追加 引き算 + - 比較する < 、 > 、 <= 、 >= 平等 不平等 = <> ブール演算子 AND AND 、 AND_THEN ブールXOR ブールOR ...", 
"body" : "式は、 演算子 特定の拘束ルールに従って。 CODESYS 最初に、最も強いバインディングを持つ演算子を処理します。同じ結合強度を持つ演算子は左から右に処理されます。 手術 シンボル 結合強度 ブラケット ( <式> ) 最強の結合力 関数呼び出し <関数名> ( <パラメータリスト> ) すべての演算子の構文は次のとおりです。 <演算子> () べき乗 EXPT 否定する 補完 - NOT 乗算 分割 モジュロ * \/ MOD 追加 引き算 + - 比較する < 、 > 、 <= 、 >= 平等 不平等 = <> ブール演算子 AND AND 、 AND_THEN ブールXOR ブールOR XOR OR 、 OR_ELSE 最も弱い結合 " }, 
{ "title" : "課題 ", 
"url" : "_cds_st_f_assignments.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ 課題 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "ST代入演算子 ", 
"url" : "_cds_st_operator_assignment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ 課題 \/ ST代入演算子 ", 
"snippet" : "構文： <operand> ：= <expression> この代入演算子は、 動く オペレーター。...", 
"body" : "構文： <operand> ：= <expression> この代入演算子は、 動く オペレーター。 " }, 
{ "title" : "出力のST代入演算子 ", 
"url" : "_cds_st_operator_output_assignment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ 課題 \/ 出力のST代入演算子 ", 
"snippet" : "代入演算子 => 関数、関数ブロック、またはメソッドの出力を変数に割り当てます。演算子の右側の位置も空白にすることができます。 構文 <output> => <variable> 例 FBcomp_Output1 => bVar1; FBcomp_Output2 => ; FBcom_Output1 と FB_Output2 機能ブロックの出力です。の値 FBcom_Output1 変数に割り当てられます bVar1 。...", 
"body" : "代入演算子 => 関数、関数ブロック、またはメソッドの出力を変数に割り当てます。演算子の右側の位置も空白にすることができます。 構文 <output> => <variable> 例 FBcomp_Output1 => bVar1;\nFBcomp_Output2 => ; FBcom_Output1 と FB_Output2 機能ブロックの出力です。の値 FBcom_Output1 変数に割り当てられます bVar1 。 " }, 
{ "title" : "ExST割り当て：S = ", 
"url" : "_cds_exst_operator_s.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ 課題 \/ ExST割り当て：S = ", 
"snippet" : "セット代入のオペランドがに切り替わるとき TRUE 、 それから TRUE 演算子の左側の変数に割り当てられます。変数が設定されます。 <variable name> S= <operand name> ; 変数とオペランドのデータ型は BOOL 。 例 PROGRAM PLC_PRG VAR xOperand: BOOL := FALSE; xSetVariable: BOOL := FALSE; END_VAR xSetVariable S= xOperand; オペランドが xOperand からのスイッチ FALSE に TRUE 、 それから TRUE 変数にも割り当てられます xS...", 
"body" : "セット代入のオペランドがに切り替わるとき TRUE 、 それから TRUE 演算子の左側の変数に割り当てられます。変数が設定されます。 <variable name> S= <operand name> ; 変数とオペランドのデータ型は BOOL 。 例 PROGRAM PLC_PRG\nVAR\n xOperand: BOOL := FALSE;\n xSetVariable: BOOL := FALSE;\nEND_VAR\n\nxSetVariable S= xOperand; オペランドが xOperand からのスイッチ FALSE に TRUE 、 それから TRUE 変数にも割り当てられます xSetVariable 。ただし、オペランドが状態を変更し続けても、変数はこの状態を維持します。 " }, 
{ "title" : "複数の割り当て ", 
"url" : "_cds_exst_operator_s.html#UUID-3e454082-8249-f217-17c5-ea427ca5ffa0_id_c050b3abf83e2bc0a8640e009a32a5_id_3abde2ab930da820c0a8646307965b6a", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ 課題 \/ ExST割り当て：S = \/ 複数の割り当て ", 
"snippet" : "コード行内の複数の割り当ての場合、個々の割り当ては右から左に処理されませんが、すべての割り当てはコード行の最後にあるオペランドを参照します。 例 FUNCTION funCompute : BOOL VAR_INPUT xIn : BOOL; END_VAR IF xIn = TRUE THEN funCompute := TRUE; RETURN; END_IF PROGRAM PLC_PRG VAR xSetVariable: BOOL; xResetVariable: BOOL := TRUE; xVar: BOOL; END_VAR xSetVariable S= xResetVari...", 
"body" : "コード行内の複数の割り当ての場合、個々の割り当ては右から左に処理されませんが、すべての割り当てはコード行の最後にあるオペランドを参照します。 例 FUNCTION funCompute : BOOL\nVAR_INPUT\n xIn : BOOL;\nEND_VAR\nIF xIn = TRUE THEN\n funCompute := TRUE;\n RETURN;\nEND_IF\n\nPROGRAM PLC_PRG\nVAR\n xSetVariable: BOOL;\n xResetVariable: BOOL := TRUE;\n xVar: BOOL;\nEND_VAR\nxSetVariable S= xResetVariable R= funCompute(xIn := xVar); xResetVariable 取得します R= の戻り値の割り当て funCompute 。 xSetVariable 取得します S= のht戻り値の割り当て funCompute 、しかしからではない xResetVariable 。 " }, 
{ "title" : "ExST割り当て：R = ", 
"url" : "_cds_exst_operator_r.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ 課題 \/ ExST割り当て：R = ", 
"snippet" : "リセット割り当てのオペランドがに切り替わるとき TRUE 、 それから FALSE 演算子の左側の変数に割り当てられます。変数がリセットされます。 <variable name> R= <operand name> ; 変数とオペランドのデータ型は BOOL 。 例 VAR xOperand: BOOL := FALSE; xResetVariable: BOOL := TRUE; END_VAR xResetVariable R= xOperand; オペランドが xOperand からのスイッチ FALSE に TRUE 、 それから FALSE 変数にも割り当てられます xResetVa...", 
"body" : "リセット割り当てのオペランドがに切り替わるとき TRUE 、 それから FALSE 演算子の左側の変数に割り当てられます。変数がリセットされます。 <variable name> R= <operand name> ; 変数とオペランドのデータ型は BOOL 。 例 VAR\n xOperand: BOOL := FALSE;\n xResetVariable: BOOL := TRUE;\nEND_VAR\n\nxResetVariable R= xOperand; オペランドが xOperand からのスイッチ FALSE に TRUE 、 それから FALSE 変数にも割り当てられます xResetVariable 。ただし、オペランドが状態を変更し続けても、変数はその状態を保持します。 " }, 
{ "title" : "複数の割り当て ", 
"url" : "_cds_exst_operator_r.html#UUID-1891bf0f-9a33-b0eb-d3ff-5838f6d073d1_id_d90635bdac550e0ac0a8640e010769d8_id_e67e66ad930a59e8c0a86463664c9b5c", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ 課題 \/ ExST割り当て：R = \/ 複数の割り当て ", 
"snippet" : "コード行内の複数の割り当ての場合、個々の割り当ては右から左に処理されませんが、すべての割り当てはコード行の最後にあるオペランドを参照します。 例 FUNCTION funCompute : BOOL VAR_INPUT xIn : BOOL; END_VAR IF xIn = TRUE THEN funCompute := TRUE; RETURN; END_IF PROGRAM PLC_PRG VAR xSetVariable: BOOL; xResetVariable: BOOL := TRUE; xVar: BOOL; END_VAR xSetVariable S= xResetVari...", 
"body" : "コード行内の複数の割り当ての場合、個々の割り当ては右から左に処理されませんが、すべての割り当てはコード行の最後にあるオペランドを参照します。 例 FUNCTION funCompute : BOOL\nVAR_INPUT\n xIn : BOOL;\nEND_VAR\nIF xIn = TRUE THEN\n funCompute := TRUE;\n RETURN;\nEND_IF\n\nPROGRAM PLC_PRG\nVAR\n xSetVariable: BOOL;\n xResetVariable: BOOL := TRUE;\n xVar: BOOL;\nEND_VAR\nxSetVariable S= xResetVariable R= funCompute(xIn := xVar); xResetVariable 取得します R= の戻り値の割り当て funCompute 。 xSetVariable 取得します S= のht戻り値の割り当て funCompute 、しかしからではない xResetVariable 。 " }, 
{ "title" : "式としてのExST割り当て ", 
"url" : "_cds_exst_operator_expression.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ 課題 \/ 式としてのExST割り当て ", 
"snippet" : "の ExST 、IEC 61131-3規格の拡張として、 CODESYS 式としての割り当ての使用を許可します。 例 int_var1 := int_var2 := int_var3 + 9; （* int_var1 と int_var2 の値を受け取る int_var3 + 9 *） real_var1 := real_var2 := int_var; （* real_var1 と real_var2 の値を取得します int_var *） int_var := real_var1 := int_var; （*誤った割り当て、データ型が対応していません*） IF b := (i = 1) T...", 
"body" : "の ExST 、IEC 61131-3規格の拡張として、 CODESYS 式としての割り当ての使用を許可します。 例 int_var1 := int_var2 := int_var3 + 9; （* int_var1 と int_var2 の値を受け取る int_var3 + 9 *） real_var1 := real_var2 := int_var; （* real_var1 と real_var2 の値を取得します int_var *） int_var := real_var1 := int_var; （*誤った割り当て、データ型が対応していません*） IF b := (i = 1) THEN i := i + 1; END_IF " }, 
{ "title" : "代入演算子 : REF ", 
"url" : "_cds_ref_assignment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ 課題 \/ 代入演算子 : REF ", 
"snippet" : "オペレーターは リファレンス （ポインタ）値へ。 構文： <variable name> REF= <variable name> ; 例 refA : REFERENCE TO DUT; B : DUT; C : DUT; A REF= B; \/\/ corresponds to A := ADR(B); A := C; \/\/ corresponds to A^ := C;...", 
"body" : "オペレーターは リファレンス （ポインタ）値へ。 構文： <variable name> REF= <variable name> ; 例 refA : REFERENCE TO DUT;\nB : DUT;\nC : DUT;\n\nA REF= B; \/\/ corresponds to A := ADR(B);\nA := C; \/\/ corresponds to A^ := C; " }, 
{ "title" : "ステートメント ", 
"url" : "_cds_st_f_instructions.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ ステートメント ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "STステートメント：IF ", 
"url" : "_cds_st_instruction_if.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ ステートメント \/ STステートメント：IF ", 
"snippet" : "IF The IF ステートメントは、条件をチェックするため、およびこの条件に応じて、後続のステートメントを実行するために使用されます。 条件は次のようにコード化されます 表現 ブール値を返します。式が返される場合 TRUE 、次に条件が満たされ、対応するステートメントが実行されます。 THEN 。式が返される場合 FALSE 、次に、次の条件で識別されます。 ELSIF 、が評価されます。もし ELSIF 条件が返されます TRUE 、次にステートメントは対応する後に実行されます THEN 。すべての条件が戻った場合 FALSE 、その後、ステートメントは後に実行されます ELSE 。 した...", 
"body" : "IF The IF ステートメントは、条件をチェックするため、およびこの条件に応じて、後続のステートメントを実行するために使用されます。 条件は次のようにコード化されます 表現 ブール値を返します。式が返される場合 TRUE 、次に条件が満たされ、対応するステートメントが実行されます。 THEN 。式が返される場合 FALSE 、次に、次の条件で識別されます。 ELSIF 、が評価されます。もし ELSIF 条件が返されます TRUE 、次にステートメントは対応する後に実行されます THEN 。すべての条件が戻った場合 FALSE 、その後、ステートメントは後に実行されます ELSE 。 したがって、最大で1つのブランチ IF ステートメントが実行されます。 ELSIF ブランチと ELSE ブランチはオプションです。 構文 IF <condition> THEN\n <statements>\n( ELSIF <condition> THEN\n <statements> )*\n( ELSE\n <statements> )?\nEND_IF;\n\/\/ ( ... )* None, once or several times\n\/\/ ( ... )? Optional 例 PROGRAM PLC_PRG\nVAR\n iTemp: INT;\n xHeatingOn: BOOL;\n xOpenWindow: BOOL;\nEND_VAR\n\nIF iTemp < 17 THEN\n xHeatingOn := TRUE;\nELSIF iTemp > 25 THEN\n xOpenWindow := TRUE;\nELSE xHeatingOn := FALSE;\nEND_IF; プログラムは実行時に次のように実行されます。 式の評価用 iTemp < 17 = TRUE 、後続のステートメントが実行され、加熱がオンになります。式の評価用 iTemp < 17 = FALSE 、後続 ELSIF 調子 iTemp > 25 評価されます。これが当てはまる場合、 ELSIF が実行され、ビューが開きます。すべての条件が FALSE 、その後、ステートメントはで実行されます ELSE 暖房がオフになります。 " }, 
{ "title" : "STステートメント：FOR ", 
"url" : "_cds_st_instruction_for.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ ステートメント \/ STステートメント：FOR ", 
"snippet" : "FOR The FOR ループは、特定の繰り返し回数でステートメントを実行するために使用されます。 構文： FOR <counter> := <start value> TO <end value> {BY <increment> } DO <instructions> END_FOR; 中括弧{}内のセクションはオプションです。 CODESYS を実行します <instructions> 限り <counter> が大きくない–または負の場合 increment ステップ未満– <end value> 。これは、実行前にチェックされます <instructions> 。 毎回 <instru...", 
"body" : "FOR The FOR ループは、特定の繰り返し回数でステートメントを実行するために使用されます。 構文： FOR <counter> := <start value> TO <end value> {BY <increment> } DO\n <instructions>\nEND_FOR; 中括弧{}内のセクションはオプションです。 CODESYS を実行します <instructions> 限り <counter> が大きくない–または負の場合 increment ステップ未満– <end value> 。これは、実行前にチェックされます <instructions> 。 毎回 <instructions> ステートメントが実行されました、カウンター <counter> 増分によって自動的に増加します <increment> 。増分 <increment> 任意の整数値を持つことができます。増分を指定しない場合、標準の増分は次のようになります。 1 。 例 FOR iCounter := 1 TO 5 BY 1 DO\n iVar1 := iVar1*2;\nEND_FOR;\nErg := iVar1; 事前設定している場合 iVar1 と 1 、 iVar1 値があります 32 FORループの後。 終了値<終了値>は、カウンターのデータ型の上限と同じ値を取得してはなりません。 カウンターの終了値がカウンターのデータ型の上限と等しい場合、無限ループが発生します。たとえば、次の場合、無限ループは上記の例になります。 iCounter データ型です SINT そしてその <end value> 等しい 127 、データ型から SINT 上限があります 127 。 IEC 61131-3規格の拡張として、次のものを使用できます。 継続する 内のステートメント FOR ループ。 " }, 
{ "title" : "STステートメント：CASE ", 
"url" : "_cds_st_instruction_case.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ ステートメント \/ STステートメント：CASE ", 
"snippet" : "CASE CASE ステートメントは、ステートメントまたはステートメントのセクションを特定の条件下でのみ実行する条件付き制御構造です。実行するセクションは、条件とラベルを比較して決定されます。 構文： CASE <condition> OF <label-1> : <instruction-1> <label-2> : <instruction-2> <label-3, label-4, label-5> : <instruction-3> <label-6 .. labe-10> : <instruction-4> <label-n> : <instruction-n> ELSE <ELSE...", 
"body" : "CASE CASE ステートメントは、ステートメントまたはステートメントのセクションを特定の条件下でのみ実行する条件付き制御構造です。実行するセクションは、条件とラベルを比較して決定されます。 構文： CASE <condition> OF\n <label-1> : \n <instruction-1>\n <label-2> : \n <instruction-2>\n <label-3, label-4, label-5> : \n <instruction-3>\n <label-6 .. labe-10> : \n <instruction-4>\n <label-n> : \n <instruction-n>\n ELSE <ELSE-instruction>\nEND_CASE 状態 条件の整数変数 例： iCondition 変数の値は、構造内で宣言されたラベルと比較されます。 CASE ステートメント内では、任意の数のラベル (最小: 2) を使用できます。それ以外の場合、IF-THEN-ELSE 構造を使用すると、構造をより明確に表示できます。 すべてのラベルは異なる値を持つ必要があります。 ラベル-n 条件と同じデータ型の定数、リテラル、または定数式 CASE 構造内のラベル (ジャンプ ターゲット) として機能します。 例： 1 、 5 、 c_ONE 、 c_TWO この値が次の値に等しい場合 状態 、その後、次のステートメントが実行されます。 この値が次と等しくない場合 状態 の場合、それぞれのステートメントは無視され、システムは次のラベルにジャンプします。 < ラベル-n >, < ラベル-n1 > ジャンプターゲットとして機能する複数のラベルを含むカンマ区切りのリスト 例： 1, 5 いずれかのラベルが条件に一致する場合 状態 に続いて、次のセクションを実行します。 < ラベル-n1 >..< ラベル-n2 > 下限値と上限値のラベルが付いた範囲 10..20 条件が 状態 からの範囲の値を取ります ラベル-n1 に ラベル-n2 に続いて、次のセクションを実行します。 ELSE オプション、最大 1 回 以前のすべてのラベルが存在する場合にジャンプされるデフォルトのジャンプ ターゲット しないでください 条件に合う。 命令-n ELSE命令 ステートメント、または複数のステートメントで構成されるステートメントセグメント ステートメントは常にセミコロン ( ; ）。 例 CASE iCondition OF\n 1, 5, c_ONE, C_TWO: \n bVar1 := TRUE;\n bVar3 := FALSE;\n 2: \n bVar2 := FALSE;\n bVar3 := TRUE;\n 10..20: \n bVar1 := TRUE;\n bVar3 := TRUE;\n ELSE\n bVar1 := NOT bVar1;\n bVar2 := bVar1 OR bVar2;\nEND_CASE " }, 
{ "title" : "STステートメント：WHILE ", 
"url" : "_cds_st_instruction_while.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ ステートメント \/ STステートメント：WHILE ", 
"snippet" : "WHILE The WHILE ループは次のように使用されます にとって 中止条件が発生するまでステートメントを数回実行するためにループします。の中止条件 WHILE loopはブール式です。 構文： WHILE <boolean expression> DO <instructions> END_WHILE; CODESYS 繰り返し実行します <instructions> 限りのステートメント <Boolean expression> TRUEを返します。ブール式がすでに存在する場合 FALSE 最初の評価で、その後 CODESYS ステートメントを実行することはありません。ブール式が値を...", 
"body" : "WHILE The WHILE ループは次のように使用されます にとって 中止条件が発生するまでステートメントを数回実行するためにループします。の中止条件 WHILE loopはブール式です。 構文： WHILE <boolean expression> DO\n <instructions>\nEND_WHILE; CODESYS 繰り返し実行します <instructions> 限りのステートメント <Boolean expression> TRUEを返します。ブール式がすでに存在する場合 FALSE 最初の評価で、その後 CODESYS ステートメントを実行することはありません。ブール式が値を適用しない場合 FALSE 、その後、ステートメントが際限なく繰り返され、その結果、ランタイムエラーが発生します。 例 WHILE iCounter <> 0 DO\n Var1 := Var1*2\n iCounter := iCounter-1;\nEND_WHILE; プログラミングを使用して、無限ループが発生しないようにする必要があります。 ある意味で WHILE と 繰り返す ループは、実行前にループの実行回数を知る必要がないため、FORループよりも強力です。したがって、場合によっては、これら2種類のループでしか機能しないことがあります。ただし、ループの実行回数が明確な場合は、 FOR 無限ループを回避するには、ループを使用することをお勧めします。 IEC 61131-3規格の拡張として、次のものを使用できます。 継続する WHILEループ内のステートメント。 " }, 
{ "title" : "STステートメント：REPEAT ", 
"url" : "_cds_st_instruction_repeat.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ ステートメント \/ STステートメント：REPEAT ", 
"snippet" : "REPEAT The REPEAT ループは次のように使用されます その間 ループしますが、違いは CODESYS ループの実行後にのみ中止条件をチェックします。この動作の結果は、 REPEAT アボート条件に関係なく、ループは少なくとも1回実行されます。 構文： REPEAT <instructions> UNTIL <boolean expression> END_REPEAT; CODESYS を実行します <instructions> までのステートメント <Boolean expression> TRUEを返します。 ブール式がすでに返される場合 TRUE 最初の評価では、 CODE...", 
"body" : "REPEAT The REPEAT ループは次のように使用されます その間 ループしますが、違いは CODESYS ループの実行後にのみ中止条件をチェックします。この動作の結果は、 REPEAT アボート条件に関係なく、ループは少なくとも1回実行されます。 構文： REPEAT\n <instructions>\nUNTIL <boolean expression>\nEND_REPEAT; CODESYS を実行します <instructions> までのステートメント <Boolean expression> TRUEを返します。 ブール式がすでに返される場合 TRUE 最初の評価では、 CODESYS ステートメントを正確に1回実行します。ブール式が値を適用しない場合 TRUE 、その後、ステートメントが際限なく繰り返され、その結果、ランタイムエラーが発生します。 例 REPEAT\n Var1 := Var1*2;\n iCounter := iCounter-1;\nUNTIL\n iCounter = 0\nEND_REPEAT; ある意味で WHILE と REPEAT ループはより強力です にとって ループの実行回数は、実行前に知る必要がないためです。場合によっては、これら2種類のループしか操作できません。ただし、ループの実行回数が明確な場合は、 FOR 無限ループを回避するには、ループを使用することをお勧めします。 IEC 61131-3規格の拡張として、次のものを使用できます。 継続する 内のステートメント WHILE ループ。 " }, 
{ "title" : "STステートメント：RETURN ", 
"url" : "_cds_st_instruction_return.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ ステートメント \/ STステートメント：RETURN ", 
"snippet" : "RETURN 使用 RETURN 機能ブロックを終了するためのステートメント。これを依存させることができます 調子 、 例えば。 例 IF xIsDone THEN RETURN; END_IF; iCounter := iCounter + 1; の値が xIsDone に等しい TRUE 、その後、機能ブロックはすぐに終了し、ステートメント iCounter := iCounter + 1; 実行されません。 なぜなら RETURN ステートメントは条件付きリターンもサポートしているため、上記の例は次のように記述することもできます。 RETURN (xIsDone); iCounter :...", 
"body" : "RETURN 使用 RETURN 機能ブロックを終了するためのステートメント。これを依存させることができます 調子 、 例えば。 例 IF xIsDone THEN\n RETURN;\nEND_IF;\n\niCounter := iCounter + 1; の値が xIsDone に等しい TRUE 、その後、機能ブロックはすぐに終了し、ステートメント iCounter := iCounter + 1; 実行されません。 なぜなら RETURN ステートメントは条件付きリターンもサポートしているため、上記の例は次のように記述することもできます。 RETURN (xIsDone);\niCounter := iCounter + 1; " }, 
{ "title" : "STステートメント：JMP ", 
"url" : "_cds_st_instruction_jmp.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ ステートメント \/ STステートメント：JMP ", 
"snippet" : "JMP The JMP ステートメントは、ジャンプラベルでマークされたプログラム行への無条件ジャンプを実行するために使用されます。 構文： <label>: <instructions> JMP <label>; ジャンプラベル <label> プログラム行の先頭に配置する一意の識別子です。に到達すると JMP ステートメント、プログラム行に戻る <label> 起こる。 例 iVar1 := 0; _label1: iVar1 := iVar1+1; (*instructions*) IF (iVar1 < 10) THEN JMP _label1; END_IF; プログラミングを使用して...", 
"body" : "JMP The JMP ステートメントは、ジャンプラベルでマークされたプログラム行への無条件ジャンプを実行するために使用されます。 構文： <label>: <instructions>\n\nJMP <label>; ジャンプラベル <label> プログラム行の先頭に配置する一意の識別子です。に到達すると JMP ステートメント、プログラム行に戻る <label> 起こる。 例 iVar1 := 0;\n\n_label1: iVar1 := iVar1+1;\n\n(*instructions*)\n\nIF (iVar1 < 10) THEN\n JMP _label1;\nEND_IF; プログラミングを使用して、無限ループが発生しないようにする必要があります。たとえば、ジャンプを条件付きにすることができます。 " }, 
{ "title" : "STステートメント：EXIT ", 
"url" : "_cds_st_instruction_exit.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ ステートメント \/ STステートメント：EXIT ", 
"snippet" : "EXIT The EXIT ステートメントはで使用されます にとって ループ、 その間 ループ、または 繰り返す 他の中止条件に関係なくループを終了するためにループします。...", 
"body" : "EXIT The EXIT ステートメントはで使用されます にとって ループ、 その間 ループ、または 繰り返す 他の中止条件に関係なくループを終了するためにループします。 " }, 
{ "title" : "EXSTステートメント：CONTINUE ", 
"url" : "_cds_exst_instruction_continue.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ ステートメント \/ EXSTステートメント：CONTINUE ", 
"snippet" : "CONTINUE CONTINUE 拡張構造化テキスト（ExST）のステートメントです。 ステートメントは、 にとって ループ、 その間 ループ、または 繰り返す ループの次の実行の最初にジャンプするためにループします。 例 FOR Counter:=1 TO 5 BY 1 DO INT1:=INT1\/2; IF INT1=0 THEN CONTINUE; (* to avoid a division by zero *) END_IF Var1:=Var1\/INT1; (* executed, if INT1 is not 0 *) END_FOR; Erg:=Var1;...", 
"body" : "CONTINUE CONTINUE 拡張構造化テキスト（ExST）のステートメントです。 ステートメントは、 にとって ループ、 その間 ループ、または 繰り返す ループの次の実行の最初にジャンプするためにループします。 例 FOR Counter:=1 TO 5 BY 1 DO\n\nINT1:=INT1\/2;\n\nIF INT1=0 THEN\n\n CONTINUE; (* to avoid a division by zero *)\n\nEND_IF\n\nVar1:=Var1\/INT1; (* executed, if INT1 is not 0 *)\n\nEND_FOR;\n\nErg:=Var1; " }, 
{ "title" : "ST機能ブロック呼び出し ", 
"url" : "_cds_st_fb_call.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ ステートメント \/ ST機能ブロック呼び出し ", 
"snippet" : "を呼び出す ファンクションブロック STで 構文 <FB instance>(<FB input variable>:=<value or address>\\|, <other FB input variables>); 例 TMR:TON; TMR (IN:=%OX5, PT:=T#300ms); varA:=TMR.Q; タイマー機能ブロック TON でインスタンス化されます TMR:TON パラメータの割り当てで呼び出されます IN と PT 。 出力 Q で対処されます TMR.Q 変数に割り当てられます varA 。...", 
"body" : "を呼び出す ファンクションブロック STで 構文 <FB instance>(<FB input variable>:=<value or address>\\|, <other FB input variables>); 例 TMR:TON;\n\nTMR (IN:=%OX5, PT:=T#300ms);\nvarA:=TMR.Q; タイマー機能ブロック TON でインスタンス化されます TMR:TON パラメータの割り当てで呼び出されます IN と PT 。 出力 Q で対処されます TMR.Q 変数に割り当てられます varA 。 " }, 
{ "title" : "STコメント ", 
"url" : "_cds_st_comment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プログラミング言語とエディター \/ 構造化テキストおよび拡張構造化テキスト（ExST） \/ ステートメント \/ STコメント ", 
"snippet" : "コメント 説明 例 単線 マーキングには2つの方法があります。 で始まる \/\/ 行の終わりで終了します で始まる \/\/\/ 行の終わりで終了します の CODESYS 、これらのコメントは同じ方法で処理されます。 ただし、ライブラリドキュメントがLibDoc Scripting Collectionを使用して作成されている場合は、以下が適用されます。 プロパティが LibDocContent = DocsOnly プロジェクト情報に入力され、コメントのみがマークされます \/\/\/ ライブラリドキュメントに処理されます。表の下にあるこの例を参照してください。 いつ LibDocContent = C...", 
"body" : "コメント 説明 例 単線 マーキングには2つの方法があります。 で始まる \/\/ 行の終わりで終了します で始まる \/\/\/ 行の終わりで終了します の CODESYS 、これらのコメントは同じ方法で処理されます。 ただし、ライブラリドキュメントがLibDoc Scripting Collectionを使用して作成されている場合は、以下が適用されます。 プロパティが LibDocContent = DocsOnly プロジェクト情報に入力され、コメントのみがマークされます \/\/\/ ライブラリドキュメントに処理されます。表の下にあるこの例を参照してください。 いつ LibDocContent = CommentsAndDocs （デフォルト設定）が定義され、すべてのコメントがライブラリドキュメントに処理されます。 \/\/\/ This is a comment \/\/\/ This is a comment マルチライン で始まる (* そしてで終わる *) 。 (* This is a multiline comment *) ネスト で始まる (* で終わる *) 。追加コメント (*....*) このコメントに含めることができます。 ( * a:=inst.out; (* comment 1 *) b:=b+1; (* comment 2 *) *) コメントは、オンラインモードでは変数宣言のコメント列に変数の情報として表示されます。また、マウスポインターを変数の上に置くとツールチップにも表示されます。以下のロジックと優先順位が適用されます コメントがで始まる場合 \/\/\/ が変数の前にあると、このコメントが表示されます。 コメントがで始まる場合 \/\/ または以内 (**) が同じ行の変数宣言の後にあると、このコメントが表示されます コメントがで始まる場合 \/\/ または以内 (**) が同じ行の変数宣言の前にある場合、このコメントが表示されます コメントの長さが原因でオンラインモードでコメント全体を表示できない場合は、 このコメントフィールドには記号が表示されます。このシンボルの上にカーソルを置くと、コメント全体がツールチップに表示されます ツールチップとPOUドキュメントへのコメント A tooltip in the header of a POU is defined by the following comment:\n \/\/ tooltip text – line 1\n \/\/ tooltip text – line 2\n \/\/ tooltip text – line 3\n\n Afterwards the documentation is defined as follows:\n \/\/\/ reStructuredText メモ:さまざまなコメントタイプを使用して、ライブラリのドキュメンテーションに表示するコメントと、ライブラリ開発者のみを対象としたコメントを制御できます。 " }, 
{ "title" : "変数 ", 
"url" : "_cds_struct_reference_variable_types.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 ", 
"snippet" : "変数のスコープは、変数を使用する方法と場所を定義します。スコープは変数宣言で定義します。...", 
"body" : "変数のスコープは、変数を使用する方法と場所を定義します。スコープは変数宣言で定義します。 " }, 
{ "title" : "変数：VAR ", 
"url" : "_cds_vartypes_var.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数：VAR ", 
"snippet" : "VAR ローカル変数はキーワード間で宣言されます VAR と END_VAR プログラミングオブジェクトの宣言部分。ローカル変数への読み取り専用アクセス権があります（外部からインスタンスパスを介して）。 変数は属性キーワードで拡張できます（ CONSTANT 、 RETAIN 、 また PERSISTENT ）。 例 VAR iVar1 : INT; END_VAR...", 
"body" : "VAR searchresult_toplevel ローカル変数はキーワード間で宣言されます VAR と END_VAR プログラミングオブジェクトの宣言部分。ローカル変数への読み取り専用アクセス権があります（外部からインスタンスパスを介して）。 変数は属性キーワードで拡張できます（ CONSTANT 、 RETAIN 、 また PERSISTENT ）。 例 VAR\n iVar1 : INT;\nEND_VAR " }, 
{ "title" : "変数：VAR_INPUT ", 
"url" : "_cds_vartypes_var_input.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数：VAR_INPUT ", 
"snippet" : "VAR_INPUT 入力変数は、ファンクション ブロックの入力で使用されます。あなたは宣言します VAR_INPUT 間の変数 VAR_INPUT そして END_VAR POU の宣言部分のキーワード。呼び出されると、値のみが渡されます (値渡し)。 変数は属性キーワードで拡張できます（ CONSTANT 、 RETAIN 、 また PERSISTENT ）。 例 VAR_INPUT iIn1 : INT; (* 1st input variable *) END_VAR...", 
"body" : "VAR_INPUT 入力変数は、ファンクション ブロックの入力で使用されます。あなたは宣言します VAR_INPUT 間の変数 VAR_INPUT そして END_VAR POU の宣言部分のキーワード。呼び出されると、値のみが渡されます (値渡し)。 変数は属性キーワードで拡張できます（ CONSTANT 、 RETAIN 、 また PERSISTENT ）。 例 VAR_INPUT\n iIn1 : INT; (* 1st input variable *)\nEND_VAR " }, 
{ "title" : "変数：VAR_OUTPUT ", 
"url" : "_cds_vartypes_var_output.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数：VAR_OUTPUT ", 
"snippet" : "VAR_OUTPUT 出力変数は、ファンクションブロックの出力で使用されます。あなたは宣言します VAR_OUTPUT 間の変数 VAR_OUTPUT と END_VAR POUの宣言部分のキーワード。この変数の値は、呼び出し元のPOUに返されます。そこで、値を取得して引き続き使用できます。 変数は属性キーワードで指定できます（ CONSTANT 、 RETAIN また PERSISTENT ）拡張されます。 例 VAR_OUPUT iOut1 : INT; (*1st output variable *) END_VAR 関数とメソッドの出力変数 IEC 61131-3規格によると、関数とメ...", 
"body" : "VAR_OUTPUT 出力変数は、ファンクションブロックの出力で使用されます。あなたは宣言します VAR_OUTPUT 間の変数 VAR_OUTPUT と END_VAR POUの宣言部分のキーワード。この変数の値は、呼び出し元のPOUに返されます。そこで、値を取得して引き続き使用できます。 変数は属性キーワードで指定できます（ CONSTANT 、 RETAIN また PERSISTENT ）拡張されます。 例 VAR_OUPUT\n iOut1 : INT; (*1st output variable *)\nEND_VAR 関数とメソッドの出力変数 IEC 61131-3規格によると、関数とメソッドには追加の出力があります。以下に示すように、関数を呼び出すときにこれらの追加の出力を割り当てる必要があります。 例 fun(iIn1 := 1, iIn2 := 2, iOut1 => iLoc1, iOut2 => iLoc2); " }, 
{ "title" : "変数：VAR_IN_OUT ", 
"url" : "_cds_vartypes_var_in_out.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数：VAR_IN_OUT ", 
"snippet" : "VAR_IN_OUT A VAR_IN_OUT variableは入力\/出力変数であり、POUインターフェースの一部であり、正式な参照渡しパラメーターとして機能します。 構文 <keyword> <POU name> VAR_IN_OUT <variable name> : <data type>; END_VAR <keyword> : FUNCTION | FUNCTION_BLOCK | METHOD | PRG 入出力変数を宣言できます。 VAR_IN_OUT POU の宣言セクション PRG 、 FUNCTION_BLOCK 、 METHOD 、 または FUNCTION 。の VA...", 
"body" : "VAR_IN_OUT A VAR_IN_OUT variableは入力\/出力変数であり、POUインターフェースの一部であり、正式な参照渡しパラメーターとして機能します。 構文 <keyword> <POU name>\nVAR_IN_OUT\n <variable name> : <data type>;\nEND_VAR\n\n<keyword> : FUNCTION | FUNCTION_BLOCK | METHOD | PRG 入出力変数を宣言できます。 VAR_IN_OUT POU の宣言セクション PRG 、 FUNCTION_BLOCK 、 METHOD 、 または FUNCTION 。の VAR_IN_OUT 変数の読み書きが可能です。 使用法 電話 ：POUが呼び出されると、正式な VAR_IN_OUT variableは、引数として実際の変数（ \"pass-by-reference変数\"）を受け取ります。実行時に、パラメーターが渡されたときにコピーは生成されません。代わりに、仮変数は、リモートで渡された実際の変数への参照を受け取ります。参照変数には、実際の値に対する値として内部にメモリアドレスが含まれています（ ポインタとして渡す 、 コールバイリファレンス ）。定数（リテラル）またはビット変数を引数として直接指定することはできません。 POU内の読み取り\/書き込みアクセス ：変数がPOU内に書き込まれる場合、これは渡される変数に影響します。 POUが終了すると、実行された変更はすべて保持されます。これは、POUが VAR_IN_OUT 呼び出し元のPOUがその変数を使用するのと同じように、変数。読み取りアクセスは常に許可されます。 リモートでの読み取り\/書き込みアクセス ： VAR_IN_OUT 変数 できません を介してリモートで直接読み取りまたは書き込み <function block instance name>.<variable name> 。これは次の場合にのみ機能します VAR_INPUT と VAR_OUTPUT 変数。 文字列変数を渡す ：文字列変数が引数として渡される場合、実際の変数と仮変数は同じ長さである必要があります。そうしないと、渡された文字列が意図せずに操作される可能性があります。この問題は、次の場合には発生しません。 VAR_OUTPUT CONSTANT パラメーター。 ビット変数の受け渡し ：ビット変数を直接に渡すことはできません VAR_IN_OUT 中間変数が必要なため、変数。 プロパティの受け渡し ： 許可されていません 文字列が変数または定数としてフォーマルに渡される場合 VAR_IN_OUT CONSTANT 変数の場合、文字列は自動的に完全に渡されます。文字列の長さを確認する必要はありません。 詳細については、以下を参照してください。 「VAR_IN_OUTCONSTANT」転送変数 例 配列の受け渡し TYPE DUT_A :\nSTRUCT\n xA: BOOL;\n iB: INT;\nEND_STRUCT\nEND_TYPE\n\nFUNCTION_BLOCK FB_SetArray\nVAR_IN_OUT\n aData_A : ARRAY[0..1] OF DUT_A; \/\/ Formal variable\nEND_VAR\naData_A[0].xA := TRUE;\naData_A[0].iB := 100;\n\nPROGRAM PLC_PRG\nVAR\n fbSetA : FB_SetArray;\n aSpecialData : ARRAY[0..1] OF DUT_A; \/\/ Actual variable\nEND_VAR\nfbSetA(aData_A := aSpecialData); 文字列を渡す {attribute 'qualified_only'}\nVAR_GLOBAL\n g_sDEV_STATUS : STRING(25) := 'Device_A';\nEND_VAR\n\nFUNCTION_BLOCK FB_SetStatus\nVAR_IN_OUT\n sDeviceStatus : STRING(25); \/\/ Formal parameter\nEND_VAR\nsDeviceStatus := CONCAT(sDeviceStatus, ' Activ');\n\nPROGRAM PLC_PRG\nVAR\n fbDoB : FB_SetStatus;\nEND_VAR\nfbDoB(sDeviceStatus := GVL.g_sDEV_STATUS); \/\/Call with actual parameter 変数 sDeviceStatus のPOUインターフェースの一部です FB_B 。電話するとき fbDoB 、最初にデバイス名が文字列に割り当てられ、次に文字列が操作されます。 ビット変数の受け渡し VAR_GLOBAL\n xBit0 AT %MX0.1 : BOOL;\n xTemp : BOOL;\nEND_VAR\n\nFUNCTION_BLOCK FB_DoSomething\nVAR_INPUT\n xIn : BOOL;\nEND_VAR\nVAR_IN_OUT\n xInOut : BOOL;\nEND_VAR\nIF xIn THEN\n xInOut := TRUE;\nEND_IF\n\nPROGRAM PLC_PRG\nVAR\n xIn : BOOL;\n DoSomething_1 : FB_DoSomething;\n DoSomething_2 : FB_DoSomething;\nEND_VAR\n\n\/\/ The following line of code causes a compiler error:\n\/\/ C0201: Typ 'BIT' is not equal to type 'BOOL' of VAR_IN_OUT 'xInOut'\nDoSomething_1(xIn := xIn, xInOut := xBit0);\n\n\/\/ Workaround\nxTemp := xBit0;\nDoSomething_2(xIn := xIn, xInOut := xTemp);\nxBit0 := xTemp; プログラムは機能ブロックインスタンスを呼び出します DoSomething_1 と DoSomething_2 。ビット変数の直接割り当ての結果として xBit0 に VAR_IN_OUT 入力の場合、コンパイラエラーが生成されます。 DoSomething_1 インスタンスが呼び出されます。対照的に、 DoSomething_2 中間変数が割り当てられたインスタンスは正しいコードです。 " }, 
{ "title" : "転送変数 VAR_IN_OUT CONSTANT ", 
"url" : "_cds_vartypes_var_in_out.html#UUID-32134341-4b6c-acd3-aa57-48bb400d17e2_id_e5c8916dc25ffdfc0a8640e01bbaaae_id_dfbe41aa0aeae611c0a864633d68e93e", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数：VAR_IN_OUT \/ 転送変数 VAR_IN_OUT CONSTANT ", 
"snippet" : "A VAR_IN_OUT CONSTANT 変数は、定数の参照渡しパラメーターとして機能します。 STRING また WSTRING 型変数または定数（リテラル）を渡すことができます。パラメータは読み取ることはできますが、書き込むことはできません。プロパティの通過は許可されていません。 構文宣言 <keyword> <POU name> VAR_IN_OUT CONSTANT <variable name> : <data type>; \/\/ formal parameter END_VAR <keyword> : FUNCTION | FUNCTION_BLOCK | METHOD | PR...", 
"body" : "A VAR_IN_OUT CONSTANT 変数は、定数の参照渡しパラメーターとして機能します。 STRING また WSTRING 型変数または定数（リテラル）を渡すことができます。パラメータは読み取ることはできますが、書き込むことはできません。プロパティの通過は許可されていません。 構文宣言 <keyword> <POU name>\nVAR_IN_OUT CONSTANT\n <variable name> : <data type>; \/\/ formal parameter\nEND_VAR\n<keyword> : FUNCTION | FUNCTION_BLOCK | METHOD | PRG VAR_IN_OUT CONSTANT 変数は、初期化値を割り当てずに宣言されます。 使用法 POUを呼び出す場合、 STRING また WSTRING 定数変数またはリテラルを渡すことができます。したがって、書き込みアクセスは許可されません。 文字列定数のパラメータの受け渡し：定数の文字列の長さは任意のサイズにすることができ、文字列の長さは文字列の長さに依存しません VAR_IN_OUT CONSTANT 変数。 の場合 定数を置き換える オプションはで選択されています プロジェクト→プロジェクト設定 の中に コンパイルオプション カテゴリの場合、基本データ型の定数または基本データ型の定数変数のパラメータを渡すと、コンパイラエラーが発生します。 この変数は、コンパイラバージョン> = 3.5.2.0でサポートされています。 例 文字列定数と文字列変数のパラメータを渡す FUNCTION funManipulate : BOOL\nVAR_IN_OUT\n sReadWrite : STRING(16); (* Can be read or written here in POU *)\n dwVarReadWrite : DWORD; (* Can be read or written here in POU *)\nEND_VAR\nVAR_IN_OUT CONSTANT\n c_sReadOnly : STRING(16); (* Constant string variable can only be read here in POU *)\nEND_VAR\n\nsReadWrite := 'String_from_POU';\ndwVarReadWrite := STRING_TO_DWORD(c_sReadOnly);\n\nPROGRAM PRG_A\nVAR\n sVarFits : STRING(16);\n sValFits : STRING(16) := '1234567890123456';\n dwVar: DWORD;\nEND_VAR\n\n\/\/ The following line of code causes the compiler error C0417:\n\/\/ C0417: VAR_IN_OUT parameter 'sReadWrite' needs a variable with write access as input.\nfunManipulate(sReadWrite:='1234567890123456', c_sReadOnly:='1234567890123456', dwVarReadWrite := dwVar);\n\n\/\/ Correct code\nfunManipulate(sReadWrite := sValFits, c_sReadOnly := '23', dwVarReadWrite := dwVar);\nfunManipulate(sReadWrite := sVarFits, c_sReadOnly := sValFits, dwVarReadWrite := dwVar); コードでは、文字列はに渡されます funManipulate 異なる経由で機能 VAR_IN_OUT 変数。文字列リテラルを渡すと、コンパイラエラーが出力されます。 VAR_IN_OUT 変数。定数変数をに渡すとき VAR_IN_OUT CONSTANT 変数、文字列変数を渡す場合でも正しいコードが生成されます。 " }, 
{ "title" : "変数：VAR_GLOBAL ", 
"url" : "_cds_vartypes_var_global.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数：VAR_GLOBAL ", 
"snippet" : "VAR_GLOBAL ブロックで宣言されたローカル変数がグローバル変数と同じ名前である場合、ブロック内で優先されます。 コンパイラバージョン3.2.0.0以降の場合、 CODESYS ローカルPOU変数の前に常にグローバル変数を初期化します。 グローバル変数は、プロジェクト全体で認識される変数、定数、外部変数または残留変数です。グローバル変数リストで、またはキーワード間のプログラミングオブジェクトの宣言部分でグローバル変数を宣言します。 VAR_GLOBAL と END_VAR 。 例 VAR_GLOBAL g_iVar1 : INT; END_VAR 変数名の前にドットを付けると、システムは...", 
"body" : "VAR_GLOBAL ブロックで宣言されたローカル変数がグローバル変数と同じ名前である場合、ブロック内で優先されます。 コンパイラバージョン3.2.0.0以降の場合、 CODESYS ローカルPOU変数の前に常にグローバル変数を初期化します。 グローバル変数は、プロジェクト全体で認識される変数、定数、外部変数または残留変数です。グローバル変数リストで、またはキーワード間のプログラミングオブジェクトの宣言部分でグローバル変数を宣言します。 VAR_GLOBAL と END_VAR 。 例 VAR_GLOBAL\n g_iVar1 : INT;\nEND_VAR 変数名の前にドットを付けると、システムはグローバル変数を認識します（例： .g_iVar1 ）。 " }, 
{ "title" : "変数：VAR_TEMP ", 
"url" : "_cds_vartypes_var_temp.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数：VAR_TEMP ", 
"snippet" : "VAR_TEMP この機能は、IEC61131-3規格の拡張です。 キーワード間でローカルに一時変数を宣言します VAR_TEMP と END_VAR 。 VAR_TEMP 宣言は、プログラムと機能ブロックでのみ可能です。 CODESYS POUが呼び出されるたびに一時変数を初期化します。 アプリケーションは、プログラムブロックまたは関数ブロックの実装部分でのみ一時変数にアクセスできます。 VAR_TEMP iVarTmp1 : INT; (*1st temporary variable *) END_VAR...", 
"body" : "VAR_TEMP この機能は、IEC61131-3規格の拡張です。 キーワード間でローカルに一時変数を宣言します VAR_TEMP と END_VAR 。 VAR_TEMP 宣言は、プログラムと機能ブロックでのみ可能です。 CODESYS POUが呼び出されるたびに一時変数を初期化します。 アプリケーションは、プログラムブロックまたは関数ブロックの実装部分でのみ一時変数にアクセスできます。 VAR_TEMP\n iVarTmp1 : INT; (*1st temporary variable *)\nEND_VAR " }, 
{ "title" : "変数：VAR_STAT ", 
"url" : "_cds_vartypes_var_stat.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数：VAR_STAT ", 
"snippet" : "VAR_STAT この機能は、IEC61131-3規格の拡張です。 静的変数をキーワード間でローカルに宣言します。 VAR_STAT そして END_VAR 。静的変数はダウンロード時に初期化されます。 静的変数にアクセスできるのは、変数が宣言されている名前空間内からのみです（Cの静的変数のように）。ただし、静的変数は、アプリケーションがブロックを離れるときにその値を保持します。たとえば、静的変数を関数呼び出しのカウンターとして使用できます。 変数は属性キーワード ( CONSTANT 、 RETAIN 、 または  PERSISTENT ）。 例 VAR_STAT iVarStat1 : I...", 
"body" : "VAR_STAT この機能は、IEC61131-3規格の拡張です。 静的変数をキーワード間でローカルに宣言します。 VAR_STAT そして END_VAR 。静的変数はダウンロード時に初期化されます。 静的変数にアクセスできるのは、変数が宣言されている名前空間内からのみです（Cの静的変数のように）。ただし、静的変数は、アプリケーションがブロックを離れるときにその値を保持します。たとえば、静的変数を関数呼び出しのカウンターとして使用できます。 変数は属性キーワード ( CONSTANT 、 RETAIN 、 または  PERSISTENT ）。 例 VAR_STAT\n iVarStat1 : INT;\nEND_VAR " }, 
{ "title" : "変数：VAR_EXTERNAL ", 
"url" : "_cds_vartypes_var_external.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数：VAR_EXTERNAL ", 
"snippet" : "VAR_EXTERNAL 外部変数は、POUに「インポート」されるグローバル変数です。 キーワード間でこれらの変数を宣言します VAR_EXTERNAL と END_VAR 。グローバル変数が存在しない場合は、エラーメッセージが出力されます。 CODESYS POUで使用するために、グローバル変数を外部変数として宣言する必要はありません。このキーワードは、IEC61131-3への準拠を維持するためにのみ存在します。 構文 <POU keyword> <POU name> VAR_EXTERNAL <variable name> : <data type>; END_VAR 初期化は許可されてい...", 
"body" : "VAR_EXTERNAL 外部変数は、POUに「インポート」されるグローバル変数です。 キーワード間でこれらの変数を宣言します VAR_EXTERNAL と END_VAR 。グローバル変数が存在しない場合は、エラーメッセージが出力されます。 CODESYS POUで使用するために、グローバル変数を外部変数として宣言する必要はありません。このキーワードは、IEC61131-3への準拠を維持するためにのみ存在します。 構文 <POU keyword> <POU name>\nVAR_EXTERNAL\n <variable name> : <data type>;\nEND_VAR 初期化は許可されていません。 例 FUNCTION_BLOCK FB_DoSomething\nVAR_EXTERNAL\n iVarExt1 : INT; (* 1st external variable *)\nEND_VAR " }, 
{ "title" : "変数：VAR_INST ", 
"url" : "_cds_vartypes_var_inst.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数：VAR_INST ", 
"snippet" : "VAR_INST The VAR_INST インスタンス変数はメソッドでのみ許可されます。この種の変数には、メソッド内でのみアクセスできます。メソッドの宣言部分でインスタンス変数の変数値を監視できます。 CODESYS 保存しません VAR_INST メソッドスタック内のメソッド変数ですが、関数ブロックインスタンスのスタック内にあります。これは、 VAR_INST 変数は、関数ブロックインスタンスの他の変数と同様に機能し、メソッドが呼び出されるたびに再初期化されることはありません。 変数は属性キーワードで拡張できます（ CONSTANT 、 RETAIN 、 また PERSISTENT ）。 ...", 
"body" : "VAR_INST The VAR_INST インスタンス変数はメソッドでのみ許可されます。この種の変数には、メソッド内でのみアクセスできます。メソッドの宣言部分でインスタンス変数の変数値を監視できます。 CODESYS 保存しません VAR_INST メソッドスタック内のメソッド変数ですが、関数ブロックインスタンスのスタック内にあります。これは、 VAR_INST 変数は、関数ブロックインスタンスの他の変数と同様に機能し、メソッドが呼び出されるたびに再初期化されることはありません。 変数は属性キーワードで拡張できます（ CONSTANT 、 RETAIN 、 また PERSISTENT ）。 例 METHOD meth_last : INT\nVAR_INPUT\n iVar : INT;\nEND_VAR\nVAR_INST\n iLast : INT := 0;\nEND_VAR\nmeth_last := iLast;\niLast := iVar; " }, 
{ "title" : "変数：VAR_CONFIG ", 
"url" : "_cds_vartypes_var_config.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数：VAR_CONFIG ", 
"snippet" : "VAR_CONFIG 構成変数は、アドレス情報が不完全な機能ブロックで宣言され、デバイスI \/ Oにマップする必要がある変数に完全なアドレスを割り当てます。 宣言は、グローバル変数リストで行われます。 VAR_CONFIG と END_VAR フルインスタンスパスと正しいアドレスを持つキーワード。この種のグローバル変数リストは「変数構成」と呼ばれます。 例 の宣言 xLocIn 不完全な変数 %I* 機能ブロック内のアドレス。 FUNCTION_BLOCK locio VAR xLocIn AT %I* : BOOL := TRUE; END_VAR The locio 機能ブロックはで使用さ...", 
"body" : "VAR_CONFIG 構成変数は、アドレス情報が不完全な機能ブロックで宣言され、デバイスI \/ Oにマップする必要がある変数に完全なアドレスを割り当てます。 宣言は、グローバル変数リストで行われます。 VAR_CONFIG と END_VAR フルインスタンスパスと正しいアドレスを持つキーワード。この種のグローバル変数リストは「変数構成」と呼ばれます。 例 の宣言 xLocIn 不完全な変数 %I* 機能ブロック内のアドレス。 FUNCTION_BLOCK locio\n\nVAR\n xLocIn AT %I* : BOOL := TRUE;\nEND_VAR The locio 機能ブロックはで使用されます PLC_PRG プログラム。 PROGRAM PLC_PRG\n\nVAR\n locioVar1 : locio;\nEND_VAR グローバル変数リストの正しい変数構成は次のとおりです。 VAR_CONFIG\n PLC_PRG.locioVar1.xLocIn AT %IX1.0 : BOOL;\nEND_VAR " }, 
{ "title" : "変数：CONSTANT ", 
"url" : "_cds_vartypes_constant.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数：CONSTANT ", 
"snippet" : "CONSTANT 定数変数は、グローバル変数リストまたはプログラミングオブジェクトの宣言部分で宣言されます。実装では、定数変数はインスタンスパスを介して読み取り専用としてアクセスできます。 構文 <scope> CONSTANT <identifier> : <data type> := <initial value> ; END_VAR <scope> : VAR | VAR_INPUT | VAR_STAT | VAR_GLOBAL <data type>: <elementary data type> | <user defined data type> | <function bloc...", 
"body" : "CONSTANT 定数変数は、グローバル変数リストまたはプログラミングオブジェクトの宣言部分で宣言されます。実装では、定数変数はインスタンスパスを介して読み取り専用としてアクセスできます。 構文 <scope> CONSTANT\n <identifier> : <data type> := <initial value> ;\nEND_VAR\n\n<scope> : VAR | VAR_INPUT | VAR_STAT | VAR_GLOBAL\n<data type>: <elementary data type> | <user defined data type> | <function block>\n<initial value> : <literal value> | <identifier> | <expression> 定数変数を宣言するときは、常に初期化値を割り当ててください。そうすると、定数を書くことができなくなります。 例 宣言 VAR CONSTANT\n c_rTAXFACTOR : REAL := 1.19;\nEND_VAR 電話 rPrice := rValue * c_rTAXFACTOR; 実装内の定数変数への読み取り専用アクセス権があります。定数変数は、代入演算子の右側にあります。 詳細については、以下を参照してください。 オペランド" }, 
{ "title" : "変数: VAR_GENERIC CONSTANT ", 
"url" : "_cds_vartypes_var_generic_constant.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数: VAR_GENERIC CONSTANT ", 
"snippet" : "VAR_GENERIC CONSTANT 一般的な定数変数 ジェネリック定数は、内の変数です VAR_GENERIC CONSTANT ファンクションブロックのスコープ。変数はファンクションブロックインスタンスが宣言されたときにのみ定義されます。 ジェネリック定数はメソッドで使用できます。これは、次のような場合に特に役立ちます。 VAR_IN_OUT または VAR_IN_OUT CONSTANT スコープ。...", 
"body" : "VAR_GENERIC CONSTANT 一般的な定数変数 ジェネリック定数は、内の変数です VAR_GENERIC CONSTANT ファンクションブロックのスコープ。変数はファンクションブロックインスタンスが宣言されたときにのみ定義されます。 ジェネリック定数はメソッドで使用できます。これは、次のような場合に特に役立ちます。 VAR_IN_OUT または VAR_IN_OUT CONSTANT スコープ。 " }, 
{ "title" : "型宣言の構文 ", 
"url" : "_cds_vartypes_var_generic_constant.html#UUID-423cfb9f-ca4e-13fd-6267-abdbf0cb4cff_section-idm234820160791049", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数: VAR_GENERIC CONSTANT \/ 型宣言の構文 ", 
"snippet" : "ジェネリック定数を含むファンクションブロックの型宣言の構文 FUNCTION_BLOCK <function block name> VAR_GENERIC CONSTANT <generic constant name> : <integer data type> := <initial value> ; \/\/Initial value will be overwritten END_VAR <function block name> ファンクションブロックの名前 VAR_GENERIC CONSTANT END_VAR ジェネリック定数のスコープ で任意の数のジェネリック定数を宣言できます...", 
"body" : "ジェネリック定数を含むファンクションブロックの型宣言の構文 FUNCTION_BLOCK <function block name>\nVAR_GENERIC CONSTANT\n <generic constant name> : <integer data type> := <initial value> ; \/\/Initial value will be overwritten\nEND_VAR\n\n <function block name> ファンクションブロックの名前 VAR_GENERIC CONSTANT END_VAR ジェネリック定数のスコープ で任意の数のジェネリック定数を宣言できます VAR_GENERIC CONSTANT スコープ。 <generic constant name> ジェネリック定数の変数名 : <integer data type> ジェネリック定数をタイプするコンストラクト。 整数データ型または整数データ型のサブスコープを使用できます。 例: maxlen1 : INT := 4; maxlen2 : INT(5..10) := 5; := <initial value> [オプション] [初期化] 初期値はコンパイルチェックにのみ必要です。実行時に、値は上書きされます 汎用定数は、ファンクションブロックの実装では通常どおり使用できます。このような定数は、たとえば配列のインデックスや文字列の長さなどに使用できます " }, 
{ "title" : "変数宣言の構文 ", 
"url" : "_cds_vartypes_var_generic_constant.html#UUID-423cfb9f-ca4e-13fd-6267-abdbf0cb4cff_section-idm234820159794331", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数: VAR_GENERIC CONSTANT \/ 変数宣言の構文 ", 
"snippet" : "指定された定数による変数宣言 (関数ブロックのインスタンス化) の構文 以下のオプションが可能です。 PROGRAM <program name> VAR <fb instance name> : <function block name> < <literal> > ; <fb instance name> : <function block name> <( <expression> )> ; <fb instance name> : ARRAY [ <index start > .. <index end> ] OF <function block name> < <array leng...", 
"body" : "指定された定数による変数宣言 (関数ブロックのインスタンス化) の構文 以下のオプションが可能です。 PROGRAM <program name>\nVAR\n <fb instance name> : <function block name> < <literal> > ;\n <fb instance name> : <function block name> <( <expression> )> ;\n <fb instance name> : ARRAY [ <index start > .. <index end> ] OF <function block name> < <array length> > ;\nEND_VAR\n 変数宣言 <scope> END_... スコープ <fb instance name> 変数; ファンクションブロックインスタンスの名前 : <function block name> 関数ブロックで変数を入力します これは一般的な定数を持つ関数ブロックです。 < <literal> > [オプション] このファンクションブロックインスタンスでのみ有効な特定の値をデータ型に割り当てます。値は正式に挿入されます in angle brackets データ型のサフィックスとして。 例: fbMyString1 : FB_MyString<100&>; もし 複数 型を定義する関数ブロックにはジェネリック定数が宣言され、カンマで区切られた値のリストが山括弧で囲まれて渡されます。各定数には 1 つの値があります。 Example: fbPou : FB_Pou<100, 1000>; <( <expression> )> [オプション] このファンクションブロックインスタンスでのみ有効な特定の式をデータ型に割り当てます。式が挿入されます。 in angle brackets データ型のサフィックスとして。式自体を囲む必要があります。 丸括弧で囲んでください。 。 丸括弧が必要なのは、次のような記号を使用することが許可されているためです。 < または > エクスプレッションで。そうしないと、コードの一意性が保証されなくなります Example: fbMyString2 : FB_MyString<(2 * cconst)>; ARRAY [ <start index start> .. <end index> ] OF <function block name> [オプション] Types the variable with an array of function blocks. The length of the array is: <end index> - <start index> + 1 これは一般的な定数を持つ関数ブロックです。定数は配列インデックスとして使用されます 例: arrMyString < <array length> > Assigns a specific array length to the data type which is valid especially for this function block instance. 指定された配列の長さは、データ型のサフィックスとして山括弧に正式に挿入されます。指定する値は、開始インデックスと終了インデックスで定義された配列の長さと一致する必要があります Example: arrMyString : ARRAY[0..5] OF FB_MyString<6>; " }, 
{ "title" : "例 ", 
"url" : "_cds_vartypes_var_generic_constant.html#UUID-423cfb9f-ca4e-13fd-6267-abdbf0cb4cff_section-idm234820152486478", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数: VAR_GENERIC CONSTANT \/ 例 ", 
"snippet" : "複数の汎用定数の使用例 FUNCTION_BLOCK FB_Pou VAR_GENERIC CONSTANT lnstring : DINT := 10; numstring : DINT := 100; END_VAR VAR arraystring : ARRAY[0..numstring-1] OF STRING(lnstring); END_VAR ; PROGRAM PLC_PRG VAR fbPou : FB_Pou<100, 1000>; END_VAR 例:サブスコープタイプの汎用定数 FUNCTION_BLOCK FB_SrString VAR_GENERIC CONSTAN...", 
"body" : "複数の汎用定数の使用例 FUNCTION_BLOCK FB_Pou\nVAR_GENERIC CONSTANT\n lnstring : DINT := 10;\n numstring : DINT := 100;\nEND_VAR\nVAR\n arraystring : ARRAY[0..numstring-1] OF STRING(lnstring);\nEND_VAR\n; PROGRAM PLC_PRG\nVAR\n fbPou : FB_Pou<100, 1000>;\nEND_VAR 例:サブスコープタイプの汎用定数 FUNCTION_BLOCK FB_SrString \nVAR_GENERIC CONSTANT\n maxlen2 : INT(5..10) := 5; \/\/subrange data type\nEND_VAR\nVAR\n arrTest : ARRAY[0..maxlen-1] OF BYTE;\nEND_VAR\n; PROGRAM SrMain\nVAR CONSTANT\n cconst: INT(5..10) := 5;\nEND_VAR\nVAR \n fbMyString1 : FB_SrString<5>;\n fbMyString2 : FB_SrString<(2 * cconst)>;\n arrMyString : ARRAY [0..5] OF FB_SrString<6>;\nEND_VAR 例：パラメーター化可能な配列変数を持つジェネリック関数ブロック 次のコードは、任意の長さの配列を処理できる関数ブロックを定義する方法を示しています。関数ブロックには、汎用であるが一定の長さの配列があります。 「一定」とは、各関数ブロックインスタンスの配列の長さが異なりますが、オブジェクトの存続期間中は一定であることを意味します。 この種の構成は、たとえば、ジェネリックライブラリーPOUを実装したいライブラリープログラマーにとって有益です。 FUNCTION_BLOCK FB_MyString \nVAR_GENERIC CONSTANT\n maxlen : UDINT := 1;\nEND_VAR\nVAR\n test : ARRAY[0..maxlen-1] OF BYTE;\nEND_VAR\n; PROGRAM PLC_PRG\nVAR CONSTANT\n cconst: DINT := 1000;\nEND_VAR\nVAR \n fbMyString1 : FB_MyString<100>;\n fbMyString2 : FB_MyString<(2 * cconst)>; \n arrMyString : ARRAY[0..5] OF FB_MyString<6>; \nEND_VAR\n; " }, 
{ "title" : "継承 ", 
"url" : "_cds_vartypes_var_generic_constant.html#UUID-423cfb9f-ca4e-13fd-6267-abdbf0cb4cff_section-idm4622913801579232886674449065", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数: VAR_GENERIC CONSTANT \/ 継承 ", 
"snippet" : "ファンクションブロックは、ジェネリック定数 () を持つ基本ファンクションブロックから継承できます。 EXTENDS )。継承する関数ブロックには独自の汎用定数が必要です。その後、特定の値を外部に転送できます。 構文: FUNCTION_BLOCK <function block name> VAR_GENERIC CONSTANT <generic constant name> : <integer data type> ; END_VAR EXTENDS <function block base> < <generic constant name> > ジェネリック定数を持つ関数ブロックは...", 
"body" : "ファンクションブロックは、ジェネリック定数 () を持つ基本ファンクションブロックから継承できます。 EXTENDS )。継承する関数ブロックには独自の汎用定数が必要です。その後、特定の値を外部に転送できます。 構文: FUNCTION_BLOCK <function block name> \nVAR_GENERIC CONSTANT \n <generic constant name> : <integer data type> ; \nEND_VAR \nEXTENDS <function block base> < <generic constant name> >\n ジェネリック定数を持つ関数ブロックは、インターフェイスを実装できます ( IMPLEMENTS )。インターフェイスはプロパティ () を宣言します。 PROPERTY ) を使うと、指定された値に外部からアクセスできます。インターフェイス自体にジェネリック定数やローカル変数を宣言してはいけません。インターフェースには実装がありません。 構文: FUNCTION_BLOCK <function block name>\nVAR_GENERIC CONSTANT\n <generic constant name> : <integer data type> ;\nEND_VAR\nIMPLEMENTS <interface name>\n コーディング時には、ジェネリック定数の宣言が最初に挿入され、その後に以下が挿入されていることを確認してください EXTENDS そして IMPLEMENTS 。慣れるには少し時間がかかりますが、その理由は、ジェネリック定数は基本クラスでも使用できるからです 例 の定義 IString ジェネリック関数ブロック用のインターフェイス。 ジェネリック関数ブロック用のインターフェイスを定義することを強くお勧めします。このインターフェースは、ジェネリック定数の知識がなくてもジェネリック関数ブロックインスタンスを使用できるようにする必要があります ザル Length プロパティはジェネリック定数へのアクセスを可能にします。 INTERFACE IString \nMETHOD Append : BOOL \nVAR_INPUT \n strAppend : IString; \nEND_VAR \n\nMETHOD Assign : BOOL\nVAR_INPUT \n stringIn : STRING; \nEND_VAR \n\nMETHOD ToString : STRING\nVAR_INPUT \nEND_VAR \n\nPROPERTY Length : DINT ファンクションブロックの宣言 FB_MyString ジェネリック定数を使って maxlen FUNCTION_BLOCK FB_MyString \nVAR_GENERIC CONSTANT \n maxlen : UDINT; \nEND_VAR \nIMPLEMENTS IString \n ファンクションブロック FB_LongString は指定されたファンクションブロックの拡張です。 FB_MyString 。 FUNCTION_BLOCK FB_LongString EXTENDS FB_MyString<1000> ファンクションブロックの宣言 FB_MySpecialString ジェネリック定数を使って maxlen2 指定されたファンクションブロックの拡張として FB_MyString 。ファンクションブロックはメソッドによって拡張されます。 METH_ToLatin 。 FUNCTION_BLOCK FB_MySpecialString \nVAR_GENERIC CONSTANT \n maxlen2 : UDINT:= 1; \nEND_VAR \nEXTENDS FB_MyString<maxlen2>\n METHOD METH_ToLatin : STRING\nVAR_INPUT\nEND_VAR 特定の定数によるファンクションブロックのインスタンス化 PROGRAM PLC_PRG \nVAR CONSTANT \n cconst: DINT := 1000; \nEND_VAR\nVAR \n string1 : FB_MyString<100>;\n string2 : FB_MyString<(2 * cconst)>;\n derived1 : FB_LongString;\n derived2 : FB_MySpecialString<100>;\nEND_VAR \n 通話 string1.METH_Assign ('Welt'); \nstring2.METH_Assign ('Hallo '); \nstring2.METH_Append(string1); \nderived2.METH_ToLatin('Hello World'); " }, 
{ "title" : "変数：PERSISTENT ", 
"url" : "_cds_var_persistent.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数：PERSISTENT ", 
"snippet" : "PERSISTENT 永続変数は宣言セクションで宣言されます VAR_GLOBAL RETAIN PERSISTENT 永続グローバル変数リスト内。でマークされている変数の場合 PERSISTENT 永続性エディターの外部のキーワードでは、インスタンスパスがそこに追加されます。 現在 CODESYS V3.3.0.1、変数宣言 PERSISTENT RETAIN と同じ効果があります RETAIN PERSISTENT また PERSISTENT 。 グローバル永続変数リストの宣言の構文 PersistentVars VAR_GLOBAL PERSISTENT RETAIN <identifi...", 
"body" : "PERSISTENT 永続変数は宣言セクションで宣言されます VAR_GLOBAL RETAIN PERSISTENT 永続グローバル変数リスト内。でマークされている変数の場合 PERSISTENT 永続性エディターの外部のキーワードでは、インスタンスパスがそこに追加されます。 現在 CODESYS V3.3.0.1、変数宣言 PERSISTENT RETAIN と同じ効果があります RETAIN PERSISTENT また PERSISTENT 。 グローバル永続変数リストの宣言の構文 PersistentVars VAR_GLOBAL PERSISTENT RETAIN\n <identifier> : <data type> (:= <initialization>)?;\n <instance path to POU variable>\nEND_VAR POUでの宣言の構文 <scope> PERSISTENT RETAIN\n <identifier> : <data type> ( := <initialization> )?; \/\/ ( ... )? : Optional\nEND_VAR\n<scope> : VAR | VAR_INPUT | VAR_OUTPUT | VAR_IN_OUT | VAR_STAT | VAR_GLOBAL 入力、出力、またはメモリアドレスの割り当て AT キーワードは許可されていません。 絶対に使用しないでください POINTER TO 永続変数リストのデータ型。アプリケーションを再度ダウンロードすると、アドレスが変わる可能性があります。対応するコンパイラの警告がメッセージウィンドウに表示されます。 残留変数の名前またはデータ型を頻繁に変更する場合は、それらを保持変数として宣言することをお勧めします。 RETAIN キーワードのみ。 この場合、2倍のメモリが使用され、サイクルタイムが長くなる可能性があるため、インスタンスパスの挿入は避けてください。代わりに、永続変数のリストで変数を宣言してください。 例 の宣言 PersistentVars 永続変数リスト {attribute 'qualified_only'}\nVAR_GLOBAL PERSISTENT RETAIN\n g_iCounter : INT;\n \/\/ Generated instance path of persistent variable\n PLC_PRG.fb_A.iPersistentCounter_A: INT;\nEND_VAR の宣言 FB_A ファンクションブロック FUNCTION_BLOCK FB_A\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR PERSISTENT\n iPersistentCounter_A : INT;\nEND_VAR の宣言 PLC_PRG プログラム VAR\n fb_A1 : FB_A;\nEND_VAR 可能な宣言場所 説明 永続グローバル変数リストに直接 変数は永続的であり、保護されたメモリ領域にあります。 永続変数リストにインスタンスパスがあるプログラムでローカルに 永続変数リストにインスタンスパスがある関数ブロックでローカルに 変数は永続的であり、保護されたメモリ領域とメモリに配置されます（二重割り当て）。 プログラム内でのみローカル 機能ブロック内でのみローカル 変数は永続的ではありません。メッセージウィンドウに警告が表示されます。 クリック 宣言→すべてのインスタンスパスを追加 変数を永続変数リストにインポートします。 関数内でローカルに この種の宣言は効果がありません。変数は永続的ではありません。 永続性エディターで、をクリックします 宣言→すべてのインスタンスパスを追加 ローカル変数がとしてマークされている場合 PERSISTENT 。 可能な限り、変数を次のようにマークすることは避けてください PERSISTENT これらは機能ブロックで宣言されています。これは、関数ブロックインスタンスが、マークされた変数だけでなく、完全に残留メモリに格納されているためです。 " }, 
{ "title" : "変数：RETAIN ", 
"url" : "_cds_var_retain.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数：RETAIN ", 
"snippet" : "RETAIN 保持変数はキーワードによって宣言されます RETAIN スコープ内のプログラミングオブジェクトに追加されます VAR 、 VAR_INPUT 、 VAR_OUTPUT 、 VAR_IN_OUT 、 VAR_STAT 、 また VAR_GLOBAL 。 宣言の構文 <scope> RETAIN <identifier>: <data type> ( := <initialization> )? \/\/ ( ... )? : Optional END_VAR <scope> : VAR | VAR_INPUT | VAR_OUTPUT | VAR_IN_OUT | VAR_STAT |...", 
"body" : "RETAIN 保持変数はキーワードによって宣言されます RETAIN スコープ内のプログラミングオブジェクトに追加されます VAR 、 VAR_INPUT 、 VAR_OUTPUT 、 VAR_IN_OUT 、 VAR_STAT 、 また VAR_GLOBAL 。 宣言の構文 <scope> RETAIN\n <identifier>: <data type> ( := <initialization> )? \/\/ ( ... )? : Optional\nEND_VAR\n<scope> : VAR | VAR_INPUT | VAR_OUTPUT | VAR_IN_OUT | VAR_STAT | VAR_GLOBAL 入力、出力、またはメモリアドレスの割り当て AT キーワードは許可されていません。 例 POUで VAR RETAIN\n iVarRetain: INT;\nEND_VAR GVLで VAR_GLOBAL RETAIN\n g_iVarRetain: INT;\nEND_VAR " }, 
{ "title" : "可能な宣言場所 ", 
"url" : "_cds_var_retain.html#UUID-157672b4-f73c-a812-8a3b-bbf486c1ca31_id_d0d24fb1c0a864631c4fb86c_id_574bae341796868bc0a86463467e40bc", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ 変数：RETAIN \/ 可能な宣言場所 ", 
"snippet" : "プログラムでローカルに 変数のみがメモリ保持領域にあります。 冗長性を使用する場合、すべてのデータを含むプログラム全体がメモリ保持領域に配置されます。 グローバル変数リストでグローバルに 変数のみがメモリ保持領域にあります。 冗長性を使用する場合、すべてのデータを含むグローバル変数リスト全体がメモリ保持領域に配置されます。 ファンクションブロックでローカルに すべてのデータを含む機能ブロックのインスタンス全体が、メモリ保持領域に配置されます。宣言された保持変数のみが保護されます。 関数内でローカルに 変数はメモリ保持領域にありません。この宣言は効果がありません。 関数内でローカルかつ永続的に ...", 
"body" : "プログラムでローカルに 変数のみがメモリ保持領域にあります。 冗長性を使用する場合、すべてのデータを含むプログラム全体がメモリ保持領域に配置されます。 グローバル変数リストでグローバルに 変数のみがメモリ保持領域にあります。 冗長性を使用する場合、すべてのデータを含むグローバル変数リスト全体がメモリ保持領域に配置されます。 ファンクションブロックでローカルに すべてのデータを含む機能ブロックのインスタンス全体が、メモリ保持領域に配置されます。宣言された保持変数のみが保護されます。 関数内でローカルに 変数はメモリ保持領域にありません。この宣言は効果がありません。 関数内でローカルかつ永続的に 変数はメモリ保持領域にありません。この宣言は効果がありません。 可能な限り、使用を避けてください RETAIN 機能ブロックの変数をマークします。 " }, 
{ "title" : "ポインター：SUPER ", 
"url" : "_cds_pointer_super.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ ポインター：SUPER ", 
"snippet" : "SUPER The SUPER ポインタは、オブジェクト指向プログラミングに使用される特別な変数です。 SUPER は、機能ブロックが生成されたベース機能ブロックインスタンスへの機能ブロックのポインタです。 The SUPER ポインタを使用すると、基本機能ブロック（基本クラス）のメソッドの実装にアクセスすることもできます。 A SUPER ポインタは、機能ブロックごとに自動的に使用可能になります。使用できます SUPER メソッドおよび関連する機能ブロックの実装でのみ。 ポインターの間接参照： SUPER^ を使用して SUPER ポインタ： SUPER キーワードを使用して、基本クラスまた...", 
"body" : "SUPER The SUPER ポインタは、オブジェクト指向プログラミングに使用される特別な変数です。 SUPER は、機能ブロックが生成されたベース機能ブロックインスタンスへの機能ブロックのポインタです。 The SUPER ポインタを使用すると、基本機能ブロック（基本クラス）のメソッドの実装にアクセスすることもできます。 A SUPER ポインタは、機能ブロックごとに自動的に使用可能になります。使用できます SUPER メソッドおよび関連する機能ブロックの実装でのみ。 ポインターの間接参照： SUPER^ を使用して SUPER ポインタ： SUPER キーワードを使用して、基本クラスまたは親クラスのインスタンスで有効なメソッドを呼び出します。 例 ST SUPER^.METH_DoIt(); FBD \/ CFC \/ LD 例 の使用 SUPER と THIS ポインタ FUNCTION_BLOCK FB_Base\nVAR_OUTPUT\n iCnt : INT;\nEND_VAR\n\nMETHOD METH_DoIt : BOOL\niCnt := -1;\n\nMETHOD METH_DoAlso : BOOL\nMETH_DoAlso := TRUE;\n\nFUNCTION_BLOCK FB_1 EXTENDS FB_Base\nVAR_OUTPUT\n iBase : INT;\nEND_VAR\n\nTHIS^.METH_DoIt(); \/\/Call of the methods of FB_1\nTHIS^.METH_DoAlso();\n\nSUPER^.METH_DoIt(); \/\/Call of the methods of FB_Base\nSUPER^.METH_DoAlso();\niBase := SUPER^.iCnt;\n\nMETHOD METH_DoIt : BOOL\niCnt := 1111;\nMETH_DoIt := TRUE;\n\nPROGRAM PLC_PRG\nVAR\n myBase : FB_Base;\n myFB_1 : FB_1;\n iTHIS : INT;\n iBase : INT;\nEND_VAR\nmyBase();\niBase := myBase.iCnt;\nmyFB_1();\niTHIS := myFB_1.iCnt; THIS 命令リスト（IL）にはまだ実装されていません。 " }, 
{ "title" : "ポインター： THIS ", 
"url" : "_cds_pointer_this.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ ポインター： THIS ", 
"snippet" : "THIS The THIS ポインタは、オブジェクト指向プログラミングに使用される特別な変数です。 THIS 自身の関数ブロックインスタンスへの関数ブロックのポインタです。 A THIS ポインタは、機能ブロックごとに自動的に使用可能になります。使用できます THIS メソッドと機能ブロックでのみ。 THIS カテゴリの入力アシスタントでの実装に使用できます キーワード 。 ポインターの間接参照： THIS^ の使用 THIS ポインター ローカル変数がメソッド内の関数ブロック変数をオーバーライドする場合は、関数ブロック変数を次のように設定できます。 THIS ポインタ。以下の例を参照してくだ...", 
"body" : "THIS The THIS ポインタは、オブジェクト指向プログラミングに使用される特別な変数です。 THIS 自身の関数ブロックインスタンスへの関数ブロックのポインタです。 A THIS ポインタは、機能ブロックごとに自動的に使用可能になります。使用できます THIS メソッドと機能ブロックでのみ。 THIS カテゴリの入力アシスタントでの実装に使用できます キーワード 。 ポインターの間接参照： THIS^ の使用 THIS ポインター ローカル変数がメソッド内の関数ブロック変数をオーバーライドする場合は、関数ブロック変数を次のように設定できます。 THIS ポインタ。以下の例を参照してください（1） 関数ブロック自体の関数ブロックインスタンスへのポインタが、関数で使用するために参照されている場合。 （以下の例（2）を参照） 例 ST THIS^.METH_DoIt(); FBD \/ CFC \/ LD 例 The iVarB ローカル変数は iVarB 機能ブロック変数。 FUNCTION_BLOCK fbA\nVAR_INPUT\n iVarA: INT;\nEND_VAR\niVarA := 1;\n\nFUNCTION_BLOCK fbB EXTENDS fbA\nVAR_INPUT\n iVarB: INT := 0;\nEND_VAR\niVarA := 11;\niVarB := 2;\n\n METHOD DoIt : BOOL\n VAR_INPUT\n END_VAR\n VAR\n iVarB: INT;\n END_VAR\n iVarB := 22; \/\/ The local variable iVarB is set.\n THIS^.iVarB := 222; \/\/ The function block variable iVarB is set even though iVarB is obscured.\n\nPROGRAM PLC_PRG\nVAR\n MyfbB: fbB;\nEND_VAR\n\nMyfbB(iVarA:=0, iVarB:= 0);\nMyfbB.DoIt(); 例 関数呼び出しには、それ自体のインスタンスへの参照が必要です。 FUNCTION funA\nVAR_INPUT\n pFB: fbA;\nEND_VAR\n...;\n\nFUNCTION_BLOCK fbA\nVAR_INPUT\n iVarA: INT;\nEND_VAR\n...;\n\nFUNCTION_BLOCK fbB EXTENDS fbA\nVAR_INPUT\n iVarB: INT := 0;\nEND_VAR\niVarA := 11;\niVarB := 2;\n\n METHOD DoIt : BOOL\n VAR_INPUT\n END_VAR\n VAR\n iVarB: INT;\n END_VAR\n iVarB := 22; \/\/The local variable iVarB is set.\n funA(pFB := THIS^); \/\/funA is called via THIS^.\n\nPROGRAM PLC_PRG\nVAR\n MyfbB: fbB;\nEND_VAR\nMyfbB(iVarA:=0 , iVarB:= 0);\nMyfbB.DoIt(); THIS 命令リスト（IL）にはまだ実装されていません。 " }, 
{ "title" : "データ型: 暗黙の列挙 ", 
"url" : "_cds_datatype_implicit_enumeration.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ データ型: 暗黙の列挙 ", 
"snippet" : "暗黙の列挙 暗黙的な列挙により、ローカル POU 内でのみ有効な新しい列挙変数を簡単に宣言できます。このタイプの変数は、コンポーネント リストで宣言されている限られた数の整数値を取ることができます。 暗黙的な列挙には、データ型の名前または識別子がありません。 宣言 : <variable name> : ( <list of component names> ) := <initialization>; <list of component names> 必要な数のコンポーネントを含むコンポーネント名のカンマ区切りリスト 各コンポーネントは、0 から始まる整数値を表します。次のコンポーネントの...", 
"body" : "暗黙の列挙 暗黙的な列挙により、ローカル POU 内でのみ有効な新しい列挙変数を簡単に宣言できます。このタイプの変数は、コンポーネント リストで宣言されている限られた数の整数値を取ることができます。 暗黙的な列挙には、データ型の名前または識別子がありません。 宣言 : <variable name> : ( <list of component names> ) := <initialization>; <list of component names> 必要な数のコンポーネントを含むコンポーネント名のカンマ区切りリスト 各コンポーネントは、0 から始まる整数値を表します。次のコンポーネントの値は、毎回 1 ずつ増加します。 例： Alfa, Bravo, Charlie, Delta, Echo コンポーネントに固定値を割り当てることもできます。 例： Zero, Alfa:=10, Bravo:=20, Charlie:=30, Delta:=40, Echo <initialization> オプション 初期値、通常はコンポーネント 電話 : 例 PROGRAM PLC_PRG\nVAR\n iAlphabet : (Alfa, Bravo, Charlie, Delta, Echo) := Echo;\n strText : STRING;\n iNumber : INT;\nEND_VAR CASE iAlphabet OF\n\tAlfa:\n\tstrText := 'A';\n\t\n\tBravo: \n\tstrText := 'B';\n\t\n\tCharlie:\n\tstrText := 'C';\n\t\n\tDelta:\n\tstrText := 'D';\n\t\n\tEcho:\n\tstrText := 'E';\nEND_CASE\niNumber := iAlphabet; " }, 
{ "title" : "内部データ型 ", 
"url" : "_cds_datatype_implicit_enumeration.html#UUID-839e1fb0-3d1c-7e8f-1286-1f54053bb20b_section-idm4597855524900833552049065596", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 変数 \/ データ型: 暗黙の列挙 \/ 内部データ型 ", 
"snippet" : "暗黙的な列挙では、データ型が内部的に作成され、その名前は次のスキームに従います。 IMPLICIT_ENUM_ <POU name> _ <variable name> ただし、内部識別子が異なる可能性は常にあるため、この内部識別子は使用しないでください。...", 
"body" : "暗黙的な列挙では、データ型が内部的に作成され、その名前は次のスキームに従います。 IMPLICIT_ENUM_ <POU name> _ <variable name> ただし、内部識別子が異なる可能性は常にあるため、この内部識別子は使用しないでください。 " }, 
{ "title" : "オペレーター ", 
"url" : "_cds_struct_reference_operators.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター ", 
"snippet" : "CODESYS V3はすべてのIEC 61131-3演算子をサポートしています。これらの演算子はプロジェクト全体で暗黙的に認識されます。これらのIEC演算子に加えて、 CODESYS IEC 61131-3 以外の演算子もいくつかサポートします。 演算子は関数などのブロック内で使用されます。 ST 演算子の処理順序 (結合強度) については、「ST 式」の章を参照してください。 浮動小数点データ型の演算の場合、計算結果は適用されるターゲット システムのハードウェアによって異なります。 データ型にオーバーフローまたはアンダーフローがある操作の場合、計算結果は適用されるターゲット システムのハード...", 
"body" : "CODESYS V3はすべてのIEC 61131-3演算子をサポートしています。これらの演算子はプロジェクト全体で暗黙的に認識されます。これらのIEC演算子に加えて、 CODESYS IEC 61131-3 以外の演算子もいくつかサポートします。 演算子は関数などのブロック内で使用されます。 ST 演算子の処理順序 (結合強度) については、「ST 式」の章を参照してください。 浮動小数点データ型の演算の場合、計算結果は適用されるターゲット システムのハードウェアによって異なります。 データ型にオーバーフローまたはアンダーフローがある操作の場合、計算結果は適用されるターゲット システムのハードウェアによって異なります。 " }, 
{ "title" : "データ型のオーバーフロー\/アンダーフロー ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4547044759401632680609081132", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ データ型のオーバーフロー\/アンダーフロー ", 
"snippet" : "の CODESYS コンパイラはターゲット デバイス用のコードを生成し、常にターゲット デバイスで定義されたネイティブ サイズで一時結果を計算します。たとえば、x86 および ARM システムでは少なくとも 32 ビットの一時値で計算が実行され、x64 システムでは常に 64 ビットの一時値で計算が実行されます。これにより、計算速度が大幅に向上し、多くの場合、目的の結果も得られます。ただし、これは、場合によっては、データ型のオーバーフローまたはアンダーフローが切り捨てられないことも意味します。 例 例1 この加算の結果は切り捨てられず、 dwVar は 65536 。 VAR wVar : W...", 
"body" : "の CODESYS コンパイラはターゲット デバイス用のコードを生成し、常にターゲット デバイスで定義されたネイティブ サイズで一時結果を計算します。たとえば、x86 および ARM システムでは少なくとも 32 ビットの一時値で計算が実行され、x64 システムでは常に 64 ビットの一時値で計算が実行されます。これにより、計算速度が大幅に向上し、多くの場合、目的の結果も得られます。ただし、これは、場合によっては、データ型のオーバーフローまたはアンダーフローが切り捨てられないことも意味します。 例 例1 この加算の結果は切り捨てられず、 dwVar は 65536 。 VAR\nwVar : WORD;\ndwVar: DWORD;\nEND_VAR\n\nwVar := 65535;\ndwVar := wVar + 1; 例2 データ型のオーバーフローとアンダーフローは切り捨てられず、結果（ bVar1, bVar2 ）は、両方の比較において FALSE 32 ビットおよび 64 ビットのハードウェアで。 VAR\nwVar1 : WORD;\nwVar2 : WORD;\nbVar1 : BOOL;\nbVar2 : BOOL;\nEND_VAR\n\nwVar1 := 65535;\nwVar2 := 0;\nbVar1 := (wVar1 + 1) = wVar2;\nbVar2 := (wVar2 - 1) = wVar1; 例3 割り当てによって wVar3 値はターゲットデータ型に切り捨てられます WORD そしてその結果 bvar1 は TRUE 。 VAR\nwVar1 : WORD;\nwVar2 : WORD;\nwVar3 : WORD;\nbVar1 : BOOL;\nEND_VAR\n\nwVar1 := 65535;\nwVar2 := 0;\nwVar3 := (wVar1 + 1);\nbVar1 := wVar3 = wVar2; 例4 コンパイラに一時的な結果を強制的に切り捨てさせるには、変換を挿入することができます。 型変換により、両方の比較が16ビットのみになり、結果（ bVar1, bVar2 ）は、両方の比較においてそれぞれ TRUE 。 VAR\nwVar1 : WORD;\nwVar2 : WORD;\nbVar1 : BOOL;\nbVar2 : BOOL;\nEND_VAR\n\nwVar1 := 65535;\nwVar2 := 0;\nbVar1 := TO_WORD(wVar1 + 1) = wVar2;\nbVar2 := TO_WORD(wVar2 - 1) = wVar1; " }, 
{ "title" : "算術演算子 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4547044771580832680618577688", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 算術演算子 ", 
"snippet" : "ADDSUBMULDIVMODMOVEINDEXOFSIZEOFXSIZEOF...", 
"body" : "ADDSUBMULDIVMODMOVEINDEXOFSIZEOFXSIZEOF" }, 
{ "title" : "ビット文字列演算子 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4613160039052832680627943345", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ ビット文字列演算子 ", 
"snippet" : "ANDORXORNOTAND_THENOR_ELSE...", 
"body" : "ANDORXORNOTAND_THENOR_ELSE" }, 
{ "title" : "ビットシフト演算子 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4614490322289632680632942766", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ ビットシフト演算子 ", 
"snippet" : "SHLSHRROLROR...", 
"body" : "SHLSHRROLROR" }, 
{ "title" : "選択演算子 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4613159872158432680635250845", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 選択演算子 ", 
"snippet" : "SELMAXMINLIMITMUX...", 
"body" : "SELMAXMINLIMITMUX" }, 
{ "title" : "比較演算子 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4547044751392032680639121857", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 比較演算子 ", 
"snippet" : "比較演算子は、2 つの入力 (最初のオペランドと 2 番目のオペランド) を比較するブール値です。 GTLTLEGEEQNE...", 
"body" : "比較演算子は、2 つの入力 (最初のオペランドと 2 番目のオペランド) を比較するブール値です。 GTLTLEGEEQNE" }, 
{ "title" : "アドレス演算子 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4547044729646432680646324029", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ アドレス演算子 ", 
"snippet" : "ADRコンテンツオペレーターBITADR...", 
"body" : "ADRコンテンツオペレーターBITADR" }, 
{ "title" : "オペレーターを呼び出す ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4613160098891232680647867881", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーターを呼び出す ", 
"snippet" : "CAL...", 
"body" : "CAL" }, 
{ "title" : "型変換演算子 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_section-idm4613160045062432680609282328", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 型変換演算子 ", 
"snippet" : "型変換演算子を明示的に呼び出すことができます。以下に説明する型変換演算子は、ある基本型から別の基本型への型指定変換やオーバーロードに使用できます。「大きい」型から「小さい」型への変換も暗黙的に可能です（たとえば、 INT に BYTE または DINT に WORD ）。 型変換: <elementary data type> _TO_ another elementary data type> オーバーロードされた変換: TO_ <elementary data type> 基本データ型 <elementary data type> = __UXINT | __XINT | __XWORD ...", 
"body" : "型変換演算子を明示的に呼び出すことができます。以下に説明する型変換演算子は、ある基本型から別の基本型への型指定変換やオーバーロードに使用できます。「大きい」型から「小さい」型への変換も暗黙的に可能です（たとえば、 INT に BYTE または DINT に WORD ）。 型変換: <elementary data type> _TO_ another elementary data type> オーバーロードされた変換: TO_ <elementary data type> 基本データ型 <elementary data type> =\n__UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT | TIME | TOD | UDINT | UINT | ULINT | USINT | WORD キーワード T 、 TIME_OF_DAY そして DATE_AND_TIME データ型の代替形式 TIME 、 TOD 、 そして DT 。 T 、 TIME_OF_DAY そして DATE_AND_TIME 型変換コマンドとしては表されません。 型変換演算子のオペランド値がターゲットデータ型の値の範囲外の場合、結果の出力はプロセッサの種類に依存し、未定義になります。これは、たとえば、負のオペランド値が変換された場合に当てはまります。 LREAL ターゲットデータ型に UINT 。 大きなデータ型から小さなデータ型に変換すると、情報が失われる可能性があります。 変換時の文字列操作 STRING または WSTRING 型を変換する場合 STRING または WSTRING 、型付けされた値は文字列として左揃えされ、長すぎる場合は切り捨てられます。したがって、型変換演算子の戻り変数を宣言します。 <>_TO_STRING そして <>_TO_WSTRING 操作しなくても文字列に十分なスペースが確保されるほど十分に長い。 REAL, LREALTIME, LTIMEDATE, DT, TOD, LDATE, LDT, LTODSTRING, WSTRINGTRUNCTRUNC_INT" }, 
{ "title" : "数値演算子 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_UUID-078cb7af-b708-bb5b-645f-7aa04bb4e566", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 数値演算子 ", 
"snippet" : "ABSSQRTLNLOGEXPEXPTSINASINCOSACOSTANATAN...", 
"body" : "ABSSQRTLNLOGEXPEXPTSINASINCOSACOSTANATAN" }, 
{ "title" : "名前空間演算子 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_UUID-eaf6bdfd-66b9-ab9a-08fc-829c9410631e", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 名前空間演算子 ", 
"snippet" : "名前空間演算子は、IEC 61131-3 演算子から拡張されたものです。これにより、プロジェクト内の変数やモジュールに同じ名前を複数回使用する場合でも、変数やモジュールへの一意のアクセスを提供できるようになります。 グローバル名前空間グローバル変数リストの名前空間列挙型名前空間ライブラリの名前空間__POOL...", 
"body" : "名前空間演算子は、IEC 61131-3 演算子から拡張されたものです。これにより、プロジェクト内の変数やモジュールに同じ名前を複数回使用する場合でも、変数やモジュールへの一意のアクセスを提供できるようになります。 グローバル名前空間グローバル変数リストの名前空間列挙型名前空間ライブラリの名前空間__POOL" }, 
{ "title" : "マルチコア演算子 ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_UUID-2fa16f56-92bc-e076-7c16-e327a025cba1", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ マルチコア演算子 ", 
"snippet" : "異なるタスクを操作するには、これらのタスクを同期する必要があります。これは、マルチコア プラットフォームで作業する場合に特に当てはまります。 CODESYS この同期をサポートするためにいくつかの特別な演算子を提供します。 これらの演算子はIEC-61131-3の拡張です。 TEST_AND_SET そして __COMPARE_AND_SWAP 同様のタスクに使用されます。 TEST_AND_SET__COMPARE_AND_SWAP__XADD...", 
"body" : "異なるタスクを操作するには、これらのタスクを同期する必要があります。これは、マルチコア プラットフォームで作業する場合に特に当てはまります。 CODESYS この同期をサポートするためにいくつかの特別な演算子を提供します。 これらの演算子はIEC-61131-3の拡張です。 TEST_AND_SET そして __COMPARE_AND_SWAP 同様のタスクに使用されます。 TEST_AND_SET__COMPARE_AND_SWAP__XADD" }, 
{ "title" : "その他のオペレーター ", 
"url" : "_cds_struct_reference_operators.html#UUID-cb6adbdf-916d-cc61-8b5b-a5e577bef114_UUID-953f3232-5824-b4c4-ff29-e4248bf72edd", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ その他のオペレーター ", 
"snippet" : "__DELETE__ISVALIDREF__NEW__QUERYINTERFACE__QUERYPOINTERINI__TRY, __CATCH, __FINALLY, __ENDTRY__POSITION__POUNAME...", 
"body" : "__DELETE__ISVALIDREF__NEW__QUERYINTERFACE__QUERYPOINTERINI__TRY, __CATCH, __FINALLY, __ENDTRY__POSITION__POUNAME" }, 
{ "title" : "演算子：ADD ", 
"url" : "_cds_operator_add.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：ADD ", 
"snippet" : "ADD IEC演算子は変数を追加します。 許可されるデータ型： __UXINT | __XINT | __XWORD | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT | TIME | TIME_OF_DAY | TOD | UDINT | UINT | ULINT | USINT | WORD 時間データ型の可能な組み合わせ TIME + TIME = TIME TI...", 
"body" : "ADD searchresult_toplevel IEC演算子は変数を追加します。 許可されるデータ型： __UXINT | __XINT | __XWORD | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT | TIME | TIME_OF_DAY | TOD | UDINT | UINT | ULINT | USINT | WORD 時間データ型の可能な組み合わせ TIME + TIME = TIME TIME + LTIME = LTIME LTIME + LTIME = LTIME 日付と時刻のデータ型の可能な組み合わせ TOD + TIME = TOD DT + TIME = DT TOD + LTIME = LTOD DT + LTIME = LDT LTOD + TIME = LTOD LDT + LTIME = LDT LTOD +LTIME = LTOD LDT + LTIME = LDT FBD \/ LDエディターの機能：拡張できます ADD 機能ブロック入力を持つ演算子。追加の機能ブロック入力の数は制限されています。 例 ST var1 := 7+2+4+7; FBD " }, 
{ "title" : "オペレーター：MUL ", 
"url" : "_cds_operator_mul.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：MUL ", 
"snippet" : "MUL IEC演算子は、変数を乗算するために使用されます。 許可されるデータ型： BYTE 、 WORD 、 DWORD 、 LWORD 、 SINT 、 USINT 、 INT 、 UINT 、 DINT 、 UDINT 、 LINT 、 ULINT 、 REAL 、 LREAL 、 TIME FBD \/ LDエディターの機能：拡張できます MUL 追加の機能ブロック入力を持つ演算子。追加の機能ブロック入力の数は制限されています。 例 ST var1 := 7*2*4*7; FBD...", 
"body" : "MUL IEC演算子は、変数を乗算するために使用されます。 許可されるデータ型： BYTE 、 WORD 、 DWORD 、 LWORD 、 SINT 、 USINT 、 INT 、 UINT 、 DINT 、 UDINT 、 LINT 、 ULINT 、 REAL 、 LREAL 、 TIME FBD \/ LDエディターの機能：拡張できます MUL 追加の機能ブロック入力を持つ演算子。追加の機能ブロック入力の数は制限されています。 例 ST var1 := 7*2*4*7; FBD " }, 
{ "title" : "オペレーター：SUB ", 
"url" : "_cds_operator_sub.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：SUB ", 
"snippet" : "SUB IEC演算子は変数を減算します。 許可されるデータ型： BYTE 、 WORD 、 DWORD 、 LWORD 、 SINT 、 USINT 、 INT 、 UINT 、 DINT 、 UDINT 、 LINT 、 ULINT 、 REAL 、 LREAL 、 TIME 、 LTIME 、 TIME_OF_DAY (TOD) 、 LTIME_OF_DAY (LTOD) 、 DATE 、 LDATE 、 DATE_AND_TIME (DT) LDATE_AND_TIME (DT) 時間データ型の可能な組み合わせ TIME - TIME = TIME LTIME - LTIME = LTI...", 
"body" : "SUB IEC演算子は変数を減算します。 許可されるデータ型： BYTE 、 WORD 、 DWORD 、 LWORD 、 SINT 、 USINT 、 INT 、 UINT 、 DINT 、 UDINT 、 LINT 、 ULINT 、 REAL 、 LREAL 、 TIME 、 LTIME 、 TIME_OF_DAY (TOD) 、 LTIME_OF_DAY (LTOD) 、 DATE 、 LDATE 、 DATE_AND_TIME (DT) LDATE_AND_TIME (DT) 時間データ型の可能な組み合わせ TIME - TIME = TIME LTIME - LTIME = LTIME 日付と時刻のデータ型の可能な組み合わせ DATE - DATE = TIME LDATE - LDATE = LTIME TOD - TIME = TOD LTOD - LTIME = LTOD TOD - TOD = TIME LTOD - LTOD = LTIME DT - TIME = DT LDT - LTIME = LDT DT - DT = TIME LDT - LDT = LTIME ネガティブ TIME\/LTIME 値は未定義です。 例 ST var1 := 7-2; FBD " }, 
{ "title" : "オペレーター：DIV ", 
"url" : "_cds_operator_div.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：DIV ", 
"snippet" : "DIV IEC演算子は、変数を除算するために使用されます。 許可されるデータ型： BYTE 、 WORD 、 DWORD 、 LWORD 、 SINT 、 USINT 、 INT 、 UINT 、 DINT 、 UDINT 、 LINT 、 ULINT 、 REAL 、 LREAL 、 TIME ゼロ除算は、ターゲットシステムによって異なる結果になる場合があります。 例 ST var1 := 8\/2; FBD 1.一連のDIVブロック、2。単一のDIVブロック、3。EN\/ ENOパラメーターを使用したDIVPOU 暗黙の監視機能を使用することにより、実行時にゼロによる除算を監視できることに注意...", 
"body" : "DIV IEC演算子は、変数を除算するために使用されます。 許可されるデータ型： BYTE 、 WORD 、 DWORD 、 LWORD 、 SINT 、 USINT 、 INT 、 UINT 、 DINT 、 UDINT 、 LINT 、 ULINT 、 REAL 、 LREAL 、 TIME ゼロ除算は、ターゲットシステムによって異なる結果になる場合があります。 例 ST var1 := 8\/2; FBD 1.一連のDIVブロック、2。単一のDIVブロック、3。EN\/ ENOパラメーターを使用したDIVPOU 暗黙の監視機能を使用することにより、実行時にゼロによる除算を監視できることに注意してください。 CheckDivInt 、 CheckDivLint 、 CheckDivReal 、 と CheckDivLReal 。 " }, 
{ "title" : "オペレーター：MOD ", 
"url" : "_cds_operator_mod.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：MOD ", 
"snippet" : "MOD IEC演算子は、モジュロ除算に使用されます。 関数の結果は、除算の非負の整数剰余です。 許可されるデータ型： BYTE 、 WORD 、 DWORD 、 LWORD 、 SINT 、 USINT 、 INT 、 UINT 、 DINT 、 UDINT 、 LINT 、 ULINT ゼロ除算は、ターゲットシステムによって異なる結果になる場合があります。 例 Var1の結果：1 ST var1 := 9 MOD 2; FBD...", 
"body" : "MOD IEC演算子は、モジュロ除算に使用されます。 関数の結果は、除算の非負の整数剰余です。 許可されるデータ型： BYTE 、 WORD 、 DWORD 、 LWORD 、 SINT 、 USINT 、 INT 、 UINT 、 DINT 、 UDINT 、 LINT 、 ULINT ゼロ除算は、ターゲットシステムによって異なる結果になる場合があります。 例 Var1の結果：1 ST var1 := 9 MOD 2; FBD " }, 
{ "title" : "オペレーター：MOVE ", 
"url" : "_cds_operator_move.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：MOVE ", 
"snippet" : "MOVE IEC演算子は、対応するタイプの別の変数に変数を割り当てるために使用されます。 なぜなら MOVE はCFC、FBD、およびLDエディターで使用でき、変数の割り当てにEN \/ ENO機能を使用することもできます。 EN \/ ENO機能に関連するCFC CODESYS の値を割り当てます var1 変数 var2 変数の場合のみ en_i is TRUE 。 ST ivar2 := MOVE(ivar1); に対応します： ivar2 := ivar1;...", 
"body" : "MOVE IEC演算子は、対応するタイプの別の変数に変数を割り当てるために使用されます。 なぜなら MOVE はCFC、FBD、およびLDエディターで使用でき、変数の割り当てにEN \/ ENO機能を使用することもできます。 EN \/ ENO機能に関連するCFC CODESYS の値を割り当てます var1 変数 var2 変数の場合のみ en_i is TRUE 。 ST ivar2 := MOVE(ivar1); に対応します： ivar2 := ivar1; " }, 
{ "title" : "演算子：INDEXOF ", 
"url" : "_cds_operator_indexof.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：INDEXOF ", 
"snippet" : "INDEXOF 演算子は、IEC61131-3規格の拡張です。 の代わりに INDEXOF 演算子、 ADR 演算子はで提供されます CODESYS POUのインデックスでポインタを取得するためのV3。...", 
"body" : "INDEXOF 演算子は、IEC61131-3規格の拡張です。 の代わりに INDEXOF 演算子、 ADR 演算子はで提供されます CODESYS POUのインデックスでポインタを取得するためのV3。 " }, 
{ "title" : "演算子：SIZEOF ", 
"url" : "_cds_operator_sizeof.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：SIZEOF ", 
"snippet" : "SIZEOF コンパイラバージョン3.5.16.0以降では、 XSIZEOF この演算子の代わりに演算子を使用する必要があります。 演算子は、IEC61131-3規格の拡張です。 構文 : <return value> := SIZEOF( <variable name> | <date type name> ); 演算子は、渡された変数またはデータ型に必要なバイト数を決定します。符号なしの値が常に返されます。戻り値の型は、渡されたオペランドの型 (変数またはデータ型) に適合します。 戻り値: <return value> 暗黙的に使用される戻り値のデータ型 0 <= <return val...", 
"body" : "SIZEOF コンパイラバージョン3.5.16.0以降では、 XSIZEOF この演算子の代わりに演算子を使用する必要があります。 演算子は、IEC61131-3規格の拡張です。 構文 : <return value> := SIZEOF( <variable name> | <date type name> ); 演算子は、渡された変数またはデータ型に必要なバイト数を決定します。符号なしの値が常に返されます。戻り値の型は、渡されたオペランドの型 (変数またはデータ型) に適合します。 戻り値: <return value> 暗黙的に使用される戻り値のデータ型 0 <= <return value> <256 USINT 256 <= <return value> < 65536 UINT 65536 <= <return value> < 4294967296 UDINT 4294967296 <= <return value> ULINT STでの例 PROGRAM PLC_PRG\nVAR\n\taData_1 : ARRAY[0..4] OF INT;\n\tiReturnValue : INT;\nEND_VAR iReturnValue := SIZEOF(aData_1); (* iReturnValue := USINT#10; *) での結果 iReturnValue は 10 . " }, 
{ "title" : "演算子：XSIZEOF ", 
"url" : "_cds_operator_xsizeof.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：XSIZEOF ", 
"snippet" : "XSIZEOF 演算子は、IEC61131-3規格の拡張です。 の XSIZEOF operator は、渡された変数またはデータ型に必要なバイト数を決定します。 その際、常に符号なしの値が返されます。戻り値のデータ型 <return value> は次のように固定されています。 ULINT 64 ビット プラットフォームおよびタイプ UDINT 他のすべてのプラットフォームで。すべてのプラットフォームで実行されるコードを生成するには、戻り値を次のように宣言します。 __UXINT データ・タイプ。 構文 : <return value> := XSIZEOF( <variable> ); S...", 
"body" : "XSIZEOF 演算子は、IEC61131-3規格の拡張です。 の XSIZEOF operator は、渡された変数またはデータ型に必要なバイト数を決定します。 その際、常に符号なしの値が返されます。戻り値のデータ型 <return value> は次のように固定されています。 ULINT 64 ビット プラットフォームおよびタイプ UDINT 他のすべてのプラットフォームで。すべてのプラットフォームで実行されるコードを生成するには、戻り値を次のように宣言します。 __UXINT データ・タイプ。 構文 : <return value> := XSIZEOF( <variable> ); STでの例 PROGRAM PLC_PRG\nVAR\n uxiReturnValue : __UXINT; (* Datentyp bei 64-bit-Plattformen: ULINT *)\n aData_1 : ARRAY[0..4] OF INT; \nEND_VAR uxiReturnValue := XSIZEOF(aData_1); 結果： uxiReturnValue = 10 型の変数への代入の場合 __UXINT を使用することをお勧めします。 XSIZEOF 演算子の代わりに SIZEOF オペレーター。これは XSIZEOF 戻り値のデータ型はプラットフォームによって異なります。その結果、SIZEOF 演算子を使用する際の問題は発生しません。 " }, 
{ "title" : "演算子：NOT ", 
"url" : "_cds_operator_not.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：NOT ", 
"snippet" : "NOT IEC演算子はビット単位で使用されます NOT ビットオペランドの。 それぞれの入力ビットが0を生成すると、出力ビットも1を生成し、その逆も同様です。 許可されるデータ型： BOOL 、 BYTE 、 WORD 、 DWORD 、 LWORD 例 結果 Var1 ： 2#0110_1100 ST Var1 := NOT 2#1001_0011; FBD...", 
"body" : "NOT IEC演算子はビット単位で使用されます NOT ビットオペランドの。 それぞれの入力ビットが0を生成すると、出力ビットも1を生成し、その逆も同様です。 許可されるデータ型： BOOL 、 BYTE 、 WORD 、 DWORD 、 LWORD 例 結果 Var1 ： 2#0110_1100 ST Var1 := NOT 2#1001_0011; FBD " }, 
{ "title" : "演算子：AND ", 
"url" : "_cds_operator_and.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：AND ", 
"snippet" : "AND IEC演算子はビット単位で使用されます AND ビットオペランドの。 入力ビットがすべて1を生成する場合、出力ビットも1を生成します。それ以外の場合は0。 許可されるデータ型： BOOL 、 BYTE 、 WORD 、 DWORD 、 LWORD 例 結果 var1: 2#1000_0010 ST var1 := 2#1001_0011 AND 2#1000_1010; FBD...", 
"body" : "AND searchresult_toplevel IEC演算子はビット単位で使用されます AND ビットオペランドの。 入力ビットがすべて1を生成する場合、出力ビットも1を生成します。それ以外の場合は0。 許可されるデータ型： BOOL 、 BYTE 、 WORD 、 DWORD 、 LWORD 例 結果 var1: 2#1000_0010 ST var1 := 2#1001_0011 AND 2#1000_1010; FBD " }, 
{ "title" : "演算子：OR ", 
"url" : "_cds_operator_or.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：OR ", 
"snippet" : "OR IEC演算子はビット単位で使用されます OR ビットオペランドの。 入力ビットの少なくとも1つが1を生成する場合、出力ビットも1を生成します。それ以外の場合は0。 許可されるデータ型： BOOL 、 BYTE 、 WORD 、 DWORD 、 LWORD 例 結果 Var1 ： 2#1001_1011 ST Var1 := 2#1001_0011 OR 2#1000_1010; FBD...", 
"body" : "OR IEC演算子はビット単位で使用されます OR ビットオペランドの。 入力ビットの少なくとも1つが1を生成する場合、出力ビットも1を生成します。それ以外の場合は0。 許可されるデータ型： BOOL 、 BYTE 、 WORD 、 DWORD 、 LWORD 例 結果 Var1 ： 2#1001_1011 ST Var1 := 2#1001_0011 OR 2#1000_1010; FBD " }, 
{ "title" : "演算子：XOR ", 
"url" : "_cds_operator_xor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：XOR ", 
"snippet" : "XOR IEC演算子はビット単位で使用されます XOR ビットオペランドの。 2つの入力ビットの1つだけが1を生成する場合、出力ビットも1を生成します。両方の入力が1または0を生成する場合、出力は0を生成します。 許可されるデータ型： BOOL 、 BYTE 、 WORD 、 DWORD 、 LWORD 次の動作に注意してください XOR 拡張形式のPOU（3つ以上の入力）：入力をペアで比較し、次に対応する結果を比較します（標準に従っていますが、必ずしも期待どおりではありません）。 例 結果 var1 ： 2#0001_1001 ST var1 := 2#1001_0011 XOR 2#100...", 
"body" : "XOR IEC演算子はビット単位で使用されます XOR ビットオペランドの。 2つの入力ビットの1つだけが1を生成する場合、出力ビットも1を生成します。両方の入力が1または0を生成する場合、出力は0を生成します。 許可されるデータ型： BOOL 、 BYTE 、 WORD 、 DWORD 、 LWORD 次の動作に注意してください XOR 拡張形式のPOU（3つ以上の入力）：入力をペアで比較し、次に対応する結果を比較します（標準に従っていますが、必ずしも期待どおりではありません）。 例 結果 var1 ： 2#0001_1001 ST var1 := 2#1001_0011 XOR 2#1000_1010; FBD " }, 
{ "title" : "演算子：AND_THEN ", 
"url" : "_cds_operator_and_then.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：AND_THEN ", 
"snippet" : "AND_THEN 演算子は、IEC61131-3規格の拡張です。 The AND_THEN 演算子は、構造化テキストでのプログラミングにのみ許可されます。 AND の操作 BOOL と BIT 短絡評価のあるオペランド。これの意味は： すべてのオペランドが TRUE 、オペランドの結果も次のようになります TRUE ;それ以外は FALSE 。 でも、 CODESYS また、他のオペランドの式は、 AND_THEN 演算子は TRUE 。これにより、たとえば次のような条件でのnullポインタの問題を防ぐことができます。 IF (ptr <> 0 AND_THEN ptr^ = 99) THEN...", 
"body" : "AND_THEN 演算子は、IEC61131-3規格の拡張です。 The AND_THEN 演算子は、構造化テキストでのプログラミングにのみ許可されます。 AND の操作 BOOL と BIT 短絡評価のあるオペランド。これの意味は： すべてのオペランドが TRUE 、オペランドの結果も次のようになります TRUE ;それ以外は FALSE 。 でも、 CODESYS また、他のオペランドの式は、 AND_THEN 演算子は TRUE 。これにより、たとえば次のような条件でのnullポインタの問題を防ぐことができます。 IF (ptr <> 0 AND_THEN ptr^ = 99) THEN... 。 対照的に、 CODESYS を使用する場合、常にすべてのオペランドを評価します AND IECオペレーター。 " }, 
{ "title" : "演算子：OR_ELSE ", 
"url" : "_cds_operator_or_else.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：OR_ELSE ", 
"snippet" : "OR_ELSE 演算子は、IEC61131-3規格の拡張です。 The OR_ELSE 演算子は、構造化テキストでのプログラミングにのみ許可されています。 OR の操作 BOOL と BIT 短絡評価のあるオペランド。これの意味は： オペランドの少なくとも1つが TRUE 、操作の結果も次のようになります TRUE ;それ以外は FALSE 。 を使用するのとは対照的に OR IEC演算子、 OR_ELSE 他のすべての演算子の式は、オペランドの1つが次のように評価されるとすぐには評価されません。 TRUE 。 例 VAR bEver: BOOL; bX: BOOL; dw: DWORD :=...", 
"body" : "OR_ELSE 演算子は、IEC61131-3規格の拡張です。 The OR_ELSE 演算子は、構造化テキストでのプログラミングにのみ許可されています。 OR の操作 BOOL と BIT 短絡評価のあるオペランド。これの意味は： オペランドの少なくとも1つが TRUE 、操作の結果も次のようになります TRUE ;それ以外は FALSE 。 を使用するのとは対照的に OR IEC演算子、 OR_ELSE 他のすべての演算子の式は、オペランドの1つが次のように評価されるとすぐには評価されません。 TRUE 。 例 VAR\n bEver: BOOL;\n bX: BOOL;\n dw: DWORD := 16#000000FF;\nEND_VAR\n\nbEver := FALSE;\nbX := dw.8 OR_ELSE dw.1 OR_ELSE (bEver := TRUE); dw.8 は FALSE と dw.1 は TRUE 。したがって、結果 bX 操作の TRUE 。ただし、3番目の入力の式は実行されず、 bEver 残っている FALSE 。一方、標準のOR演算を使用した場合は、 bEver TRUEに設定されます。 " }, 
{ "title" : "オペレーター：SHL ", 
"url" : "_cds_operator_shl.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：SHL ", 
"snippet" : "SHL IEC演算子は、オペランドをビット単位で左にシフトするために使用されます。 erg := SHL (in, n) in ：左にシフトしたオペランド n ：シフトするビット数 in 左の方です もしも n データ型の幅を超える場合は、ターゲットシステムによって異なります。 BYTE 、 WORD 、 DWORD 、 と LWORD オペランドはパディングされます。ターゲットシステムは、ゼロまたは n MOD <レジスタサイズ> 。 ビット数に注意してください CODESYS 入力変数のデータ型によって定義されたこの操作の使用 in 。 例 の結果 erg_byte と erg_word ...", 
"body" : "SHL IEC演算子は、オペランドをビット単位で左にシフトするために使用されます。 erg := SHL (in, n) in ：左にシフトしたオペランド n ：シフトするビット数 in 左の方です もしも n データ型の幅を超える場合は、ターゲットシステムによって異なります。 BYTE 、 WORD 、 DWORD 、 と LWORD オペランドはパディングされます。ターゲットシステムは、ゼロまたは n MOD <レジスタサイズ> 。 ビット数に注意してください CODESYS 入力変数のデータ型によって定義されたこの操作の使用 in 。 例 の結果 erg_byte と erg_word の値は異なりますが、 in_byte と in_word 入力変数は同じであり、入力変数のデータ型は異なります。 ST PROGRAM shl_st\nVAR\n in_byte : BYTE := 16#45; (* 2#01000101 )\n in_word : WORD := 16#0045; (* 2#0000000001000101 )\n erg_byte : BYTE;\n erg_word : WORD;\n n: BYTE := 2;\nEND_VAR\n\nerg_byte := SHL(in_byte,n); (* Result is 16#14, 2#00010100 *)\nerg_word := SHL(in_word,n); (* Result is 16#0114, 2#0000000100010100 *) FBD " }, 
{ "title" : "オペレーター：SHR ", 
"url" : "_cds_operator_shr.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：SHR ", 
"snippet" : "SHR IEC演算子は、オペランドをビット単位で右にシフトするために使用されます。 erg := SHR (in, n) in ：右にシフトしたオペランド n ：シフトするビット数 in 右の方へ もしも n データ型の幅を超える場合は、ターゲットシステムによって異なります。 BYTE 、 WORD 、 DWORD 、 と LWORD オペランドはパディングされます。ターゲットシステムは、ゼロまたは n MOD <レジスタサイズ> 。 例 ST PROGRAM shr_st VAR in_byte : BYTE := 16#45; (* 2#01000101 ) in_word : WORD ...", 
"body" : "SHR IEC演算子は、オペランドをビット単位で右にシフトするために使用されます。 erg := SHR (in, n) in ：右にシフトしたオペランド n ：シフトするビット数 in 右の方へ もしも n データ型の幅を超える場合は、ターゲットシステムによって異なります。 BYTE 、 WORD 、 DWORD 、 と LWORD オペランドはパディングされます。ターゲットシステムは、ゼロまたは n MOD <レジスタサイズ> 。 例 ST PROGRAM shr_st\nVAR\n in_byte : BYTE := 16#45; (* 2#01000101 )\n in_word : WORD := 16#0045; (* 2#0000000001000101 )\n erg_byte : BYTE;\n erg_word : WORD;\n n: BYTE := 2;\nEND_VAR\n\nerg_byte := SHR(in_byte,n); (* Result is 16#11, 2#00010001 *)\nerg_word := SHR(in_word,n); (* Result is 16#0011, 2#0000000000010001 *) FBD " }, 
{ "title" : "オペレーター：ROL ", 
"url" : "_cds_operator_rol.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：ROL ", 
"snippet" : "ROL IEC演算子は、オペランドを左にビット単位でローテーションするために使用されます。 許可されるデータ型： BYTE 、 WORD 、 DWORD 、 LWORD erg := ROL (in, n) CODESYS 動く in 左に1ビットをn回追加し、右から左端の位置にビットを追加します。 ビット数に注意してください CODESYS のデータ型によって定義されたこの操作の使用 in 入力変数。これが定数の場合、 CODESYS 可能な限り最小のデータ型を使用します。出力変数のデータ型は、この操作には影響しません。 例 の結果 erg_byte と erg_word 入力変数のデータ型...", 
"body" : "ROL IEC演算子は、オペランドを左にビット単位でローテーションするために使用されます。 許可されるデータ型： BYTE 、 WORD 、 DWORD 、 LWORD erg := ROL (in, n) CODESYS 動く in 左に1ビットをn回追加し、右から左端の位置にビットを追加します。 ビット数に注意してください CODESYS のデータ型によって定義されたこの操作の使用 in 入力変数。これが定数の場合、 CODESYS 可能な限り最小のデータ型を使用します。出力変数のデータ型は、この操作には影響しません。 例 の結果 erg_byte と erg_word 入力変数のデータ型によって異なりますが、 in_byte と in_word 入力変数は同じです。 ST PROGRAM rol_st\n\nVAR\n in_byte : BYTE := 16#45;\n in_word : WORD := 6#45;\n erg_byte : BYTE;\n erg_word : WORD;\n n: BYTE := 2;\nEND_VAR\n\nerg_byte := ROL(in_byte,n); (* Result: 16#15 *)\n\nerg_word := ROL(in_word,n); (* Result: 16#0114 *) FBD IL " }, 
{ "title" : "オペレーター：ROR ", 
"url" : "_cds_operator_ror.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：ROR ", 
"snippet" : "ROR IEC演算子は、オペランドを右にビット単位でローテーションするために使用されます。 許可されるデータ型： BYTE 、 WORD 、 DWORD 、 LWORD erg := ROR(in,n) CODESYS 動く in 右に1ビットをn回追加し、左から右端の位置にビットを追加します。 ビット数 CODESYS この操作の用途は、のデータ型によって定義されます。 in 入力変数。これが定数の場合、 CODESYS 可能な限り最小のデータ型を使用します。出力変数のデータ型は、この操作には影響しません。 例 の結果 erg_byte と erg_word 入力変数のデータ型によって異なり...", 
"body" : "ROR IEC演算子は、オペランドを右にビット単位でローテーションするために使用されます。 許可されるデータ型： BYTE 、 WORD 、 DWORD 、 LWORD erg := ROR(in,n) CODESYS 動く in 右に1ビットをn回追加し、左から右端の位置にビットを追加します。 ビット数 CODESYS この操作の用途は、のデータ型によって定義されます。 in 入力変数。これが定数の場合、 CODESYS 可能な限り最小のデータ型を使用します。出力変数のデータ型は、この操作には影響しません。 例 の結果 erg_byte と erg_word 入力変数のデータ型によって異なりますが、 in_byte と in_word 入力変数は同じです。 ST PROGRAM ror_st\n\nVAR\n in_byte : BYTE := 16#45;\n in_word : WORD := 16#45;\n erg_byte : BYTE;\n erg_word : WORD;\n n: BYTE := 2;\nEND_VAR\n\nerg_byte := ROR(in_byte,n); (* Result: 16#51 *)\nerg_word := ROR(in_word,n); (* Result: 16#4011 *) FBD " }, 
{ "title" : "オペレーター：SEL ", 
"url" : "_cds_operator_sel.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：SEL ", 
"snippet" : "SEL ビット単位の選択にはIEC演算子が使用されます。 OUT := SEL(G, IN0, IN1) 意味： OUT := IN0; もしも G = FALSE OUT := IN1; もしも G = TRUE 許可されるデータ型 IN0 、…、 INn と OUT ：同一のデータ型 特にユーザー定義のデータ型を使用する場合は、3つの位置すべてで同じ型の変数が使用されていることを確認してください。コンパイラは型IDをチェックし、コンパイルエラーを返します。インターフェイス変数への機能ブロックインスタンスの割り当ては、特にサポートされていません。 G ： BOOL いつ G is TRUE ...", 
"body" : "SEL ビット単位の選択にはIEC演算子が使用されます。 OUT := SEL(G, IN0, IN1) 意味： OUT := IN0; もしも G = FALSE OUT := IN1; もしも G = TRUE 許可されるデータ型 IN0 、…、 INn と OUT ：同一のデータ型 特にユーザー定義のデータ型を使用する場合は、3つの位置すべてで同じ型の変数が使用されていることを確認してください。コンパイラは型IDをチェックし、コンパイルエラーを返します。インターフェイス変数への機能ブロックインスタンスの割り当ては、特にサポートされていません。 G ： BOOL いつ G is TRUE 、 CODESYS 先行する式を計算しません IN0 。いつ G は FALSE 、 CODESYS 先行する式を計算しません IN1 。 注意：グラフィカルプログラミング言語の場合、 IN0 と IN1 とは独立して計算されます G の場合の入力 箱 、 ジャンプ 、 戻る 、 ラインブランチ 、 また エッジ検出 先行します。 例 ST Var1 := SEL(TRUE,3,4); (* Result: 4 *) FBD " }, 
{ "title" : "オペレーター：MAX ", 
"url" : "_cds_operator_max.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：MAX ", 
"snippet" : "MAX 最大機能にはIEC演算子を使用します。すべての入力の中で最大の値が得られます。 OUT := MAX(IN0,IN1,IN2,...) 許可されるデータ型：すべて 例 結果：90 ST Var1 := MAX(30,90,40); Var1 := MAX(40,MAX(90,30)); FBD...", 
"body" : "MAX 最大機能にはIEC演算子を使用します。すべての入力の中で最大の値が得られます。 OUT := MAX(IN0,IN1,IN2,...) 許可されるデータ型：すべて 例 結果：90 ST Var1 := MAX(30,90,40);\n\nVar1 := MAX(40,MAX(90,30)); FBD " }, 
{ "title" : "オペレーター：MIN ", 
"url" : "_cds_operator_min.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：MIN ", 
"snippet" : "MIN 最小機能にはIEC演算子を使用します。すべての入力の中で最小の値を生成します。 OUT := MIN(IN0,IN1,IN2,...) 許可されるデータ型：すべて 例 結果： 30 ST Var1 := MIN(90,30,40); Var1 := MIN(MIN(90,30),40); FBD...", 
"body" : "MIN 最小機能にはIEC演算子を使用します。すべての入力の中で最小の値を生成します。 OUT := MIN(IN0,IN1,IN2,...) 許可されるデータ型：すべて 例 結果： 30 ST Var1 := MIN(90,30,40);\n\nVar1 := MIN(MIN(90,30),40); FBD " }, 
{ "title" : "オペレーター：LIMIT ", 
"url" : "_cds_operator_limit.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：LIMIT ", 
"snippet" : "LIMIT 制限にはIEC選択演算子を使用します。 OUT := LIMIT(Min, IN, Max) つまり、次のことを意味します。 OUT := MIN (MAX (IN, Min), Max) Max は上限であり、 Min 結果の下限です。の場合 IN 値が Max 上限、次にLIMITは Max 。の値が IN 最小下限を下回っている場合、結果は次のようになります。 Min 。 許可されるデータ型 IN と OUT ： 全て 例 結果 Var1 ： 80 ST Var1 := LIMIT(30,90,80);...", 
"body" : "LIMIT 制限にはIEC選択演算子を使用します。 OUT := LIMIT(Min, IN, Max) つまり、次のことを意味します。 OUT := MIN (MAX (IN, Min), Max) Max は上限であり、 Min 結果の下限です。の場合 IN 値が Max 上限、次にLIMITは Max 。の値が IN 最小下限を下回っている場合、結果は次のようになります。 Min 。 許可されるデータ型 IN と OUT ： 全て 例 結果 Var1 ： 80 ST Var1 := LIMIT(30,90,80); " }, 
{ "title" : "オペレーター：MUX ", 
"url" : "_cds_operator_mux.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：MUX ", 
"snippet" : "MUX IEC演算子はマルチプレクサとして使用されます。 OUT := MUX(K, IN0,...,INn) つまり、次のことを意味します。 OUT = IN_K 許可されるデータ型 K ： BYTE 、 WORD 、 DWORD 、 LWORD 、 SINT 、 USINT 、 INT 、 UINT 、 DINT 、 LINT 、 ULINT UDINT IN0 、…、 INn と OUT ：同一のデータ型 特にユーザー定義のデータ型を使用する場合は、3つの位置すべてで同じ型の変数が使用されていることを確認してください。コンパイラは型IDをチェックし、コンパイルエラーを返します。インターフ...", 
"body" : "MUX IEC演算子はマルチプレクサとして使用されます。 OUT := MUX(K, IN0,...,INn) つまり、次のことを意味します。 OUT = IN_K 許可されるデータ型 K ： BYTE 、 WORD 、 DWORD 、 LWORD 、 SINT 、 USINT 、 INT 、 UINT 、 DINT 、 LINT 、 ULINT UDINT IN0 、…、 INn と OUT ：同一のデータ型 特にユーザー定義のデータ型を使用する場合は、3つの位置すべてで同じ型の変数が使用されていることを確認してください。コンパイラは型IDをチェックし、コンパイルエラーを返します。インターフェイス変数への機能ブロックインスタンスの割り当ては、特にサポートされていません。 MUX 値のセットからK番目の値を選択します。最初の値はK = 0です。もしも K が他の入力の数（n）より大きい場合、 CODESYS 最後の値を渡します（ INn ）。 ランタイム最適化の場合、 CODESYS 先行する式のみを計算します IN_K 。ただし、シミュレーションモードでは、 CODESYS すべてのブランチを計算します。 例 結果 Var1 ： 30 ST Var1 := MUX(0,30,40,50,60,70,80); " }, 
{ "title" : "オペレーター：GT ", 
"url" : "_cds_operator_gt.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：GT ", 
"snippet" : "GT IEC演算子は、「大なり記号」関数に使用されます。 オペランドの許可されるデータ型：任意の基本データ型 最初のオペランドが2番目のオペランドより大きい場合、演算子は結果を生成します TRUE ;それ以外は FALSE 。 例 結果：FALSE ST VAR1 := 20 > 30; FBD...", 
"body" : "GT IEC演算子は、「大なり記号」関数に使用されます。 オペランドの許可されるデータ型：任意の基本データ型 最初のオペランドが2番目のオペランドより大きい場合、演算子は結果を生成します TRUE ;それ以外は FALSE 。 例 結果：FALSE ST VAR1 := 20 > 30; FBD " }, 
{ "title" : "オペレーター：LT ", 
"url" : "_cds_operator_lt.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：LT ", 
"snippet" : "LT IEC演算子は、「未満」機能に使用されます。 オペランドの許可されるデータ型：任意の基本データ型 最初のオペランドが2番目のオペランドよりも小さい場合、演算子は結果を生成します TRUE ;それ以外は FALSE 。 例 結果： TRUE ST Var1 := 20 < 30;...", 
"body" : "LT IEC演算子は、「未満」機能に使用されます。 オペランドの許可されるデータ型：任意の基本データ型 最初のオペランドが2番目のオペランドよりも小さい場合、演算子は結果を生成します TRUE ;それ以外は FALSE 。 例 結果： TRUE ST Var1 := 20 < 30; " }, 
{ "title" : "オペレーター：LE ", 
"url" : "_cds_operator_le.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：LE ", 
"snippet" : "LE IEC演算子は、「以下」の機能に使用されます。 オペランドの許可されるデータ型：任意の基本データ型 第1オペランドが第2オペランド以下の場合、演算子は結果を生成します TRUE ;それ以外は FALSE 。 例 結果 Var1 ： TRUE ST Var1 := 20 <= 30;...", 
"body" : "LE IEC演算子は、「以下」の機能に使用されます。 オペランドの許可されるデータ型：任意の基本データ型 第1オペランドが第2オペランド以下の場合、演算子は結果を生成します TRUE ;それ以外は FALSE 。 例 結果 Var1 ： TRUE ST Var1 := 20 <= 30; " }, 
{ "title" : "オペレーター：GE ", 
"url" : "_cds_operator_ge.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：GE ", 
"snippet" : "GE IEC演算子は、「以上」の機能に使用されます。 オペランドの許可されるデータ型：任意の基本データ型 第1オペランドが第2オペランド以上の場合、演算子は結果を生成します TRUE ;それ以外は FALSE 。 例 結果： TRUE ST VAR1 := 60 >= 40; FBD...", 
"body" : "GE IEC演算子は、「以上」の機能に使用されます。 オペランドの許可されるデータ型：任意の基本データ型 第1オペランドが第2オペランド以上の場合、演算子は結果を生成します TRUE ;それ以外は FALSE 。 例 結果： TRUE ST VAR1 := 60 >= 40; FBD " }, 
{ "title" : "オペレーター: EQ ", 
"url" : "_cds_operator_eq.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター: EQ ", 
"snippet" : "EQ IEC 演算子は 2 つのオペランドが等しいかどうかを比較します。 すべての基本データ型がオペランドのデータ型として許可されます。 オペランドが等しい場合、演算子は結果を返します。 TRUE 戻る、そうでない場合 FALSE 。 例 結果： VAR1 = TRUE ＳＴ： \/\/実装 VAR1 := 20 = 20; FUP: 基本データ型 基本データ型は、次のデータ型です。 CODESYS Development System 事前定義されたものを利用できます。 IEC 61131-3 で説明されているデータ型に加えて、次のものがあります。 CODESYS - 特定のデータ型 BIT 、...", 
"body" : "EQ IEC 演算子は 2 つのオペランドが等しいかどうかを比較します。 すべての基本データ型がオペランドのデータ型として許可されます。 オペランドが等しい場合、演算子は結果を返します。 TRUE 戻る、そうでない場合 FALSE 。 例 結果： VAR1 = TRUE ＳＴ： \/\/実装 VAR1 := 20 = 20; FUP: 基本データ型 基本データ型は、次のデータ型です。 CODESYS Development System 事前定義されたものを利用できます。 IEC 61131-3 で説明されているデータ型に加えて、次のものがあります。 CODESYS - 特定のデータ型 BIT 、 __UXINT 、 __XINT そして __XWORD 。 基本的なデータ型: \n__UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT | TIME | TOD | TIME_OF_DAY | UDINT | UINT | ULINT | USINT | WORD " }, 
{ "title" : "オペレーター:NE ", 
"url" : "_cds_operator_ne.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター:NE ", 
"snippet" : "NE IEC 演算子は 2 つのオペランドが不等であるかどうかを比較します。 すべての基本データ型がオペランドのデータ型として許可されます。 オペランドが等しくない場合、演算子は結果を返します。 TRUE 戻る、そうでない場合 FALSE 。 例 結果： Var1 = FALSE ＳＴ： Var1 := 40 <> 40; FUP: 基本データ型 基本データ型は、次のデータ型です。 CODESYS Development System 事前定義されたものを利用できます。 IEC 61131-3 で説明されているデータ型に加えて、次のものがあります。 CODESYS - 特定のデータ型 BIT ...", 
"body" : "NE IEC 演算子は 2 つのオペランドが不等であるかどうかを比較します。 すべての基本データ型がオペランドのデータ型として許可されます。 オペランドが等しくない場合、演算子は結果を返します。 TRUE 戻る、そうでない場合 FALSE 。 例 結果： Var1 = FALSE ＳＴ： Var1 := 40 <> 40; FUP: 基本データ型 基本データ型は、次のデータ型です。 CODESYS Development System 事前定義されたものを利用できます。 IEC 61131-3 で説明されているデータ型に加えて、次のものがあります。 CODESYS - 特定のデータ型 BIT 、 __UXINT 、 __XINT そして __XWORD 。 基本的なデータ型: \n__UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT | TIME | TOD | TIME_OF_DAY | UDINT | UINT | ULINT | USINT | WORD " }, 
{ "title" : "オペレーター：ADR ", 
"url" : "_cds_operator_adr.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：ADR ", 
"snippet" : "ADR 演算子は、IEC61131-3規格の拡張です。 ADR 引数の32ビットアドレス（または可能であれば64ビットアドレス）を生成します。このアドレスを製造元の関数に渡すか、プロジェクト内のポインターに割り当てることができます。 構文 VAR <address name> : DWORD | LWORD | POINTER TO < basis data type> | __XWORD ; END_VAR <address name> := ADR( <variable name> ); FUNCTION_BLOCK FB_Adress VAR piAddress1: POINTER TO...", 
"body" : "ADR searchresult_toplevel 演算子は、IEC61131-3規格の拡張です。 ADR 引数の32ビットアドレス（または可能であれば64ビットアドレス）を生成します。このアドレスを製造元の関数に渡すか、プロジェクト内のポインターに割り当てることができます。 構文 VAR\n <address name> : DWORD | LWORD | POINTER TO < basis data type> | __XWORD ;\nEND_VAR\n\n<address name> := ADR( <variable name> ); FUNCTION_BLOCK FB_Adress\nVAR\n piAddress1: POINTER TO INT;\n iVar1 : INT := 5;\n\n lwAddress2 : LWORD;\n iVar2 : INT := 10;\n\n xwAddress3 : _XWORD;\n iVar3 : INT;\nEND_VAR\npiAddress1 := ADR(iVar1); \/\/ piNumber is assigned to address of iVar1\nlwAddress2 := ADR(iVar2); \/\/ works for 64 bit run time system\nxwAddress3 := ADR(iVar3); \/\/ works for 32 bit and 64 bit systems と違う CoDeSys V2.3 、あなたは使用することができます ADR 関数名、プログラム名、関数ブロック名、およびメソッド名を持つ演算子。したがって、 ADR を置き換えます INDEXOF オペレーター。 関数ポインタを使用する場合、関数ポインタを外部ライブラリに渡すことはできますが、内部から関数ポインタを呼び出すことはできないことに注意してください。 CODESYS 。システムコール（ランタイムシステム）を有効にするには、それぞれのオブジェクトプロパティを設定する必要があります（ 建てる タブ）関数オブジェクト用。 オンライン変更を使用すると、アドレスの内容が変わる可能性があります。結果として、 ポインタ 変数が無効なメモリ領域を指している可能性があります。問題を回避するには、ポインタの値がサイクルごとに更新されることを確認する必要があります。 戻らない Pointer-TO 関数とメソッドの変数を呼び出し元に割り当てるか、グローバル変数に割り当てます。 " }, 
{ "title" : "オペレーター：コンテンツオペレーター ", 
"url" : "_cds_operator_content_operator.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：コンテンツオペレーター ", 
"snippet" : "コンテンツオペレーター 演算子は、IEC61131-3規格の拡張です。 演算子を使用すると、ポインターを逆参照できます。演算子を次のように追加します ^ ポインタ識別子に。 アドレスへのポインタを使用する場合、オンライン変更を適用するとアドレスの内容がシフトする可能性があることに注意してください。 例 ST pt : POINTER TO INT; var_int1 : INT; var_int2 : INT; pt := ADR(var_int1); var_int2 := pt^;...", 
"body" : "コンテンツオペレーター 演算子は、IEC61131-3規格の拡張です。 演算子を使用すると、ポインターを逆参照できます。演算子を次のように追加します ^ ポインタ識別子に。 アドレスへのポインタを使用する場合、オンライン変更を適用するとアドレスの内容がシフトする可能性があることに注意してください。 例 ST pt : POINTER TO INT;\nvar_int1 : INT;\nvar_int2 : INT;\npt := ADR(var_int1);\nvar_int2 := pt^; " }, 
{ "title" : "オペレーター：BITADR ", 
"url" : "_cds_operator_bitadr.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：BITADR ", 
"snippet" : "BITADR 演算子は、IEC61131-3規格の拡張です。 BITADR のセグメント内のビットオフセットを生成します DWORD 。 オフセットは、ターゲットシステム設定で[バイトアドレス指定]オプションが選択されているかクリアされているかによって異なります。 この中で最も高い値のニブル（4ビット） DWORD メモリ範囲を定義します。 マーカー M ： 16#40000000 入力 I ： 16#80000000 出力 Q ： 16#C0000000 アドレスへのポインタを使用する場合、オンライン変更を適用するとアドレスの内容がシフトする可能性があることに注意してください。 例 ST実装...", 
"body" : "BITADR searchresult_toplevel 演算子は、IEC61131-3規格の拡張です。 BITADR のセグメント内のビットオフセットを生成します DWORD 。 オフセットは、ターゲットシステム設定で[バイトアドレス指定]オプションが選択されているかクリアされているかによって異なります。 この中で最も高い値のニブル（4ビット） DWORD メモリ範囲を定義します。 マーカー M ： 16#40000000 入力 I ： 16#80000000 出力 Q ： 16#C0000000 アドレスへのポインタを使用する場合、オンライン変更を適用するとアドレスの内容がシフトする可能性があることに注意してください。 例 ST実装言語 VAR\n xVar AT %IX2.3 : BOOL;\n dwBitoffset : DWORD;\nEND_VAR\n\ndwBitoffset := BITADR(xVar); (* If byte addressing = TRUE, result = 16#80000013; if byte addressing = FALSE, result = 16#80000023 *) " }, 
{ "title" : "オペレーター：CAL ", 
"url" : "_cds_operator_cal.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：CAL ", 
"snippet" : "CAL IEC演算子は、機能ブロックの呼び出しに使用されます。 ILでは、 CAL 関数ブロックのインスタンスを呼び出します。 CAL <function block> (<input variable1> := <value>, <input variableN> := <value>) 例 の呼び出し Inst の割り当てを持つ機能ブロックのインスタンス Par1 と Par2 入力変数 0 また TRUE CAL Inst(Par1 := 0, Par2 := TRUE);...", 
"body" : "CAL IEC演算子は、機能ブロックの呼び出しに使用されます。 ILでは、 CAL 関数ブロックのインスタンスを呼び出します。 CAL <function block> (<input variable1> := <value>, <input variableN> := <value>) 例 の呼び出し Inst の割り当てを持つ機能ブロックのインスタンス Par1 と Par2 入力変数 0 また TRUE CAL Inst(Par1 := 0, Par2 := TRUE); " }, 
{ "title" : "オペレーター：ABS ", 
"url" : "_cds_operator_abs.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：ABS ", 
"snippet" : "ABS IEC演算子は、数値の絶対値を生成します。 入力変数と出力変数および数値定数に許可されるデータ型：任意の数値基本データ型 例 結果 i ： 2 ST i := ABS(-2); FBD...", 
"body" : "ABS IEC演算子は、数値の絶対値を生成します。 入力変数と出力変数および数値定数に許可されるデータ型：任意の数値基本データ型 例 結果 i ： 2 ST i := ABS(-2); FBD " }, 
{ "title" : "オペレーター：SQRT ", 
"url" : "_cds_operator_sqrt.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：SQRT ", 
"snippet" : "SQRT IEC 演算子は数値の平方根を求めます。 入力変数に許可されるデータ型：任意の数値の基本データ型 出力変数に許可されるデータ型： REAL と LREAL 例 結果 q ： 4 ST q := SQRT(16); FBD...", 
"body" : "SQRT IEC 演算子は数値の平方根を求めます。 入力変数に許可されるデータ型：任意の数値の基本データ型 出力変数に許可されるデータ型： REAL と LREAL 例 結果 q ： 4 ST q := SQRT(16); FBD " }, 
{ "title" : "オペレーター：LN ", 
"url" : "_cds_operator_ln.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：LN ", 
"snippet" : "LN IEC演算子は、数値の自然対数を生成します。 入力変数に許可されるデータ型：任意の数値の基本データ型 出力変数に許可されるデータ型： REAL と LREAL 例 結果 q ： 3.80666 ST q := LN(45); FBD...", 
"body" : "LN IEC演算子は、数値の自然対数を生成します。 入力変数に許可されるデータ型：任意の数値の基本データ型 出力変数に許可されるデータ型： REAL と LREAL 例 結果 q ： 3.80666 ST q := LN(45); FBD " }, 
{ "title" : "オペレーター：LOG ", 
"url" : "_cds_operator_log.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：LOG ", 
"snippet" : "LOG IEC演算子は、数値の10を底とする対数を生成します。 入力変数は任意の数値の基本データ型にすることができますが、出力変数はデータ型である必要があります REAL また LREAL 。 例 結果 q ： 2.49762 ST q := LOG(314.5); FBD...", 
"body" : "LOG searchresult_toplevel IEC演算子は、数値の10を底とする対数を生成します。 入力変数は任意の数値の基本データ型にすることができますが、出力変数はデータ型である必要があります REAL また LREAL 。 例 結果 q ： 2.49762 ST q := LOG(314.5); FBD " }, 
{ "title" : "オペレーター：EXP ", 
"url" : "_cds_operator_exp.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：EXP ", 
"snippet" : "EXP IEC演算子は、指数関数を生成します。 入力変数に許可されるデータ型：任意の数値の基本データ型 出力変数に許可されるデータ型： REAL と LREAL 例 結果 q ： 7.389056099 ST q := EXP(2); FBD...", 
"body" : "EXP IEC演算子は、指数関数を生成します。 入力変数に許可されるデータ型：任意の数値の基本データ型 出力変数に許可されるデータ型： REAL と LREAL 例 結果 q ： 7.389056099 ST q := EXP(2); FBD " }, 
{ "title" : "オペレーター：EXPT ", 
"url" : "_cds_operator_expt.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：EXPT ", 
"snippet" : "EXPT IECオペレーターは、数値をより高い累乗に上げ、基数の累乗を指数に戻します。power= base 指数 。入力値（パラメーター）は、底と指数です。底がゼロで指数が負の場合、べき関数は定義されていません。ただし、この場合の動作はプラットフォームによって異なります。 構文 EXPT(<base>,<exponent>) 入力値に許可されるデータ型：数値ベースのデータ型（ SINT 、 USINT 、 INT 、 UINT 、 DINT 、 UDINT 、 LINT 、 ULINT 、 REAL 、 LREAL 、 BYTE 、 WORD 、 DWORD 、 と LWORD ）。 戻り値...", 
"body" : "EXPT IECオペレーターは、数値をより高い累乗に上げ、基数の累乗を指数に戻します。power= base 指数 。入力値（パラメーター）は、底と指数です。底がゼロで指数が負の場合、べき関数は定義されていません。ただし、この場合の動作はプラットフォームによって異なります。 構文 EXPT(<base>,<exponent>) 入力値に許可されるデータ型：数値ベースのデータ型（ SINT 、 USINT 、 INT 、 UINT 、 DINT 、 UDINT 、 LINT 、 ULINT 、 REAL 、 LREAL 、 BYTE 、 WORD 、 DWORD 、 と LWORD ）。 戻り値に許可されるデータ型：浮動小数点数型（ REAL と LREAL ）。 例 リテラルを使用したべき関数 Var1 := EXPT(7,2); FBD 戻り値： Var1 = 49 例 変数を使用したべき関数 PROGRAM PLC_PRG\nVAR\n lrPow : LREAL;\n iBase : INT := 2;\n iExponent : INT := 7;\nEND_VAR\n\nlrPow := EXPT(iBase, iExponent); 戻り値： lrPow = 128 " }, 
{ "title" : "オペレーター：SIN ", 
"url" : "_cds_operator_sin.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：SIN ", 
"snippet" : "SIN IEC演算子は、数値の正弦値を生成します。 ラジアンで角度を測定する入力変数に許可されるデータ型：任意の数値の基本データ型 出力変数に許可されるデータ型： REAL と LREAL 入力値の許容範囲は-2です。 63 +2まで 63 。 x86およびx64システムの場合：入力値が許容範囲外の場合、関数は入力値を返します。 例 結果 q ： 0.479426 。 ST q := SIN (0.5); FBD...", 
"body" : "SIN IEC演算子は、数値の正弦値を生成します。 ラジアンで角度を測定する入力変数に許可されるデータ型：任意の数値の基本データ型 出力変数に許可されるデータ型： REAL と LREAL 入力値の許容範囲は-2です。 63 +2まで 63 。 x86およびx64システムの場合：入力値が許容範囲外の場合、関数は入力値を返します。 例 結果 q ： 0.479426 。 ST q := SIN (0.5); FBD " }, 
{ "title" : "オペレーター：COS ", 
"url" : "_cds_operator_cos.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：COS ", 
"snippet" : "COS IEC演算子は、数値の正弦値を生成します。 ラジアンで角度を測定する入力変数に許可されるデータ型：任意の数値の基本データ型 出力変数に許可されるデータ型： REAL と LREAL 入力値の許容範囲は-2です。 63 +2まで 63 。 x86およびx64システムの場合：入力値が許容範囲外の場合、関数は入力値を返します。 例 結果 q ： 0.877583 ST q := COS(0.5); FBD...", 
"body" : "COS IEC演算子は、数値の正弦値を生成します。 ラジアンで角度を測定する入力変数に許可されるデータ型：任意の数値の基本データ型 出力変数に許可されるデータ型： REAL と LREAL 入力値の許容範囲は-2です。 63 +2まで 63 。 x86およびx64システムの場合：入力値が許容範囲外の場合、関数は入力値を返します。 例 結果 q ： 0.877583 ST q := COS(0.5); FBD " }, 
{ "title" : "オペレーター：TAN ", 
"url" : "_cds_operator_tan.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：TAN ", 
"snippet" : "TAN IEC演算子は、数値のタンジェント値を生成します。 ラジアンで角度を測定する入力変数に許可されるデータ型：任意の数値の基本データ型 出力変数に許可されるデータ型： REAL と LREAL 例 結果 q ： 0.546302 ST q := TAN(0.5); FBD...", 
"body" : "TAN IEC演算子は、数値のタンジェント値を生成します。 ラジアンで角度を測定する入力変数に許可されるデータ型：任意の数値の基本データ型 出力変数に許可されるデータ型： REAL と LREAL 例 結果 q ： 0.546302 ST q := TAN(0.5); FBD " }, 
{ "title" : "オペレーター：ASIN ", 
"url" : "_cds_operator_asin.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：ASIN ", 
"snippet" : "ASIN IEC演算子は、数値のアークサイン値を生成します。 入力変数に許可されるデータ型：任意の数値の基本データ型 出力変数に許可されるデータ型： REAL と LREAL 例 結果 q ： 0.523599 ST q := ASIN(0,5); FBD...", 
"body" : "ASIN IEC演算子は、数値のアークサイン値を生成します。 入力変数に許可されるデータ型：任意の数値の基本データ型 出力変数に許可されるデータ型： REAL と LREAL 例 結果 q ： 0.523599 ST q := ASIN(0,5); FBD " }, 
{ "title" : "オペレーター：ACOS ", 
"url" : "_cds_operator_acos.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：ACOS ", 
"snippet" : "ACOS IEC演算子は、数値のアークコサイン値を生成します。値はラジアンで計算されます。 ラジアンで角度を測定する入力変数に許可されるデータ型：任意の数値の基本データ型 出力変数に許可されるデータ型： REAL と LREAL 例 qの結果：1.0472 ST q := ACOS(0.5); FBD...", 
"body" : "ACOS IEC演算子は、数値のアークコサイン値を生成します。値はラジアンで計算されます。 ラジアンで角度を測定する入力変数に許可されるデータ型：任意の数値の基本データ型 出力変数に許可されるデータ型： REAL と LREAL 例 qの結果：1.0472 ST q := ACOS(0.5); FBD " }, 
{ "title" : "オペレーター：ATAN ", 
"url" : "_cds_operator_atan.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ オペレーター：ATAN ", 
"snippet" : "ATAN IEC演算子は、数値のアークタンジェント値を生成します。値はラジアンで計算されます。 ラジアンで角度を測定する入力変数に許可されるデータ型：任意の数値の基本データ型 出力変数に許可されるデータ型： REAL と LREAL 例 結果 q ： 0.463648 ST q := ATAN(0.5); FBD...", 
"body" : "ATAN IEC演算子は、数値のアークタンジェント値を生成します。値はラジアンで計算されます。 ラジアンで角度を測定する入力変数に許可されるデータ型：任意の数値の基本データ型 出力変数に許可されるデータ型： REAL と LREAL 例 結果 q ： 0.463648 ST q := ATAN(0.5); FBD " }, 
{ "title" : "演算子：__ DELETE ", 
"url" : "_cds_operator_delete.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：__ DELETE ", 
"snippet" : "__DELETE 演算子は、IEC61131-3規格の拡張です。 互換性のために、コンパイラのバージョンは3.3.2.0以上である必要があります。 オペレーターは、「__ NEW」オペレーターが動的に生成したインスタンスのメモリーを解放します。 The __DELETE 演算子には戻り値がなく、この演算の後、オペランドはゼロに設定されます。 要件： 動的メモリ割り当てを使用する オプションが選択されている アプリケーションビルドオプション アプリケーションのプロパティダイアログのタブ。 __DELETE (<pointer>) 2つのタスクが同時に__DELETEを呼び出さないようにする必要が...", 
"body" : "__DELETE 演算子は、IEC61131-3規格の拡張です。 互換性のために、コンパイラのバージョンは3.3.2.0以上である必要があります。 オペレーターは、「__ NEW」オペレーターが動的に生成したインスタンスのメモリーを解放します。 The __DELETE 演算子には戻り値がなく、この演算の後、オペランドはゼロに設定されます。 要件： 動的メモリ割り当てを使用する オプションが選択されている アプリケーションビルドオプション アプリケーションのプロパティダイアログのタブ。 __DELETE (<pointer>) 2つのタスクが同時に__DELETEを呼び出さないようにする必要があります。セマフォ（SysSemEnter）または同等のメソッドを使用して、__ DELETEの同時呼び出しを防止するか、1つのタスクでのみ__DELETEを使用します（推奨）。 セマフォ（SysSemEnter）を使用して、2つのタスクが同時にメモリを割り当てるのを防ぐことができます。結果として、 __DELETE より高いジッターを引き起こします。 もしも Pointer 関数ブロックを参照し、次に CODESYS 関連する呼び出し FB_EXIT ポインタがゼロに設定される前のメソッド。 例 機能ブロック FUNCTION_BLOCK FBDynamic\n\nVAR_INPUT\n in1, in2 : INT;\nEND_VAR\n\nVAR_OUTPUT\n out : INT;\nEND_VAR\n\nVAR\n test1 : INT := 1234;\n _inc : INT := 0;\n _dut : POINTER TO DUT;\n neu : BOOL;\nEND_VAR\n\nout := in1 + in2;\n 方法 （ FB_Exit ） METHOD FB_Exit : BOOL\n\nVAR_INPUT\n bInCopyCode : BOOL;\nEND_VAR\n\n__Delete(_dut);\n 方法 （ FB_Init ） METHOD FB_Init : BOOL\n\nVAR_INPUT\n bInitRetains : BOOL;\n bInCopyCode : BOOL;\nEND_VAR\n\n_dut := __NEW(DUT);\n 方法 METHOD INC : INT\n\nVAR_INPUT\nEND_VAR\n\n_inc := _inc + 1;\nINC := _inc;\n プログラム PLC_PRG(PRG)\n\nVAR\n pFB : POINTER TO FBDynamic;\n bInit: BOOL := TRUE;\n bDelete: BOOL;\n loc : INT;\nEND_VAR\n\nIF (bInit) THEN\n pFB := __NEW(FBDynamic);\n bInit := FALSE;\nEND_IF\n\nIF (pFB <> 0) THEN\n pFB^(in1 := 1, in2 := loc, out => loc);\n pFB^.INC();\nEND_IF\n\nIF (bDelete) THEN\n __DELETE(pFB);\nEND_IF " }, 
{ "title" : "演算子：__ ISVALIDREF ", 
"url" : "_cds_operator_isvalidref.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：__ ISVALIDREF ", 
"snippet" : "__ISVALIDREF 演算子は、IEC61131-3規格の拡張です。 演算子は、参照が有効な値を参照しているかどうかを確認するために使用されます。使用法の説明と例については、の説明を参照してください。 REFERENCE データ・タイプ。...", 
"body" : "__ISVALIDREF 演算子は、IEC61131-3規格の拡張です。 演算子は、参照が有効な値を参照しているかどうかを確認するために使用されます。使用法の説明と例については、の説明を参照してください。 REFERENCE データ・タイプ。 " }, 
{ "title" : "演算子：__ NEW ", 
"url" : "_cds_operator_new.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：__ NEW ", 
"snippet" : "__NEW 演算子は、IEC61131-3規格の拡張です。 The __NEW 演算子は、機能ブロック、ユーザー定義のデータ型、または標準型の配列をインスタンス化するために動的メモリを予約します。演算子は、一致する型付きポインターを返します。 要件：親アプリケーションのプロパティダイアログで、 アプリケーションビルドオプション タブ、 動的メモリ割り当てを使用する オプションが選択されています。 構文 <pointer name> := __NEW( <type> ( , <size> )? ); __DELETE( <pointer name> ); <type> : <function b...", 
"body" : "__NEW 演算子は、IEC61131-3規格の拡張です。 The __NEW 演算子は、機能ブロック、ユーザー定義のデータ型、または標準型の配列をインスタンス化するために動的メモリを予約します。演算子は、一致する型付きポインターを返します。 要件：親アプリケーションのプロパティダイアログで、 アプリケーションビルドオプション タブ、 動的メモリ割り当てを使用する オプションが選択されています。 構文 <pointer name> := __NEW( <type> ( , <size> )? );\n__DELETE( <pointer name> );\n\n<type> : <function block> | <data unit type> | <standard data type> オペレーターは、タイプのインスタンスを生成します <type> そして、このインスタンスへのポインタを返します。次に、インスタンスの初期化が呼び出されます。もしも <type> はスカラー標準データ型であり、オプションのオペランド <size> も評価されます。次に、演算子はタイプの配列を生成します <standard data type> とサイズ <size> 。メモリの割り当てに失敗した場合は、 __NEW 値を返します 0 。 割り当て内で演算子を使用する \" := \";それ以外の場合は、エラーメッセージが表示されます。 インスタンスがで動的に作成される関数ブロックまたはユーザー定義データ型 __NEW 固定メモリ領域を使用します。ここでは、オブジェクトをプラグマでマークする必要があります {attribute 'enable_dynamic_creation'} 。ライブラリの一部である機能ブロックには必要ありません。 オンラインモードで機能ブロックのデータレイアウトを変更すると、後でオンライン変更を使用してログインを実行することはできません。これは、ファンクションブロックインスタンスのメモリ領域が無効になっているためです。関数ブロックに新しい変数を追加したり、既存の変数を削除したり、変数のデータ型を変更したりするときに、データレイアウトを変更します。 例 配列 （ DWORD ）。 PROGRAM PLC_PRG\nVAR\n pdwScalar : POINTER TO DWORD; \/\/Typed pointer\n xInit : BOOL := TRUE;\n xDelete : BOOL;\nEND_VAR\n\nIF (xInit) THEN\n pdwScalar := __NEW(DWORD, 16); \/\/ Allocates memory (16 dwords) and assigns them to pointer pdwScalar\nEND_IF\nIF (xDelete) THEN\n __DELETE(pdwScalar); \/\/ Frees memory of pointer\nEND_IF ファンクションブロック {attribute 'enable_dynamic_creation'}\nFUNCTION_BLOCK FBComputeGamma\nVAR_INPUT\n iAlpha : INT;\n iBeta : INT;\nEND_VAR\nVAR_OUTPUT\n iGamma : INT;\nEND_VAR\nVAR\nEND_VAR\n\niGamma := iAlpha + iBeta;\n\nPROGRAM PLC_PRG\nVAR\n pComputeGamma : POINTER TO FBComputeGamma; \/\/ Typed pointer\n xInit : BOOL := TRUE;\n xDelete : BOOL;\n iResult : INT;\nEND_VAR\n\nIF (xInit) THEN\n pComputeGamma := __NEW(FBComputeGamma); \/\/ Allocates memory\n xInit := FALSE;\nEND_IF\npComputeGamma^.iAlpha := (pComputeGamma^.iAlpha + 1)MOD 100; \/\/ Sets first input of pComputeGamma\npComputeGamma^.iBeta := 10; \/\/ Sets second input of pComputeGamma\npComputeGamma^(); \/\/ Calls the FB pComputeGamma is pointing to\niResult := pComputeGamma^.iGamma; \/\/ Reads output of pComputeGamma\nIF (xDelete) THEN\n __DELETE(pComputeGamma); \/\/ Frees memory\nEND_IF ユーザー定義データ型（DUT） {attribute 'enable_dynamic_creation'}\nTYPE ABCDATA :\nSTRUCT\n iA, iB, iC, iD : INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n pABCData : POINTER TO ABCDATA; \/\/ Typed pointer\n xInit : BOOL := TRUE;\n xDelete : BOOL;\nEND_VAR\n\nIF (xInit) THEN\n pABCData := __NEW(ABCDATA); \/\/ Allocates memory\n xInit := FALSE;\nEND_IF\nIF (xDelete) THEN\n __DELETE(pABCData); \/\/ Frees memory\nEND_IF アレイ（BYTE） PROGRAM PLC_PRG\nVAR\n pbDataAlpha : POINTER TO BYTE;\n pbDataBeta : POINTER TO BYTE;\n xInit : BOOL := TRUE;\n xDelete : BOOL;\n usiCnt : USINT;\n bTestC: BYTE;\nEND_VAR\n\nIF (xInit) THEN\n pbDataAlpha := __NEW(BYTE, 16); \/\/ Allocates 16 bytes for pbDataAlpha\n pbDataBeta := __NEW(BYTE); \/\/ Allocates memory for pbDataBeta\n xInit := FALSE;\n\n FOR usiCnt := 0 TO 15 DO\n pbDataAlpha[usiCnt] := usiCnt; \/\/ Writes to new array\n END_FOR\n pbDataBeta^:= 16#FF; \/\/ Writes to new data\nEND_IF\n\nbTestC := pbDataAlpha[12]; \/\/ Reads new array by index access\n\nIF (xDelete) THEN \/\/ Frees memory\n __DELETE(pbDataAlpha);\n __DELETE(pbDataBeta);\nEND_IF 両方を呼び出す2つのタスクを同時に実行することはお勧めしません __NEW オペレーター。セマフォ（ SysSemEnter ）またはの同時呼び出しを防ぐための同等の手法 __NEW 。ただし、これにより、次の場合にジッターが高くなります。 __NEW 広く適用されます。 電話することをお勧めします __NEW 1つのタスクの演算子のみ。 " }, 
{ "title" : "演算子：__ QUERYINTERFACE ", 
"url" : "_cds_operator_queryinterface.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：__ QUERYINTERFACE ", 
"snippet" : "__QUERYINTERFACE 演算子は、IEC61131-3規格の拡張です。 実行時に、オペレーターはインターフェース参照の別の型への型変換を実行します。演算子は BOOL 結果。 TRUE という意味です CODESYS 変換が正常に実行されました。 __QUERYINTERFACE(<ITF_Source>,<ITF_Dest>); 第1オペランド：インターフェース参照またはFBインターフェース 2番目のオペランド：必要なターゲットタイプのインターフェイス参照 明示的な変換の要件は、ITF_SourceとITF_Destの両方がから派生していることです。 Interface __Sys...", 
"body" : "__QUERYINTERFACE 演算子は、IEC61131-3規格の拡張です。 実行時に、オペレーターはインターフェース参照の別の型への型変換を実行します。演算子は BOOL 結果。 TRUE という意味です CODESYS 変換が正常に実行されました。 __QUERYINTERFACE(<ITF_Source>,<ITF_Dest>); 第1オペランド：インターフェース参照またはFBインターフェース 2番目のオペランド：必要なターゲットタイプのインターフェイス参照 明示的な変換の要件は、ITF_SourceとITF_Destの両方がから派生していることです。 Interface __System.IQueryInterface 。このインターフェースは暗黙的に利用可能であり、ライブラリーは必要ありません。 例 INTERFACE ItfBase EXTENDS __System.IQueryInterface\nMETHOD mbase : BOOL\nEND_METHOD\n\nINTERFACE ItfDerived1 EXTENDS ItfBase\nMETHOD mderived1 : BOOL\nEND_METHOD\n\nINTERFACE ItfDerived2 EXTENDS ItfBase\nMETHOD mderived2 : BOOL\nEND_METHOD\n\nFUNCTION_BLOCK FB1 IMPLEMENTS ItfDerived1\nMETHOD mbase : BOOL\n mbase := TRUE;\nEND_METHOD\nMETHOD mderived1 : BOOL\n mderived1 := TRUE;\nEND_METHOD\nEND_FUNCTION_BLOCK\n\nFUNCTION_BLOCK FB2 IMPLEMENTS ItfDerived2\nMETHOD mbase : BOOL\n mbase := FALSE;\nEND_METHOD\nMETHOD mderived2 : BOOL\n mderived2 := TRUE;\nEND_METHOD\nEND_FUNCTION_BLOCK\n\nPROGRAMM POU\nVAR\n inst1 : FB1;\n inst2 : FB2;\n itfbase1 : ItfBase := inst1;\n itfbase2 : ItfBase := inst2;\n itfderived1 : ItfDerived1 := 0;\n itfderived2 : ItfDerived2 := 0;\n xResult1, xResult2, xResult3, xResult4: BOOL;\nEND_VAR\n\n\nxResult1 := __QUERYINTERFACE(itfbase1, itfderived1); \/\/ xResult = TRUE, itfderivedi1 <>0\n \/\/ references the instance inst1\nxResult2 := __QUERYINTERFACE(itfbase1, itfderived2); \/\/ xResult = FALSE, itfderived2 = 0\nxResult3 := __QUERYINTERFACE(itfbase2, itfderived1); \/\/ xResult = FALSE, itfderived1 = 0\nxResult4 := __QUERYINTERFACE(itfbase2, itfderived2); \/\/ xResult = TRUE, itfderived2 <> 0\n \/\/ references the instance inst2 " }, 
{ "title" : "演算子：__QUERYPOINTER ", 
"url" : "_cds_operator_querypointer.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：__QUERYPOINTER ", 
"snippet" : "__QUERYPOINTER 演算子は、IEC61131-3規格の拡張です。 実行時に、オペレーターは関数ブロックのインターフェース参照のタイプをポインターに変換することを可能にします。演算子は BOOL 結果。 TRUE という意味です CODESYS 変換が正常に実行されました。 互換性のために、変換されるポインタの定義は、ベースインターフェイス「__SYSTEM.IQueryInterface」の拡張である必要があります。 __QUERYPOINTER ( <ITF_Source>, <Pointer_Dest> ) オペレータは、必要なターゲットタイプを第1オペランドとして、ポインタを...", 
"body" : "__QUERYPOINTER 演算子は、IEC61131-3規格の拡張です。 実行時に、オペレーターは関数ブロックのインターフェース参照のタイプをポインターに変換することを可能にします。演算子は BOOL 結果。 TRUE という意味です CODESYS 変換が正常に実行されました。 互換性のために、変換されるポインタの定義は、ベースインターフェイス「__SYSTEM.IQueryInterface」の拡張である必要があります。 __QUERYPOINTER ( <ITF_Source>, <Pointer_Dest> ) オペレータは、必要なターゲットタイプを第1オペランドとして、ポインタを第2オペランドとして持つインターフェイス参照またはFBインスタンスを受け取ります。処理後 __QUERYPOINTER 、Pointer_Destは、ITF_Sourceインターフェイス参照が現在参照している関数ブロックの参照またはインスタンスへのポインタを受け取ります。 Pointer_Destは型指定されておらず、任意の型にキャストできます。タイプを確認する必要があります。たとえば、インターフェイスはタイプコードを返すメソッドを提供できます。 " }, 
{ "title" : "演算子：__TRY、__CATCH、__FINALLY、__ENDTRY ", 
"url" : "_cds_operator_try_catch_finally_endtry.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：__TRY、__CATCH、__FINALLY、__ENDTRY ", 
"snippet" : "__TRY, __CATCH, __FINALLY, __ENDTRY これらの演算子は、IEC 61131-3標準から拡張されており、IECコードでの特定の例外処理に使用されます。 構文 __TRY <statements_try> __CATCH(exec) <statements_catch> __FINALLY <statements_finally> __ENDTRY <statements_next> のステートメントが __Try オペレーターが例外をスローしても、アプリケーションは停止しません。代わりに、以下のステートメントを実行します __Catch したがって、例外処理を開...", 
"body" : "__TRY, __CATCH, __FINALLY, __ENDTRY これらの演算子は、IEC 61131-3標準から拡張されており、IECコードでの特定の例外処理に使用されます。 構文 __TRY\n <statements_try>\n__CATCH(exec)\n <statements_catch>\n__FINALLY\n <statements_finally>\n__ENDTRY\n <statements_next> のステートメントが __Try オペレーターが例外をスローしても、アプリケーションは停止しません。代わりに、以下のステートメントを実行します __Catch したがって、例外処理を開始します。次に、以下の手順を実行します __FINALLY 。例外処理はで終了します __ENDTRY 。次に、アプリケーションは次のステートメントを実行します。 例外のIEC変数のデータ型は __System.ExceptionCode 。 例 のステートメントの場合 __TRY 例外をスローすると、プログラムの実行は停止しません。代わりに、 __CATCH 実行されます。したがって、この例では exc 関数が実行されてから、以下のステートメントが実行されます __FINALLY 。次に、以下の手順を実行します __FINALLY 。 FUNCTION Tester : UDINT\nVAR_INPUT\n count : UDINT;\nEND_VAR\nVAR_OUTPUT\n strExceptionText : STRING;\nEND_VAR\nVAR\n exc : __SYSTEM.ExceptionCode;\nEND_VAR\n\n__TRY\nTester := tryFun(count := count, testcase := g_testcase); \/\/This instruction is tested. If it produces an exception, the statement under __CATCH is executed first and then the statement under __FINALLY.\n__CATCH(exc)\nHandleException(exc, strExceptionText => strExceptionText);\n__FINALLY\nGVL.g_count := GVL.g_count + 2;\n__ENDTRY 詳細については、以下を参照してください。 処理された例外で実行を停止しますデータ型 '__System.ExceptionCode' TYPE ExceptionCode :\n(\n\nRTSEXCPT_UNKNOWN := 16#FFFFFFFF,\nRTSEXCPT_NOEXCEPTION := 16#00000000,\nRTSEXCPT_WATCHDOG := 16#00000010,\nRTSEXCPT_HARDWAREWATCHDOG := 16#00000011,\nRTSEXCPT_IO_CONFIG_ERROR := 16#00000012,\nRTSEXCPT_PROGRAMCHECKSUM := 16#00000013,\nRTSEXCPT_FIELDBUS_ERROR := 16#00000014,\nRTSEXCPT_IOUPDATE_ERROR := 16#00000015,\nRTSEXCPT_CYCLE_TIME_EXCEED := 16#00000016,\nRTSEXCPT_ONLCHANGE_PROGRAM_EXCEEDED := 16#00000017,\nRTSEXCPT_UNRESOLVED_EXTREFS := 16#00000018,\nRTSEXCPT_DOWNLOAD_REJECTED := 16#00000019,\nRTSEXCPT_BOOTPROJECT_REJECTED_DUE_RETAIN_ERROR := 16#0000001A,\nRTSEXCPT_LOADBOOTPROJECT_FAILED := 16#0000001B,\nRTSEXCPT_OUT_OF_MEMORY := 16#0000001C,\nRTSEXCPT_RETAIN_MEMORY_ERROR := 16#0000001D,\nRTSEXCPT_BOOTPROJECT_CRASH := 16#0000001E,\nRTSEXCPT_BOOTPROJECTTARGETMISMATCH := 16#00000021,\nRTSEXCPT_SCHEDULEERROR := 16#00000022,\nRTSEXCPT_FILE_CHECKSUM_ERR := 16#00000023,\nRTSEXCPT_RETAIN_IDENTITY_MISMATCH := 16#00000024,\nRTSEXCPT_IEC_TASK_CONFIG_ERROR := 16#00000025,\nRTSEXCPT_APP_TARGET_MISMATCH := 16#00000026,\nRTSEXCPT_ILLEGAL_INSTRUCTION := 16#00000050,\nRTSEXCPT_ACCESS_VIOLATION := 16#00000051,\nRTSEXCPT_PRIV_INSTRUCTION := 16#00000052,\nRTSEXCPT_IN_PAGE_ERROR := 16#00000053,\nRTSEXCPT_STACK_OVERFLOW := 16#00000054,\nRTSEXCPT_INVALID_DISPOSITION := 16#00000055,\nRTSEXCPT_INVALID_HANDLE := 16#00000056,\nRTSEXCPT_GUARD_PAGE := 16#00000057,\nRTSEXCPT_DOUBLE_FAULT := 16#00000058,\nRTSEXCPT_INVALID_OPCODE := 16#00000059,\nRTSEXCPT_MISALIGNMENT := 16#00000100,\nRTSEXCPT_ARRAYBOUNDS := 16#00000101,\nRTSEXCPT_DIVIDEBYZERO := 16#00000102,\nRTSEXCPT_OVERFLOW := 16#00000103,\nRTSEXCPT_NONCONTINUABLE := 16#00000104,\nRTSEXCPT_PROCESSORLOAD_WATCHDOG := 16#00000105,\nRTSEXCPT_FPU_ERROR := 16#00000150,\nRTSEXCPT_FPU_DENORMAL_OPERAND := 16#00000151,\nRTSEXCPT_FPU_DIVIDEBYZERO := 16#00000152,\nRTSEXCPT_FPU_INEXACT_RESULT := 16#00000153,\nRTSEXCPT_FPU_INVALID_OPERATION := 16#00000154,\nRTSEXCPT_FPU_OVERFLOW := 16#00000155,\nRTSEXCPT_FPU_STACK_CHECK := 16#00000156,\nRTSEXCPT_FPU_UNDERFLOW := 16#00000157,\nRTSEXCPT_VENDOR_EXCEPTION_BASE := 16#00002000,\nRTSEXCPT_USER_EXCEPTION_BASE := 16#00010000\n) UDINT ;\nEND_TYPE " }, 
{ "title" : "演算子：__ VARINFO ", 
"url" : "_cds_operator_varinfo.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：__ VARINFO ", 
"snippet" : "__VARINFO 演算子は、IEC61131-3規格の拡張です。 演算子は、変数に関する情報を生成します。データ型の変数にデータ構造として情報を保存できます __SYSTEM.VAR_INFO 。 宣言の構文 <name of the info variable> : __SYSTEM.VAR_INFO; \/\/ Data structure for info variable 呼び出しの構文 <name of the info variable> := __VARINFO( <variable name> ); \/\/ Call of the operator 例 FUNCTION_BLOCK...", 
"body" : "__VARINFO 演算子は、IEC61131-3規格の拡張です。 演算子は、変数に関する情報を生成します。データ型の変数にデータ構造として情報を保存できます __SYSTEM.VAR_INFO 。 宣言の構文 <name of the info variable> : __SYSTEM.VAR_INFO; \/\/ Data structure for info variable 呼び出しの構文 <name of the info variable> := __VARINFO( <variable name> ); \/\/ Call of the operator 例 FUNCTION_BLOCK FB_Velocity\nVAR_INPUT\n rVelocity: REAL := 1.2;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n infoVelocity: __SYSTEM.VAR_INFO; \/\/Info of Velocity\nEND_VAR\n\ninfoVelocity := __VARINFO(rVelocity); \/\/ Gets the info of Velocity locally PROGRAM PLC_PRG\nVAR\n iCounter : INT := 0; \/\/ Counts the calls\n infoCounter : __SYSTEM.VAR_INFO; \/\/Info of Counter\n arrA : ARRAY [1..2, 1..2, 1..2] OF INT := [0, 1, 2, 3, 4, 5, 6, 7]; \/\/ Stores the A data\n infoA : __SYSTEM.VAR_INFO; \/\/Info of A\n fbVel : FB_Velocity;\nEND_VAR\n\niCounter := iCounter + 1;\ninfoCounter := __VARINFO(iCounter);\ninfoA := __VARINFO(arrA);\nfbVel(); The iCounter と arrA 変数はアプリケーションコードで認識されます。変数情報はに保存されます infoCounter と infoA 変数。また、 FB_Velocity 機能ブロックがインスタンス化されます。 " }, 
{ "title" : "データ型：__ SYSTEM.VAR_INFO ", 
"url" : "_cds_operator_varinfo.html#UUID-a5c59974-aff9-8df3-9a5d-66a904a67842_id_bfe36bd11d79fbf5c0a86463350fcaac_id_f26a4b1dd3c4781cc0a86463447d5db7", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：__ VARINFO \/ データ型：__ SYSTEM.VAR_INFO ", 
"snippet" : "名前 データ・タイプ 初期化 説明 ByteAddress DWORD 0 変数のアドレス 例： 16#072E35EC 注：変数のビットアクセスの場合 <variable name>.<bit index> 、ビットを含む変数のアドレスが指定されます。 ByteOffset DWORD 0 可変アドレスのオフセット（バイト単位） 例： 13936 バイト 注：変数がグローバルの場合、オフセットは領域の先頭を基準にしています。変数が関数またはメソッドのローカル変数である場合、オフセットは現在のスタックフレームを基準にしています。変数が機能ブロック内のローカル変数である場合、オフセットは機能ブロ...", 
"body" : "名前 データ・タイプ 初期化 説明 ByteAddress DWORD 0 変数のアドレス 例： 16#072E35EC 注：変数のビットアクセスの場合 <variable name>.<bit index> 、ビットを含む変数のアドレスが指定されます。 ByteOffset DWORD 0 可変アドレスのオフセット（バイト単位） 例： 13936 バイト 注：変数がグローバルの場合、オフセットは領域の先頭を基準にしています。変数が関数またはメソッドのローカル変数である場合、オフセットは現在のスタックフレームを基準にしています。変数が機能ブロック内のローカル変数である場合、オフセットは機能ブロックインスタンスに相対的です。 Area DINT 0 メモリエリア番号 Area ランタイムシステムで 例： -1 変数がメモリ内でグローバルではなく、インスタンスまたはスタック上で相対的であることを意味します 注：メモリ領域はデバイスに依存します。 BitNr INT 0 ビット数（バイト単位） 例： 16#00FF バイト 注：変数が いいえ 整数データ型の場合： BitNr = -1 = 16#FFFF BitSize INT 0 変数のメモリサイズ（ビット単位） 例： 16 ビット BitAddress UDINT 0 変数のビットアドレス 要件：変数は入力メモリ領域にあります I 、出力メモリ領域 Q 、またはマーカーメモリ領域 M 。それ以外の場合、値は未定義です。 TypeClass TYPE_CLASS TYPE_BOOL 変数のデータ型クラス 例： TYPE_INT 、 TYPE_ARRAY 注：ユーザー定義のデータ型または機能ブロックインスタンスの場合、 TYPE_USERDEF データ型クラスとして出力されます。 TypeName STRING(79) 、」 変数の日付型名 STRING(79) 注：ユーザー定義のデータ型の場合、機能ブロック名またはDUT名が出力されます。 例： 'INT' 、 'ARRAY' NumElements UDINT 0 配列要素の数 要件：変数のデータ型は ARRAY 。 例： 8 BaseTypeClass TYPE_CLASS TYPE_BOOL 配列要素の基本的な基本データ型 要件：変数のデータ型は ARRAY 。 例： TYPE_INT にとって arrA : ARRAY [1..2,1..2,1..2] OF INT; ElemBitSize UDINT 0 配列要素のメモリサイズ（ビット単位） 要件：変数のデータ型は ARRAY 。 例： 16 のビット arrA : ARRAY [1..2,1..2,1..2] OF INT; MemoryArea MEMORY_AREA MEM_MEMORY メモリ領域に関する情報 MEM_GLOBAL ：グローバルメモリ領域 例：で Area 0 MEM_LOCAL ：ローカルメモリ領域 の Area -1 MEM_MEMORY ：マーカーメモリ領域 %M 例：で 16#10 の Area 1 MEM_INPUT ：入力メモリ領域 %I 例：で 16#04 の Area 2 MEM_OUTPUT ：出力メモリ領域 %Q 例：で 16#08 の Area 3 MEM_RETAIN ：メモリ領域を保持 例：で 16#20 の Area 0 例： MEM_GLOBAL 注：メモリ領域の構成はデバイスによって異なります。 Symbol STRING(39) 、」 変数名として STRING(39) 例： 'iCounter' 、 'arrA' Comment STRING(79) 、」 変数宣言のコメント 例： 'Counts the calls' また 'Stores the A data' " }, 
{ "title" : "演算子：__CURRENTTASK ", 
"url" : "_cds_operator_currenttask.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：__CURRENTTASK ", 
"snippet" : "__CURRENTTASK 演算子は、IEC61131-3規格の拡張です。 実行時に、オペレーターは現在実行中のIECタスクに関する情報を提供します。 オペレーターは、ターゲットシステム設定が適用されるターゲットシステムでのみサポートされます memory-layout\\max-stack-size 0より大きい値に設定されます。 演算子は、2つの変数を持つ構造へのアクセスを許可します。 TaskIndex ：タスクを識別するゼロベースのインデックス pTaskInfo ：現在実行中のタスクに関する詳細情報 に割り当てることができます POINTER TO Task_Info2 図書館から C...", 
"body" : "__CURRENTTASK 演算子は、IEC61131-3規格の拡張です。 実行時に、オペレーターは現在実行中のIECタスクに関する情報を提供します。 オペレーターは、ターゲットシステム設定が適用されるターゲットシステムでのみサポートされます memory-layout\\max-stack-size 0より大きい値に設定されます。 演算子は、2つの変数を持つ構造へのアクセスを許可します。 TaskIndex ：タスクを識別するゼロベースのインデックス pTaskInfo ：現在実行中のタスクに関する詳細情報 に割り当てることができます POINTER TO Task_Info2 図書館から CmpIecTask 演算子は、POUの宣言には使用できません。エラーメッセージが表示されます。現在のタスクを特定できない場合は、 TaskIndex -1 そしてその pTaskInfo ゼロです。 例 \/\/Declaration\nVAR\n idx : INT;\n pInfo : POINTER TO Task_Info2;\nEND_VAR\n\n\/\/Program code\n\nidx := __CURRENTTASK.TaskIndex;\npInfo := __CURRENTTASK.pTaskInfo; " }, 
{ "title" : "演算子：__COMPARE_AND_SWAP ", 
"url" : "_cds_operator_compare_and_swap.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：__COMPARE_AND_SWAP ", 
"snippet" : "__COMPARE_AND_SWAP マルチコア演算子は、IEC61131-3規格の拡張です。 演算子は、セマフォを実装するために使用できます。たとえば、さまざまなタスクによって書き込まれた変数への排他的アクセスを保証するために使用できます。 __COMPARE_AND_SWAP データ型へのポインタを取得します __XWORD 変数、古い値、および入力としての新しい値（例： bMutex := __COMPARE_AND_SWAP(ADR(dwSynch), dwOld, dwNew); ）。古い値と新しい値はデータ型にすることもできます __XWORD 変数。参照 __XWORD 変数は古...", 
"body" : "__COMPARE_AND_SWAP マルチコア演算子は、IEC61131-3規格の拡張です。 演算子は、セマフォを実装するために使用できます。たとえば、さまざまなタスクによって書き込まれた変数への排他的アクセスを保証するために使用できます。 __COMPARE_AND_SWAP データ型へのポインタを取得します __XWORD 変数、古い値、および入力としての新しい値（例： bMutex := __COMPARE_AND_SWAP(ADR(dwSynch), dwOld, dwNew); ）。古い値と新しい値はデータ型にすることもできます __XWORD 変数。参照 __XWORD 変数は古い値と比較され、両方が等しい場合は、新しい値が書き込まれます。関数の結果は次のとおりです。 TRUE 新しい値を書き込めたとき。 コンパイラはデータ型を自動的に置き換えます __XWORD と DWORD 32ビットシステムおよび LWORD 64ビットシステム。 この操作はアトミックであるため、マルチコアプラットフォームであっても、別のタスクによって中断されることはありません。 例 次の例は、一般的な使用法を示しています。タイプへの排他的アクセス STRING 変数。 pstrOutput ポインタ、実装する必要があります。 文字列へのアクセスはアトミックではありません。複数のタスクが同時に同じ文字列に書き込む場合、内容に一貫性がない可能性があります。 この関数を使用すると、異なるタスクで同じSTRING変数を書き込むことができるようになりました。 FUNCTION ExclusiveStringWrite : BOOL\nVAR_INPUT\n strToWrite : STRING;\n pstrOutput : POINTER TO STRING;\nEND_VAR\nVAR_STAT\n dwSynch : __XWORD;\nEND_VAR\nVAR\n bMutex: BOOL;\nEND_VAR\n\nbMutex:= __COMPARE_AND_SWAP(ADR(dwSynch), 0, 1);\n(* compare with 0 and write 1 as atomic operation *)\nIF bMutex THEN \/\/ bMutex is TRUE if write could be done\n pstrOutput^ := strToWrite; \/\/ Now you can write safely on the string\n dwSynch := 0; \/\/ The __XWORD variable must be reset.\n ExclusiveStringWrite := TRUE; \/\/ Writing was successful\nELSE\n ExclusiveStringWrite := FALSE; \/\/ Writing was not successful\nEND_IF " }, 
{ "title" : "演算子：__XADD ", 
"url" : "_cds_operator_xadd.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：__XADD ", 
"snippet" : "__XADD マルチコア演算子は、IEC61131-3規格の拡張です。 演算子は、アトミックカウンターを実装するために使用できます。整数変数が通常の加算によってインクリメントされる場合、たとえば iTest := iTest + 1; 、この場合、この操作はアトミックに実行されません。変数への別のアクセスは、変数の読み取りと書き込みの間に行われる可能性があります。 カウンターが複数のタスクでインクリメントされる場合、カウンターの結果はカウントサイクルの数より少なくなる可能性があります。したがって、2つのタスクが上記のコードを一度に実行し、変数が以前に値を持っていた場合 0 、その場合、変数は値...", 
"body" : "__XADD マルチコア演算子は、IEC61131-3規格の拡張です。 演算子は、アトミックカウンターを実装するために使用できます。整数変数が通常の加算によってインクリメントされる場合、たとえば iTest := iTest + 1; 、この場合、この操作はアトミックに実行されません。変数への別のアクセスは、変数の読み取りと書き込みの間に行われる可能性があります。 カウンターが複数のタスクでインクリメントされる場合、カウンターの結果はカウントサイクルの数より少なくなる可能性があります。したがって、2つのタスクが上記のコードを一度に実行し、変数が以前に値を持っていた場合 0 、その場合、変数は値を持つことができます 1 。これは、配列が複数のタスクで処理されており、各処理サイクルで配列に一意のインデックスが必要な場合に特に問題になります。 いつ __XADD 演算子が呼び出され、型へのポインタを取得します DINT 最初の被加数および型としての変数 DINT 2番目の被加数としての値。 __XADD 最初の被加数の古い値を返し、同じステップで2番目の被加数を最初の被加数に追加します。 たとえば、関数呼び出しは次のようになります。 diOld := __XADD(ADR(diVar), deAdd); 例 次の例は、一般的な使用法を示しています。配列は2つのタスクから移入する必要があります。このプロセスでは、配列内のすべての位置を使用する必要があり、位置を上書きしないでください。 この関数を使用すると、複数のタスクでブール配列を設定できます。 FUNCTION WriteToNextArrayPosition : BOOL\nVAR_EXTERNAL\n g_diIndex : DINT; \/\/ Index and array are globally defined and used by multiple tasks\n g_boolArray : ARRAY [0..1000] OF BOOL;\nEND_VAR\nVAR_INPUT\n bToWrite : BOOL;\nEND_VAR\nVAR\n diIndex : DWORD;\nEND_VAR\n\ndiIndex := __XADD(ADR(g_diIndex), 1); \/\/ Returns a unique index\nWriteToNextArrayPosition := FALSE;\nIF (diIndex >= 0 AND diIndex <= 1000) THEN\n g_boolArray[diIndex] := bToWrite; \/\/Writes to unique index\n WriteToNextArrayPosition := TRUE; \/\/ TRUE: Array was not full yet\nEND_IF " }, 
{ "title" : "演算子：__POSITION ", 
"url" : "_cds_operator_position.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：__POSITION ", 
"snippet" : "__POSITION 演算子は、IEC61131-1規格の拡張です。 実行時に、オペレーターはPOUの宣言部分または実装部分で変数の位置を生成します。演算子には、タイプの変数を割り当てる必要があります STRING 宣言部分または実装部分で。 の結果 __POSITION 宣言部分： 'Line <line number> (Decl)' 実装部分： 'Line <line number>, Column <Column number> (Impl)' 例 PROGRAM PROG1 VAR strPOS : STRING := __POSITION(); \/\/Returns the line...", 
"body" : "__POSITION 演算子は、IEC61131-1規格の拡張です。 実行時に、オペレーターはPOUの宣言部分または実装部分で変数の位置を生成します。演算子には、タイプの変数を割り当てる必要があります STRING 宣言部分または実装部分で。 の結果 __POSITION 宣言部分： 'Line <line number> (Decl)' 実装部分： 'Line <line number>, Column <Column number> (Impl)' 例 PROGRAM PROG1\nVAR\n strPOS : STRING := __POSITION(); \/\/Returns the line number of this declaration\n strlocalPOS : STRING;\nEND_VAR\n\n strlocalPOS := __POSITION(); \/\/Returns row and column number of this assignment " }, 
{ "title" : "演算子：__POUNAME ", 
"url" : "_cds_operator_pouname.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：__POUNAME ", 
"snippet" : "__POUNAME 演算子は、IEC61131-1規格の拡張です。 実行時に、オペレーターはオペレーターを含むPOUの名前を生成します __POUNAME 。結果はタイプです STRING 。 結果として __POUNAME 使用場所によって異なります プログラム内：プログラム名 関数名の場合：関数名 機能ブロック内：機能ブロック名 メソッドの場合：FB名で修飾されたメソッド名 プロパティのGet \/ Setアクセサーの場合：プロパティ名+ FB名で修飾されたGet \/ Set GVLの場合：GVL名 構造内：構造名 データ構造内 UNION ：組合名 例 PROGRAM PROG1 VAR ...", 
"body" : "__POUNAME 演算子は、IEC61131-1規格の拡張です。 実行時に、オペレーターはオペレーターを含むPOUの名前を生成します __POUNAME 。結果はタイプです STRING 。 結果として __POUNAME 使用場所によって異なります プログラム内：プログラム名 関数名の場合：関数名 機能ブロック内：機能ブロック名 メソッドの場合：FB名で修飾されたメソッド名 プロパティのGet \/ Setアクセサーの場合：プロパティ名+ FB名で修飾されたGet \/ Set GVLの場合：GVL名 構造内：構造名 データ構造内 UNION ：組合名 例 PROGRAM PROG1\nVAR\n strPOU : STRING := __POUNAME(); \/\/Returns 'PROG1'\n strlocalPOU : STRING;\nEND_VAR\n\nstrlocalPOU := __POUNAME(); \/\/Returns 'PROG1' " }, 
{ "title" : "演算子：TEST_AND_SET ", 
"url" : "_cds_operator_test_and_set.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：TEST_AND_SET ", 
"snippet" : "TEST_AND_SET マルチコア演算子は、IEC61131-3規格の拡張です。 演算子は、セマフォを実装するために使用できます。たとえば、さまざまなタスクによって書き込まれた変数への排他的アクセスを保証するために使用できます。 TEST_AND_SET タイプを取得します DWORD 入力として変数。この変数への書き込みアクセスが可能である必要があります。変数はに設定されます 1 結果として前の値が返されます。 操作はアトミックです。つまり、別のタスクによって中断されることはありません。これはマルチコアプラットフォームにも当てはまります。 たとえば、プログラムの呼び出しは dwOldVal...", 
"body" : "TEST_AND_SET マルチコア演算子は、IEC61131-3規格の拡張です。 演算子は、セマフォを実装するために使用できます。たとえば、さまざまなタスクによって書き込まれた変数への排他的アクセスを保証するために使用できます。 TEST_AND_SET タイプを取得します DWORD 入力として変数。この変数への書き込みアクセスが可能である必要があります。変数はに設定されます 1 結果として前の値が返されます。 操作はアトミックです。つまり、別のタスクによって中断されることはありません。これはマルチコアプラットフォームにも当てはまります。 たとえば、プログラムの呼び出しは dwOldValue := TEST_AND_SET(dw); 、変数 dwOldValue と dw データ型である必要があります DWORD 。 例 次の例は、一般的な使用法を示しています。タイプへの排他的アクセス STRING 変数。 pstrOutput ポインタ、実装する必要があります。文字列へのアクセスはアトミックではありません。複数のタスクが同時に同じ文字列に書き込む場合、内容に一貫性がない可能性があります。とともに TEST_AND_SET 関数、同じを書くことが可能になりました STRING さまざまなタスクで変数。 FUNCTION ExclusiveStringWrite : BOOL\nVAR_INPUT\n strToWrite : STRING;\n pstrOutput : POINTER TO STRING;\nEND_VAR\nVAR_STAT\n dwSynch : DWORD;\nEND_VAR\nVAR\n dwOldValue: DWORD;\nEND_VAR\n\ndwOldValue := TEST_AND_SET(dwSynch); \/\/ Write the 1 and read the old value at the same time\nIF dwOldValue = 0 THEN \/\/ 0 means: no other task is currently writing\n pstrOutput^ := strToWrite; \/\/ Now you can write safely on the string\n dwSynch := 0; \/\/ The DWORD must be reset\n ExclusiveStringWrite := TRUE; \/\/ Writing was successful\nELSE\n ExclusiveStringWrite := FALSE; \/\/ Writing was not successful\nEND_IF " }, 
{ "title" : "演算子：グローバル名前空間 ", 
"url" : "_cds_operator_namespace_global.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：グローバル名前空間 ", 
"snippet" : "グローバル名前空間 演算子は、IEC61131-3規格の拡張です。 ドットで始まるインスタンスパス . 常にグローバル名前空間を開きます。同じ名前のローカル変数がある場合 <varname> グローバル変数として、グローバル変数を次のように参照します .<varname> 。...", 
"body" : "グローバル名前空間 演算子は、IEC61131-3規格の拡張です。 ドットで始まるインスタンスパス . 常にグローバル名前空間を開きます。同じ名前のローカル変数がある場合 <varname> グローバル変数として、グローバル変数を次のように参照します .<varname> 。 " }, 
{ "title" : "演算子：グローバル変数リストの名前空間 ", 
"url" : "_cds_operator_namespace_gvl.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：グローバル変数リストの名前空間 ", 
"snippet" : "グローバル変数リストの名前空間 演算子は、IEC61131-3規格の拡張です。 グローバル変数リスト（GVL）の名前を、リストで定義されている変数の名前空間IDとして使用できます。これにより、異なるグローバル変数リストで同じ名前の変数を使用しながら、特定の変数に一意にアクセスすることができます。ドットを使用します（ . ）グローバル変数リストの名前を変数名の前に追加します。 <global variable list name>.<variable> 例 globlist1.varx := globlist2.varx; The globlist1 と globlist2 グローバル変数リスト...", 
"body" : "グローバル変数リストの名前空間 演算子は、IEC61131-3規格の拡張です。 グローバル変数リスト（GVL）の名前を、リストで定義されている変数の名前空間IDとして使用できます。これにより、異なるグローバル変数リストで同じ名前の変数を使用しながら、特定の変数に一意にアクセスすることができます。ドットを使用します（ . ）グローバル変数リストの名前を変数名の前に追加します。 <global variable list name>.<variable> 例 globlist1.varx := globlist2.varx; The globlist1 と globlist2 グローバル変数リストにはそれぞれ varx 変数。 CODESYS コピー varx からのグローバル変数 globlist2 リストする varx の中に globlist1 リスト。 付加されたリスト名を参照せずに、いくつかのグローバル変数リストで宣言されている変数を参照すると、エラーメッセージが出力されます。 " }, 
{ "title" : "演算子：ライブラリの名前空間 ", 
"url" : "_cds_operator_namespace_lib.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：ライブラリの名前空間 ", 
"snippet" : "ライブラリの名前空間 構文： <library namespace>.<library POU identifier> 例： LIB_A.FB_A ライブラリブロック識別子は、ライブラリモジュールへの一意で修飾されたアクセスのために、ライブラリ名前空間に（ドットで区切られたプレフィックスとして）追加されます。名前空間は通常、ライブラリ名と一致します。 例 ライブラリはプロジェクトに含まれ、 FB_A ポウ。ただし、同じ名前の関数ブロックは、プロジェクト内で既にローカルで使用できます。ライブラリPOUを次のように識別します LIB_A.FB_A ローカル関数ブロックではなく、ライブラリ POU ...", 
"body" : "ライブラリの名前空間 構文： <library namespace>.<library POU identifier> 例： LIB_A.FB_A ライブラリブロック識別子は、ライブラリモジュールへの一意で修飾されたアクセスのために、ライブラリ名前空間に（ドットで区切られたプレフィックスとして）追加されます。名前空間は通常、ライブラリ名と一致します。 例 ライブラリはプロジェクトに含まれ、 FB_A ポウ。ただし、同じ名前の関数ブロックは、プロジェクト内で既にローカルで使用できます。ライブラリPOUを次のように識別します LIB_A.FB_A ローカル関数ブロックではなく、ライブラリ POU にアクセスするため。 var1 := FB_A(in := 12); \/\/ Call of the project function FB_A\nvar2 := LIB_A.FB_A(in := 22); \/\/ Call of the library function FB_A 名前空間に別の識別子を定義できます。これを行うには、プロジェクト情報で名前空間を指定します (ライブラリ開発者: ライブラリ プロジェクトの作成時)。または、ライブラリ マネージャーのライブラリに特定の名前空間を指定することもできます。 プロパティ ダイアログ (アプリケーション開発者: アプリケーションの作成時)。 詳細については、以下を参照してください。 ライブラリの使用" }, 
{ "title" : "直接アクセスの演算子 (#) ", 
"url" : "_cds_operator_namespace_lib.html#UUID-743ca1a8-1b92-e8be-7a21-610d20d2e0b2_section-idm13349116767826", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：ライブラリの名前空間 \/ 直接アクセスの演算子 (#) ", 
"snippet" : "オペレーターは IEC 61131-3 標準の拡張です。 機能ブロックのローカル コンポーネントが同じ名前のライブラリ POU をオーバーライドする可能性があり、あいまいさが生じます。その結果、通常の名前空間規則でのアクセスはできなくなります。次に、 # 直接アクセスを強制するオペレーター。 次の構文を使用して、直接アクセスを強制できます。 構文： <namespace> # <library POU path> 例 TYPE Struct1 : STRUCT Standard : Struct2; END_STRUCT END_TYPE TYPE Struct2 : STRUCT Conca...", 
"body" : "オペレーターは IEC 61131-3 標準の拡張です。 機能ブロックのローカル コンポーネントが同じ名前のライブラリ POU をオーバーライドする可能性があり、あいまいさが生じます。その結果、通常の名前空間規則でのアクセスはできなくなります。次に、 # 直接アクセスを強制するオペレーター。 次の構文を使用して、直接アクセスを強制できます。 構文： <namespace> # <library POU path> 例 TYPE Struct1 :\nSTRUCT\n\tStandard : Struct2;\nEND_STRUCT\nEND_TYPE TYPE Struct2 :\nSTRUCT\n\tConcat : DINT;\nEND_STRUCT\nEND_TYPE {attribute 'qualified_only'}\nVAR_GLOBAL\n\tStandard : Struct2;\nEND_VAR PROGRAM PLC_PRG\nVAR\n test : _3S_License#Standard#TON;\n str : STRING;\nEND_VAR\n\n\/\/ access to global variable\n_3S_License.Standard.CONCAT := 123;\n\n\/\/ with hashtag access, the library is explicitly addressed \nstr := _3S_License.Standard#CONCAT('test1', '3444');\nstr := Standard#CONCAT('test1', '3444');\nstr := _3S_License#Standard#CONCAT('test1', '3444');\nstr := _3S_License.Standard#CONCAT('test1', '3444');\nstr := CONCAT('test1', Standard#CONCAT('3444', '444'));\nstr := CONCAT('test1', _3S_License.Standard#CONCAT('3444', '444'));\nstr := CONCAT('test1', _3S_License#Standard#CONCAT('3444', '444'));\nstr := Standard#CONCAT('test1', Standard#CONCAT('3444', '444'));\nstr := Standard#CONCAT('test1', _3S_License.Standard#CONCAT('3444', '444'));\nstr := Standard#CONCAT('test1', _3S_License#Standard#CONCAT('3444', '444'));\nstr := Standard#CONCAT('test1', _3S_License#Standard#CONCAT('asdf', 'fdas'));\n " }, 
{ "title" : "演算子：列挙型名前空間 ", 
"url" : "_cds_operator_namespace_enum.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：列挙型名前空間 ", 
"snippet" : "列挙型名前空間 演算子は、IEC61131-3規格の拡張です。 列挙型のTYPE名を使用して、列挙型定数に一意にアクセスできます。このようにして、異なる列挙型で同じ定数名を使用できます。 列挙名の前にドット（ . ）。 <enumeration name>.<constant name> 例 定数 Blue 両方の列挙のコンポーネントです Colors と列挙 Feelings 。 color := Colors.Blue; \/\/ Access to coomponent Blue in enumeration Colors feeling := Feelings.Blue; \/\/ Acces...", 
"body" : "列挙型名前空間 演算子は、IEC61131-3規格の拡張です。 列挙型のTYPE名を使用して、列挙型定数に一意にアクセスできます。このようにして、異なる列挙型で同じ定数名を使用できます。 列挙名の前にドット（ . ）。 <enumeration name>.<constant name> 例 定数 Blue 両方の列挙のコンポーネントです Colors と列挙 Feelings 。 color := Colors.Blue; \/\/ Access to coomponent Blue in enumeration Colors\n\nfeeling := Feelings.Blue; \/\/ Acces to component Blue in enumeration Feelings " }, 
{ "title" : "演算子：__POOL ", 
"url" : "_cds_operator_pool.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：__POOL ", 
"snippet" : "__POOL 演算子は、IEC61131-3規格の拡張です。 演算子は、グローバルPOUプール（ POU 見る）。オペレーターは、内のオブジェクトに直接アクセスします POU 見る。 例 PROGRAM PLC_PRG VAR svar_pou : STRING; END_VAR svar_pou := __POOL.POU(); 詳細については、以下を参照してください。 シャドーイングを防ぐ方法...", 
"body" : "__POOL 演算子は、IEC61131-3規格の拡張です。 演算子は、グローバルPOUプール（ POU 見る）。オペレーターは、内のオブジェクトに直接アクセスします POU 見る。 例 PROGRAM PLC_PRG\nVAR\n svar_pou : STRING;\nEND_VAR\n\nsvar_pou := __POOL.POU(); 詳細については、以下を参照してください。 シャドーイングを防ぐ方法" }, 
{ "title" : "演算子：INI ", 
"url" : "_cds_operator_ini.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペレーター \/ 演算子：INI ", 
"snippet" : "INI の INI operator はの演算子です CoDeSys V2.3 .この演算子は、 FB_Init 現在の方法 CODESYS V3.ただし、インポート元のプロジェクトでは引き続きこの演算子を使用できます。 CoDeSys V2.3 . 構文 <boolean variable name> := INI ( <FB instance name> , <boolean value> ); \/\/ <boolean value> : TRUE | FALSE とともに INI 演算子を使用すると、POU で使用される関数ブロック インスタンスの保持変数の初期化をトリガーできます。 演算...", 
"body" : "INI の INI operator はの演算子です CoDeSys V2.3 .この演算子は、 FB_Init 現在の方法 CODESYS V3.ただし、インポート元のプロジェクトでは引き続きこの演算子を使用できます。 CoDeSys V2.3 . 構文 <boolean variable name> := INI ( <FB instance name> , <boolean value> );\n\/\/ <boolean value> : TRUE | FALSE とともに INI 演算子を使用すると、POU で使用される関数ブロック インスタンスの保持変数の初期化をトリガーできます。 演算子の 2 番目のパラメーターが TRUE 、 それから CODESYS 関数ブロックで定義されているすべての保持変数を初期化します <FB instance name> そして戻ってきます TRUE . STでの例 fbinst 機能ブロックのインスタンスです fb1 、ここで、保持変数 retvar が定義されています。 VAR\n fbinst : fb1;\n b : BOOL;\nEND_VAR\n\nb := INI(fbinst, TRUE);\nivar := fbinst.retvar; (* => retvar is initialized *)\n の例 FUP 詳細については、次を参照してください。 RETAIN、 保持変数を使用してデータを取得する" }, 
{ "title" : "型変換演算子 ", 
"url" : "_cds_conversion_operators.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 ", 
"snippet" : "境界ケースの丸めロジックは、ターゲットシステムまたはFPUによって異なります（ 浮動小数点ユニット ）の値を指定します。たとえば、 -1.5 コントローラーによって異なる変換が行われる場合があります。 キャッチ値の範囲は、アプリケーション全体でオーバーフローし、ターゲットシステムからコードに依存せずにプログラムします。 型変換演算子のオペランド値がターゲットデータ型の値の範囲外である場合、結果の出力はプロセッサタイプに依存するため、未定義になります。これは、たとえば、負のオペランド値がから変換される場合です。 LREAL ターゲットデータ型に UINT 。 大きなデータ型から小さなデータ型に変...", 
"body" : "境界ケースの丸めロジックは、ターゲットシステムまたはFPUによって異なります（ 浮動小数点ユニット ）の値を指定します。たとえば、 -1.5 コントローラーによって異なる変換が行われる場合があります。 キャッチ値の範囲は、アプリケーション全体でオーバーフローし、ターゲットシステムからコードに依存せずにプログラムします。 型変換演算子のオペランド値がターゲットデータ型の値の範囲外である場合、結果の出力はプロセッサタイプに依存するため、未定義になります。これは、たとえば、負のオペランド値がから変換される場合です。 LREAL ターゲットデータ型に UINT 。 大きなデータ型から小さなデータ型に変換すると、情報が失われる可能性があります。 文字列操作 タイプをに変換するとき STRING また WSTRING 、入力された値は文字列として左揃えになり、長すぎる場合は切り捨てられます。したがって、型変換演算子の戻り変数を宣言します <>_TO_STRING と <>_TO_WSTRING 文字列が操作なしで十分なスペースを持つのに十分な長さ。 " }, 
{ "title" : "型変換 ", 
"url" : "_cds_conversion_operators.html#UUID-a8ef93c9-c5d6-bfc3-02a3-f7ae8780fbce_UUID-42fbcdfe-e4d8-8424-32d5-eb04a19b62c4_section-idm13452249872816", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ 型変換 ", 
"snippet" : "型変換演算子を明示的に呼び出すことができます。 以下で説明する型変換演算子は、ある基本型から別の基本型への型指定変換、およびオーバーロードに使用できます。 「大きい」型から「小さい」型への変換も暗黙的に可能です（たとえば、 INT に BYTE または DINT に WORD ）。...", 
"body" : "型変換演算子を明示的に呼び出すことができます。 以下で説明する型変換演算子は、ある基本型から別の基本型への型指定変換、およびオーバーロードに使用できます。 「大きい」型から「小さい」型への変換も暗黙的に可能です（たとえば、 INT に BYTE または DINT に WORD ）。 " }, 
{ "title" : "オーバーロード変換 ", 
"url" : "_cds_operator_to_xxx.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ オーバーロード変換 ", 
"snippet" : "オーバーロード IEC 61131-3 規格では、オーバーロードされた機能は規定されていません。 IEC 61131-3に厳密に従ってプログラミングしたい場合は、構文の演算子を使用する必要があります。 <出力タイプ> _TO_ <ターゲットタイプ> 次のセクションで説明します。 演算子は、ターゲット タイプのみを明示的に指定し (オペランドの出力タイプは指定しない)、値を他のデータ型に変換します (オーバーロードされた変換)。 型付き変換の規則は、ここでもオーバーロードに適用されます。 過負荷はIEC61131-3仕様の一部ではありません。 呼び出し構文 : <TO_<ターゲットタイプ> ( ...", 
"body" : "オーバーロード IEC 61131-3 規格では、オーバーロードされた機能は規定されていません。 IEC 61131-3に厳密に従ってプログラミングしたい場合は、構文の演算子を使用する必要があります。 <出力タイプ> _TO_ <ターゲットタイプ> 次のセクションで説明します。 演算子は、ターゲット タイプのみを明示的に指定し (オペランドの出力タイプは指定しない)、値を他のデータ型に変換します (オーバーロードされた変換)。 型付き変換の規則は、ここでもオーバーロードに適用されます。 過負荷はIEC61131-3仕様の一部ではありません。 呼び出し構文 : <TO_<ターゲットタイプ> ( <オペランド> ) オペランド データタイプ 説明 変数、リテラル 標準データ型 データ型オーバーロード演算子: TO_<ターゲット データ型> オペレーター 例 戻り値 説明 TO___UXINT TO___UXINT(123.4) 123 __UXINT、__ XINT、__ XWORD TO___XINT TO___UXINT(123.4) 123 __UXINT、__ XINT、__ XWORD TO___XWORD __UXINT、__ XINT、__ XWORD TO_BIT BIT TO_BOOL TO_BOOL(0.001) TRUE BOOL TO_BYTE Integer TO_DATE 構文： D#yyyy-MM-dd, DATE#yyyy-MM-dd データ型: DATE TO_DATE_AND_TIME TO_DT TO_DT(0) DT##1970-1-1-0:0:0 構文： DT#yyyy-MM-dd-hh:mm:ss, DATE_AND_TIME#yyyy-MM-dd-hh:mm:ss データ型: DATE TO_DINT Integer TO_DWORD Integer TO_INT TO_INT(4.22) TO_INT(123.4) 4 123 Integer TO_LDATE 構文： LDATE#yyyy-MM-dd データ型: DATE TO_LDT 構文： LDT#yyyy-MM-dd-hh:mm:ss.sss データ型: DATE TO_LINT Integer TO_LREAL REAL、LREAL TO_LTIME データ型: TIME、LTIME TO_LTOD 構文： LTOD#hh:mm:ss.sssssssss データ型: DATE TO_LWORD Integer TO_REAL REAL、LREAL TO_SINT Integer TO_STRING TO_STRING(342) '342' STRING TO_TIME TO_TIME(SysTimeGetMs()) システム時間 データ型: TIME、LTIME TO_TOD データ型: DATE TO_UDINT Integer TO_UINT TO_UINT(D#2019-9-3) 44288 Integer TO_ULINT Integer TO_USINT Integer TO_WORD Integer TO_WSTRING TO_WSTRING('Hello World') \"Hello World!\" WSTRING" }, 
{ "title" : "変換: BOOL ", 
"url" : "_cds_operator_bool_to-2023061.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ 変換: BOOL ", 
"snippet" : "BOOL 演算子 BOOL_TO_<type> は、ブール値を指定されたデータ型に変換し、型変換された値を返します。 呼び出し構文 : < BOOL_TO_<型> ( <オペランド> ) オペランド データタイプ 説明 変数、リテラル BOOL 演算子: BOOL_TO_<type> オペレーター 例 戻り値 説明 BOOL_TO___UXINT BOOL_TO___UXINT(TRUE) 1 __UXINT、__ XINT、__ XWORD BOOL_TO___XINT BOOL_TO___XINT(TRUE) 1 __UXINT、__ XINT、__ XWORD BOOL_TO___XWO...", 
"body" : "BOOL 演算子 BOOL_TO_<type> は、ブール値を指定されたデータ型に変換し、型変換された値を返します。 呼び出し構文 : < BOOL_TO_<型> ( <オペランド> ) オペランド データタイプ 説明 変数、リテラル BOOL 演算子: BOOL_TO_<type> オペレーター 例 戻り値 説明 BOOL_TO___UXINT BOOL_TO___UXINT(TRUE) 1 __UXINT、__ XINT、__ XWORD BOOL_TO___XINT BOOL_TO___XINT(TRUE) 1 __UXINT、__ XINT、__ XWORD BOOL_TO___XWORD BOOL_TO___XWINT(TRUE) 1 __UXINT、__ XINT、__ XWORD BOOL_TO_BIT BOOL_TO___BIT(TRUE) TRUE BIT BOOL_TO_BYTE BOOL_TO_BYTE(TRUE) 1 Integer BOOL_TO_DATE BOOL_TO_DATE(TRUE) D#1970-1-1 0 番目のビットは設定されていますが、表示には影響しません。 データ型: DATE BOOL_TO_DINT BOOL_TO_DINT(TRUE) 1 Integer BOOL_TO_DT BOOL_TO_DT(TRUE) DT#1970-01-01-0:0:1 データ型: DATE BOOL_TO_DWORD BOOL_TO_DWORD(TRUE) 1 Integer BOOL_TO_INT BOOL_TO_INT(TRUE) 1 Integer BOOL_TO_LDATE BOOL_TO_LDATE(TRUE) LD#1970-01-01 0 番目のビットは設定されていますが、表示には影響しません。 データ型: DATE BOOL_TO_LDT BOOL_TO_LD(TRUE) DT#1970-01-01-0:0:1 データ型: DATE BOOL_TO_LINT BOOL_TO_LINT(TRUE) 1 Integer BOOL_TO_LREAL BOOL_TO_LREAL(TRUE) 1 REAL、LREAL BOOL_TO_LTIME BOOL_TO_LTIME(TRUE) LTIME#1NS データ型: DATE BOOL_TO_LTOD BOOL_TO_LTOD(TRUE) LTOD#0:0:0.000000001 データ型: DATE BOOL_TO_LWORD BOOL_TO_LWORD(TRUE) 1 Integer BOOL_TO_REAL BOOL_TO_REAL(TRUE) 1 REAL、LREAL BOOL_TO_SINT BOOL_TO_SINT(TRUE) 1 Integer BOOL_TO_STRING BOOL_TO_STRING(TRUE) 'TRUE' STRING BOOL_TO_TIME BOOL_TO_TIME(TRUE) T#1ms データ型: DATE BOOL_TO_TOD BOOL_TO_TOD(TRUE) TOD#0:0:0.001 データ型: DATE BOOL_TO_UDINT BOOL_TO_UDINT(TRUE) 1 Integer BOOL_TO_UINT BOOL_TO_UINT(TRUE) 1 Integer BOOL_TO_ULINT BOOL_TO_ULINT(TRUE) 1 Integer BOOL_TO_USINT BOOL_TO_ULSINT(TRUE) 1 Integer BOOL_TO_WORD BOOL_TO_WORD(TRUE) 1 Integer BOOL_TO_WSTRING BOOL_TO_WSTRING(TRUE) \"TRUE\" WSTRING" }, 
{ "title" : "例 ", 
"url" : "_cds_operator_bool_to-2023061.html#UUID-682020e5-0008-f30f-f004-09c97f2d0715_UUID-7cb488ce-e3ad-80d5-81d9-c44c2ef838fa_id_a353abc1de5f9c0a8640e006e95fc_id_a764924bfc35ef1cc0a8646370e2d8a1", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ 変換: BOOL \/ 例 ", 
"snippet" : "FB_ConvertFromBool STでの宣言 FUNCTION_BLOCK FB_ConvertFromBool VAR uxiReturn_1: __UXINT; uxiReturn_10: __UXINT; iReturn_2: __XINT; iReturn_20: __XINT; xwReturn_3: __XWORD; xwReturn_30: __XWORD; bitReturn_4: BOOL; bitReturn_40: BOOL; bReturn_6: BYTE; bReturn_60: BYTE; dateReturn_7: DATE; dateReturn_70: ...", 
"body" : "FB_ConvertFromBool STでの宣言 FUNCTION_BLOCK FB_ConvertFromBool\nVAR\n uxiReturn_1: __UXINT;\n uxiReturn_10: __UXINT;\n iReturn_2: __XINT;\n iReturn_20: __XINT;\n xwReturn_3: __XWORD;\n xwReturn_30: __XWORD;\n bitReturn_4: BOOL;\n bitReturn_40: BOOL;\n bReturn_6: BYTE;\n bReturn_60: BYTE;\n dateReturn_7: DATE;\n dateReturn_70: DATE;\n dtReturn_8: DATE_AND_TIME;\n dtReturn_80: DATE_AND_TIME;\n diReturn_9: DINT;\n diReturn_90: DINT;\n dtReturn_10: DATE_AND_TIME;\n dtReturn_100: DATE_AND_TIME;\n dwReturn_11: DWORD;\n dwReturn_110: DWORD;\n iReturn_12: INT;\n iReturn_120: INT;\n liReturn_13: LINT;\n liReturn_130: LINT;\n lrReturn_14: LREAL;\n lrReturn_140: LREAL;\n lwReturn_15: LWORD;\n lwReturn_150: LWORD;\n rReturn_16: REAL;\n rReturn_160: REAL;\n siReturn_17: SINT;\n siReturn_170: SINT;\n sReturn_18: STRING;\n sReturn_180: STRING;\n todReturn_19: TIME_OF_DAY;\n todReturn_190: TIME_OF_DAY;\n timReturn_20: TIME;\n timReturn_200: TIME;\n todReturn_21: TIME_OF_DAY;\n todReturn_210: TIME_OF_DAY;\n udiReturn_22: UDINT;\n udiReturn_220: UDINT;\n uiReturn_23: UINT;\n uiReturn_230: UINT;\n uliReturn_24: ULINT;\n uliReturn_240: ULINT;\n usiReturn_25: USINT;\n usiReturn_250: USINT;\n wReturn_26: WORD;\n wReturn_260: WORD;\n wsReturn_27: WSTRING;\n wsReturn_270: WSTRING;\nEND_VAR\n STでの実装 FUNCTION_BLOCK FB_ConvertFromBool\nVAR\nVAR\n uxiReturn_1: __UXINT;\n uxiReturn_10: __UXINT;\n iReturn_2: __XINT;\n iReturn_20: __XINT;\n xwReturn_3: __XWORD;\n xwReturn_30: __XWORD;\n bitReturn_4: BOOL;\n bitReturn_40: BOOL;\n bReturn_6: BYTE;\n bReturn_60: BYTE;\n dateReturn_7: DATE;\n dateReturn_70: DATE;\n dtReturn_8: DATE_AND_TIME;\n dtReturn_80: DATE_AND_TIME;\n diReturn_9: DINT;\n diReturn_90: DINT;\n dtReturn_10: DATE_AND_TIME;\n dtReturn_100: DATE_AND_TIME;\n dwReturn_11: DWORD;\n dwReturn_110: DWORD;\n iReturn_12: INT;\n iReturn_120: INT;\n liReturn_13: LINT;\n liReturn_130: LINT;\n lrReturn_14: LREAL;\n lrReturn_140: LREAL;\n lwReturn_15: LWORD;\n lwReturn_150: LWORD;\n rReturn_16: REAL;\n rReturn_160: REAL;\n siReturn_17: SINT;\n siReturn_170: SINT;\n sReturn_18: STRING;\n sReturn_180: STRING;\n todReturn_19: TIME_OF_DAY;\n todReturn_190: TIME_OF_DAY;\n timReturn_20: TIME;\n timReturn_200: TIME;\n todReturn_21: TIME_OF_DAY;\n todReturn_210: TIME_OF_DAY;\n udiReturn_22: UDINT;\n udiReturn_220: UDINT;\n uiReturn_23: UINT;\n uiReturn_230: UINT;\n uliReturn_24: ULINT;\n uliReturn_240: ULINT;\n usiReturn_25: USINT;\n usiReturn_250: USINT;\n wReturn_26: WORD;\n wReturn_260: WORD;\n wsReturn_27: WSTRING;\n wsReturn_270: WSTRING;\nEND_VAR\n\n\/\/ Return value of operand = TRUE or FALSE\nuxiReturn_1 := BOOL_TO___UXINT(TRUE);\nuxiReturn_10 := BOOL_TO___UXINT(FALSE);\n\niReturn_2 := BOOL_TO___XINT(TRUE);\niReturn_20 := BOOL_TO___XINT(FALSE);\n\nxwReturn_3 := BOOL_TO___XWORD(TRUE);\nxwReturn_30 := BOOL_TO___XWORD(FALSE);\n\nbitReturn_4 := BOOL_TO_BIT(TRUE);\nbitReturn_40 := BOOL_TO_BIT(FALSE);\n\nbReturn_6 := BOOL_TO_BYTE(TRUE);\nbReturn_60 := BOOL_TO_BYTE(FALSE);\n\ndateReturn_7 := BOOL_TO_DATE(TRUE);\ndateReturn_70 := BOOL_TO_DATE(FALSE);\n\ndtReturn_8 := BOOL_TO_DT(TRUE);\ndtReturn_80 := BOOL_TO_DT(FALSE);\n\ndiReturn_9 := BOOL_TO_DINT(TRUE);\ndiReturn_90 := BOOL_TO_DINT(FALSE);\n\ndwReturn_11 := BOOL_TO_DWORD(TRUE);\ndwReturn_110 := BOOL_TO_DWORD(FALSE);\n\niReturn_12 := BOOL_TO_INT(TRUE);\niReturn_120 := BOOL_TO_INT(FALSE);\n\nliReturn_13 := BOOL_TO_LINT(TRUE);\nliReturn_130 := BOOL_TO_LINT(FALSE);\n\nlrReturn_14 := BOOL_TO_LREAL(TRUE);\nlrReturn_140 := BOOL_TO_LREAL(FALSE);\n\nlwReturn_15 := BOOL_TO_LWORD(TRUE);\nlwReturn_150 := BOOL_TO_LWORD(FALSE);\n\nrReturn_16 := BOOL_TO_REAL(TRUE);\nrReturn_160 := BOOL_TO_REAL(FALSE);\n\nsiReturn_17 := BOOL_TO_SINT(TRUE);\nsiReturn_170 := BOOL_TO_SINT(FALSE);\n\nsReturn_18 := BOOL_TO_STRING(TRUE);\nsReturn_180 := BOOL_TO_STRING(FALSE);\n\ntimReturn_20 := BOOL_TO_TIME(TRUE);\ntimReturn_200 := BOOL_TO_TIME(FALSE);\n\ntodReturn_21 := BOOL_TO_TOD(TRUE);\ntodReturn_210 := BOOL_TO_TOD(FALSE);\n\nudiReturn_22 := BOOL_TO_UDINT(TRUE);\nudiReturn_220 := BOOL_TO_UDINT(FALSE);\n\nuiReturn_23 := BOOL_TO_UINT(TRUE);\nuiReturn_230 := BOOL_TO_UINT(FALSE);\n\nuliReturn_24 := BOOL_TO_ULINT(TRUE);\nuliReturn_240 := BOOL_TO_ULINT(FALSE);\n\nusiReturn_25 := BOOL_TO_USINT(TRUE);\nusiReturn_250 := BOOL_TO_USINT(FALSE);\n\nwReturn_26 := BOOL_TO_WORD(TRUE);\nwReturn_260 := BOOL_TO_WORD(FALSE);\n\nwsReturn_27 := BOOL_TO_WSTRING(TRUE);\nwsReturn_270 := BOOL_TO_WSTRING(FALSE); FB_FbdConvertBool FBD実装言語 " }, 
{ "title" : "変換: 整数 ", 
"url" : "_cds_operator_convert_integer.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ 変換: 整数 ", 
"snippet" : "整数 演算子は整数値をターゲット型に変換し、型変換された値を返します。変換する数値が範囲制限を超える場合、数値の最初のバイトは無視されます。 呼び出し構文 : <整数型>_TO_<標準型> ( <オペランド> ) オペランド データタイプ 説明 変数、リテラル __UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | RE...", 
"body" : "整数 演算子は整数値をターゲット型に変換し、型変換された値を返します。変換する数値が範囲制限を超える場合、数値の最初のバイトは無視されます。 呼び出し構文 : <整数型>_TO_<標準型> ( <オペランド> ) オペランド データタイプ 説明 変数、リテラル __UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT |STRING | TIME | TOD | TIME_OF_DAY | UDINT | UINT | ULINT | USINT | WORD | WSTRING IntegerSTRING, WSTRING演算子: <整数型>_TO_<標準型> (行列) __UXINT __XINT __XWORD BIT BYTE DINT DWORD INT LINT LWORD SINT UDINT UINT ULINT USINT WORD __UXINT - __XINT_TO___UXINT __XWORD_TO_UXINT BIT_TO___UXINT BYTE_TO___UXINT DINT_TO___UXINT DWORD_TO___UXINT INT_TO___UXINT LINT_TO___UXINT LWORD_TO___UXINT SINT_TO___UXINT UDINT_TO___UXINT UINT_TO___UXINT ULINT_TO___UXINT USINT_TO___XINT WORD_TO___XINT __XINT __UXINT_TO___XINT - __XWORD_TO_XINT BIT_TO___XINT BYTE_TO___XINT DINT_TO___XINT DWORD_TO___XINT INT_TO___XINT LINT_TO___XINT LWORD_TO___XINT SINT_TO___XINT UDINT_TO___XINT UINT_TO___XINT ULINT_TO___XINT USINT_TO___XINT WORD_TO___XINT __XWORD __UXINT_TO___XWORD __XINT_TO___XWORD - BIT_TO___XWORD BYTE_TO___XWORD DINT_TO___XWORD DWORD_TO___XWORD INT_TO___XWORD LINT_TO___XWORD LWORD_TO___XWORD SINT_TO___XWORD UDINT_TO___XWORD UINT_TO___XWORD ULINT_TO___XWORD USINT_TO___XWORD WORD_TO___XWORD BIT __UXINT_TO_BIT __XINT_TO_BIT __XWORD_TO_BIT - BYTE_TO_BIT DINT_TO_BIT DWORD_TO_BIT INT_TO_BIT LINT_TO_BIT LWORD_TO_BIT SINT_TO_BIT UDINT_TO_BIT UINT_TO_BIT ULINT_TO_BIT USINT_TO_BIT WORD_TO_BIT BOOL __UXINT_TO_BOOL __XINT_TO_BOOL __XWORD_TO_BOOL BIT_TO_BOOL BYTE_TO_BOOL DINT_TO_BOOL DWORD_TO_BOOL INT_TO_BOOL LINT_TO_BOOL LWORD_TO_BOOL SINT_TO_BOOL UDINT_TO_BOOL UINT_TO_BOOL ULINT_TO_BOOL USINT_TO_BOOL WORD_TO_BOOL Byte __UXINT_TO_BYTE __XINT_TO_BYTE __XWORD_TO_BYTE BIT_TO_BYTE - DINT_TO_BYTE DWORD_TO_BYTE INT_TO_BYTE LINT_TO_BYTE LWORD_TO_BYTE SINT_TO_BYTE UDINT_TO_BYTE UINT_TO_BYTE ULINT_TO_BYTE USINT_TO_BYTE WORD_TO_BYTE DATE __UXINT_TO_DATE __XINT_TO_DATE __XWORD_TO_DATE BIT_TO_DATE BYTE_TO_DATE DINT_TO_DATE DWORD_TO_DATE INT_TO_DATE LINT_TO_DATE LWORD_TO_DATE SINT_TO_DATE UDINT_TO_DATE UINT_TO_DATE ULINT_TO_DATE USINT_TO_DATE WORD_TO_DATE DINT __UXINT_TO_DINT __XINT_TO_DINT __XWORD_TO_DINT BIT_TO_DINT BYTE_TO_DINT - DWORD_TO_DINT INT_TO_DINT LINT_TO_DINT LWORD_TO_DINT SINT_TO_DINT UDINT_TO_DINT UINT_TO_DINT ULINT_TO_DINT USINT_TO_DINT WORD_TO_DINT DT __UXINT_TO_DT __XINT_TO_DT __XWORD_TO_DT BIT_TO_DT BYTE_TO_DT DINT_TO_DT DWORD_TO_DT INT_TO_DT LINT_TO_DT LWORD_TO_DT SINT_TO_DT UDINT_TO_DT UINT_TO_DT ULINT_TO_DT USINT_TO_DT WORD_TO_DT DWORD __UXINT_TO_DWORD __XINT_TO_DWORD __XWORD_TO_DWORD BIT_TO_DWORD BYTE_TO_DWORD DINT_TO_DWORD - INT_TO_DWORD LINT_TO_DWORD LWORD_TO_DWORD SINT_TO_DWORD UDINT_TO_DWORD UINT_TO_DWORD ULINT_TO_DWORD USINT_TO_DWORD WORD_TO_DWORD INT __UXINT_TO_INT __XINT_TO_INT __XWORD_TO_INT BIT_TO_INT BYTE_TO_INT DINT_TO_INT DWORD_TO_INT - LINT_TO_INT LWORD_TO_INT SINT_TO_INT UDINT_TO_INT UINT_TO_INT ULINT_TO_INT USINT_TO_INT WORD_TO_INT LDATE __UXINT_TO_LDATE __XINT_TO_LDATE __XWORD_TO_LDATE BIT_TO_LDATE BYTE_TO_LDATE DINT_TO_LDATE DWORD_TO_LDATE INT_TO_LDATE LINT_TO_LDATE LWORD_TO_LDATE SINT_TO_LDATE UDINT_TO_LDATE UINT_TO_LDATE ULINT_TO_LDATE USINT_TO_LDATE WORD_TO_LDATE LDT __UXINT_TO_LDT __XINT_TO_LDT __XWORD_TO_LDT BIT_TO_LDT BYTE_TO_LDT DINT_TO_LDT DWORD_TO_LDT INT_TO_LDT LINT_TO_LDT LWORD_TO_LDT SINT_TO_LDT UDINT_TO_LDT UINT_TO_LDT ULINT_TO_LDT USINT_TO_LDT WORD_TO_LDT LINT __UXINT_TO_LINT __XINT_TO_LINT __XWORD_TO_LINT BIT_TO_LINT BYTE_TO_LINT DINT_TO_LINT DWORD_TO_LINT INT_TO_LINT - LWORD_TO_LINT SINT_TO_LINT UDINT_TO_LINT UINT_TO_LINT ULINT_TO_LINT USINT_TO_LINT WORD_TO_LINT LREAL __UXINT_TO_LREAL __XINT_TO_LREAL __XWORD_TO_LREAL BIT_TO_LREAL BYTE_TO_LREAL DINT_TO_LREAL DWORD_TO_LREAL INT_TO_LREAL LINT_TO_LREAL LWORD_TO_LREAL SINT_TO_LREAL UDINT_TO_LREAL UINT_TO_LREAL ULINT_TO_LREAL USINT_TO_LREAL WORD_TO_LREAL LTIME __UXINT_TO_LTIME __XINT_TO_LTIME __XWORD_TO_LTIME BIT_TO_LTIME BYTE_TO_LTIME DINT_TO_LTIME DWORD_TO_LTIME INT_TO_LTIME LINT_TO_LTIME LWORD_TO_LTIME SINT_TO_LTIME UDINT_TO_LTIME UINT_TO_LTIME ULINT_TO_LTIME USINT_TO_LTIME WORD_TO_LTIME LTOD __UXINT_TO_LTOD __XINT_TO_LTOD __XWORD_TO_LTOD BIT_TO_LTOD BYTE_TO_LTOD DINT_TO_LTOD DWORD_TO_LTOD INT_TO_LTOD LINT_TO_LTOD LWORD_TO_LTOD SINT_TO_LTOD UDINT_TO_LTOD UINT_TO_LTOD ULINT_TO_LTOD USINT_TO_LTOD WORD_TO_LTOD LWORD __UXINT_TO_LWORD __XINT_TO_LWORD __XWORD_TO_LWORD BIT_TO_LWORD BYTE_TO_LWORD DINT_TO_LWORD DWORD_TO_LWORD INT_TO_LWORD LINT_TO_LWORD - SINT_TO_LWORD UDINT_TO_LWORD UINT_TO_LWORD ULINT_TO_LWORD USINT_TO_LWORD WORD_TO_LWORD REAL __UXINT_TO_REAL __XINT_TO_REAL __XWORD_TO_REAL BIT_TO_REAL BYTE_TO_REAL DINT_TO_REAL DWORD_TO_REAL INT_TO_REAL LINT_TO_REAL LWORD_TO_REAL SINT_TO_REAL UDINT_TO_REAL UINT_TO_REAL ULINT_TO_REAL USINT_TO_REAL WORD_TO_REAL SINT __UXINT_TO_SINT __XINT_TO_SINT __XWORD_TO_SINT BIT_TO_SINT BYTE_TO_SINT DINT_TO_SINT DWORD_TO_SINT INT_TO_SINT LINT_TO_SINT LWORD_TO_SINT - UDINT_TO_SINT UINT_TO_SINT ULINT_TO_SINT USINT_TO_SINT WORD_TO_SINT STRING __UXINT_TO_STRING __XINT_TO_STRING __XWORD_TO_STRING BIT_TO_STRING BYTE_TO_STRING DINT_TO_STRING DWORD_TO_STRING INT_TO_STRING LINT_TO_STRING LWORD_TO_STRING SINT_TO_STRING UDINT_TO_STRING UINT_TO_STRING ULINT_TO_STRING USINT_TO_STRING WORD_TO_STRING TIME __UXINT_TO_TIME __XINT_TO_TIME __XWORD_TO_TIME BIT_TO_TIME BYTE_TO_TIME DINT_TO_TIME DWORD_TO_TIME INT_TO_TIME LINT_TO_TIME LWORD_TO_TIME SINT_TO_TIME UDINT_TO_TIME UINT_TO_TIME ULINT_TO_TIME USINT_TO_TIME WORD_TO_TIME TOD __UXINT_TO_TOD __XINT_TO_TOD __XWORD_TO_TOD BIT_TO_TOD BYTE_TO_TOD DINT_TO_TOD DWORD_TO_TOD INT_TO_TOD LINT_TO_TOD LWORD_TO_TOD SINT_TO_TOD UDINT_TO_TOD UINT_TO_TOD ULINT_TO_TOD USINT_TO_TOD WORD_TO_TOD UDINT __UXINT_TO_UDINT __XINT_TO_UDINT __XWORD_TO_UDINT BIT_TO_UDINT BYTE_TO_UDINT DINT_TO_UDINT DWORD_TO_UDINT INT_TO_UDINT LINT_TO_UDINT LWORD_TO_UDINT SINT_TO_UDINT - UINT_TO_UDINT ULINT_TO_UDINT USINT_TO_UDINT WORD_TO_UDINT UINT __UXINT_TO_UINT __XINT_TO_UINT __XWORD_TO_UINT BIT_TO_UINT BYTE_TO_UINT DINT_TO_UINT DWORD_TO_UINT INT_TO_UINT LINT_TO_UINT LWORD_TO_UINT SINT_TO_UINT UDINT_TO_UINT - ULINT_TO_UINT USINT_TO_UINT WORD_TO_UINT ULINT __UXINT_TO_ULINT __XINT_TO_ULINT __XWORD_TO_ULINT BIT_TO_ULINT BYTE_TO_ULINT DINT_TO_ULINT DWORD_TO_ULINT INT_TO_ULINT LINT_TO_ULINT LWORD_TO_ULINT SINT_TO_ULINT UDINT_TO_ULINT UINT_TO_ULINT - USINT_TO_ULINT WORD_TO_ULINT USINT __UXINT_TO_USINT __XINT_TO_USINT __XWORD_TO_USINT BIT_TO_USINT BYTE_TO_USINT DINT_TO_USINT DWORD_TO_USINT INT_TO_USINT LINT_TO_USINT LWORD_TO_USINT SINT_TO_USINT UDINT_TO_USINT UINT_TO_USINT ULINT_TO_USINT - WORD_TO_USINT WORD __UXINT_TO_WORD __XINT_TO_WORD __XWORD_TO_WORD BIT_TO_WORD BYTE_TO_WORD DINT_TO_WORD DWORD_TO_WORD INT_TO_WORD LINT_TO_WORD LWORD_TO_WORD SINT_TO_WORD UDINT_TO_WORD UINT_TO_WORD ULINT_TO_WORD USINT_TO_WORD - WSTRING __UXINT_TO_WSTRING __XINT_TO_WSTRING __XWORD_TO_WSTRING BIT_TO_WSTRING BYTE_TO_WSTRING DINT_TO_WSTRING DWORD_TO_WSTRING INT_TO_WSTRING LINT_TO_WSTRING LWORD_TO_WSTRING SINT_TO_WSTRING UDINT_TO_WSTRING UINT_TO_WSTRING ULINT_TO_WSTRING USINT_TO_WSTRING WORD_TO_WSTRING " }, 
{ "title" : "文字列への変換 ", 
"url" : "_cds_operator_convert_integer.html#UUID-c464d72e-00eb-40f2-a434-5347b8dfb565_UUID-b3638e7b-8068-7a4c-97c9-8f7221718057_id_a4835caebc899e35c0a8640e0071a02e_id_be3e4f6f29f3e031c0a8646345a1318e", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ 変換: 整数 \/ 文字列への変換 ", 
"snippet" : "値を型の文字列に変換する演算子 STRING また WSTRING ターゲットデータ型と一致するオペランドが必要です。...", 
"body" : "値を型の文字列に変換する演算子 STRING また WSTRING ターゲットデータ型と一致するオペランドが必要です。 " }, 
{ "title" : "例 ", 
"url" : "_cds_operator_convert_integer.html#UUID-c464d72e-00eb-40f2-a434-5347b8dfb565_UUID-b3638e7b-8068-7a4c-97c9-8f7221718057_section-idm4556665049587232791080776043", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ 変換: 整数 \/ 例 ", 
"snippet" : "例: 関数ブロック – ConvertIntegers 大きいデータ型が小さいデータ型に変換されると、上位（先頭）のバイトが切り捨てられます。小さいデータ型が大きいデータ型に変換されると、より上位のバイトがゼロで埋められます。 FB_ConvertIntegersFromInt の ST での宣言 FUNCTION_BLOCK FB_ConvertIntegersFromInt VAR uxiReturn: __UXINT; xiReturn: __XINT; xwReturn: __XWORD; bitReturn: BIT; xReturn: BOOL; bReturn: BYTE; da...", 
"body" : "例: 関数ブロック – ConvertIntegers 大きいデータ型が小さいデータ型に変換されると、上位（先頭）のバイトが切り捨てられます。小さいデータ型が大きいデータ型に変換されると、より上位のバイトがゼロで埋められます。 FB_ConvertIntegersFromInt の ST での宣言 FUNCTION_BLOCK FB_ConvertIntegersFromInt\nVAR\n uxiReturn: __UXINT;\n xiReturn: __XINT;\n xwReturn: __XWORD;\n bitReturn: BIT;\n xReturn: BOOL;\n bReturn: BYTE;\n dateReturn: DATE;\n diReturn: DINT;\n dtReturn: DATE_AND_TIME;\n dwReturn: DWORD;\n liReturn: LINT;\n lrReturn: LREAL;\n lwReturn: LWORD;\n siReturn: SINT;\n sReturn: STRING;\n timReturn: TIME;\n todReturn: TIME_OF_DAY;\n udiReturn: UDINT;\n uiReturn: UINT;\n usiReturn: USINT;\n wReturn: WORD;\n wsReturn: WSTRING;\n uliReturn: ULINT;\nEND_VAR FB_ConvertIntegersFromInt の ST での実装 uxiReturn := INT_TO___UXINT(127);\nxiReturn := INT_TO___XINT(127);\nxwReturn := INT_TO___XWORD(127);\nbitReturn := INT_TO_BIT(127);\nxReturn := INT_TO_BOOL(127);\nbReturn := INT_TO_BYTE(127);\ndateReturn := INT_TO_DATE(127);\ndiReturn := INT_TO_DINT(127);\ndtReturn := INT_TO_DT(127);\ndwReturn := INT_TO_DWORD(127);\nliReturn := INT_TO_LINT(127);\nlrReturn := INT_TO_LREAL(127);\nlwReturn := INT_TO_LWORD(127);\nsiReturn := INT_TO_SINT(127);\nsReturn := INT_TO_STRING(127);\ntimReturn := INT_TO_TIME(127);\ntodReturn := INT_TO_TOD(127);\nudiReturn := INT_TO_UDINT(127);\nuiReturn := INT_TO_UINT(127);\nuliReturn := INT_TO_ULINT(127);\nusiReturn := INT_TO_USINT(127);\nwReturn := INT_TO_WORD(127);\nwsReturn := INT_TO_WSTRING(127); FB_ConvertIntegersToInt の ST での宣言 FUNCTION_BLOCK FB_ConvertIntegersToInt\nVAR\n iReturn_uxi: INT;\n iReturn_xi: INT;\n iReturn_xw: INT;\n iReturn_bit: INT;\n iReturn_bool: INT;\n iReturn_b: INT;\n iReturn_d: INT;\n iReturn_di: INT;\n iReturn_dt: INT;\n iReturn_dw: INT;\n iReturn_li: INT;\n iReturn_lr: INT;\n iReturn_lw: INT;\n iReturn_r: INT;\n iReturn_si: INT;\n iReturn_s: INT;\n iReturn_tim: INT;\n iReturn_tod: INT;\n iReturn_tod_0: INT;\n iReturn_udi: INT;\n iReturn_ui: INT;\n iReturn_uli: INT;\n iReturn_usi: INT;\n iReturn_w: INT;\n iReturn_ws: INT;\nEND_VAR\n FB_ConvertIntegersToInt の ST での実装 FUNCTION_BLOCK FB_ConvertIntegersFromInt\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n uxiReturn: __UXINT;\n xiReturn: __XINT;\n xwReturn: __XWORD;\n bitReturn: BIT;\n xReturn: BOOL;\n bReturn: BYTE;\n dateReturn: DATE;\n diReturn: DINT;\n dtReturn: DATE_AND_TIME;\n dwReturn: DWORD;\n liReturn: LINT;\n lrReturn: LREAL;\n lwReturn: LWORD;\n siReturn: SINT;\n sReturn: STRING;\n timReturn: TIME;\n todReturn: TIME_OF_DAY;\n udiReturn: UDINT;\n uiReturn: UINT;\n usiReturn: USINT;\n wReturn: WORD;\n wsReturn: WSTRING;\n uliReturn: ULINT;\nEND_VAR\n\nuxiReturn := INT_TO___UXINT(127);\nxiReturn := INT_TO___XINT(127);\nxwReturn := INT_TO___XWORD(127);\nbitReturn := INT_TO_BIT(127);\nxReturn := INT_TO_BOOL(127);\nbReturn := INT_TO_BYTE(127);\ndateReturn := INT_TO_DATE(127);\ndiReturn := INT_TO_DINT(127);\ndtReturn := INT_TO_DT(127);\ndwReturn := INT_TO_DWORD(127);\nliReturn := INT_TO_LINT(127);\nlrReturn := INT_TO_LREAL(127);\nlwReturn := INT_TO_LWORD(127);\nsiReturn := INT_TO_SINT(127);\nsReturn := INT_TO_STRING(127);\ntimReturn := INT_TO_TIME(127);\ntodReturn := INT_TO_TOD(127);\nudiReturn := INT_TO_UDINT(127);\nuiReturn := INT_TO_UINT(127);\nuliReturn := INT_TO_ULINT(127);\nusiReturn := INT_TO_USINT(127);\nwReturn := INT_TO_WORD(127);\nwsReturn := INT_TO_WSTRING(127);\n\nFUNCTION_BLOCK FB_ConvertIntegersToInt\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iReturn_uxi: INT;\n iReturn_xi: INT;\n iReturn_xw: INT;\n iReturn_bit: INT;\n iReturn_bool: INT;\n iReturn_b: INT;\n iReturn_d: INT;\n iReturn_di: INT;\n iReturn_dt: INT;\n iReturn_dw: INT;\n iReturn_li: INT;\n iReturn_lr: INT;\n iReturn_lw: INT;\n iReturn_r: INT;\n iReturn_si: INT;\n iReturn_s: INT;\n iReturn_tim: INT;\n iReturn_tod: INT;\n iReturn_tod_0: INT;\n iReturn_udi: INT;\n iReturn_ui: INT;\n iReturn_uli: INT;\n iReturn_usi: INT;\n iReturn_w: INT;\n iReturn_ws: INT;\nEND_VAR\n\niReturn_uxi := __UXINT_TO_INT(18446744073709551615);\niReturn_xi := __XINT_TO_INT(9223372036854775807);\niReturn_xw := __XWORD_TO_INT(16#FFFF_FFFF_FFFF_FFFF);\niReturn_bit := BIT_TO_INT(1);\niReturn_bool := BOOL_TO_INT(TRUE);\niReturn_b := BYTE_TO_INT(2#1111_0000);\niReturn_d := DATE_TO_INT(DATE#2019-9-13);\niReturn_di := DINT_TO_INT(2147483647);\niReturn_dt := DT_TO_INT(DT#1979-1-1-00:00:00);\niReturn_dw := DWORD_TO_INT(16#FFFF_FFFF);\n\/\/ iReturn_i := INT_TO_<>(iData_12);\niReturn_li := LINT_TO_INT(9223372036854775807);\niReturn_lr := LREAL_TO_INT(1.7976931348623157E+30);\niReturn_lw := LWORD_TO_INT(16#FFFF_FFFF_FFFF_FFFF);\niReturn_r := REAL_TO_INT(3.402823E+38);\niReturn_si := SINT_TO_INT(127);\niReturn_s := STRING_TO_INT('127');\niReturn_tim := TIME_TO_INT(T#49D17H2M47S295MS);\niReturn_tod := TOD_TO_INT(TOD#23:59:59.999);\niReturn_tod_0 := TOD_TO_INT(TOD#1:1:1.001);\niReturn_udi := UDINT_TO_INT(4294967295);\niReturn_ui := UINT_TO_INT(65535);\niReturn_uli := ULINT_TO_INT(18446744073709551615);\niReturn_usi := USINT_TO_INT(255);\niReturn_w := WORD_TO_INT(16#FFFF);\niReturn_ws := WSTRING_TO_INT(\"1234567890\");\n\nPROGRAM PLC_PRG\nVAR\n fbConvertIntegersFromInt : FB_ConvertIntegersFromInt;\n fbConvertIntegersToInt : FB_ConvertIntegersToInt;\nEND_VAR\n\nfbConvertIntegersFromInt();\nfbConvertIntegersToInt(); 実行 例: FBD での ConvertIntegers " }, 
{ "title" : "変換: REAL、LREAL ", 
"url" : "_cds_operator_real_to.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ 変換: REAL、LREAL ", 
"snippet" : "REAL, LREAL 浮動小数点数がターゲットデータ型の値の範囲内にある場合、変換はすべてのシステムで同じように動作します。 浮動小数点数が範囲制限を超える場合、数値の最初のバイトは考慮されません。 演算子は、浮動小数点数を指定されたデータ型に変換し、型変換された値を返します。該当する場合、変換は四捨五入されます。 の場合 REAL_TO_<ターゲットタイプ> 変換では、値はまず UDINT そして、その後にターゲット タイプにキャストします。 の場合 LREAL_TO_<ターゲットタイプ> 変換では、値はまず ULINT そして、その後にターゲット タイプにキャストします。 呼び出し構文 ...", 
"body" : "REAL, LREAL 浮動小数点数がターゲットデータ型の値の範囲内にある場合、変換はすべてのシステムで同じように動作します。 浮動小数点数が範囲制限を超える場合、数値の最初のバイトは考慮されません。 演算子は、浮動小数点数を指定されたデータ型に変換し、型変換された値を返します。該当する場合、変換は四捨五入されます。 の場合 REAL_TO_<ターゲットタイプ> 変換では、値はまず UDINT そして、その後にターゲット タイプにキャストします。 の場合 LREAL_TO_<ターゲットタイプ> 変換では、値はまず ULINT そして、その後にターゲット タイプにキャストします。 呼び出し構文 : REAL_TO_<ターゲットタイプ>(<オペランド>) 、 LREAL_TO_<ターゲットタイプ>(<オペランド>) オペランド タイプ 説明 変数またはリテラル REAL 、 LREAL REAL、LREALオペレーター： REAL\/LREAL_TO_<target type> オペレーター: REAL オペレーター: LREAL 例 戻り値 REAL_TO___UXINT LREAL_TO___UXINT REAL_TO___UXINT(1.234) LREAL_TO___UXINT(0.987654321) 1 1 __UXINT、__ XINT、__ XWORD REAL_TO___XINT LREAL_TO___XINT __UXINT、__ XINT、__ XWORD REAL_TO___XWORD LREAL_TO___XWORD __UXINT、__ XINT、__ XWORD REAL_TO_BIT LREAL_TO_BIT BIT REAL_TO_BOOL LREAL_TO_BOOL LREAL_TO_BOOL(0.987654321) TRUE BIT REAL_TO_BYTE LREAL_TO_BYTE REAL_TO_BYTE(1.234) LREAL_TO_BYTE(0.987654321) 1 Integer REAL_TO_DATE LREAL_TO_DATE REAL_TO_DATE(1.234) LREAL_TO_DATE(0.987654321) D#1970-1-1 データ型: DATE REAL_TO_DINT LREAL_TO_DINT REAL_TO_DINT(1.234) 1 Integer REAL_TO_DT LREAL_TO_DT REAL_TO_DT(1.234) D#1970-1-1-0:0:1 データ型: DATE REAL_TO_DWORD LREAL_TO_DWORD REAL_TO_DWORD(1.234) 32#1 Integer REAL_TO_INT LREAL_TO_INT REAL_TO_INT(-1.5) -2 Integer REAL_TO_LDATE LREAL_TO_LDATE REAL_TO_LDATE(1.234) DT#1970-1-1 内部的には、まず ULINT 値は日付として返されます。 REAL_TO_LDT LREAL_TO_LDT LREAL_TO_DT(0.987654321) D#1970-1-1-0:0:1 対象データ型: LDATE_AND_TIME データ型: DATE REAL_TO_LINT LREAL_TO_LINT REAL_TO_LINT(1.234) 1 Integer REAL_TO_LTOD LREAL_TO_LTOD データ型: DATE REAL_TO_LREAL - REAL_TO_LREAL(1.234) 1.234 REAL、LREAL REAL_TO_LTIME LREAL_TO_LTIME 内部的には、まず ULINT そして、ns として値が返されます。 データ型: TIME、LTIME REAL_TO_LWORD LREAL_TO_LWORD Integer- LREAL_TO_REAL REAL_TO_SINT LREAL_TO_SINT Integer REAL_TO_STRING LREAL_TO_STRING REAL_TO_STRING(1.234) '1.234' STRING REAL_TO_TIME LREAL_TO_TIME REAL_TO_TIME(1.234) T#1ms 内部的には、最初に ULINT にキャストされ、その後値が ms 単位で返されます。 データ型: TIME、LTIME REAL_TO_TOD LREAL_TO_TOD REAL_TO_TOD(1.234) TOD#0:0:0.001 内部的には、最初に UDINT にキャストされ、その後値が TOD として返されます。 構文: TOD#hh:mm:ss.sss データ型: DATE REAL_TO_UDINT LREAL_TO_UDINT Integer REAL_TO_UINT LREAL_TO_UINT Integer REAL_TO_ULINT LREAL_TO_ULINT Integer REAL_TO_USINT LREAL_TO_USINT Integer REAL_TO__WORD LREAL_TO__WORD REAL_TO_WORD(1.2345678E11) 1 Integer REAL_TO_WSTRING LREAL_TO_WSTRING REAL_TO_WSTRING(1.23456789E11) \"1.234\" WSTRING" }, 
{ "title" : "丸め ", 
"url" : "_cds_operator_real_to.html#UUID-09b58433-72d6-ced4-b25c-4160070bab9d_UUID-66c29c06-37d8-0602-04a7-7b5bcba80db6_id_a34c7ecbeec3bac0a8640e014adbad_id_d62d1f013f678288c0a864631fef9174", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ 変換: REAL、LREAL \/ 丸め ", 
"snippet" : "整数に変換する場合、オペランドは整数値に切り上げまたは切り捨てられます。小数点以下1〜4の場合、数値は切り捨てられます。 5から9の場合、数値は切り上げられます。次に、丸められた数値が指定された整数型に変換されます。丸められた値が整数値の範囲外の場合、未定義のターゲットシステム依存値が返されます。その場合、例外エラーも発生する可能性があります。...", 
"body" : "整数に変換する場合、オペランドは整数値に切り上げまたは切り捨てられます。小数点以下1〜4の場合、数値は切り捨てられます。 5から9の場合、数値は切り上げられます。次に、丸められた数値が指定された整数型に変換されます。丸められた値が整数値の範囲外の場合、未定義のターゲットシステム依存値が返されます。その場合、例外エラーも発生する可能性があります。 " }, 
{ "title" : "文字列への変換 ", 
"url" : "_cds_operator_real_to.html#UUID-09b58433-72d6-ced4-b25c-4160070bab9d_UUID-66c29c06-37d8-0602-04a7-7b5bcba80db6_id_a34c7ecbeec3bac0a8640e014adbad_id_6cad15a820cf3bd8c0a864633b32def9", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ 変換: REAL、LREAL \/ 文字列への変換 ", 
"snippet" : "浮動小数点数を文字列に変換する場合、仮数の小数点以下の桁数は6に制限されます。数値が1未満の場合、仮数は次のようになります。 1 <= m < 10 。仮数の桁数がコンマの後にある場合は、6桁目に丸められてから、変換されます。 文字列変数は、戻り値に対して短すぎると宣言される場合もあります。この場合、戻り文字列は右側で切り捨てられます。 例...", 
"body" : "浮動小数点数を文字列に変換する場合、仮数の小数点以下の桁数は6に制限されます。数値が1未満の場合、仮数は次のようになります。 1 <= m < 10 。仮数の桁数がコンマの後にある場合は、6桁目に丸められてから、変換されます。 文字列変数は、戻り値に対して短すぎると宣言される場合もあります。この場合、戻り文字列は右側で切り捨てられます。 例 " }, 
{ "title" : "変換: STRING、WSTRING ", 
"url" : "_cds_operator_string_to.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ 変換: STRING、WSTRING ", 
"snippet" : "STRING, WSTRING 演算子は文字列を変換します（ STRING また WSTRING ）指定されたターゲットデータ型に変換し、型変換された値を返します。 意味のある結果をもたらす変換は、オペランドがIEC61131-3規格に準拠したターゲットデータ型と一致する場合にのみ可能です。これは、オペランドの値がターゲットデータ型の有効な定数（リテラル）に対応する場合に当てはまります。 変換可能な文字列には次のものが含まれます。 タイププレフィックス付きの番号（例： '16#FFFFFFFF' ）。 グループ化文字付きの番号（例： '2#1111_1111' ）。 注：国際的な重みとメジャー...", 
"body" : "STRING, WSTRING 演算子は文字列を変換します（ STRING また WSTRING ）指定されたターゲットデータ型に変換し、型変換された値を返します。 意味のある結果をもたらす変換は、オペランドがIEC61131-3規格に準拠したターゲットデータ型と一致する場合にのみ可能です。これは、オペランドの値がターゲットデータ型の有効な定数（リテラル）に対応する場合に当てはまります。 変換可能な文字列には次のものが含まれます。 タイププレフィックス付きの番号（例： '16#FFFFFFFF' ）。 グループ化文字付きの番号（例： '2#1111_1111' ）。 注：国際的な重みとメジャーのグループ化文字（シンスペース）は受け入れられません。アンダースコアのみが受け入れられます。 浮動小数点数、これも指数表記（例： '9.876' また '1.2E-34' ）。 注：浮動小数点数は変換できません。カンマは次の文字のように扱われ、切り捨てられます。 プレフィックスとサイズを使用した時刻、時刻、および日付の指定（例： 'T#2h' 、 'DT#2019-9-9-12:30:30.9' ）。 無限の値（例： '1.7E+400' ）。 追加のキャラクター 後 数字（例： '2m' また '3.14' ）。 これらは切り捨てられます。追加の文字 前 番号は許可されていません。 前のスペース（例： '3.14' ）。 呼び出し構文 : STRING_TO_<ターゲットタイプ>(<オペランド>) 、 WSTRING_TO_<ターゲットタイプ>(<オペランド>) オペランド データタイプ 説明 変数またはリテラル STRING 、 WSTRING STRING, WSTRINGキャスト演算子: STRING\/WSTRING_TO_<target type> 演算子: STRING 演算子: WSTRING 例 戻り値 説明  STRING_TO___UXINT WSTRING_TO___UXINT __UXINT、__ XINT、__ XWORD  STRING_TO___XINT WSTRING_TO___XINT __UXINT、__ XINT、__ XWORD  STRING_TO___XWORD WSTRING_TO___XWORD __UXINT、__ XINT、__ XWORD  STRING_TO_BIT WSTRING_TO_BIT BIT STRING_TO_BOOL WSTRING_TO_BOOL STRING_TO_BOOL('TRUE') STRING_TO_BOOL('true') WSTRING_TO_BOOL(\"TRUE\") WSTRING_TO_BOOL(\"true\") TRUE BOOL STRING_TO_BYTE WSTRING_TO_BYTE Integer STRING_TO_DATE WSTRING_TO_DATE STRING_TO_DATE('DATE#2019-9-9') WSTRING_TO_DATE(\"DATE#2019-9-9\") D#2019-9-9 構文： D#yyyy-MM-dd データ型: DATE STRING_TO_DINT WSTRING_TO_DINT 出力データ型が大きい場合、情報が失われる可能性があります。 Integer STRING_TO_DT WSTRING_TO_DT STRING_TO_DT('DT#2019-9-9-1:1:1.1') WSTRING_TO_DT(\"DT#2019-9-9-1:1:1.1\") DT#2019-9-9-1:1:1 DT#2019-9-9-1:1:1 構文： DT#yyyy-MM-dd-hh:mm:ss データ型: DATE STRING_TO_DWORD WSTRING_TO_DWORD Integer STRING_TO_INT WSTRING_TO_INT STRING_TO_INT('123abc') WSTRING_TO_INT(\"123abc\") 123 Integer STRING_TO_LDATE WSTRING_TO_LDATE 構文： LDATE#yyyy-MM-dd 日付のみ表示されます。 データ型: DATE STRING_TO_LDT WSTRING_TO_LDT 構文： LDT#yyyy-MM-dd-hh:mm:ss.sss データ型: DATE STRING_TO_LINT WSTRING_TO_LINT Integer STRING_TO_LREAL WSTRING_TO_LREAL STRING_TO_LREAL('1.7E+308') WSTRING_TO_LREAL(\"1.7E+308\") 1.7000000000000001E+308 REAL、LREAL STRING_TO_LTIME WSTRING_TO_LTIME STRING_TO_LTIME('LTIME#709ms551us615ns') STRING_TO_LTIME('LTIME#1ms') WSTRING_TO_LTIME(\"LTIME#1ms\") LTIME#709ms551us615ns LTIME#1ms データ型: TIME、LTIME STRING_TO_LTOD WSTRING_TO_LTOD 構文： LTOD#hh:mm:ss.sssssssss データ型: DATE STRING_TO_LWORD WSTRING_TO_LWORD STRING_TO_LWORD('16#0123456789ABCDEF') WSTRING_TO_LWORD(\"16#0123456789ABCDEF\") 81985529216486895 Integer STRING_TO_REAL WSTRING_TO_REAL STRING_TO_REAL('1.234') WSTRING_TO_REAL(\"1.234\") 1.234 より大きな値の範囲から変換する場合、情報が失われたり、未定義の結果が返されたりする可能性があります。 REAL、LREAL STRING_TO_SINT WSTRING_TO_SINT Integer- WSTRING_TO_STRING WSTRING_TO_STRING(\"Hello World!\") Hello World! STRING_TO_TIME WSTRING_TO_TIME STRING_TO_TIME('T#5d4h3m2s') WSTRING_TO_TIME(\"T#5d4h3m2s\") T#5d4h3m2s データ型: TIME、LTIME STRING_TO_TOD WSTRING_TO_TOD STRING_TO_TOD('TOD#20:15') WSTRING_TO_TOD(\"TOD#20:15\") TOD#20:15:0 データ型: DATE STRING_TO_UDINT WSTRING_TO_UDINT Integer STRING_TO_UINT WSTRING_TO_UINT Integer STRING_TO_ULINT WSTRING_TO_ULINT STRING_TO_ULINT('615') WSTRING_TO_ULINT(\"615\") 615 Integer STRING_TO_USINT WSTRING_TO_USINT Integer STRING_TO_WORD WSTRING_TO_WORD Integer STRING_TO_WSTRING - STRING_TO_WSTRING('Hello World!') \"Hello World!\" WSTRING" }, 
{ "title" : "ブール値への変換 ", 
"url" : "_cds_operator_string_to.html#UUID-5ac2f0be-631a-851c-bdec-0e60611c4db1_UUID-fa2f799f-42c9-2838-9daf-a4b39b9aca2c_id_f500d27d07eb3bec0a8640e013e049a_id_7a13d4613f6786bbc0a864632e419b0d", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ 変換: STRING、WSTRING \/ ブール値への変換 ", 
"snippet" : "オペレーター STRING_TO_BOOL ：の値 TRUE オペランド値が 'TRUE' また 'true' 。一方で、 FALSE のために返されます 'True' 。 オペレーター WSTRING_TO_BOOL ：の値 TRUE オペランド値が \"TRUE\" また \"true\" 。一方で、 FALSE のために返されます \"True\" 。...", 
"body" : "オペレーター STRING_TO_BOOL ：の値 TRUE オペランド値が 'TRUE' また 'true' 。一方で、 FALSE のために返されます 'True' 。 オペレーター WSTRING_TO_BOOL ：の値 TRUE オペランド値が \"TRUE\" また \"true\" 。一方で、 FALSE のために返されます \"True\" 。 " }, 
{ "title" : "例 ", 
"url" : "_cds_operator_string_to.html#UUID-5ac2f0be-631a-851c-bdec-0e60611c4db1_UUID-fa2f799f-42c9-2838-9daf-a4b39b9aca2c_id_f500d27d07eb3bec0a8640e013e049a_id_817822c5d48a11e9a9c394579cee6999", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ 変換: STRING、WSTRING \/ 例 ", 
"snippet" : "FB_文字列変換 宣言 FUNCTION_BLOCK FB_ConvertStrings VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR xReturn_0: BOOL; xReturn_1: BOOL; dateReturn: DATE; dtReturn: DATE_AND_TIME; iReturn: INT; lrReturn: LREAL; lrReturn_0: LREAL; lwReturn: LWORD; lwReturn_0: LWORD; lwReturn_1: LWORD; ltReturn: LTIME; ltReturn_0: LTI...", 
"body" : "FB_文字列変換 宣言 FUNCTION_BLOCK FB_ConvertStrings\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n\t xReturn_0: BOOL;\n\txReturn_1: BOOL;\n\tdateReturn: DATE;\n\tdtReturn: DATE_AND_TIME;\n\tiReturn: INT;\n\tlrReturn: LREAL;\n\tlrReturn_0: LREAL;\n\tlwReturn: LWORD;\n\tlwReturn_0: LWORD;\n\tlwReturn_1: LWORD;\n\tltReturn: LTIME;\n\tltReturn_0: LTIME;\n\tltReturn_1: LTIME;\n\tltReturn_2: LTIME;\n\trReturn: REAL;\n\trReturn_0: REAL;\n\ttimReturn: TIME;\n\ttimReturn0: TIME;\n\ttimReturn1: TIME;\n\ttimReturn2: TIME;\n\ttodReturn: TIME_OF_DAY;\n\ttodReturn0: TIME_OF_DAY;\n\ttodReturn1: TIME_OF_DAY;\n\ttodReturn2: TIME_OF_DAY;\n\tuliReturn: ULINT;\n\tuliReturn_0: ULINT;\n\tuliReturn_1: ULINT;\n\twReturn: WORD;\n\twReturn_0: WORD;\n\twReturn_1: WORD;\n\twstrReturn: WSTRING;\n\twstrReturn_0: WSTRING;\n\tdtReturn2: DATE_AND_TIME;\nEND_VAR 実装 FUNCTION_BLOCK FB_ConvertStrings\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n xReturn_0: BOOL;\n xReturn_1: BOOL;\n dateReturn: DATE;\n dtReturn: DATE_AND_TIME;\n iReturn: INT;\n lrReturn: LREAL;\n lrReturn_0: LREAL;\n lwReturn: LWORD;\n lwReturn_0: LWORD;\n lwReturn_1: LWORD;\n ltReturn: LTIME;\n ltReturn_0: LTIME;\n ltReturn_1: LTIME;\n ltReturn_2: LTIME;\n rReturn: REAL;\n rReturn_0: REAL;\n timReturn: TIME;\n timReturn0: TIME;\n timReturn1: TIME;\n timReturn2: TIME;\n todReturn: TIME_OF_DAY;\n todReturn0: TIME_OF_DAY;\n todReturn1: TIME_OF_DAY;\n todReturn2: TIME_OF_DAY;\n uliReturn: ULINT;\n uliReturn_0: ULINT;\n uliReturn_1: ULINT;\n wReturn: WORD;\n wReturn_0: WORD;\n wReturn_1: WORD;\n wstrReturn: WSTRING;\n wstrReturn_0: WSTRING;\nEND_VAR\nxReturn_0 := STRING_TO_BOOL('FALSE');\nxReturn_1 := STRING_TO_BOOL('TRUE');\ndateReturn := STRING_TO_DATE('DATE#2019-9-9');\ndtReturn := STRING_TO_DT('DT#2019-9-9-1:1:1.1');\niReturn := STRING_TO_INT('123abc');\nlrReturn := STRING_TO_LREAL('4.94E-323');\nlrReturn_0 := STRING_TO_LREAL('1.7E+308');\nlwReturn := STRING_TO_LWORD('16#FFFF_FFFF_FFFF_FFFF');\nlwReturn_0 := STRING_TO_LWORD('16#0123456789ABCDEF');\nlwReturn_1 := STRING_TO_LWORD('16#0123456789ABCDEF');\nltReturn := STRING_TO_LTIME('LTIME#213503d23h34m33s709ms551us615ns');\nltReturn_0 := STRING_TO_LTIME('LTIME#0ns');\nltReturn_1 := STRING_TO_LTIME('LTIME#1ms');\nltReturn_2 := STRING_TO_LTIME('LTIME#2s');\nrReturn := STRING_TO_REAL('6.543e21');\nrReturn_0 := STRING_TO_REAL('1.234');\ntimReturn := STRING_TO_TIME('T#5d4h3m2s');\ntimReturn0 := STRING_TO_TIME('TIME#1s');\ntimReturn1 := STRING_TO_TIME('1s');\ntimReturn2 := STRING_TO_TIME('TIME#5s');\ntodReturn := STRING_TO_TOD('TOD#12:0:0.1');\ntodReturn0 := STRING_TO_TOD('TOD#0:0:0.0');\ntodReturn1 := STRING_TO_TOD('20:15');\ntodReturn2 := STRING_TO_TOD('TOD#20:15');\nuliReturn := STRING_TO_ULINT('18446744073709551615');\nuliReturn_0 := STRING_TO_ULINT('1');\nuliReturn_1 := STRING_TO_ULINT('0');\nwReturn := STRING_TO_WORD('16#FFFF_0000');\nwReturn_0 := STRING_TO_WORD('34abc');\nwReturn_1 := STRING_TO_WORD('16#34abc');\nwstrReturn := STRING_TO_WSTRING('Hello World!');\nwstrReturn_0 := STRING_TO_WSTRING('123456789'); ST の FB_ConvertWstrings 宣言 FUNCTION_BLOCK FB_ConvertWstrings\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n\txReturn_0: BOOL;\n\txReturn_1: BOOL;\n\tdateReturn: DATE;\n\tdtReturn: DATE_AND_TIME;\n\tiReturn: INT;\n\tlrReturn: LREAL;\n\tlrReturn_0: LREAL;\n\tlwReturn: LWORD;\n\tlwReturn_0: LWORD;\n\tlwReturn_1: LWORD;\n\tltReturn: LTIME;\n\tltReturn_0: LTIME;\n\tltReturn_1: LTIME;\n\tltReturn_2: LTIME;\n\trReturn: REAL;\n\trReturn_0: REAL;\n\ttimReturn: TIME;\n\ttimReturn0: TIME;\n\ttimReturn1: TIME;\n\ttimReturn2: TIME;\n\ttodReturn: TIME_OF_DAY;\n\ttodReturn0: TIME_OF_DAY;\n\ttodReturn1: TIME_OF_DAY;\n\ttodReturn2: TIME_OF_DAY;\n\tuliReturn: ULINT;\n\tuliReturn_0: ULINT;\n\tuliReturn_1: ULINT;\n\twReturn: WORD;\n\twReturn_0: WORD;\n\twReturn_1: WORD;\n\twstrReturn: WSTRING;\n\twstrReturn_0: WSTRING;\nEND_VAR\n STでの実装 FUNCTION_BLOCK FB_ConvertWstrings\nVAR\n xReturn_0: BOOL;\n xReturn_1: BOOL;\n dateReturn: DATE;\n dtReturn: DATE_AND_TIME;\n iReturn: INT;\n lrReturn: LREAL;\n lrReturn_0: LREAL;\n lwReturn: LWORD;\n lwReturn_0: LWORD;\n lwReturn_1: LWORD;\n ltReturn: LTIME;\n ltReturn_0: LTIME;\n ltReturn_1: LTIME;\n ltReturn_2: LTIME;\n rReturn: REAL;\n rReturn_0: REAL;\n timReturn: TIME;\n timReturn0: TIME;\n timReturn1: TIME;\n timReturn2: TIME;\n todReturn: TIME_OF_DAY;\n todReturn0: TIME_OF_DAY;\n todReturn1: TIME_OF_DAY;\n todReturn2: TIME_OF_DAY;\n uliReturn: ULINT;\n uliReturn_0: ULINT;\n uliReturn_1: ULINT;\n wReturn: WORD;\n wReturn_0: WORD;\n wReturn_1: WORD;\n wstrReturn: WSTRING;\n wstrReturn_0: WSTRING;\nEND_VAR\n\nxReturn_0 := WSTRING_TO_BOOL(\"FALSE\");\nxReturn_1 := WSTRING_TO_BOOL(\"TRUE\");\ndateReturn := WSTRING_TO_DATE(\"DATE#2019-9-9\");\ndtReturn := WSTRING_TO_DT(\"DT#2019-9-9-1:1:1.1\");\niReturn := WSTRING_TO_INT(\"123abc\");\nlrReturn := WSTRING_TO_LREAL(\"4.94E-323\");\nlrReturn_0 := WSTRING_TO_LREAL(\"1.7E+308\");\nlwReturn := WSTRING_TO_LWORD(\"16#FFFF_FFFF_FFFF_FFFF\");\nlwReturn_0 := WSTRING_TO_LWORD(\"16#0123456789ABCDEF\");\nlwReturn_1 := WSTRING_TO_LWORD(\"16#0123456789ABCDEF\");\nltReturn := WSTRING_TO_LTIME(\"LTIME#213503d23h34m33s709ms551us615ns\");\nltReturn_0 := WSTRING_TO_LTIME(\"LTIME#0ns\");\nltReturn_1 := WSTRING_TO_LTIME(\"LTIME#1ms\");\nltReturn_2 := WSTRING_TO_LTIME(\"LTIME#2s\");\nrReturn := WSTRING_TO_REAL(\"6.543e21\");\nrReturn_0 := WSTRING_TO_REAL(\"1.234\");\ntimReturn := WSTRING_TO_TIME(\"T#5d4h3m2s\");\ntimReturn0 := WSTRING_TO_TIME(\"TIME#1s\");\ntimReturn1 := WSTRING_TO_TIME(\"1s\");\ntimReturn2 := WSTRING_TO_TIME(\"TIME#5s\");\ntodReturn := WSTRING_TO_TOD(\"TOD#12:0:0.1\");\ntodReturn0 := WSTRING_TO_TOD(\"TOD#0:0:0.0\");\ntodReturn1 := WSTRING_TO_TOD(\"20:15\");\ntodReturn2 := WSTRING_TO_TOD(\"TOD#20:15\");\nuliReturn := WSTRING_TO_ULINT(\"18446744073709551615\");\nuliReturn_0 := WSTRING_TO_ULINT(\"1\");\nuliReturn_1 := WSTRING_TO_ULINT(\"0\");\nwReturn := WSTRING_TO_WORD(\"16#FFFF_0000\");\nwReturn_0 := WSTRING_TO_WORD(\"34abc\");\nwReturn_1 := WSTRING_TO_WORD(\"16#34abc\"); FBD実装言語 " }, 
{ "title" : "時間変換 ", 
"url" : "_cds_operator_time_to.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ 時間変換 ", 
"snippet" : "TIME, LTIME 演算子は時間値を変換します（ TIME また LIME ）を指定されたデータ型に変換し、この型変換された値を返します。 呼び出し構文 : <TIME_TO<ターゲットタイプ> ( <オペランド> ) 、 <LTIME_TO<ターゲットタイプ> ( <オペランド> ) オペランド データタイプ 説明 変数またはリテラル TIME 、 LTIME データ型: TIME、LTIMEキャスト演算子: TIME\/LTIME_TO_<ターゲット タイプ> オペレーター オペレーター 例 戻り値 説明 TIME_TO___UXINT LTIME_TO___UXINT __UXINT、...", 
"body" : "TIME, LTIME 演算子は時間値を変換します（ TIME また LIME ）を指定されたデータ型に変換し、この型変換された値を返します。 呼び出し構文 : <TIME_TO<ターゲットタイプ> ( <オペランド> ) 、 <LTIME_TO<ターゲットタイプ> ( <オペランド> ) オペランド データタイプ 説明 変数またはリテラル TIME 、 LTIME データ型: TIME、LTIMEキャスト演算子: TIME\/LTIME_TO_<ターゲット タイプ> オペレーター オペレーター 例 戻り値 説明 TIME_TO___UXINT LTIME_TO___UXINT __UXINT、__ XINT、__ XWORD TIME_TO___XINT LTIME_TO___XINT __UXINT、__ XINT、__ XWORD TIME_TO___XWORD LTIME_TO___XWORD __UXINT、__ XINT、__ XWORD TIME_TO_BIT LTIME_TO_BIT BIT TIME_TO_BOOL LTIME_TO_BOOL TIME_TO_BOOL(T#0MS);\nTIME_TO_BOOL(T#59ms);\nLTIME_TO_BOOL(T#0MS);\nLTIME_TO_BOOL(T#59ms); FALSE TRUE 演算子は FALSE オペランド値が「0」として解釈できる場合に限ります。 BOOL TIME_TO_BYTE LTIME_TO_BYTE Integer TIME_TO_DATE LTIME_TO_DATE LTIME_TO_DATE(LTIME#2us1ns); D#1970-1-1 構文: D#yyyy-MM-dd データ型: DATE TIME_TO_DINT LTIME_TO_DINT TIME_TO_DT LTIME_TO_DT TIME_TO_DT(T#5d4h3m2s1ms);\nLTIME_TO_DT(LTIME#2us1ns); D#1970-1-1-0:0:0.000000012 構文: DT#yyyy-MM-dd-hh:mm:ss データ型: DATE TIME_TO_DWORD LTIME_TO_DWORD Integer TIME_TO_INT LTIME_TO_INT LTIME_TO_INT(LTIME#2us1ns); 0 Integer TIME_TO_LDATE LTIME_TO_LDATE 構文: LDATE#yyyy-MM-dd データ型: DATE TIME_TO_LDT LTIME_TO_LDT 構文： LDT#yyyy-MM-dd-hh:mm:ss.sss データ型: DATE TIME_TO_LINT LTIME_TO_LINT Integer TIME_TO_LREAL LTIME_TO_LREAL TIME_TO_LREAL(T#5d4h3m2s1ms); x.x TIME_TO_LTIME - TIME_TO_LTOD LTIME_TO_LTOD 構文： LTOD#hh:mm:ss.sssssssss データ型: DATE TIME_TO_LWORD LTIME_TO_LWORD TIME_TO_LWORD(T#5d4h3m2s1ms);\nLTIME_TO_LWORD(LTIME#2us1ns); 0 Integer TIME_TO_REAL LTIME_TO_REAL TIME_TO_REAL(T#1d2h3m4s5ms);\nLTIME_TO_REAL(LTIME#2us1ns); 9.28E+07 0.0 REAL、LREAL TIME_TO_SINT LTIME_TO_SINT Integer TIME_TO_STRING LTIME_TO_STRING TIME_TO_STRING(T#0MS); 'T#0MS' 重要: 入力された値は文字列として左揃えされ、長すぎる場合は切り捨てられます。したがって、戻り変数は、操作しなくても文字列に十分なスペースが確保される長さで宣言してください。 STRING- LTIME_TO_TIME LTIME_TO_TIME(LTIME#2us1ns); T#0ms データ型: TIME、LTIME TIME_TO_TOD LTIME_TO_TOD TIME_TO_TOD(T#1d2h3m4s5ms);\nLTIME_TO_TOD(LTIME#2us1ns);\n TOD#2:3:4.005 TOD#0:0:0 データ型: DATE TIME_TO_UDINT LTIME_TO_UDINT Integer TIME_TO_UINT LTIME_TO_UINT Integer TIME_TO_ULINT LTIME_TO_ULINT TIME_TO_ULINT(T#1d2h3m4s5ms); 93784005 Integer TIME_TO_USINT LTIME_TO_USINT Integer TIME_TO_WORD LTIME_TO_WORD Integer TIME_TO_WSTRING LTIME_TO_WSTRING TIME_TO_WSTRING(T#1d2h3m4s5ms);\nLTIME_TO_WSTRING(T#0US); \"T1d2h3m4s5ms\" \"T#0US\" 入力された値は文字列として左揃えされ、長すぎる場合は切り捨てられます。したがって、戻り変数は、操作しなくても文字列に十分なスペースがあるように十分な長さで宣言してください。 WSTRING" }, 
{ "title" : "例 ", 
"url" : "_cds_operator_time_to.html#UUID-d9d61e4b-1f08-f156-98e7-b50526508425_UUID-05a4d27d-06ae-5b64-4c72-be0a87863b24_id_f415c6acc0350d7c0a8640e00547f10_id_3dd96edd20dc20dcc0a8646366ed7fd7", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ 時間変換 \/ 例 ", 
"snippet" : "ST実装言語 STでの宣言 FUNCTION_BLOCK FB_ConvertTimeAndDate VAR ltReturn_1: LTIME; lwReturn_2: LWORD; rReturn_3: REAL; strReturn_4: STRING; timReturn_5: TIME; todReturn_6: TIME_OF_DAY; uliReurn_7: ULINT; wstrReturn_8: WSTRING; wstrReturn_80: WSTRING; uliReurn_70: ULINT; todReturn_60: TIME_OF_DAY; timReturn_5...", 
"body" : "ST実装言語 STでの宣言 FUNCTION_BLOCK FB_ConvertTimeAndDate\nVAR\n ltReturn_1: LTIME;\n lwReturn_2: LWORD;\n rReturn_3: REAL;\n strReturn_4: STRING;\n timReturn_5: TIME;\n todReturn_6: TIME_OF_DAY;\n uliReurn_7: ULINT;\n wstrReturn_8: WSTRING;\n wstrReturn_80: WSTRING;\n uliReurn_70: ULINT;\n todReturn_60: TIME_OF_DAY;\n timReturn_50: TIME;\n strReturn_40: STRING;\n rReturn_30: REAL;\n lwReturn_20: LWORD;\n ltReturn_10: LTIME;\n ltReturn_11: LTIME;\n lwReturn_21: LWORD;\n rReturn_31: REAL;\n strReturn_41: STRING;\n timReturn_51: TIME;\n todRedurn_61: TIME_OF_DAY;\n uliReurn_71: ULINT;\n wstrReturn_81: WSTRING;\n ltReturn_12: LTIME;\n xReturn_9: BOOL;\n xReturn_90: BOOL;\n xReturn_91: BOOL;\n xReturn_92: BOOL;\n dateReturn_6: DATE;\n timReturn_60: TIME;\n wReturn_61: WORD;\n todReturn_61: TIME_OF_DAY;\nEND_VAR\n STでの実装 FUNCTION_BLOCK FB_ConvertTimeAndDate\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n ltReturn_1: LTIME;\n lwReturn_2: LWORD;\n rReturn_3: REAL;\n strReturn_4: STRING;\n timReturn_5: TIME;\n todReturn_6: TIME_OF_DAY;\n uliReurn_7: ULINT;\n wstrReturn_8: WSTRING;\n wstrReturn_80: WSTRING;\n uliReurn_70: ULINT;\n todReturn_60: TIME_OF_DAY;\n timReturn_50: TIME;\n strReturn_40: STRING;\n rReturn_30: REAL;\n lwReturn_20: LWORD;\n ltReturn_10: LTIME;\n ltReturn_11: LTIME;\n lwReturn_21: LWORD;\n rReturn_31: REAL;\n strReturn_41: STRING;\n timReturn_51: TIME;\n todRedurn_61: TIME_OF_DAY;\n uliReurn_71: ULINT;\n wstrReturn_81: WSTRING;\n ltReturn_12: LTIME;\n xReturn_9: BOOL;\n xReturn_90: BOOL;\n xReturn_91: BOOL;\n xReturn_92: BOOL;\n dateReturn_6: DATE;\n timReturn_60: TIME;\n wReturn_61: WORD;\n todReturn_61: TIME_OF_DAY;\nEND_VAR\n\nltReturn_1 := DT_TO_LTIME(DT#2019-9-9-23:59:59);\nltReturn_10 := DT_TO_LTIME(DT#1970-1-1-0:0:0);\nltReturn_11 := DT_TO_LTIME(DT#1970-1-2-0:0:1);\nltReturn_12 := DT_TO_LTIME(DT#1970-1-3-12:30:30);\n\nlwReturn_2 := TIME_TO_LWORD(T#5D4H2M3S2MS);\nlwReturn_20 := TIME_TO_LWORD(T#0D0H0M0S0MS);\n\nrReturn_3 := TIME_TO_REAL(T#5D4H2M3S2MS);\nrReturn_30 := TIME_TO_REAL(T#0D0H0M0S0MS);\n\nstrREturn_4 := TIME_TO_STRING(T#5D4H2M3S2MS);\nstrREturn_40 := TIME_TO_STRING(T#0D0H0M0S0MS);\n\ntimReturn_5 := TOD_TO_TIME(TOD#23:59:59.999);\ntimReturn_50 := TOD_TO_TIME(TOD#0:0:0.000);\ntimReturn_51 := TOD_TO_TIME(TOD#0:0:0.001);\n\ndateReturn_6 := TOD_TO_DATE(TOD#23:59:59.999);\ntimReturn_60 := TOD_TO_TIME(TOD#0:0:0.000);\nwReturn_61 := TOD_TO_WORD(TOD#0:0:0.001);\n\nuliReurn_7 := DATE_TO_ULINT(D#2019-9-9);\nuliReurn_70 := DATE_TO_ULINT(D#1970-1-1);\nuliReurn_71 := DATE_TO_ULINT(D#1970-1-2);\n\nwstrReturn_8 := DATE_TO_WSTRING(D#2019-9-9);\nwstrReturn_80 := DATE_TO_WSTRING(D#1970-1-1);\nwstrReturn_81 := DATE_TO_WSTRING(D#1970-1-2);\n\nxReturn_9 := DATE_TO_BOOL(D#2019-9-9);\nxReturn_90 := DATE_TO_BOOL(D#1970-1-1);\nxReturn_91 := DATE_TO_BOOL(D#1970-1-2);\nxReturn_92 := DATE_TO_BOOL(D#1970-1-3); FBD実装言語 " }, 
{ "title" : "変換: DATE、DT、TOD、LDATE、LDT、LTOD ", 
"url" : "_cds_operator_date_to.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ 変換: DATE、DT、TOD、LDATE、LDT、LTOD ", 
"snippet" : "DATE, DT, TOD, LDATE, LDT, LTOD 演算子は、日付と時刻の値を指定されたデータ型に変換し、型変換された値を返します。 データ型 DATE と DT 内部で同じメモリ形式を使用し、として保存されます DWORD 。の解決策 DATE 1日です。の解決策 DT 1秒です。どちらも1970年1月1日から始まります。 TOD として保存されます DWORD 1ミリ秒の分解能で。 キーワード DT そして TOD データ型の代替スペルである DATE_AND_TIME そして TIME_OF_DAY ただし、後者は型変換コマンドとしてマッピングされません。 データ型 LDAT...", 
"body" : "DATE, DT, TOD, LDATE, LDT, LTOD 演算子は、日付と時刻の値を指定されたデータ型に変換し、型変換された値を返します。 データ型 DATE と DT 内部で同じメモリ形式を使用し、として保存されます DWORD 。の解決策 DATE 1日です。の解決策 DT 1秒です。どちらも1970年1月1日から始まります。 TOD として保存されます DWORD 1ミリ秒の分解能で。 キーワード DT そして TOD データ型の代替スペルである DATE_AND_TIME そして TIME_OF_DAY ただし、後者は型変換コマンドとしてマッピングされません。 データ型 LDATE そして LDT そして LTOD 64ビットメモリフォーマットを使用する LWORD 内部的に。 呼び出し構文 : DATE\/DT\/TOD_TO_< ターゲットタイプ> ( <オペランド> ) 呼び出し構文 : LDATE\/LDT\/LTOD_TO_< ターゲットタイプ> ( <オペランド> ) オペランド データタイプ 説明 変数またはリテラル DATE | DATE_AND_TIME | DT | TIME_OF_DAY | TOD LDATE | LDATE_AND_TIME | LDT | LTIME_OF_DAY | LTOD データ型: DATE演算子: DATE\/DT\/TOD_TO_<ターゲット タイプ> DATE_TO_<タイプ> DT_TO_<タイプ> TOD_TO_<タイプ> 例 戻り値 説明 DATE_TO___UXINT DT_TO___UXINT TOD_TO___XINT __UXINT、__ XINT、__ XWORD DATE_TO___XINT DT_TO___XINT TOD_TO___XINT __UXINT、__ XINT、__ XWORD DATE_TO___XWORD DT_TO___XWORD TOD_TO___XWORD __UXINT、__ XINT、__ XWORD DATE_TO_BIT DT_TO_BIT TOD_TO_BIT BIT DATE_TO_BOOL DT_TO_BOOL TOD_TO_BOOL DATE_TO_BOOL(D#1970-1-1)\nDATE_TO_BOOL(D#2019-9-1)\nDT_TO_BOOL(DT#1970-1-1-0:0:0)\nDT_TO_BOOL(DT#2019-9-1-12:0:0)\nTOD_TO_BOOL(TOD#0:0:0)\nTOD_TO_BOOL(TOD#12:0:0)\n FALSE TRUE FALSE TRUE FALSE TRUE オペランド値が「0」と解釈できる場合のみ、演算子は FALSE 。 BOOL DATE_TO_BYTE DT_TO_BYTE DTOD_TO_BYTE Integer- DT_TO_DATE TOD_TO_DATE 秒単位の解像度（ただし、表示されるのは日のみ） DATE_TO_DINT DT_TO_DINT TOD_TO_DINT DATE_TO_DINT(D#1970-1-1)\nDATE_TO_DINT(D#1970-1-2)\nDATE_TO_DINT(D#2019-9-1)\nDT_TO_DINT(DT#1970-1-1-0:0:0)\nDT_TO_DINT(DT#1970-1-1-0:0:1)\nDT_TO_DINT(DT#2019-9-1-12:0:0.0)\nTOD_TO_DINT(TOD#0:0:0)\nTOD_TO_DINT(TOD#12:0:0)\n 0 86400 1567339200 0 1 1567339200 0 43200000 Integer DATE_TO_DT - TOD_TO_DT データ型: DATE DATE_TO_DWORD DT_TO_DWORD TOD_TO_DWORD Integer DATE_TO_INT DT_TO_INT TOD_TO_INT Integer DATE_TO_LDATE DT_TO_LDATE TOD_TO_LDATE データ型: DATE DATE_TO_LDT DT_TO_LDT TOD_TO_LDT データ型: DATE DATE_TO_LINT DT_TO_LINT TOD_TO_LINT Integer DATE_TO_LREAL DT_TO_LREAL TOD_TO_LREAL REAL、LREAL DATE_TO_LTIME DT_TO_LTIME TOD_TO_LTIME データ型: DATE DATE_TO_LTOD DT_TO_LTOD TOD_TO_LTOD データ型: DATE DATE_TO_LWORD DT_TO_LWORD TOD_TO_LWORD Integer DATE_TO_REAL DT_TO_REAL TOD_TO_REAL REAL、LREAL DATE_TO_SINT DT_TO_SINT TOD_TO_SINT Integer DATE_TO_STRING DT_TO_STRING TOD_TO_STRING DATE_TO_STRING(D#1970-1-1)\nDT_TO_STRING(D#1970-1-1-0:0:1)\nTOD_TO_STRING(12:0:1) 'D#1970-1-1' 'D#1970-1-1-0:0:1' 'TOD#12:0:1' STRING DATE_TO_TIME DT_TO_TIME TOD_TO_TIME データ型: DATE DATE_TO_TOD DT_TO_TOD - データ型: DATE DATE_TO_UDINT DT_TO_UDINT TOD_TO_UDINT Integer DATE_TO_UINT DT_TO_UINT TOD_TO_UINT Integer DATE_TO_ULINT DT_TO_ULINT TOD_TO_ULINT Integer DATE_TO_USINT DT_TO_USINT TODE_TO_USINT Integer DATE_TO_WORD DT_TO_WORD TOD_TO_WORD Integer DATE_TO_WSTRING DT_TO_WSTRING TOD_TO_WSTRING DATE_TO_WSTRING(D#1970-1-1)\nDT_TO_WSTRING(D#1970-1-1-0:0:1)\nTOD_TO_WSTRING(12:0:1) \"D#1970-1-1\" \"D#1970-1-1-0:0:1\" \"TOD#12:0:0\" WSTRING演算子: LDATE\/LDT\/LTOD_TO_<ターゲット タイプ> LDATE_TO_<タイプ> LDT_TO_<タイプ> LTOD_TO_<タイプ> 例 戻り値 説明 LDATE_TO___UXINT LDT_TO___UXINT LTOD_TO___XINT __UXINT、__ XINT、__ XWORD LDATE_TO___XINT LDT_TO___XINT LTOD_TO___XINT __UXINT、__ XINT、__ XWORD LDATE_TO___XWORD LDT_TO___XWORD LTOD_TO___XWORD __UXINT、__ XINT、__ XWORD LDATE_TO_BIT LDT_TO_BIT LTOD_TO_BIT BIT LDATE_TO_BOOL LDT_TO_BOOL LTOD_TO_BOOL BOOL LDATE_TO_BYTE LDT_TO_BYTE LTOD_TO_BYTE Integer LDATE_TO_DATE LDT_TO_DATE LTOD_TO_DATE 秒（ただし、表示されるのは日のみ） データ型: DATE LDATE_TO_DINT LDT_TO_DINT LTOD_TO_DINT Integer LDATE_TO_DT LDT_TO_DT LTOD_TO_DT データ型: DATE LDATE_TO_DWORD LDT_TO_DWORD LTOD_TO_DWORD Integer LDATE_TO_INT LDT_TO_INT LTOD_TO_INT Integer- LDT_TO_LDATE LTOD_TO_LDATE ナノ秒（ただし、表示されるのは日のみ） データ型: DATE LDATE_TO_LDT - LTOD_TO_LDT データ型: DATE LDATE_TO_LINT LDT_TO_LINT LTOD_TO_LINT Integer LDATE_TO_LREAL LDT_TO_LREAL LTOD_TO_LREAL REAL、LREAL LDATE_TO_LTIME LDT_TO_LTIME LTOD_TO_LTIME データ型: DATE LDATE_TO_LTOD LDT_TO_LTOD - データ型: DATE LDATE_TO_LWORD LDT_TO_LWORD LTOD_TO_LWORD Integer LDATE_TO_REAL LDT_TO_REAL LTOD_TO_REAL REAL、LREAL LDATE_TO_SINT LDT_TO_SINT LTOD_TO_SINT Integer LDATE_TO_STRING LDT_TO_STRING LTOD_TO_STRING STRING LDATE_TO_TIME LDT_TO_TIME LTOD_TO_TIME データ型: DATE LDATE_TO_TOD LDT_TO_TOD LTOD_TO_TOD データ型: DATE LDATE_TO_UDINT LDT_TO_UDINT LTOD_TO_UDINT Integer LDATE_TO_UINT LDT_TO_UINT LTOD_TO_UINT Integer LDATE_TO_ULINT LDT_TO_ULINT LTOD_TO_ULINT Integer LDATE_TO_USINT LDT_TO_USINT LTOD_TO_USINT Integer LDATE_TO_WORD LDT_TO_WORD LTOD_TO_WORD Integer LDATE_TO_WSTRING LDT_TO_WSTRING LTOD_TO_WSTRING WSTRING" }, 
{ "title" : "文字列への変換 ", 
"url" : "_cds_operator_date_to.html#UUID-4ca6892c-e4a7-a5a0-9012-c85dca949d72_UUID-404aff3f-2280-a807-32f4-4186c7d8a3ae_id_af0e820ad05f2c39c0a8640e01c81eb6_id_05525fb43f678c87c0a864636e32204e", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ 変換: DATE、DT、TOD、LDATE、LDT、LTOD \/ 文字列への変換 ", 
"snippet" : "タイプのオペランド DATE 、 DATE_AND_TIME 、 TIME_OF_DAY 、 DT 、 また TOD データと時間の変換のために演算子に渡される、は、定数構文（リテラル構文）に変換されます。生成された文字列にはキーワードが含まれています D# 、 DT# また TOD# 次に、IEC 61131-3仕様に示されているように、データと時間単位を含むサイズ。...", 
"body" : "タイプのオペランド DATE 、 DATE_AND_TIME 、 TIME_OF_DAY 、 DT 、 また TOD データと時間の変換のために演算子に渡される、は、定数構文（リテラル構文）に変換されます。生成された文字列にはキーワードが含まれています D# 、 DT# また TOD# 次に、IEC 61131-3仕様に示されているように、データと時間単位を含むサイズ。 " }, 
{ "title" : "例 ", 
"url" : "_cds_operator_date_to.html#UUID-4ca6892c-e4a7-a5a0-9012-c85dca949d72_UUID-404aff3f-2280-a807-32f4-4186c7d8a3ae_id_af0e820ad05f2c39c0a8640e01c81eb6_id_f19e7b8120d3eba4c0a864632cdf6b1f", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ 変換: DATE、DT、TOD、LDATE、LDT、LTOD \/ 例 ", 
"snippet" : "FBD実装言語 変数を監視するために、コントローラーはオンラインモードになっています。...", 
"body" : "FBD実装言語 変数を監視するために、コントローラーはオンラインモードになっています。 " }, 
{ "title" : "オペレーター：TRUNC ", 
"url" : "_cds_operator_trunc.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ オペレーター：TRUNC ", 
"snippet" : "TRUNC IEC演算子は、変換に使用されます REAL データ型を DINT データ・タイプ。 数値の整数部分のみを取ります。 の 、 TRUNC 演算子は変換します REAL の中へ INT 。 V2.3プロジェクトをインポートする場合は、 自動的に置き換えます TRUNC と TRUNC_INT 。 もしも 入力値をaで表すことはできません DINT また INT 、この場合、この関数の結果は未定義です。このような入力値の動作は、プラットフォームによって異なります。 例 ST diVar := TRUNC(1.9); (* Result: 1 *) diVar := TRUNC(-1.4...", 
"body" : "TRUNC IEC演算子は、変換に使用されます REAL データ型を DINT データ・タイプ。 数値の整数部分のみを取ります。 の 、 TRUNC 演算子は変換します REAL の中へ INT 。 V2.3プロジェクトをインポートする場合は、 自動的に置き換えます TRUNC と TRUNC_INT 。 もしも 入力値をaで表すことはできません DINT また INT 、この場合、この関数の結果は未定義です。このような入力値の動作は、プラットフォームによって異なります。 例 ST diVar := TRUNC(1.9); (* Result: 1 *)\n\ndiVar := TRUNC(-1.4); (* Result: -1 *) " }, 
{ "title" : "演算子：TRUNC_INT ", 
"url" : "_cds_operator_trunc_int.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 型変換演算子 \/ 演算子：TRUNC_INT ", 
"snippet" : "TRUNC_INT IEC演算子は、変換に使用されます REAL データ型を INT データ・タイプ。 数値の整数部分のみを取ります。 TRUNC_INT に対応します TRUNC の演算子 、およびV2.3プロジェクトをインポートするときに、この時点で自動的に使用されます。の変更機能に注意してください TRUNC 。 もしも 入力値をaで表すことはできません DINT また INT 、この場合、この関数の結果は未定義です。このような入力値の動作は、プラットフォームによって異なります。 例 ST iVar := TRUNC_INT(1.9); (* Result: 1 *) iVar := T...", 
"body" : "TRUNC_INT IEC演算子は、変換に使用されます REAL データ型を INT データ・タイプ。 数値の整数部分のみを取ります。 TRUNC_INT に対応します TRUNC の演算子 、およびV2.3プロジェクトをインポートするときに、この時点で自動的に使用されます。の変更機能に注意してください TRUNC 。 もしも 入力値をaで表すことはできません DINT また INT 、この場合、この関数の結果は未定義です。このような入力値の動作は、プラットフォームによって異なります。 例 ST iVar := TRUNC_INT(1.9); (* Result: 1 *)\n\niVar := TRUNC_INT(-1.4); (* Result: -1 *) " }, 
{ "title" : "オペランド ", 
"url" : "_cds_struct_reference_operands.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "定数とリテラル ", 
"url" : "_cds_struct_reference_operands.html#UUID-aa359e50-e152-8177-ba90-37d4949fb3ba_section-idm4613159919964832678735357547", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 定数とリテラル ", 
"snippet" : "定数は、変更できない値の識別子です。定数は、POU内でローカルに宣言することも、グローバル変数リスト内でグローバルに宣言することもできます。宣言セグメントはキーワードで拡張されます CONSTANT 。 定数は、整数や浮動小数点数などの基本型の値を表す文字列でもあります（たとえば、 16#FFFF_FFFF 、 T#5s 、 また -1.234 E-5 ）。それらを区別するために、これらの定数は、リテラル、リテラル定数、または名前のない定数とも呼ばれます。論理的（ TRUE 、 FALSE ）または数値リテラル（ 3.1415 、 T#5s ）だけでなく、文字列リテラル（ 'Hello wor...", 
"body" : "定数は、変更できない値の識別子です。定数は、POU内でローカルに宣言することも、グローバル変数リスト内でグローバルに宣言することもできます。宣言セグメントはキーワードで拡張されます CONSTANT 。 定数は、整数や浮動小数点数などの基本型の値を表す文字列でもあります（たとえば、 16#FFFF_FFFF 、 T#5s 、 また -1.234 E-5 ）。それらを区別するために、これらの定数は、リテラル、リテラル定数、または名前のない定数とも呼ばれます。論理的（ TRUE 、 FALSE ）または数値リテラル（ 3.1415 、 T#5s ）だけでなく、文字列リテラル（ 'Hello world!' 、 \"black\" ）。 構文宣言 <scope> CONSTANT\n <identifier> : <data type> := <initial value> ;\nEND_VAR\n\n<scope> : VAR | VAR_INPUT | VAR_STAT | VAR_GLOBAL\n<data type>: <elementary data type | user defined data type | function block >\n<initial value> : literal value | identifier | expression 許可される初期値： リテラル 例： TRUE 、 FALSE 、 16#FFFF_FFFF 別の場所で宣言された名前付き定数 リテラルで構成され、+-*などの単純な演算子と組み合わされた単純な式 入力や関数呼び出しを初期値として指定することはできません。 例 VAR_GLOBAL CONSTANT\n g_ciMAX_A : INT := 100;\n g_ciSPECIAL : INT := g_ciMAX_A - 10;\nEND_VAR 定数は宣言に対してのみ定義されます。初期値の割り当てが必要です。実装内では、定数は読み取られるだけなので、ステートメントの代入演算子の右側に常に表示されます。 定数は、コードのコンパイル時に初期値に置き換えられます。また、コンパイル時に初期値を計算できる必要があります。 構造化型またはユーザー定義型の定数は、実行時まで計算されません。プログラムまたはGVLの構造化定数は、プログラムの開始時に1回計算されます。関数またはメソッドの構造化定数は、関数またはメソッドが呼び出されるたびに計算されます。したがって、構造化定数の初期化は、入力または実行関数呼び出しに依存する可能性があります。 " }, 
{ "title" : "変数 ", 
"url" : "_cds_struct_reference_operands.html#UUID-aa359e50-e152-8177-ba90-37d4949fb3ba_section-idm4613160443185632678735970218", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 変数 ", 
"snippet" : "変数は、POUの宣言部分またはグローバル変数リストのいずれかでローカルとして宣言できます。変数の許可される場所は、そのデータ型によって異なります。 詳細については、以下を参照してください。 配列、構造体、ブロック内の変数へのアクセス と 変数のビットアクセス...", 
"body" : "変数は、POUの宣言部分またはグローバル変数リストのいずれかでローカルとして宣言できます。変数の許可される場所は、そのデータ型によって異なります。 詳細については、以下を参照してください。 配列、構造体、ブロック内の変数へのアクセス と 変数のビットアクセス" }, 
{ "title" : "他の ", 
"url" : "_cds_struct_reference_operands.html#UUID-aa359e50-e152-8177-ba90-37d4949fb3ba_section-idm461449035556323267873805769", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 他の ", 
"snippet" : "詳細については、以下を参照してください。 住所 と 機能...", 
"body" : "詳細については、以下を参照してください。 住所 と 機能" }, 
{ "title" : "定数：BOOL ", 
"url" : "_cds_operands_constant_bool.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 定数：BOOL ", 
"snippet" : "BOOL BOOL定数は真理値です TRUE （1）および FALSE （0）。 詳細については、以下を参照してください。 BOOL...", 
"body" : "BOOL BOOL定数は真理値です TRUE （1）および FALSE （0）。 詳細については、以下を参照してください。 BOOL" }, 
{ "title" : "定数：数値 ", 
"url" : "_cds_operands_constant_integer.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 定数：数値 ", 
"snippet" : "数値には、2進数、8進数、10進数、および16進数を指定できます。整数値が10進数でない場合は、整数定数の前に、その底に続いて番号記号（＃）を書き込む必要があります。通常どおり、10から15までの数字の16進数値をAFの文字で入力します。 数値内でアンダースコアを使用できます。 例： 14 10進数 2#1001_0011 2進数 8#67 8進数 16#A 16進数 DINT#16#A1 型付きデータ型 DINT# とベース 16# 結合 数値リテラルの可能なデータ型： BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DIN...", 
"body" : "数値には、2進数、8進数、10進数、および16進数を指定できます。整数値が10進数でない場合は、整数定数の前に、その底に続いて番号記号（＃）を書き込む必要があります。通常どおり、10から15までの数字の16進数値をAFの文字で入力します。 数値内でアンダースコアを使用できます。 例： 14 10進数 2#1001_0011 2進数 8#67 8進数 16#A 16進数 DINT#16#A1 型付きデータ型 DINT# とベース 16# 結合 数値リテラルの可能なデータ型： BYTE , WORD , DWORD , LWORD , SINT , USINT , INT , UINT , DINT , UDINT , LINT , ULINT 「大きい」タイプから「小さい」タイプへの暗黙の変換は許可されていません。 DINT変数をINT変数として単純に使用することはできません。このためには、型変換関数を使用する必要があります。 詳細については、以下を参照してください。 定数：型付きリテラル数値定数は基本的に整数値として処理されるため、除算では、剰余が失われないように浮動小数点数形式で定数を指定する必要があります。 例：除算 1\/10 収量 0 との分割 1.0\/10 収量 0.1 " }, 
{ "title" : "定数: REAL, LREAL ", 
"url" : "_cds_operands_constant_real.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 定数: REAL, LREAL ", 
"snippet" : "浮動小数点数は次のように指定できます REAL と LREAL 10進表記、または仮数と指数を使用した指数表記の定数。国際単位系（英語）によると、小数点は小数点記号として機能します。 指数表記の構文 <significand> e | E <exponent> exponent : -44..38 \/\/ REAL exponent : -324..308 \/\/ LREAL 例 REAL リテラル 7.4 10進数 カンマ付きの7,4は、コンパイラエラーを返します 1\/3.0 0.333333343の小数 注：整数型の除算の場合、結果は整数型のままです。この場合、値は丸められます。たとえば、1\/...", 
"body" : "浮動小数点数は次のように指定できます REAL と LREAL 10進表記、または仮数と指数を使用した指数表記の定数。国際単位系（英語）によると、小数点は小数点記号として機能します。 指数表記の構文 <significand> e | E <exponent> exponent : -44..38 \/\/ REAL\nexponent : -324..308 \/\/ LREAL 例 REAL リテラル 7.4 10進数 カンマ付きの7,4は、コンパイラエラーを返します 1\/3.0 0.333333343の小数 注：整数型の除算の場合、結果は整数型のままです。この場合、値は丸められます。たとえば、1\/3は結果として0になります。 1.64e + 009 指数表記 -3.402823e + 38 最小数 -1E-44 最大の負の数 1.0E-44 最小の正の数 3.402823e + 38 最大数 LREAL リテラル -1.7976931348623157E + 308 最小数 -4.94065645841247E-324 最大の負の数 4.94065645841247E-324 最小の正の数 1.7976931348623157E + 308 最大数 詳細については、以下を参照してください。 REAL、LREAL" }, 
{ "title" : "文字列定数 ", 
"url" : "_cds_operands_constant_string.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 文字列定数 ", 
"snippet" : "ストリング 文字列定数は、一重引用符で囲まれた文字列です。文字は、ISO \/ IEC8859-1で指定されている文字セットに従ってコード化されています。したがって、文字列定数にはスペースとアクセント付き文字を含めることができます。これらはこの文字セットに属しているためです。これは、文字列リテラルまたは単に文字列とも呼ばれます。 ただし、 STRINGのUTF-8エンコーディング コンパイルオプションが有効になっている場合、文字列リテラルはUTF-8形式で解釈されます。このエンコーディングは、ASCIIおよびLatin-1と互換性があります。したがって、16進コードと制御文字の特殊なケースはUT...", 
"body" : "ストリング 文字列定数は、一重引用符で囲まれた文字列です。文字は、ISO \/ IEC8859-1で指定されている文字セットに従ってコード化されています。したがって、文字列定数にはスペースとアクセント付き文字を含めることができます。これらはこの文字セットに属しているためです。これは、文字列リテラルまたは単に文字列とも呼ばれます。 ただし、 STRINGのUTF-8エンコーディング コンパイルオプションが有効になっている場合、文字列リテラルはUTF-8形式で解釈されます。このエンコーディングは、ASCIIおよびLatin-1と互換性があります。したがって、16進コードと制御文字の特殊なケースはUTF-8でも有効です。 例： 'Hello world!' 文字列リテラルの互換性はチェックされません。その結果、テキストエディタではすべての文字を入力できます。ただし、コンパイラは不明な文字を次のようにコンパイルします ? 。 " }, 
{ "title" : "16進コード ", 
"url" : "_cds_operands_constant_string.html#UUID-53b96aec-6e6d-af8b-2d30-6d54f4f8c3e0_section-idm4640076731518432920988296297", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 文字列定数 \/ 16進コード ", 
"snippet" : "文字列リテラルにドル記号（$）が含まれている場合、次の2文字は、ISO \/ IEC8859-1のコーディングに従って16進コードとして解釈されます。このコードはASCIIコードにも対応しています。さらに、特殊なケースと制御文字に注意してください。 16進コード $コード付きの文字列 解釈 '$<8-bit code>' 8ビットコード：ISO \/ IEC8859-1に従って解釈される2桁の16進数。 '$41' A '$A9' © '$40' @ '$0D' 制御文字：改行（「$ R」に対応） '$0A' 制御文字：改行（「$ L」および「$ N」に対応） 特殊なケース $コード付きの文字列 ...", 
"body" : "文字列リテラルにドル記号（$）が含まれている場合、次の2文字は、ISO \/ IEC8859-1のコーディングに従って16進コードとして解釈されます。このコードはASCIIコードにも対応しています。さらに、特殊なケースと制御文字に注意してください。 16進コード $コード付きの文字列 解釈 '$<8-bit code>' 8ビットコード：ISO \/ IEC8859-1に従って解釈される2桁の16進数。 '$41' A '$A9' © '$40' @ '$0D' 制御文字：改行（「$ R」に対応） '$0A' 制御文字：改行（「$ L」および「$ N」に対応） 特殊なケース $コード付きの文字列 解釈 '$L' 、 ' $l' 制御文字：改行（に対応 '$0A' ）。 '$N' 、 '$n' 制御文字：改行（に対応 '$0A' ）。 '$P' 、 '$p' 制御文字：フォームフィード '$R' 、 '$r' 制御文字：改行（に対応 '$0D' ）。 '$T' 、 '$t' 制御文字：タブ '$$' ドル記号： § '$'' 単一引用符： ' 定数宣言 VAR CONSTANT\n constA : STRING := 'Hello Allgäu';\n constB : STRING := 'Hello Allgäu $21'; \/\/ Hello Allgaeu!\nEND_VAR " }, 
{ "title" : "定数：UTF8＃文字列 ", 
"url" : "_cds_operands_constant_string_utf8.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 定数：UTF8＃文字列 ", 
"snippet" : "UTF8＃文字列 コンパイラバージョン> = 3.5.18.0では、UTF-8でエンコードされた文字列リテラルはベースを持つシングルバイト文字列として可能です STRING 。 構文： UTF8#' <string literal> ' 定数宣言 VAR CONSTANT constA : STRING := UTF8#'aäoöuü'; constB : STRING := UTF8#'Hello Allgäu $21'; \/\/ Hello Allgäu! END_VAR 正しい監視を確実にするために、 'monitoring_encoding'：= 'UTF-8' 属性を追加できます。 プ...", 
"body" : "UTF8＃文字列 コンパイラバージョン> = 3.5.18.0では、UTF-8でエンコードされた文字列リテラルはベースを持つシングルバイト文字列として可能です STRING 。 構文： UTF8#' <string literal> ' 定数宣言 VAR CONSTANT\n constA : STRING := UTF8#'aäoöuü';\n constB : STRING := UTF8#'Hello Allgäu $21'; \/\/ Hello Allgäu!\nEND_VAR 正しい監視を確実にするために、 'monitoring_encoding'：= 'UTF-8' 属性を追加できます。 プロジェクト全体の構成専用のUTF-8エンコーディング プロジェクト全体のコンパイルオプションの場合、UTF-8エンコーディングが使用されます STRINGのUTF8エンコーディング 有効になっています。ライブラリ関数とアドオンも、この設定に従って方向付けられます。 単一のUTF-8エンコード文字列を使用する場合は、それらが使用される場所で正しく解釈されることを確認する必要があります。たとえば、設定が選択されていない場合、OPCサーバーの文字列変数はクライアントに転送される前にUTF-8に変換されます。次のような値 UTF8#'äöü' その後、誤解されます。ビジュアライゼーションで文字列を出力するときにも、同様の問題が発生する可能性があります。 " }, 
{ "title" : "定数：文字 ", 
"url" : "_cds_operands_constant_character.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 定数：文字 ", 
"snippet" : "キャラクター 単一のUnicode文字の文字リテラルの基本型は UDINT 。タイププレフィックス UCHAR# リテラルの前に識別子として付けられます。文字リテラルの数値は、Unicode規格のコードポイントに対応しています。 構文： UCHAR#' <single charater> ' リテラル udiChar : UDINT := UCHAR#'ฒ'; \/\/ cp 3603 udiChar_1 : UDINT := UCHAR#'⳧'; \/\/ cp 11495...", 
"body" : "キャラクター 単一のUnicode文字の文字リテラルの基本型は UDINT 。タイププレフィックス UCHAR# リテラルの前に識別子として付けられます。文字リテラルの数値は、Unicode規格のコードポイントに対応しています。 構文： UCHAR#' <single charater> ' リテラル udiChar : UDINT := UCHAR#'ฒ'; \/\/ cp 3603\nudiChar_1 : UDINT := UCHAR#'⳧'; \/\/ cp 11495 " }, 
{ "title" : "定数：TIME、LTIME ", 
"url" : "_cds_operands_constant_time.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 定数：TIME、LTIME ", 
"snippet" : "使用できます TIME 標準タイマーモジュールを操作するための定数。定数のサイズは32ビットで、解像度はミリ秒単位です。 さらに、時定数 LTIME 高解像度タイマーの時間基準として利用できます。 The LTIME 定数の次元は64ビットで、解像度はナノ秒単位です。...", 
"body" : "使用できます TIME 標準タイマーモジュールを操作するための定数。定数のサイズは32ビットで、解像度はミリ秒単位です。 さらに、時定数 LTIME 高解像度タイマーの時間基準として利用できます。 The LTIME 定数の次元は64ビットで、解像度はナノ秒単位です。 " }, 
{ "title" : "定数：TIME ", 
"url" : "_cds_operands_constant_time.html#UUID-23174cc0-9514-a362-12b5-3a2a594aefce_id_d7e28b97a6ed17c0a8640e016ca2dd_id_137fbb3719b75a97c0a86463424aa10f", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 定数：TIME、LTIME \/ 定数：TIME ", 
"snippet" : "構文 <time keyword> # <length of time> <time keyword> : TIME | time | T | t <length of time> : ( <number of days>d )? ( <number of hours>h )? ( <number of minutes>m )? ( <number of seconds>s )? (<number of milleseconds>ms)? \/\/ ( ...)? Optional 時間単位の順序は変更しないでください。ただし、すべての単位を指定する必要はありません。単位は大文字で指定できます。 ...", 
"body" : "構文 <time keyword> # <length of time>\n\n<time keyword> : TIME | time | T | t\n<length of time> : ( <number of days>d )? ( <number of hours>h )? ( <number of minutes>m )? ( <number of seconds>s )? (<number of milleseconds>ms)? \/\/ ( ...)? Optional 時間単位の順序は変更しないでください。ただし、すべての単位を指定する必要はありません。単位は大文字で指定できます。 時間単位 D | d ： 日々 H | h ： 時間 M | m ： 分 s | s ：秒 MS | ms ：ミリ秒 例 ST割り当ての正しい時定数 VAR\n timLength : TIME := T#14ms;\n timLength1 : TIME := T#100s12ms; \/\/ Overflow in the highest unit is allowed.\n timLength2 : TIME := T#12h34m15s;\n timCompare : TIME;\n xIsOK: BOOL;\n\n timLongest := T#49D17H2M47S295MS; \/\/ 4294967295\nEND_VAR\n\nIF timLength < T#15MS THEN\n IF timCompare < timLength1 THEN\n xIsOK := TRUE;\n END_IF;\nEND_IF 誤った使用法 timIncorrect := t#5m68s; 低い位置でのオーバーフロー timIncorrect1 := 15ms; タイムマーカー T# ない timIncorrect2 := t#4ms13d; 時間単位の順序が正しくありません " }, 
{ "title" : "定数：LTIME ", 
"url" : "_cds_operands_constant_time.html#UUID-23174cc0-9514-a362-12b5-3a2a594aefce_id_d7e28b97a6ed17c0a8640e016ca2dd_id_a8919c2919b75a97c0a864635c7068ea", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 定数：TIME、LTIME \/ 定数：LTIME ", 
"snippet" : "構文 <long time keyword> # <length of high resolution time> <long time keyword> : LTIME | ltime <length of high resolution time> : <length of time> ( <number of microseconds>us )? ( <number of nanoseconds>ns )? \/\/ ( ...)? Optional 同じ単位を使用できます LTIME 定数は TIME 定数。指定された時間はより高い時間分解能で計算されるため、マイクロ秒とナノ秒を指定するこ...", 
"body" : "構文 <long time keyword> # <length of high resolution time>\n\n<long time keyword> : LTIME | ltime\n<length of high resolution time> : <length of time> ( <number of microseconds>us )? ( <number of nanoseconds>ns )? \/\/ ( ...)? Optional 同じ単位を使用できます LTIME 定数は TIME 定数。指定された時間はより高い時間分解能で計算されるため、マイクロ秒とナノ秒を指定することもできます。 LTIME リテラルは内部的にデータ型として扱われます LWORD したがって、値はナノ秒単位で解決されます。 追加の時間単位 US | us ：マイクロ秒 NS | ns ：ナノ秒 ST割り当ての正しい使用例 PROGRAM PLC_PRG\nVAR\n ltimLength := LTIME#1000d15h23m12s34ms2us44ns;\n ltimLength1 := LTIME#3445343m3424732874823ns;\nEND_VAR 詳細については、以下を参照してください。 データ型: TIME、LTIME と 定数：日付と時刻" }, 
{ "title" : "定数：日付と時刻 ", 
"url" : "_cds_operands_constant_date.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 定数：日付と時刻 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "32ビットの日付指定：DATE ", 
"url" : "_cds_operands_constant_date.html#UUID-e7937a91-f0b7-607d-fd3d-885eff997859_id_ce3b6c7097a791bfc0a8640e014f1995_id_615fb5921fe0403dc0a864637afb9922", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 定数：日付と時刻 \/ 32ビットの日付指定：DATE ", 
"snippet" : "使用 DATE キーワード（ D ）日付を指定します。 構文 <date keyword>#<year>-<month>-<day> <date keyword> : DATE | date | D | d <year> : 1970-2106 <month> : 1-12 <day> : 1-31 DATE リテラルは内部的にデータ型として扱われます DWORD 、これはの上限に対応します DATE#2106-2-7 。 例 PROGRAM PRG_Date VAR dateStart : DATE := DATE#2018-8-8; dateEnd : DATE := D#2018-8-3...", 
"body" : "使用 DATE キーワード（ D ）日付を指定します。 構文 <date keyword>#<year>-<month>-<day>\n\n<date keyword> : DATE | date | D | d\n<year> : 1970-2106\n<month> : 1-12\n<day> : 1-31 DATE リテラルは内部的にデータ型として扱われます DWORD 、これはの上限に対応します DATE#2106-2-7 。 例 PROGRAM PRG_Date\nVAR\n dateStart : DATE := DATE#2018-8-8;\n dateEnd : DATE := D#2018-8-31;\n dateCompare: DATE := date#1996-05-06;\n xIsDuringTheTime: BOOL;\n\n dateEarliest : DATE := d#1970-1-1; \/\/ = 0\n dateLatest : DATE := DATE#2106-2-7; \/\/ = 4294967295\nEND_VAR\n\nIF dateStart < dateCompare THEN\n IF dateCompare < dateEnd THEN\n xIsDuringTheTime := TRUE;\n END_IF;\nEND_IF " }, 
{ "title" : "64ビットの日付指定：LDATE ", 
"url" : "_cds_operands_constant_date.html#UUID-e7937a91-f0b7-607d-fd3d-885eff997859_id_ce3b6c7097a791bfc0a8640e014f1995_id_aac82d911fe0403dc0a8646373b64fb2", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 定数：日付と時刻 \/ 64ビットの日付指定：LDATE ", 
"snippet" : "使用 LDATE キーワード（ LD ）日付を指定します。 構文 <date keyword>#<year>-<month>-<day> <date keyword> : LDATE | ldate | LD | ld <year> : 1677-2262 <month> : 1-12 <day> : 1-31 LDATE リテラルは内部的にデータ型として扱われます LWORD 、これはの上限に対応します DATE#2554-7-21 。 例 PROGRAM PRG_Ldate VAR ldateStart : LDATE := LDATE#2018-8-8; ldateEnd : LDATE...", 
"body" : "使用 LDATE キーワード（ LD ）日付を指定します。 構文 <date keyword>#<year>-<month>-<day>\n\n<date keyword> : LDATE | ldate | LD | ld\n<year> : 1677-2262\n<month> : 1-12\n<day> : 1-31 LDATE リテラルは内部的にデータ型として扱われます LWORD 、これはの上限に対応します DATE#2554-7-21 。 例 PROGRAM PRG_Ldate\nVAR\n ldateStart : LDATE := LDATE#2018-8-8;\n ldateEnd : LDATE := ldate#2018-8-31;\n ldateCompare: LDATE := LD#1996-05-06;\n xIsDuringTheTime: BOOL;\n\n ldateEarliest : LDATE := ld#1677-9-22; \/\/ = 0\n ldateLatest : LDATE := LDATE#2262-4-11; \/\/ = 16#7FFFB21D1DB10000\n\n lwValue: LWORD;\nEND_VAR\n\nIF ldateStart < ldateCompare THEN\n IF ldateCompare < ldateEnd THEN\n xIsDuringTheTime := TRUE;\n END_IF;\nEND_IF\nlwValue := LDATE_TO_LWORD(ldateCompare); " }, 
{ "title" : "32ビットの日付と時刻の指定：DATE_AND_TIME ", 
"url" : "_cds_operands_constant_date.html#UUID-e7937a91-f0b7-607d-fd3d-885eff997859_id_ce3b6c7097a791bfc0a8640e014f1995_id_0042b76a1fe0403dc0a86463723e9a7f", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 定数：日付と時刻 \/ 32ビットの日付と時刻の指定：DATE_AND_TIME ", 
"snippet" : "使用 DATE_AND_TIME キーワード（ DT ）日付と時刻を指定します。 構文 <date and time keyword>#<date and time value> <date and time keyword> : DATE_AND_TIME | date_and_time | DT | dt <date and time value> : <year>-<month>-<day>-<hour>:<minute>:<second> <year> : 1970-2106 <month> : 1-12 <day> : 1-31 <hour> : 0-24 <minute> : 0-...", 
"body" : "使用 DATE_AND_TIME キーワード（ DT ）日付と時刻を指定します。 構文 <date and time keyword>#<date and time value>\n\n<date and time keyword> : DATE_AND_TIME | date_and_time | DT | dt\n<date and time value> : <year>-<month>-<day>-<hour>:<minute>:<second>\n<year> : 1970-2106\n<month> : 1-12\n<day> : 1-31\n<hour> : 0-24\n<minute> : 0-59\n<second> : 0-59 DATE_AND_TIME リテラルは内部的にデータ型として扱われます DWORD 。時間は秒単位で処理され、その結果、1970年1月1日00:00から210606：28：15までの値をとることができます。 例 PROGRAM PLC_PRG\nVAR\n dtDate : DATE_AND_TIME := DATE_AND_TIME#1996-05-06-15:36:30;\n dtDate1: DATE_AND_TIME := DT#1972-03-29-00:00:00;\n dtDate2: DATE_AND_TIME := DT#2018-08-08-13:33:20.5;\n\n dtEarliest : DATE_AND_TIME := DATE_AND_TIME#1970-1-1-00:00:00; \/\/ 0\n dtLatest : DATE_AND_TIME := DATE_AND_TIME#2106-2-7-6:28:15; \/\/ 4294967295\nEND_VAR " }, 
{ "title" : "64ビットの日付と時刻の仕様：LDATE_AND_TIME ", 
"url" : "_cds_operands_constant_date.html#UUID-e7937a91-f0b7-607d-fd3d-885eff997859_id_ce3b6c7097a791bfc0a8640e014f1995_id_5d8c31881fe0403dc0a8646357871614", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 定数：日付と時刻 \/ 64ビットの日付と時刻の仕様：LDATE_AND_TIME ", 
"snippet" : "使用 LDATE_AND_TIME キーワード（ LDT ）日付と時刻を指定します。 構文 <date and time keyword>#<long date and time value> <date and time keyword> : LDATE_AND_TIME | ldate_and_time | LDT | ldt <date and time value> : <year>-<month>-<day>-<hour>:<minute>:<second> <year> : 1677-2262 <month> : 1-12 <day> : 1-31 <hour> : 0-24 <m...", 
"body" : "使用 LDATE_AND_TIME キーワード（ LDT ）日付と時刻を指定します。 構文 <date and time keyword>#<long date and time value>\n\n<date and time keyword> : LDATE_AND_TIME | ldate_and_time | LDT | ldt\n<date and time value> : <year>-<month>-<day>-<hour>:<minute>:<second>\n<year> : 1677-2262\n<month> : 1-12\n<day> : 1-31\n<hour> : 0-24\n<minute> : 0-59\n<second> : 0-59 LDATE_AND_TIME#2262-4-10-23:59:59.99999999 LDATE_AND_TIME リテラルは内部ではデータ型として扱われます。 LWORD 。時間はナノ秒単位で処理されるため、1677 年 9 月 21 日 00:12:43.145 224192 から 2262 年 4 月 11 日 23:47:16.854 775807 までの値を指定できます 例 PROGRAM PLC_PRG\nVAR\n ldtDate : LDATE_AND_TIME := LDATE_AND_TIME#1996-05-06-15:36:30;\n ldtDate1: LDATE_AND_TIME := LDT#1972-03-29-00:00:00;\n ldtDate2: LDATE_AND_TIME := LDT#2018-08-08-13:33:20.5;\n\n dtEarliest : LDT := LDT#1677-9-21-0:12:43.145224192; \/\/ 0\n dtLatest : LDT := LDT#2262-4-11-23:47:16.854775807; \/\/ = 16#7FFFFFFFFFFFFFFF\nEND_VAR " }, 
{ "title" : "32ビットの時間指定：TIME_OF_DAY ", 
"url" : "_cds_operands_constant_date.html#UUID-e7937a91-f0b7-607d-fd3d-885eff997859_id_ce3b6c7097a791bfc0a8640e014f1995_id_cb1ceee71fe0403dc0a86463160d0889", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 定数：日付と時刻 \/ 32ビットの時間指定：TIME_OF_DAY ", 
"snippet" : "使用 TIME_OF_DAY キーワード（ TOD ）時間を指定します。 構文 <time keyword>#<time value> <time keyword> : TIME_OF_DAY | time_of_day | TOD | tod <time value> : <hour>:<minute>:<second> <hour> : 0-23 <minute> : 0-59 <second> : 0.000-59.999 1秒の端数を指定することもできます。 TIME_OF_DAY リテラルは内部的に次のように扱われます DWORD 値はミリ秒単位で解決されます。 例 PROGRAM ...", 
"body" : "使用 TIME_OF_DAY キーワード（ TOD ）時間を指定します。 構文 <time keyword>#<time value>\n\n<time keyword> : TIME_OF_DAY | time_of_day | TOD | tod\n<time value> : <hour>:<minute>:<second>\n<hour> : 0-23\n<minute> : 0-59\n<second> : 0.000-59.999 1秒の端数を指定することもできます。 TIME_OF_DAY リテラルは内部的に次のように扱われます DWORD 値はミリ秒単位で解決されます。 例 PROGRAM POU\nVAR\n todClockTime : TIME_OF_DAY := TIME_OF_DAY#15:36:30.123;\n todEarliest : TIME_OF_DAY := TIME_OF_DAY#0:0:0.000;\n todLatest : TOD := TOD#23:59:59.999;\nEND_VAR " }, 
{ "title" : "64ビット時間の指定：LTIME_OF_DAY ", 
"url" : "_cds_operands_constant_date.html#UUID-e7937a91-f0b7-607d-fd3d-885eff997859_id_ce3b6c7097a791bfc0a8640e014f1995_id_89b6b5e319701aa4c0a864633c92579b", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 定数：日付と時刻 \/ 64ビット時間の指定：LTIME_OF_DAY ", 
"snippet" : "使用 LTIME_OF_DAY キーワード（ LTOD ）時間を指定します。 構文 <time keyword>#<time value> <time keyword> : LTIME_OF_DAY | ltime_of_day | LTOD | ltod <time value> : <hour>:<minute>:<second> <hour> : 0-23 <minute> : 0-59 <second> : 0.000-59.999999999 1秒の端数を指定することもできます。 LTIME_OF_DAY リテラルは内部的に次のように扱われます LWORD 値はナノ秒単位で解決されま...", 
"body" : "使用 LTIME_OF_DAY キーワード（ LTOD ）時間を指定します。 構文 <time keyword>#<time value>\n\n<time keyword> : LTIME_OF_DAY | ltime_of_day | LTOD | ltod\n<time value> : <hour>:<minute>:<second>\n<hour> : 0-23\n<minute> : 0-59\n<second> : 0.000-59.999999999 1秒の端数を指定することもできます。 LTIME_OF_DAY リテラルは内部的に次のように扱われます LWORD 値はナノ秒単位で解決されます。 例 PROGRAM POU\nVAR\n ltodClockTime : LTIME_OF_DAY := TIME_OF_DAY#15:36:30.123456789;\n todEarliest : TIME_OF_DAY := TIME_OF_DAY#0:0:0;\n todLatest : TOD := TOD#23:59:59.999999999;\nEND_VAR 詳細については、以下を参照してください。 データ型: DATE" }, 
{ "title" : "定数：型付きリテラル ", 
"url" : "_cds_operands_constant_typedliterals.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 定数：型付きリテラル ", 
"snippet" : "のセプセプションで REAL また LREAL -定数（この場合、常に LREAL が使用されます）IEC定数を使用して計算する場合は、可能な限り最小のデータ型が使用されます。別のデータ型を使用する場合は、定数を明示的に宣言しなくても、型付きリテラルを使用してこれを行うことができます。タイプを定義するプレフィックスを定数に指定します。 構文 <type> # <literal> <type> 目的のデータ型を指定します。可能な入力は次のとおりです BOOL 、 SINT 、 USINT 、 BYTE 、 INT 、 UINT 、 WORD 、 DINT 、 UDINT 、 DWORD 、 RE...", 
"body" : "のセプセプションで REAL また LREAL -定数（この場合、常に LREAL が使用されます）IEC定数を使用して計算する場合は、可能な限り最小のデータ型が使用されます。別のデータ型を使用する場合は、定数を明示的に宣言しなくても、型付きリテラルを使用してこれを行うことができます。タイプを定義するプレフィックスを定数に指定します。 構文 <type> # <literal> <type> 目的のデータ型を指定します。可能な入力は次のとおりです BOOL 、 SINT 、 USINT 、 BYTE 、 INT 、 UINT 、 WORD 、 DINT 、 UDINT 、 DWORD 、 REAL と LREAL 。タイプを大文字にする必要があります。 <literal> 定数を指定します。入力は以下に行く必要があります <type> 指定されたデータ型が一致します。 例 diVar := DINT#34; もしも CODESYS データを失うことなく定数をターゲットタイプに変換できない場合、エラーメッセージが発行されます。 通常の定数を使用できる場所であればどこでも、型付き定数を使用できます。 " }, 
{ "title" : "配列、構造体、ブロック内の変数へのアクセス ", 
"url" : "_cds_operands_variables_accessing_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 配列、構造体、ブロック内の変数へのアクセス ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "配列要素へのアクセス ", 
"url" : "_cds_operands_variables_accessing_variables.html#UUID-ae836494-8ea7-f000-02ab-8154d9c0ddf6_section-idm4559767227196833962845179725", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 配列、構造体、ブロック内の変数へのアクセス \/ 配列要素へのアクセス ", 
"snippet" : "構文： <配列変数の名前> [ <ディメンションインデックスのカンマ区切りリスト> 】 <配列変数の名前> 配列変数の名前 例： aiCounter 詳細については、以下を参照してください。 識別子を割り当てる<ディメンションインデックスのカンマ区切りリスト> 次元ごとに 1 つのインデックスがあるため、配列の 1 つの要素が識別されます 例： 2 インデックスは、インデックスの最小値からインデックスの最大値まで有効です。例： 0..9 例 10 個のコンポーネントを含む 1 次元配列 \/\/Declaration VAR aiCounter : ARRAY[0..9] OF INT; iLoc...", 
"body" : "構文： <配列変数の名前> [ <ディメンションインデックスのカンマ区切りリスト> 】 <配列変数の名前> 配列変数の名前 例： aiCounter 詳細については、以下を参照してください。 識別子を割り当てる<ディメンションインデックスのカンマ区切りリスト> 次元ごとに 1 つのインデックスがあるため、配列の 1 つの要素が識別されます 例： 2 インデックスは、インデックスの最小値からインデックスの最大値まで有効です。例： 0..9 例 10 個のコンポーネントを含む 1 次元配列 \/\/Declaration\nVAR\n aiCounter : ARRAY[0..9] OF INT;\n iLocalVariable : INT;\nEND_VAR\n\n\/\/ Implementation\niLocalVariable := aiCounter[2]; 2 x 2 成分の 2 次元配列 \/\/Declaration\nVAR\n aiCardGame : ARRAY[1..2, 3..4] OF INT;\n iLocal_1 : INT;\nEND_VAR\n\n\/\/Implementation\niLocal_1 := aiCardGame[1, 3]; 詳細については、以下を参照してください。 ARRAY OF" }, 
{ "title" : "構造コンポーネントへのアクセス ", 
"url" : "_cds_operands_variables_accessing_variables.html#UUID-ae836494-8ea7-f000-02ab-8154d9c0ddf6_section-idm4559414443915233962845733495", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 配列、構造体、ブロック内の変数へのアクセス \/ 構造コンポーネントへのアクセス ", 
"snippet" : "構文： <構造体変数の名前> 。 <コンポーネントの名前> <構造体変数の名前> 例： sPolygon 詳細については、以下を参照してください。 識別子を割り当てる<コンポーネントの名前> 例： aiStart 例 \/\/Declaration type TYPE S_POLYGONLINE : STRUCT aiStart : ARRAY[1..2] OF INT := [-99, -99]; aiPoint1 : ARRAY[1..2] OF INT; aiPoint2 : ARRAY[1..2] OF INT; aiPoint3 : ARRAY[1..2] OF INT; aiPoint...", 
"body" : "構文： <構造体変数の名前> 。 <コンポーネントの名前> <構造体変数の名前> 例： sPolygon 詳細については、以下を参照してください。 識別子を割り当てる<コンポーネントの名前> 例： aiStart 例 \/\/Declaration type\nTYPE S_POLYGONLINE :\nSTRUCT\n aiStart : ARRAY[1..2] OF INT := [-99, -99];\n aiPoint1 : ARRAY[1..2] OF INT;\n aiPoint2 : ARRAY[1..2] OF INT;\n aiPoint3 : ARRAY[1..2] OF INT;\n aiPoint4 : ARRAY[1..2] OF INT;\n aiEnd : ARRAY[1..2] OF INT := [99, 99];\nEND_STRUCT\nEND_TYPE\n\n\/\/Declaration structure variable\nVAR\n sPolygon : S_POLYGONLINE;\n iPoint : INT;\nEND_VAR\n\n\/\/Implementation\niPoint := sPolygon.aiPoint1[1];\n 詳細については、以下を参照してください。 STRUCT" }, 
{ "title" : "POU 内の変数へのアクセス ", 
"url" : "_cds_operands_variables_accessing_variables.html#UUID-ae836494-8ea7-f000-02ab-8154d9c0ddf6_section-idm4560534545832033962845942743", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 配列、構造体、ブロック内の変数へのアクセス \/ POU 内の変数へのアクセス ", 
"snippet" : "構文： <POU 名> 。 <変数名> <POU 名> ファンクション ブロック インスタンスの名前 ( FUNCTION_BLOCK ) またはプログラム ( PROGRAM ) 例： fbController 詳細については、以下を参照してください。 識別子を割り当てる<変数名> POUの変数 例： xStart 例 FUNCTION_BLOCK FB_Controller VAR_INPUT xStart : BOOL; END_VAR VAR_OUTPUT END_VAR VAR ControlDriveA : S_CONTROL; END_VAR IF xStart = TRUE T...", 
"body" : "構文： <POU 名> 。 <変数名> <POU 名> ファンクション ブロック インスタンスの名前 ( FUNCTION_BLOCK ) またはプログラム ( PROGRAM ) 例： fbController 詳細については、以下を参照してください。 識別子を割り当てる<変数名> POUの変数 例： xStart 例 FUNCTION_BLOCK FB_Controller\nVAR_INPUT\n xStart : BOOL;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n ControlDriveA : S_CONTROL;\nEND_VAR\nIF xStart = TRUE THEN\n \/\/Symbolic bit access\n ControlDriveA.bitEnableOperation := TRUE;\nEND_IF\n\nPROGRAM PLC_PRG\n fbController : FB_Controller;\nEND_VAR\nfbController();\nfbController.xStart := TRUE; " }, 
{ "title" : "変数のビットアクセス ", 
"url" : "_cds_operands_variables_accessing_bits.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 変数のビットアクセス ", 
"snippet" : "プロセッサがメモリ上で直接ビットアクセスを実行できる場合にのみ、2つのタスクによる同時ビットアクセスを実装します。すべてのx86およびx64システムには、メモリ内のビットアクセス用のコマンドがあります。 ARMやPPCなどのシステムは、メモリ内のビットに直接アクセスできません。 プロセッサがメモリ内で直接ビットアクセスを実行できない場合でも、2つのタスクが同時にビットアクセスを実行する場合は、次の手順に従います。セマフォを使用する（ SysSemEnter ）または競合するビットアクセスを防ぐための同様の手法。ただし、タスク内でビットアクセスを実行することをお勧めします。 インデックスアクセス...", 
"body" : "プロセッサがメモリ上で直接ビットアクセスを実行できる場合にのみ、2つのタスクによる同時ビットアクセスを実装します。すべてのx86およびx64システムには、メモリ内のビットアクセス用のコマンドがあります。 ARMやPPCなどのシステムは、メモリ内のビットに直接アクセスできません。 プロセッサがメモリ内で直接ビットアクセスを実行できない場合でも、2つのタスクが同時にビットアクセスを実行する場合は、次の手順に従います。セマフォを使用する（ SysSemEnter ）または競合するビットアクセスを防ぐための同様の手法。ただし、タスク内でビットアクセスを実行することをお勧めします。 インデックスアクセスを使用すると、個々のビットを整数変数でアドレス指定できます。構造体変数または関数ブロックインスタンスを使用して、個々のビットをシンボリックにアドレス指定できます。 " }, 
{ "title" : "ビット整数変数へのインデックスアクセス ", 
"url" : "_cds_operands_variables_accessing_bits.html#UUID-d4f7a63b-4e5a-3f52-3bfa-4b1a24fbc724_id_b340eb5aade07af3c0a8640e00aa8f9e_id_14902e5878de741ec0a8652000b1e877", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 変数のビットアクセス \/ ビット整数変数へのインデックスアクセス ", 
"snippet" : "整数変数の個々のビットをアドレス指定できます。これを行うには、変数にドットとアドレス指定されたビットのインデックスを追加します。ビットインデックスは、任意の定数で指定できます。インデックス付けは0ベースです。 構文 <integer variable name> . <index> <integer data typ> = BYTE | WORD | DWORD | LWORD | SINT | USINT | INT | UINT | DINT | UDINT | LINT | ULINT 例 プログラムでは、変数の3番目のビット wA 変数の値に設定されます xB 。定数 c_usiENA...", 
"body" : "整数変数の個々のビットをアドレス指定できます。これを行うには、変数にドットとアドレス指定されたビットのインデックスを追加します。ビットインデックスは、任意の定数で指定できます。インデックス付けは0ベースです。 構文 <integer variable name> . <index>\n<integer data typ> = BYTE | WORD | DWORD | LWORD | SINT | USINT | INT | UINT | DINT | UDINT | LINT | ULINT 例 プログラムでは、変数の3番目のビット wA 変数の値に設定されます xB 。定数 c_usiENABLE 変数の3番目のビットにアクセスするためのインデックスとして機能します iX 。 インデックスアクセス PROGRAM PLC_PRG\nVAR\n wA : WORD := 16#FFFF;\n xB : BOOL := 0;\nEND_VAR\n\n\/\/ Index access in an integer variable\nwA.2 := xB; 結果： wA = 2#1111_1111_1111_1011 = 16#FFFB インデックスとしての定数 \/\/ GVL declaration\nVAR_GLOBAL CONSTANT\n gc_usiENABLE : USINT := 2;\nEND_VAR\n\nPROGRAM PLC_PRG\nVAR\n iX : INT := 0;\nEND_VAR\n\n\/\/ Constant as index\niX.gc_usiENABLE := TRUE; \/\/ Third bit in iX is set TRUE 結果： iX = 4 " }, 
{ "title" : "構造体変数のシンボリックビットアクセス ", 
"url" : "_cds_operands_variables_accessing_bits.html#UUID-d4f7a63b-4e5a-3f52-3bfa-4b1a24fbc724_id_b340eb5aade07af3c0a8640e00aa8f9e_id_747b06aff3f15e7bc0a8646368e7d8a5", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 変数のビットアクセス \/ 構造体変数のシンボリックビットアクセス ", 
"snippet" : "とともに BIT データ型の場合、個々のビットを1つの構造に組み合わせて、それらに個別にアクセスできます。次に、ビットはコンポーネント名でアドレス指定されます。 例 構造体の型宣言 TYPE S_CONTROLLER : STRUCT bitOperationEnabled : BIT; bitSwitchOnActive : BIT; bitEnableOperation : BIT; bitError : BIT; bitVoltageEnabled : BIT; bitQuickStop : BIT; bitSwitchOnLocked : BIT; bitWarning : BIT; ...", 
"body" : "とともに BIT データ型の場合、個々のビットを1つの構造に組み合わせて、それらに個別にアクセスできます。次に、ビットはコンポーネント名でアドレス指定されます。 例 構造体の型宣言 TYPE S_CONTROLLER :\nSTRUCT\n bitOperationEnabled : BIT;\n bitSwitchOnActive : BIT;\n bitEnableOperation : BIT;\n bitError : BIT;\n bitVoltageEnabled : BIT;\n bitQuickStop : BIT;\n bitSwitchOnLocked : BIT;\n bitWarning : BIT;\nEND_STRUCT\nEND_TYPE 宣言とビットへの書き込みアクセス PROGRAM PLC_PRG\nVAR\n ControlDriveA : S_CONTROLLER;\nEND_VAR\n\n\/\/ Symbolic bit access to bitEnableOperation\nControlDriveA.bitEnableOperation := TRUE; " }, 
{ "title" : "機能ブロックインスタンスでのシンボリックビットアクセス ", 
"url" : "_cds_operands_variables_accessing_bits.html#UUID-d4f7a63b-4e5a-3f52-3bfa-4b1a24fbc724_id_b340eb5aade07af3c0a8640e00aa8f9e_id_eee44594dd9f930dc0a864637e5e6307", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 変数のビットアクセス \/ 機能ブロックインスタンスでのシンボリックビットアクセス ", 
"snippet" : "関数ブロックでは、個々のビットの変数を宣言できます。 例 FUNCTION_BLOCK FB_Controller VAR_INPUT bitSwitchOnActive : BIT; bitEnableOperation : BIT; bitVoltageEnabled : BIT; bitQuickStop : BIT; bitSwitchOnLocked : BIT; END_VAR VAR_OUTPUT bitOperationEnabled : BIT; bitError : BIT; bitWarning : BIT; END_VAR VAR END_VAR ; PROGRAM P...", 
"body" : "関数ブロックでは、個々のビットの変数を宣言できます。 例 FUNCTION_BLOCK FB_Controller\nVAR_INPUT\n bitSwitchOnActive : BIT;\n bitEnableOperation : BIT;\n bitVoltageEnabled : BIT;\n bitQuickStop : BIT;\n bitSwitchOnLocked : BIT;\nEND_VAR\nVAR_OUTPUT\n bitOperationEnabled : BIT;\n bitError : BIT;\n bitWarning : BIT;\nEND_VAR\nVAR\nEND_VAR\n;\n\nPROGRAM PLC_PRG\nVAR\n fbController : FB_Controller;\nEND_VAR\n\/\/ Symbolic bit access to bitSwitchOnActive\nfbController(bitSwitchOnActive := TRUE); " }, 
{ "title" : "部分的な変数アクセス ", 
"url" : "_cds_partial_access.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 部分的な変数アクセス ", 
"snippet" : "この式は IEC 61131-3 規格に準拠しています。 データ型の IEC 変数の場合、部分的な変数アクセスが可能 BYTE 、 WORD 、 DWORD または LWORD （データ・タイプ ANY、ANY_ ）。 構文： <変数名> 。 % <部分型> <部分インデックス> ドット演算子の後にはスペースを使用できます ( . ）。パーセント記号 ( % ) および部分型の後。 <変数名> の名前 ANY_BIT 型の変数 BYTE 、 WORD 、 DWORD 、 または LWORD <部分型> X のために BIT アクセス B のために BYTE アクセス W のために WORD ア...", 
"body" : "この式は IEC 61131-3 規格に準拠しています。 データ型の IEC 変数の場合、部分的な変数アクセスが可能 BYTE 、 WORD 、 DWORD または LWORD （データ・タイプ ANY、ANY_ ）。 構文： <変数名> 。 % <部分型> <部分インデックス> ドット演算子の後にはスペースを使用できます ( . ）。パーセント記号 ( % ) および部分型の後。 <変数名> の名前 ANY_BIT 型の変数 BYTE 、 WORD 、 DWORD 、 または LWORD <部分型> X のために BIT アクセス B のために BYTE アクセス W のために WORD アクセス D のために DWORD アクセス L のために LWORD アクセス へのアクセス __XWORD も許可されており、次のように動作します。 DWORD または LWORD ポインターのサイズに応じて。 へのアクセス BOOL たとえ BOOL データ型はの一部です ANY_BIT 種類。 <部分インデックス> 0からインデックスの最大値まで 詳細については、以下を参照してください。 データ・タイプ ANY、ANY_配列、構造体、ブロック内の変数へのアクセス" }, 
{ "title" : "使用法 ", 
"url" : "_cds_partial_access.html#UUID-a998d9b0-535e-4892-deb0-bdf9fa13db54_section-idm4642469513468833961518118731", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 部分的な変数アクセス \/ 使用法 ", 
"snippet" : "部分アクセスは、非一時変数 (ユーザー定義変数、フィールド、配列アクセス、または逆参照) に対してのみ使用できます。これは、一時的な結果またはリテラルでは許可されません。 式自体は一時的なものではなく、次の式として使用できます。 REFERENCE TO またはとして ADR オペレーター。 例 \/\/ Implementation PartialVarB := GVL.Variable.%B0; PartialVarX := array[idx].%X0; PartialVarW := tempVariable.%W2; PartialVarD := ptr^.%D2; PartialVarB...", 
"body" : "部分アクセスは、非一時変数 (ユーザー定義変数、フィールド、配列アクセス、または逆参照) に対してのみ使用できます。これは、一時的な結果またはリテラルでは許可されません。 式自体は一時的なものではなく、次の式として使用できます。 REFERENCE TO またはとして ADR オペレーター。 例 \/\/ Implementation\nPartialVarB := GVL.Variable.%B0;\nPartialVarX := array[idx].%X0;\nPartialVarW := tempVariable.%W2;\nPartialVarD := ptr^.%D2;\nPartialVarB := variable.%W1.%B1\n\n 関数呼び出し、インデックス式、リテラル、またはプロパティの場合、部分的なアクセスはできません。 否定的な例: FunctionCall().%B0\n(1+index).%B0\n(DWORD#16#12345678).%B0\nProperty.%B0 " }, 
{ "title" : "部分型のインデックスの最大値 ", 
"url" : "_cds_partial_access.html#UUID-a998d9b0-535e-4892-deb0-bdf9fa13db54_section-idm464701570986723396146942364", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 部分的な変数アクセス \/ 部分型のインデックスの最大値 ", 
"snippet" : "部分アクセスは、呼び出された式が適合する型を持ち、部分インデックスが最大部分インデックス以下である場合にのみ可能です。それ以外の場合は、コンパイラ エラーが報告されます。 部分タイプ アクセスタイプ 部分インデックスの最大値 X BYTE 7 WORD 15 DWORD 31 LWORD 63 B BYTE 0 WORD 1 DWORD 3 LWORD 7 W BYTE サポートされていません WORD 0 DWORD 1 LWORD 3 D BYTE サポートされていません WORD サポートされていません DWORD 0 LWORD 1 L BYTE サポートされていません WORD サポ...", 
"body" : "部分アクセスは、呼び出された式が適合する型を持ち、部分インデックスが最大部分インデックス以下である場合にのみ可能です。それ以外の場合は、コンパイラ エラーが報告されます。 部分タイプ アクセスタイプ 部分インデックスの最大値 X BYTE 7 WORD 15 DWORD 31 LWORD 63 B BYTE 0 WORD 1 DWORD 3 LWORD 7 W BYTE サポートされていません WORD 0 DWORD 1 LWORD 3 D BYTE サポートされていません WORD サポートされていません DWORD 0 LWORD 1 L BYTE サポートされていません WORD サポートされていません DWORD サポートされていません LWORD 0 " }, 
{ "title" : "部分アクセスのある式 ", 
"url" : "_cds_partial_access.html#UUID-a998d9b0-535e-4892-deb0-bdf9fa13db54_section-idm455129619581923396149212589", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 部分的な変数アクセス \/ 部分アクセスのある式 ", 
"snippet" : "部分アクセス式の型は以下にのみ依存します。 <部分型> 次の表を使用して選択する必要があります。 部分タイプ 式の種類 X BIT B BYTE W WORD D DWORD L LWORD...", 
"body" : "部分アクセス式の型は以下にのみ依存します。 <部分型> 次の表を使用して選択する必要があります。 部分タイプ 式の種類 X BIT B BYTE W WORD D DWORD L LWORD " }, 
{ "title" : "住所 ", 
"url" : "_cds_partial_access.html#UUID-a998d9b0-535e-4892-deb0-bdf9fa13db54_section-idm4647015711872033961498739737", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 部分的な変数アクセス \/ 住所 ", 
"snippet" : "部分型の部分アクセス式からアドレスを作成できます。 B 、 W 、 D 、 そして L 。 それは ない 部分型の部分アクセス式からアドレスを作成できるようになりました X 。 それは ない type の部分アクセス式を割り当てることができます。 BIT に VAR_INOUT 変数。 例 ADR(var%.B0) referenceVariable REF= var.%W1 否定的な例: ADR(var.%X0) ref REF= var.%X0...", 
"body" : "部分型の部分アクセス式からアドレスを作成できます。 B 、 W 、 D 、 そして L 。 それは ない 部分型の部分アクセス式からアドレスを作成できるようになりました X 。 それは ない type の部分アクセス式を割り当てることができます。 BIT に VAR_INOUT 変数。 例 ADR(var%.B0)\nreferenceVariable REF= var.%W1\n 否定的な例: ADR(var.%X0)\nref REF= var.%X0\n " }, 
{ "title" : "住所 ", 
"url" : "_cds_operands_addresses.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 住所 ", 
"snippet" : "アドレスへのポインタを使用すると、オンライン変更中にアドレスの内容を移動できます。絶対アドレスを使用する場合、アドレスの内容はオンライン変更中に変更されません。 構文： % <メモリ領域番号> <サイズプレフィックス> <ポジション番号 > . <ビット位置番号> % <アドレス> 必須 メモリ領域内のアドレス % <メモリ領域プレフィックス> <サイズプレフィックス> <メモリ位置> <メモリ領域プレフィックス> 必須 I : 入力メモリ領域 入力信号と入力用のメモリ領域 入力ドライバとセンサーによる物理入力用 Q : 出力メモリ領域 出力信号と出力用のメモリ領域 出力ドライバとアクチュエー...", 
"body" : "アドレスへのポインタを使用すると、オンライン変更中にアドレスの内容を移動できます。絶対アドレスを使用する場合、アドレスの内容はオンライン変更中に変更されません。 構文： % <メモリ領域番号> <サイズプレフィックス> <ポジション番号 > . <ビット位置番号> % <アドレス> 必須 メモリ領域内のアドレス % <メモリ領域プレフィックス> <サイズプレフィックス> <メモリ位置> <メモリ領域プレフィックス> 必須 I : 入力メモリ領域 入力信号と入力用のメモリ領域 入力ドライバとセンサーによる物理入力用 Q : 出力メモリ領域 出力信号と出力用のメモリ領域 出力ドライバとアクチュエータによる物理出力用 M : フラグメモリ領域 <サイズプレフィックス> [オプション] サイズプレフィックスなし:ビット シングルビット X : ビット シングルビット B : バイト 8 ビットデータ幅 W : ワード 16 ビットデータ幅 D : 剣 32 ビットデータ幅 <メモリ位置> <ポジション番号 > . <ビット位置番号> 例: %IB2.4 3 番目のバイトの 5 番目のビットを表します。 <ポジション番号 > 必須 番号はターゲットシステムによって異なり、0 から始まります。 . <ビット位置番号> [オプション] 1 バイトの場合は 0.7 アドレスを定義するときは、特定の文字列を使用してメモリの位置とサイズを表します。住所はパーセント記号でマークされています（ % ）の後に、メモリ範囲プレフィックス、オプションのサイズプレフィックス、およびメモリ範囲位置が続きます。メモリ位置のアドレス指定に使用する番号は、ターゲットシステムによって異なります。 例 %QX7.5 %Q7.5 出力ビット7.5のシングルビットアドレス %IW215 入力ワード215のワードアドレス %QB7 出力バイト7のバイトアドレス %MD48 フラグメモリのメモリ位置48にあるダブルワードのアドレス %IW2.5.7.1 入力ワードのワードアドレス。現在のコントローラー構成に依存する解釈 VAR \n wVar AT %IW0 : WORD; \nEND_VAR 入力ワードのアドレス情報を使用した変数宣言 VAR \n xActuator AT %QW0 : BOOL; \nEND_VAR ブール変数宣言 注：ブール変数の場合、シングルビットアドレスが指定されていない場合、1バイトが内部的に割り当てられます。の値の変化 xActuator からの範囲に影響します QX0.0 に QX0.7 。 VAR \n xSensor AT %IX7.5 : BOOL; \nEND_VAR シングルビットアドレスを明示的に指定したブール変数宣言 アクセス時には、入力ビット7.5のみが読み取られます。 " }, 
{ "title" : "メモリーポジション ", 
"url" : "_cds_operands_addresses.html#UUID-b62e344d-bf98-39e1-ea00-2b46d5561ef3_id_d533aade45c8fc0a8640e00567983_id_448f942037ed6c03c0a864634fc7f314", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 住所 \/ メモリーポジション ", 
"snippet" : "アドレスが次のように有効であることを確認してください。 アプリケーションで有効な住所をマップするには、まずプロセスイメージ内の必要な位置を知る必要があります。つまり、該当するメモリ領域、つまり入力メモリ領域 ( I )、出力メモリ領域 ( Q )、またはフラグメモリ領域 ( M ) (上記参照)。さらに、必要なサイズプレフィックス (bit,) を指定する必要があります。 BYTE 、 WORD 、 DWORD (上記参照): X 、 B 、 W 、 D ) 現在使用されているデバイス構成とデバイス設定 (ハードウェア構造、デバイスの説明、I\/O 設定) が決定的な役割を果たします。 バイトア...", 
"body" : "アドレスが次のように有効であることを確認してください。 アプリケーションで有効な住所をマップするには、まずプロセスイメージ内の必要な位置を知る必要があります。つまり、該当するメモリ領域、つまり入力メモリ領域 ( I )、出力メモリ領域 ( Q )、またはフラグメモリ領域 ( M ) (上記参照)。さらに、必要なサイズプレフィックス (bit,) を指定する必要があります。 BYTE 、 WORD 、 DWORD (上記参照): X 、 B 、 W 、 D ) 現在使用されているデバイス構成とデバイス設定 (ハードウェア構造、デバイスの説明、I\/O 設定) が決定的な役割を果たします。 バイトアドレッシングを使用するデバイスとワード指向の IEC アドレッシングを使用するデバイスのビットアドレスの解釈の違いに特に注意してください。 ビットアドレスの場合 %IX5.5 、ドットの前の数字は、バイトアドレスデバイスのバイト 5 とワードアドレスデバイスのワード 5 を指します。 これとは対照的に、ワードアドレスまたはバイトアドレスによるアドレス指定は、デバイスの種類とは無関係です。 %IW5 、ワード 5 は常にアドレス指定され、バイトアドレスも指定されます %IB5 常にバイト 5。したがって、サイズとアドレッシングモードによっては、同じアドレス情報で異なるメモリセルをアドレス指定できます。 次の表は、ビット、バイト、ワード、およびダブルワードのバイトアドレッシングとワード指向のIECアドレッシングの比較を示しています。また、バイトアドレッシングの重複するメモリ領域も示しています。表の最後にある例を参照してください。 構文に関しては、IEC アドレスは常に単語指向であることに注意してください。ワード番号はドットの前、ビット番号はドットの後にあります n =バイト番号 バイトアドレッシングの重複メモリ領域の例 D0 含む B0 - B3 。 W0 含む B0 そして B1 。 W1 含む B2 そして B3 。 W2 含む B4 そして B5 。 W1 、だけでなく D1 、 D2 、および D3 アドレス指定には使用しないでください。これにより、重複が回避されます " }, 
{ "title" : "機能 ", 
"url" : "_cds_operands_functions.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ オペランド \/ 機能 ", 
"snippet" : "STでは、関数呼び出しをオペランドとして使用できます。 例： Result := Fct(7) + 3; TIME（）関数 この関数は、システムの起動から経過した時間（ミリ秒単位）を生成します。 タイムスタンプは TIME （32ビット）データ型。オーバーフロー後、値は再び 0 。 STの例 systime := TIME();...", 
"body" : "STでは、関数呼び出しをオペランドとして使用できます。 例： Result := Fct(7) + 3; TIME（）関数 この関数は、システムの起動から経過した時間（ミリ秒単位）を生成します。 タイムスタンプは TIME （32ビット）データ型。オーバーフロー後、値は再び 0 。 STの例 systime := TIME(); " }, 
{ "title" : "データ型 ", 
"url" : "_cds_reference_datatypes.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 ", 
"snippet" : "プログラミングでは、変数はターゲット システム内の名前とメモリ アドレスによって識別されます。変数名は、割り当てられたメモリをアドレス指定するための識別子です。変数のサイズは、そのデータ型によって決まります。これにより、変数に予約されるメモリの量と、メモリ内の値がどのように解釈されるかが決まります。データ型によって、許可される演算子も決まります。 関数ブロックもインスタンス化できます。関数ブロックのインスタンスは、変数と同様にメモリを使用します。メモリ要件は関数ブロックによって決まります。 使用可能なデータ タイプのグループは次のとおりです。 基本データ型 基本的なデータ型は、 CODESYS...", 
"body" : "プログラミングでは、変数はターゲット システム内の名前とメモリ アドレスによって識別されます。変数名は、割り当てられたメモリをアドレス指定するための識別子です。変数のサイズは、そのデータ型によって決まります。これにより、変数に予約されるメモリの量と、メモリ内の値がどのように解釈されるかが決まります。データ型によって、許可される演算子も決まります。 関数ブロックもインスタンス化できます。関数ブロックのインスタンスは、変数と同様にメモリを使用します。メモリ要件は関数ブロックによって決まります。 使用可能なデータ タイプのグループは次のとおりです。 基本データ型 基本的なデータ型は、 CODESYS Development System 。 __UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT | TIME | TOD | TIME_OF_DAY | UDINT | UINT | ULINT | USINT | WORD IEC 61131-3規格で規定されているデータ型のほかに、 CODESYS - 特定のデータ型 BIT 、 __UXINT 、 __XINT 、 そして __XWORD 。 標準データ型 標準型（標準データ型）は、基本データ型または文字列データ型です。 __UXINT | __XINT | __XWORD | BIT | BOOL | BYTE | DATE | DATE_AND_TIME | DINT | DT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTOD | LWORD | REAL | SINT |STRING | TIME | TOD | TIME_OF_DAY | UDINT | UINT | ULINT | USINT | WORD | WSTRING 整数データ型 __UXINT | __XINT | __XWORD | BIT | BYTE | DINT | DWORD | INT | LINT | LWORD | SINT | UDINT | UINT | ULINT | USINT | WORD 時間データ型 TIME 、 LTIME 日付と時刻のデータ型 DATE | DATE_AND_TIME | DT | TIME_OF_DAY | TOD | LDATE | LDATE_AND_TIME | LDT | LTIME_OF_DAY | LTOD IEC 61131-3規格の拡張 ユーザー定義のデータ型 TYPE詳細については、以下を参照してください。 識別子の指定" }, 
{ "title" : "データ型：BOOL ", 
"url" : "_cds_datatype_bool.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：BOOL ", 
"snippet" : "BOOL タイプ 値 メモリー BOOL TRUE （1）、 FALSE （0） 8ビット...", 
"body" : "BOOL タイプ 値 メモリー BOOL TRUE （1）、 FALSE （0） 8ビット " }, 
{ "title" : "整数データ型 ", 
"url" : "_cds_datatype_integer.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ 整数データ型 ", 
"snippet" : "Integer 大きなデータ型から小さなデータ型に変換すると、情報が失われる可能性があります。 CODESYS 次の整数データ型を提供します。 タイプ 下限 上限 メモリー BYTE 0 255 8ビット WORD 0 65535 16ビット DWORD 0 4294967295 32ビット LWORD 0 2 64 -1 64ビット SINT -128 127 8ビット USINT 0 255 8ビット INT -32768 32767 16ビット UINT 0 65535 16ビット DINT -2147483648 2147483647 32ビット UDINT 0 4294967295 ...", 
"body" : "Integer 大きなデータ型から小さなデータ型に変換すると、情報が失われる可能性があります。 CODESYS 次の整数データ型を提供します。 タイプ 下限 上限 メモリー BYTE 0 255 8ビット WORD 0 65535 16ビット DWORD 0 4294967295 32ビット LWORD 0 2 64 -1 64ビット SINT -128 127 8ビット USINT 0 255 8ビット INT -32768 32767 16ビット UINT 0 65535 16ビット DINT -2147483648 2147483647 32ビット UDINT 0 4294967295 32ビット LINT -2 63 2 63 -1 64ビット ULINT 0 2 64 -1 64ビット 詳細については、以下を参照してください。 定数：数値" }, 
{ "title" : "データ型：REAL、LREAL ", 
"url" : "_cds_datatype_real.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：REAL、LREAL ", 
"snippet" : "REAL、LREAL データ型 REAL と LREAL IEEE 754に準拠した浮動小数点型です。10進表記または指数表記で10進数と浮動小数点数を使用する場合は、浮動小数点型が必要です。 ターゲットシステム データ・タイプ 最小値の数値 最大値の数値 メモリー REAL 1.0E-44 3.402823E + 38 32ビット LREAL 4.94065645841247E-324 1.7976931348623157E + 308 64ビット 例 PROGRAM PLC_PRG VAR rMax: REAL := 3.402823E+38; \/\/ Largest number rPos...", 
"body" : "REAL、LREAL searchresult_toplevel データ型 REAL と LREAL IEEE 754に準拠した浮動小数点型です。10進表記または指数表記で10進数と浮動小数点数を使用する場合は、浮動小数点型が必要です。 ターゲットシステム データ・タイプ 最小値の数値 最大値の数値 メモリー REAL 1.0E-44 3.402823E + 38 32ビット LREAL 4.94065645841247E-324 1.7976931348623157E + 308 64ビット 例 PROGRAM PLC_PRG\nVAR\n rMax: REAL := 3.402823E+38; \/\/ Largest number\n rPosMin : REAL := 1.0E-44; \/\/ Smallest positve number\n rNegMax: REAL := -1.0E-44; \/\/ Largest negative number\n rMin: REAL := -3.402823E+38; \/\/ Smallest number\n\n lrMax: LREAL := 1.7976931348623157E+308; \/\/ Largest number\n lrPosMin : LREAL := 4.94065645841247E-324; \/\/ Smallest positve number\n lNegMax: LREAL := -4.94065645841247E-324; \/\/ Largest negative number\n lrMin: LREAL := -1.7976931348623157E+308; \/\/ Smallest number\nEND_VAR のサポート LREAL データタイプは、使用しているターゲットデバイスによって異なります。 64ビットタイプかどうかについては、それぞれのドキュメントを参照してください LREAL に変換されます REAL またはとして残ります LREAL アプリケーションをコンパイルするとき。変換すると、情報が失われる可能性があります。 の値が REAL \/ LREAL 数値が整数の値の範囲外である場合、からのデータ型変換から未定義の結果が生成されます。 REAL また LREAL に SINT 、 USINT 、 INT 、 UINT 、 DINT 、 UDINT 、 LINT 、 また ULINT 。結果はターゲットシステムによって異なります。例外エラーも発生する可能性があります。ターゲットシステムから独立したコードを取得するには、アプリケーションが範囲外の違反をキャッチする必要があります。 の場合 REAL \/ LREAL numberが整数データ型の値の範囲内にある場合、変換はすべてのシステムで同じように動作します。 " }, 
{ "title" : "データ型：STRING ", 
"url" : "_cds_datatype_string.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：STRING ", 
"snippet" : "STRING Latin-1エンコーディングの場合、 STRING 変数は常に1文字あたり1バイトに1バイトを加えたものです。たとえば、標準の場合、これは81バイトになります STRING(80) 宣言。 UTF-8エンコーディングの場合、文字の長さは最大4バイトです。ただし、文字列の長さは常にSTRING用に予約されているバイト数を示します。したがって、文字数と文字列の長さの間に1：1の関係はなくなりました。 The STRING データ型はLatin-1またはUTF-8として解釈されます。 STRINGのUTF-8エンコーディング コンパイルオプションを有効にすると、すべての文字列リテラル...", 
"body" : "STRING searchresult_toplevel Latin-1エンコーディングの場合、 STRING 変数は常に1文字あたり1バイトに1バイトを加えたものです。たとえば、標準の場合、これは81バイトになります STRING(80) 宣言。 UTF-8エンコーディングの場合、文字の長さは最大4バイトです。ただし、文字列の長さは常にSTRING用に予約されているバイト数を示します。したがって、文字数と文字列の長さの間に1：1の関係はなくなりました。 The STRING データ型はLatin-1またはUTF-8として解釈されます。 STRINGのUTF-8エンコーディング コンパイルオプションを有効にすると、すべての文字列リテラルがUTF-8形式で解釈されます。 宣言： <variable name> : STRING( <size> ) := ' <text> '; <variable name> : STRING[ <size> ] := ' <text> '; The <size> メモリサイズと初期化はオプションです。 例 sVar : STRING(46):= 'This is a string with memory for 46 characters.';\nsVar_µ : STRING[10] := 'µ (Mü)';\nsVar_ß : STRING[10] := 'Eszett'; データ型の変数 STRING 任意の文字列を含めることができます。の量 <size> 宣言中に予約されるメモリはバイト数を示し、括弧または括弧で示されます。サイズが定義されていない場合、デフォルトで80文字が予約されています。変数がデータ型に対して長すぎるリテラルで初期化されている場合、リテラルはそれに応じて右から切り捨てられます。 ただし、文字列の長さは基本的に制限されていません。ライブラリの機能を使用して文字列操作を行う場合 Standard 実行されると、255までの長さの文字列が正しく処理されます。ライブラリの機能を使用して文字列操作を行う場合 StringUtils 実行すると、より長い文字列（> 255文字）を使用することもできます。 データ型の変数の場合 STRING アプリケーションをリセットして再初期化すると、初期値の終了ヌル文字の後に存在する (古い) 文字列の内容は上書きされません。これは、初期化値を使用した初期化と、デフォルトの初期化値 0 を使用した初期化の両方に適用されます。 コンパイラバージョン3.5.18.0以降では、文字列のエンコード形式を選択できます。文字列をLatin-1形式とUTF-8形式のどちらで解釈するかを、プロジェクト全体で指定することができます。 UTF-8エンコーディングの場合、 STRINGのUTF8エンコーディング コンパイルオプション。 詳細については、以下を参照してください。 コンパイルオプション と UTF-8エンコーディングエンコード形式を変更する前に、静的分析ルールSA0175を使用してコードを確認することをお勧めします。 詳細については、以下を参照してください。 静的分析ライト追加します {attribute 'monitoring_encoding' := 'UTF8'} 変数の宣言へのプラグマ。次に、UTF8エンコーディングで変数の内容を監視できます。 詳細については、以下を参照してください。 monitoring_encoding プラグマ " }, 
{ "title" : "データ型: TIME、LTIME ", 
"url" : "_cds_datatype_time.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型: TIME、LTIME ", 
"snippet" : "時間データ型 TIME 内部的には DWORD 。 の場合 TIME これにより、ミリ秒単位の解像度が得られます。 時間データ型 LTIME 内部的には LWORD 。 の場合 LTIME ナノ秒単位の解像度が得られます。データ型 LTIME 高解像度タイマーの時間基準として。高解像度タイマーの分解能はナノ秒単位です。 データ・タイプ 下限 上限 メモリー 解決 説明 TIME T#0d0h0m0s0ms T#49d17h2m47s295ms 32ビット ミリ秒 構文： TIME#xDxHxMxSxMS 構文： TIME#xdxhxmxsxms 構文： T#xDxHxMxSxMS 構文： T#...", 
"body" : "時間データ型 TIME 内部的には DWORD 。 の場合 TIME これにより、ミリ秒単位の解像度が得られます。 時間データ型 LTIME 内部的には LWORD 。 の場合 LTIME ナノ秒単位の解像度が得られます。データ型 LTIME 高解像度タイマーの時間基準として。高解像度タイマーの分解能はナノ秒単位です。 データ・タイプ 下限 上限 メモリー 解決 説明 TIME T#0d0h0m0s0ms T#49d17h2m47s295ms 32ビット ミリ秒 構文： TIME#xDxHxMxSxMS 構文： TIME#xdxhxmxsxms 構文： T#xDxHxMxSxMS 構文： T#xdxhxmxsxms LTIME LTIME#0NS LTIME#213503D23H34M33S709MS551US615NS 64ビット ナノ秒 構文： LTIME#xDxHxMxSxMSxUSxNS 構文： LTIME#xdxhxmxsxmsxusxna 例： T#1D2H3M4S\nT#49D17H2M47S295MS\nLTIME#1000D15H23M12S34ms2us44ns\nLTIME#213503D23H34M33S709MS551US615NS 詳細については、以下を参照してください。 定数：TIME、LTIME、 TIME, LTIME" }, 
{ "title" : "データ型: DATE ", 
"url" : "_cds_datatype_date_and_time_of_day.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型: DATE ", 
"snippet" : "日付と時刻のデータ型 DATE 、 DATE_AND_TIME （ DT ）、 そして TIME_OF_DAY （ TOD ）は内部的には DWORD (32 ビット値)。 データ型 LDATE 、 LDATE_AND_TIME （（ LDT ）、 と LTIME_OF_DAY （（ LTOD ）内部的には LWORD （64ビット値）。 データ・タイプ 下限 デフォルト 上限 メモリー 解決 説明 DATE D#1970-01-01 D#2106-02-07 32ビット 秒（ただし、日のみが表示されます） 構文： DATE#yyyy-MM-dd 構文： D#yyyy-MM-dd DATE_A...", 
"body" : "日付と時刻のデータ型 DATE 、 DATE_AND_TIME （ DT ）、 そして TIME_OF_DAY （ TOD ）は内部的には DWORD (32 ビット値)。 データ型 LDATE 、 LDATE_AND_TIME （（ LDT ）、 と LTIME_OF_DAY （（ LTOD ）内部的には LWORD （64ビット値）。 データ・タイプ 下限 デフォルト 上限 メモリー 解決 説明 DATE D#1970-01-01 D#2106-02-07 32ビット 秒（ただし、日のみが表示されます） 構文： DATE#yyyy-MM-dd 構文： D#yyyy-MM-dd DATE_AND_TIME DT DT#1970-1-1-0:0:0 DT#2106-2-7-6:28:15 32ビット 秒 構文： DATE_AND_TIME#yyyy-MM-dd-hh:mm:ss 構文： DT#yyyy-MM-dd-hh:mm:ss TIME_OF_DAY TOD TOD#0:0:0 TOD#23:59:59.999 32ビット ミリ秒 構文： TIME_OF_DAY#hh:mm:ss 構文： TOD#hh:mm:ss.sss LDATE LD#1677-9-22 LD#1970-01-01 LDATE#2262-4-11 64ビット ナノ秒（ただし、日のみが表示されます） 構文： LDATE#yyyy-MM-dd LDATE_AND_TIME LDT LDT#1677-9-21-0:12:43.145224192 LDT#1970-1-1-0:0:0 LDT#2262-4-11-23:47:16.854775807 64ビット ナノ秒 構文： LDATE_AND_TIME##yyyy-MM-dd-hh:mm:ss.sssssssss 構文： LDT##yyyy-MM-dd-hh:mm:ss.sssssssss LTIME_OF_DAY LTOD LTOD##0:0:0 LTOD#23:59:59.999999999 64ビット ナノ秒 構文： LTIME_OF_DAY#hh:mm:ss.sssssssss 構文： LTOD#hh:mm:ss.sssssssss 例 VAR\n \/\/Date\n dateBottom : DATE := DATE#1970-1-1;\n dateTop : DATE := DATE#2106-2-7;\n dateAppointment : DATE := D#2020-2-7; \/\/ D as data type prohibited\n\n \/\/Date and time\n dtBottom : DATE_AND_TIME := DATE_AND_TIME#1970-1-1-0:0:0;\n dtTop : DT := DATE_AND_TIME#2106-02-07-06:28:15;\n dtAppointment : DT := DT#2020-2-7-12:55:1.234;\n\n \/\/Time of day\n todBottom : TIME_OF_DAY := TIME_OF_DAY#0:0:0;\n todTop : TOD := TIME_OF_DAY#23:59:59.999;\n todAppointment : TOD := TOD#12:3:4.567;\n\n \/\/ Long date\n ldateBottom : LDATE := LDATE#1970-1-1;\n ldateTop : LDATE := LDATE#2106-2-7;\n ldateAppointment : LDATE := LD#2020-2-7; \/\/ LD as data typ prohibited\n\n \/\/ Long date and time\n ldtBottom : LDATE_AND_TIME := LDATE_AND_TIME#1970-1-1-0:0:0;\n ldtTop : LDT := LDATE_AND_TIME#2262-4-10-23:34:33.709551615;\n ldtAppointment : LDT := LDT#2020-2-7-12:55:1.234567891;\n\n \/\/Long time of day\n ltodBottom : LTIME_OF_DAY := LTIME_OF_DAY#0:0:0;\n ltodTop : LTOD := LTIME_OF_DAY#23:59:59.999999999 ;\n ltodAppointment : LTOD := LTOD#12:3:4.567890123;\n\nEND_VAR 詳細については、以下を参照してください。 定数：日付と時刻 、 DATE, DT, TOD, LDATE, LDT, LTOD" }, 
{ "title" : "データ型: ANY、ANY_ <タイプ> ", 
"url" : "_cds_datatype_any.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型: ANY、ANY_ <タイプ> ", 
"snippet" : "ANY、ANY_ <タイプ> データ型 ANY または ANY_ <タイプ> 型が不明または指定されていない入力パラメータを入力するために、関数、関数ブロック、またはメソッドのインターフェイスで使用されます。 入力変数 ( VAR_INPUT ) は汎用データ型を持ちます。 コンパイラは入力変数の型を内部で以下に説明するデータ構造に置き換えるため、値は直接渡されません。代わりに、ポインタが実際の値に渡されるため、変数のみを渡すことができます。したがって、データ型は呼び出し時にのみ指定されます。その結果、それぞれが異なるデータ型を持つ引数を使用して、このような POU の呼び出しを行うことができ...", 
"body" : "ANY、ANY_ <タイプ> データ型 ANY または ANY_ <タイプ> 型が不明または指定されていない入力パラメータを入力するために、関数、関数ブロック、またはメソッドのインターフェイスで使用されます。 入力変数 ( VAR_INPUT ) は汎用データ型を持ちます。 コンパイラは入力変数の型を内部で以下に説明するデータ構造に置き換えるため、値は直接渡されません。代わりに、ポインタが実際の値に渡されるため、変数のみを渡すことができます。したがって、データ型は呼び出し時にのみ指定されます。その結果、それぞれが異なるデータ型を持つ引数を使用して、このような POU の呼び出しを行うことができます。 リテラル、置換された定数、関数呼び出しまたは式の結果 できない 入力変数に渡されます ( VAR_IN_OUT ）。 電話 構文の説明は、引数が渡されるパラメーターが1つだけのPOUを参照しています。その結果、引数のデータ型は入力変数のジェネリックデータ型を指定します。たとえば、タイプの引数 BYTE, WORD, DWORD, LWORD タイプに渡すことができます ANY_BIT 入力変数。 関数呼び出しの構文: <関数名> ( <引数> ) 関数ブロック呼び出しの構文 <ファンクションブロックインスタンスの名前> ( <入力変数の名前> := <引数> ) メソッド呼び出しの構文 <ファンクションブロックインスタンスの名前> 。 <メソッド名> ( <入力変数の名前> := <引数> ) <引数> 伝達変数 例 PROGRAM PLC_PRG\nVAR\n byValue : BYTE := 16#AB;\n iValue : INT := -1234;\n xResultByte : BOOL;\n xResultInt : BOOL;\n\n fbComputeAnyByte : FB_ComputeAny;\n fbComputeAnyInt : FB_ComputeAny;\n\n fbComputeM1 : FB_ComputeMethod;\n fbComputeM2 : FB_ComputeMethod;\n\n byN : BYTE := 1;\n wBitField1 : WORD := 16#FFFF;\n wBitField2 : WORD := 16#0001;\n xInit : BOOL;\n xResult : BOOL;\nEND_VAR\n\n\/\/Implementation\nxResultByte := funComputeAny(byValue);\nxResultInt := funComputeAny(iValue);\n\nxResult := funGenericCompare(wBitField1, wBitField2);\n\nfbComputeAnyByte(anyInput1 := byValue);\nfbComputeAnyInt(anyInput1 := iValue);\n\nfbComputeM1.methComputeAnny(anyInput1 := byValue);\nfbComputeM2.methComputeAnny(anyInput1 := iValue);\n " }, 
{ "title" : "ANY および ANY_ の内部データ構造 <タイプ> ", 
"url" : "_cds_datatype_any.html#UUID-08811461-dc3a-9612-9aa1-9d1b22125df5_id_ed37729bef786cc0a8640e01c41bef_id_fd745cdad9e24e11c0a8646350ca1289", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型: ANY、ANY_ <タイプ> \/ ANY および ANY_ の内部データ構造 <タイプ> ", 
"snippet" : "コードがコンパイルされるとき、入力変数は型付けされます。 内部的に と ANY 以下の構造によるデータ型。 POU が呼び出されるとき (実行時)、引数は参照パラメーターに渡されます。 TYPE AnyType : STRUCT \/\/ Type of the current parameter typeclass : __SYSTEM.TYPE_CLASS ; \/\/ Pointer to the current parameter pvalue : POINTER TO BYTE; \/\/ Size of the data to which the pointer points diSize :...", 
"body" : "コードがコンパイルされるとき、入力変数は型付けされます。 内部的に と ANY 以下の構造によるデータ型。 POU が呼び出されるとき (実行時)、引数は参照パラメーターに渡されます。 TYPE AnyType :\nSTRUCT\n \/\/ Type of the current parameter\n typeclass : __SYSTEM.TYPE_CLASS ;\n \/\/ Pointer to the current parameter\n pvalue : POINTER TO BYTE;\n \/\/ Size of the data to which the pointer points\n diSize : DINT;\nEND_STRUCT\nEND_TYPE この構造体を使用して、POU 内の入力変数にアクセスし、たとえば、渡された値をクエリできます。 例 これは、2つの入力変数が同じタイプと同じ値を持っているかどうかを比較します。 FUNCTION funGenericCompare : BOOL\n\/\/ Declaration\nVAR_INPUT\n any1 : ANY;\n any2 : ANY;\nEND_VAR\nVAR\n pTest : POINTER TO ARRAY [0..100] OF POINTER TO DWORD;\n diCount: DINT;\nEND_VAR\n\n\/\/ Implementation\npTest := ADR(any1);\nGeneric_Compare := FALSE;\nIF any1.typeclass <> any2.typeclass THEN\n RETURN;\nEND_IF\nIF any1.diSize <> any2.diSize THEN\n RETURN;\nEND_IF\n\/\/ Byte comparison\nFOR iCount := 0 TO any1.diSize-1 DO\n IF any1.pvalue[iCount] <> any2.pvalue[iCount] THEN\n RETURN;\n END_IF\nEND_FOR\nGeneric_Compare := TRUE;\nRETURN;\n " }, 
{ "title" : "宣言 ", 
"url" : "_cds_datatype_any.html#UUID-08811461-dc3a-9612-9aa1-9d1b22125df5_id_ed37729bef786cc0a8640e01c41bef_id_5fb6e029d9e24e20c0a864630acc6b04", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型: ANY、ANY_ <タイプ> \/ 宣言 ", 
"snippet" : "構文の説明は、パラメーターが1つだけのPOU（入力変数）を参照しています。 構文 <範囲> <POU 名> : <戻り値のデータ型> VAR_INPUT <変数名> : <汎用データ型> ; END_VAR <範囲> 考えられる範囲: FUNCTION FUNCTION_BLOCK METHOD <POU 名> POUの名前 : <戻り値のデータ型> オプション <変数名> 入力変数の名前 <汎用データ型> ANY 、 ANY_BIT 、 ANY_DATE 、 ANY_NUM 、 ANY_REAL 、 ANY_INT 、 または ANY_STRING 例 FUNCTION funCompute...", 
"body" : "構文の説明は、パラメーターが1つだけのPOU（入力変数）を参照しています。 構文 <範囲> <POU 名> : <戻り値のデータ型> \nVAR_INPUT\n <変数名> : <汎用データ型> ; END_VAR <範囲> 考えられる範囲: FUNCTION FUNCTION_BLOCK METHOD <POU 名> POUの名前 : <戻り値のデータ型> オプション <変数名> 入力変数の名前 <汎用データ型> ANY 、 ANY_BIT 、 ANY_DATE 、 ANY_NUM 、 ANY_REAL 、 ANY_INT 、 または ANY_STRING 例 FUNCTION funComputeAny : BOOL\nVAR_INPUT\n anyInput1 : ANY; \/\/ For valid data type see table\nEND_VAR\n\nFUNCTION_BLOCK FB_ComputeAny\nVAR_INPUT\n anyInput1 : ANY;\nEND_VAR\n\nFUNCTION_BLOCK FB_ComputeMethod\nMETHOD methComputeAnny : BOOL\nVAR_INPUT\n anyInput1 : ANY_INT; \/\/ Valid data types are SINT, INT, DINT, LINT, USINT, UINT, UDINT, ULINT\nEND_VAR 3.5.1.0を超えるコンパイラバージョンでは、表の汎用IECデータ型がサポートされます。 この表は、汎用データ型の階層を表し、仮パラメーター（宣言）のどの汎用データ型が引数（呼び出し）のどの基本データ型を許可するかに関する情報を提供します。 仮パラメータの場合のジェネリックデータ型 実パラメータ（引数）の場合に許可される基本データ型 ANY ANY_BIT BYTE WORD DWORD LWORD ANY_DATE DATE DATE_AND_TIME 、 DT TIME_OF_DAY 、 TOD LDATE LDATE_AND_TIME 、 LDT LTIME_OF_DAY 、 LTOD ANY_NUM ANY_REAL REAL 、 LREAL ANY_INT USINT 、 UINT 、 UDINT 、 ULINT SINT 、 INT 、 DINT 、 LINT ANY_STRING STRING 、 WSTRING " }, 
{ "title" : "データ型：WSTRING ", 
"url" : "_cds_datatype_wstring.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：WSTRING ", 
"snippet" : "WSTRING IEC 61131-3 規格によると、データ型 WSTRING UCS-2 エンコーディングに従います。 UCS-2 エンコーディングは、文字が 2 バイトの固定長で正確にエンコードされることを意味します。 UCS-2 は、からのコード ポイントの文字で構成されます。 U+0000 に U+D7FF そしてから U+E000 に U+FFFF .文字列は次で終了します 0 . 宣言： <variable name> : WSTRING( <size> ) := \" <text> \" サイズ <size> 文字列の長さを決定します。初期化は、 \"<text>\" ストリング。文字列...", 
"body" : "WSTRING searchresult_toplevel IEC 61131-3 規格によると、データ型 WSTRING UCS-2 エンコーディングに従います。 UCS-2 エンコーディングは、文字が 2 バイトの固定長で正確にエンコードされることを意味します。 UCS-2 は、からのコード ポイントの文字で構成されます。 U+0000 に U+D7FF そしてから U+E000 に U+FFFF .文字列は次で終了します 0 . 宣言： <variable name> : WSTRING( <size> ) := \" <text> \" サイズ <size> 文字列の長さを決定します。初期化は、 \"<text>\" ストリング。文字列は、二重引用符で囲まれた WSTRING としてフラグが付けられます。サイズの指定と初期化はオプションです。 データ型の変数の場合 WSTRING アプリケーションをリセットすることによって再初期化され、(古い) 文字列の使用可能なバイト ペアは、終端のヌル ワードの後に存在します ( WORD ) は上書きされません。これは、初期化値を使用した初期化と、デフォルトの初期化値 0 を使用した初期化の両方に適用されます。 例 WSTRING データ型の文字列には、1 文字あたり 2 バイトが必要です。の場合、 STRING 1 文字につき 1 バイトのみが予約されています。 wsString : WSTRING := \"This is a WSTRING\";\nsString : STRING := 'This is a STRING'; 文字列 wsEmpty 空文字列です。変数 wsMoney ユーロ記号 (€) のサイズは 10 です。文字列は 10 文字を超えると切り捨てられます。漢字 (U+7BE6) が変数に割り当てられます。 wsHan . PROGRAM PRG_Money\nVAR\n wsEmpty : WSTRING := \"\"; \/\/ The empty string\n wsMoney : WSTRING(10) := \"12345678 € 123\"; \/\/ String will be truncated\n wsMoney_2 : WSTRING(10) := \"12345678 €\";\n wsHan : WSTRING(10) := \"篦\"; \/\/ Chinese character U+\/BE6\nEND_VAR " }, 
{ "title" : "データ型：BIT ", 
"url" : "_cds_datatype_bit.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：BIT ", 
"snippet" : "BIT データ型 BIT 構造体メンバーを宣言するための構造体、または変数を宣言するための関数ブロックでのみ有効です。 A BIT 変数は値を持つことができます TRUE （1）および FALSE （0）。この場合、変数には正確に1ビットのメモリが必要です。 その結果、個々のビットを名前でシンボリックにアドレス指定できます。 BIT 連続して宣言される変数は、バイト単位でバンドルされます。このようにして、メモリの使用を最適化できます。 BOOL それぞれ8ビットを予約するタイプ。一方、ビットアクセスは大幅に時間がかかります。したがって、を使用する必要があります BIT 事前定義された形式でデー...", 
"body" : "BIT searchresult_toplevel データ型 BIT 構造体メンバーを宣言するための構造体、または変数を宣言するための関数ブロックでのみ有効です。 A BIT 変数は値を持つことができます TRUE （1）および FALSE （0）。この場合、変数には正確に1ビットのメモリが必要です。 その結果、個々のビットを名前でシンボリックにアドレス指定できます。 BIT 連続して宣言される変数は、バイト単位でバンドルされます。このようにして、メモリの使用を最適化できます。 BOOL それぞれ8ビットを予約するタイプ。一方、ビットアクセスは大幅に時間がかかります。したがって、を使用する必要があります BIT 事前定義された形式でデータを定義する必要がある場合にのみデータ型。 " }, 
{ "title" : "データ型：__ UXINT、__ XINT、__ XWORD ", 
"url" : "_cds_datatype_uxint_xword.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：__ UXINT、__ XINT、__ XWORD ", 
"snippet" : "__UXINT、__ XINT、__ XWORD これらの特別なデータ型を持つ変数は、ターゲットシステムに応じて、プラットフォーム準拠のデータ型に変換されます。 CODESYS 32ビットおよび64ビット幅のアドレスレジスタを備えたシステムをサポートします。 IECコードをターゲットシステムから可能な限り独立させるために、疑似データ型を使用します __UXINT 、 __XINT 、 と __XWORD 。コンパイラは、現在のターゲットシステムタイプをチェックし、これらのデータタイプを適切な標準データタイプに変換します。 さらに、これらのデータ型の変数には型変換演算子が用意されています。 疑似...", 
"body" : "__UXINT、__ XINT、__ XWORD これらの特別なデータ型を持つ変数は、ターゲットシステムに応じて、プラットフォーム準拠のデータ型に変換されます。 CODESYS 32ビットおよび64ビット幅のアドレスレジスタを備えたシステムをサポートします。 IECコードをターゲットシステムから可能な限り独立させるために、疑似データ型を使用します __UXINT 、 __XINT 、 と __XWORD 。コンパイラは、現在のターゲットシステムタイプをチェックし、これらのデータタイプを適切な標準データタイプに変換します。 さらに、これらのデータ型の変数には型変換演算子が用意されています。 疑似データ型 64ビットプラットフォームでの型変換 32ビットプラットフォームでの型変換 __UXINT ULINT UDINT __XINT LINT DINT __XWORD LWORD DWORD " }, 
{ "title" : "データ型：POINTER TO ", 
"url" : "_cds_datatype_pointer.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：POINTER TO ", 
"snippet" : "POINTER TO ポインタは、実行時に変数や関数ブロックインスタンスなどのオブジェクトのメモリアドレスを格納します。 ポインタ宣言の構文： <pointer name>: POINTER TO <data type> | <data unit type> | <function block name> ; FUNCTION_BLOCK FB_Point VAR piNumber: POINTER TO INT; iNumber1: INT := 5; iNumber2: INT; END_VAR piNumber := ADR(iNumber1); \/\/ piNumber is assig...", 
"body" : "POINTER TO searchresult_toplevel ポインタは、実行時に変数や関数ブロックインスタンスなどのオブジェクトのメモリアドレスを格納します。 ポインタ宣言の構文： <pointer name>: POINTER TO <data type> | <data unit type> | <function block name> ; FUNCTION_BLOCK FB_Point\nVAR\n piNumber: POINTER TO INT;\n iNumber1: INT := 5;\n iNumber2: INT;\nEND_VAR\npiNumber := ADR(iNumber1); \/\/ piNumber is assigned to address of iNumber1\niNumber2 := piNumber^; \/\/ value 5 of iNumber1 is assigned to variable iNumber2 by dereferencing of pointer piNumber ポインターの間接参照は、ポインターが指す値を取得することを意味します。コンテンツ演算子を追加することにより、ポインターが逆参照されます ^ ポインタ識別子へ（例：、 piNumber^ 上記の例では）。オブジェクトのアドレスをポインタに割り当てるには、アドレス演算子 ADR オブジェクトに適用されます： ADR(iNumber1) 。 オンラインモードでは、次を使用できます 参照に移動 ポインタから参照変数の宣言位置にジャンプします。 ポインタがI \/ O入力を指す場合、書き込みアクセスが適用されます。コードが生成されると、これはコンパイラの警告につながります '<ポインタ名>'は有効な割り当てターゲットではありません 。例： pwInput := ADR(wInput); この種の構成が必要な場合は、最初に入力値をコピーする必要があります（ wInput ）書き込みアクセス権を持つ変数に。 " }, 
{ "title" : "ポインタへのインデックスアクセス ", 
"url" : "_cds_datatype_pointer.html#UUID-ae92281b-697e-83f6-386d-2290b407c800_id_ca488150a6a89ac0a8640e013d12b7_id_bb51ee8bee2b020bc0a864632ddf450d", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：POINTER TO \/ ポインタへのインデックスアクセス ", 
"snippet" : "CODESYS インデックスアクセスを許可します [] タイプの変数に POINTER TO 、およびデータ型 STRING また WSTRING 。 ポインタが指すデータには、角かっこ演算子を追加してアクセスすることもできます。 [] ポインタ識別子へ（たとえば、 piData[i] ）。ポインタの基本データ型によって、インデックス付きコンポーネントのデータ型とサイズが決まります。この場合、ポインタへのインデックスアクセスは、インデックスに依存するオフセットを追加することによって算術的に行われます。 i * SIZEOF(<base type>) ポインタのアドレスに。ポインタは同時に暗黙的...", 
"body" : "CODESYS インデックスアクセスを許可します [] タイプの変数に POINTER TO 、およびデータ型 STRING また WSTRING 。 ポインタが指すデータには、角かっこ演算子を追加してアクセスすることもできます。 [] ポインタ識別子へ（たとえば、 piData[i] ）。ポインタの基本データ型によって、インデックス付きコンポーネントのデータ型とサイズが決まります。この場合、ポインタへのインデックスアクセスは、インデックスに依存するオフセットを追加することによって算術的に行われます。 i * SIZEOF(<base type>) ポインタのアドレスに。ポインタは同時に暗黙的に逆参照されます。 計算： piData[i] := (piData + i * SIZEOF(INT))^; それはそうではありません いいえ ： piData[i] != (piData + i)^; インデックスアクセス STRING タイプの変数でインデックスアクセスを使用する場合 STRING 、インデックス式のオフセットで文字を取得します。結果はタイプです BYTE 。例えば、 sData[i] 文字列のi番目の文字を返します sData なので SINT （ASCII）。 インデックスアクセス WSTRING タイプの変数でインデックスアクセスを使用する場合 WSTRING 、インデックス式のオフセットで文字を取得します。結果はタイプです WORD 。例えば、 wsData[i] 文字列のi番目の文字を次のように返します INT （Unicode）。 への参照とポインタ BIT 変数は 無効 宣言、および基本型の配列要素 BIT 。 " }, 
{ "title" : "ポインタを引く ", 
"url" : "_cds_datatype_pointer.html#UUID-ae92281b-697e-83f6-386d-2290b407c800_id_ca488150a6a89ac0a8640e013d12b7_id_d85f8909ea809296c0a8646357089285", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：POINTER TO \/ ポインタを引く ", 
"snippet" : "2つのポインターの違いの結果は、タイプの値です。 DWORD 、ポインターが64ビットポインターの場合、64ビットプラットフォームでも。 参照を使用すると、型の安全性が保証されるという利点があります。ポインタの場合はそうではありません。 ポインタのメモリアクセスは、暗黙的な監視機能によって実行時にチェックできます。 CheckPointer 。...", 
"body" : "2つのポインターの違いの結果は、タイプの値です。 DWORD 、ポインターが64ビットポインターの場合、64ビットプラットフォームでも。 参照を使用すると、型の安全性が保証されるという利点があります。ポインタの場合はそうではありません。 ポインタのメモリアクセスは、暗黙的な監視機能によって実行時にチェックできます。 CheckPointer 。 " }, 
{ "title" : "データ型：REFERENCE TO ", 
"url" : "_cds_datatype_reference.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：REFERENCE TO ", 
"snippet" : "REFERENCE TO コンパイラバージョン> = V3.3.0.0では、参照は初期化されます（0）。 参照がデバイス入力を参照している場合、そのアクセスは書き込みアクセスとして適用されます。コードが生成されると、コンパイラの警告が発生します： \" ...invalid assignment target \"。 例： rInput REF= Input; この種の構成が必要な場合は、最初に入力値をコピーする必要があります（例： rInput ）書き込みアクセス権を持つ変数に。 との参照 REFERENCE データ型は暗黙的に別のオブジェクトを参照します。割り当ては、 REF= オペレーター ...", 
"body" : "REFERENCE TO searchresult_toplevel コンパイラバージョン> = V3.3.0.0では、参照は初期化されます（0）。 参照がデバイス入力を参照している場合、そのアクセスは書き込みアクセスとして適用されます。コードが生成されると、コンパイラの警告が発生します： \" ...invalid assignment target \"。 例： rInput REF= Input; この種の構成が必要な場合は、最初に入力値をコピーする必要があります（例： rInput ）書き込みアクセス権を持つ変数に。 との参照 REFERENCE データ型は暗黙的に別のオブジェクトを参照します。割り当ては、 REF= オペレーター 。アクセスされると、参照は暗黙的に逆参照されるため、特別なコンテンツ演算子は必要ありません。 ^ ポインタなど。 構文 <identifier> : REFERENCE TO <data type> ;\n<data type>: base type of the reference 有効な宣言 PROGRAM PLC_PRG\nVAR\n rspeA : REFERENCE TO DUT_SPECIAL;\n pspeA : POINTER TO DUT_SPECIAL;\n speB : DUT_SPECIAL;\nEND_VAR\nrspeA REF= speB; \/\/ Reference rspeA is alias for speB. The code corresponds to pspeA := ADR(speB);\nrspeA := speD; \/\/ The code corresponds to pspeA^ := speD; 無効な宣言 ariTest : ARRAY[0..9] OF REFERENCE TO INT;\npriTest : POINTER TO REFERENCE TO INT;\nrriTest : REFERENCE TO REFERENCE TO INT;\nrbitTest : REFERENCE TO BIT; 参照型は、配列、ポインター、または参照の基本型として使用しないでください。さらに、参照はビット変数を参照してはなりません。これらの種類の構造は、コンパイラエラーを生成します。 識別子とそのエイリアスを使用して同じメモリセルに同時にアクセスすると、プログラムの可読性が困難になります。 例： speB と rspeA への参照とポインタ BIT 変数は 無効 宣言、および基本型の配列要素 BIT 。 例 参照が割り当てられている場合 := の場合、参照が左側、右側、または両側にあるかに関係なく、値は常にコピーされます。 Ref := value 値を書き込みます value 参照が指す場所に移動します。ポインタ表記では次のようになります。 Ref^ := value value := Ref 参照が指す値を後に書き込みます value 。ポインタ表記では次のようになります。 value := Ref^ Ref1 := Ref2 値を書き込みます Ref2 に指差す。場所で Ref1 に指差す。ポインタ表記では次のようになります。 Ref1^ := Ref2^ いつ REF= が使用される場合、アドレスは常に適用され、左側に参照が存在する必要があります。 Ref REF= value : 参照先は次のとおりです。 value 。ポインタ表記では次のようになります。 Ref :=ADR(value) Ref1 REF= Ref2 : Ref1 と同じ値を指します Ref2 。ポインタ表記では次のようになります。 Ref1 := Ref2 Value REF = Ref コンパイルエラーが発生する 宣言では、 REFERENCE TO INT REF= value のように振る舞う REFERENCE TO INT := value 。 " }, 
{ "title" : "参照とポインタの比較 ", 
"url" : "_cds_datatype_reference.html#UUID-bbf067d0-f5c8-c60a-7bd0-cfeb6b1879c8_id_e9675c6450b1e354c0a8640e011c35ec_id_7cb25b01cab174b8c0a86463367a259c", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：REFERENCE TO \/ 参照とポインタの比較 ", 
"snippet" : "参照には、ポインターに比べて次の利点があります。 使いやすさ： 参照は、間接参照せずに、参照されるオブジェクトのコンテンツに直接アクセスできます。 値を渡すときのより細かく単純な構文： ポインタの代わりにアドレス演算子なしで参照を渡す関数ブロックの呼び出し 例： fbDoIt(riInput:=iValue); それ以外の： fbDoIt_1(piInput:=ADR(iValue)); 型安全性： 2つの参照を割り当てる場合、コンパイラーはそれらの基本タイプが一致するかどうかをチェックします。ポインタの場合、これはチェックされません。...", 
"body" : "参照には、ポインターに比べて次の利点があります。 使いやすさ： 参照は、間接参照せずに、参照されるオブジェクトのコンテンツに直接アクセスできます。 値を渡すときのより細かく単純な構文： ポインタの代わりにアドレス演算子なしで参照を渡す関数ブロックの呼び出し 例： fbDoIt(riInput:=iValue); それ以外の： fbDoIt_1(piInput:=ADR(iValue)); 型安全性： 2つの参照を割り当てる場合、コンパイラーはそれらの基本タイプが一致するかどうかをチェックします。ポインタの場合、これはチェックされません。 " }, 
{ "title" : "参照の有効性のテスト ", 
"url" : "_cds_datatype_reference.html#UUID-bbf067d0-f5c8-c60a-7bd0-cfeb6b1879c8_id_e9675c6450b1e354c0a8640e011c35ec_id_8030529aea123829c0a8646368002330", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：REFERENCE TO \/ 参照の有効性のテスト ", 
"snippet" : "演算子を使用できます __ISVALIDREF 参照が有効な値（0に等しくない値を意味する）を指しているかどうかを確認します。 構文 <boolean variable name> := __ISVALIDREF( <reference name> ); <reference name> ：で宣言された識別子 REFERENCE TO ブール変数は TRUE 参照が有効な値を指している場合。それ以外の場合は FALSE 。 PROGRAM PLC_PRG VAR iAlfa : INT; riBravo : REFERENCE TO INT; riCharlie : REFERENCE TO ...", 
"body" : "演算子を使用できます __ISVALIDREF 参照が有効な値（0に等しくない値を意味する）を指しているかどうかを確認します。 構文 <boolean variable name> := __ISVALIDREF( <reference name> ); <reference name> ：で宣言された識別子 REFERENCE TO ブール変数は TRUE 参照が有効な値を指している場合。それ以外の場合は FALSE 。 PROGRAM PLC_PRG\nVAR\n iAlfa : INT;\n riBravo : REFERENCE TO INT;\n riCharlie : REFERENCE TO INT;\n bIsRef_Bravo : BOOL := FALSE;\n bIsRef_Charlie : BOOL := FALSE;\nEND_VAR\niAlfa := iAlfa + 1;\nriBravo REF= iAlfa;\nriCharlie REF= 0;\nbIsRef_Bravo := __ISVALIDREF(riBravo); (* becomes TRUE, because riBravo references to iAlfa, which is non-zero *)\nbIsRef_Charlie := __ISVALIDREF(riCharlie); (* becomes FALSE, because riCharlie is set to 0 *) コンパイラバージョン3.5.7.40以降では、暗黙的な監視機能 CheckPointer タイプの変数に作用します REFERENCE TO ポインタ変数の場合と同じように。 " }, 
{ "title" : "データ型：ARRAY OF ", 
"url" : "_cds_datatype_array.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：ARRAY OF ", 
"snippet" : "ARRAY OF 配列は、同じデータ型のデータ要素のコレクションです。固定長または可変長の1次元および多次元配列がサポートされています。...", 
"body" : "ARRAY OF searchresult_toplevel 配列は、同じデータ型のデータ要素のコレクションです。固定長または可変長の1次元および多次元配列がサポートされています。 " }, 
{ "title" : "固定長の一次元配列 ", 
"url" : "_cds_datatype_array.html#UUID-ce9d7e29-a882-1174-ca9c-9117bd3cb42b_id_afe6bda193f4f1e8c0a8640e018f0592_id_b5dd0603c8cd5e60c0a864636e8b5a53", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：ARRAY OF \/ 固定長の一次元配列 ", 
"snippet" : "配列は、POUの宣言部分またはグローバル変数リストで定義できます。 1次元配列の宣言の構文： <variable name> : ARRAY[ <dimension> ] OF <data type> := <initialization> ; <variable name> アレイの名前 例： aiCounter <dimension> ディメンション（インデックスの下限から上限） 例： 1..100 1つのディメンションには、インデックスの下限と上限によって決定される、任意の数のインデックス付き要素を含めることができます。 インデックス制限は整数です。データ型の最大値 DINT 。 <da...", 
"body" : "配列は、POUの宣言部分またはグローバル変数リストで定義できます。 1次元配列の宣言の構文： <variable name> : ARRAY[ <dimension> ] OF <data type> := <initialization> ;\n <variable name> アレイの名前 例： aiCounter <dimension> ディメンション（インデックスの下限から上限） 例： 1..100 1つのディメンションには、インデックスの下限と上限によって決定される、任意の数のインデックス付き要素を含めることができます。 インデックス制限は整数です。データ型の最大値 DINT 。 <data type> 要素のデータ型： 基本データ型 ユーザー定義のデータ型 ファンクションブロック への参照とポインタ BIT 変数は 無効 宣言、および基本型の配列要素 BIT 。 <initialization> オプション 配列の初期値 10個の整数要素の1次元配列 VAR\n aiCounter : ARRAY[0..9] OF INT;\nEND_VAR インデックスの下限：0 インデックスの上限：9 10個の要素の初期化： aiCounter : ARRAY[0..9] OF INT := [0, 10, 20, 30, 40, 50, 60, 70, 80, 90]; データアクセス iLocalVariable := aiCounter[2]; 値20がローカル変数に割り当てられます。 " }, 
{ "title" : "固定長の多次元配列 ", 
"url" : "_cds_datatype_array.html#UUID-ce9d7e29-a882-1174-ca9c-9117bd3cb42b_section-idm4611103852920032708558820554", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：ARRAY OF \/ 固定長の多次元配列 ", 
"snippet" : "<variable name> : ARRAY[ <1st dimension> , <next dimensions> ] OF <data type> := <initialization> ; <variable name> [ <index of 1st dimension> , <index of next dimensions> ] <1st dimension> 最初の次元（インデックスの下限から上限） , <next dimensions> 次のディメンション（コンマ区切り） データアクセスの構文 <index of 1st dimension> 最初の次元のインデックス制限 ...", 
"body" : "<variable name> : ARRAY[ <1st dimension> , <next dimensions> ] OF <data type> := <initialization> ;\n <variable name> [ <index of 1st dimension> , <index of next dimensions> ]\n <1st dimension> 最初の次元（インデックスの下限から上限） , <next dimensions> 次のディメンション（コンマ区切り） データアクセスの構文 <index of 1st dimension> 最初の次元のインデックス制限 , <next dimensions> 次の次元のインデックス制限 二次元配列 VAR\n aiCardGame : ARRAY[1..2, 3..4] OF INT;\nEND_VAR 1次元：1から2（2つの配列要素） 2次元：3から4（2つの配列要素） 2 * 2要素の初期化： aiCardGame : ARRAY[1..2, 3..4] OF INT := [2(10),2(20)]; \/\/ Short notation for [10, 10, 20, 20] データアクセス iLocal_1 := aiCardGame[1, 3]; \/\/ Assignment of 10\niLocal_2 := aiCardGame[2, 4]; \/\/ Assignment of 20 三次元配列 VAR\n aiCardGame : ARRAY[1..2, 3..4, 5..6] OF INT;\nEND_VAR 1次元：1から2 二次元目：3〜4 3次元：5〜6 2 * 2 * 2 = 8つの配列要素 初期化 aiCardGame : ARRAY[1..2, 3..4, 5..6] OF INT := [10, 20, 30, 40, 50, 60, 70, 80]; データアクセス iLocal_1 := aiCardGame[1, 3, 5]; \/\/ Assignment of 10\niLocal_2 := aiCardGame[2, 3, 5]; \/\/ Assignment of 20\niLocal_3 := aiCardGame[1, 4, 5]; \/\/ Assignment of 30\niLocal_4 := aiCardGame[2, 4, 5]; \/\/ Assignment of 40\niLocal_5 := aiCardGame[1, 3, 6]; \/\/ Assignment of 50\niLocal_6 := aiCardGame[2, 3, 6]; \/\/ Assignment of 60\niLocal_7 := aiCardGame[1, 4, 6]; \/\/ Assignment of 70\niLocal_8 := aiCardGame[2, 4, 6]; \/\/ Assignment of 80 初期化 aiCardGame : ARRAY[1..2, 3..4, 5..6] OF INT := [2(10), 2(20), 2(30), 2(40)]; \/\/ Short notation for [10, 10, 20, 20, 30, 30, 40, 40] データアクセス iLocal_1 := aiCardGame[1, 3, 5]; \/\/ Assignment of 10\niLocal_2 := aiCardGame[2, 3, 5]; \/\/ Assignment of 10\niLocal_3 := aiCardGame[1, 4, 5]; \/\/ Assignment of 20\niLocal_4 := aiCardGame[2, 4, 5]; \/\/ Assignment of 20\niLocal_5 := aiCardGame[1, 3, 6]; \/\/ Assignment of 30\niLocal_6 := aiCardGame[2, 3, 6]; \/\/ Assignment of 30\niLocal_7 := aiCardGame[1, 4, 6]; \/\/ Assignment of 40\niLocal_8 := aiCardGame[2, 4, 6]; \/\/ Assignment of 40 ユーザー定義構造の3次元配列 TYPE DATA_A\nSTRUCT\n iA_1 : INT;\n iA_2 : INT;\n dwA_3 : DWORD;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n aData_A : ARRAY[1..3, 1..3, 1..10] OF DATA_A;\nEND_VAR アレイ aData_A データ型の合計3 * 3 * 10 = 90の配列要素で構成されます DATA_A 。 部分的に初期化する aData_A : ARRAY[1..3, 1..3, 1..10] OF DATA_A \n := [(iA_1 := 1, iA_2 := 10, dwA_3 := 16#00FF),(iA_1 := 2, iA_2 := 20, dwA_3 := 16#FF00),(iA_1 := 3, iA_2 := 30, dwA_3 := 16#FFFF)]; この例では、最初の3つの要素のみが明示的に初期化されます。初期化値が明示的に割り当てられていない要素は、基本データ型のデフォルト値で内部的に初期化されます。これにより、要素から始まる構造コンポーネントが0で初期化されます。 aData_A[2, 1, 1] 。 データアクセス iLocal_1 := aData_A[1,1,1].iA_1; \/\/ Assignment of 1\ndwLocal_2 := aData_A[3,1,1].dwA_3; \/\/ Assignment of 16#FFFF 関数ブロックの配列 FUNCTION BLOCK FBObject_A\nVAR\n iCounter : INT;\nEND_VAR\n...\n;\n\nPROGRAM PLC_PRG\nVAR\n aObject_A : ARRAY[1..4] OF FBObject_A;\nEND_VAR アレイ aObject_A 4つの要素で構成されています。各要素はインスタンス化されます FBObject_A ファンクションブロック。 関数呼び出し aObject_A[2](); 関数ブロックの2次元配列 の実装 FB_Something メソッド付き FB_Init FUNCTION_BLOCK FB_Something\nVAR\n _nId : INT;\n _lrIn : LREAL;\nEND_VAR\n...\n METHOD FB_Init : BOOL\n VAR_INPUT\n bInitRetains : BOOL;\n bInCopyCode : BOOL;\n nId : INT;\n lrIn : LREAL;\n END_VAR\n _nId := nId;\n _lrIn := lrIN; 機能ブロック FB_Something メソッドがあります FB_Init 2つのパラメータが必要です。 初期化による配列のインスタンス化 PROGRAM PLC_PRG\nVAR\n fb_Something_1 : FB_Something(nId := 11, lrIn := 33.44);\n a_Something : ARRAY[0..1, 0..1] OF FB_Something[(nId := 12, lrIn := 11.22), (nId := 13, lrIn := 22.33), (nId := 14, lrIn := 33.55),(nId := 15, lrIn := 11.22)];\nEND_VAR 暗黙の監視機能を使用する機能に注意してください CheckBounds() 実行時にインデックス制限の維持を監視します。 " }, 
{ "title" : "配列の配列 ", 
"url" : "_cds_datatype_array.html#UUID-ce9d7e29-a882-1174-ca9c-9117bd3cb42b_id_afe6bda193f4f1e8c0a8640e018f0592_id_b66cd6345f6ee346c0a864636bd344c4", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：ARRAY OF \/ 配列の配列 ", 
"snippet" : "「配列の配列」の宣言は、多次元配列の代替構文です。要素の寸法を記入する代わりに、要素のコレクションがネストされます。入れ子の深さは無制限です。 宣言の構文 <variable name> : ARRAY[ <any dimension> ] OF ARRAY[ <any dimension> ] OF <data type> := <initialization> ; データアクセスの構文 <variable name> [<index of first array> ] [<index of next array> ] <variable name> アレイの名前 例： aaaiCounte...", 
"body" : "「配列の配列」の宣言は、多次元配列の代替構文です。要素の寸法を記入する代わりに、要素のコレクションがネストされます。入れ子の深さは無制限です。 宣言の構文 <variable name> : ARRAY[ <any dimension> ] OF ARRAY[ <any dimension> ] OF <data type> := <initialization> ;\n データアクセスの構文 <variable name> [<index of first array> ] [<index of next array> ]\n <variable name> アレイの名前 例： aaaiCounter ARRAY[ <any dimension> ] OF ARRAY[ <any dimension> ] OF ARRAY[ <any dimension> ] OF 3つのレベルのネストされた配列 例： ARRAY[1..2, 1..3] OF ARRAY[1..3] OF ARRAY[1..4] OF ARRAY[1..5] 入れ子の深さは無制限です。 <data type> 要素のデータ型： 基本データ型 ユーザー定義のデータ型 ファンクションブロック <initialization> オプション ネストされた配列の初期値 PROGRAM PLC_PRG\nVAR\n aiPoints : ARRAY[1..2,1..3] OF INT := [1,2,3,4,5,6];\n ai2Boxes : ARRAY[1..2] OF ARRAY[1..3] OF INT := [ [1, 2, 3], [ 4, 5, 6]];\n ai3Boxes : ARRAY[1..2] OF ARRAY[1..3] OF ARRAY[1..4] OF INT := [ [ [1, 2, 3, 4], [5, 6, 7, 8 ], [9, 10, 11, 12] ], [ [13, 14, 15, 16], [ 17, 18, 19, 20], [21, 22, 23, 24] ] ];\n ai4Boxes : ARRAY[1..2] OF ARRAY[1..3] OF ARRAY[1..4] OF ARRAY[1..5] OF INT;\nEND_VAR\n\naiPoints[1, 2] := 1200;\nai2Boxes[1][2] := 1200; 変数 aiPoints と ai2Boxes 同じデータ要素を収集しますが、宣言の構文はデータアクセスの構文とは異なります。 " }, 
{ "title" : "可変長の配列 ", 
"url" : "_cds_datatype_array.html#UUID-ce9d7e29-a882-1174-ca9c-9117bd3cb42b_id_afe6bda193f4f1e8c0a8640e018f0592_id_05960a2f604f5f86c0a8646342ab6f03", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：ARRAY OF \/ 可変長の配列 ", 
"snippet" : "関数ブロック、関数、またはメソッドでは、可変長の配列を宣言できます。 VAR_IN_OUT 宣言セクション。 The LOWER_BOUND と UPPER_BOUND 実行時に実際に使用される配列のインデックス制限を決定するための演算子が用意されています。 静的に宣言された配列のみ（演算子によって生成された配列ではありません） __NEW ）は可変長の配列に渡すことができます。 可変長の1次元配列の宣言の構文 <variable name> : ARRAY[*] OF <data type> := <initialization> ; <variable name> アレイの名前 例： aM...", 
"body" : "関数ブロック、関数、またはメソッドでは、可変長の配列を宣言できます。 VAR_IN_OUT 宣言セクション。 The LOWER_BOUND と UPPER_BOUND 実行時に実際に使用される配列のインデックス制限を決定するための演算子が用意されています。 静的に宣言された配列のみ（演算子によって生成された配列ではありません） __NEW ）は可変長の配列に渡すことができます。 可変長の1次元配列の宣言の構文 <variable name> : ARRAY[*] OF <data type> := <initialization> ;\n <variable name> アレイの名前 例： aMyVariableArray <data type> 要素のデータ型： 基本データ型 ユーザー定義のデータ型 ファンクションブロック <initialization> オプション 配列の配列の初期値 可変長の多次元配列の宣言の構文 <variable name> : ARRAY[*, *] OF <data type> := <initialization> ;\n <variable name> アレイの名前 例： aMyVariableArray ARRAY[*, *] 可変長の2次元配列の宣言 正式には、アスタリスクは可変長の各次元を表します。ディメンションはコンマで区切られます。 可変長の次元はいくつでも許可されます。 限界指数を計算するための演算子の構文 LOWER_BOUND( <variable name> , <dimension number> )\nUPPER_BOUND( <variable name> , <dimension number> ) The SUM 関数は、配列要素の整数値を加算し、結果として計算された合計を返します。合計は、実行時に使用可能なすべての配列要素にわたって計算されます。配列要素の実際の数は実行時にのみわかるため、ローカル変数は可変長の1次元配列として宣言されます。 FUNCTION SUM: INT;\nVAR_IN_OUT\n aiData : ARRAY[*] OF INT;\nEND_VAR\nVAR\n diCounter : DINT;\n iResult : INT;\nEND_VAR\n\niResult := 0;\nFOR diCounter := LOWER_BOUND(aiData, 1) TO UPPER_BOUND(aiData, 1) DO \/\/ Calculates the length of the current array\n iResult := iResult + aiData[diCounter];\nEND_FOR;\nSUM := iResult; " }, 
{ "title" : "ユーザー定義のデータ型：TYPE ", 
"url" : "_cds_datatype_type.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE ", 
"snippet" : "TYPE...", 
"body" : "TYPE " }, 
{ "title" : "データ構造: STRUCT ", 
"url" : "_cds_datatype_structure.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ データ構造: STRUCT ", 
"snippet" : "STRUCT 構造体はユーザー定義のデータ型で、任意のデータ型の複数の変数を 1 つの論理ユニットにまとめます。構造体内で宣言された変数はメンバーと呼ばれます 構造体の型宣言は DUT で作成したオブジェクト プロジェクト → [オブジェクトを追加] → ダクト メニューまたはアプリケーションのコンテキストメニューにあります。 詳細については、以下を参照してください。 DUT...", 
"body" : "STRUCT 構造体はユーザー定義のデータ型で、任意のデータ型の複数の変数を 1 つの論理ユニットにまとめます。構造体内で宣言された変数はメンバーと呼ばれます 構造体の型宣言は DUT で作成したオブジェクト プロジェクト → [オブジェクトを追加] → ダクト メニューまたはアプリケーションのコンテキストメニューにあります。 詳細については、以下を参照してください。 DUT" }, 
{ "title" : "構文 ", 
"url" : "_cds_datatype_structure.html#UUID-95d29ac7-011e-01bb-9b0e-097f1f196365_section-idm234801371238798", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ データ構造: STRUCT \/ 構文 ", 
"snippet" : "TYPE <structure name> STRUCT     <member name> : <data type> := <initialization> ; END_STRUCT END_TYPE <structure name> この識別子はプロジェクト全体で有効であるため、標準データ型のように使用できます。 <member name> : <data type> ; メンバーの宣言 宣言はいくつでも構いませんが、少なくとも 2 つは必要です。 構造はネストすることもできます。つまり、構造体メンバーを既存の構造型で宣言することになります。その場合、唯一の制限は、変数 (構造体のメンバ...", 
"body" : "TYPE <structure name> STRUCT     <member name> : <data type> := <initialization> ; END_STRUCT END_TYPE <structure name> この識別子はプロジェクト全体で有効であるため、標準データ型のように使用できます。 <member name> : <data type> ; メンバーの宣言 宣言はいくつでも構いませんが、少なくとも 2 つは必要です。 構造はネストすることもできます。つまり、構造体メンバーを既存の構造型で宣言することになります。その場合、唯一の制限は、変数 (構造体のメンバー) にアドレスを割り当ててはいけないということです。は AT ここでは宣言は許可されていません。 := <initialization> [オプション] タイプ宣言 TYPE S_POLYGONLINE :\nSTRUCT\n aiStart : ARRAY[1..2] OF INT := [-99, -99];\n aiPoint1 : ARRAY[1..2] OF INT;\n aiPoint2 : ARRAY[1..2] OF INT;\n aiPoint3 : ARRAY[1..2] OF INT;\n aiPoint4 : ARRAY[1..2] OF INT;\n aiEnd : ARRAY[1..2] OF INT := [99, 99];\nEND_STRUCT\nEND_TYPE " }, 
{ "title" : "型宣言の拡張 ", 
"url" : "_cds_datatype_structure.html#UUID-95d29ac7-011e-01bb-9b0e-097f1f196365_id_b2e3e6da93f532b0c0a8640e011c7a1d_id_0f4f7c7b39401232c0a8640e0030157d", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ データ構造: STRUCT \/ 型宣言の拡張 ", 
"snippet" : "既存の構造体から追加の構造が宣言されます。拡張構造には、独自のメンバーに加えて、基本構造体と同じ構造体メンバーもあります。 構文 TYPE <structure name> EXTENDS <base structure> STRUCT     <member declaration> END_STRUCT END_TYPE 例 タイプ宣言: S_PENTAGON TYPE S_PENTAGON EXTENDS S_POLYGONLINE : STRUCT aiPoint5 : ARRAY[1..2] OF INT; END_STRUCT END_TYPE...", 
"body" : "既存の構造体から追加の構造が宣言されます。拡張構造には、独自のメンバーに加えて、基本構造体と同じ構造体メンバーもあります。 構文 TYPE <structure name> EXTENDS <base structure> STRUCT     <member declaration> END_STRUCT END_TYPE 例 タイプ宣言: S_PENTAGON TYPE S_PENTAGON EXTENDS S_POLYGONLINE :\nSTRUCT\n aiPoint5 : ARRAY[1..2] OF INT;\nEND_STRUCT\nEND_TYPE " }, 
{ "title" : "構造変数の宣言と初期化 ", 
"url" : "_cds_datatype_structure.html#UUID-95d29ac7-011e-01bb-9b0e-097f1f196365_id_b2e3e6da93f532b0c0a8640e011c7a1d_id_51c8c615dae0fa66c0a8640e0071defa", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ データ構造: STRUCT \/ 構造変数の宣言と初期化 ", 
"snippet" : "例 PROGRAM progLine VAR sPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]); sPentagon : S_PENTAGON := (aiStart:=[0,0], aiPoint1:=[1,1], aiPoint2:=[2,2], aiPoint3:=[3,3], aiPoint4:=[4,4], aiPoint5:=[5,5], aiEnd:=[0,0]); END_VA...", 
"body" : "例 PROGRAM progLine\nVAR\n sPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n sPentagon : S_PENTAGON := (aiStart:=[0,0], aiPoint1:=[1,1], aiPoint2:=[2,2], aiPoint3:=[3,3], aiPoint4:=[4,4], aiPoint5:=[5,5], aiEnd:=[0,0]);\nEND_VAR 変数には初期化を使用しないでください。構造体の配列を初期化する例については、そのデータ型のヘルプページを参照してください ARRAY OF。 " }, 
{ "title" : "構造体メンバーへのアクセス ", 
"url" : "_cds_datatype_structure.html#UUID-95d29ac7-011e-01bb-9b0e-097f1f196365_id_b2e3e6da93f532b0c0a8640e011c7a1d_id_a8aa433778b4bcc1c0a8640e00eb4380", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ データ構造: STRUCT \/ 構造体メンバーへのアクセス ", 
"snippet" : "構造体メンバーには、次の構文でアクセスします。 <variable name> . <member name> 例 PROGRAM prog_Polygon VAR sPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]); iPoint : INT; END_VAR \/\/ Assigs 5 to aiPoint iPoint := sPolygon.aiPoint1[1]; 結果: iPoint =...", 
"body" : "構造体メンバーには、次の構文でアクセスします。 <variable name> . <member name> 例 PROGRAM prog_Polygon\nVAR\n sPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n iPoint : INT;\nEND_VAR \/\/ Assigs 5 to aiPoint\niPoint := sPolygon.aiPoint1[1]; 結果: iPoint = 5 " }, 
{ "title" : "構造体変数のシンボリックビットアクセス ", 
"url" : "_cds_datatype_structure.html#UUID-95d29ac7-011e-01bb-9b0e-097f1f196365_id_b2e3e6da93f532b0c0a8640e011c7a1d_id_d5b32f89e566c6fcc0a8646322497f5b", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ データ構造: STRUCT \/ 構造体変数のシンボリックビットアクセス ", 
"snippet" : "データ型の変数を使用して構造体を宣言できます BIT 個々のビットを 1 つの論理ユニットにまとめること。そうすれば、(ビットインデックスの代わりに) 名前で個々のビットをシンボリックにアドレス指定できます シンタックス宣言 TYPE <structure name> : STRUCT     <member name> : BIT; END_STRUCT END_TYPE ビットアクセスの構文 <structure name> . <member name> 例 タイプ宣言 TYPE S_CONTROL : STRUCT bitOperationEnabled : BIT; bitSwitc...", 
"body" : "データ型の変数を使用して構造体を宣言できます BIT 個々のビットを 1 つの論理ユニットにまとめること。そうすれば、(ビットインデックスの代わりに) 名前で個々のビットをシンボリックにアドレス指定できます シンタックス宣言 TYPE <structure name> : STRUCT     <member name> : BIT; END_STRUCT END_TYPE ビットアクセスの構文 <structure name> . <member name> 例 タイプ宣言 TYPE S_CONTROL :\nSTRUCT\n bitOperationEnabled : BIT;\n bitSwitchOnActive : BIT;\n bitEnableOperation : BIT;\n bitError : BIT;\n bitVoltageEnabled : BIT;\n bitQuickStop : BIT;\n bitSwitchOnLocked : BIT;\n bitWarning : BIT;\nEND_STRUCT\nEND_TYPE ビットアクセス FUNCTION_BLOCK FB_Controller\nVAR_INPUT\n xStart : BOOL;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n ControlDriveA : S_CONTROL;\nEND_VAR\n\nIF xStart = TRUE THEN\n \/\/ Symbolic bit access\n ControlDriveA.bitEnableOperation := TRUE;\nEND_IF\n\nPROGRAM PLC_PRG\n fbController : FB_Controller;\nEND_VAR\n fbController();\nfbController.xStart := TRUE; 詳細については、以下を参照してください。 変数のビットアクセスへの参照とポインタ BIT 変数は 無効 宣言、および基本型の配列要素 BIT 。 " }, 
{ "title" : "列挙 ", 
"url" : "_cds_datatype_enum.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ 列挙 ", 
"snippet" : "列挙は、ユーザー定義変数を宣言するためのカンマ区切りのメンバー (列挙値) のリストで構成されるユーザー定義データ型です。 で列挙を宣言します DUT クリックしてプロジェクト内に既に作成されているオブジェクト [オブジェクトを追加] 。 アプリケーションコードでは、識別子 <enumeration name>.<member name> がプロジェクト内でグローバルに認識される定数として、列挙メンバを使用することができます。 詳細については、以下を参照してください。 DUT...", 
"body" : "searchresult_toplevel 列挙は、ユーザー定義変数を宣言するためのカンマ区切りのメンバー (列挙値) のリストで構成されるユーザー定義データ型です。 で列挙を宣言します DUT クリックしてプロジェクト内に既に作成されているオブジェクト [オブジェクトを追加] 。 アプリケーションコードでは、識別子 <enumeration name>.<member name> がプロジェクト内でグローバルに認識される定数として、列挙メンバを使用することができます。 詳細については、以下を参照してください。 DUT" }, 
{ "title" : "デクラレーション ", 
"url" : "_cds_datatype_enum.html#UUID-1311dba6-f878-87c0-5628-03d3a9b811e5_id_c02c7c93f57fccc0a8640e014fa9b7_id_addb6d4f1efde45ac0a8646363edf874", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ 列挙 \/ デクラレーション ", 
"snippet" : "構文 {attribute 'strict'} TYPE <enumeration name> : (     <member name> := <value> ) <base data type> := <initialization> ; END_TYPE {attribute 'strict'} [オプション] プラグマには、以下のように厳密な型テストを行うという効果があります。 プラグマはオプションですが、推奨されます。 <enumeration name> コードでデータ型として使用できる列挙の名前 例: COLOR_BASIC     <member name> := <initi...", 
"body" : "構文 {attribute 'strict'} TYPE <enumeration name> : (     <member name> := <value> ) <base data type> := <initialization> ; END_TYPE {attribute 'strict'} [オプション] プラグマには、以下のように厳密な型テストを行うという効果があります。 プラグマはオプションですが、推奨されます。 <enumeration name> コードでデータ型として使用できる列挙の名前 例: COLOR_BASIC     <member name> := <initial value> 任意の数のメンバー、ただし少なくとも 2 人のメンバー 列挙は、カンマで区切られたメンバー名を丸括弧で囲んだリストです。閉じ角括弧の前の最後のメンバーにはカンマは必要ありません。すべてのメンバーのデータ型は同じです メンバーの値は自動的に初期化されます。0 から始まり、値は連続的に 1 ずつ増加します。個々のメンバーに固定の初期値を明示的に割り当てることもできます 例: yellow := 1 <base data type> [オプション] 次の基本データ型のいずれかを明示的に割り当てることができます。 INT | UINT | SINT | USINT | DINT | UDINT | LINT | ULINT | BYTE | WORD | DWORD | LWORD デフォルト: INT := <initialization> [オプション] メンバーの 1 つを初期メンバーとして明示的に宣言できます。 デフォルト:初期化が明示的に指定されていない場合、初期化は最上位メンバーで自動的に実行されます。 例 {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE COLOR_BASIC :\n(\n yellow,\n green,\n blue,\n black\n) \/\/ Basic data type is INT, default initialization for all COLOR_BASIC variables is yellow\n;\nEND_TYPE " }, 
{ "title" : "明示的な基本データ型による列挙 ", 
"url" : "_cds_datatype_enum.html#UUID-1311dba6-f878-87c0-5628-03d3a9b811e5_id_c02c7c93f57fccc0a8640e014fa9b7_id_eeaeeade1efde45ac0a864636eafe5b8", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ 列挙 \/ 明示的な基本データ型による列挙 ", 
"snippet" : "IEC 61131-3 スタンダードの拡張 列挙宣言の基本データ型は INT デフォルトです。ただし、別の整数データ型を明示的に基にした列挙を宣言することもできます 例 基本データ型による列挙 DWORD TYPE COLOR : ( white := 16#FFFFFF00, yellow := 16#FFFFFF00, green := 16#FF00FF00, blue := 16#FF0000FF, black := 16#88000000 ) DWORD := black ; \/\/ Basic data type is DWORD, default initialization fo...", 
"body" : "IEC 61131-3 スタンダードの拡張 列挙宣言の基本データ型は INT デフォルトです。ただし、別の整数データ型を明示的に基にした列挙を宣言することもできます 例 基本データ型による列挙 DWORD TYPE COLOR :\n(\n white := 16#FFFFFF00,\n yellow := 16#FFFFFF00,\n green := 16#FF00FF00,\n blue := 16#FF0000FF,\n black := 16#88000000\n) DWORD := black\n; \/\/ Basic data type is DWORD, default initialization for all COLOR variables is black\nEND_TYPE " }, 
{ "title" : "厳格なプログラミング規則 ", 
"url" : "_cds_datatype_enum.html#UUID-1311dba6-f878-87c0-5628-03d3a9b811e5_id_c02c7c93f57fccc0a8640e014fa9b7_id_9f56ad50bcf5b28cc0a8640e01b52258", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ 列挙 \/ 厳格なプログラミング規則 ", 
"snippet" : "で CODESYS V3.5 SP7 以降では、プラグマが使われています。 {attribute 'strict'} 列挙を宣言すると、最初の行に自動的に追加されます。 プラグマを追加すると、厳密なプログラミングルールが有効になります。 {attribute 'strict'} 。 次のコードはコンパイラエラーとみなされます。 列挙型メンバーによる算術演算 たとえば、列挙型変数を a のカウンタ変数として使用することはできません。 FOR ループ。 列挙値に対応しない定数値の列挙メンバーへの代入 列挙型として別のデータ型を持つ非定数変数の列挙メンバーへの代入 算術演算を行うと、宣言されていない...", 
"body" : "で CODESYS V3.5 SP7 以降では、プラグマが使われています。 {attribute 'strict'} 列挙を宣言すると、最初の行に自動的に追加されます。 プラグマを追加すると、厳密なプログラミングルールが有効になります。 {attribute 'strict'} 。 次のコードはコンパイラエラーとみなされます。 列挙型メンバーによる算術演算 たとえば、列挙型変数を a のカウンタ変数として使用することはできません。 FOR ループ。 列挙値に対応しない定数値の列挙メンバーへの代入 列挙型として別のデータ型を持つ非定数変数の列挙メンバーへの代入 算術演算を行うと、宣言されていない値が列挙メンバーに割り当てられる可能性があります。より適切なプログラミング・スタイルは、を使用することです。 SWITCH \/ CASE メンバー値を処理するためのステートメント。 " }, 
{ "title" : "列挙変数の宣言と初期化 ", 
"url" : "_cds_datatype_enum.html#UUID-1311dba6-f878-87c0-5628-03d3a9b811e5_id_c02c7c93f57fccc0a8640e014fa9b7_id_c30c45711efde45ac0a864630973c0ee", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ 列挙 \/ 列挙変数の宣言と初期化 ", 
"snippet" : "構文 <variable name> : <enumeration name> := <initialization> ; ユーザー定義の列挙を使用して列挙変数を宣言する場合、変数は列挙メンバーで初期化できます。 例 PROGRAM PLC_PRG VAR colorCar: COLOR; colorTaxi : COLOR := COLOR.yellow; END_VAR 変数 colorCar で初期化されます COLOR.black 。これが、型のすべての列挙型変数のデフォルト初期化です COLOR 型宣言でこのように定義されています。 colorTaxi 独自の初期化機能があります。 ...", 
"body" : "構文 <variable name> : <enumeration name> := <initialization> ; ユーザー定義の列挙を使用して列挙変数を宣言する場合、変数は列挙メンバーで初期化できます。 例 PROGRAM PLC_PRG\nVAR\n colorCar: COLOR;\n colorTaxi : COLOR := COLOR.yellow;\nEND_VAR 変数 colorCar で初期化されます COLOR.black 。これが、型のすべての列挙型変数のデフォルト初期化です COLOR 型宣言でこのように定義されています。 colorTaxi 独自の初期化機能があります。 初期化が指定されていない場合、初期化値は 0 です。 例 PROGRAM PLC_PRG\nVAR\n cbFlower : COLOR_BASIC;\n cbTree: COLOR_BASIC := COLOR_BASIC.green;\nEND_VAR 変数 cbFlower で初期化されます COLOR_BASIC.yellow 。これが、型のすべての列挙型変数のデフォルト初期化です COLOR_BASIC 。列挙宣言では初期化するメンバーを指定していないため、システムは値が 0 のメンバーで自動的に初期化されます。通常、これは列挙メンバーのうちの最初のメンバーです。ただし、最初の位置にはないが明示的に 0 で初期化された別のメンバーでもかまいません 変数 cbTree 明示的な初期化が行われている。 タイプと変数の両方に値を指定しない場合は、次のルールが適用されます。列挙に 0 の値が含まれている場合、この値がデフォルトの初期化になり、含まれていない場合は、リストの最初のメンバーになります。 例 0 メンバーによる初期化 TYPE ENUM :\n(\n e1 := 2,\n e2 := 0,\n e3\n)\n;\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n e : ENUM;\nEND_VAR 変数 e で初期化されます ENUM.e2 。 最初のメンバーによる初期化 TYPE ENUM2 :\n(\n e1 := 3,\n e2 := 1,\n e3\n)\n;\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n e2 : ENUM2;\nEND_VAR 変数 e2 で初期化されます ENUM.e1 。 " }, 
{ "title" : "列挙メンバーへのユニークなアクセス ", 
"url" : "_cds_datatype_enum.html#UUID-1311dba6-f878-87c0-5628-03d3a9b811e5_id_c02c7c93f57fccc0a8640e014fa9b7_id_fb7c51f31efde45ac0a864636cadf959", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ 列挙 \/ 列挙メンバーへのユニークなアクセス ", 
"snippet" : "IEC 61131-3 スタンダードの拡張 列挙メンバーは、識別子 <enumeration name>.<member name> . を使用して定数変数としても使用できます。列挙メンバーはプロジェクト全体で認識され、それらへのアクセスは一意です。したがって、メンバー名は異なる列挙で使用できます。 例 メンバー: blue PROGRAM PLC_PRG VAR cbFlower : COLOR_BASIC; colorCar : COLOR; END_VAR (* unambiguous identifiers although the component names are identi...", 
"body" : "IEC 61131-3 スタンダードの拡張 列挙メンバーは、識別子 <enumeration name>.<member name> . を使用して定数変数としても使用できます。列挙メンバーはプロジェクト全体で認識され、それらへのアクセスは一意です。したがって、メンバー名は異なる列挙で使用できます。 例 メンバー: blue PROGRAM PLC_PRG\nVAR\n cbFlower : COLOR_BASIC;\n colorCar : COLOR;\nEND_VAR\n\n(* unambiguous identifiers although the component names are identical *)\ncbFlower := COLOR_BASIC.blue;\ncolorCar := COLOR.blue;\n\n(* invalid code *)\ncbFlower := blue;\ncolorCar := blue; 詳細については、以下を参照してください。 列挙型名前空間。 " }, 
{ "title" : "データ型: 暗黙の列挙 ", 
"url" : "_cds_datatype_implicit_enumeration-1853150.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ データ型: 暗黙の列挙 ", 
"snippet" : "暗黙の列挙 暗黙的な列挙により、ローカル POU 内でのみ有効な新しい列挙変数を簡単に宣言できます。このタイプの変数は、コンポーネント リストで宣言されている限られた数の整数値を取ることができます。 暗黙的な列挙には、データ型の名前または識別子がありません。 宣言 : <variable name> : ( <list of component names> ) := <initialization>; <list of component names> 必要な数のコンポーネントを含むコンポーネント名のカンマ区切りリスト 各コンポーネントは、0 から始まる整数値を表します。次のコンポーネントの...", 
"body" : "暗黙の列挙 暗黙的な列挙により、ローカル POU 内でのみ有効な新しい列挙変数を簡単に宣言できます。このタイプの変数は、コンポーネント リストで宣言されている限られた数の整数値を取ることができます。 暗黙的な列挙には、データ型の名前または識別子がありません。 宣言 : <variable name> : ( <list of component names> ) := <initialization>; <list of component names> 必要な数のコンポーネントを含むコンポーネント名のカンマ区切りリスト 各コンポーネントは、0 から始まる整数値を表します。次のコンポーネントの値は、毎回 1 ずつ増加します。 例： Alfa, Bravo, Charlie, Delta, Echo コンポーネントに固定値を割り当てることもできます。 例： Zero, Alfa:=10, Bravo:=20, Charlie:=30, Delta:=40, Echo <initialization> オプション 初期値、通常はコンポーネント 電話 : 例 PROGRAM PLC_PRG\nVAR\n iAlphabet : (Alfa, Bravo, Charlie, Delta, Echo) := Echo;\n strText : STRING;\n iNumber : INT;\nEND_VAR CASE iAlphabet OF\n\tAlfa:\n\tstrText := 'A';\n\t\n\tBravo: \n\tstrText := 'B';\n\t\n\tCharlie:\n\tstrText := 'C';\n\t\n\tDelta:\n\tstrText := 'D';\n\t\n\tEcho:\n\tstrText := 'E';\nEND_CASE\niNumber := iAlphabet; " }, 
{ "title" : "内部データ型 ", 
"url" : "_cds_datatype_implicit_enumeration-1853150.html#UUID-b7c570d8-99e1-924b-7984-9849eebb5a31_section-idm4597855524900833552049065596", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ データ型: 暗黙の列挙 \/ 内部データ型 ", 
"snippet" : "暗黙的な列挙では、データ型が内部的に作成され、その名前は次のスキームに従います。 IMPLICIT_ENUM_ <POU name> _ <variable name> ただし、内部識別子が異なる可能性は常にあるため、この内部識別子は使用しないでください。...", 
"body" : "暗黙的な列挙では、データ型が内部的に作成され、その名前は次のスキームに従います。 IMPLICIT_ENUM_ <POU name> _ <variable name> ただし、内部識別子が異なる可能性は常にあるため、この内部識別子は使用しないでください。 " }, 
{ "title" : "Alias ", 
"url" : "_cds_datatype_alias.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ Alias ", 
"snippet" : "データ型エイリアスは、基本型、データ型、または機能ブロックの代替名が生成されるユーザー定義のデータ型の宣言です。 でエイリアスの型宣言を行います DUT で作成したオブジェクト プロジェクト → [オブジェクトを追加] → ダクト メニューまたはアプリケーションのコンテキストメニューにあります。 詳細については、以下を参照してください。 DUT...", 
"body" : "searchresult_toplevel データ型エイリアスは、基本型、データ型、または機能ブロックの代替名が生成されるユーザー定義のデータ型の宣言です。 でエイリアスの型宣言を行います DUT で作成したオブジェクト プロジェクト → [オブジェクトを追加] → ダクト メニューまたはアプリケーションのコンテキストメニューにあります。 詳細については、以下を参照してください。 DUT" }, 
{ "title" : "構文 ", 
"url" : "_cds_datatype_alias.html#UUID-01335fef-6db0-3bdd-bc29-f0b6e4b38b03_section-idm234801418271509", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ Alias \/ 構文 ", 
"snippet" : "TYPE <identifier> : <data type name> ; END_TYPE 許可されるタイプ <type name> 基本データタイプ 指定されたサイズのデータ型 ファンクションブロック 例 型の変数のエイリアスデータ型 STRING または ARRAY 特定の長さが必要な場合 デクラレーション TYPE FRAME : ARRAY[0..1499] OF BYTE; END_TYPE TYPE SYMBOL : STRING(512); END_TYPE コール PROGRAM PLC_PRG VAR frameF : FRAME; symbolS : SYMBOL; E...", 
"body" : "TYPE <identifier> : <data type name> ; END_TYPE 許可されるタイプ <type name> 基本データタイプ 指定されたサイズのデータ型 ファンクションブロック 例 型の変数のエイリアスデータ型 STRING または ARRAY 特定の長さが必要な場合 デクラレーション TYPE FRAME : ARRAY[0..1499] OF BYTE; END_TYPE\nTYPE SYMBOL : STRING(512); END_TYPE コール PROGRAM PLC_PRG\nVAR\n\tframeF : FRAME;\n\tsymbolS : SYMBOL;\nEND_VAR 例 コンパイラーが提供するものとは異なる初期値を必要とする変数のエイリアスデータ型 TYPE INDEX : DINT := -1; END_TYPE 例 元の型の特定の値のサブセットのみを適用する必要がある特定の型の変数のエイリアスデータ型 {attribute 'qualified_only'}\nVAR_GLOBAL CONSTANT\n\tc_diMaxRune : DINT := DINT#16#0010FFFF;\nEND_VAR TYPE RUNE : DINT(0..GVL.c_diMaxRune); END_TYPE 例 別の名前空間の型のエイリアスデータ型 たとえば、現在の名前空間で利用できるはずの下位ライブラリの型の場合。 TYPE ENCODING: SBB.ENCODING; END_TYPE (*ENUM*)\nTYPE RUNE : UTF8.RUNE; END_TYPE (*SUBTYPE*)\nTYPE INFO : STR.IFNFO; END_TYPE (*STRUCT*)\nTYPE IBuilder : SBB.IBuilder; END_TYPE (*INTERFACE*)\nTYPE Tange: SBB.Range; END_TYPE (*FUNCTION_BLOCK*) つまり、多くの場合、コンテナライブラリは省略できます。これは、すべての種類の下位ライブラリがこの方法で独自のライブラリの一部になるためです。 " }, 
{ "title" : "データ構造: UNION ", 
"url" : "_cds_datatype_union.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ データ構造: UNION ", 
"snippet" : "UNION UNION はユーザー定義のデータ構造で、そのメンバーのデータ型とサイズは通常異なります。 a のインスタンスのメンバー UNION データ型はすべて同じメモリ空間を予約します。すべてのメンバーが同じアドレスオフセットを持ち、メモリを共有します。メモリ要件は、最も大きいメンバーによって決まります。 UNION  変数は、正確に1つのメンバーの値を格納します。メモリには最後に割り当てられた値が含まれています。つまり、メモリが効率的に使用されているということです。 詳細については、「オブジェクト:」を参照してください。 DUT...", 
"body" : "UNION UNION はユーザー定義のデータ構造で、そのメンバーのデータ型とサイズは通常異なります。 a のインスタンスのメンバー UNION データ型はすべて同じメモリ空間を予約します。すべてのメンバーが同じアドレスオフセットを持ち、メモリを共有します。メモリ要件は、最も大きいメンバーによって決まります。 UNION  変数は、正確に1つのメンバーの値を格納します。メモリには最後に割り当てられた値が含まれています。つまり、メモリが効率的に使用されているということです。 詳細については、「オブジェクト:」を参照してください。 DUT" }, 
{ "title" : "タイプ宣言 ", 
"url" : "_cds_datatype_union.html#UUID-77065fbb-1927-c31d-6119-69d4ab77180a_section-idm234800958617735", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ データ構造: UNION \/ タイプ宣言 ", 
"snippet" : "構文: TYPE <identifier> UNION    <member name> : <data type> := <initialization> ; END_UNION END_TYPE <member name> : <data type> ; 基本データ型のメンバーの宣言 宣言はいくつでも構いませんが、少なくとも 2 つは必要です。 := <initialization> [オプション] 例 タイプ宣言: U_VAR_12 TYPE U_VAR_12: UNION wVar1: WORD; byVar2 : BYTE; END_UNION END_TYPE タイプ宣言: U_I...", 
"body" : "構文: TYPE <identifier> UNION    <member name> : <data type> := <initialization> ; END_UNION END_TYPE <member name> : <data type> ; 基本データ型のメンバーの宣言 宣言はいくつでも構いませんが、少なくとも 2 つは必要です。 := <initialization> [オプション] 例 タイプ宣言: U_VAR_12 TYPE U_VAR_12:\nUNION\n wVar1: WORD;\n byVar2 : BYTE;\nEND_UNION\nEND_TYPE タイプ宣言: U_INT_ID TYPE U_INT_ID:\nUNION\n iVar: INT;\n dVar : DINT;\nEND_UNION\nEND_TYPE タイプ宣言: U_EFFICIENT TYPE U_EFFICIENT\nUNION\n wMember : WORD;\n dwMember : DWORD;\n strMember : STRING := 'A'; \nEND_UNION\nEND_TYPE " }, 
{ "title" : "変数宣言 ", 
"url" : "_cds_datatype_union.html#UUID-77065fbb-1927-c31d-6119-69d4ab77180a_section-idm234800997913516", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ データ構造: UNION \/ 変数宣言 ", 
"snippet" : "a の変数のインスタンス化\/宣言 UNION データタイプ: <variable name> : <name UNION type> := <initialization> ; := <initialization> [オプション] := ( <member name> := <literal> ) 初期化の詳細: 代入演算子の後には、丸括弧で囲まれたメンバーへの初期値の代入が続きます。 例 TYPE U_AB: UNION lrA : LREAL; liB : LINT; END_UNION END_TYPE 初期化を伴う変数宣言 PLC_PRG PROGRAM VAR uabVAR_1 :...", 
"body" : "a の変数のインスタンス化\/宣言 UNION データタイプ: <variable name> : <name UNION type> := <initialization> ; := <initialization> [オプション] := ( <member name> := <literal> ) 初期化の詳細: 代入演算子の後には、丸括弧で囲まれたメンバーへの初期値の代入が続きます。 例 TYPE U_AB:\nUNION\n lrA : LREAL;\n liB : LINT;\nEND_UNION\nEND_TYPE 初期化を伴う変数宣言 PLC_PRG PROGRAM\nVAR\n uabVAR_1 : U_AB := (lrA := LREAL#1.5);\n uabVAR_2 : U_AB := (liB := LINT#1);\nEND_VAR 例 での変数宣言 PLC_PRG データ型付き U_EFFICIENT PLC_PRG PROGRAM\nVAR\n uefficient_1 : U_EFFICIENT := (strMember := 'A');\nEND_VAR\n 実装: PLC_PRG uefficient_1.wMember := 16#000A;\n いつ uefficient_1 が変数のメンバーに書き込まれると、変数のすべてのメンバーに影響します。 " }, 
{ "title" : "サブレンジタイプ ", 
"url" : "_cds_datatype_subint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ ユーザー定義のデータ型：TYPE \/ サブレンジタイプ ", 
"snippet" : "サブレンジ サブ範囲タイプは、値の範囲が基本タイプのサブセットであるデータ型です。 宣言の構文： <variabel name> : <integer type> ( <lower index limit> .. <upper index limit> ) <variable name> 有効なIEC識別子 詳細については、以下を参照してください。 識別子の指定<integer data type> サブレンジの整数基本データ型 SINT 、 USINT 、 INT 、 UINT 、 DINT 、 UDINT 、 BYTE 、 WORD 、 DWORD 、 LINT 、 ULINT 、 LWO...", 
"body" : "サブレンジ サブ範囲タイプは、値の範囲が基本タイプのサブセットであるデータ型です。 宣言の構文： <variabel name> : <integer type> ( <lower index limit> .. <upper index limit> ) <variable name> 有効なIEC識別子 詳細については、以下を参照してください。 識別子の指定<integer data type> サブレンジの整数基本データ型 SINT 、 USINT 、 INT 、 UINT 、 DINT 、 UDINT 、 BYTE 、 WORD 、 DWORD 、 LINT 、 ULINT 、 LWORD <lower index limit> 基本データ型と互換性がなければならない領域の下限の定数 下限自体はこの範囲に含まれます。 <upper index limit> 基本データ型と互換性がなければならない領域の上限の定数 上限もこの範囲に含まれます。 VAR\n i : INT (-4095..4095);\n ui : UINT (0..10000);\nEND_VAR\n この範囲内にない宣言または実装部分のサブ範囲タイプに値を割り当てる場合は、 CODESYS エラーメッセージを発行します。 i:=5000 \/\/Results in an error message 注：ランタイムモードでは、暗黙的な監視機能を使用して、サブ範囲タイプの範囲制限を監視できます。 CheckRangeSigned と CheckRangeUnsigned 。 " }, 
{ "title" : "データ型：__ VECTOR ", 
"url" : "_cds_data_type_vector.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：__ VECTOR ", 
"snippet" : "__VECTOR ベクトル演算は64ビットプロセッサでのみネイティブにサポートされており、これらのプロセッサでのみパフォーマンス上の利点があります。コントローラのデータシートには、コントローラで使用されているプロセッサに関する情報が記載されています。 現在、SSE2を使用するx86 \/ 64ビットプラットフォームおよびNEONを使用するARM64でのベクトル演算がネイティブにサポートされています。他のすべてのプラットフォームでは、ベクトル演算は個々のステートメントに変換されます。たとえば、ベクトル加算は複数の単一加算演算で実行されます。 プロセッサのコマンドセット拡張はSIMD拡張です。 SI...", 
"body" : "__VECTOR ベクトル演算は64ビットプロセッサでのみネイティブにサポートされており、これらのプロセッサでのみパフォーマンス上の利点があります。コントローラのデータシートには、コントローラで使用されているプロセッサに関する情報が記載されています。 現在、SSE2を使用するx86 \/ 64ビットプラットフォームおよびNEONを使用するARM64でのベクトル演算がネイティブにサポートされています。他のすべてのプラットフォームでは、ベクトル演算は個々のステートメントに変換されます。たとえば、ベクトル加算は複数の単一加算演算で実行されます。 プロセッサのコマンドセット拡張はSIMD拡張です。 SIMD（単一命令、複数データ）は、同じタイプの複数のデータセットが同時に並行して処理されるため、1回のコマンド呼び出しでより高速になるコンピューターアーキテクチャーを表します。たとえば、ベクトル演算では、4組の数値を同時に加算できます。 構文 <variable name> : __VECTOR[ <vector size> ] OF <element type> := <initialization> ;\n\n<vector size> : 1 |2 | 3 | 4 | 5| 6 | 7| 8\n<element type> : REAL | LREAL\n 変数の初期化はオプションです。 ベクトルデータ型は、最大8つの要素を持つ浮動小数点数の配列です。 The __vc<operator name> このデータ型には演算子を使用できます。これらを使用して、追加の関数呼び出しなしでベクトル演算を実装できます。 インデックスアクセスの構文 <variable name>[ <index> ]\n<index> : 0 | 1 | 2| 3 | 4 | 5| 6 | 7 ベクトル変数にインデックスを付けるときは、ベクトルの1つの要素にアクセスできます。インデックスは0から始まり、<ベクトルサイズ> -1まで続きます。 PROGRAM PLC_PRG\nVAR\n vcA : __VECTOR[3] OF REAL;\nEND_VAR\n\nvcA[0] := 1.1;\nvcA[1] := 2.2;\nvcA[2] := 3.3; " }, 
{ "title" : "最適なベクトルサイズの決定 ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-0af01dd3-fba8-5c57-0513-a55c61c26714", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：__ VECTOR \/ 最適なベクトルサイズの決定 ", 
"snippet" : "可能な限り最も効率的なコードをプログラムするために、ターゲットシステムに応じて最適なベクトルサイズをベクトルサイズとして使用します。 コンピュータアーキテクチャが一般的にベクトル処理に適しているターゲットシステムの場合、任意のサイズのベクトルを使用することはお勧めしません。プロセッサのデータ処理のタイプに応じて、最適なベクトルサイズがあります。この配列サイズで宣言されたベクトルは、可能な限り迅速に処理されます。より大きな配列として宣言されたベクトルには、速度の利点はありません。より小さな配列として宣言されたベクトルは、プロセッサの機能を十分に活用していません。 実行時に最適なサイズを照会できま...", 
"body" : "可能な限り最も効率的なコードをプログラムするために、ターゲットシステムに応じて最適なベクトルサイズをベクトルサイズとして使用します。 コンピュータアーキテクチャが一般的にベクトル処理に適しているターゲットシステムの場合、任意のサイズのベクトルを使用することはお勧めしません。プロセッサのデータ処理のタイプに応じて、最適なベクトルサイズがあります。この配列サイズで宣言されたベクトルは、可能な限り迅速に処理されます。より大きな配列として宣言されたベクトルには、速度の利点はありません。より小さな配列として宣言されたベクトルは、プロセッサの機能を十分に活用していません。 実行時に最適なサイズを照会できます。あなたは定数で情報を見つけることができます Constants.vcOptimalREAL （ベクトルの場合 REAL 要素）と Constants.vcOptimalLREAL （ベクトルの場合 LREAL 要素）。定数には LREAL データ・タイプ。定数が値を返す場合 1 最適値として、これは加速ベクトル処理がターゲットシステムで利用できないことを意味します。 PROGRAM PLC_PRG\nVAR\n iOVS_REAL : INT; \/\/ Optimal vector size for REAL eleements\n iOVS_LREAL : INT; \/\/ Optimal vector size for LREAL eleements\nEND_VAR\n\niOVS_REAL := Constants.vcOptimalREAL;\niOVS_LREAL := Constants.vcOptimalLREAL; にロードされるアプリケーション CODESYS Control Win V3 x64ターゲットシステムは、実行時に次の値を返します。 " }, 
{ "title" : "演算子：__ VCADD ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-f39e8b61-1c8e-f75f-fc5c-a2ab4edf25da", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：__ VECTOR \/ 演算子：__ VCADD ", 
"snippet" : "オペレーターは、2つのベクトルの合計を計算します。 構文 <vector variable> := <1st vector operand> __VCADD <2nd vector operand>; 添加 FUNCTION_BLOCK FB_ADD VAR vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3); vcResult : __VECTOR[3] OF REAL; END_VAR vcResult := vcA __VCADD vc...", 
"body" : "オペレーターは、2つのベクトルの合計を計算します。 構文 <vector variable> := <1st vector operand> __VCADD <2nd vector operand>; 添加 FUNCTION_BLOCK FB_ADD\nVAR\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3);\n vcResult : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult := vcA __VCADD vcB; " }, 
{ "title" : "演算子：__ VCSUB ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-f310d6e4-89f2-14f1-3296-ddf6afcfffcb", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：__ VECTOR \/ 演算子：__ VCSUB ", 
"snippet" : "演算子は、2つのベクトル間の差を計算します。 構文 <vector variable> := <vector minuend> __VCSUB <vector subtrahend>; 減算 FUNCTION_BLOCK FB_SUB VAR vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3); vcResult0 : __VECTOR[3] OF REAL; vcResult1 : __VECTOR[3] OF REAL; END_VAR ...", 
"body" : "演算子は、2つのベクトル間の差を計算します。 構文 <vector variable> := <vector minuend> __VCSUB <vector subtrahend>; 減算 FUNCTION_BLOCK FB_SUB\nVAR\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3);\n vcResult0 : __VECTOR[3] OF REAL;\n vcResult1 : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult0 := vcA __VCSUB vcB;\nvcResult1 := vcB __VCSUB vcA; " }, 
{ "title" : "演算子：__ VCMUL ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-55d1650e-3133-2368-d000-e3a75e0d705b", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：__ VECTOR \/ 演算子：__ VCMUL ", 
"snippet" : "演算子は、2つのベクトルまたはスカラー（浮動小数点数）とベクトルの積を計算します。 構文 <vector variable> := <1st vector operand> __VCMUL <2nd vector operand> | <scalar operand> __VCMUL <vector operand> | <vector operand> __VCMUL <scalar operand> ; 乗算 FUNCTION_BLOCK FB_MUL VAR rScalar : REAL := 1.1; vcA : __VECTOR[3] OF REAL; vcB : __VECTOR[...", 
"body" : "演算子は、2つのベクトルまたはスカラー（浮動小数点数）とベクトルの積を計算します。 構文 <vector variable> := <1st vector operand> __VCMUL <2nd vector operand> | <scalar operand> __VCMUL <vector operand> | <vector operand> __VCMUL <scalar operand> ; 乗算 FUNCTION_BLOCK FB_MUL\nVAR\n rScalar : REAL := 1.1;\n vcA : __VECTOR[3] OF REAL;\n vcB : __VECTOR[3] OF REAL;\n vcResult0 : __VECTOR[3] OF REAL;\n vcResult1 : __VECTOR[3] OF REAL;\n vcResult2 : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult0 := vcA __VCMUL vcB;\nvcResult1 := rScalar __VCMUL vcB;\nvcResult2 := vcA __VCMUL 3.3; " }, 
{ "title" : "演算子：__ VCDIV ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-77b2ab29-e8c3-1279-603e-d874d377ca91", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：__ VECTOR \/ 演算子：__ VCDIV ", 
"snippet" : "演算子は、2つのベクトル、またはベクトルとスカラーの商を計算します。 構文 <vector variable> := <vector dividend> __VCDIV <vector divisor> | < vector dividend> __VCMUL <scalar divisor> ; 分割 FUNCTION_BLOCK FB_DIV VAR iScalar : INT := 3; rScalar : REAL := 1.5; vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VECTOR[3] OF REAL ...", 
"body" : "演算子は、2つのベクトル、またはベクトルとスカラーの商を計算します。 構文 <vector variable> := <vector dividend> __VCDIV <vector divisor> | < vector dividend> __VCMUL <scalar divisor> ; 分割 FUNCTION_BLOCK FB_DIV\nVAR\n iScalar : INT := 3;\n rScalar : REAL := 1.5;\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3);\n vcResult0 : __VECTOR[3] OF REAL;\n vcResult1 : __VECTOR[3] OF REAL;\n vcResult2 : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult0 := vcA __VCDIV vcB;\n\/\/ ERROR CODE vcResult1 := rScalar __VCDIV vcB;\n\/\/ ERROR CODE vcResult1 := iScalar __VCDIV vcB;\n\/\/ ERROR CODE vcResult1 := 3.3 __VCDIV vcB;\nvcResult2 := vcA __VCDIV 1.5;\nvcResult2 := vcA __VCDIV iScalar;\nvcResult2 := vcA __VCDIV rScalar; " }, 
{ "title" : "演算子：__ VCDOT ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-fed81759-f085-d6b5-cffb-5e72db7228c4", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：__ VECTOR \/ 演算子：__ VCDOT ", 
"snippet" : "演算子は、2つのベクトルの内積（スカラー積）を計算します。 構文 <skalar variable> := <1st vector operand> __VCDOT <2nd vector operand> ; ドット積 FUNCTION_BLOCK FB_DOT VAR rResult : REAL; vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3); END_VAR rResult := vcA __VCDOT vcB; \/\/ = 18...", 
"body" : "演算子は、2つのベクトルの内積（スカラー積）を計算します。 構文 <skalar variable> := <1st vector operand> __VCDOT <2nd vector operand> ; ドット積 FUNCTION_BLOCK FB_DOT\nVAR\n rResult : REAL;\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3);\nEND_VAR\nrResult := vcA __VCDOT vcB; \/\/ = 18 " }, 
{ "title" : "演算子：__ VCSQRT ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-45327657-b65b-af06-a4e5-2d3e69420c0f", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：__ VECTOR \/ 演算子：__ VCSQRT ", 
"snippet" : "演算子は、ベクトル内の各要素の平方根を計算します。 構文 <vector variable> := __VCSQRT( <vector operand> ); 平方根 FUNCTION_BLOCK FB_SQRT VAR vcA : __VECTOR[3] OF REAL := __VCSET_REAL(4, 9, 16); vcResult0 : __VECTOR[3] OF REAL; END_VAR vcResult0 := __VCSQRT(vcA);...", 
"body" : "演算子は、ベクトル内の各要素の平方根を計算します。 構文 <vector variable> := __VCSQRT( <vector operand> ); 平方根 FUNCTION_BLOCK FB_SQRT\nVAR\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(4, 9, 16);\n vcResult0 : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult0 := __VCSQRT(vcA); " }, 
{ "title" : "演算子：__ VCMAX ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-a9f598fc-3f59-dfd8-7e18-b3d2aab0f705", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：__ VECTOR \/ 演算子：__ VCMAX ", 
"snippet" : "オペレーターは、2つのベクトルの最大ベクトルを計算します。最大値は要素ごとに決定されます。 構文 <vector variable> := __VCMAX( <1st vector operand>, <2nd vector operand>); 最大ベクトル FUNCTION_BLOCK FB_MAX VAR vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 6); vcResult0 : __VECTOR[3] OF REAL; END_VA...", 
"body" : "オペレーターは、2つのベクトルの最大ベクトルを計算します。最大値は要素ごとに決定されます。 構文 <vector variable> := __VCMAX( <1st vector operand>, <2nd vector operand>); 最大ベクトル FUNCTION_BLOCK FB_MAX\nVAR\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 6);\n vcResult0 : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult0 := __VCMAX(vcA, vcB); " }, 
{ "title" : "演算子：__ VCMIN ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-39832f61-8b64-561c-96f3-95f93a92e2aa", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：__ VECTOR \/ 演算子：__ VCMIN ", 
"snippet" : "オペレーターは、2つのベクトルの最小ベクトルを計算します。最小値は要素ごとに決定されます。 構文 <vector variable> := __VCMIN( <1st vector operand>, <2nd vector operand>); 最小ベクトルの例 FUNCTION_BLOCK FB_MIN VAR vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 6); vcResult0 : __VECTOR[3] OF REAL; END_...", 
"body" : "オペレーターは、2つのベクトルの最小ベクトルを計算します。最小値は要素ごとに決定されます。 構文 <vector variable> := __VCMIN( <1st vector operand>, <2nd vector operand>); 最小ベクトルの例 FUNCTION_BLOCK FB_MIN\nVAR\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 6);\n vcResult0 : __VECTOR[3] OF REAL;\nEND_VAR\nvcResult0 := __VCMIN(vcA, vcB); " }, 
{ "title" : "演算子：__ VCSET_REAL ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-fded852c-b429-752f-fdaf-5036b3560478", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：__ VECTOR \/ 演算子：__ VCSET_REAL ", 
"snippet" : "演算子は、ベクトルのすべての要素をステートメントに設定します。要素には REAL データ・タイプ。 構文 <vector variable> := __VCSET_REAL( <first literal>, ( < next literal> )+ ) ; ( ... )+ \/\/ number of elements have to match FUNCTION_BLOCK FB_SET VAR vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3); vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2,...", 
"body" : "演算子は、ベクトルのすべての要素をステートメントに設定します。要素には REAL データ・タイプ。 構文 <vector variable> := __VCSET_REAL( <first literal>, ( < next literal> )+ ) ;\n( ... )+ \/\/ number of elements have to match FUNCTION_BLOCK FB_SET\nVAR\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\n vcB : __VECTOR[3] OF REAL := __VCSET_REAL(1, 2, 3);\nEND_VAR\nvcA := __VCSET_REAL(4, 4, 4);\nvcB := __VCSET_REAL(1.1, 2.2, 3.3); " }, 
{ "title" : "演算子：__ VCSET_LREAL ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-b7e3f598-67c3-81cc-c496-d773363bb3d7", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：__ VECTOR \/ 演算子：__ VCSET_LREAL ", 
"snippet" : "演算子は、ベクトルのすべての要素をステートメントに一度に設定します。要素には LREAL データ・タイプ。 これらは、実装での割り当てや関数呼び出しでのパラメーターなど、変数が有効な場所であればどこでも使用できます。 構文 <vector variable> := __VCSET_LREAL( <first literal>, ( < next literal> )+ ) ; ( ... )+ \/\/ number of elements have to match FUNCTION_BLOCK FB_SET VAR vclA : __VECTOR[3] OF LREAL := __VCSET_...", 
"body" : "演算子は、ベクトルのすべての要素をステートメントに一度に設定します。要素には LREAL データ・タイプ。 これらは、実装での割り当てや関数呼び出しでのパラメーターなど、変数が有効な場所であればどこでも使用できます。 構文 <vector variable> := __VCSET_LREAL( <first literal>, ( < next literal> )+ ) ;\n( ... )+ \/\/ number of elements have to match FUNCTION_BLOCK FB_SET\nVAR\n vclA : __VECTOR[3] OF LREAL := __VCSET_LREAL(3, 3, 3);\n vclB : __VECTOR[3] OF LREAL := __VCSET_LREAL(1, 2, 3);\nEND_VAR\nvclA := __VCSET_LREAL(-1.7976931348623158E+308, 0.0, 1.7976931348623158E+308);\nvclB := __VCSET_LREAL(-1.7976931348623158E+308, 0.0, 1.7976931348623158E+308); " }, 
{ "title" : "演算子：__ VCLOAD_REAL ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-4cdb7360-779e-c920-db0b-dd01f936bfad", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：__ VECTOR \/ 演算子：__ VCLOAD_REAL ", 
"snippet" : "演算子は、任意のメモリ領域をベクトルとして解釈します。これは、ベクトル変数を既存のコードに接続するのに役立ちます。オペレーターには2つのパラメーターが必要です。最初のパラメーターは、ベクトル要素の数を示します。 2番目のパラメーターは、 REAL データ。 __VCLOAD_REAL(<n>,<ptr>) 読み取り <n> での連続するREAL値 <ptr> 住所。未満の場合 <n> このアドレスに値があると、コントローラーがクラッシュしたり、不要なメモリを読み取ったりする可能性があります。 構文 <vector variable> := __VCLOAD_REAL( <vector size...", 
"body" : "演算子は、任意のメモリ領域をベクトルとして解釈します。これは、ベクトル変数を既存のコードに接続するのに役立ちます。オペレーターには2つのパラメーターが必要です。最初のパラメーターは、ベクトル要素の数を示します。 2番目のパラメーターは、 REAL データ。 __VCLOAD_REAL(<n>,<ptr>) 読み取り <n> での連続するREAL値 <ptr> 住所。未満の場合 <n> このアドレスに値があると、コントローラーがクラッシュしたり、不要なメモリを読み取ったりする可能性があります。 構文 <vector variable> := __VCLOAD_REAL( <vector size>, <pointer to data of type REAL> ) ;\n<vector size> : 2 | 3 | 4 | 5| 6 | 7| 8 ベクトル化 FUNCTION_BLOCK FB_LOAD\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n rData : ARRAY[0..2] OF REAL := [1.234, 5.678, 9.123];\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL(3, 3, 3);\nEND_VAR\n\nvcA := __VCLOAD_REAL(3, ADR(rData[0])); " }, 
{ "title" : "演算子：__ VCLOAD_LREAL ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-0203977d-64f5-da8c-acda-ea013ba688bc", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：__ VECTOR \/ 演算子：__ VCLOAD_LREAL ", 
"snippet" : "演算子は、任意のメモリ領域をベクトルとして解釈します。これは、ベクトル変数を既存のコードに接続するのに役立ちます。オペレーターには2つのパラメーターが必要です。最初のパラメーターは、ベクトル要素の数を示します。 2番目のパラメーターは、 LREAL データ。 __VCLOAD_LREAL (<n>,<ptr>) 読み取り <n> での連続するLREAL値 <ptr> 住所。未満の場合 <n> このアドレスに値があると、コントローラーがクラッシュしたり、不要なメモリを読み取ったりする可能性があります。 構文 <vector variable> := __VCLOAD_LREAL( <vector...", 
"body" : "演算子は、任意のメモリ領域をベクトルとして解釈します。これは、ベクトル変数を既存のコードに接続するのに役立ちます。オペレーターには2つのパラメーターが必要です。最初のパラメーターは、ベクトル要素の数を示します。 2番目のパラメーターは、 LREAL データ。 __VCLOAD_LREAL (<n>,<ptr>) 読み取り <n> での連続するLREAL値 <ptr> 住所。未満の場合 <n> このアドレスに値があると、コントローラーがクラッシュしたり、不要なメモリを読み取ったりする可能性があります。 構文 <vector variable> := __VCLOAD_LREAL( <vector size>, <pointer to data of type LREAL> );\n<number of vector elements> : 1 | 2 | 3 | 4 | 5| 6 | 7| 8 ベクトル化 FUNCTION_BLOCK FB_LOAD\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n rData : ARRAY[0..3] OF LREAL := [-1.7976931348623158E+308, 1.6E+308, 1.7E+308, -1.6E+308];\n vcA : __VECTOR[3] OF LREAL := __VCSET_LREAL(1, 2, 3);\nEND_VAR\n\nvcA := __VCLOAD_LREAL(3, ADR(rData[0])); " }, 
{ "title" : "演算子：__ VCSTORE ", 
"url" : "_cds_data_type_vector.html#UUID-6bca878c-3bfc-18b6-004c-67b23d99cc65_UUID-883d98ce-208b-793b-46eb-aa5757fa28d1", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型：__ VECTOR \/ 演算子：__ VCSTORE ", 
"snippet" : "オペレータは、ベクトルの内容を指定されたメモリアドレスに保存\/コピーします。要素の数とタイプは、ベクトル変数から自動的に適用されます。 __VCSTORE(<n>,<ptr>) 書き込み <n> での連続値 <ptr> 住所。未満の場合 <n> このアドレスに値があると、コントローラーがクラッシュしたり、不要なメモリを書き込んだりする可能性があります。 構文 __VCSTORE( <pointer to data>, <vector variable> ); 保存する FUNCTION_BLOCK FB_STORE VAR_INPUT END_VAR VAR_OUTPUT END_VAR VA...", 
"body" : "オペレータは、ベクトルの内容を指定されたメモリアドレスに保存\/コピーします。要素の数とタイプは、ベクトル変数から自動的に適用されます。 __VCSTORE(<n>,<ptr>) 書き込み <n> での連続値 <ptr> 住所。未満の場合 <n> このアドレスに値があると、コントローラーがクラッシュしたり、不要なメモリを書き込んだりする可能性があります。 構文 __VCSTORE( <pointer to data>, <vector variable> ); 保存する FUNCTION_BLOCK FB_STORE\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n rData : ARRAY[0..2] OF REAL := [1, 2, 3];\n pData: POINTER TO REAL := ADR(rData[0]);\n\n lrData : ARRAY [0..3] OF LREAL := [1, 2, 3, 4];\n plData: POINTER TO LREAL := ADR(lrData[0];\n\n\n vcA : __VECTOR[3] OF REAL := __VCSET_REAL( 1.234, 5.678, 9.123);\n vclA : __VECTOR[4] OF LREAL := __VCSET_LREAL(-1.7976931348623158E+308, 1.6E+308, 1.7E+308, -1.6E+308);\nEND_VAR\n\n__VCSTORE(pData, vcA);\n__VCSTORE(plData, vclA); " }, 
{ "title" : "データ型: VERSION ", 
"url" : "_cds_datatype_version.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ データ型 \/ データ型: VERSION ", 
"snippet" : "VERSION の VERSION データ型には、プロジェクトまたはライブラリに関するさまざまなバージョン情報を含む構造体が含まれます。 「プロジェクト情報」POUを自動生成 オプションおよび\/または 「ライブラリ情報」POUを自動的に生成する プロジェクト情報でオプションが有効になっている場合は、 GetVersion 機能する VERSION データ型は自動的に生成され、 POU（発注書） ビュー。個々の構造要素にはプログラムでアクセスできます。 型宣言: TYPE VERSION: STRUCT \/\/\/ The major version number. This is typicall...", 
"body" : "VERSION の VERSION データ型には、プロジェクトまたはライブラリに関するさまざまなバージョン情報を含む構造体が含まれます。 「プロジェクト情報」POUを自動生成 オプションおよび\/または 「ライブラリ情報」POUを自動的に生成する プロジェクト情報でオプションが有効になっている場合は、 GetVersion 機能する VERSION データ型は自動的に生成され、 POU（発注書） ビュー。個々の構造要素にはプログラムでアクセスできます。 型宣言: TYPE VERSION:\nSTRUCT\n \/\/\/ The major version number. This is typically incremented for significant releases that may include major new features or changes.\n uiMajor : UINT;\n \/\/\/ The minor version number. This is incremented for releases that add smaller features or improvements and may include significant fixes.\n uiMinor : UINT;\n \/\/\/ The service pack number. This is used to indicate updates that usually include bug fixes, performance improvements, and minor feature enhancements.\n uiServicePack : UINT;\n \/\/\/ The patch number. This is incremented for very small changes or bug fixes that do not significantly alter the functionality.\n uiPatch : UINT;\n END_STRUCT\n END_TYPE\n 詳細については、以下を参照してください。 プロジェクト情報にアクセスするためのブロックを作成するためのオプション" }, 
{ "title" : "プラグマ ", 
"url" : "_cds_struct_reference_pragmas.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ ", 
"snippet" : "プラグマステートメントは、コンパイルまたはプリコンパイルプロセスに関して1つ以上の変数のプロパティに影響を与えます。これには、さまざまなカテゴリのプラグマを使用できます。 プラグマは現在、テキスト エディターでのみサポートされています。...", 
"body" : "プラグマステートメントは、コンパイルまたはプリコンパイルプロセスに関して1つ以上の変数のプロパティに影響を与えます。これには、さまざまなカテゴリのプラグマを使用できます。 プラグマは現在、テキスト エディターでのみサポートされています。 " }, 
{ "title" : "メッセージプラグマ ", 
"url" : "_cds_pragma_message.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ メッセージプラグマ ", 
"snippet" : "メッセージプラグマは、に表示される出力テキストを生成します メッセージ コンパイル操作後に表示。さらに、メッセージタイプ ( メッセージ 、 警告 、または エラー ) を割り当てることができます。 挿入場所：POUのテキストエディタの個別の行または既存の行。 4種類のメッセージプラグマ プラグマ コードフラグメントの例 メッセージタイプ {text <literal> } {text 'Hallo Allgäu!'} {text 'Part PLC_PRG has been compiled completely'} タイプなし 出力; 文字列リテラル <literal> で定義 Hallo...", 
"body" : "メッセージプラグマは、に表示される出力テキストを生成します メッセージ コンパイル操作後に表示。さらに、メッセージタイプ ( メッセージ 、 警告 、または エラー ) を割り当てることができます。 挿入場所：POUのテキストエディタの個別の行または既存の行。 4種類のメッセージプラグマ プラグマ コードフラグメントの例 メッセージタイプ {text <literal> } {text 'Hallo Allgäu!'} {text 'Part PLC_PRG has been compiled completely'} タイプなし 出力; 文字列リテラル <literal> で定義 Hallo Allgäu! Part PLC_PRG has been compiled completely {info <literal> } {info 'I01: This is for your information.' } メッセージとして入力 出力： I01:This is for your information. {warning <literal>} {warning 'W01: This is a warning to you.'} 警告として入力 属性プラグマとは異なり 'obsolete' 、この種の警告を現在の位置に対してローカルに定義します。 警告プラグマ {warning <'warning string'>} POUなどのオブジェクト、ステートメント、および変数に対してのみ許可されます。 出力： C0373: W01: This is a warning to you. {error <literal>} {error 'E00: Error has occured.'}\n エラーとして入力されました 出力： E00: エラーが発生しました。 の中に メッセージ ビュー、 [エラー] 、 警告 (s) 、および メッセージ (s) ボタンを使用して出力テキストをフィルタリングできます。または、次の方法を使用することもできます [次のメッセージ] そして 前のメッセージ 個々のメッセージをナビゲートするコマンド。 次の点に注意してください。 ソース位置に移動 コマンド。このコマンドを使うと、ソースコード内のプラグマが実装されている位置にジャンプできます 例 PROGRAM PLC_PRG\nVAR\n iVar : INT; {info 'Info0: This is for your information.'}\n bVar : BOOL;\n arrTest : ARRAY [0..10] OF INT;\nEND_VAR {text 'Hello Allgäu!'}\n\narrTest[iVar] := arrTest[iVar]+1;\n{warning 'W01: This is a warning'}\niVar := iVar+1;\n{warning 'W02: This is a second warning'}\n\n{text 'Part PLC_PRG has been compiled completely'} メッセージビューに表示します。 " }, 
{ "title" : "属性プラグマ ", 
"url" : "_cds_f_pragmas_attribute.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ ", 
"snippet" : "属性プラグマは、コンパイルとプリコンパイルに影響を与えます。これらは、テキスト エディターでのみサポートされています。 CODESYS 一連の事前定義された属性プラグマをサポートします。さらに、プロジェクトのコンパイル前に条件付きプラグマを使用してクエリできるユーザー定義プラグマを使用できます。 属性は宣言部分で定義されます。例外：独自の宣言部分を持たないActionオブジェクトとTransitionオブジェクトの場合、実装部分の先頭で属性を定義できます。 独自の属性を定義する場合は、それらが一意であることを確認してください。これを行うには、たとえば、属性名の前に付けます。デバイスメーカーは、...", 
"body" : "属性プラグマは、コンパイルとプリコンパイルに影響を与えます。これらは、テキスト エディターでのみサポートされています。 CODESYS 一連の事前定義された属性プラグマをサポートします。さらに、プロジェクトのコンパイル前に条件付きプラグマを使用してクエリできるユーザー定義プラグマを使用できます。 属性は宣言部分で定義されます。例外：独自の宣言部分を持たないActionオブジェクトとTransitionオブジェクトの場合、実装部分の先頭で属性を定義できます。 独自の属性を定義する場合は、それらが一意であることを確認してください。これを行うには、たとえば、属性名の前に付けます。デバイスメーカーは、この目的でベンダープレフィックスを使用できます。 " }, 
{ "title" : "シンボルへの影響 ", 
"url" : "_cds_pragma_consequences_to_symbols.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ シンボルへの影響 ", 
"snippet" : "POUと変数は、属性プラグマの結果として、シンボル構成に関する動作を変更できます。 詳細については、影響を受けるプラグマのヘルプページを参照してください。 属性を持つプラグマ 効果 も参照してください {attribute 'call_after_global_init_slot' := ' <slot> '} なし {attribute 'call_after_init'} なし {attribute 'call_after_online_change_slot' := ' <slot> '} なし {attribute 'call_before_global_exit_slot' := '...", 
"body" : "POUと変数は、属性プラグマの結果として、シンボル構成に関する動作を変更できます。 詳細については、影響を受けるプラグマのヘルプページを参照してください。 属性を持つプラグマ 効果 も参照してください {attribute 'call_after_global_init_slot' := ' <slot> '} なし {attribute 'call_after_init'} なし {attribute 'call_after_online_change_slot' := ' <slot> '} なし {attribute 'call_before_global_exit_slot' := ' <slot> ' なし {attribute 'call_on_type_change':= ' comma separated list of referenced function blocks> '} なし {attribute 'conditionalshow' := ' <some text> '} {attribute 'conditionalshow'} {attribute 'conditionalshow_all_locals' := ' <some text> '} {attribute 'conditionalshow_all_locals'} 装飾された変数は非表示になっているため、エクスポートできません。 ただし、コンパイルされたライブラリのソースコードファイルが利用可能な場合、または CODESYS コマンドラインオプションで開始されました conditionalshowsymbols 、プラグマにもかかわらず、装飾された変数が表示されます。 conditionalshowconditionalshow_all_locals{attribute 'const_replaced'} {attribute 'const_non_replaced'} 置換された定数はシンボル構成エディターで使用できないため、エクスポートできません。 置き換えられる定数は、 定数を置き換える すべての定数に対してコンパイラオプションが選択されており、プラグマが個々の定数のコンパイラオプションを上書きするかどうか。 const_replaced, const_non_replaced{attribute 'dataflow'} なし {attribute 'displaymode':= <displaymode> } なし {attribute 'enable_dynamic_creation'} なし {attribute 'estimated-stack-usage' := ' <estimated stack size in bytes> '} なし {attribute 'ExpandFully'} なし {attribute 'global_init_slot' := '<slot>'} なし {attribute 'hide'} 変数は非表示になっているため、エクスポートできません。 hide{attribute 'hide_all_locals'} 変数は非表示になっているため、エクスポートできません。 hide_all_locals' {attribute 'initialize_on_call'} なし {attribute 'init_namespace'} なし {attribute 'init_on_onlchange' } なし {attribute 'instance-path'} なし {attribute 'io_function_block'} {attribute 'io_function_block_mapping'} なし {attribute 'is_connected' := ' <input variable> '} なし {attribute 'linkalways'} POUとライブラリPOUはコンパイルリストに統合されているため、エクスポートできません。 linkalways{attribute 'monitoring' := 'variable'} {attribute 'monitoring' := 'call'} PROPERTY プロパティまたは関数（ FUNCTION ）はシンボルとして利用できます。 monitoring{'no_assign' } {'no_assign_warning' } なし {attribute 'no_check'} なし {attribute 'no_copy'} なし {attribute 'no-exit'} なし {attribute 'no_init'} {attribute 'no-init'} {attribute 'noinit'} なし {attribute 'no_instance_in_retain'} なし {attribute 'no_virtual_actions'} なし {attribute 'pingroup' := ' <group name> '} なし {attribute 'pin_presentation_order_inputs' := '< input name > '( , <next input name> )* } {attribute 'pin_presentation_order_outputs' := '< output name > '( , <next output name> )* } なし {attribute 'obsolete' := 'user defined text'} なし {attribute 'pack_mode' := ' <pack mode value> '} 意図的なメモリのずれにつながる可能性があります {attribute 'ProcessValue'} なし {attribute 'qualified_only'} なし {attribute 'reflection'} なし {attribute 'subsequent'} なし {attribute 'suppress_warning'} なし suppress_warning{attribute 'symbol' := '<access possibilities>'} 変数はシンボルとしてエクスポートされます。 変数がシンボルリストに表示されるのは、 意見 、 属性を介してエクスポートされたシンボル オプションは、シンボル構成エディターで選択されています。プラグマで定義されたアクセス権は、 属性 桁。 アトリビュート：シンボル {attribute 'to_string'} なし {warning disable <compiler ID> } {warning restore <compiler ID> } なし " }, 
{ "title" : "カスタム属性 ", 
"url" : "_cds_user_defined_attributes.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ カスタム属性 ", 
"snippet" : "ユーザー定義属性は、POU、アクション、データ型定義、および変数に適用できるアプリケーション定義またはユーザー定義の属性です。アプリケーションをコンパイルする前に、条件付きプラグマを使用してユーザー定義属性を照会できます。 演算子を使用して、条件付きプラグマを使用してユーザー定義属性を照会できます。 hasattribute 。 詳細と例については、以下を参照してください。 条件付きプラグマ構文： {attribute 'attribute'} POUとアクション 属性 'vision' 機能のために fun1 {attribute 'vision'} FUNCTION fun1 : INT ...", 
"body" : "ユーザー定義属性は、POU、アクション、データ型定義、および変数に適用できるアプリケーション定義またはユーザー定義の属性です。アプリケーションをコンパイルする前に、条件付きプラグマを使用してユーザー定義属性を照会できます。 演算子を使用して、条件付きプラグマを使用してユーザー定義属性を照会できます。 hasattribute 。 詳細と例については、以下を参照してください。 条件付きプラグマ構文： {attribute 'attribute'} POUとアクション 属性 'vision' 機能のために fun1 {attribute 'vision'}\nFUNCTION fun1 : INT\nVAR_INPUT\n i : INT;\nEND_VAR 変数 'DoCount' の属性 ivar 変数： PROGRAM PLC_PRG\nVAR\n {attribute 'DoCount'};\n ivar:INT;\n bvar:BOOL;\nEND_VAR データ型 属性 'aType' データ型の場合 DUT_1 ： {attribute 'aType'}\nTYPE DUT_1 :\nSTRUCT\n a:INT;\n b:BOOL;\nEND_STRUCT\nEND_TYPE " }, 
{ "title" : "属性：call_after_global_init_slot ", 
"url" : "_cds_pragma_attribute_call_after_global_init_slot.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：call_after_global_init_slot ", 
"snippet" : "call_after_global_init_slot VAR_INPUT 属性を使用する関数またはメソッドでの宣言は、コンパイルエラーにつながります。理由：この場合、呼び出し時に入力変数は不明です。これは、オンライン変更中に暗黙的に発生します。 このプラグマの効果は、このように装飾されたすべての関数とプログラムがグローバル初期化の後に呼び出されることです。属性値を使用して、呼び出しの順序を定義します。 属性がメソッドに設定されている場合、親機能ブロックのすべてのインスタンスが決定されます。すべてのインスタンスは、指定されたスロットで呼び出されます。この場合、インスタンス間の順序には影響しませ...", 
"body" : "call_after_global_init_slot VAR_INPUT 属性を使用する関数またはメソッドでの宣言は、コンパイルエラーにつながります。理由：この場合、呼び出し時に入力変数は不明です。これは、オンライン変更中に暗黙的に発生します。 このプラグマの効果は、このように装飾されたすべての関数とプログラムがグローバル初期化の後に呼び出されることです。属性値を使用して、呼び出しの順序を定義します。 属性がメソッドに設定されている場合、親機能ブロックのすべてのインスタンスが決定されます。すべてのインスタンスは、指定されたスロットで呼び出されます。この場合、インスタンス間の順序には影響しません。 構文 ： {attribute 'call_after_global_init_slot' := '<slot>'} 挿入場所 関数とプログラムの宣言部分の上の最初の行 <slot> 呼び出し順にランキングを定義する整数値 値が小さいほど、呼び出しが早く行われます。複数の関数ブロックの属性のランクが同じである場合、それらの呼び出しの順序は不定のままです。 詳細については、以下を参照してください。 Global Init Slots" }, 
{ "title" : "属性：call_after_init ", 
"url" : "_cds_pragma_attribute_call_after_init.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：call_after_init ", 
"snippet" : "call_after_init VAR_INPUT この属性を使用する関数またはメソッドでの宣言は、コンパイルエラーにつながります。理由：この場合、呼び出し時に入力変数は不明です。これは、オンライン変更中に暗黙的に発生します。 この機能は、コンパイラバージョン3.4.1.0からサポートされています。 このプラグマの効果は、関数ブロックインスタンスの初期化後にメソッドが暗黙的に呼び出されることです。パフォーマンス上の理由から、関数ブロックとメソッドの両方に、宣言部分の上の独自の最初の行に属性を追加する必要があります。 このプラグマを使用するメソッドは、 FB_Init メソッドおよび初期化式の変...", 
"body" : "call_after_init VAR_INPUT この属性を使用する関数またはメソッドでの宣言は、コンパイルエラーにつながります。理由：この場合、呼び出し時に入力変数は不明です。これは、オンライン変更中に暗黙的に発生します。 この機能は、コンパイラバージョン3.4.1.0からサポートされています。 このプラグマの効果は、関数ブロックインスタンスの初期化後にメソッドが暗黙的に呼び出されることです。パフォーマンス上の理由から、関数ブロックとメソッドの両方に、宣言部分の上の独自の最初の行に属性を追加する必要があります。 このプラグマを使用するメソッドは、 FB_Init メソッドおよび初期化式の変数値がインスタンス宣言で有効になった後。 構文 ： {attribute 'call_after_init'} 呼び出し：メソッドと関数ブロックの宣言部分の上の最初の行 例 意味 {attribute 'call_after_init'}\nFUNCTION_BLOCK FB_DoIt\n... <functionblock definition>\n\n{attribute 'call_after_init'}\nMETHOD FB_AfterInit\n... <method definition> 宣言は、後続のコード処理で次の宣言を実装します。 fbDoIt : FB_DoIt := (in1 := 99); コード処理 fbDoIt.FB_Init();\nfbDoIt.in1 := 99;\nfbDoIt.FB_AfterInit(); これにより、ユーザー定義の初期化に対する反応が可能になります。 FB_AfterInit 。 " }, 
{ "title" : "属性：call_after_online_change_slot ", 
"url" : "_cds_pragma_attribute_call_after_online_change_slot.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：call_after_online_change_slot ", 
"snippet" : "call_after_online_change_slot VAR_INPUT 属性を使用する関数またはメソッドでの宣言は、コンパイルエラーにつながります。その理由は、この場合、呼び出し時に入力変数が不明であるためです。これは、オンライン変更中に暗黙的に発生します。 オンライン変更中はアプリケーションを実行できないため、この状況で実行される各コードはジッターにつながる可能性があります。したがって、エグゼクティブコードの範囲はできるだけ小さくしてください。 このプラグマの効果は、この属性を設定したすべての関数とプログラムがオンライン変更後に呼び出されることです。属性を使用して呼び出しの順序を定義...", 
"body" : "call_after_online_change_slot VAR_INPUT 属性を使用する関数またはメソッドでの宣言は、コンパイルエラーにつながります。その理由は、この場合、呼び出し時に入力変数が不明であるためです。これは、オンライン変更中に暗黙的に発生します。 オンライン変更中はアプリケーションを実行できないため、この状況で実行される各コードはジッターにつながる可能性があります。したがって、エグゼクティブコードの範囲はできるだけ小さくしてください。 このプラグマの効果は、この属性を設定したすべての関数とプログラムがオンライン変更後に呼び出されることです。属性を使用して呼び出しの順序を定義します <slot> 。 属性がメソッドに設定されている場合、親機能ブロックのすべてのインスタンスが決定されます。すべてのインスタンスは、指定されたスロットで呼び出されます。この場合、インスタンス間の順序には影響しません。 構文 ： {attribute 'call_after_online_change_slot' := '<slot>'} 挿入位置 関数とプログラムの宣言部分の上の最初の行 <slot> 呼び出しの順序でのランキングを定義する整数値。値が小さいほど、呼び出しが早く行われます。複数の関数ブロックの属性のランクが同じである場合、それらの呼び出しの順序は不定のままです。 " }, 
{ "title" : "属性：call_before_global_exit_slot ", 
"url" : "_cds_pragma_attribute_call_before_global_exit_slot.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：call_before_global_exit_slot ", 
"snippet" : "call_before_global_exit_slot VAR_INPUT 属性を使用する関数またはメソッドでの宣言は、コンパイルエラーにつながります。理由：この場合、呼び出し時に入力変数は不明です。これは、オンライン変更中に暗黙的に発生します。 このプラグマの効果は、この属性が設定されているすべての関数とプログラムが、 GlobalExit 。 GlobalExit 新しいダウンロードまたはリセットの前に行われます。で提供される機能ブロック FB_Exit メソッドが影響を受けます。呼び出しの順序は、属性値によって定義されます。 属性がメソッドに設定されている場合、親機能ブロックのすべての...", 
"body" : "call_before_global_exit_slot VAR_INPUT 属性を使用する関数またはメソッドでの宣言は、コンパイルエラーにつながります。理由：この場合、呼び出し時に入力変数は不明です。これは、オンライン変更中に暗黙的に発生します。 このプラグマの効果は、この属性が設定されているすべての関数とプログラムが、 GlobalExit 。 GlobalExit 新しいダウンロードまたはリセットの前に行われます。で提供される機能ブロック FB_Exit メソッドが影響を受けます。呼び出しの順序は、属性値によって定義されます。 属性がメソッドに設定されている場合、親機能ブロックのすべてのインスタンスが決定されます。すべてのインスタンスは、指定されたスロットで呼び出されます。この場合、インスタンス間の順序には影響しません。 構文 ： {attribute 'call_before_global_exit_slot' := '<slot>'} 挿入場所 関数とプログラムの宣言部分の上の最初の行 <slot> 呼び出しの順序でのランキングを定義する整数値。値が小さいほど、呼び出しが早く行われます。複数の関数ブロックの属性のランクが同じである場合、それらの呼び出しの順序は不定のままです。 " }, 
{ "title" : "属性：call_on_type_change ", 
"url" : "_cds_pragma_attribute_call_on_type_change.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：call_on_type_change ", 
"snippet" : "call_on_type_change このプラグマの効果は、そこで参照されている関数ブロックのデータ型が上位の関数ブロックで変更された場合に、で装飾されたメソッドが呼び出されることです。参照は、ポインター変数または REFERENCE TO 変数。 構文 ： {attribute 'call_on_type_change' := ' <comma-separated names of the referenced function modules> '} 挿入場所：メソッド宣言の最初の行の上の行 例 The FB_A 機能ブロック参照 FB_B と FB_C 。 FUNCTION_BLOCK...", 
"body" : "call_on_type_change このプラグマの効果は、そこで参照されている関数ブロックのデータ型が上位の関数ブロックで変更された場合に、で装飾されたメソッドが呼び出されることです。参照は、ポインター変数または REFERENCE TO 変数。 構文 ： {attribute 'call_on_type_change' := ' <comma-separated names of the referenced function modules> '} 挿入場所：メソッド宣言の最初の行の上の行 例 The FB_A 機能ブロック参照 FB_B と FB_C 。 FUNCTION_BLOCK FB_A\nVAR\n var_pt: POINTER TO FB_B;\n var_ref: REFERENCE TO FB_C;\nEND_VAR\n... The METH_react_on_type_change メソッドは、FB_BまたはFB_Cのデータ型が変更されたときに呼び出されます。 {attribute 'call_on_type_change' := 'FB_B, FB_C'}\nMETHOD METH_react_on_type_change : INT\nVAR_INPUT\n... " }, 
{ "title" : "属性：conditionalshow ", 
"url" : "_cds_pragma_attribute_conditionalshow.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：conditionalshow ", 
"snippet" : "conditionalshow プラグマには、統合されたコンパイル済みライブラリの識別子という効果があります。 <library name>.compiled-library プラグマで装飾された、は、アプリケーションをプログラミングする前に非表示になります。 POUを呼び出すことはできますが、変数は CODESYS ユーザーインターフェース。 影響を受ける機能 図書館管理 デバッグ 入力アシスタント 「コンポーネントのリスト」機能 モニタリング シンボル構成 これは、ライブラリを開発するときに役立ちます。ライブラリ開発者は、関数ブロックまたは変数をプラグマで装飾します。その結果、統合後にアプ...", 
"body" : "conditionalshow プラグマには、統合されたコンパイル済みライブラリの識別子という効果があります。 <library name>.compiled-library プラグマで装飾された、は、アプリケーションをプログラミングする前に非表示になります。 POUを呼び出すことはできますが、変数は CODESYS ユーザーインターフェース。 影響を受ける機能 図書館管理 デバッグ 入力アシスタント 「コンポーネントのリスト」機能 モニタリング シンボル構成 これは、ライブラリを開発するときに役立ちます。ライブラリ開発者は、関数ブロックまたは変数をプラグマで装飾します。その結果、統合後にアプリケーションで非表示にする識別子を決定します。ライブラリのデバッグやさらなる開発などのために、後で非表示の識別子を表示したい場合は、その可視性を再度アクティブにすることができます。 構文 {attribute 'conditionalshow' := ' <some text> '} 挿入場所：関数ブロックの宣言部分の変数の上にある一番上の行 挿入場所 関数とプログラムの宣言部分の上の最初の行 <some text> オプション コマンドラインコマンドとこのリテラルを使用して、この種のプラグマで装飾された識別子の可視性を制御する文字列リテラル プラグマがリテラルなしで指定されている場合、 CODESYS 開発環境は、方法に関係なく、常に隠されています CODESYS 始まった。 これに関する詳細については、「ライブラリ開発の概要」ドキュメントを参照してください。 例 例については、「ライブラリ開発の概要」ドキュメントを参照してください。 変数を非表示にする FUNCTION_BLOCK FB_DataManager\nVAR\n {attribute 'conditionalshow' := 'Library_Developer'}\n iLocal : INT;\n iCounter : INT;\nEND_VAR 変数 iLocal 見えません。 機能ブロックを非表示にする {attribute 'conditionalshow' := 'Library_Developer'}\nFUNCTION_BLOCK FB_DataManager\nVAR\n iLocal : INT;\n iCounter : INT;\nEND_VAR 識別子 FB_DataManager 、 iLocal 、 と iCounter 見えません。 " }, 
{ "title" : "既存のソースコードファイルの場合の可視性 ", 
"url" : "_cds_pragma_attribute_conditionalshow.html#UUID-c2eaf3e2-3d4a-2ddd-b40f-5c12f68a8748_id_a67a86e4255dcc0a8646343179ebe_id_f83478949a10c1e9c0a864630e28568a", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：conditionalshow \/ 既存のソースコードファイルの場合の可視性 ", 
"snippet" : "ソースコードファイルの場合 <library name>.library 統合ライブラリからのデータも同じメモリ位置（リポジトリ）に存在し、プラグマにもかかわらず識別子が表示されます。これは、宣言で属性値が指定されているかどうかには関係ありません。...", 
"body" : "ソースコードファイルの場合 <library name>.library 統合ライブラリからのデータも同じメモリ位置（リポジトリ）に存在し、プラグマにもかかわらず識別子が表示されます。これは、宣言で属性値が指定されているかどうかには関係ありません。 " }, 
{ "title" : "可視性をアクティブ化するためのコマンドライン呼び出し ", 
"url" : "_cds_pragma_attribute_conditionalshow.html#UUID-c2eaf3e2-3d4a-2ddd-b40f-5c12f68a8748_id_a67a86e4255dcc0a8646343179ebe_id_cea44f6f9a10c1e9c0a8646337b3d88a", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：conditionalshow \/ 可視性をアクティブ化するためのコマンドライン呼び出し ", 
"snippet" : "を開始することにより、ソースコードファイルなしで非表示の変数の可視性を有効にすることもできます CODESYS コマンドラインオプションを使用 conditionalshowsymbols 。可視性を有効にするには、プラグマの属性値をコンマで区切って指定します。 構文 codesys.exe --conditionalshowsymbols=\" <some text> ( ,<next text> )* \" 詳細については、以下を参照してください。 コマンドラインインターフェイスを使用するcodesys.exe --conditionalshowsymbols=\"Library_Develop...", 
"body" : "を開始することにより、ソースコードファイルなしで非表示の変数の可視性を有効にすることもできます CODESYS コマンドラインオプションを使用 conditionalshowsymbols 。可視性を有効にするには、プラグマの属性値をコンマで区切って指定します。 構文 codesys.exe --conditionalshowsymbols=\" <some text> ( ,<next text> )* \" 詳細については、以下を参照してください。 コマンドラインインターフェイスを使用するcodesys.exe --conditionalshowsymbols=\"Library_Developer\" codesys.exe --conditionalshowsymbols=\"Group_A,Group_B\" " }, 
{ "title" : "モニタリングとスマートコーディングに対する属性の影響 ", 
"url" : "_cds_pragma_attribute_conditionalshow.html#UUID-c2eaf3e2-3d4a-2ddd-b40f-5c12f68a8748_section-idm43395049804922", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：conditionalshow \/ 可視性をアクティブ化するためのコマンドライン呼び出し \/ モニタリングとスマートコーディングに対する属性の影響 ", 
"snippet" : "ソースライブラリ: アクション 属性セット 属性が設定されていません スマートコーディング \/ 入力アシスタント 方法 見える 見える 入力 見える 見えない 出力 見える 見えない 監視 入力 見える 見える 出力 見える 見える 地元 見える 見える コンパイルされたライブラリ アクション 属性セット 属性が設定されていません スマートコーディング \/ 入力アシスタント 方法 見える 見える 入力 見える 見えない 出力 見える 見えない 監視 入力 見える 見えない 出力 見える 見えない 地元 見える 見えない...", 
"body" : "ソースライブラリ: アクション 属性セット 属性が設定されていません スマートコーディング \/ 入力アシスタント 方法 見える 見える 入力 見える 見えない 出力 見える 見えない 監視 入力 見える 見える 出力 見える 見える 地元 見える 見える コンパイルされたライブラリ アクション 属性セット 属性が設定されていません スマートコーディング \/ 入力アシスタント 方法 見える 見える 入力 見える 見えない 出力 見える 見えない 監視 入力 見える 見えない 出力 見える 見えない 地元 見える 見えない " }, 
{ "title" : "属性：conditionalshow_all_locals ", 
"url" : "_cds_pragma_attribute_conditionalshow_all_locals.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：conditionalshow_all_locals ", 
"snippet" : "conditionalshow_all_locals プラグマには、すべての すべてローカル プラグマで装飾されたライブラリPOUの変数は、アプリケーションプログラマから隠されています。統合されたコンパイル済みライブラリのPOU <library name>.compiled-library 呼び出すことはできますが、変数は Basic Level ユーザーインターフェース。 機能に影響します： 図書館管理 デバッグ 入力アシスタント 「コンポーネントのリスト」機能 モニタリング シンボル構成 これは、ライブラリを開発するときに役立ちます。ライブラリ開発者は、関数ブロックをプラグマで装飾します...", 
"body" : "conditionalshow_all_locals プラグマには、すべての すべてローカル プラグマで装飾されたライブラリPOUの変数は、アプリケーションプログラマから隠されています。統合されたコンパイル済みライブラリのPOU <library name>.compiled-library 呼び出すことはできますが、変数は Basic Level ユーザーインターフェース。 機能に影響します： 図書館管理 デバッグ 入力アシスタント 「コンポーネントのリスト」機能 モニタリング シンボル構成 これは、ライブラリを開発するときに役立ちます。ライブラリ開発者は、関数ブロックをプラグマで装飾します。その結果、統合後にそれらの識別子がアプリケーションに隠されていると判断します。ライブラリのデバッグやさらなる開発などのために、後でこれらの識別子を表示したい場合は、その可視性を再度アクティブにすることができます。 詳細については、「ライブラリ開発の概要」のドキュメントを参照してください。 構文 {attribute 'conditionalshow_all_locals' := ' <some text> ' } 挿入場所 関数ブロックの宣言部分の上の最初の行 <some text> オプション コマンドラインコマンドとこのリテラルを使用して、この種のプラグマで装飾された識別子の可視性を制御するためのオプションの文字列リテラル プラグマがリテラルなしで指定されている場合、 Basic Level 開発環境は、方法に関係なく、常に隠されています Basic Level 始まった。 すべてのローカル変数を非表示にする {attribute 'conditionalshow_all_locals' := 'Library_Developer'}\nFUNCTION_BLOCK FB_DataManager\nVAR\n iLocal : INT;\n iCounter : INT;\nEND_VAR 例については、「ライブラリ開発の概要」ドキュメントを参照してください。 " }, 
{ "title" : "既存のソースコードファイルの場合の可視性 ", 
"url" : "_cds_pragma_attribute_conditionalshow_all_locals.html#UUID-db59833b-7bd9-9489-c20e-ebe370f6ad67_id_a15a9e476e49230dc0a864631ad26c45_id_84ae9f519e37d9d3c0a86463554294a0", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：conditionalshow_all_locals \/ 既存のソースコードファイルの場合の可視性 ", 
"snippet" : "ソースコードファイルの場合 <library name>.library 統合ライブラリからのライブラリも同じメモリ位置（リポジトリ）に存在し、プラグマにもかかわらずライブラリPOU変数が表示されます。これは、宣言で属性値が指定されているかどうかには関係ありません。...", 
"body" : "ソースコードファイルの場合 <library name>.library 統合ライブラリからのライブラリも同じメモリ位置（リポジトリ）に存在し、プラグマにもかかわらずライブラリPOU変数が表示されます。これは、宣言で属性値が指定されているかどうかには関係ありません。 " }, 
{ "title" : "可視性をアクティブ化するためのコマンドライン呼び出し ", 
"url" : "_cds_pragma_attribute_conditionalshow_all_locals.html#UUID-db59833b-7bd9-9489-c20e-ebe370f6ad67_id_a15a9e476e49230dc0a864631ad26c45_id_83dd83ba9e37d9d3c0a86463332f087b", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：conditionalshow_all_locals \/ 可視性をアクティブ化するためのコマンドライン呼び出し ", 
"snippet" : "を開始することにより、ソースコードファイルなしで非表示の変数の可視性を有効にすることもできます Basic Level コマンドラインオプションを使用 conditionalshowsymbols 。可視性を有効にするには、プラグマの属性値をコンマで区切って指定します。 構文 codesys.exe --conditionalshowsymbols=\" <some text> ( ,<next text> )* \" 例 codesys.exe --conditionalshowsymbols=\"Library_Developer\" codesys.exe --conditionalshowsy...", 
"body" : "を開始することにより、ソースコードファイルなしで非表示の変数の可視性を有効にすることもできます Basic Level コマンドラインオプションを使用 conditionalshowsymbols 。可視性を有効にするには、プラグマの属性値をコンマで区切って指定します。 構文 codesys.exe --conditionalshowsymbols=\" <some text> ( ,<next text> )* \" 例 codesys.exe --conditionalshowsymbols=\"Library_Developer\" codesys.exe --conditionalshowsymbols=\"Group_A,Group_B\" 詳細については、以下を参照してください。 hide_all_locals、 conditionalshow、および「可視性制御」の章 " }, 
{ "title" : "属性：const_replaced、const_non_replaced ", 
"url" : "_cds_pragma_attribute_const_replaced_non.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：const_replaced、const_non_replaced ", 
"snippet" : "const_replaced, const_non_replaced The 'const_replaced' 属性には、の設定に関係なく、コード内で定数が置き換えられるという効果があります。 定数を置き換える コンパイラオプション。この属性は、スカラー型の変数にのみ影響しますが、配列や構造体などの複合型には影響しません。 プラグマを挿入します {attribute 'const_non_replaced'} したがって、明示的に非アクティブ化するために 定数を置き換える コンパイラオプション。 これは、たとえば、 シンボル構成 、定数が使用可能であり、コンパイラオプションに関係なくエクスポー...", 
"body" : "const_replaced, const_non_replaced The 'const_replaced' 属性には、の設定に関係なく、コード内で定数が置き換えられるという効果があります。 定数を置き換える コンパイラオプション。この属性は、スカラー型の変数にのみ影響しますが、配列や構造体などの複合型には影響しません。 プラグマを挿入します {attribute 'const_non_replaced'} したがって、明示的に非アクティブ化するために 定数を置き換える コンパイラオプション。 これは、たとえば、 シンボル構成 、定数が使用可能であり、コンパイラオプションに関係なくエクスポートできること。 The 定数を置き換える のオプション コンパイルオプション のカテゴリ プロジェクト設定 定数を置き換えると、通常、コードが高速になり、メモリ使用量が少なくなるため、ダイアログはプロジェクト全体に事前設定されています。 構文 ： {attribute 'const_replaced'} {attribute 'const_non_replaced'} 挿入場所：グローバル変数の宣言行の上の行。 例 定数 iTestCon と xTestCon シンボル構成で使用できるのは、 定数を置き換える オプションが無効になっています。 {attribute 'qualified_only'}\nVAR_GLOBAL CONSTANT\n {attribute 'const_non_replaced'}\n iTestCon : INT := 12;\n {attribute 'const_non_replaced'}\n xTestCon : BOOL := TRUE;\n rTestCon : REAL := 1.5;\nEND_VAR\n\nVAR_GLOBAL\n iTestVar : INT := 12;\n xTestVar : BOOL := TRUE;\nEND_VAR " }, 
{ "title" : "属性：dataflow ", 
"url" : "_cds_pragma_attribute_dataflow.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：dataflow ", 
"snippet" : "dataflow このプラグマを使用すると、FBD \/ LD \/ ILエディタでファンクションブロックを処理する際のデータフローを制御できます。この属性は、次または前の機能ブロックへの継続接続が接続されている機能ブロックの入力または出力を定義します。 1つの入力のみを指定でき、1つの出力を機能ブロックの宣言で属性で装飾することができます。 のない機能ブロックの場合 'dataflow' 属性の場合、データフローは自動的に決定されます。最初に、同じデータタイプの出力と入力の間の接続が行われます。機能ブロックの最も高い入力変数または出力変数が常に取得されます。一致するデータ型の変数がない場合、一番...", 
"body" : "dataflow このプラグマを使用すると、FBD \/ LD \/ ILエディタでファンクションブロックを処理する際のデータフローを制御できます。この属性は、次または前の機能ブロックへの継続接続が接続されている機能ブロックの入力または出力を定義します。 1つの入力のみを指定でき、1つの出力を機能ブロックの宣言で属性で装飾することができます。 のない機能ブロックの場合 'dataflow' 属性の場合、データフローは自動的に決定されます。最初に、同じデータタイプの出力と入力の間の接続が行われます。機能ブロックの最も高い入力変数または出力変数が常に取得されます。一致するデータ型の変数がない場合、一番上の出力は次のPOUの一番上の入力に接続されます。 構文 ： {attribute 'dataflow'} 挿入場所 対応する変数の宣言がある行の上の行 'dataflow' 前または次のPOUに接続されている機能ブロックの入力または出力を識別します The FB および前の機能ブロックは、入力変数を使用して接続されます i1 。間の接続 FB 次の機能ブロックは、出力変数を介して確立されます outRes1 。 FUNCTION_BLOCK FB\nVAR_INPUT\n r1 : REAL;\n {attribute 'dataflow'}\n i1 : INT;\n i2 : INT;\n r2 : REAL;\nEND_VAR\n\nVAR_OUTPUT\n {attribute 'dataflow'}\n outRes1 : REAL;\n out1 : INT;\n g1 : INT;\n g2 : REAL;\nEND_VAR " }, 
{ "title" : "属性：displaymode ", 
"url" : "_cds_pragma_attribute_displaymode.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：displaymode ", 
"snippet" : "displaymode プラグマは、個々の変数の表示モードを定義します。この定義は、監視変数の表示に関するグローバル設定を上書きします。この設定は、 表現-2進数、10進数、16進数 メニュー 構文 ： {attribute 'displaymode':= <display mode> } 以下の定義が可能です バイナリ形式 {attribute 'displaymode':='bin'} {attribute 'displaymode':='binary'} 10進形式 {attribute 'displaymode':='dec'} {attribute 'displaymode':='d...", 
"body" : "displaymode プラグマは、個々の変数の表示モードを定義します。この定義は、監視変数の表示に関するグローバル設定を上書きします。この設定は、 表現-2進数、10進数、16進数 メニュー 構文 ： {attribute 'displaymode':= <display mode> } 以下の定義が可能です バイナリ形式 {attribute 'displaymode':='bin'} {attribute 'displaymode':='binary'} 10進形式 {attribute 'displaymode':='dec'} {attribute 'displaymode':='decimal'} 16進形式 {attribute 'displaymode':='hex'} {attribute 'displaymode':='hexadecimal'} 挿入場所：対応する変数が宣言されている行の上の行。 例 VAR\n {attribute 'displaymode':='hex'}\n dwVar1: DWORD;\nEND_VAR " }, 
{ "title" : "属性：enable_dynamic_creation ", 
"url" : "_cds_pragma_attribute_enable_dynamic_creation.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：enable_dynamic_creation ", 
"snippet" : "enable_dynamic_creation The enable_dynamic_creation プラグマを使用するには __NEW ファンクションブロックの場合。 構文 ： {attribute 'enable_dynamic_creation'} 挿入場所：機能ブロックの宣言の最初の行。...", 
"body" : "enable_dynamic_creation The enable_dynamic_creation プラグマを使用するには __NEW ファンクションブロックの場合。 構文 ： {attribute 'enable_dynamic_creation'} 挿入場所：機能ブロックの宣言の最初の行。 " }, 
{ "title" : "属性：推定スタック使用量 ", 
"url" : "_cds_pragma_attribute_estimated_stack_usage.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：推定スタック使用量 ", 
"snippet" : "estimated-stack-usage プラグマは、スタックサイズ要件の推定値を提供します。 再帰呼び出しのあるメソッドは、スタックの使用状況を判別できないため、スタックチェックに合格できません。その結果、警告が発行されます。この警告を防ぐために、スタックサイズ要件の推定値（バイト単位）をメソッドに指定できます。次に、メソッドはスタックチェックに正常に合格します。 構文 {attribute 'estimated-stack-usage' := ' <estimated stack size in bytes> '} 挿入場所：メソッドの宣言部分の上の最初の行。 例 {attribute ...", 
"body" : "estimated-stack-usage プラグマは、スタックサイズ要件の推定値を提供します。 再帰呼び出しのあるメソッドは、スタックの使用状況を判別できないため、スタックチェックに合格できません。その結果、警告が発行されます。この警告を防ぐために、スタックサイズ要件の推定値（バイト単位）をメソッドに指定できます。次に、メソッドはスタックチェックに正常に合格します。 構文 {attribute 'estimated-stack-usage' := ' <estimated stack size in bytes> '} 挿入場所：メソッドの宣言部分の上の最初の行。 例 {attribute 'estimated-stack-usage' := '127'} \/\/ 127 bytes\nMETHOD PUBLIC DoIt : BOOL\nVAR_INPUT\nEND_VAR 詳細については、以下を参照してください。 メソッド呼び出し" }, 
{ "title" : "再帰的なメソッド呼び出し ", 
"url" : "_cds_pragma_attribute_estimated_stack_usage.html#UUID-4670b30e-eb2d-1ea9-9d6e-61159df75c79_id_dd29a4d911bcf410c0a8640e01471f60_id_918a5ded942a17e2c0a8646316297a73", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：推定スタック使用量 \/ 再帰的なメソッド呼び出し ", 
"snippet" : "その実装内で、メソッドは、 THIS ポインタ、または割り当てられた機能ブロックのローカル変数を使用します。 主にリンクリストなどの再帰データ型を処理するために再帰を使用します。一般に、再帰を使用する場合は注意することをお勧めします。予期しないほど深い再帰は、スタックオーバーフローやマシンのダウンタイムを引き起こす可能性があるためです。 階乗の計算 次のプログラム PLC_PRG の数値の階乗を計算します FB_Factorial それぞれ独自のメソッドで、異なる方法で関数ブロック。 方法 m_Iterative ：反復 方法 m_Pragmaed ：警告抑制を伴う再帰 方法 m_Recurs...", 
"body" : "その実装内で、メソッドは、 THIS ポインタ、または割り当てられた機能ブロックのローカル変数を使用します。 主にリンクリストなどの再帰データ型を処理するために再帰を使用します。一般に、再帰を使用する場合は注意することをお勧めします。予期しないほど深い再帰は、スタックオーバーフローやマシンのダウンタイムを引き起こす可能性があるためです。 階乗の計算 次のプログラム PLC_PRG の数値の階乗を計算します FB_Factorial それぞれ独自のメソッドで、異なる方法で関数ブロック。 方法 m_Iterative ：反復 方法 m_Pragmaed ：警告抑制を伴う再帰 方法 m_Recursive ：再帰的 方法 m_Temp ：警告抑制を伴う一時的な 警告が発行されます m_Recursive メソッドのみ。 \/\/ Contains the data of the factorial calculation of uiNumber\nTYPE FACTORIAL_RESULT :\nSTRUCT\n uiNumber : UINT;\n udiIterative : UDINT;\n udiRecursive : UDINT;\n udiPragmaed : UDINT;\n udiTemp : UDINT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n fb_Factorial_A : FB_Factorial;\n factorial_A : FACTORIAL_RESULT := (uiNumber := 9, udiIterative := 0, udiRecursive := 0, udiPragmaed := 0 );\nEND_VAR\nfb_Factorial_A.p_Number := factorial_A.uiNumber;\nfactorial_A.udiIterative := fb_Factorial_A.m_Iterative();\nfactorial_A.udiRecursive := fb_Factorial_A.m_Recursive(uiN := factorial_A.uiNumber);\nfactorial_A.udiPragmaed := fb_Factorial_A.m_Pragmaed(uiN := factorial_A.uiNumber);\nfactorial_A.udiTemp := fb_Factorial_A.m_Temp(uiN := factorial_A.uiNumber);\n\n\/\/Factorial calculation in different ways\nFUNCTION_BLOCK FB_Factorial\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n uiN : UINT;\n udiIterative : UDINT;\n udiPragmaed : UDINT;\n udiRecursive : UDINT;\nEND_VAR\n\n \/\/ Iterative calculation\n METHOD PUBLIC m_Iterative : UDINT\n VAR\n uiCnt : UINT;\n END_VAR\n m_Iterative := 1;\n IF uiN > 1 THEN\n FOR uiCnt := 1 TO uiN DO\n m_Iterative := m_Iterative * uiCnt;\n END_FOR;\n RETURN;\n ELSE\n RETURN;\n END_IF;\n\n \/\/Recursive calculation with suppressed warning\n {attribute 'estimated-stack-usage' := '99'}\n METHOD PUBLIC m_Pragmaed : UDINT\n VAR_INPUT\n uiN : UINT;\n END_VAR\n VAR\n END_VAR\n m_Pragmaed := 1;\n IF uiN > 1 THEN\n m_Pragmaed := uiN * THIS^.m_Pragmaed(uiN := (uiN - 1));\n RETURN;\n ELSE\n RETURN;\n END_IF;\n \n \/\/Recursive calculation\n METHOD PUBLIC m_Recursive : UDINT\n VAR_INPUT\n uiN : UINT;\n END_VAR\n VAR\n END_VAR\n m_Recursive := 1;\n IF uiN > 1 THEN\n m_Recursive := uiN * THIS^.m_Recursive(uiN := (uiN - 1) );\n RETURN;\n ELSE\n RETURN;\n END_IF;\n \n \/\/ Called by temporary FB instance\n {attribute 'estimated-stack-usage' := '99'}\n METHOD PUBLIC m_Temp : UDINT\n VAR_INPUT\n uiN : UINT;\n END_VAR\n VAR\n fb_Temp : FB_Factorial;\n END_VAR\n m_Temp := 1;\n IF uiN > 1 THEN\n m_Temp := uiN * fb_Temp.m_Temp(uiN := (uiN - 1));\n RETURN;\n ELSE\n RETURN;\n END_IF;\n\nPROPERTY p_Number : UINT\nuiN := p_Number; \/\/Setter method のみ m_Recursive プログラムの実行時に警告を発行します。 " }, 
{ "title" : "属性：ExpandFully ", 
"url" : "_cds_pragma_attribute_expandfully.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：ExpandFully ", 
"snippet" : "ExpandFully このプラグマの効果は、参照されたビジュアライゼーションの入力変数として使用される配列のメンバーが、ビジュアライゼーションのプロパティダイアログに表示されることです。 構文： {attribute 'ExpandFully'} 挿入場所：配列が宣言されている行の上の行。 視覚化 ヴィス ビジュアライゼーション内のフレームに挿入されます visu_main 。 arr のインターフェイスエディタで入力変数として定義されています ヴィス したがって、後でフレームの[プロパティ]ダイアログで割り当てに使用できるようになります。 visu_main 。 の個々のコンポーネントも作...", 
"body" : "ExpandFully このプラグマの効果は、参照されたビジュアライゼーションの入力変数として使用される配列のメンバーが、ビジュアライゼーションのプロパティダイアログに表示されることです。 構文： {attribute 'ExpandFully'} 挿入場所：配列が宣言されている行の上の行。 視覚化 ヴィス ビジュアライゼーション内のフレームに挿入されます visu_main 。 arr のインターフェイスエディタで入力変数として定義されています ヴィス したがって、後でフレームの[プロパティ]ダイアログで割り当てに使用できるようになります。 visu_main 。 の個々のコンポーネントも作成するために arr この[プロパティ]ダイアログで利用できる場合は、 'ExpandFully' 直前の属性 arr visuのインターフェースエディタで。のインターフェースエディタでの宣言 ヴィス ： VAR_INPUT\n{attribute 'ExpandFully'}\n arr : ARRAY[0..5] OF INT;\nEND_VAR " }, 
{ "title" : "属性：global_init_slot ", 
"url" : "_cds_pragma_attribute_global_init_slot.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：global_init_slot ", 
"snippet" : "global_init_slot プラグマは、POUおよびグローバル変数リストの初期化の順序を定義します。GVLまたはPOU内の変数は、上から下に初期化されます。複数のグローバル変数リストがある場合、初期化順序は定義されていません。 初期化は、リテラル値の初期化には適用されません。たとえば、 1 、 'hello' 、 3.6 、または基本データ型の定数。ただし、リスト間に依存関係がある場合は、初期化の順序を自分で定義する必要があります。定義された初期化スロットをGVLまたはPOUに割り当てることができます。 'global_init_slot' 属性。 定数は、変数の前に、変数と同じ順序で初...", 
"body" : "global_init_slot プラグマは、POUおよびグローバル変数リストの初期化の順序を定義します。GVLまたはPOU内の変数は、上から下に初期化されます。複数のグローバル変数リストがある場合、初期化順序は定義されていません。 初期化は、リテラル値の初期化には適用されません。たとえば、 1 、 'hello' 、 3.6 、または基本データ型の定数。ただし、リスト間に依存関係がある場合は、初期化の順序を自分で定義する必要があります。定義された初期化スロットをGVLまたはPOUに割り当てることができます。 'global_init_slot' 属性。 定数は、変数の前に、変数と同じ順序で初期化されます。初期化中、POUは<slot>の値に従ってソートされます。次に、定数を初期化するためのコードが生成され、その後、変数を初期化するためのコードが生成されます。 構文 ： {attribute 'global_init_slot' := '<slot>'} 挿入場所 プラグマは常にGVLまたはPOU全体に作用するため、プラグマは VAR_GLOBAL またはPOU宣言。 <slot> 呼び出しの順序で位置を定義する整数値 POU（プログラム、機能ブロック）のデフォルト値は50000です。GVLのデフォルト値は49990です。値が小さいほど、初期化が早いことを意味します。 複数のPOUに同じ値が割り当てられている場合 'global_init_slot' 属性の場合、初期化の順序は未定義のままです。 例 プロジェクトには、2つのグローバル変数リストが含まれています GVL_1 と GVL_2 、および PLC_PRG 両方のリストの変数を使用するプログラム。 GVL_1 変数を使用します B 変数を初期化するため A 、で初期化されます GVL_2 と 1000 。 GVL_1 VAR_GLOBAL \/\/49990\n A : INT := GVL_2.B*100;\nEND_VAR GVL_2 VAR_GLOBAL \/\/49990\n B : INT := 1000;\n C : INT := 10;\nEND_VAR PLC_PRG PROGRAM PLC_PRG \/\/50000\nVAR\n ivar: INT := GVL_1.A;\n ivar2: INT;\nEND_VAR\n\nivar:=ivar+1;\nivar2:=GVL_2.C; この場合、コンパイラはエラーを出力します。 GVL_2.B 初期化に使用されます GVL_1.A 前 GVL_2 初期化されました。これを防ぐには、 global_init_slot 位置への属性 GVL_2 前 GVL_1 初期化シーケンスで。 この例では、 GVL_1 プログラム内で最も早い初期化を実現するには、少なくとも1つのスロット値49989が必要です。低い値はすべて同じ効果があります。 GVL_2 {attribute 'global_init_slot' := '100'}\nVAR_GLOBAL\n B : INT := 1000;\nEND_VAR 使用する GVL_2.C の実装部分で PLC_PRG どちらの場合も、両方のGVLがプログラムの前に初期化されるため、プラグマを使用しなくても重要ではありません。 詳細については、以下を参照してください。 Global Init Slots" }, 
{ "title" : "属性：hide ", 
"url" : "_cds_pragma_attribute_hide.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：hide ", 
"snippet" : "hide プラグマの使用 {attribute 'hide'} 変数と POU を非表示にしても、ほとんどの場合、望ましい効果は得られません。代わりに、 {属性 '条件付き表示'} 。プラグマ。 プラグマは、プラグマで定義された変数とPOUがプラグマに表示されないようにします。 CODESYS ユーザーインターフェース。その結果、アクセスを制限することなく、これらの識別子を意図的に非表示にすることができます。これは、ライブラリを開発するときに役立ちます。 機能に影響します： 図書館管理 デバッグ 入力アシスタント 「コンポーネントのリスト」機能 モニタリング シンボル構成 プラグマで定義された...", 
"body" : "hide プラグマの使用 {attribute 'hide'} 変数と POU を非表示にしても、ほとんどの場合、望ましい効果は得られません。代わりに、 {属性 '条件付き表示'} 。プラグマ。 プラグマは、プラグマで定義された変数とPOUがプラグマに表示されないようにします。 CODESYS ユーザーインターフェース。その結果、アクセスを制限することなく、これらの識別子を意図的に非表示にすることができます。これは、ライブラリを開発するときに役立ちます。 機能に影響します： 図書館管理 デバッグ 入力アシスタント 「コンポーネントのリスト」機能 モニタリング シンボル構成 プラグマで定義された変数またはPOUは、ライブラリマネージャーには表示されず、入力アシスタントまたは「コンポーネントの一覧表示」機能にも表示されません。プラグマは、これらの装飾された変数がシンボル構成に表示されないようにします。その結果、これらの種類の変数をシンボルとしてエクスポートすることはできません。変数はオンラインモードでも表示されないため、それらの値を監視することはできません。さらに、デバッグ機能を使用することはできず、バグをチェックする際のサポートもありません。 アプリケーション開発者が非表示のPOUと変数の正確なインスタンスパスを知っている場合は、コードでそれらにアクセスできます。 構文 ： {attribute 'hide'} 挿入場所：変数の場合、変数の宣言がある行の上。 POUの場合、最初の行。 隠れた変数 機能ブロック FB_MyA 属性プラグマが含まれています {attribute 'hide'} ローカル変数を非表示にする xInvisibleIn 。 FUNCTION_BLOCK FB_MyA\nVAR_INPUT\n iInA : INT;\n {attribute 'hide'}\n xInvisibleIn : BOOL;\n xInit: BOOL;\nEND_VAR\nVAR_OUTPUT\n iOutA : INT;\nEND_VAR\nVAR\n iCounter : INT;\nEND_VAR 機能ブロックの2つのインスタンス FB_MyA メインプログラムで定義されています。 PROGRAM PLC_PRG\nVAR\n fbMyA1, fbMyA2 : FB_MyA;\n xVar2 : BOOL;\n iVar1 : INT;\n iVar2 : INT;\nEND_VAR\nfbMyA1(iInA := 1, xInit := TRUE, xInvisibleIn := TRUE, iOutA => iVar1);\nfbMyA2(iInA := 1, xInit := TRUE, iOutA => iVar2); の入力値が fbMyA1 入力時に開く「コンポーネントの一覧表示」関数が実装されました fbMyA1. （の実装部分で PLC_PRG ）、変数を表示します iInA 、 xInit 、 と iOutA 、ただし隠れた変数ではありません xInvisibleIn 。 隠しライブラリPOU FB_A ライブラリのファンクションブロックです HiddenFunctionality デフォルトの名前空間 HIDDEN 。識別子とPOUコードをアプリケーション開発者から隠すには、属性pragmaを使用してPOUの宣言を開始します。 {attribute 'hide'} 。同じ方法で従属POU（アクション、メソッド、プロパティ、および遷移）を非表示にするには、宣言を次のように開始します。 {attribute 'hide'} 。 {attribute 'hide'}\nFUNCTION_BLOCK FB_A\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\n iCount : INT;\n iInvisible : INT;\nEND_VAR\n\n{attribute 'hide'}\nMETHOD METH_Count : INT\nVAR_INPUT\nEND_VAR\niCount := iCount + 1;\n\n{attribute 'hide'}\nMETHOD METH_Invisible : BOOL\nVAR_INPUT\nEND_VAR\niInvisible := iInvisible + 1;\n\n{attribute 'hide'}\nPROPERTY PUBLIC prop_iA : INT アプリケーション開発者の場合、すべてのPOUは表示されません。インスタンスパスがわかっている場合にのみ使用できます。 PROGRAM PLC_PRG\nVAR\n fbHidden : HIDDEN.FB_A; \/\/ Hidden function block from library HiddenFunctionality\n iCounter : INT;\nEND_VAR\nfbHidden.METH_Invisible();\niCounter := fbHidden.iInvisible; オンラインモードでは、監視は実行されません。 とともに {属性 'hide_all_locals'} プラグマ、POUのすべてのローカル変数を非表示にすることができます。 " }, 
{ "title" : "属性：hide_all_locals ", 
"url" : "_cds_pragma_attribute_hide_all_locals.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：hide_all_locals ", 
"snippet" : "hide_all_locals プラグマは、署名のすべてのローカル変数が「コンポーネントの一覧表示」機能の表示、入力アシスタント、またはオンラインモードの宣言部分に表示されないようにします。さらに、これらの変数はシンボル構成に隠されているため、シンボルとしてエクスポートすることはできません。このプラグマは、POU変数をユーザーから隠すためにライブラリPOUで特に役立ちます。 影響を受ける機能 図書館管理 デバッグ 入力アシスタント 「コンポーネントのリスト」機能 モニタリング シンボル構成 構文 ： {attribute 'hide_all_locals'} 挿入場所：POUの宣言部分の上の最...", 
"body" : "hide_all_locals プラグマは、署名のすべてのローカル変数が「コンポーネントの一覧表示」機能の表示、入力アシスタント、またはオンラインモードの宣言部分に表示されないようにします。さらに、これらの変数はシンボル構成に隠されているため、シンボルとしてエクスポートすることはできません。このプラグマは、POU変数をユーザーから隠すためにライブラリPOUで特に役立ちます。 影響を受ける機能 図書館管理 デバッグ 入力アシスタント 「コンポーネントのリスト」機能 モニタリング シンボル構成 構文 ： {attribute 'hide_all_locals'} 挿入場所：POUの宣言部分の上の最初の行 例 機能ブロック FB_MyB 属性を使用します： {attribute 'hide_all_locals'}\nFUNCTION_BLOCK FB_MyB\nVAR_INPUT\n iInB : INT;\n {attribute 'hide'}\n xInvisibleIn : BOOL;\n xInit: BOOL;\nEND_VAR\nVAR_OUTPUT\n iOutB : INT;\nEND_VAR\nVAR\n iCounter : INT;\n xVar : BOOL;\nEND_VAR 機能ブロックの2つのインスタンス FB_MyB メインプログラムで定義されています。 PROGRAM PLC_PRG\nVAR\n fbMyB1, fbMyB2: FB_MyB;\n iVar3: INT;\n iVar4: INT;\nEND_VAR\n\nfbMyB1(iInB := 2, xInvisibleIn := TRUE, iOutB => iVar3);\nfbMyB2(iInB := 2, iOutB => iVar4);\nIF fbMyB2.iCounter > 100 THEN\n fbMyB2.xInit := TRUE;\nEND_IF これで、プログラムをコントローラーにダウンロードして起動し、オンラインモードに切り替えると、変数が iInB 、 xInit 、 iOutB 、 と xReset 宣言エディタに表示されます。ただし、隠されたローカル変数 iCounter と xVar 表示されません。 " }, 
{ "title" : "属性：initialize_on_call ", 
"url" : "_cds_pragma_attribute_initialize_on_call.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：initialize_on_call ", 
"snippet" : "initialize_on_call プラグマにより、関数ブロックの入力変数は、関数ブロックの呼び出しごとに初期化されます。ポインターを予期する入力変数が影響を受け、このポインターがオンライン変更中に削除された場合、変数は次のように初期化されます。 zero 。 構文： {attribute 'initialize_on_call'} 挿入場所：常に、機能ブロック全体の宣言部分の最初の行、および個々の入力変数の宣言の上の行にあります。 例 {attribute 'initialize_on_call'} FUNCTION_BLOCK fb VAR_INPUT {attribute 'initi...", 
"body" : "initialize_on_call プラグマにより、関数ブロックの入力変数は、関数ブロックの呼び出しごとに初期化されます。ポインターを予期する入力変数が影響を受け、このポインターがオンライン変更中に削除された場合、変数は次のように初期化されます。 zero 。 構文： {attribute 'initialize_on_call'} 挿入場所：常に、機能ブロック全体の宣言部分の最初の行、および個々の入力変数の宣言の上の行にあります。 例 {attribute 'initialize_on_call'}\nFUNCTION_BLOCK fb\nVAR_INPUT\n {attribute 'initialize_on_call'}\n pInt : POINTER TO INT := 0;\n {attribute 'initialize_on_call'}\n iVal : INT := 0;\nEND_VAR " }, 
{ "title" : "属性：init_namespace ", 
"url" : "_cds_pragma_attribute_init_namespace.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：init_namespace ", 
"snippet" : "init_namespace このプラグマの効果は、次のタイプの変数です。 STRING また WSTRING このプラグマを使用してライブラリ関数ブロックで宣言されている、は、ライブラリの現在の名前空間を使用してプロジェクトで使用されるときに初期化されます。 構文 {attribute 'init_namespace'} 挿入場所：ライブラリ関数ブロック内の変数が宣言されている行の上の行。 機能ブロック POU 必要な属性が提供されます： FUNCTION_BLOCK POU VAR_OUTPUT {attribute 'init_namespace'} myStr: STRING; END...", 
"body" : "init_namespace このプラグマの効果は、次のタイプの変数です。 STRING また WSTRING このプラグマを使用してライブラリ関数ブロックで宣言されている、は、ライブラリの現在の名前空間を使用してプロジェクトで使用されるときに初期化されます。 構文 {attribute 'init_namespace'} 挿入場所：ライブラリ関数ブロック内の変数が宣言されている行の上の行。 機能ブロック POU 必要な属性が提供されます： FUNCTION_BLOCK POU\nVAR_OUTPUT\n {attribute 'init_namespace'}\n myStr: STRING;\nEND_VAR インスタンス fb 機能ブロックのPOUは、メインプログラムPLC_PRG内で定義されます。 PROGRAM PLC_PRG\nVAR\n fb:POU;\n newString: STRING;\nEND_VAR\nnewString := fb.myStr; The myStr 変数は現在の名前空間で初期化されます（例： MyLib ）。この値はに割り当てられます newString メインプログラムで。 " }, 
{ "title" : "属性：init_on_onlchange ", 
"url" : "_cds_pragma_attribute_init_on_onlchange.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：init_on_onlchange ", 
"snippet" : "init_on_onlchange 高速オンライン変更中の初期化コードなし コンパイラ バージョン >= 3.5.0.0 以降、マイナーな変更に対して「高速オンライン変更」が実行されます。高速オンライン変更では、変更された POU のみがコンパイルおよびダウンロードされます。特に、初期化コードは生成されません。 変数の場合、 init_on_onlchange 属性、これはまた、 いいえ 初期化コードが生成されます。通常のシナリオでは、属性は通常アドレスで変数を初期化するために使用されるため、影響はありません。ただし、高速オンライン変更中に、変数がそのアドレスを変更することはあり得ません。 た...", 
"body" : "init_on_onlchange 高速オンライン変更中の初期化コードなし コンパイラ バージョン >= 3.5.0.0 以降、マイナーな変更に対して「高速オンライン変更」が実行されます。高速オンライン変更では、変更された POU のみがコンパイルおよびダウンロードされます。特に、初期化コードは生成されません。 変数の場合、 init_on_onlchange 属性、これはまた、 いいえ 初期化コードが生成されます。通常のシナリオでは、属性は通常アドレスで変数を初期化するために使用されるため、影響はありません。ただし、高速オンライン変更中に、変数がそのアドレスを変更することはあり得ません。 ただし、その影響を確認するために、 init_on_onlchange 属性は、アプリケーション コード全体に適用されます。一般に、アプリケーションでは、 no_fast_online_change コンパイラは、高速オンライン変更を無効にするように定義します。これを行うには、デバイス ツリーでアプリケーション オブジェクトを選択し、 プロパティ コンテキストメニューで。以下の 建てる タブで、 no_fast_online_change コンパイラ定義。 詳細については、次を参照してください。 建てるこのプラグマの効果は、プラグマが適用される変数がオンラインでの変更ごとに初期化されることです。 構文： {attribute 'init_on_onlchange' } 挿入場所：変数が宣言されている行の上の行。 例 VAR_GLOBAL    \n {attribute 'init_on_onlchange'}    \n g_fastOnlineChange : BOOL := FALSE;\nEND_VAR\n {attribute 'call_after_online_change_slot' := '4567'}\nFUNCTION FUNC_OnlineChangeDetection : BOOL\nVAR_INPUT\nEND_VAR\nVAR\nEND_VAR \n\nIF GVL_OnlineChangeDetection.g_fastOnlineChange THEN    \n \/\/ here you know that you are inside a FastOnlineChange\nEND_IF\n\/\/ reset for next detection\nGVL_OnlineChangeDetection.g_fastOnlineChange := TRUE; " }, 
{ "title" : "属性：instance-path ", 
"url" : "_cds_pragma_attribute_instance_path.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：instance-path ", 
"snippet" : "instance-path プラグマは、ローカル文字列変数に適用できます。このローカル文字列変数は、それが属するPOUのデバイスツリーパスと順番に初期化されるという効果があります。これは、エラーメッセージに役立ちます。 プラグマを適用するには、属性を適用する必要があります ' 反射 ' 関連するPOU、および追加属性の適用 ' noinit ' STRING変数に。 構文 ： {attribute 'instance-path'} 挿入位置：宣言のある行の上の行 STRING 変数。 例 次の機能ブロックには、属性が含まれています 'reflection' 、 'instance-path' ...", 
"body" : "instance-path searchresult_toplevel プラグマは、ローカル文字列変数に適用できます。このローカル文字列変数は、それが属するPOUのデバイスツリーパスと順番に初期化されるという効果があります。これは、エラーメッセージに役立ちます。 プラグマを適用するには、属性を適用する必要があります ' 反射 ' 関連するPOU、および追加属性の適用 ' noinit ' STRING変数に。 構文 ： {attribute 'instance-path'} 挿入位置：宣言のある行の上の行 STRING 変数。 例 次の機能ブロックには、属性が含まれています 'reflection' 、 'instance-path' と 'noinit' 。 {attribute 'reflection'}\nFUNCTION_BLOCK POU\nVAR\n {attribute 'instance-path'}\n {attribute 'noinit'}\n str: STRING;\nEND_VAR インスタンス myPOU 機能ブロックの POU メインプログラム内で定義されています PLC_PRG ： PROGRAM PLC_PRG\nVAR\n myPOU:POU;\n myString: STRING;\nEND_VAR\nmyPOU();\nmyString:=myPOU.str; インスタンスの初期化に続いて myPOU 、インスタンスmyPOUのパスが文字列変数に割り当てられます str 、例では PLCWinNT.Application.PLC_PRG.myPOU 。このパスは、メインプログラムで変数に割り当てられます myString 。 文字列の長さは必要に応じて定義できます（255を超える場合でも）。ただし、データ型が小さすぎる変数に割り当てられた場合、文字列は最後に切り捨てられることを考慮する必要があります。 " }, 
{ "title" : "属性：io_function_block、io_function_block_mapping ", 
"url" : "_cds_pragma_attribute_io_function_block_mapping.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：io_function_block、io_function_block_mapping ", 
"snippet" : "io_function_block、io_function_block_mapping The io_function_block 属性には、それで装飾された機能ブロックが、I \/ Oマッピングのチャネルに割り当てるためのデバイス構成で使用可能であるという効果があります。機能ブロックはに示されています 機能ブロックを選択 ダイアログ。 The 'io_function_block_mapping' 属性は、この種の機能ブロックで、機能ブロックをデバイスチャネルにマッピングするときに自動的に使用されるパラメータが装飾されるという効果があります。 機能ブロックの複数のパラメータに属性を指定すること...", 
"body" : "io_function_block、io_function_block_mapping The io_function_block 属性には、それで装飾された機能ブロックが、I \/ Oマッピングのチャネルに割り当てるためのデバイス構成で使用可能であるという効果があります。機能ブロックはに示されています 機能ブロックを選択 ダイアログ。 The 'io_function_block_mapping' 属性は、この種の機能ブロックで、機能ブロックをデバイスチャネルにマッピングするときに自動的に使用されるパラメータが装飾されるという効果があります。 機能ブロックの複数のパラメータに属性を指定することができます。 I \/ Oマッピングの場合、タイプがチャネル（入力、出力、データタイプ）と一致する最初のマッピングが自動的に使用されます。 構文 ： {attribute 'io_function_block'} {attribute 'io_function_block_mapping'} 挿入場所：機能ブロックの宣言の最初の行の上の行、およびパラメーター宣言の上の行。 例 {attribute 'io_function_block'}\nFUNCTION_BLOCK Scale_Output_Int\nVAR_INPUT\n iInput : INT;\n iNumerator : INT;\n iDenominator : INT :=1;\n iOffset : INT := 0;\nEND_VAR\nVAR_OUTPUT\n {attribute 'io_function_block_mapping'}\n iOutput : INT;\nEND_VAR\n " }, 
{ "title" : "属性：is_connected ", 
"url" : "_cds_pragma_attribute_is_connected.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：is_connected ", 
"snippet" : "is_connected プラグマを使用します 'is_connected' ブール関数ブロック変数を装飾します。これは、汎用モジュールインスタンスが呼び出されたときに、POUの関連する入力に割り当てがあるかどうかに関する情報を提供します。 プラグマを使用するには、属性を使用する必要があります 'reflection' 影響を受ける機能ブロック。 構文 ： {attribute 'is_connected' := '<input variable>'} 例 機能ブロック内 FB 、ローカル変数は入力変数ごとに宣言されます（ in1 と in2 ）と属性 'is connected' 毎回、入力...", 
"body" : "is_connected プラグマを使用します 'is_connected' ブール関数ブロック変数を装飾します。これは、汎用モジュールインスタンスが呼び出されたときに、POUの関連する入力に割り当てがあるかどうかに関する情報を提供します。 プラグマを使用するには、属性を使用する必要があります 'reflection' 影響を受ける機能ブロック。 構文 ： {attribute 'is_connected' := '<input variable>'} 例 機能ブロック内 FB 、ローカル変数は入力変数ごとに宣言されます（ in1 と in2 ）と属性 'is connected' 毎回、入力変数の名前が前に付けられます。 func自体がプラグマ属性を取得します 'reflection' 。 関数ブロックのインスタンスが呼び出されると、ローカル変数は次のようになります。 TRUE 割り当てられた入力が割り当てを受けた場合。 {attribute 'reflection'}\nFUNCTION_BLOCK FB\nVAR_INPUT\n in1: INT;\n in2: INT;\nEND_VAR\nVAR\n {attribute 'is_connected' := 'in1'}\n in1_connection_info: BOOL;\n {attribute 'is_connected' := 'in2'}\n in2_connection_info: BOOL;\nEND_VAR 仮定：機能ブロックインスタンスが呼び出されると、 in1 外部割り当てを受け取り、 in 2 割り当てを受け取りません。これにより、次のコードが生成されます。 in1_connection_info := TRUE;\nin2_connection_info := FALSE; " }, 
{ "title" : "属性：linkalways ", 
"url" : "_cds_pragma_attribute_linkalways.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：linkalways ", 
"snippet" : "linkalways プラグマ {attribute 'linkalways'} コンパイル情報に常にPOUまたはライブラリPOUを含めるようにコンパイラーに指示します。ビルド中に、POUがコンパイルされ、アプリケーションコードの一部になります。ダウンロード中に、POUがPLCにダウンロードされます。 構文 ： {attribute 'linkalways'} 挿入場所：POUまたはライブラリPOUの宣言部分の最初の行 POUは、プロジェクト全体で有効である可能性があります（ POU ビュー）またはアプリケーション全体（ デバイス 見る）。 を選択することもできます 常にリンク のオプション ...", 
"body" : "linkalways プラグマ {attribute 'linkalways'} コンパイル情報に常にPOUまたはライブラリPOUを含めるようにコンパイラーに指示します。ビルド中に、POUがコンパイルされ、アプリケーションコードの一部になります。ダウンロード中に、POUがPLCにダウンロードされます。 構文 ： {attribute 'linkalways'} 挿入場所：POUまたはライブラリPOUの宣言部分の最初の行 POUは、プロジェクト全体で有効である可能性があります（ POU ビュー）またはアプリケーション全体（ デバイス 見る）。 を選択することもできます 常にリンク のオプション 建てる POUのオブジェクトプロパティのタブ。 例 The MoreSymbols GVLにはプラグマが含まれています {attribute 'linkalways'} 。そこで宣言された変数も、アクセスに関係なく、アプリケーションコードの一部です。 GVL MoreSymbols {attribute 'linkalways'}\nVAR_GLOBAL\n g_iAlfa: INT;\n g_iBravo: INT;\n g_iCharlie: INT;\nEND_VAR シンボル構成は、コンパイル情報にもアクセスします。結果として、 MoreSymbols GVLは、 シンボル構成 編集者。 " }, 
{ "title" : "属性：monitoring ", 
"url" : "_cds_pragma_attribute_monitoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：monitoring ", 
"snippet" : "monitoring このプラグマの効果は、IECエディターのオンラインビューまたはウォッチリストでプロパティまたは関数呼び出しの値を監視できることです。これには2つの可能な属性値があります。 'variable' と 'call' 構文 {attribute 'monitoring' := 'variable'} {attribute 'monitoring' := 'call'}...", 
"body" : "monitoring searchresult_toplevel このプラグマの効果は、IECエディターのオンラインビューまたはウォッチリストでプロパティまたは関数呼び出しの値を監視できることです。これには2つの可能な属性値があります。 'variable' と 'call' 構文 {attribute 'monitoring' := 'variable'} {attribute 'monitoring' := 'call'} " }, 
{ "title" : "プログラミングオブジェクトとそのプロパティの監視 ", 
"url" : "_cds_pragma_attribute_monitoring.html#UUID-b1b46724-01c4-546c-fe9d-2236c7c9e2df_id_edeaa3c5d0ed2fac0a8640e00361c29_id_a51754afb92821c6c0a86463317326eb", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：monitoring \/ プログラミングオブジェクトとそのプロパティの監視 ", 
"snippet" : "プラグマを挿入すると {attribute 'monitoring':='call'} 監視するには、起こりうる副作用に注意を払う必要があります。この種の副作用は、プロパティに追加の操作が実装されている場合に発生する可能性があります。 プラグマ {attribute 'monitoring'} シンボル構成についても評価されます。値に対しては読み取りアクセスのみが可能です 'variable' 。 機能ブロックまたはプログラムのオンラインビューでは、ローカル変数に加えて従属プロパティを監視することができます。これにより、の値を監視できます Get と Set メソッド。 プラグマを挿入します ...", 
"body" : "プラグマを挿入すると {attribute 'monitoring':='call'} 監視するには、起こりうる副作用に注意を払う必要があります。この種の副作用は、プロパティに追加の操作が実装されている場合に発生する可能性があります。 プラグマ {attribute 'monitoring'} シンボル構成についても評価されます。値に対しては読み取りアクセスのみが可能です 'variable' 。 機能ブロックまたはプログラムのオンラインビューでは、ローカル変数に加えて従属プロパティを監視することができます。これにより、の値を監視できます Get と Set メソッド。 プラグマを挿入します {attribute 'monitoring' := 'variable'} また {attribute 'monitoring' := 'call'} プロパティブロックの宣言で。プロパティの現在の値は、IECエディタまたはウォッチリストに自動的に表示されます。 例 オンラインモードでは、 PLC_PRG オブジェクトはの値を示します Minutes STエディターのインライン呼び出し位置のプロパティ。これは、プラグマが {attribute 'monitoring' := 'variable'} の宣言にあります Minutes 財産。 どの属性プラグマが目的の値を表示するのに適しているかをアプリケーションごとに注意深く確認してください。これは、変数を使用した追加の操作がプロパティ内に実装されているかどうかによって異なります。 プラグマ： {attribute 'monitoring':='variable'} ： プロパティに対して暗黙の変数が作成され、アプリケーションが呼び出したときに常に現在のプロパティ値が与えられます。 Set また Get 方法。この変数に最後に格納された値は、モニタリングに表示されます。 プラグマ： {attribute 'monitoring':='call'} この属性は、単純なデータ型またはポインターを返すプロパティにのみ使用できますが、構造化型には使用できません。 監視対象の値は、プロパティを直接呼び出すことで読み取りまたは書き込みが行われます。これは、ランタイムの監視サービスが実行することを意味します Get また Set プロパティのメソッド。 コンテキストメニューコマンドを使用 ウォッチを追加 、カーソルが現在置かれている変数は、オンラインモードで監視リストに直接適用されます。 関数の強制または書き込みはサポートされていません。ただし、内部フォースフラグとして機能する、それぞれの関数の追加の入力パラメーターを追加することにより、強制を暗黙的に実装できます。 コンパクトランタイムでは機能監視はできません。 " }, 
{ "title" : "属性：monitoring_display ", 
"url" : "_cds_pragma_attribute_monitoring_display.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：monitoring_display ", 
"snippet" : "monitoring_display 宣言におけるこのプラグマ ファンクションブロック または 構造 指定されたメンバーの現在の値（ 財産 oder Variable）もモニタリングに表示されます。 次に、機能ブロックまたは構造体メンバーの値が、機能ブロックまたは構造体のタイプの変数の監視の最上行に表示されます。 構文： {attribute 'monitoring_display' := '<component name>'} 挿入場所：宣言の最初の行の上 例 {attribute 'monitoring_display' := 'stMonitoring'} TYPE ADUT : STR...", 
"body" : "monitoring_display 宣言におけるこのプラグマ ファンクションブロック または 構造 指定されたメンバーの現在の値（ 財産 oder Variable）もモニタリングに表示されます。 次に、機能ブロックまたは構造体メンバーの値が、機能ブロックまたは構造体のタイプの変数の監視の最上行に表示されます。 構文： {attribute 'monitoring_display' := '<component name>'} 挿入場所：宣言の最初の行の上 例 {attribute 'monitoring_display' := 'stMonitoring'} \nTYPE ADUT :\nSTRUCT\t\n val1: INT;\t\n val2: INT;\t\n stMonitoring: STRING := 'to be monitored';\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\t\n mydut: ADUT;\n nTest: INT;\nEND_VAR\nnTest:= iCounter + 1;\nmydut.stMonitoring := INT_TO_STRING(nTest);\n " }, 
{ "title" : "属性：monitoring_encoding ", 
"url" : "_cds_pragma_attribute_monitoring_encoding.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：monitoring_encoding ", 
"snippet" : "monitoring_encoding 属性プラグマは、次のデータ型の変数に使用できます。 STRING type のエイリアス データ型の変数の場合 STRING 。この属性には、監視中に UTF-8 形式でデコードされるように変数の値がマークされるという効果があります。 構文 ： {attribute 'monitoring_encoding' := 'UTF8'} 挿入場所：変数宣言の上 例 PROGRAM PLC_PRG VAR {attribute 'monitoring.encoding' := 'UTF8'} strDat : STRING := 'abc'; attribute...", 
"body" : "monitoring_encoding 属性プラグマは、次のデータ型の変数に使用できます。 STRING type のエイリアス データ型の変数の場合 STRING 。この属性には、監視中に UTF-8 形式でデコードされるように変数の値がマークされるという効果があります。 構文 ： {attribute 'monitoring_encoding' := 'UTF8'} 挿入場所：変数宣言の上 例 PROGRAM PLC_PRG\nVAR\n {attribute 'monitoring.encoding' := 'UTF8'}\n strDat : STRING := 'abc'; \n attribute 'monitoring_encoding' := 'UTF-8'}\t\n strVarUtf8: STRING := UTF8#'你好,世界!ÜüÄäÖö';\n {attribute 'monitoring_encoding' := 'UTF-8'}\n str1: STRING := UTF8#'AÄyyy';\t\t\n {attribute 'monitoring_encoding' := 'UTF-8'}\t\t\n str2: STRING := UTF8#'AÄxxxÜÜÜ';\t\n\t\t\n strVarUtf8_1: STRING := '你好,世界!ÜüÄäÖö';\n str1_1: STRING := 'AÄyyy';\t\t\t\t\n str2_1: STRING := 'AÄxxxÜÜÜ';\t\t\t\nEND_VAR " }, 
{ "title" : "属性：no_assign、no_assign_warning ", 
"url" : "_cds_pragma_attribute_no_assign.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：no_assign、no_assign_warning ", 
"snippet" : "no_assign, no_assign_warning プラグマ 'no_assign' 汎用ブロックのインスタンスが同じ汎用ブロックの別のインスタンスに割り当てられている場合、コンパイラエラーが表示されます。関数ブロックにポインタが含まれている場合、そのような割り当ては回避されることが多く、ポインタは値の割り当て中にもコピーされるため、問題が発生します。 プラグマ 'no_assign_warning' プラグマの場合と同じ結果になります 'no_assign' コンパイラエラーの代わりにコンパイラ警告が表示されます。 構文 ： {attribute 'no_assign'} 挿入場所：機...", 
"body" : "no_assign, no_assign_warning プラグマ 'no_assign' 汎用ブロックのインスタンスが同じ汎用ブロックの別のインスタンスに割り当てられている場合、コンパイラエラーが表示されます。関数ブロックにポインタが含まれている場合、そのような割り当ては回避されることが多く、ポインタは値の割り当て中にもコピーされるため、問題が発生します。 プラグマ 'no_assign_warning' プラグマの場合と同じ結果になります 'no_assign' コンパイラエラーの代わりにコンパイラ警告が表示されます。 構文 ： {attribute 'no_assign'} 挿入場所：機能ブロックの宣言部分の一番上の行。 例 ポインタを含む汎用ブロックインスタンスの割当。 この例では、機能ブロックインスタンスの値の割り当てにより、の実行中に問題が発生します。 fb_exit ： VAR_GLOBAL\n inst1 : TestFB;\n awsBufferLogFile : ARRAY [0..9] OF WSTRING(66);(* Area: 0, Offset: 0x1304 (4868)*)\n LogFile : SEDL.LogRecord := (sFileName := 'LogFile.log', pBuffer := ADR(awsBufferLogFile), udiMaxEntriesFile := UDINT#10000, udiMaxBuffered := UDINT#10, uiLineSize := UINT#64, wsSep := \" \", xCircular := TRUE, siDateFormat := SINT#0, siTimeFormat := SINT#0);\nEND_VAR\n\nPROGRAM PLC_PRG\nVAR\n inst2 : TestFB := inst1;\n LogFileNew\nEND_VAR この場合 LogRecord ポインタのリストを管理します。このリストに対して、次の場合にさまざまなアクションが実行されます。 fb_exit 。割り当てが原因で問題が発生します。 fb_exit 2回実行されます。属性を追加してこれを防ぐ必要があります 'no_assign' 機能ブロックの宣言で TestFB ： {attribute 'no_assign'}\nFUNCTION_BLOCK TestFB\nVAR_INPUT\n... 次に、次のコンパイラエラーが表示されます。 C0328: Assignment not allowed for type TestFB\nC0328: Assignment not allowed for type LogRecord プラグマの場合 no_assign_warning プラグマの代わりに使用されます no_assign 機能ブロック用 TestFB 、 そうして C0328 メッセージは、コンパイラエラーとしてではなく、コンパイラ警告として発行されます。 " }, 
{ "title" : "属性：no_check ", 
"url" : "_cds_pragma_attribute_no_check.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：no_check ", 
"snippet" : "no_check プラグマには、チェック機能（ 暗黙的なチェックのPOU）はPOUには必要ありません。チェック機能はプログラムの処理速度に影響を与える可能性があるため、すでにチェックされている、または頻繁に呼び出される機能ブロックに属性を適用すると便利な場合があります。 POUの宣言にプラグマを追加します。 構文 ： {attribute 'no_check'} 挿入場所：POUの宣言部分の最初の行 この属性は、POUの子オブジェクトにも自動的に影響します。 例：属性がプログラムに入力されている場合、このプログラムに割り当てられているアクションに対してもチェック機能は実行されません。...", 
"body" : "no_check プラグマには、チェック機能（ 暗黙的なチェックのPOU）はPOUには必要ありません。チェック機能はプログラムの処理速度に影響を与える可能性があるため、すでにチェックされている、または頻繁に呼び出される機能ブロックに属性を適用すると便利な場合があります。 POUの宣言にプラグマを追加します。 構文 ： {attribute 'no_check'} 挿入場所：POUの宣言部分の最初の行 この属性は、POUの子オブジェクトにも自動的に影響します。 例：属性がプログラムに入力されている場合、このプログラムに割り当てられているアクションに対してもチェック機能は実行されません。 " }, 
{ "title" : "属性：no_copy ", 
"url" : "_cds_pragma_attribute_no_copy.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：no_copy ", 
"snippet" : "no_copy 一般に、オンラインでの変更には、POUのインスタンスの再割り当てが必要です。その過程で、インスタンスに含まれる変数の値がコピーされます。 プラグマは、インスタンスに含まれる変数の値がオンライン変更の過程でコピーされるのを防ぎます。代わりに、変数はオンライン変更の過程で再初期化されます。これは、オンライン変更によってシフトされたばかりでアドレスが変更された変数を指すローカルポインタ変数に役立ちます。 構文 ： {attribute 'no_copy'} 関連する変数の宣言の行の上の宣言部分に属性を挿入します。...", 
"body" : "no_copy 一般に、オンラインでの変更には、POUのインスタンスの再割り当てが必要です。その過程で、インスタンスに含まれる変数の値がコピーされます。 プラグマは、インスタンスに含まれる変数の値がオンライン変更の過程でコピーされるのを防ぎます。代わりに、変数はオンライン変更の過程で再初期化されます。これは、オンライン変更によってシフトされたばかりでアドレスが変更された変数を指すローカルポインタ変数に役立ちます。 構文 ： {attribute 'no_copy'} 関連する変数の宣言の行の上の宣言部分に属性を挿入します。 " }, 
{ "title" : "属性：no-exit ", 
"url" : "_cds_pragma_attribute_no_exit.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：no-exit ", 
"snippet" : "no-exit 属性は、の呼び出しを抑制します FB_Exit そのインスタンスの特定の1つの関数ブロックのメソッド。これを行うには、関数ブロックインスタンスの宣言の前の行に属性を挿入します。 構文 ： {attribute 'no-exit'} メソッド FB_exit 機能ブロックに追加されます POU_ex 。機能ブロックの2つのインスタンス POU_ex メインプログラムで作成されます PLC_PRG 。 PROGRAM PLC_PRG VAR POU1 : POU_ex; {attribute 'no-exit'} POU2 : POU_ex; END_VAR POU1が呼び出され、...", 
"body" : "no-exit searchresult_toplevel 属性は、の呼び出しを抑制します FB_Exit そのインスタンスの特定の1つの関数ブロックのメソッド。これを行うには、関数ブロックインスタンスの宣言の前の行に属性を挿入します。 構文 ： {attribute 'no-exit'} メソッド FB_exit 機能ブロックに追加されます POU_ex 。機能ブロックの2つのインスタンス POU_ex メインプログラムで作成されます PLC_PRG 。 PROGRAM PLC_PRG\nVAR\n POU1 : POU_ex;\n {attribute 'no-exit'}\n POU2 : POU_ex;\nEND_VAR POU1が呼び出され、POU2は呼び出されません。 " }, 
{ "title" : "属性：noinit ", 
"url" : "_cds_pragma_attribute_noinit.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：noinit ", 
"snippet" : "noinit プラグマは、暗黙的に初期化されるべきではない変数に適用されます。 構文 ： {attribute 'no_init'} {attribute 'no-init'} {attribute 'noinit'} 挿入場所：宣言部分に関係する変数の宣言行の上の行。 例 PROGRAM PLC_PRG VAR iA : INT; {attribute 'no_init'} iB : INT; END_VAR 関連するアプリケーションがリセットされると、整数変数 iA で暗黙的に再初期化されます 0 、一方、変数 iB 現在の値を保持します。...", 
"body" : "noinit プラグマは、暗黙的に初期化されるべきではない変数に適用されます。 構文 ： {attribute 'no_init'} {attribute 'no-init'} {attribute 'noinit'} 挿入場所：宣言部分に関係する変数の宣言行の上の行。 例 PROGRAM PLC_PRG\nVAR\n iA : INT;\n {attribute 'no_init'}\n iB : INT;\nEND_VAR 関連するアプリケーションがリセットされると、整数変数 iA で暗黙的に再初期化されます 0 、一方、変数 iB 現在の値を保持します。 " }, 
{ "title" : "属性：no_instance_in_retain ", 
"url" : "_cds_pragma_attribute_no_instance_in_retain.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：no_instance_in_retain ", 
"snippet" : "no_instance_in_retain プラグマには、プラグマで装飾された汎用モジュールをインスタンス化できないという効果があります。 RETAIN 変数。プラグマは、機能ブロックのインスタンスが保持メモリに格納されるのを防ぎます。代わりに、エラーメッセージが表示されます。 構文 ： {attribute 'no_instance_in_retain'} 挿入位置：上の線 FUNCTION_BLOCK 関数ブロックの宣言部分の宣言。...", 
"body" : "no_instance_in_retain プラグマには、プラグマで装飾された汎用モジュールをインスタンス化できないという効果があります。 RETAIN 変数。プラグマは、機能ブロックのインスタンスが保持メモリに格納されるのを防ぎます。代わりに、エラーメッセージが表示されます。 構文 ： {attribute 'no_instance_in_retain'} 挿入位置：上の線 FUNCTION_BLOCK 関数ブロックの宣言部分の宣言。 " }, 
{ "title" : "属性: no_virtual_actions ", 
"url" : "_cds_pragma_attribute_no_virtual_actions.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性: no_virtual_actions ", 
"snippet" : "no_virtual_actions このプラグマは、SFCで実装されたファンクションブロックから派生し、この基底クラスの基本的なSFCシーケンスを使用するファンクションブロックに使用されます。このファンクションブロックから呼び出されるアクションは、メソッドと同じ仮想動作を示します。つまり、基底クラスのアクションの実装は、派生クラス独自の実装によって置き換えることができます。 プラグマを基本クラスに適用すると、そのアクションはオーバーロードから保護されます。 構文 ： {attribute 'no_virtual_actions'} 挿入場所: ファンクションブロックの宣言部の先頭行 機能ブロ...", 
"body" : "no_virtual_actions このプラグマは、SFCで実装されたファンクションブロックから派生し、この基底クラスの基本的なSFCシーケンスを使用するファンクションブロックに使用されます。このファンクションブロックから呼び出されるアクションは、メソッドと同じ仮想動作を示します。つまり、基底クラスのアクションの実装は、派生クラス独自の実装によって置き換えることができます。 プラグマを基本クラスに適用すると、そのアクションはオーバーロードから保護されます。 構文 ： {attribute 'no_virtual_actions'} 挿入場所: ファンクションブロックの宣言部の先頭行 機能ブロック POU_SFC 派生関数ブロックの基本クラスです POU_child 派生クラス POU_child SFCで書かれた基本クラスのシーケンスを特殊変数で呼び出す SUPER 。 このシーケンスの例示的な実装は、最初のステップに限定され、それにリンクされたステップアクションを含む単一のステップが続く。 ActiveAction リンクされたステップアクションを持つこのステップは、出力変数の構成を処理します。 an_int := an_int+1; \/\/ Counting the action calls\ntest_act := 'father_action';\nMETH(); \/\/ Call of the method METH in order to set the string variable test_meth 派生クラスの場合 POU_child ステップアクションは、特別な実装に置き換えられます。 ActiveAction 。 Active Action 文字列の割り当てのみがオリジナルと異なる 'child_action' の代わりに 'father_action' 変数で test_act 。 同様に、この方法は METH 文字列を割り当てる 'father_method' 変数に test_meth 基本クラスでは、上書きされて test_meth 今価値を得る 'child_method' メインプログラム PLC_PRG 関数ブロックのインスタンスを呼び出す POU_child 、名前 Child 予想どおり、文字列の値は派生クラスのアクションとメソッドの呼び出しを反映しています。 しかし、プラグマを置くと {attribute 'no_virtual_actions'} 基本クラスの前: {attribute 'no_virtual_actions'}\n\nFUNCTION_BLOCK POU_SFC... これにより動作が変わります。派生クラスの実装はメソッドに引き続き使用されますが、 METH 、ステップアクションの呼び出しは、アクションの呼び出しになります ActiveAction 基本クラスの。したがって test_act に値が与えられます 'father_action' ： " }, 
{ "title" : "属性：obsolete ", 
"url" : "_cds_pragma_attribute_obsolete.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：obsolete ", 
"snippet" : "obsolete このプラグマの効果は、データ型（構造、関数ブロックなど）がプロジェクトで使用されている場合、コンパイル中にデータ型定義に対して定義された警告が表示されることです。これにより、たとえば、インターフェイスが変更されたためにデータ型が無効になり、これもプロジェクトに実装する必要があるという事実に注意を向けることができます。 メッセージプラグマとは対照的に、この警告はデータ型のすべてのインスタンスに対して一元的に定義されます。 構文 ： {attribute 'obsolete' := 'user defined text'} 挿入場所：データ型定義の行またはその上の行。 例 プラグ...", 
"body" : "obsolete searchresult_toplevel このプラグマの効果は、データ型（構造、関数ブロックなど）がプロジェクトで使用されている場合、コンパイル中にデータ型定義に対して定義された警告が表示されることです。これにより、たとえば、インターフェイスが変更されたためにデータ型が無効になり、これもプロジェクトに実装する必要があるという事実に注意を向けることができます。 メッセージプラグマとは対照的に、この警告はデータ型のすべてのインスタンスに対して一元的に定義されます。 構文 ： {attribute 'obsolete' := 'user defined text'} 挿入場所：データ型定義の行またはその上の行。 例 プラグマは、宣言に挿入されます FB_I1 ファンクションブロック： {attribute 'obsolete' := 'Data type FB_I1 not valid'}\nFUNCTION_BLOCK FB_I1\nVAR_INPUT\n i:INT;\nEND_VAR\n; FB_I1をデータ型として使用する場合、たとえば fbI1 : FB_I1; の場合、プロジェクトのコンパイル時に次の警告が表示されます。 Data type FB_I1 not valid 。 " }, 
{ "title" : "属性：pingroup ", 
"url" : "_cds_pragma_attribute_pingroup.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：pingroup ", 
"snippet" : "pingroup このプラグマの効果は、入力ピンまたは出力ピン（パラメーター）が機能ブロックの宣言でグループ化されることです。 FBD \/ LDエディタでは、このように定義されたピングループを、挿入された機能ブロックに拡大または縮小された単位として表示できます。いくつかのグループが可能であり、それらの名前で区別されます。 CODESYS プロジェクトオプションを使用して、機能ブロックボックスごとにそれぞれの状態（縮小）を保存します。 構文 ： {attribute 'pingroup' := '<group name>'} 挿入位置：機能ブロックの宣言部分に関係する入力変数または出力変数の宣言...", 
"body" : "pingroup このプラグマの効果は、入力ピンまたは出力ピン（パラメーター）が機能ブロックの宣言でグループ化されることです。 FBD \/ LDエディタでは、このように定義されたピングループを、挿入された機能ブロックに拡大または縮小された単位として表示できます。いくつかのグループが可能であり、それらの名前で区別されます。 CODESYS プロジェクトオプションを使用して、機能ブロックボックスごとにそれぞれの状態（縮小）を保存します。 構文 ： {attribute 'pingroup' := '<group name>'} 挿入位置：機能ブロックの宣言部分に関係する入力変数または出力変数の宣言の上の行。 例 2つのグループが定義されています。 general (i1, out1) と group1 (i2, g1) 。 r1 、 r2 、 outRes1 と g2 常に表示されます。 FUNCTION_BLOCK FB\nVAR_INPUT\n r1 : REAL;\n {attribute 'pingroup' := 'general'}\n i1 : INT;\n {attribute 'pingroup' := 'group1'}\n i2 : INT;\n r2 : REAL;\nEND_VAR\nVAR_OUTPUT\n outRes1 : REAL;\n {attribute 'pingroup' := 'general'}\n out1 : INT;\n {attribute 'pingroup' := 'group1'}\n g1 : INT;\n g2 : REAL;\nEND_VAR " }, 
{ "title" : "属性：pin_presentation_order_inputs、pin_presentation_order_outputs ", 
"url" : "_cds_pragma_attribute_pin_presentation_order.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：pin_presentation_order_inputs、pin_presentation_order_outputs ", 
"snippet" : "pin_presentation_order_inputs, pin_presentation_order_outputs このプラグマは、次の場合は評価されません。 {attribute 'pingroup' := '<Group_Name>'} プラグマが使用されます。 プラグマはCFC、FBD、およびLDグラフィカルエディタで評価され、影響を受ける機能ブロックの入力\/出力の順序が指定どおりに表示されます。入力\/出力の名前を希望の順序で属性に割り当てることにより、順序をプログラムします。 構文： {attribute 'pin_presentation_order_inputs' := '...", 
"body" : "pin_presentation_order_inputs, pin_presentation_order_outputs このプラグマは、次の場合は評価されません。 {attribute 'pingroup' := '<Group_Name>'} プラグマが使用されます。 プラグマはCFC、FBD、およびLDグラフィカルエディタで評価され、影響を受ける機能ブロックの入力\/出力の順序が指定どおりに表示されます。入力\/出力の名前を希望の順序で属性に割り当てることにより、順序をプログラムします。 構文： {attribute 'pin_presentation_order_inputs' := ' <first input name> ', ' <next input names> '}\n{attribute 'pin_presentation_order_outputs' := ' <first output name> ', ' <next output names> '} ' <first input name> ', ' <next input names> ' 希望する順序での入力のコンマ区切り名 ' <first output name> ', ' <next output names> ' 希望する順序での出力のコンマ区切り名 * 指定されていないすべての名前のプレースホルダー プレースホルダーが欠落している場合、欠落している入力\/出力が最後に追加されます。 挿入位置 関数ブロックの宣言部分の一番上の行 例 {attribute 'pin_presentation_order_inputs' := 'input_2,*,input_1'}\n{attribute 'pin_presentation_order_outputs' := 'output_2, output_1'}\nFUNCTION_BLOCK POU_BASE\nVAR_INPUT\n input_1 : BOOL;\n input_2 : INT;\n input_3 : INT;\n input_4 : INT;\nEND_VAR\nVAR_OUTPUT\n output_1 : BOOL;\n output_2 : INT;\n output_3 : INT;\n output_4 : BOOL;\nEND_VAR\n\nFUNCTION_BLOCK PLC_PRG\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n pouBase_A: POU_BASE;\nEND_VAR 汎用モジュールインスタンスの表現で pouBase_A 、プラグマにより、入力ピンと出力ピンが次のように配置されます。 " }, 
{ "title" : "属性：pack_mode ", 
"url" : "_cds_pragma_attribute_pack_mode.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：pack_mode ", 
"snippet" : "pack_mode プラグマは、割り当て中にデータ構造がどのようにパックされるかを定義します。属性はデータ構造の上に挿入する必要があり、構造全体のパッキングに影響します。 構文 ： {attribute 'pack_mode' := ' <pack mode value> '} 挿入場所：データ構造の宣言の上 の可能な値 <pack mode value> <パックモード値> 関連する梱包方法 説明 0 整列 すべての変数はバイトアドレスに割り当てられます。メモリギャップはありません。 1 1バイト整列 2 2バイト整列 がある バイトアドレスの1バイト変数 2で割り切れるアドレスの2バイト変...", 
"body" : "pack_mode プラグマは、割り当て中にデータ構造がどのようにパックされるかを定義します。属性はデータ構造の上に挿入する必要があり、構造全体のパッキングに影響します。 構文 ： {attribute 'pack_mode' := ' <pack mode value> '} 挿入場所：データ構造の宣言の上 の可能な値 <pack mode value> <パックモード値> 関連する梱包方法 説明 0 整列 すべての変数はバイトアドレスに割り当てられます。メモリギャップはありません。 1 1バイト整列 2 2バイト整列 がある バイトアドレスの1バイト変数 2で割り切れるアドレスの2バイト変数。最大1バイトのギャップが生じます。 2で割り切れるアドレスの4バイト変数。最大1バイトのギャップが生じます。 2で割り切れるアドレスの8バイト変数。最大1バイトのギャップが生じます。 常にバイトアドレスにある文字列。ギャップは発生しません。 4 4バイト整列 がある バイトアドレスの1バイト変数 2で割り切れるアドレスの2バイト変数。最大1バイトのギャップが生じます。 4で割り切れるアドレスの4バイト変数。最大3バイトのギャップが生じます。 4で割り切れるアドレスの8バイト変数。最大3バイトのギャップが生じます。 常にバイトアドレスにある文字列。ギャップは発生しません。 8 8バイト整列 がある バイトアドレスの1バイト変数 2で割り切れるアドレスの2バイト変数。最大1バイトのギャップが生じます。 4で割り切れるアドレスの4バイト変数。最大3バイトのギャップが生じます。 8で割り切れるアドレスの8バイト変数。最大7バイトのギャップが生じます。 常にバイトアドレスにある文字列。ギャップは発生しません。 構造によっては、各モードのメモリマッピングに違いがない場合もあります。たとえば、構造体のメモリ分散は、 {attribute 'pack mode' := '4'} プラグマは次のプラグマに対応できます。 {attribute 'pack mode' := '8'} 。 構造体の配列 構造体が配列で結合されている場合、次の構造体が整列されるように、構造体の最後にバイトが追加されます。 の場合 互換性レイアウト シンボル構成でオプションが選択されていると同時に、属性が選択されている 'pack_mode' コードでが使用されている場合、意図しないメモリの不整合が原因で問題が発生する可能性があります。 使用時の悪影響 'pack-mode' アラインされていないメモリアクセスは、属性を使用した結果である可能性があります 'pack_mode' 。これは、たとえば、サイズが4バイトのデータ型が4で割り切れないアドレスに配置されることを意味します。通常、32ビットシステムでは、32ビットデータ型は次のように読み書きできます。シングルメモリアクセス。一部のプラットフォーム、たとえばARMプラットフォームでは、これはこの値がメモリ内で整列されている場合にのみ可能です。他のプラットフォームでは、アクセスは可能ですが、実行速度がはるかに遅くなる可能性があります。 {attribute 'pack_mode':=1}\n\nTYPE DUT\nSTRUCT\n by1 : BYTE;\n dw1 : DWORD;\nEND_STRUCT\nEND_TYPE ARMプラットフォームでは、値 dw1 1回のアクセスで読み取ることはできません。この要素に直接アクセスしようとすると、ARMプロセッサは例外をスローします。 仮定：次の読み取りアクセスが実行されます。 dwTest := dut1.dw1; このアクセスのために DWORD dw1 、各バイトが個別に読み取られ、シフトされ、分離されるため、4つのメモリアクセスが必要です。フローは、次の例と多少同じです。 DWORD 4バイトの配列から生成されます。 dwHelp := bytes[0];\ndwResult := dwHelp;\ndwHelp := bytes[1];\ndwHelp := SHL(dwHelp, 8);\ndwResult := dwResult OR dwHelp;\ndwHelp := bytes[2];\ndwHelp := SHL(dwHelp, 16);\ndwResult := dwResult OR dwHelp;\ndwHelp := bytes[3];\ndwHelp := SHL(dwHelp, 24);\ndwResult := dwResult OR dwHelp; 明らかに、この種のアクセスは、 DWORD 、メモリ内で適切に配置されます。 pdw := ADR(dut1.dw1);\ndwTest := pdw^; ただし、この種のメンバーがポインターを使用してアクセスされる場合、コンパイラーは例のアクセスを生成しません。これは、次のコードがARMプラットフォームで例外になることを意味します。 pdw := ADR(dut1.dw1);\ndwTest := pdw^; したがって、パフォーマンス上の理由から、自然に整列されていない構造での作業は避けてください。 パックされた構造には、アンパックされた構造が含まれていてはなりません。 " }, 
{ "title" : "例1 ", 
"url" : "_cds_pragma_attribute_pack_mode.html#UUID-c3d2a0b3-c4ff-c0ae-3564-f9f63f4a7e2b_id_a6bc74d60d70a21fc0a8640e001bdb68_id_6090971608ab9666c0a86463041fc5d3", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：pack_mode \/ 例1 ", 
"snippet" : "{attribute 'pack_mode' := '1'} TYPE myStruct: STRUCT Enable: BOOL; Counter: INT; MaxSize: BOOL; MaxSizeReached: BOOL; END_STRUCT END_TYPE データ型の変数のメモリ範囲 myStruct 「整列」して割り当てられます。そのコンポーネントのストレージアドレスの場合 Enable は 0x0100 たとえば、コンポーネント Counter 住所で続く 0x0101 、 MaxSize 住所で 0x0103 と MaxSizeReached 住所で 0x0104 。の...", 
"body" : "{attribute 'pack_mode' := '1'}\n\nTYPE myStruct:\nSTRUCT\n Enable: BOOL;\n Counter: INT;\n MaxSize: BOOL;\n MaxSizeReached: BOOL;\n END_STRUCT\nEND_TYPE データ型の変数のメモリ範囲 myStruct 「整列」して割り当てられます。そのコンポーネントのストレージアドレスの場合 Enable は 0x0100 たとえば、コンポーネント Counter 住所で続く 0x0101 、 MaxSize 住所で 0x0103 と MaxSizeReached 住所で 0x0104 。の場合 'pack_mode':=2 、 Counter になります 0x0102 、 MaxSize で 0x0104 と MaxSizeReached で 0x0105 。 " }, 
{ "title" : "例2 ", 
"url" : "_cds_pragma_attribute_pack_mode.html#UUID-c3d2a0b3-c4ff-c0ae-3564-f9f63f4a7e2b_id_a6bc74d60d70a21fc0a8640e001bdb68_id_c397029808b522b2c0a86463026f3ca1", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：pack_mode \/ 例2 ", 
"snippet" : "STRUCT Var1 : BOOL := 16#01; Var2 : BYTE := 16#11; Var3 : WORD := 16#22; Var4 : BYTE := 16#44; Var5 : DWORD := 16#88776655; Var6 : BYTE := 16#99; Var7 : BYTE := 16#AA; Var8 : DWORD := 16#AA; END_TYPE pack_mode = 8 pack_mode = 0 pack_mode = 1 pack_mode = 2 pack_mode = 4 変数 価値 変数 価値 変数 価値 変数 価値 変数 価値 ...", 
"body" : "STRUCT\n Var1 : BOOL := 16#01;\n Var2 : BYTE := 16#11;\n Var3 : WORD := 16#22;\n Var4 : BYTE := 16#44;\n Var5 : DWORD := 16#88776655;\n Var6 : BYTE := 16#99;\n Var7 : BYTE := 16#AA;\n Var8 : DWORD := 16#AA;\nEND_TYPE pack_mode = 8 pack_mode = 0 pack_mode = 1 pack_mode = 2 pack_mode = 4 変数 価値 変数 価値 変数 価値 変数 価値 変数 価値 0 Var1 01 Var1 01 Var1 01 Var1 01 Var1 01 1 Var2 11 Var2 11 Var2 11 Var2 11 Var2 11 2 Var3 22 Var3 22 Var3 22 Var3 22 Var3 22 3 … 00 … 00 … 00 … 00 … 00 4 Var4 44 Var4 44 Var4 44 Var4 44 Var4 44 5 Var5 55 Var5 55 6 … 66 … 66 Var5 55 7 … 77 … 77 … 66 8 Var5 55 … 88 … 88 … 77 Var5 55 9 … 66 Var6 99 Var6 99 … 88 … 66 10 … 77 Var7 AA Var7 AA Var6 99 … 77 11 … 88 Var8 AA Var8 AA Var7 AA … 88 12 Var6 99 … 00 … 00 Var8 AA Var6 99 13 Var7 AA … 00 … 00 … 00 Var7 AA 14 … 00 … 00 … 00 15 … 00 16 Var8 AA Var8 AA 17 … 00 … 00 18 … 00 … 00 19 … 00 … 00 20 21 22 23 24 25 26 27 28 29 30 31 " }, 
{ "title" : "例3 ", 
"url" : "_cds_pragma_attribute_pack_mode.html#UUID-c3d2a0b3-c4ff-c0ae-3564-f9f63f4a7e2b_id_a6bc74d60d70a21fc0a8640e001bdb68_id_7104e54be5bdcfb2c0a864634981a863", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：pack_mode \/ 例3 ", 
"snippet" : "STRUCT Var1 : BYTE := 16#01; Var2 : LWORD := 16#11; Var3 : BYTE := 16#22; Var4 : BYTE := 16#44; Var5 : DWORD := 16#88776655; Var6 : BYTE := 16#99; Var7 : BYTE := 16#AA; Var8 : WORD := 16#AA; END_TYPE pack_mode = 8 pack_mode = 0 pack_mode = 1 pack_mode = 2 pack_mode = 4 変数 価値 変数 価値 変数 価値 変数 価値 変数 価値 ...", 
"body" : "STRUCT\n Var1 : BYTE := 16#01;\n Var2 : LWORD := 16#11;\n Var3 : BYTE := 16#22;\n Var4 : BYTE := 16#44;\n Var5 : DWORD := 16#88776655;\n Var6 : BYTE := 16#99;\n Var7 : BYTE := 16#AA;\n Var8 : WORD := 16#AA;\nEND_TYPE pack_mode = 8 pack_mode = 0 pack_mode = 1 pack_mode = 2 pack_mode = 4 変数 価値 変数 価値 変数 価値 変数 価値 変数 価値 0 Var1 01 Var1 01 Var1 01 Var1 01 Var1 01 1 Var2 11 Var2 11 2 … 00 … 00 Var2 11 3 … 00 … 00 … 00 4 … 00 … 00 … 00 Var2 11 5 … 00 … 00 … 00 … 00 6 … 00 … 00 … 00 … 00 7 … 00 … 00 … 00 … 00 8 Var2 11 … 00 … 00 … 00 … 00 9 … 00 Var3 22 Var3 22 … 00 … 00 10 … 00 Var4 44 Var4 44 Var3 22 … 00 11 … 00 Var5 55 Var5 55 Var4 44 … 00 12 … 00 … 66 … 66 Var5 55 Var3 22 13 … 00 … 77 … 77 … 66 Var4 44 14 … 00 … 88 … 88 … 77 15 … 00 Var6 99 Var6 99 … 88 16 Var3 22 Var7 AA Var7 AA Var6 99 Var5 55 17 Var4 44 Var8 AA Var8 AA Var7 AA … 66 18 … 00 … 00 Var8 AA … 77 19 … 00 … 88 20 Var5 55 Var6 99 21 … 66 Var7 AA 22 … 77 Var8 AA 23 … 88 … 00 24 Var6 99 25 Var7 AA 26 Var8 AA 27 … 00 28 29 30 31 " }, 
{ "title" : "なしの行動 'pack-mode' ", 
"url" : "_cds_pragma_attribute_pack_mode.html#UUID-c3d2a0b3-c4ff-c0ae-3564-f9f63f4a7e2b_id_a6bc74d60d70a21fc0a8640e001bdb68_id_4b241196e5bdcfb2c0a864631282e50a", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：pack_mode \/ なしの行動 'pack-mode' ", 
"snippet" : "もしも 'pack-mode' が使用されていない場合、コンパイラは通常、デバイスの説明に応じてパックモード4または8を使用します。いずれの場合も、メモリアクセスを実行できるように、プロセッサにとって特に有益なパックモードが使用されます。これは、データの自然な配置または自然な配置とも呼ばれます...", 
"body" : "もしも 'pack-mode' が使用されていない場合、コンパイラは通常、デバイスの説明に応じてパックモード4または8を使用します。いずれの場合も、メモリアクセスを実行できるように、プロセッサにとって特に有益なパックモードが使用されます。これは、データの自然な配置または自然な配置とも呼ばれます " }, 
{ "title" : "属性：ProcessValue ", 
"url" : "_cds_pragma_attribute_processvalue.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：ProcessValue ", 
"snippet" : "ProcessValue とともに 'ProcessValue' 属性、構造体のメンバーを装飾します。その後、CFCエディターで、 属性付きメンバーを入力として使用する この構造をスカラー型の入力に接続するためのコマンド。 構文 ： {attribute 'ProcessValue'} 挿入位置：影響を受ける構造体メンバーの上の線。 例 TYPE QINT : STRUCT Status : STRING; {attribute 'ProcessValue'} Value1 : INT; Value2 : INT; END_STRUCT END_TYPE...", 
"body" : "ProcessValue とともに 'ProcessValue' 属性、構造体のメンバーを装飾します。その後、CFCエディターで、 属性付きメンバーを入力として使用する この構造をスカラー型の入力に接続するためのコマンド。 構文 ： {attribute 'ProcessValue'} 挿入位置：影響を受ける構造体メンバーの上の線。 例 TYPE QINT :\nSTRUCT\n Status : STRING;\n {attribute 'ProcessValue'}\n Value1 : INT;\n Value2 : INT;\nEND_STRUCT\nEND_TYPE " }, 
{ "title" : "属性：qualified_only ", 
"url" : "_cds_pragma_attribute_qualified_only.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：qualified_only ", 
"snippet" : "qualified_only このプラグマの効果は、グローバル変数リストの変数が、たとえばグローバル変数名を指定することによってのみアドレス指定されることです。 gvl.g_var 。これは、列挙型の変数にも適用され、ローカル変数と間違われるのを防ぐのに役立ちます。 構文 ： {attribute 'qualified_only'} 挿入場所：上の行 VAR_GLOBAL GVLで 例 グローバル変数リスト GVL ： {attribute 'qualified_only'} VAR_GLOBAL iVar:INT; END_VAR たとえば、POU内 PLC_PRG 、グローバル変数 iVa...", 
"body" : "qualified_only このプラグマの効果は、グローバル変数リストの変数が、たとえばグローバル変数名を指定することによってのみアドレス指定されることです。 gvl.g_var 。これは、列挙型の変数にも適用され、ローカル変数と間違われるのを防ぐのに役立ちます。 構文 ： {attribute 'qualified_only'} 挿入場所：上の行 VAR_GLOBAL GVLで 例 グローバル変数リスト GVL ： {attribute 'qualified_only'}\nVAR_GLOBAL\n iVar:INT;\nEND_VAR たとえば、POU内 PLC_PRG 、グローバル変数 iVar プレフィックスを使用してのみアドレス指定できます GVL ： GVL.iVar:=5; 逆に、次の変数の不完全な呼び出しはエラーを作成します。 iVar:=5; " }, 
{ "title" : "属性：reflection ", 
"url" : "_cds_pragma_attribute_reflection.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：reflection ", 
"snippet" : "reflection プラグマは、コンパイラがPOUを装飾して、で装飾された関数ブロック変数を検索します。 'instance-path' 属性または 'is_connected' 属性。これらの種類の変数を持つPOUには、特別な処理が必要です。 コンパイラは、で装飾されたブロックのみを検索します 'reflection' これらの属性を持つ変数の場合、したがって必要な時間は短くなります。 構文 ： {attribute 'reflection'} 詳細については、以下を参照してください。 instance-path と is_connected...", 
"body" : "reflection プラグマは、コンパイラがPOUを装飾して、で装飾された関数ブロック変数を検索します。 'instance-path' 属性または 'is_connected' 属性。これらの種類の変数を持つPOUには、特別な処理が必要です。 コンパイラは、で装飾されたブロックのみを検索します 'reflection' これらの属性を持つ変数の場合、したがって必要な時間は短くなります。 構文 ： {attribute 'reflection'} 詳細については、以下を参照してください。 instance-path と is_connected" }, 
{ "title" : "属性：後続 ", 
"url" : "_cds_pragma_attribute_subsequent.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：後続 ", 
"snippet" : "subsequent VAR_TEMP 属性を持つプログラムで 'subsequent' コンパイラエラーにつながります。 プラグマは、メモリ内の連続する変数を割り当てるために使用されます。リストが変更されると、変数リスト全体が新しいメモリ領域に割り当てられます。このプラグマは、プログラムおよびグローバル変数リストで使用されます。 構文 ： {attribute 'subsequent'} リスト内の変数がで修飾されている場合 RETAIN 、宣言部分のすべての変数は、次のメモリ領域に格納されます。 RETAIN 。...", 
"body" : "subsequent VAR_TEMP 属性を持つプログラムで 'subsequent' コンパイラエラーにつながります。 プラグマは、メモリ内の連続する変数を割り当てるために使用されます。リストが変更されると、変数リスト全体が新しいメモリ領域に割り当てられます。このプラグマは、プログラムおよびグローバル変数リストで使用されます。 構文 ： {attribute 'subsequent'} リスト内の変数がで修飾されている場合 RETAIN 、宣言部分のすべての変数は、次のメモリ領域に格納されます。 RETAIN 。 " }, 
{ "title" : "属性：to_string ", 
"url" : "_cds_pragma_attribute_to_string.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：to_string ", 
"snippet" : "to_string プラグマは、列挙型コンポーネントを変換した結果がどのように影響するかに影響します。 TO_STRING 演算子が出力されます。列挙型宣言にプラグマがある場合、列挙型コンポーネントの名前は数値ではなく文字列として表示されます。 構文： {attribute 'to_string'} 挿入場所：列挙の宣言部分の上の最初の行。 例 列挙の宣言 color ： {attribute 'to_string'} TYPE COLOR: ( red := 0, blue := 1, green := 2 ); END_TYPE との変換 TO_STRING ： PROGRAM PLC_P...", 
"body" : "to_string プラグマは、列挙型コンポーネントを変換した結果がどのように影響するかに影響します。 TO_STRING 演算子が出力されます。列挙型宣言にプラグマがある場合、列挙型コンポーネントの名前は数値ではなく文字列として表示されます。 構文： {attribute 'to_string'} 挿入場所：列挙の宣言部分の上の最初の行。 例 列挙の宣言 color ： {attribute 'to_string'}\nTYPE COLOR:\n(\n red := 0,\n blue := 1,\n green := 2\n);\nEND_TYPE との変換 TO_STRING ： PROGRAM PLC_PRG\nVAR\n i_color: COLOR;\n s_show_color: STRING;\nEND_VAR\ni_color := 1;\ns_show_color := TO_STRING(i_color); この場合、 s_show_color 値を取得します 'blue' それ以外の 1 変換結果として。 " }, 
{ "title" : "属性: suppress_warning ", 
"url" : "_cds_pragma_attribute_suppress_warning.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性: suppress_warning ", 
"snippet" : "suppress_warning このプラグマには、このプラグマの定義で指定されたコンパイラ警告を抑制する効果があります。 構文： {attribute 'suppress_warning' := '<warning id1>','<warning id2>',...} 挿入ポイント: POUまたはDUTの宣言部分の上の行 例 {attribute 'suppress_warning' := '0125'} TYPE DUT_1 : ( enum_member1 := 0, enum_member2 := 0 ); END_TYPE 警告 C0125 は抑制されます。...", 
"body" : "suppress_warning このプラグマには、このプラグマの定義で指定されたコンパイラ警告を抑制する効果があります。 構文： {attribute 'suppress_warning' := '<warning id1>','<warning id2>',...} 挿入ポイント: POUまたはDUTの宣言部分の上の行 例 {attribute 'suppress_warning' := '0125'}\nTYPE DUT_1 :\n(\n enum_member1 := 0,\n enum_member2 := 0\n);\nEND_TYPE\n 警告 C0125 は抑制されます。 " }, 
{ "title" : "属性：warning disable, warning restore ", 
"url" : "_cds_pragma_attribute_warning_disable.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 属性プラグマ \/ 属性：warning disable, warning restore ", 
"snippet" : "warning disable , warning restore の warning disable 属性には、特定の警告を抑制する効果があります。の warning restore プラグマは抑制されたメッセージを再アクティブ化します。 この属性はすべてのコンパイラ警告に使用できます。すべてのコンパイラ警告のリストは、 CODESYS Development System プロジェクトのプロジェクト設定（ プロジェクト → プロジェクト設定 、 コンパイラの警告 カテゴリー）。 構文 ： {warning disable <compiler ID>} {warning restore <c...", 
"body" : "warning disable , warning restore の warning disable 属性には、特定の警告を抑制する効果があります。の warning restore プラグマは抑制されたメッセージを再アクティブ化します。 この属性はすべてのコンパイラ警告に使用できます。すべてのコンパイラ警告のリストは、 CODESYS Development System プロジェクトのプロジェクト設定（ プロジェクト → プロジェクト設定 、 コンパイラの警告 カテゴリー）。 構文 ： {warning disable <compiler ID>} {warning restore <compiler ID>} <compiler ID> ：エラーまたは警告メッセージの先頭にあるID。 例 コンパイラメッセージ: typify code ...\nC0195: Implicit conversion from unsigned Type 'UINT' to signed Type 'INT' : possible change of sign\nCompile complete -- 0 errors プラグマを変数宣言に適用する： VAR\n {warning disable C0195}\n test1 : UINT := -1;\n {warning restore C0195}\n test2 : UINT := -1;\nEND_VAR test1 警告は生成されません。 test2 警告を生成します。 " }, 
{ "title" : "条件付きプラグマ ", 
"url" : "_cds_pragma_conditional.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ ", 
"snippet" : "条件付きプラグマの場合の制限 条件付きコンパイル用のプラグマは、POU の実装でのみ使用してください。宣言では、これらのプラグマは無視され、評価されません。 次の例外に注意してください:IFプラグマは project_defined 演算子を宣言に挿入できます。詳細については、以下を参照してください。IFプラグマと project_defined (<global define>)プラグマは、プリコンパイル処理中およびコンパイル処理中にコンパイラによって評価されます。この処理は条件付きコンパイルと呼ばれます。ST実装言語はこれらのプラグマをサポートしています。 その {IF<expressio...", 
"body" : "条件付きプラグマの場合の制限 条件付きコンパイル用のプラグマは、POU の実装でのみ使用してください。宣言では、これらのプラグマは無視され、評価されません。 次の例外に注意してください:IFプラグマは project_defined 演算子を宣言に挿入できます。詳細については、以下を参照してください。IFプラグマと project_defined (<global define>)プラグマは、プリコンパイル処理中およびコンパイル処理中にコンパイラによって評価されます。この処理は条件付きコンパイルと呼ばれます。ST実装言語はこれらのプラグマをサポートしています。 その {IF<expression> } プラグマと {ELSIF<expression> } 、 {ELSE} そして結論 {END_IF} 指定された条件に応じて保持または無視される実装内のコードを示します。 <expression> 異なるオペランドと演算子で構成できる整数定数式です。 コンパイル時に、 <{IF <expression>} 評価されます。その戻り値が FALSE すると、次の分岐が発生します {ELSIF <expression>} セグメントと、セグメントが次の式を返すまでそこで評価される式 TRUE 式は、0以外の値を返すまで順次評価されます。この式に関連付けられたコードセグメントのみがコンパイルされ、他の式は無視されます。すべての式が0を返す場合、分岐が発生します。 {ELSE} 。もし {ELSE} プラグマが欠落している場合、コード セグメントがコンパイルされない可能性があります。 構文 コードフラグメントの例 説明 {IF <expression> } {IF defined (DEF0815)}\n{info 'DEF0815 has been defined'}\nCnt0815 := iCnt0815 + 1; 有効な場合にコンパイルされるコードセグメントの先頭にラベルを付ける <expression> 状態。 {ELSIF <expression> } {ELSIF defined (DEF0816)}\n{info 'DEF0815 has been defined'}\niCnt0816 := iCnt0816 + 1; なし、1つ、または複数） 有効な場合に代替コードセグメントにラベルを付ける分岐 <expression> 状態 {ELSE} {ELSE}\n{info 'DEF0815 not defined'}\niCnt0 := iCnt0 - 1; オプション 前の条件が満たされなかった場合にコンパイルされるコードセグメントにラベルを付けるブランチ {END_IF} {END_IF} 条件付きコードセグメントの終了を示すラベル <expression> defined (DEF0815) 状態 コンパイル時に定数であり、コンパイラ定義、変数、リテラルなどの演算子とオペランドで構成できる整数式 " }, 
{ "title" : "コンパイラ定義 ", 
"url" : "_cds_pragma_conditional.html#UUID-9d13f749-64d4-ea6e-d526-1046cb95981c_section-idm13512919386826", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ コンパイラ定義 ", 
"snippet" : "コンパイラ定義は、コード内の特定の状態を表すラベルとして使用されます。コンパイラ定義は、defined演算子を使用して設定、削除、またはチェックできます。 構文 例 説明 {define <name> } {define DEF0815} コンパイラを定義する <name> タイプ付き BOOL コンパイラは定義する <name> 有効な識別子のルールに従います。 {define <name> <string> } {define DEF0123 '123'} コンパイラを定義する <name> 文字列リテラルを割り当てる <string> 価値として {undefine <name>} {u...", 
"body" : "コンパイラ定義は、コード内の特定の状態を表すラベルとして使用されます。コンパイラ定義は、defined演算子を使用して設定、削除、またはチェックできます。 構文 例 説明 {define <name> } {define DEF0815} コンパイラを定義する <name> タイプ付き BOOL コンパイラは定義する <name> 有効な識別子のルールに従います。 {define <name> <string> } {define DEF0123 '123'} コンパイラを定義する <name> 文字列リテラルを割り当てる <string> 価値として {undefine <name>} {undefine DEF0815} コンパイラ定義を削除します <name> その結果、識別子は未定義になります。未定義のコンパイラ定義を持つプラグマは無視されます。 あるいは、POU のプロパティでローカルに式とコンパイラ定義を定義したり、上位アプリケーションのプロパティでアプリケーション全体で定義したりすることもできます。 これを行うには、デバイスツリーでPOUまたは上位アプリケーションを選択します。コンテキストメニューで、 プロパティ そして、 建てる タブ。 コンパイラ定義 入力フィールドには、リテラルまたは式を定義できます（例：DEF0815）。入力フィールドには、次のようなプラグマ文は想定されていません。 {define } 、単なる名前です。 複数のコンパイラ定義をコンマで区切って指定できます。 " }, 
{ "title" : "オペレーター ", 
"url" : "_cds_pragma_conditional.html#UUID-7d0f412c-5a63-338b-4d5a-f9f63d4bbeb3", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "defined (variable: <variable name> ) ", 
"url" : "_cds_pragma_conditional.html#UUID-56a3dfa0-d8ff-39b2-d406-47873393107c", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ defined (variable: <variable name> ) ", 
"snippet" : "演算子により、式に値が与えられます TRUE 変数が <variable name> 現在のスコープ内で宣言されています。さもないと FALSE が返されます。 例 要件：2つのアプリケーション App1 と App2 存在。変数 g_bTest で宣言されています App1 、しかしではない App2 。 {IF defined (variable: g_bTest)} (* the following code is only processed in App2*) g_bTest := x > 300; {END_IF}...", 
"body" : "演算子により、式に値が与えられます TRUE 変数が <variable name> 現在のスコープ内で宣言されています。さもないと FALSE が返されます。 例 要件：2つのアプリケーション App1 と App2 存在。変数 g_bTest で宣言されています App1 、しかしではない App2 。 {IF defined (variable: g_bTest)}\n (* the following code is only processed in App2*)\n g_bTest := x > 300;\n{END_IF} " }, 
{ "title" : "defined (<identifier>) ", 
"url" : "_cds_pragma_conditional.html#UUID-e54af038-800e-5327-8957-cece6e7ac986", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ defined (<identifier>) ", 
"snippet" : "演算子により、式に値が与えられます TRUE 。要件は、識別子が <identifier> によって定義されています {define} ステートメントであり、後で未定義ではありません {undefine} 声明。さもないと FALSE が返されます。 要件：アプリケーション App1 と App2 存在。 The pdef1 変数はによって定義されます {define} のステートメント App1 、しかしではない App2 。 {IF defined (pdef1)} (* This code is processed in App1 *) {info 'pdef1 defined'} hu...", 
"body" : "演算子により、式に値が与えられます TRUE 。要件は、識別子が <identifier> によって定義されています {define} ステートメントであり、後で未定義ではありません {undefine} 声明。さもないと FALSE が返されます。 要件：アプリケーション App1 と App2 存在。 The pdef1 変数はによって定義されます {define} のステートメント App1 、しかしではない App2 。 {IF defined (pdef1)}\n(* This code is processed in App1 *)\n{info 'pdef1 defined'}\n hugo := hugo + SINT#1;\n{ELSE}\n(* the following code is only processed in App2 *)\n{info 'pdef1 not defined'}\n hugo := hugo - SINT#1;\n{END_IF} これには、メッセージプラグマの例も含まれます。メッセージのみ pdef1 defined アプリケーションがコンパイルされると、メッセージビューにが表示されます。 pdef1 実際に定義されています。メッセージ pdef1 not defined が表示されるとき pdef1 定義されていません。 " }, 
{ "title" : "defined (type: <identifier> ) ", 
"url" : "_cds_pragma_conditional.html#UUID-c146e29c-1435-150f-39b5-3565709c5179", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ defined (type: <identifier> ) ", 
"snippet" : "演算子により、式に値が与えられます TRUE データ型が識別子で宣言されている場合 <identifier> 。さもないと FALSE が返されます。 例 要件：2つのアプリケーション App1 と App2 存在。データ型 DUT で宣言されています App1 、しかしではない App2 。 {IF defined (type: DUT)} (* the following code is only processed in App1*) bDutDefined := TRUE; {END_IF}...", 
"body" : "演算子により、式に値が与えられます TRUE データ型が識別子で宣言されている場合 <identifier> 。さもないと FALSE が返されます。 例 要件：2つのアプリケーション App1 と App2 存在。データ型 DUT で宣言されています App1 、しかしではない App2 。 {IF defined (type: DUT)}\n (* the following code is only processed in App1*)\n bDutDefined := TRUE;\n{END_IF} " }, 
{ "title" : "defined (pou: <pou name>) ", 
"url" : "_cds_pragma_conditional.html#UUID-17139d7e-07b4-d059-ab0e-e4045ec20bd0", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ defined (pou: <pou name>) ", 
"snippet" : "演算子により、式に値が与えられます TRUE 名前を持つ次のオブジェクトのいずれか <pou-name> 存在します: 機能ブロック 関数 プログラム アクション 方法 インターフェース さもないと FALSE 返されます。 例 要件：2つのアプリケーション App1 と App2 存在。 POU CheckBounds に存在します App1 、しかしではない App2 。 {IF defined (pou: CheckBounds)} (* the following code is only processed in App1 *) arrTest[CheckBounds(0,i,10)...", 
"body" : "演算子により、式に値が与えられます TRUE 名前を持つ次のオブジェクトのいずれか <pou-name> 存在します: 機能ブロック 関数 プログラム アクション 方法 インターフェース さもないと FALSE 返されます。 例 要件：2つのアプリケーション App1 と App2 存在。 POU CheckBounds に存在します App1 、しかしではない App2 。 {IF defined (pou: CheckBounds)}\n (* the following code is only processed in App1 *)\n arrTest[CheckBounds(0,i,10)] := arrTest[CheckBounds(0,i,10)] + 1;\n{ELSE}\n (* the following code is only processed in App2 *)\n arrTest[i] := arrTest[i]+1;\n{END_IF} " }, 
{ "title" : "defined (resource: <identifier>) ", 
"url" : "_cds_pragma_conditional.html#UUID-0a21b728-bc6a-38b2-4fa2-d84b00fc80ee", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ defined (resource: <identifier>) ", 
"snippet" : "まだ実装されていません 演算子により、式に値が与えられます TRUE 名前の付いたリソースオブジェクトの場合 <identifier> アプリケーション用に存在します。それ以外は FALSE が返されます。 要件：2つのアプリケーション App1 と App2 存在。リソースオブジェクト glob_var1 グローバル変数リストの App1 、ただし App2 。 {IF defined (resource:glob_var1)} (* the following code is only processed in App1 *) gvar_x := gvar_x + ivar; {ELSE}...", 
"body" : "まだ実装されていません 演算子により、式に値が与えられます TRUE 名前の付いたリソースオブジェクトの場合 <identifier> アプリケーション用に存在します。それ以外は FALSE が返されます。 要件：2つのアプリケーション App1 と App2 存在。リソースオブジェクト glob_var1 グローバル変数リストの App1 、ただし App2 。 {IF defined (resource:glob_var1)}\n (* the following code is only processed in App1 *)\n gvar_x := gvar_x + ivar;\n{ELSE}\n (* the following code is only processed in App2 *)\n x := x + ivar;\n{END_IF} " }, 
{ "title" : "defined (task: <task name> ) ", 
"url" : "_cds_pragma_conditional.html#UUID-ccc52caa-f156-4e60-c0cd-17886ea9795b", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ defined (task: <task name> ) ", 
"snippet" : "演算子により、式に値が与えられます TRUE タスクが名前で定義されている場合 <task name> 。さもないと FALSE が返されます。 構文 { IF defined (task: <task name> } { ELSIF defined (task: <task name> } 例 {IF defined (task: Task_D)} 例 要件：2つのアプリケーション App1 と App2 存在。タスク PLC_PRG_Task で定義されています App1 、しかしではない App2 。 {IF defined (task: PLC_PRG_Task)} (* the fo...", 
"body" : "演算子により、式に値が与えられます TRUE タスクが名前で定義されている場合 <task name> 。さもないと FALSE が返されます。 構文 { IF defined (task: <task name> }\n{ ELSIF defined (task: <task name> } 例 {IF defined (task: Task_D)} 例 要件：2つのアプリケーション App1 と App2 存在。タスク PLC_PRG_Task で定義されています App1 、しかしではない App2 。 {IF defined (task: PLC_PRG_Task)}\n (* the following code is only processed in App1 *)\n erg := plc_prg.x;\n{ELSE}\n (* the following code is only processed in App2 *)\n erg := prog.x;\n{END_IF} " }, 
{ "title" : "defined (IsLittleEndian) ", 
"url" : "_cds_pragma_conditional.html#UUID-516da2c9-04fd-3845-f55a-087fc2d2aeab", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ defined (IsLittleEndian) ", 
"snippet" : "演算子により、式に値が与えられます FALSE CPUメモリがビッグエンディアン（モトローラバイトオーダー）で編成されている場合。...", 
"body" : "演算子により、式に値が与えられます FALSE CPUメモリがビッグエンディアン（モトローラバイトオーダー）で編成されている場合。 " }, 
{ "title" : "defined (IsSimulationMode) ", 
"url" : "_cds_pragma_conditional.html#UUID-3ab4b0b9-4bdc-b8a9-4b97-18745c21d26d", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ defined (IsSimulationMode) ", 
"snippet" : "演算子により、式に値が与えられます TRUE アプリケーションがシミュレートされたデバイスで実行されている場合（シミュレーションモード）。 詳細については、以下を参照してください。 シミュレーションモードでのテスト...", 
"body" : "演算子により、式に値が与えられます TRUE アプリケーションがシミュレートされたデバイスで実行されている場合（シミュレーションモード）。 詳細については、以下を参照してください。 シミュレーションモードでのテスト" }, 
{ "title" : "defined (IsFPUSupported) ", 
"url" : "_cds_pragma_conditional.html#UUID-77021421-79d5-0d58-faff-96b1b4636fcc", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ defined (IsFPUSupported) ", 
"snippet" : "式が値を返す場合 TRUE 、次に、コードジェネレータは、で計算するときにFPUコード（浮動小数点ユニットプロセッサ用）を生成します。 REAL 値。それ以外の場合、FPU操作はエミュレートされますが、これははるかに低速です。...", 
"body" : "式が値を返す場合 TRUE 、次に、コードジェネレータは、で計算するときにFPUコード（浮動小数点ユニットプロセッサ用）を生成します。 REAL 値。それ以外の場合、FPU操作はエミュレートされますが、これははるかに低速です。 " }, 
{ "title" : "hasattribute (pou: <pou name>, ' <attribute name> ') ", 
"url" : "_cds_pragma_conditional.html#UUID-5ca43390-2187-c6be-b000-d6a460e76960", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ hasattribute (pou: <pou name>, ' <attribute name> ') ", 
"snippet" : "演算子により、式に値が与えられます TRUE 属性が <attribute> 関数ブロックの宣言部分の最初の行で指定されます <pou name> 。さもないと FALSE が返されます。 例 要件：2つのアプリケーション App1 と App2 存在。関数 fun1 で宣言されています App1 と App2 。ただし、 App1 プラグマも付属しています {attribute 'vision'} 。 の App1 ： {attribute 'vision'} FUNCTION fun1 : INT VAR_INPUT i : INT; END_VAR VAR END_VAR の App2 ...", 
"body" : "演算子により、式に値が与えられます TRUE 属性が <attribute> 関数ブロックの宣言部分の最初の行で指定されます <pou name> 。さもないと FALSE が返されます。 例 要件：2つのアプリケーション App1 と App2 存在。関数 fun1 で宣言されています App1 と App2 。ただし、 App1 プラグマも付属しています {attribute 'vision'} 。 の App1 ： {attribute 'vision'}\nFUNCTION fun1 : INT\nVAR_INPUT\n i : INT;\nEND_VAR\nVAR\nEND_VAR の App2 ： FUNCTION fun1 : INT\nVAR_INPUT\n i : INT;\nEND_VAR\nVAR\nEND_VAR プラグマステートメント： {IF hasattribute (pou: fun1, 'vision')}\n (* the following code is only processed in App1 *)\n ergvar := fun1(ivar);\n{END_IF} " }, 
{ "title" : "hasattribute (variable: <variable name> , ' <attribute name> ') ", 
"url" : "_cds_pragma_conditional.html#UUID-acc24196-3e5c-73ec-b19f-e7572000a697", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ hasattribute (variable: <variable name> , ' <attribute name> ') ", 
"snippet" : "演算子により、式に値が与えられます TRUE プラグマが {attribute '<attribute>'} 変数宣言の前の行の変数に割り当てられます。さもないと FALSE が返されます。 例 要件：2つのアプリケーション App1 と App2 存在。変数 g_globalInt で使用されます App1 と App2 、しかしで App1 属性 'DoCount' にも割り当てられています。 の宣言 g_GlobalInt の App1 VAR_GLOBAL {attribute 'DoCount'} g_globalInt : INT; g_multiType : STRING; EN...", 
"body" : "演算子により、式に値が与えられます TRUE プラグマが {attribute '<attribute>'} 変数宣言の前の行の変数に割り当てられます。さもないと FALSE が返されます。 例 要件：2つのアプリケーション App1 と App2 存在。変数 g_globalInt で使用されます App1 と App2 、しかしで App1 属性 'DoCount' にも割り当てられています。 の宣言 g_GlobalInt の App1 VAR_GLOBAL\n {attribute 'DoCount'}\n g_globalInt : INT;\n g_multiType : STRING;\nEND_VAR 宣言 g_GlobalInt の App2 ： VAR_GLOBAL\n g_globalInt : INT;\n g_multiType : STRING;\nEND_VAR プラグマステートメント： {IF hasattribute (variable: g_globalInt, 'DoCount')}\n (* the following code is only processed in App1 *)\n g_globalInt := g_globalInt + 1;\n{END_IF} " }, 
{ "title" : "hasconstanttype( <constant name> , <boolean literal> ) ", 
"url" : "_cds_pragma_conditional.html#UUID-30672799-4e6a-2fbc-3929-5daa20235b68", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ hasconstanttype( <constant name> , <boolean literal> ) ", 
"snippet" : "オペレーターは、次のように識別される定数かどうかを確認します。 <constant name> 、置き換えられました。 2番目のパラメーター（ブール値）は、チェック対象を制御します。 TRUE ：定数が置き換えられているかどうかを確認します FALSE ：定数が置き換えられていないかどうかを確認します それぞれのケースが発生すると、オペレーターは TRUE 。 構文 { IF hasconstanttype( <constant namne> , <boolean literal> ) } { ELSIF hasconstanttype( <constant namne> , <boolean...", 
"body" : "オペレーターは、次のように識別される定数かどうかを確認します。 <constant name> 、置き換えられました。 2番目のパラメーター（ブール値）は、チェック対象を制御します。 TRUE ：定数が置き換えられているかどうかを確認します FALSE ：定数が置き換えられていないかどうかを確認します それぞれのケースが発生すると、オペレーターは TRUE 。 構文 { IF hasconstanttype( <constant namne> , <boolean literal> ) } { ELSIF hasconstanttype( <constant namne> , <boolean literal> ) } 例 {IF hasconstanttype(PLC_PRG.aConst, TRUE)} 定数の自動置換は、原則として以下に依存します。 コンパイルオプション 定数を置き換える 定数型（たとえば、 STRING タイプが置き換えられることはありません。） 属性の使用法 {attribute 'const_non_replaced'} 属性の使用法 {attribute 'const_replaced'} 例 VAR\n iCntMAXIsReplaced: INT;\n xErrorOccured : BOOL;\nEND_VAR\nVAR CONSTANT\n c_iMAX: INT := 99;\nEND_VAR\n\n{IF hasconstanttype(c_iMAX, TRUE)}\n iCntMAXIsReplaced := iCntMAXIsReplaced + 1;\n{ELSE}\n xErrorOccured := FALSE;\n{END_IF} " }, 
{ "title" : "hasconstantvalue( <constant name> , <variable name> , <comparison operator> ) ", 
"url" : "_cds_pragma_conditional.html#UUID-f4c0c696-3507-eafb-ef9c-09e853c3e51a", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ hasconstantvalue( <constant name> , <variable name> , <comparison operator> ) ", 
"snippet" : "演算子は、定数の値を比較します。 <constant name> 、2番目のパラメーターの値を使用します。 2番目のパラメーターは、リテラルとして指定できます <literal> または変数として <variable name> 。 比較演算子 <comparison operator> ： 大なり記号（ > ）。 以上 （ >= ）。 に等しい （ = ）。 （に等しくない <> ）。 （以下） <= ）。 未満 （ < ）。 構文 { IF hasconstantvalue( <constant name> , <variable name> , <comparison operator>...", 
"body" : "演算子は、定数の値を比較します。 <constant name> 、2番目のパラメーターの値を使用します。 2番目のパラメーターは、リテラルとして指定できます <literal> または変数として <variable name> 。 比較演算子 <comparison operator> ： 大なり記号（ > ）。 以上 （ >= ）。 に等しい （ = ）。 （に等しくない <> ）。 （以下） <= ）。 未満 （ < ）。 構文 { IF hasconstantvalue( <constant name> , <variable name> , <comparison operator> ) { IF hasconstantvalue( <constant name> , <literal> , <comparison operator> ) { ELSIF hasconstantvalue( <constant name> , <variable name> , <comparison operator> ) { ELSIF hasconstantvalue( <constant name> , <literal> , <comparison operator> ) 例 {IF hasconstantvalue(PLC_PRG.aConst, 99, >)} {ELSIF hasconstantvalue(PLC_PRG.aConst, GVL.intconst99, =)} 例 PROGRAM PRG_ConditionConstantValue\nVAR\n iCntMAX: INT;\n iCntGlobalMAX : INT;\n iCntABC: INT;\n iCntGlobalABC : INT;\n xErrorOccured : BOOL;\nEND_VAR\nVAR CONSTANT\n c_iMAX: INT := 999;\n c_sABC: STRING := 'ABC';\n {attribute 'const_non_replaced'}\n c_iNonReplaceable: INT := 888;\nEND_VAR\n\n{IF hasconstantvalue(c_iMAX, 999, =)}\n iCntMAX := iCntMAX + 1;\n{ELSE}\n xErrorOccured := FALSE;\n{END_IF}\n\n{IF hasconstantvalue(c_iMAX, GVL.gc_iMAX, =)}\n iCntGlobalMAX := iCntGlobalMAX + 1;\n{ELSE}\n xErrorOccured := FALSE;\n{END_IF}\n\n{IF hasconstantvalue(c_sABC, 'ABC', =)}\n iCntABC := iCntMAX + 1;\n{ELSE}\n xErrorOccured := FALSE;\n{END_IF}\n{IF hasconstantvalue(c_sABC, GVL.gc_sABC, =)}\n iCntGlobalABC := iCntMAX + 1;\n{ELSE}\n xErrorOccured := FALSE;\n{END_IF} " }, 
{ "title" : "hastype (variable: <variable name>, <data type> ) ", 
"url" : "_cds_pragma_conditional.html#UUID-92747db0-9849-d5df-f302-8252875bbffa", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ hastype (variable: <variable name>, <data type> ) ", 
"snippet" : "演算子により、式に値が与えられます TRUE 変数が <variable> データ型です <type-spec> 。さもないと FALSE が返されます。 可能なデータ型： BOOL | BYTE | DATE | DATE_AND_TIME | DT | DINT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTIME_OF_DAY | LTOD | LWORD | REAL | SINT | STRING | TIME | TIME_OF_DAY | TOD | ULINT | UDINT | ...", 
"body" : "演算子により、式に値が与えられます TRUE 変数が <variable> データ型です <type-spec> 。さもないと FALSE が返されます。 可能なデータ型： BOOL | BYTE | DATE | DATE_AND_TIME | DT | DINT | DWORD | INT | LDATE | LDATE_AND_TIME | LDT | LINT | LREAL | LTIME | LTIME_OF_DAY | LTOD | LWORD | REAL | SINT | STRING | TIME | TIME_OF_DAY | TOD | ULINT | UDINT | UINT | USINT | WORD | WSTRING 例 要件：2つのアプリケーション App1 と App2 存在。変数 g_multitype で宣言されています App1 データ型付き LREAL 、 の App2 データ型付き STRING 。 {IF (hastype (variable: g_multitype, LREAL))}\n (* the following code is only processed in App1 *)\n g_multitype := (0.9 + g_multitype) * 1.1;\n{ELSIF (hastype (variable: g_multitype, STRING))}\n (* the following code is only processed in App2 *)\n g_multitype := 'this is a multitalent';\n{END_IF} " }, 
{ "title" : "hasvalue (PackMode, ' <pack mode value> ') ", 
"url" : "_cds_pragma_conditional.html#UUID-2d0744fc-1387-4648-5d01-12d8bd56a114", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ hasvalue (PackMode, ' <pack mode value> ') ", 
"snippet" : "チェックパックモードは、個々のDUTに指定できるプラグマではなく、デバイスの説明に依存します。...", 
"body" : "チェックパックモードは、個々のDUTに指定できるプラグマではなく、デバイスの説明に依存します。 " }, 
{ "title" : "hasvalue (RegisterSize, ' <register size> ') ", 
"url" : "_cds_pragma_conditional.html#UUID-67a2d0e4-3a2a-3ab9-e96a-c17f6bf3b581", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ hasvalue (RegisterSize, ' <register size> ') ", 
"snippet" : "<register size> ：CPUレジスタのサイズ（ビット単位） 演算子により、式は値を返します TRUE CPUレジスタのサイズが等しい場合 <register size> 。 の可能な値 <register size> 16 C16xの場合、 64 X86-64ビットの場合 32 X86-32ビット用...", 
"body" : "<register size> ：CPUレジスタのサイズ（ビット単位） 演算子により、式は値を返します TRUE CPUレジスタのサイズが等しい場合 <register size> 。 の可能な値 <register size> 16 C16xの場合、 64 X86-64ビットの場合 32 X86-32ビット用 " }, 
{ "title" : "hasvalue (<define-ident>, ' <character string> ') ", 
"url" : "_cds_pragma_conditional.html#UUID-a865c5bf-1e43-4a57-cddc-238d2a436773", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ hasvalue (<define-ident>, ' <character string> ') ", 
"snippet" : "演算子により、式に値が与えられます TRUE 変数が識別子で定義されている場合 <define-ident> と値を持っています <char-string> 。さもないと FALSE が返されます。 例 要件：2つのアプリケーション App1 と App2 存在。変数 test アプリケーションで使用されます App1 と App2 。の App1 、値が与えられます 1 。の App2 、値が与えられます 2 。 {IF hasvalue(test,'1')} (* the following code is only processed in App1 *) x := x + 1; {EL...", 
"body" : "演算子により、式に値が与えられます TRUE 変数が識別子で定義されている場合 <define-ident> と値を持っています <char-string> 。さもないと FALSE が返されます。 例 要件：2つのアプリケーション App1 と App2 存在。変数 test アプリケーションで使用されます App1 と App2 。の App1 、値が与えられます 1 。の App2 、値が与えられます 2 。 {IF hasvalue(test,'1')}\n (* the following code is only processed in App1 *)\n x := x + 1;\n{ELSIF hasvalue(test,'2')}\n (* the following code is only processed in App2 *)\n x := x + 2;\n{END_IF} " }, 
{ "title" : "project_defined (<global define>) ", 
"url" : "_cds_pragma_conditional.html#UUID-801188c2-bd31-aef6-8db9-6d83d2d1c459", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ project_defined (<global define>) ", 
"snippet" : "このオペレータは以下から使用できます CODESYS V3.5 SP20 演算子により、式は値を受け取ります。 TRUE グローバル定義の場合 <global define> のグローバル定義のリストに含まれています。 コンパイルオプション プロジェクト設定の。 演算子は条件として指定されます。 IF ステートメントで使用でき、ST POU およびライブラリの実装部分と宣言部分の両方で使用できます。これらは、次の方法で他の定義と組み合わせることができます。 AND そして OR 演算子がそれぞれの位置で許可されている場合。 POU の宣言部分では、 IF 演算子を使用したステートメント pro...", 
"body" : "このオペレータは以下から使用できます CODESYS V3.5 SP20 演算子により、式は値を受け取ります。 TRUE グローバル定義の場合 <global define> のグローバル定義のリストに含まれています。 コンパイルオプション プロジェクト設定の。 演算子は条件として指定されます。 IF ステートメントで使用でき、ST POU およびライブラリの実装部分と宣言部分の両方で使用できます。これらは、次の方法で他の定義と組み合わせることができます。 AND そして OR 演算子がそれぞれの位置で許可されている場合。 POU の宣言部分では、 IF 演算子を使用したステートメント project_defined (<global define> ) には次の構造を含めることができます。 変数の宣言 例： {If project_defined(define1)}\n x : DINT;\n{END_IF} コメント 属性の宣言 プラグマステートメント 次の構造は次のとおりです。 ない 可能： 完全な変数宣言 例 {If project_defined(define1)}\nVAR\n x : DINT;\nEND_VAR\n{END_IF} POU からの完全な申告 例： {If project_defined(define1)}\nFUNCTION POU : BOOL\nVAR_INPUT\n x : INT;\nEND_VAR\n{END_IF} 範囲: VAR_INPUT 、 VAR_OUTPUT 、 VAR_IN_OUT " }, 
{ "title" : "NOT <operator> ", 
"url" : "_cds_pragma_conditional.html#UUID-01ae3a3c-e82a-ffd9-c21a-b7e1c89fd024", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ NOT <operator> ", 
"snippet" : "式には値が与えられます TRUE の逆の値が <operator> 値を返します TRUE 。 <operator> この章で説明する演算子の1つにすることができます。 例 要件：2つのアプリケーション App1 と App2 存在。 PLC_PRG1 に存在します App1 と App2 、およびPOU CheckBounds にのみ存在します App1 。 {IF defined (pou: PLC_PRG1) AND NOT (defined (pou: CheckBounds))} (* the following code is only processed in App2 *) b...", 
"body" : "式には値が与えられます TRUE の逆の値が <operator> 値を返します TRUE 。 <operator> この章で説明する演算子の1つにすることができます。 例 要件：2つのアプリケーション App1 と App2 存在。 PLC_PRG1 に存在します App1 と App2 、およびPOU CheckBounds にのみ存在します App1 。 {IF defined (pou: PLC_PRG1) AND NOT (defined (pou: CheckBounds))}\n (* the following code is only processed in App2 *)\n bANDNotTest := TRUE;\n{END_IF} " }, 
{ "title" : " <operator> AND <operator> ", 
"url" : "_cds_pragma_conditional.html#UUID-2570e549-f9f1-cc69-c881-0a2ce3064cef", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ <operator> AND <operator> ", 
"snippet" : "式には値が与えられます TRUE 指定された2つの演算子が戻るとき TRUE 。 <operator> この章で説明する演算子の1つにすることができます。 例 要件：アプリケーション App1 と App2 存在。 PLC_PRG1 に存在します App1 と App2 、およびPOU CheckBounds にのみ存在します App1 。 {IF defined (pou: PLC_PRG1) AND (defined (pou: CheckBounds))} (* the following code is only processed in App1 *) bANDTest := TRU...", 
"body" : "式には値が与えられます TRUE 指定された2つの演算子が戻るとき TRUE 。 <operator> この章で説明する演算子の1つにすることができます。 例 要件：アプリケーション App1 と App2 存在。 PLC_PRG1 に存在します App1 と App2 、およびPOU CheckBounds にのみ存在します App1 。 {IF defined (pou: PLC_PRG1) AND (defined (pou: CheckBounds))}\n (* the following code is only processed in App1 *)\n bANDTest := TRUE;\n{END_IF} " }, 
{ "title" : "<operator> OR <operator> ", 
"url" : "_cds_pragma_conditional.html#UUID-f4b44590-7911-5a28-1770-b7fdd2a04b3a", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ <operator> OR <operator> ", 
"snippet" : "式は TRUE 指定された2つの演算子のいずれかが TRUE 。 <operator> ここで説明する演算子の1つにすることができます。 例 要件：2つのアプリケーション App1 と App2 存在。 POU PLC_PRG1 に存在します App1 と App2 、およびPOU CheckBounds にのみ存在します App1 。 {IF defined (pou: PLC_PRG1) OR (defined (pou: CheckBounds))} (* the following code is only processed in App1 and in App2 *) bORTes...", 
"body" : "式は TRUE 指定された2つの演算子のいずれかが TRUE 。 <operator> ここで説明する演算子の1つにすることができます。 例 要件：2つのアプリケーション App1 と App2 存在。 POU PLC_PRG1 に存在します App1 と App2 、およびPOU CheckBounds にのみ存在します App1 。 {IF defined (pou: PLC_PRG1) OR (defined (pou: CheckBounds))}\n (* the following code is only processed in App1 and in App2 *)\n bORTest := TRUE;\n{END_IF} " }, 
{ "title" : "(<operator>) ", 
"url" : "_cds_pragma_conditional.html#UUID-59abef5c-3fde-2f82-9803-78934d89e364", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ 条件付きプラグマ \/ オペレーター \/ (<operator>) ", 
"snippet" : "() 演算子を角かっこで囲みます。...", 
"body" : "() 演算子を角かっこで囲みます。 " }, 
{ "title" : "リージョンプラグマ ", 
"url" : "_cds_pragma_region.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ プラグマ \/ リージョンプラグマ ", 
"snippet" : "プラグマは、テキストエディタの複数の行を1つのブロックに結合するために使用されます。ブロックに名前を付けることができます。リージョンプラグマもネストできます。 リージョンプラグマを使用したコード：展開されたビューと折りたたまれたビュー プラグマは、STエディターおよびすべての宣言エディターで使用できます。構文の強調表示は、オプションでカスタマイズできます。...", 
"body" : "プラグマは、テキストエディタの複数の行を1つのブロックに結合するために使用されます。ブロックに名前を付けることができます。リージョンプラグマもネストできます。 リージョンプラグマを使用したコード：展開されたビューと折りたたまれたビュー プラグマは、STエディターおよびすべての宣言エディターで使用できます。構文の強調表示は、オプションでカスタマイズできます。 " }, 
{ "title" : "識別子の指定 ", 
"url" : "_cds_identifiers.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 識別子の指定 ", 
"snippet" : "変数、定数、関数、関数ブロック、メソッド、およびその他のオブジェクトの識別子指定に関する規則と推奨事項...", 
"body" : "変数、定数、関数、関数ブロック、メソッド、およびその他のオブジェクトの識別子指定に関する規則と推奨事項 " }, 
{ "title" : "ルール ", 
"url" : "_cds_rules.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 識別子の指定 \/ ルール ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "変数の規則 ", 
"url" : "_cds_rules.html#UUID-dad2255f-3304-d0ef-3f4d-daaa6c691390_section-idm4594042020419234099402926422", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 識別子の指定 \/ ルール \/ 変数の規則 ", 
"snippet" : "識別子にスペースや特殊文字を含めることはできません。 アンダースコアが認識されます。 例えば、 A_BCD と AB_CD 2つの異なる識別子として扱われます。 複数の連続したアンダースコアは許可されていません。 大文字と小文字の区別はありません。 例えば、 VAR1 と var1 同じ変数を参照してください。 識別子の長さには制限がありません。 を適用することをお勧めします。 推奨事項 変数宣言に関して特に考慮する必要がある項目に加えて。こうすることで、名前を割り当てるときに可能な限り最高の調和が得られます。...", 
"body" : "識別子にスペースや特殊文字を含めることはできません。 アンダースコアが認識されます。 例えば、 A_BCD と AB_CD 2つの異なる識別子として扱われます。 複数の連続したアンダースコアは許可されていません。 大文字と小文字の区別はありません。 例えば、 VAR1 と var1 同じ変数を参照してください。 識別子の長さには制限がありません。 を適用することをお勧めします。 推奨事項 変数宣言に関して特に考慮する必要がある項目に加えて。こうすることで、名前を割り当てるときに可能な限り最高の調和が得られます。 " }, 
{ "title" : "複数使用のルール (名前空間) ", 
"url" : "_cds_rules.html#UUID-dad2255f-3304-d0ef-3f4d-daaa6c691390_section-idm4594041991880034099404518269", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 識別子の指定 \/ ルール \/ 複数使用のルール (名前空間) ", 
"snippet" : "識別子はローカルで2回宣言してはなりません。 識別子は、グローバルに複数回使用できます。 ローカル変数がグローバル変数と同じ名前である場合、ローカル変数はPOU内で優先されます。 識別子をキーワードと同一にすることはできません。 例：スコープ VAR_Global グローバル変数リストで宣言された変数は、別のGVLで定義された変数と同じ名前を持つことができます。 CODESYS 変数の名前空間またはスコープの標準を拡張する機能を提供します。 グローバル名前空間演算子 ドットで始まるインスタンスパスは、常にグローバル名前空間を開きます。ローカル変数がある場合（たとえば、 ivar ）グローバル変...", 
"body" : "識別子はローカルで2回宣言してはなりません。 識別子は、グローバルに複数回使用できます。 ローカル変数がグローバル変数と同じ名前である場合、ローカル変数はPOU内で優先されます。 識別子をキーワードと同一にすることはできません。 例：スコープ VAR_Global グローバル変数リストで宣言された変数は、別のGVLで定義された変数と同じ名前を持つことができます。 CODESYS 変数の名前空間またはスコープの標準を拡張する機能を提供します。 グローバル名前空間演算子 ドットで始まるインスタンスパスは、常にグローバル名前空間を開きます。ローカル変数がある場合（たとえば、 ivar ）グローバル変数と同じ名前の場合、グローバル変数を次のように参照します。 .ivar 。 グローバル変数リストの名前は、インクルード変数の名前空間を一意に定義できます。したがって、異なるグローバル変数リストで同じ名前の変数を宣言し、リスト名を前に付けることで一意に参照できます。 例： globlist1.ivar := globlist2.ivar; (* ivar from GVL globlist2 is copied to ivar in GVL globlist1 *) プロジェクトに含まれるライブラリのグローバル変数リストで定義されている変数は、次の構文に従って一意にアドレス指定できます。 <name scope library>.< GVL name>.<variable name> 例： globlist1.ivar := lib1.globlist1.ivar (* ivar from GVL globlist1 in library lib1 is copied to ivar in GVL globlist1 *) ライブラリを挿入するときは、ライブラリマネージャを使用して名前空間も定義します。このようにして、ライブラリPOUまたはライブラリ変数への一意の参照を作成できます。 <namespace library >.<POU name\\|variable name> 。ライブラリがネストされている場合は、連続しているすべてのライブラリの名前空間を参照する必要があることに注意してください。 例： Lib1 によって参照されます Lib0 、次にPOU func の Lib1 によって対処されます Lib0.Lib1.fun ： ivar := Lib0.Lib1.fun(4, 5); (* return value from func is copied to variable ivar in the project *) " }, 
{ "title" : "バックティック識別子 ", 
"url" : "_cds_rules.html#UUID-dad2255f-3304-d0ef-3f4d-daaa6c691390_section-idm4594041889873634099410376242", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 識別子の指定 \/ ルール \/ バックティック識別子 ", 
"snippet" : "バッククォートを使用すると、特殊文字など、通常は識別子で許可されない文字を識別子で使用することもできます。アキュートアクセント文字はバッククォートに使用されます。 ´ (ユニコード:U+02CA) 同じ識別子を使用できるようにするために、バッククォートの使用をお勧めします。 CODESYS 他のプログラミング言語や回路図などのドキュメントと同様です。 2 つのバッククォートの間には、改行やその他のバッククォートを除く任意の文字を使用できます。キーワードは、バッククォート間の識別子としても使用できます。 例: ´Variable+9´ ´INT´ バッククォートは各識別子の一部であるため、 va...", 
"body" : "バッククォートを使用すると、特殊文字など、通常は識別子で許可されない文字を識別子で使用することもできます。アキュートアクセント文字はバッククォートに使用されます。 ´ (ユニコード:U+02CA) 同じ識別子を使用できるようにするために、バッククォートの使用をお勧めします。 CODESYS 他のプログラミング言語や回路図などのドキュメントと同様です。 2 つのバッククォートの間には、改行やその他のバッククォートを除く任意の文字を使用できます。キーワードは、バッククォート間の識別子としても使用できます。 例: ´Variable+9´ ´INT´ バッククォートは各識別子の一部であるため、 var1 そして ´var1´ は 2 つの異なる識別子です。 例 PROGRAM PLC_PRG\nVAR\n var1 : INT;\n ´var1´: INT;\nEND_VAR\n\nvar1 := var1 + 1;\n´var1´ := 12;\n " }, 
{ "title" : "推奨事項 ", 
"url" : "_cds_recommendation.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 識別子の指定 \/ 推奨事項 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "変数の場合 ", 
"url" : "_cds_identifiers_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 識別子の指定 \/ 推奨事項 \/ 変数の場合 ", 
"snippet" : "可能な限り、アプリケーションとライブラリのハンガリアン記法で変数に名前を付ける必要があります。各変数の意味のある短い英語名をベース名として見つけます。これは複数の単語で構成できます。各単語の最初の文字を大文字で、残りの文字を小文字で書いてください。ベース名の前に、変数のデータ型を示す接頭辞を小文字で追加します。 例： iFileSize : INT; 識別子指定の推奨事項 データ・タイプ プレフィックス 説明 BOOL x 強くお勧めします x ブール変数をデータ型の識別子と区別するための接頭辞として BYTE 。接頭辞は、IECプログラマーの見解を示します。 b 予約済み BYTE by ビ...", 
"body" : "可能な限り、アプリケーションとライブラリのハンガリアン記法で変数に名前を付ける必要があります。各変数の意味のある短い英語名をベース名として見つけます。これは複数の単語で構成できます。各単語の最初の文字を大文字で、残りの文字を小文字で書いてください。ベース名の前に、変数のデータ型を示す接頭辞を小文字で追加します。 例： iFileSize : INT; 識別子指定の推奨事項 データ・タイプ プレフィックス 説明 BOOL x 強くお勧めします x ブール変数をデータ型の識別子と区別するための接頭辞として BYTE 。接頭辞は、IECプログラマーの見解を示します。 b 予約済み BYTE by ビット文字列;算術演算用ではありません WORD w ビット文字列;算術演算用ではありません DWORD dw ビット文字列;算術演算用ではありません LWORD lw ビット文字列;算術演算用ではありません SINT si 算術整数データ型、8ビット USINT usi 算術整数データ型、8ビット INT i 算術整数データ型、16ビット UINT ui 算術整数データ型、16ビット DINT di 算術整数データ型、32ビット UDINT udi 算術整数データ型、32ビット LINT li 算術整数データ型、64ビット ULINT uli 算術整数データ型、64ビット REAL r 算術浮動小数点データ型、32ビット LREAL lr 算術浮動小数点データ型、64ビット STRING s 可変長のシングルバイト文字列（デフォルト設定：80文字） WSTRING ws 可変長の2バイト文字列（デフォルト設定：80文字） TIME tim 期間、32ビット LTIME ltim 期間、64ビット TIME_OF_DAY TOD tod 時刻、32ビット LTIME_OF_DAY LTOD ltod 時刻、64ビット DATE_AND_TIME DT dt 日時 LDATE_AND_TIME LDT ldt DATE dat d カレンダーの日付 LDATE ldat ld カレンダーの日付 POINTER p ARRAY a 列挙 e 例 VAR\n bySubIndix: BYTE;\n xFlag: BOOL;\n udiCounter: UDINT;\nEND_VAR 識別子指定の推奨事項 説明 例 ネストされた宣言 プレフィックスは、宣言の順序で連続して付加されます。 pabyTelegramData: POINTER TO ARRAY [0..7] OF BYTE; 機能ブロックインスタンス ユーザー定義のデータ型の変数 プレフィックス：機能ブロックまたはデータ型の名前の略語 cansdoReceivedTelegram: CAN_SDOTelegram;\n\nTYPE CAN_SDOTelegram : (* prefix: sdo *)\nSTRUCT\n wIndex: WORD;\n bySubIndex:BYTE;\n byLen:BYTE;\n aby: ARRAY [0..3] OF BYTE;\nEND_STRUCT\nEND_TYPE ローカル定数 ローカル定数変数 プレフィックス： c_ 、その後にタイププレフィックスと変数名が続きます VAR CONSTANT\n c_uiSyncID: UINT := 16#80;\nEND_VAR\n グローバル変数 追加のプレフィックスがライブラリプレフィックスに追加されます。 g_ VAR_GLOBAL\n CAN_g_iText: INT;\nEND_VAR\n グローバル定数 グローバル定数変数 追加のプレフィックスがライブラリプレフィックスに追加されます。 gc_ VAR_GLOBAL CONSTANT\n CAN_gc_dwExample: DWORD;\nEND_VAR\n " }, 
{ "title" : "の変数の場合 CODESYS V3ライブラリ ", 
"url" : "_cds_identifiers_var_v3_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 識別子の指定 \/ 推奨事項 \/ の変数の場合 CODESYS V3ライブラリ ", 
"snippet" : "ライブラリ内の変数の場合 識別子指定の推奨事項 説明 例 変数 名前空間が関数を置き換えるため、グローバル変数と定数がライブラリプレフィックスを必要としないことを除いて、変数名の説明に対応します。 g_iTest: INT; \/\/ Declaration CAN.g_iTest; \/\/ Implementation; call in the program...", 
"body" : "ライブラリ内の変数の場合 識別子指定の推奨事項 説明 例 変数 名前空間が関数を置き換えるため、グローバル変数と定数がライブラリプレフィックスを必要としないことを除いて、変数名の説明に対応します。 g_iTest: INT; \/\/ Declaration CAN.g_iTest; \/\/ Implementation; call in the program " }, 
{ "title" : "カスタムデータ型の場合 ", 
"url" : "_cds_identifiers_dut.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 識別子の指定 \/ 推奨事項 \/ カスタムデータ型の場合 ", 
"snippet" : "DUTの場合 識別子指定の推奨事項 説明 例 構造 ライブラリプレフィックスの後にアンダースコアと構造の短い有益な説明が続く この構造の作成された変数に関連付けられたプレフィックスは、コメントとしてコロンの後に続く必要があります。 TYPE CAN_SDOTelegram : (* prefix: sdo *) STRUCT wIndex : WORD; bySubIndex : BYTE; byLen : BYTE; abyData: ARRAY [0..3] OF BYTE; END_STRUCT END_TYPE 列挙型 ライブラリプレフィックスの後にアンダースコアと大文字の識別子が続く...", 
"body" : "DUTの場合 識別子指定の推奨事項 説明 例 構造 ライブラリプレフィックスの後にアンダースコアと構造の短い有益な説明が続く この構造の作成された変数に関連付けられたプレフィックスは、コメントとしてコロンの後に続く必要があります。 TYPE CAN_SDOTelegram : (* prefix: sdo *)\n STRUCT\n wIndex : WORD;\n bySubIndex : BYTE;\n byLen : BYTE;\n abyData: ARRAY [0..3] OF BYTE;\n END_STRUCT\nEND_TYPE\n 列挙型 ライブラリプレフィックスの後にアンダースコアと大文字の識別子が続く 注：過去 CODESYS バージョン、列挙値> 16＃7FFFは、自動的に変換されなかったため、エラーが発生しました INT 。このため、常に正しい列挙型を宣言してください INT 値。 TYPE CAL_Day :\n(\nCAL_MONDAY,\nCAL_TUESDAY, \nCAL_WEDNESDAY,\nCAL_THURSDAY,\nCAL_SUNDAY\n);\n 宣言： eToday: CAL_DAY; " }, 
{ "title" : "のカスタムデータ型の場合 CODESYS V3ライブラリ ", 
"url" : "_cds_identifiers_dut_v3_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 識別子の指定 \/ 推奨事項 \/ のカスタムデータ型の場合 CODESYS V3ライブラリ ", 
"snippet" : "V3ライブラリのDUTの場合 識別子指定の推奨事項 説明 例 のDUT CODESYS V3 ライブラリ 名前空間は、ライブラリプレフィックスの必要性を置き換えます。したがって、省略します。列挙値もライブラリプレフィックスなしで定義されます。 とライブラリ CAL 名前空間： TYPE DAY : ( MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY ); 宣言： eToday: CAL.Day; アプリケーションでの使用法 IF eToday = CAL.Day.MONDAY THEN...", 
"body" : "V3ライブラリのDUTの場合 識別子指定の推奨事項 説明 例 のDUT CODESYS V3 ライブラリ 名前空間は、ライブラリプレフィックスの必要性を置き換えます。したがって、省略します。列挙値もライブラリプレフィックスなしで定義されます。 とライブラリ CAL 名前空間： TYPE DAY : \n(\nMONDAY,\nTUESDAY,\nWEDNESDAY,\nTHURSDAY,\nFRIDAY,\nSATURDAY,\nSUNDAY\n); 宣言： eToday: CAL.Day; アプリケーションでの使用法 IF eToday = CAL.Day.MONDAY THEN " }, 
{ "title" : "POUの場合 ", 
"url" : "_cds_identifiers_pous.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 識別子の指定 \/ 推奨事項 \/ POUの場合 ", 
"snippet" : "識別子指定の推奨事項 説明 例 機能、機能ブロック、プログラム ライブラリプレフィックスの後にアンダースコアと短い有益なPOU名が続く 変数の場合と同様に、各単語の最初の文字は大文字で、他のすべての文字は小文字です。動詞と名詞からPOU名を作成することをお勧めします。 関数ブロックの場合、作成されたインスタンスに関連付けられたプレフィックスは、コメントとして名前の後に続く必要があります。 FUNCTION_BLOCK CAN_SendTelegram (* prefix: canst *) 行動 ブロック自体が呼び出すアクションのみ prv_ 。それ以外の場合、アクションにはプレフィックスがあ...", 
"body" : "識別子指定の推奨事項 説明 例 機能、機能ブロック、プログラム ライブラリプレフィックスの後にアンダースコアと短い有益なPOU名が続く 変数の場合と同様に、各単語の最初の文字は大文字で、他のすべての文字は小文字です。動詞と名詞からPOU名を作成することをお勧めします。 関数ブロックの場合、作成されたインスタンスに関連付けられたプレフィックスは、コメントとして名前の後に続く必要があります。 FUNCTION_BLOCK CAN_SendTelegram (* prefix: canst *) 行動 ブロック自体が呼び出すアクションのみ prv_ 。それ以外の場合、アクションにはプレフィックスがありません。 " }, 
{ "title" : "のPOUの場合 CODESYS V3ライブラリ ", 
"url" : "_cds_identifiers_pou_v3_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 識別子の指定 \/ 推奨事項 \/ のPOUの場合 CODESYS V3ライブラリ ", 
"snippet" : "V3ライブラリブロックの場合 識別子指定の推奨事項 説明 例 POU 名前空間がライブラリプレフィックスの機能を置き換えるため、ライブラリプレフィックスは省略されます。 FUNCTION_BLOCK SendTelegram (* prefix: canst *) 方法 ブロック自体が呼び出すメソッドのみ prv_ 。 それ以外の場合、メソッドにはプレフィックスがありません。 インターフェース インターフェース I ICANDevice...", 
"body" : "V3ライブラリブロックの場合 識別子指定の推奨事項 説明 例 POU 名前空間がライブラリプレフィックスの機能を置き換えるため、ライブラリプレフィックスは省略されます。 FUNCTION_BLOCK SendTelegram (* prefix: canst *) 方法 ブロック自体が呼び出すメソッドのみ prv_ 。 それ以外の場合、メソッドにはプレフィックスがありません。 インターフェース インターフェース I ICANDevice " }, 
{ "title" : "視覚化のため ", 
"url" : "_cds_identifiers_visu.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ 識別子の指定 \/ 推奨事項 \/ 視覚化のため ", 
"snippet" : "視覚化オブジェクトの推奨事項に名前を付ける ビジュアライゼーションを変更するときに問題が発生する可能性があるため、ビジュアライゼーションはプロジェクト内の別のブロックと同じ名前ではないことに注意してください。...", 
"body" : "視覚化オブジェクトの推奨事項に名前を付ける ビジュアライゼーションを変更するときに問題が発生する可能性があるため、ビジュアライゼーションはプロジェクト内の別のブロックと同じ名前ではないことに注意してください。 " }, 
{ "title" : "シャドウイングルール ", 
"url" : "_cds_shadowing_rules.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ シャドウイングルール ", 
"snippet" : "の CODESYS 、通常、異なる要素に同じ識別子を使用できます。たとえば、POUと変数に同じ名前を付けることができます。ただし、混乱を防ぐために、この方法は避けてください。 例 否定的な例：次のコードスニペットでは、ローカル関数ブロックインスタンスの名前は関数と同じです。 このような場合、インスタンスまたは関数がプログラムで呼び出されるかどうかは不明です。 FUNCTION YYY : INT ; END_FUNCTION FUNCTION_BLOCK XXX ; END_FUNCTION_BLOCK PROGRAM PLC_PRG VAR YYY : XXX; END_VAR YYY();...", 
"body" : "の CODESYS 、通常、異なる要素に同じ識別子を使用できます。たとえば、POUと変数に同じ名前を付けることができます。ただし、混乱を防ぐために、この方法は避けてください。 例 否定的な例：次のコードスニペットでは、ローカル関数ブロックインスタンスの名前は関数と同じです。 このような場合、インスタンスまたは関数がプログラムで呼び出されるかどうかは不明です。 FUNCTION YYY : INT\n;\nEND_FUNCTION\n\nFUNCTION_BLOCK XXX\n;\nEND_FUNCTION_BLOCK\n\nPROGRAM PLC_PRG\nVAR\n YYY : XXX;\nEND_VAR\nYYY();\nEND_PROGRAM " }, 
{ "title" : "シャドウイング時のコンパイラの動作 ", 
"url" : "_cds_shadowing_rules.html#UUID-86e09bbc-278d-7399-b9c2-0648c7961f10_section-idm462806727981763350320566511", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ シャドウイングルール \/ シャドウイング時のコンパイラの動作 ", 
"snippet" : "異なる要素に同じ識別子が使用されている場合、コンパイラはエラーや警告を報告しません。代わりに、コンパイラは特定の順序でコードを検索して、識別子の宣言を探します。宣言が見つかった場合、コンパイラは他の場所で他の宣言を検索しません。他の宣言が存在する場合、それらはコンパイラに対して「シャドウ」されます。次のセクションでは、シャドウ規則 (つまり、識別子の宣言を検索するときにコンパイラが使用する検索順序) について説明します。 「あいまいなアクセスと修飾されたアクセス」セクションでは、あいまいなアクセスを防止し、シャドーイング ルールをバイパスする方法について説明します。...", 
"body" : "異なる要素に同じ識別子が使用されている場合、コンパイラはエラーや警告を報告しません。代わりに、コンパイラは特定の順序でコードを検索して、識別子の宣言を探します。宣言が見つかった場合、コンパイラは他の場所で他の宣言を検索しません。他の宣言が存在する場合、それらはコンパイラに対して「シャドウ」されます。次のセクションでは、シャドウ規則 (つまり、識別子の宣言を検索するときにコンパイラが使用する検索順序) について説明します。 「あいまいなアクセスと修飾されたアクセス」セクションでは、あいまいなアクセスを防止し、シャドーイング ルールをバイパスする方法について説明します。 " }, 
{ "title" : "シャドーイングを防ぐ方法 ", 
"url" : "_cds_shadowing_rules.html#UUID-86e09bbc-278d-7399-b9c2-0648c7961f10_section-idm4593930303395233503201805458", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ シャドウイングルール \/ シャドーイングを防ぐ方法 ", 
"snippet" : "名前が常に一意であることを確認するには、変数の特定のプレフィックスなどの命名規則に従う必要があります。 詳細については、以下を参照してください。 識別子の指定命名規則は、の静的コード分析を使用して自動的にチェックできます。 CODESYS 。静的コード分析では、名前の重複使用も検出できます YYY エラーとして報告します。 また、属性の一貫した使用を通じて qualified_only 列挙型とグローバル変数リストの場合、および修飾されたライブラリを使用することで、一意でない状況を回避できます。 同じ名前のPOUが デバイス ビューのPOUが呼び出されない場合 POU ビューが呼び出され、演算...", 
"body" : "名前が常に一意であることを確認するには、変数の特定のプレフィックスなどの命名規則に従う必要があります。 詳細については、以下を参照してください。 識別子の指定命名規則は、の静的コード分析を使用して自動的にチェックできます。 CODESYS 。静的コード分析では、名前の重複使用も検出できます YYY エラーとして報告します。 また、属性の一貫した使用を通じて qualified_only 列挙型とグローバル変数リストの場合、および修飾されたライブラリを使用することで、一意でない状況を回避できます。 同じ名前のPOUが デバイス ビューのPOUが呼び出されない場合 POU ビューが呼び出され、演算子 __POOL POUの名前が呼び出されるときに先頭に追加する必要があります。 例： svar_pou := __POOL.POU(); " }, 
{ "title" : "アプリケーションでの検索順序 ", 
"url" : "_cds_shadowing_rules.html#UUID-86e09bbc-278d-7399-b9c2-0648c7961f10_id_eb9f3a6f8dc5c0a864633ab16f46_id_ac2947743b785338c0a864635c9601cf", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ シャドウイングルール \/ アプリケーションでの検索順序 ", 
"snippet" : "コンパイラは、アプリケーションのコードで単一の識別子を検出すると、対応する宣言を次の順序で検索します。 ローカル変数 メソッドのローカル変数 関数ブロック、プログラム、関数、および任意の基本関数ブロックのローカル変数 POUのローカルメソッド アプリケーションのグローバル変数（ qualified_only グローバル変数が宣言されている変数リストに属性が設定されていません アプリケーションのグローバル変数 qualified_only グローバル変数が宣言されている変数リストに属性が設定されていません 親アプリケーションのグローバル変数 qualified_only グローバル変数が宣言され...", 
"body" : "コンパイラは、アプリケーションのコードで単一の識別子を検出すると、対応する宣言を次の順序で検索します。 ローカル変数 メソッドのローカル変数 関数ブロック、プログラム、関数、および任意の基本関数ブロックのローカル変数 POUのローカルメソッド アプリケーションのグローバル変数（ qualified_only グローバル変数が宣言されている変数リストに属性が設定されていません アプリケーションのグローバル変数 qualified_only グローバル変数が宣言されている変数リストに属性が設定されていません 親アプリケーションのグローバル変数 qualified_only グローバル変数が宣言されている変数リストに属性が設定されていません ライブラリも変数リストも修飾されたアクセスを必要としない場合の参照ライブラリのグローバル変数 POU またはタイプ名 アプリケーションからのPOUまたはタイプ名（つまり、グローバル変数リスト、関数ブロックなどの名前） 親アプリケーションからのPOUまたはタイプ名 ライブラリからのPOUまたはタイプ名 ライブラリ ローカルで参照されるライブラリの名前空間と、ライブラリによって公開されているライブラリ POU 意見 のグローバル変数 POU ビュー、 qualified_only 属性は、それらが宣言されている変数リストに設定されます POUまたはタイプ名 POU ビュー（つまり、グローバル変数リスト、関数ブロックなどの名前） からのライブラリ POU のライブラリマネージャに挿入されているライブラリ POU ビューは、プロジェクト内のすべてのアプリケーションのライブラリマネージャーで、適切なプレースホルダー解像度でミラーリングされます。これらのライブラリは、アプリケーション内のライブラリと共通の名前空間を形成します。したがって、アプリケーション内のライブラリによるプール内のライブラリのシャドウイングはありません。 " }, 
{ "title" : "ライブラリ内の検索順序 ", 
"url" : "_cds_shadowing_rules.html#UUID-86e09bbc-278d-7399-b9c2-0648c7961f10_id_eb9f3a6f8dc5c0a864633ab16f46_id_6e5cf3e23b785338c0a864631e655a41", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ シャドウイングルール \/ ライブラリ内の検索順序 ", 
"snippet" : "コンパイラーは、ライブラリーのコードで単一のIDを検出すると、対応する宣言を次の順序で検索します。 ローカル変数 メソッドのローカル変数 関数ブロック、プログラム、関数、および任意の基本関数ブロックのローカル変数 POUのローカルメソッド グローバル変数 ローカル ライブラリのグローバル変数。 qualified_only グローバル変数が宣言されている変数リストに属性が設定されていません ライブラリも変数リストも修飾されたアクセスを必要としない場合の参照ライブラリのグローバル変数 ローカルライブラリのPOUまたはタイプ名（つまり、グローバル変数リスト、関数ブロックなどの名前） ローカルライブ...", 
"body" : "コンパイラーは、ライブラリーのコードで単一のIDを検出すると、対応する宣言を次の順序で検索します。 ローカル変数 メソッドのローカル変数 関数ブロック、プログラム、関数、および任意の基本関数ブロックのローカル変数 POUのローカルメソッド グローバル変数 ローカル ライブラリのグローバル変数。 qualified_only グローバル変数が宣言されている変数リストに属性が設定されていません ライブラリも変数リストも修飾されたアクセスを必要としない場合の参照ライブラリのグローバル変数 ローカルライブラリのPOUまたはタイプ名（つまり、グローバル変数リスト、関数ブロックなどの名前） ローカルライブラリのPOUまたはタイプ名（つまり、グローバル変数リスト、関数ブロックなどの名前） 参照されたライブラリからのPOUまたはタイプ名 ローカルで参照されているライブラリの名前空間と、ローカルで参照されているライブラリによって公開されているライブラリ " }, 
{ "title" : "あいまいなアクセスと修飾されたアクセス ", 
"url" : "_cds_shadowing_rules.html#UUID-86e09bbc-278d-7399-b9c2-0648c7961f10_id_eb9f3a6f8dc5c0a864633ab16f46_id_d382bb6d3b785338c0a86463219183c4", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ シャドウイングルール \/ あいまいなアクセスと修飾されたアクセス ", 
"snippet" : "これらの検索順序にもかかわらず、あいまいなアクセスが発生する可能性があります。たとえば、修飾アクセスを必要としない 2 つのグローバル変数リストに同じ名前の変数が存在する場合がこれに該当します。このような場合は、コンパイラによってエラーとして報告されます (例: XXXの名称の曖昧な使用 ）。 この種のあいまいな使用法は、たとえばグローバル変数リストの名前を介してアクセスすることにより、修飾されたアクセスによって一意にすることができます（例： GVL.XXX ）。 シャドウイングルールを回避するために、資格のあるアクセスを常に使用することもできます。 グローバル変数リストの名前を使用して、リス...", 
"body" : "これらの検索順序にもかかわらず、あいまいなアクセスが発生する可能性があります。たとえば、修飾アクセスを必要としない 2 つのグローバル変数リストに同じ名前の変数が存在する場合がこれに該当します。このような場合は、コンパイラによってエラーとして報告されます (例: XXXの名称の曖昧な使用 ）。 この種のあいまいな使用法は、たとえばグローバル変数リストの名前を介してアクセスすることにより、修飾されたアクセスによって一意にすることができます（例： GVL.XXX ）。 シャドウイングルールを回避するために、資格のあるアクセスを常に使用することもできます。 グローバル変数リストの名前を使用して、リスト内の変数に一意にアクセスできます。 ライブラリの名前は、ライブラリ内の要素に一意にアクセスするために使用できます。 The THIS 関数ブロックのメソッドに同じ名前のローカル変数が存在する場合でも、ポインターを使用して関数ブロック内の変数に一意にアクセスします。 識別子の宣言場所をいつでも見つけるには、 編集→参照→定義に移動 指図。これは、コンパイラが明らかにあいまいなエラーメッセージを生成する場合に特に役立ちます。 " }, 
{ "title" : "インスタンスパスでの検索 ", 
"url" : "_cds_shadowing_rules.html#UUID-86e09bbc-278d-7399-b9c2-0648c7961f10_id_eb9f3a6f8dc5c0a864633ab16f46_id_4094da363b785338c0a864632107d534", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ シャドウイングルール \/ インスタンスパスでの検索 ", 
"snippet" : "上記の検索順序は、インスタンスパスのコンポーネントとして存在する識別子、または呼び出しの入力として使用される識別子には適用されません。 次のタイプのアクセス用 yy.component 、それはによって記述されたエンティティに依存します yy ここでの宣言 component が検索されます。 もしも yy 構造化データ型（つまり、型）を持つ変数を示します STRUCT また UNION ）、 それから component 次の順序で検索されます。 機能ブロックのローカル変数 基本機能ブロックのローカル変数 機能ブロックのメソッド 基本機能ブロックのメソッド もしも yy グローバル変数リスト...", 
"body" : "上記の検索順序は、インスタンスパスのコンポーネントとして存在する識別子、または呼び出しの入力として使用される識別子には適用されません。 次のタイプのアクセス用 yy.component 、それはによって記述されたエンティティに依存します yy ここでの宣言 component が検索されます。 もしも yy 構造化データ型（つまり、型）を持つ変数を示します STRUCT また UNION ）、 それから component 次の順序で検索されます。 機能ブロックのローカル変数 基本機能ブロックのローカル変数 機能ブロックのメソッド 基本機能ブロックのメソッド もしも yy グローバル変数リストまたはプログラムを示し、 component このリストでのみ検索されます。 もしも yy ライブラリの名前空間を示し、 component 上記の「ライブラリでの検索順序」のセクションで説明されているとおりに、このライブラリで検索されます。 2番目のインスタンスでのみ、コンパイラは、見つかった要素へのアクセスを許可するかどうか（つまり、変数がローカルでのみアクセス可能かどうか、またはメソッドがプライベートかどうか）を決定します。アクセスが許可されていない場合、エラーが発行されます。 " }, 
{ "title" : "キーワード ", 
"url" : "_cds_keywords.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ キーワード ", 
"snippet" : "すべてのエディターで、スコープ、データ型、演算子などを示すキーワードを大文字にする必要があります。キーワードを変数名として使用することはできません。 例 VAR END_VAR BOOL_TO_INT IF THEN ELSE LTIME MUL XOR PERSISTENT PROGRAM CODESYS キーワードの正しい使用法を自動的にチェックし、入力中のエラーを波状の下線ですぐに強調表示します。 いつ CODESYS 暗黙のコードを作成します。変数と関数には通常、2つのアンダースコア「__」が前に付いた名前が付けられます。実装コードでの二重アンダースコアの使用は自動的に防止されます。こ...", 
"body" : "すべてのエディターで、スコープ、データ型、演算子などを示すキーワードを大文字にする必要があります。キーワードを変数名として使用することはできません。 例 VAR\nEND_VAR\nBOOL_TO_INT\nIF\nTHEN\nELSE\nLTIME\nMUL\nXOR\nPERSISTENT\nPROGRAM CODESYS キーワードの正しい使用法を自動的にチェックし、入力中のエラーを波状の下線ですぐに強調表示します。 いつ CODESYS 暗黙のコードを作成します。変数と関数には通常、2つのアンダースコア「__」が前に付いた名前が付けられます。実装コードでの二重アンダースコアの使用は自動的に防止されます。これにより、内部システムIDとプログラマーによって割り当てられたIDの間の競合が排除されます。 次のキーワードは、 CODESYS エクスポート形式。したがって、それらを識別子として使用することはできません。 ACTION END_ACTION END_FUNCTION END_FUNCTION_BLOCK END_PROGRAM その他の有効なキーワード： VAR_ACCESS READ_ONLY READ_WRITE PARAMS " }, 
{ "title" : "メソッド : FB_Init 、 FB_Reinit 、 FB_Exit ", 
"url" : "_cds_method_fb_init_fb_reinit.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ メソッド : FB_Init 、 FB_Reinit 、 FB_Exit ", 
"snippet" : "関数ブロック変数の初期化、および関数ブロックを終了するときの動作に影響を与えるために、メソッドを明示的に宣言できます。 暗黙的なメソッドの戻り値のタイプは次のとおりです。 BOOL 。値はシステムによって評価されませんが、タイプは変更しないでください。 FB_Init 常に暗黙的に使用可能であり、主に初期化に使用されます。特定の影響については、メソッドを明示的に宣言し、標準の初期化コードとともに追加のコードを提供することもできます。 FB_Reinit 明示的に実装する必要があります。このメソッドが存在する場合は、影響を受ける関数ブロックのインスタンスが次のようになった後に呼び出されます。 コ...", 
"body" : "関数ブロック変数の初期化、および関数ブロックを終了するときの動作に影響を与えるために、メソッドを明示的に宣言できます。 暗黙的なメソッドの戻り値のタイプは次のとおりです。 BOOL 。値はシステムによって評価されませんが、タイプは変更しないでください。 FB_Init 常に暗黙的に使用可能であり、主に初期化に使用されます。特定の影響については、メソッドを明示的に宣言し、標準の初期化コードとともに追加のコードを提供することもできます。 FB_Reinit 明示的に実装する必要があります。このメソッドが存在する場合は、影響を受ける関数ブロックのインスタンスが次のようになった後に呼び出されます。 コピー 。これは、新しいインスタンスモジュールを再初期化するために、機能ブロック宣言を変更した後のオンライン変更（署名の変更）中に発生します。機能ブロックの基本的な実装を再初期化するには、を呼び出す必要があります FB_Reinit 明示的に。 FB_Exit 明示的に実装する必要があります。実装がある場合は、コントローラーが関数ブロックインスタンスのコードを削除する前にメソッドが呼び出されます（暗黙的な呼び出し）。 以下に、さまざまな動作条件でのこれらの方法のいくつかの使用例を示します。 " }, 
{ "title" : "「最初のダウンロード」オペレーティングケース ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_ee2ec072ce4c52dbc0a864631de40b39", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ メソッド : FB_Init 、 FB_Reinit 、 FB_Exit \/ 「最初のダウンロード」オペレーティングケース ", 
"snippet" : "工場出荷時の設定でアプリケーションをPLCにダウンロードする場合、すべての変数のメモリを必要な初期状態にオフセットする必要があります。このようにして、汎用ブロックインスタンスのデータ領域に必要な値が割り当てられます。の明示的な実装によって FB_Init 機能ブロックの場合、アプリケーションコードでこの状況に具体的に対応できます。メソッドパラメータを評価する bInCopyCode （（ FALSE ） と bInitRetains （（ TRUE ）、この動作状態を明確に検出できます。...", 
"body" : "工場出荷時の設定でアプリケーションをPLCにダウンロードする場合、すべての変数のメモリを必要な初期状態にオフセットする必要があります。このようにして、汎用ブロックインスタンスのデータ領域に必要な値が割り当てられます。の明示的な実装によって FB_Init 機能ブロックの場合、アプリケーションコードでこの状況に具体的に対応できます。メソッドパラメータを評価する bInCopyCode （（ FALSE ） と bInitRetains （（ TRUE ）、この動作状態を明確に検出できます。 " }, 
{ "title" : "「オンライン変更」オペレーティングケース ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_11211aface4c52dbc0a864635676a307", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ メソッド : FB_Init 、 FB_Reinit 、 FB_Exit \/ 「オンライン変更」オペレーティングケース ", 
"snippet" : "オンライン変更の範囲内で、メソッドを使用して汎用ブロックインスタンスの初期化に影響を与えることができます。 FB_Exit 、 FB_Init 、 と FB_Reinit 。オンライン変更中に、オフラインモードで行われたアプリケーションへの変更は、実行中のPLCに適用されます。したがって、「古い」機能ブロックインスタンスは、問題なく可能な限り「新しい兄弟」に置き換えられます。ログイン前にアプリケーションの機能ブロックの宣言部分に変更が加えられていない場合、実装のみで、データ領域は置き換えられません。コードブロックのみが置き換えられます。次に、メソッド FB_Exit 、 FB_Init 、 と...", 
"body" : "オンライン変更の範囲内で、メソッドを使用して汎用ブロックインスタンスの初期化に影響を与えることができます。 FB_Exit 、 FB_Init 、 と FB_Reinit 。オンライン変更中に、オフラインモードで行われたアプリケーションへの変更は、実行中のPLCに適用されます。したがって、「古い」機能ブロックインスタンスは、問題なく可能な限り「新しい兄弟」に置き換えられます。ログイン前にアプリケーションの機能ブロックの宣言部分に変更が加えられていない場合、実装のみで、データ領域は置き換えられません。コードブロックのみが置き換えられます。次に、メソッド FB_Exit 、 FB_Init 、 と FB_Reinit 呼び出されません。 上記のコピー操作につながる機能ブロックの宣言に変更を加えた場合、オンライン変更中に「意図しない影響の可能性」に関するメッセージが表示されます。の中に 詳細 メッセージビューの中に、コピーされるすべてのインスタンスのリストが表示されます。 のコードで FB_Init メソッド、パラメータ bInCopyCode （（ TRUE ）を評価して、オンライン変更が実行されているかどうかを検出できます。 オンライン変更中に、次の呼び出しが連続して発生します。 FB_Exit old_inst.FB_Exit(bInCopyCode := TRUE); あなたは呼び出すことができます FB_Exit 特定のクリーンアップタスクをトリガーするために「古い」インスタンスを終了するとき コピー操作前 。このようにして、次のコピー操作のためにデータを準備し、新しいインスタンスの状態に影響を与えることができます。メモリ内の場所の保留中の変更について、アプリケーションの他の部分に通知できます。タイプの変数に特に注意してください POINTER と REFERENCE 。これらは、オンライン変更後に必要なメモリ位置を参照しなくなる可能性があります。インターフェイス変数（ INTERFACE ）はコンパイラによって個別に処理され、オンライン変更中にそれに応じて調整されます。ソケット、ファイル、その他のハンドルなどの外部リソースは、新しいインスタンスによって適用できますが、場合によっては変更されません。多くの場合、オンライン変更中に特別に扱う必要はありません。 （「「再ダウンロード」操作ケース」を参照） FB_Init new_inst.FB_Init(bInitRetains := FALSE, bInCopyCode := TRUE); FB_Init コピー操作の前に呼び出され、オンライン変更の特定の操作を実行するために使用できます。たとえば、メモリ内の「新しい」場所でそれに応じて変数を初期化したり、メモリ内の特定の変数の新しい場所についてアプリケーションの他の部分に通知したりできます。 コピー操作： copy copy(&old_inst, &new_inst); 既存の値は変更されません。この目的のために、それらは古いインスタンスから新しいインスタンスにコピーされます。 FB_Reinit new_inst.FB_Reinit(); このメソッドはコピー操作の後に呼び出され、インスタンスの変数に定義された値を設定する必要があります。たとえば、メモリ内の「新しい」場所でそれに応じて変数を初期化したり、メモリ内の特定の変数の新しい場所についてアプリケーションの他の部分に通知したりできます。オンライン変更とは独立した実装を設計します。このメソッドは、関数ブロックインスタンスを元の状態にリセットするために、いつでもアプリケーションから呼び出すことができます。 とともに {attribute 'no_copy'} 属性を使用すると、機能ブロックの単一変数のオンライン変更中にこれがコピーされるのを防ぐことができます。常に初期値を保持します。 詳細については、以下を参照してください。 オンライン変更のためのメモリリザーブの設定" }, 
{ "title" : "「新規ダウンロード」オペレーティングケース ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_18382d25ce4c52dbc0a86463733d1d36", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ メソッド : FB_Init 、 FB_Reinit 、 FB_Exit \/ 「新規ダウンロード」オペレーティングケース ", 
"snippet" : "アプリケーションをダウンロードすると、PLC上の既存のアプリケーションが置き換えられる場合があります。したがって、現在の機能ブロックへのメモリの提供を調整する必要があります。あなたは使用することができます FB_Exit これに必要な手順を実装するための方法。たとえば、定義された状態で外部リソース（ソケットおよびファイルハンドルを使用）をオフセットできます。 この動作状態は、パラメータの有無で検出できます。 bInCopyCode = FALSE のために FB_Exit 方法。...", 
"body" : "アプリケーションをダウンロードすると、PLC上の既存のアプリケーションが置き換えられる場合があります。したがって、現在の機能ブロックへのメモリの提供を調整する必要があります。あなたは使用することができます FB_Exit これに必要な手順を実装するための方法。たとえば、定義された状態で外部リソース（ソケットおよびファイルハンドルを使用）をオフセットできます。 この動作状態は、パラメータの有無で検出できます。 bInCopyCode = FALSE のために FB_Exit 方法。 " }, 
{ "title" : "「アプリケーションの開始」オペレーティングケース ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_a4a0f73c27f211e6b1abd7715e61fd27", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ メソッド : FB_Init 、 FB_Reinit 、 FB_Exit \/ 「アプリケーションの開始」オペレーティングケース ", 
"snippet" : "最初の割り当ては、アプリケーションタスクの最初のサイクルの前に処理されます。 例 T1 : TON := (PT:=t#500ms); これらの種類の割り当ては、呼び出し後にのみ実行されます FB_Init 。これらの割り当ての効果を制御するために、機能ブロックまたは機能ブロックのメソッドを提供することができます。 {attribute ‘call_after_init‘} 属性。関数ブロック本体の宣言部分の上、および対応するメソッドの宣言部分の上に属性を追加する必要があります。を使用する別のPOUを拡張するPOU {attribute 'call_after_init'} 属性にも属性が必要...", 
"body" : "最初の割り当ては、アプリケーションタスクの最初のサイクルの前に処理されます。 例 T1 : TON := (PT:=t#500ms); これらの種類の割り当ては、呼び出し後にのみ実行されます FB_Init 。これらの割り当ての効果を制御するために、機能ブロックまたは機能ブロックのメソッドを提供することができます。 {attribute ‘call_after_init‘} 属性。関数ブロック本体の宣言部分の上、および対応するメソッドの宣言部分の上に属性を追加する必要があります。を使用する別のPOUを拡張するPOU {attribute 'call_after_init'} 属性にも属性が必要です。わかりやすくするために、対応するメソッドを同じ名前、同じ署名、同じ属性で上書きすることをお勧めします。これには電話が必要です SUPER^.MyInit 。メソッドの名前は制限なく選択できます。 （例外： FB_Init 、 FB_Reinit 、 と FB_Exit ）。このメソッドは、最初の割り当てを処理した後、アプリケーションタスクを開始する前に呼び出されます。したがって、メソッドはユーザー入力に反応できます。 使用する場合 FB_Init また {attribute 'call_after_init'} 、でエラーを検出することを忘れないでください FB_Init メソッドまたはで装飾されたメソッドで {attribute 'call_after_init'} ブレークポイントの設定が期待される効果をもたらさない可能性があるため、属性は面倒です。 実行中に明示的に定義された初期化コードに到達した場合、機能ブロックインスタンスは暗黙的な初期化コードを介してすでに完全に初期化されています。したがって、 SUPER^.FB_Init 電話。 FB_Init を置き換えます INI で使用される演算子 CoDeSys V2.3 。メソッドは、C＃、C ++、Javaなどのコンストラクターの設計と比較することはできません。これは、他の機能ブロックを拡張する機能ブロックに影響を及ぼします。 （以下を参照：「派生機能ブロック」） " }, 
{ "title" : "メソッドのインターフェース FB_Init ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_484f4ece66da11e7bb4fee5053811542", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ メソッド : FB_Init 、 FB_Reinit 、 FB_Exit \/ メソッドのインターフェース FB_Init ", 
"snippet" : "METHOD FB_Init : BOOL VAR_INPUT bInitRetains : BOOL; \/\/ TRUE: the retain variables are initialized (reset warm \/ reset cold) bInCopyCode : BOOL; \/\/ TRUE: the instance will be copied to the copy code afterward (online change) END_VAR 追加の機能ブロック入力をで宣言することができます FB_init 方法。次に、これらの入力を汎用ブロックインスタンスの宣言で設定する必...", 
"body" : "METHOD FB_Init : BOOL\nVAR_INPUT\n bInitRetains : BOOL; \/\/ TRUE: the retain variables are initialized (reset warm \/ reset cold)\n bInCopyCode : BOOL; \/\/ TRUE: the instance will be copied to the copy code afterward (online change)\nEND_VAR 追加の機能ブロック入力をで宣言することができます FB_init 方法。次に、これらの入力を汎用ブロックインスタンスの宣言で設定する必要があります。 例 方法 FB_Init のために serialdevice ファンクションブロック METHOD PUBLIC FB_Init : BOOL\nVAR_INPUT\n nbInitRetains : BOOL; \/\/ initializing of retain variable\n bInCopyCode : BOOL; \/\/ instance is copied to copy code\n iCOMnum : INT; \/\/ additional input: number of the COM interface, that is to be observed\nEND_VAR のインスタンス化 serialdevice ファンクションブロック： com1: serialdevice(iCOMnum:=1);\ncom0: serialdevice(iCOMnum:=0); " }, 
{ "title" : "メソッドのインターフェース FB_Reinit ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_32c7a9d6655911e799f4cbb808a4a9d0", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ メソッド : FB_Init 、 FB_Reinit 、 FB_Exit \/ メソッドのインターフェース FB_Reinit ", 
"snippet" : "METHOD FB_Reinit : BOOL...", 
"body" : "METHOD FB_Reinit : BOOL " }, 
{ "title" : "メソッドのインターフェース FB_Exit ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_12190eb0ce4c52dbc0a864635e0a9fea", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ メソッド : FB_Init 、 FB_Reinit 、 FB_Exit \/ メソッドのインターフェース FB_Exit ", 
"snippet" : "必須パラメータがあります bInCopyCode 。 METHOD FB_Exit : BOOL VAR_INPUT bInCopyCode : BOOL; \/\/ TRUE: the exit method is called in order to leave the instance which will be copied afterwards (online change). END_VAR...", 
"body" : "必須パラメータがあります bInCopyCode 。 METHOD FB_Exit : BOOL\nVAR_INPUT\n bInCopyCode : BOOL; \/\/ TRUE: the exit method is called in order to leave the instance which will be copied afterwards (online change).\nEND_VAR " }, 
{ "title" : "派生関数ブロックの動作 ", 
"url" : "_cds_method_fb_init_fb_reinit.html#UUID-bf5b9afd-371d-66e0-c2f8-fb3c8314c918_id_ffba5841cd035584c0a8640e002e57ab_id_b9d7fa100be0aaf3c0a864636c5fb2da", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ メソッド : FB_Init 、 FB_Reinit 、 FB_Exit \/ 派生関数ブロックの動作 ", 
"snippet" : "機能ブロックが別の機能ブロックから派生している場合、 FB_Init 派生関数ブロックのメソッドは、と同じパラメータを定義する必要があります FB_Init 基本機能ブロックのメソッド。ただし、インスタンスの特別な初期化を設定するために、さらにパラメーターを追加できます。 例 機能ブロック MainFB 、 SubFB 、 と SubSubFB 互いに派生しています。したがって、 SubFB EXTENDS MainFB と SubSubFB EXTENDS SubFB 申し込み。 メソッドの呼び出し順序 FB_Exit と FB_Init ： fbSubSubFb.FB_Exit(...);...", 
"body" : "機能ブロックが別の機能ブロックから派生している場合、 FB_Init 派生関数ブロックのメソッドは、と同じパラメータを定義する必要があります FB_Init 基本機能ブロックのメソッド。ただし、インスタンスの特別な初期化を設定するために、さらにパラメーターを追加できます。 例 機能ブロック MainFB 、 SubFB 、 と SubSubFB 互いに派生しています。したがって、 SubFB EXTENDS MainFB と SubSubFB EXTENDS SubFB 申し込み。 メソッドの呼び出し順序 FB_Exit と FB_Init ： fbSubSubFb.FB_Exit(...); fbSubFb.FB_Exit(...); fbMainFb.FB_Exit(...); fbMainFb.FB_Init(...); fbSubFb.FB_Init(...); fbSubSubFb.FB_Init(...); " }, 
{ "title" : "Global Init Slots ", 
"url" : "_cds_global_init_slots.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ Global Init Slots ", 
"snippet" : "スロット プラグイン\/ライブラリ POU 説明 123 GVLObject __var_persistent_write 永続リストからマップされたインスタンス パスへの永続変数のコピー 199 Compiler __var__retain__read__ リテイン領域からインスタンスパスへリテイン変数をコピー（ターゲット設定のみ） retain-in-cycle-code ) 200 LanguageModelManager __ValidateLicenseMetrics の送信 AppBasedLicenseMetrics デバイスのランタイム システムへ 500 VisualObjec...", 
"body" : "スロット プラグイン\/ライブラリ POU 説明 123 GVLObject __var_persistent_write 永続リストからマップされたインスタンス パスへの永続変数のコピー 199 Compiler __var__retain__read__ リテイン領域からインスタンスパスへリテイン変数をコピー（ターゲット設定のみ） retain-in-cycle-code ) 200 LanguageModelManager __ValidateLicenseMetrics の送信 AppBasedLicenseMetrics デバイスのランタイム システムへ 500 VisualObject Visu__VisualManager__AfterInitProgram ビジュアライゼーションの初期化 ( でマークされたすべての初期化を呼び出します) Called within Visu-Initialization ) 500 VisualObject __datasourcesFrameVisualCallTree ビジュアライゼーションとデータソースの相互作用 600 DataSourcesObject __datasourcesUpdateByDefaultCall データソースの初期化 600 DataSourcesObject __datasourcesUpdateByDefaultGVL データソースの初期化 1000 DeviceObject IoGlobalInit__Pou デバイスオブジェクトインスタンスの初期化 1000 図書館： Datasource ApplicationV3 Access Logger このライブラリのログ記録の初期化 1000 図書館： Datasource Symbolic Access Logger このライブラリのログ記録の初期化 1000 図書館： Datasources Logger このライブラリのログ記録の初期化 1234 ApplicationComposer AC_Init 生成されたPOUの初期化 1234 ApplicationComposer AC_OnlineChange Application Composer によって作成された構造体\/FB の再初期化 10000 図書館： Datasource Symbolic Access GVL_EarlyInit シンボリックデータソースの初期化 20000 図書館： Alarm Manager AlarmConstants アラーム処理の初期化 24000 図書館： VisuElemBase Private_Visu_Globals ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu 24000 図書館： VisuElemBase GVL_NativeElement ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu 24000 図書館： VisuElemBase GVL_TypeInformation ビジュアライゼーションの初期化 24000 図書館： Visu Interfaces GVL ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu 25000 図書館： VisuElemBase GVL_CommandManager ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu 25000 図書館： VisuElemBase Visu_Globals ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu 25000 図書館： VisuCommandInterface GVL ビジュアライゼーションの初期化 25000 図書館： RecipeManagement GVL_RecipeManagement_Temp ビジュアライゼーションの初期化 25990 図書館： VisuElemBase VisuFctDatasourcesResourceEntryAllocatorGet_MBM ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu 25990 図書館： VisuElemBase VisuFctDatasourcesResourceEntryAllocatorGet_SysMem ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu 26000 図書館： VisuElemBase Visu_Resources ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu 30000 図書館： Alarm Manager AlarmGlobals アラーム処理の初期化 30000 図書館： Alarm Manager GloballyForAlarmStorage アラーム処理の初期化（終了後に初期化が必要な部分） _3SStorage ) 30000 図書館： VisuFPlot GlobalInstances ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu 30000 図書館： VisuTrendStorageAccess GlobalInstances ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu 39900 DeviceObject IoConfig_Globals_ModuleList すべてのデバイス (フィールドバス スレーブ、SoftMotion 軸など) のすべてのコネクタのモジュール リスト 40000 DeviceObject IoConfig_Globals_Mapping すべてのデバイス (フィールドバス スレーブ、SoftMotion 軸など) からマップされた新しい変数 40000 TrendRecordingObject __GVL__TrendRecordingManager トレンド記録の初期化 40100 DeviceObject IoConfig_Forces_Reset マッピングの強制変数。 I\/Oマッピング用の強制変数を生成する オプションが設定されています 49980 Compiler 全て VAR_STAT で宣言されたすべての変数を初期化します。 VAR_STAT 49985 Compiler __MemManDefinition 「通常の」 GVL がすでに初期化されている動的メモリ管理に依存できるようにするには、動的メモリ管理の GVL を「通常の」 GVL よりも前に初期化する必要があります。 49990 Compiler すべての GVL すべての GVL (グローバル変数リスト) のデフォルト値 50000 Compiler デフォルトのスロット すべての POU (プログラム、ファンクション ブロック) 用の標準スロット 50000 VisualObject Visu__VisualManager__GVL__0 ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu_generated 50500 VisualObject __VisuInitInstantiation_GVL ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu_generated 51000 VisualObject Visu__VisualManager__CommonGVL ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu_generated 55000 VisualObject Visu__VisualManager__GVL__2 ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu_generated 56000 VisualObject __NativeElementUserDefTypesCall ビジュアライゼーションの初期化 (HTML5 コントロールの型情報) 56000 VisualObject __NativeElementUserDefTypesGVL ビジュアライゼーションの初期化 (HTML5 コントロールの型情報) 56000 DataSourcesObject __providerSymbolsCall データソースの初期化 56000 DataSourcesObject __providerSymbolsGVL データソースの初期化 56000 DataSourcesObject __datasourcesSymbolsCall データソースの初期化 56000 DataSourcesObject __datasourcesSymbolsGVL データソースの初期化 56500 DataSourcesObject __GVL_Datasources_Constants データソースの初期化 57000 DataSourcesObject __datasourcesInstancesCall データソースの初期化 57000 DataSourcesObject __datasourcesInstancesGVL データソースの初期化 58000 DataSourcesObject __GVL_Datasources データソースの初期化 60000 DeviceObject IoConfig_Globals すべてのデバイス (フィールドバス スレーブ、SoftMotion 軸など) の機能ブロック インスタンス 60000 TrendRecordingObject __GVL__TrendRecording__ + _metaObject.Name トレンド記録の初期化 60100 DeviceObject IoConfigRemote_Globals 安全性 SIL3 コンテキスト用にマップされた変数 70000 図書館： VisuElemBase Private_Visu_Globals_LateInit ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu_late 70000 図書館： Visu Utils PublicVariables ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu_late 70000 図書館： Visu Utils 変数 ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu_late 123456 UnitConversionObject \"__\" + _metaObject.Name + \"_InitPrg データソースとの対話 150000 図書館： VisuDialogs Dialog_Variables ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu 150000 図書館： VisuDialogs Dialog_Variables_Exp ビジュアライゼーションの初期化 vis の初期化内で呼び出されます visu 150000 RecipeManObject GVL_RecipeManagement_3300 レシピの初期化 150000 RecipeManObject GVL_RecipeManagement レシピの初期化 151000 RecipeManObject RecipeManagementInitAfterGlobalInit レシピの初期化 call_after_online_change_concurrent_slot 1000 200000 図書館： VisuElemBase GVL_ShutdownCheck ビジュアライゼーションの初期化\/非アクティブ化 vis の初期化内で呼び出されます visu " }, 
{ "title" : "エラーメッセージと警告 ", 
"url" : "_cds_struct_reference_errors.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コンパイラエラーC0001 ", 
"url" : "_cds_error_c0001.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0001 ", 
"snippet" : "C0001 メッセージ ：定数 '<定数値>'タイプ '<データ型>'には大きすぎます 考えられるエラーの原因 ：型付き定数が特定のデータ型に対して大きすぎるか、定数が可能なデータ型ごとに大きすぎます。 エラー訂正 ：型付き定数には、より小さい定数または適切なデータ型を使用してください。 エラーの例： PROGRAM PLC_PRG VAR test1: INT; test2: INT; test3: LREAL; END_VAR test1 := 12345678912345566991923939292939911; test2 := INT#123456; test3 := 10E500...", 
"body" : "C0001 メッセージ ：定数 '<定数値>'タイプ '<データ型>'には大きすぎます 考えられるエラーの原因 ：型付き定数が特定のデータ型に対して大きすぎるか、定数が可能なデータ型ごとに大きすぎます。 エラー訂正 ：型付き定数には、より小さい定数または適切なデータ型を使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n test1: INT;\n test2: INT;\n test3: LREAL;\nEND_VAR\n\ntest1 := 12345678912345566991923939292939911;\ntest2 := INT#123456;\ntest3 := 10E500;\n メッセージ： C0001：定数「12345678912345566991923939292939911」がタイプ「ANY_INT」に対して大きすぎます C0001：定数 'INT＃123456'がタイプ 'INT'には大きすぎます C0001：定数「10E500」がタイプ「ANY_REAL」に対して大きすぎます " }, 
{ "title" : "コンパイラエラーC0002 ", 
"url" : "_cds_error_c0002.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0002 ", 
"snippet" : "C0002 メッセージ ： '<タグ>'の代わりに '<演算子1>'または '<演算子2>'が必要です 考えられるエラーの原因 ： 構文エラー エラー訂正 ：正しい構文を使用してください。 エラーの例： PROGRAM PLC_PRG Fun(1; メッセージ： C0002： ';'の代わりに '、'または '）'が必要です...", 
"body" : "C0002 メッセージ ： '<タグ>'の代わりに '<演算子1>'または '<演算子2>'が必要です 考えられるエラーの原因 ： 構文エラー エラー訂正 ：正しい構文を使用してください。 エラーの例： PROGRAM PLC_PRG\nFun(1;\n メッセージ： C0002： ';'の代わりに '、'または '）'が必要です " }, 
{ "title" : "コンパイラエラーC0003 ", 
"url" : "_cds_error_c0003.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0003 ", 
"snippet" : "C0003 メッセージ ： '<value>'は '<variable>'の有効なビット番号ではありません 考えられるエラーの原因 ：データ型の範囲外のビットへのアクセスを試みました。 エラー訂正 ：変数のデータ型のビット数よりも小さいビットアクセスのビット値を使用してください。 エラーの例： PROGRAM PLC_PRG VAR test1: WORD; test2: BOOL; END_VAR test1 := test2.17; メッセージ： C0003：「17」は「w」の有効なビット番号ではありません...", 
"body" : "C0003 メッセージ ： '<value>'は '<variable>'の有効なビット番号ではありません 考えられるエラーの原因 ：データ型の範囲外のビットへのアクセスを試みました。 エラー訂正 ：変数のデータ型のビット数よりも小さいビットアクセスのビット値を使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n test1: WORD;\n test2: BOOL;\nEND_VAR\n\ntest1 := test2.17;\n メッセージ： C0003：「17」は「w」の有効なビット番号ではありません " }, 
{ "title" : "コンパイラエラーC0004 ", 
"url" : "_cds_error_c0004.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0004 ", 
"snippet" : "C0004 メッセージ ： '<変数>'は '<構造>'のコンポーネントではありません 考えられるエラーの原因 ：「。」を使用したコンポーネントアクセス構造化された値ではないか、構造のコンポーネントとして存在しない変数に。 エラー訂正 ：定義されたコンポーネントにアクセスするか、データ型のコンポーネントの定義を変更します。入力支援「コンポーネントの一覧表示」は、このポジションへのすべての有効なアクセスを提供します。 エラーの例： TYPE DUT: STRUCT x, y : INT; END_STRUCT END_TYPE PROGRAM PLC_PRG VAR test1 : DUT; t...", 
"body" : "C0004 メッセージ ： '<変数>'は '<構造>'のコンポーネントではありません 考えられるエラーの原因 ：「。」を使用したコンポーネントアクセス構造化された値ではないか、構造のコンポーネントとして存在しない変数に。 エラー訂正 ：定義されたコンポーネントにアクセスするか、データ型のコンポーネントの定義を変更します。入力支援「コンポーネントの一覧表示」は、このポジションへのすべての有効なアクセスを提供します。 エラーの例： TYPE DUT:\nSTRUCT\n x, y : INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n test1 : DUT;\n test2 : INT;\nEND_VAR\n\ntest2 := test1.z;\n メッセージ： C0032：タイプ '不明なタイプ：' test1.z 'はタイプ' INT 'に変換できません C0032：タイプ '不明なタイプ：' test1.z 'はタイプ' INT 'に変換できません " }, 
{ "title" : "コンパイラエラーC0005 ", 
"url" : "_cds_error_c0005.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0005 ", 
"snippet" : "C0005 メッセージ ：アドレス '<アドレス>'の定数オーバーフロー 考えられるエラーの原因 ：アドレスの少なくとも1つのコンポーネントが32ビット整数値に適合しません。 エラー訂正 ：有効なアドレス式を使用してください。 エラーの例： PROGRAM PLC_PRG VAR X: BYTE; END_VAR X := %QB5555555555; メッセージ： C0005：アドレス '％??'の定数オーバーフロー...", 
"body" : "C0005 メッセージ ：アドレス '<アドレス>'の定数オーバーフロー 考えられるエラーの原因 ：アドレスの少なくとも1つのコンポーネントが32ビット整数値に適合しません。 エラー訂正 ：有効なアドレス式を使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n X: BYTE;\nEND_VAR\n\nX := %QB5555555555;\n メッセージ： C0005：アドレス '％??'の定数オーバーフロー " }, 
{ "title" : "コンパイラエラーC0006 ", 
"url" : "_cds_error_c0006.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0006 ", 
"snippet" : "C0006 メッセージ ： '<token>'の代わりに '<operator>'が必要です 考えられるエラーの原因 ： 構文エラー エラー訂正 ：正しい構文を使用してください。 エラーの例： PROGRAM PLC_PRG VAR x: INT; bTest : BOOL; END_VAR IF bTest x := 9; END_IF メッセージ： C0006：「x」の代わりに「THEN」が必要...", 
"body" : "C0006 メッセージ ： '<token>'の代わりに '<operator>'が必要です 考えられるエラーの原因 ： 構文エラー エラー訂正 ：正しい構文を使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n x: INT;\n bTest : BOOL;\nEND_VAR\n\nIF bTest\n x := 9;\nEND_IF\n メッセージ： C0006：「x」の代わりに「THEN」が必要 " }, 
{ "title" : "コンパイラエラーC0007 ", 
"url" : "_cds_error_c0007.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0007 ", 
"snippet" : "C0007 Meldung ： '<token>'の代わりに式が必要です 考えられるエラーの原因 ： 構文エラー エラー訂正 ：正しい構文を使用してください。 エラーの例： PROGRAM PLC_PRG VAR x: INT; bTest : BOOL; END_VAR IF THEN x := 9; END_IF メッセージ： C0007：「THEN」の代わりに式が必要です...", 
"body" : "C0007 Meldung ： '<token>'の代わりに式が必要です 考えられるエラーの原因 ： 構文エラー エラー訂正 ：正しい構文を使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n x: INT;\n bTest : BOOL;\nEND_VAR\n\nIF THEN\n x := 9;\nEND_IF\n メッセージ： C0007：「THEN」の代わりに式が必要です " }, 
{ "title" : "コンパイラエラーC0008 ", 
"url" : "_cds_error_c0008.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0008 ", 
"snippet" : "C0008 メッセージ ：予期しないファイルの終わりが見つかりました： '<operator>'、 '<operator>'、または '<operator>'が必要です 考えられるエラーの原因 ： 構文エラー エラー訂正 ：正しい構文を使用してください。 エラーの例： PROGRAM PLC_PRG VAR x: INT; bTest : BOOL; END_VAR IF bTest THEN x := 9; メッセージ： C0008：予期しないファイルの終わりが見つかりました：「ELSIF」、「ELSE」、または「END_IF」が予期されています...", 
"body" : "C0008 メッセージ ：予期しないファイルの終わりが見つかりました： '<operator>'、 '<operator>'、または '<operator>'が必要です 考えられるエラーの原因 ： 構文エラー エラー訂正 ：正しい構文を使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n x: INT;\n bTest : BOOL;\nEND_VAR\n\nIF bTest THEN\n x := 9;\n メッセージ： C0008：予期しないファイルの終わりが見つかりました：「ELSIF」、「ELSE」、または「END_IF」が予期されています " }, 
{ "title" : "コンパイラエラーC0009 ", 
"url" : "_cds_error_c0009.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0009 ", 
"snippet" : "C0009 メッセージ ：予期しないトークン '<トークン>'が見つかりました 考えられるエラーの原因 ： 構文エラー エラー訂正 ：正しい構文を使用してください。 エラーの例： PROGRAM PLC_PRG VAR END_VAR END_FOR; メッセージ： C0009：予期しないトークン 'END_FOR'が見つかりました...", 
"body" : "C0009 メッセージ ：予期しないトークン '<トークン>'が見つかりました 考えられるエラーの原因 ： 構文エラー エラー訂正 ：正しい構文を使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nEND_FOR;\n メッセージ： C0009：予期しないトークン 'END_FOR'が見つかりました " }, 
{ "title" : "コンパイラエラーC0010 ", 
"url" : "_cds_error_c0010.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0010 ", 
"snippet" : "C0010 メッセージ ：予期しないファイルの終わりが見つかりました： '<token>'が必要です 考えられるエラーの原因 ： 構文エラー エラー訂正 ：正しい構文を使用してください。 エラーの例： PROGRAM PLC_PRG VAR i: INT; END_VAR FOR i := 0 TO 2 DO ; メッセージ： C0010：予期しないファイルの終わりが見つかりました： 'END_FOR'が予期されています...", 
"body" : "C0010 メッセージ ：予期しないファイルの終わりが見つかりました： '<token>'が必要です 考えられるエラーの原因 ： 構文エラー エラー訂正 ：正しい構文を使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n i: INT;\nEND_VAR\n\nFOR i := 0 TO 2 DO\n;\n メッセージ： C0010：予期しないファイルの終わりが見つかりました： 'END_FOR'が予期されています " }, 
{ "title" : "コンパイラエラーC0011 ", 
"url" : "_cds_error_c0011.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0011 ", 
"snippet" : "C0011 メッセージ ：「CASE」ラベルが見つかりません 考えられるエラーの原因 ：CASEステートメントの構文エラー。 CASEステートメントのステートメントはCASEラベルに割り当てられていません。 エラー訂正 ：CASEラベルを追加します。 エラーの例： PROGRAM PLC_PRG VAR i: INT; x: INT; END_VAR CASE i OF x := 9; END_CASE メッセージ： C0011：「CASE」ラベルが見つかりません エラー訂正： CASE i OF 0: x := 9; END_CASE...", 
"body" : "C0011 メッセージ ：「CASE」ラベルが見つかりません 考えられるエラーの原因 ：CASEステートメントの構文エラー。 CASEステートメントのステートメントはCASEラベルに割り当てられていません。 エラー訂正 ：CASEラベルを追加します。 エラーの例： PROGRAM PLC_PRG\nVAR\n i: INT;\n x: INT;\nEND_VAR\n\nCASE i OF\n x := 9;\nEND_CASE\n メッセージ： C0011：「CASE」ラベルが見つかりません エラー訂正： CASE i OF\n0:\n x := 9;\nEND_CASE " }, 
{ "title" : "コンパイラエラーC0013 ", 
"url" : "_cds_error_c0013.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0013 ", 
"snippet" : "C0013 メッセージ ：少なくとも1つのステートメントが必要です。 考えられるエラーの原因 ：コード内のいくつかの位置に少なくとも1つのステートメントが必要です。たとえば、IFステートメントのTHENおよびELSE部分、またはFORループの本体。 エラー訂正 ：選択した位置に少なくとも1つのステートメントを追加します。空白のステートメント「;」を書くだけで十分です。 エラーの例： PROGRAM PLC_PRG VAR bTest: BOOL; END_VAR IF bTest THEN END_IF メッセージ： C0013：少なくとも1つのステートメントが必要です。...", 
"body" : "C0013 メッセージ ：少なくとも1つのステートメントが必要です。 考えられるエラーの原因 ：コード内のいくつかの位置に少なくとも1つのステートメントが必要です。たとえば、IFステートメントのTHENおよびELSE部分、またはFORループの本体。 エラー訂正 ：選択した位置に少なくとも1つのステートメントを追加します。空白のステートメント「;」を書くだけで十分です。 エラーの例： PROGRAM PLC_PRG\nVAR\n bTest: BOOL;\nEND_VAR\n\nIF bTest THEN\nEND_IF\n メッセージ： C0013：少なくとも1つのステートメントが必要です。 " }, 
{ "title" : "コンパイラエラーC0015 ", 
"url" : "_cds_error_c0015.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0015 ", 
"snippet" : "C0015 メッセージ ：カウンタの初期化が必要です 考えられるエラーの原因 ：FORループの構文エラー。カウンタ変数が正しく初期化されていません。 エラー訂正 ：FORループの正しい構文に注意してください。 エラーの例： PROGRAM PLC_PRG VAR i: INT; END_VAR FOR i TO 10 DO ; END_FOR --> C0015: Zählvariableninitialisierung erwartet メッセージ： C0015：カウンタの初期化が必要です エラー訂正： FOR i := 0 TO 10 DO ; END_FOR...", 
"body" : "C0015 メッセージ ：カウンタの初期化が必要です 考えられるエラーの原因 ：FORループの構文エラー。カウンタ変数が正しく初期化されていません。 エラー訂正 ：FORループの正しい構文に注意してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n i: INT;\nEND_VAR\n\nFOR i TO 10 DO\n ;\nEND_FOR\n\n--> C0015: Zählvariableninitialisierung erwartet メッセージ： C0015：カウンタの初期化が必要です エラー訂正： FOR i := 0 TO 10 DO\n ;\nEND_FOR " }, 
{ "title" : "コンパイラエラーC0018 ", 
"url" : "_cds_error_c0018.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0018 ", 
"snippet" : "C0018 メッセージ ：<式>は有効な割り当てターゲットではありません 考えられるエラーの原因 ：代入の左側に書き込み権限のない式があります。例：定数。 エラー訂正 ：書き込みアクセス権を持つ変数にのみ割り当てます。 エラーの例： PROGRAM PLC_PRG VAR i: INT; END_VAR VAR CONSTANT j: INT := 0; END_VAR j := i; メッセージ： C0018： 'j'は有効な割り当てターゲットではありません...", 
"body" : "C0018 メッセージ ：<式>は有効な割り当てターゲットではありません 考えられるエラーの原因 ：代入の左側に書き込み権限のない式があります。例：定数。 エラー訂正 ：書き込みアクセス権を持つ変数にのみ割り当てます。 エラーの例： PROGRAM PLC_PRG\nVAR\n i: INT;\nEND_VAR\nVAR CONSTANT\n j: INT := 0;\nEND_VAR\n\nj := i;\n メッセージ： C0018： 'j'は有効な割り当てターゲットではありません " }, 
{ "title" : "コンパイラエラーC0020 ", 
"url" : "_cds_error_c0020.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0020 ", 
"snippet" : "C0020 メッセージ ： '<ステートメント>'は有効なステートメントではありません 考えられるエラーの原因 ：構文エラー（たとえば、文字が少なすぎる、または多すぎる） エラー訂正 ：構文が正しいことを確認してください。 エラーの例： PROGRAM PLC_PRG VAR x : INT; END_VAR x = 2; メッセージ： C0020： '（x = 2）; 'は有効なステートメントではありません エラー訂正： x := 2;...", 
"body" : "C0020 メッセージ ： '<ステートメント>'は有効なステートメントではありません 考えられるエラーの原因 ：構文エラー（たとえば、文字が少なすぎる、または多すぎる） エラー訂正 ：構文が正しいことを確認してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n x : INT;\nEND_VAR\n\nx = 2;\n メッセージ： C0020： '（x = 2）; 'は有効なステートメントではありません エラー訂正： x := 2; " }, 
{ "title" : "コンパイラエラーC0022 ", 
"url" : "_cds_error_c0022.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0022 ", 
"snippet" : "C0022 メッセージ ： '<operator>'は正確に '<オペランドの数>'オペランドが必要です 考えられるエラーの原因 ：演算子に割り当てられているオペランドが多すぎるか少なすぎます。 エラー訂正 ：必要な数のオペランドを演算子に割り当てます。 エラーの例： PROGRAM PLC_PRG VAR i : INT; pt: POINTER TO INT; END_VAR pt := ADR(i,1); メッセージ： C0022：「ADR」には正確に「1」のオペランドが必要です エラー訂正： pt := ADR(i);...", 
"body" : "C0022 メッセージ ： '<operator>'は正確に '<オペランドの数>'オペランドが必要です 考えられるエラーの原因 ：演算子に割り当てられているオペランドが多すぎるか少なすぎます。 エラー訂正 ：必要な数のオペランドを演算子に割り当てます。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\n pt: POINTER TO INT;\nEND_VAR\n\npt := ADR(i,1);\n メッセージ： C0022：「ADR」には正確に「1」のオペランドが必要です エラー訂正： pt := ADR(i); " }, 
{ "title" : "コンパイラエラーC0023 ", 
"url" : "_cds_error_c0023.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0023 ", 
"snippet" : "C0023 メッセージ ： '<operator>'には少なくとも '<オペランドの数>'オペランドが必要です 考えられるエラーの原因 ：演算子に割り当てられているオペランドが少なすぎます。 エラー訂正 ：必要な数のオペランドを演算子に割り当てます。 エラーの例： PROGRAM PLC_PRG VAR i : INT; END_VAR i := MUX(30,40); メッセージ： C0023：「MUX」には少なくとも「3」のオペランドが必要です エラー訂正： i := MUX(30,40,50);...", 
"body" : "C0023 メッセージ ： '<operator>'には少なくとも '<オペランドの数>'オペランドが必要です 考えられるエラーの原因 ：演算子に割り当てられているオペランドが少なすぎます。 エラー訂正 ：必要な数のオペランドを演算子に割り当てます。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\n\ni := MUX(30,40);\n メッセージ： C0023：「MUX」には少なくとも「3」のオペランドが必要です エラー訂正： i := MUX(30,40,50); " }, 
{ "title" : "コンパイラエラーC0026 ", 
"url" : "_cds_error_c0026.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0026 ", 
"snippet" : "C0026 メッセージ ： '<無効な識別子>'の代わりに識別子が必要です 考えられるエラーの原因 ：無効な識別子がメソッドに渡されました。 エラー訂正 ：有効な識別子を使用してください。 エラーの例： METHOD 123 VAR_INPUT END_VAR メッセージ： C0243：署名で使用されている名前がオブジェクト名と同じではありません C0026：「123」の代わりに識別子が必要です エラー訂正： METHOD METH123...", 
"body" : "C0026 メッセージ ： '<無効な識別子>'の代わりに識別子が必要です 考えられるエラーの原因 ：無効な識別子がメソッドに渡されました。 エラー訂正 ：有効な識別子を使用してください。 エラーの例： METHOD 123\nVAR_INPUT\nEND_VAR\n メッセージ： C0243：署名で使用されている名前がオブジェクト名と同じではありません C0026：「123」の代わりに識別子が必要です エラー訂正： METHOD METH123 " }, 
{ "title" : "コンパイラエラーC0027 ", 
"url" : "_cds_error_c0027.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0027 ", 
"snippet" : "C0027 メッセージ ： '（'の後に予想される文字列のサイズ 考えられるエラーの原因 ：文字列の長さが指定されていません。 エラー訂正 ：括弧の間に文字列の長さを指定します。 エラーの例： PROGRAM PLC_PRG VAR str : STRING(); END_VAR メッセージ： C0027： '（'の後に予想される文字列のサイズ C0006： ';' ：=、REF =、（または['の代わりに'が必要です '）' エラー訂正： str : STRING(100);...", 
"body" : "C0027 メッセージ ： '（'の後に予想される文字列のサイズ 考えられるエラーの原因 ：文字列の長さが指定されていません。 エラー訂正 ：括弧の間に文字列の長さを指定します。 エラーの例： PROGRAM PLC_PRG\nVAR\n str : STRING();\nEND_VAR\n メッセージ： C0027： '（'の後に予想される文字列のサイズ C0006： ';' ：=、REF =、（または['の代わりに'が必要です '）' エラー訂正： str : STRING(100); " }, 
{ "title" : "コンパイラエラーC0030 ", 
"url" : "_cds_error_c0030.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0030 ", 
"snippet" : "C0030 メッセージ ：「<識別子>」ではなく「AT」の後に直接アドレスが必要です 考えられるエラーの原因 ：「AT」の後に無効なアドレスが割り当てられているか、アドレスが割り当てられていません。 エラー訂正 ：有効なアドレスを指定してください。 エラーの例： PROGRAM PLC_PRG VAR i AT ABC : INT; END_VAR メッセージ： C0030：「ABC」ではなく「AT」の後に直接アドレスが必要 エラー訂正： i AT %IW0 : INT;...", 
"body" : "C0030 メッセージ ：「<識別子>」ではなく「AT」の後に直接アドレスが必要です 考えられるエラーの原因 ：「AT」の後に無効なアドレスが割り当てられているか、アドレスが割り当てられていません。 エラー訂正 ：有効なアドレスを指定してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n i AT ABC : INT;\nEND_VAR\n メッセージ： C0030：「ABC」ではなく「AT」の後に直接アドレスが必要 エラー訂正： i AT %IW0 : INT; " }, 
{ "title" : "コンパイラエラーC0031 ", 
"url" : "_cds_error_c0031.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0031 ", 
"snippet" : "C0031 メッセージ ： '<データ型なし>'の代わりに型定義が必要です 考えられるエラーの原因 ：識別子に無効な型定義が割り当てられています。 エラー訂正 ：有効な型定義を指定してください。 エラーの例： PROGRAM PLC_PRG VAR i : 0; END_VAR メッセージ： C0031：「0」の代わりにタイプ定義が必要です エラー訂正： i : INT;...", 
"body" : "C0031 メッセージ ： '<データ型なし>'の代わりに型定義が必要です 考えられるエラーの原因 ：識別子に無効な型定義が割り当てられています。 エラー訂正 ：有効な型定義を指定してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : 0;\nEND_VAR\n メッセージ： C0031：「0」の代わりにタイプ定義が必要です エラー訂正： i : INT; " }, 
{ "title" : "コンパイラエラーC0032 ", 
"url" : "_cds_error_c0032.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0032 ", 
"snippet" : "C0032 メッセージ ：タイプ '<タイプ1>'は '<タイプ2>'に変換できません 考えられるエラーの原因 ：互換性のないタイプの別の変数に変数が割り当てられています。 エラー訂正 ：型変換を使用します。 エラーの例： PROGRAM PLC_PRG VAR test1: INT; test2: STRING; END_VAR test1 := test2; メッセージ： C0032：タイプ 'STRING'はタイプ 'INT'に変換できません エラー訂正： test1 := TO_INT(test2);...", 
"body" : "C0032 メッセージ ：タイプ '<タイプ1>'は '<タイプ2>'に変換できません 考えられるエラーの原因 ：互換性のないタイプの別の変数に変数が割り当てられています。 エラー訂正 ：型変換を使用します。 エラーの例： PROGRAM PLC_PRG\nVAR\n test1: INT;\n test2: STRING;\nEND_VAR\n\ntest1 := test2;\n メッセージ： C0032：タイプ 'STRING'はタイプ 'INT'に変換できません エラー訂正： test1 := TO_INT(test2); " }, 
{ "title" : "コンパイラ警告C0033 ", 
"url" : "_cds_error_c0033.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告C0033 ", 
"snippet" : "C0033 メッセージ ：タイプ '<ポインタタイプ>'はタイプ '<データタイプ>'に変換できない可能性があります。 考えられるエラーの原因 ：このエラーは、プールオブジェクトをチェックする場合にのみ発生します。ポインタを整数に変換しようとしました。ライブラリ内のポインタのサイズは不明であるため、ライブラリの使用時にエラーが発生する可能性があります。 エラー訂正 ：タイプを使用 __UXINT また __XWORD ポインタを使用したプラットフォームに依存しない計算用。 エラーの例： PROGRAM PLC_PRG VAR ptr : POINTER TO INT; dw : DWORD; ...", 
"body" : "C0033 メッセージ ：タイプ '<ポインタタイプ>'はタイプ '<データタイプ>'に変換できない可能性があります。 考えられるエラーの原因 ：このエラーは、プールオブジェクトをチェックする場合にのみ発生します。ポインタを整数に変換しようとしました。ライブラリ内のポインタのサイズは不明であるため、ライブラリの使用時にエラーが発生する可能性があります。 エラー訂正 ：タイプを使用 __UXINT また __XWORD ポインタを使用したプラットフォームに依存しない計算用。 エラーの例： PROGRAM PLC_PRG\nVAR\n ptr : POINTER TO INT;\n dw : DWORD;\nEND_VAR\n dw := ptr;\n メッセージ： C0033：タイプ 'POINTER TOINT'はタイプ 'DWORD'に変換できない可能性があります。 " }, 
{ "title" : "コンパイラエラーC0035 ", 
"url" : "_cds_error_c0035.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0035 ", 
"snippet" : "C0035 メッセージ ：「<無効な関数>」の代わりに、プログラム名、関数、または関数ブロックのインスタンスが必要です 考えられるエラーの原因 ：存在しない関数が呼び出されます。 エラー訂正 ：存在するプログラム名、関数、および関数ブロックインスタンスのみが呼び出されるようにしてください。 エラーの例： PROGRAM PLC_PRG VAR END_VAR PLC_PRG.METH1(); METHOD METH VAR_INPUT END_VAR メッセージ： C0004：「METH1」は「PLC_PRG」のコンポーネントではありません C0035：「PLC_PRG.METH1」の代わりに...", 
"body" : "C0035 メッセージ ：「<無効な関数>」の代わりに、プログラム名、関数、または関数ブロックのインスタンスが必要です 考えられるエラーの原因 ：存在しない関数が呼び出されます。 エラー訂正 ：存在するプログラム名、関数、および関数ブロックインスタンスのみが呼び出されるようにしてください。 エラーの例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nPLC_PRG.METH1();\n\nMETHOD METH\nVAR_INPUT\nEND_VAR\n メッセージ： C0004：「METH1」は「PLC_PRG」のコンポーネントではありません C0035：「PLC_PRG.METH1」の代わりにプログラム名、関数、またはファンクションブロックインスタンスが必要です エラー訂正： PLC_PRG.METH(); " }, 
{ "title" : "コンパイラエラーC0036 ", 
"url" : "_cds_error_c0036.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0036 ", 
"snippet" : "C0036 メッセージ ：タイプ<type>のオブジェクトを呼び出すことはできません 考えられるエラーの原因 ：呼び出しをサポートしていないオブジェクトを呼び出そうとしました。 エラー訂正 ：呼び出すことができるのは、関数、関数ブロック、プログラム、メソッド、およびアクションのみです。 エラーの例： VAR_GLOBAL GVL value : INT; END_VAR PROGRAM PLC_PRG GVL(); メッセージ： C0036：タイプ 'VAR_GLOBAL'のオブジェクトを呼び出すことができません...", 
"body" : "C0036 メッセージ ：タイプ<type>のオブジェクトを呼び出すことはできません 考えられるエラーの原因 ：呼び出しをサポートしていないオブジェクトを呼び出そうとしました。 エラー訂正 ：呼び出すことができるのは、関数、関数ブロック、プログラム、メソッド、およびアクションのみです。 エラーの例： VAR_GLOBAL GVL\n value : INT;\nEND_VAR\nPROGRAM PLC_PRG\nGVL();\n メッセージ： C0036：タイプ 'VAR_GLOBAL'のオブジェクトを呼び出すことができません " }, 
{ "title" : "コンパイラエラーC0037 ", 
"url" : "_cds_error_c0037.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0037 ", 
"snippet" : "C0037 メッセージ ： '<無効な入力>'は '<関数名>'の入力ではありません 考えられるエラーの原因 ：ローカル変数は関数呼び出しで定義されます。 エラー訂正 ：変数を入力パラメーターとして宣言します。 エラーの例： PROGRAM PLC_PRG VAR i : INT; END_VAR i := TEST(iVar := 1); FUNCTION TEST : INT VAR iVar : INT; END_VAR メッセージ： C0037：「iVar」は「TEST」の入力ではありません エラー訂正： VAR_INPUT iVar : INT; END_VAR...", 
"body" : "C0037 メッセージ ： '<無効な入力>'は '<関数名>'の入力ではありません 考えられるエラーの原因 ：ローカル変数は関数呼び出しで定義されます。 エラー訂正 ：変数を入力パラメーターとして宣言します。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\ni := TEST(iVar := 1);\n\nFUNCTION TEST : INT\nVAR\n iVar : INT;\nEND_VAR\n メッセージ： C0037：「iVar」は「TEST」の入力ではありません エラー訂正： VAR_INPUT\n iVar : INT;\nEND_VAR " }, 
{ "title" : "コンパイラエラーC0038 ", 
"url" : "_cds_error_c0038.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0038 ", 
"snippet" : "C0038 メッセージ ： '<無効な出力>'は '<関数名>'の出力ではありません 考えられるエラーの原因 ：ローカル変数は、関数呼び出しの出力として処理されます。 エラー訂正 ：変数を出力パラメーターとして宣言します。 エラーの例： PROGRAM PLC_PRG VAR i : INT; x : INT; END_VAR i := TEST(iVar => x); FUNCTION TEST : INT VAR iVar : INT; END_VAR メッセージ： C0038：「iVar」は「TEST」の出力ではありません エラー訂正： VAR_OUTPUT iVar : INT; EN...", 
"body" : "C0038 メッセージ ： '<無効な出力>'は '<関数名>'の出力ではありません 考えられるエラーの原因 ：ローカル変数は、関数呼び出しの出力として処理されます。 エラー訂正 ：変数を出力パラメーターとして宣言します。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\n x : INT;\nEND_VAR\ni := TEST(iVar => x);\n\nFUNCTION TEST : INT\nVAR\n iVar : INT;\nEND_VAR\n メッセージ： C0038：「iVar」は「TEST」の出力ではありません エラー訂正： VAR_OUTPUT\n iVar : INT;\nEND_VAR " }, 
{ "title" : "コンパイラエラーC0039 ", 
"url" : "_cds_error_c0039.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0039 ", 
"snippet" : "C0039 メッセージ ：VAR_IN_OUT '<無効な変数>'は '<関数ブロック名>'の呼び出しで割り当てる必要があります 考えられるエラーの原因 ：IN_OUT変数は、IN_OUT変数を必要とする機能ブロックに渡されません。 エラー訂正 ：IN_OUT変数を割り当てます。 エラーの例： PROGRAM PLC_PRG VAR inst : FB; END_VAR inst(); FUNCTION_BLOCK FB VAR_IN_OUT inout : INT; END_VAR メッセージ： C0039：VAR_IN_OUT'inout 'は' FB 'の呼び出しで割り当てる必要がありま...", 
"body" : "C0039 メッセージ ：VAR_IN_OUT '<無効な変数>'は '<関数ブロック名>'の呼び出しで割り当てる必要があります 考えられるエラーの原因 ：IN_OUT変数は、IN_OUT変数を必要とする機能ブロックに渡されません。 エラー訂正 ：IN_OUT変数を割り当てます。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\ninst();\n\nFUNCTION_BLOCK FB\nVAR_IN_OUT\n inout : INT;\nEND_VAR\n メッセージ： C0039：VAR_IN_OUT'inout 'は' FB 'の呼び出しで割り当てる必要があります エラー訂正： inst(inout := i); " }, 
{ "title" : "コンパイラエラーC0040 ", 
"url" : "_cds_error_c0040.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0040 ", 
"snippet" : "C0040 メッセージ ：関数 '<関数名>'には正確に '<入力数>'入力が必要です 考えられるエラーの原因 ：呼び出された関数に渡されるパラメーターが多すぎるか少なすぎます。 エラー訂正 ：期待される数のパラメーターを関数に渡します。 エラーの例： PROGRAM PLC_PRG VAR i : INT; END_VAR i := TEST(1,2); FUNCTION TEST : INT VAR_INPUT IN: INT; END_VAR メッセージ： C0040：関数「TEST」には正確に「1」の入力が必要です エラー訂正： i := Test(1);...", 
"body" : "C0040 メッセージ ：関数 '<関数名>'には正確に '<入力数>'入力が必要です 考えられるエラーの原因 ：呼び出された関数に渡されるパラメーターが多すぎるか少なすぎます。 エラー訂正 ：期待される数のパラメーターを関数に渡します。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\ni := TEST(1,2);\n\n\nFUNCTION TEST : INT\nVAR_INPUT\n IN: INT;\nEND_VAR\n メッセージ： C0040：関数「TEST」には正確に「1」の入力が必要です エラー訂正： i := Test(1); " }, 
{ "title" : "コンパイラエラーC0041 ", 
"url" : "_cds_error_c0041.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0041 ", 
"snippet" : "C0041 メッセージ ： '<関数名>'のVAR_IN_OUTパラメータ '<パラメータ名>'には、入力として書き込みアクセス権を持つ変数が必要です 考えられるエラーの原因 ：渡されたパラメーターは、書き込みアクセス権を持つ変数ではありません（たとえば定数）。 エラー訂正 ：関数への書き込みアクセス権を持つVAR_IN_OUTパラメーターを渡します。 エラーの例： PROGRAM PLC_PRG VAR i : INT; x : INT; END_VAR i := Test(31415); FUNCTION TEST : INT VAR_IN_OUT in_out: INT; END_VAR...", 
"body" : "C0041 メッセージ ： '<関数名>'のVAR_IN_OUTパラメータ '<パラメータ名>'には、入力として書き込みアクセス権を持つ変数が必要です 考えられるエラーの原因 ：渡されたパラメーターは、書き込みアクセス権を持つ変数ではありません（たとえば定数）。 エラー訂正 ：関数への書き込みアクセス権を持つVAR_IN_OUTパラメーターを渡します。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\n x : INT;\nEND_VAR\ni := Test(31415);\n\nFUNCTION TEST : INT\nVAR_IN_OUT\n in_out: INT;\nEND_VAR\n メッセージ： C0041：「TEST」のVAR_IN_OUTパラメータ「in_out」には、入力として書き込みアクセス権を持つ変数が必要です エラー訂正： i := Test(x); " }, 
{ "title" : "コンパイラエラーC0042（コンパイラバージョン<= 3.4.10） ", 
"url" : "_cds_error_c0042.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0042（コンパイラバージョン<= 3.4.10） ", 
"snippet" : "C0042 メッセージ ：関数呼び出しですべてまたはなしの仮パラメータを指定する必要があります 考えられるエラーの原因 ：パラメータが関数に間違った順序で明示的に割り当てられています。 エラー訂正 ：均一な仮パラメータまたは暗黙パラメータを使用します。 エラーの例： PROGRAM PLC_PRG VAR i : INT; END_VAR i := Test(iPar1:=2, 5); FUNCTION Test : INT VAR_INPUT iPar1 : INT; iPar2 : INT; END_VAR メッセージ： C0042：関数呼び出しですべてまたはなしの仮パラメーターを指定する...", 
"body" : "C0042 メッセージ ：関数呼び出しですべてまたはなしの仮パラメータを指定する必要があります 考えられるエラーの原因 ：パラメータが関数に間違った順序で明示的に割り当てられています。 エラー訂正 ：均一な仮パラメータまたは暗黙パラメータを使用します。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\n i := Test(iPar1:=2, 5);\n\nFUNCTION Test : INT\nVAR_INPUT\n iPar1 : INT;\n iPar2 : INT;\nEND_VAR\n メッセージ： C0042：関数呼び出しですべてまたはなしの仮パラメーターを指定する必要があります " }, 
{ "title" : "コンパイラエラーC0043 ", 
"url" : "_cds_error_c0043.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0043 ", 
"snippet" : "C0043 メッセージ ：間違った正式なパラメータ： '<パラメータ名>'がこの場所で予期されています 考えられるエラーの原因 ：パラメータが関数に間違った順序で明示的に割り当てられています。 エラー訂正 ：パラメータを正しい順序で指定してください。 エラーの例： PROGRAM PLC_PRG VAR i : INT; END_VAR i := Test(iPar2 := 2, 5); FUNCTION Test : INT VAR_INPUT iPar1 : INT; iPar2 : INT; END_VAR メッセージ： C0043：間違った仮パラメータ： 'iPar1'がこの場所で予期...", 
"body" : "C0043 メッセージ ：間違った正式なパラメータ： '<パラメータ名>'がこの場所で予期されています 考えられるエラーの原因 ：パラメータが関数に間違った順序で明示的に割り当てられています。 エラー訂正 ：パラメータを正しい順序で指定してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\ni := Test(iPar2 := 2, 5);\n\n\nFUNCTION Test : INT\nVAR_INPUT\n iPar1 : INT;\n iPar2 : INT;\nEND_VAR\n メッセージ： C0043：間違った仮パラメータ： 'iPar1'がこの場所で予期されています C0412：パラメータ ''の複数の入力割り当て エラー訂正 ： i := Test(5, iPar2 := 2); " }, 
{ "title" : "コンパイラエラーC0044 ", 
"url" : "_cds_error_c0044.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0044 ", 
"snippet" : "C0044 メッセージ ： '<関数ブロック名>'の呼び出しでパラメータ '<入力変数名>'の入力への割り当てがありません 考えられるエラーの原因 ：入力変数は宣言されていませんが、パラメーターは渡されます。 エラー訂正 ：入力変数を宣言します。 エラーの例： PROGRAM PLC_PRG VAR inst : FB; END_VAR inst(1); FUNCTION_BLOCK FB VAR_INPUT END_VAR メッセージ： C0044：「FB」の呼び出しでパラメーター「1」の入力への割り当てがありません エラー訂正： Beispiel: VAR_INPUT in : INT; ...", 
"body" : "C0044 メッセージ ： '<関数ブロック名>'の呼び出しでパラメータ '<入力変数名>'の入力への割り当てがありません 考えられるエラーの原因 ：入力変数は宣言されていませんが、パラメーターは渡されます。 エラー訂正 ：入力変数を宣言します。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\ninst(1);\n\n\nFUNCTION_BLOCK FB\nVAR_INPUT\n\nEND_VAR\n メッセージ： C0044：「FB」の呼び出しでパラメーター「1」の入力への割り当てがありません エラー訂正： Beispiel:\nVAR_INPUT\n in : INT;\nEND_VAR " }, 
{ "title" : "コンパイラエラーC0045 ", 
"url" : "_cds_error_c0045.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0045 ", 
"snippet" : "C0045 メッセージ ：このコンテキストでは「THIS」の使用は許可されていません 考えられるエラーの原因 ：現在のインスタンスに割り当てるために、これはメソッド、アクション、遷移、または関数ブロックの本体でのみ使用できます。このエラーメッセージは、他のすべての位置で表示されます。 エラー訂正 ：これは、許可されたコンテキストでのみ使用してください。 エラーの例： PROGRAM PLC_PRG VAR test1: INT; END_VAR THIS^.test1 := 19; メッセージ： C0018： 'THIS ^ .test1'は有効な割り当てターゲットではありません C0062：...", 
"body" : "C0045 メッセージ ：このコンテキストでは「THIS」の使用は許可されていません 考えられるエラーの原因 ：現在のインスタンスに割り当てるために、これはメソッド、アクション、遷移、または関数ブロックの本体でのみ使用できます。このエラーメッセージは、他のすべての位置で表示されます。 エラー訂正 ：これは、許可されたコンテキストでのみ使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n test1: INT;\nEND_VAR\n\nTHIS^.test1 := 19;\n メッセージ： C0018： 'THIS ^ .test1'は有効な割り当てターゲットではありません C0062： 'THIS ^'は構造体変数ではありません このコンテキストでは、「THIS」の使用は許可されていません " }, 
{ "title" : "コンパイラエラーC0046 ", 
"url" : "_cds_error_c0046.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0046 ", 
"snippet" : "C0046 メッセージ ：識別子 '<識別子名>'が定義されていません 考えられるエラーの原因 ：宣言されていない識別子が使用されています。 エラー訂正 ：使用する変数を宣言します。 エラーの例： PROGRAM PLC_PRG VAR END_VAR i := 1; メッセージ： C0018：「i」は有効な割り当てターゲットではありません C0046：識別子 'i'が定義されていません エラー訂正： VAR i : INT; END_VAR...", 
"body" : "C0046 メッセージ ：識別子 '<識別子名>'が定義されていません 考えられるエラーの原因 ：宣言されていない識別子が使用されています。 エラー訂正 ：使用する変数を宣言します。 エラーの例： PROGRAM PLC_PRG\nVAR\n\nEND_VAR\n\ni := 1;\n メッセージ： C0018：「i」は有効な割り当てターゲットではありません C0046：識別子 'i'が定義されていません エラー訂正： VAR\n i : INT;\nEND_VAR " }, 
{ "title" : "コンパイラエラーC0047 ", 
"url" : "_cds_error_c0047.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0047 ", 
"snippet" : "C0047 メッセージ ：タイプ '<データ型>'の式に '[]'を使用したインデックス付けを適用することはできません 考えられるエラーの原因 ：配列ではないデータ型は、「[]」でインデックス付けされます。 エラー訂正 ：配列として宣言されている場合にのみ、データ型に「[]」のインデックスを付けます。 エラーの例： PROGRAM PLC_PRG VAR i : INT; END_VAR i[1]; メッセージ： C0047：タイプ「INT」の式に「[]」を使用したインデックス付けを適用できません...", 
"body" : "C0047 メッセージ ：タイプ '<データ型>'の式に '[]'を使用したインデックス付けを適用することはできません 考えられるエラーの原因 ：配列ではないデータ型は、「[]」でインデックス付けされます。 エラー訂正 ：配列として宣言されている場合にのみ、データ型に「[]」のインデックスを付けます。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\ni[1];\n メッセージ： C0047：タイプ「INT」の式に「[]」を使用したインデックス付けを適用できません " }, 
{ "title" : "コンパイラエラーC0048 ", 
"url" : "_cds_error_c0048.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0048 ", 
"snippet" : "C0048 メッセージ ：配列には正確に '<number>'インデックスが必要です 考えられるエラーの原因 ：配列を使用するときに指定されるインデックスが多すぎるか少なすぎます。 エラー訂正 ：配列に割り当てられた次元と同じ数のインデックスを指定します。 エラーの例： PROGRAM PLC_PRG VAR arr1 : ARRAY[1..2,1..3] OF INT; END_VAR arr1[1] := 5; メッセージ： C0048：配列には正確に2つのインデックスが必要です エラー訂正： arr1[1,2] := 5;...", 
"body" : "C0048 メッセージ ：配列には正確に '<number>'インデックスが必要です 考えられるエラーの原因 ：配列を使用するときに指定されるインデックスが多すぎるか少なすぎます。 エラー訂正 ：配列に割り当てられた次元と同じ数のインデックスを指定します。 エラーの例： PROGRAM PLC_PRG\nVAR\n arr1 : ARRAY[1..2,1..3] OF INT;\nEND_VAR\narr1[1] := 5;\n メッセージ： C0048：配列には正確に2つのインデックスが必要です エラー訂正： arr1[1,2] := 5; " }, 
{ "title" : "コンパイラエラーC0049 ", 
"url" : "_cds_error_c0049.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0049 ", 
"snippet" : "C0049 メッセージ ：定数インデックス '<インデックス値>'が '<開始インデックス>'から '<終了インデックス>'の範囲内にありません 考えられるエラーの原因 ：配列のサイズ外のインデックスが指定されています。 エラー訂正 ：配列のサイズ内のインデックスのみを使用してください。 エラーの例： PROGRAM PLC_PRG VAR arr1 : ARRAY[1..2] OF INT; END_VAR arr1[3] := 1; メッセージ： C0049：定数インデックス「3」が「1」から「2」の範囲内にありません エラー訂正： arr1[2] := 1;...", 
"body" : "C0049 メッセージ ：定数インデックス '<インデックス値>'が '<開始インデックス>'から '<終了インデックス>'の範囲内にありません 考えられるエラーの原因 ：配列のサイズ外のインデックスが指定されています。 エラー訂正 ：配列のサイズ内のインデックスのみを使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n arr1 : ARRAY[1..2] OF INT;\nEND_VAR\narr1[3] := 1;\n メッセージ： C0049：定数インデックス「3」が「1」から「2」の範囲内にありません エラー訂正： arr1[2] := 1; " }, 
{ "title" : "コンパイラエラーC0050 ", 
"url" : "_cds_error_c0050.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0050 ", 
"snippet" : "C0050 メッセージ ：ビットアクセスには、リテラルまたはシンボリック整数定数が必要です 考えられるエラーの原因 ：ビットアクセスでリテラルまたは整数定数が指定されていません。 エラー訂正 ：リテラルまたは整数定数を使用してください。 エラーの例： PROGRAM PLC_PRG VAR i : INT; x : INT; END_VAR i.x := FALSE; メッセージ： C0018：「ix」は有効な割り当てターゲットではありません C0050：ビットアクセスにはリテラルまたはシンボリック整数定数が必要です エラー訂正： i := Test(x);...", 
"body" : "C0050 メッセージ ：ビットアクセスには、リテラルまたはシンボリック整数定数が必要です 考えられるエラーの原因 ：ビットアクセスでリテラルまたは整数定数が指定されていません。 エラー訂正 ：リテラルまたは整数定数を使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\n x : INT;\nEND_VAR\n\ni.x := FALSE;\n メッセージ： C0018：「ix」は有効な割り当てターゲットではありません C0050：ビットアクセスにはリテラルまたはシンボリック整数定数が必要です エラー訂正： i := Test(x); " }, 
{ "title" : "コンパイラエラーC0051 ", 
"url" : "_cds_error_c0051.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0051 ", 
"snippet" : "C0051 メッセージ ： '<value>'ではなく属性値に必要な1バイトの文字列。 考えられるエラーの原因 ：表示された場所に文字列が期待どおりに表示されません。 エラー訂正 ：現在の値を文字列に置き換えます。 エラーの例： PROGRAM PLC_PRG {IF hasattribute(pou: MyPOU, MyAttribute)} {END_IF} メッセージ： C0051：MyAttributeではなく属性値に1バイトの文字列が必要です。 エラー訂正： PROGRAM PLC_PRG {IF hasattribute(pou: MyPOU, 'MyAttribute')} {E...", 
"body" : "C0051 メッセージ ： '<value>'ではなく属性値に必要な1バイトの文字列。 考えられるエラーの原因 ：表示された場所に文字列が期待どおりに表示されません。 エラー訂正 ：現在の値を文字列に置き換えます。 エラーの例： PROGRAM PLC_PRG\n{IF hasattribute(pou: MyPOU, MyAttribute)}\n{END_IF}\n メッセージ： C0051：MyAttributeではなく属性値に1バイトの文字列が必要です。 エラー訂正： PROGRAM PLC_PRG\n{IF hasattribute(pou: MyPOU, 'MyAttribute')}\n{END_IF} " }, 
{ "title" : "コンパイラエラーC0053 ", 
"url" : "_cds_error_c0053.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0053 ", 
"snippet" : "C0053 メッセージ ：コンパイラバージョン<version>は廃止されました。代わりに、より高いバージョンのコンパイラを使用してください。 考えられるエラーの原因 ：現在のコンパイラバージョンは使用できません。 エラー訂正 ：プロジェクト内の現在のコンパイラバージョンを適応させます（プロジェクト環境、プロジェクト設定）。...", 
"body" : "C0053 メッセージ ：コンパイラバージョン<version>は廃止されました。代わりに、より高いバージョンのコンパイラを使用してください。 考えられるエラーの原因 ：現在のコンパイラバージョンは使用できません。 エラー訂正 ：プロジェクト内の現在のコンパイラバージョンを適応させます（プロジェクト環境、プロジェクト設定）。 " }, 
{ "title" : "コンパイラエラーC0061 ", 
"url" : "_cds_error_c0061.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0061 ", 
"snippet" : "C0061 メッセージ ：関数呼び出しでのビットアクセスは許可されていません 考えられるエラーの原因 ：関数に対してビットアクセスを実行します。 エラー訂正 ：サポートされているデータ型に対してのみビットアクセスを使用します。 エラーの例： PROGRAM PLC_PRG VAR END_VAR Test().2; FUNCTION Test : INT VAR_INPUT END_VAR メッセージ： C0061：関数呼び出しでのビットアクセスは許可されていません...", 
"body" : "C0061 メッセージ ：関数呼び出しでのビットアクセスは許可されていません 考えられるエラーの原因 ：関数に対してビットアクセスを実行します。 エラー訂正 ：サポートされているデータ型に対してのみビットアクセスを使用します。 エラーの例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nTest().2;\n\nFUNCTION Test : INT\nVAR_INPUT\n\nEND_VAR\n メッセージ： C0061：関数呼び出しでのビットアクセスは許可されていません " }, 
{ "title" : "コンパイラエラーC0062 ", 
"url" : "_cds_error_c0062.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0062 ", 
"snippet" : "C0062 メッセージ ： '<変数名>'は構造化変数ではありません 考えられるエラーの原因 ：構造体変数ではない変数は、構造体変数のように扱われます。 エラー訂正 ：変数が構造体変数であることを確認してください。 エラーの例： PROGRAM PLC_PRG VAR pt : PUNKT; i : INT; END_VAR i.x := 1024; TYPE Punkt : STRUCT x : REAL; y : REAL; END_STRUCT END_TYPE メッセージ： C0018：「ix」は有効な割り当てターゲットではありません C0062：「変数」は構造変数ではありません エラ...", 
"body" : "C0062 メッセージ ： '<変数名>'は構造化変数ではありません 考えられるエラーの原因 ：構造体変数ではない変数は、構造体変数のように扱われます。 エラー訂正 ：変数が構造体変数であることを確認してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n pt : PUNKT;\n i : INT;\nEND_VAR\n\ni.x := 1024;\n\n\nTYPE Punkt :\nSTRUCT\n x : REAL;\n y : REAL;\nEND_STRUCT\nEND_TYPE\n メッセージ： C0018：「ix」は有効な割り当てターゲットではありません C0062：「変数」は構造変数ではありません エラー訂正： Beispiel:\npt.x := 1024; " }, 
{ "title" : "コンパイラエラーC0064 ", 
"url" : "_cds_error_c0064.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0064 ", 
"snippet" : "C0064 メッセージ ：間接参照にはポインターが必要です 考えられるエラーの原因 ：ポインタ変数ではない変数は「逆参照」されます。 エラー訂正 ：ポインタ変数である変数のみを「間接参照」します。 エラーの例： PROGRAM PLC_PRG VAR i : INT; pi : POINTER TO INT; END_VAR i^:=1; メッセージ： C0018： 'i ^'は有効な割り当てターゲットではありません C0064：間接参照にはポインターが必要です エラー訂正： pi := ADR(i); pi^ := 1;...", 
"body" : "C0064 メッセージ ：間接参照にはポインターが必要です 考えられるエラーの原因 ：ポインタ変数ではない変数は「逆参照」されます。 エラー訂正 ：ポインタ変数である変数のみを「間接参照」します。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\n pi : POINTER TO INT;\nEND_VAR\ni^:=1;\n メッセージ： C0018： 'i ^'は有効な割り当てターゲットではありません C0064：間接参照にはポインターが必要です エラー訂正： pi := ADR(i);\npi^ := 1; " }, 
{ "title" : "コンパイラエラーC0065 ", 
"url" : "_cds_error_c0065.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0065 ", 
"snippet" : "C0065 メッセージ ： '<name>'のグローバル定義はありません。 考えられるエラーの原因 ：検索された値は、グローバル変数、グローバルPOU、またはグローバルにアクセスできるその他の値ではありません。 エラー訂正 ： '<name>'をグローバル変数として宣言します。 エラーの例： PROGRAM PLC_PRG .someValue := 5; メッセージ： C0065：「someValue」のグローバル定義はありません。 エラー訂正： VAR_GLOBAL someValue : INT; END_VAR...", 
"body" : "C0065 メッセージ ： '<name>'のグローバル定義はありません。 考えられるエラーの原因 ：検索された値は、グローバル変数、グローバルPOU、またはグローバルにアクセスできるその他の値ではありません。 エラー訂正 ： '<name>'をグローバル変数として宣言します。 エラーの例： PROGRAM PLC_PRG\n.someValue := 5;\n メッセージ： C0065：「someValue」のグローバル定義はありません。 エラー訂正： VAR_GLOBAL\n someValue : INT;\nEND_VAR " }, 
{ "title" : "コンパイラエラーC0066 ", 
"url" : "_cds_error_c0066.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0066 ", 
"snippet" : "C0066 メッセージ ：タイプ '<データタイプ>'とタイプ '<データタイプ>'を比較できません 考えられるエラーの原因 ：互いに比較できない2つのデータ型が比較されます。 エラー訂正 ：相互に比較できるデータ型のみを比較します。 エラーの例： PROGRAM PLC_PRG VAR i : INT; re : REAL; str: STRING; b : BOOL; END_VAR b := i > str; メッセージ： C0066：タイプ 'INT'とタイプ 'STRING'を比較できません エラー訂正： b := i > re;...", 
"body" : "C0066 メッセージ ：タイプ '<データタイプ>'とタイプ '<データタイプ>'を比較できません 考えられるエラーの原因 ：互いに比較できない2つのデータ型が比較されます。 エラー訂正 ：相互に比較できるデータ型のみを比較します。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\n re : REAL;\n str: STRING;\n b : BOOL;\nEND_VAR\n\nb := i > str;\n メッセージ： C0066：タイプ 'INT'とタイプ 'STRING'を比較できません エラー訂正： b := i > re; " }, 
{ "title" : "コンパイラエラーC0068 ", 
"url" : "_cds_error_c0068.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0068 ", 
"snippet" : "C0068 メッセージ ：タイプ '<データタイプ>'のオブジェクトでは比較できません 考えられるエラーの原因 ：比較できないオブジェクトを比較しています。 エラー訂正 ：比較が可能なデータ型（INT、REALなど）のみを比較します。 エラーの例： PROGRAM PLC_PRG VAR b : BOOL; arr1 : ARRAY [1..2] OF INT; arr2 : ARRAY [1..2] OF INT; END_VAR b := arr1 > arr2; メッセージ： C0068：タイプ 'ARRAY [1..2]'のオブジェクトでは比較できません...", 
"body" : "C0068 メッセージ ：タイプ '<データタイプ>'のオブジェクトでは比較できません 考えられるエラーの原因 ：比較できないオブジェクトを比較しています。 エラー訂正 ：比較が可能なデータ型（INT、REALなど）のみを比較します。 エラーの例： PROGRAM PLC_PRG\nVAR\n b : BOOL;\n arr1 : ARRAY [1..2] OF INT;\n arr2 : ARRAY [1..2] OF INT;\nEND_VAR\n\nb := arr1 > arr2;\n メッセージ： C0068：タイプ 'ARRAY [1..2]'のオブジェクトでは比較できません " }, 
{ "title" : "コンパイラエラーC0069 ", 
"url" : "_cds_error_c0069.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0069 ", 
"snippet" : "C0069 メッセージ ：タイプ '<データタイプ>'または '<データタイプ>'のオブジェクトでは比較できません 考えられるエラーの原因 ：比較できない2つの異なるオブジェクトが比較されています。 エラー訂正 ：比較可能なデータ型（INT、REALなど）のみを比較します。 エラーの例： PROGRAM PLC_PRG VAR b : BOOL; arr1 : ARRAY [1..2] OF INT; arr2 : ARRAY [1..3] OF INT; END_VAR b := arr1 > arr2; メッセージ： C0069：タイプ 'ARRAY [1..2]'または 'ARRAY [...", 
"body" : "C0069 メッセージ ：タイプ '<データタイプ>'または '<データタイプ>'のオブジェクトでは比較できません 考えられるエラーの原因 ：比較できない2つの異なるオブジェクトが比較されています。 エラー訂正 ：比較可能なデータ型（INT、REALなど）のみを比較します。 エラーの例： PROGRAM PLC_PRG\nVAR\n b : BOOL;\n arr1 : ARRAY [1..2] OF INT;\n arr2 : ARRAY [1..3] OF INT;\nEND_VAR\n\nb := arr1 > arr2;\n メッセージ： C0069：タイプ 'ARRAY [1..2]'または 'ARRAY [1..3]'のオブジェクトでは比較できません " }, 
{ "title" : "コンパイラエラーC0070 ", 
"url" : "_cds_error_c0070.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0070 ", 
"snippet" : "C0070 メッセージ ： 'INI'演算子には、関数ブロックインスタンスまたはデータユニットタイプインスタンスが必要です 考えられるエラーの原因 ：関数ブロックインスタンスもDUTインスタンスもINI演算子に適用されません。 エラー訂正 ：ファンクションブロックインスタンスまたはDUTインスタンスのみをINIオペレータに渡します。 エラーの例： PROGRAM PLC_PRG VAR b : BOOL; inst : FB; END_VAR b := INI(b, TRUE); FUNCTION_BLOCK FB VAR END_VAR メッセージ： C0070： 'INI'演算子には、関数...", 
"body" : "C0070 メッセージ ： 'INI'演算子には、関数ブロックインスタンスまたはデータユニットタイプインスタンスが必要です 考えられるエラーの原因 ：関数ブロックインスタンスもDUTインスタンスもINI演算子に適用されません。 エラー訂正 ：ファンクションブロックインスタンスまたはDUTインスタンスのみをINIオペレータに渡します。 エラーの例： PROGRAM PLC_PRG\nVAR\n b : BOOL;\n inst : FB;\nEND_VAR\n\nb := INI(b, TRUE);\n\nFUNCTION_BLOCK FB\nVAR\nEND_VAR\n メッセージ： C0070： 'INI'演算子には、関数ブロックインスタンスまたはデータユニットタイプインスタンスが必要です エラー訂正： b := INI(inst, TRUE); " }, 
{ "title" : "コンパイラエラーC0072 ", 
"url" : "_cds_error_c0072.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0072 ", 
"snippet" : "C0072 メッセージ ：演算子 '<演算子名>'は型 '<データ型>'では使用できません 考えられるエラーの原因 ：互換性のないタイプに演算子が適用されます。 エラー訂正 ：互換性のあるタイプにのみ演算子を適用します。 エラーの例： PROGRAM PLC_PRG VAR i : INT; str : STRING; END_VAR str := ABS(str); メッセージ： C0072：演算子「Abs」はタイプ「STRING」では使用できません エラー訂正： i := ABS(i);...", 
"body" : "C0072 メッセージ ：演算子 '<演算子名>'は型 '<データ型>'では使用できません 考えられるエラーの原因 ：互換性のないタイプに演算子が適用されます。 エラー訂正 ：互換性のあるタイプにのみ演算子を適用します。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\n str : STRING;\nEND_VAR\n\nstr := ABS(str);\n メッセージ： C0072：演算子「Abs」はタイプ「STRING」では使用できません エラー訂正： i := ABS(i); " }, 
{ "title" : "コンパイラエラーC0074 ", 
"url" : "_cds_error_c0074.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0074 ", 
"snippet" : "C0074 メッセージ ：予期しないアレイの初期化 考えられるエラーの原因 ：配列初期化の構文エラー エラー訂正 ：構文を修正してください エラーの例： PROGRAM PLC_PRG VAR arr1 : INT := [1,2,3,4,5,6]; END_VAR メッセージ： C0074：予期しないアレイの初期化 C0032：タイプ '不明なタイプ：' [1,2,3,4,5,6] 'はタイプ' INT 'に変換できません エラー訂正： arr1 : ARRAY [1..6] OF INT := [1,2,3,4,5,6];...", 
"body" : "C0074 メッセージ ：予期しないアレイの初期化 考えられるエラーの原因 ：配列初期化の構文エラー エラー訂正 ：構文を修正してください エラーの例： PROGRAM PLC_PRG\nVAR\n arr1 : INT := [1,2,3,4,5,6];\nEND_VAR\n メッセージ： C0074：予期しないアレイの初期化 C0032：タイプ '不明なタイプ：' [1,2,3,4,5,6] 'はタイプ' INT 'に変換できません エラー訂正： arr1 : ARRAY [1..6] OF INT := [1,2,3,4,5,6]; " }, 
{ "title" : "コンパイラエラーC0075 ", 
"url" : "_cds_error_c0075.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0075 ", 
"snippet" : "C0075 メッセージ ：配列の初期化子が多すぎます 考えられるエラーの原因 ：配列のサイズに指定されている値が多すぎます。 エラー訂正 ：割り当てられる値の数は、配列のサイズに対応している必要があります。 エラーの例： PROGRAM PLC_PRG VAR arr1 : ARRAY [1..5] OF INT := [1,2,3,4,5,6]; END_VAR メッセージ： C0075：予期しないアレイの初期化 エラー訂正： arr1 : ARRAY [1..6] OF INT := [1,2,3,4,5,6];...", 
"body" : "C0075 メッセージ ：配列の初期化子が多すぎます 考えられるエラーの原因 ：配列のサイズに指定されている値が多すぎます。 エラー訂正 ：割り当てられる値の数は、配列のサイズに対応している必要があります。 エラーの例： PROGRAM PLC_PRG\nVAR\n arr1 : ARRAY [1..5] OF INT := [1,2,3,4,5,6];\nEND_VAR\n メッセージ： C0075：予期しないアレイの初期化 エラー訂正： arr1 : ARRAY [1..6] OF INT := [1,2,3,4,5,6]; " }, 
{ "title" : "コンパイラエラーC0076 ", 
"url" : "_cds_error_c0076.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0076 ", 
"snippet" : "C0076 メッセージ ：予期しない構造の初期化 考えられるエラーの原因 ：構造体初期化の構文エラー エラー訂正 ：構文が正しいことを確認してください。 エラーの例： PROGRAM PLC_PRG VAR st1 : INT := (p1 := 1); END_VAR メッセージ： C0076：予期しない構造の初期化 C0032：タイプ 'STRUCT（p1：= 1）'はタイプ 'INT'に変換できません C0046：識別子 'p1'が定義されていません C0018：「p1」は有効な割り当てターゲットではありません エラー訂正： st1 : STRUCT1 := (p1:=1,p2:=10)...", 
"body" : "C0076 メッセージ ：予期しない構造の初期化 考えられるエラーの原因 ：構造体初期化の構文エラー エラー訂正 ：構文が正しいことを確認してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n st1 : INT := (p1 := 1);\nEND_VAR\n メッセージ： C0076：予期しない構造の初期化 C0032：タイプ 'STRUCT（p1：= 1）'はタイプ 'INT'に変換できません C0046：識別子 'p1'が定義されていません C0018：「p1」は有効な割り当てターゲットではありません エラー訂正： st1 : STRUCT1 := (p1:=1,p2:=10); " }, 
{ "title" : "コンパイラエラーC0077 ", 
"url" : "_cds_error_c0077.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0077 ", 
"snippet" : "C0077 メッセージ ：不明なタイプ： '<データタイプ>' 考えられるエラーの原因 ：宣言のデータ型が無効です（構文エラーの可能性があります） エラー訂正 ：有効なデータ型のみを指定してください。 エラーの例： PROGRAM PLC_PRG VAR i : INTEGER; END_VAR メッセージ： C0077：不明なタイプ： 'INTEGER' エラー訂正： arr1 : ARRAY[1..2] OF STRUCT1 := (p1:=1,p2:=10);...", 
"body" : "C0077 メッセージ ：不明なタイプ： '<データタイプ>' 考えられるエラーの原因 ：宣言のデータ型が無効です（構文エラーの可能性があります） エラー訂正 ：有効なデータ型のみを指定してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INTEGER;\nEND_VAR\n メッセージ： C0077：不明なタイプ： 'INTEGER' エラー訂正： arr1 : ARRAY[1..2] OF STRUCT1 := (p1:=1,p2:=10); " }, 
{ "title" : "コンパイラエラーC0078 ", 
"url" : "_cds_error_c0078.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0078 ", 
"snippet" : "C0078 メッセージ ：サポートされていないタイプ： '<データタイプ>' 考えられるエラーの原因 ：使用されているタイプは現在のデバイスでサポートされていないため、使用できません。 エラー訂正 ：可能であれば、別のタイプを使用してください。例えば、 REAL それ以外の LREAL 。 エラーの例： PROGRAM PLC_PRG VAR value : LREAL; END_VAR メッセージ： C0078：サポートされていないタイプ： 'LREAL' エラー訂正： PROGRAM PLC_PRG VAR value : REAL; END_VAR...", 
"body" : "C0078 メッセージ ：サポートされていないタイプ： '<データタイプ>' 考えられるエラーの原因 ：使用されているタイプは現在のデバイスでサポートされていないため、使用できません。 エラー訂正 ：可能であれば、別のタイプを使用してください。例えば、 REAL それ以外の LREAL 。 エラーの例： PROGRAM PLC_PRG\nVAR\n value : LREAL;\nEND_VAR\n メッセージ： C0078：サポートされていないタイプ： 'LREAL' エラー訂正： PROGRAM PLC_PRG\nVAR\n value : REAL;\nEND_VAR " }, 
{ "title" : "コンパイラエラーC0080 ", 
"url" : "_cds_error_c0080.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0080 ", 
"snippet" : "C0080 メッセージ ：機能ブロック '<機能ブロック名>'にアクセスするには、インスタンス化する必要があります 考えられるエラーの原因 ：欠落している関数ブロックのインスタンス化 エラー訂正 ：機能ブロックをインスタンス化します。 エラーの例： PROGRAM PLC_PRG VAR END_VAR FB(); FUNCTION_BLOCK FB VAR END_VAR メッセージ： C0080：アクセスするには機能ブロック「FB」をインスタンス化する必要があります エラー訂正： VAR inst : FB; END_VAR inst();...", 
"body" : "C0080 メッセージ ：機能ブロック '<機能ブロック名>'にアクセスするには、インスタンス化する必要があります 考えられるエラーの原因 ：欠落している関数ブロックのインスタンス化 エラー訂正 ：機能ブロックをインスタンス化します。 エラーの例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nFB();\n\n\nFUNCTION_BLOCK FB\nVAR\nEND_VAR\n メッセージ： C0080：アクセスするには機能ブロック「FB」をインスタンス化する必要があります エラー訂正： VAR\n inst : FB;\nEND_VAR\ninst(); " }, 
{ "title" : "コンパイラエラーC0081 ", 
"url" : "_cds_error_c0081.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0081 ", 
"snippet" : "C0081 メッセージ ：予期しないプラグマ： '<プラグマ名>'が一致せずに見つかりました 'if' 考えられるエラーの原因 ：プラグマを使用すると、IF条件が欠落しています。 エラー訂正 ：プラグマのIF条件を完了します。 エラーの例： PROGRAM PLC_PRG VAR i : INT; END_VAR i := 5; {END_IF} メッセージ： C0081：予期しないプラグマ： 'END_IF'が 'if'と一致せずに見つかりました エラー訂正： {IF <expression>} i := 5; {END_IF}...", 
"body" : "C0081 メッセージ ：予期しないプラグマ： '<プラグマ名>'が一致せずに見つかりました 'if' 考えられるエラーの原因 ：プラグマを使用すると、IF条件が欠落しています。 エラー訂正 ：プラグマのIF条件を完了します。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\n\ni := 5;\n{END_IF}\n メッセージ： C0081：予期しないプラグマ： 'END_IF'が 'if'と一致せずに見つかりました エラー訂正： {IF <expression>}\ni := 5;\n{END_IF} " }, 
{ "title" : "コンパイラエラーC0082 ", 
"url" : "_cds_error_c0082.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0082 ", 
"snippet" : "C0082 メッセージ ： '<invalid pragma>'は、プラグマの有効な条件ではありません 考えられるエラーの原因 ：プラグマを使用する場合、IF条件で無効な式が使用されます。 エラー訂正 ：有効なプラグマ条件を使用してください。 エラーの例： PROGRAM PLC_PRG VAR i : INT; END_VAR {IF abc} i := 5; {END_IF} メッセージ： C0082： '!!!エラー!!!'プラグマの有効な条件ではありません エラー訂正： {IF defined (abc)}...", 
"body" : "C0082 メッセージ ： '<invalid pragma>'は、プラグマの有効な条件ではありません 考えられるエラーの原因 ：プラグマを使用する場合、IF条件で無効な式が使用されます。 エラー訂正 ：有効なプラグマ条件を使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\n\n{IF abc}\ni := 5;\n{END_IF}\n メッセージ： C0082： '!!!エラー!!!'プラグマの有効な条件ではありません エラー訂正： {IF defined (abc)} " }, 
{ "title" : "コンパイラエラーC0084 ", 
"url" : "_cds_error_c0084.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0084 ", 
"snippet" : "C0084 メッセージ ： '<プラグマオペランド>'はプラグマの有効なオペランドではありません 考えられるエラーの原因 ： 構文エラー エラー訂正 ：有効なプラグマオペランドを使用してください。 エラーの例： PROGRAM PLC_PRG VAR END_VAR {IF defined(0)} {END_IF} メッセージ： C0084： 'defined（null）'はプラグマの有効なオペランドではありません エラー訂正： {IF defined (abc)}...", 
"body" : "C0084 メッセージ ： '<プラグマオペランド>'はプラグマの有効なオペランドではありません 考えられるエラーの原因 ： 構文エラー エラー訂正 ：有効なプラグマオペランドを使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\n{IF defined(0)}\n{END_IF}\n メッセージ： C0084： 'defined（null）'はプラグマの有効なオペランドではありません エラー訂正： {IF defined (abc)} " }, 
{ "title" : "コンパイラエラーC0085 ", 
"url" : "_cds_error_c0085.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0085 ", 
"snippet" : "C0085 メッセージ ： '<value>'の代わりに期待される値を定義します。 考えられるエラーの原因 ：プラグマの表示位置に、現在の値の代わりに文字列が必要です。 エラー訂正 ：現在の値を文字列に置き換えます。 エラーの例： PROGRAM PLC_PRG {IF hasvalue(define, defineValue)} {END_IF} メッセージ： C0085： 'defineValue'の代わりに期待される値を定義してください。 エラー訂正： PROGRAM PLC_PRG {IF hasvalue(define, '120')} {END_IF}...", 
"body" : "C0085 メッセージ ： '<value>'の代わりに期待される値を定義します。 考えられるエラーの原因 ：プラグマの表示位置に、現在の値の代わりに文字列が必要です。 エラー訂正 ：現在の値を文字列に置き換えます。 エラーの例： PROGRAM PLC_PRG\n\n{IF hasvalue(define, defineValue)}\n{END_IF}\n メッセージ： C0085： 'defineValue'の代わりに期待される値を定義してください。 エラー訂正： PROGRAM PLC_PRG\n\n{IF hasvalue(define, '120')}\n{END_IF} " }, 
{ "title" : "コンパイラエラーC0086 ", 
"url" : "_cds_error_c0086.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0086 ", 
"snippet" : "C0086 メッセージ ：インターフェース '<インターフェース名>'の定義が見つかりません 考えられるエラーの原因 ：未定義のインターフェースが使用されています。 エラー訂正 ：インターフェースを定義します。 エラーの例： PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTION_BLOCK FB IMPLEMENTS XY VAR END_VAR メッセージ： C0086：インターフェース 'XY'の定義が見つかりません エラー訂正： INTERFACE XY...", 
"body" : "C0086 メッセージ ：インターフェース '<インターフェース名>'の定義が見つかりません 考えられるエラーの原因 ：未定義のインターフェースが使用されています。 エラー訂正 ：インターフェースを定義します。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB IMPLEMENTS XY\nVAR\nEND_VAR\n メッセージ： C0086：インターフェース 'XY'の定義が見つかりません エラー訂正： INTERFACE XY " }, 
{ "title" : "コンパイラエラーC0087 ", 
"url" : "_cds_error_c0087.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0087 ", 
"snippet" : "C0087 メッセージ ：インターフェース '<インターフェース名>'で定義されたメソッド '<メソッド名>'の実装はありません。 考えられるエラーの原因 ：インターフェースで指定されたメソッドの1つが、実装された機能ブロックによって提供されていません。 エラー訂正 ：インターフェースで指定されたすべてのメソッドを実装します。 エラーの例： PROGRAM PLC_PRG VAR inst : FB; END_VAR INTERFACE XY METHOD METH1 VAR_INPUT END_VAR FUNCTION_BLOCK FB IMPLEMENTS XY VAR END_VAR M...", 
"body" : "C0087 メッセージ ：インターフェース '<インターフェース名>'で定義されたメソッド '<メソッド名>'の実装はありません。 考えられるエラーの原因 ：インターフェースで指定されたメソッドの1つが、実装された機能ブロックによって提供されていません。 エラー訂正 ：インターフェースで指定されたすべてのメソッドを実装します。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\nINTERFACE XY\nMETHOD METH1\nVAR_INPUT\nEND_VAR\n\nFUNCTION_BLOCK FB IMPLEMENTS XY\nVAR\nEND_VAR\nMETHOD METH2\nVAR_INPUT\nEND_VAR\n メッセージ： C0087：インタフェース 'XY'で定義されたメソッド 'METH1'の実装はありません " }, 
{ "title" : "コンパイラエラーC0089 ", 
"url" : "_cds_error_c0089.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0089 ", 
"snippet" : "C0089 メッセージ ：インターフェース '{1}'のオーバーライドされたメソッド '{0}'のインターフェースが宣言と一致しません 考えられるエラーの原因 ：実装されたメソッドのシグニチャが、インターフェイスのメソッドのシグニチャと一致しません。 エラー訂正 ：同じ戻りタイプとパラメーターが宣言されていることを確認してください。 エラーの例： PROGRAM PLC_PRG VAR inst : FB; END_VAR INTERFACE XY METHOD METH1 VAR_INPUT iPar : INT; END_VAR FUNCTION_BLOCK FB IMPLEMENTS X...", 
"body" : "C0089 メッセージ ：インターフェース '{1}'のオーバーライドされたメソッド '{0}'のインターフェースが宣言と一致しません 考えられるエラーの原因 ：実装されたメソッドのシグニチャが、インターフェイスのメソッドのシグニチャと一致しません。 エラー訂正 ：同じ戻りタイプとパラメーターが宣言されていることを確認してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\nINTERFACE XY\nMETHOD METH1\nVAR_INPUT\n iPar : INT;\nEND_VAR\n\nFUNCTION_BLOCK FB IMPLEMENTS XY\nVAR\nEND_VAR\nMETHOD METH1\nVAR_INPUT\nEND_VAR\n メッセージ： C0089：インターフェース 'XY'のオーバーライドされたメソッド 'METH1'のインターフェースが宣言と一致しません " }, 
{ "title" : "コンパイラエラーC0090 ", 
"url" : "_cds_error_c0090.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0090 ", 
"snippet" : "C0090 メッセージ ：基本クラス '<関数名>'の定義が見つかりません 考えられるエラーの原因 ：ベースとして指定された機能ブロックが存在しないか、機能ブロックではありません。 エラー訂正 ：ベースとして機能ブロックを使用します。 エラーの例： PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTION_BLOCK FB EXTENDS POU VAR END_VAR FUNCTION POU VAR END_VAR メッセージ： C0090：基本クラス「POU」の定義が見つかりません...", 
"body" : "C0090 メッセージ ：基本クラス '<関数名>'の定義が見つかりません 考えられるエラーの原因 ：ベースとして指定された機能ブロックが存在しないか、機能ブロックではありません。 エラー訂正 ：ベースとして機能ブロックを使用します。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\nFUNCTION_BLOCK FB EXTENDS POU\nVAR\nEND_VAR\n\nFUNCTION POU\nVAR\nEND_VAR\n メッセージ： C0090：基本クラス「POU」の定義が見つかりません " }, 
{ "title" : "コンパイラエラーC0091 ", 
"url" : "_cds_error_c0091.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0091 ", 
"snippet" : "C0091 メッセージ ：基本関数ブロックリストの再帰：<関数名> 考えられるエラーの原因 ：基本機能ブロックはそれ自体で拡張されます。 エラー訂正 ：基本機能ブロックリストの再帰はできません。 エラーの例： PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTION_BLOCK FB EXTENDS FB VAR END_VAR メッセージ： C0091：基本機能ブロックリストの再帰：FB-> FB...", 
"body" : "C0091 メッセージ ：基本関数ブロックリストの再帰：<関数名> 考えられるエラーの原因 ：基本機能ブロックはそれ自体で拡張されます。 エラー訂正 ：基本機能ブロックリストの再帰はできません。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB EXTENDS FB\nVAR\nEND_VAR\n メッセージ： C0091：基本機能ブロックリストの再帰：FB-> FB " }, 
{ "title" : "コンパイラエラーC0094 ", 
"url" : "_cds_error_c0094.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0094 ", 
"snippet" : "C0094 メッセージ ：オーバーライドされたメソッド '<メソッド名>'のインターフェイス '<関数ブロック名>'が宣言と一致しません 考えられるエラーの原因 ：最初のインターフェースのメソッドのシグニチャーが、最初のインターフェースによって拡張された2番目のインターフェースのメソッドのシグニチャーと一致しません。 エラー訂正 ：署名を揃えます。 エラーの例： PROGRAM PLC_PRG VAR xyz : XY2; END_VAR FUNCTION_BLOCK XY METHOD METH1 VAR_INPUT END_VAR FUNCTION_BLOCK XY2 EXTENDS XY...", 
"body" : "C0094 メッセージ ：オーバーライドされたメソッド '<メソッド名>'のインターフェイス '<関数ブロック名>'が宣言と一致しません 考えられるエラーの原因 ：最初のインターフェースのメソッドのシグニチャーが、最初のインターフェースによって拡張された2番目のインターフェースのメソッドのシグニチャーと一致しません。 エラー訂正 ：署名を揃えます。 エラーの例： PROGRAM PLC_PRG\nVAR\n xyz : XY2;\nEND_VAR\n\nFUNCTION_BLOCK XY\nMETHOD METH1\nVAR_INPUT\nEND_VAR\n\nFUNCTION_BLOCK XY2 EXTENDS XY\nMETHOD METH1\nVAR_INPUT\n iPar : BOOL;\nEND_VAR\n メッセージ： C0094：ベース「XY」のオーバーライドされたメソッド「METH1」のインターフェースが宣言と一致しません " }, 
{ "title" : "コンパイラエラーC0096 ", 
"url" : "_cds_error_c0096.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0096 ", 
"snippet" : "C0096 メッセージ ：EXTENDS-listで定義できる基本機能ブロックは1つだけです。 考えられるエラーの原因 ：EXTENDSリストに2つ以上の基本機能ブロックが定義されています。 エラー訂正 ：EXTENDSリストで基本機能ブロックを1つだけ定義してください。 エラーの例： PROGRAM PLC_PRG VAR fb : FB; END_VAR FUNCTION_BLOCK FB EXTENDS FB2, FB3 VAR END_VAR FUNCTION_BLOCK FB2 VAR END_VAR FUNCTION_BLOCK FB3 VAR END_VAR メッセージ： C00...", 
"body" : "C0096 メッセージ ：EXTENDS-listで定義できる基本機能ブロックは1つだけです。 考えられるエラーの原因 ：EXTENDSリストに2つ以上の基本機能ブロックが定義されています。 エラー訂正 ：EXTENDSリストで基本機能ブロックを1つだけ定義してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n fb : FB;\nEND_VAR\n\nFUNCTION_BLOCK FB EXTENDS FB2, FB3\nVAR\nEND_VAR\n\nFUNCTION_BLOCK FB2\nVAR\nEND_VAR\n\nFUNCTION_BLOCK FB3\nVAR\nEND_VAR\n メッセージ： C0096：EXTENDSリストで定義できる基本機能ブロックは1つだけです。 " }, 
{ "title" : "コンパイラエラーC0097 ", 
"url" : "_cds_error_c0097.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0097 ", 
"snippet" : "C0097 メッセージ ：関数ブロック '<関数ブロック名>'およびベース '<ベース関数ブロック名>'の変数 '<変数名>'の定義が重複しています 考えられるエラーの原因 ：変数は、関数ブロックとそのベースで同じ名前で宣言されています。 エラー訂正 ：異なる変数名を使用してください。 エラーの例： PROGRAM PLC_PRG VAR fb : FB; END_VAR FUNCTION_BLOCK FB EXTENDS FB2 VAR i : INT; END_VAR FUNCTION_BLOCK FB2 VAR i : INT; END_VAR メッセージ： C0097：機能ブロック '...", 
"body" : "C0097 メッセージ ：関数ブロック '<関数ブロック名>'およびベース '<ベース関数ブロック名>'の変数 '<変数名>'の定義が重複しています 考えられるエラーの原因 ：変数は、関数ブロックとそのベースで同じ名前で宣言されています。 エラー訂正 ：異なる変数名を使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n fb : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB EXTENDS FB2\nVAR\n i : INT;\nEND_VAR\n\n\nFUNCTION_BLOCK FB2\nVAR\n i : INT;\nEND_VAR\n メッセージ： C0097：機能ブロック 'FB'およびベース 'FB2'の変数 'i'の定義が重複しています " }, 
{ "title" : "コンパイラエラーC0098 ", 
"url" : "_cds_error_c0098.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0098 ", 
"snippet" : "C0098 メッセージ ：キーワード「FUNCTIONBLOCK」はサポートされなくなりました。代わりに「FUNCTION_BLOCK」を使用してください。 考えられるエラーの原因 ： 構文エラー エラー訂正 ：キーワード「FUNCTION_BLOCK」を使用します。 エラーの例： PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTIONBLOCK FB VAR END_VAR メッセージ： C0098：キーワード「FUNCTIONBLOCK」はサポートされなくなりました。代わりに「FUNCTION_BLOCK」を使用してください。...", 
"body" : "C0098 メッセージ ：キーワード「FUNCTIONBLOCK」はサポートされなくなりました。代わりに「FUNCTION_BLOCK」を使用してください。 考えられるエラーの原因 ： 構文エラー エラー訂正 ：キーワード「FUNCTION_BLOCK」を使用します。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\nFUNCTIONBLOCK FB\nVAR\nEND_VAR\n メッセージ： C0098：キーワード「FUNCTIONBLOCK」はサポートされなくなりました。代わりに「FUNCTION_BLOCK」を使用してください。 " }, 
{ "title" : "コンパイラエラーC0099（コンパイラバージョン<3.5.7.0） ", 
"url" : "_cds_error_c0099.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0099（コンパイラバージョン<3.5.7.0） ", 
"snippet" : "C0099 メッセージ ：ローカルで定義された列挙はサポートされなくなりました。代わりにDUT定義を使用してください。 考えられるエラーの原因 ：ローカル列挙宣言が、これをサポートしていないコンパイラバージョンと一緒に使用されました。 エラー訂正 ：新しいバージョンのコンパイラを使用するか、DUTで列挙を定義してください。 エラーの例： エラーの例： PROGRAM PLC_PRG VAR localEnumVar : (RED, GREEN, BLUE) := RED; END_VAR メッセージ： C0099：ローカルで定義された列挙はサポートされなくなりました。代わりにDUT定義を使用し...", 
"body" : "C0099 メッセージ ：ローカルで定義された列挙はサポートされなくなりました。代わりにDUT定義を使用してください。 考えられるエラーの原因 ：ローカル列挙宣言が、これをサポートしていないコンパイラバージョンと一緒に使用されました。 エラー訂正 ：新しいバージョンのコンパイラを使用するか、DUTで列挙を定義してください。 エラーの例： エラーの例： PROGRAM PLC_PRG\nVAR\n localEnumVar : (RED, GREEN, BLUE) := RED;\nEND_VAR\n メッセージ： C0099：ローカルで定義された列挙はサポートされなくなりました。代わりにDUT定義を使用してください。 " }, 
{ "title" : "コンパイラエラーC0101 ", 
"url" : "_cds_error_c0101.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0101 ", 
"snippet" : "C0101 メッセージ ：データ再帰： '<再帰>' 考えられるエラーの原因 ：2つの機能ブロックにわたる再帰的なデータ初期化 エラー訂正 ：データ初期化の再帰を避けてください。 エラーの例： PROGRAM PLC_PRG VAR inst0 : FB1; END_VAR FUNCTION_BLOCK FB1 VAR inst1 : FB2; END_VAR FUNCTION_BLOCK FB2 VAR inst2 : FB1; END_VAR メッセージ： C0101：データ再帰：FB1-> FB2-> FB1...", 
"body" : "C0101 メッセージ ：データ再帰： '<再帰>' 考えられるエラーの原因 ：2つの機能ブロックにわたる再帰的なデータ初期化 エラー訂正 ：データ初期化の再帰を避けてください。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst0 : FB1;\nEND_VAR\n\nFUNCTION_BLOCK FB1\nVAR\n inst1 : FB2;\nEND_VAR\n\nFUNCTION_BLOCK FB2\nVAR\n inst2 : FB1;\nEND_VAR\n メッセージ： C0101：データ再帰：FB1-> FB2-> FB1 " }, 
{ "title" : "コンパイラエラーC0102 ", 
"url" : "_cds_error_c0102.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0102 ", 
"snippet" : "C0102 メッセージ : 保持メモリが不足しています: 変数 '<変数名>'、<バイト サイズ> バイト。 考えられるエラーの原因 ：PLCで使用可能なよりも多くの保持メモリが使用されています。インクリメンタルビルドが原因で、保持メモリが断片化しすぎている可能性もあります。 エラー訂正 ： 使用 綺麗 メモリを断片化するため。これにより、次のビルドですべてのデータが強制的に再割り当てされます。...", 
"body" : "C0102 メッセージ : 保持メモリが不足しています: 変数 '<変数名>'、<バイト サイズ> バイト。 考えられるエラーの原因 ：PLCで使用可能なよりも多くの保持メモリが使用されています。インクリメンタルビルドが原因で、保持メモリが断片化しすぎている可能性もあります。 エラー訂正 ： 使用 綺麗 メモリを断片化するため。これにより、次のビルドですべてのデータが強制的に再割り当てされます。 " }, 
{ "title" : "コンパイラ エラー C0103 ", 
"url" : "_cds_error_c0103.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ エラー C0103 ", 
"snippet" : "C0103 メッセージ : 保持メモリが不足しています: 変数 '<変数名>'、<バイト サイズ> バイト。 (最大の連続メモリ ギャップ {2}) 考えられるエラーの原因 ：PLCで使用可能なよりも多くの保持メモリが使用されています。インクリメンタルビルドが原因で、保持メモリが断片化しすぎている可能性もあります。 エラー訂正 ： 使用 綺麗 メモリを断片化するため。これにより、次のビルドですべてのデータが強制的に再割り当てされます。...", 
"body" : "C0103 メッセージ : 保持メモリが不足しています: 変数 '<変数名>'、<バイト サイズ> バイト。 (最大の連続メモリ ギャップ {2}) 考えられるエラーの原因 ：PLCで使用可能なよりも多くの保持メモリが使用されています。インクリメンタルビルドが原因で、保持メモリが断片化しすぎている可能性もあります。 エラー訂正 ： 使用 綺麗 メモリを断片化するため。これにより、次のビルドですべてのデータが強制的に再割り当てされます。 " }, 
{ "title" : "コンパイラエラーC0104 ", 
"url" : "_cds_error_c0104.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0104 ", 
"snippet" : "C0104 メッセージ ： 'グローバルデータメモリが不足しています：変数' <変数名> '、<バイトサイズ>バイト。 考えられるエラーの原因 ：PLCで使用可能なメモリよりも多くのデータメモリが使用されています。インクリメンタルビルドが原因でメモリが断片化しすぎている可能性もあります。 エラー訂正 ： 使用 綺麗 メモリを断片化するため。これにより、次のビルドですべてのデータが強制的に再割り当てされます。...", 
"body" : "C0104 メッセージ ： 'グローバルデータメモリが不足しています：変数' <変数名> '、<バイトサイズ>バイト。 考えられるエラーの原因 ：PLCで使用可能なメモリよりも多くのデータメモリが使用されています。インクリメンタルビルドが原因でメモリが断片化しすぎている可能性もあります。 エラー訂正 ： 使用 綺麗 メモリを断片化するため。これにより、次のビルドですべてのデータが強制的に再割り当てされます。 " }, 
{ "title" : "コンパイラ エラー C0106 ", 
"url" : "_cds_error_c0106.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ エラー C0106 ", 
"snippet" : "C0106 メッセージ : 保持メモリが不足しています: 変数 '<変数名>'、<バイト サイズ> バイト。 (最大連続メモリギャップ <バイトサイズ> バイト) 考えられるエラー原因 : PLC で使用できるよりも多くの保持メモリが使用されています。インクリメンタル コンパイルが原因で、保持メモリが断片化しすぎている可能性もあります。 エラー訂正 ： 使用 綺麗 メモリを断片化するためのコマンド。これにより、次のコンパイル時にすべてのデータとコードが強制的に再割り当てされます。...", 
"body" : "C0106 メッセージ : 保持メモリが不足しています: 変数 '<変数名>'、<バイト サイズ> バイト。 (最大連続メモリギャップ <バイトサイズ> バイト) 考えられるエラー原因 : PLC で使用できるよりも多くの保持メモリが使用されています。インクリメンタル コンパイルが原因で、保持メモリが断片化しすぎている可能性もあります。 エラー訂正 ： 使用 綺麗 メモリを断片化するためのコマンド。これにより、次のコンパイル時にすべてのデータとコードが強制的に再割り当てされます。 " }, 
{ "title" : "コンパイラエラーC0114 ", 
"url" : "_cds_error_c0114.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0114 ", 
"snippet" : "C0114 メッセージ ：「JMP」の宛先<ジャンプラベル>が無効です 考えられるエラーの原因 ：JMP宛先の構文エラーまたは誤植 エラー訂正 ：誤植または構文エラーを修正します。 エラーの例： PROGRAM PLC_PRG VAR END_VAR JMP 0; メッセージ： C0114：「JMP」の宛先0が無効です...", 
"body" : "C0114 メッセージ ：「JMP」の宛先<ジャンプラベル>が無効です 考えられるエラーの原因 ：JMP宛先の構文エラーまたは誤植 エラー訂正 ：誤植または構文エラーを修正します。 エラーの例： PROGRAM PLC_PRG\nVAR\nEND_VAR\nJMP 0;\n メッセージ： C0114：「JMP」の宛先0が無効です " }, 
{ "title" : "コンパイラエラーC0115 ", 
"url" : "_cds_error_c0115.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0115 ", 
"snippet" : "C0115 メッセージ ：条件付き呼び出しの2番目のパラメーター（???? ALWAYS CALC ????）は、有効な呼び出しステートメントである必要があります。 エラー訂正 ：条件付き???? CALC ???の2番目のパラメーターで、関数、メソッド、または関数ブロックの呼び出しを指定します。電話。 エラーの例： PROGRAM PLC_PRG VAR condition : BOOL; END_VAR CALC(condition, 1+2); メッセージ： C0115：条件付き呼び出しの2番目のパラメーターは、有効な呼び出しステートメントである必要があります。 エラー訂正： CALC(...", 
"body" : "C0115 メッセージ ：条件付き呼び出しの2番目のパラメーター（???? ALWAYS CALC ????）は、有効な呼び出しステートメントである必要があります。 エラー訂正 ：条件付き???? CALC ???の2番目のパラメーターで、関数、メソッド、または関数ブロックの呼び出しを指定します。電話。 エラーの例： PROGRAM PLC_PRG\nVAR\n condition : BOOL;\nEND_VAR\nCALC(condition, 1+2);\n メッセージ： C0115：条件付き呼び出しの2番目のパラメーターは、有効な呼び出しステートメントである必要があります。 エラー訂正： CALC(condition, MyFunction(1,2)) " }, 
{ "title" : "コンパイラエラーC0116 ", 
"url" : "_cds_error_c0116.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0116 ", 
"snippet" : "C0116 メッセージ ：ラベル '<ジャンプラベル>'は重複しています 考えられるエラーの原因 ：ラベルは複数回定義されています。 エラー訂正 ：各ラベルを1回だけ定義します。 エラーの例： PROGRAM PLC_PRG VAR END_VAR JMP label; label: label: メッセージ： C0116：ラベル「LABEL」は重複しています...", 
"body" : "C0116 メッセージ ：ラベル '<ジャンプラベル>'は重複しています 考えられるエラーの原因 ：ラベルは複数回定義されています。 エラー訂正 ：各ラベルを1回だけ定義します。 エラーの例： PROGRAM PLC_PRG\nVAR\nEND_VAR\nJMP label;\nlabel:\n\nlabel:\n メッセージ： C0116：ラベル「LABEL」は重複しています " }, 
{ "title" : "コンパイラエラーC0117 ", 
"url" : "_cds_error_c0117.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0117 ", 
"snippet" : "C0117 メッセージ ：「JMP」ステートメントの範囲内にそのようなラベル「<ジャンプラベル>」はありません 考えられるエラーの原因 ：存在しないラベルにジャンプします。 エラー訂正 ：宛先として指定するラベルを定義します。 エラーの例： PROGRAM PLC_PRG VAR END_VAR JMP A; メッセージ： C0117：「JMP」ステートメントのスコープ内にそのようなラベル「A」はありません。...", 
"body" : "C0117 メッセージ ：「JMP」ステートメントの範囲内にそのようなラベル「<ジャンプラベル>」はありません 考えられるエラーの原因 ：存在しないラベルにジャンプします。 エラー訂正 ：宛先として指定するラベルを定義します。 エラーの例： PROGRAM PLC_PRG\nVAR\nEND_VAR\nJMP A;\n メッセージ： C0117：「JMP」ステートメントのスコープ内にそのようなラベル「A」はありません。 " }, 
{ "title" : "コンパイラエラーC0118 ", 
"url" : "_cds_error_c0118.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0118 ", 
"snippet" : "C0118 メッセージ ：ラベル '<ジャンプラベル>'は参照されていません。 考えられるエラーの原因 ：参照されていないジャンプラベルが定義されています。 エラー訂正 ：未使用のジャンプラベルを削除します。 エラーの例： PROGRAM PLC_PRG VAR END_VAR LABEL: メッセージ： C0118：ラベル「LABEL」が参照されていません...", 
"body" : "C0118 メッセージ ：ラベル '<ジャンプラベル>'は参照されていません。 考えられるエラーの原因 ：参照されていないジャンプラベルが定義されています。 エラー訂正 ：未使用のジャンプラベルを削除します。 エラーの例： PROGRAM PLC_PRG\nVAR\nEND_VAR\nLABEL:\n メッセージ： C0118：ラベル「LABEL」が参照されていません " }, 
{ "title" : "コンパイラエラーC0119 ", 
"url" : "_cds_error_c0119.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0119 ", 
"snippet" : "C0119 メッセージ ：「FB_init」-関数ブロックまたは構造体のメソッドには、BOOL型の「bInitRetains」と「bInCopyCode」の2つの入力が必要です。 考えられるエラーの原因 ：タイプBOOLの入力「bInitRetains」と「bInCopyCode」の一方または両方が欠落しています。 エラー訂正 ：欠落している入力を定義します。 エラーの例： PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTION_BLOCK FB METHOD FB_init VAR_INPUT END_VAR メッセージ： C0119：「FB_init...", 
"body" : "C0119 メッセージ ：「FB_init」-関数ブロックまたは構造体のメソッドには、BOOL型の「bInitRetains」と「bInCopyCode」の2つの入力が必要です。 考えられるエラーの原因 ：タイプBOOLの入力「bInitRetains」と「bInCopyCode」の一方または両方が欠落しています。 エラー訂正 ：欠落している入力を定義します。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB\nMETHOD FB_init\nVAR_INPUT\nEND_VAR\n メッセージ： C0119：「FB_init」-関数ブロックまたは構造体のメソッドには、BOOL型の「bInitRetains」と「bInCopyCode」の2つの入力が必要です。 エラー訂正： METHOD FB_init\nVAR_INPUT\n bInitRetains : BOOL;\n bInCopyCode : BOOL;\nEND_VAR " }, 
{ "title" : "コンパイラエラーC0120 ", 
"url" : "_cds_error_c0120.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0120 ", 
"snippet" : "C0120 メッセージ ： 'FB_Exit'-関数ブロックまたは構造体のメソッドには、BOOL型の入力' bInCopyCode 'が必要です。 考えられる原因 : 入力 bInCopyCode タイプの BOOL 不足している。 エラー訂正 ：入力を定義します。 エラーの例： PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTION_BLOCK FB METHOD FB_exit VAR_INPUT END_VAR メッセージ： C0120：「FB_Exit」-関数ブロックまたは構造体のメソッドには、BOOL型の入力「bInCopyCode」が必要です...", 
"body" : "C0120 メッセージ ： 'FB_Exit'-関数ブロックまたは構造体のメソッドには、BOOL型の入力' bInCopyCode 'が必要です。 考えられる原因 : 入力 bInCopyCode タイプの BOOL 不足している。 エラー訂正 ：入力を定義します。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB\nMETHOD FB_exit\nVAR_INPUT\nEND_VAR\n メッセージ： C0120：「FB_Exit」-関数ブロックまたは構造体のメソッドには、BOOL型の入力「bInCopyCode」が必要です。 エラー訂正： METHOD FB_exit\nVAR_INPUT\n bInCopyCode : BOOL;\nEND_VAR " }, 
{ "title" : "コンパイラエラーC0122 ", 
"url" : "_cds_error_c0122.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0122 ", 
"snippet" : "C0122 メッセージ ：式 'SUPER'はこのコンテキストでは許可されていません 考えられるエラーの原因 ：「SUPER ^」は、派生関数ブロックの外部で使用されます。 エラー訂正 ：機能ブロックでのみ「SUPER ^」を使用してください。 エラーの例： PROGRAM PLC_PRG VAR END_VAR SUPER^.METH(TRUE, TRUE); メッセージ： C0122：式 'SUPER'はこのコンテキストでは許可されていません...", 
"body" : "C0122 メッセージ ：式 'SUPER'はこのコンテキストでは許可されていません 考えられるエラーの原因 ：「SUPER ^」は、派生関数ブロックの外部で使用されます。 エラー訂正 ：機能ブロックでのみ「SUPER ^」を使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nSUPER^.METH(TRUE, TRUE);\n メッセージ： C0122：式 'SUPER'はこのコンテキストでは許可されていません " }, 
{ "title" : "コンパイラエラーC0124 ", 
"url" : "_cds_error_c0124.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0124 ", 
"snippet" : "C0124 メッセージ ：「初期化」は列挙型の有効な初期化ではありません 考えられるエラーの原因 ：ANY_INTではないデータ型が列挙型の初期化に使用されます。 エラー訂正 ：列挙型の初期化にはANY_INTのみを使用してください。 エラーの例： PROGRAM PLC_PRG VAR inst : DUT; END_VAR TYPE DUT : ( enum_member := 1.5 ) DWORD; END_TYPE メッセージ： C0032：タイプ「LREAL」をタイプ「DUT」に変換できません C0124：「初期化」は列挙型の有効な初期化ではありません...", 
"body" : "C0124 メッセージ ：「初期化」は列挙型の有効な初期化ではありません 考えられるエラーの原因 ：ANY_INTではないデータ型が列挙型の初期化に使用されます。 エラー訂正 ：列挙型の初期化にはANY_INTのみを使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : DUT;\nEND_VAR\n\nTYPE DUT :\n(\n enum_member := 1.5\n) DWORD;\nEND_TYPE\n メッセージ： C0032：タイプ「LREAL」をタイプ「DUT」に変換できません C0124：「初期化」は列挙型の有効な初期化ではありません " }, 
{ "title" : "コンパイラエラーC0125 ", 
"url" : "_cds_error_c0125.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0125 ", 
"snippet" : "C0125 メッセージ ：定数<定数値>は複数の列挙に割り当てられます。 考えられるエラーの原因 ：同じ値が2つ以上の列挙に割り当てられます。 エラー訂正 ：列挙型に異なる値を割り当てます。 エラーの例： PROGRAM PLC_PRG VAR inst : DUT; END_VAR TYPE DUT : ( enum_member := 0, enum_member2 := 0 ); END_TYPE メッセージ： C0125：定数0が複数の列挙に割り当てられています。...", 
"body" : "C0125 メッセージ ：定数<定数値>は複数の列挙に割り当てられます。 考えられるエラーの原因 ：同じ値が2つ以上の列挙に割り当てられます。 エラー訂正 ：列挙型に異なる値を割り当てます。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : DUT;\nEND_VAR\n\nTYPE DUT :\n(\n enum_member := 0,\n enum_member2 := 0\n);\nEND_TYPE\n メッセージ： C0125：定数0が複数の列挙に割り当てられています。 " }, 
{ "title" : "コンパイラエラーC0126 ", 
"url" : "_cds_error_c0126.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0126 ", 
"snippet" : "C0126 メッセージ ：タイプ '<データタイプ>'の変数には正確に1つのインデックスが必要です 考えられるエラーの原因 ：1つのインデックスを持つ変数に複数のインデックスが割り当てられます。 エラー訂正 ：インデックスを1つだけ割り当てます。 エラーの例： PROGRAM PLC_PRG VAR pi : POINTER TO INT; END_VAR pi[0,1] := 0; メッセージ： C0126：タイプ 'POINTER TOINT'の変数には正確に1つのインデックスが必要です エラー訂正： pi[0] := 0;...", 
"body" : "C0126 メッセージ ：タイプ '<データタイプ>'の変数には正確に1つのインデックスが必要です 考えられるエラーの原因 ：1つのインデックスを持つ変数に複数のインデックスが割り当てられます。 エラー訂正 ：インデックスを1つだけ割り当てます。 エラーの例： PROGRAM PLC_PRG\nVAR\n pi : POINTER TO INT;\nEND_VAR\npi[0,1] := 0;\n メッセージ： C0126：タイプ 'POINTER TOINT'の変数には正確に1つのインデックスが必要です エラー訂正： pi[0] := 0; " }, 
{ "title" : "コンパイラエラーC0130 ", 
"url" : "_cds_error_c0130.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0130 ", 
"snippet" : "C0130 メッセージ ：オブジェクト '<オブジェクト名>'括弧なしで参照 '（）' 考えられるエラーの原因 ：メソッドは括弧なしで参照されます。 エラー訂正 ：常に括弧を使用してメソッドを参照します。 エラーの例： PROGRAM PLC_PRG VAR inst : FB; END_VAR inst.METH1 メッセージ： C0130：かっこなしで参照されるメソッド 'METH1' '（）' エラー訂正： inst.METH1();...", 
"body" : "C0130 メッセージ ：オブジェクト '<オブジェクト名>'括弧なしで参照 '（）' 考えられるエラーの原因 ：メソッドは括弧なしで参照されます。 エラー訂正 ：常に括弧を使用してメソッドを参照します。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\ninst.METH1\n メッセージ： C0130：かっこなしで参照されるメソッド 'METH1' '（）' エラー訂正： inst.METH1(); " }, 
{ "title" : "コンパイラエラーC0131 ", 
"url" : "_cds_error_c0131.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0131 ", 
"snippet" : "C0131 メッセージ ： '<value>'は 'ADR'のオペランドとして許可されていません 考えられるエラーの原因 ：定数がオペランドとして演算子ADRに渡されます。 エラー訂正 ：ADRには有効なオペランドのみを使用してください。 エラーの例： PROGRAM PLC_PRG VAR i : INT; pt : POINTER TO INT; END_VAR pt := ADR(1); メッセージ： C0131：「1」は「ADR」のオペランドとして許可されていません エラー訂正： pt := ADR(i);...", 
"body" : "C0131 メッセージ ： '<value>'は 'ADR'のオペランドとして許可されていません 考えられるエラーの原因 ：定数がオペランドとして演算子ADRに渡されます。 エラー訂正 ：ADRには有効なオペランドのみを使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\n pt : POINTER TO INT;\nEND_VAR\n\npt := ADR(1);\n メッセージ： C0131：「1」は「ADR」のオペランドとして許可されていません エラー訂正： pt := ADR(i); " }, 
{ "title" : "コンパイラエラーC0132 ", 
"url" : "_cds_error_c0132.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0132 ", 
"snippet" : "C0132 メッセージ ：終了する囲みループはありません 考えられるエラーの原因 ：EXITはループの外側で使用されます。 エラー訂正 ：ループ内でのみEXITを使用してください。 エラーの例： PROGRAM PLC_PRG VAR END_VAR EXIT ; メッセージ： C0132：終了する囲みループがありません...", 
"body" : "C0132 メッセージ ：終了する囲みループはありません 考えられるエラーの原因 ：EXITはループの外側で使用されます。 エラー訂正 ：ループ内でのみEXITを使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nEXIT\n;\n メッセージ： C0132：終了する囲みループがありません " }, 
{ "title" : "コンパイラエラーC0136 ", 
"url" : "_cds_error_c0136.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0136 ", 
"snippet" : "C0136 メッセージ ：名前のあいまいな使用 '<変数名>' 考えられるエラーの原因 ：変数は複数のGVLで宣言されています。 エラー訂正 ：変数を目的のGVLで修飾します。 エラーの例： PROGRAM PLC_PRG VAR j : INT := g_i; END_VAR GVL1: VAR_GLOBAL g_i : INT; END_VAR GVL2: VAR_GLOBAL g_i : INT; END_VAR --> C0136: nicht eindeutige Verwendung des Namens 'g_i' エラー訂正： Beispiel: j : INT := GVL1...", 
"body" : "C0136 メッセージ ：名前のあいまいな使用 '<変数名>' 考えられるエラーの原因 ：変数は複数のGVLで宣言されています。 エラー訂正 ：変数を目的のGVLで修飾します。 エラーの例： PROGRAM PLC_PRG\nVAR\n j : INT := g_i;\nEND_VAR\n\nGVL1:\nVAR_GLOBAL\n g_i : INT;\nEND_VAR\n\nGVL2:\nVAR_GLOBAL\n g_i : INT;\nEND_VAR\n\n--> C0136: nicht eindeutige Verwendung des Namens 'g_i' エラー訂正： Beispiel:\nj : INT := GVL1.g_i; このエラーが発生すると、メッセージビュー（C0181）に複数回使用の位置がすべて出力されます。 " }, 
{ "title" : "コンパイラエラーC0138 ", 
"url" : "_cds_error_c0138.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0138 ", 
"snippet" : "C0138 メッセージ ：POUのインスタンス化に一致する「FB_Init」メソッドが見つかりません。 考えられるエラーの原因 ： 番号 FB_Init 渡されたパラメータを受け入れるメソッドが存在します。 エラー訂正 ：どの引数を確認する FB_Init 渡された引数を受け取って調整する必要があります。 エラーの例： PROGRAM PLC_PRG VAR myPOU : POU(arg1 := 1, arg2 := 2); END_VAR メッセージ： C0138：POUのインスタンス化に一致する「FB_Init」メソッドが見つかりません。...", 
"body" : "C0138 メッセージ ：POUのインスタンス化に一致する「FB_Init」メソッドが見つかりません。 考えられるエラーの原因 ： 番号 FB_Init 渡されたパラメータを受け入れるメソッドが存在します。 エラー訂正 ：どの引数を確認する FB_Init 渡された引数を受け取って調整する必要があります。 エラーの例： PROGRAM PLC_PRG\nVAR\n myPOU : POU(arg1 := 1, arg2 := 2);\nEND_VAR\n メッセージ： C0138：POUのインスタンス化に一致する「FB_Init」メソッドが見つかりません。 " }, 
{ "title" : "コンパイラエラーC0139 ", 
"url" : "_cds_error_c0139.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0139 ", 
"snippet" : "C0139 メッセージ ：コード<code>は効果がありません。これは意図ですか？ 考えられるエラーの原因 ：書かれたコードは構文的に正しいですが、何もしません。 エラー訂正 ：目的のあるコードを書く。 エラーの例： PROGRAM PLC_PRG VAR i : INT; END_VAR i; メッセージ： C0139：コード「i」は効果がありません。これは意図ですか？...", 
"body" : "C0139 メッセージ ：コード<code>は効果がありません。これは意図ですか？ 考えられるエラーの原因 ：書かれたコードは構文的に正しいですが、何もしません。 エラー訂正 ：目的のあるコードを書く。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\n\ni;\n メッセージ： C0139：コード「i」は効果がありません。これは意図ですか？ " }, 
{ "title" : "コンパイラエラーC0140 ", 
"url" : "_cds_error_c0140.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0140 ", 
"snippet" : "C0140 メッセージ ：参照割り当ては、参照タイプの変数にのみ許可されます 考えられるエラーの原因 ：参照型として定義されていない変数に参照値を割り当てようとしました。 エラー訂正 ：変数を参照型として定義します。 エラーの例： PROGRAM PLC_PRG VAR i : INT; I_r : INT; END_VAR I_r REF= i; メッセージ： C0140：参照の割り当ては、参照タイプの変数にのみ許可されます エラー訂正： I_r : REFERENCE TO INT;...", 
"body" : "C0140 メッセージ ：参照割り当ては、参照タイプの変数にのみ許可されます 考えられるエラーの原因 ：参照型として定義されていない変数に参照値を割り当てようとしました。 エラー訂正 ：変数を参照型として定義します。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\n I_r : INT;\nEND_VAR\n\nI_r REF= i;\n メッセージ： C0140：参照の割り当ては、参照タイプの変数にのみ許可されます エラー訂正： I_r : REFERENCE TO INT; " }, 
{ "title" : "コンパイラエラーC0141 ", 
"url" : "_cds_error_c0141.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0141 ", 
"snippet" : "C0141 メッセージ ：参照割り当てには書き込みアクセス可能な変数が必要です 考えられるエラーの原因 ：定数が参照割り当てに割り当てられます。 エラー訂正 ：書き込み可能な変数を割り当てます。 エラーの例： PROGRAM PLC_PRG VAR i : INT; I_r : REFERENCE TO INT; END_VAR I_r REF= 314; メッセージ： C0141：参照割り当てには書き込みアクセス可能な変数が必要です エラー訂正： I_r REF= i;...", 
"body" : "C0141 メッセージ ：参照割り当てには書き込みアクセス可能な変数が必要です 考えられるエラーの原因 ：定数が参照割り当てに割り当てられます。 エラー訂正 ：書き込み可能な変数を割り当てます。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\n I_r : REFERENCE TO INT;\nEND_VAR\n\nI_r REF= 314;\n メッセージ： C0141：参照割り当てには書き込みアクセス可能な変数が必要です エラー訂正： I_r REF= i; " }, 
{ "title" : "コンパイラエラーC0142 ", 
"url" : "_cds_error_c0142.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0142 ", 
"snippet" : "C0142 メッセージ ：「<変数名>」という名前のローカル変数は、「<pouname>」ですでに定義されています 考えられるエラーの原因 ：同じ変数名が2回使用されています。 エラー訂正 ：異なる変数名を使用してください。 エラーの例： PROGRAM PLC_PRG VAR i : INT; i : INT; END_VAR メッセージ： C0142：「i」という名前のローカル変数はすでに「PLC_PRG」で定義されています...", 
"body" : "C0142 メッセージ ：「<変数名>」という名前のローカル変数は、「<pouname>」ですでに定義されています 考えられるエラーの原因 ：同じ変数名が2回使用されています。 エラー訂正 ：異なる変数名を使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\n i : INT;\nEND_VAR\n メッセージ： C0142：「i」という名前のローカル変数はすでに「PLC_PRG」で定義されています " }, 
{ "title" : "コンパイラエラーC0143 ", 
"url" : "_cds_error_c0143.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0143 ", 
"snippet" : "C0143 メッセージ ：プロパティ '<プロパティ名>'は、getアクセサーがないため、このコンテキストでは使用できません。 考えられるエラーの原因 ：プロパティにはGetアクセス権がありません。 エラー訂正 ：プロパティにGetアクセス定義があることを確認してください。 エラーの例： PROGRAM PLC_PRG VAR i : INT; inst: FB; END_VAR i := inst.Prop; FUNCTION_BLOCK FB VAR END_VAR PROPERTY Prop : INT Set; メッセージ： C0143：プロパティ 'Prop'は、getアクセサーがな...", 
"body" : "C0143 メッセージ ：プロパティ '<プロパティ名>'は、getアクセサーがないため、このコンテキストでは使用できません。 考えられるエラーの原因 ：プロパティにはGetアクセス権がありません。 エラー訂正 ：プロパティにGetアクセス定義があることを確認してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\n inst: FB;\nEND_VAR\n\ni := inst.Prop;\n\nFUNCTION_BLOCK FB\nVAR\nEND_VAR\n\nPROPERTY Prop : INT\nSet;\n メッセージ： C0143：プロパティ 'Prop'は、getアクセサーがないため、このコンテキストでは使用できません " }, 
{ "title" : "コンパイラエラーC0144 ", 
"url" : "_cds_error_c0144.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0144 ", 
"snippet" : "C0144 メッセージ ：継承は、機能ブロック、インターフェイス、および構造でのみ許可されます 考えられるエラーの原因 ：継承を許可しないオブジェクトで継承を使用しようとしました。 エラー訂正 ： つかいます EXTENDS 機能ブロック、インタフェース、および構造のみ。 エラーの例： PROGRAM PLC_PRG VAR inst : DUT_1; END_VAR TYPE DUT: ( enum_member := 0 ); END_TYPE TYPE DUT_1 EXTENDS DUT: ( enum_memberX := 0 ); END_TYPE メッセージ： C0144：継承は、...", 
"body" : "C0144 メッセージ ：継承は、機能ブロック、インターフェイス、および構造でのみ許可されます 考えられるエラーの原因 ：継承を許可しないオブジェクトで継承を使用しようとしました。 エラー訂正 ： つかいます EXTENDS 機能ブロック、インタフェース、および構造のみ。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : DUT_1;\nEND_VAR\n\nTYPE DUT:\n(\n enum_member := 0\n);\nEND_TYPE\n\nTYPE DUT_1 EXTENDS DUT:\n(\n enum_memberX := 0\n);\nEND_TYPE\n メッセージ： C0144：継承は、機能ブロック、インターフェイス、および構造でのみ許可されます " }, 
{ "title" : "コンパイラエラーC0145 ", 
"url" : "_cds_error_c0145.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0145 ", 
"snippet" : "C0145 メッセージ ：インタフェースは機能ブロックによってのみ実装することができます 考えられるエラーの原因 ：機能ブロックの外部にインターフェースを実装しようとしました。 エラー訂正 ：機能ブロックにのみインターフェースを実装します。 エラーの例： PROGRAM PLC_PRG VAR END_VAR POU(); FUNCTION POU IMPLEMENTS ITF VAR END_VAR メッセージ： C0145：インターフェースは機能ブロックによってのみ実装できます...", 
"body" : "C0145 メッセージ ：インタフェースは機能ブロックによってのみ実装することができます 考えられるエラーの原因 ：機能ブロックの外部にインターフェースを実装しようとしました。 エラー訂正 ：機能ブロックにのみインターフェースを実装します。 エラーの例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nPOU();\n\nFUNCTION POU IMPLEMENTS ITF\nVAR\nEND_VAR\n メッセージ： C0145：インターフェースは機能ブロックによってのみ実装できます " }, 
{ "title" : "コンパイラエラーC0149 ", 
"url" : "_cds_error_c0149.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0149 ", 
"snippet" : "C0149 メッセージ ：変数宣言はインターフェースでは許可されていません 考えられるエラーの原因 ：インターフェースで変数を定義しようとしました。 エラー訂正 ：インターフェースで変数を定義しないでください。 エラーの例： PROGRAM PLC_PRG VAR inst : ITF; END_VAR INTERFACE ITF VAR_INPUT i : INT; END_VAR メッセージ： C0149：変数宣言はインターフェイスでは許可されていません...", 
"body" : "C0149 メッセージ ：変数宣言はインターフェースでは許可されていません 考えられるエラーの原因 ：インターフェースで変数を定義しようとしました。 エラー訂正 ：インターフェースで変数を定義しないでください。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : ITF;\nEND_VAR\n\nINTERFACE ITF\nVAR_INPUT\n i : INT;\nEND_VAR\n メッセージ： C0149：変数宣言はインターフェイスでは許可されていません " }, 
{ "title" : "コンパイラエラーC0161 ", 
"url" : "_cds_error_c0161.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0161 ", 
"snippet" : "C0161 メッセージ ：配列の境界<配列境界>は定数値ではありません 考えられるエラーの原因 ：変数は配列境界として指定されます。 エラー訂正 ：配列の境界には定数を使用します。 エラーの例： PROGRAM PLC_PRG VAR i : INT := 3; arr1 : ARRAY[1..i] OF INT; END_VAR メッセージ： C0161：配列の境界線 'i'が定数値ではありません エラー訂正： arr1 : ARRAY[1..3] OF INT;...", 
"body" : "C0161 メッセージ ：配列の境界<配列境界>は定数値ではありません 考えられるエラーの原因 ：変数は配列境界として指定されます。 エラー訂正 ：配列の境界には定数を使用します。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT := 3;\n arr1 : ARRAY[1..i] OF INT;\nEND_VAR\n メッセージ： C0161：配列の境界線 'i'が定数値ではありません エラー訂正： arr1 : ARRAY[1..3] OF INT; " }, 
{ "title" : "コンパイラエラーC0162 ", 
"url" : "_cds_error_c0162.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0162 ", 
"snippet" : "C0162 メッセージ ：配列初期化の数<配列値の数>は定数値ではありません 考えられるエラーの原因 ：初期化 [Wert1,AnzahlWert2(Wert2)] の定数でのみ機能します AnzahlWert2 。 エラー訂正 ：定数のみを使用してください。 エラーの例： PROGRAM PLC_PRG VAR i : INT := 3; arr1 : ARRAY[1..4] OF INT := [1,i(7)]; END_VAR メッセージ： C0162：配列初期化の数値「i」が定数値ではありません エラー訂正： arr1 : ARRAY[1..4] OF INT := [1,3(7)];...", 
"body" : "C0162 メッセージ ：配列初期化の数<配列値の数>は定数値ではありません 考えられるエラーの原因 ：初期化 [Wert1,AnzahlWert2(Wert2)] の定数でのみ機能します AnzahlWert2 。 エラー訂正 ：定数のみを使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT := 3;\n arr1 : ARRAY[1..4] OF INT := [1,i(7)];\nEND_VAR\n メッセージ： C0162：配列初期化の数値「i」が定数値ではありません エラー訂正： arr1 : ARRAY[1..4] OF INT := [1,3(7)]; " }, 
{ "title" : "コンパイラエラーC0164 ", 
"url" : "_cds_error_c0164.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0164 ", 
"snippet" : "C0164 メッセージ ：POU <name>は出力<name>に書き込み、いくつかのタスクで呼び出されます。 考えられるエラーの原因 ：デバイス設定 codegenerator\\check-multiple-task-output-write が設定され、複数のタスクが同じ出力にアクセスします。 エラー訂正 ：複数のタスクで出力を変更するプログラムを呼び出さないでください。 エラーの例： PROGRAM PLC_PRG VAR Output AT %QB7 : BYTE END_VAR Output := 0; メッセージ： C0164：POU PLC_PRGは出力QB7に書き込み、いくつか...", 
"body" : "C0164 メッセージ ：POU <name>は出力<name>に書き込み、いくつかのタスクで呼び出されます。 考えられるエラーの原因 ：デバイス設定 codegenerator\\check-multiple-task-output-write が設定され、複数のタスクが同じ出力にアクセスします。 エラー訂正 ：複数のタスクで出力を変更するプログラムを呼び出さないでください。 エラーの例： PROGRAM PLC_PRG\nVAR\n Output AT %QB7 : BYTE\nEND_VAR\n\nOutput := 0;\n メッセージ： C0164：POU PLC_PRGは出力QB7に書き込み、いくつかのタスクで呼び出されます。 " }, 
{ "title" : "コンパイラエラーC0165 ", 
"url" : "_cds_error_c0165.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0165 ", 
"snippet" : "C0165 メッセージ ：アドレス '<address>'にマップされる変数 '<variable name>'は、さまざまなタスクで書き込まれます。 考えられるエラーの原因 ：デバイス設定 codegenerator\\check-multiple-task-output-write が設定され、複数のタスクが同じ出力にアクセスします。 エラー訂正 ：1つの固定タスクでのみ出力を書き込みます。複数のタスクが1つの出力のデータを計算する必要がある場合は、グローバル変数を使用してこの情報を1つの固定タスクに転送し、1つの出力にデータを書き込む必要があります。 エラーの例： PROGRAM PLC_...", 
"body" : "C0165 メッセージ ：アドレス '<address>'にマップされる変数 '<variable name>'は、さまざまなタスクで書き込まれます。 考えられるエラーの原因 ：デバイス設定 codegenerator\\check-multiple-task-output-write が設定され、複数のタスクが同じ出力にアクセスします。 エラー訂正 ：1つの固定タスクでのみ出力を書き込みます。複数のタスクが1つの出力のデータを計算する必要がある場合は、グローバル変数を使用してこの情報を1つの固定タスクに転送し、1つの出力にデータを書き込む必要があります。 エラーの例： PROGRAM PLC_PRG_1\nVAR\n Output AT %QB7 : BYTE;\nEND_VAR\nOutput := 0;\n\nPROGRAM PLC_PRG_2\nVAR\n Output AT %QB7 : BYTE;\nEND_VAR\nOutput := 1;\n メッセージ： C0165：アドレスQB7にマップされる変数出力は、さまざまなタスクで書き込まれます。 " }, 
{ "title" : "コンパイラエラーC0168 ", 
"url" : "_cds_error_c0168.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0168 ", 
"snippet" : "C0168 メッセージ ： 'VAR_CONFIG'宣言はVAR_CONFIGリストでのみ許可されます 考えられるエラーの原因 ：「VAR_CONFIG」はVAR_CONFIGリストの外部で使用されます。 エラー訂正 ：「VAR_CONFIG」はVAR_CONFIGリストでのみ使用してください。 エラーの例： PROGRAM PLC_PRG VAR_CONFIG i : INT; END_VAR メッセージ： メッセージ ： 'VAR_CONFIG'宣言はVAR_CONFIGリストでのみ許可されます...", 
"body" : "C0168 メッセージ ： 'VAR_CONFIG'宣言はVAR_CONFIGリストでのみ許可されます 考えられるエラーの原因 ：「VAR_CONFIG」はVAR_CONFIGリストの外部で使用されます。 エラー訂正 ：「VAR_CONFIG」はVAR_CONFIGリストでのみ使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR_CONFIG\n i : INT;\nEND_VAR\n メッセージ： メッセージ ： 'VAR_CONFIG'宣言はVAR_CONFIGリストでのみ許可されます " }, 
{ "title" : "コンパイラエラーC0169 ", 
"url" : "_cds_error_c0169.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0169 ", 
"snippet" : "C0169 メッセージ ： 'VAR_GLOBAL'宣言はグローバル変数リストでのみ許可されます 考えられるエラーの原因 ： 'VAR_GLOBAL'はグローバル変数リストの外部で使用されます。 エラー訂正 ：グローバル変数リストでのみ「VAR_GLOBAL」を使用してください。 エラーの例： PROGRAM PLC_PRG VAR_GLOBAL i : INT; END_VAR メッセージ： C0169： 'VAR_GLOBAL'宣言はグローバル変数リストでのみ許可されます...", 
"body" : "C0169 メッセージ ： 'VAR_GLOBAL'宣言はグローバル変数リストでのみ許可されます 考えられるエラーの原因 ： 'VAR_GLOBAL'はグローバル変数リストの外部で使用されます。 エラー訂正 ：グローバル変数リストでのみ「VAR_GLOBAL」を使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR_GLOBAL\n i : INT;\nEND_VAR\n メッセージ： C0169： 'VAR_GLOBAL'宣言はグローバル変数リストでのみ許可されます " }, 
{ "title" : "コンパイラエラーC0173 ", 
"url" : "_cds_error_c0173.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0173 ", 
"snippet" : "C0173 メッセージ ： '<keyword>'はこの場所では許可されていません 考えられるエラーの原因 ：宣言キーワード（例： VAR_INPUT 、 VAR_OUTPUT 、 また VAR ）この場所では許可されていません。 エラー訂正 ：宣言を修正してください：入力と出力は、型定義またはグローバル変数リストでは役に立たないか、必要ありません。 エラーの例： TYPE DUT : STRUCT VAR_INPUT member : INT; END_VAR END_STRUCT END_TYPE メッセージ： C0173：「VAR_INPUT」はこの場所では許可されていません エラー訂正...", 
"body" : "C0173 メッセージ ： '<keyword>'はこの場所では許可されていません 考えられるエラーの原因 ：宣言キーワード（例： VAR_INPUT 、 VAR_OUTPUT 、 また VAR ）この場所では許可されていません。 エラー訂正 ：宣言を修正してください：入力と出力は、型定義またはグローバル変数リストでは役に立たないか、必要ありません。 エラーの例： TYPE DUT :\nSTRUCT\n VAR_INPUT\n member : INT;\n END_VAR\nEND_STRUCT\nEND_TYPE\n メッセージ： C0173：「VAR_INPUT」はこの場所では許可されていません エラー訂正： Beispiel:\nTYPE DUT :\nSTRUCT\n member : INT;\nEND_STRUCT\nEND_TYPE " }, 
{ "title" : "コンパイラエラーC0174 ", 
"url" : "_cds_error_c0174.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0174 ", 
"snippet" : "C0174 メッセージ ： 'VAR_TEMP'宣言はこの場所では許可されていません 考えられるエラーの原因 ： 'VAR_TEMP'は、プログラムまたは機能ブロックの外部で使用されます。 エラー訂正 ：プログラムおよび機能ブロック内でのみ「VAR_TEMP」を使用してください。 エラーの例： PROGRAM PLC_PRG VAR END_VAR FUN(); FUNCTION FUN VAR_TEMP END_VAR メッセージ： C0174： 'VAR_TEMP'宣言はこの場所では許可されていません...", 
"body" : "C0174 メッセージ ： 'VAR_TEMP'宣言はこの場所では許可されていません 考えられるエラーの原因 ： 'VAR_TEMP'は、プログラムまたは機能ブロックの外部で使用されます。 エラー訂正 ：プログラムおよび機能ブロック内でのみ「VAR_TEMP」を使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nFUN();\n\nFUNCTION FUN\nVAR_TEMP\nEND_VAR\n メッセージ： C0174： 'VAR_TEMP'宣言はこの場所では許可されていません " }, 
{ "title" : "コンパイラエラーC0175 ", 
"url" : "_cds_error_c0175.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0175 ", 
"snippet" : "C0175 メッセージ ：「RETAIN」または「PERSISTENT」はこの場所では許可されていません 考えられるエラーの原因 ： 'RETAIN'または 'PERSISTENT'は関数で使用されます。 エラー訂正 ：目的の場所で「RETAIN」または「PERSISTENT」を使用します。 エラーの例： PROGRAM PLC_PRG VAR END_VAR POU_1(); FUNCTION POU_1 VAR RETAIN END_VAR メッセージ： C0175：「RETAIN」または「PERSISTENT」はこの場所では許可されていません...", 
"body" : "C0175 メッセージ ：「RETAIN」または「PERSISTENT」はこの場所では許可されていません 考えられるエラーの原因 ： 'RETAIN'または 'PERSISTENT'は関数で使用されます。 エラー訂正 ：目的の場所で「RETAIN」または「PERSISTENT」を使用します。 エラーの例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nPOU_1();\n\nFUNCTION POU_1\nVAR RETAIN\nEND_VAR\n メッセージ： C0175：「RETAIN」または「PERSISTENT」はこの場所では許可されていません " }, 
{ "title" : "コンパイラエラーC0177 ", 
"url" : "_cds_error_c0177.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0177 ", 
"snippet" : "C0177 メッセージ ： '<object>'はタイプ '<type>'であり、インスタンス化できません 考えられるエラーの原因 ：関数をインスタンス化しようとしました。 エラー訂正 ：インスタンス化できるオブジェクトのみをインスタンス化します。 エラーの例： PROGRAM PLC_PRG VAR inst : POU; END_VAR FUNCTION POU VAR END_VAR メッセージ： C0177：「POU」はタイプ「FUNCTION」であり、インスタンス化できません...", 
"body" : "C0177 メッセージ ： '<object>'はタイプ '<type>'であり、インスタンス化できません 考えられるエラーの原因 ：関数をインスタンス化しようとしました。 エラー訂正 ：インスタンス化できるオブジェクトのみをインスタンス化します。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : POU;\nEND_VAR\n\nFUNCTION POU\nVAR\nEND_VAR\n メッセージ： C0177：「POU」はタイプ「FUNCTION」であり、インスタンス化できません " }, 
{ "title" : "コンパイラエラーC0178 ", 
"url" : "_cds_error_c0178.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0178 ", 
"snippet" : "C0178 メッセージ ： '<オブジェクト名>'の 'VAR_IN_OUT'パラメータ '<パラメータ名>'への外部アクセスなし 考えられるエラーの原因 ：「VAR_IN_OUT」パラメータにリモートアクセスしようとしました。 エラー訂正 ：「VAR_IN_OUT」パラメータにリモートアクセスしないでください。 エラーの例： PROGRAM PLC_PRG VAR inst : FB; i : INT; END_VAR i := inst.in_out; FUNCTION_BLOCK FB VAR_IN_OUT in_out : INT; END_VAR メッセージ： C0178：「FB」の...", 
"body" : "C0178 メッセージ ： '<オブジェクト名>'の 'VAR_IN_OUT'パラメータ '<パラメータ名>'への外部アクセスなし 考えられるエラーの原因 ：「VAR_IN_OUT」パラメータにリモートアクセスしようとしました。 エラー訂正 ：「VAR_IN_OUT」パラメータにリモートアクセスしないでください。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : FB;\n i : INT;\nEND_VAR\ni := inst.in_out;\n\nFUNCTION_BLOCK FB\nVAR_IN_OUT\n in_out : INT;\nEND_VAR\n メッセージ： C0178：「FB」の「VAR_IN_OUT」パラメータ「in_out」への外部アクセスがありません " }, 
{ "title" : "コンパイラエラーC0179 ", 
"url" : "_cds_error_c0179.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0179 ", 
"snippet" : "C0179 メッセージ ： '<識別子>'は '機能ブロック'の出力ではありません 考えられるエラーの原因 ：機能ブロックインスタンスの初期化には、次のものを含めることはできません VAR_IN_OUT 変数。 エラー訂正 ： つかいます VAR_IN_OUT 関数ブロック呼び出しの変数のみ。機能ブロックインスタンスを初期化するときは、機能ブロックの入力のみを割り当ててください。 エラーの例： Beispiel: FUNCTION_BLOCK MyFB VAR_IN_OUT inOut : INT; END_VAR PROGRAM PLC_PRG VAR iValue : INT; fb : ...", 
"body" : "C0179 メッセージ ： '<識別子>'は '機能ブロック'の出力ではありません 考えられるエラーの原因 ：機能ブロックインスタンスの初期化には、次のものを含めることはできません VAR_IN_OUT 変数。 エラー訂正 ： つかいます VAR_IN_OUT 関数ブロック呼び出しの変数のみ。機能ブロックインスタンスを初期化するときは、機能ブロックの入力のみを割り当ててください。 エラーの例： Beispiel:\nFUNCTION_BLOCK MyFB\nVAR_IN_OUT\n inOut : INT;\nEND_VAR\n\nPROGRAM PLC_PRG\nVAR\n iValue : INT;\n fb : MyFB := (inOut := iValue);\nEND_VAR\n メッセージ： C0179：「inOut」は「MyFB」の出力ではありません " }, 
{ "title" : "コンパイラエラーC0180 ", 
"url" : "_cds_error_c0180.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0180 ", 
"snippet" : "C0180 メッセージ ：あいまいな名前空間 '<ライブラリ1>'ライブラリによって定義された '<ライブラリ2>' 考えられるエラーの原因 ：ライブラリ<library1>の名前空間は一意ではありません。すでに<ライブラリ2>に使用されています。 エラー訂正 ：それに応じてライブラリの名前空間を変更します（ プロパティ ライブラリマネージャーのボタン）。 エラーの例： メッセージ： C0180：ライブラリ 'Standard、3.5.15.0（System）'で定義されたあいまいな名前空間 'STANDARD'...", 
"body" : "C0180 メッセージ ：あいまいな名前空間 '<ライブラリ1>'ライブラリによって定義された '<ライブラリ2>' 考えられるエラーの原因 ：ライブラリ<library1>の名前空間は一意ではありません。すでに<ライブラリ2>に使用されています。 エラー訂正 ：それに応じてライブラリの名前空間を変更します（ プロパティ ライブラリマネージャーのボタン）。 エラーの例： メッセージ： C0180：ライブラリ 'Standard、3.5.15.0（System）'で定義されたあいまいな名前空間 'STANDARD' " }, 
{ "title" : "コンパイラエラーC0182 ", 
"url" : "_cds_error_c0182.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0182 ", 
"snippet" : "C0182 メッセージ ：戻りタイプは、タイプFUNCTIONおよびMETHODのPOUでのみ可能です。 考えられるエラーの原因 ：プログラムで戻り値を定義しようとしました。 エラー訂正 ：メソッドと関数でのみ戻り値を定義します。 エラーの例： エラーの例： PROGRAM PLC_PRG : BOOL VAR END_VAR メッセージ： C0182：戻りタイプは、タイプFUNCTIONおよびMETHODのPOUでのみ可能です。...", 
"body" : "C0182 メッセージ ：戻りタイプは、タイプFUNCTIONおよびMETHODのPOUでのみ可能です。 考えられるエラーの原因 ：プログラムで戻り値を定義しようとしました。 エラー訂正 ：メソッドと関数でのみ戻り値を定義します。 エラーの例： エラーの例： PROGRAM PLC_PRG : BOOL\nVAR\nEND_VAR\n メッセージ： C0182：戻りタイプは、タイプFUNCTIONおよびMETHODのPOUでのみ可能です。 " }, 
{ "title" : "コンパイラエラーC0183 ", 
"url" : "_cds_error_c0183.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0183 ", 
"snippet" : "C0183 メッセージ ：グローバルスコープ操作 '。'式 '<式>'では無効です 考えられるエラーの原因 ：「。」演算子は、グローバル変数にアクセスするために使用されます。ただし、この場所の後には有効なIEC識別子が続きませんが、たとえば「;」などの文字が続きます。またはなどの予約済み識別子 FUNCTION 、またはなどの演算子 TO_STRING 。 エラー訂正 ：グローバル変数に有効なIEC識別子を使用してください。 エラーの例： PROGRAM PLC_PRG ... iVar := .FUNCTION; strVar := .TO_STRING; メッセージ： C0183：グローバ...", 
"body" : "C0183 メッセージ ：グローバルスコープ操作 '。'式 '<式>'では無効です 考えられるエラーの原因 ：「。」演算子は、グローバル変数にアクセスするために使用されます。ただし、この場所の後には有効なIEC識別子が続きませんが、たとえば「;」などの文字が続きます。またはなどの予約済み識別子 FUNCTION 、またはなどの演算子 TO_STRING 。 エラー訂正 ：グローバル変数に有効なIEC識別子を使用してください。 エラーの例： PROGRAM PLC_PRG\n...\n\niVar := .FUNCTION;\nstrVar := .TO_STRING; メッセージ： C0183：グローバルスコープ操作 '。'式 '<式>'では無効です エラー訂正： 例：globalValueはGVLで宣言されています。 PROGRAM PLC_PRG\niVar := .globalValue; " }, 
{ "title" : "コンパイラエラーC0185 ", 
"url" : "_cds_error_c0185.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0185 ", 
"snippet" : "C0185 メッセージ ：関数呼び出しの結果、コンポーネントアクセス '。'、インデックスアクセス '[]'、または呼び出し '（）'を実行することはできません。最初にヘルプ変数に結果を割り当てます。 考えられるエラーの原因 ：関数呼び出しの結果へのコンポーネントまたはインデックスアクセスが実行されます。 エラー訂正 ：アクセスするために、結果を変数に割り当てます。 エラーの例： PROGRAM PLC_PRG VAR it : ITF; END_VAR POU_1()[0].METH1(); FUNCTION POU_1 : ARRAY[0..0] OF ITF INTERFACE ITF ...", 
"body" : "C0185 メッセージ ：関数呼び出しの結果、コンポーネントアクセス '。'、インデックスアクセス '[]'、または呼び出し '（）'を実行することはできません。最初にヘルプ変数に結果を割り当てます。 考えられるエラーの原因 ：関数呼び出しの結果へのコンポーネントまたはインデックスアクセスが実行されます。 エラー訂正 ：アクセスするために、結果を変数に割り当てます。 エラーの例： PROGRAM PLC_PRG\nVAR\n it : ITF;\nEND_VAR\n\nPOU_1()[0].METH1();\n\nFUNCTION POU_1 : ARRAY[0..0] OF ITF\n\nINTERFACE ITF\n\nMETHOD METH1\n メッセージ： C0185：関数呼び出しの結果、コンポーネントアクセス '。'、インデックスアクセス '[]'、または呼び出し '（）'を実行できません。最初にヘルプ変数に結果を割り当てます。 " }, 
{ "title" : "コンパイラエラーC0186 ", 
"url" : "_cds_error_c0186.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0186 ", 
"snippet" : "C0186 メッセージ ：呼び出しの戻り値であるインターフェースを比較することはできません。最初に変数に割り当てます。 考えられるエラーの原因 ：関数によって返されるインターフェイスに比較操作が適用されます。 エラー訂正 ：最初に関数呼び出しの結果を変数に割り当ててから、変数の値を比較します。これにより、必要な関数呼び出しの数も減ります。 エラーの例： INTERFACE MyInterface FUNCTION GetInterface : MyInterface PROGRAM PLC_PRG IF GetInterface() <> 0 THEN \/\/ ... END_IF メッセージ：...", 
"body" : "C0186 メッセージ ：呼び出しの戻り値であるインターフェースを比較することはできません。最初に変数に割り当てます。 考えられるエラーの原因 ：関数によって返されるインターフェイスに比較操作が適用されます。 エラー訂正 ：最初に関数呼び出しの結果を変数に割り当ててから、変数の値を比較します。これにより、必要な関数呼び出しの数も減ります。 エラーの例： INTERFACE MyInterface\n\nFUNCTION GetInterface : MyInterface\n\nPROGRAM PLC_PRG\nIF GetInterface() <> 0 THEN\n \/\/ ...\nEND_IF\n メッセージ： C0186：呼び出しの戻り値であるインターフェイスを比較できません。最初に変数に割り当てます。 エラー訂正： PROGRAM PLC_PRG\nVAR_TEMP\n tempInterface : MyInterface;\nEND_VAR\ntempInterface := GetInterface();\nIF tempInterface <> 0 THEN\n \/\/ ...\nEND_IF " }, 
{ "title" : "コンパイラ警告 C0187 ", 
"url" : "_cds_error_c0187.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0187 ", 
"snippet" : "0187 メッセージ : 外部参照は、ファンクション ブロック、メソッド、関数、および定数グローバル変数リストに対してのみ可能です。 PROGRAM '' の外部参照は無視されます。 考えられるエラー原因 : プログラムのプロパティダイアログで、 ビルド タブ、 外部実装 オプションが有効になっています。 エラー訂正 : 非アクティブ化 外部実装 オプション。...", 
"body" : "0187 メッセージ : 外部参照は、ファンクション ブロック、メソッド、関数、および定数グローバル変数リストに対してのみ可能です。 PROGRAM '' の外部参照は無視されます。 考えられるエラー原因 : プログラムのプロパティダイアログで、 ビルド タブ、 外部実装 オプションが有効になっています。 エラー訂正 : 非アクティブ化 外部実装 オプション。 " }, 
{ "title" : "コンパイラエラーC0188 ", 
"url" : "_cds_error_c0188.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0188 ", 
"snippet" : "C0188 メッセージ ：デバイスがシステムにインストールされていません。コード生成はできません。 考えられるエラーの原因 ：目的のデバイスがインストールされていません。 エラー訂正 ：不足しているデバイスをデバイスリポジトリにインストールするか、デバイスツリーにすでに挿入されている既存のデバイスを別の既存のデバイスに置き換えます（ デバイスの更新 ）。...", 
"body" : "C0188 メッセージ ：デバイスがシステムにインストールされていません。コード生成はできません。 考えられるエラーの原因 ：目的のデバイスがインストールされていません。 エラー訂正 ：不足しているデバイスをデバイスリポジトリにインストールするか、デバイスツリーにすでに挿入されている既存のデバイスを別の既存のデバイスに置き換えます（ デバイスの更新 ）。 " }, 
{ "title" : "コンパイラエラーC0189 ", 
"url" : "_cds_error_c0189.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0189 ", 
"snippet" : "C0189 メッセージ ： ';' '<token>'の代わりに期待 考えられるエラーの原因 ： 構文エラー エラー訂正 ：構文が正しいことを確認してください。 エラーの例： PROGRAM PLC_PRG VAR INT END_VAR メッセージ： C0009：予期しないトークン '＆lt;トークン＆gt;'見つかった C0189： ';' 'INT'の代わりに期待...", 
"body" : "C0189 メッセージ ： ';' '<token>'の代わりに期待 考えられるエラーの原因 ： 構文エラー エラー訂正 ：構文が正しいことを確認してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n INT\nEND_VAR\n メッセージ： C0009：予期しないトークン '＆lt;トークン＆gt;'見つかった C0189： ';' 'INT'の代わりに期待 " }, 
{ "title" : "コンパイラエラーC0190 ", 
"url" : "_cds_error_c0190.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0190 ", 
"snippet" : "C0190 メッセージ ： ';' POUの終わりではなく期待 考えられるエラーの原因 ：POUの構文エラー エラー訂正 ：構文が正しいことを確認してください。 エラーの例： PROGRAM PLC_PRG VAR i : INT; END_VAR i := 5 メッセージ： C0190： ';' POUの終わりではなく期待...", 
"body" : "C0190 メッセージ ： ';' POUの終わりではなく期待 考えられるエラーの原因 ：POUの構文エラー エラー訂正 ：構文が正しいことを確認してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\ni := 5\n メッセージ： C0190： ';' POUの終わりではなく期待 " }, 
{ "title" : "コンパイラエラーC0191 ", 
"url" : "_cds_error_c0191.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0191 ", 
"snippet" : "C0191 メッセージ ：演算子「INDEXOF」はサポートされなくなりました。代わりにADRを使用してください。 POU-NameのADRは、ポインターから関数コードへのポインターを返します。 考えられるエラーの原因 ：古い演算子「INDEXOF」が使用されています。 エラー訂正 ：演算子「ADR」を使用します。...", 
"body" : "C0191 メッセージ ：演算子「INDEXOF」はサポートされなくなりました。代わりにADRを使用してください。 POU-NameのADRは、ポインターから関数コードへのポインターを返します。 考えられるエラーの原因 ：古い演算子「INDEXOF」が使用されています。 エラー訂正 ：演算子「ADR」を使用します。 " }, 
{ "title" : "コンパイラエラーC0195 ", 
"url" : "_cds_error_c0195.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0195 ", 
"snippet" : "C0195 メッセージ ：符号付きタイプ '<データ型1>'から符号なしタイプ '<データ型2>'への暗黙の変換：符号の変更の可能性 考えられるエラーの原因 ：暗黙の変換で符号の競合が見落とされた可能性があります。 エラー訂正 ：同じ符号のデータ型のみを暗黙的に変換します。 エラーの例： PROGRAM PLC_PRG VAR i : INT; b : UINT; END_VAR b := i; メッセージ： C0195：符号付きタイプ 'INT'から符号なしタイプ 'UINT'への暗黙の変換：符号の変更の可能性...", 
"body" : "C0195 メッセージ ：符号付きタイプ '<データ型1>'から符号なしタイプ '<データ型2>'への暗黙の変換：符号の変更の可能性 考えられるエラーの原因 ：暗黙の変換で符号の競合が見落とされた可能性があります。 エラー訂正 ：同じ符号のデータ型のみを暗黙的に変換します。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\n b : UINT;\nEND_VAR\n\nb := i;\n メッセージ： C0195：符号付きタイプ 'INT'から符号なしタイプ 'UINT'への暗黙の変換：符号の変更の可能性 " }, 
{ "title" : "コンパイラエラーC0196 ", 
"url" : "_cds_error_c0196.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0196 ", 
"snippet" : "C0196 メッセージ ：符号なしタイプ '<データ型1>'から符号付きタイプ '<データ型2>'への暗黙の変換：符号の変更の可能性 考えられるエラーの原因 ：暗黙の変換で符号の競合が見落とされた可能性があります。 エラー訂正 ：明示的な変換を使用します。 エラーの例： PROGRAM PLC_PRG VAR i : INT; b : UINT; END_VAR i := b; メッセージ： C0196：符号なしタイプ 'UINT'から符号付きタイプ 'INT'への暗黙の変換：符号の変更の可能性...", 
"body" : "C0196 メッセージ ：符号なしタイプ '<データ型1>'から符号付きタイプ '<データ型2>'への暗黙の変換：符号の変更の可能性 考えられるエラーの原因 ：暗黙の変換で符号の競合が見落とされた可能性があります。 エラー訂正 ：明示的な変換を使用します。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\n b : UINT;\nEND_VAR\n\ni := b;\n メッセージ： C0196：符号なしタイプ 'UINT'から符号付きタイプ 'INT'への暗黙の変換：符号の変更の可能性 " }, 
{ "title" : "コンパイラエラーC0197 ", 
"url" : "_cds_error_c0197.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0197 ", 
"snippet" : "C0197 メッセージ ： '<データ型1>'から '<データ型2>'への暗黙の変換：情報が失われる可能性があります 考えられるエラーの原因 ：変数をデータ型DINTまたはLINTからデータ型REALに変換しようとしました。 エラー訂正 ：DINTの場合、データ型LREALを使用し、LINTからLREALに変換するときは、LINTの値がLREALの容量を超えないようにしてください。 エラーの例： PROGRAM PLC_PRG VAR i : DINT; b : REAL; END_VAR b := i; メッセージ： C0197：「DINT」から「REAL」への暗黙の変換：情報が失われる可能...", 
"body" : "C0197 メッセージ ： '<データ型1>'から '<データ型2>'への暗黙の変換：情報が失われる可能性があります 考えられるエラーの原因 ：変数をデータ型DINTまたはLINTからデータ型REALに変換しようとしました。 エラー訂正 ：DINTの場合、データ型LREALを使用し、LINTからLREALに変換するときは、LINTの値がLREALの容量を超えないようにしてください。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : DINT;\n b : REAL;\nEND_VAR\nb := i;\n メッセージ： C0197：「DINT」から「REAL」への暗黙の変換：情報が失われる可能性があります " }, 
{ "title" : "コンパイラエラーC0198 ", 
"url" : "_cds_error_c0198.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0198 ", 
"snippet" : "C0198 メッセージ ：文字列定数 '<文字列値>'宛先タイプ '<データ型>'には長すぎます 考えられるエラーの原因 ：文字列定数の文字数が多すぎます。 エラー訂正 ：短い文字列定数を使用するか、大きな文字列を宣言します。 エラーの例： PROGRAM PLC_PRG VAR str : STRING(4) := '12345'; END_VAR メッセージ： C0198：文字列定数「12345」が宛先タイプ「STRING（4）」に対して長すぎます...", 
"body" : "C0198 メッセージ ：文字列定数 '<文字列値>'宛先タイプ '<データ型>'には長すぎます 考えられるエラーの原因 ：文字列定数の文字数が多すぎます。 エラー訂正 ：短い文字列定数を使用するか、大きな文字列を宣言します。 エラーの例： PROGRAM PLC_PRG\nVAR\n str : STRING(4) := '12345';\nEND_VAR\n メッセージ： C0198：文字列定数「12345」が宛先タイプ「STRING（4）」に対して長すぎます " }, 
{ "title" : "コンパイラエラーC0199 ", 
"url" : "_cds_error_c0199.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0199 ", 
"snippet" : "C0199 メッセージ ：インターフェイス '<インターフェイス名>'にアクセスするには、インスタンス化する必要があります 考えられるエラーの原因 ：インターフェイスがインスタンス化されずに、インターフェイスメソッドにアクセスしようとしました。 エラー訂正 ：インターフェースをインスタンス化します。 エラーの例： PROGRAM PLC_PRG VAR END_VAR ITF.METH(); INTERFACE ITF METHOD METH VAR_INPUT END_VAR メッセージ： C0199：インターフェイス「ITF」にアクセスするにはインスタンス化する必要があります エラー訂正：...", 
"body" : "C0199 メッセージ ：インターフェイス '<インターフェイス名>'にアクセスするには、インスタンス化する必要があります 考えられるエラーの原因 ：インターフェイスがインスタンス化されずに、インターフェイスメソッドにアクセスしようとしました。 エラー訂正 ：インターフェースをインスタンス化します。 エラーの例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nITF.METH();\n\nINTERFACE ITF\n\nMETHOD METH\nVAR_INPUT\nEND_VAR\n メッセージ： C0199：インターフェイス「ITF」にアクセスするにはインスタンス化する必要があります エラー訂正： Beispiel:\nitest: ITF; " }, 
{ "title" : "コンパイラエラーC0201 ", 
"url" : "_cds_error_c0201.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0201 ", 
"snippet" : "C0201 メッセージ ：タイプ '<データタイプ1>'はVAR_IN_OUT '変数'のタイプ '<データタイプ2>'と等しくありません 考えられるエラーの原因 ：VAR_IN_OUTパラメータとして関数に渡されるデータ型が、関数で定義されているデータ型と一致しません。 エラー訂正 ：正しいデータ型の変数を渡します。 エラーの例： PROGRAM PLC_PRG VAR Inst: POU; b : BOOL; END_VAR inst(in_out := b); FUNCTION_BLOCK POU VAR_IN_OUT in_out : INT; END_VAR メッセージ： C0201...", 
"body" : "C0201 メッセージ ：タイプ '<データタイプ1>'はVAR_IN_OUT '変数'のタイプ '<データタイプ2>'と等しくありません 考えられるエラーの原因 ：VAR_IN_OUTパラメータとして関数に渡されるデータ型が、関数で定義されているデータ型と一致しません。 エラー訂正 ：正しいデータ型の変数を渡します。 エラーの例： PROGRAM PLC_PRG\nVAR\n Inst: POU;\n b : BOOL;\nEND_VAR\n\ninst(in_out := b);\n\nFUNCTION_BLOCK POU\nVAR_IN_OUT\n in_out : INT;\nEND_VAR\n メッセージ： C0201：タイプ 'BOOL'はVAR_IN_OUT '変数'のタイプ 'INT'と等しくありません " }, 
{ "title" : "コンパイラエラーC0203 ", 
"url" : "_cds_error_c0203.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0203 ", 
"snippet" : "C0203 メッセージ ：BITタイプの変数を含めることができるのは、構造体と関数ブロックのみです。 考えられるエラーの原因 ：構造体および関数ブロックの外部でBIT型の変数を宣言しようとしました。 エラー訂正 ：構造体と関数ブロックでのみBIT型の変数を宣言します。 エラーの例： PROGRAM PLC_PRG VAR b : BIT; END_VAR メッセージ： C0203：構造体と関数ブロックのみがBIT型の変数を含むことができます。...", 
"body" : "C0203 メッセージ ：BITタイプの変数を含めることができるのは、構造体と関数ブロックのみです。 考えられるエラーの原因 ：構造体および関数ブロックの外部でBIT型の変数を宣言しようとしました。 エラー訂正 ：構造体と関数ブロックでのみBIT型の変数を宣言します。 エラーの例： PROGRAM PLC_PRG\nVAR\n b : BIT;\nEND_VAR\n メッセージ： C0203：構造体と関数ブロックのみがBIT型の変数を含むことができます。 " }, 
{ "title" : "コンパイラエラーC0204 ", 
"url" : "_cds_error_c0204.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0204 ", 
"snippet" : "C0204 メッセージ ：タイプBITの変数は、VAR_INPUT-、VAR_OUTPUT、またはVARブロック内で宣言する必要があります 考えられるエラーの原因 ：タイプBITの変数を、またはVAR_IN_OUTパラメーターとして定義しようとしました。 エラー訂正 ：VAR_INPUT、VAR_OUTPUT、またはVARブロック内でのみBIT型の変数を定義します。 エラーの例： PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTION_BLOCK FB VAR_IN_OUT b : BIT; END_VAR メッセージ： C0204：タイプBITの変数は...", 
"body" : "C0204 メッセージ ：タイプBITの変数は、VAR_INPUT-、VAR_OUTPUT、またはVARブロック内で宣言する必要があります 考えられるエラーの原因 ：タイプBITの変数を、またはVAR_IN_OUTパラメーターとして定義しようとしました。 エラー訂正 ：VAR_INPUT、VAR_OUTPUT、またはVARブロック内でのみBIT型の変数を定義します。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB\nVAR_IN_OUT\n b : BIT;\nEND_VAR\n メッセージ： C0204：タイプBITの変数は、VAR_INPUT-、VAR_OUTPUT、またはVARブロック内で宣言する必要があります " }, 
{ "title" : "コンパイラエラーC0205 ", 
"url" : "_cds_error_c0205.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0205 ", 
"snippet" : "C0205 メッセージ ：POINTER TOBITは許可されていません 考えられるエラーの原因 ：POINTER TOBITを宣言しようとしました。 エラー訂正 ：POINTER TOBITを宣言しないでください。 エラーの例： PROGRAM PLC_PRG VAR pt : POINTER TO BIT; END_VAR メッセージ： C0205：POINTER TOBITは許可されていません...", 
"body" : "C0205 メッセージ ：POINTER TOBITは許可されていません 考えられるエラーの原因 ：POINTER TOBITを宣言しようとしました。 エラー訂正 ：POINTER TOBITを宣言しないでください。 エラーの例： PROGRAM PLC_PRG\nVAR\n pt : POINTER TO BIT;\nEND_VAR\n メッセージ： C0205：POINTER TOBITは許可されていません " }, 
{ "title" : "コンパイラエラーC0206 ", 
"url" : "_cds_error_c0206.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0206 ", 
"snippet" : "C0206 メッセージ ：BITは配列の基本型として許可されていません 考えられるエラーの原因 ：BIT配列を宣言しようとしました。 エラー訂正 ：BIT配列を宣言しないでください。 エラーの例： PROGRAM PLC_PRG VAR arr : ARRAY[1..2] OF BIT; END_VAR メッセージ： C0206：BITは配列の基本型として許可されていません...", 
"body" : "C0206 メッセージ ：BITは配列の基本型として許可されていません 考えられるエラーの原因 ：BIT配列を宣言しようとしました。 エラー訂正 ：BIT配列を宣言しないでください。 エラーの例： PROGRAM PLC_PRG\nVAR\n arr : ARRAY[1..2] OF BIT;\nEND_VAR\n メッセージ： C0206：BITは配列の基本型として許可されていません " }, 
{ "title" : "コンパイラエラーC0207 ", 
"url" : "_cds_error_c0207.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0207 ", 
"snippet" : "C0207 メッセージ ： '<識別子>'のシステム定義はありません 考えられるエラーの原因 ：の変数にアクセスしようとしました __SYSTEM それは存在しません。 エラー訂正 ：それぞれの変数の指定された識別子を確認して修正します。 エラーの例： PROGRAM PLC_PRG VAR Value : INT; END_VAR Value := __SYSTEM.UnknownVariable; メッセージ： C0207：「UnkownVariable」のシステム定義はありません...", 
"body" : "C0207 メッセージ ： '<識別子>'のシステム定義はありません 考えられるエラーの原因 ：の変数にアクセスしようとしました __SYSTEM それは存在しません。 エラー訂正 ：それぞれの変数の指定された識別子を確認して修正します。 エラーの例： PROGRAM PLC_PRG\nVAR\n Value : INT;\nEND_VAR\nValue := __SYSTEM.UnknownVariable;\n メッセージ： C0207：「UnkownVariable」のシステム定義はありません " }, 
{ "title" : "コンパイラエラーC0208 ", 
"url" : "_cds_error_c0208.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0208 ", 
"snippet" : "C0208 メッセージ ：「MOD」は「REAL」に対して定義されていません 考えられるエラーの原因 ：タイプの変数を使用してモジュロ演算を実行しようとしました REAL 。 エラー訂正 ：モジュロ演算は、タイプの変数でのみ可能です ANY_INT 。 エラーの例： PROGRAM PLC_PRG VAR r1 : REAL; END_VAR r1 := r1 MOD 2; メッセージ： C0208：「MOD」は「REAL」に対して定義されていません...", 
"body" : "C0208 メッセージ ：「MOD」は「REAL」に対して定義されていません 考えられるエラーの原因 ：タイプの変数を使用してモジュロ演算を実行しようとしました REAL 。 エラー訂正 ：モジュロ演算は、タイプの変数でのみ可能です ANY_INT 。 エラーの例： PROGRAM PLC_PRG\nVAR\n r1 : REAL;\nEND_VAR\nr1 := r1 MOD 2;\n メッセージ： C0208：「MOD」は「REAL」に対して定義されていません " }, 
{ "title" : "コンパイラエラーC0209 ", 
"url" : "_cds_error_c0209.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0209 ", 
"snippet" : "C0209 メッセージ ：デバイス '<デバイス名>'の '<番号>'アプリケーションを定義しました。最大数は「<number>」です。そのため、すべてのアプリケーションをダウンロードすることはできません。 考えられるエラーの原因 ：一部のデバイスは、特定の数のアプリケーション（デバイスの説明）のみをサポートします。プロジェクトにさらに多くのアプリケーションが含まれている場合、すべてがデバイスにダウンロードされるわけではありません。 エラー訂正 ：プロジェクトからアプリケーションを削除するか、別のデバイスを使用してください。...", 
"body" : "C0209 メッセージ ：デバイス '<デバイス名>'の '<番号>'アプリケーションを定義しました。最大数は「<number>」です。そのため、すべてのアプリケーションをダウンロードすることはできません。 考えられるエラーの原因 ：一部のデバイスは、特定の数のアプリケーション（デバイスの説明）のみをサポートします。プロジェクトにさらに多くのアプリケーションが含まれている場合、すべてがデバイスにダウンロードされるわけではありません。 エラー訂正 ：プロジェクトからアプリケーションを削除するか、別のデバイスを使用してください。 " }, 
{ "title" : "コンパイラエラーC0211 ", 
"url" : "_cds_error_c0211.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0211 ", 
"snippet" : "C0211 メッセージ ：<expression>の代わりに変数宣言が必要です 考えられるエラーの原因 ： 構文エラー エラー訂正 ：構文が正しいことを確認してください。 エラーの例： PROGRAM PLC_PRG VAR VAR END_VAR END_VAR メッセージ： C0211：VAREND_VARの代わりに変数宣言が必要です...", 
"body" : "C0211 メッセージ ：<expression>の代わりに変数宣言が必要です 考えられるエラーの原因 ： 構文エラー エラー訂正 ：構文が正しいことを確認してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n VAR\n\n END_VAR\nEND_VAR\n メッセージ： C0211：VAREND_VARの代わりに変数宣言が必要です " }, 
{ "title" : "コンパイラエラーC0212 ", 
"url" : "_cds_error_c0212.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0212 ", 
"snippet" : "C0212 メッセージ ：<expression>の代わりにVAR、VAR_INPUT、VAR_OUTPUT、またはVAR_INOUTが必要です 考えられるエラーの原因 ： 構文エラー エラー訂正 ：構文が正しいことを確認してください。 エラーの例： PROGRAM PLC_PRG i : INT; メッセージ： C0212：iの代わりにVAR、VAR_INPUT、VAR_OUTPUT、またはVAR_INOUTが必要です：INT;...", 
"body" : "C0212 メッセージ ：<expression>の代わりにVAR、VAR_INPUT、VAR_OUTPUT、またはVAR_INOUTが必要です 考えられるエラーの原因 ： 構文エラー エラー訂正 ：構文が正しいことを確認してください。 エラーの例： PROGRAM PLC_PRG\ni : INT;\n メッセージ： C0212：iの代わりにVAR、VAR_INPUT、VAR_OUTPUT、またはVAR_INOUTが必要です：INT; " }, 
{ "title" : "コンパイラエラー C0213 ", 
"url" : "_cds_error_c0213.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラー C0213 ", 
"snippet" : "C0213 メッセージ :  <宣言> の代わりに  VAR_GLOBAL または VAR_CONFIG が必要です 考えられるエラー原因 : グローバル変数リスト (GVL) の外部に変数宣言があります VAR_GLOBAL ブロック。 エラー訂正 : 変数宣言をに移動 VAR_GLOBAL または VAR_CONFIG ブロック。 エラーの例 VAR_GLOBAL END_VAR i : INT; メッセージ: C0213: i: INT の代わりに VAR_GLOBALまたはVAR_CONFIG が必要です...", 
"body" : "C0213 メッセージ :  <宣言> の代わりに  VAR_GLOBAL または VAR_CONFIG が必要です 考えられるエラー原因 : グローバル変数リスト (GVL) の外部に変数宣言があります VAR_GLOBAL ブロック。 エラー訂正 : 変数宣言をに移動 VAR_GLOBAL または VAR_CONFIG ブロック。 エラーの例 VAR_GLOBAL\nEND_VAR\ni : INT; メッセージ: C0213: i: INT の代わりに VAR_GLOBALまたはVAR_CONFIG が必要です " }, 
{ "title" : "コンパイラエラーC0215 ", 
"url" : "_cds_error_c0215.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0215 ", 
"snippet" : "C0215 メッセージ ：永続リストでは直接アドレス宣言はできません 考えられるエラーの原因 ：永続変数に直接アドレスを設定することはできません。 エラー訂正 ：永続変数リストの直接アドレス割り当てを削除します。 エラーの例： VAR_GLOBAL PERSISTENT RETAIN directAddressVar AT %QB7 : BYTE; END_VAR メッセージ： C0215：永続リストでは直接アドレス宣言はできません...", 
"body" : "C0215 メッセージ ：永続リストでは直接アドレス宣言はできません 考えられるエラーの原因 ：永続変数に直接アドレスを設定することはできません。 エラー訂正 ：永続変数リストの直接アドレス割り当てを削除します。 エラーの例： VAR_GLOBAL PERSISTENT RETAIN\n directAddressVar AT %QB7 : BYTE;\nEND_VAR\n メッセージ： C0215：永続リストでは直接アドレス宣言はできません " }, 
{ "title" : "コンパイラエラーC0216 ", 
"url" : "_cds_error_c0216.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0216 ", 
"snippet" : "C0216 メッセージ ：ケースラベルの重複 考えられるエラーの原因 ：CASEラベルが複数回使用されています。 エラー訂正 ：各CASEラベルは1回だけ使用してください。 エラーの例： PROGRAM PLC_PRG VAR i : INT; END_VAR CASE i OF 1: i := i+1; 1: i := i+2; ELSE i := i+10; END_CASE; --> C0216: Doppelte 'CASE'-Marke メッセージ： C0216：ケースラベルが重複しています...", 
"body" : "C0216 メッセージ ：ケースラベルの重複 考えられるエラーの原因 ：CASEラベルが複数回使用されています。 エラー訂正 ：各CASEラベルは1回だけ使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\n\nCASE i OF\n 1: i := i+1;\n 1: i := i+2;\nELSE\n i := i+10;\nEND_CASE;\n\n--> C0216: Doppelte 'CASE'-Marke メッセージ： C0216：ケースラベルが重複しています " }, 
{ "title" : "コンパイラエラーC0217 ", 
"url" : "_cds_error_c0217.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0217 ", 
"snippet" : "C0217 メッセージ ：ケースラベル<ケースラベル>も範囲に含まれています<ケース範囲開始> .. <ケース範囲終了> 考えられるエラーの原因 ：CASEラベルは、別のCASEラベルの範囲の一部です。 エラー訂正 ：交差していないことを確認してください。 エラーの例： PROGRAM PLC_PRG VAR i : INT; END_VAR CASE i OF 3..5: i := i+2; 4: i := i+2; ELSE i := i+10; END_CASE; メッセージ： C0217：ケースラベル4も範囲3 ..5に含まれています...", 
"body" : "C0217 メッセージ ：ケースラベル<ケースラベル>も範囲に含まれています<ケース範囲開始> .. <ケース範囲終了> 考えられるエラーの原因 ：CASEラベルは、別のCASEラベルの範囲の一部です。 エラー訂正 ：交差していないことを確認してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\nCASE i OF\n 3..5: i := i+2;\n 4: i := i+2;\nELSE\n i := i+10;\nEND_CASE;\n メッセージ： C0217：ケースラベル4も範囲3 ..5に含まれています " }, 
{ "title" : "コンパイラエラーC0218 ", 
"url" : "_cds_error_c0218.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0218 ", 
"snippet" : "C0218 メッセージ ： 'CASE'ラベルには、リテラルまたはシンボリック整数定数が必要です 考えられるエラーの原因 ：変数をCASEラベルとして使用しようとしました。 エラー訂正 ：リテラルとシンボリック整数定数のみを使用してください。 エラーの例： PROGRAM PLC_PRG VAR i : INT; a : INT := 2; END_VAR CASE i OF 1: i := i+1; a: i := i+2; ELSE i := i+10; END_CASE; メッセージ： C0218：「CASE」ラベルにはリテラルまたはシンボリック整数定数が必要です...", 
"body" : "C0218 メッセージ ： 'CASE'ラベルには、リテラルまたはシンボリック整数定数が必要です 考えられるエラーの原因 ：変数をCASEラベルとして使用しようとしました。 エラー訂正 ：リテラルとシンボリック整数定数のみを使用してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\n a : INT := 2;\nEND_VAR\n\nCASE i OF\n 1: i := i+1;\n a: i := i+2;\nELSE\n i := i+10;\nEND_CASE;\n メッセージ： C0218：「CASE」ラベルにはリテラルまたはシンボリック整数定数が必要です " }, 
{ "title" : "コンパイラエラーC0219 ", 
"url" : "_cds_error_c0219.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0219 ", 
"snippet" : "C0219 メッセージ ：ケースに重複する範囲が含まれています<ケース範囲1の開始> .. <ケース範囲1の終了>と<ケース範囲2の開始> .. <ケース範囲2の終了> 考えられるエラーの原因 ：CASEマーカーの2つのブランチには、同じ要素またはサブセットがあります。 エラー訂正 ：交差していないことを確認してください。 エラーの例： PROGRAM PLC_PRG VAR i : INT; END_VAR CASE i OF 3..5: i := i+2; 1..4: i := i+2; ELSE i := i+10; END_CASE; メッセージ： C0219：「CASE」には重複する...", 
"body" : "C0219 メッセージ ：ケースに重複する範囲が含まれています<ケース範囲1の開始> .. <ケース範囲1の終了>と<ケース範囲2の開始> .. <ケース範囲2の終了> 考えられるエラーの原因 ：CASEマーカーの2つのブランチには、同じ要素またはサブセットがあります。 エラー訂正 ：交差していないことを確認してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\nCASE i OF\n 3..5: i := i+2;\n 1..4: i := i+2;\nELSE\n i := i+10;\nEND_CASE;\n メッセージ： C0219：「CASE」には重複する範囲1 ..4と3..5が含まれています " }, 
{ "title" : "コンパイラエラーC0221 ", 
"url" : "_cds_error_c0221.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0221 ", 
"snippet" : "C0221 メッセージ ：直接アドレス '<アドレス>'の形式が正しくありません 考えられるエラーの原因 ：アドレスが完全に表示されていません。 エラー訂正 ：アドレスが正しく表示されていることを確認してください。 エラーの例： PROGRAM PLC_PRG VAR xVar : BOOL; END_VAR; xVar := %IX0; メッセージ： C0221：直接アドレス '％IXO'の形式が正しくありません エラー訂正： xVar := %IX0.2;...", 
"body" : "C0221 メッセージ ：直接アドレス '<アドレス>'の形式が正しくありません 考えられるエラーの原因 ：アドレスが完全に表示されていません。 エラー訂正 ：アドレスが正しく表示されていることを確認してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n xVar : BOOL;\nEND_VAR;\nxVar := %IX0;\n メッセージ： C0221：直接アドレス '％IXO'の形式が正しくありません エラー訂正： xVar := %IX0.2; " }, 
{ "title" : "コンパイラエラーC0222 ", 
"url" : "_cds_error_c0222.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0222 ", 
"snippet" : "C0222 メッセージ ：出力は「REFERENCETO」タイプにすることはできません 考えられるエラーの原因 : 定義しようとする試みがなされる REFERENCE TO 出力パラメータとして。 エラー訂正 ： 使用禁止 REFERENCE TO 出力パラメータとして。 エラーの例： PROGRAM PLC_PRG VAR inst : FB; END_VAR 機能ブロックの実装: FUNCTION_BLOCK FB VAR_OUTPUT re : REFERENCE TO INT; END_VAR メッセージ： C0222：出力のタイプを「REFERENCETO」にすることはできません...", 
"body" : "C0222 メッセージ ：出力は「REFERENCETO」タイプにすることはできません 考えられるエラーの原因 : 定義しようとする試みがなされる REFERENCE TO 出力パラメータとして。 エラー訂正 ： 使用禁止 REFERENCE TO 出力パラメータとして。 エラーの例： PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n 機能ブロックの実装: FUNCTION_BLOCK FB\nVAR_OUTPUT\n re : REFERENCE TO INT;\nEND_VAR メッセージ： C0222：出力のタイプを「REFERENCETO」にすることはできません " }, 
{ "title" : "コンパイラエラーC0224 ", 
"url" : "_cds_error_c0224.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0224 ", 
"snippet" : "C0224 メッセージ ：再帰を呼び出す：<再帰> 考えられるエラーの原因 ：関数はそれ自体を呼び出します。 エラー訂正 ：関数が再帰的でないことを確認してください。 エラーの例： エラーの例： PROGRAM PLC_PRG VAR END_VAR POU(); FUNCTION POU VAR END_VAR POU(); メッセージ： C0224：呼び出し再帰：POU-> POU...", 
"body" : "C0224 メッセージ ：再帰を呼び出す：<再帰> 考えられるエラーの原因 ：関数はそれ自体を呼び出します。 エラー訂正 ：関数が再帰的でないことを確認してください。 エラーの例： エラーの例： PROGRAM PLC_PRG\nVAR\nEND_VAR\n\nPOU();\n\nFUNCTION POU\nVAR\nEND_VAR\n\nPOU();\n メッセージ： C0224：呼び出し再帰：POU-> POU " }, 
{ "title" : "コンパイラエラーC0225 ", 
"url" : "_cds_error_c0225.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0225 ", 
"snippet" : "C0225 メッセージ ： '<name>'は '<name>'のインスタンスではありません 考えられるエラーの原因 ：グラフィカルプログラミング言語の機能ブロックに、宣言された型と一致しない明示的に指定された型が割り当てられています。 エラー訂正 ：明示的な型を宣言部分で使用されているものに置き換えるか、明示的な型の指定をPOUから削除してください。 エラーの例： PROGRAM PLC_PRG VAR fbVar : MyFB; END_VAR メッセージ： C0225：「fbVar」は「MyFB2」のインスタンスではありません エラー訂正： また...", 
"body" : "C0225 メッセージ ： '<name>'は '<name>'のインスタンスではありません 考えられるエラーの原因 ：グラフィカルプログラミング言語の機能ブロックに、宣言された型と一致しない明示的に指定された型が割り当てられています。 エラー訂正 ：明示的な型を宣言部分で使用されているものに置き換えるか、明示的な型の指定をPOUから削除してください。 エラーの例： PROGRAM PLC_PRG\nVAR\n fbVar : MyFB;\nEND_VAR\n メッセージ： C0225：「fbVar」は「MyFB2」のインスタンスではありません エラー訂正： また " }, 
{ "title" : "コンパイラエラーC0227 ", 
"url" : "_cds_error_c0227.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0227 ", 
"snippet" : "C0227 メッセージ ：定数変数<定数名>の初期化が定数ではありません 考えられるエラーの原因 ：定数は変数で初期化されます。 エラー訂正 ：定数値のみで定数を初期化します。 エラーの例： PROGRAM PLC_PRG VAR i : INT; END_VAR VAR CONSTANT k : INT := i; END_VAR メッセージ： C0227：定数変数 'k'の初期化が定数ではありません...", 
"body" : "C0227 メッセージ ：定数変数<定数名>の初期化が定数ではありません 考えられるエラーの原因 ：定数は変数で初期化されます。 エラー訂正 ：定数値のみで定数を初期化します。 エラーの例： PROGRAM PLC_PRG\nVAR\n i : INT;\nEND_VAR\nVAR CONSTANT\n k : INT := i;\nEND_VAR\n メッセージ： C0227：定数変数 'k'の初期化が定数ではありません " }, 
{ "title" : "コンパイラエラーC0228 ", 
"url" : "_cds_error_c0228.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0228 ", 
"snippet" : "C0228 メッセージ ：定数変数の初期値なし '<定数名>' 考えられるエラーの原因 ：定数が初期化されていません。 エラー訂正 ：定数を初期化します。 エラーの例： PROGRAM PLC_PRG VAR END_VAR VAR CONSTANT k : INT; END_VAR メッセージ： C0228：定数変数 'k'の初期値がありません エラー訂正： k : INT := 1;...", 
"body" : "C0228 メッセージ ：定数変数の初期値なし '<定数名>' 考えられるエラーの原因 ：定数が初期化されていません。 エラー訂正 ：定数を初期化します。 エラーの例： PROGRAM PLC_PRG\nVAR\nEND_VAR\nVAR CONSTANT\n k : INT;\nEND_VAR\n メッセージ： C0228：定数変数 'k'の初期値がありません エラー訂正： k : INT := 1; " }, 
{ "title" : "コンパイラエラーC0230 ", 
"url" : "_cds_error_c0230.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0230 ", 
"snippet" : "C0230 メッセージ ：タイプ名 '<データ型>'はこの場所では予期されていません 考えられるエラーの原因 ：列挙型のデータ型名が無効な位置で使用されています。 エラー訂正 ：この場所でデータ型名が正しく使用されているか確認してください。スペルミスがあるかもしれません。 エラーの例： TYPE MyEnum : ( enum_member := 0 ); END_TYPE PROGRAM PLC_PRG VAR value : INT; END_VAR value := MyEnum; MyEnum := value; メッセージ： PLC_PRGの場合、エラーメッセージは2回発行されます。...", 
"body" : "C0230 メッセージ ：タイプ名 '<データ型>'はこの場所では予期されていません 考えられるエラーの原因 ：列挙型のデータ型名が無効な位置で使用されています。 エラー訂正 ：この場所でデータ型名が正しく使用されているか確認してください。スペルミスがあるかもしれません。 エラーの例： TYPE MyEnum :\n(\n enum_member := 0\n);\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n value : INT;\nEND_VAR\nvalue := MyEnum;\nMyEnum := value;\n メッセージ： PLC_PRGの場合、エラーメッセージは2回発行されます。 C0230：この場所ではタイプ名 'MyEnum'は予期されていません エラー訂正： value := MyEnum.enum_member;\nMyEnum.enum_member := value; " }, 
{ "title" : "コンパイラエラーC0232 ", 
"url" : "_cds_error_c0232.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0232 ", 
"snippet" : "C0232 メッセージ ：アレイの初期化が必要です 考えられるエラーの原因 ：「配列の配列」は初期化されますが、初期化値はネストされていません。 エラー訂正 ：以下の例に示すように、ネストされた配列の初期化を使用します。 エラーの例： PROGRAM PLC_PRG VAR value : ARRAY[0..2] OF ARRAY[0..2] OF INT := [1,2,3]; END_VAR メッセージ： C0232：アレイの初期化が必要です エラー訂正： value : ARRAY[0..2] OF ARRAY[0..2] OF INT := [ [1,2,3], [4,5,6], [7...", 
"body" : "C0232 メッセージ ：アレイの初期化が必要です 考えられるエラーの原因 ：「配列の配列」は初期化されますが、初期化値はネストされていません。 エラー訂正 ：以下の例に示すように、ネストされた配列の初期化を使用します。 エラーの例： PROGRAM PLC_PRG\nVAR\n value : ARRAY[0..2] OF ARRAY[0..2] OF INT := [1,2,3];\nEND_VAR\n メッセージ： C0232：アレイの初期化が必要です エラー訂正： value : ARRAY[0..2] OF ARRAY[0..2] OF INT := [\n[1,2,3],\n[4,5,6],\n[7,8,9]]; " }, 
{ "title" : "コンパイラエラーC0233 ", 
"url" : "_cds_error_c0233.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0233 ", 
"snippet" : "C0233 メッセージ ：<データ型>の初期化リストが必要です 考えられるエラーの原因 ：構造体のタイプの配列は、構造体の初期化または変数ではない要素で初期化されます。 エラー訂正 ：以下の例に示すように、構造体の初期化または既存の変数を使用して、構造体の配列を初期化します。 エラーの例： PROGRAM PLC_PRG VAR values : ARRAY[0..2] OF COLOR := [1,2,3]; END_VAR メッセージ： C0233：COLORの初期化リストが必要です エラー訂正： PROGRAM PLC_PRG VAR colorVariable : COLOR := (...", 
"body" : "C0233 メッセージ ：<データ型>の初期化リストが必要です 考えられるエラーの原因 ：構造体のタイプの配列は、構造体の初期化または変数ではない要素で初期化されます。 エラー訂正 ：以下の例に示すように、構造体の初期化または既存の変数を使用して、構造体の配列を初期化します。 エラーの例： PROGRAM PLC_PRG\nVAR\n values : ARRAY[0..2] OF COLOR := [1,2,3];\nEND_VAR\n メッセージ： C0233：COLORの初期化リストが必要です エラー訂正： PROGRAM PLC_PRG\nVAR\n colorVariable : COLOR := (red:=0, green:=0, blue:=255);\n value : ARRAY[0..2] OF COLOR := [\n colorVariable,\n (red:=255, green:=0, blue:=0),\n (red:=0, green:=255, blue:=0)];\nEND_VAR " }, 
{ "title" : "コンパイラエラーC0234 ", 
"url" : "_cds_error_c0234.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0234 ", 
"snippet" : "C0234 メッセージ ：__ QueryInterfaceの最初のオペランドは、インターフェイス参照または関数ブロックのインスタンスである必要があります 考えられるエラーの原因 ：不正なオペランドが演算子に渡されます __QueryInterface 。 エラー訂正 ：インターフェイス参照または関数ブロックのインスタンスを渡します。 エラーの例： PROGRAM PLC_PRG VAR a : INT; ITFref, ITFref2 : ITF; ITFref2 : ITF2; END_VAR __QueryInterface(a ,ITFref); INTERFACE ITF EXTEN...", 
"body" : "C0234 メッセージ ：__ QueryInterfaceの最初のオペランドは、インターフェイス参照または関数ブロックのインスタンスである必要があります 考えられるエラーの原因 ：不正なオペランドが演算子に渡されます __QueryInterface 。 エラー訂正 ：インターフェイス参照または関数ブロックのインスタンスを渡します。 エラーの例： PROGRAM PLC_PRG\nVAR\n a : INT;\n ITFref, ITFref2 : ITF;\n ITFref2 : ITF2;\nEND_VAR\n\n__QueryInterface(a ,ITFref);\n\nINTERFACE ITF EXTENDS __SYSTEM.IQueryInterface\nINTERFACE ITF2 EXTENDS ITF\n メッセージ： C0234：__ QueryInterfaceの最初のオペランドは、インターフェイス参照または関数ブロックのインスタンスである必要があります エラー訂正： __QueryInterface(ITFref2, ITFref); " }, 
{ "title" : "コンパイラエラーC0235 ", 
"url" : "_cds_error_c0235.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0235 ", 
"snippet" : "C0235 メッセージ ：__ QueryInterfaceの2番目のオペランドはインターフェイス参照である必要があります 考えられるエラーの原因 ：不正なオペランドが演算子に渡されます __QueryInterface 。 エラー訂正 ：インターフェース参照を渡します。 エラーの例： PROGRAM PLC_PRG VAR a : INT; ITFref, ITFref2 : ITF; ITFref2 : ITF2; END_VAR __QueryInterface(ITFref2, a); INTERFACE ITF EXTENDS __SYSTEM.IQueryInterface INT...", 
"body" : "C0235 メッセージ ：__ QueryInterfaceの2番目のオペランドはインターフェイス参照である必要があります 考えられるエラーの原因 ：不正なオペランドが演算子に渡されます __QueryInterface 。 エラー訂正 ：インターフェース参照を渡します。 エラーの例： PROGRAM PLC_PRG\nVAR\n a : INT;\n ITFref, ITFref2 : ITF;\n ITFref2 : ITF2;\nEND_VAR\n\n__QueryInterface(ITFref2, a);\n\nINTERFACE ITF EXTENDS __SYSTEM.IQueryInterface\nINTERFACE ITF2 EXTENDS ITF\n メッセージ： C0235：__ QueryInterfaceの2番目のオペランドはインターフェイス参照である必要があります エラー訂正： __QueryInterface(ITFref2, ITFref); " }, 
{ "title" : "コンパイラエラーC0236 ", 
"url" : "_cds_error_c0236.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0236 ", 
"snippet" : "C0236 メッセージ ：VAR_EXTERNAL <変数名>の型定義が間違っています 考えられるエラーの原因 ：変数はで宣言されています VAR_GLOBAL \/ VAR_EXTERNAL 異なるタイプとして。 エラー訂正 ：で同じ型定義を使用する VAR_GLOBAL と VAR_EXTERNAL 。 エラーの例： PROGRAM PLC_PRG VAR_EXTERNAL ig : STRING; END_VAR VAR_GLOBAL ig : INT; END_VAR メッセージ： C0236：VAR_EXTERNALigのタイプ定義が間違っています...", 
"body" : "C0236 メッセージ ：VAR_EXTERNAL <変数名>の型定義が間違っています 考えられるエラーの原因 ：変数はで宣言されています VAR_GLOBAL \/ VAR_EXTERNAL 異なるタイプとして。 エラー訂正 ：で同じ型定義を使用する VAR_GLOBAL と VAR_EXTERNAL 。 エラーの例： PROGRAM PLC_PRG\nVAR_EXTERNAL\n ig : STRING;\nEND_VAR\n\nVAR_GLOBAL\n ig : INT;\nEND_VAR\n メッセージ： C0236：VAR_EXTERNALigのタイプ定義が間違っています " }, 
{ "title" : "コンパイラエラーC0237 ", 
"url" : "_cds_error_c0237.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0237 ", 
"snippet" : "C0237 メッセージ ：VAR_EXTERNALのグローバル定義が見つかりません '<変数名>' 考えられるエラーの原因 ：で変数を宣言しようとしました VAR_EXTERNAL に存在しない VAR_GLOBAL 。 エラー訂正 ：識別子が一致していることを確認してください。 エラーの例： PROGRAM PLC_PRG VAR_EXTERNAL i : INT; END_VAR VAR_GLOBAL ig : INT; END_VAR メッセージ： C0237：VAR_EXTERNAL'i 'のグローバル定義が見つかりません...", 
"body" : "C0237 メッセージ ：VAR_EXTERNALのグローバル定義が見つかりません '<変数名>' 考えられるエラーの原因 ：で変数を宣言しようとしました VAR_EXTERNAL に存在しない VAR_GLOBAL 。 エラー訂正 ：識別子が一致していることを確認してください。 エラーの例： PROGRAM PLC_PRG\nVAR_EXTERNAL\n i : INT;\nEND_VAR\n\nVAR_GLOBAL\n ig : INT;\nEND_VAR\n メッセージ： C0237：VAR_EXTERNAL'i 'のグローバル定義が見つかりません " }, 
{ "title" : "コンパイラエラーC0238 ", 
"url" : "_cds_error_c0238.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0238 ", 
"snippet" : "C0238 メッセージ ：VAR_EXTERNAL <変数名>の初期値は許可されていません 考えられるエラーの原因 ：で変数を初期化しようとしました VAR_EXTERNAL 。 エラー訂正 ：変数を初期化しないでください VAR_EXTERNAL 。 エラーの例： PROGRAM PLC_PRG VAR_EXTERNAL ig : INT := 2; END_VAR VAR_GLOBAL ig : INT; END_VAR メッセージ： C0238：VAR_EXTERNALigに初期値は許可されていません...", 
"body" : "C0238 メッセージ ：VAR_EXTERNAL <変数名>の初期値は許可されていません 考えられるエラーの原因 ：で変数を初期化しようとしました VAR_EXTERNAL 。 エラー訂正 ：変数を初期化しないでください VAR_EXTERNAL 。 エラーの例： PROGRAM PLC_PRG\nVAR_EXTERNAL\n ig : INT := 2;\nEND_VAR\n\nVAR_GLOBAL\n ig : INT;\nEND_VAR\n メッセージ： C0238：VAR_EXTERNALigに初期値は許可されていません " }, 
{ "title" : "コンパイラ エラー C0239 ", 
"url" : "_cds_error_c0239.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ エラー C0239 ", 
"snippet" : "C0239 メッセージ : インターフェイス <インターフェイス名 1> は <インターフェイス名 2> を拡張しません 考えられるエラー原因 : 使用されているインターフェースは別のインターフェースを拡張していません。 エラー訂正 : インターフェイスを拡張します。 エラーの例: PROGRAM PLC_PRG VAR ITFref : ITF; ITFref2 : ITF2; END_VAR __QueryInterface(ITFref2,ITFref); INTERFACE ITF INTERFACE ITF2 EXTENDS ITF メッセージ： C0239: インターフェイス IT...", 
"body" : "C0239 メッセージ : インターフェイス <インターフェイス名 1> は <インターフェイス名 2> を拡張しません 考えられるエラー原因 : 使用されているインターフェースは別のインターフェースを拡張していません。 エラー訂正 : インターフェイスを拡張します。 エラーの例: PROGRAM PLC_PRG\nVAR\n ITFref : ITF;\n ITFref2 : ITF2;\nEND_VAR\n\n__QueryInterface(ITFref2,ITFref);\n\nINTERFACE ITF\nINTERFACE ITF2 EXTENDS ITF\n メッセージ： C0239: インターフェイス ITF は __System.IQueryInterface を拡張しません エラー訂正: INTERFACE ITF EXTENDS __System.IQueryInterface " }, 
{ "title" : "コンパイラエラーC0240 ", 
"url" : "_cds_error_c0240.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0240 ", 
"snippet" : "C0240 メッセージ ：__ QueryPointerの最初のオペランドは、インターフェイス参照または関数ブロックのインスタンスである必要があります 考えられるエラーの原因 ：不正なオペランドが演算子に渡されます __QueryPointer 。 エラー訂正 ：インターフェイス参照または関数ブロックのインスタンスを渡します。 エラーの例： PROGRAM PLC_PRG VAR a : INT; ITFref : ITF; pt : POINTER TO FB; END_VAR __QueryPointer(a,pt); メッセージ： C0240：__ QueryPointerの最初のオペラ...", 
"body" : "C0240 メッセージ ：__ QueryPointerの最初のオペランドは、インターフェイス参照または関数ブロックのインスタンスである必要があります 考えられるエラーの原因 ：不正なオペランドが演算子に渡されます __QueryPointer 。 エラー訂正 ：インターフェイス参照または関数ブロックのインスタンスを渡します。 エラーの例： PROGRAM PLC_PRG\nVAR\n a : INT;\n ITFref : ITF;\n pt : POINTER TO FB;\nEND_VAR\n\n__QueryPointer(a,pt);\n メッセージ： C0240：__ QueryPointerの最初のオペランドは、インターフェイス参照または関数ブロックのインスタンスである必要があります エラー訂正： __QueryPointer (ITFref, pt); " }, 
{ "title" : "コンパイラエラーC0241 ", 
"url" : "_cds_error_c0241.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0241 ", 
"snippet" : "C0241 メッセージ ：__ QueryPointerの2番目のオペランドはポインタである必要があります 考えられるエラーの原因 ：不正なオペランドが演算子に渡されます __QueryPointer 。 エラー訂正 ：ポインタを渡します。 エラーの例： PROGRAM PLC_PRG VAR b : INT; ITFref : ITF; pt : POINTER TO FB; END_VAR __QueryPointer(ITFref,b); INTERFACE ITF EXTENDS __System.IQueryInterface メッセージ： C0241：__ QueryPointer...", 
"body" : "C0241 メッセージ ：__ QueryPointerの2番目のオペランドはポインタである必要があります 考えられるエラーの原因 ：不正なオペランドが演算子に渡されます __QueryPointer 。 エラー訂正 ：ポインタを渡します。 エラーの例： PROGRAM PLC_PRG\nVAR\n b : INT;\n ITFref : ITF;\n pt : POINTER TO FB;\nEND_VAR\n\n__QueryPointer(ITFref,b);\n\nINTERFACE ITF EXTENDS __System.IQueryInterface\n メッセージ： C0241：__ QueryPointerの2番目のオペランドはポインタである必要があります エラー訂正： __QueryPointer (ITFref, pt); " }, 
{ "title" : "コンパイラエラーC0242 ", 
"url" : "_cds_error_c0242.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0242 ", 
"snippet" : "C0242 メッセージ ：__ DELETEのオペランドはポインタである必要があります 考えられるエラーの原因 ：誤ったオペランドが演算子に渡されました __DELETE 。 エラー訂正 ：ポインタを渡します。 エラーの例： PROGRAM PLC_PRG VAR a : INT; pt : POINTER TO INT; END_VAR __DELETE(a); メッセージ： C0242：__ DELETEのオペランドはポインタである必要があります エラー訂正： __DELETE (pt);...", 
"body" : "C0242 メッセージ ：__ DELETEのオペランドはポインタである必要があります 考えられるエラーの原因 ：誤ったオペランドが演算子に渡されました __DELETE 。 エラー訂正 ：ポインタを渡します。 エラーの例： PROGRAM PLC_PRG\nVAR\n a : INT;\n pt : POINTER TO INT;\nEND_VAR\n\n__DELETE(a);\n メッセージ： C0242：__ DELETEのオペランドはポインタである必要があります エラー訂正： __DELETE (pt); " }, 
{ "title" : "コンパイラエラーC0243 ", 
"url" : "_cds_error_c0243.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0243 ", 
"snippet" : "C0243 メッセージ ：署名に使用されている名前がオブジェクト名と同じではありません 考えられるエラーの原因 ：オブジェクト名がコードで使用されている名前と異なります。 エラー訂正 ：名前が同じであることを確認してください。 エラーの例：...", 
"body" : "C0243 メッセージ ：署名に使用されている名前がオブジェクト名と同じではありません 考えられるエラーの原因 ：オブジェクト名がコードで使用されている名前と異なります。 エラー訂正 ：名前が同じであることを確認してください。 エラーの例： " }, 
{ "title" : "コンパイラ警告 C0266 ", 
"url" : "_cds_error_c0266.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0266 ", 
"snippet" : "0266 メッセージ : ループ終了条件 '' は定数 FALSE . です。無限ループの可能性あり。 考えられるエラー原因 : で FOR ループ、反復は制御変数の値の範囲全体で行われます。 エラー訂正 : IEC 61131 規格に従い、記載されているステートメント FOR ループは、制御変数の値が最終値を上回った場合にのみ実行されます。したがって、制御変数には、最終値+1をマッピングできる十分な大きさの型を使用してください 警告の例 PROGRAM PLC_PRG VAR       b : BYTE;       i : INT; END_VAR FOR b := 0 TO 255 B...", 
"body" : "0266 メッセージ : ループ終了条件 '' は定数 FALSE . です。無限ループの可能性あり。 考えられるエラー原因 : で FOR ループ、反復は制御変数の値の範囲全体で行われます。 エラー訂正 : IEC 61131 規格に従い、記載されているステートメント FOR ループは、制御変数の値が最終値を上回った場合にのみ実行されます。したがって、制御変数には、最終値+1をマッピングできる十分な大きさの型を使用してください 警告の例 PROGRAM PLC_PRG\nVAR\n      b : BYTE;\n      i : INT;\nEND_VAR\nFOR b := 0 TO 255 BY 1 DO\n      i := i + 1;\nEND_FOR;\n メッセージ C0266: ループ終了条件 'b > 255' は定数 FALSE です。無限ループが可能です " }, 
{ "title" : "コンパイラ警告 C0269 ", 
"url" : "_cds_error_c0269.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0269 ", 
"snippet" : "C0269 メッセージ : <ポインタ再参照> が指すインスタンスは、仮想関数呼び出しのために再初期化されます。<ポインタ再参照> が <ベースFB> から派生した型を指していないことを確認してください。 考えられるエラーの原因 : 派生関数ブロックのアドレスは、基本関数ブロックのアドレスとして使用されます。 警告の例 FUNCTION_BLOCK FBBase ... FUNCTION_BLOCK FBDerived EXTENDS FBBase ... FUNCTION_BLOCK FB EXTENDS Base_FB ... PROGRAM PLC_PRG VAR       pinst...", 
"body" : "C0269 メッセージ : <ポインタ再参照> が指すインスタンスは、仮想関数呼び出しのために再初期化されます。<ポインタ再参照> が <ベースFB> から派生した型を指していないことを確認してください。 考えられるエラーの原因 : 派生関数ブロックのアドレスは、基本関数ブロックのアドレスとして使用されます。 警告の例 FUNCTION_BLOCK FBBase\n...\n\nFUNCTION_BLOCK FBDerived EXTENDS FBBase\n...\n\nFUNCTION_BLOCK FB EXTENDS Base_FB\n...\nPROGRAM PLC_PRG\nVAR\n      pinst : POINTER TO FBBase;\n      inst2_2 : FBDerived;\nEND_VAR\npinst := ADR(inst2_2);\npinst^ := inst2_2;\n ポインタの逆参照により次の警告が生成されます。 メッセージ： C0269 : pinst^ が指すインスタンスは、仮想関数呼び出しのために再初期化されます。pinst^ が FBBase から派生した型を指していないことを確認してください。 : " }, 
{ "title" : "コンパイラ警告 C0298 ", 
"url" : "_cds_error_c0298.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0298 ", 
"snippet" : "C0298 メッセージ : '<再帰メソッド名' から始まる再帰呼び出しのため、スタック使用量の計算が完了しませんでした。 考えられる原因 : スタック使用量を判別できないため、再帰呼び出しのあるメソッドではスタック チェックを正常に実行できません。 エラー訂正 ： 使用 estimated-stack-usage メソッドにスタック サイズ要件の推定値 (バイト単位) を与える属性。 エラーの例: METHOD PUBLIC m_Recursive : UDINT VAR_INPUT uiN : UINT; END_VAR VAR END_VAR m_Recursive := 1; IF u...", 
"body" : "C0298 メッセージ : '<再帰メソッド名' から始まる再帰呼び出しのため、スタック使用量の計算が完了しませんでした。 考えられる原因 : スタック使用量を判別できないため、再帰呼び出しのあるメソッドではスタック チェックを正常に実行できません。 エラー訂正 ： 使用 estimated-stack-usage メソッドにスタック サイズ要件の推定値 (バイト単位) を与える属性。 エラーの例: METHOD PUBLIC m_Recursive : UDINT\n VAR_INPUT\n uiN : UINT;\n END_VAR\n VAR\n END_VAR\n m_Recursive := 1;\n IF uiN > 1 THEN\n m_Recursive := uiN * THIS^.m_Recursive(uiN := (uiN - 1) );\n RETURN;\n ELSE\n RETURN;\n END_IF; メッセージ： C0298: 'm_Recursive' から始まる再帰呼び出しのため、スタック使用量の計算が不完全です エラー訂正: {attribute 'estimated-stack-usage' := '99'} 詳細については、以下を参照してください。 estimated-stack-usage" }, 
{ "title" : "コンパイラ警告 C0316 ", 
"url" : "_cds_error_c0316.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0316 ", 
"snippet" : "0316 メッセージ : メソッドはすでに暗黙的に呼び出されている 考えられるエラー原因 : ザ・ FB_Exit ベースファンクションブロックのメソッドは、で呼び出されます。 FB_Exit 派生ブロックの。 エラー訂正 : 内のコールを削除する FB_Exit メソッド。 警告の例 FUNCTION_BLOCK Base_FB... METHOD FB_Exit: BOOL VAR_INPUT       bInCopyCode : BOOL; END_VAR FUNCTION_BLOCK FB EXTENDS Base_FB ... METHOD FB_Exit : BOOL VAR_I...", 
"body" : "0316 メッセージ : メソッドはすでに暗黙的に呼び出されている 考えられるエラー原因 : ザ・ FB_Exit ベースファンクションブロックのメソッドは、で呼び出されます。 FB_Exit 派生ブロックの。 エラー訂正 : 内のコールを削除する FB_Exit メソッド。 警告の例 FUNCTION_BLOCK Base_FB...\nMETHOD FB_Exit: BOOL\nVAR_INPUT\n      bInCopyCode : BOOL;\nEND_VAR\n\nFUNCTION_BLOCK FB EXTENDS Base_FB\n...\nMETHOD FB_Exit : BOOL\nVAR_INPUT\n      bInCopyCode : BOOL;\nEND_VAR\nSUPER^.FB_Exit(bInCopyCode); \n のステートメント FB_Exit メソッドを実行すると、次の警告が表示されます。 メッセージ: C0316: メソッド 'FB_exit' はすでに暗黙的に呼び出されています " }, 
{ "title" : "コンパイラ エラー C0319 ", 
"url" : "_cds_error_c0319.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ エラー C0319 ", 
"snippet" : "C0319 メッセージ : <> インターフェイス ライブラリでは許可されていません この警告は、インターフェイス ライブラリに適用される規則が守られていない場合に表示されます。これらの規則の詳細については、次を参照してください。 インターフェイス ライブラリ...", 
"body" : "C0319 メッセージ : <> インターフェイス ライブラリでは許可されていません この警告は、インターフェイス ライブラリに適用される規則が守られていない場合に表示されます。これらの規則の詳細については、次を参照してください。 インターフェイス ライブラリ " }, 
{ "title" : "コンパイラ警告 C0344 ", 
"url" : "_cds_error_c0344.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0344 ", 
"snippet" : "0344 メッセージ : このモニタリング属性は、プロパティ '<プロパティ名>' には対応しておらず、無視されます。 考えられるエラー原因 : プロパティにモニタリング属性がある 'call' そして構造体を返す。 エラー訂正 : モニタリング属性を使用する 'variable' 。 警告の例 TYPE ST_Test :STRUCT       a,b : INT;  END_STRUCT END_TYPE FUNCTION_BLOCK FB_Test ... {attribute 'monitoring' := 'call'} PROPERTY TestProp : ST_Test プロ...", 
"body" : "0344 メッセージ : このモニタリング属性は、プロパティ '<プロパティ名>' には対応しておらず、無視されます。 考えられるエラー原因 : プロパティにモニタリング属性がある 'call' そして構造体を返す。 エラー訂正 : モニタリング属性を使用する 'variable' 。 警告の例 TYPE ST_Test :STRUCT\n      a,b : INT;  \nEND_STRUCT\nEND_TYPE\n\nFUNCTION_BLOCK FB_Test\n...\n\n{attribute 'monitoring' := 'call'}\nPROPERTY TestProp : ST_Test\n プロパティの宣言 TestProp 次の警告が表示されます。 メッセージ: C0344: モニタリング属性はプロパティ 'TestProp' ではサポートされていないので無視されます。 " }, 
{ "title" : "コンパイラ警告 C0351 ", 
"url" : "_cds_error_c0351.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0351 ", 
"snippet" : "0351 メッセージ: 属性<は不明であり、コンパイラは無視する。 考えられるエラー原因 : 属性名にスペルミスがあります。 エラー訂正 : 定義済みの属性を使用している場合は、その属性のスペルが正しいことを確認してください (例: call_after_init )。 警告の例 {attribute 'call_after_ini'} PROGRAM PLC_PRG VAR END_VAR メッセージ: C0351: 属性call_after_iniが不明なのでコンパイラによって無視されます...", 
"body" : "0351 メッセージ: 属性<は不明であり、コンパイラは無視する。 考えられるエラー原因 : 属性名にスペルミスがあります。 エラー訂正 : 定義済みの属性を使用している場合は、その属性のスペルが正しいことを確認してください (例: call_after_init )。 警告の例 {attribute 'call_after_ini'}\nPROGRAM PLC_PRG\nVAR\nEND_VAR\n メッセージ: C0351: 属性call_after_iniが不明なのでコンパイラによって無視されます " }, 
{ "title" : "コンパイラ警告 C0354 ", 
"url" : "_cds_error_c0354.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0354 ", 
"snippet" : "0354 メッセージ : ある列挙型 (<型名1>) と別の列挙型（<型名2>) の比較 考えられるエラー原因 : 比較演算子では列挙型が使用されます。 エラー訂正 : 定義済みの整数データ型を使用する (例: INT プログラムコードの列挙型の代わりに)。 列挙変数の値を補助変数にコピーします (例: INT 変数) を選択し、比較演算子で補助変数を使用します。 警告の例 {attribute 'qualified_only'} {attribute 'strict'} TYPE ENUM1: (       enum_member1 := 0,       enum_member2 := ...", 
"body" : "0354 メッセージ : ある列挙型 (<型名1>) と別の列挙型（<型名2>) の比較 考えられるエラー原因 : 比較演算子では列挙型が使用されます。 エラー訂正 : 定義済みの整数データ型を使用する (例: INT プログラムコードの列挙型の代わりに)。 列挙変数の値を補助変数にコピーします (例: INT 変数) を選択し、比較演算子で補助変数を使用します。 警告の例 {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE ENUM1:\n(\n      enum_member1 := 0,\n      enum_member2 := 1\n);\nEND_TYPE\n\n{attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE ENUM2:\n(\n      enum_member := 0\n);\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n      enum1 : ENUM1;\n      enum2 : ENUM2;\n      i:INT;\nEND_VAR\nenum1 := 0;\nenum2 := 0;\nIF enum1 > enum2 THEN\n      i := 1;\nEND_IF;\n ザル IF ステートメントは次の警告を生成します。 メッセージ: C0354: ある列挙型 (ENUM1) と別の列挙型 (ENUM2) との比較 " }, 
{ "title" : "コンパイラ警告 C0355 ", 
"url" : "_cds_error_c0355.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0355 ", 
"snippet" : "0355 メッセージ : 1 ビットだけは参照できません。バイト全体への参照が格納されます。 考えられるエラー原因 : ビットのアドレスを特定しようとしました。 警告の例 FUNCTION_BLOCK FBVAR       pt : POINTER TO BOOL;       b : BIT; END_VAR pt := ADR(b); メッセージ: 1 ビットは参照できません。バイト全体への参照が格納されます。...", 
"body" : "0355 メッセージ : 1 ビットだけは参照できません。バイト全体への参照が格納されます。 考えられるエラー原因 : ビットのアドレスを特定しようとしました。 警告の例 FUNCTION_BLOCK FBVAR\n      pt : POINTER TO BOOL;\n      b : BIT;\nEND_VAR\npt := ADR(b); メッセージ: 1 ビットは参照できません。バイト全体への参照が格納されます。 " }, 
{ "title" : "コンパイラ警告 C0357 ", 
"url" : "_cds_error_c0357.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0357 ", 
"snippet" : "0357 メッセージ : POU ''は廃止されました： <メッセージテキスト 考えられるエラー原因 : POU には以下の属性が付加されている 'obsolete' ですが、プログラムではまだ使われています。 エラー訂正 : POU から属性を削除するか、もう使用しないでください。 警告の例 {attribute 'obsolete':= 'datatype fb not valid!'} FUNCTION_BLOCK FB_Test PROGRAM PLC_PRG VAR       inst : FB_Test; END_VAR 変数の宣言 inst 次の警告が表示されます。 メッセージ...", 
"body" : "0357 メッセージ : POU ''は廃止されました： <メッセージテキスト 考えられるエラー原因 : POU には以下の属性が付加されている 'obsolete' ですが、プログラムではまだ使われています。 エラー訂正 : POU から属性を削除するか、もう使用しないでください。 警告の例 {attribute 'obsolete':= 'datatype fb not valid!'}\nFUNCTION_BLOCK FB_Test\n\nPROGRAM PLC_PRG\nVAR\n      inst : FB_Test;\nEND_VAR 変数の宣言 inst 次の警告が表示されます。 メッセージ: C0357: POU 'FB_Test' は廃止済みとしてマークされています:データ型 fb は無効です! " }, 
{ "title" : "コンパイラ警告 C0371 ", 
"url" : "_cds_error_c0371.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0371 ", 
"snippet" : "0371 メッセージ : 外部コンテキスト''から''で宣言されたVAR_IN_OUT ''にアクセスする。 考えられるエラー原因 : A VAR_IN_OUT POU の POU は POU のメソッドでアクセスされます。 エラー訂正 : 変数の宣言を変更するか、代入を削除してください。 警告の例 FUNCTION_BLOCK FB_Test VAR_IN_OUT       bInOut : BOOL; END_VAR METHOD METH: BOOL VAR       bBool : BOOL; END_VAR bInOut := bBool; メソッドに代入すると、次の警告が表示さ...", 
"body" : "0371 メッセージ : 外部コンテキスト''から''で宣言されたVAR_IN_OUT ''にアクセスする。 考えられるエラー原因 : A VAR_IN_OUT POU の POU は POU のメソッドでアクセスされます。 エラー訂正 : 変数の宣言を変更するか、代入を削除してください。 警告の例 FUNCTION_BLOCK FB_Test\nVAR_IN_OUT\n      bInOut : BOOL;\nEND_VAR\n\nMETHOD METH: BOOL\nVAR\n      bBool : BOOL;\nEND_VAR\nbInOut := bBool; メソッドに代入すると、次の警告が表示されます。 メッセージ: C0371: 外部コンテキスト 'METH' から 'FB_Test' で宣言された VAR_IN_OUT 'BINOUT' へのアクセス " }, 
{ "title" : "コンパイラ警告 C0373 ", 
"url" : "_cds_error_c0373.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0373 ", 
"snippet" : "0373 メッセージ : プログラムコードで定義されたカスタムメッセージの表示 warning プラグマ。 例 PROGRAM PLC_PRG VAR END_VAR {warning 'This is a warning'} このプラグマは次の警告を生成します。 C0373:  This is a warning 詳細については、以下を参照してください。 メッセージプラグマ...", 
"body" : "0373 メッセージ : プログラムコードで定義されたカスタムメッセージの表示 warning プラグマ。 例 PROGRAM PLC_PRG\nVAR\nEND_VAR\n{warning 'This is a warning'} このプラグマは次の警告を生成します。 C0373:  This is a warning 詳細については、以下を参照してください。 メッセージプラグマ" }, 
{ "title" : "コンパイラエラーC0380 ", 
"url" : "_cds_error_c0380.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0380 ", 
"snippet" : "C0380 メッセージ ：演算子LOWER_BOUNDおよびUPPER_BOUNDは、可変長の配列でのみサポートされます。 考えられるエラーの原因 ：2つの演算子LOWER_BOUNDまたはUPPER_BOUNDのいずれかは、可変長の配列には使用されません。 エラー訂正 ：演算子LOWER_BOUNDおよびUPPER_BOUNDは、可変長の配列に対してのみ使用してください。 コンパイラバージョン3.5.14.0以降では、演算子は静的配列にも使用できます。その結果、エラーC0380は、以前のバージョンのコンパイラの場合にのみ発生します。 エラーの例： FUNCTION_BLOCK POU VAR...", 
"body" : "C0380 メッセージ ：演算子LOWER_BOUNDおよびUPPER_BOUNDは、可変長の配列でのみサポートされます。 考えられるエラーの原因 ：2つの演算子LOWER_BOUNDまたはUPPER_BOUNDのいずれかは、可変長の配列には使用されません。 エラー訂正 ：演算子LOWER_BOUNDおよびUPPER_BOUNDは、可変長の配列に対してのみ使用してください。 コンパイラバージョン3.5.14.0以降では、演算子は静的配列にも使用できます。その結果、エラーC0380は、以前のバージョンのコンパイラの場合にのみ発生します。 エラーの例： FUNCTION_BLOCK POU\nVAR_IN_OUT\n arrin : ARRAY [*] OF INT;\nEND_VAR\nVAR\n arrtest : ARRAY [0..5] OF INT;\n test1: DINT;\n test2: DINT;\nEND_VAR\n\ntest1 := UPPER_BOUND(arrin, 1);\ntest2 := UPPER_BOUND(arrtest, 1);\n メッセージ： C0380：演算子LOWER_BOUNDおよびUPPER_BOUNDは、可変長の配列でのみサポートされます。 " }, 
{ "title" : "コンパイラ エラー C0398 ", 
"url" : "_cds_error_c0398.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ エラー C0398 ", 
"snippet" : "C0398 メッセージ : 開発システムには、オンライン変更を処理するのに十分なメモリがありません。開発を続行する前にアプリケーションを再起動してください。 考えられるエラーの原因 : 開発用コンピュータ上でコンパイラに使用できるメモリが不足しています。 エラー訂正 ：64ビット版を使用してください。 CODESYS 開発環境として使用することも、サイズを大幅に縮小することもできます。 CODESYS プロジェクト。...", 
"body" : "C0398 メッセージ : 開発システムには、オンライン変更を処理するのに十分なメモリがありません。開発を続行する前にアプリケーションを再起動してください。 考えられるエラーの原因 : 開発用コンピュータ上でコンパイラに使用できるメモリが不足しています。 エラー訂正 ：64ビット版を使用してください。 CODESYS 開発環境として使用することも、サイズを大幅に縮小することもできます。 CODESYS プロジェクト。 " }, 
{ "title" : "コンパイラ警告 C0406 ", 
"url" : "_cds_error_c0406.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0406 ", 
"snippet" : "0406 メッセージ : 暗黙のチェック関数 '<チェック関数の名前>' は別の変数または関数によって隠されています。チェックは実行されません!コンフリクトを解決し、アプリケーションをクリーンアップしてチェック機能を使用してください。 考えられるエラー原因 : POU のメソッドが暗黙のチェック関数と同じ名前です。 エラー訂正 : メソッドの名前を変更するか、暗黙的なチェック関数を削除してください。 警告の例 \/\/ Automatically generated code: Do not edit FUNCTION CheckBounds: DINT VAR_INPUT       index...", 
"body" : "0406 メッセージ : 暗黙のチェック関数 '<チェック関数の名前>' は別の変数または関数によって隠されています。チェックは実行されません!コンフリクトを解決し、アプリケーションをクリーンアップしてチェック機能を使用してください。 考えられるエラー原因 : POU のメソッドが暗黙のチェック関数と同じ名前です。 エラー訂正 : メソッドの名前を変更するか、暗黙的なチェック関数を削除してください。 警告の例 \/\/ Automatically generated code: Do not edit\nFUNCTION CheckBounds: DINT\nVAR_INPUT\n      index, lower, upper:DINT;\nEND_VAR\n\nFUNCTION_BLOCK TestFB\nVAR\n      a:ARRAY [0..1] OF INT;\n      i : INT;\nEND_VAR\na[i] := i;\n\nMETHOD CheckBounds:DINT\nVAR_INPUT\n      index, lower, upper : DINT;\nEND_VAR での配列アクセス TestFB ファンクションブロックは次の警告を生成します。 メッセージ: C0406: 暗黙のチェック関数 'CHECKBOUNDS' が他の変数または関数によって隠されています。チェックは実行されません!コンフリクトを解決し、アプリケーションをクリーンアップしてチェック機能を使用してください。 " }, 
{ "title" : "コンパイラ エラー C0415 ", 
"url" : "_cds_error_c0415.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ エラー C0415 ", 
"snippet" : "C0415 一般に、永続変数は絶対に必要な場合にのみ使用する必要があります。 メッセージ : 永続メモリが不足しています。変数 '<変数名>'、<count> バイト (最大の連続メモリ ギャップ <サイズ>)。永続変数リストを編集すると、メモリが断片化される可能性があります。永続変数リストを圧縮するには、「宣言、リストの順序変更、ギャップのクリア」コマンドを実行してください。 考えられるエラーの原因 : 開発用コンピューターにコンパイラーに使用できるメモリが不足しています。 永続メモリは、ダウンロード後も値を保持する変数を対象としています。これは、変数の型が変更されない場合にのみ有効です。し...", 
"body" : "C0415 一般に、永続変数は絶対に必要な場合にのみ使用する必要があります。 メッセージ : 永続メモリが不足しています。変数 '<変数名>'、<count> バイト (最大の連続メモリ ギャップ <サイズ>)。永続変数リストを編集すると、メモリが断片化される可能性があります。永続変数リストを圧縮するには、「宣言、リストの順序変更、ギャップのクリア」コマンドを実行してください。 考えられるエラーの原因 : 開発用コンピューターにコンパイラーに使用できるメモリが不足しています。 永続メモリは、ダウンロード後も値を保持する変数を対象としています。これは、変数の型が変更されない場合にのみ有効です。したがって、複雑なデータ型 (構造体や構造体の配列など) を持つ変数は、永続領域にできるだけ少なくマップする必要があります。このような変数が変更されると、永続データに大きなギャップが生じ、このエラーが発生する可能性があります。 エラー訂正 : 次の操作でエラーを修正できます。 リストの順序を変更してギャップを解消する コマンドを実行して、永続変数の順序を変更し、メモリを再割り当てします。その後、永続変数は再初期化されます。これを避けたい場合は、 現在の値をレシピに保存 現在の値を確認するには、コマンドを実行します。新しいダウンロード後、 レシピから値を復元する 値を復元するコマンド。 詳細については、コマンドを参照してください。 リストを並べ替えてギャップをクリーンアップします、 指示 レシピから値を復元する" }, 
{ "title" : "コンパイラ警告 C0421 ", 
"url" : "_cds_error_c0421.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0421 ", 
"snippet" : "0421 メッセージ : キーワードを使う EXTENDS インターフェースの代わりにインターフェースを継承するため IMPLEMENTS 考えられるエラー原因 : あるインタフェースが別のインタフェースを拡張しているが、そのインタフェースが使用されている IMPLEMENTS キーワード。 エラー訂正 : 交換してください IMPLEMENTS キーワードに EXTENDS キーワード。 警告の例 INTERFACE ITF INTERFACE ITF_1 IMPLEMENTS ITF インターフェースの宣言 ITF_1 次の警告が表示されます。 メッセージ: C0421: インタフェースの...", 
"body" : "0421 メッセージ : キーワードを使う EXTENDS インターフェースの代わりにインターフェースを継承するため IMPLEMENTS 考えられるエラー原因 : あるインタフェースが別のインタフェースを拡張しているが、そのインタフェースが使用されている IMPLEMENTS キーワード。 エラー訂正 : 交換してください IMPLEMENTS キーワードに EXTENDS キーワード。 警告の例 INTERFACE ITF\n\nINTERFACE ITF_1 IMPLEMENTS ITF\n インターフェースの宣言 ITF_1 次の警告が表示されます。 メッセージ: C0421: インタフェースの継承には、実装の代わりにキーワード EXTENDS を使用する " }, 
{ "title" : "コンパイラ警告 C0426 ", 
"url" : "_cds_error_c0426.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0426 ", 
"snippet" : "0426 メッセージ : 少なくとも 1 つのステートメントが必要です 考えられるエラー原因 : A CASE ステートメントには空が含まれています。 CASE ラベル。 エラー訂正 : 空の部分を削除する CASE これにラベルを付けるか、ステートメントを追加してください。 CASE ラベル。 警告の例 PROGRAM PLC_PRG VAR       nVar:INT; END_VAR CASE nVar OF       1:       2:          nVar := nVar + 1; END_CASE ザック CASE ラベルには次の警告が表示されます。 メッセージ: C...", 
"body" : "0426 メッセージ : 少なくとも 1 つのステートメントが必要です 考えられるエラー原因 : A CASE ステートメントには空が含まれています。 CASE ラベル。 エラー訂正 : 空の部分を削除する CASE これにラベルを付けるか、ステートメントを追加してください。 CASE ラベル。 警告の例 PROGRAM PLC_PRG\nVAR\n      nVar:INT;\nEND_VAR\n\nCASE nVar OF\n      1:\n      2:\n         nVar := nVar + 1;\nEND_CASE\n ザック CASE ラベルには次の警告が表示されます。 メッセージ: C0426: 少なくとも 1 つのステートメントが必要です " }, 
{ "title" : "コンパイラ警告 C0441 ", 
"url" : "_cds_error_c0441.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0441 ", 
"snippet" : "0441 メッセージ : 初期化されていないファイルへのアクセス VAR_IN_OUT 変数 考えられるエラー原因 : A VAR_IN_OUT 変数は別の変数宣言の初期値として使用されます。 エラー訂正 : 初期値を削除し、実装部の変数に値を割り当てます。 警告の例 FUNCTION_BLOCK POU VAR_INPUT       i:INT; END_VAR VAR_OUTPUT       b:BOOL := a[i]; END_VAR VAR_IN_OUT       a:ARRAY [1..5] OF BOOL; END_VAR 変数の初期値 b 次の警告が表示されます。 メッセ...", 
"body" : "0441 メッセージ : 初期化されていないファイルへのアクセス VAR_IN_OUT 変数 考えられるエラー原因 : A VAR_IN_OUT 変数は別の変数宣言の初期値として使用されます。 エラー訂正 : 初期値を削除し、実装部の変数に値を割り当てます。 警告の例 FUNCTION_BLOCK POU\nVAR_INPUT\n      i:INT;\nEND_VAR\nVAR_OUTPUT\n      b:BOOL := a[i];\nEND_VAR\nVAR_IN_OUT\n      a:ARRAY [1..5] OF BOOL;\nEND_VAR\n 変数の初期値 b 次の警告が表示されます。 メッセージ: C0441: 初期化されていない VAR_IN_OUT 変数へのアクセス " }, 
{ "title" : "コンパイラ警告 C0508 ", 
"url" : "_cds_error_c0508.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0508 ", 
"snippet" : "0508 メッセージ : 名前「<識別子>」の曖昧な使用 考えられるエラー原因 : プログラムのローカル変数は、プログラムのアクションと同じ名前です。 エラー訂正 : ローカル変数の名前を変更します。 警告の例 FUNCTION_BLOCK FBRead_Var VAR_INPUT END_VAR ... PROGRAM PLC_PRG VAR     read_input : FBRead_Var; END_VAR read_input(); \/\/ Call of the action read_input 変数の宣言 read_input 次の警告が表示されます。 メッセージ: C0508...", 
"body" : "0508 メッセージ : 名前「<識別子>」の曖昧な使用 考えられるエラー原因 : プログラムのローカル変数は、プログラムのアクションと同じ名前です。 エラー訂正 : ローカル変数の名前を変更します。 警告の例 FUNCTION_BLOCK FBRead_Var\nVAR_INPUT\nEND_VAR\n...\n\nPROGRAM PLC_PRG\nVAR\n    read_input : FBRead_Var;\nEND_VAR\nread_input(); \/\/ Call of the action read_input 変数の宣言 read_input 次の警告が表示されます。 メッセージ: C0508: 'READ_INPUT' という名前のあいまいな使用法 " }, 
{ "title" : "コンパイラエラーC0509 ", 
"url" : "_cds_error_c0509.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0509 ", 
"snippet" : "C0509 メッセージ ：演算子 '__New'の複数の割り当ては許可されていません 考えられるエラーの原因 ：1行のコードで、代入演算子 \" := \"は複数回呼び出されます __New オペレーター。 エラー訂正 ：メモリ割り当てをプログラムする __New 動的に割り当てられたメモリを指す各ポインタの個別のコード行の演算子。 エラーの例： PROGRAM PLC_PRG VAR pbAlpha : POINTER TO BYTE; \/\/ Typed pointer to Alpha pbBeta: POINTER TO BYTE; \/\/ Typed pointer to Beta xIni...", 
"body" : "C0509 メッセージ ：演算子 '__New'の複数の割り当ては許可されていません 考えられるエラーの原因 ：1行のコードで、代入演算子 \" := \"は複数回呼び出されます __New オペレーター。 エラー訂正 ：メモリ割り当てをプログラムする __New 動的に割り当てられたメモリを指す各ポインタの個別のコード行の演算子。 エラーの例： PROGRAM PLC_PRG\nVAR\n pbAlpha : POINTER TO BYTE; \/\/ Typed pointer to Alpha\n pbBeta: POINTER TO BYTE; \/\/ Typed pointer to Beta\n xInit : BOOL := TRUE;\n xDelete : BOOL;\nEND_VAR\n\nIF (xInit) THEN\n pbBeta := pbAlpha := __NEW(BYTE); \/\/ Incorrect code for memory allocation\nEND_IF\n\npbBeta := pbAlpha := 16#01;\n\nIF (xDelete) THEN\n __DELETE(pbAlpha); \/\/ Frees memory of pointer\nEND_IF\n メッセージ： C0509：演算子 '__NEW'への複数の割り当ては許可されていません エラー訂正： PROGRAM PLC_PRG\nVAR\n pbAlpha : POINTER TO BYTE; \/\/ Pointer to Alpha\n pbBeta: POINTER TO BYTE; \/\/ Pointer to Beta\n xInit : BOOL := TRUE;\n xDelete : BOOL;\nEND_VAR\n\nIF (xInit) THEN\n pbAlpha := __NEW(BYTE); \/\/ Allocates memory for Alpha\n pbBeta := __NEW(BYTE); \/\/ Allocates memory for Beta\nEND_IF\n\npbBeta := pbAlpha := 16#01; \/\/ Multiple assignment\n\nIF (xDelete) THEN\n __DELETE(pbAlpha); \/\/ Frees memory of pointer\nEND_IF 詳細については、以下を参照してください。 __NEW" }, 
{ "title" : "コンパイラエラーC0511 ", 
"url" : "_cds_error_c0511.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0511 ", 
"snippet" : "C0511 メッセージ ：機能ブロック '<機能ブロック名>'はABSTRACTであり、割り当てのターゲットとして使用することはできません。 考えられるエラーの原因 ：抽象関数ブロックに値が割り当てられました。具象機能ブロックはタイプが異なる場合があるため、コピーできません。 エラー訂正 ：機能ブロックのデータをコピーするには、具体的な機能ブロックを使用する必要があります。 エラーの例： PROGRAM PLC_PRG VAR refAbstract1 : REFERENCE TO AbstractPOU; refAbstract2 : REFERENCE TO AbstractPOU; EN...", 
"body" : "C0511 メッセージ ：機能ブロック '<機能ブロック名>'はABSTRACTであり、割り当てのターゲットとして使用することはできません。 考えられるエラーの原因 ：抽象関数ブロックに値が割り当てられました。具象機能ブロックはタイプが異なる場合があるため、コピーできません。 エラー訂正 ：機能ブロックのデータをコピーするには、具体的な機能ブロックを使用する必要があります。 エラーの例： PROGRAM PLC_PRG\nVAR\nrefAbstract1 : REFERENCE TO AbstractPOU;\nrefAbstract2 : REFERENCE TO AbstractPOU;\nEND_VAR\n\nrefAbstract1 := refAbstract2;\n メッセージ： C0511：機能ブロック 'refAbstract1'はABSTRACTであり、割り当てのターゲットとして使用できません。 エラー訂正： 参照割り当てを使用する REF= 参照を割り当てる refAbstract1 と同じ機能ブロックに refAbstract2 。 " }, 
{ "title" : "コンパイラ警告 C0513 ", 
"url" : "_cds_error_c0513.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0513 ", 
"snippet" : "0513 メッセージ : プライベート・プロパティ <POU名> <プロパティ名> にアクセスしてはならない。 考えられるエラー原因 : POU のプロパティで、その可視性は POU が設定された POU のみに制限されています PRIVATE キーワードは、POU の外部からアクセスされます。 エラー訂正 : プロパティの可視性を変更 (たとえば、プロパティを削除する) PRIVATE キーワード) または変数の宣言を変更してください。 警告の例 FUNCTION_BLOCK POU VAR_INPUT END_VAR ... PROPERTY PRIVATE Prop : UDINT PR...", 
"body" : "0513 メッセージ : プライベート・プロパティ <POU名> <プロパティ名> にアクセスしてはならない。 考えられるエラー原因 : POU のプロパティで、その可視性は POU が設定された POU のみに制限されています PRIVATE キーワードは、POU の外部からアクセスされます。 エラー訂正 : プロパティの可視性を変更 (たとえば、プロパティを削除する) PRIVATE キーワード) または変数の宣言を変更してください。 警告の例 FUNCTION_BLOCK POU\nVAR_INPUT\nEND_VAR\n...\n\nPROPERTY PRIVATE Prop : UDINT\n\nPROGRAM\nPLC_PRG\nVAR\n      p:POU := STRUCT(Prop := 7);\nEND_VAR 変数の宣言 p 次の警告が表示されます。 メッセージ: C0513: プライベートプロパティ POU プロップにアクセスしてはいけません " }, 
{ "title" : "コンパイラ警告 C0514 ", 
"url" : "_cds_error_c0514.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0514 ", 
"snippet" : "0514 メッセージ : ライブラリ<ライブラリ名> の内部プロパティ <POU 名>.<プロパティ名> にアクセスすべきではありません。 考えられるエラー原因 : ライブラリにはプロパティの付いた POU が含まれていますが、その可視性は、次のプロパティを持つこのライブラリに制限されています INTERNAL キーワード。このプロパティには、このライブラリの外部からアクセスします。 エラー訂正 : プロパティの可視性を変更 (たとえば、プロパティを削除する) INTERNAL キーワード) または変数の宣言を変更してください。 警告の例 PROGRAM PLC_PRG VAR       p...", 
"body" : "0514 メッセージ : ライブラリ<ライブラリ名> の内部プロパティ <POU 名>.<プロパティ名> にアクセスすべきではありません。 考えられるエラー原因 : ライブラリにはプロパティの付いた POU が含まれていますが、その可視性は、次のプロパティを持つこのライブラリに制限されています INTERNAL キーワード。このプロパティには、このライブラリの外部からアクセスします。 エラー訂正 : プロパティの可視性を変更 (たとえば、プロパティを削除する) INTERNAL キーワード) または変数の宣言を変更してください。 警告の例 PROGRAM PLC_PRG\nVAR\n      p1: MyLib.POU;\n      somevar1 :INT := p1.Prop;\nEND_VAR 変数の宣言 somevar1 次の警告が表示されます。 メッセージ: C0514: ライブラリ MyLib 1.0.0.0 (MyCompany) の内部プロパティ Pou.prop にアクセスしてはいけません " }, 
{ "title" : "コンパイラ警告 C0515 ", 
"url" : "_cds_error_c0515.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0515 ", 
"snippet" : "0515 メッセージ : 保護されたプロパティ<POU名>.<プロパティ名>にアクセスすべきではありません。 考えられるエラー原因 : POU のプロパティ。POU の可視性は POU によって制限されています PROTECTED キーワード、は POU またはその継承階層の外部からアクセスされます。 エラー訂正 : プロパティの可視性を変更 (たとえば、プロパティを削除する) PROTECTED キーワード) または変数の宣言を変更してください。 警告の例 FUNCTION_BLOCK POU VAR_INPUT END_VAR ... PROPERTY PROTECTED Prop : U...", 
"body" : "0515 メッセージ : 保護されたプロパティ<POU名>.<プロパティ名>にアクセスすべきではありません。 考えられるエラー原因 : POU のプロパティ。POU の可視性は POU によって制限されています PROTECTED キーワード、は POU またはその継承階層の外部からアクセスされます。 エラー訂正 : プロパティの可視性を変更 (たとえば、プロパティを削除する) PROTECTED キーワード) または変数の宣言を変更してください。 警告の例 FUNCTION_BLOCK POU\nVAR_INPUT\nEND_VAR\n...\n\nPROPERTY PROTECTED Prop : UDINT\n\nPROGRAM PLC_PRG\nVAR\n      p:POU := STRUCT(Prop := 7);\nEND_VAR 変数の宣言 p 次の警告が表示されます。 メッセージ: C0515: 保護されたプロパティ Pou.prop にアクセスしてはいけません " }, 
{ "title" : "コンパイラ警告 C0516 ", 
"url" : "_cds_error_c0516.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0516 ", 
"snippet" : "0516 メッセージ : ライブラリ<ライブラリ名> の内部変数 <POU名> にアクセスしてはならない。 考えられるエラー原因 : ライブラリには変数を含む POU が含まれています。POU の可視性は、以下のライブラリに限定されます INTERNAL キーワード。この変数には、このライブラリの外部からアクセスします。 エラー訂正 : POU の可視性を変更 (たとえば、POU を削除する) INTERNAL キーワード) または変数の宣言を変更してください。 警告の例 PROGRAM PLC_PRG VAR     somevar1 : INT := MyLib.GVL.p.varIn; ...", 
"body" : "0516 メッセージ : ライブラリ<ライブラリ名> の内部変数 <POU名> にアクセスしてはならない。 考えられるエラー原因 : ライブラリには変数を含む POU が含まれています。POU の可視性は、以下のライブラリに限定されます INTERNAL キーワード。この変数には、このライブラリの外部からアクセスします。 エラー訂正 : POU の可視性を変更 (たとえば、POU を削除する) INTERNAL キーワード) または変数の宣言を変更してください。 警告の例 PROGRAM PLC_PRG\nVAR\n    somevar1 : INT := MyLib.GVL.p.varIn;\nEND_VAR 変数の宣言 somevar1 次の警告が表示されます。 メッセージ: C0516: ライブラリ MyLib 1.0.0.0 (MyCompany) の内部変数 InternalPou.varin にアクセスしてはいけません " }, 
{ "title" : "コンパイラ警告 C0517 ", 
"url" : "_cds_error_c0517.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0517 ", 
"snippet" : "C0517 メッセージ : ライブラリ <ライブラリ名> の内部オブジェクト<オブジェクト名> にアクセスしてはならない。 考えられるエラー原因 : ライブラリに POU が含まれていますが、その可視性は POU が存在するライブラリに限定されています。 INTERNAL キーワード。の POU は SIZEOF operator はこのライブラリの外部から使用されます。 エラー訂正 : POU の可視性を変更 (たとえば、POU を削除する) INTERNAL キーワード) または変数の宣言を変更してください。 警告の例 PROGRAM PLC_PRG VAR     somevar1 : ...", 
"body" : "C0517 メッセージ : ライブラリ <ライブラリ名> の内部オブジェクト<オブジェクト名> にアクセスしてはならない。 考えられるエラー原因 : ライブラリに POU が含まれていますが、その可視性は POU が存在するライブラリに限定されています。 INTERNAL キーワード。の POU は SIZEOF operator はこのライブラリの外部から使用されます。 エラー訂正 : POU の可視性を変更 (たとえば、POU を削除する) INTERNAL キーワード) または変数の宣言を変更してください。 警告の例 PROGRAM PLC_PRG\nVAR\n    somevar1 : INT := SIZEOF(MyLib.POU);\nEND_VAR メッセージ: C0517: ライブラリ MyLib、1.0.0.0 (MyCompany) の内部オブジェクト POU にアクセスしてはいけません " }, 
{ "title" : "コンパイラ警告 C0525 ", 
"url" : "_cds_error_c0525.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0525 ", 
"snippet" : "0525 メッセージ : このコンテキストでは、型 <type> にデフォルト値を持たせることはできない。 考えられるエラー原因 : a の初期値 VAR_INPUT カスタムデータ型がある。 エラー訂正 : 初期値を削除します。 警告の例 FUNCTION Fun: INT VAR_INPUT       iPar : INT;       xPar : BOOL;       aInt : ARRAY [0..1] OF INT := [1, 2]; END_VAR PROGRAM PLC_PRG VAR      aInt:ARRAY [0..1] OF INT := [1, 2]; E...", 
"body" : "0525 メッセージ : このコンテキストでは、型 <type> にデフォルト値を持たせることはできない。 考えられるエラー原因 : a の初期値 VAR_INPUT カスタムデータ型がある。 エラー訂正 : 初期値を削除します。 警告の例 FUNCTION Fun: INT\nVAR_INPUT\n      iPar : INT;\n      xPar : BOOL;\n      aInt : ARRAY [0..1] OF INT := [1, 2];\nEND_VAR\n\nPROGRAM PLC_PRG\nVAR\n     aInt:ARRAY [0..1] OF INT := [1, 2];\nEND_VAR\nFun(1, TRUE, aInt);\n 変数の宣言 aInt に Fun 関数は次の警告を生成します。 メッセージ: C0525: INT の ARRAY [0.. 1] 型は、このコンテキストではデフォルト値を持つことはできません " }, 
{ "title" : "コンパイラ警告 C0526 ", 
"url" : "_cds_error_c0526.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0526 ", 
"snippet" : "0526 メッセージ : デフォルト値は一定ではありません 考えられるエラー原因 : a の初期値 VAR_INPUT 定数は使用せず、関数呼び出しの結果を使用します。 エラー訂正 : 初期値として定数を使用します。 警告の例 FUNCTION F2: INT FUNCTION F1: INT VAR_INPUT       iPar : INT := F2();       xPar : BOOL; END_VAR 変数の宣言 iPar 次の警告が表示されます。 メッセージ: C0526: デフォルト値は定数ではありません...", 
"body" : "0526 メッセージ : デフォルト値は一定ではありません 考えられるエラー原因 : a の初期値 VAR_INPUT 定数は使用せず、関数呼び出しの結果を使用します。 エラー訂正 : 初期値として定数を使用します。 警告の例 FUNCTION F2: INT\n\nFUNCTION F1: INT\nVAR_INPUT\n      iPar : INT := F2();\n      xPar : BOOL;\nEND_VAR 変数の宣言 iPar 次の警告が表示されます。 メッセージ: C0526: デフォルト値は定数ではありません " }, 
{ "title" : "コンパイラ警告 C0533 ", 
"url" : "_cds_error_c0533.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0533 ", 
"snippet" : "0533 メッセージ : a のデフォルト値 VAR_OUTPUT 抽象メソッドやインタフェースメソッドでは使用されません。 考えられるエラー原因 : 抽象 POU のメソッドでは、初期値が a に割り当てられます。 VAR_OUTPUT 。 インターフェイスメソッドと抽象メソッドの場合、入力の初期値とは対照的に、出力の初期値は何の影響もありません。 エラー訂正 : 影響を受ける部分から初期値を削除します VAR_OUTPUT 。 警告の例 FUNCTION_BLOCK ABSTRACT POU METHOD METH: BOOL VAR_INPUT       iPar : INT;    ...", 
"body" : "0533 メッセージ : a のデフォルト値 VAR_OUTPUT 抽象メソッドやインタフェースメソッドでは使用されません。 考えられるエラー原因 : 抽象 POU のメソッドでは、初期値が a に割り当てられます。 VAR_OUTPUT 。 インターフェイスメソッドと抽象メソッドの場合、入力の初期値とは対照的に、出力の初期値は何の影響もありません。 エラー訂正 : 影響を受ける部分から初期値を削除します VAR_OUTPUT 。 警告の例 FUNCTION_BLOCK ABSTRACT POU\n\nMETHOD METH: BOOL\nVAR_INPUT\n      iPar : INT;\n      xPar : BOOL;\nEND_VAR\nVAR_OUTPUT\n      iOut : INT;\n      xOut : BOOL := TRUE;\nEND_VAR 変数の宣言 xOut 次の警告が表示されます。 メッセージ: C0533: VAR_OUTPUT のデフォルト値は、抽象メソッドまたはインタフェースメソッドでは使用されません " }, 
{ "title" : "コンパイラ警告 C0540 ", 
"url" : "_cds_error_c0540.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0540 ", 
"snippet" : "0540 メッセージ : POU '<POU>'に属性 'no_assign' がありません。変数 '<variable>' の型には 'no_assign' が割り当てられています。 考えられるエラー原因 : POU X には変数が含まれており、そのタイプ (POU Y) には 'no_assign' アトリビュート。POU X にはありません 'no_assign' アトリビュート。 エラー訂正 : また、POU を次のようにデコレーションしてください 'no_assign' アトリビュート。 警告の例 {attribute 'no_assign'} FUNCTION_BLOCK FB_N...", 
"body" : "0540 メッセージ : POU '<POU>'に属性 'no_assign' がありません。変数 '<variable>' の型には 'no_assign' が割り当てられています。 考えられるエラー原因 : POU X には変数が含まれており、そのタイプ (POU Y) には 'no_assign' アトリビュート。POU X にはありません 'no_assign' アトリビュート。 エラー訂正 : また、POU を次のようにデコレーションしてください 'no_assign' アトリビュート。 警告の例 {attribute 'no_assign'}\nFUNCTION_BLOCK FB_NotAssignable\nVAR\n      pBool : POINTER TO BOOL;\nEND_VAR\n\nFUNCTION_BLOCK FB_WrapperOfNotAssignable\nVAR\n      fbNotAssingable : FB_NotAssignable;\nEND_VAR\n\n 変数の宣言 fbNotAssignable 次の警告が表示されます。 メッセージ: C0540: POU 'FB_WrapperOfNotAssignable' の属性 'no_assign' が見つかりません。変数 'FBNotAssingable' の型には 'no_assign' という属性が付いています エラー訂正：デコレーションも FB_WrapperOfNotAssignable POU との 'no_assign' アトリビュート。 " }, 
{ "title" : "コンパイラ警告C0542 ", 
"url" : "_cds_error_c0542.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告C0542 ", 
"snippet" : "C0542 メッセージ ：継承は、データ型 \"UNION\" <データ型名>を対象としていません。 考えられるエラーの原因 ：構造化データ型（ DUT ）から派生 UNION で拡張することによって EXTENDS 、または UNION から派生 DUT 。この種の派生は許可されていません。ただし、互換性の理由から、警告のみが発行されます。 エラーの例： TYPE U_StringExt EXTENDS U_StringBase : UNION str10 : STRING(10); END_UNION END_TYPE TYPE U_StringBase : UNION str20 : STR...", 
"body" : "C0542 メッセージ ：継承は、データ型 \"UNION\" <データ型名>を対象としていません。 考えられるエラーの原因 ：構造化データ型（ DUT ）から派生 UNION で拡張することによって EXTENDS 、または UNION から派生 DUT 。この種の派生は許可されていません。ただし、互換性の理由から、警告のみが発行されます。 エラーの例： TYPE U_StringExt EXTENDS U_StringBase :\nUNION\n str10 : STRING(10);\nEND_UNION\nEND_TYPE TYPE U_StringBase :\nUNION\n str20 : STRING(20);\nEND_UNION\nEND_TYPE PROGRAM PLC_PRG\nVAR\n uStringExt : U_StringExt;\nEND_VAR\n\nuStringExt.str20 := 'a234567890b234567890'; -> C0542 " }, 
{ "title" : "コンパイラエラーC0543 ", 
"url" : "_cds_error_c0543.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0543 ", 
"snippet" : "C0543 メッセージ ： 名前 <keyword> IEC1131-3規格で予約されているキーワードです。将来のバージョンではエラーが発行されます。 考えられるエラーの原因 ：変数の名前として予約キーワードが割り当てられました。 エラー訂正 ：変数の名前を変更します。 エラーの例： PROGRAM PLC_PRG VAR char : BYTE; END_VAR メッセージ： C0543：「char」という名前は、IEC1131-3規格で予約されているキーワードです。将来のバージョンではエラーが発行されます。 注：コンパイルされたライブラリでの違反の場合、警告の代わりにテキストメッセージ（情...", 
"body" : "C0543 メッセージ ： 名前 <keyword> IEC1131-3規格で予約されているキーワードです。将来のバージョンではエラーが発行されます。 考えられるエラーの原因 ：変数の名前として予約キーワードが割り当てられました。 エラー訂正 ：変数の名前を変更します。 エラーの例： PROGRAM PLC_PRG\nVAR\n char : BYTE;\nEND_VAR\n メッセージ： C0543：「char」という名前は、IEC1131-3規格で予約されているキーワードです。将来のバージョンではエラーが発行されます。 注：コンパイルされたライブラリでの違反の場合、警告の代わりにテキストメッセージ（情報）のみが発行されます。 次のキーワードは予約されています。 CHAR WCHAR ANY_DERIVED ANY_ELEMENTARY ANY_MAGNITUDE ANY_SIGNED ANY_DURATION ANY_CHARS ANY_CHARS CHAR_TO TO_CHAR WCHAR_TO TO_WCHAR ATAN2 USING CLASS " }, 
{ "title" : "コンパイラエラーC0549 ", 
"url" : "_cds_error_c0549.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0549 ", 
"snippet" : "C0549 メッセージ ：静的変数の初期化 '<variable name>' 定数ではないか、置き換えられた定数が無効になっています。 考えられるエラーの原因： VAR_STAT と CONSTANT 宣言は、機能ブロック宣言で一緒に使用されます。 The 定数を置き換えます コンパイルオプションは無効になっています。 例 The 定数を置き換える コンパイルオプションは無効になっています。 VAR CONSTANT iMaxInst : INT := 2; END_VAR VAR_STAT iIDs : INT := iMaxInst - 1; END_VAR メッセージ： C0549：静...", 
"body" : "C0549 メッセージ ：静的変数の初期化 '<variable name>' 定数ではないか、置き換えられた定数が無効になっています。 考えられるエラーの原因： VAR_STAT と CONSTANT 宣言は、機能ブロック宣言で一緒に使用されます。 The 定数を置き換えます コンパイルオプションは無効になっています。 例 The 定数を置き換える コンパイルオプションは無効になっています。 VAR CONSTANT\n iMaxInst : INT := 2;\nEND_VAR\nVAR_STAT\n iIDs : INT := iMaxInst - 1;\nEND_VAR メッセージ： C0549：静的変数 'iIDs'の初期化が一定でないか、置換された定数が無効になっています。 エラー訂正 ： の プロジェクト→プロジェクト設定 、 コンパイルオプション タブで、を有効にします 定数を置き換える コンパイルオプション。 " }, 
{ "title" : "コンパイラエラーC0550 ", 
"url" : "_cds_error_c0550.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0550 ", 
"snippet" : "C0550 メッセージ ： 'FUNCTION'（ 'METHOD'）の属性 'pack_mode'は許可されていません 考えられるエラーの原因 ：プラグマに起因する関数またはメソッド {attribute 'pack_mode' := ' <pack mode value>' } 例 {attribute 'pack_mode' := '2'} METHOD METH : INT VAR_INPUT END_VAR {attribute 'pack_mode' := '1'} FUNCTION FunPacked : DINT VAR_INPUT by1: BYTE; END_VAR VAR...", 
"body" : "C0550 メッセージ ： 'FUNCTION'（ 'METHOD'）の属性 'pack_mode'は許可されていません 考えられるエラーの原因 ：プラグマに起因する関数またはメソッド {attribute 'pack_mode' := ' <pack mode value>' } 例 {attribute 'pack_mode' := '2'}\nMETHOD METH : INT\nVAR_INPUT\nEND_VAR {attribute 'pack_mode' := '1'}\nFUNCTION FunPacked : DINT\nVAR_INPUT\n by1: BYTE;\nEND_VAR\nVAR\n by2: BYTE;\nEND_VAR メッセージ： C0550：「METHOD」の属性「pack_mode」は許可されていません C0550：「FUNCTION」の属性「pack_mode」は許可されていません エラー訂正 ： 属性プラグマを削除します。 詳細については、以下を参照してください。 pack_mode" }, 
{ "title" : "コンパイラエラーC0554 ", 
"url" : "_cds_error_c0554.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラーC0554 ", 
"snippet" : "C0554 メッセージ ：「<FB名>」の明示的な呼び出しは許可されていません。 <属性の値'no_explicit_call'> 考えられるエラーの原因 ：機能ブロック no_explicit_call 属性が呼び出されました。 例 {attribute 'no_explicit_call' := 'Call of this FB is not allowed'} FUNCTION_BLOCK FB1 VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR END_VAR PROGRAM PLC_PRG VAR myFB: FB1; END_VAR myFB(); ...", 
"body" : "C0554 メッセージ ：「<FB名>」の明示的な呼び出しは許可されていません。 <属性の値'no_explicit_call'> 考えられるエラーの原因 ：機能ブロック no_explicit_call 属性が呼び出されました。 例 {attribute 'no_explicit_call' := 'Call of this FB is not allowed'}\nFUNCTION_BLOCK FB1\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\nEND_VAR PROGRAM PLC_PRG\nVAR\n myFB: FB1;\nEND_VAR\n\nmyFB();\n メッセージ： C0554：「FB1」の明示的な呼び出しは許可されていません。Call of this FB is not allowed。 エラー訂正 ： 属性プラグマを削除します。 " }, 
{ "title" : "コンパイラ警告C0555 ", 
"url" : "_cds_error_c0555.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告C0555 ", 
"snippet" : "C0555 メッセージ ：文字列リテラル<literal>に表示できない文字が含まれています。プロジェクトオプション「STRINGのUTF-8エンコーディング」を使用できます。 考えられるエラーの原因 ：Latin-1に変換できない不明な文字の入力。 例 PROGRAM PLC_PRG VAR str1: STRING(200); str2: STRING := '1 €'; str3: STRING(200) := ' !$\"#$$%&$'()*+,-.\/0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrst...", 
"body" : "C0555 メッセージ ：文字列リテラル<literal>に表示できない文字が含まれています。プロジェクトオプション「STRINGのUTF-8エンコーディング」を使用できます。 考えられるエラーの原因 ：Latin-1に変換できない不明な文字の入力。 例 PROGRAM PLC_PRG\nVAR\n\tstr1: STRING(200);\n\tstr2: STRING := '1 €';\n\tstr3: STRING(200) := ' !$\"#$$%&$'()*+,-.\/0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';\nEND_VAR\n\n str1 := '你好,世界';\nstr1 := 'ABC abc 123 äöü ß#~=\" §% \/(!)[]{}\\ ´`^*~°€µ *_-.; 中文字 Ω �';\nstr1 := '1 £';\nstr1 := '1 €';\nstr1 := ' !$\"#$$%&$'()*+,-.\/0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~'; メッセージ： C0555：文字列リテラル '你好、世界'に表示できない文字が含まれています。プロジェクトオプション「文字列のUTF-8エンコーディング」を使用できます。 修正 ： オプションを選択します。 詳細については、以下を参照してください。ダイアログ： コンパイルオプション " }, 
{ "title" : "コンパイラ警告 C0561 ", 
"url" : "_cds_error_c0561.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0561 ", 
"snippet" : "C0561 メッセージ : 再帰呼び出し：<POU> -> <POU> 考えられるエラー原因 : プログラムコードに再帰呼び出しが含まれています。 エラー訂正 : 再帰呼び出しが不要な場合は削除してください。 警告の例 METHOD METH: BOOL VAR_INPUT END_VAR Recursive(); PROGRAM Recursive VAR END_VAR Recursive(); 呼び出し Recursive で Recursive プログラムは次の警告を出します。 メッセージ: C0561: 再帰呼び出し:再帰的-> 再帰的...", 
"body" : "C0561 メッセージ : 再帰呼び出し：<POU> -> <POU> 考えられるエラー原因 : プログラムコードに再帰呼び出しが含まれています。 エラー訂正 : 再帰呼び出しが不要な場合は削除してください。 警告の例 METHOD METH: BOOL\nVAR_INPUT\nEND_VAR\nRecursive();\n\nPROGRAM Recursive\nVAR\nEND_VAR\nRecursive();\n 呼び出し Recursive で Recursive プログラムは次の警告を出します。 メッセージ: C0561: 再帰呼び出し:再帰的-> 再帰的 " }, 
{ "title" : "コンパイラ警告 C0564 ", 
"url" : "_cds_error_c0564.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0564 ", 
"snippet" : "0564 メッセージ <variable2>: <variable1>初期化されていない変数への参照がの初期化に使用されます。初期化されていない変数にアクセスすると、予期しない動作が発生する可能性があります 考えられるエラー原因 : 初期化されていない変数への参照が、別の変数の初期化に使用されます。 エラー訂正 : 変数<変数2> の前に<変数1> を宣言する 警告の例 PROGRAM PLC_PRG VAR       inst : FB := STRUCT(ii := inst2);       inst2 : FBI; END_VAR 変数の初期化 inst 宣言すると次の警告が表示され...", 
"body" : "0564 メッセージ <variable2>: <variable1>初期化されていない変数への参照がの初期化に使用されます。初期化されていない変数にアクセスすると、予期しない動作が発生する可能性があります 考えられるエラー原因 : 初期化されていない変数への参照が、別の変数の初期化に使用されます。 エラー訂正 : 変数<変数2> の前に<変数1> を宣言する 警告の例 PROGRAM PLC_PRG\nVAR\n      inst : FB := STRUCT(ii := inst2);\n      inst2 : FBI;\nEND_VAR\n\n 変数の初期化 inst 宣言すると次の警告が表示されます。 メッセージ: C0564: 初期化されていない変数 inst2 への参照が inst の初期化に使用されます。初期化されていない変数にアクセスすると、予期しない動作が起こる可能性があります。 エラー訂正:変数を宣言してください inst2 変数の前 inst 。 PROGRAM PLC_PRG\nVAR\n      inst2 : FBI;\n      inst : FB := STRUCT(ii := inst2);\nEND_VAR " }, 
{ "title" : "コンパイラ警告 C0565 ", 
"url" : "_cds_error_c0565.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0565 ", 
"snippet" : "C0565 メッセージ : 関数ブロックまたは構造体の「FB_Exit」メソッドには、BOOL タイプの入力「bInCopyCode」が必要です。 考えられる原因 : 入力 bInCopyCode タイプの BOOL 不足している。 修正 : 入力を定義します。 警告の例: PROGRAM PLC_PRG VAR inst : FB; END_VAR FUNCTION_BLOCK FB METHOD FB_exit VAR_INPUT END_VAR メッセージ： C0565: 関数ブロックまたは構造体の 'FB_Exit' メソッドには、BOOL 型の入力 'bInCopyCode' が必要...", 
"body" : "C0565 メッセージ : 関数ブロックまたは構造体の「FB_Exit」メソッドには、BOOL タイプの入力「bInCopyCode」が必要です。 考えられる原因 : 入力 bInCopyCode タイプの BOOL 不足している。 修正 : 入力を定義します。 警告の例: PROGRAM PLC_PRG\nVAR\n inst : FB;\nEND_VAR\n\n\nFUNCTION_BLOCK FB\nMETHOD FB_exit\nVAR_INPUT\nEND_VAR\n メッセージ： C0565: 関数ブロックまたは構造体の 'FB_Exit' メソッドには、BOOL 型の入力 'bInCopyCode' が必要です。 修正： METHOD FB_exit\nVAR_INPUT\n bInCopyCode : BOOL;\nEND_VAR " }, 
{ "title" : "コンパイラ警告 C0566 ", 
"url" : "_cds_error_c0566.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0566 ", 
"snippet" : "C0566 メッセージ : 関数ブロックまたは構造体の FB_ReInit メソッドには、入力がなく、BOOL 型の戻り値が必要です。 FB_ReInit は自動的には呼び出されません。 考えられる原因 : 1 つ以上の入力が定義されています FB_ReInit . 出力は単なるものではありません BOOL 変数。 修正 : の入力を削除します FB_ReInit 方法。であることを確認してください。 FB_ReInit メソッドには出力が 1 つしかなく、この出力のタイプは BOOL . 警告の例 METHOD FB_ReInit : BOOL VAR_INPUT input_var : I...", 
"body" : "C0566 メッセージ : 関数ブロックまたは構造体の FB_ReInit メソッドには、入力がなく、BOOL 型の戻り値が必要です。 FB_ReInit は自動的には呼び出されません。 考えられる原因 : 1 つ以上の入力が定義されています FB_ReInit . 出力は単なるものではありません BOOL 変数。 修正 : の入力を削除します FB_ReInit 方法。であることを確認してください。 FB_ReInit メソッドには出力が 1 つしかなく、この出力のタイプは BOOL . 警告の例 METHOD FB_ReInit : BOOL\nVAR_INPUT \n input_var : INT; \/\/C0566: unexpected input for FB_ReInit\nEND_VAR\n\nVAR_OUT_PUT\n output_var : INT; \/\/C0566: wrong type for output of FB_ReInit\nEND_VAR 修正： METHOD FB_ReInit : BOOL\n\/\/ correction: inputs have been removed\nVAR_OUTPUT\n output_var: BOOL; \/\/ correction: ouput has the correct type\nEND_VAR " }, 
{ "title" : "コンパイラ警告 C0567 ", 
"url" : "_cds_error_c0567.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0567 ", 
"snippet" : "C0567 メッセージ : インターフェイス <インターフェイス名 1> は __System.IQueryInterface を拡張しません 考えられる原因 : インターフェイス ライブラリのすべてのインターフェイスは拡張する必要があります __System.IQueryInterface .使用するインターフェースが拡張されない __System.IQueryInterface . 例 PROGRAM PLC_PRG VAR ITFref : ITF; ITFref2 : ITF2; END_VAR INTERFACE ITF INTERFACE ITF2 EXTENDS ITF メッセー...", 
"body" : "C0567 メッセージ : インターフェイス <インターフェイス名 1> は __System.IQueryInterface を拡張しません 考えられる原因 : インターフェイス ライブラリのすべてのインターフェイスは拡張する必要があります __System.IQueryInterface .使用するインターフェースが拡張されない __System.IQueryInterface . 例 PROGRAM PLC_PRG\nVAR\n ITFref : ITF;\n ITFref2 : ITF2;\nEND_VAR\n\nINTERFACE ITF\nINTERFACE ITF2 EXTENDS ITF メッセージ： C0567: インターフェイス ITF は __System.IQueryInterface を拡張しません 修正： INTERFACE ITF EXTENDS __System.IQueryInterface インターフェイス ライブラリに関するすべてのルールの概要については、次を参照してください。 インターフェイス ライブラリ " }, 
{ "title" : "コンパイラ警告 C0568 ", 
"url" : "_cds_error_c0568.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0568 ", 
"snippet" : "C0568 メッセージ : インターフェイス '<関数ブロック名>' のオーバーライドされたメソッド '<メソッド名>' のインターフェイスが宣言と一致しません 考えられる原因 : 最初のインターフェースのメソッドの署名が、最初のインターフェースによって拡張された 2 番目のインターフェースのメソッドの署名と一致しません。 修正 : 署名を揃えます。 警告の例: PROGRAM PLC_PRG VAR xyz : XY2; END_VAR FUNCTION_BLOCK XY METHOD METH1 VAR_INPUT END_VAR FUNCTION_BLOCK XY2 EXTENDS XY...", 
"body" : "C0568 メッセージ : インターフェイス '<関数ブロック名>' のオーバーライドされたメソッド '<メソッド名>' のインターフェイスが宣言と一致しません 考えられる原因 : 最初のインターフェースのメソッドの署名が、最初のインターフェースによって拡張された 2 番目のインターフェースのメソッドの署名と一致しません。 修正 : 署名を揃えます。 警告の例: PROGRAM PLC_PRG\nVAR\n xyz : XY2;\nEND_VAR\n\nFUNCTION_BLOCK XY\nMETHOD METH1\nVAR_INPUT\nEND_VAR\n\nFUNCTION_BLOCK XY2 EXTENDS XY\nMETHOD METH1\nVAR_INPUT\n iPar : BOOL;\nEND_VAR\n メッセージ： C0568: ベース 'XY' のオーバーライドされたメソッド 'METH1' のインターフェイスが宣言と一致しません " }, 
{ "title" : "コンパイラ警告 C0569 ", 
"url" : "_cds_error_c0569.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0569 ", 
"snippet" : "C0569 メッセージ : VAR_PERSISTENT リストに変数 {0} の一致するインスタンス パスが見つかりません。コマンド「すべてのインスタンス パスを追加」を使用して、すべてのインスタンス パスを VAR_PERSISTENT リストに追加します。 考えられるエラー : 外部で宣言された永続変数 VAR_PERSISTENT リストは、 すべてのインスタンス パスを追加 このリストのコマンド。永続変数が外部で宣言された後にこのコマンドが実行されなかった場合、警告が発行されます。 VAR_PERSISTENT リスト。 修正 ： の中に 宣言 メニュー、クリック すべてのインスタン...", 
"body" : "C0569 メッセージ : VAR_PERSISTENT リストに変数 {0} の一致するインスタンス パスが見つかりません。コマンド「すべてのインスタンス パスを追加」を使用して、すべてのインスタンス パスを VAR_PERSISTENT リストに追加します。 考えられるエラー : 外部で宣言された永続変数 VAR_PERSISTENT リストは、 すべてのインスタンス パスを追加 このリストのコマンド。永続変数が外部で宣言された後にこのコマンドが実行されなかった場合、警告が発行されます。 VAR_PERSISTENT リスト。 修正 ： の中に 宣言 メニュー、クリック すべてのインスタンス パスを追加 . 詳細については、次を参照してください。 すべてのインスタンスパスを追加します" }, 
{ "title" : "コンパイラ警告 C0571 ", 
"url" : "_cds_error_c0571.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0571 ", 
"snippet" : "0571 メッセージ : FB_EXIT のインスタンス数 VAR_RETAIN ウォームリセット中にも呼び出されますが、呼び出されません FB_INIT 。関数ブロックの retain 宣言を次のコードで記述することは避けてください FB_EXIT ! 考えられるエラー原因 : 次のような関数ブロックのインスタンス FB_Exit メソッドは、で宣言されています VAR_RETAIN 。 エラー訂正 : 以下のようにして関数ブロックの宣言を保持しないようにしてください。 FB_EXIT 。 警告の例 FUNCTION_BLOCK POU ... METHOD FB_Exit: BOOL VA...", 
"body" : "0571 メッセージ : FB_EXIT のインスタンス数 VAR_RETAIN ウォームリセット中にも呼び出されますが、呼び出されません FB_INIT 。関数ブロックの retain 宣言を次のコードで記述することは避けてください FB_EXIT ! 考えられるエラー原因 : 次のような関数ブロックのインスタンス FB_Exit メソッドは、で宣言されています VAR_RETAIN 。 エラー訂正 : 以下のようにして関数ブロックの宣言を保持しないようにしてください。 FB_EXIT 。 警告の例 FUNCTION_BLOCK POU\n...\nMETHOD FB_Exit: BOOL\nVAR_INPUT\n      bInCopyCode : BOOL;\nEND_VAR\n...\nFUNCTION_BLOCK POU_1\nVAR\n      inst2 : POU;\nEND_VAR\n...\nPROGRAM PLC_PRG\nVAR\n      myFB : POU_1;\nEND_VAR\nmyFB();\n 変数の宣言 myFB 次の警告が表示されます。 メッセージ: C0571: ウォームのリセット中に VAR_RETAIN 内のインスタンスの FB_EXIT も呼び出されますが、FB_INIT では呼び出されません。FB_EXIT でファンクションブロックの宣言を保持することは避けてください " }, 
{ "title" : "コンパイラ警告 C0572 ", 
"url" : "_cds_error_c0572.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0572 ", 
"snippet" : "0572 メッセージ <variable2>: <variable1>初期化されていない変数はの初期化に使用されます。を使用してください。 'global_init_slot' 初期化の順序を変更する属性。 考えられるエラー原因 : 入れ子構造の場合、内部構造に初期化されていない変数が存在すると、エラー C0268 の代わりに警告 C0272 が発行されます。 警告の例 GVL {attribute 'qualified_only'} VAR_GLOBAL       x : INT := 7;       y : INT := 9; END_VAR TYPE DUT : STRUCT    ...", 
"body" : "0572 メッセージ <variable2>: <variable1>初期化されていない変数はの初期化に使用されます。を使用してください。 'global_init_slot' 初期化の順序を変更する属性。 考えられるエラー原因 : 入れ子構造の場合、内部構造に初期化されていない変数が存在すると、エラー C0268 の代わりに警告 C0272 が発行されます。 警告の例 GVL\n{attribute 'qualified_only'}\nVAR_GLOBAL\n      x : INT := 7;\n      y : INT := 9;\nEND_VAR\n\nTYPE DUT :\nSTRUCT\n      a : INT;\n      i : INT := GVL.x;\nEND_STRUCT\nEND_TYPE\n\nTYPE DUT_1 :\nSTRUCT\n      d : DUT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR CONSTANT " }, 
{ "title" : "コンパイラ警告 C0573 ", 
"url" : "_cds_error_c0573.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0573 ", 
"snippet" : "0573 メッセージ : ザ・ ABSTRACT キーワードが見つかりません。 考えられるエラー原因 : 次のようなメソッドの場合 'abstract' オプションは追加時に設定されていたが、 ABSTRACT その後、キーワードはエディターから削除されました。 エラー訂正 : を挿入 ABSTRACT キーワードがエディタに戻った。...", 
"body" : "0573 メッセージ : ザ・ ABSTRACT キーワードが見つかりません。 考えられるエラー原因 : 次のようなメソッドの場合 'abstract' オプションは追加時に設定されていたが、 ABSTRACT その後、キーワードはエディターから削除されました。 エラー訂正 : を挿入 ABSTRACT キーワードがエディタに戻った。 " }, 
{ "title" : "コンパイラエラー C0576 ", 
"url" : "_cds_error_c0040-1853453.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラエラー C0576 ", 
"snippet" : "0576 メッセージ : 宣言メソッドの外部から '<メソッド名>' の VAR_INST '<変数名>' にアクセスできません 考えられるエラー原因 : にアクセスしようとしました VAR_INST 宣言メソッド外の変数。 エラー修正: エラーの例: FUNCTION_BLOCK FB_Test ... METHOD TestMethod: BOOL VAR_INST       bInst:BOOL; END_VAR PROGRAM PLC_PRG VAR       fbTest:FB_Test;       bTest:BOOL; END_VAR bTest := fbTest.Tes...", 
"body" : "0576 メッセージ : 宣言メソッドの外部から '<メソッド名>' の VAR_INST '<変数名>' にアクセスできません 考えられるエラー原因 : にアクセスしようとしました VAR_INST 宣言メソッド外の変数。 エラー修正: エラーの例: FUNCTION_BLOCK FB_Test\n...\nMETHOD TestMethod: BOOL\nVAR_INST\n      bInst:BOOL;\nEND_VAR\n\nPROGRAM PLC_PRG\nVAR\n      fbTest:FB_Test;\n      bTest:BOOL;\nEND_VAR\nbTest := fbTest.TestMethod.bInst; \n メッセージ: C0576: 宣言メソッドの外部から 'TestMethod' の VAR_INST 'bInst' にアクセスできない。 エラー修正: 間違ったステートメントを削除するか、アクセスする変数の宣言を変更してください (代わりに: VAR_INST メソッドの場合、 VAR_INPUT ファンクションブロック用)。 " }, 
{ "title" : "コンパイラ警告 C0579 ", 
"url" : "_cds_error_c0579.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：プログラミング \/ エラーメッセージと警告 \/ コンパイラ警告 C0579 ", 
"snippet" : "C0579 メッセージ : メッセージ コンパイラ機能 <またはコンパイラ機能 > はコンパイラバージョン  <バージョン> またはそれより新しい 考えられるエラーの原因 :ライブラリでコンパイラ機能が使用されている プロジェクトの互換性を強制するには オプション。現在設定されているコンパイラバージョンでは使用できません。 エラー修正 : 機能の使用を中止するか、メッセージで指定されたコンパイラバージョンに更新してください。 例 ザル VAR_GENERIC CONSTANT スコープはコンパイラバージョン 3.5.18.0 で導入されました。 このコンパイラ機能を現在設定されているコンパイラ...", 
"body" : "C0579 メッセージ : メッセージ コンパイラ機能 <またはコンパイラ機能 > はコンパイラバージョン  <バージョン> またはそれより新しい 考えられるエラーの原因 :ライブラリでコンパイラ機能が使用されている プロジェクトの互換性を強制するには オプション。現在設定されているコンパイラバージョンでは使用できません。 エラー修正 : 機能の使用を中止するか、メッセージで指定されたコンパイラバージョンに更新してください。 例 ザル VAR_GENERIC CONSTANT スコープはコンパイラバージョン 3.5.18.0 で導入されました。 このコンパイラ機能を現在設定されているコンパイラバージョン 3.5.16.0 のライブラリで使用すると、「 すべてのプールオブジェクトをチェックしてください。 「」コマンドを実行すると、次のエラーメッセージが生成されます。 C0579: コンパイラ機能 '汎用定数変数' は、コンパイラバージョン 3.5.18.0 以降でのみサポートされています 詳細については、以下を参照してください。 VAR_GENERIC CONSTANT" }, 
{ "title" : "参照：ユーザーインターフェイス ", 
"url" : "_cds_f_reference_user_interface.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "通知 ", 
"url" : "_cds_notification.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ 通知 ", 
"snippet" : "通知は、利用可能な更新やセキュリティ通知などの重要な情報について通知します。 開くには 通知 ビューをクリックすると、 のフレームウィンドウの右上隅にあるアイコン CODESYS 。受信したすべての通知がこのビューに表示されます。としてマークされている通知 読んだ 削除されます CODESYS 次のスタートのリストから。 新しい通知とその金額は赤で示されます アイコン。...", 
"body" : "通知は、利用可能な更新やセキュリティ通知などの重要な情報について通知します。 開くには 通知 ビューをクリックすると、 のフレームウィンドウの右上隅にあるアイコン CODESYS 。受信したすべての通知がこのビューに表示されます。としてマークされている通知 読んだ 削除されます CODESYS 次のスタートのリストから。 新しい通知とその金額は赤で示されます アイコン。 " }, 
{ "title" : "オブジェクト ", 
"url" : "_cds_struct_reference_objects.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト ", 
"snippet" : "のオブジェクト CODESYS アプリケーションを作成するための特定の機能を提供します。例：アプリケーション、プログラム、機能、ライブラリマネージャー、デバイス、およびイメージプール。オブジェクトは、のツリー構造で管理されます デバイス 、 POU 、 と モジュール ビュー。 クリックできます プロジェクト→オブジェクトの追加 にコマンド 入れる それぞれの「ツリー」へのオブジェクト。挿入オプションは、ツリー内の位置によって異なります。 すべてのオブジェクトには、オブジェクトのコンテキストメニューのコマンドを使用して表示およびアクセスできるプロパティがあります。...", 
"body" : "のオブジェクト CODESYS アプリケーションを作成するための特定の機能を提供します。例：アプリケーション、プログラム、機能、ライブラリマネージャー、デバイス、およびイメージプール。オブジェクトは、のツリー構造で管理されます デバイス 、 POU 、 と モジュール ビュー。 クリックできます プロジェクト→オブジェクトの追加 にコマンド 入れる それぞれの「ツリー」へのオブジェクト。挿入オプションは、ツリー内の位置によって異なります。 すべてのオブジェクトには、オブジェクトのコンテキストメニューのコマンドを使用して表示およびアクセスできるプロパティがあります。 " }, 
{ "title" : "オブジェクト：アプリケーション ", 
"url" : "_cds_obj_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：アプリケーション ", 
"snippet" : "アプリケーション シンボル： オブジェクトは、ノードとして表示されます。 デバイスツリー 。これは、コントローラプログラムの実行に必要なオブジェクトで構成されています。 アプリケーションオブジェクトを PLCロジック ノード（プログラム可能なデバイスの下）。 各アプリケーションの下に、 タスク構成 ここで、アプリケーションのどのプログラムがどのタスクによってどの設定を使用して呼び出されるかを構成します。 さらに、POU、グローバル変数リスト、ライブラリ マネージャーなど、コントローラー プログラムの POU をアプリケーションの下に挿入します。これらの POU は、このアプリケーションでのみ使...", 
"body" : "アプリケーション シンボル： オブジェクトは、ノードとして表示されます。 デバイスツリー 。これは、コントローラプログラムの実行に必要なオブジェクトで構成されています。 アプリケーションオブジェクトを PLCロジック ノード（プログラム可能なデバイスの下）。 各アプリケーションの下に、 タスク構成 ここで、アプリケーションのどのプログラムがどのタスクによってどの設定を使用して呼び出されるかを構成します。 さらに、POU、グローバル変数リスト、ライブラリ マネージャーなど、コントローラー プログラムの POU をアプリケーションの下に挿入します。これらの POU は、このアプリケーションでのみ使用できます。 で CODESYS バージョン3.5 SP20以降では、 オブジェクトを追加 コマンドはサポートされなくなりました。 アプリケーションは、プロジェクトグローバルPOUのインスタンスを使用することもできます。プロジェクトグローバルPOUを管理します POU 見る。これらの種類のインスタンスの使用は、オブジェクト指向プログラミングの考え方に基づいています。 PLC デバイス オブジェクトの下に複数のアプリケーションを挿入できます。これを行うには、アプリケーションに一意の名前を付ける必要があります。 「親アプリケーション」を変更した後のオンライン変更は、PLCから「子アプリケーション」を削除します。 複数のアプリケーションが1つのアプリケーション直下にある場合 CODESYS デバイスの場合、デバイスのI\/O処理のために、ターゲットシステムとの通信に使用する変数を持つアプリケーションを定義する必要があります。設定は、 PLC設定 デバイス エディターのタブ。 オンラインモードで作業するアプリケーションは、「アクティブアプリケーション」として設定する必要があります（ アプリ2 （上の図参照）。 アプリケーションに特別なプロパティを設定できます アプリケーションビルドオプション のタブ プロパティ アプリケーションオブジェクトのダイアログ。例：動的メモリ割り当てのアクティブ化 アプリケーションをPLCにダウンロードするときに、アプリケーションの内容に関する情報を含めることができます。これは、 アプリケーションビルドオプション タブ。その後、コントローラー上のアプリケーションをでアクティブなアプリケーションと比較できます。 CODESYS 。 作成者、バージョン、および個々の簡単な説明に関する個々の情報を追加する場合は、一般的な情報を変更できます プロジェクト情報 に 情報 のタブ プロパティ ダイアログ。 アプリケーションを使用してターゲットシステム（PLCまたはシミュレーション）にログインする場合、最初に、現在PLC上にあるアプリケーションと、コントローラーのアプリケーションパラメーターがプロジェクト構成のパラメーターと一致するかどうかがチェックされます。対応するメッセージは、不一致と追加アクションの可能なオプションについて通知します。このステップでは、PLCからアプリケーションを削除することもできます。 詳細については、以下を参照してください。 PLCへのアプリケーションのダウンロードに 申し込み デバイスエディタのタブで、デバイスに現在存在するアプリケーションを確認できます。そこで、ターゲットシステムからアプリケーションを削除することもできます。デバイスツリー内の個別のオブジェクトで表されていない追加のアプリケーションも表示される可能性があります。 <application>_symbols.app 、アプリケーション用に作成されたシンボルリストが含まれています（「シンボル構成」を参照）。 " }, 
{ "title" : "アラーム管理用のオブジェクト ", 
"url" : "_cds_obj_alarm_objects.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ アラーム管理用のオブジェクト ", 
"snippet" : "アラーム管理のヘルプページは、視覚化のヘルプにまとめられています。したがって、次のオブジェクトに関するヘルプを探してください。 アラーム設定 物体 警報クラス 物体 アラームグループ 物体 アラームストレージ 物体 リモートアラーム 物体...", 
"body" : "アラーム管理のヘルプページは、視覚化のヘルプにまとめられています。したがって、次のオブジェクトに関するヘルプを探してください。 アラーム設定 物体 警報クラス 物体 アラームグループ 物体 アラームストレージ 物体 リモートアラーム 物体 " }, 
{ "title" : "オブジェクト：ライブラリマネージャー ", 
"url" : "_cds_obj_library_manager.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：ライブラリマネージャー ", 
"snippet" : "ライブラリマネージャー シンボル： ライブラリマネージャーには、アプリケーションを作成するためにプロジェクトに統合されているすべてのライブラリが一覧表示されます。ライブラリのタイプ、そのプロパティ、およびその内容に関する情報を提供します。 統合ライブラリのリストを展開または折りたたんだり、依存しないライブラリのライブラリプロパティを編集したりできます。 ライブラリマネージャーは、次の3つのビューで構成されています。 上図：統合ライブラリ一覧 左下のビュー：上のビューで選択されたライブラリのすべてのモジュールを含むツリー構造 右下のビュー：ツリーで選択されたライブラリPOUのドキュメント 詳細に...", 
"body" : "ライブラリマネージャー シンボル： ライブラリマネージャーには、アプリケーションを作成するためにプロジェクトに統合されているすべてのライブラリが一覧表示されます。ライブラリのタイプ、そのプロパティ、およびその内容に関する情報を提供します。 統合ライブラリのリストを展開または折りたたんだり、依存しないライブラリのライブラリプロパティを編集したりできます。 ライブラリマネージャーは、次の3つのビューで構成されています。 上図：統合ライブラリ一覧 左下のビュー：上のビューで選択されたライブラリのすべてのモジュールを含むツリー構造 右下のビュー：ツリーで選択されたライブラリPOUのドキュメント 詳細については、次を参照してください。 ライブラリの使用 と ライブラリ開発者向けの情報" }, 
{ "title" : "統合ライブラリのリスト ", 
"url" : "_cds_obj_library_manager.html#UUID-9b9a510b-0925-f73b-58bd-0ea218f5f2d6_id_ad23efddceafc3f3c0a8640e012263e7_id_fc299100cef8fcc5c0a8640e01a9c911", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：ライブラリマネージャー \/ 統合ライブラリのリスト ", 
"snippet" : "ライブラリが他のライブラリに依存している場合、これらの参照ライブラリは自動的に統合されます。 灰色のフォントで表示 プラグインを使用して、ライブラリをプロジェクトに自動的に追加しました。 黒のフォントで表示 The ライブラリを追加 コマンドを使用して、ライブラリをプロジェクトに自動的に追加しました。 名前 次の構文での統合ライブラリーの表示： <プレースホルダー名> = <ライブラリ名>, <バージョン> (<会社名>): <プレースホルダー名> ：ライブラリがプレースホルダーライブラリの場合、プレースホルダー名は = 。 <プレースホルダー名> = (未解決) : プレースホルダー ライブ...", 
"body" : "ライブラリが他のライブラリに依存している場合、これらの参照ライブラリは自動的に統合されます。 灰色のフォントで表示 プラグインを使用して、ライブラリをプロジェクトに自動的に追加しました。 黒のフォントで表示 The ライブラリを追加 コマンドを使用して、ライブラリをプロジェクトに自動的に追加しました。 名前 次の構文での統合ライブラリーの表示： <プレースホルダー名> = <ライブラリ名>, <バージョン> (<会社名>): <プレースホルダー名> ：ライブラリがプレースホルダーライブラリの場合、プレースホルダー名は = 。 <プレースホルダー名> = (未解決) : プレースホルダー ライブラリは解決されていません。 <ライブラリ名> ：ライブラリリポジトリでの管理に使用されるライブラリの名前 <バージョン> ：最初に統合されたときに参照されたバージョン （<会社>） ：ベンダー（オプション） 名前空間 ライブラリのコンテンツに一意にアクセスするための名前空間 この目的のために、モジュール識別子の前に追加されます。 <名前空間>。<ライブラリPOU識別子> 名前空間は通常、ライブラリ名と一致します。 注：ライブラリにプロパティがある場合 LanguageModelAttribute \"qualified-access-only\" 、 次にあなた した方が良い 名前空間を使用して、アプリケーションコードのライブラリPOUにアクセスします。修飾された（一意の）アクセスが適用されます。 （プロジェクト内で）ローカルで使用するために、標準の名前空間を変更できます。 プロパティ ダイアログ。 有効版 解決後のライブラリのバージョン このバージョンのライブラリがアプリケーションで使用されます。 要件：ライブラリマネージャーが デバイス ビューが表示され、プレースホルダーライブラリが選択されます。 例： 3.5.10.0 選択したプレースホルダー ライブラリの現在の解像度がデフォルトから逸脱していることを通知するツールチップ付きのシンボル ライブラリマネージャーが デバイス 見る： このプレースホルダーは、このバージョンに明示的にリダイレクトされます（[プレースホルダー]ダイアログを参照）。 ライブラリマネージャーが POU 見る： 「Device_1」デバイスでは、プレースホルダーは「VisuElemsAlarms、1.0.0.0（システム）」に解決されます。 信頼できる証明書で署名されたライブラリ（ CODESYS >= V 3.5 SP15 信頼できる証明書で署名されているが、少なくとも1つの署名されていないライブラリを参照しているライブラリ 秘密鍵とトークンで署名されたライブラリ（ CODESYS >= V 3.5 SP15 署名されていない、または信頼できない証明書または期限切れの証明書で署名されているライブラリ 信頼できない証明書の場合、 信頼証明書 コマンドはコンテキストメニューで提供されます。 使用できないライブラリまたは未解決のプレースホルダ ライブラリ ヒント: 使用可能なライブラリをプレースホルダーに割り当てます。これを行うには、 コマンド アイコン。そこでプレースホルダーを編集して、たとえば、最新バージョンまたは別のライブラリを割り当てることができます。 オプションとして定義され、現在利用できないライブラリ ステータスが決定されているライブラリ 現在有効なライセンスが利用できないライセンスライブラリ 署名（暗号化）を検証できなかったためにロードできないライブラリのライブラリシンボル POU プール内の Library Manager によって管理されるライブラリ ライブラリマネージャーのコマンド ライブラリを追加 ライブラリを選択するためのダイアログを開きます ライブラリリポジトリにインストールされているすべてのライブラリが提供されます。 ライブラリを削除 現在選択されているライブラリをプロジェクトから削除します プロパティ 現在選択されているライブラリのプロパティを表示および編集するためのダイアログを開きます 詳細 現在選択されているライブラリの詳細（一般情報、コンテンツ、プロパティ、ライセンス情報）を含むダイアログを開きます ライブラリをリロードしてみてください 見つからないとマークされたライブラリを選択した場合は、このコマンドを使用してプロジェクトへのロードを再試行できます。 不足しているライブラリをダウンロード Library Manager で見つからないとマークされたライブラリを表示するダイアログを開きます。 ダウンロードすると、 CODESYS プロジェクト オプションで指定されたダウンロード サーバーでこれらのライブラリをスキャンします。ダウンロード後、自動的にインストールされます。 このダイアログが開いている限り、最近インストールしたライブラリをアンインストールできます。 プレースホルダー を開きます プレースホルダー ダイアログ。現在の解像度が表示され、そこで編集できます。 ライブラリ パラメータ を開きます ライブラリ パラメータ ダイアログ。アプリケーションと POU プールの Library Manager に存在するライブラリのパラメータが表示されます。このダイアログでパラメータをカスタマイズできます。 ライブラリ リポジトリ を開きます ライブラリリポジトリ ライブラリをインストールおよびアンインストールし、ライブラリの場所を定義するためのダイアログ アイコン凡例 を開きます 情報 統合ライブラリのリストにあるライブラリの現在のステータスを表示するアイコンの凡例を含むダイアログ（上記を参照） 概要 を開きます ライブラリの概要 ダイアログ プロジェクトで参照されているすべてのライブラリは、ダイアログのツリー構造で表示され、これらのライブラリを参照しているライブラリも表示されます。 ライブラリ階層内のすべてのオカレンスを表示し、ダイアログを閉じる コマンド：ライブラリマネージャーのエディターで、このライブラリを参照または使用するオープンツリー構造のライブラリにマークが付けられます。要件：ライブラリが選択されている。 The 情報 その後、ダイアログは閉じられます。 このコマンドは、ライブラリをダブルクリックしたときにも実行されます。 ライブラリの表示 管理ライブラリ ：ライブラリの名前とバージョン 発生数 ：このライブラリが他のライブラリによって参照されている場所の数 クリックすると + ライブラリの場合、このライブラリを参照するライブラリは、次のレベルに表示されます。 信頼証明書 ライブラリが信頼できない証明書で署名されている、ライブラリマネージャで選択されたライブラリのコンテキストメニューでのみ このコマンドは、信頼されていない証明書を信頼できる証明書に変換し、先頭に追加されたアイコンが に . ライブラリのエクスポート ライブラリマネージャーで選択したライブラリのコンテキストメニューでのみ使用可能 ライブラリファイルをファイルシステムに保存するためのデフォルトのダイアログを開きます " }, 
{ "title" : "選択したライブラリのすべてのモジュールのツリー構造 ", 
"url" : "_cds_obj_library_manager.html#UUID-9b9a510b-0925-f73b-58bd-0ea218f5f2d6_id_ad23efddceafc3f3c0a8640e012263e7_id_6cd6c4dccef8fcc5c0a8640e01f982cf", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：ライブラリマネージャー \/ 選択したライブラリのすべてのモジュールのツリー構造 ", 
"snippet" : "選択した<ライブラリ名>ライブラリの内容 ライブラリと統合されたすべてのライブラリPOUは、ツリー構造で一覧表示されます。 要件：上部ビューでライブラリが選択されている。 メニューバーでは、通常の並べ替えおよび検索機能を使用できます。...", 
"body" : "選択した<ライブラリ名>ライブラリの内容 ライブラリと統合されたすべてのライブラリPOUは、ツリー構造で一覧表示されます。 要件：上部ビューでライブラリが選択されている。 メニューバーでは、通常の並べ替えおよび検索機能を使用できます。 " }, 
{ "title" : "左下のビューで選択されたライブラリPOUのドキュメント ", 
"url" : "_cds_obj_library_manager.html#UUID-9b9a510b-0925-f73b-58bd-0ea218f5f2d6_id_ad23efddceafc3f3c0a8640e012263e7_id_b14c72af30bf9a91c0a864635d6eb897", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：ライブラリマネージャー \/ 左下のビューで選択されたライブラリPOUのドキュメント ", 
"snippet" : "実装ライブラリのドキュメントは一度生成する必要があります。これは、 クリックしてライブラリのドキュメントを更新します 指図。 タブ： 入力\/出力 ライブラリPOUのインターフェース（入力\/出力） タブ： グラフィカル モジュールのグラフィック表示 タブ： ドキュメンテーション ライブラリPOUのドキュメント 注：ライブラリ開発者は、「ライブラリ開発のガイドライン」に含まれるドキュメントのルールに細心の注意を払う必要があります。 詳細については、次を参照してください。 ライブラリ開発のまとめ タブ：ライブラリパラメータ 要件：ライブラリプロジェクトには、ライブラリパラメータを持つオブジェクトが含...", 
"body" : "実装ライブラリのドキュメントは一度生成する必要があります。これは、 クリックしてライブラリのドキュメントを更新します 指図。 タブ： 入力\/出力 ライブラリPOUのインターフェース（入力\/出力） タブ： グラフィカル モジュールのグラフィック表示 タブ： ドキュメンテーション ライブラリPOUのドキュメント 注：ライブラリ開発者は、「ライブラリ開発のガイドライン」に含まれるドキュメントのルールに細心の注意を払う必要があります。 詳細については、次を参照してください。 ライブラリ開発のまとめ タブ：ライブラリパラメータ 要件：ライブラリプロジェクトには、ライブラリパラメータを持つオブジェクトが含まれています。 の 設定ダイアログを開く コマンドはタブにあります。このコマンドは、 ライブラリ パラメータ ダイアログ。 " }, 
{ "title" : "オブジェクト: DUT ", 
"url" : "_cds_obj_dut.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト: DUT ", 
"snippet" : "DUT DUT (データユニットタイプ) は、ユーザー固有のデータタイプを宣言します。 シンボル: DUT テキストリストをサポートする列挙 この種類のオブジェクトは、アプリケーションの下またはアプリケーションに追加できます POU 見る。 オブジェクトが作成されると、 DUT を追加します。 ダイアログが開きます。ここで、新しいデータ型を設定し、構成 (構造体、列挙、エイリアス、ユニオン) から選択できます ユーザー定義データ型宣言の構文 TYPE <identifier> : <data type declaration> END_TYPE DUT コンストラクト 括弧の間には、ユーザー定...", 
"body" : "DUT DUT (データユニットタイプ) は、ユーザー固有のデータタイプを宣言します。 シンボル: DUT テキストリストをサポートする列挙 この種類のオブジェクトは、アプリケーションの下またはアプリケーションに追加できます POU 見る。 オブジェクトが作成されると、 DUT を追加します。 ダイアログが開きます。ここで、新しいデータ型を設定し、構成 (構造体、列挙、エイリアス、ユニオン) から選択できます ユーザー定義データ型宣言の構文 TYPE <identifier> : <data type declaration> END_TYPE DUT コンストラクト 括弧の間には、ユーザー定義のデータ型宣言が挿入されます。 TYPE と END_TYPE 。 TYPE <identifier> : STRUCT     <member declaration> END_STRUCT END_TYPE 構造体はそのメンバーを以下で囲みます STRUCT と END_STRUCT 。メンバーはいくつでも宣言できますが、最低でも2名です。 STRUCTTYPE <identifier> : (     <list of members> ) <base data type> := <initialization> ; END_TYPE 列挙は、カンマで区切られたメンバー名を丸括弧で囲んだリストです。すべてのメンバーのデータ型は同じです 列挙にはテキストリストを割り当てることもできます。これは列挙の値をローカライズするために使用されます。その結果、オブジェクトにはローカライズビューもあります 列挙TYPE <identifier> : <data type name> ; END_TYPE エイリアスは代替識別子です。 AliasTYPE <identifier> : UNION     <member declaration> END_UNION END_TYPE 組合は組合員を囲みます UNION そして END_UNION 。複数のメンバーが同じメモリ位置を共有するデータ型です。 UNION例 構造の宣言 S_POLYGONLINE メンバーの部分初期化あり TYPE S_POLYGONLINE :\nSTRUCT\n aiStart : ARRAY[1..2] OF INT := [-99, -99];\n aiPoint1 : ARRAY[1..2] OF INT;\n aiPoint2 : ARRAY[1..2] OF INT;\n aiPoint3 : ARRAY[1..2] OF INT;\n aiPoint4 : ARRAY[1..2] OF INT;\n aiEnd : ARRAY[1..2] OF INT := [99, 99];\nEND_STRUCT\nEND_TYPE 構造の宣言 S_PENTAGON の延長として S_POLYGONLINE TYPE S_PENTAGON EXTENDS S_POLYGONLINE :\nSTRUCT\n aiPoint5 : ARRAY[1..2] OF INT;\nEND_STRUCT\nEND_TYPE 例 列挙の宣言 E_TRAFFICSIGNAL {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE E_TRAFFICSIGNAL :\n(\n eRed,\n eYellow,\n eGreen := 10\n);\nEND_TYPE ローカリゼーションビューでのテキストリストサポート付き列挙 ザル テキストビュー と ローカリゼーションビュー ボタンはエディターの右端にあります。ボタンをクリックしてビューを切り替えます。 例 エイリアスの宣言 TYPE A_MESSAGE : STRING[50];\nEND_TYPE 例 の宣言 UNION TYPE U_DATA :\nUNION\n lrA : LREAL;\n liA : LINT;\n dwA : DWORD;\nEND_UNION\nEND_TYPE " }, 
{ "title" : "ダイアログ: DUT を追加 ", 
"url" : "_cds_obj_dut.html#UUID-a00e77a7-6296-ccb7-ec7b-23e513eff544_id_c3f3067aba82cc0a8640e00158fd5_id_e443a77ca18a3080c0a8646312bf4a62", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト: DUT \/ ダイアログ: DUT を追加 ", 
"snippet" : "ファンクション : ダイアログは新規の設定に使用されます DUT オブジェクト (データユニットタイプ)。 コール : プロジェクト → オブジェクト追加 → DUT  メニュー; アプリケーションオブジェクトのコンテキストメニュー [名前] 新しいものの名前 DUT データタイプ 例: S_POLYGONLINE データタイプ 構造 データ型の異なる複数の変数を 1 つの論理ユニットにまとめる構造を宣言するオブジェクトを作成します。 構造体内で宣言された変数はメンバーと呼ばれます。 例: S_POLYGONLINE 上級者向け : 既存の構造をより多くのメンバーで拡張します 入力フィールドで...", 
"body" : "ファンクション : ダイアログは新規の設定に使用されます DUT オブジェクト (データユニットタイプ)。 コール : プロジェクト → オブジェクト追加 → DUT  メニュー; アプリケーションオブジェクトのコンテキストメニュー [名前] 新しいものの名前 DUT データタイプ 例: S_POLYGONLINE データタイプ 構造 データ型の異なる複数の変数を 1 つの論理ユニットにまとめる構造を宣言するオブジェクトを作成します。 構造体内で宣言された変数はメンバーと呼ばれます。 例: S_POLYGONLINE 上級者向け : 既存の構造をより多くのメンバーで拡張します 入力フィールドで、既存の構造を指定します。既存の構造のメンバーは、新しい構造で自動的に使用できるようになります。 例: S_PENTAGON 列挙 複数の整数定数を論理単位に結合する列挙を宣言するオブジェクトを作成します 列挙内で宣言された定数は、列挙値とも呼ばれます。 例: E_TRAFFICSIGNAL 列挙にはテキストリストを含めることもできます。これは列挙の値をローカライズするために使用されます。その結果、オブジェクトにはローカライズビューもあります テキスト・リスト・サポートの追加 : テキストリストをサポートしていない列挙 : 列挙値のテキストリストが追加で保存された列挙 テキストリストでは、列挙値の名前をローカライズできます。 例: ETL_TRAFFICSIGNAL 注:既存の列挙型では、テキスト・リストのサポートは後からいつでも追加または削除できます。 これには、オブジェクトのコンテキストメニューのコマンドを使用します。 テキスト・リスト・サポートの追加 テキストリストのサポートを削除 ヒント:ローカライズされたテキストは、たとえばビジュアライゼーションに表示できます。この場合、ビジュアライゼーションエレメントのテキスト出力には、数値列挙値の代わりに現在の言語のシンボリック列挙値が表示されます。テキストリストをサポートする列挙がで指定されている場合 テキスト変数 ビジュアライゼーションエレメントのプロパティで、次の追加プロパティを取得します。 < <enumeration name> > . 例: ビジュアライゼーションでは、変数を使用します PLC_PRG.eTrafficLight タイプの ETL_TRAFFICSIGNAL 。 ETL_TRAFFICSIGNAL テキストリストをサポートする列挙です。すると、ビジュアライゼーションエレメントのプロパティエディターのエントリは次のようになります PLC_PRG.eTrafficLight <ETL_TRAFFICSIGNAL> . 詳細については、以下も参照してください。 テキストを使う ヒント:アプリケーションで列挙タイプを編集する場合、アプリケーションを閉じるときにプロンプトが開き、影響を受けるビジュアライゼーションを自動的に更新するかどうかを尋ねられます。 エイリアス 基本型、データ型、または関数ブロックの代替名を宣言するエイリアスを宣言するオブジェクトを作成します。 例: A_MESSAGE ユニオン ほとんど異なるデータ型を持つ複数のメンバーを 1 つの論理ユニットにまとめるユニオンを宣言するオブジェクトを作成します。 すべてのメンバーが同じオフセットを持つため、同じメモリを占有します。ユニオンのメモリ要件は、その「最大の」メンバーのメモリ要件によって決まります 例: U_DATA 追加 ダイアログを閉じて新しいオブジェクトを作成します オブジェクトは次のように表示されます デバイスツリーまたは POU 見る。オブジェクトのテキストリストも保存されている場合、 シンボルが表示されます。 " }, 
{ "title" : "オブジェクト：外部ファイル ", 
"url" : "_cds_obj_external_file.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：外部ファイル ", 
"snippet" : "外部ファイル アン 外部ファイル でプロジェクトに追加するファイルです POU 表示または デバイス 見る。クリック プロジェクト→オブジェクトの追加 開くには 外部ファイルを追加する ダイアログを表示し、ファイルがプロジェクトにどのように属するかを定義します。 の ダウンロード\/オンライン変更による転送 オプションを使用して、外部ファイルの転送を構成できます。 外部ファイルがコントローラーにダウンロードされても、プロジェクトでは更新されません。 詳細については、次を参照してください。 タブ：同期されたファイル...", 
"body" : "外部ファイル アン 外部ファイル でプロジェクトに追加するファイルです POU 表示または デバイス 見る。クリック プロジェクト→オブジェクトの追加 開くには 外部ファイルを追加する ダイアログを表示し、ファイルがプロジェクトにどのように属するかを定義します。 の ダウンロード\/オンライン変更による転送 オプションを使用して、外部ファイルの転送を構成できます。 外部ファイルがコントローラーにダウンロードされても、プロジェクトでは更新されません。 詳細については、次を参照してください。 タブ：同期されたファイル" }, 
{ "title" : "ダイアログ：外部ファイルの追加 ", 
"url" : "_cds_obj_external_file.html#UUID-df1ad64c-b999-f57c-46aa-2b3f52722fdb_id_b2054b53d955bf7c0a8640e017bbd78_id_559ac53835cd4544c0a8640e01b2e037", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：外部ファイル \/ ダイアログ：外部ファイルの追加 ", 
"snippet" : "ファイルパス 外部ファイルのパス The ボタンをクリックすると、ローカルファイルシステム内のファイルを選択するためのダイアログが開きます。 名前 内のファイルのオブジェクト名 CODESYS 空白のままにすると、ファイルは以前の名前に戻ります。 ファイル処理 外部ファイルの保存方法を決定します。 CODESYS 計画 リンクを覚える : Windows ファイル システムの外部ファイルを指すファイル リンクが保存されます。 注: ファイルの外部の場所が変更された場合、ファイル リンクを介したアクセスは失敗します。ファイルは、定義された保存場所に存在する限り、プロジェクトでのみ使用できます。 ...", 
"body" : "ファイルパス 外部ファイルのパス The ボタンをクリックすると、ローカルファイルシステム内のファイルを選択するためのダイアログが開きます。 名前 内のファイルのオブジェクト名 CODESYS 空白のままにすると、ファイルは以前の名前に戻ります。 ファイル処理 外部ファイルの保存方法を決定します。 CODESYS 計画 リンクを覚える : Windows ファイル システムの外部ファイルを指すファイル リンクが保存されます。 注: ファイルの外部の場所が変更された場合、ファイル リンクを介したアクセスは失敗します。ファイルは、定義された保存場所に存在する限り、プロジェクトでのみ使用できます。 リンクを覚えてプロジェクトに埋め込む : Windows ファイル システムの外部ファイルを指すファイル リンクが保存されます。さらに、セキュリティを強化するために、ファイルのコピーがプロジェクトに保存されます。 アクセス時の動作に関する注意: プロジェクト内のコピーは、リンク経由のアクセスが失敗した場合にのみアクセスされます。 外部ファイルが変更された場合、コピーは下で選択されたオプションに従って処理されます 変更追跡 . プロジェクトに埋め込む : 外部ファイルのコピーが Windows ファイル システムに保存されます。 コピーには常にアクセスします。外部ファイルが変更された場合、プロジェクト内部のコピーは更新されません。 外部ファイルを開く場合 CODESYS Development System ( オブジェクトの編集 コマンド)、編集用の一時ファイルが作成されます。 変更追跡 ファイルリンクが同時に保存されたプロジェクトに保存されたコピーの更新の種類 要件: リンクを覚えてプロジェクトに埋め込む オプションが選択されています。 ファイルを自動的にリロードする 注: 外部ファイルが変更されると、プロジェクトに保存されているコピーが自動的に更新されます。 ファイルをリロードするかどうかを確認する 注: 外部ファイルが変更された場合、プロジェクトでコピーを更新するかどうかを決定するダイアログ プロンプトが表示されます。 何もしない : 外部ファイルは変更されますが、プロジェクト内のコピーは変更されません。 ボタン： ファイルのプロパティを表示する デフォルトを開く <ファイル名> のプロパティ Windows ファイル システムの外部ファイルのダイアログ このダイアログは、 プロパティ ファイルのコンテキスト メニューから Windows で開くことができるダイアログ。 オンライン取り扱い オンラインモードでのファイルの扱い ダウンロード\/オンライン変更による転送 : ダウンロードおよびオンライン変更が行われると、外部ファイルがコントローラにダウンロードされ、 ターゲット パス . 注: に挿入される外部ファイル POU ビューは、ダウンロード中にプロジェクト内のすべてのコントローラーに転送されます。 このオプションは、ライブラリ内の外部ファイルには影響しません。原則として、これらのファイルは転送されません。 ターゲット パス (デバイスの \"$PlcLogic$\" からの相対パス) ターゲット パスは、次の方法で指定できます。 のために $PlcLogic$ ルート ディレクトリ: 入力フィールドを空白のままにします ルート ディレクトリの個々のフォルダ (まだ利用できません) 例： MySubDirectory アプリケーションのフォルダ（以下 $PlcLogic$ ) 「App123」アプリケーションの例: App123 アプリケーションフォルダーの下にネストされたフォルダー構造 例： App123\/Sub01\/SubSub01 視覚化用のプレースホルダーなど、別の使用可能なプレースホルダーを使用します。 $visu$ 使用可能なパスを使用する場合は、大文字と小文字に注意してください。 ボタン 追加 新しい オブジェクト (タイプ 外部ファイル ）。 詳細については、次を参照してください。 プロパティ – 外部ファイル" }, 
{ "title" : "オブジェクト：C実装ライブラリ ", 
"url" : "_cds_obj_c_implemented_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：C実装ライブラリ ", 
"snippet" : "C実装ライブラリ シンボル： オブジェクトをライブラリプロジェクトに追加します POU 見る。 A C実装ライブラリ 複数のプリコンパイル済みモジュールを含めることができ、各モジュールは特定のデバイスに割り当てられます。挿入されたモジュールは、ライブラリマネージャーに表示されません。 オブジェクトをダブルクリックすると、 POU ビュー、それはそのエディタで開きます。 コンパイルされたコンポーネント デバイスのオブジェクトファイル 次の情報を含む、モジュールが割り当てられているデバイスのリスト： デバイス 、 バージョン 、 ファイル名 、 ファイルサイズ 追加 を開きます デバイスを選択 プ...", 
"body" : "C実装ライブラリ シンボル： オブジェクトをライブラリプロジェクトに追加します POU 見る。 A C実装ライブラリ 複数のプリコンパイル済みモジュールを含めることができ、各モジュールは特定のデバイスに割り当てられます。挿入されたモジュールは、ライブラリマネージャーに表示されません。 オブジェクトをダブルクリックすると、 POU ビュー、それはそのエディタで開きます。 コンパイルされたコンポーネント デバイスのオブジェクトファイル 次の情報を含む、モジュールが割り当てられているデバイスのリスト： デバイス 、 バージョン 、 ファイル名 、 ファイルサイズ 追加 を開きます デバイスを選択 プリコンパイルされたモジュールをデバイスに割り当て、それをC実装ライブラリに追加するためのダイアログ このようなオブジェクトには、任意の数のモジュールを追加できます。このライブラリを含む具体的なプロジェクトをデバイスにダウンロードすると、それぞれ一致するファイルのみがデバイスにロードされます。 削除 で選択したエントリを削除します デバイスのオブジェクトファイル デバイスを選択 オブジェクトファイル に一致するファイルの入力 デバイス オペレーティングシステムによって動的オブジェクトとしてロードできます Windows の例: *.dll Linux の例: *.so 注: *.dll ファイルの名前には、ライブラリ プロジェクトのタイトルが含まれている必要があります。例: ライブラリ プロジェクトの名前が XYlib の場合、 オブジェクトファイル 名前を付ける必要があります: <name>_XYlib.dll デバイス ベンダー デバイスのリスト オプション カテゴリ別にグループ化 ： ：使用可能なデバイス（最新バージョン）は、カテゴリ別にソートされています。カテゴリは、デバイス記述ファイルで定義されています。 ：利用可能なデバイスは、フラットな構造でアルファベット順にソートされています。 すべてのバージョンを表示（エキスパートのみ） ：さらに、デバイスの他のすべての利用可能なバージョンも選択できます。 ：各デバイスの最新バージョンのみを選択できます。 古いバージョンを表示する ：さらに、古いバージョンのデバイスを選択することもできます。たとえば、古いバージョンは更新されたプラグインに起因します。 ：古いバージョンのデバイスは表示されません。 デバイスに関する情報 デバイスを選択 でプリコンパイルされたランタイムモジュール オブジェクトファイル 選択したものに割り当てられます デバイス 。 " }, 
{ "title" : "オブジェクト：デバイス、および汎用デバイスエディタ ", 
"url" : "_cds_f_obj_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ ", 
"snippet" : "デバイス、および汎用デバイスエディタ シンボル： デバイスオブジェクトは、特定のハードウェアコンポーネント（例：コントローラー、フィールドバスノード、バスカプラー、ドライブ、I \/ Oモジュール、またはモニター）を表します。マップします ハードウェア構造 のデバイスオブジェクトのレイアウトによって デバイスツリー の中に デバイス で見る CODESYS 。デバイスオブジェクトのデバイスオブジェクト構成エディターでは、デバイスのI \/ Oをプロジェクト変数にリンクすることもできます。 使用 デバイスを追加 また デバイスを挿入 デバイスオブジェクトをデバイスツリーに挿入するコマンド。 CODE...", 
"body" : "デバイス、および汎用デバイスエディタ シンボル： デバイスオブジェクトは、特定のハードウェアコンポーネント（例：コントローラー、フィールドバスノード、バスカプラー、ドライブ、I \/ Oモジュール、またはモニター）を表します。マップします ハードウェア構造 のデバイスオブジェクトのレイアウトによって デバイスツリー の中に デバイス で見る CODESYS 。デバイスオブジェクトのデバイスオブジェクト構成エディターでは、デバイスのI \/ Oをプロジェクト変数にリンクすることもできます。 使用 デバイスを追加 また デバイスを挿入 デバイスオブジェクトをデバイスツリーに挿入するコマンド。 CODESYS ツリーの挿入位置に常に適切なデバイスを提供します。 それぞれを開きます デバイスエディタ デバイスツリーでデバイスオブジェクトをダブルクリックします。エディターは、デバイス構成用の汎用タブとデバイス固有のタブを提供します。 " }, 
{ "title" : "汎用デバイスエディタ ", 
"url" : "_cds_edt_device_generic.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ 汎用デバイスエディタ ", 
"snippet" : "汎用デバイスエディタには、 構成 のPLCデバイスの CODESYS 。さらに、デバイス固有のタブがあるため、構成エディターは、デバイスに応じてさまざまなダイアログで構成されます。 でデバイスオブジェクトをダブルクリックすると、エディタが開きます デバイスツリー （意見： デバイス ）。 インデンでデバイスエディタの一般的な設定を行うことができます CODESYS オプション の中に デバイスエディタ カテゴリー。たとえば、汎用デバイスエディタのタブを表示および非表示にすることができます。 デバイスエディタには、デバイスの名前が付けられています。汎用デバイスエディタの次のタブを含めることができ...", 
"body" : "汎用デバイスエディタには、 構成 のPLCデバイスの CODESYS 。さらに、デバイス固有のタブがあるため、構成エディターは、デバイスに応じてさまざまなダイアログで構成されます。 でデバイスオブジェクトをダブルクリックすると、エディタが開きます デバイスツリー （意見： デバイス ）。 インデンでデバイスエディタの一般的な設定を行うことができます CODESYS オプション の中に デバイスエディタ カテゴリー。たとえば、汎用デバイスエディタのタブを表示および非表示にすることができます。 デバイスエディタには、デバイスの名前が付けられています。汎用デバイスエディタの次のタブを含めることができます。 コミュニケーション ：開発システムとプログラマブルデバイス（PLC）間の接続の構成。厳密にI \/ Oデバイスの場合は使用できません アプリケーション ：コントローラー上のアプリケーションのリスト <デバイス>パラメータ ：デバイスパラメータの表示と設定 バックアップと復元 ：PLC上のアプリケーション固有のファイルのバックアップと復元の構成 同期されたファイル ：アプリケーションダウンロード時にPLCにダウンロードされたファイル一覧 ファイル ：「ホスト」ファイルシステムとデバイス間のファイル転送の構成 ログ ：PLCログファイルの表示 PLC設定 ：I \/ Oの処理の構成：どのアプリケーション、停止状態での動作、更新、バスサイクルオプションなど。 PLCシェル ：コントローラーから特定の情報を問い合わせるためのテキストベースのコントロールモニター <デバイス> I \/ Oマッピング ：使用可能なチャネルを表示し、コントローラの入力、出力、およびメモリアドレスをアプリケーションの変数または機能ブロック全体にマッピングできます。 <デバイス> IECオブジェクト ：IECアプリケーションからデバイスへのアクセスを提供するオブジェクトのリスト ユーザーとグループ ：実行時のデバイスに関するユーザー管理。 アクセス権 ：デバイス上のオブジェクトおよびファイルにアクセスするための権利。 シンボルの権利 ：デバイス上のシンボル（シンボルセット）への個々のユーザーグループのアクセス権。 タスクリスト ：タスクに割り当てられているすべての入力と出力の概要（トラブルシューティングに役立ちます）。 スターテス ：デバイス固有のステータスおよび診断メッセージ。 情報 ：デバイスに関する一般情報（名前、ベンダー、バージョンなど） " }, 
{ "title" : "タブ：通信設定 ", 
"url" : "_cds_edt_device_communication_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：通信設定 ", 
"snippet" : "汎用デバイスエディタのこのタブで、間の接続を定義します CODESYS およびアプリケーションを実行するデバイス。 ダイアログの従来の表示モードを使用する場合は、ダイアログでそれを選択します。 CODESYS オプション の中に デバイスエディタ カテゴリー。 リストボックスからゲートウェイとターゲットデバイスを選択します。可能な選択は、のエントリによって異なります。 ゲートウェイの管理 と お気に入りのデバイスを管理する ダイアログ（を参照してください ゲートウェイ メニュー）。 IPアドレス（例：「192.168.101.109」）、デバイスアドレス（例： [056D] ）、またはデバイス...", 
"body" : "汎用デバイスエディタのこのタブで、間の接続を定義します CODESYS およびアプリケーションを実行するデバイス。 ダイアログの従来の表示モードを使用する場合は、ダイアログでそれを選択します。 CODESYS オプション の中に デバイスエディタ カテゴリー。 リストボックスからゲートウェイとターゲットデバイスを選択します。可能な選択は、のエントリによって異なります。 ゲートウェイの管理 と お気に入りのデバイスを管理する ダイアログ（を参照してください ゲートウェイ メニュー）。 IPアドレス（例：「192.168.101.109」）、デバイスアドレス（例： [056D] ）、またはデバイス名（例： MyDevice ）。デバイスを入力すると、 CODESYS ゲートウェイのネットワーク内でデバイスを検索します。 デバイス名で検索するオプションには、ネットワーク内の一意のデバイス名が必要です。 ゲートウェイシンボルの右下隅にある黒丸は、接続ステータスに関する情報を提供します。 赤： CODESYS 接続を確立できません。 緑：接続が確立されています。 黒：接続状態は不明です。 一部の通信プロトコルでは、ゲートウェイを定期的にチェックできるため、ステータスを表示できません。 ターゲットデバイスの黒丸をクリックすると、デバイスのネットワークスキャンが開始されます。これは、ネットワークがまだスキャンされていない場合にのみ機能します。 ネットワークをスキャン このボタンは デバイスを選択 ダイアログ。構成されているすべてのゲートウェイと関連するデバイスが一覧表示されます。このリストから1つのターゲットデバイスを選択できます。選択したデバイスの名前が一意である場合、その名前が接続設定で使用されます。それ以外の場合は、一意のデバイスアドレスが適用されます。 表示されるパラメーターはランタイムシステムの SysTarget コンポーネントで定義され、基本的にコントローラーのタイププレートを表します。デバイス名は、を使用して変更できます。 [デバイス] → アクティブデバイスの名前を変更 コマンド。 オプション: 一致しないデバイスを非表示にし、ターゲット ID で絞り込む : : 表示できるのは、プロジェクトで現在設定されているデバイスと同じターゲット ID を持つデバイスに限定されます。 : ネットワークで使用可能なすべてのデバイスが表示されます。プロジェクトで設定されているデバイスとターゲットシステム ID が異なるデバイスのエントリをダブルクリックすると、ダイアログボックスが開きます。このダイアログボックスでは、プロジェクト内のデバイスのデバイス説明を、選択したデバイスと一致する説明に更新できます。注:このような更新は ID が異なるデバイスでのみ可能で、バージョンが異なるだけのデバイスではできません。また、更新にはデバイスの説明がリポジトリに既にインストールされている必要があります。 ゲートウェイ このメニューには、次のコマンドが含まれています。 新しいゲートウェイを追加 ：開く ゲートウェイ 新しいゲートウェイ チャネルを定義するためのダイアログ ゲートウェイを管理 : を開きます。 ゲートウェイを管理 すべてのゲートウェイの概要を示すダイアログ。ここでは、エントリを追加、削除、編集したり、順序を変更したりできます ローカルゲートウェイを構成する ：を開きます ゲートウェイ構成 ダイアログ。ローカルゲートウェイのブロックドライバーを構成できます。 デバイス このメニューには、次のコマンドが含まれています。 通信設定をプロジェクトに保存する ： 現在のデバイスをお気に入りに追加 ：現在設定されているデバイスをお気に入りのデバイスのリストに追加します。 お気に入りのデバイスを管理する ：すべての優先デバイスのリストを含むお気に入りダイアログを開きます。このダイアログでは、エントリを追加または削除したり、順序を変更したりできます。一番上のデバイスがデフォルトです。 確認済みのオンラインモード ： : セキュリティ上の理由から、 CODESYS 次のオンラインコマンドを呼び出す場合は、ユーザーからの確認が必要です。 フォースバリュー 、 値を書き込む 、 複数読み込み 、 リリースフォースリスト 、 シングルサイクル 、 開始 、 ストップ 。 通信設定をプロジェクトに保存する ： ： CODESYS 同じコンピューターで再利用できるように、通信設定をプロジェクトに保存します。 注：プロジェクトを別のコンピューターで使用する場合は、アクティブパスをリセットする必要があります。 ： CODESYS 同じコンピューターで再利用できるように、通信設定をローカルインストールのオプションに保存します。 注：使用する場合 CODESYS SVN、デバイスオブジェクトのブロックを防ぐために、オプションをクリアする必要があります。 アクティブデバイスの名前を変更 ： デバイス名を変更するためのダイアログを開きます ： セキュリティ上の理由から、 CODESYS 次のオンラインコマンドを呼び出すときは、次のことを確認する必要があります：強制値、値の書き込み、複数のロード、強制リストの解放、単一サイクル、開始、停止。 ：プロジェクトで構成されている現在のデバイスと同じターゲットIDを持つデバイスでの表示が制限されます。 暗号化された通信 ： ：本機との通信は暗号化されています。コントローラにログインするには、コントローラの証明書が必要です。証明書が利用できない場合は、証明書を表示してインストールするかどうかを確認するエラーメッセージが表示されます。 もし 暗号化通信を強制する オプションが セキュリティレベル の中に セキュリティ画面 ビュー、次に 暗号化通信 コマンドはここでは無効です。 コミュニケーションポリシーの変更 を開きます ランタイム セキュリティ ポリシーの変更 通信の暗号化のデバイス設定を変更するためのダイアログ ランタイム パスワード ポリシーの変更 を開きます ランタイム パスワード ポリシーの変更 パスワード ポリシーとログイン ロックの設定を変更するためのダイアログ セキュリティ設定 ：このコマンドは、次の場合にのみ使用できます CODESYS Security Agent > = 1.3.0.0がインストールされています。それは開きます デバイスのセキュリティ設定 ダイアログ。接続されているデバイスの現在のセキュリティ設定が表示されます。で設定を変更できます 価値 列をクリックしてクリックします わかった それらをデバイスに書き込みます。 たとえば、デバイスのユーザー管理とパスワードポリシーの設定は、次の場所にあります。 CmpUserMgr ノード (以下も参照)。 ダイアログ： ランタイム セキュリティ ポリシーの変更 このダイアログで新しい通信ポリシーを選択すると、コントローラの設定が変更されます。 通信設定 現在のポリシー 通信の暗号化について現在選択されているポリシーを表示します 新しいポリシー 暗号化の新しいポリシーのリストボックス 暗号化なし ：端末は暗号化通信に対応していません。 オプションの暗号化 : デバイスは、暗号化および非暗号化通信をサポートしています。 強制暗号化 ：デバイスは暗号化通信のみをサポートしています。 コード署名 現在のポリシー ランタイムシステムで現在設定されているコード署名ポリシーの表示 新しいポリシー 全て : すべてのタイプのアプリケーション コードが受け入れられます。 強制署名 : 署名されたアプリケーション コードのみが受け入れられます (信頼できないソースからのアプリケーションのロードを防ぎます)。 デバイスユーザー管理 現在のポリシー ユーザー管理用に現在選択されているポリシーを表示します 新しいポリシー オプションのユーザー管理 ：デバイスでユーザー管理を有効にするか、デバイスを保護しないままにするのはユーザーの責任です。 ユーザー管理の強制 : デバイスのユーザー管理は有効になっており、ユーザーが無効にすることはできません。 の対応するエントリ [セキュリティ設定] : CmpUserMgr UserMgmtEnforce 。 匿名ログインを許可する ：特定の登録済みコンポーネント（たとえば、OPC UA）は、資格情報を提供せずにコントローラーに接続できます。 OPC UAへの匿名アクセスが許可されている場合でも、コントローラー用に作成されたデバイスユーザー管理はアクティブなままです。 の対応するエントリ [セキュリティ設定] デバイスの: CmpUserMgr UserMgmt.AllowAnonymous 。 ダイアログ: ランタイム パスワード ポリシーの変更 ここで設定されたランタイムシステムパスワードポリシーは、新しいデバイスユーザーのパスワードが入力されたとき、またはデバイスユーザーの既存のパスワードが変更されたときに、プログラミングシステムで事前にチェックされます。 パスワードポリシーでパスワードの有効期間が制限されている場合、この期間が経過した後にログインすると、ユーザーは新しいパスワードを設定するように求められます。 注:有効期限が切れる前にパスワードを変更するには、現在のところ、ユーザーは引き続きデバイスユーザー管理のための読み取り権限を必要とします。 パスワード ポリシーがアクティブです パスワードポリシーが有効です : このポリシーはデフォルトで有効になっています。 パスワード設定 デバイスユーザー管理用のパスワードを作成する際に変更して使用できます。 の対応するエントリ セキュリティ設定 デバイスの下にあります。 CmpUserMgr ノード ( UserMgmt.PasswordPolicy.<..> )。の設定ファイル内 CODESYS Control 、これは以下に対応します。 CMP ユーザーマネージャ セクション。例: [CmpUserMgr]\nSECURITY.UserMgmt.PasswordPolicy=ENABLED パスワード設定 最小長 デフォルト設定: 8 固有文字数 デフォルト設定: 4 小文字が必要 デフォルト設定: 有効 大文字が必要 デフォルト設定: 有効 数字が必要です デフォルト設定: 有効 特殊文字が必要です デフォルト設定: 有効 ユーザー名を含めないでください デフォルト設定: 有効 ルールが部分的または完全に無効になっている場合でも、パスワードに関する次のルールは常に適用されます。 パスワードを空白にすることはできません。 パスワードにはユーザー名を含めないでください。 パスワードの有効期限が有効です : ザ・ パスワード有効期限設定 変更可能で、ログイン時に適用されます。 の対応するエントリ [セキュリティ設定] デバイスの:の下 CmpUserMgr ノード ( Password.Expiration.<...> )。 パスワードの有効期限設定 : スコープ : 管理者 : 設定は管理者権限を持つユーザーに適用されます。 管理者なし : 設定は管理者権限を持たないすべてのユーザーに適用されます。 [すべて] : 設定はすべてのユーザーに適用されます。 タイムアウト [日数] : パスワードの有効期間 (日数)。この時間を超えると、以前のパスワードではログインできなくなります。この場合、すぐに新しいパスワードを設定するよう求められます ログインロックが有効です : ザ・ ログインロック設定 ログイン時に適用されます。 の対応するエントリ [セキュリティ設定] デバイスの:の下 CmpUserMgr ノード ( UserLogin.<...> )。 ログインロック設定 スコープ 管理者 ：設定は、管理者権限を持つユーザーに適用されます。 管理者なし : 設定は管理者権限を持たないすべてのユーザーに適用されます。 全て : 設定はすべてのユーザーに適用されます。 最大再試行回数 ：ここで指定したログイン試行回数を超えると、ユーザーは ロック期間 分野。管理者がロックを解除するか、ロックアウト時間が経過するまで、ユーザーは再度ログインできません。 ロック期間 [秒] ：ロック時間（秒） ロックされたユーザーのロック解除については、以下を参照してください。 デバイスユーザー管理の処理" }, 
{ "title" : "通信設定–クラシックモード ", 
"url" : "_cds_edt_device_communication_settings.html#UUID-4f041ba7-d0d4-e8fe-3708-a0ef62d6108b_id_a8ca3cbc369b81dc0a8640e012568ee_id_5427e3926f2911e49f48f439849fe1dc", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：通信設定 \/ 通信設定–クラシックモード ", 
"snippet" : "の中に CODESYS オプション、あなたはのクラシックモードをアクティブにすることができます ツール→オプション 「デバイスエディタ」カテゴリのダイアログ）。 コントローラへのネットワークパスを選択します 接続用のゲートウェイチャネル ビューの下部からチャネルを選択します。 構成済みのゲートウェイチャネルとネットワークデバイスを表示するビュー ビューの左側 ローカルネットワーク内の接続されたデバイスで構成されたゲートウェイチャネルのツリー構造： ノート： CODESYS これらのエントリは、プロジェクトではなく、ローカルシステムに保存されます。 デバイスエントリの前に デバイスシンボル。プロ...", 
"body" : "の中に CODESYS オプション、あなたはのクラシックモードをアクティブにすることができます ツール→オプション 「デバイスエディタ」カテゴリのダイアログ）。 コントローラへのネットワークパスを選択します 接続用のゲートウェイチャネル ビューの下部からチャネルを選択します。 構成済みのゲートウェイチャネルとネットワークデバイスを表示するビュー ビューの左側 ローカルネットワーク内の接続されたデバイスで構成されたゲートウェイチャネルのツリー構造： ノート： CODESYS これらのエントリは、プロジェクトではなく、ローカルシステムに保存されます。 デバイスエントリの前に デバイスシンボル。プロジェクトで現在構成されているものとは異なるターゲットIDを持つエントリは、灰色で表示されます。 クリック スキャンネットワーク リストを更新します。 注：ローカルシステムで最初のプロジェクトを作成した場合、ローカルゲートウェイはデフォルトでツリーのエントリとしてリストされます。 CODESYS システムの起動時にこのゲートウェイを自動的に開始します。 ゲートウェイシンボルの右下隅にある黒丸は、接続ステータスに関する情報を提供します。 赤： CODESYS Development System 接続を確立できません。 緑：接続は 設立。 黒：接続状態は不明です。 注：一部の通信プロトコルでは、ゲートウェイを定期的にチェックできるため、ステータスを表示できません。 ツリー内の各デバイスエントリは、シンボルとそれに続く <デバイス名> [ デバイスアドレス ]。ビューの右側には、 ターゲットID 、 ターゲット名 、 ターゲットタイプ、ターゲットベンダー 、 と ターゲットバージョン 。 ビューの右側 ビューの左側で選択されたデバイスのゲートウェイチャネルに関する情報 左側のビューでゲートウェイチャネルを選択すると、次の情報が表示されます。 装置名 、 IPアドレス 、 港 、 運転者 左側のビューでデバイスを選択すると、次の情報が表示されます（デバイスによって異なります）。 装置名 、 デバイスアドレス 、 チャネル数 、 ブロックドライバー 、 シリアルナンバー 、 暗号化された通信 、 ターゲットベンダー 、 ターゲットID 、 ターゲット名 、 ターゲットタイプ 、 ターゲットバージョン 。 ダイアログの右側にあるフィルターおよびソート機能 フィルター 同じデバイスの表示リストを減らすことができます ターゲットID プロジェクトで構成されている現在のデバイスとして。 並べ替え順序 リストは次のように並べ替えることができます 名前 また デバイスアドレス アルファベット順または昇順。 ダイアログの右側にあるコマンドボタン アクティブパスを設定する このコマンドは、選択した通信チャネルをアクティブとして設定します。チャネルツリーのエントリをダブルクリックすると、同じ結果が得られます。 ゲートウェイを追加 コマンドは ゲートウェイ ゲートウェイを定義できるダイアログ CODESYS 現在の構成に追加する必要があります。 デバイスを追加 コマンドは デバイスを追加 ダイアログ。ここでは、ツリーで現在選択されているゲートウェイエントリの下に挿入されるデバイスを手動で定義できます。の機能に注意してください スキャンネットワーク 同じように。 スキャンネットワーク このコマンドは、ローカルネットワークで使用可能なデバイスの検索を開始します。それに応じて、ゲートウェイの構成ツリーが更新されます。 ダイアログのゲートウェイツリーとデバイスツリーのコンテキストメニューのコマンド アドレスでデバイスをスキャン このコマンドは、構成ツリーで指定された一意のアドレスを持つデバイスをネットワークで検索します。 CODESYS ゲートウェイの下に指定されたアドレスで検出されたデバイスを表示します。検索は常に、選択したゲートウェイの下または選択したエントリの下のデバイスに適用されます。 名前でデバイスをスキャンする このコマンドは、構成ツリーで指定された名前と同じ名前のデバイスをネットワークで検索します。キャピタライゼーションは無視されます。 CODESYS ゲートウェイの下に検出されたデバイスを、指定された名前とその一意のデバイスアドレスとともに表示します。検索は常に、選択したゲートウェイの下または選択したエントリの下のデバイスに適用されます。 IPアドレスでデバイスをスキャンする このコマンドは、構成ツリーで指定された一意のIPアドレスを持つデバイスをネットワークで検索します。 CODESYS ゲートウェイの下に指定されたアドレスを持つ検出されたデバイスをその名前とともに表示します。検索は常に、選択したゲートウェイの下または選択したエントリの下のデバイスに適用されます。 エコーサービスを送信する CODESYS 5つのエコーサービスをコントローラーに送信します。これらは、「ping」機能と同様に、ネットワーク接続をテストするために使用されます。サービスは最初にペイロードなしで送信され、次にペイロード付きで送信されます。ペイロードの範囲は、PLCの通信バッファによって異なります。メッセージビューが開き、平均エコーサービス遅延と送信されたペイロードのスコープに関する情報が表示されます。 選択したデバイスを削除する このコマンドは、選択したデバイスをチャネルツリーから削除します。 ゲートウェイの編集 コマンドは ゲートウェイ 選択したゲートウェイの設定を編集するためのダイアログ。 ローカルゲートウェイを構成する このコマンドは、ローカル ゲートウェイを構成するためのダイアログを開きます。これにより、手動で編集する代わりの方法が提供されます。 Gateway.cfg ファイル。 ダイアログの下部にあるオプション プロジェクトに通信設定を保存しないでください ： CODESYS 同じコンピューターで再利用できるように、通信設定をローカルインストールのオプションに保存します。 注：使用する場合 CODESYS SVN、デバイスオブジェクトのブロックを防ぐためにオプションを選択する必要があります。 ： CODESYS 同じコンピューターで再利用できるように、通信設定をプロジェクトに保存します。 注：プロジェクトを別のコンピューターで使用する場合は、アクティブパスをリセットする必要があります。 確認済みのオンラインモード : セキュリティ上の理由から、 CODESYS 次のオンラインコマンドを呼び出す場合は、ユーザーからの確認が必要です。 フォースバリュー 、 値を書き込む 、 複数読み込み 、 リリースフォースリスト 、 シングルサイクル 、 開始 、 ストップ 。 " }, 
{ "title" : "タブ：パラメータ ", 
"url" : "_cds_edt_device_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：パラメータ ", 
"snippet" : "このダイアログは、テストを目的としています。その値は専門家のみが変更する必要があります。 デバイス固有のパラメータは、のこのタブの表に表示されます。 汎用デバイスエディタ 。デバイスの説明は、このダイアログで編集できるパラメーターを定義します。 列ヘッダーをクリックすると、エントリをアルファベットの昇順または降順、またはデフォルトの順序で並べ替えることができます。 パラメーター パラメータ名、編集不可 タイプ パラメータのデータ型、編集不可 価値 最初に、パラメータのデフォルト値を直接、または対応するシンボル名を表示します。編集できないパラメータは薄い灰色で表示されます。パラメータが編集可能な...", 
"body" : "このダイアログは、テストを目的としています。その値は専門家のみが変更する必要があります。 デバイス固有のパラメータは、のこのタブの表に表示されます。 汎用デバイスエディタ 。デバイスの説明は、このダイアログで編集できるパラメーターを定義します。 列ヘッダーをクリックすると、エントリをアルファベットの昇順または降順、またはデフォルトの順序で並べ替えることができます。 パラメーター パラメータ名、編集不可 タイプ パラメータのデータ型、編集不可 価値 最初に、パラメータのデフォルト値を直接、または対応するシンボル名を表示します。編集できないパラメータは薄い灰色で表示されます。パラメータが編集可能な場合は、テーブルフィールドをダブルクリックして入力フィールド、リストボックス、またはファイル選択ダイアログを開き、それを使用して値を変更できます。 デフォルト値 デバイスの説明で定義されたパラメータのデフォルト値、編集不可 単位 値の測定単位（例：ミリ秒の場合は「ms」、編集不可） 説明 デバイスの説明で指定されたパラメーターの簡単な説明、編集不可 " }, 
{ "title" : "タブ：アプリケーション ", 
"url" : "_cds_edt_device_applications.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：アプリケーション ", 
"snippet" : "のこのタブで 汎用デバイスエディタ デバイスに存在するアプリケーションを確認できます。システムに応じて、デバイスからアプリケーションを削除したり、アプリケーションに関する詳細情報を取得したりできます。 PLC上のアプリケーション によって発見されたアプリケーションのリスト リストを更新 コントローラの最後のスキャン中 消去 すべて削除 詳細については、「従属安全コントローラ」の章を参照してください。 注：安全コントローラがPLCの下に挿入されている場合、このコマンドは次のことができます。 恒久的に 安全コントローラから他の安全コントローラ（安全ネットワーク変数を介して）、フィールドデバイス、お...", 
"body" : "のこのタブで 汎用デバイスエディタ デバイスに存在するアプリケーションを確認できます。システムに応じて、デバイスからアプリケーションを削除したり、アプリケーションに関する詳細情報を取得したりできます。 PLC上のアプリケーション によって発見されたアプリケーションのリスト リストを更新 コントローラの最後のスキャン中 消去 すべて削除 詳細については、「従属安全コントローラ」の章を参照してください。 注：安全コントローラがPLCの下に挿入されている場合、このコマンドは次のことができます。 恒久的に 安全コントローラから他の安全コントローラ（安全ネットワーク変数を介して）、フィールドデバイス、および開発システムへの通信リンクを中断します。安全フィールドデバイスおよびその他の安全コントローラは、反応として安全状態に入ることができます。開発システムへの接続は、フィールドバスを介してメインコントローラに接続されているセーフティコントローラの場合にのみ影響を受けます。 リストで選択されているアプリケーション、またはコントローラーにリストされているすべてのアプリケーションを削除します 詳細 を開きます 詳細 ダイアログ。上のアプリケーション用に定義された情報を表示します 情報 ダイアログのタブ プロパティ 。 コンテンツ 要件： アプリケーション情報をダウンロードする オプションはでアクティブになります プロパティ 上のアプリケーションオブジェクトの アプリケーション生成オプション タブ。これにより、アプリケーションのコンテンツに関する情報がPLCに追加でダウンロードされます。 The コンテンツ ボタンをクリックすると、最新の生成コードとコントローラーに存在するアプリケーションコードの違いに関する追加情報を含むダイアログが開きます。さまざまなPOUが比較ビューに表示されます。 リストを更新 コントローラがスキャンされてアプリケーションが検出され、それに応じてリストが更新されます。 あなたは設定することができます デバイスからアプリケーションを削除する また デバイスからアプリケーションを削除する のコマンド ツール→カスタマイズ ダイアログ。これらのコマンドは、 消去 また すべて削除 ボタン。 " }, 
{ "title" : "タブ：バックアップと復元 ", 
"url" : "_cds_edt_device_backup_and_restore.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：バックアップと復元 ", 
"snippet" : "汎用デバイスエディタのこのタブで、PLC上のアプリケーション固有のファイルのバックアップと復元を開始します。これを行うには、パックされたバックアップファイルを配置するか、ファイルを読み戻します。 詳細については、以下を参照してください。 保存して回復する要件：デバイスへの接続の通信設定が正しいこと。バックアップを実行するアプリケーションがコントローラーに存在します。 メニューバー バックアップ ボタンは、次のコマンドでメニューを開きます。 デバイスからバックアップ情報を読み取る ：コマンドは、からアプリケーション固有のファイルを検索します $PlcLogic$ PLCのディレクトリであり、タブ...", 
"body" : "汎用デバイスエディタのこのタブで、PLC上のアプリケーション固有のファイルのバックアップと復元を開始します。これを行うには、パックされたバックアップファイルを配置するか、ファイルを読み戻します。 詳細については、以下を参照してください。 保存して回復する要件：デバイスへの接続の通信設定が正しいこと。バックアップを実行するアプリケーションがコントローラーに存在します。 メニューバー バックアップ ボタンは、次のコマンドでメニューを開きます。 デバイスからバックアップ情報を読み取る ：コマンドは、からアプリケーション固有のファイルを検索します $PlcLogic$ PLCのディレクトリであり、タブの下部にテーブルとして表示されます。 バックアップファイルを作成してディスクに保存 ： 要件： デバイスからバックアップ情報を読み取る コマンドは、バックアップ関連ファイルを判別するために使用されました。これらのファイルは、タブ付きページの下部にある表にあります。 このコマンドは、次のように設定されたテーブル内のファイルを圧縮します アクティブ そしてその meta.info 情報ファイルをバックアップzipファイルに変換します。ファイル拡張子は tbf （= \"ターゲットバックアップファイル\"）。 バックアップファイルをデバイスに保存 ： 要件：バックアップファイルがディスクに保存されている。このコマンドは、バックアップファイルをに保存します TBF PLCのディレクトリ。 戻す ボタンは、次のコマンドでメニューを開きます。 ディスクからバックアップファイルをロードする ：コマンドは 開ける 保存されたバックアップファイルのファイルシステムをナビゲートするためのダイアログ。含まれているファイルは、タブ付きページの下部にある表にリストされています。 デバイスからバックアップファイルをロードする ：このコマンドは、PLCで見つかったすべてのバックアップファイルのリストを生成します。これらのファイルの1つを選択して、タブ付きページのテーブルにその内容を表示します。復元操作では、オプションのコンポーネントを非アクティブ化し、コメントを編集できます。 デバイスへのバックアップの復元 ：このコマンドは、現在タブにロードされているバックアップファイルの少なくとも1つのコンポーネントがアクティブに設定されている場合に使用できます。デバイスのアプリケーションステータスを復元するように求められます。復元中、ユーザーインターフェイスはブロックされます。操作をキャンセルできます。 ターゲット情報 ID PLCのID（例： 0000 0001 ）。 タイプ デバイスタイプ（例： 4096 ）。 バージョン デバイスバージョン（例： 3.5.8.0 ）。 バックアップ情報 ファイル名 バックアップファイルのストレージパス。クリックすると ボタンをクリックすると、ファイルシステムダイアログが開きます。例： PlcLogic$\/Application\/Application.crc アクティブなファイルのサイズ （キロバイト単位）テーブルでアクティブとして設定されたファイルの合計サイズ（例： 206 KB (210965 bytes) ）。 モード バックアップの範囲を定義します。 申し込み 。アプリケーション関連のファイルがパックされています。 コメント コメントを保存するためのオプションのエントリ meta.info バックアップのファイルとファイルが復元されたときの読み取り。 バックアップ用ファイルの表 アクティブ ：オプションのファイルは、バックアップファイルで除外するためにここで非アクティブ化できます。 必要なコンポーネントは、緑色のチェックマーク（チェックボックスなし）でここに表示されます。 成分 影響を受けるコンポーネント（例： file system ）。 ファイル バックアップするコンポーネントファイルの名前（例： $PlcLogic$\/Application\/Application.app ）。 サイズ バイト単位のファイルサイズ（例： 43280 ）。 STOPが必要 ：コンポーネントの場合、バックアップと復元の前にアプリケーションを停止する必要があります。バックアップまたは復元の競合を警告するダイアログプロンプトが開きます。 " }, 
{ "title" : "タブ：同期されたファイル ", 
"url" : "_cds_edt_device_synchronized_files.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：同期されたファイル ", 
"snippet" : "のタブ 汎用デバイスエディタ アプリケーションのダウンロード時にPLCにダウンロードされるファイルを一覧表示します。たとえば、これらは 外部ファイル アプリケーションに追加されました。 ソースコードアーカイブファイルなどの暗黙的なファイルは、ダウンロード時間がこれと ImplizitePLCのエディタでアプリケーションをダウンロードするための暗黙のファイルを表示します オプションが選択されている CODESYS のオプション デバイスエディタ カテゴリー。 更新 ビューを更新します 「オンデマンド」ファイルをダウンロードする 内部使用のみ。 ファイル名 アプリケーションの下にあるファイルの名前...", 
"body" : "のタブ 汎用デバイスエディタ アプリケーションのダウンロード時にPLCにダウンロードされるファイルを一覧表示します。たとえば、これらは 外部ファイル アプリケーションに追加されました。 ソースコードアーカイブファイルなどの暗黙的なファイルは、ダウンロード時間がこれと ImplizitePLCのエディタでアプリケーションをダウンロードするための暗黙のファイルを表示します オプションが選択されている CODESYS のオプション デバイスエディタ カテゴリー。 更新 ビューを更新します 「オンデマンド」ファイルをダウンロードする 内部使用のみ。 ファイル名 アプリケーションの下にあるファイルの名前、または暗黙的に転送されたファイルの直接名（例： archive.prj ）。 ファイル名をダブルクリックしてファイルを開きます。 ホストパス ファイルの場所または元の場所（例： D:\\Proj1\\Files ）。 パスをダブルクリックして、ファイルエクスプローラーでディレクトリを開きます。 タイミング PLCでのファイル更新の時間間隔（例： アプリケーションのダウンロード\/オンライン変更後 ）。 情報 オブジェクトに依存する追加情報（例： オブジェクト：外部ファイル ）。 プロバイダー ファイルの一般的なオリジンタイプ（例： 外部ファイルオブジェクト 、 ソースコードダウンロードプロバイダー ）。 " }, 
{ "title" : "タブ：ファイル ", 
"url" : "_cds_edt_device_files.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：ファイル ", 
"snippet" : "のこのタブで 汎用デバイスエディタ 、ファイルを転送できます CODESYS （ホスト）とPLC。通信設定が正しく、PLCがオンラインの場合、 CODESYS の期間中、PLCへの接続を自動的に確立します ファイル転送 。...", 
"body" : "のこのタブで 汎用デバイスエディタ 、ファイルを転送できます CODESYS （ホスト）とPLC。通信設定が正しく、PLCがオンラインの場合、 CODESYS の期間中、PLCへの接続を自動的に確立します ファイル転送 。 " }, 
{ "title" : "", 
"url" : "_cds_edt_device_files.html#UUID-e9ed7dc5-188b-7cea-31fd-715ea645231c_UUID-aa1b8515-35d0-1cd1-0849-d17b1439fc52", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：ファイル \/ ", 
"snippet" : "ホスト\/ランタイム 標準のファイルマネージャの機能を備えたホストのファイルシステムへのアクセス 位置 ホスト側でのファイル転送の現在のディレクトリ 設定したパスに新しいディレクトリを作成するためのダイアログを開きます 選択したファイルまたはディレクトリを削除します 設定した場所のファイルとディレクトリのリストを更新します 選択したファイルとディレクトリを、ホストおよびランタイムシステムからそれぞれの他のファイルシステムにコピーします ターゲットディレクトリでファイルがまだ利用できない場合は、ファイルが作成されます。すでに使用可能であり、書き込み保護されていない場合は、上書きされます。次に、対応...", 
"body" : "ホスト\/ランタイム 標準のファイルマネージャの機能を備えたホストのファイルシステムへのアクセス 位置 ホスト側でのファイル転送の現在のディレクトリ 設定したパスに新しいディレクトリを作成するためのダイアログを開きます 選択したファイルまたはディレクトリを削除します 設定した場所のファイルとディレクトリのリストを更新します 選択したファイルとディレクトリを、ホストおよびランタイムシステムからそれぞれの他のファイルシステムにコピーします ターゲットディレクトリでファイルがまだ利用できない場合は、ファイルが作成されます。すでに使用可能であり、書き込み保護されていない場合は、上書きされます。次に、対応するメッセージが表示されます。 ：に対応 コントローラへのファイルの書き込み 指図 ：に対応 コントローラからファイルを書き込む 指図 ファイルをダブルクリックする 選択したファイルをWindowsのデフォルトプログラムで開きます 代替：ファイルを選択+ 入力 鍵 例：TXTファイルがWindowsのメモ帳で開く 注：Windowsのデフォルトプログラムで開くことは、ホスト側でのみ可能です。 デフォルトでは、 コントローラへのファイルの書き込み と コントローラからファイルを書き込む コマンドはどのメニューにも含まれていません。を使用してメニューに挿入できます ツール→カスタマイズ のダイアログ オンライン コマンドカテゴリ。 " }, 
{ "title" : "タブ: ログ ", 
"url" : "_cds_edt_device_log.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ: ログ ", 
"snippet" : "あなたはできる ビュー 汎用のこのタブの PLC ログ デバイスエディタ 。ターゲット システムに記録されたイベントがリストされます。これは次のことに関係します。 システムの起動およびシャットダウン中のイベント (ロードされたコンポーネント、バージョン付き) アプリケーションのダウンロードと起動アプリケーションのロード カスタムエントリ I\/O ドライバーからのログ エントリ データソースからのログエントリ の ログ クリックするとタブも開きます ログページを開く 。これは、メニュー コマンドとして設定できます。 カスタマイズ ダイアログ。...", 
"body" : "あなたはできる ビュー 汎用のこのタブの PLC ログ デバイスエディタ 。ターゲット システムに記録されたイベントがリストされます。これは次のことに関係します。 システムの起動およびシャットダウン中のイベント (ロードされたコンポーネント、バージョン付き) アプリケーションのダウンロードと起動アプリケーションのロード カスタムエントリ I\/O ドライバーからのログ エントリ データソースからのログエントリ の ログ クリックするとタブも開きます ログページを開く 。これは、メニュー コマンドとして設定できます。 カスタマイズ ダイアログ。 " }, 
{ "title" : "", 
"url" : "_cds_edt_device_log.html#UUID-07798ea7-5bf9-767c-956e-9d523915b989_UUID-f8e0ab33-5cb2-7220-fd3c-9c0abaec2c6a", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ: ログ \/ ", 
"snippet" : "メニューバー すべてのランタイムシステムコンポーネントのログイベントのリストを更新します コンポーネント リストボックスで選択されたランタイムシステムコンポーネントによってログイベントの表示をフィルタリングします 例： CmpApp これらのコンポーネントで発生するすべてのイベントを表示します。例：「 Application [ <name> ] loaded via [OnlineChange] \"。 <すべてのコンポーネント> ：すべてのコンポーネントの報告されたイベントを表示します 次のページに新しいログメッセージをロードします 前のページに古いログメッセージをロードします 最新のログエ...", 
"body" : "メニューバー すべてのランタイムシステムコンポーネントのログイベントのリストを更新します コンポーネント リストボックスで選択されたランタイムシステムコンポーネントによってログイベントの表示をフィルタリングします 例： CmpApp これらのコンポーネントで発生するすべてのイベントを表示します。例：「 Application [ <name> ] loaded via [OnlineChange] \"。 <すべてのコンポーネント> ：すべてのコンポーネントの報告されたイベントを表示します 次のページに新しいログメッセージをロードします 前のページに古いログメッセージをロードします 最新のログエントリを含むページをロードし、自動スクロールを有効にします ：まだ表示されていない新しいログメッセージがあることを示します これはステータスバーにも次のように表示されます 自動スクロール：オン 。 最も古いログメッセージを含むページをロードします 重大度でイベントをフィルタリングします 警告 いくつあるかを通知します 青い輪郭のボタン：警告が表示されます。 重大度でイベントをフィルタリングします エラー いくつあるかを通知します 青い輪郭のボタン：エラーが表示されます。 重大度でイベントをフィルタリングします 例外 いくつあるかを通知します 青い輪郭のボタン：例外が表示されます。 重大度でイベントをフィルタリングします 情報 そしてその数を通知します 青い輪郭のボタン：情報が表示されます。 重大度でイベントをフィルタリングします デバッグ いくつあるかを通知します 青い輪郭のボタン：デバッグメッセージが表示されます。 メッセージを検索する 検索テキストの入力フィールド 検索フィールドに1つ以上の文字を入力すると、ロガーメッセージはヒットを黄色で強調表示します。 次のヒットにジャンプします 前のヒットにジャンプします ロガー 記録されたイベントを表示するためのロガーを有効にします デフォルトでは、 <default logger> システムによって定義されたが設定されます。たとえば、それはロガーです PlcLog のために CODESYS Control Win ランタイムシステム。 .Audit.log : このロガーは、コントローラーとのすべてのユーザー操作を表示します。ユーザー名も記録されます。これらは、ダウンロード、開始、停止、ブレークポイントの設定などのアクションです。ユーザーが特定のアクションの実行を許可されていない場合、失敗した試行もログに記録されます。 UTC時間 ：以下に表示される時間を変換します タイムスタンプ 開発システムの現地時間に 変換は、オペレーティングシステムのタイムゾーンに基づいています。 CODESYS が走っています。 （デフォルト設定） ：ランタイムシステムの元のタイムスタンプを表示します オプションを変更すると、表示されているタイムスタンプが自動的に変換されます。 リストの内容をxmlファイルにエクスポートします ファイル名と場所を選択できます。 ファイルシステムに保存されたログメッセージを含むXMLファイルをインポートします 別のウィンドウが開き、ログメッセージが表示されます。 ログファイル付きの表示ウィンドウ ログメッセージの表形式の表示 1ページに1万件のログメッセージが表示されます。 重大度 ： 警告 ： エラー ： 例外 ： 情報 ：デバッグメッセージ タイムスタンプ 開発システムまたはランタイムシステムの日時） 例： 1\/12\/2007 9:48 説明 イベントの説明 例： PLC started 成分 報告されたイベントが発生したランタイムコンポーネント ステータスバー 自動スクロール 自動スクロールが有効になっているかどうかを表示します（ オン ）または無効（ オフ ）。 オン ：変更が発生すると、ログリストが自動的に更新されます。 オフ ：新しいログイベントが発生すると、その横に表示されます オフ 。また、 ボタンはで飾られています メニューバーにあります。 ヒント：をクリックします 有効にするボタン 自動スクロール 。 エラーチェック の例外について *SOURCEPOSITION* 説明、影響を受ける関数は、それをダブルクリックするか、 エディタでソースコードを表示する コンテキストメニューのコマンド。エラーの原因となっている行にカーソルがジャンプします。あなたが持っているときにこの診断を実行することもできます CODESYS ダウンロード情報ファイルとエクスポートされたログファイルを含むプロジェクトアーカイブ。 影響を受ける機能が保護されると、次のメッセージが表示されます。 <関数名>のソースコードはありません。 「」 もし VendorException が報告された後、メーカー固有の例外エラーが発生しました CODESYS ランタイム。詳細については、PLCの製造元にお問い合わせください。 " }, 
{ "title" : "タブ：PLC設定 ", 
"url" : "_cds_edt_device_plc_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：PLC設定 ", 
"snippet" : "のこのタブで 汎用デバイスエディタ 、入力と出力の処理やバスサイクルタスクなど、PLCの構成の基本設定を行います。 I\/O処理のアプリケーション I\/O処理を担当するアプリケーション PLC設定 停止中のI\/Oを更新 ：PLCが入っているとき、入力チャネルと出力チャネルの値も更新されます ストップ モード。ウォッチドッグが誤動作を検出すると、出力は事前定義されたデフォルト値に設定されます。 ：の入力チャネルと出力チャネルの値 ストップ モードは更新されません。 停止時の出力の動作 コントローラが入るときの出力チャネルの処理 ストップ モード： 値を保持する ：現在の値が保持されます。 すべての...", 
"body" : "のこのタブで 汎用デバイスエディタ 、入力と出力の処理やバスサイクルタスクなど、PLCの構成の基本設定を行います。 I\/O処理のアプリケーション I\/O処理を担当するアプリケーション PLC設定 停止中のI\/Oを更新 ：PLCが入っているとき、入力チャネルと出力チャネルの値も更新されます ストップ モード。ウォッチドッグが誤動作を検出すると、出力は事前定義されたデフォルト値に設定されます。 ：の入力チャネルと出力チャネルの値 ストップ モードは更新されません。 停止時の出力の動作 コントローラが入るときの出力チャネルの処理 ストップ モード： 値を保持する ：現在の値が保持されます。 すべての出力をデフォルト値に ：I\/Oマッピングの結果のデフォルト値が割り当てられます。 プログラムを実行する ：出力値の処理は、で実行されるプロジェクトに含まれるプログラムによって制御されます。 ストップ モード。右側のフィールドにプログラムの名前を入力します。 常に変数を更新する バスサイクルタスクでI\/O変数を更新するかどうかをグローバルに定義します この設定は、スレーブとモジュールのI \/ O変数に対して、「 非アクティブ化 \"は更新設定で定義されています。 非アクティブ化（タスクで使用される場合にのみ更新） ：I \/ O変数は、タスクで使用されている場合にのみ更新されます。 有効1（どのタスクでも使用されていない場合はバスサイクルタスクを使用） ：バスサイクルタスクのI \/ O変数は、他のタスクで使用されていない場合に更新されます。 有効2（常にバスサイクルタスクで） ：バスサイクルタスクの各サイクルのすべての変数は、それらが使用されているかどうか、および入力チャネルと出力チャネルのどちらにマップされているかに関係なく、更新されます。 このオプションを使用できるかどうかは、デバイスの説明によって異なります。 バスサイクルオプション バスサイクルタスク バスサイクルを制御するタスク。デフォルトでは、デバイスの説明で定義されたタスクが入力されます。 デフォルトでは、上位バスデバイスのバスサイクル設定が適用されます（上位バスのサイクル設定を使用）。これは、バスサイクルタスクの次の有効な定義を探すためにデバイスツリーが上向きに検索されることを意味します。 を選択する前に <詳細不明> 「バスサイクルタスクの設定では、次のことに注意する必要があります」 <詳細不明> 「」は、デバイスの説明に記載されているデフォルト設定が有効になることを意味します。 したがって、この説明を確認する必要があります。そこでは、サイクルタイムが最も短いタスクの使用をデフォルトとして定義できますが、サイクルタイムが最も長いタスクの使用も同様に定義できます。 フィールドバスの場合、決定された動作を保証するために固定サイクルマトリックスが必要です。したがって、「 フリーホイーリング \"バスサイクルタスクのタイプ。 追加の設定 I\/Oマッピングの変数を強制する この設定は、デバイスでサポートされている場合にのみ使用できます。 ：アプリケーションをコンパイルすると、I \/ Oチャネルごとに2つのグローバル変数が作成され、の変数にマップされます。 I\/Oマッピング ダイアログ。 これらの変数を使用して、たとえばHMIの視覚化を介して、このチャネルの入力値または出力値を強制することができます。 デバイスの診断をアクティブ化する ： CAA Device Diagnosis ライブラリはプロジェクトに統合されています。デバイスごとに陰関数ブロックが生成されます。デバイスの機能ブロックがすでに存在する場合は、拡張機能ブロックが生成されるか（例：EtherCAT）、別の機能ブロックインスタンスが追加されます。これには、デバイス診断の一般的な実装が含まれます。 機能ブロックインスタンスを使用して、アプリケーション内のすべてのデバイスのステータスを判別し、エラーを評価することができます。さらに、ライブラリには、デバイスツリーをプログラムで編集するための関数が含まれています。 例：バスシステムのすべての子をスキャンし、親要素にジャンプします。 詳細については、以下を参照してください。 CAAデバイス診断ライブラリのドキュメント I\/O警告をエラーとして表示する I\/O構成に関する警告はエラーとして表示されます。 I\/Oのシンボリックアクセスを有効にする ：入力変数と出力変数 (VAR_INPUT と VAR_OUTPUT ）デバイスのI\/Oチャネル用に自動的に作成されます。この目的のために、拡張機能ブロックがスレーブごとに作成されます。基本は、スレーブの既存の機能ブロックです。この種の自動生成された機能ブロックには、アプリケーションコードから直接アクセスできます。 このシンボリックアクセスは、手動で設定されたI\/Oマッピングと並行して機能します。 ：I\/Oチャネルへのアクセスはサポートされていません。マッピングを手動で設定し、I\/Oチャネルごとに新規または既存の変数を具体的に割り当てる必要があります。 " }, 
{ "title" : "タブ：PLCシェル ", 
"url" : "_cds_edt_device_plc_shell.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：PLCシェル ", 
"snippet" : "のこのタブ 汎用デバイスエディタ コントローラから特定の情報を照会するためのテキストベースのコントロールモニタが含まれています。このためにデバイスに依存するコマンドを指定し、結果ウィンドウでコントローラーからの応答を受信できます。 の PLCシェル シミュレーションモードではサポートされていません。 詳細については、以下を参照してください。 SPSシェルを使用して情報を照会する...", 
"body" : "のこのタブ 汎用デバイスエディタ コントローラから特定の情報を照会するためのテキストベースのコントロールモニタが含まれています。このためにデバイスに依存するコマンドを指定し、結果ウィンドウでコントローラーからの応答を受信できます。 の PLCシェル シミュレーションモードではサポートされていません。 詳細については、以下を参照してください。 SPSシェルを使用して情報を照会する" }, 
{ "title" : "", 
"url" : "_cds_edt_device_plc_shell.html#UUID-1cf3dce3-ea3d-52c5-2128-ebac8bef6716_UUID-9403fb45-4885-1a82-e631-65a4038d76bf", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：PLCシェル \/ ", 
"snippet" : "標準コマンド 可能なパラメータを使用したコマンド 説明 ? 使用可能なPLCシェルコマンドのリストと可能なパラメータおよび簡単な説明 getcmdlist 使用可能なPLCシェルコマンドの名前のリスト mem <memory address> [<size>] 定義されたメモリ範囲の16進ダンプを提供します The size パラメータはオプションであり、出力されるバイト数を記述します。デフォルト値：16 例： mem 16x0422139C 8 reflect 指定されたコマンドを繰り返します（接続をテストするため） applist ロードされたすべてのアプリケーションのリストを提供します ...", 
"body" : "標準コマンド 可能なパラメータを使用したコマンド 説明 ? 使用可能なPLCシェルコマンドのリストと可能なパラメータおよび簡単な説明 getcmdlist 使用可能なPLCシェルコマンドの名前のリスト mem <memory address> [<size>] 定義されたメモリ範囲の16進ダンプを提供します The size パラメータはオプションであり、出力されるバイト数を記述します。デフォルト値：16 例： mem 16x0422139C 8 reflect 指定されたコマンドを繰り返します（接続をテストするため） applist ロードされたすべてのアプリケーションのリストを提供します リスト内の順序は、で始まるアプリケーションインデックスを定義します 0 。 pid [<application name> | <application index> ] * ロードされた1つまたはすべてのアプリケーションのGUID（アプリケーションインデックス）を提供します pinf [<application name> | <application index>] * プロジェクト情報の次のフィールドの内容を提供します：タイトル、バージョン、作成者、および説明。 要件：オプション プロパティに自動的にアクセスするためのPOUを作成する の中に プロジェクト情報 ダイアログがアクティブになります。 startprg [<application name> | <application index> ] * 指定されたアプリケーションを起動します。アプリケーションが指定されていない場合は、読み込まれたすべてのアプリケーションを起動します stopprg [<application name> | <applikation index> ] * 指定されたアプリケーションを停止します。アプリケーションが指定されていない場合は、ロードされているすべてのアプリケーションを停止します resetprg [<applikation name> | <application index> ] * 指定されたアプリケーションをリセットします。アプリケーションが指定されていない場合は、ロードされているすべてのアプリケーションをリセットします resetprgcold [<application name> | <application index> ] * 指定されたアプリケーション、またはアプリケーションが指定されていない場合はロードされたすべてのアプリケーションのコールドブートを実行します reload [<application name> | <application index>] * 指定されたアプリケーションのブートアプリケーションをロードします。アプリケーションが指定されていない場合は、ロードされたすべてのアプリケーションのブートプロジェクトをロードします。 getprgstat [<application name> | <applikationsindex>] * 指定されたアプリケーションのプログラムステータス、またはアプリケーションが指定されていない場合はロードされたすべてのアプリケーションのプログラムステータスを提供します plcload コントローラのプロセッサ負荷を（パーセントで）表示します rtsinfo ランタイムシステムに関する情報（たとえば、ランタイムシステムのプロセッサとバージョン）を提供します channelinfo 通信チャネルに関する情報を提供します rtc-get 協定世界時（UTC）を DataTime ストリング rtc-set 協定世界時（UTC）を設定します DataTime 文字列（ISO 8601を参照） listpcicards [<vendor ID>] すべてのPCIアダプターのリストを提供します（またはによってフィルターされます <vendor ID> ）。 gettaskgroups すべてのタスクグループ、それらのタスク、およびCPUコアバインディングのリストを提供します cert-getapplist 登録および使用されているすべての証明書（コンポーネントのIDと使用法）を提供します cert-genselfsigned [<number for search result by \"cert-getapplist\"> <expdays=>] 自己署名証明書を生成します 証明書の有効期間は、次の方法で指定できます。 expdays= 。 デフォルト値：365日 cert-gendhparams <length in bits> Diffie-Hellman鍵交換のパラメーターを生成します この操作は、完了するまでに数分かかる場合があります。 cert-getcertlist [<trust level>] 指定された信頼レベルのすべての証明書を一覧表示します 信頼レベルが指定されていない場合は、すべての証明書が一覧表示されます。 可能な信頼レベル untrusted ：信頼できない証明書 trusted ：信頼できる証明書 own ：コントローラーの証明書 quarantine ：検証によって信頼レベル（信頼されている、信頼されていない）を判別できない証明書 したがって、着信接続は拒否されました。 cert-createcsr [<number for search result by \"cert-getapplist\">] すべてのアプリケーションのCSRファイルを生成します cert-import <trust level> <file name.cer> 指定された証明書をインポートします cert-export <trust level> [<number of search result by \"cert-getcertlist\">] 指定された証明書をエクスポートします cert-remove <trust level> <number of search result by \"cert-getcertlist\" or \"all\"> 指定された証明書を削除します cpuload CPUのプロセッサ負荷を表示します（マルチコアの場合、各プロセッサコア） gettaskgroups 定義されたタスクグループのリストを提供します 割り当てられたタスクは、タスクグループごとに表示されます。 getmulticoreinfo マルチコアがサポートされているかどうか、および使用可能なプロセッサコアの数を示します sessinfo-list 現在ログインしているすべてのクライアント\/ユーザーのリストを提供します sessinfo-getcnt 現在ログインしているクライアント\/ユーザーの数を提供します logsetfilter [<CmpName>...] <FilterValue> ログフィルターの設定を 16 進値で構成します。 loggetfilter [<CmpName>...] 指定されたコンポーネントの現在のログ フィルター設定を取得します。 logdelfilter [<CmpName>...] 指定したコンポーネントのログ フィルター設定を削除します。 * アプリケーション名：デバイスツリー内のアプリケーションの名前 アプリケーションインデックス：で呼び出すことができるコントローラー上のすべてのアプリケーションのリストからの結果 applist 指図。索引 0 リストの最初のアプリケーションを表します。 1 2番目のように。 " }, 
{ "title" : "タブ：<デバイス名> I \/ Oマッピング ", 
"url" : "_cds_edt_device_io_mapping.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：<デバイス名> I \/ Oマッピング ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "I \/ Oチャネルを備えたデバイス ", 
"url" : "_cds_edt_device_io_mapping.html#UUID-fbea3edd-739b-f693-2a4d-f97a628b9269_id_ebd811526ea50336c0a8640e0138a0ff_id_2fed243abb96eb7ec0a864637b4cf8a3", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：<デバイス名> I \/ Oマッピング \/ I \/ Oチャネルを備えたデバイス ", 
"snippet" : "このタブは、I \/ Oチャネルを備えたデバイスのデバイスエディタに表示されます。使用可能なチャネルが表示され、コントローラの入力、出力、およびメモリアドレスをアプリケーションの変数または機能ブロック全体にマッピングできます。この方法で「I \/ Oマッピング」を作成します。 詳細については、以下を参照してください。 デバイスとI \/ Oマッピングの構成I \/ O処理を処理するアプリケーションは、 PLC設定 タブ。 デバイスがサポートしている場合は、「オンライン構成モード」を使用できます。このモードでは、事前に実際のアプリケーションをデバイスにダウンロードしなくても、ハードウェアのI \/ Oにア...", 
"body" : "このタブは、I \/ Oチャネルを備えたデバイスのデバイスエディタに表示されます。使用可能なチャネルが表示され、コントローラの入力、出力、およびメモリアドレスをアプリケーションの変数または機能ブロック全体にマッピングできます。この方法で「I \/ Oマッピング」を作成します。 詳細については、以下を参照してください。 デバイスとI \/ Oマッピングの構成I \/ O処理を処理するアプリケーションは、 PLC設定 タブ。 デバイスがサポートしている場合は、「オンライン構成モード」を使用できます。このモードでは、事前に実際のアプリケーションをデバイスにダウンロードしなくても、ハードウェアのI \/ Oにアクセスできます。 アプリケーションでI\/Oチャネルが参照されていない場合、その値は更新されません。参照されていないI\/Oチャネルを監視する場合は、 常に変数を更新する オプション タブ：PLC設定または、このオプションを I\/Oマッピング タブをクリックします。有効化はこの 1 つのデバイスとその子デバイスに対してのみ有効になります。 「大きすぎる」データ型のマッピング バイトより大きいデータ型の変数がバイトアドレスにマップされている場合、変数の値はそこでバイトサイズに切り捨てられます。の変数値を監視するため I \/ Oマッピング ダイアログの場合、これは、アドレスのルート要素に、変数が現在プロジェクトに持っている値が表示されることを意味します。バイトの現在の個々のビット値は、その下のビット要素に連続して表示されますが、これは変数値全体に対して十分ではない場合があります。 の例 <デバイス名> I \/ Oマッピング CANバススレーブのタブ： このタブには、I \/ Oマッピングを編集するためのテーブルが含まれています。入力と出力に表示される情報は、デバイスの説明に基づいています。 探す （1） マッピングテーブルで検索する文字列の入力フィールド 検索結果は黄色で強調表示されます。 フィルター （2） マッピングテーブルに表示されるI \/ Oマッピングのフィルターを含むリストボックス： すべて表示する 出力のみを表示 入力のみを表示 マップされていない変数のみを表示する マップされた変数のみを表示する 既存の変数へのマッピングのみを表示 新しい変数へのマッピングのみを表示 IOチャネルにFBを追加します （11） デバイスによっては、マッピングテーブルでチャネルエントリが選択されている場合に使用可能 を開きます 機能ブロックを選択 チャネルに直接リンクする必要がある機能ブロックを選択するためのダイアログ インスタンスに移動 （12） マッピングテーブルでエントリが選択されている場合に使用可能 上の対応するエントリにジャンプします <デバイス名> IECオブジェクト タブ 変数 デバイスに応じて、デバイスの入力と出力はノードとして表示され、その下にインデントされた関連チャネル、またはデバイスによっては暗黙的に作成されたデバイスインスタンスのみが表示されます。 記号はチャネルのタイプを示します。 ：入力 ：出力 セルをダブルクリックして、入力フィールドを開きます。 可能性1：変数はすでに存在します。 フルパスを指定します：<アプリケーション名>。<POU名>。<変数名> 例： app1.plc_prg.ivar ;経由でアシスタントを入力 可能性2：変数はまだ存在していません。 単純な名前を指定する グローバル変数として内部的に自動的に作成されます デバイスに応じて、入力または出力を機能ブロックに直接リンクできます。この場合、 IOチャネルにFBを追加します ボタンをクリックできます。上記を参照。 マッピング （3） マッピングのタイプ： ：既存の変数 ：新しい変数 : ファンクションブロックインスタンスへのマッピング チャネル （4） チャネルの記号名。 住所 （5） チャネルのアドレス（例： %IW0 ）。 アドレス取り消し線：このアドレスにこれ以上変数を割り当てないことを示します。理由：ここで指定された変数は、既存の変数として別のメモリ位置で管理されますが、値が書き込まれるとき、特に出力で、あいまいさが生じる可能性があります。 ：このアドレスが編集および修正されたことを示します デバイスツリー内のデバイスオブジェクトの配置が変更された場合は、 CODESYS このアドレスを自動的に適応させません。 タイプ （6） チャネルのデータ型（例： BOOL ）。 デバイスの説明で定義された構造またはビットフィールドは、それらがIEC規格の一部であり、デバイスの説明でIECデータ型として識別されている場合にのみ表示されます。それ以外の場合、テーブルセルは空のままです。 構造化変数をマッピングする場合、エディターは両方の構造変数を指定できないようにします（例： %QB0 ）および個々の構造要素（例： %QB0.1 と QB0.2 ）。したがって、マッピングテーブルにビットチャネルエントリのサブツリーを持つメインエントリがある場合は、次のようになります。メインエントリの行またはサブ要素（ビットチャネル）の行に変数を入力できます。 、しかし両方にではありません。 デフォルト値 チャネルに適用されるパラメータのデフォルト値：オプションの場合にのみ表示されます すべての出力をデフォルトに設定 で選択されています PLC設定 停止時の出力の動作について。 注意: コンパイラバージョンV3.5 SP11以降では、変数の初期化値は、既存の変数にマッピングするときにデフォルト値として自動的に使用されます。 デフォルト値 新しく作成された変数にマップする場合にのみ、フィールドが使用されます。以前のバージョンでは、ユーザーはデフォルト値と初期化値が同一であることを明示的に指定する必要がありました。 単位 （7） パラメータ値の単位（例： ms ミリ秒） 説明 （8） パラメータの簡単な説明 現在の価値 チャネルに適用されたパラメータの実際の値。オンラインモードでのみ表示 オンライン変更によるデフォルト値の変更は許可されていますが、値は「コールドリセット」または「ウォームリセット」の後にのみ適用されます。 マッピングのリセット （9） CODESYS マッピング設定を、デバイス記述ファイルで定義されているデフォルト値にリセットします。 常に変数を更新する （10） I \/ O変数の更新に関するデバイスオブジェクトの定義 デフォルト値は、デバイスの説明で定義されています。 親デバイス設定を使用する ：上位機器の設定に応じて更新します。 有効1（どのタスクでも使用されていない場合はバスサイクルタスクを使用） ： CODESYS バスサイクルタスクでI \/ O変数が他のタスクで使用されていない場合、それらを更新します。 有効2（常にバスサイクルタスクで） ： CODESYS バスサイクルタスクの各サイクルで、変数が使用されているかどうか、および入力チャネルと出力チャネルのどちらにマップされているかに関係なく、すべての変数を更新します。 UNIONがマッピングダイアログでI \/ Oチャネルによって表される場合、ルート要素へのマッピングも可能かどうかはデバイスによって異なります。 詳細については、次を参照してください。 フィールドバスデバイスとI \/ Oドライバー" }, 
{ "title" : "I \/ Oドライバーを備えたデバイス ", 
"url" : "_cds_edt_device_io_mapping.html#UUID-fbea3edd-739b-f693-2a4d-f97a628b9269_id_ebd811526ea50336c0a8640e0138a0ff_id_d5bd0998ff830339c0a8640e014aab3c", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：<デバイス名> I \/ Oマッピング \/ I \/ Oドライバーを備えたデバイス ", 
"snippet" : "I \/ Oドライバーを備えたデバイスの場合、ここでバスサイクルタスクを設定できます。 I \/ Oマッピング 一般設定を使用しない場合はタブ（ PLC設定 タブ）。 バスサイクルオプション バスサイクルタスク リストボックスには、アクティブなアプリケーションのタスク構成で定義されているすべてのタスクが表示されます（例： 主な任務 。の場合には 親バスサイクル設定を使用する 、親ノードの設定が使用されます。...", 
"body" : "I \/ Oドライバーを備えたデバイスの場合、ここでバスサイクルタスクを設定できます。 I \/ Oマッピング 一般設定を使用しない場合はタブ（ PLC設定 タブ）。 バスサイクルオプション バスサイクルタスク リストボックスには、アクティブなアプリケーションのタスク構成で定義されているすべてのタスクが表示されます（例： 主な任務 。の場合には 親バスサイクル設定を使用する 、親ノードの設定が使用されます。 " }, 
{ "title" : "バスサイクルタスクに関する一般情報 ", 
"url" : "_cds_edt_device_io_mapping.html#UUID-fbea3edd-739b-f693-2a4d-f97a628b9269_id_ebd811526ea50336c0a8640e0138a0ff_id_3c6e4af3bb96eb7ec0a864634fef4137", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：<デバイス名> I \/ Oマッピング \/ バスサイクルタスクに関する一般情報 ", 
"snippet" : "一般に、各IECタスクについて、使用された入力データは各タスクの開始時に読み取られ（1）、書き込まれた出力データはタスクの終了時にI \/ Oドライバーに転送されます（3）。 I \/ Oドライバでの実装は、I \/ Oデータの追加転送にとって決定的です。対応するバスシステムへの実際の転送が発生する時間枠と時点を担当します。 PLCのバスサイクルタスクは、PLC設定のすべてのフィールドバスに対してグローバルに定義できます。ただし、一部のフィールドバスでは、グローバル設定とは関係なくこれを変更できます。サイクルタイムが最も短いタスクがバスサイクルタスクとして使用されます（設定： 不特定 PLC設定で）...", 
"body" : "一般に、各IECタスクについて、使用された入力データは各タスクの開始時に読み取られ（1）、書き込まれた出力データはタスクの終了時にI \/ Oドライバーに転送されます（3）。 I \/ Oドライバでの実装は、I \/ Oデータの追加転送にとって決定的です。対応するバスシステムへの実際の転送が発生する時間枠と時点を担当します。 PLCのバスサイクルタスクは、PLC設定のすべてのフィールドバスに対してグローバルに定義できます。ただし、一部のフィールドバスでは、グローバル設定とは関係なくこれを変更できます。サイクルタイムが最も短いタスクがバスサイクルタスクとして使用されます（設定： 不特定 PLC設定で）。メッセージは通常、このタスクではバス上で送信されます。 他のタスクは、バスサイクルタスクで物理ハードウェアとのみ交換される内部バッファからI \/ Oデータのみをコピーします。 (1) 入力バッファからの入力の読み取り (2) IEC タスク \n(3) 出力バッファへの出力の書き込み (4) バス サイクル \n(5) 入力バッファ (6) 出力バッファ \n(7) バスとの間でのデータのコピー \n(9) バス サイクルタスク、優先度 1、1 ms \n(10) バス サイクル タスク、優先度 5 \n(11) バス サイクル タスク、優先度 10、タスク 5 によって割り込み タスクの使用法 The タスクの展開 タブには、使用されているI \/ Oチャネル、バスサイクルの設定タスク、およびチャネルの使用法の概要が表示されます。 出力がさまざまなタスクで書き込まれる場合、ステータスは未定義です。これは、いずれの場合も上書きされる可能性があるためです。 同じ入力がさまざまなタスクで使用されている場合、タスクの処理中に入力が変更される可能性があります。これは、タスクが優先度の高いタスクによって中断され、プロセスイメージが再度読み取られる場合に発生します。解決策：IECタスクの開始時に、入力変数を変数にコピーしてから、コードの残りの部分でローカル変数のみを操作します。 結論：いくつかのタスクで同じ入力と出力を使用しても意味がなく、場合によっては予期しない反応が発生する可能性があります。 " }, 
{ "title" : "タブ： '<デバイス名> IECオブジェクト ", 
"url" : "_cds_edt_device_iec_objects.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ： '<デバイス名> IECオブジェクト ", 
"snippet" : "デバイスオブジェクトの別のインスタンスを手動で作成すると、誤動作が発生する可能性があることに注意してください。 汎用デバイスエディタのこのタブには、IECアプリケーションからデバイスへのアクセスを可能にする「オブジェクト」が一覧表示されます。オンラインモードでは、これは監視ビューとして使用されます。 機能ブロックインスタンスが暗黙的に作成されるデバイスの場合、少なくともこのインスタンスは、ここの表にオブジェクトとしてリストされています。このインスタンスは、たとえば、バスを再起動したり、アプリケーションから情報を照会したりするために使用できます。デバイスタイプによって、この種類のデバイスインスタ...", 
"body" : "デバイスオブジェクトの別のインスタンスを手動で作成すると、誤動作が発生する可能性があることに注意してください。 汎用デバイスエディタのこのタブには、IECアプリケーションからデバイスへのアクセスを可能にする「オブジェクト」が一覧表示されます。オンラインモードでは、これは監視ビューとして使用されます。 機能ブロックインスタンスが暗黙的に作成されるデバイスの場合、少なくともこのインスタンスは、ここの表にオブジェクトとしてリストされています。このインスタンスは、たとえば、バスを再起動したり、アプリケーションから情報を照会したりするために使用できます。デバイスタイプによって、この種類のデバイスインスタンスが使用可能かどうか、およびどのアクセスオプションが使用可能かが決まります。特別なデバイス構成のヘルプを参照してください。 デバイスの入力または出力にリンクされているファンクションブロックのインスタンスもここに表示されます。チャネルへの機能ブロックのマッピングは、 <デバイス名> I \/ Oマッピング タブ。 The インスタンスに移動 コマンドを実行すると、そこから影響を受けるオブジェクトに直接移動します。 さらに、デバイスチャネルにまだリンクされていないオブジェクトをここのテーブルにさらに作成できます。 オンラインモードでは、IECオブジェクトのテーブルを監視ビューとして使用できます。また、チャネルの機能ブロック変数の現在の値、アドレス、およびコメントも表示されます。最後に、値を書き込んで強制する機能を提供します。 追加 変更 を開きます 機能ブロックを選択 新しいインスタンスを作成するため、またはテーブルで選択されたインスタンスを編集するためのダイアログ。 ： 消去 選択したエントリを削除します 変数に移動 選択したエントリから、上の対応するマッピングに直接ジャンプします <デバイス名> I \/ Oマッピング タブ。 変数 オブジェクト名は、デバイス名と機能ブロック名で構成されます。例： EL2004_Relay 。デバイス名を変更すると、すぐに効果があります。デバイス名の後の名前の部分はここで編集できます。 マッピング マッピングタイプ、 <デバイス名> I \/ Oマッピング タブ タイプ データ型：ここでは、機能ブロックの名前です。 価値 準備された価値 住所 コメント オンラインモードのみ： チャネルでの変数の現在の値、アドレス、およびコメントの表示 さらに、変数を書き込むまたは強制するための値を指定するオプション。 " }, 
{ "title" : "タブ：アクセス権 ", 
"url" : "_cds_edt_device_access_rights.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：アクセス権 ", 
"snippet" : "データ保護に関する推奨事項 データセキュリティ違反のリスクを最小限に抑えるために、アプリケーションが実行されているシステムに対して、次の組織的および技術的なアクションを実行することをお勧めします。可能な限り、PLCと制御ネットワークをオープンネットワークとインターネットにさらすことは避けてください。リモートアクセス用のVPNなど、保護のために追加のデータリンク層を使用し、ファイアウォールメカニズムをインストールします。許可された人だけにアクセスを制限し、最初の試運転中に既存のデフォルトのパスワードを変更し、定期的に変更します。 デバイスユーザー管理の概念と使用法に関する詳細な情報は、 デバイス...", 
"body" : "データ保護に関する推奨事項 データセキュリティ違反のリスクを最小限に抑えるために、アプリケーションが実行されているシステムに対して、次の組織的および技術的なアクションを実行することをお勧めします。可能な限り、PLCと制御ネットワークをオープンネットワークとインターネットにさらすことは避けてください。リモートアクセス用のVPNなど、保護のために追加のデータリンク層を使用し、ファイアウォールメカニズムをインストールします。許可された人だけにアクセスを制限し、最初の試運転中に既存のデフォルトのパスワードを変更し、定期的に変更します。 デバイスユーザー管理の概念と使用法に関する詳細な情報は、 デバイスユーザー管理の処理 章。 そこには、エディタの使用方法に関する次の手順もあります。 ユーザー管理を編集および表示するためのコントローラーへの初回ログイン コントローラのユーザー管理で新しいユーザーを設定する コントローラのユーザ管理におけるコントローラオブジェクトへのアクセス権の変更 * .dumファイルからのユーザー管理のロード、変更、およびオフラインモードでのコントローラーへのダウンロード このタブでは、コントローラ上のオブジェクトに対するデバイス ユーザーのデバイス アクセス権を定義します。プロジェクト ユーザー管理と同様に、ユーザーは少なくとも 1 つのユーザー グループのメンバーである必要があり、特定のアクセス権を付与できるのはユーザー グループのみです。 の要件 アクセス権 表示されるタブ: の 「アクセス権の表示」タブ オプションはで選択する必要があります CODESYS のオプション デバイスエディタ カテゴリー。 これに注意してください CODESYS オプションは、デバイスの説明で上書きできます。 ユーザーグループに付与されるアクセス権の要件 ユーザー管理用のコンポーネントは、コントローラーで使用可能である必要があります。それが主要な要件です。 ユーザーとユーザー グループは、 ユーザーとグループ タブ。 オブジェクト ツリー構造では、実行時にアクションを実行できるオブジェクトが一覧表示されます。オブジェクトはそれぞれオブジェクトソースによって割り当てられ、オブジェクトグループに部分的に並べ替えられます。の中に 権利 ビューでは、選択したオブジェクトへのユーザーグループのアクセスオプションを構成できます。 オブジェクトソース（ルートノード） ファイルシステムオブジェクト→デバイス ：これらのオブジェクトでは、コントローラーの現在の実行ディレクトリのフォルダーにアクセス許可を付与できます。 ランタイムオブジェクト→\/ ：これらのオブジェクトでは、コントローラーでオンラインアクセスできるすべてのオブジェクトが管理されているため、アクセス許可を制御する必要があります。 オブジェクトの説明はにあります オブジェクトの概要 テーブル。 オブジェクトグループとオブジェクト（インデント） 例： デバイス 子ノードを使用 ロガー 、 PlcLogic 、 設定 、 UserManagement 。 権限 一般に、サブオブジェクトはルート オブジェクト ( デバイス または \/ ）。つまり、ユーザー グループの権限が拒否されるか、親オブジェクトに明示的に付与されると、まずすべての子オブジェクトに影響します。 この表は、ツリーで現在選択されているオブジェクトに適用されます。すべてのユーザーグループについて、このオブジェクトで可能なアクションに対して現在構成されている権限が表示されます。 オブジェクトに対して可能なアクション： 削除を追加 変更 意見 実行する オブジェクトをクリックすると、右側の表に、選択したオブジェクトで使用可能なユーザーグループのアクセス権が表示されます。 これにより、次のことをすばやく確認できます。 オブジェクトによって評価されるアクセス権 どのユーザーグループがどのオブジェクトに対してどの有効な権限を持っているか 記号の意味 ：明示的に付与されたアクセス権 ：アクセス権が明示的に拒否されました ：継承により付与されたアクセス権 ：継承によりアクセス権が拒否されました ：アクセス権が明示的に付与または拒否されておらず、親オブジェクトにも継承されていません。アクセスできません。 記号なし：アクセス権が異なる複数のオブジェクトが選択されています。 記号をクリックして権限を変更してください。 例 The ロガー 上のオブジェクト アクセス権 タブは「ロガー」コンポーネントによって作成され、そのアクセス権を制御します。真下にあります デバイス ランタイムオブジェクト。 このオブジェクトの可能なアクセス権は、 意見 アクション。 最初に、各オブジェクトには読み取りアクセス権があります。これは、すべてのユーザーがコントローラーの「ロガー」を読み取ることができることを意味します。このアクセス権を単一のユーザーグループに対して拒否する必要がある場合（ サービス 例では）、ロガーオブジェクトへの読み取りアクセスを明示的に拒否する必要があります。 " }, 
{ "title" : "タブのツールバー ", 
"url" : "_cds_edt_device_access_rights.html#UUID-cd3e7f33-8afc-1a1a-14eb-8436f7d0b1e8_UUID-bf0ecbfd-1dbd-5ac2-0f81-c00318625768", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：アクセス権 \/ タブのツールバー ", 
"snippet" : "同期 エディターとデバイスのユーザー管理の間の同期のオンとオフを切り替えます。 ボタンが「押されていない」場合は、エディタが空白であるか、ハードディスクからロードした構成が含まれています。 エディターにまだデバイスと同期されていないユーザー構成が含まれているときに同期を有効にすると、エディターの内容がどうなるかを確認するメッセージが表示されます。オプション： デバイスからアップロードし、エディターのコンテンツを上書きします ：デバイスの構成がエディターにロードされ、現在の内容が上書きされます。 エディターのコンテンツをデバイスにダウンロードし、そこでユーザー管理を上書きします ：エディターの構...", 
"body" : " 同期 エディターとデバイスのユーザー管理の間の同期のオンとオフを切り替えます。 ボタンが「押されていない」場合は、エディタが空白であるか、ハードディスクからロードした構成が含まれています。 エディターにまだデバイスと同期されていないユーザー構成が含まれているときに同期を有効にすると、エディターの内容がどうなるかを確認するメッセージが表示されます。オプション： デバイスからアップロードし、エディターのコンテンツを上書きします ：デバイスの構成がエディターにロードされ、現在の内容が上書きされます。 エディターのコンテンツをデバイスにダウンロードし、そこでユーザー管理を上書きします ：エディターの構成がデバイスに転送され、そこで適用されます。 ディスクからインポート 上のボタンをクリックすると ユーザーとグループ インポートするタブ デバイスユーザー管理ファイル* .dum2 、ファイルを選択するためのデフォルトのダイアログが開き、ハードドライブからデバイスユーザー管理ファイルを選択します。ファイルを選択した後、 パスワードを入力する ダイアログが開きます。ファイルのエクスポート時に割り当てられたパスワードを指定する必要があります。次に、ユーザー管理が有効になります。 注：V3.5 SP16より前では、 デバイスユーザー管理ファイル（* .dum） 暗号化を必要としないファイルタイプが使用されました。 上のボタンをクリックすると アクセス権 インポートするタブ デバイスの権利管理ファイル* .drm 、ファイルを選択するためのデフォルトのダイアログが開き、ハードドライブから対応するファイルを選択します。ダイアログの既存の構成は、インポートされたファイルによって上書きされます。 ディスクにエクスポート 上のボタンをクリックすると ユーザーとグループ タブ、最初に パスワードを入力する デバイスのユーザー管理ファイルにパスワードを割り当てるためのダイアログが開きます。注：コントローラーでこのユーザー管理を有効にするには、後でこのファイルをインポートするときにこのパスワードを繰り返す必要があります。 パスワード割り当てダイアログを閉じると、ハードディスクからユーザー管理構成を選択してインポートするためのデフォルトのダイアログが開きます。この場合、ファイルタイプは次のとおりです。 デバイスユーザー管理ファイル（* .dum2） 。 注：V3.5 SP16より前では、 デバイスユーザー管理ファイル（* .dum） 暗号化を必要としないファイルタイプが使用されました。 上のボタンをクリックすると アクセス権 タブ、ファイルタイプは デバイスの権利管理ファイル（* .drm） 。この場合、保存する前にファイルにパスワードを割り当てる必要はありません。 デバイスユーザー デバイスに現在ログインしているユーザーのユーザー名 " }, 
{ "title" : "オブジェクトの概要 ", 
"url" : "_cds_edt_device_access_rights.html#UUID-cd3e7f33-8afc-1a1a-14eb-8436f7d0b1e8_id_ef1aea5deb3245c0a8640e00986ced_id_963abee2e14f82aec0a86312370c73c1", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：アクセス権 \/ オブジェクトの概要 ", 
"snippet" : "ランタイムオブジェクト→デバイス Logger ロガーへのオンラインアクセスは読み取り専用です。したがって、 意見 ここでアクセス権を付与または拒否できます。 PlcLogic すべての IEC アプリケーションは、ダウンロード中に子オブジェクトとして自動的にここに挿入されます。アプリケーションが削除されると、自動的に削除されます。 これにより、アプリケーションへのオンラインアクセスを個別に制御できます。アクセス権は、システム内のすべてのアプリケーションに対して一元的に割り当てることができます。 Plcロジック The 管理者 と デベロッパー ユーザーグループは、IECアプリケーションに完全...", 
"body" : "ランタイムオブジェクト→デバイス Logger ロガーへのオンラインアクセスは読み取り専用です。したがって、 意見 ここでアクセス権を付与または拒否できます。 PlcLogic すべての IEC アプリケーションは、ダウンロード中に子オブジェクトとして自動的にここに挿入されます。アプリケーションが削除されると、自動的に削除されます。 これにより、アプリケーションへのオンラインアクセスを個別に制御できます。アクセス権は、システム内のすべてのアプリケーションに対して一元的に割り当てることができます。 Plcロジック The 管理者 と デベロッパー ユーザーグループは、IECアプリケーションに完全にアクセスできます。 The サービス と 時計 ユーザーグループには読み取りアクセスのみがあります（たとえば、値の読み取り専用監視の場合）。 次の表は、IECアプリケーションに特定のアクセス権が付与されている場合に特に影響を受けるアクションを示しています。 x ：権限は明示的に設定する必要があります。 - : 権限は関係ありません。 Application 手術 アクセス権 削除を追加 実行する 変更 意見 ログイン - - - x 作成 x - - - 子オブジェクトを作成する x - - - 消去 x - - - ダウンロード\/オンライン変更 x - - - ブートアプリケーションの作成 x - - - 変数の読み取り - - - x 変数の書き込み - - x x 力変数 - - x x ブレークポイントの設定と削除 - x x - 次のステートメントを設定 - x x - コールスタックの読み取り - - - x シングルサイクル - x - - フロー制御をオンにします - x x - 起動停止 - x - - リセット - x - - 保持変数を復元する - x - - 保持変数を保存する - - - x PLCShell だけ 変更 この時点で許可が評価されます。これは、 変更 ユーザーグループに権限が付与されており、PLCシェルコマンドも評価できます。 RemoteConnections コントローラへの追加の外部接続は、このノードの下に設定できます。現在、OPCUAサーバーへのアクセスはここで構成できます。 Settings これは、コントローラーの構成設定へのオンライン アクセスです。 Security Settings : デフォルトでは、 修正する セキュリティ設定の権限は管理者にのみ付与されます。 UserManagement これは、コントローラのユーザー管理へのオンライン アクセスです。デフォルトでは、読み取り\/書き込みアクセスは管理者にのみ許可されています。 Access Rights : このオブジェクトを選択すると、 権利 見る。つまり、権限管理の読み取りのみを許可するユーザー グループと、権限管理の変更を許可するユーザー グループを構成できます。 Groups : デバイス ユーザー管理のユーザー グループごとに個別のオブジェクトが自動的に作成され、下に表示されます。 グループ .ユーザー グループ オブジェクトを選択すると、ユーザー グループに対する権限を設定できます。つまり、ユーザー グループの読み取りまたは変更を許可するユーザー グループを構成できます (たとえば、ユーザー グループに新しいユーザーを追加するなど)。 デフォルトでは、次のユーザー グループがオブジェクトを使用できます。 Administrator Developer Service Watch これにより、段階的または制限付きの管理者グループを設定できます。たとえば、ビジュアライゼーション ユーザー グループに既存のユーザーを追加できるだけで、新しいユーザーを作成したり、既存のユーザーのパスワードを変更したりできないビジュアライゼーション管理者グループを設定できます。 Users : このオブジェクトを選択すると、ユーザーに対するユーザー グループの権限を構成できます。つまり、ユーザーの読み取り、変更、または追加 (たとえば、新しいユーザーの追加) を許可するユーザー グループを構成できます。 詳細については、次を参照してください。 デバイスユーザー管理の処理X509 これにより、X.509証明書へのオンラインアクセスが制御されます。ここでは、2つのタイプのアクセスが区別されます。 読んだ （ 意見 ）。 書く （ 変更 ）。 すべての操作は、これら 2 つのアクセス権のいずれかに割り当てられます。各操作は、X509 の下に子オブジェクトとして挿入されます。そのため、操作ごとのアクセスをさらに細かく調整できるようになりました。 ファイルシステムオブジェクト→\/ コントローラの実行パスからのすべてのフォルダは、「 \/ \"ファイルシステムオブジェクト。これにより、ファイルシステムの各フォルダに特定の権限を付与できます。 " }, 
{ "title" : "タブ：ユーザーとグループ ", 
"url" : "_cds_edt_device_users_and_groups.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：ユーザーとグループ ", 
"snippet" : "データ保護に関する推奨事項 データセキュリティ違反のリスクを最小限に抑えるために、アプリケーションが実行されているシステムに対して、次の組織的および技術的なアクションを実行することをお勧めします。可能な限り、PLCと制御ネットワークをオープンネットワークとインターネットにさらすことは避けてください。リモートアクセス用のVPNなど、保護のために追加のデータリンク層を使用し、ファイアウォールメカニズムをインストールします。許可された人だけにアクセスを制限し、最初の試運転中に既存のデフォルトのパスワードを変更し、定期的に変更します。 のこのタブで 汎用デバイスエディタ 、PLCのデバイスユーザー管理...", 
"body" : "データ保護に関する推奨事項 データセキュリティ違反のリスクを最小限に抑えるために、アプリケーションが実行されているシステムに対して、次の組織的および技術的なアクションを実行することをお勧めします。可能な限り、PLCと制御ネットワークをオープンネットワークとインターネットにさらすことは避けてください。リモートアクセス用のVPNなど、保護のために追加のデータリンク層を使用し、ファイアウォールメカニズムをインストールします。許可された人だけにアクセスを制限し、最初の試運転中に既存のデフォルトのパスワードを変更し、定期的に変更します。 のこのタブで 汎用デバイスエディタ 、PLCのデバイスユーザー管理を編集します。 デバイスでのサポート方法に応じて、ユーザーアカウントとユーザーグループを定義できます。の構成と組み合わせて アクセス権 したがって、タブを使用すると、実行時にコントロールオブジェクトとファイルへのアクセスを制御できます。 要件：コントローラーには ユーザー管理 編集できるようにします。コントローラにログインできるようにするためのログインデータがあります。 プロジェクトユーザー管理からデバイスユーザー管理にユーザーアカウント定義を適用することができます（以下を参照）。 輸入 ボタン）。 ユーザー 現在定義されているすべてのユーザーと、その下のユーザーグループのメンバーシップは、ツリー構造で一覧表示されます。 追加 を開きます ユーザーを追加する 新しいユーザー アカウントを作成するためのダイアログ。ダイアログの説明については、このページの下を参照してください。 輸入 を開きます ユーザーのインポート ダイアログ。 ダイアログには、プロジェクトのユーザー管理で定義されているすべてのユーザーアカウントが表示されます。 目的のエントリを選択して、をクリックします わかった それらをデバイスのユーザー管理にインポートするため。注意：パスワードは適用されません。 変更 を開きます ユーザーの編集<ユーザー名> ダイアログ ダイアログはに対応します ユーザーを追加する ダイアログが表示され、ユーザーアカウントの設定を変更できます。 ： 消去 現在選択されているユーザーのアカウントを削除します グループ 現在定義されているすべてのグループと、その下に割り当てられているユーザーがツリー構造で一覧表示されます。 追加 を開きます グループを追加 ダイアログ 新しいグループ名を定義します。定義されたユーザーのリストから、グループに属するユーザーを選択します。クリック わかった 選択を確認します。グループがツリーに表示されます。 輸入 を開きます ユーザーのインポート ダイアログ。 ダイアログには、プロジェクトユーザー管理で定義されたすべてのユーザーグループが表示されます。 目的のエントリを選択して、をクリックします わかった それらをデバイスのユーザー管理にインポートするため。 変更 を開きます グループの編集<グループ名> ダイアログ ダイアログはに対応します グループを追加 グループ定義を変更できるダイアログ。 ： 消去 現在選択されているグループを削除します ダイアログ：ユーザーの追加 名前 新しいユーザーの名前 デフォルトグループ 構成されたすべてのユーザーグループを含むリストボックス すべてのユーザーは、少なくとも1つのグループに属している必要があります。ここでは、これを「デフォルトグループ」として定義します。 パスワード パスワードを認証する パスワードの強度 からの範囲のパスワードセキュリティ 非常に弱い に とても良い パスワードを隠す ：パスワードは、入力時にアスタリスク「*」でのみ表示されます。 パスワードはユーザーが変更できます 最初のログイン時にパスワードを変更する必要があります パスワード ポリシー 新しいパスワードを入力すると、有効であるがまだ適用されていないルールが赤色で表示されます。パスワード ポリシーのすべてのルールが満たされている場合にのみ、[OK] ボタンをクリックしてダイアログを確認できます。ランタイム システム パスワード ポリシーの詳細については、次を参照してください。 表34「" }, 
{ "title" : "タブのツールバー ", 
"url" : "_cds_edt_device_users_and_groups.html#UUID-3317c99f-0df2-8051-6bf2-9a5235658be0_UUID-bf0ecbfd-1dbd-5ac2-0f81-c00318625768", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：ユーザーとグループ \/ タブのツールバー ", 
"snippet" : "同期 エディターとデバイスのユーザー管理の間の同期のオンとオフを切り替えます。 ボタンが「押されていない」場合は、エディタが空白であるか、ハードディスクからロードした構成が含まれています。 エディターにまだデバイスと同期されていないユーザー構成が含まれているときに同期を有効にすると、エディターの内容がどうなるかを確認するメッセージが表示されます。オプション： デバイスからアップロードし、エディターのコンテンツを上書きします ：デバイスの構成がエディターにロードされ、現在の内容が上書きされます。 エディターのコンテンツをデバイスにダウンロードし、そこでユーザー管理を上書きします ：エディターの構...", 
"body" : " 同期 エディターとデバイスのユーザー管理の間の同期のオンとオフを切り替えます。 ボタンが「押されていない」場合は、エディタが空白であるか、ハードディスクからロードした構成が含まれています。 エディターにまだデバイスと同期されていないユーザー構成が含まれているときに同期を有効にすると、エディターの内容がどうなるかを確認するメッセージが表示されます。オプション： デバイスからアップロードし、エディターのコンテンツを上書きします ：デバイスの構成がエディターにロードされ、現在の内容が上書きされます。 エディターのコンテンツをデバイスにダウンロードし、そこでユーザー管理を上書きします ：エディターの構成がデバイスに転送され、そこで適用されます。 ディスクからインポート 上のボタンをクリックすると ユーザーとグループ インポートするタブ デバイスユーザー管理ファイル* .dum2 、ファイルを選択するためのデフォルトのダイアログが開き、ハードドライブからデバイスユーザー管理ファイルを選択します。ファイルを選択した後、 パスワードを入力する ダイアログが開きます。ファイルのエクスポート時に割り当てられたパスワードを指定する必要があります。次に、ユーザー管理が有効になります。 注：V3.5 SP16より前では、 デバイスユーザー管理ファイル（* .dum） 暗号化を必要としないファイルタイプが使用されました。 上のボタンをクリックすると アクセス権 インポートするタブ デバイスの権利管理ファイル* .drm 、ファイルを選択するためのデフォルトのダイアログが開き、ハードドライブから対応するファイルを選択します。ダイアログの既存の構成は、インポートされたファイルによって上書きされます。 ディスクにエクスポート 上のボタンをクリックすると ユーザーとグループ タブ、最初に パスワードを入力する デバイスのユーザー管理ファイルにパスワードを割り当てるためのダイアログが開きます。注：コントローラーでこのユーザー管理を有効にするには、後でこのファイルをインポートするときにこのパスワードを繰り返す必要があります。 パスワード割り当てダイアログを閉じると、ハードディスクからユーザー管理構成を選択してインポートするためのデフォルトのダイアログが開きます。この場合、ファイルタイプは次のとおりです。 デバイスユーザー管理ファイル（* .dum2） 。 注：V3.5 SP16より前では、 デバイスユーザー管理ファイル（* .dum） 暗号化を必要としないファイルタイプが使用されました。 上のボタンをクリックすると アクセス権 タブ、ファイルタイプは デバイスの権利管理ファイル（* .drm） 。この場合、保存する前にファイルにパスワードを割り当てる必要はありません。 デバイスユーザー デバイスに現在ログインしているユーザーのユーザー名 " }, 
{ "title" : "タブ：シンボルの権利 ", 
"url" : "_cds_edt_device_symbol_rights.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：シンボルの権利 ", 
"snippet" : "汎用デバイスエディターのこのタブでは、コントローラーで使用可能な個々のシンボルセットに対するさまざまなユーザーグループ（クライアント）のアクセス権を定義します。 詳細については、以下を参照してください。 アイコン設定 要件：ユーザー管理はPLCで設定する必要があります。シンボルセットが定義されているコントローラにアプリケーションがダウンロードされました CODESYS 事業。コントローラにログインするためのアクセスデータがあります。 の中に シンボルセット ビューでは、すべてのシンボルセットが下に一覧表示されます 申し込み 定義がアプリケーションとともにコントローラーにダウンロードされたノード...", 
"body" : "汎用デバイスエディターのこのタブでは、コントローラーで使用可能な個々のシンボルセットに対するさまざまなユーザーグループ（クライアント）のアクセス権を定義します。 詳細については、以下を参照してください。 アイコン設定 要件：ユーザー管理はPLCで設定する必要があります。シンボルセットが定義されているコントローラにアプリケーションがダウンロードされました CODESYS 事業。コントローラにログインするためのアクセスデータがあります。 の中に シンボルセット ビューでは、すべてのシンボルセットが下に一覧表示されます 申し込み 定義がアプリケーションとともにコントローラーにダウンロードされたノード。 の中に 権利 ビュー、で定義されたユーザーグループ ユーザー管理 コントローラのを表に示します。シンボルセットを選択すると、このセットのシンボルに対する対応するユーザーグループのアクセス権が表示されます。 ：アクセスが許可されました。 ： アクセス拒否。記号をダブルクリックすると、アクセス権を変更できます。 クリック ボタンをクリックして、現在のアクセス構成をXMLファイルに保存します。ファイルタイプは次のとおりです。 デバイスシンボル管理ファイル（* .dsm） 。クリック このようなファイルをハードドライブから読み取るためのボタン。 " }, 
{ "title" : "タブ: ライセンス決定のためのソフトウェア メトリック ", 
"url" : "_cds_edt_device_licensed_software_metrics.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ: ライセンス決定のためのソフトウェア メトリック ", 
"snippet" : "この環境におけるメトリックは、ライセンスの計算に関連するユニットの「値」(数) です。製品によっては、これは、ユーザー コードのサイズ (バイト単位)、軸、I\/O チャネル、またはフィールドバス インスタンスの数などになります。 デバイス エディタのタブには、アプリケーションで使用できるメトリックを含むツリー構造が表示されます。このようにして、現在の測定値を表示し、ライセンスで許可されている以上のコードがコントローラにダウンロードされているかどうかを確認できます。ライセンスはコントローラごとに発行されるため、コントローラ上に配置されます。ライセンスチェックもそこで行われます。 メトリックは、ダ...", 
"body" : "この環境におけるメトリックは、ライセンスの計算に関連するユニットの「値」(数) です。製品によっては、これは、ユーザー コードのサイズ (バイト単位)、軸、I\/O チャネル、またはフィールドバス インスタンスの数などになります。 デバイス エディタのタブには、アプリケーションで使用できるメトリックを含むツリー構造が表示されます。このようにして、現在の測定値を表示し、ライセンスで許可されている以上のコードがコントローラにダウンロードされているかどうかを確認できます。ライセンスはコントローラごとに発行されるため、コントローラ上に配置されます。ライセンスチェックもそこで行われます。 メトリックは、ダウンロード中にコントローラーに転送されます。クリックすると更新されます ビルド→コードの生成 アクティブなアプリケーションの場合。 デバイスから現在のメトリックを読み取る コントローラからメトリックを取得して転送し、それらを デバイスの価値 桁。 メトリックを計算するコードを生成する メトリックを計算するにはコードを生成する必要があります。 ライセンスを表示 開く ライセンス ダイアログ ダイアログにはプロジェクトに必要なライセンスが表示されます。 ストア内のすべてを開いてダイアログを閉じる コマンドは、提案された製品を開きます CODESYS Store International 。 商品を展示したい場合 CODESYS Store North America 、次に選択する必要があります 北米 保管する CODESYS オプション。 指標 アプリケーションごとのメトリクスの種類 プロジェクトの価値 開発システムで使用されるタグの数。値はコード生成中に測定されます ( ビルド → コードの生成 指示）。 計算の詳細については、 値の計算 セクション。 注: アプリケーションのコンパイル情報を削除すると、値は 0 にリセットされます。 最大。許可された コントローラのライセンスに応じて、各アプリケーションに許可される最大値 デバイスの価値 コントローラから読み出した実測値 注: これらの値を決定するには、通信が機能している必要があります。 " }, 
{ "title" : "値の計算 ", 
"url" : "_cds_edt_device_licensed_software_metrics.html#UUID-f3be4987-31a8-2f1c-3e97-bb89ff6c8b60_section-idm4525765148713633834737187389", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ: ライセンス決定のためのソフトウェア メトリック \/ 値の計算 ", 
"snippet" : "メトリック 確定値 ユーザーコードのサイズ 値 (バイト単位) ユーザーがプログラムしたコード (実装) のみが評価されます。 IEC コンパイラでコンパイルされていないコードは評価されません。 宣言内の変数の数とサイズは関係ありません。 ユーザーが開発したIECライブラリはコードサイズを評価されます。標準ライブラリ、システム ライブラリ、および通信スタック CODESYS GmbH は評価されません。 タスクグループの割り当て タスク構成における IEC タスク グループの構成では、IEC タスクが異なる CPU コアで実行される場合、多くの場合、「タスク グループ割り当て」ライセンスが必要...", 
"body" : "メトリック 確定値 ユーザーコードのサイズ 値 (バイト単位) ユーザーがプログラムしたコード (実装) のみが評価されます。 IEC コンパイラでコンパイルされていないコードは評価されません。 宣言内の変数の数とサイズは関係ありません。 ユーザーが開発したIECライブラリはコードサイズを評価されます。標準ライブラリ、システム ライブラリ、および通信スタック CODESYS GmbH は評価されません。 タスクグループの割り当て タスク構成における IEC タスク グループの構成では、IEC タスクが異なる CPU コアで実行される場合、多くの場合、「タスク グループ割り当て」ライセンスが必要になります。 いいえ : 次の構成にはライセンスは必要ありません。 プロパティを持つ設定されたタスクグループ 固定ピン留め 固定コア 連続ピン留め (IEC タスクは 1 つのみ) 同じCPUコア上で実行される複数の構成済みタスクグループ はい : 次の構成にはライセンスが必要です。 プロパティを持つ設定されたタスクグループ フリーフローティング 連続ピン留め (複数の IEC タスク) プロパティを持つ複数の構成済みタスクグループ フリーフローティング 連続ピン留め 異なるCPUコアで実行される複数の構成済みタスクグループ フィールドバス 、 I\/Oチャンネル 基本データ型 ( BOOL 、 INT 、 REAL 、...）。複雑なデータ型をマッピングする場合 ( STRUCT 、 ARRAY )、基本データ型のサブ要素の数がカウントされます。 を選択した場合は、 常に変数を更新する オプションを選択すると、特定の IEC 変数に割り当てられているかどうかに関係なく、すべてのチャネルが計算で考慮されます。 CANopen、Modbus、PROFIBUS のインスタンス このタイプの使用済みフィールドバス スタック インスタンス Modbus の場合、RTU および TCP のモード クライアントのインスタンスがカウントされます。 マスター\/コントローラーまたはスレーブ\/デバイスは、デバイス構成の 1 つのインスタンスとしてカウントされます。デバイス ツリー内のこれらのマスター\/スレーブにリンクされているデバイスはカウントされません。これらは I\/O チャネル経由でカウントされます。フィールドバス ゲートウェイもインスタンスとしてカウントされます (例外: CANopen ゲートウェイ)。 EtherCAT、EtherNet\/IP、PROFINET、SAE J1939 のインスタンス 視覚化タグの数 見る 視覚化 – ライセンス ソフトモーション 見る SoftMotion – ライセンス コミュニケーション 見る コミュニケーション – ライセンス アプリケーションベースのライセンスのライセンスパッケージに関する情報は、 CODESYSストア 。 " }, 
{ "title" : "追加ライセンス ", 
"url" : "_cds_edt_device_licensed_software_metrics_list.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ: ライセンス決定のためのソフトウェア メトリック \/ 追加ライセンス ", 
"snippet" : "アプリケーションベースのライセンスのみが ライセンス決定のためのソフトウェアメトリクス タブ。アプリケーションには、この概要に含まれていない追加のライセンスが必要になる場合があります。 アプリケーションベースのライセンスの概要については、 CODESYSストア 。 以下のリストは、 ライセンス決定のためのソフトウェアメトリクス タブ。 ソフトモーション CODESYS SoftMotion Light CODESYS Depictor 視覚化 CODESYS HMI SL Unlimited variables for CODESYS HMI SL 図書館 Object Oriented Al...", 
"body" : "アプリケーションベースのライセンスのみが ライセンス決定のためのソフトウェアメトリクス タブ。アプリケーションには、この概要に含まれていない追加のライセンスが必要になる場合があります。 アプリケーションベースのライセンスの概要については、 CODESYSストア 。 以下のリストは、 ライセンス決定のためのソフトウェアメトリクス タブ。 ソフトモーション CODESYS SoftMotion Light CODESYS Depictor 視覚化 CODESYS HMI SL Unlimited variables for CODESYS HMI SL 図書館 Object Oriented Alarming Library (100) Object Oriented Alarming Library (200) MsSQL Library SL MySQL Library SL BE KOLLMORGEN s300s700 CAN Dweet Pro Library SL STweep Formatter for CODESYS Janz Tec MQTT library for CODESYS SL JSON HTTP Client Library CODESYS IIoT Libraries SL Python Editor フィールドバス HVAC KNX SL CODESYS BACnet SL CODESYS DNP3 SL CODESYS KNX SL Universal Modbus Client Master SL プロトコル IEC 60870-5-104 Server CODESYS OPC DA Server SL CODESYS IO-Link SL エンジニアリング CODESYS Professional Developer Edition ( CODESYS Static Analysis , CODESYS Test Manager , CODESYS Profiler , CODESYS UML , CODESYS Git , CODESYS SVN ) CODESYS Redundancy SL 安全性 CODESYS Safety for EtherCAT Safety Module SL " }, 
{ "title" : "タブ: タスクの展開 ", 
"url" : "_cds_edt_device_task_deployment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ: タスクの展開 ", 
"snippet" : "のこのサブダイアログ デバイスエディタ 入力と出力のテーブル、および定義されたタスクへの割り当てを表示します。 情報は、アプリケーションのコードが生成された後にのみ表示されます。優先度の異なるいくつかのタスクで入力または出力が使用される場所を示すため、トラブルシューティングに使用されます。複数回使用すると、上書きによって未定義の値が発生する可能性があります。 タスクのI \/ Oリスト（1） I \/ Oチャネル （2） リンクされたデバイスのすべての入力と出力。表示は、 I \/ Oマッピング デバイスエディタのダイアログ。 入力または出力をダブルクリックすると、関連するI \/ Oマッピングエディ...", 
"body" : "のこのサブダイアログ デバイスエディタ 入力と出力のテーブル、および定義されたタスクへの割り当てを表示します。 情報は、アプリケーションのコードが生成された後にのみ表示されます。優先度の異なるいくつかのタスクで入力または出力が使用される場所を示すため、トラブルシューティングに使用されます。複数回使用すると、上書きによって未定義の値が発生する可能性があります。 タスクのI \/ Oリスト（1） I \/ Oチャネル （2） リンクされたデバイスのすべての入力と出力。表示は、 I \/ Oマッピング デバイスエディタのダイアログ。 入力または出力をダブルクリックすると、関連するI \/ Oマッピングエディタを開くことができます。 <タスク名> （3） で定義されたすべてのタスクの列が表示されます タスク構成 。タイトルには、タスク名と優先度が含まれています。 タスクの優先度は、最初の列から最後の列に向かって減少します。赤十字 タスクによって書き込まれるか読み取られる入力と出力のボックスにが表示されます。さらに、タスクは バスサイクルタスク の中に PLC設定 デバイスエディタのは、これらのポイントで青い二重矢印でマークされています シンボル。 タイトルセルをマウスでクリックすると、このタスクに割り当てられたI \/ Oのみが表示されます。 マウスをクリックした後、 I \/ Oチャネル セル、すべてのチャネルが再び表示されます。 " }, 
{ "title" : "タブ：ステータス ", 
"url" : "_cds_edt_device_status.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：ステータス ", 
"snippet" : "のこのタブ 汎用デバイスエディタ 「実行中」や「停止中」などのステータス情報、それぞれのデバイスからの特定の診断メッセージ、使用されているカードと内部バスシステムに関する情報を表示します。...", 
"body" : "のこのタブ 汎用デバイスエディタ 「実行中」や「停止中」などのステータス情報、それぞれのデバイスからの特定の診断メッセージ、使用されているカードと内部バスシステムに関する情報を表示します。 " }, 
{ "title" : "タブ：情報 ", 
"url" : "_cds_edt_device_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：デバイス、および汎用デバイスエディタ \/ タブ：情報 ", 
"snippet" : "のこのタブ 汎用デバイスエディタ デバイス記述ファイルからの一般的な情報が表示されます：名前、ベンダー、カテゴリ、バージョン、注文番号、説明、必要に応じてイラスト。...", 
"body" : "のこのタブ 汎用デバイスエディタ デバイス記述ファイルからの一般的な情報が表示されます：名前、ベンダー、カテゴリ、バージョン、注文番号、説明、必要に応じてイラスト。 " }, 
{ "title" : "オブジェクト：GVL –グローバル変数リスト ", 
"url" : "_cds_obj_gvl.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：GVL –グローバル変数リスト ", 
"snippet" : "GVL シンボル： グローバル変数リストは、の宣言、編集、および表示に使用されます。 グローバル変数 。 クリックします プロジェクト→オブジェクトの追加→グローバル変数リスト GVLをアプリケーションまたはプロジェクトに追加します。 デバイスツリーのアプリケーションの下にGVLを挿入すると、変数がこのアプリケーション内に適用されます。にGVLを追加すると POUs ビューでは、変数はプロジェクト全体に適用されます。 オブジェクトのエディタの設定は、 ツール→オプション ダイアログ、 宣言エディター と テキストエディタ カテゴリ。 ターゲットシステムがネットワーク機能をサポートしている場合は...", 
"body" : "GVL シンボル： グローバル変数リストは、の宣言、編集、および表示に使用されます。 グローバル変数 。 クリックします プロジェクト→オブジェクトの追加→グローバル変数リスト GVLをアプリケーションまたはプロジェクトに追加します。 デバイスツリーのアプリケーションの下にGVLを挿入すると、変数がこのアプリケーション内に適用されます。にGVLを追加すると POUs ビューでは、変数はプロジェクト全体に適用されます。 オブジェクトのエディタの設定は、 ツール→オプション ダイアログ、 宣言エディター と テキストエディタ カテゴリ。 ターゲットシステムがネットワーク機能をサポートしている場合は、GVLの変数をネットワーク変数に変換し、それらをネットワーク内の他のデバイスとのデータ交換に使用できます。これを行うには、GVLに対応するプロパティをで定義する必要があります。 ネットワーク変数 のタブ プロパティ ダイアログ。 " }, 
{ "title" : "オブジェクト：GVL –グローバル変数リスト（tasklocal） ", 
"url" : "_cds_obj_gvl_tasklocal.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：GVL –グローバル変数リスト（tasklocal） ", 
"snippet" : "GVL –グローバル変数リスト（tasklocal） シンボル： グローバル変数リスト（tasklocal）は、グローバル変数の宣言、編集、および表示に使用されます。この特別なグローバル変数リストの場合、リスト内で宣言された変数は1つのタスクでのみ書き込むことができます。他のすべてのタスクには、読み取り専用アクセスのみがあります。これにより、マルチコアプロジェクトの場合でも、これらの変数の値が常に一貫していることが保証されます。 詳細については、以下を参照してください。 タスクローカル変数を使用するこのオブジェクトは、コンパイラバージョン3.5.13.0で、対応するデバイスの説明とともに使用で...", 
"body" : "GVL –グローバル変数リスト（tasklocal） シンボル： グローバル変数リスト（tasklocal）は、グローバル変数の宣言、編集、および表示に使用されます。この特別なグローバル変数リストの場合、リスト内で宣言された変数は1つのタスクでのみ書き込むことができます。他のすべてのタスクには、読み取り専用アクセスのみがあります。これにより、マルチコアプロジェクトの場合でも、これらの変数の値が常に一貫していることが保証されます。 詳細については、以下を参照してください。 タスクローカル変数を使用するこのオブジェクトは、コンパイラバージョン3.5.13.0で、対応するデバイスの説明とともに使用できます。 書き込みアクセス権のあるタスク 変数への排他的な書き込みアクセス権を持つタスク " }, 
{ "title" : "オブジェクト：ネットワーク変数リスト（送信者） ", 
"url" : "_cds_obj_nvl_send.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：ネットワーク変数リスト（送信者） ", 
"snippet" : "ネットワーク変数リスト（送信者） シンボル： ネットワーク変数リスト（送信者）は、に送信する必要のあるグローバル変数を宣言および一覧表示するために使用されます。 ネットワーク変数リスト（受信者） 別のデバイスまたはネットワークプロジェクトの。 クリックしてデバイスツリーにオブジェクトを追加します オブジェクトの追加→ネットワーク変数リスト（送信者） アプリケーションの。 プロトコルと転送パラメータは、 ネットワーク変数リストの追加（送信者） ダイアログまたは プロパティ 上のオブジェクトのダイアログ ネットワーク変数 タブ。 詳細については、以下を参照してください。 ネットワーク変数交換の構成...", 
"body" : "ネットワーク変数リスト（送信者） シンボル： ネットワーク変数リスト（送信者）は、に送信する必要のあるグローバル変数を宣言および一覧表示するために使用されます。 ネットワーク変数リスト（受信者） 別のデバイスまたはネットワークプロジェクトの。 クリックしてデバイスツリーにオブジェクトを追加します オブジェクトの追加→ネットワーク変数リスト（送信者） アプリケーションの。 プロトコルと転送パラメータは、 ネットワーク変数リストの追加（送信者） ダイアログまたは プロパティ 上のオブジェクトのダイアログ ネットワーク変数 タブ。 詳細については、以下を参照してください。 ネットワーク変数交換の構成ダイアログ：ネットワーク変数リストの追加（送信者） 関数 ：このダイアログは、送信側NVLのネットワークプロパティを定義します。ダイアログを閉じると、 CODESYS アプリケーションの送信者NVLをデバイスツリーに追加します。 電話 ： プロジェクト→オブジェクトの追加→ネットワーク変数リスト（送信者） メニュー（デバイスツリーでアプリケーションオブジェクトが選択されている場合） ダイアログはに対応します ネットワーク変数 のタブ プロパティ ネットワーク変数リストオブジェクトの。 " }, 
{ "title" : "オブジェクト：ネットワーク変数リスト（受信者） ", 
"url" : "_cds_obj_nvl_receive.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：ネットワーク変数リスト（受信者） ", 
"snippet" : "ネットワーク変数リスト（受信者） シンボル： オブジェクトは、受信したものを一覧表示するために使用されます ネットワーク変数 情報を表示します：ネットワークと送信情報と送信者。 オブジェクトをアプリケーションに追加するには、をクリックします オブジェクトの追加→ネットワーク変数リスト（受信者） 。 ネットワーク変数リスト（受信者）は、受信したネットワーク変数を一覧表示します。これらの受信したネットワーク変数は、 ネットワーク変数リスト（送信者） 別のデバイスまたはプロジェクトの。オブジェクトエディタでネットワーク変数を変更することはできません。 詳細については、以下を参照してください。 ネット...", 
"body" : "ネットワーク変数リスト（受信者） シンボル： オブジェクトは、受信したものを一覧表示するために使用されます ネットワーク変数 情報を表示します：ネットワークと送信情報と送信者。 オブジェクトをアプリケーションに追加するには、をクリックします オブジェクトの追加→ネットワーク変数リスト（受信者） 。 ネットワーク変数リスト（受信者）は、受信したネットワーク変数を一覧表示します。これらの受信したネットワーク変数は、 ネットワーク変数リスト（送信者） 別のデバイスまたはプロジェクトの。オブジェクトエディタでネットワーク変数を変更することはできません。 詳細については、以下を参照してください。 ネットワーク変数交換の構成オブジェクトエディタは、次の2つのセクションで構成されています。 リストの送信者と転送ログに関する情報 ネットワーク変数の宣言のリスト " }, 
{ "title" : "ダイアログ：ネットワーク変数リストの追加（受信者） ", 
"url" : "_cds_obj_nvl_receive.html#UUID-25c4fc5e-603f-f0b5-4a4f-e0f17cb6fe13_id_ffc4dc53ee3e2727c0a8640e01e914d6_id_656884cf32951609c0a8640e00d18f44", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：ネットワーク変数リスト（受信者） \/ ダイアログ：ネットワーク変数リストの追加（受信者） ", 
"snippet" : "関数 ：ダイアログは、受信側NVLを送信側NVLに定義し、受信側NVLをデバイスツリーのアプリケーションオブジェクトに追加します。 電話 ： プロジェクト→オブジェクトの追加→ネットワーク変数リスト（受信者） メニュー（アプリケーションオブジェクトが選択されている場合） タスク 受信する変数を制御する現在のアプリケーションのタスク 送信者 リストボックス プロジェクト内の別のデバイスで使用可能な送信者NVL ファイルからインポート ：必要な送信者NVLが別のプロジェクトで定義されている場合は必須 このため、目的の送信者NVLは、次のように別のプロジェクトで生成されている必要があります。 GVL...", 
"body" : "関数 ：ダイアログは、受信側NVLを送信側NVLに定義し、受信側NVLをデバイスツリーのアプリケーションオブジェクトに追加します。 電話 ： プロジェクト→オブジェクトの追加→ネットワーク変数リスト（受信者） メニュー（アプリケーションオブジェクトが選択されている場合） タスク 受信する変数を制御する現在のアプリケーションのタスク 送信者 リストボックス プロジェクト内の別のデバイスで使用可能な送信者NVL ファイルからインポート ：必要な送信者NVLが別のプロジェクトで定義されている場合は必須 このため、目的の送信者NVLは、次のように別のプロジェクトで生成されている必要があります。 GVLエクスポートファイル* .gvl のNVLのプロパティダイアログで ファイルへのリンク タブ。 ファイルからインポート のファイル名 GVLエクスポートファイル* .gvl 選択した場合はフォーマット ファイルからインポート ために 送信者 " }, 
{ "title" : "オブジェクト：永続変数リスト ", 
"url" : "_cds_obj_gvl_persistent.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：永続変数リスト ", 
"snippet" : "永続変数リスト シンボル： オブジェクトには、宣言セクションにグローバル永続変数の宣言が含まれています VAR_GLOBAL PERSISTENT RETAIN .. END_VAR 。変数は特別な不揮発性メモリに保存されます。 永続性エディターは、通常の方法で変数をリストとして表示します。表示されるリストは、変数の永続性の動作には影響しませんが、プロセスイメージに内部的に保存されているリストにのみ影響します。そこにあるリストには、これまでに宣言されたすべての変数が時系列で含まれています。削除した変数はプレースホルダーでマークされ、ギャップとして存在し続けます。 宣言セクションには、ローカルで...", 
"body" : "永続変数リスト シンボル： オブジェクトには、宣言セクションにグローバル永続変数の宣言が含まれています VAR_GLOBAL PERSISTENT RETAIN .. END_VAR 。変数は特別な不揮発性メモリに保存されます。 永続性エディターは、通常の方法で変数をリストとして表示します。表示されるリストは、変数の永続性の動作には影響しませんが、プロセスイメージに内部的に保存されているリストにのみ影響します。そこにあるリストには、これまでに宣言されたすべての変数が時系列で含まれています。削除した変数はプレースホルダーでマークされ、ギャップとして存在し続けます。 宣言セクションには、ローカルで宣言された永続変数を参照し、 宣言→すべてのインスタンスパスを追加 指図。 アプリケーションの永続性を設定する方法を決定する前に、 データの永続性 章。さらに、永続変数のメカニズム、保持変数、永続マネージャーの変数、およびレシピ変数を区別できると便利です。 " }, 
{ "title" : "コマンド ", 
"url" : "_cds_obj_gvl_persistent.html#UUID-f626a899-e7ba-9006-b7e2-0aca13999e74_id_cd97ea5ddcd609c0a8640e0075a8ef_id_4d7f128bb7520580c0a8646321d3f70d", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：永続変数リスト \/ コマンド ", 
"snippet" : "次のコマンドが永続性エディターで提供されます。 指示： 宣言→すべてのインスタンスパスを追加 指示： 宣言→リストの並べ替えとギャップの解消...", 
"body" : "次のコマンドが永続性エディターで提供されます。 指示： 宣言→すべてのインスタンスパスを追加 指示： 宣言→リストの並べ替えとギャップの解消 " }, 
{ "title" : "オブジェクト：POU ", 
"url" : "_cds_f_obj_pou.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU ", 
"snippet" : "POU シンボル： タイプのオブジェクト POU の「プログラミング組織ユニット」です CODESYS 事業。コントローラプログラムのソースコードはPOUで記述されています。 次のPOUタイプがあります。 プログラム 関数 ファンクションブロック 追加します POU デバイスツリーまたは POU による表示 プロジェクト→オブジェクトの追加 指図。 POUを追加するときは、POUタイプと実装言語を指定します。 これらのオブジェクトに他のプログラミングオブジェクト（メソッド、アクションなど）を追加することもできます。 POUの呼び出し 特定のPOUは、他のPOUを呼び出すことができます。再帰は許...", 
"body" : "POU シンボル： タイプのオブジェクト POU の「プログラミング組織ユニット」です CODESYS 事業。コントローラプログラムのソースコードはPOUで記述されています。 次のPOUタイプがあります。 プログラム 関数 ファンクションブロック 追加します POU デバイスツリーまたは POU による表示 プロジェクト→オブジェクトの追加 指図。 POUを追加するときは、POUタイプと実装言語を指定します。 これらのオブジェクトに他のプログラミングオブジェクト（メソッド、アクションなど）を追加することもできます。 POUの呼び出し 特定のPOUは、他のPOUを呼び出すことができます。再帰は許可されていません。 名前空間を使用してPOUを呼び出す場合、 CODESYS プロジェクトをスキャンして、次の順序で呼び出されるPOUを探します。 現在のアプリケーション ライブラリマネージャー 現在のアプリケーションの POU 見る ライブラリマネージャー の中に POU 見る アプリケーションで使用されるライブラリに同じ名前で存在し、のオブジェクトとして存在するPOUを呼び出す場合 POU ビューの場合、以下が適用されます。POUを呼び出すことができる構文はありません。 POU その名前だけで表示します。この場合、ライブラリをアプリケーションのライブラリマネージャーからプロジェクトのライブラリマネージャーに移動する必要があります（ POU 見る）。その後、POUオブジェクトを呼び出すことができます POU 単にその名前で表示します。ライブラリに名前空間を追加すると、ライブラリのPOUを呼び出すことができます。 「POU」という用語は、 CODESYS のために POU どこを見る CODESYS プロジェクト全体で有効なオブジェクトを管理します。 " }, 
{ "title" : "ダイアログ：POUを追加 ", 
"url" : "_cds_f_obj_pou.html#UUID-187a911d-cff8-20fa-f0f6-6a96a4fbedb8_section-idm4612494359414432633791667085", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ ダイアログ：POUを追加 ", 
"snippet" : "関数 ：ダイアログは、IEC61131-3規格に従って新しいPOUを構成するために使用されます。これは、POUがプログラム、機能、または機能ブロックである可能性があることを意味します。 電話 ： プロジェクト→オブジェクトの追加 メニュー;のコンテキストメニュー デバイス ビュー（アプリケーションが選択されている場合）;のコンテキストメニュー POU 見る 名前 POUの名前 タイプ プログラム ファンクションブロック 延長 ：オブジェクト指向プログラミングの考え方に基づく基本汎用モジュールの仕様または選択 で指定 拡張 関数ブロック宣言のキーワード 実装 ：オブジェクト指向プログラミングの考...", 
"body" : "関数 ：ダイアログは、IEC61131-3規格に従って新しいPOUを構成するために使用されます。これは、POUがプログラム、機能、または機能ブロックである可能性があることを意味します。 電話 ： プロジェクト→オブジェクトの追加 メニュー;のコンテキストメニュー デバイス ビュー（アプリケーションが選択されている場合）;のコンテキストメニュー POU 見る 名前 POUの名前 タイプ プログラム ファンクションブロック 延長 ：オブジェクト指向プログラミングの考え方に基づく基本汎用モジュールの仕様または選択 で指定 拡張 関数ブロック宣言のキーワード 実装 ：オブジェクト指向プログラミングの考え方に基づくインターフェースの仕様または選択 で指定 実装 関数ブロック宣言のキーワード POUが作成されると、インターフェースを介して定義されたすべてのメソッドが作成されます。 最後の ：派生アクセスは許可されていません。これは、機能ブロックを別の機能ブロックで拡張できないことを意味します。これにより、最適化されたコード生成が可能になります。 概要 ：関数ブロックの実装が欠落しているか不完全であり、インスタンス化できないことを識別します 抽象FBは基本機能ブロックとしてのみ使用され、実装は通常、派生FBで行われます。非抽象関数ブロックが作成され、それが抽象関数ブロックを拡張する場合、抽象基本関数ブロックのすべての抽象メソッドが（非抽象）メソッドとして新しい関数ブロックに追加されます。 アクセス指定子 公衆 ：アクセス指定子なしの指定に対応 内部 ：機能ブロックへのアクセスは名前空間（ライブラリ）に制限されています。 メソッド実装言語 ：を選択した場合 実装 オプションで、ここですべてのメソッドオブジェクトの実装言語を選択できます。 CODESYS インターフェイスの実装によって生成されます。 The メソッド実装言語 機能ブロックの実装言語に依存しません。 関数 注：次の場合は使用できません シーケンシャルファンクションチャート（SFC） として選択されています 実装言語 。 返品タイプ： ：戻り値のデータ型 実装言語 POUの実装言語 " }, 
{ "title" : "オブジェクト：プログラム ", 
"url" : "_cds_obj_program.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：プログラム ", 
"snippet" : "プログラム プログラムは、実行時に1つ以上の値を生成するPOUです。プログラムの実行後、次の実行まで、すべての値は変更されません。アプリケーション内のプログラムの呼び出し順序は、タスクオブジェクトで定義されます。 クリックして、オブジェクトをアプリケーションまたはプロジェクトに追加します プロジェクト→オブジェクトの追加→POU 。デバイスツリーと POU ビュー、プログラムPOUには （PRG） サフィックス。 プログラムのエディタは、宣言部分と実装部分で構成されています。 宣言部分の一番上の行には、次の宣言が含まれています。 PROGRAM <program>...", 
"body" : "プログラム searchresult_toplevel プログラムは、実行時に1つ以上の値を生成するPOUです。プログラムの実行後、次の実行まで、すべての値は変更されません。アプリケーション内のプログラムの呼び出し順序は、タスクオブジェクトで定義されます。 クリックして、オブジェクトをアプリケーションまたはプロジェクトに追加します プロジェクト→オブジェクトの追加→POU 。デバイスツリーと POU ビュー、プログラムPOUには （PRG） サフィックス。 プログラムのエディタは、宣言部分と実装部分で構成されています。 宣言部分の一番上の行には、次の宣言が含まれています。 PROGRAM <program> " }, 
{ "title" : "プログラムを呼び出す ", 
"url" : "_cds_obj_program.html#UUID-ad0a9eae-2290-5bff-bc9e-f203219c6d3b_id_f8163f81a1ed20cc0a8640e00f7941f_id_f8fc98ce4f67d6dbc0a8640e01e44c5e", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：プログラム \/ プログラムを呼び出す ", 
"snippet" : "プログラムと機能ブロックはプログラムを呼び出すことができます。関数内でのプログラム呼び出しは許可されていません。プログラムのインスタンスはありません。 もし POU プログラムを呼び出し、その結果、プログラムの値が変更されます。これらの変更は、次のプログラム呼び出しまで保持されます。プログラムの値は、次の呼び出しが別のPOUによって行われた場合でも保持されます。これは、機能ブロックの呼び出しとは異なります。機能ブロックが呼び出されると、機能ブロックのそれぞれのインスタンスの値のみが変更されます。変更は、POUが同じインスタンスを再度呼び出す場合にのみ考慮されます。 プログラムを呼び出すときに、...", 
"body" : "プログラムと機能ブロックはプログラムを呼び出すことができます。関数内でのプログラム呼び出しは許可されていません。プログラムのインスタンスはありません。 もし POU プログラムを呼び出し、その結果、プログラムの値が変更されます。これらの変更は、次のプログラム呼び出しまで保持されます。プログラムの値は、次の呼び出しが別のPOUによって行われた場合でも保持されます。これは、機能ブロックの呼び出しとは異なります。機能ブロックが呼び出されると、機能ブロックのそれぞれのインスタンスの値のみが変更されます。変更は、POUが同じインスタンスを再度呼び出す場合にのみ考慮されます。 プログラムを呼び出すときに、プログラムの入力パラメータや出力パラメータを直接設定することもできます。 構文： <program>(<input variable> := <value>, <output value> => <value>): 入力アシスタントを使用してプログラム呼び出しを挿入する場合、 引数付きで挿入 入力アシスタントでオプションを選択してから、 CODESYS 構文に従って、入力および\/または出力パラメーターをプログラム呼び出しに追加します。 例 呼び出し： AWL： パラメータの割り当て： ST： PLC_PRG()\nerg := PLC_PRG.out2; パラメータの割り当て： PLC_PRG(in1:=2, out1=>erg); " }, 
{ "title" : "オブジェクト：機能ブロック ", 
"url" : "_cds_obj_function_block.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：機能ブロック ", 
"snippet" : "ファンクションブロック 機能ブロックは、実行時に1つ以上の値を生成するPOUです。 クリックすると、オブジェクトがアプリケーションまたはプロジェクトに追加されます プロジェクト→オブジェクトの追加→POU 。デバイスツリーまたは POU ビュー、機能ブロックPOUには、 （FB） サフィックス。 機能ブロックのコピーであるインスタンスを使用して、常に機能ブロックを呼び出します。 機能ブロックのエディタは、宣言部分と実装部分で構成されています。 出力変数と内部変数の値は、実行後、次の実行まで変更されません。これは、関数ブロックが同じ入力変数を使用した複数の呼び出しに対して必ずしも同じ出力値を返す...", 
"body" : "ファンクションブロック 機能ブロックは、実行時に1つ以上の値を生成するPOUです。 クリックすると、オブジェクトがアプリケーションまたはプロジェクトに追加されます プロジェクト→オブジェクトの追加→POU 。デバイスツリーまたは POU ビュー、機能ブロックPOUには、 （FB） サフィックス。 機能ブロックのコピーであるインスタンスを使用して、常に機能ブロックを呼び出します。 機能ブロックのエディタは、宣言部分と実装部分で構成されています。 出力変数と内部変数の値は、実行後、次の実行まで変更されません。これは、関数ブロックが同じ入力変数を使用した複数の呼び出しに対して必ずしも同じ出力値を返すとは限らないことを意味します。 IEC 61131-3で説明されている機能に加えて、で機能ブロックを使用することもできます。 CODESYS オブジェクト指向プログラミングの次の機能について： 拡大 機能ブロックの 実装 インターフェイスの メソッド プロパティ 宣言部分の一番上の行には、次の宣言が含まれています。 FUNCTION_BLOCK <access specifier> <function block> \\| EXTENDS <function block> \\| IMPLEMENTS <comma-separated list of interfaces> " }, 
{ "title" : "機能ブロックの呼び出し ", 
"url" : "_cds_obj_function_block.html#UUID-bd14b797-a7fe-0201-278a-491e9af37040_id_a70a3a130569cc4fc0a8640e01f8feef_id_fdfeb24e4f64721fc0a8640e01ba60f7", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：機能ブロック \/ 機能ブロックの呼び出し ", 
"snippet" : "呼び出しは、常に機能ブロックのインスタンスを使用して行われます。機能ブロックが呼び出されると、それぞれのインスタンスの値のみが変更されます。 インスタンスの宣言： <instance> : <function block>; 以下のように、実装部分の機能ブロックの変数にアクセスします。 <instance> . <variable> 次の点に注意してください。 内部変数ではなく、機能ブロックインスタンスの外部から機能ブロックの入力変数と出力変数にのみアクセスできます。 インスタンスをグローバルに宣言していない限り、機能ブロックインスタンスへのアクセスは、インスタンスが宣言されているPOUに制限...", 
"body" : "呼び出しは、常に機能ブロックのインスタンスを使用して行われます。機能ブロックが呼び出されると、それぞれのインスタンスの値のみが変更されます。 インスタンスの宣言： <instance> : <function block>; 以下のように、実装部分の機能ブロックの変数にアクセスします。 <instance> . <variable> 次の点に注意してください。 内部変数ではなく、機能ブロックインスタンスの外部から機能ブロックの入力変数と出力変数にのみアクセスできます。 インスタンスをグローバルに宣言していない限り、機能ブロックインスタンスへのアクセスは、インスタンスが宣言されているPOUに制限されます。 インスタンスを呼び出すときに、必要な値を汎用ブロック変数に割り当てることができます。 例 機能ブロック変数へのアクセス： 機能ブロック FB1 入力変数があります iVar1 タイプの INT および出力変数 out1 。以下では、変数 iVar1 プログラムから呼び出されます Prog 。 PROGRAM Prog\nVAR\ninst1 : FB1;\nEND_VAR\n\ninst1.iVar1 := 33; (* FB1 is called and the value 33 is assigned to the variable iVar1 *)\n\ninst1(); (* FB1 is called, that's necessary for the following access to the output variable *)\n\nires := inst1.out1 (* the output variable out1 of the FB1 is read *) FBDの場合： 呼び出し時に変数値を割り当てる： テキスト言語ILおよびSTでは、機能ブロックを呼び出すときに、入力変数および\/または出力変数に値を直接割り当てることができます。 値は、次のように入力変数に割り当てられます。 := 。 値は、次のように出力変数に割り当てられます。 => 。 例 インスタンス CMD_TMR タイマー機能ブロックのは、入力変数の割り当てで呼び出されます IN と PT 。次に、出力変数 Q タイマーのが変数に割り当てられます A 。 PROGRAM PLC_PRG\nVAR\n CMD_TMR : TOF;\nEND_VAR\n\nCMD_TMR(IN := %IX5.1, PT := T#100MS);\nA := CMD_TMR.Q; を使用して機能ブロックインスタンスを挿入する場合 入力アシスタント を選択します 引数付きで挿入 のオプション 入力アシスタント ダイアログ、 CODESYS すべての入力変数と出力変数を使用して呼び出しを挿入します。次に、必要な値の割り当てを挿入するだけです。上記の例では、 CODESYS 次のように呼び出しを挿入します。 CMD_TMR (IN:= ,PT:= , Q=> ) 。 あなたは使用することができます '接続されています' ローカル変数の属性。関数ブロックインスタンスの呼び出し時に、特定の入力が外部割り当てを受け取るかどうかを決定します。 " }, 
{ "title" : "オブジェクト：関数 ", 
"url" : "_cds_obj_function.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：関数 ", 
"snippet" : "関数 関数は POU これは、実行時に正確に1つのデータ要素を提供し、テキスト言語での呼び出しは式の演算子として発生する可能性があります。データ要素は、配列または構造体にすることもできます。 クリックすると、オブジェクトがアプリケーションまたはプロジェクトに追加されます プロジェクト→オブジェクトの追加→POU 。デバイスツリーまたは POU ビュー、機能POUには （楽しい） サフィックス。 関数には内部ステータス情報がありません。つまり、関数は次の呼び出しまで変数の値を保存しません。同じ入力変数値を持つ関数の呼び出しは、常に同じ出力値を提供します。したがって、関数はグローバル変数とアドレス...", 
"body" : "関数 関数は POU これは、実行時に正確に1つのデータ要素を提供し、テキスト言語での呼び出しは式の演算子として発生する可能性があります。データ要素は、配列または構造体にすることもできます。 クリックすると、オブジェクトがアプリケーションまたはプロジェクトに追加されます プロジェクト→オブジェクトの追加→POU 。デバイスツリーまたは POU ビュー、機能POUには （楽しい） サフィックス。 関数には内部ステータス情報がありません。つまり、関数は次の呼び出しまで変数の値を保存しません。同じ入力変数値を持つ関数の呼び出しは、常に同じ出力値を提供します。したがって、関数はグローバル変数とアドレスを使用してはなりません。 関数のエディターは、宣言部分と実装部分で構成されます。 宣言部分の一番上の行には、次の宣言が含まれています。 FUNCTION <function> : <data type> その下で、入力変数と関数変数を宣言します。 関数の出力変数は関数名です。 関数でローカル変数を次のように宣言する場合 RETAIN 、これは効果がありません。この場合、 CODESYS コンパイラエラーを発行します。 の関数呼び出しで明示的および暗黙的なパラメータ割り当てを混在させることはできません CODESYS V3 。これは、関数呼び出しで明示的または暗黙的なパラメーター割り当てのみを使用する必要があることを意味します。関数を呼び出すときのパラメーター割り当ての順序は任意です。 " }, 
{ "title" : "関数を呼び出す ", 
"url" : "_cds_obj_function.html#UUID-031b5d94-7e37-be07-c3ea-2dd9a75bdc3a_id_d8edec4a146076cec0a8640e0081effa_id_f9f95a4f1a50ad0ac0a8640e0134f3b9", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：関数 \/ 関数を呼び出す ", 
"snippet" : "STでは、関数の呼び出しを式のオペランドとして使用できます。 SFCでは、ステップアクションまたはトランジション内でのみ関数呼び出しを使用できます。 例 宣言部分と行実装コードを持つ関数 関数呼び出し： ST： result := POU_Funct(5,3,22); IL： FBD：...", 
"body" : "STでは、関数の呼び出しを式のオペランドとして使用できます。 SFCでは、ステップアクションまたはトランジション内でのみ関数呼び出しを使用できます。 例 宣言部分と行実装コードを持つ関数 関数呼び出し： ST： result := POU_Funct(5,3,22); IL： FBD： " }, 
{ "title" : "追加の出力を備えた機能 ", 
"url" : "_cds_obj_function.html#UUID-031b5d94-7e37-be07-c3ea-2dd9a75bdc3a_id_d8edec4a146076cec0a8640e0081effa_id_d39a416b1a50ad0bc0a8640e0141d1c9", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：関数 \/ 追加の出力を備えた機能 ", 
"snippet" : "IEC 61131-3規格によれば、関数は追加の出力を持つことができます。キーワード間の関数で追加の出力を宣言します VAR_OUTPUT と END_VAR 。この関数は、次の構文に従って呼び出されます。 <function> (<function output variable1> => <output variable 1>, <function output variable n> => <output variable n>) 例 The fun 関数は2つの入力変数で定義されます in1 と in2 。の出力変数 fun 関数はローカルで宣言された出力変数に書き込まれます loc1...", 
"body" : "IEC 61131-3規格によれば、関数は追加の出力を持つことができます。キーワード間の関数で追加の出力を宣言します VAR_OUTPUT と END_VAR 。この関数は、次の構文に従って呼び出されます。 <function> (<function output variable1> => <output variable 1>, <function output variable n> => <output variable n>) 例 The fun 関数は2つの入力変数で定義されます in1 と in2 。の出力変数 fun 関数はローカルで宣言された出力変数に書き込まれます loc1 と loc2 。 fun(in1 := 1, in2 := 2, out1 => loc1, out2 => loc2); " }, 
{ "title" : "オブジェクト：インターフェース ", 
"url" : "_cds_obj_interface.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：インターフェース ", 
"snippet" : "インターフェース シンボル： キーワード： INTERFACE インターフェイスは、オブジェクト指向プログラミングの手段です。オブジェクト ITF メソッドとプロパティのプロトタイプのセットについて説明します。この文脈では、プロトタイプは、 メソッド と プロパティ 宣言のみが含まれ、実装は含まれません。 これにより、共通のプロパティを持つさまざまな機能ブロックを同じように使用できます。アン ITF クリックすると、オブジェクトがアプリケーションまたはプロジェクトに追加されます プロジェクト→オブジェクトの追加→インターフェース 詳細については、以下を参照してください。 インターフェイスを実装...", 
"body" : "インターフェース シンボル： キーワード： INTERFACE インターフェイスは、オブジェクト指向プログラミングの手段です。オブジェクト ITF メソッドとプロパティのプロトタイプのセットについて説明します。この文脈では、プロトタイプは、 メソッド と プロパティ 宣言のみが含まれ、実装は含まれません。 これにより、共通のプロパティを持つさまざまな機能ブロックを同じように使用できます。アン ITF クリックすると、オブジェクトがアプリケーションまたはプロジェクトに追加されます プロジェクト→オブジェクトの追加→インターフェース 詳細については、以下を参照してください。 インターフェイスを実装するインターフェイスの追加 継承 名前 インターフェイス名 高度 ：入力フィールドまたは入力アシスタントを介して選択したインターフェイスを拡張します 。これは、新しいインターフェイスを拡張するインターフェイスのすべてのメソッドが新しいインターフェイスでも使用できることを意味します。 詳細については、以下を参照してください。 インターフェイスを拡張するインターフェースでは多重継承がサポートされています。 あなたは追加することができます インターフェイスプロパティ と インターフェイス方式 にオブジェクト ITF 物体。インターフェイスメソッドには、入力変数、出力変数、およびVAR_IN_OUT変数の宣言のみを含めることができますが、実装は含めることができません。 プログラムでインタフェースも使用できるようにするには、このインタフェースを実装する機能ブロックが必要です。 これの意味は： ファンクションブロックには、宣言部分のIMPLEMENTSリストにインターフェイスが含まれています 関数ブロックには、インターフェイスのすべてのメソッドとプロパティのプロトタイプの実装が含まれています 機能ブロックは、1つ以上のインターフェースを実装できます。同じパラメータで同じメソッドを使用できますが、異なる機能ブロックで異なる実装コードを使用できます。 次の点に注意してください。 インターフェイス内で変数を定義してはなりません。インターフェイスには実装部分もアクションもありません。メソッドのコレクションのみが定義され、入力、出力、およびVAR_IN_OUT変数のみを定義できます。 CODESYS インターフェイスの型で宣言された変数を常に参照として扱います。 インターフェイスを実装する機能ブロックには、インターフェイスのメソッドの実装コードが含まれている必要があります。インターフェイスとまったく同じようにメソッドに名前を付けました。メソッドには、インターフェイスと同じ入力、出力、およびVAR_IN_OUT変数が含まれています。 インターフェイスの参照とオンラインの変更 コンパイラバージョンが3.4.1.0未満の場合、次のことが発生する可能性があります。 変数が追加または削除されたため、または変数のタイプが変更されたために関数ブロックがデータを変更した場合、 CODESYS 機能ブロックのすべてのインスタンスを新しいメモリ位置にコピーします。ただし、この場合、インターフェイス参照は新しいメモリの場所ではなく、古いメモリの場所を参照します。 コンパイラバージョン> = 3.4.1.0の場合、 CODESYS インターフェイス参照を自動的に再アドレス指定して、 CODESYS また、オンライン変更の場合に正しいインターフェースを参照します。 CODESYS これには追加のコードとより多くの時間が必要であるため、関係するオブジェクトの数によってはジッターの問題が発生する可能性があります。したがって、 CODESYS オンライン変更の実行前に関係する変数とインターフェース参照の数を表示し、オンライン変更を実行するか中止するかを決定できます。 例 インターフェイスの定義と機能ブロックでのその使用 インターフェイスを挿入しました ITF アプリケーションの下。インターフェイスにはメソッドが含まれています 方法1 と 方法2 。 ITF 、 方法1 と 方法2 実装コードは含まれていません。必要な変数宣言は、メソッドの宣言部分にのみ挿入します。 その後、インターフェイスを実装するデバイスツリーに機能ブロックを挿入する場合 ITF 、 CODESYS メソッドも自動的に挿入します 方法1 と 方法2 機能ブロックの下。ここでは、メソッドに関数ブロック固有のコードを実装できます。 " }, 
{ "title" : "オブジェクト：メソッド ", 
"url" : "_cds_obj_method.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：メソッド ", 
"snippet" : "方法 シンボル： キーワード： METHOD メソッドは、IEC 61131-3標準の拡張であり、データのカプセル化に使用されるオブジェクト指向プログラミング用のツールです。メソッドには、宣言と実装が含まれています。ただし、関数とは異なり、メソッドは独立したPOUではなく、関数ブロックまたはプログラムに従属します。メソッドは、上位POUのすべての有効な変数にアクセスできます。 プログラムまたは関数ブロックの下にメソッドを追加できます。クリック プロジェクト → オブジェクトの追加 → メソッド .そうして メソッドを追加 ダイアログが開きます。 メソッドの編成にインターフェースを使用できます。...", 
"body" : "方法 シンボル： キーワード： METHOD メソッドは、IEC 61131-3標準の拡張であり、データのカプセル化に使用されるオブジェクト指向プログラミング用のツールです。メソッドには、宣言と実装が含まれています。ただし、関数とは異なり、メソッドは独立したPOUではなく、関数ブロックまたはプログラムに従属します。メソッドは、上位POUのすべての有効な変数にアクセスできます。 プログラムまたは関数ブロックの下にメソッドを追加できます。クリック プロジェクト → オブジェクトの追加 → メソッド .そうして メソッドを追加 ダイアログが開きます。 メソッドの編成にインターフェースを使用できます。 詳細については、次を参照してください。 インターフェイスを実装するPOUの下にメソッドをコピーしてインターフェイスの下に追加するか、メソッドをそこに移動すると、含まれている実装が自動的に削除されます。 " }, 
{ "title" : "宣言 ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_id_e4507ebe4233ac0c0a8640e00a37b12_id_1a9cda980d7f5306c0a86463246390b7", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：メソッド \/ 宣言 ", 
"snippet" : "構文： METHOD <access specifier> <method name> : <type of return value> <access specifier> オプション アクセス指定子 宣言されたアクセス指定子に応じて、メソッドは独自の名前空間内でのみ呼び出すことができます ( INTERNAL )、独自の POU およびその派生物内のみ ( PROTECTED )、または独自の POU 内のみ ( PRIVATE ）。ために PUBLIC 、メソッドはどこからでも呼び出すことができます。 <method name> メソッドの識別子 <type of retur value...", 
"body" : "構文： METHOD <access specifier> <method name> : <type of return value> <access specifier> オプション アクセス指定子 宣言されたアクセス指定子に応じて、メソッドは独自の名前空間内でのみ呼び出すことができます ( INTERNAL )、独自の POU およびその派生物内のみ ( PROTECTED )、または独自の POU 内のみ ( PRIVATE ）。ために PUBLIC 、メソッドはどこからでも呼び出すことができます。 <method name> メソッドの識別子 <type of retur value> オプション メソッドの戻り値の型 注: 明示的な戻り値の型を持たないメソッドの場合、最初に宣言された出力が戻り値として使用されます。戻り値の型も出力も宣言されていない場合にのみ、メソッドは値を返しません。ただし、どちらの場合もコンパイラ エラーは生成されません。 変数宣言 (パラメーター) で可能なスコープ <scope list> スコープ: VAR_IN_OUT <variable declaration list> END_VAR 入出力変数の変数宣言用 VAR_INPUT <variable declaration list> END_VAR 入力の変数宣言用 VAR_OUTPUT <variable declaration list> END_VAR 出力用変数宣言用 関数と同様に、メソッドは追加の出力を持つことができます。メソッドを呼び出すときに、追加の出力に引数 (変数) を渡す必要もあります。 VAR <variable declaration list> END_VAR ローカル目的の変数宣言用 <variable declaration list> 変数宣言 <variable name> : <data type> := <initial value> ; 目的に応じてスコープに割り当てられる変数 (パラメーター) のセミコロン区切りのリスト。 入力および入出力の変数には、初期値を割り当てることができます 初期値の割り当てはオプションです。ただし、指定されている場合は、メソッドを呼び出すときに、このパラメーターに引数を渡すことを省略できます。これらの種類のパラメーターは、オプションのパラメーターと呼ばれます。 メソッドの変数 (パラメーター) には、メソッドの実行中にのみ有効な一時データ (スタック変数) が含まれます。メソッドで宣言および実装されるすべての変数は、メソッドが呼び出されるたびに再初期化されます。 例 宣言 METHOD PUBLIC DoIt : BOOL\nVAR_INPUT\n iInput_1 : DWORD;\n iInput_2 : DWORD;\n sInput_3 : STRING(12);\nEND_VAR " }, 
{ "title" : "実装 ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_id_e4507ebe4233ac0c0a8640e00a37b12_id_d5a78e4a116f11e8b6e4d1a39d87c360", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：メソッド \/ 実装 ", 
"snippet" : "オプション メソッドの実装のために、ファンクション ブロック インスタンスまたはプログラム変数へのアクセスが許可されます。 の これ ポインタは、独自の機能ブロック インスタンスへのアクセスを許可します。したがって、ポインターは、関数ブロックに割り当てられているメソッドでのみ使用できます。 メソッドがアクセスできない VAR_TEMP 関数ブロックの変数。 メソッドはそれ自体を再帰的に呼び出すことができます。 インターフェイス メソッドの実装はありません インターフェイスメソッド 入力、出力、およびを宣言できます VAR_IN_OUT 変数ですが、実装は含まれていません。...", 
"body" : "オプション メソッドの実装のために、ファンクション ブロック インスタンスまたはプログラム変数へのアクセスが許可されます。 の これ ポインタは、独自の機能ブロック インスタンスへのアクセスを許可します。したがって、ポインターは、関数ブロックに割り当てられているメソッドでのみ使用できます。 メソッドがアクセスできない VAR_TEMP 関数ブロックの変数。 メソッドはそれ自体を再帰的に呼び出すことができます。 インターフェイス メソッドの実装はありません インターフェイスメソッド 入力、出力、およびを宣言できます VAR_IN_OUT 変数ですが、実装は含まれていません。 " }, 
{ "title" : "メソッドの呼び出し ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_id_e4507ebe4233ac0c0a8640e00a37b12_id_7f4f002a7a7c22c7c0a864630de7909a", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：メソッド \/ メソッドの呼び出し ", 
"snippet" : "呼び出しの構文: <return value variable> := <POU name> . <method name> ( <argument passing> ); <return value variable> 戻り値の変数 型は、メソッドの戻り値の型と一致する必要があります。 注: 明示的な戻り値の型を持たないメソッドの場合、最初に宣言された出力が戻り値として使用されます。戻り値の型も出力も宣言されていない場合にのみ、メソッドは値を返しません。ただし、どちらの場合もコンパイラ エラーは生成されません。 <POU name> メソッドが配置されているファンクション ブロック インスタ...", 
"body" : "呼び出しの構文: <return value variable> := <POU name> . <method name> ( <argument passing> ); <return value variable> 戻り値の変数 型は、メソッドの戻り値の型と一致する必要があります。 注: 明示的な戻り値の型を持たないメソッドの場合、最初に宣言された出力が戻り値として使用されます。戻り値の型も出力も宣言されていない場合にのみ、メソッドは値を返しません。ただし、どちらの場合もコンパイラ エラーは生成されません。 <POU name> メソッドが配置されているファンクション ブロック インスタンスの識別子 <method name> メソッドの識別子 <argument passing> 実際の引数を含むカンマ区切りのリスト メソッドの各パラメーター (変数) に 1 つの引数が渡されます。 <parameter name> := <actual argument> 宣言された各入力\/出力または入力には、実引数が割り当てられます。引数には、値 (リテラル)、式、または型が一致する変数を指定できます。 実引数 (同じ型の変数) は、宣言された各出力に割り当てられます。引数は、型が一致する変数でなければなりません。 入力または入出力の引数の受け渡しは省略できます。 したがって、リスト内の引数の数は、パラメーター (入力または入出力のスコープ) の数よりも少なくなる場合があります。特に、宣言でデフォルト値または初期値が指定されたオプションのパラメータである場合は、引数の受け渡しを省略できます。 ヒント: メソッドを呼び出すときに入力アシスタントからヘルプを取得すると、既存の初期値について通知されます。 名前と代入演算子を使用してパラメータを指定して引数を渡すことはオプションです。 引数のみを指定するだけで十分です。宣言内の変数の順序によって、どの引数がどのパラメーターに渡されるかが決まります。 例 宣言 METHOD PUBLIC DoIt : BOOL\nVAR_INPUT\n iInput_1 : DWORD;\n iInput_2 : DWORD;\n sInput_3 : STRING(12);\nEND_VAR パラメータに引数を渡して呼び出す bFinishedMethod := fbInstance.DoIt(sInput_3 := 'Hello World ', iInput_2 := 16#FFFF, iInput_1 := 16); メソッドが呼び出されると、メソッドの戻り値がローカルに宣言された変数に割り当てられます。 例 入力変数の名前を省略した場合、引数の割り当ては宣言の順序によって行われます。 入力変数の名前を省略した場合、引数の割り当ては宣言の順序によって行われます。 METHOD PUBLIC DoIt : BOOL\nVAR_INPUT\n iInput_1 : DWORD;\n iInput_2 : DWORD;\n sInput_3 : STRING(12);\nEND_VAR\nIF iInput_1 = iInput_2 THEN\n\tDoIt := TRUE; \/\/ explicit return value\nEND_IF\n\n 宣言の順番通りに引数を渡して呼び出す bFinishedMethod := fbInstance.DoIt( 16, 16#0010,'Hello World '); " }, 
{ "title" : "再帰的なメソッド呼び出し ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_id_e4507ebe4233ac0c0a8640e00a37b12_id_421cb3a8093e22bac0a8640e01a50890", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：メソッド \/ 再帰的なメソッド呼び出し ", 
"snippet" : "実装内では、メソッドは、 これ ポインタ、または割り当てられた機能ブロックのローカル変数を使用します。 <return value variable> := <POU name> . <method name> ( <argument passing> ); 関連する機能ブロックインスタンスの直接呼び出し THIS ポインタ <return value variable> := <POU name> . <method name> ( <argument passing> ); 関連する関数ブロックを一時的にインスタンス化するメソッドのローカル変数による呼び出し 再帰的な場合、コンパイラの警告...", 
"body" : "実装内では、メソッドは、 これ ポインタ、または割り当てられた機能ブロックのローカル変数を使用します。 <return value variable> := <POU name> . <method name> ( <argument passing> ); 関連する機能ブロックインスタンスの直接呼び出し THIS ポインタ <return value variable> := <POU name> . <method name> ( <argument passing> ); 関連する関数ブロックを一時的にインスタンス化するメソッドのローカル変数による呼び出し 再帰的な場合、コンパイラの警告が発行されます 電話 .メソッドがプラグマで提供されている場合 {attribute 'estimated-stack-usage' := '<estimated stack size in bytes>'} の場合、コンパイラの警告は抑制されます。 実装例については、「属性: 「推定スタック使用量」 」の章。 メソッドを再帰的に呼び出すには、メソッド名だけを指定するだけでは不十分です。メソッド名のみを指定すると、コンパイラ エラーが発生します。 の代わりにプログラム名、関数または関数ブロックのインスタンスが必要です " }, 
{ "title" : "関数ブロックの特別なメソッド ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_id_e4507ebe4233ac0c0a8640e00a37b12_id_1c08ae16e567f9b0c0a8640e008b85b9", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：メソッド \/ 関数ブロックの特別なメソッド ", 
"snippet" : "FB_Init 宣言は自動的に暗黙的ですが、明示的な宣言も可能です 関数ブロックの宣言部分で定義されている、関数ブロックの初期化コードが含まれています FB_Reinit 明示的な宣言が必要です。 機能ブロックのインスタンスがコピーされた後に呼び出します（オンライン変更中など）。新しいインスタンスモジュールを再初期化します。 FB_Exit 明示的な宣言が必要です。 新しいダウンロードまたはリセットの前、またはシフトまたは削除されたすべてのインスタンスのオンライン変更中に、機能ブロックの各インスタンスを呼び出します。 プロパティ 提供します Set および\/または Get アクセサメソッド。...", 
"body" : "FB_Init 宣言は自動的に暗黙的ですが、明示的な宣言も可能です 関数ブロックの宣言部分で定義されている、関数ブロックの初期化コードが含まれています FB_Reinit 明示的な宣言が必要です。 機能ブロックのインスタンスがコピーされた後に呼び出します（オンライン変更中など）。新しいインスタンスモジュールを再初期化します。 FB_Exit 明示的な宣言が必要です。 新しいダウンロードまたはリセットの前、またはシフトまたは削除されたすべてのインスタンスのオンライン変更中に、機能ブロックの各インスタンスを呼び出します。 プロパティ 提供します Set および\/または Get アクセサメソッド。 " }, 
{ "title" : "ダイアログ： メソッドの追加 ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_id_e4507ebe4233ac0c0a8640e00a37b12_id_9181172594148571c0a864634fbe4313", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：メソッド \/ ダイアログ： メソッドの追加 ", 
"snippet" : "関数 ：ダイアログを閉じたときに、選択したPOUの下にメソッドを定義します。 電話 ： プロジェクト→オブジェクトの追加→メソッド ;コンテキストメニュー 要件 ： プログラム （ PRG ）または機能ブロック（ FUNCTION_BLOCK ）が選択されている POU ビューまたは デバイス 見る。 基本機能ブロックの下に挿入されたメソッドのインターフェースは、派生機能ブロックの下に同じ名前のメソッドが挿入されたときにコピーされます。 名前 例： meth_DoIt 。 標準的な方法 FB_Init と FB_Exit POUの下にまだ挿入されていない場合は、リストボックスに表示されます。派...", 
"body" : "関数 ：ダイアログを閉じたときに、選択したPOUの下にメソッドを定義します。 電話 ： プロジェクト→オブジェクトの追加→メソッド ;コンテキストメニュー 要件 ： プログラム （ PRG ）または機能ブロック（ FUNCTION_BLOCK ）が選択されている POU ビューまたは デバイス 見る。 基本機能ブロックの下に挿入されたメソッドのインターフェースは、派生機能ブロックの下に同じ名前のメソッドが挿入されたときにコピーされます。 名前 例： meth_DoIt 。 標準的な方法 FB_Init と FB_Exit POUの下にまだ挿入されていない場合は、リストボックスに表示されます。派生機能ブロックの場合、リストボックスには基本機能ブロックのすべてのメソッドも表示されます。 リターンタイプ 戻り値のデフォルトのデータ型または構造化データ型 例： BOOL 実装言語 例： 構造化テキスト（ST） アクセス指定子 データへのアクセスを制御します。 公衆 または指定なし：アクセスは制限されません。 プライベート ：アクセスは、プログラム、機能ブロック、またはGVLに制限されています。 オブジェクトはとしてマークされます (private) POUまたはデバイスビューで。宣言にはキーワードが含まれています PRIVATE 。 保護されています ：アクセスは、プログラム、機能ブロック、またはその派生物を含むGVLに制限されます。宣言にはキーワードが含まれています PROTECTED 。 オブジェクトはとしてマークされます (protected) POUまたはデバイスビューで。 内部 ：メソッドへのアクセスは名前空間（ライブラリ）に制限されています。 オブジェクトはとしてマークされます (internal) POUまたはデバイスビューで。宣言にはキーワードが含まれています INTERNAL 。 概要 ：メソッドに実装がなく、実装が派生FBによって提供されることを識別します。 追加 選択したオブジェクトの下に新しいメソッドを追加します。 " }, 
{ "title" : "継承POUを生成する際の入力サポート ", 
"url" : "_cds_obj_method.html#UUID-3ffa7d86-0dd3-df46-0982-283864627b59_UUID-e3a7d561-c8bd-ff0c-4eda-2e6419e8e10f", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：メソッド \/ ダイアログ： メソッドの追加 \/ 継承POUを生成する際の入力サポート ", 
"snippet" : "オブジェクト指向プログラミングを行い、継承を使用する場合（ EXTENDS  キーワード）POUの場合、次のようにサポートを受けることができます。 ベースPOUから派生したPOUの下にアクション、プロパティ、メソッド、またはトランジションを挿入すると、 追加 … ダイアログが開きます。次に、名前の入力フィールドがリストボックスに拡張されます。リストボックスには、ベースPOUで使用可能なアクション、プロパティ、メソッド、またはトランジションからの有効な選択が含まれています。これで、たとえば、ベースPOUのメソッドを簡単に受け入れて、それをPOUの派生関数に適合させることができます。 アクセス修飾...", 
"body" : "オブジェクト指向プログラミングを行い、継承を使用する場合（ EXTENDS  キーワード）POUの場合、次のようにサポートを受けることができます。 ベースPOUから派生したPOUの下にアクション、プロパティ、メソッド、またはトランジションを挿入すると、 追加 … ダイアログが開きます。次に、名前の入力フィールドがリストボックスに拡張されます。リストボックスには、ベースPOUで使用可能なアクション、プロパティ、メソッド、またはトランジションからの有効な選択が含まれています。これで、たとえば、ベースPOUのメソッドを簡単に受け入れて、それをPOUの派生関数に適合させることができます。 アクセス修飾子を使用したメソッドとプロパティ PRIVATE それらも継承されないため、ここにはリストされていません。アクセス修飾子を使用したメソッドとプロパティ PUBLIC 派生したPOUに受け入れると、自動的に空白のアクセス修飾子フィールドを取得します。これは、機能的には同じことを意味します。 詳細については、以下を参照してください。 財産、 方法、 遷移、 アクション、 例 " }, 
{ "title" : "オブジェクト：インターフェースメソッド ", 
"url" : "_cds_obj_interface_method.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：インターフェースメソッド ", 
"snippet" : "インターフェイス方式 シンボル： オブジェクトは、オブジェクト指向プログラミングに使用されます。 追加します インターフェイス方式 オブジェクトがに追加されます インターフェース によって プロジェクト→オブジェクトの追加 指図。 メソッドがインターフェースの下に挿入されている場合、これに変数宣言（入力、出力、および入出力変数）のみを追加してインスタンス化できます。 方法 。 プログラムコードは、機能ブロックの場合にのみメソッドに追加できます 実装 メソッドが属するインターフェース。 CODESYS 次に、関数ブロックの下にメソッドを挿入します。...", 
"body" : "インターフェイス方式 シンボル： オブジェクトは、オブジェクト指向プログラミングに使用されます。 追加します インターフェイス方式 オブジェクトがに追加されます インターフェース によって プロジェクト→オブジェクトの追加 指図。 メソッドがインターフェースの下に挿入されている場合、これに変数宣言（入力、出力、および入出力変数）のみを追加してインスタンス化できます。 方法 。 プログラムコードは、機能ブロックの場合にのみメソッドに追加できます 実装 メソッドが属するインターフェース。 CODESYS 次に、関数ブロックの下にメソッドを挿入します。 " }, 
{ "title" : "オブジェクト：インターフェイスプロパティ ", 
"url" : "_cds_obj_interface_property.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：インターフェイスプロパティ ", 
"snippet" : "インターフェイスプロパティ シンボル： インターフェイスプロパティは、IEC 61131-3標準の拡張であり、オブジェクト指向プログラミング用のツールです。インターフェイスプロパティはアクセサメソッドを宣言します Get と Set （実装コードなし）。したがって、 インターフェース また、それらのインターフェースプロパティを継承します。 インターフェイスのデバイスツリーにインターフェイスプロパティを追加できます。次に、インターフェイスがアクセサメソッドで拡張されます Get と Set 。 The Get アクセサーは読み取りアクセス用です。 The Set アクセサは書き込みアクセス用です...", 
"body" : "インターフェイスプロパティ シンボル： インターフェイスプロパティは、IEC 61131-3標準の拡張であり、オブジェクト指向プログラミング用のツールです。インターフェイスプロパティはアクセサメソッドを宣言します Get と Set （実装コードなし）。したがって、 インターフェース また、それらのインターフェースプロパティを継承します。 インターフェイスのデバイスツリーにインターフェイスプロパティを追加できます。次に、インターフェイスがアクセサメソッドで拡張されます Get と Set 。 The Get アクセサーは読み取りアクセス用です。 The Set アクセサは書き込みアクセス用です。不要なアクセサーは削除できます。クリック プロジェクト→オブジェクトの追加→インターフェースプロパティ 。アクセサーを追加します。 The インターフェイスプロパティの追加 ダイアログが開きます。 例 インターフェイスプロパティの宣言と実装 Literal_A インターフェース itf_A プロパティがあります Literal_A アクセサメソッドを使用 Get と Set 。 機能ブロック fb_A1 と fb_A2 インターフェイスを実装する itf_A したがって、そのインターフェイスプロパティを継承します。各FBには独自の実装があります。 インターフェース itf_A INTERFACE itf_A\nVAR\nEND_VAR\nPROPERTY Literal_A : STRING FB fb_A1 FUNCTION_BLOCK fb_A1 IMPLEMENTS itf_A\nVAR\n str_1 : STRING;\n str_2 : STRING;\n iCnt : INT;\nEND_VAR\niCnt := iCnt + 1;\n\nstr_1 := 'Function block A1'; アクセサー fb_A1.Literal_A.Get VAR\nEND_VAR\nLiteral_A := CONCAT (str_1,' and property.'); アクセサー fb_A1.Literal_A.Set VAR\nEND_VAR\nstr_2 := Literal_A; FB fb_A2 FUNCTION_BLOCK fb_A2 IMPLEMENTS itf_A\nVAR\n str_1 : STRING;\n str_2 : STRING;\n iCnt : INT;\nEND_VAR\n\niCnt := iCnt + 1;\nstr_1 := 'Function block A2'; アクセサー fb_A2.Literal_A.Get VAR\nEND_VAR\nLiteral_A := str_1; アクセサー fb_A2.Literal_A.Set VAR\nEND_VAR\nstr_2 := Literal_A; プログラム PLC_PRG PROGRAM PLC_PRG\nVAR\n iCnt : INT;\n my_1 : fb_A1;\n my_2 : fb_A2;\n strName_1 : STRING;\n strName_2: STRING;\nEND_VAR\n\niCnt := iCnt + 1;\nmy_1();\nmy_2();\nstrName_1:= my_1.Literal_A;\nstrName_2:= my_2.Literal_A;\nmy_1.Literal_A := 'Hello 1';\nmy_2.Literal_A := 'World 2'; これにより、次の監視が行われます。 PLC_PRG アプリケーションの実行時： " }, 
{ "title" : "オブジェクト：プロパティ ", 
"url" : "_cds_obj_property.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：プロパティ ", 
"snippet" : "財産 シンボル： キーワード： PROPERTY プロパティは、IEC 61131-3標準の拡張であり、オブジェクト指向プログラミング用のツールです。 プロパティは、データへの外部アクセスを可能にし、同時にフィルターとして機能するため、データのカプセル化に使用されます。この目的のために、プロパティはアクセサメソッドを提供します Get と Set これにより、プロパティの下にあるインスタンスのデータへの読み取りおよび書き込みアクセスが可能になります。 プログラム、関数ブロック、またはグローバル変数リストの下にアクセサメソッドを使用してプロパティを追加できます。クリック プロジェクト→オブジェク...", 
"body" : "財産 シンボル： キーワード： PROPERTY プロパティは、IEC 61131-3標準の拡張であり、オブジェクト指向プログラミング用のツールです。 プロパティは、データへの外部アクセスを可能にし、同時にフィルターとして機能するため、データのカプセル化に使用されます。この目的のために、プロパティはアクセサメソッドを提供します Get と Set これにより、プロパティの下にあるインスタンスのデータへの読み取りおよび書き込みアクセスが可能になります。 プログラム、関数ブロック、またはグローバル変数リストの下にアクセサメソッドを使用してプロパティを追加できます。クリック プロジェクト→オブジェクトの追加→プロパティ 開くには プロパティを追加 ダイアログ。 あなたは追加することができます インターフェイスプロパティ インターフェイスの下。 POUの下に挿入されたプロパティをコピーしてインターフェイスの下に追加するか、プロパティをそこに移動すると、含まれている実装が自動的に削除されます。 オンラインモードでのプロパティの監視 以下 プラグマ オンラインモードでプロパティを監視するために提供されています。それらをプロパティ定義の一番上の位置に挿入します。 {attribute 'monitoring' := 'variable'} プロパティにアクセスするたびに、 CODESYS 実際の値を変数に保存し、この変数の値を表示します。コード内でプロパティへのアクセスが行われなくなると、この値は古くなる可能性があります。 {attribute 'monitoring' := 'call'} 毎回 値が表示され、 CODESYS のコードを呼び出します Get アクセサー。このコードに副作用が含まれている場合、モニタリングは副作用を実行します。 以下の機能を使用して、プロパティを監視できます。 インラインモニタリング 要件： インラインモニタリングを有効にする オプションが選択されている テキストエディタ のカテゴリ オプション ダイアログ。 ウォッチリスト " }, 
{ "title" : "ダイアログ：プロパティの追加 ", 
"url" : "_cds_obj_property.html#UUID-9c407fa5-d8b8-4172-1c22-5219eeec8317_id_b08bdbd0d86c0a8640e00400511_id_bf40a4d8ef1988a5c0a864636ff3b754", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：プロパティ \/ ダイアログ：プロパティの追加 ", 
"snippet" : "関数 ：ダイアログを閉じたときに、選択したPOUの下に新しいプロパティを作成します。 電話 ： プロジェクト→オブジェクトの追加→プロパティ ;コンテキストメニュー 要件 ： プログラム （ PRG ）、機能ブロック（ FUNCTION_BLOCK ）、またはグローバル変数リスト（ GVL ）が選択されている POU ビューまたは デバイス 見る。 名前 プロパティの名前（識別子） 例： prop_iA リターンタイプ 戻り値のデフォルトタイプまたは構造化タイプ 例： INT 実装言語 例： 構造化テキスト（ST） アクセス指定子 データへのアクセスを制御します 公衆 または不特定 アクセスは...", 
"body" : "関数 ：ダイアログを閉じたときに、選択したPOUの下に新しいプロパティを作成します。 電話 ： プロジェクト→オブジェクトの追加→プロパティ ;コンテキストメニュー 要件 ： プログラム （ PRG ）、機能ブロック（ FUNCTION_BLOCK ）、またはグローバル変数リスト（ GVL ）が選択されている POU ビューまたは デバイス 見る。 名前 プロパティの名前（識別子） 例： prop_iA リターンタイプ 戻り値のデフォルトタイプまたは構造化タイプ 例： INT 実装言語 例： 構造化テキスト（ST） アクセス指定子 データへのアクセスを制御します 公衆 または不特定 アクセスは制限されていません。 プライベート アクセスは、プログラム、機能ブロック、またはGVLに制限されています。 オブジェクトはとしてマークされます (private) POUまたはデバイスビューで。宣言にはキーワードが含まれています PRIVATE 。 保護 アクセスは、プログラム、機能ブロック、またはその派生物を含むGVLに制限されます。 オブジェクトはとしてマークされます (protected) POUまたはデバイスビューで。宣言にはキーワードが含まれています PROTECTED 。 内部 アクセスは名前空間（ライブラリ）に制限されています。 オブジェクトはとしてマークされます (internal) POUまたはデバイスビューで。宣言にはキーワードが含まれています INTERNAL 。 概要 ：プロパティに実装がなく、実装が派生FBによって提供されることを識別します 追加 選択したオブジェクトの下に、アクセサメソッドの下に新しいプロパティを追加します Get と Set 注：プロパティを選択するときに、クリックして以前に削除したアクセサーを明示的に追加することもできます オブジェクトの追加 。 " }, 
{ "title" : "編集者：プロパティ ", 
"url" : "_cds_obj_property.html#UUID-9c407fa5-d8b8-4172-1c22-5219eeec8317_id_b08bdbd0d86c0a8640e00400511_id_8fff2f78bde26345c0a8640e018af0a1", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：プロパティ \/ 編集者：プロパティ ", 
"snippet" : "エディターでデータアクセスをプログラムできます。コードには、追加のローカル変数を含めることができます。ただし、追加の入力変数または（関数やメソッドではなく）出力変数を含めることはできません。 例 機能ブロックFB_A FUNCTION_BLOCK FB_A VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR iA : INT; END_VAR iA := iA + 1; 財産 prop_iA PROPERTY PUBLIC prop_iA : INT アクセサメソッドFB_A.prop_iA.Get prop_iA := iA; アクセサメソッドFB_A.prop...", 
"body" : "エディターでデータアクセスをプログラムできます。コードには、追加のローカル変数を含めることができます。ただし、追加の入力変数または（関数やメソッドではなく）出力変数を含めることはできません。 例 機能ブロックFB_A FUNCTION_BLOCK FB_A\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\n\niA := iA + 1; 財産 prop_iA PROPERTY PUBLIC prop_iA : INT アクセサメソッドFB_A.prop_iA.Get prop_iA := iA; アクセサメソッドFB_A.prop_iA.Set iA := prop_iA; PROGRAM PLC_PRG\nVAR\n fbA : FB_A;\n iVar: INT;\nEND_VAR\n\nfbA();\nIF fbA.prop_iA > 500 THEN\n fbA.prop_iA := 0;\nEND_IF\niVar := fbA.prop_iA; " }, 
{ "title" : "アクセサの取得と設定 ", 
"url" : "_cds_obj_property.html#UUID-9c407fa5-d8b8-4172-1c22-5219eeec8317_id_b08bdbd0d86c0a8640e00400511_id_d1b96520c2a88023c0a8640e00496635", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：プロパティ \/ アクセサの取得と設定 ", 
"snippet" : "の呼び出し Set アクセサはプロパティに書き込まれます。その後、入力パラメータと同じように使用されます。 Getアクセサーが呼び出されると、プロパティが読み取られます。出力パラメータと同じように使用されます。いずれの場合も、アクセス修飾子（修飾子）によってアクセスが制限されます。その結果、オブジェクトはそれに応じて識別されます。 プロパティが読み取り専用または書き込み専用としてアクセスされる場合、不要なアクセサーを削除できます。 プロパティを選択してクリックすると、アクセサを明示的に追加できます オブジェクトの追加 。ダイアログが開きます。 Getアクセサーを追加 また セットアクセサーを追...", 
"body" : "の呼び出し Set アクセサはプロパティに書き込まれます。その後、入力パラメータと同じように使用されます。 Getアクセサーが呼び出されると、プロパティが読み取られます。出力パラメータと同じように使用されます。いずれの場合も、アクセス修飾子（修飾子）によってアクセスが制限されます。その結果、オブジェクトはそれに応じて識別されます。 プロパティが読み取り専用または書き込み専用としてアクセスされる場合、不要なアクセサーを削除できます。 プロパティを選択してクリックすると、アクセサを明示的に追加できます オブジェクトの追加 。ダイアログが開きます。 Getアクセサーを追加 また セットアクセサーを追加 。そこで、実装言語とアクセスを設定できます。 ダイアログ：Get（Set）アクセサーの追加 実装言語 例： 構造化テキスト（ST） アクセス指定子 宣言部分の修飾子 PUBLIC または不特定 アクセスは制限されていません。 PRIVATE アクセスは、プログラム、機能ブロック、またはGVLに制限されています。 オブジェクトはとしてマークされます (private) POUまたはデバイスビューで。宣言にはキーワードが含まれています。 PROTECTED プロパティへのアクセスは、プログラム、機能ブロック、またはGVLとその派生物に制限されています。宣言にはキーワードが含まれています。 オブジェクトはとしてマークされます (protected) POUまたはデバイスビューで。 INTERNAL メソッドへのアクセスは、名前空間（ライブラリ）に制限されています。 オブジェクトはとしてマークされます (internal) POUまたはデバイスビューで。宣言にはキーワードが含まれています。 追加 アクセサメソッドを追加します Get また Set 選択したプロパティの下。 " }, 
{ "title" : "継承POUを生成する際の入力サポート ", 
"url" : "_cds_obj_property.html#UUID-9c407fa5-d8b8-4172-1c22-5219eeec8317_UUID-e3a7d561-c8bd-ff0c-4eda-2e6419e8e10f", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：プロパティ \/ 継承POUを生成する際の入力サポート ", 
"snippet" : "オブジェクト指向プログラミングを行い、継承を使用する場合（ EXTENDS  キーワード）POUの場合、次のようにサポートを受けることができます。 ベースPOUから派生したPOUの下にアクション、プロパティ、メソッド、またはトランジションを挿入すると、 追加 … ダイアログが開きます。次に、名前の入力フィールドがリストボックスに拡張されます。リストボックスには、ベースPOUで使用可能なアクション、プロパティ、メソッド、またはトランジションからの有効な選択が含まれています。これで、たとえば、ベースPOUのメソッドを簡単に受け入れて、それをPOUの派生関数に適合させることができます。 アクセス修飾...", 
"body" : "オブジェクト指向プログラミングを行い、継承を使用する場合（ EXTENDS  キーワード）POUの場合、次のようにサポートを受けることができます。 ベースPOUから派生したPOUの下にアクション、プロパティ、メソッド、またはトランジションを挿入すると、 追加 … ダイアログが開きます。次に、名前の入力フィールドがリストボックスに拡張されます。リストボックスには、ベースPOUで使用可能なアクション、プロパティ、メソッド、またはトランジションからの有効な選択が含まれています。これで、たとえば、ベースPOUのメソッドを簡単に受け入れて、それをPOUの派生関数に適合させることができます。 アクセス修飾子を使用したメソッドとプロパティ PRIVATE それらも継承されないため、ここにはリストされていません。アクセス修飾子を使用したメソッドとプロパティ PUBLIC 派生したPOUに受け入れると、自動的に空白のアクセス修飾子フィールドを取得します。これは、機能的には同じことを意味します。 詳細については、以下を参照してください。 財産、 方法、 遷移、 アクション、 例 " }, 
{ "title" : "オブジェクト: アクション ", 
"url" : "_cds_obj_action.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト: アクション ", 
"snippet" : "アクション シンボル: ファンクションブロックまたはプログラムにアクションを追加できます。すべてのアクションには名前があります。 アクションオブジェクトは追加のコードを実装します。これらのコードは、上位POUの基本実装とは異なる言語でプログラムできます。アクションは多くの場合 SFC で実装されます。アクションには独自の変数宣言はありません。上位のベース実装のデータを処理し、その変数 () を使用します VAR 、 VAR_INPUT 、 VAR_OUTPUT 、 VAR_IN_OUT )。 オブジェクト指向プログラミングでは、ファンクションブロックとその下位アクションを継承することができます...", 
"body" : "アクション シンボル: ファンクションブロックまたはプログラムにアクションを追加できます。すべてのアクションには名前があります。 アクションオブジェクトは追加のコードを実装します。これらのコードは、上位POUの基本実装とは異なる言語でプログラムできます。アクションは多くの場合 SFC で実装されます。アクションには独自の変数宣言はありません。上位のベース実装のデータを処理し、その変数 () を使用します VAR 、 VAR_INPUT 、 VAR_OUTPUT 、 VAR_IN_OUT )。 オブジェクト指向プログラミングでは、ファンクションブロックとその下位アクションを継承することができます。 詳細については、以下を参照してください。 継承POUを生成する際の入力サポートコール 構文: <program name> . <action name> ( <parameter passing> ) または <name of function block instance> . <action name> ( <parameter passing> ) <program name> . [オプション] プログラムの名前を含むインスタンスパス プログラムの対応する基本実装でアクションが呼び出される場合は、アクション名を指定すれば十分です。 <name of function block instance> . [オプション] ファンクションブロックインスタンスの名前を含むインスタンスパス ファンクションブロックの対応する基本実装でアクションが呼び出される場合は、アクション名を指定すれば十分です。 <action name> 必須 アクションの名前 ( <parameter passing> ) [オプション] パラメーターを渡す場合、引数はそれぞれの関数ブロックと同じ方法で入力変数と出力変数に渡すことができます。 見る ファンクションブロックアクションで使用可能な変数は、上位POUで宣言されます。同様に、アクションが呼び出されたときにパラメーターを渡すことができます。変数 ( VAR 、 VAR_INPUT 、 VAR_OUTPUT 、 VAR_IN_OUT (メソッド呼び出しとは対照的に) 上位プログラムの) またはファンクションブロックインスタンスにアクセスできます。 そのため、グラフィカルエディターでアクションが呼び出されると、ベース POU のすべての I\/O が表示されます。 例 を呼び出す リセット アクション ( Counter 別の POU からのファンクションブロック)。 ファンクションブロックのインスタンス化 PROGRAM PLC_PRG\nVAR\n Inst : Counter;\nEND_VAR を呼び出す リセット IL でのアクション CAL Inst.Reset(In := FALSE)\nLD Inst.Out\nST ERG を呼び出す リセット ST でのアクション Inst.Reset(In := FALSE);\nErg := Inst.out; を呼び出す リセット FBD のアクション 例 ファンクションブロックの宣言 FB_Test FUNCTION_BLOCK FB_Test\nVAR_INPUT\n i_xTest : BOOL;\n i_lrTest : LREAL;\nEND_VAR\nVAR_OUTPUT\n q_xTest : BOOL;\n q_lrTest : LREAL;\nEND_VAR\nVAR\n xSet : BOOL;\n xReset : BOOL;\n SR_0 : SR;\n R_TRIG_0 : R_TRIG;\nEND_VAR の実装 Act_Text 各ファンクションブロックの I\/O にアクセスできるアクション (FBD 内) アクションはSFC実装言語でよく使用されます。 " }, 
{ "title" : "アクションを挿入 ", 
"url" : "_cds_obj_action.html#UUID-d3c3a161-09fa-9c3d-d5e0-951656fa2f3d_section-idm234809879408146", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト: アクション \/ アクションを挿入 ", 
"snippet" : "を追加 アクション 関数ブロックまたはプログラムに プロジェクト → [オブジェクトを追加] → アクション 開いたダイアログで、コマンドを実行し、新しいアクションのプロパティを定義します。 アクションを追加 [名前] アクションの名前 実装言語 使用可能な実装言語のリストボックスから選択...", 
"body" : "を追加 アクション 関数ブロックまたはプログラムに プロジェクト → [オブジェクトを追加] → アクション 開いたダイアログで、コマンドを実行し、新しいアクションのプロパティを定義します。 アクションを追加 [名前] アクションの名前 実装言語 使用可能な実装言語のリストボックスから選択 " }, 
{ "title" : "オブジェクト：移行 ", 
"url" : "_cds_obj_transition.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：移行 ", 
"snippet" : "遷移 シンボル： このオブジェクトは、SFCで実装されたプログラムブロックの遷移要素として使用できます。 詳細については、次を参照してください。 SFC 要素: ステップとトランジション...", 
"body" : "遷移 シンボル： このオブジェクトは、SFCで実装されたプログラムブロックの遷移要素として使用できます。 詳細については、次を参照してください。 SFC 要素: ステップとトランジション " }, 
{ "title" : "継承POUを生成する際の入力サポート ", 
"url" : "_cds_obj_transition.html#UUID-ec6c8ad0-aa77-27a0-2637-e1d57601e639_UUID-e3a7d561-c8bd-ff0c-4eda-2e6419e8e10f", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POU \/ オブジェクト：移行 \/ 継承POUを生成する際の入力サポート ", 
"snippet" : "オブジェクト指向プログラミングを行い、継承を使用する場合（ EXTENDS  キーワード）POUの場合、次のようにサポートを受けることができます。 ベースPOUから派生したPOUの下にアクション、プロパティ、メソッド、またはトランジションを挿入すると、 追加 … ダイアログが開きます。次に、名前の入力フィールドがリストボックスに拡張されます。リストボックスには、ベースPOUで使用可能なアクション、プロパティ、メソッド、またはトランジションからの有効な選択が含まれています。これで、たとえば、ベースPOUのメソッドを簡単に受け入れて、それをPOUの派生関数に適合させることができます。 アクセス修飾...", 
"body" : "オブジェクト指向プログラミングを行い、継承を使用する場合（ EXTENDS  キーワード）POUの場合、次のようにサポートを受けることができます。 ベースPOUから派生したPOUの下にアクション、プロパティ、メソッド、またはトランジションを挿入すると、 追加 … ダイアログが開きます。次に、名前の入力フィールドがリストボックスに拡張されます。リストボックスには、ベースPOUで使用可能なアクション、プロパティ、メソッド、またはトランジションからの有効な選択が含まれています。これで、たとえば、ベースPOUのメソッドを簡単に受け入れて、それをPOUの派生関数に適合させることができます。 アクセス修飾子を使用したメソッドとプロパティ PRIVATE それらも継承されないため、ここにはリストされていません。アクセス修飾子を使用したメソッドとプロパティ PUBLIC 派生したPOUに受け入れると、自動的に空白のアクセス修飾子フィールドを取得します。これは、機能的には同じことを意味します。 詳細については、以下を参照してください。 財産、 方法、 遷移、 アクション、 例 " }, 
{ "title" : "オブジェクト：暗黙的チェックのPOU ", 
"url" : "_cds_f_obj_pous_implicit_check.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU ", 
"snippet" : "暗黙的なチェックのPOU これらの特別なPOUをアプリケーションに追加して、暗黙的な監視機能を提供できます。実行時に、これらの関数は、配列またはサブ範囲タイプの制限、ポインターアドレスの有効性、およびゼロ除算をチェックします。注：このオプションは、特別な暗黙のライブラリによって、これらの種類の監視ブロックがすでに装備されているデバイスでは無効にできます。 The オブジェクトの追加→暗黙的なチェックのためのPOU コマンドを使用して、アプリケーションに追加します。コマンドは 暗黙のチェック用のPOUを追加する 監視機能の種類を選択できるダイアログ（下の表を参照）。監視機能によっては、実装コード...", 
"body" : "暗黙的なチェックのPOU これらの特別なPOUをアプリケーションに追加して、暗黙的な監視機能を提供できます。実行時に、これらの関数は、配列またはサブ範囲タイプの制限、ポインターアドレスの有効性、およびゼロ除算をチェックします。注：このオプションは、特別な暗黙のライブラリによって、これらの種類の監視ブロックがすでに装備されているデバイスでは無効にできます。 The オブジェクトの追加→暗黙的なチェックのためのPOU コマンドを使用して、アプリケーションに追加します。コマンドは 暗黙のチェック用のPOUを追加する 監視機能の種類を選択できるダイアログ（下の表を参照）。監視機能によっては、実装コードを編集するか、自分で作成する必要があります。 複数の包含を防ぐために、すでに挿入されている監視機能は、 暗黙のチェック用のPOUを追加する ダイアログ。 詳細については、以下を参照してください。 暗黙のチェックにビルディングブロックを使用する監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 暗黙の監視機能を削除した後（例： Check Bounds ）プロジェクトから、ダウンロードのみが可能であり、オンラインでの変更はできません。対応するメッセージが表示されます。 デフォルトでは、 CODESYS アプリケーションで使用されるライブラリからの関数ブロックの暗黙的なチェックを実行しません。ただし、を開くと、チェックをライブラリに拡張できます。 プロパティ アプリケーションのダイアログとコンパイラ定義の指定 checks_in_libs の中に コンパイラ定義 上のフィールド 建てる タブ。この定義は実装ライブラリに影響します（ *.library ）のみ、保護されていないライブラリ（ *.compiled-library ）。 「no_check」属性を使用して、プロジェクト内の特別なPOUのチェックを無効にすることができます。 利用可能な機能 監視機能 タイプ CheckBounds 境界チェック バインドされた違反の適切な処理。このような処理には、フラグの設定やフィールドインデックスの変更が含まれます CheckDivDInt 除算チェック ： ゼロによる除算を回避するために除数の値を監視します CheckDivLInt CheckDivReal CheckDivLReal CheckRangeSigned 範囲チェック ： ランタイムモードでサブレンジタイプの範囲制限を監視します データ型に有効 DINT \/ UDINT CheckRangeUnsigned CheckLRangeSigned Lレンジチェック ： ランタイムモードでサブレンジタイプの範囲制限を監視します データ型に有効 LINT \/ ULINT CheckLRangeUnsigned CheckPointer ポインタチェック この関数に実装コードを完全に入力するのはあなたの責任です。 「POU'CheckPointer '」のヘルプページを参照してください。この関数は、渡されたポインタが有効なメモリアドレスを参照しているかどうか、および参照されているメモリ領域の方向がポインタが参照している変数タイプと一致するかどうかを監視する必要があります。両方の条件が満たされると、ポインタが返されます。そうでない場合は、 CheckPointer 適切なエラー処理を完了する必要があります。 CheckPointer タイプの変数と同じ方法で監視します REFERENCE TO 。 " }, 
{ "title" : "POU：CheckBounds ", 
"url" : "_cds_obj_pou_checkbounds.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU \/ POU：CheckBounds ", 
"snippet" : "CheckBounds この監視機能のタスクは、バインドされた違反を適切に処理することです。違反に対する反応の例には、エラーフラグの設定や配列インデックスの値の変更が含まれます。チェックは、1つの変数配列インデックスに対してのみ実行されます。定数配列インデックスが正しくないと、コンパイラエラーが発生します。 CODESYS 値がに割り当てられたときに暗黙的に関数を呼び出します 配列 変数。 詳細については、以下を参照してください。 暗黙のチェックにビルディングブロックを使用する、 暗黙のチェックにビルディングブロックを使用する関数を挿入すると、宣言部分と実装部分で自動的に生成されたコードを受け...", 
"body" : "CheckBounds この監視機能のタスクは、バインドされた違反を適切に処理することです。違反に対する反応の例には、エラーフラグの設定や配列インデックスの値の変更が含まれます。チェックは、1つの変数配列インデックスに対してのみ実行されます。定数配列インデックスが正しくないと、コンパイラエラーが発生します。 CODESYS 値がに割り当てられたときに暗黙的に関数を呼び出します 配列 変数。 詳細については、以下を参照してください。 暗黙のチェックにビルディングブロックを使用する、 暗黙のチェックにビルディングブロックを使用する関数を挿入すると、宣言部分と実装部分で自動的に生成されたコードを受け取ります。下記参照。 監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 宣言部分 \/\/ Automatisch erzeugter Code : NICHT EDITIEREN\nFUNCTION CheckBounds : DINT\nVAR_INPUT\n index, lower, upper: DINT;\nEND_VAR 実装 \/\/ Automatisch erzeugter Code: Es handelt sich hierbei um einen Implementierungsvorschlag.\nIF index < lower THEN\n CheckBounds := lower;\nELSIF index > upper THEN\n CheckBounds := upper;\nELSE\n CheckBounds := index;\nEND_IF\n\n(* It is also possible to set a breakpoint, log messages or e.g. to halt on an exception:\nAdd CmpApp.library, SysExcept.library and SysTypes2_Itf as newest.\nDeclaration:\nVAR\n _pApp : POINTER TO CmpApp.APPLICATION;\n _result : SysTypes.RTS_IEC_RESULT;\nEND_VAR\n\nImplementation:\n_pApp := AppGetCurrent(pResult:=_result);\nIF index < lower THEN\n CheckBounds := lower;\n IF _pApp <> 0 THEN\n AppGenerateException(pApp:=_pApp, ulException:=RtsExceptions.RTSEXCPT_ARRAYBOUNDS);\n END_IF\nELSIF index > upper THEN\n CheckBounds := upper;\n IF _pApp <> 0 THEN\n AppGenerateException(pApp:=_pApp, ulException:=RtsExceptions.RTSEXCPT_ARRAYBOUNDS);\n END_IF\nELSE\n CheckBounds := index;\nEND_IF\n*) いつ CheckBounds 関数が呼び出されると、次の入力パラメーターを受け取ります。 index ：配列要素のインデックス lower ：配列範囲の下限 upper ：配列範囲の上限 戻り値は、有効な範囲内にある限り、配列要素のインデックスです。そうでない場合は、 CODESYS 違反したしきい値に応じて、上限または下限のいずれかを返します。 例：定義された配列境界外の配列へのアクセスの修正 以下のサンプルプログラムでは、インデックスが定義された下限を下回っています。 a 配列。 PROGRAM PLC_PRG\nVAR\n a: ARRAY[0..7] OF BOOL;\n b: INT:=10;\nEND_VAR\n\na[b]:=TRUE; この例では、 CheckBounds 機能の原因 a 配列範囲インデックスの上限をに変更するには 10 。値 TRUE 次に要素に割り当てられます a[7] 。このようにして、関数は有効な配列範囲外の配列アクセスを修正します。 例：配列の制限に違反した場合の例外の出力。 アプリケーションのライブラリマネージャーに次のライブラリを追加します。 CmpApp.library と SysExcept.library プレースホルダーライブラリとして SysTypes2_Itfs.library と 常に最新バージョン 追加する CheckBounds アプリケーションの下のオブジェクトを作成し、以下に示すように指定されたコードを変更します。 宣言部分 FUNCTION CheckBounds : DINT\nVAR_INPUT\n index, lower, upper: DINT;\nEND_VAR\nVAR\n _pApp : POINTER TO CmpApp.APPLICATION;\n _Result : ISystypes2.RTS_IEC_RESULT;\nEND_VAR 実装部分 \/\/ Automatisch erzeugter Code: Es handelt sich hierbei um einen Implementierungsvorschlag.\n_pApp := AppGetCurrent(pResult := _Result);\nIF index < lower THEN\n CheckBounds := lower;\n IF _pApp <> 0 THEN\n AppGenerateException(pApp := _pApp, ulException := RtsExceptions.RTSEXCPT_ARRAYBOUNDS);\n END_IF\nELSIF index > upper THEN\n CheckBounds := upper;\n IF _pApp <> 0 THEN\n AppGenerateException(pApp:=_pApp, ulException:=RtsExceptions.RTSEXCPT_ARRAYBOUNDS);\n END_IF\nELSE\n CheckBounds := index;\nEND_IF プログラム MAIN_PRG 以下に示す内容のアプリケーションの下にあるオブジェクト。 PROGRAM MAIN_PRG\nVAR\n xInit : BOOL;\n arData : ARRAY[0..7] OF BYTE;\n i : INT;\n dwAdr : DWORD;\nEND_VAR\n\nIF NOT xInit THEN\n \/\/ Erforderlich für CheckBounds\n xInit := TRUE;\nEND_IF\n\n\/\/ Setze i auf einen Wert > 7 oder < 0\n\/\/ Generiert eine Exception in CheckBounds, Benutzerdefiniert\narData[i] := 11; このアプリケーションをロードして起動すると、配列の境界に違反すると「例外」がスローされます。で処理が停止します CheckBounds エラーの種類を検出できるようにします。 " }, 
{ "title" : "POU：CheckDivInt ", 
"url" : "_cds_obj_pou_checkdivint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU \/ POU：CheckDivInt ", 
"snippet" : "CheckDivInt...", 
"body" : "CheckDivInt " }, 
{ "title" : "「0」による除算を防止する機能： CheckDivInt, CheckDivLint, CheckDivReal, and CheckDivLReal ", 
"url" : "_cds_obj_pou_checkdivint.html#UUID-072cf6e7-5009-f5d9-a6f2-cfb7ba93eb0e_UUID-4cc55957-06e7-1250-5de0-d97f7051f0e6", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU \/ POU：CheckDivInt \/ 「0」による除算を防止する機能： CheckDivInt, CheckDivLint, CheckDivReal, and CheckDivLReal ", 
"snippet" : "ゼロ除算を防ぐために、関数を使用できます CheckDivInt 、 CheckDivLint 、 CheckDivReal 、 と CheckDivLReal 。これらの関数をアプリケーションに含めると、コード内の各除算操作の前に呼び出されます。 詳細については、以下を参照してください。 暗黙のチェックにビルディングブロックを使用する、 暗黙的なチェックのPOU監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 CheckDivRealのデフォルトの実装： 宣言部分： \/\/ Automatisch erzeugter Code...", 
"body" : "ゼロ除算を防ぐために、関数を使用できます CheckDivInt 、 CheckDivLint 、 CheckDivReal 、 と CheckDivLReal 。これらの関数をアプリケーションに含めると、コード内の各除算操作の前に呼び出されます。 詳細については、以下を参照してください。 暗黙のチェックにビルディングブロックを使用する、 暗黙的なチェックのPOU監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 CheckDivRealのデフォルトの実装： 宣言部分： \/\/ Automatisch erzeugter Code : NICHT EDITIEREN\nFUNCTION CheckDivReal : REAL\nVAR_INPUT\n divisor:REAL;\nEND_VAR 実装部分： \/\/ Automatisch erzeugter Code: Es handelt sich hierbei um einen Implementierungsvorschlag.\nIF divisor = 0 THEN\n CheckDivReal:=1;\nELSE\n CheckDivReal:=divisor;\nEND_IF; The DIV 演算子は、の出力を使用します CheckDivReal 除数として機能します。以下のサンプルプログラムでは、 CheckDivReal による除算を防ぎます 0 除数の暗黙の値を変更することによって d 「0」から 1 除算が実行される前。したがって、除算の結果は次のようになります。 799 。 PROGRAM PLC_PRG\nVAR\n erg:REAL;\n v1:REAL:=799;\n d:REAL:=0;\nEND_VAR\nerg:= v1 \/ d; " }, 
{ "title" : "POU：CheckDivLInt ", 
"url" : "_cds_obj_pou_checkdivlint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU \/ POU：CheckDivLInt ", 
"snippet" : "CheckDivLInt...", 
"body" : "CheckDivLInt " }, 
{ "title" : "「0」による除算を防止する機能： CheckDivInt, CheckDivLint, CheckDivReal, and CheckDivLReal ", 
"url" : "_cds_obj_pou_checkdivlint.html#UUID-99e0b883-c84e-9caf-1987-091b2733937f_UUID-4cc55957-06e7-1250-5de0-d97f7051f0e6", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU \/ POU：CheckDivLInt \/ 「0」による除算を防止する機能： CheckDivInt, CheckDivLint, CheckDivReal, and CheckDivLReal ", 
"snippet" : "ゼロ除算を防ぐために、関数を使用できます CheckDivInt 、 CheckDivLint 、 CheckDivReal 、 と CheckDivLReal 。これらの関数をアプリケーションに含めると、コード内の各除算操作の前に呼び出されます。 詳細については、以下を参照してください。 暗黙のチェックにビルディングブロックを使用する、 暗黙的なチェックのPOU監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 CheckDivRealのデフォルトの実装： 宣言部分： \/\/ Automatisch erzeugter Code...", 
"body" : "ゼロ除算を防ぐために、関数を使用できます CheckDivInt 、 CheckDivLint 、 CheckDivReal 、 と CheckDivLReal 。これらの関数をアプリケーションに含めると、コード内の各除算操作の前に呼び出されます。 詳細については、以下を参照してください。 暗黙のチェックにビルディングブロックを使用する、 暗黙的なチェックのPOU監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 CheckDivRealのデフォルトの実装： 宣言部分： \/\/ Automatisch erzeugter Code : NICHT EDITIEREN\nFUNCTION CheckDivReal : REAL\nVAR_INPUT\n divisor:REAL;\nEND_VAR 実装部分： \/\/ Automatisch erzeugter Code: Es handelt sich hierbei um einen Implementierungsvorschlag.\nIF divisor = 0 THEN\n CheckDivReal:=1;\nELSE\n CheckDivReal:=divisor;\nEND_IF; The DIV 演算子は、の出力を使用します CheckDivReal 除数として機能します。以下のサンプルプログラムでは、 CheckDivReal による除算を防ぎます 0 除数の暗黙の値を変更することによって d 「0」から 1 除算が実行される前。したがって、除算の結果は次のようになります。 799 。 PROGRAM PLC_PRG\nVAR\n erg:REAL;\n v1:REAL:=799;\n d:REAL:=0;\nEND_VAR\nerg:= v1 \/ d; " }, 
{ "title" : "POU：CheckDivReal ", 
"url" : "_cds_obj_pou_checkdivreal.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU \/ POU：CheckDivReal ", 
"snippet" : "CheckDivReal...", 
"body" : "CheckDivReal " }, 
{ "title" : "「0」による除算を防止する機能： CheckDivInt, CheckDivLint, CheckDivReal, and CheckDivLReal ", 
"url" : "_cds_obj_pou_checkdivreal.html#UUID-c703e521-3496-9988-34a7-a889e5d5836b_UUID-4cc55957-06e7-1250-5de0-d97f7051f0e6", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU \/ POU：CheckDivReal \/ 「0」による除算を防止する機能： CheckDivInt, CheckDivLint, CheckDivReal, and CheckDivLReal ", 
"snippet" : "ゼロ除算を防ぐために、関数を使用できます CheckDivInt 、 CheckDivLint 、 CheckDivReal 、 と CheckDivLReal 。これらの関数をアプリケーションに含めると、コード内の各除算操作の前に呼び出されます。 詳細については、以下を参照してください。 暗黙のチェックにビルディングブロックを使用する、 暗黙的なチェックのPOU監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 CheckDivRealのデフォルトの実装： 宣言部分： \/\/ Automatisch erzeugter Code...", 
"body" : "ゼロ除算を防ぐために、関数を使用できます CheckDivInt 、 CheckDivLint 、 CheckDivReal 、 と CheckDivLReal 。これらの関数をアプリケーションに含めると、コード内の各除算操作の前に呼び出されます。 詳細については、以下を参照してください。 暗黙のチェックにビルディングブロックを使用する、 暗黙的なチェックのPOU監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 CheckDivRealのデフォルトの実装： 宣言部分： \/\/ Automatisch erzeugter Code : NICHT EDITIEREN\nFUNCTION CheckDivReal : REAL\nVAR_INPUT\n divisor:REAL;\nEND_VAR 実装部分： \/\/ Automatisch erzeugter Code: Es handelt sich hierbei um einen Implementierungsvorschlag.\nIF divisor = 0 THEN\n CheckDivReal:=1;\nELSE\n CheckDivReal:=divisor;\nEND_IF; The DIV 演算子は、の出力を使用します CheckDivReal 除数として機能します。以下のサンプルプログラムでは、 CheckDivReal による除算を防ぎます 0 除数の暗黙の値を変更することによって d 「0」から 1 除算が実行される前。したがって、除算の結果は次のようになります。 799 。 PROGRAM PLC_PRG\nVAR\n erg:REAL;\n v1:REAL:=799;\n d:REAL:=0;\nEND_VAR\nerg:= v1 \/ d; " }, 
{ "title" : "POU：CheckDivLReal ", 
"url" : "_cds_obj_pou_checkdivlreal.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU \/ POU：CheckDivLReal ", 
"snippet" : "CheckDivLReal...", 
"body" : "CheckDivLReal " }, 
{ "title" : "「0」による除算を防止する機能： CheckDivInt, CheckDivLint, CheckDivReal, and CheckDivLReal ", 
"url" : "_cds_obj_pou_checkdivlreal.html#UUID-84677e37-4182-0e45-f4bf-d23f7f7919b1_UUID-4cc55957-06e7-1250-5de0-d97f7051f0e6", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU \/ POU：CheckDivLReal \/ 「0」による除算を防止する機能： CheckDivInt, CheckDivLint, CheckDivReal, and CheckDivLReal ", 
"snippet" : "ゼロ除算を防ぐために、関数を使用できます CheckDivInt 、 CheckDivLint 、 CheckDivReal 、 と CheckDivLReal 。これらの関数をアプリケーションに含めると、コード内の各除算操作の前に呼び出されます。 詳細については、以下を参照してください。 暗黙のチェックにビルディングブロックを使用する、 暗黙的なチェックのPOU監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 CheckDivRealのデフォルトの実装： 宣言部分： \/\/ Automatisch erzeugter Code...", 
"body" : "ゼロ除算を防ぐために、関数を使用できます CheckDivInt 、 CheckDivLint 、 CheckDivReal 、 と CheckDivLReal 。これらの関数をアプリケーションに含めると、コード内の各除算操作の前に呼び出されます。 詳細については、以下を参照してください。 暗黙のチェックにビルディングブロックを使用する、 暗黙的なチェックのPOU監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 CheckDivRealのデフォルトの実装： 宣言部分： \/\/ Automatisch erzeugter Code : NICHT EDITIEREN\nFUNCTION CheckDivReal : REAL\nVAR_INPUT\n divisor:REAL;\nEND_VAR 実装部分： \/\/ Automatisch erzeugter Code: Es handelt sich hierbei um einen Implementierungsvorschlag.\nIF divisor = 0 THEN\n CheckDivReal:=1;\nELSE\n CheckDivReal:=divisor;\nEND_IF; The DIV 演算子は、の出力を使用します CheckDivReal 除数として機能します。以下のサンプルプログラムでは、 CheckDivReal による除算を防ぎます 0 除数の暗黙の値を変更することによって d 「0」から 1 除算が実行される前。したがって、除算の結果は次のようになります。 799 。 PROGRAM PLC_PRG\nVAR\n erg:REAL;\n v1:REAL:=799;\n d:REAL:=0;\nEND_VAR\nerg:= v1 \/ d; " }, 
{ "title" : "POU：CheckRangeSigned ", 
"url" : "_cds_obj_pou_checkrangesigned.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU \/ POU：CheckRangeSigned ", 
"snippet" : "CheckRangeSigned タイプDINTのサブレンジタイプの範囲制限を監視するための機能 CheckRangeSignedの例 符号付きサブレンジタイプのDINT変数への値の割り当ては、 CheckRangeSigned 。この関数は、変数宣言で定義されているように、割り当て値をサブ範囲に制限します。 STでの関数のデフォルトの実装は次のとおりです。 宣言部分： \/\/ Automatisch erzeugter Code : NICHT EDITIEREN FUNCTION CheckRangeSigned : DINT VAR_INPUT value, lower, upper: D...", 
"body" : "CheckRangeSigned タイプDINTのサブレンジタイプの範囲制限を監視するための機能 CheckRangeSignedの例 符号付きサブレンジタイプのDINT変数への値の割り当ては、 CheckRangeSigned 。この関数は、変数宣言で定義されているように、割り当て値をサブ範囲に制限します。 STでの関数のデフォルトの実装は次のとおりです。 宣言部分： \/\/ Automatisch erzeugter Code : NICHT EDITIEREN\nFUNCTION CheckRangeSigned : DINT\nVAR_INPUT\n value, lower, upper: DINT;\nEND_VAR 実装： \/\/ Automatisch erzeugter Code : Es handelt sich hierbei um einen Implementierungsvorschlag.\nIF (value < lower) THEN\n CheckRangeSigned := lower;\n ELSEIF(value > upper) THEN\n CheckRangeSigned := upper;\nELSE\n CheckRangeSigned := value;\nEND_VAR " }, 
{ "title" : "監視範囲の制限 ", 
"url" : "_cds_obj_pou_checkrangesigned.html#UUID-966e7cc4-b54e-471f-136b-0a28b2c4f30a_UUID-2f40e0a8-a491-b3cc-9231-f5c35a224dd7", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU \/ POU：CheckRangeSigned \/ 監視範囲の制限 ", 
"snippet" : "これ 監視機能 範囲制限に対する違反を適切に処理する責任があります。違反に対する反応の例には、エラーフラグの設定や値の変更が含まれます。値がサブレンジ型変数に割り当てられると、関数は暗黙的に呼び出されます。 監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 関数が呼び出されると、次の入力パラメーターを受け取ります。 value ：サブレンジ型変数に割り当てる必要のある値 lower ：範囲下限 upper ：範囲上限 戻り値は、有効な範囲内にある限り、割り当て値です。そうでない場合は、違反したしきい値に応じて、上限または下限の...", 
"body" : "これ 監視機能 範囲制限に対する違反を適切に処理する責任があります。違反に対する反応の例には、エラーフラグの設定や値の変更が含まれます。値がサブレンジ型変数に割り当てられると、関数は暗黙的に呼び出されます。 監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 関数が呼び出されると、次の入力パラメーターを受け取ります。 value ：サブレンジ型変数に割り当てる必要のある値 lower ：範囲下限 upper ：範囲上限 戻り値は、有効な範囲内にある限り、割り当て値です。そうでない場合は、違反したしきい値に応じて、上限または下限のいずれかが返されます。 たとえば、割り当て i := 10*y 暗黙的にに置き換えられます i := CheckRangeSigned(10*y, -4095, 4095); もしも y が「1000」の場合、「10 * 1000 = 10000」はに割り当てられません i 元のコードのように。代わりに、「4095」の上限範囲が割り当てられます。 同じことが当てはまります CheckRangeUnsigned 関数。 関数が使用できない場合、実行時にそれぞれの変数のサブ範囲はチェックされません。この場合、サブレンジタイプDINT \/ UDINTの変数に-2147483648〜 + 2147483648（または0〜4294967295）の任意の値を割り当てることができます。 -9223372036854775808から+9223372036854775807（または0から18446744073709551615）の任意の値を、サブ範囲タイプLINT \/ ULINTの変数に割り当てることができます。 エリア監視機能をリンクすると、無限ループが発生する可能性があります。たとえば、FORループのカウンター変数がサブ範囲タイプであり、ループのカウント範囲が定義されたサブ範囲を終了する場合、無限ループが発生する可能性があります。 無限ループの例： VAR\n ui : UINT (0..10000);\n ...\nEND_VAR FOR ui:=0 TO 10000 DO\n ...\nEND_FOR プログラムはFORループを終了しません。 CheckRangeSigned 監視機能は防止します ui 10000より大きい値に設定されてから。 " }, 
{ "title" : "POU：CheckLRangeSigned ", 
"url" : "_cds_obj_pou_checklrangesigned.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU \/ POU：CheckLRangeSigned ", 
"snippet" : "CheckLRangeSigned タイプLINTのサブレンジタイプの範囲制限を監視するための機能 範囲監視の実装例については、のヘルプページを参照してください。 CheckRangeSigned 関数。...", 
"body" : "CheckLRangeSigned タイプLINTのサブレンジタイプの範囲制限を監視するための機能 範囲監視の実装例については、のヘルプページを参照してください。 CheckRangeSigned 関数。 " }, 
{ "title" : "監視範囲の制限 ", 
"url" : "_cds_obj_pou_checklrangesigned.html#UUID-f6d1d4fb-cc77-0cb6-74fc-fe5983251696_UUID-2f40e0a8-a491-b3cc-9231-f5c35a224dd7", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU \/ POU：CheckLRangeSigned \/ 監視範囲の制限 ", 
"snippet" : "これ 監視機能 範囲制限に対する違反を適切に処理する責任があります。違反に対する反応の例には、エラーフラグの設定や値の変更が含まれます。値がサブレンジ型変数に割り当てられると、関数は暗黙的に呼び出されます。 監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 関数が呼び出されると、次の入力パラメーターを受け取ります。 value ：サブレンジ型変数に割り当てる必要のある値 lower ：範囲下限 upper ：範囲上限 戻り値は、有効な範囲内にある限り、割り当て値です。そうでない場合は、違反したしきい値に応じて、上限または下限の...", 
"body" : "これ 監視機能 範囲制限に対する違反を適切に処理する責任があります。違反に対する反応の例には、エラーフラグの設定や値の変更が含まれます。値がサブレンジ型変数に割り当てられると、関数は暗黙的に呼び出されます。 監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 関数が呼び出されると、次の入力パラメーターを受け取ります。 value ：サブレンジ型変数に割り当てる必要のある値 lower ：範囲下限 upper ：範囲上限 戻り値は、有効な範囲内にある限り、割り当て値です。そうでない場合は、違反したしきい値に応じて、上限または下限のいずれかが返されます。 たとえば、割り当て i := 10*y 暗黙的にに置き換えられます i := CheckRangeSigned(10*y, -4095, 4095); もしも y が「1000」の場合、「10 * 1000 = 10000」はに割り当てられません i 元のコードのように。代わりに、「4095」の上限範囲が割り当てられます。 同じことが当てはまります CheckRangeUnsigned 関数。 関数が使用できない場合、実行時にそれぞれの変数のサブ範囲はチェックされません。この場合、サブレンジタイプDINT \/ UDINTの変数に-2147483648〜 + 2147483648（または0〜4294967295）の任意の値を割り当てることができます。 -9223372036854775808から+9223372036854775807（または0から18446744073709551615）の任意の値を、サブ範囲タイプLINT \/ ULINTの変数に割り当てることができます。 エリア監視機能をリンクすると、無限ループが発生する可能性があります。たとえば、FORループのカウンター変数がサブ範囲タイプであり、ループのカウント範囲が定義されたサブ範囲を終了する場合、無限ループが発生する可能性があります。 無限ループの例： VAR\n ui : UINT (0..10000);\n ...\nEND_VAR FOR ui:=0 TO 10000 DO\n ...\nEND_FOR プログラムはFORループを終了しません。 CheckRangeSigned 監視機能は防止します ui 10000より大きい値に設定されてから。 " }, 
{ "title" : "POU：CheckRangeUnsigned ", 
"url" : "_cds_obj_pou_checkrangeunsigned.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU \/ POU：CheckRangeUnsigned ", 
"snippet" : "CheckRangeUnsigned タイプUDINTのサブレンジタイプの範囲制限を監視するための機能 範囲監視の実装例については、のヘルプページを参照してください。 CheckRangeSigned 関数。...", 
"body" : "CheckRangeUnsigned タイプUDINTのサブレンジタイプの範囲制限を監視するための機能 範囲監視の実装例については、のヘルプページを参照してください。 CheckRangeSigned 関数。 " }, 
{ "title" : "監視範囲の制限 ", 
"url" : "_cds_obj_pou_checkrangeunsigned.html#UUID-8eaae037-91f2-889d-1075-c38a20b7f3b4_UUID-2f40e0a8-a491-b3cc-9231-f5c35a224dd7", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU \/ POU：CheckRangeUnsigned \/ 監視範囲の制限 ", 
"snippet" : "これ 監視機能 範囲制限に対する違反を適切に処理する責任があります。違反に対する反応の例には、エラーフラグの設定や値の変更が含まれます。値がサブレンジ型変数に割り当てられると、関数は暗黙的に呼び出されます。 監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 関数が呼び出されると、次の入力パラメーターを受け取ります。 value ：サブレンジ型変数に割り当てる必要のある値 lower ：範囲下限 upper ：範囲上限 戻り値は、有効な範囲内にある限り、割り当て値です。そうでない場合は、違反したしきい値に応じて、上限または下限の...", 
"body" : "これ 監視機能 範囲制限に対する違反を適切に処理する責任があります。違反に対する反応の例には、エラーフラグの設定や値の変更が含まれます。値がサブレンジ型変数に割り当てられると、関数は暗黙的に呼び出されます。 監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 関数が呼び出されると、次の入力パラメーターを受け取ります。 value ：サブレンジ型変数に割り当てる必要のある値 lower ：範囲下限 upper ：範囲上限 戻り値は、有効な範囲内にある限り、割り当て値です。そうでない場合は、違反したしきい値に応じて、上限または下限のいずれかが返されます。 たとえば、割り当て i := 10*y 暗黙的にに置き換えられます i := CheckRangeSigned(10*y, -4095, 4095); もしも y が「1000」の場合、「10 * 1000 = 10000」はに割り当てられません i 元のコードのように。代わりに、「4095」の上限範囲が割り当てられます。 同じことが当てはまります CheckRangeUnsigned 関数。 関数が使用できない場合、実行時にそれぞれの変数のサブ範囲はチェックされません。この場合、サブレンジタイプDINT \/ UDINTの変数に-2147483648〜 + 2147483648（または0〜4294967295）の任意の値を割り当てることができます。 -9223372036854775808から+9223372036854775807（または0から18446744073709551615）の任意の値を、サブ範囲タイプLINT \/ ULINTの変数に割り当てることができます。 エリア監視機能をリンクすると、無限ループが発生する可能性があります。たとえば、FORループのカウンター変数がサブ範囲タイプであり、ループのカウント範囲が定義されたサブ範囲を終了する場合、無限ループが発生する可能性があります。 無限ループの例： VAR\n ui : UINT (0..10000);\n ...\nEND_VAR FOR ui:=0 TO 10000 DO\n ...\nEND_FOR プログラムはFORループを終了しません。 CheckRangeSigned 監視機能は防止します ui 10000より大きい値に設定されてから。 " }, 
{ "title" : "POU：CheckLRangeUnsigned ", 
"url" : "_cds_obj_pou_checklrangeunsigned.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU \/ POU：CheckLRangeUnsigned ", 
"snippet" : "CheckLRangeUnsigned ULINTタイプのサブレンジタイプの範囲制限を監視する機能 範囲監視の実装例については、のヘルプページを参照してください。 CheckRangeSigned 関数。...", 
"body" : "CheckLRangeUnsigned ULINTタイプのサブレンジタイプの範囲制限を監視する機能 範囲監視の実装例については、のヘルプページを参照してください。 CheckRangeSigned 関数。 " }, 
{ "title" : "監視範囲の制限 ", 
"url" : "_cds_obj_pou_checklrangeunsigned.html#UUID-8c7f7188-1427-8235-15d4-450140cc7ca9_UUID-2f40e0a8-a491-b3cc-9231-f5c35a224dd7", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU \/ POU：CheckLRangeUnsigned \/ 監視範囲の制限 ", 
"snippet" : "これ 監視機能 範囲制限に対する違反を適切に処理する責任があります。違反に対する反応の例には、エラーフラグの設定や値の変更が含まれます。値がサブレンジ型変数に割り当てられると、関数は暗黙的に呼び出されます。 監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 関数が呼び出されると、次の入力パラメーターを受け取ります。 value ：サブレンジ型変数に割り当てる必要のある値 lower ：範囲下限 upper ：範囲上限 戻り値は、有効な範囲内にある限り、割り当て値です。そうでない場合は、違反したしきい値に応じて、上限または下限の...", 
"body" : "これ 監視機能 範囲制限に対する違反を適切に処理する責任があります。違反に対する反応の例には、エラーフラグの設定や値の変更が含まれます。値がサブレンジ型変数に割り当てられると、関数は暗黙的に呼び出されます。 監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 関数が呼び出されると、次の入力パラメーターを受け取ります。 value ：サブレンジ型変数に割り当てる必要のある値 lower ：範囲下限 upper ：範囲上限 戻り値は、有効な範囲内にある限り、割り当て値です。そうでない場合は、違反したしきい値に応じて、上限または下限のいずれかが返されます。 たとえば、割り当て i := 10*y 暗黙的にに置き換えられます i := CheckRangeSigned(10*y, -4095, 4095); もしも y が「1000」の場合、「10 * 1000 = 10000」はに割り当てられません i 元のコードのように。代わりに、「4095」の上限範囲が割り当てられます。 同じことが当てはまります CheckRangeUnsigned 関数。 関数が使用できない場合、実行時にそれぞれの変数のサブ範囲はチェックされません。この場合、サブレンジタイプDINT \/ UDINTの変数に-2147483648〜 + 2147483648（または0〜4294967295）の任意の値を割り当てることができます。 -9223372036854775808から+9223372036854775807（または0から18446744073709551615）の任意の値を、サブ範囲タイプLINT \/ ULINTの変数に割り当てることができます。 エリア監視機能をリンクすると、無限ループが発生する可能性があります。たとえば、FORループのカウンター変数がサブ範囲タイプであり、ループのカウント範囲が定義されたサブ範囲を終了する場合、無限ループが発生する可能性があります。 無限ループの例： VAR\n ui : UINT (0..10000);\n ...\nEND_VAR FOR ui:=0 TO 10000 DO\n ...\nEND_FOR プログラムはFORループを終了しません。 CheckRangeSigned 監視機能は防止します ui 10000より大きい値に設定されてから。 " }, 
{ "title" : "POU：CheckPointer ", 
"url" : "_cds_obj_pou_checkpointer.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：暗黙的チェックのPOU \/ POU：CheckPointer ", 
"snippet" : "CheckPointer ポインタ監視機能（CheckPointer） この関数を使用して、ランタイムモードでポインタのメモリアクセスを監視します。他とは対照的に 監視機能 、の実装のための標準的な提案は存在しません CheckPointer 。独自の要件に従って実装を定義する必要があります。 The CheckPointer 関数は、渡されたポインタが有効なメモリアドレスを参照しているかどうか、および参照されているメモリ領域の方向がポインタが参照している変数タイプと一致するかどうかを確認する必要があります。両方の条件が満たされると、ポインタが返されます。そうでない場合、関数は適切なエラー処理...", 
"body" : "CheckPointer ポインタ監視機能（CheckPointer） この関数を使用して、ランタイムモードでポインタのメモリアクセスを監視します。他とは対照的に 監視機能 、の実装のための標準的な提案は存在しません CheckPointer 。独自の要件に従って実装を定義する必要があります。 The CheckPointer 関数は、渡されたポインタが有効なメモリアドレスを参照しているかどうか、および参照されているメモリ領域の方向がポインタが参照している変数タイプと一致するかどうかを確認する必要があります。両方の条件が満たされると、ポインタが返されます。そうでない場合、関数は適切なエラー処理を完了する必要があります。 監視機能の機能を利用するには、宣言部分を編集しないでください。ただし、ローカル変数を追加することは許可されています。 では暗黙的な監視関数呼び出しは発生しません THIS ポインターと SUPER ポインター。 コンパイラバージョン3.5.7.40以降では、 CheckPointer 影響もあります REFERENCE 変数はポインタ変数と同じです。 テンプレート 宣言： \/\/ Automatically generated code: DO NOT EDIT\nFUNCTION CheckPointer : POINTER TO BYTE\nVAR_INPUT\n ptToTest : POINTER TO BYTE;\n iSize : DINT;\n iGran : DINT;\n bWrite: BOOL;\nEND_VAR 実装:(不完全） \/\/ Not a standard implementation. Insert your code here.\nCheckPointer := ptToTest; 関数が呼び出されると、次の入力パラメーターを受け取ります。 ptToTest ：ポインタのターゲットアドレス iSize ：参照される変数のサイズ。のデータ型 iSize と互換性がある必要があります INT 変数の次元スコープをカバーします iGran ：参照サイズの粒度。これは、参照される変数に含まれる最大の非構造化データ型です。のデータ型 iGran と互換性がある必要があります INT bWrite ：アクセスタイプ（ TRUE =書き込みアクセス、 FALSE =読み取りアクセス）;のデータ型 bWrite である必要があります BOOL チェックの結果が正の場合、変更されていないポインタが返されます（ ptToTest ）。 " }, 
{ "title" : "オブジェクト：POUの場所 ", 
"url" : "_cds_obj_pou_locations.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POUの場所 ", 
"snippet" : "POUの場所 このオブジェクトは、特定のコントローラーでのみ使用できます。デバイスツリーに自動的に表示されます。オブジェクトを手動で追加または削除することはできません。 このオブジェクトは、コントローラーのさまざまなコード領域にあるアプリケーションの実行可能コードをマッピングするために使用できます。特に小さなコントローラーは、多くの場合、内部コード領域（フラッシュメモリ）が制限されています。 1つ以上の追加のコード領域（たとえば、外部フラッシュメモリ）がコントローラで使用可能な場合、アプリケーションのコードPOUの場所を具体的に変更できます。安全コントローラ（SIL2）の場合、これは、安全に関...", 
"body" : "POUの場所 このオブジェクトは、特定のコントローラーでのみ使用できます。デバイスツリーに自動的に表示されます。オブジェクトを手動で追加または削除することはできません。 このオブジェクトは、コントローラーのさまざまなコード領域にあるアプリケーションの実行可能コードをマッピングするために使用できます。特に小さなコントローラーは、多くの場合、内部コード領域（フラッシュメモリ）が制限されています。 1つ以上の追加のコード領域（たとえば、外部フラッシュメモリ）がコントローラで使用可能な場合、アプリケーションのコードPOUの場所を具体的に変更できます。安全コントローラ（SIL2）の場合、これは、安全に関係のないコードPOUまたはライブラリ全体をこの外部メモリに移動するためにも使用できます。 特定の要件がない場合、コードPOUはコード領域に順番に保存されます（ ディフォルト ）。これは、最初のコード領域が埋められた場合にのみ、次のコードPOUが次の領域に保存されることを意味します。の中に POUの場所 エディタを使用すると、メモリ領域内のPOUの現在の場所が表示され、具体的に変更できます。特に安全アプリケーションの場合、これはすべての安全なPOUを安全な内部メモリ領域に入れるために必要になる場合があります。 詳細については、以下を参照してください。 さまざまなメモリ領域へのアプリケーションコードの配布" }, 
{ "title" : "編集者：POUの場所 ", 
"url" : "_cds_obj_pou_locations.html#UUID-26ae340b-748e-2b8d-dcb3-138669ca689f_id_d6ed3981f82e321c0a864631448cd76_id_ea2a3b651ff10e9fc0a8646334153b61", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：POUの場所 \/ 編集者：POUの場所 ", 
"snippet" : "ダブルクリック POUの場所 コントローラのデバイスツリー内のオブジェクトがエディタを開きます。最初は、エントリのみを取得します <アプリケーション> 。コード生成後、アプリケーションのすべてのプログラムブロックが、それぞれのオブジェクトタイプ、メモリ内の現在の場所、およびコードサイズとともに表示されます。 の中に 構成された場所 列、あなたは以外のメモリ領域の1つを設定することができます 現在位置 POUまたはライブラリごとに。 POUを最近構成されたメモリ位置に移動するには、最初に次のことを行う必要があります。 綺麗 その後 コードを生成する また。 カテゴリ内のメッセージに注意してくださ...", 
"body" : "ダブルクリック POUの場所 コントローラのデバイスツリー内のオブジェクトがエディタを開きます。最初は、エントリのみを取得します <アプリケーション> 。コード生成後、アプリケーションのすべてのプログラムブロックが、それぞれのオブジェクトタイプ、メモリ内の現在の場所、およびコードサイズとともに表示されます。 の中に 構成された場所 列、あなたは以外のメモリ領域の1つを設定することができます 現在位置 POUまたはライブラリごとに。 POUを最近構成されたメモリ位置に移動するには、最初に次のことを行う必要があります。 綺麗 その後 コードを生成する また。 カテゴリ内のメッセージに注意してください POUの場所 。これは、コードPOUを期待どおりに移動できない場合にも表示されます。 綺麗 アプリケーションのコンパイル情報の削除 に対応します ビルド→クリーン メニューコマンド これは、POUを構成済みのメモリ位置に移動するための要件です。 コードを生成する アプリケーションのコード生成の開始 に対応します ビルド→コードの生成 メニューコマンド これは、POUを構成済みのメモリ位置に移動するための要件です。 オブジェクト 参照されているライブラリのオブジェクトを含む、アプリケーションのオブジェクト タイプ オブジェクトタイプ 例： ファンクションブロック 、 方法 、 図書館 現在位置 POUの現在のメモリ位置： area_<n> 構成された場所 次のコード生成時にPOUが移動される構成済みのメモリ位置。可能な値： ディフォルト ：自動的に割り当てられた領域 area_ <n> ：明示的に割り当てられたメモリ領域（n =数値） コードサイズ POUのコードサイズ（バイト単位） " }, 
{ "title" : "オブジェクト：プロジェクト設定 ", 
"url" : "_cds_obj_project_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：プロジェクト設定 ", 
"snippet" : "プロジェクト設定 シンボル： 関数 ：オブジェクトにはプロジェクトの構成が含まれています。 電話 プロジェクト→プロジェクト設定 メニュー デバイスツリーでオブジェクトをダブルクリックします CODESYS 保存します プロジェクト設定 プロジェクトで直接。たとえば、プロジェクトを別のシステムに転送する場合、 プロジェクト設定 オブジェクトはそれと一緒に転送されます。プロジェクトアーカイブは必要ありません。 プロジェクト設定はプロジェクト全体で有効であり、次のようなさまざまなカテゴリに可能な設定を提供します。 SFC また ユーザーとグループ 。使用可能なカテゴリは、パッケージマネージャーを介...", 
"body" : "プロジェクト設定 シンボル： 関数 ：オブジェクトにはプロジェクトの構成が含まれています。 電話 プロジェクト→プロジェクト設定 メニュー デバイスツリーでオブジェクトをダブルクリックします CODESYS 保存します プロジェクト設定 プロジェクトで直接。たとえば、プロジェクトを別のシステムに転送する場合、 プロジェクト設定 オブジェクトはそれと一緒に転送されます。プロジェクトアーカイブは必要ありません。 プロジェクト設定はプロジェクト全体で有効であり、次のようなさまざまなカテゴリに可能な設定を提供します。 SFC また ユーザーとグループ 。使用可能なカテゴリは、パッケージマネージャーを介してインストールしたソフトウェアパッケージによって異なります。 " }, 
{ "title" : "オブジェクト：プロジェクト情報 ", 
"url" : "_cds_obj_project_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：プロジェクト情報 ", 
"snippet" : "プロジェクト情報 シンボル： 関数 ：オブジェクトには、プロパティ、メタ情報、およびプロジェクト情報が含まれています。これにより、プロジェクトの作成者と整合性を確認できます。 電話 デバイスツリーでオブジェクトをダブルクリックします プロジェクト→プロジェクト情報 メニュー 要件 ： CODESYS クリックするとオブジェクトが作成されます プロジェクト→プロジェクト情報 、ダイアログが開きます。 CODESYS プロジェクト情報をプロジェクトに直接保存します。たとえば、プロジェクトを別のシステムに転送する場合、 プロジェクト情報 オブジェクトも転送されます。プロジェクトアーカイブは必要ありま...", 
"body" : "プロジェクト情報 シンボル： 関数 ：オブジェクトには、プロパティ、メタ情報、およびプロジェクト情報が含まれています。これにより、プロジェクトの作成者と整合性を確認できます。 電話 デバイスツリーでオブジェクトをダブルクリックします プロジェクト→プロジェクト情報 メニュー 要件 ： CODESYS クリックするとオブジェクトが作成されます プロジェクト→プロジェクト情報 、ダイアログが開きます。 CODESYS プロジェクト情報をプロジェクトに直接保存します。たとえば、プロジェクトを別のシステムに転送する場合、 プロジェクト情報 オブジェクトも転送されます。プロジェクトアーカイブは必要ありません。 詳細については、以下を参照してください。 プロジェクト情報の取得と編集" }, 
{ "title" : "タブ：ファイル ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_b48b607558567f4ec0a8640e01c898f6", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：プロジェクト情報 \/ タブ：ファイル ", 
"snippet" : "タブには、プロジェクトファイルのプロパティとその属性が表示されます。これらの属性を編集することはできません。これらは、Windowsエクスプローラーのファイルプロパティに対応しています。...", 
"body" : "タブには、プロジェクトファイルのプロパティとその属性が表示されます。これらの属性を編集することはできません。これらは、Windowsエクスプローラーのファイルプロパティに対応しています。 " }, 
{ "title" : "タブ：概要 ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_c59e7f6558567f53c0a8640e00967a59", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：プロジェクト情報 \/ タブ：概要 ", 
"snippet" : "このタブには、プロジェクトファイルの一般情報とメタ情報が含まれています。 CODESYS この情報を使用して、 プロパティ タブ。たとえば、名前が Company_A で指定されています 会社 、 そうして Company 値を持つキー Company_A に提供されています プロパティ タブ。 もし、あんたが 保存 ライブラリプロジェクトとしてのプロジェクトの場合は、 ライブラリ開発者向けのガイドライン 。 図書館プロジェクトの場合、 会社 、 タイトル 、および バージョン ライブラリをインストールするには、指定する必要があります。 会社 会社名（例： Company_A ）。 タイトル ...", 
"body" : "このタブには、プロジェクトファイルの一般情報とメタ情報が含まれています。 CODESYS この情報を使用して、 プロパティ タブ。たとえば、名前が Company_A で指定されています 会社 、 そうして Company 値を持つキー Company_A に提供されています プロパティ タブ。 もし、あんたが 保存 ライブラリプロジェクトとしてのプロジェクトの場合は、 ライブラリ開発者向けのガイドライン 。 図書館プロジェクトの場合、 会社 、 タイトル 、および バージョン ライブラリをインストールするには、指定する必要があります。 会社 会社名（例： Company_A ）。 タイトル プロジェクトのタイトル（例 Automation_A ）。 バージョン プロジェクトのバージョン（例： 0.0.0.1 ）。 リリース済み ：変更からの保護をアクティブにします 結果：ここでプロジェクトを編集すると、プロジェクトを本当に変更するかどうかを確認するためのダイアログプロンプトが開きます。このプロンプトに一度クリックして返信する場合 はい 、その後、追加の編集アクションを求める追加のプロンプトは表示されません。 ライブラリのカテゴリ ライブラリ プロジェクトのカテゴリ。それに従って並べ替えることができます。 ライブラリリポジトリ ダイアログ カテゴリが指定されていない場合、カテゴリ 他の ライブラリに割り当てられます。 カテゴリは、XML形式の1つ以上の外部記述ファイルに由来します。ただし、すでに作成されているライブラリプロジェクトから作成することもできます。 要件：プロジェクトはライブラリプロジェクトです。 ： ライブラリカテゴリ ライブラリカテゴリを追加できるダイアログが開きます。 ライブラリ カテゴリの作成の詳細については、次を参照してください。 図書館のカテゴリー デフォルトの名前空間 要件: プロジェクトはライブラリ プロジェクトです。 ここでデフォルトの名前空間を定義しない場合、ライブラリファイルの名前が名前空間として自動的に適用されます。 プレースホルダー 要件: プロジェクトはライブラリ プロジェクトです。 このライブラリへの参照に使用されるプレースホルダ名 例： SysMem プレースホルダーを介して機能する参照は、構文に従って表示されます #<placeholder name> . 重要: プレースホルダーの名前は変更できなくなりました。したがって、他の誰かがまったく同じ名前を選択する可能性が低い名前を選択することを強くお勧めします。 ヒント: ライブラリ プレースホルダーを介して参照ライブラリを統合できます。このようにして、バージョンの依存関係やベンダー固有のライブラリを使用する必要があるために発生する可能性のある問題を回避できます。 著者 プロジェクトの作成者（例： Arnold Best ）。 説明 例： For internal use only ダイアログ： ライブラリカテゴリ カテゴリのリスト ライブラリプロジェクトに割り当てられているカテゴリのリスト それらはいくつかのソースから発生する可能性があります。 必要なカテゴリをすべて指定したら、をクリックします わかった 確認するために。 ボタン 追加 The 説明ファイルから と 他の図書館から コマンドが表示されます。 ボタン 削除 CODESYS 選択したカテゴリを削除します。 指示： 説明ファイルから The 説明ファイルを選択 説明ファイルを選択するためのダイアログが開きます（ *.libcat.xml ）。このファイルには、コマンドカテゴリが含まれています。クリックすると 開ける 、 CODESYS カテゴリを受け入れます。 指示： 他の図書館から The ライブラリを選択 ダイアログが開き、受け入れるコマンドカテゴリのあるライブラリを選択します。クリックすると 開ける 、 CODESYS カテゴリを受け入れます。 ボタン わかった CODESYS カテゴリをプロジェクト情報として提供し、 ライブラリカテゴリ 分野。 " }, 
{ "title" : "タブ：プロパティ ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_8210ee8558567f55c0a8640e01b29160", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：プロジェクト情報 \/ タブ：プロパティ ", 
"snippet" : "このタブでは、ユーザー固有のプログラムから外部から制御できるキーを定義できます。 ライブラリプロジェクトを開いた場合は、関連するキーの説明に注意してください。 ライブラリ開発者向けのガイドライン ：「ライブラリ開発の概要」。 あなたが開いた場合 シンボルライブラリ プロジェクトとして、そして鍵 VisuSymbolLibrary = TRUE 定義する必要があります。ライブラリをシンボルライブラリとして識別します。 鍵 キーの名前 新しいキーのテキストの文字列を指定するか、から既存のキーを選択します プロパティ テーブル。 タイプ キーのデータ型 可能なタイプ： 文章 、 日にち 、 番号 、...", 
"body" : "このタブでは、ユーザー固有のプログラムから外部から制御できるキーを定義できます。 ライブラリプロジェクトを開いた場合は、関連するキーの説明に注意してください。 ライブラリ開発者向けのガイドライン ：「ライブラリ開発の概要」。 あなたが開いた場合 シンボルライブラリ プロジェクトとして、そして鍵 VisuSymbolLibrary = TRUE 定義する必要があります。ライブラリをシンボルライブラリとして識別します。 鍵 キーの名前 新しいキーのテキストの文字列を指定するか、から既存のキーを選択します プロパティ テーブル。 タイプ キーのデータ型 可能なタイプ： 文章 、 日にち 、 番号 、 ブール値 、 バージョン 価値 許可された形式のキーの値： 文章 ：任意の文字列 日にち ：日付の最小エントリ： 1.1 例： Friday, January 1, 2016 12:00:00 番号 ：符号付きまたは符号なしのInteger32形式の整数 例： -32500 ブール値 ： True また False 、キャピタライゼーションは無関係 バージョン ：最大4桁 例： 1.1 、 1.0.1.0 追加 新しく定義されたキーをに追加します プロパティ テーブル 編集 で選択したキーに加えられた変更を保存します プロパティ テーブル 削除 で選択したキーを削除します プロパティ テーブル プロパティ キーとして定義されているプロパティのリスト CODESYS 内の情報のキーを自動的に作成します 概要 タブ。 キーをクリックして、リストの上の入力フィールドで編集します。 " }, 
{ "title" : "タブ：統計 ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_a4b8c2db58567f55c0a8640e000a1036", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：プロジェクト情報 \/ タブ：統計 ", 
"snippet" : "ダイアログには、プロジェクトでの個々のタイプまたは使用のオブジェクトの数に関する統計情報が表示されます。...", 
"body" : "ダイアログには、プロジェクトでの個々のタイプまたは使用のオブジェクトの数に関する統計情報が表示されます。 " }, 
{ "title" : "タブ：ライセンス ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_65b680f358567f57c0a8640e01071248", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：プロジェクト情報 \/ タブ：ライセンス ", 
"snippet" : "ダイアログは、ライブラリのライセンス保護用です。 この方法で保護できるのは「コンパイル済みライブラリ」のみです。 変数 ドングルライセンスを有効にする ：ライブラリを使用するには、ライセンス付きのドングルが必要です。 会社コード 後でライブラリを使用するためにドングルから提供する必要があるライセンス情報 製品コード アクティベーションURL アクティベーションメール...", 
"body" : "ダイアログは、ライブラリのライセンス保護用です。 この方法で保護できるのは「コンパイル済みライブラリ」のみです。 変数 ドングルライセンスを有効にする ：ライブラリを使用するには、ライセンス付きのドングルが必要です。 会社コード 後でライブラリを使用するためにドングルから提供する必要があるライセンス情報 製品コード アクティベーションURL アクティベーションメール " }, 
{ "title" : "タブ：署名 ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_4f62c3fafb05c6ffc0a8640e019c606c", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：プロジェクト情報 \/ タブ：署名 ", 
"snippet" : "このタブは、このタブで署名が作成された既存のライブラリに対してのみ表示されます。このタブは、新しく生成されたライブラリでは表示されなくなります。 詳細については、以下を参照してください。 プロジェクト情報の取得と編集証明書で署名されたライブラリが作成されたとき（ CODESYS V3 3.5 SP15 ）およびライブラリとの互換性 CODESYS < V3 3.5 SP15 が設定されていない場合、このタブの設定は無効になります。この場合、署名は、のユーザープロファイルに割り当てる必要のある証明書を使用して行われます。 セキュリティ画面 。 1つの方法。これは推奨されませんが、バージョンとの互...", 
"body" : "このタブは、このタブで署名が作成された既存のライブラリに対してのみ表示されます。このタブは、新しく生成されたライブラリでは表示されなくなります。 詳細については、以下を参照してください。 プロジェクト情報の取得と編集証明書で署名されたライブラリが作成されたとき（ CODESYS V3 3.5 SP15 ）およびライブラリとの互換性 CODESYS < V3 3.5 SP15 が設定されていない場合、このタブの設定は無効になります。この場合、署名は、のユーザープロファイルに割り当てる必要のある証明書を使用して行われます。 セキュリティ画面 。 1つの方法。これは推奨されませんが、バージョンとの互換性のために必要になる場合があります< 3.5 SP15 は、このダイアログのベンダー固有のワンタイムキーを使用したライブラリの安全性の低い署名です。要件：このキーは「 秘密鍵 \" ファイル （ *.libpk ）関連付けられたトークン。ライブラリのユーザーは、最後の署名が実際にライブラリベンダーによって実行されたかどうかを確認できるようにするために、このキーも取得する必要があります。 署名を有効にする ： CODESYS 使い捨てのベンダー固有のキーを使用してライブラリプロジェクトに署名します。 秘密鍵ファイル 秘密鍵ファイルの場所 *.libpk （例： D:\\for lib developers only\\mycomp_libkey.libpk ）。 公開鍵トークン 例： 427A5701DA3CF3CF 要件：秘密鍵ファイルが指定されており、 CODESYS トークンを読み取って入力しました。 秘密鍵ファイルを作成する CODESYS 新しい秘密鍵ファイルを作成します。 " }, 
{ "title" : "プロジェクト情報にアクセスするためのブロックを作成するためのオプション ", 
"url" : "_cds_obj_project_information.html#UUID-67d6ace4-91e2-38cc-737d-d91886fc535e_id_c95bfe46c6c18a67c0a8640e01715107_id_0a188ec6fa561b9fc0a8640e0019d8bf", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト：プロジェクト情報 \/ プロジェクト情報にアクセスするためのブロックを作成するためのオプション ", 
"snippet" : "「プロジェクト情報」POUを自動的に生成する 注：このオプションで作成された関数は、ランタイムが WSTRING データ・タイプ。そうでない場合は、少なくともプロパティにアクセスするためのアプリケーションで、プロジェクト情報の個々の項目で自動的に作成された関数を使用できます。これらの関数はランタイムに登録されていません。 ： CODESYS のPOUを作成します FUNCTION 次のように入力します POU ビュー。アプリケーションのプロジェクトプロパティへのプログラムによるアクセスを許可します。機能ブロック GetCompany 、 GetTitle と GetVersion プロパティ用...", 
"body" : "「プロジェクト情報」POUを自動的に生成する 注：このオプションで作成された関数は、ランタイムが WSTRING データ・タイプ。そうでない場合は、少なくともプロパティにアクセスするためのアプリケーションで、プロジェクト情報の個々の項目で自動的に作成された関数を使用できます。これらの関数はランタイムに登録されていません。 ： CODESYS のPOUを作成します FUNCTION 次のように入力します POU ビュー。アプリケーションのプロジェクトプロパティへのプログラムによるアクセスを許可します。機能ブロック GetCompany 、 GetTitle と GetVersion プロパティ用に作成されます 会社 、 タイトル と バージョン 。 以下の機能ブロックは、ユーザー定義プロパティに使用できます。 GetBooleanProperty ：BOOL（TRUE \/ FALSE） GetNumberProperty ：DINT（数値） GetTextProperty ：WSTRING（文字列） GetTextProperty2 ：POINTER TO WSTRING（長さ無制限） GetVersionProperty ：VERSION（文字列としてのバージョン番号） 注：標準ライブラリに対してこのオプションをアクティブにしないでください。これは、追加のメモリ要件のために、小規模なシステムで問題を引き起こす可能性があるためです。 注：ライブラリにこのプロジェクト情報POUも含まれている場合は、演算子を使用する必要があります __プール このPOUにアクセスしていることを確認します。 「ライブラリ情報」POUを自動的に生成する ： CODESYS のPOUを作成します FUNCTION 次のように入力します POU ビュー。アプリケーションのプロジェクトプロパティへのプログラムによるアクセスを許可します。 のために バージョン と リリース済み プロパティでは、次の関数が作成されます。 GetLibVersion （文字列としてのバージョン番号）、 GetLibVersionNumber （数値としてのバージョン番号）、および IsLibReleased （真\/偽）。 注：これらの関数はランタイムに登録されません。このオプションは、ランタイムがサポートしていない代替ソリューションとして利用できます。 WSTRING データ型、したがって、で作成された関数を使用することを許可しません 「プロジェクト情報」POUを自動的に生成する オプション。 プロジェクトの互換性を強制 : を使用してライブラリを保存する場合 プロジェクトに名前を付けて保存 コマンドを実行すると、選択した形式が保存されます。その場合、 プロジェクトに名前を付けて保存 コマンドを再度実行すると、保存された選択内容がデフォルトで選択されます。 このオプションを有効にして、新しいストレージ形式を必要とするオブジェクトを追加すると、ダイアログが開きます。ダイアログで、更新を明示的に確認するか、キャンセルする必要があります。 クリックすると はい そうすれば、プロジェクト内のすべての変更がデータを失うことなく保存されます。ただし、今後は元々設定されていた保存形式ではプロジェクトを開くことができなくなります。新しいフォーマットは、新しい強制ストレージフォーマットとして定義されます クリックすると いいえ その場合、プロジェクトは設定された保存形式との互換性を維持しますが、すべての変更が保存されるわけではありません。 ザル プロジェクトの互換性を強制して オプションは互換性のあるライブラリの開発に役立ちます。同時に、これによってプログラミングシステムの最新バージョンを使用できるようになります。 このオプションをオンにした場合の影響: ストレージフォーマットの更新要求は抑制されます。 プロジェクトに保存する必要のある新しい機能は使用できません。テキストオブジェクト (POU、DUT、インターフェイスなど) のみを含むライブラリを厳密に開発する場合、これは制約にはなりません コンパイラのバージョンは自由に選択できますが、パッチバージョンは選択できません。 現在最新のコンパイラバージョンが選択されている場合は、古いコンパイラバージョンを選択できます。 " }, 
{ "title" : "オブジェクト:タスク設定 ", 
"url" : "_cds_f_reference_task_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト:タスク設定 ", 
"snippet" : "タスク構成 シンボル: このオブジェクトは、タスク構成の基本設定を定義および表示するために使用されます。 のタブ タスク設定 とその機能: タスクグループ : タスクグループの定義と CPU への割り当て モニター : オンラインモードでのサイクルタイムのステータスと現在の統計情報の表示 変数使用量 : 変数にアクセスするタスクとその実行方法の概要 スタック使用量 : 呼び出し階層に従って分割されたスタックサイズ (バイト単位) システムイベント : POU 呼び出しとシステムイベントのリンク [プロパティ] : 基本設定の表示 CPU ロード : オンラインモードでの CPU 負荷のグラフィ...", 
"body" : "タスク構成 シンボル: このオブジェクトは、タスク構成の基本設定を定義および表示するために使用されます。 のタブ タスク設定 とその機能: タスクグループ : タスクグループの定義と CPU への割り当て モニター : オンラインモードでのサイクルタイムのステータスと現在の統計情報の表示 変数使用量 : 変数にアクセスするタスクとその実行方法の概要 スタック使用量 : 呼び出し階層に従って分割されたスタックサイズ (バイト単位) システムイベント : POU 呼び出しとシステムイベントのリンク [プロパティ] : 基本設定の表示 CPU ロード : オンラインモードでの CPU 負荷のグラフィカル表示 " }, 
{ "title" : "タブ:タスクグループ ", 
"url" : "_cds_obj_task_config_task_groups.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト:タスク設定 \/ タブ:タスクグループ ", 
"snippet" : "オブジェクト: タスク設定 タスクグループを定義するには、 タスクグループ タブ。タスクグループは、 マルチコア システム。 タスク タスクグループの各タスクは、 芯 フィールド。 優先度 列には、それぞれの IEC タスクのエディターで設定されているタスクの優先度が表示されます。 [グループを追加] このボタンは、 NewGroup_<no> . [グループを削除] 選択したタスクグループを削除します。 グループ名 名前は、フィールドをダブルクリックして変更できます。 コア フリーフローティング : タスク グループ内のすべての IEC タスクは、オペレーティング システムによって負荷分散を...", 
"body" : "オブジェクト: タスク設定 タスクグループを定義するには、 タスクグループ タブ。タスクグループは、 マルチコア システム。 タスク タスクグループの各タスクは、 芯 フィールド。 優先度 列には、それぞれの IEC タスクのエディターで設定されているタスクの優先度が表示されます。 [グループを追加] このボタンは、 NewGroup_<no> . [グループを削除] 選択したタスクグループを削除します。 グループ名 名前は、フィールドをダブルクリックして変更できます。 コア フリーフローティング : タスク グループ内のすべての IEC タスクは、オペレーティング システムによって負荷分散を介して個々のプロセッサ コアに動的に分散されます。つまり、タスクは通常、実行されるプロセッサ コアを頻繁に切り替えます。ユーザーはこれを制御できません。 負荷はオペレーティング システムによって自動的に分散されるため、ほとんどのアプリケーションにこの設定をお勧めします。 連続ピン留め : タスク グループのすべての IEC タスクは、異なるプロセッサ コアに永続的にバインドされます。タスクよりもプロセッサ コアの数が少ない場合、タスクは Core1 から始まり、Core2、Core3 などと、個々のプロセッサ コアにバインドされます。オーバーフローが発生した場合、プロセスは Core0、Core1 などと続行されます。ユーザーはこれを制御できません。 固定ピン留め : タスク グループのすべての IEC タスクは、プロセッサ コアに永続的にバインドされます。デフォルトでは、ランタイムによってプロセッサ コアが決定されます。通常は Core1 が使用されます。 複数のタスクグループがある場合、 固定ピン留め 設定により、各タスク グループが異なるプロセッサ コアにバインドされます。これは通常、Core1 から始まります。 <固定コア数> タスク グループのすべての IEC タスクは、定義されたプロセッサ コアに永続的にバインドされます。コントローラにプロセッサ コアが存在しない場合は、ダウンロード中にエラーが生成されます。 の 連続ピン留め 、 固定ピン留め 、 そして <固定コア数> 設定は、より確定的なジッター時間を取得するのに役立ちます。これは、これらの設定が実行時に個々のコアにタスクを動的に分散することによって影響を受けないためです。 ただし、これにより、オペレーティング システムが個々のプロセッサ コアに負荷を分散できなくなります。 したがって、これらの設定は、最初にテストしてから使用することをお勧めします。このテストにより、これらの設定によってリアルタイムの動作が大幅に改善されることが実証されるはずです。 " }, 
{ "title" : "タブ:監視 ", 
"url" : "_cds_obj_task_config_monitor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト:タスク設定 \/ タブ:監視 ", 
"snippet" : "オブジェクト: タスク設定 このタブには、のステータスが表示されます。 CODESYS オンラインモードのタスクと、サイクルとサイクルタイムの現在の測定値が表示されます。値は、コントローラーからの値の監視と同じ時間間隔で更新されます 詳細については、以下を参照してください。 ジッターとレイテンシーの定義表示された値は次のようにリセットできます 0 によって リセット コンテキストメニューコマンド。 タスク タスク名 (タスク設定で定義されているとおり) ステータス 未作成 : 前回の更新以降、タスクが開始されていません (特にイベントタスクの場合)。 生成されました : タスクは実行時に認識さ...", 
"body" : "オブジェクト: タスク設定 このタブには、のステータスが表示されます。 CODESYS オンラインモードのタスクと、サイクルとサイクルタイムの現在の測定値が表示されます。値は、コントローラーからの値の監視と同じ時間間隔で更新されます 詳細については、以下を参照してください。 ジッターとレイテンシーの定義表示された値は次のようにリセットできます 0 によって リセット コンテキストメニューコマンド。 タスク タスク名 (タスク設定で定義されているとおり) ステータス 未作成 : 前回の更新以降、タスクが開始されていません (特にイベントタスクの場合)。 生成されました : タスクは実行時に認識されますが、まだ動作していません。 有効 : タスクは正常に動作しています。 例外 : タスクは例外ステータスを生成しました。 IEC サイクルカウント アプリケーションを最初に起動してから実行され、実際にIECコードが呼び出されたサイクル数。 その結果、この値はコード内の Hugo カウンターに対応します。ただし、ターゲットシステムがカウント関数をサポートしていない場合、数値は次のままになります 0 。 サイクルカウント コントローラにログインしてから実行されたサイクル数 (タスクがログインしている場合も含む) 停止 番号は次の呼び出しに対応します IecTaskCycle2 アプリケーションが起動していてもインクリメントされます。 ストップ 。 ただし、アプリケーションが実行されていない場合にサイクルがカウントされるかどうかは、ターゲットシステムによって異なります。このような場合、 サイクルカウント より大きくなる可能性があります IEC サイクルカウント 。 最終サイクル時間 (µs) 最後に測定されたサイクル時間[µs] 平均サイクル時間 (µs) 全サイクルにおける平均サイクル時間 [µs] マックス。サイクルタイム (µs 全サイクルにおける最大測定サイクル時間 [µs] 最小。サイクルタイム (µs 全サイクルで測定された最小サイクル時間 [µs] ジッター (µs) 周期的ジッターの現在の値 [µs] 注意:から CODESYS 3.5 SP11 から SP15 までは、周期的ジッターのピークピーク値が表示されます。以前のバージョンと SP16 以降では、周期的ジッターの現在の値が表示されます 最小。ジッター (µs) 測定された最小周期ジッター [µs] マックス。ジッター (µs) 測定された最大周期的ジッター [µs] コア タスクが現在実行されているプロセッサコアの数 例: 2 要件:コントローラにはマルチコアプロセッサが搭載されています。 CPU がマルチコア CPU でない場合、値は -1 ここに表示されます。 " }, 
{ "title" : "タブ:変数使用量 ", 
"url" : "_cds_obj_task_config_variable_usage.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト:タスク設定 \/ タブ:変数使用量 ", 
"snippet" : "オブジェクト: タスク設定 タブ内 可変使用法 すべての変数とその使用法の概要がわかります。あなたはどちらで見るか タスク 変数にアクセスします。 使用する場合 マルチコア 、変数への書き込みアクセス (w) はタスク内でのみ行うべきです。そうしないと、矛盾が生じる可能性があるからです。 コンテキストメニューでは、個々のタスクを非表示にしたり、変数へのクロスリファレンスリストを表示したりできます。 [変数] 変数の名前 タイプ データタイプ カウント これらの変数にアクセスするタスクの数。 <タスク名> 変数へのアクセス (r: 読み取り、w: 書き込み、rw: 読み取り\/書き込み)...", 
"body" : "オブジェクト: タスク設定 タブ内 可変使用法 すべての変数とその使用法の概要がわかります。あなたはどちらで見るか タスク 変数にアクセスします。 使用する場合 マルチコア 、変数への書き込みアクセス (w) はタスク内でのみ行うべきです。そうしないと、矛盾が生じる可能性があるからです。 コンテキストメニューでは、個々のタスクを非表示にしたり、変数へのクロスリファレンスリストを表示したりできます。 [変数] 変数の名前 タイプ データタイプ カウント これらの変数にアクセスするタスクの数。 <タスク名> 変数へのアクセス (r: 読み取り、w: 書き込み、rw: 読み取り\/書き込み) " }, 
{ "title" : "タブ:スタック使用量 ", 
"url" : "_cds_obj_task_config_tab_stack_usage.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト:タスク設定 \/ タブ:スタック使用量 ", 
"snippet" : "スタック使用量 タスク設定エディターのタブ ザル スタック使用量 タブには、各アプリケーション、各タスク、最大コールスタック内の POU の現在のスタック使用量が表示されます。 情報を表示するための要件:アプリケーションコードが生成されました。これは、コントローラーへのログイン時に自動的に行われるか、コントローラーを使用して明示的に行われます。 ビルド → コードを生成 コマンド。 ターゲット設定からデフォルトのスタックサイズをオーバーライドする のスタックサイズの上書き 使用可能なスタックサイズ はエキスパート関数です。 この入力フィールドは、ここでオプションを有効にして表示されるメッセージ...", 
"body" : "スタック使用量 タスク設定エディターのタブ ザル スタック使用量 タブには、各アプリケーション、各タスク、最大コールスタック内の POU の現在のスタック使用量が表示されます。 情報を表示するための要件:アプリケーションコードが生成されました。これは、コントローラーへのログイン時に自動的に行われるか、コントローラーを使用して明示的に行われます。 ビルド → コードを生成 コマンド。 ターゲット設定からデフォルトのスタックサイズをオーバーライドする のスタックサイズの上書き 使用可能なスタックサイズ はエキスパート関数です。 この入力フィールドは、ここでオプションを有効にして表示されるメッセージを確認した場合にのみ使用できます。このメッセージは、スタックオーバーフローのリスクがある可能性があることを示しています。例外エラーが発生する可能性があります : ザ・ 使用可能なスタックサイズ 入力フィールドには、デバイスの説明から現在設定されているデフォルトのスタックサイズが表示されます。入力は許可されていません。デフォルト設定。 : ル  使用可能なスタックサイズ 入力フィールドは編集できます。ここで新しい値を指定したり、デフォルト値にリセットしたりできます。 デフォルトにリセット ボタンをクリックすると、の値がリセットされます 使用可能なスタックサイズ デフォルトのスタックサイズに戻します。デフォルトのスタックサイズはデバイスの説明で定義されています。 使用可能なスタックサイズ 使用可能なスタックサイズ (バイト単位) 例: 4,194,304 最大スタックサイズはデバイスの説明で指定されています。このデフォルトのスタックサイズが読み込まれ、使用可能なスタックサイズとして適用されます。 以下の場合、値を変更できます。 デフォルトのスタックサイズをターゲット設定からオーバーライドします。 オプションが有効になっています。 コンパイラーは、コンパイル中にアプリケーションの最大スタック使用量をチェックし、オーバーフローが発生する可能性がある場合は、この計算されたサイズに基づいてエラーを報告します。 外部呼び出しの想定スタックサイズ ランタイムシステムへの外部呼び出しで想定されるスタックサイズ (バイト単位) 例:24 と表示されている場合、外部関数への呼び出しはスタックの 24 バイトを使用すると想定されます 注:スタック使用量の計算結果は常に推定値です。 外部呼び出しのスタックサイズの一般的な推定値は、デバイスの説明で指定されています。この値は計算に使用されます。'' という属性を持つ外部呼び出しに特別な推定値が割り当てられていない限り、この限りではありません estimated-stack-usage'。この場合は、特別な値が優先されます。 タスク\/最大コールスタック コンパイル時に決定されるコールスタック (呼び出し階層) ヒント:このビューでコールスタックが空の場合は、コンパイル操作を開始して 作成 → コードを生成 コマンド。これで、スタックの使用状況に関する現在の情報が表示されます。 スタックサイズ 呼び出された POU あたりの使用スタックサイズ (バイト単位) または、タスクの呼び出し階層を介して合計されたスタックサイズ コンパイル時に、コンパイラーは呼び出しチェーンの最大スタック使用量を計算します。 重要:POU が赤で表示されている場合は、この POU でスタックオーバーフローが検出されたことを意味します。メモリオーバーフローのため、次の POU も赤で表示されます 詳細については、以下を参照してください。 スタック使用量の計算" }, 
{ "title" : "タブ:システムイベント ", 
"url" : "_cds_obj_task_config_sys_event.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト:タスク設定 \/ タブ:システムイベント ", 
"snippet" : "オブジェクト: タスク設定 で システムイベント タブでは、どのイベントがどの機能を呼び出すか、また構成が現在アクティブ化されているかどうかを定義します。このタブは、(タスクではなく)「システムイベント」からプロジェクト関数を呼び出す場合に使用します。 イベントハンドラを追加 を開きます イベントハンドラを追加 ダイアログ イベントハンドラを削除 選択したリスト割り当てを削除します イベント情報 対応するイベントライブラリの情報を表示します オープンイベント機能 選択した課題の新しい関数のエディターを開きます で新しい関数の実装言語を選択しました イベントハンドラーの追加 ダイアログ。 イベン...", 
"body" : "オブジェクト: タスク設定 で システムイベント タブでは、どのイベントがどの機能を呼び出すか、また構成が現在アクティブ化されているかどうかを定義します。このタブは、(タスクではなく)「システムイベント」からプロジェクト関数を呼び出す場合に使用します。 イベントハンドラを追加 を開きます イベントハンドラを追加 ダイアログ イベントハンドラを削除 選択したリスト割り当てを削除します イベント情報 対応するイベントライブラリの情報を表示します オープンイベント機能 選択した課題の新しい関数のエディターを開きます で新しい関数の実装言語を選択しました イベントハンドラーの追加 ダイアログ。 イベントを呼び出す関数のマッピングのリスト: 名前 、 説明 、 呼び出す関数 、および アクティブ (設定を有効または無効にする) イベントハンドラを追加 新しい割り当て「イベント — 呼び出す関数」をリストに追加します [イベント] 選択できる項目は、ターゲットデバイスによって異なります。 CODESYS 利用できないイベントには、名前の前に赤い記号が付きます。 考えられるすべてのシステムイベントのリストは、このセクションの最後にあります。 呼び出す関数 関数名 ( POU 、タイプ ファンクション ) の名前を指定する必要があります 新規 関数。 CODESYS ダイアログを確認した後、デバイスツリーに関数を挿入します。 スコープ [アプリケーション] : この関数はアプリケーションで使用できます。 POU : この機能はプロジェクト全体で利用できます。 実装言語 新しい関数の実装言語 [説明] 選択したイベントの簡単な説明 " }, 
{ "title" : "オンラインモードの機能 ", 
"url" : "_cds_obj_task_config_sys_event.html#UUID-c1043114-d606-9162-3795-5a941a24ff08_id_e5ddda49857aab52c0a8640e01f6cda7_id_aca2ec018ac2b258c0a8640e004f986b", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト:タスク設定 \/ タブ:システムイベント \/ オンラインモードの機能 ", 
"snippet" : "呼び出された関数からイベントへの割り当てのリストには、次の情報も含まれています。 イベントステータス 、 コールカウント 、および オンラインリセット ボタン。 イベントステータス 0 : エラーは発生していません。 等しくない 0 : エラー。それぞれのランタイムドキュメントを参照する必要があります。 コールカウント イベントの発生頻度または関連する関数が呼び出された頻度を表示します オンラインリセット CODESYS イベントリストを再初期化し、イベント\/関数呼び出しのカウンタをリセットします。正しく初期化されていないイベントは赤いステータスラインで表示されます...", 
"body" : "呼び出された関数からイベントへの割り当てのリストには、次の情報も含まれています。 イベントステータス 、 コールカウント 、および オンラインリセット ボタン。 イベントステータス 0 : エラーは発生していません。 等しくない 0 : エラー。それぞれのランタイムドキュメントを参照する必要があります。 コールカウント イベントの発生頻度または関連する関数が呼び出された頻度を表示します オンラインリセット CODESYS イベントリストを再初期化し、イベント\/関数呼び出しのカウンタをリセットします。正しく初期化されていないイベントは赤いステータスラインで表示されます " }, 
{ "title" : "発生する可能性のあるシステムイベント ", 
"url" : "_cds_obj_task_config_sys_event.html#UUID-c1043114-d606-9162-3795-5a941a24ff08_id_e5ddda49857aab52c0a8640e01f6cda7_id_18ba31b03c03a634c0a8640e01f61238", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト:タスク設定 \/ タブ:システムイベント \/ 発生する可能性のあるシステムイベント ", 
"snippet" : "[イベント] [説明] タスク デバッグ PrepareStart アプリケーションを開始する前に電話してください コミュニケーションタスク いいえ StartDone 申請開始後に電話する コミュニケーションタスク いいえ PrepareStop アプリケーションを停止する前に電話してください コミュニケーションタスク いいえ StopDone アプリケーションを停止した後に呼び出す コミュニケーションタスク いいえ PrepareReset アプリケーションをリセットする前に電話してください コミュニケーションタスク いいえ ResetDone アプリケーションをリセットした後に呼び出す ...", 
"body" : "[イベント] [説明] タスク デバッグ \n PrepareStart\n アプリケーションを開始する前に電話してください コミュニケーションタスク いいえ \n StartDone\n 申請開始後に電話する コミュニケーションタスク いいえ \n PrepareStop\n アプリケーションを停止する前に電話してください コミュニケーションタスク いいえ \n StopDone\n アプリケーションを停止した後に呼び出す コミュニケーションタスク いいえ \n PrepareReset\n アプリケーションをリセットする前に電話してください コミュニケーションタスク いいえ \n ResetDone\n アプリケーションをリセットした後に呼び出す コミュニケーションタスク いいえ \n PrepareOnlineChange\n アプリケーションをオンラインで変更する前に電話してください コミュニケーションタスク いいえ \n OnlineChangeDone\n 申請書のオンライン変更後の電話 コミュニケーションタスク いいえ \n PrepareDownload\n アプリケーションをダウンロードする前に電話してください コミュニケーションタスク いいえ \n DownloadDone\n アプリケーションをダウンロードした後に電話する コミュニケーションタスク いいえ \n PrepareDelete\n アプリケーションを削除する前に電話してください コミュニケーションタスク いいえ \n DeleteDone\n アプリケーションを削除した後に電話をかける コミュニケーションタスク いいえ \n PrepareExit\n アプリケーションを終了する前に電話してください コミュニケーションタスク いいえ \n ExitDone\n アプリケーションを終了した後に呼び出す コミュニケーションタスク いいえ \n CodeInitDone\n イベントはコード初期化後に送信されます。タスクセーフセクション内で呼び出され、オンラインで変更があった場合のみ呼び出されます。(たとえば、オンライン変更のコピーコードはここで実行されます) コミュニケーションタスク いいえ \n Exception\n イベントは、アプリケーションのコンテキストで例外が発生した場合に送信されます。 ランタイムの例外処理タスク、またはランタイムが例外処理をサポートしていない場合はタスク自体 タスクにより異なる \n Login\n このアプリケーションへのクライアントのログイン コミュニケーションタスク いいえ \n Logout\n このアプリケーションからのクライアントのログアウト コミュニケーションタスク いいえ \n BeforeReadingInputs\n 入力を読み取る前に呼び出します IEC タスク はい \n AfterReadingInputs\n 入力を読み取った後に呼び出します IEC タスク はい \n BeforeWritingOutputs\n 出力を書き込む前に呼び出す IEC タスク はい \n AfterWritingOutputs\n 出力を書き込んだ後に呼び出す IEC タスク はい \n DebugLoop\n IEC タスクがブレークポイントで停止すると、イベントは周期的にデバッグループに送信されます。 コミュニケーションタスク いいえ \n PrepareShutdown\n イベントは、ランタイムがダウンロードされる直前に送信されます。 ランタイムメインループ いいえ \n PrepareExitComm\n イベントは、通信サーバーを終了する前にダウンロード中に送信されます。 ランタイムメインループ いいえ \n PrepareExitTasks\n イベントはダウンロード中に終了前に送信されます ( Exit ) すべてのタスク。 ランタイムメインループ いいえ " }, 
{ "title" : "タブ:プロパティ ", 
"url" : "_cds_obj_task_config_properties.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト:タスク設定 \/ タブ:プロパティ ", 
"snippet" : "オブジェクト: タスク設定 の基本設定 タスク設定 ターゲットシステムで指定されたものがタブに表示されます。たとえば、タスクやウォッチドッグパラメーターの最大値などです...", 
"body" : "オブジェクト: タスク設定 の基本設定 タスク設定 ターゲットシステムで指定されたものがタブに表示されます。たとえば、タスクやウォッチドッグパラメーターの最大値などです " }, 
{ "title" : "タブ:CPU 負荷 ", 
"url" : "_cds_obj_task_config_core_deployment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト:タスク設定 \/ タブ:CPU 負荷 ", 
"snippet" : "オブジェクト: タスク設定 The CPU負荷 タブはオンラインモードで利用できます マルチコア デバイスのみ。個々のCPUの負荷は、トレースエディタに表示されます。 詳細については、以下を参照してください。 コントローラ上のすべてのトレースへのアクセス もし CODESYS Trace がインストールされている場合、右側のウィンドウの凡例をダブルクリックしてトレース構成を開くことができます。ここではさらに変数を追加することはできません。...", 
"body" : "オブジェクト: タスク設定 The CPU負荷 タブはオンラインモードで利用できます マルチコア デバイスのみ。個々のCPUの負荷は、トレースエディタに表示されます。 詳細については、以下を参照してください。 コントローラ上のすべてのトレースへのアクセス もし CODESYS Trace がインストールされている場合、右側のウィンドウの凡例をダブルクリックしてトレース構成を開くことができます。ここではさらに変数を追加することはできません。 " }, 
{ "title" : "Linuxシステムでのタスクの優先順位のマッピング ", 
"url" : "_cds_task_mapping_in_the_linux_system.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト:タスク設定 \/ Linuxシステムでのタスクの優先順位のマッピング ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "IECタスクの優先順位とLinuxの優先順位の間の依存関係 ", 
"url" : "_cds_task_mapping_in_the_linux_system.html#UUID-b85d83f0-ecf3-8513-c7aa-c29a2e7321c1_id_f1373b689f854d9c0a864633626272f_id_4e49477d8a294f1dc0a864636423535f", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト:タスク設定 \/ Linuxシステムでのタスクの優先順位のマッピング \/ IECタスクの優先順位とLinuxの優先順位の間の依存関係 ", 
"snippet" : "ターゲットシステムがLinuxで実行されている場合、IECタスクの特定の優先順位が特定の優先順位とスケジューリングポリシーにマップされます。優先度に応じて、スケジューリングポリシー SCHED_FIFO また SCHED_OTHER 表のように表示されます。 IECタスクの優先順位 Linux Priority Linux（デフォルト） 0（最高のリアルタイム優先度） 56（ SCHED_FIFO ）。 15（リアルタイムの優先度が最も低い） 41 ( SCHED_FIFO ) 16（リアルタイムの優先順位なし） 0（ SCHED_OTHER ）。 31（リアルタイムの優先順位なし） 0（ S...", 
"body" : "ターゲットシステムがLinuxで実行されている場合、IECタスクの特定の優先順位が特定の優先順位とスケジューリングポリシーにマップされます。優先度に応じて、スケジューリングポリシー SCHED_FIFO また SCHED_OTHER 表のように表示されます。 IECタスクの優先順位 Linux Priority Linux（デフォルト） 0（最高のリアルタイム優先度） 56（ SCHED_FIFO ）。 15（リアルタイムの優先度が最も低い） 41 ( SCHED_FIFO ) 16（リアルタイムの優先順位なし） 0（ SCHED_OTHER ）。 31（リアルタイムの優先順位なし） 0（ SCHED_OTHER ）。 " }, 
{ "title" : "オブジェクト:タスク ", 
"url" : "_cds_f_reference_task.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト:タスク ", 
"snippet" : "タスク シンボル: オブジェクトでタスクを設定します。優先度、タイプと時間動作、ウォッチドッグを設定できます。追加することもできます PROGRAM コール。 オブジェクトは、デバイスツリーの下にあります。 タスク設定 。...", 
"body" : "タスク シンボル: オブジェクトでタスクを設定します。優先度、タイプと時間動作、ウォッチドッグを設定できます。追加することもできます PROGRAM コール。 オブジェクトは、デバイスツリーの下にあります。 タスク設定 。 " }, 
{ "title" : "タブ:構成 ", 
"url" : "_cds_f_reference_task.html#UUID-f12a90d6-4453-79d4-dbff-668d397ebde9", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト:タスク \/ タブ:構成 ", 
"snippet" : "オブジェクト: タスク 優先度 設定可能な値:0.. 31、0 が最高優先度 タスクグループ 割り当てられた タスクグループ マルチコアの特定のプロセッサコアに割り当てることができます 例: IEC タスク 注:タスクグループは、デバイスツリーのタスクの後に括弧で囲まれて表示されます。 Linuxでランタイムシステムを使用する場合、タスクグループと優先度の間に固定の依存関係が存在します。詳細については、以下を参照してください。 Linuxシステムでのタスクの優先順位のマッピング...", 
"body" : "オブジェクト: タスク 優先度 設定可能な値:0.. 31、0 が最高優先度 タスクグループ 割り当てられた タスクグループ マルチコアの特定のプロセッサコアに割り当てることができます 例: IEC タスク 注:タスクグループは、デバイスツリーのタスクの後に括弧で囲まれて表示されます。 Linuxでランタイムシステムを使用する場合、タスクグループと優先度の間に固定の依存関係が存在します。詳細については、以下を参照してください。 Linuxシステムでのタスクの優先順位のマッピング" }, 
{ "title" : "タイプ ", 
"url" : "_cds_f_reference_task.html#UUID-f12a90d6-4453-79d4-dbff-668d397ebde9_id_b3ea97b9439f77fc0a8640e009ee507_id_2c355b338a28d370c0a8646340a97328", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト:タスク \/ タブ:構成 \/ タイプ ", 
"snippet" : "タイプ: 環状 タスクの処理は周期的に行われます。 入力フィールド: 間隔 必須 タスクが再開されるまでの期間 (タスクサイクルタイム) 形式の時間定義として TIME# 例: t#200ms 数値として 例: 200 注:番号は次の形式で自動的に表示されます TIME# 入力フィールドに再びフォーカスが移ったとき。 注:この目的のタスクサイクルタイムからのタスクの偏差は、実行時に定期的なジッターとして表示されます。 タブ:監視 タブ。 間隔の時間単位 に数値のみが指定され、時間の定義は指定されていない場合 間隔 入力フィールド、次にここで選択した単位によって時間ディメンションが決まります。 ...", 
"body" : "タイプ: 環状 タスクの処理は周期的に行われます。 入力フィールド: 間隔 必須 タスクが再開されるまでの期間 (タスクサイクルタイム) 形式の時間定義として TIME# 例: t#200ms 数値として 例: 200 注:番号は次の形式で自動的に表示されます TIME# 入力フィールドに再びフォーカスが移ったとき。 注:この目的のタスクサイクルタイムからのタスクの偏差は、実行時に定期的なジッターとして表示されます。 タブ:監視 タブ。 間隔の時間単位 に数値のみが指定され、時間の定義は指定されていない場合 間隔 入力フィールド、次にここで選択した単位によって時間ディメンションが決まります。 例: ミリ秒 注:µs 単位のタスクサイクルタイムは常に数値で表示されます。 タイプ: [イベント] タスクの処理は、イベント変数の上昇端でイベントトリガーによって開始されます。 入力フィールド: イベント グローバル変数 (ブール型) 変数値が 0 から 1 に切り替わるとすぐにタスクが開始されます。 タイプ: 外部 タスクの処理は、イベント変数の上昇端でイベントトリガーによって開始されます。 リストボックス: イベント ターゲットシステム依存イベントのリスト (Boolean 型) 注:ターゲットシステムによって、どのイベントがサポートされ、リストボックスに表示されるかが決まります。 ヒント:システムイベントと混同しないでください 間隔 での時間定義 TIME# 形式または時間単位の数値としてフォーマットする 注:イベントで時間定義が必要な場合にのみ使用できます タイプ： 自由奔放 タスクの処理は、プログラムの開始時と実行終了後、一定の待機時間後に自動的に連続ループで再開されます。 重要:実行の完了後、タスクが再度実行されるまでに一定時間待機します。この期間は、最後のサイクル期間のパーセンテージです 注:サイクルタイムは定義しません。 タイプ： 状態 タスクの処理は、イベント変数によってステートトリガーされて開始されます 入力フィールド: イベント グローバル変数 (ブール型) 変数の状態が TRUE 、タスクはフリーホイールを開始します。タスクは変数が値を取得するまで実行されます。 FALSE 。 注: 変数は通常、タスク自体でリセットされます。イベントタスクとは対照的に、この方法ではイベントを見逃すことはありません。イベントが発生すると、スケジューラは古い値を保存する必要があり、これはチェックされるよりも頻繁に変更される可能性があります。そのため、イベント変数が次のように変更された場合、 TRUE 短時間だけの場合、スケジューラはこの変更を検出しない可能性があります。これはステータスタスクで回避できます。ステータス変数は次のように設定されます。 TRUE 他のタスクによって実行され、ステータスタスクによってリセットされます。これにより、タスクが切り替わるたびに1回実行されるようになります。 TRUE 。 フィールドバスでは、決まった動作を保証するために固定サイクルマトリックスが必要です。したがって、 タイプ 自由奔放 バスサイクルタスク用。 処理タイプには以下の違いがあることに注意してください。 ステータス と イベント : 指定したイベントで次の結果が出た場合 TRUE 次に、次のタイプのタスクの開始条件 ステータス 満たされています。これとは対照的に、あるタイプのタスクの開始です イベント からのイベントの切り替えが必要 FALSE に TRUE 。タスクスケジューラのサンプリングレートが低すぎると、イベントの盛り上がりが見過ごされてしまうことがあります タスクサイクルタイムを設定するときは、現在使用されているバスシステムを特定する必要があります。たとえば、CAN バスシステムのタスクサイクルタイムは、現在設定されているボーレートとバスで使用されているフレーム数と一致している必要があります。さらに、ハートビート、ノードガーディング、および同期に設定する時間は、常にタスクサイクル時間の倍数でなければなりません。そうしないと、CAN フレームが失われる可能性があります。 詳細については、以下を参照してください。 タブ:監視" }, 
{ "title" : "ウォッチドッグ ", 
"url" : "_cds_f_reference_task.html#UUID-f12a90d6-4453-79d4-dbff-668d397ebde9_section-idm23475286613854", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト:タスク \/ タブ:構成 \/ ウォッチドッグ ", 
"snippet" : "タスクの時間監視を定義します。ターゲットシステムが高度なウォッチドッグ設定をサポートしている場合、デバイスの説明に以下の設定があらかじめ定義されている可能性があります 上限と下限 デフォルトのウォッチドッグ時間 パーセンテージで指定された時間 デフォルトのウォッチドッグ設定はデバイスによって異なります。 有効にする : ウォッチドッグはアクティブです。 タスクがウォッチドッグの現在設定されている時間を超えると、タスクはエラーステータス（例外）で停止します。エラーが発生したタスクのアプリケーションとその子アプリケーションも停止されます。これにより、影響を受けたアプリケーションのすべてのタスクも停...", 
"body" : "タスクの時間監視を定義します。ターゲットシステムが高度なウォッチドッグ設定をサポートしている場合、デバイスの説明に以下の設定があらかじめ定義されている可能性があります 上限と下限 デフォルトのウォッチドッグ時間 パーセンテージで指定された時間 デフォルトのウォッチドッグ設定はデバイスによって異なります。 有効にする : ウォッチドッグはアクティブです。 タスクがウォッチドッグの現在設定されている時間を超えると、タスクはエラーステータス（例外）で停止します。エラーが発生したタスクのアプリケーションとその子アプリケーションも停止されます。これにより、影響を受けたアプリケーションのすべてのタスクも停止されます。次に、現在定義されているのは 感度 も考慮されます。 オプションを有効にした場合 I\/O の更新 で PLC 設定 PLC の、そして CODESYS 出力を定義済みのデフォルト値にリセットします。 考えられるケース: 複数の連続タイムアウト: 感度:0、1 — サイクル 1 では例外 感度:2 — サイクル 2 では例外 感度:n — サイクル n での例外 シングルタイムアウト:現在のサイクルのサイクルタイムが (時間 x 感度) より長い場合は例外です。例:time=T #10ms、感度=5 (つまり、1 回限りのタスクが 50 ミリ秒以上実行されるとすぐに例外が発生する 時間 (例: t#200ms) ウォッチドッグタイム 定義 (とともに) 感度 ) タスクのウォッチドッグ。説明: 有効にする 。 ターゲットシステムによっては、監視期間は、可能であればタスク間隔のパーセンテージとして表示されます。この場合、ユニットのリストボックスは無効になり、表示されます % 。 感度 番号 タスクのウォッチドッグを (ウォッチドッグと一緒に) 定義します。説明は 有効にする 。 ライブラリの関数を使用する CmpIecTask.library 、特定の PLC サイクルの間、ウォッチドッグを非アクティブ化できます。これは、初期化のためにより多くの時間を要するサイクルに役立ちます 例 ウォッチドッグの非アクティブ化\/再アクティブ化: VAR\nhIecTask : RTS_IEC_HANDLE;\nEND_VAR\n\nhIecTask := IecTaskGetCurrent(0);\nIecTaskDisableWatchdog(hIecTask); \/\/Watchdog disabled\n...\nIecTaskEnableWatchdog(hIecTask); \/\/Watchdog enabled ウォッチドッグは、初期化の前に非アクティブ化されます IecTaskDisableWatchDog 残りのサイクルの間、次のサイクルで自動的に再アクティブ化されます。 ウォッチドッグは、初期化後に再アクティブ化できます IecTaskEnableWatchDog .その後、ウォッチドッグはサイクルの残りの部分ですでに再アクティブ化されています (ウォッチドッグの時間ウィンドウは最初から再び開始されます)。 内で発生する機能ブロックの初期化 FB_Init メソッドはこれによる影響を受けません。ただし、通信タイムアウトのため、30 秒未満という制限がありました。オンライン サービスは非同期で実行されるため、この時間制限は V3.5 SP18 以降存在しません。 IEC タスクの実行時間がウォッチドッグ時間を超えると、IEC タスクの通常のウォッチドッグがトリガーされます。 「省略サイクル」ウォッチドッグは、タスクがまったく開始されないときにトリガーされます。これは、タスクが最大値の < サイクルをまったく実行しない場合です 時間 * 感度 > または <2 * 間隔 >。原因としては、他のタスクが混み合っていたり、スケジューラーに障害が発生してタスクを実行できなくなったりすることが考えられます " }, 
{ "title" : "プログラムコール ", 
"url" : "_cds_f_reference_task.html#UUID-f12a90d6-4453-79d4-dbff-668d397ebde9_section-idm234752870373128", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト:タスク \/ タブ:構成 \/ プログラムコール ", 
"snippet" : "POU ( POU タイプ付きのオブジェクト PROGRAM ) はタスクによって連続して呼び出されます。 POU が呼び出される順序は、ここで設定した呼び出し順序の上から下に対応します。 通話を追加 入力アシスタントを開きます。を選択します。 PROGRAM POU。クリックすると OK 入力アシスタントを終了するには、これが新しい呼び出しとして以下のリストに追加されます。 通話を削除 通話を削除します コールを変更 選択した通話の入力アシスタントを開きます。別のものを選択する PROGRAM POU。をクリックすると、コールが変更されます OK 入力アシスタントを終了します。 上へ移動 下...", 
"body" : "POU ( POU タイプ付きのオブジェクト PROGRAM ) はタスクによって連続して呼び出されます。 POU が呼び出される順序は、ここで設定した呼び出し順序の上から下に対応します。 通話を追加 入力アシスタントを開きます。を選択します。 PROGRAM POU。クリックすると OK 入力アシスタントを終了するには、これが新しい呼び出しとして以下のリストに追加されます。 通話を削除 通話を削除します コールを変更 選択した通話の入力アシスタントを開きます。別のものを選択する PROGRAM POU。をクリックすると、コールが変更されます OK 入力アシスタントを終了します。 上へ移動 下に移動 コールの位置をリスト内で上または下に移動します。呼び出し順序は実行時にそれに応じて変わります。 POU を開く の宣言と実装を含む POU エディタを開きます PROGRAM POU " }, 
{ "title" : "オブジェクト: トレース ", 
"url" : "_cds_obj_trace_1.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ オブジェクト \/ オブジェクト: トレース ", 
"snippet" : "痕跡 シンボル： 型のオブジェクト 痕跡 アプリケーション固有のトレース データを 1 つ以上のグラフに構成および表示するために使用されます。アプリケーションの実行時に、トレース変数の値曲線。これは、次のトレース エディターで監視できます。 CODESYS この間、コントローラーに記録されます。 詳細については、以下を参照してください。 ..\/CODESYS トレース\/_cds_obj_trace.html...", 
"body" : "痕跡 シンボル： 型のオブジェクト 痕跡 アプリケーション固有のトレース データを 1 つ以上のグラフに構成および表示するために使用されます。アプリケーションの実行時に、トレース変数の値曲線。これは、次のトレース エディターで監視できます。 CODESYS この間、コントローラーに記録されます。 詳細については、以下を参照してください。 ..\/CODESYS トレース\/_cds_obj_trace.html " }, 
{ "title" : "メニューコマンド ", 
"url" : "_cds_struct_reference_commands.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド ", 
"snippet" : "デフォルトでは、ユーザーインターフェイスのメインコマンドは CODESYS アクセス可能。メニュー設定をカスタマイズする場合は、コマンドを選択します ツール → 調整 → メニュー 。...", 
"body" : "デフォルトでは、ユーザーインターフェイスのメインコマンドは CODESYS アクセス可能。メニュー設定をカスタマイズする場合は、コマンドを選択します ツール → 調整 → メニュー 。 " }, 
{ "title" : "編集するには ", 
"url" : "_cds_f_commands_edit.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "標準コマンド ", 
"url" : "_cds_cmd_standard_edit_commands.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ 標準コマンド ", 
"snippet" : "CODESYS 次の標準コマンドを提供します。 ： やり直し キーボードショートカット： ctrl + Z ： 戻す キーボードショートカット： ctrl + Y ： 切り抜く キーボードショートカット： ctrl + バツ ： コピー キーボードショートカット： ctrl + C ： 入れる キーボードショートカット： ctrl + V ： 消火 キーボードショートカット： 距離 すべてを選択 キーボードショートカット： ctrl + A コマンド 入れる すべてのエディターでサポートされているわけではないか、一部のエディターでのみ使用できます。グラフィカルエディタでは、このコマンドは、貼り...", 
"body" : "CODESYS 次の標準コマンドを提供します。 ： やり直し キーボードショートカット： ctrl + Z ： 戻す キーボードショートカット： ctrl + Y ： 切り抜く キーボードショートカット： ctrl + バツ ： コピー キーボードショートカット： ctrl + C ： 入れる キーボードショートカット： ctrl + V ： 消火 キーボードショートカット： 距離 すべてを選択 キーボードショートカット： ctrl + A コマンド 入れる すべてのエディターでサポートされているわけではないか、一部のエディターでのみ使用できます。グラフィカルエディタでは、このコマンドは、貼り付けによって正しい構成になる場合にのみサポートされます。 POUやデバイスウィンドウなどのオブジェクトツリーでは、コマンドは現在選択されているオブジェクトを参照します。複数選択が可能です。 " }, 
{ "title" : "コマンド：検索、プロジェクトで検索 ", 
"url" : "_cds_cmd_find.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：検索、プロジェクトで検索 ", 
"snippet" : "検索 、プロジェクトで検索 シンボル： キーボードショートカット： ctrl + f シンボル： キーボードショートカット： ctrl + トグル + f 関数 ：コマンドは、プロジェクトまたはプロジェクトの一部で特定の文字列を検索します。 電話 ：メニュー 編集→検索置換 コマンドはダイアログを開きます 検索 、検索する文字列を入力し、検索オプションを定義します。...", 
"body" : "検索 、プロジェクトで検索 シンボル： キーボードショートカット： ctrl + f シンボル： キーボードショートカット： ctrl + トグル + f 関数 ：コマンドは、プロジェクトまたはプロジェクトの一部で特定の文字列を検索します。 電話 ：メニュー 編集→検索置換 コマンドはダイアログを開きます 検索 、検索する文字列を入力し、検索オプションを定義します。 " }, 
{ "title" : "対話：検索 ", 
"url" : "_cds_cmd_find.html#UUID-dda521c8-7f56-fdfd-8ee1-6c9e2a366507_id_a6c8fe1a8c54f84c0a8640e01eb30dd_id_33f08ba0ec4b8c25c0a864636ff12b4d", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：検索、プロジェクトで検索 \/ 対話：検索 ", 
"snippet" : "検索する 検索する文字列 大文字と小文字を区別 ：検索では大文字と小文字が区別されます。 全文のみ ：検索された文字列と完全に一致する文字列のみが検索されます。 見上げる ：指定されたサーチスペースが上方向にトラバースされます。 ：指定されたサーチスペースが下方向にトラバースされます。 正規表現を使用する ボタンについて 正規表現を入力するときにサポートを受けます。 で検索 ：検索するプロジェクトの領域を含む選択リスト アクティブエディタ 開いているすべてのエディター 選択したオブジェクトとサブオブジェクト プロジェクト全体 プロジェクト全体とコンパイルされていないライブラリ 選択のみ ：検索...", 
"body" : "検索する 検索する文字列 大文字と小文字を区別 ：検索では大文字と小文字が区別されます。 全文のみ ：検索された文字列と完全に一致する文字列のみが検索されます。 見上げる ：指定されたサーチスペースが上方向にトラバースされます。 ：指定されたサーチスペースが下方向にトラバースされます。 正規表現を使用する ボタンについて 正規表現を入力するときにサポートを受けます。 で検索 ：検索するプロジェクトの領域を含む選択リスト アクティブエディタ 開いているすべてのエディター 選択したオブジェクトとサブオブジェクト プロジェクト全体 プロジェクト全体とコンパイルされていないライブラリ 選択のみ ：検索するプロジェクトの領域を設定できるダイアログを開きます（以下を参照） 見続ける 検索を開始します すべての検索 すべての検索結果は、オブジェクトパス、プロジェクト名、オブジェクト名、およびオブジェクト位置に関する情報とともにメッセージウィンドウに表示されます。ポジションへの可能な追加： （decl） =オブジェクトの宣言部分、 （実装） =オブジェクトの実装部分 リストエントリをダブルクリックすると、フォーカスがそれぞれのオブジェクトエディタのヒット位置にジャンプします。 代わりの 対話に切り替える 代わりの 検索結果マーカーの色は、 テキストエディタのオプション 調整されます。これは、パラメータを使用して行われます 選択色 - 非活性 タブ内 テキストエリア 。 " }, 
{ "title" : "検索するオブジェクトを設定するためのダイアログ ", 
"url" : "_cds_cmd_find.html#UUID-dda521c8-7f56-fdfd-8ee1-6c9e2a366507_id_a6c8fe1a8c54f84c0a8640e01eb30dd_id_5df2ec8bf5f911e3b101fb023b1f8cd5", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：検索、プロジェクトで検索 \/ 検索するオブジェクトを設定するためのダイアログ ", 
"snippet" : "プロジェクト全体 プロジェクトのすべてのオブジェクトの編集可能なすべての位置が検索されます。 プロジェクト全体とすべてのコンパイルされていないライブラリ プロジェクトのすべてのオブジェクトおよびリンクされた、コンパイルされていないライブラリ内のすべての編集可能な位置が検索されます 以下のオブジェクト内 ここで定義されたオブジェクト内の編集可能な場所のみが検索されます。 図式 ：コマンドによる コンピューターに保存 現在の検索構成は、指定された名前で保存されます。保存されたすべてのスキームには、選択リストからアクセスできます（ ）アクセス可能。 オブジェクトタイプ ： ：オブジェクトが検索されま...", 
"body" : "プロジェクト全体 プロジェクトのすべてのオブジェクトの編集可能なすべての位置が検索されます。 プロジェクト全体とすべてのコンパイルされていないライブラリ プロジェクトのすべてのオブジェクトおよびリンクされた、コンパイルされていないライブラリ内のすべての編集可能な位置が検索されます 以下のオブジェクト内 ここで定義されたオブジェクト内の編集可能な場所のみが検索されます。 図式 ：コマンドによる コンピューターに保存 現在の検索構成は、指定された名前で保存されます。保存されたすべてのスキームには、選択リストからアクセスできます（ ）アクセス可能。 オブジェクトタイプ ： ：オブジェクトが検索されます。 名前フィルター ：検索するオブジェクトの名前フィルター ワイルドカード「*」を使用できます。 例：フィルター「* CAN *」：名前に「CAN」が含まれるすべてのオブジェクトが検索されます。 開いているすべてのエディター 現在ウィンドウで開いているすべてのエディタが検索されます。 アクティブエディタ カーソルが置かれているエディタのみが検索されます。 選択のみ オブジェクトで現在選択されているテキストのみが検索されます。 " }, 
{ "title" : "コマンド：置換、プロジェクトで置換 ", 
"url" : "_cds_cmd_replace.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：置換、プロジェクトで置換 ", 
"snippet" : "置換、プロジェクトで置換 シンボル： キーボードショートカット： ctrl + H シンボル： キーボードショートカット： ctrl + トグル + H 関数 ：コマンドは、プロジェクトまたはプロジェクトの一部で特定の文字列を検索し、それを置き換えます。 電話 ：メニュー 編集→検索置換 要件 ：アプリケーションはオンラインモードです。 コマンドはダイアログを開きます 代わりの 、置換する文字列と新しい文字列を入力し、検索オプションを定義します。 [検索]ダイアログのオプションに加えて、次の設定も可能です。 と置換する 新しい文字列の入力フィールド 代わりの これにより、エディターで見つかった...", 
"body" : "置換、プロジェクトで置換 シンボル： キーボードショートカット： ctrl + H シンボル： キーボードショートカット： ctrl + トグル + H 関数 ：コマンドは、プロジェクトまたはプロジェクトの一部で特定の文字列を検索し、それを置き換えます。 電話 ：メニュー 編集→検索置換 要件 ：アプリケーションはオンラインモードです。 コマンドはダイアログを開きます 代わりの 、置換する文字列と新しい文字列を入力し、検索オプションを定義します。 [検索]ダイアログのオプションに加えて、次の設定も可能です。 と置換する 新しい文字列の入力フィールド 代わりの これにより、エディターで見つかった次の文字列が強調表示されて置き換えられます（段階的な置き換え）。 すべてを交換してください 見つかったすべての文字列は、エディタに表示されずに一度に置き換えられます。 すべて置換後、変更されたオブジェクトは開いたままにします 見つかったオブジェクトのエディターは開いたままです。 参照ライブラリを置き換えることはできません。 " }, 
{ "title" : "コマンド：次を検索 ", 
"url" : "_cds_cmd_find_next.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：次を検索 ", 
"snippet" : "見続ける シンボル： キーボードショートカット： F3 関数 ：プロジェクト内の特定の文字列を検索する場合、このコマンドは、関連するエディターのその位置で次の検索結果を選択します。 電話 ：メニュー 編集→検索置換 要件 ：コマンドを使用する必要があります 検索 また 代わりの プロジェクト内の特定の文字列の検索を開始します。 詳細については、以下を参照してください。 プロジェクト全体の検索と置換...", 
"body" : "見続ける シンボル： キーボードショートカット： F3 関数 ：プロジェクト内の特定の文字列を検索する場合、このコマンドは、関連するエディターのその位置で次の検索結果を選択します。 電話 ：メニュー 編集→検索置換 要件 ：コマンドを使用する必要があります 検索 また 代わりの プロジェクト内の特定の文字列の検索を開始します。 詳細については、以下を参照してください。 プロジェクト全体の検索と置換" }, 
{ "title" : "コマンド：次を検索（選択） ", 
"url" : "_cds_cmd_find_next_selected.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：次を検索（選択） ", 
"snippet" : "さらに検索（選択） キーボードショートカット： ctrl + f 関数 ：このコマンドは、現在選択されている文字列またはカーソルが現在置かれている文字列と一致するプロジェクト内の次の文字列を検索します。 電話 ：メニュー 編集→検索置換 要件 ：プロジェクト内の編集可能な文字列にカーソルを置いたか、編集可能な文字列を選択しました。 詳細については、以下を参照してください。 プロジェクト全体の検索と置換...", 
"body" : "さらに検索（選択） キーボードショートカット： ctrl + f 関数 ：このコマンドは、現在選択されている文字列またはカーソルが現在置かれている文字列と一致するプロジェクト内の次の文字列を検索します。 電話 ：メニュー 編集→検索置換 要件 ：プロジェクト内の編集可能な文字列にカーソルを置いたか、編集可能な文字列を選択しました。 詳細については、以下を参照してください。 プロジェクト全体の検索と置換" }, 
{ "title" : "コマンド：前を検索 ", 
"url" : "_cds_cmd_find_previous.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：前を検索 ", 
"snippet" : "前を検索 シンボル： キーボードショートカット： トグル + F3 関数 ：プロジェクト内の特定の文字列を検索する場合、このコマンドは、関連するエディターのその位置で前の検索結果を選択します。 電話 ：メニュー 編集→検索置換 要件 ：コマンドを使用する必要があります 検索 また 代わりの プロジェクト内の特定の文字列の検索が開始されます。 詳細については、以下を参照してください。 ブックマークを設定して使用する...", 
"body" : "前を検索 シンボル： キーボードショートカット： トグル + F3 関数 ：プロジェクト内の特定の文字列を検索する場合、このコマンドは、関連するエディターのその位置で前の検索結果を選択します。 電話 ：メニュー 編集→検索置換 要件 ：コマンドを使用する必要があります 検索 また 代わりの プロジェクト内の特定の文字列の検索が開始されます。 詳細については、以下を参照してください。 ブックマークを設定して使用する" }, 
{ "title" : "コマンド：前を検索（選択） ", 
"url" : "_cds_cmd_find_previous_selected.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：前を検索（選択） ", 
"snippet" : "前を検索（選択） キーボードショートカット： ctrl + トグル + F3 関数 ：このコマンドは、現在選択されている文字列またはカーソルが現在置かれている文字列と一致するプロジェクト内の前の文字列を検索します。 電話 ：メニュー 編集→検索置換 要件 ：プロジェクト内の編集可能な文字列にカーソルを置いたか、編集可能な文字列を選択しました。 詳細については、以下を参照してください。 プロジェクト全体の検索と置換...", 
"body" : "前を検索（選択） キーボードショートカット： ctrl + トグル + F3 関数 ：このコマンドは、現在選択されている文字列またはカーソルが現在置かれている文字列と一致するプロジェクト内の前の文字列を検索します。 電話 ：メニュー 編集→検索置換 要件 ：プロジェクト内の編集可能な文字列にカーソルを置いたか、編集可能な文字列を選択しました。 詳細については、以下を参照してください。 プロジェクト全体の検索と置換" }, 
{ "title" : "コマンド：ファイルをテキストとして貼り付けます ", 
"url" : "_cds_cmd_insert_file_as_text.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：ファイルをテキストとして貼り付けます ", 
"snippet" : "ファイルをテキストとして貼り付ける 関数 ：このコマンドは、テキストファイルの内容をアクティブなエディタの現在のカーソル位置にコピーします。 電話 ：このコマンドは、デフォルトではどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから テキストエディタ メニューに貼り付けます。 要件 ：ファイルの拡張子はファイル拡張子である必要があります .txt 持つため。このコマンドは、テキストエディタでのみ使用できます。 多くの開発環境とワードプロセッシングプログラムは、コードとテキストをテキストファイルとしてエクスポートする可能性を...", 
"body" : "ファイルをテキストとして貼り付ける 関数 ：このコマンドは、テキストファイルの内容をアクティブなエディタの現在のカーソル位置にコピーします。 電話 ：このコマンドは、デフォルトではどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから テキストエディタ メニューに貼り付けます。 要件 ：ファイルの拡張子はファイル拡張子である必要があります .txt 持つため。このコマンドは、テキストエディタでのみ使用できます。 多くの開発環境とワードプロセッシングプログラムは、コードとテキストをテキストファイルとしてエクスポートする可能性を提供します。このファイルの内容は、このコマンドでメモ帳にコピーできます。 詳細については、以下を参照してください。 テキストエディタ" }, 
{ "title" : "コマンド：上書きモード ", 
"url" : "_cds_cmd_overwrite_mode.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：上書きモード ", 
"snippet" : "上書きモード キーボードショートカット： 入れる 関数 ：このコマンド\\は上書きモードを有効にします。 電話 ：メニュー 編集→詳細 要件 ：テキストエディタが開いています。 上書きモードがオンの場合、新しい文字を入力すると、カーソルの前の文字が上書きされます。上書きモードがオフの場合、文字が挿入され、カーソルの前の既存の文字が保持されます。...", 
"body" : "上書きモード キーボードショートカット： 入れる 関数 ：このコマンド\\は上書きモードを有効にします。 電話 ：メニュー 編集→詳細 要件 ：テキストエディタが開いています。 上書きモードがオンの場合、新しい文字を入力すると、カーソルの前の文字が上書きされます。上書きモードがオフの場合、文字が挿入され、カーソルの前の既存の文字が保持されます。 " }, 
{ "title" : "コマンド：スペースを表示 ", 
"url" : "_cds_cmd_view_whitespace.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：スペースを表示 ", 
"snippet" : "スペースを表示 シンボル： 関数 ：このコマンドにより、スペースとタブの制御文字が表示されます。 電話 ：メニュー 編集→詳細 要件 ：テキストエディタが開いています。 CODESYS スペースをドットで視覚化し、タブを矢印で視覚化します。 詳細については、以下を参照してください。 テキストエディタ...", 
"body" : "スペースを表示 シンボル： 関数 ：このコマンドにより、スペースとタブの制御文字が表示されます。 電話 ：メニュー 編集→詳細 要件 ：テキストエディタが開いています。 CODESYS スペースをドットで視覚化し、タブを矢印で視覚化します。 詳細については、以下を参照してください。 テキストエディタ" }, 
{ "title" : "コマンド：インデントガイドを表示 ", 
"url" : "_cds_cmd_view_indentation_guide.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：インデントガイドを表示 ", 
"snippet" : "インデントガイドを表示する 関数 ：コマンドはインデントガイドをオンにします。 電話 ：メニュー 編集→詳細 要件 ：テキストエディタが開いています。 インデントガイドをオンにすると、コード内の手動インデントごとに破線が挿入されます。これにより、コード内のさまざまなレベルを追跡しやすくなります。ボタンを使用して手動でインデントできます タブ 入れる。 詳細については、以下を参照してください。 テキストエディタ...", 
"body" : "インデントガイドを表示する 関数 ：コマンドはインデントガイドをオンにします。 電話 ：メニュー 編集→詳細 要件 ：テキストエディタが開いています。 インデントガイドをオンにすると、コード内の手動インデントごとに破線が挿入されます。これにより、コード内のさまざまなレベルを追跡しやすくなります。ボタンを使用して手動でインデントできます タブ 入れる。 詳細については、以下を参照してください。 テキストエディタ" }, 
{ "title" : "コマンド：行に移動 ", 
"url" : "_cds_cmd_go_to_line.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：行に移動 ", 
"snippet" : "行に移動 関数 ：コマンドは、コード内の定義された行にカーソルをジャンプします。 電話 ：メニュー 編集→詳細 要件 ：テキストエディタが開いています。 このコマンドは、入力フィールドを含むダイアログを開きます 行番号 。...", 
"body" : "行に移動 関数 ：コマンドは、コード内の定義された行にカーソルをジャンプします。 電話 ：メニュー 編集→詳細 要件 ：テキストエディタが開いています。 このコマンドは、入力フィールドを含むダイアログを開きます 行番号 。 " }, 
{ "title" : "コマンド：大文字に変換 ", 
"url" : "_cds_cmd_make_uppercase.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：大文字に変換 ", 
"snippet" : "大文字に変換する キーボードショートカット： ctrl + トグル + u 関数 ：このコマンドは、選択したコード内のすべての小文字を大文字に変換します。 電話 ：メニュー 編集→詳細 要件 ：テキストエディタが開いていてコードが選択されているか、宣言エディタが開いていて変数宣言が選択されています。 詳細については、以下を参照してください。 テキストエディタ...", 
"body" : "大文字に変換する キーボードショートカット： ctrl + トグル + u 関数 ：このコマンドは、選択したコード内のすべての小文字を大文字に変換します。 電話 ：メニュー 編集→詳細 要件 ：テキストエディタが開いていてコードが選択されているか、宣言エディタが開いていて変数宣言が選択されています。 詳細については、以下を参照してください。 テキストエディタ" }, 
{ "title" : "コマンド：小文字に変換 ", 
"url" : "_cds_cmd_make_lowercase.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：小文字に変換 ", 
"snippet" : "小文字に変換する キーボードショートカット： ctrl + u 関数 ：このコマンドは、選択したコードのすべての大文字を小文字に変換します。 電話 ：メニュー 編集→詳細 要件 ：テキストエディタが開いていてコードが選択されているか、宣言エディタが開いていて変数宣言が選択されています。 詳細については、以下を参照してください。 テキストエディタ...", 
"body" : "小文字に変換する キーボードショートカット： ctrl + u 関数 ：このコマンドは、選択したコードのすべての大文字を小文字に変換します。 電話 ：メニュー 編集→詳細 要件 ：テキストエディタが開いていてコードが選択されているか、宣言エディタが開いていて変数宣言が選択されています。 詳細については、以下を参照してください。 テキストエディタ" }, 
{ "title" : "コマンド：一致するブラケットに移動します ", 
"url" : "_cds_cmd_go_to_matching_bracket.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：一致するブラケットに移動します ", 
"snippet" : "関連するブラケットに移動します 関数 ：このコマンドは、選択したコードブラケットの他の部分にカーソルをジャンプさせます。 電話 ：メニュー 編集→詳細 要件 ：テキストエディタが開いており、カーソルが開始または終了のコードブラケットに置かれています。カーソルをコードブラケットに置くと、が表示されます CODESYS オプションを選択した場合は、対応するブラケットに色を付けます 一致するブラケット の中に CODESYS -カテゴリのプロジェクトオプション テキストエディタ 、 タブ テキストエリア 有効になりました。...", 
"body" : "関連するブラケットに移動します 関数 ：このコマンドは、選択したコードブラケットの他の部分にカーソルをジャンプさせます。 電話 ：メニュー 編集→詳細 要件 ：テキストエディタが開いており、カーソルが開始または終了のコードブラケットに置かれています。カーソルをコードブラケットに置くと、が表示されます CODESYS オプションを選択した場合は、対応するブラケットに色を付けます 一致するブラケット の中に CODESYS -カテゴリのプロジェクトオプション テキストエディタ 、 タブ テキストエリア 有効になりました。 " }, 
{ "title" : "コマンド：対応するブラケットまで選択します ", 
"url" : "_cds_cmd_select_to_matching_bracket.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：対応するブラケットまで選択します ", 
"snippet" : "関連するブラケットまで選択 関数 ：このコマンドは、現在選択されているコードブラケットの下のコードセクション全体を選択します。 電話 ：メニュー 編集→詳細 要件 ：テキストエディタが開いており、カーソルが開始または終了のコードブラケットに置かれています。カーソルをコードブラケットに置くと、が表示されます CODESYS オプションを選択した場合は、対応するブラケットに色を付けます 一致するブラケット の中に CODESYS -カテゴリのプロジェクトオプション テキストエディタ 、 タブ テキストエリア 有効になりました。 詳細については、以下を参照してください。 テキストエディタ...", 
"body" : "関連するブラケットまで選択 関数 ：このコマンドは、現在選択されているコードブラケットの下のコードセクション全体を選択します。 電話 ：メニュー 編集→詳細 要件 ：テキストエディタが開いており、カーソルが開始または終了のコードブラケットに置かれています。カーソルをコードブラケットに置くと、が表示されます CODESYS オプションを選択した場合は、対応するブラケットに色を付けます 一致するブラケット の中に CODESYS -カテゴリのプロジェクトオプション テキストエディタ 、 タブ テキストエリア 有効になりました。 詳細については、以下を参照してください。 テキストエディタ" }, 
{ "title" : "コマンド：すべて展開 ", 
"url" : "_cds_cmd_expand_all.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：すべて展開 ", 
"snippet" : "すべてを展開します 関数 ：このコマンドは、テキストエディタのすべての縮小コードセクション（および記号）または相互参照リストの参照を展開して、コードまたはすべての参照が再び完全に表示されるようにします。 要件 ：テキストエディタがアクティブで、ダイアログ内にあります オプション 、 カテゴリー テキストエディタ インデントが有効になっています。または、相互参照リストがアクティブです。 電話 ：テキストエディタの場合：メニュー 編集→詳細 、 コンテキストメニュー;相互参照リスト：コンテキストメニュー 詳細については、以下を参照してください。 テキストエディタ...", 
"body" : "すべてを展開します 関数 ：このコマンドは、テキストエディタのすべての縮小コードセクション（および記号）または相互参照リストの参照を展開して、コードまたはすべての参照が再び完全に表示されるようにします。 要件 ：テキストエディタがアクティブで、ダイアログ内にあります オプション 、 カテゴリー テキストエディタ インデントが有効になっています。または、相互参照リストがアクティブです。 電話 ：テキストエディタの場合：メニュー 編集→詳細 、 コンテキストメニュー;相互参照リスト：コンテキストメニュー 詳細については、以下を参照してください。 テキストエディタ" }, 
{ "title" : "コマンド：すべて折りたたむ ", 
"url" : "_cds_cmd_collapse_all.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：すべて折りたたむ ", 
"snippet" : "すべてを折りたたむ 関数 ：このコマンドは、テキストエディタのコードのインデントされたすべてのセクション（ルートノードのマイナス記号）または相互参照リストのオカレンスを同時に折りたたみます。その結果、コードの最上位レベルのみ、または見つかった場所のルートノードのみが表示されます。 要件 ：テキストエディタがアクティブで、ダイアログ内にあります オプション 、 カテゴリー テキストエディタ インデントが有効になっています。または、相互参照リストがアクティブです。 電話 ：テキストエディタの場合：メニュー 編集→詳細 、 コンテキストメニュー;相互参照リスト：コンテキストメニュー 詳細については、...", 
"body" : "すべてを折りたたむ 関数 ：このコマンドは、テキストエディタのコードのインデントされたすべてのセクション（ルートノードのマイナス記号）または相互参照リストのオカレンスを同時に折りたたみます。その結果、コードの最上位レベルのみ、または見つかった場所のルートノードのみが表示されます。 要件 ：テキストエディタがアクティブで、ダイアログ内にあります オプション 、 カテゴリー テキストエディタ インデントが有効になっています。または、相互参照リストがアクティブです。 電話 ：テキストエディタの場合：メニュー 編集→詳細 、 コンテキストメニュー;相互参照リスト：コンテキストメニュー 詳細については、以下を参照してください。 テキストエディタ" }, 
{ "title" : "コマンド：選択した行をコメントアウトします ", 
"url" : "_cds_cmd_comment_out.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：選択した行をコメントアウトします ", 
"snippet" : "選択した行をコメントアウトする シンボル： キーボードショートカット： ctrl + O 関数 ：コマンドは、選択した行の先頭にコメント文字（ '\/\/'）を挿入します。 電話 ：メニュー 編集→詳細 、 コンテキストメニュー 要件 ：カーソルがSTエディターの実装の行にあるか、STエディターで複数の行が選択されています。...", 
"body" : "選択した行をコメントアウトする シンボル： キーボードショートカット： ctrl + O 関数 ：コマンドは、選択した行の先頭にコメント文字（ '\/\/'）を挿入します。 電話 ：メニュー 編集→詳細 、 コンテキストメニュー 要件 ：カーソルがSTエディターの実装の行にあるか、STエディターで複数の行が選択されています。 " }, 
{ "title" : "コマンド：選択した行からコメントを削除します ", 
"url" : "_cds_cmd_uncomment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：選択した行からコメントを削除します ", 
"snippet" : "選択した行からコメントを削除する シンボル 、 キーボードショートカット CTRL + 私 関数 ： 電話 ：メニュー 編集するには -> 高度 、 コンテキストメニュー 要件 ：カーソルがSTエディターの実装の行にあるか、STエディターで複数の行が選択されています。...", 
"body" : "選択した行からコメントを削除する シンボル 、 キーボードショートカット CTRL + 私 関数 ： 電話 ：メニュー 編集するには -> 高度 、 コンテキストメニュー 要件 ：カーソルがSTエディターの実装の行にあるか、STエディターで複数の行が選択されています。 " }, 
{ "title" : "コマンド: インライン監視を有効にする ", 
"url" : "_cds_cmd_toggle_inline_monitoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド: インライン監視を有効にする ", 
"snippet" : "インライン監視を有効にする 関数 : このコマンドは、「インライン監視」機能を有効または無効にします。これは、 テキストエディタ オプションでは、 テキストエディタ カテゴリー。 要件 : テキスト エディターがアクティブです。 電話 : テキストエディタのコンテキストメニュー（ 高度な ） 詳細については、以下を参照してください。 価値の監視...", 
"body" : "インライン監視を有効にする 関数 : このコマンドは、「インライン監視」機能を有効または無効にします。これは、 テキストエディタ オプションでは、 テキストエディタ カテゴリー。 要件 : テキスト エディターがアクティブです。 電話 : テキストエディタのコンテキストメニュー（ 高度な ） 詳細については、以下を参照してください。 価値の監視" }, 
{ "title" : "コマンド：ブックマークのオン\/オフを切り替えます ", 
"url" : "_cds_cmd_toggle_bookmark.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：ブックマークのオン\/オフを切り替えます ", 
"snippet" : "ブックマークのオン\/オフを切り替える シンボル： キーボードショートカット： ctrl + F12 関数 ：コマンドは、現在の位置にブックマークを設定または削除します。 電話 ：メニュー 編集→ブックマーク 要件 ：POUがエディターで開いており、カーソルがプログラム行にあります。 詳細については、以下を参照してください。 ブックマークを設定して使用する...", 
"body" : "ブックマークのオン\/オフを切り替える シンボル： キーボードショートカット： ctrl + F12 関数 ：コマンドは、現在の位置にブックマークを設定または削除します。 電話 ：メニュー 編集→ブックマーク 要件 ：POUがエディターで開いており、カーソルがプログラム行にあります。 詳細については、以下を参照してください。 ブックマークを設定して使用する" }, 
{ "title" : "コマンド：次のブックマーク（アクティブエディター） ", 
"url" : "_cds_cmd_next_bookmark_active_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：次のブックマーク（アクティブエディター） ", 
"snippet" : "次のブックマーク（アクティブエディタ） シンボル： キーボードショートカット： F12 関数 ：コマンドは、アクティブなエディターの次のブックマークにジャンプします。 電話 ：メニュー 編集→ブックマーク 要件 ：POUがエディターで開いており、カーソルがPOUにあります。 詳細については、以下を参照してください。 ブックマークを設定して使用する...", 
"body" : "次のブックマーク（アクティブエディタ） シンボル： キーボードショートカット： F12 関数 ：コマンドは、アクティブなエディターの次のブックマークにジャンプします。 電話 ：メニュー 編集→ブックマーク 要件 ：POUがエディターで開いており、カーソルがPOUにあります。 詳細については、以下を参照してください。 ブックマークを設定して使用する" }, 
{ "title" : "コマンド：次のブックマーク ", 
"url" : "_cds_cmd_next_bookmark_global.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：次のブックマーク ", 
"snippet" : "次のブックマーク シンボル： 関数 ：コマンドがビューにジャンプします ブックマーク プロジェクトで次のブックマークに移動し、対応するPOUを開きます。ブックマークがジャンプされる順序は、ビューのテーブル内のブックマークの順序に対応します。 ブックマーク 。 電話 ： ボタン 次のブックマーク ビューで ブックマーク デフォルトでは、コマンドはどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから ブックマーク メニューに貼り付けます。 要件 ： プロジェクトが開いています。 景色 ブックマーク が開かれます。 詳細について...", 
"body" : "次のブックマーク シンボル： 関数 ：コマンドがビューにジャンプします ブックマーク プロジェクトで次のブックマークに移動し、対応するPOUを開きます。ブックマークがジャンプされる順序は、ビューのテーブル内のブックマークの順序に対応します。 ブックマーク 。 電話 ： ボタン 次のブックマーク ビューで ブックマーク デフォルトでは、コマンドはどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから ブックマーク メニューに貼り付けます。 要件 ： プロジェクトが開いています。 景色 ブックマーク が開かれます。 詳細については、以下を参照してください。 ブックマークを設定して使用する" }, 
{ "title" : "コマンド：前のブックマーク（アクティブエディター） ", 
"url" : "_cds_cmd_previous_bookmark_active_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：前のブックマーク（アクティブエディター） ", 
"snippet" : "前のブックマーク（アクティブエディター） シンボル： キーボードショートカット： トグル + F12 関数 ：コマンドは、アクティブなエディターの前のブックマークにジャンプします。 電話 ：メニュー 編集→ブックマーク POUはエディターで開いており、カーソルはPOUにあります。 詳細については、以下を参照してください。 プロジェクト全体の検索と置換...", 
"body" : "前のブックマーク（アクティブエディター） シンボル： キーボードショートカット： トグル + F12 関数 ：コマンドは、アクティブなエディターの前のブックマークにジャンプします。 電話 ：メニュー 編集→ブックマーク POUはエディターで開いており、カーソルはPOUにあります。 詳細については、以下を参照してください。 プロジェクト全体の検索と置換" }, 
{ "title" : "コマンド：前のブックマーク ", 
"url" : "_cds_cmd_previous_bookmark_global.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：前のブックマーク ", 
"snippet" : "前のブックマーク シンボル： 関数 ：コマンドがビューにジャンプします ブックマーク プロジェクトで前のブックマークに移動し、対応するPOUを開きます。ブックマークがジャンプされる順序は、ビューのテーブル内のブックマークの順序に対応します。 ブックマーク 。 電話 ： ボタン 前のブックマーク ビューで ブックマーク デフォルトでは、コマンドはどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから ブックマーク メニューに貼り付けます。 要件 ： プロジェクトが開いています。 景色 ブックマーク が開かれます。 詳細について...", 
"body" : "前のブックマーク シンボル： 関数 ：コマンドがビューにジャンプします ブックマーク プロジェクトで前のブックマークに移動し、対応するPOUを開きます。ブックマークがジャンプされる順序は、ビューのテーブル内のブックマークの順序に対応します。 ブックマーク 。 電話 ： ボタン 前のブックマーク ビューで ブックマーク デフォルトでは、コマンドはどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから ブックマーク メニューに貼り付けます。 要件 ： プロジェクトが開いています。 景色 ブックマーク が開かれます。 詳細については、以下を参照してください。 ブックマークを設定して使用する" }, 
{ "title" : "コマンド：すべてのブックマークをクリア（アクティブエディター） ", 
"url" : "_cds_cmd_clear_all_bookmarks_active_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：すべてのブックマークをクリア（アクティブエディター） ", 
"snippet" : "すべてのブックマークを削除する（アクティブエディター） シンボル： 関数 ：このコマンドは、アクティブなエディターのすべてのブックマークを削除します。 電話 ：メニュー 編集→ブックマーク 要件 ：POUがエディターで開いており、カーソルがPOUにあります。 詳細については、以下を参照してください。 ブックマークを設定して使用する...", 
"body" : "すべてのブックマークを削除する（アクティブエディター） シンボル： 関数 ：このコマンドは、アクティブなエディターのすべてのブックマークを削除します。 電話 ：メニュー 編集→ブックマーク 要件 ：POUがエディターで開いており、カーソルがPOUにあります。 詳細については、以下を参照してください。 ブックマークを設定して使用する" }, 
{ "title" : "コマンド：すべてのブックマークを削除します ", 
"url" : "_cds_cmd_clear_all_bookmarks_global.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：すべてのブックマークを削除します ", 
"snippet" : "すべてのブックマークを削除する シンボル： 関数 ：このコマンドは、開いているプロジェクトのすべてのブックマークを削除します。 電話 ：このコマンドは、デフォルトではどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから ブックマーク メニューに貼り付けます。 要件 ：POUがエディターで開いており、カーソルがPOUにあります。 詳細については、以下を参照してください。 ブックマークを設定して使用する...", 
"body" : "すべてのブックマークを削除する シンボル： 関数 ：このコマンドは、開いているプロジェクトのすべてのブックマークを削除します。 電話 ：このコマンドは、デフォルトではどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから ブックマーク メニューに貼り付けます。 要件 ：POUがエディターで開いており、カーソルがPOUにあります。 詳細については、以下を参照してください。 ブックマークを設定して使用する" }, 
{ "title" : "コマンド：相互参照を出力します ", 
"url" : "_cds_cmd_browse_cross_references.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：相互参照を出力します ", 
"snippet" : "出力相互参照 シンボル： 関数 ：コマンドは、ビューで変数が使用されているすべての場所を表示します 相互参照リスト 。 電話 ：メニュー 編集→検索アイコン 、ビューのツールバー 相互参照リスト 要件 ：POUがエディターで開いており、カーソルが変数内にあります。またはビュー 相互参照リスト が開いていて、変数がフィールドにあります 姓 指定。 詳細については、以下を参照してください。 相互参照リストで使用場所を見つける...", 
"body" : "出力相互参照 シンボル： 関数 ：コマンドは、ビューで変数が使用されているすべての場所を表示します 相互参照リスト 。 電話 ：メニュー 編集→検索アイコン 、ビューのツールバー 相互参照リスト 要件 ：POUがエディターで開いており、カーソルが変数内にあります。またはビュー 相互参照リスト が開いていて、変数がフィールドにあります 姓 指定。 詳細については、以下を参照してください。 相互参照リストで使用場所を見つける" }, 
{ "title" : "コマンド：グローバル相互参照を出力する ", 
"url" : "_cds_cmd_browse_global_cross_references.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：グローバル相互参照を出力する ", 
"snippet" : "グローバル相互参照を出力する シンボル： 関数 ：コマンドは、ビューに同じ名前のすべての変数の使用場所を表示します 相互参照リスト 。コマンドに反して 出力相互参照 異なる変数にすることができます。 電話 ：メニュー 編集→検索アイコン 、ビューのツールバー 相互参照リスト 要件 ：POUがエディターで開いており、カーソルが変数内にあります。またはビュー 相互参照リスト が開いていて、変数がフィールドにあります 姓 指定。 詳細については、以下を参照してください。 相互参照リストで使用場所を見つける...", 
"body" : "グローバル相互参照を出力する シンボル： 関数 ：コマンドは、ビューに同じ名前のすべての変数の使用場所を表示します 相互参照リスト 。コマンドに反して 出力相互参照 異なる変数にすることができます。 電話 ：メニュー 編集→検索アイコン 、ビューのツールバー 相互参照リスト 要件 ：POUがエディターで開いており、カーソルが変数内にあります。またはビュー 相互参照リスト が開いていて、変数がフィールドにあります 姓 指定。 詳細については、以下を参照してください。 相互参照リストで使用場所を見つける" }, 
{ "title" : "コマンド：出力呼び出しツリー ", 
"url" : "_cds_cmd_browse_call_tree.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：出力呼び出しツリー ", 
"snippet" : "出力呼び出しツリー シンボル： 関数 ：コマンドはビューを開きます ツリーを呼び出す 、ビルディングブロックとその呼び出し元の呼び出しを表します。 電話 ： メニュー 編集→検索アイコン コンテキストメニュー 要件 ：ブロックがエディターで開いていて、カーソルが変数内にあるか、ブロックがビュー内にあります 装置 また POU 選択されました。...", 
"body" : "出力呼び出しツリー シンボル： 関数 ：コマンドはビューを開きます ツリーを呼び出す 、ビルディングブロックとその呼び出し元の呼び出しを表します。 電話 ： メニュー 編集→検索アイコン コンテキストメニュー 要件 ：ブロックがエディターで開いていて、カーソルが変数内にあるか、ブロックがビュー内にあります 装置 また POU 選択されました。 " }, 
{ "title" : "コマンド：変数を宣言する ", 
"url" : "_cds_cmd_declare_variable.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：変数を宣言する ", 
"snippet" : "変数を宣言する キーボードショートカット： トグル + F2 関数 ：コマンドはダイアログを開きます 変数を宣言する 、変数の宣言をサポートします。 電話 ：メニュー 編集するには 要件 ：プロジェクトのオブジェクトまたはデバイスがエディターで開いています。 自動宣言機能によりダイアログが表示されます 変数を宣言する また、宣言されていない変数の名前を含むPOUの実装部分でカーソルが1行にある場合も同様です。このための前提条件として、コマンドが必要です ツール→オプション 選択され、カテゴリに スマートコーディング オプション 不明な変数を自動的に宣言する（AutoDeclare） 有効になり...", 
"body" : "変数を宣言する キーボードショートカット： トグル + F2 関数 ：コマンドはダイアログを開きます 変数を宣言する 、変数の宣言をサポートします。 電話 ：メニュー 編集するには 要件 ：プロジェクトのオブジェクトまたはデバイスがエディターで開いています。 自動宣言機能によりダイアログが表示されます 変数を宣言する また、宣言されていない変数の名前を含むPOUの実装部分でカーソルが1行にある場合も同様です。このための前提条件として、コマンドが必要です ツール→オプション 選択され、カテゴリに スマートコーディング オプション 不明な変数を自動的に宣言する（AutoDeclare） 有効になりました。 コマンドはスマートタグ機能を介して表示されます 変数を宣言する これは、宣言されていないSTエディターの実装部分の変数にカーソルを置いてからオンにした場合にも当てはまります。 クリック。 " }, 
{ "title" : "ダイアログ：変数を宣言する ", 
"url" : "_cds_cmd_declare_variable.html#UUID-bcf3934d-34a2-e1ad-d7f7-47aa728ded88_id_a21027ccec5d5fc0a8640e01ff1fb3_id_3fd5849fbf939f94c0a8640e00ee08a5", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：変数を宣言する \/ ダイアログ：変数を宣言する ", 
"snippet" : "範囲 まだ宣言されていない変数のスコープ 例： VAR （ローカル変数のデフォルト） 姓 変数名はまだ宣言されていません 例： bIsValid データ・タイプ 例： BOOL ：標準のデータ型を一覧表示します 入力ヘルプ ：ダイアログを開きます 入力ヘルプ アレイウィザード ：ダイアログを開きます 配列 物体 新しい変数が宣言されているオブジェクト デフォルトでは、現在編集しているオブジェクト。 例： fbA ：変数を宣言できるオブジェクトを一覧表示します 選択した場合 範囲 使用可能なオブジェクトがない場合、エントリが表示されます <オブジェクトの作成> 。エントリが表示された場合 <オブ...", 
"body" : "範囲 まだ宣言されていない変数のスコープ 例： VAR （ローカル変数のデフォルト） 姓 変数名はまだ宣言されていません 例： bIsValid データ・タイプ 例： BOOL ：標準のデータ型を一覧表示します 入力ヘルプ ：ダイアログを開きます 入力ヘルプ アレイウィザード ：ダイアログを開きます 配列 物体 新しい変数が宣言されているオブジェクト デフォルトでは、現在編集しているオブジェクト。 例： fbA ：変数を宣言できるオブジェクトを一覧表示します 選択した場合 範囲 使用可能なオブジェクトがない場合、エントリが表示されます <オブジェクトの作成> 。エントリが表示された場合 <オブジェクトの作成> 選択すると、ダイアログが開きます オブジェクトを追加 適切なオブジェクトを作成します。 初期化値 例： FALSE 初期化値を入力しない場合、変数は自動的に初期化されます。 ：ダイアログを開きます 初期化値 この手順は、構造化変数の初期化に役立ちます。 住所 まだ宣言されていない変数のアプリケーションのメモリアドレス 例： %IX1.0 知らせ： 次の有効領域でのみ可能です。 ローカル変数（ VAR ）。 グローバル変数（ VAR_GLOBAL ）。 永続変数（ PERSISTENT ）。 フラグ 属性キーワード CONSTANT ：定数のキーワード RETAIN ：残留変数のキーワード PERSISTENT ：永続変数のキーワード（より厳密 RETAIN ）。 選択した属性キーワードが変数宣言に追加されます。 コメント 例： New input In1 表形式の宣言エディタでは、入力されたコメントが列に表示されます コメント 、変数宣言の上にあるテキスト宣言エディタで。 リファクタリングを使用して変更を適用する ：ダイアログを閉じるとき、変数はまだ宣言されていませんが、ダイアログが最初に開きます リファクタリング 。そこで、変更をさらに編集できます。 このオプションは、次の有効な領域に表示されます。 入力変数（ VAR_INPUT ）。 出力変数（ VAR_OUTPUT ）。 VAR_IN_OUT -変数（入力変数と出力変数） わかった 変数が宣言され、宣言に表示されます。 例： VAR RETAIN\n \/\/ New input In1\n xIn1 AT %IX1.0: BOOL := FALSE;\nEND_VAR " }, 
{ "title" : "ダイアログ：配列 ", 
"url" : "_cds_cmd_declare_variable.html#UUID-bcf3934d-34a2-e1ad-d7f7-47aa728ded88_id_a21027ccec5d5fc0a8640e01ff1fb3_id_0d35552abf939f96c0a8640e01838bc5", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：変数を宣言する \/ ダイアログ：配列 ", 
"snippet" : "寸法とベースタイプの仕様 フィールドサイズの定義（ 寸法 ）下限と上限を入力して ベースタイプ アレイの 基本タイプは直接入力することも、ダイアログを使用して入力することもできます 入力ヘルプ また 配列 ボタンをクリックすると クリック。 結果 定義された配列の表示 CODESYS 変数の初期化値を変更した場合にのみ、変数を再初期化します。...", 
"body" : "寸法とベースタイプの仕様 フィールドサイズの定義（ 寸法 ）下限と上限を入力して ベースタイプ アレイの 基本タイプは直接入力することも、ダイアログを使用して入力することもできます 入力ヘルプ また 配列 ボタンをクリックすると クリック。 結果 定義された配列の表示 CODESYS 変数の初期化値を変更した場合にのみ、変数を再初期化します。 " }, 
{ "title" : "ダイアログ：初期化値 ", 
"url" : "_cds_cmd_declare_variable.html#UUID-bcf3934d-34a2-e1ad-d7f7-47aa728ded88_id_a21027ccec5d5fc0a8640e01ff1fb3_id_4086b2105903f5bdc0a864637bd9aa66", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：変数を宣言する \/ ダイアログ：初期化値 ", 
"snippet" : "名前の付いた変数のリスト（ 表現 ）、 初期化値 と データ・タイプ 変更された初期化値は太字で示されています。 リストの下の入力フィールド 選択した変数の初期化値を入力します 選択した行に値を適用します 入力フィールドの値に応じて、選択した行の初期化値を変更します 選択した行をデフォルト値にリセットします デフォルトの初期化値を確立する わかった CODESYS ダイアログで初期化値を受け入れます 変数を宣言する 。 このダイアログを介して初期化される変数が、テーブルの上にある拡張FB_Initメソッドを持つファンクションブロックインスタンスである場合 初期化値 別のテーブルが表示されます。...", 
"body" : "名前の付いた変数のリスト（ 表現 ）、 初期化値 と データ・タイプ 変更された初期化値は太字で示されています。 リストの下の入力フィールド 選択した変数の初期化値を入力します 選択した行に値を適用します 入力フィールドの値に応じて、選択した行の初期化値を変更します 選択した行をデフォルト値にリセットします デフォルトの初期化値を確立する わかった CODESYS ダイアログで初期化値を受け入れます 変数を宣言する 。 このダイアログを介して初期化される変数が、テーブルの上にある拡張FB_Initメソッドを持つファンクションブロックインスタンスである場合 初期化値 別のテーブルが表示されます。この表は、追加のFB_Initパラメーターを示しています。意味と操作は基本的に以下の表に対応していますが、次の違いがあります。 すべての変数に初期化値を割り当てる必要があります。それ以外の場合は わかった 選択できません。 複雑なデータ型（構造体、配列）の場合、そこに含まれるコンポーネントは表示されません（型は展開できません）。この場合、複合型は適切な変数で初期化する必要があります。 このように構成されたFB_Initパラメーターを使用して、ダイアログで 変数を宣言する 初期化値の後に対応する記号が表示されます。 詳細については、以下を参照してください。 メソッド : と AT宣言" }, 
{ "title" : "コマンド：アクセシビリティ ", 
"url" : "_cds_cmd_input_assistant.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：アクセシビリティ ", 
"snippet" : "入力ヘルプ シンボル： キーボードショートカット： F2 関数 ：コマンドはダイアログを開きます 入力ヘルプ 、現在のカーソル位置で可能なプログラミング要素を選択する際にサポートします。 電話 ：メニュー 編集するには 、 コンテキストメニュー 要件 ：POUがエディターで開いており、カーソルがプログラム行にあります。...", 
"body" : "入力ヘルプ シンボル： キーボードショートカット： F2 関数 ：コマンドはダイアログを開きます 入力ヘルプ 、現在のカーソル位置で可能なプログラミング要素を選択する際にサポートします。 電話 ：メニュー 編集するには 、 コンテキストメニュー 要件 ：POUがエディターで開いており、カーソルがプログラム行にあります。 " }, 
{ "title" : "ダイアログ：エントリヘルパー-タブ：カテゴリ ", 
"url" : "_cds_cmd_input_assistant.html#UUID-6ebae50a-4bd0-b4f9-9ae7-22fbbd5b58ca_id_ac201b561ba225dc0a8640e00215c1f_id_9b1329a161d157c1c0a8640e00c51282", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：アクセシビリティ \/ ダイアログ：エントリヘルパー-タブ：カテゴリ ", 
"snippet" : "ダイアログには、エディターの現在のカーソル位置に挿入できるすべてのプログラミング要素が表示されます。 要素は後です カテゴリ 並べ替え。あなたはカテゴリーに入ることができます 変数 さらに1つ フィルター などのスコープに設定 ローカル変数 、 グローバル変数 また 定数 。 構造化ビュー ：要素は構造ツリーに表示されます。あなたは列を見ることができます タイプ 、 住所 と 元 サブメニューの列タイトルを右クリックして、非表示または表示します。 ：要素はフラットな構造で表示されます。 ドキュメントを見る ：ダイアログはボックスを折り返します ドキュメンテーション 拡大しました。 引数付きで挿...", 
"body" : "ダイアログには、エディターの現在のカーソル位置に挿入できるすべてのプログラミング要素が表示されます。 要素は後です カテゴリ 並べ替え。あなたはカテゴリーに入ることができます 変数 さらに1つ フィルター などのスコープに設定 ローカル変数 、 グローバル変数 また 定数 。 構造化ビュー ：要素は構造ツリーに表示されます。あなたは列を見ることができます タイプ 、 住所 と 元 サブメニューの列タイトルを右クリックして、非表示または表示します。 ：要素はフラットな構造で表示されます。 ドキュメントを見る ：ダイアログはボックスを折り返します ドキュメンテーション 拡大しました。 引数付きで挿入 ：関数などの引数を持つ要素は、それらの引数とともにカーソル位置に挿入されます。 例：汎用モジュールを使用する場合 fb1 、入力変数です fb1_in および出力変数 fb1_out 「引数付き」を挿入すると、エディターでは次のようになります。 fb1(fb1_in:=>, fb1_out=>) 。 名前空間プレフィックスを付けて貼り付けます ：名前空間が前にある選択した要素を挿入します ライブラリブロックの場合、名前空間の指定が必須であるとライブラリプロパティで指定されていると、チェックボックスを操作できません。 グローバルに同じ名前とカテゴリのオブジェクトがある場合（表示 POU ）およびアプリケーションに割り当てられます（表示 装置 ）、入力ヘルプに表示されるエントリは1つだけです。使用法は通常の呼び出し優先度に従います（グローバルの前に適用可能）。 " }, 
{ "title" : "ダイアログ：エントリヘルパー-タブ：テキスト検索 ", 
"url" : "_cds_cmd_input_assistant.html#UUID-6ebae50a-4bd0-b4f9-9ae7-22fbbd5b58ca_id_ac201b561ba225dc0a8640e00215c1f_id_03fff56d17a6622cc0a864633a9aeacf", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：アクセシビリティ \/ ダイアログ：エントリヘルパー-タブ：テキスト検索 ", 
"snippet" : "タブで特定のオブジェクトを検索できます。検索フィールドに1つ以上の文字を入力すると、ヒットウィンドウに、この検索文字列が名前に含まれているすべてのオブジェクトの名前が一覧表示されます。目的のオブジェクトをダブルクリックして、エディターの現在のカーソル位置に挿入します。 フィルター 検索を特定のカテゴリの変数に制限します 詳細については、以下を参照してください。 入力アシスタンスを使用する...", 
"body" : "タブで特定のオブジェクトを検索できます。検索フィールドに1つ以上の文字を入力すると、ヒットウィンドウに、この検索文字列が名前に含まれているすべてのオブジェクトの名前が一覧表示されます。目的のオブジェクトをダブルクリックして、エディターの現在のカーソル位置に挿入します。 フィルター 検索を特定のカテゴリの変数に制限します 詳細については、以下を参照してください。 入力アシスタンスを使用する" }, 
{ "title" : "コマンド：ソースコードの位置に移動 ", 
"url" : "_cds_cmd_go_to_source_position.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：ソースコードの位置に移動 ", 
"snippet" : "ソース位置に移動 関数 ：コマンドを使用すると、メッセージをトリガーしたソースコード内の位置にジャンプします。 電話 ：メニュー 編集するには 、メッセージウィンドウのメッセージのコンテキストメニュー 要件 ：メッセージウィンドウでメッセージが選択されています。 メッセージウィンドウの次または前のメッセージのソーステキスト内の位置に到達するには、コマンドを使用します 次のメッセージ また 前のメッセージ 。...", 
"body" : "ソース位置に移動 関数 ：コマンドを使用すると、メッセージをトリガーしたソースコード内の位置にジャンプします。 電話 ：メニュー 編集するには 、メッセージウィンドウのメッセージのコンテキストメニュー 要件 ：メッセージウィンドウでメッセージが選択されています。 メッセージウィンドウの次または前のメッセージのソーステキスト内の位置に到達するには、コマンドを使用します 次のメッセージ また 前のメッセージ 。 " }, 
{ "title" : "コマンド：次のメッセージ ", 
"url" : "_cds_cmd_next_message.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：次のメッセージ ", 
"snippet" : "次のメッセージ キーボードショートカット： F4 関数 ：コマンドは、メッセージウィンドウで次のメッセージを選択します。 電話 ：メニュー 編集するには リストの最後のメッセージに到達すると、ハイライトが最初に戻ります。...", 
"body" : "次のメッセージ キーボードショートカット： F4 関数 ：コマンドは、メッセージウィンドウで次のメッセージを選択します。 電話 ：メニュー 編集するには リストの最後のメッセージに到達すると、ハイライトが最初に戻ります。 " }, 
{ "title" : "コマンド：前のメッセージ ", 
"url" : "_cds_cmd_previous_message.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：前のメッセージ ", 
"snippet" : "前のメッセージ キーボードショートカット： トグル + F4 関数 ：コマンドは、メッセージウィンドウで前のメッセージを選択します。 電話 ：メニュー 編集するには リストの最初のメッセージに到達すると、マーカーは最後にジャンプして戻ります。...", 
"body" : "前のメッセージ キーボードショートカット： トグル + F4 関数 ：コマンドは、メッセージウィンドウで前のメッセージを選択します。 電話 ：メニュー 編集するには リストの最初のメッセージに到達すると、マーカーは最後にジャンプして戻ります。 " }, 
{ "title" : "コマンド：定義に移動 ", 
"url" : "_cds_cmd_goto_definition.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：定義に移動 ", 
"snippet" : "定義に移動 シンボル： 関数 ：コマンドは、変数または関数の定義場所を表示します。 電話 ：メニュー 編集→検索アイコン 要件 ：POUがエディターで開いており、カーソルが変数または関数にあります。 詳細については、以下を参照してください。 宣言を見つける...", 
"body" : "定義に移動 シンボル： 関数 ：コマンドは、変数または関数の定義場所を表示します。 電話 ：メニュー 編集→検索アイコン 要件 ：POUがエディターで開いており、カーソルが変数または関数にあります。 詳細については、以下を参照してください。 宣言を見つける" }, 
{ "title" : "コマンド：リファレンスに移動 ", 
"url" : "_cds_cmd_goto_reference.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：リファレンスに移動 ", 
"snippet" : "参照に移動 シンボル： 関数 ：オンラインモードでは、コマンドは、現在フォーカスされているポインターによって参照されている変数の宣言場所を開きます。 電話 ： 宣言部分または実装コードのコンテキストメニュー メニュー 編集→検索アイコン 要件 ：オンライン操作 エディターでブロックが開いており、カーソルがポインター上にあります。参照される変数はスタティックメモリにあります。 ポインタが変数の先頭を正確に指していない場合、変数宣言に切り替えると、対応するメッセージが出力されます。...", 
"body" : "参照に移動 シンボル： 関数 ：オンラインモードでは、コマンドは、現在フォーカスされているポインターによって参照されている変数の宣言場所を開きます。 電話 ： 宣言部分または実装コードのコンテキストメニュー メニュー 編集→検索アイコン 要件 ：オンライン操作 エディターでブロックが開いており、カーソルがポインター上にあります。参照される変数はスタティックメモリにあります。 ポインタが変数の先頭を正確に指していない場合、変数宣言に切り替えると、対応するメッセージが出力されます。 " }, 
{ "title" : "コマンド：インスタンスに移動 ", 
"url" : "_cds_cmd_goto_instance.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：インスタンスに移動 ", 
"snippet" : "インスタンスに移動 シンボル： 関数 ：このコマンドは、ファンクションブロックのインスタンスを新しいウィンドウで開きます。 電話 ：メニュー 編集→検索アイコン 要件 ：アプリケーションはオンラインモードです。 POUがエディタで開かれ、カーソルが機能ブロックのインスタンスにあります。 このコマンドは、一時インスタンスまたは変換されたライブラリのインスタンスには使用できません。 詳細については、以下を参照してください。 宣言を見つける...", 
"body" : "インスタンスに移動 シンボル： 関数 ：このコマンドは、ファンクションブロックのインスタンスを新しいウィンドウで開きます。 電話 ：メニュー 編集→検索アイコン 要件 ：アプリケーションはオンラインモードです。 POUがエディタで開かれ、カーソルが機能ブロックのインスタンスにあります。 このコマンドは、一時インスタンスまたは変換されたライブラリのインスタンスには使用できません。 詳細については、以下を参照してください。 宣言を見つける" }, 
{ "title" : "コマンド：リファクタリング-名前の変更<…> ", 
"url" : "_cds_cmd_refactoring_rename.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：リファクタリング-名前の変更<…> ", 
"snippet" : "リファクタリング-名前の変更<…> 関数 ：このコマンドは、プロジェクト全体でオブジェクトまたは変数の名前を変更するためのダイアログを開きます。 電話 ：メニュー 編集→リファクタリング 、 コンテキストメニュー 要件 ：デバイスツリーまたはビュー内のオブジェクト POU が選択されているか、カーソルがプログラミングオブジェクトの宣言部分の変数識別子の前または上に置かれています。 次の名前を変更できます。 変数 POU GVLの メソッド プロパティ 装置 単位変換エディター内の変数と単位変換...", 
"body" : "リファクタリング-名前の変更<…> 関数 ：このコマンドは、プロジェクト全体でオブジェクトまたは変数の名前を変更するためのダイアログを開きます。 電話 ：メニュー 編集→リファクタリング 、 コンテキストメニュー 要件 ：デバイスツリーまたはビュー内のオブジェクト POU が選択されているか、カーソルがプログラミングオブジェクトの宣言部分の変数識別子の前または上に置かれています。 次の名前を変更できます。 変数 POU GVLの メソッド プロパティ 装置 単位変換エディター内の変数と単位変換 " }, 
{ "title" : "対話：名前を変更する ", 
"url" : "_cds_cmd_refactoring_rename.html#UUID-2430b763-4ab5-90f5-a69e-2da0a1ef8661_id_f49c110c42fdcc0a8640e01cee140_id_7c48a1fabf8ddfbec0a8640e0166cc68", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：リファクタリング-名前の変更<…> \/ 対話：名前を変更する ", 
"snippet" : "現在の名前 オブジェクトまたは変数の名前 新しい名前 新しい名前の入力フィールド 入力した名前がすでに存在する場合は、報告してください CODESYS これは、この入力フィールドのすぐ下にあります。 わかった あなたがいるときに有効にする 新しい名前 有効な名前を入力しました ダイアログを開きます リファクタリング それぞれのオブジェクトと位置は、両方のウィンドウでカラーでマークされています。...", 
"body" : "現在の名前 オブジェクトまたは変数の名前 新しい名前 新しい名前の入力フィールド 入力した名前がすでに存在する場合は、報告してください CODESYS これは、この入力フィールドのすぐ下にあります。 わかった あなたがいるときに有効にする 新しい名前 有効な名前を入力しました ダイアログを開きます リファクタリング それぞれのオブジェクトと位置は、両方のウィンドウでカラーでマークされています。 " }, 
{ "title" : "対話：リファクタリング ", 
"url" : "_cds_cmd_refactoring_rename.html#UUID-2430b763-4ab5-90f5-a69e-2da0a1ef8661_id_f49c110c42fdcc0a8640e01cee140_id_f64f5fbfa6beea08c0a8640e01fd503b", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：リファクタリング-名前の変更<…> \/ 対話：リファクタリング ", 
"snippet" : "ダイアログには、プロジェクト内のすべての使用場所が表示されます。 それぞれのオブジェクトと位置は、両方のウィンドウでカラーでマークされています。 右ウィンドウ オブジェクト内のそれぞれの場所を表示する 現在の名前 発生します 左ウィンドウ それぞれのオブジェクトを含むプロジェクトのナビゲーションツリー 両方のウィンドウで、使用ポイントごとに何を行うかを指定できます。この目的のために、コンテキストメニューで次のコマンドを使用できます。 この変更を破棄します 右側のウィンドウで1つの変更を破棄します このアイテムを受け入れる 影響を受けるオブジェクトのすべての変更を受け入れる このオブジェクトを破...", 
"body" : "ダイアログには、プロジェクト内のすべての使用場所が表示されます。 それぞれのオブジェクトと位置は、両方のウィンドウでカラーでマークされています。 右ウィンドウ オブジェクト内のそれぞれの場所を表示する 現在の名前 発生します 左ウィンドウ それぞれのオブジェクトを含むプロジェクトのナビゲーションツリー 両方のウィンドウで、使用ポイントごとに何を行うかを指定できます。この目的のために、コンテキストメニューで次のコマンドを使用できます。 この変更を破棄します 右側のウィンドウで1つの変更を破棄します このアイテムを受け入れる 影響を受けるオブジェクトのすべての変更を受け入れる このオブジェクトを破棄します 影響を受けるオブジェクトのすべての変更を破棄します プロジェクト全体を受け入れる プロジェクトのすべての変更を受け入れる プロジェクト全体を破棄する プロジェクトのすべての変更を破棄します CODESYS 受け入れられた変更を黄色の背景で表し、破棄された変更を灰色の背景で表します。 詳細については、以下を参照してください。 リファクタリング" }, 
{ "title" : "コマンド：リファクタリング-関連するポートを更新します ", 
"url" : "_cds_cmd_refactoring_update_referenced_pins.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：リファクタリング-関連するポートを更新します ", 
"snippet" : "リファクタリング-関連するポートを更新します このコマンドは現在、CFC、FBD、LD、および IL エディターにのみ適用されます。の組み合わせです 接続をリセット と パラメータの更新 . シンボル: 関数 ：このコマンドは、影響を受けるすべてのブロックの使用ポイントで、I \/ Oを現在のブロック宣言に適合させます。 電話 ：メニュー 編集→リファクタリング 、 コンテキストメニュー 要件 ：カーソルは、デバイス宣言の最初の行またはデバイスツリーにあるデバイスの名前にあります。 詳細については、以下を参照してください。 リファクタリング...", 
"body" : "リファクタリング-関連するポートを更新します このコマンドは現在、CFC、FBD、LD、および IL エディターにのみ適用されます。の組み合わせです 接続をリセット と パラメータの更新 . シンボル: 関数 ：このコマンドは、影響を受けるすべてのブロックの使用ポイントで、I \/ Oを現在のブロック宣言に適合させます。 電話 ：メニュー 編集→リファクタリング 、 コンテキストメニュー 要件 ：カーソルは、デバイス宣言の最初の行またはデバイスツリーにあるデバイスの名前にあります。 詳細については、以下を参照してください。 リファクタリング" }, 
{ "title" : "コマンド：リファクタリング-変数の追加 ", 
"url" : "_cds_cmd_refactoring_add_variable.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：リファクタリング-変数の追加 ", 
"snippet" : "リファクタリング-変数を追加 シンボル ： 関数 ：このコマンドを使用すると、新しい変数をPOUで宣言し、それに応じてPOUの使用時に自動的に更新できます。 電話 ：メニュー 編集→リファクタリング 、 コンテキストメニュー 要件 ：焦点はPOUの宣言部分にあります。 このコマンドは、変数を宣言するための標準ダイアログを開きます。...", 
"body" : "リファクタリング-変数を追加 シンボル ： 関数 ：このコマンドを使用すると、新しい変数をPOUで宣言し、それに応じてPOUの使用時に自動的に更新できます。 電話 ：メニュー 編集→リファクタリング 、 コンテキストメニュー 要件 ：焦点はPOUの宣言部分にあります。 このコマンドは、変数を宣言するための標準ダイアログを開きます。 " }, 
{ "title" : "対話：リファクタリング ", 
"url" : "_cds_cmd_refactoring_add_variable.html#UUID-581e76a8-35ca-3ac1-f711-53d8a5822085_id_eaa36acdfe35c86c0a8640e01aae2be_id_f770113be1ae9112c0a8640e01d33576", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：リファクタリング-変数の追加 \/ 対話：リファクタリング ", 
"snippet" : "で宣言ダイアログを閉じた後 わかった 2部構成のダイアログが表示されます リファクタリング 。 対話の右側 宣言部分と、変数が追加された宣言のPOUの実装 変更点の色分け：青い文字と黄色の背景で新しく追加された宣言（1） 対話の左側 プロジェクトのデバイスツリーまたはPOUツリー POUが使用されているブロックの色分け：赤いフォントと黄色の背景（2） POUオブジェクトをダブルクリックすると、詳細ビューが開きます。 適用する変更と場所を決定する前に、右上の選択リスト（3）から目的のオプションを選択します。 プレースホルダーテキストを使用して入力を追加する デフォルトのプレースホルダーテキスト ...", 
"body" : "で宣言ダイアログを閉じた後 わかった 2部構成のダイアログが表示されます リファクタリング 。 対話の右側 宣言部分と、変数が追加された宣言のPOUの実装 変更点の色分け：青い文字と黄色の背景で新しく追加された宣言（1） 対話の左側 プロジェクトのデバイスツリーまたはPOUツリー POUが使用されているブロックの色分け：赤いフォントと黄色の背景（2） POUオブジェクトをダブルクリックすると、詳細ビューが開きます。 適用する変更と場所を決定する前に、右上の選択リスト（3）から目的のオプションを選択します。 プレースホルダーテキストを使用して入力を追加する デフォルトのプレースホルダーテキスト _REFACTOR_ ;編集可能 ここで定義されたプレースホルダーテキストは、実装コードに新しく追加された変数の使用ポイントに表示されます。影響を受ける位置を検索するために使用されます。 次の値で入力を追加します 新しい変数の初期化値 ダイアログの左側と右側の両方の変更点のコンテキストメニューに、変更を承認または拒否するためのコマンドがあります。コマンドの説明も参照してください リファクタリング→名前の変更 。 例 建築用ブロック fun リファクタリングを介して新しい入力変数を受け取ります input3 初期化値付き 1 。 この変更には次の効果があります。 前： fun(a + b, 3, TRUE);\nfun(input1:= a + b , input2 :=3 , inputx := TRUE); その後： fun(a + b, 3, 1, TRUE);\nfun(input1:= a + b , input2 :=3 , _REFACTOR_, inputx := TRUE); 建築用ブロック fun リファクタリングを介して新しい入力変数を受け取ります input3 プレースホルダーテキスト付き _REFACTOR_ 。 前： inst(input1 := a + b, input2 := 3, inputx := TRUE);\nfun(a + b, 3, TRUE); その後： inst(input1 := a + b, input2 := 3, input3 := _REFACTOR_, inputx := TRUE);\nfun(a + b, 3, _REFACTOR_, TRUE); 詳細については、以下を参照してください。 リファクタリング" }, 
{ "title" : "コマンド：リファクタリング-<変数>を削除 ", 
"url" : "_cds_cmd_refactoring_remove_variable.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：リファクタリング-<変数>を削除 ", 
"snippet" : "リファクタリング-<変数>を削除します シンボル： 関数 ：このコマンドは、POUおよびPOUのすべての使用ポイントから入力変数または出力変数を削除します。 電話 ：メニュー 編集→リファクタリング 、 コンテキストメニュー 要件 ：カーソルは、POUの宣言部分で削除される変数の識別子にあります。 このコマンドは、最初に目的の距離の詳細を示すダイアログを開きます。確認後、ダイアログが表示されます リファクタリング 。ダイアログの説明については、を参照してください リファクタリング コマンドヘルプページ 編集→リファクタリング→ 名前を変更 。 ダイアログに変更が表示されたら リファクタリング ...", 
"body" : "リファクタリング-<変数>を削除します シンボル： 関数 ：このコマンドは、POUおよびPOUのすべての使用ポイントから入力変数または出力変数を削除します。 電話 ：メニュー 編集→リファクタリング 、 コンテキストメニュー 要件 ：カーソルは、POUの宣言部分で削除される変数の識別子にあります。 このコマンドは、最初に目的の距離の詳細を示すダイアログを開きます。確認後、ダイアログが表示されます リファクタリング 。ダイアログの説明については、を参照してください リファクタリング コマンドヘルプページ 編集→リファクタリング→ 名前を変更 。 ダイアログに変更が表示されたら リファクタリング 受け入れると、影響を受けるPOUの使用ポイントで、対応する入力または出力パラメーターが削除されます。 削除された入力または出力のブロックへの接続のみがCFCで削除されます。入口または出口自体はチャートに残ります。 STの例 「リファクタリング」を使用して、POUの入力変数を削除します。 input4 。 自動調整は使用場所で行われます。 取り外す前： inst(input1 := a + b, input2 := 3, input4 := 1, input5 := TRUE);\nfun(a + b, 3, 1, TRUE); 距離後： inst(input1 := a + b, input2 := 3, input5 := TRUE);\nfun(a + b, 3, TRUE); 詳細については、以下を参照してください。 リファクタリング" }, 
{ "title" : "コマンド：リファクタリング-変数の並べ替え ", 
"url" : "_cds_cmd_refactoring_reorder_variables.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 編集するには \/ コマンド：リファクタリング-変数の並べ替え ", 
"snippet" : "リファクタリング-変数の並べ替え シンボル： 関数 ：このコマンドを使用すると、宣言エディターで、現在フォーカスされているスコープ内の変数の順序を変更できます。 VAR_INPUT 、 VAR_OUTPUT また VAR_IN_OUT 。 電話 ：メニュー 編集→リファクタリング 、宣言エディタで現在フォーカスされているスコープのコンテキストメニュー 要件 ：焦点は上記のスコープの1つの宣言にあり、複数の変数が宣言されています。 コマンドはダイアログを開きます 再配置 現在フォーカスされているスコープのすべての宣言のリスト。マウスでドラッグすると、選択した宣言を別の位置に上下に移動できます。 ...", 
"body" : "リファクタリング-変数の並べ替え シンボル： 関数 ：このコマンドを使用すると、宣言エディターで、現在フォーカスされているスコープ内の変数の順序を変更できます。 VAR_INPUT 、 VAR_OUTPUT また VAR_IN_OUT 。 電話 ：メニュー 編集→リファクタリング 、宣言エディタで現在フォーカスされているスコープのコンテキストメニュー 要件 ：焦点は上記のスコープの1つの宣言にあり、複数の変数が宣言されています。 コマンドはダイアログを開きます 再配置 現在フォーカスされているスコープのすべての宣言のリスト。マウスでドラッグすると、選択した宣言を別の位置に上下に移動できます。 詳細については、以下を参照してください。 リファクタリング" }, 
{ "title" : "ファイル ", 
"url" : "_cds_f_commands_file.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド：新しいプロジェクト ", 
"url" : "_cds_cmd_new_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：新しいプロジェクト ", 
"snippet" : "新しいプロジェクト シンボル： キーボードショートカット： Ctrl + N 関数 ：コマンドは 新しいプロジェクト 新しいプロジェクトファイルを作成するため。 電話 ： ファイル メニュー...", 
"body" : "新しいプロジェクト シンボル： キーボードショートカット： Ctrl + N 関数 ：コマンドは 新しいプロジェクト 新しいプロジェクトファイルを作成するため。 電話 ： ファイル メニュー " }, 
{ "title" : "ダイアログ：新しいプロジェクト ", 
"url" : "_cds_cmd_new_project.html#UUID-6f88f662-6ca0-6f10-4ff7-01e65ed2eded_id_ad7732caf0c41c1c0a8640e00c145e1_id_1e70c84630a111d6c0a8640e0028ba1d", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：新しいプロジェクト \/ ダイアログ：新しいプロジェクト ", 
"snippet" : "関数 ：プロジェクトカテゴリとプロジェクトテンプレートの選択 電話 ： ファイル→新規プロジェクト 指図 選択したテンプレートに応じて、特定の範囲のオブジェクトを備えたプロジェクトを取得します。 カテゴリ ライブラリ プロジェクト テンプレート プロジェクト カテゴリー 空のプロジェクト のみが含まれています プロジェクト設定 物体 標準プロジェクト オブジェクトとライブラリの基本的な範囲が含まれています ウィザードはプロジェクトの作成に役立ちます。 ApplicationComposerを使用した標準プロジェクト ApplicationComposerを操作するための基本的なオブジェクトとラ...", 
"body" : "関数 ：プロジェクトカテゴリとプロジェクトテンプレートの選択 電話 ： ファイル→新規プロジェクト 指図 選択したテンプレートに応じて、特定の範囲のオブジェクトを備えたプロジェクトを取得します。 カテゴリ ライブラリ プロジェクト テンプレート プロジェクト カテゴリー 空のプロジェクト のみが含まれています プロジェクト設定 物体 標準プロジェクト オブジェクトとライブラリの基本的な範囲が含まれています ウィザードはプロジェクトの作成に役立ちます。 ApplicationComposerを使用した標準プロジェクト ApplicationComposerを操作するための基本的なオブジェクトとライブラリの範囲が含まれています ウィザードはプロジェクトの作成に役立ちます。 ライブラリ カテゴリー CODESYS コンテナライブラリ 追加のライブラリのみを含み、独自の機能ブロックを含まないライブラリ CODESYS インターフェイスライブラリ ソフトウェアコンポーネントのインターフェイスを定義するためのライブラリのみ その結果、コードを生成しないオブジェクト（定数、構造、インターフェースなど）のみが含まれます。 空白のライブラリ のみが含まれています プロジェクト設定 物体 外部の CODESYS 図書館 ターゲットシステムに固有のライブラリ ランタイムシステムの一部として実装（ANSICまたはC ++） 名前 作成するプロジェクトの名前 テンプレートに応じて、デフォルトの名前が表示されます。数字の接尾辞は、ファイルシステム内の名前が一意であることを確認します。 オペレーティングシステムのファイルパス規則を考慮して、ファイル名を変更できます。名前にピリオドを使用することはできません。 CODESYS 選択したテンプレートに対応するファイル拡張子を自動的に追加します。 位置 新しいプロジェクトファイルの保存場所 ファイルシステムを検索するためのダイアログを開きます。 以前に使用されたパスの履歴を示します。 わかった CODESYS 新しいプロジェクトを開きます。エラー 入力フィールドの横の記号は、欠落しているデータを示します。マウスポインタをその上に置くと、何をすべきかを示すツールチップが表示されます。 " }, 
{ "title" : "ダイアログ：標準プロジェクト ", 
"url" : "_cds_cmd_new_project.html#UUID-6f88f662-6ca0-6f10-4ff7-01e65ed2eded_id_ad7732caf0c41c1c0a8640e00c145e1_id_2aa85e4f30a111d8c0a8640e01abeee3", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：新しいプロジェクト \/ ダイアログ：標準プロジェクト ", 
"snippet" : "関数 ：標準プロジェクトを作成するためのウィザード 電話 ： ファイル→新規プロジェクト 指図;の中に 新しいプロジェクト ダイアログで、 プロジェクト カテゴリと 標準プロジェクト テンプレートをクリックしてからクリックします わかった 。 デバイス PLCデバイスのリストボックス デバイスビューでは、選択したデバイスがルートノードの下のオブジェクトとして挿入されます。 PLC_PRGの 実装言語のリストボックス 自動的に挿入されるPLC_PRGプログラムは、選択した言語で作成されます。 詳細については、以下を参照してください。 標準プロジェクトの作成...", 
"body" : "関数 ：標準プロジェクトを作成するためのウィザード 電話 ： ファイル→新規プロジェクト 指図;の中に 新しいプロジェクト ダイアログで、 プロジェクト カテゴリと 標準プロジェクト テンプレートをクリックしてからクリックします わかった 。 デバイス PLCデバイスのリストボックス デバイスビューでは、選択したデバイスがルートノードの下のオブジェクトとして挿入されます。 PLC_PRGの 実装言語のリストボックス 自動的に挿入されるPLC_PRGプログラムは、選択した言語で作成されます。 詳細については、以下を参照してください。 標準プロジェクトの作成" }, 
{ "title" : "コマンド：プロジェクトを開く ", 
"url" : "_cds_cmd_open_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：プロジェクトを開く ", 
"snippet" : "プロジェクトを開く シンボル： キーボードショートカット： Ctrl + O 関数 : このコマンドは、プロジェクトをロードするための標準ダイアログを開きます。ファイルシステムを次のように変更できます。 CODESYS -プロジェクトを参照して開発システムで開きます。 電話 ： ファイル メニュー...", 
"body" : "プロジェクトを開く シンボル： キーボードショートカット： Ctrl + O 関数 : このコマンドは、プロジェクトをロードするための標準ダイアログを開きます。ファイルシステムを次のように変更できます。 CODESYS -プロジェクトを参照して開発システムで開きます。 電話 ： ファイル メニュー " }, 
{ "title" : "ダイアログ：プロジェクトを開く ", 
"url" : "_cds_cmd_open_project.html#UUID-8a8b7dbf-6789-e615-a76d-2d52433df19e_id_ec92c4aaf11d53dc0a8640e00e17490_id_f8c83f4b11842681c0a864634a242657", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：プロジェクトを開く \/ ダイアログ：プロジェクトを開く ", 
"snippet" : "ファイルタイプ の種類 CODESYS 開発システムにロードされるプロジェクト サポートされているすべてのファイル すべてのプロジェクトでフィルタリングします CODESYS ロードできます ヒント：たとえば、 PRO で作成されたプロジェクト CoDeSys V2.3 。これらの種類のプロジェクトも変換されます。 project ファイル拡張子 で作成されたプロジェクトによるフィルター CODESYS V3 projectarchive ファイル拡張子 で作成されたプロジェクトアーカイブによるフィルター CODESYS V3 library ファイル拡張子 で作成されたライブラリプロジェクト...", 
"body" : "ファイルタイプ の種類 CODESYS 開発システムにロードされるプロジェクト サポートされているすべてのファイル すべてのプロジェクトでフィルタリングします CODESYS ロードできます ヒント：たとえば、 PRO で作成されたプロジェクト CoDeSys V2.3 。これらの種類のプロジェクトも変換されます。 project ファイル拡張子 で作成されたプロジェクトによるフィルター CODESYS V3 projectarchive ファイル拡張子 で作成されたプロジェクトアーカイブによるフィルター CODESYS V3 library ファイル拡張子 で作成されたライブラリプロジェクトによるフィルタ CODESYS V3 開ける 選択したプロジェクトをにロードします CODESYS 注：あなたの状態に応じて CODESYS インストールの場合、インストールを更新または補足する必要がある場合があります。この場合は、最初に別のを開きます プロジェクトを開く インストール管理のオプションを含むダイアログ。 " }, 
{ "title" : "ダイアログ：プロジェクトを開く（インストール管理が必要な場合） ", 
"url" : "_cds_cmd_open_project.html#UUID-8a8b7dbf-6789-e615-a76d-2d52433df19e_id_ec92c4aaf11d53dc0a8640e00e17490_id_b8f2d4bb2ffd39eec0a8640e00ffd301", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：プロジェクトを開く \/ ダイアログ：プロジェクトを開く（インストール管理が必要な場合） ", 
"snippet" : "の場合 CODESYS 編集するプロジェクトが現在のインストールでロードするのに適していない場合、次のダイアログが開きます。そこで、次のステップを決定できます。たとえば、選択したプロジェクトにオブジェクトが含まれている場合、インストールは適切ではありません。 UML状態チャート 実装言語ですが、インストールはこれらのオブジェクトを認識しません。 CODESYS UML アドオンがインストールされていません。 不適切なインストールの例: 開こうとしているプロジェクトに、 UML ステートチャート 実装言語ですが、インストールには含まれていません CODESYS UML アドオン。 ウィザードは次...", 
"body" : "の場合 CODESYS 編集するプロジェクトが現在のインストールでロードするのに適していない場合、次のダイアログが開きます。そこで、次のステップを決定できます。たとえば、選択したプロジェクトにオブジェクトが含まれている場合、インストールは適切ではありません。 UML状態チャート 実装言語ですが、インストールはこれらのオブジェクトを認識しません。 CODESYS UML アドオンがインストールされていません。 不適切なインストールの例: 開こうとしているプロジェクトに、 UML ステートチャート 実装言語ですが、インストールには含まれていません CODESYS UML アドオン。 ウィザードは次のダイアログを介して実行されます。 プロジェクト検査 - 概要 プロジェクトは別のバージョン <CODESYS バージョン> で保存されています。 このプロジェクトはまだ開発段階にあります。このバージョンで開きたいのですが、別のコードが生成される可能性があります。 クリックする 次 を開きます プロジェクトの検査 – アドオンの欠落 現在のインストールにないアドオンを開く前に追加する必要があるかどうかを決定するためのダイアログ。 このプロジェクトは、すでにマシン\/プラントに展開されています。まったく同じコードを生成したいので、変更せずにログインできるようにする必要があります。 結果: まだ利用できない場合は、互換性のあるバージョンが開かれるか、インストールされます。 クリックする 次 を開きます プロジェクトの検査 – 選択 別のインストールに切り替えるためのダイアログ。 詳細 このボタンは、プロジェクトがで保存された場合にのみ使用できます CODESYS バージョン 3.5.19.0 以降。 を開きます 違い ダイアログ。ここでは、プロジェクトを保存したときにインストールされたアドオンと、現在のインストールで利用できるかどうか、およびどのように利用できるかを確認できます。 プロジェクトの検査 – アドオンの欠落 プロジェクトには、適切なアドオンがインストールされていないオブジェクトが含まれています このバージョンの不足しているアドオンをインストールして再起動します。 クリック 次 を表示します プロジェクト検査 – アドオン 追加のアドオンのインストールを構成するためのダイアログ。 とにかく続けます。オブジェクトは変更できません。 クリックする 終了 現在のインストールでプロジェクトを開きます。 制限： プロジェクトが書き込み禁止で開きます。 プロジェクトには、判読できない不明なオブジェクトが含まれています。 プロジェクトではコントローラにログインできません。 プロジェクト検査 – アドオン 次のアドオンによって現在のインストールを拡張します。 表示されていない必要なアドオンと、明示的に選択されたオプションのアドオンは、クリック後にインストールされます 終了 確認するために。これを行うには、 CODESYS Development System そしてインストーラーを起動します。 必要なアドオン 、 スターテス 必要なアドオンの名前、バージョン、およびステータス 可能なステータス: ない マッチング <バージョン番号> から <バージョン番号> に更新 オプションのアドオン 、 スターテス オプションのアドオンの名前とバージョン。これらは、プロジェクトで絶対に必要なわけではありませんが、保存時に使用できるアドオンです。 プロジェクトの検査 – 選択 このダイアログは、プロジェクトを互換性のある CODESYS バージョンが選択されました プロジェクト検査 - 概要 .ここでは、プロジェクトと互換性のある別のインストールを選択します。 アドオン アドオンの名前 アクション クリックする 次 を開きます プロジェクト検査 – アドオン ダイアログ。作成中の新しいインストールに含まれている、または追加できる必須およびオプションのアドオンが表示されます。 「完了」をクリックすると閉じます CODESYS Development System そしてスタート CODESYS Installer .ダウンロードと新規インストールを実行します。 詳細については、以下を参照してください。 開く と V2.3プロジェクトを開く" }, 
{ "title" : "コマンド:プロジェクトを閉じる ", 
"url" : "_cds_cmd_close_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド:プロジェクトを閉じる ", 
"snippet" : "プロジェクトを閉じる 関数 ：このコマンドは、現在開いているプロジェクトを閉じます。 CODESYS 開いたままです。 電話 ： ファイルメニュー ;さらに、別のプロジェクトがまだ開いているときに新しいプロジェクトまたは他のプロジェクトを開くときに暗黙的に プロジェクトに保存されていない変更が含まれている場合は、プロジェクトを保存するかどうかに関するクエリが表示されます。 プロジェクトをまだ明示的に保存していない場合は、プロジェクトファイルを削除するかどうかを尋ねるダイアログプロンプトが表示されます。...", 
"body" : "プロジェクトを閉じる 関数 ：このコマンドは、現在開いているプロジェクトを閉じます。 CODESYS 開いたままです。 電話 ： ファイルメニュー ;さらに、別のプロジェクトがまだ開いているときに新しいプロジェクトまたは他のプロジェクトを開くときに暗黙的に プロジェクトに保存されていない変更が含まれている場合は、プロジェクトを保存するかどうかに関するクエリが表示されます。 プロジェクトをまだ明示的に保存していない場合は、プロジェクトファイルを削除するかどうかを尋ねるダイアログプロンプトが表示されます。 " }, 
{ "title" : "コマンド:プロジェクトを保存 ", 
"url" : "_cds_cmd_save_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド:プロジェクトを保存 ", 
"snippet" : "プロジェクトを保存 シンボル： キーボードショートカット： Ctrl + S 関数 ：コマンドはプロジェクトファイルを保存します。 電話 ： ファイル メニュー このコマンドは、メインウィンドウのタイトルバーに表示される現在のプロジェクト名でプロジェクトファイルを保存します。前回保存した後でプロジェクトが変更されている場合、プロジェクト名にはアスタリスクが付きます プロジェクトが書き込み保護されている場合、このコマンドは使用できません。 書き込み保護は、次の場合に存在します。 プロジェクトは、プロジェクト情報（要約）で「リリース済み」として識別されます。 プロジェクトを開くとき、 読み取り専用...", 
"body" : "プロジェクトを保存 シンボル： キーボードショートカット： Ctrl + S 関数 ：コマンドはプロジェクトファイルを保存します。 電話 ： ファイル メニュー このコマンドは、メインウィンドウのタイトルバーに表示される現在のプロジェクト名でプロジェクトファイルを保存します。前回保存した後でプロジェクトが変更されている場合、プロジェクト名にはアスタリスクが付きます プロジェクトが書き込み保護されている場合、このコマンドは使用できません。 書き込み保護は、次の場合に存在します。 プロジェクトは、プロジェクト情報（要約）で「リリース済み」として識別されます。 プロジェクトを開くとき、 読み取り専用で開く オプションがで選択されました プロジェクトを開く ダイアログ。 書き込み保護は、メインウィンドウの右上隅にある線で示されます。この行をクリックすると、次の可能なアクションのコマンドを含むメニューが表示されます。 プロジェクトを別のファイル名でディスクに保存します ：このオプションをクリックすると、[名前を付けてファイルを保存]ダイアログが開きます。 読み取り専用モードを終了します ：次の場合にのみ表示されます 読み取り専用で開く プロジェクトを開くときにオプションが選択されている ディスク上のプロジェクトから読み取り専用属性を削除します ：プロジェクトファイルがディスク上で開かれたときに「読み取り専用」プロパティが提供された場合にのみ表示されます プロジェクト情報の「リリース済み」のIDを削除します ：この属性が現在設定されている場合にのみ表示されます バックアップコピー プロジェクトファイルのバックアップコピーは、オプションで作成できます。の場合 バックアップコピーを作成する オプションが選択されている ロードして保存 オプションダイアログの場合、プロジェクトは次の名前のファイルにもコピーされます <project name.backup> プロジェクトが保存されるたび。 詳細については、以下を参照してください。 プロジェクトの保存 と ロードして保存" }, 
{ "title" : "コマンド：プロジェクトを名前を付けて保存 ", 
"url" : "_cds_cmd_save_project_as.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：プロジェクトを名前を付けて保存 ", 
"snippet" : "プロジェクトを名前を付けて保存 このコマンドは、ファイルを保存するための標準のWindowsダイアログを開きます。プロジェクトは、目的の場所とファイルタイプで保存できます。 ファイルタイプ 通常のプロジェクトとライブラリプロジェクトの両方の場合、このリストボックスには、プロジェクトを保存できる開発システムのそれぞれのバージョンが含まれています。現在のプロジェクトに、選択したメモリ形式（プロファイル）で使用できないアドオンが含まれている場合は、 プロファイルを拡張する ダイアログが開きます。 プロジェクトファイル（ CODESYS V <バージョン>）（*。project） ：プロジェクトはとし...", 
"body" : "プロジェクトを名前を付けて保存 このコマンドは、ファイルを保存するための標準のWindowsダイアログを開きます。プロジェクトは、目的の場所とファイルタイプで保存できます。 ファイルタイプ 通常のプロジェクトとライブラリプロジェクトの両方の場合、このリストボックスには、プロジェクトを保存できる開発システムのそれぞれのバージョンが含まれています。現在のプロジェクトに、選択したメモリ形式（プロファイル）で使用できないアドオンが含まれている場合は、 プロファイルを拡張する ダイアログが開きます。 プロジェクトファイル（ CODESYS V <バージョン>）（*。project） ：プロジェクトはとして保存されます CODESYS 現在使用または選択されている開発システムのバージョンの「<プロジェクト名> .project」という名前のプロジェクトファイル。 ライブラリファイル（V <バージョン>）（*。library） CODESYS ：プロジェクトはとして保存されます CODESYS 現在使用または選択されている開発システムのバージョンの「<プロジェクト名> .library」という名前のライブラリファイル。 後で古いバージョンでプロジェクトを開きたい場合は、データ損失の可能性がすぐに通知されるため、正確にこのメモリ形式で保存することが合理的です。 プロジェクトの保存形式はプロジェクト情報（ プロジェクト → プロジェクト情報 、 ファイル タブ）。 プロジェクトをライブラリとして保存する前に： ライブラリを作成するためのルールに従っていることを確認してください。 後でアプリケーションでライブラリによって提供されるグローバル定数を構成できるようにする場合は、パラメーターリストでそれらを定義する必要があります。パラメータリストは、特殊なタイプのグローバル変数リストです。 プロジェクトを保存するとき、エラーの自動チェックは実行されません。 と違う CoDeSys V2.3 、「外部」ライブラリと「内部」ライブラリの区別はありません。これで、個々のプロジェクトオブジェクトのプロパティで、オブジェクトを「外部」として扱うかどうかを定義できます。 作成したライブラリをすぐにシステム ライブラリ リポジトリにインストールする必要があるかどうかを検討してください。その場合は、 プロジェクトを保存してライブラリ リポジトリにインストールする 指示。 ライブラリプロジェクトを後の変更から保護する場合は、 リリース済み の属性 プロジェクト情報 ダイアログ。次にプロジェクトを保存しようとすると、対応するメッセージが表示され、ユーザーは意図的なアクションで書き込み保護に対応する必要があります。 現在使用されているもの以外のバージョンの開発システムとしてプロジェクトを保存すると、最初にデータ損失の可能性について通知されます。 " }, 
{ "title" : "ダイアログ：プロファイルの拡張 ", 
"url" : "_cds_cmd_save_project_as.html#UUID-3a5f4010-3111-46e1-90db-bb8388a40eca_id_fa7eae44c8e9c0a8640e018912b9_id_b152c4d5d9ce2c28c0a864637c36b07f", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：プロジェクトを名前を付けて保存 \/ ダイアログ：プロファイルの拡張 ", 
"snippet" : "このダイアログでは、選択したプロファイル（メモリ形式）を、現在のプロジェクトに含まれているアドオンによって拡張できます。プロファイルは一時的に保存され、保存またはエクスポートされた後に削除されます。 プロファイルに追加 ：現在のプロファイルはアドオンによって拡張されるため、現在のプロジェクトのアドオンデータも保存されます。 アドオン 選択したメモリ形式に含まれていない現在のプロジェクトのアドオン バージョン のバージョン アドオン 現在のプロファイルに含まれています 複数のバージョンがインストールされている場合は、バージョンを選択できます。 プロファイルを保存 を開きます プロファイル名を入力...", 
"body" : "このダイアログでは、選択したプロファイル（メモリ形式）を、現在のプロジェクトに含まれているアドオンによって拡張できます。プロファイルは一時的に保存され、保存またはエクスポートされた後に削除されます。 プロファイルに追加 ：現在のプロファイルはアドオンによって拡張されるため、現在のプロジェクトのアドオンデータも保存されます。 アドオン 選択したメモリ形式に含まれていない現在のプロジェクトのアドオン バージョン のバージョン アドオン 現在のプロファイルに含まれています 複数のバージョンがインストールされている場合は、バージョンを選択できます。 プロファイルを保存 を開きます プロファイル名を入力してください ダイアログ ダイアログで、新しいプロファイルの名前を指定します。新しいプロファイルはに永続的に保存されます $ProgramData$\/$PRODUCT$\/CustomInformationalProfiles 。 保存したプロファイルを使用する これで プロファイルを保存 永続的に保存されたプロファイルは、現在のプロジェクトを保存またはエクスポートするために使用されます。 詳細については、以下を参照してください。 プロジェクトの保存 と ロードして保存" }, 
{ "title" : "コマンド：プロジェクトを保存してライブラリリポジトリにインストールする ", 
"url" : "_cds_cmd_save_project_and_save_into_library_repository.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：プロジェクトを保存してライブラリリポジトリにインストールする ", 
"snippet" : "プロジェクトを保存してライブラリリポジトリにインストールする 関数 ：このコマンドは、プロジェクトをライブラリとして「システム」ライブラリリポジトリに保存します。 電話 ： ファイル メニュー コマンドで、 CODESYS プロジェクトをライブラリとして「システム」ライブラリリポジトリに保存します。これは、を使用してプロジェクトをライブラリファイルとして保存するための拡張機能です。 プロジェクトを名前を付けて保存 指図。ライブラリはローカルシステムにインストールされ、プロジェクトにすぐに挿入できます。...", 
"body" : "プロジェクトを保存してライブラリリポジトリにインストールする 関数 ：このコマンドは、プロジェクトをライブラリとして「システム」ライブラリリポジトリに保存します。 電話 ： ファイル メニュー コマンドで、 CODESYS プロジェクトをライブラリとして「システム」ライブラリリポジトリに保存します。これは、を使用してプロジェクトをライブラリファイルとして保存するための拡張機能です。 プロジェクトを名前を付けて保存 指図。ライブラリはローカルシステムにインストールされ、プロジェクトにすぐに挿入できます。 " }, 
{ "title" : "コマンド：プロジェクトをコンパイル済みライブラリとして保存 ", 
"url" : "_cds_cmd_save_project_as_compiled_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：プロジェクトをコンパイル済みライブラリとして保存 ", 
"snippet" : "プロジェクトをコンパイル済みライブラリとして保存 関数 ：このコマンドは、ライブラリプロジェクトを暗号化された形式で保存します。 電話 ： ファイル メニュー このコマンドは、ファイルシステムにファイルを保存するためのデフォルトのダイアログを開きます。 The 編集済み CODESYS ライブラリ ファイルタイプはすでにプリセットされています。ファイル拡張子は .compiled-library-v3 また .compiled-library （（ CODESYS < 3.5 SP15 ）。この形式では、ライブラリがプロジェクトで使用されている場合、ライブラリPOUのソースコードは表示されませ...", 
"body" : "プロジェクトをコンパイル済みライブラリとして保存 関数 ：このコマンドは、ライブラリプロジェクトを暗号化された形式で保存します。 電話 ： ファイル メニュー このコマンドは、ファイルシステムにファイルを保存するためのデフォルトのダイアログを開きます。 The 編集済み CODESYS ライブラリ ファイルタイプはすでにプリセットされています。ファイル拡張子は .compiled-library-v3 また .compiled-library （（ CODESYS < 3.5 SP15 ）。この形式では、ライブラリがプロジェクトで使用されている場合、ライブラリPOUのソースコードは表示されません。 の場合 コンパイルされたライブラリの署名を強制する オプションが選択されている セキュリティ画面 上のビュー ユーザー タブをクリックすると、保存時にライブラリプロジェクトにデジタル証明書ベースの署名を提供する必要があります。適切な証明書が利用可能な場合、それは セキュリティ画面 に ユーザー のタブ デジタル署名 セクション。の中に プロジェクト情報 、 概要 タブ、 ライブラリの互換性 とともに CODESYS バージョン> = 3.5 SP15 デフォルトで設定されています。この場合、プロジェクトファイルは .compiled-library-v3 コンパイルおよび署名されたライブラリとして保存される場合のファイル拡張子。それでもユーザープロファイルに適した有効な証明書を指定していない場合は、 セキュリティ画面 、次に、これを行うためのダイアログプロンプトが開きます。その後、saveコマンドを再度実行できます。 他のすべての点で、コンパイルされたライブラリファイルは同じように動作します *.library ファイル、したがって、それらは同じ手順でインストールおよび参照できます。 コンパイルされ、証明書で署名されたライブラリを使用することをお勧めします。ソースコードの保護とライブラリの不正使用に加えて、使用されるメモリも少なくなるため、ロード時間が短縮されます。 翻訳付きの対応するヘルプファイルがある場合は、 CODESYS V 3.5 SP15 その後、次のように他の言語に翻訳してライブラリのドキュメントを拡張できます。 を配置します __lmd__<language>.aux 新しい言語用に作成されたファイル <library name>.lmd に平行なディレクトリ <library name>.compiled-library-v3 ライブラリプロジェクト。 ファイルが正しければ、ライブラリプロジェクトが次の方法で保存されるときに、コンパイルされたライブラリファイルに含まれます。 プロジェクトをコンパイル済みライブラリとして保存 指図。 例： standard.lmd ディレクトリは、と並行して存在します standard.compiled-library-v3 ライブラリファイルとが含まれています __lmd__fr.aux ライブラリドキュメントのフランス語訳を含むファイル。コンパイルされたライブラリが保存されると、フランス語版のドキュメントもライブラリマネージャで利用できるようになります。 詳細については、以下を参照してください。 ライブラリ開発者向けの情報 と プロジェクトを保存してライブラリリポジトリにインストールする" }, 
{ "title" : "コマンド：アーカイブの保存\/送信 ", 
"url" : "_cds_cmd_save_send_archive.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：アーカイブの保存\/送信 ", 
"snippet" : "アーカイブの保存\/送信 関数 ：コマンドは プロジェクトアーカイブ プロジェクトアーカイブの構成に関するダイアログ。 コール : ファイル → プロジェクトアーカイブ メニュー アーカイブファイル（* .projectarchive）には、現在開いているプロジェクトに含まれ、参照されているすべてのファイルが含まれています。保存することも、電子メールの添付ファイルとして送信することもできます。電子メールとして送信することは、プロジェクトに関連するすべてのファイルを同僚に提供するのに非常に役立ちます。ファイルは、次の方法で簡単に再度解凍できます。 アーカイブの抽出 指図。 アーカイブ機能は、プロジ...", 
"body" : "アーカイブの保存\/送信 関数 ：コマンドは プロジェクトアーカイブ プロジェクトアーカイブの構成に関するダイアログ。 コール : ファイル → プロジェクトアーカイブ メニュー アーカイブファイル（* .projectarchive）には、現在開いているプロジェクトに含まれ、参照されているすべてのファイルが含まれています。保存することも、電子メールの添付ファイルとして送信することもできます。電子メールとして送信することは、プロジェクトに関連するすべてのファイルを同僚に提供するのに非常に役立ちます。ファイルは、次の方法で簡単に再度解凍できます。 アーカイブの抽出 指図。 アーカイブ機能は、プロジェクトの保存ではなく、プロジェクトに関連するすべてのファイルの単純な要約を目的としています。 " }, 
{ "title" : "ダイアログ：プロジェクトアーカイブ ", 
"url" : "_cds_cmd_save_send_archive.html#UUID-276bb6db-1861-3b1e-cd2f-bfc223682f8d_id_a9a34c3aeeaced8c0a8640e00146045_id_96a5b119635a8e3bc0a8640e005df4c1", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：アーカイブの保存\/送信 \/ ダイアログ：プロジェクトアーカイブ ", 
"snippet" : "ダイアログには、プロジェクトアーカイブに追加できるすべてのカテゴリが表示されます。このダイアログでは、次を選択できます カテゴリ全体またはカテゴリの個々のオブジェクトをプロジェクトアーカイブに追加できます。 リストに赤で表示されるエントリには注意が必要です。詳細については、このライブラリにマウスポインタを合わせてください。 追加ファイル を開きます 追加ファイル ダイアログ そこで使用できます 追加 ボタンを押してファイルを追加します。 コメント 「コメント」ダイアログを開きます そこで、アーカイブにコメントを追加できます。 保存 アーカイブファイルを作成して保存します 場所とアーカイブ名は、...", 
"body" : "ダイアログには、プロジェクトアーカイブに追加できるすべてのカテゴリが表示されます。このダイアログでは、次を選択できます カテゴリ全体またはカテゴリの個々のオブジェクトをプロジェクトアーカイブに追加できます。 リストに赤で表示されるエントリには注意が必要です。詳細については、このライブラリにマウスポインタを合わせてください。 \n \n \n \n \n 追加ファイル \n \n \n を開きます 追加ファイル ダイアログ \n そこで使用できます 追加 ボタンを押してファイルを追加します。 \n \n \n \n コメント \n \n \n 「コメント」ダイアログを開きます \n そこで、アーカイブにコメントを追加できます。 \n \n \n \n 保存 \n \n \n アーカイブファイルを作成して保存します \n 場所とアーカイブ名は、後続のダイアログで指定されます。 \n \n \n \n 送信 \n \n \n 空の電子メールに添付される一時的なアーカイブファイルを作成します \n この操作を正常に実行するには、MAPI（Messaging Application Programming Interface）を正しくインストールする必要があります。障害は、対応するエラーメッセージを表示することで文書化されます。電子メールの送信後、一時アーカイブは自動的に削除されます。 \n \n " }, 
{ "title" : "コマンド：アーカイブの抽出 ", 
"url" : "_cds_cmd_extract_archive.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：アーカイブの抽出 ", 
"snippet" : "アーカイブの抽出 関数 : コマンドは、コマンドを使用して作成されたリポジトリを抽出します アーカイブを保存\/送信 作成されました。その前に、アーカイブのどのコンテンツを抽出し、ファイル システム内のどのディレクトリにコピーするかを構成する必要があります。 電話 ： ファイル→プロジェクトアーカイブ メニュー デフォルトでは、アーカイブには .projectarchive ファイル拡張子。 アーカイブを選択すると、 プロジェクトアーカイブの抽出 抽出を構成するダイアログが開きます。...", 
"body" : "アーカイブの抽出 関数 : コマンドは、コマンドを使用して作成されたリポジトリを抽出します アーカイブを保存\/送信 作成されました。その前に、アーカイブのどのコンテンツを抽出し、ファイル システム内のどのディレクトリにコピーするかを構成する必要があります。 電話 ： ファイル→プロジェクトアーカイブ メニュー デフォルトでは、アーカイブには .projectarchive ファイル拡張子。 アーカイブを選択すると、 プロジェクトアーカイブの抽出 抽出を構成するダイアログが開きます。 " }, 
{ "title" : "ダイアログ：プロジェクトアーカイブの抽出 ", 
"url" : "_cds_cmd_extract_archive.html#UUID-0b9634c6-9978-893d-8419-d94a07a18d40_UUID-d609574c-71bc-f347-9967-86de00b02f23", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：アーカイブの抽出 \/ ダイアログ：プロジェクトアーカイブの抽出 ", 
"snippet" : "プロジェクトアーカイブを抽出する ダイアログには、プロジェクトアーカイブの内容が表示されます。選択を解除できます カテゴリ全体またはカテゴリからの単一のオブジェクトを抽出から除外します。 リポジトリにGitプロジェクトとGitリポジトリ情報が含まれている場合は、リポジトリ情報も必ず解凍してください。そうしないと、解凍されたGitプロジェクトが、ローカルにすでに存在するディレクトリと同じ名前のリポジトリにリンクされている場合に、望ましくない影響が発生する可能性があります。 ファイルパス アーカイブが配置されているのと同じフォルダーに抽出します アーカイブは同じディレクトリに抽出されます。 次のフ...", 
"body" : "プロジェクトアーカイブを抽出する ダイアログには、プロジェクトアーカイブの内容が表示されます。選択を解除できます カテゴリ全体またはカテゴリからの単一のオブジェクトを抽出から除外します。 リポジトリにGitプロジェクトとGitリポジトリ情報が含まれている場合は、リポジトリ情報も必ず解凍してください。そうしないと、解凍されたGitプロジェクトが、ローカルにすでに存在するディレクトリと同じ名前のリポジトリにリンクされている場合に、望ましくない影響が発生する可能性があります。 ファイルパス アーカイブが配置されているのと同じフォルダーに抽出します アーカイブは同じディレクトリに抽出されます。 次のフォルダに解凍します アーカイブの内容は、指定されたパスに抽出されます。 高度 を開きます 高度 アーカイブから特別なファイルと追加のファイルを抽出する場所を定義するダイアログ。 コンテンツ オブジェクト オブジェクトカテゴリで構造化されたアーカイブのコンテンツを表示します ：オブジェクトが抽出されます。 ：オブジェクトは抽出されません。 コメント プロジェクトアーカイブの作成時に入力されたコメント エキス 抽出されたファイルの名前がターゲットディレクトリ内の既存のファイルと同じである場合は、ダイアログが開き、ローカルファイルを置き換えるかどうかを確認するメッセージが表示されます。決定は、他の競合する名前に自動的に適用できます。この場合、を選択する必要があります すべてのオブジェクトとファイルに適用 オプション。 " }, 
{ "title" : "ダイアログ： 高度 ", 
"url" : "_cds_cmd_extract_archive.html#UUID-0b9634c6-9978-893d-8419-d94a07a18d40_id_e7d1fb8371682c0a8640e01de9372_id_1ab891adf85c11e3ab2595dcbe415eae", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：アーカイブの抽出 \/ ダイアログ： 高度 ", 
"snippet" : "リポジトリ デバイスをにインストールします 現在利用可能なリポジトリのリストボックス リポジトリを選択します CODESYS アーカイブのデバイスとライブラリをインストールする必要があります。 ライブラリをにインストールする 追加ファイル デフォルトでは、「追加ファイル」は次のように事前構成されています 抽出しないでください 。これを変更するには、テーブルのエントリを選択し、次のいずれかのオプションを選択します。 プロジェクトフォルダに抽出します プロジェクトファイルのディレクトリ フォルダに抽出 カスタムディレクトリ 抽出しないでください デフォルト設定...", 
"body" : "リポジトリ デバイスをにインストールします 現在利用可能なリポジトリのリストボックス リポジトリを選択します CODESYS アーカイブのデバイスとライブラリをインストールする必要があります。 ライブラリをにインストールする 追加ファイル デフォルトでは、「追加ファイル」は次のように事前構成されています 抽出しないでください 。これを変更するには、テーブルのエントリを選択し、次のいずれかのオプションを選択します。 プロジェクトフォルダに抽出します プロジェクトファイルのディレクトリ フォルダに抽出 カスタムディレクトリ 抽出しないでください デフォルト設定 " }, 
{ "title" : "コマンド：ソースダウンロード ", 
"url" : "_cds_cmd_source_upload.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：ソースダウンロード ", 
"snippet" : "ソースのダウンロード 関数 ：このコマンドは、コントローラーでプロジェクトアーカイブとして使用できるプロジェクトソースコードをコントローラーからロードします。 電話 ： ファイル メニュー 要件 ：コントローラのネットワークパスを設定する必要があります。 コマンドを実行すると、ネットワーク内のすべてのデバイスの概要が開きます。この概要からコントローラーを選択します。その後、 プロジェクトアーカイブの抽出 ダイアログが開き、抽出の設定が表示されます。 詳細については、以下を参照してください。 PLCとの間でソースコードをダウンロードする...", 
"body" : "ソースのダウンロード 関数 ：このコマンドは、コントローラーでプロジェクトアーカイブとして使用できるプロジェクトソースコードをコントローラーからロードします。 電話 ： ファイル メニュー 要件 ：コントローラのネットワークパスを設定する必要があります。 コマンドを実行すると、ネットワーク内のすべてのデバイスの概要が開きます。この概要からコントローラーを選択します。その後、 プロジェクトアーカイブの抽出 ダイアログが開き、抽出の設定が表示されます。 詳細については、以下を参照してください。 PLCとの間でソースコードをダウンロードする" }, 
{ "title" : "ダイアログ：プロジェクトアーカイブの抽出 ", 
"url" : "_cds_cmd_source_upload.html#UUID-0bffdb14-f884-fdff-c7f7-9f985d6beb45_UUID-d609574c-71bc-f347-9967-86de00b02f23", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：ソースダウンロード \/ ダイアログ：プロジェクトアーカイブの抽出 ", 
"snippet" : "プロジェクトアーカイブを抽出する ダイアログには、プロジェクトアーカイブの内容が表示されます。選択を解除できます カテゴリ全体またはカテゴリからの単一のオブジェクトを抽出から除外します。 リポジトリにGitプロジェクトとGitリポジトリ情報が含まれている場合は、リポジトリ情報も必ず解凍してください。そうしないと、解凍されたGitプロジェクトが、ローカルにすでに存在するディレクトリと同じ名前のリポジトリにリンクされている場合に、望ましくない影響が発生する可能性があります。 ファイルパス アーカイブが配置されているのと同じフォルダーに抽出します アーカイブは同じディレクトリに抽出されます。 次のフ...", 
"body" : "プロジェクトアーカイブを抽出する ダイアログには、プロジェクトアーカイブの内容が表示されます。選択を解除できます カテゴリ全体またはカテゴリからの単一のオブジェクトを抽出から除外します。 リポジトリにGitプロジェクトとGitリポジトリ情報が含まれている場合は、リポジトリ情報も必ず解凍してください。そうしないと、解凍されたGitプロジェクトが、ローカルにすでに存在するディレクトリと同じ名前のリポジトリにリンクされている場合に、望ましくない影響が発生する可能性があります。 ファイルパス アーカイブが配置されているのと同じフォルダーに抽出します アーカイブは同じディレクトリに抽出されます。 次のフォルダに解凍します アーカイブの内容は、指定されたパスに抽出されます。 高度 を開きます 高度 アーカイブから特別なファイルと追加のファイルを抽出する場所を定義するダイアログ。 コンテンツ オブジェクト オブジェクトカテゴリで構造化されたアーカイブのコンテンツを表示します ：オブジェクトが抽出されます。 ：オブジェクトは抽出されません。 コメント プロジェクトアーカイブの作成時に入力されたコメント エキス 抽出されたファイルの名前がターゲットディレクトリ内の既存のファイルと同じである場合は、ダイアログが開き、ローカルファイルを置き換えるかどうかを確認するメッセージが表示されます。決定は、他の競合する名前に自動的に適用できます。この場合、を選択する必要があります すべてのオブジェクトとファイルに適用 オプション。 " }, 
{ "title" : "コマンド：ソースのアップロード ", 
"url" : "_cds_cmd_source_download.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：ソースのアップロード ", 
"snippet" : "ソースのアップロード 関数 ：このコマンドは、プロジェクトのソースコードをプロジェクトアーカイブとしてコントローラーにロードします。 電話 ： ファイル メニュー 要件 ：コントローラのネットワークパスを設定する必要があります。 コマンドを実行すると、ネットワーク内のすべてのデバイスの概要が開きます。この概要からコントローラーを選択します。その後、 Archive.prj プロジェクトアーカイブがこのコントローラーにダウンロードされます。後で、クリックすることができます ソースのアップロード 完全なソースコードをにダウンロードするには CODESYS 開発システム。 すでにコントローラーに接続...", 
"body" : "ソースのアップロード 関数 ：このコマンドは、プロジェクトのソースコードをプロジェクトアーカイブとしてコントローラーにロードします。 電話 ： ファイル メニュー 要件 ：コントローラのネットワークパスを設定する必要があります。 コマンドを実行すると、ネットワーク内のすべてのデバイスの概要が開きます。この概要からコントローラーを選択します。その後、 Archive.prj プロジェクトアーカイブがこのコントローラーにダウンロードされます。後で、クリックすることができます ソースのアップロード 完全なソースコードをにダウンロードするには CODESYS 開発システム。 すでにコントローラーに接続している場合（オンラインモード）、 接続されたデバイスへのソースのダウンロード この操作にはコマンドも使用できます。 詳細については、以下を参照してください。 PLCとの間でソースコードをダウンロードする" }, 
{ "title" : "コマンド：印刷 ", 
"url" : "_cds_cmd_print.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：印刷 ", 
"snippet" : "印刷 シンボル ： 関数 ：このコマンドは、ドキュメントを印刷するためのデフォルトのWindowsダイアログを開きます。 電話 ： ファイル メニュー...", 
"body" : "印刷 シンボル ： 関数 ：このコマンドは、ドキュメントを印刷するためのデフォルトのWindowsダイアログを開きます。 電話 ： ファイル メニュー " }, 
{ "title" : "コマンド：印刷プレビュー ", 
"url" : "_cds_cmd_print_preview.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：印刷プレビュー ", 
"snippet" : "印刷プレビュー 関数 ：コマンドは、である要素の印刷プレビューを開きます。コマンドは、現在開いている要素の印刷プレビューを開きます。 電話 ： ファイル メニュー 要件 ：オブジェクトがエディタで開かれています。...", 
"body" : "印刷プレビュー 関数 ：コマンドは、である要素の印刷プレビューを開きます。コマンドは、現在開いている要素の印刷プレビューを開きます。 電話 ： ファイル メニュー 要件 ：オブジェクトがエディタで開かれています。 " }, 
{ "title" : "コマンド：ページ設定 ", 
"url" : "_cds_cmd_page_setup.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：ページ設定 ", 
"snippet" : "ページ設定 シンボル： 関数 ：コマンドは ページ設定 プロジェクトコンテンツの印刷バージョンのレイアウトを構成するためのダイアログ。 電話 ： ファイル→ページ設定 メニュー...", 
"body" : "ページ設定 シンボル： 関数 ：コマンドは ページ設定 プロジェクトコンテンツの印刷バージョンのレイアウトを構成するためのダイアログ。 電話 ： ファイル→ページ設定 メニュー " }, 
{ "title" : "コマンド：最近のプロジェクト ", 
"url" : "_cds_cmd_recent_projects.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：最近のプロジェクト ", 
"snippet" : "最近のプロジェクト 関数 ：このコマンドは、最近使用されたプロジェクトのリストを開きます。そのうちの1つを選択して開くことができます。 電話 ： ファイル メニュー...", 
"body" : "最近のプロジェクト 関数 ：このコマンドは、最近使用されたプロジェクトのリストを開きます。そのうちの1つを選択して開くことができます。 電話 ： ファイル メニュー " }, 
{ "title" : "コマンド：終了 ", 
"url" : "_cds_cmd_exit.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ファイル \/ コマンド：終了 ", 
"snippet" : "出口 キーボードショートカット： Alt + F4 関数 ：コマンドはプログラミングシステムを終了します。最後の保存操作以降に変更されたプロジェクトが開いている場合は、プロジェクトを保存するかどうかを確認するダイアログが開きます。 電話 ： ファイル メニュー...", 
"body" : "出口 キーボードショートカット： Alt + F4 関数 ：コマンドはプログラミングシステムを終了します。最後の保存操作以降に変更されたプロジェクトが開いている場合は、プロジェクトを保存するかどうかを確認するダイアログが開きます。 電話 ： ファイル メニュー " }, 
{ "title" : "意見 ", 
"url" : "_cds_f_commands_view.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "ビューのデフォルトメニュー：デバイス、POU、モジュール ", 
"url" : "_cds_dropdown_menu_in_standard_views.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ ビューのデフォルトメニュー：デバイス、POU、モジュール ", 
"snippet" : "ビュー 装置 、 POU と モジュール それぞれ右上隅にボタンがあります 次のコマンドでメニューを開きます。 メモ帳で開く ：対応するエディタのビューで選択されたブロックを開きます 検索オブジェクト ：ダイアログを開きます 検索オブジェクト ビュー内のオブジェクトツリーの場合 文字列の入力を開始すると、現在の検索結果が常に名前とパスとともに表示されます。ボタン付き 開ける 選択した検索結果を関連するエディターで開くことができます。 タイプで並べ替え ：ウィンドウ内のオブジェクトをタイプ別およびアルファベット順に並べ替えます 名前順 ：ウィンドウ内のオブジェクトを名前とアルファベット順に並べ替...", 
"body" : "ビュー 装置 、 POU と モジュール それぞれ右上隅にボタンがあります 次のコマンドでメニューを開きます。 メモ帳で開く ：対応するエディタのビューで選択されたブロックを開きます 検索オブジェクト ：ダイアログを開きます 検索オブジェクト ビュー内のオブジェクトツリーの場合 文字列の入力を開始すると、現在の検索結果が常に名前とパスとともに表示されます。ボタン付き 開ける 選択した検索結果を関連するエディターで開くことができます。 タイプで並べ替え ：ウィンドウ内のオブジェクトをタイプ別およびアルファベット順に並べ替えます 名前順 ：ウィンドウ内のオブジェクトを名前とアルファベット順に並べ替えます ソート昇順 ：上で選択した並べ替えを昇順で表示します 降順で並べ替える ：上記で選択した並べ替えを降順で表示します アクティブなエディタを追跡する ： CODESYS ビューのオブジェクトツリーで現在アクティブなエディタで開いているオブジェクトを選択します。 " }, 
{ "title" : "コマンド：デバイス ", 
"url" : "_cds_cmd_devices.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：デバイス ", 
"snippet" : "装置 シンボル： キーボードショートカット： 年 + 0 関数 ：コマンドはビューを開きます 装置 の中に CODESYS メインウィンドウ。これには、アプリケーションを構成するプロジェクトの「デバイスツリー」が含まれています。 ボタンについて ビューのオブジェクトツリーをナビゲートするための標準メニューが利用可能です。 電話 ：メニュー 意見 詳細については、以下を参照してください。 デバイスツリーとデバイスエディタ...", 
"body" : "装置 シンボル： キーボードショートカット： 年 + 0 関数 ：コマンドはビューを開きます 装置 の中に CODESYS メインウィンドウ。これには、アプリケーションを構成するプロジェクトの「デバイスツリー」が含まれています。 ボタンについて ビューのオブジェクトツリーをナビゲートするための標準メニューが利用可能です。 電話 ：メニュー 意見 詳細については、以下を参照してください。 デバイスツリーとデバイスエディタ" }, 
{ "title" : "コマンド：POU ", 
"url" : "_cds_cmd_pous.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：POU ", 
"snippet" : "POU シンボル： キーボードショートカット： 年 + 1 関数 ：コマンドはビューを開きます POU の中に CODESYS メインウィンドウ。ここにあるブロックは、プロジェクト全体で利用できます。 電話 ：メニュー 意見...", 
"body" : "POU シンボル： キーボードショートカット： 年 + 1 関数 ：コマンドはビューを開きます POU の中に CODESYS メインウィンドウ。ここにあるブロックは、プロジェクト全体で利用できます。 電話 ：メニュー 意見 " }, 
{ "title" : "コマンド：モジュール ", 
"url" : "_cds_cmd_modules.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：モジュール ", 
"snippet" : "モジュール シンボル： 関数 ：コマンドはビューを開きます モジュール 。その中で彼らは モジュール ツリー構造のApplicationComposerの 電話 ：メニュー 意見...", 
"body" : "モジュール シンボル： 関数 ：コマンドはビューを開きます モジュール 。その中で彼らは モジュール ツリー構造のApplicationComposerの 電話 ：メニュー 意見 " }, 
{ "title" : "コマンド：レポート ", 
"url" : "_cds_cmd_messages.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：レポート ", 
"snippet" : "メッセージ シンボル： 関数 ：コマンドはビューを開きます メッセージ 。 電話 ：メニュー 意見...", 
"body" : "メッセージ シンボル： 関数 ：コマンドはビューを開きます メッセージ 。 電話 ：メニュー 意見 " }, 
{ "title" : "表示：メッセージ ", 
"url" : "_cds_cmd_messages.html#UUID-119e042d-47fd-099a-1188-ae75ac690d78_id_af63110db5724c0a8640e01487d4a_id_57525bcedefa7c4cc0a8640e01fa4246", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：レポート \/ 表示：メッセージ ", 
"snippet" : "メッセージカテゴリ メッセージはコンポーネントまたは機能ごとに分類され、選択ダイアログで利用できます。カテゴリを選択して、メッセージ表示をフィルタリングします。 メッセージタイプ メッセージタイプアイコンをクリックして、メッセージを表示または非表示にします。各アイコンの横に表示されます CODESYS 発生したメッセージの数。 ： エラー ： 警告 ： 情報 選択したメッセージカテゴリのすべてのメッセージを削除します すべてのメッセージカテゴリのすべてのメッセージを削除します 説明 それを引き起こしたオブジェクトとオブジェクト内の位置を含むメッセージテキスト テーブル内のメッセージエントリをダ...", 
"body" : "メッセージカテゴリ メッセージはコンポーネントまたは機能ごとに分類され、選択ダイアログで利用できます。カテゴリを選択して、メッセージ表示をフィルタリングします。 メッセージタイプ メッセージタイプアイコンをクリックして、メッセージを表示または非表示にします。各アイコンの横に表示されます CODESYS 発生したメッセージの数。 ： エラー ： 警告 ： 情報 選択したメッセージカテゴリのすべてのメッセージを削除します すべてのメッセージカテゴリのすべてのメッセージを削除します 説明 それを引き起こしたオブジェクトとオブジェクト内の位置を含むメッセージテキスト テーブル内のメッセージエントリをダブルクリックして、ソースコードの場所に移動します。 コマンド アイコン: 未解決のライブラリの場合、報告されたエラーのクイックフィックスに使用できるコマンドを一覧表示します プレースホルダー '<ライブラリ>' を最新バージョンに更新します ライブラリマネージャーの「プレースホルダー」ダイアログを開く 計画 メッセージを生成するプロジェクトの名前 物体 メッセージが生成されたオブジェクト ポジション コード内の位置 コンテキストメニューのコマンド 次のメッセージ 次のメッセージのソーステキストの位置が表示されます。 前のメッセージ 前のメッセージのソースコード位置が表示されます。 ソース位置に移動 選択したメッセージのソーステキストの位置が表示されます。 " }, 
{ "title" : "コマンド：要素のプロパティ ", 
"url" : "_cds_cmd_element_properties.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：要素のプロパティ ", 
"snippet" : "アイテムのプロパティ シンボル： 関数 ：コマンドはビューを開きます アイテムのプロパティ 。 電話 ：メニュー 意見 このコマンドを使用して、現在開いているオブジェクトのプロパティビューを開きます。このビューは、ビジュアライゼーションやPOU（AS）などのいくつかのオブジェクトでのみ使用できます。 プロパティは構造化テーブルに表示されます。値フィールドをクリックして、プロパティの値を変更します。プロパティビューをフィルタリングまたは並べ替えることができます。...", 
"body" : "アイテムのプロパティ シンボル： 関数 ：コマンドはビューを開きます アイテムのプロパティ 。 電話 ：メニュー 意見 このコマンドを使用して、現在開いているオブジェクトのプロパティビューを開きます。このビューは、ビジュアライゼーションやPOU（AS）などのいくつかのオブジェクトでのみ使用できます。 プロパティは構造化テーブルに表示されます。値フィールドをクリックして、プロパティの値を変更します。プロパティビューをフィルタリングまたは並べ替えることができます。 " }, 
{ "title" : "コマンド：ツール ", 
"url" : "_cds_cmd_tools.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：ツール ", 
"snippet" : "ツール シンボル： 関数 ：コマンドはビューを開きます ツール 。 電話 ：メニュー 意見 このコマンドを使用して、現在開いているオブジェクトのツールビューを開きます。このビューは、デフォルトでグラフィカルエディタまたはビジュアライゼーションで使用できます。これには、エディターにドラッグできるグラフィカルプログラミング要素が含まれています。...", 
"body" : "ツール シンボル： 関数 ：コマンドはビューを開きます ツール 。 電話 ：メニュー 意見 このコマンドを使用して、現在開いているオブジェクトのツールビューを開きます。このビューは、デフォルトでグラフィカルエディタまたはビジュアライゼーションで使用できます。これには、エディターにドラッグできるグラフィカルプログラミング要素が含まれています。 " }, 
{ "title" : "コマンド：watchlist-watchlist <n> ", 
"url" : "_cds_cmd_view_watch.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：watchlist-watchlist <n> ", 
"snippet" : "ウォッチリスト-ウォッチリスト<n> シンボル： 関数 ：コマンドはビューを開きます ウォッチリスト<n> 。単一のビュー内でこれらの変数の値をオンラインで監視、強制、または書き込むことができるように、プロジェクトの変数を監視リストに入力できます。値「n」は1、2、3、または4にすることができます。これは、最大4つのウォッチリストを構成できることを意味します。 電話 ：メニュー 意見 詳細については、以下を参照してください。 ウォッチリストを使用する...", 
"body" : "ウォッチリスト-ウォッチリスト<n> シンボル： 関数 ：コマンドはビューを開きます ウォッチリスト<n> 。単一のビュー内でこれらの変数の値をオンラインで監視、強制、または書き込むことができるように、プロジェクトの変数を監視リストに入力できます。値「n」は1、2、3、または4にすることができます。これは、最大4つのウォッチリストを構成できることを意味します。 電話 ：メニュー 意見 詳細については、以下を参照してください。 ウォッチリストを使用する" }, 
{ "title" : "コマンド：ウォッチリスト :すべての部隊を表示 ", 
"url" : "_cds_cmd_view_watch_all_forces.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：ウォッチリスト :すべての部隊を表示 ", 
"snippet" : "ウォッチリスト :すべての部隊を表示 シンボル： 関数 ：コマンドはビューを開きます すべての力を表示 、これはウォッチリストの特別な形式です。 電話 ：メニュー 表示→ウォッチリスト→すべての部隊を表示 要件 ：プロジェクトはオフラインモードまたはオンラインモードで開いています。 ビューには、現在強制用に準備されているアプリケーションのすべての変数と、リスト内のすべての強制変数が含まれています。リストでは、他の監視リストでも可能なアクションが可能です。また、セレクションリストにあります 強制解除 次のコマンド： すべての力を表示 強制され、強制のために準備されたアプリケーションのすべての変数...", 
"body" : "ウォッチリスト :すべての部隊を表示 シンボル： 関数 ：コマンドはビューを開きます すべての力を表示 、これはウォッチリストの特別な形式です。 電話 ：メニュー 表示→ウォッチリスト→すべての部隊を表示 要件 ：プロジェクトはオフラインモードまたはオンラインモードで開いています。 ビューには、現在強制用に準備されているアプリケーションのすべての変数と、リスト内のすべての強制変数が含まれています。リストでは、他の監視リストでも可能なアクションが可能です。また、セレクションリストにあります 強制解除 次のコマンド： すべての力を表示 強制され、強制のために準備されたアプリケーションのすべての変数の表形式の表示 表現 変数名 データ・タイプ 変数のデータ型 価値 変数の現在の強制値 準備された価値 強制するために準備された値 サイクル開始時に上書きされた値 入力の場合、ユーザーコードが実行される前に、実際の値はすでにforce値で上書きされています。したがって、これは強制値です。 出力の場合、これは強制値です。 サイクル終了時に上書きされた値 出力の場合、これはサイクルで計算される値です。ただし、この値は、サイクルの終了時に力の値で上書きされます。 入力の場合、これは強制値です。 選択したすべての値を強制解除して保持します ：リストで選択されたすべてのエントリについて、変数が強制値に設定され、強制が削除されます。 選択したすべての値を強制解除して復元します ：リストで選択されたすべてのエントリについて、変数は強制前の値にリセットされ、強制は削除されます。 詳細については、以下を参照してください。 変数の強制と書き込み と ウォッチリストを使用する" }, 
{ "title" : "コマンド：すべての部隊を監視リストに追加します ", 
"url" : "_cds_cmd_add_all_forces_to_watchlist.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：すべての部隊を監視リストに追加します ", 
"snippet" : "ウォッチリストにすべての部隊を追加 関数 ：このコマンドは、現在強制する準備ができている、またはすでに強制されている現在のアプリケーションのすべての変数を監視リストに追加します。ただし、これはドッキングされたウォッチリストに対してのみ機能することに注意してください。 電話 ：ビューのコンテキストメニュー ウォッチリスト 要件 ：オンライン操作、監視リストがアクティブです。 特別なウォッチリストがあります： すべての力を見る 、強制するために準備された、または強制されているすべての変数を常に自動的に表示します。また、強制をキャンセルするコマンドも提供します。 詳細については、以下を参照してくださ...", 
"body" : "ウォッチリストにすべての部隊を追加 関数 ：このコマンドは、現在強制する準備ができている、またはすでに強制されている現在のアプリケーションのすべての変数を監視リストに追加します。ただし、これはドッキングされたウォッチリストに対してのみ機能することに注意してください。 電話 ：ビューのコンテキストメニュー ウォッチリスト 要件 ：オンライン操作、監視リストがアクティブです。 特別なウォッチリストがあります： すべての力を見る 、強制するために準備された、または強制されているすべての変数を常に自動的に表示します。また、強制をキャンセルするコマンドも提供します。 詳細については、以下を参照してください。 ウォッチリスト :すべての部隊を表示" }, 
{ "title" : "コマンド：ブックマーク ", 
"url" : "_cds_cmd_bookmarks.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：ブックマーク ", 
"snippet" : "ブックマーク シンボル： 関数 ：コマンドはビューを開きます ブックマーク 。 電話 ：メニュー 意見 前のブックマーク 選択した行の1行上にあるテーブルに表示されているブックマークにジャンプし、対応するPOUをエディターで開きます 次のブックマーク 選択した行の1行下のテーブルに表示されているブックマークにジャンプし、対応するPOUをエディターで開きます 選択したブックマークをテーブルと対応するPOUから削除します 情報を含むプロジェクトのブックマークのリスト ブックマーク 、 物体 と ポジション ドラッグアンドドロップを使用して、ブックマークの順序を変更できます。 行をダブルクリックする...", 
"body" : "ブックマーク シンボル： 関数 ：コマンドはビューを開きます ブックマーク 。 電話 ：メニュー 意見 前のブックマーク 選択した行の1行上にあるテーブルに表示されているブックマークにジャンプし、対応するPOUをエディターで開きます 次のブックマーク 選択した行の1行下のテーブルに表示されているブックマークにジャンプし、対応するPOUをエディターで開きます 選択したブックマークをテーブルと対応するPOUから削除します 情報を含むプロジェクトのブックマークのリスト ブックマーク 、 物体 と ポジション ドラッグアンドドロップを使用して、ブックマークの順序を変更できます。 行をダブルクリックすると、が開きます CODESYS 対応します 物体 エディターで、そのブックマークにジャンプします。 ブックマーク から CODESYS 番号付きの昇順で割り当てられたブックマークの指定： ブックマーク_0 、 しおり_2 等 ブックマークを選択してフィールドをクリックすると、ブックマークが編集可能になり、ブックマークのラベルを変更できます。 物体 ブックマークが設定されているPOUの名前とプロジェクトパス 例： POU_Add [PLC_1: SPS-Logic: Application] ポジション POU内のブックマークの位置 例： Zeile3, Spalte 1 (Impl) (Impl) ：POUの実装部分 (Decl) ：POUの宣言部分 詳細については、以下を参照してください。 ブックマークを設定して使用する" }, 
{ "title" : "コマンド：ブレークポイント ", 
"url" : "_cds_cmd_breakpoints.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：ブレークポイント ", 
"snippet" : "ブレークポイント シンボル： 関数 ：コマンドはビューを開きます ブレークポイント 。 電話 ：メニュー 意見 ビューには、アプリケーションで定義されているすべてのブレークポイントの概要が表示されます。すべてのブレークポイントコマンドは、ビュー内で使用できます。 現在のブレークポイントのテーブル 応用 リストから目的のアプリケーションを選択します。 POU ブレークポイントを含むビルディングブロックの名前 ポジション POU内のブレークポイントの位置 テキストエディタ：行と列番号 グラフィックエディタ：ネットワークまたは要素番号 ファンクションブロックの場合の「（Impl）」は、ブレークポイン...", 
"body" : "ブレークポイント シンボル： 関数 ：コマンドはビューを開きます ブレークポイント 。 電話 ：メニュー 意見 ビューには、アプリケーションで定義されているすべてのブレークポイントの概要が表示されます。すべてのブレークポイントコマンドは、ビュー内で使用できます。 現在のブレークポイントのテーブル 応用 リストから目的のアプリケーションを選択します。 POU ブレークポイントを含むビルディングブロックの名前 ポジション POU内のブレークポイントの位置 テキストエディタ：行と列番号 グラフィックエディタ：ネットワークまたは要素番号 ファンクションブロックの場合の「（Impl）」は、ブレークポイントがインスタンスではなく、ファンクションブロックの実装にあることを示します。 インスタンスパス ブレークポイント位置の完全なオブジェクトパス タスク ブレークポイントを実行するタスクの名前 制限がない場合は「（すべて）」と表示されます。 調子 常に停止する ：追加のアクティベーション条件は定義されていません ブレークポイントは常にアクティブです。 ブール式 式はする必要があります TRUE ブレークポイントをアクティブにするために配信します。 ヒットカウント条件 （ヒット数に応じて）ブレークポイントを有効にするタイミングの指定 現在のヒット数 実行中にブレークポイントがすでに渡された（「ヒット」）頻度の指定 最終更新日時監視値 監視対象の値が最後に更新された時刻を表示します。 ツールバー 新しいブレークポイント コマンドはダイアログを開きます ブレークポイントのプロパティ 。 新しいデータブレークポイント コマンドはダイアログを開きます 新しいブレークポイント 。 ブレークポイントを削除する ブレークポイントを削除します 非アクティブ化と混同しないでください！ ブレークポイントを有効\/無効にする ブレークポイントまたは実行ポイントを有効状態と無効状態の間で切り替えます ：ブレークポイントが有効になっています。 ：ブレークポイントは無効です。 ：実行ポイントがアクティブになります。 ：実行ポイントは無効になっています。 ：データブレークポイントが有効になっています。 ：データブレークポイントが無効になっています。 ：データ実行ポイントが有効になります。 ：データ実行ポイントが無効になります。 に反して ブレークポイントを削除する 無効にしたブレークポイントはリストに残り、再度有効にすることができます。 プロパティ 対話 ブレークポイントのプロパティ ブレークポイントパラメータを編集するために表示されます。対話は対話に対応します 新しいブレークポイント 。オンラインモードでは、ここでブレークポイントを実行ポイントに変換できます。 ソースコードの場所に移動します 関連するブロックのオンラインビューを開きます カーソルはブレークポイントの位置にあります。 すべてのブレークポイントを削除します アプリケーションのすべてのブレークポイントと実行ポイントをクリアします リストは空になります。非アクティブ化と混同しないでください！ すべてのブレークポイントを有効にする 現在無効になっているすべてのブレークポイントと実行ポイントを有効にします すべてのブレークポイントを無効にする 現在有効になっているすべてのブレークポイントと実行ポイントを無効にします ポイントはリストに残り、再度アクティブ化できます。 詳細については、以下を参照してください。 ブレークポイントの使用" }, 
{ "title" : "コマンド：相互参照リスト ", 
"url" : "_cds_cmd_view_cross_reference_list.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：相互参照リスト ", 
"snippet" : "相互参照リスト シンボル： 関数 ：コマンドはビューを開きます 相互参照リスト 。 電話 ：メニュー 意見 、 また 編集→シンボルの検索→相互参照の出力 ビューには、プロジェクト内のシンボルの相互参照のリストが表示されます。シンボルは、変数、POU（プログラム、関数ブロック、関数）、またはユーザー定義データ型（DUT）にすることができます。相互参照リストは、基本的に2種類の検索を提供します。 テキスト検索：シンボル名を入力すると、その名前のプロジェクト内のすべてのシンボルの相互参照が表示されます。同じ名前のシンボルが複数見つかった場合は、コンテキストメニューを使用して表示を個々の宣言に制限で...", 
"body" : "相互参照リスト シンボル： 関数 ：コマンドはビューを開きます 相互参照リスト 。 電話 ：メニュー 意見 、 また 編集→シンボルの検索→相互参照の出力 ビューには、プロジェクト内のシンボルの相互参照のリストが表示されます。シンボルは、変数、POU（プログラム、関数ブロック、関数）、またはユーザー定義データ型（DUT）にすることができます。相互参照リストは、基本的に2種類の検索を提供します。 テキスト検索：シンボル名を入力すると、その名前のプロジェクト内のすべてのシンボルの相互参照が表示されます。同じ名前のシンボルが複数見つかった場合は、コンテキストメニューを使用して表示を個々の宣言に制限できます。 宣言検索：シンボルは、入力ヘルプを使用するか、修飾されたパスを入力することで見つけることができます（たとえば Device.Application.PLC_PRG.i また __POOL.POU.a ）選ばれる。その後、同じ名前の他のシンボルがあっても、このシンボルが使用されている場所のみが表示されます。 入力ボックス シンボル名（変数名、ブロック名、DUT名）-入力オプション： ボタンを介した入力ヘルプによる宣言されたシンボルの選択 シンボル名を手動で入力する ボタンを使用して検索をトリガーします または 入力 ワイルドカードを使用できます \" * \"（任意の数の文字）または\" ? 「（正確に任意の文字）変数識別子のサブストリングとの組み合わせ。 つかいます \" % 'IECアドレスを検索する場合。 例： \" %MW8 \"、\" %M* 「」 コマンドの使用 シンボルの検索→相互参照の出力 、宣言されたシンボルの名前がエディタで選択されているか、カーソルが名前にある場合。デバイスツリーまたはPOUプールでオブジェクトが選択されている場合は、検索も可能です。 宣言されたシンボルの名前がエディターで選択されたとき、またはカーソルが名前にあるときに自動的に デバイスツリーまたはPOUプールでオブジェクトが選択されている場合は、自動検索も可能です。 要件： CODESYS -オプション 選択を変更するときに相互参照を自動的に更新します がアクティブになります。カテゴリー スマートコーディング 。 次のエントリが有効です。 変数名、単純または修飾 例： \" iVar \"、\" PLC_PRG.iVar 「」 ビルディングブロック名 例： \" PLC_PRG \"、\" myFB 「」 DUT名 例： \" mySTRUCT 「」 ワイルドカード「*」（任意の文字）または「？」（正確に1文字）と組み合わせた文字列 例： \" iVar * \"よろしく iVar1 、 iVar_glob2 、 iVar45 等 「」 iVar? 「よろしく iVar1 、 iVar2 、 iVarX など、しかしではない iVar_glob2 、 iVar45 等 「」 %<IEC-Adresse> \"： CODESYS このアドレスとダイレクトメモリアクセスに割り当てられた変数を探します。 例： \" %QB0 \"、 %Q0 := 2 入力ヘルプを開いて記号を選択します 検索を実行します 文字列を検索する列を定義します 入力ボックス 選択した列で検索される文字列 場所は黄色でマークされています。この文字列のない相互参照は非表示になります。 以前の相互参照のソースの場所を表示する 、 トグル + F4 次の相互参照のソース位置を表示 、 F4 結果を現在の宣言に制限する シンボルに対して複数の宣言が見つかった場合に使用可能 リストで選択した宣言に表示を制限します 選択した相互参照のソース位置を表示 フォーカスは、シンボルが使用されている場所にジャンプします。 相互参照リストを印刷する 印刷ジョブを設定するための標準ダイアログが表示されます。 見つかった相互参照は、次の情報とともに表示されます。 シンボル シンボル（変数、POU、DUT）の場所は、宣言に従ってグループ化されます。宣言ポイントはルートノードを形成し、プロジェクトの使用ポイントは下にインデントされて表示されます。シンボルが使用時に持っている表現が正確に表示されます。 例：プロジェクトにグローバル変数がありますか i およびPOUでローカルに宣言された変数 i 、次に相互参照のテキスト検索後、2つのルートノードエントリがリストに表示され、その下に変数が使用される場所が表示されます i 。 建築用ブロック デバイス名、DUT名;また、たとえば、タスク構成でのブロック呼び出しの場合のタスク名 変数 純粋な変数名 例： iVar アクセス 使用時点での変数へのアクセスのタイプ： 宣言 \/ 読む \/ 書くには \/ 電話 ポインタの特殊なケース 種類の割り当て p := ADR(var1) 探しているときに var1 なので Schreiben | Adresse 表示されます。理由：書き込みアクセスの可能性 p 探している var1 表示されません。ポインタ変数を介して書き込みアクセスも可能です。 タイプ 変数のデータ型 住所 変数に割り当てられている場合はIECアドレス 例： \" AT %QB0 「」 ポジション 影響を受けるPOUのエディター内での使用ポイントの位置（行番号、ネットワーク番号、宣言部分、実装部分など） 例： \" Zeile 1, Spalte 1 (Impl) 「」 物体 POU名+角かっこで囲まれた使用ポイントのフルパス（これがビューにある場合） 装置 位置した 例： \" PLC_PRG [Device:Plc Logic:Application] 「」 コメント 変数の宣言に存在する場合はコメント 検索では、プロジェクト内およびアタッチされたコンパイルされていないライブラリ内のすべてのオカレンスが返されます。 " }, 
{ "title" : "相互参照リストのコンテキストメニューのコマンド ", 
"url" : "_cds_cmd_view_cross_reference_list.html#UUID-623fb12f-e68b-767c-3d16-234d22da3a6e_id_aecb6e1644a20ddec0a8640e0091d2ef_id_9e849137def5910dc0a8640e00806466", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：相互参照リスト \/ 相互参照リストのコンテキストメニューのコマンド ", 
"snippet" : "ソース位置を表示 ：関連するブロックを開き、使用場所をマークします：ルートエントリの宣言、従属する子エントリのそれぞれの使用場所。または、行をダブルクリックすることもできます。 結果を選択した宣言に制限する ：複数の宣言が見つかった場合、結果の表示を選択したシンボル宣言に制限します すべてを拡張する ：すべての個別の場所がリストに表示されます。 すべてを減らす ：すべてのオカレンスのルートノードのみがリストに表示されます。 詳細については、以下を参照してください。 相互参照リストで使用場所を見つける...", 
"body" : "ソース位置を表示 ：関連するブロックを開き、使用場所をマークします：ルートエントリの宣言、従属する子エントリのそれぞれの使用場所。または、行をダブルクリックすることもできます。 結果を選択した宣言に制限する ：複数の宣言が見つかった場合、結果の表示を選択したシンボル宣言に制限します すべてを拡張する ：すべての個別の場所がリストに表示されます。 すべてを減らす ：すべてのオカレンスのルートノードのみがリストに表示されます。 詳細については、以下を参照してください。 相互参照リストで使用場所を見つける" }, 
{ "title" : "コマンド：クラシックビューで相互参照を出力する ", 
"url" : "_cds_cmd_browse_cross_references_classic_view.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：クラシックビューで相互参照を出力する ", 
"snippet" : "クラシックビューで相互参照を出力する シンボル： 関数 ：コマンドはビューを開きます 従来の相互参照リスト 。 電話 ：このコマンドは、デフォルトではどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから コードナビゲーション メニューに貼り付けます。 ビューはビューに対応します 相互参照リスト 前 CODESYS V3.5SP6。...", 
"body" : "クラシックビューで相互参照を出力する シンボル： 関数 ：コマンドはビューを開きます 従来の相互参照リスト 。 電話 ：このコマンドは、デフォルトではどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから コードナビゲーション メニューに貼り付けます。 ビューはビューに対応します 相互参照リスト 前 CODESYS V3.5SP6。 " }, 
{ "title" : "コマンド：callstack ", 
"url" : "_cds_cmd_call_stack.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：callstack ", 
"snippet" : "コールスタック シンボル： 関数 ：コマンドはビューを開きます コールスタック 。 電話 ：メニュー 意見 このビューは、プログラムをステップスルーする場合に非常に役立ちます。完全なコールパスで現在到達している位置が表示されます。 応用 到達したばかりのプログラムブロックを制御するアクティブなアプリケーションの名前 タスク 到達したばかりのプログラムブロックを制御するタスクの名前 POU プログラム実行が配置されているプログラムブロックの名前 リストの最初の行は、現在の実行位置を示しています。黄色の矢印でマークされています。この位置が別の人によって呼び出されたPOU内にある場合、2行目は呼び出...", 
"body" : "コールスタック シンボル： 関数 ：コマンドはビューを開きます コールスタック 。 電話 ：メニュー 意見 このビューは、プログラムをステップスルーする場合に非常に役立ちます。完全なコールパスで現在到達している位置が表示されます。 応用 到達したばかりのプログラムブロックを制御するアクティブなアプリケーションの名前 タスク 到達したばかりのプログラムブロックを制御するタスクの名前 POU プログラム実行が配置されているプログラムブロックの名前 リストの最初の行は、現在の実行位置を示しています。黄色の矢印でマークされています。この位置が別の人によって呼び出されたPOU内にある場合、2行目は呼び出しの位置を示します。発信者が別のビルディングブロックによって順番に呼び出された場合、この呼び出し位置は3行目に記述されます。 ポジション プログラム実行が配置されているプログラムモジュール内の位置 テキストエディタの行番号と列番号 グラフィックエディタのネットワークまたは要素番号 インスタンスパス プログラムの実行が配置されているインスタンス コールスタックは、デバッグ機能を使用していない場合、オフラインモードおよび通常のオンラインモードでも使用できます。この場合、ステップ中に表示された最後の位置が含まれますが、「グレー表示」フォントで表示されます。 景色 ツリーを呼び出す とは対照的に コールスタック ブロックの情報をいつでも呼び出すことができます。 詳細については、以下を参照してください。 ツリーを呼び出す と ブレークポイントの使用" }, 
{ "title" : "コマンド：ツリーを呼び出す ", 
"url" : "_cds_cmd_view_call_tree.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：ツリーを呼び出す ", 
"snippet" : "ツリーを呼び出す シンボル： 関数 ：コマンドはビューを開きます ツリーを呼び出す 。 電話 ： メニュー 意見 ビュー内の呼び出し可能なビルディングブロックのコンテキストメニュー 装置 また POU...", 
"body" : "ツリーを呼び出す シンボル： 関数 ：コマンドはビューを開きます ツリーを呼び出す 。 電話 ： メニュー 意見 ビュー内の呼び出し可能なビルディングブロックのコンテキストメニュー 装置 また POU " }, 
{ "title" : "ビュー：コールツリー ", 
"url" : "_cds_cmd_view_call_tree.html#UUID-8ef23822-0953-bda0-f712-59bcfbcff6c2_id_e97c4a78798cce68c0a8646329524733_id_1d4c07637a2363d1c0a86463011a235d", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：ツリーを呼び出す \/ ビュー：コールツリー ", 
"snippet" : "コールツリーは、アプリケーションをコンパイル（翻訳）する前にいつでも利用できます。これは、明示的に指定した呼び出し元とビルディングブロックの呼び出しの静的な表現です。したがって、ツリーには常に2つのルートノードが含まれ、その下でそれぞれの呼び出しシーケンスを連続してインデントされたエントリと見なすことができます。このツリービューでは、再帰呼び出しをすぐに認識できます。 ブロック（2）の呼び出しツリー（1）の例 PLC_PRG ： ノード (3): <POU 名> は次によって呼び出されます。 ノード (4): <POU 名> の通話 ビルディングブロック名 プログラムブロックの名前 手動で、ま...", 
"body" : "コールツリーは、アプリケーションをコンパイル（翻訳）する前にいつでも利用できます。これは、明示的に指定した呼び出し元とビルディングブロックの呼び出しの静的な表現です。したがって、ツリーには常に2つのルートノードが含まれ、その下でそれぞれの呼び出しシーケンスを連続してインデントされたエントリと見なすことができます。このツリービューでは、再帰呼び出しをすぐに認識できます。 ブロック（2）の呼び出しツリー（1）の例 PLC_PRG ： ノード (3): <POU 名> は次によって呼び出されます。 ノード (4): <POU 名> の通話 ビルディングブロック名 プログラムブロックの名前 手動で、または別のビューからドラッグするか、ボタンを使用して実行できます 入力する 選択リストには、最後に入力されたブロック名が含まれています。 ツールバーとキーボードのコントロール ： ビルディングブロックを見つける CODESYS で検索 ビルディングブロック名 指定されたビルディングブロックであり、その呼び出し元とその呼び出しを表します。 ： 入力ヘルプからブロックを取得 対話 入力ヘルプ ブロック呼び出しまたはインスタンス呼び出しを選択するように見えます。選択後、コールツリーは自動的に更新されます。 ： 選択したブロックのソースコードの位置を表示する CODESYS プログラムのソースコード内のブロックの使用ポイントにジャンプします。 F4 ： 次のビルディングブロックのソースコードの位置を表示する トグル + F4 ： 前のビルディングブロックのソースコードの位置を表示する 呼び出しツリーでの選択は、呼び出し構造内の次または前のブロックにジャンプします。同時に、関連するソースコードの位置がそれぞれのエディタで開かれます。 注：コールツリーのエントリをダブルクリックすると、関連するソースコードの位置も開きます。 コールツリーの表現 シンボル <ブロック名>はによって呼び出されます ：ブロックの呼び出しシーケンスがこのノードの下に表示されます。このツリー構造の一番下のエントリは、呼び出しの開始を示しています。 <ブロック名>の呼び出し ：ブロックから発信された呼び出しは、このノードの下に表示されます。このツリー構造の一番下のエントリは、コールチェーンの終わりを示しています。 ポジション コールツリーのルートノードの場合：宣言の行番号（ decl ）ブロックの ルートノードの下の発信者または通話の場合：実装言語、行番号、列番号、その位置のネットワーク番号によって異なります ツリーで現在選択されているエントリのコンテキストメニュー すべてを減らす 呼び出しツリーの展開されたエントリは、2つのルートノードを除いて折りたたまれています。 ソースコードの場所を表示する CODESYS プログラムのソースコード内のブロックの使用ポイントにジャンプします。 新しいルートノードとして設定 コールツリーで選択されたエントリは、 ビルディングブロック名 。ツリーは、新しいルートノードに合わせて自動的に調整されます。 静的とは対照的に ツリーを呼び出す 、ブロックの通話情報をいつでも提供するビューです コールスタック プログラムの段階的な処理中の即時情報を対象としています。 the コールスタック 到達したばかりの位置の完全なコールパスを常に表示します。 詳細については、以下を参照してください。 コールスタック" }, 
{ "title" : "コマンド：メモリビュー ", 
"url" : "_cds_cmd_memory.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：メモリビュー ", 
"snippet" : "メモリビュー シンボル： 関数 ： の CODESYS SP11より古いV3.5バージョンこのコマンドはビューを開きます ストレージ 。 電話 ：メニュー 意見 SP11以降、メモリビューを使用するにはパッケージが必要であるというメッセージとともにコマンドが表示されます。 CODESYS Memory Tools インストールする必要があり、で利用可能 CODESYS お店。インストール後、表示することができます ストレージ コマンドについて ビュー→メモリビュー 開く。...", 
"body" : "メモリビュー シンボル： 関数 ： の CODESYS SP11より古いV3.5バージョンこのコマンドはビューを開きます ストレージ 。 電話 ：メニュー 意見 SP11以降、メモリビューを使用するにはパッケージが必要であるというメッセージとともにコマンドが表示されます。 CODESYS Memory Tools インストールする必要があり、で利用可能 CODESYS お店。インストール後、表示することができます ストレージ コマンドについて ビュー→メモリビュー 開く。 " }, 
{ "title" : "コマンド：セキュリティ画面 ", 
"url" : "_cds_cmd_cyber_screen.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：セキュリティ画面 ", 
"snippet" : "セキュリティ画面 シンボル： 関数 ：コマンドはビューを開きます セキュリティ画面 。 電話 ： メニュー 意見 アイコン また ステータスバー デジタル署名に有効な証明書が指定されている場合、アイコンは青色になります。暗号化通信用にクライアント証明書が1つだけ指定されている場合、クライアント証明書によってユーザーのセキュリティが向上しないため、アイコンは灰色のままになります。 ビューでは、次のセキュリティ機能 CODESYS 構成および表示： ユーザーの個人証明書 暗号化された通信 IECプロジェクトの暗号化と署名 ダウンロード、オンライン変更、およびブートアプリケーションの暗号化と署名 セ...", 
"body" : "セキュリティ画面 シンボル： 関数 ：コマンドはビューを開きます セキュリティ画面 。 電話 ： メニュー 意見 アイコン また ステータスバー デジタル署名に有効な証明書が指定されている場合、アイコンは青色になります。暗号化通信用にクライアント証明書が1つだけ指定されている場合、クライアント証明書によってユーザーのセキュリティが向上しないため、アイコンは灰色のままになります。 ビューでは、次のセキュリティ機能 CODESYS 構成および表示： ユーザーの個人証明書 暗号化された通信 IECプロジェクトの暗号化と署名 ダウンロード、オンライン変更、およびブートアプリケーションの暗号化と署名 セキュリティレベル の場合 セキュリティ画面 を開いたり閉じたりすると、アクティブな変更が行われていなくても、現在の設定がユーザーオプションに適用されます。 アドオン製品の場合 CODESYS Security Agent インストールされ、ビューを提供します セキュリティ画面 別のタブ： 装置 。これにより、コントローラーとの暗号化通信用の証明書を構成できます。 タブ：デバイス このタブは、をインストールした後にのみ使用できます CODESYS Security Agent アドオン。詳細については、以下を参照してください セキュリティ画面:デバイス で CODESYS Security Agent 助けて。 " }, 
{ "title" : "タブ：ユーザー ", 
"url" : "_cds_cmd_cyber_screen.html#UUID-b01565e9-8d26-9511-6f6b-c6ddb491ec4a_id_f1b6b5ab8b9c634c0a8646304f94292_id_6b26b715c2e29ee4c0a86463458183bc", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：セキュリティ画面 \/ タブ：ユーザー ", 
"snippet" : "暗号化された通信に必要な証明書とユーザーのデジタル署名は、このタブで構成されます。ここでは、秘密鍵を使用してのみ証明書を指定できます。ユーザープロファイルは、ユーザーオプションにXMLとして保存されます。 ユーザープロファイルと証明書の選択 デフォルトでは、Windowsログイン名がユーザープロファイルとして入力されます。 既存のユーザープロファイルを含む選択リスト ：ダイアログを開きます ユーザープロファイル ここに新しいユーザープロファイルの名前を入力します。 ：選択したユーザープロファイルを削除します このユーザープロファイルは、選択リストに表示されなくなります。 デジタル署名 ：ダイア...", 
"body" : "暗号化された通信に必要な証明書とユーザーのデジタル署名は、このタブで構成されます。ここでは、秘密鍵を使用してのみ証明書を指定できます。ユーザープロファイルは、ユーザーオプションにXMLとして保存されます。 ユーザープロファイルと証明書の選択 デフォルトでは、Windowsログイン名がユーザープロファイルとして入力されます。 既存のユーザープロファイルを含む選択リスト ：ダイアログを開きます ユーザープロファイル ここに新しいユーザープロファイルの名前を入力します。 ：選択したユーザープロファイルを削除します このユーザープロファイルは、選択リストに表示されなくなります。 デジタル署名 ：ダイアログを開きます 証明書の選択 デジタル署名の証明書を選択するため 証明書を1つ選択できます。証明書には秘密鍵が必要です。 ：表示されている証明書を削除します。 証明書を1つ選択できます。証明書には秘密鍵が必要です。 プロジェクトファイルの復号化 ：ダイアログを開きます 証明書の選択 プロジェクトファイルを復号化するための証明書を選択するため 証明書を1つ選択できます。証明書には秘密鍵が必要です。 ：表示されている証明書を削除します 詳細については、以下を参照してください。 証明書の選択セキュリティレベル 高度なセキュリティのために証明書の使用を有効にする 暗号化された通信を実施する ：ユーザーがコントロールと通信する場合、コントロールのサーバー証明書が暗号化された接続の確立に使用されます。その後、すべての通信が暗号化されます。 プロジェクトファイルの暗号化を実施する ：ユーザーのすべてのプロジェクトファイルは証明書で暗号化されています。保存すると、プロジェクトはプロジェクト設定（ダイアログ）に保存されます プロジェクト設定→セキュリティ ）暗号化された指定された証明書。選択した証明書がタブに表示されます 計画 の プロジェクトファイルの暗号化 表示されます。 このプロジェクトを開くには、暗号化に使用される秘密鍵を含む証明書が含まれている必要があります プロジェクトファイルの復号化 登録する。 プロジェクトファイルの署名を強制する ：ユーザーのすべてのプロジェクトファイルは証明書で署名されています。の デジタル署名 秘密鍵を含む証明書を入力する必要があります。 プロジェクトを保存すると、プロジェクトディレクトリに署名ファイルが作成されます <project name>.project.p7s 署名を含む生成されます。 ダウンロード、オンライン変更、およびブートアプリケーションの暗号化を適用します ：コントローラーにロードされるデータは、コントローラー証明書で暗号化する必要があります。 この証明書は、アプリケーションのプロパティダイアログのタブに直接表示されます 暗号化 セットまたはタブで 計画 、 領域 ブートアプリケーションの暗号化、ダウンロード、オンライン変更 。 制御証明書は、フォルダー内のローカルWindows証明書ストアにあります PLC証明書 。コントローラの証明書がフォルダに含まれていない場合は、最初にコントローラからロードしてフォルダにインストールする必要があります。この手順については、「」の章を参照してください。 コントローラ証明書 \"。 詳細については、以下を参照してください。 アプリケーションの保護ダウンロード、オンライン変更、およびブートアプリケーションの署名を強制します ：オンラインコード、つまりダウンロード、オンライン変更、およびブートアプリケーションは、個人キーを使用した証明書で署名する必要があります。エリア内の証明書を選択します デジタル署名 アウト。 詳細については、以下を参照してください。 アプリケーションの保護翻訳されたライブラリの署名を強制する ： コマンド ファイル→プロジェクトを翻訳済みライブラリとして保存 署名されたライブラリを作成します <library name>.compiled-library-v3 。 要件 コード署名をサポートする秘密鍵証明書が存在します。 プロジェクト情報には、ライブラリの互換性があります> = CODESYS V3 SP15 セットする。 署名されたライブラリのタイムスタンプを適用する ： 現場で タイムスタンプサーバー タイムスタンプを生成するタイムスタンプサーバーのURLを入力する必要があります。 例： timestamp.comodoca.com\/rfc3161 詳細については、以下を参照してください。 プロジェクトをコンパイル済みライブラリとして保存" }, 
{ "title" : "タブ：プロジェクト ", 
"url" : "_cds_cmd_cyber_screen.html#UUID-b01565e9-8d26-9511-6f6b-c6ddb491ec4a_id_f1b6b5ab8b9c634c0a8646304f94292_id_eb95a26f13bac6bec0a864635014e693", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：セキュリティ画面 \/ タブ：プロジェクト ", 
"snippet" : "プロジェクト固有の設定はすべて、このタブで構成されます。これらのアイテムは、プライマリプロジェクトがロードされている場合にのみアクティブになります。 プロジェクトファイルの暗号化 テクノロジー ：ダイアログを開きます プロジェクト設定→セキュリティ ダイアログでプロジェクト設定を変更した場合 暗号化 選択してから 証明書 アクティベート、あなたは経由することができます 適切な証明書を選択します。詳細については、ダイアログの説明をご覧ください。 プロジェクト設定-セキュリティ 。 このプロジェクトを共有しているユーザーからの証明書 プロジェクトファイルを暗号化する証明書を一覧表示する領域 ブート...", 
"body" : "プロジェクト固有の設定はすべて、このタブで構成されます。これらのアイテムは、プライマリプロジェクトがロードされている場合にのみアクティブになります。 プロジェクトファイルの暗号化 テクノロジー ：ダイアログを開きます プロジェクト設定→セキュリティ ダイアログでプロジェクト設定を変更した場合 暗号化 選択してから 証明書 アクティベート、あなたは経由することができます 適切な証明書を選択します。詳細については、ダイアログの説明をご覧ください。 プロジェクト設定-セキュリティ 。 このプロジェクトを共有しているユーザーからの証明書 プロジェクトファイルを暗号化する証明書を一覧表示する領域 ブートアプリケーションの暗号化、ダウンロード、オンライン変更 コントローラのアプリケーションのリスト リスト内のアプリケーションをダブルクリックすると、ダイアログが開きます プロパティ→暗号化 。の設定に応じて セキュリティレベル タブ上 ユーザー の セキュリティ画面 開いたプロパティダイアログでは、次のフィールドを使用できます。 タブ 暗号化 アクティブエリア付き 証明書 タブ 暗号化 選択リスト付き 暗号化技術 対話の中で プロパティ→暗号化 ボタンを使用して選択 管理証明書 ブートアプリケーションの暗号化、ダウンロード、オンライン変更 アウト。詳細については、ダイアログの説明をご覧ください。 プロパティ-暗号化 。 制御証明書は、フォルダー内のローカルWindows証明書ストアにあります コントローラ証明書 。コントローラの証明書がフォルダに含まれていない場合は、最初にコントローラからロードしてフォルダにインストールする必要があります。この手順は、この章に記載されています。 プロジェクトの保護と保存-証明書による暗号化 。 詳細については、以下を参照してください。 アプリケーションの保護詳細については、以下を参照してください。 安全な開発\/ソースコードの保護 " }, 
{ "title" : "コマンド：オンライン変更用のメモリ予約の設定 ", 
"url" : "_cds_cmd_memory_reserve_online_change.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：オンライン変更用のメモリ予約の設定 ", 
"snippet" : "オンライン変更のためのメモリリザーブの設定 関数 ：コマンドはビューを開きます オンライン変更のためのメモリリザーブ 。 電話 ：メニュー 意見 ビューでは、オンライン変更用のメモリリザーブが機能ブロック用に設定されています。 検索アプリケーション 選択したアプリケーションで機能ブロックを検索し、領域に表示します ファンクションブロック の上 エリアを更新します ファンクションブロック 、アプリケーションが再コンパイルされた後 エリアを更新します ファンクションブロック オンライン変更後 オープンプロジェクトのアプリケーションを含む選択リスト このビューで機能ブロックを表示および\/または編集す...", 
"body" : "オンライン変更のためのメモリリザーブの設定 関数 ：コマンドはビューを開きます オンライン変更のためのメモリリザーブ 。 電話 ：メニュー 意見 ビューでは、オンライン変更用のメモリリザーブが機能ブロック用に設定されています。 検索アプリケーション 選択したアプリケーションで機能ブロックを検索し、領域に表示します ファンクションブロック の上 エリアを更新します ファンクションブロック 、アプリケーションが再コンパイルされた後 エリアを更新します ファンクションブロック オンライン変更後 オープンプロジェクトのアプリケーションを含む選択リスト このビューで機能ブロックを表示および\/または編集するアプリケーションの選択 ファンクションブロック 全て 選択したアプリケーションのすべての機能ブロックが表示されます。 プール ビューのすべての機能ブロック POU アプリケーションで参照されているものが表示されます。 メモリリザーブなし メモリリザーブが0バイトのすべての機能ブロックが表示されます。 <メモリリザーブ>バイト にあるバイト数ですべての機能ブロックを表示します メモリリザーブ 定義済みが表示されます 機能ブロックに関する情報 メモリリザーブを設定するためのブロックを選択するときに、複数の選択も可能です。 汎用モジュール 汎用モジュールの名称 サイズ 機能ブロックのサイズ 関数ブロックのインスタンスのサイズ バイト単位で指定 インスタンス数 プロジェクト内の機能ブロックのインスタンスの数 メモリリザーブ 機能ブロックのインスタンスごとのメモリリザーブの表示 すべてのインスタンス用の追加ストレージ 製品オフ インスタンス数 と メモリリザーブ メモリリザーブの残り 予約としてまだ使用可能なバイト数 アイデア メモリリザーブ（バイト単位） 選択した機能ブロックのメモリリザーブの入力フィールド バイト単位で指定 要件：アプリケーションがまだコントロールされていないか、ボタンをクリックしている 編集するには エリア内 編集を許可する メモリリザーブを変更できます。 選択に適用 the メモリリザーブ（バイト単位） 汎用モジュールとテーブル列に割り当てられます メモリリザーブ 更新されます。 複数選択の場合、入力した値が各機能ブロックに割り当てられます。 列の周り サイズ 、 インスタンス数 、 すべてのインスタンス用の追加ストレージ と メモリーリザーブの残り量 更新するには、最初にコマンドを選択します 作成→翻訳 次にボタンをクリックします 検索アプリケーション 。 編集を許可する 編集するには 入力フィールド メモリリザーブ（バイト単位） 編集可能になります。 このボタンは 編集可能 かわった。 情報 FBの数 アプリケーション内のファンクションブロックの総数 すべてのインスタンス用の追加ストレージ アプリケーションのすべての機能ブロックインスタンスのメモリリザーブの合計 バイト単位で指定 詳細については、以下を参照してください。 オンライン変更用のメモリリザーブを構成する" }, 
{ "title" : "コマンド：ホーム ", 
"url" : "_cds_cmd_start_page.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：ホーム ", 
"snippet" : "ホームページ シンボル： 関数 ：コマンドはビューを開きます ホームページ 。 電話 ：メニュー 意見 ビューには、いくつかの基本的なコマンドと最近開いたプロジェクトのリストが含まれています。さらに、あなたは CODESYS ホームページが表示されます。 インターネットへのプロキシアクセスを使用する場合は、次の認証データを使用できます。 CODESYS カテゴリ内のオプション プロキシ設定 保証金。そうすれば、ホームページを呼び出すたびにエントリの入力を求められることはありません。 最近開いたプロジェクトのリストにカーソルを合わせると、リストから個々のプロジェクトを削除または固定できます。固定...", 
"body" : "ホームページ シンボル： 関数 ：コマンドはビューを開きます ホームページ 。 電話 ：メニュー 意見 ビューには、いくつかの基本的なコマンドと最近開いたプロジェクトのリストが含まれています。さらに、あなたは CODESYS ホームページが表示されます。 インターネットへのプロキシアクセスを使用する場合は、次の認証データを使用できます。 CODESYS カテゴリ内のオプション プロキシ設定 保証金。そうすれば、ホームページを呼び出すたびにエントリの入力を求められることはありません。 最近開いたプロジェクトのリストにカーソルを合わせると、リストから個々のプロジェクトを削除または固定できます。固定されたプロジェクトは、固定を解除するまでこのリストに残ります。 あなたは CODESYS カテゴリ内のオプション 読み込みと保存 このスタートページを自動的に表示するかどうかを設定します CODESYS 始める。 " }, 
{ "title" : "コマンド：全画面 ", 
"url" : "_cds_cmd_full_screen.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：全画面 ", 
"snippet" : "全画面表示 シンボル： キーボードショートカット： ctrl + トグル + F12 関数 ：コマンドは、の表示を切り替えます CODESYS フルスクリーンモードにします。 電話 ：メニュー 意見 コマンドをアクティブにすると、のメインウィンドウが CODESYS フルスクリーンモードで表示されるユーザーインターフェイス。コマンドまたはキーボードショートカットを無効にすることで、以前に設定したサイズに戻すことができます ctrl + トグル + F12 作動します。...", 
"body" : "全画面表示 シンボル： キーボードショートカット： ctrl + トグル + F12 関数 ：コマンドは、の表示を切り替えます CODESYS フルスクリーンモードにします。 電話 ：メニュー 意見 コマンドをアクティブにすると、のメインウィンドウが CODESYS フルスクリーンモードで表示されるユーザーインターフェイス。コマンドまたはキーボードショートカットを無効にすることで、以前に設定したサイズに戻すことができます ctrl + トグル + F12 作動します。 " }, 
{ "title" : "コマンド：プロパティ ", 
"url" : "_cds_cmd_properties.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 意見 \/ コマンド：プロパティ ", 
"snippet" : "プロパティ シンボル： 関数 ：コマンドは プロパティ POUまたはデバイスツリーで現在選択されているオブジェクトの 電話 ：メニュー 意見...", 
"body" : "プロパティ シンボル： 関数 ：コマンドは プロパティ POUまたはデバイスツリーで現在選択されているオブジェクトの 電話 ：メニュー 意見 " }, 
{ "title" : "計画 ", 
"url" : "_cds_f_commands_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド：オブジェクトを追加 ", 
"url" : "_cds_cmd_add_object.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：オブジェクトを追加 ", 
"snippet" : "オブジェクトを追加 シンボル： 関数 ：コマンドは、ビュー内の現在の位置に依存するオブジェクトを含むサブメニューを開きます 装置 また POU 挿入できるすべてのオブジェクトが含まれています。 電話 ：メニュー 計画 、ビューのコンテキストメニュー 装置 また POU 要件 ： いつ CODESYS デバイスツリーにオブジェクトを挿入するには、既存のオブジェクトを選択します。その下に、新しいインデントされたオブジェクトを作成できます。いつ CODESYS オブジェクトをPOUツリーに挿入するには、フォーカスを CODESYS 窓。 詳細については、以下を参照してください。 オブジェクトの追加...", 
"body" : "オブジェクトを追加 シンボル： 関数 ：コマンドは、ビュー内の現在の位置に依存するオブジェクトを含むサブメニューを開きます 装置 また POU 挿入できるすべてのオブジェクトが含まれています。 電話 ：メニュー 計画 、ビューのコンテキストメニュー 装置 また POU 要件 ： いつ CODESYS デバイスツリーにオブジェクトを挿入するには、既存のオブジェクトを選択します。その下に、新しいインデントされたオブジェクトを作成できます。いつ CODESYS オブジェクトをPOUツリーに挿入するには、フォーカスを CODESYS 窓。 詳細については、以下を参照してください。 オブジェクトの追加" }, 
{ "title" : "コマンド：フォルダーを追加 ", 
"url" : "_cds_cmd_add_folder.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：フォルダーを追加 ", 
"snippet" : "フォルダーを追加 シンボル： 関数 ：このコマンドは、[デバイス]または[POU]ビューで新しいフォルダーを定義するためのダイアログを開きます。 電話 ：メニュー 計画 、デバイスまたはPOUビューのコンテキストメニュー 自分で作成したフォルダを使用して、デバイスノードとデバイスオブジェクトの配置を構成することはできません。 このコマンドは、ツリー内で現在選択されているオブジェクトの下にフォルダーを挿入します。オブジェクトが選択されていない場合は、追加します CODESYS ルートノードのすぐ下にあるツリーの最上部にあるフォルダ。...", 
"body" : "フォルダーを追加 シンボル： 関数 ：このコマンドは、[デバイス]または[POU]ビューで新しいフォルダーを定義するためのダイアログを開きます。 電話 ：メニュー 計画 、デバイスまたはPOUビューのコンテキストメニュー 自分で作成したフォルダを使用して、デバイスノードとデバイスオブジェクトの配置を構成することはできません。 このコマンドは、ツリー内で現在選択されているオブジェクトの下にフォルダーを挿入します。オブジェクトが選択されていない場合は、追加します CODESYS ルートノードのすぐ下にあるツリーの最上部にあるフォルダ。 " }, 
{ "title" : "コマンド：デバイスを接続します ", 
"url" : "_cds_cmd_add_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：デバイスを接続します ", 
"snippet" : "デバイスを接続します 関数 ：コマンドはダイアログを開きます デバイスを接続します 現在選択されているオブジェクトの下のデバイスツリーに挿入されるデバイスオブジェクトを選択します。 電話 ：デバイスツリー内のデバイスオブジェクトのコンテキストメニュー 要件 ：デバイスツリーでオブジェクトが選択され、その下にデバイスオブジェクトを挿入できます。...", 
"body" : "デバイスを接続します 関数 ：コマンドはダイアログを開きます デバイスを接続します 現在選択されているオブジェクトの下のデバイスツリーに挿入されるデバイスオブジェクトを選択します。 電話 ：デバイスツリー内のデバイスオブジェクトのコンテキストメニュー 要件 ：デバイスツリーでオブジェクトが選択され、その下にデバイスオブジェクトを挿入できます。 " }, 
{ "title" : "ダイアログ：デバイスを接続します ", 
"url" : "_cds_cmd_add_device.html#UUID-eb0bed63-ea86-053f-3973-94136b2ff14c_id_bd4a3d10fecdecc0a8640e002b80ee_id_b68e4f085aa0f27fc0a8640e01039101", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：デバイスを接続します \/ ダイアログ：デバイスを接続します ", 
"snippet" : "関数 ：デバイスツリーで現在選択されている位置に応じて、ダイアログには、この時点で挿入できるデバイスの選択肢が表示されます。また、コンテキストメニューでも使用できるコマンドが含まれています。 デバイスを接続します 、 挿入装置 、 プラグインデバイス 、 更新デバイス 。 要件 ：デバイスは、ローカルシステムのデバイスリポジトリにインストールされます。 ダイアログを開いた場合、ボタンをクリックするまで、デバイスツリーで現在選択されているオブジェクトに一致する選択が常に表示されます。 結論 クリック。 姓 デバイスがデバイスツリーに表示される名前 有効なIEC識別子である必要があります アクショ...", 
"body" : "関数 ：デバイスツリーで現在選択されている位置に応じて、ダイアログには、この時点で挿入できるデバイスの選択肢が表示されます。また、コンテキストメニューでも使用できるコマンドが含まれています。 デバイスを接続します 、 挿入装置 、 プラグインデバイス 、 更新デバイス 。 要件 ：デバイスは、ローカルシステムのデバイスリポジトリにインストールされます。 ダイアログを開いた場合、ボタンをクリックするまで、デバイスツリーで現在選択されているオブジェクトに一致する選択が常に表示されます。 結論 クリック。 姓 デバイスがデバイスツリーに表示される名前 有効なIEC識別子である必要があります アクション デバイスを接続します CODESYS デバイスツリーの選択されたオブジェクトの下にインデントされた選択されたデバイスを挿入します。 挿入装置 CODESYS 選択したデバイスを、デバイスツリーのその下にある選択したオブジェクトと同じレベルに挿入します。 プラグインデバイス CODESYS 選択したデバイスを選択したスロットに挿入します。スロットがすでに使用されている場合は、既存のモジュールが新しいモジュールに置き換えられます。 更新デバイス CODESYS デバイスツリーで選択されたデバイスを選択されたデバイスに置き換えます。 注：デバイスによっては、デバイスエディターで既に行われた構成がデフォルト値で上書きされる可能性があります。 すべてのデバイスでの全文検索の文字列 このフィールドをクリックすると、編集可能になります。文字列を入力すると、文字列を含むデバイスのみが下のウィンドウに表示されます。これらのデバイスでは、一致する文字列が黄色で強調表示されます。 メーカー 利用可能なデバイスが表示されているメーカーの選択リスト カテゴリ別にグループ化 ：使用可能なデバイス（最新バージョン）は、カテゴリ別にソートされています。カテゴリは、デバイス記述ファイルで定義されています。 ：使用可能なデバイスはフラットに表示され、アルファベット順に並べ替えられます。 すべてのバージョンを表示（エキスパートのみ） ：デバイスの他のすべての利用可能なバージョンも選択可能です。 ：各デバイスの最新バージョンのみを選択できます。 古いバージョンを表示する ：古いバージョンのデバイスも選択できます。古いバージョンは、たとえばプラグインを更新することによって作成されます。 ：古いバージョンのデバイスは表示されません。 デバイス記述ファイルを介して提供される情報が表示されます：デバイス名、メーカー、カテゴリー、バージョン、注文番号、および簡単な説明、デバイス固有のビットマップ。 詳細については、以下を参照してください。 挿入装置 と プラグインデバイス" }, 
{ "title" : "コマンド：デバイスを接続します ", 
"url" : "_cds_cmd_plug_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：デバイスを接続します ", 
"snippet" : "プラグインデバイス 関数 ：コマンドはコマンドのように開きます デバイスを接続します 対話 デバイスを接続します 現在選択されているスロットのデバイスツリーに挿入されるデバイスオブジェクトを選択します。 電話 ：デバイスツリー内のデバイスオブジェクトのスロットのコンテキストメニュー 要件 ：デバイスツリーでデバイスオブジェクトのスロットが選択されています。 空のスロットはアイコンで示されます エントリに「<Empty>（<Empty>）」のマークを付けます。占有スロットには記号が付けられます およびデバイスの名前。 スロットが占有されている場合、コマンドは既存のモジュールを新しいモジュールに置...", 
"body" : "プラグインデバイス 関数 ：コマンドはコマンドのように開きます デバイスを接続します 対話 デバイスを接続します 現在選択されているスロットのデバイスツリーに挿入されるデバイスオブジェクトを選択します。 電話 ：デバイスツリー内のデバイスオブジェクトのスロットのコンテキストメニュー 要件 ：デバイスツリーでデバイスオブジェクトのスロットが選択されています。 空のスロットはアイコンで示されます エントリに「<Empty>（<Empty>）」のマークを付けます。占有スロットには記号が付けられます およびデバイスの名前。 スロットが占有されている場合、コマンドは既存のモジュールを新しいモジュールに置き換えます。 " }, 
{ "title" : "コマンド：デバイスを検索 ", 
"url" : "_cds_cmd_scan_for_devices.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：デバイスを検索 ", 
"snippet" : "検索デバイス 関数 ：このコマンドは、ハードウェアへの一時的な接続を確立し、ネットワーク上のデバイスを検出します。その後、プロジェクトのデバイスツリーにあるデバイスを採用できます。 電話 ：メニュー 計画 、デバイスツリー内のデバイスオブジェクトのコンテキストメニュー 要件 ：制御装置との通信設定は正しいです。ゲートウェイとPLCが起動しました。デバイスはスキャン機能をサポートしています。 次のデバイスがスキャン機能を提供します：EtherCATマスター、EtherNet \/ IPスキャナー（IEC）、Sercosマスター、CANopenマネージャー、CANopenマネージャーSIL2、Pro...", 
"body" : "検索デバイス 関数 ：このコマンドは、ハードウェアへの一時的な接続を確立し、ネットワーク上のデバイスを検出します。その後、プロジェクトのデバイスツリーにあるデバイスを採用できます。 電話 ：メニュー 計画 、デバイスツリー内のデバイスオブジェクトのコンテキストメニュー 要件 ：制御装置との通信設定は正しいです。ゲートウェイとPLCが起動しました。デバイスはスキャン機能をサポートしています。 次のデバイスがスキャン機能を提供します：EtherCATマスター、EtherNet \/ IPスキャナー（IEC）、Sercosマスター、CANopenマネージャー、CANopenマネージャーSIL2、ProfinetコントローラーおよびProfibusDPマスター。 スキャン機能がPLCにしっかりと実装されていれば、デバイススキャンをすぐに実行できます。スキャン機能がライブラリに実装されている場合、ライブラリをコントローラにロードするには、一度ログインする必要があります。 このコマンドは、デバイスツリーで選択されたマスターコントローラーを参照します。たとえば、すでに挿入されているPROFINET IOコントローラを選択し、それに割り当てられているI \/ OデバイスとI \/ Oモジュールをコマンドで決定できます。 スキャンを実行すると、ダイアログが表示されます 検索デバイス 見つかったデバイスで。 スキャンのダイアログは、デバイスの種類によって異なります。それぞれのデバイスエディタのヘルプページを参照してください。 見つかったデバイス デバイス名、デバイスタイプ、アドレス、ステーション名など。 ネットワークタイプに応じて、検出されたデバイスに関する情報 見つかったデバイスのリストで値を変更すると、その値は斜体で表示されます。これは、エディターの新しい値が CODESYS 変更されましたが、まだデバイスにはありません。値をデバイスにロードするとすぐに、通常どおりに表示されます。 プロジェクトと見つかったデバイスの違いを示す値はオレンジ色で表示されます。 見つかったデバイスのデバイスの説明が複数ある場合は、名前が太字で表示されます。適切なデバイス記述の選択は、さまざまなフィールドバスに対して異なる方法で解決されます。詳細については、関連するフィールドバスの章を参照してください。 デバイスの説明が見つからなかった場合は、「注意！デバイスがリポジトリに見つかりませんでした。」バスシステムによっては、メーカー番号や製品番号などの追加情報が表示されます。インストールされたデバイスの説明がないと、デバイスをプロジェクトに挿入できません。 プロジェクトとの違いを示す ：この表には、設定されたデバイス（プロジェクトのデバイスツリー内のデバイス）もダイアログに表示されます。 ：表には、見つかったすべてのデバイスが表示されます。構成されたデバイスは表示されません。 検索デバイス 新しい検索を開始します プロジェクトにコピー テーブルで選択されたデバイスがプロジェクトのデバイスツリーに追加されます。何も選択されていない場合、見つかったすべてのデバイスが受け入れられます。 あなたが すべてのデバイスをプロジェクトにコピーします デバイスツリーにすでに存在するデバイスをデバイスツリーに挿入する場合は、次の点に注意してください。タブのデータ プロセスデータ と <…> I \/ Oマッピング 既存のデバイスのうち、新しく挿入されたデバイスのデータで上書きすることができます。 構成済みデバイス ダイアログのこの部分は、オプションを選択した場合にのみ表示されます プロジェクトとの違いを示す 有効になりました。 検出されたデバイスと構成されたデバイスの違いは、色で強調表示されます。緑で示されているデバイスは、両側で同じです。赤で表示されているデバイスは、検出または構成されたデバイスのビューでのみ使用できます。 両方のビューでデバイスを選択した場合、見つかったデバイスは、選択した構成済みデバイスの上に挿入されます。 両方のビューでデバイスを選択した場合、見つかったデバイスは、選択した構成済みデバイスの下に挿入されます。 両方のビューでデバイスを選択した場合、構成されたデバイスは、見つかったデバイスに置き換えられます。 見つかったすべてのデバイスがプロジェクトにコピーされます。 選択した構成済みデバイスが削除されます。 詳細については、以下を参照してください。 デバイスツリーでのハードウェア構造のマッピング" }, 
{ "title" : "コマンド：デバイスを更新します ", 
"url" : "_cds_cmd_update_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：デバイスを更新します ", 
"snippet" : "更新デバイス 関数 ：コマンドはコマンドのように開きます デバイスを接続します 対話 デバイスを接続します デバイスオブジェクトを選択します。このオブジェクトは、現在選択されているオブジェクトの代わりにデバイスツリーに挿入されます。 電話 ：デバイスツリー内のデバイスオブジェクトのコンテキストメニュー 要件 ：デバイスツリーでオブジェクトが選択され、その下にデバイスオブジェクトを挿入できます。 このコマンドでは、前のデバイスの代わりに、異なるバージョンのデバイスまたは異なるタイプのデバイスを使用できます。 デバイスツリーで使用されているシンボリックデバイス名はそのままで、別のタイプを選択すると...", 
"body" : "更新デバイス 関数 ：コマンドはコマンドのように開きます デバイスを接続します 対話 デバイスを接続します デバイスオブジェクトを選択します。このオブジェクトは、現在選択されているオブジェクトの代わりにデバイスツリーに挿入されます。 電話 ：デバイスツリー内のデバイスオブジェクトのコンテキストメニュー 要件 ：デバイスツリーでオブジェクトが選択され、その下にデバイスオブジェクトを挿入できます。 このコマンドでは、前のデバイスの代わりに、異なるバージョンのデバイスまたは異なるタイプのデバイスを使用できます。 デバイスツリーで使用されているシンボリックデバイス名はそのままで、別のタイプを選択すると、後ろの括弧内に指定されているデバイスタイプが変わります。したがって、デバイスのバージョンのみが変更された場合、オブジェクトエントリは変更されていないように見えます。 デバイスタイプが変更されない場合、影響を受けるデバイスエントリの下にインデントされた構成ツリーが保持されます。この場合、構成設定は保持されます。デバイスの更新によって引き起こされた構成の不整合を報告します CODESYS 次回アプリケーションがコンパイルされるとき。これは、暗黙的に含まれているライブラリにも影響します。 CODESYS デバイスの更新中に適宜削除されません。 詳細については、以下を参照してください。 デバイスを接続します" }, 
{ "title" : "コマンド：診断の確認、サブツリーの診断の確認 ", 
"url" : "_cds_cmd_acknowledge_diagnosis.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：診断の確認、サブツリーの診断の確認 ", 
"snippet" : "診断を確認し、サブツリーの診断を確認します 関数 ：コマンドは診断メッセージを確認します。 電話 ：デバイスツリー内のデバイスオブジェクトのコンテキストメニュー 要件 ：プロジェクトはオンラインです。 コマンド 診断を確認する 単一のデバイスの診断メッセージを確認します。コマンド サブツリーの診断を確認する また、すべての従属デバイスの診断メッセージを確認します。保留中の障害の診断メッセージは、デバイスオブジェクトの赤い感嘆符で示されます。解決された障害の診断メッセージは、デバイスオブジェクトの灰色の感嘆符で示されます。 詳細については、以下を参照してください。 オンラインモードのデバイスツリ...", 
"body" : "診断を確認し、サブツリーの診断を確認します 関数 ：コマンドは診断メッセージを確認します。 電話 ：デバイスツリー内のデバイスオブジェクトのコンテキストメニュー 要件 ：プロジェクトはオンラインです。 コマンド 診断を確認する 単一のデバイスの診断メッセージを確認します。コマンド サブツリーの診断を確認する また、すべての従属デバイスの診断メッセージを確認します。保留中の障害の診断メッセージは、デバイスオブジェクトの赤い感嘆符で示されます。解決された障害の診断メッセージは、デバイスオブジェクトの灰色の感嘆符で示されます。 詳細については、以下を参照してください。 オンラインモードのデバイスツリー" }, 
{ "title" : "コマンド：オブジェクトの編集 ", 
"url" : "_cds_cmd_edit_object.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：オブジェクトの編集 ", 
"snippet" : "オブジェクトを編集する 関数 ：コマンドは、エディターでオブジェクトを開きます。 電話 ：メニュー 計画 、 コンテキストメニュー 要件 ：デバイスツリーまたはビュー内のオブジェクト POU が選択されています。...", 
"body" : "オブジェクトを編集する 関数 ：コマンドは、エディターでオブジェクトを開きます。 電話 ：メニュー 計画 、 コンテキストメニュー 要件 ：デバイスツリーまたはビュー内のオブジェクト POU が選択されています。 " }, 
{ "title" : "コマンド：でオブジェクトを編集 ", 
"url" : "_cds_cmd_edit_object_with.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：でオブジェクトを編集 ", 
"snippet" : "でオブジェクトを編集 関数 ：オブジェクトに複数のオブジェクトが使用可能な場合、コマンドは目的のエディターを選択するためのダイアログを開きます。 オブジェクトに使用できるエディターが1つしかない場合、コマンドはそのエディターでオブジェクトを開きます。 電話 ：メニュー 計画 、 コンテキストメニュー 要件 ：デバイスツリーまたはビュー内のオブジェクト POU が選択されています。 の中に CODESYS 標準インストールでは、複数のエディターを使用できるオブジェクトはありません。...", 
"body" : "でオブジェクトを編集 関数 ：オブジェクトに複数のオブジェクトが使用可能な場合、コマンドは目的のエディターを選択するためのダイアログを開きます。 オブジェクトに使用できるエディターが1つしかない場合、コマンドはそのエディターでオブジェクトを開きます。 電話 ：メニュー 計画 、 コンテキストメニュー 要件 ：デバイスツリーまたはビュー内のオブジェクト POU が選択されています。 の中に CODESYS 標準インストールでは、複数のエディターを使用できるオブジェクトはありません。 " }, 
{ "title" : "コマンド：オブジェクトを編集します（オフライン）。 ", 
"url" : "_cds_cmd_edit_object_offline.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：オブジェクトを編集します（オフライン）。 ", 
"snippet" : "オブジェクトを編集します（オフライン）。 関数 ：コマンドは、エディターでオブジェクトをオフラインで開きます。 電話 ：メニュー 計画 、 コンテキストメニュー 要件 ：アプリケーションはオンラインモードです。デバイスツリーまたはビュー内のオブジェクト POU が選択されています。 これは、オンラインモードでオブジェクトを編集することもできることを意味します。次に、メニューコマンドを使用して変更を転送します オンライン→ オンライン変更 また オンライン→ ロード コントローラー上。...", 
"body" : "オブジェクトを編集します（オフライン）。 関数 ：コマンドは、エディターでオブジェクトをオフラインで開きます。 電話 ：メニュー 計画 、 コンテキストメニュー 要件 ：アプリケーションはオンラインモードです。デバイスツリーまたはビュー内のオブジェクト POU が選択されています。 これは、オンラインモードでオブジェクトを編集することもできることを意味します。次に、メニューコマンドを使用して変更を転送します オンライン→ オンライン変更 また オンライン→ ロード コントローラー上。 " }, 
{ "title" : "コマンド：アクティブなアプリケーションを設定します ", 
"url" : "_cds_cmd_set_active_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：アクティブなアプリケーションを設定します ", 
"snippet" : "アクティブなアプリケーションを設定する 関数 ：このコマンドは、選択したアプリケーションを「アクティブなアプリケーション」として設定します。 電話 ：メニュー 計画 、オブジェクトのコンテキストメニュー 応用 要件 ：プロジェクトには少なくとも2つのアプリケーションがあります。選択したアプリケーションはアクティブではありません。 オンラインアクションは常にアクティブなアプリケーションにのみ影響します。アクティブなアプリケーションは、デバイスツリーに太字で表示されます。...", 
"body" : "アクティブなアプリケーションを設定する 関数 ：このコマンドは、選択したアプリケーションを「アクティブなアプリケーション」として設定します。 電話 ：メニュー 計画 、オブジェクトのコンテキストメニュー 応用 要件 ：プロジェクトには少なくとも2つのアプリケーションがあります。選択したアプリケーションはアクティブではありません。 オンラインアクションは常にアクティブなアプリケーションにのみ影響します。アクティブなアプリケーションは、デバイスツリーに太字で表示されます。 " }, 
{ "title" : "コマンド：プロジェクト情報 ", 
"url" : "_cds_cmd_project_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：プロジェクト情報 ", 
"snippet" : "プロジェクト情報 シンボル： 関数 ：コマンドはダイアログを開きます プロジェクト情報 。 電話 ：メニュー 計画 プロジェクトで初めてコマンドを実行するとき CODESYS オブジェクト プロジェクト情報 の上。 詳細については、以下を参照してください。 プロジェクト情報の取得と編集...", 
"body" : "プロジェクト情報 シンボル： 関数 ：コマンドはダイアログを開きます プロジェクト情報 。 電話 ：メニュー 計画 プロジェクトで初めてコマンドを実行するとき CODESYS オブジェクト プロジェクト情報 の上。 詳細については、以下を参照してください。 プロジェクト情報の取得と編集" }, 
{ "title" : "コマンド：プロジェクト設定 ", 
"url" : "_cds_cmd_project_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：プロジェクト設定 ", 
"snippet" : "プロジェクト設定 シンボル： 関数 ：コマンドはダイアログを開きます プロジェクト設定 。 電話 ：メニュー 計画 またはオブジェクトをダブルクリックします プロジェクト設定 ビューで POU 要件 ：プロジェクトは開いています。 詳細については、以下を参照してください。 プロジェクト設定の構成...", 
"body" : "プロジェクト設定 シンボル： 関数 ：コマンドはダイアログを開きます プロジェクト設定 。 電話 ：メニュー 計画 またはオブジェクトをダブルクリックします プロジェクト設定 ビューで POU 要件 ：プロジェクトは開いています。 詳細については、以下を参照してください。 プロジェクト設定の構成" }, 
{ "title" : "コマンド：プロジェクト環境 ", 
"url" : "_cds_cmd_project_environment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：プロジェクト環境 ", 
"snippet" : "プロジェクト環境 関数 ：コマンドはダイアログを開きます プロジェクト環境 。 電話 ：メニュー 計画 要件 ：プロジェクトは開いています。 このコマンドは、プロジェクトに関連するソフトウェアとファイルが最新であり、それらを更新できるかどうかを確認するために使用されます。...", 
"body" : "プロジェクト環境 関数 ：コマンドはダイアログを開きます プロジェクト環境 。 電話 ：メニュー 計画 要件 ：プロジェクトは開いています。 このコマンドは、プロジェクトに関連するソフトウェアとファイルが最新であり、それらを更新できるかどうかを確認するために使用されます。 " }, 
{ "title" : "コマンド：プロジェクトのローカリゼーション-ローカリゼーションテンプレートを作成します ", 
"url" : "_cds_cmd_project_loc_create_localization_template.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：プロジェクトのローカリゼーション-ローカリゼーションテンプレートを作成します ", 
"snippet" : "プロジェクトのローカリゼーション-ローカリゼーションテンプレートを作成します 関数 ：コマンドはダイアログを開きます ローカリゼーションテンプレートを作成する 。ここでは、ファイル形式の翻訳テンプレートでプロジェクトからのテキスト情報を定義します pot エクスポートされます。 電話 ：メニュー プロジェクト→プロジェクトのローカリゼーション 要件 ：プロジェクトは開いています。...", 
"body" : "プロジェクトのローカリゼーション-ローカリゼーションテンプレートを作成します 関数 ：コマンドはダイアログを開きます ローカリゼーションテンプレートを作成する 。ここでは、ファイル形式の翻訳テンプレートでプロジェクトからのテキスト情報を定義します pot エクスポートされます。 電話 ：メニュー プロジェクト→プロジェクトのローカリゼーション 要件 ：プロジェクトは開いています。 " }, 
{ "title" : "ダイアログ：ローカリゼーションテンプレートを作成する ", 
"url" : "_cds_cmd_project_loc_create_localization_template.html#UUID-7af442ed-2731-3bea-0dd4-611b4d702b7c_id_bf604acce1e6ac0a8640e00e72f04_id_97aec47ead1fa1b9c0a8640e01caaf0d", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：プロジェクトのローカリゼーション-ローカリゼーションテンプレートを作成します \/ ダイアログ：ローカリゼーションテンプレートを作成する ", 
"snippet" : "ダイアログは、ローカリゼーションテンプレートに含めるテキスト情報を選択するために使用されます。 次の情報を含めます 名前 ダイアログタイトル、デバイスツリー内のオブジェクト名などのテキスト 識別子 変数識別子 例： Counter 文字列 例： 'count' 宣言で strVar: STRING := 'count'; コメントコメント プログラミングブロックのコメントテキスト 位置情報 プロジェクトで上記で選択したテキストカテゴリのどの位置を翻訳ファイルに含めるかを選択します 位置情報は、翻訳のセクションの最初の行にあります。例： #: D:\\Proj1.project\\Project_S...", 
"body" : "ダイアログは、ローカリゼーションテンプレートに含めるテキスト情報を選択するために使用されます。 次の情報を含めます 名前 ダイアログタイトル、デバイスツリー内のオブジェクト名などのテキスト 識別子 変数識別子 例： Counter 文字列 例： 'count' 宣言で strVar: STRING := 'count'; コメントコメント プログラミングブロックのコメントテキスト 位置情報 プロジェクトで上記で選択したテキストカテゴリのどの位置を翻訳ファイルに含めるかを選択します 位置情報は、翻訳のセクションの最初の行にあります。例： #: D:\\Proj1.project\\Project_Settings:1 msgid \"Projekteinstellungen\" msgstr \"\" 全て ：テキストの見つかったすべての位置が一覧表示されます。 第一印象 ：翻訳対象のテキストが最初に表示されるプロジェクト内の位置は、翻訳ファイルに含まれています。 なし 生産 ボタンをクリックすると、ファイルを保存するためのダイアログが開きます。翻訳テンプレートは、タイプのテキストファイルに保存されます POT Translation Template (*.pot) 作成した。世代を追加するたびに、完全に新しいテンプレートファイルが作成されます。 " }, 
{ "title" : "コマンド：プロジェクトのローカリゼーション-ローカリゼーションの管理 ", 
"url" : "_cds_cmd_project_loc_manage_localizations.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：プロジェクトのローカリゼーション-ローカリゼーションの管理 ", 
"snippet" : "プロジェクトのローカリゼーション-ローカリゼーションを管理する 関数 ：コマンドはダイアログを開きます ローカリゼーションを管理する 。ダイアログで、目的のローカリゼーション言語またはプロジェクトの元のバージョンを選択します。ここからローカリゼーションファイルをダウンロードすることもできます *.<Sprache>.po プロジェクトに含めるか、プロジェクトから削除します。 電話 ：メニュー プロジェクト→プロジェクトのローカリゼーション 要件 ：プロジェクトは開いています。...", 
"body" : "プロジェクトのローカリゼーション-ローカリゼーションを管理する 関数 ：コマンドはダイアログを開きます ローカリゼーションを管理する 。ダイアログで、目的のローカリゼーション言語またはプロジェクトの元のバージョンを選択します。ここからローカリゼーションファイルをダウンロードすることもできます *.<Sprache>.po プロジェクトに含めるか、プロジェクトから削除します。 電話 ：メニュー プロジェクト→プロジェクトのローカリゼーション 要件 ：プロジェクトは開いています。 " }, 
{ "title" : "ダイアログ：ローカリゼーションを管理する ", 
"url" : "_cds_cmd_project_loc_manage_localizations.html#UUID-81e04e1c-4d12-6b2a-71f2-e34de5e21169_id_e115a730acd0bb1dc0a8640e0057d3f1_id_0580deebc55938f3c0a8640e01d8ca60", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：プロジェクトのローカリゼーション-ローカリゼーションの管理 \/ ダイアログ：ローカリゼーションを管理する ", 
"snippet" : "利用可能なローカリゼーション プロジェクトに存在するローカリゼーションファイルのリスト 例： proj1-de.po proj1-en.po <Originalversion> 元のバージョンはいつでも利用できます。プロジェクトは元のバージョンでのみ編集できます。 追加 ボタンは、別のものを選択するためのダイアログを開きます po -ファイルシステムからのファイル。 削除する ボタンは左側で選択されたものを削除します po プロジェクトからのファイル。 デフォルトのローカリゼーション ：現在選択されているローカリゼーションがデフォルトのローカリゼーションになります。エントリは太字で示されていま...", 
"body" : "利用可能なローカリゼーション プロジェクトに存在するローカリゼーションファイルのリスト 例： proj1-de.po proj1-en.po <Originalversion> 元のバージョンはいつでも利用できます。プロジェクトは元のバージョンでのみ編集できます。 追加 ボタンは、別のものを選択するためのダイアログを開きます po -ファイルシステムからのファイル。 削除する ボタンは左側で選択されたものを削除します po プロジェクトからのファイル。 デフォルトのローカリゼーション ：現在選択されているローカリゼーションがデフォルトのローカリゼーションになります。エントリは太字で示されています。 ローカリゼーションを変更する ボタンを使用して、現在選択されているローカリゼーションに切り替えます。 わかった プロジェクトは、[ファイル]で選択したファイルによって提供される国語で表示されます。もし、あんたが <オリジナルバージョン> を選択すると、プロジェクトは編集可能なローカライズされていないバージョンで表示されます。 " }, 
{ "title" : "コマンド：プロジェクトのローカリゼーション-ローカリゼーションの切り替え ", 
"url" : "_cds_cmd_project_loc_toggle_localization.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：プロジェクトのローカリゼーション-ローカリゼーションの切り替え ", 
"snippet" : "プロジェクトのローカリゼーション-ローカリゼーションの切り替え シンボル： 関数 ：コマンドは、現在設定されているプロジェクトのローカリゼーションと<元のバージョン>を切り替えます。 電話 ：メニュー プロジェクト→プロジェクトのローカリゼーション 次に、ダイアログのボタンをクリックします ローカリゼーションを管理する 、またはボタン ツールバーで 要件 ：プロジェクトは開いています。プロジェクトのデフォルトのローカリゼーションはダイアログにあります ローカリゼーションを管理する 定義されています。...", 
"body" : "プロジェクトのローカリゼーション-ローカリゼーションの切り替え シンボル： 関数 ：コマンドは、現在設定されているプロジェクトのローカリゼーションと<元のバージョン>を切り替えます。 電話 ：メニュー プロジェクト→プロジェクトのローカリゼーション 次に、ダイアログのボタンをクリックします ローカリゼーションを管理する 、またはボタン ツールバーで 要件 ：プロジェクトは開いています。プロジェクトのデフォルトのローカリゼーションはダイアログにあります ローカリゼーションを管理する 定義されています。 " }, 
{ "title" : "コマンド：ドキュメント ", 
"url" : "_cds_cmd_document_project.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：ドキュメント ", 
"snippet" : "書類 シンボル ： 関数 ：コマンドはダイアログを開きます プロジェクトを文書化する 、プロジェクトドキュメントを定義します。プロジェクトドキュメントは、コンテンツを印刷するオープンプロジェクトのオブジェクトの選択です。 電話 ：メニュー 計画 ダイアログ プロジェクトを文書化する 印刷するオブジェクトを選択してください プロジェクトのツリービュー ビューでは、各オブジェクトをアクティブ化または非アクティブ化して、印刷用にオブジェクトを選択または選択解除できます。 デフォルトでは、すべてのオブジェクトが選択されています。 表紙 CODESYS 「プロジェクトドキュメント」というタイトルのカバー...", 
"body" : "書類 シンボル ： 関数 ：コマンドはダイアログを開きます プロジェクトを文書化する 、プロジェクトドキュメントを定義します。プロジェクトドキュメントは、コンテンツを印刷するオープンプロジェクトのオブジェクトの選択です。 電話 ：メニュー 計画 ダイアログ プロジェクトを文書化する 印刷するオブジェクトを選択してください プロジェクトのツリービュー ビューでは、各オブジェクトをアクティブ化または非アクティブ化して、印刷用にオブジェクトを選択または選択解除できます。 デフォルトでは、すべてのオブジェクトが選択されています。 表紙 CODESYS 「プロジェクトドキュメント」というタイトルのカバーシートと次の情報を作成します。 ファイル：プロジェクトのファイル名 日付：プロジェクトドキュメントが作成された日付 プロファイル： CODESYS プロジェクトプロファイル 目次 CODESYS プロジェクトドキュメントの目次を作成します。 プレビュー CODESYS プロジェクトドキュメントのプリントアウトのプレビューを作成して開きます。 選ぶ CODESYS プロジェクトドキュメントのすべてまたは個々のオブジェクトタイプを選択するための選択リストを開きます。 選択を解除 CODESYS プロジェクトドキュメントに含めるべきではないすべてまたは個々のオブジェクトタイプを選択するための選択リストを開きます。 わかった 対話 押す 開きます。 " }, 
{ "title" : "コマンド：比較 ", 
"url" : "_cds_cmd_project_compare.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：比較 ", 
"snippet" : "比較 シンボル： 関数 ：コマンドはダイアログを開きます プロジェクトの比較 。このダイアログでは、現在のプロジェクトと比較される参照プロジェクトを定義します。オプションを使用して比較プロセスを構成します。ダイアログを閉じると、比較が開始され、結果がビューに表示されます プロジェクトの比較-違い 示されています。 電話 ： プロジェクト→比較 要件 ：プロジェクトは開いています。 詳細については、以下を参照してください。 プロジェクトの比較...", 
"body" : "比較 シンボル： 関数 ：コマンドはダイアログを開きます プロジェクトの比較 。このダイアログでは、現在のプロジェクトと比較される参照プロジェクトを定義します。オプションを使用して比較プロセスを構成します。ダイアログを閉じると、比較が開始され、結果がビューに表示されます プロジェクトの比較-違い 示されています。 電話 ： プロジェクト→比較 要件 ：プロジェクトは開いています。 詳細については、以下を参照してください。 プロジェクトの比較" }, 
{ "title" : "ダイアログ：プロジェクトの比較 ", 
"url" : "_cds_cmd_project_compare.html#UUID-f5ea182a-cfb7-3593-8e76-0cea6ad834e6_id_b4ab0feb656a504c0a8640e0049e575_id_63feca2505a112dcc0a8640e0093f4b0", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：比較 \/ ダイアログ：プロジェクトの比較 ", 
"snippet" : "現在開いているプロジェクトを ディスク上のプロジェクト ファイルシステム内の参照プロジェクトのパス ソースコードデータベースでのプロジェクト ホスティング： ソースコード管理が存在するホストの名前 ポート： ソース管理に接続するためのポート番号 位置： 参照プロジェクトのパス 要件：プロジェクトはソースコード管理にリンクされています（例： CODESYS SVN ）接続されています。 比較オプション： スペースを無視する ：スペースのみに基づく参照プロジェクトからの現在のプロジェクトの逸脱は無視されます。 コメントを無視する ：プログラミングコード内のコメントは比較から除外されます。 プロパテ...", 
"body" : "現在開いているプロジェクトを ディスク上のプロジェクト ファイルシステム内の参照プロジェクトのパス ソースコードデータベースでのプロジェクト ホスティング： ソースコード管理が存在するホストの名前 ポート： ソース管理に接続するためのポート番号 位置： 参照プロジェクトのパス 要件：プロジェクトはソースコード管理にリンクされています（例： CODESYS SVN ）接続されています。 比較オプション： スペースを無視する ：スペースのみに基づく参照プロジェクトからの現在のプロジェクトの逸脱は無視されます。 コメントを無視する ：プログラミングコード内のコメントは比較から除外されます。 プロパティを無視する ：オブジェクトのプロパティは比較から除外されます。 わかった プロジェクトの比較を開始し、結果をビューに表示します プロジェクトの比較-違い 代表する " }, 
{ "title" : "ビュー：プロジェクトの比較-違い ", 
"url" : "_cds_cmd_project_compare.html#UUID-f5ea182a-cfb7-3593-8e76-0cea6ad834e6_id_b4ab0feb656a504c0a8640e0049e575_id_b06064bf995011e79187da3a4d206d74", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：比較 \/ ビュー：プロジェクトの比較-違い ", 
"snippet" : "ダイアログを開くと、プロジェクト比較ビューが表示されます プロジェクトの比較 と わかった 別れる。 （1）現在のプロジェクトのオブジェクトツリー （2）参照プロジェクトのオブジェクトツリー （3）コマンド ブロックを引き継ぐ 、 指図 個別に引き継ぐ （4） 比較オプション 、ダイアログで構成 プロジェクトの比較 、 比較統計 ：追加、削除、変更されたオブジェクト ツールバー 詳細比較ビューに切り替えます プロジェクトの比較-<オブジェクト名>の違い ツリーで選択されたオブジェクトの場合 別の方法：オブジェクトをダブルクリックします 違いが見つかったデバイスツリーの次に低いオブジェクトを選択...", 
"body" : "ダイアログを開くと、プロジェクト比較ビューが表示されます プロジェクトの比較 と わかった 別れる。 （1）現在のプロジェクトのオブジェクトツリー （2）参照プロジェクトのオブジェクトツリー （3）コマンド ブロックを引き継ぐ 、 指図 個別に引き継ぐ （4） 比較オプション 、ダイアログで構成 プロジェクトの比較 、 比較統計 ：追加、削除、変更されたオブジェクト ツールバー 詳細比較ビューに切り替えます プロジェクトの比較-<オブジェクト名>の違い ツリーで選択されたオブジェクトの場合 別の方法：オブジェクトをダブルクリックします 違いが見つかったデバイスツリーの次に低いオブジェクトを選択します 差異が見つかったデバイスツリーの次の上位オブジェクトを選択します ブロックを引き継ぐ ブロック（すべての従属オブジェクトとユニットを含む選択されたオブジェクト）が、参照ブロックから現在のブロックへの転送用に選択されます。 繰り返しクリック ブロックを引き継ぐ 最後に使用した効果を元に戻します。 個別に引き継ぐ オブジェクトは、参照オブジェクトから現在のオブジェクトへの転送用に選択されています。 要件：オブジェクトツリーで選択されたオブジェクトには、さまざまなプロパティ、アクセス権、またはフォルダの割り当てがあります。 ダイアログを開きます 買収 詳細なクエリ 色と記号による違いの表示 を含むオブジェクト名 オブジェクトの子オブジェクトが異なります。 黒のフォント オブジェクトは同一です。 灰色の背景 オブジェクトは異なります。 灰色の背景+太字の青いフォント オブジェクトは、参照プロジェクトでのみ使用できます。 灰色の背景+太字の緑色のフォント オブジェクトは、開いているプロジェクトでのみ使用できます（参照オブジェクトでは使用できません）。 灰色の背景+赤い書き込み+ オブジェクトにはさまざまなプロパティがあります。 灰色の背景+赤い書き込み+ オブジェクトと参照オブジェクトのアクセス権は異なります。 灰色の背景+太字の赤いフォント+ オブジェクトの実装は異なります。 線をダブルクリックすると、オブジェクト固有の比較ビューが表示されます。 黄色のハイライト オブジェクトは受け入れられるように設定されています。 黄色のハイライト + 開いているプロジェクトに参照オブジェクトを追加する設定を行います。 黄色のハイライト + オブジェクト（開いているプロジェクト内）の削除が設定されています。 黄色のハイライト + 参照プロジェクトのプロパティの受け入れが設定されます。 黄色のハイライト + 赤のフォント + 参照プロジェクトのアクセス権の受け入れが有効になります。 グレーのハイライト + 赤の太字フォント + リファレンスプロジェクトの実施の承認が設定されています。 ビューのフッターに表示 比較オプション 対話中のもの プロジェクトの比較 定義された比較オプション 比較統計 参照プロジェクトと比較した現在のプロジェクトの挿入、削除、変更の数 変形 両方のプロジェクトに存在するオブジェクト内の違いを意味します。 プロンプト 比較ビューで行った変更を保存しますか？ が表示されます。 はい ：背景が黄色のオブジェクトのコンテンツ、プロパティ、またはアクセス権がプロジェクトで変更されます。その後、それらは参照プロジェクトのものに対応します。次に、プロジェクト比較ビューが完全に閉じられます。 " }, 
{ "title" : "ビュー：プロジェクトの比較-<オブジェクト名>の違い ", 
"url" : "_cds_cmd_project_compare.html#UUID-f5ea182a-cfb7-3593-8e76-0cea6ad834e6_id_b4ab0feb656a504c0a8640e0049e575_id_0c281e3bff98a2e4c0a8646318863ab4", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：比較 \/ ビュー：プロジェクトの比較-<オブジェクト名>の違い ", 
"snippet" : "関数 ：詳細比較ビュー プロジェクト比較ビューを呼び出す 別のコンテンツがあるとマークされているため、そのコンテンツを詳細に必要とするオブジェクトを選択し、をクリックします。 。 オブジェクトをダブルクリックします ツールバー プロジェクト比較ビューに戻ります 違いが見つかったコードの1つ下の行を選択します 違いが見つかったコードの次の上の行を選択します ブロックを引き継ぐ 2 参照ブロックを現在のプロジェクトに転送するために、ブロック（すべての従属行を含む）が選択されます。 詳細比較ビューのブロックは、カーソルが現在置かれているユニットと、同じ差異のマークが付いているすべての関連ユニットで構...", 
"body" : "関数 ：詳細比較ビュー プロジェクト比較ビューを呼び出す 別のコンテンツがあるとマークされているため、そのコンテンツを詳細に必要とするオブジェクトを選択し、をクリックします。 。 オブジェクトをダブルクリックします ツールバー プロジェクト比較ビューに戻ります 違いが見つかったコードの1つ下の行を選択します 違いが見つかったコードの次の上の行を選択します ブロックを引き継ぐ 2 参照ブロックを現在のプロジェクトに転送するために、ブロック（すべての従属行を含む）が選択されます。 詳細比較ビューのブロックは、カーソルが現在置かれているユニットと、同じ差異のマークが付いているすべての関連ユニットで構成されます。ユニットは、回線、ネットワーク、または要素です。関連する単位は、たとえば、行の後続の行です。 繰り返しクリック ブロックを引き継ぐ 最後に使用した効果を元に戻します。 個別に引き継ぐ この線は、現在のオブジェクトの参照線を引き継ぐために選択されます。 このボタンは、詳細比較ビューでのみ使用できます。 異なる単位（行、ネットワーク、要素）が赤で表示されるデフォルトの表示と、異なる表示を切り替えます それらは赤で強調表示され、同じ高さで互いに真向かいに配置されます どちらの場合も、現在開いているプロジェクトまたは参照プロジェクトで、削除または挿入として表示されます。 注：表示に応じて、統計で見つかった差異は、変更として、または挿入と削除としてカウントされます。 詳細比較ビューの 3 番目のビュー このボタンは、現在のビューと参照ビューの比較の下にある 3 番目のビューを開いたり閉じたりします (下の図を参照)。この 3 番目のビューには、検出された相違点を解決するために実行されたアクションの結果が表示されます。影響を受ける行には、行頭に黄色のバーが表示されます。 (1) 第三比較図 (2) 結果 右線を使用 アクション (3) ボタン: 右線を使用 左の行 (現在のプロジェクトの実装) が使用されます。 左のブロック (現在のプロジェクトのブロックの実装) が使用されます。 右側の行 (参照プロジェクトの実装) が使用されます。 右側のブロック (参照プロジェクトのブロックの実装) が使用されます。 違いが直接比較されない場合にのみ使用できます ( ): 3 番目の (結果) ビューでは、左の行が右の行の上に挿入されます。 違いが直接比較されない場合にのみ使用できます ( ) : 3 番目の (結果) ビューでは、左の行の上に右の行が挿入されます。 色と記号による違いの表示 黒のフォント オブジェクトは同一です。 を含むオブジェクト名 オブジェクトの子オブジェクトが異なります。 灰色のハイライト + 太字の青色のフォント コードは参照プロジェクトにのみ存在します。 灰色のハイライト + 太字の緑色のフォント コードは現在のプロジェクトにのみ存在します (参照プロジェクトには存在しません)。 黄色のハイライト オブジェクトは受け入れられるように設定されています。 の 差分ビューで行った変更をコミットしますか? ダイアログプロンプトが開きます。 はい : 黄色で強調表示されたコードがプロジェクトに受け入れられます。コードは参照プロジェクトに対応しています。その後、詳細ビューが閉じられ、プロジェクト ビューが表示されます。プロジェクト比較の作業を続行できます。 " }, 
{ "title" : "対話：適用 ", 
"url" : "_cds_cmd_project_compare.html#UUID-f5ea182a-cfb7-3593-8e76-0cea6ad834e6_id_b4ab0feb656a504c0a8640e0049e575_id_2299abfeff98a2e4c0a864630c6c353e", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：比較 \/ 対話：適用 ", 
"snippet" : "どのメタ情報を転送する必要がありますか？ アクセス権 ：継承用に選択された権限 承認されたグループ アクセス権が参照プロジェクトから継承されているグループ グループが両方のプロジェクトに存在し、アクセス権が異なる場合、グループは受け入れられます。 例： Group_A 受け入れられないグループ（プロジェクトに参加していません） どちらのプロジェクトにも存在しない場合、グループは受け入れられません。 プロパティ ：継承が有効になっているプロパティ 要件：参照オブジェクトとオブジェクトのプロパティが異なります。 わかった 設定は受け入れられます。...", 
"body" : "どのメタ情報を転送する必要がありますか？ アクセス権 ：継承用に選択された権限 承認されたグループ アクセス権が参照プロジェクトから継承されているグループ グループが両方のプロジェクトに存在し、アクセス権が異なる場合、グループは受け入れられます。 例： Group_A 受け入れられないグループ（プロジェクトに参加していません） どちらのプロジェクトにも存在しない場合、グループは受け入れられません。 プロパティ ：継承が有効になっているプロパティ 要件：参照オブジェクトとオブジェクトのプロパティが異なります。 わかった 設定は受け入れられます。 " }, 
{ "title" : "コマンド：受け入れられた変更を転送する ", 
"url" : "_cds_cmd_commit_accepted_changes.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：受け入れられた変更を転送する ", 
"snippet" : "承認された変更を転送する シンボル： 関数 ：コマンドは、採用された差異をプロジェクト比較から現在のプロジェクトに転送します。 電話 ： プロジェクト→承認された変更の転送 要件 ：プロジェクト比較からの変更が採用されました。 変更はプロジェクトにのみコピーされます。このコマンドではディスクに保存されません。 詳細については、以下を参照してください。 詳細比較ビューを開く...", 
"body" : "承認された変更を転送する シンボル： 関数 ：コマンドは、採用された差異をプロジェクト比較から現在のプロジェクトに転送します。 電話 ： プロジェクト→承認された変更の転送 要件 ：プロジェクト比較からの変更が採用されました。 変更はプロジェクトにのみコピーされます。このコマンドではディスクに保存されません。 詳細については、以下を参照してください。 詳細比較ビューを開く" }, 
{ "title" : "コマンド:XML としてエクスポート ", 
"url" : "_cds_cmd_export.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド:XML としてエクスポート ", 
"snippet" : "XML としてエクスポート 関数 ：このコマンドは、プロジェクトのオブジェクトをXMLファイルにエクスポートするためのダイアログを開きます。 コール : プロジェクト → エクスポート メニュー...", 
"body" : "XML としてエクスポート 関数 ：このコマンドは、プロジェクトのオブジェクトをXMLファイルにエクスポートするためのダイアログを開きます。 コール : プロジェクト → エクスポート メニュー " }, 
{ "title" : "ダイアログ 輸出 ", 
"url" : "_cds_cmd_export.html#UUID-776705e8-b094-bcb8-d7f6-5fd436c5781b_id_e897dec0fff2c0a8640e0188145f_id_96a5b119635a8e3bc0a8640e005df4c1", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド:XML としてエクスポート \/ ダイアログ 輸出 ", 
"snippet" : "ダイアログには、デバイスツリー、POUツリー、およびモジュールツリーのすべてのオブジェクトが一覧表示されます。 CODESYS エクスポートできます。 サブツリーごとに1つのファイル ： CODESYS ルートノードのすぐ下にあり、選択したオブジェクトを含むサブツリーごとに個別のエクスポートファイルを作成します。 ： CODESYS 選択したすべてのオブジェクトに対して1つのエクスポートファイルのみを作成します。 メモリバージョン バージョンは、エクスポートファイルが後でインポートされるバージョンに対応している必要があります。 現在のプロジェクトに、選択したストレージ形式（プロファイル）で使用...", 
"body" : "ダイアログには、デバイスツリー、POUツリー、およびモジュールツリーのすべてのオブジェクトが一覧表示されます。 CODESYS エクスポートできます。 サブツリーごとに1つのファイル ： CODESYS ルートノードのすぐ下にあり、選択したオブジェクトを含むサブツリーごとに個別のエクスポートファイルを作成します。 ： CODESYS 選択したすべてのオブジェクトに対して1つのエクスポートファイルのみを作成します。 メモリバージョン バージョンは、エクスポートファイルが後でインポートされるバージョンに対応している必要があります。 現在のプロジェクトに、選択したストレージ形式（プロファイル）で使用できないプラグインまたはアドオンが含まれている場合、ダイアログが開きます プロファイルを展開 。このダイアログでは、選択したプロファイルをアドオンで拡張できます。 詳細については、以下を参照してください。 プロジェクトのエクスポートとインポート" }, 
{ "title" : "コマンド:XML からインポート ", 
"url" : "_cds_cmd_import.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド:XML からインポート ", 
"snippet" : "XML からインポート 関数 ：このコマンドは、XMLファイルからオブジェクトをインポートするためのダイアログを開きます。 コール : プロジェクト → インポート メニュー 要件 ：プロジェクトは開いています。 プロジェクトをインポートする前に、 CODESYS インストールされていないアドオンがプロジェクトに必要かどうかをチェックします。この場合、不足しているアドオンを含むダイアログが開きます。これらは、このダイアログを使用して後でインストールできます。...", 
"body" : "XML からインポート 関数 ：このコマンドは、XMLファイルからオブジェクトをインポートするためのダイアログを開きます。 コール : プロジェクト → インポート メニュー 要件 ：プロジェクトは開いています。 プロジェクトをインポートする前に、 CODESYS インストールされていないアドオンがプロジェクトに必要かどうかをチェックします。この場合、不足しているアドオンを含むダイアログが開きます。これらは、このダイアログを使用して後でインストールできます。 " }, 
{ "title" : "ダイアログ 輸入 ", 
"url" : "_cds_cmd_import.html#UUID-ac71f905-c8c9-883c-f3d4-548c03b37cbc_id_fe172f01dec6b272c0a8640e000bd57a_id_96a5b119635a8e3bc0a8640e005df4c1", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド:XML からインポート \/ ダイアログ 輸入 ", 
"snippet" : "ダイアログには、エクスポートファイルからのすべてのオブジェクトが一覧表示されます。 CODESYS この時点でインポートできます。 現在選択されているターゲットオブジェクト デバイスツリーで選択されているオブジェクト 挿入可能なオブジェクト エクスポートファイルのすべてのオブジェクトを表示します CODESYS 選択したオブジェクトの下 コンテンツを見る エクスポートファイルの内容をツリー構造で表示します 詳細については、以下を参照してください。 プロジェクトのエクスポートとインポート...", 
"body" : "ダイアログには、エクスポートファイルからのすべてのオブジェクトが一覧表示されます。 CODESYS この時点でインポートできます。 現在選択されているターゲットオブジェクト デバイスツリーで選択されているオブジェクト 挿入可能なオブジェクト エクスポートファイルのすべてのオブジェクトを表示します CODESYS 選択したオブジェクトの下 コンテンツを見る エクスポートファイルの内容をツリー構造で表示します 詳細については、以下を参照してください。 プロジェクトのエクスポートとインポート" }, 
{ "title" : "コマンド：PLCopenXMLをエクスポート ", 
"url" : "_cds_cmd_export_plcopenxml.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：PLCopenXMLをエクスポート ", 
"snippet" : "PLCopenXMLをエクスポートする 関数 ：このコマンドは、プロジェクトのオブジェクトをPLCopen形式のXMLファイルにエクスポートするためのダイアログを開きます。 コール : プロジェクト → エクスポート メニュー ダイアログ：PLCopenXMLをエクスポート ダイアログには、デバイスツリーのすべてのオブジェクトが一覧表示されます。 CODESYS PLCopen形式に従ってXMLファイルにエクスポートします。 PLCopenXMLスキーマでは、VAR_GLOBALブロックとVAR_GLOBALCONSTANTブロックを同じ変数リストに含めることはできません。したがって、両方をエ...", 
"body" : "PLCopenXMLをエクスポートする 関数 ：このコマンドは、プロジェクトのオブジェクトをPLCopen形式のXMLファイルにエクスポートするためのダイアログを開きます。 コール : プロジェクト → エクスポート メニュー ダイアログ：PLCopenXMLをエクスポート ダイアログには、デバイスツリーのすべてのオブジェクトが一覧表示されます。 CODESYS PLCopen形式に従ってXMLファイルにエクスポートします。 PLCopenXMLスキーマでは、VAR_GLOBALブロックとVAR_GLOBALCONSTANTブロックを同じ変数リストに含めることはできません。したがって、両方をエクスポートする場合は、最初に変数を2つの別々の変数リストに分割する必要があります。 詳細については、以下を参照してください。 プロジェクトのエクスポートとインポート" }, 
{ "title" : "コマンド：PLCopenXMLをインポートする ", 
"url" : "_cds_cmd_import_plcopenxml.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：PLCopenXMLをインポートする ", 
"snippet" : "PLCopenXMLをインポートする 関数 ：このコマンドは、PLCopen形式のXMLファイルからオブジェクトをインポートするためのダイアログを開きます。 コール : プロジェクト → インポート メニュー 要件 ：プロジェクトは開いています。...", 
"body" : "PLCopenXMLをインポートする 関数 ：このコマンドは、PLCopen形式のXMLファイルからオブジェクトをインポートするためのダイアログを開きます。 コール : プロジェクト → インポート メニュー 要件 ：プロジェクトは開いています。 " }, 
{ "title" : "ダイアログ：PLCopenXMLをインポートします ", 
"url" : "_cds_cmd_import_plcopenxml.html#UUID-30e7f7a4-620a-f8ba-886c-a6ca39fbab9d_id_deccec55c0a8640e00ef38fa_id_96a5b119635a8e3bc0a8640e005df4c1", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：PLCopenXMLをインポートする \/ ダイアログ：PLCopenXMLをインポートします ", 
"snippet" : "ダイアログには、PLCopenエクスポートファイルからのすべてのオブジェクトが一覧表示されます。 CODESYS この時点でインポートできます。 現在選択されているターゲットオブジェクト デバイスツリーで選択されているオブジェクト 挿入可能なエントリ エクスポートファイルのすべてのオブジェクトを表示します CODESYS 選択したオブジェクトの下 紛争解決 既存のオブジェクトと同じ名前のオブジェクトがインポートされると、次のようにオブジェクトごとに競合を解決できます。 既存のオブジェクトを置き換える : プロジェクトに存在するオブジェクトは、インポートされたオブジェクトによって上書きされます。...", 
"body" : "ダイアログには、PLCopenエクスポートファイルからのすべてのオブジェクトが一覧表示されます。 CODESYS この時点でインポートできます。 現在選択されているターゲットオブジェクト デバイスツリーで選択されているオブジェクト 挿入可能なエントリ エクスポートファイルのすべてのオブジェクトを表示します CODESYS 選択したオブジェクトの下 紛争解決 既存のオブジェクトと同じ名前のオブジェクトがインポートされると、次のようにオブジェクトごとに競合を解決できます。 既存のオブジェクトを置き換える : プロジェクトに存在するオブジェクトは、インポートされたオブジェクトによって上書きされます。 新しいオブジェクトの名前を変更する : 新しいオブジェクトが変更された名前でインポートされます。文字列 _<no> 名前の末尾に追加されます。 新しいオブジェクトをスキップ : オブジェクトはインポートされません。 選択する オブジェクト タイプを選択するためのリスト ボックスを開きます 選択解除 オブジェクト タイプの選択を解除するためのリスト ボックスを開きます 競合 すべての競合を解決するためのリスト ボックスを開きます 内容を表示 XML ファイルのオブジェクトが表示されるダイアログを開きます PLCopenXMLスキーマでは、VAR_GLOBALブロックとVAR_GLOBALCONSTANTブロックを同じ変数リストに含めることはできません。したがって、両方をエクスポートする場合は、最初に変数を2つの別々の変数リストに分割する必要があります。 詳細については、次を参照してください。 プロジェクトのエクスポートとインポート" }, 
{ "title" : "コマンド:IEC61131-10 をエクスポート ", 
"url" : "_cds_cmd_export_iec_61131_10.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド:IEC61131-10 をエクスポート ", 
"snippet" : "IEC61131-10 をエクスポート この機能は、IEC 61131-10規格でもサポートされている要素のみを処理するため、他のIDEとの交換にのみお勧めします。他のオブジェクト (CFC オブジェクトやライブラリマネージャーなど) はサポートされていません。からのエクスポート\/インポート用 CODESYS へ CODESYS したがって、100% のカバレッジを得るには、引き続きネイティブのインポート\/エクスポートをお勧めします。 シンボル: ファンクション : このコマンドは、現在開いているプロジェクトを XML ファイル形式にエクスポートするためのダイアログを開きます。 *.iec61...", 
"body" : "IEC61131-10 をエクスポート この機能は、IEC 61131-10規格でもサポートされている要素のみを処理するため、他のIDEとの交換にのみお勧めします。他のオブジェクト (CFC オブジェクトやライブラリマネージャーなど) はサポートされていません。からのエクスポート\/インポート用 CODESYS へ CODESYS したがって、100% のカバレッジを得るには、引き続きネイティブのインポート\/エクスポートをお勧めします。 シンボル: ファンクション : このコマンドは、現在開いているプロジェクトを XML ファイル形式にエクスポートするためのダイアログを開きます。 *.iec6113110.xml 。ザの エクスポート ダイアログには、からのオブジェクトが表示されます。 [デバイス] ( デバイス ノード) と POU ( プールオブジェクト ノード () ビューこのコマンドでエクスポートできるすべてのオブジェクトが選択されます。ダイアログでは、個々のオブジェクトを選択してエクスポートしたり、選択を解除したりできます コール : コマンドはどの標準メニューにも含まれていません。コマンドは次の方法で追加できます。 ツール → カスタマイズ のダイアログ デバイス カテゴリー。詳細については、以下を参照してください。 メニューをカスタマイズする必要条件 : プロジェクトが開いている。 For more information, see: IEC-61131-10 をインポート" }, 
{ "title" : "コマンド:IEC-61131-10 をインポート ", 
"url" : "_cds_cmd_import_iec_61131_10.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド:IEC-61131-10 をインポート ", 
"snippet" : "IEC-61131-10 をインポート この機能は、IEC 61131-10規格でもサポートされている要素のみを処理するため、他のIDEとの交換にのみお勧めします。他のオブジェクト (CFC オブジェクトやライブラリマネージャーなど) はサポートされていません。からのエクスポート\/インポート用 CODESYS へ CODESYS したがって、100% のカバレッジを得るには、引き続きネイティブのインポート\/エクスポートをお勧めします。 シンボル: ファンクション : このコマンドは、次の形式の XML ファイルをインポートするための標準ダイアログを開きます。 IecXchangefiles (...", 
"body" : "IEC-61131-10 をインポート この機能は、IEC 61131-10規格でもサポートされている要素のみを処理するため、他のIDEとの交換にのみお勧めします。他のオブジェクト (CFC オブジェクトやライブラリマネージャーなど) はサポートされていません。からのエクスポート\/インポート用 CODESYS へ CODESYS したがって、100% のカバレッジを得るには、引き続きネイティブのインポート\/エクスポートをお勧めします。 シンボル: ファンクション : このコマンドは、次の形式の XML ファイルをインポートするための標準ダイアログを開きます。 IecXchangefiles (*.xml) 。インポートすると、 インポートします。 ダイアログが開き、オブジェクトを選択\/選択解除したり、コンフリクトを処理したりするための機能が表示されます。で選択したオブジェクトによって異なります デバイス または POU view、そこに挿入できる要素のリストがインポートダイアログで更新されます。ダイアログが開いている間は、をクリックして選択を変更できます [デバイス] または POU 見る。 コール : コマンドはどの標準メニューにも含まれていません。コマンドは次の方法で追加できます。 ツール → カスタマイズ のダイアログ デバイス カテゴリー。詳細については、以下を参照してください。 メニューをカスタマイズする必要条件 : プロジェクトが開いている。 ダイアログ:インポート [コンテンツ] 挿入可能なアイテム 現在のプロジェクトで選択したオブジェクトの下に挿入できるインポートファイル内のすべてのオブジェクトのリスト。個々のオブジェクトはインポート用に選択または選択解除できます 紛争解決 フィールドをクリックすると、この要素に表示される競合解決方法を変更するためのリストボックスが開きます。 要件:エレメントに矛盾があります。 既存のオブジェクトと同じ名前のオブジェクトをインポートすると、次のように各オブジェクトのコンフリクトを解決できます。 既存のオブジェクトを置換 : プロジェクトに存在するオブジェクトは、インポートされたオブジェクトによって上書きされます。 Rename the new object : The new object is imported with the changed name. A consecutive number _<no> is appended to the name Skip the new object : The object is not imported. [デバイス] フィールドをクリックすると、 ボタンが表示されます。このボタンを使うと、で別のデバイスを選択できます。 [デバイス] を選択します。 ダイアログ。 追加情報 ファイルヘッダー コンテンツのヘッダー インポートファイル情報の表示 [選択] このリストボックスを使用して、すべてのオブジェクトまたは特定のタイプのすべてのオブジェクトを選択できます。 選択解除 このリストボックスを使用して、すべてのオブジェクトまたは特定のタイプのすべてのオブジェクトを選択解除できます。 コンフリクト このリストボックスを使用して、コンフリクトのあるすべてのオブジェクトに適用されるコンフリクトレゾリューションを選択できます。 特定のオブジェクトのコンフリクトレゾリューションを変更するには、をクリックします コンフリクト解決 各オブジェクトのフィールド。 For more information, see: IEC61131-10 をエクスポート" }, 
{ "title" : "コマンド：ユーザー管理-ログインユーザー ", 
"url" : "_cds_cmd_usermanagement_logon.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：ユーザー管理-ログインユーザー ", 
"snippet" : "ユーザー管理-ユーザーの登録 シンボル： 関数 ：コマンドはダイアログを開きます 登録 。 電話 ：メニュー プロジェクト→ユーザー管理 対話中 登録 編集するプロジェクトと、適切な権限を持つユーザーアカウントのクレデンシャルを指定します。このダイアログからパスワードマネージャーを開くこともできます。 詳細については、以下を参照してください。 プロジェクトとオブジェクトのユーザー管理とアクセス権の設定...", 
"body" : "ユーザー管理-ユーザーの登録 シンボル： 関数 ：コマンドはダイアログを開きます 登録 。 電話 ：メニュー プロジェクト→ユーザー管理 対話中 登録 編集するプロジェクトと、適切な権限を持つユーザーアカウントのクレデンシャルを指定します。このダイアログからパスワードマネージャーを開くこともできます。 詳細については、以下を参照してください。 プロジェクトとオブジェクトのユーザー管理とアクセス権の設定 " }, 
{ "title" : "コマンド：ユーザー管理-ユーザーをログオフします ", 
"url" : "_cds_cmd_usermanagement_logoff.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：ユーザー管理-ユーザーをログオフします ", 
"snippet" : "ユーザー管理-ユーザーをログオフします シンボル： 関数 ：このコマンドは、現在プロジェクトにログインしているユーザーをログオフします。これは、現在ログオンしているユーザーがいない場合を除き、ダイアログやメッセージなしで発生します。 電話 ：メニュー プロジェクト→ユーザー管理 ユーザーが現在複数のプロジェクトまたはリンクされたライブラリにログインしている場合（同じユーザーアカウントである必要はありません）、ダイアログが表示されます 登録解除 。このダイアログでは、現在のユーザーがログオフするプロジェクトまたはライブラリプロジェクトを具体的に選択できます。 ステータスバーには、プロジェクトに現...", 
"body" : "ユーザー管理-ユーザーをログオフします シンボル： 関数 ：このコマンドは、現在プロジェクトにログインしているユーザーをログオフします。これは、現在ログオンしているユーザーがいない場合を除き、ダイアログやメッセージなしで発生します。 電話 ：メニュー プロジェクト→ユーザー管理 ユーザーが現在複数のプロジェクトまたはリンクされたライブラリにログインしている場合（同じユーザーアカウントである必要はありません）、ダイアログが表示されます 登録解除 。このダイアログでは、現在のユーザーがログオフするプロジェクトまたはライブラリプロジェクトを具体的に選択できます。 ステータスバーには、プロジェクトに現在ログインしているユーザーが常に表示されます。 フィールドをダブルクリックします 現在の使用者 ステータスバーで、にすばやくアクセスできます 登録 - また。 登録解除 -ダイアログ。 詳細については、以下を参照してください。 プロジェクトとオブジェクトのユーザー管理とアクセス権の設定 そして ユーザー管理-ユーザーの登録" }, 
{ "title" : "コマンド：ユーザー管理-権利 ", 
"url" : "_cds_cmd_usermanagement_rights.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：ユーザー管理-権利 ", 
"snippet" : "ユーザー管理-権利 関数 ：コマンドはダイアログを開きます 正しい 。 電話 ：メニュー プロジェクト→ユーザー管理 対話中 正しい どのプロジェクトオブジェクトのどのユーザーグループがどのアクションを実行できるかを定義します。 詳細については、以下を参照してください。 プロジェクトとオブジェクトのユーザー管理とアクセス権の設定...", 
"body" : "ユーザー管理-権利 関数 ：コマンドはダイアログを開きます 正しい 。 電話 ：メニュー プロジェクト→ユーザー管理 対話中 正しい どのプロジェクトオブジェクトのどのユーザーグループがどのアクションを実行できるかを定義します。 詳細については、以下を参照してください。 プロジェクトとオブジェクトのユーザー管理とアクセス権の設定 " }, 
{ "title" : "コマンド：デバイスを挿入 ", 
"url" : "_cds_cmd_insert_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：デバイスを挿入 ", 
"snippet" : "挿入装置 関数 ：コマンドはコマンドのように開きます デバイスを接続します 対話 デバイスを接続します デバイスオブジェクトを選択します。このオブジェクトは、現在選択されているオブジェクトと同じレベルのデバイスツリーに挿入されます。 電話 ：デバイスツリー内のデバイスオブジェクトのコンテキストメニュー 要件 ：デバイスツリーでオブジェクトが選択され、その下にデバイスオブジェクトを同じレベルで挿入できます。...", 
"body" : "挿入装置 関数 ：コマンドはコマンドのように開きます デバイスを接続します 対話 デバイスを接続します デバイスオブジェクトを選択します。このオブジェクトは、現在選択されているオブジェクトと同じレベルのデバイスツリーに挿入されます。 電話 ：デバイスツリー内のデバイスオブジェクトのコンテキストメニュー 要件 ：デバイスツリーでオブジェクトが選択され、その下にデバイスオブジェクトを同じレベルで挿入できます。 " }, 
{ "title" : "コマンド：EtherCATXMLを生成する ", 
"url" : "_cds_cmd_generate_ethercat_xml.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：EtherCATXMLを生成する ", 
"snippet" : "EtherCATXMLを生成する このコマンドは標準メニューには含まれていません。あなたは彼にダイアログについて尋ねることができます ツール→カスタマイズ カテゴリから 装置 追加。詳細については、以下を参照してください。 メニューをカスタマイズする関数 ：このコマンドは、ローカルファイルシステムにファイルを保存するための標準ダイアログを開きます。 xmlファイルの名前と場所を定義できます。 CODESYS デバイスツリーで現在選択されているEtherCATマスターのEtherCAT設定を保存する必要があります。これは、外部EtherCATスタックを操作するために必要な場合があります。 電話 ...", 
"body" : "EtherCATXMLを生成する このコマンドは標準メニューには含まれていません。あなたは彼にダイアログについて尋ねることができます ツール→カスタマイズ カテゴリから 装置 追加。詳細については、以下を参照してください。 メニューをカスタマイズする関数 ：このコマンドは、ローカルファイルシステムにファイルを保存するための標準ダイアログを開きます。 xmlファイルの名前と場所を定義できます。 CODESYS デバイスツリーで現在選択されているEtherCATマスターのEtherCAT設定を保存する必要があります。これは、外部EtherCATスタックを操作するために必要な場合があります。 電話 ：デバイスツリー内のEtherCATマスターデバイスオブジェクトのコンテキストメニュー 詳細については、以下を参照してください。 I \/ Oリンクの構成" }, 
{ "title" : "コマンド：sercos SCIXMLを生成します ", 
"url" : "_cds_cmd_generate_sercos3_xml.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：sercos SCIXMLを生成します ", 
"snippet" : "sercos SCIXMLを生成する このコマンドは標準メニューには含まれていません。あなたは彼にダイアログについて尋ねることができます ツール→カスタマイズ カテゴリから 装置 追加。 関数 ：このコマンドは、ローカルファイルシステムにファイルを保存するための標準ダイアログを開きます。 xmlファイルの名前と場所を定義できます。 CODESYS デバイスツリーで現在選択されているsercosマスターの構成データを保存する必要があります。これは、外部のsercosスタックを操作するために必要になる場合があります。 電話 ：デバイスツリー内のsercosマスターデバイスオブジェクトのコンテキスト...", 
"body" : "sercos SCIXMLを生成する このコマンドは標準メニューには含まれていません。あなたは彼にダイアログについて尋ねることができます ツール→カスタマイズ カテゴリから 装置 追加。 関数 ：このコマンドは、ローカルファイルシステムにファイルを保存するための標準ダイアログを開きます。 xmlファイルの名前と場所を定義できます。 CODESYS デバイスツリーで現在選択されているsercosマスターの構成データを保存する必要があります。これは、外部のsercosスタックを操作するために必要になる場合があります。 電話 ：デバイスツリー内のsercosマスターデバイスオブジェクトのコンテキストメニュー " }, 
{ "title" : "コマンド：デバイスを無効にする-デバイスを有効にする ", 
"url" : "_cds_cmd_disable_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：デバイスを無効にする-デバイスを有効にする ", 
"snippet" : "デバイスを無効にし、デバイスを有効にします 関数 ：コマンドは、バスシステム内のデバイスのアクティブ状態と非アクティブ状態を切り替えます。 電話 ：デバイスツリー内のデバイスオブジェクトのコンテキストメニュー 要件 ：プロジェクトはオフラインモードです。バスドライバーは機能をサポートする必要があります。 非アクティブ化されたデバイスは無視され、アドレス指定されません。一部のバスシステムでは、ノードを非アクティブ化するとマスターが停止することに注意してください。 ツリー内の非アクティブ化されたデバイスのエントリは、薄い灰色のフォントで表示されます。ログインすると、非アクティブ化されたデバイスも赤...", 
"body" : "デバイスを無効にし、デバイスを有効にします 関数 ：コマンドは、バスシステム内のデバイスのアクティブ状態と非アクティブ状態を切り替えます。 電話 ：デバイスツリー内のデバイスオブジェクトのコンテキストメニュー 要件 ：プロジェクトはオフラインモードです。バスドライバーは機能をサポートする必要があります。 非アクティブ化されたデバイスは無視され、アドレス指定されません。一部のバスシステムでは、ノードを非アクティブ化するとマスターが停止することに注意してください。 ツリー内の非アクティブ化されたデバイスのエントリは、薄い灰色のフォントで表示されます。ログインすると、非アクティブ化されたデバイスも赤い三角形でマークされます マークされた。 " }, 
{ "title" : "コマンド：I \/ O画像を編集する ", 
"url" : "_cds_cmd_edit_io_mapping.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：I \/ O画像を編集する ", 
"snippet" : "I \/ O画像を編集する 関数 ：コマンドはビューを開きます I \/ O画像を編集する 。このビューには、現在選択されているデバイスオブジェクトのすべてのI \/ Oイメージ（「マッピング」）と、デバイスツリーのこのオブジェクトの下に接続されている他のすべてのデバイスオブジェクトのI \/ Oイメージが表示されます。 電話 ：デバイスツリー内のデバイスオブジェクトのコンテキストメニュー...", 
"body" : "I \/ O画像を編集する 関数 ：コマンドはビューを開きます I \/ O画像を編集する 。このビューには、現在選択されているデバイスオブジェクトのすべてのI \/ Oイメージ（「マッピング」）と、デバイスツリーのこのオブジェクトの下に接続されている他のすべてのデバイスオブジェクトのI \/ Oイメージが表示されます。 電話 ：デバイスツリー内のデバイスオブジェクトのコンテキストメニュー " }, 
{ "title" : "表示：I \/ O画像の編集 ", 
"url" : "_cds_cmd_edit_io_mapping.html#UUID-a0e8fdc8-841e-1079-dd03-c917fffbb646_id_a879c3411c826d0c0a8640e019cc157_id_e4690835796ca3e6c0a8640e002c9eba", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：I \/ O画像を編集する \/ 表示：I \/ O画像の編集 ", 
"snippet" : "このダイアログでは、ダイアログと同じ方法でI \/ O画像を編集できます。 I \/ Oマッピング 個々のデバイスエディタの。他のダイアログはそれに応じてすぐに更新されます。 求める マッピングテーブルで検索する文字列の入力フィールド 検索結果は黄色で強調表示されます。 フィルター マッピングテーブルに示されているI \/ O割り当てのフィルターを含む選択リスト すべて表示する 出力のみを表示 入力のみを表示 マップされていない変数のみを表示する マップされた変数のみを表示する 既存の変数へのマッピングのみを表示 新しい変数へのマッピングのみを表示する コンテキストメニューには、次のコマンドが含まれ...", 
"body" : "このダイアログでは、ダイアログと同じ方法でI \/ O画像を編集できます。 I \/ Oマッピング 個々のデバイスエディタの。他のダイアログはそれに応じてすぐに更新されます。 求める マッピングテーブルで検索する文字列の入力フィールド 検索結果は黄色で強調表示されます。 フィルター マッピングテーブルに示されているI \/ O割り当てのフィルターを含む選択リスト すべて表示する 出力のみを表示 入力のみを表示 マップされていない変数のみを表示する マップされた変数のみを表示する 既存の変数へのマッピングのみを表示 新しい変数へのマッピングのみを表示する コンテキストメニューには、次のコマンドが含まれています。 I \/ O画像をCSVにエクスポート ：デバイスとそのサブデバイスのマッピングを外部ファイルに保存するために使用されます これを行うには、デバイスツリーまたはマッピングリストでデバイスを選択します。 CSVからI \/ O画像をインポートする ：以前にエクスポートによって生成されたファイルからマッピングを挿入するために使用されます 詳細については、以下を参照してください。 I \/ Oリンクの構成" }, 
{ "title" : "コマンド：CSVからI \/ O画像をインポートする ", 
"url" : "_cds_cmd_import_io_mapping_csv.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：CSVからI \/ O画像をインポートする ", 
"snippet" : "CSVからI \/ O画像をインポートする 関数 ：このコマンドは、ローカルファイルシステムでファイルを開くための標準ダイアログを開きます。フィルタはファイル形式に基づいています csv コマンドで以前に作成されたファイルからデバイスのI \/ Oイメージ構成をインポートするように設定 I \/ O画像をCSVにエクスポート エクスポートされました。 CODESYS 選択したデバイスに構成を書き込みます。 電話 ：ビュー内のデバイスオブジェクトのコンテキストメニュー 装置 要件 ：I \/ Oマッピング構成のデバイスを含むプロジェクトが開いています。デバイスはエクスポートされたものと一致します csv...", 
"body" : "CSVからI \/ O画像をインポートする 関数 ：このコマンドは、ローカルファイルシステムでファイルを開くための標準ダイアログを開きます。フィルタはファイル形式に基づいています csv コマンドで以前に作成されたファイルからデバイスのI \/ Oイメージ構成をインポートするように設定 I \/ O画像をCSVにエクスポート エクスポートされました。 CODESYS 選択したデバイスに構成を書き込みます。 電話 ：ビュー内のデバイスオブジェクトのコンテキストメニュー 装置 要件 ：I \/ Oマッピング構成のデバイスを含むプロジェクトが開いています。デバイスはエクスポートされたものと一致します csv -ファイル。 I\/Oマッピング設定は以下に保存されます CSV Windows の地域設定でリスト区切り文字 (カンマまたはセミコロン) として定義された区切り文字を持つファイル。これらのファイルは手動で編集できます。ファイルを手動で編集する場合、正常にインポートするにはこの形式が保持されていることが不可欠です。 次の点に注意してください。ファイル内のエントリは、デバイス名（DeviceName）とチャネル名（パラメータ名）を介してデバイスのI \/ Oイメージに割り当てられます。このファイルでは、一意でないパラメータ名に連続した番号が付けられています @<n> 拡大しました。 にコンテンツがないフィールド csv インポート中、ファイルは無視されます。インポートによってI \/ Oイメージの既存のエントリを削除するには、に関連するフィールドを入力する必要があります。 csv -ファイルにスペースを挿入します。 詳細については、以下を参照してください。 デバイスとI \/ Oマッピングの構成" }, 
{ "title" : "コマンド：I \/ O画像をCSVにエクスポート ", 
"url" : "_cds_cmd_export_io_mapping_csv.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：I \/ O画像をCSVにエクスポート ", 
"snippet" : "I \/ O画像をCSVにエクスポート 関数 : このコマンドは、ローカルファイルシステムにファイルを保存するためのデフォルトのダイアログを開きます。フィルターは次のように設定されています。 CSV ファイル形式。名前と保存場所を指定したら、 CODESYS I\/Oマッピング設定を CSV Windows の地域設定でリスト区切り文字 (カンマまたはセミコロン) として定義された区切り文字を含むファイル。 電話 ：ビュー内のデバイスオブジェクトのコンテキストメニュー 装置 要件 ：デバイスツリーで、I \/ Oマッピング構成のデバイスオブジェクトが選択されています。 このファイルでは、一意でないパ...", 
"body" : "I \/ O画像をCSVにエクスポート 関数 : このコマンドは、ローカルファイルシステムにファイルを保存するためのデフォルトのダイアログを開きます。フィルターは次のように設定されています。 CSV ファイル形式。名前と保存場所を指定したら、 CODESYS I\/Oマッピング設定を CSV Windows の地域設定でリスト区切り文字 (カンマまたはセミコロン) として定義された区切り文字を含むファイル。 電話 ：ビュー内のデバイスオブジェクトのコンテキストメニュー 装置 要件 ：デバイスツリーで、I \/ Oマッピング構成のデバイスオブジェクトが選択されています。 このファイルでは、一意でないパラメータ名に連続した番号が付けられています @<n> 拡大しました。 詳細については、以下を参照してください。 デバイスとI \/ Oマッピングの構成" }, 
{ "title" : "コマンド：PLCパラメータファイルを設定に読み込みます ", 
"url" : "_cds_cmd_read_plc_parameter_file_to_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：PLCパラメータファイルを設定に読み込みます ", 
"snippet" : "PLCパラメータファイルを設定に読み込みます 関数 ：コマンドは構成ファイルを読み取ります IoConfig.par PLCから取得し、プロジェクトに値を保存します。このようなファイルは、PLCのパラメータが別のデバイスによって、たとえば視覚化によって変更された場合に作成されます。次に、これらのパラメータはPLCのメモリでのみ変更され、プロジェクトの構成では変更されません。 電話 ：PLCデバイスオブジェクトのコンテキストメニュー 要件 ：あなたはダイアログの指揮を執っています ツール→カスタマイズ ユーザーインターフェイスで利用できるようになりました。 詳細については、以下を参照してください...", 
"body" : "PLCパラメータファイルを設定に読み込みます 関数 ：コマンドは構成ファイルを読み取ります IoConfig.par PLCから取得し、プロジェクトに値を保存します。このようなファイルは、PLCのパラメータが別のデバイスによって、たとえば視覚化によって変更された場合に作成されます。次に、これらのパラメータはPLCのメモリでのみ変更され、プロジェクトの構成では変更されません。 電話 ：PLCデバイスオブジェクトのコンテキストメニュー 要件 ：あなたはダイアログの指揮を執っています ツール→カスタマイズ ユーザーインターフェイスで利用できるようになりました。 詳細については、以下を参照してください。 PLCパラメータファイルを設定に読み込みます " }, 
{ "title" : "コマンド：オンラインコンフィギュレーションモード ", 
"url" : "_cds_cmd_online_configuration_mode.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：オンラインコンフィギュレーションモード ", 
"snippet" : "オンライン構成操作 関数 ：このコマンドは、オンライン構成モードのオンとオフを切り替えるために使用されます。オンにすると、PLCへの接続が確立され、暗黙的に作成されたアプリケーションがそこにロードされます。 HiddenOnlineConfigModeApp 。デバイスによって異なります CODESYS シンプルなオンライン設定モードに切り替えるか、シンプルなオンライン設定モードと高度なオンライン設定モードを選択するためのダイアログが表示されます。 電話 ：デバイスツリー内のPLCオブジェクトのコンテキストメニュー 要件 ：PLC機器の通信設定が正しく設定されている。 簡単なオンライン構成操作...", 
"body" : "オンライン構成操作 関数 ：このコマンドは、オンライン構成モードのオンとオフを切り替えるために使用されます。オンにすると、PLCへの接続が確立され、暗黙的に作成されたアプリケーションがそこにロードされます。 HiddenOnlineConfigModeApp 。デバイスによって異なります CODESYS シンプルなオンライン設定モードに切り替えるか、シンプルなオンライン設定モードと高度なオンライン設定モードを選択するためのダイアログが表示されます。 電話 ：デバイスツリー内のPLCオブジェクトのコンテキストメニュー 要件 ：PLC機器の通信設定が正しく設定されている。 簡単なオンライン構成操作 コマンドは暗黙のアプリケーションを作成します HiddenOnlineConfigModeApp そしてそれをコントローラーにアップロードします。アプリケーションは、コントローラーのすべての入力と出力を1回自動的に初期化します。その後、次のようにI \/ Oにアクセスできます。 I \/ Oを読む 出力を書き込む 診断（デバイスツリーおよびタブ 状態 デバイスエディタの） （現在のハードウェアの）スキャン 利用可能な場合のオンラインインタラクティブ機能（非同期メッセージの作成など） 拡張オンライン設定モード（パラメータモード） PLCにすでにアプリケーションがあり、コントローラがそれらをサポートしている場合、コマンドは最初にダイアログを開きます 装置 、コントローラにアプリケーションを表示します。ボタンを使用してこのダイアログを終了できます パラメータ操作 PLCに接続してから、実際のアプリケーションでログインしなくても、デバイスパラメータの値にアクセスします。 I \/ Oイメージへの書き込みと強制 タブへの値の書き込みと強制は、オンライン構成モードで機能します I \/ Oマッピング 実際のオンライン操作とは異なります。出力は、挿入された直後にテーブルに書き込まれます。列はありません 準備された価値 、ただし、列をダブルクリックした後、初期値に直接アクセスできます 現在の価値 変更されます。 " }, 
{ "title" : "ダイアログ：構成モードを選択 ", 
"url" : "_cds_cmd_online_configuration_mode.html#UUID-91bcb393-0216-c2c1-9344-e0347e485d28_id_ec211ca1ba0c0a8640e000c867a_id_ddb7ffbc9269d801c0a8640e000ce2e0", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 計画 \/ コマンド：オンラインコンフィギュレーションモード \/ ダイアログ：構成モードを選択 ", 
"snippet" : "コマンドの後にダイアログが表示されます オンライン構成操作 、デバイスが拡張オンラインコンフィギュレーションモードをサポートし、実際のアプリケーションがすでにコントローラ上にある場合。 パラメータ操作 プロジェクトのコントローラー構成は、デバイスのコントローラー構成と比較されます。それらが一致する場合、ビルド CODESYS PLCへの接続を確立します。単純なオンライン構成モードとは対照的に、パラメーターを読み取り、ドライバーでサポートされている場合は汎用デバイスエディターで書き込むことができます。この場合、デバイスにすでにロードされているアプリケーションは変更されません。 構成操作 CODE...", 
"body" : "コマンドの後にダイアログが表示されます オンライン構成操作 、デバイスが拡張オンラインコンフィギュレーションモードをサポートし、実際のアプリケーションがすでにコントローラ上にある場合。 パラメータ操作 プロジェクトのコントローラー構成は、デバイスのコントローラー構成と比較されます。それらが一致する場合、ビルド CODESYS PLCへの接続を確立します。単純なオンライン構成モードとは対照的に、パラメーターを読み取り、ドライバーでサポートされている場合は汎用デバイスエディターで書き込むことができます。この場合、デバイスにすでにロードされているアプリケーションは変更されません。 構成操作 CODESYS 「シンプルオンライン設定モード」に切り替わります。 詳細については、次を参照してください。 オンライン設定モードコマンド " }, 
{ "title" : "作成 ", 
"url" : "_cds_f_commands_build.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 作成 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド：コードを生成する ", 
"url" : "_cds_cmd_generate_code.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 作成 \/ コマンド：コードを生成する ", 
"snippet" : "コードを生成する シンボル： キーボードショートカット： F11 関数 ：このコマンドは、アクティブなアプリケーションのコード生成を開始します。 電話 ：メニュー 作成 このコマンドでコードを生成すると、アプリケーションをコントローラーにロードするときと同じようにコードが生成されます。ただし、コードはコントローラーに転送されません。ソースコードのさらなるテストが実行されます。これにより、コンパイラで認識されないエラーがないかコードをチェックし、オンラインで使用する前に修正することができます。 詳細については、以下を参照してください。 アプリケーションコードの生成...", 
"body" : "コードを生成する シンボル： キーボードショートカット： F11 関数 ：このコマンドは、アクティブなアプリケーションのコード生成を開始します。 電話 ：メニュー 作成 このコマンドでコードを生成すると、アプリケーションをコントローラーにロードするときと同じようにコードが生成されます。ただし、コードはコントローラーに転送されません。ソースコードのさらなるテストが実行されます。これにより、コンパイラで認識されないエラーがないかコードをチェックし、オンラインで使用する前に修正することができます。 詳細については、以下を参照してください。 アプリケーションコードの生成" }, 
{ "title" : "コマンド：クリーン ", 
"url" : "_cds_cmd_clean.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 作成 \/ コマンド：クリーン ", 
"snippet" : "掃除 関数 ：このコマンドは、現在アクティブなアプリケーションの翻訳情報を削除します。 電話 ：メニュー 作成 コンパイル情報は、アプリケーションが最後にダウンロードされてファイル（* .compileinfo）に保存されたときに作成されました。 クリーンアッププロセスの後、影響を受けるアプリケーションのオンライン変更はできなくなります。アプリケーションをコントローラーに完全にリロードする必要があります。 詳細については、以下を参照してください。 すべてをきれいにする...", 
"body" : "掃除 関数 ：このコマンドは、現在アクティブなアプリケーションの翻訳情報を削除します。 電話 ：メニュー 作成 コンパイル情報は、アプリケーションが最後にダウンロードされてファイル（* .compileinfo）に保存されたときに作成されました。 クリーンアッププロセスの後、影響を受けるアプリケーションのオンライン変更はできなくなります。アプリケーションをコントローラーに完全にリロードする必要があります。 詳細については、以下を参照してください。 すべてをきれいにする" }, 
{ "title" : "コマンド：すべてをクリーンアップ ", 
"url" : "_cds_cmd_clean_all.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 作成 \/ コマンド：すべてをクリーンアップ ", 
"snippet" : "すべてをきれいにする 関数 ：このコマンドは、プロジェクト内のすべてのアプリケーションの翻訳情報を削除します。 電話 ：メニュー 作成 翻訳情報は、アプリケーションが最後にダウンロードされてファイル（* .compileinfo）に保存されたときにローカルファイルシステムで作成されました。 このコマンドは、再度ログインする前にダウンロードを実行する必要があることを意味します。オンラインでの変更はできなくなりました。コマンドとは異なり 掃除 （アクティブなアプリケーションのみ）が生成されます CODESYS すべてのオブジェクトの言語モデル。これには追加の時間がかかります。 コマンドを使用する必...", 
"body" : "すべてをきれいにする 関数 ：このコマンドは、プロジェクト内のすべてのアプリケーションの翻訳情報を削除します。 電話 ：メニュー 作成 翻訳情報は、アプリケーションが最後にダウンロードされてファイル（* .compileinfo）に保存されたときにローカルファイルシステムで作成されました。 このコマンドは、再度ログインする前にダウンロードを実行する必要があることを意味します。オンラインでの変更はできなくなりました。コマンドとは異なり 掃除 （アクティブなアプリケーションのみ）が生成されます CODESYS すべてのオブジェクトの言語モデル。これには追加の時間がかかります。 コマンドを使用する必要があるかどうかを慎重に検討してください。アクティブなアプリケーションを再コンパイルしてダウンロードするだけの場合は、次のコマンドを使用します 掃除 。 " }, 
{ "title" : "コマンド：翻訳 ", 
"url" : "_cds_cmd_build.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 作成 \/ コマンド：翻訳 ", 
"snippet" : "翻訳すること 関数 ：このコマンドは、現在アクティブなアプリケーションの変換プロセスを開始します。 電話 ：このコマンドは、デフォルトではどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから 翻訳すること メニューに貼り付けます。 翻訳のリード CODESYS アプリケーションのすべてのオブジェクトの構文チェック。ただし、ターゲットシステムにログオンしたり、アプリケーションをダウンロードしたりする場合のように、プロセスでコードは生成されません。変更したプログラムでログインする場合、コンパイルプロセスは常に自動的に実行されま...", 
"body" : "翻訳すること 関数 ：このコマンドは、現在アクティブなアプリケーションの変換プロセスを開始します。 電話 ：このコマンドは、デフォルトではどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから 翻訳すること メニューに貼り付けます。 翻訳のリード CODESYS アプリケーションのすべてのオブジェクトの構文チェック。ただし、ターゲットシステムにログオンしたり、アプリケーションをダウンロードしたりする場合のように、プロセスでコードは生成されません。変更したプログラムでログインする場合、コンパイルプロセスは常に自動的に実行されます。 検証ショーを完了した後 CODESYS カテゴリの下のメッセージウィンドウのエラーメッセージまたは警告 翻訳すること の上。 最後のエラーのないコンパイルプロセス以降にプログラムが変更されていない場合、プログラムは再コンパイルされません。 「アプリケーションは最新です」というメッセージが表示されます。それでも構文チェックを繰り返したい場合は、コマンドを使用する必要があります 再翻訳 使用する。 " }, 
{ "title" : "コマンド：再コンパイル ", 
"url" : "_cds_cmd_rebuild.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 作成 \/ コマンド：再コンパイル ", 
"snippet" : "再翻訳 関数 : このコマンドは、最後のビルドにエラーが含まれていなかった場合でも、アクティブなアプリケーションのビルド操作を開始します。 電話 ：このコマンドは、デフォルトではどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから 翻訳すること メニューに貼り付けます。 詳細については、以下を参照してください。 翻訳すること...", 
"body" : "再翻訳 関数 : このコマンドは、最後のビルドにエラーが含まれていなかった場合でも、アクティブなアプリケーションのビルド操作を開始します。 電話 ：このコマンドは、デフォルトではどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから 翻訳すること メニューに貼り付けます。 詳細については、以下を参照してください。 翻訳すること" }, 
{ "title" : "コマンド：ランタイムシステムファイルを生成する ", 
"url" : "_cds_cmd_generate_runtime_system_files.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 作成 \/ コマンド：ランタイムシステムファイルを生成する ", 
"snippet" : "ランタイムシステムファイルを生成する 関数 ：このコマンドは、現在のライブラリプロジェクトからCフレームファイルとインターフェイスファイルをM4ファイル形式で生成します。これらのファイルは、外部ライブラリファイルを作成するための基礎として機能します。 電話 ：メニュー 作成 要件 ：ライブラリプロジェクトが開いています。 コマンドはダイアログを開きます ランタイムシステムファイルを生成する 。 出力ディレクトリ ディレクトリがあります CODESYS ランタイムシステムファイルを作成します ボタンについて ファイルシステムを参照するための標準ダイアログを開くことができます。 コンポーネント名 ...", 
"body" : "ランタイムシステムファイルを生成する 関数 ：このコマンドは、現在のライブラリプロジェクトからCフレームファイルとインターフェイスファイルをM4ファイル形式で生成します。これらのファイルは、外部ライブラリファイルを作成するための基礎として機能します。 電話 ：メニュー 作成 要件 ：ライブラリプロジェクトが開いています。 コマンドはダイアログを開きます ランタイムシステムファイルを生成する 。 出力ディレクトリ ディレクトリがあります CODESYS ランタイムシステムファイルを作成します ボタンについて ファイルシステムを参照するための標準ダイアログを開くことができます。 コンポーネント名 ライブラリプロジェクト名 どのファイルを作成しますか? M4インターフェースファイル ：インターフェースファイル <projectname>Itf.m4 定義付き M4 エクスポートでサポートされている IEC コード構造については、以下の表も参照してください。 M4 ファイルの例: Cスタブファイル ：Cでライブラリをプログラミングするためのフレームファイル スタブファイルの例： オプション ライブラリに含まれる参照型をエクスポートする : 参照された型はエクスポートに含まれます。 元のタイプ名を使用する : ライブラリ プロジェクトの型名が使用されます。 " }, 
{ "title" : "M4エクスポートでサポートされているIEC構造 ", 
"url" : "_cds_cmd_generate_runtime_system_files.html#UUID-4294143b-f9fb-2ec4-7378-d8337c13d93c_section-idm234462007759195", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 作成 \/ コマンド：ランタイムシステムファイルを生成する \/ M4エクスポートでサポートされているIEC構造 ", 
"snippet" : "表に明示的に記載されていないすべてのタイプはサポートされていません。それらの動作は気付かないうちに変更される可能性があります。 IECの構成と言語手段 M4ファイルにエクスポート 注記 PROGRAM サポートされていません FUNCTION_BLOCK struct すべての入力\/出力\/入出力\/ローカル変数を含む さらに、 <fb_name>__main の実装のために作成されました FUNCTION_BLOCK 。 FUNCTION STRUCT すべての入力\/出力\/入出力\/ローカル変数と DEF_API マクロ INTERFACE struct 単一のインスタンスポインターで METHO...", 
"body" : "表に明示的に記載されていないすべてのタイプはサポートされていません。それらの動作は気付かないうちに変更される可能性があります。 IECの構成と言語手段 M4ファイルにエクスポート 注記 PROGRAM サポートされていません FUNCTION_BLOCK struct すべての入力\/出力\/入出力\/ローカル変数を含む さらに、 <fb_name>__main の実装のために作成されました FUNCTION_BLOCK 。 FUNCTION STRUCT すべての入力\/出力\/入出力\/ローカル変数と DEF_API マクロ INTERFACE struct 単一のインスタンスポインターで METHOD 同じ FUNCTION 、名前 <fb_name>__<method_name> 、これはポインタを使用して <fb_name> 追加入力として ACTION 同じ METHOD TRANSITION 同じ METHOD 、名前 get<transition_name> PROPERTY メソッドペアの名前 get<prop_name> そして set<prop_name> GVL サポートされていません UNION C-union ENUM #define 各列挙コンポーネントについて ALIAS サポートされていません STRUCT C-struct 継承がサポートされています。コンポーネントは「フラット」に（構造なしで）エクスポートされます。 CONSTANT #define 各定数について 定数は明示的にエクスポートすることはできませんが、他のオブジェクトで使用されている場合は自動的にエクスポートされます。 コメント Cコメント 3 つのスラッシュを含むコメントもエクスポートされます。 定義済みのデータ型 (INT、BOOL、REAL など) 同じサイズの対応するCデータ型 で始まるタイプ RTS_IEC ランタイムシステムの他の場所で宣言されているため、個別にエクスポートされません。 ANY 種類 struct __SYSTEM.AnyType 全て ANY 種類（例： ANY_INT 、 ANY_BIT など）はC型にエクスポートされます struct __SYSTEM.AnyType 。 配列 固定サイズのC配列 任意の次元数 配列の面積は負の値になることがあります。 ARRAY[*] 1つのポインタと1つのサイズ 文字列 固定サイズの文字のC配列 " }, 
{ "title" : "コマンド：すべてのプールオブジェクトを確認してください ", 
"url" : "_cds_cmd_check_all_pool_objects.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 作成 \/ コマンド：すべてのプールオブジェクトを確認してください ", 
"snippet" : "すべてのプールオブジェクトを確認してください シンボル： キーボードショートカット： F11 関数 ：このコマンドは、POUビューで管理されているため、プロジェクト全体で使用できるすべてのプールオブジェクトに対して、変換の実行、つまり構文チェックを開始します。これは主にライブラリを作成するときに役立ちます。 電話 ：メニュー 作成 要件 ：ライブラリプロジェクトが開いています。 このコマンドはコード生成にはつながりません。また、コンパイル実行に関する情報を含むファイルはプロジェクトディレクトリに作成されません。...", 
"body" : "すべてのプールオブジェクトを確認してください シンボル： キーボードショートカット： F11 関数 ：このコマンドは、POUビューで管理されているため、プロジェクト全体で使用できるすべてのプールオブジェクトに対して、変換の実行、つまり構文チェックを開始します。これは主にライブラリを作成するときに役立ちます。 電話 ：メニュー 作成 要件 ：ライブラリプロジェクトが開いています。 このコマンドはコード生成にはつながりません。また、コンパイル実行に関する情報を含むファイルはプロジェクトディレクトリに作成されません。 " }, 
{ "title" : "コマンド：アクティブなアプリケーションのコードを生成します ", 
"url" : "_cds_cmd_generate_code_for_active_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 作成 \/ コマンド：アクティブなアプリケーションのコードを生成します ", 
"snippet" : "アクティブなアプリケーションのコードを生成する 関数 ：このコマンドは、ライブラリプロジェクトを適用するためのコードを生成します。 電話 ：メニュー 作成 要件 ：プロジェクトにはアプリケーションが含まれています。 図書館プロジェクトが開かれています。 ライブラリプロジェクトにはアプリケーションが含まれています。 このコマンドでコードを生成すると、アプリケーションをコントローラーにロードするときと同じようにコードが生成されます。ただし、コードはコントローラーに転送されません。ソースコードのさらなるテストが実行されます。これにより、コンパイラで認識されないエラーがないかコードをチェックし、オンラ...", 
"body" : "アクティブなアプリケーションのコードを生成する 関数 ：このコマンドは、ライブラリプロジェクトを適用するためのコードを生成します。 電話 ：メニュー 作成 要件 ：プロジェクトにはアプリケーションが含まれています。 図書館プロジェクトが開かれています。 ライブラリプロジェクトにはアプリケーションが含まれています。 このコマンドでコードを生成すると、アプリケーションをコントローラーにロードするときと同じようにコードが生成されます。ただし、コードはコントローラーに転送されません。ソースコードのさらなるテストが実行されます。これにより、コンパイラで認識されないエラーがないかコードをチェックし、オンラインで使用する前に修正することができます。 詳細については、以下を参照してください。 ランタイムシステムファイルを生成する" }, 
{ "title" : "コマンド：すべてのアプリケーションオブジェクトを確認してください ", 
"url" : "_cds_cmd_check_all_application_objects.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 作成 \/ コマンド：すべてのアプリケーションオブジェクトを確認してください ", 
"snippet" : "すべてのアプリケーションオブジェクトを確認してください 関数 ：このコマンドは、アクティブなアプリケーションのすべてのオブジェクト、つまりアプリケーションで使用されていないPOUに対しても変換の実行を開始します。コンパイルの実行後、未使用のオブジェクトで見つかったエラーもメッセージウィンドウに表示されます。 電話 ：このコマンドは、デフォルトではどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから 翻訳すること メニューに貼り付けます。 要件 ：開いているプロジェクトのアプリケーションがアクティブです。 このコマンドはコー...", 
"body" : "すべてのアプリケーションオブジェクトを確認してください 関数 ：このコマンドは、アクティブなアプリケーションのすべてのオブジェクト、つまりアプリケーションで使用されていないPOUに対しても変換の実行を開始します。コンパイルの実行後、未使用のオブジェクトで見つかったエラーもメッセージウィンドウに表示されます。 電話 ：このコマンドは、デフォルトではどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから 翻訳すること メニューに貼り付けます。 要件 ：開いているプロジェクトのアプリケーションがアクティブです。 このコマンドはコード生成にはつながりません。また、コンパイル実行に関する情報を含むファイルはプロジェクトディレクトリに作成されません。 " }, 
{ "title" : "コマンド：ライブラリの互換性を確認する ", 
"url" : "_cds_cmd_check_library_compatibility.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 作成 \/ コマンド：ライブラリの互換性を確認する ", 
"snippet" : "ライブラリの互換性を確認する 関数 ：このコマンドは、現在開いているライブラリプロジェクトが、このライブラリの最後にインストールされたバージョン（次に小さいバージョン番号）と互換性があるかどうかのチェックを開始します。 電話 ：このコマンドは、デフォルトではどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから 翻訳すること メニューに貼り付けます。 要件 ：ライブラリプロジェクトが開いています。 このチェックでは、メソッドの実装されたインターフェース（インターフェース）の違いを探します。チェック後、次の場合にエラーメッセー...", 
"body" : "ライブラリの互換性を確認する 関数 ：このコマンドは、現在開いているライブラリプロジェクトが、このライブラリの最後にインストールされたバージョン（次に小さいバージョン番号）と互換性があるかどうかのチェックを開始します。 電話 ：このコマンドは、デフォルトではどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから 翻訳すること メニューに貼り付けます。 要件 ：ライブラリプロジェクトが開いています。 このチェックでは、メソッドの実装されたインターフェース（インターフェース）の違いを探します。チェック後、次の場合にエラーメッセージがメッセージウィンドウに表示されます。 ファンクションブロック、関数、またはメソッドの入力または出力の追加または削除 入力または出力のデータ型を変更する メソッドの実装されたインターフェース（インターフェース）の変更 詳細については、以下を参照してください。 ライブラリ開発者向けの情報" }, 
{ "title" : "コマンド：分解ファイルを生成します ", 
"url" : "_cds_cmd_generate_disassembly_file.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 作成 \/ コマンド：分解ファイルを生成します ", 
"snippet" : "分解ファイルを生成する 関数 ：コマンドは、現在のプロジェクトから分解ファイルを作成します <project name>.asm プロジェクトフォルダのファイルディレクトリに保存します。 電話 ：このコマンドは、デフォルトではどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→ 調整 コマンドカテゴリから 翻訳すること メニューに貼り付けます。...", 
"body" : "分解ファイルを生成する 関数 ：コマンドは、現在のプロジェクトから分解ファイルを作成します <project name>.asm プロジェクトフォルダのファイルディレクトリに保存します。 電話 ：このコマンドは、デフォルトではどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→ 調整 コマンドカテゴリから 翻訳すること メニューに貼り付けます。 " }, 
{ "title" : "オンライン ", 
"url" : "_cds_f_commands_online.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド：アクティブなアプリケーションを選択します ", 
"url" : "_cds_cmd_active_app_selector.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：アクティブなアプリケーションを選択します ", 
"snippet" : "アクティブなアプリケーションを選択します シンボル： このコマンドは、アプリケーションをアクティブ化できる選択リストとして実装されます。デフォルトでは、選択リストはツールバーにあります。 関数 ：選択リストには、現在アクティブなアプリケーションとそのデバイスパスが表示されます。 電話 ：選択リストには、ビューの下にあるすべてのアプリケーションが含まれます 装置 配置されています。選択リストのエントリをクリックすると、選択したアプリケーションがアクティブになります。 要件 ：プロジェクトにはいくつかのアプリケーションがあります。 例 メニューコマンドを使用する場合 作成 また オンライン を呼び...", 
"body" : "アクティブなアプリケーションを選択します シンボル： このコマンドは、アプリケーションをアクティブ化できる選択リストとして実装されます。デフォルトでは、選択リストはツールバーにあります。 関数 ：選択リストには、現在アクティブなアプリケーションとそのデバイスパスが表示されます。 電話 ：選択リストには、ビューの下にあるすべてのアプリケーションが含まれます 装置 配置されています。選択リストのエントリをクリックすると、選択したアプリケーションがアクティブになります。 要件 ：プロジェクトにはいくつかのアプリケーションがあります。 例 メニューコマンドを使用する場合 作成 また オンライン を呼び出すと、これらのコマンドはアクティブなアプリケーションに作用します。これは選択リストに表示され、デバイスツリーに太字で表示されます。これは主にコマンドに影響します ビルド→コードの生成 と オンライン→ログイン 。 これらのコマンドには、選択リストも含まれているツールバーのコマンドアイコンからアクセスすることもできます。コマンドアイコンが呼び出されると、アクティブなアプリケーションにも影響します。 ただし、デバイスオブジェクトのコンテキストメニューを介してデバイスツリーでコマンドを呼び出すと、そのコマンドは関連するオブジェクトに影響します。たとえば、Iconを呼び出すことによって アクティブではないデバイス上のアプリケーションへの接続を確立します。 " }, 
{ "title" : "コマンド：ログイン ", 
"url" : "_cds_cmd_login.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：ログイン ", 
"snippet" : "ログインする シンボル： キーボードショートカット： 年 + F8 関数 ：このコマンドは、アプリケーションをターゲットシステム（コントローラーまたはシミュレートされたデバイス）に接続し、オンライン操作を確立します。 電話 ：メニュー オンライン 、オブジェクトのコンテキストメニュー 応用 要件 ：アプリケーションにエラーがなく、通信設定が構成されています。 通信設定が正しくない場合は、ダイアログが表示されます。その後、直接行くことができます 通信設定 コントローラを変更します。 あなたが命令した場合 ログインする オンラインメニューから、現在アクティブなアプリケーションがターゲットシステムに...", 
"body" : "ログインする シンボル： キーボードショートカット： 年 + F8 関数 ：このコマンドは、アプリケーションをターゲットシステム（コントローラーまたはシミュレートされたデバイス）に接続し、オンライン操作を確立します。 電話 ：メニュー オンライン 、オブジェクトのコンテキストメニュー 応用 要件 ：アプリケーションにエラーがなく、通信設定が構成されています。 通信設定が正しくない場合は、ダイアログが表示されます。その後、直接行くことができます 通信設定 コントローラを変更します。 あなたが命令した場合 ログインする オンラインメニューから、現在アクティブなアプリケーションがターゲットシステムに接続されます。コンテキストメニューからコマンドを呼び出し、デバイスツリーでアプリケーションを選択した場合、このアプリケーションは、「アクティブなアプリケーション」として設定されていなくても、ログインに使用されます。 ターゲットデバイスでオンラインユーザー管理が設定されている場合、ログイン時にユーザーデータを入力するように求められます。このためのダイアログが表示されます デバイスユーザーログイン 。 制御するアクセスオプションを確認してください いかなる状況においても、インターネットや信頼できないネットワークからコントロールにアクセスしてはなりません。特に、コントローラーのプログラミングポートは、いかなる状況でもインターネットから保護されてはなりません（通常、UDPポート1740..1743およびTCPポート1217 + 11740またはコントローラー固有のポート）。ただし、インターネットからのアクセスを有効にする必要がある場合は、コントローラーに接続するために安全な方法を選択する必要があります（VPNなど）。 詳細については、以下を参照してください。 デバイスユーザー管理の処理安全コントローラがコントローラの下に取り付けられている場合、このコマンドは通信リンクを使用できます 一時的 割り込み！ 安全コントローラのその他の安全コントローラへの接続（安全ネットワーク変数を介して）、フィールドデバイス、および開発システムへの接続が影響を受けます。安全フィールドデバイスまたは他の安全コントローラは、反応として安全状態に入る可能性があります。開発システムへの接続は、セーフティコントローラがフィールドバスを介してメインコントローラに接続されている場合にのみ影響を受けます。 詳細については、「従属安全管理」の章を参照してください。 ログイン時に起こりうる状況 デバイスの説明の新しいバージョンは、プロジェクトよりもコントローラーで利用できます。プロセスをキャンセルするオプションを含む警告が表示されます。 アプリケーションはまだコントローラーに存在しません。ダウンロードの確認を求められます。 アプリケーションはすでにコントローラー上にあり、最後にロードされてから変更されていません。ログインは、それ以上の操作なしで行われます。 アプリケーションはすでにコントローラー上にありますが、最後のダウンロード以降に変更されています。 次のいずれかのオプションを選択するように求められます。 オンライン変更でログインします（「コマンド」のオンライン変更に関する情報に注意してください オンライン変更 \"） ダウンロードしてログイン 変更せずにログインする この時点で、コントローラーのブートアプリケーションを更新するオプションもあります。 不明なバージョンのアプリケーションがすでにコントローラー上にあります。かどうか尋ねられます CODESYS これを交換します。 アプリケーションのバージョンはすでにコントローラー上にあり、実行されています。かどうか尋ねられます CODESYS とにかくログインして、現在実行中のアプリケーションを上書きします。 コントローラ上のアプリケーションは現在、ブレークポイントで停止しています。ログアウトしてプログラムを変更しました。 CODESYS オンラインでの変更またはダウンロードの場合、PLCは完全に停止することを警告します。これは、複数のタスクがあり、1つだけがブレークポイントの影響を受ける場合にも発生します。 ボタン付き 詳細 上記のダイアログで、ダイアログを開きます アプリケーション情報 。 から CODESYS -バージョンV3.5SP17は、コントローラーのアプリケーションで1つだけにすることができます CODESYS ログインするインスタンス。秒の場合 CODESYS 同じコントローラの同じアプリケーションのインスタンスでは、エラーメッセージが表示されます。 詳細については、以下を参照してください。 オンライン変更 と 従属安全コントローラ" }, 
{ "title" : "ダイアログ：アプリケーション情報（詳細） ", 
"url" : "_cds_cmd_login.html#UUID-51a355d9-96c3-eb5c-5f83-080a64d34b57_id_f7339dad366f5b2ec0a8640e002c9fcf_id_afdfe799069d6517c0a8640e01ead196", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：ログイン \/ ダイアログ：アプリケーション情報（詳細） ", 
"snippet" : "ダイアログには、現在コントローラー上にある以前のバージョンと比較して、プログラミングシステムで変更されたアプリケーションに関する情報が表示されます。 2つのタブがあります： アプリケーション情報 ：のアプリケーションプロパティ IDEでのアプリケーション （統合開発環境=プログラミングシステム）は PLCでのアプリケーション 比較：プロジェクト名、最終変更、IDEバージョン、作成者、説明。さらにショー CODESYS は、最後のダウンロード以降に変更されたオブジェクトを示しています。 アプリケーションコンテンツ ：オプションの場合 アプリケーション情報をダウンロードする をアクティブにすると、...", 
"body" : "ダイアログには、現在コントローラー上にある以前のバージョンと比較して、プログラミングシステムで変更されたアプリケーションに関する情報が表示されます。 2つのタブがあります： アプリケーション情報 ：のアプリケーションプロパティ IDEでのアプリケーション （統合開発環境=プログラミングシステム）は PLCでのアプリケーション 比較：プロジェクト名、最終変更、IDEバージョン、作成者、説明。さらにショー CODESYS は、最後のダウンロード以降に変更されたオブジェクトを示しています。 アプリケーションコンテンツ ：オプションの場合 アプリケーション情報をダウンロードする をアクティブにすると、PLC（2）のアプリケーションの内容をプログラミングシステム（1）のアプリケーションの内容と比較できます。オプション アプリケーション情報をダウンロードする アプリケーションのプロパティ、カテゴリで見つけることができます 翻訳すること 。 プログラミングシステムのコードが最新でない場合、コマンドは左下に表示されます アプリケーションが最新ではありません。今すぐコードを再生成しますか？ （3）。このコマンドを実行して、アプリケーションのソースコードを更新します。 この詳細情報は、現在の状況でのログインの影響をより適切に評価し、新しいアプリケーションのダウンロードについて決定するのに役立ちます。 比較は、タブのデバイスエディタにも表示されます アプリケーション ボタン経由 コンテンツ 示されています。 " }, 
{ "title" : "PLC上の不明なアプリケーション ", 
"url" : "_cds_cmd_login.html#UUID-51a355d9-96c3-eb5c-5f83-080a64d34b57_id_f7339dad366f5b2ec0a8640e002c9fcf_id_67cd7a3e1e8ebbd7c0a8640e00b8388e", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：ログイン \/ PLC上の不明なアプリケーション ", 
"snippet" : "プロジェクトに含まれていないアプリケーションがコントローラー上にすでに1つ以上ある場合は、を開きます CODESYS これらのアプリケーションのリストを含むダイアログ。現在のアプリケーションをロードする前に、PLCからアプリケーションを削除するかどうか、およびどのアプリケーションを削除するかを指定できます。これは、コントローラー上にあるが、その後プロジェクトから削除された子アプリケーションにも適用されます。...", 
"body" : "プロジェクトに含まれていないアプリケーションがコントローラー上にすでに1つ以上ある場合は、を開きます CODESYS これらのアプリケーションのリストを含むダイアログ。現在のアプリケーションをロードする前に、PLCからアプリケーションを削除するかどうか、およびどのアプリケーションを削除するかを指定できます。これは、コントローラー上にあるが、その後プロジェクトから削除された子アプリケーションにも適用されます。 " }, 
{ "title" : "ログインする前にプロジェクトをコンパイルする ", 
"url" : "_cds_cmd_login.html#UUID-51a355d9-96c3-eb5c-5f83-080a64d34b57_id_f7339dad366f5b2ec0a8640e002c9fcf_id_e30afcf16bc19572c0a8640e014e4835", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：ログイン \/ ログインする前にプロジェクトをコンパイルする ", 
"snippet" : "アプリケーションプロジェクトが最後に変更されてからまだコンパイルされていない場合は、コンパイルされます CODESYS ログインする前にプロジェクト。この操作はコマンドに対応します コードを生成する ログアウト状態です。 コンパイル中にエラーが発生した場合は、メッセージダイアログが表示されます。エラーは、カテゴリのメッセージウィンドウに一覧表示されます 翻訳すること 発行済み。次に、プログラムをコントローラーにロードせずにログインするかどうかを決定できます。...", 
"body" : "アプリケーションプロジェクトが最後に変更されてからまだコンパイルされていない場合は、コンパイルされます CODESYS ログインする前にプロジェクト。この操作はコマンドに対応します コードを生成する ログアウト状態です。 コンパイル中にエラーが発生した場合は、メッセージダイアログが表示されます。エラーは、カテゴリのメッセージウィンドウに一覧表示されます 翻訳すること 発行済み。次に、プログラムをコントローラーにロードせずにログインするかどうかを決定できます。 " }, 
{ "title" : "ログイン中にエラーが発生しました ", 
"url" : "_cds_cmd_login.html#UUID-51a355d9-96c3-eb5c-5f83-080a64d34b57_id_f7339dad366f5b2ec0a8640e002c9fcf_id_dbcc3ada1e8ebbd8c0a8640e015a729c", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：ログイン \/ ログイン中にエラーが発生しました ", 
"snippet" : "コントローラへのログオン中にエラーが発生した場合、中断します CODESYS エラーメッセージ付きの読み込みプロセス。エラーダイアログでは、エラーの詳細を表示できます。例外が発生し、テキスト* SOURCEPOSITION *がログメッセージに含まれている場合は、コマンドを使用できます。 メモ帳で表示 影響を受ける関数をエディターに表示します。エラーの原因となっている行にカーソルがジャンプします。...", 
"body" : "コントローラへのログオン中にエラーが発生した場合、中断します CODESYS エラーメッセージ付きの読み込みプロセス。エラーダイアログでは、エラーの詳細を表示できます。例外が発生し、テキスト* SOURCEPOSITION *がログメッセージに含まれている場合は、コマンドを使用できます。 メモ帳で表示 影響を受ける関数をエディターに表示します。エラーの原因となっている行にカーソルがジャンプします。 " }, 
{ "title" : "ロードプロセスに関する情報の出力 ", 
"url" : "_cds_cmd_login.html#UUID-51a355d9-96c3-eb5c-5f83-080a64d34b57_id_f7339dad366f5b2ec0a8640e002c9fcf_id_4ba66a1395c4915dc0a8640e0199319f", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：ログイン \/ ロードプロセスに関する情報の出力 ", 
"snippet" : "いつ CODESYS ログイン時にプロジェクトをコントローラーにロードすると、メッセージウィンドウに次の情報が出力されます。 生成されたコードサイズ グローバルデータサイズ コントローラで結果として生じるメモリ要件 影響を受けるブロックのリスト（オンライン変更の場合） オンラインモードでは、デバイスまたはモジュールの設定を変更することはできません。デバイスパラメータを変更するには、アプリケーションからログアウトする必要があります。ただし、バスシステムによっては、オンラインモードでも変更できる特別なパラメータがいくつかある場合があります。 ビューの構成を保存します CODESYS オンラインモー...", 
"body" : "いつ CODESYS ログイン時にプロジェクトをコントローラーにロードすると、メッセージウィンドウに次の情報が出力されます。 生成されたコードサイズ グローバルデータサイズ コントローラで結果として生じるメモリ要件 影響を受けるブロックのリスト（オンライン変更の場合） オンラインモードでは、デバイスまたはモジュールの設定を変更することはできません。デバイスパラメータを変更するには、アプリケーションからログアウトする必要があります。ただし、バスシステムによっては、オンラインモードでも変更できる特別なパラメータがいくつかある場合があります。 ビューの構成を保存します CODESYS オンラインモードとオフラインモードで互いに別々に。また、動作モードで使用できないビューは閉じられます。このため、ログインするとビューが自動的に変更される場合があります。 " }, 
{ "title" : "コマンド：ログアウト ", 
"url" : "_cds_cmd_logoff.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：ログアウト ", 
"snippet" : "ログアウト シンボル： キーボードショートカット： ctrl + F8 関数 ：このコマンドは、アプリケーションをターゲットシステム（コントローラーまたはシミュレートされたデバイス）から切断し、オフライン操作に戻ります。 電話 ：メニュー オンライン 、オブジェクトのコンテキストメニュー 応用...", 
"body" : "ログアウト シンボル： キーボードショートカット： ctrl + F8 関数 ：このコマンドは、アプリケーションをターゲットシステム（コントローラーまたはシミュレートされたデバイス）から切断し、オフライン操作に戻ります。 電話 ：メニュー オンライン 、オブジェクトのコンテキストメニュー 応用 " }, 
{ "title" : "コマンド：ブートアプリケーションを作成する ", 
"url" : "_cds_cmd_create_boot_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：ブートアプリケーションを作成する ", 
"snippet" : "ブートアプリケーションを作成する 関数 ：コマンドはブートアプリケーションを作成します。 電話 ：メニュー オンライン ブートアプリケーションは、コントローラーの電源がオンまたは起動したときに自動的に起動するアプリケーションです。 オフラインモードでは、ブートアプリケーションを任意のディレクトリに保存できます。オンラインモードで保存 CODESYS ターゲットデバイス上のブートアプリケーション。ファイル名は <Applikationsname>.app 。 詳細については、以下を参照してください。 ブートアプリケーションの作成...", 
"body" : "ブートアプリケーションを作成する 関数 ：コマンドはブートアプリケーションを作成します。 電話 ：メニュー オンライン ブートアプリケーションは、コントローラーの電源がオンまたは起動したときに自動的に起動するアプリケーションです。 オフラインモードでは、ブートアプリケーションを任意のディレクトリに保存できます。オンラインモードで保存 CODESYS ターゲットデバイス上のブートアプリケーション。ファイル名は <Applikationsname>.app 。 詳細については、以下を参照してください。 ブートアプリケーションの作成" }, 
{ "title" : "コマンド：ロード ", 
"url" : "_cds_cmd_load.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：ロード ", 
"snippet" : "ロード 関数 ：このコマンドにより、アクティブなアプリケーションがコンパイルされ、その後コントローラーにダウンロードされます。 電話 ：メニュー オンライン 要件 ：アプリケーションはオンラインモードです。 コマンドリード付き CODESYS 構文チェックを実行し、アプリケーションコードを生成します。このコードはコントローラーにロードされます。まだ生成されています CODESYS プロジェクトディレクトリの翻訳ログ <project name>.<device name>.<application ID>.compileinfo 。 ロード時に、永続変数を除くすべての変数が再初期化されます。 ...", 
"body" : "ロード 関数 ：このコマンドにより、アクティブなアプリケーションがコンパイルされ、その後コントローラーにダウンロードされます。 電話 ：メニュー オンライン 要件 ：アプリケーションはオンラインモードです。 コマンドリード付き CODESYS 構文チェックを実行し、アプリケーションコードを生成します。このコードはコントローラーにロードされます。まだ生成されています CODESYS プロジェクトディレクトリの翻訳ログ <project name>.<device name>.<application ID>.compileinfo 。 ロード時に、永続変数を除くすべての変数が再初期化されます。 安全コントローラがコントローラの下に取り付けられている場合、このコマンドは通信リンクを使用できます 一時的 割り込み！ 安全コントローラのその他の安全コントローラへの接続（安全ネットワーク変数を介して）、フィールドデバイス、および開発システムへの接続が影響を受けます。安全フィールドデバイスまたは他の安全コントローラは、反応として安全状態に入る可能性があります。開発システムへの接続は、セーフティコントローラがフィールドバスを介してメインコントローラに接続されている場合にのみ影響を受けます。 詳細については、以下を参照してください。 従属安全コントローラの説明は、 ログイン コマンドでは、ログイン時とダウンロード時に考えられる状況について説明します。 このアプリケーションの同じバージョンがすでにコントローラー上にあるときにアプリケーションをロードしようとすると、次のメッセージが表示されます。「プログラムは変更されていません。アプリケーションがロードされませんでした」。 CODESYS アプリケーションをPLCにロードしません。 メッセージカテゴリのメッセージウィンドウに読み込みが表示されたとき 翻訳すること 進行中のアクションのログ（コードの生成、初期化の実行など）。メモリ領域、コードのサイズ、グローバルデータ、および割り当てられたメモリに関する情報も出力されます。オンラインでの変更とは対照的に、変更されたブロックは、わかりやすくするためにリストされなくなりました。 " }, 
{ "title" : "コマンド：オンライン変更 ", 
"url" : "_cds_cmd_online_change.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：オンライン変更 ", 
"snippet" : "オンライン変更 関数 ：このコマンドは、現在アクティブなアプリケーションへのオンライン変更を開始するために使用されます。ロード中 CODESYS コントローラですでに実行されているアプリケーションの変更された部分のみがコントローラに再ロードされます。 電話 ：メニュー オンライン 、オブジェクトのコンテキストメニュー 応用 要件 ：アプリケーションはオンラインモードです。 このコマンドは、デバイスツリーでアプリケーションが選択されているときにコンテキストメニューで使用できます。したがって、アプリケーションが現在「アクティブ」なものでなくても、アプリケーション専用のオンライン変更を実行できます。...", 
"body" : "オンライン変更 関数 ：このコマンドは、現在アクティブなアプリケーションへのオンライン変更を開始するために使用されます。ロード中 CODESYS コントローラですでに実行されているアプリケーションの変更された部分のみがコントローラに再ロードされます。 電話 ：メニュー オンライン 、オブジェクトのコンテキストメニュー 応用 要件 ：アプリケーションはオンラインモードです。 このコマンドは、デバイスツリーでアプリケーションが選択されているときにコンテキストメニューで使用できます。したがって、アプリケーションが現在「アクティブ」なものでなくても、アプリケーション専用のオンライン変更を実行できます。 オンラインで変更すると、実行中のアプリケーションプログラムが変更され、再起動は発生しません。 新しいアプリケーションコードが、制御対象システムの望ましい動作を引き起こしていることを確認してください。 制御するシステムによっては、システムやワークピースに損傷を与えたり、人の健康や生命を危険にさらしたりする可能性があります。 オンライン変更が実行されると、マシンはそのステータスを保持するため、アプリケーション固有の初期化 (例: 原点復帰) は実行されません。このため、新しいプログラムコードが意図した効果を発揮しない可能性があります。 ポインターへの変数は、最後のサイクルの値を保持します。オンライン変更で値が変更された変数をポインターが参照すると、その変数は正しい値を返さなくなります。ポインタが各サイクルで再割り当てされていることを確認してください。 「親アプリケーション」を変更した後、オンライン変更を実行すると、「子アプリケーション」がコントローラから削除されます。 高速オンライン変更中の初期化コードなし コンパイラ バージョン >= 3.5.0.0 以降、マイナーな変更に対して「高速オンライン変更」が実行されます。高速オンライン変更では、変更された POU のみがコンパイルおよびダウンロードされます。特に、初期化コードは生成されません。 変数の場合、 init_on_onlchange 属性、これはまた、 いいえ 初期化コードが生成されます。通常のシナリオでは、属性は通常アドレスで変数を初期化するために使用されるため、影響はありません。ただし、高速オンライン変更中に、変数がそのアドレスを変更することはあり得ません。 ただし、その影響を確認するために、 init_on_onlchange 属性は、アプリケーション コード全体に適用されます。一般に、アプリケーションでは、 no_fast_online_change コンパイラは、高速オンライン変更を無効にするように定義します。これを行うには、デバイス ツリーでアプリケーション オブジェクトを選択し、 プロパティ コンテキストメニューで。以下の 建てる タブで、 no_fast_online_change コンパイラ定義。 詳細については、次を参照してください。 建てるリストをロードするとき CODESYS カテゴリのメッセージウィンドウで 翻訳すること また、変更されたインターフェイス、影響を受ける変数、および新しいコードが生成されたすべてのブロック。保存場所が変更されると、ポインタ関連の問題の可能性を警告するダイアログボックスが表示されます。 ビューで オンライン変更のためのメモリリザーブ オンライン変更用のメモリリザーブは、プロジェクトの機能ブロック用に構成できるため、オンライン変更中に機能ブロックに変更が加えられた場合、メモリ内のインスタンス変数を移動する必要はありません。 詳細については、以下を参照してください。 オンライン変更のためのメモリリザーブの設定" }, 
{ "title" : "オンラインでの変更を妨げるものは何ですか？ ", 
"url" : "_cds_cmd_online_change.html#UUID-cdc45270-a748-554a-175e-be948d7ae781_id_ef254ea5d484e8d4c0a8640e019da19e_id_6e316fe7ee4c1585c0a86463711858ab", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：オンライン変更 \/ オンラインでの変更を妨げるものは何ですか？ ", 
"snippet" : "で CODESYS 、アクションの後、コントローラーでのオンライン変更が不可能になります。その後、アプリケーションは常に完全に再コンパイルする必要があります。典型的なケースとしては、 すべてをクリーンアップ 前回のダウンロード時に保存されたコンパイル情報を削除するコマンド。ただし、この種のアクションでは通常、確認する必要がある警告が生成されます。 しかし、次のログイン時にオンライン変更が不可能になる「通常の」編集アクションもあります。したがって、プログラム POU で編集するときは、ステータス バーの次の記号に注意する必要があります。 .このシンボルが赤色に変わったとき 、コントローラへの完全...", 
"body" : "で CODESYS 、アクションの後、コントローラーでのオンライン変更が不可能になります。その後、アプリケーションは常に完全に再コンパイルする必要があります。典型的なケースとしては、 すべてをクリーンアップ 前回のダウンロード時に保存されたコンパイル情報を削除するコマンド。ただし、この種のアクションでは通常、確認する必要がある警告が生成されます。 しかし、次のログイン時にオンライン変更が不可能になる「通常の」編集アクションもあります。したがって、プログラム POU で編集するときは、ステータス バーの次の記号に注意する必要があります。 .このシンボルが赤色に変わったとき 、コントローラへの完全なダウンロードのみを実行できます。シンボルをダブルクリックして アプリケーション情報 最後のダウンロードからの相違点のリストを含むダイアログ。ダイアログには、どの変更がオンライン変更を妨げているかについての情報も表示されます。 詳細については、以下を参照してください。 コマンド: ログイン オンライン変更を妨げるアプリケーションのさまざまな領域でのアクションと変更: チェック機能 チェック機能の有効化または削除（ CheckBounds 、 CheckRange 、 CheckDiv 等。） チェック機能のインターフェースの変更（ローカル変数の挿入と削除を含む） タスク構成 構成設定の変更 プロジェクト設定 の変更 コンパイルオプション セクションで アイデア （Unicode、定数の置換、ブレークポイントへのログイン） の変化 コンパイラは定義します アプリケーションのプロパティ の変更 ターゲットシステムのストレージ設定 （タブ 建てる ）。 ビルディングブロックのプロパティ オプションの変更 外部実装 （タブ 建てる ）。 タスクローカルグローバル変数リスト すべての変更 汎用モジュール 汎用モジュールの基本モジュールの変更（ EXTENDS FBbase ）、そのような基本的な構成要素の挿入または削除を含む インターフェイスリストの変更（ IMPLEMENTS ITF ）。 例外：リストの最後に新しいインターフェイスを追加する データ・タイプ 変数のデータ型をあるユーザー定義のデータ型から別のユーザー定義のデータ型に変更する（たとえば、 TON に TOF ）。 データ型をユーザー定義のデータ型から基本データ型に変更する（例： TON に TIME ）。 注：回避策として、データ型と同時に変数の名前を常に変更する必要があります。次に、変数が新しい変数として初期化され、古い変数が削除されます。その後、オンラインでの変更が可能になります。 アラーム設定 アラームデータベース構成の変更 ラッチ変数の数の変更（データベースのストレージ形式にも影響します） 分散アラームの構成に変更します 情報源 構成のすべての変更 デバイス構成 デバイスツリーの変更（これもコマンドによる） 更新デバイス ）。 デバイス構成の変更：標準の場合、デバイスパラメータの変更はオンラインで変更できません。ただし、デバイスの説明で例外を設定できます。 注：変数へのI \/ Oマッピングは、オンライン変更を介して可能です。 視覚化 オーバーレイ機能を切り替えます V3.5 SP6より前：微量元素の構成の変更 注：以下はV3.5 SP6から適用されます。視覚化に影響を与える、またはアプリケーションのデータに影響を与えるオンライン変更の場合（たとえば、新しい変数が挿入された場合）、視覚化は完全に再初期化されます。 TargetVisuの場合、これは、たとえば、ビジュアライゼーションが閉じて、スタートページで再び開くことを意味します。 WebvVisuの場合、ビジュアライゼーションも短い待機時間の後にビジュアライゼーションの開始から再開されます。 単位変換 単位変換オブジェクトを挿入または削除します 傾向 変数の数または変数の最大数を変更する 説明または特別な行の設定で変数の数を変更する 詳細については、以下を参照してください。 オンライン変更を実行する と init_on_onlchange" }, 
{ "title" : "コマンド：接続されたコントローラーにソースコードをロードします ", 
"url" : "_cds_cmd_source_download_connected_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：接続されたコントローラーにソースコードをロードします ", 
"snippet" : "接続されたコントローラーにソースコードをロードする 関数 ：このコマンドは、プロジェクトのソースコードをプロジェクトアーカイブとして現在接続されているコントローラーにロードします。 電話 ：メニュー オンライン 要件 ：アプリケーションはオンラインモードです。...", 
"body" : "接続されたコントローラーにソースコードをロードする 関数 ：このコマンドは、プロジェクトのソースコードをプロジェクトアーカイブとして現在接続されているコントローラーにロードします。 電話 ：メニュー オンライン 要件 ：アプリケーションはオンラインモードです。 " }, 
{ "title" : "コマンド：複数ダウンロード ", 
"url" : "_cds_cmd_multiple_download.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：複数ダウンロード ", 
"snippet" : "複数ダウンロード 関数 ：このコマンドにより、プロジェクトに含まれるアプリケーションのコードが生成され、対応するコントローラーにアプリケーションが読み込まれます。 電話 ：メニュー オンライン このコマンドは、アプリケーションのリストを含むダイアログを開きます。このダイアログでは、ロードするアプリケーションを選択します。その後リード CODESYS これらのアプリケーションの構文チェックを実行し、関連するコードを生成します。次に、コードが対応するコントローラーにロードされます。プロジェクトディレクトリで生成 CODESYS 選択した各アプリケーションの名前が記載された翻訳ログ <project...", 
"body" : "複数ダウンロード 関数 ：このコマンドにより、プロジェクトに含まれるアプリケーションのコードが生成され、対応するコントローラーにアプリケーションが読み込まれます。 電話 ：メニュー オンライン このコマンドは、アプリケーションのリストを含むダイアログを開きます。このダイアログでは、ロードするアプリケーションを選択します。その後リード CODESYS これらのアプリケーションの構文チェックを実行し、関連するコードを生成します。次に、コードが対応するコントローラーにロードされます。プロジェクトディレクトリで生成 CODESYS 選択した各アプリケーションの名前が記載された翻訳ログ <project name>.<device name>.<application ID>.compileinfo 。 安全コントローラがコントローラの下に取り付けられている場合、このコマンドは通信リンクを使用できます 一時的 割り込み！ 安全コントローラのその他の安全コントローラへの接続（安全ネットワーク変数を介して）、フィールドデバイス、および開発システムへの接続が影響を受けます。安全フィールドデバイスまたは他の安全コントローラは、反応として安全状態に入る可能性があります。開発システムへの接続は、セーフティコントローラがフィールドバスを介してメインコントローラに接続されている場合にのみ影響を受けます。 詳細については、以下を参照してください。 従属安全コントローラ" }, 
{ "title" : "対話：複数のダウンロード ", 
"url" : "_cds_cmd_multiple_download.html#UUID-bff2081a-a86c-2315-20e6-97bba25d9cab_id_b6ceffd313d207c0a8640e01914b7b_id_f3237677278f5f78c0a8646372db20c9", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：複数ダウンロード \/ 対話：複数のダウンロード ", 
"snippet" : "アプリケーションを選択してください ：アプリケーションの選択 アプリケーションは、さまざまなコントローラーにもロードされます。 上 、 下向き アプリケーションのダウンロード順序を変更する アプリケーションは、このリストの順序でコントローラーにロードされます。デフォルトでは、このリストはアルファベット順にソートされています。アプリケーションの親子関係が考慮されます。 わかった 選択したすべてのアプリケーションを構文的にチェックします その後、ダウンロードが行われる前に、関連するコントローラーとの通信がアプリケーションごとに検証されます。 オンライン変更オプション 以前のバージョンがコントローラ...", 
"body" : "アプリケーションを選択してください ：アプリケーションの選択 アプリケーションは、さまざまなコントローラーにもロードされます。 上 、 下向き アプリケーションのダウンロード順序を変更する アプリケーションは、このリストの順序でコントローラーにロードされます。デフォルトでは、このリストはアルファベット順にソートされています。アプリケーションの親子関係が考慮されます。 わかった 選択したすべてのアプリケーションを構文的にチェックします その後、ダウンロードが行われる前に、関連するコントローラーとの通信がアプリケーションごとに検証されます。 オンライン変更オプション 以前のバージョンがコントローラーにすでに存在し、現在のバージョンと異なる場合は、次のオプションがあります。 オンライン変更をお試しください。不可能な場合は、ダウンロードしてください デフォルトで有効 いずれかのアプリケーションのオンライン変更を完了できない場合は、ダウンロードが実行されます。 オンライン変更を強制します。不可能な場合は、操作を中止してください （少なくとも）1つのアプリケーションのオンライン変更を完了できない場合、ダウンロードは実行されませんが、中止されます。たとえば、以前にコマンドを使用した場合 すべてをきれいにする 実行しました。 常にフルダウンロードを行う 既存のバージョンを考慮せずに、アプリケーションのすべての部分をコントローラーにロードします コントローラにまだ存在しない選択されたアプリケーションの場合 CODESYS 関連するコントローラーへのダウンロードを自動的に実行します。 追加オプション プロジェクトに含まれていないコントローラー上のすべてのアプリケーションを削除します ：対応するアプリケーションが削除されます。 ダウンロードまたはオンライン変更後にすべてのアプリケーションを起動します ：ダウンロード\/オンライン変更後にアプリケーションが起動します。 強制変数を解放しないでください ：コントローラーに強制変数を持つアプリケーションがあり、その間にこのアプリケーションの実装が変更された場合、このアプリケーションのダウンロードは実行されません。 ウィンドウ内 複数ダウンロード-結果 このアプリケーションには、次のメッセージが表示されます。 エラー：1つ以上の変数が強制されたためスキップされました 。 キー属性を持つ変数に注意してください PERSISTENT RETAIN 通常、初期化されません。ただし、データレイアウトを変更すると、永続変数は自動的に再初期化されます。 詳細については、以下を参照してください。 データの永続性ダウンロードが完了すると、選択したすべてのアプリケーションのリストが、構成したダウンロード順序で表示されます。さらに、ダイアログで各アプリケーションのダウンロードの成功に関する情報を受け取ります 複数ダウンロード-結果 ： 作成した ：新しいアプリケーションが作成され、コントローラーにロードされました。 変更なし ：コントローラにすでに存在するアプリケーションは変更されていません。 オンライン変更が実行されました ：コントロールにすでに存在するアプリケーションは、オンライン変更によって変更されました。 ダウンロード ：コントローラー上に既に存在するアプリケーションは、新しく作成されたアプリケーションに置き換えられました。 オンラインで変更できないためスキップされました ：アプリケーションのオンライン変更は実行できませんでした。変更されませんでした。 エラー ：このアプリケーションのダウンロード中にエラーが発生しました。必要に応じて、詳細が表示されます。 ユーザーによってキャンセルされました ：ユーザーが操作をキャンセルしました。 詳細については、以下を参照してください。 アプリケーションコードの生成" }, 
{ "title" : "コマンド：コールドリセット ", 
"url" : "_cds_cmd_reset_cold.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：コールドリセット ", 
"snippet" : "コールドリセット 関数 ：このコマンドにより、コントローラー上のアクティブなアプリケーションがコールドスタートされます。 電話 ：メニュー オンライン 要件 ：アプリケーションはオンラインモードです。 安全コントローラがコントローラの下に取り付けられている場合、このコマンドは通信リンクを使用できます 一時的 割り込み！ 安全コントローラのその他の安全コントローラへの接続（安全ネットワーク変数を介して）、フィールドデバイス、および開発システムへの接続が影響を受けます。安全フィールドデバイスまたは他の安全コントローラは、反応として安全状態に入る可能性があります。開発システムへの接続は、セーフティコ...", 
"body" : "コールドリセット 関数 ：このコマンドにより、コントローラー上のアクティブなアプリケーションがコールドスタートされます。 電話 ：メニュー オンライン 要件 ：アプリケーションはオンラインモードです。 安全コントローラがコントローラの下に取り付けられている場合、このコマンドは通信リンクを使用できます 一時的 割り込み！ 安全コントローラのその他の安全コントローラへの接続（安全ネットワーク変数を介して）、フィールドデバイス、および開発システムへの接続が影響を受けます。安全フィールドデバイスまたは他の安全コントローラは、反応として安全状態に入る可能性があります。開発システムへの接続は、セーフティコントローラがフィールドバスを介してメインコントローラに接続されている場合にのみ影響を受けます。 詳細については、以下を参照してください。 従属安全管理 再起動をどうするか コールドリセット 起こる： アプリケーションコードはコントローラーに残ります。 変数は初期化され（初期化値またはデフォルトの初期化値0で）、以前の値は失われます。 保持変数は初期化され、以前の値は失われます。 永続変数は値のままです。 コードで設定されたブレークポイントは、ステータス（有効または無効など）のままになります。 アプリケーションは状態になります 止まる 。 ちなみに、アプリケーションのデバッグ中にコマンドを選択することもできます。 血圧を下げる ブレークポイントに立っています。次に、ウォームスタートがすぐに実行されるか、まだ欠落している現在のサイクルの命令が最初に処理されます。したがって、メッセージウィンドウが表示され、さらに動作を選択できます。ただし、メッセージウィンドウは、ランタイムシステムが最初にサイクルを終了せずに再起動できる場合にのみ表示されます。 後 リセット 通常どおり、たとえばコマンドを使用してアプリケーションを操作できます。 デバッグ→起動 実行を開始します。 詳細については、以下を参照してください。 ResetWarm と 原点をリセット" }, 
{ "title" : "コマンド：ResetWarm ", 
"url" : "_cds_cmd_reset_warm.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：ResetWarm ", 
"snippet" : "ResetWarm 関数 ：このコマンドにより、コントローラー上のアクティブなアプリケーションがウォームスタートされます。 電話 ：メニュー オンライン 要件 ：アプリケーションはオンラインモードです。 安全コントローラがコントローラの下に取り付けられている場合、このコマンドは通信リンクを使用できます 一時的 割り込み！ 安全コントローラのその他の安全コントローラへの接続（安全ネットワーク変数を介して）、フィールドデバイス、および開発システムへの接続が影響を受けます。安全フィールドデバイスまたは他の安全コントローラは、反応として安全状態に入る可能性があります。開発システムへの接続は、セーフティ...", 
"body" : "ResetWarm 関数 ：このコマンドにより、コントローラー上のアクティブなアプリケーションがウォームスタートされます。 電話 ：メニュー オンライン 要件 ：アプリケーションはオンラインモードです。 安全コントローラがコントローラの下に取り付けられている場合、このコマンドは通信リンクを使用できます 一時的 割り込み！ 安全コントローラのその他の安全コントローラへの接続（安全ネットワーク変数を介して）、フィールドデバイス、および開発システムへの接続が影響を受けます。安全フィールドデバイスまたは他の安全コントローラは、反応として安全状態に入る可能性があります。開発システムへの接続は、セーフティコントローラがフィールドバスを介してメインコントローラに接続されている場合にのみ影響を受けます。 詳細については、以下を参照してください。 従属安全コントローラ再起動をどうするか ResetWarm 起こる： アプリケーションコードはコントローラにロードされたままです。 変数は初期化されます（初期化値またはデフォルトの初期化値0を使用）。 保持変数はその値を保持します。 永続変数は値のままです。 コードで設定されたブレークポイントは、ステータス（有効または無効など）のままになります。 アプリケーションは状態になります 止まる 。 ちなみに、アプリケーションのデバッグ中にコマンドを選択することもできます。 血圧を下げる ブレークポイントに立っています。次に、ウォームスタートがすぐに実行されるか、まだ欠落している現在のサイクルの命令が最初に処理されます。したがって、メッセージウィンドウが表示され、さらに動作を選択できます。ただし、メッセージウィンドウは、ランタイムシステムが最初にサイクルを終了せずに再起動できる場合にのみ表示されます。 リセット後、たとえばコマンドを使用して、通常どおりにアプリケーションを操作できます。 デバッグ→起動 実行を開始します。 詳細については、以下を参照してください。 アプリケーションのリセットを実行します と コールドリセット" }, 
{ "title" : "コマンド：原点をリセット ", 
"url" : "_cds_cmd_reset_origin.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：原点をリセット ", 
"snippet" : "原点をリセット 関数 ：このコマンドにより、コントローラー上のアクティブなアプリケーションが全体的にリセットされます。 電話 ：メニュー オンライン 要件 ：アプリケーションはオンラインモードです。 安全コントローラがコントローラの下に取り付けられている場合、このコマンドは通信リンクを使用できます 連続 割り込み！ 安全コントローラのその他の安全コントローラへの接続（安全ネットワーク変数を介して）、フィールドデバイス、および開発システムへの接続が影響を受けます。安全フィールドデバイスまたは他の安全コントローラは、反応として安全状態に入る可能性があります。開発システムへの接続は、セーフティコント...", 
"body" : "原点をリセット 関数 ：このコマンドにより、コントローラー上のアクティブなアプリケーションが全体的にリセットされます。 電話 ：メニュー オンライン 要件 ：アプリケーションはオンラインモードです。 安全コントローラがコントローラの下に取り付けられている場合、このコマンドは通信リンクを使用できます 連続 割り込み！ 安全コントローラのその他の安全コントローラへの接続（安全ネットワーク変数を介して）、フィールドデバイス、および開発システムへの接続が影響を受けます。安全フィールドデバイスまたは他の安全コントローラは、反応として安全状態に入る可能性があります。開発システムへの接続は、セーフティコントローラがフィールドバスを介してメインコントローラに接続されている場合にのみ影響を受けます。 詳細については、以下を参照してください。 従属安全コントローラ再起動をどうするか 原点をリセット 起こる： アプリケーションコードが削除されたため、アプリケーションにステータスはありません。 変数が削除され、値が失われます。 保持変数が削除され、値が失われます。 永続変数が削除され、値が失われます。 コードで設定されたブレークポイントは失われます。 詳細については、以下を参照してください。 永続変数でデータを保存する" }, 
{ "title" : "コマンド：ソースデバイスをリセット ", 
"url" : "_cds_cmd_reset_origin_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：ソースデバイスをリセット ", 
"snippet" : "ソースデバイスをリセット 関数 ：コマンドはダイアログを開き、デバイスを元の状態（出荷時の状態）にリセットします。デバイス上のすべてのアプリケーション、ブートアプリケーション、および保持変数が削除されます。デバイスのバージョンに応じて、このダイアログで削除する要素を選択できます。これらの要素がダイアログで選択解除された場合、それらはリセットで削除されず、コントロールに残ります。 デフォルトでは、すべてのアイテムが選択され、すべてが削除されます。通常、選択できない要素も削除されます。 電話 ：デバイスツリー内のプログラム可能なデバイスのコンテキストメニュー 安全コントローラがコントローラの下に取...", 
"body" : "ソースデバイスをリセット 関数 ：コマンドはダイアログを開き、デバイスを元の状態（出荷時の状態）にリセットします。デバイス上のすべてのアプリケーション、ブートアプリケーション、および保持変数が削除されます。デバイスのバージョンに応じて、このダイアログで削除する要素を選択できます。これらの要素がダイアログで選択解除された場合、それらはリセットで削除されず、コントロールに残ります。 デフォルトでは、すべてのアイテムが選択され、すべてが削除されます。通常、選択できない要素も削除されます。 電話 ：デバイスツリー内のプログラム可能なデバイスのコンテキストメニュー 安全コントローラがコントローラの下に取り付けられている場合、このコマンドは通信リンクを使用できます 連続 割り込み！ 安全コントローラのその他の安全コントローラへの接続（安全ネットワーク変数を介して）、フィールドデバイス、および開発システムへの接続が影響を受けます。安全フィールドデバイスまたは他の安全コントローラは、反応として安全状態に入る可能性があります。開発システムへの接続は、セーフティコントローラがフィールドバスを介してメインコントローラに接続されている場合にのみ影響を受けます。 詳細については、以下を参照してください。 従属安全コントローラ再起動をどうするか ソースデバイスをリセット 起こる： すべてのアプリケーションはコマンドと同じです 原点をリセット リセットします。 コマンドによって作成されたすべてのファイル 原点をリセット 記録されていないものは削除されます（視覚化、アラーム、レシピなどのファイル） ユーザー管理が削除されます。 ランタイムシステムによって現在管理されているすべての証明書が削除されます。 デバイスのリセットに関する注意：デバイスをリセットすると、このダイアログで選択した項目も削除されます。このダイアログで表示されているすべてのオブジェクトが選択されていない場合、他のオブジェクトが使用できなくなったり、削除されたりする可能性があります。 消火 ：コマンド実行時にオブジェクトが作成されます ソースデバイスをリセット オフになりました。 物体 日付の付いたオブジェクト 消火 除外できます リストされるオブジェクトは、コントローラーのバージョンによって異なります。バージョン3.5.16.20以降、次のオブジェクトを削除プロセスから除外できます。 ユーザー管理 PLCロジック 証明書 " }, 
{ "title" : "コマンド：現在のデバイスユーザーをログアウトします ", 
"url" : "_cds_cmd_logoff_current_online_user.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：現在のデバイスユーザーをログアウトします ", 
"snippet" : "現在のデバイスユーザーをログアウトします シンボル： 関数 ：このコマンドは、現在コントローラーにログインしているユーザーをログアウトします。いつ CODESYS まだコントローラーへの接続があり、これは終了します。 電話 ：メニュー オンライン→セキュリティ 要件 ：アプリケーションはオンラインモードです。 アクセス保護デバイス タブからデバイスのユーザー管理を管理できます ユーザーとグループ と アクセス権 デバイスエディタの。メニューコマンド オンライン→セキュリティ ターゲットデバイスへのアクセスを保護するための追加の簡略化された方法を提供します。 詳細については、以下を参照してくださ...", 
"body" : "現在のデバイスユーザーをログアウトします シンボル： 関数 ：このコマンドは、現在コントローラーにログインしているユーザーをログアウトします。いつ CODESYS まだコントローラーへの接続があり、これは終了します。 電話 ：メニュー オンライン→セキュリティ 要件 ：アプリケーションはオンラインモードです。 アクセス保護デバイス タブからデバイスのユーザー管理を管理できます ユーザーとグループ と アクセス権 デバイスエディタの。メニューコマンド オンライン→セキュリティ ターゲットデバイスへのアクセスを保護するための追加の簡略化された方法を提供します。 詳細については、以下を参照してください。 デバイスユーザー管理の処理" }, 
{ "title" : "コマンド：デバイスユーザーを追加 ", 
"url" : "_cds_cmd_add_online_user.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：デバイスユーザーを追加 ", 
"snippet" : "デバイスユーザーを追加 シンボル： 関数 ：このコマンドは、Administratorsグループに自動的に追加される新しいデバイスユーザーを簡単に定義します。 電話 ：メニュー オンライン→セキュリティ 要件 ：デバイスはデバイスユーザー管理をサポートします。デバイスにユーザーとしてログインしています。 アクセス保護デバイス タブからデバイスのユーザー管理を管理できます ユーザーとグループ と アクセス権 デバイスエディタの。メニューコマンド オンライン→セキュリティ ターゲットデバイスへのアクセスを保護するための追加の簡略化された方法を提供します。 コマンドはダイアログを開きます デバイスユ...", 
"body" : "デバイスユーザーを追加 シンボル： 関数 ：このコマンドは、Administratorsグループに自動的に追加される新しいデバイスユーザーを簡単に定義します。 電話 ：メニュー オンライン→セキュリティ 要件 ：デバイスはデバイスユーザー管理をサポートします。デバイスにユーザーとしてログインしています。 アクセス保護デバイス タブからデバイスのユーザー管理を管理できます ユーザーとグループ と アクセス権 デバイスエディタの。メニューコマンド オンライン→セキュリティ ターゲットデバイスへのアクセスを保護するための追加の簡略化された方法を提供します。 コマンドはダイアログを開きます デバイスユーザーを追加 。ここでは、新しいユーザーのアクセスデータを指定します。 ダイアログはタブのダイアログに対応します ユーザーとグループ デバイスエディタのは、新しいユーザーを追加するために使用されます。 常に強力なパスワードを使用してください。次の点に注意してください。 パスワードの長さ> = 8文字（理想的には> = 12） 大文字と小文字を使用する 数字をインストール 特殊文字を使用する パスワードに既存の名前と推測しやすい文字列（「123」、「abc」、「qwerty」など）を使用しないでください。 このアクションの後、空のユーザー名とパスワードでログインすることはできなくなります。パスワードを覚えておく必要があります！ " }, 
{ "title" : "コマンド：デバイスユーザーを削除します ", 
"url" : "_cds_cmd_remove_online_user.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：デバイスユーザーを削除します ", 
"snippet" : "デバイスユーザーを削除する シンボル： 関数 ：このコマンドは、ターゲットシステム（デバイス）のユーザー管理からユーザーを削除します。 電話 ：メニュー オンライン→セキュリティ 要件 ：デバイスにユーザーとしてログインしています。 アクセス保護デバイス タブからデバイスのユーザー管理を管理できます ユーザーとグループ と アクセス権 デバイスエディタの。メニューコマンド オンライン→セキュリティ ターゲットデバイスへのアクセスを保護するための追加の簡略化された方法を提供します。 コマンドはダイアログを開きます デバイスユーザーを削除する 。削除するユーザーのユーザー名とパスワードを入力し、で...", 
"body" : "デバイスユーザーを削除する シンボル： 関数 ：このコマンドは、ターゲットシステム（デバイス）のユーザー管理からユーザーを削除します。 電話 ：メニュー オンライン→セキュリティ 要件 ：デバイスにユーザーとしてログインしています。 アクセス保護デバイス タブからデバイスのユーザー管理を管理できます ユーザーとグループ と アクセス権 デバイスエディタの。メニューコマンド オンライン→セキュリティ ターゲットデバイスへのアクセスを保護するための追加の簡略化された方法を提供します。 コマンドはダイアログを開きます デバイスユーザーを削除する 。削除するユーザーのユーザー名とパスワードを入力し、で確認します わかった 。 この操作を行うと、削除されたユーザーのアカウントでログインできなくなります。ターゲットシステムで指定されているのがユーザーだけの場合、このユーザーを削除できないというメッセージが表示されます。 " }, 
{ "title" : "コマンド：デバイスのユーザーパスワードを変更する ", 
"url" : "_cds_cmd_change_password_online_user.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：デバイスのユーザーパスワードを変更する ", 
"snippet" : "デバイスのユーザーパスワードを変更する シンボル： 関数 ：このコマンドは、現在コントローラーにログオンしているユーザーのパスワードを変更します。 電話 ：メニュー オンライン→セキュリティ 要件 ：デバイスにユーザーとしてログインしています。 このコマンドは、新しいパスワードを定義するためのダイアログを開きます デバイスのユーザーパスワードを変更する 。また、古いパスワードを再入力する必要があります。 このアクションを実行すると、以前のパスワードでログインできなくなります。 常に強力なパスワードを使用してください。次の点に注意してください。 パスワードの長さ> = 8文字（理想的には> = ...", 
"body" : "デバイスのユーザーパスワードを変更する シンボル： 関数 ：このコマンドは、現在コントローラーにログオンしているユーザーのパスワードを変更します。 電話 ：メニュー オンライン→セキュリティ 要件 ：デバイスにユーザーとしてログインしています。 このコマンドは、新しいパスワードを定義するためのダイアログを開きます デバイスのユーザーパスワードを変更する 。また、古いパスワードを再入力する必要があります。 このアクションを実行すると、以前のパスワードでログインできなくなります。 常に強力なパスワードを使用してください。次の点に注意してください。 パスワードの長さ> = 8文字（理想的には> = 12） 大文字と小文字を使用する 数字をインストール 特殊文字を使用する パスワードに既存の名前と推測しやすい文字列（「123」、「abc」、「qwerty」など）を使用しないでください。 詳細については、以下を参照してください。 デバイスユーザー管理の処理" }, 
{ "title" : "コマンド：処理された例外の実行を停止します ", 
"url" : "_cds_cmd_stop_execution_on_handled_exceptions.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：処理された例外の実行を停止します ", 
"snippet" : "処理された例外で実行を停止します 関数 ：コマンドは、プログラムされた例外処理にもかかわらず、エラーの場所でアプリケーションを停止します。 電話 ：コマンドはデフォルトでは使用できませんが、 ツール→カスタマイズ 構成可能。コマンドはタブにあります コマンドアイコン カテゴリ内 オンライン 。 要件 ：アプリケーションには、オペレーターによるプログラムされた例外処理が含まれています __TRY と __CATCH そしてオンラインです。 メニューにコマンドを入力したとき オンライン 構成してそこで呼び出すと、現在アクティブなアプリケーションが影響を受けます。このコマンドは、トラブルシューティン...", 
"body" : "処理された例外で実行を停止します 関数 ：コマンドは、プログラムされた例外処理にもかかわらず、エラーの場所でアプリケーションを停止します。 電話 ：コマンドはデフォルトでは使用できませんが、 ツール→カスタマイズ 構成可能。コマンドはタブにあります コマンドアイコン カテゴリ内 オンライン 。 要件 ：アプリケーションには、オペレーターによるプログラムされた例外処理が含まれています __TRY と __CATCH そしてオンラインです。 メニューにコマンドを入力したとき オンライン 構成してそこで呼び出すと、現在アクティブなアプリケーションが影響を受けます。このコマンドは、トラブルシューティングをサポートします。 詳細については、以下を参照してください。 __TRY, __CATCH, __FINALLY, __ENDTRY と メニュー" }, 
{ "title" : "コマンド：デバイスに接続します ", 
"url" : "_cds_cmd_connect_to_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：デバイスに接続します ", 
"snippet" : "デバイスに接続する 関数 ：このコマンドは、デバイスツリーで現在選択されているデバイスとの接続を確立します。 電話 ：デバイスのコンテキストメニュー 要件 ：デバイスツリーでデバイスが選択されています。通信設定が正しく設定されている。...", 
"body" : "デバイスに接続する 関数 ：このコマンドは、デバイスツリーで現在選択されているデバイスとの接続を確立します。 電話 ：デバイスのコンテキストメニュー 要件 ：デバイスツリーでデバイスが選択されています。通信設定が正しく設定されている。 " }, 
{ "title" : "コマンド：デバイスから切断します ", 
"url" : "_cds_cmd_disconnect_from_device.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：デバイスから切断します ", 
"snippet" : "デバイスから切断します 関数 ：このコマンドは、デバイスへの既存の接続を切断します。 電話 ：デバイスのコンテキストメニュー 要件 ：デバイスツリーでデバイスが選択されています。...", 
"body" : "デバイスから切断します 関数 ：このコマンドは、デバイスへの既存の接続を切断します。 電話 ：デバイスのコンテキストメニュー 要件 ：デバイスツリーでデバイスが選択されています。 " }, 
{ "title" : "コマンド：ショートフラッシュ ", 
"url" : "_cds_cmd_wink.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：ショートフラッシュ ", 
"snippet" : "短い点滅 シンボル： 関数 ：コマンドにより、接続されているコントローラのLEDが短時間点滅します。これにより、ハードウェアを一意に識別できます。 電話 ：このコマンドは、デフォルトではどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから オンライン メニューに貼り付けます。 要件 ：コントローラーはこの機能をサポートしており、接続パラメーターは正しく構成されています。...", 
"body" : "短い点滅 シンボル： 関数 ：コマンドにより、接続されているコントローラのLEDが短時間点滅します。これにより、ハードウェアを一意に識別できます。 電話 ：このコマンドは、デフォルトではどのメニューにも含まれていません。ダイアログを使用して彼を見つけることができます ツール→カスタマイズ コマンドカテゴリから オンライン メニューに貼り付けます。 要件 ：コントローラーはこの機能をサポートしており、接続パラメーターは正しく構成されています。 " }, 
{ "title" : "コマンド：シミュレーション ", 
"url" : "_cds_cmd_simulation.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：シミュレーション ", 
"snippet" : "シミュレーション 関数 ：このコマンドは、開発システムをシミュレーションモードに切り替えます。 電話 ：メニュー オンライン シミュレーションモードでは、「シミュレートされたターゲットデバイス」でアクティブなアプリケーションを起動およびデバッグできます。アプリケーションのオンライン動作をテストするために、実際のターゲットデバイスは必要ありません。初めてログインするときに、アプリケーションを作成してロードする必要があるかどうかを尋ねられます。シミュレートされたデバイスの通信設定を行う必要はありません。シミュレーションモードの場合 CODESYS イタリック体のデバイスツリー内のコントローラーのエ...", 
"body" : "シミュレーション 関数 ：このコマンドは、開発システムをシミュレーションモードに切り替えます。 電話 ：メニュー オンライン シミュレーションモードでは、「シミュレートされたターゲットデバイス」でアクティブなアプリケーションを起動およびデバッグできます。アプリケーションのオンライン動作をテストするために、実際のターゲットデバイスは必要ありません。初めてログインするときに、アプリケーションを作成してロードする必要があるかどうかを尋ねられます。シミュレートされたデバイスの通信設定を行う必要はありません。シミュレーションモードの場合 CODESYS イタリック体のデバイスツリー内のコントローラーのエントリ。 ログインに成功すると、アイコンが信号を送ります デバイスツリーのシミュレーションモード。適切なオンラインコマンドを使用して、アプリケーションをテストできます。 シミュレーションモードをオフにするには、最初にコントローラーからログアウトしてから、コマンドを再度選択します シミュレーション 。 このコマンドは常にアクティブなアプリケーションに影響します。 の PLCシェル シミュレーションモードではサポートされていません。 " }, 
{ "title" : "シミュレーションと実際のコントローラーでの操作の違い ", 
"url" : "_cds_cmd_simulation.html#UUID-1e9f2166-cf60-2911-9295-8053f1f65558_id_fb4e48096e42d9c0a8640e0168cbf5_id_4c9f73c83797cddcc0a864631a9fb9dd", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：シミュレーション \/ シミュレーションと実際のコントローラーでの操作の違い ", 
"snippet" : "シミュレーション 実際のコントロール リアルタイム動作\/マルチコア で実行されます CODESYS -通常の優先度で処理する シングルコア ->より悪いリアルタイムの動作 リアルタイムオペレーティングシステム シングルコアまたはマルチコア 建築の幅 シミュレーション64ビット（ CODESYS -からのインストール） ->アプリケーションが以前に32ビットのみで操作されていた場合（例：使用時）、IECアプリケーションで発生する可能性のあるコンパイルエラー DWORD ポインタとして） 32ビット制御 FPU（丸め誤差） PCのFPUを使用 FPU例外の異なる構成 コントローラのFPUまたはFP...", 
"body" : "シミュレーション 実際のコントロール リアルタイム動作\/マルチコア で実行されます CODESYS -通常の優先度で処理する シングルコア ->より悪いリアルタイムの動作 リアルタイムオペレーティングシステム シングルコアまたはマルチコア 建築の幅 シミュレーション64ビット（ CODESYS -からのインストール） ->アプリケーションが以前に32ビットのみで操作されていた場合（例：使用時）、IECアプリケーションで発生する可能性のあるコンパイルエラー DWORD ポインタとして） 32ビット制御 FPU（丸め誤差） PCのFPUを使用 FPU例外の異なる構成 コントローラのFPUまたはFPUエミュレーションを使用します FPU例外の異なる構成 例外の処理 Windowsランタイムシステムの例外処理 コントローラの例外処理 外部ライブラリ（Cmp \/ Sys \/ CAA \/ OEM \/…） 実際に利用できる外部cmp \/ syslibはごくわずかです。 Embeddedと比較してSysLibが多い可能性もあります。 SysLibsのさまざまな実装\/動作（コントロールのOSとは対照的なWindows） ダウンロード中の「未解決の参照エラー」は無視されます。アプリケーションは引き続きコントローラーにロードして開始できます。ただし、欠落している関数が実際に呼び出された場合、それらは無意味な値を返します。 このため、外部ブロックに対してIEC実装を指定することもできます。次に、この代表的なIECコードがシミュレーションで実行されます。 コントローラで外部ライブラリが利用できない場合のダウンロード中の「未解決の参照エラー」 I \/ Oドライバー I \/ O構成は作成されますが、評価されません。 フィールドバススタックは実行されません。 I \/ Oチャネルは更新されず、バステレグラムは送信されません。 ほとんど制限はありませんが、制御の可能性に依存します SoftMotionドライバー すべてのSoftMotion軸は仮想に設定されているため、シミュレートされます。 ほとんど制限はありませんが、制御の可能性に依存します 詳細については、以下を参照してください。 シミュレーションモードでのテスト" }, 
{ "title" : "コマンド：動作モード-デバッグ、ロック、動作 ", 
"url" : "_cds_cmd_operating_modes.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド：動作モード-デバッグ、ロック、動作 ", 
"snippet" : "動作モード-デバッグ、ロック、動作 関数 ：コマンドは、プロジェクトが誤って変更されるのを防ぐ状態にコントローラーを置きます。 電話 ：メニュー オンライン たとえば、コマンドを使用してコントローラーの状態をロックし、別のコントローラーでプログラミングしているときにそのコントローラーの状態が変更されないようにすることができます。 プログラミングの最後に、コントローラーを定義された外部から見える状態にする必要があります。これは、再起動後もまったく同じです。 シンボルはステータスバーに表示されます 、 と 現在の動作モード。これらの記号の1つをダブルクリックすると、ヘルプウィンドウが開きます。 コ...", 
"body" : "動作モード-デバッグ、ロック、動作 関数 ：コマンドは、プロジェクトが誤って変更されるのを防ぐ状態にコントローラーを置きます。 電話 ：メニュー オンライン たとえば、コマンドを使用してコントローラーの状態をロックし、別のコントローラーでプログラミングしているときにそのコントローラーの状態が変更されないようにすることができます。 プログラミングの最後に、コントローラーを定義された外部から見える状態にする必要があります。これは、再起動後もまったく同じです。 シンボルはステータスバーに表示されます 、 と 現在の動作モード。これらの記号の1つをダブルクリックすると、ヘルプウィンドウが開きます。 コントローラがサポートしている場合は、コントローラを次の動作モードに切り替えることができます。 ： デバッグ 制限なし ： ロック済み アプリケーションのデバッグの現在の状態はロックされています。これ以上ブレークポイントを設定したり、変数を強制したりすることはできません。ただし、すでに設定されている変数やブレークポイントを書き込み、アクティブのままにすることは可能です。 アプリケーションの「実行」ステータスのみが動作モードのままになります ロック済み コントローラを再起動することによっても取得されます。 この状態では、開発者は、ブレークポイントを設定または削除したり、ファイルシステムを強制または変更したりすることで、自分自身または別の開発者がコントローラー上のアプリケーションを変更できないようにすることができます。この動作モードは、システム内の複数のコントローラーがプログラムされている場合など、間違ったコントローラーへのダウンロードを防ぐのに役立ちます。 ： 使用する準備ができて この動作モードにより、再起動後にコントローラーが同じアプリケーションを再度ロードし、デバッグ機能がアクティブでなくなることが保証されます。動作モードは、制御が完全にプログラムされて受け入れられる場合、またはすでにそうである場合に設定されます。 動作モードをアクティブにするための条件 使用する準備ができて ： コントローラ上のアプリケーションごとにブートアプリケーションが必要です。 アクティブなブレークポイントが設定されていない必要があります。 すべてのアプリケーションが実行されている必要があります。 強制的な値があってはなりません。 さらに、デバイスは独自の制限を設定できます。 動作モード ロック済み と 使用する準備ができて アプリケーションと動作モードをアクティブにするための要件が異なります。ただし、どちらの動作モードでも、ランタイムシステムは次のアクションを防止します。 アプリケーションについて アプリケーションをダウンロードする オンライン変更 力変数 ブレークポイントを設定する アプリケーションを停止します アプリケーションをリセット アプリケーションを起動します アプリケーションを削除する コントローラのファイル転送について コントローラにファイルをダウンロードします コントローラ上のファイルを削除します コントローラのファイルの名前を変更します コントローラにディレクトリを作成します コントローラのディレクトリを削除します コントローラのディレクトリの名前を変更します 動作モードは以下から選択できます ロック済み と 使用する準備ができて 切り替えないでください。 " }, 
{ "title" : "コマンド: ダウンロード時にサーバー アプリケーションを割り当てる ", 
"url" : "_cds_assign_server_app_download.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ オンライン \/ コマンド: ダウンロード時にサーバー アプリケーションを割り当てる ", 
"snippet" : "ダウンロード時にサーバー アプリケーションを割り当てる このコマンドは、 CODESYS Automation Server Connector アドオンがインストールされています。 コマンドの説明は、のヘルプにあります。 CODESYS Automation Server の コマンド: ダウンロード時にサーバー アプリケーションを割り当てる ....", 
"body" : "ダウンロード時にサーバー アプリケーションを割り当てる このコマンドは、 CODESYS Automation Server Connector アドオンがインストールされています。 コマンドの説明は、のヘルプにあります。 CODESYS Automation Server の コマンド: ダウンロード時にサーバー アプリケーションを割り当てる . " }, 
{ "title" : "デバッグ ", 
"url" : "_cds_f_commands_debug.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド：開始 ", 
"url" : "_cds_cmd_start.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：開始 ", 
"snippet" : "始める シンボル： キーボードショートカット： F5 関数 ：コマンドはアプリケーションを起動します（状態 ランニング ）。 電話 ：メニュー デバッグ 、オブジェクトのコンテキストメニュー 応用 要件 ：アプリケーションはオンラインモードです 止まる 。 メニューからコマンドを使用する場合 デバッグ 呼び出し、現在アクティブなアプリケーションに作用します。 詳細については、以下を参照してください。 アプリケーションコードのダウンロード、ログイン、およびPLCの起動...", 
"body" : "始める シンボル： キーボードショートカット： F5 関数 ：コマンドはアプリケーションを起動します（状態 ランニング ）。 電話 ：メニュー デバッグ 、オブジェクトのコンテキストメニュー 応用 要件 ：アプリケーションはオンラインモードです 止まる 。 メニューからコマンドを使用する場合 デバッグ 呼び出し、現在アクティブなアプリケーションに作用します。 詳細については、以下を参照してください。 アプリケーションコードのダウンロード、ログイン、およびPLCの起動" }, 
{ "title" : "コマンド：停止 ", 
"url" : "_cds_cmd_stop.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：停止 ", 
"snippet" : "止まる シンボル： キーボードショートカット： トグル + F8 関数 ：コマンドはアプリケーションを停止します（状態 止まる ）。 電話 ：メニュー デバッグ 、オブジェクトのコンテキストメニュー 応用 要件 ：アプリケーションはオンラインモードです ランニング 。 メニューからコマンドを使用する場合 デバッグ 呼び出し、現在アクティブなアプリケーションに作用します。...", 
"body" : "止まる シンボル： キーボードショートカット： トグル + F8 関数 ：コマンドはアプリケーションを停止します（状態 止まる ）。 電話 ：メニュー デバッグ 、オブジェクトのコンテキストメニュー 応用 要件 ：アプリケーションはオンラインモードです ランニング 。 メニューからコマンドを使用する場合 デバッグ 呼び出し、現在アクティブなアプリケーションに作用します。 " }, 
{ "title" : "コマンド：シングルサイクル ", 
"url" : "_cds_cmd_single_cycle.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：シングルサイクル ", 
"snippet" : "シングルサイクル キーボードショートカット： ctrl + F5 関数 ：コマンドは、アクティブなアプリケーションを1サイクル実行します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードであり、プログラムはプログラムステップにあります。...", 
"body" : "シングルサイクル キーボードショートカット： ctrl + F5 関数 ：コマンドは、アクティブなアプリケーションを1サイクル実行します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードであり、プログラムはプログラムステップにあります。 " }, 
{ "title" : "コマンド：新しいブレークポイント ", 
"url" : "_cds_cmd_new_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：新しいブレークポイント ", 
"snippet" : "新しいブレークポイント シンボル： キーボードショートカット： 年 + F7 関数 ：コマンドはダイアログを開きます ブレークポイントのプロパティ 。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードである必要があります。 コマンドで 新しいブレークポイント オンラインモードでは、現在のカーソル位置に直接新しいブレークポイントを設定できます。 詳細については、以下を参照してください。 ブレークポイントの使用...", 
"body" : "新しいブレークポイント シンボル： キーボードショートカット： 年 + F7 関数 ：コマンドはダイアログを開きます ブレークポイントのプロパティ 。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードである必要があります。 コマンドで 新しいブレークポイント オンラインモードでは、現在のカーソル位置に直接新しいブレークポイントを設定できます。 詳細については、以下を参照してください。 ブレークポイントの使用" }, 
{ "title" : "コマンド：新しいデータブレークポイント ", 
"url" : "_cds_cmd_new_data_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：新しいデータブレークポイント ", 
"snippet" : "新しいデータブレークポイント シンボル： 関数 ：コマンドはダイアログを開きます 新しいブレークポイント 。 電話 ：メニュー デバッグ 要件 ： アプリケーションはオンラインモードです。 ターゲットデバイスのデバイス記述ファイルには、「データブレークポイント」機能のエントリが含まれています。現在、データブレークポイントは CODESYS Control Win 可能。 詳細については、以下を参照してください。 ブレークポイントの使用...", 
"body" : "新しいデータブレークポイント シンボル： 関数 ：コマンドはダイアログを開きます 新しいブレークポイント 。 電話 ：メニュー デバッグ 要件 ： アプリケーションはオンラインモードです。 ターゲットデバイスのデバイス記述ファイルには、「データブレークポイント」機能のエントリが含まれています。現在、データブレークポイントは CODESYS Control Win 可能。 詳細については、以下を参照してください。 ブレークポイントの使用" }, 
{ "title" : "コマンド：ブレークポイントを編集 ", 
"url" : "_cds_cmd_edit_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：ブレークポイントを編集 ", 
"snippet" : "ブレークポイントの編集 シンボル： 関数 ：コマンドはダイアログを開きます ブレークポイントのプロパティ 。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインであり、カーソルはブレークポイントにあります。 詳細については、以下を参照してください。 ブレークポイントの使用...", 
"body" : "ブレークポイントの編集 シンボル： 関数 ：コマンドはダイアログを開きます ブレークポイントのプロパティ 。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインであり、カーソルはブレークポイントにあります。 詳細については、以下を参照してください。 ブレークポイントの使用" }, 
{ "title" : "コマンド：ブレークポイントを有効にする ", 
"url" : "_cds_cmd_activate_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：ブレークポイントを有効にする ", 
"snippet" : "ブレークポイントを有効にする 関数 ：コマンドは無効なブレークポイントを有効にします。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインであり、カーソルは非アクティブ化されたブレークポイントにあります。 詳細については、以下を参照してください。 ブレークポイントの使用...", 
"body" : "ブレークポイントを有効にする 関数 ：コマンドは無効なブレークポイントを有効にします。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインであり、カーソルは非アクティブ化されたブレークポイントにあります。 詳細については、以下を参照してください。 ブレークポイントの使用" }, 
{ "title" : "コマンド：ブレークポイントを無効にする ", 
"url" : "_cds_cmd_deactivate_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：ブレークポイントを無効にする ", 
"snippet" : "ブレークポイントを無効にする 関数 ：このコマンドは、有効なブレークポイントを無効にします。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードであり、カーソルはアクティブ化されたブレークポイントにあります。 詳細については、以下を参照してください。 ブレークポイントの使用...", 
"body" : "ブレークポイントを無効にする 関数 ：このコマンドは、有効なブレークポイントを無効にします。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードであり、カーソルはアクティブ化されたブレークポイントにあります。 詳細については、以下を参照してください。 ブレークポイントの使用" }, 
{ "title" : "コマンド：ブレークポイントを切り替えます ", 
"url" : "_cds_cmd_toggle_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：ブレークポイントを切り替えます ", 
"snippet" : "ブレークポイントを切り替えます キーボードショートカット： F9 関数 ：コマンドはブレークポイントを設定するか、既存のブレークポイントを削除します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードです。カーソルはブレークポイントにあります。 詳細については、以下を参照してください。 ブレークポイントの使用...", 
"body" : "ブレークポイントを切り替えます キーボードショートカット： F9 関数 ：コマンドはブレークポイントを設定するか、既存のブレークポイントを削除します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードです。カーソルはブレークポイントにあります。 詳細については、以下を参照してください。 ブレークポイントの使用" }, 
{ "title" : "コマンド：手順ステップ ", 
"url" : "_cds_cmd_step_over.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：手順ステップ ", 
"snippet" : "手順ステップ シンボル： キーボードショートカット： F10 関数 ：コマンドは、プログラムが現在配置されているステートメントを実行し、プログラミングブロック内の次のステートメントの前に停止します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードであり、プログラムは現在の停止位置（デバッグモード）にあります。 実行するステートメントに（プログラム、関数ブロックインスタンス、関数、メソッド、またはアクションからの）呼び出しが含まれている場合、プログラミングサブブロックは1つのステップで完全にトラバースされ、呼び出しに戻ります。次に、次のステートメントの前（コードの次の行）...", 
"body" : "手順ステップ シンボル： キーボードショートカット： F10 関数 ：コマンドは、プログラムが現在配置されているステートメントを実行し、プログラミングブロック内の次のステートメントの前に停止します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードであり、プログラムは現在の停止位置（デバッグモード）にあります。 実行するステートメントに（プログラム、関数ブロックインスタンス、関数、メソッド、またはアクションからの）呼び出しが含まれている場合、プログラミングサブブロックは1つのステップで完全にトラバースされ、呼び出しに戻ります。次に、次のステートメントの前（コードの次の行）で停止します。 コマンドを選択します 単一段階 単一のステップで実行するために、下位のビルディングブロックにジャンプします。 詳細については、以下を参照してください。 プログラムの段階的な処理（ステップ）" }, 
{ "title" : "コマンド：シングルステップ ", 
"url" : "_cds_cmd_step_into.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：シングルステップ ", 
"snippet" : "シングルステップ シンボル： キーボードショートカット： F8 関数 ：コマンドは、プログラムが現在立っているステートメントを実行し、次のステートメントの前に停止します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードであり、プログラムは現在の停止位置（デバッグモード）にあります。 実行するステートメントに（プログラム、関数ブロックインスタンス、関数、メソッド、またはアクションからの）呼び出しが含まれている場合、この従属プログラミングブロックにジャンプします。そのコードは独自のエディターに表示されます。そこで最初の命令が実行され、次の命令の前に停止されます。新しい現在の...", 
"body" : "シングルステップ シンボル： キーボードショートカット： F8 関数 ：コマンドは、プログラムが現在立っているステートメントを実行し、次のステートメントの前に停止します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードであり、プログラムは現在の停止位置（デバッグモード）にあります。 実行するステートメントに（プログラム、関数ブロックインスタンス、関数、メソッド、またはアクションからの）呼び出しが含まれている場合、この従属プログラミングブロックにジャンプします。そのコードは独自のエディターに表示されます。そこで最初の命令が実行され、次の命令の前に停止されます。新しい現在の停止位置は、呼び出されたプログラミングブロックにあります。 コマンドを選択します 手順ステップ 現在アクティブなプログラミングブロックにとどまり、1つのステップで呼び出しを実行します。 " }, 
{ "title" : "コマンド：戻るまで実行する ", 
"url" : "_cds_cmd_step_out.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：戻るまで実行する ", 
"snippet" : "実行して戻る シンボル： キーボードショートカット： トグル + F10 関数 ：コマンドは、次の戻りまでプログラムを実行してから停止します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードであり、プログラムは現在の停止位置（デバッグモード）にあります。 現在の停止位置が下位のプログラミングデバイスにある場合、最後まで実行されます。次に、呼び出し側のプログラミングモジュールの呼び出しポイントに戻り、そこで停止します（呼び出しの行で）。 現在の停止位置がメインプログラムにある場合、プログラミングブロックは最後まで実行されます。次に、最初にジャンプして（プログラミングブロッ...", 
"body" : "実行して戻る シンボル： キーボードショートカット： トグル + F10 関数 ：コマンドは、次の戻りまでプログラムを実行してから停止します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードであり、プログラムは現在の停止位置（デバッグモード）にあります。 現在の停止位置が下位のプログラミングデバイスにある場合、最後まで実行されます。次に、呼び出し側のプログラミングモジュールの呼び出しポイントに戻り、そこで停止します（呼び出しの行で）。 現在の停止位置がメインプログラムにある場合、プログラミングブロックは最後まで実行されます。次に、最初にジャンプして（プログラミングブロックのコードの最初の行にあるプログラムの最初に）、そこで停止します。 詳細については、以下を参照してください。 __TRY, __CATCH, __FINALLY, __ENDTRY と メニュー" }, 
{ "title" : "コマンド：カーソルまで実行 ", 
"url" : "_cds_cmd_run_to_cursor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：カーソルまで実行 ", 
"snippet" : "カーソルまで実行 シンボル： 関数 ：コマンドは、カーソルで示された位置までプログラムを実行します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードであり、プログラムは現在の停止位置（デバッグモード）にあります。また、任意のプログラミングブロックの任意のコード行をカーソルでマークしました。 現在の停止位置とカーソル位置の間のステートメントは、1つのステップで実行されます。その後、カーソル位置で実行が停止し、次の停止位置になります。カーソルを置いたコード行に到達しましたが、実行されていないことに注意してください。 詳細については、以下を参照してください。 __TRY, _...", 
"body" : "カーソルまで実行 シンボル： 関数 ：コマンドは、カーソルで示された位置までプログラムを実行します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードであり、プログラムは現在の停止位置（デバッグモード）にあります。また、任意のプログラミングブロックの任意のコード行をカーソルでマークしました。 現在の停止位置とカーソル位置の間のステートメントは、1つのステップで実行されます。その後、カーソル位置で実行が停止し、次の停止位置になります。カーソルを置いたコード行に到達しましたが、実行されていないことに注意してください。 詳細については、以下を参照してください。 __TRY, __CATCH, __FINALLY, __ENDTRY と メニュー" }, 
{ "title" : "コマンド：次のステートメントを設定 ", 
"url" : "_cds_cmd_set_next_statement.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：次のステートメントを設定 ", 
"snippet" : "次のステートメントを設定 シンボル： 関数 ：コマンドは、次に実行されるステートメントを決定します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードであり、プログラムは現在の停止位置（デバッグモード）にあります。また、任意のプログラミングブロックの任意のコード行をカーソルでマークしました。 カーソルでマークされたコード行は、間にステートメントを実行したり、ステートメントがジャンプしたりすることなく、現在のブレーク位置になります。 詳細については、以下を参照してください。 プログラムの段階的な処理（ステップ）...", 
"body" : "次のステートメントを設定 シンボル： 関数 ：コマンドは、次に実行されるステートメントを決定します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードであり、プログラムは現在の停止位置（デバッグモード）にあります。また、任意のプログラミングブロックの任意のコード行をカーソルでマークしました。 カーソルでマークされたコード行は、間にステートメントを実行したり、ステートメントがジャンプしたりすることなく、現在のブレーク位置になります。 詳細については、以下を参照してください。 プログラムの段階的な処理（ステップ）" }, 
{ "title" : "コマンド：次のステートメントを表示 ", 
"url" : "_cds_cmd_show_next_statement.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：次のステートメントを表示 ", 
"snippet" : "次のステートメントを表示 シンボル： 関数 ：コマンドは、次のステップで処理されるプログラムステートメントを表示します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードであり、プログラムは現在の停止位置（デバッグモード）にあります。ホールド位置は、見えないコード行にあります。 このコマンドにより、ウィンドウに現在の停止位置が表示されます。コードでは黄色でアイコンが表示されます。 がマークされ、アクティブになり、停止位置が表示されます。これは、多くのエディターを開いていて、非アクティブなエディターでホールド位置が非表示になっている場合に便利です。 詳細については、以下を参...", 
"body" : "次のステートメントを表示 シンボル： 関数 ：コマンドは、次のステップで処理されるプログラムステートメントを表示します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードであり、プログラムは現在の停止位置（デバッグモード）にあります。ホールド位置は、見えないコード行にあります。 このコマンドにより、ウィンドウに現在の停止位置が表示されます。コードでは黄色でアイコンが表示されます。 がマークされ、アクティブになり、停止位置が表示されます。これは、多くのエディターを開いていて、非アクティブなエディターでホールド位置が非表示になっている場合に便利です。 詳細については、以下を参照してください。 プログラムの段階的な処理（ステップ）" }, 
{ "title" : "コマンド：値を強制する ", 
"url" : "_cds_cmd_force_values.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：値を強制する ", 
"snippet" : "力の値 キーボードショートカット： F7 関数 ：このコマンドは、コントローラー上の変数の値を事前定義された値に永続的に設定します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードです。 コントローラ上で実行されているアプリケーションで変数値が異常に変化すると、制御対象システムの望ましくない動作が発生する可能性があります。 変数値を強制する前に潜在的な危険性を評価し、適切なセキュリティ対策を講じてください。制御するシステムによっては、システムやワークピースに損傷を与えたり、人の健康や生命を危険にさらしたりする可能性があります。 コマンドセットを使用 CODESYS コン...", 
"body" : "力の値 キーボードショートカット： F7 関数 ：このコマンドは、コントローラー上の変数の値を事前定義された値に永続的に設定します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードです。 コントローラ上で実行されているアプリケーションで変数値が異常に変化すると、制御対象システムの望ましくない動作が発生する可能性があります。 変数値を強制する前に潜在的な危険性を評価し、適切なセキュリティ対策を講じてください。制御するシステムによっては、システムやワークピースに損傷を与えたり、人の健康や生命を危険にさらしたりする可能性があります。 コマンドセットを使用 CODESYS コントローラ上のアクティブなアプリケーションの1つ以上の変数を、定義された値に永続的に変更します。 「強制」値は、 マークされたアイコン。 値の強制と準備がどのように機能するかについては、「変数の強制と書き込み」のマンページを参照してください。 コマンド 値を強制する[すべてのアプリ] プロジェクト内のすべてのアプリケーションに影響する、はデフォルトではメニューに含まれていません。 詳細については、以下を参照してください。 変数の強制と書き込み と ウォッチリストを使用する" }, 
{ "title" : "コマンド：値を書き込む ", 
"url" : "_cds_cmd_write_values.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：値を書き込む ", 
"snippet" : "値を書き込む キーボードショートカット： ctrl + F7 関数 ：このコマンドは、コントローラー上の変数の値を事前定義された値に1回設定します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードです。 コントローラ上で実行されているアプリケーションで変数値が異常に変化すると、制御対象システムの望ましくない動作が発生する可能性があります。 変数値を強制する前に潜在的な危険性を評価し、適切なセキュリティ対策を講じてください。制御するシステムによっては、システムやワークピースに損傷を与えたり、人の健康や生命を危険にさらしたりする可能性があります。 このコマンドを使用して、コ...", 
"body" : "値を書き込む キーボードショートカット： ctrl + F7 関数 ：このコマンドは、コントローラー上の変数の値を事前定義された値に1回設定します。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードです。 コントローラ上で実行されているアプリケーションで変数値が異常に変化すると、制御対象システムの望ましくない動作が発生する可能性があります。 変数値を強制する前に潜在的な危険性を評価し、適切なセキュリティ対策を講じてください。制御するシステムによっては、システムやワークピースに損傷を与えたり、人の健康や生命を危険にさらしたりする可能性があります。 このコマンドを使用して、コントローラー上のアクティブなアプリケーションの1つ以上の変数を一度定義された値に設定します。書き込みは、次のサイクルの開始時に1回行われます。 次のように値を準備できます： フィールドをクリックします 準備された価値 宣言部分に新しい値を入力します。ブール変数の場合は、フィールドをクリックするだけで値を変更できます。 FBD \/ LAD \/ ILエディターの実装部分の[インライン監視]フィールドをクリックして、新しい値を入力します。 フィールドをクリックします 準備された価値 監視ウィンドウで、新しい値を入力します。 コマンド 値を書く[すべてのアプリケーション] プロジェクト内のすべてのアプリケーションに影響する、はデフォルトではメニューに含まれていません。 詳細については、以下を参照してください。 変数の強制と書き込み" }, 
{ "title" : "コマンド：すべての値を強制解除します ", 
"url" : "_cds_cmd_unforce_all_values.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：すべての値を強制解除します ", 
"snippet" : "すべての値を強制解除します キーボードショートカット： 年 + F7 関数 ：このコマンドは、すべての変数の強制をリセットします。変数は、コントローラーから実際の値を受け取ります。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードです。 コマンド 強制リストをキャンセル このコマンドと同じ機能がありますが、違いがあります。コマンドの場合 強制リストをキャンセル すべての強制変数に対して実行できなかった場合、メッセージは表示されません。 コントローラ上で実行されているアプリケーションで変数値が異常に変化すると、制御対象システムの望ましくない動作が発生する可能性があります。 ...", 
"body" : "すべての値を強制解除します キーボードショートカット： 年 + F7 関数 ：このコマンドは、すべての変数の強制をリセットします。変数は、コントローラーから実際の値を受け取ります。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードです。 コマンド 強制リストをキャンセル このコマンドと同じ機能がありますが、違いがあります。コマンドの場合 強制リストをキャンセル すべての強制変数に対して実行できなかった場合、メッセージは表示されません。 コントローラ上で実行されているアプリケーションで変数値が異常に変化すると、制御対象システムの望ましくない動作が発生する可能性があります。 変数値を強制する前に潜在的な危険性を評価し、適切なセキュリティ対策を講じてください。制御するシステムによっては、システムやワークピースに損傷を与えたり、人の健康や生命を危険にさらしたりする可能性があります。 コマンド [すべてのアプリケーション]の強制を解除します プロジェクト内のすべてのアプリケーションに影響する、はデフォルトではメニューに含まれていません。 詳細については、以下を参照してください。 力の値 と 変数の強制と書き込み" }, 
{ "title" : "コマンド：<Device.Application>のすべての値を強制します ", 
"url" : "_cds_cmd_force_all_values_of_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：<Device.Application>のすべての値を強制します ", 
"snippet" : "<Device.Application>のすべての値を強制します 関数 ：このコマンドは、選択した<Device.Application>の変数のすべての値を事前定義された値に永続的に設定します。 電話 ： デバイスツリー内のアプリケーションのコンテキストメニュー 選択したアプリケーションのPOUのエディターのコンテキストメニュー 要件 ：アプリケーションはオンラインモードです。 コントローラ上で実行されているアプリケーションで変数値が異常に変化すると、制御対象システムの望ましくない動作が発生する可能性があります。 変数値を強制する前に潜在的な危険性を評価し、適切なセキュリティ対策を講じてくだ...", 
"body" : "<Device.Application>のすべての値を強制します 関数 ：このコマンドは、選択した<Device.Application>の変数のすべての値を事前定義された値に永続的に設定します。 電話 ： デバイスツリー内のアプリケーションのコンテキストメニュー 選択したアプリケーションのPOUのエディターのコンテキストメニュー 要件 ：アプリケーションはオンラインモードです。 コントローラ上で実行されているアプリケーションで変数値が異常に変化すると、制御対象システムの望ましくない動作が発生する可能性があります。 変数値を強制する前に潜在的な危険性を評価し、適切なセキュリティ対策を講じてください。制御するシステムによっては、システムやワークピースに損傷を与えたり、人の健康や生命を危険にさらしたりする可能性があります。 コマンドセットを使用 CODESYS コントローラ上のアクティブなアプリケーションの1つ以上の変数を、定義された値に永続的に変更します。この設定は、処理サイクルの開始時と終了時に行われます。処理シーケンス：1。入力の読み取り、2。値の強制、3。コードの処理、4。値の強制、5。出力の書き込み。 次のように値を準備できます： フィールドをクリックします 準備された価値 宣言部分に新しい値を入力します。ブール変数の場合は、フィールドをクリックするだけで値を変更できます。 FBD \/ LAD \/ ILエディターの実装部分の[インライン監視]フィールドをクリックして、新しい値を入力します。 フィールドをクリックします 準備された価値 監視ウィンドウで、新しい値を入力します。 「強制」値は、 マークされたアイコン。 CODESYS 次のように、ユーザーによって明示的に強制が解除されるまで強制を実行します。 指図 すべての値を強制解除します 指図 '<Device.Application>'のすべての値を強制解除します ダイアログによる力のキャンセル 価値を準備する アプリケーションからログアウトします コマンド 値を強制する[すべてのアプリ] プロジェクト内のすべてのアプリケーションに影響する、はデフォルトではメニューに含まれていません。 詳細については、以下を参照してください。 変数の強制と書き込み" }, 
{ "title" : "コマンド：<Device.Application>のすべての値を書き込みます ", 
"url" : "_cds_cmd_write_all_values_of_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：<Device.Application>のすべての値を書き込みます ", 
"snippet" : "<Device.Application>のすべての値を書き込みます 関数 ：コマンドは、選択した<Device.Application>の変数のすべての値を事前定義された値に一度設定します。 電話 ： デバイスツリー内のアプリケーションのコンテキストメニュー 選択したアプリケーションのPOUのエディターのコンテキストメニュー 要件 ：アプリケーションはオンラインモードです。 コントローラ上で実行されているアプリケーションで変数値が異常に変化すると、制御対象システムの望ましくない動作が発生する可能性があります。 変数値を強制する前に潜在的な危険性を評価し、適切なセキュリティ対策を講じてください。...", 
"body" : "<Device.Application>のすべての値を書き込みます 関数 ：コマンドは、選択した<Device.Application>の変数のすべての値を事前定義された値に一度設定します。 電話 ： デバイスツリー内のアプリケーションのコンテキストメニュー 選択したアプリケーションのPOUのエディターのコンテキストメニュー 要件 ：アプリケーションはオンラインモードです。 コントローラ上で実行されているアプリケーションで変数値が異常に変化すると、制御対象システムの望ましくない動作が発生する可能性があります。 変数値を強制する前に潜在的な危険性を評価し、適切なセキュリティ対策を講じてください。制御するシステムによっては、システムやワークピースに損傷を与えたり、人の健康や生命を危険にさらしたりする可能性があります。 このコマンドを使用して、コントローラーで選択した<Device.Application>の1つ以上の変数を、定義された値に1回設定します。書き込みは、次のサイクルの開始時に1回行われます。 次のように値を準備できます： 宣言部分の準備された値フィールドをクリックして、新しい値を入力します。ブール変数の場合は、フィールドをクリックするだけで値を変更できます。 FBD \/ LAD \/ ILエディターの実装部分の[インライン監視]フィールドをクリックして、新しい値を入力します。 モニターウィンドウの準備された値フィールドをクリックして、新しい値を入力します。 詳細については、以下を参照してください。 変数の強制と書き込み" }, 
{ "title" : "コマンド：<Device.Application>のすべての値を強制解除します ", 
"url" : "_cds_cmd_unforce_all_values_of_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：<Device.Application>のすべての値を強制解除します ", 
"snippet" : "<Device.Application>のすべての値を強制解除します 関数 ：コマンドは、選択した<Device.Application>の変数のすべての値の強制をリセットします。変数は、コントローラーから実際の値を受け取ります。 電話 ： デバイスツリー内のアプリケーションのコンテキストメニュー 選択したアプリケーションのPOUのエディターのコンテキストメニュー 要件 ：アプリケーションはオンラインモードです。 コントローラ上で実行されているアプリケーションで変数値が異常に変化すると、制御対象システムの望ましくない動作が発生する可能性があります。 変数値を強制する前に潜在的な危険性を評価し、...", 
"body" : "<Device.Application>のすべての値を強制解除します 関数 ：コマンドは、選択した<Device.Application>の変数のすべての値の強制をリセットします。変数は、コントローラーから実際の値を受け取ります。 電話 ： デバイスツリー内のアプリケーションのコンテキストメニュー 選択したアプリケーションのPOUのエディターのコンテキストメニュー 要件 ：アプリケーションはオンラインモードです。 コントローラ上で実行されているアプリケーションで変数値が異常に変化すると、制御対象システムの望ましくない動作が発生する可能性があります。 変数値を強制する前に潜在的な危険性を評価し、適切なセキュリティ対策を講じてください。制御するシステムによっては、システムやワークピースに損傷を与えたり、人の健康や生命を危険にさらしたりする可能性があります。 " }, 
{ "title" : "コマンド: フロー制御モードの切り替え ", 
"url" : "_cds_cmd_flowcontrol.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド: フロー制御モードの切り替え ", 
"snippet" : "フロー制御モードの切り替え 関数 ：このコマンドは、フロー制御を有効または無効にします。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードです。 フロー制御を有効にするダイアログでは、フロー制御を適用するタスクをリストボックスから選択できます。デフォルトでは、 タスクを自動的に選択 オプションが選択されています。デバイス ツリーでは、選択したタスクには のマークが付けられます。 フロー制御 。フロー制御モードが有効な場合、 フロー制御タスク → このタスクを選択してください そして フロー制御タスク → タスクを自動的に選択 フロー制御用に別のタスクを選択するために、すべ...", 
"body" : "フロー制御モードの切り替え 関数 ：このコマンドは、フロー制御を有効または無効にします。 電話 ：メニュー デバッグ 要件 ：アプリケーションはオンラインモードです。 フロー制御を有効にするダイアログでは、フロー制御を適用するタスクをリストボックスから選択できます。デフォルトでは、 タスクを自動的に選択 オプションが選択されています。デバイス ツリーでは、選択したタスクには のマークが付けられます。 フロー制御 。フロー制御モードが有効な場合、 フロー制御タスク → このタスクを選択してください そして フロー制御タスク → タスクを自動的に選択 フロー制御用に別のタスクを選択するために、すべてのタスクのコンテキスト メニューのデバイス ツリーでコマンドを使用できます。 アクティブなプロセス制御により、アプリケーションの実行時間が延長されます。 オプションの場合 オンライン操作の確認 通信設定でがアクティブになっている場合、フロー制御がオンになるとメッセージボックスが表示され、それを介してプロセスを中止することができます。 フロー制御がアクティブになっている場合、ブレークポイントの使用とプログラムの段階的な処理はできません。 詳細については、以下を参照してください。 プロセス制御" }, 
{ "title" : "コマンド：表現-2進数、10進数、16進数 ", 
"url" : "_cds_cmd_display_mode.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ デバッグ \/ コマンド：表現-2進数、10進数、16進数 ", 
"snippet" : "表現-2進数、10進数、16進数 関数 ：サブメニューコマンド 描写 オンラインモードで監視するときに値を表示するための形式を設定するために使用されます。 電話 ：メニュー デバッグ 要件 ：プロジェクトはオフラインモードまたはオンラインモードです。 表示形式「Binary」と「Hexadecimal」は符号なし、「Decimal」は符号付きです。 詳細については、以下を参照してください。 プログラミングオブジェクトでのコールモニタリング...", 
"body" : "表現-2進数、10進数、16進数 関数 ：サブメニューコマンド 描写 オンラインモードで監視するときに値を表示するための形式を設定するために使用されます。 電話 ：メニュー デバッグ 要件 ：プロジェクトはオフラインモードまたはオンラインモードです。 表示形式「Binary」と「Hexadecimal」は符号なし、「Decimal」は符号付きです。 詳細については、以下を参照してください。 プログラミングオブジェクトでのコールモニタリング" }, 
{ "title" : "ツール ", 
"url" : "_cds_f_commands_tools.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ツール ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド：パッケージマネージャー ", 
"url" : "_cds_cmd_package_manager.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ツール \/ コマンド：パッケージマネージャー ", 
"snippet" : "パッケージマネージャー シンボル： 関数 ：コマンドはダイアログを開きます パッケージマネージャー 、パッケージをインストール、アンインストール、および管理する場所。 電話 ：メニュー ツール コマンドラインからスタンドアロンアプリケーションとしてパッケージマネージャーを呼び出すこともできます。 すでにインストールされているパッケージ インストールされているパッケージのリスト 姓 、 バージョン 、 インストール日 、 更新情報 、 ライセンス情報 からのパッケージの場合 CODESYS Store International 起源、マーク CODESYS 赤いパッケージアイコンでそれ 黄色の...", 
"body" : "パッケージマネージャー シンボル： 関数 ：コマンドはダイアログを開きます パッケージマネージャー 、パッケージをインストール、アンインストール、および管理する場所。 電話 ：メニュー ツール コマンドラインからスタンドアロンアプリケーションとしてパッケージマネージャーを呼び出すこともできます。 すでにインストールされているパッケージ インストールされているパッケージのリスト 姓 、 バージョン 、 インストール日 、 更新情報 、 ライセンス情報 からのパッケージの場合 CODESYS Store International 起源、マーク CODESYS 赤いパッケージアイコンでそれ 黄色のアイコンの代わりに 。 アップデートが利用可能な場合は、 CODESYS これは、列にエントリがあります 更新情報 とアイコンで の上。 パッケージをインストールする予定の場合は、フラグを付けます CODESYS アイコン付き 。 パッケージがアンインストールを保留している場合、フラグを立てます CODESYS アイコン付き 。 更新するには リストを更新します インストールするには ファイルシステムでパッケージを検索するための標準ダイアログを開きます ファイルタイプはデフォルトで* .packageです。 パッケージの2つのバージョンをインストールすることもできます。 パッケージを選択すると、ダイアログが開きます パッケージの署名を確認する 。 署名情報を含むパッケージがダイアログに表示されます。署名に関する詳細情報は、ツールチップと、パッケージをダブルクリックしたときに開くダイアログに表示されます。 署名されていないパッケージと自己署名されたパッケージを許可する ：パッケージは、署名されていないか自己署名されていますが、インストールする必要があります。 パッケージを選択すると、インストールウィザードが次のダイアログとともに表示されます。 インストール-使用許諾契約 このダイアログでは、 CODESYS また チェックサム パッケージの。 パッケージに使用許諾契約が含まれている場合にのみ表示されます インストールタイプを選択します オプションはパッケージに依存します。 完全なインストール ： CODESYS すべてのコンポーネントをインストールします 通常のインストール ： CODESYS パッケージで定義されているデフォルトのコンポーネントセットをインストールします カスタマイズされたインストール ： CODESYS ダイアログで選択されたコンポーネントをインストールします インストール-ターゲットバージョン ：パッケージのインストールによって更新する既存のターゲットバージョンを選択します。少なくとも1つのバージョンプロファイルを選択する必要があります。 このダイアログが正常に完了すると、選択したパッケージをインストールする準備が整います。パッケージのインストールを自動的に開始して実行するために、すべて CODESYS -インスタンスは閉じられます。 アンインストール 選択したパッケージをアンインストールします いつ バージョンを表示 有効化されていない、アンインストールされている CODESYS 選択したパッケージのすべてのバージョン。 いつ バージョンを表示 が有効になっていて、最上位のパッケージノードを選択した場合はアンインストールされます CODESYS 選択したパッケージのすべてのバージョン。 いつ バージョンを表示 がアクティブ化され、単一のパッケージバージョンを選択した場合はアンインストールされます CODESYS まさにこのバージョン。 この対話が完了すると、誰もが CODESYS インスタンスを閉じて、パッケージのアンインストールを開始します。 詳細 選択したパッケージのダイアログを開きます 詳細 次のタブで： パッケージの詳細 姓 ： パッケージ名 バージョン チェックサム ：パッケージのSHA-1チェックサム プロバイダー 著作権 説明 インストール日 ライセンス契約 インストールログ バックグラウンドで更新を確認します ： CODESYS プログラミングシステムを起動するたびに、その後1時間に1回、更新の検索を自動的に実行します。 バージョンを表示 ：インストールされているパッケージのすべてのバージョンを表示します あなたはすることができます チェックサム 、 CODESYS 対話中 詳細 と対話で インストール-使用許諾契約 パッケージプロバイダーのパッケージチェックサムに対するインストールウィザードの比較。これにより、元のパッケージがインストールされていることが保証されます。 以前のバージョンと同じインストールディレクトリに新しいバージョンのプログラミングシステムをインストールすると、すでにインストールされているパッケージのライセンス情報が保持され、 CODESYS ダイアログに情報を表示します パッケージマネージャー の上。 更新 アップデートを確認する システムとでの検索 CODESYS Store International 選択したパッケージの更新 CODESYS 列に見つかった更新を表示します 更新情報 パッケージリスト。 ダウンロード ダイアログを使用して更新パッケージをインストールします パッケージのダウンロード 対話中 パッケージのダウンロード これを行うには、ボタンをクリックします ダウンロードとインストール 。 評価 パッケージの評価の提出 CODESYS Store International ストアのホームページへのリンク 詳細については、以下を参照してください。 パッケージのインストールとアンインストール" }, 
{ "title" : "コマンド：ライブラリリポジトリ ", 
"url" : "_cds_cmd_library_repository.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ツール \/ コマンド：ライブラリリポジトリ ", 
"snippet" : "ライブラリリポジトリ シンボル： 関数 ：コマンドはダイアログを開きます ライブラリリポジトリ 。このダイアログでは、ローカルシステムにインストールされているため、アプリケーションで使用できるライブラリを指定します。 電話 ：メニュー ツール...", 
"body" : "ライブラリリポジトリ シンボル： 関数 ：コマンドはダイアログを開きます ライブラリリポジトリ 。このダイアログでは、ローカルシステムにインストールされているため、アプリケーションで使用できるライブラリを指定します。 電話 ：メニュー ツール " }, 
{ "title" : "ダイアログ：ライブラリリポジトリ ", 
"url" : "_cds_cmd_library_repository.html#UUID-e51f7153-0441-0423-efa0-7c686a5e982f_id_afbbe45c2ee4c0a8640e008206fd_id_009a224eb32511e3a3e2f1561f0d131d", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ツール \/ コマンド：ライブラリリポジトリ \/ ダイアログ：ライブラリリポジトリ ", 
"snippet" : "位置 ライブラリファイルが配置されているローカルシステム上のディレクトリの表示 このライブラリ 位置 エリアにあります インストールされたライブラリ リストされています。 編集するには ダイアログを開きます リポジトリの場所を編集する 空のディレクトリは、新しいリポジトリにのみ使用できます。 既存のリポジトリを保管場所として使用することもできます。 「システム」リポジトリは編集できません。 CODESYS エントリをイタリック体で示します。 ダイアログ リポジトリの場所を編集する リポジトリのリスト 位置 と 姓 追加 新しいリポジトリを作成します ダイアログを開きます リポジトリの場所 選択...", 
"body" : "位置 ライブラリファイルが配置されているローカルシステム上のディレクトリの表示 このライブラリ 位置 エリアにあります インストールされたライブラリ リストされています。 編集するには ダイアログを開きます リポジトリの場所を編集する 空のディレクトリは、新しいリポジトリにのみ使用できます。 既存のリポジトリを保管場所として使用することもできます。 「システム」リポジトリは編集できません。 CODESYS エントリをイタリック体で示します。 ダイアログ リポジトリの場所を編集する リポジトリのリスト 位置 と 姓 追加 新しいリポジトリを作成します ダイアログを開きます リポジトリの場所 選択したディレクトリ（入力フィールド 位置 ）は空であるか、既存の有効なリポジトリである必要があります。 姓 シンボリックリポジトリ名の入力フィールドです。 編集するには ダイアログを開きます リポジトリの場所 （ご参照ください 追加 ）。 削除する リポジトリのリストからエントリのみを削除するかどうか、またはライブラリファイルを含むディレクトリもファイルシステムから削除するかどうかを尋ねるクエリが表示されます。ディレクトリを削除する場合は、これを確認する必要があります。 インストールされたライブラリ ツリー構造のライブラリのリスト カテゴリ、名前、会社、バージョンを含む各ライブラリのプレゼンテーション 前のアイコンから、ライブラリがデジタルであるかどうかを確認できます 署名または 署名されていません。 会社 表示されたライブラリをフィルタリングするための選択リスト インストールするには ダイアログを開きます ライブラリを選択 可能なフィルター： 翻訳済み CODESYS ライブラリ（* .compiled-library） 編集済み CODESYS ライブラリ (*.compiled-library、*.compiled-library-v3) ライブラリ（* .library） まだ翻訳されていない図書館プロジェクトの場合 すべてのファイル （*。*） アンインストール 選択したライブラリをアンインストールします 輸出 ライブラリプロジェクトをローカルファイルシステムに保存するための標準ダイアログを開きます ファイルタイプは Bibliotheken (*.library) 、 Übersetzte Bibliotheken (*.compiled-library) また Übersetzte Bibliotheken (*.compiled-library-v3) 。 検索 ライブラリと関数ブロックを検索します ダイアログを開きます 検索ライブラリ 入力フィールドに文字列を入力すると、 CODESYS 一致するライブラリが見つかりました。 詳細 選択したバージョンのライブラリのダイアログを開きます 詳細 図書館のプロジェクト情報からの詳細 ボタンについて もっと 対話中 詳細 また、次の情報を受け取ります。 サイズ ：バイト単位で指定 生成された ： 作成日 かわった ：最終変更日 最終アクセス ： 日にち 属性 プロパティ 依存関係 選択したライブラリのダイアログを開きます 依存関係 他のライブラリの依存関係を表示する 各ライブラリリファレンスについて タイトル 、 バージョン と 会社 表示されます。ワイルドカードを介して機能する参照は、構文によって次のようになります。 #<Platzhaltername> 示されています。 カテゴリ別にグループ化 ：ライブラリカテゴリによるグループ化 ：アルファベット順 カテゴリは、外部記述ファイル「* .libcat.xml」によって定義されます。 ライブラリプロファイル ライブラリプロファイルは、どのライブラリバージョンで使用するかを定義します CODESYS プロジェクトに特定のコンパイラバージョンが設定されている場合、ライブラリプレースホルダーを解決します。 輸入 1つインポートする *.libraryprofile -ファイル インポートにすでにプレースホルダーエントリが含まれている場合は、 CODESYS これは上書きする必要があります。 輸出 拡張子が「 .libraryprofile 「選択したプレースホルダーエントリの割り当て 1つのエントリを1つ作成することもできます コンパイラバージョン 選択する。 プレースホルダーの解像度は、現在使用されているターゲットデバイスで定義することも、ライブラリマネージャーのプレースホルダーダイアログの特定のローカル仕様で定義することもできます。 コンパイラのバージョンが 3.5.18.0 未満のプロジェクトをロードする場合は、適切なバージョンの CODESYS をインストールし、それを使用してプロジェクトを開始すると有利です。 詳細については、以下を参照してください。 ライブラリマネージャー と ライブラリ参照変換" }, 
{ "title" : "コマンド: ライセンス マネージャー ", 
"url" : "_cds_cmd_license_manager.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ツール \/ コマンド: ライセンス マネージャー ", 
"snippet" : "ライセンス マネージャー シンボル： 関数 : コマンドは、ライセンスを設定するためのウィザードを開きます。 CODESYS アドオン製品。ウィザードは ライセンス マネージャー – ターゲットの選択 ダイアログ。 電話 : ツール メニュー ライセンスマネージャは、以下のライセンスを処理できます。 CODESYS ローカル コンピューター上のアドオン製品、およびデバイス上のランタイム アドオン製品のライセンス。ソフト コンテナーとドングルの両方のインストールをサポートします。 製品サブスクリプションのライセンス更新は自動的に行われます。現在のライセンスステータスは、 ライセンス マネージャー...", 
"body" : "ライセンス マネージャー シンボル： 関数 : コマンドは、ライセンスを設定するためのウィザードを開きます。 CODESYS アドオン製品。ウィザードは ライセンス マネージャー – ターゲットの選択 ダイアログ。 電話 : ツール メニュー ライセンスマネージャは、以下のライセンスを処理できます。 CODESYS ローカル コンピューター上のアドオン製品、およびデバイス上のランタイム アドオン製品のライセンス。ソフト コンテナーとドングルの両方のインストールをサポートします。 製品サブスクリプションのライセンス更新は自動的に行われます。現在のライセンスステータスは、 ライセンス マネージャー 。 " }, 
{ "title" : "ダイアログ: ライセンス マネージャー – ターゲットの選択 ", 
"url" : "_cds_cmd_license_manager.html#UUID-4c91bfd0-6e5a-4a63-c33f-74e8df7f1048_id_ede5cbc7f814a56fc0a8640e0110cfc6_id_c2501cd1580911e887f0cb8e1905b970", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ツール \/ コマンド: ライセンス マネージャー \/ ダイアログ: ライセンス マネージャー – ターゲットの選択 ", 
"snippet" : "これは、ライセンス マネージャー ウィザードの開始ダイアログです。ここで、ライセンスをインストールする場所を決定します。 ワークステーション ローカルコンピュータ デバイス コントローラ ライセンス操作を実行するには、このデバイスへの接続を正しく構成する必要があります（ 通信設定 タブ)。 クリック後 次 ライセンスを管理するコンテナーを決定します。...", 
"body" : "これは、ライセンス マネージャー ウィザードの開始ダイアログです。ここで、ライセンスをインストールする場所を決定します。 ワークステーション ローカルコンピュータ デバイス コントローラ ライセンス操作を実行するには、このデバイスへの接続を正しく構成する必要があります（ 通信設定 タブ)。 クリック後 次 ライセンスを管理するコンテナーを決定します。 " }, 
{ "title" : "ダイアログ: ライセンス マネージャー – コンテナーの選択 ", 
"url" : "_cds_cmd_license_manager.html#UUID-4c91bfd0-6e5a-4a63-c33f-74e8df7f1048_id_ede5cbc7f814a56fc0a8640e0110cfc6_id_427f0789b3f411e3b5a0cccd02e48994", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ツール \/ コマンド: ライセンス マネージャー \/ ダイアログ: ライセンス マネージャー – コンテナーの選択 ", 
"snippet" : "ドングル 対応するドングルをコンピューターまたはデバイスに接続する必要があります。すべてのデバイスがドングルをサポートしているわけではありません。 ソフトコンテナ CODESYS セキュリティキー 対応するソフトコンテナをCodeMeterコントロールセンターに登録する必要があります。 CODESYS インストールによりソフトコンテナが提供されます。 製品をローカルコンピュータにインストールする場合（ ワークステーション ）、 そうして ライセンス マネージャー ドングルまたはソフトコンテナの特定の選択と次のアクションのためのウィンドウがすぐに開きます。これはコンテナの種類を選択してクリックし...", 
"body" : "ドングル 対応するドングルをコンピューターまたはデバイスに接続する必要があります。すべてのデバイスがドングルをサポートしているわけではありません。 ソフトコンテナ CODESYS セキュリティキー 対応するソフトコンテナをCodeMeterコントロールセンターに登録する必要があります。 CODESYS インストールによりソフトコンテナが提供されます。 製品をローカルコンピュータにインストールする場合（ ワークステーション ）、 そうして ライセンス マネージャー ドングルまたはソフトコンテナの特定の選択と次のアクションのためのウィンドウがすぐに開きます。これはコンテナの種類を選択してクリックした後に発生します。 次 。 コントローラのアドオン製品のライセンスを取得する場合は、クリックするとネットワーク内のデバイスを選択するためのダイアログが最初に開きます。 次 ダイアログは、 通信設定 デバイス エディターのタブ。 " }, 
{ "title" : "ダイアログ: ライセンス マネージャー – 概要 ", 
"url" : "_cds_cmd_license_manager.html#UUID-4c91bfd0-6e5a-4a63-c33f-74e8df7f1048_id_ede5cbc7f814a56fc0a8640e0110cfc6_id_9842496a67cfbaa3c0a864630673a51d", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ツール \/ コマンド: ライセンス マネージャー \/ ダイアログ: ライセンス マネージャー – 概要 ", 
"snippet" : "ライセンス インストールされているすべてのリスト CODESYS ライセンスの対象となり、コンピューターまたはデバイス上にある製品。ライセンスがコンテナから提供される場合、コンテナはライセンス リストのノードとして表示されます。 先頭に追加された記号は、ライセンスがコンピューターに存在し、有効であるかどうかを示します。 ウィンドウの右側には、選択した製品と対応するライセンスに関する次の情報が表示されます。 名前 会社 ユニットカウンター ライセンス数 使用期間 機能マップ 起動時間 有効期限 企業コード 製品コード 説明 ライセンスのインストール 開く <コンピュータ> にライセンスをインスト...", 
"body" : "ライセンス インストールされているすべてのリスト CODESYS ライセンスの対象となり、コンピューターまたはデバイス上にある製品。ライセンスがコンテナから提供される場合、コンテナはライセンス リストのノードとして表示されます。 先頭に追加された記号は、ライセンスがコンピューターに存在し、有効であるかどうかを示します。 ウィンドウの右側には、選択した製品と対応するライセンスに関する次の情報が表示されます。 名前 会社 ユニットカウンター ライセンス数 使用期間 機能マップ 起動時間 有効期限 企業コード 製品コード 説明 ライセンスのインストール 開く <コンピュータ> にライセンスをインストールする – 操作を選択 ダイアログ： ライセンスを有効化 : 開く <コンピュータ> にライセンスをインストール – ライセンスをアクティブ化 ダイアログ（詳細は下記を参照） ライセンスをリクエスト : 開く <コンピュータ> にライセンスをインストールする – ライセンスをリクエスト ダイアログ（詳細は下記を参照） ライセンスのインストール : 開く <コンピュータ> にライセンスをインストール – ライセンスのインストール ダイアログ（詳細は下記を参照） 追加機能 次のアクションを含むメニューを開きます。 ウィンク : コンピュータ上のそれぞれのライセンス ドングルが点滅します。 ライセンスの返却 : 開く ライセンスの返却 （詳細は下記を参照） ライセンスを復元 : この機能はデバイスライセンスの場合にのみ使用できます。 ライセンスの復元 ダイアログ（詳細は下記を参照） コンテナの更新 : 検出されたすべてのコンテナを含むリスト ボックスが再度作成されます。 <コンピュータ> にライセンスをインストール – ライセンスをアクティブ化 これは、インターネット接続がある場合にライセンス サーバー経由で利用可能なライセンスをアクティブ化するための推奨される方法です。要件: コンピューターがインターネットに接続されていること。 チケットID ソフトウェアベンダーから受け取ったチケットIDの入力フィールド チケット ID は 5 つのブロックで構成され、各ブロックには 5 文字の英数字が含まれます。 例： LYSQ3-ZU93K-24LWC-XGWJ8-5AY7H ライセンスサーバー 製品をアクティベートするためのライセンスを提供するライセンスサーバーのリストボックス サーバーの URL はソフトウェア ベンダーから取得します。 容器 ライセンスをインストールするコンテナまたはドングルのリスト ボックス。 リポジトリからチケットを選択 開く ライセンスリポジトリ ダイアログ 次 CODESYS ライセンス サーバーへの接続を確立します。 指定されたチケットにライセンスが 1 つだけ含まれている場合は、サーバー アクションの完了後にアクティベーションが成功したことを確認するダイアログが開きます。 指定されたチケットに複数のライセンスが含まれている場合、 ライセンスのインストール – ライセンスの選択 これらのライセンスのリストを含むダイアログが開きます (下記の説明を参照)。 ライセンスのインストール – ライセンスの選択 チケットにアクティブ化するライセンスの選択 ライセンスのインストール – ライセンスの有効化 ダイアログ 名前 商品名 利用可能 利用可能なライセンスの数 使用済み 使用ライセンス数 合計 使用済みおよび利用可能なライセンスの合計 次 CODESYS ライセンス サーバーへの接続を確立します。サーバー アクションが正常に完了すると、アクティベーションの確認を示すダイアログが開きます。 <コンピュータ> にライセンスをインストールする – ライセンスをリクエスト コンピュータがインターネットに接続されていない場合は、このダイアログを使用してコンテキスト ファイルを生成できます。このファイル (WibuCmRaC) は、インターネット対応のコンピュータを介してライセンス サーバーに送信されます。アクティベーションが完了すると、ライセンス更新ファイル (WibuCmRaU) がダウンロード用に提供されます。 ソフトウェアベンダー 製品をアクティベートするためのライセンスを提供したソフトウェアベンダーからの企業コードの入力フィールド あるいは、リスト ボックスからソフトウェア ベンダーを選択することもできます。 容器 コンテキスト ファイルを生成するコンテナーまたはドングルのリスト ボックス。 コンテキストファイル 場所と名前 <コンピュータ> にライセンスをインストール – ライセンスのインストール ソフトウェアのアクティベーション中にインターネットからライセンス更新ファイルをダウンロードした場合は、このダイアログを使用してライセンスをドングルにインストールできます。これを行うには、目的のコンテナまたはドングルを指定します。 容器 入力フィールドにライセンス更新ファイルのパスを指定します。 ファイル 。 ライセンスの返却 ライセンスが許可している場合は、ライセンスを「返却」して、後で別のコンピューターで再アクティブ化することができます。 チケットID ライセンスに使用されたチケットIDを指定するフィールド ライセンスサーバー 製品をアクティベートするためのライセンスを提供するライセンスサーバーを選択するためのリストボックス サーバーの URL はソフトウェア ベンダーから取得します。 ライセンスをロードする 指定されたチケットIDに対してサーバーにインストールされている現在のライセンスをすべて表示するボタン。 ライセンス 窓 ライセンス 指定されたチケット ID に対してサーバー上で利用可能なライセンスのリスト 選択したライセンスに関する次の情報が、右側のウィンドウの横に表示されます。 名前 アクティベーション数 返品可能 アクティベーションタイプ 有効化日 企業コード コメント ライセンスの返却 選択したライセンスを返却するためのボタン これらは、別のシステムで再度アクティブ化できます。 ライセンスのインストール – ライセンスの復元 有効化されると、デバイスライセンスはファイルに保存されます（ *.WibuCmRau ）と「 CODESYS 「中央ライセンス サーバー」。紛失した場合は、このファイルから同一のデバイスに復元できます。 この手順は、128 で始まり、CodeMeter Embedded を使用するライセンスに対してのみ機能します。 CODESYS Control for BeagleBone CODESYS Control for emPC-A\/iMX6 CODESYS Control for IOT2000 CODESYS Control for PFC100 CODESYS Control for PFC200 CODESYS Control for PLCnext CODESYS Control for Raspberry Pi CODESYS Control for WAGO​ Touch Panel 600​ 130... で始まる新しい UFC ベースのライセンスについては、次を参照してください。 Wibu SL ライセンスのバックアップと復元 チケットID すでに実行されたライセンスに使用されたチケットIDを指定するフィールド 復元する 対応するライセンス バックアップ ファイルが見つかった場合、デバイス内でライセンスが再アクティブ化されます。 詳細については、以下を参照してください。 ライセンスリポジトリ" }, 
{ "title" : "コマンド：ライセンスリポジトリ ", 
"url" : "_cds_cmd_license_repository.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ツール \/ コマンド：ライセンスリポジトリ ", 
"snippet" : "ライセンスリポジトリ シンボル： 関数 ：コマンドはダイアログを開きます ライセンスリポジトリ 個々のライセンスに関する情報を表示します。 電話 ：メニュー ツール 要件 ： CODESYS オフラインまたはオンラインモードです。 ライセンスリポジトリでは、チケット番号を入力すると、中央のライセンスサーバーから関連するライセンスに関する情報を受け取ります。 クリップボードからチケット番号を貼り付けるか、テキストファイルからインポートすることができます。 切符売場 <リポジトリにインポートされたライセンス管理コンポーネントチケットIDのリスト> ライセンス チケットリストでエントリを選択すると、...", 
"body" : "ライセンスリポジトリ シンボル： 関数 ：コマンドはダイアログを開きます ライセンスリポジトリ 個々のライセンスに関する情報を表示します。 電話 ：メニュー ツール 要件 ： CODESYS オフラインまたはオンラインモードです。 ライセンスリポジトリでは、チケット番号を入力すると、中央のライセンスサーバーから関連するライセンスに関する情報を受け取ります。 クリップボードからチケット番号を貼り付けるか、テキストファイルからインポートすることができます。 切符売場 <リポジトリにインポートされたライセンス管理コンポーネントチケットIDのリスト> ライセンス チケットリストでエントリを選択すると、ライセンスされたコンポーネントの名前とステータスがここに表示されます。 ：ライセンスは利用可能で有効です。 ：ライセンスが見つかりましたが、無効です。 ：ライセンスが見つかりませんでした。 ダイアログの右側に、このライセンスに関する次の情報が表示されます。 姓 ：ライセンスされる製品の名前 商品番号 ：ライセンスサーバーの記事番号 返品可 ：このライセンスを非アクティブ化して、別のシステムで再度アクティブ化できるようにすることができます。 有効 ：ライセンスマネージャを介してライセンスをアクティブ化できます。 アクティベーションの数 ：以前のアクティベーション数 アクティベーション日 ：現在のアクティベーションの日付 コンテナのシリアル番号 会社コード コメント チケットをインポートする ローカルファイルシステムを参照するための標準ダイアログが表示されます。 1つ以上の「チケット」、つまりライセンス番号を含むテキストファイルを開くと、これらはリポジトリにインポートされます。または、クリップボードの番号をリストに貼り付けることもできます。 詳細については、以下を参照してください。 パッケージとライセンスの管理 と ライセンス マネージャー" }, 
{ "title" : "コマンド：デバイスリポジトリ ", 
"url" : "_cds_cmd_device_repository.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ツール \/ コマンド：デバイスリポジトリ ", 
"snippet" : "デバイスリポジトリ シンボル： 関数 ：コマンドはダイアログを開きます デバイスリポジトリ 。このダイアログは、ローカルシステムおよびにインストールされているデバイスを管理するために使用されます CODESYS -プロジェクトを統合することができます。 電話 ：メニュー ツール...", 
"body" : "デバイスリポジトリ シンボル： 関数 ：コマンドはダイアログを開きます デバイスリポジトリ 。このダイアログは、ローカルシステムおよびにインストールされているデバイスを管理するために使用されます CODESYS -プロジェクトを統合することができます。 電話 ：メニュー ツール " }, 
{ "title" : "ダイアログ：デバイスリポジトリ ", 
"url" : "_cds_cmd_device_repository.html#UUID-c7973f6f-9c3e-2045-8831-d042c5a98295_id_ad0cf3f4f3c53320c0a8640e00a42838_id_8c4c14bcb0f111e3bd3cdc72696803d0", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ツール \/ コマンド：デバイスリポジトリ \/ ダイアログ：デバイスリポジトリ ", 
"snippet" : "内部デバイスリポジトリを手動で変更しないでください。 リポジトリや他の場所からファイルをコピーすることはできません。デバイスをインストールまたはアンインストールするには、常にデバイスリポジトリダイアログを使用する必要があります。 位置 ローカルシステム上のデバイスリポジトリディレクトリの表示 選択リストには、現在構成されている保管場所が表示されます。デフォルトで設定 CODESYS インストールされたシステムリポジトリ。選択した場所のデバイスがスコープに表示されます インストールされているデバイスの説明 リストされています。 編集するには ダイアログを開きます リポジトリの場所を変更する ダイ...", 
"body" : "内部デバイスリポジトリを手動で変更しないでください。 リポジトリや他の場所からファイルをコピーすることはできません。デバイスをインストールまたはアンインストールするには、常にデバイスリポジトリダイアログを使用する必要があります。 位置 ローカルシステム上のデバイスリポジトリディレクトリの表示 選択リストには、現在構成されている保管場所が表示されます。デフォルトで設定 CODESYS インストールされたシステムリポジトリ。選択した場所のデバイスがスコープに表示されます インストールされているデバイスの説明 リストされています。 編集するには ダイアログを開きます リポジトリの場所を変更する ダイアログ リポジトリの場所を変更する リポジトリのリスト 位置 と 姓 追加 新しいリポジトリを作成します ダイアログを開きます リポジトリの場所 選択したディレクトリ（入力フィールド 位置 ）は空であるか、既存の有効なリポジトリである必要があります。 編集するには ダイアログを開きます リポジトリの場所 （ご参照ください 追加） 削除する 対応するディレクトリもハードディスクから削除する必要があるかどうかを尋ねるクエリが表示されます。 インストールされているデバイスの説明 マルチレベルツリー構造のデバイス記述のリスト 各デバイスの説明のプレゼンテーション 姓 、 メーカー と バージョン 最上位ノードは、コントローラ、フィールドバス、論理デバイスなどのデバイスカテゴリを表します。 すべてのデバイスでの全文検索の文字列 このフィールドをクリックすると、編集可能になります。文字列を入力すると、文字列を含むデバイスのみが下のウィンドウに表示されます。これらのデバイスでは、一致する文字列が黄色で強調表示されます。 メーカー 利用可能なデバイスが表示されているメーカーの選択リスト インストールするには ダイアログを開きます デバイスの説明をインストールします ファイルタイプ「.devdesc.xml」のデフォルトデバイスの場合 PROFIBUSDPモジュール用の「* gsd」ファイル、CANデバイス用の* .edsおよびdcfファイルなど、メーカー固有の記述ファイルを選択することもできます。 で選択した場合 わかった 追加を確認 CODESYS デバイスリポジトリに新しいデバイスを入力します。インストール中にエラーが発生しました（デバイスの説明で参照されているファイルが見つからないなど）。 CODESYS デバイスリポジトリダイアログの下部にあります。 アンインストール 選択したデバイスをアンインストールします デバイスリポジトリからデバイスを削除すると、プログラミングシステムで使用できなくなります。 デバイスリポジトリを更新する デバイスリポジトリ内のすべてのデバイスを更新します インポートプラグインの新しいバージョンが利用可能になると、一部のデバイスの説明が古くなる可能性があります。影響を受けるデバイスには記号が付いています マークされた。このコマンドは、更新を確認するためのダイアログを開きます。 不足している説明をダウンロードする デバイスリポジトリに存在しないデバイスをプロジェクトで使用すると表示されます コマンドを実行すると、不足しているデバイスのリストが表示されます。そこで、ダウンロードに適したデバイスを選択できます。 詳細 ダイアログを開きます 詳細 選択したデバイスの説明 ダイアログには、デバイス記述ファイルからの追加情報が含まれています。 インストール中にコピーされます CODESYS デバイス記述ファイルと、それらによって内部保管場所に参照される追加ファイル。これは、元のファイルへの変更がインストールされたデバイスに影響を与えなくなることを意味します。このような変更を有効にするには、デバイスを再インストールする必要があります。変更後は、デバイスの説明の内部バージョン番号を変更することをお勧めします。 " }, 
{ "title" : "コマンド：カスタマイズ ", 
"url" : "_cds_cmd_customize.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ツール \/ コマンド：カスタマイズ ", 
"snippet" : "調整 関数 ：コマンドはダイアログを開きます 調整 。このダイアログでは、メニュー、ツールバー、およびキーボードレイアウトを個々の要件に適合させます。 電話 ：メニュー ツール 詳細については、以下を参照してください。 メニューをカスタマイズする...", 
"body" : "調整 関数 ：コマンドはダイアログを開きます 調整 。このダイアログでは、メニュー、ツールバー、およびキーボードレイアウトを個々の要件に適合させます。 電話 ：メニュー ツール 詳細については、以下を参照してください。 メニューをカスタマイズする" }, 
{ "title" : "コマンド：オプション ", 
"url" : "_cds_cmd_options.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ツール \/ コマンド：オプション ", 
"snippet" : "オプション 関数 ：コマンドはダイアログを開きます オプション を構成するには CODESYS -オプション。これらのオプションは、の動作と外観を定義します CODESYS -ユーザーインターフェース。 CODESYS ローカルシステムの現在のユーザープロファイルの設定を保存します。現在のプロファイルはデフォルト設定を提供します。 電話 ：メニュー ツール...", 
"body" : "オプション 関数 ：コマンドはダイアログを開きます オプション を構成するには CODESYS -オプション。これらのオプションは、の動作と外観を定義します CODESYS -ユーザーインターフェース。 CODESYS ローカルシステムの現在のユーザープロファイルの設定を保存します。現在のプロファイルはデフォルト設定を提供します。 電話 ：メニュー ツール " }, 
{ "title" : "コマンド：インポートおよびエクスポートオプション ", 
"url" : "_cds_cmd_import_export_options.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ツール \/ コマンド：インポートおよびエクスポートオプション ", 
"snippet" : "インポートおよびエクスポートオプション 関数 ：コマンドはダイアログを開きます インポートおよびエクスポートオプション 。ここでは、の選択した設定をエクスポートまたはインポートできます CODESYS -オプションを構成します。設定は、デフォルトの拡張子を持つXMLファイルにエクスポートされます options.xml 保存しました。 電話 ：メニュー ツール...", 
"body" : "インポートおよびエクスポートオプション 関数 ：コマンドはダイアログを開きます インポートおよびエクスポートオプション 。ここでは、の選択した設定をエクスポートまたはインポートできます CODESYS -オプションを構成します。設定は、デフォルトの拡張子を持つXMLファイルにエクスポートされます options.xml 保存しました。 電話 ：メニュー ツール " }, 
{ "title" : "ダイアログ：インポートおよびエクスポートオプション ", 
"url" : "_cds_cmd_import_export_options.html#UUID-25bc3cff-9cbf-00c6-2e4e-eb5e83058ec6_id_f16f26eccdc7cec0a864631a9a7d9e_id_290c9402ed02fe4ec0a864633381844a", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ツール \/ コマンド：インポートおよびエクスポートオプション \/ ダイアログ：インポートおよびエクスポートオプション ", 
"snippet" : "選択したオプションをエクスポート オプションを選択 ：表では、現在の設定をXMLファイルにエクスポートする必要があるマシン（コンピューター）またはユーザー関連のオプションのカテゴリーを選択できます。 ファイル ：ローカルファイルシステム内のエクスポートファイルのパス 例： D:\\system1.options.xml ボタン ：ローカルファイルシステムで既存のファイルを検索したり、新しいファイルを作成したりするための標準ダイアログを開きます the ファイルの種類 Optionenexport (*.options.xml) プリセットされています。 選択したオプションをインポートする ファイ...", 
"body" : "選択したオプションをエクスポート オプションを選択 ：表では、現在の設定をXMLファイルにエクスポートする必要があるマシン（コンピューター）またはユーザー関連のオプションのカテゴリーを選択できます。 ファイル ：ローカルファイルシステム内のエクスポートファイルのパス 例： D:\\system1.options.xml ボタン ：ローカルファイルシステムで既存のファイルを検索したり、新しいファイルを作成したりするための標準ダイアログを開きます the ファイルの種類 Optionenexport (*.options.xml) プリセットされています。 選択したオプションをインポートする ファイル ：コンテンツがインポートされるオプションエクスポートファイルのパス ボタン ：タイプのファイルを検索するための標準ダイアログを開きます Optionenexport (*.options.xml) ローカルファイルシステムで でダイアログを閉じた後 わかった ファイルに記述されている設定がプロジェクトに転送されます。 詳細については、以下を参照してください。 CODESYS" }, 
{ "title" : "コマンド:インストール設定をエクスポート ", 
"url" : "_cds_cmd_export_installation_configuration.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ツール \/ コマンド:インストール設定をエクスポート ", 
"snippet" : "インストール構成をエクスポート ファンクション : このコマンドは現在の設定ファイルをエクスポートします。 CODESYS 次の形式のファイルへのインストール .installation-config 。エクスポートファイルには、のバージョンに関する情報が含まれています CODESYS およびインストールされているアドオン。 デフォルトでは、インストール設定はプロジェクトアーカイブに含まれています。プロジェクトアーカイブは、 ファイル → プロジェクトアーカイブ → アーカイブを保存 コマンド。 コール : ツール メニュー...", 
"body" : "インストール構成をエクスポート ファンクション : このコマンドは現在の設定ファイルをエクスポートします。 CODESYS 次の形式のファイルへのインストール .installation-config 。エクスポートファイルには、のバージョンに関する情報が含まれています CODESYS およびインストールされているアドオン。 デフォルトでは、インストール設定はプロジェクトアーカイブに含まれています。プロジェクトアーカイブは、 ファイル → プロジェクトアーカイブ → アーカイブを保存 コマンド。 コール : ツール メニュー " }, 
{ "title" : "コマンド：デバイスライセンスリーダー ", 
"url" : "_cds_cmd_device_reader.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ツール \/ コマンド：デバイスライセンスリーダー ", 
"snippet" : "デバイスライセンスリーダー 関数 ：コマンドは標準ダイアログを開きます デバイスを選択 コントロールを選択した後、このコントロールのライセンスと製品情報を読み取ります。このライセンスと製品情報はダイアログに表示されます デバイスライセンスリーダー 表示されます。 電話 ：メニュー ツール 要件 ：コントローラにアプリケーションはありません。 コントローラにアプリケーションがあるにもかかわらずコマンドが選択された場合、ユーザーはダイアログですべてのアプリケーションをコントローラから削除するかどうかを尋ねられます。ユーザーがこのダイアログをクリックした場合 いいえ クリック、コマンド デバイスライ...", 
"body" : "デバイスライセンスリーダー 関数 ：コマンドは標準ダイアログを開きます デバイスを選択 コントロールを選択した後、このコントロールのライセンスと製品情報を読み取ります。このライセンスと製品情報はダイアログに表示されます デバイスライセンスリーダー 表示されます。 電話 ：メニュー ツール 要件 ：コントローラにアプリケーションはありません。 コントローラにアプリケーションがあるにもかかわらずコマンドが選択された場合、ユーザーはダイアログですべてのアプリケーションをコントローラから削除するかどうかを尋ねられます。ユーザーがこのダイアログをクリックした場合 いいえ クリック、コマンド デバイスライセンスリーダー キャンセル。 ダイアログ デバイスライセンスリーダー 利用可能なデバイス機能のステータス 製品 CODESYS -製品 例： SoftMotion 特徴 の特徴 製品 例： CNC は 特徴 から SoftMotion 。 ライセンスアクティブ\/番号 Yes ：この機能のライセンスを利用できます。 No ：この機能のライセンスはありません。 量 ：ライセンス数 " }, 
{ "title" : "窓 ", 
"url" : "_cds_f_commands_window.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド：次のエディター ", 
"url" : "_cds_cmd_next_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ コマンド：次のエディター ", 
"snippet" : "次の編集者 キーボードショートカット： ctrl + F6 関数 ：このコマンドは、フォーカスを現在アクティブなウィンドウから次のウィンドウに切り替えます。 「次の」ウィンドウは、現在アクティブなウィンドウの右側にタブがあるウィンドウです。 電話 ：メニュー 窓 要件 ：少なくとも1つのエディターが開いています。...", 
"body" : "次の編集者 キーボードショートカット： ctrl + F6 関数 ：このコマンドは、フォーカスを現在アクティブなウィンドウから次のウィンドウに切り替えます。 「次の」ウィンドウは、現在アクティブなウィンドウの右側にタブがあるウィンドウです。 電話 ：メニュー 窓 要件 ：少なくとも1つのエディターが開いています。 " }, 
{ "title" : "コマンド：前のエディター ", 
"url" : "_cds_cmd_previous_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ コマンド：前のエディター ", 
"snippet" : "前の編集者 キーボードショートカット： トグル + ctrl + F6 関数 ：このコマンドは、フォーカスを現在アクティブなウィンドウから前のウィンドウに切り替えます。 「前の」ウィンドウは、タブが現在アクティブなウィンドウの左側にあるウィンドウです。 電話 ：メニュー 窓 要件 ：少なくとも1つのエディターが開いています。...", 
"body" : "前の編集者 キーボードショートカット： トグル + ctrl + F6 関数 ：このコマンドは、フォーカスを現在アクティブなウィンドウから前のウィンドウに切り替えます。 「前の」ウィンドウは、タブが現在アクティブなウィンドウの左側にあるウィンドウです。 電話 ：メニュー 窓 要件 ：少なくとも1つのエディターが開いています。 " }, 
{ "title" : "コマンド：すべてのエディターを閉じます ", 
"url" : "_cds_cmd_close_all_editors.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ コマンド：すべてのエディターを閉じます ", 
"snippet" : "すべてのエディターを閉じる シンボル： 関数 ：このコマンドは、現在開いているすべてのエディターウィンドウを閉じます。 電話 ：メニュー 窓 要件 ：少なくとも1つのエディターが開いています。...", 
"body" : "すべてのエディターを閉じる シンボル： 関数 ：このコマンドは、現在開いているすべてのエディターウィンドウを閉じます。 電話 ：メニュー 窓 要件 ：少なくとも1つのエディターが開いています。 " }, 
{ "title" : "コマンド：非アクティブなアプリケーションのすべてのエディターを閉じます ", 
"url" : "_cds_cmd_close_all_editors_of_inactive_applications.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ コマンド：非アクティブなアプリケーションのすべてのエディターを閉じます ", 
"snippet" : "非アクティブなアプリケーションのすべてのエディターを閉じる 関数 ：このコマンドは、現在非アクティブなアプリケーションのすぐ下にあるオブジェクトのすべてのエディターウィンドウを閉じます。 POUビューオブジェクトのエディタは開いたままです。 電話 ：メニュー 窓 要件 ：非アクティブなアプリケーションの少なくとも1つのエディターが開いています。...", 
"body" : "非アクティブなアプリケーションのすべてのエディターを閉じる 関数 ：このコマンドは、現在非アクティブなアプリケーションのすぐ下にあるオブジェクトのすべてのエディターウィンドウを閉じます。 POUビューオブジェクトのエディタは開いたままです。 電話 ：メニュー 窓 要件 ：非アクティブなアプリケーションの少なくとも1つのエディターが開いています。 " }, 
{ "title" : "コマンド：ウィンドウレイアウトをリセット ", 
"url" : "_cds_cmd_reset_window_layout.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ コマンド：ウィンドウレイアウトをリセット ", 
"snippet" : "ウィンドウレイアウトをリセット 関数 ：このコマンドは、現在開いているすべてのウィンドウとビューをデフォルトの位置にリセットします。コマンドを実行する前に、コマンドを確認する必要があります。 電話 ：メニュー ツール...", 
"body" : "ウィンドウレイアウトをリセット 関数 ：このコマンドは、現在開いているすべてのウィンドウとビューをデフォルトの位置にリセットします。コマンドを実行する前に、コマンドを確認する必要があります。 電話 ：メニュー ツール " }, 
{ "title" : "コマンド：新しい水平タブグループ ", 
"url" : "_cds_cmd_new_horizontal_tab_group.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ コマンド：新しい水平タブグループ ", 
"snippet" : "新しい水平タブグループ シンボル： 関数 ：このコマンドは、現在アクティブなウィンドウを、既存のウィンドウの下にある新しい別のタブグループに移動します。 電話 ：メニュー 窓 、タブのコンテキストメニュー 要件 ：複数のエディタウィンドウがタブページとして隣り合って配置されています。 エディターで別のオブジェクトを開くと、フォーカスのあるタブグループに自動的に配置されます。...", 
"body" : "新しい水平タブグループ シンボル： 関数 ：このコマンドは、現在アクティブなウィンドウを、既存のウィンドウの下にある新しい別のタブグループに移動します。 電話 ：メニュー 窓 、タブのコンテキストメニュー 要件 ：複数のエディタウィンドウがタブページとして隣り合って配置されています。 エディターで別のオブジェクトを開くと、フォーカスのあるタブグループに自動的に配置されます。 " }, 
{ "title" : "コマンド：新しい垂直タブグループ ", 
"url" : "_cds_cmd_new_vertical_tab_group.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ コマンド：新しい垂直タブグループ ", 
"snippet" : "新しい垂直タブグループ シンボル： 関数 ：このコマンドは、現在アクティブなウィンドウを、既存のウィンドウの右側にある新しい別のタブグループに移動します。 電話 ：メニュー 窓 、タブのコンテキストメニュー 要件 ：複数のエディタウィンドウがタブページとして隣り合って配置されています。 エディターで別のオブジェクトを開くと、フォーカスのあるタブグループに自動的に配置されます。...", 
"body" : "新しい垂直タブグループ シンボル： 関数 ：このコマンドは、現在アクティブなウィンドウを、既存のウィンドウの右側にある新しい別のタブグループに移動します。 電話 ：メニュー 窓 、タブのコンテキストメニュー 要件 ：複数のエディタウィンドウがタブページとして隣り合って配置されています。 エディターで別のオブジェクトを開くと、フォーカスのあるタブグループに自動的に配置されます。 " }, 
{ "title" : "コマンド：フローティング ", 
"url" : "_cds_cmd_window_float.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ コマンド：フローティング ", 
"snippet" : "フローティング 関数 ：このコマンドは、ユーザーインターフェイスのフレームにドッキング（固定）されているウィンドウをフレームからドッキング解除し、フローティングウィンドウとして画面に配置するために使用されます。 電話 ：メニュー 窓 要件 ：アプリケーションはオンラインモードです。 このウィンドウは、ユーザーインターフェイスの外部に配置することもできます。フローティングウィンドウをユーザーインターフェイスフレームに再バインドするには、次のコマンドを使用します ドッキング 。...", 
"body" : "フローティング 関数 ：このコマンドは、ユーザーインターフェイスのフレームにドッキング（固定）されているウィンドウをフレームからドッキング解除し、フローティングウィンドウとして画面に配置するために使用されます。 電話 ：メニュー 窓 要件 ：アプリケーションはオンラインモードです。 このウィンドウは、ユーザーインターフェイスの外部に配置することもできます。フローティングウィンドウをユーザーインターフェイスフレームに再バインドするには、次のコマンドを使用します ドッキング 。 " }, 
{ "title" : "コマンド：ドック ", 
"url" : "_cds_cmd_window_dock.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ コマンド：ドック ", 
"snippet" : "ドッキング 関数 ：コマンドは、コマンドの前にあるウィンドウを開くのに役立ちます フローティング ドッキングが解除され、UIフレームに「ドッキング」するための画面上のフローティングウィンドウになりました。 電話 ：メニュー 窓...", 
"body" : "ドッキング 関数 ：コマンドは、コマンドの前にあるウィンドウを開くのに役立ちます フローティング ドッキングが解除され、UIフレームに「ドッキング」するための画面上のフローティングウィンドウになりました。 電話 ：メニュー 窓 " }, 
{ "title" : "コマンド：非表示 ", 
"url" : "_cds_cmd_window_autohide.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ コマンド：非表示 ", 
"snippet" : "隠れる キーボードショートカット： F7 関数 ：このコマンドは、ウィンドウを「非表示または表示」するために使用されます。 電話 ：メニュー 窓 「隠す」とは CODESYS ウィンドウには、ユーザーインターフェイスのフレームに複数のタブのみが表示され、このタブの上にマウスを移動したときにのみ表示されます。コマンドはオプションとして機能します。つまり、ウィンドウが非表示の場合、メニューの前にチェックマークが付いて表示されます。コマンドをもう一度クリックすると、チェックマークが削除され、ウィンドウが再度表示されます。...", 
"body" : "隠れる キーボードショートカット： F7 関数 ：このコマンドは、ウィンドウを「非表示または表示」するために使用されます。 電話 ：メニュー 窓 「隠す」とは CODESYS ウィンドウには、ユーザーインターフェイスのフレームに複数のタブのみが表示され、このタブの上にマウスを移動したときにのみ表示されます。コマンドはオプションとして機能します。つまり、ウィンドウが非表示の場合、メニューの前にチェックマークが付いて表示されます。コマンドをもう一度クリックすると、チェックマークが削除され、ウィンドウが再度表示されます。 " }, 
{ "title" : "コマンド：次のペイン ", 
"url" : "_cds_cmd_next_pane.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ コマンド：次のペイン ", 
"snippet" : "次のペイン キーボードショートカット： F6 関数 ：このコマンドは、フォーカスを次のペインに設定します。 電話 ：メニュー 窓 要件 ：2つ以上のペインを含むオブジェクトが開いています。 例：STエディターでオブジェクトを開き、カーソルが宣言ウィンドウにある場合、コマンドはフォーカスを実装部分に設定します。...", 
"body" : "次のペイン キーボードショートカット： F6 関数 ：このコマンドは、フォーカスを次のペインに設定します。 電話 ：メニュー 窓 要件 ：2つ以上のペインを含むオブジェクトが開いています。 例：STエディターでオブジェクトを開き、カーソルが宣言ウィンドウにある場合、コマンドはフォーカスを実装部分に設定します。 " }, 
{ "title" : "コマンド：前のペイン ", 
"url" : "_cds_cmd_previous_pane.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ コマンド：前のペイン ", 
"snippet" : "前のペイン キーボードショートカット： トグル + F6 関数 ：このコマンドは、フォーカスを前のペインに設定します。 電話 ：メニュー 窓 要件 ：2つ以上のペインを含むオブジェクトが開いています。 例：STエディターでオブジェクトを開き、カーソルが宣言ウィンドウにある場合、コマンドはフォーカスを実装部分に設定します。...", 
"body" : "前のペイン キーボードショートカット： トグル + F6 関数 ：このコマンドは、フォーカスを前のペインに設定します。 電話 ：メニュー 窓 要件 ：2つ以上のペインを含むオブジェクトが開いています。 例：STエディターでオブジェクトを開き、カーソルが宣言ウィンドウにある場合、コマンドはフォーカスを実装部分に設定します。 " }, 
{ "title" : "コマンド：最初の部分ビューを切り替えます ", 
"url" : "_cds_cmd_toggle_first_pane.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ コマンド：最初の部分ビューを切り替えます ", 
"snippet" : "最初の部分ビューを切り替えます キーボードショートカット： 年 + F6 関数 ：コマンドは宣言ウィンドウを表示\/非表示にします。 電話 ：メニュー 窓 要件 ：カーソルは、次のいずれかのオブジェクトのエディタにあります。 POU トランジット 方法 プロパティのアクセサメソッドを取得する プロパティのアクセサメソッドを設定する 視覚化 ボタンを使用して部分ビューを編集することもできます スイッチ。...", 
"body" : "最初の部分ビューを切り替えます キーボードショートカット： 年 + F6 関数 ：コマンドは宣言ウィンドウを表示\/非表示にします。 電話 ：メニュー 窓 要件 ：カーソルは、次のいずれかのオブジェクトのエディタにあります。 POU トランジット 方法 プロパティのアクセサメソッドを取得する プロパティのアクセサメソッドを設定する 視覚化 ボタンを使用して部分ビューを編集することもできます スイッチ。 " }, 
{ "title" : "コマンド：2番目の部分ビューを切り替えます ", 
"url" : "_cds_cmd_toggle_second_pane.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ コマンド：2番目の部分ビューを切り替えます ", 
"snippet" : "2番目の部分ビューを切り替えます 関数 ：コマンドは、展開ウィンドウを表示\/非表示にします。 電話 ：メニュー 窓 要件 ：カーソルは、次のいずれかのオブジェクトのエディタにあります。 POU トランジット 方法 プロパティのアクセサメソッドを取得する プロパティのアクセサメソッドを設定する 視覚化 ボタンを使用して部分ビューを編集することもできます スイッチ。...", 
"body" : "2番目の部分ビューを切り替えます 関数 ：コマンドは、展開ウィンドウを表示\/非表示にします。 電話 ：メニュー 窓 要件 ：カーソルは、次のいずれかのオブジェクトのエディタにあります。 POU トランジット 方法 プロパティのアクセサメソッドを取得する プロパティのアクセサメソッドを設定する 視覚化 ボタンを使用して部分ビューを編集することもできます スイッチ。 " }, 
{ "title" : "コマンド：ウィンドウ ", 
"url" : "_cds_cmd_window.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ コマンド：ウィンドウ ", 
"snippet" : "窓 関数 ：コマンドはダイアログを開きます 窓 、開いているすべてのオブジェクトが表示されます。その中のウィンドウをアクティブ化または閉じることができます。 電話 ：メニュー 窓...", 
"body" : "窓 関数 ：コマンドはダイアログを開きます 窓 、開いているすべてのオブジェクトが表示されます。その中のウィンドウをアクティブ化または閉じることができます。 電話 ：メニュー 窓 " }, 
{ "title" : "コマンド：これ以外のすべてのエディターを閉じます ", 
"url" : "_cds_cmd_close_all_editor_but_this.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ コマンド：これ以外のすべてのエディターを閉じます ", 
"snippet" : "これ以外のすべてのエディターを閉じます 関数 ：このコマンドは、現在のウィンドウを除くすべてのエディタウィンドウを閉じます。 電話 ：タブのコンテキストメニュー 要件 ：少なくとも2つのオブジェクトが開いています。...", 
"body" : "これ以外のすべてのエディターを閉じます 関数 ：このコマンドは、現在のウィンドウを除くすべてのエディタウィンドウを閉じます。 電話 ：タブのコンテキストメニュー 要件 ：少なくとも2つのオブジェクトが開いています。 " }, 
{ "title" : "コマンド：ナビゲーターでオブジェクトを選択します ", 
"url" : "_cds_cmd_select_object_in_navigator.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ コマンド：ナビゲーターでオブジェクトを選択します ", 
"snippet" : "ナビゲーターでオブジェクトを選択します 関数 ：このコマンドは、デバイスツリーでアクティブなエディタのオブジェクトを選択します。 電話 ：タブのコンテキストメニュー 要件 ：少なくとも1つのオブジェクトが開いています。 デバイスツリーでオプションを選択すると、このコマンドが自動的に実行されます アクティブなエディタを追跡する 活性化。...", 
"body" : "ナビゲーターでオブジェクトを選択します 関数 ：このコマンドは、デバイスツリーでアクティブなエディタのオブジェクトを選択します。 電話 ：タブのコンテキストメニュー 要件 ：少なくとも1つのオブジェクトが開いています。 デバイスツリーでオプションを選択すると、このコマンドが自動的に実行されます アクティブなエディタを追跡する 活性化。 " }, 
{ "title" : "コマンド：ナビゲーターで親オブジェクトを選択します ", 
"url" : "_cds_cmd_select_parent_object_in_navigator.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ コマンド：ナビゲーターで親オブジェクトを選択します ", 
"snippet" : "ナビゲーターで親オブジェクトを選択します 関数 ：このコマンドは、デバイスツリーで親オブジェクトを選択します。 電話 ：タブのコンテキストメニュー 要件 ：少なくとも1つのオブジェクトが開いています。...", 
"body" : "ナビゲーターで親オブジェクトを選択します 関数 ：このコマンドは、デバイスツリーで親オブジェクトを選択します。 電話 ：タブのコンテキストメニュー 要件 ：少なくとも1つのオブジェクトが開いています。 " }, 
{ "title" : "サブメニューコマンド：ウィンドウ ", 
"url" : "_cds_cmd_window_n.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 窓 \/ サブメニューコマンド：ウィンドウ ", 
"snippet" : "関数 ：コマンドは選択したウィンドウをアクティブにします 電話 ：メニュー 窓 開いているエディタウィンドウごとに、[ウィンドウ]メニューにコマンドが含まれています <n> <オブジェクト名> 、これを介してウィンドウをアクティブにします。つまり、そこにフォーカスを設定します。オフラインモードでは、CODESYSはコマンドの後に拡張子を追加します （オフライン） 。ファンクションブロックの場合、拡張子（Impl）または <インスタンスパス 追加した。...", 
"body" : "関数 ：コマンドは選択したウィンドウをアクティブにします 電話 ：メニュー 窓 開いているエディタウィンドウごとに、[ウィンドウ]メニューにコマンドが含まれています <n> <オブジェクト名> 、これを介してウィンドウをアクティブにします。つまり、そこにフォーカスを設定します。オフラインモードでは、CODESYSはコマンドの後に拡張子を追加します （オフライン） 。ファンクションブロックの場合、拡張子（Impl）または <インスタンスパス 追加した。 " }, 
{ "title" : "ヘルプ ", 
"url" : "_cds_f_commands_help.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ヘルプ ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド: CODESYS ヘルプ ", 
"url" : "_cds_cmd_content.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ヘルプ \/ コマンド: CODESYS ヘルプ ", 
"snippet" : "CODESYS ヘルプ シンボル： キーボードショートカット： ctrl + トグル + F1 関数 ：コマンドは CODESYS -ヘルプ。 電話 ：メニュー ヘルプ に応じて オフラインヘルプの代わりにオンラインヘルプを使用する オプションを選択すると、オンラインヘルプまたはオフラインヘルプが開きます。...", 
"body" : "CODESYS ヘルプ シンボル： キーボードショートカット： ctrl + トグル + F1 関数 ：コマンドは CODESYS -ヘルプ。 電話 ：メニュー ヘルプ に応じて オフラインヘルプの代わりにオンラインヘルプを使用する オプションを選択すると、オンラインヘルプまたはオフラインヘルプが開きます。 " }, 
{ "title" : "コマンド:インストールされているサードパーティパッケージのヘルプ ", 
"url" : "_cds_cmd_3rd_party_help.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ヘルプ \/ コマンド:インストールされているサードパーティパッケージのヘルプ ", 
"snippet" : "インストールされているサードパーティパッケージのヘルプ シンボル： 機能 : このコマンドは、ファイルエクスプローラーで ...\\Online Help\\<language code>\\   ディレクトリを開きます。 電話 : ヘルプ メニュー 要件 : CHM オフラインヘルプディレクトリには、お客様固有の CHM ヘルプファイルが含まれています。 このコマンドは、CODESYS ユーザーインターフェイスから顧客固有の CHM ヘルプファイルにアクセスできるようにするために使用されます。その後、Windows CHM ビューアーを使用してヘルプファイルを開くことができます CODESYS S...", 
"body" : "インストールされているサードパーティパッケージのヘルプ シンボル： 機能 : このコマンドは、ファイルエクスプローラーで ...\\Online Help\\<language code>\\   ディレクトリを開きます。 電話 : ヘルプ メニュー 要件 : CHM オフラインヘルプディレクトリには、お客様固有の CHM ヘルプファイルが含まれています。 このコマンドは、CODESYS ユーザーインターフェイスから顧客固有の CHM ヘルプファイルにアクセスできるようにするために使用されます。その後、Windows CHM ビューアーを使用してヘルプファイルを開くことができます CODESYS SP21 の標準インストールには、古いCHMヘルプファイルを提供する追加アドオンが含まれています. これらのファイルも ...\\Online Help\\<language code>\\ ディレクトリに保存される. このディレクトリに追加の顧客固有のCHMファイルが保存されていない限り、コマンドは非アクティブのままです。 ザル CODESYS CHM ビューアーは SP21 では使用できなくなりました。CHM ファイルをマージすることはできなくなりました 追加の HTML ヘルプページを、に統合することができます。 CODESYS オフラインヘルプ。詳細については、以下を参照してください。 独自のコンテンツでCODESYSオフラインヘルプを拡張" }, 
{ "title" : "コマンド：CODESYSホームページ ", 
"url" : "_cds_cmd_homepage.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ヘルプ \/ コマンド：CODESYSホームページ ", 
"snippet" : "CODESYSホームページ 関数 ：コマンドはのホームページを開きます CODESYS GmbH 。 電話 ：メニュー ヘルプ...", 
"body" : "CODESYSホームページ 関数 ：コマンドはのホームページを開きます CODESYS GmbH 。 電話 ：メニュー ヘルプ " }, 
{ "title" : "コマンド：情報 ", 
"url" : "_cds_cmd_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ヘルプ \/ コマンド：情報 ", 
"snippet" : "情報 関数 : コマンドにより、スプラッシュ画面が開き、 CODESYS バージョンと著作権。さらに、バージョン、ライセンス、確認事項に関する詳細情報を表示するボタンも用意されています。 電話 ：メニュー ヘルプ バージョン情報 ダイアログを開きます 詳細なバージョン情報 のリストで CODESYS -オペレーティングシステムに関するコンポーネントと情報 ライセンス情報 ダイアログを開きます ライセンス情報 プラグイン\/コンポーネント ：ライセンス情報を表示するプラグインの選択リスト ソフトウェアライセンス ：選択したライセンス情報 プラグイン\/コンポーネント ありがとう ダイアログ: 詳細な...", 
"body" : "情報 関数 : コマンドにより、スプラッシュ画面が開き、 CODESYS バージョンと著作権。さらに、バージョン、ライセンス、確認事項に関する詳細情報を表示するボタンも用意されています。 電話 ：メニュー ヘルプ バージョン情報 ダイアログを開きます 詳細なバージョン情報 のリストで CODESYS -オペレーティングシステムに関するコンポーネントと情報 ライセンス情報 ダイアログを開きます ライセンス情報 プラグイン\/コンポーネント ：ライセンス情報を表示するプラグインの選択リスト ソフトウェアライセンス ：選択したライセンス情報 プラグイン\/コンポーネント ありがとう ダイアログ: 詳細なバージョン情報 プログラミングシステム プログラミング システムのバージョンに関する情報 次の情報を含むコンポーネントのリスト 成分 : コンポーネントの名前 バージョン : コンポーネントのバージョン アドオン : コンポーネントを含むアドオン オペレーティング·システム オペレーティング システムに関する情報 アドオン署名情報 選択したコンポーネントの署名情報 輸出 詳細なバージョン情報をテキスト ファイルとしてエクスポートします ( *.txt ) または他の形式 " }, 
{ "title" : "ライブラリ ", 
"url" : "_cds_f_commands_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ライブラリ ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド：ライブラリを追加 ", 
"url" : "_cds_cmd_add_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ライブラリ \/ コマンド：ライブラリを追加 ", 
"snippet" : "ライブラリを追加 関数 ：コマンドはダイアログを開きます ライブラリを追加 。このダイアログでは、ライブラリをライブラリマネージャーに追加して、アプリケーションに統合できます。 電話 ：メニュー ライブラリ 要件 ：ライブラリマネージャーがエディターで開いています。...", 
"body" : "ライブラリを追加 関数 ：コマンドはダイアログを開きます ライブラリを追加 。このダイアログでは、ライブラリをライブラリマネージャーに追加して、アプリケーションに統合できます。 電話 ：メニュー ライブラリ 要件 ：ライブラリマネージャーがエディターで開いています。 " }, 
{ "title" : "ダイアログ：ライブラリを追加 ", 
"url" : "_cds_cmd_add_library.html#UUID-b7d5aeaf-fe0d-cacd-4cbd-07b0b70036cd_id_cab383442a7a332cc0a8640e00d16ef2_id_c6de462e2a8098cdc0a8640e00eeb4e2", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ライブラリ \/ コマンド：ライブラリを追加 \/ ダイアログ：ライブラリを追加 ", 
"snippet" : "ライブラリリストの上の行で、適切な文字列を入力して、ライブラリ名またはライブラリブロックを検索できます。 図書館 ライブラリリポジトリにインストールされているすべてのライブラリ 表示されるライブラリは、デフォルトでカテゴリにグループ化されています。 会社 図書館プロバイダー 高度 拡張ダイアログを開きます ライブラリを追加 表示されるライブラリは、カテゴリにグループ化されています。 表示されるライブラリはアルファベット順にリストされています。 特定のライブラリは、デバイスのデバイスの説明で「ブラックリストに登録されている」とマークできます。これらのライブラリは、このデバイスの下のライブラリマネ...", 
"body" : "ライブラリリストの上の行で、適切な文字列を入力して、ライブラリ名またはライブラリブロックを検索できます。 図書館 ライブラリリポジトリにインストールされているすべてのライブラリ 表示されるライブラリは、デフォルトでカテゴリにグループ化されています。 会社 図書館プロバイダー 高度 拡張ダイアログを開きます ライブラリを追加 表示されるライブラリは、カテゴリにグループ化されています。 表示されるライブラリはアルファベット順にリストされています。 特定のライブラリは、デバイスのデバイスの説明で「ブラックリストに登録されている」とマークできます。これらのライブラリは、このデバイスの下のライブラリマネージャに追加することはできません。 詳細については、以下を参照してください。 ライブラリリポジトリ" }, 
{ "title" : "コマンド：ライブラリをリロードしてみてください ", 
"url" : "_cds_cmd_reload_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ライブラリ \/ コマンド：ライブラリをリロードしてみてください ", 
"snippet" : "ライブラリをリロードしてみてください 関数 ：コマンドは、選択したライブラリを再ロードしようとします。 電話 ：メニュー ライブラリ 要件 ：ロードに失敗したライブラリが選択されています。 プロジェクトを開いたときに、何らかの理由で定義されたリポジトリパスでライブラリが利用できない場合は、 CODESYS 対応するエラーメッセージ。 エラーを修正した後、つまりライブラリが再び適切に使用可能になった後、プロジェクトを離れることなく、コマンドを使用してこのライブラリを再ロードできます。 詳細については、以下を参照してください。 ライブラリリポジトリ...", 
"body" : "ライブラリをリロードしてみてください 関数 ：コマンドは、選択したライブラリを再ロードしようとします。 電話 ：メニュー ライブラリ 要件 ：ロードに失敗したライブラリが選択されています。 プロジェクトを開いたときに、何らかの理由で定義されたリポジトリパスでライブラリが利用できない場合は、 CODESYS 対応するエラーメッセージ。 エラーを修正した後、つまりライブラリが再び適切に使用可能になった後、プロジェクトを離れることなく、コマンドを使用してこのライブラリを再ロードできます。 詳細については、以下を参照してください。 ライブラリリポジトリ" }, 
{ "title" : "コマンド：プロパティ ", 
"url" : "_cds_cmd_library_properties.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ライブラリ \/ コマンド：プロパティ ", 
"snippet" : "プロパティ 関数 ：コマンドはダイアログを開きます プロパティ ライブラリマネージャで選択されたライブラリの場合。 電話 メニュー ライブラリ 選択したライブラリのコンテキストメニュー シンボル ライブラリマネージャーツールバー 要件 ：ライブラリが選択されています。 このダイアログは、ライブラリ開発者を対象としています。ライブラリの参照について深い知識があり、ライブラリ開発者のガイドラインに必ず従っている場合にのみ使用してください。 詳細については、以下を参照してください。 ライブラリ開発者向けの情報...", 
"body" : "プロパティ 関数 ：コマンドはダイアログを開きます プロパティ ライブラリマネージャで選択されたライブラリの場合。 電話 メニュー ライブラリ 選択したライブラリのコンテキストメニュー シンボル ライブラリマネージャーツールバー 要件 ：ライブラリが選択されています。 このダイアログは、ライブラリ開発者を対象としています。ライブラリの参照について深い知識があり、ライブラリ開発者のガイドラインに必ず従っている場合にのみ使用してください。 詳細については、以下を参照してください。 ライブラリ開発者向けの情報" }, 
{ "title" : "ダイアログ：プロパティ ", 
"url" : "_cds_cmd_library_properties.html#UUID-15f672ba-ddd7-126d-50f4-2ed64e8a9235_id_addd92672ae0c16bc0a8640e011af5c6_id_6803d930a6c811e4a21c94779d6b67d7", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ライブラリ \/ コマンド：プロパティ \/ ダイアログ：プロパティ ", 
"snippet" : "全般的 名前空間 選択したライブラリの名前空間 ライブラリの作成時にプロジェクト情報で明示的に定義されていない限り、通常はライブラリ名と同じです。 （現在開いている）プロジェクトの名前空間を変更できます。 例： LA ディフォルト 他の解決策が定義されていない、または不可能な場合にプレースホルダーを解決するライブラリ 要件：選択したライブラリがライブラリプレースホルダーである場合、設定を使用できます。 注：コンパイラバージョン3.5.8.0以降は、デバイスの説明に解決策があるライブラリプレースホルダーに適用されますが、ビューのライブラリマネージャーに適用されます。 POU 嘘：このプレースホル...", 
"body" : "全般的 名前空間 選択したライブラリの名前空間 ライブラリの作成時にプロジェクト情報で明示的に定義されていない限り、通常はライブラリ名と同じです。 （現在開いている）プロジェクトの名前空間を変更できます。 例： LA ディフォルト 他の解決策が定義されていない、または不可能な場合にプレースホルダーを解決するライブラリ 要件：選択したライブラリがライブラリプレースホルダーである場合、設定を使用できます。 注：コンパイラバージョン3.5.8.0以降は、デバイスの説明に解決策があるライブラリプレースホルダーに適用されますが、ビューのライブラリマネージャーに適用されます。 POU 嘘：このプレースホルダーは、アプリケーションがコンパイルされるデバイスの説明に従って常に自動的に解決されます。 選択したライブラリが「ライブラリ開発ガイドライン」に従って開発された場合、以下の設定を変更することはお勧めしません。 バージョン 強制バージョンの選択 要件：選択したライブラリの場合のみ いいえ ライブラリプレースホルダー、設定が利用可能です。 注：コンテナーおよびインターフェース・ライブラリーは、対応するバージョン制約のあるライブラリー参照を使用して自動的に作成されます。それ以外の場合は、可能であれば、強制バージョンのライブラリ参照を含むライブラリを作成せず、プレースホルダーを使用してライブラリを参照します。ダイアログでプレースホルダー解決を使用できます プレースホルダー 編集します。 正確なバージョン ：バージョン（選択リストから選択）は、プロジェクトに永続的に統合されています。 注：このオプションは、コンテナー・ライブラリーに強く推奨されており、通常、このタイプのライブラリーのデフォルトです。 常に最新バージョン ：ライブラリリポジトリが検索され、そこで見つかった最新バージョンが含まれます。 注：新しいバージョンのライブラリーが使用可能な場合、実際に使用されるライブラリー・ブロックが変更される可能性があります。このオプションは、インターフェイスライブラリに強く推奨され、通常、このタイプのライブラリに事前設定されています。 視認性 すべての識別子への修飾されたアクセスのみを許可します。 ：ライブラリブロック（および変数）は、先行する名前空間パスを持つプロジェクトでのみ呼び出されます。 現在のプロジェクトが別のプロジェクトのライブラリとして参照されている場合 注：プロジェクトでライブラリを作成していて、ライブラリプロジェクトを開いている場合にのみ、次の設定を変更するのが理にかなっています。選択したライブラリは、新しいライブラリで参照されます。 この参照がここに直接含まれているかのように、すべてのIECシンボルをプロジェクトに表示します。 ：選択したライブラリは、参照されているライブラリのトップレベル（トップレベル）のコンテンツをコンテナライブラリとして（プロジェクトの後半で）表示します。 要件：ライブラリプロジェクトを使用してコンテナライブラリを作成します。コンテナライブラリは、独自のビルディングブロックを実装せず、他のライブラリのみを参照するライブラリです。ライブラリをバンドルします。コンテナライブラリを使用して、複数のライブラリを（1つの参照で）プロジェクトに統合できます。各ライブラリリファレンスについて に着いた このオプションを有効にする必要があります。 ライブラリブロックへのシンボリックアクセス： <Namensraum Containerbibliothek>.<Bausteinname> ：参照されるライブラリのコンテンツは、名前空間を介して一意にアドレス指定できます。パス名は、ライブラリの名前とそれ自体の名前（ライブラリ参照）で構成され、ブロック名の前に配置されます。 要件：ライブラリプロジェクトで作成する なし コンテナライブラリ。 この参照を依存関係ツリーに表示しないでください。 ：選択したライブラリは、ライブラリマネージャでライブラリ参照として（後でプロジェクトで）表示されません。ライブラリは非表示で参照されます。 警告：非表示のライブラリのエラーが原因でコンパイルエラーが発生した場合、デバッグが困難になる可能性があります。 ：選択したライブラリが（プロジェクトの後半で）ライブラリ参照として表示されます。 オプション（ライブラリが欠落している場合、エラーはスローされません）。 ： ：選択したライブラリはオプションとして扱われます。ライブラリがライブラリリポジトリにある場合でも、ライブラリを参照するプロジェクトをロードしてもエラーは発生しません いいえ 利用可能です。 詳細については、以下を参照してください。 プレースホルダー" }, 
{ "title" : "コマンド：ワイルドカード ", 
"url" : "_cds_cmd_placeholder.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ライブラリ \/ コマンド：ワイルドカード ", 
"snippet" : "プレースホルダー 関数 ：コマンドはダイアログを開きます プレースホルダー 。ダイアログには、選択したプレースホルダーライブラリに関する情報が表示され、プロジェクトに特に有効な解像度を割り当てることができます。 コンパイル操作は、常に特定のアプリケーションに対して行われます。このためには、ライブラリ マネージャに存在するライブラリ エントリに対して実際に使用可能なライブラリが必要です。プロジェクトのさまざまなライブラリ マネージャーでのプレースホルダーの解決 (アプリケーション、 POU プール) は複雑な操作です。解決の結果は、コンパイル プロセス中にのみ表示され、ライブラリ マネージャーの...", 
"body" : "プレースホルダー 関数 ：コマンドはダイアログを開きます プレースホルダー 。ダイアログには、選択したプレースホルダーライブラリに関する情報が表示され、プロジェクトに特に有効な解像度を割り当てることができます。 コンパイル操作は、常に特定のアプリケーションに対して行われます。このためには、ライブラリ マネージャに存在するライブラリ エントリに対して実際に使用可能なライブラリが必要です。プロジェクトのさまざまなライブラリ マネージャーでのプレースホルダーの解決 (アプリケーション、 POU プール) は複雑な操作です。解決の結果は、コンパイル プロセス中にのみ表示され、ライブラリ マネージャーのプレースホルダー情報から事前に確実に読み取ることはできません。 電話 ： メニュー ライブラリ シンボル LibraryManagerウィンドウの上部にあるツールバー 未解決のライブラリに関するエラー メッセージが表示された場合の Quickfix コマンド。 詳細については、次を参照してください。 メッセージ. コンパイラ バージョン 3.5.18.0 以降では、プレースホルダーの解決でライブラリ プロファイルが無視されます。プレースホルダーは「フリー プレースホルダー」になります。 要件 ： の中に ライブラリマネージャー プレースホルダーライブラリが選択されています。 ビューの下のプレースホルダーライブラリ 装置 含まれているは、次のように解決されます。 ダイアログでプレースホルダーライブラリに特別な解決策を指定した場合 プレースホルダー 割り当てられ、これが採用されます。 特別な解像度が指定されていない場合は、アプリケーションのデバイスの説明で解像度が指定されているかどうかがチェックされます。 次に、ライブラリプロファイルで解像度が指定されているかどうかがチェックされます。 のライブラリ マネージャのプレースホルダ テーブル POU 意見 結果は以下のライブラリマネージャーに表示されます。 有効なバージョン 。これに関する情報は、 アイコン。どの解決手順も成功しなかった場合、ライブラリには次のフラグが立てられます。 (未解決) そしてライブラリはコンパイルに含まれません。 ライブラリ プレースホルダの詳細については、次を参照してください。 ライブラリの使用ライブラリ開発者向けの情報ライブラリ プレースホルダーの更新プロパティLibDev概要 " }, 
{ "title" : "ダイアログ：プレースホルダー ", 
"url" : "_cds_cmd_placeholder.html#UUID-98becf1f-bedf-8e6a-baab-8f7e3b147e27_id_c70a2add81efc0a8640e016d5a59_id_4450599b767011e6b248ef4427d74153", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ライブラリ \/ コマンド：ワイルドカード \/ ダイアログ：プレースホルダー ", 
"snippet" : "姓 プレースホルダーの識別子 図書館 プロジェクトの現在の解像度 エントリをダブルクリックして、プレースホルダーの解像度を編集します。ライブラリの利用可能なバージョンの選択リストが表示されます。コマンドも表示されます その他の図書館 。 指図 他の図書館 対話 ライブラリを検索 ライブラリの検索とインストール用に開きます。別のバージョンではなく、特別なライブラリにリダイレクトするコマンドを選択します。 情報 プレースホルダー解決のタイプ デバイスの説明で解決 ライセンスメカニズムによって解決 ライブラリプロファイルによって解決 <専門図書館>により解決 すべての未解決のバインドされていないプレ...", 
"body" : "姓 プレースホルダーの識別子 図書館 プロジェクトの現在の解像度 エントリをダブルクリックして、プレースホルダーの解像度を編集します。ライブラリの利用可能なバージョンの選択リストが表示されます。コマンドも表示されます その他の図書館 。 指図 他の図書館 対話 ライブラリを検索 ライブラリの検索とインストール用に開きます。別のバージョンではなく、特別なライブラリにリダイレクトするコマンドを選択します。 情報 プレースホルダー解決のタイプ デバイスの説明で解決 ライセンスメカニズムによって解決 ライブラリプロファイルによって解決 <専門図書館>により解決 すべての未解決のバインドされていないプレースホルダーを最新の利用可能なバージョンに設定します ライブラリ マネージャーでまだ解決されていないプレースホルダー ライブラリを解決するために、利用可能な最新バージョンが指定されます。 " }, 
{ "title" : "コマンド：ライブラリのエクスポート ", 
"url" : "_cds_cmd_export_library.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ ライブラリ \/ コマンド：ライブラリのエクスポート ", 
"snippet" : "ライブラリのエクスポート 関数 ：このコマンドは、ライブラリファイルをディスクに保存するためのものです。 電話 ：メニュー ライブラリ 、ライブラリマネージャーのコンテキストメニュー 要件 ：ライブラリマネージャでライブラリが選択されています。 このコマンドは、ローカルファイルシステムにファイルを保存するための標準ダイアログを開きます。ライブラリファイルは、ファイルタイプにすることができます Bibliotheken (*.library) 、 Übersetzte Bibliotheken (*.compiled-library) また Übersetzte Bibliotheken (*....", 
"body" : "ライブラリのエクスポート 関数 ：このコマンドは、ライブラリファイルをディスクに保存するためのものです。 電話 ：メニュー ライブラリ 、ライブラリマネージャーのコンテキストメニュー 要件 ：ライブラリマネージャでライブラリが選択されています。 このコマンドは、ローカルファイルシステムにファイルを保存するための標準ダイアログを開きます。ライブラリファイルは、ファイルタイプにすることができます Bibliotheken (*.library) 、 Übersetzte Bibliotheken (*.compiled-library) また Übersetzte Bibliotheken (*.compiled-library-v3) 持つため。 詳細については、以下を参照してください。 ライブラリファイルのエクスポート" }, 
{ "title" : "宣言 ", 
"url" : "_cds_f_commands_declarations.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 宣言 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド：貼り付け ", 
"url" : "_cds_cmd_insert.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 宣言 \/ コマンド：貼り付け ", 
"snippet" : "入れる シンボル： 関数 ：コマンドは、表形式の宣言エディターで変数宣言の新しい行を挿入し、変数名の入力フィールドが開きます。 電話 ：表形式の宣言エディターのコンテキストメニュー、宣言ヘッダーのボタン 宣言行の他のフィールドを編集するには、フィールドをダブルクリックして、選択リストから、または適切なダイアログを使用して情報を選択します。...", 
"body" : "入れる シンボル： 関数 ：コマンドは、表形式の宣言エディターで変数宣言の新しい行を挿入し、変数名の入力フィールドが開きます。 電話 ：表形式の宣言エディターのコンテキストメニュー、宣言ヘッダーのボタン 宣言行の他のフィールドを編集するには、フィールドをダブルクリックして、選択リストから、または適切なダイアログを使用して情報を選択します。 " }, 
{ "title" : "コマンド：宣言ヘッダーを編集します ", 
"url" : "_cds_cmd_edit_declaration_header.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 宣言 \/ コマンド：宣言ヘッダーを編集します ", 
"snippet" : "宣言ヘッダーを編集する 関数 ：コマンドはダイアログを開きます 宣言ヘッダーを編集する 、POUのヘッダーを構成するために表形式の宣言エディターで使用されます。 電話 ：表形式の宣言エディタのコンテキストメニュー 要件 ：焦点は表形式の宣言エディタにあります。...", 
"body" : "宣言ヘッダーを編集する 関数 ：コマンドはダイアログを開きます 宣言ヘッダーを編集する 、POUのヘッダーを構成するために表形式の宣言エディターで使用されます。 電話 ：表形式の宣言エディタのコンテキストメニュー 要件 ：焦点は表形式の宣言エディタにあります。 " }, 
{ "title" : "ダイアログ：宣言ヘッダーの編集 ", 
"url" : "_cds_cmd_edit_declaration_header.html#UUID-45e0a327-995d-f0be-3bd9-68bfcb2d6ac3_id_be8f1f656b67481c0a8640e01948269_id_96a5b119635a8e3bc0a8640e005df4c1", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 宣言 \/ コマンド：宣言ヘッダーを編集します \/ ダイアログ：宣言ヘッダーの編集 ", 
"snippet" : "関数 ：ダイアログで、POUの表形式の宣言部分のヘッダーを設定します。 電話 ：表形式の宣言エディターのヘッダー、表形式の宣言エディターのコンテキストメニューをマウスでクリックします 宣言 POUタイプを変更するための選択リスト プログラム FUNCTION_BLOCK 拡張 ：基本機能ブロックの入力項目 実装 ：インターフェースの入力フィールド 関数 リターンタイプ 現在のPOU名の入力フィールド POUの名前を変更できます。 名前を変更するときにすべての参照を自動的に調整する ： 対話 リファクタリング 開きます。 ：名前の変更は、POUの宣言ヘッダーでのみ有効になります。 属性 対話 属...", 
"body" : "関数 ：ダイアログで、POUの表形式の宣言部分のヘッダーを設定します。 電話 ：表形式の宣言エディターのヘッダー、表形式の宣言エディターのコンテキストメニューをマウスでクリックします 宣言 POUタイプを変更するための選択リスト プログラム FUNCTION_BLOCK 拡張 ：基本機能ブロックの入力項目 実装 ：インターフェースの入力フィールド 関数 リターンタイプ 現在のPOU名の入力フィールド POUの名前を変更できます。 名前を変更するときにすべての参照を自動的に調整する ： 対話 リファクタリング 開きます。 ：名前の変更は、POUの宣言ヘッダーでのみ有効になります。 属性 対話 属性 属性とプラグマを入力するために開きます。 詳細については、以下を参照してください。 デクラレーションエディタの使用" }, 
{ "title" : "コマンド：下に移動 ", 
"url" : "_cds_cmd_move_down.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 宣言 \/ コマンド：下に移動 ", 
"snippet" : "下に移動 シンボル： 関数 ：このコマンドは、変数宣言を1行下に移動します。 電話 ： コンテキストメニュー 要件 ：表形式の宣言エディタで、変数宣言のある行が選択されています。...", 
"body" : "下に移動 シンボル： 関数 ：このコマンドは、変数宣言を1行下に移動します。 電話 ： コンテキストメニュー 要件 ：表形式の宣言エディタで、変数宣言のある行が選択されています。 " }, 
{ "title" : "コマンド：上に移動 ", 
"url" : "_cds_cmd_move_up.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 宣言 \/ コマンド：上に移動 ", 
"snippet" : "上に移動 シンボル： 関数 ：このコマンドは、変数宣言を1行上に移動します。 電話 ： コンテキストメニュー 要件 ：表形式の宣言エディタで、変数宣言のある行が選択されています。...", 
"body" : "上に移動 シンボル： 関数 ：このコマンドは、変数宣言を1行上に移動します。 電話 ： コンテキストメニュー 要件 ：表形式の宣言エディタで、変数宣言のある行が選択されています。 " }, 
{ "title" : "宣言（永続性） ", 
"url" : "_cds_f_commands_declarations_persistence.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 宣言（永続性） ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド：リストを並べ替えてギャップをクリーンアップする ", 
"url" : "_cds_cmd_reorder_list.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 宣言（永続性） \/ コマンド：リストを並べ替えてギャップをクリーンアップする ", 
"snippet" : "リストを並べ替えてギャップをクリーンアップします 関数 ：このコマンドは、永続変数の宣言に変更を加えたときに発生する可能性のあるギャップをクリーンアップします。クリーンアップにより、メモリ要件が削減されます。コマンドを実行すると、 CODESYS データが失われる可能性があることをユーザーに通知する警告メッセージを表示します。 電話 ：メニュー 宣言 、 コンテキストメニュー 要件 ：永続性エディター（永続性変数リスト）がアクティブです。 クリーニングする前に、永続変数の現在の値をレシピに保存することを検討する必要があります（コマンド レシピに現在の値を保存する ）。次に、次回のダウンロード後...", 
"body" : "リストを並べ替えてギャップをクリーンアップします 関数 ：このコマンドは、永続変数の宣言に変更を加えたときに発生する可能性のあるギャップをクリーンアップします。クリーンアップにより、メモリ要件が削減されます。コマンドを実行すると、 CODESYS データが失われる可能性があることをユーザーに通知する警告メッセージを表示します。 電話 ：メニュー 宣言 、 コンテキストメニュー 要件 ：永続性エディター（永続性変数リスト）がアクティブです。 クリーニングする前に、永続変数の現在の値をレシピに保存することを検討する必要があります（コマンド レシピに現在の値を保存する ）。次に、次回のダウンロード後に、値をコントローラーに再度転送できます。 詳細については、以下を参照してください。 データの永続性" }, 
{ "title" : "コマンド：レシピに現在の値を保存する ", 
"url" : "_cds_cmd_save_actual_values_recipe.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 宣言（永続性） \/ コマンド：レシピに現在の値を保存する ", 
"snippet" : "レシピに現在の値を保存する 関数 ：このコマンドは、レシピマネージャーで新しいレシピ定義を作成し、その中に永続変数の現在の値を保存します。コマンドの前にコマンドを置く必要があります リストを並べ替えてギャップをクリーンアップします データ損失の可能性を回避するために実行します。コマンドで レシピから値を復元する その後、データを復元できます。 電話 ：メニュー 宣言 要件 ：アプリケーションはオンラインであり、永続性エディター（永続性変数リスト）がアクティブです。 永続変数リストが保存されたときに、対応する名前のリストがレシピマネージャーにすでに存在する場合、現在の永続変数は次のリストに並べ替...", 
"body" : "レシピに現在の値を保存する 関数 ：このコマンドは、レシピマネージャーで新しいレシピ定義を作成し、その中に永続変数の現在の値を保存します。コマンドの前にコマンドを置く必要があります リストを並べ替えてギャップをクリーンアップします データ損失の可能性を回避するために実行します。コマンドで レシピから値を復元する その後、データを復元できます。 電話 ：メニュー 宣言 要件 ：アプリケーションはオンラインであり、永続性エディター（永続性変数リスト）がアクティブです。 永続変数リストが保存されたときに、対応する名前のリストがレシピマネージャーにすでに存在する場合、現在の永続変数は次のリストに並べ替えられます。 新しい永続変数がリストに追加されます。 永続変数のリストにない変数は削除されます。 したがって、レシピマネージャのリストに他のレシピを追加することができます。これは保持されます。ただし、新しい変数がリストに追加されると、それらはコマンドの次の実行に追加されます レシピに現在の値を保存する オフになりました。 詳細については、以下を参照してください。 やること " }, 
{ "title" : "コマンド：レシピから値を復元する ", 
"url" : "_cds_cmd_restore_values_recipe.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 宣言（永続性） \/ コマンド：レシピから値を復元する ", 
"snippet" : "レシピから値を復元する 関数 ：コマンドは、コマンドで設定した永続変数の値を復元します レシピに現在の値を保存する レシピに保存されます。通常、コマンドの実行後にコマンドを選択します リストを並べ替えてギャップをクリーンアップします アウト。 電話 ：メニュー 宣言 要件 ：永続性エディター（永続性変数リスト）がアクティブです。アプリケーションはオンラインモードです。 詳細については、以下を参照してください。 データの永続性...", 
"body" : "レシピから値を復元する 関数 ：コマンドは、コマンドで設定した永続変数の値を復元します レシピに現在の値を保存する レシピに保存されます。通常、コマンドの実行後にコマンドを選択します リストを並べ替えてギャップをクリーンアップします アウト。 電話 ：メニュー 宣言 要件 ：永続性エディター（永続性変数リスト）がアクティブです。アプリケーションはオンラインモードです。 詳細については、以下を参照してください。 データの永続性" }, 
{ "title" : "コマンド：すべてのインスタンスパスを追加します ", 
"url" : "_cds_cmd_add_all_instance_paths.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 宣言（永続性） \/ コマンド：すべてのインスタンスパスを追加します ", 
"snippet" : "すべてのインスタンスパスを追加します 関数 ： 永続性エディターでコマンドを選択すると、アプリケーションはキーワードを使用して永続的な変数宣言を検索します PERSISTENT 永続性エディターの外部にある検索。見つかった宣言ごとに、その変数のインスタンスパスが永続性エディターに追加されます。 変数構成でコマンドを選択すると、部分的なアドレスを持つ変数ごとにインスタンスパスが追加されます。アプリケーションのすべての機能ブロックが考慮されます。 電話 ：メニュー 宣言 、 コンテキストメニュー 要件 永続性エディター（グローバル永続変数リスト）がアクティブであるか、変数構成（グローバル変数リスト...", 
"body" : "すべてのインスタンスパスを追加します 関数 ： 永続性エディターでコマンドを選択すると、アプリケーションはキーワードを使用して永続的な変数宣言を検索します PERSISTENT 永続性エディターの外部にある検索。見つかった宣言ごとに、その変数のインスタンスパスが永続性エディターに追加されます。 変数構成でコマンドを選択すると、部分的なアドレスを持つ変数ごとにインスタンスパスが追加されます。アプリケーションのすべての機能ブロックが考慮されます。 電話 ：メニュー 宣言 、 コンテキストメニュー 要件 永続性エディター（グローバル永続変数リスト）がアクティブであるか、変数構成（グローバル変数リストと VAR_CONFIG -宣言）は開いています。 アプリケーションは正常にコンパイルされました。 詳細については、以下を参照してください。 PERSISTENT と RETAIN" }, 
{ "title" : "コミュニケーション-ゲ : トウェイ ", 
"url" : "_cds_f_commands_device_communication.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ コミュニケーション-ゲ : トウェイ ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド：新しいゲートウェイを追加します ", 
"url" : "_cds_cmd_add_gateway.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ コミュニケーション-ゲ : トウェイ \/ コマンド：新しいゲートウェイを追加します ", 
"snippet" : "新しいゲートウェイを追加する 関数 ：コマンドはダイアログを開きます ゲートウェイ 、ゲートウェイチャネルを定義し、それを現在のデバイス構成に追加できます。 電話 ：メニュー ゲートウェイ 対話中 コミュニケーション デバイスエディタの...", 
"body" : "新しいゲートウェイを追加する 関数 ：コマンドはダイアログを開きます ゲートウェイ 、ゲートウェイチャネルを定義し、それを現在のデバイス構成に追加できます。 電話 ：メニュー ゲートウェイ 対話中 コミュニケーション デバイスエディタの " }, 
{ "title" : "対話：ゲートウェイ ", 
"url" : "_cds_cmd_add_gateway.html#UUID-38ab0375-8d48-62f3-f65e-4b40ba5a736f_id_d79c74fc3cfb092c0a8640e0168b9f8_id_1bd97f47c406359cc0a8640e007a53f7", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ コミュニケーション-ゲ : トウェイ \/ コマンド：新しいゲートウェイを追加します \/ 対話：ゲートウェイ ", 
"snippet" : "姓 ゲートウェイの名前 運転者 選択リストからのドライバータイプ ドライバー固有の設定、例： IPアドレス、ポート 指定した値をダブルクリックすると編集可能 パラメータの簡単な説明がダイアログの下部に表示されます。 注：DNSドメインアドレスを指定することもできます。これはあなたと一緒に来なければなりません dns: たとえば、開始します dns:MyDynDNSAdress 。 このダイアログは、プロジェクト内のゲートウェイエントリを後で編集するためにも使用されます。 詳細については、以下を参照してください。 タブ：通信設定...", 
"body" : "姓 ゲートウェイの名前 運転者 選択リストからのドライバータイプ ドライバー固有の設定、例： IPアドレス、ポート 指定した値をダブルクリックすると編集可能 パラメータの簡単な説明がダイアログの下部に表示されます。 注：DNSドメインアドレスを指定することもできます。これはあなたと一緒に来なければなりません dns: たとえば、開始します dns:MyDynDNSAdress 。 このダイアログは、プロジェクト内のゲートウェイエントリを後で編集するためにも使用されます。 詳細については、以下を参照してください。 タブ：通信設定" }, 
{ "title" : "コマンド：ローカルゲートウェイを構成する ", 
"url" : "_cds_cmd_connect_to_local_gateway.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ コミュニケーション-ゲ : トウェイ \/ コマンド：ローカルゲートウェイを構成する ", 
"snippet" : "ローカルゲートウェイを構成する 関数 ：コマンドはダイアログを開きます ゲートウェイ構成 、構成ファイルを手動で編集する代わりに、ローカルゲートウェイのブロックドライバー構成を行うことができます Gateway.cfg 。 電話 ：ダイアログのデバイスエディタにあるときのコンテキストメニュー コミュニケーション ゲートウェイエントリが選択されています ゲートウェイを正しく構成するには、詳細な知識が必要です。疑わしい場合は、デフォルトの構成設定を変更しないでください。 Edge Gateway 機能を有効にし、Edge Gateway を CODESYS Automation Server 、あ...", 
"body" : "ローカルゲートウェイを構成する 関数 ：コマンドはダイアログを開きます ゲートウェイ構成 、構成ファイルを手動で編集する代わりに、ローカルゲートウェイのブロックドライバー構成を行うことができます Gateway.cfg 。 電話 ：ダイアログのデバイスエディタにあるときのコンテキストメニュー コミュニケーション ゲートウェイエントリが選択されています ゲートウェイを正しく構成するには、詳細な知識が必要です。疑わしい場合は、デフォルトの構成設定を変更しないでください。 Edge Gateway 機能を有効にし、Edge Gateway を CODESYS Automation Server 、あなたは使用することができます CODESYS Automation Server Connector または CODESYS Service Tool .詳細については、 CODESYS Automation Server 「Edge Gateway をサーバーに接続して PLC を入力する」の章を参照してください。ヘルプの「Edge Gateway のセキュリティ通知」にも注意してください。 " }, 
{ "title" : "ダイアログ：ゲートウェイ構成 ", 
"url" : "_cds_cmd_connect_to_local_gateway.html#UUID-113d1b31-e0b0-905d-0a3a-3bc12e9738f0_id_dfde2d61c3f6ec73c0a8640e0083d45e_id_1513b072c607f333c0a8640e00d023da", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ コミュニケーション-ゲ : トウェイ \/ コマンド：ローカルゲートウェイを構成する \/ ダイアログ：ゲートウェイ構成 ", 
"snippet" : "ダイアログに表示される構成ツリーは、現在有効な構成ファイルの説明に対応しています。 gateway.cfg 。関連するインターフェースの現在の設定を含むパラメーターが表示されます。ダイアログでの構成の変更。 わかった 構成ファイルの即時更新を引き起こします。 ゲートウェイ構成ファイルの場合 gateway.cfg 変更された場合、変更を有効にするには、最初にゲートウェイを停止して再起動する必要があります。 追加 インターフェイスと設定を追加するためのコマンドを含むメニュー コマンドは、ダイアログのコンテキストメニューでも使用できます。選択は、選択されているエントリと、すでに挿入されている設定に...", 
"body" : "ダイアログに表示される構成ツリーは、現在有効な構成ファイルの説明に対応しています。 gateway.cfg 。関連するインターフェースの現在の設定を含むパラメーターが表示されます。ダイアログでの構成の変更。 わかった 構成ファイルの即時更新を引き起こします。 ゲートウェイ構成ファイルの場合 gateway.cfg 変更された場合、変更を有効にするには、最初にゲートウェイを停止して再起動する必要があります。 追加 インターフェイスと設定を追加するためのコマンドを含むメニュー コマンドは、ダイアログのコンテキストメニューでも使用できます。選択は、選択されているエントリと、すでに挿入されている設定によって異なります。 インターフェイスを追加 ：ゲートウェイを介した通信用のインターフェースを選択します。ツリーの最上位に挿入されます。可能なブロックドライバインターフェイスについては、以下の表を参照してください。 構成設定の追加 ：選択したインターフェースの設定を選択します。ツリーのインターフェイスの下に挿入されます。設定の値を編集するには、列をダブルクリックして開きます 態度 編集フィールド。ブロックドライバーインターフェイスごとに可能な設定については、以下の表を参照してください。 消火 選択した構成設定を削除します 上 、 下向き 選択した構成エントリを1つ上または下に移動します 可能なブロックドライバーインターフェイス COMポート デバイスのシリアルポート。たとえば、専用COMポートのRS232規格に準拠したデータ交換用。 可能な構成設定： 姓 ：シンボリックのみ ポート ：このインターフェイスに使用される物理シリアルポート（例： COM 5 Windowsコンピューターの場合 ボーレート ： 2400 、 4800 、 9600 、 19200 、 38400 、 57600 、 115200 自動アドレス指定を有効にする ： （デフォルト= ）。 態度 Local address 評価されます。シリアルインターフェイスを介して通信する2つのデバイスは、メッセージの交換を開始する前に、アドレスを個別にネゴシエートします。 2つのデバイスのアドレスが同じである場合、それらは再ネゴシエートされます。この設定は、物理的に離れたデバイスなどでローカルアドレスを明示的に設定できない場合に役立ちます。 ローカルアドレス ：次の場合にのみ評価 自動アドレス指定を有効にする がアクティブになります デフォルト=ポートの実際の値 共有メモリ 共有メモリドライバ 可能な設定： 姓 ：シンボリックのみ 強制アドレス ：デフォルト= -1（= no forced address ）。 例： 42 これは、ドライバーがここで定義された固定アドレスを使用する必要があり、アドレスが 0 - 255 与えられる。この設定は、構成で複数の共有メモリドライバーが有効になっている場合に役立ちます。 イーサネットUDP \/ IP 「ユーザーデータグラムプロトコル」に従ったデータ交換のためのイーサネットインターフェース 可能な設定： 姓 ：シンボリックのみ ポートインデックス ：通信用のポート番号 ポートインデックスは範囲内です 0 それまで 3 。 これらは、次のイーサネットポートにマップされます。 1740 それまで 1743 。 IPアドレス ：デフォルト= 127.0.0.1 この設定は、デバイスに複数のネットワークインターフェイスがある場合にインターフェイスを明示的に設定するのに役立ちます。 例： 127.0.0.1 ローカルネットワークインターフェースの略で、別名 localhost 専用。その他の住所（例： 10.27.7.72 ）は、デバイスで使用可能である必要がある実際のIPアドレスを表します。 ネットワークマスク ：デフォルト= 255.255.255.0 例：255.255.252.0 この設定は、デバイスに複数のネットワークインターフェイスがある場合にインターフェイスを明示的に設定するのに役立ちます。 PPPリモートアドレス ：デフォルト= 127.0.0.1 例： 10.13.42.240 UDPインターフェイスとここで指定されたアドレスで指定されたノードとの間に論理的なポイントツーポイント接続を確立します UDPインターフェースがこのノードと排他的に通信し、ネットワーク上でブロードキャストが送信されないようにします イーサネットTCP \/ IP 「伝送制御プロトコル」に従ったデータ交換用のイーサネットインターフェース 可能な設定： 姓 、 ポート 、 IPアドレス ：イーサネットUDP \/ IPについては、上記を参照してください 非アクティブタイムアウト ：デフォルト= 0 この設定は、データが交換されなくなった場合にTCP接続が閉じられるまでの期間を秒単位で定義します。 CANクライアント 姓 ：シンボリックのみ その他の設定の説明は、ダイアログに直接表示されます。 USBポート 姓 ：シンボリックのみ その他の設定の説明は、ダイアログに直接表示されます。 詳細については、以下を参照してください。 タブ：通信設定" }, 
{ "title" : "他の ", 
"url" : "_cds_f_commands_miscellaneous.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 他の ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "コマンド: ウォッチリストに追加 ", 
"url" : "_cds_cmd_add_watch.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 他の \/ コマンド: ウォッチリストに追加 ", 
"snippet" : "気に入ったリストに追加する シンボル： 関数 : このコマンドは、オンライン監視の目的で、カーソルの現在の位置の変数をウォッチ リストに追加します。 電話 : アプリケーションがオンライン モードで、カーソルがエディター内の変数上にある場合、コマンドはコンテキスト メニューで使用できます。 このコマンドは、現在開いているウォッチリストに変数を追加します。ウォッチリストが開いていない場合は、変数は ウォッチ1 リストとそのビューが開きます。 詳細については、以下を参照してください。 ウォッチリストを使用する そして 価値の監視...", 
"body" : "気に入ったリストに追加する シンボル： 関数 : このコマンドは、オンライン監視の目的で、カーソルの現在の位置の変数をウォッチ リストに追加します。 電話 : アプリケーションがオンライン モードで、カーソルがエディター内の変数上にある場合、コマンドはコンテキスト メニューで使用できます。 このコマンドは、現在開いているウォッチリストに変数を追加します。ウォッチリストが開いていない場合は、変数は ウォッチ1 リストとそのビューが開きます。 詳細については、以下を参照してください。 ウォッチリストを使用する そして 価値の監視" }, 
{ "title" : "コマンド：インターフェースを実装する ", 
"url" : "_cds_cmd_implement_interfaces.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 他の \/ コマンド：インターフェースを実装する ", 
"snippet" : "インターフェイスを実装する 関数 ：このコマンドは、機能ブロックに実装されているインターフェイスを更新します。 電話 ：デバイスツリーでファンクションブロック（FB）が選択されている場合のコンテキストメニュー 要件 ：汎用モジュールは、変更したインタフェースを実装します。たとえば、インターフェイスに別のメソッドを追加しました。 オブジェクト指向プログラミングでは、継承の目的で1つ以上のインターフェースを実装する基本機能ブロックから機能ブロック（FB）を派生させる場合、以下が適用されます。 あなたが命令した場合 インターフェイスを実装する 派生FBに対して実行すると、ベースFBのすべてのインター...", 
"body" : "インターフェイスを実装する 関数 ：このコマンドは、機能ブロックに実装されているインターフェイスを更新します。 電話 ：デバイスツリーでファンクションブロック（FB）が選択されている場合のコンテキストメニュー 要件 ：汎用モジュールは、変更したインタフェースを実装します。たとえば、インターフェイスに別のメソッドを追加しました。 オブジェクト指向プログラミングでは、継承の目的で1つ以上のインターフェースを実装する基本機能ブロックから機能ブロック（FB）を派生させる場合、以下が適用されます。 あなたが命令した場合 インターフェイスを実装する 派生FBに対して実行すると、ベースFBのすべてのインターフェイスメソッドとインターフェイスプロパティが、派生FBで「スタブ」（実装なし）の形式で採用されます。ここで、派生FBの「空の」メソッド\/プロパティがベースFBに実装されているものと競合しないことを確認する必要があります。これを支援するために、次のことが起こります。メソッド\/プロパティの基本実装がある場合、それは追加します CODESYS 影響を受ける派生インターフェイスメソッドまたはインターフェイスプロパティの最初の行にプラグマ属性{error ..}を入力すると、適切なエラーメッセージが生成されます。メソッド\/プロパティの基本実装がない場合は、警告のプラグマ属性エントリがあります。ビルディングブロックを編集した後、それぞれの場合にエラープラグマ属性エントリを明示的に削除する必要があります。 詳細については、以下を参照してください。 インターフェイスを実装する" }, 
{ "title" : "コマンド：結果を現在の宣言に制限する ", 
"url" : "_cds_cmd_limit_results_to_current_declaration.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ メニューコマンド \/ 他の \/ コマンド：結果を現在の宣言に制限する ", 
"snippet" : "結果を現在の宣言に制限する 関数 ：複数の宣言が見つかった場合、コマンドは相互参照リストの表示を折りたたむ。リストで明示的に選択した宣言の結果のみが表示されます。 電話 ： コンテキストメニュー 要件 ：相互参照リストがアクティブです。探しているシンボルのいくつかの宣言は、相互参照としてリストされています。...", 
"body" : "結果を現在の宣言に制限する 関数 ：複数の宣言が見つかった場合、コマンドは相互参照リストの表示を折りたたむ。リストで明示的に選択した宣言の結果のみが表示されます。 電話 ： コンテキストメニュー 要件 ：相互参照リストがアクティブです。探しているシンボルのいくつかの宣言は、相互参照としてリストされています。 " }, 
{ "title" : "ダイアログ ", 
"url" : "_cds_struct_reference_dialogs.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ ", 
"snippet" : "のダイアログ CODESYS ユーザーインターフェイスは、基本的にのヘルプページで説明されています CODESYS メニューコマンドまたは CODESYS オブジェクト。 The ダイアログ ヘルプセクションには、ダイアログに関する次の説明のみが含まれています。 メニューコマンドの後またはオブジェクトエディタで追加のマルチレベル呼び出しによってのみ表示されるダイアログの説明 複雑なためにコマンドまたはオブジェクトのヘルプページに含まれていないダイアログの説明（複数のサブダイアログ）...", 
"body" : "のダイアログ CODESYS ユーザーインターフェイスは、基本的にのヘルプページで説明されています CODESYS メニューコマンドまたは CODESYS オブジェクト。 The ダイアログ ヘルプセクションには、ダイアログに関する次の説明のみが含まれています。 メニューコマンドの後またはオブジェクトエディタで追加のマルチレベル呼び出しによってのみ表示されるダイアログの説明 複雑なためにコマンドまたはオブジェクトのヘルプページに含まれていないダイアログの説明（複数のサブダイアログ） " }, 
{ "title" : "ダイアログ：インポートアシスタント ", 
"url" : "_cds_dlg_import_assistant.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：インポートアシスタント ", 
"snippet" : "インポートアシスタント 関数 ：ダイアログでは、 CODESYS 古いものからのオプションとパッケージのインストール CODESYS ローカルコンピュータで見つかったインストール。 電話 ：最近インストールするとダイアログが開きます CODESYS バージョンが初めて起動され、古いバージョンがコンピューターにインストールされます。 プログラム設定 ： 習慣 CODESYS オプションは、古いインストールから新しいインストールに転送されます。 パッケージ ：古いものと一緒にインストールされたパッケージ CODESYS バージョンは、新しいバージョンのパッケージマネージャーに転送されます。これにつ...", 
"body" : "インポートアシスタント 関数 ：ダイアログでは、 CODESYS 古いものからのオプションとパッケージのインストール CODESYS ローカルコンピュータで見つかったインストール。 電話 ：最近インストールするとダイアログが開きます CODESYS バージョンが初めて起動され、古いバージョンがコンピューターにインストールされます。 プログラム設定 ： 習慣 CODESYS オプションは、古いインストールから新しいインストールに転送されます。 パッケージ ：古いものと一緒にインストールされたパッケージ CODESYS バージョンは、新しいバージョンのパッケージマネージャーに転送されます。これについては、検出されたパッケージのインストールのリストと詳細を参照してください。 名前 、 バージョン 、 と インストール日 。 輸入 プログラム設定および\/またはオプションは現在に転送されます CODESYS バージョン。 スキップ プログラム設定および\/またはオプションは現在に転送されません CODESYS バージョン。 詳細については、以下を参照してください。 CODESYS" }, 
{ "title" : "ダイアログ：ライブラリ参照の変換 ", 
"url" : "_cds_dlg_library_reference_conversion.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：ライブラリ参照の変換 ", 
"snippet" : "ライブラリ参照変換 関数 ：ダイアログは、使用できなくなったライブラリへの参照を処理する方法を定義します。注：未定義のライブラリ参照は、にあるグローバルライブラリマネージャにあります。 POU 見る。 電話 ：開くとき CoDeSys V2.3 のプロジェクト V3 、現在のライブラリで使用できなくなったライブラリをコンバータが検出すると、ダイアログが開きます CODESYS バージョン。 A CoDeSys V2.3 プロジェクトはに変換することができます CODESYS V3 プロジェクトの場合のみ CODESYS V2.3 Converter パッケージはにインストールされています CO...", 
"body" : "ライブラリ参照変換 関数 ：ダイアログは、使用できなくなったライブラリへの参照を処理する方法を定義します。注：未定義のライブラリ参照は、にあるグローバルライブラリマネージャにあります。 POU 見る。 電話 ：開くとき CoDeSys V2.3 のプロジェクト V3 、現在のライブラリで使用できなくなったライブラリをコンバータが検出すると、ダイアログが開きます CODESYS バージョン。 A CoDeSys V2.3 プロジェクトはに変換することができます CODESYS V3 プロジェクトの場合のみ CODESYS V2.3 Converter パッケージはにインストールされています CODESYS V3 。パッケージはで利用可能です CODESYS Store International 。 何をしたいですか？ ライブラリも変換してインストールします。 コンバーターは、ライブラリファイルも新しい形式に変換します。プロジェクトで参照されたままです。 「その他」カテゴリのライブラリリポジトリに自動的にインストールされます。ライブラリがインストールに必要なプロジェクト情報を提供していない場合は、 プロジェクト情報を入力する 追加する情報のダイアログが開きます。 すでにインストールされている以下のライブラリを使用してください 以前に使用されていたライブラリは、別のライブラリに置き換えられます。 The ブラウズ ボタンをクリックすると、ローカルライブラリリポジトリから選択するためのダイアログが開きます。 ライブラリを無視します。参照は変換されたプロジェクトには表示されません ライブラリ参照がプロジェクトから削除されます。 そのライブラリ参照の将来のすべての発生のためにこのマッピングを覚えておいてください ここでダイアログで行った設定は、将来のプロジェクト変換にも使用されます。 詳細については、以下を参照してください。 V2.3プロジェクトを開く" }, 
{ "title" : "ダイアログ：機能ブロックを選択 ", 
"url" : "_cds_dlg_select_function_block.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：機能ブロックを選択 ", 
"snippet" : "機能ブロックを選択 関数 ：ダイアログは、I \/ Oマッピングの機能ブロックを選択するために使用されます。機能ブロックは、で選択されたI \/ Oチャネルにマッピングする必要があります。 <デバイス名> I \/ Oマッピング タブまたはで選択したオブジェクトに <デバイス名> IECオブジェクト タブ。 電話 ： <デバイス名> I \/ Oマッピング タブ、 I \/ OチャネルにFBを追加 コマンドボタン <デバイス名> IECオブジェクト 、 追加 コマンドボタン ダイアログには、アクティブなアプリケーションのすべての機能ブロックと、プロジェクトに含まれる次の条件を満たすライブラリが表示されま...", 
"body" : "機能ブロックを選択 関数 ：ダイアログは、I \/ Oマッピングの機能ブロックを選択するために使用されます。機能ブロックは、で選択されたI \/ Oチャネルにマッピングする必要があります。 <デバイス名> I \/ Oマッピング タブまたはで選択したオブジェクトに <デバイス名> IECオブジェクト タブ。 電話 ： <デバイス名> I \/ Oマッピング タブ、 I \/ OチャネルにFBを追加 コマンドボタン <デバイス名> IECオブジェクト 、 追加 コマンドボタン ダイアログには、アクティブなアプリケーションのすべての機能ブロックと、プロジェクトに含まれる次の条件を満たすライブラリが表示されます。 機能ブロックには {attribute 'io_function_block'} 属性。 機能ブロックには、チャネルタイプ（入力、出力、データタイプ）に一致する入力または出力パラメータが含まれ、 {attribute 'io_function_block_mapping'} 属性。 複数の一致するパラメータを提供する機能ブロックが選択されると、最初のパラメータのみがチャネルに自動的にマッピングされます。その他は手動でのみマッピングできます <デバイス名> I \/ Oマッピング タブ。 機能ブロックがマッピングされた後、機能ブロックインスタンスのパラメータがに入力されます。 変数 マッピングテーブルの列。この場合、パスは次のように構成されます。 <application name>.<device channel name>_<FB name>_<incremented FB instance number>.<FB parameter name> 例： App1.Out_4_Int_myScale_Output_Int_1.iOutput のために iOutput 最初に挿入されたインスタンスのパラメータ myScale_Output ファンクションブロック 探す 機能ブロック名を検索するための入力フィールド タイプ チャネルタイプに一致するツリー構造の機能ブロック ノード：アプリケーション、ライブラリ名 ドキュメンテーション ツリーまたはライブラリブロックで選択されたライブラリで利用可能なドキュメントを表示します 詳細については、以下を参照してください。 io_function_block、io_function_block_mapping" }, 
{ "title" : "ダイアログ：デバイス変換 ", 
"url" : "_cds_dlg_device_conversion.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：デバイス変換 ", 
"snippet" : "デバイス変換 関数 ：ダイアログは、使用できなくなったデバイスへの参照を処理する方法を定義します。 電話 ：開くとき CoDeSys V2.3 のプロジェクト V3 、コンバータが使用できなくなったデバイスの参照を検出すると、ダイアログが開きます。 A CoDeSys V2.3 プロジェクトはに変換することができます CODESYS V3 プロジェクトの場合のみ CODESYS V2.3 Converter パッケージはにインストールされています CODESYS V3 。パッケージはで利用可能です CODESYS Store International 。 何をしたいですか？ すでにインストー...", 
"body" : "デバイス変換 関数 ：ダイアログは、使用できなくなったデバイスへの参照を処理する方法を定義します。 電話 ：開くとき CoDeSys V2.3 のプロジェクト V3 、コンバータが使用できなくなったデバイスの参照を検出すると、ダイアログが開きます。 A CoDeSys V2.3 プロジェクトはに変換することができます CODESYS V3 プロジェクトの場合のみ CODESYS V2.3 Converter パッケージはにインストールされています CODESYS V3 。パッケージはで利用可能です CODESYS Store International 。 何をしたいですか？ すでにインストールされている次のデバイスを使用してください CODESYS デバイスツリーで以前に使用したデバイスを別のデバイスに置き換えます。 The ブラウズ ボタンをクリックすると、ローカルデバイスリポジトリから選択するためのダイアログが開きます。 デバイスを無視します。すべてのデバイス固有のオブジェクトが新しいプロジェクトで使用できるわけではありません その下にすべてのオブジェクトが挿入されたデバイスエントリは、デバイスツリーから削除されます。 そのデバイスの将来のすべての発生のためにこのマッピングを覚えておいてください ここでダイアログで行った設定は、 CODESYS オプション、 CoDeSys V2.3 V2.3コンバーター 、 カテゴリー。結果として、それらは将来のプロジェクト変換にも有効です。 詳細については、以下を参照してください。 V2.3プロジェクトを開く" }, 
{ "title" : "ダイアログ：ブレークポイントのプロパティ ", 
"url" : "_cds_dlg_breakpoint_properties.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：ブレークポイントのプロパティ ", 
"snippet" : "ブレークポイントのプロパティ 関数 ：ダイアログは、で選択したブレークポイントのプロパティを表示または変更するために使用されます ブレークポイント 見る。 電話 ： ブレークポイント 見る、 プロパティ ボタン ブレークポイント 見る、 新しい ボタン、 新しいブレークポイント コマンドまたは 新しいデータブレークポイント 指図 要件 ：ブレークポイントリストでエントリが選択されています。 ダイアログはと同じです 新しいブレークポイント で開かれるダイアログ デバッグ それぞれのコマンドによるメニュー。したがって、ヘルプの説明を参照してください。 新しいブレークポイント ダイアログ。...", 
"body" : "ブレークポイントのプロパティ 関数 ：ダイアログは、で選択したブレークポイントのプロパティを表示または変更するために使用されます ブレークポイント 見る。 電話 ： ブレークポイント 見る、 プロパティ ボタン ブレークポイント 見る、 新しい ボタン、 新しいブレークポイント コマンドまたは 新しいデータブレークポイント 指図 要件 ：ブレークポイントリストでエントリが選択されています。 ダイアログはと同じです 新しいブレークポイント で開かれるダイアログ デバッグ それぞれのコマンドによるメニュー。したがって、ヘルプの説明を参照してください。 新しいブレークポイント ダイアログ。 " }, 
{ "title" : "ダイアログ：権限 ", 
"url" : "_cds_dlg_permissions.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：権限 ", 
"snippet" : "権限 関数 ：ユーザーグループの権限はここで定義され、プロジェクト内の特定のオブジェクトに対して特定のアクションを実行できます。 電話 ： プロジェクト→ユーザー管理 指図 ダイアログで行われたすべての変更はすぐに適用されます。...", 
"body" : "権限 関数 ：ユーザーグループの権限はここで定義され、プロジェクト内の特定のオブジェクトに対して特定のアクションを実行できます。 電話 ： プロジェクト→ユーザー管理 指図 ダイアログで行われたすべての変更はすぐに適用されます。 " }, 
{ "title" : "行動 ", 
"url" : "_cds_dlg_permissions.html#UUID-a96b28c3-bb7e-e6a6-49a3-ce72aed4d7c5_id_a4aafd27a7b86c0a8640e008b3558_id_bed3192ed33cb005c0a8640e01de9170", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：権限 \/ 行動 ", 
"snippet" : "プロジェクトのオブジェクトに対して可能なすべてのアクションは、にリストされています。 行動 。アクションは4つのカテゴリに分類され、プロジェクトの現在のすべてのオブジェクトへのマッピングが各アクションの下に一覧表示されます。 「アクション->オブジェクト」マッピングごとに、既存のユーザーグループごとに権限を定義できます。 アクションカテゴリ： コマンド コマンドの実行に関するアクション ユーザー、グループ、権限 ユーザーアカウント、ユーザーグループ、およびそれらの権限の構成に関するアクション オブジェクトタイプ オブジェクトタイプの作成に関するアクション プロジェクトオブジェクト プロジェクト...", 
"body" : "プロジェクトのオブジェクトに対して可能なすべてのアクションは、にリストされています。 行動 。アクションは4つのカテゴリに分類され、プロジェクトの現在のすべてのオブジェクトへのマッピングが各アクションの下に一覧表示されます。 「アクション->オブジェクト」マッピングごとに、既存のユーザーグループごとに権限を定義できます。 アクションカテゴリ： コマンド コマンドの実行に関するアクション ユーザー、グループ、権限 ユーザーアカウント、ユーザーグループ、およびそれらの権限の構成に関するアクション オブジェクトタイプ オブジェクトタイプの作成に関するアクション プロジェクトオブジェクト プロジェクトのオブジェクトの表示、変更、削除、および子オブジェクトの処理に関するアクション アクションの詳細： 実行する メニューコマンドを実行する 作成 プロジェクトに新しいオブジェクトを作成します 子を追加または削除する 既存のオブジェクトの下に子オブジェクトを追加または削除します 変更 エディターでオブジェクトを変更するか、対応するエディター\/ダイアログでユーザー、グループ、および権限の設定を変更します 削除する オブジェクトを削除または削除する 意見 エディターでオブジェクトのビューを開きます アクションの可能なターゲット これは、プロジェクトの特定のオブジェクト、またはユーザー、グループ、および権限の構成にすることができます。 " }, 
{ "title" : "権限 ", 
"url" : "_cds_dlg_permissions.html#UUID-a96b28c3-bb7e-e6a6-49a3-ce72aed4d7c5_id_a4aafd27a7b86c0a8640e008b3558_id_c220390986c76268c0a864635794e243", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：権限 \/ 権限 ", 
"snippet" : "定義されたすべてのユーザーグループ（「所有者」グループを除く）は、 権限 グループの権限を構成するためのツールバーがあります。 承諾する アクションビューで選択された、選択されたターゲット上のアクションは次のとおりです。 承諾する 選択したグループに対して。 拒否された で選択されたアクション 行動 選択したターゲットのビューは 拒否された 選択したグループに対して。 で選択されたアクションを実行する権限 行動 選択したターゲットのビューが明示的に定義されていません。ただし、アクションは デフォルトで付与 。たとえば、対応する権限が親オブジェクトに付与されているためです。例：グループには、「m...", 
"body" : "定義されたすべてのユーザーグループ（「所有者」グループを除く）は、 権限 グループの権限を構成するためのツールバーがあります。 承諾する アクションビューで選択された、選択されたターゲット上のアクションは次のとおりです。 承諾する 選択したグループに対して。 拒否された で選択されたアクション 行動 選択したターゲットのビューは 拒否された 選択したグループに対して。 で選択されたアクションを実行する権限 行動 選択したターゲットのビューが明示的に定義されていません。ただし、アクションは デフォルトで付与 。たとえば、対応する権限が親オブジェクトに付与されているためです。例：グループには、「myplc」オブジェクトに対する権限があります。その結果、デフォルトでは「myplc.pb_1」オブジェクトに対する権限もあります。 選択したターゲットに対するアクションビューで展開されるアクションは、明示的に拒否されていません。ただし、デフォルトでは拒否されます。たとえば、「親オブジェクト」に対して拒否されているためです。 記号なし 現在、グループが同じ権限を持っていないアクションビューで複数のアクションが選択されています。 ツールバー： 許す 選択されたターゲットオブジェクトに対する選択されたアクションは、選択されたグループに対して明示的に付与されます。 拒否 選択されたターゲットオブジェクトで選択されたアクションは、選択されたグループに対して明示的に拒否されます。 クリア 選択したターゲットオブジェクトに対する選択したアクションの権限が、選択したグループのデフォルト値にリセットされます。 輸出入 コマンドでメニューを開きます すべての権限をエクスポートする 選択した権限をエクスポートする インポート権限 すべての権限をエクスポートする 現在のプロジェクトのすべてのアクションとそれらに構成されたアクセス許可を、データ型のユーザー固有のファイルにエクスポートします *.perms これを行うには、 輸出許可 ダイアログが開き、ファイル名を指定したり、ファイルディレクトリ内の場所を選択したりできます。デフォルトのファイルタイプは Permissions (*.perms) 。 選択した権限をエクスポートする 選択したすべてのアクションと、現在のプロジェクトで構成されているアクセス許可を、データ型のユーザー固有のファイルにエクスポートします *.perms これを行うには、 輸出許可 ダイアログが開き、ファイル名を指定したり、ファイルディレクトリ内の場所を選択したりできます。デフォルトのファイルタイプは Permissions (*.perms) 。 インポート権限 の内容 *.perms ファイルは、現在のプロジェクトのアクションと権限とマージされます。ファイルの一部であるがプロジェクトの一部ではないグループは無視されます。アクションと権限は名前で並べられています。 インポートされたファイルの権限がプロジェクトの権限と異なる場合、プロジェクトの権限は上書きされます。 これを行うには、 インポート権限 を選択するために開きます *.perms ファイルシステムからのファイル。 詳細については、以下を参照してください。 プロジェクトとオブジェクトのユーザー管理とアクセス権の設定 " }, 
{ "title" : "ダイアログ：価値の準備 ", 
"url" : "_cds_dlg_prepare_value.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：価値の準備 ", 
"snippet" : "価値を準備する 関数 ：ダイアログは、強制変数の値を準備するために使用されます。 CODESYS 次の力で準備されたアクションを実行します。 CODESYS 次の状況でダイアログを開きます。 クリックすると 準備された価値 宣言部分の強制変数のフィールド 強制変数のインライン監視フィールドをクリックすると クリックすると 準備された価値 監視ビューの強制変数のフィールド 次の書き込みまたは強制操作のために新しい値を準備します 価値 CODESYS 次の強制操作で変数に書き込みます 値のある準備を削除します CODESYS 準備された値を削除します。 値を変更せずに力を解放します CODESYS...", 
"body" : "価値を準備する 関数 ：ダイアログは、強制変数の値を準備するために使用されます。 CODESYS 次の力で準備されたアクションを実行します。 CODESYS 次の状況でダイアログを開きます。 クリックすると 準備された価値 宣言部分の強制変数のフィールド 強制変数のインライン監視フィールドをクリックすると クリックすると 準備された価値 監視ビューの強制変数のフィールド 次の書き込みまたは強制操作のために新しい値を準備します 価値 CODESYS 次の強制操作で変数に書き込みます 値のある準備を削除します CODESYS 準備された値を削除します。 値を変更せずに力を解放します CODESYS 強制値を保持し、強制を終了します。 CODESYS 変数をマークします <Unforce> 。 強制を解放し、変数を強制する前の値に復元します CODESYS 強制値をリセットし、強制を終了します。変数はでマークされています <Unforce and restore> 。 詳細については、以下を参照してください。 力の値" }, 
{ "title" : "ダイアログ：新しいブレークポイント ", 
"url" : "_cds_dlg_new_breakpoint.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：新しいブレークポイント ", 
"snippet" : "新しいブレークポイント 関数 ：ダイアログで、新しいブレークポイントまたはデータブレークポイントの設定を定義します。それはと同じです ブレークポイントのプロパティ で使用されるダイアログ ブレークポイント 見る。 電話 ： 指示： デバッグ→新しいブレークポイント 指示： 新しいブレークポイント 要件 ：アプリケーションはオンラインモードです。...", 
"body" : "新しいブレークポイント 関数 ：ダイアログで、新しいブレークポイントまたはデータブレークポイントの設定を定義します。それはと同じです ブレークポイントのプロパティ で使用されるダイアログ ブレークポイント 見る。 電話 ： 指示： デバッグ→新しいブレークポイント 指示： 新しいブレークポイント 要件 ：アプリケーションはオンラインモードです。 " }, 
{ "title" : "タブ：状態 ", 
"url" : "_cds_dlg_new_breakpoint.html#UUID-816d639d-e87b-2c62-8afe-4b8f8899c45f_id_b37f8599ca5eabebc0a864630cdc6bd3_id_1c96e8afbc3c9a60c0a864633bdbd9c2", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：新しいブレークポイント \/ タブ：状態 ", 
"snippet" : "ダイアログは、プログラム処理がブレークポイントで停止する必要がある要件を定義します。 条件付きブレークポイントを使用すると、条件が生成されない場合でも、コードの実行が遅くなります TRUE 。 条件付きブレークポイントには、 CODESYS ランタイムシステム> = V3.5.4.0。 タスク 次のいずれかのタスクでブレークポイントに到達した場合にのみブレークします ： CODESYS 特定のタスクが到達した場合にのみブレークポイントを評価します。必要なタスクをアクティブ化する必要があります。 たとえば、単一の「デバッグタスク」を定義して、その結果、同じPOUを使用する他のタスクがデバッグ時に...", 
"body" : "ダイアログは、プログラム処理がブレークポイントで停止する必要がある要件を定義します。 条件付きブレークポイントを使用すると、条件が生成されない場合でも、コードの実行が遅くなります TRUE 。 条件付きブレークポイントには、 CODESYS ランタイムシステム> = V3.5.4.0。 タスク 次のいずれかのタスクでブレークポイントに到達した場合にのみブレークします ： CODESYS 特定のタスクが到達した場合にのみブレークポイントを評価します。必要なタスクをアクティブ化する必要があります。 たとえば、単一の「デバッグタスク」を定義して、その結果、同じPOUを使用する他のタスクがデバッグ時に影響を受けないようにすることができます。 ヒットカウント ヒットカウント 常に休憩 ：プログラムは常にこのブレークポイントで停止します。 代替方法：以下で定義されている頻度でブレークポイントに到達すると、プログラムはブレークポイントで停止します（必要なヒット数を入力するか、番号リストから選択します）。 ヒット数が等しいときにブレーク ヒット数がの倍数の場合はブレーク ヒット数が以上の場合にブレーク 調子 本当のとき、壊す ： CODESYS 指定された条件を評価し、結果が得られた場合にのみブレークポイントでプログラムを停止します TRUE 。条件を有効なブール式として定義できます。 例： x>100 、 x[y]=z 、 a AND b 、 boolVar " }, 
{ "title" : "タブ：データ ", 
"url" : "_cds_dlg_new_breakpoint.html#UUID-816d639d-e87b-2c62-8afe-4b8f8899c45f_id_b37f8599ca5eabebc0a864630cdc6bd3_id_44f01d14144802b9c0a8640e00e05719", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：新しいブレークポイント \/ タブ：データ ", 
"snippet" : "要件：これは、「データブレークポイント」のプロパティに使用されます。 データブレークポイントの機能は、ターゲットシステムによって異なります。現在、データブレークポイントは CODESYS Control Win 。 タブでは、データブレークポイントが設定されている、または設定される予定の変数またはメモリアドレスが指定されます。 変数またはアドレスの値が変更されたときに実行を中断します 修飾変数名の入力 ：変数の選択 入力アシスタント ダイアログ、 変数を見る カテゴリー 例 変数： PLC_PRG.fb_DoSth.dwVariable 住所： 16#12A 、 0x12A 、 129 サイズ...", 
"body" : "要件：これは、「データブレークポイント」のプロパティに使用されます。 データブレークポイントの機能は、ターゲットシステムによって異なります。現在、データブレークポイントは CODESYS Control Win 。 タブでは、データブレークポイントが設定されている、または設定される予定の変数またはメモリアドレスが指定されます。 変数またはアドレスの値が変更されたときに実行を中断します 修飾変数名の入力 ：変数の選択 入力アシスタント ダイアログ、 変数を見る カテゴリー 例 変数： PLC_PRG.fb_DoSth.dwVariable 住所： 16#12A 、 0x12A 、 129 サイズ 指定された変数またはメモリアドレスのバイト数。これを超えると、変更を監視する必要があります。 新しい変数またはメモリアドレスを指定すると、まずデータ型またはメモリに一致する値が自動的に設定されます。 注： サイズ カウントはターゲットシステムによって異なります。のために CODESYS Control Win 、最大サイズ8バイトの最大4つのデータブレークポイントを定義できます。 例： 4 データ型の場合 DWORD 例： 2 データ型の場合 DWORD ：変数の最初の2バイトのみが監視されます。 " }, 
{ "title" : "タブ：実行ポイントの設定 ", 
"url" : "_cds_dlg_new_breakpoint.html#UUID-816d639d-e87b-2c62-8afe-4b8f8899c45f_id_b37f8599ca5eabebc0a864630cdc6bd3_id_e90f365e144802bbc0a8640e00766226", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：新しいブレークポイント \/ タブ：実行ポイントの設定 ", 
"snippet" : "ここで、既存のブレークポイントまたはデータブレークポイントを実行ポイントに変換できます。 実行ポイント（実行はブレークポイントで停止しません） ：ブレークポイントが実行ポイントになります。この時点で処理は停止せず、指定されたコードが実行されます。 ブレークポイントの実行ポイント： 有効、 無効 データブレークポイントの実行ポイント： 有効、 無効 次のコードを実行します 実行ポイントに達したときに実行されるコード ループ構造（For、While）およびIFまたはCASE式は使用できません。 デバイスログにメッセージを出力します このオプションは、を選択した場合にのみ使用できます。 ブレークポイ...", 
"body" : "ここで、既存のブレークポイントまたはデータブレークポイントを実行ポイントに変換できます。 実行ポイント（実行はブレークポイントで停止しません） ：ブレークポイントが実行ポイントになります。この時点で処理は停止せず、指定されたコードが実行されます。 ブレークポイントの実行ポイント： 有効、 無効 データブレークポイントの実行ポイント： 有効、 無効 次のコードを実行します 実行ポイントに達したときに実行されるコード ループ構造（For、While）およびIFまたはCASE式は使用できません。 デバイスログにメッセージを出力します このオプションは、を選択した場合にのみ使用できます。 ブレークポイントへのログインを有効にする のオプション プロジェクト設定→コンパイルオプション 。 CODESYS 変数を出力できます {variable name} メッセージテキストのプレースホルダー。 " }, 
{ "title" : "タブ：場所 ", 
"url" : "_cds_dlg_new_breakpoint.html#UUID-816d639d-e87b-2c62-8afe-4b8f8899c45f_id_b37f8599ca5eabebc0a864630cdc6bd3_id_0620c3861dee5ba1c0a8640e0121f47f", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：新しいブレークポイント \/ タブ：場所 ", 
"snippet" : "要件： 新しいブレークポイント コマンドが実行されました。 POU ブレークポイントが配置されているアクティブなアプリケーションのPOU ポジション POU内のブレークポイントの位置 行番号と列番号（テキストエディタ）またはネットワーク番号または要素番号としてのエントリ インスタンス ファンクションブロックの場合、ブレークポイントを実装で設定するか、インスタンスで設定するかを定義する必要があります。 CODESYS インスタンスにブレークポイントを設定します。このオプションでは、 インスタンスパス 。 CODESYS 実装にブレークポイントを設定します。 ブレークポイントをすぐに有効にする ：...", 
"body" : "要件： 新しいブレークポイント コマンドが実行されました。 POU ブレークポイントが配置されているアクティブなアプリケーションのPOU ポジション POU内のブレークポイントの位置 行番号と列番号（テキストエディタ）またはネットワーク番号または要素番号としてのエントリ インスタンス ファンクションブロックの場合、ブレークポイントを実装で設定するか、インスタンスで設定するかを定義する必要があります。 CODESYS インスタンスにブレークポイントを設定します。このオプションでは、 インスタンスパス 。 CODESYS 実装にブレークポイントを設定します。 ブレークポイントをすぐに有効にする ：ブレークポイントが有効になっています。 ：ブレークポイントは無効です。後で有効にするには、をクリックします のボタン ブレークポイント 見る。 詳細については、以下を参照してください。 ブレークポイントの使用" }, 
{ "title" : "ダイアログ：監視範囲 ", 
"url" : "_cds_dlg_monitoring_range.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：監視範囲 ", 
"snippet" : "監視範囲 関数 ：ダイアログは、監視中に値が表示される配列要素の範囲を制限します。 電話 ：をクリックします データ・タイプ 配列変数に属する列フィールド。 要件 ：POUはオンラインモードであり、監視されています。さらに、POUの変数には 配列 データ・タイプ。 有効範囲 監視される配列要素の範囲 3次元配列の例： [1..10][-3..3][-10..10] 配列要素の最大数 配列変数の要素数 例： 1470 のいずれかを編集するとき 始める 、 終わり 、 また 1000要素のスクロール範囲 設定、他の設定の両方が自動的に適応されます。 始める 値が表示される最初の配列要素のインデック...", 
"body" : "監視範囲 関数 ：ダイアログは、監視中に値が表示される配列要素の範囲を制限します。 電話 ：をクリックします データ・タイプ 配列変数に属する列フィールド。 要件 ：POUはオンラインモードであり、監視されています。さらに、POUの変数には 配列 データ・タイプ。 有効範囲 監視される配列要素の範囲 3次元配列の例： [1..10][-3..3][-10..10] 配列要素の最大数 配列変数の要素数 例： 1470 のいずれかを編集するとき 始める 、 終わり 、 また 1000要素のスクロール範囲 設定、他の設定の両方が自動的に適応されます。 始める 値が表示される最初の配列要素のインデックス 終わり 値が表示される最後の配列要素のインデックス 1000要素のスクロール範囲 配列要素のセットから範囲を選択するためのスライダー 詳細については、以下を参照してください。 プログラミングオブジェクトでのコールモニタリング" }, 
{ "title" : "ダイアログ：プロパティ ", 
"url" : "_cds_f_dlg_properties.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロパティ ", 
"snippet" : "プロパティ ダイアログは、オブジェクトのプロパティを構成するために使用されます CODESYS 。オブジェクトに応じて、ダイアログにはこの目的のために異なるタブがあり、それぞれがプロパティのカテゴリを処理します。 電話 ： 意見 メニュー;内のオブジェクトのコンテキストメニュー デバイス 見る、 POU ビュー、または モジュール 見る 一部のアドオンのオブジェクトには、それぞれのアドオンのヘルプで説明されている追加のプロパティがあります。これらの特別なプロパティは次の場所にあります。 CODESYS Visualization : ビジュアライゼーションオブジェクトのプロパティ CODESY...", 
"body" : "プロパティ ダイアログは、オブジェクトのプロパティを構成するために使用されます CODESYS 。オブジェクトに応じて、ダイアログにはこの目的のために異なるタブがあり、それぞれがプロパティのカテゴリを処理します。 電話 ： 意見 メニュー;内のオブジェクトのコンテキストメニュー デバイス 見る、 POU ビュー、または モジュール 見る 一部のアドオンのオブジェクトには、それぞれのアドオンのヘルプで説明されている追加のプロパティがあります。これらの特別なプロパティは次の場所にあります。 CODESYS Visualization : ビジュアライゼーションオブジェクトのプロパティ CODESYS Visualization Support : プロパティ:テキストリスト CODESYS SFC : プロパティ:SFC 設定 CODESYS UML : UML オブジェクトのプロパティ CODESYS CFC : プロパティ:CFC 実行順序 " }, 
{ "title" : "ダイアログ：プロパティ：一般 ", 
"url" : "_cds_dlg_properties_common.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロパティ \/ ダイアログ：プロパティ：一般 ", 
"snippet" : "全般的 関数 ：ダイアログには、現在選択されているオブジェクトに関する一般的な情報が表示されます。 電話 ： 表示→プロパティ 指図;オブジェクトのコンテキストメニュー、 一般 カテゴリー 要件 ：デバイスツリーまたはPOUビューでオブジェクトが選択されています。 名前 デバイスツリーまたはPOUビューに表示されるオブジェクト名 オブジェクトタイプ オブジェクトのタイプ（たとえば、POU、アプリケーション、またはインターフェース） で開く オブジェクトを表示または編集するエディターのタイプ...", 
"body" : "全般的 関数 ：ダイアログには、現在選択されているオブジェクトに関する一般的な情報が表示されます。 電話 ： 表示→プロパティ 指図;オブジェクトのコンテキストメニュー、 一般 カテゴリー 要件 ：デバイスツリーまたはPOUビューでオブジェクトが選択されています。 名前 デバイスツリーまたはPOUビューに表示されるオブジェクト名 オブジェクトタイプ オブジェクトのタイプ（たとえば、POU、アプリケーション、またはインターフェース） で開く オブジェクトを表示または編集するエディターのタイプ " }, 
{ "title" : "ダイアログ:プロパティ:情報 ", 
"url" : "_cds_dlg_properties_information.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロパティ \/ ダイアログ:プロパティ:情報 ", 
"snippet" : "[情報] ファンクション : このダイアログでは、アプリケーション固有のプロパティを定義できます。 コール : [表示] → [プロパティ] コマンド; のコンテキストメニュー アプリケーション オブジェクト 必要条件 : タイプのオブジェクト アプリケーション デバイスビューまたは POU ビューで選択されている。 これらのプロパティは、プロジェクトに複数のアプリケーションがある場合に役立ちます。 著者 アプリケーションの作成者 [バージョン] アプリケーションのバージョン (例: 0.0.0.1 ) [説明] アプリケーションの説明 プロジェクト情報の値にリセット 値はプロジェクト情報の値...", 
"body" : "[情報] ファンクション : このダイアログでは、アプリケーション固有のプロパティを定義できます。 コール : [表示] → [プロパティ] コマンド; のコンテキストメニュー アプリケーション オブジェクト 必要条件 : タイプのオブジェクト アプリケーション デバイスビューまたは POU ビューで選択されている。 これらのプロパティは、プロジェクトに複数のアプリケーションがある場合に役立ちます。 著者 アプリケーションの作成者 [バージョン] アプリケーションのバージョン (例: 0.0.0.1 ) [説明] アプリケーションの説明 プロジェクト情報の値にリセット 値はプロジェクト情報の値にリセットされます。 詳細については、以下を参照してください。 プロジェクト情報" }, 
{ "title" : "ダイアログ：プロパティ：ブートアプリケーション ", 
"url" : "_cds_dlg_properties_boot_application.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロパティ \/ ダイアログ：プロパティ：ブートアプリケーション ", 
"snippet" : "ブートアプリケーション 関数 ：このタブの設定は、いつ、どのように ブートアプリケーション アプリケーションから作成されます。 要件 ：デバイスは設定をサポートしています。アプリケーションオブジェクトが選択されます。 電話 ： 表示→プロパティ 指図、 ブートアプリケーション カテゴリー; プロパティ コンテキストメニューで ダウンロード時に暗黙のブートアプリケーションを作成する アプリケーションがダウンロードされると、ブートアプリケーションが自動的に作成されます。 オンライン変更で暗黙のブートアプリケーションを作成する ブートアプリケーションは、オンライン変更中に自動的に作成されます。 プロ...", 
"body" : "ブートアプリケーション 関数 ：このタブの設定は、いつ、どのように ブートアプリケーション アプリケーションから作成されます。 要件 ：デバイスは設定をサポートしています。アプリケーションオブジェクトが選択されます。 電話 ： 表示→プロパティ 指図、 ブートアプリケーション カテゴリー; プロパティ コンテキストメニューで ダウンロード時に暗黙のブートアプリケーションを作成する アプリケーションがダウンロードされると、ブートアプリケーションが自動的に作成されます。 オンライン変更で暗黙のブートアプリケーションを作成する ブートアプリケーションは、オンライン変更中に自動的に作成されます。 プロジェクトの終了時にブートアプリケーションに通知する プロジェクトを閉じる前に、 CODESYS ブートアプリケーションを作成（新規）するかどうかを尋ねるダイアログプロンプトを開きます。 作成後にブートアプリケーションを確認する ブートアプリケーションが作成された後、独立したサービスがブートアプリケーションが正しく作成されたかどうかをチェックします。 ここで定義されているプリセットに関係なく、ログイン時にいつでも明示的にブートアプリケーションを作成できます。 " }, 
{ "title" : "ダイアログ：プロパティ：安全 ", 
"url" : "_cds_dlg_properties_encryption.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロパティ \/ ダイアログ：プロパティ：安全 ", 
"snippet" : "安全 関数 ：ダイアログには、暗号化用のアプリケーションのプロパティが含まれています。の場合 CODESYS Security Agent がインストールされると、ダウンロード、オンライン変更、およびブートアプリケーションの暗号化のためのウィザードを開始できます。 電話 ： 指示： 表示→プロパティ アプリケーションオブジェクトのコンテキストメニュー ドングルを使用した暗号化は、安全な暗号化方法として分類されなくなりました。 代わりに証明書で暗号化することをお勧めします。 暗号化技術 の場合 ダウンロード、オンライン変更、およびブートアプリケーションの暗号化を適用します オプションが選択されて...", 
"body" : "安全 関数 ：ダイアログには、暗号化用のアプリケーションのプロパティが含まれています。の場合 CODESYS Security Agent がインストールされると、ダウンロード、オンライン変更、およびブートアプリケーションの暗号化のためのウィザードを開始できます。 電話 ： 指示： 表示→プロパティ アプリケーションオブジェクトのコンテキストメニュー ドングルを使用した暗号化は、安全な暗号化方法として分類されなくなりました。 代わりに証明書で暗号化することをお勧めします。 暗号化技術 の場合 ダウンロード、オンライン変更、およびブートアプリケーションの暗号化を適用します オプションが選択されている セキュリティ画面 で見る セキュリティレベル グループの場合、暗号化テクノロジーは次のように設定されます 証明書による暗号化 このダイアログでは変更できません。 詳細については、以下を参照してください。 アプリケーションの保護暗号化なし 単純な暗号化 定義されたドングル（ライセンスキー）がコンピューターに接続されている場合にのみ、ブートアプリケーションをコントローラーにダウンロードできます。 ドングルはによって提供されます CODESYS GmbH またはそれぞれのハードウェアメーカーによって。会社コードが表示されます。付属の製品コードを指定してください。 ライセンス管理による暗号化 製品コードと会社コードを指定し、それぞれのドングルが開発用コンピューターとコントローラーの両方に接続されている場合にのみ、ブートアプリケーションをコントローラーにダウンロードできます。ライセンスを管理するベンダーからコードを受け取ります。 証明書による暗号化 ブートアプリケーションは、有効な証明書が存在する場合にのみコントローラーにダウンロードできます。 The 証明書 グループが有効になります。以下の説明を参照してください。 オプションがすでに選択されている場合 ダウンロード、オンライン変更、およびブートアプリケーションの暗号化を適用します オプションが選択されている ユーザー のタブ セキュリティ画面 見る。 を選択することもできます アプリケーションコードにデジタル署名する オプション。 証明書で署名する 有効な証明書で署名されている場合にのみ、アプリケーション コードをコントローラにロードできます。この場合、暗号化は必要ありません。 証明書 注： ダウンロード、オンライン変更、およびブートアプリケーションの暗号化を適用します オプションが選択されている セキュリティ画面 で見る セキュリティレベル グループの場合、暗号化テクノロジーは次のように設定されます 証明書による暗号化 で変更することはできません プロパティ ダイアログ。 : The 証明書の選択 ダイアログが開きます。ここでは、ダウンロード、オンライン変更、およびブートアプリケーションの暗号化が有効になっているデバイスの以前にインストールされた証明書を選択できます。複数のデバイスがこのアプリケーションの実行を許可されている場合、リストには複数のエントリを含めることができます。 アプリケーションコードにデジタル署名する アプリケーションはデジタル署名で署名されています。デジタル署名の証明書は、 セキュリティ画面 上のビュー ユーザー タブ。 選択した証明書と対応する情報を表示するための領域 各証明書の情報： のために発行された が発行 から有効 まで有効 拇印 暗号化ウィザード このボタンは、 CODESYS Security Agent がインストールされています。同じ名前のウィザードを起動します。これについては、のヘルプを参照してください CODESYS Security Agent 。 詳細については、以下を参照してください。 プロジェクトの保護と保存 とのヘルプ CODESYS Security Agent " }, 
{ "title" : "ダイアログ：プロパティ：ビルド ", 
"url" : "_cds_dlg_properties_build.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロパティ \/ ダイアログ：プロパティ：ビルド ", 
"snippet" : "建てる シンボル： 関数 ：ダイアログには、オブジェクトをコンパイル（ビルド操作）するためのオプションが含まれています。 電話 ： 表示→プロパティ 指図;デバイスツリー内のオブジェクトのコンテキストメニュー 名前 説明 ビルドから除外する ：このオブジェクトとその子オブジェクトは、次のコンパイル操作には含まれません。 オブジェクトエントリは、緑色のフォントで表示されます。 デバイス ビューまたはで POU 見る。 外部実装 （ランタイムシステムのレイトリンク） ： CODESYS プロジェクトのコンパイル時に、このオブジェクトのコードは生成されません。プロジェクトがターゲットシステムで実行さ...", 
"body" : "建てる シンボル： 関数 ：ダイアログには、オブジェクトをコンパイル（ビルド操作）するためのオプションが含まれています。 電話 ： 表示→プロパティ 指図;デバイスツリー内のオブジェクトのコンテキストメニュー 名前 説明 ビルドから除外する ：このオブジェクトとその子オブジェクトは、次のコンパイル操作には含まれません。 オブジェクトエントリは、緑色のフォントで表示されます。 デバイス ビューまたはで POU 見る。 外部実装 （ランタイムシステムのレイトリンク） ： CODESYS プロジェクトのコンパイル時に、このオブジェクトのコードは生成されません。プロジェクトがターゲットシステムで実行されるとすぐに、オブジェクトがそこに存在する場合（たとえば、ライブラリ内）にリンクされます。 これらのオブジェクト名 (関数ブロックとメソッド) の最大長は 64 文字です。 オブジェクト名は次のように追加されます (EXT) の中に デバイス ビューまたはで POU 見る。 システムコールを有効にする ：関数のシステムコール（ランタイムシステム）が可能です。 背景：とは異なります CoDeSys V2.3 、のADR演算子 V3 関数名、プログラム名、関数ブロック名、およびメソッド名とともに使用できます。それは INSTANCE_OF オペレーター。 ただし、内部から関数ポインタを呼び出すことはできません CODESYS 。 常にリンク ：オブジェクトはコンパイラーでマークされているため、常にコンパイル情報に含まれます。これは、常にコンパイルされ、コントローラーにダウンロードされることを意味します。 注：プラグマ {属性 'linkalways'} また、常にオブジェクトを含めるようにコンパイラーに指示するために使用することもできます。 コンパイラは定義します ここでは、オブジェクトをコンパイルするための「定義」または条件を指定できます（条件付きコンパイル）。を指定することもできます expr これらの種類のプラグマで使用される式。カンマ区切りのリストとして複数のエントリを入力できます（を参照）。 {define} ステートメント）。 例： hello, test:='1' デバイスの説明からの追加のコンパイラ定義 デバイスで定義 デバイス記述に由来するコンパイラ定義のリスト これらのコンパイラ定義は、にリストされていない場合、ビルドで使用されます。 無視された定義 分野。 無視された定義 ビルドで使用されないデバイス記述からのコンパイラ定義のリスト 選択したコンパイラ定義をからコピーします デバイスで定義 フィールドに 無視された定義 分野 選択したコンパイラ定義をから移動します 無視された定義 フィールドに デバイスで定義 分野 コンパイラ定義はビルドで使用されます。 詳細については、以下を参照してください。 条件付きプラグマ" }, 
{ "title" : "ダイアログ：プロパティ：アクセス制御 ", 
"url" : "_cds_dlg_properties_access_control.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロパティ \/ ダイアログ：プロパティ：アクセス制御 ", 
"snippet" : "アクセス制御 関数 ：タブは、オブジェクトに対してどのユーザーグループがどのアクションを実行できるかを定義するために使用されます。 電話 ： 表示→プロパティ 指図;コンテキストメニュー、 プロパティ 指図、 アクセス制御 タブ 要件 ：オブジェクトが選択されている デバイス ビューまたはで POU 見る。 グループ、アクション、および権限 既存のユーザーグループがオブジェクトに対して持っている次の権限のどれを示す表： 意見 編集 削除する 子を追加\/削除 権限シンボルをダブルクリックして、可能なすべての権限のリストボックスを開くことができます。 詳細については、以下を参照してください。 アク...", 
"body" : "アクセス制御 関数 ：タブは、オブジェクトに対してどのユーザーグループがどのアクションを実行できるかを定義するために使用されます。 電話 ： 表示→プロパティ 指図;コンテキストメニュー、 プロパティ 指図、 アクセス制御 タブ 要件 ：オブジェクトが選択されている デバイス ビューまたはで POU 見る。 グループ、アクション、および権限 既存のユーザーグループがオブジェクトに対して持っている次の権限のどれを示す表： 意見 編集 削除する 子を追加\/削除 権限シンボルをダブルクリックして、可能なすべての権限のリストボックスを開くことができます。 詳細については、以下を参照してください。 アクセス権を使用してプロジェクト内のオブジェクトを保護する " }, 
{ "title" : "ダイアログ: プロパティ – 外部ファイル ", 
"url" : "_cds_dlg_properties_external_file.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロパティ \/ ダイアログ: プロパティ – 外部ファイル ", 
"snippet" : "プロパティ – 外部ファイル 関数 : 選択したオブジェクトのプロパティ (タイプ 外部ファイル  ) がこのダイアログに表示されます。プロパティは、オブジェクトがデバイス ツリーまたはプールに追加されたときに最初に設定され、このプロパティ ダイアログで調整できます。 電話 : 表示 → プロパティ 指図;オブジェクトのコンテキスト メニュー 要件 ： の中に デバイス 表示または POU ビュー、タイプのオブジェクト 外部ファイル が選択されます。 詳細については、次を参照してください。 外部ファイルファイル処理 外部ファイルの保存方法を決定します。 CODESYS 計画 リンクを覚えておい...", 
"body" : "プロパティ – 外部ファイル 関数 : 選択したオブジェクトのプロパティ (タイプ 外部ファイル  ) がこのダイアログに表示されます。プロパティは、オブジェクトがデバイス ツリーまたはプールに追加されたときに最初に設定され、このプロパティ ダイアログで調整できます。 電話 : 表示 → プロパティ 指図;オブジェクトのコンテキスト メニュー 要件 ： の中に デバイス 表示または POU ビュー、タイプのオブジェクト 外部ファイル が選択されます。 詳細については、次を参照してください。 外部ファイルファイル処理 外部ファイルの保存方法を決定します。 CODESYS 計画 リンクを覚えておいてください : Windows ファイル システムの外部ファイルを指すファイル リンクが保存されます。 注: ファイルの外部の場所が変更された場合、ファイル リンクを介したアクセスは失敗します。ファイルは、定義された保存場所に存在する限り、プロジェクトでのみ使用できます。 リンクを覚えて、プロジェクトに埋め込みます : Windows ファイル システムの外部ファイルを指すファイル リンクが保存されます。さらに、セキュリティを強化するために、ファイルのコピーがプロジェクトに保存されます。 アクセス時の動作に関する注意: プロジェクト内のコピーは、リンク経由のアクセスが失敗した場合にのみアクセスされます。 外部ファイルが変更された場合、コピーは下で選択されたオプションに従って処理されます 外部ファイルが変更されると、 . プロジェクトに埋め込む : 外部ファイルのコピーが Windows ファイル システムに保存されます。 注: コピーは常にアクセスされます。外部ファイルが変更された場合、プロジェクト内部のコピーは更新されません。 外部ファイルが変更されると、 ファイルリンクが同時に保存されたプロジェクトに保存されたコピーの更新の種類 要件: リンクを覚えてプロジェクトに埋め込む オプションが選択されています。 ファイルを自動的にリロードします 注: 外部ファイルが変更されると、プロジェクトに保存されているコピーが更新されます。 ファイルをリロードするかどうかを確認する 注: 外部ファイルが変更された場合、プロジェクトでコピーを更新するかどうかを決定するダイアログ プロンプトが表示されます。 何もしない : 外部ファイルは変更されますが、プロジェクト内のコピーは変更されません。 リンクされたファイル プロジェクトに保存されたファイル リンクに関する情報 要件: いずれか リンクを覚える オプションまたは リンクを覚えてプロジェクトに埋め込む オプションが選択されています。 名前 、 位置 、 サイズ 、 かわった ファイルリンクに関する情報 ボタン： ファイルのプロパティを表示する デフォルトを開く <ファイル名> のプロパティ Windows ファイル システムの外部ファイルのダイアログ このダイアログは、 プロパティ ファイルのコンテキスト メニューから Windows で開くことができるダイアログ。 埋め込みファイル プロジェクトに保存されたコピーに関する情報 要件：いずれか リンクを覚えて、プロジェクトに埋め込みます オプションまたは プロジェクトに埋め込む オプションが選択されています。 サイズ 、 かわった コピーに関する情報 (埋め込みファイル) 埋め込まれたファイルを更新します 注: 外部ファイルが変更された場合、プロジェクトに埋め込まれたコピーが更新されます。 オンライン取り扱い オンラインモードでのファイルの扱い ダウンロード\/オンライン変更による転送 : ダウンロードおよびオンライン変更が行われると、外部ファイルがコントローラにダウンロードされ、 ターゲット パス . ターゲット パス (デバイスの \"$PlcLogic$\" からの相対パス) ターゲット パスは、次の方法で指定できます。 のために $PlcLogic$ ルート ディレクトリ: 入力フィールドを空白のままにします ルート ディレクトリの個々のフォルダ (まだ利用できません) 例： MySubDirectory アプリケーションのフォルダ（以下 $PlcLogic$ ) 「App123」アプリケーションの例: App123 アプリケーションフォルダーの下にネストされたフォルダー構造 例： App123\/Sub01\/SubSub01 別の使用可能なプレースホルダーを使用する 視覚化の例: $visu$ 使用可能なパスを使用する場合は、大文字と小文字に注意してください。 ボタン OK の設定を適用します 物体 " }, 
{ "title" : "ダイアログ：プロパティ：ビットマップ ", 
"url" : "_cds_dlg_properties_bitmap.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロパティ \/ ダイアログ：プロパティ：ビットマップ ", 
"snippet" : "ビットマップ 関数 ：ダイアログは、オブジェクトがビットマップファイル（画像ファイル）を取得するかどうか、およびどのファイルを取得するかを定義するために使用されます。ビットマップは、ライブラリマネージャーのグラフィカルビューと ツールボックス FBD \/ LD \/ ILエディターのビュー。 電話 ： 表示→プロパティ 指図;オブジェクトのコンテキストメニュー 要件 ：オブジェクトはで選択されています デバイス ビューまたは POU 見る。 透明色 この色は、ビットマップで透過的に表示されます。...", 
"body" : "ビットマップ 関数 ：ダイアログは、オブジェクトがビットマップファイル（画像ファイル）を取得するかどうか、およびどのファイルを取得するかを定義するために使用されます。ビットマップは、ライブラリマネージャーのグラフィカルビューと ツールボックス FBD \/ LD \/ ILエディターのビュー。 電話 ： 表示→プロパティ 指図;オブジェクトのコンテキストメニュー 要件 ：オブジェクトはで選択されています デバイス ビューまたは POU 見る。 透明色 この色は、ビットマップで透過的に表示されます。 " }, 
{ "title" : "ダイアログ：プロパティ：アプリケーションビルドオプション ", 
"url" : "_cds_dlg_properties_options_app_generation.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロパティ \/ ダイアログ：プロパティ：アプリケーションビルドオプション ", 
"snippet" : "アプリケーションビルドオプション 関数 ：ダイアログには、次の設定が含まれています CODESYS コントローラのブートアプリケーションを生成するために使用します。 電話 ： 表示→プロパティ 指図;アプリケーションオブジェクトのコンテキストメニュー アプリケーション情報をダウンロードする この機能には、コンパイラバージョン> = 3.5.0.0、ランタイムシステムバージョン> = 3.5.0.0が必要です。 アプリケーションの内容に関する情報もコントローラーにダウンロードされます。現在のアプリケーションとコントローラー上のアプリケーションの違いを確認できるため、このオプションを有効にしておく...", 
"body" : "アプリケーションビルドオプション 関数 ：ダイアログには、次の設定が含まれています CODESYS コントローラのブートアプリケーションを生成するために使用します。 電話 ： 表示→プロパティ 指図;アプリケーションオブジェクトのコンテキストメニュー アプリケーション情報をダウンロードする この機能には、コンパイラバージョン> = 3.5.0.0、ランタイムシステムバージョン> = 3.5.0.0が必要です。 アプリケーションの内容に関する情報もコントローラーにダウンロードされます。現在のアプリケーションとコントローラー上のアプリケーションの違いを確認できるため、このオプションを有効にしておくことをお勧めします。比較には、POUの数、データの数、およびメモリの場所の数が含まれます。 違いに関する情報を取得するには、をクリックします 詳細 の中に アプリケーション デバイスエディタのタブ。これは、コントローラーに存在するものとは異なる場合はいつでも、アプリケーションをコントローラーにダウンロードしたときに開くメッセージビューにもあります。 例外で親アプリケーションを停止する 親アプリケーションを使用するアプリケーションで使用可能 ダイナミックメモリ設定 たとえば、メモリを使用する場合、メモリはアプリケーションに動的に割り当てられます。 __NEW オペレーター。この場合、必要なものを定義します メモリの最大サイズ（バイト） 。 注意：オブジェクトを動的に作成するためにメモリ全体を使用することはできません。代わりに、システムは常にその一部を管理情報に使用します。 詳細については、以下を参照してください。 アプリケーションコードの生成" }, 
{ "title" : "ダイアログ：プロパティ：ターゲットメモリ設定 ", 
"url" : "_cds_dlg_properties_target_memory_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロパティ \/ ダイアログ：プロパティ：ターゲットメモリ設定 ", 
"snippet" : "ターゲットメモリ設定 関数 ：ダイアログでは、ターゲットデバイスのメモリ設定を変更できます。 電話 ： 表示→プロパティ 指図;アプリケーションのコンテキストメニュー 要件 ：アプリケーションはで選択されています デバイス 見る。 ターゲットメモリ設定を上書きする ：デバイスの説明に保存されているメモリ設定は、で指定された値によって上書きされます 入力サイズ 、 出力サイズ 、 と メモリー容量 。 注：ターゲットデバイスのメモリ設定が変更されると、ターゲットデバイス上の既存のアプリケーションにログインできなくなり、オンラインで変更を実行できなくなります。 入力サイズ 出力サイズ メモリー容量...", 
"body" : "ターゲットメモリ設定 関数 ：ダイアログでは、ターゲットデバイスのメモリ設定を変更できます。 電話 ： 表示→プロパティ 指図;アプリケーションのコンテキストメニュー 要件 ：アプリケーションはで選択されています デバイス 見る。 ターゲットメモリ設定を上書きする ：デバイスの説明に保存されているメモリ設定は、で指定された値によって上書きされます 入力サイズ 、 出力サイズ 、 と メモリー容量 。 注：ターゲットデバイスのメモリ設定が変更されると、ターゲットデバイス上の既存のアプリケーションにログインできなくなり、オンラインで変更を実行できなくなります。 入力サイズ 出力サイズ メモリー容量 オーバーライドに使用されるメモリサイズの入力フィールド \"memory-layout\\\\input-size\" 、 \"memory-layout\\\\output-size\" 、 と \"memory-layout\\\\memory-size\" デバイスの説明に保存されている値 要件： ターゲットメモリ設定を上書きする オプションが選択されています。 " }, 
{ "title" : "ダイアログ：プロパティ：ネットワーク変数 ", 
"url" : "_cds_dlg_properties_networkvariables.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロパティ \/ ダイアログ：プロパティ：ネットワーク変数 ", 
"snippet" : "ネットワーク変数 シンボル： 関数 ：このダイアログでは、デバイスツリーで選択されている変数リストのネットワークプロパティを定義します。さらに、ネットワーク変数として宣言されている変数も使用できます。 電話 ： デバイスツリーの変数リストのコンテキストメニュー→プロパティ 、 ネットワーク変数 タブ ネットワークタイプ UDP 仕事 送信する変数を制御する現在のアプリケーションのタスク CODESYS タスクサイクルの最後に常に変数を送信します。 リスト識別子 ネットワーク変数リストを識別するために使用されます ユニークである必要があります パック変数 送信されるパッケージ（テレグラム）のサイ...", 
"body" : "ネットワーク変数 シンボル： 関数 ：このダイアログでは、デバイスツリーで選択されている変数リストのネットワークプロパティを定義します。さらに、ネットワーク変数として宣言されている変数も使用できます。 電話 ： デバイスツリーの変数リストのコンテキストメニュー→プロパティ 、 ネットワーク変数 タブ ネットワークタイプ UDP 仕事 送信する変数を制御する現在のアプリケーションのタスク CODESYS タスクサイクルの最後に常に変数を送信します。 リスト識別子 ネットワーク変数リストを識別するために使用されます ユニークである必要があります パック変数 送信されるパッケージ（テレグラム）のサイズは、ネットワークの種類によって異なります。の場合 UDP 、パッケージは256バイトです。 ： CODESYS 送信するパッケージの数を可能な限り減らすために、パッケージを送信するための変数をバンドルします。配列型または構造化データ型の変数の場合、これにより、変数が複数のテレグラムに分割される可能性があります。その結果、変数のサイズがパッケージのサイズよりも小さい場合でも、これらの変数内でデータの不整合が発生する可能性があります。 ： CODESYS 変数ごとに1つのパッケージを生成します。 チェックサムを送信する ：変数パッケージごとにチェックサムが提供されます。受信者はチェックサムをチェックして、変数定義が送信者と受信者から一致していることを確認します。チェックサムが競合するパッケージは受け入れられません。 了承 ： CODESYS 受信したデータパッケージごとに確認メッセージを送信します。送信者が再送信する前に確認応答を受信しない場合、エラーが診断構造に書き込まれます。 注： NetVarUdp ライブラリバージョン3.5.7.0以降では、確認済みの転送が選択されていない場合、受信者チャネルは割り当てられなくなりました。その結果、1つのハードウェアデバイス上の2つのコントローラー間でネットワーク変数の交換も可能です。 サイクリックトランスミッション 、 間隔 CODESYS 定義された間隔内で変数を送信します。 時間定義の例：「T＃70ms」 変更時に送信 、 最小ギャップ ： CODESYS 値が変更された場合にのみ変数を送信します。 「最小ギャップ」を使用して、2つの送信間の最小時間を定義できます。 イベントで送信 、 変数 ： CODESYS 定義された変数が生成されるとすぐに変数を送信します TRUE 。 設定 プロトコル固有の設定 可能なエントリは、ネットワークライブラリによって異なります。 ポート ：ポートの番号 CODESYS 他のネットワークユニットとのデータ交換に使用 The デフォルト値 「1202」です。 現在の値はいつでも変更できます 価値 フィールド：フィールドを選択し、を押します スペースキー 、値を指定します。 注意 ：ネットワーク内の他のノードは同じポートを定義する必要があります。プロジェクトで複数のUDP接続が定義されている場合、すべての構成のポート番号がこの値に適合します。 放送Adr。 ： デフォルト値 は255.255.255.255です。これは、すべてのネットワークユニットでデータ交換が行われることを意味します。 現在の値はいつでも変更できます 価値 フィールド：フィールドを選択し、を押します スペースキー 、およびサブネットワークのアドレスまたはアドレス範囲を指定します。 例： 197.200.100.255 「197.200.100.x」の範囲のIPアドレスを持つすべてのノードと通信を行う必要がある場合 詳細については、以下を参照してください。 ネットワーク変数交換の構成" }, 
{ "title" : "ダイアログ：プロパティ：ネットワーク設定 ", 
"url" : "_cds_dlg_properties_network_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロパティ \/ ダイアログ：プロパティ：ネットワーク設定 ", 
"snippet" : "ネットワーク設定 デバイスがネットワーク機能をサポートしている場合は、GNVL（グローバルネットワーク変数リスト）の現在のネットワーク設定を表示および変更できます。 プロパティ オブジェクトのダイアログ。これらは、GNVLをに追加するときに使用された設定です。 ネットワーク変数リストの追加（受信者） ダイアログ。 詳細については、以下を参照してください。 ネットワーク変数交換の構成...", 
"body" : "ネットワーク設定 デバイスがネットワーク機能をサポートしている場合は、GNVL（グローバルネットワーク変数リスト）の現在のネットワーク設定を表示および変更できます。 プロパティ オブジェクトのダイアログ。これらは、GNVLをに追加するときに使用された設定です。 ネットワーク変数リストの追加（受信者） ダイアログ。 詳細については、以下を参照してください。 ネットワーク変数交換の構成" }, 
{ "title" : "ダイアログ：プロパティ：ァイルへのリンク ", 
"url" : "_cds_dlg_properties_link_to_file.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロパティ \/ ダイアログ：プロパティ：ァイルへのリンク ", 
"snippet" : "ファイルへのリンク 関数 ：ダイアログは、外部ファイルとグローバル変数リスト（GVL）の内容とのリンクを定義します。 GVLを外部ファイルにエクスポートするか、外部ファイルからインポートすることができます。 電話 ： 表示→プロパティ 指図;のコンテキストメニュー グローバル変数リスト 物体 ファイル名 ファイルパスの入力フィールド コンパイルする前にエクスポートする ：プロジェクトの各コンパイルの前（たとえば、 F11 ）、 CODESYS でファイルを保存します gvl パスの拡張子。これは、 ファイル名 分野。 コンパイルする前にインポートする ：で指定されているエクスポートファイル フ...", 
"body" : "ファイルへのリンク 関数 ：ダイアログは、外部ファイルとグローバル変数リスト（GVL）の内容とのリンクを定義します。 GVLを外部ファイルにエクスポートするか、外部ファイルからインポートすることができます。 電話 ： 表示→プロパティ 指図;のコンテキストメニュー グローバル変数リスト 物体 ファイル名 ファイルパスの入力フィールド コンパイルする前にエクスポートする ：プロジェクトの各コンパイルの前（たとえば、 F11 ）、 CODESYS でファイルを保存します gvl パスの拡張子。これは、 ファイル名 分野。 コンパイルする前にインポートする ：で指定されているエクスポートファイル ファイル名 フィールドは、各プロジェクトがコンパイルされる前に自動的に読み取られます。その結果、別のプロジェクトからエクスポートされたGVLをインポートして、たとえばネットワーク変数を使用して通信を設定することができます。 " }, 
{ "title" : "ダイアログ：プロパティ：オプション ", 
"url" : "_cds_dlg_properties_options_controller.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロパティ \/ ダイアログ：プロパティ：オプション ", 
"snippet" : "オプション...", 
"body" : "オプション " }, 
{ "title" : "オプション（コントローラー） ", 
"url" : "_cds_dlg_properties_options_controller.html#UUID-b4ec29e7-91f8-fff3-50ec-7d1a39d7664e_id_efceb58c0a2747d2c0a8640e01d2593a_id_3199fa7b528ae709c0a8640e01bcacf4", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロパティ \/ ダイアログ：プロパティ：オプション \/ オプション（コントローラー） ", 
"snippet" : "関数 ：ダイアログには、デバイスオブジェクトの監視とログインの設定が含まれています。デバイスの説明によって、使用可能なオプションが決まります。 電話 ：デバイスオブジェクトのコンテキストメニュー。 表示→プロパティ デバイスオブジェクトが選択されたときのコマンド 監視間隔（ミリ秒） 監視の間隔（10〜1000ミリ秒） インタラクティブログインモード このモードは、別のコントローラーへの誤ったログインを防ぐために使用されます。 なし ログイン時にユーザーとの対話はありません 古いバージョンの以前の動作に対応します IDを入力してください CODESYS ログイン時にIDを提供する必要があります。...", 
"body" : "関数 ：ダイアログには、デバイスオブジェクトの監視とログインの設定が含まれています。デバイスの説明によって、使用可能なオプションが決まります。 電話 ：デバイスオブジェクトのコンテキストメニュー。 表示→プロパティ デバイスオブジェクトが選択されたときのコマンド 監視間隔（ミリ秒） 監視の間隔（10〜1000ミリ秒） インタラクティブログインモード このモードは、別のコントローラーへの誤ったログインを防ぐために使用されます。 なし ログイン時にユーザーとの対話はありません 古いバージョンの以前の動作に対応します IDを入力してください CODESYS ログイン時にIDを提供する必要があります。 IDはコントローラーに保存されます。有効なIDがないとログインできません。 次のログイン時に、 CODESYS コンピューター名、ユーザー名、デバイス名、およびデバイスアドレスが変更されていない場合、IDを要求しなくなります。情報はプロジェクトオプションに保存されます。 キーを押す ログイン時にダイアログが開き、コントローラのキーを押すように求められます。このアクションのタイムアウトは、デバイスの説明で定義されています。 ウインク（= LEDを点滅） ログイン時に接続されているコントローラーが点滅します。 シンボル構成 IECタスクと同期した変数へのアクセス ： デフォルト設定;一貫したアクセスは許可されていません ：一貫したアクセスが許可されます この設定は、すべてのアプリケーションをダウンロードし、アプリケーションをコントローラーに再度起動した後にのみ有効になります。 注：このオプションを選択すると、すべてのIECアプリケーションでこのデバイスのジッターが増加する可能性があります。一貫したアクセスにより、リアルタイム機能が中断される可能性があります。 詳細については、以下を参照してください。 デバイス、および汎用デバイスエディタ と アイコン設定 " }, 
{ "title" : "ダイアログ：プロパティ：監視 ", 
"url" : "_cds_dlg_properties_monitoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロパティ \/ ダイアログ：プロパティ：監視 ", 
"snippet" : "モニタリング 関数 ：タブには、監視のオプションが含まれています トランジション SFCで。 電話 ：トランジションオブジェクトを選択してから プロパティ コンテキストメニューまたは 表示→プロパティ 指図 監視を有効にする ：トランジション用に暗黙の変数が作成され、アプリケーションがトランジションメソッドを呼び出すと、常に現在のプロパティ値が与えられます。この変数に最後に格納された値は、モニタリングに表示されます。 通話を使用した監視 ：監視対象の遷移は、遷移を直接呼び出すことによって読み取られます。 注：このオプションを選択するときは、起こりうる副作用を考慮する必要があります。これらの種類...", 
"body" : "モニタリング 関数 ：タブには、監視のオプションが含まれています トランジション SFCで。 電話 ：トランジションオブジェクトを選択してから プロパティ コンテキストメニューまたは 表示→プロパティ 指図 監視を有効にする ：トランジション用に暗黙の変数が作成され、アプリケーションがトランジションメソッドを呼び出すと、常に現在のプロパティ値が与えられます。この変数に最後に格納された値は、モニタリングに表示されます。 通話を使用した監視 ：監視対象の遷移は、遷移を直接呼び出すことによって読み取られます。 注：このオプションを選択するときは、起こりうる副作用を考慮する必要があります。これらの種類の副作用は、移行中に追加の操作が実装された場合に発生する可能性があります。 詳細については、以下を参照してください。 monitoring" }, 
{ "title" : "ダイアログ：プロジェクト設定 ", 
"url" : "_cds_f_dlg_project_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト設定 ", 
"snippet" : "プロジェクト設定 シンボル： 関数 ：オブジェクトには、プロジェクトの基本構成が含まれています。で編集できます プロジェクト設定 ダイアログ。 電話 ：ダブルクリック プロジェクト設定 デバイスツリー内のオブジェクト。 プロジェクト→プロジェクト設定 指図 CODESYS プロジェクト設定をプロジェクトに直接保存します。たとえば、プロジェクトを別のシステムに転送する場合、 プロジェクト設定 オブジェクトはそれと一緒に転送されます。プロジェクトアーカイブは必要ありません。 プロジェクト設定はプロジェクト全体で有効であり、インストールされているパッケージに応じて、次のようなさまざまなカテゴリの可能...", 
"body" : "プロジェクト設定 シンボル： 関数 ：オブジェクトには、プロジェクトの基本構成が含まれています。で編集できます プロジェクト設定 ダイアログ。 電話 ：ダブルクリック プロジェクト設定 デバイスツリー内のオブジェクト。 プロジェクト→プロジェクト設定 指図 CODESYS プロジェクト設定をプロジェクトに直接保存します。たとえば、プロジェクトを別のシステムに転送する場合、 プロジェクト設定 オブジェクトはそれと一緒に転送されます。プロジェクトアーカイブは必要ありません。 プロジェクト設定はプロジェクト全体で有効であり、インストールされているパッケージに応じて、次のようなさまざまなカテゴリの可能な設定を提供します。 SFC また ユーザーとグループ 。 " }, 
{ "title" : "ダイアログ：プロジェクト設定：ユーザーとグループ ", 
"url" : "_cds_dlg_project_settings_user_groups.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト設定 \/ ダイアログ：プロジェクト設定：ユーザーとグループ ", 
"snippet" : "ユーザーとグループ シンボル： 関数 ：ダイアログは、現在のプロジェクトのユーザー管理を構成するために使用されます。 電話 ： プロジェクト→プロジェクト設定 指図、 ユーザーとグループ カテゴリー...", 
"body" : "ユーザーとグループ シンボル： 関数 ：ダイアログは、現在のプロジェクトのユーザー管理を構成するために使用されます。 電話 ： プロジェクト→プロジェクト設定 指図、 ユーザーとグループ カテゴリー " }, 
{ "title" : "タブ：ユーザー ", 
"url" : "_cds_dlg_project_settings_user_groups.html#UUID-2be88356-b96d-20b2-57af-5b575487a87f_id_c4a56f464271c61c0a8640e019890cd_id_bd8ddfdd6488f1d2c0a8640e00905b40", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト設定 \/ ダイアログ：プロジェクト設定：ユーザーとグループ \/ タブ：ユーザー ", 
"snippet" : "ユーザーとそのメンバーシップをグループで表示します 追加 を開きます ユーザーを追加する ダイアログ 編集 を開きます ユーザーの編集 ダイアログ 消去 グループには少なくとも1つのメンバーが必要であるため、グループの最後のユーザーを削除しようとすると、エラーメッセージが表示されます。 ユーザーを追加する \/ ユーザーの編集 新しいユーザーアカウントを設定したり、既存のユーザーアカウントを変更したりするための入力フィールド アクティブ ：(デフォルト）ユーザーアカウントを使用できます。 ：ユーザーはログインできません。ユーザーが間違った資格情報で繰り返しログインしようとすると、アカウントが自動...", 
"body" : "ユーザーとそのメンバーシップをグループで表示します 追加 を開きます ユーザーを追加する ダイアログ 編集 を開きます ユーザーの編集 ダイアログ 消去 グループには少なくとも1つのメンバーが必要であるため、グループの最後のユーザーを削除しようとすると、エラーメッセージが表示されます。 ユーザーを追加する \/ ユーザーの編集 新しいユーザーアカウントを設定したり、既存のユーザーアカウントを変更したりするための入力フィールド アクティブ ：(デフォルト）ユーザーアカウントを使用できます。 ：ユーザーはログインできません。ユーザーが間違った資格情報で繰り返しログインしようとすると、アカウントが自動的に無効になる可能性があります（以下を参照：設定）。 メンバーシップ に加えて、定義したすべてのユーザーグループのリスト みんな グループ（各新規ユーザーが自動的に属する） <グループ名>：新しいユーザーはグループに属しています。 輸出入 ユーザーとグループのエクスポート このコマンドは、ローカルファイルシステムにファイルを保存するためのデフォルトのダイアログを開きます。プロジェクトで定義されているユーザーとグループをに保存できます。 *.users XML形式のファイル。 ユーザーとグループのインポート このコマンドは、ファイルを検索するためのデフォルトのダイアログを開きます。 *.users ユーザーとグループの定義をプロジェクトに読み込むためのローカルファイルシステムの拡張子。 " }, 
{ "title" : "タブ：グループ ", 
"url" : "_cds_dlg_project_settings_user_groups.html#UUID-2be88356-b96d-20b2-57af-5b575487a87f_id_c4a56f464271c61c0a8640e019890cd_id_a09a4f276488f1d3c0a8640e011cd62d", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト設定 \/ ダイアログ：プロジェクト設定：ユーザーとグループ \/ タブ：グループ ", 
"snippet" : "グループとそのメンバーの表示 グループは、グループのメンバーになることもできます。 追加 を開きます グループを追加 ダイアログ 編集 を開きます グループの編集 ダイアログ 消去 グループを削除しても、メンバーのユーザーアカウントは変更されません。 削除することはできません みんな と オーナー グループ。 についての情報 輸出入 ボタン、の説明を参照してください ユーザー 上のタブ。...", 
"body" : "グループとそのメンバーの表示 グループは、グループのメンバーになることもできます。 追加 を開きます グループを追加 ダイアログ 編集 を開きます グループの編集 ダイアログ 消去 グループを削除しても、メンバーのユーザーアカウントは変更されません。 削除することはできません みんな と オーナー グループ。 についての情報 輸出入 ボタン、の説明を参照してください ユーザー 上のタブ。 " }, 
{ "title" : "タブ：設定 ", 
"url" : "_cds_dlg_project_settings_user_groups.html#UUID-2be88356-b96d-20b2-57af-5b575487a87f_id_c4a56f464271c61c0a8640e019890cd_id_fa0bbb63c47411e3a9c4fffae27ed7af", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト設定 \/ ダイアログ：プロジェクト設定：ユーザーとグループ \/ タブ：設定 ", 
"snippet" : "ツリー構造でのグループとそのメンバーの表示 グループは、グループのメンバーになることもできます。 認証試行の最大数 ：(デフォルト）ユーザーがここで指定された回数だけ間違ったパスワードでログインしようとすると、ユーザーアカウントは無効になります。 ：失敗した試行の数は無制限です。 非アクティブな時間の後に自動的にログアウトします ：次の場合、ユーザーは自動的にログアウトされます CODESYS ここで指定されている期間（分単位）の間に、マウスまたはキーボードからのユーザーアクションを登録しません。 詳細については、以下を参照してください。 プロジェクトの保護と保存...", 
"body" : "ツリー構造でのグループとそのメンバーの表示 グループは、グループのメンバーになることもできます。 認証試行の最大数 ：(デフォルト）ユーザーがここで指定された回数だけ間違ったパスワードでログインしようとすると、ユーザーアカウントは無効になります。 ：失敗した試行の数は無制限です。 非アクティブな時間の後に自動的にログアウトします ：次の場合、ユーザーは自動的にログアウトされます CODESYS ここで指定されている期間（分単位）の間に、マウスまたはキーボードからのユーザーアクションを登録しません。 詳細については、以下を参照してください。 プロジェクトの保護と保存" }, 
{ "title" : "ダイアログ:プロジェクト設定:ライブラリ開発 ", 
"url" : "_cds_library_development.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト設定 \/ ダイアログ:プロジェクト設定:ライブラリ開発 ", 
"snippet" : "図書館開発 シンボル: ファンクション : のパラメータの設定 すべてのプールオブジェクトをチェックしてください。 コマンド。このコマンドは、すべてのオブジェクトが正しくコンパイルできるかどうかを確認するために特にライブラリで使用されます。 コール : プロジェクト → プロジェクト設定 、 ライブラリ開発 カテゴリー 要件 ：プロジェクトは開いています。 アプリケーションのコンパイルプロセスでは、アプリケーションコードによって実際に直接または間接的に使用される関数ブロック\/プログラム\/関数のみがコンパイルされます。ただし、 すべてのプールオブジェクトを確認してください。 コマンドは未使用のフ...", 
"body" : "図書館開発 シンボル: ファンクション : のパラメータの設定 すべてのプールオブジェクトをチェックしてください。 コマンド。このコマンドは、すべてのオブジェクトが正しくコンパイルできるかどうかを確認するために特にライブラリで使用されます。 コール : プロジェクト → プロジェクト設定 、 ライブラリ開発 カテゴリー 要件 ：プロジェクトは開いています。 アプリケーションのコンパイルプロセスでは、アプリケーションコードによって実際に直接または間接的に使用される関数ブロック\/プログラム\/関数のみがコンパイルされます。ただし、 すべてのプールオブジェクトを確認してください。 コマンドは未使用のファンクションブロック\/プログラム\/ファンクションもチェックします。可能であれば、コード内のすべての実行パスを考慮する必要があります。 使用するコンパイラ定義 スキャン ライブラリのすべてのファンクションブロック\/プログラム\/関数をスキャンし、見つかったコンパイラ定義をコンマで区切られたリストとして入力します 使用するコンパイラ定義 概要。 カスケード用 {IF defined(...)}-{ELSIF defined(...)} ステートメント、次の定義のみ {IF} が考慮されます。 すべてのプールオブジェクトを確認 使用するポインターサイズ POINTER 変数をライブラリの DWORD 変数に保存すると、このライブラリは 32 ビットデバイスでのみコンパイルできます。 この問題を検出して回避するには、に指定するポインタサイズを指定します。 すべてのプールオブジェクトをチェックしてください。 コマンド。以下の値を選択できます 32 ビット 64 ビット 32 ビットおよび 64 ビット 次の例は、の使用方法を示しています すべてのプールオブジェクトをチェックしてください。 64 ビットポインタサイズの無効な代入を検出するコマンド: FUNCTION F : INT\nVAR\n               \nptr : POINTER TO BYTE;\n               \nptrSave : DWORD;\nEND_VAR\nptrSave := ptr; この割り当てはエラーになります C0032: タイプ 'バイトへのポインタ' は 'DWORD' タイプに変換できません 。 次の宣言を次のように使用してください ptrSave このエラーを回避するには: ptrSave : __XWORD; 詳細については、以下を参照してください。 すべてのプールオブジェクトを確認してください" }, 
{ "title" : "ダイアログ：プロジェクト設定：コンパイルオプション ", 
"url" : "_cds_dlg_project_settings_compile_options.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト設定 \/ ダイアログ：プロジェクト設定：コンパイルオプション ", 
"snippet" : "コンパイルオプション シンボル： 関数 ：ダイアログは、コンパイラオプションを設定するために使用されます。 電話 ： プロジェクト→プロジェクト設定 指図、 コンパイルオプション カテゴリー 要件 ：プロジェクトは開いています。 コンパイラバージョン 修正バージョン コンパイル時およびコンパイルのためのロード時に使用されるコンパイラのバージョンを表示します。 最新のコンパイラ バージョンに更新することは可能ですが、古いバージョンにリセットすることはできません。 設定 識別子として Unicode 文字を許可する 識別子名にUnicode文字を使用することは、IEC規格では許可されていないため、...", 
"body" : "コンパイルオプション シンボル： 関数 ：ダイアログは、コンパイラオプションを設定するために使用されます。 電話 ： プロジェクト→プロジェクト設定 指図、 コンパイルオプション カテゴリー 要件 ：プロジェクトは開いています。 コンパイラバージョン 修正バージョン コンパイル時およびコンパイルのためのロード時に使用されるコンパイラのバージョンを表示します。 最新のコンパイラ バージョンに更新することは可能ですが、古いバージョンにリセットすることはできません。 設定 識別子として Unicode 文字を許可する 識別子名にUnicode文字を使用することは、IEC規格では許可されていないため、デフォルトでクリアされています 一部の外国語（アジア言語など）では必要になる場合があります 定数を置き換える ：(デフォルト）値はすべてのスカラー定数に対して直接ロードされます（ STRING 、 ARRAY 、または構造）。 ： （ディフォルト） CODESYS すべてのスカラー定数の値を直接ロードします（したがって、 STRING 、 ARRAY 、または構造）。オンラインモードでは、 CODESYS 宣言エディタまたは監視ビューの値の前に付けられる記号で定数をマークします。この場合、たとえば、 ADR 演算子、強制、および書き込み。 ：定数へのアクセスは可能ですが、計算時間が長くなります。 ブレークポイントでのロギングを有効にする 実行ポイントとして定義されているブレークポイントの場合、メッセージテキストを作成できます。 実行ポイントの設定 ダイアログ。 CODESYS アプリケーションが実行ポイントで停止すると、このテキストをデバイスログに出力します。 STRINGのUTF8エンコーディング ：文字列 STRING データ型は、プロジェクト全体でASCII形式でエンコードされます。リテラルへのインデックスアクセスは正しく機能します。 ：文字列 STRING データ型は、プロジェクト全体でUTF-8形式でエンコードされます。これはすべてに適用されます STRING 文字通り、監視にも使用されます。 UTF-8リテラルへのインデックスアクセスはお勧めできません。ほとんどの場合、エラーが発生します。 プロジェクト全体をUTF-8形式にエンコードする必要がない場合は、単一の変数型を暗黙的に変換できます。 UTF8# プレフィックス。 プロジェクト全体の構成専用のUTF-8エンコーディング プロジェクト全体のコンパイルオプションの場合、UTF-8エンコーディングが使用されます STRINGのUTF8エンコーディング 有効になっています。ライブラリ関数とアドオンも、この設定に従って方向付けられます。 単一のUTF-8エンコード文字列を使用する場合は、それらが使用される場所で正しく解釈されることを確認する必要があります。たとえば、設定が選択されていない場合、OPCサーバーの文字列変数はクライアントに転送される前にUTF-8に変換されます。次のような値 UTF8#'äöü' その後、誤解されます。ビジュアライゼーションで文字列を出力するときにも、同様の問題が発生する可能性があります。 プロジェクト定義の編集 を開きます プロジェクト定義の編集 ダイアログ。 コンパイラの警告 警告の最大数 警告を参照します CODESYS メッセージビューに出力します 表示されるコンパイラ警告の選択を定義します。 プロジェクト設定 ダイアログの コンパイラの警告 カテゴリー。 ダイアログ： プロジェクト定義の編集 プロジェクト定義の追加 テーブルに新しい行を追加します。この行をダブルクリックして行エディタを開き、新しいプロジェクト定義の識別子を入力します。新しいプロジェクト定義は有効な IEC 識別子である必要があります。 プロジェクト定義は、プロジェクト全体および参照されるすべてのライブラリで有効です。これらはパブリック インターフェイスには適用されません。 プロジェクト定義の詳細については、以下を参照してください。 project_defined (<global define>)" }, 
{ "title" : "ダイアログ：プロジェクト設定：コンパイラの警告 ", 
"url" : "_cds_dlg_project_settings_compile_warnings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト設定 \/ ダイアログ：プロジェクト設定：コンパイラの警告 ", 
"snippet" : "コンパイラの警告 シンボル： 関数 ：ダイアログは、コンパイラの警告を選択するために使用されます。 CODESYS コンパイル操作中にメッセージビューに表示されます。 電話 ： プロジェクト→プロジェクト設定 指図、 コンパイラの警告 カテゴリー 要件 ：プロジェクトは開いています。 チェックボックスをクリックすると、個々のメッセージを次のように構成できます。 : メッセージは表示されません。 : メッセージは警告として表示されます。 メッセージはエラーとして表示されます。アプリケーションをダウンロードすることはできません。 リストされている警告の最大数を コンパイルオプション ダイアログ。 ...", 
"body" : "コンパイラの警告 シンボル： 関数 ：ダイアログは、コンパイラの警告を選択するために使用されます。 CODESYS コンパイル操作中にメッセージビューに表示されます。 電話 ： プロジェクト→プロジェクト設定 指図、 コンパイラの警告 カテゴリー 要件 ：プロジェクトは開いています。 チェックボックスをクリックすると、個々のメッセージを次のように構成できます。 : メッセージは表示されません。 : メッセージは警告として表示されます。 メッセージはエラーとして表示されます。アプリケーションをダウンロードすることはできません。 リストされている警告の最大数を コンパイルオプション ダイアログ。 詳細については、以下を参照してください。 コンパイルオプション" }, 
{ "title" : "ダイアログ：プロジェクト設定：ソースのダウンロード ", 
"url" : "_cds_dlg_project_settings_source_code.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト設定 \/ ダイアログ：プロジェクト設定：ソースのダウンロード ", 
"snippet" : "ソースのダウンロード シンボル： 関数 ：ダイアログは、ソースコードの転送と保存を1つ以上のコントローラー上のソースダウンロードアーカイブとして定義します。 電話 ： プロジェクト→プロジェクト設定 指図、 ソースのダウンロード カテゴリー ソースダウンロードアーカイブは、という名前のプロジェクトアーカイブです。 Archive.prj 。 ターゲットデバイス プロジェクトアーカイブの場所を定義します <コントローラーの名前> 選択したコントローラー CODESYS プロジェクトアーカイブをこのコントローラーにダウンロードします。要件：プロジェクトには複数のコントローラーが含まれています。 <...", 
"body" : "ソースのダウンロード シンボル： 関数 ：ダイアログは、ソースコードの転送と保存を1つ以上のコントローラー上のソースダウンロードアーカイブとして定義します。 電話 ： プロジェクト→プロジェクト設定 指図、 ソースのダウンロード カテゴリー ソースダウンロードアーカイブは、という名前のプロジェクトアーカイブです。 Archive.prj 。 ターゲットデバイス プロジェクトアーカイブの場所を定義します <コントローラーの名前> 選択したコントローラー CODESYS プロジェクトアーカイブをこのコントローラーにダウンロードします。要件：プロジェクトには複数のコントローラーが含まれています。 <プロジェクト内のすべてのデバイス> CODESYS プロジェクトアーカイブをプロジェクト内のすべてのコントローラーにダウンロードします。 コンテンツ プロジェクトアーカイブの内容を定義します コンパクトなダウンロードを使用する ：プロジェクトアーカイブには、アクティブなアプリケーションを含むプロジェクトデバイスのみが含まれます。 ：プロジェクトアーカイブには、プロジェクト内のすべてのデバイスが含まれています。 追加ファイル を開きます 追加ファイル ダウンロードするファイルをさらに選択できるダイアログ タイミング 時間を定義します CODESYS プロジェクトアーカイブを作成します プログラムのダウンロードとオンライン変更で暗黙的に アプリケーションがダウンロードされるか、オンライン変更が実行されるたびに、 CODESYS また、プロンプトなしでプロジェクトアーカイブを宛先デバイスにダウンロードします。 ブートプロジェクトの作成時に暗黙的に ブートアプリケーションが作成されるたびに、 CODESYS また、プロンプトなしでプロジェクトアーカイブを宛先デバイスにダウンロードします。 暗黙的にブートプロジェクトの作成、ダウンロード、オンライン変更 ブートアプリケーションが作成されるたびに、アプリケーションがダウンロードされるか、オンライン変更が実行されます。 CODESYS また、プロンプトなしでプロジェクトアーカイブを宛先デバイスにダウンロードします。 プログラムのダウンロードとオンライン変更でプロンプトを表示 アプリケーションがダウンロードされるか、オンライン変更が実行されるたびに、 CODESYS プロンプトを開きます。そこで、かどうかを選択できます CODESYS プロジェクトアーカイブをコントローラーにダウンロードする必要があります。 オンデマンドのみ プロンプトは、 オンライン→接続されたコントローラーにソースコードをロード コマンドが呼び出されます。そこで、かどうかを選択できます CODESYS プロジェクトアーカイブをコントローラーにダウンロードする必要があります。 詳細については、以下を参照してください。 PLCとの間でソースコードをダウンロードする" }, 
{ "title" : "ダイアログ：プロジェクト設定–監視 ", 
"url" : "_cds_dlg_project_settings_monitoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト設定 \/ ダイアログ：プロジェクト設定–監視 ", 
"snippet" : "モニタリング シンボル： 関数 ：ダイアログには、モニタリングで変数値を表示するための設定が含まれています。 電話 ： ツール→オプション 指図、 モニタリング カテゴリー 整数変数のモード バイナリ 変数の値は、オンラインモードで対応する形式で表示されます。 このオプションは、 デバッグ→表示モード 指図。 10進数 16進数 表示桁数 REAL値が表示されたときにオンラインモードで表される小数点以下の桁数 注：設定は、ウォッチリスト、宣言エディタの監視、およびトレースエディタに適用されます。エディターのインライン監視の構成は、テキストエディターのオプションで設定されます。 継承階層の構造化...", 
"body" : "モニタリング シンボル： 関数 ：ダイアログには、モニタリングで変数値を表示するための設定が含まれています。 電話 ： ツール→オプション 指図、 モニタリング カテゴリー 整数変数のモード バイナリ 変数の値は、オンラインモードで対応する形式で表示されます。 このオプションは、 デバッグ→表示モード 指図。 10進数 16進数 表示桁数 REAL値が表示されたときにオンラインモードで表される小数点以下の桁数 注：設定は、ウォッチリスト、宣言エディタの監視、およびトレースエディタに適用されます。エディターのインライン監視の構成は、テキストエディターのオプションで設定されます。 継承階層の構造化された表現 ：ファンクションブロックと構造の継承階層がツリー構造で表示されます。変数は、関数ブロックの子ノードまたは変数が宣言されている構造体として表示されます。 ：表現はフラットリストとして表示されます。 詳細については、以下を参照してください。 タブ：監視 " }, 
{ "title" : "ダイアログ：プロジェクト設定：ページ設定 ", 
"url" : "_cds_dlg_project_settings_page_setup.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト設定 \/ ダイアログ：プロジェクト設定：ページ設定 ", 
"snippet" : "ページ設定 シンボル： 関数 ：ダイアログは、プロジェクトコンテンツの印刷バージョンのレイアウトを定義します。レイアウトは、プロジェクト情報の印刷に使用されます。 ファイル→ 印刷 コマンドとプロジェクトドキュメントのプリントアウト プロジェクト→ 書類 指図。 電話 ： プロジェクト→プロジェクト設定 指図、 ページ設定 カテゴリー 次のプロパティの設定を構成できます。 論文 マージン ヘッダーとフッター 書類 タイトルページ ヘッダーの編集 \/ フッターを編集する ヘッダーとフッターはテーブルスタイルで構成されています。行と列を構成し、結果のセルにテキストと画像を追加できます。 行スパン ...", 
"body" : "ページ設定 シンボル： 関数 ：ダイアログは、プロジェクトコンテンツの印刷バージョンのレイアウトを定義します。レイアウトは、プロジェクト情報の印刷に使用されます。 ファイル→ 印刷 コマンドとプロジェクトドキュメントのプリントアウト プロジェクト→ 書類 指図。 電話 ： プロジェクト→プロジェクト設定 指図、 ページ設定 カテゴリー 次のプロパティの設定を構成できます。 論文 マージン ヘッダーとフッター 書類 タイトルページ ヘッダーの編集 \/ フッターを編集する ヘッダーとフッターはテーブルスタイルで構成されています。行と列を構成し、結果のセルにテキストと画像を追加できます。 行スパン 列の数 CODESYS 単一の行にマージする必要があります 列スパン 列の数 CODESYS 単一の行にマージする必要があります で利用可能なプレースホルダーのリストを開きます 文章 分野 ページを印刷するとき、 CODESYS プレースホルダーに現在の値を提供します。 " }, 
{ "title" : "ダイアログ：プロジェクト設定：キュリティ ", 
"url" : "_cds_dlg_project_settings_security.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト設定 \/ ダイアログ：プロジェクト設定：キュリティ ", 
"snippet" : "キュリティ シンボル： 関数 ：ダイアログは、パスワード、ドングル、または証明書によるプロジェクト保護を構成するために使用されます。 電話 ： プロジェクト→プロジェクト設定 指図、 安全 カテゴリー 暗号化パスワードを紛失すると、プロジェクトを開くことができなくなります。また、復元することもできなくなります。 保護なし ：プロジェクトファイルは、不正アクセスやデータ操作から保護されていません。 注：セキュリティ機能を使用することを強くお勧めします。 ： パスワード 、 ドングル 、 と 証明書 オプションは選択できません。 整合性チェック 新しいプロジェクトを作成すると、このオプションはデフ...", 
"body" : "キュリティ シンボル： 関数 ：ダイアログは、パスワード、ドングル、または証明書によるプロジェクト保護を構成するために使用されます。 電話 ： プロジェクト→プロジェクト設定 指図、 安全 カテゴリー 暗号化パスワードを紛失すると、プロジェクトを開くことができなくなります。また、復元することもできなくなります。 保護なし ：プロジェクトファイルは、不正アクセスやデータ操作から保護されていません。 注：セキュリティ機能を使用することを強くお勧めします。 ： パスワード 、 ドングル 、 と 証明書 オプションは選択できません。 整合性チェック 新しいプロジェクトを作成すると、このオプションはデフォルトで有効になります。 ：プロジェクトファイルは独自の形式で保存され、プロジェクトがロードされるたびにその整合性がチェックされます。このファイルは、古いバージョンの開発システムと互換性がない可能性があります。 プロジェクトファイルは暗号化されていないことに注意してください。データをより適切に保護するには、暗号化機能の1つをアクティブにします。 暗号化 ： パスワード 、 ドングル 、 と 証明書 暗号化機能を選択できます。 パスワード 暗号化パスワードの入力、変更、確認 これらの設定でプロジェクトを保存する場合、プロジェクトをライブラリ参照としてロードする場合でも、プロジェクトを再度開くには、後でパスワードを指定する必要があります。 ドングル 要件：接続している CODESYS コンピュータへのセキュリティキー（ドングル）。 追加 ： 登録ドングルを追加 ダイアログが開きます。 登録ドングル 登録ドングルのリストボックス 証明書 証明書は、開いているプロジェクトファイルの内容を暗号化するために使用されます。 要件：プロジェクトを共有するすべてのユーザーの証明書は、ローカルメモリにインストールする必要があります。 ： 証明書の選択 ダイアログが開きます。 登録ドングルを追加 ドングル 接続されているすべてのドングルのリストボックス 更新 CODESYS リストボックスを更新します。 点滅 選択したドングルのLEDが2秒間点滅します（この機能をサポートしている場合）。 ドングルは、次の場合にコンピュータに接続する必要があります CODESYS ライブラリ参照としてロードされている場合でも、プロジェクトをロードします。 詳細については、以下を参照してください。 プロジェクトの保護と保存" }, 
{ "title" : "ダイアログ：プロジェクト設定：静的分析ライト ", 
"url" : "_cds_dlg_project_settings_stat_analysis_light.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト設定 \/ ダイアログ：プロジェクト設定：静的分析ライト ", 
"snippet" : "静的分析ライト シンボル： 関数 ：ダイアログは、ライトバージョンで実行されるチェックをアクティブにします。 CODESYS コードが生成されるたびの静的分析。 電話 ： プロジェクト→プロジェクト設定 指図、 静的分析ライト カテゴリー コードにマークを付けることで、静的コード分析からコード行を除外できます。 {analysis ...} プラグマまたは {attribute 'analysis' := '...'} プラグマ。 詳細については、以下を参照してください。 コードを静的に分析する...", 
"body" : "静的分析ライト シンボル： 関数 ：ダイアログは、ライトバージョンで実行されるチェックをアクティブにします。 CODESYS コードが生成されるたびの静的分析。 電話 ： プロジェクト→プロジェクト設定 指図、 静的分析ライト カテゴリー コードにマークを付けることで、静的コード分析からコード行を除外できます。 {analysis ...} プラグマまたは {attribute 'analysis' := '...'} プラグマ。 詳細については、以下を参照してください。 コードを静的に分析する" }, 
{ "title" : "追加のコンパイルチェック ", 
"url" : "_cds_dlg_project_settings_stat_analysis_light.html#UUID-bce0b3be-97a6-5ed6-5660-1fba15122580_id_e31a3b0a7345218c0a8640e011b5c22_id_2475103c69e2cf17c0a864637d7f918d", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト設定 \/ ダイアログ：プロジェクト設定：静的分析ライト \/ 追加のコンパイルチェック ", 
"snippet" : "SA0033：未使用の変数 宣言されているが、コンパイルされたプログラムコード内で使用されていない変数を検出します GVL変数の場合：プロジェクトに複数のアプリケーションが存在する場合、現在アクティブなアプリケーションの下にあるオブジェクトのみが影響を受けます。アプリケーションが1つしかない場合は、 POUs ビューも影響を受けます。 SA0028：重複するメモリ領域 2つ以上の変数が同じメモリを予約しているコード行を検出します たとえば、これは次の宣言で発生します。 var1 AT %QB21: INT と var2 AT %QD5: DWORD 。この場合、両方の変数はバイト21を使用しま...", 
"body" : "SA0033：未使用の変数 宣言されているが、コンパイルされたプログラムコード内で使用されていない変数を検出します GVL変数の場合：プロジェクトに複数のアプリケーションが存在する場合、現在アクティブなアプリケーションの下にあるオブジェクトのみが影響を受けます。アプリケーションが1つしかない場合は、 POUs ビューも影響を受けます。 SA0028：重複するメモリ領域 2つ以上の変数が同じメモリを予約しているコード行を検出します たとえば、これは次の宣言で発生します。 var1 AT %QB21: INT と var2 AT %QD5: DWORD 。この場合、両方の変数はバイト21を使用します。これは、変数のメモリ範囲が重複していることを意味します。 SA0006：いくつかのタスクからの書き込みアクセス 複数のタスクによって書き込まれる変数を検出します SA0004：出力での複数の書き込みアクセス 複数の場所に書き込まれた出力を検出します 注：出力変数（ VAR_IN_OUT ）のさまざまなブランチに書き込まれます IF と CASE ステートメント。 注：プラグマはこのルールを無効にすることはできません。 SA0027：識別子の複数の使用 プロジェクトのスコープ内の変数またはオブジェクト（POU）の名前\/識別子の複数の使用を検出します 次のケースが検出されます。 列挙定数の名前は、アプリケーション内の別の列挙と同じであるか、含まれているライブラリで使用されています。 変数の名前は、アプリケーション内のオブジェクトの名前または統合ライブラリーの名前と同じです。 変数の名前は、アプリケーションの列挙型の列挙型定数の名前または統合ライブラリーの名前と同じです。 オブジェクトの名前は、アプリケーション内の別のオブジェクトの名前と同じです。 変数の名前はメソッドの名前と同じです。 オブジェクトの名前は、上位オブジェクト（「親オブジェクト」）の名前と同じです。 SA0167：一時的なFunctionBlockインスタンスを報告します このチェックは、一時変数として宣言されている関数ブロックインスタンスを検出します。これは、メソッドまたは関数で宣言されているインスタンスに影響します。 VAR_TEMP 、したがって、各処理サイクルまたはPOU呼び出しごとに再初期化されます。 SA0175：文字列に対する疑わしい操作 デフォルトでは非アクティブ UTF-8エンコーディングが疑われるコードの場所を検出します 次の構成が含まれています。 シングルバイト文字列へのインデックスアクセス 例： str[2] メッセージ： 文字列に対する疑わしい操作：インデックスアクセス '<式>' シングルバイト文字列へのアドレスアクセス 例： ADR(str) メッセージ ：文字列に対する疑わしい操作：インデックスアクセスの可能性 '<式>' 標準ライブラリの文字列関数を呼び出す それ外 CONCAT と LEN メッセージ： 文字列に対する疑わしい操作：インデックスアクセスの可能性 '<式>' 非ASCII文字を含むシングルバイトリテラル 例： str := '99€'; str := 'Ä'; メッセージ： 文字列に対する疑わしい操作：リテラル '<literal>'に非ASCII文字が含まれています チェックの結果によっては、有効にしないことをお勧めします STRINGのUTF8エンコーディング コンパイルオプション。 詳細については、以下を参照してください。 コンパイルオプション例 SA0003：空のステートメント ;\n(* Comment *);\niVar; SA0006：同時アクセス FUNCTION_BLOCK ADD_FB\ng_iTemp1 := g_iTemp1 + INT#1; PROGRAM PLC_PRG \/\/controlled by MainTask\ng_iTemp1 := g_iTemp1 + INT#2;\ng_xTemp2 := g_iTemp1 > INT#10; PROGRAM PLC_PRG_1 \/\/controlled by SubTask\ng_iTemp1 := g_iTemp1 - INT#3;\ng_xTemp2 := g_iTemp1 < INT#-10; SA0004：出力での複数の書き込みアクセス VAR_GLOBAL\n g_xVar AT %QX0.0 : BOOL ;\n g_iTest AT %QW0 : INT ;\nEND_VAR PROGRAM PLC_PRG\nIF iCondition < INT#0 THEN\n g_xVar := TRUE;\n g_iTest := INT#12;\nEND_IF CASE iCondition OF\n INT#1:\n g_xVar := FALSE;\n INT#2:\n g_iTest := INT#11;\n ELSE\n g_xVar := TRUE;\n g_iTest := INT#9;\nEND_CASE SA0006：いくつかのタスクからの書き込みアクセス FUNCTION_BLOCK ADD_FB\ng_iTemp1 := g_iTemp1 + INT#1;\n PROGRAM PLC_PRG \/\/ Controlled by MainTask\ng_iTemp1 := g_iTemp1 + INT#2;\ng_xTemp2 := g_iTemp1 > INT#10; PROGRAM PLC_PRG_1 \/\/Controlled by SubTask\ng_iTemp1 := g_iTemp1 - INT#3;\ng_xTemp2 := g_iTemp1 < INT#-10; SA0027：名前の複数の使用 PROGRAM PLC_PRG\nVAR\n ton : INT; \/\/ error SA0027\nEND_VAR SA0029：宣言とは異なるコードの表記 A PLC_PRG POUと fnc （機能）POUはデバイスツリーに存在します。 PROGRAM PLC_PRG\nVAR\n iVar:INT;\n _123test_var_: INT;\nEND_VAR\n ivar := iVar + 1; \/\/ notation different to that in the declaration part -> SA0029\n_123TEST_var_ := _123test_var_INT; \/\/ notation different to that in the declaration part -> SA0029\nFnc(); \/\/ notation different to that in the devices tree -> SA0029 SA0167：一時的なFunctionBlockインスタンスを報告します PROGRAM PLC_PRG\nVAR\nEND_VAR\nVAR_TEMP\n yafb: AFB;\nEND_VAR\n\n FUNCTION Fun : INT\nVAR_INPUT\nEND_VAR\nVAR\n funafb: AFB;\nEND_VAR METHOD METH: INT\nVAR_INPUT\nEND_VAR\nVAR\n methafb: AFB;\nEND_VAR 詳細については、以下を参照してください。 コードを静的に分析する" }, 
{ "title" : "ダイアログ：プロジェクト設定：視覚化 ", 
"url" : "_cds_dlg_project_settings_visualization.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト設定 \/ ダイアログ：プロジェクト設定：視覚化 ", 
"snippet" : "視覚化 シンボル： 関数 ：ダイアログは、の設定を構成するために使用されます 視覚化 プロジェクト全体のオブジェクト。 電話 ： プロジェクト→プロジェクト設定 指図、 視覚化 カテゴリー 要件 ：プロジェクトは開いています。...", 
"body" : "視覚化 シンボル： 関数 ：ダイアログは、の設定を構成するために使用されます 視覚化 プロジェクト全体のオブジェクト。 電話 ： プロジェクト→プロジェクト設定 指図、 視覚化 カテゴリー 要件 ：プロジェクトは開いています。 " }, 
{ "title" : "タブ：一般 ", 
"url" : "_cds_dlg_project_settings_visualization.html#UUID-a7420fda-c00e-6880-4017-0aae347dbd65_id_ec5a4b10864b2e0c0a8640e008c94e5_id_97bc6eea60007fddc0a8640e010193e0", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト設定 \/ ダイアログ：プロジェクト設定：視覚化 \/ タブ：一般 ", 
"snippet" : "視覚化ディレクトリ テキストリストファイル さまざまな言語のテキストを構成するためにプロジェクトで使用できるテキストリストを含むディレクトリ CODESYS たとえば、テキストリストをインポートまたはエクスポートするためにディレクトリを使用します。 クリックした後 ボタン、 ディレクトリを選択 ファイルシステム内のディレクトリを選択するためのダイアログが開きます。 画像ファイル プロジェクトで利用可能な画像ファイルを含むディレクトリ 複数のフォルダはセミコロンで区切られます。 CODESYS たとえば、画像ファイルをインポートまたはエクスポートするためにディレクトリを使用します。 クリックした...", 
"body" : "視覚化ディレクトリ テキストリストファイル さまざまな言語のテキストを構成するためにプロジェクトで使用できるテキストリストを含むディレクトリ CODESYS たとえば、テキストリストをインポートまたはエクスポートするためにディレクトリを使用します。 クリックした後 ボタン、 ディレクトリを選択 ファイルシステム内のディレクトリを選択するためのダイアログが開きます。 画像ファイル プロジェクトで利用可能な画像ファイルを含むディレクトリ 複数のフォルダはセミコロンで区切られます。 CODESYS たとえば、画像ファイルをインポートまたはエクスポートするためにディレクトリを使用します。 クリックした後 ボタン、 ディレクトリを選択 ファイルシステム内のディレクトリを選択するためのダイアログが開きます。 高度 すべての要素プロパティでプロパティ処理をアクティブ化する ：視覚化要素を構成することもできます IEC変数を選択するプロパティのプロパティ。それで CODESYS ビジュアライゼーションのコンパイル時にプロパティを処理するための追加のコードを作成します。 要件：IECコードに少なくとも1つ含まれている インターフェイスプロパティ オブジェクトタイプ（ 。財産）。 要件： 見える オプションが選択されています。 視覚化POUの暗黙的なチェックをアクティブ化する ：暗黙的なチェックは、視覚化POUに対しても実行されます。その結果、追加のコードが生成され、メモリ使用量が増加します。メモリが制限されている場合は、このオプションを無効にする必要があります。 " }, 
{ "title" : "タブ：シンボルライブラリ ", 
"url" : "_cds_dlg_project_settings_visualization.html#UUID-a7420fda-c00e-6880-4017-0aae347dbd65_id_ec5a4b10864b2e0c0a8640e008c94e5_id_a34bf5cec3c311e388b6f6b960add9a6", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト設定 \/ ダイアログ：プロジェクト設定：視覚化 \/ タブ：シンボルライブラリ ", 
"snippet" : "視覚化シンボルライブラリ シンボルライブラリ インストールされているすべてのシンボルライブラリのリスト（例： VisuSymbols ）。 アクティブ ：プロジェクトでシンボルライブラリが選択され、 CODESYS で利用できるようにします 視覚化ツールボックス 視覚化のビュー。 ：シンボルライブラリはライブラリリポジトリにインストールされていますが、 CODESYS します いいえ で利用できるようにする 視覚化ツールボックス 視覚化のビュー。 詳細については、以下を参照してください。 CODESYS Visualization ヘルプ...", 
"body" : "視覚化シンボルライブラリ シンボルライブラリ インストールされているすべてのシンボルライブラリのリスト（例： VisuSymbols ）。 アクティブ ：プロジェクトでシンボルライブラリが選択され、 CODESYS で利用できるようにします 視覚化ツールボックス 視覚化のビュー。 ：シンボルライブラリはライブラリリポジトリにインストールされていますが、 CODESYS します いいえ で利用できるようにする 視覚化ツールボックス 視覚化のビュー。 詳細については、以下を参照してください。 CODESYS Visualization ヘルプ " }, 
{ "title" : "ダイアログ：プロジェクト設定：視覚化プロファイル ", 
"url" : "_cds_dlg_project_settings_visualzation_profile.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト設定 \/ ダイアログ：プロジェクト設定：視覚化プロファイル ", 
"snippet" : "視覚化プロファイル シンボル： 関数 ：ダイアログでは、視覚化プロファイルを設定できます。 電話 ： プロジェクト→プロジェクト設定 指図、 視覚化プロファイル カテゴリー 要件 ：プロジェクトは開いています。 視覚化プロファイル 特定のプロファイル プロフィール CODESYS プロジェクトで使用し、プロジェクトで使用可能な視覚化要素を決定します リストボックスには、以前にインストールされたすべてのプロファイルが含まれています。...", 
"body" : "視覚化プロファイル シンボル： 関数 ：ダイアログでは、視覚化プロファイルを設定できます。 電話 ： プロジェクト→プロジェクト設定 指図、 視覚化プロファイル カテゴリー 要件 ：プロジェクトは開いています。 視覚化プロファイル 特定のプロファイル プロフィール CODESYS プロジェクトで使用し、プロジェクトで使用可能な視覚化要素を決定します リストボックスには、以前にインストールされたすべてのプロファイルが含まれています。 " }, 
{ "title" : "ダイアログ：プロジェクト環境 ", 
"url" : "_cds_f_dlg_project_environment.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト環境 ", 
"snippet" : "プロジェクト環境 関数 ：ダイアログは、プロジェクトに統合されているソフトウェアとファイルが最新であるかどうかを確認するために使用されます。例えば、 CODESYS 選択したコンパイラをチェックし、新しいバージョンが利用可能かどうかを判断します。その場合は、関連するコンポーネントを更新できます。 電話 ： 計画 メニュー...", 
"body" : "プロジェクト環境 関数 ：ダイアログは、プロジェクトに統合されているソフトウェアとファイルが最新であるかどうかを確認するために使用されます。例えば、 CODESYS 選択したコンパイラをチェックし、新しいバージョンが利用可能かどうかを判断します。その場合は、関連するコンポーネントを更新できます。 電話 ： 計画 メニュー " }, 
{ "title" : "ダイアログ：プロジェクト環境：ライブラリバージョン ", 
"url" : "_cds_dlg_project_environment_library_version.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト環境 \/ ダイアログ：プロジェクト環境：ライブラリバージョン ", 
"snippet" : "ライブラリバージョン 関数 ：ダイアログには、新しいバージョンが利用可能な、開いているプロジェクトのライブラリが表示されます。 電話 ： プロジェクト→プロジェクト環境 指図、 ライブラリバージョン タブ 古いライブラリを含むプロジェクトを開くと、このダイアログが自動的に開きます。 リストには、古いライブラリの名前とそのバージョン、使用可能なバージョン、および計画されているアクションが表示されます。 アクション フィールド内をダブルクリックして、目的のアクションを選択します。 このプロジェクトをロードするときに更新を確認してください ：プロジェクトが開かれるたびにチェックが行われます。 ：チェ...", 
"body" : "ライブラリバージョン 関数 ：ダイアログには、新しいバージョンが利用可能な、開いているプロジェクトのライブラリが表示されます。 電話 ： プロジェクト→プロジェクト環境 指図、 ライブラリバージョン タブ 古いライブラリを含むプロジェクトを開くと、このダイアログが自動的に開きます。 リストには、古いライブラリの名前とそのバージョン、使用可能なバージョン、および計画されているアクションが表示されます。 アクション フィールド内をダブルクリックして、目的のアクションを選択します。 このプロジェクトをロードするときに更新を確認してください ：プロジェクトが開かれるたびにチェックが行われます。 ：チェックは1回だけ行われます。 すべてを最新に設定 CODESYS ライブラリの最新バージョンを使用します。 わかった CODESYS 選択したアクションを実行します。 " }, 
{ "title" : "ダイアログ：プロジェクト環境：コンパイラバージョン ", 
"url" : "_cds_dlg_project_environment_compiler_version.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト環境 \/ ダイアログ：プロジェクト環境：コンパイラバージョン ", 
"snippet" : "コンパイラバージョン 関数 ：ダイアログには、プロジェクトの現在のコンパイラバージョンが表示され、プロジェクトを更新するオプションが提供されます。 電話 ： プロジェクト→プロジェクト環境 指図、 コンパイラバージョン タブ プロジェクト内の現在のコンパイラバージョン 開いているプロジェクトの設定済みコンパイラバージョンを表示します 推奨される最新バージョン 最新バージョンを表示します アクション 更新しないでください ：プロジェクトのコンパイラバージョンは変更されません。 xxxxに更新 ：選択したコンパイラバージョンがプロジェクトに設定されます。 このプロジェクトをロードするときに更新を確...", 
"body" : "コンパイラバージョン 関数 ：ダイアログには、プロジェクトの現在のコンパイラバージョンが表示され、プロジェクトを更新するオプションが提供されます。 電話 ： プロジェクト→プロジェクト環境 指図、 コンパイラバージョン タブ プロジェクト内の現在のコンパイラバージョン 開いているプロジェクトの設定済みコンパイラバージョンを表示します 推奨される最新バージョン 最新バージョンを表示します アクション 更新しないでください ：プロジェクトのコンパイラバージョンは変更されません。 xxxxに更新 ：選択したコンパイラバージョンがプロジェクトに設定されます。 このプロジェクトをロードするときに更新を確認してください ： CODESYS プロジェクトを開くたびに新しいバージョンをチェックします。その場合、対応する更新ダイアログが自動的に開きます。 ：バージョンはチェックされていません。更新ダイアログは自動的には開きません。 すべてを最新に設定 コンパイラのバージョンは最新バージョンに設定されています。 " }, 
{ "title" : "ダイアログ：プロジェクト環境：デバイスバージョン ", 
"url" : "_cds_dlg_project_environment_device_versions.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト環境 \/ ダイアログ：プロジェクト環境：デバイスバージョン ", 
"snippet" : "デバイスバージョン 関数 ：ダイアログには、新しいバージョンが利用可能な、開いているプロジェクトのデバイスが表示されます。 電話 ： プロジェクト→プロジェクト環境 指図、 デバイスバージョン タブ 古いデバイスを含むプロジェクトを開くと、このダイアログが自動的に開きます。 古いデバイスの名前とそのバージョン、および使用可能なバージョンと計画されているアクション アクション フィールド内をダブルクリックして、目的のアクションを選択します。 このプロジェクトをロードするときに更新を確認してください ：プロジェクトが開かれるたびにチェックが行われます。 ：チェックは1回だけ行われます。 すべてを最...", 
"body" : "デバイスバージョン 関数 ：ダイアログには、新しいバージョンが利用可能な、開いているプロジェクトのデバイスが表示されます。 電話 ： プロジェクト→プロジェクト環境 指図、 デバイスバージョン タブ 古いデバイスを含むプロジェクトを開くと、このダイアログが自動的に開きます。 古いデバイスの名前とそのバージョン、および使用可能なバージョンと計画されているアクション アクション フィールド内をダブルクリックして、目的のアクションを選択します。 このプロジェクトをロードするときに更新を確認してください ：プロジェクトが開かれるたびにチェックが行われます。 ：チェックは1回だけ行われます。 すべてを最新に設定 CODESYS ライブラリの最新バージョンを使用します。 わかった CODESYS 選択したアクションを実行します。 " }, 
{ "title" : "ダイアログ：プロジェクト環境：視覚化プロファイル ", 
"url" : "_cds_dlg_project_environment_visualization_profile.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト環境 \/ ダイアログ：プロジェクト環境：視覚化プロファイル ", 
"snippet" : "視覚化プロファイル 関数 ：ダイアログには、プロジェクトの現在の視覚化プロファイルが表示されます。プロファイルはここで更新できます。 電話 ： プロジェクト→プロジェクト環境 指図、 視覚化プロファイル タブ プロジェクトの現在の視覚化プロファイル 開いているプロジェクトの設定された視覚化プロファイル 推奨される最新のプロファイル 最新バージョン アクション 更新しないでください ：プロジェクトの視覚化プロファイルは変更されません。 xxxxに更新 ： CODESYS プロジェクトを選択した視覚化プロファイルに更新します。 このプロジェクトをロードするときに更新を確認してください ： CODE...", 
"body" : "視覚化プロファイル 関数 ：ダイアログには、プロジェクトの現在の視覚化プロファイルが表示されます。プロファイルはここで更新できます。 電話 ： プロジェクト→プロジェクト環境 指図、 視覚化プロファイル タブ プロジェクトの現在の視覚化プロファイル 開いているプロジェクトの設定された視覚化プロファイル 推奨される最新のプロファイル 最新バージョン アクション 更新しないでください ：プロジェクトの視覚化プロファイルは変更されません。 xxxxに更新 ： CODESYS プロジェクトを選択した視覚化プロファイルに更新します。 このプロジェクトをロードするときに更新を確認してください ： CODESYS プロジェクトが開かれるたびに、新しいプロファイルをチェックします。その場合、対応する更新ダイアログが自動的に開きます。 ：プロジェクトを開いたときにプロファイルはチェックされません。更新ダイアログは自動的には開きません。 すべてを最新に設定 CODESYS プロファイルを更新します。 詳細については、以下を参照してください。 CODESYS Visualization ヘルプ " }, 
{ "title" : "ダイアログ：プロジェクト環境：視覚化スタイル ", 
"url" : "_cds_dlg_project_environment_visualization_style.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト環境 \/ ダイアログ：プロジェクト環境：視覚化スタイル ", 
"snippet" : "視覚化スタイル 関数 ：ダイアログには、プロジェクトの現在の視覚化スタイルが表示され、プロジェクトを更新するオプションが提供されます。 電話 ： プロジェクト→プロジェクト環境 指図、 視覚化スタイル タブ 現在使用されている次の視覚化スタイルについては、新しいバージョンが利用可能です 視覚化スタイル 開いているプロジェクトで設定された視覚化スタイルのバージョン 電流 視覚化スタイルの現在のバージョン 例： 3.5.6.0 おすすめされた 視覚化スタイルの推奨バージョン 例： 3.5.7.0 アクション 更新しないでください ：プロジェクトの視覚化スタイルは変更されません。 xxxxに更新 ：...", 
"body" : "視覚化スタイル 関数 ：ダイアログには、プロジェクトの現在の視覚化スタイルが表示され、プロジェクトを更新するオプションが提供されます。 電話 ： プロジェクト→プロジェクト環境 指図、 視覚化スタイル タブ 現在使用されている次の視覚化スタイルについては、新しいバージョンが利用可能です 視覚化スタイル 開いているプロジェクトで設定された視覚化スタイルのバージョン 電流 視覚化スタイルの現在のバージョン 例： 3.5.6.0 おすすめされた 視覚化スタイルの推奨バージョン 例： 3.5.7.0 アクション 更新しないでください ：プロジェクトの視覚化スタイルは変更されません。 xxxxに更新 ： CODESYS プロジェクトを選択した視覚化スタイルのバージョンに更新します。 このプロジェクトをロードするときに更新を確認してください ： CODESYS プロジェクトを開くたびに新しいバージョンをチェックします。その場合、対応する更新ダイアログが自動的に開きます。 ：バージョンはチェックされていません。 更新ダイアログは自動的には開きません。 すべてを最新に設定 CODESYS バージョンを更新します。 詳細については、以下を参照してください。 視覚化スタイルの使用 " }, 
{ "title" : "ダイアログ：プロジェクト：環境–視覚化シンボル ", 
"url" : "_cds_dlg_project_environment_visualization_symbols.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：プロジェクト環境 \/ ダイアログ：プロジェクト：環境–視覚化シンボル ", 
"snippet" : "視覚化シンボル 関数 ：ダイアログには、インストールされているシンボルライブラリが一覧表示され、プロジェクトにシンボルライブラリを割り当てることができます。 電話 ： プロジェクト→プロジェクト環境 指図、 視覚化シンボル タブ 要件 ：開いているプロジェクトには視覚化が含まれており、コンパイラバージョンで保存されています < 3.5.7.0 。 CODESYS コンパイラバージョンのシンボルライブラリを認識します 3.5.7.0 以上。 シンボルライブラリ インストールされているすべてのシンボルライブラリのリスト アクティブ ：プロジェクトにシンボルライブラリが選択されています。 CODES...", 
"body" : "視覚化シンボル 関数 ：ダイアログには、インストールされているシンボルライブラリが一覧表示され、プロジェクトにシンボルライブラリを割り当てることができます。 電話 ： プロジェクト→プロジェクト環境 指図、 視覚化シンボル タブ 要件 ：開いているプロジェクトには視覚化が含まれており、コンパイラバージョンで保存されています < 3.5.7.0 。 CODESYS コンパイラバージョンのシンボルライブラリを認識します 3.5.7.0 以上。 シンボルライブラリ インストールされているすべてのシンボルライブラリのリスト アクティブ ：プロジェクトにシンボルライブラリが選択されています。 CODESYS でそのシンボルを提供します 視覚化ツールボックス 見る。 ：シンボルライブラリは、以前はライブラリリポジトリにのみインストールされていました。 詳細については、以下を参照してください。 CODESYS Visualization 、「視覚化でのシンボルライブラリの使用」の章 " }, 
{ "title" : "ダイアログ：オプション ", 
"url" : "_cds_f_dlg_options.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション ", 
"snippet" : "オプション 関数 ：ダイアログは、を選択するために使用されます CODESYS ユーザーインターフェイスの動作と外観を構成するオプション。 CODESYS 現在の設定をデフォルト設定としてローカルシステムに保存します。 電話 ： ツール→オプション 指図...", 
"body" : "オプション 関数 ：ダイアログは、を選択するために使用されます CODESYS ユーザーインターフェイスの動作と外観を構成するオプション。 CODESYS 現在の設定をデフォルト設定としてローカルシステムに保存します。 電話 ： ツール→オプション 指図 " }, 
{ "title" : "ダイアログ：オプション：ライブラリ ", 
"url" : "_cds_dlg_options_lib.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：ライブラリ ", 
"snippet" : "ライブラリ シンボル： 関数 ：ダイアログは、ライブラリ参照のマッピングを管理するのに役立ちます。 CODESYS 古いプロジェクトの変換中に使用します。特定のライブラリのマッピングをまだ保存していない場合は、このライブラリが統合されている古いプロジェクトを開くたびに、マッピングを再定義する必要があります。 電話 ： ツール→オプション 指図、 ライブラリ カテゴリー マッピングは、プロジェクトを現在の形式に変換した後のライブラリ参照がどのようになるかを定義します。 3つの可能性があります： 参照を保持します。この意味は CODESYS また、ライブラリを現在の形式（* .library）に変...", 
"body" : "ライブラリ シンボル： 関数 ：ダイアログは、ライブラリ参照のマッピングを管理するのに役立ちます。 CODESYS 古いプロジェクトの変換中に使用します。特定のライブラリのマッピングをまだ保存していない場合は、このライブラリが統合されている古いプロジェクトを開くたびに、マッピングを再定義する必要があります。 電話 ： ツール→オプション 指図、 ライブラリ カテゴリー マッピングは、プロジェクトを現在の形式に変換した後のライブラリ参照がどのようになるかを定義します。 3つの可能性があります： 参照を保持します。この意味は CODESYS また、ライブラリを現在の形式（* .library）に変換し、ローカルライブラリリポジトリにインストールします。 ある参照を別の参照に置き換えます。これは、インストールされたライブラリの1つが統合ライブラリを置き換えることを意味します。 参照を削除します。これは、変換されたプロジェクトがライブラリを統合しなくなったことを意味します。 CODESYS リストされているすべてのマッピングを、次に変換されるときに古いプロジェクトのライブラリ参照に適用します。したがって、同じライブラリが変換されるプロジェクトに再度統合される場合は、マッピング定義を繰り返す必要があります。 最後の行に新しいマッピングを入力できます。 ソースライブラリ 変換前にプロジェクトに統合されたライブラリのパス エントリをダブルクリックすると、フィールドが編集可能になり、入力支援のボタンが表示されます。 ターゲットライブラリ 変換後にプロジェクトに統合されるライブラリの名前と場所 エントリをダブルクリックすると、 ターゲットライブラリを設定する ダイアログ。 ダイアログ： ターゲットライブラリを設定する スキャン The ライブラリを追加 ダイアログが開きます。そこで、ライブラリリポジトリからライブラリを選択できます。ダイアログは、ライブラリリポジトリのダイアログに対応しています。 無視。このライブラリ参照はインポートされません。 いつ CODESYS プロジェクトを変換し、 CODESYS プロジェクトから既存のソースライブラリを常に削除します。 " }, 
{ "title" : "ダイアログ：オプション：ライブラリのダウンロード ", 
"url" : "_cds_dlg_options_lib_download.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：ライブラリのダウンロード ", 
"snippet" : "ライブラリのダウンロード シンボル： 関数 ：ダイアログは、ダウンロードサーバーを構成するために使用されます。 電話 ： ツール→オプション 指図、 ライブラリのダウンロード カテゴリー クリックすると 行方不明のライブラリをダウンロードする ライブラリマネージャーで、 CODESYS これらのダウンロードサーバーを参照して、ライブラリマネージャーで欠落しているとマークされているライブラリを探し、プロキシサーバーに設定された資格情報を使用します。 ダウンロードサーバー ライブラリファイルを含むサーバーのURL ダブルクリック （ここに新しいダウンロードサーバーを入力してください） サーバーのU...", 
"body" : "ライブラリのダウンロード シンボル： 関数 ：ダイアログは、ダウンロードサーバーを構成するために使用されます。 電話 ： ツール→オプション 指図、 ライブラリのダウンロード カテゴリー クリックすると 行方不明のライブラリをダウンロードする ライブラリマネージャーで、 CODESYS これらのダウンロードサーバーを参照して、ライブラリマネージャーで欠落しているとマークされているライブラリを探し、プロキシサーバーに設定された資格情報を使用します。 ダウンロードサーバー ライブラリファイルを含むサーバーのURL ダブルクリック （ここに新しいダウンロードサーバーを入力してください） サーバーのURLアドレスを指定できる入力フィールドが開きます。 詳細については、以下を参照してください。 ライブラリマネージャー と プロキシ設定" }, 
{ "title" : "ダイアログ：オプション： CoDeSys V2.3 コンバータ ", 
"url" : "_cds_dlg_options_v23_convert.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション： CoDeSys V2.3 コンバータ ", 
"snippet" : "CoDeSys V2.3 コンバータ シンボル： 関数 ：ダイアログは、変換時にマッピングを定義するために使用されます CoDeSys V2.3 事業。 電話 ： ツール→オプション 指図、 CoDeSys V2.3 コンバータ カテゴリー A CoDeSys V2.3 プロジェクトはに変換することができます CODESYS V3 プロジェクトの場合のみ CODESYS V2.3 Converter パッケージはにインストールされています CODESYS V3 。パッケージはで利用可能です CODESYS Store International 。 タブ： デバイス 変換用のデバイスマッピング...", 
"body" : "CoDeSys V2.3 コンバータ シンボル： 関数 ：ダイアログは、変換時にマッピングを定義するために使用されます CoDeSys V2.3 事業。 電話 ： ツール→オプション 指図、 CoDeSys V2.3 コンバータ カテゴリー A CoDeSys V2.3 プロジェクトはに変換することができます CODESYS V3 プロジェクトの場合のみ CODESYS V2.3 Converter パッケージはにインストールされています CODESYS V3 。パッケージはで利用可能です CODESYS Store International 。 タブ： デバイス 変換用のデバイスマッピングのリストと定義 このリストのすべてのデバイスマッピングは、次回も有効になります。 CoDeSys V2.3 プロジェクトが変換されます。これにより、同じデバイスが複数のプロジェクトで使用されている場合に、イメージ定義を再度作成する必要がなくなります。 ソースデバイス エントリまたは空のフィールドをダブルクリックして、 ソースデバイスを選択 ダイアログ。 CODESYS コンバータが処理できるすべてのデバイスを一覧表示します。 ターゲットデバイス エントリまたは空のフィールドをダブルクリックして、 ターゲットデバイスを選択 ダイアログ。 以下のインストール済みデバイスのリストからターゲットデバイスを選択します 。クリック わかった 選択を確認します。 なし ：ソースデバイスは、新しいプロジェクトでは使用できなくなります。これは、タスク構成などのアプリケーション固有のオブジェクトがインポートされないことも意味します。 タブ： 視覚化 の処理を定義します CODESYS TargetVisu と CODESYS WebVisu バリアントを表示する CoDeSys V2.3 プロジェクトが開かれます Targetvisualizationsのインポート Webビジュアライゼーションのインポート リストボックス 古い動作を模倣してみてください ：現在使用されているデバイスがオプションをサポートしている場合、このオプションを使用できます。このオプションの効果は、ターゲットの視覚化またはWebの視覚化の新しい設定が、古いプロジェクトの設定に可能な限り一致することです。 ユーザーに一度尋ねる ： CODESYS 「古い」視覚化プロジェクトを初めてインポートするときにのみ、設定を定義するようにユーザーに求めます。その後、 CODESYS 他のすべてのビジュアライゼーションのインポートに設定を自動的に適用します。 ユーザーに尋ねる ： CODESYS 「古い」視覚化プロジェクトを開くたびに、設定を定義するようにユーザーに求めます。 デバイスの説明から設定 ： CODESYS インストールされているターゲットデバイスのデバイスの説明のエントリに従って設定を構成します。 古い動作を模倣してみてください ：このオプションは、現在使用されているデバイスがオプションをサポートしている場合にのみ使用できます。このオプションの効果は、ターゲットビジュアライゼーションまたはWebビジュアライゼーションの新しい表示バリアント設定が古いプロジェクトの設定に可能な限り一致することです。 CODESYS TargetVisu へのアクセスをサポートしていません VAR_IN_OUT コンパイラがサポートしていないため、変数。この動作は、 CoDeSys V2.3 ターゲットの視覚化。 詳細については、以下を参照してください。 開く " }, 
{ "title" : "ダイアログ: オプション: デバッグ ", 
"url" : "_cds_dlg_options_debugging.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ: オプション: デバッグ ", 
"snippet" : "デバッグ シンボル： 関数 : このダイアログのオプションは、リセット後もブレークポイントが有効になっているかどうかを制御します。 電話 : ツール → オプション 指示、 デバッグ カテゴリー リセット後にブレークポイントを復元する ： 後に リセットコールド または リセットウォーム コマンドでは、設定されたすべてのブレークポイントは有効なままです。 ： 後に リセットコールド または リセットウォーム コマンドを実行すると、すべてのブレークポイントが無効になります。...", 
"body" : "デバッグ シンボル： 関数 : このダイアログのオプションは、リセット後もブレークポイントが有効になっているかどうかを制御します。 電話 : ツール → オプション 指示、 デバッグ カテゴリー リセット後にブレークポイントを復元する ： 後に リセットコールド または リセットウォーム コマンドでは、設定されたすべてのブレークポイントは有効なままです。 ： 後に リセットコールド または リセットウォーム コマンドを実行すると、すべてのブレークポイントが無効になります。 " }, 
{ "title" : "ダイアログ：オプション：宣言エディタ ", 
"url" : "_cds_dlg_options_declaration_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：宣言エディタ ", 
"snippet" : "宣言エディタ シンボル： 関数 ：ダイアログは、宣言エディタの表示設定を構成するために使用されます。 電話 ： ツール→オプション 指図、 宣言エディタ カテゴリー テキストのみ 宣言エディタのテキストビュー 表形式のみ 宣言エディタの表形式のビュー テキストと表形式の間で切り替え可能 宣言エディタには、テキストビューと表形式ビューを切り替えるための2つのボタンがあります。 ：テキストビュー ：表形式 次のオプションは、プログラミングオブジェクトを開いたときに表示されるデフォルトのビューを定義します。 常にテキスト 常に表形式 最近の設定を覚えておいてください（オブジェクトごと） 最近の設定を...", 
"body" : "宣言エディタ シンボル： 関数 ：ダイアログは、宣言エディタの表示設定を構成するために使用されます。 電話 ： ツール→オプション 指図、 宣言エディタ カテゴリー テキストのみ 宣言エディタのテキストビュー 表形式のみ 宣言エディタの表形式のビュー テキストと表形式の間で切り替え可能 宣言エディタには、テキストビューと表形式ビューを切り替えるための2つのボタンがあります。 ：テキストビュー ：表形式 次のオプションは、プログラミングオブジェクトを開いたときに表示されるデフォルトのビューを定義します。 常にテキスト 常に表形式 最近の設定を覚えておいてください（オブジェクトごと） 最近の設定を（グローバルに）覚えておいてください " }, 
{ "title" : "ダイアログ：オプション：デバイスの説明ダウンロード ", 
"url" : "_cds_dlg_options_dev_descr_download.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：デバイスの説明ダウンロード ", 
"snippet" : "デバイスの説明ダウンロード シンボル： 関数 ：ダイアログは、デバイスの説明用にダウンロードサーバーのアドレスを構成するために使用されます。 電話 ： ツール→オプション 指図、 デバイスの説明ダウンロード カテゴリー ダウンロードサーバー デバイスの説明を含むダウンロードサーバーのリスト デフォルトでは、 'https:\/\/store.codesys.com\/CODESYSDevs' ダウンロードサーバーとして入力されます。 クリックすると 不足しているデバイスの説明をダウンロードする のボタン デバイスリポジトリ ダイアログ、 CODESYS ここで指定されたサーバーとプロキシサーバー用に...", 
"body" : "デバイスの説明ダウンロード シンボル： 関数 ：ダイアログは、デバイスの説明用にダウンロードサーバーのアドレスを構成するために使用されます。 電話 ： ツール→オプション 指図、 デバイスの説明ダウンロード カテゴリー ダウンロードサーバー デバイスの説明を含むダウンロードサーバーのリスト デフォルトでは、 'https:\/\/store.codesys.com\/CODESYSDevs' ダウンロードサーバーとして入力されます。 クリックすると 不足しているデバイスの説明をダウンロードする のボタン デバイスリポジトリ ダイアログ、 CODESYS ここで指定されたサーバーとプロキシサーバー用に構成された資格情報を使用します。 ダブルクリック （ここに新しいダウンロードサーバーを入力してください） サーバーのURLアドレスを指定できる入力フィールドが開きます。 デル 選択したダウンロードサーバーを削除します 詳細については、以下を参照してください。 デバイスの管理 と プロキシ設定" }, 
{ "title" : "ダイアログ：オプション：デバイスエディタ ", 
"url" : "_cds_dlg_options_device_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：デバイスエディタ ", 
"snippet" : "デバイスエディタ シンボル： 関数 ：ダイアログには、デバイスエディタを表示するための設定が含まれています。 電話 ： ツール→オプション 指図、 デバイスエディタ カテゴリー...", 
"body" : "デバイスエディタ シンボル： 関数 ：ダイアログには、デバイスエディタを表示するための設定が含まれています。 電話 ： ツール→オプション 指図、 デバイスエディタ カテゴリー " }, 
{ "title" : "タブ：表示 ", 
"url" : "_cds_dlg_options_device_editor.html#UUID-e361ad24-5293-3d45-6457-8b1691928017_id_a7d16484a2e9f34c0a8640e0124d84a_id_303e1b31bf1d11e3b5929fc0353aead8", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：デバイスエディタ \/ タブ：表示 ", 
"snippet" : "一般的なデバイス構成ビューを表示する ：デバイスパラメータのリストを含むタブは、パラメータ設定可能なデバイスのデバイスエディタで使用できます。 IECアドレスの相互参照を作成します（クリーンが必要です） ：マップされていないI \/ Oの相互参照を作成します。 コミュニケーションページ クラシックモード ： コミュニケーション デバイスエディタのタブは分割ウィンドウとして表示され、左側にはツリー構造で現在構成されているゲートウェイチャネルが表示され、右側には関連するデータと情報が表示されます。 シンプルモード ： コミュニケーション ヘルプの対応する章で説明されているように、タブが表示されます。...", 
"body" : "一般的なデバイス構成ビューを表示する ：デバイスパラメータのリストを含むタブは、パラメータ設定可能なデバイスのデバイスエディタで使用できます。 IECアドレスの相互参照を作成します（クリーンが必要です） ：マップされていないI \/ Oの相互参照を作成します。 コミュニケーションページ クラシックモード ： コミュニケーション デバイスエディタのタブは分割ウィンドウとして表示され、左側にはツリー構造で現在構成されているゲートウェイチャネルが表示され、右側には関連するデータと情報が表示されます。 シンプルモード ： コミュニケーション ヘルプの対応する章で説明されているように、タブが表示されます。 カスタム拡張機能を使用して、追加のモードを使用できる場合もあります。 PLCのエディタでアプリケーションダウンロード用の暗黙的なファイルを表示する ： 同期されたファイル のタブは、デバイスエディタで使用できます。同期ファイルは、アプリケーションのダウンロード時にPLCにダウンロードされます。これらは、アプリケーションに追加された外部ファイル、またはソースコードアーカイブなどの暗黙的なファイルである可能性があります。 アクセス権ページを表示する ： アクセス権 タブはデバイスエディタで利用できます。 注：デバイスによっては、デバイスの説明によってこの設定が上書きされる場合があります。 " }, 
{ "title" : "ダイアログ：オプション：ヘルプ ", 
"url" : "_cds_dlg_options_help.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：ヘルプ ", 
"snippet" : "ヘルプ シンボル： 関数 ：ダイアログは、 CODESYS オンラインヘルプまたは CODESYS ヘルプが呼び出されると、オフラインヘルプが開きます。 電話 ： ツール→オプション 指図、 ヘルプ カテゴリー オンラインヘルプの代わりにオフラインヘルプを使用する : ザ・ CODESYS オフラインヘルプは、次の場合に開きます。 CODESYS ヘルプが呼び出されます。 : ザ・ CODESYS オンラインヘルプは、次の場合に開きます。 CODESYS ヘルプが呼び出されます。...", 
"body" : "ヘルプ シンボル： 関数 ：ダイアログは、 CODESYS オンラインヘルプまたは CODESYS ヘルプが呼び出されると、オフラインヘルプが開きます。 電話 ： ツール→オプション 指図、 ヘルプ カテゴリー オンラインヘルプの代わりにオフラインヘルプを使用する : ザ・ CODESYS オフラインヘルプは、次の場合に開きます。 CODESYS ヘルプが呼び出されます。 : ザ・ CODESYS オンラインヘルプは、次の場合に開きます。 CODESYS ヘルプが呼び出されます。 " }, 
{ "title" : "ダイアログ：オプション: SmartCoding ", 
"url" : "_cds_dlg_options_smart_code.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション: SmartCoding ", 
"snippet" : "SmartCoding シンボル： 関数 ：ダイアログは、コーディングを容易にする設定を構成するために使用されます。 電話 ： ツール→オプション 指図、 SmartCoding カテゴリー 不明な変数を自動的に宣言する（AutoDeclare） ： 変数を宣言する 宣言されていない識別子を実装言語エディタに入力し、入力行から離れてクリックすると、ダイアログが開きます。 AutoDeclare関数をSTエディターでも使用できるようにするには、 STエディターを有効にする オプションも選択する必要があります。 STエディターを有効にする 要件： 未知の変数を自動的に宣言する（AutoDeclar...", 
"body" : "SmartCoding シンボル： 関数 ：ダイアログは、コーディングを容易にする設定を構成するために使用されます。 電話 ： ツール→オプション 指図、 SmartCoding カテゴリー 不明な変数を自動的に宣言する（AutoDeclare） ： 変数を宣言する 宣言されていない識別子を実装言語エディタに入力し、入力行から離れてクリックすると、ダイアログが開きます。 AutoDeclare関数をSTエディターでも使用できるようにするには、 STエディターを有効にする オプションも選択する必要があります。 STエディターを有効にする 要件： 未知の変数を自動的に宣言する（AutoDeclare） オプションが選択されています。 ：AutoDeclare関数はSTエディターでも使用できます。 ：AutoDeclare関数はSTエディターでは使用できません。 入力アシスタントにすべてのインスタンス変数を表示する ： コンポーネントを一覧表示 functionでは、関数ブロックインスタンスのローカル変数を選択することもできます。 ： コンポーネントを一覧表示 関数を使用すると、関数ブロックインスタンスの入力変数と出力変数のみを選択できます。 入力アシスタントでシステムライブラリのシンボルを表示する システムライブラリはライブラリマネージャに自動的に挿入され、薄い灰色で表示されます。 ：入力アシスタントは、グローバル変数、データ型、関数ブロックなどのシンボルを提供します。 ：システムライブラリのシンボルは、入力アシスタントでは使用できません。 ドット（。）を入力した後、コンポーネントを一覧表示します ：有効にします コンポーネントを一覧表示 関数 ドットを入力すると（ . ）場所で CODESYS 識別子を期待すると、リストボックスが開き、可能なコードが提供されます。 入力時にすぐにコンポーネントを一覧表示 要件： ドット（。）を入力した後、コンポーネントを一覧表示します オプションが選択されています。 ：コードを入力すると、リストボックスが開き、可能な識別子と演算子が表示されます。 名前空間で挿入 ： CODESYS 識別子の前に名前空間を追加します。 キーワードを自動的に大文字に変換する（オートフォーマット） ： CODESYS すべてのキーワードが自動的に大文字で表示されます。 相互参照ビューで選択を自動的に一覧表示します ：相互参照リストには、現在選択されている変数、POU、およびDUTの参照、またはカーソルが置かれている場所の参照が自動的に表示されます。 エディターでエラーに下線を付ける ：不正または不明なプログラムコードに下線が引かれています。 このオプションは、プリコンパイル機能を有効または無効にするために使用されます。 プリコンパイルフェーズではコードが生成されないため、すべてのエラーが認識されるわけではないことに注意してください。 認識されないエラーは特に、データを割り当てるとき、たとえばデータに使用可能なメモリが不足したときに発生するエラーです。 さらに、プリコンパイルフェーズでは、コード生成時には関係のないエラーも発生する可能性があります。 報告されるがコード生成には関係ないエラーの一例として、どこにも使われていない関数ブロックで報告される問題があります。ある関数ブロックの種類に該当するインスタンスがない場合、コンパイラはその関数ブロックには関心を持ちませんが、エディターではエラーには引き続き下線が引かれます ハイライト記号 ：カーソルが置かれているシンボルのすべての出現は、エディター内でカラーで強調表示されます。その結果、エディター内の相互参照がすばやく検出されます。 最大並列度 プリコンパイル処理に使用できる並列スレッド数のリストボックス CODESYS CPUコアの数から表示されているスレッド数を検出します。このデフォルトの番号は、例外的な場合にのみ変更する必要があります。 " }, 
{ "title" : "ダイアログ：オプション：国際設定 ", 
"url" : "_cds_dlg_options_int_set.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：国際設定 ", 
"snippet" : "国際設定 シンボル： 関数 ：ダイアログは、ユーザーインターフェイスとヘルプで言語を構成するために使用されます。 電話 ： ツール→オプション 指図、 国際設定 カテゴリー...", 
"body" : "国際設定 シンボル： 関数 ：ダイアログは、ユーザーインターフェイスとヘルプで言語を構成するために使用されます。 電話 ： ツール→オプション 指図、 国際設定 カテゴリー " }, 
{ "title" : "ダイアログ：オプション：ロードして保存 ", 
"url" : "_cds_dlg_options_load_save.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：ロードして保存 ", 
"snippet" : "ロードして保存 シンボル： 関数 ：ダイアログには、の動作の設定が含まれています CODESYS プロジェクトがロードまたは保存されたとき。 電話 ： ツール→オプション 指図、 ロードして保存 カテゴリー バックアップファイルを作成する ：プロジェクトが保存されるたびに、 CODESYS 保存します <project name>.backup に加えてファイル <project name>.project ファイル。バックアップファイルの名前を変更して、プログラミングシステムで開くことができます。 …分ごとに自動的に保存 ： CODESYS 指定された時間間隔でプロジェクトを自動的に保存しま...", 
"body" : "ロードして保存 シンボル： 関数 ：ダイアログには、の動作の設定が含まれています CODESYS プロジェクトがロードまたは保存されたとき。 電話 ： ツール→オプション 指図、 ロードして保存 カテゴリー バックアップファイルを作成する ：プロジェクトが保存されるたびに、 CODESYS 保存します <project name>.backup に加えてファイル <project name>.project ファイル。バックアップファイルの名前を変更して、プログラミングシステムで開くことができます。 …分ごとに自動的に保存 ： CODESYS 指定された時間間隔でプロジェクトを自動的に保存します <project name>.autosave ファイル。プログラミングシステムを不定期に閉じた後にリロードできます。 プロジェクトが定期的に閉じられるか保存される場合、 CODESYS を削除します .autosave ファイル。不規則なプログラム終了の場合、 CODESYS を維持します .autosave ファイル。関連付けられているプロジェクトを開くとき .autosave ファイル、 自動保存バックアップ ダイアログが開きます。このダイアログでは、を開くかどうかを選択します .autosave ファイルまたはユーザーが最後に保存したプロジェクトのバージョン。 ビルドする前に保存 CODESYS 各ビルド操作の前にプロジェクトを自動的に保存します。 プロジェクト復旧情報を作成する 要件: 保護なし オプションまたは 整合性チェック のプロジェクト設定でオプションが選択されている 安全 カテゴリー。これは、プロジェクトが不正アクセスやデータ操作から保護されておらず、プロジェクトのロード時に整合性チェックが行われないことを意味します。 ：編集中にプロジェクトがクラッシュした場合、次にプロジェクトを開くと、保存されていないデータを復元して新しいプロジェクトファイルを作成するかどうかを尋ねるプロンプトが開きます。クリックすると はい 、次に別のダイアログが開きます。このダイアログでは、復元されたプロジェクトを開くか、プロジェクト比較を開くかを選択できます。このプロジェクト比較では、最後に保存されたプロジェクトと復元されたプロジェクトの違いが表示されます。 注：プロジェクトの復元では、変更が行われたときにすべての変更がハードディスクに記録されます。この操作中にハードディスクで電源障害またはハードディスクエラーが発生した場合、最後の変更が失われる可能性があります。 高度な設定 The 高度な設定 ダイアログが開きます。 起動時 の起動画面のリストボックス CODESYS ： スタートページを表示 ：のスタートページ CODESYS 表示されています。 最後にロードされたプロジェクトをロードする [プロジェクトを開く]ダイアログボックスを表示する 「新規プロジェクト」ダイアログボックスを表示 空の環境を表示する ニュースページ によって開かれるURL ヘルプ→ CODESYS ホームページ 指図 デフォルトでは、 http:\/\/www.codesys.com\/startpage ここで指定します。 ダイアログ： 高度な設定 プロジェクトの圧縮 レベル 要件： 保護なし オプションは、のプロジェクト設定で選択されています 安全 カテゴリー。これは、プロジェクトが不正アクセスやデータ操作から保護されておらず、プロジェクトのロード時に整合性チェックが行われないことを意味します。 プロジェクトの保存時に使用される圧縮レベルのリストボックス： 最小の圧縮–最高の速度（推奨） 中程度の圧縮–中速 ほとんどの圧縮–最悪の速度 荷重挙動 プロジェクトの編集中に、ライブラリとコンパイル情報がバックグラウンドで読み込まれます。 詳細については、以下を参照してください。 プロジェクトの保護と保存" }, 
{ "title" : "ダイアログ：オプション：監視 ", 
"url" : "_cds_dlg_options_monitoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：監視 ", 
"snippet" : "監視 シンボル： 関数 ：ダイアログには、モニタリングで変数値を表示するための設定が含まれています。 電話 ： ツール→オプション 指図、 モニタリング カテゴリー 整数変数のモード バイナリ 変数の値は、オンラインモードで対応する形式で表示されます。 このオプションは、 デバッグ→表示モード 指図。 10進数 16進数 浮動小数点変数 表示桁数 REAL値が表示されたときにオンラインモードで表される小数点以下の桁数 注：設定は、ウォッチリスト、宣言エディタの監視、およびトレースエディタに適用されます。エディターのインライン監視の構成は、テキストエディターのオプションで設定されます。 詳細につ...", 
"body" : "監視 シンボル： 関数 ：ダイアログには、モニタリングで変数値を表示するための設定が含まれています。 電話 ： ツール→オプション 指図、 モニタリング カテゴリー 整数変数のモード バイナリ 変数の値は、オンラインモードで対応する形式で表示されます。 このオプションは、 デバッグ→表示モード 指図。 10進数 16進数 浮動小数点変数 表示桁数 REAL値が表示されたときにオンラインモードで表される小数点以下の桁数 注：設定は、ウォッチリスト、宣言エディタの監視、およびトレースエディタに適用されます。エディターのインライン監視の構成は、テキストエディターのオプションで設定されます。 詳細については、以下を参照してください。 タブ：監視 " }, 
{ "title" : "ダイアログ: オプション - オンライン ", 
"url" : "_cds_dlg_options_online.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ: オプション - オンライン ", 
"snippet" : "オンライン シンボル： 関数 : このダイアログでは、コントローラとの接続を強制的に切断したり、コントローラとの接続が切断されるまでの無操作時間を設定したりできます。 電話 : 非アクティブ時間が経過した後にデバイスから強制的に切断します : このダイアログで指定した時間(秒単位)が経過すると、コントローラへの接続が終了します。 <番号> 秒 デフォルト値: 1800 秒 値の範囲: [10, 10800] ここで設定した時間は保存されます。つまり、この値は閉じて再度開いた後も設定されたままになります。 CODESYS 。 詳細については、以下を参照してください。 オプション: --Force...", 
"body" : "オンライン シンボル： 関数 : このダイアログでは、コントローラとの接続を強制的に切断したり、コントローラとの接続が切断されるまでの無操作時間を設定したりできます。 電話 : 非アクティブ時間が経過した後にデバイスから強制的に切断します : このダイアログで指定した時間(秒単位)が経過すると、コントローラへの接続が終了します。 <番号> 秒 デフォルト値: 1800 秒 値の範囲: [10, 10800] ここで設定した時間は保存されます。つまり、この値は閉じて再度開いた後も設定されたままになります。 CODESYS 。 詳細については、以下を参照してください。 オプション: --ForceDisconnectAfterInactivity" }, 
{ "title" : "ダイアログ：オプション：PLCopenXML ", 
"url" : "_cds_dlg_options_plcopenxml.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：PLCopenXML ", 
"snippet" : "PLCopenXML シンボル： 関数 ：ダイアログには、の動作の設定が含まれています CODESYS PLCopenXMLの場合 輸出 また 輸入 。 電話 ： ツール→オプション 指図、 PLCopenXML カテゴリー PLCopenXMLエクスポート設定 さらに、宣言をプレーンテキストとしてエクスポートします デフォルトでは、 CODESYS PLCopenXMLスキームに従って宣言部分を個々の変数に分割するため、フォーマットと一部のコメント情報が失われます。 ：フォーマットとコメントは保持されます。 CODESYS エクスポートされた宣言部分のプレーンテキストをPLCopenXMLフ...", 
"body" : "PLCopenXML シンボル： 関数 ：ダイアログには、の動作の設定が含まれています CODESYS PLCopenXMLの場合 輸出 また 輸入 。 電話 ： ツール→オプション 指図、 PLCopenXML カテゴリー PLCopenXMLエクスポート設定 さらに、宣言をプレーンテキストとしてエクスポートします デフォルトでは、 CODESYS PLCopenXMLスキームに従って宣言部分を個々の変数に分割するため、フォーマットと一部のコメント情報が失われます。 ：フォーマットとコメントは保持されます。 CODESYS エクスポートされた宣言部分のプレーンテキストをPLCopenXMLファイルに書き込むため、PLCopenXMLスキームが拡張されます。 エクスポートフォルダの構造 ： CODESYS 選択したオブジェクトの1つが含まれている場合は、フォルダーもエクスポートします。あれは CODESYS -PLCopenXMLスキームの特定の拡張。 PLCopenXMLインポート設定 フォルダ構造をインポートする ：インポートファイルにオブジェクトのフォルダ構造に関する情報が含まれている場合、 CODESYS この構造もインポートします。 ： CODESYS 構造のないオブジェクトをインポートします。 詳細については、以下を参照してください。 プロジェクトのエクスポートとインポート" }, 
{ "title" : "ダイアログ：オプション：プロキシ設定 ", 
"url" : "_cds_dlg_options_proxy_settings.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：プロキシ設定 ", 
"snippet" : "プロキシ設定 シンボル： 関数 ：ダイアログは、現在使用されているプロキシサーバーの認証データを保存するために使用されます CODESYS インターネットにアクセスします。 電話 ： ツール→オプション 指図、 プロキシ設定 カテゴリー 要件 ：インターネットは、プロキシサーバーを介してネットワークでアクセスされます。 プロキシクレデンシャルを入力してください ダブルクリックすると、プロキシサーバーのユーザー名とパスワードのダイアログプロンプトが開きます。 CODESYS クレデンシャルを使用して、ライブラリとデバイスの説明のダウンロードサーバーへの接続、 CODESYS 、および 表示→スタ...", 
"body" : "プロキシ設定 シンボル： 関数 ：ダイアログは、現在使用されているプロキシサーバーの認証データを保存するために使用されます CODESYS インターネットにアクセスします。 電話 ： ツール→オプション 指図、 プロキシ設定 カテゴリー 要件 ：インターネットは、プロキシサーバーを介してネットワークでアクセスされます。 プロキシクレデンシャルを入力してください ダブルクリックすると、プロキシサーバーのユーザー名とパスワードのダイアログプロンプトが開きます。 CODESYS クレデンシャルを使用して、ライブラリとデバイスの説明のダウンロードサーバーへの接続、 CODESYS 、および 表示→スタートページ 指図。 要件：このボタンは、コンピューターまたはネットワークがプロキシサーバー経由でインターネットにアクセスできる場合に使用できます。 " }, 
{ "title" : "ダイアログ：オプション：リファクタリング ", 
"url" : "_cds_dlg_options_refactoring.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：リファクタリング ", 
"snippet" : "リファクタリング シンボル： 関数 ：ダイアログは、自動リファクタリングが提案されているプロジェクトの操作を定義するために使用されます。リファクタリング機能は、改善の取り組みに役立ちます。 電話 ： ツール→オプション 指図、 リファクタリング カテゴリー...", 
"body" : "リファクタリング シンボル： 関数 ：ダイアログは、自動リファクタリングが提案されているプロジェクトの操作を定義するために使用されます。リファクタリング機能は、改善の取り組みに役立ちます。 電話 ： ツール→オプション 指図、 リファクタリング カテゴリー " }, 
{ "title" : "次の操作のリファクタリングを提案する ", 
"url" : "_cds_dlg_options_refactoring.html#UUID-1bedf43c-55f6-693f-ef62-59657cb1e67e_id_d71dbe1a61c0a8640e00abed65_id_0152096f7d12ab0bc0a864637db0450e", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：リファクタリング \/ 次の操作のリファクタリングを提案する ", 
"snippet" : "自動宣言 AutoDeclareを呼び出すとき（ シフト + F2 ）宣言内の変数の名前を変更するには、選択した リファクタリングを使用して変更を適用する オプションが表示されます。そうして リファクタリング ダイアログが開き、プロジェクト全体で変数を変更できます。 変数の追加または削除、またはスコープの変更について ：名前を削除します 変数を宣言する ダイアログをクリックしてクリックします わかった ダイアログを閉じます。そうして リファクタリング ダイアログが開き、プロジェクト全体で変数が削除されます。 変数の名前変更について ：名前を指定します 変数を宣言する ダイアログをクリックしてク...", 
"body" : "自動宣言 AutoDeclareを呼び出すとき（ シフト + F2 ）宣言内の変数の名前を変更するには、選択した リファクタリングを使用して変更を適用する オプションが表示されます。そうして リファクタリング ダイアログが開き、プロジェクト全体で変数を変更できます。 変数の追加または削除、またはスコープの変更について ：名前を削除します 変数を宣言する ダイアログをクリックしてクリックします わかった ダイアログを閉じます。そうして リファクタリング ダイアログが開き、プロジェクト全体で変数が削除されます。 変数の名前変更について ：名前を指定します 変数を宣言する ダイアログをクリックしてクリックします わかった ダイアログを閉じます。そうして リファクタリング ダイアログが開き、プロジェクト全体で変数の名前を変更できます。 「リファクタリング」の章「変数宣言の変更とリファクタリングの自動適用」を参照してください。 単位変換エディタ 単位変換の名前変更について ：単位変換エディタで変換の名前を変更すると、かどうかを確認するメッセージが表示されます CODESYS 名前を変更するときは、「自動リファクタリング」を実行する必要があります。 マッピングエディタ 変数の名前変更について ：デバイスエディタで変数名を変更した場合（ I \/ Oマッピング タブ）、プロンプトが表示されます CODESYS 名前を変更するときは、「自動リファクタリング」を実行する必要があります。 ナビゲーター オブジェクトの名前変更について ：デバイスツリーまたはPOUビューでオブジェクトの名前を変更すると、プロンプトが表示されます。 CODESYS 名前を変更するときは、「自動リファクタリング」を実行する必要があります。 表形式の宣言エディター 変数の名前変更について ：表形式の宣言エディタで変数の名前を変更すると、プロンプトが表示されます。 CODESYS 名前を変更するときは、「自動リファクタリング」を実行する必要があります。 UMLクラス図 クラス図エディタで行われた変更に対するリファクタリング（プロジェクト全体でのIECコードの適応を意味する）のサポートのオプション 変数の追加または削除について ：リファクタリングは、変数を追加または削除するときにサポートされます。 VAR_INPUT 、 VAR_OUTPUT 、 と VAR_INOUT クラス図のセクション。 POUの名前変更について ：クラス図でPOUの名前を変更すると、リファクタリングがサポートされます。 変数またはプロパティの名前変更について ：クラス図で変数またはプロパティの名前を変更すると、リファクタリングがサポートされます。 注： リファクタリングプレビューをスキップ UMLオプションでオプションが選択されている場合、プロジェクト内の関連するすべての場所でリファクタリングが実行されます。 リファクタリング 場合によっては、ダイアログ。詳細については、ヘルプの「ダイアログ 'オプション' –'UML '」を参照してください。 CODESYS UML 詳細については、以下を参照してください。 リファクタリング" }, 
{ "title" : "ダイアログ：オプション：シーケンスエディタ ", 
"url" : "_cds_dlg_options_seq_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：シーケンスエディタ ", 
"snippet" : "シーケンスエディタ シンボル： 関数 ：ダイアログには、 シーケンスエディタ 。 電話 ： ツール→オプション 指図、 シーケンスエディタ カテゴリー 全般的 要素の選択 CODESYS シーケンスエディタのシーケンスステップに表示されます 外観 シーケンスステップの外観とシーケンスステップ間の接続線、および テキスト 、 パラメーター 、 参考文献 、 と I \/ Oチャネル 接続 分岐ステップ後の接続線の色の選択 B接続 分岐ステップ（代替分岐）後の接続線の色の選択...", 
"body" : "シーケンスエディタ シンボル： 関数 ：ダイアログには、 シーケンスエディタ 。 電話 ： ツール→オプション 指図、 シーケンスエディタ カテゴリー 全般的 要素の選択 CODESYS シーケンスエディタのシーケンスステップに表示されます 外観 シーケンスステップの外観とシーケンスステップ間の接続線、および テキスト 、 パラメーター 、 参考文献 、 と I \/ Oチャネル 接続 分岐ステップ後の接続線の色の選択 B接続 分岐ステップ（代替分岐）後の接続線の色の選択 " }, 
{ "title" : "ダイアログ：オプション：テキストエディタ ", 
"url" : "_cds_dlg_options_text_editor.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：テキストエディタ ", 
"snippet" : "テキストエディタ シンボル： 関数 ：ダイアログには、テキストエディタを表示して操作するための設定が含まれています。 電話 ： ツール→オプション 指図、 テキストエディタ カテゴリー...", 
"body" : "テキストエディタ シンボル： 関数 ：ダイアログには、テキストエディタを表示して操作するための設定が含まれています。 電話 ： ツール→オプション 指図、 テキストエディタ カテゴリー " }, 
{ "title" : "タブ：テーマ ", 
"url" : "_cds_dlg_options_text_editor.html#UUID-aee4222a-ae45-5987-36f9-2fa9772b4160_id_e24f8a1565c0a8640e005b0b28_id_b87761b04ff2cdecc0a8640e00bac4c1", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：テキストエディタ \/ タブ：テーマ ", 
"snippet" : "このタブでは、STエディタのインターフェイスデザインで目的の「テーマ」を設定します。 テーマ テキストエディタのカラーテーマ 選択したテーマがに表示されます プレビュー 窓。使用可能な配色は、のインストールディレクトリに保存されています。 Themes フォルダ。...", 
"body" : "このタブでは、STエディタのインターフェイスデザインで目的の「テーマ」を設定します。 テーマ テキストエディタのカラーテーマ 選択したテーマがに表示されます プレビュー 窓。使用可能な配色は、のインストールディレクトリに保存されています。 Themes フォルダ。 " }, 
{ "title" : "タブ：編集 ", 
"url" : "_cds_dlg_options_text_editor.html#UUID-aee4222a-ae45-5987-36f9-2fa9772b4160_id_e24f8a1565c0a8640e005b0b28_id_eafa9d684ff2cdefc0a8640e00d4f909", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：テキストエディタ \/ タブ：編集 ", 
"snippet" : "元に戻す回数 適用できる編集ステップの最大数 編集→元に戻す 指図 折りたたみ インデントによってコードの構造を定義します インデントを選択すると、各セクションの最初の行の前にあるプラス記号とマイナス記号を使用して、インデントセクションを展開または折りたたむことができます。 インデント ： CODESYS 前の行に対してインデントされているすべての行を1つのインデント単位に結合します。 明示的 ：1つのインデント単位で組み合わせる必要のあるコメントでコードセグメントを明示的にマークします。3つの開始中括弧 \"{{{\"を含むコメントはセグメントの前にあり、3つの終了中括弧 \"}}}を含むコメント...", 
"body" : "元に戻す回数 適用できる編集ステップの最大数 編集→元に戻す 指図 折りたたみ インデントによってコードの構造を定義します インデントを選択すると、各セクションの最初の行の前にあるプラス記号とマイナス記号を使用して、インデントセクションを展開または折りたたむことができます。 インデント ： CODESYS 前の行に対してインデントされているすべての行を1つのインデント単位に結合します。 明示的 ：1つのインデント単位で組み合わせる必要のあるコメントでコードセグメントを明示的にマークします。3つの開始中括弧 \"{{{\"を含むコメントはセグメントの前にあり、3つの終了中括弧 \"}}}を含むコメントは次のようになります。セグメントの後にあります。コメントには追加のテキストを含めることができます。例： ワードラップ 柔らかい ：0を指定すると、エディタウィンドウの端で改行が発生します。 ラップマージン 。 難しい ：指定された文字数の後に改行が発生します ラップマージン 。 タブ幅 文字数 タブを維持する ： CODESYS によって挿入した間隔を分割しません タブ キー、後で個々のスペースに。 インデント幅 選択した場合 頭いい また コード補完でスマート のために AutoIndent オプション、次に CODESYS 行の先頭にスペースの数を挿入します。 AutoIndent なし ブロック ：新しい行は、前の行のインデントを自動的に適用します。 頭いい ：キーワードを含む行に続く行（たとえば、 VAR ）指定された値で自動的にインデントします Indent width 。 コード補完でスマート ：の場合のようにインデント 頭いい オプションですが、 CODESYS また、終了キーワードを挿入します（たとえば、 END_VAR ）。 " }, 
{ "title" : "タブ：テキストエリア ", 
"url" : "_cds_dlg_options_text_editor.html#UUID-aee4222a-ae45-5987-36f9-2fa9772b4160_id_e24f8a1565c0a8640e005b0b28_id_69e944a24ff2cdf1c0a8640e01db5766", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：テキストエディタ \/ タブ：テキストエリア ", 
"snippet" : "現在の行を強調表示 ：カーソルのある行が強調表示されます。 一致するブラケット ：カーソルがコード行内の角かっこの前または後ろにある場合、対応する閉じかっこまたは開きかっこはフレームでマークされます。 行末マーカー ：各エディター行の終わりは、行の最後の文字（スペースを含む）の後に小さなダッシュでマークされます。 ラップガイド ：ソフトまたはハードの改行を選択すると、定義した改行位置が縦線で表示されます。 フォント フィールドをクリックすると、フォントを構成するためのデフォルトのダイアログが開きます。...", 
"body" : "現在の行を強調表示 ：カーソルのある行が強調表示されます。 一致するブラケット ：カーソルがコード行内の角かっこの前または後ろにある場合、対応する閉じかっこまたは開きかっこはフレームでマークされます。 行末マーカー ：各エディター行の終わりは、行の最後の文字（スペースを含む）の後に小さなダッシュでマークされます。 ラップガイド ：ソフトまたはハードの改行を選択すると、定義した改行位置が縦線で表示されます。 フォント フィールドをクリックすると、フォントを構成するためのデフォルトのダイアログが開きます。 " }, 
{ "title" : "タブ：マージン ", 
"url" : "_cds_dlg_options_text_editor.html#UUID-aee4222a-ae45-5987-36f9-2fa9772b4160_id_e24f8a1565c0a8640e005b0b28_id_1e6959244ff2cdf1c0a8640e01e6af9e", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：テキストエディタ \/ タブ：マージン ", 
"snippet" : "垂直線で入力領域から分離されているテキストエディタウィンドウの左マージンの設定 行番号 ：エディターの宣言と実装の部分は左側に番号が付けられており、それぞれ1で始まります。 現在の行を強調表示 ：カーソルが置かれている行の行番号が強調表示されます。 ブラケットスコープを表示 ：角かっこには、構成要素を開いたり閉じたりするキーワード間の行が含まれます（たとえば、 IF と END_IF ）。オプションが選択され、カーソルが構成のキーワードの前、後、またはいずれかに置かれると、角かっこ領域が余白に角かっこで表示されます。 マウスアクション 指定したマウスアクションまたはマウス\/キーボードの組み合わ...", 
"body" : "垂直線で入力領域から分離されているテキストエディタウィンドウの左マージンの設定 行番号 ：エディターの宣言と実装の部分は左側に番号が付けられており、それぞれ1で始まります。 現在の行を強調表示 ：カーソルが置かれている行の行番号が強調表示されます。 ブラケットスコープを表示 ：角かっこには、構成要素を開いたり閉じたりするキーワード間の行が含まれます（たとえば、 IF と END_IF ）。オプションが選択され、カーソルが構成のキーワードの前、後、またはいずれかに置かれると、角かっこ領域が余白に角かっこで表示されます。 マウスアクション 指定したマウスアクションまたはマウス\/キーボードの組み合わせのそれぞれに、次のアクションのいずれかを割り当てることができます。 CODESYS 括弧で囲まれた領域のヘッダーの前にあるプラス記号またはマイナス記号にマウスを移動すると、選択したアクションが実行されます。 なし ：マウスアクションはアクションをトリガーしません。 フォールドを選択 ： CODESYS 括弧で囲まれた領域のすべての行を選択します。 トグルフォールド ： CODESYS 角かっこ領域を開いたり閉じたりします。ネストされた角かっこがある場合は、角かっこ領域の最初のレベルです。 完全に折りたたむ ： CODESYS ネストされた括弧で囲まれた領域のすべてのレベルを開いたり閉じたりします。 " }, 
{ "title" : "タブ：監視 ", 
"url" : "_cds_dlg_options_text_editor.html#UUID-aee4222a-ae45-5987-36f9-2fa9772b4160_id_e24f8a1565c0a8640e005b0b28_id_0ca52533c15411e3a290e57e01b702a2", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：オプション \/ ダイアログ：オプション：テキストエディタ \/ タブ：監視 ", 
"snippet" : "監視フィールドを表示するための設定 インラインモニタリングを有効にする ：オンラインモードでの変数の後の監視フィールドの表示 表示桁数 監視フィールドに表示される浮動小数点数の桁数 例：値：12.345;表示桁数：3;表示：12.3 文字列の長さ 監視フィールドの文字列変数値の最大長...", 
"body" : "監視フィールドを表示するための設定 インラインモニタリングを有効にする ：オンラインモードでの変数の後の監視フィールドの表示 表示桁数 監視フィールドに表示される浮動小数点数の桁数 例：値：12.345;表示桁数：3;表示：12.3 文字列の長さ 監視フィールドの文字列変数値の最大長 " }, 
{ "title" : "ダイアログ：カスタマイズ ", 
"url" : "_cds_f_dlg_customize.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：カスタマイズ ", 
"snippet" : "カスタマイズ ダイアログには、ユーザーインターフェイスを構成するためのタブが含まれています。 いつでも使用できます リセット ボタンをリセットして CODESYS デフォルトの設定。...", 
"body" : "カスタマイズ ダイアログには、ユーザーインターフェイスを構成するためのタブが含まれています。 いつでも使用できます リセット ボタンをリセットして CODESYS デフォルトの設定。 " }, 
{ "title" : "ダイアログ：カスタマイズ：メニュー ", 
"url" : "_cds_dlg_customize_menu.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：カスタマイズ \/ ダイアログ：カスタマイズ：メニュー ", 
"snippet" : "メニュー 関数 ：このダイアログでは、ユーザーインターフェイスの構造と内容を定義します。 電話 ： ツール→カスタマイズ 指図、 メニュー タブ クリックすると わかった ダイアログを閉じるには、変更がのメニューバーに表示されます CODESYS ユーザーインターフェース。 メニュー 現在定義されているメニュー、サブメニュー、および含まれているコマンドの表示 CODESYS メニューまたはサブメニューのキャプションを シンボル。上から下へのレイアウトは、後で表示されるレイアウトに対応しています。 CODESYS メニュー。 コマンドの追加 コマンド選択時に選択可能 選択したコマンドの上にコマン...", 
"body" : "メニュー 関数 ：このダイアログでは、ユーザーインターフェイスの構造と内容を定義します。 電話 ： ツール→カスタマイズ 指図、 メニュー タブ クリックすると わかった ダイアログを閉じるには、変更がのメニューバーに表示されます CODESYS ユーザーインターフェース。 メニュー 現在定義されているメニュー、サブメニュー、および含まれているコマンドの表示 CODESYS メニューまたはサブメニューのキャプションを シンボル。上から下へのレイアウトは、後で表示されるレイアウトに対応しています。 CODESYS メニュー。 コマンドの追加 コマンド選択時に選択可能 選択したコマンドの上にコマンドを追加します を開きます コマンドの追加 ダイアログ 使用 コマンドの追加 1つまたは複数のコマンドを選択するためのダイアログ。 左側：カテゴリのリスト 右側：選択したカテゴリのコマンドのリスト セパレータを追加 選択したコマンドの上にセパレータを挿入します ポップアップメニューを追加 選択したメニュー、サブメニュー、またはコマンドの上にポップアップメニューを追加します を開きます ポップアップメニューを追加 ダイアログ ポップアップメニューの編集 を開きます ポップアップメニューを追加 ダイアログ リセット メニュー全体をデフォルト設定にリセットします ロード 保存されたファイル（<ファイル名> .opt.menu）から設定をロードします ポップアップメニューを追加 CODESYS メニューに少なくとも1つのコマンドが含まれている場合にのみ、メニューバーに新しいメニューを表示します。 デフォルトのテキスト ローカリゼーションが利用可能な場合は、このオプションを選択してください。 ローカライズされたテキスト 言語とローカライズされたテキストのリスト 言語を追加 言語のリストボックスを開きます CODESYS 選択した言語をで表示します ローカライズされたテキスト 範囲。使用 文章 ローカライズされたテキストを指定する列。 詳細については、以下を参照してください。 メニューをカスタマイズする" }, 
{ "title" : "ダイアログ：カスタマイズ：コマンドアイコン ", 
"url" : "_cds_dlg_customize_command_icon.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：カスタマイズ \/ ダイアログ：カスタマイズ：コマンドアイコン ", 
"snippet" : "コマンドアイコン 関数 ：このダイアログでは、メニューコマンドのアイコンを定義します。 電話 ： ツール→カスタマイズ 指図、 コマンドアイコン タブ コマンドアイコン 割当 新しいアイコン（* .ico）を選択できるダイアログを開きます 削除する カスタムアイコンを削除します デフォルトのアイコンが再びアクティブになります。 リセット すべてのコマンドアイコンをデフォルト設定にリセットします ロード 保存されたファイル（<ファイル名> .opt.keyb）から設定をロードします 保存する 現在の設定をファイル（<ファイル名> .opt.keyb）に保存します 詳細については、以下を参照してく...", 
"body" : "コマンドアイコン 関数 ：このダイアログでは、メニューコマンドのアイコンを定義します。 電話 ： ツール→カスタマイズ 指図、 コマンドアイコン タブ コマンドアイコン 割当 新しいアイコン（* .ico）を選択できるダイアログを開きます 削除する カスタムアイコンを削除します デフォルトのアイコンが再びアクティブになります。 リセット すべてのコマンドアイコンをデフォルト設定にリセットします ロード 保存されたファイル（<ファイル名> .opt.keyb）から設定をロードします 保存する 現在の設定をファイル（<ファイル名> .opt.keyb）に保存します 詳細については、以下を参照してください。 コマンドアイコンのカスタマイズ" }, 
{ "title" : "ダイアログ：カスタマイズ：ツールバー ", 
"url" : "_cds_dlg_customize_toolbar.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：カスタマイズ \/ ダイアログ：カスタマイズ：ツールバー ", 
"snippet" : "ツールバー 関数 ：このダイアログでは、新しいツールバーを作成するか、既存のツールバーをカスタマイズします。 電話 ： ツール→カスタマイズ 指図、 ツールバー タブ クリックすると わかった ダイアログを閉じるには、変更がのメニューバーに表示されます CODESYS ユーザーインターフェース。 ツールバー 現在定義されているツールバーの表示 CODESYS は、ツールバーに表示される順序で、各ツールバーの下に関連するコマンドを一覧表示します。 リストのツールバーをダブルクリックすると、編集モードに切り替わります。 ツールバーを追加 ツールバー選択時に選択可能 CODESYS 選択したツールバ...", 
"body" : "ツールバー 関数 ：このダイアログでは、新しいツールバーを作成するか、既存のツールバーをカスタマイズします。 電話 ： ツール→カスタマイズ 指図、 ツールバー タブ クリックすると わかった ダイアログを閉じるには、変更がのメニューバーに表示されます CODESYS ユーザーインターフェース。 ツールバー 現在定義されているツールバーの表示 CODESYS は、ツールバーに表示される順序で、各ツールバーの下に関連するコマンドを一覧表示します。 リストのツールバーをダブルクリックすると、編集モードに切り替わります。 ツールバーを追加 ツールバー選択時に選択可能 CODESYS 選択したツールバーの上にツールバーを追加し、新しいツールバーの名前フィールドにカーソルを置きます。 コマンドの追加 ツールバーの下のコマンドまたは空白のコマンドエントリを選択すると選択できます 選択したコマンドの上にコマンドを追加します を開きます コマンドの追加 ダイアログ 使用 コマンドの追加 1つまたは複数のコマンドを選択するためのダイアログ。 左側：カテゴリのリスト 右側：選択したカテゴリのコマンドのリスト セパレータを追加 選択したコマンドの上にセパレータを挿入します 隠れる 選択したツールバーをから非表示にします CODESYS ユーザーインターフェース 見せる 選択したツールバーを CODESYS ユーザーインターフェース リセット ツールバーをデフォルト設定にリセットします ロード 保存されたファイル（<ファイル名> .opt.tbar）から設定をロードします 詳細については、以下を参照してください。 ツールバーをカスタマイズする" }, 
{ "title" : "ダイアログ：カスタマイズ：キーボード ", 
"url" : "_cds_dlg_customize_keyboard.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：カスタマイズ \/ ダイアログ：カスタマイズ：キーボード ", 
"snippet" : "キーボード 関数 ：このダイアログでは、コマンドのショートカット（クイックアクセスキーまたはキーボードの組み合わせ）を定義します。 コール : ツール → カスタマイズ コマンド、 キーボード タブ タブ: キーボード 選択したコマンドのショートカット 選択したコマンドのキーボードショートカット リストボックスには、コマンドの複数のショートカットを含めることができます。 ショートカットキーを押す 選択したフィールドのショートカットの入力フィールド 許可される組み合わせは次のとおりです。 Ctrl 、 Alt 、 シフト 、およびその他のキー。クリックします 割当 記録されたショートカットを選択...", 
"body" : "キーボード 関数 ：このダイアログでは、コマンドのショートカット（クイックアクセスキーまたはキーボードの組み合わせ）を定義します。 コール : ツール → カスタマイズ コマンド、 キーボード タブ タブ: キーボード 選択したコマンドのショートカット 選択したコマンドのキーボードショートカット リストボックスには、コマンドの複数のショートカットを含めることができます。 ショートカットキーを押す 選択したフィールドのショートカットの入力フィールド 許可される組み合わせは次のとおりです。 Ctrl 、 Alt 、 シフト 、およびその他のキー。クリックします 割当 記録されたショートカットを選択したコマンドに割り当てます。 現在使用されているショートカット 現在定義されているショートカットに割り当てられたコマンド リセット ショートカットをデフォルト設定にリセットします ロード 保存されたファイルから設定をロードします <file name>.opt.keyb 詳細については、以下を参照してください。 キーボードショートカットのカスタマイズ、 キーボードショートカット、および ウィンドウズ™ ショートカット" }, 
{ "title" : "ダイアログ：証明書の選択 ", 
"url" : "_cds_dlg_certificate_selection.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：証明書の選択 ", 
"snippet" : "証明書の選択 シンボル： 関数 ：ダイアログは、暗号化、復号化、およびデジタル署名の証明書を選択するために使用されます。 電話 ： セキュリティ画面 見る、 ユーザー タブ 表示→プロパティ 指図、 暗号化 タブ、 応用 デバイスツリーで選択されている プロジェクト→プロジェクト設定 指図、 安全 カテゴリー...", 
"body" : "証明書の選択 シンボル： 関数 ：ダイアログは、暗号化、復号化、およびデジタル署名の証明書を選択するために使用されます。 電話 ： セキュリティ画面 見る、 ユーザー タブ 表示→プロパティ 指図、 暗号化 タブ、 応用 デバイスツリーで選択されている プロジェクト→プロジェクト設定 指図、 安全 カテゴリー " }, 
{ "title" : "ダイアログ：証明書の選択 ", 
"url" : "_cds_dlg_certificate_selection.html#UUID-e72f57e4-30c1-3979-3c7c-8789f178b99d_id_fbfcef7f68cc8d6c0a864630f88b355_id_66ae7b16c2e29ee4c0a8646372161059", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ：証明書の選択 \/ ダイアログ：証明書の選択 ", 
"snippet" : "ダイアログで選択される証明書の目的は、呼び出し場所によって異なります。 呼び出し場所： セキュリティ画面 見る、 ユーザー タブ デジタル署名の証明書 プロジェクトファイルの復号化のための証明書 暗号化された通信証明書 呼び出し場所： 表示→プロパティ アプリケーションの 暗号化されたダウンロードとブートアプリケーションを共有するデバイスの証明書 呼び出し場所： プロジェクト→プロジェクト設定 、 安全 カテゴリー プロジェクト暗号化の証明書 選択した証明書のテーブルへの一覧 選択したX.509証明書ごとに、次のプロパティが表示されます。 のために発行された が発行 から有効 まで有効 拇印 ...", 
"body" : "ダイアログで選択される証明書の目的は、呼び出し場所によって異なります。 呼び出し場所： セキュリティ画面 見る、 ユーザー タブ デジタル署名の証明書 プロジェクトファイルの復号化のための証明書 暗号化された通信証明書 呼び出し場所： 表示→プロパティ アプリケーションの 暗号化されたダウンロードとブートアプリケーションを共有するデバイスの証明書 呼び出し場所： プロジェクト→プロジェクト設定 、 安全 カテゴリー プロジェクト暗号化の証明書 選択した証明書のテーブルへの一覧 選択したX.509証明書ごとに、次のプロパティが表示されます。 のために発行された が発行 から有効 まで有効 拇印 ：SHA1フィンガープリント エントリをダブルクリックすると、 証明書 との対話 全般的 タブ、 詳細 タブ、および 認定パス タブ。タブには、ダイアログの詳細についてのWindowsヘルプへの参照があります。 選択した使用可能な証明書を選択した証明書のリストに追加します リストで選択された証明書を削除します ローカルのWindows証明書ストアで利用可能な証明書 エントリをダブルクリックすると、 証明書 との対話 全般的 タブ、 詳細 タブ、および 認定パス タブ。タブには、ダイアログの詳細についてのWindowsヘルプへの参照があります。 証明書アイコン ：秘密鍵を使用した証明書 ：信頼できない証明書 詳細については、以下を参照してください。 セキュリティ画面" }, 
{ "title" : "ダイアログ: ライブラリ パラメータ ", 
"url" : "_cds_dlg_library_parameter.html", 
"breadcrumbs" : "CODESYS Essentials \/ 参照：ユーザーインターフェイス \/ ダイアログ \/ ダイアログ: ライブラリ パラメータ ", 
"snippet" : "ライブラリ パラメータ このダイアログには、アプリケーションと POU プールの Library Manager に存在するライブラリのライブラリ パラメータが表示されます。パラメータの値は、このダイアログで変更できます。さらに、パラメータのエクスポートとインポートが可能です。 書き出す を開きます Export Library Parameters エクスポートするパラメーター リストを選択するためのダイアログ。パラメータリストごとに CSV ファイルが生成されます。 輸入 インポートするパラメータ リストを選択するためのダイアログを開きます リセット (ツールバー) すべてのパラメータをデ...", 
"body" : "ライブラリ パラメータ このダイアログには、アプリケーションと POU プールの Library Manager に存在するライブラリのライブラリ パラメータが表示されます。パラメータの値は、このダイアログで変更できます。さらに、パラメータのエクスポートとインポートが可能です。 書き出す を開きます Export Library Parameters エクスポートするパラメーター リストを選択するためのダイアログ。パラメータリストごとに CSV ファイルが生成されます。 輸入 インポートするパラメータ リストを選択するためのダイアログを開きます リセット (ツールバー) すべてのパラメータをデフォルト値にリセットします 値 (編集可能) パラメータの値。値を編集できます。 デフォルト値 ライブラリで定義されているパラメータのデフォルト値 リセット アイコンをクリックすると、個々のパラメータ、パラメータ リストのすべてのパラメータ、またはすべてのパラメータ リストのすべてのパラメータをデフォルト値にリセットできます。 " }, 
{ "title" : "キーボードショートカット ", 
"url" : "_cds_shortcuts.html", 
"breadcrumbs" : "CODESYS Essentials \/ キーボードショートカット ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "既定のキーボードショートカット ", 
"url" : "_cds_shortcuts.html#UUID-5d1e0bf4-8c51-7fbb-189a-4bb7f0ecc719", 
"breadcrumbs" : "CODESYS Essentials \/ キーボードショートカット \/ 既定のキーボードショートカット ", 
"snippet" : "いつ CODESYS Development System を初めてインストールすると、次のキーの組み合わせがデフォルトで設定されます。 デフォルトのショートカットは、個人の要件に合わせてカスタマイズできます。 デフォルトのキーボードショートカットは、にあります。 [ツール] → カスタマイズ メニュー、 キーボード タブ。そこにリストされているコマンドのいずれかにキーボードショートカットを割り当てたり、削除したり変更したりできます。 詳細については、次を参照してください。 キーボードショートカットのカスタマイズアイコン コマンド ショートカット [説明] カテゴリー 表示 メニュー: 意見[...", 
"body" : "いつ CODESYS Development System を初めてインストールすると、次のキーの組み合わせがデフォルトで設定されます。 デフォルトのショートカットは、個人の要件に合わせてカスタマイズできます。 デフォルトのキーボードショートカットは、にあります。 [ツール] → カスタマイズ メニュー、 キーボード タブ。そこにリストされているコマンドのいずれかにキーボードショートカットを割り当てたり、削除したり変更したりできます。 詳細については、次を参照してください。 キーボードショートカットのカスタマイズアイコン コマンド ショートカット [説明] カテゴリー 表示 メニュー: 意見[デバイス] Alt + 0 を開きます デバイス 表示 [フルスクリーン] Ctrl + Shift + F12 ザル [フルスクリーン] コマンドはフルスクリーンモードとウィンドウモードを切り替えます。 POU Alt + 1 を開きます POU ビュー モジュール Alt + 2 を開きます モジュール 表示 メッセージ Alt + 3 を開きます メッセージ 表示 カテゴリー CFC メニュー: CFC すべて選択 Ctrl + Shift + A CFC エディタのすべてを選択します ピンのリセット Ctrl + U ボックスのピンをリセットします 出力の挿入 Ctrl + A 新しい出力 挿入ボックス Ctrl + Shift + B 新しい箱 入力アシスタントからボックスを挿入 Ctrl + B 入力アシスタントを開きます 入力アシスタントからの EN\/ENO 付きの挿入ボックス Ctrl + Shift + E 入力アシスタントを開きます 入力を挿入 Ctrl + Q 否定する Ctrl + N ジャンプを挿入 Ctrl + L スイッチ S\/R\/Ref\/None Ctrl + M カテゴリー ファイル メニュー: ファイル出口 Alt + F4 出口 CODESYS Development System 新しいプロジェクト Ctrl + N プロジェクトを開く Ctrl + O プロジェクトを保存 Ctrl + S カテゴリー FBD\/LD メニュー: FBD\/LD IL行を削除 Ctrl + Del エッジ検出 Ctrl + E 選択したボックスの入力または出力の前 挿入ボックス Ctrl + B 最後に選択したネットワークで EN\/ENO 付きインサートボックス Ctrl + Shift + E ブランチを挿入 Ctrl + Shift + V 選択した行で コイルを挿入 Ctrl + A 連絡先を挿入 Ctrl + K 連絡先を挿入 (右) Ctrl + D 接触を平行に挿入 (上) Ctrl + P 接触を平行に挿入 (下) Ctrl + R インサートアサインメント Ctrl + A 挿入エッジ検出 Ctrl + E 空のボックスを挿入 Ctrl + Shift + B ネットワークを挿入 Ctrl + I ネットワークを挿入 (下) Ctrl + T 入力を挿入 Ctrl + Q ジャンプを挿入 Ctrl + L 否定 Ctrl + N 上に貼り付け Ctrl + H 下に貼り付け Ctrl + F 右（後）に貼り付け Ctrl + G 出力接続の設定 Ctrl + W セット\/リセット Ctrl + M ネットワーク コメント状態の切り替え Ctrl + O パラメータの更新 Ctrl + U 機能ブロック図で見る Ctrl + 1 インストラクションリストとして表示 Ctrl + 3 ラダーロジックとして表示 Ctrl + 2 カテゴリー デクラレーション メニュー: デクラレーション 入れる Ins 入れるカテゴリー ウィンドウ メニュー: 窓エディタを閉じる Ctrl + F4 前の編集者 Ctrl + Shift + F6 次の編集者 Ctrl + F6 前のペイン Shift + F6 次のペイン F6 最初のペインを切り替え Alt + F6 カテゴリー ブレークポイント メニュー: デバッグブレークポイントの切り替え F9 ステップイン F8 踏みでる Shift + F10 ステップオーバー F10 カテゴリー ヘルプ ヘルプコンテンツ Ctrl + Shift + F1 カテゴリー スマートコーディング 入力アシスタント F2 入力ヘルプ自動申告 Shift + F2 変数を宣言するカテゴリー ラダー (LD2) メニュー: はしご アウトコメント済み Ctrl + O ブロックを挿入 Ctrl + B スイッチエッジ検出 Ctrl + E 連絡先を挿入 Ctrl + K インサートコイル Ctrl + A 入力の挿入 Ctrl + Shift + I 出力の挿入 Ctrl + Shift + O STブロックを挿入 Ctrl + Shift + S 否定する Ctrl + N ネットワークを挿入 Ctrl + I スイッチ セット\/リセット修飾子 Ctrl + M ジャンプを挿入 Ctrl + L リターンを挿入 Ctrl + R EN Ctrl + Shift + E EN 入力を追加または削除します ENQ Ctrl + Shift + N EN0 入力を追加します オープンパラレルブランチ Ctrl + P 並列分岐を閉じる Ctrl + Shift + P カテゴリー ブックマーク メニュー: [編集] → ブックマーク 次のブックマーク (アクティブなエディター) F12 次のブックマーク（アクティブエディタ）前のブックマーク (アクティブなエディター) Shift + F12 前のブックマーク（アクティブエディター）ブックマークの切り替え Ctrl + F12 ブックマークのオン\/オフを切り替えるカテゴリ「メッセージビュー」 次のメッセージ F4 次のメッセージ前のメッセージ Shift + F4 前のメッセージカテゴリー オンライン オンラインデバッグ力の値 F7 力の値ログイン Alt + F8 ログアウト Ctrl + F8 シングルサイクル Ctrl + F5 始める F5 ストップ Shift + F8 値の強制解除 [アクティブなアプリケーション] Alt + F7 値の書き込み [アクティブなアプリケーション] Ctrl + F7 カテゴリー プロジェクトをブラウズ 定義へ移動 Ctrl + Shift + D 定義に移動クロスリファレンスの表示 Ctrl + Shift + X 出力相互参照カテゴリー 元に戻す\/やり直し 標準コマンド元に戻す Ctrl + Z 復元 Ctrl + Y カテゴリー 検索\/置換 編集するには交換 Ctrl + H プロジェクトで置換 Ctrl + Shift + H 探す Ctrl + F プロジェクト内を検索 Ctrl + Shift + F 前を検索 Shift + F3 前を検索 (選択済み) Ctrl + Shift + F3 次を見つける F3 次を検索 (選択済み) Ctrl + F3 カテゴリー テキストエディター 構造化テキストおよび拡張構造化テキスト（ExST）インクリメンタル検索のトグル フィールド Ctrl + Shift + I 小文字にする Ctrl + U 小文字に変換する大文字にする Ctrl + Shift + U 大文字に変換する上書きモード Ins 上書きモード選択した行をコメントアウトする Ctrl + O 選択した行をコメントアウトする選択した行のコメントを解除 Ctrl + I 選択した行からコメントを削除するカテゴリー ビルド コードの生成 F11 コードを生成するカテゴリー クリップボード 標準コマンドコピー Ctrl + Ins 切る Ctrl + X 消去 Del 入れる Ctrl + V [すべて選択] Ctrl + A " }, 
{ "title" : "ST エディタのショートカット ", 
"url" : "_cds_shortcuts.html#UUID-f3d4b715-919a-f02b-f433-3a0754c935f4", 
"breadcrumbs" : "CODESYS Essentials \/ キーボードショートカット \/ ST エディタのショートカット ", 
"snippet" : "ST エディター キーコンビネーション シフト + Alt + → IEC コードの矩形選択範囲を右に拡張します。 ヒント:四角形の選択範囲を使用してコードのインデントを変更してください。 シフト + Alt + ← IEC コードの矩形選択範囲を左に拡張します シフト + Alt + ↑ IEC コードの矩形選択範囲を上に拡張します シフト + Alt + ↓ IEC コードの四角形の選択範囲を下に拡張します シフト + → 選択範囲を右に 1 文字分拡張します シフト + ← 選択範囲を左に 1 文字分拡張します シフト + ↑ 選択範囲を 1 行分拡張します シフト + ↓ 選択範囲を ...", 
"body" : "ST エディター キーコンビネーション シフト + Alt + → IEC コードの矩形選択範囲を右に拡張します。 ヒント:四角形の選択範囲を使用してコードのインデントを変更してください。 シフト + Alt + ← IEC コードの矩形選択範囲を左に拡張します シフト + Alt + ↑ IEC コードの矩形選択範囲を上に拡張します シフト + Alt + ↓ IEC コードの四角形の選択範囲を下に拡張します シフト + → 選択範囲を右に 1 文字分拡張します シフト + ← 選択範囲を左に 1 文字分拡張します シフト + ↑ 選択範囲を 1 行分拡張します シフト + ↓ 選択範囲を 1 行下へ拡張します シフト + マウスホイールを回す IEC コードをスクロールバーに沿ってスクロールします コードをウィンドウに表示できなくなると、スクロールバーが自動的に表示されます。 Ctrl + マウスホイールを回す IEC コードのズームインとズームアウト Ctrl + シフト + 私 文字列のインクリメンタル検索用のダイアログを開きます 文字列を指定してください。この文字列はフィルタリングに使用されます。一致したものはすべて強調表示されます。 Alt + ページアップ Alt + ページダウン IEC コード内の次の強調表示された一致箇所にジャンプします ショートカットは、インクリメンタルサーチのダイアログが開いているときにのみアクティブになります。 " }, 
{ "title" : "変数宣言のショートカット ", 
"url" : "_cds_shortcuts.html#UUID-b084a34b-4c9b-2f23-7f63-b00a45a8774d", 
"breadcrumbs" : "CODESYS Essentials \/ キーボードショートカット \/ 変数宣言のショートカット ", 
"snippet" : "テキスト宣言エディタでは、変数を宣言するショートカットを使用して入力の手間を省くことができます。 1 行のコードでショートフォームを指定し、を押してアクションを完了します Ctrl + 入力してください 。これで、コード行が自動的に完成します。スコープの指定を短くしたり、変数宣言を短くしたりできます 詳細については、「ショートフォーム機能」のセクションを参照してください。 入力アシスタンスを使用するスコープ ショートスコープ 押した後 Ctrl + 入力してください 、完了しました v VAR ev END_VAR vi VAR_INPUT vo VAR_OUTPUT vio VAR_IN_O...", 
"body" : "テキスト宣言エディタでは、変数を宣言するショートカットを使用して入力の手間を省くことができます。 1 行のコードでショートフォームを指定し、を押してアクションを完了します Ctrl + 入力してください 。これで、コード行が自動的に完成します。スコープの指定を短くしたり、変数宣言を短くしたりできます 詳細については、「ショートフォーム機能」のセクションを参照してください。 入力アシスタンスを使用するスコープ ショートスコープ 押した後 Ctrl + 入力してください 、完了しました v VAR ev END_VAR vi VAR_INPUT vo VAR_OUTPUT vio VAR_IN_OUT ショートフォームによる変数宣言 <短い宣言> + Ctrl + Enter 短い宣言は、インデント、最後のセミコロン、コメントを含む完全な変数宣言で補完されます。 行のコードで、最初に変数名を指定し、その後にデータ型、アドレス、初期化、およびコメントの省略形を指定します (すべてオプション)。を押して入力を完了します Ctrl + 入力してください 。次に、省略されたエントリが追加されます <変数名> % <アドレス><データ型の短縮形><初期化> ;  <コメント> ショートデクラレーションのオプション <変数名> 少なくとも 1 つの変数名を指定してください。 複数の変数名をスペースで区切って指定することもできます。カンマは自動的に追加されます % <アドレス> [オプション] ショートアドレスには以下が補足されます AT デクラレーション 。 <データ型の短縮形> [オプション] デフォルトのデータタイプは BOOL 。データ型が指定されていない場合は、 BOOL が追加されました。 括弧内に完全な構文を含む可能性のある短縮形式 b ( : BOOL ) d ( : DINT ) i ( := INT) l ( : LINT ) r ( : REAL ) s ( : STRING ) s 8 ( : STRING(8) 文字列長付き t ( : TIME ) u ( : UINT ) w ( : WORD ) <初期化> [オプション] データ型に一致するリテラルを指定します。 オプションは次のように補足されます :=  <literal> ; <コメント> [オプション] 例 ショートデクラレーション 押した後 Ctrl + 入力してください 、完了しました xStart xStart : BOOL; xStop b xStop : BOOL; xSensor %IX7.5 xSensor AT %IX7.5: BOOL; diMax d 999 diMax: DINT; iMaxLoop i 100 iMaxLoop : INT := 100; liBigLoop l liBigLoop : LINT; rRadius r rRadius : REAL; strStateInProgress s 32 ; State in progress strStateInProgress : STRING(32); \/\/ State in Progress tMaxTime t tMaxTime : TIME; uiCounter u uiCounter : UINT; wFilter w 16#aaaa wFilter : WORD := 16#AAAA; Error_1 Error_2 Error_3 i ; Error codes Error_1, Error_2, Error_3 : INT; \/\/ Error codes " }, 
{ "title" : "ウィンドウズ™ ショートカット ", 
"url" : "_cds_shortcuts.html#UUID-f952bfa4-6c2c-721d-4fad-ddafaad7c598", 
"breadcrumbs" : "CODESYS Essentials \/ キーボードショートカット \/ ウィンドウズ™ ショートカット ", 
"snippet" : "Windows™ のキーボードショートカットは、一般的に以下によってサポートされています。 CODESYS 。 次のキーボードショートカットを使用して次の場所に移動します。 デバイス ビュー、 POU ビュー、ライブラリマネージャー (コンテンツ内)、タスク構成、入力アシスタント、クロスリファレンスリスト、 ビジュアライゼーションツールボックス ビュー、プロパティ、ビジュアライゼーションタグビュー、トレンドレコーディング、トレース設定、またはリポジトリ。 上記のビュー内のオブジェクトには、次のマークが付いています。 その下にさらにオブジェクトがある場合はシンボル。この時点でビューを拡大できます...", 
"body" : "Windows™ のキーボードショートカットは、一般的に以下によってサポートされています。 CODESYS 。 次のキーボードショートカットを使用して次の場所に移動します。 デバイス ビュー、 POU ビュー、ライブラリマネージャー (コンテンツ内)、タスク構成、入力アシスタント、クロスリファレンスリスト、 ビジュアライゼーションツールボックス ビュー、プロパティ、ビジュアライゼーションタグビュー、トレンドレコーディング、トレース設定、またはリポジトリ。 上記のビュー内のオブジェクトには、次のマークが付いています。 その下にさらにオブジェクトがある場合はシンボル。この時点でビューを拡大できます。オブジェクトには、というマークが付いています。 その下にオブジェクトがなくなるとシンボルが表示されます。ビューが完全に拡大されます。 ナビゲーションに便利な Windows ショートカット キーボードエリア キー プロシージャ エフェクト テンキーパッド * ツリービューで、とマークされたエントリを選択します。 シンボル。次に、を押します。 * キー。 ツリービューで選択したオブジェクトまたはフォルダの下にあるすべてのものが展開されます。 テンキーパッド 矢印キー + → ツリービューで、とマークされたエントリを選択します。 シンボル。次に、を押します。 + または → キー。 ノードには、次のマークが付きます。 シンボル。 オブジェクトまたはフォルダが展開されます。 テンキーパッド - ツリービューで、とマークされたエントリを選択します。 シンボル。次に、を押します。 - キー。 フォルダまたはエレメントが折りたたまれています。 テンキーパッド 矢印キー \/ ← ツリービューで、とマークされたエントリを選択します。 シンボル。次に、を押します。 \/ または ← キー。 選択したオブジェクトまたはフォルダの下にあるものはすべて折りたたまれています。 矢印キー ↓ ツリービューで、ノードを選択します。次に、を押します。 ↓ キー。 選択範囲が下に移動します。 矢印キー ↑ ツリービューで、ノードを選択します。次に、を押します。 ↑ キー。 選択範囲が上に移動します。 テンキーパッドのキーでショートカットを使用するときは、テンキーが有効になっていることを確認してください。 ズーム キーボードエリア ショートカット エフェクト テンキーパッド (テンキー) Ctrl + + [ズームイン] テンキーパッド (テンキー) Ctrl + - [ズームアウト] " }, 
{ "title" : "フィールドバスサポート ", 
"url" : "f_device_editors.html", 
"breadcrumbs" : "CODESYS Essentials \/ フィールドバスサポート ", 
"snippet" : "CODESYS 一般的なフィールドバスタイプへのリンクをサポートします。 デバイスの使用に関する一般的な情報については、以下を参照してください。 デバイスツリーとデバイスエディタ特定のフィールドバスタイプでのデバイスの使用に関する特別な情報については、その特定のフィールドバスタイプに関するヘルプを参照してください。 Hilscher GmbH（それぞれのIECライブラリを使用）によるcifXカードを使用する場合、 CODESYS 構成ファイル（ .cfg ）次のエントリで拡張する必要があります。 Component. <next free number> =CmpHilscherCIFX...", 
"body" : "CODESYS 一般的なフィールドバスタイプへのリンクをサポートします。 デバイスの使用に関する一般的な情報については、以下を参照してください。 デバイスツリーとデバイスエディタ特定のフィールドバスタイプでのデバイスの使用に関する特別な情報については、その特定のフィールドバスタイプに関するヘルプを参照してください。 Hilscher GmbH（それぞれのIECライブラリを使用）によるcifXカードを使用する場合、 CODESYS 構成ファイル（ .cfg ）次のエントリで拡張する必要があります。\n Component. <next free number> =CmpHilscherCIFX " }, 
{ "title" : "デバイス診断 ", 
"url" : "_cds_device_diagnosis.html", 
"breadcrumbs" : "CODESYS Essentials \/ フィールドバスサポート \/ デバイス診断 ", 
"snippet" : "CODESYS 接続されたデバイスで診断を実行するための一般的およびフィールドバス固有の機能ブロックを提供します。 バス固有の診断 バス固有の診断オプションについては、個々のフィールドバスの診断の章を参照してください。 詳細については、以下を参照してください。 PROFINET診断 CANbus診断 EtherCAT診断...", 
"body" : "CODESYS 接続されたデバイスで診断を実行するための一般的およびフィールドバス固有の機能ブロックを提供します。 バス固有の診断 バス固有の診断オプションについては、個々のフィールドバスの診断の章を参照してください。 詳細については、以下を参照してください。 PROFINET診断 CANbus診断 EtherCAT診断 " }, 
{ "title" : "一般的な診断 ", 
"url" : "_cds_device_diagnosis.html#UUID-72f58fb2-a1cc-a2fd-a40b-f4a3fa8ca139_id_daf5ed59161447ec0a864634c91a40a_id_6d82803d91777a29c0a864635f481699", 
"breadcrumbs" : "CODESYS Essentials \/ フィールドバスサポート \/ デバイス診断 \/ 一般的な診断 ", 
"snippet" : "フィールドバスに関係なく、デバイスの診断を実行できます。関数はからブロックします CAA Device Diagnosis この目的のためにライブラリが提供されています。 これらの機能ブロックを操作する前に、 デバイスの診断を有効にする PLC設定のオプション。これは〜をひき起こす CODESYS 診断機能ブロックのインスタンスを自動的に作成します。これらの機能ブロックは、診断に使用できます。 診断機能ブロックの自動生成されたインスタンスのみを操作します。独自のインスタンスを作成しないでください。 詳細については、以下を参照してください。 タブ：PLC設定ライブラリ：CAA DeviceDia...", 
"body" : "フィールドバスに関係なく、デバイスの診断を実行できます。関数はからブロックします CAA Device Diagnosis この目的のためにライブラリが提供されています。 これらの機能ブロックを操作する前に、 デバイスの診断を有効にする PLC設定のオプション。これは〜をひき起こす CODESYS 診断機能ブロックのインスタンスを自動的に作成します。これらの機能ブロックは、診断に使用できます。 診断機能ブロックの自動生成されたインスタンスのみを操作します。独自のインスタンスを作成しないでください。 詳細については、以下を参照してください。 タブ：PLC設定ライブラリ：CAA DeviceDiagnosis デバイスツリーとデバイスエディタ" }, 
{ "title" : "フィールドバスデバイスとI \/ Oドライバー ", 
"url" : "_cds_device_fieldbus_devices_io_driver.html", 
"breadcrumbs" : "CODESYS Essentials \/ フィールドバスサポート \/ フィールドバスデバイスとI \/ Oドライバー ", 
"snippet" : "デバイスツリーで構成されている各フィールドバスデバイスの技術的基礎は、I\/Oドライバです。 I \/ Oドライバーは、フィールドバススタック、IECアプリケーション、およびIDE間のリンクです。ドライバは、デバイス構成のデータからフィールドバススタックを構成します。診断を示し、IECアプリケーション用のAPIを提供し、I \/ Oマッピングを担当します（「I \/ Oマッピング」の章を参照）。 この章では、特定のバスシステムの詳細については説明せずに、I\/Oドライバデバイスの基本機能の概要を説明します。さらに、構成に関するいくつかの推奨事項が提供されています。 複数のI \/ Oドライバーとタスク（ト...", 
"body" : "デバイスツリーで構成されている各フィールドバスデバイスの技術的基礎は、I\/Oドライバです。 I \/ Oドライバーは、フィールドバススタック、IECアプリケーション、およびIDE間のリンクです。ドライバは、デバイス構成のデータからフィールドバススタックを構成します。診断を示し、IECアプリケーション用のAPIを提供し、I \/ Oマッピングを担当します（「I \/ Oマッピング」の章を参照）。 この章では、特定のバスシステムの詳細については説明せずに、I\/Oドライバデバイスの基本機能の概要を説明します。さらに、構成に関するいくつかの推奨事項が提供されています。 複数のI \/ Oドライバーとタスク（トラブルシューティング） 複数のタスクから、場合によっては複数のI \/ Oドライバーインスタンス間でI \/ Oデータに一貫してアクセスする必要がある場合、特定の状況下でバスとアプリケーションタスク間の望ましくない相互干渉が発生する可能性があります。 これは、たとえば、一般的なシステム負荷が高い場合、またはリアルタイムクリティカルフィールドバスシステムのI \/ Oデータが、同じタスクで低速でブロッキングしているローカルバスシステムのI \/ Oデータと一緒に使用される場合です。 。 したがって、特にリアルタイムで重要なフィールドバス（EtherCAT、Profinet、CAN）を使用した通信の予期しない干渉の場合、タスクの監視では、最初にサイクル時間の非常に大きなジッターまたは外れ値（平均と比較した最大値）を調べる必要があります。価値）。タスクリストには、さまざまなタスクでのI \/ Oデータの使用に関する詳細情報が記載されています。 1つの同じタスクで異なるバスシステムからのI \/ Oデータを使用することを回避したり、I \/ Oタスクの数を減らしたりすることができる場合があります。 詳細については、以下を参照してください。 タブ: タスクの展開" }, 
{ "title" : "バスサイクルタスク ", 
"url" : "_cds_device_fieldbus_devices_io_driver.html#UUID-0697b338-d922-83f2-5218-d9fb5943436b_id_cc679fb955dea19c0a86463511f6cb4_id_28c562449569c838c0a8646342ae39cb", 
"breadcrumbs" : "CODESYS Essentials \/ フィールドバスサポート \/ フィールドバスデバイスとI \/ Oドライバー \/ バスサイクルタスク ", 
"snippet" : "バスサイクルタスクは、I\/Oドライバが実行されるコンテキストでのIECタスクです。一部のI\/Oドライバーは、複数のタスクを使用します。通常、I \/ Oデータの転送に使用されるリアルタイムの重要なタスク（優先度が高い）と、診断の評価や非周期的なタスクの実行などのタスクのための優先度の低い別のタスクです。バスシステムサービス。 リアルタイムのクリティカルバスシステムでは、このバスタスクのコンテキストで、実行時間のためにバスクロックを中断する操作が実行されないようにする必要があります。 バスタスクは、I \/ OドライバーデバイスのI \/ Oマッピングダイアログで構成できます。親デバイスの設定はデフォ...", 
"body" : "バスサイクルタスクは、I\/Oドライバが実行されるコンテキストでのIECタスクです。一部のI\/Oドライバーは、複数のタスクを使用します。通常、I \/ Oデータの転送に使用されるリアルタイムの重要なタスク（優先度が高い）と、診断の評価や非周期的なタスクの実行などのタスクのための優先度の低い別のタスクです。バスシステムサービス。 リアルタイムのクリティカルバスシステムでは、このバスタスクのコンテキストで、実行時間のためにバスクロックを中断する操作が実行されないようにする必要があります。 バスタスクは、I \/ OドライバーデバイスのI \/ Oマッピングダイアログで構成できます。親デバイスの設定はデフォルトで継承されることに注意してください。このデバイスがPLCの場合、そのPLC設定がバスサイクルタスクに適用されます。 上記の設定が設定されていない場合は、サイクルタイムが最も短いタスクが使用されます。このようにして、非リアルタイムI \/ Oドライバーが、リアルタイムクリティカルドライバーのタスクコンテキストで意図せずに実行され、その通信が中断される可能性があります。これらの通信の問題を診断するには、タスクの監視を確認することをお勧めします。 詳細については、以下を参照してください。 タブ：PLC設定" }, 
{ "title" : "I \/ Oマッピング ", 
"url" : "_cds_device_fieldbus_devices_io_driver.html#UUID-0697b338-d922-83f2-5218-d9fb5943436b_id_cc679fb955dea19c0a86463511f6cb4_id_a15ed2aa9569c838c0a864637ae138e7", 
"breadcrumbs" : "CODESYS Essentials \/ フィールドバスサポート \/ フィールドバスデバイスとI \/ Oドライバー \/ I \/ Oマッピング ", 
"snippet" : "I \/ Oドライバーの重要な機能は、I\/Oイメージの更新です。これは、バスシステムのI \/ OデータをIECアプリケーションの変数にマッピングすることを意味します（その逆も同様です）。 入出力データは、バスシステムの内部メモリイメージから％Iおよび％Qアドレスに割り当てられたIEC変数への両方向のコピーおよび変換操作によって周期的にマッピングされます。 I \/ Oドライバーの場合、このI \/ Oマッピングにシンボリック名を使用するか、％Iおよび％Qアドレスへの「直接」アクセスを使用するかにかかわらず、内部的な違いはありません。アプリケーションの保守性のために、常に説明的な変数名を使用することを...", 
"body" : "I \/ Oドライバーの重要な機能は、I\/Oイメージの更新です。これは、バスシステムのI \/ OデータをIECアプリケーションの変数にマッピングすることを意味します（その逆も同様です）。 入出力データは、バスシステムの内部メモリイメージから％Iおよび％Qアドレスに割り当てられたIEC変数への両方向のコピーおよび変換操作によって周期的にマッピングされます。 I \/ Oドライバーの場合、このI \/ Oマッピングにシンボリック名を使用するか、％Iおよび％Qアドレスへの「直接」アクセスを使用するかにかかわらず、内部的な違いはありません。アプリケーションの保守性のために、常に説明的な変数名を使用することをお勧めします（例：「％IW117」アクセスの代わりに変数「TemperatureReactor」）。 I\/Oマッピングの更新は次のように設定できます。 常に変数を更新する （グローバルに PLC設定 または、I \/ Oマッピングダイアログのデバイスごとに個別に）： 無効： アプリケーションで使用されるI \/ Oデータのみがマップされます。 これにより、コピー操作を回避してパフォーマンスを向上させることができますが、I \/ OマッピングダイアログのI \/ Oデータが更新されない場合（値がグレー表示される場合）、混乱が生じる可能性があります。この設定は、開発が完了したアプリケーションに推奨されます。 有効1： すべてのデータが更新されます。 有効化2： このオプションを使用できるかどうかは、デバイスの説明によって異なります。 注意：特別な場合にのみ生産的に使用してください。 その結果、バスサイクルタスクがこのデータを読み書きし、アプリケーションコードが他のタスクで使用するため、一貫性のないI \/ Oデータが発生する可能性があります。 詳細については、以下を参照してください。 タブ：<デバイス名> I \/ Oマッピング" }, 
{ "title" : "I \/ Oデータの一貫性 ", 
"url" : "_cds_device_fieldbus_devices_io_driver.html#UUID-0697b338-d922-83f2-5218-d9fb5943436b_id_cc679fb955dea19c0a86463511f6cb4_id_8f4981b79569c838c0a8646301a3da14", 
"breadcrumbs" : "CODESYS Essentials \/ フィールドバスサポート \/ フィールドバスデバイスとI \/ Oドライバー \/ I \/ Oデータの一貫性 ", 
"snippet" : "プログラミングシステムにより、IECアプリケーションは並行して実行される複数のタスクを使用できます（視覚化、フィールドバス、その他のPOU用）。アプリケーションコードは、マップされたIEC変数を介して、これらのタスクのコンテキストから任意のI\/Oデータにアクセスできます。異なるタスクから1つの同じデータにアクセスすると、データの一貫性が失われたり破損したりする可能性があります（たとえば、書き込みアクセスの中断が原因）。 I \/ Oドライバーは、タスクサイクルを実行する各タスクに、使用されるすべてのI \/ Oデータの一貫したマッピング（いわばスナップショット）を提供することにより、データの一貫性...", 
"body" : "プログラミングシステムにより、IECアプリケーションは並行して実行される複数のタスクを使用できます（視覚化、フィールドバス、その他のPOU用）。アプリケーションコードは、マップされたIEC変数を介して、これらのタスクのコンテキストから任意のI\/Oデータにアクセスできます。異なるタスクから1つの同じデータにアクセスすると、データの一貫性が失われたり破損したりする可能性があります（たとえば、書き込みアクセスの中断が原因）。 I \/ Oドライバーは、タスクサイクルを実行する各タスクに、使用されるすべてのI \/ Oデータの一貫したマッピング（いわばスナップショット）を提供することにより、データの一貫性を確保します。 したがって、次の例のようなコードは問題を引き起こすことはありません:(「DIVbyZERO」に注意してください） IF(inputData <> 0) THEN \/\/ inputData is mapped to %I\n x := y \/ inputData; \/\/ This will never result in DIV_BY_ZERO Exception\nEND_IF \/\/ inputData is not updated by bus cycle during execution of POU とともに 常に変数を更新する オプションをに設定 有効2–常にバスサイクルタスク 、このメカニズムはオーバーライドされます。したがって、アプリケーションコードはこれを考慮に入れる必要があります。 " }, 
{ "title" : "サービス ", 
"url" : "_cds_device_fieldbus_devices_io_driver.html#UUID-0697b338-d922-83f2-5218-d9fb5943436b_id_cc679fb955dea19c0a86463511f6cb4_id_06856b5b9569c838c0a864632fe4dc2e", 
"breadcrumbs" : "CODESYS Essentials \/ フィールドバスサポート \/ フィールドバスデバイスとI \/ Oドライバー \/ サービス ", 
"snippet" : "一部のI \/ Oドライバは、基本的な機能に加えて、デバイススキャン機能やデバイスアドレスの設定など、IDEから呼び出すことができるサービスを提供します。...", 
"body" : "一部のI \/ Oドライバは、基本的な機能に加えて、デバイススキャン機能やデバイスアドレスの設定など、IDEから呼び出すことができるサービスを提供します。 " }, 
{ "title" : "一般的な推奨事項 ", 
"url" : "_cds_device_fieldbus_devices_io_driver.html#UUID-0697b338-d922-83f2-5218-d9fb5943436b_id_cc679fb955dea19c0a86463511f6cb4_id_597a65569569c838c0a864636c5a9a3d", 
"breadcrumbs" : "CODESYS Essentials \/ フィールドバスサポート \/ フィールドバスデバイスとI \/ Oドライバー \/ 一般的な推奨事項 ", 
"snippet" : "設定： PLC設定 ： 停止中のI \/ O更新： バスサイクルは、アプリケーションがデバッグブレークポイントにある場合など、アプリケーションが停止している場合でも継続します。このようにして、フィールドデバイスとの通信が維持され、中断することなくすぐに継続できます。 PLC設定 ： 常に変数を更新する に設定されています 有効1-どのタスクでも使用されていない場合はバスサイクルタスクを使用 ： アプリケーションの開発中に、すべてのI \/ Oデータの値を確認すると便利です。 タスク構成： 特に、正確な送受信クロックの維持に依存するProfinet、EtherCAT、CANなどのリアルタイムの重要な...", 
"body" : "設定： PLC設定 ： 停止中のI \/ O更新： バスサイクルは、アプリケーションがデバッグブレークポイントにある場合など、アプリケーションが停止している場合でも継続します。このようにして、フィールドデバイスとの通信が維持され、中断することなくすぐに継続できます。 PLC設定 ： 常に変数を更新する に設定されています 有効1-どのタスクでも使用されていない場合はバスサイクルタスクを使用 ： アプリケーションの開発中に、すべてのI \/ Oデータの値を確認すると便利です。 タスク構成： 特に、正確な送受信クロックの維持に依存するProfinet、EtherCAT、CANなどのリアルタイムの重要なフィールドバスシステムでは、優先度の高い別のバスサイクルタスクを使用することをお勧めします。リアルタイムの重要度が低いタスク（視覚化など）の場合は、バスサイクルタスクよりも大幅に低い優先度を選択する必要があります。 可能な限り少ないオフセットで最大のI \/ Oスループットを達成するために、フィールドバスシステムのバスタスクで個別のPOUを実行できます。ただし、これらはリアルタイムの要件を満たす必要があります。たとえば、ファイルアクセスやブロッキングソケット機能は実行できませんが、たとえば出力データの計算のみが実行できます。 " }, 
{ "title" : "バスサイクルタスク ", 
"url" : "_cds_buscycle_task.html", 
"breadcrumbs" : "CODESYS Essentials \/ フィールドバスサポート \/ バスサイクルタスク ", 
"snippet" : "一般に、各IECタスクについて、使用された入力データは各タスクの開始時に読み取られ（1）、書き込まれた出力データはタスクの終了時にI \/ Oドライバーに転送されます（3）。 I \/ Oドライバでの実装は、I \/ Oデータの追加転送にとって決定的です。対応するバスシステムへの実際の転送が発生する時間枠と時点を担当します。 PLCのバスサイクルタスクは、PLC設定のすべてのフィールドバスに対してグローバルに定義できます。ただし、一部のフィールドバスでは、グローバル設定とは関係なくこれを変更できます。サイクルタイムが最も短いタスクがバスサイクルタスクとして使用されます（設定： 不特定 PLC設定で）...", 
"body" : "一般に、各IECタスクについて、使用された入力データは各タスクの開始時に読み取られ（1）、書き込まれた出力データはタスクの終了時にI \/ Oドライバーに転送されます（3）。 I \/ Oドライバでの実装は、I \/ Oデータの追加転送にとって決定的です。対応するバスシステムへの実際の転送が発生する時間枠と時点を担当します。 PLCのバスサイクルタスクは、PLC設定のすべてのフィールドバスに対してグローバルに定義できます。ただし、一部のフィールドバスでは、グローバル設定とは関係なくこれを変更できます。サイクルタイムが最も短いタスクがバスサイクルタスクとして使用されます（設定： 不特定 PLC設定で）。メッセージは通常、このタスクではバス上で送信されます。 他のタスクは、バスサイクルタスクで物理ハードウェアとのみ交換される内部バッファからI \/ Oデータのみをコピーします。 （1）入力バッファから入力を読み取ります （2）IECタスク (3) 出力バッファへの出力の書き込み （4）バスサイクル （5）入力バッファ （6）出力バッファ （7）バスとの間でデータをコピーする （9）バスサイクルタスク、優先度1、1ミリ秒 （10）バスサイクルタスク、優先度5 （11）バスサイクルタスク、優先度10、タスク5によって中断されました タスクの使用法 The タスクの展開 タブには、使用されているI \/ Oチャネル、バスサイクルの設定タスク、およびチャネルの使用法の概要が表示されます。 出力がさまざまなタスクで書き込まれる場合、ステータスは未定義です。これは、いずれの場合も上書きされる可能性があるためです。 さまざまなタスクで同じ入力が使用されている場合、タスクの処理中に入力が変更される可能性があります。これは、優先度の高いタスクによってタスクが中断され、プロセスイメージが再度読み込まれる場合に起こります。対処法:IEC タスクの開始時に、入力変数を変数にコピーし、残りのコードではローカル変数のみを操作してください 結論：いくつかのタスクで同じ入力と出力を使用しても意味がなく、場合によっては予期しない反応が発生する可能性があります。 詳細については、以下を参照してください。 タスク構成バスサイクルタスク付き CANopen マネージャー でのバスサイクルタスク EtherCAT でのバスサイクルタスク Sercos でのバスサイクルタスク EtherNet\/IP でのバスサイクルタスク PROFIBUS " }, 
{ "title" : "I\/Oチャネルへのシンボリックアクセス ", 
"url" : "_cds_symbolic_access_io_channels.html", 
"breadcrumbs" : "CODESYS Essentials \/ フィールドバスサポート \/ I\/Oチャネルへのシンボリックアクセス ", 
"snippet" : "デバイスごとおよびチャネルごとに手動でマッピングをアクティブに設定しなくても、特別に生成された機能ブロックを使用して、デバイスのI\/Oチャネルに直接アクセスできます。 自動生成 入力と出力は、I\/Oチャネルの名前で機能ブロックに結合されます。可能であれば、デバイスの説明で定義されている基本ブロックが拡張されます。 チャネル名は、のデバイスエディタで指定されている名前に対応しています。 I\/Oマッピング \"のタブ チャネル \" 桁。 この方法で作成された入力変数と出力変数は、入力アシスタントにも表示されます。 I \/ Oチャネルが構造化または列挙されている場合、それらの機能ブロックもそれに応じて...", 
"body" : "デバイスごとおよびチャネルごとに手動でマッピングをアクティブに設定しなくても、特別に生成された機能ブロックを使用して、デバイスのI\/Oチャネルに直接アクセスできます。 自動生成 入力と出力は、I\/Oチャネルの名前で機能ブロックに結合されます。可能であれば、デバイスの説明で定義されている基本ブロックが拡張されます。 チャネル名は、のデバイスエディタで指定されている名前に対応しています。 I\/Oマッピング \"のタブ チャネル \" 桁。 この方法で作成された入力変数と出力変数は、入力アシスタントにも表示されます。 I \/ Oチャネルが構造化または列挙されている場合、それらの機能ブロックもそれに応じて構造化されます。そのため、生成された機能ブロックには、構造化された入力と出力または列挙が含まれます。 同じ名前のチャンネルの場合、接尾辞 _<X> 機能ブロックの入力または出力に追加されます。 デバイスに独自のI\/Oチャネルがない場合（例：EK1100スレーブ）、機能ブロックは作成されません。 " }, 
{ "title" : "自動マッピングを有効にする ", 
"url" : "_cds_symbolic_access_io_channels.html#UUID-0a064dd1-3562-5c32-2219-21a759dad045_section-idm4536908457891232946602093636", 
"breadcrumbs" : "CODESYS Essentials \/ フィールドバスサポート \/ I\/Oチャネルへのシンボリックアクセス \/ 自動マッピングを有効にする ", 
"snippet" : "の中に デバイス 表示して、一番上のデバイスを開きます。デバイスエディタで、 PLC設定 タブ。 下 追加の設定 、 そこには I\/Oのシンボリックアクセスを有効にする オプション。 チェックボックスを選択します 。 生成された機能ブロックインスタンスは、 IECオブジェクト デバイスのタブ。 I \/ Oチャネルごとに、（通常は拡張された）機能ブロックが自動的に作成され、インスタンス化されるようになりました。これにより、すぐに直接アクセスできます。機能ブロックの変数を使用して、I\/Oチャネルにアクセスすることができます。 例： EtherCAT Slave 新しい機能ブロックは、既存の機能ブロ...", 
"body" : "の中に デバイス 表示して、一番上のデバイスを開きます。デバイスエディタで、 PLC設定 タブ。 下 追加の設定 、 そこには I\/Oのシンボリックアクセスを有効にする オプション。 チェックボックスを選択します 。 生成された機能ブロックインスタンスは、 IECオブジェクト デバイスのタブ。 I \/ Oチャネルごとに、（通常は拡張された）機能ブロックが自動的に作成され、インスタンス化されるようになりました。これにより、すぐに直接アクセスできます。機能ブロックの変数を使用して、I\/Oチャネルにアクセスすることができます。 例： EtherCAT Slave 新しい機能ブロックは、既存の機能ブロックを拡張します。 The EL1008 機能ブロックインスタンスは、以下のデバイスエディタに一覧表示されます。 EtherCATIECオブジェクト タブ。 The DrvEthercatLib.ETCSlave_Diag 機能ブロックはに拡張されます EL1008_FB 出力変数を取得します Input_<n> 。 ファンクションブロック： EL1008_FB 例：基本ブロックが定義されていないデバイス 拡張可能なデバイス記述に機能ブロックが定義されていない場合、新しい機能ブロックが生成されます。たとえば、 Generic_XN1AI 機能ブロックインスタンスは、以下のデバイスエディタに一覧表示されます。 IECオブジェクト タブ。 新しい機能ブロック： Generic_XN_1AI_F 例：CANopen The BK5120_FB 既存の機能ブロックを拡張する機能ブロック _3SCOS.CANRemoteDevice デバイスの説明に従って機能ブロックが生成されます。 The BK5120 機能ブロックインスタンスは、のデバイスエディタに一覧表示されます CANopenIECオブジェクト タブ。 ファンクションブロック： BK5120_FB " }, 
{ "title" : "オンラインモード ", 
"url" : "_cds_symbolic_access_io_channels.html#UUID-0a064dd1-3562-5c32-2219-21a759dad045_section-idm4536908379939232946873025889", 
"breadcrumbs" : "CODESYS Essentials \/ フィールドバスサポート \/ I\/Oチャネルへのシンボリックアクセス \/ オンラインモード ", 
"snippet" : "オンラインモードでは、既存の機能を使用してデータが更新されます。ただし、実際に使用される生成変数のみが更新されます。または、 常に変数を更新する オプションが有効になっています。 チャネルがシンボリックに同時にI\/Oマッピングを介してアクセスされる場合、コンパイラ警告が発行されます。...", 
"body" : "オンラインモードでは、既存の機能を使用してデータが更新されます。ただし、実際に使用される生成変数のみが更新されます。または、 常に変数を更新する オプションが有効になっています。 チャネルがシンボリックに同時にI\/Oマッピングを介してアクセスされる場合、コンパイラ警告が発行されます。 " }, 
{ "title" : "ライブラリ ", 
"url" : "f_libraries.html", 
"breadcrumbs" : "CODESYS Essentials \/ ライブラリ ", 
"snippet" : "ライブラリは、アプリケーションで使用するPOUと関数を準備するために使用されます。ここにヘルプで示されている説明に加えて、ライブラリに含まれているドキュメントも常に参照してください。 プロジェクトでライブラリを使用する方法については、以下を参照してください。 ライブラリの使用自分でライブラリを使用してビルドする場合は、必ず注意してください。 ライブラリ開発者ガイドライン 。...", 
"body" : "ライブラリは、アプリケーションで使用するPOUと関数を準備するために使用されます。ここにヘルプで示されている説明に加えて、ライブラリに含まれているドキュメントも常に参照してください。 プロジェクトでライブラリを使用する方法については、以下を参照してください。 ライブラリの使用自分でライブラリを使用してビルドする場合は、必ず注意してください。 ライブラリ開発者ガイドライン 。 " }, 
{ "title" : "ライブラリ作成のガイドライン ", 
"url" : "_cds_guidelines_for_creating_libraries.html", 
"breadcrumbs" : "CODESYS Essentials \/ ライブラリ \/ ライブラリ作成のガイドライン ", 
"snippet" : "ライブラリ 互換性の問題を回避するために、特定のルールに従って作成する必要があります。 主な項目は次のとおりです。 意味のあるライブラリ名を選択してください（必須） テンプレートを使用して一貫性を確保する（オプション） 可能な場合は、使い慣れた統一されたプロジェクト構造を使用します（オプション） 一意のライブラリ名前空間を登録する（必須） すべてのプロジェクト情報を入力してください（必須） 他のライブラリを正しく参照するための正しい方法を適用する（必須） スマートな外部および内部インターフェースの設計（必須） ユーザーフレンドリーなエラー管理を実装する（必須） 展開に正しい方法（保護）を適用す...", 
"body" : "ライブラリ 互換性の問題を回避するために、特定のルールに従って作成する必要があります。 主な項目は次のとおりです。 意味のあるライブラリ名を選択してください（必須） テンプレートを使用して一貫性を確保する（オプション） 可能な場合は、使い慣れた統一されたプロジェクト構造を使用します（オプション） 一意のライブラリ名前空間を登録する（必須） すべてのプロジェクト情報を入力してください（必須） 他のライブラリを正しく参照するための正しい方法を適用する（必須） スマートな外部および内部インターフェースの設計（必須） ユーザーフレンドリーなエラー管理を実装する（必須） 展開に正しい方法（保護）を適用する（必須） 一貫した命名規則を適用して、クリーンなコードを取得します（オプション） 既存のライブラリを改訂するときは、以前のバージョンとのインターフェースの互換性を考慮してください。 でライブラリを開発するときは、これらのガイドラインに従ってください CODESYS ：「ライブラリ開発の概要」。 " }, 
{ "title" : "このヘルプリクエストのヘルプページはありません。 ", 
"url" : "_cds_f_development_system_introduction.html", 
"breadcrumbs" : "CODESYS Essentials \/ このヘルプリクエストのヘルプページはありません。 ", 
"snippet" : "ヘルプポータルのスタートページに移動するには、ここをクリックしてください。...", 
"body" : "ヘルプポータルのスタートページに移動するには、ここをクリックしてください。 " }
]
$(document).trigger('search.ready');
});