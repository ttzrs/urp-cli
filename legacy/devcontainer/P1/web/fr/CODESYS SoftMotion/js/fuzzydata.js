$(document).ready(function () {indexDict['fr'] = [{ "title" : "CODESYS SoftMotion ", 
"url" : "_sm_start_page.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion ", 
"snippet" : "Avec CODESYS SoftMotion , vous pouvez créer efficacement des mouvements API. Cela va des simples mouvements monoaxes ou cames aux mouvements complexes dans plusieurs dimensions. En particulier, les applications qui incluent le contrôle de flux et le contrôle de processus en plus de la fonctionnalité...", 
"body" : "Avec CODESYS SoftMotion , vous pouvez créer efficacement des mouvements API. Cela va des simples mouvements monoaxes ou cames aux mouvements complexes dans plusieurs dimensions. En particulier, les applications qui incluent le contrôle de flux et le contrôle de processus en plus de la fonctionnalité de mouvement font partie du champ d'application du CODESYS SoftMotion . Vous pouvez télécharger le CODESYS SoftMotion du  CODESYS Store International ou la  CODESYS Store North America . Vous y trouverez également la fiche technique du produit. Voir également CODESYS SoftMotion dans le Forum CODESYS " }, 
{ "title" : "Licence ", 
"url" : "_sm_licensing.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Licence ", 
"snippet" : "En plus du général métriques des logiciels sous licence , les métriques sont définies pour CODESYS SoftMotion qui sont vérifiés lors du téléchargement. Le SoftMotion les mesures sont calculées lors de la compilation et la valeur actuelle n'est affichée dans l'éditeur qu'après. Les valeurs déterminée...", 
"body" : "En plus du général métriques des logiciels sous licence , les métriques sont définies pour CODESYS SoftMotion qui sont vérifiés lors du téléchargement. Le SoftMotion les mesures sont calculées lors de la compilation et la valeur actuelle n'est affichée dans l'éditeur qu'après. Les valeurs déterminées se réfèrent à une application. Lorsque plusieurs applications existent, les valeurs des applications individuelles sont additionnées. Groupe Métrique Valeur déterminée Nombre d'axes Axes réels La valeur de la métrique est définie par la plus grande valeur des axes réels et des axes virtuels utilisés. Exemple : Avec 3 axes réels et 4 axes virtuels, la valeur dans l'application = 4. Axes virtuels Nombre de groupes d'axes et interpolateurs CNC Groupes d'axes La valeur de la métrique est définie par la somme des groupes d'axes et des interpolateurs CNC. Exemple : Avec 2 groupes d'axes et 2 interpolateurs CNC, la valeur dans l'application = 4. Interpolateurs CNC " }, 
{ "title" : "Composants de CODESYS SoftMotion ", 
"url" : "_sm_components.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Composants de CODESYS SoftMotion ", 
"snippet" : "CODESYS SoftMotion est un progiciel utilisé comme environnement de développement et d'exécution pour le contrôle de mouvement. Il est décrit comme suit : Configuration du lecteur : La configuration du variateur fournit un éditeur qui vous permet de définir la structure et la configuration du matérie...", 
"body" : "CODESYS SoftMotion est un progiciel utilisé comme environnement de développement et d'exécution pour le contrôle de mouvement. Il est décrit comme suit : Configuration du lecteur : La configuration du variateur fournit un éditeur qui vous permet de définir la structure et la configuration du matériel du variateur à l'aide des CODESYS interface utilisateur. A ce stade, une instance d'un bloc fonctionnel CEI est créée pour représenter le variateur. Ce bloc fonctionnel communique automatiquement avec les variateurs sans effort supplémentaire de la part du programmeur CEI. Il est responsable de la transmission des données mises à jour. Pour piloter les variateurs, le programme CEI peut adresser un variateur au moyen des blocs fonction du SoftMotion bibliothèques. Alternativement, vous pouvez également développer vos propres blocs fonctionnels à cette fin. Les valeurs de consigne (pour la position, la vitesse, l'accélération, etc.) sont écrites cycliquement par ces blocs fonction. Noter la CODESYS SoftMotion Light produit fait partie de l'installation standard de CODESYS . Il permet de commander les axes. De cette façon, CODESYS définit uniquement la position cible uniquement et attend la réponse du contrôleur d'axe. Le contrôleur d'axe est responsable de la planification du mouvement. Un mouvement coordonné de plusieurs axes par CODESYS n'est pas possible. Éditeur de cames : Dans l'éditeur de cames, vous pouvez décrire une came graphiquement ou au moyen de tableaux. CODESYS génère à partir de là une instance globale d'une structure de données qui décrit la came. Celui-ci est transmis à l'application où les POU applicables peuvent y accéder. Editeur CNC : Dans l'éditeur CNC, vous pouvez générer des mouvements multidimensionnels. Vous pouvez créer la trajectoire CNC avec un éditeur de texte (selon DIN 66025) ou avec un éditeur graphique. Comme alternative à l'éditeur de texte, vous pouvez également travailler dans une vue tabulaire simplifiée. Configuration du groupe d'axes : Un groupe d'axes définit les relations entre plusieurs axes mécaniquement dépendants qui positionnent et orientent collectivement un outil ou une plaque d'outil dans l'espace. Avec le configurateur, vous sélectionnez et configurez la cinématique à utiliser. De plus, vous pouvez affecter les axes SoftMotion. le SM3_Basic la bibliothèque est une bibliothèque de base pour tous SoftMotion applications. Plus précisément, il contient les éléments suivants : Blocs fonction PLCopen selon la norme PLCopen Ces blocs fonction permettent de piloter des mouvements monoaxes ou des mouvements maître\/esclave de deux axes (came électrique, entraînements électriques). FB supplémentaires non couverts par les fonctionnalités PLCopen Fonctions d'aide : par exemple pour la gestion des fichiers ou pour les messages d'erreur le SM3_CNC bibliothèque est basée sur SM3_Basic bibliothèque. En plus des blocs fonctionnels pour les transformations cinématiques, il fournit tous les POU nécessaires pour générer, exécuter et afficher le mouvement CNC. Il fournit également des blocs fonctionnels pour le prétraitement et la reconstruction de chemin. le SM3_Robotics contient des blocs fonctionnels selon PLCopen Part 4 pour la robotique et des blocs fonctionnels supplémentaires. Le inclus SM3_Transformations bibliothèque contient les transformations cinématiques prises en charge. le Interface d'entraînement fait partie de la SM3_Basic bibliothèque et est responsable de la communication entre le programme CEI et les variateurs. Pour les lecteurs pris en charge, CODESYS SoftMotion fournit des bibliothèques qui implémentent cette interface de lecteur. Voir également les descriptions des exemples d'application. " }, 
{ "title" : "Utilisation des contrôleurs CODESYS RTE V3 et CODESYS WIN V3 ", 
"url" : "_sm_rtev3_winv3.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Utilisation des contrôleurs CODESYS RTE V3 et CODESYS WIN V3 ", 
"snippet" : "Dans CODESYS Development System SP20 et versions supérieures, le SoftMotion contrôleurs CODESYS SoftMotion RTE V3 et CODESYS SoftMotion Win V3 n'est plus disponible. La norme CODESYS Control RTE V3 et CODESYS Control Win Les contrôleurs V3 sont désormais utilisés. Commande : Activer la commande est ...", 
"body" : "Dans CODESYS Development System SP20 et versions supérieures, le SoftMotion contrôleurs CODESYS SoftMotion RTE V3 et CODESYS SoftMotion Win V3 n'est plus disponible. La norme CODESYS Control RTE V3 et CODESYS Control Win Les contrôleurs V3 sont désormais utilisés. Commande : Activer la commande est utilisée pour convertir le contrôleur standard en SoftMotion contrôleur. " }, 
{ "title" : "SoftMotion avec des processeurs multicœurs ", 
"url" : "_sm_multicore_hint.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ SoftMotion avec des processeurs multicœurs ", 
"snippet" : "En répartissant les tâches de mouvement sur plusieurs cœurs de processeur, davantage d'axes ou de groupes d'axes peuvent être actionnés par SoftMotion . Par conséquent, les tâches gourmandes en ressources de calcul, telles que le prétraitement des trajectoires CNC ou la planification des trajectoire...", 
"body" : "En répartissant les tâches de mouvement sur plusieurs cœurs de processeur, davantage d'axes ou de groupes d'axes peuvent être actionnés par SoftMotion . Par conséquent, les tâches gourmandes en ressources de calcul, telles que le prétraitement des trajectoires CNC ou la planification des trajectoires robotiques pour les mouvements CP, peuvent être transférées vers un autre cœur de processeur. Ensuite, il y a plus de temps pour d'autres tâches dans la tâche de bus. Le fait que la puissance de calcul du contrôleur monocœur soit insuffisante est démontré dans le cas de la robotique par la diminution inexplicable de la vitesse du trajet. Configuration requise SM V4.5.1.0 ou supérieur Compilateur V3.5.12.0 ou supérieur Système d'exécution compatible multicœur Usage Robotique et CNC : définissez les tâches de planification et de bus sur différents cœurs de processeur Lorsque vous utilisez différents systèmes de bus, définissez les tâches de bus individuelles sur différents cœurs de processeur Lorsque vous utilisez plusieurs tâches et plusieurs cœurs de processeur, notez les points suivants : Les blocs fonctionnels de la tâche de planification CNC sont autorisés à obtenir un nouvel avantage au Execute entrée uniquement dans des états spécifiques de l'interpolateur ( iStatus sortie). Cela vaut également pour le monocœur IPO_UNKNOWN IPO_WAIT IPO_FINISHED IPO_INIT (pour le premier démarrage uniquement, pas pour le redémarrage) Les tâches de bus d'axes interdépendants (groupe d'axes, came et cinématique CNC) doivent s'exécuter sur le même cœur de processeur. " }, 
{ "title" : "CODESYS SoftMotion Drives ", 
"url" : "_sm_f_drive_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Configuration du lecteur SoftMotion ", 
"url" : "_sm_f_drive_configuration.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuration du lecteur SoftMotion ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Aperçu ", 
"url" : "_sm_overview_drive_configuration.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuration du lecteur SoftMotion \/ Aperçu ", 
"snippet" : "L'interface du variateur SoftMotion est une interface standardisée que vous utilisez pour relier, configurer et adresser le matériel du variateur au sein d'un programme CEI. En mappant différents matériels sur une seule interface, vous pouvez facilement échanger des disques et réutiliser des program...", 
"body" : "L'interface du variateur SoftMotion est une interface standardisée que vous utilisez pour relier, configurer et adresser le matériel du variateur au sein d'un programme CEI. En mappant différents matériels sur une seule interface, vous pouvez facilement échanger des disques et réutiliser des programmes CEI. L'interface couple les variateurs au mappage E\/S et est responsable de la mise à jour et de la transmission des données de mouvement requises au contrôle du variateur. L'interface du lecteur se compose des composants suivants : Description de l'appareil du SoftMotion appareils à leur représentation dans l'arborescence des appareils Bibliothèques référencées dans la description de l'appareil qui étendent ou surchargent les blocs fonctionnels de base de AXIS_REF_SM3 selon les exigences des types d'entraînement spécifiques Bibliothèques contenant les blocs fonctionnels pour la lecture et l'écriture acycliques de données pour envelopper les fonctions standard du pilote de bus de terrain Si vous utilisez un SoftMotion PLC, tel que CODESYS SoftMotion Win , les bibliothèques de base sont automatiquement liées dans le gestionnaire de bibliothèques. Ces types de contrôleurs fournissent un Pool d'axes généraux SoftMotion . C'est ici que vous pouvez insérer des unités de disque libres. " }, 
{ "title" : "Unités d'entraînement couplées ", 
"url" : "_sm_inserting_connected_drive_devices.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuration du lecteur SoftMotion \/ Unités d'entraînement couplées ", 
"snippet" : "Les entraînements couplés appartiennent à un appareil qui représente l'entraînement dans la topologie du bus de terrain. Les symboles de ces variateurs comportent une petite marque indiquant le type de bus de terrain correspondant. Par exemple, chaque servo variateur standard est connecté au contrôl...", 
"body" : "Les entraînements couplés appartiennent à un appareil qui représente l'entraînement dans la topologie du bus de terrain. Les symboles de ces variateurs comportent une petite marque indiquant le type de bus de terrain correspondant. Par exemple, chaque servo variateur standard est connecté au contrôleur par un bus de terrain. Lors de l'utilisation de lecteurs, CODESYS SoftMotion fournit des descriptions d'appareils spécifiques pour le maître de bus de terrain (suffixe \"_SoftMotion\"). Ceux-ci ont des paramètres de base optimisés pour l'entraînement. Pour les lecteurs utilisés avec CODESYS SoftMotion , la gestion modulo doit être désactivée dans le variateur. La gestion modulo est effectuée par CODESYS SoftMotion dans le contrôleur. Si possible, la plage de déplacement maximale doit être définie sur 32 bits. Ajout d'un dispositif d'entraînement couplé (EtherCAT) Condition : un contrôleur compatible SoftMotion est inséré dans le projet. Sélectionnez le SoftMotion contrôleur dans l'arborescence des appareils. Dans le menu contextuel, cliquez sur Ajouter un appareil . Dans le Ajouter un appareil boîte de dialogue, sélectionnez le Bus de terrain → EtherCAT → Maître → EtherCAT Maître SoftMotion appareil. Clique le Ajouter un appareil bouton. L'appareil est ajouté à l'arborescence des appareils. le Ajouter un appareil la boîte de dialogue reste ouverte. Sélectionnez l'appareil que vous venez d'ajouter à l'arborescence des appareils. Dans le Ajouter un appareil boîte de dialogue, sélectionnez un esclave SoftMotion ( Bus de terrain → EtherCAT → Esclave → <Variateur SoftMotion> ). Clique le Ajouter un appareil bouton. L'appareil est ajouté à l'arborescence des appareils. Un double-clic sur l'appareil ouvre l'éditeur d'appareil correspondant. " }, 
{ "title" : "Axe de l'encodeur ", 
"url" : "_sm_encoder_drive_devices.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuration du lecteur SoftMotion \/ Axe de l'encodeur ", 
"snippet" : "Les axes de l'encodeur sont utilisés pour convertir les valeurs de l'encodeur en un axe SoftMotion qui peut être utilisé comme axe principal pour MC_CamIn , MC_GearIn , et d'autres blocs de fonctions maître\/esclave. Les axes des codeurs peuvent représenter des codeurs supplémentaires provenant des u...", 
"body" : "Les axes de l'encodeur sont utilisés pour convertir les valeurs de l'encodeur en un axe SoftMotion qui peut être utilisé comme axe principal pour MC_CamIn , MC_GearIn , et d'autres blocs de fonctions maître\/esclave. Les axes des codeurs peuvent représenter des codeurs supplémentaires provenant des unités d'entraînement. Dans ce cas, ils sont configurés en tant qu'axes de codage spéciaux sous les appareils de bus de terrain dans l'arborescence des appareils. Vous pouvez également utiliser des encodeurs gratuits dans Pool General Axis pourrait également utiliser des entrées analogiques comme axes d'encodeur. Pour plus d'informations, voir : Encodeur gratuitPropriétés Tout comme les axes logiques, les axes du codeur sont en « lecture seule ». Ils fournissent uniquement les valeurs de position et de vitesse. Aucun mouvement ne peut être commandé sur eux. L'état des axes du codeur est toujours standstill . C'est l'état de PLCopen pour Motion Control Part 1 qui correspond le mieux. Selon l'organigramme, cet état signifie que l'axe est prêt et qu'il n'y a pas d'erreur. De plus, aucun des mouvements commandés par le PLC n'est actif sur l'axe. Notez qu'avant CODESYS SoftMotion version 4.18.0.0 les axes de l'encodeur étaient dans l'état power_off . Toutefois, lorsque MC_Power a été appelé pour eux, ils étaient dans un état standstill . La position zéro de l'axe du codeur peut être décalée avec MC_SetPosition . Les blocs de fonctions maître\/esclave utilisent toujours les valeurs réelles de l'axe du codeur. Un axe logique situé en dessous de l'axe du codeur peut être utilisé pour la compensation des temps morts. Lorsque vous utilisez des axes d'encodeur, il n'est pas nécessaire d'appeler MC_Power , et cela n'a aucune incidence sur le comportement de l'axe du codeur pour CODESYS SoftMotion version 4.18.0.0 et supérieure. " }, 
{ "title" : "Insertion d'unités d'entraînement libres ", 
"url" : "_sm_f_free_drive_devices.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuration du lecteur SoftMotion \/ Insertion d'unités d'entraînement libres ", 
"snippet" : "Les unités d'entraînement libres ne sont pas couplées de manière permanente avec d'autres appareils dans l'arborescence des appareils. Ils sont insérés dans l'arborescence des appareils ci-dessous SoftMotion Pool d'entraînement général ....", 
"body" : "Les unités d'entraînement libres ne sont pas couplées de manière permanente avec d'autres appareils dans l'arborescence des appareils. Ils sont insérés dans l'arborescence des appareils ci-dessous SoftMotion Pool d'entraînement général . " }, 
{ "title" : "Commande de conduite 'Drive_PosControl' ", 
"url" : "_sm_drive_controller_drive_poscontrol.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuration du lecteur SoftMotion \/ Insertion d'unités d'entraînement libres \/ Commande de conduite 'Drive_PosControl' ", 
"snippet" : "Avec le Drive_PosControl commande d'entraînement, vous pouvez laisser le contrôle de position d'un axe de CODESYS continuer à courir. L'exigence est un appareil qui est contrôlé par la vitesse définie et renvoie sa position actuelle. Il peut s'agir par exemple d'un appareil à régulation de vitesse (...", 
"body" : "Avec le Drive_PosControl commande d'entraînement, vous pouvez laisser le contrôle de position d'un axe de CODESYS continuer à courir. L'exigence est un appareil qui est contrôlé par la vitesse définie et renvoie sa position actuelle. Il peut s'agir par exemple d'un appareil à régulation de vitesse (convertisseur de fréquence) avec recopie de position. Ajout d'un contrôle d'entraînement Condition : un contrôleur SoftMotion est inséré dans le projet. Dans l'arborescence des appareils, sélectionnez SoftMotion Piscine de l'axe général . Dans le menu contextuel, cliquez sur Ajouter un appareil . Dans le Ajouter un appareil boîte de dialogue, sélectionnez le Entraînements SoftMotion → Entraînements à régulation de position → SMC_Drive_PosControl appareil. Clique le Ajouter un appareil bouton. L'appareil est ajouté à l'arborescence des appareils. Un double-clic sur l'appareil ouvre l'éditeur d'appareil correspondant. Pour plus d'informations, consultez: Onglet : Général" }, 
{ "title" : "Lecteur logique ", 
"url" : "_sm_drive_controller_logical_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuration du lecteur SoftMotion \/ Insertion d'unités d'entraînement libres \/ Lecteur logique ", 
"snippet" : "Vous pouvez ajouter un lecteur logique à n'importe quel type d'unité de disque. L'axe du lecteur logique reflète le mouvement de son axe maître alors qu'il représente une instance autonome. Cela permet l'exécution des instructions suivantes sans affecter l'axe maître. MC_SetPosition : Réglage de la ...", 
"body" : "Vous pouvez ajouter un lecteur logique à n'importe quel type d'unité de disque. L'axe du lecteur logique reflète le mouvement de son axe maître alors qu'il représente une instance autonome. Cela permet l'exécution des instructions suivantes sans affecter l'axe maître. MC_SetPosition : Réglage de la position à une valeur définie (exemple : 0) MC_TouchProbe : Sauvegarde de la position actuelle de l'axe d'un signal de déclenchement MC_AbortTrigger : Désactivation d'un capteur précédemment activé avec MC_TouchProbe Une application serait une bande transporteuse qui traverse plusieurs stations de traitement. La position du composant est détectée au moyen d'un signal externe (par exemple, une barrière lumineuse) et l'axe est réglé sur une position définie (fonction Touch Probe). Le lecteur logique offre la possibilité de filtrer le signal. Par conséquent, le lecteur logique peut également être utilisé avec un codeur qui délivre un signal de bruit. Ajout d'un lecteur logique Condition : un contrôleur SoftMotion est inséré dans le projet. Sélectionnez une unité d'entraînement dans l'arborescence des appareils. Dans le menu contextuel, cliquez sur Ajouter un appareil . Dans le Ajouter un appareil boîte de dialogue, sélectionnez le Disques SoftMotion → disques virtuels → SM_Drive_Logical appareil. Clique le Ajouter un appareil bouton. L'appareil est ajouté à l'arborescence des appareils. Un double-clic sur l'appareil ouvre l'éditeur d'appareil correspondant. " }, 
{ "title" : "Conduite virtuelle ", 
"url" : "_sm_drive_controller_virtual_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuration du lecteur SoftMotion \/ Insertion d'unités d'entraînement libres \/ Conduite virtuelle ", 
"snippet" : "Les lecteurs virtuels sont des lecteurs simulés dans le logiciel. Avec cela, vous pouvez tester vos programmes sans matériel connecté ou implémenter des fonctionnalités étendues. Ces types de fonctions incluent, par exemple, le contrôle du dépassement du mouvement des axes et la méthode cartésienne ...", 
"body" : "Les lecteurs virtuels sont des lecteurs simulés dans le logiciel. Avec cela, vous pouvez tester vos programmes sans matériel connecté ou implémenter des fonctionnalités étendues. Ces types de fonctions incluent, par exemple, le contrôle du dépassement du mouvement des axes et la méthode cartésienne manuelle d'un robot dans un espace. Pour plus d'informations, consultez : Contrôle d'un entraînement à cames avec un axe de temps virtuelLes variateurs virtuels simulent un entraînement physique en utilisant les positions définies des cycles précédents pour calculer les valeurs réelles de position, de vitesse et d'accélération au début d'un cycle. Fonctions nécessitant un lecteur physique, telles qu'un MC_TouchProbe dans le lecteur ou à l'aide de SMC_SetControllerMode , ne sont pas pris en charge. Ajout d'un lecteur virtuel Condition : un contrôleur SoftMotion est inséré dans le projet. Dans l'arborescence des appareils, sélectionnez SoftMotion Piscine de l'axe général . Dans le menu contextuel, cliquez sur Ajouter un appareil . Dans le Ajouter un appareil boîte de dialogue, sélectionnez le Disques SoftMotion → disques virtuels → SM_Drive_Virtual appareil. Clique le Ajouter un appareil bouton. L'appareil est ajouté à l'arborescence des appareils. Un double-clic sur l'appareil ouvre l'éditeur d'appareil correspondant. " }, 
{ "title" : "Encodeur gratuit ", 
"url" : "_sm_drive_controller_free_encoder.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuration du lecteur SoftMotion \/ Insertion d'unités d'entraînement libres \/ Encodeur gratuit ", 
"snippet" : "Utilisez le Encodeur gratuit pour l'intégration d'un codeur qui n'est pas couplé en permanence à des E\/S ou à du matériel. Ajout d'un encodeur gratuit Dans l'arborescence des appareils, sélectionnez SoftMotion Piscine de l'axe général . Dans le menu contextuel, cliquez sur Ajouter un appareil . Dans...", 
"body" : "Utilisez le Encodeur gratuit pour l'intégration d'un codeur qui n'est pas couplé en permanence à des E\/S ou à du matériel. Ajout d'un encodeur gratuit Dans l'arborescence des appareils, sélectionnez SoftMotion Piscine de l'axe général . Dans le menu contextuel, cliquez sur Ajouter un appareil . Dans le Ajouter un appareil boîte de dialogue, sélectionnez le Entraînements SoftMotion → Encodeurs libres → SMC_FreeeEncoder appareil. Clique le Ajouter un appareil bouton. L'appareil est ajouté à l'arborescence des appareils. Ouvrez l'encodeur dans le Éditeur . Adaptez les paramètres au matériel et définissez la largeur de bit et la mise à l'échelle. Affectez la valeur d'entrée de l'encodeur au <FREE_ENCODER_AXIS>.diEncoderPosition variable. Ceci est possible soit sous forme de code CEI, soit en mappant la mémoire des données d'entrée. Lors de l'initialisation du bus de terrain, cette entrée peut donner des valeurs invalides. Vous pouvez utiliser le bDélaiActivation entrée pour désactiver l’évaluation de l’entrée jusqu’à ce qu’une valeur valide soit disponible. Vous pouvez maintenant utiliser l'encodeur comme un lecteur. Pour plus d'informations, voir : Axe de l'encodeur" }, 
{ "title" : "Création d'axes par programmation ", 
"url" : "_sm_programmatic_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Configuration du lecteur SoftMotion \/ Insertion d'unités d'entraînement libres \/ Création d'axes par programmation ", 
"snippet" : "Les unités de disque libres suivantes peuvent également être créées par programmation : Haches AXE_VIRTUEL SMC Crée un axe virtuel sans avoir à l'ajouter à l'arborescence des appareils Pour plus d'informations, consultez les rubriques suivantes : Conduite virtuelleAxe logique SMC Crée un axe logique...", 
"body" : "Les unités de disque libres suivantes peuvent également être créées par programmation : Haches AXE_VIRTUEL SMC Crée un axe virtuel sans avoir à l'ajouter à l'arborescence des appareils Pour plus d'informations, consultez les rubriques suivantes : Conduite virtuelleAxe logique SMC Crée un axe logique sans avoir à l'ajouter à l'arborescence des appareils. Pour plus d'informations, consultez les rubriques suivantes : Lecteur logiqueEncodeur SMC_Free Crée un axe d'encodeur sans avoir à l'ajouter à l'arborescence des appareils Pour plus d'informations, consultez les rubriques suivantes : Encodeur gratuit" }, 
{ "title" : "Disques pris en charge ", 
"url" : "_sm_drives_supported_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Disques pris en charge ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Disques compatibles : EtherCAT ", 
"url" : "_sm_drives_supported_drives_ethercat.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Disques pris en charge \/ Disques compatibles : EtherCAT ", 
"snippet" : "EtherCAT Beckhoff EL2521 Beckhoff EL5101 Beckhoff EL72x1 Beckhoff EL7031 Beckhoff EL7037 Beckhoff EL7041 Beckhoff EL7047 Beckhoff EP7041 Bonfiglioli iBMD Bosch Rexroth IndraDrive CoE Bosch Rexroth ctrlX DRIVE CoE Bosch Rexroth ctrlX DRIVE SoE CMZ BD CMZ LBD CMZ SBD Control Techniques Digitax Control...", 
"body" : "EtherCAT Beckhoff EL2521 Beckhoff EL5101 Beckhoff EL72x1 Beckhoff EL7031 Beckhoff EL7037 Beckhoff EL7041 Beckhoff EL7047 Beckhoff EP7041 Bonfiglioli iBMD Bosch Rexroth IndraDrive CoE Bosch Rexroth ctrlX DRIVE CoE Bosch Rexroth ctrlX DRIVE SoE CMZ BD CMZ LBD CMZ SBD Control Techniques Digitax Control Techniques Mentor Control Techniques Unidrive M Copley Accelnet Danfoss ISD 520 Delta ASDA A2 Delta ASDA A3 Delta ASDA B3 Delta R1-EC5621 Festo CMMP EtherCAT Pilote générique CiA 402 : voir Configuration de l'axe générique CiA402Generischer SoE Treiber (auch für mehrachsige Antriebe) Hitachi ADV series Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB H6 KEBA KeDrive D3 Kollmorgen AKD Kollmorgen AKD-N\/C Kollmorgen MKD-N\/C Kollmorgen AKD2G Kollmorgen KED Metronix ARS 2000-Serie Mitsubishi Melservo MR-J5 Mitsubishi Melservo MR-JET Omron G5 Panasonic MINAS A5B Panasonic MINAS A6B Panasonic MINAS A6 MultiDrive Parker compax3 Parker SBC Parker PSD Sanyo Denki RS2 Schneider Electric Lexium32 Schneider Electric Lexium32i Servotronix CDHD Stäubli uniVAL Stöber Posidrive Stöber SD6 Stöber SI6\/SC6 WEG SCA06 Yaskawa Sigma7 series " }, 
{ "title" : "Disques compatibles : CAN ", 
"url" : "_sm_drives_supported_drives_can.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Disques pris en charge \/ Disques compatibles : CAN ", 
"snippet" : "PEUT Bonfiglioli iBMD CMZ BD CMZ SD CMZ LBD CMZ SBD Festo EMCA Festo CMMP Pilote générique CiA 402 : voir Configuration de l'axe générique CiA402Infranor cd1-k Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB Stepless Technology Maxon EPOS4 Metronix ARS 2000-Serie Nanotec PD4C Schneider E...", 
"body" : "PEUT Bonfiglioli iBMD CMZ BD CMZ SD CMZ LBD CMZ SBD Festo EMCA Festo CMMP Pilote générique CiA 402 : voir Configuration de l'axe générique CiA402Infranor cd1-k Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB Stepless Technology Maxon EPOS4 Metronix ARS 2000-Serie Nanotec PD4C Schneider Electric Lexium05 Schneider Electric Lexium23 Schneider Electric Lexium28 Schneider Electric Lexium32 Schneider Electric Lexium32i Schneider Electric SD-3 " }, 
{ "title" : "Cas d'utilisation ", 
"url" : "_sm_f_use_cases_drive_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cas d'utilisation ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Cas d'utilisation standard ", 
"url" : "_sm_special_use_cases.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cas d'utilisation \/ Cas d'utilisation standard ", 
"snippet" : "le SM3_Basic La bibliothèque contient des blocs fonctionnels supérieurs qui n'interagissent pas avec l'entraînement via l'interface standard consigne\/valeur réelle. Ces blocs fonction fournissent des commandes ou modifient les paramètres du variateur en lisant ou en écrivant les paramètres de l'inst...", 
"body" : "le SM3_Basic La bibliothèque contient des blocs fonctionnels supérieurs qui n'interagissent pas avec l'entraînement via l'interface standard consigne\/valeur réelle. Ces blocs fonction fournissent des commandes ou modifient les paramètres du variateur en lisant ou en écrivant les paramètres de l'instance de AXIS_REF_SM3 . " }, 
{ "title" : "Réinitialisation d'un lecteur ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_0e9f93f91e8d4c6dc0a8640e01d50c94", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cas d'utilisation \/ Cas d'utilisation standard \/ Réinitialisation d'un lecteur ", 
"snippet" : "Si vous avez modifié les paramètres du lecteur lors de l'exécution, vous devez le réinitialiser. Exemple : modifiez le facteur d'échelle ou la période modulo des variateurs rotatifs. En appelant le SMC3_ReinitDrive bloc fonctionnel avec un bord montant au niveau du Execute entrée, le wCommuncationSt...", 
"body" : "Si vous avez modifié les paramètres du lecteur lors de l'exécution, vous devez le réinitialiser. Exemple : modifiez le facteur d'échelle ou la période modulo des variateurs rotatifs. En appelant le SMC3_ReinitDrive bloc fonctionnel avec un bord montant au niveau du Execute entrée, le wCommuncationState le paramètre du lecteur est réinitialisé et le processus de démarrage complet du lecteur est répété. La réinitialisation doit attendre que l'axe atteigne l'état requis SMC_COMSTATE_BASE_COM_INITIALIZATION ou plus. Sinon, l'erreur s'affichera SMC_RAG_ERROR_AXIS_NOT_INITIALIZED . Si la communication d'un bus de terrain subordonné est interrompue, une réinitialisation explicite n'est plus nécessaire pour CODESYS SoftMotion version 4.18.0.0 et supérieure. L'axe est automatiquement réinitialisé dès que la communication par bus de terrain est rétablie. Avant la version 4.18.0.0, après l'interruption de la communication du bus de terrain, un SMC3_ReinitDrive était nécessaire (erreur avec SMC_DI_GENERAL_COMMUNICATION_ERROR ) dès que la communication par bus de terrain aura été rétablie. L'ancien comportement peut être restauré en réglant AutoRestart entrée du SMC_AxisChangeSettings bloc de fonctions pour SMC_AXIS_AUTORESTART_MODE.OFF . " }, 
{ "title" : "Allumer et éteindre un lecteur ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_bd45abb41e8d4c6dc0a8640e01589872", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cas d'utilisation \/ Cas d'utilisation standard \/ Allumer et éteindre un lecteur ", 
"snippet" : "le bRegulatorOn et bDriveStart paramètres de la AXIS_REF_SM3 bloc fonctionnel contrôle le niveau de performance et la décélération d'un variateur. L'accès se fait au moyen du MC_Power  bloc fonctionnel. Pour libérer l'étage de sortie, il faut régler le bRegulatorOn paramètre de la MC_Power bloc fonc...", 
"body" : "le bRegulatorOn et bDriveStart paramètres de la AXIS_REF_SM3 bloc fonctionnel contrôle le niveau de performance et la décélération d'un variateur. L'accès se fait au moyen du MC_Power  bloc fonctionnel. Pour libérer l'étage de sortie, il faut régler le bRegulatorOn paramètre de la MC_Power bloc fonctionnel. Le variateur signale l'état actuel de ce processus via le bRegulatorRealState sortir. S'il est pris en charge par le lecteur, un bRegulatorOn réinitialisé pendant le mouvement désactivera immédiatement le couple. Dans ce cas, le bloc fonction signale une erreur et règle les axes sur la errorstop Etat. le bDriveStart La variable détermine si le lecteur est autorisé ou non à se déplacer. L'état actuel de ce paramètre se trouve dans bDriveStartRealState . S'il est pris en charge par le lecteur, un bDriveStart la réinitialisation des paramètres décélère l'entraînement avec la rampe configurée (\"QuickStop\") pendant le mouvement. Après cela, l'entraînement s'arrête à la position atteinte tant que bRegulatorOn . L'axe reste dans le stopping tant que le mécanisme \"QuickStop\" est actif ( bDriveStart entrée = FAUX). Si le variateur a déjà été déplacé par un bloc fonction, il affichera maintenant CommandAborted . Ceci ne s'applique pas aux MC_Stop bloc fonctionnel qui signale une erreur et règle les axes sur errorstop Etat. " }, 
{ "title" : "Manipulation des freins mécaniques ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_6670a1571e8d4c6ec0a8640e01f5eecb", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cas d'utilisation \/ Cas d'utilisation standard \/ Manipulation des freins mécaniques ", 
"snippet" : "S'il est pris en charge par le lecteur, le eBrakeControl variable peut être définie ou réinitialisée au moyen de la SMC3_BrakeControl bloc fonctionnel. Trois modes différents sont possibles. SMC3_BrakeSetState SMC_BRAKE_AUTO : L'état du frein est contrôlé par le variateur. SMC_BRAKE_OPEN : Le frein ...", 
"body" : "S'il est pris en charge par le lecteur, le eBrakeControl variable peut être définie ou réinitialisée au moyen de la SMC3_BrakeControl bloc fonctionnel. Trois modes différents sont possibles. SMC3_BrakeSetState SMC_BRAKE_AUTO : L'état du frein est contrôlé par le variateur. SMC_BRAKE_OPEN : Le frein est ouvert. SMC_BRAKE_CLOSE : Le frein est fermé. le bBrakeClosedRealState La variable signale l'état actuel du frein. Du point de vue de SoftMotion , la commande, ainsi que l'état du frein mécanique, ne dépendent pas de l'état du variateur ou du mouvement de marche. " }, 
{ "title" : "Changer le mode de la manette ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_959f85271e8d4c6ec0a8640e01ed4fcb", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cas d'utilisation \/ Cas d'utilisation standard \/ Changer le mode de la manette ", 
"snippet" : "Avec le SMC_SetControllerMode bloc de fonction, vous pouvez basculer entre les différents modes du contrôleur. byControllerMode et byRealControllerMode paramètres de AXIS_REF_SM3 représentent le mode souhaité et le mode actuel du contrôleur. Valeurs possibles SMC_nocontrol SoftMotion n'envoie pas de...", 
"body" : "Avec le SMC_SetControllerMode bloc de fonction, vous pouvez basculer entre les différents modes du contrôleur. byControllerMode et byRealControllerMode paramètres de AXIS_REF_SM3 représentent le mode souhaité et le mode actuel du contrôleur. Valeurs possibles SMC_nocontrol SoftMotion n'envoie pas de données cycliques au variateur. Cela permet de contrôler le lecteur d'autres manières. SMC_torque Contrôle couple\/force SMC_velocity Contrôle de la vitesse SMC_position , Contrôle de position Après avoir écrit le byControllerMode variables, le mode actuel est vérifié jusqu'à ce qu'il corresponde au mode de contrôleur souhaité. Le bloc fonctionnel calcule les valeurs définies jusqu'à ce que le nouveau mode soit confirmé par le variateur. Dès que le lecteur confirme le nouveau mode, bDone la sortie est réglée et SMC_SetControllerMode n'écrit plus les valeurs définies. Cela doit être fait à l'aide d'autres blocs fonctionnels. Exemple : Le bDone la sortie est connectée à Execute entrée d'un bloc fonctionnel, tel que MC_MoveVelocity , MC_MoveAbsolute , ou MC_Halt . Sinon, l'axe s'arrête immédiatement après le changement de mode. Notez que le temps mort est utilisé pour calculer la position définie. Pour plus d'informations, consultez les rubriques suivantes : Valeurs réelles, valeurs définies et temps mort. " }, 
{ "title" : "Prise d'origine (contrôlée par l'entraînement) ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_7fa66d251e8d4c6fc0a8640e00782f3b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cas d'utilisation \/ Cas d'utilisation standard \/ Prise d'origine (contrôlée par l'entraînement) ", 
"snippet" : "Dans SoftMotion , il existe deux manières de référencer un lecteur : Référencement par un automate dans l'automate : Ce référencement s'effectue en appelant le SMC_Homing bloc fonctionnel. Le signal de référence doit faire partie du mappage E\/S de l'unité de contrôle. Au moment du référencement, le ...", 
"body" : "Dans SoftMotion , il existe deux manières de référencer un lecteur : Référencement par un automate dans l'automate : Ce référencement s'effectue en appelant le SMC_Homing bloc fonctionnel. Le signal de référence doit faire partie du mappage E\/S de l'unité de contrôle. Au moment du référencement, le variateur reste en mode de régulation \"régulation de position\". En général, cette méthode n'est pas particulièrement précise car la détection de la position (lorsque l'interrupteur de référence est activé) est basée sur les positions actuelles obtenues par le variateur. Par conséquent, la précision est limitée par le cycle de communication. Référencement par un contrôleur dans le variateur : L'interrupteur de référence est câblé au variateur. Sa position est détectée plus rapidement et avec une plus grande précision. Pendant la course de référence commandée par l'entraînement, l'entraînement se trouve dans un autre mode de régulation, dans lequel l'entraînement est commandé par des processus internes et ne suit pas les valeurs réglées de l'unité de commande. Lorsque le chemin de référence se termine, le variateur est réinitialisé à son mode de contrôle d'origine. le MC_Home  bloc fonctionnel démarre le chemin de référence commandé par le variateur en définissant fReference et bStartReference . De plus, l'état de AXIS_REF_SM3 ( wState ) est réglé sur homing . Lorsque le variateur passe sur la voie de référence (c'est-à-dire qu'il ne suit plus les valeurs spécifiées par l'unité de contrôle), le variateur positionne le paramètre sur TRUE . Pour afficher la fin du chemin de référence, le pilote définit les valeurs de bStartReference et bStartReferenceRealState à FALSE . " }, 
{ "title" : "Verrouillage ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_index_14", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cas d'utilisation \/ Cas d'utilisation standard \/ Verrouillage ", 
"snippet" : "Vous pouvez détecter la position d'un axe de plusieurs manières, selon les fonctions d'entraînement prises en charge par l'entraînement : Le variateur détecte lui-même la position de l'axe (intégré ou en activant un capteur externe). Étant donné que la position réelle est transmise par le variateur ...", 
"body" : "Vous pouvez détecter la position d'un axe de plusieurs manières, selon les fonctions d'entraînement prises en charge par l'entraînement : Le variateur détecte lui-même la position de l'axe (intégré ou en activant un capteur externe). Étant donné que la position réelle est transmise par le variateur lui-même, le temps de transfert du signal est minimal et précis. La position actuelle de l'axe est déterminée indépendamment de l'entraînement et transmise à la commande via une entrée. La latence survenant de l'entrée du contrôleur et le cycle d'application rendent cette méthode moins précise. Lorsque la position de l'entraînement lui-même est transférée, elle est traitée directement dans l'application, généralement par le pilote respectif en fonction du fabricant. Pour déterminer la position de ce type d'axe, vous pouvez utiliser la MC_TouchProbe bloc fonctionnel. Il permet l'enregistrement de la position de l'axe sur un déclencheur configurable et dans une fenêtre de position. Si la position n'est pas transmise par l'entraînement, elle doit être transmise au pilote d'appareil de l'entraînement, par exemple pour le contrôle. Pour plus d'informations, consultez : Contrôle de position sur le contrôleur avec SM_Drive_PosControl" }, 
{ "title" : "Persistance d'une position d'axe ", 
"url" : "_sm_storing_axis_position_persistently.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cas d'utilisation \/ Persistance d'une position d'axe ", 
"snippet" : "Un axe doté d'un codeur absolu peut enregistrer une position afin de conserver sa position précédente après le redémarrage du contrôleur. Le repérage n'est pas obligatoire. SMC3_PersistPosition et SMC3_PersistPositionLogical les blocs fonctionnels fournissent les fonctionnalités nécessaires à l'opér...", 
"body" : "Un axe doté d'un codeur absolu peut enregistrer une position afin de conserver sa position précédente après le redémarrage du contrôleur. Le repérage n'est pas obligatoire. SMC3_PersistPosition et SMC3_PersistPositionLogical les blocs fonctionnels fournissent les fonctionnalités nécessaires à l'opération de sauvegarde. Les données nécessaires sont enregistrées dans SMC3_PersistPosition_Data et SMC3_PersistPositionLogical_Data . Le bPositionStored la sortie indique si le contenu de PersistentData ont changé. Cela se produit à des moments différents selon le type de persistance. La plage de valeurs conservée par l'encodeur doit être configurée sur SMC_PersistPosition.maxPersistedValue entrée. Pour les codeurs multitours, la valeur est définie 16#FFFFFFFFFF . Pour un encodeur à tour unique 12 bits, par exemple, la valeur est définie sur 2^12 = 4096 Pour plus d'informations, consultez : Persistance des données L'instance est rendue persistante au moyen d'une déclaration as VAR_PERSISTENT ou le gestionnaire de persistance d'Application Composer. Conserver la position d'axe d'un axe logique Condition : L'axe est logique. Utilisez le SMC3_PersistPositionLogique bloc fonctionnel pour rendre persistante la position de l'axe logique. Cela ne fonctionne que si la position de l'axe physique supérieur est rendue persistante. La position d'un axe virtuel ne peut pas être rendue persistante au moyen de ces FB. Créez une instance de SMC3_PersistPositionLogical bloc fonctionnel pour l'axe. ppl: SM3_BASIC.SMC3_PersistPositionLogical; Instancier une structure de données persistante du SMC3_PersistPositionLogical_Data taper. ppl_Data: SMC3_PersistPositionLogical_Data; Prolongez le programme de la tâche de mouvement afin qu'un appel de la SMC3_PersistPositionLogical instance est implémentée et les données persistantes de type SMC3_PersistPositionLogical_Data lui est transmis. " }, 
{ "title" : "Persistance de la position d'axe d'un codeur absolu multitours avec un axe physique ", 
"url" : "_sm_storing_axis_position_persistently.html#UUID-71a9dfd2-c008-608a-c739-86d0c80e041d_id_f83d9cd75f3d951cc0a8640e00a495cd_id_49c53944c3ac11e3ae6789f982afc4cc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cas d'utilisation \/ Persistance d'une position d'axe \/ Persistance de la position d'axe d'un codeur absolu multitours avec un axe physique ", 
"snippet" : "Condition requise : L'axe est équipé d'un codeur absolu multitour. Utilisez le SMC3_PersistPosition FB pour rendre persistante la position de l'axe physique. Le programme respectif s'exécute dans la tâche de mouvement. Créez une instance de SMC3_PersistPosition bloc fonctionnel pour l'axe. pp: SM3_B...", 
"body" : "Condition requise : L'axe est équipé d'un codeur absolu multitour. Utilisez le SMC3_PersistPosition FB pour rendre persistante la position de l'axe physique. Le programme respectif s'exécute dans la tâche de mouvement. Créez une instance de SMC3_PersistPosition bloc fonctionnel pour l'axe. pp: SM3_BASIC.SMC3_PersistPosition; Instancier une structure de données persistante du SMC3_PersistPosition_Data taper. pp_Data: SM3_BASIC.SMC3_PersistPosition_Data1; Prolongez le programme de la tâche de mouvement afin qu'un appel de la SMC3_PersistPosition instance y est implémentée. Appel implémenté dans CFC : Le bloc fonction est appelé en cycles avec la tâche de mouvement. le SMC3_PersistPosition instance effectue la restauration de la position enregistrée lors de l'opération de démarrage. En fonctionnement normal, le FB enregistre la position réelle dans la structure de données correspondante. " }, 
{ "title" : "Maintien de la position de l'axe d'un codeur absolu monotour avec axe physique ", 
"url" : "_sm_storing_axis_position_persistently.html#UUID-71a9dfd2-c008-608a-c739-86d0c80e041d_id_f83d9cd75f3d951cc0a8640e00a495cd_id_a4cc9967c3ac11e3ae6789f982afc4cc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cas d'utilisation \/ Persistance d'une position d'axe \/ Maintien de la position de l'axe d'un codeur absolu monotour avec axe physique ", 
"snippet" : "Condition préalable : L'axe physique dispose d'un codeur absolu monotour. Utilisez le SMC3_Position persistante bloc fonctionnel pour rendre persistante la position de l'axe. Le programme correspondant s'exécute dans la tâche de mouvement. La position n'est affichée correctement que si l'axe n'a par...", 
"body" : "Condition préalable : L'axe physique dispose d'un codeur absolu monotour. Utilisez le SMC3_Position persistante bloc fonctionnel pour rendre persistante la position de l'axe. Le programme correspondant s'exécute dans la tâche de mouvement. La position n'est affichée correctement que si l'axe n'a parcouru aucune distance ou seulement une courte distance (maximum de la moitié de la distance en un tour) entre la mise hors tension et la mise en marche du contrôleur. Par exemple, vous pouvez utiliser un frein mécanique pour ce faire. Si l'axe effectue un mouvement important lorsque le contrôleur est éteint, il reçoit une position incorrecte. Il n'est pas possible de vérifier via le FB. Créez une instance de SMC3_PersistPosition bloc fonctionnel pour l'axe. ppst_X: SM3_BASIC.SMC3_PersistPositionSinglturn; Instanciez une structure de données persistante du SMC3_PersistPosition_Data type. ppst_Data_X: SMC3_PersistPositionSingleturn_Data; Étendez le programme de la tâche de mouvement de sorte qu'un appel du SMC3_PersistPosition l'instance est implémentée et la structure de données persistante du SMC_PersistPosition_Data le type lui est transmis. " }, 
{ "title" : "Détection de la position initiale d'un axe modulo ", 
"url" : "_sm_initial_positioning_of_a_rotary_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Cas d'utilisation \/ Détection de la position initiale d'un axe modulo ", 
"snippet" : "La position réelle d'un entraînement ou d'un codeur est transmise en tant que DWORD au contrôleur. Pour un axe modulo, la période P est définie en pas par la valeur modulo et la mise à l'échelle. La période P spécifie le nombre exact d'incréments dans une rotation. Cela signifie que les valeurs de p...", 
"body" : "La position réelle d'un entraînement ou d'un codeur est transmise en tant que DWORD au contrôleur. Pour un axe modulo, la période P est définie en pas par la valeur modulo et la mise à l'échelle. La période P spécifie le nombre exact d'incréments dans une rotation. Cela signifie que les valeurs de position X, X+1*P, X+2*P, etc. décrivent la même position physique. La position X+n*P dépasse la limite de DWORD lorsque n est suffisamment grand. Cela se produit à la position 0x1 00 00 00 00. Ensuite, la première place est coupée et la valeur commence à 0 . Si P n'est pas un facteur de 0x1 00 00 00 00 , alors la position X ne décrit plus la même position physique avant et après l'interruption. Si les rapports de démultiplication sont réglés de manière à ce que la période ne soit pas un facteur de 0x1 0000 0000 , la position d'un axe de rotation peut être déplacée après activation. Exemple L'axe commence à la position 0x0 . Il est à 0°. Une période correspond à 360°. La mise à l'échelle est choisie de sorte qu'elle corresponde à 3600000 = 0x36 EE80 incréments. Après 1193 tours, l'axe s'arrête à 0xFFFD 7280=1193*3600000 . Après une autre rotation complète, l'axe atteint la position 0x10034 6100 . A l'interruption, le premier 1 est coupé et la position 0x34 6100 est formé. Si vous remettez l'axe en position 0x0 , puis l'axe s'arrête à la position 16,7296°. Par conséquent, la position 0x0 correspond à la position 0°, 16,7296°, etc., selon l'interruption réelle. Si vous avez sélectionné la mise à l'échelle de manière à ce que l'effet ci-dessus puisse se produire et si la prise d'origine n'est pas possible ou requise au démarrage du programme, vous pouvez récupérer la position avant la dernière désactivation à l'aide de la SMC3_PersistPosition bloc fonctionnel. Vous utilisez ici un codeur de valeur absolue. " }, 
{ "title" : "Haches CiA402 ", 
"url" : "_sm_cia402_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Haches CiA402 ", 
"snippet" : "Pour plus d'informations, voir Ajouter...", 
"body" : "Pour plus d'informations, voir Ajouter " }, 
{ "title" : "Configuration de l'axe générique CiA402 ", 
"url" : "_sm_drives_generic_cia402_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Haches CiA402 \/ Configuration de l'axe générique CiA402 ", 
"snippet" : "CODESYS SoftMotion fournit des pilotes pour différents lecteurs. Si aucun pilote spécifique n'est disponible pour le variateur CiA402 que vous utilisez, vous pouvez utiliser l'axe générique CiA402 Cependant, la compatibilité et le comportement de l'axe générique dépendent largement de l'implémentati...", 
"body" : "CODESYS SoftMotion fournit des pilotes pour différents lecteurs. Si aucun pilote spécifique n'est disponible pour le variateur CiA402 que vous utilisez, vous pouvez utiliser l'axe générique CiA402 Cependant, la compatibilité et le comportement de l'axe générique dépendent largement de l'implémentation du CiA402 dans le lecteur concerné. Dans la pratique, il a été démontré que les différents fabricants interprètent différemment la norme CiA402, notamment en ce qui concerne la gestion des erreurs et la prise en charge des interrupteurs de fin de course Par conséquent, il n'est pas possible de garantir que l'axe générique CiA402 fonctionnera toujours correctement ou complètement avec un entraînement particulier. Le pilote générique CiA402 prend en charge jusqu'à 8 axes dans le cas où la description de périphérique du lecteur ne spécifie pas de nombre. Sinon, le nombre d'axes défini dans la description de l'appareil est pris en charge. CANopen : Le nombre d'axes possibles dépend des profils des équipements logiques dans le fichier EDS ( 1000H objet et 67FFH + X * 800H , où X = nombre de périphériques logiques). Pour plus de détails, consultez la norme CANopen CiA301. EtherCAT : Le nombre d'axes possibles dépend des canaux CiA402 définis (CoE DS402Channels) dans le fichier ESI. Une adaptation du fichier EDS ou ESI doit être effectuée par le fabricant de l'appareil. " }, 
{ "title" : "Objets utilisés lors de la mise en service ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e06c925bc32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Haches CiA402 \/ Configuration de l'axe générique CiA402 \/ Objets utilisés lors de la mise en service ", 
"snippet" : "Lors de la mise en service, les objets suivants sont accessibles s'ils sont pris en charge par l'appareil. Objet Accès en lecture\/écriture (M) Obligatoire (O) Optionnel Commenter 0x1000:0 Lire M La valeur inférieure doit être 402. Sinon, annulez. 0x1018:1 Lire O 0x1018:2 Lire O 0x1018:3 Lire O 0x101...", 
"body" : "Lors de la mise en service, les objets suivants sont accessibles s'ils sont pris en charge par l'appareil. Objet Accès en lecture\/écriture (M) Obligatoire (O) Optionnel Commenter 0x1000:0 Lire M La valeur inférieure doit être 402. Sinon, annulez. 0x1018:1 Lire O 0x1018:2 Lire O 0x1018:3 Lire O 0x1018:4 Lire O 0x6502:0 Lire O 0x605A:0 Lire O 0x60C2:1 Écrivez Si paramètre Set60C2 = TRUE 0x60C2:2 Écrivez Si paramètre Set60C2 = TRUE 0x6076:0 Lire O " }, 
{ "title" : "Objets utilisés pendant le fonctionnement ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e7dfc492c32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Haches CiA402 \/ Configuration de l'axe générique CiA402 \/ Objets utilisés pendant le fonctionnement ", 
"snippet" : "Les objets suivants sont utilisés pendant le fonctionnement selon les fonctions utilisées : 0x603F:00 , 0x6040:00 , 0x6041:00 , 0x6060:00 , 0x6061:00 , 0x6062:00 , 0x6064:00 , 0x606B:00 , 0x606C:00 , 0x6074:00 , 0x6077:00 , 0x6078:00 , 0x607C:00 , 0x60B1:00 , 0x60B2:00, 0x60B8:00 0x60B9:00 , 0x60BA:...", 
"body" : "Les objets suivants sont utilisés pendant le fonctionnement selon les fonctions utilisées : 0x603F:00 , 0x6040:00 , 0x6041:00 , 0x6060:00 , 0x6061:00 , 0x6062:00 , 0x6064:00 , 0x606B:00 , 0x606C:00 , 0x6074:00 , 0x6077:00 , 0x6078:00 , 0x607C:00 , 0x60B1:00 , 0x60B2:00, 0x60B8:00 0x60B9:00 , 0x60BA:00 , 0x60BB:00 , 0x60BC:00 , 0x60BD:00 , 0x60F4:00 . " }, 
{ "title" : "Configuration avancée ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e7e012b4c32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Haches CiA402 \/ Configuration de l'axe générique CiA402 \/ Configuration avancée ", 
"snippet" : "Vous devez sélectionner le Afficher les éditeurs de configuration de périphérique génériques possibilité dans le Options – Editeur d'appareils dialogue pour que l'onglet avec les paramètres s'affiche. Vous pouvez utiliser les paramètres suivants pour affiner le flux du diagramme d'états transitions ...", 
"body" : "Vous devez sélectionner le Afficher les éditeurs de configuration de périphérique génériques possibilité dans le Options – Editeur d'appareils dialogue pour que l'onglet avec les paramètres s'affiche. Vous pouvez utiliser les paramètres suivants pour affiner le flux du diagramme d'états transitions CiA402. Paramètre CiA402 La description _readVelocityFactor_6096 TRUE : Le facteur de vitesse (objet 6096 ) est lu et utilisé pour convertir les unités de vitesse. FALSE : Le facteur de vitesse n'est pas lu. L'unité de vitesse est supposée être des incréments par seconde. _bImmediateDisabling TRUE : Quand bRegulator est réinitialisé à FALSE , fait passer l'état du lecteur de Operation enabled directement à Switch on disabled . FALSE : Commute l'état via \"Activé\" et \"Prêt à allumer\", donnant à l'entraînement la possibilité d'exécuter un arrêt rapide et de gérer correctement le frein. Remarque : Si cette option est définie sur FALSE , les états pour lesquels la désactivation immédiate est désactivée peuvent être ajustés avec le masque de bits _dwStatesImmediateDisabling . _bForbidReenableDuringDisabling Pertinent uniquement lorsque _bImmediateDisabling = FALSE . TRUE : Le variateur est désactivé pas à pas jusqu'à ce que le variateur signale Ready to switch on avant qu'une nouvelle commande d'activation ne soit traitée. dwStatesImmediateDisabling Pertinent uniquement lorsque _bImmediateDisabling = FALSE . Masque binaire des états pour lesquels la désactivation immédiate est activée. Bit 0 : fonctionnement normal Bit 1 : Arrêt rapide Bit 2 : Arrêt rapide externe Bit 3 : prise d'origine Exemple : Supposons _bImmediateDisabling = FALSE , la valeur 2#0110 signifie que la désactivation immédiate n'est désactivée que pour les états \"Fonctionnement normal\" et \"Homing\". Pour les états \"Quickstop\" et \"External Quickstop\", la désactivation immédiate est activée. _uiPreHomingWait Nombre de cycles pendant lesquels la machine à états attend dans l'état PRE_HOMING avant de démarrer le processus de référencement en réglant le bit 4 du mot de contrôle. _uiPostHomingWait Nombre de cycles dans lesquels la machine d'état reste HOMING_DONE avant de revenir au \"Fonctionnement normal\". _uiHomingMinCycles Nombre de cycles au début de HOMING , où les bits de fin (bit 10\/12 du mot d'état) sont ignorés. _uiWaitCyclesForStateSwitch Nombre de cycles pendant lesquels le système attend jusqu'à ce que le variateur exécute une commande de changement d'état. Si le disque tombe en panne, le système reviendra à SWITCH_ON_DISABLED . _bPreHomingWaitBit12Clear TRUE : Attendez PRE_HOMING jusqu'à ce que le bit 12 du mot d'état ait été effacé par le variateur avant de démarrer la prise d'origine (avant de définir le bit 4 du mot de contrôle). Notez que dans tous les cas, la machine d'état reste dans PRE_HOMING pour au moins _uiPreHomingCycles . _bCheckBit10PostHoming TRUE : Basculer vers HOMING_DONE si le bit 12 et le bit 10 du mot d'état sont tous les deux TRUE (comme spécifié dans CiA-402). FALSE : Ignorer le bit 10 ; n'utilisez que le bit 12. _bCheckOpMode TRUE : Vérifier si 0x6061 affiche la valeur définie dans 0x6060 lors de l'activation de l'axe. FALSE : Omettez cette vérification et activez-la immédiatement après avoir défini le mode de fonctionnement. _abyControllerMode Ce ARRAY[0..7] OF BYTE contient les modes de fonctionnement (objet 0x6060 ) qui correspondent à AXIS_REF_SM3.byOperationMode . (indice 0,3 = poste ; indice 1 = vitesse ; indice 2 = couple) _bCheckBit12InPositionMode TRUE : AxisIsReadyForMotion vérifie le bit 12 dans CSP ou IP. FALSE : AxisIsReadyForMotion ne vérifie pas le bit 12. _bDoHaltWhenStopInterruptsHome TRUE : Lorsque MC_Stop interruptions, abandonne le référencement avec le bit 8 du mot de commande. FALSE : Ne définissez pas le bit 8, mais commutez directement le mode de fonctionnement. _bCheckBit13InHomingMode TRUE : Dans HOMING_ACTIVE , wStatusWord.13 = TRUE conduit à un arrêt d'erreur et wControlWord.8 := TRUE (cela dépend de _bDoHaltWhenStopInterruptsHome ) _bSetControlBit4InCSP TRUE : Met également le bit 4 du mot d'état en mode CSP. Certains lecteurs l'exigent bien que ce ne soit pas standard. _uiHomingWaitListeningBits101213 En état HOMING_ACTIVE , n'écoutez pas les bits 10, 12 et 13 pendant ce nombre de cycles à partir du réglage du bit 4. (Certains variateurs mettent un certain temps à réinitialiser ces bits). _bRegulatorOnRequiresVoltageEnabled Si le bit 4 du mot d'état (tension activée) doit être TRUE pour que bRegulatorRealState = TRUE (valeur par défaut: FALSE ). _bDriveStartRequiresOperationEnabled Si le bit 2 du mot d'état (fonctionnement activé) doit être TRUE pour que bDriveStartRealState = TRUE (valeur par défaut: TRUE ). _modeOfOperation_Torque Le ModeOfOperation à utiliser pour le mode contrôleur torque . Doit se comporter comme le mode couple de synchronisation cyclique _modeOfOperation_Velocity Le ModeOfOperation à utiliser pour le mode contrôleur velocity . Doit se comporter comme le mode de synchronisation cyclique de la vélocité. _modeOfOperation_Position Le ModeOfOperation à utiliser pour le mode contrôleur position . Doit se comporter comme le mode de position de synchronisation cyclique _bStayInSwitchOnDisabled FALSE : Une transition automatique depuis SWITCH_ON_DISABLED à READY_TO_SWITCH_ON est effectué, si MC_Power.bDriveStart est TRUE ou le code d'option d'arrêt rapide ( object 0x605A:00 ) est > 4. VRAI : La transition entre SWITCH_ON_DISABLED à READY_TO_SWITCH_ON n'est effectué que si MC_Power.bRegulatorOn est TRUE . " }, 
{ "title" : "Sonde tactile ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_section-idm235087437140543", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Haches CiA402 \/ Configuration de l'axe générique CiA402 \/ Sonde tactile ", 
"snippet" : "Le MC_TouchProbe le bloc fonctionnel nécessite un TRIGGER_REF en tant qu'entrée. TRIGGER_REF.iTriggerNumber a la signification suivante pour l'axe générique CiA402 : Trigger_ref.itNuméro de déclenchement Signification 0 Sonde tactile 1, bord positif 1 Sonde tactile 1, bord négatif 2 Sonde tactile 2,...", 
"body" : "Le MC_TouchProbe le bloc fonctionnel nécessite un TRIGGER_REF en tant qu'entrée. TRIGGER_REF.iTriggerNumber a la signification suivante pour l'axe générique CiA402 : Trigger_ref.itNuméro de déclenchement Signification 0 Sonde tactile 1, bord positif 1 Sonde tactile 1, bord négatif 2 Sonde tactile 2, bord positif 3 Sonde tactile 2, bord négatif " }, 
{ "title" : "Diagnostic d'erreur : le lecteur ne peut pas être allumé via MC_Power ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_section-idm235087440495495", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Haches CiA402 \/ Configuration de l'axe générique CiA402 \/ Diagnostic d'erreur : le lecteur ne peut pas être allumé via MC_Power ", 
"snippet" : "L'axe générique attend les bits suivants dans le mot d'état afin de renvoyer MC_Power.Status = TRUE : Bit 0 (prêt à être allumé) Bit 1 (activé) Bit 2 (opération activée) Bit 5 (arrêt rapide) Bit 12 Cependant, le bit 12 n'est pas défini par tous les lecteurs. Si le lecteur ne règle pas le bit, _bChec...", 
"body" : "L'axe générique attend les bits suivants dans le mot d'état afin de renvoyer MC_Power.Status = TRUE : Bit 0 (prêt à être allumé) Bit 1 (activé) Bit 2 (opération activée) Bit 5 (arrêt rapide) Bit 12 Cependant, le bit 12 n'est pas défini par tous les lecteurs. Si le lecteur ne règle pas le bit, _bCheckBit12InPositionMode le paramètre de l'axe générique peut être réglé sur FALSE . " }, 
{ "title" : "Sonde tactile ", 
"url" : "_sm_touch_probe.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Haches CiA402 \/ Sonde tactile ", 
"snippet" : "Les variateurs dotés d'un profil CiA402 prennent parfois en charge la sélection de la source de la sonde tactile. Il n'est pas possible de régler la source via le MC_TouchProbe bloc fonctionnel. Par défaut, l'entrée numérique appartenant à la sonde tactile est utilisée. Modification de la source : É...", 
"body" : "Les variateurs dotés d'un profil CiA402 prennent parfois en charge la sélection de la source de la sonde tactile. Il n'est pas possible de régler la source via le MC_TouchProbe bloc fonctionnel. Par défaut, l'entrée numérique appartenant à la sonde tactile est utilisée. Modification de la source : Écriture manuelle de l'objet de la sonde tactile 0x60B8 Pour ce faire, vous devez appeler le MC_WriteParameter bloc fonctionnel avec ParameterNumber = 10184 . Cela correspond à l'objet CiA 402 0x60B8 . Si la sortie MC_WriteParameter.Done = TRUE , vous pouvez alors commander MC_TouchProbe bloc de fonction comme d'habitude. Seuls les bits de l'objet 0x60B8 sont définis et peuvent être définis par MC_TouchProbe (indiqué par ). Les bits restants conservent la valeur de l'étape 1 (indiquée par ) : Bits de l'objet 0x60B8 Sonde tactile 2 Sonde tactile 1 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 Remarque concernant l'objet 0x60D0 Dans l'objet de la sonde tactile 0x60B8 , vous pouvez spécifier la source pour qu'elle soit résolue via l'objet 0x60D0 . Cela correspond à la combinaison de bits 10 b pour embouts 3 , 2 ou 11 , 10 de l'objet 0x60B8 . Dans ce cas, vous devez écrire l'objet 0x60D0 avant d'exécuter MC_TouchProbe . Pour ce faire, vous devez utiliser le MC_WriteParameter bloc de fonction, dans lequel ParameterNumber est calculé à l'aide de SMC_ParameterNumber_CoE fonction. " }, 
{ "title" : "Valeurs réelles, valeurs définies et temps mort ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valeurs réelles, valeurs définies et temps mort ", 
"snippet" : "Cette page répond à la question de savoir quand les valeurs réelles et les valeurs définies sont reçues et envoyées, et comment elles sont liées au temps mort. Par souci de simplicité, nous nous concentrons sur la position, mais il en va de même pour d'autres valeurs telles que la vitesse ou le coup...", 
"body" : "Cette page répond à la question de savoir quand les valeurs réelles et les valeurs définies sont reçues et envoyées, et comment elles sont liées au temps mort. Par souci de simplicité, nous nous concentrons sur la position, mais il en va de même pour d'autres valeurs telles que la vitesse ou le couple. Nous nous concentrons également sur EtherCAT. Le comportement est similaire pour les autres bus de terrain. (Notez que nous supposons la configuration par défaut et recommandée avec FrameAtTaskStart = TRUE ). " }, 
{ "title" : "Quand les valeurs réelles sont-elles reçues ? ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054861776368", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valeurs réelles, valeurs définies et temps mort \/ Quand les valeurs réelles sont-elles reçues ? ", 
"snippet" : "The actual position ( <DriveA>.fActPosition ) is received at the beginning of the current bus task cycle. It is the actual position of the drive at the time of the previous EtherCAT SYNC event. Dans le cycle de tâches de bus i, la trame EtherCAT qui a été envoyée lors du précédent cycle de tâches de...", 
"body" : "The actual position ( <DriveA>.fActPosition ) is received at the beginning of the current bus task cycle. It is the actual position of the drive at the time of the previous EtherCAT SYNC event. Dans le cycle de tâches de bus i, la trame EtherCAT qui a été envoyée lors du précédent cycle de tâches de bus i-1 est reçue. Ce cadre contient la position réelle qui a été verrouillée par le lecteur lors de l'événement SYNC i-2 " }, 
{ "title" : "Quand les valeurs définies sont-elles envoyées ? ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862001312", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valeurs réelles, valeurs définies et temps mort \/ Quand les valeurs définies sont-elles envoyées ? ", 
"snippet" : "Les valeurs définies qui sont calculées dans le cycle de tâches de bus actuel i sont envoyées au lecteur lors du cycle de tâches de bus suivant i+1 et appliquées par le lecteur lors de l'événement SYNC i+1. Voir le schéma ci-dessus....", 
"body" : "Les valeurs définies qui sont calculées dans le cycle de tâches de bus actuel i sont envoyées au lecteur lors du cycle de tâches de bus suivant i+1 et appliquées par le lecteur lors de l'événement SYNC i+1. Voir le schéma ci-dessus. " }, 
{ "title" : "Qu'est-ce que le temps mort, comment est-il estimé et comment est-il utilisé ? ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862210917", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valeurs réelles, valeurs définies et temps mort \/ Qu'est-ce que le temps mort, comment est-il estimé et comment est-il utilisé ? ", 
"snippet" : "En règle générale, le temps mort est important chaque fois qu'il est nécessaire d'effectuer une action exactement au moment où le lecteur atteint une position. Le temps mort est également important pour déterminer exactement la position du moteur à un moment donné. Les exemples incluent l'applicatio...", 
"body" : "En règle générale, le temps mort est important chaque fois qu'il est nécessaire d'effectuer une action exactement au moment où le lecteur atteint une position. Le temps mort est également important pour déterminer exactement la position du moteur à un moment donné. Les exemples incluent l'application de colle à haute vitesse ou la réalisation d'une sonde tactile dans l'API avec des entrées numériques de haute précision connectées à l'API. " }, 
{ "title" : "Définition du temps mort ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862962511", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valeurs réelles, valeurs définies et temps mort \/ Qu'est-ce que le temps mort, comment est-il estimé et comment est-il utilisé ? \/ Définition du temps mort ", 
"snippet" : "Le temps mort est le temps nécessaire au variateur pour atteindre réellement la position définie envoyée par l'API. Cela signifie que c'est le décalage entre fActPosition et le fSetPosition , au début du cycle de tâches du bus en cours. Le temps mort peut être configuré dans l'éditeur de disque géné...", 
"body" : "Le temps mort est le temps nécessaire au variateur pour atteindre réellement la position définie envoyée par l'API. Cela signifie que c'est le décalage entre fActPosition et le fSetPosition , au début du cycle de tâches du bus en cours. Le temps mort peut être configuré dans l'éditeur de disque général ( Onglet : Général) ou à l'aide du Paramètre MC_Write bloc de fonction avec le numéro de paramètre 1070 ( fSetActTimeLagCycles ). Le temps mort est la somme des temps suivants : Le temps nécessaire pour envoyer la position définie au variateur Le temps nécessaire au contrôleur d'entraînement pour atteindre la position définie Le temps nécessaire pour recevoir la position réelle du lecteur " }, 
{ "title" : "Estimation du temps mort ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054864599382", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valeurs réelles, valeurs définies et temps mort \/ Qu'est-ce que le temps mort, comment est-il estimé et comment est-il utilisé ? \/ Estimation du temps mort ", 
"snippet" : "Le temps mort peut être estimé à l'aide du SMC_EstimateDeadTime bloc fonctionnel. Le variateur doit être déplacé à une vitesse constante et la médiane ou la moyenne de plusieurs mesures de temps mort doit être utilisée Le temps mort peut également être estimé à l'aide de l'éditeur de traces. Pour pl...", 
"body" : "Le temps mort peut être estimé à l'aide du SMC_EstimateDeadTime bloc fonctionnel. Le variateur doit être déplacé à une vitesse constante et la médiane ou la moyenne de plusieurs mesures de temps mort doit être utilisée Le temps mort peut également être estimé à l'aide de l'éditeur de traces. Pour plus d'informations, consultez les rubriques suivantes : Détermination du temps mort du système" }, 
{ "title" : "Utilisation du temps mort ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054865995483", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Valeurs réelles, valeurs définies et temps mort \/ Qu'est-ce que le temps mort, comment est-il estimé et comment est-il utilisé ? \/ Utilisation du temps mort ", 
"snippet" : "Le temps mort est utilisé dans la fonctionnalité suivante. Si vous utilisez l'une de ces fonctions et que vous avez besoin d'une précision élevée, assurez-vous de déterminer et de configurer le temps mort. Lors du passage du mode contrôleur au mode contrôleur SMC_position Pour plus d'informations, c...", 
"body" : "Le temps mort est utilisé dans la fonctionnalité suivante. Si vous utilisez l'une de ces fonctions et que vous avez besoin d'une précision élevée, assurez-vous de déterminer et de configurer le temps mort. Lors du passage du mode contrôleur au mode contrôleur SMC_position Pour plus d'informations, consultez les rubriques suivantes : Cas d'utilisation standardEn mode contrôleur SMC_velocity pour calculer la position définie à partir de la position réelle et de la vitesse définie En mode contrôleur SMC_torque pour calculer la position définie à partir de la position réelle et de la vitesse réelle Si la surveillance du décalage de position du logiciel est activée Dans le SMC_GetTravelTime bloc de fonction si l'entrée ValueSource a la valeur MC_SOURCE.ACT Dans le SMC_DigitalCamSwitch_HighPrecision bloc de fonction si l'entrée ValueSource a la valeur MC_SOURCE.ACT Dans le SMC_ETC_InterpolateAxisPosition bloc fonctionnel (sonde tactile basée sur PLC) " }, 
{ "title" : "Exemples ", 
"url" : "_sm_drives_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Exemples ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Contrôle de position sur le contrôleur avec SM_Drive_PosControl ", 
"url" : "_sm_example_poscontrol.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Exemples \/ Contrôle de position sur le contrôleur avec SM_Drive_PosControl ", 
"snippet" : "Voir le PosControl.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Dans la plupart des cas, une servocommande prend en charge le contrôle de position du variateur, ainsi que le contrôle de puissance et le contrôle de vitesse de ro...", 
"body" : "Voir le PosControl.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Dans la plupart des cas, une servocommande prend en charge le contrôle de position du variateur, ainsi que le contrôle de puissance et le contrôle de vitesse de rotation. Cependant, il existe des cas d'utilisation dans lesquels le contrôleur prend en charge le contrôle de position de l'axe. Cet exemple montre comment un dispositif à vitesse contrôlée (par exemple, un variateur de fréquence avec retour de position) est contrôlé en position par CODESYS SoftMotion . L'exigence est un appareil qui est contrôlé par la vitesse définie et renvoie sa position actuelle. Dans cet exemple, une borne de sortie analogique 10 V EL4031 est utilisée avec un signal utilisé comme point de consigne de vitesse pour un variateur de fréquence. Une borne d'encodeur EL5101 est utilisée pour le retour de position. " }, 
{ "title" : "Contrôle de la position de l'axe au moyen de SM_Drive_PosControl ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_7bfb9b9f2d9ce618c0a8646335ff28dd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Exemples \/ Contrôle de position sur le contrôleur avec SM_Drive_PosControl \/ Contrôle de la position de l'axe au moyen de SM_Drive_PosControl ", 
"snippet" : "Ajouter un axe contrôlé en position de type SM_Drive_PosControl au dessous de Pool d'axes généraux SoftMotion dans l'arborescence des appareils. Ajoutez les bornes de la borne analogique (EL4031) et de l'encodeur (EL5101) à l'arborescence des appareils. Arborescence des appareils : Les descriptions ...", 
"body" : "Ajouter un axe contrôlé en position de type SM_Drive_PosControl au dessous de Pool d'axes généraux SoftMotion dans l'arborescence des appareils. Ajoutez les bornes de la borne analogique (EL4031) et de l'encodeur (EL5101) à l'arborescence des appareils. Arborescence des appareils : Les descriptions d'appareils des appareils de bus de terrain doivent être téléchargées et installées auprès du fabricant. Ouvrez le SM_Drive_PosControl dans l'éditeur et spécifiez le paramètre général Modulo avec la valeur 360.0 sur le Général languette. Clique le Mise à l'échelle\/Mappage languette. Le nombre d'incréments par tour de moteur est tiré de la fiche technique du codeur. Dans cet exemple, 4096 les incréments (1) sont d'un tour de moteur. Comme vous travaillez avec des degrés angulaires dans l'application, vous spécifiez la valeur 360 (2) pour unités en application . Paramètres: Basculez vers le SoftMotion Drive : boucle de contrôle de position tab et spécifiez les paramètres suivants : D 2.0 Le temps mort détermine le nombre de cycles pendant lesquels la position réelle reçue (codeur) est déphasée vers la position définie de l'axe. Le temps mort dépend des composants appliqués et doit être déterminé par essais et erreurs. Kp 0.0 La constante de proportionnalité est le facteur par lequel l'erreur de position (l'écart entre la position définie et la position réelle) est multipliée pour être ajoutée ultérieurement à la vitesse définie. Maintenant, définissez cette valeur sur 0 . Vous déterminerez la valeur expérimentalement ultérieurement. Bit width: 16 La largeur de bit de la valeur réelle est reçue en fonction des composants utilisés et peut être définie sur des valeurs de 16, 24 ou 32 bits. Réglez la valeur sur 16 parce que les composants utilisés donnent la position comme UINT . max Laissez l'interrupteur de surveillance d'erreur de position désactivé. Vous pouvez le rallumer si nécessaire. Cochez la case et spécifiez un décalage maximum autorisé. Si cette valeur est dépassée pendant le fonctionnement, l'axe passe dans un état d'erreur. δ\/δt Le paramètre a la valeur 1 et ne doit être modifié que dans des cas très particuliers. Il définit la relation entre la vitesse de consigne et la dérivation de la position. La plage de valeurs est de 0 à 1 : 0 : Seule la dérivée numérique de fSetPosition est utilisé. 1 : La dérivation numérique de la position définie est utilisée comme source. Boucle de contrôle : Vous définissez maintenant les valeurs de vitesse qui sont envoyées à l'actionneur. Pour cela, vous devez connaître la vitesse maximale en unités d'application et la valeur brute correspondante des données transférées. Dans cet exemple, la vitesse maximale est atteinte par la sortie de la valeur 16#7FFF , ce qui correspond à une vitesse de 10 tours par seconde. Cela correspond également à 3600 degrés par seconde selon les réglages. Paramètres: " }, 
{ "title" : "Mappage des variables aux entrées et sorties ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_869c8e3e2852db2ec0a8640e00c42e8b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Exemples \/ Contrôle de position sur le contrôleur avec SM_Drive_PosControl \/ Mappage des variables aux entrées et sorties ", 
"snippet" : "Mappez les variables avec les données d'axe sur les modules d'E\/S. Les données cycliques disponibles de l'axe se trouvent dans les structures de données in et out . Vous pouvez établir cette connexion dans l'éditeur d'appareils de l'appareil d'entrée et de sortie soit par programmation, soit directe...", 
"body" : "Mappez les variables avec les données d'axe sur les modules d'E\/S. Les données cycliques disponibles de l'axe se trouvent dans les structures de données in et out . Vous pouvez établir cette connexion dans l'éditeur d'appareils de l'appareil d'entrée et de sortie soit par programmation, soit directement. Connectez la sortie (vitesse définie) à l'appareil EL4031. Ouvrez l'appareil dans l'éditeur et cliquez sur le bouton Mappage des E\/S EtherCAT languette. Attribuer la variable out.iSetVelocity de l'axe à la sortie. Dans le cas d'une sortie 32 bits, out.diSetVelocity est utilisé. Cartographie : Procédez de la même manière avec la saisie de position. Ouvrez l'appareil EL5101 dans l'éditeur et définissez la valeur d'entrée de position sur in.wActPosition . Pour une entrée 32 bits, définissez la valeur sur in.dwActPosition . Cartographie : Pour que l'activation de la commande, l'arrêt rapide et l'interrupteur de fin de course fonctionnent, les entrées correspondantes de SMC_PosControlInput doivent être définis par les valeurs du variateur. Les sorties de SMC_PosControlOutput doivent être transmises au variateur (voir description ci-dessous). Si le variateur ne prend pas en charge l'arrêt rapide, par exemple, alors SM_Drive_PosControl.in.bDriveStartRealState := TRUE doit être réglé et SM_Drive_PosControl.out.bDriveStart peut être ignoré. Dans cet exemple, bDriveStartRealState et bRegulatorRealState doivent être définis dans l'application. SM_Drive_PosControl.in.bDriveStartRealState := TRUE;\nSM_Drive_PosControl.in.bRegulatorRealState := TRUE; " }, 
{ "title" : "Détermination du temps mort du système ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_section-idm43260109050006", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Exemples \/ Contrôle de position sur le contrôleur avec SM_Drive_PosControl \/ Détermination du temps mort du système ", 
"snippet" : "Définissez maintenant le mode en ligne avec l'axe et définissez les paramètres de contrôle. Notez que l'axe peut devenir incontrôlable. Par conséquent, vous devez prendre les mesures de sécurité correspondantes. Essayer ensuite de faire fonctionner l'axe sans asservissement de position. fKp est déjà...", 
"body" : "Définissez maintenant le mode en ligne avec l'axe et définissez les paramètres de contrôle. Notez que l'axe peut devenir incontrôlable. Par conséquent, vous devez prendre les mesures de sécurité correspondantes. Essayer ensuite de faire fonctionner l'axe sans asservissement de position. fKp est déjà défini sur 0,0 et les paramètres de mise à l'échelle sont vérifiés. Commuter l'axe sur MC_Power et commencer MC_MoveVelocity . L'axe se déplace maintenant à la vitesse programmée de 1 U\/s. En cas d'écarts, vous devrez corriger la mise à l'échelle en conséquence. Terminer le mouvement, par exemple avec MC_MoveRelative , et démarrez la fonction de trace. Déterminez le temps mort du système en mesurant la différence de temps entre la position réglée et la position réelle. Dans MC_MoveRelative , définissez la vitesse maximale et une grande accélération. Démarrez la trace d'échantillonnage avec MC_MoveRelative . Déterminez maintenant la différence de temps entre le mouvement de démarrage de la position définie et la première réaction de la position réelle. Trace: Pour déterminer le temps mort D , divisez cette différence de temps par la durée du cycle (D = différence de temps\/durée du cycle). Sur le SoftMotion Drive : contrôle de position onglet, spécifiez cette valeur dans la boucle de contrôle à D . Essayez maintenant de déterminer le réglage correct de fKp . Pour ce faire, modifiez la valeur de la variable <drive>.controller.fKp dans une liste de contrôle. Set fKp à un petit nombre (par exemple, 0,0001) et augmentez la valeur étape par étape. Vérifiez le comportement pour chaque changement à l'aide de la trace d'échantillonnage. Dès que vous détectez des fluctuations, la limite supérieure est atteinte. Diminuez maintenant la valeur de fKp d'environ 10 % et spécifiez-le sur le SoftMotion Drive : contrôle de position onglet dans la boucle de contrôle à Kp . Vous pouvez maintenant utiliser l'axe. " }, 
{ "title" : "Bloc fonctionnel : SMC_PosControlInput ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_666f8939fd0b11e3b1f5b5a0173eacdc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Exemples \/ Contrôle de position sur le contrôleur avec SM_Drive_PosControl \/ Bloc fonctionnel : SMC_PosControlInput ", 
"snippet" : "Une bibliothèque: SM3_Drive_PosControl Entrées (VAR_INPUT) Nom Type de données Valeur initiale La description bLimitPos BOOL Fin de course dans le sens positif (uniquement pour les axes finis) Depuis SoftMotion version 4.12.0.0, la surveillance des interrupteurs de fin de course est activée par défa...", 
"body" : "Une bibliothèque: SM3_Drive_PosControl Entrées (VAR_INPUT) Nom Type de données Valeur initiale La description bLimitPos BOOL Fin de course dans le sens positif (uniquement pour les axes finis) Depuis SoftMotion version 4.12.0.0, la surveillance des interrupteurs de fin de course est activée par défaut. Pour les anciennes versions, cela doit être activé manuellement en paramétrant bHWLimitEnable à TRUE . Cela se fait généralement en écrivant le numéro de paramètre correspondant 1206 au moyen de MC_WriteBoolParameter . TRUE : Fin de course non actionné FALSE : Fin de course actionné bLimitNeg BOOL Fin de course dans le sens négatif TRUE : Fin de course non actionné FALSE : Fin de course actionné wActPosition WORD Position actuelle (position réelle) en tant que valeur 16 bits dwActPosition DWORD Position actuelle (position réelle) en tant que valeur 32 bits bExternalError BOOL Erreur externe bRegulatorRealState BOOL TRUE : Axe contrôlé bDriveStartRealState BOOL FALSE : Axe en Quick Stop dwEncoderCounterModulo DWORD 0 bDelayActivation BOOL TRUE : Tant que bDelayActivation est TRUE , SM3_Drive_PosControl ne passe pas à l'état de communication 100 . Cas d'utilisation : la valeur est maintenue à TRUE jusqu'à ce que le codeur appliqué donne des valeurs de position valides. " }, 
{ "title" : "Bloc fonctionnel : SMC_PosControlOutput ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_60809817bdae11e9b2a8cd92ec450e2f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Exemples \/ Contrôle de position sur le contrôleur avec SM_Drive_PosControl \/ Bloc fonctionnel : SMC_PosControlOutput ", 
"snippet" : "Une bibliothèque: SM3_Drive_PosControl Sorties (VAR_OUTPUT) Nom Type de données Valeur initiale La description bRegulatorOnIn BOOL TRUE : L'axe doit être contrôlé. bDriveStart BOOL FALSE : L'axe doit exécuter un arrêt rapide. diSetVelocity DINT Définir la vitesse iSetVelocity INT Définir la vitesse...", 
"body" : "Une bibliothèque: SM3_Drive_PosControl Sorties (VAR_OUTPUT) Nom Type de données Valeur initiale La description bRegulatorOnIn BOOL TRUE : L'axe doit être contrôlé. bDriveStart BOOL FALSE : L'axe doit exécuter un arrêt rapide. diSetVelocity DINT Définir la vitesse iSetVelocity INT Définir la vitesse " }, 
{ "title" : "Bloc fonction : SMC_SetPosControlParams ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_6080e639bdae11e9b2a8cd92ec450e2f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Exemples \/ Contrôle de position sur le contrôleur avec SM_Drive_PosControl \/ Bloc fonction : SMC_SetPosControlParams ", 
"snippet" : "Une bibliothèque: SM3_Drive_PosControl Modifie les paramètres d'un SM3_Drive_PosControl axe Entrées (VAR_INPUT) Nom Type de données Valeur initiale La description Axis AXIS_REF_POSCONTROL Référence de l'axe bExecute BOOL TRUE : Active l'exécution du bloc fonction fKp LREAL -1 Gain proportionnel pour...", 
"body" : "Une bibliothèque: SM3_Drive_PosControl Modifie les paramètres d'un SM3_Drive_PosControl axe Entrées (VAR_INPUT) Nom Type de données Valeur initiale La description Axis AXIS_REF_POSCONTROL Référence de l'axe bExecute BOOL TRUE : Active l'exécution du bloc fonction fKp LREAL -1 Gain proportionnel pour le décalage Une valeur inférieure à 0 est ignorée. fPartVelPilotControl LREAL -1 Facteur pour le contrôle de la vitesse avec fSetPosition 0 : pas de contrôle pilote de vitesse ; 1 : sortie directe de fSetVelocity . Une valeur inférieure à 0 est ignorée. fDeadTime LREAL -1 Décalage temporel en cycles entre fSetPosition et fActPositioin Cette valeur ne doit pas être 0. Une valeur inférieure à 0 est ignorée. fMaxPositionDiff LREAL -1 décalage de position maximum 0 désactive le contrôle du décalage de position maximum. Une valeur inférieure à 0 est ignorée. Sorties (VAR_OUTPUT) Nom Type de données Valeur initiale La description bDone BOOL L'exécution du bloc fonction est terminée. bError BOOL TRUE : Une erreur s'est produite dans le bloc fonction. ErrorID SMC_ERROR Identification des erreurs Exemple Les paramètres du variateur d'axe SM_Drive_PosControl sont fixés. PROGRAM PLC_PRG\nVAR\n fbSetPosControlParams : SMC_SetPosControlParams;\nEND_VAR\n\nfbSetPosControlParams.fKp := 1;\nfbSetPosControlParams.fPartVelPilotControl :=0;\nfbSetPosControlParams.fDeadTime :=0.1;\nfbSetPosControlParams.fMaxPositionDiff :=1;\n\nfbSetPosControlParams(Axis:= SM_Drive_PosControl, bExecute:= TRUE); " }, 
{ "title" : "Interface utilisateur ", 
"url" : "_sm_drives_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interface utilisateur ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Commande : Ajouter SoftMotion Axe CiA402 ", 
"url" : "_sm_cmd_add_softmotion_cia402_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interface utilisateur \/ Commande : Ajouter SoftMotion Axe CiA402 ", 
"snippet" : "Ajouter SoftMotion Axe CiA402 Fonction : La commande ajoute un général SoftMotion Axe CiA402 sous un esclave de bus de terrain dans l'arborescence des appareils. Appel : Projet menu; menu contextuel d'un objet périphérique dans l'arborescence des périphériques Exigence : Dans l'arborescence des péri...", 
"body" : "Ajouter SoftMotion Axe CiA402 Fonction : La commande ajoute un général SoftMotion Axe CiA402 sous un esclave de bus de terrain dans l'arborescence des appareils. Appel : Projet menu; menu contextuel d'un objet périphérique dans l'arborescence des périphériques Exigence : Dans l'arborescence des périphériques, un périphérique compatible avec ce lecteur est sélectionné. Exemples : esclave EtherCAT ou esclave CAN Le fichier ESI du lecteur contient l'entrée indiquant qu'il s'agit d'un axe CiA402 ( ProfileNo 402 ). La commande insère un axe CiA402 générique. Pour plus d'informations, consultez les rubriques suivantes : Configuration de l'axe générique CiA402 " }, 
{ "title" : "Commande : Ajouter SoftMotion Axe Sercos ", 
"url" : "_sm_cmd_add_softmotion_sercos_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interface utilisateur \/ Commande : Ajouter SoftMotion Axe Sercos ", 
"snippet" : "Ajouter SoftMotion Axe Sercos Fonction : La commande ajoute un général SoftMotion Axe Sercos sous un module Sercos. Appel : Projet menu; menu contextuel du Sercos Slave Exigence : Un esclave Sercos approprié est sélectionné dans l'arborescence des appareils. Les axes Sercos ne sont plus pris en char...", 
"body" : "Ajouter SoftMotion Axe Sercos Fonction : La commande ajoute un général SoftMotion Axe Sercos sous un module Sercos. Appel : Projet menu; menu contextuel du Sercos Slave Exigence : Un esclave Sercos approprié est sélectionné dans l'arborescence des appareils. Les axes Sercos ne sont plus pris en charge pour SoftMotion Version 4.17.0.0 et supérieure. Cette commande est utilisée pour que n'importe quel servomoteur fonctionne avec CODESYS SoftMotion . Le variateur doit uniquement prendre en charge la norme Sercos. CODESYS utilise un pilote standard pour communiquer avec le périphérique. La manière dont le variateur fonctionne ou non avec l'appareil dépend de l'implémentation dans l'appareil lui-même. Par conséquent, il n'y a aucune garantie sur le fonctionnement ou non du pilote avec l'appareil. Le pilote Sercos générique prend en charge les appareils multi-axes jusqu'à huit axes. " }, 
{ "title" : "Commande : Ajouter SoftMotion Axe SoE ", 
"url" : "_sm_cmd_add_softmotion_soe_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interface utilisateur \/ Commande : Ajouter SoftMotion Axe SoE ", 
"snippet" : "Ajouter SoftMotion Axe SoE Fonction : La commande ajoute un général SoftMotion Axe SoE sous un esclave EtherCAT. Appel : Projet menu; menu contextuel de l'esclave Exigence : Un esclave EtherCAT approprié est sélectionné dans l'arborescence des appareils. Cette commande est utilisée pour que n'import...", 
"body" : "Ajouter SoftMotion Axe SoE Fonction : La commande ajoute un général SoftMotion Axe SoE sous un esclave EtherCAT. Appel : Projet menu; menu contextuel de l'esclave Exigence : Un esclave EtherCAT approprié est sélectionné dans l'arborescence des appareils. Cette commande est utilisée pour que n'importe quel servomoteur fonctionne avec CODESYS SoftMotion . Le servo variateur doit uniquement prendre en charge la norme SoE. CODESYS utilise un pilote standard pour communiquer avec le périphérique. La manière dont le variateur fonctionne ou non avec l'appareil dépend de l'implémentation dans l'appareil lui-même. Par conséquent, il n'y a aucune garantie sur le fonctionnement ou non du pilote avec l'appareil. Le pilote SoE générique prend en charge les périphériques multiaxes jusqu'à huit axes. " }, 
{ "title" : "SoftMotion Disques ", 
"url" : "_sm_f_reference_object_sm_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interface utilisateur \/ SoftMotion Disques ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Onglet : Général ", 
"url" : "_sm_edt_drive_general.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interface utilisateur \/ SoftMotion Disques \/ Onglet : Général ", 
"snippet" : "Type d'axe et paramètres Type d'axe Mode virtuel : Le lecteur est remplacé par une simulation similaire à une unité d'entraînement virtuelle. Lorsqu'il existe un entraînement couplé, cela n'a aucun effet sur le périphérique de bus de terrain. Ils fonctionnent normalement sans envoyer ni recevoir de ...", 
"body" : "Type d'axe et paramètres Type d'axe Mode virtuel : Le lecteur est remplacé par une simulation similaire à une unité d'entraînement virtuelle. Lorsqu'il existe un entraînement couplé, cela n'a aucun effet sur le périphérique de bus de terrain. Ils fonctionnent normalement sans envoyer ni recevoir de messages depuis ou vers un appareil physique. Remarque : Vous pouvez également définir et réinitialiser un mode virtuel d'un variateur en code CEI à l'aide de la SMC3_ReinitDrive bloc fonctionnel. Modulo : L'entraînement tourne sans fin sans limiter la plage de déplacement (exemple : entraînement par courroie). Valeur modulo [u] : Valeur d'un cycle (période modulo) La valeur est enregistrée dans le fPositionPeriod paramètre de la AXIS_REF_SM3 bloc fonctionnel. Remarque : si vous sélectionnez le Modulo type de lecteur, puis le produit fPositionPeriod * dwRatioTechUnitsDenom doit être un entier. Fini : Le variateur a une zone de travail fixe (exemple : un variateur linéaire). Fins de course logiciels Activé : Les valeurs de position sont limitées par la limite inférieure Négatif et une limite supérieure Positif . Négatif : Champ de saisie pour la valeur limite négative Positif : Champ de saisie pour la valeur limite positive Type de moteur Rotary : les paramètres de Dimensionnement s'appliquent aux moteurs rotatifs. Linéaire : les paramètres de Dimensionnement s'appliquent aux moteurs linéaires. (Configuration simplifiée sans engrenages ni tours de moteur) Type de rampe de vélocité Définit le profil de vitesse pour les modules monoaxes et maître\/esclave générateurs de mouvements : Remarque : les types de rampes Pins² et Quadratique (lisse) ne sont pas pris en charge pour la robotique. Trapèze : Profil de vitesse trapézoïdal (avec accélération constante dans chaque segment) Pins² : Un profil de vitesse tel que défini par la fonction sin² (avec une courbe d'accélération constante). Quadratique : Profil d'accélération en forme trapézoïdale avec limitation des secousses Quadratique (lisse) : Comme Quadratique mais génère un profil de secousse sans sauts. Identification IDENTIFIANT Identifiant entier. Doit être unique pour chaque lecteur. Par exemple, cet identifiant est utilisé dans le journal du PLC afin d'identifier le variateur en cas d'erreur. Temps mort Cycles Le temps mort par cycles entre fActPosition et le fSetPosition au début de ce cycle Limites dynamiques Les valeurs limites des POU PLCopen Part 4 sont prises en compte. De plus, ils sont utilisés par les POU des bibliothèques sous le nom SMC_ControlAxisBy* pour détecter les sauts. Vélocité [u\/s] Valeur limite de la vitesse, de l'accélération, de la décélération et de la secousse Accélération [u\/s²] Décélération [u\/s²] Secousse [u\/s³] Surveillance et réaction aux erreurs Limites logicielles Activé : les valeurs de position sont limitées par la limite inférieure Négatif et une limite supérieure Positif . Négatif : Champ de saisie pour la valeur limite négative Positif : Champ de saisie pour la valeur limite positive Réaction à une erreur logicielle Causes d'une erreur logicielle Atteindre un interrupteur de limite logiciel Dépassement du décalage logiciel maximal autorisé Pour les axes finis : trop de débordements de 32 bits MC_Power.bRegulatorOn = FALSE lors d'un mouvement actif (erreur : SMC_FB_ACTIVE_AXIS_DISABLED ) Bloc de fonctions de mouvement avec Busy=TRUE non appelé (erreur : SMC_FB_WASNT_CALLED_DURING_MOTION ) Pour la réaction à une erreur logicielle, Décélération , le Max. , et la décélération des limites dynamiques sont prises en compte. Une décélération est également calculée à partir de la distance maximale. La plus élevée de ces valeurs de décélération est utilisée pour la rampe d'erreur Décélération [u\/s²] : Décélération de la rampe d'erreur Distance maximale [u] Facultatif Le lecteur doit s'être arrêté à cette distance après qu'une erreur se soit produite. Surveillance du décalage de position Réponse du système à un décalage détecté. Un décalage est détecté lorsque la différence entre la position réglée et la position réelle compensée dépasse la limite de décalage. La position réelle extrapolée est calculée selon la formule suivante : extrapolated actual position := actual position + actual velocity * cycle time * Axis.fSetActTimeLagCycles Cette valeur est la position réelle de l'axe compensée par le temps mort. Remarque : Si vous surveillez le décalage, vous devez déterminer et saisir le temps mort. Pour une description, reportez-vous au chapitre suivant : Valeurs réelles, valeurs définies et temps mort. Remarque : la surveillance du décalage n'est pas disponible pour les lecteurs virtuels. Désactivé Pas de réponse La surveillance du décalage est désactivée. Désactiver le lecteur Le bRegulatorOn bit est obligé de FALSE (comparer avec MC_Power input) qui force d'abord la décélération du variateur puis sa désactivation (en fonction de la mise en œuvre du variateur). Effectuez un arrêt rapide Le bDriveStart bit est obligé de FALSE (comparer avec MC_Power entrée) qui force le variateur à effectuer un arrêt rapide. Restez activé Le variateur reste allumé, mais tous les mouvements de course sont interrompus brusquement. Limite de décalage : Surveillance du décalage dans le contrôleur Une surveillance indépendante peut également exister dans le lecteur, mais elle n'est pas configurée dans cette boîte de dialogue. En ligne Condition préalable : l'automate est en mode connecté. Tableau des variables Liste des variables d'entraînement avec nom de variable, Définir la valeur et Valeur actuelle Statut Affichage de l'état actuel du variateur SoftMotion Paramètres de communication Affichage de l'état actuel de la communication Erreur Erreur d'axe Erreur FB uiDriveInterfaceError strDriveInterfaceError Pour plus d'informations, consultez : Détermination du temps mort du systèmeExemple Les images suivantes illustrent l'effet des différents types de rampes. La position est dessinée en vert, la vitesse en bleu et l'accélération en rouge. trapèze La vitesse est partiellement linéaire et continue, tandis que l'accélération partiellement constante indique des sauts. Sin² Les ruptures du profil de vitesse sont lissées (en utilisant la fonction sin² à la place des lignes) pour réduire les sauts d'accélération. L'utilisateur ne peut pas limiter l'à-coup pour ce type de rampe. L'à-coup maximum réglé n'a d'effet que si l'accélération n'est pas égale à zéro au début du mouvement et que la rampe de décélération et d'accélération interrompue ne peut pas être poursuivie sans interruption. Ensuite, en tenant compte de la limite d'à-coup, l'accélération est réduite à zéro avant le démarrage du mouvement en cours. Par rapport au profil de vitesse trapézoïdal, la décélération prend plus de temps dans ce cas. Quadratique L'accélération est partiellement linéaire et continue et la secousse a des sauts. La vitesse se compose de segments quadratiques et linéaires. Quadratique (lisse) Les rampes d'accélération linéaires de type rampe quadratique sont remplacées par une fonction \"lisse\" avec une valeur de pente nulle en début et en fin. En conséquence, la secousse est également continue. Remarque : Si un mouvement est interrompu, des interruptions de l'à-coup peuvent se produire. Pour plus d'informations, voir : Interruption des mouvements" }, 
{ "title" : "Onglet : Mise à l'échelle\/Mappage ", 
"url" : "_sm_edt_drive_scaling_mapping.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interface utilisateur \/ SoftMotion Disques \/ Onglet : Mise à l'échelle\/Mappage ", 
"snippet" : "Sur cet onglet, vous pouvez définir la relation entre les unités techniques (par exemple, millimètres ou degrés) et les unités d'entraînement (incréments). En fonction de la description de l'appareil, les options de réglage s'affichent de manière simplifiée (paramètre bHiresMode = TRUE ), et\/ou une ...", 
"body" : "Sur cet onglet, vous pouvez définir la relation entre les unités techniques (par exemple, millimètres ou degrés) et les unités d'entraînement (incréments). En fonction de la description de l'appareil, les options de réglage s'affichent de manière simplifiée (paramètre bHiresMode = TRUE ), et\/ou une mise à l'échelle pour les moteurs linéaires peut également être possible (paramètre IsLinearMotor = TRUE ). Si nécessaire, vous pouvez également influencer le mappage des objets entraînement transmis cycliquement aux variables CEI. Mise à l'échelle Inverser le sens : Le sens de rotation est inversé. Le moteur obtient les valeurs spécifiées avec des signes opposés. Précision (chiffres décimaux) Condition : La description de l'appareil indique une boîte de dialogue de configuration simplifiée (paramètre bHiresMode = TRUE ). Dans ce cas, les paramètres cachés obtiennent la valeur par défaut de 1 . Nombre de décimales pour les unités utilisateur des incréments à mettre à l'échelle et à transférer. Par exemple, 3 correspond à une précision de 10 3 . incréments <=> tours moteur Nombre d'incréments correspondant à un nombre donné de tours moteur. Vous pouvez voir le paramètre sur le Configuration onglet de l'éditeur d'appareils. le moteur tourne <=> la sortie de l'engrenage tourne Nombre de tours du moteur correspondant à un nombre donné de tours de sortie de l'engrenage. la sortie de l'engrenage tourne <=> unités dans l'application Nombre de tours de sortie d'engrenage correspondant à une unité dans l'application. Exemple de configuration complète Dans l'exemple de configuration, un variateur qui a 3600 incréments pour un tour de moteur est mis à l'échelle de sorte que les unités techniques de l'application soient des degrés angulaires droits. Cartographie Remarque : ces paramètres ne sont pas disponibles pour Drive_PosControl. Cartographie automatique : Les paramètres CEI qui affectent le variateur sont automatiquement mappés sur les entrées et sorties correspondantes de l'appareil. Après désactivation de l'option, la cartographie peut être éditée manuellement. Pour ce faire, modifiez l'adresse ou le type des entrées et sorties dans la liste de paramètres affichée qui a été créée conformément au fichier de description de l'appareil. " }, 
{ "title" : "Mise en service Languette ", 
"url" : "_sm_edt_drive_commisioning.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interface utilisateur \/ SoftMotion Disques \/ Mise en service Languette ", 
"snippet" : "Vous pouvez déplacer le lecteur au moyen des boutons sur cette page. Le lecteur peut effectuer des mouvements inattendus. Prenez toutes les précautions de sécurité nécessaires. Cet onglet est utilisé à des fins de test lors de la mise en service des disques physiques. Il n'est disponible que si le M...", 
"body" : "Vous pouvez déplacer le lecteur au moyen des boutons sur cette page. Le lecteur peut effectuer des mouvements inattendus. Prenez toutes les précautions de sécurité nécessaires. Cet onglet est utilisé à des fins de test lors de la mise en service des disques physiques. Il n'est disponible que si le Mode de configuration en ligne est autorisé. Dans ce mode, le système de développement est connecté à l'appareil ; cependant, une application n'a pas besoin d'être téléchargée. En ligne Condition préalable : l'automate est en mode connecté. Tableau des variables Liste des variables d'entraînement avec nom de variable, Définir la valeur et Valeur actuelle Statut Affichage de l'état actuel du variateur SoftMotion Paramètres de communication Affichage de l'état actuel de la communication Erreur Erreur d'axe Erreur FB uiDriveInterfaceError strDriveInterfaceError " }, 
{ "title" : "Éléments de commande ", 
"url" : "_sm_edt_drive_commisioning.html#UUID-44ff80c7-7f0e-b818-51b8-af95752bbbbd_id_b3c83ad0f91194c0a8646325634a44_id_063bbc9a58bd11e68fa9d28177272265", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interface utilisateur \/ SoftMotion Disques \/ Mise en service Languette \/ Éléments de commande ", 
"snippet" : "Éléments de commande Puissance Le variateur est alimenté (comparer avec MC_Power ). Erreur de réinitialisation Réinitialise le variateur suite à une erreur (comparer avec MC_Reset ). Commencer le ralliement Le variateur exécute le référencement avec les paramètres réglés dans le variateur (comparer ...", 
"body" : "Éléments de commande Puissance Le variateur est alimenté (comparer avec MC_Power ). Erreur de réinitialisation Réinitialise le variateur suite à une erreur (comparer avec MC_Reset ). Commencer le ralliement Le variateur exécute le référencement avec les paramètres réglés dans le variateur (comparer avec MC_Home ). Le jogging Au moyen des commutateurs < et >, l'entraînement peut être déplacé vers l'avant et vers l'arrière selon les valeurs spécifiées pour Distance , Rapidité , Accélération , Ralentissement , et Secousse (comparer avec MC_Inch ). Lire écrire Pour le paramètre d'entraînement spécifié, le courant Valeur est lu depuis l'automate et affiché. Dans Valeur préparée , vous pouvez spécifier une nouvelle valeur et écrire dans le paramètre du variateur à l'aide du petit bouton (comparer avec MC_ReadParameter , MC_WriteParameter ). " }, 
{ "title" : "Onglet : SoftMotion Drive – Contrôle de position ", 
"url" : "_sm_edt_drive_poscontrol_position_control_loop.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interface utilisateur \/ SoftMotion Disques \/ Onglet : SoftMotion Drive – Contrôle de position ", 
"snippet" : "Dans cet onglet, vous définissez les paramètres du contrôle de position. Veuillez également noter l'exemple Contrôle de position sur le contrôleur avec SM_Drive_PosControl. Boucle de contrôle de position fDéfinirPosition Définir la valeur de position D Le temps mort détermine le nombre de cycles pen...", 
"body" : "Dans cet onglet, vous définissez les paramètres du contrôle de position. Veuillez également noter l'exemple Contrôle de position sur le contrôleur avec SM_Drive_PosControl. Boucle de contrôle de position fDéfinirPosition Définir la valeur de position D Le temps mort détermine le nombre de cycles pendant lesquels la position réelle reçue (codeur) est déphasée vers la position définie de l'axe. Le temps mort dépend des composants appliqués et doit être déterminé par essais et erreurs. Pour plus d'informations, consultez : Détermination du temps mort du systèmefActPosition Valeur de position réelle Largeur de bits La largeur de bit de la valeur réelle est reçue en fonction des composants utilisés et peut être définie sur des valeurs de 16, 24 ou 32 bits. Max : La surveillance des erreurs de position est activée. Saisie du décalage maximum autorisé Si cette valeur est dépassée pendant le fonctionnement, l'axe passe dans un état d'erreur. Kp La constante de proportionnalité est le facteur par lequel l'erreur de position (l'écart entre la position définie et la position réelle) est multipliée pour être ajoutée ultérieurement à la vitesse définie. fSetVelocity Définir la valeur de vélocité Mise à l'échelle de la sortie de vitesse fActPosition et la sortie de vitesse ont des directions opposées : Si la sortie de vitesse et la position actuelle ont un sens opposé, cela est corrigé en activant l'option. Candidature [tu\/s] Valeur de vitesse minimale et maximale (en unités d'application) par exemple 3600 rotations par seconde. Valeur de sortie Valeur de sortie minimale et maximale envoyée à l'actionneur (par exemple 16#7FFF). " }, 
{ "title" : "Axes logiques Languette ", 
"url" : "_sm_edt_drive_logical_general.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interface utilisateur \/ SoftMotion Disques \/ Axes logiques Languette ", 
"snippet" : "Type d'axe Modulo : L'entraînement tourne à l'infini sans limitation de la plage de déplacement (exemple : entraînement par courroie). Paramètres modulo Valeur modulo : Valeur d'un cycle La valeur est enregistrée dans le fPositionPeriod paramètre de la AXIS_REF_SM3 bloc fonction. Remarque : si vous ...", 
"body" : "Type d'axe Modulo : L'entraînement tourne à l'infini sans limitation de la plage de déplacement (exemple : entraînement par courroie). Paramètres modulo Valeur modulo : Valeur d'un cycle La valeur est enregistrée dans le fPositionPeriod paramètre de la AXIS_REF_SM3 bloc fonction. Remarque : si vous sélectionnez le Modulo type de lecteur, puis le produit fPositionPeriod * dwRatioTechUnitsDenom doit être un entier. Fini : Le variateur a une zone de travail fixe (exemple : un variateur linéaire). Négatif : Champ de saisie pour la valeur limite négative Positif : Champ de saisie pour la valeur limite positive Valeur de référence maître Régler : La valeur de consigne du maître est utilisée comme entrée pour l'axe logique et la compensation de temps mort. Réel : La valeur réelle du maître est utilisée comme entrée pour l'axe logique et la compensation de temps mort. Décalage horaire Décalage temporel par rapport aux valeurs maîtres Nombre de cycles Les valeurs de consigne doivent être extrapolées dans ce laps de temps Filtres de données d'entrée Les filtres permettent de lisser les valeurs de position et de vitesse d'un codeur à l'aide d'un filtre PT1. Position Nombre de cycles utilisé comme constante de temps du filtre PT1. Plage de valeurs : [0..999.9] Valeur 0 : aucun filtrage n'est effectué (les valeurs brutes sont renvoyées). La valeur de retour filtrée est une combinaison d'un signal de position filtré PT1 et d'une extrapolation de position supplémentaire utilisant le signal de vitesse. L'extrapolation elle-même utilise également un filtre PT1 pour atténuer le bruit et sélectionne automatiquement une constante de temps appropriée : Si seules les valeurs de consigne doivent être filtrées ou si l'axe envoie le signal de vitesse, la constante de temps de l'extrapolation PT1 est la même que pour le filtre de position PT1. Sinon, une approche heuristique est utilisée : T Extrapolate = (T Pos + T Dead ) * T Pos \/ T Cycle T Extrapolate :  Constante de temps du filtre d'extrapolation PT1 T Pos : Constante de temps du filtre de position PT1 T Cycle : Temps d'un cycle T Dead : Compensation du temps mort, utilisant le décalage temporel par rapport aux valeurs pilotes de l'axe logique  n Shift  et le temps de cycle  T Cycle : T Dead = n Shift * T Cycle Rapidité Nombre de cycles utilisé comme constante de temps du filtre PT1. Plage de valeurs : [0..999.9] Valeur 0 : aucun filtrage n'est effectué (les valeurs brutes sont renvoyées). La valeur de retour filtrée est une combinaison d'un signal de vitesse filtré PT1 et d'une extrapolation de vitesse supplémentaire utilisant le signal d'accélération. Notez que l'extrapolation n'est utilisée que si l'axe envoie un signal de vitesse ou si les points de consigne doivent être filtrés. L'extrapolation elle-même utilise également un filtre PT1 pour atténuer le bruit et sélectionne automatiquement une constante de temps appropriée : T Extrapolate = (T Vel + T Dead ) * T Vel \/ T Cycle avec T Extrapolate : Constante de temps du filtre d'extrapolation PT1 T Vel : Constante de temps du filtre de vitesse PT1 T Cycle : Temps d'un cycle T Dead : Compensation du temps mort, utilisant le décalage temporel par rapport aux valeurs pilotes de l'axe logique  n Shift   et le temps de cycle  T Cycle : T Dead = n Shift * T Cycle Signal de vitesse de l'axe logique ( fActVelocity ): Cas 1: Valeur de référence maître = Régler fSetVelocity de l'axe maître est utilisée comme valeur brute pour le signal de vitesse de l'axe logique. Cas 2 : Valeur de référence maître = Réel et pas de signal de vitesse de l'axe maître. La dérivée numérique de la position filtrée de l'axe logique ( fActPosition ) sert de valeur brute pour le signal de vitesse de l'axe logique. Cas 3 : Valeur de référence maître = Réel et un signal de vitesse de l'axe maître. Le signal de vitesse est utilisé comme valeur brute pour le signal de vitesse de l'axe logique. Un filtrage de vitesse est effectué sur ce signal brut. Cela signifie que s'il est configuré avec la valeur par défaut usiFilterDepthVelocity = 0 , alors ce signal est transmis tel quel à fActVelocity . Dans le cas 2, il serait également possible d'utiliser la dérivée numérique de la position non filtrée ( fActPosition de l'axe maître). La position filtrée a été sélectionnée car dans ce cas la fActVelocity de l'axe logique correspond à la fActPosition dans la configuration par défaut sans filtrage de vitesse. Pour la vitesse, l'extrapolation du retard du filtre n'est effectuée que dans les cas 1 et 3. Dans le cas 2, ce ne serait pas numériquement stable ou cela nécessiterait trop de filtrage de l'accélération pour être significatif. Accélération de l'axe logique ( fActAcceleration ) Cas 1: Valeur de référence maître = Régler fSetAcceleration de l'axe maître est utilisé pour le signal d'accélération de l'axe logique. Cas 2 : Valeur de référence maître = Réel et un signal de vitesse de l'axe maître. La dérivée numérique de la vitesse filtrée de l'axe logique ( fActVelocity ) est utilisé pour le signal d'accélération de l'axe logique. Cas 3 : Valeur de référence maître = Réel et pas de signal de vitesse de l'axe maître. La valeur 0 est utilisé pour le signal d'accélération de l'axe logique car différencier deux fois une position bruitée conduit à des résultats inexploitables. Jerk de l'axe logique ( fActJerk ) L'à-coup de l'axe logique ( fActJerk ) est soit Cas 1: Valeur de référence maître = Régler fSetJerk de l'axe maître est utilisé pour le signal d'à-coup de l'axe logique. Cas 2 : Valeur de référence maître = Réel La valeur 0 est utilisé pour le signal d'à-coup de l'axe logique car différencier trois fois un signal de position bruité conduit à des résultats inexploitables. Aucune compensation de temps mort n'est effectuée pour le signal d'accélération et d'à-coup. Toutes les valeurs de consigne (position, vitesse, accélération et à-coup) de l'axe logique correspondent aux valeurs réelles. Écrire des valeurs Écrit les valeurs de Filtres de données d'entrée et Décalage horaire sur l'automate. Identification identifiant ID unique de l'axe logique En ligne Condition préalable : l'automate est en mode connecté. Tableau des variables Liste des variables d'entraînement avec nom de variable, Définir la valeur et Valeur actuelle Statut Affichage de l'état actuel du variateur SoftMotion Paramètres de communication Affichage de l'état actuel de la communication Erreur Erreur d'axe Erreur FB uiDriveInterfaceError strDriveInterfaceError " }, 
{ "title" : "Onglet : Encodeur ", 
"url" : "_sm_edt_drive_free_encoder_general.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Interface utilisateur \/ SoftMotion Disques \/ Onglet : Encodeur ", 
"snippet" : "Paramètres généraux de l'encodeur Modulo Dans un variateur modulo, cette option doit être activée et un Valeur modulo spécifié. : L'entraînement tourne sans fin sans limiter la plage de déplacement (exemple : entraînement par courroie). Les Paramètres modulo la fenêtre s'affiche : Valeur modulo : Ch...", 
"body" : "Paramètres généraux de l'encodeur Modulo Dans un variateur modulo, cette option doit être activée et un Valeur modulo spécifié. : L'entraînement tourne sans fin sans limiter la plage de déplacement (exemple : entraînement par courroie). Les Paramètres modulo la fenêtre s'affiche : Valeur modulo : Champ de saisie pour la valeur modulo La valeur est enregistrée dans le fPositionPeriod paramètre de la AXIS_REF_SM3 bloc fonction. Remarque : si vous sélectionnez le Modulo type de lecteur, puis le produit fPositionPeriod * dwRatioTechUnitsDenom doit être un entier. Fini : Le lecteur est limité. Largeur de bits Zone de liste pour une largeur de bits appropriée Mise à l'échelle Définition de la conversion des valeurs de position entières qui sont envoyées par l'appareil ; par incréments et unités techniques qui sont utilisés dans une application CEI. Inverser le sens : Le codeur reçoit les valeurs spécifiées avec des signes inversés et tourne donc dans le sens de rotation opposé. incréments < = > rotations codeur Nombre de incréments qui correspondent au nombre de complets rotations de l'encodeur rotations codeur <=> unités en application Nombre de l'encodeur tourne qui correspondent à unités en application En ligne Condition préalable : l'automate est en mode connecté. Tableau des variables Liste des variables d'entraînement avec nom de variable, Définir la valeur et Valeur actuelle Statut Affichage de l'état actuel du variateur SoftMotion Paramètres de communication Affichage de l'état actuel de la communication Erreur Erreur d'axe Erreur FB uiDriveInterfaceError strDriveInterfaceError " }, 
{ "title" : "CODESYS Softmotion Basic ", 
"url" : "_sm_basic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Aperçu ", 
"url" : "_sm_overview_basic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Aperçu ", 
"snippet" : "CODESYS Softmotion Basic fournit une interface pour les blocs fonctionnels pour le contrôle de mouvement des axes individuels. Cette interface est basée sur la spécification PLCopen « Blocs fonctionnels pour le contrôle de mouvement Partie 1 V2.0 ». La planification de la trajectoire se fait dans le...", 
"body" : "CODESYS Softmotion Basic fournit une interface pour les blocs fonctionnels pour le contrôle de mouvement des axes individuels. Cette interface est basée sur la spécification PLCopen « Blocs fonctionnels pour le contrôle de mouvement Partie 1 V2.0 ». La planification de la trajectoire se fait dans le CODESYS manette. La gamme de fonctions s'étend du mouvement à une position ou vitesse cible, en passant par la superposition de deux mouvements et les mouvements synchronisés, jusqu'aux engrenages et cames virtuels. Les commandes de mouvement peuvent être mises en mémoire tampon et interrompues avec une précision de cycle, ainsi que décélérées ou arrêtées et reprises via une dérogation. " }, 
{ "title" : "Commencer avec CODESYS Softmotion Basic ", 
"url" : "_sm_basic_first_steps.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commencer avec CODESYS Softmotion Basic ", 
"snippet" : "Pour programmer un mouvement avec CODESYS Softmotion Basic , au moins un axe doit être configuré dans l'arborescence des appareils. Cela inclut la définition du type d'axe ( module ou fini ), le type de rampe de vitesse, les fins de course logiciels et la réaction aux erreurs. Vous trouverez un aper...", 
"body" : "Pour programmer un mouvement avec CODESYS Softmotion Basic , au moins un axe doit être configuré dans l'arborescence des appareils. Cela inclut la définition du type d'axe ( module ou fini ), le type de rampe de vitesse, les fins de course logiciels et la réaction aux erreurs. Vous trouverez un aperçu des codes mouvement pris en charge dans le Mouvements sur un seul axe chapitre. Pour plus d'informations sur la programmation d'un mouvement sur un seul axe, consultez le Contrôle du mouvement des axes simples chapitre. Pour plus d'informations sur l'utilisation de base des cames, consultez le Contrôle d'un entraînement à cames avec un axe de temps virtuel chapitre. Pour plus d'informations sur la mise en mémoire tampon, le mélange et la superposition de mouvements, consultez le Commander plusieurs mouvements section. Pour plus d'informations, voir : Vue générale de CamesChapitre: Basculer entre les camérasCréation d'une cam en ligne depuis l'application : Structures de données des camesChapitre: Adaptation dynamique avec MC_SetOverride" }, 
{ "title" : "Blocs de fonctions administratives ", 
"url" : "_sm_administrative_fbs.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Blocs de fonctions administratives ", 
"snippet" : "Les blocs fonctionnels administratifs sont utilisés pour demander des informations ou modifier des paramètres spécifiques. Cependant, ils ne déclenchent jamais de mouvement. Un lecteur physique (appelé lecteur à partir de maintenant) est représenté dans CODESYS SoftMotion par l'objet logiciel AXIS_R...", 
"body" : "Les blocs fonctionnels administratifs sont utilisés pour demander des informations ou modifier des paramètres spécifiques. Cependant, ils ne déclenchent jamais de mouvement. Un lecteur physique (appelé lecteur à partir de maintenant) est représenté dans CODESYS SoftMotion par l'objet logiciel AXIS_REF_SM3 (appelé axe à partir de maintenant). Selon le bloc fonctionnel administratif utilisé, l'exécution a lieu soit sur le lecteur, soit sur l'axe, soit sur les deux. Blocs fonctionnels MC_Power Contrôle l'étage de puissance du variateur MC_Reset Réinitialise les erreurs d'axe et les erreurs de conduite MC_SetPosition Déplace le système de coordonnées de l'axe vers n'importe quelle valeur ; par exemple, cela peut être utile pour le référencement. SMC3_BrakeControl Contrôle le frein mécanique lorsque le variateur prend en charge cette fonction SMC3_BrakeStatus Lit l'état actuel du frein mécanique SMC_ChangeDynamicLimits Définit les limites dynamiques (vitesse, accélération, décélération, secousse et couple) d'un axe Pour plus d'informations, consultez les rubriques suivantes : Limites dynamiques dans Onglet : GénéralSMC_ChangeAxisScalingLinear Modifie l'échelle d'un axe linéaire SMC_ChangeAxisScalingRotary Modifie l'échelle d'un axe de rotation SMC_SetForecast Définit le Prévision d'un axe SMC_GetForecast Renvoie la prévision définie pour l'axe SMC_GetTravelTime Renvoie l'heure à laquelle l'axe atteint une position spécifique. Ceci est particulièrement utile lorsqu'il est combiné avec Prévision. SMC_SetAdditionalConversionFactors Définit des facteurs supplémentaires pour la conversion. Par exemple, le facteur de couple peut être utilisé pour prendre en compte une boîte de vitesses SMC_SetControllerMode Définit un mode de fonctionnement différent pour l'axe lorsque le variateur prend en charge cette fonction SMC_SetMovementType Définit le type de mouvement d'un axe virtuel sur limité ou modulo Pour plus d'informations, consultez les rubriques suivantes : Onglet : Général. SMC_SetRampType Définit le type de rampe de vitesse d'un axe Pour plus d'informations, consultez les rubriques suivantes : Type de rampe de vélocité dans le Onglet : Général chapitre SMC_SetSoftwareLimits Définit les limites de position pour des axes limités et la réaction correspondante en cas d'erreur Pour plus d'informations, consultez les rubriques suivantes : Interrupteurs de limite logiciels et Réaction à une erreur logicielle dans le Onglet : Général chapitre MC_TouchProbe Renvoie la position du lecteur lorsqu'un événement déclencheur défini est déclenché MC_AbortTrigger Interrompt les fonctions qui utilisent des événements déclencheurs (exemple : MC_TouchProbe ) SMC_ReadFBError Renvoie l'entrée la plus ancienne de la mémoire d'erreurs du bloc fonctionnel de l'axe. Ces informations peuvent être utilisées pour être affichées dans une visualisation, par exemple. SMC_ClearFBError Supprime l'entrée la plus ancienne de la mémoire des erreurs du bloc fonctionnel de l'axe. SMC_ReadSetPosition Renvoie la position définie de l'axe SMC_ReadSetValues Renvoie la position définie, la vitesse définie, l'accélération et la secousse définies. Prévision est activé, les données peuvent également être interrogées ultérieurement. Pour plus d'informations, consultez les rubriques suivantes : Prévisions SMC_Set MC_ReadActualPosition Renvoie la position réelle du lecteur MC_ReadActualVelocity Renvoie la vitesse réelle du variateur MC_ReadActualTorque Renvoie le couple réel ou la force réelle de l'entraînement MC_ReadAxisError Lit l'erreur sur le lecteur MC_ReadStatus Lit l'état actuel de l'axe SMC_CheckAxisCommunication Renvoie l'état de communication de l'axe SMC_CheckLimits Vérifie si les valeurs définies actuelles dépassent les limites dynamiques définies de l'axe Pour plus d'informations, consultez les rubriques suivantes : SMC_ChangeLimites dynamiques et Limites dynamiques dans Onglet : GénéralSMC_GetTrackingError Renvoie le décalage de l'axe (différence entre la position définie de l'axe et la position réelle du lecteur) SMC_InPosition Indique si le décalage se situe dans une plage configurable SMC_MeasureDistance Renvoie la distance parcourue par l'axe depuis le démarrage du bloc. Cela est particulièrement utile pour les axes modulo MC_ReadBoolParameter Lit une valeur booléenne à partir de l'axe ou du lecteur MC_ReadParameter Lit une valeur depuis l'axe ou le lecteur MC_WriteBoolParameter Ecrit une valeur booléenne sur l'axe ou le lecteur MC_WriteParameter Ecrit une valeur sur l'axe ou le lecteur Blocs de fonctions de diagnostic SMC_AxisDiagnosticLog Ecrit les valeurs définies et les valeurs réelles (position, vitesse et accélération) de l'axe et les transmet de manière cyclique dans un fichier. Cela peut être utile pour diagnostiquer les erreurs et les séquences de mouvements dans d'autres outils. SMC_GetMaxSetVelocity Enregistre la valeur maximale de la vitesse définie de l'axe. Ce bloc fonctionnel peut être utile à des fins de diagnostic. SMC_GetMaxSetAccDec Enregistre la valeur maximale de l'accélération définie de l'axe. Ce bloc fonctionnel peut être utile à des fins de diagnostic. Persister SMC3_PersistPosition Conserve la position d'un axe avec un encodeur absolu Pour plus d'informations sur « Persist », consultez les rubriques suivantes : Persistance d'une position d'axeSMC3_PersistPositionLogical Conserve la position d'un axe logique Pour plus d'informations sur les axes logiques, consultez les rubriques suivantes : Lecteur logique" }, 
{ "title" : "Mouvements sur un seul axe ", 
"url" : "_sm_basic_single_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements sur un seul axe ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Aperçu ", 
"url" : "_sm_overview_single_axis_movement.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements sur un seul axe \/ Aperçu ", 
"snippet" : "CODESYS SoftMotion fait la distinction entre les mouvements qui n'agissent que sur un seul axe et les mouvements dans lesquels deux axes sont synchronisés (par exemple via des cames électroniques ou des engrenages virtuels). Ce dernier est décrit sur le Mouvements synchrones de deux axes page d'aide...", 
"body" : "CODESYS SoftMotion fait la distinction entre les mouvements qui n'agissent que sur un seul axe et les mouvements dans lesquels deux axes sont synchronisés (par exemple via des cames électroniques ou des engrenages virtuels). Ce dernier est décrit sur le Mouvements synchrones de deux axes page d'aide. En principe, les blocs de mouvement qui n'agissent que sur un seul axe peuvent être subdivisés dans les catégories suivantes : Blocs de mouvement Bloc Description MC_MoveAbsolute Exécute un mouvement vers la position spécifiée MC_MoveRelative Exécute un mouvement de la distance spécifiée par rapport à la position actuelle MC_MoveAdditive Exécute un mouvement selon la distance spécifiée par rapport à la dernière position cible commandée d'un autre mouvement (par exemple, depuis MC_MoveAbsolute ) MC_MoveSuperimposed Exécute un mouvement selon la distance relative spécifiée en plus d'un autre mouvement actif (par exemple, depuis MC_MoveAbsolute ). Le mouvement actif n'est pas interrompu. MC_MoveVelocity Exécute un mouvement continu à la vitesse spécifiée SMC_MoveContinuousAbsolute Exécute un mouvement vers la position spécifiée. Dans ce cas, la position cible est atteinte à une vitesse définie qui est ensuite maintenue. SMC_MoveContinuousRelative Exécute un mouvement de la distance spécifiée par rapport à la position actuelle. Dans ce cas, la position cible est atteinte à une vitesse définie qui est ensuite maintenue. MC_Jog Exécute un mouvement continu à la vitesse spécifiée tant que l'axe doit avancer ou reculer SMC_Inch Exécute un mouvement de la distance spécifiée par rapport à la position actuelle tant que l'axe doit avancer ou reculer Arrêt des mouvements Bloc Description MC_Halt Exécute un arrêt contrôlé, interrompt tout mouvement actif et immobilise l'axe. MC_Halt est destiné aux conditions normales de fonctionnement car l'arrêt peut être interrompu par de nouveaux mouvements. De plus, le fonctionnement peut être repris plus facilement après un arrêt car l'axe reste dans un état opérationnel. MC_Stop Exécute un arrêt contrôlé, interrompt tout mouvement actif et immobilise l'axe. MC_Stop est destiné aux situations d'urgence car l'arrêt ne peut être interrompu par de nouveaux mouvements. Une fois l'arrêt effectué, l'axe se trouve à l'état d'arrêt, de sorte qu'aucun nouveau mouvement n'est accepté. De nouveaux mouvements ne sont à nouveau possibles qu'une fois l'arrêt terminé et le Execute l'entrée est réglée sur FALSE . MC_HaltSuperImposed Exécute un arrêt contrôlé de SuperImposed mouvements. Le mouvement sous-jacent n’est pas interrompu dans le processus Retour à destination Bloc Description MC_Home Démarre un référencement de l'axe contrôlé par le variateur. Le fonctionnement et ses paramètres dépendent du variateur et du fabricant. SMC_Homing Démarre un référencement de l'axe contrôlé par le contrôleur MC_SetPosition Ne déplace pas l'axe, mais déplace uniquement le point zéro. De cette manière, le bloc peut être utilisé par exemple pour le référencement. De plus, le bloc peut également être appelé lors d'un mouvement actif. Mouvements spéciaux Bloc Description SMC_FollowPosition Écrit la position définie de l'axe. Cela peut être utilisé pour transmettre vos propres trajectoires calculées à l'axe. SMC_FollowVelocity Écrit la vitesse définie de l'axe. Cela peut être utilisé pour transmettre vos propres trajectoires calculées à l’axe. SMC_FollowPositionVelocity Écrit la position et la vitesse définies de l'axe. Cela peut être utilisé pour transmettre vos propres trajectoires calculées à l'axe. SMC_FollowSetValues Écrit de manière sélective la position définie, la vitesse, l'accélération, l'à-coup et\/ou le couple cible défini de l'axe. Cela peut être utilisé pour transmettre vos propres trajectoires calculées à l’axe. SMC_SetTorque Écrit le couple réglé de l'axe. En fonction du mode de fonctionnement de l'axe, la valeur est utilisée soit pour la commande anticipée du couple, soit comme couple que l'axe est censé appliquer. " }, 
{ "title" : "Interruption des mouvements ", 
"url" : "_sm_interrupt_single_axis_movement.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements sur un seul axe \/ Interruption des mouvements ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Interruption des mouvements à axe unique ", 
"url" : "_sm_interrupt_single_axis_movement.html#UUID-1984849b-9835-f096-d6a5-a51b59ed2387_section-idm234855926060424", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements sur un seul axe \/ Interruption des mouvements \/ Interruption des mouvements à axe unique ", 
"snippet" : "Les mouvements à axe unique, tels que MC_MoveAbsolute , peut être interrompu à tout moment par d'autres mouvements. Il peut s'agir d'un mouvement vers une position différente ou d'un changement de vitesse maximale, d'accélération ou de secousse avec le même type de mouvement et vers la même position...", 
"body" : "Les mouvements à axe unique, tels que MC_MoveAbsolute , peut être interrompu à tout moment par d'autres mouvements. Il peut s'agir d'un mouvement vers une position différente ou d'un changement de vitesse maximale, d'accélération ou de secousse avec le même type de mouvement et vers la même position. L'interruption est mise en œuvre de telle sorte qu'il n'y ait pas de saut de vitesse. Pour tous les types de rampes quadratiques, il n'y a pas non plus de saut d'accélération Dans certains cas, une inversion de l'axe est inévitable en raison du mouvement interrompu : Si la nouvelle position cible d'un MC_MoveAbsolute existe avant la fin de la distance de décélération actuelle Si une décélération maximale plus faible et\/ou une secousse maximale plus faible sont utilisées pour le mouvement interrompu, qui à son tour étend la distance de décélération au-delà de la position cible Si SMC_MoveContinuousAbsolute ou SMC_MoveContinuousRelative est utilisé avec un EndVelocity qui ne peut pas être atteint à partir de l'état actuel de l'axe sans inversion Quand la rampe est typée sin² et quadratique (lisse) sont utilisées, une inversion peut se produire lors de l'interruption même si cela ne semble pas nécessaire. (C'est-à-dire, même si les raisons énumérées ci-dessus ne s'appliquent pas. Voir les explications ci-dessous.) La nouvelle position cible pourrait alors être dépassée, bien qu'elle ne soit pas située avant l'ancienne position cible. Cela peut se produire même si la décélération maximale et la secousse maximale ne sont pas modifiées (voire augmentées) et si la vitesse finale n'est pas modifiée par rapport au mouvement interrompu. Dans ce cas, les règles suivantes s'appliquent : Pour les types de rampes trapézoïdales et quadratiques, il n'y a jamais de dépassement. Pour sin² type de rampe, il n'y a pas de dépassement lorsque la nouvelle position cible et les valeurs limites d'accélération et de décélération sont égales aux anciennes valeurs. Dans tous les autres cas, il se peut qu'il y ait un dépassement sin² et quadratique (lisse) types de rampes. Explication de la sin² type de rampe : Le mouvement interrompu commence par une nouvelle rampe de vitesse sin², ce qui signifie que l'accélération commence à 0 et augmente ou diminue progressivement. Si l'accélération de l'axe n'est pas égale à 0 au moment de l'abandon, l'accélération passe à 0 au début de la rampe de vitesse sin². Cela peut entraîner un dépassement car l'augmentation ou la diminution de l'accélération prend du temps. Explication de la quadratique (lissé) type de rampe : la même explication s'applique que pour sin² , mais pour la secousse plutôt que pour l'accélération. Remarque à propos de la dérogation Sur la base des explications ci-dessus, en utilisant MC_SetOverride avec le sin² et quadratique (lissé) le type de rampe n'est pas recommandé " }, 
{ "title" : "Interruption pendant la phase de décélération ", 
"url" : "_sm_interrupt_single_axis_movement.html#UUID-1984849b-9835-f096-d6a5-a51b59ed2387_id_fbc677d73098ed1c0a86463411e7edd_id_b5d8fdf3fc0362bfc0a8658d00b6a52e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements sur un seul axe \/ Interruption des mouvements \/ Interruption pendant la phase de décélération ", 
"snippet" : "Mouvements à axe unique, tels que MC_MoveAbsolute , peut être interrompu à tout moment par d'autres mouvements. Il peut s'agir d'un mouvement vers une autre position ou d'un changement de vitesse ou d'accélération. Fondamentalement, l'interruption du mouvement est mise en œuvre par un autre de maniè...", 
"body" : "Mouvements à axe unique, tels que MC_MoveAbsolute , peut être interrompu à tout moment par d'autres mouvements. Il peut s'agir d'un mouvement vers une autre position ou d'un changement de vitesse ou d'accélération. Fondamentalement, l'interruption du mouvement est mise en œuvre par un autre de manière à ce qu'il n'y ait pas de saut de vitesse. Pour tous les types de rampes (sauf trapèze ), il n'y a pas non plus de saut dans l'accélération. Lorsque les types de rampe sin² et quadratique (lisse) sont utilisés, une inversion peut se produire lors d'une interruption et n'apparaît pas nécessaire dans un premier temps (voir explication). Ensuite, la nouvelle position cible est dépassée, bien qu'elle ne soit pas située avant l'ancienne position cible. Cela peut se produire dans les situations suivantes : Si une valeur de décélération maximale plus petite est définie pour le mouvement d'annulation qu'auparavant Dans ce cas, la distance de décélération disponible jusqu'à la nouvelle position cible est peut-être trop courte (pour tous les types de rampe). En conséquence, pour quadratique et quadratique (lisse) types de rampe lorsqu'une valeur maximale inférieure est définie pour le jerk Cependant, si ces valeurs maximales restent inchangées (ou augmentent), les règles suivantes s'appliquent : Pour trapèze et quadratique rampes, il n'y a jamais de surcourse. Pour le sin² de type rampe, il n'y a pas de surcourse lorsque la nouvelle position cible et les valeurs limites d'accélération et de décélération sont égales aux anciennes valeurs. Dans tous les autres cas, il peut y avoir surcourse avec sin² et quadratique (lisse) types de rampes. " }, 
{ "title" : "Mouvements synchrones de deux axes ", 
"url" : "_sm_basic_synch_movements_2_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Aperçu ", 
"url" : "_sm_overview_synch_movements_2_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Aperçu ", 
"snippet" : "Cette section donne un aperçu des mouvements pour lesquels un axe est déplacé de manière synchrone avec un autre axe (en fonction du temps ou de la position). Cames : En fonction d'un entraînement (maître), un autre entraînement (esclave) doit exécuter tout type de mouvements définis. Pour plus d'in...", 
"body" : "Cette section donne un aperçu des mouvements pour lesquels un axe est déplacé de manière synchrone avec un autre axe (en fonction du temps ou de la position). Cames : En fonction d'un entraînement (maître), un autre entraînement (esclave) doit exécuter tout type de mouvements définis. Pour plus d'informations, voir : CamesSynchronisation de deux axes avec un rapport de transmission défini à l'aide MC_GearIn , MC_GearOut , et MC_GearInPos . Pour plus d'informations sur ces fonctions, consultez la documentation du bloc fonction concerné. Décalage de phase entre un axe maître et un axe esclave à l'aide MC_Phase . Pour plus d'informations sur cette fonction, consultez la documentation du bloc fonction. Compensation du jeu entre composants mécaniques (par exemple dans une boîte de vitesses) à l'aide de SMC_BacklashCompensation . Pour plus d'informations sur cette fonction, consultez la documentation du bloc fonction. " }, 
{ "title" : "Cames ", 
"url" : "_sm_f_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Aperçu ", 
"url" : "_sm_overview_synch_movements_2_axis_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Aperçu ", 
"snippet" : "Le SoftMotion cam est intégré dans l'interface utilisateur de CODESYS . Dans l'éditeur de cames, les cames et les poussoirs peuvent être implémentés graphiquement ou au moyen de tableaux. Dès que le code est généré pour l'application correspondante, des structures de données globales (« Cam Data ») ...", 
"body" : "Le SoftMotion cam est intégré dans l'interface utilisateur de CODESYS . Dans l'éditeur de cames, les cames et les poussoirs peuvent être implémentés graphiquement ou au moyen de tableaux. Dès que le code est généré pour l'application correspondante, des structures de données globales (« Cam Data ») sont créées auxquelles le programme CEI peut accéder. A cet effet, le SM3_Basic est également automatiquement lié au projet lors de l'insertion d'un lecteur SoftMotion. Pour plus d'informations, voir : Définition d'un et Comment créer une caméra" }, 
{ "title" : "Définition d'un SoftMotion Came ", 
"url" : "_sm_cam_definition_softmotion_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Définition d'un SoftMotion Came ", 
"snippet" : "Une came décrit la dépendance fonctionnelle d'un entraînement (esclave) sur un autre entraînement (maître). La relation est décrite par une fonction continue (ou courbe) qui associe une plage définie de valeurs maîtres à des valeurs esclaves. Pour être plus précis : Après avoir divisé l'axe maître e...", 
"body" : "Une came décrit la dépendance fonctionnelle d'un entraînement (esclave) sur un autre entraînement (maître). La relation est décrite par une fonction continue (ou courbe) qui associe une plage définie de valeurs maîtres à des valeurs esclaves. Pour être plus précis : Après avoir divisé l'axe maître en segments convenables, le graphe de ces fonctions peut être représenté sur chacun de ces intervalles par une droite ou un polynôme du 5ème degré. Exemple Les valeurs maîtres sont appliquées à l'axe horizontal et les valeurs esclaves à l'axe vertical dans le diagramme à cames. Dans l'exemple, les valeurs maîtres sont comprises entre 0 et 360. Cette plage est divisée en trois intervalles : (1) Premier intervalle : [0, 140] (2) Deuxième intervalle : [140, 280] (3) Troisième intervalle : [280, 360] La fonction (graphique) est linéaire dans les premier et troisième intervalles et son graphique est affiché sous forme de ligne. En conséquence, sa première dérivée (pente) est constante et toutes les dérivées supérieures sont égales à 0. Dans le second intervalle, le graphe est décrit par un polynôme du 5ème degré. Par conséquent, sa première dérivée est un polynôme du 4ème degré, sa seconde dérivée (courbure) est un polynôme du 3ème degré, et sa troisième dérivée est un polynôme du 2ème degré, etc. Lorsque la fonction décrit le mouvement de l'esclave en fonction de la position du maître, sa dérivée première correspond à la vitesse de l'esclave et la dérivée seconde à son accélération. Lorsque vous gardez cette interprétation physique à l'esprit, il est évident que la cartographie doit être continue. Cela signifie que son graphique n'est pas autorisé à avoir de sauts. En particulier, la continuité doit également être remplie à chaque point où deux intervalles se rencontrent. De plus, la continuité en général est également requise par les dérivées première et seconde. (En fait, ces trois conditions de continuité aux points de début et de fin d'un intervalle déterminent les coefficients du polynôme du 5ème degré inséré entre deux segments de droite. De plus, vous pouvez ajouter des poussoirs (commutateurs binaires) à la came à n'importe quelle position. De cette manière, vous pouvez créer des tables de cames contenant uniquement des poussoirs. La position de l'esclave est alors mise à zéro sur toute la plage de valeurs pilote. " }, 
{ "title" : "Vue d'ensemble des types de segments définis ", 
"url" : "_sm_overview_segment_types.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Vue d'ensemble des types de segments définis ", 
"snippet" : "CODESYS SoftMotion fournit différents types de segments pour les cames. En fonction de format de compilation , seuls certains types de segments sont pris en charge : XYVA : Line et Poly5 uniquement. Segments : tous les types de segments sont pris en charge. Type de segment Paramètres Courbe Poly7 Co...", 
"body" : "CODESYS SoftMotion fournit différents types de segments pour les cames. En fonction de format de compilation , seuls certains types de segments sont pris en charge : XYVA : Line et Poly5 uniquement. Segments : tous les types de segments sont pris en charge. Type de segment Paramètres Courbe Poly7 Conditions aux limites Poste de maître Position d'esclave Vitesse esclave Accélération des esclaves Esclave abruti Poly5 Conditions aux limites Poste de maître Position d'esclave Vitesse esclave Accélération des esclaves ModifiedSine Conditions aux limites Poste de maître Position d'esclave Vitesse esclave Paramètres du segment Soit le paramètre du point d'inflexion λ (0≤λ≤1) Ou paramètre d'accélération C une * (décélération maximale) Line Conditions aux limites Poste de maître Position d'esclave InclinedSine Conditions aux limites Poste de maître Position d'esclave Le choix du type de segment dépend de l'application car chaque type possède des propriétés dynamiques spéciales. Il existe différents types de segments applicables en fonction de la tâche de déplacement (par exemple, maintien — vitesse constante). Le tableau suivant fournit une vue d'ensemble : Demeurer (v=0, a=0) Vitesse constante (v­­≠0, a=0) Inversion (v=0, a≠0) Mouvement (v≠0, a≠0) Demeurer (v=0, a=0) Line Poly5\/7 InclinedSine ModifiedSine Poly5\/7 ModifiedSine Poly5\/7 Poly5\/7 Vitesse constante (v≠0, a=0) Poly5\/7 ModifiedSine Line Poly5\/7 ModifiedSine Poly5\/7 Poly5\/7 Inversion (v=0, a≠0) Poly5\/7 Poly5\/7 Poly5\/7 Poly5\/7 Mouvement (v≠0, a≠0) Poly5\/7 Poly5\/7 Poly5\/7 Poly5\/7 " }, 
{ "title" : "Structure de l'éditeur de came ", 
"url" : "_sm_cam_editor_layout.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Structure de l'éditeur de came ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Aperçu ", 
"url" : "_sm_overview_synch_movements_2_axis_cam_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Structure de l'éditeur de came \/ Aperçu ", 
"snippet" : "Ouvrez l'éditeur de cames en double-cliquant sur le Came objet dans l’arborescence des appareils. L'éditeur est composé des onglets suivants : Onglet : Caméra Onglet : Dans cet éditeur, vous utilisez un éditeur graphique pour créer un chemin de came. Ici, vous pouvez afficher et modifier la position...", 
"body" : "Ouvrez l'éditeur de cames en double-cliquant sur le Came objet dans l’arborescence des appareils. L'éditeur est composé des onglets suivants : Onglet : Caméra Onglet : Dans cet éditeur, vous utilisez un éditeur graphique pour créer un chemin de came. Ici, vous pouvez afficher et modifier la position de l'esclave, la vitesse de l'esclave, l'accélération de l'esclave et l'à-coup de l'esclave. Dans l'éditeur graphique, vous reconnaissez très rapidement lorsque vous programmez un mouvement avec une forte accélération. Table à cames onglet : Dans cet éditeur, les points de base sont présentés dans un tableau. Ici, vous pouvez spécifier les positions et vitesses exactes. Poussoirs Onglet : Dans cet éditeur, vous programmez les poussoirs (points de commutation) dans un diagramme. Cet affichage donne un très bon aperçu de l'ordre séquentiel des poussoirs. Table à poussoirs Onglet : Dans cet éditeur, les points de commutation sont présentés dans un tableau. Ici, vous pouvez spécifier les points de commutation exacts. Les onglets sont divisés en un éditeur, ainsi qu'un Boîte à outils voir et Propriétés voir. Exemple de programme pour l'utilisation de l'éditeur de cames " }, 
{ "title" : "Onglet : Caméra ", 
"url" : "_sm_obj_cam_table_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Structure de l'éditeur de came \/ Onglet : Caméra ", 
"snippet" : "Dans cet éditeur graphique, les courbes de came sont définies. A tout moment, vous pouvez basculer entre l'éditeur graphique et l'éditeur tabulaire alternatif ( Onglet : Tableau des cames). Les courbes de quatre graphiques sont affichées sous l'éditeur : Position esclave (noir) Vitesse esclave (bleu...", 
"body" : "Dans cet éditeur graphique, les courbes de came sont définies. A tout moment, vous pouvez basculer entre l'éditeur graphique et l'éditeur tabulaire alternatif ( Onglet : Tableau des cames). Les courbes de quatre graphiques sont affichées sous l'éditeur : Position esclave (noir) Vitesse esclave (bleu) Accélération esclave (vert) Esclave jerk (jaune) L'axe horizontal des quatre systèmes de coordonnées montre la plage des valeurs de référence ([0,360]). L'axe vertical dans le diagramme de positions montre la plage de valeurs qui est définie dans les propriétés de came. L'axe vertical de la vitesse, de l'accélération et de l'à-coup est mis à l'échelle automatiquement. Une nouvelle came insérée est affectée avec des valeurs par défaut. Il se compose de quatre points qui subdivisent le graphique en trois sections : [0,120], [120,240] et [240,360]. Chacune des parties d'intervalle des graphiques à cames est de type Poly5 (polynôme de 5e degré). Vous pouvez modifier toutes les courbes. Étant donné que la vitesse, l'accélération et la secousse sont des courbes dérivées, une modification de l'un des graphiques affecte également les autres Vous modifiez la hauteur du diagramme en déplaçant les barres de séparation horizontales. Voir: Boîte à outils Sélectionner Sélectionnez une ligne dans le tableau à l'aide de cet outil. Les points sélectionnés sont supprimés en appuyant sur la touche Suppr clé. Ajouter un point Ajoutez de nouveaux points avec cet outil. Cliquez sur le point d'insertion dans le diagramme. Le graphe est alors adapté automatiquement pour que sa courbe passe par le nouveau point inséré. Vue 'Propriétés' X Position X de l'axe esclave Y Position Y de l'axe esclave V Vitesse de l'axe esclave A Accélération de l'axe esclave J Jerk de l'axe esclave Pour plus d'informations, consultez : Boîte de dialogue : Propriétés - Came et Comment créer une caméra" }, 
{ "title" : "Onglet : Tableau des cames ", 
"url" : "_sm_obj_cam_table_cam_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Structure de l'éditeur de came \/ Onglet : Tableau des cames ", 
"snippet" : "En alternative à l'éditeur graphique, vous pouvez également définir les courbes de came dans la table de came ( Came languette). Vous pouvez à tout moment basculer entre l'éditeur tabulaire et l'éditeur graphique. La première ligne du tableau contient toujours la position de départ du maître (et les...", 
"body" : "En alternative à l'éditeur graphique, vous pouvez également définir les courbes de came dans la table de came ( Came languette). Vous pouvez à tout moment basculer entre l'éditeur tabulaire et l'éditeur graphique. La première ligne du tableau contient toujours la position de départ du maître (et les valeurs d'esclave associées) et la dernière ligne est toujours la position de fin. Les lignes intermédiaires définissent alternativement des segments et des points. Insère une nouvelle ligne Supprime le segment sélectionné X Position X de l'axe esclave Y Position Y de l'axe esclave V Vitesse de l'axe esclave A Accélération de l'axe esclave J Jerk de l'axe esclave Type de segment Line : Ligne Poly5 : polynôme du 5e degré Poly7 : polynôme du 7e degré InclinedSine : Ligne sinusoïdale inclinée ModifiedSine : ligne sinusoïdale modifiée Lambda Paramètres du point d'inflexion pour la ligne sinusoïdale modifiée Paramètres d'accélération Paramètres de retard maximum pour la ligne sinusoïdale modifiée Les valeurs suivantes résultent des valeurs du segment respectif. Ils ne peuvent pas être modifiés. min(Position) Valeur minimale de la position esclave max(Position) Valeur maximale de la position esclave max(Vitesse) Valeur maximale de la vitesse de l'esclave, basée sur l'axe maître max(Accélération) Valeur maximale de l'accélération de l'esclave, basée sur l'axe maître Voir: Boîte à outils Sélectionner Sélectionnez une ligne dans le tableau à l'aide de cet outil. Les points sélectionnés sont supprimés en appuyant sur la touche Suppr clé. Pour plus d'informations, consultez : Boîte de dialogue : Propriétés - Came et Comment créer une caméra" }, 
{ "title" : "Onglet : Poussoirs ", 
"url" : "_sm_obj_cam_table_tappets.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Structure de l'éditeur de came \/ Onglet : Poussoirs ", 
"snippet" : "Dans cet éditeur graphique, les chemins des poussoirs sont définis. Un chemin de poussoir définit un ou plusieurs poussoirs en fonction de la position du maître. Au bord supérieur de la fenêtre de l'éditeur, un axe horizontal approche la plage des positions du maître. Les chemins de poussoir individ...", 
"body" : "Dans cet éditeur graphique, les chemins des poussoirs sont définis. Un chemin de poussoir définit un ou plusieurs poussoirs en fonction de la position du maître. Au bord supérieur de la fenêtre de l'éditeur, un axe horizontal approche la plage des positions du maître. Les chemins de poussoir individuels suivent ci-dessous. A tout moment, vous pouvez basculer entre l'éditeur graphique et l'éditeur tabulaire alternatif ( Onglet : tableau des poussoirs). « ID de piste » du chemin du poussoir Tous les poussoirs d'un chemin de poussoir font référence au même interrupteur à poussoir (une variable de type BOOL). Voir: Boîte à outils Sélectionner Utilisez cet outil pour sélectionner les poussoirs. Vous pouvez faire glisser les poussoirs sélectionnés vers une autre position. Vous pouvez modifier l'attribut d'activation\/désactivation d'un poussoir en cliquant sur l'extrémité correspondante du ligne croisée. Supprimez le poussoir sélectionné en appuyant sur le Suppr clé. Ajoutez de nouveaux poussoirs avec cet outil. Cliquez sur le point d'insertion dans le chemin. Vue 'Propriétés' Le poussoir est affecté à un résultat, s'il est passé de la position de l'axe maître dans le sens positif (augmentation des valeurs maîtres) ou négatif. X Position du poussoir Passe positive Activer\/désactiver l'attribut Pas d'action Passer à ON Basculer sur OFF Inverser Passe négative Activer\/désactiver l'attribut Pas d'action Passer à ON Basculer sur OFF Inverser Tableau des combinaisons possibles d'attributs de poussoir Symbole de poussoir Passe positive Passe négative Pas d'action Pas d'action Passer à ON Pas d'action Basculer sur OFF Pas d'action Pas d'action Passer à ON Pas d'action Basculer sur OFF Passer à ON Basculer sur OFF Passer à ON Basculer sur OFF Basculer sur OFF Passer à ON Basculer sur OFF Basculer sur OFF Inverser Pas d'action Pas d'action Inverser Passer à ON Inverser Inverser Passer à ON Inverser Basculer sur OFF Basculer sur OFF Inverser Inverser Inverser Pour plus d'informations, consultez : Comment définir les points de commutation" }, 
{ "title" : "Onglet : tableau des poussoirs ", 
"url" : "_sm_obj_cam_table_tappet_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Structure de l'éditeur de came \/ Onglet : tableau des poussoirs ", 
"snippet" : "Dans ce tableau tabulaire, vous pouvez également configurer les chemins des poussoirs comme alternative à l'éditeur graphique ( Onglet : Poussoirs). Un chemin de poussoir définit un ou plusieurs poussoirs en fonction de la position du maître. Dans le tableau, les lignes avec les définitions des pous...", 
"body" : "Dans ce tableau tabulaire, vous pouvez également configurer les chemins des poussoirs comme alternative à l'éditeur graphique ( Onglet : Poussoirs). Un chemin de poussoir définit un ou plusieurs poussoirs en fonction de la position du maître. Dans le tableau, les lignes avec les définitions des poussoirs respectifs sont répertoriées sous chaque ligne qui définit un chemin de poussoir. Vous pouvez à tout moment basculer entre l'éditeur tabulaire et l'éditeur graphique. Insère un nouveau poussoir Supprime le poussoir ID de piste ID du chemin du poussoir Tous les poussoirs d'un chemin de poussoir font référence au même interrupteur à poussoir (une variable de type BOOL). X Position du poussoir Passe positive Activer\/désactiver l'attribut Pas d'action Passer à ON Basculer sur OFF Inverser Passe négative Activer\/désactiver l'attribut Pas d'action Passer à ON Basculer sur OFF Inverser Voir: Propriétés Le poussoir est affecté à un résultat, s'il est passé de la position de l'axe maître dans le sens positif (augmentation des valeurs maîtres) ou négatif. X Position du poussoir Passe positive Activer\/désactiver l'attribut Pas d'action Passer à ON Basculer sur OFF Inverser Passe négative Activer\/désactiver l'attribut Pas d'action Passer à ON Basculer sur OFF Inverser Pour plus d'informations, consultez : Comment définir les points de commutation" }, 
{ "title" : "Comment créer une caméra ", 
"url" : "_sm_cam_creating_a_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Comment créer une caméra ", 
"snippet" : "Les étapes de création d'une came sont expliquées à l'aide d'un exemple d'application qui décrit une table tournante à huit fentes (division à 45°). À l'intérieur, il y a un composant qui est fusionné par ultrasons. L'outil de soudage est alimenté par un entraînement linéaire après la rotation de la...", 
"body" : "Les étapes de création d'une came sont expliquées à l'aide d'un exemple d'application qui décrit une table tournante à huit fentes (division à 45°). À l'intérieur, il y a un composant qui est fusionné par ultrasons. L'outil de soudage est alimenté par un entraînement linéaire après la rotation de la table rotative. Après le soudage, l'axe linéaire revient et la table rotative continue de tourner. Étapes de travail Le plateau tournant tourne à 45° (durée : 400 ms). La tête de soudage est déplacée vers le bas d'un axe vertical de 250 mm (durée : 200 ms). Démarrer le soudage (durée : 1200 ms). La tête de soudage est déplacée vers le haut d'un axe vertical de 250 mm (durée : 200 ms). Un temps de cycle de 2000 ms résulte des temps totaux. L'application est réalisée au moyen d'un axe maître virtuel qui fonctionne en continu (modulo). La valeur finale de l'axe est projetée selon le temps de cycle de 2000 ms. Le plateau rotatif est réalisé sous forme de came (modulo ; valeur finale : 45°). L'axe vertical est également réalisé sous forme de came (restreint ; valeur finale : 300 mm). Le processus de soudage est contrôlé par un poussoir. Définition des propriétés de la came Sélectionnez le table rotative cam dans l'arborescence des appareils. Cliquez sur Propriétés dans le Voir menu ou dans le menu contextuel. Sélectionnez le Came languette. Spécifiez les valeurs suivantes : Position de départ maître : 0 Position finale maître : 2000 Position de départ esclave : 0 Position finale esclave : 45 Transition en douceur : (désactivée) Cliquez sur d'accord pour quitter la boîte de dialogue. Confirmez la boîte de dialogue de modification de l'objet came. Modifiez les valeurs de Axe vertical cam de la même manière : Position de départ maître : 0 Position finale maître : 2000 Position de départ esclave : 0 Position finale esclave : 300 Transition en douceur : (activée) Cliquez sur d'accord pour quitter la boîte de dialogue. Confirmez la boîte de dialogue de modification de l'objet came. " }, 
{ "title" : "Ajout d'une came à l'arborescence des appareils ", 
"url" : "_sm_cam_creating_a_cam.html#UUID-7c227a8f-47be-4a95-ca96-f0cd1d78635d_id_edb85f246cc9d9f4c0a8646368ed3bd6_id_fa86c256038b2152c0a864632d864483", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Comment créer une caméra \/ Ajout d'une came à l'arborescence des appareils ", 
"snippet" : "Condition : un contrôleur SoftMotion est sélectionné. Dans l'arborescence des appareils, sélectionnez le Application objet. Cliquez sur Projet → Ajouter un objet → Table de cames . Précisez le nom table rotative pour la cam et cliquez d'accord . L'objet est inséré dans l'arborescence des appareils. ...", 
"body" : "Condition : un contrôleur SoftMotion est sélectionné. Dans l'arborescence des appareils, sélectionnez le Application objet. Cliquez sur Projet → Ajouter un objet → Table de cames . Précisez le nom table rotative pour la cam et cliquez d'accord . L'objet est inséré dans l'arborescence des appareils. L'éditeur de cames s'ouvre. Insérez une autre came nommée Axe vertical . " }, 
{ "title" : "Comment changer le chemin de la came ", 
"url" : "_sm_cam_changing_the_course.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Comment changer le chemin de la came ", 
"snippet" : "Ces instructions utilisent l'exemple du Comment créer une caméra chapitre pour montrer comment changer une came....", 
"body" : "Ces instructions utilisent l'exemple du Comment créer une caméra chapitre pour montrer comment changer une came. " }, 
{ "title" : "Modification du chemin avec l'éditeur graphique ", 
"url" : "_sm_cam_changing_the_course.html#UUID-709e6439-f0d2-35ec-865b-a7484c34883c_id_c04b066ccb6844c0a8646367ecded3_id_0e7e8ac72c554f26c0a86463347ccca5", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Comment changer le chemin de la came \/ Modification du chemin avec l'éditeur graphique ", 
"snippet" : "Ouvrez le table rotative cam dans l'éditeur. le Came l'onglet est visible. Sélectionnez le point à 120 et supprimez-le en appuyant sur la touche de suppression ( Suppr ). Supprimez également le point à 240. Sélectionnez le Ajouter un point outil de la Boîte à outils voir. Le pointeur de la souris se...", 
"body" : "Ouvrez le table rotative cam dans l'éditeur. le Came l'onglet est visible. Sélectionnez le point à 120 et supprimez-le en appuyant sur la touche de suppression ( Suppr ). Supprimez également le point à 240. Sélectionnez le Ajouter un point outil de la Boîte à outils voir. Le pointeur de la souris se transforme en réticule lorsque vous le déplacez dans l'éditeur. Cliquez à proximité Poste de maître 400 et Position esclave 45 dans les graphiques supérieurs (position esclave). La courbe de la position de l'esclave est modifiée. Les courbes de vitesse, d'accélération et de secousse changent également. Sélectionnez le nouveau point inséré en cliquant dessus. Faites glisser le point vers une autre position. La courbe de la position de l'esclave est ajustée en conséquence. Changer la X et Oui propriétés aux valeurs exactes de 400 et 45, respectivement. De la même manière, modifiez la valeur X à 45 du point à la position principale 2000. Sélectionnez le Sélectionner outil de la Boîte à outils voir. Sélectionnez le deuxième élément de courbe (entre 400 et 2000). Changer la Type de segment propriété à Ligne . Vérifiez la courbe dans l'éditeur graphique. Affichage: " }, 
{ "title" : "Changer le chemin avec une table de came ", 
"url" : "_sm_cam_changing_the_course.html#UUID-709e6439-f0d2-35ec-865b-a7484c34883c_id_c04b066ccb6844c0a8646367ecded3_id_a888a2ff556a11e6abf6d2d0503b3e46", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Comment changer le chemin de la came \/ Changer le chemin avec une table de came ", 
"snippet" : "Ouvrez le Axe vertical cam dans l'éditeur. le Came l'onglet est visible. Sélectionnez le Tableau des cames languette. Clique le pour supprimer le point à 120. Supprimez également le point à 240. Clique le symbole. Un nouveau point et un nouveau segment sont insérés à (1000\/150). Ajoutez deux autres ...", 
"body" : "Ouvrez le Axe vertical cam dans l'éditeur. le Came l'onglet est visible. Sélectionnez le Tableau des cames languette. Clique le pour supprimer le point à 120. Supprimez également le point à 240. Clique le symbole. Un nouveau point et un nouveau segment sont insérés à (1000\/150). Ajoutez deux autres points. Modifiez les valeurs X\/Y des points suivants : Point 1 : 0 \/ 0 Point 2 : 400 \/ 0 Point 3 : 600 \/ 250 Point 4 : 1800 \/ 250 Point 5 : 2000 \/ 0 La courbe de la position de l'esclave est modifiée. Les courbes de vitesse, d'accélération et de secousse changent également. Dans la table des cames, modifiez le Type de segment des premier et troisième segments à Ligne . Vérifiez la courbe dans l'éditeur graphique. Affichage: En pratique, les courbes des différentes cames sont définies fréquemment comme imbriquées afin de gagner du temps de cycle. Dans l'exemple ci-dessus, l'axe vertical pourrait déjà commencer le mouvement alors que la table rotative est encore en mouvement (par exemple, à X : 350). " }, 
{ "title" : "Comment définir les points de commutation ", 
"url" : "_sm_cam_defining_tappets.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Comment définir les points de commutation ", 
"snippet" : "Utilisez des points de commutation pour déclencher des événements en fonction de la position du maître. Il peut s'agir par exemple du réglage d'une sortie ou de l'appel d'un bloc fonction. Ces instructions utilisent l'exemple du Comment créer une caméra chapitre pour montrer comment définir des poin...", 
"body" : "Utilisez des points de commutation pour déclencher des événements en fonction de la position du maître. Il peut s'agir par exemple du réglage d'une sortie ou de l'appel d'un bloc fonction. Ces instructions utilisent l'exemple du Comment créer une caméra chapitre pour montrer comment définir des points de commutation. Dans cet exemple, le poussoir démarre et arrête le processus de soudage. Ouvrez le Axe vertical cam dans l'éditeur. le Came l'onglet est visible. Sélectionnez le Onglet : Poussoirs. Dans le Boîte à outils vue, sélectionnez le Ajouter un poussoir outil. Le pointeur de la souris se transforme en réticule lorsque vous le déplacez dans l'éditeur. Cliquez sous la position principale près de la position 600. Un poussoir est inséré dans le chemin de poussoir 1. Sélectionnez le poussoir. Modifiez les valeurs du poussoir dans la vue \"Propriétés\". X : 600 Passe plus positive : Allumer Passe négative : Pas d'action Insérez un autre poussoir sur le chemin de poussoir 1 en X : 1800. X : 1800 Passe plus positive : Éteindre Passe négative : Pas d'action Vérifiez le résultat. Vous pouvez également modifier les valeurs de Passe positive et Passe négative en cliquant sur l'extrémité correspondante du réticule. Notez que vous pouvez également définir les points de commutation sur le Tableau des poussoirs languette. Cet éditeur vous propose les mêmes options, mais sous forme de tableau. " }, 
{ "title" : "Créer des cames par programme ", 
"url" : "_sm_basic_cam_programmatic_creation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Créer des cames par programme ", 
"snippet" : "Dès CODESYS SoftMotion version 4.17.0.0, le CamBuilder Le bloc fonctionnel fournit une interface pour créer des cames par programmation directement dans l'application CEI. Pour plus d'informations, consultez l'exemple : Créer des cames par programme...", 
"body" : "Dès CODESYS SoftMotion version 4.17.0.0, le CamBuilder Le bloc fonctionnel fournit une interface pour créer des cames par programmation directement dans l'application CEI. Pour plus d'informations, consultez l'exemple : Créer des cames par programme" }, 
{ "title" : "Utilisation du bloc fonction CamBuilder (à partir de SM 4.17.0.0) ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm4552813176932834337885510319", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Créer des cames par programme \/ Utilisation du bloc fonction CamBuilder (à partir de SM 4.17.0.0) ", 
"snippet" : "La came suivante est créée par défaut lorsqu'un objet came est créé dans l'arborescence des appareils : La came se compose de trois polynômes du cinquième degré avec les quatre valeurs limites suivantes : X Y V A 0 0 0 0 120 120 1 0 240 240 1 0 360 360 0 0 Pour créer cette came par programme, une in...", 
"body" : "La came suivante est créée par défaut lorsqu'un objet came est créé dans l'arborescence des appareils : La came se compose de trois polynômes du cinquième degré avec les quatre valeurs limites suivantes : X Y V A 0 0 0 0 120 120 1 0 240 240 1 0 360 360 0 0 Pour créer cette came par programme, une instance du CamBuilder Le bloc fonctionnel est d'abord déclaré : VAR\n camBuilder : SMCB.CamBuilder;\nEND_VAR Dans la partie mise en œuvre, le CamBuilder l'instance doit d'abord être initialisée. Trois segments de type Poly5 peut ensuite être ajouté à l'aide du Append méthode: camBuilder.Init();\n \ncamBuilder.Append(\n SMCB.Poly5(\n\tSMCB.BoundImplicit(),\n\tSMCB.Bound(120, 120, 1)));\ncamBuilder.Append(\n SMCB.Poly5(\n\tSMCB.BoundImplicit(),\n\tSMCB.Bound(240, 240, 1)));\ncamBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.Bound(360, 360))); Les polynômes sont définis via les conditions aux limites gauche et droite. Dans l'exemple, le BoundImplicit La fonction est toujours utilisée pour la limite gauche. En conséquence, la condition aux limites droite du segment précédent est appliquée. Si la BoundImplicit La fonction est utilisée comme limite gauche pour le premier segment, puis elle commence à zéro : dans cet exemple, avec le segment Poly5 à (X, Y, V, A) = (0, 0, 0, 0). Quand le MC_CamTableSelect et MC_CamIn des blocs fonctionnels sont utilisés, la came définie dans le CamBuilder le bloc de fonction doit enfin être converti en un MC_CamRef . Il existe deux manières de procéder, selon l'endroit où le CamBuilder est appelé Appel du CamBuilder dans la tâche du bus : Tout d'abord, la partie déclaration doit être étendue par les instances correspondantes : VAR\n    ...\n    camRef : MC_CAM_REF;\n    aCamSegments : ARRAY[1..3] OF SMC_CAM_SEGMENT;\nEND_VAR Ensuite, l'instance du bloc fonctionnel MC_CAM_REF est initialisé et écrit à l'aide de Write méthode du CamBuilder bloc fonctionnel. SMCB.InitCamRef(camRef, ADR(aCamSegments), XSIZEOF(aCamSegments));\ncamBuilder.Write(camRef); Appel du CamBuilder dans le cadre d'une autre tâche (multitâche, multicœur) : Tout d'abord, une instance multitâche\/multicore-sécurisée de la caméra est créée dans un GVL, accessible à la fois par la tâche bus et par la tâche CamBuilder. VAR_GLOBAL\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\nEND_VAR Ensuite, la création de la caméra dans l'autre tâche est lancée à partir de la tâche bus. Pour déterminer dans la tâche de bus quand la nouvelle caméra a été écrite dans l'autre tâche, le programme mémorise CamId dans STATE_INIT_ONLINE_TABLE_MULTITASK avant la création de la caméra. Ensuite, la création de la caméra est lancée dans l'autre tâche du STATE_START_CREATE_ONLINE_TABLE_MULTITASK état. Ensuite, la caméra créée est lue dans le STATE_READ_ONLINE_TABLE_MULTITASK état. PROGRAM BUS_TASK\nVAR\n    state : UDINT;\n    error : SMC_ERROR;\n    camIdBeforeCreate : UDINT;\n    camSegments: ARRAY[0..99] OF SMC_CAM_SEGMENT;\n    camRef: MC_CAM_REF;\nEND_VAR\nVAR CONSTANT\n    STATE_INIT_ONLINE_TABLE_MULTITASK : UDINT := 0;\n    STATE_START_CREATE_ONLINE_TABLE_MULTITASK : UDINT := 10;\n    STATE_READ_ONLINE_TABLE_MULTITASK : UDINT := 20;\n    STATE_ERROR : UDINT := 1000;\nEND_VAR\n\n\nCASE state OF\nSTATE_INIT_ONLINE_TABLE_MULTITASK:\n    camIdBeforeCreate := GVL.safeCam.CamId;\n\n    state := STATE_START_CREATE_ONLINE_TABLE_MULTITASK;\n\nSTATE_START_CREATE_ONLINE_TABLE_MULTITASK:\n    CamBuilderTask.BuildCam := TRUE;\n\n    state := STATE_READ_ONLINE_TABLE_MULTITASK;\n\nSTATE_READ_ONLINE_TABLE_MULTITASK:\n    IF CamBuilderTask.Error THEN\n        error := CamBuilderTask.ErrorId;\n        state := state + STATE_ERROR;\n    ELSIF GVL.safeCam.CamId <> camIdBeforeCreate THEN\n        error := GVL.safeCam.GetCopy(\n            camRef:= camRef,\n            pCamSegments:= ADR(camSegments),\n            arraySize:= XSIZEOF(camSegments));\n\n        IF error = SMC_NO_ERROR THEN\n            state := state + 10;\n        ELSE\n            state := state + STATE_ERROR;\n        END_IF\n    END_IF\nEND_CASE Dans la tâche CamBuilder, la caméra multitâche\/multicore-safe est écrite en appelant CamBuilder.WriteMulticoreSafe() : PROGRAM CamBuilderTask\nVAR_INPUT\n    BuildCam : BOOL;\nEND_VAR\nVAR_OUTPUT\n    Error : BOOL;\n    ErrorId : SMC_ERROR;\nEND_VAR\nVAR\n    camBuilder : SMCB.CamBuilder;\nEND_VAR\n\nIF BuildCam THEN\n    BuildCam := FALSE;\n\n    camBuilder.Init();\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(120, 120, 1)));\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(240, 240, 1)));\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(360, 360)));\n     \n Error := camBuilder.IsErrorPending(errorID=> ErrorId);\n\n    IF NOT Error THEN\n        ErrorId := camBuilder.WriteMulticoreSafe(GVL.safeCam);\n        Error := ErrorId <> SMC_NO_ERROR;\n    END_IF\nEND_IF " }, 
{ "title" : "Conditions aux limites implicites et explicites ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433930557874", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Créer des cames par programme \/ Utilisation du bloc fonction CamBuilder (à partir de SM 4.17.0.0) \/ Conditions aux limites implicites et explicites ", 
"snippet" : "Une condition aux limites implicite définie avec BoundImplicit veille à ce que la transition vers le segment adjacent soit aussi fluide que possible. Pour ce faire, la condition aux limites du segment adjacent doit être explicitement définie à l'aide de la Bound méthode. Ainsi, si la condition aux l...", 
"body" : "Une condition aux limites implicite définie avec BoundImplicit veille à ce que la transition vers le segment adjacent soit aussi fluide que possible. Pour ce faire, la condition aux limites du segment adjacent doit être explicitement définie à l'aide de la Bound méthode. Ainsi, si la condition aux limites gauche d’un segment est implicite, alors la condition aux limites droite du segment précédent doit être explicite. Inversement, si la condition aux limites droite est implicite, alors la condition aux limites gauche du segment suivant doit être explicite. Le cas d'utilisation le plus courant est probablement que seules les bonnes conditions aux limites des segments sont explicitement spécifiées, comme dans l'exemple ci-dessus. En raison des conditions implicites aux limites gauches, les transitions de segment sont automatiquement aussi douces que possible et il n'y a aucun espace dans la zone de définition. L’exemple suivant est un cas simple où il est utile de s’écarter de cette approche : L'axe esclave doit se déplacer à vitesse constante de la position 20 à 100 : camBuilder.Append(\n SMCB.Line(\n SMCB.Bound(20, 20),\n SMCB.Bound(100, 100))); Avant et après cela, un Poly5 Le segment est utilisé pour l'accélération et la décélération : camBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.BoundImplicit()));\ncamBuilder.Append(\n SMCB.Line(\n SMCB.Bound(20, 20),\n SMCB.Bound(100, 100)));\ncamBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.Bound(120, 120, 0))); La came ainsi définie présente des phases d'accélération et de décélération indésirables dans les segments Poly5 (vitesse en bleu) : Pour éviter cela, il suffit d'ajuster la position du maître dans le segment de type Line (par exemple, celle de la limite gauche de 20 à 30 et celle de la limite droite de 100 à 90) : ...\ncamBuilder.Append(\n SMCB.Line(\n SMCB.Bound(30, 20),\n SMCB.Bound(90, 100)));\n... Il n'est pas nécessaire d'ajuster les segments de type Poly5 car ils sont automatiquement ajoutés au segment de droite de la manière la plus fluide possible en raison des conditions aux limites définies à l'aide de la BoundImplicit fonction. " }, 
{ "title" : "La gestion des erreurs ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433930649954", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Créer des cames par programme \/ Utilisation du bloc fonction CamBuilder (à partir de SM 4.17.0.0) \/ La gestion des erreurs ", 
"snippet" : "Le Append méthode du CamBuilder retour du bloc fonctionnel TRUE lorsqu'un segment a été ajouté avec succès et renvoie FALSE si une erreur s'est produite. Après une erreur, plus aucun segment ne peut être ajouté et le CamBuilder Le bloc fonction doit être réinitialisé à l'aide du Init méthode. La cau...", 
"body" : "Le Append méthode du CamBuilder retour du bloc fonctionnel TRUE lorsqu'un segment a été ajouté avec succès et renvoie FALSE si une erreur s'est produite. Après une erreur, plus aucun segment ne peut être ajouté et le CamBuilder Le bloc fonction doit être réinitialisé à l'aide du Init méthode. La cause de l'erreur peut être déterminée à l'aide du IsErrorPending méthode: camBuilder.IsErrorPending(errorId=> errorId); " }, 
{ "title" : "Création manuelle de la structure de données MC_CAM_REF (avant SM 4.17.0.0) ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm4565212026644834337937734299", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Créer des cames par programme \/ Création manuelle de la structure de données MC_CAM_REF (avant SM 4.17.0.0) ", 
"snippet" : "Il est recommandé d'utiliser le SM3_CamBuilder bibliothèque dès CODESYS SoftMotion 4.17.0.0....", 
"body" : "Il est recommandé d'utiliser le SM3_CamBuilder bibliothèque dès CODESYS SoftMotion 4.17.0.0. " }, 
{ "title" : "Structures de données des cames ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793858538", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Créer des cames par programme \/ Création manuelle de la structure de données MC_CAM_REF (avant SM 4.17.0.0) \/ Structures de données des cames ", 
"snippet" : "Lors de la compilation du projet, les données de came créées sont converties en interne en une liste de variables globales. En cliquant Afficher le code généré dans l'éditeur de cames, vous pouvez afficher les variables globales créées automatiquement. Chaque came est représentée par la structure de...", 
"body" : "Lors de la compilation du projet, les données de came créées sont converties en interne en une liste de variables globales. En cliquant Afficher le code généré dans l'éditeur de cames, vous pouvez afficher les variables globales créées automatiquement. Chaque came est représentée par la structure de données MC_CAM_REF . Vous pouvez accéder à cette structure de données au moyen du programme CEI ou en prétraitant des fonctions et des blocs fonctionnels. Il est disponible auprès du SM3_Basic bibliothèque. Un bloc fonctionnel décrivant une came peut également être généré ou renseigné par le programme CEI lors de l'exécution. Exemple Définition de la structure des données : TYPE mySMC_CAMTable_LREAL_10000_2 :\nSTRUCT\n Table: ARRAY[0..9999] OF ARRAY[0..1] OF LREAL;\n (* set all scaling definitions to 0 and 1\n result: all values of the table are not scaled *)\n fEditorMasterMin: REAL := 0;\n fEditorMasterMax: REAL := 1;\n fEditorSlaveMin: REAL := 0;\n fEditorSlaveMax: REAL := 1;\n fTableMasterMin: REAL := 0;\n fTableMasterMax: REAL := 1;\n fTableSlaveMin: REAL := 0;\n fTableSlaveMax: REAL := 1;\nEND_STRUCT\nEND_TYPE Instanciation de la structure des données : Cam: MC_CAM_REF;\nCam_PointArray : mySMC_CAMTable_LREAL_10000_2; Calcul de la came : Cam.byType:=2;\nCam.byVarType:=6;\nCam.nTappets:=0;\nCam.strCAMName:='myCAM';\nCam.pce:= ADR(CAM_PointArray);\nFOR i:=0 TO 9999 DO\n (* example cam: master 0..360, slave 0..100,\n constant velocity *)\n Cam_PointArray.Table[i][0]:=UDINT_TO_LREAL(I)\/10000 * 360; (* X *)\n Cam_PointArray.Table[i][1]:=UDINT_TO_LREAL(I)\/10000 * 100; (* Y *)\nEND_FOR\nCam.nElements:=10000\nCam.xStart:=0.0;\nCam.xEnd:=360.0; " }, 
{ "title" : "Cames générées manuellement ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793936406", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Créer des cames par programme \/ Création manuelle de la structure de données MC_CAM_REF (avant SM 4.17.0.0) \/ Cames générées manuellement ", 
"snippet" : "Une came peut être créée dans un programme CEI sans utiliser l'éditeur de cames. Exemple Déclaration: VAR i: INT; CAM: MC_CAM_REF := ( byType:=2, (* non-equidistant *) byVarType:=2, (* UINT *) nElements:=128, xStart:=0, xEnd:=360); Table: SMC_CAMTable_UINT_128_2 := ( fEditorMasterMin := 0, fEditorMa...", 
"body" : "Une came peut être créée dans un programme CEI sans utiliser l'éditeur de cames. Exemple Déclaration: VAR\ni: INT;\nCAM: MC_CAM_REF := (\n byType:=2, (* non-equidistant *)\n byVarType:=2, (* UINT *)\n nElements:=128,\n xStart:=0,\n xEnd:=360);\nTable: SMC_CAMTable_UINT_128_2 := (\n fEditorMasterMin := 0, fEditorMasterMax := 360,\n fTableMasterMin := 0, fTableMasterMax := 6000,\n fEditorSlaveMin := 0, fEditorSlaveMax := 360,\n fTableSlaveMin := 0, fTableSlaveMax := 6000);\nEND_VAR Mise en œuvre: (* Create cam disk (example straight line); unambiguous *)\nFOR i:=0 TO 127 DO\n Table.Table[i][0] := Table.Table[i][1] := REAL_TO_UINT(i \/ 127.0 * 6000);\nEND_FOR\n(* Link pointer; must be done in every cycle! *)\nCAM.pce := ADR(Table); Cette came générée peut être spécifiée dans le MC_CamTableSelect bloc fonctionnel et sa sortie utilisée à nouveau pour MC_CamIn . " }, 
{ "title" : "Compilation des définitions de came ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793975398", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Créer des cames par programme \/ Création manuelle de la structure de données MC_CAM_REF (avant SM 4.17.0.0) \/ Compilation des définitions de came ", 
"snippet" : "Au moment de la compilation, les variables de type MC_CAM_REF sont créés pour une came. Ils comprennent une description de chaque segment de la came. Les structures de données de ce type sont transmises au MC_CamTableSelect bloc fonctionnel. La structure fait partie du SM3_Basic bibliothèque....", 
"body" : "Au moment de la compilation, les variables de type MC_CAM_REF sont créés pour une came. Ils comprennent une description de chaque segment de la came. Les structures de données de ce type sont transmises au MC_CamTableSelect bloc fonctionnel. La structure fait partie du SM3_Basic bibliothèque. " }, 
{ "title" : "Basculer entre les caméras ", 
"url" : "_sm_cam_switch_between_cams.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Basculer entre les caméras ", 
"snippet" : "Fondamentalement, vous pouvez basculer entre différentes caméras à tout moment. Cependant, vous devriez considérer certains points: Dans l'éditeur de cames, la position de l'esclave est définie uniquement comme valeur de fonction de la fonction de came. Cette fonction est définie dans la plage de va...", 
"body" : "Fondamentalement, vous pouvez basculer entre différentes caméras à tout moment. Cependant, vous devriez considérer certains points: Dans l'éditeur de cames, la position de l'esclave est définie uniquement comme valeur de fonction de la fonction de came. Cette fonction est définie dans la plage de valeurs pilote et peut être exprimée comme suit : SlavePosition = CAM( MasterPosition ) Étant donné que la position actuelle de l'entraînement maître s'écarte généralement de la plage de valeurs pilote, vous devez mettre à l'échelle la position maître dans la plage de définition de la fonction de came afin de représenter un argument valable : SlavePosition = CAM( MasterScale*MasterPosition + MasterOffset ) De la même manière, vous devez mettre à l'échelle la valeur de la fonction (la position de l'esclave) si le début de la came en mode Absolute conduirait à un saut: SlavePosition = SlaveScale*CAM( MasterPosition ) + SlaveOffset Vous devrez peut-être appliquer les deux valeurs de mise à l'échelle, ce qui donne les résultats suivants : Slaveposition = SlaveScale*CAM( MasterScale*Masterposition + MasterOffset ) + SlaveOffset Les valeurs appropriées pour les paramètres de mise à l'échelle et de décalage peuvent varier d'une période à l'autre. La commutation entre les cames peut être effectuée de trois manières : Démarrez la deuxième caméra via une deuxième instance de MC_CamIn avec BufferMode = MC_BUFFER_MODE.Buffered , StartMode = relative , MasterAbsolute = FALSE , et SlaveAbsolute = FALSE . Dès CODESYS SoftMotion version 4.17.0.0 Démarrage de la nouvelle came en affectant MC_CamIn.CamTableID à la nouvelle came (pas de redémarrage de la MC_CamIn bloc fonctionnel requis). Cette variante est recommandée si les points suivants s'appliquent à votre cas d'utilisation : Toutes les cames suivantes doivent être exécutées relativement avec MasterAbsolute = FALSE ou SlaveAbsolute = FALSE . La nouvelle came doit commencer exactement à la fin de la précédente. Aucun autre paramètre n'est modifié (exemple : SlaveOffset ). Le saut, qui est expliqué dans l'exemple suivant pour les cames périodiques et SlaveAbsolute = FALSE , Est-ce que ne pas s'appliquent à cette variante car la came suivante est placée exactement aux fins de course de la came précédente. La nouvelle came est placée exactement à la fin de la came précédente uniquement si le passage à la nouvelle came se fait dans le même cycle lorsque la came précédente signale EndOfProfile = TRUE . Démarrage de la nouvelle came en redémarrant la MC_CamIn bloc fonctionnel. Cette variante est recommandée si des paramètres doivent être modifiés pour le bon fonctionnement de la nouvelle came (par exemple, SlaveOffset de l'exemple suivant). Les restrictions de l'exemple suivant s'appliquent. Exemple Dans l'exemple suivant, il passe de CAM1 à CAM2 : CAM1 se compose d'un polynôme d'ordre 5 suivi de deux segments de droite. CAM2 se compose de deux segments de droite suivis d'un polynôme d'ordre 5. Lorsque vous basculez entre les deux cames, vous devez tenir compte des éléments suivants : Pour éviter les sauts, les valeurs de vitesse et d'accélération au point final de la première came doivent correspondre aux valeurs au point de départ de la deuxième came. Dans l'exemple, cette condition est remplie car la même vitesse (=1) et la même accélération (=0) sont affectées au point final de CAM1 et le point de départ de CAM2 . Vous pouvez démarrer la deuxième cam dans Relative lorsque vous avez défini la position de départ de l'esclave sur 0. Cependant, la première came doit tourner en non-periodic mode. Sinon, si CAM1 étaient périodiques, alors les Relative réglage entraînerait un saut. Le grossissement montre la transition de CAM1 à CAM2 . Les lignes bleues marquent les évaluations des fonctions de came aux positions maîtres x1 et x2 . Nous allons maintenant examiner le cas défavorable de periodic : MasterAbsolute := TRUE; SlaveAbsolute := FALSE; CAM(x1, CAM1, PERIODIC:=TRUE); L'appel lance une évaluation de la came à la position maître x1 , qui est inférieure à la position finale du maître de CAM1 . Puis CAM1 est évalué par défaut et donne point 1 comme position pour l'esclave. CAM(x2, CAM1, PERIODIC:=TRUE); Pour l'appel suivant du module, la position maître x2 se trouve en dehors de la plage de valeurs pilotes de CAM1 , dont la limite est marquée par la ligne pointillée verte et correspond à l'axe horizontal du point 3p . Par conséquent, la EndOfProfile est réglé. Parce que CAM1 a été commencé en periodic mode, son redémarrage s'effectue à la fin de la plage de valeurs, ce qui donne finalement le point 2p à la suite de l’appel du module. CAM(EXECUTE:=FALSE); Passer à la nouvelle caméra CAM(x2, CAM2, PERIODIC:=TRUE); Deuxième évaluation au poste de maître x2 . Cette fois, le nouveau CAM2 est évalué. Après CAM2 est lancé en Relative mode, la position actuelle de l'esclave ( 2p ) est ajouté comme décalage à l'image de la fonction came de CAM2 . Cela déplace le point de départ de son graphique au point 3p et son évaluation au poste de maître x2 donne le point 4p , et donc un saut défavorable. Sélectionnez le non-periodic mode afin d'éviter les sauts : MasterAbsolute := TRUE; SlaveAbsolute := FALSE; CAM(x1, CAM1, PERIODIC:=FALSE); L'appel lance une évaluation de la came à la position maître x1 , qui est inférieure à la position finale du maître de CAM1 . Puis CAM1 est évalué par défaut et donne le point 1 comme position de l'esclave. CAM(x2, CAM1, PERIODIC:=FALSE); Pour l'appel suivant du module, la position maître x2 se trouve en dehors de la plage de valeurs pilotes de CAM1 , dont la limite est marquée par la ligne pointillée verte et correspond à l'axe horizontal du point 3n . Par conséquent, la EndOfProfile est réglé. Parce que CAM1 a été commencé en non-periodic mode, position esclave ( 2n ) affecté au poste de maître x2 est identique à la position de l'esclave à la fin de la plage de valeurs de CAM1 ( 3n ). CAM(EXECUTE:=FALSE); Passez à la nouvelle caméra. CAM(x2, CAM2, PERIODIC:=FALSE); Deuxième évaluation au poste de maître x2 . Cette fois, le nouveau CAM2 est évalué. Après CAM2 est lancé en Relative mode, la position actuelle de l'esclave ( 2n ) est ajouté comme décalage à l'image de la fonction came de CAM2 . Cela déplace le point de départ de son graphique au point 3n et son évaluation au poste de maître x2 donne le point 4n , qui est sur la ligne spécifique passant par les points 1 et 3n . Pour démarrer la came dans Absolute mode, vous devez vous assurer que l'esclave est dans une position de départ appropriée. Si la plage de valeurs du maître concorde avec la période de l'esclave, alors la commutation entre les cames n'a pas de complications, que les cames soient périodiques ou non. Dans l'exemple ci-dessus, vous pouvez commencer CAM2 dans Absolute mode lorsque les périodes du maître et de l'esclave correspondent à la plage de valeurs maître de CAM2 (chacun fait 360°). Sinon, par exemple lorsque la période de l'esclave est 270° (indiqué par la ligne bleu clair), puis le Absolute option n'est pas autorisée sans prendre des mesures supplémentaires. Dans ce cas, l'esclave est à 90° lors du passage de CAM1 à CAM2 . Départ CAM2 dans Absolute mode provoque un saut à 0° (indiqué par une ligne grise). Cependant, le saut peut être évité en réglant le décalage de l'esclave sur la valeur appropriée de 90°. " }, 
{ "title" : "Cames périodiques ", 
"url" : "_sm_basic_periodic_cams.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Cames périodiques ", 
"snippet" : "Une came peut être exécutée à plusieurs reprises lorsque le Periodic entrée du MC_CamTableSelect Le bloc fonctionnel est défini sur TRUE . Ensuite, la came redémarre automatiquement après avoir atteint la position finale. Si cette entrée est FALSE , puis le EndOfProfile variable de sortie du MC_CamI...", 
"body" : "Une came peut être exécutée à plusieurs reprises lorsque le Periodic entrée du MC_CamTableSelect Le bloc fonctionnel est défini sur TRUE . Ensuite, la came redémarre automatiquement après avoir atteint la position finale. Si cette entrée est FALSE , puis le EndOfProfile variable de sortie du MC_CamIn Le bloc fonctionnel est défini sur TRUE lorsque la position finale du maître est atteinte. L'esclave fait une pause à sa position actuelle. Notez que l'activité de la came ne s'arrête pas après avoir quitté la plage de valeurs pilote. Lorsque l'entraînement maître rentre dans la plage de valeurs maître, l'entraînement esclave suit à nouveau le plateau à cames. Comportement en cas de Slave.EndPosition <> Slave.StartPosition : Le bloc fonction MC_CamIn calcule un décalage interne à la fin d'une période. Dans la période suivante, la came est décalée de ce décalage de sorte qu'elle continue à la position actuelle de l'esclave et empêche ainsi les sauts. Pour une came périodique, vous pouvez activer le Transition en douceur option dans les propriétés de la came. Ceci est utilisé pour empêcher les sauts lors de la transition d’une période à une autre. L'esclave a alors la même vitesse et la même accélération en position finale qu'en position de départ. La période et l'avance sont mesurées dans les unités de mise à l'échelle esclave. Même si vous ne sélectionnez pas le Transition en douceur En option, la came peut fonctionner en continu. Dans ce cas, votre tâche est de vous assurer que la cohérence des transitions est satisfaite à un degré suffisant. " }, 
{ "title" : "Élément de visualisation 'Online Cam Editor' ", 
"url" : "_sm_cam_visu_elem_online_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Élément de visualisation 'Online Cam Editor' ", 
"snippet" : "L'éditeur de caméras en ligne est un modèle de visualisation qui affiche une caméra dans la visualisation. Avec cet élément, vous pouvez modifier la caméra en mode en ligne. L'élément de visualisation est disponible dans un modèle de visualisation ( Éditeur SMC_Visu_Cam ) du SM3_Basic_Visu bibliothè...", 
"body" : "L'éditeur de caméras en ligne est un modèle de visualisation qui affiche une caméra dans la visualisation. Avec cet élément, vous pouvez modifier la caméra en mode en ligne. L'élément de visualisation est disponible dans un modèle de visualisation ( Éditeur SMC_Visu_Cam ) du SM3_Basic_Visu bibliothèque. Vous le trouverez dans l'éditeur de visualisation du Boîte à outils voir dans SM3_Basic_Visu étiquette. Le SMC_Visu_CamEditor est inséré dans la visualisation via un cadre. Pour plus d'informations sur cet élément de visualisation, consultez : Élément de visualisation : cadre . Outre les propriétés de l'élément frame, ce modèle contient les propriétés suivantes : Propriété Descriptif SafeCam Référence à la caméra à modifier Afficher la position Variable booléenne permettant d'activer et de désactiver l'affichage de la courbe de position Afficher la vélocité Variable booléenne permettant d'activer et de désactiver l'affichage de la courbe de vitesse Afficher l'accélération Variable booléenne permettant d'activer et de désactiver l'affichage de la courbe d'accélération Afficher Jerk Variable booléenne permettant d'activer et de désactiver l'affichage de la courbe de secousse Afficher le segment sélectionné Variable booléenne permettant d'activer et de désactiver la mise en surbrillance du segment sélectionné La caméra à modifier est transférée via une instance du SMCB.CAM_REF_MULTICORE_SAFE bloc fonctionnel. PROGRAM PLC_PRG\nVAR\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\nEND_VAR " }, 
{ "title" : "Editeur de cames en mode en ligne ", 
"url" : "_sm_cam_visu_elem_online_cam.html#UUID-2e587bbc-4adf-7494-0ee4-e771bd15b571_id_ba4cc02c6ccda90bc0a864637badf4e0_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Élément de visualisation 'Online Cam Editor' \/ Editeur de cames en mode en ligne ", 
"snippet" : "En mode en ligne, les différents segments de la caméra peuvent être sélectionnés dans le graphique. L'éditeur de segments sur le côté droit peut être utilisé pour ajouter et supprimer des segments, ainsi que pour adapter les conditions aux limites du segment sélectionné (1) Caméra de charge Charge l...", 
"body" : "En mode en ligne, les différents segments de la caméra peuvent être sélectionnés dans le graphique. L'éditeur de segments sur le côté droit peut être utilisé pour ajouter et supprimer des segments, ainsi que pour adapter les conditions aux limites du segment sélectionné (1) Caméra de charge Charge la caméra configurée dans l'éditeur (2) Enregistrer la caméra Enregistre la caméra modifiée (3) Barre d'état Affiche les messages d'état (4) Sélection des segments Un segment peut être sélectionné à l'aide des flèches. Le type de segment peut être modifié via la zone de liste. (5) Poste de maître La position principale sur les bords gauche et droit du segment (6) Position d'esclave La position de l'esclave sur les bords gauche et droit du segment. (7) Vitesse esclave La vitesse esclave sur les bords gauche et droit du segment. Non modifiable pour tous les types de segments (8) Accélération de l'esclave L'accélération esclave sur les bords gauche et droit du segment. Non modifiable pour tous les types de segments (9) Esclave abruti La secousse de l'esclave sur les bords gauche et droit du segment. Non modifiable pour tous les types de segments (10) Paramètre Lambda Paramètre Lambda pour la ligne sinusoïdale modifiée. (11) Split Divise le segment sélectionné en deux segments. (12) Supprimer Supprime le segment sélectionné. " }, 
{ "title" : "Utilisation d'une caméra créée dans l'application ", 
"url" : "_sm_cam_visu_elem_online_cam.html#UUID-2e587bbc-4adf-7494-0ee4-e771bd15b571_section-idm234870310600632", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Mouvements synchrones de deux axes \/ Cames \/ Élément de visualisation 'Online Cam Editor' \/ Utilisation d'une caméra créée dans l'application ", 
"snippet" : "Vous pouvez utiliser la caméra créée avec le SMC_Visu_CamEditor élément de visualisation dans l'application en appelant le GetCopy méthode du CAM_REF_MULTICORE_SAFE instance. PROGRAM PLC_PRG VAR     safeCam : SMCB.CAM_REF_MULTICORE_SAFE;     camRef : MC_CAM_REF;     camSegments : ARRAY[0..99] OF SMC...", 
"body" : "Vous pouvez utiliser la caméra créée avec le SMC_Visu_CamEditor élément de visualisation dans l'application en appelant le GetCopy méthode du CAM_REF_MULTICORE_SAFE instance. PROGRAM PLC_PRG\nVAR\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\n    camRef : MC_CAM_REF;\n    camSegments : ARRAY[0..99] OF SMC_CAM_SEGMENT;\n    error : SMC_ERROR;\nEND_VAR\n\nIF safeCam.CamId <> oldCamId THEN\n     error :=\n         safeCam.GetCopy(\n            camRef:= camRef,\n            pCamSegments:= ADR(camSegments),\n            arraySize:= XSIZEOF(camSegments));\n\n oldCamId := safeCam.CamId;\nEND_IF Le programme vérifie d'abord si une nouvelle caméra a été créée ( CamId <> oldCamID ). Si c'est le cas, une copie de cette caméra est créée à l'aide du GetCopy méthode. Si l'appel revient SMC_NO_ERROR , puis le camRef instance du MC_CAM_REF le bloc fonctionnel peut être utilisé avec les blocs fonctionnels de la caméra SoftMotion MC_CamTableSelect et MC_CamIn . GetCopy l'appel est sécurisé pour les tâches et ne doit donc pas être effectué à partir de la tâche Visu. " }, 
{ "title" : "Commander plusieurs mouvements ", 
"url" : "_sm_basic_mulitple_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commander plusieurs mouvements ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Aperçu ", 
"url" : "_sm_overview_mulitple_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commander plusieurs mouvements \/ Aperçu ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Mode Tampon ", 
"url" : "_sm_overview_mulitple_movements.html#UUID-2f590113-2f84-eead-4ae8-73304891aaa0_section-idm43431844820766", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commander plusieurs mouvements \/ Aperçu \/ Mode Tampon ", 
"snippet" : "Certains blocs fonctionnels ont un BufferMode entrée qui permet de contrôler l'ordre chronologique des mouvements. Le mode tampon définit si le bloc fonction fonctionne en mode non tamponné (\"Aborting\", comportement standard) ou en mode tamponné (\"Buffered\"). La différence entre ces deux modes est l...", 
"body" : "Certains blocs fonctionnels ont un BufferMode entrée qui permet de contrôler l'ordre chronologique des mouvements. Le mode tampon définit si le bloc fonction fonctionne en mode non tamponné (\"Aborting\", comportement standard) ou en mode tamponné (\"Buffered\"). La différence entre ces deux modes est le moment où ils commencent leurs actions : « Mode non tamponné » : La commande de mouvement est effective immédiatement, même si elle interrompt un autre mouvement. Le tampon des mouvements commandés est supprimé. « Mode tampon » : la commande de mouvement attend que le bloc fonction actuel définisse sa sortie Done (ou InPosition , ou InVelocity , etc.). Les modes tampons sont également utilisés pour définir l'apparence de la courbe de vitesse lors de la transition des mouvements. L'entrée BufferMode est un ENUM de type MC_BUFFER_MODE. Aborting Mode par défaut sans mise en mémoire tampon. Le bloc fonctionnel démarre immédiatement et interrompt un mouvement actif. La commande prend effet immédiatement sur l'axe. Buffered Le bloc fonction démarre dès que le dernier mouvement commandé est terminé. Aucun mélange n'a lieu ici. Le nouveau mouvement démarre à la vitesse du mouvement précédent lorsque la condition de fin est atteinte ( Done , InVelocity , InEndVelocity , InGear , InSync , EndOfProfile , etc.). Si le mouvement précédent était MC_MoveAbsolute ou MC_MoveRelative , alors le nouveau mouvement démarre à l’arrêt. BlendingLow Le bloc fonction démarre dès que le dernier mouvement commandé est terminé. L'axe ne s'arrête pas entre les mouvements, mais passe par la position finale du premier mouvement à la vitesse la plus faible des deux commandes de mouvement. BlendingPrevious Le bloc fonction démarre dès que le dernier mouvement commandé est terminé. L'axe ne s'arrête pas entre les mouvements, mais passe par la position finale du premier mouvement à la vitesse de la première commande de mouvement. BlendingNext Le bloc fonction démarre dès que le dernier mouvement commandé est terminé. L'axe ne s'arrête pas entre deux mouvements, mais passe par la position finale du premier mouvement à la vitesse de la deuxième commande de mouvement. BlendingHigh Le bloc fonction démarre dès que le dernier mouvement commandé est terminé. L'axe ne s'arrête pas entre les mouvements, mais passe par la position finale du premier mouvement à la vitesse la plus élevée des deux commandes de mouvement. " }, 
{ "title" : "Blocs fonctionnels pris en charge ", 
"url" : "_sm_overview_mulitple_movements.html#UUID-2f590113-2f84-eead-4ae8-73304891aaa0_section-idm43431844838676", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commander plusieurs mouvements \/ Aperçu \/ Mode Tampon \/ Blocs fonctionnels pris en charge ", 
"snippet" : "Tous les blocs fonctionnels qui peuvent être spécifiés comme commandes mises en mémoire tampon\/mélange ont les entrées et sorties suivantes : BufferMode saisir ( MC_BUFFER_MODE taper) Active sortir: ( BOOL taper) Une commande est acceptée lorsque le bloc fonction passe à l'état Busy après qu'un nouv...", 
"body" : "Tous les blocs fonctionnels qui peuvent être spécifiés comme commandes mises en mémoire tampon\/mélange ont les entrées et sorties suivantes : BufferMode saisir ( MC_BUFFER_MODE taper) Active sortir: ( BOOL taper) Une commande est acceptée lorsque le bloc fonction passe à l'état Busy après qu'un nouveau mouvement ait été commandé. Bloc fonctionnel Peut être défini comme une commande tamponnée\/mélangée Peut être suivi d'une commande tamponnée\/mélangée Signal pertinent pour l’activation du prochain FB tamponné\/mélangé MC_Power Non Non MC_Home Non Non MC_Stop Non Non MC_Halt Non Non MC_MoveAbsolute MC_MoveRelative Oui Oui Done MC_MoveAdditive Non Oui ( Buffered seulement) Done MC_MoveSuperImposed MC_HaltSuperImposed Non Non Pour plus d'informations, voir : Comportement de MC_MoveSuperImposed et MC_HaltSuperImposedMC_MoveVelocity Oui Oui ( Buffered seulement) InVelocity SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative Non Oui ( Buffered seulement) InEndVelocity MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile Non Oui ( Buffered seulement) Done MC_CamIn Oui (uniquement Buffered et BlendingPrevious ) Oui, même si périodique (uniquement Buffered ) EndOfProfile MC_CamOut Non Oui ( Buffered seulement) Done MC_GearIn Oui ( BlendingPrevious seulement) Oui ( Buffered seulement) InGear MC_GearOut Non Oui ( Buffered seulement) Done MC_GearInPos Oui ( BlendingPrevious seulement) Oui ( Buffered seulement) InSync SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues Non Non SMC_SetTorque Non Non MC_Phasing Non Non MC_Jog SMC_Inch Non Non Ces blocs fonction ne doivent pas être utilisés lorsque les mouvements sont commandés en mode tampon. Buffered ou Blending* . Le jogging et les mouvements commandés pourraient s'interrompre. SMC_BacklashCompensation Non Non SMC_TrackAxis Non Non SMC_TrackSetValues Non Non Remarque pour MC_GearInPos et MC_GearIn : Le comportement des autres modes tampon comme BlendingPrevious est difficile à établir. Le principal problème est que la vitesse de ces blocs fonction peut changer à tout moment en fonction de l'axe maître. Parce que le mixage fonctionne mieux lorsque la vitesse de mixage est connue le plus tôt possible, seulement BlendingPrevious est pris en charge. Dans le cas d BlendingPrevious , la direction de l'axe maître peut également changer à tout moment. Cela signifie que la direction que doit avoir l'axe esclave pour MC_GearInPos n'est connue que lorsque le mélange est terminé. Cependant, nous avons besoin d’une direction pour le mouvement de mélange dès le début du mélange. C'est pourquoi le premier mouvement définit à la fois la vitesse et la direction du mélange, quelle que soit la direction définie par le mouvement suivant. MC_GearIn(Pos) . " }, 
{ "title" : "Comportement en cas de mouvements tamponnés ", 
"url" : "_sm_buffermode_buffered_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commander plusieurs mouvements \/ Comportement en cas de mouvements tamponnés ", 
"snippet" : "Lorsqu'un mouvement tamponné est commandé après MC_MoveAbsolute ou MC_MoveRelative , le mouvement tamponné est actif dans le même cycle où le mouvement précédent signale Done et atteint la vitesse 0. Cependant, l'interpolation du mouvement tamponné ne démarre qu'au cycle suivant, de sorte que la vit...", 
"body" : "Lorsqu'un mouvement tamponné est commandé après MC_MoveAbsolute ou MC_MoveRelative , le mouvement tamponné est actif dans le même cycle où le mouvement précédent signale Done et atteint la vitesse 0. Cependant, l'interpolation du mouvement tamponné ne démarre qu'au cycle suivant, de sorte que la vitesse de l'axe en fin de cycle est égale à 0. Lorsqu'un mouvement tampon est commandé après MC_CamIn , le mouvement tamponné est actif dans le même cycle où le mouvement précédent rapporte EndOfProfile . L'interpolation du mouvement tamponné commence immédiatement dans ce cycle. " }, 
{ "title" : "Comportement en cas de mélange ", 
"url" : "_sm_buffermode_blending.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commander plusieurs mouvements \/ Comportement en cas de mélange ", 
"snippet" : "Une propriété fondamentale du comportement de mélange de CODESYS SoftMotion est que l'axe se déplace le long des mêmes positions pendant le mélange que pendant un mouvement tamponné. La seule différence est la vitesse le long de ces positions. Ceci est évident pour les cas simples. Voir l'exemple su...", 
"body" : "Une propriété fondamentale du comportement de mélange de CODESYS SoftMotion est que l'axe se déplace le long des mêmes positions pendant le mélange que pendant un mouvement tamponné. La seule différence est la vitesse le long de ces positions. Ceci est évident pour les cas simples. Voir l'exemple suivant pour cela : Il existe des cas dans lesquels la propriété de parcourir les mêmes positions par l'axe indépendamment du mode tampon influence la vitesse de mélange effective entre les deux mouvements. C'est le cas, par exemple, si l'exemple ci-dessus est modifié de telle sorte que la vitesse maximale du deuxième mouvement soit si élevée qu'elle ne puisse pas être atteinte en position de mélange. Selon les règles décrites dans PLCopen, la vitesse de mélange doit être de 500 u\/s. Cependant, pour atteindre cette vitesse à la position 100 u, l'axe devrait s'inverser, se déplacer dans le sens négatif jusqu'à une position inférieure à 0 u, puis accélérer jusqu'à 500 u\/s. Au lieu de cela, dans de tels cas, la vitesse de mélange effective est limitée à la vitesse maximale pouvant être atteinte sans inversion ni dépassement de position. Dans cet exemple, la vitesse maximale est de 447 u\/s. Les règles suivantes pour la vitesse de mélange effective résultent de la propriété selon laquelle le mode tampon ne modifie pas les positions entraînées : Si la vitesse de mélange ne peut pas être atteinte sans dépassement de position, alors la vitesse de mélange effective est la prochaine vitesse possible qui peut être atteinte sans dépassement (voir l'exemple ci-dessus). Remarque : La vitesse de mélange effective peut être supérieure ou inférieure à la vitesse de mélange. Si la direction au début du deuxième mouvement est opposée à la direction du premier mouvement, la vitesse de fusion effective est définie sur 0. Cela empêche la position de dépasser dans la direction du premier mouvement au-delà de sa position cible. Si le trajet du deuxième mouvement est trop court pour permettre une décélération de la vitesse de mélange à l'arrêt, alors la vitesse de mélange effective est ajustée. Il est réglé sur la vitesse maximale qui permet un freinage sûr jusqu'à l'arrêt sur la trajectoire du deuxième mouvement. Dans le cas d'axes modulo, l'effet de l'entrée Direction de MC_MoveAbsolute n'est pas affecté par la fusion avec un deuxième mouvement. Cela signifie que la position cible du premier mouvement est toujours dans la même période modulo, qu'un mouvement de mélange suive ou non. Dans le cas d'axes modulo et d'un deuxième mouvement de type MC_MoveAbsolute , la vitesse de mélange n'affecte pas la période modulo de la position cible du deuxième mouvement lorsque Direction = fastest est utilisé. Cela signifie que la même période cible est sélectionnée, que le deuxième mouvement soit commandé avec Buffered ou Blending . " }, 
{ "title" : "Accélération, décélération et secousses pendant le mélange ", 
"url" : "_sm_buffermode_blending.html#UUID-60273b62-3ad5-7014-3fa9-e2fa61f7a008_section-idm235068399508112", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commander plusieurs mouvements \/ Comportement en cas de mélange \/ Accélération, décélération et secousses pendant le mélange ", 
"snippet" : "Le mode tampon ( BlendingLow \/ BlendingHigh \/ BlendingPrevious \/ BlendingNext ) du second mouvement détermine la vitesse à laquelle la position de départ du mouvement est atteinte. En revanche, l'accélération maximale, la décélération et la secousse maximales pendant le mélange sont toujours les val...", 
"body" : "Le mode tampon ( BlendingLow \/ BlendingHigh \/ BlendingPrevious \/ BlendingNext ) du second mouvement détermine la vitesse à laquelle la position de départ du mouvement est atteinte. En revanche, l'accélération maximale, la décélération et la secousse maximales pendant le mélange sont toujours les valeurs du premier mouvement. La raison en est que la position cible du premier mouvement peut être dépassée si, par exemple, le retard maximum du second mouvement est inférieur à celui du premier et si le retard le plus faible est utilisé. " }, 
{ "title" : "Mise en mémoire tampon\/mélange à partir d'un mouvement continu ou synchronisé ", 
"url" : "_sm_buffermode_continuous_motion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commander plusieurs mouvements \/ Mise en mémoire tampon\/mélange à partir d'un mouvement continu ou synchronisé ", 
"snippet" : "Selon PLCopen, le mode tampon de mélange détermine la vitesse à la fin du premier mouvement. Dans certains cas, la vitesse est déjà entièrement déterminée par le premier mouvement. C'est le cas lorsque le premier mouvement est de l'un des types suivants : Mouvement continu ( MC_MoveVelocity , SMC_Mo...", 
"body" : "Selon PLCopen, le mode tampon de mélange détermine la vitesse à la fin du premier mouvement. Dans certains cas, la vitesse est déjà entièrement déterminée par le premier mouvement. C'est le cas lorsque le premier mouvement est de l'un des types suivants : Mouvement continu ( MC_MoveVelocity , SMC_MoveContinuousRelative , ou SMC_MoveContinuousAbsolute ) Mouvement synchronisé ( MC_CamIn , MC_GearIn , ou MC_GearInPos ) Dans ces cas, CODESYS SoftMotion ne prend en charge que le Buffered et Aborting modes tampons. L'utilisation de l'un des modes de tampon de mélange provoque une erreur FB ( SMC_BLENDING_NOT_SUPPORTED_BY_PREVIOUS_MOVEMENT) . Lorsque la commande mise en mémoire tampon suivante devient active, la sortie CommandAborted est réglé sur TRUE pour une commande de mouvement précédente. De plus, les sorties \"Inxxx\" (par exemple, InVelocity pour MC_MoveVelocity ou InGear pour MC_GearIn ) et la sortie Busy sont réglés pour un cycle. Ceci contraste avec PLCopen, Section 2.4.1, dans lequel CommandAborted et \"Inxxx\" ainsi que Busy s'excluent mutuellement. " }, 
{ "title" : "Ordre d'exécution des blocs fonctionnels de mouvement ", 
"url" : "_sm_buffermode_execution_order.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commander plusieurs mouvements \/ Ordre d'exécution des blocs fonctionnels de mouvement ", 
"snippet" : "Lorsque des mouvements tamponnés ou des mouvements de mélange sont commandés, l'instance de bloc fonction qui commande le mouvement suivant ne doit pas être exécutée avant l'instance de bloc fonction qui commande le mouvement précédent. Si cet ordre n'est pas respecté, la nouvelle erreur SMC_FB_WASN...", 
"body" : "Lorsque des mouvements tamponnés ou des mouvements de mélange sont commandés, l'instance de bloc fonction qui commande le mouvement suivant ne doit pas être exécutée avant l'instance de bloc fonction qui commande le mouvement précédent. Si cet ordre n'est pas respecté, la nouvelle erreur SMC_FB_WASNT_CALLED_DURING_MOTION est signalé et l'axe passe à l'état Errorstop . Exemple movement1();\nmovement2(); Ordre d'exécution correct Exécution de movement1() Exécution de movement2() dès que movement1() c'est actif Ordre d'exécution invalide Exécution de movement2() Exécution de movement1() dès que movement2() c'est actif Cela se traduit par la SMC_MOVING_WITHOUT_ACTIVE_MOVEMENT Erreur. " }, 
{ "title" : "Utilisation d'une instance de bloc fonctionnel pour contrôler plusieurs mouvements ", 
"url" : "_sm_buffermode_one_fb.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commander plusieurs mouvements \/ Utilisation d'une instance de bloc fonctionnel pour contrôler plusieurs mouvements ", 
"snippet" : "Une seule instance de bloc fonction (par exemple, de MC_MoveAbsolute ) ne peut pas être utilisé pour contrôler plusieurs mouvements tamponnés\/mélangés tant qu'il est Busy . Lorsqu'une instance de bloc fonction est Busy , la commande d'un nouveau mouvement tamponné ou mélangé avec cette instance entr...", 
"body" : "Une seule instance de bloc fonction (par exemple, de MC_MoveAbsolute ) ne peut pas être utilisé pour contrôler plusieurs mouvements tamponnés\/mélangés tant qu'il est Busy . Lorsqu'une instance de bloc fonction est Busy , la commande d'un nouveau mouvement tamponné ou mélangé avec cette instance entraîne l'erreur SMC_MORE_THAN_ONE_MOVEMENT_PER_INSTANCE . Pour commander rapidement plusieurs mouvements tamponnés ou mélangés du même type, plusieurs instances de module de fonction sont nécessaires. " }, 
{ "title" : "Comportement en cas d'erreur ", 
"url" : "_sm_basic_behavior_error.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commander plusieurs mouvements \/ Comportement en cas d'erreur ", 
"snippet" : "En cas d'erreur d'axe (par exemple, l'axe passe à l'état Errorstop ), le mouvement actif signalera une erreur avec tous les autres mouvements acceptés. Si une erreur FB se produit dans le bloc fonctionnel d'un mouvement actif, tous les mouvements acceptés ultérieurement signalent également une erreu...", 
"body" : "En cas d'erreur d'axe (par exemple, l'axe passe à l'état Errorstop ), le mouvement actif signalera une erreur avec tous les autres mouvements acceptés. Si une erreur FB se produit dans le bloc fonctionnel d'un mouvement actif, tous les mouvements acceptés ultérieurement signalent également une erreur. Cela contraste avec PLCopen, section 2.2.2, dans laquelle les commandes suivantes continueront leur exécution après une erreur FB. " }, 
{ "title" : "Comportement de MC_MoveSuperImposed et MC_HaltSuperImposed ", 
"url" : "_sm_buffermode_movesuperimposed.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commander plusieurs mouvements \/ Comportement de MC_MoveSuperImposed et MC_HaltSuperImposed ", 
"snippet" : "Si MC_MoveSuperImposed ou MC_HaltSuperImposed est actif et le mouvement sous-jacent est interrompu, alors MC_MoveSuperImposed \/ MC_HaltSuperImposed est également avortée. Si le mouvement sous-jacent n'est pas annulé, mais un autre mouvement avec le mode Buffered ou l'un des Blending-BufferMode est c...", 
"body" : "Si MC_MoveSuperImposed ou MC_HaltSuperImposed est actif et le mouvement sous-jacent est interrompu, alors MC_MoveSuperImposed \/ MC_HaltSuperImposed est également avortée. Si le mouvement sous-jacent n'est pas annulé, mais un autre mouvement avec le mode Buffered ou l'un des Blending-BufferMode est commandé, le comportement est le suivant : MC_MoveSuperImposed \/ MC_HaltSuperImposed ne sera pas annulé lorsque le mélange démarre ou que le nouveau mouvement devient actif. Plutôt, MC_MoveSuperImposed \/ MC_HaltSuperImposed continue en arrière-plan jusqu'à ce qu'il soit terminé. " }, 
{ "title" : "Dès CODESYS SoftMotion version 4.17.0.0 ", 
"url" : "_sm_buffermode_movesuperimposed.html#UUID-55e334a2-da44-00d6-2f2a-9f3f03732605_section-idm234439539337338", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commander plusieurs mouvements \/ Comportement de MC_MoveSuperImposed et MC_HaltSuperImposed \/ Dès CODESYS SoftMotion version 4.17.0.0 ", 
"snippet" : "Quand un MC_MoveAbsolute configuré avec un mode tampon ou un mode de mélange est commandé, la position finale résultante est la somme de la position configurée à MC_MoveAbsolute et la distance configurée à MC_MoveSuperImposed \/ MC_HaltSuperImposed . Peu importe que ce soit ou non MC_MoveSuperImposed...", 
"body" : "Quand un MC_MoveAbsolute configuré avec un mode tampon ou un mode de mélange est commandé, la position finale résultante est la somme de la position configurée à MC_MoveAbsolute et la distance configurée à MC_MoveSuperImposed \/ MC_HaltSuperImposed . Peu importe que ce soit ou non MC_MoveSuperImposed \/ MC_HaltSuperImposed est toujours actif. La distance SuperImposed est conservée même une fois le mouvement SuperImposed terminé. La distance SuperImposed est réinitialisée dès qu'un mouvement d'abandon est commandé. " }, 
{ "title" : "Avant CODESYS SoftMotion version 4.17.0.0 ", 
"url" : "_sm_buffermode_movesuperimposed.html#UUID-55e334a2-da44-00d6-2f2a-9f3f03732605_section-idm234439540497353", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commander plusieurs mouvements \/ Comportement de MC_MoveSuperImposed et MC_HaltSuperImposed \/ Avant CODESYS SoftMotion version 4.17.0.0 ", 
"snippet" : "Si un MC_MoveAbsolute attribué au mode tampon ou à un mode de fusion est commandé tandis qu'un MC_MoveSuperImposed \/ MC_HaltSuperImposed est actif, la position finale résultante dépend de l'état de MC_MoveSuperImposed \/ MC_HaltSuperImposed au moment où le MC_MoveAbsolute c'est actif. Si MC_MoveSuper...", 
"body" : "Si un MC_MoveAbsolute attribué au mode tampon ou à un mode de fusion est commandé tandis qu'un MC_MoveSuperImposed \/ MC_HaltSuperImposed est actif, la position finale résultante dépend de l'état de MC_MoveSuperImposed \/ MC_HaltSuperImposed au moment où le MC_MoveAbsolute c'est actif. Si MC_MoveSuperImposed \/ MC_HaltSuperImposed est encore actif à ce moment, la position finale qui en résulte est la somme de la position de MC_MoveAbsolute et la distance de MC_MoveSuperImposed \/ MC_HaltSuperImposed . En revanche, si MC_MoveSuperImposed \/ MC_HaltSuperImposed n'est plus actif à ce moment-là, la position finale qui en résulte est alors la position de MC_MoveAbsolute sans la distance de MC_MoveSuperImposed \/ MC_HaltSuperImposed . De la même manière, la vitesse résultante de MC_MoveVelocity dépend du statut de MC_MoveSuperImposed \/ MC_HaltSuperImposed quand MC_MoveVelocity c'est actif. La courbe ci-dessous montre un MC_MoveSuperImposed ( souper bloc fonctionnel) parallèle à trois mouvements absolus avec mode tampon de mélange BlendingHigh . Les premier et deuxième mouvements sont commandés avec une vitesse de 100 u\/s avec le ma0 et ma1 blocs fonctionnels. Le ma2 Le bloc fonctionnel commande le troisième mouvement avec une vitesse de 120 u\/s. La première position cible est de 10 u, la deuxième de 25 u et la troisième de 40 u. La vitesse du mouvement superposé est de 20 et la distance est de 10. La position résultante est de 50 u : la position du dernier mouvement absolu plus la distance de MC_MoveSuperimposed . " }, 
{ "title" : "Points de commutation numériques ", 
"url" : "_sm_digital_switches.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Points de commutation numériques ", 
"snippet" : "CODESYS SoftMotion propose différentes options pour créer des points de commutation numériques. Cette section donne un aperçu des avantages et des inconvénients respectifs....", 
"body" : "CODESYS SoftMotion propose différentes options pour créer des points de commutation numériques. Cette section donne un aperçu des avantages et des inconvénients respectifs. " }, 
{ "title" : "Exemple d'application ", 
"url" : "_sm_digital_switches.html#UUID-5c8c3ded-d3b5-7c4d-2e37-1277ff2bb5f0_section-idm235063632666072", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Points de commutation numériques \/ Exemple d'application ", 
"snippet" : "Des points de commutation numériques sont nécessaires, par exemple, pour allumer un pistolet à colle en fonction de la position de l'axe. Dans l'exemple suivant, le pistolet à colle doit appliquer de l'adhésif sur un produit de la position 90 à la position 120. Un pistolet à colle a un délai entre l...", 
"body" : "Des points de commutation numériques sont nécessaires, par exemple, pour allumer un pistolet à colle en fonction de la position de l'axe. Dans l'exemple suivant, le pistolet à colle doit appliquer de l'adhésif sur un produit de la position 90 à la position 120. Un pistolet à colle a un délai entre la mise en marche et l'application de la colle. Il en va de même pour la mise hors tension. Une compensation marche\/arrêt est donc requise pour que le pistolet à colle soit allumé 50 ms avant la position 90 et éteint 50 ms avant la position 120 " }, 
{ "title" : "Vue d'ensemble des blocs fonctionnels ", 
"url" : "_sm_digital_switches.html#UUID-5c8c3ded-d3b5-7c4d-2e37-1277ff2bb5f0_section-idm235063632773598", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Points de commutation numériques \/ Vue d'ensemble des blocs fonctionnels ", 
"snippet" : "Bloc fonctionnel Points de commutation multiples Compensation activé\/désactivée Prévision Haute précision (résolution temporelle supérieure à la durée du cycle) Base de données Remarque SMC_DigitalCamSwitch_HighPrecision 1 2 Définir la position ou la position réelle Utile lorsqu'une précision tempor...", 
"body" : "Bloc fonctionnel Points de commutation multiples Compensation activé\/désactivée Prévision Haute précision (résolution temporelle supérieure à la durée du cycle) Base de données Remarque SMC_DigitalCamSwitch_HighPrecision 1 2 Définir la position ou la position réelle Utile lorsqu'une précision temporelle plus élevée est requise. En plus de ce bloc fonctionnel, une carte de sortie numérique de haute précision est requise pour un fonctionnement de haute précision. Cette combinaison permet de commuter les sorties avec une précision temporelle élevée, même à des temps de cycle plus élevés. Pour plus d'informations sur l'utilisation du bloc fonctionnel, consultez ce qui suit : exemple Utilisation de MC_DigitalCamSwitch_HighPrecision. SMC_GetTravelTime 2 Définir la position ou la position réelle Utile s'il s'agit d'une version distincte du DigitalCamSwitch un bloc fonctionnel doit être implémenté (par exemple, parce que des fonctions supplémentaires sont requises). MC_DigitalCamSwitch 3 Définir la position ou la position réelle Utile si une résolution temporelle précise par cycle est suffisante. SMC_GetTappetValue Définir la position ou la position réelle Ces blocs fonctionnels sont conservés pour des raisons de compatibilité uniquement. Pour les projets actuels et futurs, les autres blocs fonctionnels plus avancés devraient être utilisés. SMC_CamRegister Définir la position ou la position réelle 1 Exactement. Les données des prévisions sont utilisées. 2 La prévision doit être définie au moyen du SMC_SetForecast bloc fonctionnel. Pour plus d'informations sur les prévisions, consultez les rubriques suivantes : Prévision. 3 Uniquement par extrapolation " }, 
{ "title" : "Adaptation dynamique avec MC_SetOverride ", 
"url" : "_sm_adjust_dynamics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Adaptation dynamique avec MC_SetOverride ", 
"snippet" : "La dynamique (vitesse, accélération et à-coup) des mouvements actifs et futurs peut être adaptée en utilisant MC_SetOverride . Une adaptation de la dynamique signifie toujours une réduction par rapport au mouvement initialement commandé (les facteurs supérieurs à 1 ne sont pas autorisés). Cela perme...", 
"body" : "La dynamique (vitesse, accélération et à-coup) des mouvements actifs et futurs peut être adaptée en utilisant MC_SetOverride . Une adaptation de la dynamique signifie toujours une réduction par rapport au mouvement initialement commandé (les facteurs supérieurs à 1 ne sont pas autorisés). Cela permet aux opérateurs de machines d'arrêter temporairement un mouvement ( VelFactor = 0 ) ou l'exécuter avec des valeurs dynamiques réduites, par exemple pour vérifier de nouvelles séquences de mouvements. L'adaptation de la dynamique avec MC_SetOverride et l'adaptation de trajectoire qui en résulte prend effet directement dans le même cycle. La condition pour cela est que MC_SetOverride est appelé avant le bloc fonction de mouvement actif. Pour plus d'informations, voir aussi l'exemple Annulation de la vitesse pour les axes SoftMotion. " }, 
{ "title" : "Blocs fonctionnels pris en charge ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4626631011382434026679825113", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Adaptation dynamique avec MC_SetOverride \/ Blocs fonctionnels pris en charge ", 
"snippet" : "Bloc fonctionnel Soutien: MC_SetOverride Commentaire MC_Stop -- MC_Stop est un arrêt d'urgence qui doit toujours être exécuté le plus rapidement possible. Par conséquent, les facteurs dynamiques de MC_SetOverride n'ont aucun effet sur le mouvement. MC_Halt ✓ Le facteur de vitesse n'a aucun effet. MC...", 
"body" : "Bloc fonctionnel Soutien: MC_SetOverride Commentaire MC_Stop -- MC_Stop est un arrêt d'urgence qui doit toujours être exécuté le plus rapidement possible. Par conséquent, les facteurs dynamiques de MC_SetOverride n'ont aucun effet sur le mouvement. MC_Halt ✓ Le facteur de vitesse n'a aucun effet. MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative ✓ MC_Jog SMC_Inch ✓ SMC_Homing ✓ SMC_ControlAxisByPos SMC_ControlAxisByPosVel SMC_ControlAxisByVel O Les facteurs dynamiques n'ont d'effet que si le bAvoidGaps La fonction est activée et un saut a été détecté. Les facteurs de MC_SetOverride prendre en compte à la fois l'arrêt et le mouvement absolu ultérieur pour combler l'écart. MC_Home -- Le référencement est exécuté indépendamment par le variateur afin que les facteurs dynamiques de MC_SetOverride n'ont aucun effet. MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile -- Nous vous recommandons d'utiliser MC_CamIn à la place de ces blocs fonctionnels. MC_CamIn O Les facteurs dynamiques n'ont plus d'effet dès que le mouvement est synchronisé ( MC_CamIn.InSync = TRUE ). MC_CamOut -- MC_CamOut n'a pas de limites dynamiques réglables et doit maintenir la vitesse actuelle. Les facteurs dynamiques de MC_SetOverride n’ont donc aucun effet. MC_GearIn O Les facteurs dynamiques n'ont plus d'effet dès que le mouvement est synchronisé ( MC_GearIn.InGear = TRUE ). Lors du ramping, seuls les facteurs d'accélération et d'à-coup sont pris en compte. Modifications du facteur de vitesse (en particulier VelFactor=0 ) sont ignorés. MC_GearInPos -- Contrairement à MC_GearIn , il n'a pas de mouvement de rampe configurable. Par conséquent, les facteurs dynamiques de MC_SetOverride n'ont pas d'effet. SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues -- Ces blocs fonctionnels écrivent les valeurs définies de l'axe (par exemple, fSetPosition ). Ces valeurs ne doivent pas être modifiées. Par conséquent, les facteurs dynamiques de MC_SetOverride n'ont pas d'effet. MC_Phasing O Les facteurs dynamiques n'ont plus d'effet dès que le mouvement est synchronisé ( MC_Phasing.Done = TRUE ). Lors du ramping, seuls les facteurs d'accélération et d'à-coup sont pris en compte. Modifications du facteur de vitesse (en particulier VelFactor=0 ) sont ignorés. SMC_BacklashCompensation -- Les facteurs dynamiques n'ont pas d'effet sur les mouvements synchronisés. Par conséquent, ce bloc fonction ignore les facteurs dynamiques de MC_SetOverride . " }, 
{ "title" : "Dépassement de la position cible ou de la vitesse cible en modifiant les facteurs dynamiques ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4552469374918434026680028303", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Adaptation dynamique avec MC_SetOverride \/ Dépassement de la position cible ou de la vitesse cible en modifiant les facteurs dynamiques ", 
"snippet" : "Si le facteur d'accélération et\/ou le facteur d'à-coup diminue pendant un mouvement actif, la position cible ou la vitesse cible peut être temporairement dépassée. Cela pourrait endommager la machine. Avec SMC_MoveContinuousAbsolute et SMC_MoveContinuousRelative , une modification du facteur de vite...", 
"body" : "Si le facteur d'accélération et\/ou le facteur d'à-coup diminue pendant un mouvement actif, la position cible ou la vitesse cible peut être temporairement dépassée. Cela pourrait endommager la machine. Avec SMC_MoveContinuousAbsolute et SMC_MoveContinuousRelative , une modification du facteur de vitesse peut également conduire à un dépassement des limites ou à une inversion. Plus de détails peuvent être trouvés dans la documentation des deux blocs fonctionnels. " }, 
{ "title" : "Effet du profil de vitesse sur l'utilisation de MC_SetOverride ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4552469646968034026680341439", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Adaptation dynamique avec MC_SetOverride \/ Effet du profil de vitesse sur l'utilisation de MC_SetOverride ", 
"snippet" : "Il est généralement recommandé d'utiliser MC_SetOverride ainsi qu'un profil de vitesse trapézoïdal ou quadratique des axes. Les profils de vitesse quadratique et de vitesse sin² ne répondent pas bien au redémarrage ou à l'interruption ( Interruption des mouvements). Étant donné qu'une modification d...", 
"body" : "Il est généralement recommandé d'utiliser MC_SetOverride ainsi qu'un profil de vitesse trapézoïdal ou quadratique des axes. Les profils de vitesse quadratique et de vitesse sin² ne répondent pas bien au redémarrage ou à l'interruption ( Interruption des mouvements). Étant donné qu'une modification de la dérogation équivaut à un redémarrage du mouvement avec des limites modifiées, il est également possible que les limites commandées soient dépassées lors de l'utilisation de ces profils de vitesse en combinaison MC_SetOverride . " }, 
{ "title" : "Effet de MC_SetOverride sur les mouvements coordonnés avec un groupe d'axes ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm456655390848963402668059106", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Adaptation dynamique avec MC_SetOverride \/ Effet de MC_SetOverride sur les mouvements coordonnés avec un groupe d'axes ", 
"snippet" : "Mouvements coordonnés avec un groupe d'axes (par exemple, MC_MoveLinearAbsolute ) considérez les remplacements définis avec MC_SetOverride pour chaque axe lors de la planification du mouvement. Inversement, MC_GroupSetOverride écrase les remplacements de chaque axe du groupe d'axes....", 
"body" : "Mouvements coordonnés avec un groupe d'axes (par exemple, MC_MoveLinearAbsolute ) considérez les remplacements définis avec MC_SetOverride pour chaque axe lors de la planification du mouvement. Inversement, MC_GroupSetOverride écrase les remplacements de chaque axe du groupe d'axes. " }, 
{ "title" : "Prévision ", 
"url" : "_sm_basic_forecast.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Prévision ", 
"snippet" : "La fonction de prévision peut être utilisée pour interroger des informations sur le mouvement futur d'un axe. Une application importante de la prévision consiste à déterminer le temps nécessaire pour atteindre une position (similaire à la fonctionnalité de déclenchement). Une autre application consi...", 
"body" : "La fonction de prévision peut être utilisée pour interroger des informations sur le mouvement futur d'un axe. Une application importante de la prévision consiste à déterminer le temps nécessaire pour atteindre une position (similaire à la fonctionnalité de déclenchement). Une autre application consiste à déterminer la position et la vitesse qu'aura un axe à un instant donné. De cette manière, les temps morts peuvent être compensés lors de l'activation des actionneurs, par exemple lors de l'activation d'une buse d'encollage. Il peut également être utilisé pour contrôler avec précision les actionneurs avec temps mort, par exemple pour contrôler la sortie de collage en fonction de la vitesse de l'axe 100 ms à l'avenir. Pour implémenter ces applications, vous pouvez utiliser le SMC_GetTravelTime et SMC_ReadSetValues blocs fonctionnels après avoir configuré la durée de prévision avec SMC_SetForecast . Pour un exemple d'utilisation, voir : Prévision des mouvements sur un seul axe" }, 
{ "title" : "Blocs fonctionnels de mouvement avec fonctionnalité de prévision ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm2344331274012", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Prévision \/ Blocs fonctionnels de mouvement avec fonctionnalité de prévision ", 
"snippet" : "L'aperçu suivant montre quels blocs fonctionnels prennent en charge la fonction de prévision. Bloc fonctionnel Prévision MC_Home -- MC_Stop ✓ MC_Halt ✓ MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed MC_HaltSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveC...", 
"body" : "L'aperçu suivant montre quels blocs fonctionnels prennent en charge la fonction de prévision. Bloc fonctionnel Prévision MC_Home -- MC_Stop ✓ MC_Halt ✓ MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed MC_HaltSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative ✓ MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile -- MC_CamIn ✓ MC_CamOut ✓ MC_GearIn ✓ MC_GearOut ✓ MC_GearInPos ✓ SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues -- SMC_SetTorque -- MC_Phasing ✓ MC_Jog SMC_Inch ✓ SMC_BacklashCompensation ✓ " }, 
{ "title" : "Activation de la fonction de prévision ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433129890703", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Prévision \/ Activation de la fonction de prévision ", 
"snippet" : "La fonction de prévision est désactivée par défaut. Cela signifie que SMC_ReadSetValues renvoie des valeurs valides uniquement pour un TimeOffset entre 0 s (début du cycle de tâche en cours) et l'intervalle de tâche (fin du cycle de tâche en cours), et SMC_GetTravelTime renvoie une heure valide uniq...", 
"body" : "La fonction de prévision est désactivée par défaut. Cela signifie que SMC_ReadSetValues renvoie des valeurs valides uniquement pour un TimeOffset entre 0 s (début du cycle de tâche en cours) et l'intervalle de tâche (fin du cycle de tâche en cours), et SMC_GetTravelTime renvoie une heure valide uniquement pour les positions atteintes dans ce cycle. Le SMC_SetForecast Le bloc fonctionnel est utilisé pour configurer la durée de prévision requise et la SMC_GetForecast Le bloc fonctionnel est utilisé pour lire. Remarques: La durée prévisionnelle peut être modifiée à tout moment. Évitez une durée de prévision inutilement longue car le calcul de la prévision consomme du temps de calcul. Sélectionnez la plus petite valeur suffisante pour votre application. Si vous utilisez des blocs fonction maître\/esclave (tels que MC_CamIn ), alors la prévision doit être activée à la fois pour l'axe maître et pour l'axe esclave. " }, 
{ "title" : "Ordre d'appel ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130424909", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Prévision \/ Ordre d'appel ", 
"snippet" : "Pour que la fonction de prévision donne les meilleurs résultats possibles, il est important de s'assurer que les blocs fonction maître\/esclave sont appelés dans le bon ordre. Ceci s'applique à MC_CamIn , MC_GearIn , MC_GearInPos , MC_Phasing , SMC_BacklashCompensation , et SMC_TrackAxis . Le bloc fo...", 
"body" : "Pour que la fonction de prévision donne les meilleurs résultats possibles, il est important de s'assurer que les blocs fonction maître\/esclave sont appelés dans le bon ordre. Ceci s'applique à MC_CamIn , MC_GearIn , MC_GearInPos , MC_Phasing , SMC_BacklashCompensation , et SMC_TrackAxis . Le bloc fonction mouvement de l’axe maître doit être appelé avant le bloc fonction maître\/esclave. Même sans prévision, la trajectoire est meilleure lorsque l'ordre d'appel est correct. Lorsque l'ordre est erroné, le mouvement de l'esclave est retardé d'un cycle. Pour MC_SetOverride , ce bloc fonction doit également être appelé avant les blocs fonction de mouvement de l'axe. En modifiant la correction, le mouvement de l'axe est modifié dans le même cycle de tâche. Les valeurs précédemment déterminées sur la base des prévisions perdent ainsi leur validité. Ils sont à nouveau déterminés la prochaine fois SMC_GetTravelTime ou SMC_ReadSetValues est appelé. " }, 
{ "title" : "Modes tampon ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130652478", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Prévision \/ Modes tampon ", 
"snippet" : "La fonction prévisionnelle ne se limite pas à un seul mouvement. Il s'étend également à tous les mouvements ultérieurs qui sont commandés avec un mode blending ou buffered buffer. Lorsqu'un mouvement interrompu est exécuté sur un axe, cela modifie le mouvement de l'axe dans ce cycle de tâche. Les va...", 
"body" : "La fonction prévisionnelle ne se limite pas à un seul mouvement. Il s'étend également à tous les mouvements ultérieurs qui sont commandés avec un mode blending ou buffered buffer. Lorsqu'un mouvement interrompu est exécuté sur un axe, cela modifie le mouvement de l'axe dans ce cycle de tâche. Les valeurs précédemment déterminées sur la base des prévisions perdent ainsi leur validité. Ils sont à nouveau déterminés la prochaine fois SMC_GetTravelTime ou SMC_ReadSetValues est appelé. " }, 
{ "title" : "Prévisions\/restrictions efficaces ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130869747", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Prévision \/ Prévisions\/restrictions efficaces ", 
"snippet" : "Idéalement, la durée de prévision effective disponible est égale à la durée de prévision configurée. Cependant, certains facteurs peuvent conduire à ce que la prévision effective soit plus courte que la prévision configurée. Lorsqu'un mouvement maître\/esclave est exécuté, la prévision effective de l...", 
"body" : "Idéalement, la durée de prévision effective disponible est égale à la durée de prévision configurée. Cependant, certains facteurs peuvent conduire à ce que la prévision effective soit plus courte que la prévision configurée. Lorsqu'un mouvement maître\/esclave est exécuté, la prévision effective de l'esclave est le minimum de la prévision effective du maître et de la prévision configurée de l'esclave. Pour les axes logiques et les axes codeurs, la prévision effective est toujours 0. Si le bloc fonctionnel de mouvement actif ne prend pas en charge la fonction de prévision, la prévision effective est également 0. Dans tous les autres cas, la prévision effective est la même que la prévision configurée. " }, 
{ "title" : "Diagnostics ", 
"url" : "_sm_basic_error_diagnosis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Diagnostics ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Erreurs courantes ", 
"url" : "_sm_basic_common_errors.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Diagnostics \/ Erreurs courantes ", 
"snippet" : "Cette page décrit les erreurs courantes lors de l'utilisation CODESYS Softmotion Basic , leurs causes et les actions possibles à entreprendre pour corriger l'erreur. Pour une liste de toutes les erreurs possibles avec une brève description, consultez la documentation de la bibliothèque : SMC_ERREUR ...", 
"body" : "Cette page décrit les erreurs courantes lors de l'utilisation CODESYS Softmotion Basic , leurs causes et les actions possibles à entreprendre pour corriger l'erreur. Pour une liste de toutes les erreurs possibles avec une brève description, consultez la documentation de la bibliothèque : SMC_ERREUR Code d'erreur Description et causes Actions SMC_DI_AXIS_ERROR Le lecteur a signalé une erreur. Causes possibles: Décalage de position Fin de course Surcharge (erreur I²t) Vérifiez quelle erreur le lecteur signale. L'erreur peut être lue sur l'écran du variateur (si disponible) ou en la récupérant avec le MC_ReadAxisError bloc fonctionnel. SMC_AXIS_ERROR_DURING_MOTION Le lecteur a signalé une erreur. Lors d'un mouvement, le bloc de mouvement actif renvoie cette erreur. Voir les actions pour l'erreur SMC_DI_AXIS_ERROR . SMC_FB_WASNT_CALLED_DURING_MOTION Le bloc fonction qui contrôle le mouvement actif n'a pas été appelé dans le cycle en cours. Causes possibles : L'ordre d'appel pour les mouvements mis en mémoire tampon ou les mouvements de fusion est incorrect. L'instance de bloc fonctionnel du mouvement suivant ne doit pas être appelée avant l'instance de bloc fonctionnel qui a commandé le mouvement précédent. Dès SoftMotion version 4.15.0.0, le message de journal de cette erreur contient le chemin d'instance vers le bloc fonctionnel concerné. Dans l'application, vérifiez la raison pour laquelle le bloc fonctionnel n'a pas été appelé de manière cyclique. Corrigez l'appel pour qu'il soit effectué de manière cyclique (au moins tant que le bloc est utilisé). SMC_BLOCKING_MC_STOP_WASNT_CALLED Lors d'un arrêt actif, le bloc fonction associé MC_Stop n’a pas été appelé dans le cycle en cours. Voir les actions pour l'erreur SMC_FB_WASNT_CALLED_DURING_MOTION . SMC_AXIS_NOT_READY_FOR_MOTION L'axe n'est pas prêt à l'emploi et ne peut pas exécuter le mouvement souhaité. Causes possibles: L'axe n'est pas dans un état opérationnel pour le mouvement concerné (par exemple, power_off ou errorstop ). L'axe est dans un état d'erreur et tous les mouvements mis en mémoire tampon renvoient cette erreur. L'axe est dans le stopping état (pendant une activité MC_Stop ) et un nouveau mouvement d'abandon est commandé. Vérifiez l'état de l'axe : L'axe est-il dans un état opérationnel par MC_Power ? L'axe est-il dans le errorstop État? Si tel est le cas, identifiez l'erreur d'axe et corrigez-la. L’état de l’axe correspond-il au mouvement commandé ? Par exemple, MC_CamOut ne peut être commandé que lorsque l'axe est dans l'état de mouvement synchronisé. SMC_FB_CALLED_FROM_WRONG_TASK Le SoftMotion Le bloc a été appelé à partir d'une tâche qui ne correspond pas à la tâche de bus de l'axe. Parce que le SoftMotion Les blocs changent de valeurs dans l'axe, des états incohérents peuvent se produire si des appels sont effectués à partir de tâches autres que la tâche de bus. Cela peut conduire à des erreurs indéfinies, ce qui est évité par cette erreur. Vérifiez le journal : l'axe et l'instance de bloc concernés sont enregistrés. Supprimez l'appel de la tâche incorrecte. SMC_DI_FIELDBUS_LOST_SYNCRONICITY Se produit lors de l'utilisation EtherCAT avec des horloges distribuées si le télégramme du contrôleur vers l'entraînement n'a pas été reçu à temps (dans la fenêtre de temps définie (\"SyncWindow\") ou n'a pas été reçu du tout. Causes possibles: Problèmes en temps réel : La gigue des tâches est trop élevée. La priorité des tâches du EtherCAT la tâche est trop faible. D'autres bus de terrain (par exemple, Modbus ) ou des opérations longues en plus des tâches de contrôle (par exemple, accès aux fichiers) dans le EtherCAT tâche Modbus est exécuté dans une autre tâche, mais les canaux d'E\/S qu'il utilise sont également référencés dans le EtherCAT tâche. Surtout avec les systèmes d'exploitation Linux, la configuration du système (par exemple, les priorités IRQ) Problème de communication avec le EtherCAT esclave : Connexion interrompue, problèmes de compatibilité électromagnétique (CEM), etc. Recherchez la cause du comportement. Les fonctions suivantes peuvent vous y aider : Le Page d'état de la EtherCAT Maître Analyse des temps de cycle et de gigue de la tâche EtherCAT dans le Configuration des tâches Actions possibles pour les problèmes en temps réel : Optimisez le temps réel. Pour ce faire, suivez les instructions de Optimisation des performances Augmentez le temps de cycle du EtherCAT tâche. Augmenter DCInSyncWindow de la EtherCAT Maître. Voir: IoDrvEtherCAT.DCInSyncWindow (PROP) Activer FrameAtTaskStart pour le EtherCAT Maître. Voir: IoDrvEtherCAT.FrameAtTaskStart (PROP) Si le lecteur peut gérer les problèmes de synchronisation, le contrôle de synchronisation peut être désactivé au moyen de SMC_Set_ETC_DCSyncSupervision . SMC_DI_SWLIMITS_EXCEEDED L'axe se déplace dans le sens du fin de course logiciel positif ou négatif et le dépassera avec la dynamique du courant. L'erreur se déclenche également avant la position réelle du fin de course, car la distance de freinage requise est également incluse dans le calcul. Vérifiez si le mouvement est souhaité ou non dans cette plage de positions. Si nécessaire, ajustez la position du fin de course logiciel négatif et\/ou positif. Voir Onglet : GénéralSMC_DI_HWLIMITS_EXCEEDED Le fin de course matériel positif ou négatif s'est déclenché et l'axe se déplace dans la direction de ce fin de course. Vérifiez la position commandée du mouvement. Cela ne doit pas dépasser les positions des fins de course matériels. Si le mouvement est OK, vérifiez les signaux des fins de course matériels. SMC_MOVING_WITHOUT_ACTIVE_MOVEMENT Il n'y a pas de mouvement actif, mais la vitesse réglée n'est pas égale à zéro et l'axe se trouve dans un état de fonctionnement dans lequel les valeurs réglées sont respectées. Causes possibles: Lors de l'utilisation MC_PositionProfile , MC_VelocityProfile , ou MC_AccelerationProfile , l'axe doit s'arrêter à la fin de ce mouvement ou un mouvement ultérieur doit être commandé dans le même cycle. Sinon, cette erreur est renvoyée. Vérifiez la cause du problème : Ordre d'appel incorrect pour les mouvements tamponnés et mélangés : ajustez l'ordre d'appel. Pour plus d'informations, consultez la rubrique Ordre d'exécution des blocs fonctionnels de mouvement. MC_PositionProfile , MC_VelocityProfile , ou MC_AccelerationProfile est utilisé et aucun arrêt n'est atteint à la fin : Réglez le profil en conséquence pour que l'arrêt soit atteint à la fin. Ou utilisez plutôt Cames, qui couvrent un cas d'utilisation similaire à ces blocs fonctionnels, mais sont plus flexibles et plus faciles à utiliser. " }, 
{ "title" : "Performance ", 
"url" : "_sm_diagnosis_performance.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Diagnostics \/ Performance ", 
"snippet" : "Les POU qui utilisent le AXIS_REF_SM3 bloc fonctionnel vérifie toujours s'il est appelé ou non depuis la tâche de cycle de bus. Cette vérification peut être désactivée pour les applications urgentes au moyen de la définition du compilateur SM3_DISABLE_TASK_CHECKS ....", 
"body" : "Les POU qui utilisent le AXIS_REF_SM3 bloc fonctionnel vérifie toujours s'il est appelé ou non depuis la tâche de cycle de bus. Cette vérification peut être désactivée pour les applications urgentes au moyen de la définition du compilateur SM3_DISABLE_TASK_CHECKS . " }, 
{ "title" : "Exemples ", 
"url" : "_sm_basic_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Mouvements sur un seul axe ", 
"url" : "_sm_basic_examples_single_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Mouvements sur un seul axe ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Contrôle du mouvement des axes simples ", 
"url" : "_sm_example_single_axis_motion_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Mouvements sur un seul axe \/ Contrôle du mouvement des axes simples ", 
"snippet" : "Voir le PLCopenSingle.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment piloter un entraînement à l'aide de blocs fonction standardisés PLCopen. Insérez un lecteur virtuel nommé Drive dans l'arborescence d...", 
"body" : "Voir le PLCopenSingle.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment piloter un entraînement à l'aide de blocs fonction standardisés PLCopen. Insérez un lecteur virtuel nommé Drive dans l'arborescence des appareils ci-dessous Pool d'axes généraux SoftMotion . Créer un MOTION_PRG programme à ST. PROGRAM MOTION_PRG\nVAR\n iStatus: INT;\n Power: MC_Power;\n MoveAbsolute: MC_MoveAbsolute;\n p:REAL:=100;\nEND_VAR\n\nCASE iStatus OF\n\n\/\/ initialization of the axis\n0:\n Power(Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE, Axis:=Drive);\n IF Power.Status THEN\n iStatus := iStatus + 1;\n END_IF\n\n\/\/ Move the axis to position p by use of the MC_MoveAbsolute function block\n1:\n MoveAbsolute(Execute:=TRUE, Position:= p, Velocity:=100, Acceleration:=100, Deceleration:=100, Axis:=Drive);\n IF MoveAbsolute.Done THEN\n MoveAbsolute(Execute:=FALSE, Axis:=Drive);\n iStatus := iStatus + 1;\n END_IF\n\n\/\/ Move the axis back to position 0 by use of the MC_MoveAbsolute function block:\n2:\n MoveAbsolute(Execute:=TRUE, Position:= 0, Velocity:=100, Acceleration:=100, Deceleration:=100, Axis:=Drive);\n IF MoveAbsolute.Done THEN\n MoveAbsolute(Execute:=FALSE, Axis:=Drive);\n iStatus := 1;\n END_IF Ajouter l'appel du programme MOTION_PRG à la tâche Tâche principale . Arborescence des appareils : Téléchargez le projet dans le contrôleur et démarrez-le. Ouvrez le Conduire axe virtuel dans l'éditeur. Dans le En ligne partie de la Général onglet, vous voyez le mouvement de l'axe. " }, 
{ "title" : "Contrôle du mouvement des axes simples dans CFC avec un modèle de visualisation ", 
"url" : "_sm_example_single_axis_visu_template.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Mouvements sur un seul axe \/ Contrôle du mouvement des axes simples dans CFC avec un modèle de visualisation ", 
"snippet" : "Voir le PLCopenSingle2.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . N'importe lequel des autres langages d'implémentation IEC peut également être utilisé à la place de ST, par exemple CFC ici. Ce langage illustre le mécanisme d...", 
"body" : "Voir le PLCopenSingle2.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . N'importe lequel des autres langages d'implémentation IEC peut également être utilisé à la place de ST, par exemple CFC ici. Ce langage illustre le mécanisme de démarrage et d'interruption des blocs fonction. De plus, les différents modes de démarrage du bloc fonction MC_MoveAbsolute peut être testé pour les axes rotatifs. Insérez un lecteur virtuel nommé Drive dans l'arborescence des appareils ci-dessous Pool d'axes généraux SoftMotion . Double-cliquez sur l'objet pour ouvrir son éditeur. Modifiez les paramètres en un entraînement rotatif avec une période de 360°. Type d'axe : modulo Valeur modulo [u] : 360.0 Créer un MOTION_PRG programme en CFC. Insérer les blocs fonction MC_Power , MC_MoveAbsolute , et MC_MoveVelocity . Il est généralement recommandé d'initialiser les entrées du bloc fonction. Ainsi, vous n'avez pas besoin de spécifier les valeurs encore et encore plus tard lors du démarrage de cette application de test. PROGRAM MOTION_PRG\nVAR\n mcp: MC_Power := (Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n mcmv: MC_MoveVelocity :=(Velocity:=100, Acceleration:=100, Deceleration:=100, Direction:=positive);\n mcma: MC_MoveAbsolute := (Position:=180, Velocity:=100, Acceleration:=100, Deceleration:=100, Direction:=positive);\nEND_VAR CFC : Ajouter l'appel du MOTION_PRG programme à la tâche Tâche principale . Ajouter un Visualisation s'opposer à la demande. Positionner les modèles de visualisation VISU_NEW_MC_MoveAbsolute , VISU_NEW_MC_MoveVelocity , VISU_NEW_MC_Power , et RotDrive dans l'éditeur de visualisation. Liez-les aux instances de blocs fonctionnels de MOTION_PRG . Visualisation: Générez le projet et téléchargez-le dans l'automate. Démarrez le projet. Ouvrez la visualisation dans l'éditeur. Clique le Permettre entrée (MC_Power) puis la Exécuter entrée (MC_Move_Absolute). Le lecteur tourne. Ouvrez le Conduire axe virtuel dans l'éditeur. Dans le En ligne partie de la Général onglet, vous voyez le mouvement de l'axe. Expérimentez avec les paramètres de ces blocs fonctionnels. Modifiez les paramètres et observez le comportement. " }, 
{ "title" : "Prévision des mouvements sur un seul axe ", 
"url" : "_sm_basic_example_forecast.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Mouvements sur un seul axe \/ Prévision des mouvements sur un seul axe ", 
"snippet" : "Le BasicMotion_Forecast.project L'exemple de projet se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment définir une prévision pour un axe afin d'obtenir des informations sur l'état de l'axe dans le futur. Dans l'exemple, un mouvemen...", 
"body" : "Le BasicMotion_Forecast.project L'exemple de projet se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment définir une prévision pour un axe afin d'obtenir des informations sur l'état de l'axe dans le futur. Dans l'exemple, un mouvement absolu est exécuté sur un axe jusqu'à la position 10. En définissant une prévision de 300 ms sur l'axe, vous pouvez savoir à l'avance dans l'application quand et avec quelle dynamique l'axe passera par la position 8. Pour plus d'informations sur les prévisions pour les axes, voir : Prévision" }, 
{ "title" : "Structure de la candidature ", 
"url" : "_sm_basic_example_forecast.html#UUID-0813b57c-b654-1961-50ef-d370b88506f6_section-idm43442768266588", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Mouvements sur un seul axe \/ Prévision des mouvements sur un seul axe \/ Structure de la candidature ", 
"snippet" : "La candidature se compose d'un PLC_PRG programme et un Trace . PLC_PRG L'axe virtuel est activé dans le STATE_POWER_DRIVE État. Puis le SMC_SetForecast Le bloc fonction permet de définir une prévision de 300 ms pour l'axe dans le STATE_SET_FORECAST État. Le SMC_GetForecast Le bloc fonctionnel peut ê...", 
"body" : "La candidature se compose d'un PLC_PRG programme et un Trace . PLC_PRG L'axe virtuel est activé dans le STATE_POWER_DRIVE État. Puis le SMC_SetForecast Le bloc fonction permet de définir une prévision de 300 ms pour l'axe dans le STATE_SET_FORECAST État. Le SMC_GetForecast Le bloc fonctionnel peut être utilisé pour lire la prévision définie pour l’axe. Dans le STATE_MOVE_TO_POSITION état, un mouvement absolu vers la position 10 est exécuté. Le SMC_GetTravelTime Le bloc fonctionnel est également démarré. Le bloc fonction permet de lire l'heure à laquelle l'axe atteindra la position 8. Le SMC_ReadSetValues Le bloc fonction est utilisé pour déterminer la dynamique à la position 8. Un décalage temporel peut être transmis à ce bloc fonction où la dynamique de l'axe doit être lue. Dans notre cas, on passe la durée dont l'axe a besoin pour atteindre la position 8. Tracer Vous pouvez utiliser la trace pour suivre le mouvement de l'axe virtuel. La position actuelle, la vitesse et l'accélération de l'axe sont enregistrées. La durée jusqu'à la position 8 et la dynamique de l'axe à cette position sont également affichées. Notez que la durée de SMC_GetTravelTime est précisé par rapport au début du cycle. Les valeurs de consigne de l'axe correspondent à celles de fin de cycle. " }, 
{ "title" : "Mise en service ", 
"url" : "_sm_basic_example_forecast.html#UUID-0813b57c-b654-1961-50ef-d370b88506f6_section-idm43442768283734", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Mouvements sur un seul axe \/ Prévision des mouvements sur un seul axe \/ Mise en service ", 
"snippet" : "Créez l'application et téléchargez-la sur un contrôleur. Démarrez la trace et l'application. Dans la trace, vous pouvez suivre le mouvement de l'axe virtuel. Faites attention à la durée jusqu'à la position 8 et à la dynamique à la position 8....", 
"body" : "Créez l'application et téléchargez-la sur un contrôleur. Démarrez la trace et l'application. Dans la trace, vous pouvez suivre le mouvement de l'axe virtuel. Faites attention à la durée jusqu'à la position 8 et à la dynamique à la position 8. " }, 
{ "title" : "Mouvements synchrones de deux axes ", 
"url" : "_sm_basic_synch_movements_2_axis_example.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Mouvements synchrones de deux axes ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Engrenages électroniques, décalage de phase et compensation du jeu des engrenages ", 
"url" : "_sm_basic_example_synchronized_motion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Mouvements synchrones de deux axes \/ Engrenages électroniques, décalage de phase et compensation du jeu des engrenages ", 
"snippet" : "Voir le BasicMotion_SynchronizedMotion.project exemple dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment utiliser une boîte de vitesses électronique en combinaison avec un déphasage et une compensation de jeu d'engrenage....", 
"body" : "Voir le BasicMotion_SynchronizedMotion.project exemple dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment utiliser une boîte de vitesses électronique en combinaison avec un déphasage et une compensation de jeu d'engrenage. " }, 
{ "title" : "Structure de la candidature ", 
"url" : "_sm_basic_example_synchronized_motion.html#UUID-5f979be9-50d7-427c-01e2-01bc4a0e21cb_section-idm4538843986680034227085857199", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Mouvements synchrones de deux axes \/ Engrenages électroniques, décalage de phase et compensation du jeu des engrenages \/ Structure de la candidature ", 
"snippet" : "L'application consiste en une simple machine à états dans le PLC_PRG programme et une trace que vous pouvez utiliser pour suivre facilement la fonctionnalité des blocs fonctionnels. Activer les axes avec MC_Power . (STATE_POWER ) Démarrez les mouvements synchrones et déplacez l'axe maître en continu...", 
"body" : "L'application consiste en une simple machine à états dans le PLC_PRG programme et une trace que vous pouvez utiliser pour suivre facilement la fonctionnalité des blocs fonctionnels. Activer les axes avec MC_Power . (STATE_POWER ) Démarrez les mouvements synchrones et déplacez l'axe maître en continu entre la position 0 et la position 100 ( STATE_COMMAND_POS_0 et STATE_COMMAND_POS_1 ). " }, 
{ "title" : "Usage ", 
"url" : "_sm_basic_example_synchronized_motion.html#UUID-5f979be9-50d7-427c-01e2-01bc4a0e21cb_section-idm4561564117984034227086974585", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Mouvements synchrones de deux axes \/ Engrenages électroniques, décalage de phase et compensation du jeu des engrenages \/ Usage ", 
"snippet" : "L'axe maître (noir dans le diagramme de trace) se déplace continuellement d'avant en arrière entre la position 0 et la position 100 à une vitesse maximale de 50 unités par seconde. Une boîte de vitesses électronique ( MC_GearIn ) avec un rapport de transmission de 2:3 convertit le mouvement maître e...", 
"body" : "L'axe maître (noir dans le diagramme de trace) se déplace continuellement d'avant en arrière entre la position 0 et la position 100 à une vitesse maximale de 50 unités par seconde. Une boîte de vitesses électronique ( MC_GearIn ) avec un rapport de transmission de 2:3 convertit le mouvement maître en Slave0 axe (vert dans le diagramme de trace). La vitesse maximale résultant des engrenages est de 75 unités par seconde. Ensuite, un déphasage ( MC_Phasing ) de 30 unités est appliqué au Slave1 axe (orange dans le diagramme de trace). La vitesse est identique à la Slave0 axe, à l’exception de la phase de rampe. Enfin, la compensation du jeu des engrenages est utilisée pour amener le mouvement au Drive axe (bleu dans le diagramme de trace). Une valeur irréaliste de 5 unités est fixée pour le jeu des engrenages à des fins de démonstration. Le schéma montre un mouvement compensateur au début du mouvement et à chaque inversion du sens du mouvement. " }, 
{ "title" : "GearInPos (scie volante) ", 
"url" : "_sm_basic_example_gearinpos.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Mouvements synchrones de deux axes \/ GearInPos (scie volante) ", 
"snippet" : "Voir le BasicMotion_GearInPos.project exemple dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment utiliser MC_GearInPos mettre en œuvre une scie volante. Pour ce projet, nous vous recommandons d'installer CODESYS Depictor , qui peut afficher ...", 
"body" : "Voir le BasicMotion_GearInPos.project exemple dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment utiliser MC_GearInPos mettre en œuvre une scie volante. Pour ce projet, nous vous recommandons d'installer CODESYS Depictor , qui peut afficher l'application sous forme d'animation 3D. (La version gratuite sans licence suffit pour ce faire.) " }, 
{ "title" : "Structure de la candidature ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm4565133330038434227193133829", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Mouvements synchrones de deux axes \/ GearInPos (scie volante) \/ Structure de la candidature ", 
"snippet" : "L'application consiste en une machine à états dans le PLC_PRG programme, une représentation 3D (Scène, DepictorCalculation programme), une simple simulation de pièce ( SimulateWorkpiece programme), et une trace que vous pouvez utiliser pour comprendre facilement l'effet des blocs fonctionnels. Le dé...", 
"body" : "L'application consiste en une machine à états dans le PLC_PRG programme, une représentation 3D (Scène, DepictorCalculation programme), une simple simulation de pièce ( SimulateWorkpiece programme), et une trace que vous pouvez utiliser pour comprendre facilement l'effet des blocs fonctionnels. Le déroulement dans PLC_PRG est le suivant : Activer les axes avec MC_Power . ( STATE_POWER ) Attendez que la barrière lumineuse détecte une pièce à usiner. ( STATE_WAIT_FOR_WORKPIECE ) Dès que la barrière lumineuse détecte une pièce, l'esclave qui transporte la scie parallèlement au tapis transporteur est synchronisé avec la pièce sur le tapis transporteur (contrôlé par le Master axe). ( STATE_WAIT_FOR_SYNC ) Lorsque la synchronisation est atteinte, la scie est déplacée d'avant en arrière une fois perpendiculairement à la pièce. ( STATE_MOVE_TOOL_0\/1 ) Déplacez l'esclave en position de repos et recommencez le processus à 2. ( STATE_MOVE_TO_REST ) " }, 
{ "title" : "Systèmes de coordonnées et dimensions ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm4627667581768034227193767932", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Mouvements synchrones de deux axes \/ GearInPos (scie volante) \/ Systèmes de coordonnées et dimensions ", 
"snippet" : "L'origine du système de coordonnées se trouve au centre de la bande transporteuse, l'axe Z pointe vers le haut et l'axe X pointe dans la direction de mouvement de la bande transporteuse. Depuis le tapis roulant, l'axe Y pointe à l'opposé de la scie. Les dimensions de la bande transporteuse et de la ...", 
"body" : "L'origine du système de coordonnées se trouve au centre de la bande transporteuse, l'axe Z pointe vers le haut et l'axe X pointe dans la direction de mouvement de la bande transporteuse. Depuis le tapis roulant, l'axe Y pointe à l'opposé de la scie. Les dimensions de la bande transporteuse et de la pièce à usiner, la position de la barrière lumineuse et la position dans laquelle la scie fonctionne de manière synchrone avec la pièce à usiner sont stockées sous forme de constantes dans le GVL Const . " }, 
{ "title" : "Usage ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm458752582335683422719410462", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Mouvements synchrones de deux axes \/ GearInPos (scie volante) \/ Usage ", 
"snippet" : "Démarrez l'application. Dans le Scène Objet Représentateur et dans la trace, vous pouvez voir comment s'effectue la synchronisation entre le maître (pièce à usiner sur le tapis roulant) et l'esclave (scie)....", 
"body" : "Démarrez l'application. Dans le Scène Objet Représentateur et dans la trace, vous pouvez voir comment s'effectue la synchronisation entre le maître (pièce à usiner sur le tapis roulant) et l'esclave (scie). " }, 
{ "title" : "Cames ", 
"url" : "_sm_basic_examples_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Cames ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Caméras alternées ", 
"url" : "_sm_example_changing_cams.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Cames \/ Caméras alternées ", 
"snippet" : "Voir le PLCopenMultiCAM.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment créer un mouvement de came avec deux cames alternées. Le programme est implémenté dans ST et exécute les mêmes actions que l'exempl...", 
"body" : "Voir le PLCopenMultiCAM.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment créer un mouvement de came avec deux cames alternées. Le programme est implémenté dans ST et exécute les mêmes actions que l'exemple \"Cam Drive Control using a Virtual Time Axis\". A la fin de la première came, le MC_CamIn le bloc fonction définit le EndOfProfile sortir. De cette façon, l'autre table de courbes est affectée à MC_CamTableSelect et MC_CamIn est redémarré. " }, 
{ "title" : "Contrôle d'un entraînement à cames avec un axe de temps virtuel ", 
"url" : "_sm_example_drive_control_virtual_time_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Cames \/ Contrôle d'un entraînement à cames avec un axe de temps virtuel ", 
"snippet" : "Voir le PLCopenMulti.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment implémenter une came périodique sur un entraînement linéaire. L'exemple montre également comment utiliser la fonction tappet. Insérer ...", 
"body" : "Voir le PLCopenMulti.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment implémenter une came périodique sur un entraînement linéaire. L'exemple montre également comment utiliser la fonction tappet. Insérer une came nommée Example dans l'arborescence des appareils ci-dessous Application . Ouvrez la came dans l'éditeur. Définir un poussoir sur le Poussoir languette. X : 8.0 Passe positive : Invert Passe négative : Invert Insérez un lecteur virtuel nommé Drive dans l'arborescence des appareils ci-dessous Pool d'axes généraux SoftMotion . Pour cet axe, sélectionnez le type d'axe Modulo avec une valeur modulo de 360 . Insérez un autre lecteur virtuel nommé Virtual . Pour cet axe, sélectionnez le Modulo type d'axe avec une valeur modulo de 10 . Créer un MOTION_PRG programme en CFC. PROGRAM MOTION_PRG\nVAR\n power1, power2: MC_Power;\n TableSelect: MC_CamTableSelect;\n CamIn: MC_CamIn;\n Tappet: SMC_GetTappetValue;\n MoveVirtual: MC_MoveVelocity;\nEND_VAR Insérer un élément de boîte et affecter la variable power1 à cela. L'élément de boîtier est utilisé pour allumer le Drive . Configurez les entrées comme suit : Axe : Drive Permettre : TRUE bRégulateurOn : TRUE bDriveDémarrer TRUE Insérer un élément de boîte et affecter la variable power2 à cela. L'élément de boîtier est utilisé pour allumer le Virtual conduire. Configurez les entrées comme suit : Axe : Virtual Permettre : TRUE bRégulateurOn : TRUE bDriveDémarrer TRUE Insérer un élément de boîte et affecter la variable MoveVirtual à cela. L'élément box est utilisé pour déplacer le maître virtuel. Configurez les entrées comme suit : Axe : Virtual Exécuter : power2.Status Rapidité : 2 Accélération 10 Ralentissement 10 Direction positive Insérer un élément de boîte et affecter la variable TableSelect à cela. L'élément boîte est utilisé pour sélectionner une came. Configurez les entrées comme suit : Maître : Virtual Trimer : Drive CamTable : Example Exécuter TRUE Périodique TRUE MaîtreAbsolu TRUE EsclaveAbsolu TRUE Insérer un élément de boîte et affecter la variable CamIn à cela. L'élément boîte implémente la plaque à cames sélectionnée. Configurez les entrées comme suit : Maître : Virtual Trimer : Drive Exécuter power1.Status Décalage maître : 0 Décalage esclave : 0 MasterScaling : 1 EsclaveMise à l'échelle : 1 StartMode : absolute IDTableCam : TableSelect.CamTableID VitesseDiff : 1 Accélération : 1 Ralentissement : 1 PoussoirHystérésis : 1 Insérer un élément de boîte et affecter la variable Tappet à cela. L'élément de boîtier vérifie le réglage du commutateur à came. Configurez les entrées comme suit : Poussoirs : CamIn.Tappets iID : 1 bInitValue FALSE bSetInitValueAtReset : FALSE Le poussoir est défini comme un poussoir inverseur. Pour cette raison, sa valeur est modifiée toutes les 10 secondes. L'exemple de projet fournit une visualisation pour contrôler les différents blocs fonctionnels et la position des axes. Ajouter l'appel du MOTION_PRG programme à la tâche Tâche principale . Téléchargez le projet dans le contrôleur et démarrez-le. Pour plus d'informations, consultez : MC_Puissance MC_CamTableSelect MC_CamIn SMC_GetTappetValue MC_MoveVelocity " }, 
{ "title" : "Créer des cames par programme ", 
"url" : "_sm_basic_example_cam_programmatic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Cames \/ Créer des cames par programme ", 
"snippet" : "Le BasicMotion_CreateCamTableOnline.project L'exemple de projet se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . L'exemple montre comment utiliser le code IEC pour créer et utiliser une caméra. Les points suivants sont abordés ici : Une caméra créée dans l...", 
"body" : "Le BasicMotion_CreateCamTableOnline.project L'exemple de projet se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . L'exemple montre comment utiliser le code IEC pour créer et utiliser une caméra. Les points suivants sont abordés ici : Une caméra créée dans l'éditeur de caméras est créée à nouveau à l'aide du code IEC. Dans un cas, le disque à cames est généré dans la tâche du bus. Dans l'autre cas, le disque à cames est généré dans le cadre d'une tâche distincte. Ensuite, les trois cames fonctionnent avec le même axe principal et des axes esclaves différents. Le mouvement des trois esclaves est identique. La caméra générée dans le code IEC est affichée dans la visualisation. Pour plus d'informations sur la création programmatique de cames, voir : Créer des cames par programme" }, 
{ "title" : "Structure de la candidature ", 
"url" : "_sm_basic_example_cam_programmatic.html#UUID-ea402455-f321-1e3f-0d8c-522b4772732e_section-idm4538843986680034227085857199", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Cames \/ Créer des cames par programme \/ Structure de la candidature ", 
"snippet" : "L'application comprend les éléments suivants : CamOffline La caméra créée dans l'éditeur de caméras qui doit être créée à nouveau à l'aide du code IEC. PLC_PRG Le programme se compose d'une simple machine à états et, logiquement, de trois parties. Dans les première et deuxième parties, une came est ...", 
"body" : "L'application comprend les éléments suivants : CamOffline La caméra créée dans l'éditeur de caméras qui doit être créée à nouveau à l'aide du code IEC. PLC_PRG Le programme se compose d'une simple machine à états et, logiquement, de trois parties. Dans les première et deuxième parties, une came est créée en code IEC. Dans la troisième partie, les caméras créées précédemment et une caméra identique créée hors ligne sont exécutées. Partie 1: Dans le premier état STATE_CREATE_ONLINE_TABLE , une came est créée en code CEI. Le SMCB.CamBuilder bloc fonctionnel du SM3_CamBuilder la bibliothèque est utilisée à cet effet. Trois segments sont ajoutés : un élément Poly5 suivi d'un élément Line et d'un autre élément Poly5. Le Constructeur génère un CamOnline came de ça. A partir de ce moment, la came est créée en code CEI et peut être utilisée de la même manière que la CamHors ligne caméra créée hors ligne dans l'éditeur de caméras. Partie 2: Dans le STATE_INIT_ONLINE_TABLE_MULTITASK , STATE_START_CREATE_ONLINE_TABLE_MULTITASK , et STATE_READ_ONLINE_TABLE_MULTITASK états, la création de la caméra est lancée dans une autre tâche puis elle est lue. Troisième partie : Dans le STATE_POWER_DRIVES état, les axes virtuels pour le maître et les trois axes esclaves sont initialisés. Les cames sont ensuite sélectionnées à l'aide de MC_CamTableSelect dans le STATE_SELECT_TABLE état et exécuté en finale STATE_MOVEMENT état. L'axe principal est déplacé à l'aide de MC_MoveVelocity et est utilisé comme maître pour les trois cames. MultitaskCamBuilder Un programme qui génère une caméra comme décrit dans la partie 1 de PLC_PRG . La seule différence ici est qu'une variante multitâche\/multicore sécurisée de la caméra GVL La variante multitâche\/multicore-safe de la caméra est instanciée ici. Visualization La visualisation contient les SMC_Visu_CamDisplayer élément pour afficher les caméras. La caméra générée dans la partie 1 de PLC_PRG s'affiche. CamDisplayerSettings Éléments supplémentaires pour l'affichage de la caméra Visualization Trace Vous pouvez utiliser la trace pour suivre le mouvement des axes virtuels. La position actuelle du maître est enregistrée, ainsi que la position, la vitesse et l'accélération des trois axes esclaves. " }, 
{ "title" : "Mise en service ", 
"url" : "_sm_basic_example_cam_programmatic.html#UUID-ea402455-f321-1e3f-0d8c-522b4772732e_section-idm4561564117984034227086974585", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Cames \/ Créer des cames par programme \/ Mise en service ", 
"snippet" : "Créez l'application et téléchargez-la sur un contrôleur. Démarrez la trace et l'application. Observez la trace d’échantillonnage. Affichage de la caméra générée dans la visualisation...", 
"body" : "Créez l'application et téléchargez-la sur un contrôleur. Démarrez la trace et l'application. Observez la trace d’échantillonnage. Affichage de la caméra générée dans la visualisation " }, 
{ "title" : "Utilisation de MC_DigitalCamSwitch_HighPrecision ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Cames \/ Utilisation de MC_DigitalCamSwitch_HighPrecision ", 
"snippet" : "L'exemple BasicMotion_DigitalCamSwitch_HighPrecision.project se trouve dans le répertoire d'installation CODESYS sous ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment utiliser les sorties de SMC_DigitalCamSwitch_HighPrecision pour contrôler les sorties numériques avec une résolution tempo...", 
"body" : "L'exemple BasicMotion_DigitalCamSwitch_HighPrecision.project se trouve dans le répertoire d'installation CODESYS sous ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment utiliser les sorties de SMC_DigitalCamSwitch_HighPrecision pour contrôler les sorties numériques avec une résolution temporelle élevée. Les terminaux EL2258 et EL2252 de Beckhoff sont utilisés à titre d' Les descriptions des appareils fournies par Beckhoff ne sont pas incluses dans l'exemple. Vous pouvez les télécharger directement auprès du fournisseur et les installer dans le référentiel des appareils. Pour exécuter cet exemple, vous avez besoin d'un coupleur de bus EK1100, d'une borne EL2258 et d'une borne EL2252 Cet exemple a été développé et testé conformément à la révision 0017 de l'EL2258 et à la révision 0020 de l'EL2252. Cela ne sert qu'à titre d'exemple. Nous n'en garantissons pas l'exactitude. Le code source doit être testé avant utilisation. Si nécessaire, il doit être modifié pour d'autres révisions des terminaux. " }, 
{ "title" : "Structure de la demande ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856510750361", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Cames \/ Utilisation de MC_DigitalCamSwitch_HighPrecision \/ Structure de la demande ", 
"snippet" : "L'application se compose d'un Main programme, le DigitalCamSwitch_EL2258 et DigitalCamSwitch_EL2252 des blocs fonctionnels et un coupleur de bus EK1100 avec les bornes de sortie EL2258 et EL2252. Le DigitalCamSwitch_EL2258 et DigitalCamSwitch_EL2252 les blocs fonctionnels sont les éléments essentiel...", 
"body" : "L'application se compose d'un Main programme, le DigitalCamSwitch_EL2258 et DigitalCamSwitch_EL2252 des blocs fonctionnels et un coupleur de bus EK1100 avec les bornes de sortie EL2258 et EL2252. Le DigitalCamSwitch_EL2258 et DigitalCamSwitch_EL2252 les blocs fonctionnels sont les éléments essentiels de l'exemple. Ils montrent comment utiliser Events sortie de SMC_DigitalCamSwitch_HighPrecision pour programmer des sorties numériques. Les blocs fonctionnels doivent être compris comme des exemples qui peuvent être adaptés à d'autres matériels. " }, 
{ "title" : "DigitalCamSwitch_EL2258 ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856513787236", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Cames \/ Utilisation de MC_DigitalCamSwitch_HighPrecision \/ Structure de la demande \/ DigitalCamSwitch_EL2258 ", 
"snippet" : "Le bloc fonctionnel fonctionne comme suit : Le bloc de fonction est initialisé sur un front montant au Enable entrée. Dans le STATE_INIT_0 et STATE_INIT_1 états, les OutputBufferReset les signaux du terminal EL2258 sont écrits et aLastEventIds tableau est initialisé. L'ID du dernier événement traité...", 
"body" : "Le bloc fonctionnel fonctionne comme suit : Le bloc de fonction est initialisé sur un front montant au Enable entrée. Dans le STATE_INIT_0 et STATE_INIT_1 états, les OutputBufferReset les signaux du terminal EL2258 sont écrits et aLastEventIds tableau est initialisé. L'ID du dernier événement traité pour chaque piste est enregistré dans ce tableau. Cela permet d'éviter qu'un événement soit transféré plusieurs fois au terminal. Une fois initialisé ( STATE_ACTIVE ), toutes les pistes sont traitées à tour de rôle et la logique suivante est exécutée pour chaque piste : Vérifiez si le terminal EL2258 a déjà accepté les derniers événements commandés ( ChannelsIn[channel].OutputOrderFeedback = ChannelsOut[channel].OutputOrderCounter ). Parcourez tous les événements de la piste. Seuls les événements dont ToggleEventId est supérieur au dernier identifiant traité sont pris en compte ultérieurement. (Requête EventId_GreaterThan(event^.ToggleEventId, aLastEventIds[channel]) ) Voir la section : « Remarque sur l'ordre des événements ». Convertissez le Duration de l'événement dans un horodatage EtherCAT et écriture correspondante du ChannelsOut[channel].OutputEventState et ChannelsOut[channel].OutputEventTime sorties. Interrompez le traitement après un maximum de 5 événements. Avertissez le terminal de l'existence de nouveaux événements si au moins un événement a été détecté ( ChannelsOut[channel].OutputOrderCounter := ChannelsOut[channel].OutputOrderCounter + 1 ). Remarque sur l'ordre des événements Les événements sont renvoyés par SMC_DigitalCamSwitch_HighPrecision bloc fonctionnel pour chaque piste d'un tableau. SwitchNumber et un ToggleEventId sont remboursés pour chaque événement. ToggleEventId est unique et ascendante pour chaque piste. Pour plus d'informations, voir : ÉVÉNEMENT SMC_CAMSWITCH_TOGGLE_EVENT . Dans l'exemple, aLastEventIds[trackNo] le tableau stocke pour chaque piste qui ToggleEventId a été transféré pour la dernière fois au terminal lors d'un appel de bloc fonctionnel précédent. Parce que le ToggleEventIds sont classés par ordre croissant, le prochain appel saura exactement quels événements doivent encore être transférés. Deux détails doivent encore être pris en compte : Parce que l'on ne sait pas à quel moment ToggleEventId les événements commencent, un valid le drapeau est enregistré dans EventId type de données en plus de l'ID. Pour le EventId_GreaterThan comparaison, cette valid le drapeau est pris en compte en conséquence. Le ToggleEventIds avoir le type de données 32 bits UDINT et peuvent donc, en principe, déborder avec une durée de fonctionnement respectivement longue ou une fréquence de commutation élevée. La valeur passe ensuite de 2^32-1 à 0. La fonction de comparaison EventId_GreaterThan prend également en compte les dépassements de 32 bits. Cartographie PDO EL2258 Le ChannelsOut et ChannelsIn sorties du DigitalCamSwitch_EL2258 les blocs fonctionnels sont connectés aux canaux d'E\/S respectifs de la borne EL2258. L'image suivante montre les mappages pour le canal 1. Le canal 2 est similaire ; uniquement lors de l'accès ChannelsOut et ChannelsIn l'indice est 2 et non 1. " }, 
{ "title" : "DigitalCamSwitch_EL2252 ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234861434780928", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Cames \/ Utilisation de MC_DigitalCamSwitch_HighPrecision \/ Structure de la demande \/ DigitalCamSwitch_EL2252 ", 
"snippet" : "Le principe de base est identique à DigitalCamSwitch_EL2258 . La différence réside dans la façon dont les signaux sont écrits, car le terminal EL2252 ne peut programmer qu'un seul événement actif Tout d'abord, le bloc fonctionnel est initialisé dans STATE_INIT . Puis STATE_CHECK_FOR_EVENT vérifie si...", 
"body" : "Le principe de base est identique à DigitalCamSwitch_EL2258 . La différence réside dans la façon dont les signaux sont écrits, car le terminal EL2252 ne peut programmer qu'un seul événement actif Tout d'abord, le bloc fonctionnel est initialisé dans STATE_INIT . Puis STATE_CHECK_FOR_EVENT vérifie si les événements provenant du SMC_DigitalCamSwitch_HighPrecision le bloc de fonction est en attente. Si un événement est disponible, il doit être programmé en deux cycles : Les sorties et l'horodatage EtherCAT sont écrits au cours du premier cycle. Activate la sortie est réglée sur 0. Au cours du deuxième cycle, Activate la sortie est réglée sur 3 STATE_ACTIVATE_EVENT_IN_EL2252 . Cela active l'événement dans le terminal. Dans STATE_WAIT_UNTIL_THE_INPUTS_MATCH_THE_OUTPUTS , le système attend ensuite que l'événement soit exécuté. Les signaux provenant du Feedback les entrées du terminal sont utilisées pour cela. Cartographie PDO EL2252 " }, 
{ "title" : "Main ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234861434889277", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Cames \/ Utilisation de MC_DigitalCamSwitch_HighPrecision \/ Structure de la demande \/ Main ", 
"snippet" : "Dans le programme principal, quatre commutateurs sont configurés (deux sur chaque piste). Les pistes ont également différentes compensations activées\/désactivées OnComp , OffComp ) : Le programme inclut les appels de blocs fonctionnels nécessaires pour activer une prévision pour l'axe et le déplacer...", 
"body" : "Dans le programme principal, quatre commutateurs sont configurés (deux sur chaque piste). Les pistes ont également différentes compensations activées\/désactivées OnComp , OffComp ) : Le programme inclut les appels de blocs fonctionnels nécessaires pour activer une prévision pour l'axe et le déplacer constamment à 180°\/s (*), ainsi que pour SMC_DigitalCamSwitch_HighPrecision , DigitalCamSwitch_EL2258 , et DigitalCamSwitch_EL2252 . Avant de démarrer le mouvement, le bus de terrain doit être complètement mis sous tension. Dans le cas contraire, les événements ne peuvent pas être transmis au terminal. (*) Le mouvement constant a été choisi pour que l'exemple reste simple et clair. Cependant, le SMC_DigitalCamSwitch_HighPrecision bloc fonctionnel fonctionne avec tous les types de mouvements. Par exemple, il fournit également des horodatages exacts lors d'une phase d'accélération ou avec " }, 
{ "title" : "Mise en service ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856511865803", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Cames \/ Utilisation de MC_DigitalCamSwitch_HighPrecision \/ Mise en service ", 
"snippet" : "Créez l'application et téléchargez-la sur une manette. Démarrez l'application....", 
"body" : "Créez l'application et téléchargez-la sur une manette. Démarrez l'application. " }, 
{ "title" : "Exportation et importation de caméras ", 
"url" : "_sm_example_cams_export_import.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Cames \/ Exportation et importation de caméras ", 
"snippet" : "Le BasicMotion_CamExportAndImport.project un exemple de projet se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . L'exemple montre comment exporter et importer une caméra....", 
"body" : "Le BasicMotion_CamExportAndImport.project un exemple de projet se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . L'exemple montre comment exporter et importer une caméra. " }, 
{ "title" : "Structure de la demande ", 
"url" : "_sm_example_cams_export_import.html#UUID-a44eacc8-df29-93b8-408e-06aec7d8a9f5_section-idm235085906313629", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Cames \/ Exportation et importation de caméras \/ Structure de la demande ", 
"snippet" : "L'application comprend PLC_PRG programme et CamEditor cam. PLC_PRG Le programme consiste en une simple machine à états dans laquelle une came est créée en code IEC dans STATE_CREATE_CAM état. Pour plus d'informations, consultez les rubriques suivantes : Créer des cames par programme. Ensuite, cette ...", 
"body" : "L'application comprend PLC_PRG programme et CamEditor cam. PLC_PRG Le programme consiste en une simple machine à états dans laquelle une came est créée en code IEC dans STATE_CREATE_CAM état. Pour plus d'informations, consultez les rubriques suivantes : Créer des cames par programme. Ensuite, cette caméra est exportée dans STATE_EXPORT_CAM état à l'aide du SMC_WriteCam bloc de fonction, puis importé dans le STATE_START_IMPORT_CAM état à l'aide du Caméra SMC_Read bloc fonctionnel. CamEditor La caméra n'a aucune signification au début car elle n'est pas utilisée dans l'application. L'exportation provenait de PLC_PRG peuvent être importés dans l'éditeur de caméras. Il s'agit d'une étape manuelle qui est décrite dans la section suivante. " }, 
{ "title" : "Mise en service ", 
"url" : "_sm_example_cams_export_import.html#UUID-a44eacc8-df29-93b8-408e-06aec7d8a9f5_section-idm23508590648994", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Cames \/ Exportation et importation de caméras \/ Mise en service ", 
"snippet" : "Créez l'application et téléchargez-la sur une manette. Démarrez l'application. Le PLC_PRG le programme génère la caméra et l'exporte vers le PlcLogic répertoire du contrôleur. Vous pouvez également afficher et modifier la caméra exportée dans l'éditeur de caméra. Pour ce faire, ouvrez CamEditor camé...", 
"body" : "Créez l'application et téléchargez-la sur une manette. Démarrez l'application. Le PLC_PRG le programme génère la caméra et l'exporte vers le PlcLogic répertoire du contrôleur. Vous pouvez également afficher et modifier la caméra exportée dans l'éditeur de caméra. Pour ce faire, ouvrez CamEditor caméra et importez la caméra à l'aide du Lire le fichier en ligne de la caméra commande. Après avoir apporté des modifications, vous pouvez exporter la caméra modifiée à l'aide du Écrire le fichier en ligne de la caméra commande. Cette caméra peut être lue dans le code IEC à l'aide du SMC_ReadCAM bloc fonctionnel et utilisé dans l'application. " }, 
{ "title" : "Annulation de la vitesse pour les axes SoftMotion ", 
"url" : "_sm_example_override.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Annulation de la vitesse pour les axes SoftMotion ", 
"snippet" : "Le BasicMotion_Override.project L'exemple de projet décrit ici se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment définir une correction de vitesse pour un axe SoftMotion. Pour plus d’informations sur le remplacement, consultez : A...", 
"body" : "Le BasicMotion_Override.project L'exemple de projet décrit ici se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment définir une correction de vitesse pour un axe SoftMotion. Pour plus d’informations sur le remplacement, consultez : Adaptation dynamique avec MC_SetOverride" }, 
{ "title" : "Structure de la candidature ", 
"url" : "_sm_example_override.html#UUID-ba001b0a-d3fc-8a58-4f4f-ec6aee022bd0_section-idm4552520462032034028650702932", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Annulation de la vitesse pour les axes SoftMotion \/ Structure de la candidature ", 
"snippet" : "La candidature se compose d'un PLC_PRG programme et un Trace . PLC_PRG Le programme consiste en une simple machine à états. Dans le premier état STATE_POWER , l'axe virtuel Drive est initialisé. Dans le deuxième état STATE_COMMAND_MOVEMENT , une correction de vitesse de 0,5 est réglée pour que les m...", 
"body" : "La candidature se compose d'un PLC_PRG programme et un Trace . PLC_PRG Le programme consiste en une simple machine à états. Dans le premier état STATE_POWER , l'axe virtuel Drive est initialisé. Dans le deuxième état STATE_COMMAND_MOVEMENT , une correction de vitesse de 0,5 est réglée pour que les mouvements de l'axe soient exécutés uniquement à moitié vitesse. Un mouvement est ensuite exécuté en utilisant MC_MoveAbsolute en position 10. Une vitesse maximale de 20 unités\/s est spécifiée dans le bloc fonctionnel. Grâce à la correction de vitesse réglée dans l'axe virtuel, le mouvement est exécuté à une vitesse maximale de 10 unités\/s. Dès que la moitié du mouvement est terminée en position 5, la correction de vitesse est réduite à 0,25 dans la position 5. STATE_CHANGE_OVERRIDE État. L'axe décélère à 5 unités\/s et effectue le reste du mouvement à cette vitesse. Les facteurs de correction actifs (vitesse, accélération et à-coup) de l'axe virtuel sont également lus dans le programme. Le SMC_GetOverride Le bloc fonctionnel est utilisé à cet effet. Tracer La trace peut être utilisée pour suivre le mouvement de l'axe virtuel. La position actuellement spécifiée, la vitesse et l'accélération de l'axe ainsi que la correction de vitesse active sont enregistrées. " }, 
{ "title" : "Mise en service ", 
"url" : "_sm_example_override.html#UUID-ba001b0a-d3fc-8a58-4f4f-ec6aee022bd0_section-idm4563439233780834028650966211", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Annulation de la vitesse pour les axes SoftMotion \/ Mise en service ", 
"snippet" : "Créez l'application et téléchargez-la sur un contrôleur. Démarrez la trace et l'application. Dans la trace, vous pouvez suivre le mouvement de l'axe virtuel....", 
"body" : "Créez l'application et téléchargez-la sur un contrôleur. Démarrez la trace et l'application. Dans la trace, vous pouvez suivre le mouvement de l'axe virtuel. " }, 
{ "title" : "Rampe basée sur la distance ", 
"url" : "_sm_axis_based_ramp_in.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Rampe basée sur la distance ", 
"snippet" : "Le BasicMotion_CamIn_StartModes.project L'exemple de projet décrit ici se trouve dans le répertoire d'installation de CODESYS sous le ..\\CODESYS SoftMotion\\Examples annuaire. Cet exemple montre comment utiliser le StartMode entrée du MC_CamIn bloc fonctionnel. Cette entrée est utilisée pour configur...", 
"body" : "Le BasicMotion_CamIn_StartModes.project L'exemple de projet décrit ici se trouve dans le répertoire d'installation de CODESYS sous le ..\\CODESYS SoftMotion\\Examples annuaire. Cet exemple montre comment utiliser le StartMode entrée du MC_CamIn bloc fonctionnel. Cette entrée est utilisée pour configurer la façon dont l'axe esclave est synchronisé avec l'axe maître lorsque MC_CamIn a démarré. En gros, il y a trois manières possibles : L'axe esclave suit immédiatement la trajectoire spécifiée par la came et l'axe maître. En fonction de l'état de démarrage de l'axe esclave, cela peut entraîner un saut de position, de vitesse et\/ou d'accélération de l'axe esclave. StartMode : absolute , relative L'axe esclave se synchronise le plus rapidement possible tout en conservant les limites prédéfinies de vitesse, d'accélération, de décélération et d'à-coup. StartMode : ramp_in , ramp_in_pos , ramp_in_neg Une position maître est spécifiée dans la came où l'axe esclave doit suivre la trajectoire spécifiée par la came et l'axe maître. La synchronisation s'effectue sur une distance configurable par rapport à l'axe maître. StartMode : ramp_in_dist Pour plus d'informations sur le bloc fonction MC_CamIn, voir : MC_CamIn (FB) " }, 
{ "title" : "Structure de la candidature ", 
"url" : "_sm_axis_based_ramp_in.html#UUID-08122319-fcc2-39b9-d37e-80454ce1f88b_section-idm4561064201451234280796827706", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Rampe basée sur la distance \/ Structure de la candidature ", 
"snippet" : "La candidature se compose d'un PLC_PRG programme et un Trace. De plus, il existe quatre axes virtuels : l'axe maître Master et les trois axes esclaves SlaveAbsolute , SlaveRampIn , et SlaveRampInDist . Et il y a la cam Cam . Dans le PLC_PRG programme, trois instances de MC_CamIn sont exécutés avec l...", 
"body" : "La candidature se compose d'un PLC_PRG programme et un Trace. De plus, il existe quatre axes virtuels : l'axe maître Master et les trois axes esclaves SlaveAbsolute , SlaveRampIn , et SlaveRampInDist . Et il y a la cam Cam . Dans le PLC_PRG programme, trois instances de MC_CamIn sont exécutés avec le StartMode input définir différemment : ciSlaveAbsolute avec StartMode = absolute ciSlaveRampIn avec StartMode = ramp_in ciSlaveRampInDist avec StartMode = ramp_in_dist Les instances de bloc fonction contrôlent les axes virtuels correspondants SlaveAbsolute , SlaveRampIn , et SlaveRampInDist . L'axe maître est déplacé à une vitesse constante à l'aide d'un MC_MoveVelocity exemple. Les trajectoires des trois axes esclaves et du Active et InSync sorties du MC_CamIn les instances peuvent être suivies dans la trace. Tous MC_CamIn les instances sont démarrées lorsque l'axe maître dépasse la position 40 : Le SlaveAbsolute l'axe passe immédiatement aux valeurs de consigne définies à partir de la came. Le correspondant MC_CamIn l'instance est immédiatement Active et InSync . Le SlaveRampIn l'axe se synchronise tout en maintenant les limites dynamiques commandées. Le correspondant MC_CamIn l'instance est immédiatement Active . Depuis la position de maître ~114 , l'axe esclave suit la trajectoire spécifiée par la came et l'axe maître et le MC_CamIn rapports d'instance InSync . Le SlaveRampInDist L'axe reste d'abord stationnaire jusqu'à ce que l'axe maître se soit approché du MasterSyncPosition de 120 jusqu'au MasterStartDistance de 60 configurés sur le MC_CamIn instance . Ensuite, la synchronisation commence et le MC_CamIn rapports d'instance Active . Lorsque l'axe maître atteint le MasterSyncPosition de 120 , l'axe esclave suit la trajectoire spécifiée par la came et l'axe maître et le MC_CamIn rapports d'instance InSync . " }, 
{ "title" : "Mise en service ", 
"url" : "_sm_axis_based_ramp_in.html#UUID-08122319-fcc2-39b9-d37e-80454ce1f88b_section-idm4602846053456034280814845985", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Exemples \/ Rampe basée sur la distance \/ Mise en service ", 
"snippet" : "Créez l'application et téléchargez-la sur un contrôleur. Démarrez la trace et l'application. Dans la trace, vous pouvez suivre le mouvement des axes virtuels....", 
"body" : "Créez l'application et téléchargez-la sur un contrôleur. Démarrez la trace et l'application. Dans la trace, vous pouvez suivre le mouvement des axes virtuels. " }, 
{ "title" : "Interface utilisateur ", 
"url" : "_sm_basic_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interface utilisateur ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Came ", 
"url" : "_sm_basic_user_interface_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interface utilisateur \/ Came ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Boîte de dialogue : Propriétés - Came ", 
"url" : "_sm_dlg_properties_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interface utilisateur \/ Came \/ Boîte de dialogue : Propriétés - Came ", 
"snippet" : "Fonction : Utilisez ce dialogue pour définir les variables globales de la came. Dimensions Position de début\/fin maître Les positions de début et de fin du maître définissent la plage des valeurs maître et donc l'échelle de l'axe horizontal de la came. Les paramètres par défaut sont donnés en degrés...", 
"body" : "Fonction : Utilisez ce dialogue pour définir les variables globales de la came. Dimensions Position de début\/fin maître Les positions de début et de fin du maître définissent la plage des valeurs maître et donc l'échelle de l'axe horizontal de la came. Les paramètres par défaut sont donnés en degrés angulaires avec 0 et 360 comme valeurs limites. Position de début\/fin de l'esclave Les positions esclaves associées sont déterminées par le type de graphe défini pour la came. Cependant, le segment représenté par les courbes (c'est aussi l'échelle de l'axe vertical) peut être défini par les positions de début et de fin de l'esclave qui sont données ici. Période Ces paramètres affectent le travail dans l'éditeur de cames et la table de cames. En fonction de ces paramètres, le point de départ de l'esclave est ajusté automatiquement lors du changement du point final, ainsi que l'inverse. Cet ajustement optimise la transition des règles pour qu'elle soit aussi douce et sans à-coups que possible. Transition en douceur : Les valeurs de position, de vitesse et d'accélération sont ajustées automatiquement. Période d'esclavage Indique quand la période esclave est répétée mécaniquement. Ensuite, la position de l'esclave au début et à la fin de la période maître peut s'écarter d'un multiple entier de cette valeur. Cette valeur n'est effective que si le Transition en douceur la case est cochée. Exigences de continuité L'activation de ces options de continuité de la courbe n'a aucun effet lors de l'édition de la came. Cependant, il provoque un contrôle de continuité, qui signale toute violation à la vue des messages ( CAME catégorie). Il n'est pas possible d'éditer des sauts dans la courbe de position. Le réglage par défaut nécessite également la continuité de la vitesse et de l'accélération. Vous pouvez désactiver ces options, par exemple dans le cas particulier d'une courbe constituée uniquement de segments linéaires. Cependant, cela peut conduire à des ruptures dans la courbe de position. Par défaut, le jerk (dérivé 4ème) n'est pas testé pour les sauts. Position : La courbe est vérifiée pour les sauts. Rapidité Accélération Secousse Format de compilation Lors de la compilation, MC_CAM_REF des variables de structure sont générées. Une came est décrite selon les options suivantes : polynôme (XYVA) Description polynomiale des points individuels, comprenant la position maître, la position esclave, la vitesse esclave et l'accélération esclave. tableau de points à une dimension Tableau 1D des positions des esclaves tableau de points à deux dimensions Tableau 2D des positions composites maître\/esclave Éléments Nombre d'éléments pour les réseaux de points à 1 ou 2 dimensions. Ce tableau a déjà été créé dans SM3_Basic pour les boîtiers standard 128 et 256 . Si vous saisissez une autre valeur, vous devez créer la structure dans votre application. Reportez-vous à l'exemple suivant pour cela. Segments Format de compilation standard ; prend en charge tous les types de segments Exemple d'un tableau avec 720 éléments TYPE SMC_CAMTable_LREAL_720_2 :\nSTRUCT\n Table: ARRAY[0..719] OF ARRAY[0..1] OF LREAL;\n fEditorMasterMin, fEditorMasterMax: REAL;\n fEditorSlaveMin, fEditorSlaveMax: REAL;\n fTableMasterMin, fTableMasterMax: REAL;\n fTableSlaveMin, fTableSlaveMax: REAL;\nEND_STRUCT\nEND_TYPE Pour plus d'informations, consultez : Comment créer une caméra" }, 
{ "title" : "Commande : Afficher le code généré ", 
"url" : "_sm_cmd_cam_display_generated_code.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interface utilisateur \/ Came \/ Commande : Afficher le code généré ", 
"snippet" : "Afficher le code généré Fonction : La commande ouvre le Code généré dialogue où s'affiche le code d'initialisation CEI de la came représentée. Appel : Came menu Exigence : L'éditeur de came est ouvert et affiche une came. Aucun code généré n'est affiché pour Segments format de compilation. Le code g...", 
"body" : "Afficher le code généré Fonction : La commande ouvre le Code généré dialogue où s'affiche le code d'initialisation CEI de la came représentée. Appel : Came menu Exigence : L'éditeur de came est ouvert et affiche une came. Aucun code généré n'est affiché pour Segments format de compilation. Le code généré n'est plus nécessaire car l'API CamBuilder peut être utilisée pour mieux générer des caméras par programmation Code généré Dialogue Exemple : code d'initialisation CEI {attribute 'linkalways'}\n\nVAR_GLOBAL\nCam_A: ARRAY[0..3] OF SMC_CAMXYVA := [\n (dX := 0, dY := 0, dV := 0, dA := 0),\n (dX := 120, dY := 120, dV := 1, dA := 0),\n (dX := 240, dY := 240, dV := 1, dA := 0),\n (dX := 360, dY := 360, dV := 0, dA := 0)];\nCam: MC_CAM_REF := (nElements := 4, byType := 3, xStart := 0, xEnd := 360, nTappets := 0, strCAMName := 'Cam', pce := ADR(Cam_A), xPartofLM := TRUE);\nEND_VAR " }, 
{ "title" : "Lire les données de came à partir du tableau ASCII Commander ", 
"url" : "_sm_cmd_cam_read_data_from_ascii_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interface utilisateur \/ Came \/ Lire les données de came à partir du tableau ASCII Commander ", 
"snippet" : "Lire les données de came à partir du tableau ASCII Fonction : La commande lit un ASCII déposer. Appel : Came menu Exigence : L'éditeur de came est ouvert. Lors de la lecture, les données du fichier sont interprétées comme les valeurs X\/Y d'une came. Les Nombre de points La boîte de dialogue s'ouvre ...", 
"body" : "Lire les données de came à partir du tableau ASCII Fonction : La commande lit un ASCII déposer. Appel : Came menu Exigence : L'éditeur de came est ouvert. Lors de la lecture, les données du fichier sont interprétées comme les valeurs X\/Y d'une came. Les Nombre de points La boîte de dialogue s'ouvre pour vous permettre de diminuer le nombre de points d'interpolation. Ensuite, les points déterminés sont interpolés dans une came et affichés dans l'éditeur. Les Écrire les données de came dans la table ASCII commandes crée un TXT déposer. " }, 
{ "title" : "Nombre de points Dialogue ", 
"url" : "_sm_cmd_cam_read_data_from_ascii_table.html#UUID-dc22ffbd-b76b-ca74-a92b-235fbf0143cb_id_d53fe1240e8dd1c0a8640e0032565c_id_b03dff25496d07f6c0a8646340c5ba9e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interface utilisateur \/ Came \/ Lire les données de came à partir du tableau ASCII Commander \/ Nombre de points Dialogue ", 
"snippet" : "Nombre de points Nombre de points utilisés pour l'interpolation. Préréglage : selon le nombre de valeurs X\/Y stockées dans le fichier lu. Exemple: 256 Vous pouvez diminuer la valeur prédéfinie afin de déterminer la came avec moins de points d'interpolation. Lors de la détermination des points d'inte...", 
"body" : "Nombre de points Nombre de points utilisés pour l'interpolation. Préréglage : selon le nombre de valeurs X\/Y stockées dans le fichier lu. Exemple: 256 Vous pouvez diminuer la valeur prédéfinie afin de déterminer la came avec moins de points d'interpolation. Lors de la détermination des points d'interpolation, leurs valeurs X sont réparties de manière équidistante. Comme la came est interpolée à l'aide d'un polynôme du 5e degré, un plus grand nombre de points d'interpolation peut provoquer des oscillations. " }, 
{ "title" : "Commande : écrire les données de came dans la table ASCII ", 
"url" : "_sm_cmd_cam_write_data_into_ascii_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interface utilisateur \/ Came \/ Commande : écrire les données de came dans la table ASCII ", 
"snippet" : "Écrire les données de came dans la table ASCII Fonction : La commande crée un ASCII déposer ( TXT extension) sur le système de développement. Un nombre spécifié de valeurs X\/Y de la came active est enregistré dans ce fichier. Une boîte de dialogue par défaut s'ouvre d'abord, puis le Nombre de points...", 
"body" : "Écrire les données de came dans la table ASCII Fonction : La commande crée un ASCII déposer ( TXT extension) sur le système de développement. Un nombre spécifié de valeurs X\/Y de la came active est enregistré dans ce fichier. Une boîte de dialogue par défaut s'ouvre d'abord, puis le Nombre de points dialogue. Appel : Came menu Exigence : L'éditeur de came est ouvert et affiche une came. " }, 
{ "title" : "Nombre de points Dialogue ", 
"url" : "_sm_cmd_cam_write_data_into_ascii_table.html#UUID-b84e5af8-679e-916c-e8a6-2358c4cccb5c_id_c2bdaa8241199e2c0a8640e018c7af7_id_b03dff25496d07f6c0a8646340c5ba9e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interface utilisateur \/ Came \/ Commande : écrire les données de came dans la table ASCII \/ Nombre de points Dialogue ", 
"snippet" : "La table ASCII ne contient aucune information sur les cames. Nombre de points Nombre de valeurs X\/Y enregistrées dans le fichier et représentées dans la forme de la courbe. À cette fin, la courbe X est divisée de manière équidistante et la valeur Y respective est déterminée....", 
"body" : "La table ASCII ne contient aucune information sur les cames. Nombre de points Nombre de valeurs X\/Y enregistrées dans le fichier et représentées dans la forme de la courbe. À cette fin, la courbe X est divisée de manière équidistante et la valeur Y respective est déterminée. " }, 
{ "title" : "Commande : lire le fichier en ligne de la caméra ", 
"url" : "_sm_cmd_cam_read_online_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interface utilisateur \/ Came \/ Commande : lire le fichier en ligne de la caméra ", 
"snippet" : "Lire le fichier en ligne de la caméra Fonction : La commande lit un fichier externe avec des données de came. L'extension de fichier est CAM . La came est affichée dans l'éditeur de came. Appel : Came menu Exigence : L'éditeur de came est ouvert. Les Écrire le fichier en ligne de la caméra commande ...", 
"body" : "Lire le fichier en ligne de la caméra Fonction : La commande lit un fichier externe avec des données de came. L'extension de fichier est CAM . La came est affichée dans l'éditeur de came. Appel : Came menu Exigence : L'éditeur de came est ouvert. Les Écrire le fichier en ligne de la caméra commande crée un fichier approprié dans CAM format. " }, 
{ "title" : "Commande : écrire le fichier en ligne de la caméra ", 
"url" : "_sm_cmd_cam_write_online_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Interface utilisateur \/ Came \/ Commande : écrire le fichier en ligne de la caméra ", 
"snippet" : "Écrire le fichier en ligne de la caméra Fonction : La commande crée un fichier ( CAM extension). Le fichier contient les données de la came active sous l'éditeur. Appel : Came menu Exigence : L'éditeur de came est ouvert et affiche une came. Les données de came sont composées d'une description de ca...", 
"body" : "Écrire le fichier en ligne de la caméra Fonction : La commande crée un fichier ( CAM extension). Le fichier contient les données de la came active sous l'éditeur. Appel : Came menu Exigence : L'éditeur de came est ouvert et affiche une came. Les données de came sont composées d'une description de came et des positions et types de cames. UNE CAM peut être lu par l'éditeur au moyen de la Lire le fichier en ligne de la caméra commander. De plus, une instance de la SMC_ReadCAM Le bloc fonction peut lire le fichier afin de charger une table de cames dans l'application au moment de l'exécution. Pour plus d'informations, voir : Structures de données des cames" }, 
{ "title" : "CODESYS SoftMotion CNC ", 
"url" : "_sm_f_cnc.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Éditeur ", 
"url" : "_sm_f_cnc_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Éditeur ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Aperçu ", 
"url" : "_sm_overview_cnc_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Éditeur \/ Aperçu ", 
"snippet" : "Dans l'éditeur CNC, vous implémentez des mouvements multidimensionnels complexes dans l'éditeur tabulaire ou l'éditeur de texte selon le langage CNC DIN 66025. De plus, l'éditeur propose les éléments suivants : Éditeur graphique pour afficher le chemin Boîte à outils pour l'éditeur graphique Vue ave...", 
"body" : "Dans l'éditeur CNC, vous implémentez des mouvements multidimensionnels complexes dans l'éditeur tabulaire ou l'éditeur de texte selon le langage CNC DIN 66025. De plus, l'éditeur propose les éléments suivants : Éditeur graphique pour afficher le chemin Boîte à outils pour l'éditeur graphique Vue avec les propriétés de l'élément de chemin sélectionné " }, 
{ "title" : "Fondamentaux de l'éditeur CNC ", 
"url" : "_sm_cnc_edt_basics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Éditeur \/ Fondamentaux de l'éditeur CNC ", 
"snippet" : "Avec la norme DIN 66025, vous pouvez créer jusqu'à 9 trajets dimensionnels. Trois de ces dimensions ne sont pas interpolées linéairement. En X\/Y\/Z, vous pouvez programmer des lignes, des arcs, des ellipses, des paraboles et des splines. Huit autres axes supplémentaires sont fournis. Parmi ceux-ci, c...", 
"body" : "Avec la norme DIN 66025, vous pouvez créer jusqu'à 9 trajets dimensionnels. Trois de ces dimensions ne sont pas interpolées linéairement. En X\/Y\/Z, vous pouvez programmer des lignes, des arcs, des ellipses, des paraboles et des splines. Huit autres axes supplémentaires sont fournis. Parmi ceux-ci, cinq sont interpolés linéairement (P\/Q\/U\/V\/W) et trois avec un polynôme du 3e degré (A\/B\/C). Pour chaque bloc de mouvement dans le programme CNC, l'interpolateur calcule la trajectoire transversale. En même temps, l'interpolateur calcule la forme de la trajectoire, la vitesse, l'accélération et la secousse selon l'interpolation spécifiée. Pour chaque chemin programmé, CODESYS crée automatiquement une structure de données globale avec les données CNC utilisables dans un programme CEI. Il existe différentes options à cet effet : SMC_CNC_REF : Le programme CNC est enregistré sous la forme d'un tableau de mots de code G qui sont traités au moment de l'exécution de l'application au moyen de SMC_NCInterpreter . Le résultat est le chemin CNC décrit comme une séquence d'objets de structure GEOINFO. Au moyen de modules de prétraitement de trajectoire de la bibliothèque SM3_CNC (exemple : correction de rayon d'outil), ces objets peuvent être édités, interpolés, transformés et transférés de l'interface du variateur au matériel pour la communication. SMC_OUTQUEUE : Le programme CNC est écrit dans une structure de données sous la forme d'une liste d'objets de structure GEOINFO avec le nom SMC_OUTQUEUE , et il peut ensuite être entré directement dans l'interpolateur. En conséquence, contrairement à SMC_CNC_REF , le bloc fonction interpréteur et les blocs fonction de prétraitement de chemin n'ont pas besoin d'être appelés. Cependant, le programme ne peut pas être modifié à l'exécution et aucune variable en code G ne peut être utilisée dans ce mode. FILE : Ensuite, le programme CNC est enregistré sous forme de fichier ASCII dans le système de fichiers du contrôleur et lu et mis en œuvre étape par étape. Cette méthode est particulièrement appropriée pour les programmes volumineux qui ne peuvent pas être stockés entièrement dans la mémoire. Il convient également aux programmes générés par l'utilisateur après la compilation de l'application du contrôleur. " }, 
{ "title" : "Structure de l'éditeur CNC ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_43423fe2e9a24fa0c0a864632228473f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Éditeur \/ Fondamentaux de l'éditeur CNC \/ Structure de l'éditeur CNC ", 
"snippet" : "L'éditeur CNC se compose des composants suivants : Editeur principal : L'éditeur de texte affiche le programme DIN 66025, ou l'éditeur tabulaire affiche le chemin CNC. Editeur graphique : La vue graphique du chemin est affichée ici. Propriétés vue des éléments CNC Boîte à outils vue : Contient des o...", 
"body" : "L'éditeur CNC se compose des composants suivants : Editeur principal : L'éditeur de texte affiche le programme DIN 66025, ou l'éditeur tabulaire affiche le chemin CNC. Editeur graphique : La vue graphique du chemin est affichée ici. Propriétés vue des éléments CNC Boîte à outils vue : Contient des outils pour sélectionner et insérer des éléments de chemin Lorsque vous appuyez sur le F6 , le focus bascule entre l'éditeur principal et l'éditeur graphique. Si un élément de trajectoire est sélectionné dans l'éditeur graphique, le bloc ou la ligne de déplacement respectif est sélectionné implicitement dans l'éditeur de texte ou l'éditeur tabulaire. De même, un élément sélectionné dans l'éditeur tabulaire ou l'éditeur de texte est également sélectionné dans l'éditeur graphique. Les modifications dans l'éditeur graphique sont appliquées dans l'éditeur de texte ou l'éditeur tabulaire, et inversement. Les paramètres CNC à l'échelle de l'application sont appliqués et enregistrés dans le Paramètres CNC objet. Les réglages CNC spécifiques à l'objet sont appliqués et enregistrés dans le Propriétés boîte de dialogue de l'objet CNC. " }, 
{ "title" : "Composants logiciels SoftMotion de l'éditeur CNC ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_92f7df24e9a24fa0c0a864630c4c4560", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Éditeur \/ Fondamentaux de l'éditeur CNC \/ Composants logiciels SoftMotion de l'éditeur CNC ", 
"snippet" : "(1) éditeur CNC (2) Programme IEC (3) Paramètre (4) Interprète (5) GéoInfo (6) Prétraitement de chemin (7) Interpolateur (8) Points de chemin (9) Coordonnées cartésiennes (10) Cinématique directe (11) Transformation spécifique à la machine (12) Cinématique inverse (13) Position de l'axe (14) Interfa...", 
"body" : "(1) éditeur CNC (2) Programme IEC (3) Paramètre (4) Interprète (5) GéoInfo (6) Prétraitement de chemin (7) Interpolateur (8) Points de chemin (9) Coordonnées cartésiennes (10) Cinématique directe (11) Transformation spécifique à la machine (12) Cinématique inverse (13) Position de l'axe (14) Interface d'entraînement " }, 
{ "title" : "Compilation d'objets CNC ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_c0635f14eddc9007c0a8646316c80481", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Éditeur \/ Fondamentaux de l'éditeur CNC \/ Compilation d'objets CNC ", 
"snippet" : "le Mode compilation est sélectionné lors de l'ajout d'un nouvel objet CNC, et si nécessaire, il peut être modifié dans le Propriétés boîte de dialogue ( CNC onglet de l'objet CNC). En fonction de la Mode compilation , une SMC_OutQueue bloc fonction, SMC_CNC_REF bloc fonctionnel ou un fichier ASCII a...", 
"body" : "le Mode compilation est sélectionné lors de l'ajout d'un nouvel objet CNC, et si nécessaire, il peut être modifié dans le Propriétés boîte de dialogue ( CNC onglet de l'objet CNC). En fonction de la Mode compilation , une SMC_OutQueue bloc fonction, SMC_CNC_REF bloc fonctionnel ou un fichier ASCII avec le chemin CNC programmé est créé au moment de la compilation. Si la Exclure de la construction l'option est sélectionnée dans le Propriétés dialogue sur le Construire de l'objet CNC, aucune donnée CEI n'est générée. En mode compilation Déposer , aucune donnée n'est téléchargée vers le contrôleur. " }, 
{ "title" : "Ouverture d'un CoDeSys V2.3 Projets ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_88cb0aeee9a24fa0c0a864634f00b359", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Éditeur \/ Fondamentaux de l'éditeur CNC \/ Ouverture d'un CoDeSys V2.3 Projets ", 
"snippet" : "Lorsque vous ouvrez un CoDeSys V2.3 projet en CODESYS , un convertisseur est fourni pour exécuter les fonctions suivantes tant qu'un contrôleur SoftMotion est utilisé : Chaque programme CNC est converti en un objet CNC avec le même nom et le même type d'implémentation DIN 66025. Le mode de compilati...", 
"body" : "Lorsque vous ouvrez un CoDeSys V2.3 projet en CODESYS , un convertisseur est fourni pour exécuter les fonctions suivantes tant qu'un contrôleur SoftMotion est utilisé : Chaque programme CNC est converti en un objet CNC avec le même nom et le même type d'implémentation DIN 66025. Le mode de compilation, la taille de la file d'attente et la position de départ du programme converti sont également appliqués comme état de la suppression d'étape. Si la Exclure de la construction option est sélectionnée dans le programme CNC du CoDeSys V2.3 projet, cette option est acceptée. le Paramètres CNC objet est généré automatiquement. Tous les objets CNC sont répertoriés sous une application compatible SoftMotion. " }, 
{ "title" : "Création d'un programme CNC ", 
"url" : "_sm_cnc_creating_cnc_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Éditeur \/ Création d'un programme CNC ", 
"snippet" : "Sélectionnez une application dans l'arborescence des appareils. Cliquez sur Projet → Ajouter un objet → Programme CNC . Spécifiez un nom dans le Ajouter un programme CNC boîte de dialogue et sélectionnez un Mise en œuvre dans la zone de liste : DIN 66025 : Pour créer votre programme dans l'éditeur d...", 
"body" : "Sélectionnez une application dans l'arborescence des appareils. Cliquez sur Projet → Ajouter un objet → Programme CNC . Spécifiez un nom dans le Ajouter un programme CNC boîte de dialogue et sélectionnez un Mise en œuvre dans la zone de liste : DIN 66025 : Pour créer votre programme dans l'éditeur de texte Tableau : Pour créer votre programme dans l'éditeur tabulaire Sélectionner un Mode compilation pour déterminer le comportement lors de la compilation : SMC_OutQueue : Une structure de données SMC_OutQueue est générée à la compilation. Vous bénéficiez d'un accès mondial au moyen de g_CNCQueueManager (SMC_OutQueue). SMC_CNC_REF : Les variables de programme sont générées à la compilation. Vous bénéficiez d'un accès mondial au moyen de g_CNCProgManager (SMC-CNC_REF) dans un programme CEI. DÉPOSER : Un fichier généré par code G est téléchargé et mis à jour à chaque connexion. L'automate peut télécharger ce fichier au moyen de blocs fonction. Vous pouvez changer le Mise en œuvre et Mode compilation plus tard dans le Propriétés boîte de dialogue ( CNC onglet du programme CNC). Cliquez sur Ajouter . L'objet CNC est inséré dans l'arborescence des appareils et ouvert dans l'éditeur. " }, 
{ "title" : "Programmation d'un chemin selon DIN 66025 ", 
"url" : "_sm_cnc_programming_din_66025.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Éditeur \/ Programmation d'un chemin selon DIN 66025 ", 
"snippet" : "SoftMotion prend en charge des parties du langage CNC DIN 66025 qui permet la programmation de trajectoires géométriques dans l'éditeur d'un objet CNC. le Éditeur DIN 66025 de l'objet CNC (également : éditeur de texte CNC) est prévu pour la programmation dans le langage CNC DIN 66025. Exigence : Un ...", 
"body" : "SoftMotion prend en charge des parties du langage CNC DIN 66025 qui permet la programmation de trajectoires géométriques dans l'éditeur d'un objet CNC. le Éditeur DIN 66025 de l'objet CNC (également : éditeur de texte CNC) est prévu pour la programmation dans le langage CNC DIN 66025. Exigence : Un Programme CNC l'objet est ouvert avec DIN 66025 la mise en oeuvre. Placez le curseur dans la ligne vide. Saisissez les blocs de code G ligne par ligne dans l'éditeur. Lorsque vous avez entré un bloc (exemple : N10 G01 X100 Y100 E100 F100 E-200 ), l'élément de chemin s'affiche immédiatement dans l'éditeur graphique. C'est ici que vous pouvez utiliser le champ de commande pour modifier la vue et la direction de la vue sur les différents axes. Si vous sélectionnez l'élément de chemin dans l'éditeur graphique, ses propriétés sont affichées dans le Propriétés voir. Pour plus d'informations, consultez : Principes de base DIN 66025" }, 
{ "title" : "Programmation d'un chemin dans l'éditeur tabulaire ", 
"url" : "_sm_cnc_programming_table_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Éditeur \/ Programmation d'un chemin dans l'éditeur tabulaire ", 
"snippet" : "Exigence : Un Programme CNC l'objet est créé avec le Tableau l'implémentation, et l'objet est ouvert dans le éditeur de tableau ....", 
"body" : "Exigence : Un Programme CNC l'objet est créé avec le Tableau l'implémentation, et l'objet est ouvert dans le éditeur de tableau . " }, 
{ "title" : "Insertion d'éléments ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f56fa52f4ccd11e69d4cb2db330b91fd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Éditeur \/ Programmation d'un chemin dans l'éditeur tabulaire \/ Insertion d'éléments ", 
"snippet" : "Double-cliquez sur le Vide cellule dans le Taper colonne. Sélectionnez un élément dans la zone de liste et appuyez sur la touche Entrer clé. S'il s'agit du premier élément de la table, les champs sont remplis avec les valeurs initiales de l'élément. Sinon, l'élément reçoit les valeurs de l'élément d...", 
"body" : "Double-cliquez sur le Vide cellule dans le Taper colonne. Sélectionnez un élément dans la zone de liste et appuyez sur la touche Entrer clé. S'il s'agit du premier élément de la table, les champs sont remplis avec les valeurs initiales de l'élément. Sinon, l'élément reçoit les valeurs de l'élément de la ligne précédente. Tous les autres champs restent grisés et l'élément est affiché dans l'éditeur graphique. La dernière ligne du tableau est une ligne vide avec le type Vide . Pour ajouter un autre élément, vous pouvez également cliquer sur le Insérer un élément commande dans le menu contextuel d'une entrée de table. " }, 
{ "title" : "Modification d'une entrée de table ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f568c7504ccd11e69d4cb2db330b91fd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Éditeur \/ Programmation d'un chemin dans l'éditeur tabulaire \/ Modification d'une entrée de table ", 
"snippet" : "Double-cliquez sur une entrée de tableau d'un élément. Le champ est modifiable ou il y a un symbole d'une zone de liste. L'élément est marqué en rouge dans l'éditeur graphique. Modifiez la valeur de l'entrée de table. La modification est affichée dans l'éditeur graphique. Si vous cliquez sur la comm...", 
"body" : "Double-cliquez sur une entrée de tableau d'un élément. Le champ est modifiable ou il y a un symbole d'une zone de liste. L'élément est marqué en rouge dans l'éditeur graphique. Modifiez la valeur de l'entrée de table. La modification est affichée dans l'éditeur graphique. Si vous cliquez sur la commande Appliquer la valeur à tous les éléments dans le menu contextuel de l'entrée du tableau, la valeur actuelle est alors appliquée dans toutes les autres entrées de la même colonne. Condition : La valeur peut être utilisée pour le type d'élément respectif. Le numéro de ligne ne peut pas être modifié. " }, 
{ "title" : "Suppression d'un élément ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f0684d0502561eafc0a864633d0e8542", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Éditeur \/ Programmation d'un chemin dans l'éditeur tabulaire \/ Suppression d'un élément ", 
"snippet" : "Sélectionnez une ligne du tableau et cliquez sur la commande Supprimer l'élément dans le menu contextuel. La dernière ligne du tableau avec le type Vide ne peut pas être supprimé....", 
"body" : "Sélectionnez une ligne du tableau et cliquez sur la commande Supprimer l'élément dans le menu contextuel. La dernière ligne du tableau avec le type Vide ne peut pas être supprimé. " }, 
{ "title" : "Structures de données CNC et accès global ", 
"url" : "_sm_cnc_data_structure_global_access.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Éditeur \/ Structures de données CNC et accès global ", 
"snippet" : "Les objets CNC disponibles dans le projet sont compilés dans des blocs fonctionnels de type SMC_OUTQUEUE ou SMC_CNC_REF . (Cela ne se produit pas lorsque la méthode de compilation DÉPOSER est utilisé.) Lors de la compilation du projet, les données CNC créées sont gérées en interne dans le SMC_CNC_Da...", 
"body" : "Les objets CNC disponibles dans le projet sont compilés dans des blocs fonctionnels de type SMC_OUTQUEUE ou SMC_CNC_REF . (Cela ne se produit pas lorsque la méthode de compilation DÉPOSER est utilisé.) Lors de la compilation du projet, les données CNC créées sont gérées en interne dans le SMC_CNC_Data blocs fonctionnels. Pour le mode compilation SMC_OutQueue , chaque élément CNC est représenté par un SMC_OUTQUEUE bloc fonctionnel. Pour le mode compilation SMC_CNC_REF , un élément CNC est représenté par SMC_CNC_REF . Pendant le traitement du programme CEI, les blocs fonctionnels sont instanciés et remplis de valeurs pouvant être traitées dans les programmes CEI. Tous ces POU sont contenus dans SM3_CNC . " }, 
{ "title" : "Accès mondial aux données CNC ", 
"url" : "_sm_cnc_data_structure_global_access.html#UUID-aaee586d-72f4-405c-8bb5-b4b2cb32f52d_id_cb8536efda52bb5c0a8646375871841_id_4fd460ed02599820c0a864633ab223de", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Éditeur \/ Structures de données CNC et accès global \/ Accès mondial aux données CNC ", 
"snippet" : "Lors de l'initialisation, le type et le nombre d'objets générés sont déterminés à partir du programme CNC. Tous ces objets sont répertoriés ensemble dans une structure de données globale déclarée implicitement. Objets de type SMC_OUTQUEUE sont répertoriés dans l'objet de données global g_CNCQueueMan...", 
"body" : "Lors de l'initialisation, le type et le nombre d'objets générés sont déterminés à partir du programme CNC. Tous ces objets sont répertoriés ensemble dans une structure de données globale déclarée implicitement. Objets de type SMC_OUTQUEUE sont répertoriés dans l'objet de données global g_CNCQueueManager avec la propriété Count et la méthode GetOutQueue(int n) . Objets de type SMC_CNC_REF sont répertoriés dans l'objet de données global g_CNCProgManager avec la propriété Count et la méthode GetProgram(int n) . L'utilisateur peut désormais y accéder dans un programme IEC. Exemple Accès aux objets de données de la structure SMC_OUTQUEUE PROGRAM CNCManageQueue\nVAR\n pCNC_OutQueue : POINTER TO SMC_OUTQUEUE;\n n: INT;\n i: INT;\nEND_VAR\n\nn := g_CNCQueueManager.Count;\nFOR i:= 0 to n-1 DO\n pCNC_OutQueue := g_CNCQueueManager.GetOutQueue(I);\n (* calculate pCNC_OutQueue *)\nEND_FOR Accès aux objets de données de la structure SMC_CNC_REF PROGRAM CNCManageRef\nVAR\n pCNC_Ref: POINTER TO SMC_CNC_REF;\n n: INT;\nEND_VAR\n\nn := g_CNCProgManager.Count;\nFOR i:= 0 to n-1 DO\n pCNC_Ref := g_CNCProgManager.GetProgram(I);\n (* calculate pCNC_Ref *)\nEND_FOR " }, 
{ "title" : "Transformations cinématiques ", 
"url" : "_sm_f_cnc_kinematic_transformations.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Transformation directe et inverse ", 
"url" : "_sm_cnc_forward_backward_transformation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Transformation directe et inverse ", 
"snippet" : "CODESYS SoftMotion fournit des blocs fonctionnels pour la transformation mathématique directe et inverse pour de nombreuses cinématiques populaires. Pour chaque conception cinématique, deux blocs fonctionnels sont disponibles pour la transformation. Le POU nommé SMC_TRAFO_<kinematics> calcule la pos...", 
"body" : "CODESYS SoftMotion fournit des blocs fonctionnels pour la transformation mathématique directe et inverse pour de nombreuses cinématiques populaires. Pour chaque conception cinématique, deux blocs fonctionnels sont disponibles pour la transformation. Le POU nommé SMC_TRAFO_<kinematics> calcule la position de l'axe à partir de la position dans l'espace (transformation inverse). Le POU nommé SMC_TRAFOF_<kinematics> calcule la position dans l'espace à partir de la position de l'axe (transformation vers l'avant). Vous pouvez lier rapidement et facilement les instances des POU de transformation directe à des modèles de visualisation afin de visualiser la cinématique. SMC_TRAFOV_ Certaines des transformations inverses utilisent également la vitesse de trajectoire et la direction de trajectoire pour calculer les vitesses d'axe. Les noms de ces POU de transformation commencent par SMC_TRAFOV_ à la place de SMC_TRAFO_ . Ces POU obtiennent la tangente au chemin ( v ) et la vitesse de trajectoire ( dVel ) comme entrées supplémentaires de l'interpolateur. Ils renvoient également les vitesses réglées ( dvx\/dvy\/dvz ) en plus des positions définies. L'avantage est que le retard dans le variateur peut être minimisé par le contrôle d'entrée de la vitesse, à condition que le variateur prenne en charge cette méthode. Pour transférer les vitesses réglées au variateur, vous devez utiliser SMC_ControlAxisByPosVel à la place de SMC_ControlAxisByPos dans ce cas. Pour plus d'informations, consultez : SMC_ControlAxisByPos (FB) , SMC_ControlAxisByVel (FB) , et SMC_ControlAxisByPosVel (FB) " }, 
{ "title" : "Transformation 5 axes ", 
"url" : "_sm_trafo_pou_five_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Transformation 5 axes ", 
"snippet" : "Avec la transformation 5 axes, vous pouvez contrôler une cinématique composée de trois axes spatiaux linéaires (X, Y, Z) et d'une tête d'outil. La tête de l'outil se compose de deux axes qui maintiennent l'outil. Un axe d'outil tourne autour de l'axe Z et l'outil incline les autres selon le schéma s...", 
"body" : "Avec la transformation 5 axes, vous pouvez contrôler une cinématique composée de trois axes spatiaux linéaires (X, Y, Z) et d'une tête d'outil. La tête de l'outil se compose de deux axes qui maintiennent l'outil. Un axe d'outil tourne autour de l'axe Z et l'outil incline les autres selon le schéma suivant. Paramètre : Longueur de dTool = Distance entre le point d'usinage (pointe d'outil = TCP) et l'inclinaison de l'axe rotatif. Contrôle de la transformation 5 axes par cinq valeurs de position : Position X\/Y\/Z du point de traitement (TCP) inclus dans pi.dX, pi.dY, pi.dZ . Unité : Unités de position des axes. Orientation de l'outil par des coordonnées sphériques (inclinaison et azimut) incluses dans pi.dB et pi.dC . Unité : Degrés angulaires. Position zéro Le point de traitement (TCP) est situé à la position ( 0\/0\/-dTool ). L'outil s'étend dans la direction de l'axe Z négatif. L'inclinaison de l'axe de rotation est positionnée de manière à ce qu'une rotation dans le sens positif déplace l'outil dans la direction de l'axe X positif. Exemple Pour le mouvement N30, l'axe d'inclinaison qui pointe en premier dans la direction X est tourné et il reste incliné dans la direction X négative à la fin du mouvement. N0 PB360 PC360 (set axis B and C in modulo mode 360)\nN10 F10 FB100 FC100 (velocity in X\/Y\/Z: 10, in B and C 100)\nN20 G0 X0 Y0 Z0 C0 B30 (start position)\nN30 G1 X20 B-30 (target position) Pour plus d'informations, consultez : SMC_TRAFO_5Axes (FB) et SMC_TRAFOF_5Axes (FB) " }, 
{ "title" : "Système de portique ", 
"url" : "_sm_trafo_pou_gantry_system.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Système de portique ", 
"snippet" : "Les systèmes de portique se composent de deux ou trois axes linéaires disposés à angle droit. Comme les transformations ne doivent pas être exécutées dans les systèmes de portique, les modules respectifs pour les transformations inverses et directes ajoutent un seul décalage aux axes X, Y et Z en de...", 
"body" : "Les systèmes de portique se composent de deux ou trois axes linéaires disposés à angle droit. Comme les transformations ne doivent pas être exécutées dans les systèmes de portique, les modules respectifs pour les transformations inverses et directes ajoutent un seul décalage aux axes X, Y et Z en deux ou trois dimensions. Pour plus d'informations, consultez : MC_TRAFO_Gantry2 (FB) SMC_TRAFOF_Gantry2 (FB) SMC_TRAFO_Gantry3 (FB) SMC_TRAFOF_Gantry3 (FB) " }, 
{ "title" : "Système de portique avec axes d'orientation ", 
"url" : "_sm_trafo_pou_gantry_cutter.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Système de portique avec axes d'orientation ", 
"snippet" : "Un \"portique de découpe\" est un système de portique à axe rotatif équipé d'un outil de coupe. La configuration d'un système portique à axe rotatif est similaire à celle d'un système portique simple. Cependant, ces systèmes ont également un axe rotatif où l'unité de coupe verticale est fixée. Lorsque...", 
"body" : "Un \"portique de découpe\" est un système de portique à axe rotatif équipé d'un outil de coupe. La configuration d'un système portique à axe rotatif est similaire à celle d'un système portique simple. Cependant, ces systèmes ont également un axe rotatif où l'unité de coupe verticale est fixée. Lorsque vous utilisez un système de portique avec un axe rotatif, vous devez utiliser le SMC_TRAFO<n>_GantryCutter<n> POU au lieu de SMC_TRAFO<n>_Gantry<n> . Ensuite, l'axe rotatif est commandé de manière à ce qu'il soit orienté le long de la tangente à la trajectoire courante. Les POU de découpeur à portique ont les entrées supplémentaires suivantes : DriveR : Axe rotatif à utiliser avec une période de 360° dOffsetR : Décalage de l'axe rotatif iDirectionR : Direction de rotation Pour plus d'informations, consultez : SMC_TRAFO_GantryCutter2 (FB) SMC_TRAFOF_GantryCutter2 (FB) SMC_TRAFO_GantryCutter3 (FB) SMC_TRAFOF_GantryCutter3 (FB) Les POU pour la transformation inverse doivent également inclure le vecteur de la tangente du chemin actuel (v) qui est une sortie de l'interpolateur. Pour plus d'informations, consultez : SMC_TRAFOV_GantryCutter2 (FB) et SMC_TRAFOV_GantryCutter3 (FB) " }, 
{ "title" : "Système de portique avec décalage d'outil ", 
"url" : "_sm_trafo_pou_gantry_system_tool.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Système de portique avec décalage d'outil ", 
"snippet" : "Si l'axe de l'outil présente un décalage et ne coïncide pas avec l'axe Z du système de portique, le point de contact de l'outil ne correspond pas à la position X\/Y\/Z du système de portique. Si l'axe Z ne peut pas être tourné, le décalage résultant des coordonnées X et Y est constant et peut être uti...", 
"body" : "Si l'axe de l'outil présente un décalage et ne coïncide pas avec l'axe Z du système de portique, le point de contact de l'outil ne correspond pas à la position X\/Y\/Z du système de portique. Si l'axe Z ne peut pas être tourné, le décalage résultant des coordonnées X et Y est constant et peut être utilisé directement pour la transformation de portique standard. Si l'outil est tourné par l'axe C (environ Z), alors le décalage n'est pas constant, mais dépend de la position de l'axe C. Dans ce cas, l'un des deux POU peut être sélectionné, selon la forme de l'outil : SMC_TRAFO_Gantry2Tool1 et SMC_TRAFOF_Gantry2Tool1 L'outil pointe le long de l'axe X pivoté de dAlpha et a une longueur de dToolA . SMC_TRAFO_Gantry2Tool2 et SMC_TRAFOF_Gantry2Tool2 L'outil est partiellement dans la direction de l'axe X tourné par dAlpha (longueur: dToolA ) et partiellement dans la direction de l'axe Y pivoté (longueur : dToolB ). Dans la figure de l'exemple suivant, le laser est fixé avec un décalage dans la direction X et la direction Y. Au lieu d'exécuter cette transformation unidimensionnelle, la trajectoire peut également être modulée avec un décalage d'outil. A ce moment, l'outil s'approche d'une ligne droite. le SMC_ToolCorr ou SMC_ToolRadiusCorr des blocs fonctionnels sont utilisés à cet effet. La différence entre ces deux méthodes est la vitesse de la pointe de l'outil. Si la modulation est utilisée à partir de SMC_ToolCorr , la vitesse du point de rotation est contrôlée en fonction des préréglages du programme CNC (F, E). La vitesse de la pointe de l'outil peut fluctuer. Si la transformation unidimensionnelle est utilisée, la vitesse de la pointe de l'outil est déterminée par le programme CNC. Pour calculer l'orientation de l'outil, le SMC_CalcDirectionFromVector POU est utilisé. " }, 
{ "title" : "Portique en H avec axes stationnaires ", 
"url" : "_sm_trafo_pou_h_gantry_stationary_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Portique en H avec axes stationnaires ", 
"snippet" : "La configuration cinématique est similaire au système de portique, mais les axes (entraînements) sont solidement montés. Ils déplacent le porte-outil au moyen d'une courroie. Transformation au moyen de la SMC_TRAFO_GantryH2 et SMC_TRAFOF_GantryH2 Les POU nécessitent les configurations d'axe suivante...", 
"body" : "La configuration cinématique est similaire au système de portique, mais les axes (entraînements) sont solidement montés. Ils déplacent le porte-outil au moyen d'une courroie. Transformation au moyen de la SMC_TRAFO_GantryH2 et SMC_TRAFOF_GantryH2 Les POU nécessitent les configurations d'axe suivantes. D'autres configurations peuvent être réalisées en échangeant x et y : Cette transformation nécessite un référencement particulier : les deux axes doivent être déplacés à la même vitesse. Si le mouvement doit être dans la direction X, alors les entraînements A et B doivent être déplacés, alors qu'ils doivent se déplacer avec une vitesse inverse pour strictement un mouvement X. Pour un mouvement X uniquement, ils doivent être déplacés avec une vitesse opposée. Si la prise d'origine est trouvée, les valeurs X et Y calculées à partir de la POU de transformation directe sont utilisées comme décalage ( dOffsetX et dOffsetY ). " }, 
{ "title" : "Portique en T avec axes stationnaires ", 
"url" : "_sm_trafo_pou_t_gantry_statinary_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Portique en T avec axes stationnaires ", 
"snippet" : "Ce système cinématique est similaire aux systèmes à portique en H. Les entraînements sont ici également montés à l'arrêt et le porte-outil est déplacé au moyen d'une courroie. Les transformations exécutées par le SMC_TRAFO_GantryT2 et SMC_TRAFOF_GantryT2 Les POU sont conçues pour les constellations ...", 
"body" : "Ce système cinématique est similaire aux systèmes à portique en H. Les entraînements sont ici également montés à l'arrêt et le porte-outil est déplacé au moyen d'une courroie. Les transformations exécutées par le SMC_TRAFO_GantryT2 et SMC_TRAFOF_GantryT2 Les POU sont conçues pour les constellations de disques suivantes : Notez qu'un référencement spécial est nécessaire pour cette transformation. Si vous exécutez un mouvement dans la direction X, vous devez déplacer les moteurs A et B à la même vitesse. Si vous exécutez strictement un mouvement en Y, les entraînements doivent tourner dans des directions opposées. Si le variateur trouve la position de référence, les valeurs X et Y calculées à partir de la transformation directe POU sont utilisées comme décalage ( dOffsetX et dOffsetY ). le SMC_TRAFO_GantryT2_O et SMC_TRAFOF_GantryT2_O les blocs fonctionnels exécutent le même calcul avec la constellation suivante : " }, 
{ "title" : "Système polaire ", 
"url" : "_sm_trafo_pou_polar_system.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Système polaire ", 
"snippet" : "Les systèmes polaires se composent d'un axe de rotation (direction) et d'un axe linéaire (distance). L'origine et la direction de l'axe linéaire peuvent être modifiées au moyen des décalages dPhi et dR . Pour plus d'informations, consultez : SMC_TRAFO_Polaire (FB) et SMC_TRAFOF_Polaire (FB)...", 
"body" : "Les systèmes polaires se composent d'un axe de rotation (direction) et d'un axe linéaire (distance). L'origine et la direction de l'axe linéaire peuvent être modifiées au moyen des décalages dPhi et dR . Pour plus d'informations, consultez : SMC_TRAFO_Polaire (FB) et SMC_TRAFOF_Polaire (FB) " }, 
{ "title" : "Système SCARA à 2 articulations ", 
"url" : "_sm_trafo_pou_two_jointed_scara.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Système SCARA à 2 articulations ", 
"snippet" : "le Bras de robot d'assemblage de conformité sélective (SCARA) est un type spécial de robot industriel qui ressemble à un bras humain. Un système SCARA a deux axes et deux degrés de liberté. Le mouvement est limité au plan X\/Y. Pour plus d'informations, consultez : SMC_TRAFO_Scara2 (FB) et SMC_TRAFOF...", 
"body" : "le Bras de robot d'assemblage de conformité sélective (SCARA) est un type spécial de robot industriel qui ressemble à un bras humain. Un système SCARA a deux axes et deux degrés de liberté. Le mouvement est limité au plan X\/Y. Pour plus d'informations, consultez : SMC_TRAFO_Scara2 (FB) et SMC_TRAFOF_Scara2 (FB) " }, 
{ "title" : "Système SCARA à 3 articulations ", 
"url" : "_sm_trafo_pou_three_jointed_scara.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Système SCARA à 3 articulations ", 
"snippet" : "Le système SCARA à 3 articulations possède un troisième axe qui permet un mouvement dans une direction constante. Comme dans les systèmes à 2 articulations, le mouvement est limité au plan X\/Y. Pour plus d'informations, consultez : SMC_TRAFO_Scara3 (FB) et SMC_TRAFOF_Scara3 (FB)...", 
"body" : "Le système SCARA à 3 articulations possède un troisième axe qui permet un mouvement dans une direction constante. Comme dans les systèmes à 2 articulations, le mouvement est limité au plan X\/Y. Pour plus d'informations, consultez : SMC_TRAFO_Scara3 (FB) et SMC_TRAFOF_Scara3 (FB) " }, 
{ "title" : "Cinématique parallèle ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Cinématique parallèle ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Trépied avec axes linéaires ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_b6b32d1fbe665307c0a8640e00033022", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Cinématique parallèle \/ Trépied avec axes linéaires ", 
"snippet" : "Ce système comporte trois entraînements linéaires qui forment un angle défini l'un par rapport à l'autre. Les entraînements se composent de 3 rails avec des glissières de déplacement. Le plateau porte-outils est relié aux coulisseaux traversants par des bielles de même longueur. Un ensemble apparié ...", 
"body" : "Ce système comporte trois entraînements linéaires qui forment un angle défini l'un par rapport à l'autre. Les entraînements se composent de 3 rails avec des glissières de déplacement. Le plateau porte-outils est relié aux coulisseaux traversants par des bielles de même longueur. Un ensemble apparié de bielles maintient la plaque d'outil parallèle au sol dans la même orientation. La cinématique permet de déplacer le plateau porte-outil en trois dimensions. La transformation directe et inverse de ces cinématiques est calculée dans le SMC_Trafo_Tripod_Lin et SMC_TrafoF_Tripod_Lin POU. L'angle d'axe du trépied est défini par l'angle entre le rail et l'axe vertical ( dAxisAngle ). Exigences mécaniques et système de coordonnées Les longueurs des 3 axes sont identiques. Les longueurs des bielles sont identiques. La distance entre les paires de bielles entre elles est identique pour toutes les paires. L'angle d'axe entre les rails d'entraînement et l'axe vertical est identique pour les trois entraînements. La tolérance d'angle est comprise entre 0° et 90°. L'axe définit le mouvement du point entre les joints de bielle sur les curseurs. Le système de coordonnées XYZ est droitier. Les vecteurs X et Y sont horizontaux et Z pointe vers le haut. L'origine est définie de sorte que les intersections des trois axes de déplacement avec le plan XY (graphiques ci-dessous : points A) soient sur un cercle à la position [0,0,0]. Paramétrage du bloc fonction SMC_TrafoF_Tripod_Lin Nom La description dInnerRadius Distance du centre de la plaque porte-outils aux points de préhension des bielles dOuterRadius Le point A est l'intersection de l'axe avec le plan XY. dLength Longueur des bielles dDistance Distance entre les deux bielles d'une paire dRotationOffset Le point A du premier axe définit l'axe X par défaut. Le décalage est utilisé pour faire pivoter toute la structure autour de l'axe Z. Dans ce cas, le point A n'est plus sur l'axe X. dOffsetA Le décalage est utilisé pour définir la valeur de position de l'axe sur son réglage par défaut de zéro. dOffsetB dOffsetC Vous trouverez des informations sur d'autres paramètres dans la description de la bibliothèque. " }, 
{ "title" : "Trépied à axes verticaux ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_74ba1833be665308c0a8640e019694c6", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Cinématique parallèle \/ Trépied à axes verticaux ", 
"snippet" : "Ce système est une variante spéciale de la conception cinématique décrite ci-dessus et a les mêmes exigences mécaniques. L'angle dAxisAngle entre les rails de guidage et l'axe vertical est de 0° et les rails de guidage sont parallèles à l'axe vertical. La transformation directe et inverse de ces cin...", 
"body" : "Ce système est une variante spéciale de la conception cinématique décrite ci-dessus et a les mêmes exigences mécaniques. L'angle dAxisAngle entre les rails de guidage et l'axe vertical est de 0° et les rails de guidage sont parallèles à l'axe vertical. La transformation directe et inverse de ces cinématiques est calculée dans le SMC_Trafo_Tripod_Lin et SMC_TrafoF_Tripod_Lin blocs fonctionnels. L'angle d'axe du trépied est défini par l'angle entre le rail et l'axe vertical ( dAxisAngle ). Paramétrage du bloc fonction SMC_TrafoF_Tripod_Lin Nom La description dInnerRadius Le paramètre définit le rayon du cercle qui est décrit par les six points de préhension des bielles à la plaque porte-outil. dOuterRadius dLength Longueur des bielles dDistance Distance des paires de bielles entre elles dRotationOffset Le point A du premier axe définit l'axe X par défaut. Le décalage est utilisé pour faire pivoter toute la structure autour de l'axe Z. Dans ce cas, le point A n'est plus sur l'axe X. dOffsetA Le décalage est utilisé pour définir la valeur de position de l'axe sur son réglage par défaut de zéro. dOffsetB dOffsetC Vous trouverez des informations sur d'autres paramètres dans la description de la bibliothèque. " }, 
{ "title" : "Trépied avec axes rotatifs ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_30491f2ca003ef70c0a864631e92f50c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Cinématique parallèle \/ Trépied avec axes rotatifs ", 
"snippet" : "Pour les trépieds, la cinématique est mise en œuvre par 3 entraînements rotatifs qui sont reliés au plateau porte-outil par des bras et des bielles. L'origine du système de coordonnées est l'emplacement du centre de la plaque porte-outils lorsque les 3 bras sont en position horizontale. La transform...", 
"body" : "Pour les trépieds, la cinématique est mise en œuvre par 3 entraînements rotatifs qui sont reliés au plateau porte-outil par des bras et des bielles. L'origine du système de coordonnées est l'emplacement du centre de la plaque porte-outils lorsque les 3 bras sont en position horizontale. La transformation directe et inverse de ces cinématiques est calculée dans le SMC_TRAFO_Tripod_Arm et SMC_TRAFOF_Tripod_Arm blocs fonctionnels. Exigences mécaniques et système de coordonnées Les longueurs des trois axes sont identiques. Les longueurs des bielles sont identiques. La distance entre les paires de bielles entre elles est identique pour toutes les paires. Paramétrage du bloc fonction SMC_TrafoF_Tripod_Arm Nom La description dArmLength1 dArmLength2 dArm1Radius Le paramètre définit le rayon du cercle établi par les 3 points P des entraînements. dStewartRadius Le paramètre définit le rayon du cercle qui est décrit par les 6 points de préhension des bielles à la plaque porte-outil. dDistance Distance entre les deux bielles d'une paire dOffsetA dOffsetB dOffsetC Vous trouverez des informations sur d'autres paramètres dans la description de la bibliothèque. L'image montre la position zéro de tous les axes. (Les trois bras supérieurs sont horizontaux.) Le MCS est représenté sur la plaque porte-outils. Les flèches sur les axes A0, A1 et A2 indiquent le sens de rotation des entraînements selon la règle de la main droite. Système de coordonnées machine (MCS) Origine Défini au milieu de la plaque d'outil lorsque les 3 bras supérieurs (ceux qui sont connectés directement à A0, A1 ou A2) sont en position horizontale X À partir de l'origine, pointe à l'opposé du premier moteur (A0), parallèle au segment de bras supérieur du premier bras Y Déterminé par X et Z pour que le MCS soit droitier Z Orthogonal à la plaque d'outil Points de la plaque à outils en direction des moteurs Les transformations respectives sont exécutées par les POU suivants SMC_TRAFO_Tripod_Arm et SMC_TRAFOF_Tripod_Arm : Exemple : trépied 3S Paramètres de transformation tta:\nSMC_TRAFO_Tripod_Arm := (dArmLength1:=200, dArmLength2:=300, dArm1Radius:=112, dStewartRadius:=53,dDistance:=41,dMaxAngleBallJoint:=60);\nttaf:\nSMC_TRAFOF_Tripod_Arm := (dArmLength1:=200, dArmLength2:=300, dArm1Radius:=112, dStewartRadius:=53,dDistance:=41); " }, 
{ "title" : "Cinématique du palettiseur 4 axes ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Cinématique du palettiseur 4 axes ", 
"snippet" : "La cinématique de palettisation à 4 axes est un type de robot général fréquemment utilisé pour les tâches de palettisation. La cinématique est dotée de quatre axes rotatifs commandés (marqués en rouge) et d'un cinquième axe rotatif mécanique (marqué en gris). le SMC_Trafo_4AxisPalettiseur et SMC_Tra...", 
"body" : "La cinématique de palettisation à 4 axes est un type de robot général fréquemment utilisé pour les tâches de palettisation. La cinématique est dotée de quatre axes rotatifs commandés (marqués en rouge) et d'un cinquième axe rotatif mécanique (marqué en gris). le SMC_Trafo_4AxisPalettiseur et SMC_TrafoF_4AxisPalettiseur Les POU implémentent sa transformation directe et inverse. Le système de coordonnées cartésien est la base du palettiseur. L'axe Z pointe vers le bas perpendiculairement et l'axe X \"vers l'avant\", c'est-à-dire dans la direction où le bras pointe dans la direction zéro des axes. L'origine du système de coordonnées cartésiennes est l'intersection de l'axe de l'articulation 1 et du dessous du robot. Objets La structure des données SMC_TrafoConfig_4AxisPalletizer et le SMC_Trafo_4AxisPalletizer et SMC_TrafoF_4AxisPalletizer les blocs fonctionnels sont liés à la bibliothèque SM3_Transformation . Pour une description des paramètres, recherchez ces objets dans le gestionnaire de bibliothèque. " }, 
{ "title" : "Définition des axes ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_945c0811df409256c0a8657d0066458b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Cinématique du palettiseur 4 axes \/ Définition des axes ", 
"snippet" : "L'image suivante montre le sens de rotation des quatre axes. Les flèches noires suivent l'axe de l'articulation. Le sens de rotation est déterminé selon la règle de la main droite : Si le pouce de la main droite pointe vers le bas le long de la flèche, alors le sens de rotation positif est dans la d...", 
"body" : "L'image suivante montre le sens de rotation des quatre axes. Les flèches noires suivent l'axe de l'articulation. Le sens de rotation est déterminé selon la règle de la main droite : Si le pouce de la main droite pointe vers le bas le long de la flèche, alors le sens de rotation positif est dans la direction du doigt légèrement incurvé. Par exemple, vu de dessus, le sens de rotation positif de l'axe 0 est le sens des aiguilles d'une montre, tandis que les axes 1 et 2 s'inclinent \"vers l'avant\" pour une rotation positive. La cinématique est dotée de quatre axes de rotation contrôlés (voir les axes de couleur rouge a0, a1, a2, a3) et d'un cinquième axe de rotation mécanique (voir l'axe de couleur grise M). Plages de valeurs des axes : Axe 0 : ]-180°, 180°[ Axe 1 : [-90°, 90°] Axe 2 : [-180°, 90[ Axe M : axe rotatif mécanique. Aucune restriction Axe 3 : Sans restriction ; la portée peut également être supérieure à 360° " }, 
{ "title" : "Position zéro et dimensions ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_e7016982df408f59c0a8657d017550b3", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Cinématique du palettiseur 4 axes \/ Position zéro et dimensions ", 
"snippet" : "L'image montre la cinématique en position zéro de tous les axes. En position zéro, les axes du système de coordonnées de l'outil sont parallèles à ceux du système de coordonnées de la machine. Spécifiez les dimensions indiquées dans la structure de configuration SMC_TrafoConfig_4AxisPalletizer Préci...", 
"body" : "L'image montre la cinématique en position zéro de tous les axes. En position zéro, les axes du système de coordonnées de l'outil sont parallèles à ceux du système de coordonnées de la machine. Spécifiez les dimensions indiquées dans la structure de configuration SMC_TrafoConfig_4AxisPalletizer Précisez également tout a_i avec des signes positifs et tout d_i avec des signes négatifs. Les noms des paramètres sont conformes à la convention Denavit-Hartenberg. Transformation de Denavit-Hartenberg des articulations Décalage de joint (sigma_i) Distance articulaire (d_i) Longueur de l'élément de bras (a_i) Torsion (alpha_i) 1 0° j_1 un_1 90° 2 -90° 0 a_2 0° 3 90° 0 a_3 0° 4 0° 0 a_4 90° 5 0° j_5 0 180° " }, 
{ "title" : "Programmation en code G ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_67269b93df408f35c0a8657d0178e964", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Cinématique du palettiseur 4 axes \/ Programmation en code G ", 
"snippet" : "La position du préhenseur est contrôlée avec X, Y et Z. La rotation du préhenseur sur la verticale est contrôlée par l'axe supplémentaire C. Les angles sont spécifiés en degrés....", 
"body" : "La position du préhenseur est contrôlée avec X, Y et Z. La rotation du préhenseur sur la verticale est contrôlée par l'axe supplémentaire C. Les angles sont spécifiés en degrés. " }, 
{ "title" : "Robot articulé 6 axes ", 
"url" : "_sm_trafo_pou_six_dof_robot.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Robot articulé 6 axes ", 
"snippet" : "Transformation d'un robot à bras articulé à six axes rotatifs et six degrés de liberté (DoF). Les trois axes d'orientation du bras du robot se croisent en un point : le centre de l'articulation. Les SMC_Trafo_ArticulatedRobot_6DOF et SMC_TrafoF_ArticulatedRobot_6DOF les blocs fonctionnels implémente...", 
"body" : "Transformation d'un robot à bras articulé à six axes rotatifs et six degrés de liberté (DoF). Les trois axes d'orientation du bras du robot se croisent en un point : le centre de l'articulation. Les SMC_Trafo_ArticulatedRobot_6DOF et SMC_TrafoF_ArticulatedRobot_6DOF les blocs fonctionnels implémentent les transformations avant et inverse d'un robot à bras articulé avec six axes de rotation. Dans l'image, le système de coordonnées cartésiennes est marqué ci-dessous à l'axe 0. L'axe z pointe vers le bas et l'axe x pointe vers l'avant en direction du point central de l'outil (TCP). L'origine du système de coordonnées cartésiennes est l'axe d'intersection 0 et le dessous du robot. Objets de transformation La structure des données SMC_TrafoConfig_ArticulatedRobot_6DOF et le SMC_Trafo_ArticulatedRobot_6DOF et SMC_TrafoF_ArticulatedRobot_6DOF les blocs fonctionnels sont liés à SM3_CNC . " }, 
{ "title" : "Définition des axes ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_7e060a95379b6b55c0a8640e01f01d63", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Robot articulé 6 axes \/ Définition des axes ", 
"snippet" : "Les axes rotatifs sont identifiés par des flèches noires. Le sens de rotation positif est donné par la règle de la main droite. Par exemple, lorsque l'axe 0 est tourné dans le sens positif, le robot tourne dans le sens des aiguilles d'une montre vu de dessus. Les axes sont limités aux plages suivant...", 
"body" : "Les axes rotatifs sont identifiés par des flèches noires. Le sens de rotation positif est donné par la règle de la main droite. Par exemple, lorsque l'axe 0 est tourné dans le sens positif, le robot tourne dans le sens des aiguilles d'une montre vu de dessus. Les axes sont limités aux plages suivantes : Axes 0, 1, 3 et 4 : ]-180°, 180°[ Axe 2 : [-90°, 180°] Axe 5 : Illimité ; la portée peut être supérieure à 360°. " }, 
{ "title" : "Position de référencement et dimensions ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_e7016982df408f59c0a8657d017550b3", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Robot articulé 6 axes \/ Position de référencement et dimensions ", 
"snippet" : "L'image de gauche montre la position de référence de la cinématique, c'est-à-dire la position où tous les axes sont en position zéro. Spécifiez les dimensions indiquées dans la structure de configuration SMC_TrafoConfig_ArticulatedRobot_6DOF . Les noms et signes des paramètres sont conformes à la co...", 
"body" : "L'image de gauche montre la position de référence de la cinématique, c'est-à-dire la position où tous les axes sont en position zéro. Spécifiez les dimensions indiquées dans la structure de configuration SMC_TrafoConfig_ArticulatedRobot_6DOF . Les noms et signes des paramètres sont conformes à la convention Denavit-Hartenberg. L'image de droite montre le paramètre supplémentaire Denavit-Hartenberg d3 . Noter: a1, a3, d4 et d6 doivent être >= 0 a2 doit être > 0 (> g_fSMC_CNC_EPS ) d1 doit être <= 0 Transformation Denavit-Hartenberg des articulations Décalage de joint (sigma_i) Décalage du levier (d_i) Longueur du levier (a_i) Rotation du levier (alpha_i) 1 0° d1 a_1 -90° 2 90° 0 a_2 0° 3 0° d3 a_3 90° 4 0° d4 0 90° 5 0° 0 0 -90° 6 0° d6 0 0° " }, 
{ "title" : "La programmation ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_9cf41a3c6a5fb376c0a8640e005461c1", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Robot articulé 6 axes \/ La programmation ", 
"snippet" : "La position du centre de l'outil est contrôlée par X, Y et Z. Les unités de X, Y et Z sont les mêmes que celles utilisées pour les paramètres a_i et d_i (par exemple : mm). L'orientation est contrôlée en degrés avec A (lacet), B (tangage) et C (roulis)....", 
"body" : "La position du centre de l'outil est contrôlée par X, Y et Z. Les unités de X, Y et Z sont les mêmes que celles utilisées pour les paramètres a_i et d_i (par exemple : mm). L'orientation est contrôlée en degrés avec A (lacet), B (tangage) et C (roulis). " }, 
{ "title" : "Enveloppe pour les blocs fonctionnels de transformation cinématique du SM3_Transformation bibliothèque ", 
"url" : "_sm_wrapper_kinematic_fbs.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Transformations cinématiques \/ Enveloppe pour les blocs fonctionnels de transformation cinématique du SM3_Transformation bibliothèque ", 
"snippet" : "Le SMC_Trafo_Wrapper et SMC_Trafof_Wrapper les blocs de fonction vous permettent d'utiliser la cinématique dans SM3_Transformation bibliothèque pour les applications CNC. Pour plus d'informations sur la cinématique du SM3_Transformation bibliothèque, consultez les rubriques suivantes : CinématiqueIl...", 
"body" : "Le SMC_Trafo_Wrapper et SMC_Trafof_Wrapper les blocs de fonction vous permettent d'utiliser la cinématique dans SM3_Transformation bibliothèque pour les applications CNC. Pour plus d'informations sur la cinématique du SM3_Transformation bibliothèque, consultez les rubriques suivantes : CinématiqueIl est possible d'utiliser n'importe quelle transformation qui implémente le MC_KIN_REF_SM3 interface. De plus, des combinaisons de « cinématique de position » et de « cinématique d'orientation Pour plus d'informations, consultez les rubriques suivantes : Combinaison de cinématiques de position et d'orientation" }, 
{ "title" : "Langage CNC selon DIN 66025 ", 
"url" : "_sm_struct_reference_programming_din66025.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Principes de base DIN 66025 ", 
"url" : "_sm_cnc_din66025_basics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Principes de base DIN 66025 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Structure d'un programme DIN 66025 ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_c348b29fedfe7b9ec0a86463427bc61d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Principes de base DIN 66025 \/ Structure d'un programme DIN 66025 ", 
"snippet" : "Le programme DIN 66025 se compose de blocs de mouvement individuels. Le numéro de bloc est situé au début de chaque bloc. ['%' <Programmname>] <Satz>{<Satz>} Les blocs peuvent être structurés comme suit : N<block number> G<expression> <G code words> N<block number> <G code words> (les G<expression> ...", 
"body" : "Le programme DIN 66025 se compose de blocs de mouvement individuels. Le numéro de bloc est situé au début de chaque bloc. ['%' <Programmname>]\n<Satz>{<Satz>} Les blocs peuvent être structurés comme suit : N<block number> G<expression> <G code words> N<block number> <G code words> (les G<expression> du bloc précédent s'appliquent) N<block number> M<expression> <G code words> N<block number> <subroutine name> ( <ActualParamList> ) Structures de blocs supplémentaires pour les sous-programmes : SUBPROGRAM <Name> {<FormalParamList>} <RESTORE_OPT> N<block number> RETURN END_SUBPROGRAM Exemple Chemin à partir de deux lignes et d'un arc, suivi d'un appel de sous-programme % MyProgram\nN10 G01 X100 Y100 E100 F100 E-200\nN20 G01 Z40 F20\nN30 G03 X-100 R200 F100\nN40 SubPrg{5} " }, 
{ "title" : "Syntaxe ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_section-idm4580346248046432600861986014", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Principes de base DIN 66025 \/ Syntaxe ", 
"snippet" : "['%' <nom du programme>] En-tête en option Commence par %, suivi du nom du programme séparé par un Espacer ou Languette <bloc> Le bloc est traité mot par mot de droite à gauche. \/ Suppression de pas Si un bloc commence par \/ et le CNC Suppression de pas commande est sélectionnée, le bloc n'est pas e...", 
"body" : "['%' <nom du programme>] En-tête en option Commence par %, suivi du nom du programme séparé par un Espacer ou Languette <bloc> Le bloc est traité mot par mot de droite à gauche. \/ Suppression de pas Si un bloc commence par \/ et le CNC Suppression de pas commande est sélectionnée, le bloc n'est pas exécuté. N<numéro de bloc> Le numéro de bloc est utilisé comme marqueur pour définir les cibles de saut. Exemple: N01 G<expression> Commande de voyage Si aucune commande de déplacement n'est spécifiée dans un bloc, la commande de déplacement du bloc précédent est complétée automatiquement. Les majuscules et les minuscules sont ignorées. Les zéros non significatifs sont ignorés. Par conséquent, G01 = g1 s'applique Correspond à un élément de chemin ou à un objet de chemin Exemple: G1 (linéaire), G2 (arc) La vitesse à laquelle les objets de trajectoire sont interpolés ; correspond en principe à la vitesse de trajectoire, à l'accélération de trajectoire et à la décélération de trajectoire réglées. L'interpolateur s'assure que ces valeurs limites ne sont pas dépassées. <Mot de code G> Les majuscules et les minuscules sont ignorées. mot de code G Il s'agit d'une adresse (par ex. E ) et une expression (par ex. 100 ; ensemble E100 ) Les majuscules et les minuscules sont ignorées. Les zéros non significatifs sont ignorés. Écrit le numéro du mot dans une variable La lettre du mot est le nom de la variable. La commande de déplacement y accède. Tous les nombres peuvent être des valeurs à virgule flottante. Cela ne s'applique pas aux G<expression> commande de voyage, M<expression> fonction M, et H<expression> point de commutation. Les mots d'un bloc sont séparés par un espacer ou languette . <expression> Voir: Expressions() Commenter Les caractères entre parenthèses sont interprétés comme un commentaire. Remarque : Les commentaires peuvent être redéfinis à l'aide des bParenthesesAsComments saisir ( FB SMC_ReadNCFile2 ) . Interpolation entre deux blocs consécutifs La vitesse lors de la transition de deux objets adjacents est déterminée par les règles suivantes : Si l'un des deux objets est un positionnement de G0 , alors la vitesse de transition = 0. Si l'angle entre les tangentes des deux éléments de trajectoire à la transition est supérieur à la tolérance d'angle, alors la vitesse de transition = 0. Sinon, la vitesse de transition est la vitesse la moins spécifiée des deux éléments de trajet. En règle générale, la commande de déplacement est responsable d'une interpolation de la position cible de la dernière commande de déplacement vers la position cible, qui a été spécifiée par la commande de déplacement actuelle, à exécuter. La première commande de déplacement démarre à la position qui a été définie dans le décodeur ou l'éditeur CNC. Si cette position n'est pas définie, alors le point de départ est X=0, Y=0, Z=0. " }, 
{ "title" : "Commandes de déplacement et éléments de chemin correspondants ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_48e0dea1edfe7b9ec0a8646321fb969d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Principes de base DIN 66025 \/ Commandes de déplacement et éléments de chemin correspondants ", 
"snippet" : "Commande de voyage La description Élément de chemin G0 Mouvement direct sans opération d'outil ; mouvement linéaire PositionnementG1 Mouvement linéaire avec fonctionnement de l'outil Mouvement linéaireG2 Segment circulaire ou cercle, dans le sens des aiguilles d'une montre ArcG3 Segment circulaire o...", 
"body" : "Commande de voyage La description Élément de chemin G0 Mouvement direct sans opération d'outil ; mouvement linéaire PositionnementG1 Mouvement linéaire avec fonctionnement de l'outil Mouvement linéaireG2 Segment circulaire ou cercle, dans le sens des aiguilles d'une montre ArcG3 Segment circulaire ou cercle, dans le sens inverse des aiguilles d'une montre ArcG4 Temps de séjour Temps de séjourG5 Point d'une spline cardinale 2D SplineG6 Parabole ParaboleG8 Arc ou ellipse elliptique, dans le sens des aiguilles d'une montre EllipseG9 Arc ou ellipse elliptique, dans le sens antihoraire EllipseG10 Point d'une spline cardinale 3D SplineG15 Passer en 2D Mode 3DG16 Passez en 3D en activant le mode 3D avec le vecteur normal I \/ J \/ K à l'avion Mode 3DG17 Passez en 3D en activant le mode 3D dans X \/ Y avion Mode 3DG18 Passez en 3D en activant le mode 3D dans Z \/ X avion Mode 3DG19 Passez en 3D en activant le mode 3D dans Y \/ Z avion Mode 3DG20 Saut conditionnel à L , si K <> 0 SautG31 Supprimer la distance restante avec arrêt du décodage Fonction de sondage (distance restante claire)G36 Écrire la valeur D à variable O Modification des valeurs des variablesG37 Incrémenter la variable O par valeur D Modification des valeurs des variablesG38 Activez la fonction de prétraitement étendue Activation de la fonction de prétraitement étenduG39 Désactiver la fonction de prétraitement étendue Activation de la fonction de prétraitement étenduG40 Fin de la compensation du rayon de l'outil PrétraitementG41 Début de la compensation du rayon de l'outil, à gauche du sens de déplacement PrétraitementG42 Début de la compensation du rayon de l'outil, à droite du sens de déplacement PrétraitementG43 Démarre la correction de la longueur de l'outil PrétraitementG50 Arrondissement\/lissage de la fin des coins PrétraitementG51 Début du lissage des coins PrétraitementG52 Début de l'arrondissement des virages PrétraitementG53 Termine la transformation des coordonnées et réinitialise le système de coordonnées du décodeur à la position d'origine (= système de coordonnées machine) Déplacement, rotation et mise à l'échelle du système de coordonnéesG54 Transformation absolue des coordonnées Déplacement, rotation et mise à l'échelle du système de coordonnéesG55 Transformation relative des coordonnées Déplacement, rotation et mise à l'échelle du système de coordonnéesG56 Définit l'orientation, la position et l'échelle actuelles du DCS comme point de référence Déplacement, rotation et mise à l'échelle du système de coordonnéesG60 Suppression de fin de boucle PrétraitementG61 Début de suppression de boucle PrétraitementG70 Fin du lissage des axes supplémentaires Voir: SMC_SmoothAddAxes PrétraitementG71 Début du lissage des axes supplémentaires Voir: SMC_SmoothAddAxes PrétraitementG75 Synchronisation temporelle avec l'interpolateur Synchronisation temporelle avec l'interpolateurG90 Les coordonnées ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) sont interprétés comme des valeurs absolues. (Ce sont les paramètres par défauts.) ModesG91 Les coordonnées ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) sont interprétées comme des valeurs relatives à la position actuelle. ModesG92 Positionnement par saut PositionnementG98 Les milieux de l'axe ( I \/ J \/ K ) sont interprétés comme des valeurs absolues. ModesG99 Les milieux de l'axe ( I \/ J \/ K ) sont interprétées comme des valeurs relatives à la position de départ. (Ce sont les paramètres par défauts.) Modes" }, 
{ "title" : "Reconnaissance du mot de code G ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_591ac87c61b577fcc0a8640e0070747c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Principes de base DIN 66025 \/ Reconnaissance du mot de code G ", 
"snippet" : "A Position cible de l'axe spline supplémentaire Pour une transformation de coordonnées dans le système de coordonnées du décodeur, le mot contient un angle. B C D Rayon d'outil pour la compensation G40 - G42 Distance de l'outil pour arrondir les angles G50 - G51 Valeur variable G36 \/ G37 E Accélérat...", 
"body" : "A Position cible de l'axe spline supplémentaire Pour une transformation de coordonnées dans le système de coordonnées du décodeur, le mot contient un angle. B C D Rayon d'outil pour la compensation G40 - G42 Distance de l'outil pour arrondir les angles G50 - G51 Valeur variable G36 \/ G37 E Accélération\/décélération de trajectoire maximale en [u\/sec 2 ]. Valeur > 0 : accélération ; valeur < 0 : décélération EF Accélération\/décélération de trajectoire pour G0 mouvement E<axis> Accélération\/décélération individuelle (>0\/<0) du <axis> axe supplémentaire Des axes supplémentaires sont A , B , C , P , Q , U , V , W , et aussi Z en mode 2D. Si ce code G est utilisé, alors le bloc de traitement de chemin SMC_ExtendedVelocityChecks doit être utilisé pour limiter la vitesse. F Vitesse (en [u\/sec]) : « Avance » FF Vitesse pour G0 mouvements F<axis> Vitesse individuelle de l'axe supplémentaire spécifié <axe> Des axes supplémentaires sont A , B , C , P , Q , U , V , W , et aussi Z en mode 2D. Si ce code G est utilisé, alors le bloc de traitement de chemin SMC_ExtendedVelocityChecks doit être utilisé pour limiter la vitesse. G Condition de chemin H Point de commutation (fonction H) Positif : allumer Négatif : éteindre I Coordonnée X du milieu du cercle\/ellipse pour G02 \/ G03 \/ G08 \/ G09 abscisse du sommet de la parabole pour G06 Vecteur normal (X) pour la fonction plan 3D Paramètres d'activation des fonctions de prétraitement étendues pour G38 \/ G39 Mise à l'échelle dans la direction X pour G54 \/ G55 \/ G56 Correction d'outil dans la direction X pour G43 J Coordonnée Y du milieu du cercle\/ellipse pour G02 \/ G03 \/ G08 \/ G09 Coordonnée Y du sommet de la parabole pour G06 Vecteur normal (Y) pour la fonction plan 3D Paramètres d'activation des fonctions de prétraitement étendues pour G38 \/ G39 Mise à l'échelle dans la direction Y pour G54 \/ G55 \/ G56 Correction d'outil dans la direction Y pour G43 K Direction de l'axe de l'ellipse primaire ; mathématiquement : 0° = O , 90° = N , etc. Condition de saut pour G20 Valeur du paramètre dT1 pour la fonction M Coordonnée Z du milieu du cercle pour G02 \/ G03 en mode 3D Vecteur normal (Z) pour la fonction plan 3D Paramètres d'activation des fonctions de prétraitement étendues pour G38 \/ G39 Mise à l'échelle dans la direction Z pour G54 \/ G55 \/ G56 Correction d'outil dans la direction Z pour G43 L Position absolue du commutateur pour la fonction H, mesurée depuis le début de l'élément de trajectoire (si position > 0) ou mesurée depuis la fin de l'élément de trajectoire (si position < 0). Cible de saut pour G20 Valeur du paramètre dT2 pour la fonction M Numéro de l'axe supplémentaire pour G70 et G71 M Option supplémentaire pour les machines ; aussi la fonction M O Position relative du point de commutation avec plage de valeurs [0..1] pour la fonction H Valeur variable G36 \/ G37 . Structure de données pour les paramètres d'une fonction M P Position cible de l'axe linéaire supplémentaire P P<axis><period> Configuration des axes modulo Si Period = 0 s'applique (exemple : PA0 ), alors le comportement de l'axe est linéaire. PROBE Active la fonction de sondage (distance restante libre) pour le mouvement Q Position cible de l'axe linéaire supplémentaire Q R Rayon de cercle alternatif à I, J avec G02 \/ G03 Rapport de longueur de l'axe secondaire\/primaire elliptique dans la plage de valeurs de [0..1] avec G08 \/ G09 S Profil S pour axes linéaires Positif : allumer Négatif : éteindre Axe 3 : Z, si Z est en mode 2D 7 :P 8 : Q 9 : U 10 : V 11 : W T Paramètre spécifique à la commande U Position cible de l'axe linéaire supplémentaire U V Position cible de l'axe linéaire supplémentaire V W Position cible de l'axe linéaire supplémentaire W X Coordonnée X de la position cible Y Coordonnée Y de la position cible Z Coordonnée Z de la position cible " }, 
{ "title" : "Mode 3D ", 
"url" : "_sm_cnc_din66025_3dmode.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Mode 3D ", 
"snippet" : "code G : G15 , G16 , G17 , G18 , G19 Code G La description G15 Passe en mode 2D. Valable pour tous les autres éléments G16 Active la fonction de plan 3D dans le plan normal avec le vecteur normal I\/J\/K et passe en mode 3D Valable pour tous les autres éléments G17 Active la fonction de plan 3D dans l...", 
"body" : "code G : G15 , G16 , G17 , G18 , G19 Code G La description G15 Passe en mode 2D. Valable pour tous les autres éléments G16 Active la fonction de plan 3D dans le plan normal avec le vecteur normal I\/J\/K et passe en mode 3D Valable pour tous les autres éléments G17 Active la fonction de plan 3D dans le plan X\/Y et passe en mode 3D Valable pour tous les autres éléments G18 Active la fonction de plan 3D dans le plan X\/Z. Passe en mode 3D Valable pour tous les autres éléments G19 Active la fonction de plan 3D dans le plan Y\/Z. Passe en mode 3D Valable pour tous les autres éléments Les éléments de trajectoire tridimensionnels sont utilisés en mode 3D. Dans l'espace 3D, vous pouvez définir des points et vous connecter avec des splines 3D. Vous pouvez également insérer des arcs dans n'importe quel plan spatial. Contrairement aux éléments de trajectoire 2.5D qui utilisent uniquement les coordonnées X\/Y, la vitesse et l'accélération de trajectoire font référence au mouvement dans les coordonnées X\/Y\/Z. L'axe Z est traité de la même manière que l'axe X et l'axe Y. Par conséquent, chaque mouvement peut être mis en œuvre dans la direction Z. Mode 3D Le mode ne prend pas en charge les ellipses, les paraboles et les splines 2D. Un message d'erreur est émis. SMC_CheckVelocities vérifie le composant Z SMC_ToolCorr et SMC_AvoidLoop générer des erreurs Principales différences entre 2.5D et 3D Principales différences entre 2.5D et 3D Vitesse et accélération (F\/E) : En 3D : Définit la vitesse et l'accélération de la trajectoire. En 2.5D : Définit la vitesse et l'accélération de la projection de la trajectoire sur le plan X\/Y. Splines 3D : avec un composant Z lissé sans à-coups (G10) 2.5D : dans la direction Z non lissé (G5) Arc 3D : Peut être défini dans tous les plans possibles de l'espace (G2\/G3 avec G16\/G17\/G18\/G19) 2.5D : limité au plan X\/Y (G2\/G3) Exemple Comparaison de vitesse de 3D et 2.5D N0 G1 X1 Z100 F1 La 3D nécessite un mouvement d'environ 100 secondes, car la longueur de l'objet contient la composante Z. Longueur = (1 2 + 100 2 ) 1\/2 À une vitesse de 1, environ 100 secondes sont nécessaires. La vitesse de la composante Z est d'environ 1. En 2.5D, le mouvement nécessite environ 1 seconde pour le calcul ou la longueur = 1. La vitesse dans la direction Z est d'environ 100. " }, 
{ "title" : "Activation de la fonction de prétraitement étendu ", 
"url" : "_sm_cnc_din66025_activating_extended_preprocessor_functions.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Activation de la fonction de prétraitement étendu ", 
"snippet" : "code G : G38 , G39 Fonction : Ces commandes activent et désactivent la fonction de prétraitement étendu. Syntaxe G38 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> G39 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> Mot de code G La description <bit> Valeur comprise entre 0 et 31. L'affecta...", 
"body" : "code G : G38 , G39 Fonction : Ces commandes activent et désactivent la fonction de prétraitement étendu. Syntaxe G38 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value>\nG39 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> Mot de code G La description <bit> Valeur comprise entre 0 et 31. L'affectation des bits aux fonctions est laissée au développeur. Certains blocs fonctionnels, tels que SMC_SmoothMerge ou SMC_SmoothBSpline , avoir une entrée wFeatureBit (valeur initiale 0) qui définit le bit à utiliser. Le bit est enregistré dans la variable SMC_GeoInfo.dwFeatureFlags . <ValeurParam1> De n'importe quelle valeur. Les valeurs sont enregistrées dans le tableau SMC_GeoInfo.aAdditionalParams : ARRAY[0..MAX_ADDITIONAL_PARAMS-1] OF LREAL . <ValeurParam1> <ValeurParam1> " }, 
{ "title" : "Déplacement, rotation et mise à l'échelle du système de coordonnées ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Déplacement, rotation et mise à l'échelle du système de coordonnées ", 
"snippet" : "code G : G53 , G54 , G55 , G56 Fonction : Les commandes du code G G54 , G55 , et G56 décaler, faire pivoter et mettre à l'échelle le système de coordonnées du décodeur utilisé en interne par le bloc fonctionnel interpréteur SMC_NCInterpreter . Les transformations de coordonnées sont calculées pour t...", 
"body" : "code G : G53 , G54 , G55 , G56 Fonction : Les commandes du code G G54 , G55 , et G56 décaler, faire pivoter et mettre à l'échelle le système de coordonnées du décodeur utilisé en interne par le bloc fonctionnel interpréteur SMC_NCInterpreter . Les transformations de coordonnées sont calculées pour tous les éléments du chemin lors de l'exécution du SMC_NCInterpreter instance de bloc fonctionnel. La commande du code G G53 réinitialise le système de coordonnées du décodeur à la position, à l'orientation et à l'échelle d'origine (correspondant au système de coordonnées de la machine). Vous décalez et faites pivoter le système de coordonnées du décodeur afin de réutiliser le code G des mêmes éléments de chemin qui ne diffèrent que par la position, l'orientation ou l'échelle. La rotation et la mise à l'échelle du système de coordonnées du décodeur ne fonctionnent que dans l'interpréteur en ligne (pas dans l'éditeur CNC). " }, 
{ "title" : "Systèmes de coordonnées MCS et DCS ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_f644d63d98ef7863c0a864636e4c0bd6", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Déplacement, rotation et mise à l'échelle du système de coordonnées \/ Systèmes de coordonnées MCS et DCS ", 
"snippet" : "Le système de coordonnées machine (MCS) est défini par la cinématique appliquée qui détermine sa position et son orientation. Le système de coordonnées du décodeur (DCS) est géré par l'interpréteur ( SMC_NCInterpreter instance de bloc fonction). Toutes les informations de coordonnées pour les comman...", 
"body" : "Le système de coordonnées machine (MCS) est défini par la cinématique appliquée qui détermine sa position et son orientation. Le système de coordonnées du décodeur (DCS) est géré par l'interpréteur ( SMC_NCInterpreter instance de bloc fonction). Toutes les informations de coordonnées pour les commandes de mouvement sont interprétées dans ce système de coordonnées. Cela affecte la position cible d'un mouvement ( X\/Y\/Z ), ainsi qu'un milieu d'arc ( I\/J\/K ) ou un avion réglé avec G15\/G16\/G17\/G18\/G19 . Le DCS est programmé avec les commandes G53\/G54\/G55\/G56 . Vous pouvez faire pivoter, déplacer et mettre à l'échelle le DCS par rapport au système de coordonnées de la machine, et donc adapter la position, l'orientation et la mise à l'échelle dans le fichier de code G autant de fois que vous le souhaitez. Vous programmez les éléments de chemin relatifs au DCS. Par exemple, cela peut être un avantage pour les mêmes éléments de chemin dans différentes positions et orientations. L'image suivante montre un décalage (à gauche) et un décalage avec rotation (à droite). L'interprète obtient les informations de son eOriConv entrée sur la question de savoir si A\/B\/C sont traitées comme des axes supplémentaires ou comme des valeurs d'orientation. Les coordonnées des éléments du chemin sont transformées en conséquence. Le bloc fonction interpréteur gère donc un système de coordonnées actif. Initialement, si le DCS n'est ni décalé, ni tourné, ni mis à l'échelle, alors le DCS correspond au MCS. Les positions de départ et cible ainsi que le plan des arcs sont spécifiés dans les objets GeoInfo générés toujours par rapport au MCS. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ADDAXES Aucune convention d'orientation n'est spécifiée. Le contenu du mot de code G A\/B\/C est interprété comme une valeur de décalage. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ZYZ La convention d'orientation est la convention Y standard (Z, Y', Z''). Le contenu du mot de code G A\/B\/C est interprété comme une valeur d'angle. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ZYX La convention d'orientation est la convention lacet-tangage-roulis (Z, Y', X''). Le contenu du mot de code G A\/B\/C est interprété comme une valeur d'angle. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.XYZ La convention d'orientation est la convention XYZ (X, Y', Z''). Le contenu du mot de code G A\/B\/C est interprété comme une valeur d'angle. " }, 
{ "title" : "Commandes G53, G54, G55, G56 ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_02170a739e1947dec0a864637ea0fc00", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Déplacement, rotation et mise à l'échelle du système de coordonnées \/ Commandes G53, G54, G55, G56 ", 
"snippet" : "Code G La description G53 Réinitialise le système de coordonnées du décodeur Le DCS est réinitialisé à la même position et orientation que le MCS. G54 Absolu décalage, rotation et mise à l'échelle du DCS Les valeurs se réfèrent au MCS. Si une convention d'orientation est pas spécifié ( SMC_NCInterpr...", 
"body" : "Code G La description G53 Réinitialise le système de coordonnées du décodeur Le DCS est réinitialisé à la même position et orientation que le MCS. G54 Absolu décalage, rotation et mise à l'échelle du DCS Les valeurs se réfèrent au MCS. Si une convention d'orientation est pas spécifié ( SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ADDAXES ), alors la commande entraîne un décalage uniquement le long des axes X\/Y\/Z\/A\/B\/C et sur tous les axes linéaires supplémentaires P\/Q\/U\/V\/W. Par conséquent, un décalage peut également être programmé le long des axes A\/B\/C. Si une convention d'orientation est spécifiée, alors la commande entraîne un décalage également le long des axes X\/Y\/Z et le long des axes linéaires supplémentaires P\/Q\/U\/V\/W. De plus, les axes de coordonnées sont tournés. Ensuite, la convention d'orientation fournit l'ordre de rotation et les mots de code G A\/B\/C donnent les angles de rotation en degrés. Remarque : Le décodeur peut effectuer des rotations directionnelles dans une plage de -180° à +180°. Si vous spécifiez un angle en dehors de cette plage, le décodeur convertit la valeur afin qu'elle se situe dans la plage exécutable. Ce n'est qu'alors que le décodeur fait pivoter les axes de coordonnées. Par exemple, une rotation de -10° est effectuée pour un angle de 350°. G55 Relatif décalage, rotation et mise à l'échelle du DCS vers sa position et son orientation actuelles Par conséquent, les valeurs sont relatives à l'origine DCS actuelle et interprétées dans la direction des axes de coordonnées actuels du DCS. Un décalage\/une rotation supplémentaire est ajouté par rapport au système de coordonnées machine. Si une convention d'orientation est ne pas spécifié, la commande entraîne un décalage relatif uniquement le long des axes X\/Y\/Z\/A\/B\/C et sur tous les axes linéaires supplémentaires P\/Q\/U\/V\/W. Par conséquent, un décalage peut également être programmé le long des axes A\/B\/C. Si une convention d'orientation est spécifiée, alors la commande entraîne un décalage relatif également le long des axes X\/Y\/Z et le long des axes linéaires supplémentaires P\/Q\/U\/V\/W. Mais surtout, les axes de coordonnées sont davantage tournés. Ensuite, la convention d'orientation fournit l'ordre de rotation et les mots de code G A\/B\/C donnent les angles de rotation. G56 Réinitialise le point de référence du système de coordonnées du décodeur L'orientation, la position et l'échelle actuelles du DCS sont définies comme référence. Astuce : Si le point de référence est X0 Y0 Z0 A0 B0 C0, alors le DCS est réglé de manière identique à la position et à l'orientation actuelles. Syntaxe G53\nG54 X Y Z A B C I J K P Q U V W\nG55 X Y Z A B C I J K P Q U V W\nG56 X Y Z A B C I J K P Q U V W Mot de code G La description X Y Z Valeur autour de laquelle le système de coordonnées du décodeur est décalé A B C Si l'entrée est eOriConf = SMC_ORI_CONVENTION.ADDAXES à SMC_NCInterpreter , la valeur est alors donnée en unités dans quelle mesure l'axe supplémentaire respectif est décalé. Par conséquent, le paramètre définit le décalage pour chaque axe du système de coordonnées du décodeur par rapport au système de coordonnées de la machine. Si la eOriConf l'entrée est SMC_ORI_CONVENTION.ZYZ , SMC_ORI_CONVENTION.ZYX , ou SMC_ORI_CONVENTION.XYZ à SMC_NCInterpreter , alors une convention d'orientation est fournie. Dans ce cas, les valeurs indiquées ici sont automatiquement interprétées en degrés et déterminent la rotation des axes du système de coordonnées du décodeur par rapport au système de coordonnées de la machine. Par conséquent, vous définissez la rotation des axes principaux selon la convention d'orientation. Remarque : Lors de la programmation de la rotation DCS, les angles de rotation doivent toujours être spécifiés dans A\/B\/C pour les trois axes. Un angle de rotation manquant provoque une erreur lors du décodage ( SMC_DEC_DCS_NOT_ALL_OF_ABC_GIVEN ). I Mise à l'échelle dans la direction X Exemple: 10 pour étendre d'un facteur 10 J Mise à l'échelle dans la direction Oui Exemple: 10 pour étendre d'un facteur 10 K Mise à l'échelle dans la direction Z Exemple: 10 pour étendre d'un facteur 10 P Q U V W Valeur autour de laquelle l'axe supplémentaire du système de coordonnées du décodeur est décalé " }, 
{ "title" : "Déplacement du DCS ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_4557d91f9e1947dec0a864630016f87d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Déplacement, rotation et mise à l'échelle du système de coordonnées \/ Déplacement du DCS ", 
"snippet" : "Met le eOriConv entrée du SMC_NCInterpreter instance de bloc fonctionnel à SMC_ORI_CONVENTION.ADDAXES . Le DCS peut être déplacé. Une rotation n'est pas possible. Programmer la trajectoire CNC. Tout d'abord, spécifiez le décalage de position du DCS. Exemple: G54 X10 Y10 Z10 A30 B30 C30 Les axes X\/Y\/...", 
"body" : "Met le eOriConv entrée du SMC_NCInterpreter instance de bloc fonctionnel à SMC_ORI_CONVENTION.ADDAXES . Le DCS peut être déplacé. Une rotation n'est pas possible. Programmer la trajectoire CNC. Tout d'abord, spécifiez le décalage de position du DCS. Exemple: G54 X10 Y10 Z10 A30 B30 C30 Les axes X\/Y\/Z\/A\/B\/C du DCS sont décalés. Exemple Décalage absolu N10 G0 X100 Y100 F100\nN20 G54 X50 Y50 (Offset auf 50\/50)\nN30 G1 X0 Y0 (Fahrt nach 50\/50)\nN40 G54 X100 Y100 (Offset auf 100\/100)\nN50 G1 X0 Y0 (Fahrt nach 100\/100)\nN60 G53 (Offset auf 0)\nN70 G1 X0 Y0 (Fahrt nach 0\/0) Position actuelle comme décalage N0 G0 X100 Y100 F100\nN10 G56 X0 Y0 (Aktuelle Position 100\/100 wird 0\/0)\nN20 G1 X10 (Fahrt nach 110\/100)\nN30 G56 X20 Y0 (Aktuelle Position 110\/100 wird 20\/0)\nN40 G1 X0 (Fahrt nach 90\/100) Adapter l'offset par valeur N0 G54 X10 Y20 Z30 U7 (Offset: X=10, Y=20, Z=30, U=7)\nN10 G55 X-10 U7 (Offset: X=0, Y=20, Z=30, U=14) Mêmes éléments de chemin dans deux positions N05 G17\nN10 G54 X10 Y10 Z10\nN20 G01 X6.574 Y-10 Z-1.961 I8.287 J-0.000\nN30 G02 X-0.480 Y-10 Z0.008 I-3.527 J4.988E-05\nN040 G02 X3.418 Y-9.806 Z4.482 I1.949 J0.097\nN50 G55 X10 Y10 Z10\nN60 G01 X6.574 Y-10 Z-1.961 I8.287 J-0.000\nN70 G02 X-0.480 Y-10 Z0.008 I-3.527 J4.988E-05\nN80 G02 X3.418 Y-9.806 Z4.482 I1.949 J0.097 " }, 
{ "title" : "Déplacement et rotation du DCS ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_df6926f62eedd311c0a8646378b457e7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Déplacement, rotation et mise à l'échelle du système de coordonnées \/ Déplacement et rotation du DCS ", 
"snippet" : "Met le eOriConv entrée du SMC_NCInterpreter instance de bloc fonction à la convention d'orientation souhaitée (par exemple, SMC_ORI_CONVENTION.ZYZ ). La convention d'orientation et l'ordre de rotation des axes X\/Y\/Z du DCS sont programmés. Pour SMC_ORI_CONVENTION.ZYZ , l'ordre de rotation est ZY'Z''...", 
"body" : "Met le eOriConv entrée du SMC_NCInterpreter instance de bloc fonction à la convention d'orientation souhaitée (par exemple, SMC_ORI_CONVENTION.ZYZ ). La convention d'orientation et l'ordre de rotation des axes X\/Y\/Z du DCS sont programmés. Pour SMC_ORI_CONVENTION.ZYZ , l'ordre de rotation est ZY'Z'' et correspond à la convention Y standard. Remarque : tant que l'entrée eOriConv contient une convention d'orientation et non la valeur SMC_ORI_CONVENTION.ADDAXES , les valeurs des mots A\/B\/C sont interprétées comme des valeurs d'angle pour la rotation pour les commandes du code G G54\/G55\/G56 . Programmer la trajectoire CNC. Tout d'abord, spécifiez le décalage de position et la rotation du DCS. Exemple: G54 X10 Y10 Z10 A30 B30 C30 Les valeurs des mots A\/B\/C fournir le sens de rotation et l'angle en degrés. Le système de coordonnées est pivoté en conséquence. Les valeurs des mots X\/Y\/Z définir le décalage. Remarque : Lors de la programmation de la rotation DCS, les angles de rotation doivent toujours être spécifiés dans A\/B\/C pour les trois axes. Un angle de rotation manquant provoque une erreur lors du décodage ( SMC_DEC_DCS_NOT_ALL_OF_ABC_GIVEN ). Si la eOriConv entrée du SMC_NCInterpreter l'instance de bloc fonction contient la valeur SMC_ORI_CONVENTION.ADDAXES , la rotation du DCS n'est alors pas possible. Les valeurs dans G54\/G55\/G56 sont interprétées comme des valeurs d’axe de spline supplémentaires. Le déplacement est possible. Exemples La convention d'orientation a été définie dans les exemples comme la convention Y standard ( eOriConv = SMC_ORI_CONVENTION.ZYZ ). En général pour G54 : X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W fournit une valeur absolue dans le MCS. G55 : X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W fournit une valeur relative dans le DCS. G56 : X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W fournit une nouvelle valeur absolue dans le DCS. Orientation absolue avec G54 N01 G54 X10 A30 B0 C0 G54 entraîne un décalage et une rotation. La position et l'orientation sont fournies de manière absolue au MCS. Orientation relative avec G55 N01 G54 X10 A30 B0 C0 (Bezieht sich auf MCS)\nN02 G55 Y10 A0 B30 C0 (Bezieht sich auf das in 01 definierte DCS) G54 entraîne un décalage de 10 unités dans la direction X et une rotation de 30° autour de l'axe Z absolu par rapport au MCS. Dans le bloc 02, le DCS est décalé de 10 unités supplémentaires dans la direction de l'axe Y tourné et ensuite tourné de 30° supplémentaires autour de l'axe Y tourné. Par conséquent, la transformation dans le bloc 02 est relative à la transformation dans le bloc 01. Référencement par rapport à l'orientation actuelle avec G56 N01 G01 X10 A10 B90 C10 (Orientierung ist A=10°, B=90°, C=10°)\nN02 G56 A0 B0 C0 (DCS wird auf X=10, A=10°, B=90°, C=10° gesetzt) G56 entraîne la mise en référence de l'orientation actuelle du DCS (programmée au bloc 01 dans l'exemple). Exemple : Arc N0 G17\nN0 G54 A0 B90 C0 Le plan circulaire sélectionné est interprété par rapport au DCS. Dans l'exemple, le plan X\/Y est sélectionné avec G17 puis le DCS est tourné de 90° autour de l'axe Y. Ensuite, le plan sélectionné dans le DCS est le plan X\/Y comme précédemment. Cela correspond à celui du plan X\/Z dans le MCS. Avec G17 , le plan X\/Y est sélectionné. Ensuite, le DCS est tourné de 90°. Cela entraîne l'activation du plan X\/Y dans le DCS comme auparavant. Cela correspond au plan X\/Y dans le MCS. En mode 2.5D ( G15 ), la rotation est autorisée uniquement autour de l'axe Z. La rotation autour d'un autre axe provoque une erreur qui est émise par le décodeur ( SMC_DEC_DCS_2D_NOT_IN_XY_PLANE ). Par conséquent, le plan X\/Y du MCS reste toujours défini en mode 2,5D. " }, 
{ "title" : "Mise à l'échelle du système de coordonnées ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_52b3763cadb811e79ffc84f8a2d3d270", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Déplacement, rotation et mise à l'échelle du système de coordonnées \/ Mise à l'échelle du système de coordonnées ", 
"snippet" : "Si une rotation est programmée après une mise à l'échelle inégale, alors un écrêtage peut se produire. Dans ce cas, l'erreur SMC_DEC_ROTATION_AFFECTS_SCALING n'est pas délivré. Les trois facteurs d'échelle doivent être spécifiés ou aucun. Mise à l'échelle absolue Syntaxe: G54 I<i> J<j> K<k> Un systè...", 
"body" : "Si une rotation est programmée après une mise à l'échelle inégale, alors un écrêtage peut se produire. Dans ce cas, l'erreur SMC_DEC_ROTATION_AFFECTS_SCALING n'est pas délivré. Les trois facteurs d'échelle doivent être spécifiés ou aucun. Mise à l'échelle absolue Syntaxe: G54 I<i> J<j> K<k> Un système de coordonnées peut être étiré ou compressé dans les trois directions spatiales X\/Y\/Z indépendamment les uns des autres. Vous pouvez spécifier un facteur pour chaque direction. Spécifiez le facteur d'échelle pour X dans I, Y dans J et Z dans K. Un facteur d'échelle > 1 s'étend. Un facteur d'échelle < 1 compresse. Extension de 10x : N01 G01 X10\nN02 G54 A90 B0 C0 I10 J1 K1\nN03 G01 X10 Y20\nN04 G01 X5 Y10 Tous les points cibles sont étendus de 10x dans la direction de l'axe X pivoté. Le code suivant génère le même chemin : N01 G01 X10\nN02 G01 X-20 Y100\nN03 G01 X-10 Y50. Si ni I ni J ni K ne sont spécifiés, la valeur précédemment définie reste inchangée : N01 G54 I10 J1 K1\nN02 G54 X1\nN03 G01 X10 Le même chemin est réalisé avec le code suivant : N01 G01 X101 Mise à l'échelle relative Syntaxe: G55 I<i> J<j> K<k> Un facteur d'échelle > 1 s'étend. Un facteur d'échelle < 1 compresse. Les facteurs d'échelle sont multipliés. Extension de 100x : N01 G54 I10 J1 K1\nN02 G55 I10 J1 K1\nN03 G01 X10 Y20\nN04 G01 X5 Y10 Le code suivant donne la même mise à l'échelle : N01 G55 I100 J1 K1 Mise à l'échelle circulaire La mise à l'échelle d'un arc n'est valide que si l'élément est toujours un arc (pas une ellipse) après la mise à l'échelle. Résultat des chemins valides : Lorsque les trois facteurs d'échelle ont la même valeur Lorsque le plan circulaire est l'un des plans principaux du DCS et que les deux facteurs d'échelle correspondants sont les mêmes valeurs " }, 
{ "title" : "Symétrie du système de coordonnées ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_adba25b098ef7863c0a8646324d700b4", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Déplacement, rotation et mise à l'échelle du système de coordonnées \/ Symétrie du système de coordonnées ", 
"snippet" : "Une mise à l'échelle absolue avec des facteurs d'échelle négatifs dans I , J , ou K entraîne la mise en miroir du système de coordonnées courant. Facteur d'échelle négatif G54 A30 B0 C0 I-1 J1 K1...", 
"body" : "Une mise à l'échelle absolue avec des facteurs d'échelle négatifs dans I , J , ou K entraîne la mise en miroir du système de coordonnées courant. Facteur d'échelle négatif G54 A30 B0 C0 I-1 J1 K1 " }, 
{ "title" : "Modes ", 
"url" : "_sm_cnc_din66025_modi.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Modes ", 
"snippet" : "Fonction : Ces commandes déterminent si les coordonnées et les points médians des axes sont interprétés comme des valeurs absolues ou des coordonnées relatives. Code G La description G90 Les coordonnées ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) sont interprétés comme des valeurs absolues. (Ce so...", 
"body" : "Fonction : Ces commandes déterminent si les coordonnées et les points médians des axes sont interprétés comme des valeurs absolues ou des coordonnées relatives. Code G La description G90 Les coordonnées ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) sont interprétés comme des valeurs absolues. (Ce sont les paramètres par défauts.) G91 Les coordonnées ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) sont interprétées comme des valeurs relatives à la position actuelle. G98 Les milieux de l'axe ( I \/ J \/ K ) sont interprétés comme des valeurs absolues. G99 Les milieux de l'axe ( I \/ J \/ K ) sont interprétées comme des valeurs relatives à la position de départ. (Ce sont les paramètres par défauts.) Syntaxe G90\nG91\nG98\nG99 Exemples Valeur de coordonnée en valeur absolue L'interpolateur passe à 10\/10 puis à 100\/10. Les coordonnées sont interprétées comme des valeurs absolues. N0 G90\nN10 G1 X10 Y10 F100 (Startposition)\nN20 G1 X100 (Nächste Position) Valeur de coordonnée comme valeur relative L'interpolateur passe à 10\/10 puis à 110\/10. Les coordonnées sont interprétées comme des valeurs relatives. N0 G91\nN10 G1 X10 Y10 F100\nN20 G1 X100 Valeur de coordonnée en valeur absolue en I\/J\/K Le milieu du demi-cercle est à 150\/0. Les coordonnées sont interprétées comme des valeurs absolues. N00 G98\nN10 G92 X100 Y0 (Startposition)\nN20 G2 X200 Y0 I150 J0 F100 Valeur de coordonnée comme valeur relative dans I\/J\/K Le milieu du demi-cercle est à 150\/0. Les coordonnées sont interprétées comme des valeurs relatives. N00 G99\nN10 G92 X100 Y0 (Startposition)\nN20 G2 X200 Y0 I50 J0 F100 Pour plus d'informations, consultez : Configuration d'axes supplémentaires uniques en tant qu'axes modulo (PA\/PB\/…)" }, 
{ "title" : "Temps de séjour ", 
"url" : "_sm_cnc_din66025_delay.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Temps de séjour ", 
"snippet" : "code G : G4 Fonction : La commande fait que l'interpolateur reste à la position actuelle pendant un temps spécifique. Exemple Temps de séjour N0 G4 T1 L'interpolateur marque une pause d'une seconde....", 
"body" : "code G : G4 Fonction : La commande fait que l'interpolateur reste à la position actuelle pendant un temps spécifique. Exemple Temps de séjour N0 G4 T1 L'interpolateur marque une pause d'une seconde. " }, 
{ "title" : "Point de commutation (fonction H) ", 
"url" : "_sm_cnc_din66025_hfunction.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Point de commutation (fonction H) ", 
"snippet" : "Fonction : La fonctionnalité de point de commutation ou la fonction H active des commutateurs binaires dépendants du chemin. Un nombre maximum de trois points de commutation ( MAX_SWITCHES ) peut être traité pour chaque élément de chemin. Syntaxe [G-Befehl] H O\/L Tout d'abord, le numéro de point de ...", 
"body" : "Fonction : La fonctionnalité de point de commutation ou la fonction H active des commutateurs binaires dépendants du chemin. Un nombre maximum de trois points de commutation ( MAX_SWITCHES ) peut être traité pour chaque élément de chemin. Syntaxe [G-Befehl] H O\/L Tout d'abord, le numéro de point de commutation H<nombre> est défini, puis la position du point de commutation dans l'élément de chemin est définie comme absolue (mot L<position>) ou relative (mot O<position>). Mot de code G La description H{-}<nombre> Numéro de la fonction H Si le nombre H est positif, la fonction de commutation respective est activée. Si le nombre H est négatif, la fonction de commutation est désactivée. Le nombre H est différent de zéro et compris entre -32768 et 32767. O<position> Position relative [0…1] dans l'élément de trajectoire 0 : Début de l'élément 1 : Fin L<position> L>0 : Distance au point de départ L<0 : Distance au point final Représentation graphique Dans l'éditeur graphique, vous pouvez utiliser la souris pour déplacer les points de commutation le long du chemin. Lorsque la souris est déplacée sur la fonction H, une info-bulle s'affiche avec le numéro H de la fonction H. Effet sur le SMC_Interpolator bloc fonctionnel L'interpolateur envoie le dernier nombre H commuté au iLastSwitch sortir. iLastSwitch est positif lorsque la fonction H est activée. Les dwSwitches la sortie est un masque de bits. Numéro de bit i indique si la fonction H (i+1) est actuellement réglée ou non. Si le nombre H est compris entre 1 et 32, alors le bit correspondant est positionné dans l'interpolateur dwSwitches sortir. Une valeur négative comprise entre -1 et -32 réinitialise le bit. Les iLastSwitch la sortie a le numéro du dernier point de commutation exécuté, même si la valeur est en dehors de la plage de -32 à 32. Exemples Coupure point de commutation 2 avec position par rapport à l'élément Le point de commutation 2 est désactivé à la position X=40\/Y=25 après le premier quart de l'élément. N90 G1 X20 Y20\nN100 G1 X100 Y40 H-2 O0.25 Allumer et éteindre le point de commutation 2 avec position par rapport au point de départ et d'arrivée Le point de commutation 2 est activé à la position X=40, c'est-à-dire 20 unités après le point de départ de l'élément de trajectoire. Le point de commutation 2 est désactivé à la position X=90, soit 10 unités avant le point final. N90 G1 X20\nN100 G1 X100 H2 L20 H-2 L-10 " }, 
{ "title" : "Fonction M ", 
"url" : "_sm_cnc_din66025_mfunction.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Fonction M ", 
"snippet" : "Fonction : Les fonctions M ou les fonctions supplémentaires lancent des actions lors de l'interpolation du code G. L'interpolateur décélère à la vitesse 0, envoie le numéro de la fonction M en file d'attente à la sortie wM , et attend la confirmation dans bAcknM avant d'accélérer à nouveau. Contrair...", 
"body" : "Fonction : Les fonctions M ou les fonctions supplémentaires lancent des actions lors de l'interpolation du code G. L'interpolateur décélère à la vitesse 0, envoie le numéro de la fonction M en file d'attente à la sortie wM , et attend la confirmation dans bAcknM avant d'accélérer à nouveau. Contrairement au point de commutation, le programme reste à la position actuelle jusqu'à ce que la fonction M soit confirmée en réglant l'entrée sur l'interpolateur. Si SMC_PreAcknowledgeM est exécutée, le bloc fonction confirme la fonction M de manière anticipée. Si le bloc fonction est exécuté à temps, l'interpolateur ne s'arrête pas et le programme continue comme si l'instruction M n'était pas présente. Une fonction M est implémentée par l'application et non définie par le système. Syntaxe M K L O Mot de code G La description M Numéro de la fonction M, M > 0 Remarque : les numéros 65533–65535 sont réservés aux fonctions internes. K Paramètre numérique ( LREAL ) L Paramètre numérique ( LREAL ) O Références avec O$var$ une variable de type SMC_M_PARAMETERS qui contient d'autres paramètres. Dans l'application, les valeurs des paramètres des variables sont lues à l'exécution au moyen de la fonction SMC_GetMParameters . De plus, tous les paramètres sont évalués au moment du décodage et enregistrés dans la structure de données SMC_GEOINFO du tampon SMC_OUTQUEUE . En règle générale, cela se produit avant l'exécution de la fonction M à l'interpolateur. Pour que la variable puisse être trouvée par le bloc fonction utilisé (par exemple SMC_ReadNCFile2 ) lors du décodage, il doit être ajouté à son SMC_VARLIST avec le genre SMC_VARTYPE.SMC_TYPE_USERDEF . Exemples M avec paramètre La fonction M 10 démarre. Pour l'exécution du programme de N90, le système attend que la confirmation soit disponible. N90 M10 K100.7 M avec paramètre supplémentaire La fonction M 10 démarre. La structure de données définie par l'utilisateur g_myMParams (Type de données SMC_M_PARAMETER ) est référencé par O$var$ . g_myMParams contient des paramètres supplémentaires. Les valeurs de K, L et les paramètres de g_myMParams peut être lu lors de l'arrêt du chemin de la fonction M. Cela se fait en appelant une instance du bloc fonction SMC_GetMParameters . N150 M13 O$g_myMParams$ " }, 
{ "title" : "Synchronisation temporelle avec l'interpolateur ", 
"url" : "_sm_cnc_din66025_time_synchronisation_with_interpolator.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Synchronisation temporelle avec l'interpolateur ", 
"snippet" : "code G : G75 Fonction : La commande empêche le bloc fonction du décodeur de traiter le code G tant que l'interpolateur n'a pas parcouru tous les objets précédents. Lorsque l'interpolateur atteint G75 , toutes les files d'attente sont vides et le NCDecoder et tous les blocs fonctionnels de prétraitem...", 
"body" : "code G : G75 Fonction : La commande empêche le bloc fonction du décodeur de traiter le code G tant que l'interpolateur n'a pas parcouru tous les objets précédents. Lorsque l'interpolateur atteint G75 , toutes les files d'attente sont vides et le NCDecoder et tous les blocs fonctionnels de prétraitement continuent de s'exécuter. Cette fonction est utile pour utiliser des variables. Le décodeur remplace les variables lors du traitement de la ligne correspondante. Cependant, l'exécution par l'interpolateur se produit après un temps spécifié selon le mécanisme de file d'attente. Vous pouvez utiliser G75 pour attendre et synchroniser l'évaluation des variables et le traitement ultérieur par l'interpolateur. Syntaxe G75 Exemple N10 G1 X100\nN20 G75\nN30 G1 Y$g_y$ La variable g_y est disponible avec l'élément G1 et n'est pas détecté au préalable. Si G75 n'est pas inséré, alors le NCDecoder traite la ligne 30 juste avant que la valeur ne soit détectée. G75 n'a aucun effet sur l'éditeur CNC ou sur les chemins que l'éditeur CNC génère comme SMC_OutQueue . " }, 
{ "title" : "Saut ", 
"url" : "_sm_cnc_din66025_jump.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Saut ", 
"snippet" : "code G : G20 Fonction : La commande exécute un saut conditionnel. Syntaxe G20 L K Mot de code G La description L Cible de saut : Numéro de ligne défini (exemple : L20 ) Étiquette de saut Le saut est défini par un point d'interrogation et un index, par exemple L?4 . La commande de la destination de s...", 
"body" : "code G : G20 Fonction : La commande exécute un saut conditionnel. Syntaxe G20 L K Mot de code G La description L Cible de saut : Numéro de ligne défini (exemple : L20 ) Étiquette de saut Le saut est défini par un point d'interrogation et un index, par exemple L?4 . La commande de la destination de saut elle-même est identifiée par un point d'exclamation et l'index associé, par exemple L!4 . La cible de saut peut être ajoutée à n'importe quelle commande de code G. Ce saut est utilisé pour les programmes CNC générés automatiquement lorsque la ligne cible est inconnue. Les sauts avec des cibles inconnues vers des étiquettes de saut fonctionnent uniquement dans le décodeur en ligne (pas dans l'éditeur CNC). Condition : La ligne avec l'étiquette de saut doit être située après la ligne avec la commande de saut. \"Revenir en arrière\" n'est pas possible. Si la \"ligne cible\" n'est pas définie, les commandes suivant la commande de saut ne sont pas exécutées. K État Si K <> 0, alors le saut est exécuté. Si K n'est pas défini, alors une variable de décodeur interne est utilisée. La valeur de la variable interne du décodeur peut être définie avec le Modification des valeurs des variables commande. La valeur par défaut de cette variable interne est -1 . Exemple : exécuter le saut jusqu'à ce que le compteur interne = 0 Dix lignes sont reliées entre elles par le mode relatif. Il en résulte un mouvement de ligne à 100\/100. N00 G36 D10 (set counter to 10)\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN30 G37 D-1 (decrement counter)\nN40 G20 L20 (jump, if counter != 0) Exemple : évaluer la condition de saut au moment du décodage Exigence : Le comportement de la variable bvar est programmé dans l'application. Si l'axe X dépasse la position 15, alors bvar FALSE est réglé. ( bVar est initialement réglé sur TRUE .) Dans le premier cycle du programme, la position X est 10 et le programme saute à la ligne 20. La boucle est exécutée en continu car l'évaluation de la condition a lieu au moment du décodage et l'interpolateur n'a pas encore démarré ou est occupé avec le traitement d'objets au début du tampon. Cette condition est remplie et le décodeur ne sort de la boucle qu'après avoir généré suffisamment d'objets pour que la mémoire tampon soit pleine et que l'interpolateur commence le traitement. Dans le deuxième passage, l'axe X n'est pas encore à la position 20. La condition n'est pas remplie et bVar n'était pas réglé sur FALSE dans le code CEI. N0 G92 X0 Y0\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN30 G20 L20 K$bvar$ (jump, if counter != 0) Exemple : Insérer une synchronisation temporelle G75 exécute une synchronisation temporelle de l'interpolateur. G75 interrompt le traitement du décodeur jusqu'à ce que l'interpolateur et la mécanique atteignent la position respective. N0 G92 X0 Y0\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN25 G75\nN30 G20 L20 K$x$ (jump, if counter != 0) Pour plus d'informations, consultez : Synchronisation temporelle avec l'interpolateurExemple : Aller à l'étiquette de saut Remarque : Les sauts vers les étiquettes de saut fonctionnent uniquement dans le décodeur en ligne (pas dans l'éditeur CNC). N0 G16 F100 E100 E-100\nN10 G20 L?4 \/\/unconditional jump to the unknown target with index 4\nN15 G20 L60\nN20 G1 X1\nN30 G1 X1 L!5 \/\/resolution unknown jump target with index 5\nN40 G1 Z1 L!4 \/\/resolution unknown jump target with index 4\nN50 G20 L15\nN55 G1 Y1\nN60 G0 X0 Y0 Z0 " }, 
{ "title" : "Arc ", 
"url" : "_sm_cnc_din66025_arc.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Arc ", 
"snippet" : "code G : G2 , G3 Fonction : La commande interpole un arc à partir de la position actuelle le long d'une trajectoire circulaire jusqu'à la position cible. G2 se déplace dans le sens des aiguilles d'une montre et G3 se déplace dans le sens antihoraire. L'arc est défini comme suit : Méthode du rayon Co...", 
"body" : "code G : G2 , G3 Fonction : La commande interpole un arc à partir de la position actuelle le long d'une trajectoire circulaire jusqu'à la position cible. G2 se déplace dans le sens des aiguilles d'une montre et G3 se déplace dans le sens antihoraire. L'arc est défini comme suit : Méthode du rayon Coordonnée cible + rayon : Les coordonnées cibles sont définies en X\/Y\/Z. La courbe est définie par le rayon R. Méthode du point médian Coordonnée cible + coordonnée médiane : Les coordonnées cibles sont définies en X\/Y\/Z. La courbe est définie par la coordonnée médiane I\/J\/K. La coordonnée du milieu est située sur les médiatrices des points de départ et d'arrivée. Si ce n'est pas le cas, la coordonnée médiane est corrigée automatiquement. L'écart ne doit pas être supérieur à 10 %. Méthode de l'angle d'ouverture Angle d'ouverture + coordonnée médiane : Angle d'ouverture défini en T et coordonnées médianes en I\/J\/K. La position cible est calculée automatiquement. Des paramètres incohérents conduisent à parcourir une ligne au lieu d'un cercle. Exemples : Si le rayon est inférieur à la moitié de la distance entre le départ et la cible, l'écart ne peut pas être corrigé. C'est également le cas si le point médian défini entre la position de départ et la position cible a une distance différente. Syntaxe G2 X Y Z R A B C P Q U V W F E H L\/O D S\nG2 X Y Z I J K A B C P Q U V W F E H L\/O D S\nG2 I J K T A B C P Q U V W F E H L\/O D S\nG3 X Y Z R A B C P Q U V W F E H L\/O D S\nG3 X Y Z I J K A B C P Q U V W F E H L\/O D S\nG3 I J K T A B C P Q U V W F E H L\/O D S Mot de code G La description X Y Z Positions cibles des axes cartésiens R Rayon du cercle I J K Coordonnées du milieu du cercle T Angle d'ouverture (en degrés) A B C P Q U V W Positions cibles des axes supplémentaires F E Vitesse de trajectoire, accélération\/décélération de trajectoire H L\/O Point de commutation D Rayon de l'outil S Profil S Représentation graphique : Un arc est représenté par des extrémités noires. Les extrémités peuvent être déplacées lorsque vous sélectionnez l'élément. Arc en mode 3D En mode 3D, le système définit les arcs par le plan d'interpolation qui est défini à l'aide de G15-G19. Exemple Un demi-cercle dans le plan X\/Z et un demi-cercle dans le plan X\/Y N10 G1 X100 Y100\nN15 G18\nN20 G2 X200 R50\nN25 G17\nN30 G3 X100 R50 " }, 
{ "title" : "Méthode du rayon ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_535707857cba3404c0a86463692656db", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Arc \/ Méthode du rayon ", 
"snippet" : "Vous pouvez utiliser la méthode du rayon pour générer un arc < 180°. La méthode du rayon est valable pour deux arcs. L'un est plus petit qu'un demi-cercle et l'autre est plus grand qu'un demi-cercle. Le système utilise toujours l'arc le plus petit. Exemple Demi-cercle N10 G1 X100 Y100 F100 N20 G2 X2...", 
"body" : "Vous pouvez utiliser la méthode du rayon pour générer un arc < 180°. La méthode du rayon est valable pour deux arcs. L'un est plus petit qu'un demi-cercle et l'autre est plus grand qu'un demi-cercle. Le système utilise toujours l'arc le plus petit. Exemple Demi-cercle N10 G1 X100 Y100 F100\nN20 G2 X200 Y100 R50 Utilisez la méthode du point médian avec I\/J\/K pour générer un arc avec un angle d'ouverture supérieur à 180°. La méthode du rayon est unique, sauf dans le cas où les points de départ et d'arrivée du cercle sont identiques. Cela définit soit un cercle nul, soit un cercle complet. Dans ce cas, le système insère un cercle complet. " }, 
{ "title" : "Méthode du point médian ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_7dc8851b7cba3404c0a864637c8195be", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Arc \/ Méthode du point médian ", 
"snippet" : "Si vous utilisez la méthode du point médian, vous distinguez si les coordonnées I\/J\/K sont relatives ou absolues. Si I , J , et K ne sont pas spécifiés correctement, alors un arc n'est pas possible et le système le remplace par une ligne. Si elle est correcte, alors la distance entre le point médian...", 
"body" : "Si vous utilisez la méthode du point médian, vous distinguez si les coordonnées I\/J\/K sont relatives ou absolues. Si I , J , et K ne sont pas spécifiés correctement, alors un arc n'est pas possible et le système le remplace par une ligne. Si elle est correcte, alors la distance entre le point médian et le point de départ ou d'arrivée est identique. Exemples Même demi-cercle que dans la méthode du rayon ; spécifié au moyen du point médian relatif N10 G1 X100 Y100 F100\nN15 G99\nN20 G2 X200 Y100 I50 J0 Même demi-cercle que dans la méthode du rayon ; spécifié au moyen d'un point médian absolu N10 G1 X100 Y100 F100\nN15 G98\nN20 G2 X200 Y100 I150 J100 " }, 
{ "title" : "Méthode de l'angle d'ouverture ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_955d99e37cba3404c0a864634d5c784c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Arc \/ Méthode de l'angle d'ouverture ", 
"snippet" : "Si vous définissez le cercle par l'angle d'ouverture T, trois cercles complets au maximum sont autorisés (T ≤ 1080). La méthode de l'angle d'ouverture est appropriée pour un arc > 180°. Exemples Même demi-cercle que dans la méthode du rayon ; spécifié au moyen de l'angle d'ouverture N10 G1 X100 Y100...", 
"body" : "Si vous définissez le cercle par l'angle d'ouverture T, trois cercles complets au maximum sont autorisés (T ≤ 1080). La méthode de l'angle d'ouverture est appropriée pour un arc > 180°. Exemples Même demi-cercle que dans la méthode du rayon ; spécifié au moyen de l'angle d'ouverture N10 G1 X100 Y100\nN15 G99\nN20 G2 I50 J0 T180 Helix (deux cercles complets) N10 G1 X100 Y100\nN15 G99\nN20 G2 I50 J0 T720 " }, 
{ "title" : "Ellipse ", 
"url" : "_sm_cnc_din66025_ellipse.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Ellipse ", 
"snippet" : "code G : G8 , G9 Fonction : La commande spécifie un arc d'ellipse passant par les coordonnées cibles X\/Y, le milieu de l'ellipse I\/J, les directions de l'axe principal de l'ellipse K et le rapport de longueur R entre les axes principal et secondaire. Syntaxe G8 X Y Z R I J K A B C P Q U V W F E H L\/...", 
"body" : "code G : G8 , G9 Fonction : La commande spécifie un arc d'ellipse passant par les coordonnées cibles X\/Y, le milieu de l'ellipse I\/J, les directions de l'axe principal de l'ellipse K et le rapport de longueur R entre les axes principal et secondaire. Syntaxe G8 X Y Z R I J K A B C P Q U V W F E H L\/O D S\nG9 X Y Z R I J K A B C P Q U V W F E H L\/O D S Mot de code G La description X Y Z Positions cibles des axes cartésiens R Rapport de longueur R entre les axes primaire et secondaire. Gamme : 0 < R <= 1 R est utilisé uniquement si l'arc d'ellipse n'est pas défini uniquement par les extrémités, le point médian et la pente de l'axe principal. C'est le cas lorsque les deux extrémités ont la même distance par rapport à l'axe principal. Ensuite, les deux extrémités doivent avoir la même distance par rapport à l'axe secondaire. Sinon, aucune ellipse ne passe par ces points et le système remplace l'ellipse par une droite I J Milieu K Direction de l'axe principal de l'ellipse (en degrés) 0 : dans la direction de l'axe X 90 : dans le sens de l'axe Y -90 : Dans la direction opposée de l'axe Y A B C P Q U V W Positions cibles des axes supplémentaires F E Vitesse de trajectoire, accélération\/décélération de trajectoire H L\/O Point de commutation D Rayon de l'outil S Profil S L'ellipse est un objet 2.5D. Cela signifie que l'ellipse appartient toujours au plan X\/Y. Les ellipses dans d'autres plans ne sont pas prises en charge. Exemple N10 G0 X100 Y100 F100\nN15 G98\nN20 G8 X200 Y100 I150 J100 K45 R0.5 " }, 
{ "title" : "Mouvement linéaire ", 
"url" : "_sm_cnc_din66025_line.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Mouvement linéaire ", 
"snippet" : "code G : G1 Fonction : Cette commande de positionnement exécute une interpolation de ligne. L'interpolation de ligne déplace le point d'interpolation de la position actuelle aux coordonnées cibles définies sur une ligne. Tous les axes y arrivent en même temps. Les coordonnées cibles (X\/Y\/Z) doivent ...", 
"body" : "code G : G1 Fonction : Cette commande de positionnement exécute une interpolation de ligne. L'interpolation de ligne déplace le point d'interpolation de la position actuelle aux coordonnées cibles définies sur une ligne. Tous les axes y arrivent en même temps. Les coordonnées cibles (X\/Y\/Z) doivent être définies pour la description des lignes. En plus du déplacement dans l'espace, vous pouvez spécifier des positions cibles pour les axes supplémentaires A\/B\/C\/P\/Q\/U\/V\/W qui sont atteints en même temps avec les coordonnées cibles cartésiennes. Deux positions identiques consécutives entraînent toujours un arrêt du mouvement à cette position. L'arrêt se produit également lorsque le chemin suivant se connecte régulièrement et peut être parcouru sans s'arrêter. Syntaxe G1 X Y Z A B C P Q U V W F E H L\/O D S Mot de code G La description X Y Z Positions cibles des axes cartésiens A B C P Q U V W Positions cibles des axes supplémentaires F E Vitesse de trajectoire, accélération\/décélération de trajectoire H L\/O Point de commutation D Rayon de l'outil S Profil S Exemples Interpolation linéaire L'outil est positionné à la position de départ 0\/0\/0 (préréglé) puis se déplace en ligne droite jusqu'à la position cible 1\/2\/3 à la vitesse 1, à l'accélération 10 et à la décélération 20. En même temps, l'orientation l'axe A est parcouru à 180 degrés : N010 G01 X1 Y2 Z3 A180 F1 E10 E-20 La position de départ Position de départ 50\/50\/50, interpolation linéaire de 50\/50\/50 à 64\/30\/0 avec avance 100 N000 G92 X50 Y50 Z50 F100\nN010 G01 X64 Y30 Z0 " }, 
{ "title" : "Parabole ", 
"url" : "_sm_cnc_din66025_parabel.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Parabole ", 
"snippet" : "code G : G6 Fonction : La commande interpole une parabole qui est définie par les coordonnées du point final X\/Y\/Z et du sommet I\/J. Le sommet est le point où la tangente de l'élément est parallèle à la ligne de connexion du point de départ et d'arrivée. Une parabole est un objet 2.5D qui est toujou...", 
"body" : "code G : G6 Fonction : La commande interpole une parabole qui est définie par les coordonnées du point final X\/Y\/Z et du sommet I\/J. Le sommet est le point où la tangente de l'élément est parallèle à la ligne de connexion du point de départ et d'arrivée. Une parabole est un objet 2.5D qui est toujours dans le plan X\/Y. Les paraboles sur d'autres plans ne sont pas prises en charge. Syntaxe G6 X Y Z I J A B C P Q U V W F E H L\/O D S Mot de code G La description X Y Z Positions cibles des axes cartésiens I J Sommet de la parabole A B C P Q U V W Positions cibles des axes supplémentaires F E Vitesse de trajectoire, accélération\/décélération de trajectoire H L\/O Fonction H D Rayon de l'outil S Profil S Exemple N010 G00 X100 Y200 Z0 F100\nN020 G98\nN030 G06 X-100 Y200 Z00 I0 J0 " }, 
{ "title" : "Positionnement ", 
"url" : "_sm_cnc_din66025_positioning.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Positionnement ", 
"snippet" : "code G : G0 , G92 Fonction : Ces commandes positionnent l'outil. G0 commande un positionnement rapide sur une droite jusqu'à la position définie (normalement sans intervention sur l'outil). G92 définit immédiatement la position. Il en résulte qu'un saut est également exécuté sur les axes. SMC_Contro...", 
"body" : "code G : G0 , G92 Fonction : Ces commandes positionnent l'outil. G0 commande un positionnement rapide sur une droite jusqu'à la position définie (normalement sans intervention sur l'outil). G92 définit immédiatement la position. Il en résulte qu'un saut est également exécuté sur les axes. SMC_ControlAxisByPos.bAvoidGaps:=TRUE est défini, aucun saut n'est alors exécuté. Au lieu de cela, tous les axes sont parcourus individuellement jusqu'à la position cible sur la distance la plus courte. Le G92 peut être inséré au début du chemin afin de définir la position de départ Dans une série de commandes G92, la dernière est exécutée en premier. Les précédents sont ignorés. Si un bloc G1 avec des coordonnées identiques est inséré, le saut est exécuté pendant un cycle. C'est un avantage si le chemin entre les positions des commandes de saut n'est pas important, mais la position spécifiée doit être parcourue aussi vite que possible. Les SMC_ControlAxisByPos* les blocs fonctionnels détectent un saut vers les valeurs spécifiées, mettent l'interpolateur en pause et interpolent chaque axe individuellement aussi rapidement que possible. Deux positions identiques consécutives entraînent toujours un arrêt du mouvement à cette position. L'arrêt se produit également lorsque le chemin suivant se connecte régulièrement et peut être parcouru sans s'arrêter. Pour plus d'informations, consultez la documentation de la bibliothèque sur Direct Axis Control Syntaxe G0 X Y Z A B C P Q U V W F FF E EF H L\/O S\nG92 X Y Z A B C P Q U V W H L\/O Mot de code G La description X Y Z Positions cibles des axes cartésiens A B C P Q U V W Positions cibles des axes supplémentaires E Accélération\/décélération de trajectoire EF Accélération\/décélération de trajectoire uniquement pour le mouvement G0. Si est défini EF <> 0, alors la valeur définie dans E n'est pas prise en compte pour les mouvements G0. F Vitesse de trajectoire FF Vitesse qui n'est utilisée que pour les mouvements G0. Si est réglé FF <> 0, alors la valeur qui est définie dans F n'est pas prise en considération pour les mouvements G0. H L\/O Fonction H S Profil S Représentation graphique Dans l'éditeur graphique, les commandes G0 sont représentées par une ligne verte. Les commandes G92 ne sont pas représentées directement. Ils déplacent simplement le point de départ de l'élément suivant. Les commandes de positionnement ne peuvent être insérées que dans l'éditeur de texte CNC ou dans l'éditeur tabulaire. Ils peuvent être déplacés dans l'éditeur graphique. Exemples Positionnement avec interpolation linéaire avec avance définie N0 G92 X10 Y10 Sets the start position at 10\/10\nN10 G1 X20 F10 Linear interpolation to 20\/10 with feed 10\nN20 G0 Y20 F100 Linear positioning to 20\/20 with feed 100 Différents modes de positionnement N0 G92 X100 Y100 F100 Sets the position at 100\/100\nN10 G1 X100 Y100 Saves the output of this position for one cycle\nN20 G92 X50 Y100 Sets the position suddenly to 50\/100 Positionnement avec vitesse de trajectoire définie N1 G0 X1000 Y0 FF1000 EF10000 EF-10000 Positioning with velocity 1000\nN2 G1 Y100 F100 E100 E-100 Interpolating positioning with velocity 100\nN3 G0 X0 Y0 Positioning with velocity 1000\nN4 G0 X1000 FF0 EF0 Positioning with velocity 100 because FF and FE are reset; thus the values in F and E are used. " }, 
{ "title" : "Spline ", 
"url" : "_sm_cnc_din66025_spline.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Spline ", 
"snippet" : "code G : G5 , G10 Fonction : La commande interpole l'élément de chemin avec une spline afin que les transitions de l'élément de chemin précédent et vers l'élément de chemin suivant se confondent sans interruption. En même temps, le segment de spline du système est calculé de manière à ce que la tang...", 
"body" : "code G : G5 , G10 Fonction : La commande interpole l'élément de chemin avec une spline afin que les transitions de l'élément de chemin précédent et vers l'élément de chemin suivant se confondent sans interruption. En même temps, le segment de spline du système est calculé de manière à ce que la tangente de fin de l'élément de trajectoire précédent concorde avec la tangente de début de la spline. De même, la tangente de fin de la spline concorde avec l'élément de trajectoire suivant. Fonction : La commande crée un segment de spline pour la position donnée. Les transitions de l'élément de chemin précédent à l'élément de chemin suivant sont continuellement en position et en tangente. Syntaxe G5 X Y Z A B C P Q U V W F E H L\/O D S\nG10 X Y Z A B C P Q U V W F E H L\/O D S Mot de code G La description X Y Z Positions cibles des axes cartésiens A B C P Q U V W Positions cibles des axes supplémentaires F E Vitesse de trajectoire, accélération\/décélération de trajectoire H L\/O Point de commutation D Rayon de l'outil S Profil S Plusieurs segments de spline consécutifs sont connectés comme suit : Tangente de départ S'il existe un élément de trajectoire avec opération d'outil (exemple : G1, G2, G3, G8, G9), la tangente de fin de l'élément de trajectoire est utilisée comme tangente de début pour la spline. Si aucun élément de trajectoire n'est disponible avec l'utilisation de l'outil (par ex. G0, G92, M), la ligne de connexion entre le point de départ et le premier point de la spline est utilisée comme tangente de départ. Tangente au milieu de la spline Les points adjacents sont connectés. La tangente du point est parallèle à cette ligne de connexion (ligne verte). Tangente finale S'il existe un élément de trajectoire avec opération d'outil (exemple : G1, G2, G3, G8, G9), la tangente de départ de l'élément de trajectoire est utilisée comme tangente de fin pour la spline. Si aucun élément de trajectoire n'est disponible avec l'opération d'outil (par exemple, G0, G92, M), la ligne de connexion entre le point final et le premier point de la spline est utilisée comme tangente finale. Exemples Profil d'escalier à cannelures arrondies N0 G0 X0 Y0 Z0 F100 (Startposition)\nN10 G5 X20 Y0\nN20 G5 X20 Y20\nN30 G5 X40 Y20\nN40 G5 X40 Y40 Profil arrondi à double cannelure N0 G0 X0 Y0 F100 (Startposition)\nN5 G1 X5 Y0\nN10 G5 X20 Y0\nN20 G5 X20 Y20\nN21 G5 X20 Y20\nN30 G5 X40 Y20\nN40 G5 X40 Y40\nN45 G1 X0 Y40 Le point de spline pour X20 Y20 existe deux fois. De cette façon, la spline est interrompue et redémarrée. Ceci est déterminé par la méthode de définition de la tangente en ce point. Les points de début et de fin sont définis par les tangentes de début du segment de ligne précédent et suivant. " }, 
{ "title" : "Prétraitement ", 
"url" : "_sm_cnc_din66025_preprocessor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Prétraitement ", 
"snippet" : "code G : G40, G41, G42, G43, G50, G51, G52, G60, G61, G70, G71 Fonction : Les commandes activent des modules de prétraitement, tels que SMC_SmoothPath , SMC_RoundPath , SMC_AvoidLoop , SMC_ToolCorr , SMC_ToolLengthCorr , et SMC_ToolRadiusCorr . Si la Afficher le chemin prétraité est sélectionnée, le...", 
"body" : "code G : G40, G41, G42, G43, G50, G51, G52, G60, G61, G70, G71 Fonction : Les commandes activent des modules de prétraitement, tels que SMC_SmoothPath , SMC_RoundPath , SMC_AvoidLoop , SMC_ToolCorr , SMC_ToolLengthCorr , et SMC_ToolRadiusCorr . Si la Afficher le chemin prétraité est sélectionnée, le chemin modifié est visible dans l'éditeur graphique. Syntaxe G40\nG41 D\nG42 D\nG50\nG51 D\nG52 D\nG60\nG61 Mot de code G La description D Rayon d'outil ou rayon de recouvrement pour G51\/G52 . Pour les versions antérieures à 4.18.0.0 : L'angle arrondi\/lissage ( G51\/G52 ) et correction du rayon de l'outil ( G41\/G42 ) peuvent s'influencer mutuellement car les deux préprocessus interprètent chaque mot D du code G. Par exemple, si une correction du rayon d'outil avec rayus=1 est active lorsqu'un angle arrondi commence par D=5, la correction du rayon de l'outil utilise également un rayon Pour les versions 4.18.0.0 et supérieures : arrondissement\/lissage des angles ( G51\/G52 ) et correction du rayon de l'outil ( G41\/G42 ) peuvent être utilisés simultanément sans s'affecter mutuellement. Le comportement suivant s'applique à cet égard. Pour la correction du rayon de l'outil ( G41\/G42 ) : Par défaut, le rayon « Outil » utilisé par SMC_ToolRadiusCorr est égal à 0. Si un mot D est spécifié après les mots G G41\/G42 , puis le rayon de l'outil est ajusté et pris en compte par les blocs fonctionnels. Lorsqu'aucune valeur n'est spécifiée, le rayon « Outil » actuellement défini est utilisé. Pour arrondir et lisser les angles ( G51\/G52 ) : Par défaut, le rayon « Smooth » utilisé par SMC_Round\/SmoothPath est égal à 0. Si un mot D est spécifié après un mot G (sauf G36\/G37\/G40\/G41\/G42 ) ou seul (par exemple, N00 D5 ), cela affecte le rayon « lisse » actuel et est pris en compte par le SMC_Round\/SmoothPath blocs fonctionnels. Commandes de correction d'outil Code G La description G40 Fin de la compensation du rayon de l'outil G41 Début de la compensation du rayon d'outil à gauche de la pièce G42 Début de la compensation du rayon d'outil à droite de la pièce G43 Début de la compensation de longueur d'outil. La correction d'outil à corriger est spécifiée avec les paramètres I, J K (pour X, Y, Z ). La compensation de longueur d'outil est désactivée en remettant les paramètres à zéro. Après l'activation ou la désactivation, une rampe d'entrée ou de sortie est effectuée. Pour plus de détails, voir : SMC_ToolLengthCorr Remarque : La longueur de l'outil ne doit pas changer pendant une compensation de rayon d'outil active car elle peut casser la trajectoire. La correction de longueur d'outil (G43) ne fonctionne que dans le décodeur en ligne (pas dans l'éditeur CNC). Commandes d'arrondi et de lissage d'angle Code G La description G50 Arrondi et lissage de fin d'angle G51 Début du lissage d'angle au moyen de SMC_SmoothPath G52 Début de l'arrondi d'angle au moyen de SMC_RoundPath G70 Fin du lissage des axes supplémentaires au moyen de SMC_SmoothAddAxes G71 Début du lissage d'axes supplémentaires au moyen de SMC_SmoothAddAxes Commandes de suppression de boucle Code G La description G60 Fin de fonction pour suppression de boucle G61 Début de la fonction de suppression de boucle au moyen de SMC_AvoidLoop Exemple : Lissage d'angle N0 G51 D10 F100\nN10 G01 X$g_x$ Y0 F50 E30 E-30\nN20 G01 X0 Y$g_y$\nN30 G01 X0 Y0\nN40 G50 " }, 
{ "title" : "Axes de spline supplémentaires A, B, C ", 
"url" : "_sm_cnc_din66025_additional_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Axes de spline supplémentaires A, B, C ", 
"snippet" : "mot de code G : A , B , C Fonction : Utilisation A , B , et C pour définir les positions cibles pour les axes splines supplémentaires. Ces axes sont similaires à P , Q , U , V , et W . Alors que P , Q , U , et V sont interpolés linéairement, A , B , et C sont interpolés avec un polynôme du 3e degré....", 
"body" : "mot de code G : A , B , C Fonction : Utilisation A , B , et C pour définir les positions cibles pour les axes splines supplémentaires. Ces axes sont similaires à P , Q , U , V , et W . Alors que P , Q , U , et V sont interpolés linéairement, A , B , et C sont interpolés avec un polynôme du 3e degré. En utilisant A , B , ou C exclut l'utilisation des axes supplémentaires U , V , et W parce que U , V , et W définissez le dégradé. Les haches A , B , ou C peut être sélectionné avec les bits 3, 4 ou 5 au wAxis entrée de SMC_Limit Dynamics ou wAddAxis de SMC_Check for Limits . Le SMC_SmoothPath , SMC_SmoothMerge , SMC_SmoothBSpline , et SMC_Reculez les pentes ABC des blocs fonctionnels déterminent automatiquement la pente des axes supplémentaires. Cela signifie que la définition de U , V , ou W n'est pas nécessaire. Exemple 1 Code G N10 G0 X0 A0 P0 F10 E30 E-30\nN20 G1 X100 A100 P100 L'axe supplémentaire linéaire P est interpolé linéairement à la trajectoire parcourue. En conséquence, son profil temporel renvoie celui de la vitesse de trajectoire. L'axe de spline supplémentaire A est interpolé en tant que fonction polynomiale. Exemple 2 L'utilisation de la fonction spline est nécessaire, en particulier si une trajectoire avec des transitions tangentes constantes est utilisée, que l'interpolateur n'a pas à décélérer à la vitesse 0 : Code G N10 G0 X0 A0 P0 F10 E30 E-30\nN20 G1 X50 A40 P40\nN30 G1 X100 A100 P100 Dans le cas linéaire, vous constatez un saut de vitesse, car 40 unités de l'axe supplémentaire se déplacent sur 50 unités de trajectoire dans la première partie et 60 unités de l'axe supplémentaire se déplacent sur 50 unités de trajectoire dans la deuxième partie. Comme la vitesse de trajectoire ne définit (XYZ) qu'après l'espace cartésien de trajectoire, une vitesse constante en X provoque un saut de vitesse en P : L'axe de la spline affiche le profil suivant : Exemple 3 La pente des axes A, B et C à la position finale peut être définie par les mots U, V et W. L'unité de la pente est l'unité de trajectoire de l'axe supplémentaire par unité de trajectoire dans l'espace. Code G N10 G0 X0 A0 F10 E30 E-30\nN20 G1 X100 A100 U1.5\nN30 G1 X200 A200 U0 La pente programmée par l'utilisateur (U=2) de l'axe A s'applique car ce programme contient une transition continue entre N20 et N30 . Par conséquent, pour X=100, la position de l'axe A augmente deux fois plus vite que la longueur du trajet " }, 
{ "title" : "Lissage du mouvement d'axe supplémentaire à l'aide de plusieurs objets ", 
"url" : "_sm_cnc_din66025_smooth_additional_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Lissage du mouvement d'axe supplémentaire à l'aide de plusieurs objets ", 
"snippet" : "code G : G70 , G71 Fonction : G71 démarre et G70 termine le lissage du mouvement sur l'axe supplémentaire qui est donné dans L et se déplace sur plusieurs objets. Syntaxe G70 L4 G71 L4 Mot de code G Axe supplémentaire L4 A L5 B L6 C L7 P L8 Q L9 U L10 V L11 W...", 
"body" : "code G : G70 , G71 Fonction : G71 démarre et G70 termine le lissage du mouvement sur l'axe supplémentaire qui est donné dans L et se déplace sur plusieurs objets. Syntaxe G70 L4\nG71 L4 Mot de code G Axe supplémentaire L4 A L5 B L6 C L7 P L8 Q L9 U L10 V L11 W " }, 
{ "title" : "Configuration d'axes supplémentaires uniques en tant qu'axes modulo (PA\/PB\/…) ", 
"url" : "_sm_cnc_din66025_define_additional_axis_modulo.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Configuration d'axes supplémentaires uniques en tant qu'axes modulo (PA\/PB\/…) ", 
"snippet" : "Fonction: Pour les axes A, B, C, P, Q, U, V et W, une période modulo peut être spécifiée en définissant les mots PA , PB , PC , etc. Par défaut, PA , PB , etc. ont la valeur 0, ce qui signifie que l'axe est linéaire. Si un axe supplémentaire est configuré comme axe modulo, la distance la plus courte...", 
"body" : "Fonction: Pour les axes A, B, C, P, Q, U, V et W, une période modulo peut être spécifiée en définissant les mots PA , PB , PC , etc. Par défaut, PA , PB , etc. ont la valeur 0, ce qui signifie que l'axe est linéaire. Si un axe supplémentaire est configuré comme axe modulo, la distance la plus courte est toujours interpolée de la position de départ à la position cible. Pour une période modulo de 360, le déplacement s'effectue de la position de départ 270 à la position cible 45 comme suit : dans le sens positif (au-delà de 360) de 135 unités au total et non dans le sens négatif de 225 unités, comme pour une ligne de temps linéaire . La sortie de position de l'interpolateur peut être en dehors de l'intervalle [0..période limite[. (Par exemple, 400 au lieu de 40 pour une période modulo de 360.) La position est déplacée dans la plage modulo en suivant les POU, telles que SMC_ControlAxisByPos , ou SMC_FollowPosition . Exemple Commande rotative d'un axe par mode modulo Dans le bloc 30, l'axe A est déplacé dans le sens positif de 90° de 270° à 360°=0°. N10 PA360 (A axis has a period of 360 degree)\nN20 G92 A270 (Set the position of A axis to 270)\nN30 G1 A0 " }, 
{ "title" : "Utilisation de variables ", 
"url" : "_sm_cnc_din66025_usage_of_variables.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Utilisation de variables ", 
"snippet" : "Syntaxe $<Variablenname>$ Types de base CEI valides pour les variables et les expressions : INT , SINT , USINT , UINT , DINT , UDINT , BYTE , WORD , DWORD , REAL , et LREAL . Les exceptions incluent le paramètre O pour les fonctions M (qui attend une variable de type SMC_M_PARAMETERS ) et G36\/G37 (o...", 
"body" : "Syntaxe $<Variablenname>$ Types de base CEI valides pour les variables et les expressions : INT , SINT , USINT , UINT , DINT , UDINT , BYTE , WORD , DWORD , REAL , et LREAL . Les exceptions incluent le paramètre O pour les fonctions M (qui attend une variable de type SMC_M_PARAMETERS ) et G36\/G37 (où les variables de chaîne sont également autorisées). Des variables ou des expressions peuvent être définies pour tous les mots, à l'exception de N mots (numéros de bloc). Les expressions et variables CEI sont remplacées par leurs valeurs actuelles uniquement dans la POU du décodeur en ligne. Cela se produit lorsque la ligne est décodée, c'est-à-dire un certain temps avant que l'élément ne soit traité dans l'interpolateur. La valeur d'une variable en mode hors ligne est modifiée dans le Valeurs hors ligne des variables dialogue. Vous ouvrez la boîte de dialogue à l'aide de la CNC → Définir la variable commande ou le Variables dans les propriétés de l'objet CNC. Utiliser une variable globale en mode hors ligne Déclarez les variables dans la liste des variables globales. Utilisez les variables dans l'éditeur CNC à au moins un emplacement. Exécuter le CNC → Définir la variable commander. Les Valeurs hors ligne des variables la boîte de dialogue s'ouvre. Spécifiez les valeurs souhaitées dans le tableau. Exemple VAR_GLOBAL\n rVal_x1: REAL:=100;\n rVal_y1: REAL:=50;\nEND_VAR\n\n\/\/ CNC-Editor\nN0 G01 X$rVal_x1$ Y0 F50 E30 E-30\nN10 G01 X0 Y$rVal_y1$\nN20 G01 X0 Y0 Comportement en mode connecté Lorsque le décodeur POU traite le programme en ligne comme une variable de programme avec SMC_CNC_REF , des variables peuvent être utilisées. Les variables sont remplacées au moment où le décodeur traite la ligne respective. L'utilisation de variables dans des programmes en code G lus en ligne nécessite une préparation supplémentaire avec SMC_VARLIST . Si le programme CNC est compilé comme SMC_OUTQUEUE , alors le mécanisme variable ne fonctionne pas. En effet, le chemin est généré hors ligne et transmis en tant que structure de données non modifiable de l'application. Dans ce cas, l'éditeur remplace la variable par sa valeur hors ligne pour un affichage en mode hors ligne. Pour plus d'informations, consultez : Structures de données CNC et accès global" }, 
{ "title" : "Modification des valeurs des variables ", 
"url" : "_sm_cnc_din66025_change_variable_values.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Modification des valeurs des variables ", 
"snippet" : "code G : G36 , G37 Fonction : Les commandes changent la valeur d'une variable. G36 écrit la valeur spécifiée dans une variable. G37 incrémente la variable de la valeur spécifiée. O$var$ définit la variable qui est éditée. D définit la valeur qui est écrite pour G36 ou ajouté pour G37 . La commande e...", 
"body" : "code G : G36 , G37 Fonction : Les commandes changent la valeur d'une variable. G36 écrit la valeur spécifiée dans une variable. G37 incrémente la variable de la valeur spécifiée. O$var$ définit la variable qui est éditée. D définit la valeur qui est écrite pour G36 ou ajouté pour G37 . La commande est utilisée, par exemple, pour un compteur de boucle nécessaire aux sauts conditionnels. Syntaxe G36 O D\nG37 O D Mot de code G pour G36 La description O Variable écrite. O n'est pas défini, alors une variable de décodeur interne est utilisée. La valeur par défaut de cette variable interne est -1 . La variable interne peut être utilisée dans Saut commande. D Nouvelle valeur de variable Mot de code G pour G37 O Variable qui est incrémentée. Si O n'est pas défini, une variable de décodeur interne est utilisée. D Incrément Exemple Programmation du compteur (si le chemin est traité en ligne) Les g_i la variable globale est définie sur 5. N1000 G36 O$g_i$ D5 Les lignes 1010 et 1020 sont parcourues cinq fois. N1000 G36 O$g_i$ D5\nN1010 G1 X100 F100 E100 E-100\nN1020 G1 X0\nN1030 G37 O$g_i$ D-1\nN1040 G20 L1010 K$g_i$ Le mécanisme ne fonctionne que si le chemin est traité en ligne, car ce n'est qu'alors que des variables peuvent être utilisées. Ce mécanisme ne fonctionne pas dans l'éditeur CNC. Programmation du compteur pour le mode hors ligne Pour travailler avec l'éditeur hors ligne, ne spécifiez aucune variable au moyen de O . Puis une variable de décodeur implicite de type INT est utilisé. Cependant, une seule variable est disponible. Vous ne pouvez pas programmer de sauts ou de boucles imbriqués. Utilisation de variables de chaîne Vous pouvez utiliser une variable de chaîne dans le mot O du code G. De plus, une valeur de chaîne peut être affectée et insérée à cette variable au moyen de la commande G36 et G37 . Exemple N10 G36 O$strTest$ D'Name' Les strTest variable obtient la valeur Nom. N20 G37 O$strTest$ D'=Test' La valeur =Test est ajouté à la variable strTest . Si des variables de chaîne sont utilisées dans le programme CNC et si le programme CNC (dans le programme CEI) est lu au moyen de la SMC_ReadNCFile bloc fonction, les tampons pour les chaînes doivent être réservés dans le programme CEI. Sinon, l'erreur SMV_RNCF_NO_STRINGBUFFER se produit. Les SMC_StringBuffer bloc fonction est disponible à cet effet. Chaque chaîne du programme CNC requiert son propre espace dans l'instance de bloc fonction de SMC_StringBuffer , même si la même chaîne apparaît plusieurs fois. La déclaration suivante peut mettre en mémoire tampon 32 chaînes, par exemple : sb: SMC_StringBuffer(uiBufferSize := 32); L'instance du bloc fonction sb est passé en tant que pointeur vers le pStringBuffer entrée de la SMC_ReadNCFile exemple. " }, 
{ "title" : "Sous-programmes ", 
"url" : "_sm_cnc_din66025_subprograms.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Sous-programmes ", 
"snippet" : "Fonction : Appel d'un sous-programme Les tâches fréquemment récurrentes, telles que le fraisage de poches, le perçage de trous et le changement d'outil, peuvent être transférées vers des sous-programmes de code G et appelées à partir de là. Lors d'un appel, des paramètres peuvent être passés au sous...", 
"body" : "Fonction : Appel d'un sous-programme Les tâches fréquemment récurrentes, telles que le fraisage de poches, le perçage de trous et le changement d'outil, peuvent être transférées vers des sous-programmes de code G et appelées à partir de là. Lors d'un appel, des paramètres peuvent être passés au sous-programme. Les types de données BOOL , LREAL , et STRING sont autorisés à cet effet. Si vous utilisez des sous-programmes, vous devez utiliser les blocs fonctionnels SMC_ReadNCFile2 et SMC_NCInterpreter à la place de SMC_ReadNCFile et SMC_NCDecoder . Les sous-programmes fonctionnent uniquement dans le décodeur en ligne (pas dans l'éditeur CNC). Chaque sous-programme est stocké dans un fichier séparé. Ces fichiers sont stockés dans un ou plusieurs sous-répertoires sur le contrôleur. Les noms de fichiers doivent être en minuscules, l'extension de fichier .cnc et correspondent au nom du sous-programme. Exemple : Nom du sous-programme \"Drill\" -> nom du fichier drill.cnc . Notez que le nom de fichier du sous-programme doit être écrit en minuscules. Le POU SMC_ReadNCFile2 a une entrée aSubProgramDirs : ARRAY[0..4] OF STRING(174) . Au-delà, jusqu'à cinq sous-répertoires peuvent être spécifiés. Ils sont scannés dans l'ordre indiqué. S'il y a des sous-programmes avec le même nom dans plusieurs répertoires, alors le sous-programme est trouvé qui a le répertoire avec l'index le plus bas dans le tableau. Le nom du sous-programme est converti en minuscule. Exemple aSubProgramDirs = ['subprograms\/user', 'subprograms\/system', ''] Le sous-programme DrillA1 est analysé en premier dans le fichier subprograms\/user\/drilla1.cnc . Si ce fichier n'existe pas, la recherche se poursuit dans subprograms\/system\/drilla1.cnc . Il est possible d'appeler des sous-programmes indirectement au moyen d'une variable (plus précisément, au moyen d'une expression de type STRING ). L'expression (et donc aussi toute recherche de variables) est évaluée – généralement dans le cas de l'utilisation de variables dans le code G – au moment du prétraitement lorsque l'interpréteur atteint la ligne. Dans ce cas, la vérification du type des arguments n'est effectuée que lorsque l'interpréteur a atteint la ligne et non déjà lors de l'analyse, comme c'est le cas avec les appels statiques. Les sous-programmes ne peuvent pas être créés hors ligne dans l'éditeur CNC. Profondeur d'imbrication maximale des appels de sous-programmes Avant la version 4.18.0.0 : la profondeur d'imbrication maximale des appels de sous-programmes est limitée à 14. Version 4.18.0.0 et supérieure : la profondeur d'imbrication est désormais limitée uniquement par la mémoire. La valeur maximale peut être modifiée à l'aide du paramètre de bibliothèque SMC_CNC_LibParams.MAX_SUBPROGRAM_NESTING_DEPTH . " }, 
{ "title" : "Syntaxe de l'appel ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_f644d63d98ef7863c0a864636e4c0bd6", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Sous-programmes \/ Syntaxe de l'appel ", 
"snippet" : "Les appels de sous-programmes sont des blocs spéciaux dans le code G qui se composent uniquement d'un numéro de bloc et d'un appel. Aucun mot supplémentaire n'est autorisé. De plus, il existe un appel dynamique dans lequel le nom du sous-programme est encore inconnu lors de l'analyse et est préparé ...", 
"body" : "Les appels de sous-programmes sont des blocs spéciaux dans le code G qui se composent uniquement d'un numéro de bloc et d'un appel. Aucun mot supplémentaire n'est autorisé. De plus, il existe un appel dynamique dans lequel le nom du sous-programme est encore inconnu lors de l'analyse et est préparé (par exemple, par une variable IEC). N<SentenceNo> <Name> <BracketOpen> <ActualParamList> <BracketClosed>\nN<SentenceNo> DYNCALL <BracketOpen> <SubNameExp> [, <ActualParamListNotEmpty] <BracketClosed>\n\n<SubNameExp> : An expression with exactly one value of type STRING\n<ActualParamList> ::= Empty | <ActualParamListNotEmpty>\n<ActualParamListNotEmpty> ::= <ActualParamValue> | <ActualParamValue>, <ActualParamListNotEmpty> <Name> Identifiant IEC valide avec un minimum de 3 et un maximum de 80 caractères. Il doit correspondre au nom de fichier (sans extension) dans lequel le sous-programme est défini. Les majuscules ou les minuscules n'ont pas d'importance pour les noms de sous-programmes. Les personnages [a-zA-Z0-9_] sont autorisés. Les mots clés suivants ne sont pas valides en tant que noms : SUBPROGRAM, RETURN, END_SUBPROGRAM, RESTORE_MODES, BOOL, LREAL, STRING, LET, DYNCALL, IF, ELSE, END_IF, CASE, END_CASE, FOR,END_FOR, WHILE, END_WHILE, REPEAT, UNTIL, END_REPEAT . <ActualParamList> Il doit y avoir exactement le même nombre de valeurs de paramètres spécifiés que le sous-programme définit (voir \"Syntaxe pour la déclaration\"). Le type de chaque valeur de paramètre doit être conforme à la déclaration. <BracketOpen>\/<BracketClosed> Pour des raisons de compatibilité, les accolades sont utilisées à la place des parenthèses dans les paramètres par défaut pour SMC_ReadNCFile2 et les appels et déclarations de sous-programmes. Les parenthèses sont valides dans le code G pour les commentaires. Le bloc fonction SMC_ReadNCFile2 a un mode ( bParenthesesAsComments input) où les parenthèses ne sont pas des commentaires. Au lieu de cela, les commentaires multilignes sont ouverts avec (* et fermé avec *) . Dans ce nouveau mode, les accolades et les parenthèses peuvent être utilisées pour les appels et les déclarations de sous-programmes. <ActualParamValue> Variable, littéral ou toute expression Exemple N10 SUB1()\nN20 DRILL(10.0)\nN30 SUB2(5, \"Text\", 2.5)\nN40 G36 O#SUBNAME D'DRILL' % Indirect call via local variable\nN40 DYNCALL(#SUBNAME, 2) % equivalent to N40 DRILL(2)\nN50 DYNCALL($SUBNAME$, 2, 4) % Indirect call via IEC variable " }, 
{ "title" : "Syntaxe de la déclaration ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_02170a739e1947dec0a864637ea0fc00", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Sous-programmes \/ Syntaxe de la déclaration ", 
"snippet" : "Un sous-programme doit être enregistré dans un fichier séparé. La première ligne (ni vide ni ligne de commentaire) doit contenir la déclaration du sous-programme. La syntaxe suivante s'applique : SUBPROGRAM <Name> <BracketOpen> <FormalParamList> <BracketClosed> <RESTORE_OPT> <Inhalt Unterprogramm> E...", 
"body" : "Un sous-programme doit être enregistré dans un fichier séparé. La première ligne (ni vide ni ligne de commentaire) doit contenir la déclaration du sous-programme. La syntaxe suivante s'applique : SUBPROGRAM <Name> <BracketOpen> <FormalParamList> <BracketClosed> <RESTORE_OPT>\n<Inhalt Unterprogramm>\nEND_SUBPROGRAM\n\n<FormalParamList> ::= Empty | <FormalParamListNotEmpty>\n<FormalParamListNoEmpty> ::= <FormalParam> | <FormalParam> , <FormalParamListNotEmpty>\n<FormalParam> ::= <ParamName> : <ParamType>\n<ParamName> ::= #[a-zA-Z0-9_]+\n\n<ParamType> ::= LREAL | BOOL | STRING ; String with a maximum length of 255 bytes\n<RESTORE_OPT> ::= RESTORE_MODES <ParamName> La longueur du nom peut être au maximum de 80 caractères (sans compter le préfixe # ). RESTORE_MODES Si ce mot-clé est spécifié, alors les états modaux suivants sont restaurés lors du retour au programme appelant (défini à la valeur qu'il avait lors de l'appel) : Code G actif Mode relatif\/absolu (G90\/G91, G98\/G99) Plan circulaire et mode 2D\/3D Système de coordonnées du décodeur (y compris la mise à l'échelle) Avance (trajet et axes supplémentaires), vitesse d'avance rapide, accélérations et décélérations maximales (trajet et axes supplémentaires) Indicateurs de fonction et paramètres généraux (G38) Rayon de l'outil (mot D) Corrections d'outils (G43) Profil S (mot S) Les états modaux suivants ne sont pas restaurés : Position actuelle du décodeur\/interpréteur ainsi que l'état actuel de la spline cardinale La position inclut l'ensemble de la structure SMC_POSINFO (c'est-à-dire X, Y, Z, l'orientation et tous les axes supplémentaires). État (marche\/arrêt) des POU de prétraitement de chemin (G40-G43, G50-G52, G60-G61, G70-G71) Réglage modulo des axes supplémentaires (PA, PB, …) Remarque : Quel que soit ce mot-clé, les variables implicites du compteur (G36, G37) sont restaurées lors du retour du sous-programme vers le programme appelant. Exemples SUBPROGRAM SUB1() ; no formal parameters\nSUBPROGRAM DRILL(#depth : LREAL)\nSUBPROGRAM SUB2(#a : LREAL, #b : STRING, #c : LREAL)\nSUBPROGRAM SRM1() RESTORE_MODES " }, 
{ "title" : "Syntaxe pour le retour ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_4557d91f9e1947dec0a864630016f87d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Sous-programmes \/ Syntaxe pour le retour ", 
"snippet" : "Le retour se fait soit à la fin du texte du sous-programme (avant le END_SUBPROGRAM ) ou explicitement avec la syntaxe suivante : N<block number> RETURN ....", 
"body" : "Le retour se fait soit à la fin du texte du sous-programme (avant le END_SUBPROGRAM ) ou explicitement avec la syntaxe suivante : N<block number> RETURN . " }, 
{ "title" : "Utilisation des paramètres formels dans le sous-programme ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_ba614a0b6544562fc0a864631e9ee966", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Sous-programmes \/ Utilisation des paramètres formels dans le sous-programme ", 
"snippet" : "Les valeurs des paramètres formels sont accessibles dans le sous-programme par #<ParamName> . Le nombre de paramètres formels est limité à 21. Exemple SUBPROGRAM SUB(#Param1 : LREAL) N10 G01 X#Param1...", 
"body" : "Les valeurs des paramètres formels sont accessibles dans le sous-programme par #<ParamName> . Le nombre de paramètres formels est limité à 21. Exemple SUBPROGRAM SUB(#Param1 : LREAL)\nN10 G01 X#Param1 " }, 
{ "title" : "Affichage de la pile d'appels ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_1c910ecf4b371465c0a86463522d8482", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Sous-programmes \/ Affichage de la pile d'appels ", 
"snippet" : "L'interprète ( SMC_NCInterpreter ) a une sortie qui contient les 10 principaux programmes\/sous-programmes actifs : aActivePrograms : ARRAY[0..9] OF STRING . La première entrée ( aActivePrograms[0] ) est le programme\/sous-programme actuellement interprété. La deuxième entrée ( aActivePrograms[1] ) es...", 
"body" : "L'interprète ( SMC_NCInterpreter ) a une sortie qui contient les 10 principaux programmes\/sous-programmes actifs : aActivePrograms : ARRAY[0..9] OF STRING . La première entrée ( aActivePrograms[0] ) est le programme\/sous-programme actuellement interprété. La deuxième entrée ( aActivePrograms[1] ) est le programme\/sous-programme appelant et ainsi de suite. S'il n'y a pas de programme appelant, la chaîne correspondante est vide. La pile d'appels peut également être affichée au moment de l'interpolation. Les SMC_DisplayNCCallstack POU montre les programmes\/sous-programmes actifs dans le même format que l'interpréteur, seulement plus tard (c'est-à-dire lorsque le mouvement est exécuté). Ce faisant, la sortie de l'interpréteur CallstackInfo (SMC_NCCallstackInfo) et l'interpolateur lui sont transmis comme VAR_IN_OUT variables. SMC_NCCallstackInfo stocke tous les changements de pile d'appels, y compris les SMC_GeoInfo numéro d'objet, dans un tampon en anneau. À ce stade, cela limite le nombre de changements de pile d'appels stockables entre le temps d'interprétation et le temps d'interpolation à 128. Étant donné que la mémoire tampon en anneau ne répond pas aux critères de multitâche, SMC_DisplayNCCallstack doit être appelé à partir de la tâche d'interprétation. L'exemple de programme Exemple CNC 07 : Utilisation d'expressions et de sous-programmesmontre un exemple d'affichage de la pile des appels au moment de l'interpolation. " }, 
{ "title" : "Expressions ", 
"url" : "_sm_cnc_din66025_expressions.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Expressions ", 
"snippet" : "Fonction : Dans la version 4.4.0.0 et supérieure, il est possible d'utiliser des expressions mathématiques, booléennes et de chaîne. Les SMC_ReadNCFile2 et SMC_NCInterpreter des blocs fonctions doivent être utilisés pour cela (au lieu de SMC_ReadNCFile et SMC_NCDecoder ). Les expressions fonctionnen...", 
"body" : "Fonction : Dans la version 4.4.0.0 et supérieure, il est possible d'utiliser des expressions mathématiques, booléennes et de chaîne. Les SMC_ReadNCFile2 et SMC_NCInterpreter des blocs fonctions doivent être utilisés pour cela (au lieu de SMC_ReadNCFile et SMC_NCDecoder ). Les expressions fonctionnent uniquement dans le décodeur en ligne (pas dans l'éditeur CNC). En principe, les expressions peuvent être utilisées en code G dans deux positions : Comme valeurs de mots G (un mot G est constitué d'une adresse et d'une valeur, par exemple \"G1\") En tant que paramètres de transfert pour les appels de sous-programme " }, 
{ "title" : "Syntaxe – Général ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_42546a9cc18a4349c0a86463750fefea", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Expressions \/ Syntaxe – Général ", 
"snippet" : "Une expression peut être constituée des éléments suivants : Littéraux numériques et de chaîne Variables globales et locales Opérateurs et fonctions infixes Virgules et crochets De la même manière, les parenthèses (si elles ne sont pas utilisées pour identifier les commentaires) et les accolades peuv...", 
"body" : "Une expression peut être constituée des éléments suivants : Littéraux numériques et de chaîne Variables globales et locales Opérateurs et fonctions infixes Virgules et crochets De la même manière, les parenthèses (si elles ne sont pas utilisées pour identifier les commentaires) et les accolades peuvent être utilisées pour la structuration des expressions. Cela signifie que l'expression (1 + 2} * 3 est autorisé. Le bloc fonction SMC_ReadNCFile2 a un nouveau mode ( bParenthesesAsComments input) où les parenthèses ne sont pas des commentaires. Au lieu de cela, les commentaires multilignes sont ouverts et fermés avec \"(*\" et \"*)\", respectivement. Dans ce nouveau mode, les accolades et les parenthèses peuvent être utilisées pour les expressions. Un espace après l'adresse G n'est requis que si SMC_ReadNCFile2 ne le reconnaîtrait pas comme un jeton indépendant (exemple : X abs{-2} à la place de Xabs{-2}. ). Contrairement à ST, les fonctions à position unique ne doivent pas nécessairement être appelées avec des parenthèses (exemple : sin 3 ). Lors de l'analyse, chaque expression partielle se voit attribuer l'un des trois types : BOOL, LREAL ou STRING. En conséquence, chaque opérateur Infix et chaque fonction attend une séquence spécifique de types d'arguments pour lesquels la non-conformité (type incorrect, trop peu ou trop d'arguments) renvoie une erreur. Restrictions : Les numéros de bloc doivent être des littéraux numériques. Pour des raisons strictement techniques, les balises de saut ( x dans L!x ) ne doit contenir aucune variable locale. Pour plus d'informations, voir : Saut, Utilisation de variables" }, 
{ "title" : "Exemples ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_5b6258e8c18a4349c0a864632640e903", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Expressions \/ Exemples ", 
"snippet" : "N01 G36 O$var$ D concat{'prefix_', concat{$var$, '_suffix'}} N02 G1 X$var$ + sin{pi + 3 * #locvar} N03 G20 L0 K NOT {myfun{$var$, expt{2, #locvar}} XOR myfun{0, 0}}...", 
"body" : "N01 G36 O$var$ D concat{'prefix_', concat{$var$, '_suffix'}}\nN02 G1 X$var$ + sin{pi + 3 * #locvar}\nN03 G20 L0 K NOT {myfun{$var$, expt{2, #locvar}} XOR myfun{0, 0}} " }, 
{ "title" : "Opérateurs et fonctions pris en charge ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_da2d0ac5c18a4349c0a864637cb30dc8", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Expressions \/ Opérateurs et fonctions pris en charge ", 
"snippet" : "Opérateurs infixes Personnage Taper Arguments Priorité MOD LREAL LREAL , LREAL 14 * LREAL LREAL , LREAL 13 \/ LREAL LREAL , LREAL 13 + LREAL LREAL , LREAL 12 - LREAL LREAL , LREAL 12 = BOOL BOOL , BOOL 10 = BOOL LREAL , LREAL 10 = BOOL STRING , STRING 10 <> BOOL BOOL , BOOL 10 <> BOOL LREAL , LREAL 1...", 
"body" : "Opérateurs infixes Personnage Taper Arguments Priorité MOD LREAL LREAL , LREAL 14 * LREAL LREAL , LREAL 13 \/ LREAL LREAL , LREAL 13 + LREAL LREAL , LREAL 12 - LREAL LREAL , LREAL 12 = BOOL BOOL , BOOL 10 = BOOL LREAL , LREAL 10 = BOOL STRING , STRING 10 <> BOOL BOOL , BOOL 10 <> BOOL LREAL , LREAL 10 <> BOOL STRING , STRING 10 > BOOL LREAL , LREAL 10 < BOOL LREAL , LREAL 10 >= BOOL LREAL , LREAL 10 <= BOOL LREAL , LREAL 10 AND BOOL BOOL , BOOL 6 XOR BOOL BOOL , BOOL 5 OR BOOL BOOL , BOOL 4 Les fonctions Personnage Taper Arguments - LREAL LREAL ABS LREAL LREAL MAX LREAL LREAL , LREAL MIN LREAL LREAL , LREAL NOT BOOL BOOL TRUE BOOL FALSE BOOL SIN LREAL LREAL COS LREAL LREAL TAN LREAL LREAL ASIN LREAL LREAL ACOS LREAL LREAL ATAN LREAL LREAL EXP LREAL LREAL LN LREAL LREAL SQRT LREAL LREAL EXPT LREAL LREAL , LREAL FLOOR LREAL LREAL CEIL LREAL LREAL PI LREAL LEN LREAL STRING CONCAT STRING STRING , STRING " }, 
{ "title" : "Définir vos propres fonctions ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_fca8916cc18a4349c0a8646350db2bd3", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Expressions \/ Définir vos propres fonctions ", 
"snippet" : "Il est possible d'ajouter vos propres fonctions ou d'écraser une implémentation existante. (Lors de l'analyse du code G, les fonctions sont recherchées en premier dans les fonctions utilisateur.) L'interface SMC_NC_IFunction doit être implémentée et une instance globale du POU correspondant doit êtr...", 
"body" : "Il est possible d'ajouter vos propres fonctions ou d'écraser une implémentation existante. (Lors de l'analyse du code G, les fonctions sont recherchées en premier dans les fonctions utilisateur.) L'interface SMC_NC_IFunction doit être implémentée et une instance globale du POU correspondant doit être transférée vers SMC_ReadNCFile2 ou SMC_ReadNCFromStream via la structure SMC_NC_GFunctionTable . Le dénombrement SMC_GVar_Type est utilisé pour le type de retour et les types d'argument. L'entrée qu'il contient T_OTHER peut être utilisé comme espace réservé pour un type. Lors de l'analyse, le système vérifie que tous les arguments qui correspondent à un T_OTHER dans la signature ont le même type. Le genre n'a pas d'importance. Pour plus d'informations, voir : Fonctions G-Code spécifiques à l'utilisateur" }, 
{ "title" : "La gestion des erreurs ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_1c910ecf4b371465c0a86463522d8482", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Expressions \/ La gestion des erreurs ", 
"snippet" : "Lorsque cela est possible, la position exacte du jeton défectueux et sa longueur sont émises dans des erreurs de syntaxe. La position d'erreur est répertoriée dans SMC_ReadNCFile2.errorPos ....", 
"body" : "Lorsque cela est possible, la position exacte du jeton défectueux et sa longueur sont émises dans des erreurs de syntaxe. La position d'erreur est répertoriée dans SMC_ReadNCFile2.errorPos . " }, 
{ "title" : "Variables locales ", 
"url" : "_sm_cnc_din66025_local_variables.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Variables locales ", 
"snippet" : "Chaque fichier de code G peut déclarer des variables locales. Pour les programmes principaux, les déclarations doivent être insérées au tout début ; pour les sous-programmes, directement après la déclaration du sous-programme. Les variables locales ne sont visibles que dans le programme ou sous-prog...", 
"body" : "Chaque fichier de code G peut déclarer des variables locales. Pour les programmes principaux, les déclarations doivent être insérées au tout début ; pour les sous-programmes, directement après la déclaration du sous-programme. Les variables locales ne sont visibles que dans le programme ou sous-programme où elles sont déclarées. (Pas de portée dynamique) Les variables locales ne fonctionnent que dans le décodeur en ligne (pas dans l'éditeur CNC). Nombre de variables locales Avant la version 4.18.0.0 : le nombre de variables locales est limité à 21 par sous-programme et dans le programme principal. Version 4.18.0.0 et supérieure : le nombre de variables locales est limité uniquement par la mémoire. La valeur maximale peut être modifiée à l'aide du paramètre de bibliothèque SMC_CNC_LibParams.MAX_SUBPROGRAM_PARAMS . Pour plus d'informations, voir : Paramètres de la bibliothèque Syntaxe de la déclaration La syntaxe est similaire à la syntaxe utilisée pour déclarer les paramètres de sous-programme. Une variable peut être déclarée par bloc. Le bloc ne commence pas par un mot N. La variable peut être fournie avec une valeur initiale facultative lors de sa déclaration. Sinon, une valeur par défaut lui est attribuée en fonction du type de données ( LREAL: 0, BOOL: FALSE, STRING: ‘‘ ). Syntaxe de la déclaration : LET <FormalParam> [:= <InitialValue>] . <FormalParam> ::= <ParamName> : <ParamType>\n<ParamName> ::= #[a-zA-Z0-9_]+\n\n<ParamType> ::= LREAL | BOOL | STRING ; String mit maximaler Länge von 255 Bytes <InitialValue> : expression qui a une valeur et un type qui correspondent à la variable. L'expression peut également utiliser des variables locales (et dans les sous-programmes les paramètres du sous-programme), mais uniquement celles déclarées ci-dessus dans le code du programme. Exemples • LET #x : LREAL (* Variable #x, Typ LREAL, Initialwert 0 *)\n• LET #y : LREAL := #x + 1 (* Variable #y, Typ LREAL, Initialwert #x+1 = 1 *)\n• LET #b : BOOL := #x >= #y (* Variable #b, Typ BOOL, Initialwert FALSE *) Comme pour les paramètres de sous-programme, les variables locales ne sont pas sensibles à la casse. (Les deux #x et #X indiquent la même variable.) Les noms de toutes les variables locales déclarées dans un programme\/sous-programme doivent être différents. Ils doivent différer des noms des paramètres formels du sous-programme. Les variables locales peuvent être utilisées dans le code G comme des paramètres de sous-programmes. Exemples • N10 G01 X#x Y#y\n• N20 G20 L10 K#b " }, 
{ "title" : "Fonction de sondage (distance restante claire) ", 
"url" : "_sm_probe_movement.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Langage CNC selon DIN 66025 \/ Fonction de sondage (distance restante claire) ", 
"snippet" : "Code G : G31 \/Toute commande de mouvement associée à la PROBE mot Fonction : La fonction de sondage (distance restante nette) est un mouvement spécial qui est interrompu dès qu'un signal ( PROBE ) est en attente. Le reste du code G continue à partir de la position où le mouvement a été interrompu, e...", 
"body" : "Code G : G31 \/Toute commande de mouvement associée à la PROBE mot Fonction : La fonction de sondage (distance restante nette) est un mouvement spécial qui est interrompu dès qu'un signal ( PROBE ) est en attente. Le reste du code G continue à partir de la position où le mouvement a été interrompu, et non à partir de la position finale programmée du La fonction de sondage (distance restante nette) provoque un arrêt implicite du décodage avant le mouvement suivant (similaire à G75 ). Le décodage du code G ne se poursuivra qu'après réception du signal. Les cas d'utilisation typiques incluent la mesure de la longueur d'un outil (déplacement vers un interrupteur) ou déplacement sur un bloc. La fonction de sondage (distance restante nette) peut être activée pour n'importe quel nombre de mouvements, tels que des lignes droites et des arcs de cercle. Pour cela, seul le PROBE le mot doit être ajouté au code G. G31 est un mouvement linéaire avec la fonction de sondage (distance restante nette), avec le numéro de sonde par défaut 1. Cette valeur par défaut peut être remplacée par un mot PROBE Chaque mouvement peut comporter au plus un PROBE mot. Les fonctions H (déclencheurs) ne sont pas prises en charge pour les mouvements avec la fonction de sondage (distance restante libre). Le prétraitement de trajectoire tel que le lissage des angles, la correction du rayon d'outil, etc. n'est pas pris en charge pour les mouvements avec la fonction de palpage (distance restante nette). Le numéro de sonde doit être positif. Si aucun signal de sonde n'est reçu pendant le traitement d'un mouvement avec la fonction de sondage (distance restante nette), l'interpolation s'arrête à la fin du mouvement avec une erreur. L'interpolateur doit d'abord être arrêté lorsqu'un signal de sonde est reçu. L'une des entrées bSlow_Stop , bQuick_Stop , ou bEmergency_Stop peuvent être utilisés à cette fin. Dès que l'interpolation est arrêtée, la fonction de sondage (distance restante nette) peut être reconnue. À cette fin, un bord montant est appliqué sur le SMC_Interpolator.bAcknProbe entrée. Syntaxe G31 X Y Z A B C P Q U V W F E S PROBE\nG1\/2\/3\/8\/9 X Y Z A B C P Q U V W F E S PROBE Mot G-Code Descriptif X Y Z Positions cibles des axes cartésiens A B C P Q U V W Positions cibles des axes supplémentaires F E Vitesse de trajectoire, accélération\/décélération de trajectoire S profil S PROBE Le numéro de sonde doit être positif. Exemples Mouvement linéaire Mouvement linéaire avec fonction de sondage (distance restante nette) et sonde numéro 1 par défaut N010 G31 X100 Mouvement circulaire Mouvement circulaire avec fonction de sondage (distance libre restante) et sonde numéro 7 N010 G02 X100 R50 PROBE 7 Pour plus d'informations, consultez l'exemple suivant : Exemple CNC 16 : fonction de sondage (distance restante nette) (G31)" }, 
{ "title" : "Prétraitement des chemins et tailles des files d'attente ", 
"url" : "_sm_preprocessing_queuesize.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Prétraitement des chemins et tailles des files d'attente ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Pipelinage du traitement du code G ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103127844091", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Prétraitement des chemins et tailles des files d'attente \/ Pipelinage du traitement du code G ", 
"snippet" : "Lorsque le code G est lu à partir d'un fichier, il est souvent peu pratique de lire et de traiter l'intégralité du fichier avant de commencer l'usinage. Pour certaines applications, les fichiers G-code peuvent comporter quelques centaines de milliers, voire des millions de lignes. La lecture en une ...", 
"body" : "Lorsque le code G est lu à partir d'un fichier, il est souvent peu pratique de lire et de traiter l'intégralité du fichier avant de commencer l'usinage. Pour certaines applications, les fichiers G-code peuvent comporter quelques centaines de milliers, voire des millions de lignes. La lecture en une seule fois prendrait beaucoup de temps et nécessiterait également beaucoup de mémoire. Au lieu de cela, le code G est lu ligne par ligne, mais seule une petite fraction (quelques centaines de lignes) est conservée en mémoire à chaque instant. Cette partie est conservée dans des files d'attente, c'est-à-dire dans des structures de données qui fonctionnent selon le principe « premier entré, premier sorti » : le bloc fonctionnel producteur ajoute des éléments à la file d'attente. Le bloc fonctionnel consommateur lit et supprime les éléments dans l'ordre dans lequel ils ont été insérés. Le schéma montre le flux du code G dans le système. Tout d'abord, le code G est lu à partir d'un fichier, puis converti en éléments dits GeoInfo par l'interpréteur. Ces éléments sont traités par les blocs fonctionnels de prétraitement des chemins et finalement interpolés. Les parties marquées par « GeoInfo » représentent les files d'attente. Si plusieurs préprocesseurs de chemin (tels que SMC_SmoothPath , SMC_ToolRadiusCorr , ou SMC_AvoidLoop ) est utilisé, puis ils sont également connectés par des files d'attente. " }, 
{ "title" : "Tailles de file d'attente recommandées ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103128036484", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Prétraitement des chemins et tailles des files d'attente \/ Tailles de file d'attente recommandées ", 
"snippet" : "En règle générale, pour la plupart des files d'attente, une taille de 16 éléments convient. La dernière file d'attente avant SMC_Interpolator bloc fonctionnel (qui est généralement la file d'attente du bloc fonctionnel de prétraitement du chemin avant SMC_CheckVelocities ) devrait avoir une taille d...", 
"body" : "En règle générale, pour la plupart des files d'attente, une taille de 16 éléments convient. La dernière file d'attente avant SMC_Interpolator bloc fonctionnel (qui est généralement la file d'attente du bloc fonctionnel de prétraitement du chemin avant SMC_CheckVelocities ) devrait avoir une taille de file d'attente plus élevée : 100 éléments constituent un bon point de départ pour la plupart des applications. Pour comprendre ces règles et savoir quand s'en écarter, nous examinons les effets de la taille des files d'attente : Latence de traitement : plus les files d'attente sont longues, plus leur remplissage initial sera long. SMC_Interpolator bloc de fonctions attend que la dernière file soit remplie avant de commencer l'interpolation. Pour la latence, la taille totale de la file d'attente (somme de toutes les tailles de file d'attente) est pertinente. Regardez vers l'avenir de l'interpolateur : la taille de la dernière file d'attente avant SMC_Interpolator détermine la prévision de l'interpolation. Lors du calcul d'une trajectoire, l'interpolateur ne peut planifier que jusqu'à la fin de la prévision. Si la prévision est trop faible, l'interpolateur risque de ne pas être en mesure d'atteindre la vitesse totale du trajet. En fonction de la vitesse de trajet et de la longueur des éléments, 100 éléments constituent un bon point de départ, mais pour les vitesses élevées et\/ou les éléments courts, une taille de file d'attente plus importante peut être nécessaire Effet sur blocs fonctionnels particuliers : blocs fonctionnels tels que SMC_AvoidLoop ou SMC_SmoothMerge nécessitent une certaine taille de la file d'attente entrante pour fonctionner efficacement. Par exemple, pour détecter une boucle dans le G-Code, cette boucle doit entrer dans la file d'attente avant SMC_AvoidLoop . Consultez la documentation des blocs fonctionnels de votre pipeline de traitement des chemins pour plus de détails. " }, 
{ "title" : "Appel des blocs de fonctions de traitement ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103128219711", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Prétraitement des chemins et tailles des files d'attente \/ Appel des blocs de fonctions de traitement ", 
"snippet" : "Comme indiqué ci-dessus, l'interpolation ne commence que lorsque toutes les files d'attente sont remplies. Cela entraîne une latence initiale lors du démarrage de l'usinage. Outre la réduction de la taille totale de la file d'attente, il existe un autre moyen de réduire cette latence. Les blocs de f...", 
"body" : "Comme indiqué ci-dessus, l'interpolation ne commence que lorsque toutes les files d'attente sont remplies. Cela entraîne une latence initiale lors du démarrage de l'usinage. Outre la réduction de la taille totale de la file d'attente, il existe un autre moyen de réduire cette latence. Les blocs de fonctions de prétraitement des chemins sont généralement appelés dans le cadre d'une tâche d'arrière-plan cyclique, comme le montrent les exemples tels que Exemple CNC 03 : Exécution du prétraitement de trajectoire en ligne. Pour réduire la latence, le programme appelant SMC_ReadNCFile2 , SMC_NCInterpreter , et les préprocesseurs de chemin peuvent être appelés en boucle. En fonction de l'application et des priorités des tâches, il peut être suffisant d'exécuter le programme plusieurs fois par appel de tâche (par exemple 100 fois) ou de terminer la boucle après un certain laps de temps (par exemple 5 ms). " }, 
{ "title" : "Exemples ", 
"url" : "_sm_cnc_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Exemple CNC 01 : Génération directe de la file d'attente de sortie ", 
"url" : "_sm_example_cnc_1.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 01 : Génération directe de la file d'attente de sortie ", 
"snippet" : "Voir le CNC01_direct.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Cet exemple montre un programme CNC avec deux axes. Quatre positions sont accostées dans le plan X\/Y avec une vitesse et une accélération définies. Le programme ...", 
"body" : "Voir le CNC01_direct.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Cet exemple montre un programme CNC avec deux axes. Quatre positions sont accostées dans le plan X\/Y avec une vitesse et une accélération définies. Le programme définit deux points de commutation de chemin sur le chemin. Le programme est écrit directement dans une structure de données en utilisant le SMC_OutQueue mode compilation. Mise en service Compilez et démarrez le programme créé. Le programme exécute le mouvement CNC dès que le Execute l'entrée de l'interpolateur a été réglée. Après l'exécution complète du programme, vous pouvez le redémarrer au moyen d'un nouveau front montant. Notez la fonction des commutateurs de chemin qui sont également affichés dans la visualisation du bloc fonction d'interpolation. " }, 
{ "title" : "Création d'un programme CN dans l'éditeur CNC ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_0decf30fe1170213c0a864632e7a1fa2", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 01 : Génération directe de la file d'attente de sortie \/ Création d'un programme CN dans l'éditeur CNC ", 
"snippet" : "Créer un CNCdirect projet avec un SoftMotion manette. Insérez un programme CNC objet nommé Example . Sélectionnez le Mise en œuvre Din66025 et le Mode de compilation SMC_OutQueue . Spécifiez les blocs de mouvement suivants : Éditeur CNC :...", 
"body" : "Créer un CNCdirect projet avec un SoftMotion manette. Insérez un programme CNC objet nommé Example . Sélectionnez le Mise en œuvre Din66025 et le Mode de compilation SMC_OutQueue . Spécifiez les blocs de mouvement suivants : Éditeur CNC : " }, 
{ "title" : "Création d'une interface variateur et configuration automate ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_502a86c7e1170213c0a864631de910a9", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 01 : Génération directe de la file d'attente de sortie \/ Création d'une interface variateur et configuration automate ", 
"snippet" : "Définissez une structure d'entraînement avec deux entraînements linéaires comme suit : Insérer deux disques virtuels X_Drive et Y_Drive sous le Pool d'axes généraux SoftMotion . Met le Type d'axe paramètre à Finite (1). Éditeur de configuration :...", 
"body" : "Définissez une structure d'entraînement avec deux entraînements linéaires comme suit : Insérer deux disques virtuels X_Drive et Y_Drive sous le Pool d'axes généraux SoftMotion . Met le Type d'axe paramètre à Finite (1). Éditeur de configuration : " }, 
{ "title" : "Création d'un programme IEC ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_2840ecebe1170213c0a8646360b1cd08", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 01 : Génération directe de la file d'attente de sortie \/ Création d'un programme IEC ", 
"snippet" : "Ajouter un nouveau programme CFC Ipo à l'application et configurer une tâche cyclique avec un intervalle de 3 ms. Activez le lecteur avec le MC_Power  bloc fonctionnel. POU : Insérez le SMC_Interpolator PU. Le bloc fonction convertit un chemin défini par des objets GEOINFO en points de chemin discre...", 
"body" : "Ajouter un nouveau programme CFC Ipo à l'application et configurer une tâche cyclique avec un intervalle de 3 ms. Activez le lecteur avec le MC_Power  bloc fonctionnel. POU : Insérez le SMC_Interpolator PU. Le bloc fonction convertit un chemin défini par des objets GEOINFO en points de chemin discrets. Le bloc fonction reçoit l'adresse du programme CNC créé à l'entrée poqDataIn . Ensuite, le temps de cycle de la tâche CEI doit être écrit dans l'entrée dwIpoTime . Vous pouvez les spécifier comme valeurs constantes à l'entrée dwIpoTime ou vous pouvez utiliser la variable dwCycle de la structure du groupe d'axes depuis la configuration de l'automate. L'avantage est que le temps correct est automatiquement utilisé comme entrée d'interpolation lorsque vous modifiez le temps de cycle de la tâche. POU : Dans cet exemple, un système de portique sera contrôlé. Pour cela, insérez une instance des blocs fonction de transformation inverse et directe du SM_Trafo une bibliothèque. Le bloc fonction de transformation directe contient les variateurs comme entrées. Le bloc fonction de transformation inverse doit contenir la position définie de l'interpolateur. La transformation vers l'avant dans l'exemple est requise pour la visualisation uniquement. Instance de bloc fonction : Les sorties du bloc fonctionnel (les coordonnées d'axe) doivent être écrites dans les entraînements. Cela se fait avec le SMC_ControlAxisByPos bloc fonction. Étant donné que l'application ne garantit pas que les sorties de l'interpolateur sont constantes (par exemple, le chemin se termine à un autre point que celui où il a commencé), activez l'évitement d'écart ( bAvoidGaps , fGapVelocity , fGapAcceleration , fGapDeceleration ). Connectez ensuite le StopIpo sortie vers le bEmergency_Stop entrée de l'interpolateur et connecter la sortie de l'interpolateur iStatus aux entrées respectives des blocs fonction de commande d'axe. Notez l'ordre correct des blocs fonctionnels lors de la programmation avec CFC. CFC : " }, 
{ "title" : "Création d'une interface d'exploitation et d'une interface de test ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_af479c23e1170213c0a8646355fa8e27", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 01 : Génération directe de la file d'attente de sortie \/ Création d'une interface d'exploitation et d'une interface de test ", 
"snippet" : "Liez deux objets de visualisation à une nouvelle visualisation : le modèle de l'interpolateur et le modèle de la transformation. Vous devez utiliser des espaces réservés pour les lier aux instances de blocs fonctionnels respectives (ici : Ipo.smci et Ipo.trafof )....", 
"body" : "Liez deux objets de visualisation à une nouvelle visualisation : le modèle de l'interpolateur et le modèle de la transformation. Vous devez utiliser des espaces réservés pour les lier aux instances de blocs fonctionnels respectives (ici : Ipo.smci et Ipo.trafof ). " }, 
{ "title" : "Exemple CNC 02 : Décodage en ligne avec variables ", 
"url" : "_sm_example_cnc_2.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 02 : Décodage en ligne avec variables ", 
"snippet" : "Voir le CNC02_online.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . L'exemple montre comment un programme CNC ci-dessous Utilisation de variables peut être décodé. Mise en service Compilez et démarrez le programme créé. Le progra...", 
"body" : "Voir le CNC02_online.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . L'exemple montre comment un programme CNC ci-dessous Utilisation de variables peut être décodé. Mise en service Compilez et démarrez le programme créé. Le programme exécute le mouvement CNC dès que le Execute l'entrée du décodeur et de l'interpolateur a été réglée. Si vous modifiez les valeurs des variables globales, elles sont alors utilisées au redémarrage du décodeur et le chemin est adapté en conséquence. Surveiller le fonctionnement du Append l'entrée du décodeur également. " }, 
{ "title" : "Création d'un programme CN dans l'éditeur CNC ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_4c86ec04e529c0bcc0a864636a6ae1dc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 02 : Décodage en ligne avec variables \/ Création d'un programme CN dans l'éditeur CNC ", 
"snippet" : "Créer un CNCOnline programme avec un SoftMotion manette. Créez une liste de variables globale et déclarez deux variables. VAR_GLOBAL g_x: REAL:=100; g_y:REAL:=50; END_VAR Insérez un programme CNC objet nommé Example . Sélectionnez le Mise en œuvre Din66025 et le Mode compilation SMC_CNC_REF . Ce mod...", 
"body" : "Créer un CNCOnline programme avec un SoftMotion manette. Créez une liste de variables globale et déclarez deux variables. VAR_GLOBAL\n g_x: REAL:=100;\n g_y:REAL:=50;\nEND_VAR Insérez un programme CNC objet nommé Example . Sélectionnez le Mise en œuvre Din66025 et le Mode compilation SMC_CNC_REF . Ce mode est requis car vous utilisez des variables dans votre programme. Spécifiez les blocs de mouvement suivants : Éditeur CNC : " }, 
{ "title" : "Création d'une interface variateur et configuration automate ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_7e9d1704e529c0bcc0a8646343b60bbd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 02 : Décodage en ligne avec variables \/ Création d'une interface variateur et configuration automate ", 
"snippet" : "Définir une structure d'entraînement (par ex. CNCdirect )....", 
"body" : "Définir une structure d'entraînement (par ex. CNCdirect ). " }, 
{ "title" : "Création d'un programme IEC ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_3989abe9e529c0bcc0a864630f20ee19", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 02 : Décodage en ligne avec variables \/ Création d'un programme IEC ", 
"snippet" : "Ajouter un POU (CFC) nommé Path à l'application. Le décodage du programme CN pour OUTQUEUE et le contrôle de vitesse ont lieu dans le Path programme. Appel SMC_CheckVelocities est requis. CFC : Ajouter un POU (CFC) nommé Ipo à l'application. Ce programme est presque identique au CNCdirect exemple de...", 
"body" : "Ajouter un POU (CFC) nommé Path à l'application. Le décodage du programme CN pour OUTQUEUE et le contrôle de vitesse ont lieu dans le Path programme. Appel SMC_CheckVelocities est requis. CFC : Ajouter un POU (CFC) nommé Ipo à l'application. Ce programme est presque identique au CNCdirect exemple de projet. Cependant, l'entrée des données de l'interpolateur ne correspond pas aux noms des programmes CNC ( ADR(Example) ), mais à la sortie OutQueue des blocs fonction de prétraitement de chemin ( checkVel.poqDataOut ). " }, 
{ "title" : "Création d'une tâche pour le prétraitement du chemin ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_3014d45de529c0bcc0a86463617895a7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 02 : Décodage en ligne avec variables \/ Création d'une tâche pour le prétraitement du chemin ", 
"snippet" : "Parce que vous avez sélectionné le mode de compilation SMC_CNC_REF , vous devez effectuer le décodage et le prétraitement du chemin dans le programme IEC. Ce calcul prend du temps. Il n'a pas besoin d'être exécuté dans le cycle d'interpolation car un objet chemin est généré par appel de décodeur, et...", 
"body" : "Parce que vous avez sélectionné le mode de compilation SMC_CNC_REF , vous devez effectuer le décodage et le prétraitement du chemin dans le programme IEC. Ce calcul prend du temps. Il n'a pas besoin d'être exécuté dans le cycle d'interpolation car un objet chemin est généré par appel de décodeur, et cet objet est généralement utilisé pour de nombreux appels d'interpolateur. Vous devez remplacer cette opération par une tâche avec une priorité faible et des appels moins fréquents. Créer un PathTask tâche. Définissez les paramètres suivants : Priorité : dix Intervalle : T#30ms Ajouter le Path POU à la tâche. Tâche \"PathTask\" Mécanisme sous-jacent : Dans la tâche lente, environ un objet GEOINFO est généré par cycle dans un premier temps. Cet objet est stocké dans la structure OUTQUEUE du bloc fonction décodeur. Si la OUTQUEUE est pleine, les blocs fonction de la tâche lente s'arrêtent jusqu'à ce que la OUTQUEUE ne soit plus pleine. Cela se produit dès que la tâche rapide traite le premier objet GEOINFO et le supprime de la OUTQUEUE. Ensuite, les blocs fonction de la tâche lente redeviennent actifs et remplissent la structure OUTQUEUE. Dans la tâche rapide, un point de chemin de la structure OUTQUEUE, que le DataIn points d'entrée vers, est calculé et traité à chaque cycle. Comme un objet GEOINFO se compose généralement de plusieurs points de chemin, il faut quelques cycles jusqu'à ce que le premier objet GEOINFO soit traité et supprimé automatiquement par l'interpolateur. Comme le traitement d'un objet GEOINFO dure plusieurs cycles par opposition à sa création, la tâche lente peut être appelée moins fréquemment que la tâche rapide. Cependant, les heures des tâches doivent être sélectionnées de manière à ce qu'un nombre suffisant d'objets GEOINFO soit toujours stocké dans la dernière QUEUE DE SORTIE de la tâche lente, évitant ainsi l'apparition de toute sous-exécution de données. Cela se produit lorsqu'il n'y a plus d'objets GEOINFO disponibles pour l'interpolateur à partir de DataIn et que la fin du chemin n'a pas encore été atteinte. Dans ce cas, l'interpolateur ralentit et s'arrête jusqu'à ce que de nouveaux éléments de données soient à nouveau disponibles. " }, 
{ "title" : "Création d'une interface d'exploitation et d'une interface de test ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_af479c23e1170213c0a8646355fa8e27", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 02 : Décodage en ligne avec variables \/ Création d'une interface d'exploitation et d'une interface de test ", 
"snippet" : "La visualisation correspond à la CNCdirect.project exemple de projet. Ajoutez des modèles supplémentaires aux nouveaux blocs fonctionnels ( SMC_NCDecoder et SMC_CheckVelocities ). Créer un affichage également pour les variables globales g_x et g_y afin que vous puissiez vérifier leur fonction ultéri...", 
"body" : "La visualisation correspond à la CNCdirect.project exemple de projet. Ajoutez des modèles supplémentaires aux nouveaux blocs fonctionnels ( SMC_NCDecoder et SMC_CheckVelocities ). Créer un affichage également pour les variables globales g_x et g_y afin que vous puissiez vérifier leur fonction ultérieurement lors de la mise en service. " }, 
{ "title" : "Exemple CNC 03 : Exécution du prétraitement de trajectoire en ligne ", 
"url" : "_sm_example_cnc_3.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 03 : Exécution du prétraitement de trajectoire en ligne ", 
"snippet" : "Voir le CNC03_prepro.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . L'exemple montre comment le prétraitement de trajectoire peut être effectué en ligne sur l'automate. Prolongez le CNC02_online projet avec un préprocesseur de ch...", 
"body" : "Voir le CNC03_prepro.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . L'exemple montre comment le prétraitement de trajectoire peut être effectué en ligne sur l'automate. Prolongez le CNC02_online projet avec un préprocesseur de chemin. Ensuite, les angles du mouvement de la CNConline projet sont arrondis au moyen de splines. Cela se fait avec le SMC_SmoothPath bloc fonctionnel. Étendre le programme CNC : Ajouter le programme précédent avec les éléments G51\/G50 . Cliquez sur CNC → Afficher le chemin prétraité afin que les splines créées par le prétraitement du chemin soient affichées dans l'éditeur, comme dans la capture d'écran ci-dessous. Affichage: Sans utiliser de variables, vous pouvez compiler le programme sous cette forme sous forme de file d'attente et l'entrer directement dans l'interpolateur. Cependant, comme des variables sont disponibles, vous devez effectuer vous-même le décodage et le lissage d'angle. Déclarer un nouveau bloc fonction de type SMC_SmoothPath . Appelez-le après le décodeur. Réglez l'entrée de données du bloc fonction interpolateur comme d'habitude sur le poqDataOut sortie de la CheckVelocities bloc fonction. Un nouveau buffer doit être déclaré pour l'entrée SMC_SmoothPath.pbyBufferOutQueue . CFC : Mise en service Compilez et démarrez le programme créé. Contrairement au programme précédent, ce programme ne s'arrête plus aux angles du programme CN car les angles de la trajectoire ont été rendus sans plis grâce au prétraitement de trajectoire. " }, 
{ "title" : "Exemple de CNC 04 : Programmation de la CNC à l'aide de l'éditeur tabulaire ", 
"url" : "_sm_example_cnc_4.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple de CNC 04 : Programmation de la CNC à l'aide de l'éditeur tabulaire ", 
"snippet" : "Voir le CNC04_table.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Dans ce projet, la fonctionnalité du CNC03_prepro.project exemple de projet est programmé avec l'éditeur tabulaire. En contraste avec CNC03_prepro.project , aucun...", 
"body" : "Voir le CNC04_table.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Dans ce projet, la fonctionnalité du CNC03_prepro.project exemple de projet est programmé avec l'éditeur tabulaire. En contraste avec CNC03_prepro.project , aucune variable CEI n'est utilisée dans ce projet. Au lieu de cela, il est calculé avec des valeurs fixes. Sinon, la fonctionnalité est identique. " }, 
{ "title" : "Exemple de CNC 05: Création de CNC à partir d'un fichier ", 
"url" : "_sm_example_cnc_5.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple de CNC 05: Création de CNC à partir d'un fichier ", 
"snippet" : "Voir le CNC05_File.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Avec cet exemple de projet, vous pouvez comprendre comment un programme de code G est lu à partir d'un fichier ASCII stocké sur l'API. L'utilisation de ce type de ...", 
"body" : "Voir le CNC05_File.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Avec cet exemple de projet, vous pouvez comprendre comment un programme de code G est lu à partir d'un fichier ASCII stocké sur l'API. L'utilisation de ce type de fichier est logique lorsque le programme de code G est très volumineux. La fonction du projet est similaire à celle du CNC02_online.project exemple de projet. Cependant, le programme en code G est lu à partir d'un fichier ASCII. Aucune variable n'est utilisée et l'ordre de traitement est comparable à celui du CNC02_online.project exemple de projet. Les différences suivantes peuvent être déterminées : Lecteur virtuel supplémentaire (axe z) Bloc fonction smoothpath non requis Code G lu à partir du fichier Prétraitement en ligne (voir CNC02_online.project ) " }, 
{ "title" : "Exemple CNC 06 : Utilisation de Path3D avec SoftMotion CNC ", 
"url" : "_sm_example_cnc_6.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 06 : Utilisation de Path3D avec SoftMotion CNC ", 
"snippet" : "Voir le CNC06_File_3DPath.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Cet exemple prolonge l'exemple précédent CNC05_File . Il démontre une application possible de l'élément de visualisation Path3D avec CODESYS SoftMotion CNC....", 
"body" : "Voir le CNC06_File_3DPath.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Cet exemple prolonge l'exemple précédent CNC05_File . Il démontre une application possible de l'élément de visualisation Path3D avec CODESYS SoftMotion CNC. Extension du programme CNC_File à CNC_File_Path3D Ouvrez le Gestionnaire de bibliothèque et ajoutez le SM3_CNC_Visu une bibliothèque. Créer une instance de SMC_PathCopierFile dans CNC_PreparePath et l'appeler au début du traitement du chemin ( iState=0 ). La programmation: Dans le Visualisation visualisation, remplacez l'affichage graphique de la position précédemment utilisé par le Chemin3D élément. Modifier les propriétés du Chemin3D élément: Description du chemin → Données du chemin (VisuStruct3DTrack) : CNC_prepare_path.pcf.vs3dt Insérez le Cadre élément de visualisation. Référencez le Panneau de commande visualisation de la VisuElem3DPath une bibliothèque. Cet élément est utilisé pour contrôler la position de la caméra de l'élément. Dans la déclaration du CNC_PreparePath programme, créez une instance de VisuStruct3DControl ( VisuElem3DPath une bibliothèque): vc: VisuStruct3DControl; . Cette instance forme l'interface de données entre l'élément Path3D et le panneau de commande de la caméra. Modifier les propriétés du Chemin3D élément: Contrôle de la caméra → Structure des données de contrôle (VisuStruct3DControl) : CNC_PreparePath.vc Modifier les propriétés du Panneau de commande élément: Références → VisuElem3DPath.ControlPanel → vc : CNC_PreparePath.vc Compilez, téléchargez et démarrez l'application. L'élément Path3D montre le chemin. Vous pouvez contrôler la position de la caméra à partir du panneau. Ajouter une instance du SMC_PositionTracker bloc fonctionnel dans le CNC programme. Créez une mémoire pour tracer la trace actuelle (les dernières positions parcourues). pt: SMC_PositionTracker; pointbuffer_pt: ARRAY [0..1000] OF VisuStruct3DPathPoint; Insérez un appel de l'instance : SMC_PositionTracker dans le Interpolation action CFC : Liez les données de chemin à l'élément Path3D. Modifier les propriétés du Chemin3D élément: Description du chemin → Données du chemin (VisuStruct3DTrack) : CNC.pt.vs3dt Allez en ligne et lancez l'application. L'élément Path3D affiche également le dernier chemin interpolé vers le chemin. Configurer d'autres propriétés de Chemin3D . Par exemple, configurez les éléments du chemin traité à afficher en gris : Surbrillance → Couleur de surbrillance : Gray Exemple de projet : \"Générateur de chemin 3D\" " }, 
{ "title" : "Exemple CNC 07 : Utilisation d'expressions et de sous-programmes ", 
"url" : "_sm_example_cnc_7.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 07 : Utilisation d'expressions et de sous-programmes ", 
"snippet" : "Voir le CNC07_Subprogram.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment appeler un  sous-programme à partir d'un fichier CNC ainsi que l'utilisation expressions dans les instructions de mouvement CNC. D...", 
"body" : "Voir le CNC07_Subprogram.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment appeler un  sous-programme à partir d'un fichier CNC ainsi que l'utilisation expressions dans les instructions de mouvement CNC. Dans le CNC programme, les variateurs sont d'abord mis sous tension, comme dans les autres exemples. Les CNC_PreparePath programme utilise le SMC_ReadNCFile2 bloc fonction de lecture du fichier CNC. SMC_ReadNCFile2 crée le SMC_ReadNCFile POU et l'étend avec la prise en charge des sous-programmes et des expressions. Le programme CNC CNC2Main.cnc est converti au moyen de la SMC_NCInterpreter bloc fonction. SMC_NCInterpreter crée le SMC_NCDecoder POU et l'étend avec la prise en charge des sous-routines et des expressions. Le projet contient deux programmes CNC : le programme principal CNC2Main.cnc et le sous-programme CNC2.cnc . Le programme principal passe la valeur 25 dans le #RADIUS paramètre au sous-programme. Dans le sous-programme, l'expression X#RADIUS*2 est utilisé pour calculer la trajectoire circulaire. Programme principal N0 G01 X$g_x$ Y0 F50 E30 E-30\nN10 G01 X0 Y$g_y$\nN20 CNC2{25}\nN30 G01 X0 Y-200 Sous-programme SUBPROGRAM CNC2{#RADIUS : LREAL}\nN010 G91\nN020 G02 X#RADIUS*2 Y0 R#RADIUS Z2.5 F100 E-100 E100\nN030 G02 X-#RADIUS*2 Y0 R#RADIUS Z7.5\nEND_SUBPROGRAM " }, 
{ "title" : "Exemple CNC 08 : Utilisation d'axes supplémentaires ", 
"url" : "_sm_example_external_axes_usage.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 08 : Utilisation d'axes supplémentaires ", 
"snippet" : "Voir le CNC08_AdditionalAxes.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Cet exemple prolonge la CNC01_direct.projekt projet décrit dans Exemple CNC 01 : Génération directe de la file d'attente de sortie. Il montre comment uti...", 
"body" : "Voir le CNC08_AdditionalAxes.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Cet exemple prolonge la CNC01_direct.projekt projet décrit dans Exemple CNC 01 : Génération directe de la file d'attente de sortie. Il montre comment utiliser des axes supplémentaires. Comme dans l'exemple CNC 01, quatre positions sont accostées dans le plan X\/Y avec une vitesse et une accélération définies. De plus, l'axe supplémentaire A est parcouru lors de chaque mouvement. Le programme définit deux points de commutation de chemin sur le chemin. " }, 
{ "title" : "Edition d'un programme CNC dans l'éditeur ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4510557821784033079793683298", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 08 : Utilisation d'axes supplémentaires \/ Edition d'un programme CNC dans l'éditeur ", 
"snippet" : "Ouvrez le CNC01_direct.project projet à partir du répertoire d'installation de CODESYS . Dans le projet, ouvrez le programme CNC Example . Ajoutez des positions pour l'axe supplémentaire A aux commandes de déplacement : Editeur CNC N0 G01 X82.9 Y 8.9 A20 F50 E30 E-30 N10 G02 X84.9 Y84.6 A40 R100 H12...", 
"body" : "Ouvrez le CNC01_direct.project projet à partir du répertoire d'installation de CODESYS . Dans le projet, ouvrez le programme CNC Example . Ajoutez des positions pour l'axe supplémentaire A aux commandes de déplacement : Editeur CNC N0 G01 X82.9 Y 8.9 A20 F50 E30 E-30\nN10 G02 X84.9 Y84.6 A40 R100 H12 L10\nN20 G01 X 6.6 Y25.7 A60 H-1 O0.8\nN30 G03 X54.6 Y49.7 A80 R100 " }, 
{ "title" : "Création d'une interface variateur et d'une configuration API ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4590758202758433079807306962", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 08 : Utilisation d'axes supplémentaires \/ Création d'une interface variateur et d'une configuration API ", 
"snippet" : "Insérer un lecteur virtuel supplémentaire Une conduite sous le Groupe d'axes généraux SoftMotion . Définissez les paramètres comme suit :...", 
"body" : "Insérer un lecteur virtuel supplémentaire Une conduite sous le Groupe d'axes généraux SoftMotion . Définissez les paramètres comme suit : " }, 
{ "title" : "Edition d'un programme CEI ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4590758311412833079809057524", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 08 : Utilisation d'axes supplémentaires \/ Edition d'un programme CEI ", 
"snippet" : "Ouvrir le programme CFC Ipo . Activer le lecteur précédemment ajouté Une conduite avec le MC_Power bloc fonctionnel. Dans cet exemple, un simple axe d'orientation ( Une conduite ) doit être commandé avec l'axe supplémentaire A. Pour cette raison, aucun module de transformation supplémentaire n'est n...", 
"body" : "Ouvrir le programme CFC Ipo . Activer le lecteur précédemment ajouté Une conduite avec le MC_Power bloc fonctionnel. Dans cet exemple, un simple axe d'orientation ( Une conduite ) doit être commandé avec l'axe supplémentaire A. Pour cette raison, aucun module de transformation supplémentaire n'est nécessaire. La position de consigne de l'interpolateur correspond directement à la position de consigne de l'entraînement et est appliquée via le SMC_POSINFO sélecteur avec le SMC_ControlAxisByPos bloc fonctionnel. L'application ne garantit pas que les sorties de l'interpolateur sont continues. Par exemple, la position de l'axe supplémentaire se termine à un point différent de celui où elle commence. Par conséquent, vous devez activer l'évitement d'écart ( bAvoidGaps , fGapVelocity , fGapAcceleration , et fGapDeceleration ). Connectez ensuite le bStopIpo sortie vers le bEmergency_Stop entrée de l'interpolateur et connecter la sortie de l'interpolateur iStatus aux entrées respectives des blocs fonctionnels de commande d'axe. Veillez avant tout à l'ordre correct des blocs fonctionnels lors de la programmation avec CFC. " }, 
{ "title" : "Commissioning ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4584880865328033079813143466", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 08 : Utilisation d'axes supplémentaires \/ Commissioning ", 
"snippet" : "Compilez et démarrez le programme créé. Le programme exécute le mouvement CNC dès que le Execute l'entrée de l'interpolateur a été définie. Après l'exécution complète du programme, vous pouvez appliquer un nouveau front montant pour le redémarrer. Pendant l'exécution du programme CNC, notez la posit...", 
"body" : "Compilez et démarrez le programme créé. Le programme exécute le mouvement CNC dès que le Execute l'entrée de l'interpolateur a été définie. Après l'exécution complète du programme, vous pouvez appliquer un nouveau front montant pour le redémarrer. Pendant l'exécution du programme CNC, notez la position de l'axe supplémentaire A ( piSetPosition.dA ) qui apparaît dans la visualisation du POU d'interpolation. " }, 
{ "title" : "Exemple CNC 09 : Utilisation de la correction de longueur d'outil ", 
"url" : "_sm_example_tool_correction_usage.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 09 : Utilisation de la correction de longueur d'outil ", 
"snippet" : "Voir l'exemple de projet pour cela CNC09_ToolLengthCorr.project dans le répertoire d'installation de CODESYS parmi ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment utiliser le SMC_ToolLengthCorr POU pour compenser la longueur d'un outil. Pour plus d'informations sur le sujet de la correct...", 
"body" : "Voir l'exemple de projet pour cela CNC09_ToolLengthCorr.project dans le répertoire d'installation de CODESYS parmi ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment utiliser le SMC_ToolLengthCorr POU pour compenser la longueur d'un outil. Pour plus d'informations sur le sujet de la correction de longueur d'outil, voir : Prétraitement" }, 
{ "title" : "Application ", 
"url" : "_sm_example_tool_correction_usage.html#UUID-1d022e7a-4834-0535-1cca-7cab7ecde5dd_section-idm458488080921763308005489139", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 09 : Utilisation de la correction de longueur d'outil \/ Application ", 
"snippet" : "Pour l'exemple, une cinématique Gantry3 est utilisée avec un axe d'orientation ajouté ( AxisA ) qui peut tourner autour de l'axe Z. Un outil d'une longueur de 2 unités dans la direction Z est à son tour attaché à l'axe d'orientation. Un programme CNC simple doit être exécuté. Ceci est stocké dans le...", 
"body" : "Pour l'exemple, une cinématique Gantry3 est utilisée avec un axe d'orientation ajouté ( AxisA ) qui peut tourner autour de l'axe Z. Un outil d'une longueur de 2 unités dans la direction Z est à son tour attaché à l'axe d'orientation. Un programme CNC simple doit être exécuté. Ceci est stocké dans le projet en tant que fichier externe CNC.cnc fichier et peut être ouvert avec un éditeur de texte. Dans le programme CNC, la correction de longueur d'outil est d'abord activée au moyen du code G G43 . La I , J , et K correspondent au décalage dans les directions X, Y et Z pour cela. Ensuite, trois points sont parcourus dans le plan XY. Pendant le déplacement vers le dernier point, l'axe supplémentaire A est également tourné de 90 degrés. N000 G43 I0 J0 K2 (Activate tool length correction with tool offset X=0 Y=0 Z=2)\nN010 G01 X10 F10 E100 E-100\nN020 G03 Y10 R5N030 G01 X0 A90 L'application se compose de plusieurs parties. Dans le CNC_PreparePath programme, le programme CNC CNC.cnc est importé sous forme de fichier depuis le contrôleur et prétraité. Dans le CNC programme, les entraînements sont d'abord mis sous tension, comme dans les autres exemples. Ensuite, l'interpolation du programme CNC lu précédemment est effectuée. Dans chaque cycle, l'interpolateur délivre une position définie (piSetPosition ) et le décalage actuel de l'outil (adToolLength ). La SMC_ToolLengthCorr Le POU a besoin de ces informations pour compenser la longueur d'outil spécifiée. La position compensée est ensuite transformée et finalement transmise aux axes au moyen de la SMC_ControlAxisByPos POU. Le programme est presque identique aux autres exemples. Seulement le SMC_ToolLengthCorr Le POU a été inséré après l'interpolateur et avant la transformation afin de traiter la sortie de position définie par l'interpolateur. " }, 
{ "title" : "Mise en service ", 
"url" : "_sm_example_tool_correction_usage.html#UUID-1d022e7a-4834-0535-1cca-7cab7ecde5dd_section-idm4590758219934433080059282556", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 09 : Utilisation de la correction de longueur d'outil \/ Mise en service ", 
"snippet" : "Compilez et démarrez le programme créé. Le programme exécute le mouvement CNC dès que le CNC_PreparePath.xStart l'entrée a été définie. Vous pouvez cliquer sur le Commencer pour définir cette variable dans l'application ou dans la visualisation. Après l'exécution complète du programme, vous pouvez a...", 
"body" : "Compilez et démarrez le programme créé. Le programme exécute le mouvement CNC dès que le CNC_PreparePath.xStart l'entrée a été définie. Vous pouvez cliquer sur le Commencer pour définir cette variable dans l'application ou dans la visualisation. Après l'exécution complète du programme, vous pouvez appliquer un nouveau front montant pour le redémarrer. Pendant l'exécution du programme CNC, notez les sorties de l'interpolateur ( piSetPosition , adToolLength ) et la position compensée ( piOut ) de la SMC_ToolLengthCorr PU. Remarque : La rotation de AxisA pendant le dernier mouvement du programme CNC n'a aucun effet (supplémentaire) sur la position cartésienne compensée dans cet exemple car l'outil n'a qu'un décalage dans la direction Z. Si vous ajoutez un composant au décalage de l'outil (dans le fichier CNC, sur le contrôleur dans le dossier de l'application) dans les directions X et Y, alors la rotation de AxisA lors du dernier mouvement aura un effet supplémentaire sur la position compensée. " }, 
{ "title" : "Lire l'état de l'interpolateur ", 
"url" : "_sm_example_state_interpolator.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Lire l'état de l'interpolateur ", 
"snippet" : "Consultez les CNC13_ReadInterpolatorState.project exemple de projet dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . L'exemple de projet montre comment lire l'état de l'interpolateur CNC. L'état est utilisé pour afficher la position de la machine à la fois dans les ...", 
"body" : "Consultez les CNC13_ReadInterpolatorState.project exemple de projet dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . L'exemple de projet montre comment lire l'état de l'interpolateur CNC. L'état est utilisé pour afficher la position de la machine à la fois dans les coordonnées de la machine et du décodeur " }, 
{ "title" : "Structure de la demande ", 
"url" : "_sm_example_state_interpolator.html#UUID-7d495950-6d6e-d3d4-336b-0d7c83f08247_section-id235234546899564", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Lire l'état de l'interpolateur \/ Structure de la demande ", 
"snippet" : "La structure est typique des applications CNC. Le code G est lu dans la tâche d'arrière-plan. L'interpolation est effectuée dans la tâche du bus Au cours de l'interpolation, SMC_ReadAdditionalIpoState bloc de fonction appelé. Dès que l'interpolation commence, le Valid la sortie est TRUE . La positio...", 
"body" : "La structure est typique des applications CNC. Le code G est lu dans la tâche d'arrière-plan. L'interpolation est effectuée dans la tâche du bus Au cours de l'interpolation, SMC_ReadAdditionalIpoState bloc de fonction appelé. Dès que l'interpolation commence, le Valid la sortie est TRUE . La position de l'interpolateur, qui est toujours sortie dans le système de coordonnées de la machine (MCS), est ensuite convertie à l'aide du système de coordonnées du décodeur (DCS) actuel et SMC_V3_Set(pos_MCS, ipo.piSetPosition.dX, ipo.piSetPosition.dY, ipo.piSetPosition.dZ);\n\nreadState(\n    Enable:= TRUE,\n    ipo:= ipo);\n\nIF readState.Valid THEN\n    SMC_PosInfo_Trf_Inverse(\n        piOut:= piMCS_to_DCS,\n        piIn:= readState.State.DCS,\n        eOriConv:= readState.State.OriConv);\n\n SMC_PosInfo_Trf_Apply(\n        vDst:= pos_DCS,\n        piTrf:= piMCS_to_DCS,\n        vSrc:= pos_MCS,\n        eOriConv:= readState.State.OriConv);\nEND_IF Pour plus d'informations sur le système de coordonnées du décodeur, consultez les rubriques suivantes : Déplacement, rotation et mise à l'échelle du système de coordonnées. " }, 
{ "title" : "Mise en service ", 
"url" : "_sm_example_state_interpolator.html#UUID-7d495950-6d6e-d3d4-336b-0d7c83f08247_section-id235234714771807", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Lire l'état de l'interpolateur \/ Mise en service ", 
"snippet" : "Créez l'application et téléchargez-la sur une manette. Ouvrez la visualisation. Démarrez l'application et appuyez sur Commencer bouton de la visualisation. Vous pouvez suivre le mouvement des coordonnées X et Y dans MCS et DCS....", 
"body" : "Créez l'application et téléchargez-la sur une manette. Ouvrez la visualisation. Démarrez l'application et appuyez sur Commencer bouton de la visualisation. Vous pouvez suivre le mouvement des coordonnées X et Y dans MCS et DCS. " }, 
{ "title" : "Implémentation d'un bloc fonctionnel de prétraitement de chemin ", 
"url" : "_sm_example_cnc14_path_preprocessing.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Implémentation d'un bloc fonctionnel de prétraitement de chemin ", 
"snippet" : "Consultez les CNC14_PathPreprocessing.project exemple de projet dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . L'exemple de projet montre comment implémenter un nouveau bloc fonctionnel de prétraitement de chemin. prétraitement du chemin est généralement utilisé p...", 
"body" : "Consultez les CNC14_PathPreprocessing.project exemple de projet dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . L'exemple de projet montre comment implémenter un nouveau bloc fonctionnel de prétraitement de chemin. prétraitement du chemin est généralement utilisé pour modifier le chemin lu à partir du code G. Cela permet de mettre en œuvre des fonctions telles que la correction du rayon de l'outil ou le lissage des angles. Cependant, il est également possible d'intégrer des fonctions spécifiques pour une machine ou une application particulière sous la forme d'un bloc fonctionnel de prétraitement de chemin Pour plus d'informations sur le prétraitement des chemins, consultez les rubriques suivantes : Prétraitement des chemins et tailles des files d'attente. Pour un exemple d'utilisation d'un bloc fonctionnel de prétraitement de chemin, consultez les rubriques suivantes : Exemple CNC 03 : Exécution du prétraitement de trajectoire en ligne. " }, 
{ "title" : "Limiter le changement de tangente ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234576416031", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Implémentation d'un bloc fonctionnel de prétraitement de chemin \/ Limiter le changement de tangente ", 
"snippet" : "L'exemple montre une application de découpe 2D. Un couteau doit être utilisé pour couper le long d'un chemin défini par le code G. SMC_TRAFO_GantryCutter2 Une transformation est utilisée pour déterminer l'angle du couteau en fonction de la tangente actuelle de la trajectoire. Le défi est que le cout...", 
"body" : "L'exemple montre une application de découpe 2D. Un couteau doit être utilisé pour couper le long d'un chemin défini par le code G. SMC_TRAFO_GantryCutter2 Une transformation est utilisée pour déterminer l'angle du couteau en fonction de la tangente actuelle de la trajectoire. Le défi est que le couteau ne doit pas tourner trop vite, sinon la coupe ne sera pas nette. La limitation de la vitesse angulaire du couteau est résolue dans le projet d'exemple au moyen du bloc fonctionnel de prétraitement de trajectoire nouvellement créé LimitTangentVelocity . Il modifie la vitesse d'avance sur la trajectoire afin que la vitesse de variation de la tangente ne dépasse pas une valeur maximale configurable Le code G est un simple rectangle aux coins lissés. Le tracé montre le résultat de l'exécution : la vitesse de l'axe C, qui correspond à la vitesse de rotation du couteau, est affichée en orange. Elle est limitée à 45°\/s comme spécifié " }, 
{ "title" : "Structure de la demande ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234546899564", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Implémentation d'un bloc fonctionnel de prétraitement de chemin \/ Structure de la demande ", 
"snippet" : "La structure est typique des applications CNC. Le code G est lu dans la tâche d'arrière-plan et le prétraitement du chemin a également lieu ici. L'interpolation est effectuée dans la tâche du bus Le LimitTangentVelocity Un bloc fonctionnel affiche les étapes et les états nécessaires pour un bloc fon...", 
"body" : "La structure est typique des applications CNC. Le code G est lu dans la tâche d'arrière-plan et le prétraitement du chemin a également lieu ici. L'interpolation est effectuée dans la tâche du bus Le LimitTangentVelocity Un bloc fonctionnel affiche les étapes et les états nécessaires pour un bloc fonctionnel de prétraitement de chemin. Le principe de base est que le bloc fonctionnel lit, traite puis écrit les éléments du chemin (type SMC_GEOINFO ) depuis la file d'entrée ( poqDataIn ) vers la file d'attente de sortie ( poqDataOut ). Les éléments sont supprimés de la file d'attente d'entrée. La logique permettant de modifier le débit d'alimentation se trouve dans les lignes 102 à 138. La fonction auxiliaire ComputeMaxCurvature calcule la courbure maximale qui peut apparaître sur un élément de trajectoire donné. \/\/ Our velocity limitation comes here. This modifies an element from the\n\/\/ input queue and copies the modified element to the output queue.\n\/\/ Finally, the element is removed from the input queue\n\nm_geo := pgeo^; \/\/ Copy the element\n \/\/ Note: the feature flags set in the G-Code with G38\/G39 can be queried\n \/\/ by reading pgo^.dwFeatureFlags, like this:\n IF (SHR(m_geo.dwFeatureFlags, featureFlag) AND 1) = 1 THEN\n     \/\/ feature is turned on\n\n     ok := ComputeMaxCurvature(m_geo, kappa=> kappa_max);\n     IF NOT ok THEN\n         \/\/ Curvature cannot be computed\n         m_state := STATE_ERROR;\n         ErrorID := SMC_INVALID_PARAMETER;\n         OnExit();\n         RETURN;\n     END_IF\n\n     \/\/ Compute maximum allowed path velocity based on maximum curvature\n     \/\/ and maximum allowed angular velocity\n     IF kappa_max = 0 THEN\n         \/\/ No curvature, no limitation necessary\n         vel := m_geo.dVel;\n     ELSE\n         vel := m_maxAngularVelocity_rad \/ kappa_max;\n     END_IF\n\n     IF velMin < 0 OR vel < velMin THEN\n         velMin := vel;\n     END_IF\n\n     \/\/ Set new maximum velocity for the element\n     m_geo.dVel := MIN(m_geo.dVel, vel);\n ELSE\n     \/\/ feature is turned off\n END_IF " }, 
{ "title" : "Mise en service ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234584108811", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Implémentation d'un bloc fonctionnel de prétraitement de chemin \/ Mise en service ", 
"snippet" : "Créez l'application et téléchargez-la sur une manette. Démarrez l'application. Ouvrez la trace et téléchargez-la sur le contrôleur. Écrivez la valeur TRUE aux variables Path.bExecute et PLC_PRG.bStart . Vous pouvez suivre le traitement du code G dans la trace....", 
"body" : "Créez l'application et téléchargez-la sur une manette. Démarrez l'application. Ouvrez la trace et téléchargez-la sur le contrôleur. Écrivez la valeur TRUE aux variables Path.bExecute et PLC_PRG.bStart . Vous pouvez suivre le traitement du code G dans la trace. " }, 
{ "title" : "Prétraitement de fichiers G-Code volumineux ", 
"url" : "_sm_example_large_c_code.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Prétraitement de fichiers G-Code volumineux ", 
"snippet" : "Le CNC15_LargeGCode.project un exemple de projet se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . L'exemple de projet montre comment traiter des fichiers de code G volumineux. Étant donné que les fichiers très volumineux sont particulièrement courants en s...", 
"body" : "Le CNC15_LargeGCode.project un exemple de projet se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . L'exemple de projet montre comment traiter des fichiers de code G volumineux. Étant donné que les fichiers très volumineux sont particulièrement courants en sortie de systèmes CAD\/CAM, ce cas est illustré à titre d'exemple systèmes CAD\/CAM génèrent souvent des fichiers de code G de plusieurs centaines de milliers de lignes. Il s'agit de segments linéaires très courts ( G1 ), généralement de l'ordre de 100 micromètres à un millimètre. Ces courts segments linéaires tracent le contour de la pièce. Ils ne forment pas un chemin fluide. La tangente saute généralement entre les segments linéaires L'exemple montre comment lire ces fichiers volumineux de manière efficace avec des besoins de mémoire constants et comment obtenir une courbe de vitesse lisse sur une trajectoire composée de nombreux segments linéaires courts. Le contour d'origine de la pièce est reconstruit lors du prétraitement du code G. " }, 
{ "title" : "Structure de la demande ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231424931037", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Prétraitement de fichiers G-Code volumineux \/ Structure de la demande ", 
"snippet" : "La structure est typique des applications CNC. Le code G est lu dans la tâche d'arrière-plan PathTask ), et le prétraitement des chemins a également lieu ici. L'interpolation est effectuée dans la tâche du bus MainTask )....", 
"body" : "La structure est typique des applications CNC. Le code G est lu dans la tâche d'arrière-plan PathTask ), et le prétraitement des chemins a également lieu ici. L'interpolation est effectuée dans la tâche du bus MainTask ). " }, 
{ "title" : "Lecture de fichiers volumineux ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425324995", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Prétraitement de fichiers G-Code volumineux \/ Lecture de fichiers volumineux ", 
"snippet" : "Afin de réduire la latence au début du traitement du code G, une boucle est utilisée dans la tâche d'arrière-plan. Par souci de simplicité, un compteur est utilisé pour la condition d'interruption. En fonction de l'application, du code G et des performances de l'automate, d'autres conditions d'inter...", 
"body" : "Afin de réduire la latence au début du traitement du code G, une boucle est utilisée dans la tâche d'arrière-plan. Par souci de simplicité, un compteur est utilisé pour la condition d'interruption. En fonction de l'application, du code G et des performances de l'automate, d'autres conditions d'interruption, telles qu'un minuteur, peuvent être utiles. La boucle se terminera avant d'atteindre cette condition d'abandon lorsque la file d'attente des chemins est pleine \/\/ Set this value depending on your other tasks, PLC performance, and G-Code\ncounter := 25;\n\nWHILE counter > 0 AND\n      (poqDataOut = 0 OR_ELSE (NOT poqDataOut^.bFull AND NOT poqDataOut^.bEndOfList))\nDO\n     <Read G-Code and process it>\n\n     counter := counter - 1;\nEND_WHILE Au moyen de canalisations dans le prétraitement , même les très gros fichiers de code G peuvent être lus avec des besoins de mémoire faibles et constants. Les tailles de file d'attente sont choisies de manière à être suffisamment grandes pour permettre aux blocs fonctionnels respectifs de prévoir suffisamment. La file d'attente de sortie de SMC_NCInterpreter est également la file d'attente d'entrée de SMC_SmoothMerge . Au total, 128+3 éléments sont réservés à la file d'attente de sortie. 3 est une réserve du SMC_OutQueue et 128 restent à utiliser comme prévisions pour SMC_SmoothMerge . SMC_SmoothMerge combine un maximum de 128 segments linéaires courts en une seule spline. La file d'attente de sortie de SMC_SmoothMerge est également la file d'attente d'entrée de SMC_SmoothPath . SMC_SmoothPath nécessite au moins 2 éléments, plus une réserve de 3 éléments, comme prévision. Si les fonctions M sont situées entre deux éléments lissés, d'autres éléments sont nécessaires en fonction du nombre de La file d'attente de sortie de SMC_SmoothMerge est également la file d'attente d'entrée de SMC_Interpolator . Une prévision de 100 éléments convient à la plupart des applications. Pour plus d'informations, consultez les rubriques suivantes : Prétraitement des chemins et tailles des files d'attente. \/\/\/ Buffer of the interpreter, lookahead for SMC_SmoothMerge\naBufIp : ARRAY[0..130] OF SMC_GeoInfo;\n\/\/\/ Buffer of SMC_SmoothMerge\naBufSmm : ARRAY[0..15] OF SMC_GeoInfo;\n\/\/\/ Buffer of SMC_SmoothPath, lookahead for SMC_Interpolator\naBufSmp : ARRAY[0..99] OF SMC_GeoInfo; " }, 
{ "title" : "Prétraitement de segments linéaires ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425764624", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Prétraitement de fichiers G-Code volumineux \/ Prétraitement de segments linéaires ", 
"snippet" : "Le SMC_SmoothMerge Le bloc fonctionnel assure une courbe de vitesse régulière sur les nombreux segments linéaires très courts. Il combine autant de segments linéaires consécutifs que possible en une seule spline, tout en maintenant les tolérances spécifiées. Dans cet exemple, un écart maximal de 0,1...", 
"body" : "Le SMC_SmoothMerge Le bloc fonctionnel assure une courbe de vitesse régulière sur les nombreux segments linéaires très courts. Il combine autant de segments linéaires consécutifs que possible en une seule spline, tout en maintenant les tolérances spécifiées. Dans cet exemple, un écart maximal de 0,1 mm en X et Y est autorisé ( PARAMETERS.piMaxDifference ). Les figures montrent le traitement étape par étape : Lecture des segments linéaires courts Combiner plusieurs segments linéaires en splines à l'aide de SMC_SmoothMerge . Lissage entre les cannelures avec SMC_SmoothPath car, comme on l'a vu plus haut, les splines ne se connectent pas tangentiellement les unes aux autres. " }, 
{ "title" : "Mise en service ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425998344", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Prétraitement de fichiers G-Code volumineux \/ Mise en service ", 
"snippet" : "Créez l'application et téléchargez-la sur une manette. Ouvrez la trace et téléchargez-la sur le contrôleur. Démarrez l'application. Vous pouvez suivre le traitement du code G....", 
"body" : "Créez l'application et téléchargez-la sur une manette. Ouvrez la trace et téléchargez-la sur le contrôleur. Démarrez l'application. Vous pouvez suivre le traitement du code G. " }, 
{ "title" : "Exemple CNC 16 : fonction de sondage (distance restante nette) (G31) ", 
"url" : "_sm_example_cnc_16.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 16 : fonction de sondage (distance restante nette) (G31) ", 
"snippet" : "Consultez les CNC16_G31.project exemple de projet dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . L'exemple de projet montre comment utiliser la fonction de sondage (distance restante nette). Dans l'exemple, la machine se déplace dans la direction X jusqu'à ce qu'u...", 
"body" : "Consultez les CNC16_G31.project exemple de projet dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . L'exemple de projet montre comment utiliser la fonction de sondage (distance restante nette). Dans l'exemple, la machine se déplace dans la direction X jusqu'à ce qu'une barrière lumineuse soit atteinte à X=50 . Dès que la barrière lumineuse est atteinte, la machine doit s'arrêter. Le code G restant doit être traité à partir de cette position " }, 
{ "title" : "Structure de la demande ", 
"url" : "_sm_example_cnc_16.html#UUID-78892014-10dd-8256-9708-05f2d78a2884_section-id235224424924168", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 16 : fonction de sondage (distance restante nette) (G31) \/ Structure de la demande ", 
"snippet" : "La structure est typique des applications CNC. Le code G est lu dans la tâche d'arrière-plan PathTask ). Le prétraitement des chemins est également effectué dans le cadre de cette tâche. L'interpolation est effectuée dans la tâche du bus MainTask ). Le code G suivant est utilisé. En bloc N10 , un po...", 
"body" : "La structure est typique des applications CNC. Le code G est lu dans la tâche d'arrière-plan PathTask ). Le prétraitement des chemins est également effectué dans le cadre de cette tâche. L'interpolation est effectuée dans la tâche du bus MainTask ). Le code G suivant est utilisé. En bloc N10 , un positionnement rapide est effectué pour X = 20 . Ensuite, avec G31 (fonction de sondage : dégagement du chemin restant), un mouvement est effectué X = 100 . Enfin, en bloc N30 , un mouvement linéaire est effectué pour X = 20, Y = 50 . N10 G0 X20 F100 E1000 E-1000\nN20 G31 X100\nN30 G1 X20 Y50 L'interaction entre l'interpolateur et l'interpréteur est particulièrement importante pour la fonction de sondage (chemin restant clair). L'interpréteur décode le code G et génère une ligne droite à partir de X=20 à X=100 pour bloc N20 . Ensuite, le décodage s'arrête L'interpolateur effectue le mouvement linéaire et émet simultanément le numéro de sonde en sortie udiActProbe . Pour le G31, le numéro d'échantillon est toujours 1 Dans l'application, l'interpolateur est arrêté avec bQuick_Stop dès que le lecteur dépasse sa position X=50 . (Cela simule la barrière lumineuse. Dans le cadre de la tâche relative au bus, SMC_SetInterpreterStartPosition le bloc fonctionnel est utilisé pour copier en continu la position actuelle de la machine. Dans le PathTask , la position de départ est affectée à l'entrée SMC_NCInterpreter.piStartPosition : inter(\n    sentences:= read.sentences,\n    bExecute:= read.bExecute,\n    nSizeOutQueue:= SIZEOF(bufIpo),\n    pbyBufferOutQueue:= ADR(bufIpo),\n    piStartPosition:= Main.setStart.StartPos); Dès que l'interpolateur est arrêté, bAcknProbe l'entrée est utilisée pour accuser réception de la commande G31. Dans une application réelle, il convient également de vérifier à ce stade que les axes ont bien atteint la position d'arrêt. SMC_En position un bloc fonctionnel peut être utilisé pour ce faire. Cela amène l'interpréteur à reprendre le décodage, mais avec la position de départ mise à jour, de sorte que le bloc suivant N30 est démarré à partir de la position X=55.5 . Le schéma suivant illustre ces étapes. Les chiffres entre parenthèses font référence aux étapes correspondantes du processus décrit ci-dessus. " }, 
{ "title" : "Mise en service ", 
"url" : "_sm_example_cnc_16.html#UUID-78892014-10dd-8256-9708-05f2d78a2884_section-id235224425037675", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 16 : fonction de sondage (distance restante nette) (G31) \/ Mise en service ", 
"snippet" : "Créez l'application et téléchargez-la sur une manette. Ouvrez la trace et téléchargez-la sur le contrôleur. Démarrez l'application et ouvrez la visualisation....", 
"body" : "Créez l'application et téléchargez-la sur une manette. Ouvrez la trace et téléchargez-la sur le contrôleur. Démarrez l'application et ouvrez la visualisation. " }, 
{ "title" : "Exemple CNC 17 : lire le code G à partir de chaînes ", 
"url" : "_sm_example_cnc_17.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 17 : lire le code G à partir de chaînes ", 
"snippet" : "Consultez les CNC17_ReadGCodeFromStrings.project exemple de projet dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . L'exemple de projet montre comment utiliser SMC_StringStream 2 pour lire le code G à partir d'une chaîne. Cet exemple peut être considéré comme un poi...", 
"body" : "Consultez les CNC17_ReadGCodeFromStrings.project exemple de projet dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . L'exemple de projet montre comment utiliser SMC_StringStream 2 pour lire le code G à partir d'une chaîne. Cet exemple peut être considéré comme un point de départ et utilisé pour lire le code G à partir d'autres sources, par exemple via une communication réseau (sockets). Dans ce cas, un bloc fonctionnel doit être implémenté qui implémente le SMC_ITextStream interface et lit le texte (par exemple, à partir d'un socket). Ceci est similaire à la façon dont SMC_StringStream2 implémente cette interface pour lire le code G à partir d'une chaîne. " }, 
{ "title" : "Structure de la demande ", 
"url" : "_sm_example_cnc_17.html#UUID-7c947453-e422-10bd-3720-9f55e7b54f9f_section-id235224424924168", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 17 : lire le code G à partir de chaînes \/ Structure de la demande ", 
"snippet" : "La structure est typique des applications CNC. Le code G est lu dans la tâche d'arrière-plan PathTask ), et le prétraitement des chemins a également lieu ici. L'interpolation est effectuée dans la tâche du bus Dans le Path programme, le SMC_ReadNCFromStream bloc fonctionnel est utilisé pour lire le ...", 
"body" : "La structure est typique des applications CNC. Le code G est lu dans la tâche d'arrière-plan PathTask ), et le prétraitement des chemins a également lieu ici. L'interpolation est effectuée dans la tâche du bus Dans le Path programme, le SMC_ReadNCFromStream bloc fonctionnel est utilisé pour lire le code G. Pour des raisons techniques, pas seulement un flux de type SMC_StringStream2 est passé à ce bloc de fonction, mais également à un tableau dont la taille dépend du paramètre SMC_CNC_LibParams.MAX_SUBPROGRAM_NESTING_DEPTH . Le premier flux du tableau est utilisé pour le programme principal, tandis que les autres flux sont utilisés pour d'éventuels appels de sous-programmes Au début, le programme principal est chargé dans le premier flux du tableau : \/\/ Load G-Code into first stream\naStringStream[0].Init(sProgramName) ;\naStringStream[0].AppendData(sGCode) ;\naStringStream[0].SetEndOfData() ; Ensuite, tout est prêt pour la lecture des programmes de code G habituels. L'exemple montre également comment les appels de sous-programmes peuvent être pris en charge Pour cela, il est nécessaire de créer un bloc fonctionnel qui implémente le SMC_INCLookup interface. Ce bloc fonctionnel est chargé de renvoyer le code G d'un sous-programme lorsqu'il est lu SMC_ReadNCFromStream . Lookup La méthode reçoit le nom du sous-programme et initialise un flux entrant avec le code G : METHOD LookUp : SMC_ERROR\nVAR_IN_OUT CONSTANT\n    programName : STRING;\nEND_VAR\nVAR_INPUT\n    stream : SMC_ITextStream;\nEND_VAR\nVAR\n    i : UDINT ;\n    pStringStream : POINTER TO SMC_StringStream2 ;\nEND_VAR Cet exemple permet d'effectuer une recherche dans un tableau de sous-programmes. Le tableau est défini dans Path programme en tant que VAR_INPUT : \/\/ The table of subprograms.\n aSubs : ARRAY[0..0] OF SubProgram := [\n            (stName := 'SUB1',\n             stContent := '\nSUBPROGRAM SUB1{#p1 : LREAL, #p2 : LREAL, #p3 : LREAL}\nN10 G1 X#p1\nN20 G1 X#p2\nN30 G1 X#p3\nEND_SUBPROGRAM')\n        ] ; Dans Lookup , le tableau est itéré jusqu'à ce qu'un sous-programme portant le même nom soit trouvé : i := 0 ;\nWHILE i < nNumSPs DO\n IF psp[i].stName = programName THEN\n IF NOT __QUERYPOINTER(stream, pStringStream) OR_ELSE\n pStringStream = 0\n THEN\n \/\/ A stream of the wrong type has been passed by SMC_ReadNCFromStream.\n LookUp := SMC_CNC_INTERNAL_ERROR ;\n ELSE\n pStringStream^.Init(sName := psp[i].stName) ;\n LookUp := pStringStream^.AppendData(psp[i].stContent) ;\n pStringStream^.SetEndOfData() ;\n END_IF\n RETURN ;\n END_IF\n\n i := i + 1 ;\nEND_WHILE\n \n\/\/ No subprogram with name programName has been found in the array psp.\nLookUp := SMC_RNCF_SUBPROGRAM_FILE_NOT_FOUND ; " }, 
{ "title" : "Mise en service ", 
"url" : "_sm_example_cnc_17.html#UUID-7c947453-e422-10bd-3720-9f55e7b54f9f_section-id235224425037675", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 17 : lire le code G à partir de chaînes \/ Mise en service ", 
"snippet" : "Créez l'application et téléchargez-la sur une manette. Ouvrez la visualisation. Presse Commencer pour démarrer le traitement du code G....", 
"body" : "Créez l'application et téléchargez-la sur une manette. Ouvrez la visualisation. Presse Commencer pour démarrer le traitement du code G. " }, 
{ "title" : "Exemple CNC 10 : Programmation de trajectoires CNC dynamiques ", 
"url" : "_sm_example_dynamic_path.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Exemple CNC 10 : Programmation de trajectoires CNC dynamiques ", 
"snippet" : "Voir le CNC10_DynamicPath.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment un chemin CNC peut être créé directement dans l'application au moment de l'exécution - sans être alimenté avec du code G à partir...", 
"body" : "Voir le CNC10_DynamicPath.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment un chemin CNC peut être créé directement dans l'application au moment de l'exécution - sans être alimenté avec du code G à partir d'un objet de programme CNC ou d'un fichier. Lorsque ce type de programme CNC conventionnel est compilé, les données de chemin sont stockées dans un SMC_CNC_Data type de structure de données. Ces données internes sont ensuite compilées dans des structures de données globales spécifiques selon le mode de compilation ( SMC_CNC_REF ou SMC_OutQueue ). En mode compilation SMC_CNC_REF , les données sont stockées dans un tableau de SMC_GEOINFO éléments. Le tableau dans le code de l'application est généralement transmis à l'instance du bloc fonction SMC_NCDecoder . A l'exécution, les données y sont décodées et stockées dans une structure de données globale de type SMC_OUTQUEUE . Ensuite, les blocs fonctionnels de prétraitement de chemin peuvent être appelés. En mode compilation SMC_OutQueue , une structure de données globale ( SMC_OUTQUEUE ) est généré directement . Cette structure de données dans le code de l'application est transmise à l'interpolateur ( SMC_Interpolator instance FB). Le bloc fonction SMC_NCDecoder ne s'appelle pas. En mode compilation DÉPOSER , les données sont stockées dans un fichier. Les données sont stockées sous la forme d'un tableau d'éléments de type SMC_GEOINFO et correspondent aux données générées en mode compilation SMC_CNC_REF . Au lieu de programmer le chemin CNC, vous pouvez programmer un code d'application qui instancie une structure de données de type SMC_OUTQUEUE au moment de l'exécution et attribue ses valeurs. Vous programmez une trajectoire CNC qui est générée dynamiquement lors de l'exécution. Vous pouvez transmettre la structure de données à d'autres instances de blocs fonctionnels (par exemple aux blocs fonctionnels de prétraitement de chemin ou au bloc fonctionnel SMC_Interpolator ). La programmation le CNCDynamicPath exemple de projet se trouve dans le répertoire d'installation de CODESYS . L'exemple de projet a été élaboré à partir du CNConline projet. Il comprend le Path programme au lieu de la programmation graphique Example chemin. Une structure de données de type SMC_OUTQUEUE est généré dynamiquement. Déclaration: Déclarer une structure de données de type SMC_OUTQUEUE . La structure de données contient les données de trajectoire CNC et est renseignée dynamiquement. Exemple: QUEUE Allouez de la mémoire pour le chemin avec la quantité requise pour SMC_GEOINFO éléments. Exemple: BUF Déclarer une variable de type SMC_GEOINFO avec une première étape. Exemple: GEO Mise en œuvre: Un élément de tableau de type de données SMC_GEOINFO correspond à un élément de chemin dans le code CNC. Les étapes suivantes doivent être effectuées pour chaque élément afin d'ajouter l'élément au SMC_OUTQUEUE : Chaque élément de tableau a une position de début qui correspond à la position de fin de l'élément de tableau précédent. Exemple: GEO.piStartPos.dX := 0; ou GEO.piStartPos := GEO.piDestPos; Déterminez un type de mouvement pour chaque élément du tableau. Exemple: GEO.iMoveType := CCLW; ou GEO.iMoveType := LIN; Définissez les paramètres du type de mouvement. Ceci n'est pas obligatoire pour tous les types de mouvement. Exemple : Pour un arc (type de mouvement : CCLW), le réglage des positions suivantes est requis : geoinfo_A[i].dP1 := 200; geoinfo_A[i].dP2 := 100; geoinfo_A[i].dP3 := 50; geoinfo_A[i].dT1 := 0; geoinfo_A[i].dT2 := 90; Insérez le calcul de la position finale. SMC_CalcEndPnt(ADR(GEO)); Insérez le calcul de la longueur de l'objet. SMC_CalcLengthGeo(ADR(GEO)); Enregistrez l'objet dans QUEUE : SMC_AppendObj(POQ:=ADR(QUEUE), PGI:=ADR(GEO)); Lorsque le chemin est entièrement créé, les marqueurs de fin doivent être définis : QUEUE.bEndOfList := TRUE; Ensuite, lorsqu'un bloc fonction de prétraitement de chemin est appelé, il est nécessaire de définir le bit de début ou de fin pour InternMark . Exemple Chemin CNC avec deux éléments de chemin Dans cet exemple, les tableaux ne sont pas définis avec les positions X\/Y. S'il s'agissait d'un exemple avec deux éléments de chemin comme décrit, alors ces tableaux devraient avoir deux éléments chacun. Par exemple, dérivé de l'exemple de projet : xp:ARRAY[1..2] OF REAL:= [100,50]; yp:ARRAY[1..2] OF REAL:= [0,100]; PROGRAM Path\nVAR\n iState : INT;\n QUEUE : SMC_OUTQUEUE;\n BUF : ARRAY[0..49] OF SMC_GEOINFO;\n \/\/ Memory allocation\n GEO : SMC_GEOINFO:=(dT1:=0, dT2:=1, dToolRadius:=0, dVel:=100, dVel_End:=100, dAccel:=200, dDecel:=500, iObj_Nr:=0);\n \/\/ Initial path element\n n : INT := 0;\n QUEUE.nSize := SIZEOF(BUF);\nEND_VAR\n\nCASE iState OF\n0:\n QUEUE.pbyBuffer := ADR(BUF[0]);\n \/\/ Initialize QUEUE\n SMC_SetQueueCapacity(ADR(QUEUE), SIZEOF(BUF));\n iState := iState + 1;\n\n1:\n \/\/ Fill QUEUE\n WHILE NOT QUEUE.bFull DO\n \/\/ When QUEUE is full, wait until it has been processed by the following FBs\n n := n + 1;\n GEO.iSourceLine_No := n;\n GEO.piStartPos := GEO.piDestPos;\n \/\/ Copying last destination\n GEO.iMoveType := LIN;\n \/\/ Generating linear movement\n GEO.iObjNo := GEO.iObjNo + 1;\n \/\/ Calculating number\n GEO.piDestPos.dX := xp[n];\n \/\/ Generatint position\n GEO.piDestPos.dY := yp[n];\n SMC_CalcLengthGeo(pg := ADR(GEO));\n \/\/ Calculating length of object with the help of the standard function\n SMC_AppendObj(poq:=ADR(QUEUE), pgi:=ADR(GEO));\n \/\/ Appending object to QUEUE\n IF n = SIZEOF(xp)\/SIZEOF(xp[1]) THEN\n \/\/ All target positions processed\n QUEUE.bEndOfList := TRUE;\n n := 0;\n iState := 2;\n EXIT;\n END_IF\n END_WHILE\n\n2:\n \/\/Done\n ;\nEND_CASE\n\nCheckVel(bExecute:=TRUE , poqDataIn:=ADR(queue)); \/\/ Preprocessing Si la SMC_OUTQUEUE la structure de données est remplie avec SMC_GEOINFO data et l'élément de structure de données a été défini sur bFULL = TRUE , alors nous ne recommandons pas une autre affectation de SMC_GEOINFO Les données. Dans ce cas, la création du chemin est interrompue à l'exécution jusqu'à ce que le premier élément du SMC_OUTQUEUE la structure des données est traitée dans l'interpolateur. Ce n'est qu'alors qu'un autre élément est inséré. Évitez cette interruption en allouant suffisamment de mémoire. Voir variable BUF . Si la structure de données SMC_OUTQUEUE est rechargé après la première exécution, puis l'interpolateur et tous les blocs fonction de prétraitement (exemple : SMC_CheckVelocities ) doivent être redémarrés par un front montant à Execute . " }, 
{ "title" : "Utilisation de la recherche de bloc ", 
"url" : "_sm_example_using_block_search.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Utilisation de la recherche de bloc ", 
"snippet" : "Une recherche de bloc permet de poursuivre l'interpolation après une interruption. La position d'arrêt est parcourue en premier et la trajectoire est parcourue sans changement à partir de cette position. Pour cela, le programme qui effectue l'interpolation et le programme qui effectue le prétraiteme...", 
"body" : "Une recherche de bloc permet de poursuivre l'interpolation après une interruption. La position d'arrêt est parcourue en premier et la trajectoire est parcourue sans changement à partir de cette position. Pour cela, le programme qui effectue l'interpolation et le programme qui effectue le prétraitement du chemin doivent être étendus. Exemple Une tête de fraisage interrompue arrête la course. Après avoir été réparé, le chemin peut être poursuivi avec la recherche de bloc. Prolongez l'application en Instance de bloc fonction dans la tâche d'interpolation qui enregistre la position de prétraitement Instance de bloc fonction dans la tâche de chemin qui raccourcit un élément de chemin Pour plus d'informations, voir : SMC_BlockSearchSavePos, SMC_BlockSearchPos et SMC_BlockSearch Utiliser la recherche de bloc Un exemple de SMC_BlockSearch le bloc de fonction doit être appelé dans la même tâche que le prétraitement du chemin restant, généralement juste avant le SMC_CheckVelocities bloc fonctionnel. Si un front montant existe à bExecute , une recherche de bloc est effectuée. Après le démarrage, la position enregistrée est parcourue et la trajectoire est parcourue sans modification à partir de cette position. Déclarer une instance du SMC_BlockSearch bloc fonctionnel dans le programme que le prétraitement de chemin exécute. bs: SMC_BlockSearch; Mettre en œuvre le déclenchement de la bExecute entrée de la SMC_BlockSearch exemple. La position enregistrée précédemment avec le SMC_BlockSearchSavePos bloc de fonction doit être transmis en tant que epos entrée de la SMC_BlockSearch bloc fonctionnel. Exemple : recherche de blocs dans le prétraitement du chemin PROGRAM CNC_PreparePath\n...\nVAR\n bs: SMC_BlockSearch;\nEND_VAR\n...\nbs(\n ePos:=CNC.bssp.ePos ,\n bExecute:=rncf.bExecuteDecoder ,\n bAbort:= ,\n bAppend:= ,\n poqDataIn:=ncd.poqDataOut ,\n bStartFromSavedPos:=CNC.bssp.bPositionStored ,\n nSizeOutQueue:=SIZEOF(agiBufBlockSearch) ,\n pbyBufferOutQueue:=ADR(agiBufBlockSearch) ,\n bDone=> ,\n bBusy=> ,\n bError=> ,\n wErrorID=> ,\n poqDataOut=> ); Les bStartFromSavedPos l'entrée peut également être activée avec une variable de contrôle. La variable de contrôle peut être activée après une annulation afin de continuer à nouveau à la dernière position enregistrée. " }, 
{ "title" : "Enregistrement de la position de prétraitement ", 
"url" : "_sm_example_using_block_search.html#UUID-c7e93ecd-388f-baf1-4162-0ba994d84585_id_defc89f86dbffeecc0a86463490ce87e_id_04188a3f3bea4adbc0a8640e000b4984", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Utilisation de la recherche de bloc \/ Enregistrement de la position de prétraitement ", 
"snippet" : "Vous pouvez utiliser le SMC_BlockSearchSavePos bloc fonction de sauvegarde de la position courante sur commande. A ce moment, l'instance du bloc fonction doit s'exécuter dans la tâche de l'interpolateur. Le programme d'interpolation dans l'exemple est nommé \"CNC\". Déclarer une instance du SMC_BlockS...", 
"body" : "Vous pouvez utiliser le SMC_BlockSearchSavePos bloc fonction de sauvegarde de la position courante sur commande. A ce moment, l'instance du bloc fonction doit s'exécuter dans la tâche de l'interpolateur. Le programme d'interpolation dans l'exemple est nommé \"CNC\". Déclarer une instance du SMC_BlockSearchSavePos bloc fonction dans le programme que l'interpolation exécute. bssp: SMC_BlockSearchSavePos; Connectez le ipo entrée de la SMC_BlockSearchSavePos instance à l'instance d'interpolateur. Connectez le bExecute entrée dans une variable de contrôle qui est définie dans l'application lorsque le programme CNC est annulé (par exemple si le bAbort l'entrée de l'instance SMC_Interpolator a été définie). La position mémorisée au ePos la sortie est utilisée comme suit pour la recherche de bloc au moyen de SMC_BlockSearc . Après interruption, bExecute doit être réinitialisé avec un front montant. Exemple Partie du programme qui effectue l'interpolation avec l'instance du SMC_BlockSearchSavePos bloc fonctionnel dans CFC. " }, 
{ "title" : "ReadNCFile2 avec Token Modificateur ", 
"url" : "_sm_example_readncfile2_token_modifier.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ ReadNCFile2 avec Token Modificateur ", 
"snippet" : "Le CNC12_TokenModifier.project un exemple de projet se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment modifier le code G lors de l'importation afin de convertir l'unité de vitesse de trajectoire (mot F) de mm\/min en mm\/s. Pour ce ...", 
"body" : "Le CNC12_TokenModifier.project un exemple de projet se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment modifier le code G lors de l'importation afin de convertir l'unité de vitesse de trajectoire (mot F) de mm\/min en mm\/s. Pour ce faire, insérez le code G 1\/60.0 * avant la valeur de vitesse pendant la lecture du code G du mot F. F6000 devient alors F 1\/60.0 * 6000 , qui est ensuite traitée par le SMC_NCInterpreter bloc de fonctions pour F100 . Dans les cas simples, vous pouvez ignorer la multiplication par 1\/60 et ajustez simplement la valeur (par exemple, à partir de 6000 à 100 ). Cependant, la multiplication est plus générale car elle fonctionne également lorsque des variables sont utilisées. F $SPEED$ devient F 1\/60.0 * $SPEED$ . " }, 
{ "title" : "Structure de la demande ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869818233271", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ ReadNCFile2 avec Token Modificateur \/ Structure de la demande ", 
"snippet" : "Comme d'habitude pour les applications CNC, l'application consiste en un traitement de trajectoire ( CNC_PreparePath programme) et interpolation ( CNC programme). Comme l'interpolation n'est pas différente des autres exemples, elle ne sera pas abordée plus Le traitement des chemins est appelé cycliq...", 
"body" : "Comme d'habitude pour les applications CNC, l'application consiste en un traitement de trajectoire ( CNC_PreparePath programme) et interpolation ( CNC programme). Comme l'interpolation n'est pas différente des autres exemples, elle ne sera pas abordée plus Le traitement des chemins est appelé cycliquement toutes les 20 ms en basse priorité PathTask . L'interpolation est appelée cycliquement toutes les 4 ms MotionTask . La tâche d'arrière-plan VISU_TASK est défini pour la visualisation. Vous pouvez commencer à traiter le code G dans la visualisation. Le code G et le mouvement de la machine (portique 3D) sont affichés sur le côté droit de la visualisation " }, 
{ "title" : "Le code G ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869818432406", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ ReadNCFile2 avec Token Modificateur \/ Le code G ", 
"snippet" : "CNC_PathSpeed N10 G01 X1000 F6000 N20 Y1000 Dans ce code G, la vitesse de trajet en bloc N10 est défini avec F6000 jusqu'à 6000 mm\/min. Cependant, les blocs fonctionnels CNC s'attendent à une vitesse de trajectoire en mm\/s. Deux mouvements linéaires sont commandés, le premier X=1000 puis à X=1000, Y...", 
"body" : "CNC_PathSpeed N10 G01 X1000 F6000\nN20 Y1000 Dans ce code G, la vitesse de trajet en bloc N10 est défini avec F6000 jusqu'à 6000 mm\/min. Cependant, les blocs fonctionnels CNC s'attendent à une vitesse de trajectoire en mm\/s. Deux mouvements linéaires sont commandés, le premier X=1000 puis à X=1000, Y=1000 . " }, 
{ "title" : "Traitement des jetons ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869819460923", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ ReadNCFile2 avec Token Modificateur \/ Traitement des jetons ", 
"snippet" : "Le SMC_ReadNCFile2 et SMC_ReadNCFromStream les blocs de fonctions permettent d'effectuer vos propres transformations lorsque le code G est lu. Ici, nous utilisons avec le SMC_ITokenModifier interface, qui est transmise via aTokenModifier entrée. Cette interface fonctionne sur des « jetons ». Il s'ag...", 
"body" : "Le SMC_ReadNCFile2 et SMC_ReadNCFromStream les blocs de fonctions permettent d'effectuer vos propres transformations lorsque le code G est lu. Ici, nous utilisons avec le SMC_ITokenModifier interface, qui est transmise via aTokenModifier entrée. Cette interface fonctionne sur des « jetons ». Il s'agit des éléments de base du code G dans lesquels le texte du code G est subdivisé au démarrage du traitement Exemple N50 G36 O$plc_variable$ D'TextTest' X-1 (Comment) Ce code G est subdivisé comme suit : Texte SMC_TOKENTYPE SMC_TOKENVALUE N identifer stValue = 'N' 50 number fValue = 50.0 G identifer stValue = 'G' 36 number fValue = 36.0 O identifer stValue = 'O' $plc_variable$ variable stValue = 'plc_variable' D identifer stValue = 'D' 'TextTest' strLiteral stValue = 'TextTest' X identifer stValue = 'X' - operator stValue = '-' 1 number fValue = 1.0 Les informations qui ne sont pas nécessaires pour un traitement ultérieur (par exemple, les caractères d'espacement, les sauts de ligne et les commentaires) n'apparaissent pas dans la liste des jetons. Quand le SMC_ITokenModifier l'interface est implémentée, la liste des jetons peut être adaptée en ajoutant de nouveaux jetons, en supprimant des jetons et en modifiant les valeurs des jetons. L'interface définit deux méthodes : Start : Initialisation du bloc fonctionnel. L'état interne est réinitialisé. Call : appel de cette méthode pendant le traitement du code G. Les jetons peuvent être lus et supprimés de la file d'entrée et ajoutés à la file d'attente de sortie. " }, 
{ "title" : "Mise en œuvre ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869819739016", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ ReadNCFile2 avec Token Modificateur \/ Mise en œuvre ", 
"snippet" : "Le flux de traitement dans PLC_PRG est le suivant : Tous les jetons sont déplacés de la file d'entrée vers la file d'attente de sortie. Si un mot F est détecté, deux nouveaux jetons, 1\/60 et * , sont ajoutés après le jeton pour « F » et avant le jeton pour la valeur de vitesse. Le Call La méthode co...", 
"body" : "Le flux de traitement dans PLC_PRG est le suivant : Tous les jetons sont déplacés de la file d'entrée vers la file d'attente de sortie. Si un mot F est détecté, deux nouveaux jetons, 1\/60 et * , sont ajoutés après le jeton pour « F » et avant le jeton pour la valeur de vitesse. Le Call La méthode contient la logique pour traiter les jetons. Il est utile de déplacer d'abord les jetons de la file d'entrée ( tokensIn ) vers une file d'attente temporaire ( m_tmpQueue ), traitez-les là-bas, puis déplacez-les vers la file de sortie ( tokensOut ). La file d'attente temporaire n'est pas absolument nécessaire pour adapter la vitesse du trajet, mais elle simplifie la structure du programme dans les cas les plus complexes. Méthode : Appel Dans un premier temps, le système attend STATE_RUNNING état jusqu'à ce que le traitement puisse démarrer (lorsque des jetons sont disponibles dans la file d'entrée et qu'il reste de la place dans la file d'attente de sortie). IF NOT SMC_NC_CanProcessTokens(tokensIn, tokensOut) THEN\n    \/\/ Wait until processing can proceed\n    RETURN;\nEND_IF Ensuite, un jeton est déplacé de la file d'entrée vers la file d'attente temporaire. IF m_tmpQueue.IsEmpty() THEN\n    \/\/ Move the next token from the in-queue to the tmp-queue.\n  pt := tokensIn.GetFromStart(0);\n    m_tmpQueue.Append(pt^);\n    tokensIn.RemoveFirst();\nEND_IF Le traitement proprement dit est effectué dans ConvertSpeed méthode. IF NOT m_tmpQueue.IsEmpty() THEN\n    \/\/ The actual processing is done here\n    ConvertSpeed();\nEND_IF À la fin de la méthode, un jeton est déplacé de la file d'attente temporaire vers la file d'attente de sortie. Méthode : ConvertSpeed Le premier jeton de la file d'attente temporaire est vérifié. Si un identifiant avec la valeur F est trouvé, puis deux jetons supplémentaires sont ajoutés : le nombre 1\/60.0 et l'opérateur * . (La taille de la file d'attente temporaire est sélectionnée de telle sorte que deux jetons supplémentaires entrent dans la file d'attente en plus du jeton de la file d'entrée). tk := m_tmpQueue.GetFromStart(0)^;\n\nIF tk.tokenType = SMC_TokenType.identifier THEN\n tk.GetString(pbyString => pby, iSize => iSize);\n \/\/ 70 = ASCII code for F (path velocity)\n IF iSize = 1 AND pby^ = 70 THEN\n \/\/ Insert the number 1\/60\n SMC_Token_InitNumber(\n tk:= tkNumber,\n value:= 1\/60.0,\n srcPos:= tk.srcPos);\n m_tmpQueue.Append(tkNumber);\n\n \/\/ Insert operator '*' for multiplication\n SMC_Token_InitOperator(\n tk:= tkOperator,\n value:= '*',\n srcPos:= tk.srcPos);\n m_tmpQueue.Append(tkOperator);\n END_IF\nEND_IF " }, 
{ "title" : "Mise en service ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869820021001", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ ReadNCFile2 avec Token Modificateur \/ Mise en service ", 
"snippet" : "Créez l'application et téléchargez-la sur une manette. Démarrez l'application, passez à la visualisation et appuyez sur Start ....", 
"body" : "Créez l'application et téléchargez-la sur une manette. Démarrez l'application, passez à la visualisation et appuyez sur Start . " }, 
{ "title" : "Fonctions G-Code spécifiques à l'utilisateur ", 
"url" : "_sm_custom_g_code_functions.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Fonctions G-Code spécifiques à l'utilisateur ", 
"snippet" : "Le CNC11_CustomFunctions.project un exemple de projet se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment créer vos propres fonctions à utiliser dans des expressions en G-code. Pour plus d'informations sur les expressions et les fon...", 
"body" : "Le CNC11_CustomFunctions.project un exemple de projet se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment créer vos propres fonctions à utiliser dans des expressions en G-code. Pour plus d'informations sur les expressions et les fonctions du code G, consultez : Expressions. Vous y trouverez une liste de tous les opérateurs et fonctions pris en charge par défaut. L'exemple définit SEL opérateur de la norme IEC 61131-3 afin qu'il puisse également être utilisé en code G. " }, 
{ "title" : "Structure de la demande ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867931475267", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Fonctions G-Code spécifiques à l'utilisateur \/ Structure de la demande ", 
"snippet" : "Comme d'habitude pour les applications CNC, l'application consiste en un traitement de trajectoire ( CNC_PreparePath programme) et interpolation ( CNC programme). Comme l'interpolation ne diffère pas des autres exemples, le sujet ne sera pas abordé plus Le traitement des chemins est appelé cycliquem...", 
"body" : "Comme d'habitude pour les applications CNC, l'application consiste en un traitement de trajectoire ( CNC_PreparePath programme) et interpolation ( CNC programme). Comme l'interpolation ne diffère pas des autres exemples, le sujet ne sera pas abordé plus Le traitement des chemins est appelé cycliquement toutes les 20 ms en basse priorité PathTask . L'interpolation est appelée cycliquement toutes les 4 ms MotionTask . La tâche d'arrière-plan VISU_TASK est défini pour la visualisation. Dans la visualisation, vous pouvez commencer à traiter le code G et définir la valeur de la variable $LONGLINE$ . Le code G et le mouvement de la machine (portique 3D) sont affichés sur le côté droit de la visualisation " }, 
{ "title" : "Le code G ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867932695176", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Fonctions G-Code spécifiques à l'utilisateur \/ Le code G ", 
"snippet" : "CNC LET #WIDTH : LREAL N10 G36 O#WIDTH D SEL($LONGLINE$, 40, 110) N20 F50 E100 E-100 N30 G01 X#WIDTH Y#WIDTH Z#WIDTH\/2 N40 Y-#WIDTH N50 X-#WIDTH Z-#WIDTH\/2 N60 Y#WIDTH N70 X0 Y0 Z0 Ligne 1 : Déclaration de la variable locale #WIDTH de type LREAL . Ligne 2, bloc N10 : Affectation de la valeur de SEL(...", 
"body" : "CNC LET #WIDTH : LREAL\nN10 G36 O#WIDTH D SEL($LONGLINE$, 40, 110)\nN20 F50 E100 E-100\nN30 G01 X#WIDTH Y#WIDTH Z#WIDTH\/2\nN40 Y-#WIDTH\nN50 X-#WIDTH Z-#WIDTH\/2\nN60 Y#WIDTH\nN70 X0 Y0 Z0 Ligne 1 : Déclaration de la variable locale #WIDTH de type LREAL . Ligne 2, bloc N10 : Affectation de la valeur de SEL($LONGLINE$, 40, 110) à la variable #WIDTH . Si la valeur de la variable PLC $LONGLINE$ est TRUE , alors la valeur de l'expression est 110 ; sinon elle est 40. Dans les lignes suivantes, un rectangle avec un mouvement supplémentaire dans la direction Z est parcouru ; la longueur d'un côté du rectangle est 2*#WIDTH . " }, 
{ "title" : "Mise en œuvre de la SEL fonction ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867935164437", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Fonctions G-Code spécifiques à l'utilisateur \/ Mise en œuvre de la SEL fonction ", 
"snippet" : "Pour créer une fonction définie par l'utilisateur, vous devez écrire un bloc de fonction qui implémente le SMC_NC_IFunction interface. Pour plus d'informations, voir : Fonction SMC_NC_I . L'interface définit deux méthodes : GetSignature . Le type de retour, le nombre et les types d'arguments de la f...", 
"body" : "Pour créer une fonction définie par l'utilisateur, vous devez écrire un bloc de fonction qui implémente le SMC_NC_IFunction interface. Pour plus d'informations, voir : Fonction SMC_NC_I . L'interface définit deux méthodes : GetSignature . Le type de retour, le nombre et les types d'arguments de la fonction sont renvoyés ici. Dans cet exemple, SEL la fonction renvoie une valeur de type T_OTHER et possède 3 arguments de type T_BOOL , T_OTHER , et T_OTHER . T_OTHER représente n'importe quel type (soit T_BOOL , T_LREAL , ou T_STRING ]. Les 3 occurrences de T_OTHER doit être du même type. METHOD GetSignature\nVAR_OUTPUT\n    resultType : SMC_GVar_Type;\n    nNumArguments : UDINT;\n    pType : POINTER TO SMC_GVar_Type;\nEND_VAR\nVAR    argTypes : ARRAY[0..2] OF SMC_GVar_Type :=\n        [SMC_GVar_Type.T_BOOL,\n         SMC_GVar_Type.T_OTHER,\n         SMC_GVar_Type.T_OTHER];\nEND_VAR\n\nresultType := SMC_GVAR_Type.T_OTHER;\nnNumArguments := 3;\npType := ADR(argTypes); Call : Cette méthode est appelée lorsque le code G est en cours de traitement. Les arguments sont transmis via pa entrée. L'expression pa[0].argValue.bValue est utilisé pour accéder à la valeur booléenne du premier argument. En fonction du type du deuxième argument pa[1].argType , le résultat est la valeur de retour result.argType et le branchement vers une instruction CASE. METHOD Call\nVAR_IN_OUT\n    result : SMC_NC_GArgument;\nEND_VAR\nVAR_INPUT\n    pa : POINTER TO SMC_NC_GArgument;\nEND_VA\nRVAR_OUTPUT\n    eError : SMC_ERROR;\nEND_VAR\nVAR\n    g : BOOL;\nEND_VAR\n\ng := pa[0].argValue.bValue;\n\nresult.argType := pa[1].argType;\n\nCASE result.argType OF\nSMC_GVAR_Type.T_BOOL:\n    result.argValue.bValue := SEL(g, pa[1].argValue.bValue, pa[2].argValue.bValue);\n\nSMC_GVAR_Type.T_STRING:\n    result.argValue.sValue := SEL(g, pa[1].argValue.sValue, pa[2].argValue.sValue);\n\nSMC_GVAR_Type.T_LREAL:\n    result.argValue.fValue := SEL(g, pa[1].argValue.fValue, pa[2].argValue.fValue);\n\nELSE\n    eError := SMC_INVALID_PARAMETER;\nEND_CASE " }, 
{ "title" : "Configuration de SMC_ReadNCFile2 ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867956933133", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Fonctions G-Code spécifiques à l'utilisateur \/ Configuration de SMC_ReadNCFile2 ", 
"snippet" : "Une instance de CNC_Sel le bloc de fonction est créé dans le GVL_CNCFunctions liste globale de variables. Un tableau aCNCFunctions de longueur 1 est initialisée avec le nom et l'instance du bloc fonctionnel. Ce tableau est ensuite lié dans le tableau funTable de type SMC_NC_GFunctionTable . aCNCFunc...", 
"body" : "Une instance de CNC_Sel le bloc de fonction est créé dans le GVL_CNCFunctions liste globale de variables. Un tableau aCNCFunctions de longueur 1 est initialisée avec le nom et l'instance du bloc fonctionnel. Ce tableau est ensuite lié dans le tableau funTable de type SMC_NC_GFunctionTable . aCNCFunctions : ARRAY[0..0] OF SMC_NC_GFunction :=\n    [(stName:= 'SEL', iFunc:= GVL_CNCFunctions.g_Sel)];\n\nfunTable : SMC_NC_GFunctionTable :=\n    (numFunctions:= 1,     pFunction:= ADR(aCNCFunctions)) ; Enfin, ce tableau est transmis au SMC_ReadNCFile2 bloc fonctionnel : rncf2 : SMC_ReadNCFile2 := (bParenthesesAsComments:= FALSE);\n\n[...]\n\nrncf2(\n    bExecute:= TRUE,\n    sFileName:= sFileName,\n    pCustomFunTable:= ADR(funTable),\n    pvl:= ADR(varList)); " }, 
{ "title" : "Mise en service ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867960408693", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Exemples \/ Fonctions G-Code spécifiques à l'utilisateur \/ Configuration de SMC_ReadNCFile2 \/ Mise en service ", 
"snippet" : "Créez l'application et téléchargez-la sur une manette. Démarrez l'application, passez à la visualisation et appuyez sur Start . Vous pouvez utiliser Longline bouton radio pour définir la valeur de la variable $LONGLINE$ dans le code G pour TRUE ou FALSE ....", 
"body" : "Créez l'application et téléchargez-la sur une manette. Démarrez l'application, passez à la visualisation et appuyez sur Start . Vous pouvez utiliser Longline bouton radio pour définir la valeur de la variable $LONGLINE$ dans le code G pour TRUE ou FALSE . " }, 
{ "title" : "Interface utilisateur ", 
"url" : "_sm_cnc_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Commande : Analyser la dynamique ", 
"url" : "_sm_cmd_cnc_analyze_dynamics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Analyser la dynamique ", 
"snippet" : "Analyser la dynamique Fonction : La commande lance une analyse dynamique de la trajectoire CNC active dans l'éditeur. En même temps, les dimensions pour la position, la vitesse, l'accélération et l'à-coup de la trajectoire CNC sont déterminées en fonction du temps, et elles sont affichées dans les c...", 
"body" : "Analyser la dynamique Fonction : La commande lance une analyse dynamique de la trajectoire CNC active dans l'éditeur. En même temps, les dimensions pour la position, la vitesse, l'accélération et l'à-coup de la trajectoire CNC sont déterminées en fonction du temps, et elles sont affichées dans les chronogrammes du Analyse dynamique dialogue. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Afin d'effectuer une analyse dynamique de la trajectoire CNC, il ne doit pas y avoir d'erreurs dans le calcul de leur prétraitement de trajectoire. Pour plus d'informations, consultez : Afficher le chemin prétraité" }, 
{ "title" : "Boîte de dialogue : Analyse dynamique ", 
"url" : "_sm_cmd_cnc_analyze_dynamics.html#UUID-172573a8-7bc5-69ee-931b-3074ace95453_id_f14ff69a244133a5c0a8640e0144954d_id_72da7ed158aa22a9c0a864637a09d164", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Analyser la dynamique \/ Boîte de dialogue : Analyse dynamique ", 
"snippet" : "Les paramètres de la boîte de dialogue sont utilisés exclusivement pour l'affichage de l'analyse dynamique et n'ont aucun effet sur le programme CNC ou les paramètres CNC. Dans l'analyse dynamique, les courbes de temps pour les dimensions de la position, de la vitesse, de l'accélération et de l'à-co...", 
"body" : "Les paramètres de la boîte de dialogue sont utilisés exclusivement pour l'affichage de l'analyse dynamique et n'ont aucun effet sur le programme CNC ou les paramètres CNC. Dans l'analyse dynamique, les courbes de temps pour les dimensions de la position, de la vitesse, de l'accélération et de l'à-coup sont déterminées pour l'ensemble du trajet parcouru. Les diagrammes temporels sont affichés dans la boîte de dialogue sur le même axe temporel. Les paramètres de la boîte de dialogue sont utilisés (prédéfinis ou enregistrés). Tableau des positions Courbe de position de l'axe sélectionné (noir) Cercle rouge; indique le début d'un élément de chemin L'info-bulle du marqueur fournit des informations sur les numéros de ligne dans le code G respectif ou dans le tableau. Diagramme de vitesse Courbe de vitesse de l'axe sélectionné (bleu) Graphique d'accélération Courbe d'accélération de l'axe sélectionné (vert) Graphique de secousses Courbe de jerk de l'axe sélectionné (orange) Les paramètres sont enregistrés à la fermeture et utilisés à la prochaine ouverture de la boîte de dialogue. Par exemple, le facteur de zoom ne rend visible qu'une partie de la courbe. Zoome sur une partie des courbes temporelles Alternative: Ctrl + + Ctrl + Roulette de la souris Effectue un zoom arrière sur les courbes temporelles Alternative: Ctrl + - Ctrl + Roulette de la souris Effectue un zoom sur les courbes de temps pour afficher l'intégralité des trajectoires CNC Axe Sélection des axes : X , Y , Z , A , B , C , A1(P) , A2(Q) , A3 (U) , A4(V) , A5(W) , A6 , ou Chemin Préréglage : X axe Chemin Axe : Affichage de la position de trajectoire, de la vitesse de trajectoire, de l'accélération de trajectoire et de l'à-coup de trajectoire Temps de cycle [µs] Valeur pour le dwIpoTime entrée de la SMC_Interpolator bloc fonctionnel Valeur prédéfinie Temps de cycle [µs] dans l'objet Paramètres CNC (languette Préinterpolation ) Mode vitesse Valeur pour le iVelMode entrée de la SMC_Interpolateur bloc fonction trapèze Profil de vitesse trapézoïdal sigmoïde Comme trapèze , mais les fronts montants ou descendants sont remplacés par des fonctions sin² de même surface. Dans ce mode de vitesse, la valeur limite est dépassée d'environ un facteur \/2. Sigmoïde limité Comme sigmoïde , mais la durée d'interpolation de la trajectoire est la même que dans le mode vitesse trapèze . Défaut Quadratique Profil d'accélération de forme trapézoïdale avec limitation des à-coups La secousse atteint une valeur maximale dans Secousse maximale [u\/s³] . Il en résulte un profil de vitesse quadratique. Le profil de position se compose de polynômes du troisième degré. Le résultat est que le profil de vitesse se compose de paraboles, l'accélération se compose de segments linéaires et la secousse se compose de segments de ligne horizontaux. Secousse maximale [u\/s³] Limitation des secousses " }, 
{ "title" : "Commande : Importer depuis un fichier DXF ", 
"url" : "_sm_cmd_cnc_dxf_import.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Importer depuis un fichier DXF ", 
"snippet" : "Importer à partir d'un fichier DXF Fonction : La commande ouvre la boîte de dialogue par défaut. Après avoir sélectionné le fichier, le Importer un fichier DXF La boîte de dialogue s'ouvre pour configurer l'import d'un fichier DXF dans l'éditeur CNC. Appel : CNC menu Exigence : Un objet CNC est ouve...", 
"body" : "Importer à partir d'un fichier DXF Fonction : La commande ouvre la boîte de dialogue par défaut. Après avoir sélectionné le fichier, le Importer un fichier DXF La boîte de dialogue s'ouvre pour configurer l'import d'un fichier DXF dans l'éditeur CNC. Appel : CNC menu Exigence : Un objet CNC est ouvert dans l'éditeur. Restrictions du standard DXF à l'import de fichiers SPLINE les éléments ne sont pas importés exactement. Seuls les points de contrôle sont lus et positionnés par ces splines cardinales. Les références externes ne sont pas prises en charge. (Ce sont des références à d'autres fichiers DXF dans un BLOCK élément.) Les ellipses ne sont prises en charge que dans la mesure où elles existent dans le plan X\/Y. Arcs (élément ARC ) et des cercles (élément CIRCLE ) ne sont pris en charge que lorsque la mise à l'échelle est égale dans tous les axes spatiaux (paramètres 41, 42 et 43 de l'élément INSERT ). Cela affecte également les éléments POLYLINE et LWPOLYLINE qui incluent des arcs (paramètre bulge pas égal à 0 ). Références de bloc (élément INSERT ) ne sont pris en charge que lorsque la matrice de mise à l'échelle n'est pas un miroir. (Le produit des facteurs d'échelle doit être positif.) Les éléments de zone, les maillages polygonaux et les maillages polyfaces ne sont pas pris en charge. Éléments solides ( SOLID , …) ne sont pas non plus pris en charge. Les éléments MLINE (multiligne), RAY , XLINE , et LEADER (ligne de repère) ne sont pas pris en charge. Les éléments TEXT , MTEXT , et DIMENSION ne sont pas pris en charge. La largeur, la couleur et le style de ligne sont ignorés, ainsi que les informations sur la visibilité des éléments. Fichiers DXF binaires (extension de fichier DXB ) ne sont pas pris en charge. Les éléments non pris en charge sont ignorés (implicitement) lors de l'importation. " }, 
{ "title" : "Boîte de dialogue : Importer un fichier DXF ", 
"url" : "_sm_cmd_cnc_dxf_import.html#UUID-ceb47740-324e-76a2-abd9-2d1fa27e1a26_id_fde6e1824400e36c0a8640e013dba7a_id_754451675df6e481c0a8646326153262", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Importer depuis un fichier DXF \/ Boîte de dialogue : Importer un fichier DXF ", 
"snippet" : "Couches Toutes les couches du dessin technique ; déterminé à partir des données du fichier DXF : Le calque sera importé. Taille maximale de l'espace Distance entre les extrémités des éléments géométriques jusqu'à l'endroit où les points sont considérés comme interconnectés. Déterminé à partir des do...", 
"body" : "Couches Toutes les couches du dessin technique ; déterminé à partir des données du fichier DXF : Le calque sera importé. Taille maximale de l'espace Distance entre les extrémités des éléments géométriques jusqu'à l'endroit où les points sont considérés comme interconnectés. Déterminé à partir des données du fichier DXF. Exemple: 0.001 Aperçu sur trajectoire CNC Les données du fichier DXF sélectionné sont affichées telles qu'elles sont importées dans l'éditeur CNC. La couche sélectionnée pour la visualisation est également prise en compte. Exemple: Vue Pour changer de couche considérée dans la fenêtre d'aperçu. plan x\/y ; sélectionné pour l'affichage plan x\/z plan y\/z Bouton ' Importer ' Les données sont chargées dans l'éditeur CNC et le programme CNC existant est remplacé. Les numéros de bloc sont attribués automatiquement. L'objet CNC conserve son nom. " }, 
{ "title" : "Commande : Infos CNC ", 
"url" : "_sm_cmd_cnc_info.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Infos CNC ", 
"snippet" : "Informations sur la CNC Fonction : La commande ouvre le Informations CNC sur le programme <nom> dialogue. Appel : CNC menu Menu contextuel d'un objet (type programme CNC ) Exigence : Un programme CNC est ouvert dans l'éditeur. Boîte de dialogue : Code généré La boîte de dialogue affiche le code d'in...", 
"body" : "Informations sur la CNC Fonction : La commande ouvre le Informations CNC sur le programme <nom> dialogue. Appel : CNC menu Menu contextuel d'un objet (type programme CNC ) Exigence : Un programme CNC est ouvert dans l'éditeur. Boîte de dialogue : Code généré La boîte de dialogue affiche le code d'initialisation CEI du programme CNC actif, en fonction du mode de compilation du bloc fonction SMC_OutQueue ou SMC_CNC_REF . Exemple : code d'initialisation CEI {attribute 'linkalways'}\nVAR_GLOBAL\n {attribute 'init_on_onlchange'}\n {attribute 'init_on_onlchange'}\n Example : SMC_CNC_REF := (nElements := 22, strProgramName := 'Example', piStartPosition := (iFrameNo:=0, wAuxData:=7, wSProfile:=0, dX:=0, dY:=0, dZ:=0, dA:=0, dB:=0, dC:=0, dA1:=0, dA2:=0, dA3:=0, dA4:=0, dA5:=0, dA6:=0), pgc := ADR(Example_D), xPartofLM := TRUE);\n {attribute 'blobinit'}\n {attribute 'init_on_onlchange'}\n Example_D : ARRAY[0..21] OF SMC_GCODE_WORD := [\n {p 35184372088832 }\n (byLetter := 78, fValue:=0, diValue:=0),\n {p 35184372088832 }\n (byLetter := 70, fValue:=0, diValue:=0),\n {p 35184372088832 }\n (byLetter := 69, fValue:=100, diValue:=100),\n {p 35184372088832 }\n (byLetter := 69, fValue:=-100, diValue:=-100),\n {p 35184372088832 }\n (byLetter := 128, fValue:=1, diValue:=1),\n {p 36283883716609 }\n (byLetter := 78, fValue:=0, diValue:=0),\n {p 36835250143233 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 38486665068545 }\n (byLetter := 88, pAdr := ADR(g_x), byVarType := ANY_TO_BYTE(__TYPEOF(g_x) + 32)),\n {p 36291399909377 }\n (byLetter := 89, fValue:=0, diValue:=0),\n {p 36842766336001 }\n (byLetter := 70, fValue:=50, diValue:=50),\n {p 36844913819649 }\n (byLetter := 69, fValue:=30, diValue:=30),\n {p 37396817117185 }\n (byLetter := 69, fValue:=-30, diValue:=-30),\n {p 35184372088832 }\n (byLetter := 128, fValue:=2, diValue:=2),\n {p 36833639530498 }\n (byLetter := 78, fValue:=10, diValue:=10),\n {p 36835787014146 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 36288178683906 }\n (byLetter := 88, fValue:=0, diValue:=0),\n {p 38488812552194 }\n (byLetter := 89, pAdr := ADR(g_y), byVarType := ANY_TO_BYTE(__TYPEOF(g_y) + 32)),\n {p 35184372088832 }\n (byLetter := 128, fValue:=3, diValue:=3),\n {p 36833639530499 }\n (byLetter := 78, fValue:=20, diValue:=20),\n {p 36835787014147 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 36288178683907 }\n (byLetter := 88, fValue:=0, diValue:=0),\n {p 36289789296643 }\n (byLetter := 89, fValue:=0, diValue:=0)];\nEND_VAR " }, 
{ "title" : "Boîte de dialogue : informations CNC du programme <nom> ", 
"url" : "_sm_cmd_cnc_info.html#UUID-ad8caf78-e0cf-3500-0750-16c2eb5fabe7_id_dc9afe4124423d69c0a8640e01f781e8_id_fc2c1e2959841990c0a864630e5a26e5", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Infos CNC \/ Boîte de dialogue : informations CNC du programme <nom> ", 
"snippet" : "La boîte de dialogue fournit des informations sur le programme CNC spécifié. Nom du programme Exemple: Workpiece_1 Version des blocs fonction Exemple: 4.2.0.0 Nombre de lignes Exemple: 5 Nombre d'objets Exemple: 3 Longueur du chemin [unités] Exemple: 261.803398874992 Durée [s] Temps (en secondes) po...", 
"body" : "La boîte de dialogue fournit des informations sur le programme CNC spécifié. Nom du programme Exemple: Workpiece_1 Version des blocs fonction Exemple: 4.2.0.0 Nombre de lignes Exemple: 5 Nombre d'objets Exemple: 3 Longueur du chemin [unités] Exemple: 261.803398874992 Durée [s] Temps (en secondes) pour parcourir le chemin prétraité Exemple: 10.158 Exigence : prétraitement du chemin sans erreurs et points d'interpolation générés avec succès Afficher le code généré Les Code généré la boîte de dialogue s'ouvre. Condition : Le programme ne contient aucune erreur. " }, 
{ "title" : "Commande : Charger le programme à partir du fichier ASCII ", 
"url" : "_sm_cmd_cnc_load_program_from_ascii_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Charger le programme à partir du fichier ASCII ", 
"snippet" : "Charger le programme à partir d'un fichier ASCII Fonction : La commande charge un ASCII fichier avec les données du programme CNC dans l'éditeur CNC. L'objet CNC conserve son nom. Appel : CNC menu Exigence : Un objet CNC est ouvert dans l'éditeur. La commande ouvre la boîte de dialogue par défaut po...", 
"body" : "Charger le programme à partir d'un fichier ASCII Fonction : La commande charge un ASCII fichier avec les données du programme CNC dans l'éditeur CNC. L'objet CNC conserve son nom. Appel : CNC menu Exigence : Un objet CNC est ouvert dans l'éditeur. La commande ouvre la boîte de dialogue par défaut pour rechercher le système de fichiers. Le filtre doit être défini sur CNC, GCODE ou TXT. Le fichier sélectionné est chargé dans l'éditeur CNC actif. Tout programme CNC existant est écrasé (après une autre requête). " }, 
{ "title" : "Commande : Déplacer le programme ", 
"url" : "_sm_cmd_cnc_move_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Déplacer le programme ", 
"snippet" : "Programme de déménagement Fonction : La commande ouvre le Vecteur de traduction dialogue de configuration d'un déplacement de la trajectoire CNC. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur....", 
"body" : "Programme de déménagement Fonction : La commande ouvre le Vecteur de traduction dialogue de configuration d'un déplacement de la trajectoire CNC. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. " }, 
{ "title" : "Contrainte ", 
"url" : "_sm_cmd_cnc_move_program.html#UUID-67135dbc-74ff-3167-05ff-7a200cb0af34_id_f409bfb22439d072c0a8640e01561fb2_id_e69692297289ca8ec0a864631a178469", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Déplacer le programme \/ Contrainte ", 
"snippet" : "Le déplacement de la trajectoire CNC est possible dans les conditions suivantes : Pas d'utilisation de l'axe A, B ou C des variables...", 
"body" : "Le déplacement de la trajectoire CNC est possible dans les conditions suivantes : Pas d'utilisation de l'axe A, B ou C des variables " }, 
{ "title" : "Boîte de dialogue : vecteur de traduction ", 
"url" : "_sm_cmd_cnc_move_program.html#UUID-67135dbc-74ff-3167-05ff-7a200cb0af34_id_f409bfb22439d072c0a8640e01561fb2_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Déplacer le programme \/ Boîte de dialogue : vecteur de traduction ", 
"snippet" : "Vecteur de translation en coordonnées pour tous les axes X Défaut: 1.0000000 Y Z P Q U V W d'accord Cela déplace la trajectoire CNC. De plus, une commande G0 (commande de positionnement relatif) est insérée avec les coordonnées du vecteur de translation dans le programme CNC avant la première comman...", 
"body" : "Vecteur de translation en coordonnées pour tous les axes X Défaut: 1.0000000 Y Z P Q U V W d'accord Cela déplace la trajectoire CNC. De plus, une commande G0 (commande de positionnement relatif) est insérée avec les coordonnées du vecteur de translation dans le programme CNC avant la première commande de positionnement. Les commandes de positionnement sont G1, G2, G3, G5, G6, G8, G9, G10, G11 et G92. Si les commandes G54, G55 ou G56 décalent le système de coordonnées dans le programme CNC, alors les arguments sont adaptés dans ces commandes. Les blocs jusqu'à G53 ne nécessitent aucune autre adaptation. Si une commande G56 est la première commande de positionnement, alors seule cette commande est adaptée. Les numéros de bloc sont attribués automatiquement. " }, 
{ "title" : "Commande : Renuméroter le programme CNC ", 
"url" : "_sm_cmd_cnc_renumber_cnc_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Renuméroter le programme CNC ", 
"snippet" : "Renuméroter le programme CNC Symbole: Fonction : La commande rafraîchit la numérotation des lignes de programme dans le programme CNC. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Les numéros commencent à 0 et sont incrémentés de 10. Chaque bloc sans numéro de bloc reçoit un ...", 
"body" : "Renuméroter le programme CNC Symbole: Fonction : La commande rafraîchit la numérotation des lignes de programme dans le programme CNC. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Les numéros commencent à 0 et sont incrémentés de 10. Chaque bloc sans numéro de bloc reçoit un numéro. Le code L dans les blocs G20 est corrigé. " }, 
{ "title" : "Commande : Inverser la direction ", 
"url" : "_sm_cmd_cnc_reverse_direction.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Inverser la direction ", 
"snippet" : "Inverser le sens Fonction : La commande inverse le programme CNC et définit les éléments de trajectoire dans l'ordre inverse. Les numéros de bloc du programme CNC sont également réinitialisés automatiquement. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Contrainte L'inversion...", 
"body" : "Inverser le sens Fonction : La commande inverse le programme CNC et définit les éléments de trajectoire dans l'ordre inverse. Les numéros de bloc du programme CNC sont également réinitialisés automatiquement. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Contrainte L'inversion de la trajectoire CNC est possible dans les conditions suivantes : Si le prétraitement a été sélectionné pour le programme CNC, alors les blocs G41\/G42 sont traités dans le programme inverse : G41 devient G42 et G42 devient G41. Le sens de la correction est également inversé. Si le programme CNC contient des arcs définis avec un angle d'ouverture (paramètre K pour les éléments 2D ou paramètre T pour les éléments 3D), la commande ne génère pas d'arcs inversés exacts. Si la trajectoire CNC a été programmée par les moyens suivants, l'inversion n'est pas possible. Pas de marche arrière quand Utilisation de l'axe A, B ou C Utilisation de variables Suppression d'étape d'appel " }, 
{ "title" : "Commande : Rotation du programme ", 
"url" : "_sm_cmd_cnc_rotate_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Rotation du programme ", 
"snippet" : "Programme de rotation Fonction : La commande ouvre le Paramètres de rotation dialogue où la rotation de la trajectoire CNC est configurée. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur....", 
"body" : "Programme de rotation Fonction : La commande ouvre le Paramètres de rotation dialogue où la rotation de la trajectoire CNC est configurée. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. " }, 
{ "title" : "Contrainte ", 
"url" : "_sm_cmd_cnc_rotate_program.html#UUID-b9a9e82f-9e38-05fb-3bf2-345a94e26b09_id_b540ec0a8640e01ab500e_id_45841f775e56fd50c0a864632eb28d67", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Rotation du programme \/ Contrainte ", 
"snippet" : "La rotation de la trajectoire CNC est possible dans les conditions suivantes : Pas d'utilisation de l'axe A, B ou C des variables...", 
"body" : "La rotation de la trajectoire CNC est possible dans les conditions suivantes : Pas d'utilisation de l'axe A, B ou C des variables " }, 
{ "title" : "Paramètres de rotation Dialogue ", 
"url" : "_sm_cmd_cnc_rotate_program.html#UUID-b9a9e82f-9e38-05fb-3bf2-345a94e26b09_id_b540ec0a8640e01ab500e_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Rotation du programme \/ Paramètres de rotation Dialogue ", 
"snippet" : "Angle (degrés) Angle de rotation (en degrés) autour du Axe rotatif . Exemple: Étant donné Rotation autour de l'axe Z L'axe X pointe vers la droite et l'axe Y pointe vers le bas. La direction d'observation est contre l'axe de rotation (règle de droite). Pour une valeur négative, la rotation est effec...", 
"body" : "Angle (degrés) Angle de rotation (en degrés) autour du Axe rotatif . Exemple: Étant donné Rotation autour de l'axe Z L'axe X pointe vers la droite et l'axe Y pointe vers le bas. La direction d'observation est contre l'axe de rotation (règle de droite). Pour une valeur négative, la rotation est effectuée dans le sens horaire. Pour une valeur positive, la rotation est effectuée dans le sens inverse des aiguilles d'une montre. Axe de rotation La sélection d'un axe rotatif n'est possible que si les éléments de la trajectoire CNC sont tous des éléments 3D. Pas de sélection si la trajectoire CNC de l'un des éléments suivants comprend : Spline G5 Parabole Ellipse arc 2D L'axe de rotation est défini par les paramètres X , Oui , et Z . Défaut: X : 0, Oui : 0, Z : 1 --> rotation autour de l'axe Z X Défaut: 0.00000 Y Défaut: 0.00000 Z Défaut: 1.00000 d'accord La rotation est exécutée. Les numéros de bloc sont attribués automatiquement. " }, 
{ "title" : "Commande : programme de mise à l'échelle ", 
"url" : "_sm_cmd_cnc_scale_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : programme de mise à l'échelle ", 
"snippet" : "Programme d'échelle Fonction : La commande ouvre le Programme à l'échelle boîte de dialogue dans laquelle la mise à l'échelle de la trajectoire CNC est configurée. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur....", 
"body" : "Programme d'échelle Fonction : La commande ouvre le Programme à l'échelle boîte de dialogue dans laquelle la mise à l'échelle de la trajectoire CNC est configurée. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. " }, 
{ "title" : "Contrainte ", 
"url" : "_sm_cmd_cnc_scale_program.html#UUID-d8f93f90-76cd-f349-684b-7ab5ca0dd141_id_fc67fe112446a403c0a8640e01ee1047_id_1320e28c7289c9f2c0a864633d064770", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : programme de mise à l'échelle \/ Contrainte ", 
"snippet" : "La mise à l'échelle de la trajectoire CNC est possible dans les conditions suivantes : Pas d'utilisation de l'axe A, B ou C des variables...", 
"body" : "La mise à l'échelle de la trajectoire CNC est possible dans les conditions suivantes : Pas d'utilisation de l'axe A, B ou C des variables " }, 
{ "title" : "Programme d'échelle Dialogue ", 
"url" : "_sm_cmd_cnc_scale_program.html#UUID-d8f93f90-76cd-f349-684b-7ab5ca0dd141_id_fc67fe112446a403c0a8640e01ee1047_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : programme de mise à l'échelle \/ Programme d'échelle Dialogue ", 
"snippet" : "Facteur d'échelle Défaut: 0.001 Condition : Facteur d'échelle >= 1e-3 Pour un facteur d'échelle > 1, il est augmenté. Haches : L'axe est mis à l'échelle. D (rayon d'outil) : Le rayon d'outil D est mis à l'échelle. d'accord La mise à l'échelle est effectuée. Les numéros de bloc sont attribués automat...", 
"body" : "Facteur d'échelle Défaut: 0.001 Condition : Facteur d'échelle >= 1e-3 Pour un facteur d'échelle > 1, il est augmenté. Haches : L'axe est mis à l'échelle. D (rayon d'outil) : Le rayon d'outil D est mis à l'échelle. d'accord La mise à l'échelle est effectuée. Les numéros de bloc sont attribués automatiquement. " }, 
{ "title" : "Commande : Afficher le chemin de défilement ", 
"url" : "_sm_cmd_cnc_scroll_path_view.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Afficher le chemin de défilement ", 
"snippet" : "Faire défiler la vue du chemin Fonction : La commande active et désactive le défilement de la trajectoire CNC. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Si le défilement est activé, la vue de la trajectoire CNC défile et zoome dans l'éditeur graphique afin qu'un élément de...", 
"body" : "Faire défiler la vue du chemin Fonction : La commande active et désactive le défilement de la trajectoire CNC. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Si le défilement est activé, la vue de la trajectoire CNC défile et zoome dans l'éditeur graphique afin qu'un élément de trajectoire sélectionné dans le programme CNC soit complètement visible. " }, 
{ "title" : "Commande : Définir les variables ", 
"url" : "_sm_cmd_cnc_set_offline_variables.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Définir les variables ", 
"snippet" : "Définir des variables Fonction : La commande ouvre le Valeurs hors ligne des variables dialogue. Les variables du programme CNC peuvent être définies ici pour le mode hors ligne. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur....", 
"body" : "Définir des variables Fonction : La commande ouvre le Valeurs hors ligne des variables dialogue. Les variables du programme CNC peuvent être définies ici pour le mode hors ligne. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. " }, 
{ "title" : "Boîte de dialogue : Valeurs hors ligne des variables ", 
"url" : "_sm_cmd_cnc_set_offline_variables.html#UUID-101f0c28-cef6-51dc-ec33-33b8d27ee9c8_id_c97aba1d244400ffc0a8640e01a5ad6c_id_d54502d95df6e2f6c0a8646351ba116d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Définir les variables \/ Boîte de dialogue : Valeurs hors ligne des variables ", 
"snippet" : "Variable Variable du programme CNC Exemple: G_X Si la variable est affichée en italique gris, elle n'est pas utilisée dans le programme CNC. Valeur Valeur hors ligne configurée Exemple: 100 Définir sur les valeurs en ligne Les valeurs sont remplacées par les valeurs actuellement affectées dans l'app...", 
"body" : "Variable Variable du programme CNC Exemple: G_X Si la variable est affichée en italique gris, elle n'est pas utilisée dans le programme CNC. Valeur Valeur hors ligne configurée Exemple: 100 Définir sur les valeurs en ligne Les valeurs sont remplacées par les valeurs actuellement affectées dans l'application. Condition préalable : La commande est disponible si l'application est en cours d'exécution et l'éditeur CNC est en mode en ligne. Ensuite, il est possible de charger les valeurs en ligne. d'accord Si les valeurs sont valides, elles sont appliquées dans le programme CNC et le chemin de l'éditeur est rafraîchi. " }, 
{ "title" : "Commande : Afficher les extrémités ", 
"url" : "_sm_cmd_cnc_show_end_points.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Afficher les extrémités ", 
"snippet" : "Afficher les points d'extrémité Fonction : La commande active et désactive l'affichage des points de trajectoire CNC. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Si l'affichage est activé, tous les éléments de trajectoire sont dotés de points d'extrémité....", 
"body" : "Afficher les points d'extrémité Fonction : La commande active et désactive l'affichage des points de trajectoire CNC. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Si l'affichage est activé, tous les éléments de trajectoire sont dotés de points d'extrémité. " }, 
{ "title" : "Commande : Afficher la grille ", 
"url" : "_sm_cmd_cnc_show_grid.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Afficher la grille ", 
"snippet" : "Afficher la grille Symbole: Fonction : La commande active et désactive l'affichage d'une grille dans l'éditeur graphique. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Le facteur de zoom détermine l'espacement des lignes de la grille. L'expansion du chemin détermine la taille ...", 
"body" : "Afficher la grille Symbole: Fonction : La commande active et désactive l'affichage d'une grille dans l'éditeur graphique. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Le facteur de zoom détermine l'espacement des lignes de la grille. L'expansion du chemin détermine la taille de la grille. " }, 
{ "title" : "Commande : Afficher les points d'interpolation ", 
"url" : "_sm_cmd_cnc_show_interpolation_points.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Afficher les points d'interpolation ", 
"snippet" : "Afficher les points d'interpolation Symbole: Fonction : La commande active et désactive l'affichage des points d'interpolation. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Si l'affichage des points d'interpolation est activé, alors la trajectoire CNC est affichée avec les po...", 
"body" : "Afficher les points d'interpolation Symbole: Fonction : La commande active et désactive l'affichage des points d'interpolation. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Si l'affichage des points d'interpolation est activé, alors la trajectoire CNC est affichée avec les points d'interpolation. Le temps de cycle, qui est défini dans la boîte de dialogue des paramètres CNC ( Préinterpolation tab), est utilisé pour déterminer les points d'interpolation. De plus, cette fonction détermine si une trajectoire CNC est affichée ou non avec prétraitement dans l'éditeur. " }, 
{ "title" : "Affichage dans l'éditeur graphique ", 
"url" : "_sm_cmd_cnc_show_interpolation_points.html#UUID-043dd64e-e07a-5e2b-2f1d-fc2a843ef4b7_id_be380e1242fa185c0a8640e005adee9_id_d6d5fcd172c9c53cc0a864633c37464d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Afficher les points d'interpolation \/ Affichage dans l'éditeur graphique ", 
"snippet" : "Un point d'interpolation est affiché avec une ligne perpendiculaire à la direction du mouvement. La longueur de la ligne est proportionnelle à la vitesse de trajectoire actuelle. Cela permet une estimation grossière du comportement de la vitesse. Plus grande distance et longue ligne Vitesse élevée D...", 
"body" : "Un point d'interpolation est affiché avec une ligne perpendiculaire à la direction du mouvement. La longueur de la ligne est proportionnelle à la vitesse de trajectoire actuelle. Cela permet une estimation grossière du comportement de la vitesse. Plus grande distance et longue ligne Vitesse élevée Distance plus petite et ligne courte Faible vitesse rouge L'interpolateur est décéléré. Vert L'interpolateur est accéléré. gris L'interpolateur a une vitesse constante. " }, 
{ "title" : "Commande : Suppression d'étape ", 
"url" : "_sm_cmd_cnc_step_suppression.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Suppression d'étape ", 
"snippet" : "Suppression de pas Symbole: Fonction : La commande active et désactive la suppression de pas. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Le programme CNC est implémenté en tant que DIN66025. Si la suppression de pas est activée, les blocs du programme CNC commençant par \/ s...", 
"body" : "Suppression de pas Symbole: Fonction : La commande active et désactive la suppression de pas. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Le programme CNC est implémenté en tant que DIN66025. Si la suppression de pas est activée, les blocs du programme CNC commençant par \/ sont ignorés. Si le programme CNC est implémenté sous forme de table, la commande n'est pas disponible. " }, 
{ "title" : "Commande : écrire le programme dans un fichier ASCII ", 
"url" : "_sm_cmd_cnc_write_program_to_ascii_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : écrire le programme dans un fichier ASCII ", 
"snippet" : "Écrire le programme dans un fichier ASCII Fonction : La commande ouvre la boîte de dialogue par défaut pour enregistrer un fichier dans le système de fichiers. Le programme CNC peut être enregistré sous forme de fichier ASCII. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Nom ...", 
"body" : "Écrire le programme dans un fichier ASCII Fonction : La commande ouvre la boîte de dialogue par défaut pour enregistrer un fichier dans le système de fichiers. Le programme CNC peut être enregistré sous forme de fichier ASCII. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Nom Par défaut : Nom de l'objet CNC Exemple: cncSpiral_A Type de fichier Extension de fichier: TXT , GCODE , CNC " }, 
{ "title" : "Commande : Afficher le chemin prétraité ", 
"url" : "_sm_cmd_cnc_show_preprocessed_path.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Commande : Afficher le chemin prétraité ", 
"snippet" : "Afficher le chemin prétraité Symbole: Fonction : La commande active et désactive l'affichage de la trajectoire CNC avec prétraitement. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Si l'affichage est actif, le chemin est affiché avec un prétraitement et le chemin d'origine est...", 
"body" : "Afficher le chemin prétraité Symbole: Fonction : La commande active et désactive l'affichage de la trajectoire CNC avec prétraitement. Appel : CNC menu Exigence : Un chemin CNC est ouvert dans l'éditeur. Si l'affichage est actif, le chemin est affiché avec un prétraitement et le chemin d'origine est affiché en gris clair en arrière-plan. Le prétraitement est configuré dans le Paramètres CNC dialogue ( Prétraitement de chemin languette). Le prétraitement configuré ici s'affiche. Ensuite, vous pouvez simuler l'effet des différents blocs fonctionnels (en série) sur le prétraitement. La commande n'a aucun effet sur la génération de code. Même si une structure de fichier SMC_OutQueue est générée lors de la compilation du programme CNC, la commande n'a aucun effet sur le contenu du fichier. Le prétraitement est toujours pris en compte lors de la compilation. " }, 
{ "title" : "Objet : Programme CNC ", 
"url" : "_sm_f_reference_object_cnc_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Objet : Programme CNC ", 
"snippet" : "programme CNC...", 
"body" : "programme CNC " }, 
{ "title" : "Aperçu ", 
"url" : "_sm_f_reference_object_cnc_program-1561724.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Objet : Programme CNC \/ Aperçu ", 
"snippet" : "CODESYS offre la possibilité de créer des programmes CNC dans deux éditeurs différents : l'éditeur pour DIN 66025 et l'éditeur tabulaire. Les deux éditeurs affichent une vue graphique du chemin programmé. Bien que la programmation puisse être échangée entre les éditeurs, cela peut entraîner des pert...", 
"body" : "CODESYS offre la possibilité de créer des programmes CNC dans deux éditeurs différents : l'éditeur pour DIN 66025 et l'éditeur tabulaire. Les deux éditeurs affichent une vue graphique du chemin programmé. Bien que la programmation puisse être échangée entre les éditeurs, cela peut entraîner des pertes d'informations. Les éditeurs individuels offrent une gestion différente des éléments. Élément Editeur pour DIN 66025 Éditeur tabulaire Positionnement X X Ligne X X Arc X X Ellipse X X Spline X X Positionnement rapide X X Fonction M X X Parabole X Utilisation de variables X Saut X Changement de coordonnées X Suppression de pas X Temps de séjour X Synchronisation temporelle avec l'interpolateur X Pour plus d'informations, consultez : Éditeur tabulaire et Editeur pour DIN 66025" }, 
{ "title" : "Éditeur tabulaire ", 
"url" : "_sm_obj_cnc_program_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Objet : Programme CNC \/ Éditeur tabulaire ", 
"snippet" : "Dans l'éditeur tabulaire, les commandes de chemin sont répertoriées dans un tableau. Sur le Éditeur tabulaire onglet, dans le Paramètres CNC , vous pouvez personnaliser les colonnes de ce tableau. Les Paramètres CNC se trouvent en tant qu'objet dans l'arborescence des appareils. Par défaut, les prop...", 
"body" : "Dans l'éditeur tabulaire, les commandes de chemin sont répertoriées dans un tableau. Sur le Éditeur tabulaire onglet, dans le Paramètres CNC , vous pouvez personnaliser les colonnes de ce tableau. Les Paramètres CNC se trouvent en tant qu'objet dans l'arborescence des appareils. Par défaut, les propriétés de l'élément de chemin sélectionné sont affichées sur le côté droit du tableau. Ceux-ci ne peuvent pas être modifiés ici. Lorsque vous sélectionnez une ligne, la trajectoire de mouvement respective est dessinée dans l'éditeur graphique. Le type d'élément détermine quelles propriétés spécifiques d'un élément de chemin peuvent être modifiées. Les paramètres non modifiables sont ombrés. En appuyant sur le F6 La touche bascule le focus sur l'éditeur graphique et inversement. Pour un aperçu des éléments supportés par cet éditeur, voir le chapitre \"Objet programme CNC\". Pour plus d'informations, consultez : Programmation d'un chemin dans l'éditeur tabulaire et Éditeur graphique" }, 
{ "title" : "Editeur pour DIN 66025 ", 
"url" : "_sm_obj_cnc_program_din66025.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Objet : Programme CNC \/ Editeur pour DIN 66025 ", 
"snippet" : "Dans cet éditeur, vous spécifiez les éléments de trajectoire en tant que programme CNC selon DIN 66025. Par défaut, les propriétés de l'élément de trajectoire sélectionné sont affichées sur le côté droit. Cependant, ils ne peuvent pas y être modifiés. Lorsque vous sélectionnez une ligne, la trajecto...", 
"body" : "Dans cet éditeur, vous spécifiez les éléments de trajectoire en tant que programme CNC selon DIN 66025. Par défaut, les propriétés de l'élément de trajectoire sélectionné sont affichées sur le côté droit. Cependant, ils ne peuvent pas y être modifiés. Lorsque vous sélectionnez une ligne, la trajectoire de mouvement respective est dessinée dans l'éditeur graphique. En appuyant sur le F6 La touche bascule le focus sur l'éditeur graphique et inversement. Pour un aperçu des éléments supportés par cet éditeur, voir le chapitre \"Objet programme CNC\". Notez que les références des variables globales sont évaluées dans le module décodeur lorsque l'interpréteur traite les blocs. Cela peut se produire quelques cycles à l'avance avant que l'objet ne se déplace. Pour plus d'informations, consultez : Programmation d'un chemin selon DIN 66025 et Paramètres CNC" }, 
{ "title" : "Éditeur graphique ", 
"url" : "_sm_obj_cnc_program_graphical.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Objet : Programme CNC \/ Éditeur graphique ", 
"snippet" : "L'éditeur graphique est situé dans la partie inférieure de l'éditeur tabulaire CNC et de l'éditeur pour DIN 66025. L'éditeur permet d'afficher le programme CNC programmé. L'éditeur fournit des outils pour modifier et étendre le chemin. Structure de l'éditeur (1) : Editeur tabulaire ou éditeur selon ...", 
"body" : "L'éditeur graphique est situé dans la partie inférieure de l'éditeur tabulaire CNC et de l'éditeur pour DIN 66025. L'éditeur permet d'afficher le programme CNC programmé. L'éditeur fournit des outils pour modifier et étendre le chemin. Structure de l'éditeur (1) : Editeur tabulaire ou éditeur selon DIN 66025 (2) : Vue des propriétés : Affiche les propriétés de l'élément de chemin sélectionné (3) : éditeur graphique (4) : Panneau de contrôle : Éléments de contrôle de la position de la caméra et de la direction de vision (5) : Outils pour modifier le chemin Remarques sur l'utilisation de l'éditeur graphique L'élément de chemin sélectionné est affiché en rouge. Les commandes de positionnement (G0) et les fonctions de point de commutation sont affichées en vert. Si le point final d'un élément est mobile, il s'affiche sous la forme d'un petit cercle à contour noir. Les tangentes de début et de fin sont affichées en gris. La position actuelle de l'élément de chemin sélectionné est affichée dans la barre d'état. Notez les commandes du menu CNC pour la mise à l'échelle et le déplacement de la trajectoire entière. Notez les exemples de programmes inclus dans l'installation de CODESYS SoftMotion . " }, 
{ "title" : "Outils ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_0ffa6b2d9c1625bec0a8646341693b76", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Objet : Programme CNC \/ Éditeur graphique \/ Outils ", 
"snippet" : "Vous pouvez utiliser des outils pour modifier et étendre les trajectoires de mouvement dans l'éditeur graphique. Les modifications sont visibles simultanément dans l'éditeur de texte et l'éditeur tabulaire. Sélectionner : Cet outil sélectionne un point ou un élément de chemin. L'élément est alors af...", 
"body" : "Vous pouvez utiliser des outils pour modifier et étendre les trajectoires de mouvement dans l'éditeur graphique. Les modifications sont visibles simultanément dans l'éditeur de texte et l'éditeur tabulaire. Sélectionner : Cet outil sélectionne un point ou un élément de chemin. L'élément est alors affiché en rouge avec un point de départ bleu. Le pointeur de la souris dans l'éditeur graphique se transforme en pointeur. Ligne : ajoute ou insère une nouvelle ligne. Le pointeur de la souris dans l'éditeur graphique se transforme en croix. Insérer un cercle (dans le sens des aiguilles d'une montre) : ajoute ou insère un nouvel arc (dans le sens des aiguilles d'une montre). Le pointeur de la souris dans l'éditeur graphique se transforme en croix. Insérer un cercle (dans le sens inverse des aiguilles d'une montre) : ajoute ou insère un nouvel arc (sens antihoraire). Le pointeur de la souris dans l'éditeur graphique se transforme en croix. Spline : ajoute ou insère un nouveau point de spline. Le pointeur de la souris dans l'éditeur graphique se transforme en croix. " }, 
{ "title" : "Position de la caméra et direction de la vue ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_05ff18059c1625bec0a864634ba4f71d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Objet : Programme CNC \/ Éditeur graphique \/ Position de la caméra et direction de la vue ", 
"snippet" : "Vous pouvez utiliser la souris pour modifier la position et la perspective de la caméra sur le chemin du programme de quelque manière que ce soit. Bouton gauche de la souris enfoncé + mouvement de la souris : Déplace la position de la caméra le long des axes dans le plan d'affichage. Bouton droit de...", 
"body" : "Vous pouvez utiliser la souris pour modifier la position et la perspective de la caméra sur le chemin du programme de quelque manière que ce soit. Bouton gauche de la souris enfoncé + mouvement de la souris : Déplace la position de la caméra le long des axes dans le plan d'affichage. Bouton droit de la souris appui + mouvement de la souris : Fait pivoter la vue sur le programme CNC. Ctrl + Roulette de la souris : modifie le facteur de zoom. " }, 
{ "title" : "Panneau de commande pour le contrôle de l'affichage ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_4693d34dba46042bc0a864633b130501", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Objet : Programme CNC \/ Éditeur graphique \/ Panneau de commande pour le contrôle de l'affichage ", 
"snippet" : "Dans le coin supérieur gauche de l'éditeur graphique, un panneau de commande propose différentes commandes pour changer la vue du chemin. Le chemin n'est pas modifié dans le processus. Au lieu de cela, seules la position et la perspective de la caméra sont modifiées. Vous pouvez réduire le panneau d...", 
"body" : "Dans le coin supérieur gauche de l'éditeur graphique, un panneau de commande propose différentes commandes pour changer la vue du chemin. Le chemin n'est pas modifié dans le processus. Au lieu de cela, seules la position et la perspective de la caméra sont modifiées. Vous pouvez réduire le panneau de configuration en cliquant sur la flèche noire afin de maximiser la taille de l'espace de travail de l'éditeur. En cliquant à nouveau, vous agrandissez le panneau de configuration. Le panneau de commande fournit les commandes suivantes pour définir l'orientation, la position et le zoom. Agrandir Dézoomer Changer le pas de la caméra (dans le sens des aiguilles d'une montre) Changer le pas de la caméra (dans le sens inverse des aiguilles d'une montre) Changer le lacet de la caméra (dans le sens des aiguilles d'une montre) Changer le lacet de la caméra (sens antihoraire) Faites pivoter la caméra (dans le sens des aiguilles d'une montre) Faites pivoter la caméra (dans le sens inverse des aiguilles d'une montre) Déplacer la caméra vers le haut Déplacer la caméra vers la gauche Déplacer la caméra vers la droite Déplacer la caméra vers le bas Définissez la direction de la vue sur l'axe z négatif et redimensionnez Définir la direction de la vue sur l'axe des x et redimensionner Définir la direction de la vue sur l'axe des y et redimensionner " }, 
{ "title" : "Boîte de dialogue : propriétés CNC ", 
"url" : "_sm_dlg_cnc_program_properties.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Objet : Programme CNC \/ Boîte de dialogue : propriétés CNC ", 
"snippet" : "Symbole: Fonction : La boîte de dialogue fournit des paramètres pour le Programme CNC objet. Appel : Affichage → Propriétés commander; menu contextuel de l'objet Exigence : L'objet CNC est sélectionné dans l'arborescence des appareils. Les paramètres CNC à l'échelle de l'application sont enregistrés...", 
"body" : "Symbole: Fonction : La boîte de dialogue fournit des paramètres pour le Programme CNC objet. Appel : Affichage → Propriétés commander; menu contextuel de l'objet Exigence : L'objet CNC est sélectionné dans l'arborescence des appareils. Les paramètres CNC à l'échelle de l'application sont enregistrés dans le Paramètres CNC objet. " }, 
{ "title" : "Onglet : Général ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_e398c87e5062d26bc0a86520014051d1", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Objet : Programme CNC \/ Boîte de dialogue : propriétés CNC \/ Onglet : Général ", 
"snippet" : "Modifiez le nom de l'objet CNC....", 
"body" : "Modifiez le nom de l'objet CNC. " }, 
{ "title" : "Onglet : Contrôle d'accès ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_6f1287e45062d25bc0a865200009f33d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Objet : Programme CNC \/ Boîte de dialogue : propriétés CNC \/ Onglet : Contrôle d'accès ", 
"snippet" : "Ici, vous spécifiez les autorisations des groupes d'utilisateurs. Pour plus d'informations, consultez : Propriétés – Contrôle d'accès...", 
"body" : "Ici, vous spécifiez les autorisations des groupes d'utilisateurs. Pour plus d'informations, consultez : Propriétés – Contrôle d'accès " }, 
{ "title" : "Onglet : Créer ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_18be1ff163875181c0a865ca014256df", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Objet : Programme CNC \/ Boîte de dialogue : propriétés CNC \/ Onglet : Créer ", 
"snippet" : "Activez l'option pour exclure l'objet CNC de la construction. Les données IEC ne sont alors pas générées. Cependant, il est possible d'enregistrer le code G sous forme de fichier ASCII. Pour lire ce type de fichier à l'exécution, vous pouvez utiliser les blocs fonctions de la SM3_CNC une bibliothèqu...", 
"body" : "Activez l'option pour exclure l'objet CNC de la construction. Les données IEC ne sont alors pas générées. Cependant, il est possible d'enregistrer le code G sous forme de fichier ASCII. Pour lire ce type de fichier à l'exécution, vous pouvez utiliser les blocs fonctions de la SM3_CNC une bibliothèque. Pour plus d'informations, consultez : Propriétés – Contrôle d'accès " }, 
{ "title" : "CNC Languette ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Objet : Programme CNC \/ Boîte de dialogue : propriétés CNC \/ CNC Languette ", 
"snippet" : "Mise en œuvre Din66025 : La trajectoire de mouvement est définie dans le langage CNC DIN 66025. Table : La trajectoire de mouvement est définie au moyen du paramétrage d'une table. Mode de compilation Comportement à la compilation SMC_OutQueue : Une structure de données SMC_OutQueue est générée à la...", 
"body" : "Mise en œuvre Din66025 : La trajectoire de mouvement est définie dans le langage CNC DIN 66025. Table : La trajectoire de mouvement est définie au moyen du paramétrage d'une table. Mode de compilation Comportement à la compilation SMC_OutQueue : Une structure de données SMC_OutQueue est générée à la compilation. Vous bénéficiez d'un accès global au moyen de g_CNCQueueManager . SMC_CNC_REF : Les variables du programme sont générées à la compilation. Vous bénéficiez d'un accès global au moyen de g_CNCProgManager . Déposer : Un fichier généré par le code G est téléchargé et mis à jour à chaque connexion. L'automate peut télécharger ce fichier au moyen de blocs fonction. Les fichiers de code G sont mis à jour à chaque fois à chaque connexion à l'application. Cela signifie que les fichiers sur l'automate sont écrasés à chaque connexion. Nom de fichier Exigence: Mode de compilation est réglé sur Déposer . Défaut: $NomObjet$.cnc . Cette valeur par défaut est un espace réservé qui est remplacé par le nom d'objet de l'objet CNC (nom de fichier effectif) lors de la connexion. Seuls les caractères [a-zA-Z0-9$_.] sont autorisés dans un nom de fichier. Le champ du nom de fichier ne doit pas être vide ni commencer ou se terminer par un point. De plus, un point ne doit pas nécessairement faire partie du chemin dans le nom du fichier. Taille de la file d'attente [éléments] Par défaut : 100 Le paramètre de taille n'affecte pas la taille du fichier généré SMC_OutQueue structure de données (lorsque ce mode est sélectionné). La taille de SMC_OutQueue est déterminé uniquement par le nombre d'objets chemin. Cependant, le paramètre définit la taille de la mémoire tampon des FB de prétraitement (par exemple, SMC_NCDecoder , SMC_RoundPath ) qui sont utilisés en interne et définissent la taille du tampon d'anticipation. Les valeurs par défaut Vitesse (F) [u\/s] Cette valeur est utilisée lorsque la valeur de la vitesse (dans le mot \"F\") n'est pas définie dans le programme CNC. En unités de chemin par seconde. Plage de valeurs : [0, 1e9]. Par défaut : 0 Accélération (E+) [u\/s²] Cette valeur est utilisée lorsque la valeur de l'accélération (dans le mot \"E\" avec une valeur positive) n'est pas définie. En unités de chemin par seconde au carré. Plage de valeurs : ]0, 1e9]. Par défaut : 100 Décélération (E-) [u\/s²] Cette valeur est utilisée lorsque la valeur de la décélération (dans le mot \"E\" avec une valeur négative) n'est pas définie. En unités de chemin par seconde au carré. Plage de valeurs : ]0, 1e9]. Par défaut : 100 Valeurs par défaut pour l'avance rapide (G0) Vitesse (FF) [u\/s] Cette valeur est utilisée lorsque la valeur d'avance de la vitesse (dans le mot \"FF\") n'est pas définie dans le programme CNC. En unités de chemin par seconde. Plage de valeurs : [0, 1e9]. Par défaut : 0 Accélération (EF+) [u\/s²] Cette valeur est utilisée lorsque la valeur d'avance de l'accélération (dans le mot \"EF+\" avec une valeur positive) n'est pas définie. En unités de chemin par seconde au carré. Plage de valeurs : [0, 1e9]. Par défaut : 0 Décélération (EF-) [u\/s²] Cette valeur est utilisée lorsque la valeur d'avance de la décélération (dans le mot \"EF-\" avec une valeur négative) n'est pas définie. En unités de chemin par seconde au carré. Plage de valeurs : [0, 1e9]. Par défaut : 0 Mode 3D Exigence : mise en œuvre Din66025 , mode de traduction CNC_REF , et OUTQueue : le mode 3D est la valeur par défaut. Valeurs hors ligne des variables Variables : Si des valeurs hors ligne sont définies, le Valeurs hors ligne des variables la boîte de dialogue s'ouvre. Dans cette boîte de dialogue, des variables sont affichées et peuvent également être modifiées. La position de départ Par défaut : 0 Précision La précision du chemin en unités techniques. Cette valeur spécifie la précision des positions lues à partir du code G. Par exemple, si le code G est spécifié avec 3 décimales, la précision doit être définie sur 0,001 unités. La précision ne doit pas être négative. Cette valeur est utilisée, par exemple, par le prétraitement de chemin tel que SMC_ToolRadiusCorr et SMC_AvoidLoop . " }, 
{ "title" : "Objet : Paramètres CNC ", 
"url" : "_sm_obj_cnc_settings.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Objet : Paramètres CNC ", 
"snippet" : "Paramètres CNC Symbole: Les paramètres de cet objet sont valables pour tous les objets CNC de l'application. L'objet est ajouté à l'arborescence des appareils de l'application ou il est généré automatiquement lorsqu'un objet CNC est ajouté à l'application. L'objet ne peut exister qu'une seule fois p...", 
"body" : "Paramètres CNC Symbole: Les paramètres de cet objet sont valables pour tous les objets CNC de l'application. L'objet est ajouté à l'arborescence des appareils de l'application ou il est généré automatiquement lorsqu'un objet CNC est ajouté à l'application. L'objet ne peut exister qu'une seule fois par application et ne peut pas être renommé. Dans l'éditeur de l'objet, des paramètres peuvent être spécifiés pour les modules de prétraitement de trajectoire, la préinterpolation et l'éditeur tabulaire CNC. Vous pouvez supprimer le Paramètres CNC objet uniquement si aucun objet CNC n'existe sous l'application. Les réglages valables uniquement pour un programme CNC spécifique sont enregistrés dans le Paramètres dialogue du programme CNC. " }, 
{ "title" : "Onglet : Préprocesseurs de chemin ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_id_e55a0b19a1678229c0a8646353e40d98_id_de809dbaa55775c9c0a8646311985883", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Objet : Paramètres CNC \/ Onglet : Préprocesseurs de chemin ", 
"snippet" : "Sur cet onglet, le prétraitement du chemin est programmé en sélectionnant les blocs fonction. Blocs fonctionnels disponibles Liste de tous les blocs fonctionnels disponibles Instances de blocs fonctionnels actifs Liste des instances de blocs fonction sélectionnées La position dans la liste définit l...", 
"body" : "Sur cet onglet, le prétraitement du chemin est programmé en sélectionnant les blocs fonction. Blocs fonctionnels disponibles Liste de tous les blocs fonctionnels disponibles Instances de blocs fonctionnels actifs Liste des instances de blocs fonction sélectionnées La position dans la liste définit l'ordre de traitement et peut être modifiée. Un bloc fonction peut être instancié plusieurs fois dans la liste. Paramètre Ouvre le Editeur de paramètres pour <instance de bloc fonction active sélectionnée> dialogue Alternative : double-cliquez sur une instance de bloc fonction active Ajoute une instance du bloc fonction au Instances de blocs fonctionnels actifs qui est sélectionné dans Instances de blocs fonctionnels actifs Supprime l'instance de bloc fonction sélectionnée Les instances de blocs fonctionnels de blocs fonctionnels, qui sont affichées en italique gris clair, ne peuvent pas être supprimées. Déplace l'instance de bloc fonction active sélectionnée vers le haut d'une ligne Alternative : Appuyez sur Décalage + Flèche vers le haut Déplace l'instance de bloc fonction active sélectionnée vers le bas d'une ligne Alternative : Appuyez sur Décalage + Flèche vers le bas Editeur de paramètres pour <instance de bloc fonction active sélectionnée> Dialogue La boîte de dialogue est utilisée pour afficher et modifier les entrées de l'instance sélectionnée. Toutes les entrées ne sont pas visibles. Spalte1 Nom du paramètre de l'instance de bloc fonction active sélectionnée Spalte2 Zone de liste pour définir la valeur Spalt3 Description du paramètre " }, 
{ "title" : "Onglet : Préinterpolation ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_id_e55a0b19a1678229c0a8646353e40d98_id_9a258724a55775c9c0a8646350128da9", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Objet : Paramètres CNC \/ Onglet : Préinterpolation ", 
"snippet" : "Temps de cycle µs Temps d'interpolation Valeur initiale : 20000 Mode vitesse trapèze : Profil de vitesse avec forme trapézoïdale Sigmoïde : Profil de vitesse comme le profil trapézoïdal mais avec des fonctions sin² qui remplacent la rampe de vitesse linéaire Sigmoïde limité : Profil de vitesse comme...", 
"body" : "Temps de cycle µs Temps d'interpolation Valeur initiale : 20000 Mode vitesse trapèze : Profil de vitesse avec forme trapézoïdale Sigmoïde : Profil de vitesse comme le profil trapézoïdal mais avec des fonctions sin² qui remplacent la rampe de vitesse linéaire Sigmoïde limité : Profil de vitesse comme le profil sigmoïde mais avec prise en compte des limites d'accélération et de décélération Quadratique : Profil d'accélération de forme trapézoïdale avec limitation des à-coups tel que défini dans Secousse maximale . Le profil de vitesse quadratique résultant est également reconnu comme une courbe en S. Quadratique (lisse) : Fonctionne comme Quadratique mode mais génère un profil de secousse sans sauts. Secousse maximale [u\/s³] Limitation de la valeur absolue du jerk Utilisé uniquement pour le profil de vitesse quadratique Le temps d'interpolation et le temps de cycle de la tâche respective, dans laquelle l'interpolateur est appelé, doivent correspondre pour un comportement identique de l'éditeur CNC et de l'application en ligne. " }, 
{ "title" : "Onglet : Éditeur tabulaire ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_section-idm43260108321858", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Interface utilisateur \/ Objet : Paramètres CNC \/ Onglet : Éditeur tabulaire ", 
"snippet" : "Les colonnes de l'éditeur tabulaire et son ordre sont définis sur cet onglet. Colonnes du tableau Liste de tous les attributs disponibles : L'attribut est visible dans l'éditeur tabulaire. L'ordre dans cette liste détermine l'ordre des lignes dans l'éditeur tabulaire. Déplace l'attribut sélectionné ...", 
"body" : "Les colonnes de l'éditeur tabulaire et son ordre sont définis sur cet onglet. Colonnes du tableau Liste de tous les attributs disponibles : L'attribut est visible dans l'éditeur tabulaire. L'ordre dans cette liste détermine l'ordre des lignes dans l'éditeur tabulaire. Déplace l'attribut sélectionné vers le haut d'une ligne Déplace l'attribut sélectionné vers le bas d'une ligne " }, 
{ "title" : "CODESYS SoftMotion Robotics ", 
"url" : "_sm_f_robotics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Aperçu ", 
"url" : "_sm_overview_robotics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Aperçu ", 
"snippet" : "CODESYS SoftMotion Robotics fournit une interface de blocs fonctionnels pour le contrôle de mouvement des robots, basée sur la spécification PLCopen « Blocs fonctionnels pour le contrôle de mouvement Partie 4 ». Les séquences de mouvements complexes peuvent être composées de simples mouvements point...", 
"body" : "CODESYS SoftMotion Robotics fournit une interface de blocs fonctionnels pour le contrôle de mouvement des robots, basée sur la spécification PLCopen « Blocs fonctionnels pour le contrôle de mouvement Partie 4 ». Les séquences de mouvements complexes peuvent être composées de simples mouvements point à point ou de trajectoires continues, telles que des lignes droites ou des arcs de cercle. Une fusion configurable est possible entre les mouvements individuels (par exemple, en fonction de la distance ou de la vitesse). Les limites de vitesse, d'accélération et d'à-coup, tant sur les axes individuels que sur la trajectoire, sont prises en compte. La planification de la trajectoire se fait en ligne sur le CODESYS contrôleur, parallèlement à l’exécution du mouvement. De nouveaux mouvements peuvent être ajoutés au moment du traitement et sans arrêter le robot. La livraison comprend des modèles cinématiques pour différents robots standards, depuis les simples portiques jusqu'aux robots delta et SCARA et aux robots industriels typiques à six axes. Des modèles cinématiques personnalisés pour machines spéciales peuvent être liés sous la forme d'un bloc fonctionnel CEI 61131-3. De même, des modèles dynamiques peuvent être utilisés via une interface pour limiter les forces et les couples apparaissant et permettre le contrôle anticipé du couple. D'autres blocs fonctionnels sont utilisés pour implémenter facilement des cas d'utilisation typiques. Cela inclut la synchronisation avec les systèmes de coordonnées en mouvement, l'interruption et la reprise des mouvements ou le contrôle des sorties numériques de haute précision via des déclencheurs. " }, 
{ "title" : "Commencer ", 
"url" : "_sm_robotics_first_steps.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Commencer ", 
"snippet" : "Pour programmer les mouvements des axes d'un robot, vous devez d'abord créer un groupe d'axes sous l'application dans votre projet. Pour plus d'informations à ce sujet, consultez : Comment créer un groupe d'axes. Vous configurez le groupe d'axes créé avec la cinématique souhaitée. Vous insérez des a...", 
"body" : "Pour programmer les mouvements des axes d'un robot, vous devez d'abord créer un groupe d'axes sous l'application dans votre projet. Pour plus d'informations à ce sujet, consultez : Comment créer un groupe d'axes. Vous configurez le groupe d'axes créé avec la cinématique souhaitée. Vous insérez des axes réels ou virtuels sous l'appareil et reliez ces axes au groupe d'axes. Pour plus d'informations, consultez les pages d'aide dans Cinématique: États du groupe d'axesCombinaison de cinématiques de position et d'orientationJoints tournants et axes moduloAxes rotatifs avec plage de valeurs supérieure à 360°La création d'un programme pour la commande d'axes après la création et la configuration des axes est illustrée ici à titre d'exemple : Comment créer un programme pour contrôler le groupe d'axesPour plus d'informations sur la mise en œuvre des différentes demandes de contrôle de mouvement, consultez les pages d'aide supplémentaires dans Contrôle de mouvement . Mise en mémoire tampon et fusion des mouvementsJogging des groupes d'axesInterruption et poursuite des mouvementsSynchronisation avec un système de coordonnées en mouvementConfiguration d'un décalage d'outilDes informations générales pour comprendre comment des mouvements spécifiques sont effectués peuvent être trouvées ici : Interpolation d'orientation pour les mouvements de CPPour les utilisateurs avancés : Limitation de couple et commande d'avance de coupleCréation de cinématiques personnalisées" }, 
{ "title" : "Groupe d'axes ", 
"url" : "_sm_robotics_axis_group.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Groupe d'axes ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Comment créer un groupe d'axes ", 
"url" : "_sm_creating_an_axis_group.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Groupe d'axes \/ Comment créer un groupe d'axes ", 
"snippet" : "Ajout d'objets à l'arborescence des appareils Les étapes suivantes décrivent comment créer et configurer un groupe d'axes. Créer un nouveau projet standard avec CODESYS Control . Pour le POU PLC_PRG , sélectionnez la langue d'implémentation CFC. Dans l'arborescence des appareils, ouvrez le menu cont...", 
"body" : "Ajout d'objets à l'arborescence des appareils Les étapes suivantes décrivent comment créer et configurer un groupe d'axes. Créer un nouveau projet standard avec CODESYS Control . Pour le POU PLC_PRG , sélectionnez la langue d'implémentation CFC. Dans l'arborescence des appareils, ouvrez le menu contextuel de Appareil objet et sélectionnez le Activer SoftMotion commande. UN Groupe d'axes généraux SoftMotion l'objet est inséré sous le Appareil . Dans l'arborescence des appareils, sélectionnez Groupe d'axes généraux SoftMotion . Dans le menu contextuel, cliquez sur Ajouter un appareil . le Ajouter un appareil la boîte de dialogue s'ouvre. Sélectionnez le SM_Drive_Virtuel appareil. Spécifiez le nom de l'appareil comme \"DriveX\". De la même manière, insérez deux autres lecteurs nommés \"DriveY\" et \"DriveZ\" . Dans l'arborescence des appareils, ouvrez le menu contextuel du Application objet et cliquez Projet → Ajouter un objet → Groupe d'axes . Insérer l'objet avec le nom spécifié Groupe d'axes . le Groupe d'axes l'objet est inséré sous l'application. Le configurateur de groupes d'axes s'ouvre. Dans l'éditeur de configuration, cliquez sur le Sélectionner la cinématique bouton. le Sélectionner la cinématique La boîte de dialogue s'ouvre avec une liste de toutes les configurations cinématiques disponibles et leurs descriptions. Sélectionnez le TRAFO.Kin_Gantry3 configuration cinématique. L'éditeur de configuration de la configuration cinématique sélectionnée s'ouvre. Dans le Mappage sur les axes groupe de paramètres, mappez les axes aux entraînements utilisés dans le projet. Pour ce faire, précisez la valeur DriveX dans le X champ de saisie, la valeur DriveY dans le Oui champ de saisie et la valeur DriveZ dans le Z champ de saisie. Vous pouvez également utiliser l'Assistant de saisie pour sélectionner le lecteur ou faites-le glisser de l'arborescence des périphériques vers le champ de saisie. Pour plus d'informations, consultez : Editeur de groupes d'axes" }, 
{ "title" : "Editeur de groupes d'axes ", 
"url" : "_sm_obj_axis_group.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Groupe d'axes \/ Editeur de groupes d'axes ", 
"snippet" : "Symbole: Dans l'éditeur du Groupe d'axes objet, sélectionnez le type de cinématique de base et de cinématique d'orientation. La cinématique d'orientation ne peut être sélectionnée que si elle est prise en charge par la cinématique de base. De plus, vous mappez les axes de la cinématique aux entraîne...", 
"body" : "Symbole: Dans l'éditeur du Groupe d'axes objet, sélectionnez le type de cinématique de base et de cinématique d'orientation. La cinématique d'orientation ne peut être sélectionnée que si elle est prise en charge par la cinématique de base. De plus, vous mappez les axes de la cinématique aux entraînements de votre projet. Cinématique Sélectionnez la cinématique Changer la cinématique Ouvre une liste de toutes les cinématiques prises en charge par CODESYS Lorsque vous sélectionnez un type de cinématique, une brève description s'affiche dans le cadre à droite de la liste. Après avoir sélectionné un type de cinématique, vous pouvez modifier les paramètres respectifs dans l'éditeur. Cinématique d'orientation Sélectionnez la cinématique Changer la cinématique Ouvre une liste de toutes les cinématiques d'orientation prises en charge par CODESYS Lorsque vous sélectionnez un type de cinématique, une brève description s'affiche dans le cadre à droite de la liste. Après avoir sélectionné un type de cinématique, vous pouvez modifier les paramètres respectifs dans l'éditeur. Cartographie des axes En fonction de la cinématique sélectionnée, vous mappez les axes de la cinématique aux entraînements de votre projet. Axes supplémentaires Ajouter un axe Ajoute un champ de configuration pour un axe supplémentaire. Le lecteur du projet est saisi dans ce champ de configuration. Tâches Tâche de cycle de bus Tâche de cycle de bus des axes, si les axes sont déjà mappés Le réglage ne peut pas être modifié ici. Tâche de planification Tâche pour la planification des tâches du CP Une tâche de planification est créée automatiquement lors de l'insertion du premier groupe d'axes. Un chien de garde ne doit pas être configuré car le temps d'exécution peut fluctuer considérablement. Pour plus d'informations, voir : Configuration de la tâche de planificationSi vous supprimez cette tâche, une erreur est émise dans la vue des messages. Pour créer une nouvelle tâche, cliquez sur Projet → Créer une tâche de planification . Pour plus d'informations, consultez : Comment créer un groupe d'axes" }, 
{ "title" : "États du groupe d'axes ", 
"url" : "_sm_robotics_state_machine.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Groupe d'axes \/ États du groupe d'axes ", 
"snippet" : "L'image ci-dessous montre les états possibles pour les groupes d'axes et les transitions entre les états. Les erreurs des axes individuels dirigent toujours le groupe d'axes vers le GroupErrorStop État. Si le groupe d'axes passe à GroupMoving , alors tous les axes sont commutés sur SynchronizedMotio...", 
"body" : "L'image ci-dessous montre les états possibles pour les groupes d'axes et les transitions entre les états. Les erreurs des axes individuels dirigent toujours le groupe d'axes vers le GroupErrorStop État. Si le groupe d'axes passe à GroupMoving , alors tous les axes sont commutés sur SynchronizedMotion . Si le groupe d'axes passe de GroupMoving à GroupStandby , alors tous les axes sont commutés sur standstill . Si le groupe d'axes passe de GroupMoving à GroupErrorStop , alors tous les axes sont commutés sur GroupErrorStop . Si le groupe d'axes est en GroupStandby , alors les axes individuels ne sont pas nécessairement tous dans standstill parce qu'ils peuvent être contrôlés au moyen de blocs fonctionnels de mouvement à axe unique tels que MC_Jog . Si le mouvement se termine par une erreur, alors tous les mouvements suivants mis en mémoire tampon sont interrompus avec CommandAborted . Tant que le groupe d'axes suit un système de coordonnées dynamique, il restera dans GroupMoving . Le groupe d'axes est en GroupMoving si et seulement si le groupe est déplacé de manière coordonnée (par l'un des blocs de mouvement de la partie 4). Passer de GroupMoving à GroupStandby se fait un cycle après le dernier changement de position. " }, 
{ "title" : "Configuration de la tâche de planification ", 
"url" : "_sm_configuration_planning_task.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Groupe d'axes \/ Configuration de la tâche de planification ", 
"snippet" : "La planification des mouvements du groupe d'axes s'effectue dans une tâche distincte qui est automatiquement créée sous le nom \"SoftMotion_PlanningTask\" lors de l'insertion d'un groupe d'axes. Par défaut, cette tâche de planification s'exécute sur le même cœur de processeur que la tâche de bus. Sur ...", 
"body" : "La planification des mouvements du groupe d'axes s'effectue dans une tâche distincte qui est automatiquement créée sous le nom \"SoftMotion_PlanningTask\" lors de l'insertion d'un groupe d'axes. Par défaut, cette tâche de planification s'exécute sur le même cœur de processeur que la tâche de bus. Sur les systèmes multicœurs, il est conseillé de les localiser sur un cœur séparé. Selon que la tâche de planification s'exécute ou non sur son propre noyau, elle doit être configurée différemment. Noyau unique Si la tâche de planification s'exécute sur le même cœur que la tâche de bus, elle doit alors être configurée comme une tâche libre avec une faible priorité en temps réel. C'est le cas par défaut. La tâche de planification est automatiquement créée en tant que tâche libre avec la priorité 15. Multicœur Sur les systèmes multicœurs, la tâche de planification doit s'exécuter sur un cœur distinct avec la priorité la plus élevée (0). Le type de tâche doit être défini sur cyclique et l'intervalle de tâche sur une valeur faible (par exemple 2 ms). Avec ces paramètres, la tâche de planification dépassera fréquemment son intervalle de tâche. Il faut s'y attendre et ce n'est pas un problème. Les paramètres de tâche sont sélectionnés pour garantir que la tâche de planification soit à nouveau appelée immédiatement après une exécution. De cette manière, le noyau dédié est utilisé autant que possible pour la planification des mouvements. Pour plus d'informations sur la configuration des tâches, voir : Configuration des tâches Objet : Configuration des tâches Objet : Tâche " }, 
{ "title" : "Cinématique ", 
"url" : "_sm_robotics_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinématique ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Aperçu ", 
"url" : "_sm_overview_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinématique \/ Aperçu ", 
"snippet" : "L'une des tâches les plus importantes de la robotique consiste à déplacer un outil (par exemple, une plaque à outils ou un pistolet de soudage) le long d'une trajectoire prédéfinie. Pour ce faire, CODESYS SoftMotion Robotics calcule la manière dont les différentes articulations du robot doivent se d...", 
"body" : "L'une des tâches les plus importantes de la robotique consiste à déplacer un outil (par exemple, une plaque à outils ou un pistolet de soudage) le long d'une trajectoire prédéfinie. Pour ce faire, CODESYS SoftMotion Robotics calcule la manière dont les différentes articulations du robot doivent se déplacer pour que la pointe de l'outil, le point central de l'outil (TCP), suive la trajectoire commandée avec l'orientation souhaitée. La cinématique ou la transformation cinématique est fondamentale pour ce calcul. Il implémente la conversion des positions conjointes en position TCP et en orientation TCP, et vice versa La règle de calcul varie en fonction du type de robot utilisé. CODESYS SoftMotion Robotics inclut une cinématique configurable pour de nombreux robots standard. Pour plus d'informations, voir : Cinématique Inclus dans La cinématique est divisée en une cinématique de positionnement et une cinématique d'orientation qui peuvent être combinées. Pour plus d'informations, voir : Combinaison de cinématiques de position et d'orientationIl est possible de configurer un décalage d'outil qui peut être modifié lors de l'exécution. Pour plus d'informations, voir : Configuration d'un décalage d'outilDes axes modulo à rotation infinie sont pris en charge pour les joints rotatifs. Pour plus d'informations, voir : Joints tournants et axes moduloPour les types de robots spéciaux dont la règle de calcul ne peut pas être mappée par l'une des cinématiques fournies, vous pouvez implémenter votre propre cinématique sous la forme d'un bloc fonctionnel. Pour plus d'informations, voir : Création de cinématiques personnalisées" }, 
{ "title" : "Cinématique Inclus dans CODESYS SoftMotion ", 
"url" : "_sm_robotics_cds_sm_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinématique \/ Cinématique Inclus dans CODESYS SoftMotion ", 
"snippet" : "Systèmes de portique Nom Représentation Peut être lié à la cinématique d'orientation Informations Complémentaires Gantry2 ✓ Kin_Gantry2 (FB) Gantry3 ✓ Kin_Gantry3 (FB) HGantry2 ✓ Kin_HGantry2 (FB) HGantry3 ✓ Kin_HGantry3 (FB) TGantry2 ✓ Kin_TGantry2 (FB) portique 5 axes -- Kin_5Axes (FB) Systèmes SC...", 
"body" : "Systèmes de portique Nom Représentation Peut être lié à la cinématique d'orientation Informations Complémentaires Gantry2 ✓ Kin_Gantry2 (FB) Gantry3 ✓ Kin_Gantry3 (FB) HGantry2 ✓ Kin_HGantry2 (FB) HGantry3 ✓ Kin_HGantry3 (FB) TGantry2 ✓ Kin_TGantry2 (FB) portique 5 axes -- Kin_5Axes (FB) Systèmes SCARA Nom Représentation Peut être lié à la cinématique d'orientation Informations Complémentaires Polaire ✓ Kin_Polar (FB) Polaire avec axe Z ✓ Kin_Polar_Z (FB) Scara2 avec axe Z ✓ Kin_Scara2_Z (FB) Scara3 avec axe Z -- Kin_Scara3_Z (FB) Robots articulés Nom Représentation Peut être lié à la cinématique d'orientation Informations Complémentaires Robot articulé à 3 axes rotatifs ✓ Kin_Pos_RRR (FB) Palettiseur 4 axes -- Kin_4AxesPalettiseur (FB) Robot articulé 6 axes -- Kin_ArticulatedRobot_6DOF (FB) Systèmes parallèles Nom Représentation Peut être lié à la cinématique d'orientation Informations Complémentaires Bipied à axes rotatifs ✓ Kin_Bipod_Rotary (FB) Trépied à axes rotatifs ✓ Kin_Tripod_Rotary (FB) Trépied à axes linéaires ✓ Kin_Tripod_Linear (FB) Cinématique d'orientation Nom Représentation Informations Complémentaires Axe C Kin_CAxis (FB) Axe C avec outil Kin_CAxis_Tool (FB) Outil Kin_Tool (FB) Wrist2 Kin_Wrist2 (FB) Wrist3 Kin_Wrist3 (FB) " }, 
{ "title" : "Combinaison de cinématiques de position et d'orientation ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinématique \/ Combinaison de cinématiques de position et d'orientation ", 
"snippet" : "Avec le configurateur de groupes d'axes, vous pouvez combiner cinématique de position et cinématique d'orientation. De ce fait, un grand nombre de robots peuvent être configurés avec un petit nombre de cinématiques. Des exemples de cinématiques de position incluent les portiques ( Kin_Gantry3 ) et t...", 
"body" : "Avec le configurateur de groupes d'axes, vous pouvez combiner cinématique de position et cinématique d'orientation. De ce fait, un grand nombre de robots peuvent être configurés avec un petit nombre de cinématiques. Des exemples de cinématiques de position incluent les portiques ( Kin_Gantry3 ) et trépieds ( Kin_Tripod_Lin , Kin_Tripod_Rotary ). Ces cinématiques peuvent se déplacer vers n'importe quel point ou position, mais ne peuvent pas effectuer un certain nombre d'orientations. Le système de coordonnées avant d'un système cinématique de position est appelé système de coordonnées de bride. Il définit l'endroit où la cinématique d'orientation est fixée (figure de gauche). Des exemples de cinématique d'orientation sont Kin_CAxis , Kin_Wrist2 , et Kin_Wrist3 . Cette cinématique peut entraîner une orientation souhaitée du TCP, mais ne peut atteindre aucune position (voir figure de droite). En combinant à la fois la cinématique de position et la cinématique d'orientation, il est possible de parcourir un nombre quelconque de positions dans l'orientation souhaitée, ou inversement. Remarques sur la cinématique personnalisée Les utilisateurs qui souhaitent créer leur propre cinématique de position ou d'orientation doivent implémenter les interfaces supplémentaires suivantes dans leurs blocs fonction cinématique : Pour la cinématique de position : L'interface ISMPositionCinematics2 avec les méthodes AxesToOrientation et GetOrientationImage . AxesToOrientation est une transformation avant \"abrégé\" qui calcule l'orientation du système de coordonnées de bride à partir des valeurs d'axe. Il n'est nécessaire que pour des raisons d'efficacité. Par exemple, rien ne doit être calculé avec un portique, mais plutôt une orientation constante peut être renvoyée. GetOrientationImage renvoie comment l'orientation du système de coordonnées de bride peut changer. Cette méthode n'est nécessaire que pour vérifier si la cinématique d'orientation est compatible avec la cinématique de position. Pour la cinématique d'orientation : L'interface ISMToolKinematics2 avec les méthodes GetPositionFromOrientation2 et IsCompatibleWithPosKin . GetPositionFromOrientation2 calcule le vecteur entre le système de coordonnées de la bride et le TCP à partir de l'orientation souhaitée (en MCS). Ce calcul est nécessaire pour la transformation inverse de la cinématique combinée. La méthode IsCompatibleWithPosKin vérifie si la cinématique d'orientation est compatible avec la cinématique de position. " }, 
{ "title" : "Combinaisons invalides ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html#UUID-ccacfa9e-092b-a9a9-875d-01e9182027a1_id_dd90bf9efee04f9c0a8646352f64466_id_718d71abf014b14bc0a864635271f262", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinématique \/ Combinaison de cinématiques de position et d'orientation \/ Combinaisons invalides ", 
"snippet" : "Toutes les combinaisons de cinématique de position et de cinématique d'orientation ne sont pas possibles car parfois une transformation inverse unique ne peut pas être déterminée. Un exemple est un SCARA avec deux articulations comme cinématique de position et Kin_CAxis_Tool comme cinématique d'orie...", 
"body" : "Toutes les combinaisons de cinématique de position et de cinématique d'orientation ne sont pas possibles car parfois une transformation inverse unique ne peut pas être déterminée. Un exemple est un SCARA avec deux articulations comme cinématique de position et Kin_CAxis_Tool comme cinématique d'orientation avec une correction d'outil différente de 0 dans la coordonnée X ou Y. L'orientation du système de coordonnées de bride du SCARA n'est pas constante. Il est tourné autour de l'axe Z par rapport à la position 0. Pour le calcul de la transformation inverse, cette rotation n'est pas encore connue, ce qui ne permet pas de déterminer clairement les angles d'axe dans ce cas. La possibilité d'une combinaison peut être vérifiée lors de l'exécution, car cela dépend du paramétrage de la cinématique. Dans ce cas, l'erreur SMC_TRAFO_INVALID_COUPLING est émis. " }, 
{ "title" : "Comportement lors de la programmation d'orientations \"impossibles\" ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html#UUID-ccacfa9e-092b-a9a9-875d-01e9182027a1_id_dd90bf9efee04f9c0a8646352f64466_id_5ba01e61f014b14bc0a86463044fcdf7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinématique \/ Combinaison de cinématiques de position et d'orientation \/ Comportement lors de la programmation d'orientations \"impossibles\" ", 
"snippet" : "En pratique, il est souvent utile de pouvoir programmer des orientations qui ne sont pas disponibles pour la cinématique. Comme exemple simple, considérons un robot SCARA avec un outil ayant un degré de liberté (rotation autour de l'axe Z). En principe, ce robot ne peut accepter que des orientations...", 
"body" : "En pratique, il est souvent utile de pouvoir programmer des orientations qui ne sont pas disponibles pour la cinématique. Comme exemple simple, considérons un robot SCARA avec un outil ayant un degré de liberté (rotation autour de l'axe Z). En principe, ce robot ne peut accepter que des orientations dans lesquelles l'outil pointe verticalement vers le bas. Lorsque des positions doivent être parcourues sur une pièce, celle-ci sera facilement inclinée depuis le plan X\/Y. L'utilisateur enseigne la pièce à usiner puis programme les positions et orientations relatives à la pièce à usiner. L'inclinaison de la pièce entraîne des orientations dans lesquelles la direction de l'outil est légèrement inclinée par rapport à la verticale. Comment gérer une orientation aussi impossible et inaccessible ? Une mesure drastique serait de signaler une violation de l’espace de travail. Cependant, comme le montre l’exemple, cela rendrait la programmation fastidieuse. Par conséquent, la cinématique d’orientation ( Kin_CAxis_Tool dans cet exemple) sont mis en œuvre de telle manière qu'ils adoptent l'orientation la plus proche possible. Dans cet exemple, cela signifie que l'orientation commandée est inclinée de telle sorte que l'outil se tienne debout et que cette orientation soit acceptée. Le comportement peut être réduit aux règles suivantes (à condition que la cinématique de position puisse se positionner dans les trois directions spatiales) : La position est toujours approchée exactement (sinon une erreur est signalée). L'orientation est \"projetée\" sur la plus proche accessible si elle n'est pas accessible. Lors de la projection de l'orientation, la direction de l'outil est prioritaire. Les difficultés décrites ici surviennent parce que la cinématique d'orientation n'a pas les trois degrés de liberté pour atteindre toutes les orientations souhaitées. C'est le cas avec Kin_Wrist2 et Kin_CAxis , mais pas avec Kin_Wrist3 . Des difficultés supplémentaires surviennent lorsque la cinématique de position n'a pas non plus tous les degrés de liberté spatiaux. (Cela ne se produit pas souvent dans la pratique.) Un exemple est la combinaison de Kin_Gantry2 , un portique positionnable en X\/Y uniquement, et avec Kin_Wrist2 , un outil avec seulement deux degrés de liberté. Dans ce cas, il y a des orientations impossibles ainsi que des positions impossibles, car la coordonnée Z est déjà définie par la longueur de l'outil et la position de l'axe d'orientation. Par conséquent, nous vous recommandons de ne pas utiliser ce genre de combinaisons, mais de ne programmer que des positions atteignables. " }, 
{ "title" : "Configurations cinématiques ", 
"url" : "_sm_configure_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinématique \/ Configurations cinématiques ", 
"snippet" : "Une configuration cinématique décrit la disposition des axes dans un groupe d'axes les uns par rapport aux autres. Selon la cinématique, plusieurs configurations sont possibles pour une même position TCP. Par exemple, deux configurations possibles sont présentées pour SCARA 2. Le groupe d'axes a une...", 
"body" : "Une configuration cinématique décrit la disposition des axes dans un groupe d'axes les uns par rapport aux autres. Selon la cinématique, plusieurs configurations sont possibles pour une même position TCP. Par exemple, deux configurations possibles sont présentées pour SCARA 2. Le groupe d'axes a une configuration active qui ne doit pas nécessairement correspondre aux positions d'axes actuelles. Si un mouvement est commandé, alors la position cible peut être convertie en coordonnées d'axe. La configuration active au moment de la commande est utilisée. Cette configuration active peut être définie avec le bloc fonction SMC_SetKinConfiguration . Lors de l'initialisation et à chaque changement de cinématique, le groupe d'axes applique la configuration standard. Toute cinématique avec une configuration a une configuration standard. Un mouvement CP entre deux configurations n'est pas possible. Dans ce cas, le positionnement doit être effectué au moyen d'un mouvement PTP. La configuration actuelle peut être déterminée avec le bloc fonction MC_GroupReadActualPosition . " }, 
{ "title" : "Réglage de la configuration pour une conception cinématique ", 
"url" : "_sm_configure_kinematics.html#UUID-a0dd90bd-a3ae-b4c7-c573-b244e5ca8497_id_fd441540121e3a8c0a8646325f17a66_id_b2318eb4acf011e79acc88930c5b16a7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinématique \/ Configurations cinématiques \/ Réglage de la configuration pour une conception cinématique ", 
"snippet" : "Chaque conception cinématique avec une configuration possède son propre POU pour le calcul des données de configuration. Le nom de ce bloc fonction correspond au nom de la cinématique plus le suffixe _config . Le POU convertit les différentes configurations dans le type de données ConfigData . Ce ty...", 
"body" : "Chaque conception cinématique avec une configuration possède son propre POU pour le calcul des données de configuration. Le nom de ce bloc fonction correspond au nom de la cinématique plus le suffixe _config . Le POU convertit les différentes configurations dans le type de données ConfigData . Ce type de données est transmis au bloc fonction SMC_SetKinConfiguration . Exemple : définition d'une configuration pour une conception cinématique SCARA 2 Appeler le bloc fonction Kin_Scara2_Z_Config de la bibliothèque SM3_Transformation . Saisir xElbowRight = VRAI Le bloc fonctionnel fournit les données de configuration de type ConfigData . Appeler le bloc fonction SMC_SetKinConfiguration de la bibliothèque SM3_Robotics . Ecrire l'entrée ConfigData avec les données de configuration préalablement déterminées. Définissez la configuration active du SCARA 2. VAR\n config: TRAFO.Kin_Scara2_Z_Config;\n skc: SMC_SetKinConfiguration;\nEND_VAR\n\nconfig(xElbowRight := TRUE);\nskc(AxisGroup := Scara2, Execute := TRUE, ConfigData := config.Config); " }, 
{ "title" : "Manipulation de la cinématique couplée ", 
"url" : "_sm_configure_kinematics.html#UUID-a0dd90bd-a3ae-b4c7-c573-b244e5ca8497_id_fd441540121e3a8c0a8646325f17a66_id_b22c1067acf011e79acc88930c5b16a7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinématique \/ Configurations cinématiques \/ Manipulation de la cinématique couplée ", 
"snippet" : "Il existe une cinématique couplée lorsque la cinématique de position et la cinématique d'orientation sont utilisées simultanément. Cela se traduit par la configuration \"couplée\" des deux configurations en appelant Kin_Coupled_Config de la bibliothèque SM3_Transformation . La configuration de la ciné...", 
"body" : "Il existe une cinématique couplée lorsque la cinématique de position et la cinématique d'orientation sont utilisées simultanément. Cela se traduit par la configuration \"couplée\" des deux configurations en appelant Kin_Coupled_Config de la bibliothèque SM3_Transformation . La configuration de la cinématique de position et de la cinématique d'orientation est fournie au bloc fonction aux entrées. Pour plus d'informations, consultez : Axes rotatifs avec plage de valeurs supérieure à 360°" }, 
{ "title" : "Configuration d'un décalage d'outil ", 
"url" : "_sm_configure_tool_offset.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinématique \/ Configuration d'un décalage d'outil ", 
"snippet" : "Vous pouvez définir le décalage entre le système de coordonnées de bride de la cinématique (XYZ) et le système de coordonnées TCP de la cinématique (X'Y'Z') en configurant une correction d'outil. Cette correction d'outil agit sur tous les déplacements ultérieurs. TCP : point central de l'outil La co...", 
"body" : "Vous pouvez définir le décalage entre le système de coordonnées de bride de la cinématique (XYZ) et le système de coordonnées TCP de la cinématique (X'Y'Z') en configurant une correction d'outil. Cette correction d'outil agit sur tous les déplacements ultérieurs. TCP : point central de l'outil La correction d'outil est spécifiée par un décalage v=(x,y,z) et une rotation r=(A,B,C) dans les angles d'Euler ZYZ. Le décalage et la rotation sont exprimés par rapport au système de coordonnées de bride de la cinématique. Lorsque vous configurez un correcteur d'outil, celui-ci peut être incompatible avec la cinématique actuelle. En conséquence, un décalage d'outil peut empêcher la cinématique d'atteindre les orientations. Dans cette situation, une erreur est émise et le correcteur d'outil est ignoré. Par exemple, vous pouvez configurer un correcteur d'outil dans la direction Z pour la cinématique Kin_Scara2_Z . En revanche, un décalage avec des pièces dans la direction X ou Y entraîne une erreur. Lorsque les cinématiques présentent ce type de restrictions, elles sont décrites avec le cinématique . " }, 
{ "title" : "Bloc fonction : SMC_GroupSetTool ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_348cb75b4119d4bfc0a864631ca28fed", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinématique \/ Configuration d'un décalage d'outil \/ Bloc fonction : SMC_GroupSetTool ", 
"snippet" : "Le bloc fonction configure la correction d'outil spécifiée à l'entrée ToolOffset (taper MC_COORD_REF ) pour un groupe d'axes. Cependant, tant que le groupe d'axes est dans l'état GroupDisabled ou GroupErrorStop , non la correction d'outil peut être configurée. Si l'outil n'est pas compatible avec la...", 
"body" : "Le bloc fonction configure la correction d'outil spécifiée à l'entrée ToolOffset (taper MC_COORD_REF ) pour un groupe d'axes. Cependant, tant que le groupe d'axes est dans l'état GroupDisabled ou GroupErrorStop , non la correction d'outil peut être configurée. Si l'outil n'est pas compatible avec la cinématique actuelle, alors le POU émet l'erreur SMC_AXIS_GROUP_TOOL_OFFSET_INCOMPATIBLE_WITH_KINEMATICS . Cette erreur est également émise si l'interface ISMKinematicsWithOrientationImage n'a pas été implémenté pour la description de la cinématique. " }, 
{ "title" : "Bloc fonctionnel : SMC_GroupReadTool ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_c1689be51d4132b4c0a864637c06bdff", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinématique \/ Configuration d'un décalage d'outil \/ Bloc fonctionnel : SMC_GroupReadTool ", 
"snippet" : "Ce bloc fonction lit la correction d'outil : sortie ToolOffset (taper MC_COORD_REF ). Dans ce processus, l'entrée ReadMode détermine si l'outil du mouvement actif, le dernier mouvement commandé ou l'outil actuellement défini dans le groupe d'axes doit être lu....", 
"body" : "Ce bloc fonction lit la correction d'outil : sortie ToolOffset (taper MC_COORD_REF ). Dans ce processus, l'entrée ReadMode détermine si l'outil du mouvement actif, le dernier mouvement commandé ou l'outil actuellement défini dans le groupe d'axes doit être lu. " }, 
{ "title" : "Cinématiques compatibles ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_ff04bb6d41a8190bc0a864635e26fe13", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinématique \/ Configuration d'un décalage d'outil \/ Cinématiques compatibles ", 
"snippet" : "Toutes les cinématiques ne prennent pas en charge toutes les corrections d'outil. La liste suivante indique quels outils sont adaptés à quelle cinématique. Cinématique Outil compatible Cinématique SCARA 2 Kin_Scara2_Z Outils avec décalage de position dans la direction Z et décalage dans l'orientatio...", 
"body" : "Toutes les cinématiques ne prennent pas en charge toutes les corrections d'outil. La liste suivante indique quels outils sont adaptés à quelle cinématique. Cinématique Outil compatible Cinématique SCARA 2 Kin_Scara2_Z Outils avec décalage de position dans la direction Z et décalage dans l'orientation Cinématique SCARA 3 Kin_Scara3_Z Tous les outils Cinématique polaire Kin_Polar , Kin_Polar_Z Outils avec décalage de position dans la direction Z et décalage dans l'orientation Robot articulé 3 axes Kin_Pos_RRR Outils avec un décalage dans l'orientation Robot articulé 6 axes Kin_ArticulatedRobot_6DOF Tous les outils Palettiseur 4 axes Kin_4AxisPalletizer Tous les outils Bipied Kin_Bipod_Rotary Tous les outils Portique 5 axes Kin_5Axes Tous les outils Systèmes de portique Tous les outils Système de portique en H Tous les outils Système de portique en T Tous les outils Trépied rotatif ou linéaire Tous les outils Si un système cinématique n'a pas 3 degrés de liberté pour l'orientation, il se peut que toutes les corrections d'outil ne soient pas compatibles. " }, 
{ "title" : "Pour une cinématique personnalisée ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_6c7b39581d4132b4c0a8646366a3228c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinématique \/ Configuration d'un décalage d'outil \/ Pour une cinématique personnalisée ", 
"snippet" : "Afin d'utiliser votre cinématique personnalisée avec un correcteur d'outil, vous devez implémenter le ISMKinematicsWithOrientationImage interface. Pour ajouter un correcteur d'outil pour votre cinématique de position personnalisée, vous devez d'abord implémenter l'interface ISMPositionKinematics2 ....", 
"body" : "Afin d'utiliser votre cinématique personnalisée avec un correcteur d'outil, vous devez implémenter le ISMKinematicsWithOrientationImage interface. Pour ajouter un correcteur d'outil pour votre cinématique de position personnalisée, vous devez d'abord implémenter l'interface ISMPositionKinematics2 . " }, 
{ "title" : "Interface : ISMKinematicsWithOrientationImage ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_592ee99f1d4132b4c0a864637bd8a061", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinématique \/ Configuration d'un décalage d'outil \/ Interface : ISMKinematicsWithOrientationImage ", 
"snippet" : "L'interface cinématique fournit la méthode GetFlangeOrientationImage avec la variable mR_Flange du type de données SMC_Matrix3 , qui contient l'orientation commandée de la bride. En conséquence, la méthode renvoie les orientations résultantes possibles oriInfo comme type de données OrientationSpace ...", 
"body" : "L'interface cinématique fournit la méthode GetFlangeOrientationImage avec la variable mR_Flange du type de données SMC_Matrix3 , qui contient l'orientation commandée de la bride. En conséquence, la méthode renvoie les orientations résultantes possibles oriInfo comme type de données OrientationSpace . Comportement de l'interface En particulier, lorsque l'orientation de la bride dans l'orientation commandée est connue, dof = zero est retourné et mOriZero est réglé sur l'orientation connue. Si l'orientation R de la bride n'est que partiellement connue sous la forme R*vU = vRot (où vU et vRot sont des vecteurs unitaires connus), alors dof = one est retourné. mOriZero est réglé sur une orientation dans l'espace accessible. Autrement, dof = three est retourné. Une correction d'outil spécifiée est compatible avec la cinématique si la position de la bride peut être calculée de manière unique en tenant compte de l'orientation calculée. C'est toujours le cas lorsque l'orientation calculée peut être obtenue par la cinématique. La correction d'outil peut être incompatible uniquement si toutes les orientations ne peuvent pas être atteintes. De plus, si la méthode GetFlangeOrientationImage Retour dof = zero , alors chaque correction d'outil est compatible. Si la méthode retourne dof = one , alors seul le décalage de la position de l'outil v_off parallèle au vecteur unitaire vU est compatible. Dans ce cas, R*v_off = R*vU*x = vRot*x ne dépend pas des parties inconnues de la matrice d'orientation R . Cela inclut également un décalage d'outil avec v_off = 0 (où x = 0). Si dof = three est renvoyé, alors seuls les décalages de position sans décalage en x\/y\/z sont compatibles. Remarques sur la mise en œuvre Implémenter l'interface ISMOrientationKinematicsWithOriImage2 pour la cinématique d'orientation. Ensuite, une correction d'outil peut être utilisée pour coupler la cinématique d'orientation avec la cinématique de position. L'interface a la méthode GetOrientationImage2 avec la variable VAR_IN_OUT CONSTANT mR_Flange du type de données SMC_Matrix3 , qui contient l'orientation commandée de la bride. La méthode retourne csTool et oriinfo avec le type de données OrientationSpace dans le repère de base de la cinématique d'orientation. De plus, la méthode revient dans bActive si les degrés de liberté de orinfo sont actifs ( TRUE ) ou passif ( FALSE ). Exemple de degrés de liberté actifs : Kin_CAxis . La rotation autour de l'axe z est contrôlée par l'axe cinématique d'orientation. Exemple de degrés de liberté passifs : Kin_Wrist2 . Le degré de liberté restant est la rotation de X\/Y autour de l'axe Z, qui pointe dans la direction programmée par l'utilisateur. Lorsque le dernier mouvement commandé et le nouveau mouvement sont des mouvements CP (les deux mouvements linéaires ou rotatifs) lors d'un changement d'outil, le mode tampon du mouvement suivant passe de Blending ou Aborting à Buffered . Si vous configurez une nouvelle correction d'outil après MC_GroupInterrupt et avant MC_GroupContinue , l'ancienne correction d'outil est utilisée pour les déplacements interrompus. La nouvelle correction d'outil n'est utilisée que pour les mouvements commandés ultérieurement. Lorsque la cinématique est modifiée ( MC_SetKinTransform ), la correction d'outil est réinitialisée (pas de décalage, pas de rotation). " }, 
{ "title" : "Joints tournants et axes modulo ", 
"url" : "_sm_robotics_rotary_joints_modulo_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinématique \/ Joints tournants et axes modulo ", 
"snippet" : "Les axes modulo au sein des groupes d'axes sont pris en charge à partir de SoftMotion 4.12.0.0. Les axes modulo ne sont autorisés que pour les articulations tournantes de la cinématique. Ce sont des joints tournants pour lesquels SMKinematicWithInfo.GetAxisProperties renvoie la valeur props.eType = ...", 
"body" : "Les axes modulo au sein des groupes d'axes sont pris en charge à partir de SoftMotion 4.12.0.0. Les axes modulo ne sont autorisés que pour les articulations tournantes de la cinématique. Ce sont des joints tournants pour lesquels SMKinematicWithInfo.GetAxisProperties renvoie la valeur props.eType = Axis_Type.Rotary . Si un axe modulo est utilisé pour un joint linéaire ou pour une cinématique qui ne met pas en œuvre ISMKinematicWithInfo , alors MC_GroupEnable renvoie le SMC_MODULO_AXIS_FOR_NON_ROTARY_JOINT Erreur. Si un axe modulo est utilisé et que la cinématique limite la plage d'un joint tournant, alors MC_GroupEnable renvoie le SMC_MODULO_AXIS_FOR_LIMITED_ROTARY_JOINT Erreur. Les axes modulo ne sont pris en charge que si la période modulo est de 360°. La raison en est que les axes reliés aux joints tournants doivent être configurés de telle sorte qu'une unité technique [u] corresponde à un degré angulaire [°]. Une période doit correspondre à une rotation complète. Si un axe modulo avec une période autre que 360° est utilisé, alors MC_GroupEnable renvoie le SMC_MODULO_AXIS_PERIOD_NOT_360 Erreur. Depuis la version 4.12.0.0, SoftMotion ne prend en charge que le shortest modes ( MC_DIRECTION ). Cela signifie que la distance et la direction d'un axe modulo sont sélectionnées de manière à ce qu'elles soient aussi proches que possible de la position de départ de l'axe. Par exemple, si l'axe d'orientation est à a2 = 30° au début du mouvement et à a2 = 290° à la position cible, alors la position a2 = 290° – 360° = –70° est sélectionnée et l'axe se déplace 100° dans le sens négatif au lieu de se déplacer de 260° dans le sens positif. " }, 
{ "title" : "Création de cinématiques personnalisées ", 
"url" : "_sm_kinematic_transformations.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Cinématique \/ Création de cinématiques personnalisées ", 
"snippet" : "L'outil open source wkhtmltopdf est nécessaire pour générer la documentation de la cinématique à partir des commentaires du bloc fonction. Cependant, ce composant n'est plus inclus dans la configuration de CODESYS version 3.5 SP15 et supérieure. Vous pouvez télécharger la DLL à partir de https:\/\/wkh...", 
"body" : "L'outil open source wkhtmltopdf est nécessaire pour générer la documentation de la cinématique à partir des commentaires du bloc fonction. Cependant, ce composant n'est plus inclus dans la configuration de CODESYS version 3.5 SP15 et supérieure. Vous pouvez télécharger la DLL à partir de https:\/\/wkhtmltopdf.org\/downloads.html . Créer un répertoire nommé DocScripting\\3.5.xx.x\\bin dans le répertoire d'installation de CODESYS et enregistrez le fichier wkhtmltox.dll là. Attention : depuis wkhtmltox.dll ne prend plus en charge les images par défaut dans la version 0.12.6 et supérieure, vous devez utiliser la version 0.12.5 ou inférieure. Lorsqu'une instance d'une transformation cinématique d'un groupe d'axes est utilisée, les entrées de l'instance ne doivent plus être modifiées. Pour modifier le paramétrage de la transformation cinématique, il faut utiliser la configuration si possible, ou créer plusieurs instances. Lorsque vous créez une cinématique personnalisée, vous devez respecter les points suivants : La cinématique est décrite par des blocs fonctionnels spéciaux qui peuvent être stockés dans des bibliothèques ou dans le POU vision du projet. Pour CODESYS pour lister la cinématique dans le configurateur, les blocs fonctions associés doivent implémenter MC_KIN_REF_SM3 interface (partie de SM3_Transformation.library ). Vous pouvez définir une cinématique comme une combinaison de deux autres cinématiques. Les cinématiques avec possibilité de fixer des plaques à outils ou des outils doivent également mettre en œuvre les ISMPositionCinématique2 interface. Les cinématiques qui spécifient une plaque à outils ou un outil doivent mettre en œuvre les ISMToolKinematics2 interface. Si vous n'implémentez que ISMPositionKinematics \/ ISMToolKinematics à la place de ISMPositionKinematics2 \/ ISMToolKinematics2 , les orientations \"non disponibles\" pourraient être traitées de manière incorrecte. Lorsque vous implémentez également l'interface ISMPositionKinematics_Offset , vous pouvez utiliser le mode d'orientation Axis . Lorsque le POU a le sm_kin_libdoc , le commentaire spécifié dans le bloc fonction est utilisé dans le configurateur comme description de la cinématique. Le formatage \"Texte restructuré\" est utilisé pour cela. Notez cependant que les liens ne sont pas pris en charge. Les paramètres liés à la conception, tels que les longueurs et les angles des bras, sont créés en tant que variables VAR_INPUT du bloc fonctionnel. Vous devez commenter les paramètres car le commentaire sert de description dans le configurateur. Si les paramètres sont de type numérique et que leur plage de valeurs est restreinte, ils doivent alors être fournis avec le sm_kin_param_range attribut. La syntaxe de la plage de valeurs est [a .. b] pour les intervalles fermés et ]a .. b[ pour les intervalles ouverts. Les formulaires combinés ]a .. b] et [a .. b[ sont également possibles. Dans ce but, a et b doivent être des littéraux appropriés pour le type de paramètre. Les valeurs spéciales +inf et -inf sont possibles pour les limites d'intervalle ouvertes. Exemples: [0 .. 1] , [1 .. +inf[ , ]-inf .. -5] . Les paramètres peuvent être de n'importe quel type numérique ou BOOL . Les paramètres doivent avoir une valeur initiale utilisée comme valeur par défaut. Vous pouvez spécifier l'unité du paramètre avec l'attribut facultatif sm_kin_param_unit (exemple : \"rad\", \"°\", \"deg\"). Vous devez utiliser l'unité \"u\" pour les longueurs et les distances. L'application et la mise à l'échelle des variateurs déterminent si ces unités sont \"mm\", \"cm\" ou \"m\". Si aucune documentation de bibliothèque n'est disponible pour le bloc fonctionnel, le commentaire de l'élément FB est affiché aux emplacements respectifs comme option de secours. La langue configurée dans CODESYS est la langue affichée pour la documentation LibDoc. Si une localisation n'est pas disponible dans cette langue, la langue par défaut de la bibliothèque est utilisée. Les noms d'axes de la cinématique sont définis par l'attribut FB sm_kin_axes . La valeur de l'attribut est une liste de noms d'axes (exemple : \"A1, A2, A3\"). Une icône facultative est spécifiée avec l'attribut FB sm_kin_icon . La valeur est indiquée sous la forme <image pool>.<identifier> . Le pool d'images est spécifié par rapport au bloc fonctionnel. Si vous créez un bloc fonction cinématique personnalisé avec des axes rotatifs (par exemple, Kin_Scara3_Z_Config ), alors vous devez utiliser le concept de période pour ces axes et implémenter le ISMKinPeriodHandling interface. Pour les axes rotatifs, seule la transformation cinématique inverse ( CartesianToAxes ) est responsable du calcul de l'angle. Puis CODESYS SoftMotion décale automatiquement cet angle à la période correcte. Par exemple, si la transformation calcule un angle dans la plage ]-180°, 180°], alors CODESYS SoftMotion décale cet angle dans la plage [0°, 360°[, à condition que les limites logicielles de l'entraînement soient de 0° .. 360°. De plus, vous devez mettre en œuvre le ISMKinematicsWithConfiguration3 interface. C'est le seul moyen de s'assurer que la cinématique des mouvements CP fonctionne sans problème. Dans le cas d'une cinématique couplée avec une disposition irrégulière de la cinématique de position et d'orientation, vous devez implémenter la ISMCoupledKinematics3 interface. De cette manière, le système peut détecter si un axe pour la cinématique de position ou d'orientation appartient ou non au numéro d'axe respectif. Remarque : Vous devez implémenter le ISMKinematicWithConfigurations2.CPConnectible de manière à ce que les paramètres de période soient ignorés lors de la comparaison. Puis CPConnectible renvoie la valeur TRUE , même si le paramètre de période est différent. Toutes les transformations inverses ont une entrée de type CONFIGDATA qui contient un tableau d'octets avec des informations sur la configuration de la cinématique. Les transformations directes ont une sortie correspondante. Les cinématiques avec une configuration doivent implémenter ISMKinematicWithConfigurations interface. Ces cinématiques comportent chacune un bloc fonction qui doit implémenter ISMConfigurationData interface (fonction de sérialisation des données de configuration). Le nom de ce bloc fonction doit être le même que celui de la cinématique plus le suffixe _config . Vous pouvez utiliser ce FB pour modifier la configuration dans l'application (à l'aide du bloc fonction SMC_SetKinConfiguration bloquer). Cependant, la cinématique ne doit contenir aucune instance du FB correspondant. Pour obtenir des instructions étape par étape, consultez le Cinématique personnalisée chapitre. " }, 
{ "title" : "Systèmes de coordonnées ", 
"url" : "_sm_coordinate_systems.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Systèmes de coordonnées ", 
"snippet" : "CODESYS SoftMotion Robotics fournit différents systèmes de coordonnées dans lesquels les mouvements peuvent être commandés. Système de coordonnées des axes (ACS) Système de coordonnées d'outils (TCS) Système de coordonnées mondial (WCS) Système de coordonnées de la machine (MCS) Système de coordonné...", 
"body" : "CODESYS SoftMotion Robotics fournit différents systèmes de coordonnées dans lesquels les mouvements peuvent être commandés. Système de coordonnées des axes (ACS) Système de coordonnées d'outils (TCS) Système de coordonnées mondial (WCS) Système de coordonnées de la machine (MCS) Système de coordonnées du produit (PCS_1, PCS_2) Système de coordonnées Descriptif Système de coordonnées des axes (ACS) Le système de coordonnées des axes définit un système de coordonnées dans l'espace des axes où chaque axe du robot couvre une dimension. Il est ainsi possible de spécifier une position pour chaque axe du robot. Système de coordonnées d'outils (TCS) Le système de coordonnées de l'outil est un système de coordonnées cartésien situé sur le point central de l'outil (TCP) de la cinématique. Sa position et son orientation dépendent de la position du robot. Système de coordonnées mondial (WCS) Le système de coordonnées mondial est un système de coordonnées cartésien statique qui constitue la base de tous les systèmes de coordonnées suivants. Ils sont définis par rapport au système de coordonnées mondial. Système de coordonnées de la machine (MCS) Le système de coordonnées de la machine est un système de coordonnées cartésien statique. La position et l'orientation du MCS par rapport au robot physique sont définies par la cinématique Le MC_SetCoordinateTransform Un bloc fonctionnel peut être utilisé pour déplacer le système de coordonnées par rapport au système de coordonnées mondial (WCS). Système de coordonnées du produit (PCS_1, PCS_2) Les systèmes de coordonnées des produits sont des systèmes de coordonnées cartésiens qui peuvent être définis par l'utilisateur. Ils sont exprimés par rapport au système de coordonnées mondial (WCS) et peuvent être statiques ou dynamiques Statique Le MC_SetCoordinateTransform Un bloc fonctionnel peut être utilisé pour déplacer les systèmes de coordonnées par rapport au système de coordonnées mondial (WCS). Dynamique Les blocs fonctionnels suivants peuvent être utilisés pour définir des systèmes de coordonnées dynamiques : MC_SetDynCoordTransform SMC_Set DyncoordTransformEx Courroie transporteuse MC_Track Table rotative MC_Track " }, 
{ "title" : "Position initiale et orientation des systèmes de coordonnées ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056579261585", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Systèmes de coordonnées \/ Position initiale et orientation des systèmes de coordonnées ", 
"snippet" : "La cinématique du robot détermine la position initiale et l'orientation des systèmes de coordonnées. Ceci est décrit dans la documentation de la cinématique La cinématique définit les éléments suivants : Position et orientation du système de coordonnées de la machine (MCS) par rapport au robot physi...", 
"body" : "La cinématique du robot détermine la position initiale et l'orientation des systèmes de coordonnées. Ceci est décrit dans la documentation de la cinématique La cinématique définit les éléments suivants : Position et orientation du système de coordonnées de la machine (MCS) par rapport au robot physique Position et orientation du point central de l'outil (TCP) par rapport au MCS et donc au système de coordonnées de l'outil (TCS) Position zéro du robot ainsi que sens de rotation ou de mouvement des différents axes Le système de coordonnées mondial (WCS) et les systèmes de coordonnées du produit (PCS_1, PCS_2) ne sont pas initialement décalés et sont identiques au système de coordonnées de la machine. " }, 
{ "title" : "Robots et pièces multiples ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056581220108", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Systèmes de coordonnées \/ Robots et pièces multiples ", 
"snippet" : "La position et l'orientation des systèmes de coordonnées sont définies pour chaque robot. Lorsque plusieurs robots travaillent ensemble, il peut être utile de définir le système de coordonnées mondial (WCS) comme un système de coordonnées de base commun. Sur la base de ce système de coordonnées, les...", 
"body" : "La position et l'orientation des systèmes de coordonnées sont définies pour chaque robot. Lorsque plusieurs robots travaillent ensemble, il peut être utile de définir le système de coordonnées mondial (WCS) comme un système de coordonnées de base commun. Sur la base de ce système de coordonnées, les systèmes de coordonnées des machines (MCS) et les systèmes de coordonnées des produits (PCS_1, PCS_2) des robots individuels peuvent être " }, 
{ "title" : "Exemple ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056581719182", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Systèmes de coordonnées \/ Exemple ", 
"snippet" : "Exemple d'utilisation d'un robot à deux joints rotatifs ( a0 et a1 )...", 
"body" : "Exemple d'utilisation d'un robot à deux joints rotatifs ( a0 et a1 ) " }, 
{ "title" : "Cinématique ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056582142746", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Systèmes de coordonnées \/ Exemple \/ Cinématique ", 
"snippet" : "La cinématique définit la position zéro du robot (comme indiqué ci-dessous). L'origine du système de coordonnées de la machine se trouve sur l'axe de rotation de l'axe a0 . L'axe X pointe dans la direction du premier maillon lorsque la position du premier a0 est 0 . L'axe Y pointe dans la direction ...", 
"body" : "La cinématique définit la position zéro du robot (comme indiqué ci-dessous). L'origine du système de coordonnées de la machine se trouve sur l'axe de rotation de l'axe a0 . L'axe X pointe dans la direction du premier maillon lorsque la position du premier a0 est 0 . L'axe Y pointe dans la direction du premier maillon lorsque la position du premier a0 est +90° . La rotation dans le sens antihoraire correspond au sens de rotation positif. Le point central de l'outil (TCP) se trouve à l'extrémité de la deuxième liaison du robot (comme indiqué ci-dessous) et constitue l'origine du TCS. Le TCS est aligné de telle sorte que l'axe X longe le second " }, 
{ "title" : "Système de coordonnées des axes (ACS) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056582875889", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Systèmes de coordonnées \/ Exemple \/ Système de coordonnées des axes (ACS) ", 
"snippet" : "La cinématique a spécifié la position zéro du robot et le sens de rotation des différents axes. Parce que le robot est composé de deux axes a0 et a1 , nous pouvons spécifier les positions des axes a0 et a1 dans l'ACS. Dans la première image, nous indiquons la position ( a0:= 0, a1:= 0 ). Cela corres...", 
"body" : "La cinématique a spécifié la position zéro du robot et le sens de rotation des différents axes. Parce que le robot est composé de deux axes a0 et a1 , nous pouvons spécifier les positions des axes a0 et a1 dans l'ACS. Dans la première image, nous indiquons la position ( a0:= 0, a1:= 0 ). Cela correspond à la position zéro du robot. Dans la deuxième image, nous indiquons la position ( a0:= 90, a1:= 0 ). En partant de la position zéro, le premier axe a0 est pivoté 90° dans le sens de rotation positif. Le deuxième axe a1 reste en position zéro. Dans la troisième image, nous indiquons la position ( a0:= 90, a1:= -90 ). En partant de la position zéro, le premier axe a0 est pivoté 90° dans le sens de rotation positif (comme dans la deuxième image). De plus, le deuxième axe a1 est pivoté 90° dans le sens négatif de la rotation. " }, 
{ "title" : "Système de coordonnées d'outils (TCS) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056583569251", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Systèmes de coordonnées \/ Exemple \/ Système de coordonnées d'outils (TCS) ", 
"snippet" : "La cinématique définit la position et l'orientation du TCP et du TCS. En fonction de la façon dont nous déplaçons le robot, la position et l'orientation du TCS changent également...", 
"body" : "La cinématique définit la position et l'orientation du TCP et du TCS. En fonction de la façon dont nous déplaçons le robot, la position et l'orientation du TCS changent également " }, 
{ "title" : "Système de coordonnées mondial (WCS), système de coordonnées machine (MCS) et système de coordonnées produit (PCS_1, PCS_2) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056584038831", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Systèmes de coordonnées \/ Exemple \/ Système de coordonnées mondial (WCS), système de coordonnées machine (MCS) et système de coordonnées produit (PCS_1, PCS_2) ", 
"snippet" : "Dans un hall de production, deux robots se tiennent à gauche et à droite d'un tapis roulant. Les robots doivent traiter les produits sur la bande transporteuse. Nous définissons un système de coordonnées mondial commun et le plaçons dans le coin supérieur gauche de notre hall de production. À partir...", 
"body" : "Dans un hall de production, deux robots se tiennent à gauche et à droite d'un tapis roulant. Les robots doivent traiter les produits sur la bande transporteuse. Nous définissons un système de coordonnées mondial commun et le plaçons dans le coin supérieur gauche de notre hall de production. À partir de ce système de coordonnées, nous déterminons la distance et la rotation par rapport aux systèmes de coordonnées de la machine et au produit et nous décalons les systèmes de coordonnées en conséquence. Dans l'exemple, tous les systèmes de coordonnées sont alignés de la même manière, il suffit de les déplacer. Le système de coordonnées machine du robot gauche est décalé dans la direction Y, le système de coordonnées machine du robot droit est décalé dans la direction X et le système de coordonnées du produit est décalé à la fois dans la direction X et dans la direction " }, 
{ "title" : "Contrôle de mouvement ", 
"url" : "_sm_f_motion_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Aperçu ", 
"url" : "_sm_overview_robotics_motion_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Aperçu ", 
"snippet" : "Ce chapitre décrit les types de mouvements de base en robotique : Jogging SMC_GroupJog2 Mouvements PTP (Point à Point) MC_MoveDirectAbsolu MC_MoveDirectRelative Mouvements CP (chemin continu) MC_MoveLinearAbsolute MC_MoveLinearRelative MC_MoveCircularAbsolute MC_MoveCircularRelative Attendez SMC_Gro...", 
"body" : "Ce chapitre décrit les types de mouvements de base en robotique : Jogging SMC_GroupJog2 Mouvements PTP (Point à Point) MC_MoveDirectAbsolu MC_MoveDirectRelative Mouvements CP (chemin continu) MC_MoveLinearAbsolute MC_MoveLinearRelative MC_MoveCircularAbsolute MC_MoveCircularRelative Attendez SMC_GroupWait Arrêtez (voir Arrêt sur le chemin avec MC_GroupHalt ou MC_GroupStop et Interruption et poursuite des mouvements) MC_GroupHalt MC_GroupStop MC_GroupInterrupt De plus, tous les sujets importants liés aux mouvements sont également expliqués : Mise en mémoire tampon et fusion des mouvementsSynchronisation avec un système de coordonnées en mouvementSynchronisation des axes externes, contrôle de l'avance du coupleAxes supplémentairesDiagnostic en cas de mouvements lents ou saccadés" }, 
{ "title" : "Comment créer un programme pour contrôler le groupe d'axes ", 
"url" : "_sm_creating_an_axis_group_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Comment créer un programme pour contrôler le groupe d'axes ", 
"snippet" : "Les instructions suivantes décrivent comment créer un programme pour contrôler un groupe d'axes. Exigence : Un projet a été créé avec un groupe d'axes, comme spécifié dans le Comment créer un groupe d'axes chapitre. Le programme de commande d'un groupe d'axes est créé dans le PLC_PRG POU avec CFC co...", 
"body" : "Les instructions suivantes décrivent comment créer un programme pour contrôler un groupe d'axes. Exigence : Un projet a été créé avec un groupe d'axes, comme spécifié dans le Comment créer un groupe d'axes chapitre. Le programme de commande d'un groupe d'axes est créé dans le PLC_PRG POU avec CFC comme langage d'implémentation. Ouvrez le PLC_PRG programme dans l'éditeur. Faites glisser le Boîte élément à l'éditeur. Mapper le bloc fonction SMC_GroupPower à la boîte. Configurez le bloc fonction selon l'image suivante. Explication: Le bloc fonction active les entraînements du groupe d'axes. Le résultat Status indique une activation réussie du contrôleur. Créer un bloc fonction de type MC_GroupEnable . Ce bloc fonction transfère le contrôle des axes liés au AxisGroup groupe d'axes. Connectez le Status sortie de la SMC_GroupPower bloc fonctionnel au Execute entrée de la MC_GroupEnable bloc fonctionnel. Explication: Lorsque tous les contrôleurs d'axes du groupe d'axes sont alimentés (Status = TRUE), le groupe d'axes sera activé. Le Done la sortie signale le succès de la commande. Insérez un MC_MoveDirectAbsolute bloc fonctionnel pour faire fonctionner le variateur. Connectez le Done sortie de la MC_GroupEnable bloc fonctionnel au Execute entrée de la MC_MoveDirectAbsolute bloc fonctionnel. Prolongez le programme comme suit : Explication: Le MC_MoveDirectAbsolute Le bloc fonctionnel commande un mouvement PTP du Groupe d'axes groupe d’axes. Dans l'exemple, la cinématique est déplacée vers la position (X = 10, Y= 20, Z = 30). Cette valeur est mappée à la Position saisie via le SMC_POS_REF structure. La position est spécifiée dans le système de coordonnées machine (MCS). Le système de coordonnées est sélectionné à l'aide de la CoordSystem saisir. Démarrage du programme Si le programme a été entièrement créé et qu'il peut être compilé sans erreur, vous pouvez le transférer dans l'automate. Commencer le CODESYS Control Win système d'exécution ( CODESYSControlService.exe programme dans le \"...\\GatewayPLC\" annuaire). Dans le Paramètres de communication , définissez le chemin de connexion à votre contrôleur. Cliquez sur En ligne → Se connecter . Téléchargez le projet dans le contrôleur. Cliquez sur Débogage → Démarrer . Dans l'éditeur, ouvrez le AxisGroup objet. Les positions des axes sont affichées. Cliquez sur Déboguer → Commencer . Les positions des axes changent. " }, 
{ "title" : "Jogging des groupes d'axes ", 
"url" : "_sm_cartesian_jogging.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Jogging des groupes d'axes ", 
"snippet" : "Vous pouvez utiliser le SMC_GroupJog2 bloc fonction pour déplacer un groupe d'axes dans l'espace. Le SMC_GroupJog2 Le bloc fonctionnel possède deux entrées booléennes pour chaque coordonnée. Une entrée est destinée au déplacement vers l'avant le long de cette coordonnée, et une entrée est destinée a...", 
"body" : "Vous pouvez utiliser le SMC_GroupJog2 bloc fonction pour déplacer un groupe d'axes dans l'espace. Le SMC_GroupJog2 Le bloc fonctionnel possède deux entrées booléennes pour chaque coordonnée. Une entrée est destinée au déplacement vers l'avant le long de cette coordonnée, et une entrée est destinée au déplacement vers l'arrière. Les entrées booléennes pour les différentes coordonnées de SMC_GroupJog2 peut être interprété de différentes manières. Par exemple, en coordonnées cartésiennes, en coordonnées machine, en coordonnées d'axe ou en coordonnées d'outil, selon le système de coordonnées défini. Avec une entrée spéciale ABC_as_ACS: BOOL , X\/Y\/Z et les axes de la cinématique de l'outil peuvent être déplacés simultanément en coordonnées cartésiennes et en coordonnées d'axe. Le jogging \"mixte\" n'est pris en charge que lorsque les cinématiques sont couplées et que les cinématiques de position implémentent l'interface ISMPositionKinematics_Offset . (Sinon, le bloc fonction génère une erreur.) En mode pas à pas, A fait tourner le TCP autour de l'axe X du système de coordonnées configuré (MCS, WCS, PCS ou TCS). B et C font pivoter le TCP autour des axes Y et Z dans le même système de coordonnées. Cependant, cela ne s'applique que lorsque ABC_as_ACS = FALSE . Le jogging cartésien commence lorsque le SMC_GroupJog2 bloc fonction reçoit un front montant et définit le Busy sortir. Le jogging cartésien provoque l'interruption des mouvements coordonnés actifs ou des mouvements des axes de la cinématique. Le jogging cartésien se termine lorsque le jogging est interrompu par un mouvement (coordonné ou sur les axes de la cinématique) ou lorsque la position est hors de l'espace de travail. Lors du pilotage manuel, les limites d'axes sont toujours maintenues sur les axes de la cinématique. Pour plus d'informations, consultez : Faire du jogging avec un robot" }, 
{ "title" : "Mouvements PTP invariants sur le chemin ", 
"url" : "_sm_robotics_path_invariant_ptp_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Mouvements PTP invariants sur le chemin ", 
"snippet" : "Pour les mouvements PTP, la trajectoire dans l'espace dépend de la cinématique et seuls les points de départ et d'arrivée sont fixes. Le mouvement est entièrement synchrone de sorte que la phase d'accélération, de mouvement constant et de décélération pour tous les axes commence et se termine en mêm...", 
"body" : "Pour les mouvements PTP, la trajectoire dans l'espace dépend de la cinématique et seuls les points de départ et d'arrivée sont fixes. Le mouvement est entièrement synchrone de sorte que la phase d'accélération, de mouvement constant et de décélération pour tous les axes commence et se termine en même temps. Les mouvements PTP sont toujours invariants de chemin et, par conséquent, les caractéristiques suivantes s'appliquent : Le chemin est indépendant de la dérogation. La trajectoire est indépendante de toutes les limites dynamiques des axes (limites de vitesse, d'accélération, de décélération et d'à-coup). La seule exception est pour déterminer les points de coupure dans TMStartVelocity mode. Dans TMCornerDistance mode, le chemin est indépendant du type de fusion ( BlendingHigh \/ Low \/ Previous \/ Next ). Le chemin n'est pas quitté à l'arrêt ou à l'arrêt ( MC_GroupHalt \/ MC_GroupStop ). Le chemin n'est pas quitté en cas d'interruption ou de poursuite ( MC_GroupInterrupt \/ MC_GroupContinue ). " }, 
{ "title" : "Mouvements du PC ", 
"url" : "_sm_robotics_cp_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Mouvements du PC ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Aperçu ", 
"url" : "_sm_overview_robotics_motion_control_cp.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Mouvements du PC \/ Aperçu ", 
"snippet" : "Les mouvements CP (Continuous Path) sont donnés par leur trajectoire géométrique. Dans le cas de la robotique, ce sont des segments linéaires ( MC_MoveLinearAbsolute et MC_MoveLinearRelative ) et des segments circulaires ( MC_MoveCircularAbsolute et MC_MoveCircularRelative ). Une vitesse de trajecto...", 
"body" : "Les mouvements CP (Continuous Path) sont donnés par leur trajectoire géométrique. Dans le cas de la robotique, ce sont des segments linéaires ( MC_MoveLinearAbsolute et MC_MoveLinearRelative ) et des segments circulaires ( MC_MoveCircularAbsolute et MC_MoveCircularRelative ). Une vitesse de trajectoire maximale, une accélération de trajectoire maximale et une secousse de trajectoire maximale peuvent être spécifiées pour les mouvements CP. Si le mélange est effectué entre deux mouvements CP, et si les deux mouvements se situent dans un plan commun, alors ce plan n'est pas quitté lors du mélange. Par exemple, deux segments de droite consécutifs se trouvent toujours dans un seul plan. La géométrie du chemin ne détermine pas encore comment l'orientation du TCP est transférée de l'orientation de départ à l'orientation cible. Ceci est expliqué dans le Interpolation d'orientation pour les mouvements de CP section. Les mouvements CP commencent et se terminent toujours de la même manière configuration du robot. Il n'est pas possible de modifier la configuration avec les mouvements CP car le robot se déplacerait dans une position singulière. Le mouvement à travers une position singulière peut conduire à des vitesses d’axe illimitées. Vous pouvez utiliser Mouvements PTP invariants sur le chemin pour basculer entre les configurations. " }, 
{ "title" : "Interpolation d'orientation pour les mouvements de CP ", 
"url" : "_sm_robotics_orientation_interpolation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Mouvements du PC \/ Interpolation d'orientation pour les mouvements de CP ", 
"snippet" : "Dans le cas de mouvements CP tels que MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute , ou MC_MoveCircularRelative , toute orientation cible de l'outil peut être spécifiée au moyen de la position cible du mouvement. La conséquence est que l'orientation de l'outil est converti...", 
"body" : "Dans le cas de mouvements CP tels que MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute , ou MC_MoveCircularRelative , toute orientation cible de l'outil peut être spécifiée au moyen de la position cible du mouvement. La conséquence est que l'orientation de l'outil est convertie en orientation cible pendant le mouvement de la trajectoire avec la pointe de l'outil se déplaçant sur la trajectoire. Pour l'interpolation d'orientation, le système de coordonnées dans lequel l'orientation cible a été donnée ne fait aucune différence, que ce soit en coordonnées d'axe (ACS) ou en coordonnées machine (MCS). L'image suivante montre une interpolation linéaire avec l'interpolation d'orientation simultanée. La flèche rouge indique la direction de l'outil aux points de départ et d'arrivée. La ligne rouge en pointillé indique comment l'outil est positionné à certains endroits pendant l'interpolation. Les blocs fonction mentionnés ci-dessus pour les déplacements sur trajectoire ont la OrientationMode saisir. Cette entrée définit comment l'orientation de départ est transmise à l'orientation cible. Interpolation grand cercle ( SMC_Orientation_Mode.GreatCircle ) Il s'agit d'un paramètre par défaut. Avec ce réglage, l'orientation de départ est également transmise à l'orientation cible sur la distance la plus courte. La distance la plus courte signifie que l'outil est tourné dans l'orientation cible de sorte que l'angle de rotation parcouru est minimisé. Interpolation de l'orientation des axes ( SMC_Orientation_Mode.Axis ) Exemple 1 : interpolation de grand cercle Considérons un portique ayant un axe C avec une plage de valeurs de -360° à 360°. L'orientation de départ est C=179° et l'orientation cible est C=-175°. L'interpolation du grand cercle déplace l'axe C de l'angle d'Euler ZYZ (A,B,C) proportionnellement à la distance parcourue sur la trajectoire de 179° dans le sens positif au-delà de 180° à 185°, ce qui correspond à -175°. Dans ce cas, il parcourt un angle total de 6°. Exemple 2 : Interpolation d'orientation d'axe Considérons à nouveau le portique ayant un axe C avec une plage de valeurs de -180° à 180°. L'orientation de départ est C=179° et l'orientation cible est C=-175°. L'interpolation d'axe déplace l'axe C du portique proportionnellement à la distance parcourue sur le trajet de 179° dans le sens négatif au-delà de 0° à -175°, parcourant un angle total de 354°. (Si l'interpolation du grand cercle était utilisée dans cet exemple, une erreur se serait produite, car l'espace de travail de l'axe C aurait été dépassé.) Ces deux types d'interpolation diffèrent par certaines caractéristiques importantes. Dans l'interpolation grand cercle, le changement d'orientation de l'outil peut être prédit. Dans l'interpolation des axes, il est difficile de prédire le changement d'orientation, car les axes d'orientation peuvent affecter l'orientation différemment selon la position. L'interpolation d'orientation d'axe partage cette caractéristique avec les mouvements PTP. (Cependant, cela ne signifie pas qu'il est difficile de prédire le chemin dans l'espace pour l'interpolation d'orientation d'axe. Le chemin est le même pour les deux types d'interpolation d'orientation, et le TCP parcourt toujours exactement le contour défini.) Avec l'interpolation de grand cercle, les singularités dans la cinématique d'orientation ne peuvent pas être parcourues. Ceci est facilement possible avec l'interpolation d'axe. Dans l'interpolation grand cercle, des violations des limites des axes d'orientation peuvent en résulter, comme mentionné dans le deuxième exemple. Lors de la commande, il faut donc s'assurer qu'aucune limite d'axe n'est violée lors du déplacement vers l'orientation cible avec la rotation la plus courte. Avec l'interpolation des axes, il est possible de tourner à plus de 360°. Si un axe d'orientation a un espace de travail de plus de 360°, vous pouvez par exemple vous déplacer jusqu'à la position 540° au lieu de la position 180°. Cela correspond à la même orientation de l'outil. Avec l’interpolation grand cercle, cela n’est pas possible. La rotation la plus courte vers l'orientation cible correspond toujours à un angle total de 180° au maximum. L'interpolation de l'orientation des axes nécessite une cinématique couplée composée d'une cinématique de position et d'outil. La partie position doit implémenter l'interface ISMPositionKinematics_Offset2 . Si la cinématique n'a pas d'axes rotatifs et qu'elle implémente l'interface ISMPositionKinematics , puis le mode d'orientation sélectionné ( SMC_Orientation_Mode ) est ignoré. Singularités dans l'interpolation de l'orientation des axes Avec l'interpolation d'orientation d'axe, un mouvement de trajectoire peut avoir lieu à travers les singularités de la cinématique d'orientation, ce qui peut faciliter considérablement la programmation. Les singularités de la cinématique de position changent à cet effet. Dans le cas d'une grande interpolation circulaire, Scara3_Z a une singularité si le point d'aile (A3) est situé sur la ligne définie par la première partie du bras (si le deuxième angle de joint est de 0°). Pour l'interpolation d'orientation d'axe, les singularités de la cinématique de position changent de sorte que le TCP assume le rôle que le point d'aile (A3) a par ailleurs. Cette singularité se produit lorsque le TCP (pas le point de bride) est situé sur la ligne définie par la première partie du bras. Lors de la commande d'un mouvement avec interpolation d'orientation d'axe, il est vérifié si cette singularité modifiée se situe ou non entre les positions de départ et d'arrivée du mouvement. Si c'est le cas, le mouvement n'est pas accepté et une erreur est émise. Pour les robots à bras articulés 6 axes, la situation est comparable à Scara3_Z, mais deux singularités sont possibles. Le premier se produit lorsque le TCP est situé sur la ligne passant par A2 et A3. La seconde se produit lorsque le TCP est situé sur la ligne passant par A1. Le commandant vérifie également ici qu'aucune singularité n'est traversée. Il peut arriver que la configuration de Scara3 (ou du robot à bras articulé 6 axes) change lors des déplacements avec interpolation de l'orientation des axes. Cependant, à la fin du mouvement, la même configuration que le robot avait au point de départ est toujours appliquée. " }, 
{ "title" : "Axes supplémentaires ", 
"url" : "_sm_additional_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Axes supplémentaires ", 
"snippet" : "Les axes supplémentaires sont des axes qui font partie du groupe d'axes mais ne font pas partie de la cinématique. Ils peuvent être déplacés de manière synchrone avec le mouvement coordonné de la cinématique. Les axes supplémentaires et les axes de la cinématique commencent à se déplacer et atteigne...", 
"body" : "Les axes supplémentaires sont des axes qui font partie du groupe d'axes mais ne font pas partie de la cinématique. Ils peuvent être déplacés de manière synchrone avec le mouvement coordonné de la cinématique. Les axes supplémentaires et les axes de la cinématique commencent à se déplacer et atteignent leur position cible en même temps. Les mouvements des axes supplémentaires sont tamponnés et combinés avec des mouvements coordonnés. Il en va de même pour les mouvements d'axes supplémentaires purs, sans aucun mouvement de la cinématique " }, 
{ "title" : "Différences par rapport aux mouvements à axe unique ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062102818545", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Axes supplémentaires \/ Différences par rapport aux mouvements à axe unique ", 
"snippet" : "La principale différence par rapport aux mouvements à axe unique qui sont commandés par des blocs fonctionnels tels que MC_MoveAbsolute ou MC_MoveRelative est la synchronisation du mouvement. Si la synchronisation n'est pas importante, il peut être judicieux de commander les axes à l'aide de blocs f...", 
"body" : "La principale différence par rapport aux mouvements à axe unique qui sont commandés par des blocs fonctionnels tels que MC_MoveAbsolute ou MC_MoveRelative est la synchronisation du mouvement. Si la synchronisation n'est pas importante, il peut être judicieux de commander les axes à l'aide de blocs fonctionnels à axe unique, car les axes peuvent alors être déplacés plus rapidement. Une autre différence réside dans le fait que les axes supplémentaires sont gérés conjointement avec le groupe d'axes. Ils sont activés avec SMC_GroupPower et les erreurs peuvent être réinitialisées avec MC_GroupReset . Il convient de noter qu'une erreur sur un axe sur un axe supplémentaire entraînera une erreur de groupe d'axes " }, 
{ "title" : "Commander des mouvements d'axes supplémentaires ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062103093337", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Axes supplémentaires \/ Commander des mouvements d'axes supplémentaires ", 
"snippet" : "Lorsque vous commandez des mouvements d'axes supplémentaires, vous pouvez toujours choisir entre des mouvements absolus et relatifs, que le mouvement principal du groupe d'axes soit absolu ou relatif. Par exemple, un mouvement d'axe supplémentaire relatif peut être commandé de manière synchrone avec...", 
"body" : "Lorsque vous commandez des mouvements d'axes supplémentaires, vous pouvez toujours choisir entre des mouvements absolus et relatifs, que le mouvement principal du groupe d'axes soit absolu ou relatif. Par exemple, un mouvement d'axe supplémentaire relatif peut être commandé de manière synchrone avec un MC_MoveLinearAbsolute commande. Les mouvements d'axe supplémentaires sont commandés via le AdditionalAxes entrée des blocs de fonction de mouvement pour le groupe d'axes. Par exemple, un mouvement PTP absolu avec un mouvement d'axe supplémentaire relatif peut être commandé comme suit : Si seuls les axes supplémentaires doivent être déplacés, alors un mouvement coordonné de longueur 0 (par exemple, MC_MoveDirectRelative avec distance 0 ) peuvent être commandés conjointement avec un mouvement d'axe supplémentaire. " }, 
{ "title" : "Remarques ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062106608843", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Axes supplémentaires \/ Remarques ", 
"snippet" : "Les axes Modulo sont également pris en charge en tant qu'axes supplémentaires. Ils sont toujours exploités en shortest mode pour des mouvements d'axes supplémentaires absolus. Pour plus d'informations, consultez les rubriques suivantes : MC_DirectionMC_Direction Le nombre maximum d'axes supplémentai...", 
"body" : "Les axes Modulo sont également pris en charge en tant qu'axes supplémentaires. Ils sont toujours exploités en shortest mode pour des mouvements d'axes supplémentaires absolus. Pour plus d'informations, consultez les rubriques suivantes : MC_DirectionMC_Direction Le nombre maximum d'axes supplémentaires est limité par le paramètre de bibliothèque MAX_NUM_ADDITIONAL_AXES à partir du SM3_CPKernelDefaults bibliothèque. Ce paramètre peut être modifié dans le gestionnaire de bibliothèques. Pour un exemple d'utilisation d'axes supplémentaires, consultez les rubriques suivantes : Utilisation d'axes supplémentaires en robotique" }, 
{ "title" : "Tolérances pour la précision du chemin ", 
"url" : "_sm_path_accuracy_tolerances.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Tolérances pour la précision du chemin ", 
"snippet" : "Des tolérances pour la précision de la trajectoire peuvent être définies pour les groupes d'axes. En cas de mouvement inattendu d'un repère dynamique, ces tolérances permettent à un groupe d'axes de rattraper ce repère au lieu de s'arrêter avec erreur SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED , SMC_AXIS_...", 
"body" : "Des tolérances pour la précision de la trajectoire peuvent être définies pour les groupes d'axes. En cas de mouvement inattendu d'un repère dynamique, ces tolérances permettent à un groupe d'axes de rattraper ce repère au lieu de s'arrêter avec erreur SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED , SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED , ou SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED . " }, 
{ "title" : "Aperçu ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4560250800668834033944790208", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Tolérances pour la précision du chemin \/ Aperçu ", 
"snippet" : "Pourquoi des tolérances sont-elles nécessaires pour la précision de la trajectoire ? Idéalement, le groupe d’axes devrait suivre exactement le chemin. Cependant, si un système de coordonnées dynamiques est utilisé (par exemple, un objet sur une courroie ou une table rotative, ou un système de coordo...", 
"body" : "Pourquoi des tolérances sont-elles nécessaires pour la précision de la trajectoire ? Idéalement, le groupe d’axes devrait suivre exactement le chemin. Cependant, si un système de coordonnées dynamiques est utilisé (par exemple, un objet sur une courroie ou une table rotative, ou un système de coordonnées spécifié par un autre groupe d'axes), il n'est dans certains cas pas possible de suivre le chemin. Exemple : Un robot doit placer une pièce sur un tapis roulant. La courroie se déplace à une vitesse constante, mais juste avant que le robot n'atteigne la position de placement de la pièce, la courroie accélère de manière inattendue. Dans cette situation, la trajectoire de mise en place de la pièce a déjà été calculée, mais en supposant que la bande continue de se déplacer à vitesse constante. Par conséquent, le mouvement restant peut désormais conduire à une violation de l'accélération maximale de l'un des axes du robot. Dans des situations comme celle-ci, les tolérances sont importantes. Ils permettent au groupe d'axes de s'écarter du chemin dans les limites spécifiées et de rattraper le système de coordonnées. La précision du chemin est contrôlée par un filtre. Le filtre reçoit la trajectoire prévue ( q_ref ) et les dernières positions cibles calculées ( q_set ) comme entrée. La sortie du filtre sont les positions cibles ( q_set ), qui sont transférés aux lecteurs. Si q_ref viole l'une des limites de l'axe, le filtre quitte alors la trajectoire et suit au plus près la trajectoire prévue sans violer une limite de l'axe. Tant que le décalage entre q_set et q_ref est dans les tolérances, aucune erreur n'est générée. Les tolérances pour la précision de trajectoire se composent de plusieurs valeurs : Décalage maximum du TCP en unités techniques (valeur par défaut : 1 u ) Erreur d'orientation maximale du TCP en degrés angulaires (valeur par défaut : 1 deg ) Retard maximum autorisé de chaque axe en unités techniques de l'axe (valeur par défaut : infini) " }, 
{ "title" : "Effet sur les blocs fonctionnels d'administration ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4579672191731234033944887183", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Tolérances pour la précision du chemin \/ Effet sur les blocs fonctionnels d'administration ", 
"snippet" : "Les valeurs de position, de vitesse, d'accélération et d'à-coup renvoyées par le SMC_GroupReadSetPosition , SMC_GroupReadSetVelocity , SMC_GroupReadSetAcceleration , et SMC_GroupReadSetJerk les blocs fonctionnels sont calculés en fonction de la trajectoire prévue ( q_ref ). Ils ne contiennent donc p...", 
"body" : "Les valeurs de position, de vitesse, d'accélération et d'à-coup renvoyées par le SMC_GroupReadSetPosition , SMC_GroupReadSetVelocity , SMC_GroupReadSetAcceleration , et SMC_GroupReadSetJerk les blocs fonctionnels sont calculés en fonction de la trajectoire prévue ( q_ref ). Ils ne contiennent donc pas la contribution du filtre. D'autre part, les valeurs réelles de position, de vitesse et d'à-coup - qui sont renvoyées par le MC_GroupReadActualPosition , MC_GroupReadActualVelocity , et MC_GroupReadActualAcceleration blocs fonctionnels – sont calculés sur la base de la position réelle des entraînements du groupe d’axes. Ils contiennent donc également la contribution du filtre. La dynamique du chemin qui est renvoyée par SMC_GroupReadPathDynamics avec Source = MC_SOURCE.SET est basé sur la trajectoire prévue ( q_ref ) et n'est donc pas influencé par le filtre. (Pour les autres valeurs du Source entrée, la contribution du filtre est incluse) Les déclencheurs font toujours référence à la trajectoire prévue ( q_ref ). L'heure qui est renvoyée par MC_GroupReadTrigger est le moment où la trajectoire prévue atteint le déclencheur. Lorsque le filtre est actif ( q_ref<>q_set ), le groupe d'axes n'atteint généralement pas exactement la position et\/ou l'heure du déclenchement. Remarque : Un mouvement signale Done seulement lorsque la trajectoire prévue ( q_ref ) a atteint la fin du mouvement et le filtre n'est pas (ou plus) actif (c'est-à-dire qu'un éventuel décalage a été éliminé). Puis la position réglée ( q_set ) correspond à la position cible du mouvement. " }, 
{ "title" : "Définition des tolérances et surveillance de l'écart de trajectoire ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4575205545955234033945121691", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Tolérances pour la précision du chemin \/ Définition des tolérances et surveillance de l'écart de trajectoire ", 
"snippet" : "Les tolérances peuvent être définies à l'aide du SMC_GroupSetPathTolerance bloc fonctionnel. L'état du filtre et le décalage actuel entre la trajectoire prévue q_ref et les valeurs définies q_set du groupe d'axes peut être surveillé avec le InSync , PositionLag , et OrientationLag sorties de MC_Grou...", 
"body" : "Les tolérances peuvent être définies à l'aide du SMC_GroupSetPathTolerance bloc fonctionnel. L'état du filtre et le décalage actuel entre la trajectoire prévue q_ref et les valeurs définies q_set du groupe d'axes peut être surveillé avec le InSync , PositionLag , et OrientationLag sorties de MC_GroupReadStatus . InSync = TRUE signifie que q_ref = q_set et que le filtre n'est pas actif. InSync = FALSE signifie que q_ref<>q_set et que le filtre est actif. " }, 
{ "title" : "Mise en mémoire tampon et fusion des mouvements ", 
"url" : "_sm_robotics_blending.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Mise en mémoire tampon et fusion des mouvements ", 
"snippet" : "Les commandes de mouvement peuvent être mises en mémoire tampon avec CODESYS SoftMotion . Pour chaque mouvement commandé, il est possible de spécifier comment le mouvement est mis en mémoire tampon et comment le mélange doit être effectué entre le mouvement précédent et le nouveau mouvement. La traj...", 
"body" : "Les commandes de mouvement peuvent être mises en mémoire tampon avec CODESYS SoftMotion . Pour chaque mouvement commandé, il est possible de spécifier comment le mouvement est mis en mémoire tampon et comment le mélange doit être effectué entre le mouvement précédent et le nouveau mouvement. La trajectoire commandée est ajustée en arrondissant les coins afin que la trajectoire puisse être parcourue sans arrêt La mise en mémoire tampon d'un mouvement et la manière dont il est effectué peuvent être configurées à l'aide du BufferMode entrée du bloc de mouvement (par exemple, MC_MoveDirectAbsolute ou MC_MoveCircularRelative ). Pour plus d'informations, consultez les rubriques suivantes : MC_Buffer_Mode . Le TransitionMode et TransitionParameter les entrées déterminent la façon dont les coins sont arrondis. Pour plus d'informations, consultez les rubriques suivantes : MC_TRANSITION_MODE . Pour plus d'informations sur les mouvements, consultez les rubriques suivantes : Blocs fonctionnels pour les mouvements Dans les modes de fusion, TransitionMode ne doit pas être égal à TMNone . Le mélange entre deux mouvements commence au plus tôt à la moitié du premier mouvement et se termine au plus tard à la moitié du deuxième mouvement. Si le premier mouvement a déjà été planifié trop loin, le mélange peut ne plus être possible avec les paramètres définis. La zone de fusion est alors réduite ou la fusion n'est plus possible. Afin de garantir un mélange réussi, les deux mouvements doivent être commandés dans le même cycle. " }, 
{ "title" : "Dynamique des trajectoires lors du mélange ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-idm43523137701146", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Mise en mémoire tampon et fusion des mouvements \/ Dynamique des trajectoires lors du mélange ", 
"snippet" : "Si le mélange est effectué entre des mouvements CP (entre des segments linéaires et circulaires), il convient de noter que l'accélération maximale de la trajectoire et la secousse de trajectoire maximale peuvent être dépassées pendant le mélange. Plus la plage de fusion est courte, plus cet effet se...", 
"body" : "Si le mélange est effectué entre des mouvements CP (entre des segments linéaires et circulaires), il convient de noter que l'accélération maximale de la trajectoire et la secousse de trajectoire maximale peuvent être dépassées pendant le mélange. Plus la plage de fusion est courte, plus cet effet sera important. Cependant, les limites des axes (accélération maximale de l'axe et secousse maximale de l'axe) sont toujours maintenues Par conséquent, si l'accélération maximale de la trajectoire est faible et que l'accélération maximale de l'axe est élevée, des accélérations trop élevées peuvent se produire lors du mélange. Cela peut être contrecarré au moyen du AccFactor la saisie des blocs de mouvement, par example, en réduisant l'accélération maximale de l'axe pour un mouvement. " }, 
{ "title" : "Caractéristiques de TMStartVelocity ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-id235231378653745", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Mise en mémoire tampon et fusion des mouvements \/ Caractéristiques de TMStartVelocity ", 
"snippet" : "Le calcul des points de mélange est basé sur une courbe de vitesse idéalisée, qui peut s'écarter de la courbe de vitesse réelle. À ce stade, une rampe de décélération est simulée sur la trajectoire initiale vers le point de mélange et une rampe d'accélération s'éloignant du point de mélange. Le mini...", 
"body" : "Le calcul des points de mélange est basé sur une courbe de vitesse idéalisée, qui peut s'écarter de la courbe de vitesse réelle. À ce stade, une rampe de décélération est simulée sur la trajectoire initiale vers le point de mélange et une rampe d'accélération s'éloignant du point de mélange. Le minimum de la vitesse de trajectoire programmée et de la vitesse de trajectoire maximale estimée résultant des limites de l'axe est utilisé comme vitesse cible. De plus, lors de la fusion entre des lignes droites, l'angle entre elles est pris en compte. Un rayon de courbure minimal pour l'élément de mélange résulte de la vitesse de trajectoire souhaitée et des limites dynamiques estimées. Les points A' et B' résultent à leur tour de ce rayon et de l'angle entre les droites Si les mouvements sont ralentis pendant le processus de mélange malgré un facteur défini de 1, il peut être utile d'augmenter le facteur. " }, 
{ "title" : "Exemple ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-id235231380207819", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Mise en mémoire tampon et fusion des mouvements \/ Exemple ", 
"snippet" : "Dans un petit exemple d'application, une pièce est censée être prélevée. Le robot doit d'abord se déplacer au-dessus de la pièce, puis vers le bas pour la ramasser. Pour atteindre la pièce le plus rapidement possible, le déplacement entre les deux mouvements ne doit pas être arrêté, mais mélangé. La...", 
"body" : "Dans un petit exemple d'application, une pièce est censée être prélevée. Le robot doit d'abord se déplacer au-dessus de la pièce, puis vers le bas pour la ramasser. Pour atteindre la pièce le plus rapidement possible, le déplacement entre les deux mouvements ne doit pas être arrêté, mais mélangé. La fusion avec le second mouvement devrait commencer dix unités avant la fin du premier mouvement. Pour répondre aux exigences, deux mouvements doivent être commandés. Le premier mouvement ( moveAbove ) sur la pièce et le second mouvement ( moveDown ) vers le bas en direction de la pièce. Pour le second mouvement, il faut définir comment le mouvement doit être tamponné et mélangé Comme le montre l'image suivante, BlendingHigh est sélectionné pour BufferMode . Cela définit que le mouvement doit être mis en mémoire tampon après le premier mouvement, puis mélangé. En outre, pour TransitionMode , TMCornerDistance est défini avec une distance de 10 unités pour intégrer en douceur le premier mouvement au second. Afin de régler les deux entrées TransitionMode et TransitionParameter de manière appropriée, le SMC_CornerDistance un bloc fonctionnel est utilisé. " }, 
{ "title" : "Attendre entre les mouvements ", 
"url" : "_sm_robotics_wait.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Attendre entre les mouvements ", 
"snippet" : "SoftMotion Robotics offre la possibilité d'attendre un temps précis entre deux mouvements. Cela peut être nécessaire, par exemple, lorsqu'un robot est censé saisir une pièce à usiner à la position cible d'un mouvement avant de commencer le mouvement suivant. Comme pour les mouvements, le temps d'att...", 
"body" : "SoftMotion Robotics offre la possibilité d'attendre un temps précis entre deux mouvements. Cela peut être nécessaire, par exemple, lorsqu'un robot est censé saisir une pièce à usiner à la position cible d'un mouvement avant de commencer le mouvement suivant. Comme pour les mouvements, le temps d'attente est commandé via le SMC_GroupWait bloc fonctionnel. Pour plus d'informations sur ce bloc fonctionnel, voir : SMC_GroupWait . " }, 
{ "title" : "Arrêt sur le chemin avec MC_GroupHalt ou MC_GroupStop ", 
"url" : "_sm_robotics_halt_stop.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Arrêt sur le chemin avec MC_GroupHalt ou MC_GroupStop ", 
"snippet" : "Le MC_GroupHalt et MC_GroupStop les blocs fonctionnels permettent l'arrêt sur la trajectoire, en tenant compte des limites configurables de décélération et d'à-coup. L'arrêt commence immédiatement. Les limites de décélération et d'à-coup pour l'arrêt peuvent différer de celles du mouvement actif et ...", 
"body" : "Le MC_GroupHalt et MC_GroupStop les blocs fonctionnels permettent l'arrêt sur la trajectoire, en tenant compte des limites configurables de décélération et d'à-coup. L'arrêt commence immédiatement. Les limites de décélération et d'à-coup pour l'arrêt peuvent différer de celles du mouvement actif et peuvent être aussi bien plus grandes que plus petites. Ils sont entretenus tant que le chemin n'est pas quitté. Au milieu de la trajectoire, par exemple, un arrêt en douceur avec une faible décélération est possible. Cependant, à la fin du trajet, la décélération est au moins suffisamment forte pour empêcher tout déplacement au-delà de la fin. Différence entre MC_GroupHalt et MC_GroupStop La principale différence entre MC_GroupHalt et MC_GroupStop est-ce un MC_GroupStop ne peut pas être interrompu et que les mouvements ultérieurs ne sont acceptés qu'après le Execute l’entrée a été réinitialisée. Un MC_GroupStop empêche le groupe d'axes de bouger. Différenciation de MC_GroupInterrupt Contrairement à MC_GroupHalt et MC_GroupStop , un MC_GroupInterrupt démarre avec un court délai et n'a pas de limites de décélération et d'à-coups configurables. Au lieu de cela, les limites du mouvement actif sont utilisées. Après un MC_GroupInterrupt , le mouvement interrompu peut être repris avec MC_GroupContinue . Avec l'aide de SMC_GroupSaveContinueData , c'est aussi possible avec MC_GroupHalt et MC_GroupStop . Pour plus d'informations, voir : Interruption et poursuite des mouvements. Comportement avec les mouvements dans des systèmes de coordonnées en mouvement Pour les mouvements dans déplacement de systèmes de coordonnées (par exemple, lorsque le robot se déplace par rapport à un tapis roulant), un MC_GroupHalt ou MC_GroupStop entraîne un arrêt absolu. Par conséquent, il n’est pas arrêté par rapport au système de coordonnées en mouvement. Le groupe d'axes reste sur la trajectoire qu'il aurait parcourue dans le système de coordonnées machine (MCS) si aucun MC_GroupHalt ou MC_GroupStop avait été commandé. " }, 
{ "title" : "Planification des mouvements ", 
"url" : "_sm_robotics_factor_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Planification des mouvements ", 
"snippet" : "Lorsqu'un mouvement est commandé, par exemple avec MC_MoveLinearAbsolute , la vitesse résultante du robot dépend des facteurs suivants : La vitesse, l'accélération et l'à-coup maximum configurés pour chaque axe du groupe d'axes. (configuré dans la configuration des axes). Les limites supérieures déf...", 
"body" : "Lorsqu'un mouvement est commandé, par exemple avec MC_MoveLinearAbsolute , la vitesse résultante du robot dépend des facteurs suivants : La vitesse, l'accélération et l'à-coup maximum configurés pour chaque axe du groupe d'axes. (configuré dans la configuration des axes). Les limites supérieures définissent pour chaque axe la vitesse à laquelle il est autorisé à se déplacer. Les autres limites expliquées ci-dessous ne peuvent que réduire les limites effectives. Ils ne peuvent pas les augmenter au-delà de ces limites. La vitesse, l'accélération et l'à-coup maximum qui sont fournis en tant qu'entrées au bloc fonction de mouvement. Ces limites supérieures définissent la vitesse à laquelle le TCP peut se déplacer le long du chemin. Elles s'appliquent en plus des limites des différents axes. Le remplacement actuel (voir MC_GroupSetOverride ) et les limites annexes pour un groupe d'axes Pour une description de la manière dont toutes ces limites sont combinées pour calculer les limites effectives de trajectoire et d'axe, consultez l'aide de SMC_GroupSetAncillaryAxisLimits , SMC_GroupSetAncillaryPathLimits , et SMC_GroupSetAxisLimitFactors . Le chemin programmé du robot Par exemple, lorsque la fusion des mouvements entraîne un très petit rayon de courbure, le robot doit se déplacer lentement afin de ne pas dépasser les limites de l'axe. Ensemble, ces facteurs déterminent la vitesse maximale effective sur la trajectoire. Cependant, il existe un autre facteur qui peut limiter la vitesse réalisable : les performances de l'automate. Si les performances ne sont pas suffisantes pour planifier le mouvement, le robot se déplace à une vitesse plus lente. Si, pour des raisons de performances, l'algorithme de planification ne peut pas vérifier qu'il est possible d'accélérer en toute sécurité, il se déplacera alors à une vitesse plus lente. Pour plus d'informations, voir : Performance" }, 
{ "title" : "Interruption et poursuite des mouvements ", 
"url" : "_sm_robotics_stop_continue_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Interruption et poursuite des mouvements ", 
"snippet" : "Lorsqu'un groupe d'axes est en mouvement, le mouvement peut être arrêté. Cela peut être un arrêt intentionnel ( MC_GroupHalt , MC_GroupStop ), ou une pause sur le chemin ( MC_GroupInterrupt ), ou un arrêt dû à une erreur. Dans tous les cas, CODESYS SoftMotion fournit des blocs fonctionnels pour rame...", 
"body" : "Lorsqu'un groupe d'axes est en mouvement, le mouvement peut être arrêté. Cela peut être un arrêt intentionnel ( MC_GroupHalt , MC_GroupStop ), ou une pause sur le chemin ( MC_GroupInterrupt ), ou un arrêt dû à une erreur. Dans tous les cas, CODESYS SoftMotion fournit des blocs fonctionnels pour ramener le groupe d'axes à la trajectoire planifiée et la poursuivre. Arrêt d'un mouvement suite à une erreur Si un mouvement est arrêté en raison d'une erreur, les différents axes d'un groupe d'axes sont arrêtés individuellement et commutés en état d'erreur. Dans le processus, le TCP quitte le chemin prévu. Vous pouvez maintenant acquitter l'erreur, réinitialiser le groupe d'axes et vous déplacer jusqu'à la position où l'erreur a été détectée. Ensuite, vous pouvez demander au groupe d'axes de continuer les mouvements précédemment planifiés. Vous utilisez le SMC_GroupEnableResumeAfterError bloc fonction pour permettre à la fonction de reprendre les mouvements programmés après une erreur. Le bloc fonction doit être appelé cycliquement dans la tâche de cycle de bus. Une seule instance de ce bloc fonction peut être appelée par groupe d'axes. Si le groupe d'axes détecte une erreur et passe à l'état Errorstop , puis il enregistre les mouvements déjà acceptés et les informations d'état nécessaires dans une variable de type SMC_AXIS_GROUP_CONTINUE_DATA . Ensuite, cette variable contient les \"données continues\" et est passée en entrée de SMC_GroupEnableResumeAfterError . Cela vous permet de reprendre les mouvements plus tard en utilisant MC_GroupContinue . Si les erreurs sont causées par les mouvements commandés (par exemple, des violations de l'espace de travail ou un rayon d'arc invalide), elles ne peuvent pas être résolues de cette manière. Ces erreurs se reproduiront après la poursuite du mouvement. Le mécanisme est davantage destiné aux erreurs d'axe unique et à d'autres événements externes qui forcent le groupe d'axes à l'arrêt d'erreur. MC_GroupContinue nécessite que le groupe d'axes soit à une position spécifique lors de la poursuite du mouvement. En cas de reprise après une erreur, cette position est la position actuelle au moment où l'erreur a été détectée. Vous pouvez utiliser le SMC_GroupGetContinuePosition bloc fonction pour obtenir cette position. Si une erreur de groupe d'axes ne permet pas la poursuite du mouvement (comme une erreur interne lors de l'écriture des données de poursuite), alors MC_GroupContinue et SMC_GroupGetContinuePosition renvoyer le nouvel identifiant d'erreur SMC_AXIS_GROUP_CONTINUE_DATA_NOT_WRITTEN . Si un MC_GroupStop est actif lorsque l'erreur se produit, alors MC_GroupStop est également réactivé lorsque le mouvement se poursuit. Le groupe d'axes a déjà été arrêté et le MC_GroupStop a supprimé tous les mouvements en attente afin qu'aucun mouvement ne se produise. Lorsqu'une erreur de groupe d'axes se produit, l'instance de bloc fonction du mouvement actif émet l'erreur (sorties Active et Busy basculer vers FALSE , et sortie Error passe à TRUE ). Les instances de blocs fonctionnels de mouvements tamponnés ou mélangés, qui ne sont pas encore actives, génèrent également une erreur. Après le redémarrage, toutes ces instances de blocs fonctionnels sont réinitialisées à Busy \/ Active et leurs sorties remises à Error \/ CommandAborted . " }, 
{ "title" : "Arrêter un mouvement en faisant une pause ", 
"url" : "_sm_robotics_stop_continue_movements.html#UUID-5b8e7899-940c-fb66-b17a-ee1b74aa00fd_id_d17b9abed7a5b50cc0a864636890315c_id_74b10b31cbbdb856c0a8646354735c5f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Interruption et poursuite des mouvements \/ Arrêter un mouvement en faisant une pause ", 
"snippet" : "Vous pouvez utiliser le MC_GroupInterrupt et MC_GroupInterruptAt blocs fonctions pour interrompre l'exécution des mouvements commandés. Pour MC_GroupInterrupt , un arrêt immédiat est exécuté. Pour MC_GroupInterruptAt , un arrêt est exécuté à une position spécifique. Ensuite, le mouvement peut être p...", 
"body" : "Vous pouvez utiliser le MC_GroupInterrupt et MC_GroupInterruptAt blocs fonctions pour interrompre l'exécution des mouvements commandés. Pour MC_GroupInterrupt , un arrêt immédiat est exécuté. Pour MC_GroupInterruptAt , un arrêt est exécuté à une position spécifique. Ensuite, le mouvement peut être poursuivi plus tard avec MC_GroupContinue . Le bloc fonction MC_GroupInterruptAt fournit l'entrée SMC_GroupInterruptPositionMvtRel . Ceci spécifie une position d'interruption par rapport à un mouvement. Le mouvement est référencé par son SMC_Movement_Id . La position dans le mouvement est définie par une valeur (réelle) comprise entre 0 et 1, où 0 est le début du mouvement et 1 est la fin. Une position entre les points B et A est interprétée exactement comme s'il n'y avait pas de fusion. Une position entre P début et B ou entre A et P destin est projeté sur le chemin de fusion. Gestion des erreurs pour MC_GroupInterruptAt Lorsque l'ID de mouvement spécifié est inconnu, le bloc fonction renvoie une erreur. Le mouvement de course n'est pas interrompu. Si l'état dynamique actuel du groupe d'axes ne permet pas d'atteindre l'arrêt avant la position d'interruption spécifiée, alors SMC_GroupInterruptAt se comporte exactement comme MC_GroupInterrupt : l'interruption est exécutée immédiatement et le groupe d'axes s'arrête quelque part derrière la position d'interruption commandée. Toutes les autres erreurs sont traitées exactement comme pour MC_GroupInterrupt . Limites de MC_GroupInterruptAt Une interruption à une position spécifique peut être interrompue avec un autre mouvement tant que le processus d'arrêt à la position d'interruption n'a pas encore commencé. Une seule interruption peut être commandée à une position spécifique à la fois. Si une interruption a été commandée, elle doit être terminée ou abandonnée pour qu'une autre interruption puisse être acceptée. Lorsque vous exécutez MC_GroupInterrupt ou MC_GroupInterruptAt , un arrêt invariant de chemin est exécuté dans un premier temps, semblable à un MC_GroupHalt . Ensuite, l'état du groupe d'axes (\"continue data\") est stocké dans une variable transmise par l'utilisateur (type SMC_AXIS_GROUP_CONTINUE_DATA ). Maintenant, le groupe d'axes est dans l'état GroupStandby et peut être utilisé normalement. Un exemple typique serait que le groupe d'axes est décalé. Plus tard, vous pouvez utiliser MC_GroupContinue pour continuer l'exécution interrompue. Pour ce faire, transférez les \"données continues\" enregistrées. Pour que cela fonctionne sans erreur, la position du groupe d'axes doit correspondre à la position qu'il avait après l'exécution de MC_GroupInterrupt . (Voir SMC_GroupGetContinuePosition .) Lorsqu'un mouvement de poursuite a été interrompu (c'est-à-dire un mouvement qui a été commandé par rapport à un repère dynamique), MC_GroupInterrupt ne s'arrête pas absolument (comme MC_GroupHalt ), mais relativement au repère dynamique. Par exemple, si une pièce est suivie sur une table rotative, MC_GroupInterrupt s'arrête par rapport à la pièce. Le groupe d'axes continue à suivre la pièce. Les données continues doivent être mises à jour avec SMC_GroupUpdateContinueData si la cinématique a des axes rotatifs à périodes multiples. Ensuite, le mouvement peut être poursuivi avec MC_GroupContinue . La variable de type SMC_AXIS_GROUP_CONTINUE_DATA ne doivent pas être stockés de manière persistante ou modifiés lors d'un changement en ligne. Utilisation du bloc fonction SMC_GroupWait , vous pouvez attendre sur le chemin entre deux mouvements pendant un temps programmable. " }, 
{ "title" : "Arrêt du mouvement via MC_GroupHalt ou MC_GroupStop ", 
"url" : "_sm_robotics_stop_continue_movements.html#UUID-5b8e7899-940c-fb66-b17a-ee1b74aa00fd_id_d17b9abed7a5b50cc0a864636890315c_id_28e8e9a71ed1fa93c0a8646375852228", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Interruption et poursuite des mouvements \/ Arrêt du mouvement via MC_GroupHalt ou MC_GroupStop ", 
"snippet" : "Après un arrêt du mouvement déclenché par MC_GroupHalt ou MC_GroupStop , le mouvement du groupe d'axes peut être poursuivi en utilisant SMC_GroupSaveContinueData et MC_GroupContinue sans aucune perte d'information. Cette POU enregistre l'état actuel, la position actuelle et tous les mouvements comma...", 
"body" : "Après un arrêt du mouvement déclenché par MC_GroupHalt ou MC_GroupStop , le mouvement du groupe d'axes peut être poursuivi en utilisant SMC_GroupSaveContinueData et MC_GroupContinue sans aucune perte d'information. Cette POU enregistre l'état actuel, la position actuelle et tous les mouvements commandés. En conséquence, le mouvement peut être poursuivi plus tard exactement à partir de cette position. Comportement avant la version 4.12.0.0 : Le SMC_GroupSaveContinueData le bloc fonction doit être appelé dans le même cycle où MC_GroupHalt ou MC_GroupStop est appelé. A ce moment, vous devez vous assurer que SMC_GroupSaveContinueData est appelé avant MC_GroupHalt ou MC_GroupStop . Sinon, les mouvements abandonnés seront supprimés de la file d'attente. Comportement à partir de la version 4.12.0.0 : Le SMC_GroupSaveContinueData le bloc fonctionnel peut être appelé à tout moment jusqu'au premier mouvement après l'appel MC_GroupHalt ou MC_GroupStop . La position de continuation est la position actuelle du groupe d'axes au moment du premier appel du bloc fonction. Le chemin enregistré se compose de tous les mouvements qui ont été acceptés avant la commande d'arrêt\/d'arrêt. Pour pouvoir continuer la trajectoire à l'endroit où le groupe d'axes s'est arrêté en raison de MC_GroupHalt ou MC_GroupStop , SMC_GroupSaveContinueData doit être appelé dans le cycle où MC_GroupHalt ou MC_GroupStop fixe le Done signal. Une seule instance de SMC_GroupSaveContinueData peut être appelé par groupe d'axes. L'enregistrement de l'état actuel avant la commande d'arrêt\/arrêt peut prendre plusieurs cycles, mais il est garanti que les informations d'état du premier cycle seront enregistrées avant tout mouvement interrompu. SMC_GroupSaveContinueData peut être appelé à tout moment pour enregistrer l'état actuel, non seulement en relation avec l'appel MC_GroupHalt ou MC_GroupStop . " }, 
{ "title" : "Interaction avec les mouvements à axe unique ", 
"url" : "_sm_additional_axes_single_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Interaction avec les mouvements à axe unique ", 
"snippet" : "Chaque axe d'un groupe d'axes (y compris les axes supplémentaires) peut également être déplacé avec des mouvements à axe unique. Cela ne nécessite pas de supprimer l'axe du groupe d'axes. Les règles suivantes sont utilisées : Si le groupe d'axes se trouve dans GroupStandby état lorsqu'un mouvement à...", 
"body" : "Chaque axe d'un groupe d'axes (y compris les axes supplémentaires) peut également être déplacé avec des mouvements à axe unique. Cela ne nécessite pas de supprimer l'axe du groupe d'axes. Les règles suivantes sont utilisées : Si le groupe d'axes se trouve dans GroupStandby état lorsqu'un mouvement à axe unique est commandé sur l'un de ses axes, le groupe d'axes reste dans cet état. Pour plus d'informations, consultez les rubriques suivantes : États du groupe d'axesSi le groupe d'axes se trouve dans GroupMoving état lorsqu'un mouvement à axe unique est commandé sur l'un de ses axes, puis le groupe d'axes passe au GroupError état. L'erreur SMC_AXIS_GROUP_INTERRUPTED_BY_SINGLE_AXIS est signalé et tous les autres axes sont arrêtés. Si un mouvement est commandé sur le groupe d'axes alors qu'un mouvement à axe unique est actif sur au moins l'un de ses axes, alors le groupe d'axes entre dans GroupError état. " }, 
{ "title" : "Synchronisation avec un système de coordonnées en mouvement ", 
"url" : "_sm_robotics_dynamic_tracking.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Synchronisation avec un système de coordonnées en mouvement ", 
"snippet" : "La fonction de suivi intégrée permet de programmer des mouvements par rapport à un système de coordonnées en mouvement. Un cas d'utilisation typique consiste à prélever un produit sur un tapis roulant et à le placer sur un autre tapis roulant. Après avoir défini un système de coordonnées dynamiques ...", 
"body" : "La fonction de suivi intégrée permet de programmer des mouvements par rapport à un système de coordonnées en mouvement. Un cas d'utilisation typique consiste à prélever un produit sur un tapis roulant et à le placer sur un autre tapis roulant. Après avoir défini un système de coordonnées dynamiques pour chaque courroie, l'utilisateur peut simplement fournir des positions cibles pour les mouvements qui sont relatifs à ces systèmes de coordonnées. CODESYS SoftMotion se charge de superposer le mouvement commandé du groupe d'axes et le mouvement de la courroie. Un mouvement de suivi typique se compose de trois phases : Tracking in : passage d'un autre système de coordonnées au système de coordonnées dynamique. Une fois la position cible atteinte, le groupe d'axes suivra le mouvement du système de coordonnées dynamique. Mouvement de suivi : déplacement vers une position différente à l'intérieur du même système de coordonnées dynamiques. Le mouvement commandé et le mouvement du repère dynamique seront superposés. Tracking out : passage du système de coordonnées dynamique à un système de coordonnées différent. Une fois la position cible atteinte, le mouvement du groupe d'axes n'est plus influencé par le mouvement du système de coordonnées dynamique. " }, 
{ "title" : "Définition d'un système de coordonnées dynamique ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4599737357387233382157942652", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Synchronisation avec un système de coordonnées en mouvement \/ Définition d'un système de coordonnées dynamique ", 
"snippet" : "La première étape de la mise en œuvre d'une application de suivi dynamique consiste à définir un système de coordonnées dynamique. CODESYS SoftMotion fournit quatre blocs fonctionnels pour définir des systèmes de coordonnées dynamiques : MC_TrackConveyorBelt : Un bloc fonction facile à utiliser pour...", 
"body" : "La première étape de la mise en œuvre d'une application de suivi dynamique consiste à définir un système de coordonnées dynamique. CODESYS SoftMotion fournit quatre blocs fonctionnels pour définir des systèmes de coordonnées dynamiques : MC_TrackConveyorBelt : Un bloc fonction facile à utiliser pour le cas d'utilisation courant du suivi d'une bande transporteuse. Une référence à la courroie réelle est fournie via le ConveyorBelt entrée, qui attend un axe SoftMotion de type AXIS_REF_SM3 . MC_TrackRotaryTable : Un bloc fonction facile à utiliser pour le cas d'utilisation courant du suivi d'une table rotative. Une référence à la table rotative réelle est fournie via le RotaryTable entrée, qui attend un axe SoftMotion de type AXIS_REF_SM3 . MC_SetDynCoordTransform : Le bloc fonction fonctionne comme MC_TrackConveyorBelt et MC_TrackRotaryTable , mais, au lieu d'être contrôlé par un seul axe, est contrôlé par un groupe d'axes complet. Cela permet de mettre en œuvre un système de coordonnées dynamique avec jusqu'à six degrés de liberté. SMC_SetDynCoordTransformEx : Le bloc fonction permet d'implémenter un système de coordonnées dynamiques entièrement personnalisé. Chacun des quatre blocs fonctionnels possède un CoordSystem entrée qui permet essentiellement de donner un nom au système de coordonnées, soit PCS_1 ou PCS_2 . Lors de la commande d'un mouvement, le système de coordonnées est référencé par ce nom. " }, 
{ "title" : "Commander un mouvement vers une position dans un système de coordonnées dynamique ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4620464078688033382158385681", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Synchronisation avec un système de coordonnées en mouvement \/ Commander un mouvement vers une position dans un système de coordonnées dynamique ", 
"snippet" : "Après avoir défini un repère dynamique, commander un déplacement vers une position dans ce repère est facile. Chaque bloc fonctionnel de mouvement, par exemple MC_MoveLinearAbsolute , a un CoordSystem saisir. Cette entrée doit être réglée sur le nom ( PCS_1 ou PCS_2 ) donné au système de coordonnées...", 
"body" : "Après avoir défini un repère dynamique, commander un déplacement vers une position dans ce repère est facile. Chaque bloc fonctionnel de mouvement, par exemple MC_MoveLinearAbsolute , a un CoordSystem saisir. Cette entrée doit être réglée sur le nom ( PCS_1 ou PCS_2 ) donné au système de coordonnées dynamique. La Position l'entrée peut alors être réglée sur la position souhaitée par rapport à l'origine du système de coordonnées dynamiques. L'exécution du bloc fonctionnel de déplacement entraînera un déplacement vers la position à l'intérieur du système de coordonnées de déplacement. Une fois la position cible atteinte, le groupe d'axes suivra le repère dynamique tout en restant à cette position relative. " }, 
{ "title" : "La sortie \"InUse\" des blocs fonctionnels du système de coordonnées dynamique ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4663886345662433382158689616", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Synchronisation avec un système de coordonnées en mouvement \/ La sortie \"InUse\" des blocs fonctionnels du système de coordonnées dynamique ", 
"snippet" : "Chaque bloc fonctionnel de système de coordonnées dynamique ( MC_TrackConveyorBelt , MC_TrackRotaryTable , MC_SetDynCoordTransform , et SMC_SetDynCoordTransformEx ) a un InUse production. Le redémarrage d'un bloc fonction alors que le système de coordonnées est encore utilisé n'est pas autorisé et e...", 
"body" : "Chaque bloc fonctionnel de système de coordonnées dynamique ( MC_TrackConveyorBelt , MC_TrackRotaryTable , MC_SetDynCoordTransform , et SMC_SetDynCoordTransformEx ) a un InUse production. Le redémarrage d'un bloc fonction alors que le système de coordonnées est encore utilisé n'est pas autorisé et entraînera l'erreur SMC_AXIS_GROUP_PCS_STILL_IN_USE . Un système de coordonnées dynamique sera utilisé dès qu'un mouvement vers une position dans le système de coordonnées sera commandé. Il restera utilisé jusqu'à ce qu'une position cible dans un système de coordonnées différent soit atteinte. " }, 
{ "title" : "Limites d'axe pour le suivi des mouvements ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4557758355867233382158929251", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Synchronisation avec un système de coordonnées en mouvement \/ Limites d'axe pour le suivi des mouvements ", 
"snippet" : "Les limites d'axe doivent tenir compte à la fois du mouvement du système de coordonnées et du mouvement commandé par rapport au système de coordonnées. Si une dynamique d'axe élevée est nécessaire pour suivre le système de coordonnées, le mouvement par rapport au système de coordonnées peut être len...", 
"body" : "Les limites d'axe doivent tenir compte à la fois du mouvement du système de coordonnées et du mouvement commandé par rapport au système de coordonnées. Si une dynamique d'axe élevée est nécessaire pour suivre le système de coordonnées, le mouvement par rapport au système de coordonnées peut être lent ou impossible du tout. Si le groupe d'axes est proche d'une singularité de la cinématique, cela peut même se produire avec un système de coordonnées à déplacement relativement lent. Pour plus d'informations, consultez : Onglet : Général" }, 
{ "title" : "Dynamique de trajectoire des mouvements CP pendant le suivi ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm466388653271043338215917861", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Synchronisation avec un système de coordonnées en mouvement \/ Dynamique de trajectoire des mouvements CP pendant le suivi ", 
"snippet" : "Une attention particulière doit être accordée à la dynamique des trajectoires des mouvements de CP. Cela inclut le Velocity , Acceleration , Deceleration , et Jerk entrées de MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute , et MC_MoveCircularRelative . Si les positions de dé...", 
"body" : "Une attention particulière doit être accordée à la dynamique des trajectoires des mouvements de CP. Cela inclut le Velocity , Acceleration , Deceleration , et Jerk entrées de MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute , et MC_MoveCircularRelative . Si les positions de départ et cible sont dans le même système de coordonnées dynamiques, la dynamique du chemin sera relative à ce système de coordonnées. Cependant, si les positions de début et de fin se trouvent dans des systèmes de coordonnées différents, la dynamique du trajet est fusionnée de la dynamique relative au premier système de coordonnées à la dynamique relative au second système de coordonnées. Il est important que la dynamique du trajet soit supérieure à la valeur absolue de la différence de dynamique entre les deux systèmes de coordonnées. En particulier, lors du passage d'un système de coordonnées statique à un système de coordonnées dynamique, la dynamique du chemin doit être définie à un niveau supérieur à la valeur absolue de la dynamique du système de coordonnées. La vitesse de trajectoire ne peut pas être surveillée avec SMC_GroupReadPathDynamics lors du déplacement entre les systèmes de coordonnées (suivi entrant, sortant ou entre différents systèmes de coordonnées dynamiques). SMC_GroupReadPathDynamics calcule la dynamique du chemin par rapport à un système de coordonnées spécifié. Dans le cas d'un suivi d'entrée ou de sortie ou d'un déplacement entre des systèmes de coordonnées dynamiques, il s'agit d'un mouvement qui dépend de deux systèmes de coordonnées (les systèmes de coordonnées de départ et de destination diffèrent). En conséquence, le SMC_GroupReadPathDynamics bloc fonctionnel ne convient pas pour calculer la dynamique du chemin dans ces cas. " }, 
{ "title" : "Évitez les erreurs SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED, SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED ou SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED. ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4558812953211233382159412375", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Synchronisation avec un système de coordonnées en mouvement \/ Évitez les erreurs SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED, SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED ou SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED. ", 
"snippet" : "Les erreurs SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED , SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED , ou SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED sont signalés s'il n'est pas possible de suivre la trajectoire commandée sans violer les limites d'axe configurées ou la dynamique de la trajectoire. Si cette ...", 
"body" : "Les erreurs SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED , SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED , ou SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED sont signalés s'il n'est pas possible de suivre la trajectoire commandée sans violer les limites d'axe configurées ou la dynamique de la trajectoire. Si cette erreur se produit, il convient d'abord de vérifier si les limites de l'axe et la dynamique de trajectoire sont configurées conformément aux deux sections précédentes. L'écart de trajectoire peut être surveillé avec les sorties PositionLag et OrientationLag de la MC_GroupReadStatus bloc fonctionnel. Les solutions possibles sont les suivantes : Augmentez les limites de l'axe. Augmentez la dynamique de trajectoire des mouvements CP lors du suivi dans un système de coordonnées dynamique. Réduire la dynamique du système de coordonnées. Eviter les mouvements proches d'une singularité de la cinématique, par exemple en repositionnant le robot. Si le système de coordonnées dynamiques est contrôlé par la sortie d'un encodeur bruyant, il peut être utile de filtrer le signal de l'encodeur à l'aide d'un axe logique. Pour plus d'informations, voir  Axes logiques. Une tolérance acceptable pour la position et le décalage d'orientation peut être configurée à l'aide du SMC_GroupSetPathTolerance bloc fonctionnel. " }, 
{ "title" : "Axes rotatifs avec plage de valeurs supérieure à 360° ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Axes rotatifs avec plage de valeurs supérieure à 360° ", 
"snippet" : "Comportement en cas de mouvements de CP Lors d'un mouvement de CP ( MC_MoveLinearAbsolute \/ MC_MoveLinearRelative , MC_MoveCircularAbsolute \/ MC_MoveCircularRelative ), les axes rotatifs sont toujours entraînés en mode automatique (Période 0). La période de l'axe est toujours sélectionnée de manière...", 
"body" : "Comportement en cas de mouvements de CP Lors d'un mouvement de CP ( MC_MoveLinearAbsolute \/ MC_MoveLinearRelative , MC_MoveCircularAbsolute \/ MC_MoveCircularRelative ), les axes rotatifs sont toujours entraînés en mode automatique (Période 0). La période de l'axe est toujours sélectionnée de manière à ce qu'il n'y ait pas de saut dans l'axe. Il est possible qu'à la fin du mouvement du CP, la valeur de l'axe commandé ne soit pas atteinte, mais que l'axe arrive dans une période différente du fait de la sélection automatique de la période. Cela signifie que la position commandée ne peut pas être atteinte avec le type de mouvement sélectionné. Ce conflit est détecté avant d'atteindre la position cible, le groupe d'axes est arrêté et une erreur est émise. Exemple : Vous utilisez un robot SCARA avec trois axes rotatifs A1, A2 et A3. A3 a une plage de valeurs de -360° à +360°. Vous apprenez deux positions en coordonnées d'axe. Position1 = (A1 = 0°, A2 = 90°, A3 = 170°), Position2 = (A1 = 10°, A2 = 90°, A3 = -170°). Ensuite vous commandez un mouvement linéaire ( MC_MoveLinear\/MC_MoveAbsolute) ) avec le mode d'orientation GreatCircle . Cette combinaison de commande en ACS et d'interpolation d'orientation grand cercle crée un conflit. Pour suivre l'interpolation d'orientation, il faudrait que l'axe A3 se déplace de 170° dans le sens positif à 190°. Il ne peut donc pas atteindre la position cible requise (-170°). Remarque : Dans le cas des mouvements CP, la période de l'axe rotatif est déterminée par le type d'interpolation sélectionné. Cela signifie également que la position cible de l'axe dépend de la trajectoire par laquelle le point cible est approché. Il est donc possible par exemple qu'en mélangeant deux mouvements un axe arrive dans une période différente de ce qui aurait été le cas avec des mouvements tamponnés. Pour plus d'informations, consultez : Interpolation d'orientation pour les mouvements de CP" }, 
{ "title" : "introduction ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html#UUID-12fb3c35-3bac-219e-b53a-31166417b16d_id_da342072b79533ffc0a864635077a64a_id_48a1e2bdb79a4093c0a864631bc39e2b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Axes rotatifs avec plage de valeurs supérieure à 360° \/ introduction ", 
"snippet" : "Les robots ont souvent des axes rotatifs avec une plage de valeurs supérieure à 360°. Par exemple, le dernier axe (axe d'orientation A3) d'un robot SCARA peut souvent effectuer plus d'une rotation, d'environ -540° à 540°. Cela signifie que la même position et la même orientation peuvent être approch...", 
"body" : "Les robots ont souvent des axes rotatifs avec une plage de valeurs supérieure à 360°. Par exemple, le dernier axe (axe d'orientation A3) d'un robot SCARA peut souvent effectuer plus d'une rotation, d'environ -540° à 540°. Cela signifie que la même position et la même orientation peuvent être approchées de plusieurs manières. En considérant SCARA par exemple, l'orientation et la position de l'outil sont identiques, que le dernier axe soit à -170° ou à 190° (= -170° + 360°). En conséquence, la conversion de la position et de l'orientation cartésiennes en valeurs d'axe (la transformation cinématique inverse) n'est pas unique, mais a plusieurs solutions. Cela peut être utilisé par exemple dans les applications Pick&Place pour gagner du temps en passant de 170° à 190° et non à -170°. Remarque : Le mouvement de l'axe d'orientation SCARA peut rapidement devenir un facteur limitant du temps de cycle dans ces applications. " }, 
{ "title" : "Résolution d'ambiguïté ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html#UUID-12fb3c35-3bac-219e-b53a-31166417b16d_id_da342072b79533ffc0a864635077a64a_id_e9620f70b79a4093c0a86463477a7031", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Axes rotatifs avec plage de valeurs supérieure à 360° \/ Résolution d'ambiguïté ", 
"snippet" : "Si les points à parcourir sont commandés dans le système de coordonnées d'axe (ACS), alors il est clair pour chaque axe quelle valeur il prendra dans le point cible. Par contre, en commande cartésienne (position X\/Y\/Z et orientation en A\/B\/C) cette ambiguïté existe pour les axes rotatifs. La configu...", 
"body" : "Si les points à parcourir sont commandés dans le système de coordonnées d'axe (ACS), alors il est clair pour chaque axe quelle valeur il prendra dans le point cible. Par contre, en commande cartésienne (position X\/Y\/Z et orientation en A\/B\/C) cette ambiguïté existe pour les axes rotatifs. La configuration de la cinématique est utilisée pour lever cette ambiguïté. Avec les robots SCARA, la configuration inclut déjà le réglage si le SCARA doit s'approcher d'un point avec ElbowRight ou ElbowLeft . De plus, la configuration SCARA comprend également le réglage nPeriodA3 , qui peut être utilisé pour déterminer comment l'ambiguïté de l'axe A3 doit être levée. A cet effet, toute la plage de valeurs est divisée en périodes d'une longueur maximale de 360° : Période -1 de -540° à -180° Période 1 de -180° à 180° Période 2 de 180° à 540° (Pour une plus grande plage de valeurs de l'axe, il y a en conséquence plus de périodes possibles.) Il y a aussi une valeur spéciale. Si nPeriodA3 := 0 est défini, alors une résolution automatique d'ambiguïté est activée. Pour les mouvements PTP, cela signifie que la période est sélectionnée de manière à ce que la distance entre les positions de départ et de destination pour l'axe 4 soit aussi petite que possible. (Le comportement avec les mouvements CP est décrit ci-dessous.) Il est donc possible de contrôler la résolution de l'ambiguïté d'un axe rotatif en réglant la configuration cinématique en conséquence (voir SMC_SetKinConfiguration ). Les cinématiques qui prennent en charge cette fonctionnalité implémentent l'interface SMKinematicWithConfigurations3 . Le SMC_GroupReadSetPosition , MC_GroupReadActualPosition , et SMC_GroupTargetPosition les blocs fonctionnels sortent toujours la configuration avec la résolution automatique des périodes activée. La configuration actuelle avec des périodes explicitement définies peut être lue en lisant la position dans l'ACS et en la convertissant ensuite dans le MCS au moyen de SMC_GroupConvertPosition . La configuration renvoyée a défini explicitement des périodes. Pour plus d'informations, consultez : Configurations cinématiques" }, 
{ "title" : "Synchronisation des axes externes, contrôle de l'avance du couple ", 
"url" : "_sm_robotics_external_axis_torque_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Synchronisation des axes externes, contrôle de l'avance du couple ", 
"snippet" : "Les valeurs des axes d'un groupe d'axes sont normalement calculées en fin de cycle après exécution du code application programmé par l'utilisateur. Cependant, pour certaines applications, il est nécessaire que ces valeurs soient disponibles plus tôt afin de pouvoir les utiliser dans le code de l'app...", 
"body" : "Les valeurs des axes d'un groupe d'axes sont normalement calculées en fin de cycle après exécution du code application programmé par l'utilisateur. Cependant, pour certaines applications, il est nécessaire que ces valeurs soient disponibles plus tôt afin de pouvoir les utiliser dans le code de l'application. Le SMC_GroupUpdate Le bloc fonctionnel garantit que les valeurs de tous les axes qui font partie d'un groupe d'axes sont mises à jour immédiatement. Un cas d'utilisation pour SMC_GroupUpdate est la synchronisation des axes qui ne font pas partie du groupe d'axes. Un exemple serait un deuxième entraînement pour l'axe X dans le cas d'un portique XY. Avant CODESYS SoftMotion version 4.13.0.0 : Un cas d'utilisation supplémentaire pour le SMC_GroupUpdate Le bloc fonctionnel est la commande anticipée de couple. Les valeurs d'axe calculées dans le cycle en cours peuvent être utilisées pour calculer les couples définis appropriés à l'aide d'un modèle dynamique du robot. Dans CODESYS SoftMotion version 4.13.0.0 et supérieure : Si un modèle dynamique a été affecté au groupe d'axes à l'aide SMC_GroupSetDynamics , les couples réglés sont alors automatiquement calculés de manière cyclique et peuvent être utilisés pour le contrôle anticipé du couple. L'utilisation de SMC_GroupUpdate n’est plus nécessaire pour ce cas d’utilisation. Pour plus d'informations, voir : Limitation de couple et commande d'avance de couple" }, 
{ "title" : "Déclencheurs ", 
"url" : "_sm_digital_switches-1517880.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Déclencheurs ", 
"snippet" : "Les déclencheurs sont utilisés pour effectuer une action lorsque le groupe d'axes atteint une position définie sur la trajectoire. Par exemple, un distributeur de colle peut être activé lorsque vous atteignez la position de collage. Les déclencheurs prennent également en charge les décalages tempore...", 
"body" : "Les déclencheurs sont utilisés pour effectuer une action lorsque le groupe d'axes atteint une position définie sur la trajectoire. Par exemple, un distributeur de colle peut être activé lorsque vous atteignez la position de collage. Les déclencheurs prennent également en charge les décalages temporels afin que l'action puisse être exécutée à un moment précis avant ou après que la position soit atteinte. Cela peut être utilisé, par exemple, pour compenser le temps mort d'un distributeur de colle. À cette fin, CODESYS SoftMotion permet de configurer les déclencheurs des mouvements, puis de lire en continu le temps restant jusqu'à ce que la position soit atteinte. Lorsque vous utilisez des déclencheurs, faites attention aux points suivants : Le temps jusqu'à ce qu'un déclencheur soit atteint ne peut être récupéré que lorsque le groupe d'axes s'est approché du déclencheur jusqu'à l'heure d'une prévision configurable. La configuration de cette prévision et les impacts des paramètres sont expliqués dans le Configuration de l'application pour utiliser des déclencheurs section. La trajectoire n'est pas modifiée par l'utilisation de déclencheurs. En particulier, la trajectoire n'est pas ralentie pour respecter la prévision configurée. Si, par exemple, la position d'un déclencheur au début d'un mouvement est déjà atteinte après 0,01 seconde, alors même une prévision plus élevée ne peut pas faire en sorte qu'une notification soit fournie sur l'atteinte du point plus de 0,01 seconde à l'avance. Pour plus d'informations, consultez les exemples Exemple de déclencheur 1 : exemple simple et Exemple de déclencheur 2 : Processus de collage. " }, 
{ "title" : "Configuration de l'application pour utiliser des déclencheurs ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4612456003211233798533752147", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Déclencheurs \/ Configuration de l'application pour utiliser des déclencheurs ", 
"snippet" : "Paramétrage de la durée prévisionnelle La durée de prévision détermine jusqu'où dans le futur la planification est effectuée. Celle-ci est fixée par le fPlanningForecastDuration paramètre de la SMC_TuneCPKernel bloc fonctionnel. La façon dont ce paramètre doit être défini dépend des exigences de l'a...", 
"body" : "Paramétrage de la durée prévisionnelle La durée de prévision détermine jusqu'où dans le futur la planification est effectuée. Celle-ci est fixée par le fPlanningForecastDuration paramètre de la SMC_TuneCPKernel bloc fonctionnel. La façon dont ce paramètre doit être défini dépend des exigences de l'application. Il existe deux exigences principalement contradictoires : Durée de prévision la plus longue possible Latence la plus faible possible. La latence au démarrage d'un mouvement augmente car il faut d'abord établir la prévision. La taille de cette latence supplémentaire dépend principalement des performances du contrôleur utilisé et est généralement bien inférieure à la prévision configurée. De plus, la latence du groupe d'axes pour réagir aux mouvements interrompus et aux interruptions augmente de la prévision configurée. La prévision n'a pas d'incidence sur MC_GroupHalt et MC_GroupStop . Les deux blocs fonctionnels agissent toujours immédiatement et indépendamment de la prévision configurée. Le fPlanningForecastDuration paramètre de la SMC_TuneCPKernel bloc fonctionnel doit donc être réglé aussi haut que nécessaire mais aussi bas que possible. Si une prévision n'est pas requise, le paramètre peut être laissé à la valeur par défaut de 0. La prévision disponible réelle peut différer de celle configurée pour diverses raisons, par exemple, si la fin du dernier mouvement est déjà presque atteinte. Les prévisions actuellement disponibles peuvent être surveillées au moyen du CurrentPlanningForecast sortie de MC_GroupReadStatus . Configuration du nombre maximum de déclenchements par mouvement Comme livré, CODESYS SoftMotion prend en charge jusqu'à 8 déclencheurs par mouvement. Si ce nombre n'est pas suffisant, le MAX_NUM_TRIGGERS_PER_MOVEMENT Le paramètre peut être modifié en tant que paramètre de bibliothèque. C'est possible avec le Gestionnaire de bibliothèque et l'éditeur respectif pour le paramètres de la bibliothèque . Pour utiliser les paramètres de la bibliothèque, un CODESYS version >= SP19 est recommandée. " }, 
{ "title" : "Commande et évaluation des déclencheurs ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4620348699414433798534144567", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Déclencheurs \/ Commande et évaluation des déclencheurs ", 
"snippet" : "Deux blocs fonction sont disponibles pour commander les déclencheurs : SMC_GroupPrepareTrigger et SMC_GroupReadTrigger . Les déclencheurs sont affectés à un mouvement. Chaque déclencheur individuel doit être préparé à l'aide du SMC_GroupPrepareTrigger bloc fonctionnel. La position peut être spécifié...", 
"body" : "Deux blocs fonction sont disponibles pour commander les déclencheurs : SMC_GroupPrepareTrigger et SMC_GroupReadTrigger . Les déclencheurs sont affectés à un mouvement. Chaque déclencheur individuel doit être préparé à l'aide du SMC_GroupPrepareTrigger bloc fonctionnel. La position peut être spécifiée relative, absolue ou comme une intersection avec un plan (voir SMC_TriggerPositionType ). L'ordre d'appel de SMC_GroupPrepareTrigger et le mouvement respectif est d'une importance particulière car les déclencheurs préparés sont affectés au prochain mouvement commandé dans le même cycle. Par conséquent, dans chaque application, vous devez faire attention aux points suivants : SMC_GroupPrepareTrigger doit toujours être appelé avant le bloc fonction mouvement. Les déclencheurs et le mouvement respectif doivent toujours être commandés dans le même cycle. Si aucun mouvement n'est démarré dans le cycle, les déclencheurs préparés sont rejetés et le CommandAborted sortie de la SMC_GroupPrepareTrigger blocs fonctionnels est défini. Lorsque le déclencheur est affecté à un mouvement, les informations sur un déclencheur peuvent être récupérées à l'aide de SMC_GroupReadTrigger . Dès que le déclencheur est dans la durée de prévision disponible, le statut passe à SMC_TRIGGER_STATUS.Active et le temps jusqu'à ce que le déclencheur soit atteint peut être lu. L'heure se réfère toujours à l'heure de début du cycle en cours. Selon le moment où le déclencheur doit être déclenché (avant, pendant ou après que la position est atteinte), l'action souhaitée peut être exécutée dans l'application dans un cycle approprié. Les déclencheurs ne peuvent pas être annulés lorsqu'ils ont été affectés à un mouvement. Au lieu de cela, ils peuvent simplement être ignorés. Si un mouvement est interrompu par un deuxième mouvement avec MC_BUFFER_MODE.Aborting , les déclencheurs affectés au premier mouvement disparaissent également. " }, 
{ "title" : "Déclencheurs de mouvements avec blending ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4612455902227233798534431018", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Contrôle de mouvement \/ Déclencheurs \/ Déclencheurs de mouvements avec blending ", 
"snippet" : "Pour les mouvements avec Mise en mémoire tampon et fusion des mouvements, les déclencheurs sont projetés sur le chemin de fusion. L'image suivante montre qualitativement un cas dans lequel un mouvement de P1 à P2 ainsi qu'un mouvement suivant ont chacun été commandés avec mélange. La fusion avec le ...", 
"body" : "Pour les mouvements avec Mise en mémoire tampon et fusion des mouvements, les déclencheurs sont projetés sur le chemin de fusion. L'image suivante montre qualitativement un cas dans lequel un mouvement de P1 à P2 ainsi qu'un mouvement suivant ont chacun été commandés avec mélange. La fusion avec le premier mouvement se termine au point B, et la fusion avec le mouvement précédent commence au point A. Le déclencheur bleu est situé entre P1 et B. Il est projeté sur la moitié arrière du premier mouvement de fusion (mis en évidence par la ligne bleue) . De la même manière, la gâchette rouge, située entre A et P2, est projetée sur la moitié avant du second mouvement de mixage (mise en évidence par le trait rouge). Le déclencheur vert est en dehors des zones de fusion et n'est pas décalé. Lors de la fusion avec des déclencheurs, il existe une fonction spéciale concernant l'état du mouvement et les déclencheurs respectifs. Le bloc fonction de commande pour passer des rapports P1 à P2 Done dès que le point A est atteint. Cependant, le déclencheur rouge associé à ce mouvement reste actif jusqu'à ce que la position sur l'élément de fusion vers laquelle il a été projeté soit atteinte. " }, 
{ "title" : "Limitation de couple et commande d'avance de couple ", 
"url" : "_sm_torque_limitation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitation de couple et commande d'avance de couple ", 
"snippet" : "La limitation de couple de CODESYS SoftMotion empêche le dépassement des limites spécifiées des couples ou des forces des entraînements lors de mouvements coordonnés. Ces limites de couples et d'efforts sont respectées en plus des limites existantes de vitesse, d'accélération et d'à-coup des entraîn...", 
"body" : "La limitation de couple de CODESYS SoftMotion empêche le dépassement des limites spécifiées des couples ou des forces des entraînements lors de mouvements coordonnés. Ces limites de couples et d'efforts sont respectées en plus des limites existantes de vitesse, d'accélération et d'à-coup des entraînements. La condition préalable est un modèle dynamique pour la cinématique appliquée sous la forme d'un bloc fonctionnel qui implémente le ISMDynamics l'interface de la SM3_Dynamics bibliothèque. Au fond, un AxesStateToTorque est nécessaire, qui calcule les couples requis pour un état donné des axes (pour leur position, leur vitesse et leur accélération). Outre la limitation de couple, un modèle dynamique permet de calculer des couples de consigne pour une commande anticipatrice de couple. Vous trouverez un exemple d'application dans le chapitre Modèle de robot dynamique. " }, 
{ "title" : "Cas d'utilisation ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4597660278291233422349551383", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitation de couple et commande d'avance de couple \/ Cas d'utilisation ", 
"snippet" : "Dans de nombreuses cinématiques, notamment la cinématique série, il existe un couplage de plusieurs articulations ou de toutes les articulations. Un exemple simple de ceci est le double pendule avec des entraînements dans les articulations comme indiqué ci-dessous : Cas d'utilisation 1 Cas d'utilisa...", 
"body" : "Dans de nombreuses cinématiques, notamment la cinématique série, il existe un couplage de plusieurs articulations ou de toutes les articulations. Un exemple simple de ceci est le double pendule avec des entraînements dans les articulations comme indiqué ci-dessous : Cas d'utilisation 1 Cas d'utilisation 2 L'entraînement de la première articulation effectue une rotation de 90° ; la deuxième articulation ne doit pas bouger (cas d'utilisation 1). En supposant une deuxième articulation passive, il est facile d'imaginer que la deuxième branche du double pendule tournera vers la gauche en raison de son inertie. Pour empêcher cette rotation, l'entraînement dans la deuxième articulation doit générer un couple vers la droite. Par conséquent, le mouvement du premier disque nécessite une réaction du deuxième disque. Un couplage en sens inverse existe, par exemple, dans le cas où le premier entraînement doit se déplacer à vitesse constante tandis que le deuxième entraînement rétracte la deuxième branche du double pendule (cas d'utilisation 2). Ceci réduit les matrices d'inertie du double pendule par rapport à la première articulation. Pour obtenir le moment cinétique (le produit des matrices d'inertie et de la vitesse angulaire), la vitesse angulaire de la première articulation doit être augmentée. Pour maintenir la vitesse angulaire constante, le moment cinétique doit être diminué en changeant le couple du premier entraînement contre son sens de rotation. Par conséquent, le mouvement du deuxième disque nécessite une réaction du premier disque. Sans modèle dynamique, seules la position définie, la vitesse définie et l'accélération définie peuvent être envoyées au variateur. Dans le premier cas, une position de consigne constante est définie pour le second entraînement, que la première articulation soit mobile ou non. L'unité de commande du deuxième variateur doit pouvoir gérer le fait qu'un couple doit être généré dans un cas et pas dans un autre pour les mêmes valeurs de consigne. Le comportement est similaire dans le second cas. Ici, la même vitesse de consigne constante est spécifiée pour le premier entraînement, que la deuxième articulation soit en mouvement ou non. Ici aussi, l'unité de commande du variateur doit faire face au fait que différents couples doivent être générés pour les mêmes valeurs de consigne. Avec un modèle dynamique, les couples de consigne peuvent être calculés et envoyés aux variateurs. Là, ils peuvent être utilisés comme dimension d'anticipation pour les unités de commande. En conséquence, l'unité de contrôle reçoit des informations supplémentaires qui permettent une amélioration de la qualité du contrôle. La limitation de couple permet de respecter plus précisément les limites du variateur. Dans de nombreux cas, ce n'est pas la limitation de la vitesse ou de l'accélération de l'entraînement qui est déterminante, mais la limitation des couples. Les avantages de la limitation de couple ressortent de l'exemple du double pendule tel que décrit ci-dessus lorsque l'on compare les mouvements suivants : un mouvement du premier moteur avec la seconde branche rentrée et un mouvement du premier moteur avec la seconde branche sortie. A l'état rétracté, les matrices d'inertie par rapport à la première articulation sont inférieures à celles à l'état sorti. Pour un même mouvement (mêmes courbes de vitesse et d'accélération du moteur), il faut donc un couple plus important à l'état sorti qu'à l'état rentré. Sans modèle dynamique, les limites de vitesse et d'accélération doivent être définies de manière à ce que les limites de couple soient respectées dans les deux états. Cela peut amener le premier entraînement à se déplacer à une vitesse ou une accélération inférieure à l'état rétracté à ce qui serait nécessaire pour respecter les limites de couple de l'entraînement. Avec un modèle dynamique, les limites de couple peuvent être configurées, prises en compte lors de la planification du mouvement, et donc pleinement utilisées dans les deux états. Un exemple légèrement plus complexe est le premier cas tel que décrit ci-dessus, où le premier disque est en mouvement et le deuxième disque doit maintenir sa position. Le couple requis dans le deuxième entraînement pour maintenir sa position dépend du mouvement du premier entraînement. Si le premier entraînement accélère trop brusquement, la limite de couple du deuxième entraînement peut en principe être dépassée. Sans modèle dynamique, cela ne peut être évité qu'en configurant les limites d'accélération du premier entraînement en conséquence. Avec un modèle dynamique, la limite de couple configurée du deuxième entraînement peut être prise en compte lors de la planification du mouvement et l'accélération du premier entraînement peut être limitée. Dans le cas de mouvements ou de cinématiques plus complexes, les effets de couplage décrits ici s'accompagnent d'encore plus d'effets de couplage. Un modèle dynamique permet de prendre en compte ces couplages, d'où un meilleur cahier des charges et un meilleur respect des limites des variateurs. " }, 
{ "title" : "Configuration du modèle dynamique ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4510933957710433418427140333", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitation de couple et commande d'avance de couple \/ Configuration du modèle dynamique ", 
"snippet" : "Un modèle dynamique existant sous la forme d'un bloc fonction qui implémente la ISMDynamics l'interface peut être affectée à un groupe d'axes à l'aide de la SMC_GroupSetDynamics bloc fonctionnel. Outre le modèle dynamique, le bloc fonctionnel doit également être utilisé pour configurer la direction ...", 
"body" : "Un modèle dynamique existant sous la forme d'un bloc fonction qui implémente la ISMDynamics l'interface peut être affectée à un groupe d'axes à l'aide de la SMC_GroupSetDynamics bloc fonctionnel. Outre le modèle dynamique, le bloc fonctionnel doit également être utilisé pour configurer la direction et l'amplitude de l'accélération gravitationnelle sous la forme d'un vecteur dans le système de coordonnées de la machine. " }, 
{ "title" : "Prise en compte des charges ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552490173838433418429772624", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitation de couple et commande d'avance de couple \/ Prise en compte des charges ", 
"snippet" : "Des charges supplémentaires (par exemple, des objets saisis ou des outils attachés) peuvent être prises en compte au moyen du SMC_GroupSetLoad bloc fonctionnel et modifié lors de l'exécution. Le ExecutionMode L'entrée du bloc fonction peut être utilisée pour définir quand un changement de charge doi...", 
"body" : "Des charges supplémentaires (par exemple, des objets saisis ou des outils attachés) peuvent être prises en compte au moyen du SMC_GroupSetLoad bloc fonctionnel et modifié lors de l'exécution. Le ExecutionMode L'entrée du bloc fonction peut être utilisée pour définir quand un changement de charge doit prendre effet (par exemple, immédiatement ou seulement après que le mouvement en cours soit terminé). Suite avec MC_GroupContinue : Lors de la poursuite, chaque mouvement stocké dans les données de poursuite conserve la charge avec laquelle il a été commandé à l'origine. Tout mouvement commandé après la poursuite utilise la dernière charge définie. " }, 
{ "title" : "Considération d'une boîte de vitesses ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552678559262433422353734728", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitation de couple et commande d'avance de couple \/ Considération d'une boîte de vitesses ", 
"snippet" : "Les couples réglés sont calculés pour la sortie du réducteur et ne sont pas automatiquement convertis en entraînement. Le SMC_SetAdditionalConversionFactors bloc fonction permet de configurer un facteur de conversion supplémentaire du couple pour chaque axe. La boîte de vitesses peut également être ...", 
"body" : "Les couples réglés sont calculés pour la sortie du réducteur et ne sont pas automatiquement convertis en entraînement. Le SMC_SetAdditionalConversionFactors bloc fonction permet de configurer un facteur de conversion supplémentaire du couple pour chaque axe. La boîte de vitesses peut également être prise en compte de cette manière. " }, 
{ "title" : "Unités ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4597662777713633422354433707", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitation de couple et commande d'avance de couple \/ Unités ", 
"snippet" : "Les forces et les couples et leurs limites sont essentiellement spécifiés dans l'application en newtons (N) ou en newtons mètres (Nm). Avant que les forces définies ou les couples définis ne soient envoyés aux variateurs, une remise à l'échelle peut être effectuée. Pour cela, la norme CiA 402 impose...", 
"body" : "Les forces et les couples et leurs limites sont essentiellement spécifiés dans l'application en newtons (N) ou en newtons mètres (Nm). Avant que les forces définies ou les couples définis ne soient envoyés aux variateurs, une remise à l'échelle peut être effectuée. Pour cela, la norme CiA 402 impose par exemple que les couples de consigne soient envoyés au variateur en millièmes du couple nominal (en mNm). L'unité des longueurs est spécifique à l'utilisateur dans SoftMotion. Étant donné que les forces et les couples sont définis comme une unité fixe (N ou Nm), un facteur de conversion d'une unité de longueur spécifique à l'utilisateur en mètres doit être configuré (sauf si les mètres sont utilisés comme unité de longueur). Ceci peut être fait avec le SMC_GroupSetUnits bloc fonctionnel. " }, 
{ "title" : "Limitation de couple dans les systèmes de coordonnées mobiles ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552049322772833422354993274", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitation de couple et commande d'avance de couple \/ Limitation de couple dans les systèmes de coordonnées mobiles ", 
"snippet" : "Si le groupe d'axes se déplace dans un système de coordonnées mobile, alors les limites de couple ne peuvent être respectées que lorsque le groupe d'axes peut suivre exactement le système de coordonnées mobile. Si cela n'est pas possible et que les tolérances pour l'écart sont configurées au moyen d...", 
"body" : "Si le groupe d'axes se déplace dans un système de coordonnées mobile, alors les limites de couple ne peuvent être respectées que lorsque le groupe d'axes peut suivre exactement le système de coordonnées mobile. Si cela n'est pas possible et que les tolérances pour l'écart sont configurées au moyen de SMC_GroupSetPathTolerance , les limites de couple peuvent être dépassées lors de la tentative de compensation de l'écart. Si une erreur se produit parce que les écarts sont en dehors des tolérances, alors le groupe d'axes s'arrête. Pendant cet arrêt, les limites de couple peuvent également être dépassées. Les couples réglés sont calculés dans chaque cas et envoyés aux entraînements. " }, 
{ "title" : "Limitation de couple en cas d'erreur ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4612699285196833422355410226", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitation de couple et commande d'avance de couple \/ Limitation de couple en cas d'erreur ", 
"snippet" : "Si une erreur est détectée pendant la planification (par exemple, qu'un mouvement commandé violera la zone de travail), alors le groupe d'axes s'arrête sur la trajectoire précédemment commandée. Ce faisant, les limites de couple sont respectées. S'il n'est pas possible de s'arrêter sur la trajectoir...", 
"body" : "Si une erreur est détectée pendant la planification (par exemple, qu'un mouvement commandé violera la zone de travail), alors le groupe d'axes s'arrête sur la trajectoire précédemment commandée. Ce faisant, les limites de couple sont respectées. S'il n'est pas possible de s'arrêter sur la trajectoire (par exemple, parce qu'un entraînement signale une erreur), les limites de couple ne peuvent pas non plus être respectées. " }, 
{ "title" : "Différences lors de l'utilisation de mouvements à axe unique et de mouvements coordonnés ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4483062104566433422355806924", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Limitation de couple et commande d'avance de couple \/ Différences lors de l'utilisation de mouvements à axe unique et de mouvements coordonnés ", 
"snippet" : "Fondamentalement, les couples de consigne sont calculés pour tous les axes faisant partie d'un groupe d'axes avec un modèle dynamique. Ceci s'applique aussi bien à l'arrêt que lorsque l'axe est déplacé au moyen de mouvements mono-axes (par exemple, MC_MoveAbsolute ) ou l'ensemble du groupe d'axes es...", 
"body" : "Fondamentalement, les couples de consigne sont calculés pour tous les axes faisant partie d'un groupe d'axes avec un modèle dynamique. Ceci s'applique aussi bien à l'arrêt que lorsque l'axe est déplacé au moyen de mouvements mono-axes (par exemple, MC_MoveAbsolute ) ou l'ensemble du groupe d'axes est parcouru par des mouvements coordonnés (par exemple, MC_MoveDirectAbsolute ). La limitation de couple n'est active que pour les mouvements coordonnés. La raison en est que les couples nécessaires d'un axe, comme décrit ci-dessus, dépendent de la position et du mouvement de certains ou de tous les autres axes du groupe d'axes. Par conséquent, une limitation de couple n'est possible que lorsque tous les axes du groupe d'axes peuvent être déplacés en tant que mouvements coordonnés. Une exception est la SMC_GroupJog bloc de fonctions. Ce bloc fonctionnel ne prend pas en charge la limitation de couple. Il est recommandé d'utiliser SMC_GroupJog2 au lieu. " }, 
{ "title" : "Diagnostic ", 
"url" : "_sm_robotics_diagnosis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnostic ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Erreurs courantes ", 
"url" : "_sm_robotics_errors.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnostic \/ Erreurs courantes ", 
"snippet" : "Cette page décrit les erreurs courantes de groupe d'axes, leurs causes et les actions possibles à entreprendre pour corriger l'erreur. Pour une liste de toutes les erreurs possibles avec une brève description, consultez la page d'aide de SMC_ERROR (ENUM) . Code d'erreur Explication et causes Actions...", 
"body" : "Cette page décrit les erreurs courantes de groupe d'axes, leurs causes et les actions possibles à entreprendre pour corriger l'erreur. Pour une liste de toutes les erreurs possibles avec une brève description, consultez la page d'aide de SMC_ERROR (ENUM) . Code d'erreur Explication et causes Actions SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED Le groupe d'axes ne peut pas suivre la trajectoire commandée sans violer une limite d'axe (vitesse, accélération ou à-coup). Cette erreur se produit souvent lors suivi si le système de coordonnées dynamiques se déplace de manière inattendue. L'erreur peut également se produire lorsque la trajectoire passe à proximité d'une position singulière du robot. Des positions singulières se produisent entre différents configurations (par exemple avec le robot SCARA lorsque le bras est complètement étendu). Voir Évitez les erreurs SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED, SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED ou SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED.Si aucun système de coordonnées dynamiques n'est utilisé, assurez-vous que la trajectoire du robot ne passe pas à proximité d'une position singulière. SMC_CP_QUEUE_UNDERRUN La trajectoire (profil de vitesse) du groupe d'axes n'a pas pu être calculée assez rapidement et le groupe d'axes doit donc interrompre le mouvement. Causes possibles: Problèmes de performances. Le contrôleur utilisé ne fournit pas de performances suffisantes ou trop de calculs sont effectués dans une tâche hautement prioritaire. Paramétrage des tâches défavorables : Le calcul de la trajectoire est déplacé par d'autres tâches. Commandes gourmandes en calcul. Par exemple, cela peut nécessiter plus de temps de calcul si un mouvement de mélange est interrompu par un mouvement interrompu et qu'il est ensuite à nouveau interrompu par un mouvement interrompu. L'utilisation du tracking (systèmes de coordonnées dynamiques) nécessite également plus de temps de calcul. L'exécution de SMC_GroupSaveContinueData lors d'un mouvement et l'utilisation de nombreux déclencheurs actifs simultanément peuvent également augmenter le temps de calcul requis. Vérifiez si les paramètres de tâche pour la tâche de planification du groupe d'axes ont été sélectionnés correctement et, si possible, déplacez cette tâche vers un cœur de CPU séparé et dédié. Pour plus d'informations, voir : Configuration de la tâche de planificationSur le Surveillance onglet de configuration des tâches 1 vérifiez si une tâche hautement prioritaire nécessite beaucoup de temps de calcul et, si possible, déplacez les calculs gourmands en performances vers une tâche peu prioritaire. Utiliser SMC_TuneCPKernel pour augmenter l'intervalle de planification. Pour plus d'informations, voir : Diagnostic en cas de mouvements lents ou saccadésRemarque : Vous pouvez utiliser les compteurs de performances de SMC_GroupReadPlanningStatistics pour déterminer l'effet de ces actions. Pour plus d'informations, voir : Diagnostic en cas de mouvements lents ou saccadésSMC_TRAFO_INVALID_CONSTELLATION SMC_AXIS_POSITION_EXCEEDS_POSLIMITS SMC_AXIS_INVERSE_TRAFO_EXCEEDING_POSLIMITS Le chemin est totalement ou partiellement en dehors de l'espace de travail du robot. Causes possibles: Le point de départ ou d’arrivée d’un mouvement se situe en dehors de l’espace de travail. Selon le type de robot, une partie du mouvement d'un CP peut se faire en dehors de l'espace de travail. Un segment circulaire avec un rayon trop grand peut se trouver au début et à la fin de l'espace de travail, tandis que la section médiane quitte l'espace de travail. Lors de l'utilisation du suivi (systèmes de coordonnées dynamiques), il est possible qu'une position précédemment localisée dans l'espace de travail quitte l'espace de travail au fil du temps en raison du mouvement du système de coordonnées. Remarque : Lorsque l'erreur est signalée, le groupe d'axes n'est pas nécessairement proche de la position problématique. Il est possible que l'erreur soit trouvée et signalée lors du calcul de la trajectoire et concerne un segment de trajet encore éloigné de la position actuelle. Vérifiez les mouvements commandés et assurez-vous qu'ils se trouvent complètement dans l'espace de travail. Lors de l'utilisation du suivi : utilisez des limites appropriées pour vous assurer que le groupe d'axes ne quitte pas l'espace de travail au fil du temps. Dans le cas du Pick&Place utilisant des bandes transporteuses, par exemple, il est courant de définir une zone sûre où les pièces peuvent encore être prélevées sur la bande transporteuse. Une fois qu'une pièce a quitté cette région, le groupe d'axes ne doit plus se déplacer vers la pièce. SMC_CP_CONFIGS_DIFFER SMC_CP_AXIS_ORIENTATION_IPO_CONFIG_DIFFERS Les positions de départ et d'arrivée d'un mouvement CP sont situées dans différentes configurations. La gestion des configurations est expliquée dans le Configurations cinématiques chapitre. Lors de l'utilisation OrientationMode Axis , voir le Interpolation d'orientation pour les mouvements de CP chapitre pour plus de détails sur la configuration de la partie orientation du robot. Actions possibles : Assurez-vous que les positions de début et de fin des mouvements du CP sont situées dans la même configuration. Si nécessaire, utilisez le SMC_SetKinConfiguration bloc fonction pour définir la configuration du robot au début (après MC_GroupEnable ). Utilisez les mouvements PTP pour basculer entre les configurations si vous le souhaitez. " }, 
{ "title" : "Performance ", 
"url" : "_sm_robotics_performance.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnostic \/ Performance ", 
"snippet" : "La planification des mouvements se fait dans une tâche distincte car le calcul est gourmand en CPU. Cette tâche distincte est appelée tâche de planification et s'exécute en parallèle avec la tâche de bus. Si les performances de l'automate ne suffisent pas à planifier le chemin dans la tâche de plani...", 
"body" : "La planification des mouvements se fait dans une tâche distincte car le calcul est gourmand en CPU. Cette tâche distincte est appelée tâche de planification et s'exécute en parallèle avec la tâche de bus. Si les performances de l'automate ne suffisent pas à planifier le chemin dans la tâche de planification à temps pour la tâche de bus, il s'agit alors de problèmes de performances. Les problèmes de performance dans la planification des mouvements peuvent conduire à SMC_CP_QUEUE_UNDERRUN erreur, mais ils peuvent aussi conduire à un mouvement saccadé ou plus lent que prévu. Pour obtenir des informations sur le SMC_CP_QUEUE_UNDERRUN erreur, voir le Erreurs courantes chapitre. Le diagnostic des problèmes de performance liés aux mouvements est décrit ci-dessous. " }, 
{ "title" : "Diagnostic en cas de mouvements lents ou saccadés ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm4597696111868834242456592379", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnostic \/ Performance \/ Diagnostic en cas de mouvements lents ou saccadés ", 
"snippet" : "S'il n'y a aucun problème de performance, alors chaque mouvement est planifié de telle manière qu'au moins un des limites efficaces est atteint pendant tout le mouvement. A titre d'exemple, considérons un simple portique bidimensionnel avec deux axes X et Y et un mouvement PTP de la position (0,0) à...", 
"body" : "S'il n'y a aucun problème de performance, alors chaque mouvement est planifié de telle manière qu'au moins un des limites efficaces est atteint pendant tout le mouvement. A titre d'exemple, considérons un simple portique bidimensionnel avec deux axes X et Y et un mouvement PTP de la position (0,0) à (10,-10). La vitesse maximale de l'axe est de 20, l'accélération maximale de l'axe est de 100 et l'à-coup maximal de l'axe est de 1 000. Le mouvement attendu ressemble à ceci : L'accélération s'établit d'abord avec un à-coup maximum jusqu'à ce que la valeur limite d'accélération de 100 soit atteinte. Après une courte phase d'accélération constante, l'accélération est à nouveau réduite avec un à-coup maximum, de sorte que la valeur limite de vitesse de 20 soit atteinte avec une accélération de 0. Après une phase de vitesse constante, une décélération a lieu de sorte que la position cible soit atteinte avec la vitesse. et accélération 0. Il y a deux raisons possibles pour lesquelles le mouvement réel s’écarte de cette courbe idéale : Le mouvement prévu ne correspond pas à la courbe idéale en raison de problèmes de performance dans la tâche de planification. Le mouvement prévu correspond à la courbe idéale, mais le robot ne l'exécute pas comme prévu. " }, 
{ "title" : "Cas 1 : Problèmes de performance de la tâche de planification ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433006527711", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnostic \/ Performance \/ Diagnostic en cas de mouvements lents ou saccadés \/ Cas 1 : Problèmes de performance de la tâche de planification ", 
"snippet" : "S’il y a des problèmes de performance lors de la planification, le mouvement pourrait alors ressembler à ceci : En effet, le mouvement est planifié dans la tâche de planification parallèlement à l'exécution dans la tâche de bus. En moyenne, la tâche de planification doit fournir autant de trajectoir...", 
"body" : "S’il y a des problèmes de performance lors de la planification, le mouvement pourrait alors ressembler à ceci : En effet, le mouvement est planifié dans la tâche de planification parallèlement à l'exécution dans la tâche de bus. En moyenne, la tâche de planification doit fournir autant de trajectoire que l’exige la tâche de bus. Si les performances ne sont pas suffisantes, le mouvement est alors ralenti. Cela conduit à la courbe de vitesse ondulée. Le premier et le plus important outil pour diagnostiquer de tels problèmes est la trace. En plus de fSetPosition , fSetVelocity , et fSetAcceleration variables pour chaque axe, le numTimeBudgetExceeded et numSlowDownLowIpoQueue sorties du SMC_GroupReadPlanningStatistics Le bloc fonctionnel doit également être enregistré. Si ces compteurs augmentent continuellement, il y a alors un problème de performances. De la même manière que le fSetPosition , fSetVelocity , et fSetAcceleration variables, il y a aussi les fSetJerk variable pour le jerk. Il convient de noter que l'à-coup n'est pas l'à-coup moyen appliqué pendant le cycle de la tâche du bus (comme on s'y attend souvent), mais plutôt l'à-coup instantané à la fin du cycle. Donc, FSetJerk n'a qu'une importance limitée pour diagnostiquer les problèmes de performances. " }, 
{ "title" : "Façons d'améliorer le mouvement ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm43443300985204", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnostic \/ Performance \/ Diagnostic en cas de mouvements lents ou saccadés \/ Cas 1 : Problèmes de performance de la tâche de planification \/ Façons d'améliorer le mouvement ", 
"snippet" : "La liste suivante contient les étapes permettant de gérer les problèmes de performances : Ajustement des valeurs limites pour la vitesse, l'accélération et l'à-coup : Plus il faut de temps pour décélérer depuis la vitesse actuelle jusqu'à l'arrêt, plus la puissance de calcul requise est élevée. Une ...", 
"body" : "La liste suivante contient les étapes permettant de gérer les problèmes de performances : Ajustement des valeurs limites pour la vitesse, l'accélération et l'à-coup : Plus il faut de temps pour décélérer depuis la vitesse actuelle jusqu'à l'arrêt, plus la puissance de calcul requise est élevée. Une valeur limite efficace élevée pour la vitesse et des valeurs limites efficaces faibles pour l'accélération et l'à-coup sont donc plus susceptibles d'entraîner des problèmes de performances. En particulier, les valeurs limites d'accélération et d'à-coup ne doivent donc pas être fixées inutilement à des niveaux bas. Augmentez la priorité de la tâche de planification ou diminuez la priorité des autres tâches si elles bloquent la tâche de planification. La tâche de planification doit avoir la deuxième priorité la plus élevée après la tâche de bus. Attribuez la tâche de planification à un cœur dédié si plusieurs cœurs de processeur sont disponibles (voir Configuration de la tâche de planification). Utiliser SMC_TuneCPKernel pour augmenter la valeur du fPlanningInterval et\/ou fSyncBufferDuration paramètres de planification. Le fPlanningInterval Le paramètre spécifie l'incrément de planification maximum (en secondes). Le temps de cycle de la tâche de planification ne doit pas dépasser cette valeur en permanence. Une valeur plus élevée réduit la puissance de calcul, mais peut également empêcher que les valeurs limites définies pour la vitesse, l'accélération et l'à-coup ne soient pas pleinement utilisées. A partir d'une valeur de départ de 0,016 seconde (valeur par défaut depuis CODESYS SoftMotion version 4.6.0.0), la valeur doit être augmentée progressivement jusqu'à ce que les performances soient acceptables. Le fSyncBufferDuration Le paramètre spécifie la taille du tampon entre la tâche de planification et la tâche de bus. Les temps de cycle de pointe de la tâche de planification ne doivent pas dépasser cette valeur. Une valeur plus élevée peut compenser les pics de temps de cycle de la tâche de planification. Mais dans le même temps, cela augmente également le temps de latence pour l'exécution des interruptions et l'abandon des mouvements. " }, 
{ "title" : "Cas 2 : Le robot ne suit pas le mouvement prévu comme prévu ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433008452776", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnostic \/ Performance \/ Diagnostic en cas de mouvements lents ou saccadés \/ Cas 2 : Le robot ne suit pas le mouvement prévu comme prévu ", 
"snippet" : "Si le robot ne suit pas le mouvement prévu comme prévu, cela peut être dû aux raisons suivantes : Capacité temps réel insuffisante du contrôleur Problèmes de boucle de contrôle des variateurs Sur un contrôleur non compatible temps réel tel que le CODESYS Control Win , ou un contrôleur basé sur Linux...", 
"body" : "Si le robot ne suit pas le mouvement prévu comme prévu, cela peut être dû aux raisons suivantes : Capacité temps réel insuffisante du contrôleur Problèmes de boucle de contrôle des variateurs Sur un contrôleur non compatible temps réel tel que le CODESYS Control Win , ou un contrôleur basé sur Linux sans correctif en temps réel du système Linux sous-jacent, des mouvements trop lents ou saccadés peuvent se produire même avec des performances suffisantes. Cela se produit si la tâche de bus n'est pas exécutée à temps dans le laps de temps configuré. " }, 
{ "title" : "Façons d'améliorer le mouvement ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433012326085", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnostic \/ Performance \/ Diagnostic en cas de mouvements lents ou saccadés \/ Cas 2 : Le robot ne suit pas le mouvement prévu comme prévu \/ Façons d'améliorer le mouvement ", 
"snippet" : "Sur l'onglet \"Suivi\" de la configuration des tâches 1 , vérifiez si la tâche gigue de la tâche de bus 2 est trop élevé. Cela peut être le cas soit parce que la tâche du bus est déplacée par une tâche ayant une priorité identique ou supérieure, soit parce que le contrôleur n'est pas suffisamment capa...", 
"body" : "Sur l'onglet \"Suivi\" de la configuration des tâches 1 , vérifiez si la tâche gigue de la tâche de bus 2 est trop élevé. Cela peut être le cas soit parce que la tâche du bus est déplacée par une tâche ayant une priorité identique ou supérieure, soit parce que le contrôleur n'est pas suffisamment capable de fonctionner en temps réel. Si la gigue est trop élevée et que vous avez déjà veillé à ce que la tâche de bus ait la priorité la plus élevée, la capacité temps réel du contrôleur n'est pas suffisante. Dans ce cas, utilisez un contrôleur doté de meilleures propriétés temps réel. S'il y a des problèmes de boucle de contrôle dans le variateur, vous devez alors ajuster les paramètres de la boucle de contrôle. Le contrôle anticipé du couple peut également améliorer les performances de la boucle de contrôle. Pour plus d'informations, voir : Limitation de couple et commande d'avance de couple1 : Il est conseillé de réinitialiser les valeurs mesurées du suivi des tâches dans le menu contextuel car le premier cycle automate après le démarrage de l'application a souvent une durée accrue et un jitter accru. 2 : Valeurs de gigue jusqu'à env. 20 us sont très bons et valorisent jusqu'à env. 100 nous, c'est bien. Selon les lecteurs utilisés, un fonctionnement avec des valeurs de gigue plus élevées peut également fonctionner. Les valeurs de gigue qui atteignent l'ordre de grandeur de l'intervalle de tâche de la tâche de bus peuvent entraîner le modèle d'erreur décrit ci-dessus. " }, 
{ "title" : "Informations de journalisation ", 
"url" : "_sm_information_logging.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnostic \/ Informations de journalisation ", 
"snippet" : "Le Journalisation des événements SMC_Group bloc fonctionnel a été introduit avec la version 4.18.0.0 de SoftMotion. Le bloc fonctionnel peut être utilisé pour activer les messages de journalisation pour un groupe d'axes. Dès que les messages du journal sont activés, le groupe d'axes écrit les action...", 
"body" : "Le Journalisation des événements SMC_Group bloc fonctionnel a été introduit avec la version 4.18.0.0 de SoftMotion. Le bloc fonctionnel peut être utilisé pour activer les messages de journalisation pour un groupe d'axes. Dès que les messages du journal sont activés, le groupe d'axes écrit les actions qu'il exécute dans le Journal de l'appareil. De cette manière, les événements du groupe d'axes peuvent être suivis chronologiquement. Cela peut être utile pour étudier les problèmes et le comportement inattendu du groupe d'axes. Attribuez des noms à vos mouvements, à vos charges, à vos outils, etc. afin d'obtenir des messages de journal informatifs. CODESYS SoftMotion version 4.18.0.0 et supérieure, certains blocs de fonctions de commande (tels que MC_MoveLinearAbsolute , SMC_GroupSetTool et MC_SetCoordinateTransform ) ont été dotés d'un nouveau Name entrée. La journalisation peut avoir un impact négatif sur les performances et doit donc être activée via le SMC_GroupEventLogging bloc fonctionnel. Dans CODESYS SoftMotion version 4.18.0.0, les messages relatifs à la trajectoire du groupe d'axes sont enregistrés. Catégorie Action Descriptif Informations supplémentaires Mouvement Le mouvement commence Le groupe d'axes a commencé l'interpolation d'un mouvement. AperçuFin du mouvement Le groupe d'axes a terminé l'interpolation d'un mouvement. Le mélange commence Le groupe d'axes a commencé à se fondre du mouvement actif au mouvement suivant. Fin du mélange Le groupe d'axes a terminé la fusion et poursuit l'interpolation lors du prochain mouvement. L'avortement commence Le groupe d'axes a interrompu le mouvement en cours et se fond dans le mouvement interrompu. Fin de l'avortement Le groupe d'axes a terminé la fusion et poursuit l'interpolation sur le mouvement interrompu. L'attente commence Le groupe d'axes attend à la position actuelle. L'attente prend fin Le groupe d'axes a fini d'attendre. Démarrages d'arrêt\/d'arrêt Le groupe d'axes a commencé à effectuer un arrêt ou un arrêt sur la trajectoire. Fin de l'arrêt et de l'arrêt Le groupe d'axes a effectué l'arrêt\/l'arrêt sur la trajectoire. Outil Outil attaché Le groupe d'axes utilise un nouvel outil. Configuration d'un décalage d'outilCharger Charge attachée Le groupe d'axes utilise une nouvelle charge. Limitation de couple et commande d'avance de coupleRemplacer Le remplacement de l'axe ou de la trajectoire a été modifié Le remplacement de l'axe ou de la trajectoire a été modifié et a été appliqué par le groupe d'axes. MC_GroupSetOverride (FB) Précision de la trajectoire Sentier emprunté Le groupe d'axes a quitté la trajectoire commandée afin d'éviter de violer les limites des axes. Le groupe d'axes essaie à nouveau d'atteindre la trajectoire commandée. Tolérances pour la précision du cheminSentier atteint à nouveau Le groupe d'axes a de nouveau atteint la trajectoire commandée. Interrompre — Continuer L'interruption commence Le groupe d'axes a commencé à exécuter une interruption. Interruption et poursuite des mouvementsFin de l'interruption Le groupe d'axes a exécuté l'interruption et enregistré les données Continuer. Continuer commence Le groupe d'axes a lu Continuer les données et commence à les poursuivre. " }, 
{ "title" : "Exemples ", 
"url" : "_sm_robotics_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Faire du jogging avec un robot ", 
"url" : "_sm_robotics_jogging.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Faire du jogging avec un robot ", 
"snippet" : "Voir le Robotics_Jogging.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment déplacer un groupe d'axes avec la SMC_GroupJog2 PU. Il est recommandé d'installer le CODESYS Depictor pour cet exemple (la version...", 
"body" : "Voir le Robotics_Jogging.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment déplacer un groupe d'axes avec la SMC_GroupJog2 PU. Il est recommandé d'installer le CODESYS Depictor pour cet exemple (la version démo gratuite est suffisante). Alternativement, vous pouvez également supprimer les parties de code correspondantes de l'exemple afin d'utiliser l'exemple sans Depictor. " }, 
{ "title" : "Application ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4584875037158433080105006434", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Faire du jogging avec un robot \/ Application ", 
"snippet" : "Afin de démontrer le cas le plus général possible, l'exemple a les fonctions suivantes : Utilisation d'un robot à singularités (robot articulé 6 axes). L'exemple montre que vous pouvez déplacer le robot à travers des singularités dans ACS, puis continuer le jogging de manière cartésienne dans une co...", 
"body" : "Afin de démontrer le cas le plus général possible, l'exemple a les fonctions suivantes : Utilisation d'un robot à singularités (robot articulé 6 axes). L'exemple montre que vous pouvez déplacer le robot à travers des singularités dans ACS, puis continuer le jogging de manière cartésienne dans une configuration différente. Décalage et rotation du système de coordonnées machine (MCS) du robot par rapport au système de coordonnées mondial (WCS). De cette façon, vous pouvez voir comment le jogging diffère dans MCS et WCS. Configuration d'un outil décalé et tourné par rapport à la bride (F). Dans la figure ci-dessous, vous pouvez voir l'outil et le déplacement et la rotation du TCS par rapport à la bride (F). Un axe linéaire supplémentaire Add0 et un axe rotatif supplémentaire Add1 . " }, 
{ "title" : "Structure de la demande ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4576391101379233081218831739", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Faire du jogging avec un robot \/ Structure de la demande ", 
"snippet" : "Programme principal Le programme principal PLC_PRG se compose d'une machine d'état, qui Active le groupe d'axes (état 0) Configure l'outil (état 5) Configure le MCS (état 6) Démarre le jogging (état 10) Dans l'état 20, les erreurs de jogging sont gérées et les commandes de mouvement sont acceptées (...", 
"body" : "Programme principal Le programme principal PLC_PRG se compose d'une machine d'état, qui Active le groupe d'axes (état 0) Configure l'outil (état 5) Configure le MCS (état 6) Démarre le jogging (état 10) Dans l'état 20, les erreurs de jogging sont gérées et les commandes de mouvement sont acceptées ( Déplacer vers un poste basculer dans la visualisation). Les autres états sont utilisés pour effectuer le mouvement (60, 70) et pour gérer et acquitter les erreurs (900, 1000). Selon la machine à états, tous les POU robotiques et les GroupJog2 Le programme est appelé de manière cyclique et certains calculs sont effectués pour l'affichage 3D dans Depictor. Programme GroupJog2 Ce programme contient une machine d'état avec les étapes suivantes : Dans l'état 10, les entrées de SMC_GroupJog2 sont définies et la configuration des axes du robot est lue (SMC_GroupReadActualPosition). Cette configuration se fait à l'état 20 dans le groupe d'axes (SMC_SetKinConfiguration). Dans l'état 30, le système réagit aux erreurs pendant le jogging, ainsi qu'aux modifications des paramètres du jogging (par exemple, à un système de coordonnées modifié). S'il y a un changement, alors le système repasse à l'état 10. L'état 50 est entré sur un front descendant de l'entrée Enable. Le jogging est arrêté par MC_GroupHalt. " }, 
{ "title" : "Mise en service ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4584880854092833081221538291", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Faire du jogging avec un robot \/ Mise en service ", 
"snippet" : "Compilez et démarrez le programme créé. Vous pouvez utiliser la visualisation pour exécuter le robot. Vous pouvez définir tous les paramètres pertinents pour le déplacement manuel (par exemple, dans quel système de coordonnées le déplacement manuel est effectué et à quelle vitesse). Si vous avez ins...", 
"body" : "Compilez et démarrez le programme créé. Vous pouvez utiliser la visualisation pour exécuter le robot. Vous pouvez définir tous les paramètres pertinents pour le déplacement manuel (par exemple, dans quel système de coordonnées le déplacement manuel est effectué et à quelle vitesse). Si vous avez installé le CODESYS Depictor , il est recommandé de placer la fenêtre avec le Depictor ( Scene POU) à côté de la fenêtre de visualisation. Le Depictor représente le TCS (Tool Coordinate System) à l'avant du robot. De plus, l'axe de rotation actuel du TCS est affiché en violet. Ceci est utile pour vérifier les différents types de changement d'orientation (par exemple, tester le ABC_as_ACS l'option et la SDC système de coordonnées). " }, 
{ "title" : "Interruption et poursuite des mouvements ", 
"url" : "_sm_robotics_example_stop_continue.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Interruption et poursuite des mouvements ", 
"snippet" : "Le Robotics_Interrupt_Continue.project L'exemple de projet décrit ici se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment les mouvements commandés peuvent être interrompus avec le SMC_GroupInterrupt bloc fonctionnel et repris ultéri...", 
"body" : "Le Robotics_Interrupt_Continue.project L'exemple de projet décrit ici se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . Cet exemple montre comment les mouvements commandés peuvent être interrompus avec le SMC_GroupInterrupt bloc fonctionnel et repris ultérieurement avec le SMC_GroupContinue bloc fonctionnel. Le groupe d'axes peut effectuer n'importe quel mouvement entre interruption et continuation. " }, 
{ "title" : "Structure de la candidature ", 
"url" : "_sm_robotics_example_stop_continue.html#UUID-0303b007-363c-c1b9-a999-ee926c8f8deb_section-idm4519127872464034232302809299", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Interruption et poursuite des mouvements \/ Structure de la candidature ", 
"snippet" : "L'application consiste en une simple machine à états dans le PLC_PRG programme et une trace pour suivre facilement les transitions d’état. Tout d'abord, les axes et le groupe d'axes sont activés. ( STATE_POWER_ON ) Puis, deux mouvements, moveLinearA et moveLinearB , sont commandés avec le mélange. (...", 
"body" : "L'application consiste en une simple machine à états dans le PLC_PRG programme et une trace pour suivre facilement les transitions d’état. Tout d'abord, les axes et le groupe d'axes sont activés. ( STATE_POWER_ON ) Puis, deux mouvements, moveLinearA et moveLinearB , sont commandés avec le mélange. ( STATE_START_MOVING ) Dès que le deuxième mouvement est actif (lorsque le mixage commence), le mouvement est interrompu. La cause pourrait être, par exemple, qu'un défaut d'outil ait été détecté. (STATE_INTERRUPT ) Un mouvement PTP relatif est effectué dans la direction Z positive, par exemple pour remplacer l'outil après le défaut. (STATE_INTERMEDIATE_MOVEMENT ) Avant de reprendre, le système revient à la position où le mouvement initial a été interrompu. ( STATE_GET_CONTINUE_POS \/ STATE_MOVE_TO_CONTINUE_POS ) Le mouvement initial est repris. (STATE_CONTINUE) " }, 
{ "title" : "Usage ", 
"url" : "_sm_robotics_example_stop_continue.html#UUID-0303b007-363c-c1b9-a999-ee926c8f8deb_section-idm4586020725065634232302901331", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Interruption et poursuite des mouvements \/ Usage ", 
"snippet" : "Compilez le programme créé et connectez-vous. Pour suivre les différents états, vous pouvez télécharger la trace sur le contrôleur. Démarrez l'application....", 
"body" : "Compilez le programme créé et connectez-vous. Pour suivre les différents états, vous pouvez télécharger la trace sur le contrôleur. Démarrez l'application. " }, 
{ "title" : "Programmer un robot avec Pick&Place ", 
"url" : "_sm_example_robotics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Programmer un robot avec Pick&Place ", 
"snippet" : "Voir le Robotics_PickAndPlace.project et Robotics_PickAndPlace_without_Depictor.project exemples de projets dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . le Robotics_PickAndPlace.project et Robotics_PickAndPlace_without_Depictor.project les exemples de p...", 
"body" : "Voir le Robotics_PickAndPlace.project et Robotics_PickAndPlace_without_Depictor.project exemples de projets dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . le Robotics_PickAndPlace.project et Robotics_PickAndPlace_without_Depictor.project les exemples de projets se trouvent dans le répertoire d'installation ...\\CODESYS\\Projects\\SoftMotion\\<version>\\Examples . le Robotics_PickAndPlace.project projet nécessite la CODESYS Depictor Package Depictor à installer. Ce projet affiche la cinématique dans une animation 3D. Le projet Robotics_PickAndPlace_without_Depictor.project montre une forme simplifiée de la séquence dans un écran de visualisation. Ce chapitre ne couvre que les objets qui sont pertinents pour SoftMotion . L'exemple se compose d'un trépied, d'une table rotative et d'un convoyeur. La cinématique reprend un anneau qui se trouve sur la table rotative. Lors du ramassage, le plateau porte-outils de la cinématique se déplace de manière synchrone avec la table rotative. Ensuite, l'anneau est placé sur un cône situé sur une bande transporteuse. Lors de la pose, la cinématique se déplace de manière synchrone avec la bande transporteuse. Deux boutons sont situés sur l'écran de visualisation pour contrôler la séquence. Lorsque vous appuyez sur le Auto bouton, les anneaux sont déposés automatiquement. Sinon, le Jouer Le bouton apparaît pour vous permettre de placer la bague. Blocs fonctionnels : MC_TrackConveyorBelt et MC_TrackRotaryTable le MC_TrackRotaryTable bloc fonction, qui est appelé dans le Ring bloc fonction, est utilisé pour déterminer le PCS_1 système de coordonnées partiel. Ce système de coordonnées est défini lorsqu'un anneau est placé sur la table rotative. L'origine du système de coordonnées de la table rotative RotaryTableOrigin est le milieu de la table rotative. L'axe Z est l'axe de rotation de la table rotative. Le PCS_1 est tourné autour de l'axe Z du système de coordonnées de la table rotative en fonction de la variable d'entrée RotaryTable . Comme le groupe d'axes se déplace dans PCS_1, il suit la rotation de la table. Le comportement est similaire au MC_TrackConveyorBelt bloc fonction, qui est appelé dans le Cone bloc fonctionnel. Dans ce cas, le PCS ( PCS_2 ) suit l'axe X du système de coordonnées ConveyorBeltOrigin . " }, 
{ "title" : "Structure du projet ", 
"url" : "_sm_example_robotics.html#UUID-39569b76-aa01-d4da-f1dd-395ea28c5771_id_e806d396dc0abefc0a864632a6f2305_id_9645ebb75a1273b0c0a8640e01c9af58", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Programmer un robot avec Pick&Place \/ Structure du projet ", 
"snippet" : "CODESYS SoftMotion Manette Groupe d'axes Trépied : Le groupe d'axes définit la cinématique et la correspondance avec les axes individuels Trépied1 , Trépied2 , et Trépied3 . DepictorCalculs (PRG) , Environnement (PRG) , Anneau (FB) : Programmes pour contrôler la séquence complète et la visualisation...", 
"body" : "CODESYS SoftMotion Manette Groupe d'axes Trépied : Le groupe d'axes définit la cinématique et la correspondance avec les axes individuels Trépied1 , Trépied2 , et Trépied3 . DepictorCalculs (PRG) , Environnement (PRG) , Anneau (FB) : Programmes pour contrôler la séquence complète et la visualisation. Ces POU ne sont pas pertinents pour la compréhension des blocs PLCopen, à l'exception de la définition du système de coordonnées du produit (PCS_1 et PCS_2). Robot (PRG) : Programme de contrôle des séquences de mouvement. Une description détaillée se trouve dans le paragraphe suivant. Visualisation : Visualisation animée pour clarifier la séquence. Trépied1 , Trépied2 , Trépied3 : Axes linéaires du trépied. DriveRotaryTable : Axe pour la table rotative. Convoyeur à courroie d'entraînement : Axe pour la bande transporteuse. " }, 
{ "title" : "Structure de la Robot (PRG) programme séquentiel ", 
"url" : "_sm_example_robotics.html#UUID-39569b76-aa01-d4da-f1dd-395ea28c5771_id_e806d396dc0abefc0a864632a6f2305_id_d2b72ec95a1273b5c0a8640e012cc527", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Programmer un robot avec Pick&Place \/ Structure de la Robot (PRG) programme séquentiel ", 
"snippet" : "Les Robot (PRG) programme est exécuté en cycles. A ce stade, les étapes individuelles sont exécutées en fonction de la state . A la fin d'un programme, les appels de tous les blocs fonction utilisés sont prêts pour la commande de mouvement. Les axes simples du trépied sont activés (blocs fonction pw...", 
"body" : "Les Robot (PRG) programme est exécuté en cycles. A ce stade, les étapes individuelles sont exécutées en fonction de la state . A la fin d'un programme, les appels de tous les blocs fonction utilisés sont prêts pour la commande de mouvement. Les axes simples du trépied sont activés (blocs fonction pwA1 , pwA2 , et pwA3 de genre MC_Power ). CASE 0 : Attendez que les axes participants soient opérationnels. CASE 10 : définit les positions de référencement ; dans les applications physiques, le référencement est effectué à cette position (blocs fonction spA1 , spA2 , et spA3 de genre MC_SetPosition ). CASE 20 : Placement du système de coordonnées machine dans le système de coordonnées universel (bloc fonction setCoord de genre MC_SetCoordinateTransform ). CASE 30 : Libération du groupe d'axes (bloc fonction enable de genre MC_GroupEnable . Attendez une réponse indiquant que le groupe d'axes a appliqué toutes les valeurs. CASE 40 à CASE 130 : Application Pick&Place : Tous les mouvements sont commandés éventuellement avec plusieurs instances MC_MoveDirectAbsolute , MC_MoveDirectRelative , et MC_MoveLinear qui sont appelés en cycles. Un front montant au Execute l'entrée de ces POU dans chaque état conduit à émettre une nouvelle commande de mouvement dans laquelle la sortie bCommandAccepted indique le succès du processus. Une chaîne typique de commandes résulte de l'interrogation de cette sortie avant la prochaine commande de mouvement. " }, 
{ "title" : "Modèle de robot dynamique ", 
"url" : "_sm_dynamic_robot_model.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Modèle de robot dynamique ", 
"snippet" : "Voir le Robotics_DynamicModel.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Afin de limiter les couples\/forces de l'axe pendant un mouvement, un modèle dynamique est nécessaire qui calcule ces valeurs à partir de l'état actuel d...", 
"body" : "Voir le Robotics_DynamicModel.project exemple de projet dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples . Afin de limiter les couples\/forces de l'axe pendant un mouvement, un modèle dynamique est nécessaire qui calcule ces valeurs à partir de l'état actuel de l'axe (position, vitesse et accélération). Cet exemple comprend les pièces suivantes : La première partie montre comment utiliser un modèle dynamique existant dans une application et les résultats de quelques exemples de mouvements. La partie 2 montre comment créer un modèle dynamique pour un robot SCARA basé sur un algorithme présenté dans le livre \"Modern Robotics\" de KM Lynch et FC Park. " }, 
{ "title" : "Structure de la demande ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4640407923376033369958289569", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Modèle de robot dynamique \/ Structure de la demande ", 
"snippet" : "Partie 1 : Utiliser un modèle dynamique dans une application Le code de cette pièce se trouve dans le TorqueLimitationDemo dossier. PLC_PRG est le programme principal, qui comprend une machine à états qui déclenche des mouvements de test. Les mouvements peuvent être surveillés à l'aide du Trace . Pa...", 
"body" : "Partie 1 : Utiliser un modèle dynamique dans une application Le code de cette pièce se trouve dans le TorqueLimitationDemo dossier. PLC_PRG est le programme principal, qui comprend une machine à états qui déclenche des mouvements de test. Les mouvements peuvent être surveillés à l'aide du Trace . Partie 2 : Création d'un modèle de robot dynamique Le code du modèle dynamique se trouve dans le DynModel dossier. DynModel_Scara2_Z est le modèle dynamique du robot SCARA. DynModel_Tests exécute tous les tests de Test_DynModel_Scara2_Z pour vérifier les erreurs courantes. Le modèle dynamique est basé sur un robot SCARA avec deux articulations tournantes et un axe Z prismatique. Une figure du robot avec les dimensions et les systèmes de coordonnées requis pour le modèle dynamique est illustrée ci-dessous : Dimension dans la figure Nom de variable correspondant dans l'exemple de projet dans le bloc fonction DynModel_Scara2_Z h0 baseHeight h1 armOneHeight h2 armTwoHeight h3 zAxisLength h4 zAxisOffset l1 armOneLength l1 armTwoLength " }, 
{ "title" : "Partie 1 : Utiliser un modèle dynamique dans une application ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4592064830952033369979173999", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Modèle de robot dynamique \/ Partie 1 : Utiliser un modèle dynamique dans une application ", 
"snippet" : "L'utilisation d'un modèle dynamique dans une application nécessite un modèle qui implémente ISMDynamics interface de la SM3_Dynamics bibliothèque. Le modèle dynamique de Partie 2 : Création d'un modèle de robot dynamique est utilisé pour cette démonstration. Le modèle peut être affecté à un groupe d...", 
"body" : "L'utilisation d'un modèle dynamique dans une application nécessite un modèle qui implémente ISMDynamics interface de la SM3_Dynamics bibliothèque. Le modèle dynamique de Partie 2 : Création d'un modèle de robot dynamique est utilisé pour cette démonstration. Le modèle peut être affecté à un groupe d'axes à l'aide de SMC_GroupSetDynamics . Cette étape nécessite la mise en place de l'accélération gravitationnelle par rapport au MCS. Parce que le SCARA dans cet exemple est monté sur le sol, l'accélération gravitationnelle pointe dans la direction z0 positive. L'accélération gravitationnelle doit être spécifiée en unités utilisateur u\/s². Étant donné que toutes les longueurs dans cet exemple ont été définies dans l'unité utilisateur m, l'accélération gravitationnelle doit également être spécifiée en m\/s². SMC_ChangeDynamicLimits peut être utilisé pour ajuster les limites de chaque axe. Notez que le groupe d'axes doit être réactivé à l'aide de MC_GroupEnable afin d'activer les nouvelles limites dynamiques. Si des masses supplémentaires sont ajoutées au TCP (par exemple, un outil ou un objet qui est ramassé par le robot), alors SMC_GroupSetLoad peut être utilisé pour définir la charge. La PLC_PRG programme contient tous les composants ci-dessus et exécute deux mouvements de test : Mouvement 1 Mouvement 2 Mouvement droit du bras de (a0=0°, a1=0°, a2=0 m) à (a0=90°, a1=0°, a2=0,02 m) : Mouvement angulaire du bras de (a0=0°, a1=-120°, a2=0 m) à (a0=90°, a1=-120°, a2=0,02 m) : Chaque mouvement est exécuté trois fois de suite avec les conditions aux limites suivantes : La limite de couple de tous les axes est infinie (illimitée). La limite de couple du bras 2 est réglée sur une valeur inférieure au couple maximal atteint pendant un mouvement illimité. La valeur a été fixée arbitrairement à 2 Nm . La limite de couple du bras 2 est toujours 2 Nm , et en plus une charge a été appliquée au TCP ( mLoad=3 kg , lLoad=0.2 m ): Le calcul de l'inertie de la charge a été simplifié grâce à l'utilisation de tiges fines : Les mouvements peuvent être surveillés dans la trace. Le mouvement 1 a les résultats suivants : Même si le bras 2 ne bouge pas pendant le mouvement 1, le mouvement du bras 1 entraîne un couple pour le bras 2 pendant l'accélération\/la décélération. Le couple calculé est envoyé au variateur et peut potentiellement améliorer la boucle du régulateur en mode régulateur SMC_velocity ou SMC_position . Ceci est également appelé commande anticipatrice de couple. La deuxième exécution avec un couple limité montre que même si le bras 2 ne bouge pas, une limite de couple pour le bras 2 ralentit le mouvement du bras 1. Sans le modèle dynamique, l'accélération et la décélération du bras 1 devraient être réduites manuellement pour cela. mouvement afin d'éviter une contrainte mécanique excessive sur le bras 2. La troisième course avec une charge ralentit encore plus le mouvement du bras 1 afin de ne pas violer la limite de couple du bras 2. Les avantages de l'utilisation d'un modèle dynamique sont évidents. Pour éviter des contraintes mécaniques excessives sans modèle dynamique : Soit les limites dynamiques pour chaque mouvement devraient être définies en fonction de l'état actuel du robot. Ou les limites dynamiques de tous les axes devraient être réduites de telle manière que tous les mouvements potentiels n'entraîneront pas de contraintes mécaniques excessives sur aucun axe. La première méthode est une tâche complexe et il peut être difficile de calculer des limites raisonnables, tandis que la seconde méthode entraîne des mouvements qui ne sont pas aussi rapides que possible la plupart du temps. Ces inconvénients n'existent plus avec un modèle dynamique car le robot se déplace toujours le plus vite possible tout en respectant les limites mécaniques de chaque axe. Ces avantages sont illustrés par les résultats du Mouvement 2 : En raison de l'angle du bras 2, le couple résultant du bras 2 est considérablement inférieur à celui du mouvement 1. Par conséquent, les trois courses ne sont jamais limitées par le couple de l'axe. Si l'on avait utilisé des limites dynamiques ajustées basées sur le mouvement 1 (accélération et décélération réduites afin de ne pas violer la limite de couple du bras 2), alors ce mouvement aurait été plus lent que nécessaire. " }, 
{ "title" : "Partie 2 : Création d'un modèle de robot dynamique ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4583105024958433369980945572", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Modèle de robot dynamique \/ Partie 2 : Création d'un modèle de robot dynamique ", 
"snippet" : "Le modèle qui est créé dans cet exemple est basé sur un algorithme pour les robots à chaîne ouverte tel que présenté dans le livre \"Modern Robotics\" de KM Lynch et FC Park (voir chapitre 8 \"Dynamique des chaînes ouvertes\"). L'explication de cet algorithme sort du cadre de cet exemple. Au lieu de cel...", 
"body" : "Le modèle qui est créé dans cet exemple est basé sur un algorithme pour les robots à chaîne ouverte tel que présenté dans le livre \"Modern Robotics\" de KM Lynch et FC Park (voir chapitre 8 \"Dynamique des chaînes ouvertes\"). L'explication de cet algorithme sort du cadre de cet exemple. Au lieu de cela, l'exemple se concentre sur la façon de définir les valeurs d'entrée de l'algorithme. Simplifications Pour rendre cet exemple plus compréhensible, quelques simplifications ont été faites : Les longueurs de bras l1 et l2 (distance entre les axes de rotation) sont utilisées comme longueur de bras totale respective. Le centre de masse est toujours situé au centre géométrique de chaque maillon. Les matrices d'inertie spatiale des bras et de l'axe Z sont calculées pour des tiges minces. Exigences du modèle dynamique Afin d'utiliser le modèle dynamique dans une application SoftMotion, ce modèle doit implémenter le ISMDynamics interface du SM3_Dynamics bibliothèque. La position zéro, les systèmes de coordonnées et le sens de rotation positif du modèle dynamique peuvent théoriquement s'écarter du modèle cinématique. Cependant, ces différences doivent être prises en considération, et pour simplifier le modèle dynamique, il est donc recommandé d'utiliser les définitions du modèle cinématique. Étant donné que le modèle dynamique doit calculer les valeurs de couple en Nm et les forces en N, il doit convertir l'unité utilisateur u pour les longueurs en unités SI m. Le facteur de conversion peut être défini par SMC_GroupSetUnits et est inclus dans le addParams entrée de ISMDynamics.AxesStateToTorque . Cet exemple utilise uniquement m pour les longueurs et peut donc ignorer le facteur de conversion. Spécification des données géométriques et dynamiques du modèle L'implémentation CEI de l'algorithme présenté dans le livre \"Modern Robotics\" de KM Lynch et FC Park (voir chapitre 8 \"Dynamics of Open Chains\") nécessite les valeurs d'entrée suivantes : La position du centre de masse de chaque maillon lorsque le robot est en position d'origine. La position est spécifiée dans le système de coordonnées du lien précédent (le premier lien est spécifié par rapport au système de coordonnées de base). La matrice d'inertie spatiale et la masse de chaque lien, exprimées dans le cadre de lien respectif. L'axe de vis de chaque joint, exprimé dans le cadre de base. Positions du centre de gravité Les cadres avec la position du centre de masse de chaque maillon sont les suivants : Lien Cadre Bras 1 Le centre de masse du bras 1, exprimé dans le système de coordonnées de base x 0 , y 0 ,z 0 : Notez qu'il y a une rotation de 180° autour de l'axe x0. Bras 2 Le centre de masse du bras 2, exprimé dans le système de coordonnées du bras 1 : Axe z Le centre de masse de l'axe Z exprimé dans le système de coordonnées du bras 2 : Point central de l'outil (TCP) Un cadre supplémentaire pour gérer une charge arbitraire au TCP (par exemple, par un outil, un produit ou une combinaison des deux), exprimée dans le système de coordonnées de l'axe Z : Matrices d'inertie spatiale Les valeurs d'inertie spatiale doivent être exprimées dans le cadre de liaison respectif. Puisque les cadres sont définis au centre de masse, l'inertie spatiale peut être représentée par une matrice d'inertie de rotation 3x3 et la masse du corps. Avec la simplification de l'utilisation de tiges minces pour les articulations, les composants de la matrice d'inertie de rotation sont les suivants : Lien Matrice d'inertie spatiale Bras 1, Bras 2 Bras 1 et Bras 2 avec leur masse correspondante m1 et m2 , et la longueur l1 et l2 : Axe z Axes à vis Les axes de vis de tous les assemblages doivent être exprimés par rapport au système de coordonnées de base x 0 , y 0 ,z 0 . Lien Vis Axe Bras 1 Imaginez une plaque tournante tournant autour de l'articulation 1 dans le sens positif avec une vitesse angulaire de 1 rad\/s. Exprimé dans le système de coordonnées de base, il s'agit d'une rotation positive autour de z 0 -axe selon la règle de la main droite : Étant donné que l'axe de rotation du bras 1 est égal au centre du système de coordonnées de base, la vitesse linéaire est nulle : Bras 2 Encore une fois, imaginez une plaque tournante tournant autour de l'articulation 2 dans le sens positif avec une vitesse angulaire de 1 rad\/s, qui est affichée en vue de dessus du bras 1 dans la figure suivante : Comme pour le bras 1, la vitesse angulaire est : La figure montre la vitesse linéaire résultante v 2,y , qui pointe vers moins y 0 direction et est égal à v 2,y =-ω 2,z * l 1 . Axe z L'axe Z est un axe prismatique pour lequel les règles suivantes s'appliquent : Le vecteur vitesse angulaire ω est nul. Le vecteur vitesse linéaire est un vecteur unitaire dans le sens de la translation positive. Cela conduit aux vecteurs suivants, exprimés dans le système de coordonnées de base x 0 , y 0 ,z 0 : Essais Le modèle dynamique peut maintenant être testé car tous les paramètres du modèle sont définis. Cette section comprend quelques tests de base du modèle. Vérification des axes de vis Un axe à vis S avec vitesse angulaire ω et vitesse linéaire v peut être exprimée comme un élément de se(3) : Une transformation en avant T peut être exécuté avec les axes à vis S , un cadre effecteur terminal M pour la position zéro du robot, et l'angle d'articulation θ de chaque articulation : L'exemple de projet comprend déjà une fonction qui résout cette équation (voir SMC_OpenChainKinematics_SolveForward ). Pour plus de détails, voir le livre \"Modern Robotics\" de KM Lynch et FC Park. En utilisant l'équation de transformation directe, on peut maintenant exécuter un test avec des positions d'axe connues et vérifier si la transformation conduit au résultat attendu. Vérification du calcul du couple à l'arrêt Pour vérifier les repères de position du centre de masse, vous pouvez calculer manuellement le couple d'axe résultant à l'arrêt pour des positions d'axe données et les comparer aux valeurs calculées par le modèle. Étant donné que cet exemple est basé sur un robot SCARA monté au sol, toutes les positions des axes à l'arrêt conduiront aux mêmes couples ou forces des entraînements : Découper Couple\/Force résultant Bras 1 Le bras 1 étant un axe de révolution, le résultat est un couple : M1=0 Nm . Bras 2 Le bras 2 étant un axe de révolution, le résultat est un couple : M2=0 Nm . Axe z Comme l'axe Z est un axe prismatique, le résultat est une force : F3=m3*g N avec accélération gravitationnelle g . " }, 
{ "title" : "Cinématique personnalisée ", 
"url" : "_sm_example_custom_robotics_kinematic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Cinématique personnalisée ", 
"snippet" : "Voir le PLCopenSingle2.project exemple de projet et le CustomKinematics.library bibliothèque dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples. Cet exemple décrit comment créer une bibliothèque avec une transformation cinématique personnalisée ( Gantry3C ) et ...", 
"body" : "Voir le PLCopenSingle2.project exemple de projet et le CustomKinematics.library bibliothèque dans le répertoire d'installation de CODESYS en dessous de ..\\CODESYS SoftMotion\\Examples. Cet exemple décrit comment créer une bibliothèque avec une transformation cinématique personnalisée ( Gantry3C ) et comment utiliser cette bibliothèque dans un projet de contrôle du robot. Le Gantry3C La transformation cinématique se compose de 3 axes linéaires (X, Y et Z) qui portent une tête d'outil. La tête d'outil est constituée d'un axe supplémentaire qui porte un outil monté. La tête de l'outil peut être tournée autour de l'axe Z. " }, 
{ "title" : "1. Créez un nouveau projet de bibliothèque ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_3b0657d06b6990f1c0a8646379b25f1e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Cinématique personnalisée \/ 1. Créez un nouveau projet de bibliothèque ", 
"snippet" : "Créez un nouveau projet avec le Bibliothèque vide modèle....", 
"body" : "Créez un nouveau projet avec le Bibliothèque vide modèle. " }, 
{ "title" : "2. Ajoutez un gestionnaire de bibliothèque. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_0125d98b6b6990f1c0a8646339c29917", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Cinématique personnalisée \/ 2. Ajoutez un gestionnaire de bibliothèque. ", 
"snippet" : "Ajoutez un gestionnaire de bibliothèque au POU voir. Ajouter le SM3_Transformation , SM3_Math , et SM3_Error bibliothèques au gestionnaire de bibliothèques....", 
"body" : "Ajoutez un gestionnaire de bibliothèque au POU voir. Ajouter le SM3_Transformation , SM3_Math , et SM3_Error bibliothèques au gestionnaire de bibliothèques. " }, 
{ "title" : "3. Créez le bloc fonction Gantry3C. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_b156dbec6b6990f1c0a86463322b661a", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Cinématique personnalisée \/ 3. Créez le bloc fonction Gantry3C. ", 
"snippet" : "Ce bloc fonction implémente les interfaces MC_KIN_REF_SM3 et ISMKinematicsWithInfo2 de la bibliothèque SM3_Transformation . Vous pouvez définir un décalage en entrée pour chaque axe. Ce décalage est soustrait avant la transformation directe et ajouté après la transformation inverse. Exemple de Gantr...", 
"body" : "Ce bloc fonction implémente les interfaces MC_KIN_REF_SM3 et ISMKinematicsWithInfo2 de la bibliothèque SM3_Transformation . Vous pouvez définir un décalage en entrée pour chaque axe. Ce décalage est soustrait avant la transformation directe et ajouté après la transformation inverse. Exemple de Gantry3C avec deux cinématiques découplées et KinCoupled : FUNCTION_BLOCK Custom_Kin_Gantry3 IMPLEMENTS ISMPositionKinematics\nFUNCTION_BLOCK Custom_Kin_CAxis IMPLEMENTS ISMOrientationKinematics\n\nFUNCTION_BLOCK Custom_Kin_Gantry3C EXTENDS Kin_Coupled Fournir les blocs fonction Custom_Kin_Gantry3 et Custom_Kin_CAxis comme entrées pour le bloc fonction Kin_Coupled lors de l'initialisation. Maintenant Custom_Kin_Gantry3C devient une cinématique couplée combinant les cinématiques de position et d'orientation. " }, 
{ "title" : "4. Implémentez les méthodes de l'interface MC_KIN_REF_SM3 et la propriété NumAxes4. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_f0953a666b6990f1c0a864632a54ddd5", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Cinématique personnalisée \/ 4. Implémentez les méthodes de l'interface MC_KIN_REF_SM3 et la propriété NumAxes4. ", 
"snippet" : "AxesToCartesian : Cinématique avant : Calcul de la position et de l'orientation à partir des valeurs des axes. CartesianToAxes : Cinématique inverse : Calcul des valeurs des axes à partir de la position et de l'orientation. NumAxes : Nombre d'axes de la cinématique...", 
"body" : "AxesToCartesian : Cinématique avant : Calcul de la position et de l'orientation à partir des valeurs des axes. CartesianToAxes : Cinématique inverse : Calcul des valeurs des axes à partir de la position et de l'orientation. NumAxes : Nombre d'axes de la cinématique " }, 
{ "title" : "5. Implémentez les méthodes des interfaces ISMKinematicsWithInfo2 et ISMKinematicsWithInfo. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_cd5f17f76b6990f1c0a86463705dcfa1", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Cinématique personnalisée \/ 5. Implémentez les méthodes des interfaces ISMKinematicsWithInfo2 et ISMKinematicsWithInfo. ", 
"snippet" : "GetAxisProperties : propriétés, telles que le type d'axe. Les limites pour chaque axe peuvent être définies. GetKinematicsName : Nom de la cinématique IsSingularity : Peut être ignoré pour cette cinématique...", 
"body" : "GetAxisProperties : propriétés, telles que le type d'axe. Les limites pour chaque axe peuvent être définies. GetKinematicsName : Nom de la cinématique IsSingularity : Peut être ignoré pour cette cinématique " }, 
{ "title" : "6. Spécifiez les informations du projet. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_2f5ca72b6b6990f1c0a864634f9c8dd7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Cinématique personnalisée \/ 6. Spécifiez les informations du projet. ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "7. Vérifiez la bibliothèque pour les erreurs de compilateur. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_24eaad936b6990f1c0a864633896924b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Cinématique personnalisée \/ 7. Vérifiez la bibliothèque pour les erreurs de compilateur. ", 
"snippet" : "Pour consulter la bibliothèque, cliquez sur Construire → Vérifier tous les objets du pool ....", 
"body" : "Pour consulter la bibliothèque, cliquez sur Construire → Vérifier tous les objets du pool . " }, 
{ "title" : "8. Créez la description dans le configurateur de groupe d'axes. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_51fd948a6c11885ac0a8646354b16b84", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Cinématique personnalisée \/ 8. Créez la description dans le configurateur de groupe d'axes. ", 
"snippet" : "Pour créer la description, vous devez d'abord installer CODESYS Library Documentation Support module complémentaire. Ce module complémentaire contient le programme libdoc.exe qui est requis dans les instructions suivantes. Le module complémentaire peut être installé via CODESYS Installer . Lorsque l...", 
"body" : "Pour créer la description, vous devez d'abord installer CODESYS Library Documentation Support module complémentaire. Ce module complémentaire contient le programme libdoc.exe qui est requis dans les instructions suivantes. Le module complémentaire peut être installé via CODESYS Installer . Lorsque le POU a l'attribut sm_kin_libdoc , le commentaire spécifié dans le bloc fonction est utilisé dans le configurateur de groupe d'axes comme description de la cinématique. Le formatage de texte restructuré est utilisé pour cela. Pour générer la description de la cinématique à partir des commentaires du bloc fonction dans l'éditeur de groupes d'axes, procédez comme suit : Inclure l'attribut sm_kin_libdoc comme le montre l'image ci-dessus. Inclure les propriétés de projet requises DocFormat et DocLanguages (dans la boîte de dialogue d'informations sur le projet) liés à la documentation de la bibliothèque. Résultat: Assurez-vous que le répertoire d'installation de CODESYS contient le libdoc.exe fichier exécutable (répertoire : ...\\DocScripting\\3.5.xx.0 \\). Téléchargez le convertisseur wkhtmltox 32 bits avec la version 0.12.5 ou inférieure à partir de https:\/\/wkhtmltopdf.org\/downloads.html . Extraire le wkhtmltox.dll fichier et copiez-le dans ...\\\\DocScripting\\\\3.5.xx.0\\\\bin dans le CODESYS répertoire d'installation. Depuis wkhtmltox.dll ne prend plus en charge les images par défaut dans la version 0.12.6 et supérieure, vous devez utiliser la version 0.12.5 ou inférieure. Créer la variable système LIBDOC_CODESYS dans Windows. Définissez la valeur sur le chemin du fichier de CODESYS.exe . Assurez-vous de spécifier le nom du chemin et le nom du profil entre guillemets doubles. Résultat: Enregistrez, fermez et rouvrez le projet de bibliothèque. Cliquez sur Fichier → Enregistrer le projet en tant que bibliothèque compilée . La bibliothèque compilée sera installée dans le projet qui utilise cette cinématique. " }, 
{ "title" : "Utilisation de la bibliothèque dans un projet (CustomKinematics_Implementation.project) ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_3c747e2a6b6990f1c0a864637a72fb84", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Cinématique personnalisée \/ Utilisation de la bibliothèque dans un projet (CustomKinematics_Implementation.project) ", 
"snippet" : "Le projet montre comment utiliser et contrôler la cinématique créée dans la section précédente en faisant du jogging ou en commandant un mouvement. Créer un CODESYS projet standard avec le CODESYS SoftMotion Win manette. Ouvrez le gestionnaire de bibliothèque et installez la bibliothèque CustomKinem...", 
"body" : "Le projet montre comment utiliser et contrôler la cinématique créée dans la section précédente en faisant du jogging ou en commandant un mouvement. Créer un CODESYS projet standard avec le CODESYS SoftMotion Win manette. Ouvrez le gestionnaire de bibliothèque et installez la bibliothèque CustomKinematics.compiled-library (créé dans la section précédente) contenant la cinématique Gantry3C. Ajoutez la bibliothèque au gestionnaire de bibliothèque. Ajoutez un objet groupe d'axes et sélectionnez le KinCustom.Gantry3C cinématique. Résultat: Ajoutez 4 axes virtuels au Pool d'axes généraux SoftMotion pool d'axes dans l'arborescence des périphériques. (DriveX, Y, Z et C) Ouvrez le configurateur de groupe d'axes. Dans le Mappage aux axes section, mappez les axes à leurs champs respectifs. Résultat: Le programme Prg_Visu est le programme principal qui contrôle le groupe d'axes. Au démarrage de l'application, Prg_Visu met le groupe d'axes sous tension et l'active. De plus, il appelle tous les blocs fonctionnels nécessaires pour contrôler le groupe d'axes (mouvements pas à pas, linéaires et PTP). Tous ces mouvements peuvent être contrôlés à partir de la visualisation jointe. Résultat: Bloc fonctionnel : Jog : Ce FB combine le jogging dans l'espace des axes ainsi que dans l'espace cartésien. Il utilise deux instances de SMC_GroupJog2 . L’un concerne l’espace des axes et l’autre l’espace cartésien. Ce bloc fonction peut être utilisé avec les modèles de visualisation V_RobotPosition_axes et V_RobotPosition_cart_Jog pour déplacer n'importe quelle cinématique dans l'espace cartésien et axial. Résultat: FB SMC_TRAFOF_Gantry3C : Ce bloc fonction transforme les valeurs d'axe d'entrée d'une cinématique Gantry3C en ses valeurs TCP respectives. De plus, les valeurs des axes sont normalisées afin qu'elles puissent être utilisées avec le modèle de visualisation TRAFOF_Gantry3C_YZ visualiser les mouvements de la cinématique. Résultat: Compilez et exécutez l'application. Ouvrez la visualisation. Vous pouvez piloter le robot aussi bien dans l'espace des axes que dans l'espace cartésien. Il existe également des modèles de visualisation pour commander un mouvement linéaire ou PTP. Résultat: L'exemple décrit ici traite des axes de positionnement et d'orientation dans un bloc fonctionnel commun. De nombreuses cinématiques peuvent comprendre deux cinématiques partielles découplées : une cinématique de positionnement (delta, portique, etc.) et une cinématique d'orientation (outils comme l'axe C, le poignet2, le poignet3, etc.). Les deux cinématiques sont reliées entre elles au \"point de bride\", le TCP de la cinématique de positionnement. La cinématique d'orientation se caractérise par le fait qu'elle est capable de calculer le vecteur du point de bride au TCP de la cinématique couplée. Le calcul se fait en utilisant uniquement l'orientation de ce TCP (c'est-à-dire qu'il est indépendant de la cinématique de positionnement ou indépendant de l'orientation du point d'aile). La cinématique de positionnement doit à son tour pouvoir déterminer ses positions d'axe à partir de la seule position du point d'aile. Il ne doit pas dépendre de l'orientation du point de bride. Dans ce cas, vous pouvez recourir à des interfaces telles que ISMPositionKinematics ou ISMOrientationKinematics . Pour implémenter ces interfaces, définissez un bloc fonction à implémenter ISMPositionKinematics et un autre bloc fonctionnel à implémenter ISMOrientationKinematics . Enfin, définissez un bloc fonction qui étend le bloc fonction Kin_Coupled (depuis SM3_Transformation ) avec les blocs fonctionnels définis précédemment comme entrées. Pour plus d'informations, consultez : Création de cinématiques personnalisées" }, 
{ "title" : "Utilisation de Depictor pour visualiser les groupes d'axes ", 
"url" : "_sm_example_axis_group_depictor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Utilisation de Depictor pour visualiser les groupes d'axes ", 
"snippet" : "Pour ce projet, vous avez également besoin du CODESYS Depictor add-on avec une licence valide. L'application SoftMotion se compose de quatre entraînements rotatifs configurés en groupe d'axes. Les trois premiers axes déplacent le TCP dans le plan X\/Y et le quatrième axe dans le plan Z. L'exemple mon...", 
"body" : "Pour ce projet, vous avez également besoin du CODESYS Depictor add-on avec une licence valide. L'application SoftMotion se compose de quatre entraînements rotatifs configurés en groupe d'axes. Les trois premiers axes déplacent le TCP dans le plan X\/Y et le quatrième axe dans le plan Z. L'exemple montre comment vous pouvez utiliser Depictor avec la configuration cinématique Kin_Scara3_Z. Vous pouvez également personnaliser la même procédure pour d'autres configurations cinématiques. Démarrer et tester le programme Vous pouvez modifier les valeurs des axes dans la visualisation du projet. Si vous commentez la commande de mouvement active ( MoveAbs... , ...) dans le programme PLC_PRG et supprimez les commentaires de la deuxième commande de déplacement, vous pouvez alors modifier les coordonnées cartésiennes. Générez le projet et téléchargez-le dans l'automate. Ouvrez l'éditeur de l'objet Depictor dans votre projet. Basculez vers la visualisation et modifiez les valeurs des axes ou les valeurs cartésiennes. Observez le mouvement du robot SCARA dans Depictor. " }, 
{ "title" : "Création du projet standard ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a87f67372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Utilisation de Depictor pour visualiser les groupes d'axes \/ Création du projet standard ", 
"snippet" : "Créez un projet standard avec le CODESYS SoftMotion Win contrôleur et le langage de programmation ST. Ajouter un gestionnaire de bibliothèque dans le POU vue. Ouvrez le gestionnaire de bibliothèque et ajoutez les bibliothèques SM3_Depictor et DepictorBase ....", 
"body" : "Créez un projet standard avec le CODESYS SoftMotion Win contrôleur et le langage de programmation ST. Ajouter un gestionnaire de bibliothèque dans le POU vue. Ouvrez le gestionnaire de bibliothèque et ajoutez les bibliothèques SM3_Depictor et DepictorBase . " }, 
{ "title" : "Ajout et paramétrage des axes ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a65c81372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Utilisation de Depictor pour visualiser les groupes d'axes \/ Ajout et paramétrage des axes ", 
"snippet" : "Insérer quatre axes virtuels sous l'objet Pool d'axes généraux SoftMotion et nommez les axes Drive1...Drive4. Paramétrer les axes Drive1, Drive2, Drive3 et Drive4 comme type d'axe fini avec des interrupteurs de fin de course logiciels de -180 degrés à 180 degrés. Éditeur de configuration : Pour plus...", 
"body" : "Insérer quatre axes virtuels sous l'objet Pool d'axes généraux SoftMotion et nommez les axes Drive1...Drive4. Paramétrer les axes Drive1, Drive2, Drive3 et Drive4 comme type d'axe fini avec des interrupteurs de fin de course logiciels de -180 degrés à 180 degrés. Éditeur de configuration : Pour plus d'informations, consultez : Conduite virtuelle" }, 
{ "title" : "Configuration des groupes d'axes ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a5e750372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Utilisation de Depictor pour visualiser les groupes d'axes \/ Configuration des groupes d'axes ", 
"snippet" : "Ajoutez un groupe d'axes \"KinScara\" sous l'application. Pour ce faire, cliquez sur Projet → Ajouter un objet → Groupe d'axes . Dans le configurateur, cliquez sur Sélectionnez la cinématique . Sélectionnez le TRAFO.Kin_Scara3_Z cinématique. Définissez les paramètres comme suit : dArmLength1 , dArmLen...", 
"body" : "Ajoutez un groupe d'axes \"KinScara\" sous l'application. Pour ce faire, cliquez sur Projet → Ajouter un objet → Groupe d'axes . Dans le configurateur, cliquez sur Sélectionnez la cinématique . Sélectionnez le TRAFO.Kin_Scara3_Z cinématique. Définissez les paramètres comme suit : dArmLength1 , dArmLength2 , dArmLength3 : 500 dDécalageA1 , dDécalageA2 , dDécalageA3 , dDécalageZ : 0 Commandez les axes comme suit : A1 : Drive1 A2 : Drive2 A3 : Drive3 Z : Drive4 Remarque : Vous pouvez faire glisser les axes directement dans le champ de saisie. Pour plus d'informations, voir : Cinématique" }, 
{ "title" : "Création du programme du contrôleur ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_26c321018be5c522c0a864636ae45467", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Utilisation de Depictor pour visualiser les groupes d'axes \/ Création du programme du contrôleur ", 
"snippet" : "Dans le PLC_PRG programme, déclarer des instances du MC_Power bloc fonctionnel pour tous les variateurs. Créé un istate variable pour le diagramme d'état. VAR Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 : MC_Power; istate: INT; END_VAR Définir un diagramme d'états transitions dans l'implé...", 
"body" : "Dans le PLC_PRG programme, déclarer des instances du MC_Power bloc fonctionnel pour tous les variateurs. Créé un istate variable pour le diagramme d'état. VAR\n Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 : MC_Power;\n istate: INT;\nEND_VAR Définir un diagramme d'états transitions dans l'implémentation. CASE istate OF\n 0:\n 1:\n 2:\nEND_CASE Activer tous les lecteurs en état 0 . 0:\n Power_Drive1(Axis:=Drive1, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive2(Axis:=Drive2, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive3(Axis:=Drive3, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive4(Axis:=Drive4, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n IF Power_Drive1.Status AND Power_Drive2.Status AND Power_Drive3.Status AND Power_Drive4.Status THEN\n istate:=istate+1;\n END_IF Lorsque les axes sont activés, activer le groupe d'axes (passer de \"désactivé\" à \"veille\"). VAR\n GroupEnable:MC_GroupEnable;\nEND_VAR\n\n1:\n GroupEnable(AxisGroup:=KinScara, Execute:=TRUE);\n IF GroupEnable.Done THEN\n istate:=istate+1;\n END_IF Déclarez et initialisez une variable pour enregistrer la valeur de consigne en coordonnées machine. Déclarer deux instances de type SMC_POS_REF pour représenter le TCP en coordonnées cartésiennes et d'axe. VAR\n Frame: MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & orientation of the TCP\n Pos_Cart: SMC_POS_REF; \/\/ This variable represents the position of the TCP in cartesian coordinates coordinates\n Pos_Axis: SMC_POS_REF := (a := axispos);\/\/ This variable represents the position of the TCP in Axis coordinates\nEND_VAR\nVAR CONSTANT\n axispos: TRAFO.AXISPOS_REF := (a0 := 0, a1 := 100, a2:=60);\nEND_VAR\n\n2:\n Pos_Cart.c:= Frame; \/\/ To represent the TCP in cartesian coordinates; Déclarer une instance de MC_MoveDirectAbsolute pour déplacer le robot SCARA aux coordonnées spécifiées. VAR\n MoveAbs:MC_MoveDirectAbsolute; \/\/ Moves the TCP to the defined coordinates\nEND_VAR\n\n2:\n MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Axis,CoordSystem:=SMC_COORD_SYSTEM.ACS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined Axis coordinates\n \/\/MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Cart,CoordSystem:=SMC_COORD_SYSTEM.MCS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined cartesian coordinates\n\n IF MoveAbs.Done THEN\n MoveAbs(AxisGroup:=KinScara, Execute:=FALSE); \/\/ Waits for the next new coordinates\n istate:=2;\n END_IF Déclarer une variable de type SMC_GroupReadSetPosition pour lire la valeur actuelle du robot en coordonnées cartésiennes et coordonnées d'axe. VAR\n Car_pos, Axis_pos :SMC_GroupReadSetPosition; \/\/to read the current axis values\nEND_VAR\n\n2:\n Car_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.MCS, Enable:=TRUE); \/\/ to read the current position in cartesian coordinates\n Axis_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.ACS, Enable:=TRUE); \/\/ to read the current axis values " }, 
{ "title" : "L'ensemble du programme PLC_PRG ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a5721f372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Utilisation de Depictor pour visualiser les groupes d'axes \/ L'ensemble du programme PLC_PRG ", 
"snippet" : "Comparez votre programme et ajoutez les parties de programme manquantes. Déclaration PROGRAM PLC_PRG VAR Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 :MC_Power; istate: INT; GroupEnable:MC_GroupEnable; Frame:MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & ...", 
"body" : "Comparez votre programme et ajoutez les parties de programme manquantes. Déclaration PROGRAM PLC_PRG\nVAR\n Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 :MC_Power;\n istate: INT;\n\n GroupEnable:MC_GroupEnable;\n\n Frame:MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & orientation of the TCP\n Pos_Cart:SMC_POS_REF; \/\/ This variable represents the position of the TCP in cartesian coordinates coordinates\n Pos_Axis:SMC_POS_REF := (a := axispos);\/\/ This variable represents the position of the TCP in Axis coordinates\n\n MoveAbs:MC_MoveDirectAbsolute; \/\/ Moves the TCP to the defined coordinates (PTP)\n\n Car_pos,Axis_pos :SMC_GroupReadSetPosition; \/\/to read the current position of the TCP in Cartesian and Axis Coordinates and display it on the visu\n\n scara_Config:trafo.Kin_Scara3_Z_Config; \/\/ To set the configuration of the SCARA_3_Z\n kin_Config:SMC_SetKinConfiguration; \/\/ To set the defined configuration of SCARA_3_Z to the axis group used\n nPeriod:DINT:=0; \/\/ SCARA_3_Z Period\n Xelbow:BOOL:=TRUE;\n\nEND_VAR\nVAR CONSTANT\n axispos : TRAFO.AXISPOS_REF := (a0 := 0, a1 := 100, a2:=60);\nEND_VAR Mise en œuvre CASE istate OF\n\n0:\n Power_Drive1(Axis:=Drive1, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive2(Axis:=Drive2, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive3(Axis:=Drive3, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive4(Axis:=Drive4, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n\n IF Power_Drive1.Status AND Power_Drive2.Status AND Power_Drive3.Status AND Power_Drive4.Status THEN\n istate:=istate+1;\n END_IF\n\n1:\n GroupEnable(AxisGroup:=KinScara, Execute:=TRUE);\n\n IF GroupEnable.Done THEN\n istate:=istate+1;\n END_IF\n\n2:\n scara_Config(xElbowRight:=Xelbow, nPeriodA3:=nPeriod);\n kin_Config(AxisGroup:=KinScara,ConfigData:=scara_Config.Config, Execute:=TRUE);\n Pos_Cart.c:=Frame; \/\/ To represent the TCP in cartesian coordinates\n\n Car_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.MCS, Enable:=TRUE); \/\/ read the current position in cartesian coordinates\n Axis_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.ACS, Enable:=TRUE); \/\/ read the current position in Axis coordinates\n\n MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Axis,CoordSystem:=SMC_COORD_SYSTEM.ACS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined axis coordinates\n \/\/MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Cart,CoordSystem:=SMC_COORD_SYSTEM.MCS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined cartesian coordinates\n\n IF MoveAbs.Done THEN\n MoveAbs(AxisGroup:=KinScara, Execute:=FALSE); \/\/ Waits for the next new coordinates\n istate:=2;\n END_IF\nEND_CASE " }, 
{ "title" : "Création d'un programme Depictor ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_8f044cf9373811e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Utilisation de Depictor pour visualiser les groupes d'axes \/ Création d'un programme Depictor ", 
"snippet" : "Ajoutez un nouveau POU \"Depic\" de type \"Programme\" sous l'application. Pour ce faire, cliquez sur Projet → Ajouter un objet → POU . Déclarer une variable de type SM3_Depictor.SMC_R_Scara3_Z_Data . Déclarer une variable LrSize de genre LREAL et initialisez la variable avec la valeur 100. VAR ScaraTra...", 
"body" : "Ajoutez un nouveau POU \"Depic\" de type \"Programme\" sous l'application. Pour ce faire, cliquez sur Projet → Ajouter un objet → POU . Déclarer une variable de type SM3_Depictor.SMC_R_Scara3_Z_Data . Déclarer une variable LrSize de genre LREAL et initialisez la variable avec la valeur 100. VAR\n ScaraTrafo : SM3_Depictor.SMC_R_Scara3_Z_Data;\n LrSize:LREAL:=100;\nEND_VAR Insérez un appel au bloc fonction dans l'implémentation. ScaraTrafo(AxisGroup:=KinScara, trf:=KinScara.trafo); Ajoutez le POU \"Depic\" au Tâche principale . " }, 
{ "title" : "Configuration de Depictor ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a523fe372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Utilisation de Depictor pour visualiser les groupes d'axes \/ Configuration de Depictor ", 
"snippet" : "Ajoutez un objet \"Depictor\" sous l'application. Pour ce faire, cliquez sur Projet → Ajouter un objet → Depictor . Double-cliquez sur l'objet. Sélectionnez le Pose élément dans l'arbre Depictor. Cliquez sur Depictor → Ajouter un élément . Les Boîte l'élément est ajouté sous la pose. Sélectionnez le D...", 
"body" : "Ajoutez un objet \"Depictor\" sous l'application. Pour ce faire, cliquez sur Projet → Ajouter un objet → Depictor . Double-cliquez sur l'objet. Sélectionnez le Pose élément dans l'arbre Depictor. Cliquez sur Depictor → Ajouter un élément . Les Boîte l'élément est ajouté sous la pose. Sélectionnez le Dépeceur Réf. option dans les propriétés de l'élément. Clique le bouton. Sélectionnez le SMC_R_Depictor_Scara3_Z objet de la SM3_Depictor une bibliothèque. Définissez les variables d'interface comme suit : fb : Depic.ScaraTrafo lrZ_ : Drive1.fSetPosition lrZmin : dix lrZmax : -50 lrTaille : Depic.LrSize xShowPlane : 0 " }, 
{ "title" : "Création de visualisations ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a460ad372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Utilisation de Depictor pour visualiser les groupes d'axes \/ Création de visualisations ", 
"snippet" : "Créez un écran de visualisation dans lequel les coordonnées cartésiennes et les coordonnées des axes peuvent être affichées et modifiées. Ajoutez un objet \"Visualisation\" sous l'application. Pour ce faire, cliquez sur Projet → Ajouter un objet → Visualisation . Ouvrez la visualisation dans l'éditeur...", 
"body" : "Créez un écran de visualisation dans lequel les coordonnées cartésiennes et les coordonnées des axes peuvent être affichées et modifiées. Ajoutez un objet \"Visualisation\" sous l'application. Pour ce faire, cliquez sur Projet → Ajouter un objet → Visualisation . Ouvrez la visualisation dans l'éditeur. Insérez un Rectangle élément de visualisation (1). Modifiez les propriétés de l'élément. Textes → Texte : %s Variables de texte → Variable de texte : PLC_PRG.Car_pos.Position.c.X Configuration d'entrée → OnMouseDown → Écrire la variable Type d'entrée : VisuDialogs.Numppad Utiliser une autre variable : PLC_PRG.Frame.X Insérez l'autre Boîte éléments de visualisation. Modifiez les propriétés des éléments (2) et (3). Textes → Texte : %s Variables de texte → Variable de texte : PLC_PRG.Car_pos.Position.c.Y ou PLC_PRG.Car_pos.Position.c.Z Configuration d'entrée → OnMouseDown → Écrire la variable Type d'entrée : VisuDialogs.Numppad Utiliser une autre variable : PLC_PRG.Frame.Y et PLC_PRG.Frame.Z Modifiez les propriétés des éléments (4), (5) et (6). Textes → Texte : %s Variables de texte → Variable de texte : PLC_PRG.Frame.A ou PLC_PRG.Frame.B ou PLC_PRG.Frame.C Modifiez les propriétés des éléments (7), (8), (9) et (10). Textes → Texte : %s Variables de texte → Variable de texte : PLC_PRG.Axis_pos.Position.a.a0 ou PLC_PRG.Axis_pos.Position.a.a1 ou PLC_PRG.Axis_pos.Position.a.a2 ou PLC_PRG.Axis_pos.Position.a.a3 Configuration d'entrée → OnMouseDown → Écrire la variable Type d'entrée : VisuDialogs.Numppad Utiliser une autre variable : PLC_PRG.Pos_Axis.a.a0 et PLC_PRG.Pos_Axis.a.a1 et PLC_PRG.Pos_Axis.a.a2 et PLC_PRG.Pos_Axis.a.a3 Étiquetez les éléments de visualisation avec le Étiqueter élément. " }, 
{ "title" : "Exemple de déclencheur 1 : exemple simple ", 
"url" : "_sm_example_digital_switches1.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Exemple de déclencheur 1 : exemple simple ", 
"snippet" : "Le Robotics_Trigger.project l'exemple de projet décrit ici se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . Les déclencheurs sont utilisés pour savoir exactement quand un groupe d'axes atteint un point spécifique sur la trajectoire commandée. Ces informati...", 
"body" : "Le Robotics_Trigger.project l'exemple de projet décrit ici se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . Les déclencheurs sont utilisés pour savoir exactement quand un groupe d'axes atteint un point spécifique sur la trajectoire commandée. Ces informations peuvent être utilisées, par exemple, pour allumer ou éteindre un outil exactement au bon moment. Cet exemple montre comment un déclencheur unique est commandé sur un mouvement, puis lu de manière cyclique. Sur cette base, le Exemple de déclencheur 2 : Processus de collage projet montre un exemple d'application réaliste. " }, 
{ "title" : "Structure de la demande ", 
"url" : "_sm_example_digital_switches1.html#UUID-69fc12d0-622f-ba4d-33ec-32604b337f95_section-idm4609369968113633803655575311", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Exemple de déclencheur 1 : exemple simple \/ Structure de la demande ", 
"snippet" : "L'application se compose de deux programmes : un Main_PRG s'exécutant dans la tâche de bus et un Planning_PRG exécuté dans la tâche de planification du groupe d'axes. De plus, il y a aussi une trace. Main_PRG : Le Main_PRG programme contient la machine d'état principale de l'application. Les deux pr...", 
"body" : "L'application se compose de deux programmes : un Main_PRG s'exécutant dans la tâche de bus et un Planning_PRG exécuté dans la tâche de planification du groupe d'axes. De plus, il y a aussi une trace. Main_PRG : Le Main_PRG programme contient la machine d'état principale de l'application. Les deux premiers états permettent d'initialiser et de mettre sous tension les variateurs et le groupe d'axes. Dans le STATE_COMMAND_MOVEMENT_WITH_TRIGGER état, un déclencheur est d'abord préparé à l'aide d'une instance de l'état SMC_GroupPrepareTrigger bloc fonctionnel. La position est spécifiée relativement avec une valeur de 0,6. En conséquence, le déclencheur est placé au point où 60 % du mouvement assigné est terminé. Le déclencheur préparé est affecté au prochain mouvement commandé. Dans cet exemple, un déplacement linéaire vers la position (X=20, Y=10) est commandé par un MC_MoveLinearAbsolute . prepTrigger.PositionType := SMC_TriggerPositionType.MvtRelative;\nprepTrigger.Position.MvtPosition := 0.6;\nprepTrigger(AxisGroup:= AxisGroup, Execute:= TRUE);\n \nmoveLinear(AxisGroup:= AxisGroup, Execute:= prepTrigger.Prepared); Dans l'état suivant STATE_ENABLE_READ_TRIGGER , un exemple de SMC_GroupReadTrigger est lancé afin de lire l'état du déclencheur commandé. Le lien avec le déclencheur est établi au moyen de la TriggerId retourné par SMC_GroupPrepareTrigger . readTrigger.TriggerId := prepTrigger.TriggerId;\nreadTrigger.Enable := TRUE; Dans le STATE_CHECK_TRIGGER état, l'état du déclencheur est enfin vérifié cycliquement. Dès que SMC_GroupReadTrigger rapports Active en tant qu'état, la durée jusqu'à ce que le déclencheur soit atteint peut être lue. La durée se réfère toujours au début du cycle en cours. Ainsi, le déclenchement est atteint dans le cycle en cours si la durée est inférieure au temps de cycle (dans cet exemple, 0,004 s) : IF readTrigger.TriggerInfo.status = SMC_TRIGGER_STATUS.Active THEN\n IF readTrigger.TriggerInfo.triggerTime <= 0.004 THEN\n triggerFired := TRUE;\n ...\n END_IF\nEND_IF Planning_PRG Dans le Planning_PRG programme, la durée prévisionnelle du planning est configurée au moyen du SMC_TuneCPKernel bloc fonctionnel. Le SMC_GroupReadTrigger le bloc fonctionnel peut émettre une sortie lorsqu'un déclencheur atteint la durée de prévision. Dans l'exemple, la durée de prévision est fixée à 0,1 s. Par conséquent, le statut de la SMC_GroupReadTrigger le bloc fonction passe à Active 0,1 s avant que le groupe d'axes n'atteigne le déclencheur et délivre une durée valide à partir de là. tuneCpKernel(AxisGroup:= axisGroup, Execute:= TRUE, fPlanningForecastDuration:= 0.1); Trace La trace peut être utilisée pour suivre le comportement du SMC_GroupReadTrigger bloc fonctionnel. Dans le premier diagramme, vous pouvez voir qu'un mouvement est exécuté de (X=0, Y=0) à (X=20, Y=10). La gâchette est située à la position relative 0.6 sur le mouvement, c'est-à-dire à (X=12, Y=6). Le deuxième diagramme montre la valeur de triggerTime sortie de SMC_GroupReadTrigger . La valeur saute à 0,1 s car la durée prévue de la planification est de 0,1 s, puis chute linéairement jusqu'à ce que la valeur 0 soit atteinte à la position (X=12, Y=6). Le troisième diagramme montre la valeur de triggerFired variable définie dans le STATE_CHECK_TRIGGER état de Main_PRG dès que le groupe d'axes est à moins de 0,004 s du déclencheur. " }, 
{ "title" : "Exemple de déclencheur 2 : Processus de collage ", 
"url" : "_sm_example_digital_switches2.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Exemple de déclencheur 2 : Processus de collage ", 
"snippet" : "Le Robotics_Trigger_Advanced.project l'exemple de projet décrit ici se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . Les déclencheurs peuvent être utilisés pour effectuer des actions à des positions spécifiques sur le chemin, telles que l'activation et la ...", 
"body" : "Le Robotics_Trigger_Advanced.project l'exemple de projet décrit ici se trouve dans le répertoire d'installation de CODESYS sous ..\\CODESYS SoftMotion\\Examples . Les déclencheurs peuvent être utilisés pour effectuer des actions à des positions spécifiques sur le chemin, telles que l'activation et la désactivation d'une buse de collage. Cet exemple inclut les composants suivants : La configuration d'une prévision garantie de la trajectoire par le fPlanningForecastDuration paramètre de la SMC_TuneCPKernel bloc fonctionnel. La commande de différents déclencheurs. Ici, les trois méthodes disponibles pour définir la position de la trajectoire sont utilisées (voir SMC_TriggerPositionType ). L'utilisation de déclencheurs avec décalage temporel. L'exemple d'application contient les TriggerWithTimeShift bloc fonctionnel qui peut réagir à l'atteinte de la position de trajectoire avec un décalage temporel (plus tôt et plus tard). Ces composants sont illustrés dans un exemple d'application pour un processus de collage. Le mouvement affiché en rouge dans l'image suivante est exécuté (avec fondu). Des déclencheurs ont été définis aux positions marquées en vert : Position 1 : Allumer l'encolleuse 0,05 s avant d'atteindre la position. Position 1 : Allumer la lampe UV lorsque la position est atteinte. Position 2 : Remplissez le réservoir de colle lorsque la position est atteinte. Position 3 : Éteindre l'encolleuse et arrêter de remplir le réservoir de colle 0,05 s avant d'atteindre la position. Position 3 : éteindre la lampe UV 1,5 s après avoir atteint la position " }, 
{ "title" : "Structure de la demande ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4589008317470433803801762921", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Exemple de déclencheur 2 : Processus de collage \/ Structure de la demande ", 
"snippet" : "L'application se compose des parties suivantes. GlueApplication : Ce programme contient l'exemple d'application qui montre comment utiliser des déclencheurs pour un processus de collage. Planning_PRG : Dans ce programme, une prévision de la trajectoire est configurée. TriggerWithTimeShift : Ce bloc ...", 
"body" : "L'application se compose des parties suivantes. GlueApplication : Ce programme contient l'exemple d'application qui montre comment utiliser des déclencheurs pour un processus de collage. Planning_PRG : Dans ce programme, une prévision de la trajectoire est configurée. TriggerWithTimeShift : Ce bloc fonction contient la logique des triggers avec décalage temporel et est utilisé dans le GlueApplication exemple de programme. Trace : La trace montre la dynamique des axes ainsi que les sorties du GlueApplication programme qui sont commutés par les déclencheurs. " }, 
{ "title" : "Configuration d'une prévision ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4570491496867233803803206327", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Exemple de déclencheur 2 : Processus de collage \/ Configuration d'une prévision ", 
"snippet" : "Si vous voulez réagir tôt avant qu'un déclencheur ne soit atteint, par exemple 0,05 s avant, alors le fPlanningForecastDuration paramètre du SMC_ SMC_TuneCPKernel bloc fonctionnel doit être réglé sur au moins 0,05 s. Comme le paramètre a un impact direct sur la latence, sa valeur ne doit pas être pl...", 
"body" : "Si vous voulez réagir tôt avant qu'un déclencheur ne soit atteint, par exemple 0,05 s avant, alors le fPlanningForecastDuration paramètre du SMC_ SMC_TuneCPKernel bloc fonctionnel doit être réglé sur au moins 0,05 s. Comme le paramètre a un impact direct sur la latence, sa valeur ne doit pas être plus grande que nécessaire (voir la documentation de fPlanificationPrévisionDurée ). Noter que SMC_TuneCPKernel doit être appelé dans le SoftMotion tâche de planification. Pour cette raison, la configuration n'est pas exécutée dans le programme principal GlueApplication , mais dans le Planning_PRG programme. Dans cet exemple d'application, l'évaluation du déclencheur est requise au plus tôt 0,05 s avant qu'une position ne soit atteinte. Pour cette raison, le paramètre fPlanningForecastDuration =0,05 est défini dans le Planning_PRG programme. " }, 
{ "title" : "Bloc fonction : TriggerWithTimeShift ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4609369977958433803803968971", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Exemple de déclencheur 2 : Processus de collage \/ Bloc fonction : TriggerWithTimeShift ", 
"snippet" : "Le TriggerWithTimeShift Le bloc fonctionnel fournit une interface simplifiée pour l'utilisation des déclencheurs. De plus, un décalage temporel peut être défini afin que le déclencheur puisse réagir avant qu'une position (valeur positive) ainsi qu'après qu'une position (valeur négative) ne soit atte...", 
"body" : "Le TriggerWithTimeShift Le bloc fonctionnel fournit une interface simplifiée pour l'utilisation des déclencheurs. De plus, un décalage temporel peut être défini afin que le déclencheur puisse réagir avant qu'une position (valeur positive) ainsi qu'après qu'une position (valeur négative) ne soit atteinte. En fonction de la précision temporelle requise dans une application, la réaction à l'atteinte d'un déclencheur peut être la suivante : Précision de temps requise >= cycle de tâche de bus : Dans ce cas, la TriggerWithTimeShift.TriggerReachedThisCycle sortie peut être utilisée. Précision de temps requise < cycle de tâche de bus : dans ce cas, le temps restant exact TriggerWithTimeShift.TriggerTime jusqu'à ce que le déclencheur soit atteint peut être utilisé. Intérieurement, TriggerWithTimeShift utilise le SMC_GroupPrepareTrigger et SMC_GroupReadTrigger blocs fonctionnels. " }, 
{ "title" : "Commander des déclencheurs ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4608844104630433803805051855", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Exemple de déclencheur 2 : Processus de collage \/ Commander des déclencheurs ", 
"snippet" : "Dans le GlueApplication programme, les mouvements et les déclenchements sont commandés. L'ordre d'appel est particulièrement important pour les déclencheurs car les déclencheurs préparés à l'aide SMC_GroupPrepareTrigger sont affectés au prochain mouvement commandé dans le même cycle. Par conséquent,...", 
"body" : "Dans le GlueApplication programme, les mouvements et les déclenchements sont commandés. L'ordre d'appel est particulièrement important pour les déclencheurs car les déclencheurs préparés à l'aide SMC_GroupPrepareTrigger sont affectés au prochain mouvement commandé dans le même cycle. Par conséquent, dans chaque application, vous devez faire attention aux points suivants : Les blocs fonctionnels de commande des déclencheurs sont toujours appelés avant les blocs fonctionnels de mouvement. Les déclencheurs et le mouvement respectif sont toujours commandés dans le même cycle. Les déclencheurs utilisent tous les types de SMC_TriggerPositionType : Les déclencheurs à la position 1 utilisent la définition d'une distance relative ( SMC_TriggerPositionType.MvtRelative ) et comme Position 0.5. Étant donné que le mouvement respectif a une distance de 10, les déclencheurs sont situés à X=5. Le déclencheur à la position 2 utilise la définition d'une distance en unités utilisateur u ( SMC_TriggerPositionType.MvtDistance ) et en position 5. Par conséquent, le déclencheur est également situé à X=5. Les déclencheurs en Position 3 utilisent l'intersection avec un plan ( SMC_TriggerPositionType.PlaneIntersection ). Le plan a été défini pour que les déclencheurs soient situés en X=5. GlueApplication a la EnableGlue , EnableUVLamp , et RefillGlueStorage les sorties. Ceux-ci sont commutés aux déclencheurs appropriés dans GlueApplication.EvaluateTriggers() . Le mouvement et l'état de ces sorties peuvent être surveillés et évalués dans la trace. " }, 
{ "title" : "Utilisation d'axes supplémentaires en robotique ", 
"url" : "_sm_example_additional_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Utilisation d'axes supplémentaires en robotique ", 
"snippet" : "Le Robotics_AdditionalAxes.project Un exemple de projet montre comment des axes supplémentaires sont configurés et utilisés en robotique. Les axes supplémentaires sont des axes qui sont déplacés de manière synchrone avec les mouvements coordonnés du robot Le projet se trouve dans le répertoire d'ins...", 
"body" : "Le Robotics_AdditionalAxes.project Un exemple de projet montre comment des axes supplémentaires sont configurés et utilisés en robotique. Les axes supplémentaires sont des axes qui sont déplacés de manière synchrone avec les mouvements coordonnés du robot Le projet se trouve dans le répertoire d'installation de CODESYS en dessous ..\\CODESYS SoftMotion\\Examples . " }, 
{ "title" : "Structure de la demande ", 
"url" : "_sm_example_additional_axes.html#UUID-c2402508-ef5a-d02d-ee68-db3b85c8530d_section-idm235063293414778", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Utilisation d'axes supplémentaires en robotique \/ Structure de la demande ", 
"snippet" : "Le groupe d'axes est configuré dans Groupe Axis objet. Un robot SCARA à 3 axes (deux axes rotatifs et un axe Z linéaire) est utilisé Deux axes supplémentaires ont également été ajoutés ci-dessous. Axes supplémentaires et relié aux deux axes DriveAdd1 et DriveAdd2 . Le PLC_PRG Le programme contient u...", 
"body" : "Le groupe d'axes est configuré dans Groupe Axis objet. Un robot SCARA à 3 axes (deux axes rotatifs et un axe Z linéaire) est utilisé Deux axes supplémentaires ont également été ajoutés ci-dessous. Axes supplémentaires et relié aux deux axes DriveAdd1 et DriveAdd2 . Le PLC_PRG Le programme contient une machine à états simple pour le flux du programme. Tout d'abord, le groupe d'axes est activé dans l'état 0 , puis un mouvement PTP pour se positionner (X=50, Y=50) est effectué. Ceci est ensuite mélangé dans un mouvement linéaire pour positionner (X=50, Y=-50) . Pour le premier mouvement du robot, un mouvement d'axe supplémentaire relatif avec la distance (10, 20) est commandé. Pour le second mouvement du robot, la distance de l'axe supplémentaire est (-10, -20) . Le MC_GroupReadActualPosition et MC_GroupReadActualVelocity des blocs fonctionnels sont utilisés pour lire la position et la vitesse de la cinématique et des axes supplémentaires. " }, 
{ "title" : "Mise en service ", 
"url" : "_sm_example_additional_axes.html#UUID-c2402508-ef5a-d02d-ee68-db3b85c8530d_section-idm235063296617065", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Exemples \/ Utilisation d'axes supplémentaires en robotique \/ Mise en service ", 
"snippet" : "Créez l'application et téléchargez-la sur une manette. Ouvrez la trace et téléchargez-la sur le contrôleur. Démarrez l'application. Vous pouvez suivre le mouvement des coordonnées X et Y et des deux axes supplémentaires dans le tracé....", 
"body" : "Créez l'application et téléchargez-la sur une manette. Ouvrez la trace et téléchargez-la sur le contrôleur. Démarrez l'application. Vous pouvez suivre le mouvement des coordonnées X et Y et des deux axes supplémentaires dans le tracé. " }, 
{ "title" : "Interface utilisateur ", 
"url" : "_sm_robotics_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Interface utilisateur ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Commande : Créer une tâche de planification ", 
"url" : "_sm_cmd_create_planning_task.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Interface utilisateur \/ Commande : Créer une tâche de planification ", 
"snippet" : "Fonction : La commande crée automatiquement une tâche de planification. Cette tâche est nécessaire pour la planification des déplacements CP (par exemple, déplacement linéaire ou déplacement circulaire). Appel : Projet menu; menu contextuel du groupe d'axes Exigence : La commande n'est disponible qu...", 
"body" : "Fonction : La commande crée automatiquement une tâche de planification. Cette tâche est nécessaire pour la planification des déplacements CP (par exemple, déplacement linéaire ou déplacement circulaire). Appel : Projet menu; menu contextuel du groupe d'axes Exigence : La commande n'est disponible que si aucune tâche de planification n'est configurée pour le groupe d'axes. " }, 
{ "title" : "Editeur de groupes d'axes ", 
"url" : "_sm_obj_axis_group-1018069.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Interface utilisateur \/ Editeur de groupes d'axes ", 
"snippet" : "Symbole: Dans l'éditeur du Groupe d'axes objet, sélectionnez le type de cinématique de base et de cinématique d'orientation. La cinématique d'orientation ne peut être sélectionnée que si elle est prise en charge par la cinématique de base. De plus, vous mappez les axes de la cinématique aux entraîne...", 
"body" : "Symbole: Dans l'éditeur du Groupe d'axes objet, sélectionnez le type de cinématique de base et de cinématique d'orientation. La cinématique d'orientation ne peut être sélectionnée que si elle est prise en charge par la cinématique de base. De plus, vous mappez les axes de la cinématique aux entraînements de votre projet. Cinématique Sélectionnez la cinématique Changer la cinématique Ouvre une liste de toutes les cinématiques prises en charge par CODESYS Lorsque vous sélectionnez un type de cinématique, une brève description s'affiche dans le cadre à droite de la liste. Après avoir sélectionné un type de cinématique, vous pouvez modifier les paramètres respectifs dans l'éditeur. Cinématique d'orientation Sélectionnez la cinématique Changer la cinématique Ouvre une liste de toutes les cinématiques d'orientation prises en charge par CODESYS Lorsque vous sélectionnez un type de cinématique, une brève description s'affiche dans le cadre à droite de la liste. Après avoir sélectionné un type de cinématique, vous pouvez modifier les paramètres respectifs dans l'éditeur. Cartographie des axes En fonction de la cinématique sélectionnée, vous mappez les axes de la cinématique aux entraînements de votre projet. Axes supplémentaires Ajouter un axe Ajoute un champ de configuration pour un axe supplémentaire. Le lecteur du projet est saisi dans ce champ de configuration. Tâches Tâche de cycle de bus Tâche de cycle de bus des axes, si les axes sont déjà mappés Le réglage ne peut pas être modifié ici. Tâche de planification Tâche pour la planification des tâches du CP Une tâche de planification est créée automatiquement lors de l'insertion du premier groupe d'axes. Un chien de garde ne doit pas être configuré car le temps d'exécution peut fluctuer considérablement. Pour plus d'informations, voir : Configuration de la tâche de planificationSi vous supprimez cette tâche, une erreur est émise dans la vue des messages. Pour créer une nouvelle tâche, cliquez sur Projet → Créer une tâche de planification . Pour plus d'informations, consultez : Comment créer un groupe d'axes" }, 
{ "title" : "Interface utilisateur ", 
"url" : "_sm_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Interface utilisateur ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Commande : Activer SoftMotion ", 
"url" : "_sm_cmd_enable_softmotion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Interface utilisateur \/ Commande : Activer SoftMotion ", 
"snippet" : "Fonction : La commande active les composants de SoftMotion pour le contrôleur sélectionné et permet d'utiliser le contrôleur comme contrôleur de mouvement. Appel : Projet menu; menu contextuel d'un appareil sélectionné dans l'arborescence des appareils Exigence : Pour le contrôleur sélectionné, Soft...", 
"body" : "Fonction : La commande active les composants de SoftMotion pour le contrôleur sélectionné et permet d'utiliser le contrôleur comme contrôleur de mouvement. Appel : Projet menu; menu contextuel d'un appareil sélectionné dans l'arborescence des appareils Exigence : Pour le contrôleur sélectionné, SoftMotion n'est pas activé. La commande provoque le Pool d'axes généraux SoftMotion dispositif à ajouter sous la configuration du contrôleur tant que l'objet est toujours manquant. Il y a au plus un Pool d'axes généraux SoftMotion par appareil CPL. De plus, les bibliothèques SoftMotion (avec préfixe SM3_ ) sont ajoutés au gestionnaire de bibliothèque. Ainsi, vous pouvez utiliser la fonctionnalité SoftMotion sur tous les automates conventionnels et, par exemple, appeler les blocs fonction SoftMotion même sans licence au moins en mode démo. Activation automatique Si votre appareil est désactivé pour SoftMotion et que vous avez ajouté un objet SoftMotion sous l'appareil, le Activer SoftMotion commande est immédiatement exécutée implicitement. Un objet SoftMotion est un objet came, un objet CNC, un objet groupe d'axes ou tout axe SoftMotion. Mise à jour de l'appareil d'un automate SoftMotion vers un automate standard Si SoftMotion a été activé et les appareils ont été configurés ci-dessous Pool d'axes généraux SoftMotion , vous pouvez quand même mettre à jour votre appareil vers un API standard. En effet, ces appareils restent disponibles même après la mise à jour. Par exemple, vous pouvez mettre à jour à partir de CODESYS SoftMotion RTE à CODESYS Control RTE sans aucune perte. " }, 
{ "title" : "Commande : Désactiver SoftMotion ", 
"url" : "_sm_cmd_disable_softmotion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Interface utilisateur \/ Commande : Désactiver SoftMotion ", 
"snippet" : "Fonction : La commande désactive les composants de SoftMotion . Appel : Projet menu; menu contextuel d'un appareil sélectionné dans l'arborescence des appareils Exigence : Pour le contrôleur sélectionné, SoftMotion a été activé au moyen de la commande. SoftMotion ne peut pas être désactivé pour les ...", 
"body" : "Fonction : La commande désactive les composants de SoftMotion . Appel : Projet menu; menu contextuel d'un appareil sélectionné dans l'arborescence des appareils Exigence : Pour le contrôleur sélectionné, SoftMotion a été activé au moyen de la commande. SoftMotion ne peut pas être désactivé pour les contrôleurs qui sont destinés à prendre en charge SoftMotion (Exemple: CODESYS SoftMotion Win ). La commande provoque le Pool d'axes généraux SoftMotion dispositif à retirer du dessous de la configuration du contrôleur. De plus, les bibliothèques SoftMotion (avec préfixe SM3_ ) sont supprimés du gestionnaire de bibliothèque. Vous ne pouvez plus utiliser la fonctionnalité SoftMotion. " }
]
$(document).trigger('search.ready');
});