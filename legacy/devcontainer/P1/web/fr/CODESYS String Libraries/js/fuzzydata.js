$(document).ready(function () {indexDict['fr'] = [{ "title" : "CODESYS String Libraries ", 
"url" : "_strlib_start_page.html", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Pr√©sentation ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4664735744121633736389596078", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Pr√©sentation ", 
"snippet" : "Les biblioth√®ques du CODESYS String Libraries Le package peut √™tre utilis√© pour traiter des cha√Ænes cod√©es en UTF-8. La base est IString interface depuis String Segments biblioth√®que. √Ä l'aide de cette interface, les cha√Ænes peuvent √™tre transmises aux fonctions respectives par r√©f√©rence. Par exempl...", 
"body" : "Les biblioth√®ques du CODESYS String Libraries Le package peut √™tre utilis√© pour traiter des cha√Ænes cod√©es en UTF-8. La base est IString interface depuis String Segments biblioth√®que. √Ä l'aide de cette interface, les cha√Ænes peuvent √™tre transmises aux fonctions respectives par r√©f√©rence. Par exemple, pour cr√©er un IString exemple, le GSB.UTF8String bloc de fonction du Generic String Base une biblioth√®que est fournie. Les biblioth√®ques suivantes sont fournies avec le package¬†: String Segments Fonctions de base pour IString instances Documentation de la biblioth√®que de segments de cha√Ænes String Builder Gestion efficace des segments de cha√Ænes cod√©s en UTF-8 Documentation de la biblioth√®que String Builder String Conversions Conversion de cha√Ænes de diff√©rents encodages vers\/depuis UTF-8 Documentation de la biblioth√®que de conversions de cha√Ænes String Functions Fonctions de traitement de cha√Ænes cod√©es en UTF-8 en suivant l'exemple de la biblioth√®que standard conventionnelle. Documentation de la biblioth√®que de fonctions de cha√Æne Unicode Support Fonctions de traitement des cat√©gories de caract√®res Unicode. Documentation de la biblioth√®que des fonctions de support Unicode UTF-16 Encoding Support Fonction de base pour g√©rer les zones de m√©moire cod√©es en UTF-16 Documentation de la biblioth√®que de support de l'encodage UTF-16 UTF-8 Encoding Support Fonction de base pour g√©rer les zones de m√©moire cod√©es en UTF-8 Documentation de la biblioth√®que des fonctions de support de l'encodage UTF-8 Generic String Base Blocs fonctionnels pour le traitement de cha√Ænes cod√©es en UTF-8 qui g√®rent leur m√©moire de mani√®re statique via GENERIC CONSTANT . Documentation de la biblioth√®que de fonctions de base de cha√Ænes g√©n√©riques " }, 
{ "title" : "Avantages des nouvelles biblioth√®ques de cha√Ænes ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4563869800648033733012917566", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Avantages des nouvelles biblioth√®ques de cha√Ænes ", 
"snippet" : "Les nouvelles biblioth√®ques de cha√Ænes ne remplacent pas les anciennes fonctions de cha√Æne famili√®res du Standard et Standard64 biblioth√®ques. N√©anmoins, nous vous recommandons d'utiliser les nouvelles biblioth√®ques de cha√Ænes pour les nouveaux projets. Les nouvelles biblioth√®ques de cha√Ænes peuvent...", 
"body" : "Les nouvelles biblioth√®ques de cha√Ænes ne remplacent pas les anciennes fonctions de cha√Æne famili√®res du Standard et Standard64 biblioth√®ques. N√©anmoins, nous vous recommandons d'utiliser les nouvelles biblioth√®ques de cha√Ænes pour les nouveaux projets. Les nouvelles biblioth√®ques de cha√Ænes peuvent √©galement g√©rer de grandes cha√Ænes de mani√®re efficace. La longueur des cordes est quasiment illimit√©e. Pour cette raison, les biblioth√®ques sont √©galement adapt√©es √† l'√©dition de fichiers texte volumineux et de contenus Web. Autres avantages¬†: L'UTF-8 est un codage qui peut repr√©senter la gamme compl√®te de caract√®res selon UNICODE. L'UTF-8 est largement utilis√© sur Internet et est recommand√© par le World Wide Web Consortium (W3C). L'UTF-8 est compatible avec les syst√®mes existants en raison de la compatibilit√© ASCII. L'UTF-8 offre un haut niveau d'interop√©rabilit√©. L'UTF-8 fonctionne pour optimiser la m√©moire. Les nouvelles biblioth√®ques de cha√Ænes vous permettent d'interroger une cha√Æne pr√©c√©demment d√©finie via les m√©thodes correspondantes, comme vous le savez dans d'autres langages de haut niveau. Exemple de m√©thode de cha√Æne¬†: Len() udiStringLen := myString.Len();\nif¬†udiStringLen =¬†22¬†THEN\n... √Ä partir du CODESYS 3.5.18.0, vous pouvez configurer le compilateur pour interpr√©ter le contenu des variables de type STRING sous forme de codage UTF-8. Vous s√©lectionnez le Encodage UTF8 pour STRING option dans le Param√®tres du projet dans le Options de compilation cat√©gorie. Si vous ne souhaitez pas tout traiter STRING variables d'un projet cod√©es en UTF-8, vous devez d√©sactiver cette option. Ensuite, vous pouvez appliquer le codage UTF-8 √† des litt√©raux individuels STRING tapez au cas par cas. Codage UTF-8 pour les litt√©raux {attribute¬†'monitoring_encoding'¬†:=¬†'UTF-8'}\nsValue : STRING(140) := UTF8#'√êŒ± ·πß—Ç‚ÑØ‚ôÑ ·∏Ø·∏â‚Ñå Œ∑uŒ∑, i¬¢‚Ñå Œ±—è–º‚ÑØ“ë ùïã√∏“ë‚Äº ·π≤·æî‚Öæ ‚ô≠·∏ØŒ∑ ÔºÑ‚ò∫ ·∏±‚ÑìœÖ‚Ñä Œ±≈ÇÔºÑ œâ‚Öà‚ÑÆ ·∫ïœÖ‚àö‚óé“ë'; Gr√¢ce aux capacit√©s de l'encodage UTF-8, vous n'avez pas besoin d'utiliser WSTRING type de donn√©es dans CODESYS pour utiliser un jeu de caract√®res √©tendu. encodage UCS-2 WSTRING est bas√© sur, peut n√©cessiter plus de m√©moire qu'un codage UTF-8, selon l'application. Le codage UCS-2 en utilise toujours WORD par caract√®re et ne peut repr√©senter que les personnages U+0000 √† U+D800 et U+DFFF √† U+FFFD . Le codage UTF-8 n√©cessite entre un et quatre octets par caract√®re. Par cons√©quent, tous les caract√®res Unicode peuvent √™tre trait√©s Avec le codage UTF-8, si vous essayez d'obtenir un caract√®re sp√©cifique √† l'aide d'un index sp√©cifique, cela entra√Ænera des r√©sultats inattendus en raison de la longueur variable. Codage de longueur variable {attribute 'monitoring_encoding' := 'UTF-8'}\nsValue : STRING(140) := UTF8#'√êŒ± ·πß—Ç‚ÑØ‚ôÑ ·∏Ø·∏â‚Ñå Œ∑uŒ∑, i¬¢‚Ñå Œ±—è–º‚ÑØ“ë ùïã√∏“ë‚Äº ·π≤·æî‚Öæ ‚ô≠·∏ØŒ∑ ÔºÑ‚ò∫ ·∏±‚ÑìœÖ‚Ñä Œ±≈ÇÔºÑ œâ‚Öà‚ÑÆ ·∫ïœÖ‚àö‚óé“ë';\n\nbyValue := sValue[13];¬†\/\/ The 'u' is NOT the 13th character in the string\nxOk := byValue <>¬†16#75; Vous devez d√©terminer l'index d'un caract√®re en parcourant la cha√Æne. It√©ration sur des cha√Ænes cod√©es en UTF-8 VAR\t\n {attribute 'monitoring_encoding' := 'UTF-8'}\n sValue : STRING(140) := UTF8#'√êŒ± ·πß—Ç‚ÑØ‚ôÑ ·∏Ø·∏â‚Ñå Œ∑uŒ∑, i¬¢‚Ñå Œ±—è–º‚ÑØ“ë ùïã√∏“ë‚Äº ·π≤·æî‚Öæ ‚ô≠·∏ØŒ∑ ÔºÑ‚ò∫ ·∏±‚ÑìœÖ‚Ñä Œ±≈ÇÔºÑ œâ‚Öà‚ÑÆ ·∫ïœÖ‚àö‚óé“ë';\n\n fbsValue : STR.UTF8Literal := (psValue:=ADR(sValue)); \n fbRange : STR.Range := (itfString:=fbsValue);\n diRune : STR.RUNE;\n udiIndex, udiLength : UDINT;\n xOk : BOOL;\nEND_VAR\n \nWHILE (diRune := fbRange.GetNextRune(udiLength=>udiLength)) <> 0 DO\n IF diRune = 16#75 (* 'u' *) THEN\n EXIT;\n END_IF\n udiIndex := udiIndex + udiLength;\nEND_WHILE\n \nxOk := sValue[udiIndex] = 16#75 (* 'u' *); " }, 
{ "title" : "Inconv√©nients de l'√©tabli STRING fonctions ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4613761597678433733013344138", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Inconv√©nients de l'√©tabli STRING fonctions ", 
"snippet" : "Dans le cadre pr√©c√©demment √©tabli STRING fonctions de la biblioth√®que standard, les param√®tres de type STRING sont copi√©s lorsqu'ils sont transmis aux fonctions. La valeur de retour est √©galement copi√©e dans une variable avec l'affectation. Probl√®mes li√©s aux fonctions STRING √©tablies VAR sValue : S...", 
"body" : "Dans le cadre pr√©c√©demment √©tabli STRING fonctions de la biblioth√®que standard, les param√®tres de type STRING sont copi√©s lorsqu'ils sont transmis aux fonctions. La valeur de retour est √©galement copi√©e dans une variable avec l'affectation. Probl√®mes li√©s aux fonctions STRING √©tablies VAR\n sValue : STRING;\nEND_VAR\n \nsValue := CONCAT(CONCAT(CONCAT('Da steh ich nun,', ' ich armer Tor!'), ' Und bin so'), ' klug als wie zu vor');\n\/\/ -> Copy, LEN -> Copy, LEN -> Copy, LEN -> Copy, LEN\n\/\/ -> 2xCopy, LEN\n\/\/ -> 2xCopy, LEN\n\/\/ -> 2xCopy, LEN Avant de traiter les param√®tres de type STRING dans les fonctions respectives, leur longueur doit souvent √™tre d√©termin√©e par it√©ration jusqu'au caract√®re nul final. Pour les cha√Ænes plus longues, ces op√©rations de copie et d'it√©ration augmentent le temps de traitement de l'application. La longueur des cha√Ænes est limit√©e √† 255 caract√®res pour l'application de ces fonctions. " }, 
{ "title" : "√Ä l'aide du IString interface ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4598276788502433733013693363", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ √Ä l'aide du IString interface ", 
"snippet" : "Le STR.IString interface a √©t√© introduite pour transmettre la structure de donn√©es qui g√®re les informations relatives √† une cha√Æne par r√©f√©rence. Il s'agit d'une diff√©rence majeure par rapport aux fonctions STRING pr√©c√©demment √©tablies, qui n'impl√©mentent pas le STR.IString interface. De plus, la t...", 
"body" : "Le STR.IString interface a √©t√© introduite pour transmettre la structure de donn√©es qui g√®re les informations relatives √† une cha√Æne par r√©f√©rence. Il s'agit d'une diff√©rence majeure par rapport aux fonctions STRING pr√©c√©demment √©tablies, qui n'impl√©mentent pas le STR.IString interface. De plus, la taille d'une cha√Æne (la m√©moire respective pour les caract√®res cod√©s UTF-8) peut √™tre comprise dans la plage num√©rique UDINT 4 ‚â¶ udiSize ‚â¶ 16#FFFF_FF00 ). Dans la structure de donn√©es mentionn√©e, les informations suivantes sont tenues √† jour et ne doivent pas √™tre recalcul√©es √† chaque fois avant une √©tape de traitement¬†: R√©f√©rence au segment de m√©moire correspondant Capacit√© actuelle (‚Üí GetSegment ) Longueur (‚Üí Len ) en octets Nombre de caract√®res (‚Üí RuneCount ) Propri√©t√©s de STR.IString VAR\n itfString : STR.IString;\n udiLength, udiSize, udiRuneCount : UDINT;\n pbySegment : POINTER TO BYTE;\n xValid : BOOL;\nEND_VAR\n \nudiLength := itfString.Len(); \/\/ Current length in byte\npbySegment := itfString.GetSegment(udiSize=>udiSize); \/\/ Address first byte, capacity of the segment in bytes\nudiRuneCount := STR.RuneCount(itfString); \/\/ Current number of \"characters\" in the segment\nxValid := itfString.IsValid(); \/\/ Indication that a valid UTF-8 encoding is present. Corr√©lation¬†: ¬´¬†personnage¬†¬ª et ¬´¬†rune¬†¬ª Le terme ¬´¬†rune¬†¬ª appara√Æt dans les biblioth√®ques et dans le code source et signifie exactement la m√™me chose que ¬´¬†point de code Unicode¬†¬ª, avec un ajout int√©ressant. Les biblioth√®ques d√©finissent le mot ¬´¬†rune¬†¬ª comme alias pour le type DINT . Par cons√©quent, l'utilisateur peut clairement voir quand une valeur enti√®re repr√©sente un point de code. De plus, ce que l'on peut imaginer comme une constante de caract√®re est appel√© constante runique Exemple¬†: type et valeur de l'expression WSTRING#\"‚åò\" est une rune dont la valeur est un entier DINT#16#2318 . " }, 
{ "title" : "Informations pour les experts ", 
"url" : "_strlib_expert_information.html", 
"breadcrumbs" : "CODESYS String Libraries \/ Informations pour les experts ", 
"snippet" : "Dans CODESYS versions ant√©rieures √† 3.5.18.0, vous n'avez pas la possibilit√© d'utiliser des variables cod√©es en UTF-8 de type STRING et le Generic String Base biblioth√®que. Cela n'est possible qu'√† partir de la version 3.5.19.50. Vous pouvez toujours utiliser les autres biblioth√®ques du CODESYS Stri...", 
"body" : "Dans CODESYS versions ant√©rieures √† 3.5.18.0, vous n'avez pas la possibilit√© d'utiliser des variables cod√©es en UTF-8 de type STRING et le Generic String Base biblioth√®que. Cela n'est possible qu'√† partir de la version 3.5.19.50. Vous pouvez toujours utiliser les autres biblioth√®ques du CODESYS String Libraries colis. Cependant, la gestion des zones de m√©moire cod√©es en UTF-8 (par exemple, ARRAY OF BYTE ) y est un peu plus complexe. AVANT SP18 VAR\n abyValue : ARRAY[0..33] OF BYTE := [ \/\/ UTF-8 C√òD‚Ç¨≈°≈∏≈† √Ø√ü v√§r√ø √ß√¥√µl\n 16#43, 16#C3, 16#98, 16#44, 16#E2, 16#82, 16#AC, 16#C5, 16#A1, 16#C5, 16#B8,\n 16#C5, 16#A0, 16#20, 16#C3, 16#AF, 16#C3, 16#9F, 16#20, 16#76, 16#C3, 16#A4,\n 16#72, 16#C3, 16#BF, 16#20, 16#C3, 16#A7, 16#C3, 16#B4, 16#C3, 16#B5, 16#6C, 0\n ];\n myString : STR.UTF8Literal := (psValue:=ADR(abyValue));\nEND_VAR D√®s que les variables cod√©es en UTF-8 sont de type STRING sont disponibles, l'exemple ci-dessus est encore simplifi√©¬†: VAR\n myString : STR.UTF8Literal := (psValue:=ADR(UTF8#'C√òD‚Ç¨≈°≈∏≈† √Ø√ü v√§r√ø √ß√¥√µl'));\nEND_VAR " }, 
{ "title" : "Conversion depuis STRING √† IString ", 
"url" : "_strlib_expert_information.html#UUID-ab7f59ef-3fd1-9368-2073-8d15fffc313a_section-idm4670931916384033733014074571", 
"breadcrumbs" : "CODESYS String Libraries \/ Informations pour les experts \/ Conversion depuis STRING √† IString ", 
"snippet" : "La structure de donn√©es permettant de g√©rer les propri√©t√©s d'un segment de cha√Æne est mise en ≈ìuvre au moyen du STR._UTF8String bloc fonctionnel. Pour ce faire, vous devez allouer de la m√©moire pour une instance de ce bloc fonctionnel et pour le segment de cha√Æne lui-m√™me. Une instance de bloc fonct...", 
"body" : "La structure de donn√©es permettant de g√©rer les propri√©t√©s d'un segment de cha√Æne est mise en ≈ìuvre au moyen du STR._UTF8String bloc fonctionnel. Pour ce faire, vous devez allouer de la m√©moire pour une instance de ce bloc fonctionnel et pour le segment de cha√Æne lui-m√™me. Une instance de bloc fonctionnel doit √™tre situ√©e dans une zone de m√©moire align√©e sur __XWORD address . Conversion de String √† IString VAR CONSTANT\n c_udiLength : UDINT := MAX(4, 512); \/\/ String segment capacity including terminal NULL\n c_udiXWORD : UDINT := SIZEOF(__XWORD);\n¬† ¬†¬†c_udiMaxIndex : UDINT := (SIZEOF(STR._UTF8String) + c_udiLength +¬† c_udiXWORD¬† -¬†1) \/ c_udiXWORD;\nEND_VAR\n \nVAR\n abyValue : ARRAY[0..33] OF BYTE := [ \/\/ UTF-8 C√òD‚Ç¨≈°≈∏≈† √Ø√ü v√§r√ø √ß√¥√µl\n 16#43, 16#C3, 16#98, 16#44, 16#E2, 16#82, 16#AC, 16#C5, 16#A1, 16#C5, 16#B8,\n 16#C5, 16#A0, 16#20, 16#C3, 16#AF, 16#C3, 16#9F, 16#20, 16#76, 16#C3, 16#A4,\n 16#72, 16#C3, 16#BF, 16#20, 16#C3, 16#A7, 16#C3, 16#B4, 16#C3, 16#B5, 16#6C, 0\n\t];\n axwMemory : ARRAY[0..c_udiMaxIndex] OF __XWORD;\n udiSize : UDINT;\n itfString : STR.IString := STR.CreateString(\n ADR(axwMemory), SIZEOF(axwMemory),\n ADR(abyValue),\n udiStrSize=>udiSize\n );\n xOk : BOOL;\nEND_VAR\n \nxOk := (\n udiSize >= 512 AND\n itfString.Len() = 33 AND\n STR.RuneCount(itfString) = 20 AND\n itfString.IsValid() AND\n NOT itfString.IsASCII()\n); Avec l'aide du Generic String Base biblioth√®que, bon nombre de ces exigences sont prises en compte par les blocs de fonctions correspondants, lib√©rant ainsi l'utilisateur de nombreuses t√¢ches. Surtout, la r√©servation et l'alignement corrects de la m√©moire sont encapsul√©s dans les blocs fonctionnels correspondants " }, 
{ "title" : "Exemples ", 
"url" : "_strlib_examples.html", 
"breadcrumbs" : "CODESYS String Libraries \/ Exemples ", 
"snippet" : "Le Generic String Base une biblioth√®que est fournie pour rendre le traitement des cha√Ænes aussi simple que possible. Cependant, il utilise VAR_GENERIC CONSTANT fonction de compilation et ne peut donc √™tre utilis√©e qu'√† partir de CODESYS Mise √† jour 5 V3.5 SP19....", 
"body" : "Le Generic String Base une biblioth√®que est fournie pour rendre le traitement des cha√Ænes aussi simple que possible. Cependant, il utilise VAR_GENERIC CONSTANT fonction de compilation et ne peut donc √™tre utilis√©e qu'√† partir de CODESYS Mise √† jour 5 V3.5 SP19. " }, 
{ "title" : "Biblioth√®que¬†: Generic String Base ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4598276773272033733014529891", 
"breadcrumbs" : "CODESYS String Libraries \/ Exemples \/ Biblioth√®que¬†: Generic String Base ", 
"snippet" : "Voici un exemple ( myString ) d'un GSB.UTF8String d'une capacit√© de 128 octets est cr√©√© et le segment de cha√Æne avec la valeur d'une variable STRING (chiffre romain 1968) est initialis√©. Les m√©thodes de STR.IString sont disponibles. √Ä partir de STRING √† IString VAR ¬† ¬†¬†myString : GSB.UTF8String<128>...", 
"body" : "Voici un exemple ( myString ) d'un GSB.UTF8String d'une capacit√© de 128 octets est cr√©√© et le segment de cha√Æne avec la valeur d'une variable STRING (chiffre romain 1968) est initialis√©. Les m√©thodes de STR.IString sont disponibles. √Ä partir de STRING √† IString VAR\n¬† ¬†¬†myString : GSB.UTF8String<128> := (sValue := UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß');¬†\/\/ r√∂misch 1968¬†¬†¬†¬†\n psString : POINTER TO STRING;¬†¬†¬†¬†udiSize, udiLength : UDINT;¬† ¬†¬†xASCII, xOk : BOOL;\nEND_VAR\n \n psString := myString.GetSegment(udiSize=>udiSize, udiLength=>udiLength, xASCII=>xASCII);¬†\/\/ Conversion back to the STRING data type\n \nxOk := (\n myString.IsValid() AND \/\/ A valid UTF-8 encoding is present\n udiSize = 128 AND \/\/ The capacity of the string in bytes\n myString.Len() = 17 AND \/\/ The current length of the string in bytes\n STR.RuneCount(myString) = 6 \/\/ The current number of characters in the string\n); Fonction du g√©n√©rateur de cha√Ænes VAR\n myString : GSB.UTF8String<20> := (sValue := UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß'); \/\/ roman 1968\n sValue : STRING := 'wurden in Mexico-Stadt die';\n wsValue : WSTRING := \"‚Ö©‚Ö®.\";\n diSpace : STR.RUNE := 32;\n myValue : GSB.UTF8String<128> := (sValue := UTF8#'—∫‚Ñì∆¥ŒºœÅ‚ò§·πß·∏â–ΩŒµŒ∑ $$œÅ—ó‚ÑÆ≈Ç‚ÑØ Œ±‚ô≠‚ÑäŒµ‚ÑåŒ± ü‚ä•‚ÑÆ·æî.');\n \n myBuilder : GSB.Builder<(*udiInitialCapacity*) 64, (*usiExtensionFactor*) 50> := (itfString:=myString);\n myResult : GSB.UTF8String<128>;\n \n {attribute 'monitoring_encoding' := 'UTF-8'}\n sResult : STRING(128) := UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß wurden in Mexico-Stadt die ‚Ö©‚Ö®. —∫‚Ñì∆¥ŒºœÅ‚ò§·πß·∏â–ΩŒµŒ∑ $$œÅ—ó‚ÑÆ≈Ç‚ÑØ Œ±‚ô≠‚ÑäŒµ‚ÑåŒ± ü‚ä•‚ÑÆ·æî.';\n \n psResult : POINTER TO STRING;\n udiLength : UDINT;\n xOk : BOOL;\nEND_VAR\n \nmyBuilder.WriteRune(diSpace);\nmyBuilder.WriteString(sValue);\nmyBuilder.WriteRune(diSpace);\nmyBuilder.WriteWString(wsValue);\nmyBuilder.WriteRune(diSpace);\nmyBuilder.WriteIString(myValue);\n \nudiLength := myBuilder.Len(); \/\/ The number of bytes occupied in the builder.\nmyBuilder.ToIString(myResult); \/\/ The individual parts of the string are copied together to myResult.\n \npsResult := myResult.GetSegment(); \nxOk := (psResult^ = sResult); \/\/ Both memory areas should have the same content. Dans l'exemple ci-dessus, une instance du g√©n√©rateur est cr√©√©e avec une capacit√© initiale de 64 octets ( udiInitialCapacity ) et un facteur dynamique de 50 ( usiExtensionFactor ). La cha√Æne g√©n√©r√©e plus haut est toujours transmise dans la d√©claration et, par cons√©quent, le g√©n√©rateur est rempli avec cette cha√Æne ( UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß' ). √Ä l'aide du usiExtensionFactor param√®tre, augmente le g√©n√©rateur de 50¬†% lorsque sa capacit√© actuelle est √©puis√©e. Lire un fichier √† l'aide du g√©n√©rateur VAR\n sPath : STRING := 'myFilePath';\n hFile : RTS_IEC_HANDLE := RTS_INVALID_HANDLE;\n myBuilder : GSB.Builder<(*udiInitialCapacity*) 16#10000, (*usiExtensionFactor*) 50>;\n abyBuffer : ARRAY[0..4095] OF BYTE;\n pbyData : POINTER TO BYTE;\n udiSize : UDINT;\n udiCount : UDINT;\n eEncoding : SCV.ENCODING;\n eErrorID : SCV.ERROR;\n udiResult : RTS_IEC_RESULT;\nEND_VAR\n \nhFile := SysFileOpen(sPath, ACCESS_MODE.AM_READ, ADR(udiResult));\nIF udiResult <> ERRORS.ERR_OK THEN\n \/\/ handle error condition\n RETURN; \nEND_IF\n \nREPEAT \/\/ fake loop - We need the EXIT feature\n pbyData := ADR(abyBuffer);\n udiSize := TO_UDINT(SysFileRead(hFile, pbyData, XSIZEOF(abyBuffer), ADR(udiResult)));\n IF udiResult <> ERRORS.ERR_OK THEN\n \/\/ handle error condition\n EXIT; \n END_IF\n \n \/\/ Determination of the file encoding\n udiCount := SCV.DecodeBOM(pbyData, udiSize, eEncoding=>eEncoding, eErrorID=>eErrorID);\n IF eErrorID <> 0 THEN\n \/\/ handle error condition\n EXIT;\n END_IF\n \n pbyData := pbyData + udiCount;\n udiSize := udiSize - udiCount;\n \n WHILE udiSize > 0 DO\n \/\/ Convert file content to UTF-8 and copy to Builder-Content\n udiCount := myBuilder.WriteMemSegment(pbyData, udiSize, eEncoding, eErrorID=>eErrorID);\n IF eErrorID <> 0 THEN\n \/\/ handle error condition\n EXIT;\n END_IF\n pbyData := ADR(abyBuffer);\n udiSize := TO_UDINT(SysFileRead(hFile, pbyData, XSIZEOF(abyBuffer), ADR(udiResult)));\n IF udiResult <> ERRORS.ERR_OK THEN\n \/\/ handle error condition\n EXIT; \n END_IF\n END_WHILE\nUNTIL TRUE\nEND_REPEAT\n \nIF hFile <> RTS_INVALID_HANDLE THEN\n SysFileClose(hFile);\n hFile := RTS_INVALID_HANDLE;\n udiCount : UDINT;\nEND_IF Analyse du contenu d'une instance de g√©n√©rateur VAR\n myRange : SBD.Range := (itfBuilder := myBuilder);\n diRune : STR.RUNE;\n eError : STR.ERROR;\nEND_VAR\n \nmyRange.Reset();\nWHILE (diRune := myRange.GetNextRune(eErrorID=>eErrorID)) <> 0 AND_THEN eErrorID = 0 DO\n IF UC.IsSpace(diRune) THEN\n \/\/ The characters in the builder which are considered as spaces according to UNICODE are counted.\n udiCount := udiCount + 1;\n END_IF\nEND_WHILE Pour transmettre du contenu cod√© en UTF-8, aucun cache n'est n√©cessaire pour le codage de la conversion car les donn√©es sont d√©j√† cod√©es en UTF-8 dans le g√©n√©rateur. Par cons√©quent, le contenu d'un segment d'un g√©n√©rateur peut √™tre envoy√© directement, par exemple via une connexion TCP\/IP Transport du contenu cod√© en UTF-8 d'un g√©n√©rateur sur le r√©seau VAR\n itfConnection : NBS.IConnection;\n pbySegment : POINTER TO BYTE;\n udiSize : UDINT;\n eError : NBS.ERROR;\nEND_VAR\n \n(* Provide an active itfConnection *)\n \npbySegment:= myBuilder.GetFirstSegment(udiSize=>udiSize, eErrorID=>eErrorID);\nWHILE pbySegment <> 0 AND eErrorID = 0 DO\n eError := itfConnection.Write(pbySegment, udiSize, udiCount=>udiCount);\n IF eError <> 0 OR udiCount <> udiSize THEN\n \/\/ Handle Error\n EXIT;\n END_IF\n pbySegment := myBuilder.GetNextSegment(pbySegment, udiSize=>udiSize, eErrorID=>eErrorID);\nEND_WHILE\n \n(* e.g. Close itfConnection *) " }, 
{ "title" : "En collaboration avec StringPool et RangePool blocs fonctionnels ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4670931838168033733015007444", 
"breadcrumbs" : "CODESYS String Libraries \/ Exemples \/ En collaboration avec StringPool et RangePool blocs fonctionnels ", 
"snippet" : "Le code suivant montre comment utiliser la dynamique IString instances provenant d'un StringPool . StringPool ou un RangePool est bien adapt√© pour √™tre transmis aux parties subordonn√©es d'un programme. Ils peuvent ensuite cr√©er les instances correspondantes √† partir du pool correspondant selon les b...", 
"body" : "Le code suivant montre comment utiliser la dynamique IString instances provenant d'un StringPool . StringPool ou un RangePool est bien adapt√© pour √™tre transmis aux parties subordonn√©es d'un programme. Ils peuvent ensuite cr√©er les instances correspondantes √† partir du pool correspondant selon les besoins, les utiliser, puis renvoyer ces instances dans le pool. Travailler avec StringPool et RangePool VAR\n myString : GSB.UTF8String<256> := (sValue:=UTF8#'Was du nicht willst, dass man dir tu‚Äô, das f√ºg auch keinem andern zu.');\n myRange : STR.Range := (itfString:=myString);\n \n myStringPool : GSB.StringPool<(*udiStringSize*) 30, (*udiInitialCapacity*) 25, (*usiExtensionFactor*) 0>;\n myRangePool : GSB.RangePool<GSB.RANGE_TYPE.ISTRING, (*udiInitialCapacity*) 10, (*usiExtensionFactor*) 0>;\n \n diRune : STR.RUNE;\n eErrorID : STR.ERROR;\n itfSubString : STR.IString;\n liStart, liEnd : LINT;\n udiCount : UDINT;\nEND_VAR\n \nmyRange.Reset();\n\/\/ Decompose myString into substrings and analyze them via a subroutine.\nWHILE (diRune:=myRange.GetNextRune(eErrorID=>eErrorID)) <> 0 AND eErrorID = 0 DO\n IF diRune = 16#2C (*,*) OR diRune = 16#2E (*.*) THEN\n itfSubString := myStringPool.GetString();\n IF itfSubString = 0 THEN\n (* Handle Error *)\n EXIT;\n END_IF\n myString.ToIString(itfSubString, liStart+1, liEnd, eErrorID=>eErrorID);\n IF eErrorID <> 0 THEN\n (* Handle Error *)\n EXIT;\n END_IF\n \/\/ Analyse the substring and use pool's\n \/\/ Will release itfSubString\n udiCount := Analyse(itfSubString, myStringPool, myRangePool);\n (* ... Handle Result ... *)\n IF diRune = 16#2E (*.*) THEN\n EXIT;\n END_IF\n diRune:=myRange.GetNextRune(eErrorID=>eErrorID);\n IF diRune = 16#20 (* space *) AND eErrorID = 0 THEN\n liEnd := liEnd + 1;\n ELSE\n myRange.UngetLastRune();\n END_IF\n liStart := liEnd + 1;\n END_IF\n liEnd := liEnd + 1;\nEND_WHILE " }, 
{ "title" : "Utilisation des cat√©gories de caract√®res Unicode ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4613758488403233733015299155", 
"breadcrumbs" : "CODESYS String Libraries \/ Exemples \/ Utilisation des cat√©gories de caract√®res Unicode ", 
"snippet" : "La norme Unicode vise √† capturer num√©riquement tous les caract√®res du monde entier et √† d√©crire leurs propri√©t√©s. Pour ce faire, les personnages sont regroup√©s en groupes (cat√©gories). Dans la biblioth√®que Unicode, il existe des fonctions qui v√©rifient la cat√©gorie d'un caract√®re. Ces fonctions renv...", 
"body" : "La norme Unicode vise √† capturer num√©riquement tous les caract√®res du monde entier et √† d√©crire leurs propri√©t√©s. Pour ce faire, les personnages sont regroup√©s en groupes (cat√©gories). Dans la biblioth√®que Unicode, il existe des fonctions qui v√©rifient la cat√©gorie d'un caract√®re. Ces fonctions renvoient TRUE si le caract√®re transmis appartient √† la cat√©gorie correspondante¬†; sinon FALSE est renvoy√©. Nom Fonction IsControl Reconna√Æt les caract√®res de contr√¥le g√©n√©raux IsLetter Reconna√Æt les lettres au sens large IsMark Reconna√Æt les combinaisons de caract√®res, par exemple les caract√®res diacritiques IsDigit Reconna√Æt les chiffres d√©cimaux IsLower Reconna√Æt les lettres minuscules IsNumber Reconna√Æt les chiffres et les caract√®res qui s'appliquent aux nombres IsGraphic Reconna√Æt uniquement les caract√®res imprimables (y compris les diff√©rents types d'espaces) IsUpper Reconna√Æt les lettres majuscules IsPunct Reconna√Æt les caract√®res de ponctuation IsPrint Reconna√Æt uniquement les caract√®res imprimables (ne prend en compte que 16#20 (comme caract√®re d'espace) IsTitle Reconna√Æt les lettres majuscules pour les en-t√™tes IsSpace D√©tecte les espaces de diff√©rentes largeurs, les sauts de ligne, etc. IsSymbol Reconna√Æt les symboles dans un sens plus large, par exemple les symboles math√©matiques et les symboles mon√©taires. Le contenu d'un IString ou IBuilder l'instance peut √™tre analys√©e ¬´¬†caract√®re par caract√®re¬†¬ª √† l'aide d'un bloc fonctionnel appropri√© de type Range . Les fonctions de la biblioth√®que Unicode peuvent √™tre tr√®s utiles pour l'analyse Analyse des personnages VAR\n myString : GSB.UTF8String<50> := (sValue:='Hello World!');\n myBuilder : GSB.Builder<100, 0> := (itfString:=myString);\n mySRange : STR.Range := (itfString:=myString);\n myBRange : SBD.Range := (itfBuilder:=myBuilder);\n diSRune, diBRune : STR.RUNE;\n eErrorID : STR.ERROR;\n udiCount : UDINT;\nEND_VAR\n \nWHILE (diSRune:=mySRange.GetNextRune(eErrorID=>eErrorID)) <> 0 AND eErrorID = 0 DO\n diBRune := myBRange.GetNextRune();\n IF diSRune <> diBRune THEN\n (* Solle nicht vorkommen *)\n END_IF\n IF UC.IsSpace(diSrune) THEN\n udiCount := udiCount + 1;\n END_IF\nEND_WHILE " }, 
{ "title" : "Conversion de caract√®res ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4613761628716833733015669185", 
"breadcrumbs" : "CODESYS String Libraries \/ Exemples \/ Conversion de caract√®res ", 
"snippet" : "Convertir les lettres en majuscules ( UC.ToUpper ) Convertissez les lettres en minuscules ( UC.ToLower ) Conversion VAR diRuneA, diRuneB : STR.RUNE; END_VAR diRuneA := 16#1F3; \/\/ U+01F3 = «Ö diRuneB := UC.ToUpper(diRuneA); \/\/ U+01F1 = «± diRuneA := UC.ToLower(diRuneB); \/\/ U+01F3 = «Ö diRuneB := UC.ToTi...", 
"body" : "Convertir les lettres en majuscules ( UC.ToUpper ) Convertissez les lettres en minuscules ( UC.ToLower ) Conversion VAR\n diRuneA, diRuneB : STR.RUNE;\nEND_VAR\n \ndiRuneA := 16#1F3; \/\/ U+01F3 = «Ö\ndiRuneB := UC.ToUpper(diRuneA); \/\/ U+01F1 = «±\ndiRuneA := UC.ToLower(diRuneB); \/\/ U+01F3 = «Ö\ndiRuneB := UC.ToTitle(diRuneA); \/\/ U+01F2 = «≤ " }, 
{ "title" : "Comparaison de cha√Ænes ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4563870076659233733015900115", 
"breadcrumbs" : "CODESYS String Libraries \/ Exemples \/ Comparaison de cha√Ænes ", 
"snippet" : "Sensibilisation aux majuscules STR.Compare ) Pas de distinction majuscules\/minuscules ( UC.EqualFold ) Comparaison de cha√Ænes VAR myFirstString : GSB.UTF8String<50> := (sValue:='test'); mySecondString : GSB.UTF8String<50> := (sValue:='Test'); myThirdString : GSB.UTF8String<50> := (sValue:='CoDeSys')...", 
"body" : "Sensibilisation aux majuscules STR.Compare ) Pas de distinction majuscules\/minuscules ( UC.EqualFold ) Comparaison de cha√Ænes VAR\n myFirstString : GSB.UTF8String<50> := (sValue:='test');\n mySecondString : GSB.UTF8String<50> := (sValue:='Test');\n \n myThirdString : GSB.UTF8String<50> := (sValue:='CoDeSys');\n myFourthString : GSB.UTF8String<50> := (sValue:='CODESYS');\n \n diResult : DINT;\n xEqual : BOOL;\nEND_VAR\n \n\/\/\/ Comparing two Strings lexicographically\n\/\/\/ diResult = 1 --> myFirstString > mySecondString\ndiResult := STR.Compare(myFirstString, mySecondString);\n \n\/\/\/ Unicode defined simple case folding\n\/\/\/ xEqual = TRUE --> myThirdString == myFourthString\nxEqual := UC.EqualFold(\n ADR(myThirdString.sValue), myThirdString.Len(),\n ADR(myFourthString.sValue), myFourthString.Len()\n); " }
]
$(document).trigger('search.ready');
});