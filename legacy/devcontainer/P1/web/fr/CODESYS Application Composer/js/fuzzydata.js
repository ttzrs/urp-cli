$(document).ready(function () {indexDict['fr'] = [{ "title" : "CODESYS Application Composer ", 
"url" : "_ac_start_page.html", 
"breadcrumbs" : "CODESYS Application Composer \/ CODESYS Application Composer ", 
"snippet" : "CODESYS Application Composer est un logiciel permettant de créer efficacement des variantes d'application qui consistent en des blocs fonctionnels récurrents. Sur la base de modules, vous créez une application machine et vous la paramétrez. Le programme PLC est automatiquement généré à partir de cel...", 
"body" : "CODESYS Application Composer est un logiciel permettant de créer efficacement des variantes d'application qui consistent en des blocs fonctionnels récurrents. Sur la base de modules, vous créez une application machine et vous la paramétrez. Le programme PLC est automatiquement généré à partir de cela. Améliore la réutilisabilité et la qualité des pièces d'application Efficacité accrue grâce à la génération automatique d'applications à partir de modules prédéfinis Particulièrement adapté à l'ingénierie de projet simplifiée d'applications dans les domaines de l'usine numérique ou de l'industrie 4.0 Les applications Digital Factory ou Industry 4.0 peuvent être planifiées plus facilement Prêt à être utilisé immédiatement grâce aux générateurs fournis et au concept d'application Clip vidéo : Automatisation des bâtiments avec le CODESYS Application Composer module complémentaire Exemples de projets Vous pouvez installer et mettre à jour CODESYS Application Composer module complémentaire dans CODESYS Installer . " }, 
{ "title" : "Aperçu ", 
"url" : "ac_application_composer_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Aperçu ", 
"snippet" : "le CODESYS Application Composer est utilisé pour créer des applications en utilisant des modules existants. L'utilisateur compose, paramètre et connecte les modules nécessaires pour former une application complète. Cette configuration ne nécessite aucune connaissance en programmation automate et peu...", 
"body" : "le CODESYS Application Composer est utilisé pour créer des applications en utilisant des modules existants. L'utilisateur compose, paramètre et connecte les modules nécessaires pour former une application complète. Cette configuration ne nécessite aucune connaissance en programmation automate et peut donc être réalisée par des techniciens sans expérience en programmation. Les générateurs internes créent des applications CEI 61131-3 complètes et bien structurées, y compris le mappage et les visualisations des E\/S. CODESYS Application Composer se compose de deux composants principaux : Editeur de modules, permettant de composer les modules logiciels développés avec l'éditeur de déclarations de modules Éditeur de déclaration de module pour développer des modules Exemple d'arborescence et de visualisation du module CODESYS Application Composer Pour plus d'informations sur l'éditeur de module, voir : Éditeur de modulesPour plus d'informations sur l'éditeur de déclaration de module, consultez : Éditeur de déclaration de module" }, 
{ "title" : "Éditeur de modules ", 
"url" : "ac_module_editor_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules ", 
"snippet" : "A l'aide des éditeurs d'Application Composer, les instances de module du arborescence des modules peut être configuré et paramétré. Les éditeurs disponibles de l'instance de module s'ouvrent en double-cliquant sur l'objet ou sur le Modifier l'objet commande du menu contextuel : Déploiement IHM Param...", 
"body" : "A l'aide des éditeurs d'Application Composer, les instances de module du arborescence des modules peut être configuré et paramétré. Les éditeurs disponibles de l'instance de module s'ouvrent en double-cliquant sur l'objet ou sur le Modifier l'objet commande du menu contextuel : Déploiement IHM Paramètres E\/S Information Autres éditeurs : Éditeur de modules d'extension Éditeur de séquence Le Comparer les projets La commande peut également être utilisée pour les instances du module Application Composer. " }, 
{ "title" : "Déploiement ", 
"url" : "ac_toplevel.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Déploiement ", 
"snippet" : "Cette boîte de dialogue est uniquement disponible pour les instances de module de niveau supérieur et fournit les paramètres d'application et de tâche. Boîte de dialogue pour les paramètres de niveau supérieur Application : saisi comme cible de génération dans l'instance de module de niveau supérieu...", 
"body" : "Cette boîte de dialogue est uniquement disponible pour les instances de module de niveau supérieur et fournit les paramètres d'application et de tâche. Boîte de dialogue pour les paramètres de niveau supérieur Application : saisi comme cible de génération dans l'instance de module de niveau supérieur. Le Le bouton peut être utilisé pour sélectionner une application existante ou créer une nouvelle application en spécifiant un nom. Si l'application est affectée au pool de POU, alors Mappage d'E\/S n'est pas possible. Dans le cas de modules découplés qui possèdent un module parent, l'application parent est proposée ( [Utiliser l'application parent] ). Tâches standards Dans cette section, jusqu'à trois tâches prédéfinies sont disponibles : une tâche avec une priorité élevée, une avec une priorité moyenne et une avec une priorité faible. Le nom et la disponibilité des tâches sont définis dans le module lui-même et ne peuvent pas être modifiés (dans la boîte de dialogue ci-dessus : Tâche de bus de terrain et Tâche standard ). En plus des tâches prédéfinies, l'utilisateur peut créer une nouvelle tâche en précisant un nom si le \" CREATE_IF_MISSING \" est défini dans la déclaration du module. Le paramètre de la nouvelle tâche peut être défini dans le Paramètres standard du générateur . Tâches spécifiques au module : Ce champ affiche des informations sur les tâches spécifiques au module. " }, 
{ "title" : "E\/S ", 
"url" : "ac_io.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ E\/S ", 
"snippet" : "Cette boîte de dialogue fournit des informations sur les entrées et sorties du module. Les entrées et sorties décrivent la demande d'E\/S des modules et peuvent être connectées aux éléments suivants : Entrées et sorties des appareils Entrées et sorties d'autres instances de module Expressions ou cons...", 
"body" : "Cette boîte de dialogue fournit des informations sur les entrées et sorties du module. Les entrées et sorties décrivent la demande d'E\/S des modules et peuvent être connectées aux éléments suivants : Entrées et sorties des appareils Entrées et sorties d'autres instances de module Expressions ou constantes ST (exemple : à des fins de simulation, les entrées du module booléen peuvent être connectées à TRUE ) En mode en ligne, le Valeur en ligne La colonne est visible et la valeur actuelle du contrôleur est affichée. Aperçu des E\/S de l'interface du module En cliquant sur le Cartographie Le champ ouvre la boîte de dialogue de mappage d'E\/S : Boîte de dialogue pour le mappage des E\/S Canal d'E\/S : En cliquant sur le … Le bouton ouvre une autre boîte de dialogue pour mapper l’entrée\/sortie à une E\/S de périphérique. Expression ST : Cette option permet de mapper l'entrée\/sortie à une expression ST. En cliquant sur le Le bouton ouvre l'assistant de saisie pour sélectionner une variable. Se connecter au module-E\/S : Cette option peut être utilisée pour mapper l'entrée\/sortie sur une E\/S qui n'a aucune connexion. En cliquant sur le Le bouton ouvre l'assistant de saisie pour sélectionner un module. Pas de connection : Pas de mappage des entrées\/sorties. Cette option est similaire à Connexion manquante , mais il ne génère pas de message d'avertissement. Connexion manquante : Cette option est celle par défaut et génère un avertissement dans la vue des messages lors de la génération du projet. Les E\/S connectées automatiquement par le générateur d'appareils sont signalées par (AUTO) dans la colonne IN\/OUT et sont désactivés. Si le mappage est toujours modifié manuellement, un avertissement s'affiche indiquant que cette action écrasera le mappage automatique. Si une connexion générée automatiquement est écrasée par une connexion définie manuellement, ce canal d'E\/S n'est plus pris en compte dans les opérations du générateur de périphérique. " }, 
{ "title" : "IHM ", 
"url" : "ac_hmi.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ IHM ", 
"snippet" : "Dans cette boîte de dialogue, vous définissez le modèle de page et les visualisations de module qui doivent être intégrées dans la visualisation de niveau supérieur. Créer un onglet de niveau supérieur : Crée un onglet au niveau supérieur de la visualisation qui mène directement à la visualisation d...", 
"body" : "Dans cette boîte de dialogue, vous définissez le modèle de page et les visualisations de module qui doivent être intégrées dans la visualisation de niveau supérieur. Créer un onglet de niveau supérieur : Crée un onglet au niveau supérieur de la visualisation qui mène directement à la visualisation de cette instance de module. Raccourci clavier : Avec le raccourci défini ici, vous pouvez basculer directement vers cette page de visualisation. Le paramètre par défaut du raccourci est défini dans la déclaration du module dans le fichier std.Visu section. Modèle de pages : Un modèle pour la visualisation du module peut être sélectionné ici et sera utilisé comme arrière-plan pour la visualisation. La liste déroulante fournit une sélection de toutes les visualisations définies dans la déclaration du module. La première visualisation dans la déclaration du module est sélectionnée par défaut. Si Non visualisation définie, alors \"Aucun\" s'affiche. Intégrer la visualisation : Cette fonction permet d'embarquer la visualisation de l'instance de module dans le module supérieur suivant ( Ancêtre suivant ) ou dans toute autre visualisation de l'instance de module. S'il est défini dans le module, alors le %PAGE_VISU% un espace réservé peut être sélectionné. Dans ce cas, l'écran de visualisation créé pour l'instance de module est intégré. Plusieurs entrées peuvent être définies. Pour plus d'informations sur la création d'écrans de visualisation, voir : Génération d'écrans de visualisation " }, 
{ "title" : "Paramètre ", 
"url" : "ac_parameter.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Paramètre ", 
"snippet" : "Cette boîte de dialogue affiche tous les paramètres disponibles de l'instance de module qui peuvent être paramétrés. Les entrées dans Paramètre , Taper , Description , Min. , et Max. sont uniquement à titre informatif. Vous pouvez double-cliquer sur le Valeur champ pour le modifier. Boîte de dialogu...", 
"body" : "Cette boîte de dialogue affiche tous les paramètres disponibles de l'instance de module qui peuvent être paramétrés. Les entrées dans Paramètre , Taper , Description , Min. , et Max. sont uniquement à titre informatif. Vous pouvez double-cliquer sur le Valeur champ pour le modifier. Boîte de dialogue de paramètres des instances de module Les valeurs des paramètres sont affichées en caractères gras lorsqu'elles ont été explicitement définies ; sinon les polices restent normales. Les paramètres modifiés peuvent être réinitialisés à leur valeur par défaut au moyen du Réinitialiser aux valeurs par défaut commande dans le menu contextuel. Les paramètres en polices rouges doivent être définis par l'utilisateur car sinon une erreur s'affichera lors de la création. En mode en ligne, le Valeur en ligne La colonne est visible et la valeur actuelle est affichée. Si vous modifiez la valeur du paramètre dans le Valeur colonne, la valeur est également modifiée sur le contrôleur. Utilisez le Utiliser les valeurs en ligne commande pour copier la valeur en ligne actuelle dans le Valeur et par conséquent de l'utiliser comme valeur de paramètre de l'instance de module dans l'arborescence des modules. En général, les valeurs de paramètre sont affichées et éditées dans la syntaxe des littéraux CEI (exemple : valeur de paramètre de type TIME comme t#7s35ms . Après la modification d'un paramètre, le Générer La commande doit être exécutée pour créer à nouveau le projet. Si vous avez modifié des valeurs de paramètres dans les instances de module en mode en ligne, vous pouvez utiliser le Valeurs de paramètres différentes commande pour obtenir une liste des paramètres modifiés dans le messages voir. Un double-clic sur ce type de message ouvre la boîte de dialogue des paramètres de l'instance de module concernée où les valeurs de paramètre modifiées sont indiquées par un cadre rouge. " }, 
{ "title" : "Information ", 
"url" : "ac_information.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Information ", 
"snippet" : "Cette boîte de dialogue d'informations affiche des détails sur le Icône , Nom , Description , Source , Version , Fournisseur , et Catégorie de l'instance de module. En option, plusieurs liens peuvent également être affichés. En cliquant sur les liens, vous ouvrez l'application correspondante. Le con...", 
"body" : "Cette boîte de dialogue d'informations affiche des détails sur le Icône , Nom , Description , Source , Version , Fournisseur , et Catégorie de l'instance de module. En option, plusieurs liens peuvent également être affichés. En cliquant sur les liens, vous ouvrez l'application correspondante. Le contenu de la première URL est affiché sur le côté droit. Pour que les liens soient affichés ici, ils doivent être définis dans le MetaData section de la déclaration du module. Les domaines et sites de confiance sont définis dans l'application Options du compositeur . Si vous cliquez sur une URL qui n'est pas définie comme « de confiance », une boîte de dialogue s'ouvre dans la vue de droite. Dans cette vue, vous pouvez ensuite ajouter l'URL aux domaines ou sites de confiance. " }, 
{ "title" : "Modèle Source ", 
"url" : "ac_copyfb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Modèle Source ", 
"snippet" : "Cette boîte de dialogue définit les blocs fonctionnels du pool de POU qui sont copiés dans l'application lorsque la commande Générer est exécutée. Pour copier des blocs fonction, le SourceTemplate Modèle Source-Le générateur doit être activé dans le Configuration du générateur . La boîte de dialogue...", 
"body" : "Cette boîte de dialogue définit les blocs fonctionnels du pool de POU qui sont copiés dans l'application lorsque la commande Générer est exécutée. Pour copier des blocs fonction, le SourceTemplate Modèle Source-Le générateur doit être activé dans le Configuration du générateur . La boîte de dialogue affiche tous les blocs fonctionnels définis dans le SourceTemplate section de la déclaration du module. Source-FB : Identifiant des blocs fonctions à copier C'est copier : VRAI\/FAUX : Le bloc fonction est copié ou non copié. Si la IsMandatory Le paramètre est défini comme TRUE dans la déclaration du module, la valeur ne peut pas être modifiée ici. Type de source FB : Nom du bloc fonction à copier " }, 
{ "title" : "Éditeur : ExportDevices ", 
"url" : "ac_export_devices.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Éditeur : ExportDevices ", 
"snippet" : "Avec cet éditeur, vous pouvez sélectionner un fichier généré par une exportation d'appareil. Cet appareil est ajouté à l'arborescence des appareils lors de la génération du projet. Ce option de configuration est requis lorsque des périphériques dotés de propriétés spéciales sont ajoutés et lorsque l...", 
"body" : "Avec cet éditeur, vous pouvez sélectionner un fichier généré par une exportation d'appareil. Cet appareil est ajouté à l'arborescence des appareils lors de la génération du projet. Ce option de configuration est requis lorsque des périphériques dotés de propriétés spéciales sont ajoutés et lorsque les périphériques ne peuvent pas être ajoutés par le générateur de périphériques. Identifiant : Identifiant issu de la déclaration du module Fichier exporté : Sélection de tous les fichiers définis dans la déclaration du module Si un seul fichier est défini dans la déclaration du module, ce fichier n'est pas affiché ici. Plusieurs ExportDevices peuvent exister pour chaque périphérique. Ceux-ci sont différenciés par leurs identifiants de la déclaration du module et affichés ici. " }, 
{ "title" : "Boîte de dialogue : Options : Compositeur ", 
"url" : "ac_options.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Boîte de dialogue : Options : Compositeur ", 
"snippet" : "Ce sous-dialogue de CODESYS la boîte de dialogue des options fournit différents onglets pour CODESYS Application Composer réglages....", 
"body" : "Ce sous-dialogue de CODESYS la boîte de dialogue des options fournit différents onglets pour CODESYS Application Composer réglages. " }, 
{ "title" : "Onglet : Général ", 
"url" : "ac_options.html#UUID-f0422aff-2b78-70d6-5e11-24472852cab0_ce9930fe2eec0a8640e0080c1b5_id_71025f62d62f3d9cc0a8640e01589d60", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Boîte de dialogue : Options : Compositeur \/ Onglet : Général ", 
"snippet" : "Général Afficher la sélection de niveau supérieur avant la génération : Vous pouvez cliquer Compositeur → Générer pour ouvrir une boîte de dialogue permettant de sélectionner les modules de niveau supérieur. Vous pouvez réduire le temps de génération de l'application en désélectionnant les modules q...", 
"body" : "Général Afficher la sélection de niveau supérieur avant la génération : Vous pouvez cliquer Compositeur → Générer pour ouvrir une boîte de dialogue permettant de sélectionner les modules de niveau supérieur. Vous pouvez réduire le temps de génération de l'application en désélectionnant les modules qui ne changent plus. Éditeurs Type d'éditeur de paramètres Affichage de la Paramètres sur le Paramètres onglet (éditeur de modules). Vue arborescente : Les groupes de paramètres sont affichés dans l'éditeur sous forme d'arborescence. Vue par onglets : Les groupes de paramètres sont affichés dans l'éditeur sous forme d'onglets uniques. Analyse Analyse automatique (enregistrée avec le projet) : Le CODESYS Application Composer recherche automatiquement les modules existants et les instances de module lorsqu'une nouvelle bibliothèque est insérée dans la vue POU. : Le CODESYS Application Composer recherche les modules et instances de modules existants uniquement dans les cas suivants : Après avoir ouvert le projet Après avoir inséré une instance de module dans l'arborescence des modules si aucune recherche n'a été effectuée Remarque : Ce paramètre est enregistré avec le projet. Domaines de confiance Sites Web de confiance Les URL de cette liste peuvent être affichées sur le Information onglet de l'éditeur de modules. Prérequis : L'URL est définie dans la section MetaData de la déclaration du module. " }, 
{ "title" : "Onglet : Editeur de séquence ", 
"url" : "ac_options.html#UUID-f0422aff-2b78-70d6-5e11-24472852cab0_ce9930fe2eec0a8640e0080c1b5_id_70cecd07d62f3d9fc0a8640e00b85eda", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Boîte de dialogue : Options : Compositeur \/ Onglet : Editeur de séquence ", 
"snippet" : "Général Afficher les références Afficher les paramètres Afficher le mappage des E\/S Afficher les noms d'instances Afficher le commentaire Afficher les variables en ligne : L'élément respectif est affiché dans l'étape de éditeur de séquence . Afficher Largeur de marche : Largeur de l'en-tête de l'ong...", 
"body" : "Général Afficher les références Afficher les paramètres Afficher le mappage des E\/S Afficher les noms d'instances Afficher le commentaire Afficher les variables en ligne : L'élément respectif est affiché dans l'étape de éditeur de séquence . Afficher Largeur de marche : Largeur de l'en-tête de l'onglet (en pixels) Valeurs valides : 25–500. Distance de pas (vert.) Distance entre les pas de séquence (en pixels) Valeurs valides : 10–100 Norme. connexion Une connexion Connexion B Couleurs des lignes de connexion entre les étapes de la séquence Les couleurs de Une connexion et Connexion B sont utilisés après une étape de branchement. Des textes Paramètres Les références Canaux d'E\/S Couleurs d'affichage du texte, des paramètres, des références et des canaux d'E\/S Police du texte Le bouton ouvre la boîte de dialogue par défaut pour définir la police du texte dans l'éditeur. Police du lien Le bouton ouvre la boîte de dialogue par défaut pour définir la police d'étiquetage des liens. " }, 
{ "title" : "Éditeur de séquence ", 
"url" : "ac_sequenceeditor.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Éditeur de séquence ", 
"snippet" : "L'éditeur de séquence est un éditeur graphique qui affiche et édite les arborescence des modules dans un organigramme. Il permet d'ajouter et de supprimer des modules ou de modifier leurs propriétés. L'éditeur fournit également un mode en ligne, destiné à être utilisé pour le suivi des étapes active...", 
"body" : "L'éditeur de séquence est un éditeur graphique qui affiche et édite les arborescence des modules dans un organigramme. Il permet d'ajouter et de supprimer des modules ou de modifier leurs propriétés. L'éditeur fournit également un mode en ligne, destiné à être utilisé pour le suivi des étapes actives du module et des points d'arrêt du module, afin de pouvoir être utilisé pour le débogage. Le déroulement des séquences lui-même (exécution et ordre des séquences) n'est pas implémenté par l'éditeur. Ceci est utilisé uniquement pour afficher et modifier l’arborescence des modules. Toute fonctionnalité ou logique des étapes du module doit être implémentée dans les blocs fonctionnels des modules comme CEI ( CODESYS ) code du programme Éditeur de séquence L'éditeur est disponible pour tous les modules avec la définition Racine dans la rubrique mse.Sequence de la déclaration du module. Le contenu de l'éditeur correspond à l'arborescence des modules. Chaque modification dans l'arborescence des modules changera l'éditeur de séquence et vice versa. Seules les instances de module insérées sous un \" Root \" instance. Leur contenu affiché est défini par les définitions de la section mse.Sequence de leur déclaration de module. L'apparence des étapes dépend de la définition dans la déclaration du module. Outre la définition Root il existe les trois définitions suivantes : Étape: Parallèle: Bifurquer: " }, 
{ "title" : "Données affichées dans la zone de séquence ", 
"url" : "ac_sequenceeditor.html#UUID-c7b42e58-c2ec-c00e-5692-55a5d60221bd_d125a077ca9f50ac0a8640e01732ee5_id_ad20551e9b6d77a9c0a865200163ff8b", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Éditeur de séquence \/ Données affichées dans la zone de séquence ", 
"snippet" : "Dans la case de chaque étape, le nom du type de module et le nom de l'instance de module (facultatif) ainsi que l'icône définie seront affichés. Cette dernière correspond à l'icône définie dans les métadonnées du configuration des modules . Les canaux paramètres et E\/S de l'instance de module seront...", 
"body" : "Dans la case de chaque étape, le nom du type de module et le nom de l'instance de module (facultatif) ainsi que l'icône définie seront affichés. Cette dernière correspond à l'icône définie dans les métadonnées du configuration des modules . Les canaux paramètres et E\/S de l'instance de module seront également affichés, s'ils sont définis ainsi dans la section mse.Sequence . Il en va de même pour les références, même si l’on distingue deux types différents de références : Références générales aux instances de module Références de saut, qui définissent un saut dans la séquence. Les instances de module référencées seront affichées avec leur chemin relatif dans l'arborescence des modules (exemple : ..\/..\/WaitTime ). Le survenant ..\/ sont écrits dans une notation abrégée (exemple : .\/..\/..\/ devient 3x[..\/] ). Un commentaire, qui sera affiché séparé par une ligne, peut être ajouté à chaque étape. Ceci est enregistré séparément pour chaque étape (instance de module). Si le texte affiché des noms de module, des paramètres, des canaux IO ou des références ne rentre pas dans l'espace donné au sein de l'étape, le texte sera renvoyé sur une deuxième ligne. Si nécessaire, le texte sera coupé. Dans ce cas, un … sera ajouté. En résumé, jusqu'à un maximum de quatre listes\/entrées supplémentaires peuvent être définies pour une étape de séquence : Paramètres : nom du paramètre + valeur du paramètre Voies d'E\/S : nom de la voie + nom de la cible de la voie Références : icône, chemin et nom de l'instance de module référencée Pour les références de saut : >> + icône, chemin et nom de l'instance du module de références Commentaires : Ligne horizontale + commentaire Pour plus d'informations sur l'éditeur de séquence, voir dans les chapitres d'aide Travailler dans l'éditeur de séquence et Éditeur de séquence en mode en ligne " }, 
{ "title" : "Travailler avec l'éditeur de séquence ", 
"url" : "ac_sequenceeditor_edit.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Éditeur de séquence \/ Travailler avec l'éditeur de séquence ", 
"snippet" : "Lorsque le pointeur de la souris est déplacé sur une étape, celle-ci est surlignée en gris. Lorsque le pointeur est déplacé sur l'extrémité vide d'une connexion, un triangle gris s'affiche. Les étapes peuvent être sélectionnées en cliquant sur changer la couleur de l'étape sélectionnée en rouge. La ...", 
"body" : "Lorsque le pointeur de la souris est déplacé sur une étape, celle-ci est surlignée en gris. Lorsque le pointeur est déplacé sur l'extrémité vide d'une connexion, un triangle gris s'affiche. Les étapes peuvent être sélectionnées en cliquant sur changer la couleur de l'étape sélectionnée en rouge. La multisélection d'étapes est également possible. Les étapes peuvent être déplacées par glisser-déposer. Quand le Ctrl est également enfoncée, les étapes sont copiées. Les positions d'insertion possibles pour les étapes déplacées ou copiées sont marquées par une ligne pointillée rouge. Déplacer les éléments par glisser-déposer Lorsque le pointeur de la souris est déplacé sur un élément de saut dont la cible est disponible dans la séquence actuelle, le champ de texte de la référence de saut est également relié à l'étape cible spécifiée par une ligne pointillée. La cible est également marquée d'un cercle pointillé. Cible de saut d'une référence de saut Édition avec les canaux d'E\/S Un double-clic sur le canal d'E\/S ouvre la boîte de dialogue de mappage d'E\/S, qui est également utilisée dans l'éditeur d'E\/S des instances de module. Pour plus d'informations, voir : E\/S " }, 
{ "title" : "Commandes de l'éditeur de séquence ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_00bbee939046545bc0a8652000fd02ce", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Éditeur de séquence \/ Travailler avec l'éditeur de séquence \/ Commandes de l'éditeur de séquence ", 
"snippet" : "Un clic droit sur une étape de la séquence ou sur le triangle gris (étape de branche parallèle vide) fournit les commandes du menu contextuel qui sont disponibles sur cette position. En plus de la norme Couper , Copie , et Pâte commandes, le menu propose les commandes suivantes : Ajouter une étape a...", 
"body" : "Un clic droit sur une étape de la séquence ou sur le triangle gris (étape de branche parallèle vide) fournit les commandes du menu contextuel qui sont disponibles sur cette position. En plus de la norme Couper , Copie , et Pâte commandes, le menu propose les commandes suivantes : Ajouter une étape après Toutes les étapes suivantes sont affichées dans une commande de liste. En conséquence, seules les étapes et les modules qui conviendraient à l'emplacement de module à cet emplacement sont ajoutés. Ajouter une étape après les sous-séquences fermées Cette commande peut être utilisée lorsque des sous-séquences de branches et des séquences parallèles doivent être fermées. L'étape insérée est ajoutée après les sous-séquences et non à l'intérieur de celles-ci. Il n'est disponible que pour les positions ayant des sous-séquences fermables. Ajouter un commentaire Ajoute un commentaire à l'étape sélectionnée. Définir la référence de saut Cette commande n'est disponible que dans le menu contextuel d'un élément de saut. La souris peut être utilisée pour tracer une ligne rouge jusqu'à l'étape cible. Le menu contextuel des éléments de séquence sélectionnés peut également être ouvert avec le barre d'espace . Menu contextuel d'une branche Les étapes consécutives sont reliées par des flèches. Pour l'élément branche, des couleurs différentes peuvent être définies pour les deux branches. Pour plus d'informations, voir : mse.Sequence. Les couleurs sont définies dans le CODESYS choix ( Éditeur de séquence ). " }, 
{ "title" : "Changer la position sur les pas de séquence ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_74415e1a90465440c0a865200120cb10", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Éditeur de séquence \/ Travailler avec l'éditeur de séquence \/ Changer la position sur les pas de séquence ", 
"snippet" : "Pour modifier la position d'un élément de séquence, l'élément doit être sélectionné et déplacé à l'aide de la touche centrale de la souris. La disposition des paramètres au sein de l'étape peut également être modifiée. Changer la position d'un pas de séquence Par conséquent, seule la position de l'é...", 
"body" : "Pour modifier la position d'un élément de séquence, l'élément doit être sélectionné et déplacé à l'aide de la touche centrale de la souris. La disposition des paramètres au sein de l'étape peut également être modifiée. Changer la position d'un pas de séquence Par conséquent, seule la position de l'élément peut être déplacée dans l'éditeur – la modification de la position dans une séquence et donc de l'ordre n'est pas possible. " }, 
{ "title" : "Modifier paramètre \/ commentaires \/ nom d'instance \/ canaux d'E\/S ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_a585f36190465431c0a8652000ac8cda", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Éditeur de séquence \/ Travailler avec l'éditeur de séquence \/ Modifier paramètre \/ commentaires \/ nom d'instance \/ canaux d'E\/S ", 
"snippet" : "Pour changer un paramètre , il faut double-cliquer dessus. Selon le type de données de la variable, le champ peut être modifié ou la valeur de la variable peut être sélectionnée dans une zone de liste (exemple : TRUE ou FALSE ). Les commentaires ou les noms d'instances peuvent également être modifié...", 
"body" : "Pour changer un paramètre , il faut double-cliquer dessus. Selon le type de données de la variable, le champ peut être modifié ou la valeur de la variable peut être sélectionnée dans une zone de liste (exemple : TRUE ou FALSE ). Les commentaires ou les noms d'instances peuvent également être modifiés en double-cliquant. " }, 
{ "title" : "Édition des références ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_939c29699046541bc0a865200038e978", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Éditeur de séquence \/ Travailler avec l'éditeur de séquence \/ Édition des références ", 
"snippet" : "Une référence peut être modifiée en cliquant dessus avec le bouton droit. Le menu contextuel propose une liste de références pouvant être insérées à cet emplacement. Définir les références En cas de référence de saut, le menu contextuel fournit la Définir la référence de saut commande. L'exécution d...", 
"body" : "Une référence peut être modifiée en cliquant dessus avec le bouton droit. Le menu contextuel propose une liste de références pouvant être insérées à cet emplacement. Définir les références En cas de référence de saut, le menu contextuel fournit la Définir la référence de saut commande. L'exécution de cette commande permet de définir la cible du saut à l'aide de la souris. Une ligne pointillée rouge est tracée vers la cible, qui peut être définie en cliquant dessus. Une référence de saut existante peut être supprimée avec le Supprimer dans le menu contextuel. Définir la référence de saut " }, 
{ "title" : "Éditeur de séquence en mode en ligne ", 
"url" : "ac_sequenceeditor_onlinemode.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Éditeur de séquence \/ Éditeur de séquence en mode en ligne ", 
"snippet" : "Une fois l'application connectée, l'éditeur de séquence passe en mode en ligne. L'apparence des étapes du module en mode en ligne est très similaire à celle du mode hors ligne. Toutes les étapes sont affichées, mais elles ne peuvent pas être sélectionnées ou modifiées comme en mode hors ligne. Ce mo...", 
"body" : "Une fois l'application connectée, l'éditeur de séquence passe en mode en ligne. L'apparence des étapes du module en mode en ligne est très similaire à celle du mode hors ligne. Toutes les étapes sont affichées, mais elles ne peuvent pas être sélectionnées ou modifiées comme en mode hors ligne. Ce mode offre également la possibilité d'afficher des valeurs variables au sein d'une étape. Commandes en mode en ligne En mode connecté, l'éditeur de séquence propose deux commandes supplémentaires dans la Compositeur menu: Points d'arrêt actifs vers l'étape suivante Vue centrale vers les points d'arrêt " }, 
{ "title" : "Étape active ", 
"url" : "ac_sequenceeditor_onlinemode.html#UUID-2af85472-49e7-4d96-1c40-aacbe534fb38_cd6429848b1bdae2c0a8640e002e3857_id_e0ed25b7911507a5c0a8640e003e283b", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Éditeur de séquence \/ Éditeur de séquence en mode en ligne \/ Étape active ", 
"snippet" : "S'il est correctement déclaré dans le déclaration de module , l'étape active sera affichée en jaune : Mode en ligne – Étape active...", 
"body" : "S'il est correctement déclaré dans le déclaration de module , l'étape active sera affichée en jaune : Mode en ligne – Étape active " }, 
{ "title" : "Points d'arrêt ", 
"url" : "ac_sequenceeditor_onlinemode.html#UUID-2af85472-49e7-4d96-1c40-aacbe534fb38_cd6429848b1bdae2c0a8640e002e3857_id_e06ef3f19ba07a7bc0a8652001bdb8af", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Éditeur de séquence \/ Éditeur de séquence en mode en ligne \/ Points d'arrêt ", 
"snippet" : "S'il est correctement déclaré dans la déclaration du module, l'éditeur vous permet de définir des points d'arrêt. Le point d'arrêt d'une étape peut être défini\/réinitialisé par le Basculer le point d'arrêt commande du menu contextuel de l’étape. Un point d'arrêt activé est indiqué par une bordure ro...", 
"body" : "S'il est correctement déclaré dans la déclaration du module, l'éditeur vous permet de définir des points d'arrêt. Le point d'arrêt d'une étape peut être défini\/réinitialisé par le Basculer le point d'arrêt commande du menu contextuel de l’étape. Un point d'arrêt activé est indiqué par une bordure rouge. Si le point d'arrêt est actif (la séquence s'arrête sur le point d'arrêt), l'étape sera affichée en rouge. Mode en ligne – Points d'arrêt Pour plus d'informations, voir : mse.Sequence" }, 
{ "title" : "Éditeur de modules d'extension ", 
"url" : "ac_editor_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Éditeur de modules d'extension ", 
"snippet" : "L'éditeur de modules d'extension permet de définir les extensions et de fournir les quatre Métadonnées , Paramètre, E\/S, et IHM onglets. L'éditeur peut être ouvert par un double-clic sur le bloc fonction dans le POU pool (dans le répertoire selon le nom donné à l'extension). La gestion des erreurs E...", 
"body" : "L'éditeur de modules d'extension permet de définir les extensions et de fournir les quatre Métadonnées , Paramètre, E\/S, et IHM onglets. L'éditeur peut être ouvert par un double-clic sur le bloc fonction dans le POU pool (dans le répertoire selon le nom donné à l'extension). La gestion des erreurs En cas d'erreurs fatales interdisant un affichage des éditeurs, les messages d'erreur seront affichés sur l'écran. Métadonnées page. Les pages de l'éditeur sont désactivées afin qu'elles ne puissent réagir à aucune entrée. Un exemple de ce type d’erreur est un bloc fonctionnel de module manquant. " }, 
{ "title" : "Modifier les événements ", 
"url" : "ac_editor_extension_module.html#UUID-91f9cff1-6f9e-ea6b-b3cd-d65abac7523b_ef0072b48b6aa7c0a8640e00080c11_id_4681e6c5b4a5a074c0a8640e01e5e429", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Éditeur de modules d'extension \/ Modifier les événements ", 
"snippet" : "Le contenu des éditeurs est automatiquement mis à jour en cas de modification du bloc fonctionnel, de la liste de textes, du pool d'images ou de la visualisation correspondant. (Les objets mentionnés seront considérés comme \"correspondants\" s'ils se trouvent dans le même dossier que le module d'exte...", 
"body" : "Le contenu des éditeurs est automatiquement mis à jour en cas de modification du bloc fonctionnel, de la liste de textes, du pool d'images ou de la visualisation correspondant. (Les objets mentionnés seront considérés comme \"correspondants\" s'ils se trouvent dans le même dossier que le module d'extension.) " }, 
{ "title" : "Métadonnées ", 
"url" : "ac_metadata_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Éditeur de modules d'extension \/ Métadonnées ", 
"snippet" : "Sur cet onglet du Éditeur de modules d'extension , la description et la catégorie s'affichent. Les textes affichés (à l'exception de la catégorie) sont lus à partir d'une liste de textes. Le langage actuellement utilisé du système de programmation est utilisé à cet effet. S'il n'y a pas de texte dis...", 
"body" : "Sur cet onglet du Éditeur de modules d'extension , la description et la catégorie s'affichent. Les textes affichés (à l'exception de la catégorie) sont lus à partir d'une liste de textes. Le langage actuellement utilisé du système de programmation est utilisé à cet effet. S'il n'y a pas de texte disponible dans cette langue, le texte par défaut sera utilisé. S'il n'y a aucune saisie de texte, aucun texte ne sera affiché. Comme la liste de textes, les images sont lues à partir du pool d'images. Boîte de dialogue du module d'extension Métadonnées Les boutons à droite des valeurs affichées ouvrent la ligne correspondante dans la liste de textes ou dans le pool d'images et permettent ainsi de modifier les textes. S'il n'y a pas de texte\/image avec l'ID correspondant, un nouvel élément avec cet ID sera créé. " }, 
{ "title" : "Paramètre ", 
"url" : "ac_parameters_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Éditeur de modules d'extension \/ Paramètre ", 
"snippet" : "Sur l'onglet du éditeur de module d'extension , les paramètres du module d'extension sont répertoriés dans un tableau. Boîte de dialogue du module d'extension : Paramètre Le Identifiant , Variable , Taper , et Défaut les colonnes sont en lecture seule. Dans le Nom et Description colonnes, vous pouve...", 
"body" : "Sur l'onglet du éditeur de module d'extension , les paramètres du module d'extension sont répertoriés dans un tableau. Boîte de dialogue du module d'extension : Paramètre Le Identifiant , Variable , Taper , et Défaut les colonnes sont en lecture seule. Dans le Nom et Description colonnes, vous pouvez cliquer sur la ligne correspondante (quand elle est déjà sélectionnée) ou sur le barre d'espace pour accéder directement à la ligne correspondante de la liste de textes correspondante. Le texte affiché est lu dans la liste de textes dans la langue actuellement définie pour le système de programmation. Si cette langue manque dans la liste de textes, le texte par défaut de l'entrée sera utilisé. Dans la colonne Défaut la valeur d'initialisation du paramètre sera affichée. Ce tableau prend en charge la sélection multiple d'entrées et la manipulation standard avec la souris et le clavier. Toutes les actions qui modifient les paramètres peuvent être annulées ou rétablies au moyen du standard annuler et Refaire commandes. Le Couper , Copie , et Pâte les fonctions ne sont pas prises en charge. Vous pouvez utiliser les boutons fléchés ou les Alt + ↑ et Alt + ↓ des raccourcis pour déplacer le paramètre sélectionné vers le haut ou vers le bas pour modifier l'ordre. Vous pouvez utiliser le bouton avec le X ou la norme Del commande pour supprimer les paramètres sélectionnés. Toutes les erreurs ou avertissements concernant les paramètres seront affichés au bas de la liste des messages. Si un message est sélectionné, le paramètre correspondant sera sélectionné dans la liste des paramètres ci-dessus. Le bouton avec l'astérisque ou le Alt + n Un raccourci (si le tableau a le focus) peut être utilisé pour ouvrir le Nouveau paramètre dialogue: Boîte de dialogue du module d'extension : Nouveau paramètre Dans la partie supérieure de la boîte de dialogue, un tableau hiérarchique avec toutes les variables compatibles du bloc fonction est affiché. Pour activer le D'ACCORD bouton une variable doit être sélectionnée et un unique Identifiant doit être saisi. Si la Identifiant n'est pas unique, un point d'exclamation rouge avec un texte d'erreur y est ajouté. Dans les champs Nom et Description le texte standard peut être saisi et sera stocké dans la liste de textes associée. Les textes des différentes langues doivent ensuite être ajoutés à la liste de textes. Une variable est affichée s'il s'agit d'une variable d'entrée d'un module fonction ou d'une variable locale d'une structure. Une variable peut être sélectionnée si elle est de type primitif. " }, 
{ "title" : "E\/S ", 
"url" : "ac_io_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Éditeur de modules d'extension \/ E\/S ", 
"snippet" : "Cet onglet du éditeur de modules d'extension et la boîte de dialogue de création de nouvelles E\/S se comportent de la même manière que la Paramètres languette. Au lieu de la colonne Défaut la direction Entrée\/Sortie de l’entrée\/sortie s’affiche. Boîte de dialogue du module d'extension : E\/S...", 
"body" : "Cet onglet du éditeur de modules d'extension et la boîte de dialogue de création de nouvelles E\/S se comportent de la même manière que la Paramètres languette. Au lieu de la colonne Défaut la direction Entrée\/Sortie de l’entrée\/sortie s’affiche. Boîte de dialogue du module d'extension : E\/S " }, 
{ "title" : "IHM ", 
"url" : "ac_hmi_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Éditeur de modules d'extension \/ IHM ", 
"snippet" : "Cet onglet du éditeur de modules d'extension permet de définir le visualisations de pages aussi bien que visualisations intégrées . Les deux champs de texte permettent de définir plusieurs noms de visualisation, séparés par une virgule. Boîte de dialogue du module d'extension : IHM...", 
"body" : "Cet onglet du éditeur de modules d'extension permet de définir le visualisations de pages aussi bien que visualisations intégrées . Les deux champs de texte permettent de définir plusieurs noms de visualisation, séparés par une virgule. Boîte de dialogue du module d'extension : IHM " }, 
{ "title" : "Écrans de visualisation ", 
"url" : "f_application_composer_visualization_pages.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Écrans de visualisation ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Modèles de niveau supérieur ", 
"url" : "ac_toplevel_templates.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Écrans de visualisation \/ Modèles de niveau supérieur ", 
"snippet" : "Un modèle de niveau supérieur est un modèle pour la page de démarrage de la visualisation générée. Il contient un cadre comme espace réservé pour les pages spécifiques à l'utilisateur et des onglets permettant de basculer entre les différentes pages. En option, il y a des boutons pour naviguer vers ...", 
"body" : "Un modèle de niveau supérieur est un modèle pour la page de démarrage de la visualisation générée. Il contient un cadre comme espace réservé pour les pages spécifiques à l'utilisateur et des onglets permettant de basculer entre les différentes pages. En option, il y a des boutons pour naviguer vers les pages et une ligne de statut et d'adresse. Le modèle de niveau supérieur peut être sélectionné dans les paramètres du Générateur de visualisation . le AC_ModuleBase bibliothèque qui fait partie de l'installation standard de CODESYS Application Composer contient trois modèles de niveau supérieur : AC.GenVisu_Toplevel_Template , AC.Toplevel_Vertical_Template et AC.Toplevel_3S_Vertical_Template . Modèles standards de niveau supérieur Modèle de niveau supérieur : AC_Toplevel_3S_Vertical_Template Outre les modèles préparés, il est également possible de créer des modèles de niveau supérieur définis par l'utilisateur. Éléments des modèles de niveau supérieur (1) : Navigation : Haut \/ Précédent \/ Suivant (2) : Cadre pour afficher les pages (3) : onglet pour une navigation directe vers les pages de niveau supérieur (4) : Ligne d'état (5) : Ligne d'adresse : Chemin d'instance de l'instance de modules affichée Les éléments du modèle de visualisation sont identifiés par leurs noms d'éléments. Dans la liste ci-dessous, le nom des éléments est écrit entre parenthèses. Éléments obligatoires du modèle [Frame] : Cadre principal qui affiche les pages de visualisation. Pour de meilleurs résultats, le type d'échelle du cadre doit être défini sur \"isotrope\". [Tab_Template_1] , [Tab_Template_2] : Deux éléments qui sont utilisés pour l'apparence et la disposition de tous les onglets. Tab_Template_1 définit la position du premier onglet et l'apparence de tous les onglets. A partir de la position de Tab_Template_2, la disposition des onglets (horizontal ou vertical) et l'écart entre les onglets seront calculés. La couleur de l'alarme sera définie si la hiérarchie de la page affichée est inférieure à l'instance représentée par l'onglet. Si l'élément est un bouton, la variable d'état du bouton sera également définie. Si l'élément est un cadre, la couleur de l'alarme ne sera pas utilisée. Au lieu de cela, la variable du cadre de commutation sera définie sur \"1\", si l'onglet est sélectionné (0 par défaut). Éléments facultatifs du modèle [Up] , [Back] , [Forward] : Éléments de navigation qui peuvent être un bouton ou un cadre. Le type d'élément peut être un bouton ou un cadre. Dans le cas d'un cadre, le cadre doit contenir trois visualisations qui doivent être dans l'ordre suivant : Neutre, Enfoncé, Désactivé. [Address] : Champ de texte qui affiche le chemin d'instance de l'instance de module affichée. [Status] : Champ de texte qui affiche le contenu de la variable chaîne globale ac.g_stVisuStatusBar de la bibliothèque AC_ModuleBase. Cette variable peut être utilisée dans les implémentations de modules propres pour afficher l'état d'une variable. Tous les autres éléments ne sont pas spécialement gérés par le générateur de visualisation. Pour la génération, la visualisation modèle copie et modifie la copie. L'original n'est pas modifié. À l'exception des éléments de visualisation mentionnés ci-dessus, le générateur de visualisation essaie de ne modifier aucun élément modifié manuellement. Lors de la première génération de visualisation, le modèle de visualisation décrit est copié. Cette copie, tant qu'elle n'est pas supprimée par l'utilisateur, sera uniquement modifiée dans les générations futures et non recopiée. Cela se fait en traitant une visualisation de niveau supérieur d'une exécution antérieure du générateur comme s'il s'agissait d'un nouveau modèle de visualisation (le modèle d'origine n'est jamais modifié), bien qu'il ne soit pas copié. Ainsi, s'il y a des onglets supplémentaires, ces onglets seront ajoutés aux onglets déjà existants. Toutes les autres propriétés et éléments ne seront pas touchés si possible afin que les boutons, onglets, etc., qui ont été ajoutés manuellement par l'utilisateur, conservent leur position. La suppression, par exemple, des boutons de navigation entraîne leur perte. Pour les générer, le visu de niveau supérieur doit être supprimé et régénéré " }, 
{ "title" : "Alignement des onglets ", 
"url" : "ac_toplevel_templates.html#UUID-b04a5efa-11da-0879-903b-e5e3a3f27499_ac_toplevel_templates0", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Écrans de visualisation \/ Modèles de niveau supérieur \/ Alignement des onglets ", 
"snippet" : "Les onglets seront alignés horizontalement de gauche à droite ou verticalement de haut en bas. La position relative de l'élément du modèle Tab_Template_1 et Tab_Template_2 définit l'alignement : Si la distance verticale des éléments est supérieure à la distance horizontale, les éléments seront align...", 
"body" : "Les onglets seront alignés horizontalement de gauche à droite ou verticalement de haut en bas. La position relative de l'élément du modèle Tab_Template_1 et Tab_Template_2 définit l'alignement : Si la distance verticale des éléments est supérieure à la distance horizontale, les éléments seront alignés horizontalement, sinon verticalement. En cas d'alignement vertical, tous les onglets ont la même largeur, qui est la largeur minimale sur laquelle tous les noms d'onglets peuvent être affichés. Dans le cas d'un alignement horizontal, chaque onglet obtient la largeur minimale pouvant afficher son nom. Dans les deux cas la hauteur des onglets sera fixée à la hauteur du premier modèle ( Tab_Template_1 ). Pour le placement, le premier modèle est copié et adapté pour chaque onglet. Le placement commence à la position du premier modèle – la distance entre deux onglets résulte de la distance horizontale ou verticale entre les deux modèles. Cette distance peut aussi être négative, auquel cas la languette suivante chevauche la précédente et peint dessus car elle est plus en avant. Dans le cas d'un alignement vertical, la génération est interrompue avec une erreur s'il n'y a pas assez d'espace vers le bas pour accueillir tous les onglets. Aucune deuxième colonne d'onglets n'est créée. En cas d'alignement horizontal, une nouvelle ligne sera créée si l'onglet suivant ne tient plus horizontalement dans la visualisation. Si cela se produit pour le premier onglet d'une ligne, alors la génération est interrompue avec une erreur. Il peut arriver qu'il n'y ait pas assez d'espace pour l'onglet. Dans le cas d'un alignement horizontal, cela se produit lors du retour à une nouvelle ligne. Lorsqu'ils sont alignés verticalement, cela se produit lorsque la largeur des onglets est supérieure à l'espace qui leur est prévu dans le modèle. Dans ces cas-là, on tente de créer plus d’espace. Grâce à cet alignement automatique des éléments, il existe quatre cas possibles pour disposer les onglets : Alignement horizontal des onglets : Tous les onglets doivent être complètement au-dessus du cadre Alignement horizontal des onglets : tous les onglets doivent être complètement en dessous du cadre Alignement vertical des languettes : Tous les languettes doivent être entièrement sur le côté gauche du cadre. Alignement vertical des languettes : Tous les languettes doivent être entièrement sur le côté droit du cadre. Si l'alignement des onglets ne correspond pas à la restriction ci-dessus, un message d'erreur sera créé. S'il n'y a pas assez d'espace pour les onglets, le cadre est réduit en conséquence. Tous les éléments entre les onglets et le cadre sont déplacés. La position d'un élément est interprétée comme \"entre les onglets et le cadre\" si elle n'est pas complètement en dehors de la limite extérieure du premier modèle d'onglet (voir les exemples de disposition horizontale ci-dessous). La création de la visualisation sera interrompue si la modification de la taille du cadre conduisait à des valeurs négatives. Exemple pour les éléments entre onglets et cadre Exemple pour les éléments \"à l'extérieur\" des onglets et du cadre " }, 
{ "title" : "Génération d'écrans de visualisation ", 
"url" : "ac_generating_visualization_pages.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Écrans de visualisation \/ Génération d'écrans de visualisation ", 
"snippet" : "Pour les écrans de visualisation dans Application Composer, tous les éléments de CODESYS V3 ainsi que les écrans de visualisation intégrés peuvent être utilisés. De plus, des éléments visuels (exemple : rectangle), marqués comme espace réservé spécial, peuvent être utilisés : Navigation dans la visu...", 
"body" : "Pour les écrans de visualisation dans Application Composer, tous les éléments de CODESYS V3 ainsi que les écrans de visualisation intégrés peuvent être utilisés. De plus, des éléments visuels (exemple : rectangle), marqués comme espace réservé spécial, peuvent être utilisés : Navigation dans la visualisation La navigation au sein de la visualisation peut se faire à l'aide des onglets ou des Dos , En haut , et Avant Boutons de navigation. Un clic de souris sur les éléments de l'onglet permet de passer directement aux écrans de visualisation correspondants. Le Dos et Avant des boutons permettent de naviguer dans l'historique des écrans affichés (similaire à la navigation dans les navigateurs Internet). Le En haut Le bouton passe au niveau supérieur suivant. " }, 
{ "title" : "Éléments d'espace réservé dans les écrans de visualisation ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_1d3a1d9285970a30c0a8640e01de1c5b", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Écrans de visualisation \/ Génération d'écrans de visualisation \/ Éléments d'espace réservé dans les écrans de visualisation ", 
"snippet" : "Les éléments de visualisation standards (exemple : rectangles, images) peuvent être utilisés comme éléments d'espace réservé. Lors de la génération de la visualisation, les visualisations intégrées attribuées seront disposées sur la position de l'espace réservé (position et taille). spécification La...", 
"body" : "Les éléments de visualisation standards (exemple : rectangles, images) peuvent être utilisés comme éléments d'espace réservé. Lors de la génération de la visualisation, les visualisations intégrées attribuées seront disposées sur la position de l'espace réservé (position et taille). spécification La définition des éléments d'espace réservé se fait par le nom d'instance de l'élément. Le nom de l'élément doit être PLACEHOLDER_<SUBPATH> . Syntaxe de <SUBPATH> : <SUBPATH> ::= <SLOTREF> | <SLOTREF>:<SUBPATH> <SLOTREF> ::= <SLOTNAME> | <SLOTNAME>[<idx>] Le <SLOTNAME> est le nom cible d'un emplacement (les majuscules ou les minuscules ne sont pas pertinentes). <idx> est un index de base zéro qui ne peut être utilisé que pour les multislots. Il définit quelle instance de sous-module du multislot doit être affichée. Lors de la lecture de la définition du module, le système vérifie si les noms d'espace réservé dans les écrans de visualisation sont valides. Si un élément de l'écran de visualisation commence par \" PLACEHOLDER_ \" (les majuscules ou les minuscules ne sont pas pertinentes), le <SUBPATH> doit commencer par une référence d'emplacement valide. Si un index est présent, il doit être compatible avec la cardinalité du slot. Tous les noms d'emplacement du chemin doivent être des identifiants CEI valides. S'il y a plusieurs espaces réservés, tous les chemins doivent être différents. De plus, les éléments fictifs ne doivent pas avoir de zone vide. S'il n'existe aucune instance de module correspondant au <SUBPATH> d'un élément placeholder, aucune visualisation ne sera affectée à cet élément. Aucun message d'erreur ne sera créé. S'il existe une instance de module correspondant au <SUBPATH> d'un élément d'espace réservé, cet élément sera intégré s'il est défini comme une visualisation d'écran intégrée pour l'écran actuel. Les visualisations intégrées conserveront leur rapport hauteur\/largeur d'origine. La taille sera adaptée au mieux à l'espace réservé sans dépasser celui-ci. Exemple d'éléments d'espace réservé Seules les instances de sous-module et leurs instances de sous-module peuvent être intégrées à l'aide d'espaces réservés. Il n'est pas possible d'incorporer des visualisations provenant d'autres branches de l'arborescence du module. " }, 
{ "title" : "Vérification du modèle de niveau supérieur ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_335369a685ed9d34c0a8652001ab0576", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Écrans de visualisation \/ Génération d'écrans de visualisation \/ Vérification du modèle de niveau supérieur ", 
"snippet" : "Les vérifications suivantes sont effectuées sur l'écran de niveau supérieur : Si le modèle de visualisation n'existe pas ou s'il y a des entrées ou des sorties définies dans son interface, une erreur sera affichée. S’il manque un élément obligatoire, une erreur s’affichera. Si un élément d'un modèle...", 
"body" : "Les vérifications suivantes sont effectuées sur l'écran de niveau supérieur : Si le modèle de visualisation n'existe pas ou s'il y a des entrées ou des sorties définies dans son interface, une erreur sera affichée. S’il manque un élément obligatoire, une erreur s’affichera. Si un élément d'un modèle de niveau supérieur est défini mais qu'il comporte une zone vide ou un type d'élément incorrect, une erreur sera affichée. Si les modèles d'onglets et le cadre se chevauchent, une erreur s'affichera. Si la position du modèle du deuxième onglet est identique au premier modèle ou si sa position est sur le côté gauche ou au-dessus du premier modèle, une erreur sera affichée. En cas d'alignement horizontal des languettes, une erreur sera créée si les languettes ne sont pas complètement au-dessus ou en dessous du cadre. En cas d'alignement vertical des languettes, une erreur sera créée si les languettes ne sont pas complètement à droite ou à gauche du cadre. " }, 
{ "title" : "Création des écrans de visualisation ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_85c3e6868b643da6c0a8640e01a0782b", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Écrans de visualisation \/ Génération d'écrans de visualisation \/ Création des écrans de visualisation ", 
"snippet" : "Tous les écrans de visualisation seront initialement créés par la commande Générer . Avec un deuxième générateur exécuté, seuls les paramètres modifiés de l'arborescence des modules seront mis à jour. Un écran de visualisation créé contient un cadre qui définit la taille de la visualisation et qui c...", 
"body" : "Tous les écrans de visualisation seront initialement créés par la commande Générer . Avec un deuxième générateur exécuté, seuls les paramètres modifiés de l'arborescence des modules seront mis à jour. Un écran de visualisation créé contient un cadre qui définit la taille de la visualisation et qui contient la visualisation correspondante du module. Ce cadre est en arrière-plan, toutes les visualisations intégrées seront disposées comme suit : Tous les éléments incorporés sont identifiés de manière persistante par l'ID d'élément. Si un écran de visualisation existant est mis à jour par une nouvelle exécution du générateur, le système recherche l'ID correspondant. Si cet élément (ID) existe seul le paramètre modifié dans la configuration du module sera mis à jour. Par exemple, la position reste inchangée et le commutateur visualisation\/cadre ainsi que l'objet de visualisation utilisé pour l'affichage peuvent changer. Les visualisations intégrées seront disposées sur l'écran de gauche à droite et de haut en bas. Un élément d'espace réservé correspondant a une priorité plus élevée. Enfin, les deux mécanismes ne sont pas utilisés si le cadre avec le correspondant ElementID existe déjà au cours de la génération. Dans ce cas, la situation reste inchangée. Les écrans de visualisation qui ont été créés lors du dernier fonctionnement du générateur, mais qui n'existent pas dans le fonctionnement actuel du générateur, seront supprimés. " }, 
{ "title" : "Ordre d'intégration des éléments de visualisation ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_b67bb7c98bca4d3bc0a8640e01a07a7d", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Écrans de visualisation \/ Génération d'écrans de visualisation \/ Ordre d'intégration des éléments de visualisation ", 
"snippet" : "Dans un premier temps, toutes les visualisations intégrées par next Ancestor sera arrangé. Ces éléments seront insérés dans le pré-ordre des instances du module dans l'arborescence des modules. (D'abord le premier enfant, puis tous ses sous-modules, puis le deuxième enfant et ainsi de suite) Après c...", 
"body" : "Dans un premier temps, toutes les visualisations intégrées par next Ancestor sera arrangé. Ces éléments seront insérés dans le pré-ordre des instances du module dans l'arborescence des modules. (D'abord le premier enfant, puis tous ses sous-modules, puis le deuxième enfant et ainsi de suite) Après cela, toutes les visualisations intégrées par la définition de l'instance seront insérées. Cela sera également fait dans la précommande des instances du module. " }, 
{ "title" : "Gestionnaire de persistance ", 
"url" : "ac_pm_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance ", 
"snippet" : "Le Persistence Manager est un composant standard d’Application Composer. Il est utilisé pour gérer les données rémanentes persistantes. Il reconnaît ces variables par certains les attributs dans la déclaration des variables. C'est donc un option alternative au mécanisme VAR PERSISTENT du système de ...", 
"body" : "Le Persistence Manager est un composant standard d’Application Composer. Il est utilisé pour gérer les données rémanentes persistantes. Il reconnaît ces variables par certains les attributs dans la déclaration des variables. C'est donc un option alternative au mécanisme VAR PERSISTENT du système de programmation standard. qui gère les variables persistantes dans une liste spéciale de variables globales ( Variables persistantes ). Ce mécanisme est conçu pour la performance temporelle et le stockage dans une zone mémoire rémanente. En revanche, le gestionnaire de persistance stocke les valeurs persistantes dans un fichier externe et sollicite donc moins les ressources mémoire d'un contrôleur. Il permet de conserver les valeurs même lorsque les déclarations ont été modifiées et permet une édition externe des données. Cette fonctionnalité étendue se fait cependant au détriment des performances. En fonction du contrôleur, la lecture et surtout l'écriture d'un grand nombre de variables persistantes peuvent prendre beaucoup de temps et bloquer la tâche correspondante très longtemps. Cela dépend donc du cas d'utilisation et du mécanisme recommandé pour établir la persistance des données. Dans certains cas, même l’utilisation de recettes peut être la meilleure solution. Pour vous aider à prendre une décision, consultez : Persistance Le gestionnaire de persistance est un module de niveau supérieur et peut être ajouté à l'arborescence des modules à l'aide de la commande Ajouter une instance de module de niveau supérieur . Sous le gestionnaire de persistance, vous pouvez insérer jusqu'à 64 canaux. Dans les chaînes, vous pouvez définir groupes de persistance et configurez leur comportement de stockage par paramètres. Chaque canal doit avoir un sous-module Data Storage , définissant le format dans lequel les données persistantes sont écrites dans un fichier. Ici, vous définissez le format dans lequel les données persistantes sont stockées dans un fichier. Ce fichier archive est stocké en externe, par défaut dans le répertoire d'installation du contrôleur. Pour les versions du système d'exécution >= 3.5.8.0, l'emplacement des fichiers d'archive est défini via l'espace réservé $ac_persistence$ . Les archives déjà existantes seront déplacées vers cet emplacement, si elles se trouvent dans le répertoire défini par l'espace réservé $PLCLogic$ . Ce répertoire était l'emplacement par défaut dans les versions précédentes du système d'exécution. Pour les archives situées aux deux emplacements, un avertissement est émis dans le journal système d'exécution. Un seul Persistence Manager par application peut être ajouté à l’arborescence des modules. Si le gestionnaire de persistance est ajouté au POU pool ou si plusieurs gestionnaires de persistance sont ajoutés à l’application, un message d’erreur sera créé. Persistence Manager ajouté à l'arborescence des modules Si l'arborescence du module ou les paramètres des instances de module ont été modifiés, une exécution du générateur doit être exécutée. (Commande: produire) Différences avec le mécanisme \"VAR PERSISTENCE\" Les données persistantes sont stockées dans un fichier externe. Les données persistantes peuvent être échangées entre projets. Les variables persistantes peuvent être supprimées de l'application resp. ajouté à l’application sans perte des données restantes. Les données créées par Persistence Manager peuvent être modifiées avec des éditeurs externes. (Exemple : Bloc-notes). Voir également: Persistance " }, 
{ "title" : "Module de gestion de persistance ", 
"url" : "ac_pm_persistencemanager_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance \/ Module de gestion de persistance ", 
"snippet" : "Un double clic sur le Gestionnaire de persistance nœud dans l'arborescence des modules ou dans le Modifier l'objet La commande ouvre les éditeurs associés. Outre les éditeurs standards de modules de premier niveau (voir Aperçu ) le Persistence Manager fournit le Persistance languette. IHM Le Persist...", 
"body" : "Un double clic sur le Gestionnaire de persistance nœud dans l'arborescence des modules ou dans le Modifier l'objet La commande ouvre les éditeurs associés. Outre les éditeurs standards de modules de premier niveau (voir Aperçu ) le Persistence Manager fournit le Persistance languette. IHM Le Persistence Manager fournit un modèle de visualisation ( VISU_PersistenceManager ) qui peut être ajouté à la visualisation. Boîte de dialogue pour les paramètres HMI Cette page fournit des informations statistiques sur la lecture et l'écriture des variables : Page de visualisation des données de persistance " }, 
{ "title" : "Persistance ", 
"url" : "ac_pm_persistencemanager_module.html#UUID-87fcb435-c65b-2e65-6037-f61974f5b1d7_e4fa0ddccaa0cf0c0a8640e01493625_id_2bd57d34d6d13475c0a8640e0192d4cf", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance \/ Module de gestion de persistance \/ Persistance ", 
"snippet" : "Dialogue: Persistance Dans le Persistance Dans la boîte de dialogue, un ou plusieurs groupes peuvent être exclus du stockage. Pour créer un nouveau groupe, un nom unique doit être saisi et ajouté avec le Ajouter bouton. Le Retirer La commande permet de supprimer des groupes existants. Les variables ...", 
"body" : "Dialogue: Persistance Dans le Persistance Dans la boîte de dialogue, un ou plusieurs groupes peuvent être exclus du stockage. Pour créer un nouveau groupe, un nom unique doit être saisi et ajouté avec le Ajouter bouton. Le Retirer La commande permet de supprimer des groupes existants. Les variables peuvent être exclues du stockage en utilisant l'attribut ac_persist_exclude . Pour plus d'informations, consultez : Attribut : ‚ac_persist_exclude' " }, 
{ "title" : "Canal de persistance ", 
"url" : "ac_pm_channel_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance \/ Canal de persistance ", 
"snippet" : "Un canal de persistance définit les paramètres de stockage pour un ou plusieurs groupes de variables persistantes. Il peut être ajouté à un nœud Persistence Manager à l'aide de la commande Ajouter une instance de sous-module . Sous un nœud Persistence Manager, jusqu'à 64 canaux peuvent être créés. I...", 
"body" : "Un canal de persistance définit les paramètres de stockage pour un ou plusieurs groupes de variables persistantes. Il peut être ajouté à un nœud Persistence Manager à l'aide de la commande Ajouter une instance de sous-module . Sous un nœud Persistence Manager, jusqu'à 64 canaux peuvent être créés. IHM, Informations Pour plus de détails sur ces boîtes de dialogue, consultez les rubriques suivantes : E\/S, IHM et Information. " }, 
{ "title" : "Persistance ", 
"url" : "ac_pm_channel_module.html#UUID-af8d821d-a61e-6db4-8c17-a9f12c86748c_dc660673ccac225bc0a8640e0116ede0_id_1c75f716cd06b00bc0a865200055fd43", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance \/ Canal de persistance \/ Persistance ", 
"snippet" : "Groupes persistants Dans cette boîte de dialogue, un ou plusieurs groupes peuvent être définis qui sont gérés par ce canal. Par défaut, le nom de l'instance du module de canal est disponible dans la liste. Pour créer un nouveau groupe, un nom unique doit être saisi et ajouté avec le Ajouter bouton. ...", 
"body" : "Groupes persistants Dans cette boîte de dialogue, un ou plusieurs groupes peuvent être définis qui sont gérés par ce canal. Par défaut, le nom de l'instance du module de canal est disponible dans la liste. Pour créer un nouveau groupe, un nom unique doit être saisi et ajouté avec le Ajouter bouton. Retirer peut être utilisé pour supprimer les groupes sélectionnés. Les variables peuvent être affectées à des groupes via l'attribut ac_persist . Pour plus d'informations, voir : Définition des variables persistantes, attribut 'ac.persist' Variables persistantes : Cette liste affiche toutes les variables persistantes affectées à l'un des groupes de persistance répertoriés ci-dessus. " }, 
{ "title" : "Paramètre ", 
"url" : "ac_pm_channel_module.html#UUID-af8d821d-a61e-6db4-8c17-a9f12c86748c_dc660673ccac225bc0a8640e0116ede0_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance \/ Canal de persistance \/ Paramètre ", 
"snippet" : "Le Paramètres L'onglet propose une liste d'options relatives au stockage des variables : Paramètres des canaux persistants tSauvegarde périodique : Après cet intervalle, les variables sont stockées. Saisie de la valeur t#0s désactivera cette sauvegarde périodique. xSaveOnChange : Si ceci est réglé s...", 
"body" : "Le Paramètres L'onglet propose une liste d'options relatives au stockage des variables : Paramètres des canaux persistants tSauvegarde périodique : Après cet intervalle, les variables sont stockées. Saisie de la valeur t#0s désactivera cette sauvegarde périodique. xSaveOnChange : Si ceci est réglé sur TRUE, la valeur actuelle sera constamment comparée à la dernière valeur enregistrée, et si elles sont différentes, la valeur actuelle sera stockée. Canaux de persistance, qui ont défini xSaveOnChange=FALSE , sera stocké lors d'un arrêt du contrôleur ainsi que lors d'une réinitialisation (à chaud, à froid, origine). De plus, des économies périodiques peuvent avoir lieu. xReadVarsDuringInit : Si ceci est réglé sur TRUE , les valeurs des variables persistantes seront lues lors de l'initialisation de l'application. Sinon, ils sont chargés lors du premier cycle d’application. xCompressTags : Si ceci est réglé sur TRUE , les chemins d'instance des variables seront enregistrés dans un format compressé. Pour plus d'informations, voir : Format de stockage, archives compressées . xConsistentCopyInHighPrioTask : Si ceci est réglé sur TRUE , les variables sont copiées de la tâche de priorité la plus élevée et enregistrées dans la tâche de priorité inférieure. Cette option est utilisée pour éviter les incohérences des données lorsque les variables sont modifiées dans une tâche hautement prioritaire. xConvertVarsWithDifferentType : Si ceci est réglé sur TRUE , le canal de persistance tentera de convertir la valeur lue dans l'archive en type de données cible (si le type de données de la valeur est différent de celui de la cible). En cas de succès, la valeur de l'archive sera acceptée ; sinon, la valeur sera rejetée. Cette fonction prend en charge les conversions suivantes : Type de données dans l'archive Type de données cible La description n'importe quel entier n'importe quel entier uniquement si la valeur se trouve dans la plage couverte par le type de données actuel n'importe quel entier Réel n'importe quel entier Lréel tous les types de données Chaîne de caractères Réel Lréel Réel ANY_INT uniquement si la valeur de l'archive est un nombre entier dans la plage correcte Lréel Réel uniquement si la valeur est dans la plage couverte par un REAL Lréel ANY_INT uniquement si la valeur de l'archive est un nombre entier dans la plage correcte xIntegrityCheckBeforeReading : Si ceci est réglé sur TRUE , l'intégrité de la base de données est vérifiée. xSeparateArchivePerToplevelInstance : Lorsque cette option est définie sur TRUE , une archive distincte est créée pour chaque instance de niveau supérieur. Le nom de cette archive est son propre nom (tel que configuré dans le DataStorage), suivi du nom de l'instance de niveau supérieur : <archive name>_<instance name> ou <archive name> pour toutes les instances qui ne sont pas inférieures à une instance de module de niveau supérieur (exemple : variables d'application). Cette option est désactivée par défaut. Si vous modifiez le paramètre par la suite ( TRUE <-> FALSE ), le nom de l'archive sera modifié et les variables persistantes risquent d'être perdues ! xMakeDataCRCConsistencyCheck : Si ceci est réglé sur TRUE , une valeur CRC est calculée au début et à la fin de l'opération de sauvegarde. Ces deux valeurs doivent être identiques pour réussir l’opération de sauvegarde. uiSavingRetriesIfCRCConsistencyCheckFails : Spécifie le nombre de fois où répéter le stockage si xMakeDataCRCConsistencyCheckFails est réglé sur TRUE et les valeurs CRC ne correspondent pas. xLogSaveTimeEnabled : Si ceci est réglé sur TRUE , le temps nécessaire à l'écriture est enregistré. eAutomaticActionOnlineChange : Comportement, si et comment les valeurs des variables sont stockées lors d'un changement en ligne. Aucun : Pas de stockage Sauvegarder : Les valeurs sont enregistrées. Ainsi, les modifications apportées à la configuration sont également enregistrées dans la mémoire de persistance (par exemple, ajout ou renommage de variables). Charger : Les valeurs sont chargées depuis la mémoire de persistance. Ainsi, les initialisations possibles (par exemple FB_INIT , IModule.Init et les paramètres du module) sont écrasés par les valeurs persistantes. ChargerEtEnregistrer : Les valeurs sont chargées ainsi qu'écrites depuis la mémoire de persistance. eAutomaticActionPlcStop : Détermine si les valeurs des variables sont stockées lors d'une réinitialisation. Aucun : Pas de stockage Sauvegarder : Les valeurs sont enregistrées. " }, 
{ "title" : "Module : Stockage des données ", 
"url" : "ac_pm_storage_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance \/ Module : Stockage des données ", 
"snippet" : "Stockage de données Le sous-module Stockage de données définit le format de stockage d'un canal de persistance . Choisissez l'un des formats de stockage suivants : ASCIIFileStorage : Sauvegarde des valeurs au format ASCII dans un fichier. Le ASCIIFileStorage Ce format permet d'ouvrir le fichier arch...", 
"body" : "Stockage de données Le sous-module Stockage de données définit le format de stockage d'un canal de persistance . Choisissez l'un des formats de stockage suivants : ASCIIFileStorage : Sauvegarde des valeurs au format ASCII dans un fichier. Le ASCIIFileStorage Ce format permet d'ouvrir le fichier archive dans un éditeur de texte et d'en modifier les valeurs. Des commentaires peuvent être ajoutés aux archives de fichiers ASCII. Ceux-ci seront ignorés lors de la lecture du fichier. BinaryFileStorage : Sauvegarde des valeurs au format binaire dans un fichier. BinaryMemoryStorage :Sauvegarde des valeurs au format binaire dans la zone \"RETAIN\" du compilateur ou de l'appareil concerné (exemple : dans la NVRAM d'un tel appareil.) PersistentBinaryMemoryStorage : Sauvegarde des valeurs au format binaire dans la zone \"Persistant\" du compilateur ou de l'appareil concerné (exemple : dans la NVRAM d'un tel appareil.) Sous le canal de persistance, insérez un Stockage de données module du format souhaité. Si nécessaire, modifiez la configuration dans Paramètre languette: Boîte de dialogue : Informations Pour plus de détails sur cette boîte de dialogue, voir : Information . " }, 
{ "title" : "Boîte de dialogue : Paramètres ", 
"url" : "ac_pm_storage_module.html#UUID-1d4190f0-4f49-535e-fe96-bf340f625ee5_aa44ae4cccad1068c0a8640e019d97f0_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance \/ Module : Stockage des données \/ Boîte de dialogue : Paramètres ", 
"snippet" : "sArchiveName Nom du fichier d'archive Par défaut, l'espace réservé %CHANNEL_NAME% est défini. Cet espace réservé sera remplacé par le nom d'instance du canal de persistance supérieur. Le nom de l'archive doit être unique, car tous les fichiers d'archive sont stockés par défaut dans le répertoire d'i...", 
"body" : "sArchiveName Nom du fichier d'archive Par défaut, l'espace réservé %CHANNEL_NAME% est défini. Cet espace réservé sera remplacé par le nom d'instance du canal de persistance supérieur. Le nom de l'archive doit être unique, car tous les fichiers d'archive sont stockés par défaut dans le répertoire d'installation du contrôleur. Remarque : L'emplacement de stockage par défaut des fichiers d'archive dépend de la version du système d'exécution. Voir: Présentation du gestionnaire de persistance xDoubleStorage Si activé ( TRUE ), les variables sont stockées alternativement dans deux archives différentes ( sArchive1 , sArchive2 ). En cas de fichier corrompu (exemple : dû à un arrêt du contrôleur lors du stockage des variables), le fichier de sauvegarde sera utilisé. Lorsque le fichier est ouvert, le gestionnaire de persistance vérifie l'horodatage des deux archives. S'il n'y a aucun dommage, l'archive la plus récente sera utilisée, sinon l'autre. udiMaximumFileSize La taille maximale du fichier en octets Si 0 est définie, aucune limite n'est définie ou vérifiée. Ainsi, la taille du fichier peut atteindre n'importe quelle taille. parSeparator Valeur ASCII pour le séparateur entre le nom et la valeur de la variable. udiMemDataSize Taille de la mémoire dans la zone variable \"RETAIN\", créée pour le module. La valeur est comparée à la taille des données à stocker. Si la valeur est définitivement trop petite, une erreur de compilation est créée. S'il est peut-être trop petit, un avertissement s'affiche dans la vue des messages. LineEnding Caractère indiquant la fin de la ligne dans le fichier " }, 
{ "title" : "Définition des variables persistantes ", 
"url" : "ac_pm_definition_persistent_variables.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance \/ Définition des variables persistantes ", 
"snippet" : "Les variables simples ainsi que les instances de structure et les instances de blocs fonctionnels peuvent être marquées comme « persistantes » à l'aide d'attributs. Lorsqu'une instance est marquée, tous les membres de VAR , VAR_INPUT , et VAR_OUTPUT sera stocké de manière persistante. Dans le cas où...", 
"body" : "Les variables simples ainsi que les instances de structure et les instances de blocs fonctionnels peuvent être marquées comme « persistantes » à l'aide d'attributs. Lorsqu'une instance est marquée, tous les membres de VAR , VAR_INPUT , et VAR_OUTPUT sera stocké de manière persistante. Dans le cas où des variables dans un VAR PERSISTENT section sont marquées comme « persistantes », un avertissement sera créé. De plus, il existe des attributs permettant de définir un groupe de stockage par défaut, ainsi que d'exclure des variables particulières du stockage persistant de structures ou d'instances de blocs fonctionnels. Si la définition des variables persistantes a été modifiée (ajout, suppression, renommage, changement de type de données), aucune nouvelle génération de code composer (commande Generate) ne doit être exécutée. Ces modifications seront automatiquement mises à jour dans les instances de Persistent Manager lors de la compilation. Pour plus d'informations sur les conversions implicites possibles en cas de définition de type de données modifiée, veuillez consulter : Paramètre Attribut : 'ac_persist_exclude' L'attribut 'ac_persist_exclude' est utilisé pour exclure une variable du stockage persistant, peu importe si les membres de la structure ou de la déclaration du bloc fonctionnel sont définis comme « persistants ». S'il n'existe aucun membre persistant dans la déclaration, une erreur sera créée lors de la génération du code. Exemple d'exclusion de variables PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist_exclude'}\n fb1 : FB;\nEND_VAR " }, 
{ "title" : "Types de données pris en charge ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_beff9eaed151b190c0a8640e01016617", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance \/ Définition des variables persistantes \/ Types de données pris en charge ", 
"snippet" : "Les instances avec les types de données suivants ne peuvent pas être stockées de manière persistante : PEU Aiguille Interfaces Constantes Tableaux de types de données non persistants Tous les autres types de données sont pris en charge. Cela inclut les énumérations, les types de données de sous-gamm...", 
"body" : "Les instances avec les types de données suivants ne peuvent pas être stockées de manière persistante : PEU Aiguille Interfaces Constantes Tableaux de types de données non persistants Tous les autres types de données sont pris en charge. Cela inclut les énumérations, les types de données de sous-gamme, les tableaux de tableaux et les tableaux multidimensionnels : ARRAY[0..9] OF ARRAY[5..6, 7..8, 9..10] OF INT Type de données: SYNDICAT Pour enregistrer l'instance d'une union de manière persistante, l'un de ses champs doit être marqué comme \"représentatif\". Il y a trois manières possibles : Exactement un champ dans la déclaration de l'union est marqué avec l'attribut ac_persist_union_representant (sans valeur d'attribut). Ce champ « représente » alors le syndicat. Sa valeur sera enregistrée et chargée de manière représentative pour l'union complète. Exactement un champ dans la déclaration de l'union est marqué avec l'attribut ac_persist – cela définit en même temps le représentant. L'instance de l'union est marquée avec l'attribut ac_persist_union_set_representant y compris la valeur de l'attribut. La valeur de l'attribut décrit le nom du champ union qui doit être utilisé comme représentant. Cet attribut écrase un existant ac_persist_union_representant attribut dans la déclaration du syndicat. Les tableaux d'unions peuvent également être marqués et faire référence aux éléments du tableau. Exemples 'ac_persist_union_representant' TYPE UnionWithRep :\nUNION\n di : DINT ;\n {attribute 'ac_persist_union_representant'}\n dw : DWORD ;\nEND_UNION\nEND_TYPE 'ac_persist' TYPE UnionWithPersist :\nUNION\n di : DINT ;\n {attribute 'ac_persist' := 'TestUnion'}\n dw : DWORD ;\nEND_UNION\nEND_TYPE 'ac_persist_union_set_representant' FUNCTION_BLOCK FBTestUnion\nVAR\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n u2 : UnionWithoutRep ;\nEND_VAR Tableau d'union VAR\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n aElems ARRAY[0..7] OF SomeUnion ;\n\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n aaElems ARRAY[0..7] OF ARRAY[0..1] OF SomeUnion ;\nEND_VAR Pour qu'un représentant soit valable, il doit remplir les règles suivantes : Le représentant doit avoir la même taille que l'ensemble du syndicat. Sinon, les données complètes ne seraient pas enregistrées. Le représentant ne doit pas non plus disposer de zones de remplissage (zones de données vides créées par le compilateur pour aligner les données dans le stockage). La décomposition du représentant en types de données primitifs ne doit pas contenir d'instances de type REAL ou LREAL ou instance de type STRING ou WSTRING . De plus, le représentant doit être composé de types pris en charge (voir ci-dessus). Par exemple le représentant peut être du type Structure – cependant, la structure elle-même ne doit pas contenir de pointeur. " }, 
{ "title" : "Attribut : 'ac_persist' ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_e844aaa8d151b192c0a8640e01722fe3", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance \/ Définition des variables persistantes \/ Attribut : 'ac_persist' ", 
"snippet" : "L'attribut ' ac_persist ' peut être utilisé pour Variables Instances de structures Instances de blocs fonctionnels Membres des structures Membres des blocs fonctionnels {attribute 'ac_persist' [ := '<PERSISTENCE_GROUP>']} PERSISTENCE_GROUP est le nom du groupe de persistance auquel la déclaration do...", 
"body" : "L'attribut ' ac_persist ' peut être utilisé pour Variables Instances de structures Instances de blocs fonctionnels Membres des structures Membres des blocs fonctionnels {attribute 'ac_persist' [ := '<PERSISTENCE_GROUP>']} PERSISTENCE_GROUP est le nom du groupe de persistance auquel la déclaration doit être affectée. Il doit s'agir d'un identifiant CEI valide. Si aucun groupe de persistance n'est nommé ici, l'affectation sera effectuée selon l'attribut 'ac_persist_set_default_group' , qui dans ce cas doit être défini. Si une instance de structure ou une instance de bloc fonctionnel est marquée comme « persistante » et qu'au moins un membre de la déclaration est également marqué comme « persistant », un message d'erreur sera créé. Exemple pour une instance persistante La variable t est affecté au groupe de persistance PROCESS . Tous les membres seront stockés de manière persistante. PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist' := 'PROCESS'}\n t : TON;\nEND_VAR Exemple pour un membre persistant d'un bloc fonctionnel Le membre iNumIOs est affecté au groupe de persistance CONFIG . Ce membre sera stocké de manière persistante pour toutes les instances du bloc fonction (s'il n'est pas explicitement supprimé par l'attribut 'ac_persist_exclude' ). FUNCTION_BLOCK FB\nVAR\n {attribute 'ac_persist' := 'CONFIG'}\n iNumIOs : INT := 0;\nEND_VAR " }, 
{ "title" : "Attribut : 'ac_persist_set_default_group' ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_4130a661d151b192c0a8640e00b1a163", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance \/ Définition des variables persistantes \/ Attribut : 'ac_persist_set_default_group' ", 
"snippet" : "Si le nom du groupe est manquant dans l'attribut 'ac_persist' , un groupe par défaut doit être défini dans une instance de bloc fonctionnel ou une instance de structure contenant la variable correspondante directement ou indirectement. Ceci est possible avec l'attribut 'ac_persist_set_default_group'...", 
"body" : "Si le nom du groupe est manquant dans l'attribut 'ac_persist' , un groupe par défaut doit être défini dans une instance de bloc fonctionnel ou une instance de structure contenant la variable correspondante directement ou indirectement. Ceci est possible avec l'attribut 'ac_persist_set_default_group' . L'attribut peut également être défini pour un membre du bloc fonctionnel. La définition la plus intime de 'ac_persist_set_default_group' sera utilisé comme groupe par défaut pour la variable. Il est interdit d'utiliser 'ac_persist_set_default_group' ensemble avec 'ac_persist' ou 'ac_persist_exclude' . Dans ce cas, un message d'erreur sera créé lors de la génération du code. Exemple pour un groupe par défaut FUNCTION_BLOCK FB_Util\nVAR\n {attribute 'ac_persist'} \/\/ no group\n \/\/'ac_persist_set_default_group‘ and 'ac_persist_exclude' not allowed here\n i : INT := 0;\nEND_VAR PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist_set_default_group' := 'PROCESS'}\n fbu1 : FB_Util;\n\n {attribute 'ac_persist_set_default_group'´ := 'CONFIG'}\n fbu2 : FB_Util;\nEND_VAR " }, 
{ "title" : "Stockage de données ", 
"url" : "ac_pm_data_storage.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance \/ Stockage de données ", 
"snippet" : "Le stockage des variables persistantes peut être déclenché de différentes manières : Chaque canal de persistance fournit une interface d'application qui peut être utilisée par l'application pour déclencher un stockage (voir Accès aux données ). Dans les paramètres du canal de persistance un interval...", 
"body" : "Le stockage des variables persistantes peut être déclenché de différentes manières : Chaque canal de persistance fournit une interface d'application qui peut être utilisée par l'application pour déclencher un stockage (voir Accès aux données ). Dans les paramètres du canal de persistance un intervalle de temps ( tSauvegarde périodique ) peut être défini pour le stockage automatique. Le canal de persistance peut être configuré pour stocker une variable chaque fois que sa valeur change. Pour cela, la valeur précédente et la valeur actuelle sont comparées ; s'ils sont différents le stockage sera déclenché. Les différents modes de stockage peuvent être utilisés en parallèle et ne s’excluent pas mutuellement. En cas d'arrêt du régulateur ou après \"Reset\" (chaud \/ froid \/ origine) les données sont stockées automatiquement si le paramètre xSaveOnChange n’est pas défini. Pour plus d'informations, voir aussi : Module : Stockage de données " }, 
{ "title" : "Format de stockage ", 
"url" : "ac_pm_storage_format.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance \/ Format de stockage ", 
"snippet" : "Il existe deux implémentations de l'interface IDataStorage disponible: ASCIIDataStorage et BinaryDataStorage . Dans les deux formats, la première variable stockée est la variable réservée ___xCompressTags de type BOOL . Sa valeur détermine si les chemins d'instance sont stockés compressés. Si un obj...", 
"body" : "Il existe deux implémentations de l'interface IDataStorage disponible: ASCIIDataStorage et BinaryDataStorage . Dans les deux formats, la première variable stockée est la variable réservée ___xCompressTags de type BOOL . Sa valeur détermine si les chemins d'instance sont stockés compressés. Si un objet d'intégrité est écrit, il est alors écrit comme dernière variable nommée ___Integrity de type BOOL avec valeur TRUE . Toutes les variables persistantes, à l'exception de ces variables réservées, sont stockées dans l'ordre et triées selon leur chemin d'instance complet. Peu importe que les chemins d'instance soient compressés ou non. Si les données sont modifiées par l'utilisateur, il doit s'assurer que le bon ordre de tri sera maintenu. Archives compressées Les valeurs des variables sont stockées avec le chemin et le nom (dans le chemin il n'y a ni l'application ni le nom de l'appareil) dans une orthographe compacte pour économiser des ressources et du temps. Dans tous les cas (compressés ou non), les chemins d'instance doivent être triés dans l'ordre du chemin d'instance complet. Cet ordre de tri est alphabétique, les indices de tableau étant triés numériquement. Exemples Objets Format compressé Fb1.fb2.fb3.a Fb1.fb2.fb3.a Fb1.fb2.fb3.b <b Fb1.fb2.d <<d Fb4 FB4 " }, 
{ "title" : "Format ASCII ", 
"url" : "ac_pm_storage_format.html#UUID-fdd959e2-aa65-d5fc-5e9f-c1b6b7e12d4a_d165b0fbc0a8640e003c31fa_id_7b30973fd16738e7c0a8640e01455e29", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance \/ Format de stockage \/ Format ASCII ", 
"snippet" : "ASCIIDataStorage écrit chaque chemin d'instance des variables persistantes (éventuellement au format compressé), le type de données et la valeur sous forme de chaîne dans le fichier. Le nom et la date sont séparés par une tabulation (modifiable par paramètre codbySeparator ). Lorsque l'archive est l...", 
"body" : "ASCIIDataStorage écrit chaque chemin d'instance des variables persistantes (éventuellement au format compressé), le type de données et la valeur sous forme de chaîne dans le fichier. Le nom et la date sont séparés par une tabulation (modifiable par paramètre codbySeparator ). Lorsque l'archive est lue, une conversion sera exécutée. Par conséquent, le fichier peut être modifié en externe. Les lignes doivent être séparées par \"\\r\\n\" (convention Windows). Les lignes commençant par un point-virgule seront ignorées lors de la lecture - cette ligne ne sera pas ajoutée lors de l'écriture de l'archive. Format d'un fichier ASCII : {timestamp}\\r\\n\n{instance path}{bySeparator}{Typ}:{value}\\r\\n\n…\n{instance path}{bySeparator}{Typ}:{value}\\r\\n L'horodatage détermine l'heure à laquelle le stockage a été déclenché. Il est écrit sous la forme littérale DATE_AND_TIME (exemple : DT#2012-01-11-15:11:09 ) Exemple de fichier ASCII Traitement de REAL et LREAL variables : Les valeurs des variables sont écrites sous forme de littéraux ST. REAL et LREAL les valeurs sont traitées différemment, car la mise en œuvre de la conversion vers et depuis des fractions décimales sans perte de précision. Cependant pour éviter toute perte de précision et conserver la lisibilité et la possibilité de modifier le fichier ASCII, ces valeurs sont stockées au format hexadécimal. La fraction décimale (inexacte) est ajoutée derrière la valeur hexadécimale en guise de commentaire. Lors de la lecture du fichier, le format hexadécimal ainsi que le format décimal ST sont pris en charge. Cela permet à l'utilisateur de modifier la fraction décimale. Le format hexadécimal est défini comme suit : F16#{Mantissa}H{Exp} | F16#NaN | F16#+Inf | F16#-Inf\n{Mantissa} ::= {HexNumeral}\n{Exp} ::= {HexNumeral}\n{HexNumeral} ::= [+-]?[1-9A-F][0-9A-F]* Si m est la valeur de la mantisse et e la valeur de l'exposant est supérieure à la valeur du nombre m * 16^e . Exemple de valeur RÉELLE stockée lr1 LREAL:F16#F0H-3 0.05859375 " }, 
{ "title" : "Format binaire ", 
"url" : "ac_pm_storage_format.html#UUID-fdd959e2-aa65-d5fc-5e9f-c1b6b7e12d4a_d165b0fbc0a8640e003c31fa_id_602fd614d22a5f95c0a8640e0110d837", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance \/ Format de stockage \/ Format binaire ", 
"snippet" : "BinaryDataStorage enregistre les données au format binaire. L'horodatage suit cela (tapez DATE_AND_TIME ). Après cela, les variables sont répertoriées....", 
"body" : "BinaryDataStorage enregistre les données au format binaire. L'horodatage suit cela (tapez DATE_AND_TIME ). Après cela, les variables sont répertoriées. " }, 
{ "title" : "Accès aux données ", 
"url" : "ac_pm_data_access.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance \/ Accès aux données ", 
"snippet" : "Le gestionnaire de persistance fournit jusqu'à 10 instances de sous-modules de type PersistenceChannel. Chaque canal de persistance fournit une instance de sous-module de type DataStorage qui est responsable de l’accès aux données. Cette instance implémente l'interface IDataStorage :...", 
"body" : "Le gestionnaire de persistance fournit jusqu'à 10 instances de sous-modules de type PersistenceChannel. Chaque canal de persistance fournit une instance de sous-module de type DataStorage qui est responsable de l’accès aux données. Cette instance implémente l'interface IDataStorage : " }, 
{ "title" : "Diagnostic ", 
"url" : "ac_pm_diagnosis.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance \/ Diagnostic ", 
"snippet" : "Chaque canal de persistance dispose d'un sous-module qui permet l'accès aux données (interface IDataStorage ). Les sorties suivantes fournissent des informations de diagnostic : Sortir Type de données Description xActionOngoing BOOL TRUE si le gestionnaire de persistance lit ou écrit des données udi...", 
"body" : "Chaque canal de persistance dispose d'un sous-module qui permet l'accès aux données (interface IDataStorage ). Les sorties suivantes fournissent des informations de diagnostic : Sortir Type de données Description xActionOngoing BOOL TRUE si le gestionnaire de persistance lit ou écrit des données udiDataMemSize UDINT Taille des données persistantes en octets xReadingDone BOOL Lecture des données persistantes terminée dtLastReading DT Date et heure de la dernière lecture uiNumberVarsNotOk UINT Nombre de variables qui n'ont pas été lues correctement uiNumberVarsOk UINT Nombre de variables qui ont été lues correctement tTimeForReading TIME Durée de lecture dtLastSaving DT Date et heure de la dernière lecture tTimeForWriting TIME Durée d'écriture uiWritingCycles UINT Nombre de stockages jusqu'au début de l'application Les informations sur le nombre de variables lues et sur la réussite du stockage sont également affichées dans l'enregistreur de l'automate. Journalisation de l'automate¶ " }, 
{ "title" : "La gestion des erreurs ", 
"url" : "ac_pm_error_handling.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de persistance \/ La gestion des erreurs ", 
"snippet" : "Les numéros d'erreur et les chaînes associées sont appelés ou acquittés au moyen des interfaces de module standard ( ClearErrors , FirstErrorNumber , GetFirstErrorMessage , LastErrorNumber , GetLastErrorMessage ). Numéro d'erreur Description 100 La liste des données persistantes a changé et ne corre...", 
"body" : "Les numéros d'erreur et les chaînes associées sont appelés ou acquittés au moyen des interfaces de module standard ( ClearErrors , FirstErrorNumber , GetFirstErrorMessage , LastErrorNumber , GetLastErrorMessage ). Numéro d'erreur Description 100 La liste des données persistantes a changé et ne correspond pas à la taille initiale 110 La mémoire (pour comparaison ou copie cohérente) ne peut pas être créée. <ErrorCode SysMemAllocData> . La fonctionnalité est désactivée. 120 Il n'est pas possible de créer un stockage de données pour le stockage de comparaison. La fonctionnalité est désactivée. 130 Stockage de données non créé pour une copie cohérente 140 Variable persistante de type String a une taille non valide : <nom de la variable> 150 La variable persistante n'est pas d'un type pris en charge : <nom de la variable> 160 La base de données ne peut pas être ouverte. Lecture interrompue : <description détaillée de l'erreur de l'objet de base de données> 170 La base de données ne peut pas être fermée. Lecture interrompue : <description détaillée de l'erreur de l'objet de base de données> 190 La base de données ne peut pas être créée. Sauvegarde interrompue. <description détaillée de l'erreur de l'objet de base de données> 200 La base de données ne peut pas être ouverte. Sauvegarde interrompue. <description détaillée de l'erreur de l'objet de base de données> 210 La base de données ne peut pas être fermée. <description détaillée de l'erreur de l'objet de base de données> 220 Erreur lors de l'écriture d'une entrée : <description détaillée de l'erreur de l'objet de la base de données> 230 Erreur lors de la lecture de l'heure du système " }, 
{ "title" : "Gestionnaire de journaux de données ", 
"url" : "ac_dlm_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de journaux de données ", 
"snippet" : "Le DataLog Manager est un composant standard d'Application Composer. Il sert au stockage cyclique des valeurs de variables dans un fichier. Ces variables sont signalées par un signe spécial les attributs dans la déclaration de variable. Pour rendre le module disponible, vous devez ajouter le AC_Data...", 
"body" : "Le DataLog Manager est un composant standard d'Application Composer. Il sert au stockage cyclique des valeurs de variables dans un fichier. Ces variables sont signalées par un signe spécial les attributs dans la déclaration de variable. Pour rendre le module disponible, vous devez ajouter le AC_DataLog bibliothèque au gestionnaire de la bibliothèque. Un seul DataLog Manager par application peut être ajouté à l'arborescence des modules. Le DataLog Manager est un module de niveau supérieur et peut être ajouté à l'arborescence des modules à l'aide du Ajouter une instance de module de niveau supérieur commande. Sous les DataLog Managers, vous pouvez insérer jusqu'à 64 canaux. Dans les canaux, vous pouvez définir des groupes et configurer leur comportement de stockage par paramètres. Chaque canal doit disposer d'un sous-module de stockage DataLog. Ajouter DataLog Manager à l'arborescence des modules Si l'arborescence du module ou les paramètres des instances de module ont été modifiés, une exécution du générateur doit être exécutée. (Commande: Générer ). À cet effet, le générateur DataLog dans le Configuration du générateur doit être activé. " }, 
{ "title" : "Module : DataLog Manager ", 
"url" : "ac_dlm_datalogmanager_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de journaux de données \/ Module : DataLog Manager ", 
"snippet" : "DataLog Manager Le Gestionnaire de journaux de données gère l'enregistrement des données des variables. Il peut être ajouté à l'arborescence des modules sous l'objet le plus haut . Ceci est fait par le Ajouter une instance de niveau supérieur commande et la sélection du DataLogManager module. Un seu...", 
"body" : "DataLog Manager Le Gestionnaire de journaux de données gère l'enregistrement des données des variables. Il peut être ajouté à l'arborescence des modules sous l'objet le plus haut . Ceci est fait par le Ajouter une instance de niveau supérieur commande et la sélection du DataLogManager module. Un seul DataLog Manager par application peut être ajouté. Boîte de dialogue : IHM Le DataLog Manager fournit un modèle de visualisation ( VISU_DataLogManager ) qui peut être ajouté à la visualisation. Pour plus d'informations, voir : IHMEn mode en ligne, cette page fournit des informations statistiques sur la lecture et l'écriture des variables. " }, 
{ "title" : "Boîte de dialogue : Enregistrement des données ", 
"url" : "ac_dlm_datalogmanager_module.html#UUID-5158e4eb-39c1-2002-c9f6-d4d4a1d20765_f45d0fbcc9eecefdc0a8646307e5e8bf_id_2bd57d34d6d13475c0a8640e0192d4cf", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de journaux de données \/ Module : DataLog Manager \/ Boîte de dialogue : Enregistrement des données ", 
"snippet" : "Dans cette boîte de dialogue, un ou plusieurs groupes peuvent être exclus du stockage. Par défaut le DataLogManager le groupe est créé. Ajouter Ajout et suppression de groupes exclus du stockage. Retirer...", 
"body" : "Dans cette boîte de dialogue, un ou plusieurs groupes peuvent être exclus du stockage. Par défaut le DataLogManager le groupe est créé. Ajouter Ajout et suppression de groupes exclus du stockage. Retirer " }, 
{ "title" : "Module : Canal DataLog ", 
"url" : "ac_dlm_channel_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de journaux de données \/ Module : Canal DataLog ", 
"snippet" : "Canal DataLog le Canal DataLog module est utilisé pour définir des groupes pour le stockage des variables. Le module peut être ajouté sous le Gestionnaire de journaux de données nœud. Ceci est fait par le Ajouter une instance de sous-module commande et la sélection du DataLogChannel module. Jusqu'à ...", 
"body" : "Canal DataLog le Canal DataLog module est utilisé pour définir des groupes pour le stockage des variables. Le module peut être ajouté sous le Gestionnaire de journaux de données nœud. Ceci est fait par le Ajouter une instance de sous-module commande et la sélection du DataLogChannel module. Jusqu'à 64 canaux DataLog peuvent être ajoutés. Boîte de dialogue : IHM, informations Pour plus de détails sur ces boîtes de dialogue, consultez la page d'aide IHM , et Information " }, 
{ "title" : "Boîte de dialogue : enregistrement des données ", 
"url" : "ac_dlm_channel_module.html#UUID-e506780f-95c5-ee2b-f5d3-9586237393e3_a5d87b34c9f11a67c0a8646314ce243b_id_1c75f716cd06b00bc0a865200055fd43", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de journaux de données \/ Module : Canal DataLog \/ Boîte de dialogue : enregistrement des données ", 
"snippet" : "Dans cette boîte de dialogue, un ou plusieurs groupes peuvent être définis qui sont gérés par ce canal. Par défaut, le nom d'instance de l'instance du module de voie est disponible dans la liste. Groupes enregistrés par ce canal Nouvelle Définition d'un groupe L'entrée est ajoutée à la liste à l'aid...", 
"body" : "Dans cette boîte de dialogue, un ou plusieurs groupes peuvent être définis qui sont gérés par ce canal. Par défaut, le nom d'instance de l'instance du module de voie est disponible dans la liste. Groupes enregistrés par ce canal Nouvelle Définition d'un groupe L'entrée est ajoutée à la liste à l'aide de la Ajouter commander. Utiliser des chemins d'instance hachés : L'entrée n'est pas stockée avec le chemin complet de l'instance mais avec la valeur de hachage de la chaîne pour économiser de l'espace mémoire. L'affectation entre le hachage et le chemin d'instance est enregistrée dans un fichier séparé. Retirer Supprime le groupe sélectionné de la liste Variables enregistrées Liste des variables affectées aux listes Ces variables ont le {attribute 'ac_datalog' := '<group name>'} attribut. Rafraîchir Met à jour la liste des variables journalisées Remarque : La liste ne peut être mise à jour que si le DataLog Generator est activé. Des variables peuvent être affectées aux groupes par le ac_datalog attribut. le ac_datalog_hysteresis L'attribut définit l'hystérésis qui doit être dépassée avant qu'une variable ne soit journalisée. Exemple VAR\n {attribute 'ac_datalog' := 'DataLogChannel'}\n {attribute 'ac_datalog_hysteresis' := '0.745'}\n rLogVar : REAL;\nEND_VAR " }, 
{ "title" : "Boîte de dialogue : Paramètres ", 
"url" : "ac_dlm_channel_module.html#UUID-e506780f-95c5-ee2b-f5d3-9586237393e3_a5d87b34c9f11a67c0a8646314ce243b_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de journaux de données \/ Module : Canal DataLog \/ Boîte de dialogue : Paramètres ", 
"snippet" : "Dans cette boîte de dialogue, les paramètres d'enregistrement des variables DataLog sont définis. Activer FALSE : Les variables stockées par ce canal ne sont pas enregistrées. Économisez au premier cycle TRUE : Toutes les variables de ce canal seront enregistrées dans le premier cycle. Enregistrer c...", 
"body" : "Dans cette boîte de dialogue, les paramètres d'enregistrement des variables DataLog sont définis. Activer FALSE : Les variables stockées par ce canal ne sont pas enregistrées. Économisez au premier cycle TRUE : Toutes les variables de ce canal seront enregistrées dans le premier cycle. Enregistrer cyclique Type de données TIME : Toutes les variables de ce canal seront stockées cycliquement. La valeur T#0s désactive la journalisation. " }, 
{ "title" : "Module: DataLog Storage CSV ", 
"url" : "ac_dlm_storage_csv_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de journaux de données \/ Module: DataLog Storage CSV ", 
"snippet" : "DataLog Storage CSV Le sous-module DataLog_Storage_CSV  définit le format de stockage d'un Canal DataLog sous forme de fichier CSV. Il peut être ajouté en dessous d'un nœud de canal DataLog Cela est fait par Ajouter une instance de sous-module commande et sélection du DataLogStorage_CSV  module. Dia...", 
"body" : "DataLog Storage CSV Le sous-module DataLog_Storage_CSV  définit le format de stockage d'un Canal DataLog sous forme de fichier CSV. Il peut être ajouté en dessous d'un nœud de canal DataLog Cela est fait par Ajouter une instance de sous-module commande et sélection du DataLogStorage_CSV  module. Dialogue : Informations Pour plus de détails sur ces boîtes de dialogue, consultez la page d'aide dans Informations . " }, 
{ "title" : "Boîte de dialogue : Paramètres ", 
"url" : "ac_dlm_storage_csv_module.html#UUID-77b82c47-16c6-5f2f-5d4f-34b67bccf3d3_d1edd6c9f1f1a7c0a864637755e4ae_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de journaux de données \/ Module: DataLog Storage CSV \/ Boîte de dialogue : Paramètres ", 
"snippet" : "Nom du stockage Nom du fichier de stockage Par défaut, l'espace réservé %CHANNEL_NAME% est défini. Cet espace réservé sera remplacé par le nom d'instance du canal DataLog supérieur. Le nom du fichier de stockage doit être unique, car tous les fichiers de stockage sont stockés dans le même répertoire...", 
"body" : "Nom du stockage Nom du fichier de stockage Par défaut, l'espace réservé %CHANNEL_NAME% est défini. Cet espace réservé sera remplacé par le nom d'instance du canal DataLog supérieur. Le nom du fichier de stockage doit être unique, car tous les fichiers de stockage sont stockés dans le même répertoire par défaut. Facultativement, un espace réservé %DATE% peut être ajouté pour la date de stockage. La résolution est définie dans le paramètre Chaîne de format pour remplacer %DATE% (voir ci-dessous). Exemple : Avec la spécification du nom '%CHANNEL_NAME%_AT_%DATE%' , le nom de fichier suivant est obtenu pour DataLogChannel_1 chaîne : Application_DataLogChannel_1_AT_20191211_02-10-30.csv Séparateur : Valeur ASCII pour le séparateur entre le nom et la valeur de la variable. Exemple : ',' Taille de la mémoire tampon : Taille de la mémoire tampon interne pour le stockage temporaire des entrées. Exemple : 2000 Niveau de remplissage de la mémoire tampon Valeur en pourcentage. Si la mémoire tampon est remplie jusqu'à cette valeur, son contenu est écrit dans le fichier CSV. Spécifier 0 désactive la mise en mémoire tampon. Une entrée dans le fichier a la forme suivante (avec | comme séparateur) : <TimeStamp>|<InstancePath\/Hash>|<Value>[|<TypeClass>] Si le stockage est exécuté avec des chemins hachés, le type de données n'est pas stocké avec chaque entrée, mais une seule fois dans un fichier séparé où le chemin d'instance Assignment hash ↔ est stocké. L'entrée de ce fichier est de la forme suivante : <InstancePath>|<TypeClass>|<Hash> En cas de modification en ligne, les fichiers ne sont pas supprimés. Les nouvelles entrées sont ajoutées. Dans le fichier de hachage, une modification en ligne est marquée d'un horodatage. Ainsi, l'attribution du chemin d'instance hash ↔ pour les entrées avant la modification en ligne est toujours possible. Lors de l'initialisation après un téléchargement (aucune modification en ligne), les données et les fichiers de hachage sont supprimés. Caractères encadrants Ajouter des caractères encadrants TRUE : les entrées de chaîne seront stockées dans leur environnement. Exemple : valeur de variable : File1 , entrée de fichier : -File1- . FALSE : les entrées de chaîne sont stockées sans caractères. Caractères encadrants Caractères utilisés pour encadrer. Exemple : '-' Chaîne de format pour remplacer %DATE% Format de date utilisé pour remplacer le %DATE% qui peut être spécifié en paramètre Nom du stockage (voir plus haut). Exemples : 'yyyyMMdd' , 'yyyyMMdd_hh-mm-ss' LineEnding Caractère indiquant la fin de la ligne dans le fichier " }, 
{ "title" : "Module : DataLog Storage SQLite ", 
"url" : "ac_dlm_storage_sqlite_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de journaux de données \/ Module : DataLog Storage SQLite ", 
"snippet" : "DataLog Storage SQLite Le sous-module DataLogStorage_SQLite définit le format de stockage d'un Canal DataLog pour une base de données SQLite. Il peut être ajouté sous un nœud de canal DataLog. Ceci est fait par le Ajouter une instance de sous-module commande et la sélection du DataLogStorage_SQLite ...", 
"body" : "DataLog Storage SQLite Le sous-module DataLogStorage_SQLite définit le format de stockage d'un Canal DataLog pour une base de données SQLite. Il peut être ajouté sous un nœud de canal DataLog. Ceci est fait par le Ajouter une instance de sous-module commande et la sélection du DataLogStorage_SQLite module. Boîte de dialogue : informations Pour plus de détails sur cette boîte de dialogue, voir : Information . " }, 
{ "title" : "Boîte de dialogue : Paramètres ", 
"url" : "ac_dlm_storage_sqlite_module.html#UUID-63e71af3-388f-498c-6553-5ab20ff603a1_accbd5f8d8b6d029c0a86463569e125f_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de journaux de données \/ Module : DataLog Storage SQLite \/ Boîte de dialogue : Paramètres ", 
"snippet" : "Nom de stockage : Nom du fichier d'archive Par défaut, l'espace réservé %CHANNEL_NAME% est défini. Cet espace réservé sera remplacé par le nom d'instance du canal DataLog supérieur. Le nom de l'archive doit être unique, car tous les fichiers d'archive sont stockés par défaut dans le répertoire d'ins...", 
"body" : "Nom de stockage : Nom du fichier d'archive Par défaut, l'espace réservé %CHANNEL_NAME% est défini. Cet espace réservé sera remplacé par le nom d'instance du canal DataLog supérieur. Le nom de l'archive doit être unique, car tous les fichiers d'archive sont stockés par défaut dans le répertoire d'installation du contrôleur. Toutes les instances de ce module d'une application partagent ce fichier. Ce fichier est initialement créé par l'un des modules de stockage. Le nom du fichier est toujours <ApplicationName>_DataLog.sqlite Nombre maximal d'entrées : Le nombre maximum d'entrées pour la base de données de cette instance de module. La valeur 0 désactive la fonction. Si le nombre maximum est dépassé, la table se comporte comme un tampon circulaire et les premières entrées seront écrasées. " }, 
{ "title" : "Définition des variables de journalisation ", 
"url" : "ac_dlm_definition_logging_variables.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Gestionnaire de journaux de données \/ Définition des variables de journalisation ", 
"snippet" : "Les variables sont signalées pour le enregistrement de données par attributs. ac_datalog [:= group name] : cet attribut affecte la variable à un groupe de journalisation. Si la variable est une variable structurée, tous les membres qui peuvent être journalisés et qui ne sont pas exclus seront journa...", 
"body" : "Les variables sont signalées pour le enregistrement de données par attributs. ac_datalog [:= group name] : cet attribut affecte la variable à un groupe de journalisation. Si la variable est une variable structurée, tous les membres qui peuvent être journalisés et qui ne sont pas exclus seront journalisés. Si aucun nom de groupe n'est défini, chaque instance de la variable structurée doit être marquée séparément. ac_datalog_set_default_group : définit le groupe de tous les membres d'une instance d'un type structuré qui ne sont pas explicitement affectés à un groupe. ac_datalog_exclude : Cet attribut exclut une variable d'un type de données structurées de l'enregistrement des données. ac_datalog_union_representant : Cet attribut définit un représentant au sein d'une UNION, qui est utilisé pour l'enregistrement des données. ac_datalog_hysteresis := ‘value‘ : Cet attribut définit l'hystérésis. La valeur doit être dépassée pour enregistrer une variable. Cet attribut n'est respecté que pour les types de données numériques. S'il est utilisé pour des types de données non numériques, un avertissement s'affiche et la valeur est ignorée. Vous trouverez une description supplémentaire et des exemples sur la page d'aide du Gestionnaire de persistance les attributs. " }, 
{ "title" : "Générateur de diagnostic d'appareil ", 
"url" : "ac_device_diagnose_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Générateur de diagnostic d'appareil ", 
"snippet" : "Le module de diagnostic d'appareil est un composant standard d'Application Composer, qui est inclus dans la bibliothèque AC_DeviceDiagnosis . Le module est un module de niveau supérieur et peut être ajouté à l'arborescence des modules par la commande Ajouter une instance de module de niveau supérieu...", 
"body" : "Le module de diagnostic d'appareil est un composant standard d'Application Composer, qui est inclus dans la bibliothèque AC_DeviceDiagnosis . Le module est un module de niveau supérieur et peut être ajouté à l'arborescence des modules par la commande Ajouter une instance de module de niveau supérieur . Module de diagnostic d'appareil dans l'arborescence des modules A l'aide du module de diagnostic d'appareil, une page de visualisation est créée, basée sur la configuration d'appareil existante, qui représente l'API et les appareils de bus de terrain connectés dans une structure arborescente. Dans cette arborescence, l'état de chaque composant est affiché. Si nécessaire, des informations détaillées peuvent être appelées ou le mode de fonctionnement de composants individuels modifié. Page de visualisation générée pour le diagnostic de l'appareil Diagnostic de l'appareil en mode en ligne En mode en ligne, le nom de l'appareil, l'état et le code d'erreur sont affichés. L'état des appareils est affiché dans un jeu de couleurs : Vert : l'appareil a l'état \"En cours d'exécution\" Rouge : l'appareil n'a pas l'état \"En cours d'exécution\" Boîte de dialogue pour modifier l'état Cliquer sur l'appareil ouvre une fenêtre dans laquelle l'appareil peut être arrêté, ( Arrêter ), réinitialiser ( Réinitialiser ) ou commencé ( Démarrer) . Lorsque la boîte de dialogue est ouverte pour la première fois, toutes les fonctions sont affichées. Les fonctions qui ne sont pas prises en charge par le matériel seront masquées lors de la première activation. " }, 
{ "title" : "Conditions ", 
"url" : "ac_device_diagnose_overview.html#UUID-fd01086a-c692-d615-c1cf-d5963632aa4b_ac778b834d585cc0a8640e01a520c3_id_be299b7583c984f0c0a86520016ce88a", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Générateur de diagnostic d'appareil \/ Conditions ", 
"snippet" : "Les détails de diagnostic affichés proviennent des CAA-Device-Diagnose-FB (Device-FB) qui ont été créés par les appareils. Pour générer ces composants, l'option Activer le diagnostic pour les appareils doit être défini dans les paramètres de l'API. Ces FB fournissent non seulement les informations d...", 
"body" : "Les détails de diagnostic affichés proviennent des CAA-Device-Diagnose-FB (Device-FB) qui ont été créés par les appareils. Pour générer ces composants, l'option Activer le diagnostic pour les appareils doit être défini dans les paramètres de l'API. Ces FB fournissent non seulement les informations d'état normales qui sont affichées dans la vue d'ensemble (ci-dessus), mais également des informations détaillées, qui sont affichées sur un écran supplémentaire. Si l'option Activer le diagnostic pour les appareils n'a pas été défini avant la génération, le processus de génération est abandonné et l'option est définie automatiquement, de sorte que l'exécution de génération suivante crée la visualisation souhaitée. Pour générer cette page de visualisation, le générateur de diagnostic de l'appareil doit être activé dans Configuration du générateur . " }, 
{ "title" : "Commandes de l'éditeur d'applications ", 
"url" : "core_applicationcomposer_composer_home.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications ", 
"snippet" : "Les commandes de la catégorie de commande \"Composer\" sont fournies avec le CODESYS Application Composer . Ces commandes servent principalement à ajouter des objets composer au Arborescence des modules ou de les modifier. De plus, il existe des fonctions pour mapper les variables à la configuration I...", 
"body" : "Les commandes de la catégorie de commande \"Composer\" sont fournies avec le CODESYS Application Composer . Ces commandes servent principalement à ajouter des objets composer au Arborescence des modules ou de les modifier. De plus, il existe des fonctions pour mapper les variables à la configuration IO et pour construire un CODESYS application. La disponibilité des commandes dépend de l'objet sélectionné dans l'arborescence du module - seules les commandes autorisées à la position actuellement sélectionnée seront sélectionnées. " }, 
{ "title" : "Vue dédiée Application Composer ", 
"url" : "ac_dedicated_view.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Vue dédiée Application Composer ", 
"snippet" : "Application Composer offre un moyen aussi simple que possible de créer des applications entières et de les exécuter. Dédié à cet aspect de simplicité, CODESYS offre une vue réduite de l'interface utilisateur. Cette vue peut être démarrée en sélectionnant le profil \"CODESYS Composer Dedicated\" ou par...", 
"body" : "Application Composer offre un moyen aussi simple que possible de créer des applications entières et de les exécuter. Dédié à cet aspect de simplicité, CODESYS offre une vue réduite de l'interface utilisateur. Cette vue peut être démarrée en sélectionnant le profil \"CODESYS Composer Dedicated\" ou par le lien correspondant dans le CODESYS entrées du menu Démarrer. Après cela, une vue réduite de CODESYS , qui ne donne accès qu'aux fenêtres et commandes absolument nécessaires pour créer une application fonctionnelle à l'aide de CODESYS Application Composer L'éditeur d'application s'affiche. Vue dédiée Application Composer Il n'y a que des fenêtres pour l'arborescence des modules, l'arborescence des périphériques et les messages ainsi que des commandes pour les opérations de connexion\/déconnexion\/exécution\/arrêt en ligne et Composer. Au sein de cette dernière, deux commandes sont fortement liées à la vue « Application Composer dédiée » : Générer, compiler et se connecter : utilisé pour générer du code, le compiler et éventuellement se connecter à l'appareil et démarrer l'application sur l'appareil. Ajouter une bibliothèque de modules au projet : utilisé pour ajouter des bibliothèques au gestionnaire de bibliothèques du pool de POU, qui n'est normalement pas disponible dans la vue \"Application Composer dédiée\". Toute bibliothèque ajoutée contenant des modules rend les modules disponibles pour être ajoutés dans l'arborescence des modules. " }, 
{ "title" : "Arborescence des modules ", 
"url" : "ac_module_tree.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Arborescence des modules ", 
"snippet" : "En plus de l'arborescence des appareils et de l'arborescence des POU, Application Composer propose l'arborescence des modules. Cette arborescence permet de créer ou de modifier une application en utilisant les modules prédéfinis. Les commandes Application Composer permettent d'ajouter des sous-modul...", 
"body" : "En plus de l'arborescence des appareils et de l'arborescence des POU, Application Composer propose l'arborescence des modules. Cette arborescence permet de créer ou de modifier une application en utilisant les modules prédéfinis. Les commandes Application Composer permettent d'ajouter des sous-modules à l'arborescence des modules ou de les modifier ou de les supprimer. L'arborescence peut être réduite ou développée. Exemple d'arborescence de module Selon l'objet sélectionné, des modules compatibles peuvent être ajoutés à l'arborescence. Ceci peut être fait en utilisant le commandes dans le menu \"Composer\" ou en utilisant le menu contextuel. Les icônes des éléments sont définies dans la déclaration du module. " }, 
{ "title" : "Eléments de l'arborescence des modules ", 
"url" : "ac_module_tree.html#UUID-e2887a12-08dd-106a-0027-83341681c6bc_e38a4aaee73c0a8640e01c263f8_id_a88610fbb413e565c0a8640e00f61f5a", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Arborescence des modules \/ Eléments de l'arborescence des modules ", 
"snippet" : "(1) Modules de niveau supérieur définissant les paramètres de l'application et des tâches (2) : Sous-modules (3) : Références d'instance qui référencent des sous-modules. Les références d'instance n'ont pas leurs propres paramètres ou E\/S. (4) : Extensions qui peuvent être créées sans l'Application ...", 
"body" : "(1) Modules de niveau supérieur définissant les paramètres de l'application et des tâches (2) : Sous-modules (3) : Références d'instance qui référencent des sous-modules. Les références d'instance n'ont pas leurs propres paramètres ou E\/S. (4) : Extensions qui peuvent être créées sans l'Application Composer et qui permettent de faire des réglages sur la machine (5) : Slot (simple ou multi slots) qui peut être obligatoire ou facultatif " }, 
{ "title" : "Affichage de l'arborescence ", 
"url" : "ac_module_tree.html#UUID-e2887a12-08dd-106a-0027-83341681c6bc_e38a4aaee73c0a8640e01c263f8_id_8a0710cab44f1a9bc0a8640e00ddf9a1", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Arborescence des modules \/ Affichage de l'arborescence ", 
"snippet" : "Les nœuds enfants, qui sont affichés sous une instance de module étendue, seront affichés selon les règles suivantes, selon lesquelles l'ordre de tous les emplacements occupés et inoccupés correspond toujours à l'ordre de déclaration de la déclaration de module : Dans le cas où l'instance de module ...", 
"body" : "Les nœuds enfants, qui sont affichés sous une instance de module étendue, seront affichés selon les règles suivantes, selon lesquelles l'ordre de tous les emplacements occupés et inoccupés correspond toujours à l'ordre de déclaration de la déclaration de module : Dans le cas où l'instance de module à cet emplacement est uniquement référencée, elle n'a pas d'enfant. Tous les créneaux inoccupés sont affichés, à l'exception des créneaux facultatifs qui sont explicitement masqués. Pour les slots, le nom du rôle et le type sont affichés. Les emplacements occupés avec la cardinalité 1 ne sont pas affichés (les instances de sous-module connectées sont affichées à la place). L'instance de sous-module connectée remplace visuellement l'emplacement. Les sous-modules facultatifs et obligatoires sont affichés dans l'arborescence des modules à la position des emplacements. Le nom du rôle est affiché entre parenthèses après le nom de l'instance du module. Les instances de sous-module d'un emplacement multiple sont affichées sous l'emplacement respectif. Le nom du rôle s'affiche, car il est défini dans le nœud parent. Les propriétés suivantes des emplacements sont indiquées par des icônes supplémentaires : Emplacements optionnels Créneaux obligatoires Multi-emplacements Références aux instances de sous-module Si une instance de module est supprimée, toutes les références à cette instance de module seront marquées d'une icône d'erreur. Si le type d'une instance de module est modifié, toutes les références à ce module avec un type incorrect seront marquées d'une icône d'erreur. Selon la position dans l'arborescence des modules, le Couper \/ Copie \/ Pâte les commandes du menu contextuel peuvent être utilisées. Les éléments de l'arborescence des modules peuvent être déplacés par Drag&Drop. En appuyant sur le Ctrl lors d'une opération de Glisser-Déposer copiera l'élément. Les éléments de l'arborescence du module peuvent également être exportés et importés dans CODESYS . " }, 
{ "title" : "Boîte de dialogue des modules ", 
"url" : "ac_module_dialog.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Boîte de dialogue des modules ", 
"snippet" : "En utilisant les commandes Ajouter une instance de niveau supérieur , Ajouter une instance de sous-module , Instance de référence , et Module de mise à jour , une boîte de dialogue non modale s'ouvre. En fonction de la position dans l'arborescence des modules, tous les modules compatibles seront aff...", 
"body" : "En utilisant les commandes Ajouter une instance de niveau supérieur , Ajouter une instance de sous-module , Instance de référence , et Module de mise à jour , une boîte de dialogue non modale s'ouvre. En fonction de la position dans l'arborescence des modules, tous les modules compatibles seront affichés. Par un double clic sur le module ou avec le bouton Ajouter un module resp. Ajouter une instance de sous-module le module sélectionné sera copié dans l'arborescence des modules. Le bouton Ajouter un module ( ou Module de référence ) n'est activé que si un module compatible est sélectionné et si l'emplacement sélectionné dans l'arborescence des modules n'est pas plein. De plus, un nom valide (avec un identifiant CEI valide) doit être saisi. Le nom de l'objet ne peut être défini que pour les nouvelles instances de module. Dans la boîte de dialogue du Module de mise à jour commande, le nom ne peut pas être modifié. Afficher uniquement les instances compatibles : Cette option filtre, lorsqu'elle est activée, les instances affichées, afin que seules les instances compatibles soient affichées. S'il est désactivé, toutes les instances sont affichées, où les instances compatibles sont mises en évidence en gras. Application : L'instance du module de niveau supérieur est générée sous cette application. Cliquez sur pour sélectionner une application existante. Boîte de dialogue pour ajouter des instances de module Le dialogue est non modal. Il permet la sélection d'autres objets dans l'arborescence sans avoir à fermer la boîte de dialogue. Les éléments répertoriés dans la boîte de dialogue ainsi que les actions possibles sont ajustés automatiquement. Le comportement de cette boîte de dialogue est identique à celui de Ajouter un appareil dialogue. " }, 
{ "title" : "Commande : Générer ", 
"url" : "ac_generate.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Générer ", 
"snippet" : "produire Symbole: Cette commande (catégorie \"Composer\") démarre un processus de build qui génère automatiquement le CODESYS application à partir de l'arborescence des modules et les paramètres du Configuration du générateur . Les messages et les erreurs seront affichés dans la vue des messages. Tous...", 
"body" : "produire Symbole: Cette commande (catégorie \"Composer\") démarre un processus de build qui génère automatiquement le CODESYS application à partir de l'arborescence des modules et les paramètres du Configuration du générateur . Les messages et les erreurs seront affichés dans la vue des messages. Tous les objets créés par le générateur standard (sauf les objets tâches et les applications) seront stockés dans le sous-dossier de l'application resp. Pool de POU nommé AC_Std et AC_FBs . Si un dossier du même nom existe déjà, un nom unique sera créé en ajoutant un suffixe _0 . Blocs fonction générés Tous les objets créés par le Générer Les commandes sont marquées d’une icône de superposition bleue. Si l'utilisateur tente de supprimer, déplacer ou modifier l'un de ces objets, une boîte de dialogue s'ouvrira indiquant que cette action peut provoquer des problèmes de compilation. Si l'utilisateur continue, la couleur de l'icône de superposition passe au rouge (voir bloc fonction AC_PRG_RMP (PRG) dans la capture d'écran ci-dessus). Si vous utilisez Application Composer avec CODESYS SVN : Tous les objets générés par Composer sont marqués d'un Ignore on Commit pour SVN. De plus, SVN passe en mode hors ligne pour éviter les verrous SVN pendant l'exécution de la commande Built. Création de l'infrastructure de communication Définition : Dans la description suivante, l'application A1 envoie à l'application A2 (ou A2 reçoit de A1) si les conditions suivantes sont remplies : Une instance de module affectée à l'application A1 fait référence à une instance de module affectée à l'application A2 ou vice versa. Une sortie d'une instance de module qui est affectée à A1 est connectée à une instance de module qui est affectée à A2 au moyen d'une connexion E\/S de module directe. Tous les objets mentionnés ci-dessous seront créés dans le dossier AC_RMP pour chaque application créée par le générateur. Une tâche de communication sera créée. (Temps de cycle et priorité selon les réglages de la configuration du générateur). Dans cette tâche, les instances proxy seront appelées et les variables FB proxy du module miroir seront lues resp. écrit. Pour chaque application qui envoie vers l'application actuelle, un GVL (d'envoi) sera créé et les paramètres réseau seront définis. (Protocole \"UDP\", transmission cyclique, somme de contrôle, temps de cycle selon paramétrage, tâche de communication). L'\"identifiant de liste\" qui doit être une valeur entière comprise entre 1 et 2^15-1 sera déterminé aléatoirement au début de la génération et augmenté de 1 après chaque envoi de GVL. Cette valeur est d'au moins 128 et se situe dans la plage valide. S'il existe des références de module entre les applications une variable de type RMPExchangeData sera créé dans le GVL. Le nom de la variable contient le nom de l'application source et de l'application cible. Si une instance de module définit des variables dans sa définition de proxy à mettre en miroir ( MirrorVar ) et est référencé à partir d'une autre instance de module, pour chacun de ces MirrorVars, une variable sera créée dans le GVL (d'envoi) de l'instance de module référencée. Son nom contient le chemin d'instance de l'instance du module et le TargetID de la définition \"MirrorVar\" correspondante. Pour chaque application A2, à laquelle l'application actuelle envoie, un NVL (réception) sera créé et connecté au GVL d'envoi correspondant de A2 et à la tâche de communication. Un bloc fonction de type RMPService sera instancié dans le GVL AC_RMP et initialisé dans la déclaration (avec l'attribut init_on_onlchange ). Deux tableaux de type RMPConnection seront créés qui font référence aux variables créées de type RMPExchangeData dans les GVL et NVL. Un programme AC_PRG_RMP sera créé qui appelle le bloc fonction de type RMPService . Ce programme sera ajouté à la tâche de communication. De plus, la valeur des variables en miroir (\"MirrorVars\") sera définie et lue dans le AC_PRG_RMP programme. Cela signifie que le proxy \"MirrorVars\" sera affecté aux variables correspondantes du (recevoir) GVL. Puis le Main La méthode de l'instance proxy est appelée et enfin les variables correspondantes du GVL (expéditeur) du module \"MirrorVars\". Cela se produit en fonction du sens d'envoi des instances de module aux proxys. " }, 
{ "title" : "Création d'instances de blocs fonction par le générateur standard ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_65e9c9d2b9a5b65fc0a8640e0003897d", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Générer \/ Création d'instances de blocs fonction par le générateur standard ", 
"snippet" : "Pour chaque instance de module, un bloc fonction sera créé (dans le dossier AC_FBs ). Ce bloc fonction dérive du bloc fonction module. Le bloc fonction contient des variables d'entrée Instances de sous-module Tableaux de taille configurable Variables tampon des connexions E\/S directes Tableaux de mu...", 
"body" : "Pour chaque instance de module, un bloc fonction sera créé (dans le dossier AC_FBs ). Ce bloc fonction dérive du bloc fonction module. Le bloc fonction contient des variables d'entrée Instances de sous-module Tableaux de taille configurable Variables tampon des connexions E\/S directes Tableaux de multislots et références d'instance Le nom de la variable de tableau respective est créé par le préfixe AC_ARRAY_ suivi du nom de la variable de pointeur respective. Pour les tableaux avec une taille d'index variable (VarArrays), le nom peut être écrasé par le paramètre VarArray.InstName . La partie implémentation du bloc fonction contient la commande SUPER^(); qui appelle la partie implémentation du bloc fonction module. Exemple L'instance du module ModuleInstanceA est du type ModuleA et bloc fonctionnel associé ModuleA_FB . Cette instance a une instance de sous-module de type ModuleB . L'instance du module ModuleInstanceA est du type ModuleA et bloc fonctionnel associé ModuleA_FB . Cette instance a une instance de sous-module de type ModuleB . FUNCTION_BLOCK AC_ModuleInstanceA EXTENDS ModuleA_FB\n\nVAR_INPUT\n Inst_Sub1 : AC_ModuleInstanceB ;\nEND_VAR Le nom du bloc fonction est créé à partir du chemin de l'instance du module et du préfixe AC_ . Le nom de la variable de l'instance de sous-module est créé à partir d'un préfixe suivi du nom de l'instance de sous-module respective. Chaque bloc fonctionnel est instancié une fois, l'instance FB du module de niveau supérieur directement dans le GVL - le reste dans les blocs fonctionnels correspondants des instances pères. Pour chaque instance de module référencée qui se trouve dans une autre application, exactement une instance de bloc fonctionnel du FB proxy sera créée dans un GVL d'une instance de module référente. Le nom de l'instance proxy est AC_PROXY_<InstanceName> où <InstanceName> est le nom de l'instance cible dans l'autre application. Des adresses uniques sont attribuées à toutes les instances de module. Les instances FB proxy sont attribuées par les adresses des instances de module dans l'application distante. La méthode IBaseInstance.Main des instances proxy est appelée cycliquement dans la tâche de communication. " }, 
{ "title" : "Création de l'application et des appels de tâches ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_c88cdc4bba310f0dc0a8640e0094f683", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Générer \/ Création de l'application et des appels de tâches ", 
"snippet" : "Si un module est affecté à une application qui n'existe pas, cette application sera créée. Création d'une tâche standard inexistante TASK_MODULE_HIGH TASK_MODULE_MEDIUM TASK_MODULE_LOW La priorité et le temps de cycle des tâches sont définis en fonction des paramètres du générateur. De plus, des tâc...", 
"body" : "Si un module est affecté à une application qui n'existe pas, cette application sera créée. Création d'une tâche standard inexistante TASK_MODULE_HIGH TASK_MODULE_MEDIUM TASK_MODULE_LOW La priorité et le temps de cycle des tâches sont définis en fonction des paramètres du générateur. De plus, des tâches spécifiques au module avec les paramètres donnés seront créées. Création d'une liste de variables globales par niveau supérieur. Dans ce GVL, les instances de module situées sous les instances de module de niveau supérieur de la même application seront créées. La liste des variables globales a le nom défini dans le module, ou si elle n'a pas de nom défini, elle obtiendra le nom GVL_MODULE . Le GVL est situé sous l'application sélectionnée ou dans l'arborescence globale des POU. Création d'un GVL avec le nom GVL_ MODULE_TREE pour chaque candidature. Cette liste contient des variables pour gérer l'arborescence des modules. Le GVL sera créé dans le dossier AC_Std . Création du code d'initialisation qui est appelé automatiquement lors du téléchargement et de la modification en ligne : L'arborescence sera créée. Les valeurs des paramètres seront définies. Les références et les instances de sous-modules seront attribuées. Les tableaux de taille variable seront remplis. Les références d’instance seront définies. Lors du téléchargement, seuls les paramètres qui ne sont pas définis sur leur valeur par défaut seront définis. Lors du changement en ligne, tous les paramètres seront définis. Les POU seront créés dans le dossier AC_Std . Pour chaque point d'entrée défini, un PROGRAM Un POU (langage ST) sera créé qui contient les appels des modules de niveau supérieur. L'appel de ce nouveau POU sera ajouté en dessous de la tâche. Dans le cas de la tâche standard, les noms des POU sont : MODULE_CALL_<TASKNAME>_START MODULE_CALL_<TASKNAME>_END Les POU seront créés dans le dossier AC_Std . Pour les modules de niveau supérieur dans le POU pool, les appels de tâches seront créés dans toutes les applications. " }, 
{ "title" : "Création de l'affectation des E\/S ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_bf24656dba310f0fc0a8640e01fdf5a6", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Générer \/ Création de l'affectation des E\/S ", 
"snippet" : "En fonction du type d'affectation des E\/S, les actions suivantes seront exécutées : [Canal E\/S] : dans le canal d'appareil correspondant, le nom d'instance des E\/S de l'instance de module sera ajouté. [expression ST] : les affectations des expressions aux entrées ou des sorties aux expressions seron...", 
"body" : "En fonction du type d'affectation des E\/S, les actions suivantes seront exécutées : [Canal E\/S] : dans le canal d'appareil correspondant, le nom d'instance des E\/S de l'instance de module sera ajouté. [expression ST] : les affectations des expressions aux entrées ou des sorties aux expressions seront pour toutes les instances de module situées en dessous de la même instance de niveau supérieur. S'il existe des affectations correspondantes, pour chaque instance de niveau supérieur, une fonction nommée AC_Io_SetInputs_<instance name> ou AC_Io_SetOutputs_<instance name> sera créé. La tâche qui définit les entrées et les sorties sera identifiée par le drapeau UPDATE-IOS dans la description du module. Cette tâche sera appelée « tâche d'E\/S » dans la description suivante. La fonction pour les entrées sera appelée dans la tâche d'E\/S avant que la méthode de tâche de l'instance de module ne soit appelée. (Si la tâche d'E\/S est une tâche standard, avant la méthode de démarrage.) La fonction pour les sorties sera appelée dans la tâche d'E\/S après la méthode de tâche de l'instance de module. (Si la tâche d'E\/S est une tâche standard, après la méthode end.) [Connexion directe au module E\/S, local] : Une variable tampon de type compatible sera créée dans le bloc fonction de l'instance de l'entrée. Le nom de la variable tampon commence par le préfixe AC_Io_Buffer_ . Les variables tampon seront initialisées aux valeurs actuelles des sorties connectées lors de l'initialisation de l'application. Le générateur gère les affectations d'entrée et de sortie comme une affectation ST à cette variable tampon (voir [Expression ST]. [Connexions directes aux E\/S du module, à distance] : Pour chaque sortie connectée à une entrée d'une instance de module d'une autre application, une variable tampon de type compatible sera créée dans le réseau d'émission GVL correspondant. Le nom de la variable tampon commence par un préfixe AC_RemoteIo_Buffer_ et sera construit à partir du chemin de l'instance et du chemin de la variable de la sortie. Les variables tampon seront initialisées avec l'expression d'initialisation de la variable de sortie, si elle existe. Si la valeur de cette expression d'initialisation n'est pas contenue dans les informations de précompilation (car l'expression utilise des exemples : variables, fonctions et constantes), une erreur est créée. Le générateur gère l'affectation de sortie comme une affectation à cette variable tampon. L'affectation d'entrée dans l'autre application est gérée comme une affectation de la variable correspondante dans le récepteur NVL (voir [expression ST]). Remarque : La synchronisation entre la tâche dans laquelle la variable réseau doit être mise à jour et la tâche d'E\/S du module n'est pas encore réalisée. Par conséquent, il est possible que les valeurs aient été écrites de manière incomplète pendant que la tâche d'E\/S les lit. " }, 
{ "title" : "Commande : Configuration du générateur ", 
"url" : "ac_generator_configuration.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Configuration du générateur ", 
"snippet" : "Configuration du générateur Cette commande (catégorie \"Composer\") ouvre une boîte de dialogue avec tous les générateurs disponibles. Dans cette boîte de dialogue, chaque générateur peut être activé ou désactivé. Un clic sur l'icône \"Outils\" ouvre une boîte de dialogue détaillée avec des paramètres s...", 
"body" : "Configuration du générateur Cette commande (catégorie \"Composer\") ouvre une boîte de dialogue avec tous les générateurs disponibles. Dans cette boîte de dialogue, chaque générateur peut être activé ou désactivé. Un clic sur l'icône \"Outils\" ouvre une boîte de dialogue détaillée avec des paramètres spécifiques sur le générateur actuellement sélectionné et activé. " }, 
{ "title" : "Générateur d'appareils ", 
"url" : "ac_generator_configuration.html#UUID-808f4cf5-ae70-df89-d868-14922e672101", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Configuration du générateur \/ Générateur d'appareils ", 
"snippet" : "Ce générateur essaie de générer les appareils nécessaires et les connecte aux E\/S du module, si possible. Dans la version actuelle du plug-in Application Composer, aucune boîte de dialogue de configuration n'est disponible pour le générateur de périphériques....", 
"body" : "Ce générateur essaie de générer les appareils nécessaires et les connecte aux E\/S du module, si possible. Dans la version actuelle du plug-in Application Composer, aucune boîte de dialogue de configuration n'est disponible pour le générateur de périphériques. " }, 
{ "title" : "Générateur SourceTemplate ", 
"url" : "ac_generator_configuration.html#UUID-dcd74dd8-c2bf-daf3-03d2-c4b54ecf55a8", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Configuration du générateur \/ Générateur SourceTemplate ", 
"snippet" : "Ce générateur copie les blocs fonctionnels existants du POU piscine à l'application. Les blocs fonctionnels copiés sont ajoutés dans le AC_SourceTemplate dossier. Dans ce dossier, la fonction supplémentaire AC_SourceTemplateInit est également ajouté. Ce bloc fonction permet d'initialiser les blocs f...", 
"body" : "Ce générateur copie les blocs fonctionnels existants du POU piscine à l'application. Les blocs fonctionnels copiés sont ajoutés dans le AC_SourceTemplate dossier. Dans ce dossier, la fonction supplémentaire AC_SourceTemplateInit est également ajouté. Ce bloc fonction permet d'initialiser les blocs fonction copiés. Les blocs fonctionnels créés peuvent être modifiés et ne sont pas écrasés par une nouvelle exécution du générateur. Les blocs fonctionnels inutilisés sont renommés et déplacés vers le UnusedSourceTemplate sous-dossier. Puis la rallonge _unused est ajouté. Condition : Le générateur standard doit être activé. " }, 
{ "title" : "Générateur par défaut ", 
"url" : "ac_generator_configuration.html#UUID-a3c9c7e9-e567-6ffc-3f6c-ae4016d57a70", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Configuration du générateur \/ Générateur par défaut ", 
"snippet" : "Paramètres de tâche par défaut Tâche hautement prioritaire Définition de la priorité et de l'intervalle des tâches définies par l'utilisateur Les tâches définies par l'utilisateur peuvent être paramétrées dans l'éditeur des modules de niveau supérieur (voir Utilisation). Tâche de priorité moyenne Tâ...", 
"body" : "Paramètres de tâche par défaut Tâche hautement prioritaire Définition de la priorité et de l'intervalle des tâches définies par l'utilisateur Les tâches définies par l'utilisateur peuvent être paramétrées dans l'éditeur des modules de niveau supérieur (voir Utilisation). Tâche de priorité moyenne Tâche de faible priorité Paramètres de communication Activer la communication RMP : Les éléments nécessaires à la communication RMP sont créés. Priorité des tâches Priorité des tâches RMP Intervalle de tâche Intervalle de tâche de la tâche RMP Pragmes du compilateur GVL Définition des pragmas du compilateur Cette liste de pragmas est insérée devant les GVL ou modules fonction générés. Blocs fonctionnels Configuration des symboles Générer une configuration de symbole : L'objet de configuration du symbole est ajouté à l'application. " }, 
{ "title" : "Générateur de persistance ", 
"url" : "ac_generator_configuration.html#UUID-e4484f57-2155-dad9-990f-264462e75e1e", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Configuration du générateur \/ Générateur de persistance ", 
"snippet" : "Le générateur de persistance lit la configuration de persistance à partir de l'arborescence du module et crée un objet de configuration de persistance sous chaque application qui utilise la persistance. Pour plus d'informations, voir aussi : Gestionnaire de persistanceUne application utilise la fonc...", 
"body" : "Le générateur de persistance lit la configuration de persistance à partir de l'arborescence du module et crée un objet de configuration de persistance sous chaque application qui utilise la persistance. Pour plus d'informations, voir aussi : Gestionnaire de persistanceUne application utilise la fonctionnalité de persistance du composeur d'application si une instance de Persistence Manager est mappée à cette application. " }, 
{ "title" : "Générateur de DataLog ", 
"url" : "ac_generator_configuration.html#UUID-0a4d1c9e-c363-489e-e742-4b6d5c1afaa4", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Configuration du générateur \/ Générateur de DataLog ", 
"snippet" : "Le générateur DataLog crée un objet de configuration DataLog à partir de la configuration de l'arborescence du module. Cet objet sera ajouté à l'application à laquelle l'instance du Gestionnaire de journaux de données est cartographié. Dans la version actuelle du CODESYS Application Composer , aucun...", 
"body" : "Le générateur DataLog crée un objet de configuration DataLog à partir de la configuration de l'arborescence du module. Cet objet sera ajouté à l'application à laquelle l'instance du Gestionnaire de journaux de données est cartographié. Dans la version actuelle du CODESYS Application Composer , aucune boîte de dialogue de configuration n'est disponible pour le générateur DataLog. " }, 
{ "title" : "Générateur de tendance ", 
"url" : "ac_generator_configuration.html#UUID-b0155d06-1fc0-2914-55ee-2233ae0d22ee", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Configuration du générateur \/ Générateur de tendance ", 
"snippet" : "Le générateur de tendance lit les définitions de tendance à partir des descriptions de module et crée une configuration de tendance avec les visualisations associées. Ces visualisations seront intégrées dans les visualisations existantes....", 
"body" : "Le générateur de tendance lit les définitions de tendance à partir des descriptions de module et crée une configuration de tendance avec les visualisations associées. Ces visualisations seront intégrées dans les visualisations existantes. " }, 
{ "title" : "Générateur d'alarme ", 
"url" : "ac_generator_configuration.html#UUID-62c4fd14-9eaa-46b5-f370-4e36a88614fe", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Configuration du générateur \/ Générateur d'alarme ", 
"snippet" : "Le générateur d'alarmes lit les définitions d'alarmes à partir des descriptions de modules et crée ou étend les composants associés de la gestion des alarmes. De plus, une visualisation est créée à partir d'un modèle. Dans cette visualisation, une table d'alarmes est insérée. La visualisation sera a...", 
"body" : "Le générateur d'alarmes lit les définitions d'alarmes à partir des descriptions de modules et crée ou étend les composants associés de la gestion des alarmes. De plus, une visualisation est créée à partir d'un modèle. Dans cette visualisation, une table d'alarmes est insérée. La visualisation sera ajoutée aux autres modèles de visualisation du générateur de visualisation comme visualisation de haut niveau . Modèle Modèle pour l'écran de visualisation. Remarque : Pour utiliser une visualisation comme modèle, elle doit satisfaire aux conditions suivantes : Un rectangle avec le nom Placeholder_AlarmTable Les variables bAckVisible , bAckSel , bHistory , et bFreezeScrlPos de type BOOL Modèle de stockage d'alarme Objets de type AlarmStorageTemplate , qui se trouvent dans le projet en cours et les bibliothèques référencées Le modèle sélectionné sera utilisé pour toutes les configurations d'alarme générées. Créer un onglet de niveau supérieur : Un onglet de niveau supérieur sera créé pour la visualisation d'alarme créée. Le nom défini sera affiché dans l'onglet de niveau supérieur. " }, 
{ "title" : "Générateur de diagnostic d'appareil ", 
"url" : "ac_generator_configuration.html#UUID-eacb5fd7-1329-2790-9483-fe45edbe632a", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Configuration du générateur \/ Générateur de diagnostic d'appareil ", 
"snippet" : "Ce générateur crée des écrans de visualisation pour le diagnostic de l'appareil. Dans les paramètres, le modèles de visualisation et la disposition des écrans peut être définie. Paramètres du générateur de diagnostic de l'appareil Dans la boîte de dialogue, les modèles de visualisation de base, de m...", 
"body" : "Ce générateur crée des écrans de visualisation pour le diagnostic de l'appareil. Dans les paramètres, le modèles de visualisation et la disposition des écrans peut être définie. Paramètres du générateur de diagnostic de l'appareil Dans la boîte de dialogue, les modèles de visualisation de base, de modèle PLC, de modèle de bus, de modèle de pile, de modèle d'appareil parent et de modèle d'appareil enfant peuvent être définis. Les listes déroulantes répertorient tous les modèles de visualisation disponibles qui correspondent aux types de modèles respectifs. Dans la partie inférieure de la boîte de dialogue, la taille minimale de l'écran de visualisation et l'espace entre les éléments de visualisation du diagnostic de l'appareil peuvent être définis. " }, 
{ "title" : "Générateur de programmes CFC ", 
"url" : "ac_generator_configuration.html#UUID-fdaff0f3-814e-b71a-bcac-a2994393c9ed", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Configuration du générateur \/ Générateur de programmes CFC ", 
"snippet" : "Le générateur CFC sert à créer des programmes CFC. Toujours régénérer toutes les broches CFC : : Application Composer essaie toujours de générer toutes les E\/S de bloc fonctionnel pour les appels FB d'instance de module....", 
"body" : "Le générateur CFC sert à créer des programmes CFC. Toujours régénérer toutes les broches CFC : : Application Composer essaie toujours de générer toutes les E\/S de bloc fonctionnel pour les appels FB d'instance de module. " }, 
{ "title" : "Générateur de visualisation ", 
"url" : "ac_generator_configuration.html#UUID-a364420f-f798-9fe6-3c1a-b98bc7c07391", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Configuration du générateur \/ Générateur de visualisation ", 
"snippet" : "Ce générateur crée des écrans de visualisation pour les CODESYS Application Composer à partir des visualisations disponibles dans le CODESYS projet. Nom de niveau supérieur : Entrez un nom symbolique pour la visualisation modèle (\"modèle de niveau supérieur\"). Modèle : La liste de sélection propose ...", 
"body" : "Ce générateur crée des écrans de visualisation pour les CODESYS Application Composer à partir des visualisations disponibles dans le CODESYS projet. Nom de niveau supérieur : Entrez un nom symbolique pour la visualisation modèle (\"modèle de niveau supérieur\"). Modèle : La liste de sélection propose toutes les visualisations disponibles (dans le projet et les bibliothèques chargées) et compatibles. Si vous sélectionnez Défaut , le modèle par défaut de la bibliothèque AC_Module sera utilisé. Si un modèle configuré ici dans la boîte de dialogue est ultérieurement supprimé du projet ou de la bibliothèque, il reste disponible dans cette boîte de dialogue. TargetVisu , WebVisu : activez l'option correspondante, si le modèle de page doit être utilisé pour cette variante d'affichage. Largeur: Largeur de la visualisation générée en pixels (valeur par défaut : 640, minimum 100, maximum 10000) Hauteur: Hauteur de la visualisation générée en pixels (valeur par défaut : 480, minimum 100, maximum 10000) Largeur minimale de ToplevelTab : largeur minimale des onglets de niveau supérieur générés en pixels. Si 0 est entré ici, le réglage n'est pas pris en compte. Largeur maximale de ToplevelTab : largeur maximale des onglets de niveau supérieur générés en pixels. Si 0 est entré ici, le réglage n'est pas pris en compte. Pour plus d'informations sur les modèles de niveau supérieur, consultez : Modèles de niveau supérieurNombre maximal de clients : Nombre maximal de clients fonctionnant en parallèle (par défaut 8, minimum 1, maximum 128). Ignorer le visus généré si SVN est disponible : Si le projet est stocké dans Subversion, cette option doit être activée. : CODESYS s'assure que les visualisations générées sont ignorées dans SVN. Sinon, des problèmes pourraient survenir. Recréer le visus lors de la régénération : : A chaque génération de code, toutes les visualisations sont également régénérées et les visualisations existantes sont écrasées. Cette option doit être sélectionnée si l'on ne souhaite pas que l'utilisateur du module apporte des modifications aux visualisations générées après la génération. Cependant, si des modifications des visualisations sont encore nécessaires après la génération, l'option doit être désactivée. Puis CODESYS essaie de conserver les modifications ultérieures également avec les régénérations. Utiliser le nom d'instance par défaut pour les onglets de niveau supérieur : : Au lieu du chemin d'accès complet à l'instance, seul le nom de l'instance est affiché dans l'onglet de niveau supérieur. S'il y a une erreur dans la configuration, elle est affichée avec une icône de fournisseur d'erreur, et le d'accord le bouton est désactivé. " }, 
{ "title" : "Commande : Scanner ", 
"url" : "ac_scan.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Scanner ", 
"snippet" : "Analyse Symbole: Cette commande (catégorie \"Composer\") analyse l'ensemble du projet à la recherche de déclarations de module. Normalement, cette commande n'est pas nécessaire car CODESYS analyse automatiquement le système chaque fois que cela est nécessaire (exemple : après l'installation d'une nouv...", 
"body" : "Analyse Symbole: Cette commande (catégorie \"Composer\") analyse l'ensemble du projet à la recherche de déclarations de module. Normalement, cette commande n'est pas nécessaire car CODESYS analyse automatiquement le système chaque fois que cela est nécessaire (exemple : après l'installation d'une nouvelle bibliothèque). " }, 
{ "title" : "Commande : Vérifier et analyser tous les objets du pool ", 
"url" : "_ac_cmd_check_and_scan_all_pool_objects.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Vérifier et analyser tous les objets du pool ", 
"snippet" : "Vérifier et analyser tous les objets du pool Fonction : Lorsque la commande est appelée, le code CEI d'une bibliothèque est d'abord vérifié, puis les déclarations de module sont recherchées. Le test correspond à la commande LVérifiez tous les objets du pool . La recherche correspond à la commande An...", 
"body" : "Vérifier et analyser tous les objets du pool Fonction : Lorsque la commande est appelée, le code CEI d'une bibliothèque est d'abord vérifié, puis les déclarations de module sont recherchées. Le test correspond à la commande LVérifiez tous les objets du pool . La recherche correspond à la commande Analyse. Appel : Compositeur menu Exigence : La commande est visible uniquement lorsqu'un projet de bibliothèque est ouvert. " }, 
{ "title" : "Commande : Mapper les E\/S ", 
"url" : "ac_map_channels_for_ioconfig.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Mapper les E\/S ", 
"snippet" : "Mapper les E\/S Symbole: Cette commande (catégorie \"Composer\") ouvre une boîte de dialogue pour définir le mappage entre les modules et E\/S configuration. Dialogue: Mappage d'E\/S Sur le côté gauche de la boîte de dialogue, toutes les entrées et sorties des modules sont affichées dans une arborescence...", 
"body" : "Mapper les E\/S Symbole: Cette commande (catégorie \"Composer\") ouvre une boîte de dialogue pour définir le mappage entre les modules et E\/S configuration. Dialogue: Mappage d'E\/S Sur le côté gauche de la boîte de dialogue, toutes les entrées et sorties des modules sont affichées dans une arborescence selon les arborescence des modules . Sur le côté droit se trouve la structure de l’arborescence des appareils. Les connexions des modules de niveau supérieur aux applications sont établies en fonction des paramètres des modules de niveau supérieur. Cette connexion ne peut pas être modifiée dans cette boîte de dialogue. Les entrées sont affichées avec une connexion verte et une flèche verte - les sorties sont affichées en rouge. Les entrées ou sorties ouvertes (sans connexion) sont représentées par une ligne pointillée. Dans le cas où une expression ST est mappée à l'entrée resp. sortie, la connexion sera affichée avec un \"ST\". Les connexions entre modules et appareils ne sont possibles que d’entrée à entrée ou de sortie à sortie. De plus, les deux connexions doivent avoir un type de données compatible. Les connexions entre modules ne sont possibles que depuis les entrées vers les sorties et vice versa. Les connexions entre appareils ne sont pas possibles. Pour créer une connexion, l'entrée ou la sortie ouverte doit être sélectionnée. Une épingle sélectionnée s'affiche avec un fond bleu. Les entrées et sorties sont connectées par glisser-déposer. Une cible de connexion valide ou non valide est indiquée par différents pointeurs de souris. Les connexions existantes seront supprimées si l'entrée ou la sortie est occupée. Si un périphérique ou un module est réduit, la connexion sera dessinée en noir car il est possible que la direction des données ne puisse pas être déterminée. S'il est davantage réduit (par exemple, le périphérique supérieur), les connexions seront également masquées. Ceci est fait pour améliorer la vue d'ensemble car l'épaisseur du trait peut être réduite dans la zone médiane. Si une connexion sur le côté gauche ou droit est sélectionnée, le périphérique correspondant sera développé s'il est réduit. Les flèches indiquent la direction des données. Un périphérique réduit affiche des flèches vertes et rouges si le périphérique utilise des entrées et des sorties. S'il n'y a que des entrées ou des sorties, le sens des données est également affiché. En mode en ligne, les valeurs des paramètres sont affichées sur le côté gauche. Les valeurs ne peuvent pas être modifiées dans cette vue. Avec un double-clic sur un module ou un appareil, l'objet correspondant s'ouvre dans l'éditeur. Les connexions peuvent également être établies au-delà des limites des applications ! Si une instance de module est mappée au pool de POU, les lignes de connexion sont grisées. Dans cette situation, aucun mappage d'E\/S ne peut être créé, mais les mappages existants peuvent être supprimés. Imprimer : Cette commande permet d'imprimer les mappages d'E\/S définis dans un style d'aperçu. " }, 
{ "title" : "Commande : Sélection de caractères génériques ", 
"url" : "ac_wildcard_selection.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Sélection de caractères génériques ", 
"snippet" : "Sélection de caractères génériques Cette commande (catégorie \"Composer\") ouvre la boîte de dialogue Affectation de caractères génériques . La partie supérieure de la boîte de dialogue affiche les caractères génériques actuellement configurés et les types d'appareils attribués. Dans la partie inférie...", 
"body" : "Sélection de caractères génériques Cette commande (catégorie \"Composer\") ouvre la boîte de dialogue Affectation de caractères génériques . La partie supérieure de la boîte de dialogue affiche les caractères génériques actuellement configurés et les types d'appareils attribués. Dans la partie inférieure de la boîte de dialogue, le référentiel de périphériques est représenté, proposant les périphériques installés à sélectionner. Vous pouvez modifier les affectations dans la boîte de dialogue. À cette fin, la boîte de dialogue apparaît également lors de la génération de l'appareil, lorsque les caractères génériques ne peuvent pas être attribués automatiquement aux types d'appareil et qu'une affectation manuelle est nécessaire. L'affectation des caractères génériques aux types d'appareils est stockée dans le projet. Cependant, vous pouvez également utiliser un fichier XML pour enregistrer les affectations en externe et les recharger à partir de là. Le fichier et le chemin de ce fichier sont affichés en haut de la boîte de dialogue. Dialogue: Affectation de caractères génériques Nouveau : Cette commande permet de créer un nouveau fichier XML d'affectation de caractères génériques (vide). Définissez le nom du fichier et le répertoire de stockage. Sauvegarder : Cette commande enregistre explicitement l'affectation de périphérique générique actuellement définie dans un fichier choisi manuellement. En dehors de cela, les affectations seront automatiquement enregistrées dans le fichier actuellement spécifié, lors de la fermeture de la boîte de dialogue à l'aide du D'ACCORD bouton. Charger : Cette commande permet de charger un fichier d'affectation de caractères génériques (XML) existant. Dans l'arborescence en surbrillance, le ID de l'appareil (nom du module) La colonne affiche les identifiants des appareils du générateur de périphérique qui utilisent des caractères génériques. Le nom de l'instance de module qui apporte ce périphérique est indiqué entre parenthèses. Dans le cas d'un dispositif générateur d'appareil inséré statiquement (défini par la déclaration du module Identification et pas Wildcard \/ FlexibleWildcard ) un nœud standard Statique est créé et contient tous les périphériques insérés statiquement. Les appareils statiques ne peuvent pas être modifiés. Le Rapports Les colonnes montrent la relation entre les appareils parents et enfants du générateur de périphériques. Une ligne en gras indique une relation fixe, tandis qu'une ligne pointillée sert de suggestion de relation. La suggestion est basée sur la définition de ParentID dans le Device section. Les caractères génériques peuvent également être marqués comme vides en les sélectionnant simplement et en appuyant sur le bouton Del clé. Par exemple, un tel caractère générique vide pourrait servir à modifier les relations parent-enfant proposées. Les caractères génériques attribués sont affichés avec une couleur d'arrière-plan verte ; caractère générique non attribué avec une couleur de fond rouge. Afficher uniquement les compatibilités avec la première génération d'appareils parents possibles : Si cette option est activée, l'assortiment d'appareils de la vue du référentiel d'appareils est en outre limité aux appareils qui sont des enfants compatibles uniquement des premiers parents d'appareils. Ceci est défini par le configuration des modules . S'ils ne sont pas activés, les parents d'appareils de 2e, 3e,…, nième génération sont également traités comme des parents possibles, élargissant ainsi l'assortiment d'appareils affiché dans la vue du référentiel d'appareils. Règles de cession de propriété Si un appareil ou un canal IO ou une instance FB est sélectionné sur le côté gauche, toutes les propriétés de cet appareil ou canal IO ou instance FB qui sont déjà attribuées seront marquées par une case cochée sur le côté droit. Les appareils sur le côté gauche sans propriétés attribuées pour leurs canaux IO ou instances FB seront affichés avec un fond rouge, le canal IO ou l'instance FB concernée sera affiché avec un fond rouge, respectivement. Les appareils pour lesquels tous les canaux d'E\/S et instances FB sont affectés sont surlignés en vert, tout comme les canaux d'E\/S et instances FB connus. La cession inclut également le fait de ne pas céder une propriété « exigeante ». Ce dernier résultat peut être obtenu pour un appareil complet en double-cliquant sur un nœud d'appareil pour l'ensemble de l'appareil avec tous ses canaux d'E\/S et instances FB. Les propriétés de droite peuvent être ajoutées aux propriétés « d'offre » de l'appareil, du canal d'E\/S ou de l'instance FB sélectionnée à gauche en cochant la case. Un nombre illimité de propriétés, voire aucune, peut être attribué à un appareil, un canal d'E\/S ou une instance FB. Si une propriété d'E\/S « exigeante » est attribuée à un nœud d'appareil, cette propriété est alors attribuée à tous les nœuds de canal d'E\/S enfants de ce nœud d'appareil, mais pas aux instances FB. De même, si un appareil se voit attribuer une propriété InstRef « exigeante », alors seules les instances FB enfants de cet appareil se voient attribuer cette propriété. Plusieurs appareils, canaux d'E\/S ou instances FB peuvent être sélectionnés en même temps, chacun d'entre eux étant ensuite affecté, dans la mesure du possible, aux propriétés sélectionnées. Les propriétés « exigeantes » du côté droit qui sont proposées par au moins un appareil du côté gauche seront affichées sur fond vert. Les propriétés « exigeantes » sans offres correspondantes sur le côté gauche seront affichées sur fond rouge. " }, 
{ "title" : "Attribution de caractères génériques ", 
"url" : "ac_wildcard_selection.html#UUID-ceaa9faa-d44c-71c5-eba0-b0e56ec22feb_e2fe68ddbc7dc0a8640e014c3c31_id_342a92346a13602cc0a8640e00a6970a", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Sélection de caractères génériques \/ Attribution de caractères génériques ", 
"snippet" : "Il existe deux manières d'attribuer un caractère générique : Dans la partie supérieure de la boîte de dialogue, dans la ligne du caractère générique à attribuer, cliquez dans le champ de la colonne Appareils sélectionnés . Ensuite, dans l'arborescence du référentiel de périphériques dans la partie i...", 
"body" : "Il existe deux manières d'attribuer un caractère générique : Dans la partie supérieure de la boîte de dialogue, dans la ligne du caractère générique à attribuer, cliquez dans le champ de la colonne Appareils sélectionnés . Ensuite, dans l'arborescence du référentiel de périphériques dans la partie inférieure de la boîte de dialogue, double-cliquez sur le périphérique souhaité. Dans l'arborescence du référentiel de périphériques dans la partie inférieure de la boîte de dialogue, sélectionnez le périphérique souhaité. Puis, dans la partie supérieure de la boîte de dialogue, dans la ligne du joker à attribuer, double-cliquez sur le champ en colonne Appareils sélectionnés . " }, 
{ "title" : "Attribution des propriétés de l'appareil ", 
"url" : "ac_wildcard_selection.html#UUID-ceaa9faa-d44c-71c5-eba0-b0e56ec22feb_e2fe68ddbc7dc0a8640e014c3c31_id_4703909473b5f037c0a8640e01022fbe", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Sélection de caractères génériques \/ Attribution des propriétés de l'appareil ", 
"snippet" : "La commande Attribution des propriétés du périphérique ouvre la boîte de dialogue correspondante, qui sert à attribuer offre propriétés aux appareils. Dialogue: Attribution des propriétés de l'appareil Sur le côté gauche de la boîte de dialogue répertorie tous les appareils générés utilisés dans le ...", 
"body" : "La commande Attribution des propriétés du périphérique ouvre la boîte de dialogue correspondante, qui sert à attribuer offre propriétés aux appareils. Dialogue: Attribution des propriétés de l'appareil Sur le côté gauche de la boîte de dialogue répertorie tous les appareils générés utilisés dans le projet. Les nœuds enfants de ces appareils affichent toutes les entrées, sorties (non en gras) et les blocs fonctionnels créés (en gras) du type d'appareil correspondant. L'écran de droite répertorie toutes les propriétés \"exigeantes\", qui sont définies dans les déclarations de module des modules utilisés comme exigeant IO. Les nœuds enfants de ces « demandes » correspondent à tous les modules IO qui nécessitent que leurs nœuds parents soient exigeants. La boîte de dialogue d'attribution des propriétés permet d'attribuer les propriétés du côté droit aux appareils et à leurs canaux IO. Ces affectations seront enregistrées dans un fichier supplémentaire à côté de la description de l'appareil, qui fait référence au fichier supplémentaire. La boîte de dialogue s'ouvre automatiquement lors de la génération du code si toutes les propriétés « exigeantes » des IO du module ne sont pas satisfaites par au moins une affectation à un appareil qui offre ces propriétés. " }, 
{ "title" : "Commande : Supprimer les mappages d'E\/S ", 
"url" : "ac_remove_connections_to_ios.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Supprimer les mappages d'E\/S ", 
"snippet" : "Supprimer les mappages d'E\/S Cette commande (catégorie \"Composer\") supprime les mappages d'E\/S. Les sous-commandes suivantes sont fournies. Tout généré : Supprime les mappages générés automatiquement. Les mappages ajoutés manuellement restent. Tous : Supprime tous les mappages - mappages générés aut...", 
"body" : "Supprimer les mappages d'E\/S Cette commande (catégorie \"Composer\") supprime les mappages d'E\/S. Les sous-commandes suivantes sont fournies. Tout généré : Supprime les mappages générés automatiquement. Les mappages ajoutés manuellement restent. Tous : Supprime tous les mappages - mappages générés automatiquement et mappages ajoutés manuellement. Tous générés par l'instance de module : Si une instance de module est sélectionnée dans l'arborescence des modules, cette commande peut être exécutée. La commande supprime les mappages générés automatiquement de cette instance. Les mappages ajoutés manuellement restent. Toute l'instance de module : Si une instance de module est sélectionnée dans l'arborescence des modules, cette commande peut être exécutée. La commande supprime tous les mappages de cette instance : mappages générés automatiquement et mappages ajoutés manuellement. " }, 
{ "title" : "Commande : Ajouter une instance de module de niveau supérieur ", 
"url" : "ac_add_toplevel_module_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Ajouter une instance de module de niveau supérieur ", 
"snippet" : "Ajouter une instance de module de niveau supérieur Cette commande (catégorie \"Composer\") ouvre le Boîte de dialogue du module qui propose tous les modules de niveau supérieur qui peuvent être ajoutés à l'arborescence des modules. Il n'y a aucune limitation quant au nombre de modules de niveau supéri...", 
"body" : "Ajouter une instance de module de niveau supérieur Cette commande (catégorie \"Composer\") ouvre le Boîte de dialogue du module qui propose tous les modules de niveau supérieur qui peuvent être ajoutés à l'arborescence des modules. Il n'y a aucune limitation quant au nombre de modules de niveau supérieur pouvant être ajoutés à une application. " }, 
{ "title" : "Commande : Ajouter une instance de sous-module ", 
"url" : "ac_add_submodule_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Ajouter une instance de sous-module ", 
"snippet" : "Ajouter une instance de sous-module Cette commande (catégorie \"Composer\") ouvre le Boîte de dialogue du module qui propose tous les sous-modules qui peuvent être ajoutés à la position sélectionnée dans l'arborescence des modules. Les sous-modules qui offrent des emplacements de référence obligatoire...", 
"body" : "Ajouter une instance de sous-module Cette commande (catégorie \"Composer\") ouvre le Boîte de dialogue du module qui propose tous les sous-modules qui peuvent être ajoutés à la position sélectionnée dans l'arborescence des modules. Les sous-modules qui offrent des emplacements de référence obligatoires permettent de remplir automatiquement tous les emplacements de référence non ambigus. Dans cette situation, une boîte de dialogue demande à l'utilisateur si les modules doivent être référencés automatiquement ou non. " }, 
{ "title" : "Commande : Instance de module de référence ", 
"url" : "ac_reference_module_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Instance de module de référence ", 
"snippet" : "Instance de module de référence Cette commande (catégorie \"Composer\") ouvre le Boîte de dialogue du module qui propose tous les modules pouvant être référencés à la position sélectionnée dans l'arborescence des modules....", 
"body" : "Instance de module de référence Cette commande (catégorie \"Composer\") ouvre le Boîte de dialogue du module qui propose tous les modules pouvant être référencés à la position sélectionnée dans l'arborescence des modules. " }, 
{ "title" : "Commande : Afficher la vue des références du module ", 
"url" : "ac_module_references_editor.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Afficher la vue des références du module ", 
"snippet" : "Afficher la vue des références de module Cette commande (catégorie \"Composer\") ouvre le Référence des modules et fournit un aperçu de l'utilisation des instances de module dans le projet. La commande est disponible dans le menu contextuel si une instance de module est sélectionnée dans l'arborescenc...", 
"body" : "Afficher la vue des références de module Cette commande (catégorie \"Composer\") ouvre le Référence des modules et fournit un aperçu de l'utilisation des instances de module dans le projet. La commande est disponible dans le menu contextuel si une instance de module est sélectionnée dans l'arborescence des modules. La vue est mise à jour automatiquement si une autre instance de module est sélectionnée ou si les références de l'instance actuellement sélectionnée changent. " }, 
{ "title" : "Vue : Références des modules ", 
"url" : "ac_module_references_editor.html#UUID-7a9e7bcf-5b4a-4286-24df-e6cd7795a03a_c2a0935773056bc0a86463423a2ab0_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Afficher la vue des références du module \/ Vue : Références des modules ", 
"snippet" : "Application\/Source de référence Les références sont triées par application. Rôle de la référence auprès de sa cible Rôle de la référence auprès de sa cible...", 
"body" : "Application\/Source de référence Les références sont triées par application. Rôle de la référence auprès de sa cible Rôle de la référence auprès de sa cible " }, 
{ "title" : "Commande : Module de mise à jour ", 
"url" : "ac_update_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Module de mise à jour ", 
"snippet" : "Module de mise à jour Cette commande (catégorie \"Composer\") ouvre le Boîte de dialogue du module . L'arborescence des modules fournit tous les modules compatibles avec l'instance de module sélectionnée dans l'arborescence des modules. La commande permet de mettre à jour une instance de module vers u...", 
"body" : "Module de mise à jour Cette commande (catégorie \"Composer\") ouvre le Boîte de dialogue du module . L'arborescence des modules fournit tous les modules compatibles avec l'instance de module sélectionnée dans l'arborescence des modules. La commande permet de mettre à jour une instance de module vers un nouveau type de module. Il peut également s'agir d'une nouvelle version du même module. Lors de la mise à jour, les données configurées de l'instance seront conservées dans la mesure du possible : Les valeurs des paramètres qui existent dans les nouvelles versions seront adoptées même si la valeur actuelle est incompatible avec le nouveau type de paramètre. Si une valeur de paramètre n'est pas définie explicitement dans l'instance, alors la valeur par défaut du nouveau module est utilisée. Les mappages d'E\/S qui existent dans la nouvelle version et qui ont le même sens (entrée ou sortie) que l'affectation dans l'instance seront repris. Il n'est pas nécessaire que l'affectation soit du même type que la nouvelle E\/S à adopter. Les affectations de tâches qui existent dans les deux versions seront adoptées. Les sous-instances ou références d'emplacements qui ont le même ID d'emplacement dans le nouveau module seront conservées avec toutes les sous-instances et références. Cela s'applique même si le type des sous-instances ou des références ne correspond pas au nouvel emplacement, ou si la cardinalité du nouvel emplacement n'autorise pas toutes les sous-instances ou références. Les sous-instances ou références de slots qui n'existent pas dans le nouveau module sont insérées en dessous d'un nouveau slot nommé « Instances orphelines » ou « Références orphelines ». Ces emplacements sont identifiés par des identifiants spéciaux qui ne peuvent pas apparaître dans les emplacements normaux. Si un slot avec des éléments orphelins existe déjà, ce slot sera utilisé. Les sous-instances ou références d'emplacements qui existent dans le nouveau module mais qui attendent maintenant des références (en cas de sous-instances) ou des sous-instances (en cas de références) seront traitées comme des sous-instances resp. fait référence à l'emplacement qui n'est pas disponible dans le nouveau module. Les informations de niveau supérieur qui existent dans l'instance seront supprimées s'il y a une mise à jour d'un module qui n'est pas de niveau supérieur. Si aucune information de niveau supérieur n'existe dans l'instance, elle sera créée si le module est mis à jour vers un module de niveau supérieur. Données d'instance définies par extensions : Les extensions respectives déterminent quelles données seront conservées et lesquelles seront supprimées. Il doit adhérer au principe consistant à obtenir autant de données que possible. Si l'ordre des emplacements dans le nouveau module a changé, l'ordre des emplacements sous l'instance sera également ajusté en conséquence. Si la mise à jour supprime des données (par exemple, des valeurs de paramètres, des affectations d'E\/S, des emplacements non vides ou des données d'instance étendue), alors un message s'affichera décrivant les objets qui seront supprimés et permettant à l'utilisateur d'annuler la mise à jour. La mise à jour d'une instance peut être annulée en une seule étape d'annulation dans l'arborescence du module. " }, 
{ "title" : "Commande : Mettre à jour toutes les instances ", 
"url" : "ac_update_all_instances.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Mettre à jour toutes les instances ", 
"snippet" : "Mettre à jour toutes les instances Cette commande (catégorie \"Composer\") permet de mettre à jour toutes les instances de module vers les nouvelles versions des modules avec une seule commande. Cette commande n'est pas disponible dans le menu contextuel. Le comportement de la commande est conforme à ...", 
"body" : "Mettre à jour toutes les instances Cette commande (catégorie \"Composer\") permet de mettre à jour toutes les instances de module vers les nouvelles versions des modules avec une seule commande. Cette commande n'est pas disponible dans le menu contextuel. Le comportement de la commande est conforme à la description du Module de mise à jour commande, cependant une mise à jour vers un autre module n'est pas possible. " }, 
{ "title" : "Commande : Masquer les emplacements optionnels vides : Tous\/Sélectionnés uniquement ", 
"url" : "ac_hide_empty_optional_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Masquer les emplacements optionnels vides : Tous\/Sélectionnés uniquement ", 
"snippet" : "Masquer les emplacements optionnels vides : Tous\/Sélectionnés Avec ces commandes (catégorie \"Composer\") vous pouvez masquer les emplacements optionnels vides dans l'arborescence des modules. Selon le focus actuel, cela fait référence à tous les sous-modules ou uniquement au sous-module actuellement ...", 
"body" : "Masquer les emplacements optionnels vides : Tous\/Sélectionnés Avec ces commandes (catégorie \"Composer\") vous pouvez masquer les emplacements optionnels vides dans l'arborescence des modules. Selon le focus actuel, cela fait référence à tous les sous-modules ou uniquement au sous-module actuellement sélectionné. Les emplacements obligatoires ne peuvent pas être masqués. Exemple d'emplacements optionnels vides Pour afficher les emplacements cachés, veuillez utiliser le Afficher les emplacements cachés – Tous\/Sélectionnés uniquement commande. " }, 
{ "title" : "Commande : Afficher les emplacements masqués : Tous\/Sélectionnés uniquement ", 
"url" : "ac_show_hidden_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Afficher les emplacements masqués : Tous\/Sélectionnés uniquement ", 
"snippet" : "Afficher les emplacements masqués : Tous\/Sélectionnés uniquement Avec ces commandes (catégorie \"Composer\") dans l'arborescence des modules, vous pouvez rendre visibles à nouveau tous les emplacements qui avaient été masqués auparavant. Selon le focus actuel, cela fait référence à tous les sous-modul...", 
"body" : "Afficher les emplacements masqués : Tous\/Sélectionnés uniquement Avec ces commandes (catégorie \"Composer\") dans l'arborescence des modules, vous pouvez rendre visibles à nouveau tous les emplacements qui avaient été masqués auparavant. Selon le focus actuel, cela fait référence à tous les sous-modules ou uniquement au sous-module actuellement sélectionné. Pour masquer les emplacements, voir le Masquer les emplacements optionnels vides – Tous\/Sélectionnés uniquement commande. " }, 
{ "title" : "Commande : Aller à la cible ", 
"url" : "ac_go_to_target.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Aller à la cible ", 
"snippet" : "Aller à la cible Cette commande (catégorie \"Composer\") n'est disponible que si une référence de module est sélectionnée dans le arborescence des modules . Si cette commande est exécutée, la cible de la référence sera sélectionnée dans l'arborescence du module....", 
"body" : "Aller à la cible Cette commande (catégorie \"Composer\") n'est disponible que si une référence de module est sélectionnée dans le arborescence des modules . Si cette commande est exécutée, la cible de la référence sera sélectionnée dans l'arborescence du module. " }, 
{ "title" : "Commande : Créer un module d'extension ", 
"url" : "_ac_cmd_create_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Créer un module d'extension ", 
"snippet" : "Créer un module d'extension Symbole: La commande crée un module d'extension pour un emplacement de sous-module. Il n'est disponible que si un emplacement de module vide ou un sous-module est sélectionné dans l'arborescence des modules. La commande ouvre une boîte de dialogue dans laquelle vous défin...", 
"body" : "Créer un module d'extension Symbole: La commande crée un module d'extension pour un emplacement de sous-module. Il n'est disponible que si un emplacement de module vide ou un sous-module est sélectionné dans l'arborescence des modules. La commande ouvre une boîte de dialogue dans laquelle vous définissez si l'extension doit être créée en tant que nouveau module (\"Aucune variation\") ou en tant que variation d'un module existant ou d'une instance de module. A cet effet, tous les modules adaptés à l'emplacement sont proposés dans une liste déroulante. Il y a deux options : Dériver la variation Le module d'extension dérive du module ou de l'instance de module sélectionné dans Variante de . Le module choisi est importé via IMPORTS au module d'extension et le bloc fonction du nouveau module dérive du bloc fonction modèle de module. Copier la source pour la variante Un nouveau module d'extension est créé en copiant la déclaration complète du module, y compris le bloc fonction et les visualisations associées du module sélectionné dans Variante de (y compris le code source). Ceci n'est possible que si le module sélectionné dans Variante de est disponible dans le code source et pas seulement en tant que module d'une bibliothèque compilée. Les modules d'extension servent à ajouter toute modification ou extension spécifique à l'utilisateur aux modules ou instances de module existants et prédéfinis. Après avoir fermé la boîte de dialogue avec d'accord un nouveau dossier sera créé dans le POU pool avec le nom du module d'extension. Dans ce dossier, les objets suivants seront créés (où <nom> est le nom du module d'extension) : Cas standard : Un bloc fonction portant le nom <name> , étendant la classe \"Modules\" et implémentant l'interface requise du type de slot. Dans ce bloc fonctionnel, toutes les méthodes et propriétés seront créées, qui existent dans une interface implémentée mais qui ne sont implémentées dans aucune classe de base. Cas de variante : Comme dans le cas standard, un bloc fonction correspondant sera créé. Ce bloc fonction dérive du bloc fonction modèle de module choisi ( Dériver la variation ) ou en est une copie ( Copier la source pour la variante ). Un pool d'images et une liste de texte (nom IP_<name> ou TL_<name> ). Le pool d'images contient deux icônes avec identifiant Icon_16 et Icon_32 . La liste de textes contient l'entrée Desc , qui est rempli d'un <name> . Il n'y a pas de langues dans la liste de texte, seule la colonne Standard . Une page de visualisation vide Visu_M_<name> , qui implémente l'interface requise. Si Copier la variation à partir de la source est sélectionné, les visualisations du module source sont copiées à la place. Un module d'extension sera ajouté à l'arborescence des modules, qui n'a ni paramètres ni E\/S. Pour les métadonnées, les images, textes et éléments de visualisation créés seront utilisés. La catégorie est \"Extension\". S'il s'agit d'une variante \"dérivée\", la déclaration de modèle de module est également importée via IMPORTS . S'il s'agit d'une variante \"copiée\", la déclaration du modèle de module est copiée et adaptée de manière à utiliser les listes de textes et les pools d'images correspondants du module d'extension. " }, 
{ "title" : "Commande : Créer des entrées de liste de textes manquants ", 
"url" : "ac_create_missing_textlist_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Créer des entrées de liste de textes manquants ", 
"snippet" : "Créer des entrées de listes de texte manquantes Cette commande (catégorie \"Composer\") crée automatiquement toutes les listes de textes et entrées de liste de textes qui sont référencées par une déclaration de module et qui n'existent pas. La commande n'est disponible que si un éditeur de déclaration...", 
"body" : "Créer des entrées de listes de texte manquantes Cette commande (catégorie \"Composer\") crée automatiquement toutes les listes de textes et entrées de liste de textes qui sont référencées par une déclaration de module et qui n'existent pas. La commande n'est disponible que si un éditeur de déclaration de module est ouvert avec le focus dessus et l'objet existe dans le projet principal. La fonction ne fonctionne que s'il n'y a pas d'erreur de syntaxe. Les listes de textes seront créées sous le même objet père que l'objet dans l'éditeur. Avec les nouvelles entrées créées, seul le texte \"par défaut\" sera rempli (avec l'ID). " }, 
{ "title" : "Commande : générer les entrées manquantes dans les pools d'images ", 
"url" : "ac_create_missing_image_pool_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : générer les entrées manquantes dans les pools d'images ", 
"snippet" : "Générer des entrées manquantes dans les pools d'images La commande génère un pool d'images d'entrées définies dans une description de module mais qui n'existent pas encore dans un pool d'images du projet. Si le pool d'images n'existe pas encore, alors le pool d'images est généré dans le POU voir en ...", 
"body" : "Générer des entrées manquantes dans les pools d'images La commande génère un pool d'images d'entrées définies dans une description de module mais qui n'existent pas encore dans un pool d'images du projet. Si le pool d'images n'existe pas encore, alors le pool d'images est généré dans le POU voir en premier. Par défaut, la commande n'est pas disponible dans le Compositeur menu. Vous utilisez le Outils → Personnaliser boîte de dialogue pour l'ajouter à partir de la Compositeur catégorie de commande à la Compositeur menu. La commande est alors visible dans le Compositeur lorsqu'un module est ouvert et activé dans l'éditeur. " }, 
{ "title" : "Commande : Monter ", 
"url" : "ac_move_up.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Monter ", 
"snippet" : "Déplacer vers le haut Cette commande (catégorie \"Composer\") permet de changer la position des modules dans le arborescence des modules . Cette commande n'est disponible que pour les éléments multislots (instances et références de module) et si l'élément sélectionné n'est pas le premier élément du mu...", 
"body" : "Déplacer vers le haut Cette commande (catégorie \"Composer\") permet de changer la position des modules dans le arborescence des modules . Cette commande n'est disponible que pour les éléments multislots (instances et références de module) et si l'élément sélectionné n'est pas le premier élément du multislot. " }, 
{ "title" : "Commande : Descendre ", 
"url" : "ac_move_down.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Descendre ", 
"snippet" : "Descendre Cette commande (catégorie \"Composer\") permet de changer la position des modules dans le arborescence des modules . Cette commande n'est disponible que pour les éléments multislots (instances et références de module) et si l'élément sélectionné n'est pas le dernier élément du multislot....", 
"body" : "Descendre Cette commande (catégorie \"Composer\") permet de changer la position des modules dans le arborescence des modules . Cette commande n'est disponible que pour les éléments multislots (instances et références de module) et si l'élément sélectionné n'est pas le dernier élément du multislot. " }, 
{ "title" : "Commande : Rechercher les entrées inconnues ", 
"url" : "ac_check_for_unknown_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Rechercher les entrées inconnues ", 
"snippet" : "Vérifier les entrées inconnues Cette commande (catégorie \"Composer\") vérifie les déclarations de module pour les définitions de section inconnues. La sous-commande Tous , qui est toujours disponible, vérifie toutes les déclarations de module du projet. Si une déclaration de module est ouverte dans l...", 
"body" : "Vérifier les entrées inconnues Cette commande (catégorie \"Composer\") vérifie les déclarations de module pour les définitions de section inconnues. La sous-commande Tous , qui est toujours disponible, vérifie toutes les déclarations de module du projet. Si une déclaration de module est ouverte dans l'éditeur, la sous-commande supplémentaire Dans l'éditeur actuel vérifie la déclaration de module actuellement ouverte pour les définitions de section inconnues. " }, 
{ "title" : "Commande : générer, compiler et se connecter ", 
"url" : "ac_generate_compile_login.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : générer, compiler et se connecter ", 
"snippet" : "Générer, compiler et se connecter Symbole: Cette commande (catégorie \"Composer\") exécute plusieurs commandes en un seul clic de souris. Le code est d’abord créé et compilé. Si possible, l'application est connectée au contrôleur et démarrée....", 
"body" : "Générer, compiler et se connecter Symbole: Cette commande (catégorie \"Composer\") exécute plusieurs commandes en un seul clic de souris. Le code est d’abord créé et compilé. Si possible, l'application est connectée au contrôleur et démarrée. " }, 
{ "title" : "Commande : Ajouter une bibliothèque de modules au projet ", 
"url" : "ac_add_libraries_to_pou.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Ajouter une bibliothèque de modules au projet ", 
"snippet" : "Ajouter une bibliothèque de modules au projet Symbole: Cette commande (catégorie \"Composer\") ouvre une boîte de dialogue avec un module contenant des bibliothèques. Avec le D'ACCORD les bibliothèques sélectionnées seront ajoutées au gestionnaire de bibliothèques du pool de POU. Si la bibliothèque st...", 
"body" : "Ajouter une bibliothèque de modules au projet Symbole: Cette commande (catégorie \"Composer\") ouvre une boîte de dialogue avec un module contenant des bibliothèques. Avec le D'ACCORD les bibliothèques sélectionnées seront ajoutées au gestionnaire de bibliothèques du pool de POU. Si la bibliothèque standard Composer AC_ModlueBase est manquant, il est également ajouté automatiquement. Boîte de dialogue pour ajouter des bibliothèques Application Composer La boîte de dialogue fournit le bouton Ouvrir le gestionnaire de bibliothèque de POU qui permet d'ouvrir le gestionnaire de bibliothèque du POU piscine également dans Composer Dedicated voir. " }, 
{ "title" : "Commande : Points d'arrêt actifs vers l'étape suivante ", 
"url" : "ac_active_breakpoints_to_next_step.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Points d'arrêt actifs vers l'étape suivante ", 
"snippet" : "Points d'arrêt actifs à l'étape suivante Cette commande (catégorie \"Composer\") n'est disponible qu'en mode connecté et si la séquence s'est arrêtée sur un point d'arrêt. Il supprime les points d'arrêt actuellement actifs et en ajoute un nouveau aux étapes suivantes....", 
"body" : "Points d'arrêt actifs à l'étape suivante Cette commande (catégorie \"Composer\") n'est disponible qu'en mode connecté et si la séquence s'est arrêtée sur un point d'arrêt. Il supprime les points d'arrêt actuellement actifs et en ajoute un nouveau aux étapes suivantes. " }, 
{ "title" : "Commande : Centrer la vue sur les points d'arrêt ", 
"url" : "ac_center_view_to_breakpoints.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Centrer la vue sur les points d'arrêt ", 
"snippet" : "Centrer la vue sur les points d'arrêt Cette commande (catégorie \"Composer\") n'est disponible qu'en mode connecté et si la séquence s'est arrêtée sur un point d'arrêt. Il centre la vue de l'éditeur de séquence sur les points d'arrêt actuellement actifs....", 
"body" : "Centrer la vue sur les points d'arrêt Cette commande (catégorie \"Composer\") n'est disponible qu'en mode connecté et si la séquence s'est arrêtée sur un point d'arrêt. Il centre la vue de l'éditeur de séquence sur les points d'arrêt actuellement actifs. " }, 
{ "title" : "Commande : Création de modules de macro ", 
"url" : "ac_create_macro_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Création de modules de macro ", 
"snippet" : "Création de macro-modules Symbole: Cette commande (dans la catégorie \"Composer\") ouvre une boîte de dialogue de génération de modules macro. Pour utiliser cette commande, vous avez besoin d'une licence valide pour créer déclarations de modules . La commande est disponible si vous avez sélectionné un...", 
"body" : "Création de macro-modules Symbole: Cette commande (dans la catégorie \"Composer\") ouvre une boîte de dialogue de génération de modules macro. Pour utiliser cette commande, vous avez besoin d'une licence valide pour créer déclarations de modules . La commande est disponible si vous avez sélectionné un sous-arbre dans l'arborescence des modules. Vous pouvez utiliser cette commande pour générer un module macro à partir des modules du sous-arbre. De cette façon, vous pouvez définir quels emplacements, E\/S et paramètres du sous-module sont disponibles dans le nouveau module macro. Métadonnées Nom Il s'agit du nom unique du module macro. Description des macros La description est créée sous forme de listes de textes. Catégorie de macros La catégorie permet de subdiviser les modules dans la boîte de dialogue d'insertion des modules. Slots \/ E\/S \/ Paramètres Sous-arborescence du module macro Vue arborescente de tous les objets du sous-arbre La structure affiche également tous les emplacements, E\/S et paramètres de l'instance de sous-module respective en tant qu'éléments enfants (police en gras). Emplacements pour modules macro Ceci affiche tous les emplacements, E\/S et paramètres que le type de module macro doit inclure. Ces éléments viennent directement de l'arborescence à gauche. E\/S du module macro Paramètres du macro-module Ajouter à la macro Ceci est actif si vous sélectionnez un emplacement, une E\/S ou un paramètre dans l'arborescence de gauche. Vous ajoutez les éléments au module macro en cliquant sur ce bouton. Supprimer de la macro Ceci est actif si vous sélectionnez des emplacements, des E\/S ou des paramètres dans l'arborescence de droite. Vous supprimez les éléments du module macro en cliquant sur ce bouton. Lorsque vous fermez la boîte de dialogue en cliquant sur D'ACCORD , CODESYS Application Composer génère une déclaration de module, une liste de textes et un pool d'images pour ce module de macro. Les objets sont stockés dans un dossier portant le nom de la macro. Vous pouvez désormais éditer les objets générés sans restrictions et indépendamment de la génération. De cette façon, par exemple, vous pouvez échanger l'icône de macro dans le pool d'images. " }, 
{ "title" : "Commande : Signer tous les modules ", 
"url" : "ac_sign_all_modules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Signer tous les modules ", 
"snippet" : "Signer tous les modules Cette commande (catégorie \"Composer\") permet le signe (renouvelé) de tous les modules du pool POU. Cette commande peut être utilisée pour re-signer tous les modules du POU piscine. Les modules développés avec une licence valide sont automatiquement signés. Cette commande est ...", 
"body" : "Signer tous les modules Cette commande (catégorie \"Composer\") permet le signe (renouvelé) de tous les modules du pool POU. Cette commande peut être utilisée pour re-signer tous les modules du POU piscine. Les modules développés avec une licence valide sont automatiquement signés. Cette commande est destinée à reprendre les modules non signés existants des versions précédentes d'Application Composer. " }, 
{ "title" : "Commande : Aller au module FB ", 
"url" : "ac_goto_modul_fb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Aller au module FB ", 
"snippet" : "Aller au module FB La commande (catégorie \"Composer\") permet d'ouvrir le bloc fonction du module ou ses méthodes sous l'éditeur. Vous devez sélectionner un module dans l'arborescence des modules pour rendre cette commande disponible. En mode hors ligne, la déclaration du type de bloc fonction ou de ...", 
"body" : "Aller au module FB La commande (catégorie \"Composer\") permet d'ouvrir le bloc fonction du module ou ses méthodes sous l'éditeur. Vous devez sélectionner un module dans l'arborescence des modules pour rendre cette commande disponible. En mode hors ligne, la déclaration du type de bloc fonction ou de la méthode du bloc fonction sera ouverte dans l'éditeur. En mode en ligne, l'instance de bloc fonction ou la méthode de l'instance de module sera ouverte dans l'éditeur. " }, 
{ "title" : "Commande : valeurs de paramètres différentes ", 
"url" : "ac_differing_parameter_values.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : valeurs de paramètres différentes ", 
"snippet" : "Valeurs de paramètre différentes Utilisez cette commande en mode en ligne pour vérifier si les valeurs des paramètres des instances de module utilisées dans l'arborescence du module ont été modifiées dans le bloc fonction du module. Dans ce cas, vous obtiendrez une liste des modifications paramètres...", 
"body" : "Valeurs de paramètre différentes Utilisez cette commande en mode en ligne pour vérifier si les valeurs des paramètres des instances de module utilisées dans l'arborescence du module ont été modifiées dans le bloc fonction du module. Dans ce cas, vous obtiendrez une liste des modifications paramètres et des instances de module concernées dans le messages voir. Un double-clic sur un message ouvrira l'éditeur de paramètres de l'instance de module concernée. Là, tous les paramètres avec des valeurs différentes en mode en ligne et en mode hors ligne de l'application seront indiqués par des cellules encadrées en rouge dans les colonnes. Valeur et Valeur en ligne . " }, 
{ "title" : "Commande : Réinitialiser le texte des onglets de niveau supérieur ", 
"url" : "ac_reset_text_of_toplevel_tabs.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Réinitialiser le texte des onglets de niveau supérieur ", 
"snippet" : "Réinitialiser le texte des onglets de niveau supérieur Fonction : Cette commande réinitialise les textes aux paramètres par défaut pour le onglets de niveau supérieur qui ont été définis dans les éditeurs de modules dans le IHM languette. En cliquant Compositeur → Réinitialiser le texte des onglets ...", 
"body" : "Réinitialiser le texte des onglets de niveau supérieur Fonction : Cette commande réinitialise les textes aux paramètres par défaut pour le onglets de niveau supérieur qui ont été définis dans les éditeurs de modules dans le IHM languette. En cliquant Compositeur → Réinitialiser le texte des onglets de niveau supérieur → Tous réinitialise les textes de tous les onglets de niveau supérieur. En cliquant Compositeur → Réinitialiser le texte des onglets de niveau supérieur → Sélectionné uniquement réinitialise uniquement le texte du module sélectionné (dans le Modules voir). Cliquez sur Compositeur → Créer pour mettre à jour l'application. Appel : Compositeur menu Exigence : Des modules avec un texte spécialement configuré pour les onglets de niveau supérieur sont présents dans le Modules voir. Exemple pour un module Les étapes suivantes décrivent comment définir et réinitialiser le texte d'un onglet de niveau supérieur. Votre projet comprend le Building module. Double-cliquez sur le Building modules dans le Modules voir. L'éditeur de module (configurateur de module) s'ouvre. Activez l'option Créer un onglet de niveau supérieur . Ensuite, un champ de saisie apparaît avec le texte de niveau supérieur prédéfini Building . Spécifiez le texte City hall . Cliquez sur Compositeur → Créer . Les visualisations des modules et les Toplevel visualisation sont créées et stockées dans le Dispositifs voir. Double-cliquez sur le Toplevel visualisation dans le Dispositifs voir. → Enregistrez le projet. Double-cliquez sur le Building modules dans le Modules voir. Les commandes du Compositeur menus sont disponibles. Sélectionnez le Building module. Cliquez sur Compositeur → Réinitialiser le texte des onglets de niveau supérieur → Sélectionné uniquement . Le texte est réinitialisé au réglage par défaut Building dans l'éditeur de module dans le champ de saisie à côté du Créer un onglet de niveau supérieur option. Cliquez sur Compositeur → Créer . Les visualisations des modules et les Toplevel visualisation sont mises à jour et stockées dans le Dispositifs voir. Ouvrez le Toplevel visualisation dans le Dispositifs voir. → Exemple pour un sous-module Les étapes suivantes décrivent comment définir et réinitialiser le texte des onglets de niveau supérieur dans une structure de modules de modules et de sous-modules. Votre projet comprend le Building modules et le Bathroom sous-module. Double-cliquez sur le Building modules dans le Modules voir. L'éditeur de module (configurateur de module) s'ouvre. Activez l'option Créer un onglet de niveau supérieur . Ensuite, un champ de saisie apparaît avec le texte de niveau supérieur prédéfini Building . Spécifiez le texte City hall . Double-cliquez sur le Bathroom modules dans le Modules voir. L'éditeur de module (configurateur de module) s'ouvre. Activez l'option Créer un onglet de niveau supérieur . Ensuite, un champ de saisie apparaît avec le texte de niveau supérieur prédéfini Building.Bathroom . Spécifiez le texte WC . Cliquez sur Compositeur → Créer . Les visualisations des modules et les Toplevel visualisation sont créées et stockées dans le Dispositifs voir. Double-cliquez sur le Toplevel visualisation dans le Dispositifs voir. → Enregistrez le projet. Double-cliquez sur le Building modules dans le Modules voir. Les commandes du Compositeur menus sont disponibles. Sélectionnez le Building module. Cliquez sur Compositeur → Réinitialiser le texte des onglets de niveau supérieur → Tout . Cliquez sur Compositeur → Créer . Les visualisations des modules et les Toplevel visualisation sont mises à jour et stockées dans le Dispositifs voir. Ouvrez le Toplevel visualisation dans le Dispositifs voir. → " }, 
{ "title" : "Commande : Créer un module à partir de FB ", 
"url" : "ac_create_module_from_fb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Créer un module à partir de FB ", 
"snippet" : "Créer un module à partir de FB Cette commande (Catégorie \"Composer\") crée une description de module à partir d'un bloc fonction. Les objets suivants sont créés : Description du module avec le nom <NameOfTheFB> Pool d'images avec le nom IP_<NameOfTheFB> Liste de texte avec le nom TL_<NameOfTheFB> Int...", 
"body" : "Créer un module à partir de FB Cette commande (Catégorie \"Composer\") crée une description de module à partir d'un bloc fonction. Les objets suivants sont créés : Description du module avec le nom <NameOfTheFB> Pool d'images avec le nom IP_<NameOfTheFB> Liste de texte avec le nom TL_<NameOfTheFB> Interface avec le nom TL_<NameOfTheFB> I<NameOfTheFB>. Cette interface s'étend AC.IModule . La description du module est créée selon les règles suivantes : Toutes variables var_input constant sont définis comme paramètre de module. Là, les attributs parameterCategory , parameterMinValue , et parameterMaxValuehere peut être utilisé pour définir des catégories et des valeurs minimales \/ maximales. Toutes les variables numériques var_output sont définis comme des sorties de module. Toutes les variables numériques var_input sont définies comme des entrées de module, à moins qu'elles ne soient marquées comme faisant partie d'un multi-emplacement. Toutes variables var_input de type Interface deviennent des emplacements uniques, s'ils sont marqués avec le ac_single_slot attribut. Pour créer un multi-slot, une paire de var_input est nécessaire, consistant en un Pointer to Interface et une variable entière. Les deux doivent être marqués avec le 'ac_multi_slot' := '<ID>' attribut, où le <ID> des deux doivent correspondre. " }, 
{ "title" : "Commande : Créer un gestionnaire de persistance ", 
"url" : "ac_create_persistence_manager.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Créer un gestionnaire de persistance ", 
"snippet" : "Créer un gestionnaire de persistance Cette commande (catégorie \"Compositeur\") insère un Gestionnaire de persistance avec les paramètres par défaut dans l'arborescence du module. Sous le gestionnaire de persistance un module Canal de persistance et en dessous un module Stockage de données est inséré....", 
"body" : "Créer un gestionnaire de persistance Cette commande (catégorie \"Compositeur\") insère un Gestionnaire de persistance avec les paramètres par défaut dans l'arborescence du module. Sous le gestionnaire de persistance un module Canal de persistance et en dessous un module Stockage de données est inséré. La structure créée peut ensuite être modifiée et étendue à volonté. Cela se fait dans les paramètres du module canal de persistance et le module stockage de données . Dans l'instance de module de niveau supérieur du Module de gestion de la persistance au moins l'application cible doit être définie. Avant le chargement de l'application sur le contrôleur, la commande produire doit également être exécuté. La commande ajoute en outre toutes les bibliothèques requises au gestionnaire de bibliothèques et active les générateurs associés. " }, 
{ "title" : "Commande : Créer un gestionnaire de journaux de données ", 
"url" : "ac_create_datalog_manager.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Créer un gestionnaire de journaux de données ", 
"snippet" : "Créer un gestionnaire de journaux de données Cette commande (catégorie \"Compositeur\") insère un Gestionnaire de journaux de données avec les paramètres par défaut dans l'arborescence du module. Sous le DataLog Manager un module Canal DataLog et en dessous un module Stockage des journaux de données e...", 
"body" : "Créer un gestionnaire de journaux de données Cette commande (catégorie \"Compositeur\") insère un Gestionnaire de journaux de données avec les paramètres par défaut dans l'arborescence du module. Sous le DataLog Manager un module Canal DataLog et en dessous un module Stockage des journaux de données est inséré. La structure créée peut ensuite être modifiée et étendue à volonté. Cela se fait dans les paramètres du Module 'Canal DataLog' et le Module 'DataLog Stockage CSV' . Dans l'instance de module de niveau supérieur du Module DataLog Manager au moins l'application cible doit être définie. Avant le chargement de l'application sur le contrôleur, la commande produire doit également être exécuté. La commande ajoute en outre toutes les bibliothèques requises au gestionnaire de bibliothèques et active les générateurs associés. " }, 
{ "title" : "Commande : Obtenir les informations de licence ", 
"url" : "ac_cmd_get_license_information.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Commandes de l'éditeur d'applications \/ Commande : Obtenir les informations de licence ", 
"snippet" : "Obtenir des informations sur la licence Avec cette commande (catégorie « Composer »), CODESYS obtient le nombre d'instances de module utilisées dans l'arborescence des modules. Le nombre maximum autorisé d'instances de la licence actuelle est également demandé. Le résultat est affiché dans Messages ...", 
"body" : "Obtenir des informations sur la licence Avec cette commande (catégorie « Composer »), CODESYS obtient le nombre d'instances de module utilisées dans l'arborescence des modules. Le nombre maximum autorisé d'instances de la licence actuelle est également demandé. Le résultat est affiché dans Messages voir. Pour plus d'informations, voir ???" }, 
{ "title" : "Tutoriel ", 
"url" : "f_application_composer_example.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Tutoriel ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Exemples de démarrage ", 
"url" : "f_application_composer_first_steps.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Tutoriel \/ Exemples de démarrage ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Exemple de compositeur d'application ", 
"url" : "ac_example_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Tutoriel \/ Exemples de démarrage \/ Exemple de compositeur d'application ", 
"snippet" : "Basé sur un petit projet, cet exemple décrit comment créer des modules pour Application Composer. Certaines URL de ce didacticiel renvoient vers des pages d'aide faisant partie d'Application Composer. Si vous n'avez pas installé ce package, ces liens ne fonctionneront pas. Le module d'exemple représ...", 
"body" : "Basé sur un petit projet, cet exemple décrit comment créer des modules pour Application Composer. Certaines URL de ce didacticiel renvoient vers des pages d'aide faisant partie d'Application Composer. Si vous n'avez pas installé ce package, ces liens ne fonctionneront pas. Le module d'exemple représente une pièce avec une lumière et un interrupteur. L'interrupteur peut être utilisé comme robinet ou gradateur. Le pousser plus longtemps atténuera la lumière et le pousser brièvement le fera basculer. La vitesse de la fonction variateur ainsi que la valeur maximale de la lumière peuvent être définies par l'utilisateur. Lorsque le commutateur est enfoncé plus longtemps qu'un temps spécifié, la fonction dim est activée. La sortie de la lumière est la luminosité. Il existe une deuxième lumière, plus simple, qui ne peut être allumée et éteinte que par un deuxième interrupteur. Exemple de projet Étape 0 : Préliminaires " }, 
{ "title" : "Étape 0 : Préliminaires ", 
"url" : "ac_example_s0_preliminaries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Tutoriel \/ Exemples de démarrage \/ Étape 0 : Préliminaires ", 
"snippet" : "Tout d'abord, un nouveau projet doit être créé. Choisissez donc Nouveau projet du Fichier menu et enregistrez le nouveau projet. Un gestionnaire de bibliothèque doit être ajouté dans le POU voir. Puis la bibliothèque AC_ModuleBase , qui fait partie du CODESYS Application Composer package, peut être ...", 
"body" : "Tout d'abord, un nouveau projet doit être créé. Choisissez donc Nouveau projet du Fichier menu et enregistrez le nouveau projet. Un gestionnaire de bibliothèque doit être ajouté dans le POU voir. Puis la bibliothèque AC_ModuleBase , qui fait partie du CODESYS Application Composer package, peut être ajouté au gestionnaire de bibliothèque. Ajouter la bibliothèque \"AC_ModulBase\" Étape 1 : Créer le module de niveau supérieur \"Pièce\" " }, 
{ "title" : "Étape 1 : Créer le module de niveau supérieur \"Pièce\" ", 
"url" : "ac_example_s1_create_toplevel_room.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Tutoriel \/ Exemples de démarrage \/ Étape 1 : Créer le module de niveau supérieur \"Pièce\" ", 
"snippet" : "Ajoutez une déclaration de module et un bloc fonctionnel au POU bassin. Le bloc fonction est utilisé pour la mise en œuvre (programme de fonction) du module. Dans cet exemple, le module et le bloc fonctionnel portent le nom Room . De plus, le bloc fonction doit étendre le type de base AC.Module , qu...", 
"body" : "Ajoutez une déclaration de module et un bloc fonctionnel au POU bassin. Le bloc fonction est utilisé pour la mise en œuvre (programme de fonction) du module. Dans cet exemple, le module et le bloc fonctionnel portent le nom Room . De plus, le bloc fonction doit étendre le type de base AC.Module , qui fait partie du AC_ModuleBase bibliothèque et fournit un large éventail de propriétés et de fonctionnalités. Comme nous ne voulons pas modifier ce dernier, toutes les propriétés et fonctions créées avec le bloc fonctionnel peuvent être supprimées. Ajouter un bloc fonctionnel et un module La déclaration commence par le mot clé MODULE suivi du nom du module et IMPLEMENTED_BY et le nom du bloc fonction implémentant le module, qui est, dans le cas présent, le bloc fonction Room. Dans ce cas précis, il s'agit de la Room bloc fonctionnel. Dans la plupart des cas, la section MetaData est déclaré maintenant. Pour des informations détaillées sur tous les paramètres de toutes les sections, consultez les pages d'aide dans Déclaration des modules . Parce que Salle est le module de niveau supérieur dans notre exemple, la prochaine section déclarée est la Toplevel section. Ce dernier permet de définir un nom pour la liste des variables globales ( GVL_name ) incluant les instances des blocs fonctionnels de niveau supérieur après génération. Après cela, au moins une tâche supplémentaire doit être définie dans la section de niveau supérieur. C'est Standard_Task dans cet exemple, qui est défini comme un MEDIUM tâche et contient les drapeaux CREATE_IF_MISSING et UPDATE_IOS . Déclaration de module Room Toutes les icônes et les chaînes, qui sont utilisées pour les espaces réservés de description et d'icône du module (paramètres Desc , Icon_16 et Icon_32 ) doivent être référencés à partir de listes de textes et de pools d'images. Cela dit, une liste de textes appropriée TL et pool d'images IP , qui incluent toutes les icônes et tous les textes référencés, doivent être créés et ajoutés au POU bassin. Création d'une liste de textes et d'un pool d'images Étape 2 : Créer le sous-module \"Switch\" " }, 
{ "title" : "Étape 2 : Créer le sous-module \"Switch\" ", 
"url" : "ac_example_s2_create_sublevel_switch.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Tutoriel \/ Exemples de démarrage \/ Étape 2 : Créer le sous-module \"Switch\" ", 
"snippet" : "L'étape suivante consiste à déclarer un module pour l'interrupteur de la pièce. Encore une fois, une déclaration de module et un bloc fonction doivent être créés. Ici, les deux s'appellent Switch , où la déclaration doit être implémentée par le bloc fonction. La déclaration de module de Switch n'a p...", 
"body" : "L'étape suivante consiste à déclarer un module pour l'interrupteur de la pièce. Encore une fois, une déclaration de module et un bloc fonction doivent être créés. Ici, les deux s'appellent Switch , où la déclaration doit être implémentée par le bloc fonction. La déclaration de module de Switch n'a pas besoin d'une section de niveau supérieur, car elle sera ajoutée sous le module Light (décrit plus loin) dans aucune position de niveau supérieur. Comme il est obligatoire pour tous les modules implémentant des blocs fonction, le bloc fonction Switch doit s'étendre AC.Module , aussi. Dans le cas présent, le bloc fonction implémente également une interface ISwitch , qui doit être créé. Cette interface elle-même doit implémenter l'interface IModule , fourni par la bibliothèque AC_ModuleBase . Cependant, l'interface ISwitch reste \"vide\" - aucune propriété ou fonction n'est déclarée. De plus, le commutateur a besoin d'un signal d'entrée (provenant probablement d'une source externe \/ d'un commutateur physique) pour indiquer quand il est tapé. Ce signal est déclaré dans le OI section utilisant la variable xIn du bloc fonction qui implémente ce module. De plus, un temps de référence est nécessaire pour distinguer les deux fonctions de l'interrupteur : Appui sur l'interrupteur pendant la durée tTimer démarre la fonction de gradation - une pression plus courte ne fait qu'allumer ou éteindre la lumière. Cette variable tTimer (faisant également partie du module implémentant le bloc fonction) sera déclaré comme paramètre du module (section Parameters ), qui peut éventuellement être facilement modifié lors de l'utilisation du module. Déclaration de sous-module Switch Les variables référencées xIn et tTimer sont tous deux définis comme entrées du bloc fonction Switch , où le paramètre tTimer obtient une valeur par défaut initiale de 500 ms. Ainsi, lorsque l'utilisateur appuie sur le Switch plus de 500 ms, la lumière sera atténuée. Déclaration dans le Switch bloc fonction De plus, les listes de textes et le pool d'images doivent être étendus pour inclure les textes de description nécessaires de l'entrée et du paramètre. Entrées dans la liste de textes et le pool d'images Étape 3 : Créer le sous-module \"Switch Simple\" " }, 
{ "title" : "Étape 3 : Créer le sous-module \"Switch Simple\" ", 
"url" : "ac_example_s3_create_sublevel_switchsimple.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Tutoriel \/ Exemples de démarrage \/ Étape 3 : Créer le sous-module \"Switch Simple\" ", 
"snippet" : "Le deuxième module de commutation, que nous voulons déclarer, est un module simplifié avec seulement deux états : allumé et éteint. Par conséquent, une déclaration de module et un bloc fonctionnel doivent être créés, qui sont adaptés du \"Dim-Switch\" ci-dessus. Une nouvelle interface de type ISwitchS...", 
"body" : "Le deuxième module de commutation, que nous voulons déclarer, est un module simplifié avec seulement deux états : allumé et éteint. Par conséquent, une déclaration de module et un bloc fonctionnel doivent être créés, qui sont adaptés du \"Dim-Switch\" ci-dessus. Une nouvelle interface de type ISwitchSimple est utilisé pour le bloc fonction. Une autre différence est que la variable xIn doit être déclaré en tant que variable BOOL et sans paramètre tTimer est nécessaire du tout. Étape 4 : Créez le sous-module \"Lumière\" " }, 
{ "title" : "Étape 4 : Créez le sous-module \"Lumière\" ", 
"url" : "ac_example_s4_create_sublevel_light.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Tutoriel \/ Exemples de démarrage \/ Étape 4 : Créez le sous-module \"Lumière\" ", 
"snippet" : "Comme cela se faisait auparavant pour le Switch et le SwitchSimple , pour le module Light , une déclaration de module Light , un bloc fonction Light et une interface ILight doivent être créés. Le module doit être implémenté par le bloc fonction, qui lui-même doit implémenter l'interface ILight . Pou...", 
"body" : "Comme cela se faisait auparavant pour le Switch et le SwitchSimple , pour le module Light , une déclaration de module Light , un bloc fonction Light et une interface ILight doivent être créés. Le module doit être implémenté par le bloc fonction, qui lui-même doit implémenter l'interface ILight . Pour pouvoir ajouter le Light module ci-dessous notre Room module, la déclaration de module de Room doit être prolongé d'un Slots section. Dans cette section, une sous-section Slot_Multi doit être créé, ce qui s'appelle Lights et pourra contenir des modules du type Light . Le nombre de luminaires pouvant ou devant être ajoutés à une pièce est défini par le paramètre Cardinality (dans ce cas entre 1 et 3 feux). De plus deux variables sont déclarées : Variable ( pLights , qui contiendra les instances de bloc fonction des modules Lumière ajoutés à la pièce) et Var_Count ( uiNumberOfLights , qui sera rempli avec le nombre de modules Lumière ajoutés à la pièce). Définition de la section Slots Les variables pLights et uiNumberOfLights doivent être ajoutés au bloc fonction du module \"Lumières\", où uiNumberOfLights est un UINT et pLights de type POINTER TO ILight Avec cette définition, seuls les modules dont les blocs fonctionnels implémentent également ILight l'interface peut être ajoutée à la Lights fente. Déclaration dans le Room bloc fonction Le même concept de fente qui a été utilisé pour le Room modules est maintenant utilisé pour le Light module. En conséquence, la déclaration de Light comprend une fente avec un Switch , c'est pourquoi ce slot n'est pas un multi-slot, mais un simple slot. Paramètres supplémentaires de la Light module sont la vitesse du gradateur rSpeed et la luminosité maximale uiMaxValue . Enfin, une sortie doit être définie qui représente la luminosité de la lumière associée. Tous les paramètres, emplacements et sorties doivent également être ajoutés en tant que variables au bloc fonctionnel du Light module. Déclaration de module Light Déclaration du bloc fonction Light Liste de textes et pool d'images Etape 5 : Créer le sous-module \"Light simple\" " }, 
{ "title" : "Etape 5 : Créer le sous-module \"Light simple\" ", 
"url" : "ac_example_s5_create_sublevel_lightsimple.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Tutoriel \/ Exemples de démarrage \/ Etape 5 : Créer le sous-module \"Light simple\" ", 
"snippet" : "La lumière simple, qui est créée maintenant, fonctionnera avec un simple interrupteur, mais peut être adaptée à partir de Light dessus, en tout cas. Par conséquent, une nouvelle déclaration de module et un bloc fonctionnel LightSimple doivent être créés. Étant donné que le bloc fonction implémente s...", 
"body" : "La lumière simple, qui est créée maintenant, fonctionnera avec un simple interrupteur, mais peut être adaptée à partir de Light dessus, en tout cas. Par conséquent, une nouvelle déclaration de module et un bloc fonctionnel LightSimple doivent être créés. Étant donné que le bloc fonction implémente simplement l'interface ILight , il sera possible d'ajouter ultérieurement des luminaires de différents types dans une pièce. La principale différence avec Light c'est-à-dire que la variable du slot doit être du type ISwitchSimple afin d'éviter qu'un mauvais interrupteur ne soit placé sous un LightSimple module. De plus la sortie de LightSimple sera de type BOOL et est nommé xSwitchedOn . Étape 6 : Mise en œuvre " }, 
{ "title" : "Étape 6 : Mise en œuvre ", 
"url" : "ac_example_s6_implementation.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Tutoriel \/ Exemples de démarrage \/ Étape 6 : Mise en œuvre ", 
"snippet" : "Commutateurs Pour la mise en œuvre des fonctionnalités du module Switch nous utilisons la méthode CallPrioMediumStart à partir de Module en le remplaçant par notre propre implémentation. Nous choisissons cette fonction, car le module Room a déclaré un MEDIUM tâche, ce qui implique que la méthode Cal...", 
"body" : "Commutateurs Pour la mise en œuvre des fonctionnalités du module Switch nous utilisons la méthode CallPrioMediumStart à partir de Module en le remplaçant par notre propre implémentation. Nous choisissons cette fonction, car le module Room a déclaré un MEDIUM tâche, ce qui implique que la méthode CallPrioMediumStart du bloc fonction Switch sera appelée à chaque cycle d'une tâche moyenne. Les informations détaillées peuvent être consultées dans l'exemple de projet lui-même. Cependant, la fonctionnalité principale du commutateur est de différer entre la fonction tap et la fonction dim. Après avoir appuyé sur le commutateur, une minuterie démarre avec le temps donné par le paramètre utilisateur. Lorsque la minuterie est terminée et que l'interrupteur n'est pas relâché, la fonction dim est utilisée, indiquée par la variable xPushLong . La variable xPush est TRUE , si le commutateur est juste tapé. Pour les deux xPushLong et xPush les propriétés sont ajoutées à la fois au bloc fonction Switch et l'interface ISwitch , afin qu'ils puissent être utilisés à partir du bloc de fonction d'éclairage parent. Léger Encore une fois, le Light le bloc fonction remplace la méthode CallPrioMediumStart . Selon les variables d'entrée de l'interrupteur sous-jacent, la lumière est atténuée sur \"on\" ou \"off\" ou seulement basculée. Pour le variateur, la valeur de vitesse du paramètre déclaré rSpeed est utilisé. Après avoir atteint la valeur de variation maximale ou minimale, la variation est arrêtée. Si la lumière est dans un état atténué et que l'interrupteur est enfoncé, la lumière est allumée. (L'implémentation détaillée est donnée dans l'exemple de projet correspondant.) Vérifiez le code Après la mise en œuvre, les déclarations doivent être vérifiées à l'aide de la commande Construire . Si aucune erreur ne s'affiche, les déclarations sont correctes. Étape 7 : Composer des modules " }, 
{ "title" : "Étape 7 : Composer des modules ", 
"url" : "ac_example_s7_composing_modules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Tutoriel \/ Exemples de démarrage \/ Étape 7 : Composer des modules ", 
"snippet" : "Après avoir scanné avec succès les déclarations, tous les modules sont disponibles pour une utilisation ultérieure, de sorte qu'un exemple d'application peut être composé. Par conséquent, les modules sont ajoutés à l'arborescence des modules du projet. Pour cela la vue Modules doit être ouvert. Dans...", 
"body" : "Après avoir scanné avec succès les déclarations, tous les modules sont disponibles pour une utilisation ultérieure, de sorte qu'un exemple d'application peut être composé. Par conséquent, les modules sont ajoutés à l'arborescence des modules du projet. Pour cela la vue Modules doit être ouvert. Dans la première étape, le module de niveau supérieur Room doit être ajouté à l'arbre. Ajouter un module de niveau supérieur à l'arborescence des modules le Boîte de dialogue des modules s'ouvre et propose tous les modules de niveau supérieur disponibles. Dans cette boîte de dialogue s'affichent les icônes correspondantes qui ont été définies dans le pool d'images, ainsi que les textes des listes de textes. Maintenant, le module \"Pièce\" peut être sélectionné et ajouté à l'arborescence des modules. Boîte de dialogue : \"Ajouter un module\" Maintenant, l'éditeur du module de niveau supérieur peut être ouvert en double-cliquant Room dans l'arborescence des modules. Une application cible pour la génération de code doit être sélectionnée sur le Toplevel languette. Les tâches qui ont été déclarées dans la déclaration du module sont affichées dans le champ Tâches standards . Paramètres du module \"Pièce\" Analogue aux étapes au-dessus du sous-module Light peuvent être ajoutés à l'arborescence des modules. En raison de la définition de plusieurs emplacements dans la déclaration de la pièce, jusqu'à trois lumières peuvent être ajoutées. Les valeurs pour maxLightValue et Speed peut être paramétré sur le Parameters onglet de l'éditeur du Light module. Dans l'éditeur d'E\/S, la sortie Brightness est mappé à une variable locale uiBrightness pour notre exemple. Paramètres du module \"Lumière\" Ci-dessous le nouveau Light , un module Switch il faut ajouter. Dans l'éditeur d'instance de Switch module, tous les paramètres et E\/S définis dans la déclaration du module sont disponibles. Pour notre exemple la variable locale xPushSwitch est mappé à la variable d'entrée xIn . La sortie de la lumière simple est mappée à la variable locale xSimpleOn . Paramètres du module \"Switch\" Dans une dernière étape de notre exemple, un LightSimple avec un SwitchSimple sont ajoutés à l'arborescence du module. La sortie de la lumière simple est mappée à la variable locale xSimpleOn . L'entrée de l'interrupteur simple xPushSimpleSwitch est mappé à la variable xPushSimpleSwitch. Exemple d'arborescence du module de composition A la fin, le projet doit être généré à l'aide de la commande produire . Après le téléchargement sur un appareil, l'exemple peut être testé en modifiant la valeur de xPushSwitch . Pour faire varier la valeur de uiLuminosité doit augmenter lentement et en tapotant, sa valeur est directement réglée sur 0 ou au maximum. En changeant xPushSimpleSwitch commute directement la sortie de la lumière correspondante. Enfin, il faut mentionner que les dernières étapes de composition des modules peuvent être effectuées dans n'importe quelle combinaison, sans perdre la fonctionnalité du code généré. " }, 
{ "title" : "Bibliothèque : Mécatronique ", 
"url" : "ac_mechatronics_example.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de modules \/ Tutoriel \/ Bibliothèque : Mécatronique ", 
"snippet" : "le Mechatronics bibliothèque est censée être un exemple d'implémentation simple (et non complète) d'une unité mécatronique à exécution séquentielle. Il ne répond pas à toutes les exigences qu'une application mécatronique complète pourrait avoir. Il est plutôt destiné à être un point d'entrée ou une ...", 
"body" : "le Mechatronics bibliothèque est censée être un exemple d'implémentation simple (et non complète) d'une unité mécatronique à exécution séquentielle. Il ne répond pas à toutes les exigences qu'une application mécatronique complète pourrait avoir. Il est plutôt destiné à être un point d'entrée ou une base pour une application de ce type. Le noyau essentiel du modèle mécatronique proposé repose sur la structure de module suivante : Exemple de compositeur d'applications Mechatronics Ainsi toute machine est supposée posséder éventuellement plusieurs sous-ensembles mécatroniques (exemple : chacun représentant un préhenseur). Une telle sous-unité se décompose à nouveau en ses actionneurs (équivalant à l'unité mécanique elle-même, également sa mise en œuvre fonctionnelle ou la gestion des entrées\/sorties) et un gestionnaire de programme. Le gestionnaire de programme est destiné à gérer les différents états d'un sous-ensemble mécatronique, par exemple son Idle ou Execute Etat. Finalement, ces états sont représentés par des séquences de programme contrôlant les actionneurs ou tout autre élément nécessaire à une exécution correcte. À ce stade, les différentes parties seront brièvement décrites en détail. Lors de l'utilisation de la bibliothèque, dans de nombreux cas, il sera nécessaire d'implémenter vos propres actionneurs, étapes de flux ou séquences de programme, qui seront également expliqués ici. Actionneurs : Tous les modules qui doivent être des actionneurs doivent être implémentés par un bloc fonction qui implémente à son tour IActuator interface. Cette interface n'a pas de méthodes ou de propriétés et n'est utilisée que pour la compatibilité des modules (voir le IActuator documentation à la bibliothèque). Il n'y a pas de restrictions ou de règles données pour les implémentations d'actionneurs, de sorte que le mouvement ou l'activation d'un tel actionneur doit être effectué séparément. Normalement, cela se fait en mettant en œuvre un module d'étape de séquence, qui peut maintenir les actionneurs appropriés dans une fente de référence et ainsi déplacer ces derniers de la manière souhaitée (par exemple en utilisant des interfaces supplémentaires). Étapes de la séquence Il est fortement recommandé d'exécuter l'implémentation des étapes de flux en tant que classes dérivées du StepBase bloc fonctionnel. Cela fournit toutes les implémentations de base nécessaires du IProgramSequenceStep interface. Voir le IActuator documentation à la bibliothèque. Lors de l'utilisation de la classe de base StepBase , il suffit alors d'implémenter Execute méthode. Ce dernier est alors appelé cycliquement par le déroulement du programme jusqu'à ce que la variable xDone de la classe de base est défini sur TRUE . De plus, pour un bon fonctionnement, le drapeau xActive doit être réglé sur TRUE tant que l'étape est active. Cependant, la connexion aux actionneurs peut se faire de n'importe quelle manière, par exemple par les fentes de référence proposées (voir 1.). Séquence de programme et responsable de programme Une séquence de programme est un sous-module d'un gestionnaire de programme, qui représente un état. Ces états sont gérés sous la forme d'une machine à états OMAC. Ses implémentations reposent à nouveau sur une méthode \"Execute\" (pour plus de détails, voir l'implémentation dans la bibliothèque). Cependant, la mise en oeuvre d'un tel déroulement de programme par l'utilisateur n'est pas nécessaire dans la plupart des cas. Cependant, la manière dont le comportement de la machine d'état est mis en œuvre dans le gestionnaire de programme et exécute ainsi les séquences de programme doit être brièvement décrite ici : Il existe deux types d'états : les états actifs (se terminant par \"ing\") et les états d'attente\/duels (le reste). Les états d'attente sont terminés par des commandes externes, tandis que les états actifs sont automatiquement exécutés et terminés. Les commandes disponibles dépendent de l'état dans lequel se trouve actuellement le gestionnaire de programme. Un bref aperçu est donné dans le diagramme d'état OMAC : Diagramme OMAC Module: MovableBarrier Le module MovableBarrier est mis en œuvre de la manière suivante : Le bloc fonction correspondant MovableBarrier implémente l'interface créée IMovableBarrier . Cette dernière interface définit les méthodes de déplacement d'une barrière, alors que IMovableBarrier implémente lui-même l'interface IActuator , de sorte que le module MovableBarrier est insérable comme actionneur dans l'arborescence des modules sous une unité mécatronique : Implémentation du module MovableBarrier Cependant, cet actionneur \"MovableBarrier\" est déplacé par le module d'étape de séquence MoveBarrierForTime , qui est lui-même implémenté de la manière suivante : Implémentation du module MoveBarrierForTime Le module implémentant le bloc fonctionnel MoveBarrierForTime dérive simplement du bloc fonctionnel de base contenu dans la bibliothèque AC_MEC.StepBase . Par là, le bloc fonctionnel MoveBarrierForTime implémente déjà l'interface IProgramSequenceStep . Par conséquent le module MoveBarrierForTime est insérable comme pas de séquence sous une séquence de programme. La mise en œuvre fonctionnelle du bloc fonction MoveBarrierForTime est la suivante : en définissant un emplacement de référence pour le module MoveBarrierForTime , pouvant recevoir un actionneur mettant en oeuvre l'interface IMovableBarrier , on obtient une connexion à un actionneur \"MovableBarrier\" existant. Le mouvement de cet actionneur se fait finalement dans le Execute fonction de la MoveBarrierForTime bloc fonction, qui appelle simplement la méthode de déplacement (pictural) du capot de protection. Cette méthode est fournie par l'actionneur référencé, qui met en œuvre IMovableBarrier . De plus la propriété Done et la variable xActive sont couplés à un TON, de sorte que les appels répétés aux fonctions de déplacement de IMovableBarrier sont effectués jusqu'à ce qu'un certain temps (TON) se soit écoulé, après quoi Done est défini sur TRUE et xActive à FAUX. La propriété Done fait partie de l'interface IProgramSequenceStep et indique ainsi à la séquence de programme supérieure que l'étape suivante de la séquence doit être exécutée. En dehors de votre propre implémentation des étapes de séquence, le AC_Mechatronics.library fournit également des étapes pré-implémentées, qui peuvent être utilisées pour des opérations logiques générales. Cela signifie par exemple une étape BranchOnBool est fourni, qui comporte deux sous-séquences \/ branches d'étapes, qui sont exécutées en fonction de la valeur d'une variable BOOL. Ces sous-étapes sont exécutées en fonction de la valeur d'une variable booléenne. Par ailleurs, la bibliothèque AC_Mechatronics.library contient des étapes de flux pour les flux parallèles, des sauts conditionnels ou des étapes d'attente simples et bien d'autres tâches. " }, 
{ "title" : "Éditeur de déclaration de module ", 
"url" : "ac_module_declaration_editor_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module ", 
"snippet" : "Un module représente généralement un composant mécatronique mais peut également être une fonction purement logicielle. Il contient tous les aspects techniques couverts par CODESYS . Un module a un bloc fonctionnel qui implémente l'interface IModule de la bibliothèque AC_ModuleBase . Il contient égal...", 
"body" : "Un module représente généralement un composant mécatronique mais peut également être une fonction purement logicielle. Il contient tous les aspects techniques couverts par CODESYS . Un module a un bloc fonctionnel qui implémente l'interface IModule de la bibliothèque AC_ModuleBase . Il contient également des informations sur les sous-modules, le paramétrage, la demande d'E\/S, l'affectation des tâches et les visualisations. Les modules constituent le concept central de la CODESYS Application Composer . le CODESYS Application Composer fournit également un modèle de projet, qui peut être sélectionné dans le Nouveau projet dialogue. Ce modèle crée un projet avec un appareil, une application et un gestionnaire de bibliothèque dans le pool de POU. Ce dernier contient les librairies AC_ModuleBase et AC_Persistence . Le modèle, qui est basé sur le projet ComposerProject.project , peut être modifié si nécessaire. Il est stocké dans le sous-dossier \"Modèles\" du CODESYS répertoire d'installation. Un module peut être créé automatiquement à partir d'un bloc fonction existant. Ainsi, dans la mesure du possible, les déclarations existantes sont transférées dans la déclaration du module. Pour plus de détails, voir la description du Créer un module à partir de FB commander. Voir Déclaration des modules pour des informations détaillées sur la façon de développer des modules. Pour plus d'informations sur l'échange de données entre différentes applications, voir Service IRMP . " }, 
{ "title" : "Déclaration du module ", 
"url" : "ac_module_declaration.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module ", 
"snippet" : "La déclaration des modules se fait avec un langage de description propre qui est similaire à la déclaration des variables en code texte structuré (ST). Sections de la déclaration du module Section : Métadonnées Section : Niveau supérieur Rubrique : IO Rubrique : Paramètres Rubrique : Machines à sous...", 
"body" : "La déclaration des modules se fait avec un langage de description propre qui est similaire à la déclaration des variables en code texte structuré (ST). Sections de la déclaration du module Section : Métadonnées Section : Niveau supérieur Rubrique : IO Rubrique : Paramètres Rubrique : Machines à sous Rubrique : Visu Rubrique : Procurations Section : VarArrays Rubrique : Contraintes Section : InstRefs Section : mse.Séquence Générateur d'appareilsalg.Alarme" }, 
{ "title" : "Format de la déclaration du module ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_48fab9ed86f6686ac0a8640e00dcb86d", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Format de la déclaration du module ", 
"snippet" : "Un en-tête du formulaire MODULE<name> commence la déclaration. Ceci est suivi d'une liste de \"sections\". Chaque section est introduite par le mot-clé SEC (pour \"section\") et un nom unique. Le mot clé END_SEC ferme la section. Le contenu d'une section contient une liste d'entrées composée d'autres se...", 
"body" : "Un en-tête du formulaire MODULE<name> commence la déclaration. Ceci est suivi d'une liste de \"sections\". Chaque section est introduite par le mot-clé SEC (pour \"section\") et un nom unique. Le mot clé END_SEC ferme la section. Le contenu d'une section contient une liste d'entrées composée d'autres sections ou de définitions. Une définition se compose d'un nom et d'une valeur facultative et se termine par un point-virgule. Les commentaires peuvent être utilisés comme dans le code ST : \"\/\/\"\" pour un commentaire sur une seule ligne et \"(*\" et \"*)\" pour les commentaires multilignes. Les espaces (tabulations et espaces) et les nouvelles lignes\/sauts de ligne peuvent être utilisés pour séparer les parties. d'une déclaration, sinon ils seront ignorés lors du traitement ultérieur. Comme pour le code ST, le respect de la casse ne fait aucune différence. L'exemple suivant explique les éléments d'une déclaration de module 01 MODULE Persistence IMPLEMENTED_BY PersistenceFB\n02 SEC MetaData\n03 NAME := TL.ChannelName ;\n04 DESC := TL.ChannelDesc ;\n05 COLLECTION CATEGORY := ’Persistence’TL.Collection ;\n06 ICON_16 := IP.Channel16 ;\n07 ICON_32 := IP.Channel32 ;\n08 END_SEC\n09 SEC Toplevel\n10 SEC STANDARD_TASK : LOW\n11 NAME := LOW ;\n12 DESC := TL.TaskLow ;\n13 FLAGS := CREATE_IF_MISSING | READONLY ;\n14 END_SEC\n15 GVL_NAME := 'GVL_%InstanceName%' ;\n16 END_SEC A la ligne 01 se trouve la définition du nom du module \"Persistance\". IMPLEMENTED_BY définit le bloc fonction \"PersitenceFB\" qui contient la logique du module. Ce bloc fonction doit dériver de IModule . À la ligne 02, la section MetaData commence et se termine par la ligne 08. Cette section contient cinq définitions. La possibilité de sections imbriquées est indiquée dans la section Toplevel (lignes 09 à 16) qui contient la sous-section STANDARD_TASK (ligne 10). " }, 
{ "title" : "Syntaxe de la déclaration du module ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_819a1c8e627d0b32c0a8640e01623943", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Syntaxe de la déclaration du module ", 
"snippet" : "Dans cette section, la syntaxe et la structure syntaxique autorisée d'une déclaration de module seront expliquées. Dans le scanner suivant, les jetons seront écrits en majuscules (exemple : ID ). Les non-terminaux de la grammaire seront écrits entre accolades (exemple : {Entry} ). Analyse lexicale (...", 
"body" : "Dans cette section, la syntaxe et la structure syntaxique autorisée d'une déclaration de module seront expliquées. Dans le scanner suivant, les jetons seront écrits en majuscules (exemple : ID ). Les non-terminaux de la grammaire seront écrits entre accolades (exemple : {Entry} ). Analyse lexicale (scanner) Dans un premier temps, des jetons (ou lexèmes) seront créés à partir des caractères de la déclaration du module (exemple : mots-clés, constantes, identifiants). Les espaces ainsi que les caractères de nouvelle ligne\/saut de ligne séparent les jetons, mais seront ignorés autrement. Les commentaires seront également ignorés pour le traitement ultérieur de la déclaration. (Les commentaires peuvent être rédigés sur une seule ligne ( \/\/ \") ou des commentaires multilignes ( (* et *) ) comme dans le langage ST. Les commentaires multilignes peuvent être imbriqués. Fondamentalement, un jeton a toujours une longueur maximale. Par exemple a123 sera interprété comme un identifiant et non comme un identifiant a suivi d'un littéral 123 . L'ordre des jetons dans la liste ci-dessous indique leur priorité. Par exemple l'entrée MODULE sera compris comme mot clé et non comme identifiant. Liste de tous les jetons disponibles : Mots clés: MODULE , SEC , END_SEC , IMPORTS , et IMPLEMENTED_BY OP : une séquence non vide des caractères suivants : .:,%()[]{}<>|+-*\/@!?^°=\\~ Remarque : Les marqueurs de commentaire \/\/ , (* , et *) ont une priorité plus élevée que les opérateurs. Il ne peut y avoir aucun commentaire à l'intérieur d'un opérateur aucun commentaire ne peut être, exemple : +\/\/+ sera, selon la règle de longueur maximale, interprété comme un opérateur et non comme + suivi d'un commentaire. LIT : Un littéral CEI, tel qu'il est utilisé dans ST, exemple : 1.4 , tod#12:13:14 . Cela inclut les littéraux booléens TRUE et FALSE (les majuscules ou les minuscules ne sont pas pertinentes). Remarque : les littéraux non typés avec un signe négatif ( -1 , -3.2 ) sera lu comme deux jetons, c'est-à-dire comme opérateur - suivi d'un littéral non typé. Les littéraux numériques non typés qui en résultent ne peuvent jamais être négatifs. Littéraux typés ( INT#-34 ) sera toujours interprété comme un jeton. ID : un identifiant CEI valide ( [a-zA-Z_][a-zA-Z0-9_]* ), dans lequel deux soulignements consécutifs ne sont pas autorisés. Cela inclut, contrairement à ST, également les mots-clés de ST (c'est-à-dire : FUNCTION , INT , EXTENDS , …) Point-virgule : le personnage ; Syntaxe (analyseur) La syntaxe de la déclaration du module est définie par la grammaire suivante. µ est une séquence vide. {MDecl} ::= MODULE {QID} {ImplSpec} {ImportsSpec} {MBody}\n{ImplSpec} ::= IMPLEMENTED_BY {QID} | µ\n{ImportsSpec} ::= IMPORTS {QID} | µ\n{MBody} ::= {SecList}\n{SecList} ::= {Modifiers} {Sec} {SecList} | µ\n{Sec} ::= SEC {QID} {SecTarget} {EntryList} END_SEC\n{SecTarget} ::= OP(\":\") {QID} | µ\n{Modifiers} ::= OP(\"[\") {ModifierList} OP(\"]\") | µ\n{ModifierList} ::= {QID} OP(\",\") {ModifierList} | {QID}\n{EntryList} ::= {Modifiers} {Entry} {EntryList}\n{Entry} ::= {Sec} | {Def}\n{Def} ::= {QID} OP(\":=\") {ValList} SEMICOLON |\n {QID} SEMICOLON\n{ValList} ::= {Val} {ValList} | {Val}\n{Val} ::= ID | LIT | OP\n{QID} ::= ID | ID OP(\".\") {QID} La liste des valeurs de définition ( {ValList} ) doit être complété par un point-virgule. Cela simplifie la grammaire et évite les ambiguïtés, car le point-virgule ne peut pas faire partie d'une valeur ( {VAL} ), sauf dans un littéral de chaîne. L'opérateur d'affectation ( := ) des définitions ( {Def} ) sert également à éviter les ambiguïtés ( {QID} ) des noms et valeurs de définition. Types définis pour les définitions Texte : ID.ID (nom de la liste de textes et identifiant de la liste de textes) - voir Localisation des chaînes de liste de textes Image : ID.ID (nom du pool d'images et identifiant du pool d'images) ID (identifiant CEI) QID (Identifiant Qualifié) : {QID} ::= ID | ID.ID CategoryPath ::= {StringLiteral} | {CategoryPath} Cardinalité : [{MIN} .. {MAX}] | [ {MIN} .. INF [ {MIN} , et {MAX} sont des littéraux entiers non négatifs. Si {MAX} != INF , alors {MIN} <= {MAX} doit postuler. StringLiteral : un littéral de chaîne CEI peut contenir des sauts de ligne. StdTaskFlags ::= {StdTaskFlag} | {StdTaskFlags} StdTaskFlag ::= NONE | CREATE_IF_MISSING | READONLY Littéral : tout littéral CEI ou QID (pour les constantes Enum) DTBoolFlag : µ (séquence vide) | TRUE | FALSE Type d'emplacement : SUBMODULE | REFERENCE Pragmes : [ {PragmaList} ] {PragmaList} ::= {Pragma} | {Pragma} , {PragmaList} {Pragma} ::= { ( ID | {StringLiteral} | {OP2} )+ } {OP2} : tous les opérateurs sauf {, }, [, ] et , . Chemin d'instance : InstancePath ::= {IComp} | {IComp} . {IComp} avec {IComp} ::= ID {ArrayAccess}* et {ArrayAccess} ::= [ {IntList} ] et {IntList} ::= Int | Int , {IntList} TaskRef : Standard_Task. ( Low | Medium | High ) | Custom_Task.ID " }, 
{ "title" : "Chemins d'instance ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_e00dd4f26a1882aec0a8652000c0a4ae", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Chemins d'instance ", 
"snippet" : "À certaines positions dans la déclaration du module, des chemins d'instance peuvent être définis pour adresser une variable d'un bloc fonctionnel : pour les paramètres, les emplacements, les E\/S, les tableaux avec une taille variable et les références d'instance. Un chemin d'instance est défini comm...", 
"body" : "À certaines positions dans la déclaration du module, des chemins d'instance peuvent être définis pour adresser une variable d'un bloc fonctionnel : pour les paramètres, les emplacements, les E\/S, les tableaux avec une taille variable et les références d'instance. Un chemin d'instance est défini comme une séquence non vide de composants, séparés par des points : C1.C2…CN . Un composant doit être soit un identifiant CEI, soit un composant suivi d'une expression d'index [i1, …, iN] , où i1 à iN sont des valeurs entières. Les chemins d'instance sont toujours relatifs au bloc fonctionnel qui implémente la logique du module. Le premier composant du chemin d'instance est un membre ( VAR_INPUT ou VAR_OUTPUT , selon le cas d'utilisation) du bloc fonction. Dans le cas de composants supplémentaires dans le chemin de l'instance, ces composants adressent la variable au sein du membre. Sinon, c'est le membre lui-même qui est adressé. Les chemins d'instance peuvent être limités aux variables d'entrée ou de sortie (exemple : pour les E\/S). Pour les structures, ces restrictions ne sont pas valables. Ces types de chemins d'instance sont appelés chemins d'instance d'entrée, respectivement. chemins d’instance de sortie. " }, 
{ "title" : "Localisation des chaînes de liste de textes ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_497561d55e22d540c0a8640e01561e3c", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Localisation des chaînes de liste de textes ", 
"snippet" : "Les textes des modules (exemple : description du module, nom, description du paramètre) peuvent être affichés dans différentes langues. Ces textes sont gérés dans des listes de textes. Spécification du nom de la langue : Le nom de la langue est de format <LanguageCode>[-<Country\/Region>] (exemple: e...", 
"body" : "Les textes des modules (exemple : description du module, nom, description du paramètre) peuvent être affichés dans différentes langues. Ces textes sont gérés dans des listes de textes. Spécification du nom de la langue : Le nom de la langue est de format <LanguageCode>[-<Country\/Region>] (exemple: en-US , de-DE ). <LanguageCode> est le nom de la langue selon la norme ISO 639-1 (exemple : de ou en ). <Country\/Region> est un code de pays selon la norme ISO 3166. Lors de la récupération d'une entrée de liste de textes, le système recherche d'abord le nom complet de la langue. Si rien n'est trouvé, il recherche le <LanguageCode> . Si cette recherche échoue également, le texte par défaut sera utilisé. Exemples de noms de langues dans les listes de textes Langue Nom de la langue Chinois zh-CHS Anglais fr-US Français F RFR Allemand de-DE italien ça ça Japonais ja-JP Portugais pt-PT russe ru-RU Espagnol es-ES " }, 
{ "title" : "Dérivation des déclarations de module ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_a596cccf5e22d542c0a8640e019ddff8", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Dérivation des déclarations de module ", 
"snippet" : "De manière analogue à l'héritage orienté objet d'un bloc fonctionnel A à partir d'un bloc fonctionnel B (\"EXTENDS\"), il existe la possibilité de dériver des déclarations de module en utilisant l'attribut IMPORTS mot-clé. Les modificateurs UPDATE et HIDE sont traités spécialement. Les règles suivante...", 
"body" : "De manière analogue à l'héritage orienté objet d'un bloc fonctionnel A à partir d'un bloc fonctionnel B (\"EXTENDS\"), il existe la possibilité de dériver des déclarations de module en utilisant l'attribut IMPORTS mot-clé. Les modificateurs UPDATE et HIDE sont traités spécialement. Les règles suivantes sont utilisées : Le nom du module importé doit être spécifié avec un espace de noms si ce module est défini dans une autre bibliothèque. Les importations cycliques ne sont pas autorisées, en particulier un module ne doit pas s'importer lui-même. (Exemple d'import cyclique : le module M_1 importe le module M_2, M_2 importe M_3, …, M_N importe à nouveau M_1.) Un module dérivé peut être défini sans le IMPLEMENTED_BY directif. Dans ce cas, le bloc fonction du module de base sera utilisé. Si un module dérivé spécifie un bloc fonction (en utilisant MPLEMENTED_BY ), ce bloc fonction doit dériver du bloc fonction du module de base ou doit lui être identique. Un module dérivé hérite de toutes les sections du module de base. Il peut ajouter de nouvelles sections ou modifier des sections existantes. Une section peut être modifiée dans le module dérivé en utilisant le même nom et la même cible étendue avec le modificateur UPDATE . Dans ce cas, ses entrées sont modifiées. Toutes les définitions manquantes de la section dans le module dérivé seront reprises du module de base. Le modificateur UPDATE et HIDE ne peut être utilisé que si la section correspondante (nom et cible) est définie dans le module de base. A l'inverse, une section définie dans le module de base ne peut être utilisée dans le module dérivé que si elle possède l'attribut HIDE ou UPDATE modificateur. S'il n'y a que le HIDE modificateur dans la section et non UPDATE , alors aucune définition n'est autorisée. Certaines entrées doivent être modifiées dans le module dérivé (exemple : la description). Exemple: MODULE MBase IMPLEMENTED_BY FBBase\nSEC MetaData\n DESC := TL.Desc_Base ;\nEND_SEC\nSEC Parameters\n SEC Param : paramxIn\n Variable := xIn ;\n Name := TL.Param1_Name ;\n Desc := TL.Param1_Desc ;\n END_SEC\nEND_SEC\n\nMODULE MDerived IMPORTS MBase\n[UPDATE] SEC MetaData\n DESC := TL.Desc_Derived ;\nEND_SEC\n[UPDATE] SEC Parameters\n [UPDATE,HIDE] SEC Param : paramIn\n Variable := xIn ;\n DEFAULT := TRUE ;\n END_SEC\nEND_SEC Dans l'exemple ci-dessus, le paramètre paramIn du module MBase est caché dans le module dérivé MDerived (en utilisant le HIDE modificateur), et en même temps une nouvelle valeur par défaut ( TRUE ) est défini. " }, 
{ "title" : "Notes sur l'ordre des sections et des définitions ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_87237560fda311e1967bf6fe1c17b04f", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Notes sur l'ordre des sections et des définitions ", 
"snippet" : "L'ordre des sections directement après l'en-tête du module n'a pas d'importance. Au sein des sections, l’ordre peut être très important. Par exemple, l'ordre des déclarations de slot définit l'ordre des modules dans l'arborescence des modules. L’ordre des définitions n’a toujours pas d’importance. R...", 
"body" : "L'ordre des sections directement après l'en-tête du module n'a pas d'importance. Au sein des sections, l’ordre peut être très important. Par exemple, l'ordre des déclarations de slot définit l'ordre des modules dans l'arborescence des modules. L’ordre des définitions n’a toujours pas d’importance. Règles pour les modules dérivés relatifs à la commande : Les sections des modules de base sont toujours définies avant les sections du module lui-même. Si une section du module de base est modifiée à l'aide de UPDATE ou HIDE , son ordre n'est pas affecté. Il n'est pas possible pour un module dérivé de modifier l'ordre tel que défini dans le module de base. " }, 
{ "title" : "Auto-complétion et « liste des composants » ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_23e0e10e3a0c71c9c0a8640e0040f55b", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Auto-complétion et « liste des composants » ", 
"snippet" : "Lorsque vous commencez à taper dans l'éditeur de module, toutes les définitions de section disponibles\/possibles sont affichées dans un menu \"liste des composants\". Seules les sections et définitions significatives pour la position actuelle sont affichées. Même si certaines entrées de sous-section p...", 
"body" : "Lorsque vous commencez à taper dans l'éditeur de module, toutes les définitions de section disponibles\/possibles sont affichées dans un menu \"liste des composants\". Seules les sections et définitions significatives pour la position actuelle sont affichées. Même si certaines entrées de sous-section portent le même nom que les entrées de sous-section d'autres sections, il tentera d'afficher uniquement les définitions de section correspondantes. Si Retour est enfoncé après avoir terminé la première ligne d'une section, la section sera alors complétée avec toutes les définitions\/sections nécessaires et le END_SEC . Après les définitions des variables, les variables d'entrée\/sortie sont présentées par des définitions de « composants de liste ». Les indicateurs ou valeurs prédéfinies sont également présentés dans une sélection de « composants de liste », qui montre les indicateurs\/valeurs possibles. Après les définitions, qui utilisent des entrées de liste de texte ou des entrées de pool d'images (exemple : la plupart du temps Desc := ), un menu « composants de liste » comprenant toutes les listes de textes ou pools d'images disponibles et visibles et leurs entrées est présenté. En appuyant F2 , le support de saisie correspondant peut être ouvert. " }, 
{ "title" : "Initialisation des instances de modules (changement en ligne) ", 
"url" : "ac_initialization_of_module_instances.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Initialisation des instances de modules (changement en ligne) ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Initialisation et réinitialisation des instances de module et des instances proxy (changement en ligne) ", 
"url" : "ac_initialization_of_module_instances.html#UUID-d33dd918-6f7b-5e75-6686-b9d605273b58_index_2", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Initialisation des instances de modules (changement en ligne) \/ Initialisation et réinitialisation des instances de module et des instances proxy (changement en ligne) ", 
"snippet" : "La méthode IBaseInstance.Init(bOnlineChange : BOOL) ) est appelé après un téléchargement ou une modification en ligne pour toutes les instances de module de niveau supérieur et pour toutes les instances de proxy. Les modules sont chargés d'appeler toutes les instances de modules gérés, si nécessaire...", 
"body" : "La méthode IBaseInstance.Init(bOnlineChange : BOOL) ) est appelé après un téléchargement ou une modification en ligne pour toutes les instances de module de niveau supérieur et pour toutes les instances de proxy. Les modules sont chargés d'appeler toutes les instances de modules gérés, si nécessaire. Init est appelé dès que toutes les valeurs des paramètres, les instances de module gérées et référencées sont définies et que les instances de module ont été montées dans l'arborescence des modules, mais avant que les tâches ne soient démarrées ou poursuivies. L'implémentation standard en bloc fonctionnel Module appelle tous les sous-modules. Les méthodes IBaseInstance.OnBeforeOnlineChange et IBaseInstance.OnAfterOnlineChange sont appelés avant et après que la structure de l'arborescence des modules a été recréée et que les valeurs des paramètres ont été modifiées. De plus, les méthodes sont appelées avant et après que tous les sous-modules et modules référencés aient été réaffectés, mais avant que les tâches ne soient (re)démarrées. Contrairement à FB_Init , cette méthode est appelée à chaque changement en ligne, que ce soit FB_Exit a déjà été appelé sur l'ancienne instance. " }, 
{ "title" : "Section : Métadonnées ", 
"url" : "ac_module_fb_sec_metadata.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Section : Métadonnées ", 
"snippet" : "Métadonnées La section MetaData contient la description, la catégorie et les icônes (de taille 16x16 pixels et 32x32 pixels). SEC MetaData \/\/optional: yes, modifier: [UPDATE]] Desc := <description>; \/\/optional: no, type: text Category := <category name>; \/\/optional: no, type: CategoryPath Icon_16 :=...", 
"body" : "Métadonnées La section MetaData contient la description, la catégorie et les icônes (de taille 16x16 pixels et 32x32 pixels). SEC MetaData \/\/optional: yes, modifier: [UPDATE]]\n Desc := <description>; \/\/optional: no, type: text\n Category := <category name>; \/\/optional: no, type: CategoryPath\n Icon_16 := <icon16 name>; \/\/optional: no, type: image\n Icon_32 := <icon32 name>; \/\/optional: no, type: image\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: IDOrNothing\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n Links := ['<link1>','<link2>',...] \/\/optional: Yes, type: UriCollection\nEND_SEC Les détails concernant la syntaxe des types de définition sont décrits dans la section Déclaration du module . Spécification: Si la section MetaData est manquant, ce module sera utilisé comme module de base qui ne pourra pas être instancié. Category définit un sujet pour les modules appartenant au même sujet. Le personnage | crée une structure hiérarchique des éléments dans la boîte de dialogue \"Ajouter un module\". Les personnages | et newline ou carriage return ne sont pas autorisés dans les noms de structures. Icon_16 définit le nom de l'icône avec une résolution de 16 x 16 pixels. Les images des icônes doivent être définies dans un pool d'images. L'icône Icon_16 est utilisé pour l'arborescence des modules et l'icône Icon_32 pour la boîte de dialogue d'informations. Inst_Prefix définit le préfixe par défaut pour les noms des instances FB et des instances de sous-modules générées. Préfixe vide ( Inst_Prefix := ) sont également possibles, ce qui peut toutefois provoquer une intersection avec d'autres noms de variables du bloc fonction. Ce préréglage peut être écrasé dans la section Slot . Si vous dérivez d'une classe de module avec IMPORTS , la section MetaData doit être mis à jour si cette section existe dans le module de base. Pour ce faire la section doit être déclarée avec le modificateur UPDATE et la description doit être redéfinie. Default_Inst_Name peut être utilisé pour définir un nom par défaut pour les instances de module étant des enfants de cet emplacement. Chaque module ajouté recevra ce nom par défaut en utilisant l'entrée de liste de textes définie par \"Default_Inst_Name\". S'il existe un nom par défaut d'un slot parent, ce nom est préféré à celui présent dans les métadonnées du module Links définit une liste de liens. Les liens sont affichés dans l'éditeur de module dans la Information languette. Le contenu de la première URL de la liste de liens est affiché dans le Information languette. Exemple SEC MetaData\n Desc := TL.Desc_Drives ;\n Category := 'Mechatronics'|'Drives' ;\n Icon_16 := IP.Drive_Icon_16 ;\n Icon_32 := IP.Drive_Icon_32 ;\n Default_Inst_Name := IDrive ;\n Links := ['file:\/\/\/d:\\Document1.pdf', 'https:\/\/www.codesys.com', 'mailto:info@codesys.com'];\nEND_SEC Category := 'Mechatronics'|'Drives crée la structure suivante : " }, 
{ "title" : "Section : Niveau supérieur ", 
"url" : "ac_module_fb_sec_toplevel.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Section : Niveau supérieur ", 
"snippet" : "Haut niveau Les modules situés au premier niveau de l'arborescence des modules sont appelés modules de niveau supérieur. Contrairement aux autres modules, ils disposent de méthodes qui peuvent être appelées directement depuis une ou plusieurs tâches. Les modules de niveau supérieur contiennent la se...", 
"body" : "Haut niveau Les modules situés au premier niveau de l'arborescence des modules sont appelés modules de niveau supérieur. Contrairement aux autres modules, ils disposent de méthodes qui peuvent être appelées directement depuis une ou plusieurs tâches. Les modules de niveau supérieur contiennent la section Toplevel . SEC Toplevel \/\/optional: yes, modifier: [UPDATE]\n GVL_Name := <GVL name>; \/\/optional: yes, type: literal\n Default_Application := <default application>; \/\/optional: yes, type: QID\n Default_POUPool := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n SEC Standard_Task : <task name> \/\/optional: yes, modifier: [HIDE,UPDATE]\n Name := <task name>; \/\/optional: no, type: ID\n Desc := <task description>; \/\/(optional: no, type: Text)\n Flags:= <flag>; \/\/(optional: no, type: StdTaskFlags)\n END_SEC\n SEC Custom_Task : <task name> \/\/optional: yes, modifier: [UPDATE]\n Priority := <priority>; \/\/optional: no, type: Subrange(0 .. 31)\n Interval := <interval>; \/\/optional: no, type: TimeLiteral)\n Flags:= <flag>; \/\/optional: no, type: CustomTaskFlags)\n END_SEC\nEND_SEC Les détails concernant la syntaxe des types de définition sont décrits dans la section Déclaration du module . Spécification: GVL_Name définit le nom de la GVL dans laquelle l'instance du module et toutes ses sous-instances seront déclarées. L'espace réservé %Instancename% (L'orthographe en majuscules ou minuscules n'est pas pertinente), sera remplacé par le nom de l'instance du module. Le paramètre Default_Application définit l'affectation de l'application pour toutes les instances de ce module à une application spécifique. Si une application par défaut est définie, l'utilisation de Default_POUPool n'est pas possible. Le paramètre Default_POUPool définit l'affectation d'application pour toutes les instances de ce module au pool de POU. Si un pool de POU par défaut est défini, l'utilisation de Default_Application n'est pas possible. Le paramètre Pragmas contient une liste de pragmas du compilateur, qui seront insérés avant la déclaration des instances FB du module. La section Standard_Task définit les tâches à partir desquelles les appels seront exécutés. Pour cela, trois tâches standards sont disponibles : LOW , MEDIUM , et HIGH . Les définitions de Standard_Task sont: Name : Nom de tâche par défaut qui sera défini comme affectation de tâche après la création de l'instance de module. Desc : Identifiant de l'appel de tâche. Celui-ci doit être court et significatif (exemple : I\/O task ). Flags : Les valeurs suivantes peuvent être combinées avec le | personnage: CREATE_IF_MISSING : La tâche sera créée si elle n'existe pas. READONLY : L'affectation de la tâche est en lecture seule et l'utilisateur ne peut pas la modifier. UPDATE_IOS : La tâche permet de mettre à jour les E\/S. Chaque E\/S peut être écrasée par le UpdateInTask paramètre dans le IO section. NONE : Aucun indicateur n'est défini. Exemple SEC Standard_Task : MEDIUM\n Name := MainTask ;\n Desc := TL.TaskMedium_Desc ;\n Flags := READONLY | CREATE_IF_MISSING ;\nEND_SEC En utilisant la section Custom_Task un module peut définir une ou plusieurs tâches personnalisées. La cible de la section doit être le nom d'une méthode du bloc fonction du module. La méthode ne doit pas avoir d'arguments (ni INPUT , OUTPUT , ni INOUT ). Priority : Définit la priorité de la tâche. Interval : Définit l'intervalle des tâches (constante de type de données \"TIME\" ou \"LTIME\"). Flags : Les valeurs suivantes peuvent être combinées avec le | personnage: SHARED : Pour des raisons de compatibilité, cet indicateur existe toujours, mais est toujours implicitement supposé être défini. Cela signifierait essentiellement que si une tâche avec les propriétés spécifiées dans le Custom_Task existe déjà, cette tâche sera utilisée. Mais comme une nouvelle tâche sera créée s’il n’existe aucune tâche existante avec des propriétés correspondantes, cet indicateur devient obsolète. Le nom de la tâche créée est TASK_<ModuleInstanceName>_<MethodName> . UPDATE_IOS : La tâche sera utilisée pour mettre à jour les E\/S, qui sont connectées aux expressions ST ou directement aux E\/S du module. NONE : Aucun indicateur n'est défini. Il n'y a pas d'implémentation par défaut dans la classe de module pour la méthode spécifiée. Exemple SEC Custom_Task : Method1\n Priority := 7 ;\n CycleTime := t#14ms ;\n Flags := NONE ;\nEND_SEC Exactement une tâche standard ou spécifique doit avoir le UPDATE_IOS ensemble de drapeaux. Quelques règles de base sur la manière dont les tâches sont générées doivent être mentionnées ici : S'il existe des tâches standards qui n'ont pas le CREATE_IF_MISSING indicateur défini, une tâche avec le nom spécifié et les propriétés des paramètres du générateur doit exister. Si les propriétés ne correspondent pas à celles spécifiées, un message d'avertissement s'affiche. S'il existe des tâches standard, qui ont le CREATE_IF_MISSING indicateur défini, une tâche avec les propriétés spécifiées est d'abord générée. Désormais, chaque fois que les paramètres du générateur pour cette tâche sont modifiés, la tâche est adaptée, sans aucun message d'avertissement. Les tâches standard de types différents faisant référence au même nom de tâche ne sont pas autorisées. Dans ce cas, aucune erreur n'est émise. En fonction du standard configuré, les méthodes suivantes sont appelées au début et à la fin de la tâche définie pour chaque instance de niveau supérieur : METHOD CallPrioHighStart: BOOL\nMETHOD CallPrioHighEnd: BOOL\nMETHOD CallPrioMediumStart: BOOL\nMETHOD CallPrioMediumEnd: BOOL\nMETHOD CallPrioLowStart: BOOL\nMETHOD CallPrioLowEnd: BOOL Chaque module est responsable d'appeler ses instances de sous-module. Les références de sous-modules ne doivent pas être appelées. L'implémentation par défaut dans le FB Module appelle les méthodes respectives de toutes les instances de sous-modules dans l'ordre de leur position dans l'arborescence des modules. Le pointeur SUPER permet d'accéder à l'instance du bloc fonction de base. Ainsi par exemple l'appel SUPER^.CallPrioHighStart() peut être utilisé pour appeler la méthode Module.CallPrioHighStart() si le bloc fonction s'étend Module . De cette façon, la mise en œuvre dans Module s'assurera que tous les sous-modules sont appelés. " }, 
{ "title" : "Rubrique : IO ", 
"url" : "ac_module_fb_sec_io.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Rubrique : IO ", 
"snippet" : "OI La définition des entrées et des sorties peut être effectuée dans cette section. Toutes les entrées et sorties définies sont disponibles dans le Mapper les E\/S . SEC IO \/\/optional: yes, modifier: [UPDATE] SEC Input : <input identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable := <variable...", 
"body" : "OI La définition des entrées et des sorties peut être effectuée dans cette section. Toutes les entrées et sorties définies sont disponibles dans le Mapper les E\/S . SEC IO \/\/optional: yes, modifier: [UPDATE]\n SEC Input : <input identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Name := <name>; \/\/optional: no, type: text\n Desc := <description>; \/\/optional: no, type: text\n UpdateInTask := <task name>; \/\/optional: yes, type: TaskRef\n END_SEC\n SEC Output : <output identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Name := <name>; \/\/optional: no, type: text\n Desc := <description>; \/\/optional: no, type: text\n UpdateInTask := <task name>; \/\/optional: yes, type: TaskRef\n END_SEC\nEND_SEC Pour plus de détails sur la syntaxe des types de définition, voir : description dans Syntaxe de la déclaration du module . Spécification: Le paramètre Variable définit le chemin d'instance d'une variable d'entrée ou d'une variable de sortie. Tous les composants du chemin des entrées doivent être des variables d'entrée (ou des variables locales dans les structures). Tous les composants du chemin des sorties doivent également être des variables de sortie (ou des variables locales dans les structures). La variable doit être un type de données primitif ou un type de données enum. Une variable peut être à la fois paramètre et entrée\/sortie. Une variable ne doit pas être utilisée par deux E\/S différentes. La cible d'un input ou output La section doit identifier de manière unique l’entrée ou la sortie. Il n'y a pas de sensibilité à la casse. Le paramètre UpdateInTask détermine la tâche de mise à jour des E\/S. Si ce paramètre manque la tâche avec le drapeau UPDATE_IOS sera utilisé. Pour les modules de niveau supérieur, une erreur sera créée si la tâche spécifiée dans UpdateInTask n'est pas défini pour le module. Exemple SEC Io\n SEC Input : uiTemperature\n Variable := uiTemperature ;\n Name := TL_WeatherStation.NAME_iTemperature ;\n Desc := TL_WeatherStation.DESC_iTemperature ;\n UpdateInTask := Standard_Task : Medium;\n END_SEC\n SEC Output : uiLigh\n Variable := uiLightnessSouth ;\n Name := TL_WeatherStation.NAME_uiLightnessSouth ;\n Desc := TL_WeatherStation.DESC_uiLightnessSouth ;\n UpdateInTask := Standard_Task : Medium;\n END_SEC\nEND_S " }, 
{ "title" : "Rubrique : Paramètres ", 
"url" : "ac_module_fb_sec_parameters.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Rubrique : Paramètres ", 
"snippet" : "Paramètres Dans cette section, vous pouvez définir tous les paramètres qui doivent être disponibles pour un paramétrage dans le Paramètres de l'instance de module. SEC Parameters \/\/optional: yes, modifier: [UPDATE] SEC Param : <parameter identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable :...", 
"body" : "Paramètres Dans cette section, vous pouvez définir tous les paramètres qui doivent être disponibles pour un paramétrage dans le Paramètres de l'instance de module. SEC Parameters \/\/optional: yes, modifier: [UPDATE]\n SEC Param : <parameter identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: yes, type: InstancePath\n VariableType := <data type> \/\/optional: yes, type: @JG???IEC-Typ\n Name := <parameter name>; \/\/optional: no, type: text\n Desc := <parameter description>; \/\/optional: no, type: text\n Group := <parameter group name> \/\/optional: yes, type: text\n MustBeSet := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n Default := <default value>; \/\/optional: yes, type: LiteralOrConstant\n Max := <max value>; \/\/Optional: yes, type: LiteralOrConstant\n Min := <min value>; \/\/Optional: yes, type: LiteralOrConstant\n END_SEC\nEND_SEC Les détails concernant la syntaxe des types de définition sont décrits dans la section Déclaration du module . Spécification: La cible de la section Param doit identifier le paramètre de manière unique. La définition Variable est un chemin d'instance d'entrée relatif au bloc fonctionnel du module. Cette variable stockera la valeur du paramètre, son type définit le type du paramètre. Si Variable est déclaré, le paramètre VariableType n’a pas besoin d’être défini et sera ignoré. Le paramètre VariableType définit le type CEI de la variable. Si VariableType est déclaré mais aucune variable FB réellement existante n'est donnée dans le Variable définition, le Default une définition doit exister. Cette valeur doit correspondre à la VariableType . Les paramètres Name et Desc sont des chaînes et doivent être définies dans une liste de textes. Le paramètre du module peut être des types et des énumérations de base, mais aucune instance de structures ou de tableaux. Les variables de paramètres doivent avoir Valeurs d'initialisation , qui sont définis dans la déclaration du bloc fonction. Le paramètre facultatif Default permet d'écraser la valeur d'initialisation. Pour l'expression d'initialisation et pour la valeur par défaut, les littéraux et les constantes du type correct sont autorisés. Cela inclut les paramètres de bibliothèque. Le paramètre facultatif Group permet de diviser les paramètres en groupes. Chaque groupe est ensuite affiché sous forme d'onglet distinct dans l'éditeur de module sous Paramètres . Avec le paramètre optionnel MustBeSet l'utilisateur peut être obligé de définir un paramètre dans l'éditeur de module. Si le paramètre n'est pas défini, un message d'erreur apparaît. Les définitions Min. et Max. permettent de fixer des limites pour la valeur du paramètre. La vérification de ces limites n'est possible que pour les variables de type numérique ou horaires. Tous les autres types de variables ne sont pas autorisés et produiront une erreur. Exemple SEC Parameters\n SEC Param : InParam1\n Variable := xIn1;\n VariableTyp := BOOL;\n Name := TL.Input1_Name;\n Desc := TL.Input1_Desc;\n END_SEC\nEND_SEC La variable xIn1 doit être défini dans la partie déclaration du bloc fonction : xIn1 : BOOL := FALSE ; " }, 
{ "title" : "Valeurs d'initialisation ", 
"url" : "ac_module_fb_sec_parameters.html#UUID-1cddf7ea-faa7-0b82-e29a-04e9f27653b0_ac_module_fb_sec_parameters0", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Rubrique : Paramètres \/ Valeurs d'initialisation ", 
"snippet" : "La valeur d'initialisation est la valeur d'une variable définie lors de l'initialisation. Dans les variables simples du FB, cette valeur se trouve toujours à droite de la déclaration de variable : iVar : INT := 17 ; \/\/ Initialisierungswert: 17 En cas de définition de variables dans des structures l'...", 
"body" : "La valeur d'initialisation est la valeur d'une variable définie lors de l'initialisation. Dans les variables simples du FB, cette valeur se trouve toujours à droite de la déclaration de variable : iVar : INT := 17 ; \/\/ Initialisierungswert: 17 En cas de définition de variables dans des structures l'initialisation de la structure est indispensable : TYPE s : STRUCT\n i1 : INT := 7 ;\n r1 : REAL := 5 ;\nEND_STRUCT END_TYPE Déclaration dans le module FB : structVar : s := (i1 := 2, r1 := 0.0) ; Dans ce cas la valeur d'initialisation qui définit la valeur de structVar.i1 est 2 (et pas 7 ). Dans les structures imbriquées, toutes les initialisations dans le chemin allant du module FB à la variable doivent être prises en compte. L'initialisation la plus externe de la variable détermine la valeur. " }, 
{ "title" : "Rubrique : Machines à sous ", 
"url" : "ac_module_fb_sec_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Rubrique : Machines à sous ", 
"snippet" : "Machines à sous Cette section définit la disponibilité et le type d'emplacements des modules dans l'arborescence des modules. Deux types différents de slots peuvent être définis. Fente SEC Slots \/\/optional: yes, modifier: [UPDATE]] SEC Slot : <slot identifier> \/\/optional: yes, modifier [HIDE,UPDATE]...", 
"body" : "Machines à sous Cette section définit la disponibilité et le type d'emplacements des modules dans l'arborescence des modules. Deux types différents de slots peuvent être définis. Fente SEC Slots \/\/optional: yes, modifier: [UPDATE]]\n SEC Slot : <slot identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Role := <role name>; \/\/optional: no, type: text\n Type := <slot type>; \/\/optional: no, type: SlotType\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: ID\n Optional := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n RegularExpressionParameterId := <RegEx param ID> \/\/optional: yes, type: text\n SEC Default_Allocation : \/\/optional: yes, modifier [UPDATE]\n Module_Name := <default module ID>; \/\/optional: yes, type: ID\n Instance_Name := <default name>; \/\/optional: yes, type: ID\n NotDeletable := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n SEC VisuEmbeddings \/\/optional: yes, modifier [UPDATE]\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <visu identigier> \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: ID\n Target := <target name>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: yes, type: ID\n TopLevelTap := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n SEC IOMappings \/\/optional: yes, modifier [UPDATE]\n SEC Mapping : <mapping identifier> \/\/optional: yes, modifier [UPDATE]\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, tye: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier [UPDATE]\n SEC Param : <param identifier> \/\/optional: yes, modifier [UPDATE]\n Value := <value>; \/\/optional: no, type: ID)\n END_SEC\n END_SEC\n END_SEC\n END_SEC\nEND_SEC Les détails concernant la syntaxe des types de définition sont décrits dans la section Déclaration du module . Spécification: La section Slot définit un emplacement qui autorise 0 connexion ou 1 connexion. La cible de la section Slot doit identifier le paramètre de manière unique. Il ne doit donc pas y avoir deux emplacements différents (que ce soit Slot ou Slot_Multi ) qui ont la même cible. (Les majuscules\/minuscules ne sont pas pertinentes.) La définition Variable est un chemin d'instance d'entrée relatif au bloc fonctionnel du module. Le chemin d'instance peut faire référence dans tous ses composants uniquement à des variables d'entrée (pour les instances de structure également à des variables locales). Le type de la variable adressée doit être une interface ou un type FB. Deux slots différents ne doivent pas utiliser la même variable. Role définit la description du rôle du slot. Type définit le type d'emplacement. Le type de connexion peut avoir les valeurs suivantes : SUBMODULE : Emplacement pour les instances de sous-modules. REFERENCE : Emplacement pour les instances de sous-modules référencées. DECOUPLED : Emplacement pour instances de modules \"découplés\". Voir également: Section : Découplé Inst_Prefix est un préfixe utilisé pour le nom de la variable FB générée. Préfixe vide ( Inst_Prefix := ; ) est également possible, mais peut créer des conflits avec d'autres noms de variables du bloc fonction. Ne peut être spécifié que pour SUBMODULE tapez des emplacements. Optional définit s'il est permis de laisser le slot ouvert ou s'il doit être connecté. Default_Inst_Name peut être utilisé pour définir un nom par défaut pour les instances de module étant des enfants de cet emplacement. Chaque module ajouté recevra ce nom par défaut en utilisant l'entrée de liste de textes définie par \"Default_Inst_Name\". Le nom par défaut du slot est préféré à celui des métadonnées du module. Pragmas contient une liste de pragmas du compilateur qui sont insérés avant les instances FB des sous-modules. Les pragmas ne peuvent être utilisés que pour les emplacements gérés. RegularExpressionParameterId définit un paramètre de type STRING\/WSTRING pour ce slot. La valeur de ce paramètre est interprétée comme une expression régulière et elle doit correspondre au nom du sous-module inséré. Les rubriques Slot.Default_Allocation et Slot_Multi.Default_Allocation permettent de définir les paramètres par défaut pour les slots avec un nombre d'éléments variable (Multi_Slots et Slots). Pour Slots.Multi_Slot ils doivent être identifiés par des cibles uniques alors que Slots.Slot n'a pas de cible et ne peut en avoir qu'une Default_Allocation section. L'instance sera ajoutée en fonction de sa position dans la section. Le nom du module et le nom de l'instance suivent la définition de Slot.DefaultModule et Slot.DefaultName . Si ces définitions ne sont pas disponibles, les paramètres de Default_Allocation.Module_Name et Default_Allocation.Instance_Name sera utilisé. Il est recommandé d'utiliser Default_Allocation.* pour les emplacements au lieu de DefaultModule et DefaultName qui n'existe que pour des raisons de compatibilité. Les paramètres de l'instance de module par défaut peuvent être définis dans les sous-sections de Default_Allocation : Module_Name définit le nom du module dont une instance sera créée automatiquement. Si le module provient d'une bibliothèque, le nom du module doit être qualifié avec namespace. Le paramètre n'est autorisé que pour les emplacements de type SUBMODULE . Les appels infinis ne sont pas autorisés et créeront un message d'erreur (exemple : la déclaration du module \"A\" contient le module par défaut \"B\" ; la déclaration du module \"B\" contient le module par défaut \"A\"). Instance_Name doit être précisé à chaque fois DefaultModule est spécifié, et jamais autrement. Il doit s'agir d'un identifiant CEI valide qui est utilisé comme nom de l'instance de module par défaut. Le nom ne doit ni commencer ni se terminer par un soulignement ( _ ). Les noms par défaut de tous les slots d'une déclaration doivent être uniques. (Le respect de la casse ne fait aucune différence.) NotDeletable précise si le module peut ou non être supprimé par l'utilisateur. Si TRUE , le module ne peut pas être supprimé. Un message d'erreur s'affiche. Si le paramètre est FALSE ou s'il est omis, le module peut alors être supprimé. VisuEmbeddings : Si la Empty le paramètre est réglé sur TRUE , puis une liste vide de visus intégrés est créée pour cette instance de module. Si la valeur est FALSE , la liste souhaitée des visualisations intégrées peut être générée pour l'instance de module via la liste des visualisations intégrées souhaitées dans le Embedding sous-section. Chaque Embedding la section doit définir le nom VisuName de la visu intégrée souhaitée à cet effet et peut spécifier des propriétés supplémentaires telles que Target ou LinkId de cette visu embarquée. PageVisu : Dans cette section, le PageVisu de l'instance de module peut être choisi ( VisuName ). De plus, il peut être défini si cette visu crée un TopLevelTap . Le paramètre TopLevelTap il faut donner les valeurs TRUE et FALSE . IOMappings : Dans la sous-section Mapping les canaux d'E\/S peuvent être définis. Les cibles des sections Mapping décrire le canal d'E\/S cible. La valeur par défaut peut être définie sur NoMapping ou à un STExpression . Parameters : Dans la sous-section Param la valeur Value de chaque paramètre défini dans la cible de la section peut être défini. Slot_Multi En utilisant la section Slot_Multi une liste de sous-instances et de références peut être créée. SEC Slots \/\/optional: yes, modifier: [UPDATE]]\n SEC Slot_Multi : <slot name> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable for count>; \/\/optional: no, type: InstancePath\n Role := <name role>; \/\/optional: no, type: text\n Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\n Type := <slot type>; \/\/optional: no, type: SlotType\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: ID\n Pragmas := <pragma list>; \/\/optional: yes, type: Pragmalist\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n RegularExpressionParameterId := <RegEx param ID> \/\/optional: yes, type: text\n SEC Default_Allocation : \/\/optional: yes, modifier [UPDATE]\n Module_Name := <default module ID>; \/\/optional: yes, type: ID\n Instance_Name := <default name>; \/\/optional: yes, type: ID\n NotDeletable := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n SEC VisuEmbeddings \/\/optional: yes, modifier [UPDATE]\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <visu identifier> \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: ID\n Target := <target name>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: yes, type: ID\n TopLevelTap := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n SEC IOMappings \/\/optional: yes, modifier [UPDATE]\n SEC Mapping : <mapping identifier>; \/\/optional: yes, modifier [UPDATE]\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, tye: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier [UPDATE]\n SEC Param : <param identifier> \/\/optional: yes, modifier [UPDATE]\n Value := <value>; \/\/optional: no, type: ID)\n END_SEC\n END_SEC\n END_SEC\n END_SEC\nEND_SEC Spécifications supplémentaires : Var_Count définit le chemin de l'instance d'entrée du bloc fonctionnel du module. Cette variable (de type Integer) enregistrera les informations sur le nombre d'instances connectées au slot. Cardinality définit le nombre minimum et maximum d'instances. Le Slot_Multi.Default_Allocation La section peut être utilisée pour définir des allocations par défaut pour les emplacements avec un nombre variable d'éléments. Ils doivent être identifiés via des cibles uniques. Les instances sont insérées dans l'ordre des sections. Pour le nom du module et le nom de l'instance, les spécifications pour Slot.DefaultModule ou Slot.DefaultName appliquer. Le nombre d'affectations par défaut ne doit pas dépasser le chiffre supérieur. La variable adressée par un Slot_Multi la section doit être de type POINTER TO <INTERFACE> . Chaque variable d'entrée de type entier peut être adressée par Var_Count juste une fois. (Cela inclut également InstRef_Multi.Var_Count et VarArray.Var_Count ). Exemple SEC Slot\n SEC Slot_Multi : subs\n Variable := pSubs;\n Var_Count := uiArraySize;\n Role := TL.Role;\n Cardinality := [2 .. 17];\n Type := SUBMODULE;\n RegularExpressionParameterId := Param_RegEx_Ref;\n SEC Default_Allocation : def1\n Module_Name := Sub1;\n Instance_Name := Submodule;\n END_SEC\n Name := TL.Input1_Name;\n Desc := TL.Input1_Desc;\n END_SEC\nEND_SEC Entre autres déclarations, la partie déclaration du bloc fonctionnel doit contenir : uiArraySize: UINT; pSubs: POINTER TO ITestModule . Dans l'exemple, un emplacement est défini et contient au moins 2, mais au plus 17 sous-instances. Un tableau sera créé pour les sous-instances et pSubs le souligne. Lors de l'ajout de l'instance, le sous-module portant le nom Submodule de type Sub1 sera ajouté automatiquement à l’emplacement. " }, 
{ "title" : "Section : Modèle source ", 
"url" : "ac_module_fb_sec_copyfb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Section : Modèle source ", 
"snippet" : "Modèle source Les sous-sections de la section SourceTemplate définit les blocs fonction à copier dans le projet. Dans l'éditeur de module, les blocs fonctionnels définis ici sont répertoriés. Là, vous pouvez activer ou désactiver la copie. Voir également Modèle source SEC std.SourceTemplate SEC Sour...", 
"body" : "Modèle source Les sous-sections de la section SourceTemplate définit les blocs fonction à copier dans le projet. Dans l'éditeur de module, les blocs fonctionnels définis ici sont répertoriés. Là, vous pouvez activer ou désactiver la copie. Voir également Modèle source SEC std.SourceTemplate\n SEC SourceFB : <Identifier> \/\/ optional: no\n SourceType := <FunctionBlock>; \/\/ optional: no, type: InstancePath\n Variable := <variable name>; \/\/ optional: no, type: InstancePath\n Default := TRUE\/FALSE; \/\/ optional: yes, type: Bool Flag\n IsMandatory := TRUE\/FALSE; \/\/ optional: yes, type: Bool Flag\n FBVariable := <variable name>; \/\/ optional: yes, type: InstancePath\n DestinationType := <default name>; \/\/ optional: yes, Type: String\/Literal\n END_SEC\nEND_SEC Les détails concernant la syntaxe des types de définition sont décrits dans la section Déclaration du module . Spécification: Le Identifier est utilisé dans l'éditeur de module. Il définit le nom du bloc fonction copié si DestinationType n'est pas défini. SourceType définit le bloc fonction à copier. Variable définit une variable d'entrée du bloc fonction du module. Il doit s'agir d'un pointeur vers une classe de base de la fonction copiée ou une interface implémentée par le bloc fonction à copier. Default définit si le bloc fonction est copié par défaut pour ce module. Si la définition manque, TRUE est réglé. Cette option peut être ajustée dans l'éditeur de module. Si IsMandatory est réglé sur TRUE , l'utilisateur ne peut pas modifier le IsToCopy option dans l'éditeur de module. FBVariable définit une variable d'entrée du bloc fonction à copier. La variable d'entrée est ensuite instanciée avec l'instance de module. Le type de l'entrée est un pointeur vers un type de base du module FB ou un pointeur vers l'interface du module FB. DestinationType définit un nom standard pour le bloc fonction copié. Si la définition est manquante, la convention de dénomination suivante est utilisée : <Nom de the instance de module>_<Identifiant>[_<numéro consécutif>]. Les SourceTemplates spécifiés sont copiés dans le AC_SourceTemplate dossier. Ils sont instanciés et initialisés par le module FB affecté. Les SourceTemplates, une fois créés, peuvent être modifiés et ne seront pas écrasés par de nouvelles exécutions du générateur. Les SourceTemplates, qui ne sont plus nécessaires, sont renommés (avec le <_unused > suffixe) et déplacé vers le <UnusedSourceTemplates> dossier. Exemple SEC std.SourceTemplate\n SEC SourceFB : ID_ConnectSwitches\n SourceType := ConnectSwitches;\n Variable := itfConnect;\n FBVariable := pBuilding;\n Default := TRUE;\n IsMandatory := FALSE;\n DestinationType := 'TypeInModuleDescription';\n END_SEC\nEND_SEC " }, 
{ "title" : "Rubrique : Visu ", 
"url" : "ac_module_fb_sec_visu.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Rubrique : Visu ", 
"snippet" : "Visu SEC Visu \/\/optional: yes, modifier: [UPDATE] Toplevel_Tab; \/\/optional: yes, type: bool Embedded := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList Embedded_Proxy := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList Page =: [<visu1>, <visu2>,...]; \/\/optional: yes, type: Vis...", 
"body" : "Visu SEC Visu \/\/optional: yes, modifier: [UPDATE]\n Toplevel_Tab; \/\/optional: yes, type: bool\n Embedded := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList\n Embedded_Proxy := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList\n Page =: [<visu1>, <visu2>,...]; \/\/optional: yes, type: VisuList\n\n SEC DefaultEmbeddings \/\/optional: yes\n SEC Embedding : <visu identifier> \/\/optional: yes, modifier: [HIDE, UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: literal\n Target := <target name>; \/\/optional: yes, type: literal\n ProxyVisuName := <visu name>; \/\/optional: yes, type: literal\n LinkId := <linkID>; \/\/optional: yes, type: literal\n END_SEC\n END_SEC\n\n SEC Toplevel_Tab_Hotkey \/\/optional: yes\n Hotkey := <keycode>; \/\/optional: no, type: literal\n Modifiers := <modifier>; \/\/optional: yes, modifier: [SHIFT, CONTROL, ALT]\n END_SEC\n\nEND_SEC Les détails concernant la syntaxe des types de définition sont décrits dans la section Déclaration des modules . Spécification: Toplevel_Tab définit si la case à cocher Créer un onglet de niveau supérieur dans l'éditeur HMI est activé ou désactivé par défaut. Page définit une liste d'objets de visualisation disponibles pour le module. Embedded définit une liste d'objets de visualisation disponibles du sous-module qui seront intégrés dans d'autres écrans de visualisation. Utilisation de l'espace réservé %PAGE_VISU% au lieu du nom de la visualisation, les écrans de visualisation générés peuvent éventuellement être intégrés dans d'autres écrans. Embedded_Proxy définit une liste des objets de visualisation disponibles du module. La liste n'est utilisée que si un decoupled module est inséré dans un decoupled slot et s'il n'est pas créé sous le contrôleur de son instance de module père (en tant que proxy). Pour les modules qui importent un autre module, l'espace réservé %NONE% peut être utilisé à la place du nom de la visualisation. Cela a pour effet que les visualisations importées sont masquées. Cette approche est possible aussi bien pour la liste des écrans de visualisation que pour les écrans de (proxy-)visualisation embarqués. Section: DefaultEmbeddings : Cette section sert à la spécification des encastrements par défaut, qui apparaîtront alors comme une pré-configuration sur le IHM onglet d'un sous-module (similaire à la section \"Default_Allocation\", voir Rubrique : Machines à sous ). Les plongements par défaut souhaités doivent être décrits dans les sous-sections Embedding . Prérequis : L'objet de visualisation spécifié et le proxy doivent être disponibles dans la liste des incorporations possibles pour le module (voir ci-dessus : Embedded et Embedded_Proxy ). Section: Toplevel_Tab_Hotkey : Cette section définit un raccourci clavier comme paramètre par défaut pour la page de niveau supérieur. Les raccourcis clavier ne doivent pas être utilisés plus d'une fois. Ce paramètre peut être ajusté dans l'éditeur de module sur le IHM languette. Exemple SEC Visu\n Toplevel_Tab ;\n Page := [VISU_CNC_Machine_1, VISU_CNC_Machine_2];\n Embedded := [%PAGE_VISU%];\n SEC DefaultEmbeddings\n SEC Embedding : No1\n VisuName := SubModule_Emb;\n Target := '..\/..\/TopLevel_2';\n END_SEC\n SEC Embedding : No2\n VisuName := SubModule_Emb_2;\n \/\/ProxyVisuName := SubModule_Emb_1;\n Target := '';\/\/ leave empty for next ancestor\n END_SEC\n END_SEC\n SEC Toplevel_Tab_Hotkey\n Hotkey := T;\n Modifiers := SHIFT | CONTROL;\n END_SEC\nEND_SEC Le nom de la visualisation est le nom de l'objet de visualisation respectif (non sensible à la casse). L'objet de visualisation doit se trouver au même niveau hiérarchique que le bloc fonction du module. Règles pour l'interface des objets de visualisation : Tous les objets de visualisation et les objets de visualisation intégrés peuvent avoir une variable VAR_IN_OUT avec le nom inst , qui peut être du type du bloc fonction du module ou d'une classe de base. Le nom de la variable n'est pas sensible à la casse. VAR_IN_OUT   inst : <MODULE_FB> ; END_VAR Comme alternative à l'option décrite ici avec VAR_IN_OUT, une variable VAR_INPUT peut également être utilisée. Cette variable doit répondre aux exigences suivantes : Nom: inst Type : interface que le bloc fonction du module implémente Les objets de visualisation intégrés peuvent avoir deux variables supplémentaires (les noms de variables ne sont pas sensibles à la casse) : VAR_INPUT paVisuFB : POINTER TO POINTER TO AC_Visu_Base ; iOwnFrameIndex : INT ; END_VAR Ces variables doivent être définies ensemble ; il n'est pas permis de définir l'un sans l'autre. Ces deux variables permettent aux visualisations intégrées de basculer le cadre central dans la visualisation de niveau supérieur. paVisuFB est un tableau de pointeurs sur AC_Visu_Base instances . Utiliser la variable de visualisation globale CURRENTCLIENTID pour accéder à l'instance correcte du client actuel. La commutation de trame est effectuée par une action ST de la forme : paVisuFB[CURRENTCLIENTID]^.uiFrameIdx := iOwnFrameIndex ; iOwnFrameIndex est l'indice que l'image de visualisation du propre module a dans ce cadre de niveau supérieur. (Si le propre module ne définit pas d'image de visualisation, cet indice est -1.) Hormis les variables mentionnées ci-dessus, aucune autre variable VAR_INPUT, VAR_OUTPUT ou VAR_INOUT n'est autorisée. le AC_Visu_Base les instances fournissent la fonction supplémentaire GetModuleFrameIndex . Cette fonction renvoie l'indice de l'écran de visualisation (si présent) dans la visualisation de niveau supérieur pour une instance de module (voir IModule dans AC_Module_Base.library) . Avec cette fonction, vous pouvez accéder à n'importe quel écran de visualisation dans l'arborescence des instances de module. Pour permettre également la navigation dans le code d'un module, l'environnement du module (voir IModule dans AC_Module_Base.library ) possède un membre, Environment.visus , ce qui correspond à ce qui précède paVisuFB aiguille. Pour pouvoir utiliser la variable CURRENTCLIENTID , la bibliothèque VisuGlobalClientManager (catégorie \"Intern|Visu\") doit être ajouté au projet. La première visualisation sera utilisée comme paramètre par défaut. " }, 
{ "title" : "Rubrique : Tendance ", 
"url" : "ac_module_fb_sec_trend.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Rubrique : Tendance ", 
"snippet" : "Tendance SEC tre.Trend \/\/optional: yes, modifier: [UPDATE] SEC TrendRecording : <CFC trend identifier> \/\/optional: yes, modifier: [UPDATE] Task := <trend task> \/\/optional: yes, type: TimeLiteral CycleTime := <time value> \/\/optional: yes, type: TimeLiteral LimitType := <limit type> \/\/optional: yes, t...", 
"body" : "Tendance SEC tre.Trend \/\/optional: yes, modifier: [UPDATE]\n SEC TrendRecording : <CFC trend identifier> \/\/optional: yes, modifier: [UPDATE]\n Task := <trend task> \/\/optional: yes, type: TimeLiteral\n CycleTime := <time value> \/\/optional: yes, type: TimeLiteral\n LimitType := <limit type> \/\/optional: yes, type: FileLimitType\n LimitMaximum := <max bytes> \/\/optional: yes, type: Literal\n RecordCondition \/\/optional: yes, type: InstanceAccess\n SEC Visu \/\/optional: yes, modifier: [UPDATE]\n VisuPlaceholder \/\/optional: yes, type: StringLiteral\n VisuTemplate := <visu template> \/\/optional: yes, type: StringLiteral\n Target := <path module instance \/\/optional: yes, type: StringLiteral\n END_SEC\n END_SEC\n\n SEC TrendVariable : <variable identifier> \/\/optional: yes, modifier: [UPDATE]\n Variable := <variable name> \/\/optional: yes, type: InstanceAccess\n TrendRecording := <recording name> \/\/optional: no, type: : Id)\n Description := <tooltip> \/\/optional: yes, type: TextRef\n Color := <graph color> \/\/optional: yes, type: Literal\n GraphType := <graph type> \/\/optional: yes, type: GraphType\n LineWidth := <width> \/\/optional: yes, type: Literal\n LineStyle := <line style> \/\/optional: yes, type: LineStyle\n SEC Warning : MIN\/MAX \/\/optional: yes, modifier: [UPDATE]\n Limit := <limit value> \/\/optional: no, type: Literal\n Color := <limit color> \/\/optional: yes, type: Literal\n END_SEC\n END_SEC\nEND_SEC Les détails concernant la syntaxe des types de définition sont décrits dans la section Déclaration des modules . Spécification: Task : Définit la tâche pour l'enregistrement de tendance. Si aucune tâche n'est définie, la tâche, créée automatiquement par le visu trend sera utilisée. CycleTime : Temps de cycle de l'enregistrement de la tendance LimitType : Type de limitation de la tendance enregistrée. LimitMaximum : Taille maximale de l'enregistrement de tendance en Ko (uniquement avec LimitType ==FichierLimite). RecordCondition : Condition d'enregistrement. La variable référencée doit être de type BOOL. VisuPlaceholder : Espace réservé, remplacé par la visualisation de tendance générée. VisuTemplate : Modèle pour le visu à créer. Le modèle doit avoir un espace réservé Trend_Placeholder . Il peut contenir des champs avec l'identifiant suivant : TrendLegend -> taper : Légende TrendTimeRangeSelector -> type : Sélecteur de plage de temps TrendDateRangeSelector -> Type : Sélecteur de plage de dates Target : chemin relatif vers l'instance de module, dans laquelle la visualisation sera intégrée. Variable : Variable à enregistrer. TrendRecording : Objet TrendRecording auquel appartient la variable. Description : entrée de la liste de texte, qui sera affichée pour la variable sous forme d'info-bulle. Color : Couleurs du graphique de la variable sous forme de code couleur ARGB GraphType : Type de graphique LineWithPoints : Lignes avec des points Cross : Des croix StepWithPoints : Étapes avec des points Point : Points Lines : Lignes Step : Pas LinesWithCrosses : Lignes avec croix \\\\ StepWithCrosses : Marches avec croix LineWidth : Largeur de la ligne tracée. Plage de valeurs : 1 à 255. LineStyle : Style de ligne Solid : Solide Dashed : En pointillé Dotted : Pointillé DashDotted : Tiret pointillé DashDotDotted : Tiret point pointillé Warning : Cette sous-section doit avoir pour cible MAX ou MIN . Selon la cible, le dépassement ou le sous-dépassement déclenchera l'avertissement. Limit : Début de la plage critique. Color : Couleur pour la plage critique comme code couleur ARGB Exemple SEC tre.Trend\n SEC TrendRecording : TrendSensor\n SEC Visu\n VisuPlaceholder := 'TrendPlaceholder_TrendSensor';\n VisuTemplate := 'AC_Trend.GenTrend_VisuTemplate';\n END_SEC\n CycleTime := t#5s;\n LimitType := Records;\n LimitMaximum := 452;\n END_SEC\n SEC TrendVariable : Value\n Variable := value;\n TrendRecording := TrendSensor;\n Color := 16#FF00FF00;\n SEC Warning : MIN\n Limit := -5;\n Color := 16#FF101020;\n END_SEC\n GraphType := LinesWithCrosses;\n LineWidth := 3;\n END_SEC\nEND_SEC " }, 
{ "title" : "Rubrique : Procurations ", 
"url" : "ac_module_fb_sec_proxies.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Rubrique : Procurations ", 
"snippet" : "Procurations La section Proxies définit un bloc fonctionnel qui implémente le proxy. Un proxy sert à l'échange de données de modules d'application différente. L'instance du FB proxy représente l'instance du module dans une application distante. SEC Proxies \/\/optional: yes, modifier: [UPDATE] SEC Pro...", 
"body" : "Procurations La section Proxies définit un bloc fonctionnel qui implémente le proxy. Un proxy sert à l'échange de données de modules d'application différente. L'instance du FB proxy représente l'instance du module dans une application distante. SEC Proxies \/\/optional: yes, modifier: [UPDATE]\n SEC Proxy : <identifier> \/\/optional: yes, modifier [UPDATE]\n FB := <FB name>; \/\/optional: no, type: QID\n SEC MirrorVar : <identifier> \/\/optional: yes, modifier [UPDATE])\n Variable := <variable name>; \/\/optional: no, type: VarPath\n END_SEC\n SEC ProxyParameter : <target> \/\/ optional: yes, modifier [UPDATE]\n Variable := <InstancePath>; \/\/ optional: no, type: VarPath\n END_SEC\n END_SEC\nEND_SEC Les détails concernant la syntaxe des types de définition sont décrits dans la section Déclaration des modules . Spécification: Le bloc fonction doit dériver de IBaseInstance . Le bloc fonction doit avoir une méthode SetProxyIdentification avec la signature suivante, qui n'est pas incluse dans l'interface IBaseInstance : SetProxyIdentification(pbyName : POINTER TO BYTE, udiComAddr : UDINT, udiLocalComAddr : UDINT, pEnvironment : MEnv) Le nom d'instance passé et l'adresse définie doivent être renvoyés à partir des propriétés InstanceName , ComAddress , et LocalComAddress . Le bloc fonction ne doit pas dériver de IModule . La section MirrorVar permet de refléter une variable d'instances de module sur ses instances proxy. Pour cela, le chemin d'instance de la variable doit être déclaré dans la définition Variable , qui doit être indiqué sous la forme d'un chemin relatif (à l'instance de module FB). Les règles suivantes s'appliquent à la variable spécifiée de l'instance de module FB : La variable doit faire partie des variables, entrées ou sorties du FB de l'instance de module. Il doit être défini dans le module FB ainsi que dans le proxy FB Il doit être du même type dans les deux FB Il doit avoir un type primitif ; ainsi, aucun pointeur, interface ou structure dans son ensemble n'est autorisé pour la mise en miroir, mais seuls les types simples (numeric, STRING, TIME, etc.) Si les variables spécifiées remplissent ces conditions, elles sont automatiquement transférées dans le cadre du RMP sans que l'utilisateur ait à se soucier davantage du transfert. La section ProxyParameter permet de définir des paramètres pour le proxy. Les points suivants doivent être pris en compte : La cible de la ProxyParameter doit correspondre à un paramètre cible du module le variable du module proxy doit correspondre au type de la variable utilisée pour le paramètre module. Seuls les types primitifs et les énumérations sont autorisés Les paramètres proxy sont définis une fois sur la valeur configurée dans l'instance de module lors de la phase d'initialisation de l'application respective. Pendant que l'application est en cours d'exécution, ces variables ne sont pas reflétées dans les proxys Le nom du bloc fonction peut être qualifié par un chemin d'espace de noms. Exemple SEC Proxies\n SEC Proxy ProxyFB1\n FB := ProxyModule1;\n SEC MirrorVar : diInput\n Variable := diInput;\n END_SEC\n SEC ProxyParameter : InParam1\n Variable := TL.Input1_Name;\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "Section : Tableaux Var ", 
"url" : "ac_module_fb_sec_vararray.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Section : Tableaux Var ", 
"snippet" : "Tableaux Var Le paramètre VarArrays permet de créer des tableaux de taille configurable. SEC VarArrays \/\/optional: yes, modifier: [UPDATE]] SEC VarArray : <slot identifier> \/\/optional: yes, modifier [] Variable := <variable name>; \/\/optional: no, type: InstancePath Var_Count := <variable count>; \/\/o...", 
"body" : "Tableaux Var Le paramètre VarArrays permet de créer des tableaux de taille configurable. SEC VarArrays \/\/optional: yes, modifier: [UPDATE]]\n SEC VarArray : <slot identifier> \/\/optional: yes, modifier []\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable count>; \/\/optional: no, type: InstancePath\n Inst_Name := <instance name>; \/\/optional: yes, type: StringLiteral\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n Var_Decl_Flags := <Flag1> | <Flag2> | ... ; \/\/optional: yes, type: Flags\n END_SEC\nEND_SEC Les détails concernant la syntaxe des types de définition sont décrits dans la section Déclaration des modules . Spécification: La définition Variable est un chemin d'instance d'entrée relatif au bloc fonction du module. Le type de données est POINTER TO <ELEMTYPE> . <ELEMTYPE> peut être n'importe quel type de données. La cible d'une section VarArray doit identifier le tableau de variables de manière unique. Var_Count définit le chemin de l'instance d'entrée d'un entier Variable du bloc fonction du module. Pour être disponible dans l'éditeur pour la configuration, cette variable doit être définie en tant que paramètre. Alternativement la variable Var_Count de Slot_Multi ou InstRef_Multi peut être utilisé pour définir cette variable. Plusieurs VarArrays peuvent utiliser le même Var_Count variable. Si la taille du tableau est 0, aucun tableau ne sera généré et le pointeur du tableau sera défini sur 0. Inst_Name définit le nom de la variable tableau créée. L'espace réservé %Instancename% et %VariablePath% (l'orthographe en majuscules ou minuscules n'est pas pertinente) sera remplacé par le nom d'instance du module instance resp. le chemin d'instance de la variable de pointeur. Les points seront remplacés par des soulignements. Si la définition est omise, la valeur par défaut AC_ARRAY_%VariablePath% . est utilisé. Une erreur sera créée si deux VarArrays différents d'un module ont le même Inst_Name , qui n'inclut pas l'espace réservé %VariablePath% . Pragmas contient une liste de pragmas de compilateur, qui seront insérés avant la variable de tableau générée. Var_Decl_Flags peut être utilisé pour spécifier le type de variable du tableau créé. Les drapeaux possibles sont NONE , RETAIN , et PERSISTENT . Ces drapeaux sont ajoutés à la section variable VAR_INPUT , dans lequel le tableau est créé. (exemple : pour le drapeau RETAIN , VAR_INPUT RETAIN ). Exemple SEC VAR_ARRAYS\n SEC VAR_ARRAY : NameList\n Variable := psNameList;\n Var_Count := uiArraySize;\n END_SEC\n ...\n SEC PARAM : ArraySize\n Variable := uiArraySize;\n Name := TL.ArraySize_Name;\n Desc := TL.ArraySize_Desc;\n END_SEC\nEND_SEC Entre autres déclarations, la partie déclaration du bloc fonctionnel doit contenir : uiArraySize: UINT := 7; psNameList: POINTER TO STRING; . " }, 
{ "title" : "Rubrique : Contraintes ", 
"url" : "ac_module_fb_sec_constraints.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Rubrique : Contraintes ", 
"snippet" : "Contraintes Cette section spéciale permet de vérifier si chaque instance de module est référencée au moins une fois. SEC Constraints \/\/optional: yes, modifier: [UPDATE] Referenced_By := <interface name>; \/\/optional: yes, type: QID) Referenced_Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, ...", 
"body" : "Contraintes Cette section spéciale permet de vérifier si chaque instance de module est référencée au moins une fois. SEC Constraints \/\/optional: yes, modifier: [UPDATE]\n Referenced_By := <interface name>; \/\/optional: yes, type: QID)\n Referenced_Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\nEND_SEC Les détails concernant la syntaxe des types de définition sont décrits dans la section Déclaration des modules . Spécification: Le paramètre Referenced_By sert à vérifier si les instances de module sont référencées à partir d'autres instances de module. La valeur de ReferencedBy doit être une interface qui dérive de IModule . Si le type de l'instance de référence n'a pas d'importance, IModule peut être spécifié ici. Referenced_Cardinality définit la fréquence à laquelle ce module doit être référencé. Si le nombre de références n'est pas dans cette plage, une erreur est produite lors de la scrutation du générateur standard. Exemple SEC Constraints\n Referenced_By := ISpecificModule;\n Referenced_Cardinality := [1 .. 3];\nEND_SEC " }, 
{ "title" : "Section : InstRefs ", 
"url" : "ac_module_fb_sec_instrefs.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Section : InstRefs ", 
"snippet" : "InstRefs La section InstRefs définit les références aux instances FB ou aux instances de structure. SEC InstRefs \/\/optional: yes, modifier: [UPDATE] SEC InstRef : <identifier> \/\/target: yes, optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/optional: no, type: InstancePath Desc :=...", 
"body" : "InstRefs La section InstRefs définit les références aux instances FB ou aux instances de structure. SEC InstRefs \/\/optional: yes, modifier: [UPDATE]\n SEC InstRef : <identifier> \/\/target: yes, optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Desc := <description>; \/\/optional: no, type: text\n Optional := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n...\n SEC InstRef_Multi : <identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable for count>; \/\/optional: no, type: InstancePath\n Desc := <description>; \/\/optional: no, type: text\n Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\n END_SEC\nEND_SEC Les détails concernant la syntaxe des types de définition sont décrits dans la section Déclaration des modules . Spécification: Inst_Ref.Variable définit le chemin de l'instance d'entrée d'une variable de type POINTER TO <T> ou de type <interface> . ( <T> est n'importe quelle structure ou type de FB) InstRef_Multi.Variable définit le chemin de l'instance d'entrée de type POINTER TO POINTER TO <T> ou de type POINTER TO <interface> . ( <T> est n'importe quelle structure ou type de FB) Deux entrées InstRef ou InstRef-Multi différentes ne doivent pas utiliser la même variable. La cible doit identifier de manière unique la référence d'instance. Cela signifie qu'il ne doit pas exister deux déclarations de référence d'instance différentes (section InstRef et InstRef_Multi ) avec la même cible (l'orthographe des majuscules ou des minuscules n'a pas d'importance). La variable entière d'entrée définie par Var_Count ne peut être utilisé qu'une seule fois VarCounts de Slot_Multi ou InstRef_Multi . Seules les variables entières définies par Var_Count de VarArray peut être utilisé en parallèle avec Var_Counts de Slot_Multi ou InstRef_Multi . Exemple SEC InstRef_Multi : Elements\n Variable := piElems ;\n Var_Count := uiArraySize ;\n Desc := TL.Elems_Desc ;\n Cardinality := [1 .. 10] ;\nEND_SEC Entre autres déclarations, la partie déclaration du bloc fonctionnel doit contenir : uiArraySize : UINT; piElems : POINTER TO Interface; piElems pointe vers un créé globalement, correctement initialisé ARRAY[0..uiArraySize-1] OF interface ou OF POINTER TO <T> , qui pointe vers les instances individuelles. Par conséquent, le i-ème objet est accessible au moyen de piElems[i] . " }, 
{ "title" : "Section : mse.Séquence ", 
"url" : "ac_module_fb_sec_sequence.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Section : mse.Séquence ", 
"snippet" : "mse.Sequence Cette section détermine les définitions de l'éditeur de séquence. La section doit être présente dans la déclaration du module, afin que l'éditeur des modules propose l'onglet supplémentaire Éditeur de séquence . SEC mse.Sequence \/\/optional: yes, modifier: [UPDATE] Root := TRUE\/FALSE; \/\/...", 
"body" : "mse.Sequence Cette section détermine les définitions de l'éditeur de séquence. La section doit être présente dans la déclaration du module, afin que l'éditeur des modules propose l'onglet supplémentaire Éditeur de séquence . SEC mse.Sequence \/\/optional: yes, modifier: [UPDATE]\n Root := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Step := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Parallel := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Branch := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n VisibleParams := [<visparam1>, <visparam2>,...]; \/\/optional: yes, type: ID-list\n VisibleIOs := [<visIO1>, <visIO2>,...]; \/\/optional: yes, type: ID-list\n VisibleRefs := [<visref1>, <visref2>,...]; \/\/optional: yes, type: ID-list\n AConnectionColor := [<itfname>]; \/\/optional: yes, type: ID-list\n BConnectionColor := [<itfname>]; \/\/optional: yes, type: ID-list\n OnlineActiveVar := <xActive>; \/\/optional: yes, type: ID\n OnlineBreakpointVar := <xBreakpoint>; \/\/optional: yes, type: ID\n OnlineBreakpointActiveVar := <xAvtiveBreakpoint>; \/\/optional: yes, type: ID\n OnlineWatchVars := [<variable1>, <variable2>,...]; \/\/optional: yes\nEND_SEC Les détails concernant la syntaxe des types de définition sont décrits dans la section Déclaration des modules . Spécification: Une seule des définitions Root , Step , Parallel , ou Branch peut être défini sur TRUE pour un module. Selon cette définition, le module est représenté dans l'éditeur de séquence comme l'un des éléments de séquence suivants : Racine: Si la séquence est définie comme Root , l'éditeur de l'instance de module fournit l'onglet supplémentaire Éditeur de séquence . Pour toutes les autres séquences, aucun éditeur de séquence n'est affiché. La largeur de la boîte peut être modifiée dans les options. Étape: Cet élément est similaire au Root élément, mais n'active pas l'onglet supplémentaire Éditeur de séquence . La boîte permet d'afficher et de régler certaines propriétés du module, qui sont définies dans son mse.Sequence section. Parallèle: Une séquence parallèle s'affiche avec un cercle sous la case. La boîte permet d'afficher et de régler certaines propriétés du module, qui sont définies dans son mse.Sequence section. Branche: Un carré incliné sous la case indique une branche. La boîte permet d'afficher et de régler certaines propriétés du module, qui sont définies dans son mse.Sequence section. VisibleParams définit les paramètres disponibles dans la zone d'élément de séquence. VisibleIOs définit les E\/S disponibles dans la zone d'élément de séquence. VisibleRefs définit les références disponibles dans la zone d'élément de séquence. AConnectionColor : Les lignes de connexion entre les instances de module de l'emplacement attribué sont dessinées dans la couleur du Une connexion . Cela peut être défini dans les options de l'éditeur de séquence. BConnectionColor : Les lignes de connexion entre les instances de module de l'emplacement attribué sont dessinées dans la couleur du Connexion B . Cela peut être défini dans les options de l'éditeur de séquence. OnlineActiveVar : Ce paramètre peut être affecté d'une variable booléenne, qui doit être déclarée dans le bloc fonction approprié ou l'un de ses blocs fonction de base. En mode connecté, si la variable est définie sur TRUE , l'étape de la séquence est indiquée en jaune. OnlineBreakpointVar : Ce paramètre peut être affecté d'une variable booléenne, qui doit être déclarée dans le bloc fonction correspondant ou dans l'un de ses blocs fonction de base. En mode en ligne, la commande Basculer le point d'arrêt dans le menu contextuel définit ou réinitialise un point d'arrêt. De plus, il définit la variable affectée à TRUE ou FALSE S'il est réglé sur TRUE , l'étape dans l'éditeur de séquence est affichée avec une bordure rouge. OnlineBreakpointActiveVar : Ce paramètre peut être affecté d'une variable booléenne, qui doit être déclarée dans le bloc fonction correspondant ou dans l'un de ses blocs fonction de base. En mode connecté, si la variable est définie sur TRUE , l'étape de la séquence est indiquée en rouge. OnlineWatchVars : Toutes les variables (avec un type de données simple) qui sont définies sous VAR_INPUT , VAR_OUTPUT , VAR , ou VAR_IN_OUT du FB (ou de ses FB de base) peuvent ici être utilisés comme variables. Types de variables complexes (de la forme FBInst.xVariable etc.) ne peut pas être utilisé. Les variables doivent être saisies dans une liste séparée par des virgules. Exemple SEC mse.Sequence\n Branch;\n VisibleIOs := [xIn];\n AConnectionColor := [itfSequenceTrue];\n BConnectionColor := [itfSequenceFalse];\n OnlineActiveVar := xActive;\n OnlineBreakpointVar := xBreakpoint;\n OnlineBreakpointActiveVar := xBreakpointActive;\n OnlineWatchVars := [iPartTimeElapsed];\nEND_SEC " }, 
{ "title" : "Section : Découplé ", 
"url" : "ac_module_fb_sec_decoupled.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Section : Découplé ", 
"snippet" : "Découplé Cette section définit les \"modules découplés\". Ce sont des modules avec les propriétés des modules de niveau supérieur, mais ils peuvent également être insérés en tant que sous-modules dans des emplacements spécifiques ( Type:= DECOUPLED ) des autres modules. Les modules ne peuvent pas être...", 
"body" : "Découplé Cette section définit les \"modules découplés\". Ce sont des modules avec les propriétés des modules de niveau supérieur, mais ils peuvent également être insérés en tant que sous-modules dans des emplacements spécifiques ( Type:= DECOUPLED ) des autres modules. Les modules ne peuvent pas être \"de niveau supérieur\" et \"découplés\" en même temps. Les \"modules découplés\" sont générés à l'aide de la section Decoupled dans la déclaration du module. La section Decoupled est presque identique à la section Toplevel ; cependant, une seule de ces sections est autorisée dans une déclaration de module. SEC Decoupled \/\/optional: yes, modifier: [UPDATE]\n GVL_Name := <GVL name>; \/\/optional: yes, type: literal\n Default_Application := <default application>; \/\/optional: yes, type: QID\n Default_POUPool := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n Toplevel_Insertable := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n SEC Standard_Task : <task name> \/\/optional: yes, modifier: [HIDE,UPDATE]\n Name := <task name>; \/\/optional: no, type: ID\n Desc := <task description>; \/\/optional: no, type: Text)\n Flags:= <flag>; \/\/optional: no, type: StdTaskFlags)\n END_SEC\n SEC Custom_Task : <task name> \/\/optional: yes, modifier: [UPDATE]\n Priority := <priority>; \/\/optional: no, type: Subrange(0 .. 31)\n Interval := <interval>; \/\/optional: no, type: TimeLiteral)\n Flags:= <flag>; \/\/optional: no, type: CustomTaskFlags)\n END_SEC\nEND_SEC Les détails concernant la syntaxe des types de définition sont décrits dans le chapitre sur la déclaration de module. Spécification : la spécification de la section Decoupled correspond à la description de la rubrique Toplevel . De plus, les paramètres suivants peuvent être définis : Toplevel_Insertable définit si un \"sous-module découplé\" peut également être inséré au niveau supérieur comme un module de niveau supérieur. Remarque : Un \"module découplé\" doit définir et implémenter un proxy respectif. Le proxy doit implémenter la même interface que le \"module découplé\". Si l'instance de module parent se trouve sous un autre contrôleur en tant qu'instance de module \"découplée\", l'instance de module \"découplée\" peut toujours être insérée dans cet emplacement via son proxy. Voir également Déclaration des modules Section : Niveau supérieur " }, 
{ "title" : "Section : MacroModule ", 
"url" : "ac_module_fb_sec_macromodule.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Section : MacroModule ", 
"snippet" : "MacroModule Cette section décrit les paramètres du MacroModule. La section est créée automatiquement lorsque vous générez un module de macro. Comme alternative, vous pouvez insérer manuellement la section dans une déclaration de module ou modifier une section générée automatiquement. SEC MacroModule...", 
"body" : "MacroModule Cette section décrit les paramètres du MacroModule. La section est créée automatiquement lorsque vous générez un module de macro. Comme alternative, vous pouvez insérer manuellement la section dans une déclaration de module ou modifier une section générée automatiquement. SEC MacroModule \/\/optional: yes, modifier: None\n SEC Rootmodule : <identifier> \/\/optional: no, modifier: None\n SEC MacroParameter : <identifier> \/\/optional: yes, modifier: None\n Local_ParameterID := <parameter ID>; \/\/optional: no, type: ID\n New_Name := <parameter name>; \/\/optional: no, type: text\n New_Desc := <parameter description>; \/\/optional: no, type: text\n END_SEC\n SEC MacroIO : <identifier> \/\/optional: yes, modifier: None\n Local_IOID := <IO ID>; \/\/optional: no, type: ID\n New_Name := <IO name>; \/\/optional: yes, type: text\n New_Desc := <IO description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroSlot : <identifier> \/\/optional: yes, modifier: None\n Local_SlotID := <slot ID>; \/\/optional: no, type: ID\n New_Role := <role name>; \/\/optional: yes, type: text\n END_SEC\n SEC Default_Allocation \/\/optional: no, modifier: None\n Module_Name := <module name>; \/\/optional: no, type: QID\n SEC VisuEmbeddings \/\/optional: yes, modifier: None\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <identifier> \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: no, type: ID\n ProxyVisuName := <proxy visu ID>; \/\/optional: no, type: ID\n Target := <target ID>; \/\/optional: yes, type: ID\n LinkId := <linke ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: yes, type: ID\n TopLevelTab := <top level tab>; \/\/optional: yes, type: ID\/Bool\n END_SEC\n SEC IOMappings : <identifier> \/\/optional: no, modifier: None\n SEC Mapping : <identifier> \/\/optional: yes, modifier: None\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, type: ID\/ST expression\n ModuleConnection := <module connection>; \/\/optional: yes, type: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters : <identifier> \/\/optional: yes, modifier: None\n SEC Param : <identifier> \/\/optional: yes, modifier: None\n Value := <value ID>; \/\/optional: no, type: ID\n END_SEC\n END_SEC\n END_SEC\n END_SEC\n SEC Submodule : <identifier> \/\/optional: yes, modifier: None\n Parent_Instance := <instance ID>; \/\/optional: no, type: ID\n Parent_Slot := <slot ID>; \/\/optional: no, type: ID\n SEC MacroParameter : <identifier> \/\/optional: yes, modifier: None\n Local_ParameterID := <parameter ID>; \/\/optional: no, type: ID\n New_Name := <parameter name>; \/\/optional: yes, type: text\n New_Desc := <parameter description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroIO : <identifier> \/\/optional: yes, modifier: None\n Local_IOID := <IO Id>; \/\/optional: no, type: ID\n New_Name := <IO name>; \/\/optional: yes, type: text\n New_Desc := <IO description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroSlot : <identifier> \/\/optional: yes, modifier: None\n Local_SlotID := <slot ID>; \/\/optional: no, type: ID\n New_Role := <role name>; \/\/optional: yes, type: text\n END_SEC\n SEC Default_Allocation \/\/optional: no, modifier: None\n Module_Name := <module name>; \/\/optional: no, type: QID\n Instance_Name := <instance name>; \/\/optional: no, type: ID\n SEC VisuEmbeddings \/\/optional: no, modifier: None\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <identifier> \/\/optional: yes, modifier: None\n VisuName := <visu ID> \/\/optional: no, type: ID\n ProxyVisuName := <proxy visu ID> \/\/optional: no, type: ID\n Target := <target ID>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: yes, type: ID\n TopLevelTap := <top level tab>; \/\/optional: yes, type: ID\/Bool\n END_SEC\n SEC IOMappings : <identifier> \/\/optional: yes, modifier: None\n SEC Mapping : <identifier> \/\/optional: yes, modifier: None\n NoMapping := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression> \/\/optional: yes, type: ID\/ST expression\n ModuleConnection := <module connection> \/\/optional: yes, type: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier: None\n SEC Param : <identifier> \/\/optional: yes, modifier: None\n Value := <value>; \/\/optional: no, type: ID\n END_SEC\n END_SEC\n END_SEC\n END_SEC\n SEC Reference : <identifier> \/\/optional: yes, modifier: None\n Parent_Instance := <instance ID>; \/\/optional: no, type: ID\n Parent_Slot := <slot ID>; \/\/optional: no, type: ID\n Referenced_Instance := <instance ID>; \/\/optional: no, type: ID\n END_SEC\nEND_SEC Les détails concernant la syntaxe des types de définition sont décrits dans la section Déclaration des modules . Spécification: MacroModule : Si cette section est définie, aucune autre section n'est autorisée à apparaître dans l'ensemble de la déclaration du module, à l'exception de la section MetaData . Chaque déclaration de module avec cette section est clairement identifiée comme type MacroModule. Une autre rubrique MacroModule n'est pas autorisé dans une déclaration de module. Rootmodule : Indique que les sous-sections suivantes décrivent le sous-module racine, qui doit être 1) la racine de ce type MacroModule et 2) inséré en tant que parent supérieur de tous les autres sous-modules du type MacroModule. Submodule : Indique que les sous-sections suivantes décrivent un sous-module, qui doit être inséré sous le sous-module racine dans une sous-arborescence pour le type MacroModule. MacroParameter : Si ce type de sous-section est utilisé dans une section Submodule ou Root , on peut alors indiquer qu'un paramètre spécifique du sous-module défini (ou racine) doit lui-même apparaître en tant que paramètre du module macro. Pour cela, la cible de la section MacroParameter est utilisé comme nouvel ID de paramètre pour le paramètre de module de macro. Le paramètre du sous-module donné (ou racine) est alors défini par Local_ParameterID . De plus, des entrées de liste de textes peuvent être créées à l'aide des définitions de New_Name et New_Desc . Ces entrées sont utilisées pour le nom et la description du nouveau paramètre de module de macro au lieu de celui du sous-module ou du paramètre racine. Toutes les cibles définies de toutes les sections MacroParameter dans un module de macro entier doit être clair pour garantir des ID de paramètres uniques pour tous les paramètres de module de macro. MacroIO : Si ce type de sous-section est utilisé dans la section Submodule ou Root , on peut alors indiquer qu'une E\/S spécifique du sous-module défini (ou racine) doit elle-même apparaître comme une E\/S du module macro. Pour cela, la cible de la section MacroIO est utilisé comme nouvel ID d'E\/S pour les E\/S du module macro. L'E \/ S du sous-module (ou racine) donné est alors défini par Local_IOID . De plus, des entrées de liste de textes peuvent être créées à l'aide des définitions de New_Name et New_Desc . Ces entrées sont utilisées pour le nom et la description de la nouvelle E\/S du module macro au lieu du sous-module ou de l'E\/S racine. Toutes les cibles définies de toutes les sections MacroIO dans un module macro entier doit être clair pour garantir des ID d'E\/S uniques pour toutes les E\/S du module macro. MacroSlot : Si cette sous-section est utilisée dans la section Submodule ou Root , on peut alors indiquer qu'un emplacement spécifique du sous-module défini (ou racine) doit lui-même apparaître comme un emplacement du macro-module. De cette manière, des instances de module supplémentaires peuvent être insérées sous cet emplacement de l'instance de MacroModule. Pour cela, la cible de la section MacroSlot est utilisé comme nouvel ID d'emplacement pour l'emplacement du module macro. L'emplacement du sous-module donné (ou racine) est alors défini par Local_SlotID . De plus, une entrée de liste de textes peut être créée à l'aide des définitions New_Role . Cette entrée est utilisée pour le rôle du nouvel emplacement de module macro au lieu de celui du sous-module ou de l'emplacement racine. Toutes les cibles définies de toutes les sections MacroSlot à l'intérieur d'un MacroModule entier doit être clair pour garantir des ID d'emplacement uniques pour tous les emplacements de MacroModule. Parent_Instance : Définit un ID correspondant à un ID cible d'une section Rootmodule ou Submodule de la section englobante MacroModule . Cette définition n'existe que dans la section Submodule . Il définit l'instance du module parent sous laquelle le sous-module doit être inséré. Ce sous-module est décrit par la section correspondante Submodule du MacroModule. De plus, la définition Parent_Slot est également requis. Parent_Slot : Définit un ID correspondant à l'ID d'emplacement situé sous le type de sous-module identifié par Parent_Module . Le sous-module de type MacroModule décrit par la section Submodule est inséré sous cette fente. Default_Allocation : Ceci est identique à la section du même nom sous les déclarations d'emplacement ( Slot et Slot_Multi ). Cette section définit à la fois pour le \"module racine\" et le \"sous-module\" quel type de sous-module de type MacroModule doit être inséré pour quelle configuration d'instance. La seule différence est que non Instance_Name peut être défini pour Default_Allocation sous une rubrique Rootmodule , mais plutôt sous les rubriques Submodule . La raison en est que les instances de module insérées en tant que \"module racine\" reçoivent leur nom de l'instance MacroModule et ne peuvent donc pas être saisies par \"défaut\". Reference : Indique que les sous-sections suivantes décrivent une référence de module. Une référence est générée sous l'instance du module Parent_Instance et la fente Parent_Slot , faisant référence au sous-module Referenced_Instance . Comme le Parent_Instance , cette instance référencée doit provenir de l'ensemble du sous-module d'instances de module racine sous la même section MacroModule . La déclaration de module d'un type MacroModule doit satisfaire les conditions suivantes : Il ne doit pas utiliser IMPLEMENTED_BY ou IMPORTS dans sa déclaration de module. Il doit inclure la section MetaData et MacroModule . Sinon, les sections supplémentaires ne doivent pas être utilisées. Il doit y avoir au moins un Rootmodule rubrique sous le Macro_Module section. De plus, il ne doit pas y avoir une seconde Rootmodule section. Pour chaque submodule , à la fois le Parent_Instance et le Parent_Slot doit être défini dans MacroModule . Celle-ci doit alors être définie comme Local_SlotID dans MacroSlot du Parent_Instance . " }, 
{ "title" : "Section : Générateur d'appareils ", 
"url" : "ac_module_fb_sec_devicegenerator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Section : Générateur d'appareils ", 
"snippet" : "Générateur d'appareils La section DeviceGenerator sert à définir tous les paramètres liés au Device Generator. Il contient les sous-sections suivantes : Sous-section : Device : Définitions pour ajouter des appareils à l'arborescence des appareils Sous-section : Parameter : Définitions pour ajouter o...", 
"body" : "Générateur d'appareils La section DeviceGenerator sert à définir tous les paramètres liés au Device Generator. Il contient les sous-sections suivantes : Sous-section : Device : Définitions pour ajouter des appareils à l'arborescence des appareils Sous-section : Parameter : Définitions pour ajouter ou modifier les paramètres des appareils Sous-section : Connexion : définitions pour connecter le module iOS à l'appareil iOS Sous-section : Wildcards : Définitions permettant de créer des appareils « Wildcard ». Sous-section : Demand : Définitions permettant de définir les propriétés « exigeantes ». Sous-section : InstRefMapping : Définition permettant de connecter les appareils créés avec le module InStrefs. Les détails concernant la syntaxe des types de définition sont décrits dans la section Déclaration des modules . " }, 
{ "title" : "Sous-section : Appareil ", 
"url" : "ac_module_fb_sec_devicegenerator_device.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Section : Générateur d'appareils \/ Sous-section : Appareil ", 
"snippet" : "le Device La sous-section définit les appareils à ajouter par le générateur d'appareils. Il existe plusieurs types d'appareils générés qui sont définis avec les différentes sous-sections Identification , Wildcard , et FlexibleWildcard . Syntaxe: SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE...", 
"body" : "le Device La sous-section définit les appareils à ajouter par le générateur d'appareils. Il existe plusieurs types d'appareils générés qui sont définis avec les différentes sous-sections Identification , Wildcard , et FlexibleWildcard . Syntaxe: SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC Device : <target ID> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n ParentSlotIndex := <slot number>; \/\/optional: yes, type: literal\/integer\n SEC Identification \/\/optional: yes, modifier: [UPDATE]\n Type := <type number>; \/\/optional: no, type: literal\/string\n ID := <ID mumber>; \/\/optional: no, type: literal\/string\n ModuleID := <module ID>; \/\/optional: yes, type: literal\/string\n Version := <version mumber>; \/\/optional: no, type: literal\/string\n SEC SetChildName \/\/optional: yes, modifier: [UPDATE]\n Value := <child name>; \/\/optional: no, type: literal\/string\n ChildIndex := <index number>; \/\/optional: no, type: literal\/string\n END_SEC\n END_SEC\n END_SEC\n SEC ExportDevice \/\/optional: yes, modifier: [UPDATE, HIDE]\n Files :=[<filename1>, <filename2>, ...]; \/\/optional: no, type: string\n END_SEC\nEND_SEC Spécification: le Device section a un ID cible qui l'identifie de manière unique parmi les autres appareils générés d'un module. Cet ID peut être utilisé pour référencer cet appareil. Cela se fait principalement dans la définition Parent d'autres appareils créés ou E\/S connectées. le Parent définition spécifie le périphérique parent souhaité sous lequel le périphérique créé doit être monté. L'appareil parent peut être identifié pas du tout (la définition est facultative), par son ID ou par un paramètre. Dans le détail, l'appareil parent est alors déterminé de la manière suivante : Sinon Parent est défini, le premier parent disponible correspondant est toujours utilisé, et pour un vide Parent la définition recherche uniquement à partir du premier module parent. Si aucun périphérique n'est défini dans le module parent direct lui-même, l'historique des modules parents est suivi jusqu'à ce qu'il y ait finalement un périphérique qui corresponde ou que le module de niveau supérieur soit atteint. Dans ce cas, son dispositif d'application est alors utilisé si possible. Si, en plus, un ID d'appareil ou un paramètre est spécifié comme Parent , l'historique des appareils parents est scanné de la même manière, les appareils du module de sortie lui-même étant désormais également pris en compte et un éventuel appareil parent doit également avoir l'ID correspondant. Si, selon les règles décrites ci-dessus, aucun périphérique parent possible ne peut être trouvé, une erreur est émise lors du contrôle de génération. ParentSlotIndex : Spécifie l'index de l'emplacement (numéro) du périphérique parent dans lequel le périphérique est inséré. Ceci est utile lorsqu’un branchement est nécessaire. le Identification La sous-section inclut la description unique d'un appareil à ajouter. Cela crée une référence claire à ce type d'appareil. Les définitions Type , ID , ModuleID , et Version du Identification section identifient de manière unique un type d'appareil d'une version spécifique. Par exemple, un maître EtherCAT a la définition suivante : Type := '64'; ID := '000 0001'; Version := '3.5.1.0'; Si * est défini comme la version, la dernière version de l'appareil est toujours utilisée. Si la ModuleID définition n'est pas utilisée, le système recherche les appareils avec une DeviceIdentification, sinon il recherche les appareils avec une identification de module. Si l'appareil défini n'existe pas dans le référentiel d'appareils, un message d'erreur correspondant est déjà émis pendant le processus d'analyse. Sous-section : SetChildName avec les définitions de Value et ChildIndex Ces options vous permettent de spécifier le nom que doit avoir un périphérique inséré automatiquement. Si le même nom est utilisé plusieurs fois, le nom résultant est rendu unique en ajoutant un trait de soulignement et un chiffre. Value : Nom souhaité de l'appareil ChildIndex : Index du périphérique inséré automatiquement à renommer Cette section offre la possibilité de remplir les champs à l'aide de l'assistant de saisie. Pour cela, placez le curseur en fin de ligne après Identification et appuyez sur Retourner . Ensuite, l'assistant de saisie s'ouvre et propose les canaux disponibles. Après avoir sélectionné un appareil, les paramètres correspondants sont transférés dans la déclaration de module. Veuillez noter que cette fonction n'est disponible que lorsque la fin de la sous-section ( END_SEC ) n'a pas encore été saisi. La définition Des dossiers contient une liste d'appareils qui seront ajoutés au projet. Ces appareils ont été configurés manuellement et exportés vers une bibliothèque. Exemple SEC Device : Buskoppler2\n SEC Identification\n Type := '65';\n ID := '2_044C2C5200110000';\n Version := '*';\n END_SEC\nEND_SEC\nSEC Device : KlemmeDigitalOutput\n Parent := Buskoppler2;\n SEC Wildcard : KlemmeTyp\n Desc := TL.WildDesc;\n END_SEC\n SEC ExportDevices\n Files := [ExtFile.BK5120_1SDO, ExtFile.BK5120_2SDO];\n END_SEC\nEND_SEC Exemple avec paramètres SEC std.DeviceGenerator\n SEC Device : CANopen_Manager\n Parent := CurrentCAN;\n SEC FlexibleIdentification\n Type := '16';\n ID := '181016';\n Version := '*';\n Maximum := 1;\n END_SEC\n END_SEC\nEND_SEC\nSEC std.Parameters\n SEC Param : CurrentCAN\n Name := TL.CurrentCAN_Name;\n Desc := TL.CurrentCAN_Desc;\n VariableType := wSTRING;\n Default := 'CANBus_0';\n END_SEC\nEND_SEC Exemple de définition d'un nom d'appareil SEC std.DeviceGenerator\n\tSEC Device : EcoVario\n\t Parent := CanManager;\n\t\tSEC Identification\n\t\t Type := '18';\n\t\t ID := '1619 0001';\n\t\t Version := '*';\n\t\t SEC SetChildName : ChildDevice\n\t\t\t Value := 'ChildName';\n\t\t\t ChildIndex := 0;\n\t\t END_SEC\n\t END_SEC\n END_SEC\n SEC Parameters : EcoVario\n\t SEC AddParameter : BoolParamAdd\n\t\t ParameterID := '150';\n\t\t ParameterName := 'BoolParam';\n\t \tParameterType := 'std:BOOL';\n\t\t ChildIndex := 0;\n\t END_SEC\n\t SEC SetParameter : BoolParamAdd\n\t\t ParameterID := '150';\n\t\t\tElemPath := '';\n\t\t\tValue := 'TRUE';\n\t\t\tChildIndex := 0;\n\t\tEND_SEC\n\t\tSEC SetParameter : bVirtual\n\t\t\tParameterID := '1040';\n\t\t\tElemPath := '';\n\t\t\tConnectorID := '0';\n\t\t\tValue := 'TRUE';\n\t\t\tChildIndex := 0;\n\t\tEND_SEC\n\tEND_SEC\n SEC InstRefMapping : Axis\n\t SEC Demand\n\t Desc := TL.DescAxis;\n\t\t\tProperties := [SM_DRIVE_CAN];\n\t\tEND_SEC\n\tEND_SEC\nEND_SEC\n " }, 
{ "title" : "Sous-section : Se connecter ", 
"url" : "ac_module_fb_sec_devicegenerator_connect.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Section : Générateur d'appareils \/ Sous-section : Se connecter ", 
"snippet" : "Cette sous-section de la section IOMapping sert à connecter les E\/S du module avec les E\/S de l'appareil spécifié. Ce mappage est effectué sans connaître la structure IO exacte de l'appareil. Pour les connexions directes, on suppose que le module IO et l'appareil spécifié IO sont compatibles SEC Dev...", 
"body" : "Cette sous-section de la section IOMapping sert à connecter les E\/S du module avec les E\/S de l'appareil spécifié. Ce mappage est effectué sans connaître la structure IO exacte de l'appareil. Pour les connexions directes, on suppose que le module IO et l'appareil spécifié IO sont compatibles SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC IOMapping : <mapping identifier> \/\/optional: yes, modifier: [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Connect \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ElemPath := <elempath name>; \/\/optional: no, type: literal\/string\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n END_SEC\n END_SEC\nEND_SEC Spécification: La section IO a une cible qui correspond à l'ID cible du module IO qui sera connecté. Le module qui contient la connexion de périphérique spécifiée sera recherché pour cet ID cible. Si aucun module IO correspondant ne peut être trouvé, un message d'erreur est émis pendant la scrutation. La définition facultative Parent donne l'ID de l'appareil qui sera recherché pour l'IO d'appareil spécifié (ParameterID). Jusqu'à ce qu'il soit trouvé, le module de l'appareil et l'historique des appareils parents seront recherchés consécutivement. Si un appareil approprié est introuvable, un message d'erreur est émis lors du contrôle de génération. La section Connect contient toutes les définitions nécessaires pour connecter un module IO à un périphérique IO. ParameterID définit le canal IO ParameterID de l'appareil qui sera connecté. Une tentative est faite pour trouver ce paramètre dans les dispositifs spécifiés par le module lui-même. Si aucun périphérique n'est spécifié, une tentative est effectuée pour trouver le paramètre dans le prochain périphérique parent possible. Ensuite, le paramètre est connecté aux E\/S du module. Si aucun des appareils générés dans la hiérarchie des modules n'offre le paramètre spécifié avec ce ParameterID , une erreur est émise. ElemPath définit le sous-élément du paramètre de l'appareil (canal d'E\/S) qui sera connecté aux E\/S du module. Il est également possible de spécifier des chemins, etc. Le paramètre ConnectorID définit éventuellement le connecteur de l'appareil, dont HostParameterSet contient le ParameterID . Sinon ConnectorID est spécifié, le ParameterID est recherché sous le DeviceParameterSet . Cette section offre la possibilité de remplir les champs à l'aide de l'assistant de saisie. Pour cela, placez le curseur en fin de ligne après Connect et appuyez sur Retourner . Ensuite, l'assistant de saisie s'ouvre et propose les canaux disponibles. Après avoir choisi un canal, les paramètres correspondants sont transférés dans la déclaration de module. Veuillez noter que cette fonction n'est disponible que lorsque la fin de la sous-section ( END_SEC ) n'a pas encore été saisi. Exemple SEC IOMapping: xIn\n SEC Connect\n ParameterID := '33554434';\n ElemPath := '';\n ConnectorID := '1';\n END_SEC\nEND_SEC " }, 
{ "title" : "Sous-section : Demande ", 
"url" : "ac_module_fb_sec_devicegenerator_demand.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Section : Générateur d'appareils \/ Sous-section : Demande ", 
"snippet" : "Cette sous-section de IOMapping permet aux E\/S du module de spécifier les propriétés (exemple : 24 V et non 230 V), qui doivent être proposées par les E\/S de l'appareil pour une connexion correcte. Les propriétés demandées peuvent être affectées en tant que propriétés \"d'offre\" aux périphériques IO ...", 
"body" : "Cette sous-section de IOMapping permet aux E\/S du module de spécifier les propriétés (exemple : 24 V et non 230 V), qui doivent être proposées par les E\/S de l'appareil pour une connexion correcte. Les propriétés demandées peuvent être affectées en tant que propriétés \"d'offre\" aux périphériques IO lors de la génération. L'affectation est stockée attachée au fichier de description de l'appareil. Pour la connexion IO automatique du générateur d'appareils, cela signifie que chaque module IO avec des propriétés \"exigeantes\" analysera les appareils générés ou les caractères génériques de ses modules parents jusqu'à ce qu'un appareil et un canal IO soient trouvés, dont les propriétés \"d'offre\" répondent aux demandes SEC IOMapping : <target> \/\/optional: yes, modifier: [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Demand \/\/optional: yes, modifier: [UPDATE]\n Desc := <description>; \/\/optional: no, type: text\n Properties := [<property1>,<property2>,...]; \/\/optional: no, type: IDList\n END_SEC\nEND_SEC Spécification: Les sous-sections Demand et Connect ne peuvent pas être définis simultanément. Desc définit une description (localisée) de la connexion requise (dans une liste de textes). Properties définit une liste de propriétés qui décrivent les propriétés requises par le module IO (exemple : [Input24V, Digital]) Il est possible de définir plusieurs propriétés qui permettent de qualifier les IO du module (exemple : module IOs qui ne nécessitaient que \"Property1\" et module IOs qui nécessitaient \"Property1\", \"Property2\", etc.). Parent définit l'Id de l'appareil sous lequel le canal doit être connecté. Pour les E\/S « exigeantes », les périphériques génériques sont également autorisés en tant que périphériques de connexion possibles. SEC std.DeviceGenerator\n SEC IOMapping : xOn\n SEC Demand\n Desc := TL_Rooms.Role_RoomStandard_Lights;\n Properties := [V24Output];\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "Sous-section : Caractères génériques ", 
"url" : "ac_module_fb_sec_devicegenerator_wildcard.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Section : Générateur d'appareils \/ Sous-section : Caractères génériques ", 
"snippet" : "le Wildcard La sous-section est utilisée pour créer des périphériques génériques pour les modules qui ne sont pas encore connus lors de la création du module. Les dispositifs doivent alors être flexibles pour être spécifiés par l'utilisateur avant ou pendant la génération. SEC Device : <target> \/\/op...", 
"body" : "le Wildcard La sous-section est utilisée pour créer des périphériques génériques pour les modules qui ne sont pas encore connus lors de la création du module. Les dispositifs doivent alors être flexibles pour être spécifiés par l'utilisateur avant ou pendant la génération. SEC Device : <target> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Wildcard : <target> \/\/optional: yes, modifier: [UPDATE]\n Desc := <description>; \/\/optional: no, type: text\n END_SEC\nEND_SEC Spécification: le Identification , Wildcard , et FlexibleWildcard les sous-sections ne peuvent pas être utilisées en même temps. La cible de la section Wildcard détermine le type du périphérique générique. Différents modules peuvent utiliser des périphériques génériques du même type (exemple : \"8 entrées\"). Tous les périphériques génériques du même type sont affectés au même périphérique. Desc définit une description (localisée) du périphérique générique (dans une liste de texte). Parent définit le périphérique parent souhaité. Les appareils génériques sont également possibles ici, à condition qu'ils soient déjà affectés à des appareils. Si le périphérique défini pour le périphérique générique n'est pas un périphérique parent compatible, une erreur est émise lors de la génération. Exemple SEC Device : KlemmeAnalogOutput\n Parent := Buskoppler2;\n SEC Wildcard : KlemmeTyp\n Desc := TL.WildDesc;\n END_SEC\nEND_SEC " }, 
{ "title" : "Sous-section : Paramètre ", 
"url" : "ac_module_fb_sec_devicegenerator_parameter.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Section : Générateur d'appareils \/ Sous-section : Paramètre ", 
"snippet" : "La section Parameter avec les sous-sections SetParameter et AddParameter sert à ajouter ou à modifier des paramètres d'appareils. Cela permet de générer des paramètres spécifiques des appareils (exemple : temps de cycle). SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC Parameters : <para...", 
"body" : "La section Parameter avec les sous-sections SetParameter et AddParameter sert à ajouter ou à modifier des paramètres d'appareils. Cela permet de générer des paramètres spécifiques des appareils (exemple : temps de cycle). SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC Parameters : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n SEC SetParameter : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ElemPath := <elempath name>; \/\/optional: no, type: literal\/string\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n Value := <value name>; \/\/optional: no, type: literal\/string\n ChildIndex := <device ID>;\n Download := <boolean value> \/\/ opional: yes, type: boolean\n END_SEC\n SEC AddParameter : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ParameterName := <parameter name>; \/\/optional: no, type: literal\/string\n ParameterType := <parameter type>; \/\/optional: no, type: literal\/string\n ChannelType := <channel type>; \/\/optional: yes, type: enum\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n ChildIndex := <device ID>;\n END_SEC\n END_SEC\nEND_SEC Spécification: La cible de la section Parameters définit l'Id de l'équipement cible généré, dont le paramètre doit être modifié. L'appareil cible sera d'abord recherché dans les appareils du module puis dans leur historique parent. Des périphériques génériques ou d'autres périphériques sont également possibles. On suppose que ces appareils ont le paramètre correspondant ou que le paramètre correspondant peut être ajouté. Si l'analyse ne parvient pas à trouver l'appareil cible, un avertissement s'affiche. Les cibles des sections SetParameter et AddParameter définissent l'ID de la section respective mais n'ont plus d'utilité. Spécification pour la section SetParameter : ParameterID définit la ParameterID du paramètre de l'appareil qui sera modifié. ElemPath spécifie l'élément exact du paramètre qui sera modifié. Le paramètre ConnectorID définit éventuellement le connecteur de l'équipement, dont HostParemeterSet contient le paramètre Id. Sinon ConnectorID est spécifié, le ParameterID est recherché sous DeviceParameterSet. Value définit la valeur qui sera affectée à l'élément du paramètre spécifié. Cette valeur doit être compatible avec le type d'élément. La valeur peut être une expression par exemple [paramID] + 2*MODULE_SLOT_INDEX Là [paramID] définit un ID cible d'un paramètre, de sorte que [paramID] sera remplacé par la valeur du paramètre. le MODULE_SLOT_INDEX mot-clé est remplacé par l'index d'emplacement qu'une instance de module du type de module défini aurait après l'insertion. Si le paramètre est introuvable dans l'appareil cible, la vérification du générateur créera des avertissements. ChildIndex définit le périphérique subordonné sous lequel le paramètre est ajouté ou défini. Si ce périphérique subordonné avec l'index spécifique n'existe pas, alors un avertissement est généré lors de la génération. Download : Entrée facultative. Si cette entrée a la valeur FALSE , le paramètre ne sera pas téléchargé sur l'appareil. Il est judicieux d'utiliser, par exemple, pour désactiver CheckVendorId pour les appareils CAN, par exemple. Spécification pour la section AddParameter : ParameterID définit le nouvel ID du paramètre à ajouter. Celui-ci doit être unique parmi les autres ID de paramètre de l'appareil cible. Le paramètre ConnectorID définit éventuellement le connecteur de l'équipement, dont HostParemeterSet contient le paramètre Id à ajouter. Si aucun ID de connecteur n'est défini, l'ID de paramètre sera ajouté dans DeviceParameterSet. ParameterName définit le nom du paramètre ajouté à l'équipement cible. ParameterType définit le type de paramètre ajouté à l'équipement cible. Ce type est nommé selon la notation de type CEI avec préfixe de type. Donc exemple : std:bool créera un paramètre booléen. Si le paramètre ne peut pas être ajouté, la vérification du générateur créera des avertissements. ChannelType définit le type de canal. Les valeurs possibles sont NONE , INPUT , OUTPUT , et OUTPUTREADONLY . ChildIndex définit le périphérique subordonné sous lequel le paramètre est ajouté ou défini. Si ce périphérique subordonné avec l'index spécifique n'existe pas, alors un avertissement est généré lors de la génération. Les deux sections AddParameter et SetParameter peuvent être utilisés ensemble pour ajouter un paramètre à un appareil et lui attribuer une valeur en même temps. Exemple SEC Parameters : Buskoppler1\n SEC AddParameter : ExpertSettings\n ParameterID := '805306368';\n ConnectorID := '1';\n ParameterName := 'ExpertSettings';\n ParameterType := 'std:int';\n ChannelType := OUTPUT;\n END_SEC\n SEC SetParameter : ExpertSettings\n ParameterID := '805306368';\n ElemPath := '';\n ConnectorID := '1';\n Value := dwParameterOffset + 2 * MODULE_SLOT_INDEX;\n END_SEC\n END_SEC " }, 
{ "title" : "Sous-section : InstRefMapping ", 
"url" : "ac_module_fb_sec_devicegenerator_instrefmapping.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Section : Générateur d'appareils \/ Sous-section : InstRefMapping ", 
"snippet" : "Dans la rubrique InstRefMapping avec la sous-section Demand un module InstRef peut être rempli automatiquement avec une instance FB créée par un appareil. SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC InstRefMapping : <target ID> \/\/optional: yes, modifier [UPDATE] Parent := <target ID>...", 
"body" : "Dans la rubrique InstRefMapping avec la sous-section Demand un module InstRef peut être rempli automatiquement avec une instance FB créée par un appareil. SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC InstRefMapping : <target ID> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Demand \/\/optional: yes, modifier: [UPDATE]\n Desc := <...>; \/\/optional: no, type: text\n Properties := <...>; \/\/optional: no, type: IDList\n END_SEC\n END_SEC\nEND_SEC Spécification: La partie supérieure InstRefMapping est complétée par une section facultative supplémentaire Demand . La cible de la section supérieure InstRefMapping définit l'ID d'un module InstRef, qui sera rempli avec l'instance FB. Seuls les InstRefs uniques (pas InstRef_Multi) sont pris en charge, car seules des instances FB uniques d'appareils uniques peuvent être créées. Desc définit une description localisée de la connexion. Properties définit une liste de propriétés qui décrivent, par exemple, les types de FB requis par le module InstRef. Plus que sur la propriété peut être défini afin que les InstRefs du module unique soient classés comme avec les E\/S du module. Syntaxe [<Property1>, <Property2>,...] (Exemple: [SoftMotionVirtualDrive, Property2] ). Parent définit l'ID de l'appareil requis, dont l'instance FB créée doit être utilisée pour remplir le module InstRefs. Pour les InstRefs exigeants, les périphériques génériques ainsi que les périphériques insérés fixes sont autorisés. Exemple SEC std.InstRefs\n SEC InstRef : axisRef\n Variable := axis_ref;\n Desc := TL.axisref_Desc ;\n END_SEC\nEND_SEC\n\nSEC std.DeviceGenerator\n SEC Device : virtAxis\n SEC Identification\n Type := '1024';\n ID := 'FFFF 0001';\n Version := '*';\n END_SEC\n END_SEC\n SEC InstRefMapping : axisRef\n SEC Demand\n Desc := TL.axisref_Desc;\n Properties := [VirtualAxis];\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "Règles pour les générateurs ", 
"url" : "ac_module_fb_sec_devicegenerator_generating_rules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Section : Générateur d'appareils \/ Règles pour les générateurs ", 
"snippet" : "Règles de génération d'appareils Les appareils spécifiés dans les modules de niveau supérieur sont accrochés sous l'appareil parent qui contient l'application générée. Aucun appareil de niveau supérieur ne sera créé. Si aucun ID de périphérique parent n'est spécifié, le périphérique parent correspon...", 
"body" : "Règles de génération d'appareils Les appareils spécifiés dans les modules de niveau supérieur sont accrochés sous l'appareil parent qui contient l'application générée. Aucun appareil de niveau supérieur ne sera créé. Si aucun ID de périphérique parent n'est spécifié, le périphérique parent correspondant le plus récent est utilisé comme nouvel objet parent. Cela signifie que si un module enfant génère un périphérique, ce périphérique sera ajouté si possible sous l'un des périphériques générés du module parent. Si le module parent direct n'a aucun périphérique ou ne génère pas de périphérique qui s'insère sous le périphérique enfant, les périphériques du module parent-parent sont utilisés, et ainsi de suite. S'il n'y a plus de périphériques parents générés, une tentative de génération est effectuée dans le périphérique de niveau supérieur du module de niveau supérieur correspondant. Si plusieurs appareils sont proposés à partir d'un objet module parent, le premier appareil compatible sera utilisé. Voir également: Sous-section : Appareil Le nom de l'appareil généré est \"ID de l'appareil + nom du module + appareil\". Si ce nom est déjà utilisé par un appareil, un numéro croissant sera ajouté. Les appareils déjà créés ne seront pas supprimés par une exécution de nouvelle génération ; par conséquent, les ajustements manuels des paramètres seront conservés. Les paramètres supplémentaires ou modifiés créés par la déclaration du module seront affectés aux appareils correspondants à chaque génération. Comme tous les objets créés par Application Composer, les périphériques supplémentaires seront marqués dans l'arborescence des périphériques. En cas de tentative de modification ou de suppression d'un tel appareil, un avertissement s'affiche. Cet avertissement attire l'attention sur le fait que toute modification apportée aux paramètres de l'appareil peut être perdue si, par exemple, la structure du module est régénérée après avoir été modifiée. Règles supplémentaires pour la génération d'appareils Les appareils enfants, qui sont automatiquement ajoutés sous certains appareils, sont classés sous la même instance de module que leur parent. Cela signifie que ces périphériques enfants sont traités comme s'ils étaient définis dans la déclaration du module, qui contient en effet la définition de leur périphérique parent. Les appareils enfants ne sont pas créés ou supprimés indépendamment, mais sont uniquement traités avec leurs appareils parents. Si un appareil apporte des connecteurs explicites, lors des vérifications de compatibilité avec d'autres appareils, ces derniers sont traités comme s'il s'agissait de connecteurs implicites. En d'autres termes, tous les connecteurs sont utilisés pour tester la compatibilité avec d'autres périphériques, de sorte que finalement seul ce connecteur (qu'il soit explicite ou implicite) est utilisé, ce qui correspond au périphérique parent et au périphérique enfant (explicitement en tant qu'objet parent du connecteur, implicitement dans le cadre de l'objet parent du périphérique). " }, 
{ "title" : "Générateur d'alarme ", 
"url" : "ac_alarmgenerator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Générateur d'alarme ", 
"snippet" : "Le générateur d'alarmes offre au développeur du module un moyen simple d'équiper les modules existants de la gestion des alarmes disponible dans CODESYS . Ce faisant, des fonctionnalités pour la gestion complète des alarmes, ainsi qu'une visualisation correspondante, sont générées. La nouvelle décla...", 
"body" : "Le générateur d'alarmes offre au développeur du module un moyen simple d'équiper les modules existants de la gestion des alarmes disponible dans CODESYS . Ce faisant, des fonctionnalités pour la gestion complète des alarmes, ainsi qu'une visualisation correspondante, sont générées. La nouvelle déclaration de module ( Section alg. Alarme ) implémente cette fonctionnalité. Toutes les définitions nécessaires à la gestion des alarmes y sont définies. Création de la visualisation En même temps que la génération d'alarmes, un écran de visualisation d'alarmes est créé, qui est une suggestion pour une visualisation d'ensemble (tableau d'alarmes) des alarmes dans le projet. Le modèle de cette visualisation est défini dans les paramètres du générateur d'alarmes. Si le générateur de visualisation est actif, l'objet de visualisation créé ou réutilisé est intégré en tant qu'onglet dans la visualisation de niveau supérieur. " }, 
{ "title" : "Génération d'alarme ", 
"url" : "ac_alarmgenerator.html#UUID-dd47c9b0-4cb3-6491-d721-bbb6aed14278_a4ecc0cda058afc0a8640e004fda36_id_4e1d8099cdf16f9cc0a8640e0073d212", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Générateur d'alarme \/ Génération d'alarme ", 
"snippet" : "Comme tous les générateurs du CODESYS Application Composer , ce générateur peut être activé ou désactivé dans le Configuration du générateur . Le générateur effectue les étapes suivantes : Un objet de configuration d'alarme est recherché, afin qu'il puisse être utilisé pour la prochaine génération. ...", 
"body" : "Comme tous les générateurs du CODESYS Application Composer , ce générateur peut être activé ou désactivé dans le Configuration du générateur . Le générateur effectue les étapes suivantes : Un objet de configuration d'alarme est recherché, afin qu'il puisse être utilisé pour la prochaine génération. Si aucun objet de configuration d'alarme n'existe, un nouveau est créé. Sous l'objet de configuration d'alarme, un objet de stockage d'alarme est recherché. Si aucun objet de stockage d'alarme n'existe, le modèle de stockage d'alarme est utilisé. Ce modèle est défini dans les paramètres du générateur d'alarmes. Si l'option Pas de stockage est sélectionné, aucun modèle de stockage d'alarme n'est utilisé et le processus se poursuit sans stockage d'alarme. Si plusieurs modèles sont trouvés, un message d'erreur s'affiche. Sous l'objet de configuration d'alarme sont recherchés les objets de classe d'alarme dont le nom est défini dans n'importe quelle description de module sous la définition alg.Alarm.SetAlarm.Class . Si les objets de classe d'alarme correspondants sont trouvés, ils seront utilisés. Si aucune classe d'alarme correspondante n'est trouvée, une tentative est faite pour en créer une nouvelle. Cela nécessite que l'objet de modèle de classe d'alarme de nom correspondant existe en tant que modèle dans le pool de POU du projet ou d'une bibliothèque référencée, afin qu'il puisse être utilisé comme modèle de classe d'alarme. Si aucun objet de modèle de classe d'alarme correspondant n'est disponible, une erreur s'affiche. " }, 
{ "title" : "Section : alg.Alarme ", 
"url" : "ac_module_fb_sec_alarm.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Générateur d'alarme \/ Section : alg.Alarme ", 
"snippet" : "alg.Alarme La section SEC alg.Alarm décrit une alarme de module. Une alarme de module correspond essentiellement à une alarme du CODESYS gestion des alarmes qui a été configurée dans un groupe d'alarmes. Cependant, une alarme de module contient toujours des ajouts spécifiques au module. Pour plus d'...", 
"body" : "alg.Alarme La section SEC alg.Alarm décrit une alarme de module. Une alarme de module correspond essentiellement à une alarme du CODESYS gestion des alarmes qui a été configurée dans un groupe d'alarmes. Cependant, une alarme de module contient toujours des ajouts spécifiques au module. Pour plus d'informations, consultez le Déclaration du module chapitre et Objet : Alarm Group " }, 
{ "title" : "spécification ", 
"url" : "ac_module_fb_sec_alarm.html#UUID-e8936893-7db9-1fda-4737-bf3cf49fe064_aa4c0cec89085aac0a8640e01a3c6fe_id_355d83fb191b4801c0a864637767cb78", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Générateur d'alarme \/ Section : alg.Alarme \/ spécification ", 
"snippet" : "SEC alg.Alarm \/\/optional: yes, modifier: [UPDATE] SEC SetAlarm <alarm identifier> \/\/optional: yes, modifier [UPDATE] Class := <class name>; \/\/optional: no, type: ID Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry LatchVar1 := <LatchVariable1>; \/\/optional: yes, type: InstancePath Latc...", 
"body" : "SEC alg.Alarm \/\/optional: yes, modifier: [UPDATE]\n SEC SetAlarm <alarm identifier> \/\/optional: yes, modifier [UPDATE]\n Class := <class name>; \/\/optional: no, type: ID\n Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry\n LatchVar1 := <LatchVariable1>; \/\/optional: yes, type: InstancePath\n LatchVar2 := <LatchVariable2>; \/\/optional: yes, type: InstancePath\n Deactivation := <DeactivationVariable>; \/\/optional: yes, type: InstancePath\n PendingTime := <PendingTime>; \/\/optional: yes, type: LiteralOrConstant\n PendingTimeParameter := <string> \/\/optional: no, type: literal\/string\n HigherPrioAlarm := <HigherPrioAlarm_ID>; \/\/optional: yes, type: ID\n ModuleCalls := <ModuleCallFlags>; \/\/optional: yes, type: ModuleCallFlag\n SEC Messages : <alarm identifier> \/\/optional: yes, modifier: [UPDATE]\n Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry\n Number := <ColumnNumber>; \/\/optional: no, type: Literal\n END_SEC\n SEC LatchVar <latch var identifier> \/\/optional: yes, modifier [UPDATE]\n LatchVar := <LatchVariable>; \/\/optional: no, type: InstancePath\n Number := <LatchVarNumber> \/\/optional: no, type: LiteralOrConstant\n END_SEC\n SEC UpperLimit \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n IncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n UpperExpression := <UpperExpression>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC LowerLimit \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n IncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n LowerExpression := <LowerExpression>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC InsideRange \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n AreaLow := <AreaLowValue>; \/\/optional: no, type: Literal\/String\n LowIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n HighIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n AreaHigh := <AreaHighValue>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC OutsideRange \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n AreaLow := <AreaLowValue>; \/\/optional: no, type: Literal\/String\n LowIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n HighIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n AreaHigh := <AreaHighValue>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC Digital \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n Equal := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n EqualsExpression := <Expression>; \/\/optional: no, type: Literal\/String\n END_SEC\n SEC Change \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n END_SEC\n SEC Event \/\/optional: yes, modifier: [UPDATE]\n END_SEC\n END_SEC\nEND_SEC SEC SetAlarm Les sous-sections de SetAlarm définir toutes les propriétés nécessaires ou possibles pour une alarme. La cible de SetAlarm identifie l'alarme parmi les autres alarmes du module et sert à la référencer (principalement dans la définition HigherPrioAlarm ). Class Nom de la classe d'alarme sous laquelle l'alarme sera créée. Si cette classe d'alarme existe déjà dans l'application, l'alarme sera créée sous cette classe. Si cette classe n'existe pas, un objet modèle de classe d'alarme est recherché, qui doit être présent dans la POU voir. Si aucun objet de modèle de classe d'alarme approprié n'est trouvé, une erreur est émise lors de l'analyse du module. Message ID (de la forme TextListenName.TextListenEintragID ) d'une entrée de liste de textes pour le texte d'alarme Le message référencé par l'ID peut contenir les mêmes espaces réservés que le texte dans une configuration d'alarme. Par exemple, des espaces réservés tels que LATCH1 ou LATCH2 peut être utilisé Si une entrée de liste de textes spécifiée est introuvable, un avertissement est émis pendant l'analyse. Correspond à la Un message réglage dans le Groupe d'alarme objet. LatchVar1 LatchVar2 Variables d'espace réservé Dans le cas présent d'alarmes spécifiques au module, les variables ne peuvent être spécifiées que directement à partir du bloc fonctionnel du module (tout comme les variables sont spécifiées dans la déclaration du module, par exemple pour les paramètres) Correspond aux paramètres Variable de verrouillage 1 \/ Variable de verrouillage 2 pour les espaces réservés <LATCH1> \/ <LATCH2> dans le Groupe d'alarme objet. Deactivation Variable de désactivation ( BOOL ). TRUE : Désactive l'alarme définie, où seules les variables du bloc fonction du module peuvent être utilisées. Si le type de la variable saisie n'est pas BOOL , une erreur est émise lors de l'analyse Correspond à la Désactivation réglage dans le Groupe d'alarme objet. PendingTime Temps d'attente minimal. Définit la durée avant que l'alarme ne se déclenche après avoir atteint ses limites. Exemple: TIME#5S Correspond au réglage Min. temps d'attente dans le Groupe d'alarme objet. PendingTimeParameter Paramètre pour définir le temps d'attente minimum La valeur attribuée au paramètre est une chaîne qui peut être interprétée comme une heure. Ou aussi comme une expression composée de paramètres de module et de littéraux temporels. Exemple: TIME#5S 'NoVar' 'WithVar' 'WithVar - NoVar + TIME#5S' HigherPrioAlarm ID des alarmes de priorité supérieure Pour identifier l'alarme sous laquelle l'alarme actuelle doit être classée, un ID cible d'un SetAlarm section est spécifiée pour les alarmes de module existantes. Pour trouver le SetAlarm section avec l'ID cible correspondant, une recherche hiérarchique est effectuée à partir du propre module vers le haut dans les instances du module parent pour trouver les ID correspondants parmi les déclarations d'alarme. Si aucune alarme parent correspondante n'est trouvée, une erreur est émise lors de la vérification du générateur Correspond au réglage Priorité plus élevée. alarme dans le Groupe d'alarme objet. ModuleCalls Pour la gestion des alarmes spécifiques au module, les FB de module peuvent offrir des interfaces spécifiques qui peuvent être appelées en cas d'alarme de module. Les drapeaux définissent dans quels cas cela se produira. Disponible ModuleCallFlags : NONE : Aucun appel n'aura lieu THIS : Un appel se produira pour les alarmes du module actuel PARENTS : Un appel se produira à tous les modules parents du module actuel ALL : Un appel se produira à tous les modules Les FB de module qui seront appelés par cet indicateur doivent implémenter le IModuleAlarming interface. L'appel est effectué par le ConsumeModuleAlarm fonction de cette interface Si la PARENTS drapeau a été défini pour un module de niveau supérieur, un avertissement s'affiche si un scan est exécuté (car ce drapeau n'existe pas pour les modules de niveau supérieur). SEC Messages La sous-section gère la même tâche que la Message paramètre, mais autorise plusieurs messages pour une alarme. Pour des raisons de compatibilité, l'(ancien) paramètre Message est toujours valide. Le message peut contenir les mêmes espaces réservés que le texte réel dans une configuration d'alarme. Cela signifie que les espaces réservés tels que <LATCH1> et <LATCH2> peut être utilisé. Si une entrée de liste de textes spécifiée est introuvable, un avertissement est émis pendant l'analyse. Messages : Texte d'alarme sous la forme d'une entrée de liste de textes (de la forme TextListenName.TextListenEintragID ) Number : Colonne du tableau des alarmes où le message est affiché. SEC LatchVar Verrouiller les variables. Jusqu'à 10 variables de verrouillage peuvent être définies dans cette section. Si, en plus de cette rubrique, LatchVar1 ou LatchVar2 est défini, la variable de cette section sera utilisée. LatchVar : variable de verrouillage Number : Numéro pour identifier la variable de verrouillage. SEC UpperLimit SEC LowerLimit Conditions d'alarme pour les alarmes qui se déclenchent si les limites supérieures ou inférieures sont franchies. La section ne peut apparaître qu'une seule fois sous le SEC SetAlarm section. Si ce n'est pas le cas, une erreur est émise lors de l'analyse. Expression : expression ou valeur CEI qui est testée. Dans les expressions, des variables locales des FB du module ainsi que des constantes globales peuvent être utilisées. IncludeBorder : TRUE Correspond à <= ( UpperLimit ) ou >= ( LowerLimit ). FALSE Correspond à < ( UpperLimit ) ou > ( LowerLimit ). UpperExpresssion , LowerExpresssion : expression ou valeur CEI par rapport à laquelle Expression est testé. Dans les expressions, des variables locales des FB du module ainsi que des constantes globales peuvent être utilisées. Hysteresis : Hystérésis d'alarme en %. Correspond aux réglages Limite supérieure \/ Limite inférieure pour les types d'observation dans Groupe d'alarme objet. SEC InsideRange SEC OutsideRange Conditions d'alarme pour les alarmes qui se déclenchent si une expression est à l'intérieur ou à l'extérieur d'une certaine plage de valeurs. La section ne peut apparaître qu'une seule fois sous le SEC SetAlarm section. Si ce n'est pas le cas, une erreur est émise lors de l'analyse. Hysteresis : Hystérésis d'alarme en % Expression : expression ou valeur CEI qui est testée. Dans les expressions, des variables locales des FB du module ainsi que des constantes globales peuvent être utilisées. AreaLow : Limites inférieures de la gamme (valeur ou expression CEI). Dans les expressions, des variables locales des FB du module ainsi que des constantes globales peuvent être utilisées. LowIncludeBorder : Cet indicateur booléen détermine si la limite inférieure elle-même est incluse dans la plage de comparaison (correspond à <= ) HighIncludeBorder : Cet indicateur booléen détermine si la limite supérieure elle-même est incluse dans la plage de comparaison (correspond à >= ) AreaHigh : Bornes hautes de la gamme (valeur ou expression CEI). Dans les expressions, des variables locales des FB du module ainsi que des constantes globales peuvent être utilisées. Correspond aux paramètres À l'intérieur de la plage \/ Hors plage pour les types d'observation dans Groupe d'alarme objet. SEC Digital Alarme déclenchée si deux expressions sont comparées l'une à l'autre. La section ne peut apparaître qu'une seule fois sous le SEC SetAlarm section. Si ce n'est pas le cas, une erreur est émise lors de l'analyse. Expression : expression ou valeur CEI qui est testée. Dans les expressions, des variables locales des FB du module ainsi que des constantes globales peuvent être utilisées. Equal : TRUE \/ FALSE : L'expression sera vérifiée pour l'égalité\/l'inégalité. EqualsExpression : expression ou valeur CEI qui est vérifiée Expression . Dans les expressions, des variables locales des FB du module ainsi que des constantes globales peuvent être utilisées. Correspond au type d'observation Numérique dans le Groupe d'alarme objet. SEC Change Alarme déclenchée si une expression change de valeur. La section ne peut apparaître qu'une seule fois sous le SEC SetAlarm section. Si ce n'est pas le cas, une erreur est émise lors de l'analyse. Expression : expression ou valeur CEI dont les modifications sont vérifiées. Dans les expressions, des variables locales des FB du module ainsi que des constantes globales peuvent être utilisées. Correspond au type d'observation Changement dans le Groupe d'alarme objet. SEC Event Détermine que la section d'alarme actuelle crée une alarme d'événement. Cette alarme peut être déclenchée par la fonction RaiseModuleEvent() du AC_Alarming bibliothèque. " }, 
{ "title" : "Exemple ", 
"url" : "ac_module_fb_sec_alarm.html#UUID-e8936893-7db9-1fda-4737-bf3cf49fe064_aa4c0cec89085aac0a8640e01a3c6fe_id_00a4549e191b4801c0a8646366566922", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Générateur d'alarme \/ Section : alg.Alarme \/ Exemple ", 
"snippet" : "Plage de valeurs SEC SetAlarm : ValueRange Class := Error; Message := TL.Alarm_Temperature; LatchVar1 := rAlarmValueLow; LatchVar2 := rAlarmValueHigh; ModuleCalls := THIS | PARENTS; SEC Messages : msg2 Message := TL.msg5_Message; Number := 5; END_SEC SEC OutsideRange Expression := 'rValue'; AreaLow ...", 
"body" : "Plage de valeurs SEC SetAlarm : ValueRange\n Class := Error;\n Message := TL.Alarm_Temperature;\n LatchVar1 := rAlarmValueLow;\n LatchVar2 := rAlarmValueHigh;\n ModuleCalls := THIS | PARENTS;\n SEC Messages : msg2\n Message := TL.msg5_Message;\n Number := 5;\n END_SEC\n SEC OutsideRange\n Expression := 'rValue';\n AreaLow := 'rAlarmValueLow';\n LowIncludeBorder := TRUE;\n HighIncludeBorder := TRUE;\n AreaHigh := 'rAlarmValueHigh';\n END_SEC\nEND_SEC Section: PendingTime SEC alg.Alarm\n\tSEC SetAlarm : NoVar\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'NoVar';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\n\tSEC SetAlarm : WithVar\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'WithVar';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\n\tSEC SetAlarm : SimpleMath\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'WithVar - NoVar + TIME#5S';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\t\n\tSEC SetAlarm : NoParam\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTime := TIME#5S;\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\nEND_SEC " }, 
{ "title" : "Générateur de CFC ", 
"url" : "ac_cfc_generator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Générateur de CFC ", 
"snippet" : "Le générateur CFC crée automatiquement des programmes CFC qui peuvent contenir des appels d'instances de FB de module. Les programmes CFC créés peuvent être édités. Les changements de programme persistent après des fonctionnements répétés du générateur....", 
"body" : "Le générateur CFC crée automatiquement des programmes CFC qui peuvent contenir des appels d'instances de FB de module. Les programmes CFC créés peuvent être édités. Les changements de programme persistent après des fonctionnements répétés du générateur. " }, 
{ "title" : "Rubrique : CFCCréation ", 
"url" : "ac_module_fb_sec_cfccreation.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Générateur de CFC \/ Rubrique : CFCCréation ", 
"snippet" : "CFCCréation Cette section contient toutes les sous-sections qui sont interprétées par le générateur CFC. SEC cfc.CFCCreation SEC CreateCFCProgram : <CFC program identifier> \/\/optional: yes, modifier [UPDATE] StandardCallTask := <Task type>; \/\/optional: yes, type: ID CustomCallTask := <Task type>; \/\/...", 
"body" : "CFCCréation Cette section contient toutes les sous-sections qui sont interprétées par le générateur CFC. SEC cfc.CFCCreation\n\n SEC CreateCFCProgram : <CFC program identifier> \/\/optional: yes, modifier [UPDATE]\n StandardCallTask := <Task type>; \/\/optional: yes, type: ID\n CustomCallTask := <Task type>; \/\/optional: yes, type: ID\n ParentFolder := <create folder ID; \/\/optional: yes, type: ID\n END_SEC\n\n SEC CreateCFCModuleCall \/\/optional: yes, modifier [UPDATE]\n PreferredCFCProgram := <CFC program> \/\/optional: yes; type: FB type\n END_SEC\n\n SEC CreateCFCIOCall : <CFC IO call ID> \/\/ optional: yes; modifier [UPDATE]\n FB := <FB name>; \/\/ optional: no; type: FB type\n PreferredCFCProgram := <CFC program> \/\/ optional: yes; type: FB type\n FBInstanceBaseName := AInput; \/\/ optional: yes; type: identifier\n END_SEC\n\n SEC CreateFolder : <folder ID> \/\/optional: yes, modifier [UPDATE]\n ParentFolder := <folder name>; \/\/optional: yes, type: ID\n END_SEC\n\nEND_SEC Les détails concernant la syntaxe des types de définition sont décrits dans la section Déclaration des modules . " }, 
{ "title" : "Sous-section : Créer un programme CFC ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_bddcc1eb1403f77cc0a8640e01907eda", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Générateur de CFC \/ Rubrique : CFCCréation \/ Sous-section : Créer un programme CFC ", 
"snippet" : "Si une déclaration de module contient une section cfc.CFCCreation y compris la sous-section CreateCFCProgram , un programme CFC est créé pour le type de module affecté. Le programme CFC sera inséré sous l'application cible de l'instance de module parent de niveau supérieur\/découplé immédiatement sup...", 
"body" : "Si une déclaration de module contient une section cfc.CFCCreation y compris la sous-section CreateCFCProgram , un programme CFC est créé pour le type de module affecté. Le programme CFC sera inséré sous l'application cible de l'instance de module parent de niveau supérieur\/découplé immédiatement supérieur. La définition CustomCallTask ou StandardCallTask permet de définir la tâche qui appelle le programme CFC à créer. Spécification: La cible de la section CreateCFCProgram identifie les programmes CFC de ce type de module. En principe, un type de module peut définir et créer plusieurs programmes CFC pour son instance de module. Une définition pour StandardCallTask ou CustomCallTask doit exister, mais une seule définition est autorisée. Pour StandardCallTask les trois identifiants LOW , MEDIUM , et HIGH sont disponibles pour définir la tâche de l'instance de module parent de niveau supérieur\/découplé suivant. Pour CustomCallTask tous les ID cibles sont disponibles et sont utilisés dans la tâche personnalisée respective de l'instance de module parent de niveau supérieur\/découplé suivant. Dans ParentFolder l'ID cible du CreateFolder section peut être saisi. Ensuite, le programme CFC créé est ajouté dans ce sous-dossier ( CreateFolder ). " }, 
{ "title" : "Sous-section : CreateCFCModuleCall ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_4225fb301403f77dc0a8640e01bbc228", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Générateur de CFC \/ Rubrique : CFCCréation \/ Sous-section : CreateCFCModuleCall ", 
"snippet" : "Si une déclaration de module contient une section cfc.CFCCreation y compris la sous-section CreateCFCProgram , un appel de l'instance de module FB est créé pour le type de module affecté dans le programme CFC de l'instance de module parent immédiatement supérieure. Spécification: PreferredCFCProgram...", 
"body" : "Si une déclaration de module contient une section cfc.CFCCreation y compris la sous-section CreateCFCProgram , un appel de l'instance de module FB est créé pour le type de module affecté dans le programme CFC de l'instance de module parent immédiatement supérieure. Spécification: PreferredCFCProgram définit le programme CFC à utiliser si plusieurs programmes sont disponibles. " }, 
{ "title" : "Sous-section : CréerCFCIOCall ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_72ec1fc41403f77ec0a8640e00114156", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Générateur de CFC \/ Rubrique : CFCCréation \/ Sous-section : CréerCFCIOCall ", 
"snippet" : "La section est utilisée pour marquer les E\/S d'un type de module ou d'une déclaration de module. Pour ces E\/S, des instances FB d'un type défini sont créées. Ensuite, les appels de ces instances de FB sont créés dans le programme CFC. Spécification: La cible de la CreateCFCIOCall définit l'ID d'E\/S ...", 
"body" : "La section est utilisée pour marquer les E\/S d'un type de module ou d'une déclaration de module. Pour ces E\/S, des instances FB d'un type défini sont créées. Ensuite, les appels de ces instances de FB sont créés dans le programme CFC. Spécification: La cible de la CreateCFCIOCall définit l'ID d'E\/S du module pour lequel un FB d'E\/S global sera créé. Le FB d'E\/S créé est appelé dans un programme CFC. FB définit le type de bloc fonction qui est globalement instancié et appelé pour le FB d'E\/S mentionné ci-dessus. PreferredCFCProgram définit le programme CFC à utiliser si plusieurs programmes sont disponibles. FBInstanceBaseName définit un \"nom de base\" qui est utilisé pour nommer les FB d'E\/S créés. Si la définition n'existe pas, le nom de l'instance du module est utilisé pour l'instance de base. " }, 
{ "title" : "Sous-section : Créer un dossier ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_a2dd1e181403f77ec0a8640e013c4468", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Déclaration du module \/ Générateur de CFC \/ Rubrique : CFCCréation \/ Sous-section : Créer un dossier ", 
"snippet" : "Cette section contient des paramètres pour créer des sous-dossiers sous le AC_CFC_Programs dossier. Correspondant à cela un ParentFolder peut être défini dans le CreateCFCProgram section. Les programmes CFC sont alors générés dans le répertoire créé par le CreateFolder section. Les dossiers eux-même...", 
"body" : "Cette section contient des paramètres pour créer des sous-dossiers sous le AC_CFC_Programs dossier. Correspondant à cela un ParentFolder peut être défini dans le CreateCFCProgram section. Les programmes CFC sont alors générés dans le répertoire créé par le CreateFolder section. Les dossiers eux-mêmes peuvent définir un ParentFolder pour spécifier d'autres sous-dossiers et sous-sous-dossiers. Spécification: Dans ParentFolder l'ID cible du CreateFolder section peut être saisi. Ensuite, le répertoire créé sera créé dans ce sous-dossier ( CreateFolder ). Exemple SEC cfc.CFCCreation\n SEC CreateCFCProgram : Standard\n StandardCallTask := MEDIUM;\n ParentFolder := SubFolderUnderFolder;\n END_SEC\n SEC CreateFolder : SubFolderUnderFolder\n ParentFolder := SubFolder;\n END_SEC\nEND_SEC " }, 
{ "title" : "Bibliothèque : AC_ModuleBase ", 
"url" : "ac_library.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Bibliothèque : AC_ModuleBase ", 
"snippet" : "La bibliothèque de base de module AC_ModuleBase fait partie du concept de module du CODESYS Application Composer . Tous les modules développés pour être disponibles dans le configurateur d'arborescence de modules doivent être dérivés de cette bibliothèque de base. Navigation vers le niveau supérieur...", 
"body" : "La bibliothèque de base de module AC_ModuleBase fait partie du concept de module du CODESYS Application Composer . Tous les modules développés pour être disponibles dans le configurateur d'arborescence de modules doivent être dérivés de cette bibliothèque de base. Navigation vers le niveau supérieur La fonction GetToplevelRange renvoie une instance de plage (type SiblingRange ) qui donne accès à toutes les instances de niveau supérieur. La fonction GetToplevelInstance renvoie le module de niveau supérieur qui est un ancêtre de l'instance donnée. " }, 
{ "title" : "Nom de l'instance ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_f44958df1c1aa580c0a8640e00033aeb", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Bibliothèque : AC_ModuleBase \/ Nom de l'instance ", 
"snippet" : "La propriété InstanceName de la classe de base renvoie une chaîne qui contient le nom de l'instance du module. Propriété dans IInstanceBase : PROPERTY InstanceName : STRING(255) Valeur de retour : nom de l'instance de l'instance du module Les instances proxy renvoient le nom d'instance de l'instance...", 
"body" : "La propriété InstanceName de la classe de base renvoie une chaîne qui contient le nom de l'instance du module. Propriété dans IInstanceBase : PROPERTY InstanceName : STRING(255) Valeur de retour : nom de l'instance de l'instance du module Les instances proxy renvoient le nom d'instance de l'instance du module distant. " }, 
{ "title" : "Informations sur les modules ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_a581c7b51c1aa580c0a8640e012cbe1e", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Bibliothèque : AC_ModuleBase \/ Informations sur les modules ", 
"snippet" : "PROPERTY ModuleInfo : POINTER TO ModuleInfo : Cette propriété renvoie un pointeur vers un bloc fonction ModuleInfo avec la méthode PROPERTY ModuleType : STRING(255) . PROPERTY ModuleType : STRING(255) : Cette propriété renvoie le nom du module qui est qualifié par l'espace de nom de la bibliothèque ...", 
"body" : "PROPERTY ModuleInfo : POINTER TO ModuleInfo : Cette propriété renvoie un pointeur vers un bloc fonction ModuleInfo avec la méthode PROPERTY ModuleType : STRING(255) . PROPERTY ModuleType : STRING(255) : Cette propriété renvoie le nom du module qui est qualifié par l'espace de nom de la bibliothèque de modules. (L'espace de nom est relatif au projet principal.) " }, 
{ "title" : "Chemin de l'instance ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_247de8bc1c1aa581c0a8640e00b26998", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Bibliothèque : AC_ModuleBase \/ Chemin de l'instance ", 
"snippet" : "La fonction GetInstancePath(IModule) renvoie le chemin d'instance d'une instance de module. Le chemin d'instance est construit en concaténant les noms d'instance de tous les ancêtres, en commençant par le module de niveau supérieur jusqu'à l'instance donnée. Les noms d'instance sont séparés par des ...", 
"body" : "La fonction GetInstancePath(IModule) renvoie le chemin d'instance d'une instance de module. Le chemin d'instance est construit en concaténant les noms d'instance de tous les ancêtres, en commençant par le module de niveau supérieur jusqu'à l'instance donnée. Les noms d'instance sont séparés par des points. Si le nom d'instance résultant comporte plus de 255 caractères, une chaîne vide est renvoyée. PROPERTY InstancePath : STRING(255) " }, 
{ "title" : "Navigation à plat ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_acbf32a81c1aa581c0a8640e0039f1c2", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Bibliothèque : AC_ModuleBase \/ Navigation à plat ", 
"snippet" : "La fonction GetPrevModule(IModule) et GetNextModule(IModule) permettent de sauter à l'élément précédent ou suivant (si l'arborescence du module est considérée comme une liste plate d'instances de module). Les modules sont renvoyés dans le préordre en profondeur de l'arborescence des modules. Les réf...", 
"body" : "La fonction GetPrevModule(IModule) et GetNextModule(IModule) permettent de sauter à l'élément précédent ou suivant (si l'arborescence du module est considérée comme une liste plate d'instances de module). Les modules sont renvoyés dans le préordre en profondeur de l'arborescence des modules. Les références de module sont ignorées s'il n'y a pas de module précédent ou suivant. Alternativement, le bloc fonction DepthFirstRange peut être utilisé qui répertorie toutes les instances à partir d'une instance spécifique. La fonction GetDepthFirstRange renvoie une instance de bloc fonction range (de type DepthFirstRange ) qui répertorie l'arborescence complète, à partir d'une instance donnée. " }, 
{ "title" : "Navigation hiérarchique ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_1e4f5ff21c1aa58ec0a8640e0059614e", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Bibliothèque : AC_ModuleBase \/ Navigation hiérarchique ", 
"snippet" : "L'interface IModuleTree permet de naviguer dans l'arborescence du module. Un objet de cette interface est fourni à chaque module par l'utilisation d'un pointeur vers une instance de type MEnv . Ce pointeur est passé à la fonction SetIdentification . Les références de module sont ignorées dans la nav...", 
"body" : "L'interface IModuleTree permet de naviguer dans l'arborescence du module. Un objet de cette interface est fourni à chaque module par l'utilisation d'un pointeur vers une instance de type MEnv . Ce pointeur est passé à la fonction SetIdentification . Les références de module sont ignorées dans la navigation. L'ordre des nœuds enfants correspond à l'ordre des instances de module dans l'arborescence du module. GetParent(itfM : IModule) : IModule : IModule : Renvoie l'instance parente d'une instance de module donnée. Pour les instances de module de niveau supérieur, la valeur de retour est 0. GetFirstChild(itfM : IModule) : IModule : Renvoie le premier enfant d'une instance de module donnée. Pour les instances de module sans enfants, la valeur de retour est 0 NextSibling(itfM : IModule) : IModule : Renvoie le frère suivant d'une instance de module. Pour les instances de module sans autre frère, il renvoie 0. Il peut également être appelé pour les instances de niveau supérieur. PrevSibling(itfM : IModule) : IModule : Renvoie le frère précédent d'une instance de module. Pour les instances de module sans frère précédent, il renvoie 0. Il peut également être appelé pour les instances de niveau supérieur. GetFirstToplevelInstance() : IModule : renvoie la première instance de niveau supérieur de l'arborescence. Elle renvoie 0 si l'arbre est vide. " }, 
{ "title" : "Navigation vers les ancêtres, les frères et sœurs et les enfants ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_f30cbdfc1c1aa58fc0a8640e0098179e", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Bibliothèque : AC_ModuleBase \/ Navigation vers les ancêtres, les frères et sœurs et les enfants ", 
"snippet" : "Le bloc fonction AncestorRange permet d'accéder à tous les ancêtres d'une instance, en commençant par l'instance elle-même. Le bloc fonction SiblingRange permet d'accéder à tous les frères et sœurs suivants d'une instance dans l'arborescence du module, en commençant par l'instance elle-même. La fonc...", 
"body" : "Le bloc fonction AncestorRange permet d'accéder à tous les ancêtres d'une instance, en commençant par l'instance elle-même. Le bloc fonction SiblingRange permet d'accéder à tous les frères et sœurs suivants d'une instance dans l'arborescence du module, en commençant par l'instance elle-même. La fonction GetChildRange renvoie un élément de plage (type SiblingRange ) de tous les enfants d'une instance. " }, 
{ "title" : "Protocole de message fiable (RMP) ", 
"url" : "ac_reliable_message_protocol.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Bibliothèque : AC_ModuleBase \/ Protocole de message fiable (RMP) ", 
"snippet" : "Le protocole de message fiable est utilisé pour envoyer des messages d'une instance de module à une autre. Cette communication peut se faire entre applications. Par conséquent, une instance du gestionnaire RMP est créée pour chaque application. Spécification de l'adressage : Chaque partenaire possèd...", 
"body" : "Le protocole de message fiable est utilisé pour envoyer des messages d'une instance de module à une autre. Cette communication peut se faire entre applications. Par conséquent, une instance du gestionnaire RMP est créée pour chaque application. Spécification de l'adressage : Chaque partenaire possède un ID unique de 32 bits, qui se compose d'un mot haut (bit 16–31) pour l'ID d'application et d'un mot bas (bit 0–15) pour l'ID local. Chaque ID (32 bits) doit être unique – les mots simples (mot bas ou mot haut) de l'ID peuvent être utilisés plus d'une fois. L'ID de l'application qui appelle l'instance doit être défini dans le mot haut de l'instance. Conventions de nommage des variables : udi<xxx>ID : ID complet du module composé de l'ID de l'application et de l'ID du module local ui<xxx>AppID : ID d'application (16 bits), mot de poids fort de l'ID complet ui<xxx>ModuleID : ID module local (16 bits), mot de poids faible de l'ID complet " }, 
{ "title" : "Service IRMP ", 
"url" : "ac_rmp_irmpservice.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Bibliothèque : AC_ModuleBase \/ Service IRMP ", 
"snippet" : "Méthodes et propriétés de l'interface IRMPService . Propriété : LocalAppID PROPERTY LocalAppID : UINT (get) Cette propriété décrit l'adresse de l'application locale. (Le mot de poids fort de l'ID de communication des instances de module de cette application.)...", 
"body" : "Méthodes et propriétés de l'interface IRMPService . Propriété : LocalAppID PROPERTY LocalAppID : UINT (get) Cette propriété décrit l'adresse de l'application locale. (Le mot de poids fort de l'ID de communication des instances de module de cette application.) " }, 
{ "title" : "Méthode : IsMessageSent ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_538e8d066de1851ec0a8652001725d6d", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Bibliothèque : AC_ModuleBase \/ Service IRMP \/ Méthode : IsMessageSent ", 
"snippet" : "METHOD IsMessageSent : BOOL VAR_INPUT uiHandle: UINT; END_VAR Cette méthode vérifie si un message qui a été mis en file d'attente avec QueueSendMessage a été envoyé et reconnu. uiHandle est le handle renvoyé par QueueSendMessage . Pour cela, vérifiez l'utilisation du bloc fonction RMPSendMessage est...", 
"body" : "METHOD IsMessageSent : BOOL\nVAR_INPUT\n uiHandle: UINT;\nEND_VAR Cette méthode vérifie si un message qui a été mis en file d'attente avec QueueSendMessage a été envoyé et reconnu. uiHandle est le handle renvoyé par QueueSendMessage . Pour cela, vérifiez l'utilisation du bloc fonction RMPSendMessage est recommandé, car il fournit une interface de commande standardisée. " }, 
{ "title" : "Méthode : QueueSendMessage ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_b6b7ed9d6de18513c0a8652000b31074", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Bibliothèque : AC_ModuleBase \/ Service IRMP \/ Méthode : QueueSendMessage ", 
"snippet" : "METHOD QueueSendMessage : UINT VAR_INPUT udiSenderID: UDINT; udiReceiverID: UDINT; tValidity: TIME; pmdData: POINTER TO ARRAY[0..63] OF BYTE; END_VAR Cette méthode ajoute un message à envoyer dans la file d'attente d'envoi et renvoie un handle. Cette poignée peut être utilisée pour vérifier si la tr...", 
"body" : "METHOD QueueSendMessage : UINT\nVAR_INPUT\n udiSenderID: UDINT;\n udiReceiverID: UDINT;\n tValidity: TIME;\n pmdData: POINTER TO ARRAY[0..63] OF BYTE;\nEND_VAR Cette méthode ajoute un message à envoyer dans la file d'attente d'envoi et renvoie un handle. Cette poignée peut être utilisée pour vérifier si la transmission a réussi. Une valeur de retour de 16#FFFF indique que la mémoire tampon est pleine et que le message n'a pas été transmis. Une valeur de retour de 16#FFFE indique que le module récepteur est dans la même application et que la transmission a réussi. Pour ajouter un message à la file d'attente d'envoi, utilisez le bloc fonction RMPSendMessage est recommandé, car il fournit une interface de commande standardisée. " }, 
{ "title" : "Méthode : Recevoir ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_385683a56de1850cc0a8652000d330da", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Bibliothèque : AC_ModuleBase \/ Service IRMP \/ Méthode : Recevoir ", 
"snippet" : "METHOD Receive : UDINT VAR_INPUT uiReceiverModuleID: UINT; pmd: POINTER TO ARRAY[0..63] OF BYTE; END_VAR Cette méthode est appelée par chaque module pouvant recevoir un message. Il prend le plus ancien message reçu pour uiReceiverID et le reconnaît. Si un message n'est pas disponible, alors 16#FFFFF...", 
"body" : "METHOD Receive : UDINT\nVAR_INPUT\n uiReceiverModuleID: UINT;\n pmd: POINTER TO ARRAY[0..63] OF BYTE;\nEND_VAR Cette méthode est appelée par chaque module pouvant recevoir un message. Il prend le plus ancien message reçu pour uiReceiverID et le reconnaît. Si un message n'est pas disponible, alors 16#FFFFFFFF est retourné. Il revient 16#FFFFFFFE s'il y a au moins un message en attente du destinataire, si le message le plus ancien est actuellement verrouillé par une autre tâche. Dans tous les autres cas, l'adresse de communication de l'expéditeur est renvoyée. " }, 
{ "title" : "RMPSendMessage ", 
"url" : "ac_rmp_sendmessage.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Bibliothèque : AC_ModuleBase \/ RMPSendMessage ", 
"snippet" : "Ce bloc fonction sert à envoyer des messages à n'importe quelle instance de module. L'adresse de l'instance doit être connue. Le comportement des variables xExecute , xDone , xBusy , et xError est conforme aux \"Directives pour la conception des bibliothèques\". Ce document fait partie du CODESYS inst...", 
"body" : "Ce bloc fonction sert à envoyer des messages à n'importe quelle instance de module. L'adresse de l'instance doit être connue. Le comportement des variables xExecute , xDone , xBusy , et xError est conforme aux \"Directives pour la conception des bibliothèques\". Ce document fait partie du CODESYS installation standard. " }, 
{ "title" : "FUNCTION_BLOCK : RMPSendMessage ", 
"url" : "ac_rmp_sendmessage.html#UUID-2d1f2b05-610c-bf06-e2fe-18d7e3819bbc_ac_rmp_sendmessage0", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Bibliothèque : AC_ModuleBase \/ RMPSendMessage \/ FUNCTION_BLOCK : RMPSendMessage ", 
"snippet" : "FUNCTION_BLOCK RMPSendMessage EXTENDS CBM.ETRIG VAR_IN_OUT mdData: ARRAY[0..63] OF BYTE; END_VAR VAR_INPUT itfrmp: IRMPService; xExecute: BOOL; udiReceiverID: UDINT; uiSenderModuleID: UINT; tValidity: TIME := t#1s; END_VAR VAR_OUTPUT xDone: BOOL; xBusy: BOOL; xError: BOOL; uiErrorID: UINT; END_VAR V...", 
"body" : "FUNCTION_BLOCK RMPSendMessage EXTENDS CBM.ETRIG\nVAR_IN_OUT\n mdData: ARRAY[0..63] OF BYTE;\nEND_VAR\nVAR_INPUT\n itfrmp: IRMPService;\n xExecute: BOOL;\n udiReceiverID: UDINT;\n uiSenderModuleID: UINT;\n tValidity: TIME := t#1s;\nEND_VAR\nVAR_OUTPUT\n xDone: BOOL;\n xBusy: BOOL;\n xError: BOOL;\n uiErrorID: UINT;\nEND_VAR Veuillez noter que la tâche du bloc fonctionnel est terminée avec succès dès que la réception du message dans le RMPService du côté opposé est confirmée. Cela ne signifie pas nécessairement que le message a atteint l'interface réelle du module récepteur. Dans mdData , les données à envoyer seront transférées. udiReceiverID définit l'ID du récepteur. rmp définit l'instance locale de RMPService. tValidity définit la période de validation du message. Les éléments suivants sont vérifiés : La durée jusqu'à l'envoi du message ne doit pas dépasser tValidity (sinon un message d'erreur sera créé). La durée jusqu'à ce que le message soit capté par le récepteur du côté opposé, ne doit pas dépasser tValidity (sinon le message sera supprimé). Les erreurs suivantes peuvent se produire et seront renvoyées dans uiErrorID : Le tampon d'envoi est plein ; il est recommandé de renvoyer ultérieurement. Le message ne sera pas supprimé du tampon d'envoi. Les raisons peuvent être un transfert lent, une connexion interrompue ou un tampon de réception plein du côté opposé. L'application à laquelle le message est envoyé n'est pas connectée à cette application. Dans ce cas, un transfert des données n'est pas possible. " }, 
{ "title" : "Débogage ", 
"url" : "ac_rmp_debugging.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Éditeur de déclaration de module \/ Bibliothèque : AC_ModuleBase \/ Débogage ", 
"snippet" : "La variable globale g_AC_RMP_xDiagLog peut être utilisé pour activer le mécanisme de journalisation. Ce mécanisme enregistre tous les événements d'envoi et de réception et enregistre la création et la suppression d'un message dans une file d'attente du journal standard. De plus, tous les événements ...", 
"body" : "La variable globale g_AC_RMP_xDiagLog peut être utilisé pour activer le mécanisme de journalisation. Ce mécanisme enregistre tous les événements d'envoi et de réception et enregistre la création et la suppression d'un message dans une file d'attente du journal standard. De plus, tous les événements et erreurs inattendus sont consignés dans le journal standard. " }
]
$(document).trigger('search.ready');
});