$(document).ready(function () {indexDict['fr'] = [{ "title" : "CODESYS Git ", 
"url" : "_git_start_page.html", 
"breadcrumbs" : "CODESYSGit \/ CODESYS Git ", 
"snippet" : "CODESYS Git permet d'utiliser le système de contrôle de version distribué Git dans CODESYS afin de gérer les versions de CODESYS projets. Les fonctions de Git sont disponibles directement dans CODESYS . Vous pouvez télécharger le CODESYS Git depuis CODESYS Boutique Internationale ou Boutique CODESYS...", 
"body" : "CODESYS Git permet d'utiliser le système de contrôle de version distribué Git dans CODESYS afin de gérer les versions de CODESYS projets. Les fonctions de Git sont disponibles directement dans CODESYS . Vous pouvez télécharger le CODESYS Git depuis CODESYS Boutique Internationale ou Boutique CODESYS Amérique du Nord . Vous y trouverez également la fiche technique du produit. Lancer CODESYS Git (clip vidéo) " }, 
{ "title" : "Introduction ", 
"url" : "_git_introduction.html", 
"breadcrumbs" : "CODESYSGit \/ Introduction ", 
"snippet" : "L'implémentation de CODESYS Git est basé sur le travail dans Git et sur la terminologie de Git. Après l'installation, la barre de menus de CODESYS comprendra le Gite menu avec les commandes pour initialiser un projet Git et travailler avec les référentiels Git liés. Voir ci-dessous pour certains des...", 
"body" : "L'implémentation de CODESYS Git est basé sur le travail dans Git et sur la terminologie de Git. Après l'installation, la barre de menus de CODESYS comprendra le Gite menu avec les commandes pour initialiser un projet Git et travailler avec les référentiels Git liés. Voir ci-dessous pour certains des termes utilisés dans le CODESYS Git aide et dans le CODESYS Git interface utilisateur. Les commandes Git standard correspondantes sont incluses. Une connaissance de base du travail avec Git est un prérequis. Pour obtenir de la documentation à ce sujet, consultez (par exemple) : Livre Git , Seau Git d'Atlassian Référentiel Git , Stockage de projet Git (\"répertoire de travail\", \"arbre de travail\") Pour le référentiel purement local d'un CODESYS Git projet, nous utilisons ici le terme abrégé \"référentiel Git\". Le dépôt Git se trouve dans le système de fichiers, dans le \"Git project storage\", dans le sous-répertoire .git . Les objets du projet ( <objecttype>_<ID> ) qui sont gérés dans Git se trouvent dans le sous-répertoire project . Les fichiers d'objets sont situés dans une hiérarchie de répertoires qui correspond à la hiérarchie des objets dans le CODESYS projet. Le stockage du projet Git contient également les fichiers de gestion Git .gitattribute , .gitignore , et .apsession . Le fichier .apsession est utilisé pour contrôler l'accès de CODESYS instances au référentiel Git et est ignoré par Git. Le chemin du stockage de projet Git d'un projet peut être vu dans le Paramètres du projet Git voir. The configuration settings, which are available in the .git\/config file, can be modified in a CODESYS Git project via a configuration dialog . If there is no global config file in the local user directory from previous Git actions, then the user is prompted to create a configuration when initializing or cloning a project. CODESYS répertoire du projet Un projet géré avec CODESYS Git est également toujours stocké dans un ordinaire CODESYS répertoire du projet en plus d'être stocké dans le stockage du projet Git (double gestion des données). Référentiel distant : Voir: Télécommandes Git git remote Assurez-vous de disposer d'une connexion sécurisée à un serveur distant. Pour plus d'informations, voir : Sécurité pour CODESYS Git Les référentiels distants sont des versions de votre projet qui sont hébergées sur Internet ou quelque part sur votre réseau. Il est tout à fait possible que vous puissiez travailler avec un référentiel \"distant\" qui se trouve en fait sur le même ordinateur (hôte) sur lequel vous travaillez actuellement. Le référentiel distant est généralement nommé origin . A. CODESYS un projet qui est déjà géré dans Git dans un dépôt Git local peut être lié à un dépôt distant dans le Télécommandes Git voir ( git remote , git remote add ). Ce n'est qu'après cela que les branches locales peuvent \"suivre\" les branches distantes et que des branches équivalentes peuvent être créées pour les branches locales dans le référentiel distant (\"en amont\"). Et ce n'est qu'après cela que le Aller chercher , Tirer , Pousser , et Fusionner être utilisées pour l'échange\/la fusion de commits entre le dépôt Git local et le dépôt distant. Pour effectuer des opérations Git avec un dépôt distant, des informations d'identification sont généralement requises pour l'authentification. Ils sont enregistrés sous Windows dans le Credential Manager. Les mêmes informations d'identification peuvent être utilisées pour tous les référentiels distants situés sur le même serveur hôte. Pour plus d'informations, voir : Identifiants nécessaires. Succursales locales, succursales distantes Voir: Branches Git git remote git branch Il existe exactement deux types de branches : \"locales\" et \"distantes\". Une branche locale peut \"suivre\" exactement une branche distante. Filiales locales : Les succursales locales sont affichées dans le Branches Git Locale (<n>) voir. La branche standard locale d'un dépôt Git (généralement master ) est créé automatiquement après le premier commit. Après le CODESYS projet a été créé à l'aide git clone , la branche \"maître\" locale suit automatiquement la branche distante du même nom. Une branche locale est également créée en copiant une branche locale existante ou en extrayant une branche distante. Dans ce dernier cas, la branche locale récemment créée suit automatiquement la branche distante. Succursales distantes : Les succursales distantes sont affichées dans le Branches Git Distant (<n>) voir. Il s'agit des représentants existants dans le référentiel Git de la branche respective portant le même nom dans le référentiel distant. Les succursales distantes ne sont utilisées qu'en interne comme \"emplacement intermédiaire\" pour la communication via Pousser \/ Tirer avec le référentiel distant et ne sont pas utilisés directement par l'utilisateur. \" Upstream \" Commande dans le Branches Git Local voir git branch --set-upstream-to <origin\/remote-branch> La En amont Régler provoque la création d'une branche, qui correspond à la branche locale, dans le référentiel distant (branche distante). \" Tracking \", \"Succursales de suivi à distance\" Commande dans le Branches Git voir git branch --track git checkout Suivre la branche consiste à créer un lien entre une agence locale et une agence distante. Cas par défaut : La branche représentative locale master du dépôt Git suit la branche distante origin\/master du référentiel distant. Lorsqu'une branche locale suit une branche distante, un échange de commits avec le dépôt distant est possible au moyen de Tirer et Pousser . Alternativement, vous pouvez également utiliser le Vérifier commande dans le Branches Git Distant (<n>) vue pour créer une branche locale \"de suivi\", qui est définie comme branche \"courante\" en même temps, pour une branche distante existante. La branche actuelle est celle où arrivent les nouveaux commits. Indice Git Voir: Statut Git git status L'index est un niveau intermédiaire interne à Git entre le répertoire de travail et le référentiel Git. Il permet de marquer sélectivement uniquement une sélection d'objets modifiés pour un commit. Toutes les modifications ne doivent pas être archivées en tant que validation. Les objets situés dans l'index Git sont visibles dans Statut et mise en scène voir, dans Changements par étapes section. Resynchronisation et recharger le projet Synchronisation La CODESYS projet en CODESYS est resynchronisé avec l'état actuel du stockage du projet Git après chaque opération Git qui effectue une modification du référentiel Git. Ces opérations comprennent les suivantes : Vérifier , Tirer , et Fusionner de succursales ( Branches Git voir) Ignorer toutes les modifications et Annuler toutes les modifications non mises en scène ( Statut et mise en scène voir) Changements par la résolution des conflits La resynchronisation du CODESYS projet a pour effet que le projet est entièrement reconstruit à partir du référentiel. Aucune tentative n'est faite pour mettre à jour le projet. Vous pouvez utiliser le Reconstruire le projet à partir du référentiel pour lancer explicitement une resynchronisation. La synchronisation, quant à elle, est l'application des modifications CODESYS stockage du projet dans le référentiel de projet Git. Cela se produit chaque fois qu'une modification est apportée au CODESYS projet. Lorsque des modifications sont apportées au projet, seules ces modifications sont appliquées. Lorsque le projet est rouvert, le projet complet est à nouveau appliqué au référentiel de projet Git et écrase l'état qui s'y trouve. Vous pouvez utiliser le Synchroniser le projet avec le stockage de projet Git (pas dans le menu Git par défaut) pour lancer explicitement une synchronisation. " }, 
{ "title" : "Placer un projet dans Git Management ", 
"url" : "_git_setting_up_repositories.html", 
"breadcrumbs" : "CODESYSGit \/ Placer un projet dans Git Management ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Dépôts et succursales dans CODESYS Git ", 
"url" : "_git_setting_up_repositories.html#UUID-45dd2cae-82b0-7a65-3526-e4fdc7369aa4_id_d99ef84311db29bfc0a8646324d30e24-id-73febd7011db29bfc0a86463349a40b7", 
"breadcrumbs" : "CODESYSGit \/ Placer un projet dans Git Management \/ Dépôts et succursales dans CODESYS Git ", 
"snippet" : "Pour gérer un CODESYS projet dans Git avec l'aide de CODESYS Git , il suffit tout d'abord d'utiliser un Référentiel Git dans le \"project storage\" (répertoire de travail), également appelé \"dépôt Git\" dans le texte suivant. Pour la collaboration avec d'autres développeurs sur le projet, le référentie...", 
"body" : "Pour gérer un CODESYS projet dans Git avec l'aide de CODESYS Git , il suffit tout d'abord d'utiliser un Référentiel Git dans le \"project storage\" (répertoire de travail), également appelé \"dépôt Git\" dans le texte suivant. Pour la collaboration avec d'autres développeurs sur le projet, le référentiel Git local peut être lié avec un \" référentiel distant \" qui est accessible à tous. Le travail sur le projet géré dans Git se fait d'abord en local branches (statuts de travail). Les branches locales peuvent tracer une branche distante (lien vers le dépôt distant). Les branches distantes sont les représentants existants dans le référentiel Git local de la branche respective dans le référentiel distant. Vous pouvez utiliser le Déplacer le référentiel commande pour déplacer un référentiel Git vers un autre emplacement dans le système de fichiers. Vous pouvez utiliser Déconnexion du référentiel Git commande pour dissocier un projet de la gestion du code source dans Git. Lorsque le cryptage est défini pour le CODESYS projet ( CODESYS - Paramètres du projet – Sécurité ), le référentiel Git (ni local ni distant) n'est pas automatiquement protégé en conséquence. " }, 
{ "title" : "Utilisant git init placer un CODESYS projet en gestion Git ", 
"url" : "_git_setting_up_repositories.html#UUID-45dd2cae-82b0-7a65-3526-e4fdc7369aa4_id_d99ef84311db29bfc0a8646324d30e24-id-e53fbb62a75511ebb64e996906c7fdba", 
"breadcrumbs" : "CODESYSGit \/ Placer un projet dans Git Management \/ Utilisant git init placer un CODESYS projet en gestion Git ", 
"snippet" : "Exigence: CODESYS Git est installé. UN CODESYS projet est ouvert. Préparez un répertoire vide dans le système de fichiers pour que le référentiel du projet Git contienne le référentiel Git local. Exemple: D:\\git_local\\rep1 Dans CODESYS Git , ouvrez le CODESYS projet qui devrait être placé sous la ge...", 
"body" : "Exigence: CODESYS Git est installé. UN CODESYS projet est ouvert. Préparez un répertoire vide dans le système de fichiers pour que le référentiel du projet Git contienne le référentiel Git local. Exemple: D:\\git_local\\rep1 Dans CODESYS Git , ouvrez le CODESYS projet qui devrait être placé sous la gestion de Git. Exemple: myproj.project . Cliquez sur Git → Initialiser le référentiel Git commande. La Initialiser le référentiel Git la boîte de dialogue s'ouvre. Dans la boîte de dialogue, spécifiez le chemin du répertoire vide pour Stockage de projets Git (exemple : D:\\git_local\\rep1 ). Le dépôt Git qui y est créé est votre « master » local. S'il n'y a pas de global fichier de configuration .gitconfig dans l'annuaire des utilisateurs local (exemple : C:\\Users\\m.muster ), une boîte de dialogue s'ouvrira pour vous permettre de créer une configuration de base pour tous CODESYS Git actions. Vous obtenez la même boîte de dialogue pour saisir certains paramètres que via le Configuration Git commande. Le paramètre par défaut pour Branche par défaut est master . Entrez vos données d'utilisateur Nom d'utilisateur et E-mail adresse (exemple) m.muster , m.muster@company.com ). The objects in the project navigator are provided with blue plus signs (status: \"added\"), and the root node (project name) is provided with an orange square (status: \"changed\"). Le chemin du stockage du projet Git est affiché dans le Git → Paramètres du projet voir. En conséquence, la gestion de projet dans le référentiel Git situé dans le stockage de projet est initialisée. Enregistrez le projet (comme d'habitude sans gestion Git) dans un dossier séparé répertoire de projets (exemple : D:\\git_projects\\myproj.project ). Remarque : Les fichiers de projet font donc l'objet d'une double gestion des données. Ouvrez le Statut Git voir. Dans Modifications non échelonnées dans la partie inférieure, sélectionnez les objets du projet affichés. Cliquez ensuite sur le bouton pour le mettre en scène pour un commit. Les objets sont déplacés vers le haut pour Modifications par étapes . Clique le bouton (valider). Dans le Commettre des modifications par étapes boîte de dialogue, entrez un message de validation et cliquez sur D'ACCORD confirmer. L'état actuel des objets du projet est validé dans le référentiel local. Cliquez sur Git → Historique de Git . Dans le Histoire vue, le premier commit pour le \"maître\" est affiché avec plus d'informations. Dans le navigateur de projet, symboles de cercles verts pleins sont affichés devant les objets validés et devant la racine. Cela signifie que le statut du projet est synchronisé avec son statut dans le référentiel Git. Cliquez sur Git → Branches Git et sélectionnez le Locale (1) filtre. La branche par défaut du référentiel Git est visible sous la forme master (refs\/heads\/master) . Dans le système de fichiers, accédez au référentiel local D:\\git_local\\rep1 . maintenant le répertoire .git (le référentiel Git actuel) se trouve ici avec le sous-répertoire project et les fichiers .gitattributes , .gitignore , et .apsession . Le répertoire project contient les objets du CODESYS projet. Maintenant, vous pouvez toujours lier le projet (si nécessaire) à un référentiel distant. " }, 
{ "title" : "En utilisant Clone Git Repository pour créer un nouveau CODESYS projet déjà dans la gestion de Git ", 
"url" : "_git_setting_up_repositories.html#UUID-45dd2cae-82b0-7a65-3526-e4fdc7369aa4_id_d99ef84311db29bfc0a8646324d30e24-id-11ad0c1713d3a29ac0a8646340f28253", 
"breadcrumbs" : "CODESYSGit \/ Placer un projet dans Git Management \/ En utilisant Clone Git Repository pour créer un nouveau CODESYS projet déjà dans la gestion de Git ", 
"snippet" : "Avec Git Clone , un nouveau CODESYS projet est créé, dont la version est gérée dans Git. Par conséquent, le clonage d'un référentiel distant crée le nouveau stockage de projet (le nouveau répertoire de travail avec le référentiel Git). Exigence: CODESYS Git est installé. Vous avez accès à un référen...", 
"body" : "Avec Git Clone , un nouveau CODESYS projet est créé, dont la version est gérée dans Git. Par conséquent, le clonage d'un référentiel distant crée le nouveau stockage de projet (le nouveau répertoire de travail avec le référentiel Git). Exigence: CODESYS Git est installé. Vous avez accès à un référentiel distant. Ouvrir CODESYS Git . Cliquez sur Git → Cloner le dépôt Git commande. Il est disponible lorsque non CODESYS le projet est ouvert. La Git Clone la boîte de dialogue s'ouvre. Dans URL source , spécifiez l'URL ou le chemin du fichier du référentiel distant à cloner (exemple : D:\\git_remotes\\remote1 ). Dans Chemin de stockage Git , précisez le répertoire de fichiers vide destiné au stockage du nouveau projet Git (nouveau référentiel Git) (exemple : D:\\git_local\\rep1 ). Dans Dossier de projet , spécifiez un répertoire de projet où le nouveau CODESYS le projet doit être enregistré en plus et en dehors de Git (!) (exemple : D:\\git_projects\\myproj1.project , double gestion des données !). Dans Type de fichier de projet , indiquez s'il doit s'agir d'un projet standard ou d'un projet de bibliothèque. Confirmez la boîte de dialogue. S'il n'y a pas de global fichier de configuration .gitconfig dans l'annuaire des utilisateurs local (exemple : C:\\Users\\m.muster ), une boîte de dialogue s'ouvrira pour vous permettre de créer une configuration de base pour tous CODESYS Git actions. Consultez les instructions ci-dessus pour initialiser un projet Git (étape 4). If the Git option Accept self signed certificate is not selected, then CODESYS Git first checks the certificate for the connection to the server from which the project should be cloned. If the certificate is not trusted, then you will be given the option of allowing the connection after a personal check. Le nouveau projet est ouvert. Le nouveau répertoire de travail est créé et automatiquement initialisé en tant que référentiel Git. Il a d'abord l'état exact du référentiel distant au moment du clonage. Dans le CODESYS projet, cliquez Git → Branches Git . Dans le Branches Git vue, les branches distantes sont déjà visibles. Par défaut, pour la branche \"maître\" distante, une branche \"maître\" locale est également créée, qui suit la branche distante. Vous pouvez maintenant commencer à travailler dans cette succursale locale immédiatement. De plus, un lien (tracking) de l'agence locale vers l'agence distante \"représentant\" ( origin\/master ) du nouveau référentiel Git est déjà établi. " }, 
{ "title" : "Lier un projet à un référentiel distant ", 
"url" : "_git_setting_up_repositories.html#UUID-45dd2cae-82b0-7a65-3526-e4fdc7369aa4_id_d99ef84311db29bfc0a8646324d30e24-id-57b75172176320a3c0a864631b96d43f", 
"breadcrumbs" : "CODESYSGit \/ Placer un projet dans Git Management \/ Lier un projet à un référentiel distant ", 
"snippet" : "Exigence : un projet est géré dans Git dans CODESYS Git . Vous voulez maintenant établir un lien vers un dépôt distant pour y synchroniser vos commits avec ceux des autres Cliquez sur Git → Télécommandes Git . Dans le Télécommandes Git vue, cliquez sur le Ajouter bouton. La Ajouter une nouvelle télé...", 
"body" : "Exigence : un projet est géré dans Git dans CODESYS Git . Vous voulez maintenant établir un lien vers un dépôt distant pour y synchroniser vos commits avec ceux des autres Cliquez sur Git → Télécommandes Git . Dans le Télécommandes Git vue, cliquez sur le Ajouter bouton. La Ajouter une nouvelle télécommande Git la boîte de dialogue s'ouvre. Spécifiez le chemin et un nom pour le référentiel distant à lier. Exemple: Surnom : origin , URL : D:\\git_remote . Exécutez le Aller chercher commande puis cliquez sur Git → Branches Git pour passer à la Branches Git voir. Des informations d'identification sont généralement requises pour accéder à un référentiel distant. Ce n'est que si aucune information d'identification valide n'est trouvée sur l'ordinateur Informations d'identification nécessaires boîte de dialogue pour votre saisie. Pour plus d'informations, voir : Identifiants nécessaires. Sélectionnez le Distant (<n>) filtre. Vous voyez les branches distantes. Désélectionnez le Distant (<n>) filtre. Sélectionnez le Locale (1) filtre. Sélectionnez le master entrée et cliquez En amont Régler . S'il n'y a toujours pas de succursale distante ( origin\/master ) pour le référentiel distant sélectionné, voici ce qui se produit : La Définir la télécommande en amont pour la succursale la boîte de dialogue s'ouvre. Le nom distant origin est déjà prédéfini. Cliquez sur D'ACCORD pour confirmer les saisies. → Le Suivi et Courant les options sont sélectionnées pour master . Dans Succursale suivie, Nom , origin\/master est affiché. Cela signifie que la succursale distante origin\/master pour le référentiel distant est créé en interne. Celui-ci n'est utilisé qu'en tant que représentant : Aucun travail n'est effectué directement sur cette branche. Sélectionnez le master et cliquez Pousser . Sélectionnez le Télécommande (1) filtre. Maintenant la branche représentative origin\/master en dessous de Branches Git Télécommande (1) s'affiche également. Le lien du local master au référentiel distant est établi par l'intermédiaire de son représentant origin\/master . Dans le Branches Git Locale (<1>) vue, vous pouvez maintenant utiliser le Suivre la branche commande pour lier la branche locale ( master ) du dépôt Git vers la nouvelle branche distante du dépôt distant. " }, 
{ "title" : "Meilleures pratiques ", 
"url" : "_git_best_practises.html", 
"breadcrumbs" : "CODESYSGit \/ Meilleures pratiques ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Restaurer un projet Git si CODESYS s'est écrasé lors de l'édition du projet ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm457535419458083309225168268", 
"breadcrumbs" : "CODESYSGit \/ Meilleures pratiques \/ Restaurer un projet Git si CODESYS s'est écrasé lors de l'édition du projet ", 
"snippet" : "Selon l'opération CODESYS planté auparavant, vous disposez des options de récupération suivantes : Normalement, vous pouvez rouvrir le projet après un plantage. CODESYS Git restaure le dernier état de projet enregistré en interne et réécrit le contenu du projet dans le stockage de projet Git. Ce méc...", 
"body" : "Selon l'opération CODESYS planté auparavant, vous disposez des options de récupération suivantes : Normalement, vous pouvez rouvrir le projet après un plantage. CODESYS Git restaure le dernier état de projet enregistré en interne et réécrit le contenu du projet dans le stockage de projet Git. Ce mécanisme de « échec de sauvegarde » traite le projet comme une source de données « maître ». Si le projet s'est écrasé lors d'une opération de fusion, vous ne devez pas enregistrer immédiatement avant de continuer à travailler après la réouverture, mais d'abord annuler toutes les modifications (git reset --hard). Pour ce faire, vous pouvez utiliser le Ignorer toutes les modifications commande dans le Statut et mise en scène voir. S'il n'est plus possible d'ouvrir le projet après le crash (par exemple parce que des fichiers totalement incompatibles se sont retrouvés dans le stockage du projet), vous disposez de l'option de récupération suivante : Recharger complètement le projet à partir du référentiel. Pour plus d'informations, voir : Reconstruire le projet à partir du référentiel" }, 
{ "title" : "Transférer un projet de CODESYS SVN à CODESYS Git ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm4543860664779233978358194268", 
"breadcrumbs" : "CODESYSGit \/ Meilleures pratiques \/ Transférer un projet de CODESYS SVN à CODESYS Git ", 
"snippet" : "Nous vous recommandons fortement de ne pas supprimer les référentiels SVN après avoir transféré avec succès les projets vers GIT afin de pouvoir toujours y accéder si nécessaire. Dans CODESYS Git version 1.4.0.0 et supérieures, une interface de script sera disponible pour transférer un projet depuis...", 
"body" : "Nous vous recommandons fortement de ne pas supprimer les référentiels SVN après avoir transféré avec succès les projets vers GIT afin de pouvoir toujours y accéder si nécessaire. Dans CODESYS Git version 1.4.0.0 et supérieures, une interface de script sera disponible pour transférer un projet depuis CODESYS SVN à CODESYS Git . La commande Git git-svn ne peut pas être utilisé pour transférer CODESYS des projets de CODESYS SVN à CODESYS Git parce que CODESYS Git utilise le .json format de fichier, contrairement au format de fichier binaire de CODESYS SVN . Commentaires et recommandations dus aux différentes structures de référentiel de CODESYS SVN et CODESYS Git Dans CODESYS Git , un dépôt Git ne peut gérer qu'un seul CODESYS projet. Parce qu'un dépôt SVN peut contenir plusieurs CODESYS projets, un référentiel Git distinct doit être créé pour chaque projet dans un référentiel SVN lors du transfert vers CODESYS Git . Il est recommandé de transférer les projets individuels d'un dépôt SVN vers les dépôts de CODESYS Git sur une base projet par projet. Il n'est pas recommandé de diviser un référentiel SVN en plusieurs référentiels SVN car cela peut entraîner des problèmes ultérieurement. Les branches et les balises existent à la fois dans SVN et GIT, mais elles sont conçues différemment dans ces deux systèmes. Un transfert avec le git-svn la commande n'est pas possible car cette commande ne peut pas être utilisée dans CODESYS Git (voir au dessus). On se limite donc à transférer le trunk SVN vers une branche Git (par défaut « Master » ou « Main »). Si nécessaire, les balises SVN peuvent être ajoutées manuellement en tant que balises Git. " }, 
{ "title" : "Transférer un projet SVN vers Git sans historique ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm4551054095480033979915375444", 
"breadcrumbs" : "CODESYSGit \/ Meilleures pratiques \/ Transférer un projet de CODESYS SVN à CODESYS Git \/ Transférer un projet SVN vers Git sans historique ", 
"snippet" : "Dans cette procédure, la dernière version du CODESYS le projet est d'abord extrait dans CODESYS SVN . Ensuite la connexion à SVN est déconnectée et un dépôt Git avec CODESYS Git est initialisé pour le projet. L'inconvénient de cette procédure est que l'historique du projet est perdu car seule la der...", 
"body" : "Dans cette procédure, la dernière version du CODESYS le projet est d'abord extrait dans CODESYS SVN . Ensuite la connexion à SVN est déconnectée et un dépôt Git avec CODESYS Git est initialisé pour le projet. L'inconvénient de cette procédure est que l'historique du projet est perdu car seule la dernière révision SVN est transférée vers Git. Exigences: CODESYS SVN et CODESYS Git sont installés dans CODESYS . Au moyen du Outils → Personnaliser commande, le Validation terminée la commande a été ajoutée au Intégration Git catégorie de commande dans le Git menu. Ouvrez le CODESYS projet que vous avez enregistré dans le référentiel SVN. Cliquez sur Projet → SVN → Vérifier . La dernière révision du projet est extraite. Cliquez sur Projet → SVN → Déconnecter le projet du SVN . Créez un nouveau dossier vide dans le répertoire de fichiers local de votre ordinateur. Dans CODESYS , Cliquez sur Git → Initialiser le référentiel Git et sélectionnez le dossier vide créé à l'étape précédente dans la boîte de dialogue. Cliquez sur Git → Validation terminée . Le projet est désormais stocké dans le référentiel Git local et peut être transféré vers un référentiel distant si nécessaire. " }, 
{ "title" : "Transférer manuellement un projet SVN vers Git avec historique ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm4577975410139233980281280226", 
"breadcrumbs" : "CODESYSGit \/ Meilleures pratiques \/ Transférer un projet de CODESYS SVN à CODESYS Git \/ Transférer manuellement un projet SVN vers Git avec historique ", 
"snippet" : "Dans cette procédure, chaque révision SVN est transférée manuellement dans un commit Git. Exigences: CODESYS SVN et CODESYS Git sont installés dans CODESYS . Au moyen du Outils → Personnaliser commande, le Validation terminée la commande a été ajoutée au Intégration Git catégorie de commande dans le...", 
"body" : "Dans cette procédure, chaque révision SVN est transférée manuellement dans un commit Git. Exigences: CODESYS SVN et CODESYS Git sont installés dans CODESYS . Au moyen du Outils → Personnaliser commande, le Validation terminée la commande a été ajoutée au Intégration Git catégorie de commande dans le Git menu. Créez un nouveau projet vide dans CODESYS et nommez-le, par exemple, Main Project . Cliquez sur Git → Initialiser le référentiel Git . Cliquez sur Git → Validation terminée . Cliquez sur Git → Commettre pour exécuter un commit vide. Dans le Valider les modifications par étapes boîte de dialogue, sélectionnez le Autoriser la validation vide option. Fermez ce projet. Cliquez sur Projet → SVN → Vérifier pour consulter la révision souhaitée du projet stockée dans SVN. Cliquez sur Projet → SVN → Déconnecter le projet du SVN . Dans la boîte de dialogue suivante, conservez l'option par défaut et cliquez sur D'ACCORD . Enregistrez le projet. Cliquez sur Git → Initialiser le référentiel Git et sélectionnez un dossier vide dans le répertoire de fichiers (exemple : Température ). Cliquez sur Git → Validation terminée . Enregistrez le projet et fermez-le. Le *.project Le fichier de ce projet peut être supprimé. Le dépôt Git Temp du projet ne doit en aucun cas être supprimé. Ouvrez le Main Project projet à nouveau. Cliquez sur Git → Télécommandes pour ouvrir le Télécommandes voir. Dans le Télécommandes voir, cliquez Ajouter . Dans le Ajouter une nouvelle télécommande boîte de dialogue, spécifiez l'URL du référentiel Git Temp et précisez, par exemple, Temp_Remote comme le Alias . Sélectionnez cette télécommande ajoutée et cliquez sur Aller chercher . Cliquez sur Git → Branches pour ouvrir le Branches Git voir. Sélectionnez la branche principale\/maître de Main , Cliquez sur Suivre la branche . Dans le Suivre la succursale distante boîte de dialogue, sélectionnez la branche maître\/principale du Temp_Remote télécommande qui a été ajoutée à l’étape 14. Exécuter un pull sur la branche master\/main du dépôt Git Principal en cliquant Tirez avec des options dans le Branches Git afficher et sélectionner le Utilisez « le leur » pour les conflits option comme Fusionner la stratégie de conflit dans le Maître Git Pull dialogue. L'option par défaut pour Stratégie d'avance rapide ne devrait pas être modifié. Cliquez maintenant Git -→ Validation terminée . dans le Valider les modifications échelonnées et non échelonnées boîte de dialogue, sélectionnez le Modifier le commit option. La révision du projet SVN qui a été extraite au début de ce guide est désormais stockée dans le dépôt Git Principal comme un engagement. Dans le Télécommandes vue, sélectionnez le Temp télécommande et cliquez Retirer . Sauver la Main Project projet et fermez-le. Supprimer le dépôt Git Temp à partir de votre répertoire de fichiers. Si vous souhaitez transférer une autre révision du projet SVN vers le référentiel Git, suivez ces instructions de l'étape 6 pour la prochaine révision souhaitée du projet SVN. " }, 
{ "title" : "Transférer un projet SVN vers Git avec des scripts ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm53402697907264", 
"breadcrumbs" : "CODESYSGit \/ Meilleures pratiques \/ Transférer un projet de CODESYS SVN à CODESYS Git \/ Transférer un projet SVN vers Git avec des scripts ", 
"snippet" : "Exigence: CODESYS Git version >= 1.4.0.0 Les modèles de script suivants pour le transfert sont affichés ci-dessous : 1. Script pour transférer un projet depuis CODESYS SVN à CODESYS Git 2. Script pour vérifier si un commit Git correspondant a été créé pour chaque révision SVN lors du transfert Remar...", 
"body" : "Exigence: CODESYS Git version >= 1.4.0.0 Les modèles de script suivants pour le transfert sont affichés ci-dessous : 1. Script pour transférer un projet depuis CODESYS SVN à CODESYS Git 2. Script pour vérifier si un commit Git correspondant a été créé pour chaque révision SVN lors du transfert Remarques Aucune modification n'est apportée au référentiel SVN. Les deux scripts sont conçus comme des modèles que vous devez adapter aux exigences respectives. " }, 
{ "title" : "Script pour le transfert d'un projet SVN ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm4610024336323234027017655364", 
"breadcrumbs" : "CODESYSGit \/ Meilleures pratiques \/ Transférer un projet de CODESYS SVN à CODESYS Git \/ Script pour le transfert d'un projet SVN ", 
"snippet" : "Le script transfère toutes les révisions SVN du tronc d'un CODESYS SVN projet à la branche \"maître\" d'un CODESYS Git projet. import os import shutil import logging \"\"\" --- inputs --- \"\"\" # URL of the SVN project you want to migrate # only migrate a single project at a time if you have multiple in yo...", 
"body" : "Le script transfère toutes les révisions SVN du tronc d'un CODESYS SVN projet à la branche \"maître\" d'un CODESYS Git projet. import os\nimport shutil\nimport logging\n\n\n\"\"\" --- inputs ---\n\"\"\"\n# URL of the SVN project you want to migrate\n# only migrate a single project at a time if you have multiple in your SVN repo\nSVN_REPO_URL = 'svn:\/\/your.svnserver.com\/trunk\/CodesysProjectNr1'\n# Starts migration at this svn revision\nSTARTING_REVISION = 0\n# Directory of the new project with the git repository\nNEW_PROJECT_DIR = 'C:\/CodesysProjects\/CodesysProjectNr1'\n# Name of the new project\nNEW_PROJECT_NAME = 'CodesysProjectNr1'\n# Is the project a library (otherwise will be checked out as a project)\nIS_LIBRARY = False\n# Path to the local git repository of the new project\nNEW_PROJECT_REPO_DIR = 'C:\/CodesysProjects\/CodesysProjectNr1\/repo'\n\n# Path to an EMPTY temporary folder (doesn't have to exist) that can be deleted\nTEMP_PATH = 'C:\/CodesysProjects\/CodesysProjectNr1\/temp'\n\n# Author of the git commits\nAUTHOR_NAME = 'Author Name'\n# E-mail address of the git commits\nAUTHOR_EMAIL = 'Author.Name@e-mail.com'\n\n# Name of the branch that should contain the history\n# Can't be named 'master'\nTARGET_BRANCH_NAME = 'develop'\n# Initial commit messages on the master branch and the target branch\nIC_MSG_MASTER = 'master: Initial commit.'\nIC_MSG_TARGET_BRANCH = 'develop: Initial commit.'\n\n# Removes the newly created project and its repository if the migration fails\nREMOVE_MAIN_PROJECT_ON_FAILURE = True\n\n\ndef get_git_commit_msg(svn_log):\n \"\"\" Returns the commit messages that will be seen in the resulting git history\n Can be customized to ones demands.\n *svn_log* see: https:\/\/content.helpme-codesys.com\/en\/ScriptingEngine\/ScriptSubversion.html#ScriptSubversion.LogInfo\n \"\"\"\n return 'SVN revision %d: %s' % (svn_log.revision, svn_log.message)\n\n\n\"\"\" --- migration script ---\n\"\"\"\n# Type extension of the project (.project \/ .library)\nPROJECT_FILE_TYPE_EXTENSION = '.library' if IS_LIBRARY else '.project'\n# Path to your new Git project\nNEW_MAIN_PROJECT_PATH = os.path.join(NEW_PROJECT_DIR, NEW_PROJECT_NAME + PROJECT_FILE_TYPE_EXTENSION)\n# Name of the temporarily added remote\nTEMP_REMOTE_NAME = 'remote1'\n# Temporary commit message will be overwritten\/amended (put what u like)\nTEMP_COMMIT_MSG = 'TEMP COMMIT: This will be overwritten'\n\n\ndef create_git_project():\n \"\"\" 1. Creates a new project at *NEW_MAIN_PROJECT_PATH*\n 2. Initializes it in git with the repository at *NEW_PROJECT_REPO_DIR*\n 3. Makes an initial commit with the message *IC_MSG_MASTER*\n 4. Creates and switches to the target branch *TARGET_BRANCH_NAME*\n 5. Makes an initial commit on the target branch with the message *IC_MSG_TARGET_BRANCH*\n 6. Saves and closes the project\n \"\"\"\n git_project = projects.create(NEW_MAIN_PROJECT_PATH)\n git_project.git.init(NEW_PROJECT_REPO_DIR)\n git_project.git.commit_complete(IC_MSG_MASTER, AUTHOR_NAME, AUTHOR_EMAIL)\n\n git_project, git_branch = git_project.git.branch_copy(TARGET_BRANCH_NAME, checkout=True)\n git_project.git.commit_complete(IC_MSG_TARGET_BRANCH, AUTHOR_NAME, AUTHOR_EMAIL, bAllowEmptyCommits=True)\n\n git_project.save()\n git_project.close()\n\n\ndef remove_all_children(project):\n \"\"\" Removes all objects that can be removed from the project *project*\n \"\"\"\n children = project.get_children(recursive=True)\n for child in children:\n try:\n child.remove()\n except Exception as ex:\n if not 'Object reference not set to an instance of an object.' == str(ex):\n logging.error(ex)\n\n\ndef create_git_repo_from_svn_revision(svn_log):\n \"\"\" 1. Checks out a project from the SVN server *SVN_REPO_URL*\n 2. Disconnects it from SVN\n 3. Initiates it in git with the repository at *repo_dir*\n 4. Makes a commit with the message *commit_message*\n 4.1 See \"get_git_commit_msg\" to customize the commit message\n 5. Saves and closes the project\n 6. Returns the path of the project and path of the repository\n \"\"\"\n project_path = os.path.join(TEMP_PATH, 'revision_' + str(svn_log.revision) + PROJECT_FILE_TYPE_EXTENSION)\n repo_dir = os.path.join(TEMP_PATH, 'repo_' + str(svn_log.revision))\n commit_message = get_git_commit_msg(svn_log)\n\n temp_project_name = 'revision_%d' % svn_log.revision\n svn_project = svn.checkout(SVN_REPO_URL, TEMP_PATH, temp_project_name, svn_log.revision, as_library=IS_LIBRARY)\n\n svn_project.svn.disconnect()\n svn_project.git.init(repo_dir)\n svn_project.git.commit_complete(commit_message, AUTHOR_NAME, AUTHOR_EMAIL)\n svn_project.save()\n svn_project.close()\n\n return project_path, repo_dir\n\n\ndef magic_git_pull(project, temp_repo_path, svn_log):\n \"\"\" 1. Removes everything from the *project* (to insure svn revision and git commit match exactly)\n 2. Pulls from the repo at *repo_path*\n 4. Commits the changes with the commit message *commit_message*\n 5. Saves and closes the project\n \"\"\"\n remove_all_children(project)\n\n # Temp commit for fake git merge --squash\n project.git.commit_complete(TEMP_COMMIT_MSG, AUTHOR_NAME, AUTHOR_EMAIL, bAllowEmptyCommits=True)\n\n project.git.remote_add(TEMP_REMOTE_NAME, temp_repo_path)\n project.git.fetch(TEMP_REMOTE_NAME)\n project.git.branch_track('refs\/remotes\/%s\/master' % TEMP_REMOTE_NAME, TARGET_BRANCH_NAME)\n\n pull_options = git.get_pull_options()\n pull_options.fast_forward_strategy = GitFastForwardStrategy.NoFastForward\n pull_options.resolve_file_conflict_strategy = GitResolveFileConflictStrategy.Theirs\n project, merge_result = project.git.pull(AUTHOR_NAME, AUTHOR_EMAIL, pull_options)\n\n commit_message = get_git_commit_msg(svn_log)\n project.git.commit_complete(commit_message, AUTHOR_NAME, AUTHOR_EMAIL, bAllowEmptyCommits=True, bAmendCommit=True)\n\n project.git.branch_unset_upstream()\n project.git.remote_remove(TEMP_REMOTE_NAME)\n\n project.save()\n project.close()\n\n\ndef remove_repo(project_path):\n try:\n project = projects.open(project_path)\n project.git.de_init(True)\n project.close()\n except:\n pass\n\n\ndef remove_temp_project(project_path):\n \"\"\" Opens the project at *project_path* and deinitializes its git repository\n This needs to be done because the script can't delete the repository with \"shutil.rmtree\"\n Removes the rest of the contents int the folder at *TEMP_PATH*\n Removes the temporary .project\/.library files and their associated files\n \"\"\"\n remove_repo(project_path)\n try:\n shutil.rmtree(TEMP_PATH)\n os.makedirs(TEMP_PATH)\n except Exception as e:\n logging.error('Failed to delete %s. Reason: %s' % (TEMP_PATH, e))\n\n\ndef main():\n if projects.primary is not None:\n projects.primary.close()\n\n create_git_project()\n\n # get the list of all revision of SVN_REPO_URL\n # oldest to newest\n # starting at revision STARTING_REVISION + 1\n svn_logs = list(reversed(svn.get_log(SVN_REPO_URL)))\n svn_logs_to_migrate = [log for log in svn_logs if STARTING_REVISION <= log.revision]\n assert svn_logs_to_migrate, ('Nothing to migrate. STARTING_REVISION is greater than the newest '\n 'revision in %s') % SVN_REPO_URL\n\n system.prompt_answers['LossOfDataWarning2'] = PromptResult.Yes\n no_project_root_dir_amount = 0\n try:\n for svn_log in svn_logs_to_migrate:\n try:\n temp_project_path, temp_git_repo_path = create_git_repo_from_svn_revision(svn_log)\n\n # pull to your main Git project\n git_project = projects.open(NEW_MAIN_PROJECT_PATH)\n\n magic_git_pull(git_project, temp_git_repo_path, svn_log)\n\n # can be omitted if enough storage space is available (big performance increase)\n # if omitted the folder at \"TEMP_PATH\" needs to be deleted manually\n # needed storage space = (project file size + project git repository size) * revisions\n # example: 255.16 MB = (1.6 KB + 2.55 MB) * 100\n remove_temp_project(temp_project_path)\n except ValueError as ve:\n # Early svn revisions often do not contain a codesys project\n if ('The URL %s is not a project root directory.' % SVN_REPO_URL) == str(ve):\n no_project_root_dir_amount += 1\n if no_project_root_dir_amount < len(svn_logs_to_migrate):\n logging.info(ve)\n continue\n logging.critical(ve)\n raise\n except:\n if REMOVE_MAIN_PROJECT_ON_FAILURE:\n remove_repo(NEW_MAIN_PROJECT_PATH)\n for file in os.listdir(NEW_PROJECT_DIR):\n if file.startswith(NEW_PROJECT_NAME):\n os.remove(os.path.join(NEW_PROJECT_DIR, file))\n raise\n finally:\n system.prompt_answers.clear()\n\n\nif __name__ == '__main__':\n main()\n\n " }, 
{ "title" : "Script pour vérifier le résultat du transfert ", 
"url" : "_git_best_practises.html#UUID-0db9904c-7b98-8597-0cc3-db21ff9c2524_section-idm53402698265504", 
"breadcrumbs" : "CODESYSGit \/ Meilleures pratiques \/ Transférer un projet de CODESYS SVN à CODESYS Git \/ Script pour vérifier le résultat du transfert ", 
"snippet" : "Le script suivant effectue les vérifications suivantes : Vérifiez s'il existe ou non un commit Git correspondant dans le CODESYS Git projet après le transfert pour chaque révision SVN du tronc d'un CODESYS SVN projet Vérifiez si oui ou non le CODESYS projet d'une révision SVN et le CODESYS Les proje...", 
"body" : "Le script suivant effectue les vérifications suivantes : Vérifiez s'il existe ou non un commit Git correspondant dans le CODESYS Git projet après le transfert pour chaque révision SVN du tronc d'un CODESYS SVN projet Vérifiez si oui ou non le CODESYS projet d'une révision SVN et le CODESYS Les projets du commit Git correspondant sont identiques La comparaison d'un CODESYS le projet est basé sur le CODESYS environnement de développement où le transfert et la vérification sont effectués. La méthode de script habituelle compare_to() dans CODESYS ne se comporte pas comme prévu dans ce contexte. Pour cette raison, une solution de contournement est utilisée dans le script. import os\nimport logging\n\n\n\"\"\" --- inputs ---\n\"\"\"\n# URL of the SVN project you want to check the migration for\nSVN_REPO_URL = 'svn:\/\/your.svnserver.com\/trunk\/CodesysProjectNr1'\n# Directory of the project with git repository to check\nPROJECT_DIR = 'C:\/CodesysProjects\/CodesysProjectNr1'\n# Name of the project to check\nPROJECT_NAME = 'CodesysProjectNr1'\n# Is the project a library (otherwise will be checked out as a project)\nIS_LIBRARY = False\n\n# Path to an EMPTY temporary folder (doesn't have to exist) that can be deleted\nTEMP_PATH = 'C:\/CodesysProjects\/CodesysProjectNr1\/temp'\n\n# Name of the branch that should be checked\nTARGET_BRANCH_NAME = 'develop'\n\n\"\"\" --- check script ---\n\"\"\"\n# Type extension of the project (.project \/ .library)\nPROJECT_FILE_TYPE_EXTENSION = '.library' if IS_LIBRARY else '.project'\n# Path to your new Git project\nMAIN_PROJECT_PATH = os.path.join(PROJECT_DIR, PROJECT_NAME + PROJECT_FILE_TYPE_EXTENSION)\n\n\ndef get_revision_from_commit_msg(msg):\n \"\"\" filters out the revision number from the commit message *msg*\n migrated SVN commits in git: git commit = 'SVN revision *revision number*: *svn commit message*'\n if your migrated svn commits in git are different this possibly won't work\n \"\"\"\n s_num = ''\n for c in msg:\n if c.isdigit():\n s_num = s_num + c\n if ':' == c:\n break\n return int(s_num)\n\n\ndef compare_changed_objects_workaround(changed_objects):\n \"\"\" Compares the changed objects in the *changed_objects* list\n by comparing their content\n Returns True if the objects are identical (not changed)\n \"\"\"\n for changed_object in changed_objects:\n if changed_object.left_object is None:\n return False\n if changed_object.right_object is None:\n return False\n if not changed_object.left_object.textual_declaration.text == changed_object.right_object.textual_declaration.text:\n logging.error('Compared objects are not the same:')\n logging.error('left: %s\/%s' %\n (changed_object.left_object.parent.get_name(), changed_object.left_object.get_name()))\n logging.error(changed_object.left_object.textual_declaration.text)\n logging.error('right: %s\/%s' %\n (changed_object.right_object.parent.get_name(), changed_object.right_object.get_name()))\n logging.error(changed_object.right_object.textual_declaration.text)\n logging.error('diff: ' + str(changed_object.differences))\n logging.error('-----------------------------------------------------')\n return False\n return True\n\n\ndef compare_projects(project_one, project_two):\n \"\"\" Compares two projects\n Returns True if they are identical\n \"\"\"\n comparison_result = project_one.compare_to(project_two, flags=ComparisonFlags.IGNORE_PROPERTIES)\n changed_objects = list(comparison_result.get_changed_objects())\n\n if 0 == len(changed_objects):\n return True\n else:\n return compare_changed_objects_workaround(changed_objects)\n\n\ndef main():\n system.prompt_handling = PromptHandling.LogSimplePrompts\n\n if projects.primary is not None:\n projects.primary.close()\n\n git_project = projects.open(MAIN_PROJECT_PATH)\n\n git_project, git_branch = git_project.git.checkout(TARGET_BRANCH_NAME, force=True)\n\n git_logs = list(reversed(list(git_project.git.log())))\n\n system.prompt_answers['LossOfDataWarning2'] = PromptResult.Yes\n\n checks_done = 0\n try:\n for git_log in git_logs:\n if 'SVN revision ' in git_log.message_string:\n git_project, git_null_branch = git_project.git.checkout(git_log.sha_string)\n\n revision = get_revision_from_commit_msg(git_log.message_string)\n\n temp_project = svn.checkout(SVN_REPO_URL, TEMP_PATH, 'revision_' + str(revision), revision,\n as_library=IS_LIBRARY ,as_primary_project=False)\n\n if not compare_projects(git_project, temp_project):\n prompt_message = (\"Revision %d does not equal it's corresponding git commit. \"\n \"Do you want to continue?\") % revision\n logging.error(prompt_message)\n prompt_result = system.ui.prompt(prompt_message, PromptChoice.YesNo, PromptResult.No)\n if PromptResult.No == prompt_result:\n temp_project.close()\n break\n\n checks_done += 1\n temp_project.close()\n finally:\n system.prompt_answers.clear()\n git_project, git_branch = git_project.git.checkout(TARGET_BRANCH_NAME)\n git_project.close()\n\n if checks_done:\n system.ui.prompt('Done', PromptChoice.OK, PromptResult.OK)\n else:\n error_msg = 'No migrated commits found. If you have custom commit messages change this script accordingly.'\n logging.error(error_msg)\n raise Exception(error_msg)\n\n\nif __name__ == '__main__':\n main()\n \n " }, 
{ "title" : "Conflits de fusion, « problèmes relationnels » ", 
"url" : "_git_merge_conflicts.html", 
"breadcrumbs" : "CODESYSGit \/ Conflits de fusion, « problèmes relationnels » ", 
"snippet" : "Une opération de fusion fusionne le contenu de deux branches qui ont un ancêtre commun mais qui ont reçu des modifications différentes. La fusion ciblée de succursales se fait principalement dans Branches Git visualiser à l'aide de la Fusionner commande. Une opération de fusion est également incluse...", 
"body" : "Une opération de fusion fusionne le contenu de deux branches qui ont un ancêtre commun mais qui ont reçu des modifications différentes. La fusion ciblée de succursales se fait principalement dans Branches Git visualiser à l'aide de la Fusionner commande. Une opération de fusion est également incluse dans une action d'extraction. Différents états des branches source et cible sont détectés lors de l'opération de fusion et sont appelés conflits. Une structure de projet non autorisée résultant d'une fusion est identifiée comme un « problème relationnel ». En fonction de l'option sélectionnée, CODESYS Git essaie de résoudre automatiquement ces conflits dans la mesure du possible, ou cette résolution est laissée à l'utilisateur. Une fois le conflit résolu, CODESYS Git essaie toujours de Resynchroniser (relisez le projet depuis le stockage de projets). Cela se fait en fermant le projet qui est ouvert dans CODESYS et en créer un nouveau à partir du stockage. CODESYS Git fait la distinction entre deux types de problèmes à résoudre qui peuvent survenir lors de la fusion : Conflits : Conflits purement Git : un ou plusieurs objets ont reçu des modifications concurrentes. Il peut s'agir de différentes modifications du contenu d'un objet. La \"stratégie de conflit de fusion\" de base est définie dans le Options de fusion Git dans le Branches Git voir. En fonction de ce paramètre, soit une résolution automatique des conflits s'exécute chaque fois que possible, soit une action d'acceptation de base est effectuée dans une direction spécifique, soit les conflits sont gérés manuellement. En cas de résolution manuelle des conflits, les objets en conflit sont affichés tels quels dans la Statut et mise en scène voir. Double-cliquer sur un objet en conflit ouvre une vue de comparaison. Dans la vue de comparaison, les changements provenant des deux branches sont affichés côte à côte. Vous pouvez nettoyer les différences de contenu en les acceptant spécifiquement. S'il s'agit uniquement de conflits d'espace de noms, vous devez les résoudre en les renommant ou en les supprimant dans l'arborescence du projet. Cliquez sur \"Appliquer\" pour résoudre le conflit. Après cela, l'objet précédemment en conflit est automatiquement déplacé vers la zone \"Modifications par étapes\". \"Problèmes relationnels\"  : des modifications concurrentes ont entraîné une structure de projet non valide dans CODESYS , qui ne peut pas être géré par la fonction de fusion Git. Des modifications peuvent avoir été apportées en externe dans le système de fichiers avec des outils externes. Soit une création concurrente d'un objet de même type et\/ou de même nom a été commitée depuis différentes branches, et cet objet se trouve alors dans le même espace de noms dans le CODESYS projet. Ceci n'est pas autorisé dans un CODESYS projet. Ou une relation d'objet père\/enfant non valide s'est produite. Une autre possibilité est que les problèmes relationnels proviennent de fusions précédentes, où ils ont été délibérément ignorés afin de pouvoir continuer à travailler pour le moment. Par exemple, il arrive que deux configurations d'alarme soient insérées sous un appareil, ce qui n'est pas autorisé. L'utilisateur doit corriger manuellement la structure du projet en utilisant les moyens disponibles (fusionner un objet dans un autre, supprimer, renommer ou déplacer) pour obtenir à nouveau un projet cohérent. À partir de la version 1.2.0.0, un projet peut également être traité plus avant avec des problèmes de relation existants (ignorer). Attention : Dans ce cas, les modifications apportées au projet sont annulées par une resynchronisation ultérieure. Raison : L'opération de resynchronisation charge la version du projet à partir du système de fichiers qui a été enregistrée avant que le problème de relation Dans le Statut et mise en scène vue, vous, en tant qu'utilisateur, pouvez vérifier et modifier un conflit comme suit : Des commandes utiles sont disponibles dans le menu contextuel d'un objet en conflit. La sélection actuelle dépend de la situation : Afficher tous les objets concernés \/ Afficher cet objet : Les objets ou l'objet seront mis en surbrillance dans Dispositifs vision du projet. Résoudre en utilisant le leur : Le statut de la branche source est appliqué. Résoudre en utilisant le nôtre : Le statut de la branche cible est appliqué. Résoudre automatiquement : CODESYS Git essaie de consolider les changements lui-même. Marquer comme résolu : L'objet qui existe actuellement dans le projet est appliqué et considéré comme la résolution du conflit. L'objet correspondant a été mis en scène. Ignorer le problème de relation : Le problème de relation est ignoré jusqu'à la prochaine resynchronisation. Cela peut être utile lorsque vous souhaitez uniquement pouvoir continuer à travailler sur un projet et que le conflit n'a pas d'importance pour cela. Double-cliquer sur un objet en conflit ouvre la vue de comparaison des contenus des branches source et cible. Dans le cas de contenus concurrents, les contenus peuvent être appliqués d'une branche à l'autre comme vous le souhaitez. Dans le messages vue, vous pouvez double-cliquer sur un message d'erreur pour un conflit afin d'ouvrir l'objet concerné. " }, 
{ "title" : "Utilisation de l'interface de script Git ", 
"url" : "_git_using_scripting.html", 
"breadcrumbs" : "CODESYSGit \/ Utilisation de l'interface de script Git ", 
"snippet" : "CODESYS Git fournit une interface de script pour Git. Des exemples d'utilisation de l'interface sont présentés ci-dessous. Vous trouverez également ci-dessous des informations sur la sortie textuelle des messages générés par de nombreuses opérations Git Pour plus d'informations, voir : Documentation...", 
"body" : "CODESYS Git fournit une interface de script pour Git. Des exemples d'utilisation de l'interface sont présentés ci-dessous. Vous trouverez également ci-dessous des informations sur la sortie textuelle des messages générés par de nombreuses opérations Git Pour plus d'informations, voir : Documentation de l'API du moteur de script " }, 
{ "title" : "Exigences ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm53403339456886", 
"breadcrumbs" : "CODESYSGit \/ Utilisation de l'interface de script Git \/ Exigences ", 
"snippet" : "Pour exécuter les exemples ci-dessous, les éléments suivants sont requis : CODESYS 3.5.19.30 ou supérieur Les composants suivants sont également requis : CODESYS Library Documentation Support (pour créer la bibliothèque compilée) CODESYS Git 1.6.0.0 ou version ultérieure Une installation Git locale ...", 
"body" : "Pour exécuter les exemples ci-dessous, les éléments suivants sont requis : CODESYS 3.5.19.30 ou supérieur Les composants suivants sont également requis : CODESYS Library Documentation Support (pour créer la bibliothèque compilée) CODESYS Git 1.6.0.0 ou version ultérieure Une installation Git locale Utilisez des mots de passe SecureString dans la mesure du possible Pour une sécurité accrue, les mots de passe doivent être transmis sous forme de .NET SecureString. Les opérations GIT concernées sont les suivantes : clone , fetch , pull , push SecureStrings peut être créé dans IronPython comme suit. Le « mot de passe » lui-même doit provenir d'une chaîne sécurisée et non, comme ici à des fins de démonstration, être en texte brut dans le script. En interne, chaque mot de passe fourni est géré de manière sécurisée from System.Security import SecureString \n\n sec_str_password = SecureString()\n for c in \"Passwort\": \n sec_str_password.AppendChar(c) Pour des mesures de sécurité supplémentaires lors de l'utilisation CODESYS Git voir : Sécurité pour CODESYS Git " }, 
{ "title" : "Préparation ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm53403341267380", 
"breadcrumbs" : "CODESYSGit \/ Utilisation de l'interface de script Git \/ Préparation ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CODESYS bibliothèque ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm56806682534762", 
"breadcrumbs" : "CODESYSGit \/ Utilisation de l'interface de script Git \/ Préparation \/ CODESYS bibliothèque ", 
"snippet" : "Parce que non CODESYS les bibliothèques sont actuellement gérées dans Git, les sources d'un CODESYS une bibliothèque est requise. String Functions.library bibliothèque de CODESYS String Libraries le produit est utilisé dans les exemples....", 
"body" : "Parce que non CODESYS les bibliothèques sont actuellement gérées dans Git, les sources d'un CODESYS une bibliothèque est requise. String Functions.library bibliothèque de CODESYS String Libraries le produit est utilisé dans les exemples. " }, 
{ "title" : "Dépôt Git distant ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm566365154713912", 
"breadcrumbs" : "CODESYSGit \/ Utilisation de l'interface de script Git \/ Préparation \/ Dépôt Git distant ", 
"snippet" : "Pour cet exemple, un référentiel Git nu dans le système de fichiers est utilisé comme référentiel distant. Pour vous préparer, supprimez d’abord le répertoire correspondant puis créez-en un nouveau. import shutil import os  def prepare_empty_dir(empty_dir_path):     print(\"Prepare empty directory at...", 
"body" : "Pour cet exemple, un référentiel Git nu dans le système de fichiers est utilisé comme référentiel distant. Pour vous préparer, supprimez d’abord le répertoire correspondant puis créez-en un nouveau. import shutil\nimport os \n\ndef prepare_empty_dir(empty_dir_path):\n    print(\"Prepare empty directory at\", empty_dir_path)\n    shutil.rmtree(empty_dir_path, ignore_errors=True)\n    if not(os.path.exists(empty_dir_path) and os.path.isdir(empty_dir_path)):\n        os.makedirs(empty_dir_path) Un dépôt Git vide est ensuite créé. import subprocess\ndef create_bare_git_repository(bare_repository_path):\n    print(\"Create bare git repository at\", bare_repository_path)\n    create_bare_repository_cmd = 'cmd \/c \"git -C \\\"' + bare_repository_path + '\\\" init --bare\"'\n    try:\n        retcode = subprocess.call(create_bare_repository_cmd, shell=True)\n        if retcode < 0:\n            raise Exception(\"Creating bare git repository at \" + bare_repository_path + \" failed: \", -retcode)\n        else:\n            print(\"Creating bare git repository at \" + bare_repository_path + \" succeeded.\")\n    except Exception as e:\n        print(\"[ERROR] Creating bare git repository failed: \", e)\n        raise Le dépôt Git vide est rempli avec le contenu du CODESYS bibliothèque. def initialize_bare_git_repository(library_path, local_repository_path, bare_repository_path):\n    print(\"Open library:\", library_path)\n    project = projects.open(library_path)\n     \n print(\"Initiate local git repository\")\n    project.git.init(local_repository_path)\n    project.git.commit_complete(\"Create git repo for lib\", \"user\", \"mail@mail\")\n     \n print(\"Push to remote git repository\")\n    origin_remote = project.git.remote_add(\"origin\", bare_repository_path)\n    project.git.branch_set_upstream_to(origin_remote)\n    project.git.push()\n    project.git.de_init(cleanUpFileSystem=True)\n    project.close() Le script suivant exécute les fonctions décrites. import os\n\ndef main():\n    if projects.primary:\n        projects.primary.close()\n\n    basepath = \"C:\\\\CODESYS_Projects\\\\Git_Scripting_Tutorial\\\\\"\n\n    project_basepath = os.path.join(basepath, \"projects\\\\\")\n    library_file_name = \"ExampleLib1.library\"\n    library_path = os.path.join(project_basepath, library_file_name)\n\n    remote_repo_basepath = os.path.join(basepath, \"remotes\\\\\")\n    remote_repo_directory_name = \"ExampleLib1RemoteRepo\"\n    remote_repo_path = os.path.join(remote_repo_basepath, remote_repo_directory_name)\n\n    local_repo_basepath = os.path.join(basepath, \"repos\\\\\")\n    local_repo_directory_name = \"ExampleLib1LocalRepo\"\n    local_repo_path = os.path.join(local_repo_basepath, local_repo_directory_name)\n\n    print(\"Create and push library to remote git repository\")\n    \n prepare_empty_dir(remote_repo_path)\n    create_bare_git_repository(remote_repo_path)\n    initialize_bare_git_repository(library_path, local_repo_path, remote_repo_path)\n\n    print(\"[Success] All done\")\n\n\nif __name__ == '__main__':\n    main() Le référentiel Git nu ainsi créé et fourni avec son contenu est utilisé pour les autres exemples. " }, 
{ "title" : "Clonage d'un dépôt Git distant ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm53403354678654", 
"breadcrumbs" : "CODESYSGit \/ Utilisation de l'interface de script Git \/ Préparation \/ Clonage d'un dépôt Git distant ", 
"snippet" : "La fonction suivante exécute git clone pour un dépôt Git distant. def clone_git_repository(project_basepath, project_file_name, remote_repo_url_or_path, local_repo_path):     update_flags = VersionUpdateFlags.UpdateAll | VersionUpdateFlags.SilentMode     project = git.clone(project_basepath, project...", 
"body" : "La fonction suivante exécute git clone pour un dépôt Git distant. def clone_git_repository(project_basepath, project_file_name, remote_repo_url_or_path, local_repo_path):\n    update_flags = VersionUpdateFlags.UpdateAll | VersionUpdateFlags.SilentMode    \n project = git.clone(project_basepath, project_file_name, remote_repo_url_or_path, local_repo_path, update_flags=update_flags)\n    project.save()\n    return project " }, 
{ "title" : "Créer et fusionner une nouvelle branche ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_id_CopyofCODESYSGitScriptingUsage-ErstellenundMergeneinesneuenBranches", 
"breadcrumbs" : "CODESYSGit \/ Utilisation de l'interface de script Git \/ Préparation \/ Créer et fusionner une nouvelle branche ", 
"snippet" : "La fonction auxiliaire suivante crée de nouveaux objets dans un CODESYS projet à titre d'exemple. def add_dut(project): ST_STRUCT_STR = \"\"\"\\ a : BOOL; b : BIT; c : BIT; \"\"\" ST_UNION_STR = \"\"\"\\ TYPE ExampleUnion : UNION Zahl : INT; Prozent : ExampleAlias; Bits : ExampleStruct; END_UNION END_TYPE \"\"\" ...", 
"body" : "La fonction auxiliaire suivante crée de nouveaux objets dans un CODESYS projet à titre d'exemple. def add_dut(project):\n ST_STRUCT_STR = \"\"\"\\\n a : BOOL;\n b : BIT;\n c : BIT;\n \"\"\"\n\n ST_UNION_STR = \"\"\"\\\n TYPE ExampleUnion :\n UNION\n Zahl : INT;\n Prozent : ExampleAlias;\n Bits : ExampleStruct;\n END_UNION\n END_TYPE\n \"\"\"\n\n # Create a struct DUT and insert the list of variables just into the right\n   # place in line two, row 0 (line numbering starts with line 0)\n   example_dut_struct = project.create_dut('ExampleStruct') # DutType.Structure is the default\n   example_dut_struct.textual_declaration.insert(2, 0, ST_STRUCT_STR) \n\n   # Alias types get their \"content\" via the base type, which will just end up \n   # as one line in the declaration part:    \n # TYPE MyAlias : INT (0..100); END_TYPE \n   example_dut_alias = project.create_dut('ExampleAlias', DutType.Alias, \"INT (0..100)\") \n\n   # Instead of injecting the variables into the existing declaration, \n   # one can also just replace the complete declaration part, including the \n   # boilerplate code.\n   example_dut_union = project.create_dut('ExampleUnion', DutType.Union)\n   example_dut_union.textual_declaration.replace(ST_UNION_STR) La fonction auxiliaire suivante incrémente la version de build dans les informations de projet d'un CODESYS projet. def increment_build_version(project):\n \"\"\"\n Increment build version in project info.\n \"\"\"\n info = project.get_project_info()\n old_version = info.version\n info.version = (old_version.Major, old_version.Minor, old_version.Build + 1, 0)\n project.save() La fonction suivante crée d'abord une nouvelle branche et apporte des modifications à cette branche, puis fusionne ces modifications dans la branche principale. def copy_branch_and_merge(project):\n current_branch = project.git.branch_show_current()\n print(\"Current branch: \", current_branch.friendly_name)\n project, current_branch = project.git.branch_copy(current_branch, \"new_branch\", checkout=True)\n print(\"Current branch: \", current_branch.friendly_name)\n\n add_dut(project)\n project.git.commit_complete(\"Added DUT\", \"user\", \"mail@mail\")\n\n increment_build_version(project)\n project.git.commit_complete(\"Incremented build version\", \"user\", \"mail@mail\")\n\n project, current_branch = project.git.checkout(\"master\")\n print(\"Current branch: \", current_branch.friendly_name)\n project, merge_result = project.git.merge(\"new_branch\")\n print(\"Merged: \", merge_result.ToString())\n project.save()\n return project Le script suivant s'exécute git clone pour un dépôt Git distant, apporte des modifications au projet, puis transmet les modifications au référentiel Git distant ( CopyBranchAndMerge.py ). def main():\n    if projects.primary: \n       projects.primary.close()\n\n    basepath = \"C:\\\\CODESYS_Projects\\\\Git_Scripting_Tutorial\\\\\"\n\n project_basepath = os.path.join(basepath, \"projects\\\\\")\n    library_file_name = \"ExampleLib1Cloned.library\"\n\n remote_repo_basepath = os.path.join(basepath, \"remotes\\\\\")\n    remote_repo_directory_name = \"ExampleLib1RemoteRepo\"\n    remote_repo_path = os.path.join(remote_repo_basepath, remote_repo_directory_name)\n\n local_repo_basepath = os.path.join(basepath, \"repos\\\\\")\n    local_repo_directory_name = \"ExampleLib1LocalRepo\"\n    local_repo_path = os.path.join(local_repo_basepath, local_repo_directory_name)\n\n print(\"Clone project\")\n    project = clone_git_repository(project_basepath, library_file_name, remote_repo_path, local_repo_path)\n project = copy_branch_and_merge(project)\n project.git.push()\n    project.save()\n    project.git.de_init(cleanUpFileSystem=True)\n    project.save()\n    project.close()\n print(\"[Success] All done\")\n\nif __name__ == '__main__':\n    main()) " }, 
{ "title" : "Création d'une bibliothèque compilée ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm53403356979728", 
"breadcrumbs" : "CODESYSGit \/ Utilisation de l'interface de script Git \/ Préparation \/ Création d'une bibliothèque compilée ", 
"snippet" : "Le script suivant s'exécute git clone pour un CODESYS bibliothèque source à partir d'un référentiel Git distant, puis crée une bibliothèque compilée à partir de celui-ci ( CreateCompiledLibrary.py ). import os class CompileError(Exception): pass def clone_git_repository(project_basepath, project_fil...", 
"body" : "Le script suivant s'exécute git clone pour un CODESYS bibliothèque source à partir d'un référentiel Git distant, puis crée une bibliothèque compilée à partir de celui-ci ( CreateCompiledLibrary.py ). import os\n\nclass CompileError(Exception):\n pass\n\ndef clone_git_repository(project_basepath, project_file_name, remote_repo_url_or_path, local_repo_path):\n update_flags = VersionUpdateFlags.UpdateAll | VersionUpdateFlags.SilentMode\n project = git.clone(project_basepath, project_file_name, remote_repo_url_or_path, local_repo_path, update_flags=update_flags)\n project.save()\n return project\n\ndef create_compiled_library(project):\n # requires the CODESYS Library Documentation Support Package!\n project.check_all_pool_objects()\n compile_result_message = system.get_messages(category='{97F48D64-A2A3-4856-B640-75C046E37EA9}')[-1]\n if \"0 errors\" in compile_result_message:\n project.save_as_compiled_library(destination_name=None)\n else:\n raise CompileError(\"Compile failed: \" + compile_result_message)\n return project\n\nbasepath = \"D:\\\\JiraTickets\\\\GIT-145\\\\\"\n\nproject_basepath = os.path.join(basepath, \"projects\\\\\")\n\nremote_repo_basepath = os.path.join(basepath, \"remotes\\\\\")\nremote_repo_directory_name = \"StringFunctions.git\"\nremote_repo_path = os.path.join(remote_repo_basepath, remote_repo_directory_name)\n\nlocal_repo_basepath = os.path.join(basepath, \"repos\\\\\")\nlocal_repo_path = os.path.join(local_repo_basepath, \"StringFunctions.git\")\n\nprint(\"Clone project\")\nproject = clone_git_repository(project_basepath, \"String Functions Cloned.library\", remote_repo_path, local_repo_path)\nproject = create_compiled_library(project)\nproject.git.de_init(cleanUpFileSystem=True)\nproject.close()\n\nprint(\"[Success] All done\") " }, 
{ "title" : "Installer une bibliothèque à partir d'un référentiel Git distant ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm53403357071816", 
"breadcrumbs" : "CODESYSGit \/ Utilisation de l'interface de script Git \/ Préparation \/ Installer une bibliothèque à partir d'un référentiel Git distant ", 
"snippet" : "Le script suivant s'exécute git clone pour un CODESYS bibliothèque source à partir d'un référentiel Git distant et installe cette bibliothèque dans le CODESYS exemple ( InstallLibrary.py ). import os def clone_git_repository(project_directory_path, project_file_name, remote_repo_url_or_path, local_r...", 
"body" : "Le script suivant s'exécute git clone pour un CODESYS bibliothèque source à partir d'un référentiel Git distant et installe cette bibliothèque dans le CODESYS exemple ( InstallLibrary.py ). import os\n\ndef clone_git_repository(project_directory_path, project_file_name, remote_repo_url_or_path, local_repo_path):\n    update_flags = VersionUpdateFlags.UpdateAll | VersionUpdateFlags.SilentMode\n    project = git.clone(project_directory_path, project_file_name, remote_repo_url_or_path, local_repo_path, update_flags=update_flags)\n    project.save()\n    return project\n\ndef install_library(project):\n    library_repo = librarymanager.repositories[0]\n    librarymanager.install_library(project.path, library_repo, True)\n\ndef main():\n    if projects.primary:\n        projects.primary.close()\n\n     basepath = \"C:\\\\CODESYS_Projects\\\\Git_Scripting_Tutorial\\\\\"\n\n    project_basepath = os.path.join(basepath, \"projects\\\\\")\n    library_file_name = \"ExampleLib1Cloned2.library\"\n\n remote_repo_basepath = os.path.join(basepath, \"remotes\\\\\")\n    remote_repo_directory_name = \"ExampleLib1RemoteRepo\"\n    remote_repo_path = os.path.join(remote_repo_basepath, remote_repo_directory_name)\n\n    local_repo_basepath = os.path.join(basepath, \"repos\\\\\")\n    local_repo_directory_name = \"ExampleLib1LocalRepo\"\n    local_repo_path = os.path.join(local_repo_basepath, local_repo_directory_name)\n\n    print(\"Clone project\")\n    project = clone_git_repository(project_basepath, library_file_name, remote_repo_path, local_repo_path)\n\n print(\"Install library\")\n    install_library(project)\n    project.git.de_init(cleanUpFileSystem=True)\n    project.close()\n\n print(\"[Success] All done\")\n\nif __name__ == '__main__':\n    main() " }, 
{ "title" : "Sortie de message pour les opérations Git ", 
"url" : "_git_using_scripting.html#UUID-953fd16d-a6e9-80c5-4d45-fba27efa8b9a_section-idm234656140725653", 
"breadcrumbs" : "CODESYSGit \/ Utilisation de l'interface de script Git \/ Préparation \/ Installer une bibliothèque à partir d'un référentiel Git distant \/ Sortie de message pour les opérations Git ", 
"snippet" : "Lors de l'utilisation CODESYS Git , la plupart des commandes fournissent une sortie basée sur du texte. Lors de la course CODESYS dans la ligne de commande, cette sortie est automatiquement générée lors de l'exécution de CODESYS Git commandes via le pilote de script. Lors de l'utilisation CODESYS Gi...", 
"body" : "Lors de l'utilisation CODESYS Git , la plupart des commandes fournissent une sortie basée sur du texte. Lors de la course CODESYS dans la ligne de commande, cette sortie est automatiquement générée lors de l'exécution de CODESYS Git commandes via le pilote de script. Lors de l'utilisation CODESYS Git dans CODESYS Development System , les résultats apparaissent également dans la fenêtre de message. Structure of the messages: Git:<severity>: [<time>] <text> In the user interface of CODESYS Git , the output is reduced to: [<time>] <text> severity : catégorie de message. Les catégories vont de l'erreur purement informative à l'erreur critique time : Heure exacte du message. Format : HH:MM:SS text : Contenu du message. Pour les commandes Git standard, le contenu correspond à la commande de ligne de commande qui fournirait le même résultat que l'appel du pilote de script effectué. CODESYS Git commandes qui ne correspondent pas à une commande Git standard (par exemple, Restaurer le projet à partir du référentiel ), le texte du message explique l'action effectuée. Commands with multiple messages: Pour certaines commandes (par exemple, git log ), la sortie est divisée en plusieurs messages. Dans le cas de git log , chaque validation affichée est affichée dans un message distinct. Dans ce cas, afin de préciser que ces messages font partie du git log commande, une référence est faite à la commande d'origine dans les messages. " }, 
{ "title" : "Référence, interface utilisateur ", 
"url" : "_git_f_reference_user_interface.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Vues et dialogues ", 
"url" : "_git_struct_reference_views_dialogs.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Vues et dialogues ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Afficher : Git Status & Staging ", 
"url" : "_git_view_status.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Vues et dialogues \/ Afficher : Git Status & Staging ", 
"snippet" : "Git Status & Staging Symbole: Commande Git correspondante : git status Fonction : La vue montre l'état Git des objets et des fichiers qui ont changé ou sont nouveaux depuis le dernier commit. Les modifications peuvent être mises en place pour un commit ici et validées. Une comparaison des modificati...", 
"body" : "Git Status & Staging Symbole: Commande Git correspondante : git status Fonction : La vue montre l'état Git des objets et des fichiers qui ont changé ou sont nouveaux depuis le dernier commit. Les modifications peuvent être mises en place pour un commit ici et validées. Une comparaison des modifications est possible directement et les modifications depuis le dernier commit peuvent être supprimées du répertoire de travail. Lorsque des conflits ou des problèmes relationnels surviennent à la suite d'une tentative de fusion, cela est illustré dans la vue ci-dessous. Appel : Git → Statut et mise en scène menu Exigence : Le projet ouvert est géré dans Git. Barre de titre: Bifurquer: <nom de la succursale> Dernière validation : <ID> Nom de la personne concernée bifurquer Le statut actuel de la branche est préfixé. Exemples : Fusion , Conflits non résolus ou Problèmes relationnels non résolus Cliquer sur le nom de la branche ouvre le Branches Git voir. Cliquer sur l'ID du dernier commit ouvre le Historique de Git voir. La vue est rafraîchie. Ignorer toutes les modifications ( git reset --hard ) Indépendamment d'une sélection dans le tableau, toutes les modifications sont ignorées, même toutes les modifications non mises en œuvre. Le projet est réinitialisé à l'état qu'il avait avant que toutes les modifications ne soient pas encore validées. Validation terminée ( git commit complete ) Ouvre le Valider les modifications par étapes et non par étapes boîte de dialogue (voir ci-dessous) Comparez les changements : Double-cliquez sur une entrée d'objet pour ouvrir une Vue de comparaison (\"Diff\"), qui montre les différences entre l'état actuel de l'objet ( Nouveau... ) et le dernier état validé ( base... ). Pour plus de détails, voir \"Vue de comparaison\" ci-dessous. Recherchez les objets concernés dans le navigateur de projet : Pour plus d'informations, consultez le Afficher cet objet et Afficher tous les objets concernés commandes dans le menu contextuel d'une entrée d'objet. Modifications par étapes La partie supérieure du Statut Git La vue montre les objets modifiés qui sont mis en scène pour un commit (index Git). C'est là que la mise en scène des commits est organisée et que les commits sont exécutés. Objet Chemin physique Chemin de l'objet modifié dans le projet Git Exemple: project\\device\\plc_logic\\application\\plc_prg Quand le Afficher les chemins physiques option dans le menu contextuel de Objet colonne est sélectionnée, la Chemin physique colonne avec le chemin complet de l'objet est également affichée. Exemple: project\\device_5aca2685\\plc_logic_b738fa32\\application_0dcb78bb\\plc_prg_33759ca0\\33759ca04 b4e4930a972d2050e97661a.object Menu contextuel d'une entrée d'objet : Afficher cet objet : L'objet est sélectionné dans le navigateur de projet. Afficher tous les objets concernés : Disponible à l'entrée d'un objet concerné par un conflit ou un problème de relation : Tous les objets pour lesquels le conflit n'a pas encore été résolu sont sélectionnés dans le navigateur de projet. État de l'index , Détails Statut Git de l'objet dans l'index (interne) Statuts possibles : : Inaltéré : L'objet est identique à l'état actuel dans le référentiel Git. : Nouveau (dans l'index) : L'objet a récemment été ajouté à l'index. Il n'existe pas dans le référentiel Git. : Modifié (dans l'index) : L'objet a été modifié par rapport à la version précédente dans l'index. Dans ce cas, la réponse peut être de commettre ( git commit ) ou annuler les modifications ( git reset ). La modification peut être supprimée de l'index ( git reset --mixed ): Annuler la mise en scène des modifications sélectionnées (git reset --mixed) La modification peut être complètement ignorée : Ignorer toutes les modifications ( git reset --hard ) : Supprimé : L'objet a été supprimé. Attention : Une opération de réinitialisation dans l'index peut écraser le contenu de l'objet dans le répertoire de travail. Ignorer toutes les modifications ( git reset --hard ) Indépendamment d'une sélection dans le tableau, toutes les modifications sont ignorées, même toutes les modifications non mises en œuvre. Le projet est réinitialisé à l'état qu'il avait avant que toutes les modifications ne soient pas encore validées. Validation terminée Ouvre le Valider les modifications par étapes et non par étapes dialogue Valider les modifications par étapes (git commit) Ouvre le Commettre des modifications par étapes dialogue Lors de la validation, toutes les modifications apportées à l'index (modifications par étapes) sont appliquées au nouveau commit. Les modifications dans le répertoire de travail (unstaged) ne sont pas appliquées. Annuler la mise en scène des modifications sélectionnées (git reset --mixed) Les modifications échelonnées pour le commit sont réinitialisées sur \"unstaged\". Les entrées de la fenêtre sont supprimées. Attention : Une opération de réinitialisation dans l'index peut écraser le contenu de l'objet dans le répertoire de travail. Modifications non échelonnées La partie inférieure du Statut Git La vue affiche toutes les modifications apportées au projet depuis le dernier commit et celles qui n'ont pas encore été mises en scène pour un commit. Ils peuvent désormais être mis en scène. Il peut s'agir de modifications d'objets déjà suivis dans le référentiel Git, ou encore d'objets \"non suivis\". Les objets \"non suivis\" n'ont pas encore été enregistrés dans le référentiel Git au moyen du Ajouter ( git add ) ou Commettre ( git commit ) commande. Objet Chemin physique Chemin de l'objet modifié dans le projet Git Exemple: project\\device\\plc_logic\\application\\plc_prg Pour l'affichage éventuel de Chemin physique , voir ci-dessus dans \"Modifications par étapes\". État de l'arborescence de travail , Détails Statut de l'objet dans le répertoire de travail : : Inaltéré (dans le répertoire de travail) : L'objet est inchangé par rapport à l'index. : Nouveau (dans le répertoire de travail) : l'objet existe dans le répertoire de travail, mais il n'est pas encore dans l'index ou le référentiel Git. : Supprimé (dans le répertoire de travail) : l'objet n'existe plus dans le répertoire de travail, mais il est suivi dans le référentiel Git (index). Il a déjà été ajouté une fois au moyen du git add et\/ou git commit commande. : Modifié (dans le répertoire de travail) : L'objet a été modifié par rapport à la version précédente dans l'index. : un conflit ou un problème de relation est survenu lors de la fusion de l'objet. Dans ce cas, le menu contextuel inclut les commandes suivantes pour gérer le conflit : Résoudre manuellement : Une vue de comparaison des deux commits concernés s'ouvre. Résoudre en utilisant 'ours': Le statut du commit le plus récent (\"Nouveau\") est appliqué. Résoudre en utilisant 'theirs' : Le statut de l'ancien commit ( base ) est appliqué. Lors de la validation après avoir traité le conflit, le message de validation inclut automatiquement une liste des objets affectés. : Changements d'étape ( git add ) Les modifications sélectionnées sont mises en scène pour le commit et déplacées vers le Modifications par étapes Région. : Annuler toutes les modifications non mises en scène (git clean & git checkout ) Toutes les modifications répertoriées dans le Modifications non échelonnées vue sont ignorées. : Basculer la sélection de toutes les modifications La sélection de toutes les modifications est sélectionnée ou désélectionnée. " }, 
{ "title" : "Boîte de dialogue : Valider les modifications par étapes ", 
"url" : "_git_view_status.html#UUID-d928d26b-8202-57f2-233c-383ef01152f6_id_c24a156863171e3cc0a8646329f090c1-id-76eeb06c64c0f307c0a86463133e3737", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Vues et dialogues \/ Afficher : Git Status & Staging \/ Boîte de dialogue : Valider les modifications par étapes ", 
"snippet" : "Symbole: Fonction  : Dans la boîte de dialogue, vous initiez une validation des modifications par étapes ou une validation vide. Appel : Validation terminée commande dans le Statut Git voir <user name and email> Nom et adresse e-mail du validateur Ces informations d'identification pour le référentie...", 
"body" : "Symbole: Fonction  : Dans la boîte de dialogue, vous initiez une validation des modifications par étapes ou une validation vide. Appel : Validation terminée commande dans le Statut Git voir <user name and email> Nom et adresse e-mail du validateur Ces informations d'identification pour le référentiel peuvent être enregistrées dans le fichier .gitconfig du référentiel local avec Souvenez-vous de moi . CODESYS Git les utilisera automatiquement pour les prochaines actions correspondantes. S'engager à <...> Destination du commit. Exemple: S'engager sur la branche 'refs\/heads\/master' <nom du committer> Nom et E-mail adresse de l'auteur Dans CODESYS Git , aucune distinction n'est faite entre l'auteur et l'auteur. Par conséquent, l'auteur est déjà spécifié ici en tant que committer. Message de validation Message de validation (obligatoire) Autoriser un commit vide : S'il n'y a pas de modifications dans le projet, un commit \"vide\" est effectué. Les commits vides sont utilisés comme une sorte de commentaire ou de marqueur dans l'historique. " }, 
{ "title" : "Boîte de dialogue : valider les modifications par étapes et non par étapes ", 
"url" : "_git_view_status.html#UUID-d928d26b-8202-57f2-233c-383ef01152f6_id_c24a156863171e3cc0a8646329f090c1-id-8a99954a5b645d73c0a8646331f25fbc", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Vues et dialogues \/ Afficher : Git Status & Staging \/ Boîte de dialogue : valider les modifications par étapes et non par étapes ", 
"snippet" : "Symbole: Fonction : Dans la boîte de dialogue, vous initiez la validation de toutes les modifications du projet, le statut \"staged\" étant ignoré. Comme dans le Commettre des modifications par étapes dialogue, vous devez spécifier un message de validation et fournir ou confirmer les informations de v...", 
"body" : "Symbole: Fonction : Dans la boîte de dialogue, vous initiez la validation de toutes les modifications du projet, le statut \"staged\" étant ignoré. Comme dans le Commettre des modifications par étapes dialogue, vous devez spécifier un message de validation et fournir ou confirmer les informations de validation. En option, un commit vide est également possible ici. Appel : Validation terminée commande dans le Statut Git voir " }, 
{ "title" : "Vue de comparaison ", 
"url" : "_git_view_status.html#UUID-d928d26b-8202-57f2-233c-383ef01152f6_id_c24a156863171e3cc0a8646329f090c1-id-17604f183ce6a486c0a86463069dfb21", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Vues et dialogues \/ Afficher : Git Status & Staging \/ Vue de comparaison ", 
"snippet" : "Symbole: Fonction : La vue montre les différences entre les commits. Les modifications peuvent être acceptées ou rejetées. Appel : Double-cliquez sur un changement dans le Statut Git. voir N'apportez AUCUNE modification dans la vue de comparaison. Seule exception : Résoudre tout conflit. La fonction...", 
"body" : "Symbole: Fonction : La vue montre les différences entre les commits. Les modifications peuvent être acceptées ou rejetées. Appel : Double-cliquez sur un changement dans le Statut Git. voir N'apportez AUCUNE modification dans la vue de comparaison. Seule exception : Résoudre tout conflit. La fonctionnalité et la manipulation de la vue de comparaison correspondent à la vue de comparaison utilisée pour une comparaison de projet. Le nouveau statut de l'objet ( nouveau (mis en scène|non mis en scène ) créé par la modification est comparé au dernier état de l'objet dans l'index ( base (head, <object ID>) pour les modifications non échelonnées. Pour les modifications par étapes, il est comparé au dernier statut dans le référentiel. Pour plus d'informations sur le CODESYS vue de comparaison, voir : Comparaison de projets " }, 
{ "title" : "Afficher : Git History ", 
"url" : "_git_view_history.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Vues et dialogues \/ Afficher : Git History ", 
"snippet" : "Git History Commande Git correspondante : git log Fonction : La vue affiche l'historique des commits qui ont été effectués sur les objets du projet ou sur d'autres fichiers du Référentiel Git . Les informations de modification sont affichées pour chaque validation. Une comparaison entre les commits ...", 
"body" : "Git History Commande Git correspondante : git log Fonction : La vue affiche l'historique des commits qui ont été effectués sur les objets du projet ou sur d'autres fichiers du Référentiel Git . Les informations de modification sont affichées pour chaque validation. Une comparaison entre les commits est possible. Vous pouvez également créer une nouvelle branche directement à partir d'un commit. Appel : Git → Historique menu Exigence  : des actions Git ont déjà été effectuées pour le projet ouvert. Au moins un commit doit exister. Comparer Le commit sélectionné est comparé à son état dans le stockage du projet et les modifications sont affichées dans le vue de comparaison . Lorsque deux commits sont sélectionnés, ils sont comparés. Graphique Représentation visuelle de la bifurcation et de la fusion de branches Les commits consécutifs effectués sur une branche sont affichés dans l'ordre chronologique (de bas en haut). Les branches individuelles sont disposées les unes à côté des autres et se distinguent par différentes couleurs. A l'extrême gauche se trouve la branche \"maître\", et à côté se trouvent les branches qui lui sont liées. Les commits ordinaires sont identifiés par des symboles circulaires et les commits de fusion sont identifiés par des symboles carrés. Les lignes entre les symboles de cercle des commits indiquent quand ils ont été forkés ou fusionnés. Les étiquettes Git attribuées dans un outil Git sont affichées avec une icône d'étiquette. Pour les validations vers le maître distant mutuel, son nom est inclus (par exemple, origin\/master ). Message Message de validation Auteur Auteur du commit Auteur Date du commit SHA1 \"Algorithme de hachage sécurisé 1\" SHA1 est une valeur de hachage et a la fonction d'un ID unique du commit. Les informations suivantes s'affichent pour le commit sélectionné ci-dessus : Détails <texte du message de validation> SHA1 : \"Algorithme de hachage sécurisé 1\" SHA1 est une valeur de hachage et a la fonction d'un ID unique du commit. Auteur Nom de l'auteur de la modification Commis Nom de l'auteur du changement Chemin Chemin physique Chemin de l'objet dans le répertoire de travail Git du CODESYS projet Exemple: project\\device\\plc_logic\\application\\plc_prg Quand le Afficher les chemins physiques option dans le menu contextuel de Objet colonne est sélectionnée, la Chemin physique colonne avec le chemin complet de l'objet est également affichée. Exemple: project\\device_5aca2685\\plc_logic_b738fa32\\application_0dcb78bb\\plc_prg_33759ca0\\33759ca04 b4e4930a972d2050e97661a.object Nom de l'objet Nom de l'objet dans le CODESYS projet ou nom d'un autre fichier dans le référentiel Git Exemples: PLC_PRG , Device , .gitattributes Type d'objet Type d'objet dans le CODESYS projet ou type de fichier Exemples: DeviceObject , .gitattributes Genre de changement Type de changement qui a été engagé Exemples: Added , Deleted , Modified , Renamed , Moved Un double-clic sur une modification ouvre la vue de comparaison connue de la Statut et mise en scène voir. Le changement par le nouveau commit ( nouvel objet <ID de validation> ) est affiché. La vue est utilisée uniquement à des fins d'information. Les informations ne peuvent pas être modifiées. Vous pouvez utiliser le Créer une branche à partir du commit dans le menu contextuel pour créer directement une nouvelle branche pour un commit sélectionné. " }, 
{ "title" : "Vue : Git Branches ", 
"url" : "_git_view_branches.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Vues et dialogues \/ Vue : Git Branches ", 
"snippet" : "Git Branches Symbole : Commande Git correspondante : git branch Fonction : Les branches Git locales sont affichées et gérées dans la vue. Il peut s'agir de branches qui suivent déjà une branche distante ou de branches qui existent uniquement localement et ne contiennent aucun lien vers un référentie...", 
"body" : "Git\nBranches Symbole : Commande Git correspondante : git branch Fonction : Les branches Git locales sont affichées et gérées dans la vue. Il peut s'agir de branches qui suivent déjà une branche distante ou de branches qui existent uniquement localement et ne contiennent aucun lien vers un référentiel distant. Appel : Git → Succursales menu Exigence : au moins un commit existe dans le référentiel. La vue est actualisée. Copier ( git copy ) Ouvre le Créer une nouvelle succursale boîte de dialogue pour créer une nouvelle branche locale en tant que copie de la branche locale actuellement sélectionnée (voir ci-dessus) Supprimer ( git branch -D ) La branche sélectionnée est supprimée, même si elle n'a pas encore été complètement fusionnée. Remarque : La branche actuelle ne peut pas être supprimée. Commander ( git checkout ) À la suite de Checkout opération, la branche sélectionnée devient la branche en cours. Cela signifie que les opérations Git agissent sur le contenu de cette branche, qui est chargé dans le référentiel Git local (« répertoire de travail ») à cette fin. A checkout is prevented by uncommitted changes. When dealing with a remote branch – an entry under Remote (<n>) – the following options are possible: Une boîte de dialogue s'ouvre avec le message suivant : Cette branche distante est déjà suivie par la branche « principale » locale, qui sera extraite à la place. Nom de la branche « origin\/master » . In this case, there is already a local remote branch (under Local (<n>) ) which tracks the currently selected remote branch and can therefore Pull and Push with it. Then this local branch is loaded into the working directory for editing. It is possible that the checkout is denied at first, because of inconsistencies caused by local changes made directly in the working directory. With the Force option, these inconsistencies can be accepted initially and the checkout can still be performed. L'extraction de cette succursale distante créera une branche de suivi locale correspondante. Ce nom pour la branche locale est déjà utilisé. L'opération échouera très probablement. Dans ce cas, aucune succursale distante locale ne suivait encore la succursale distante actuellement sélectionnée. CODESYS Git souhaite créer une branche locale, mais son nom est déjà utilisé. Avec le Force option, l'opération peut toujours être forcée. Attention : La branche existante sera remplacée par celle-ci. y avait pas encore de succursale locale distante. Aucun suivi. Cette branche est maintenant créée et définie comme « actuelle » et le suivi est activé. Cela signifie que les travaux se poursuivront immédiatement sur cette branche. Fusionner ( git merge ) Cliquer sur le bouton exécutera la commande directement. Alternativement, vous pouvez également définir des options pour celui-ci. Pour ce faire, utilisez le touche fléchée pour sélectionner le Fusionner avec les options commande. Le Fusionner la branche une boîte de dialogue s'ouvre dans laquelle vous pouvez sélectionner le Possibilités qui est valable pour l'action de fusion en cours. fusion nécessite le nom et l'adresse e-mail de l'utilisateur. Ces informations sont extraites des paramètres Git. Si cela n'est pas possible, une boîte de dialogue s'ouvre. Le nom d'utilisateur et l'adresse e-mail peuvent être modifiés dans Fusionner une branche dialogue. Lorsque vous confirmez la demande (invite de dialogue), que vous souhaitiez réellement valider ou non, les validations de la branche actuellement sélectionnée sont validées dans la branche en cours. La branche actuelle est celle dont le statut se trouve désormais dans le répertoire de travail. (coche dans Actuel colonne) Si des conflits surviennent lors de la fusion, ils doivent d’abord être résolus. Selon les cas et l'ensemble fusionner Possibilités , des actions automatisées seront exécutées ou des actions manuelles sont nécessaires. Si un conflit ne peut pas être résolu automatiquement, cela est indiqué dans le Statut Git et mise en scène voir. Pour résoudre les conflits dans un premier temps, faites attention aux commandes du menu contextuel fournies dans le Statut et mise en scène voir. Voir aussi le Conflits de fusion, « problèmes relationnels » page d'aide. Tant que l'opération de fusion n'est pas terminée, les informations de statut Merging s'affiche dans l'en-tête de la vue ainsi que dans la barre des tâches. Le Fusionner L'action nécessite le nom et l'adresse e-mail de l'utilisateur. Ces informations sont extraites du Paramètres du projet Git . Si cela n'est pas possible, une boîte de dialogue s'ouvre. En amont : Set\/Clear git push -u origin local-branch git branch --set-upstream-to <origin\/remote-branch> Ouvre le Configurer la télécommande en amont pour Branch dialogue Ici, une branche correspondant à la branche locale est créée et le lien avec celle-ci est établi sur le référentiel distant lié (généralement nommé « origine » et situé sur un serveur, par exemple). Branche Track git branch --track Ouvre le Suivez une succursale distante dialogue Ici, la branche locale peut être liée à un représentant disponible d'un référentiel distant (branche distante). Cela permet un échange de commits (opérations Git) Tirer et Poussez ) entre le dépôt local et le dépôt distant. Tirer ( git pull ) Tirez avec options L'état de la branche du référentiel distant suivi est récupéré dans la branche locale ( git fetch ) et a également fusionné avec celui-ci ( git merge ). Exigence : la branche locale assure le suivi de la branche distante du référentiel distant. The Pull action requires the name and email address of the user. This information is taken from the credentials stored on the computer. If this is not possible, then they are queried again in the Git pull <remote branch> dialog. For more information about the credentials for a remote repository, see: Identifiants nécessairesLe Tirez avec options commande ouvre explicitement cette boîte de dialogue afin que les paramètres puissent être modifiés. Si le Souvenez-vous de moi l'option est activée pour Nom et Courrier électronique informations d'identification, puis les paramètres de la boîte de dialogue sont enregistrés dans le fichier de configuration Git .git\/config dans le référentiel local. Poussez ( git push ) Si la branche sélectionnée n'est pas une branche de suivi, alors la Pousser la branche La boîte de dialogue s'ouvre. Ici, vous spécifiez la branche distante dans laquelle fusionner. Les commits de la branche locale sont poussés vers la branche correspondante dans le référentiel distant. If the selected branch is a tracking branch, then the action is performed immediately. No dialog opens. Comparez La branche sélectionnée est comparée au dernier état du projet dans le stockage du projet et les différences sont affichées dans le vue comparative . Lorsque deux branches sont sélectionnées, elles sont comparées. Filter branches: Local|Remote By clicking the Local (<n>) and\/or Remote (<n>) buttons, the display of local branches and\/or remote branches (\"representatives\" of the branches located in the remote repository) is enabled or disabled in the table. Tableau Actuel : : Il s'agit de l'antenne locale où les travaux sont actuellement en cours. Checkout L'opération est utilisée pour faire d'une branche la branche actuelle. Le répertoire de travail (dépôt Git) contient l'état actuel exact de cette branche. télécommande : : Il s'agit d'une « branche distante » située dans le référentiel distant. L'entrée ici est utilisée comme représentant cette branche (par exemple, origin\/master en tant que branche représentative du référentiel distant). Suivi : : La branche locale suit une branche distante et est donc liée à celle-ci pour l'échange de commits à l'aide des opérations Git. Nom : Nom de la succursale Nom canonique : nom unique de la succursale Exemple : refs\/heads\/master télécommande : Nom du référentiel distant auquel la branche distante fait référence (généralement origin ) Nom canonique de la branche en amont Exemple : refs\/heads\/master Nom de la succursale suivie : nom de la succursale distante qui est suivie Exemple : origin\/master Nom canonique de la branche suivie : nom canonique de la branche distante qui est suivie. Exemple : remotes\/origin\/master Lorsqu'une succursale suit une succursale distante, les informations suivantes sont pertinentes. Attention : Cet affichage n'est actualisé que lorsqu'un Va chercher la commande est exécutée : S'engage à l'avance : Nombre de commits sur la branche locale (de suivi) dont l'heure est « en avance » sur la branche distante S'engage derrière : Nombre de commits dont la branche locale (suivi) se trouve derrière la branche distante. " }, 
{ "title" : "Boîte de dialogue : Créer une nouvelle branche ", 
"url" : "_git_view_branches.html#UUID-97ba347b-85e1-cc8a-9709-7e25d06325fd_id_c9b5a632b41e5c0a8646364f8237e-id-de5b4ae7906a11eba659cf2e134a78be", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Vues et dialogues \/ Vue : Git Branches \/ Boîte de dialogue : Créer une nouvelle branche ", 
"snippet" : "Commande Git correspondante : git branch --copy Symbole : Fonction : créez une nouvelle succursale locale. Appel : Copier commande dans le Succursales locales voir Exigence : Une agence locale existe déjà. Branche source Nom de la branche copiée Nouveau nom de succursale Champ de saisie pour le nouv...", 
"body" : "Commande Git correspondante : git branch --copy Symbole : Fonction : créez une nouvelle succursale locale. Appel : Copier commande dans le Succursales locales voir Exigence : Une agence locale existe déjà. Branche source Nom de la branche copiée Nouveau nom de succursale Champ de saisie pour le nouveau nom de la branche Force : S'il y a des modifications non validées au moment du paiement, les succursales ne peuvent pas être changées par défaut. Cependant, cela peut être forcé à l'aide de la commande sélectionnée Force option. Commander : La nouvelle branche est immédiatement extraite lors de sa création et est sélectionnée avec une coche comme Actuel . " }, 
{ "title" : "Boîte de dialogue : Fusionner une branche ", 
"url" : "_git_view_branches.html#UUID-97ba347b-85e1-cc8a-9709-7e25d06325fd_section-idm4555057866660833047299804314", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Vues et dialogues \/ Vue : Git Branches \/ Boîte de dialogue : Fusionner une branche ", 
"snippet" : "Symbole : Fonction : définissez les options de fusion pour l'opération de fusion en cours. Ces options sont prédéfinies dans le CODESYS options et peuvent être modifiées pour des cas individuels ici dans le Fusionner une branche dialogue. Appel : Fusionner bouton dans le Succursales dialogue ; Fusio...", 
"body" : "Symbole : Fonction : définissez les options de fusion pour l'opération de fusion en cours. Ces options sont prédéfinies dans le CODESYS options et peuvent être modifiées pour des cas individuels ici dans le Fusionner une branche dialogue. Appel : Fusionner bouton dans le Succursales dialogue ; Fusionner avec des options commande Exigence : Dans le Succursales Git vue, une branche est sélectionnée qui doit être fusionnée avec la branche actuellement récupérée. Branche à fusionner La branche sélectionnée dans le Succursales Git voir User name and email address Lorsque le texte est développé, Nom et Courrier électronique peut être modifié. Le contenu des champs est prédéfini à partir des paramètres Git user.name et user.email . Si ces paramètres Git ne sont pas disponibles, l'utilisateur doit spécifier les valeurs. Options de fusion avec Git Stratégie de fusion des conflits Pour plus d'informations, voir : Options – GitStratégie Fast Forward Pour plus d'informations, voir : Options – GitEngagez-vous pour le succès Si la fusion est réussie, les modifications qui en résultent sont automatiquement validées. " }, 
{ "title" : "Afficher : Remotes ", 
"url" : "_git_view_remotes.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Vues et dialogues \/ Afficher : Remotes ", 
"snippet" : "Remotes Symbole: Commande Git correspondante : git remote Fonction : La vue permet de gérer les référentiels distants , qui servent à gérer CODESYS projets sur lesquels plusieurs utilisateurs devraient pouvoir travailler. Les référentiels locaux d'utilisateurs individuels peuvent établir un lien ver...", 
"body" : "Remotes Symbole: Commande Git correspondante : git remote Fonction : La vue permet de gérer les référentiels distants , qui servent à gérer CODESYS projets sur lesquels plusieurs utilisateurs devraient pouvoir travailler. Les référentiels locaux d'utilisateurs individuels peuvent établir un lien vers un référentiel distant partagé et y synchroniser\/fusionner leurs commits. Assurez-vous de disposer d'une connexion sécurisée à un serveur distant. Pour plus d'informations, voir : Sécurité pour CODESYS Git Appel : Git → Télécommandes menu Exigence : Un projet est ouvert et géré dans Git. La vue est rafraîchie. Ajouter Ouvre le Ajouter une nouvelle télécommande boîte de dialogue pour spécifier le référentiel distant avec lequel CODESYS le projet doit être lié Surnom Remarque : Le nom habituel dans Git pour le référentiel distant est origin . URL : URL ou chemin de fichier du référentiel distant Les protocoles suivants sont actuellement pris en charge : HTTP, HTTPS, local. Exemples: file:\/\/\/D:\/GitRep\/Remote\/<repository name> , https:\/\/dockerhostpde\/testuser1\/publicproject.git Retirer L'utilisateur est invité à supprimer le lien vers le référentiel distant du projet. Remarque : Toutes les branches distantes appartenant au référentiel distant supprimé sont supprimées. Les branches locales sont conservées, mais ne suivent plus les branches distantes supprimées. Cette action ne peut pas être annulée. Renommer La Surnom du référentiel distant peut être modifié. Définir l'URL Ouvre le Définir l'URL pour Remote <remote> dialogue Ici, la spécification du chemin (URL ou chemin du fichier) pour le référentiel distant actuellement utilisé peut être modifiée. La modification des informations de chemin et donc du lien vers le référentiel distant peut entraîner la disparition des branches distantes. Par conséquent, l'utilisateur doit réaffecter les mappages des branches locales aux branches distantes (tracking). Les succursales locales ne sont pas modifiées. Aller chercher Aller chercher (prune) Le représentant local du dépôt distant (exemple : origin\/master ) est mis à jour avec le statut du référentiel distant utilisé par tous les utilisateurs. Toutes les modifications sont appliquées à partir du référentiel distant. Ce sont toutes de nouvelles branches et de nouveaux commits dans les branches distantes. Cependant, les commits ne sont pas appliqués aux branches de suivi. Remarque : Pour mettre à jour une branche locale avec l'état actuel de la branche distante, un Tirer l'opération doit également être effectuée dans le Branches Git voir. En option, vous obtenez le Chercher (tailler) commande au moyen de la bouton. Cette commande de récupération a pour effet que les branches distantes qui n'existent plus dans le référentiel distant sont supprimées du référentiel local. Identifiants Le bouton ouvre le Modifier les informations d'identification dialogue. Nom d'utilisateur et Mot de passe pour accéder au référentiel distant peut être spécifié et modifié ici. Pour le référentiel distant sélectionné ( nom de la télécommande ), la zone de liste fournit tous URL pour lesquels le référentiel peut fournir des informations d'identification. Les informations d'identification pour l'URL sélectionnée peuvent ensuite être enregistrées, supprimées ou modifiées. Il est recommandé de stocker les informations d'identification de la première URL dans la zone de liste, car elles peuvent ensuite être réutilisées pour d'autres projets au sein du « domaine ». Pour des informations détaillées sur la gestion des informations d'identification spécifiques à un domaine, consultez Identifiants nécessaires. La modification dans la boîte de dialogue remplace la modification dans le Gestionnaire d'informations d'identification Windows. Note: A PAT (personal access token) is required when working with GitHUb. Then the PAT has to be specified instead of the password. Example of a PAT in GitHub: ghp_WPZP1ijlX4E<xxxxxxxxxxxxxxxxxx> Table Nom : Nom d'alias du référentiel distant URL URL ou chemin de fichier du référentiel distant " }, 
{ "title" : "Afficher : Paramètres du projet Git ", 
"url" : "_git_view_project_settings.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Vues et dialogues \/ Afficher : Paramètres du projet Git ", 
"snippet" : "Paramètres du projet Git Fonction : Cette vue affiche les paramètres actuels du projet pour le CODESYS projet (\"projet Git\") qui est géré dans Git avec l'aide de CODESYS Git . Appel : Git → Paramètres du projet Git menu Exigence : Un projet Git est ouvert. Chemin de stockage du projet Git Chemin du ...", 
"body" : "Paramètres du projet Git Fonction : Cette vue affiche les paramètres actuels du projet pour le CODESYS projet (\"projet Git\") qui est géré dans Git avec l'aide de CODESYS Git . Appel : Git → Paramètres du projet Git menu Exigence : Un projet Git est ouvert. Chemin de stockage du projet Git Chemin du stockage du projet Git (dépôt Git local) où CODESYS Git gère les dossiers du projet Le chemin est défini lorsque le lien Git est initialisé ( Init Git ou Git Clone ). À ne pas confondre avec l'emplacement de stockage supplémentaire en dehors de la gestion Git pour le CODESYS fichiers de projet (double gestion des données). " }, 
{ "title" : "Boîte de dialogue : Identifiants nécessaires ", 
"url" : "_git_dlg_credentials_needed.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Vues et dialogues \/ Boîte de dialogue : Identifiants nécessaires ", 
"snippet" : "Identifiants nécessaires Fonction : La boîte de dialogue est utilisée pour fournir les identifiants d'accès au référentiel distant . Appel : La boîte de dialogue s'ouvre lorsque vous souhaitez accéder à un référentiel distant protégé depuis CODESYS Git . Par exemple, cela se fait avec le Fetch comma...", 
"body" : "Identifiants nécessaires Fonction : La boîte de dialogue est utilisée pour fournir les identifiants d'accès au référentiel distant . Appel : La boîte de dialogue s'ouvre lorsque vous souhaitez accéder à un référentiel distant protégé depuis CODESYS Git . Par exemple, cela se fait avec le Fetch commande dans le Télécommandes voir. Après un nombre de tentatives infructueuses dépendant du serveur pour fournir des informations d'identification correctes, l'opération est abandonnée avec un message correspondant. Assurez-vous de disposer d'une connexion sécurisée à un serveur distant. Pour plus d'informations, voir : Sécurité pour CODESYS Git Les informations d'identification pour le référentiel distant via le serveur Git peuvent être modifiées dans le Télécommandes Git voir. Vous n'avez pas besoin de basculer vers le gestionnaire d'informations d'identification Windows pour ce faire. Dans le Télécommandes Git vue, vous pouvez modifier les informations d'identification du référentiel distant via le serveur Git. Vous n'avez pas besoin de passer au gestionnaire d'informations d'identification Windows pour ce faire. Consultez les informations ci-dessous pour plus d'informations sur la gestion des informations d'identification spécifiques à un domaine Utilisateur Nom d'utilisateur pour le référentiel distant Mot de passe Mot de passe pour le dépôt distant, un mot de passe vide est possible Enregistrer : Les informations d'identification sont automatiquement enregistrées dans le Gestionnaire d'informations d'identification Windows. Lorsque vous accéderez à nouveau au référentiel distant par la suite, vous ne serez plus invité à fournir les informations d'identification. " }, 
{ "title" : "Informations d'identification spécifiques au domaine ", 
"url" : "_git_dlg_credentials_needed.html#UUID-933ca5ae-45c1-256f-cb97-3e472b5757e0_section-idm234662684414694", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Vues et dialogues \/ Boîte de dialogue : Identifiants nécessaires \/ Informations d'identification spécifiques au domaine ", 
"snippet" : "Les référentiels distants peuvent partager un nom d'hôte ou un chemin d'accès sur un serveur hôte. Dans ce cas, les informations d'identification enregistrées pour une URL d'hôte peuvent être utilisées pour tous les projets portant le même nom d'hôte. Exemple : informations d'identification enregist...", 
"body" : "Les référentiels distants peuvent partager un nom d'hôte ou un chemin d'accès sur un serveur hôte. Dans ce cas, les informations d'identification enregistrées pour une URL d'hôte peuvent être utilisées pour tous les projets portant le même nom d'hôte. Exemple : informations d'identification enregistrées avec l'URL git:https:\/\/gitlab.com\/user peut être utilisé pour un référentiel avec l'URL git:https:\/\/gitlab.com\/user\/project1.git ainsi que pour un référentiel avec l'URL git:https:\/\/gitlab.com\/user\/project2.git car l'URL fait partie des deux URL du référentiel. Cela signifie qu'un seul ensemble d'informations d'identification doit être créé pour plusieurs référentiels. " }, 
{ "title" : "Utilisation des informations d'identification stockées ", 
"url" : "_git_dlg_credentials_needed.html#UUID-933ca5ae-45c1-256f-cb97-3e472b5757e0_section-idm234662700956759", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Vues et dialogues \/ Boîte de dialogue : Identifiants nécessaires \/ Utilisation des informations d'identification stockées ", 
"snippet" : "Dans CODESYS Git , lorsqu'une opération à distance est effectuée pour laquelle des informations d'identification sont requises, CODESYS Git recherche des informations d'identification valides selon la procédure suivante : À partir de l'URL complète du référentiel, le système recherche les informatio...", 
"body" : "Dans CODESYS Git , lorsqu'une opération à distance est effectuée pour laquelle des informations d'identification sont requises, CODESYS Git recherche des informations d'identification valides selon la procédure suivante : À partir de l'URL complète du référentiel, le système recherche les informations d'identification stockées pour chaque chemin partiel de l'URL jusqu'à ce qu'une entrée soit trouvée, puis les utilise pour l'authentification. Si les informations d'identification ne sont pas valides, une boîte de dialogue s'ouvre avec les options suivantes : Remplacez les informations d'identification actuelles par les nouvelles informations d'identification à saisir Supprimez les informations d'identification des informations d'identification Windows et recherchez à nouveau les entrées en fonction de l'URL actuellement affichée. Si aucune information d'identification valide n'est trouvée lors de cette recherche, une boîte de dialogue s'ouvre pour vous permettre de saisir vos informations d'identification pour l'URL la plus générale possible. Les informations d'identification pourront ensuite être utilisées à l'avenir pour d'autres projets sous cette URL. " }, 
{ "title" : "Authentification à deux facteurs ", 
"url" : "_git_dlg_credentials_needed.html#UUID-933ca5ae-45c1-256f-cb97-3e472b5757e0_section-idm4575047671689634318583574228", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Vues et dialogues \/ Boîte de dialogue : Identifiants nécessaires \/ Authentification à deux facteurs ", 
"snippet" : "Une authentification à deux facteurs peut être requise pour se connecter aux plateformes Git telles que GitHub ou GitLab. Si tel est le cas, vous devez d'abord créer un PAT (Personal Access Token) sur la plateforme respective et le spécifier dans CODESYS Git dans le Informations d'identification req...", 
"body" : "Une authentification à deux facteurs peut être requise pour se connecter aux plateformes Git telles que GitHub ou GitLab. Si tel est le cas, vous devez d'abord créer un PAT (Personal Access Token) sur la plateforme respective et le spécifier dans CODESYS Git dans le Informations d'identification requises boîte de dialogue au lieu du mot de passe ou du nom d'utilisateur. Le tableau suivant contient des informations sur la création et l'utilisation d'un PAT pour les plates-formes Git individuelles. Plateforme Git Informations requises pour l'authentification Informations détaillées pour la création du PAT GitHub Utilisateur : Nom d'utilisateur Mot de passe : PAT (au lieu du mot de passe) GitHub : PAT GitLab Utilisateur : Nom d'utilisateur facultatif (actuellement ignoré) Mot de passe : PAT (au lieu du mot de passe) GitLab : jetons d'accès personnels Bitbucket User : User name Password : PAT (instead of the password) Bitbucket Support: Create a Repository Access Token " }, 
{ "title" : "Boîte de dialogue : Choisissez l'emplacement du référentiel Git ", 
"url" : "_git_dlg_extract_git_repository.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Vues et dialogues \/ Boîte de dialogue : Choisissez l'emplacement du référentiel Git ", 
"snippet" : "Choisissez l'emplacement du référentiel Git Fonction : Dans cette boîte de dialogue, vous définissez un nouvel emplacement de stockage pour ce référentiel lors de l'extraction d'un CODESYS projet qui contient également un référentiel Git. Appel : Fichier → Archive du projet → Extraire l'archive comm...", 
"body" : "Choisissez l'emplacement du référentiel Git Fonction : Dans cette boîte de dialogue, vous définissez un nouvel emplacement de stockage pour ce référentiel lors de l'extraction d'un CODESYS projet qui contient également un référentiel Git. Appel : Fichier → Archive du projet → Extraire l'archive commande, sélectionnez Référentiel Git objet, Extrait bouton Exigence : L'archive du projet à extraire contient un dépôt Git. Choisissez l'emplacement du référentiel Git Chemin valide pour un référentiel Git dans le système de fichiers local Exemple: D:\\GIT_LOCAL\\proj_xy . Voir le Git → Paramètres du projet voir. " }, 
{ "title" : "Boîte de dialogue : Récupération de projet Git ", 
"url" : "_git_dlg_project_recovery.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Vues et dialogues \/ Boîte de dialogue : Récupération de projet Git ", 
"snippet" : "Récupération de projet Git Fonction : Dans la boîte de dialogue, vous définissez ce qui doit se passer lorsqu'un CODESYS projet ne peut plus accéder au référentiel Git respectif. Appel : La boîte de dialogue s'ouvre lorsqu'un projet Git est ouvert dans CODESYS et si le chemin du référentiel Git enre...", 
"body" : "Récupération de projet Git Fonction : Dans la boîte de dialogue, vous définissez ce qui doit se passer lorsqu'un CODESYS projet ne peut plus accéder au référentiel Git respectif. Appel : La boîte de dialogue s'ouvre lorsqu'un projet Git est ouvert dans CODESYS et si le chemin du référentiel Git enregistré est introuvable ou si l'ouverture du projet échoue pour d'autres raisons. Une description de l'échec de la tentative de chargement du projet Git à partir du référentiel s'affiche dans le champ de texte. Il contient la note pour vérifier les messages Git dans la fenêtre de message. Choix Fermer le projet Plus d'action Supprimer la connexion git du projet Les informations du référentiel Git dans les paramètres du projet Git sont supprimées. Le projet n'est plus géré dans Git en cours de sauvegarde. Utiliser un chemin de référentiel existant Le projet est nouvellement lié à un référentiel Git valide dans le système de fichiers local. Le nouveau chemin du référentiel doit être saisi ici dans la boîte de dialogue et est automatiquement appliqué au Paramètres du projet Git lorsque le projet est enregistré. Attention : Le référentiel sélectionné doit correspondre au projet. " }, 
{ "title" : "Boîte de dialogue : Options - Git ", 
"url" : "_git_dlg_options_git.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Vues et dialogues \/ Boîte de dialogue : Options - Git ", 
"snippet" : "Options – Git Symbole: Fonction : La boîte de dialogue contient des paramètres pour CODESYS Git . Pour plus d'informations sur le CODESYS options, voir : Boîte de dialogue : Options Appel : Menu Gestion des certificats Toujours accepter le certificat Désactivé par défaut : Le certificat envoyé par l...", 
"body" : "Options – Git Symbole: Fonction : La boîte de dialogue contient des paramètres pour CODESYS Git . Pour plus d'informations sur le CODESYS options, voir : Boîte de dialogue : Options Appel : Menu Gestion des certificats Toujours accepter le certificat Désactivé par défaut : Le certificat envoyé par le serveur est toujours accepté même s'il n'est pas valide. Il n'est pas marqué comme fiable. Accepter le certificat auto-signé Désactivé par défaut : Un certificat auto-signé est également accepté (ceux-ci sont normalement rejetés). Si l'option n'est pas sélectionnée et qu'il n'y a pas de certificat de confiance, vous recevrez un message d'erreur. Vous pouvez ensuite consulter les détails du certificat et décider si la connexion doit quand même être établie ou non. Options Git Pull\/Merge Git Pull \/ Git Merge Ces options n'affectent que Conflits Git . Fusionner la stratégie de conflit Option : Appliquer les fusions automatiques (selon disponibilité) : Les fonctionnalités de fusion automatique doivent être utilisées chaque fois qu'elles sont disponibles pour le type d'objet concerné. Échec en cas de conflit (ne pas fusionner) : L'opération de fusion est abandonnée avec un message d'erreur en cas de conflit. Laisser l'utilisateur résoudre les conflits : Les conflits doivent fondamentalement être traités manuellement. Pour plus d'informations, consultez : Conflits de fusion, « problèmes relationnels »Utilisez \"le nôtre\" pour les conflits : CODESYS Git devrait essayer de résoudre les conflits en utilisant toujours le contenu de la branche cible lors de la fusion. Utilisez 'leurs' pour les conflits : CODESYS Git devrait essayer de résoudre les conflits en utilisant toujours le contenu de la branche source lors de la fusion. Stratégie d'avance rapide Option : Utilisez l'avance rapide si possible : Les commits de la branche source, dont l'heure est postérieure à un commit qui existe déjà dans les deux branches, sont automatiquement appliqués lors de la fusion. Dans ce cas, aucune entrée de commit de fusion n'est créée dans l'historique. Si les validations sont incohérentes, aucune avance rapide n'a lieu. Pas d'avance rapide Avance rapide uniquement (échec sinon) : La fusion est toujours tentée avec une stratégie d'avance rapide. Si les conditions ne sont pas remplies, la fusion échoue avec un message correspondant. Cas d'utilisation typique de l'avance rapide : Tirez Engagez-vous sur le succès : : si l'opération d'extraction ou de fusion a été exécutée sans aucun conflit, un commit est également exécuté automatiquement. Si l'avance rapide réussit, l'option n'a aucun effet. Signalement des messages Niveau de verbosité Sélection du niveau de détail : Par défaut : Informations de base (par exemple, le nom de la commande avec des informations sur le succès de l'action, aucun détail) Verbeux : Informations supplémentaires sur les résultats et les étapes intermédiaires. Utile pour la création de scripts en cours d'exécution sans CODESYS interface utilisateur. " }, 
{ "title" : "Commandes de menus ", 
"url" : "_git_struct_reference_commands.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Commandes de menus ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Commande : Paramètres du projet Git ", 
"url" : "_git_cmd_git_project_settings.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Commandes de menus \/ Commande : Paramètres du projet Git ", 
"snippet" : "Paramètres du projet Git Fonction : La commande ouvre le Paramètres du projet Git voir. La vue montre le chemin du stockage du projet Git (référentiel local) pour le projet actuellement ouvert. Appel : Gite menu Exigence : L'ouvert CODESYS projet est géré dans Git dans un référentiel local....", 
"body" : "Paramètres du projet Git Fonction : La commande ouvre le Paramètres du projet Git voir. La vue montre le chemin du stockage du projet Git (référentiel local) pour le projet actuellement ouvert. Appel : Gite menu Exigence : L'ouvert CODESYS projet est géré dans Git dans un référentiel local. " }, 
{ "title" : "Commande : Status & Staging ", 
"url" : "_git_cmd_status_and_staging.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Commandes de menus \/ Commande : Status & Staging ", 
"snippet" : "Status & Staging Symbole: ( git status ) Fonction : La commande ouvre le Git Status & Staging voir. La vue affiche le statut Git des objets qui ont changé depuis le dernier commit. Dans la vue, les objets modifiés sont préparés pour la validation Git (mise en scène) et les objets préparés sont valid...", 
"body" : "Status & Staging Symbole: ( git status ) Fonction : La commande ouvre le Git Status & Staging voir. La vue affiche le statut Git des objets qui ont changé depuis le dernier commit. Dans la vue, les objets modifiés sont préparés pour la validation Git (mise en scène) et les objets préparés sont validés dans le référentiel Git local lié. Appel : Gite menu Exigence : L'ouvert CODESYS projet est géré dans un référentiel Git local. " }, 
{ "title" : "Commandement : Branches ", 
"url" : "_git_cmd_branches.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Commandes de menus \/ Commandement : Branches ", 
"snippet" : "Branches Symbole: ( git branch ) Fonction : La commande ouvre le Branches Git voir où les branches pour le travail dans le référentiel Git sont créées et gérées. Appel : Gite menu Exigence : L'ouvert CODESYS projet est géré dans un référentiel Git local....", 
"body" : "Branches Symbole: ( git branch ) Fonction : La commande ouvre le Branches Git voir où les branches pour le travail dans le référentiel Git sont créées et gérées. Appel : Gite menu Exigence : L'ouvert CODESYS projet est géré dans un référentiel Git local. " }, 
{ "title" : "Commande : Remotes ", 
"url" : "_git_cmd_remotes.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Commandes de menus \/ Commande : Remotes ", 
"snippet" : "Remotes Raccourci: F7 ( git remote ) Fonction : La commande ouvre le Télécommandes voir. Dans la vue, les référentiels distants sont gérés, qui sont utilisés en relation avec les référentiels Git locaux pour CODESYS projets sous CODESYS Git . Appel : Gite menu Exigence : UN CODESYS Le projet est ouv...", 
"body" : "Remotes Raccourci: F7 ( git remote ) Fonction : La commande ouvre le Télécommandes voir. Dans la vue, les référentiels distants sont gérés, qui sont utilisés en relation avec les référentiels Git locaux pour CODESYS projets sous CODESYS Git . Appel : Gite menu Exigence : UN CODESYS Le projet est ouvert et géré dans Git dans un référentiel Git local. " }, 
{ "title" : "Commande : History ", 
"url" : "_git_cmd_history.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Commandes de menus \/ Commande : History ", 
"snippet" : "History ( git log ) Fonction : La commande ouvre le Histoire voir. La vue affiche l'historique des commits dans le référentiel. Appel : Gite menu Exigence : L'ouvert CODESYS projet est géré dans un référentiel Git local....", 
"body" : "History ( git log ) Fonction : La commande ouvre le Histoire voir. La vue affiche l'historique des commits dans le référentiel. Appel : Gite menu Exigence : L'ouvert CODESYS projet est géré dans un référentiel Git local. " }, 
{ "title" : "Commande : Git init ", 
"url" : "_git_cmd_git_init.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Commandes de menus \/ Commande : Git init ", 
"snippet" : "Git init ( git init ) Fonction : La commande ouvre le Initialiser le référentiel Git boîte de dialogue pour initialiser un local Référentiel Git pour l'ouvert CODESYS projet. Lors de l'initialisation, le projet est importé dans Git, qui crée un référentiel local et l'index du projet (stockage de pro...", 
"body" : "Git init ( git init ) Fonction : La commande ouvre le Initialiser le référentiel Git boîte de dialogue pour initialiser un local Référentiel Git pour l'ouvert CODESYS projet. Lors de l'initialisation, le projet est importé dans Git, qui crée un référentiel local et l'index du projet (stockage de projet Git). En conséquence, le répertoire de travail Git pour le projet est créé. Appel : Gite menu Exigence : UN CODESYS projet est ouvert. Lorsque le cryptage est défini pour le CODESYS projet ( CODESYS - Paramètres du projet – Sécurité ), le référentiel Git (ni local ni distant) n'est pas automatiquement protégé en conséquence. Dialogue: Initialiser le référentiel Git Champ de saisie pour le chemin du répertoire Git local Chemin du répertoire vide dans le système de fichiers qui doit être utilisé pour le nouveau stockage de projet Git Exemple: D:\\git_local\\rep1 D'ACCORD Le projet ouvert est importé dans Git et le référentiel local est créé pour le projet. Dans les vues du navigateur du projet, les objets sont identifiés par les symboles suivants : Nœud racine du projet : Tous les autres objets et appareils du projet : Les messages Git correspondants sont affichés dans la fenêtre de message. " }, 
{ "title" : "Commande : Git Clone ", 
"url" : "_git_cmd_git_clone.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Commandes de menus \/ Commande : Git Clone ", 
"snippet" : "Git Clone ( git clone ) Fonction : La commande ouvre le Git Clone dialogue. A l'aide de la boîte de dialogue, un référentiel distant est copié dans un répertoire vide, qui devient à son tour un nouveau référentiel Git local. Après l'opération de copie, le référentiel local contient l'historique comp...", 
"body" : "Git Clone ( git clone ) Fonction : La commande ouvre le Git Clone dialogue. A l'aide de la boîte de dialogue, un référentiel distant est copié dans un répertoire vide, qui devient à son tour un nouveau référentiel Git local. Après l'opération de copie, le référentiel local contient l'historique complet du référentiel distant. Appel : Gite menu Exigence : Aucun projet n'est ouvert dans CODESYS . Lorsque le cryptage est défini pour le CODESYS projet ( CODESYS - Paramètres du projet – Sécurité ), le référentiel Git (ni local ni distant) n'est pas automatiquement protégé en conséquence. Dialogue: Git Clone Cloner à partir de URL source URL ou chemin de fichier du référentiel distant Cloner vers Chemin de stockage Git Répertoire de fichiers pour le Stockage du projet Git (emplacement du répertoire du référentiel local). Exemple: D:\\git_local\\rep1 Dossier de projet Chemin d'accès au fichier de projet ( répertoire du projet ). Remarque : Le fichier du projet ne doit pas se trouver dans le même répertoire que le stockage du projet Git. Exemple: D:\\git_projects\\myproj1.project Type de fichier de projet Projet Bibliothèque En ce qui concerne l'opération de clonage, vous pouvez utiliser le Récupérer le projet à partir du référentiel commande pour charger un projet, qui existe déjà dans le référentiel Git, en tant que nouveau CODESYS projet. " }, 
{ "title" : "Commande : Git Deinit ", 
"url" : "_git_cmd_git_deinit.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Commandes de menus \/ Commande : Git Deinit ", 
"snippet" : "Git Deinit Fonction : La commande supprime tout le Stockage de projet Git . En conséquence, l'ouverture CODESYS project n'est plus disponible dans Git. Appel : Gite menu Exigence : Un stockage de projet Git existe pour l'open CODESYS projet et donc également un référentiel local. Cela signifie que I...", 
"body" : "Git Deinit Fonction : La commande supprime tout le Stockage de projet Git . En conséquence, l'ouverture CODESYS project n'est plus disponible dans Git. Appel : Gite menu Exigence : Un stockage de projet Git existe pour l'open CODESYS projet et donc également un référentiel local. Cela signifie que Init Git ou Git Clone ont été exécutés auparavant. " }, 
{ "title" : "Commande : Récupérer le projet à partir du référentiel ", 
"url" : "_git_cmd_build_project_from_repository.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Commandes de menus \/ Commande : Récupérer le projet à partir du référentiel ", 
"snippet" : "Récupérer le projet du référentiel Fonction : La commande permet de reconstruire un projet en CODESYS depuis le stockage du projet Git (dépôt local). De cette façon, l'opération est similaire à la création d'un projet Git au moyen de Git Clone (depuis le référentiel distant). Appel : La commande n'e...", 
"body" : "Récupérer le projet du référentiel Fonction : La commande permet de reconstruire un projet en CODESYS depuis le stockage du projet Git (dépôt local). De cette façon, l'opération est similaire à la création d'un projet Git au moyen de Git Clone (depuis le référentiel distant). Appel : La commande n'est pas dans le menu Git par défaut. Exigence : Aucun projet n'est ouvert dans CODESYS . La commande ouvre le Récupérer le projet dialogue. Ici, vous spécifiez la source et la destination du projet à récupérer. La source Emplacement du référentiel Git Chemin du dépôt Git à partir duquel le projet doit être récupéré dans CODESYS Destination Dossier de projet Répertoire de fichiers pour le stockage du projet CODESYS Exemple : D:\\proj.projet Type de fichier de projet : Projet : Bibliothèque " }, 
{ "title" : "Commande : Reconstruire le projet à partir du référentiel ", 
"url" : "_git_cmd_load_project_from_repository.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Commandes de menus \/ Commande : Reconstruire le projet à partir du référentiel ", 
"snippet" : "Reconstruire le projet à partir du référentiel Fonction : La commande lance une Resynchronisation du projet. Appel : La commande n'est pas dans le menu Git par défaut. Exigence : Un projet est ouvert et ses versions sont gérées dans Git. CODESYS Git tente de reconstruire le projet à partir de l'état...", 
"body" : "Reconstruire le projet à partir du référentiel Fonction : La commande lance une Resynchronisation du projet. Appel : La commande n'est pas dans le menu Git par défaut. Exigence : Un projet est ouvert et ses versions sont gérées dans Git. CODESYS Git tente de reconstruire le projet à partir de l'état actuel à partir du répertoire de travail du référentiel Git. " }, 
{ "title" : "Commande : Synchroniser le projet avec le stockage de projet Git ", 
"url" : "_git_cmd_synchronize_project.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Commandes de menus \/ Commande : Synchroniser le projet avec le stockage de projet Git ", 
"snippet" : "Synchroniser le projet avec le stockage de projet Git Fonction : UN CODESYS projet qui est sous gestion Git est écrit dans le stockage de projet Git. Appel : Gite menu Exigence : Un projet Git est ouvert dans CODESYS . La synchronisation signifie que le courant CODESYS project dans le stockage de pr...", 
"body" : "Synchroniser le projet avec le stockage de projet Git Fonction : UN CODESYS projet qui est sous gestion Git est écrit dans le stockage de projet Git. Appel : Gite menu Exigence : Un projet Git est ouvert dans CODESYS . La synchronisation signifie que le courant CODESYS project dans le stockage de projet Git écrase le répertoire de travail actuel. " }, 
{ "title" : "Commande : Déplacer le référentiel ", 
"url" : "_git_cmd_move_repository.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Commandes de menus \/ Commande : Déplacer le référentiel ", 
"snippet" : "Déplacer le référentiel Fonction : La commande ouvre le Déplacer le référentiel Git boîte de dialogue pour déplacer le Stockage de projet Git avec tout son contenu dans un nouveau répertoire. Tous les contenus sont déplacés et l'historique de validation est également conservé. Appel : Gite menu Exig...", 
"body" : "Déplacer le référentiel Fonction : La commande ouvre le Déplacer le référentiel Git boîte de dialogue pour déplacer le Stockage de projet Git avec tout son contenu dans un nouveau répertoire. Tous les contenus sont déplacés et l'historique de validation est également conservé. Appel : Gite menu Exigence : Au moins un commit a déjà été effectué pour l'open CODESYS projet. Dialogue: Déplacer le référentiel Git Déplacer le référentiel de Chemin actuel Chemin du dépôt local du projet À Chemin de destination Répertoire de destination où le dépôt local est déplacé Condition : Le répertoire spécifié doit être vide. " }, 
{ "title" : "Commande : Comparer l'objet ", 
"url" : "_git_cmd_compare_object.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Commandes de menus \/ Commande : Comparer l'objet ", 
"snippet" : "Comparer l'objet Symbole : Fonction : Un objet qui est sélectionné dans le CODESYS L'arborescence du projet peut être comparée à son dernier état validé ou à l'état par étapes (index). Appel : Menu contextuel de l'objet sélectionné dans le navigateur de projet Exigence : Un projet Git est ouvert dan...", 
"body" : "Comparer l'objet Symbole : Fonction : Un objet qui est sélectionné dans le CODESYS L'arborescence du projet peut être comparée à son dernier état validé ou à l'état par étapes (index). Appel : Menu contextuel de l'objet sélectionné dans le navigateur de projet Exigence : Un projet Git est ouvert dans CODESYS . La commande ouvre le Vue de comparaison qui compare l'état actuel de l'objet dans le projet avec son dernier état validé dans le référentiel Git ou le dernier état de l'index. La fenêtre de gauche affiche l'état du projet (plus récent) et la fenêtre de droite affiche l'état du dernier commit ou le dernier état de l'index. " }, 
{ "title" : "Commande : Fusionner deux objets ", 
"url" : "_git_cmd_merge_two_objects.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Commandes de menus \/ Commande : Fusionner deux objets ", 
"snippet" : "Fusionner deux objets Fonction : Deux objets de même type sélectionnés dans le navigateur de projet peuvent être fusionnés. Appel : Menu contextuel, si les objets sont sélectionnés dans le navigateur de projet Exigence : Les objets doivent être du même type. Par exemple, un bloc fonction ne peut pas...", 
"body" : "Fusionner deux objets Fonction : Deux objets de même type sélectionnés dans le navigateur de projet peuvent être fusionnés. Appel : Menu contextuel, si les objets sont sélectionnés dans le navigateur de projet Exigence : Les objets doivent être du même type. Par exemple, un bloc fonction ne peut pas être fusionné avec une configuration de tâche. La commande ouvre le Fusionner <object1> dans <object2> voir. Cela correspond en grande partie à la vue qui est également utilisée pour comparer des objets. Là, vous pouvez définir explicitement quel contenu doit être appliqué de la source de fusion (fenêtre de gauche) à la destination de fusion (fenêtre de droite). Pour inverser le sens de la fusion, utilisez la Changer d'objet bouton. En conséquence, le contenu affiché des deux objets alterne entre les fenêtres gauche et droite. La fusion ne prend en compte que les objets affichés ici dans la vue. Leurs enfants ou propriétés ne sont ni fusionnés ni modifiés. Pour plus d'informations sur la vue de comparaison, voir : Vue de comparaison" }, 
{ "title" : "Commande : Créer une branche à partir du commit ", 
"url" : "_git_cmd_create_branch_from_commit.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Commandes de menus \/ Commande : Créer une branche à partir du commit ", 
"snippet" : "Créer une branche à partir du commit Symbole : Fonction : À partir d'un commit dans le L'histoire vue, une nouvelle branche est créée pour le projet concerné et est ensuite disponible dans le Succursales voir. Appel : Menu contextuel d'une entrée de commit dans le Histoire voir La commande ouvre le ...", 
"body" : "Créer une branche à partir du commit Symbole : Fonction : À partir d'un commit dans le L'histoire vue, une nouvelle branche est créée pour le projet concerné et est ensuite disponible dans le Succursales voir. Appel : Menu contextuel d'une entrée de commit dans le Histoire voir La commande ouvre le Créer une branche à partir du commit boîte de dialogue pour définir la nouvelle branche. " }, 
{ "title" : "Boîte de dialogue : créer une branche à partir d'un commit ", 
"url" : "_git_cmd_create_branch_from_commit.html#UUID-102fabea-ba95-ff2e-3b37-dc6bdeefb8e0_section-idm4573495381971233102385669569", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Commandes de menus \/ Commande : Créer une branche à partir du commit \/ Boîte de dialogue : créer une branche à partir d'un commit ", 
"snippet" : "Source de validation SHA1 SHA1 (identifiant unique) du commit Message Message de validation du commit Nouveau nom de succursale Nom sous lequel la nouvelle branche doit apparaître dans le Branches voir Force La nouvelle branche est créée même s'il existe déjà une branche portant le même nom et même ...", 
"body" : "Source de validation SHA1 SHA1 (identifiant unique) du commit Message Message de validation du commit Nouveau nom de succursale Nom sous lequel la nouvelle branche doit apparaître dans le Branches voir Force La nouvelle branche est créée même s'il existe déjà une branche portant le même nom et même s'il existe des modifications locales non validées. Vérifier La nouvelle branche est récupérée dans le Branches vue après sa création. " }, 
{ "title" : "Commande : Git Config ", 
"url" : "_git_cmd_git_config.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Commandes de menus \/ Commande : Git Config ", 
"snippet" : "Configuration Git Fonction : La commande ouvre une boîte de dialogue pour modifier les entrées du core , init , et user sections du .git\/config fichier de configuration. Ce fichier est stocké dans le dépôt Git local après l'initialisation Background: If you clone or initialize a repository and there...", 
"body" : "Configuration Git Fonction : La commande ouvre une boîte de dialogue pour modifier les entrées du core , init , et user sections du .git\/config fichier de configuration. Ce fichier est stocké dans le dépôt Git local après l'initialisation Background: If you clone or initialize a repository and there is no global .gitconfig file exists yet, then you will be asked to configure one initially. You can edit the file again at any time using the Git Config command. The global .gitconfig file is located in the user directory by default (example: C:\/Users\/<user name> ). Appel : Gite menu Exigence : L'ouvert CODESYS projet est géré dans Git dans un référentiel local. Dialogue : Modifiez votre configuration git. Les modifications seront stockées dans le fichier de configuration du référentiel. Noyau Longs chemins Cette option doit être activée pour que les longs chemins soient pris en charge et CODESYS Git peut fonctionner correctement. Init Branche par défaut La branche locale par défaut d'un dépôt Git (généralement master ) est créé automatiquement après le premier commit. Voir également : IntroductionUtilisateur Utilisateur Courrier électronique " }, 
{ "title" : "Symboles ", 
"url" : "_git_reference_symbols.html", 
"breadcrumbs" : "CODESYSGit \/ Référence, interface utilisateur \/ Symboles ", 
"snippet" : "Chaque objet a un statut dans l'index (changements échelonnés) et dans le Référentiel Git . L'état est affiché par un symbole correspondant devant l'objet dans les vues du navigateur du CODESYS projet ou dans le Statut et mise en scène voir. Symbole La description Inaltéré (dans le répertoire de tra...", 
"body" : "Chaque objet a un statut dans l'index (changements échelonnés) et dans le Référentiel Git . L'état est affiché par un symbole correspondant devant l'objet dans les vues du navigateur du CODESYS projet ou dans le Statut et mise en scène voir. Symbole La description Inaltéré (dans le répertoire de travail) L'objet est inchangé par rapport à l'index. Modifié (dans le répertoire de travail) L'objet a été modifié par rapport à la version précédente dans l'index. Nouveau (dans le répertoire de travail) L'objet existe dans le répertoire de travail, mais il n'est pas encore dans l'index ou le référentiel local. Conflit ou Problème relationnel Un conflit ou un problème de relation est survenu lors de la fusion de l'objet. Supprimé (dans le répertoire de travail) L'objet n'existe pas dans le répertoire de travail, mais il existe toujours dans l'index. Erreur Pas d'affectation à un statut Le symbole s'affiche uniquement dans le navigateur. Transitoire Les objets transitoires ne sont pas appliqués au référentiel Git. Le symbole s'affiche uniquement dans le navigateur. Le statut Git n'a pas encore pu être déterminé. Dès que l'état est connu, le symbole correspondant s'affiche. Le symbole s'affiche uniquement dans le navigateur. " }, 
{ "title" : "Troubleshooting – \"Unknown error\" ", 
"url" : "_git_troubleshooting.html", 
"breadcrumbs" : "CODESYSGit \/ Troubleshooting – \"Unknown error\" ", 
"snippet" : "The error message \"Unknown error\" appears for a number of errors which CODESYS cannot resolve by itself. However, there are ways for the user to correct some of these errors. In the message dialog with the error message, click the Details button to get more information about the error. See below for...", 
"body" : "The error message \"Unknown error\" appears for a number of errors which CODESYS cannot resolve by itself. However, there are ways for the user to correct some of these errors. In the message dialog with the error message, click the Details button to get more information about the error. See below for instructions on how to handle the respective error: " }, 
{ "title" : "Path too long ", 
"url" : "_git_troubleshooting.html#UUID-5b09f6b2-044d-09e7-27fa-a7ba0d49e5a2_section-idm23463169779052", 
"breadcrumbs" : "CODESYSGit \/ Troubleshooting – \"Unknown error\" \/ Path too long ", 
"snippet" : "This error message can appear if the file paths of the Git project in the file system are too long. To resolve the problem, you need to enable the Long paths option for Git. There are two possible solutions for this: Enable the option in the project via Git Config : In the open project, click the Gi...", 
"body" : "This error message can appear if the file paths of the Git project in the file system are too long. To resolve the problem, you need to enable the Long paths option for Git. There are two possible solutions for this: Enable the option in the project via Git Config : In the open project, click the Git → Git Config command. In the configuration dialog, enable the Long paths option. Click OK to exit the dialog. Close the project and open it again. Enable the option in the .gitconfig file of the user: Open the file C:\\Benutzer\\<user name>\\.gitconfig (example: C:\\Users\\m.muster\\.gitconfig ). Edit the file so that there is an entry longpaths = true in the core area. Then close the project and open it again. [core]    \n longpaths = true " }, 
{ "title" : "Conflict prevents checkout ", 
"url" : "_git_troubleshooting.html#UUID-5b09f6b2-044d-09e7-27fa-a7ba0d49e5a2_section-idm23463173497096", 
"breadcrumbs" : "CODESYSGit \/ Troubleshooting – \"Unknown error\" \/ Conflict prevents checkout ", 
"snippet" : "Cette erreur peut se produire avec les opérations Git qui effectuent une fusion ( git merge\/git pull ). Il y a probablement des fichiers modifiés dans le référentiel qui ne font pas partie du CODESYS projet. Ouvrez le Statut et mise en scène voir. Vérifiez si les fichiers « externes » sont répertori...", 
"body" : "Cette erreur peut se produire avec les opérations Git qui effectuent une fusion ( git merge\/git pull ). Il y a probablement des fichiers modifiés dans le référentiel qui ne font pas partie du CODESYS projet. Ouvrez le Statut et mise en scène voir. Vérifiez si les fichiers « externes » sont répertoriés sous Changements non planifiés . Cela signifie que les fichiers qui ne peuvent pas être trouvés en tant qu'objets dans le projet dans Appareils ou POU vues. Vous pouvez également vérifier si un fichier est un fichier externe comme suit : Double-cliquez sur l'entrée du fichier dans le Objet colonne du État et marque voir. Si le message d'erreur External objects are not supported in diff view apparaît à la place de la vue de comparaison, alors un objet externe existe. " }
]
$(document).trigger('search.ready');
});