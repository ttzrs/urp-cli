$(document).ready(function () {indexDict['fr'] = [{ "title" : "CODESYS Static Analysis ", 
"url" : "_san_start_page.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ CODESYS Static Analysis ", 
"snippet" : "Avec CODESYS Static Analysis , une vérification du code source CEI peut être effectuée à l'aide de règles définies, de conventions de dénomination ou de métriques. En conséquence, les indications d'éventuels problèmes de développement sont mises en évidence et les erreurs peuvent être identifiées et...", 
"body" : "Avec CODESYS Static Analysis , une vérification du code source CEI peut être effectuée à l'aide de règles définies, de conventions de dénomination ou de métriques. En conséquence, les indications d'éventuels problèmes de développement sont mises en évidence et les erreurs peuvent être identifiées et corrigées avant un test sur le terrain. Cela peut faire gagner beaucoup de temps lors du développement d’applications et de la vérification des erreurs. Dans CODESYS Static Analysis , plus de 100 règles (dont certaines paramétrables) sont déjà implémentées. Ces règles peuvent être combinées pour créer des ensembles de règles personnalisés. Dans certaines règles, les ensembles de règles définis dans les « PLCopen Coding Guidelines » sont inclus. Vous pouvez également définir une convention de dénomination pour chaque type de données possible, dont la conformité est ensuite vérifiée. En outre, plus de 20 mesures sont disponibles qui, si elles sont calculées régulièrement, peuvent analyser le code source sous-jacent et fournir des indications sur les tendances négatives et les écarts par rapport aux objectifs de qualité. Vous pouvez télécharger le CODESYS Static Analysis depuis CODESYS Boutique Internationale ou Boutique CODESYS Amérique du Nord . Vous y trouverez également la fiche technique du produit. Le produit est soumis à licence. Webinaire CODESYS Static Analysis Si CODESYS Static Analysis est installé mais aucune licence n'est activée, alors une interface réduite avec la fonctionnalité de Static Analysis Light est affiché. Comme alternative à CODESYS Static Analysis , CODESYS Development System fournit le Static Analysis Light Ajouter sur. Le module complémentaire fait automatiquement partie de CODESYS quand Non CODESYS Static Analysis est installé. " }, 
{ "title" : "Static Analysis Light ", 
"url" : "_san_start_page.html#UUID-cc139654-e7d3-fe83-903e-e33f8fd0a5ec_section-idm452529692233763389020840932", 
"breadcrumbs" : "CODESYS Static Analysis \/ CODESYS Static Analysis \/ Static Analysis Light ", 
"snippet" : "Static Analysis Light a un ensemble de fonctionnalités très limité et ne fournit que 7 vérifications de compilation. Le produit est disponible gratuitement. Vous pouvez activer les contrôles de compilation individuellement dans le Projet → Paramètres du projet menu, dans le Lumière d'analyse statiqu...", 
"body" : "Static Analysis Light a un ensemble de fonctionnalités très limité et ne fournit que 7 vérifications de compilation. Le produit est disponible gratuitement. Vous pouvez activer les contrôles de compilation individuellement dans le Projet → Paramètres du projet menu, dans le Lumière d'analyse statique catégorie. Pour plus d'informations, voir : Paramètres du projet : Lumière d'analyse statique " }, 
{ "title" : "Aperçu ", 
"url" : "_san_overview.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Aperçu ", 
"snippet" : "L'analyse statique est effectuée dans le projet en cours uniquement pour le code de l'application. Les bibliothèques et leurs codes sources ne sont pas analysés. CODESYS Static Analysis vous aide lors de l'implémentation afin d'écrire un code meilleur et plus lisible et d'identifier les parties de p...", 
"body" : "L'analyse statique est effectuée dans le projet en cours uniquement pour le code de l'application. Les bibliothèques et leurs codes sources ne sont pas analysés. CODESYS Static Analysis vous aide lors de l'implémentation afin d'écrire un code meilleur et plus lisible et d'identifier les parties de programme conflictuelles ou non prises en charge. Des sources d’erreurs potentielles sont notamment révélées. Par exemple, les emplacements sont identifiés où le code de test est toujours contenu. Ou bien des pointeurs sont trouvés qui ne sont pas vérifiés pour 0 avant le déréférencement. Ou (avec le SA0119 règle), les emplacements sont analysés où l'orientation objet est utilisée et les ports vers un autre environnement de développement, qui ne prend pas en charge l'orientation objet, ce qui rend cela impossible. La portabilité du code peut ainsi être garantie. Pour les erreurs signalées par Static Analysis sur la base des informations de précompilation, il existe un support pour une gestion immédiate des erreurs (\"Quickfix\"). Cela vous permet de trouver et de corriger rapidement les emplacements dans le code qui sont signalés lors de l'analyse. Pour améliorer la lisibilité du code source, vous pouvez définir des conventions de dénomination et vérifier leur conformité. De plus, pour évaluer la qualité du code, vous pouvez visualiser les métriques déterminées à partir du code source. Les exemples incluent la métrique McCabe comme mesure de la testabilité du code, ou la complexité cognitive comme mesure de la lisibilité et de la maintenabilité du code source. L'analyse du flux de données effectuée dans l'analyse statique est basée sur le principe de propagation constante. Avec le Créer → Effectuer une analyse statique commande de menu, vous activez explicitement l'analyse statique. Dans le Paramètres , vous activez une analyse statique qui est automatiquement effectuée après chaque compilation de code. Tu utilises déclarations pragmatiques pour exclure des parties individuelles ou des blocs de code de l’analyse. Dans le Règles Dans la boîte de dialogue, vous pouvez savoir quelles règles sont configurées, comment elles sont activées et quand les contrôles sont exécutés sur la règle respective. Là, vous activez les règles qui vous concernent. Dans le Conventions de dénomination , vous attribuez un préfixe à chaque type de données tel qu'il est ensuite attendu dans les déclarations. Des écarts sont signalés. Dans le Paramètres d'analyse statique : Métriques dans la boîte de dialogue, vous activez les métriques qui vous concernent. Avec le Afficher la complexité cognitive pour l'éditeur actuel commande, les incréments déterminés sont affichés ligne par ligne dans l'éditeur actif. Le Afficher les valeurs de propagation constante pour l'éditeur actuel La commande analyse en détail le flux de données dans l'éditeur actif et l'affiche chemin par chemin. En fonction de cela, des améliorations du code sont possibles. Pour plus d'informations, voir : Des règles, Métrique, et Pragmas et attributs" }, 
{ "title" : "Configuration et exécution d'une analyse statique ", 
"url" : "_san_configuring_and_running.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configuration et exécution d'une analyse statique ", 
"snippet" : "À l’aide d’un exemple de projet de base ci-dessous, vous trouverez les étapes et options les plus importantes pour configurer et exécuter une analyse statique. Exigences : CODESYS Static Analysis est installé....", 
"body" : "À l’aide d’un exemple de projet de base ci-dessous, vous trouverez les étapes et options les plus importantes pour configurer et exécuter une analyse statique. Exigences : CODESYS Static Analysis est installé. " }, 
{ "title" : "Exemple de projet ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-5b7b70fe166a598dc0a864631da88a82", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configuration et exécution d'une analyse statique \/ Exemple de projet ", 
"snippet" : "Si vous souhaitez reproduire l'exemple de projet, créez un projet standard et insérez les POU sous l'application dans l'arborescence des appareils. Configurez ensuite les paramètres de communication pour la connexion à votre réseau local. CODESYS Control Win . FUNCTION_BLOCK fb1 VAR_INPUT iVar_fb1in...", 
"body" : "Si vous souhaitez reproduire l'exemple de projet, créez un projet standard et insérez les POU sous l'application dans l'arborescence des appareils. Configurez ensuite les paramètres de communication pour la connexion à votre réseau local. CODESYS Control Win . FUNCTION_BLOCK fb1\nVAR_INPUT\n iVar_fb1in1 : INT;\n ivar_fb1in2 : INT;\n rVar_fb1in3 : REAL;\nEND_VAR\nVAR_OUTPUT\n iVar_fb1out:INT;\nEND_VAR\nVAR\n P_fSampleProperty : INT;\n rVar : REAL;\n PRO : BOOL;\nEND_VAR\n iVar_fb1out:=iVar_fb1in1 + 1; FUNCTION_BLOCK fb2\nVAR_INPUT\n iVar_fb2in:INT;\nEND_VAR\nVAR_OUTPUT\n iVar_fb2out:INT;\nEND_VAR\nVAR\nEND_VAR\n iVar_fb2out:=iVar_fb2in - 1; PROGRAM PLC_PRG\nVAR\n fb1_inst: fb1;\n fb2_inst: fb2;\nEND_VAR fb1_inst(iVar_fb1in1 := 99);\nfb2_inst(iVar_fb2in := 22);\nfb2_inst(iVar_fb2in := 1); " }, 
{ "title" : "Vérification du respect des règles ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-9641312f166a598dc0a864630126d291", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configuration et exécution d'une analyse statique \/ Vérification du respect des règles ", 
"snippet" : "Cliquez sur Construire → Analyse statique → Paramètres . Passez à la Des règles languette . Une liste s'affiche contenant toutes les vérifications de règles possibles. Ils sont organisés selon une arborescence par catégorie thématique. Le « numéro de règle » est ajouté entre parenthèses (exemple : V...", 
"body" : "Cliquez sur Construire → Analyse statique → Paramètres . Passez à la Des règles languette . Une liste s'affiche contenant toutes les vérifications de règles possibles. Ils sont organisés selon une arborescence par catégorie thématique. Le « numéro de règle » est ajouté entre parenthèses (exemple : Variables inutilisées (33) dans la catégorie Objets inutilisés ). Cochez plusieurs fois la case de la première ligne ( Règles nœud). Cliquer pour basculer l'état d'activation. Les cases à cocher dans l'ensemble de l'arborescence comportent une coche rouge ou orange, voire aucune coche du tout. De cette manière, activez toutes les entrées avec une coche rouge. Cela signifie que CODESYS Static Analysis doit signaler toute violation de règle détectée comme une erreur. Cliquez sur Construire → Analyse statique → Exécuter une analyse statique . Les erreurs sont signalées dans la vue des messages. Les textes des messages sont marqués d'un et commencer par le numéro d'erreur \"SA<numéro de règle>\". Double-cliquez sur le message SA0033 : Variables inutilisées 'iVar_fb2out' . Le focus se déplace vers la partie déclaration du bloc fonction fb2 et la variable pertinente est sélectionnée. La variable est déclarée, mais pas utilisée. Ceci est vérifié dans la règle 33 ( Variables inutilisées ). Dans le code, les emplacements concernés sont soulignés par un trait ondulé. Pour tester l'exécution automatique de l'analyse, cliquez sur Construire → Analyse statique → Paramètres . Sur le Paramètres onglet, sélectionnez l'onglet Effectuer une analyse statique automatiquement après la compilation option. Cliquez sur D'ACCORD pour quitter la boîte de dialogue. Cliquez sur En ligne → Connexion . Une invite de dialogue indique que des erreurs de compilation existent. Les erreurs signalées par l'analyse du code sont à nouveau affichées dans la vue des messages. Cliquez sur Construire → Analyse statique → Paramètres . Passez au Règles languette. Effacez maintenant toutes les règles de la boîte de dialogue. Dans le Objets inutilisés catégorie, activez explicitement la règle SA0035 ( Variables d'entrée inutilisées (35) ) avec une coche de couleur orange pour signaler un « avertissement ». Consultez l'info-bulle pour le texte de la règle : Cette règle correspond aux règles PLCopen suivantes : CP24 ). Cliquez sur D'ACCORD pour quitter la boîte de dialogue. Cliquez sur Construire → Générer du code . L'analyse est effectuée automatiquement. Dans la vue des messages, deux erreurs sont signalées au Messages d'analyse statique catégorie: § SA0035 : Entrée inutilisée 'iVar_fb1in2' § SA0035 : Entrée inutilisée 'iVar_fb1in3' Double-cliquez sur le message et commentez ou supprimez la déclaration. Effectuez à nouveau l’analyse du code. Aucun message d'erreur ne s'affiche. " }, 
{ "title" : "Vérification de la conformité aux conventions de dénomination définies ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-d64b88b5166a598dc0a864632e22b38d", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configuration et exécution d'une analyse statique \/ Vérification de la conformité aux conventions de dénomination définies ", 
"snippet" : "Cliquez sur Construire → Analyse statique → Paramètres . Passez au Conventions de nommage languette. Vous voyez un tableau dans une structure arborescente divisée en catégories extensibles de variables et de blocs de programme. Élargir la Préfixes pour les variables – Préfixes pour les types catégor...", 
"body" : "Cliquez sur Construire → Analyse statique → Paramètres . Passez au Conventions de nommage languette. Vous voyez un tableau dans une structure arborescente divisée en catégories extensibles de variables et de blocs de programme. Élargir la Préfixes pour les variables – Préfixes pour les types catégorie, et dans la Préfixe colonne, précisez I pour INT (14) . Élargir la Préfixes pour les POU – Préfixes pour le type de POU catégorie. Dans le Préfixe colonne, précisez le prog pour PROGRAMME (122) et fb pour BLOC FONCTIONNEL (103) . Sélectionnez le Le premier caractère après le préfixe doit être une lettre majuscule option. Désactivez toutes les autres options. Cliquez sur Construire → Analyse statique → Exécuter une analyse statique . Messages d'erreur: NC0102 : Nom non valide 'PLC_PRG' : attendez le préfixe 'prog' car PLC_PRG n'a pas le préfixe requis Le premier caractère après le préfixe doit être en majuscule : 'ivar_fb1in2' parce que ivar_fb1in2 : INT; est dans fb1 . NC0014 : Nom de variable non valide P_fSampleProperty : Attendez-vous au préfixe « i » car cette variable entière n'a pas le préfixe requis. " }, 
{ "title" : "Vérification des symboles interdits ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-7e83abe1166a598dc0a86463714e1dc5", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configuration et exécution d'une analyse statique \/ Vérification des symboles interdits ", 
"snippet" : "Cliquez sur Construire → Analyse statique → Paramètres . Passez à la Symboles interdits languette . Un éditeur de ligne permet de spécifier des chaînes à ne pas utiliser dans le code. Par exemple, double-cliquez sur la ligne vide et saisissez la chaîne invalide PRO directement. Double-cliquez sur la...", 
"body" : "Cliquez sur Construire → Analyse statique → Paramètres . Passez à la Symboles interdits languette . Un éditeur de ligne permet de spécifier des chaînes à ne pas utiliser dans le code. Par exemple, double-cliquez sur la ligne vide et saisissez la chaîne invalide PRO directement. Double-cliquez sur la ligne vierge suivante et cliquez sur le pour ouvrir l'assistant de saisie. À partir de Types standards , sélectionnez RÉEL . Cliquez sur d'accord pour quitter la boîte de dialogue. Cliquez sur Construire → Analyse statique → Exécuter une analyse statique . Les messages d'erreur Forbidden symbol 'REAL' et Forbidden symbol 'PRO' sont affichés dans la vue des messages. Double-cliquez sur le texte du message pour accéder à la ligne de code correspondante. " }, 
{ "title" : "Affichage des métriques ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configuration et exécution d'une analyse statique \/ Affichage des métriques ", 
"snippet" : "CODESYS Static Analysis effectue des tests sélectionnés sur le code et vous pouvez afficher les résultats dans une vue. Cliquez sur Construire → Analyse statique → Paramètres . Passez à la Métrique languette . Les métriques qui CODESYS Static Analysis s'applique au code sont répertoriés dans un tabl...", 
"body" : "CODESYS Static Analysis effectue des tests sélectionnés sur le code et vous pouvez afficher les résultats dans une vue. Cliquez sur Construire → Analyse statique → Paramètres . Passez à la Métrique languette . Les métriques qui CODESYS Static Analysis s'applique au code sont répertoriés dans un tableau. Pour cet exemple, activez le Nombre de variables d'entrée métrique et spécifier la plage de valeurs autorisée : limite inférieure 1 et limite supérieure 2 . Activez certaines mesures supplémentaires, telles que taille du code , nombre de vues Etc. Cliquez sur Construire → Analyse statique → Afficher les métriques standard . La vue comprend un tableau avec une ligne pour chacun Unité de programme de l’exemple de programme. Pour chaque métrique activée, il existe une colonne affichant les valeurs mesurées. Les valeurs qui se situent en dehors de la plage de valeurs définie dans les paramètres sont surlignées en rouge. Dans le cas de cet exemple spécifique, c'est au moins le PLC_PRG\/Entrées champ car le nombre de variables d'entrée dans ce POU est supérieur à la limite supérieure définie de 2 . " }, 
{ "title" : "Correction rapide des violations de règles dans le code ST ", 
"url" : "_san_fix_errors_quickly.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Correction rapide des violations de règles dans le code ST ", 
"snippet" : "Dans le Paramètres d'analyse statique dialogue, sur le Des règles , vous pouvez activer les règles pour le code ST. La conformité de ces règles est vérifiée sur la base des informations précompilées. Aucun appel explicite de l'analyse statique n'est nécessaire pour détecter de telles violations de r...", 
"body" : "Dans le Paramètres d'analyse statique dialogue, sur le Des règles , vous pouvez activer les règles pour le code ST. La conformité de ces règles est vérifiée sur la base des informations précompilées. Aucun appel explicite de l'analyse statique n'est nécessaire pour détecter de telles violations de règle. Le respect des règles est vérifié dans l'éditeur ST actif lors de la précompilation et après une compilation réussie. Lorsqu'une violation de règle se produit, elle est immédiatement affichée dans l'éditeur ST par un soulignement ondulé. De plus, dans la vue des messages, les messages d'erreur ou les avertissements sont répertoriés dans le Précompiler voir. Un guide pour cela : Vérification de la conformité aux conventions de dénomination définiesVous pouvez trouver le Quickfix soit dans l'éditeur ST en cliquant sur le code souligné en forme d'onde, puis en cliquant sur le symbole de l'ampoule. , ou dans la vue des messages à l'aide du dans la ligne du message d'erreur. Dans chaque cas, vous disposez des commandes correspondantes pour gérer la violation des règles. Pour le Quickfix, les commandes suivantes sont fournies, chacune dépendant de l'erreur : Ignorer l'erreur\/l'avertissement La commande permet d'insérer automatiquement des pragmas ou des attributs dans le code, ce qui exclut une vérification de la règle correspondante pour cette ligne de code. Ignorer l'erreur\/l'avertissement globalement pour <nom de l'objet de programmation> La commande permet d'insérer automatiquement un attribut au début de la partie déclaration de l'objet de programmation. Une vérification de la règle correspondante pour cet objet de programmation est alors exclue. Commande avec une suggestion sur la façon de modifier le code ST pour éviter la violation de la règle (Quickfix). Exemple: SA0168 : Supprimer l'affectation 'enum1 := 5' Désactiver le contrôle La commande permet de désactiver la vérification de la règle correspondante dans les paramètres. Vous pouvez annuler les effets de l'appel de n'importe quelle commande. Pour ce faire, cliquez d'abord dans le Dispositifs voir (ou POU voir). Puis le annuler commande est activée. " }, 
{ "title" : "Activation des règles ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-1cca77b1336bf579c0a8646302e5e6f3", 
"breadcrumbs" : "CODESYS Static Analysis \/ Correction rapide des violations de règles dans le code ST \/ Activation des règles ", 
"snippet" : "Cliquez sur Construire → Analyse statique → Paramètres . Passez à la Des règles languette. Une liste s'affiche contenant toutes les vérifications de règles possibles. Ils sont organisés en arborescence par catégorie thématique. Le \"numéro de règle\" est ajouté entre parenthèses. Vous pouvez filtrer l...", 
"body" : "Cliquez sur Construire → Analyse statique → Paramètres . Passez à la Des règles languette. Une liste s'affiche contenant toutes les vérifications de règles possibles. Ils sont organisés en arborescence par catégorie thématique. Le \"numéro de règle\" est ajouté entre parenthèses. Vous pouvez filtrer les règles, les trier par options ou les afficher dans une liste. Clique le Affichage structuré filtre ( symbole), puis sélectionnez le Structuré par moment d'exécution option. Les règles qui peuvent également être vérifiées lors de la précompilation sont répertoriées sous le Exécuté pendant la précompilation et après une compilation réussie nœud. Ce sont les règles qui sont identifiées par une coche dans le Précompiler colonne. Dans la colonne de gauche, vous pouvez désormais activer la règle de contrôle. Cliquez sur la case à cocher dans la ligne de règle (168) pour que l'état passe de \"coche rouge\" à \"coche jaune\" à \"pas de coche\". Une coche rouge signifie que la violation de la règle est émise sous la forme d'un message d'erreur. Une coche jaune signifie que la violation de la règle est émise comme un avertissement. Aucune coche signifie que la règle n'est pas cochée. Les règles activées sont maintenant cochées. En cas de violation, ils sont marqués dans le code et affichés dans la vue des messages. " }, 
{ "title" : "Affichage des violations de règles dans la vue des messages ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-8f3e8ec3336bf579c0a86463654e2139", 
"breadcrumbs" : "CODESYS Static Analysis \/ Correction rapide des violations de règles dans le code ST \/ Affichage des violations de règles dans la vue des messages ", 
"snippet" : "Cliquez sur Affichage → Messages . La vue des messages s'ouvre. Dans la vue des messages, dans la zone de liste, sélectionnez le Précompiler Catégorie. Dans cette catégorie, seules les violations de règles sont affichées, qui ont été détectées lors de la précompilation et après une compilation réuss...", 
"body" : "Cliquez sur Affichage → Messages . La vue des messages s'ouvre. Dans la vue des messages, dans la zone de liste, sélectionnez le Précompiler Catégorie. Dans cette catégorie, seules les violations de règles sont affichées, qui ont été détectées lors de la précompilation et après une compilation réussie et que vous pouvez résoudre avec Quickfix. Le Le bouton fournit les commandes respectives pour cela. " }, 
{ "title" : "Exécution d'un correctif rapide ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-8a9adfb3336bf579c0a8646308d0b385", 
"breadcrumbs" : "CODESYS Static Analysis \/ Correction rapide des violations de règles dans le code ST \/ Exécution d'un correctif rapide ", 
"snippet" : "Dans les paramètres, la règle 168 est activée et une violation de règle est affichée dans l'éditeur ST. Condition préalable : Au moins une ligne est soulignée en forme de vague dans le code ST et le numéro SA correspondant est affiché dans la vue des messages. Cliquez sur la ligne de code avec le so...", 
"body" : "Dans les paramètres, la règle 168 est activée et une violation de règle est affichée dans l'éditeur ST. Condition préalable : Au moins une ligne est soulignée en forme de vague dans le code ST et le numéro SA correspondant est affiché dans la vue des messages. Cliquez sur la ligne de code avec le soulignement ondulé. Le Le symbole s'affiche. Cliquez sur le symbole de l'ampoule. Une fenêtre avec les commandes de menu pour la gestion des erreurs s'ouvre. Vous voulez corriger l'erreur. Par conséquent, vous cliquez sur la commande Affectation 'enum1 := GVL.CONST' . Maintenant, la ligne de code est modifiée automatiquement, comme indiqué dans la commande. L'erreur est corrigée. La troisième commande inclut une suggestion sur la façon de corriger l'erreur en modifiant le code, en fonction de la violation de la règle. La même gestion des erreurs est possible en cliquant sur le dans la ligne de message d'erreur de la vue des messages. " }, 
{ "title" : "Désactivation de la vérification des règles pour une ligne de code ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-107e44f0336bf579c0a8646347e7d5cc", 
"breadcrumbs" : "CODESYS Static Analysis \/ Correction rapide des violations de règles dans le code ST \/ Désactivation de la vérification des règles pour une ligne de code ", 
"snippet" : "Dans les paramètres, la règle 168 est activée et une violation de règle est affichée dans l'éditeur ST. Condition préalable : Au moins une ligne est soulignée en forme de vague dans le code ST et le numéro SA correspondant est affiché dans la vue des messages. Cliquez sur la ligne de code avec le so...", 
"body" : "Dans les paramètres, la règle 168 est activée et une violation de règle est affichée dans l'éditeur ST. Condition préalable : Au moins une ligne est soulignée en forme de vague dans le code ST et le numéro SA correspondant est affiché dans la vue des messages. Cliquez sur la ligne de code avec le soulignement ondulé. Le Le symbole s'affiche. Cliquez sur le symbole de l'ampoule. Une fenêtre avec les commandes de menu pour la gestion des erreurs s'ouvre. Vous ne voulez pas corriger l'erreur. Par conséquent, vous cliquez sur la commande Ignorer l'erreur\/l'avertissement . Désormais, la ligne de code est automatiquement dotée de pragmas. Les pragmas sont utilisés pour empêcher la vérification de la ligne de la règle concernée. Aucun message d'erreur ou avertissement n'est émis. La commande pour désactiver la vérification des règles pour la ligne de code affectée est également disponible au moyen de la dans la ligne du message d'erreur dans la vue des messages. " }, 
{ "title" : "Désactivation de la vérification des règles pour un objet de programmation ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-6dee377f336bf579c0a8646357b65fa8", 
"breadcrumbs" : "CODESYS Static Analysis \/ Correction rapide des violations de règles dans le code ST \/ Désactivation de la vérification des règles pour un objet de programmation ", 
"snippet" : "Dans les paramètres, la règle 168 est activée et une violation de règle est affichée dans l'éditeur ST. Condition préalable : Au moins une ligne est soulignée en forme de vague dans le code ST et le numéro SA correspondant est affiché dans la vue des messages. Cliquez sur la ligne de code avec le so...", 
"body" : "Dans les paramètres, la règle 168 est activée et une violation de règle est affichée dans l'éditeur ST. Condition préalable : Au moins une ligne est soulignée en forme de vague dans le code ST et le numéro SA correspondant est affiché dans la vue des messages. Cliquez sur la ligne de code avec le soulignement ondulé. Le Le symbole s'affiche. Cliquez sur le symbole de l'ampoule. Une fenêtre avec les commandes de menu pour la gestion des erreurs s'ouvre. Vous ne voulez pas que l'objet de programmation soit vérifié avec la règle spécifiée. Par conséquent, vous cliquez sur la deuxième commande Ignorer l'erreur\/l'avertissement globalement pour PLC_PRG . La déclaration de l'objet est désormais automatiquement dotée d'un attribut. L'attribut est utilisé pour empêcher la règle affectée d'être vérifiée pour l'objet. Aucun message d'erreur ou avertissement n'est émis. La commande pour ignorer le message est également disponible au moyen de la dans la ligne du message d'erreur dans la vue des messages. " }, 
{ "title" : "Désactivation de la vérification des règles en général ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ Correction rapide des violations de règles dans le code ST \/ Désactivation de la vérification des règles en général ", 
"snippet" : "Dans les paramètres, la règle 168 est activée et une violation de règle est affichée dans l'éditeur ST. Condition préalable : Au moins une ligne est soulignée en forme de vague dans le code ST et le numéro SA correspondant est affiché dans la vue des messages. Cliquez sur la ligne de code avec le so...", 
"body" : "Dans les paramètres, la règle 168 est activée et une violation de règle est affichée dans l'éditeur ST. Condition préalable : Au moins une ligne est soulignée en forme de vague dans le code ST et le numéro SA correspondant est affiché dans la vue des messages. Cliquez sur la ligne de code avec le soulignement ondulé. Le Le symbole s'affiche. Cliquez sur le symbole de l'ampoule. Une fenêtre avec les commandes de menu pour la gestion des erreurs s'ouvre. Vous ne voulez plus que la règle affichée soit vérifiée. Par conséquent, vous cliquez sur la quatrième commande Désactiver le contrôle . La règle est désactivée dans les paramètres d'analyse statique. Cliquez sur Construire → Analyse statique → Paramètres . Passez à la Des règles languette. La règle 168 est désactivée. La commande pour désactiver globalement le contrôle est également disponible au moyen de la dans la ligne du message d'erreur dans la vue des messages. " }, 
{ "title" : "Définition des conventions de nommage ", 
"url" : "_san_define_naming_conventions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Définition des conventions de nommage ", 
"snippet" : "Dans le Paramètres d'analyse statique dialogue, sur le Conventions de nommage , définissez les conventions de nommage que vous suivrez dans votre code. Vous définissez des préfixes pour les identifiants de vos POU, variables et types de données en fonction de leurs étendues et qualificateurs. Ensuit...", 
"body" : "Dans le Paramètres d'analyse statique dialogue, sur le Conventions de nommage , définissez les conventions de nommage que vous suivrez dans votre code. Vous définissez des préfixes pour les identifiants de vos POU, variables et types de données en fonction de leurs étendues et qualificateurs. Ensuite, vous pouvez laisser l'analyse statique vérifier la conformité des conventions de nommage. Un guide pour cela : Vérification de la conformité aux conventions de dénomination définies" }, 
{ "title" : "Définition des préfixes ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-291ced2808fb693bc0a8646323d0819d", 
"breadcrumbs" : "CODESYS Static Analysis \/ Définition des conventions de nommage \/ Définition des préfixes ", 
"snippet" : "Dans le Paramètres d'analyse statique dialogue, sur le Conventions de nommage , définissez les conventions de nommage dans le champ de saisie de l'onglet Préfixe colonne. Caractère littéral Exemple: PRG_ dans Préfixes pour les POU , Préfixes pour le type de POU , PROGRAMME (102) Plusieurs littéraux ...", 
"body" : "Dans le Paramètres d'analyse statique dialogue, sur le Conventions de nommage , définissez les conventions de nommage dans le champ de saisie de l'onglet Préfixe colonne. Caractère littéral Exemple: PRG_ dans Préfixes pour les POU , Préfixes pour le type de POU , PROGRAMME (102) Plusieurs littéraux par entrée séparés par une virgule Syntaxe: <prefix> ( , <next prefix> )* Exemple: PRG_, PRG dans Préfixes pour les POU , Préfixes pour le type de POU , PROGRAMME (102) Expression régulière RegEx qui définit un ensemble de préfixes Syntaxe: @ <expression> Exemples: @x[a-dA-D] définit un préfixe commençant par x , suivi d'exactement un caractère dans le jeu a-dA-D @[A-Za-z][A-Za-z][A-Za-z][A-Za-z0-9] définit un préfixe composé de quatre caractères : les trois premiers caractères sont des lettres et le quatrième caractère peut également être un chiffre. " }, 
{ "title" : "Définition de préfixes pour les types de données combinables ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-e9a24404c19ad708c0a86463215af896", 
"breadcrumbs" : "CODESYS Static Analysis \/ Définition des conventions de nommage \/ Définition de préfixes pour les types de données combinables ", 
"snippet" : "Les types de données suivants sont basés sur des types de données standard, des types de données existants ou des blocs fonctionnels : Aiguille: POINTER TO <basic type> Référence: REFERENCE TO <basic type> Déployer: ARRAY[ <lower index bound> .. <upper index bound> ] OF <basic type> Ces types de don...", 
"body" : "Les types de données suivants sont basés sur des types de données standard, des types de données existants ou des blocs fonctionnels : Aiguille: POINTER TO <basic type> Référence: REFERENCE TO <basic type> Déployer: ARRAY[ <lower index bound> .. <upper index bound> ] OF <basic type> Ces types de données peuvent être imbriqués et mutuellement combinés. Quand le Préfixes récursifs pour les types de données combinables est sélectionnée, l'analyse statique attend des préfixes combinés de manière récursive pour les variables de ces types de données combinables. Les préfixes suivent la déclaration et correspondent aux conventions de nommage définies pour les types de données de base. Exemple Les conventions de dénomination suivantes ont été définies : i dans Préfixes pour les variables , INT (26) p dans Préfixes pour les variables , POINTEUR (26) ref dans Préfixes pour les variables , RÉFÉRENCE (27) struct dans Préfixes pour les variables , Ouvrage (32) Préfixes récursifs pour les types de données combinables option: Le code suivant ne respecte pas les conventions de dénomination et est difficile à lire. PROGRAM plc1\nVAR\n var1 : ARRAY[100..110] OF ARRAY[30..50] OF ARRAY[6..7] OF BOOL;\n var2 : ARRAY[1..3] OF INT;\n var3 : REFERENCE TO INT;\n iVar4 : INT;\n iVar5 : INT;\n var6 : ARRAY[1..3] OF INT := [11, 22, 33];\n var7 : POINTER TO ARRAY[1..3] OF INT;\n var8 : REFERENCE TO INT;\n var9 : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n var0 : ARRAY[0..3] OF S_POLYGONLINE; \/\/ S_POLYGONLINE is a already defined structure\nEND_VAR\n\niVar4 := iVar4 + 1;\nvar8 REF= iVar4;\nvar1[100][30][6] := TRUE;\nvar9.aiPoint1[1] := 99;\nvar7 := ADR(var6);\nvar6[2] := 44;\niVar5 := var7^[2];\nvar0[0] := var9; L'analyse statique signale les violations suivantes des conventions de dénomination : NC0102 : Nom invalide 'plc1' : Préfixe attendu 'PRG_' NC0014 : Nom de variable 'var0' non valide : préfixe 'astruct' attendu NC0014 : Nom de variable 'var1' non valide : préfixe attendu 'aaax' NC0014 : Nom de variable 'var2' non valide : préfixe 'ai' attendu NC0014 : Nom de variable 'var3' non valide : préfixe 'refi' attendu NC0014 : Nom de variable 'var6' non valide : préfixe 'ai' attendu NC0014 : Nom de variable 'var7' non valide : préfixe 'pai' attendu NC0014 : Nom de variable 'var8' non valide : préfixe 'refi' attendu NC0014 : Nom de variable 'var9' non valide : préfixe 'struct' attendu " }, 
{ "title" : "Définir des préfixes pour les variables d'un alias ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-9f66c39a945e11eab0a0b46479d263a5", 
"breadcrumbs" : "CODESYS Static Analysis \/ Définition des conventions de nommage \/ Définir des préfixes pour les variables d'un alias ", 
"snippet" : "Vous pouvez définir des préfixes pour les variables de type de données Alias comme un littéral avec l'espace réservé {datatype} . Ensuite, Static Analysis attend le préfixe du type de données de base au lieu de l'espace réservé. le Combiner le préfixe de portée avec le préfixe de type de données l'o...", 
"body" : "Vous pouvez définir des préfixes pour les variables de type de données Alias comme un littéral avec l'espace réservé {datatype} . Ensuite, Static Analysis attend le préfixe du type de données de base au lieu de l'espace réservé. le Combiner le préfixe de portée avec le préfixe de type de données l'option n'a aucun effet sur l'utilisation du préfixe {datatype} . Exemple Les conventions de dénomination suivantes ont été définies : s dans Préfixes pour les variables , Préfixes pour les types , CHAÎNE()19 A_{datatype} dans Préfixes pour les variables , Alias (33) Code TYPE A_MESSAGE : STRING[50]; \/\/ base data type is STRING\nEND_TYPE\n\nVAR\n A_sMessage_N1 : A_MESSAGE := 'Robot is running.';\n A_s_Message_N2 : A_MESSAGE := 'Robot has been finished.';\n As_Message_N3 : A_MESSAGE := 'Robot has been stopped.';\n AsMessage_N4 : A_MESSAGE := 'Error 3 has been occured.';\nEND_VAR L'analyse statique signale la violation suivante de la convention d'attribution de noms : NC0033 : Nom de variable invalide 'As_Message_N3' : préfixe attendu 'A_s' NC0033 : Nom de variable invalide 'AsMessage_N4' : préfixe attendu 'A_s' " }, 
{ "title" : "Définition de préfixes pour les propriétés ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-e0cda739c19ad708c0a864636e955ca0", 
"breadcrumbs" : "CODESYS Static Analysis \/ Définition des conventions de nommage \/ Définition de préfixes pour les propriétés ", 
"snippet" : "Vous pouvez définir le préfixe pour les POU de type de données PROPERTY comme un littéral avec l'espace réservé {datatype} . Ensuite, Static Analysis attend le préfixe du type de données de retour de la propriété au lieu de l'espace réservé. le Combiner le préfixe de portée avec le préfixe de type d...", 
"body" : "Vous pouvez définir le préfixe pour les POU de type de données PROPERTY comme un littéral avec l'espace réservé {datatype} . Ensuite, Static Analysis attend le préfixe du type de données de retour de la propriété au lieu de l'espace réservé. le Combiner le préfixe de portée avec le préfixe de type de données l'option n'a aucun effet sur l'utilisation de l'espace réservé {datatype} . Exemple Les conventions de dénomination suivantes ont été définies : fb dans Préfixes pour les variables , Préfixes pour les types , Instance de bloc fonction FB_ dans Préfixes pour les POU , Préfixes pour le type de POU , BLOC FONCTION (103) prop_{datatype} dans Préfixes pour les POU , Préfixes pour le type de POU , IMMOBILIER (107) Code FUNCTION_BLOCK blocka \/\/ Invalid function block name\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\nPROPERTY PUBLIC vara : INT \/\/ Invalid property name, return data type is INT\nGet\n vara := iA;\nSet\niA := vara;\n\nPROGRAM plc1\nVAR\n var10 : blocka; \/\/ Invalid variable name of typ function block\n iVar11: INT;\nEND_VAR\n\nvar10();\nIF var10.vara > 500 THEN\n var10.vara := 0;\nEND_IF\niVar11 := var10.vara; L'analyse statique signale la violation suivante des conventions de dénomination : NC0102 : Nom invalide 'plc1' : Préfixe attendu 'PRG_' NC0031 : Nom de variable 'var10' non valide : préfixe 'fb' attendu NC0103 : Nom de variable invalide ''blocka' : préfixe attendu 'FB_' NC0107 : Nom de variable invalide 'blocka.vara' : préfixe attendu 'prop_i' Code selon les conventions de nommage FUNCTION_BLOCK FB_A\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\nPROPERTY PUBLIC prop_iA : INT\nGet\n prop_iA := iA;\nSet\n iA := prop_iA;\n\nPROGRAM PRG_PLC1\nVAR\n fbA : FB_A;\n iVar11: INT;\nEND_VAR\n\nfbA();\nIF fbA.prop_iA > 500 THEN\n fbA.prop_iA := 0;\nEND_IF\niVar11 := fbA.prop_iA; " }, 
{ "title" : "Définition des préfixes pour les structures ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-ed64228609104c08c0a864630c58c86b", 
"breadcrumbs" : "CODESYS Static Analysis \/ Définition des conventions de nommage \/ Définition des préfixes pour les structures ", 
"snippet" : "Vous pouvez définir un préfixe général pour les structures du projet dans Préfixes pour les DUT , Ouvrage (151) . Vous pouvez également donner à une structure un préfixe spécial. Le préfixe spécial remplace alors le préfixe général. Le préfixe spécial est défini dans la déclaration du type de donnée...", 
"body" : "Vous pouvez définir un préfixe général pour les structures du projet dans Préfixes pour les DUT , Ouvrage (151) . Vous pouvez également donner à une structure un préfixe spécial. Le préfixe spécial remplace alors le préfixe général. Le préfixe spécial est défini dans la déclaration du type de données de la structure avec le pragma {attribute 'nameprefix' := <special prefix> '} . Commencez ensuite toutes les variables de cette structure avec ce préfixe <special prefix> . Exemple Les conventions de dénomination suivantes ont été définies : struct dans Préfixes pour les variables , Ouvrage (32) S_ dans Préfixes pour les DUT , Ouvrage (151) Préfixes récursifs pour les types de données combinables : Code TYPE S_POLYGONLINE :\nSTRUCT\n aiStart : ARRAY[1..2] OF INT := [-99, -99];\n aiPoint1 : ARRAY[1..2] OF INT;\n aiPoint2 : ARRAY[1..2] OF INT;\n aiPoint3 : ARRAY[1..2] OF INT;\n aiPoint4 : ARRAY[1..2] OF INT;\n aiEnd : ARRAY[1..2] OF INT := [99, 99];\nEND_STRUCT\nEND_TYPE\n\n{attribute 'nameprefix' := 'penta'} \/\/ Pragma to define a special prefix\nTYPE S_PENTA EXTENDS S_POLYGONLINE :\nSTRUCT\n aiPoint5 : ARRAY[1..2] OF INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PRG_Compute\nVAR\n structPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n structPentagon : S_PENTAGON := (aiStart:=[0,0], aiPoint1:=[1,1], aiPoint2:=[2,2], aiPoint3:=[3,3], aiPoint4:=[4,4], aiPoint5:=[5,5]);\n structLine0 : S_PENTA;\n pentaLine1 : S_PENTA;\n iXPoint: INT;\n aPoint0: ARRAY [1..2] OF INT;\n aPoint1: ARRAY [1..2] OF INT;\nEND_VAR\n\niXPoint := structPolygon.aiPoint1[1];\naPoint0 := structLine0.aiEnd;\naiPoint1 := pentaLine1.aiEnd; L'analyse statique signale la violation suivante des conventions de dénomination : Nom de variable non valide 'structLine0' : préfixe attendu 'penta' " }, 
{ "title" : "Fournir d'autres CODESYS Static Analysis projets avec des conventions de nommage ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ Définition des conventions de nommage \/ Fournir d'autres CODESYS Static Analysis projets avec des conventions de nommage ", 
"snippet" : "Enregistrez vos conventions de dénomination dans un fichier CSA. Vous pouvez charger et utiliser ce fichier dans d'autres CODESYS Static Analysis projets. Enregistrement dans un fichier Cliquez sur Construire → Analyse statique → Paramètres . Clique le Sauvegarder bouton. Une boîte de dialogue de sé...", 
"body" : "Enregistrez vos conventions de dénomination dans un fichier CSA. Vous pouvez charger et utiliser ce fichier dans d'autres CODESYS Static Analysis projets. Enregistrement dans un fichier Cliquez sur Construire → Analyse statique → Paramètres . Clique le Sauvegarder bouton. Une boîte de dialogue de sélection de fichier s'ouvre. Là, vous pouvez stocker les conventions de dénomination dans un fichier sous n'importe quel nom avec l'extension de fichier CSA. Chargement d'un fichier avec des conventions de nommage Cliquez sur Construire → Analyse statique → Paramètres . Clique le Charger bouton. La boîte de dialogue de sélection de fichier s'ouvre. Sélectionnez l'un des fichiers CSA affichés ci-dessous. " }, 
{ "title" : "Détection des clones de code ", 
"url" : "_san_find_code_clone.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Détection des clones de code ", 
"snippet" : "Exigences: CODESYS Static Analysis est installé. Un  CODESYS le projet est ouvert. Le projet inclut le même bloc de code dans au moins deux objets de programmation. Cliquez sur  Construire → Analyse statique → Détecter les clones . le Résultats de la détection des clones la vue s'ouvre. Cliquez sur ...", 
"body" : "Exigences: CODESYS Static Analysis est installé. Un  CODESYS le projet est ouvert. Le projet inclut le même bloc de code dans au moins deux objets de programmation. Cliquez sur  Construire → Analyse statique → Détecter les clones . le Résultats de la détection des clones la vue s'ouvre. Cliquez sur Résultats . Les clones de code détectés sont affichés sous forme d'arborescence dans une fenêtre. Si, en plus des clones de code identiques, il existe également des clones de code avec des déviations, ces nœuds enfants sont mis en surbrillance en couleur dans l'arborescence. Dans l'arborescence, sélectionnez deux clones de code d'un nœud enfant et cliquez sur le Afficher les clones sélectionnés bouton. Les deux objets de programmation contenant ce code dupliqué sont ouverts sous l'éditeur et affichés dans la partie supérieure de la vue. Les clones de code identiques sont surlignés en jaune clair et les clones de code avec des écarts, tels que les noms de variables ivar3 et ivarx dans cet exemple, sont surlignés en rouge. Pour créer une fonction à partir du clone de code identique de l'objet de programmation POU_1 , double-cliquez d'abord dans l'arborescence sur la ligne contenant le code clone de Objet POU_1 . L'objet de programmation POU_1 s'ouvre dans l'éditeur, et dans la partie implémentation les quatre lignes sont mises en surbrillance qui contiennent le code dupliqué. Lorsque vous cliquez sur le Fonction d'extraction commande dans le menu contextuel du bloc de code en surbrillance, le bloc de code est extrait de POU_1 et une nouvelle méthode est créée à partir de celle-ci. Le bloc de code dans la partie implémentation de POU_1 est remplacé automatiquement par l'appel de la méthode. Dans le deuxième objet de programmation, vous devez supprimer manuellement le code en double et remplacer l'appel de la méthode. Dans une version ultérieure, la fonctionnalité sera étendue afin que le bloc de code dupliqué soit automatiquement extrait des deux objets de programmation et qu'il puisse être remplacé par l'appel de fonction correct. " }, 
{ "title" : "Propagation constante ", 
"url" : "_san_constant_propagation.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagation constante ", 
"snippet" : "Avec le CODESYS Static Analysis version V5.0.0.0, l'analyse du code est basée sur une propagation constante. Les résultats de propagation constante sont utilisés pour divers contrôles. Par exemple, il vérifie si les pointeurs ne sont pas égaux à 0 ou si les indices de tableau sont hors plage valide....", 
"body" : "Avec le CODESYS Static Analysis version V5.0.0.0, l'analyse du code est basée sur une propagation constante. Les résultats de propagation constante sont utilisés pour divers contrôles. Par exemple, il vérifie si les pointeurs ne sont pas égaux à 0 ou si les indices de tableau sont hors plage valide. Vous pouvez prendre en charge efficacement l'analyse statique simplement en sachant comment cette analyse fonctionne et quelles sont ses limites. " }, 
{ "title" : "Propagation constante ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078132035233833484992758", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagation constante \/ Propagation constante ", 
"snippet" : "L'analyse statique tente de déterminer la valeur d'une variable en fonction de son utilisation. Exemple PROGRAM PLC_PRG \/\/Declaration VAR x: INT; bTest: BOOL; END_VAR \/\/Implementation x := 99; IF x < 100 THEN bTest := TRUE; END_IF Dans l'implémentation de la ligne 1, la propagation constante enregis...", 
"body" : "L'analyse statique tente de déterminer la valeur d'une variable en fonction de son utilisation. Exemple PROGRAM PLC_PRG\n\/\/Declaration\nVAR\n x: INT;\n bTest: BOOL;\nEND_VAR \/\/Implementation\nx := 99;\nIF x < 100 THEN\n bTest := TRUE;\nEND_IF Dans l'implémentation de la ligne 1, la propagation constante enregistre la valeur 99 pour la variable x pour utiliser cette valeur pour une analyse plus approfondie. L’analyse reconnaît alors que l’expression suivante IF -Constante de déclaration TRUE est. " }, 
{ "title" : "Propagation constante effectuée localement ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4525765239721633833551650952", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagation constante \/ Propagation constante \/ Propagation constante effectuée localement ", 
"snippet" : "Une valeur est déterminée uniquement localement dans le bloc fonctionnel. La manière dont une entrée est transmise n'a pas d'importance. Les résultats des appels de fonction ne sont pas non plus pertinents. Exemple FUNCTION Func : BOOL \/\/Declaration VAR_INPUT bText : BOOL; END_VAR \/\/Implementation I...", 
"body" : "Une valeur est déterminée uniquement localement dans le bloc fonctionnel. La manière dont une entrée est transmise n'a pas d'importance. Les résultats des appels de fonction ne sont pas non plus pertinents. Exemple FUNCTION Func : BOOL\n\/\/Declaration\nVAR_INPUT\n bText : BOOL;\nEND_VAR \/\/Implementation\nIF bTest THEN\n Func := OtherFunc(TRUE);\nEND_IF Même si le paramètre bTest est réglé sur TRUE à chaque appel, cela n'a aucun effet sur la propagation constante. Même si OtherFunc(TRUE) revient toujours TRUE , cela n'a aucun effet sur la propagation constante. " }, 
{ "title" : "Seules les variables temporaires ont des valeurs initiales. ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4505885763755233833526533567", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagation constante \/ Propagation constante \/ Seules les variables temporaires ont des valeurs initiales. ", 
"snippet" : "Les variables locales statiques dans les programmes et les blocs fonctionnels n'ont pas de valeur initiale supposée. Les variables conservent leurs valeurs du dernier appel et peuvent donc en principe être \"n'importe quoi\". Les variables locales dans les fonctions et les variables temporaires ont un...", 
"body" : "Les variables locales statiques dans les programmes et les blocs fonctionnels n'ont pas de valeur initiale supposée. Les variables conservent leurs valeurs du dernier appel et peuvent donc en principe être \"n'importe quoi\". Les variables locales dans les fonctions et les variables temporaires ont une valeur initiale à chaque appel. La propagation constante est calculée avec cette valeur initiale. Exemple PROGRAM PLC_PRG\n\/\/Declaration\nVAR\n x: INT := 6;\n bTest: BOOL;\nEND_VAR\nVAR_TEMP\n y : INT := 8;\nEND_VAR bText := x < y; La variable y est exécuté à chaque fois PLC_PRG ont la valeur 8. La variable x  mais pas nécessairement. Par conséquent, la propagation constante n’est utilisée que pour y prendre une valeur, mais pas pour x . Il est recommandé de déclarer des variables qui sont toujours écrites en premier puis lues comme variables temporaires. " }, 
{ "title" : "La propagation constante détermine des plages de valeurs pour les types de données numériques. ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078129465633833541363136", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagation constante \/ Propagation constante \/ La propagation constante détermine des plages de valeurs pour les types de données numériques. ", 
"snippet" : "Pour réduire la complexité, une plage de valeurs avec des limites supérieure et inférieure est déterminée pour chaque variable. Exemple PROGRAM PLC_PRG VAR x: INT := 6; bTest: BOOL; y : INT; END_VAR \/\/Implementation IF bTest THEN x := 1; ELSSE x := 100; END_IF IF x = 77 THEN y := 13; END_IF Ici la p...", 
"body" : "Pour réduire la complexité, une plage de valeurs avec des limites supérieure et inférieure est déterminée pour chaque variable. Exemple PROGRAM PLC_PRG\nVAR\n x: INT := 6;\n bTest: BOOL;\n y : INT; \nEND_VAR\n \/\/Implementation\nIF bTest THEN\n x := 1;\nELSSE\n x := 100;\nEND_IF\nIF x = 77 THEN\n y := 13;\nEND_IF Ici la plage de valeurs [1..100] est déterminé pour la variable x . En conséquence, à la ligne 7, la comparaison x = 77 n'est pas reconnu comme une expression constante car 77 est dans la plage de valeurs. " }, 
{ "title" : "Les expressions complexes récurrentes ne sont pas reconnues comme la même variable. ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4581954142281633833566535545", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagation constante \/ Propagation constante \/ Les expressions complexes récurrentes ne sont pas reconnues comme la même variable. ", 
"snippet" : "Les expressions complexes ne peuvent pas avoir de valeur attribuée. Si de telles expressions apparaissent plusieurs fois, il est alors utile d’introduire une variable auxiliaire. Exemple PROGRAM PLC_PRG VAR x: DINT; py : POINTER TO INT; y : INT; testArray : ARRAY [0..4] OF DINT; END_VAR \/\/Implementa...", 
"body" : "Les expressions complexes ne peuvent pas avoir de valeur attribuée. Si de telles expressions apparaissent plusieurs fois, il est alors utile d’introduire une variable auxiliaire. Exemple PROGRAM PLC_PRG\nVAR\n x: DINT;\n py : POINTER TO INT;\n y : INT; \n testArray : ARRAY [0..4] OF DINT; \nEND_VAR\n \/\/Implementation\nIF py^ >= 0 AND py^<= 4 THEN\n x := testArray[py^];\nEND_IF\ny := py^;\nIF y <= 0 AND y <=4 THEN\n x := testArray[y];\nEND_IF A la ligne 2, une erreur est émise pour un éventuel accès via pointeur à une valeur, bien que la zone pointée par le pointeur soit vérifiée. Si la valeur est d'abord copiée dans une variable locale et que sa plage est vérifiée, alors la propagation constante peut déterminer la plage de valeurs pour cette variable et permettre l'accès au tableau sur la ligne 7. " }, 
{ "title" : "Ramification ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078204272033833577361725", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagation constante \/ Propagation constante \/ Ramification ", 
"snippet" : "Pour le branchement, les branches individuelles sont calculées séparément. Les plages de valeurs des différentes plages sont ensuite combinées pour former une nouvelle plage de valeurs. Exemple \/\/Implementation IF func(TRUE) THEN x := 1; ELSE x := 10; END_IF IF func(FALSE) THEN y := x; ELSE Y := 2*x...", 
"body" : "Pour le branchement, les branches individuelles sont calculées séparément. Les plages de valeurs des différentes plages sont ensuite combinées pour former une nouvelle plage de valeurs. Exemple \/\/Implementation\nIF func(TRUE) THEN\n x := 1;\nELSE \n x := 10;\nEND_IF\n\nIF func(FALSE) THEN\n y := x;\nELSE\n Y := 2*x;\nEND_IF Sur la ligne 6, x a la portée [1..10] . Après la ligne 11, y a la plage de valeurs [1..20] ; cela résulte de l'union des deux plages de valeurs [1..10] et [2..20] . " }, 
{ "title" : "Conditions ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4505886343398433833583258632", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagation constante \/ Propagation constante \/ Conditions ", 
"snippet" : "Exemple Les conditions peuvent restreindre la plage de valeurs d'une variable dans un bloc de code. Plusieurs conditions peuvent être combinées. Des conditions mutuellement exclusives peuvent également donner lieu à une plage de valeurs vide. IF y > 0 AND y < 10 THEN x := y; ELSE x:= 0; END_IF IF x ...", 
"body" : "Exemple Les conditions peuvent restreindre la plage de valeurs d'une variable dans un bloc de code. Plusieurs conditions peuvent être combinées. Des conditions mutuellement exclusives peuvent également donner lieu à une plage de valeurs vide. IF y > 0 AND y < 10 THEN\n x := y;\nELSE\n x:= 0;\nEND_IF\nIF x < 0 THEN\n i := 99;\nEND_IF y a la plage de valeurs [1..9] à la ligne 2. Cela donne la plage de valeurs [0..9] pour x à la ligne 6. Combiné avec la condition x < 0 , cela donne un ensemble vide de valeurs possibles pour x à la ligne 8. Le code n'est pas accessible. L'analyse statique indiquera que la condition x < 0 revient toujours FALSE à ce point. " }, 
{ "title" : "Boucle ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4649940201660833833593476437", 
"breadcrumbs" : "CODESYS Static Analysis \/ Propagation constante \/ Propagation constante \/ Boucle ", 
"snippet" : "Une propagation constante bouclera le code jusqu'à ce que les valeurs des variables dans la boucle ne changent plus. On suppose qu’une boucle peut être exécutée un nombre illimité de fois. Les valeurs déterminées jusqu'à présent sont combinées avec les valeurs précédentes. Les variables modifiées da...", 
"body" : "Une propagation constante bouclera le code jusqu'à ce que les valeurs des variables dans la boucle ne changent plus. On suppose qu’une boucle peut être exécutée un nombre illimité de fois. Les valeurs déterminées jusqu'à présent sont combinées avec les valeurs précédentes. Les variables modifiées dans la boucle ont une plage croissante. Ici, la propagation constante ne prend pas toutes les valeurs possibles pour les plages, mais utilise uniquement les limites qui apparaissent dans le code ainsi que les valeurs 0, 1, 2, 3 et 10 car celles-ci sont souvent pertinentes. Exemple La façon la plus simple de décrire la procédure est de prendre un exemple : PROGRAM PLC_PRG\nVAR\n x: DINT;\n i : DINT;\n y : DINT;\nEND_VAR \/\/Implementation\nx := 0;\ny := 0;\nFOR i := 0 TO 5 DO\n x := x + 1;\n y := i;\nEND_FOR La propagation constante connaît les éléments suivants à propos de la boucle : i , x , et y valent 0 au début de la première exécution de la boucle. La condition i <= 5 s'applique au code dans la boucle. La condition i > 5 s'applique au code après la boucle. Pour les valeurs des variables dans la boucle, la propagation constante détermine les valeurs suivantes : i x y [0..5] [0..MAXDINT] [0..5] Dans le détail, les étapes intermédiaires suivantes sont parcourues : Passer i x y 1 0 [0..1] 0 i a été initialisé à 0 ; y obtient toujours les mêmes valeurs que i. 2 [0..1] [0..2] [0..1] 6 [0..5] [0..6] [0..5] Tout d'abord, la gamme [0..6] est en fait calculé pour i . Or, on sait que i < 5 est une condition. Par conséquent, la valeur du code dans la boucle est limitée à cette valeur. 7 [0..5] [0..7] [0..5] 10 [0..5] [0..10] [0..5] x s'accroît de plus en plus. Depuis 10 , cependant, la valeur est « arrondie » à MAXINT . 11 [0..5] [0..MAXDINT] [0..5] MAXDINT + 1 résulte en MAXDINT Dès le 11 A partir du 11ème passage, les valeurs dans la boucle ne changeront pas. La propagation est terminée. En outre, i = 6 s'applique au code suivant cette boucle. La gamme [0..6] est déterminé dans la boucle et ceci est combiné avec la condition i > 5 , ce qui donne exactement la valeur 6. " }, 
{ "title" : "Référence : Interface Utilisateur ", 
"url" : "_san_f_reference_user_interface.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Commandes ", 
"url" : "_san_struct_reference_commands.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Commandes ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Commande : Extraire la fonction ", 
"url" : "_san_cmd_extract_function.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Commandes \/ Commande : Extraire la fonction ", 
"snippet" : "fonction d'extraction Une fonction : La commande ouvre le Extraire la configuration de la fonction dialogue. La commande extrait le code sélectionné de l'éditeur ST et crée une nouvelle méthode ou fonction contenant ce code. Le code affecté dans l'éditeur ST est remplacé par un appel correct. Lorsqu...", 
"body" : "fonction d'extraction Une fonction : La commande ouvre le Extraire la configuration de la fonction dialogue. La commande extrait le code sélectionné de l'éditeur ST et crée une nouvelle méthode ou fonction contenant ce code. Le code affecté dans l'éditeur ST est remplacé par un appel correct. Lorsque le code est extrait d'un bloc fonctionnel ou de l'enfant d'un bloc fonctionnel, une nouvelle méthode est créée à partir du code. Lorsque le code est extrait d'un programme ou d'une fonction, une nouvelle fonction est créée à partir du code. A noter également dans ce contexte : Détection des clones de codeAppeler : Menu contextuel: Refactoring Exigences : Lorsque le code sélectionné est composé d'une ou plusieurs instructions : Le code sélectionné ne contient aucune erreur de compilation. Le code sélectionné se trouve dans la partie implémentation d'une ST POU. Le code sélectionné ne contient aucun saut sortant Voici des exemples de sauts sortants : Utilisant RETURN pour quitter la fonction englobante Utilisant CONTINUE ou EXIT pour sortir d'une boucle contenant le code Vous pouvez annuler les modifications que le Fonction d'extraction commande effectuée dans votre projet en positionnant le curseur dans l'arborescence des appareils et en cliquant sur Édition → Annuler . Extraire la configuration de la fonction Dialogue Nom Nom de la fonction ou de la méthode récemment créée Le nom par défaut peut être modifié. Valeur de retour Détermine la valeur de retour d'une fonction s'il y a plusieurs paramètres de sortie et\/ou d'entrée\/sortie Paramètres Affichage des POU disponibles Configuration si les paramètres sont utilisés comme variables d'entrée, de sortie ou d'entrée\/sortie : Variables d'entrée : Variables de sortie : Variables d'entrée\/sortie Les changements apportés pour Nom , Valeur de retour , ou Paramètre sont défaits. Fenêtre de code supérieure Code récemment créé de l'emplacement de l'appel Fenêtre de code inférieure Code récemment créé de la fonction ou de la méthode d'accord Les modifications de code affichées sont acceptées dans les POU ST et la boîte de dialogue se ferme. Annuler Les modifications de code affichées sont rejetées et la boîte de dialogue se ferme. " }, 
{ "title" : "Commande : Inverse l'instruction IF ", 
"url" : "_san_cmd_invert_if_statement.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Commandes \/ Commande : Inverse l'instruction IF ", 
"snippet" : "Inverse l'instruction IF Fonction : Cette commande inverse le IF déclaration sans changer la sémantique de la IF déclaration. La condition est niée. Les déclarations dans le THEN et ELSE les branches sont échangées. Tous les commentaires sont conservés. Appel : Menu contextuel sous Refactorisation c...", 
"body" : "Inverse l'instruction IF Fonction : Cette commande inverse le IF déclaration sans changer la sémantique de la IF déclaration. La condition est niée. Les déclarations dans le THEN et ELSE les branches sont échangées. Tous les commentaires sont conservés. Appel : Menu contextuel sous Refactorisation commande Condition préalable : le curseur est positionné n'importe où dans un IF déclaration. Règles de négation Expression Expression niée Description < >= La comparaison sur « inférieur à » devient « supérieur à » et vice versa. <= > La comparaison sur « inférieur ou égal à » devient « supérieur à » et vice versa. = <> La comparaison sur « égal » devient « n'est pas égal » et vice versa. <expression1> AND <expression2> ( NOT <expression1> ) OR ( NOT <expression2> ) Négation selon De Morgan pour AND opérateur <expression1> OR <expression2> (NOT <expression1> ) AND (NOT <expression2> ) Négation selon De Morgan pour OR opérateur <expression> NOT <expression> Négation standard NOT <expression> <expression> Pas de double NOT expression a (*commentaire*) = b a (*commentaire*) <> b Les commentaires sont conservés. Ceci s'applique particulièrement aux opérandes échangés Exemple PROGRAM Inversion1\nVAR\n xA, xB, xC : BOOL;\n iVar : INT;\nEND_VAR iVar := 0;\nIF NOT(xA AND xB AND xC) THEN\n\tiVar:= 1; (* IF 1 *)\nELSE\n\tiVar := iVar + 1; (* ELSE counter*)\nEND_IFiVar := 0;\n Coder après avoir appelé la commande en logique inversée avec la même sémantique : iVar := 0;\nIF (xA AND xB AND xC) THEN\n iVar := iVar + 1; (* ELSE counter*)\nELSE\n iVar:= 1; (* IF 1 *)\nEND_IF " }, 
{ "title" : "Commande : Afficher les valeurs de propagation constante pour l'éditeur actuel ", 
"url" : "_san_cmd_show_values_of_constant_propagation_for_current_editor.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Commandes \/ Commande : Afficher les valeurs de propagation constante pour l'éditeur actuel ", 
"snippet" : "Afficher les valeurs de propagation constante pour l'éditeur actuel Symbole: Fonction : La commande démarre l'analyse statique du code et calcule une valeur mesurée pour la propagation constante du code dans l'éditeur courant. La boîte de dialogue qui s'ouvre visualise le résultat. Le code analysé e...", 
"body" : "Afficher les valeurs de propagation constante pour l'éditeur actuel Symbole: Fonction : La commande démarre l'analyse statique du code et calcule une valeur mesurée pour la propagation constante du code dans l'éditeur courant. La boîte de dialogue qui s'ouvre visualise le résultat. Le code analysé est répertorié et les valeurs mesurées déterminées sont affichées. Appel : Construire → Analyse statique menu Exigence : Un objet de programmation dans le langage d'implémentation ST est ouvert sous l'éditeur. Pour plus d'informations, voir : Propagation constante" }, 
{ "title" : "Boîte de dialogue : Résultats d'une propagation constante ", 
"url" : "_san_cmd_show_values_of_constant_propagation_for_current_editor.html#UUID-948900c6-97a3-c88d-ff29-bca9a5de0d7b_section-idm4549177267643233866303721891", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Commandes \/ Commande : Afficher les valeurs de propagation constante pour l'éditeur actuel \/ Boîte de dialogue : Résultats d'une propagation constante ", 
"snippet" : "Exemple...", 
"body" : "Exemple " }, 
{ "title" : "Commande : Exécuter une analyse statique ", 
"url" : "_san_cmd_run_static_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Commandes \/ Commande : Exécuter une analyse statique ", 
"snippet" : "effectuer une analyse statique Symbole: Une fonction : La commande démarre l'analyse statique pour l'application active et affiche les métriques de toutes les POU dans un tableau. Appeler : Construire → Analyse statique menu Lors de l'analyse du code, CODESYS Static Analysis génère du code comme le ...", 
"body" : "effectuer une analyse statique Symbole: Une fonction : La commande démarre l'analyse statique pour l'application active et affiche les métriques de toutes les POU dans un tableau. Appeler : Construire → Analyse statique menu Lors de l'analyse du code, CODESYS Static Analysis génère du code comme le Construire → Générer du code commander. Les résultats de l'analyse sont affichés sous forme d'erreurs et avertissements dans la vue des messages ( Construire Catégorie). Les numéros renvoient aux des règles tels qu'ils sont définis dans les paramètres du projet. La syntaxe des messages affichés est SA<numéro de règle> :<texte de règle> . " }, 
{ "title" : "Commande : Paramètres ", 
"url" : "_san_cmd_settings.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Commandes \/ Commande : Paramètres ", 
"snippet" : "paramètres Une fonction : La commande ouvre le Paramètres d'analyse statique dialogue. Appeler : Construire → Analyse statique menu Exigence : Le paquet CODESYS Static Analysis est installé. Un projet est ouvert....", 
"body" : "paramètres Une fonction : La commande ouvre le Paramètres d'analyse statique dialogue. Appeler : Construire → Analyse statique menu Exigence : Le paquet CODESYS Static Analysis est installé. Un projet est ouvert. " }, 
{ "title" : "Commande : Afficher les métriques standard ", 
"url" : "_san_cmd_view_standard_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Commandes \/ Commande : Afficher les métriques standard ", 
"snippet" : "Afficher les métriques par défaut Symbole: Fonction : La commande démarre l'analyse du code statique pour l'application active. Les métriques par défaut pour tous les blocs de programmation sont ensuite calculées et affichées dans un tableau sur le Métriques standards languette. Appel : Construire →...", 
"body" : "Afficher les métriques par défaut Symbole: Fonction : La commande démarre l'analyse du code statique pour l'application active. Les métriques par défaut pour tous les blocs de programmation sont ensuite calculées et affichées dans un tableau sur le Métriques standards languette. Appel : Construire → Analyse statique menu Pour plus d'informations, voir : Affichage des métriquesMétrique" }, 
{ "title" : "Onglet : Métriques standard ", 
"url" : "_san_cmd_view_standard_metrics.html#UUID-c2310f81-c613-bf67-ba1e-4f10694a38a1_section-idm4622240725232033866114829692", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Commandes \/ Commande : Afficher les métriques standard \/ Onglet : Métriques standard ", 
"snippet" : "Exemple Dans le Paramètres d'analyse statique : Métriques , vous pouvez modifier la configuration des métriques. Vous pouvez désactiver le calcul d'une métrique. Et vous pouvez définir des valeurs limites pour des métriques spécifiques. Si une valeur se situe en dehors des limites supérieure et infé...", 
"body" : "Exemple Dans le Paramètres d'analyse statique : Métriques , vous pouvez modifier la configuration des métriques. Vous pouvez désactiver le calcul d'une métrique. Et vous pouvez définir des valeurs limites pour des métriques spécifiques. Si une valeur se situe en dehors des limites supérieure et inférieure configurées, le champ du tableau est surligné en rouge. Les commandes suivantes sont fournies dans le menu contextuel du tableau : Calculer Met à jour les valeurs Copier le tableau Copie le tableau dans le presse-papiers Le séparateur est une tabulation. Imprimer le tableau Ouvre la boîte de dialogue par défaut pour configurer le travail d'impression Exporter le tableau Exporte le tableau vers un fichier CSV Le séparateur est un point-virgule. Diagramme de Kiviat Condition : Au moins trois métriques sont activées et ont des limites supérieures et inférieures définies. Représente les métriques du bloc fonctionnel sélectionné sous forme de graphique radar. Cela visualise la qualité du code POU par rapport à une norme donnée. Chaque métrique est représentée dans un cercle sous la forme d'un axe qui, partant du centre (valeur 0), s'étend vers l'extérieur à travers trois zones annulaires du cercle. La zone de l'anneau intérieur représente la plage de valeurs en dessous de la limite inférieure définie pour la métrique, celle extérieure au-dessus de la limite supérieure. Les axes des métriques affectées sont uniformément répartis sur le cercle. Les valeurs actuelles des métriques individuelles sur leurs axes sont reliées par des lignes et, idéalement, la ligne globale se situe dans la zone du cercle central. Configurer Ouvre le tableau pour sélectionner les métriques souhaitées Cela correspond au tableau dans les paramètres du projet. Ouvrir le POE Ouvre l'éditeur avec le POU Exemple Exemple de graphique de Kiviat pour 5 métriques Le nom de la métrique est en bout d'axe, le nom du module est en haut à droite. " }, 
{ "title" : "Commande : Calculer et exporter les métriques standard ", 
"url" : "_san_calculate_and_export_standard_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Commandes \/ Commande : Calculer et exporter les métriques standard ", 
"snippet" : "Calculer et exporter des métriques standard Fonction : Calcule et exporte directement les métriques standards sans afficher le tableau des métriques dans l'éditeur. Spécifiez un nom approprié pour le fichier d'exportation CSV dans la boîte de dialogue de fichier standard. Appel : Cette commande n’es...", 
"body" : "Calculer et exporter des métriques standard Fonction : Calcule et exporte directement les métriques standards sans afficher le tableau des métriques dans l'éditeur. Spécifiez un nom approprié pour le fichier d'exportation CSV dans la boîte de dialogue de fichier standard. Appel : Cette commande n’est disponible dans aucun menu par défaut. Alternativement, vous pouvez également utiliser le Afficher les métriques standards commande pour afficher les métriques dans l’éditeur. Entre autres choses, l'éditeur fournit le Exporter le tableau commande contextuelle. Personnalisation du menu Fournir la commande Cliquez sur Outils → Personnaliser . Le Menu l'onglet s'ouvre. Vous devez d’abord définir une position dans le menu pour la commande. Dans ce cas, il est judicieux de sélectionner un élément sous le Construire → Analyse statique menu. Sélectionnez la position souhaitée et cliquez sur le Ajouter une commande bouton. Toutes les commandes sont répertoriées dans le Ajouter une commande dialogue. Sélectionnez le Analyse statique catégorie sur le côté gauche, puis la commande souhaitée sur le côté droit. Cliquez sur D'ACCORD pour fermer la boîte de dialogue. Puis clique D'ACCORD encore une fois pour fermer le Personnaliser dialogue. Le Calculer et exporter des métriques standard la commande est désormais disponible dans le Construire → Analyse statique menu. " }, 
{ "title" : "Commande : Détecter les clones ", 
"url" : "_san_cmd_find_clones.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Commandes \/ Commande : Détecter les clones ", 
"snippet" : "rechercher des clones Une fonction : La commande scanne le code programme de la CODESYS projet pour le code copié, et ouvre le Résultats de la détection des clones view pour afficher les blocs de code clonés détectés. Dans le processus, seuls les blocs de code supérieurs à une taille spécifique sont...", 
"body" : "rechercher des clones Une fonction : La commande scanne le code programme de la CODESYS projet pour le code copié, et ouvre le Résultats de la détection des clones view pour afficher les blocs de code clonés détectés. Dans le processus, seuls les blocs de code supérieurs à une taille spécifique sont considérés comme des clones. De très petits morceaux de code ne sont pas affichés en tant que clones. A noter également à cet égard fonction d'extraction et les consignes Détection des clones de code. Appeler : Construire → Analyse statique menu Analyse statique menu contextuel Exigence : Le CODESYS Static Analysis projet est ouvert. Deux positions de code sont considérées comme des clones si elles ont les propriétés suivantes : Même composition structurelle Les variables ont le même type de données. Les noms de variables peuvent être différents (exception : accès aux composants). Cependant, un identifiant qui est contenu plusieurs fois dans le code doit être au même endroit dans les deux positions de code. Les littéraux ont le même type de données. Les littéraux peuvent être différents. Un littéral qui apparaît plusieurs fois dans le code doit apparaître au même endroit dans les deux positions de code. Résultats de la détection des clones Voir Résumé Onglet pour afficher les résultats de la recherche Nombre de séquences de code clonées trouvées Nombre de relevés comparés Nombre d'instructions dans le code cloné Rapport de clonage : Spécifié en pourcentage : Nombre d'instructions dans le code cloné \/ Nombre de relevés comparés Résultats L'onglet affiche les clones de code dans une arborescence et fournit des commandes et des options de filtrage. La première occurrence d'un doublon dans l'ensemble de doublons est considérée comme le nœud racine. La couleur de fond des nœuds enfants indique si le code est différent ou complètement identique. Les mêmes couleurs signifient le \"même code\". Le contenu de l'arborescence est trié par ordre décroissant du nombre d'instructions du code dupliqué. Commandes et filtres sur le Résultats languette Sous-nœuds\/clone Nombre de sous-nœuds (instructions) dans le bloc de code Si le nombre de sous-nœuds est inférieur à 20, le clone de code n'est pas pris en compte. Filtrer sur l'objet Champ de saisie pour un Objet , par lequel la liste des clones est filtrée Afficher les clones sélectionnés Condition : deux nœuds enfants du même nœud parent sont sélectionnés. Les deux objets de programmation sont affichés dans la partie supérieure de la vue à des fins de comparaison. Dans le processus, les doublons de code sont mis en surbrillance et les différences (par exemple, différents noms de variable) sont mises en surbrillance dans une couleur différente. Liste des clones de code Colonnes La description Sous-nœuds\/clone Objet Position Un double-clic sur un nœud enfant ouvre l'objet de programmation correspondant et le bloc de code dupliqué y est sélectionné. " }, 
{ "title" : "Commande : Afficher la complexité cognitive pour l'éditeur actuel ", 
"url" : "_san_cmd_show_cognitive_complexity_for_current_editor.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Commandes \/ Commande : Afficher la complexité cognitive pour l'éditeur actuel ", 
"snippet" : "Afficher la complexité cognitive pour l'éditeur actuel Symbole : Fonction : La commande démarre l'analyse statique du code et calcule une valeur mesurée pour la complexité cognitive du code dans l'éditeur actuel. La boîte de dialogue qui s'ouvre visualise le résultat et précise la somme des valeurs ...", 
"body" : "Afficher la complexité cognitive pour l'éditeur actuel Symbole : Fonction : La commande démarre l'analyse statique du code et calcule une valeur mesurée pour la complexité cognitive du code dans l'éditeur actuel. La boîte de dialogue qui s'ouvre visualise le résultat et précise la somme des valeurs mesurées dans le titre. Le code analysé est répertorié et affiché avec les complexités détectées. Appel : Construire → Analyse statique menu Exigence : Un objet de programmation dans le langage d'implémentation ST est ouvert sous l'éditeur. " }, 
{ "title" : "Boîte de dialogue : Complexité cognitive de <Nom du POU> : <valeur mesurée calculée> ", 
"url" : "_san_cmd_show_cognitive_complexity_for_current_editor.html#UUID-315a7cbe-83be-ba91-4d86-234b9f3e6fc3_section-idm4549177267643233866303721891", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Commandes \/ Commande : Afficher la complexité cognitive pour l'éditeur actuel \/ Boîte de dialogue : Complexité cognitive de <Nom du POU> : <valeur mesurée calculée> ", 
"snippet" : "Exemple...", 
"body" : "Exemple " }, 
{ "title" : "Commande : Exécuter une analyse statique et exporter vers un fichier SARIF ", 
"url" : "_san_cmd_run_and_export_to_sarif_file.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Commandes \/ Commande : Exécuter une analyse statique et exporter vers un fichier SARIF ", 
"snippet" : "Exécuter une analyse statique et exporter vers un fichier SARIF Symbole : Fonction : Cette commande lance l'analyse du code statique et enregistre le résultat dans un fichier SARIF. Appel : Construire → Analyse statique menu Un dossier SARIF (» Format d'échange des résultats d'analyse statique «) es...", 
"body" : "Exécuter une analyse statique et exporter vers un fichier SARIF Symbole : Fonction : Cette commande lance l'analyse du code statique et enregistre le résultat dans un fichier SARIF. Appel : Construire → Analyse statique menu Un dossier SARIF (» Format d'échange des résultats d'analyse statique «) est un fichier JSON lisible par machine avec l'extension de fichier » *.sarif.json \"qui est créé par Static Analysis pour stocker les résultats dans un format standardisé. SARIF est une norme OASIS. Cela signifie que différents outils et plateformes peuvent l'utiliser pour échanger et traiter les résultats des analyses. " }, 
{ "title" : "Commandes en ligne de commande ", 
"url" : "_san_cmd_run_and_export_to_sarif_file.html#UUID-b1a6530c-4103-8c37-7a9e-f6ad763d2402_section-idm235003337576496", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Commandes \/ Commande : Exécuter une analyse statique et exporter vers un fichier SARIF \/ Commandes en ligne de commande ", 
"snippet" : "La commande peut également être exécutée automatiquement via CODESYS Scripting . La commande batch [\"staticanalysis\", \"runandexportosarif\"] accepte les arguments ci-dessous. Argument : --sariffile --sariffile=<path to output>; Spécifiez le chemin dans lequel le fichier SARIF obtenu doit être écrit. ...", 
"body" : "La commande peut également être exécutée automatiquement via CODESYS Scripting . La commande batch [\"staticanalysis\", \"runandexportosarif\"] accepte les arguments ci-dessous. Argument : --sariffile --sariffile=<path to output>; Spécifiez le chemin dans lequel le fichier SARIF obtenu doit être écrit. Si vous ne spécifiez aucun chemin, le fichier est enregistré dans le dossier du projet en cours. Argument : --rulesfile --rulesfile=<patch to CSA file>; Spécifiez le chemin d'accès au fichier CSA qui doit être utilisé pour l'analyse statique. Si vous ne spécifiez aucun chemin, la configuration actuelle est utilisée. Exemple d'appel dans un script Python system.commands[\"staticanalysis\", \"runandexportosarif\"].execute(\"--sariffile=result.sarif\", \"--rulesfile=rules.csa\") " }, 
{ "title" : "Commande : Formater ", 
"url" : "_san_cmd_format.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Commandes \/ Commande : Formater ", 
"snippet" : "Format Mode débogage Cette fonctionnalité est disponible uniquement lorsque votre CODESYS l'instance est démarrée en mode débogage. Pour ce faire, démarrez votre instance avec l'appel de ligne de commande suivant : codesys.exe --debug Fonction : La commande formate un objet ST selon les règles confi...", 
"body" : "Format Mode débogage Cette fonctionnalité est disponible uniquement lorsque votre CODESYS l'instance est démarrée en mode débogage. Pour ce faire, démarrez votre instance avec l'appel de ligne de commande suivant : codesys.exe --debug Fonction : La commande formate un objet ST selon les règles configurées dans le CODESYS options afin d’améliorer la lisibilité du code. Appel : Menu contextuel sous le Refactorisation menu Condition préalable : Un éditeur ST est ouvert et le curseur se trouve dans une déclaration ou une implémentation. Pour plus d'informations, voir : Formateur automatique" }, 
{ "title" : "Dialogues ", 
"url" : "_san_struct_reference_dialogs.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Dialogues ", 
"snippet" : "Les boîtes de dialogue de configuration de l'analyse de code statique se trouvent dans Construire → Analyse statique → Paramètres . Comme condition préalable, un CODESYS -Projet être ouvert....", 
"body" : "Les boîtes de dialogue de configuration de l'analyse de code statique se trouvent dans Construire → Analyse statique → Paramètres . Comme condition préalable, un CODESYS -Projet être ouvert. " }, 
{ "title" : "Boîte de dialogue : Paramètres d'analyse statique : Paramètres ", 
"url" : "_san_dlg_settings_static_analysis_settings.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Dialogues \/ Boîte de dialogue : Paramètres d'analyse statique : Paramètres ", 
"snippet" : "Paramètres Une fonction : Dans la boîte de dialogue, vous sélectionnez analyse statique , et enregistrez ou chargez les paramètres du projet pour l'analyse statique en tant que fichier CSA. Projet → Paramètres du projet menu, Analyse statique Catégorie, Ouvrir la boîte de dialogue de configuration l...", 
"body" : "Paramètres Une fonction : Dans la boîte de dialogue, vous sélectionnez analyse statique , et enregistrez ou chargez les paramètres du projet pour l'analyse statique en tant que fichier CSA. Projet → Paramètres du projet menu, Analyse statique Catégorie, Ouvrir la boîte de dialogue de configuration lien Construire → Analyse statique → Paramètres menu Exigence : le CODESYS Static Analysis le paquet est installé. Un projet est ouvert. Effectuer une analyse statique automatiquement : CODESYS Static Analysis effectue automatiquement la vérification du code à chaque génération de code (par exemple, lorsque le Construire → Générer du code commande est exécutée ou avant un téléchargement. : La vérification du code n'est pas effectuée automatiquement, mais elle peut être effectuée explicitement au moyen de la Construire → Analyse statique → Exécuter une analyse statique commander. Charger Ouvre le Charger la configuration de l'analyse statique boîte de dialogue de sélection des paramètres du projet pour l'analyse statique en tant que fichier CSA dans le système de fichiers. Lorsque vous cliquez sur le Ouvert , le fichier CSA sélectionné est chargé. Sauvegarder Ouvre le Enregistrer la configuration de l'analyse statique boîte de dialogue pour enregistrer tous les paramètres du projet dans le Analyse statique catégorie en tant que fichier CSA dans le système de fichiers. " }, 
{ "title" : "Boîte de dialogue : Paramètres d'analyse statique : Règles ", 
"url" : "_san_dlg_settings_sa_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Dialogues \/ Boîte de dialogue : Paramètres d'analyse statique : Règles ", 
"snippet" : "Règles Fonction : Dans la boîte de dialogue, vous sélectionnez le règles qui sont vérifiés lors de l’analyse statique du code source d’un projet. Pour plus d'informations, voir : Configuration et exécution d'une analyse statiqueAppel : Projet → Paramètres du projet menu, Analyse statique catégorie, ...", 
"body" : "Règles Fonction : Dans la boîte de dialogue, vous sélectionnez le règles qui sont vérifiés lors de l’analyse statique du code source d’un projet. Pour plus d'informations, voir : Configuration et exécution d'une analyse statiqueAppel : Projet → Paramètres du projet menu, Analyse statique catégorie, Ouvrir la boîte de dialogue de configuration lien Construire → Analyse statique → Paramètres menu Exigence : Le CODESYS Static Analysis le paquet est installé. Un projet est ouvert. Cet onglet affiche une arborescence de toutes les règles qui peuvent être vérifiées lors de l'analyse statique. Par défaut, toutes les règles sont activées, à l'exception de SA0016, SA0024, SA0073, SA0101, SA0105, SA0106, SA0133, SA0134, SA0150, SA0162 et toutes les « règles CEI strictes ». Chaque règle possède un numéro unique. Lorsque la règle est vérifiée et qu'une violation est détectée, le numéro de règle et une description de l'erreur sont affichés dans la vue des messages dans le Construire catégorie au format suivant : SA<numéro de règle> , où « SA » signifie « Analyse statique » (exemple : « SA003 » pour la règle 3). La liste des règles disponibles peut être étendue par des plug-ins spécifiques. Filtre Champ de saisie des chaînes à rechercher Les règles sont regroupées par catégorie. Structuré par importance : Trier par Importance élevée , Moyenne , et Faible importance Défaut : Structuration par défaut des règles dans CODESYS Static Analysis : Les règles sont affichées sous forme de liste plate. En cliquant sur l'en-tête de colonne correspondant, la liste peut être triée par numéro de règle, activation\/désactivation, configuration spécifique à la règle ou importance. Certaines règles activées dans la boîte de dialogue peuvent être désactivées temporairement dans l'application en appliquant un pragma . Lorsque vous cochez la case, le paramètre bascule entre , , et . Lorsque vous activez ou désactivez un nœud parent, toutes les règles enfants sont également activées ou désactivées, respectivement. Colonnes Règles Liste des règles avec numéro de règle Vérification des règles ⁣ : La règle n'est pas vérifiée. ⁣ : Si le résultat du contrôle est positif, alors une erreur ( ) pour l'analyse statique est affiché dans la vue des messages. ⁣ : Si le résultat du contrôle est positif, alors un avertissement ( ) pour l'analyse statique est affiché dans la vue des messages. Précompiler  : Les règles qui peuvent être vérifiées lors de la précompilation sont identifiées par une coche ( ) dans cette colonne. Cela signifie que les règles sont déjà vérifiées lors de la saisie du code. Une correction immédiate (Quickfix) est possible pour ces règles. Vous pouvez exécuter une gestion automatique et immédiate des erreurs directement aux positions de code concernées. : Les règles qui ne sont pas marquées ne sont vérifiées qu'après une compilation réussie. Configuration spécifique à une règle Pour certaines règles, vous pouvez double-cliquer sur le champ pour ouvrir une boîte de dialogue spécifique à la règle afin de configurer la règle. Importance : Importance de la règle : 3 étoiles rouges : Élevé 2 étoiles orange : Moyen 1 étoile grise : Faible " }, 
{ "title" : "Boîte de dialogue : Paramètres d'analyse statique : Conventions de dénomination ", 
"url" : "_san_dlg_settings_sa_naming_conventions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Dialogues \/ Boîte de dialogue : Paramètres d'analyse statique : Conventions de dénomination ", 
"snippet" : "Conventions de dénomination Une fonction : Dans la boîte de dialogue, vous définir les préfixes pour les types de données et les portées des variables, ainsi que les préfixes pour les POU et les types de données définis par l'utilisateur (DUT). Contrôles d'analyse statique conformité avec les conven...", 
"body" : "Conventions de dénomination Une fonction : Dans la boîte de dialogue, vous définir les préfixes pour les types de données et les portées des variables, ainsi que les préfixes pour les POU et les types de données définis par l'utilisateur (DUT). Contrôles d'analyse statique conformité avec les conventions de nommage. Lorsqu'une convention n'est pas respectée, l'analyse statique signale un message d'erreur dans le messages voir. Pour plus d'informations, consultez : Configuration et exécution d'une analyse statiqueAppeler : Projet → Paramètres du projet menu, Analyse statique Catégorie, Ouvrir la boîte de dialogue de configuration lien Construire → Analyse statique → Paramètres menu Exigence : le CODESYS Static Analysis le paquet est installé. Un projet est ouvert. Les messages d'erreur s'affichent au format suivant : NC <prefix of convention number> : <message text> . NC signifie \"convention de dénomination\". Par exemple, le message d'erreur NC0102 : Nom invalide… signifie une violation de la convention de dénomination 102 pour les POU de type PROGRAM . Vous pouvez utiliser le 'naming' pragma pour désactiver les conventions de nommage pour les individus identifiants . Les identifiants peuvent commencer par n'importe quoi, pas nécessairement par le préfixe. Filtre Champ de saisie des chaînes à rechercher Tableau avec les conventions de nommage Noms Nœuds et éléments pour lesquels un préfixe peut être défini. Le nombre entre parenthèses après chaque élément (par exemple, PROGRAMME (102) ) est le numéro de convention de préfixe signalé en cas de non-respect d'une convention de dénomination. Préfixe Champ de saisie du préfixe Plusieurs préfixes peuvent être spécifiés au moyen d'une séparation par des virgules. Exemple: Préfixe pour les POU , PROGRAM (102) : prog, PRG_ Préfixe pour les POU , FUNCTION (103) : fun, FUN_ Les expressions régulières (RegEx) sont également possibles pour les préfixes. Pour ce faire, un @ doit être préfixé. Exemple: Le nom doit commencer par x et peut contenir un caractère de la portée a-dA-D : @x[a-dA-D] . Pour les variables de type Alias et POU de type Propriété , le préfixe peut être défini avec l'espace réservé {datatype} . Préfixes pour les variables Nœud organisationnel pour toutes les variables pour lesquelles un préfixe peut être défini en fonction du type de données ou de la portée. Préfixes pour les POU Nœud organisationnel pour tous les types de POU et portées de méthode pour lesquels un préfixe peut être défini Préfixes pour les DUT Nœud organisationnel pour les types de données DUT (structure, énumération, alias ou union) pour lesquels un préfixe peut être défini Préfixes pour les types personnalisés Nœud organisationnel pour les types personnalisés spéciaux (en particulier ceux des bibliothèques) Vous pouvez étendre la liste avec des conventions : Cliquez sur l'espace vide en dessous. Dans le Assistant de saisie boîte de dialogue, spécifiez le nom d'un type personnalisé ou sélectionnez un type personnalisé. Pour supprimer une convention, sélectionnez-la et appuyez sur la Suppr clé. Remarque : Ces conventions sont prioritaires sur les préfixes qui sont définis avec l'attribut {attribute 'nameprefix' := '<prefix>'} . Choix Le premier caractère après le préfixe doit être une lettre majuscule : L'analyse statique signale une erreur pour une variable lorsque le premier caractère du nom de la variable après le préfixe défini n'est pas une lettre majuscule. Combiner le préfixe de portée avec le préfixe de type de données : comme espace de noms, une variable doit avoir le préfixe défini suivi du préfixe défini pour son type de données. Exemple : Les préfixes suivants sont définis : g_ pour VAR_GLOBAL , et r pour le type de données RÉEL . L'analyse du code signale des erreurs pour les variables REAL globales qui n'ont pas le préfixe g_r avoir. : Si des conventions pour l'espace de noms sont spécifiées pour une variable, ces conventions sont prises en compte. Par conséquent, toutes les conventions de type de données sont ignorées. Exemple : Les préfixes suivants sont définis : g_ pour VAR_GLOBAL , et r pour le type de données RÉEL . L'analyse du code ne signale que les erreurs globales REAL -Variables qui n'ont pas le préfixe g_ avoir. Préfixes récursifs pour les types de données combinables : Les variables de types de données combinés doivent avoir des préfixes composés qui suivent les conventions de dénomination définies. Exemple: ppiVariable : POINTER TO POINTER TO INT; Le préfixe p a été défini pour les variables de type de données POINTER , et le préfixe I a été défini pour le type de données INT . L'analyse de code statique signale des erreurs pour toutes les variables de type de données POINTER TO POINTER TO INT , pas le préfixe ppi avoir. refaiVar : REFERENCE TO ARRAY[1..3] OF INT; Le préfixe ref a été défini pour le type de données REFERENCE TO , le préfixe a pour un tableau, et le préfixe I pour le type de données INT . L'analyse de code statique signale des erreurs pour toutes les variables de type de données REFERENCE TO ARRAY[1..3] OF INT , pas le préfixe refai avoir. Exemple La convention de nommage suivante correspond en grande partie aux recommandations décrites dans CODESYS pour les \"identifiants\". Exemple La convention de nommage (1) fait référence au POU standard TON . Par conséquent, les déclarations de la bibliothèque spéciale POU sont vérifiées pour le préfixe \"ton_\". Cliquez sur l'espace vide (2) pour insérer plus de conventions de nommage. " }, 
{ "title" : "Boîte de dialogue : Paramètres d'analyse statique : Métriques ", 
"url" : "_san_dlg_settings_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Dialogues \/ Boîte de dialogue : Paramètres d'analyse statique : Métriques ", 
"snippet" : "Paramètres d'analyse statique : Métriques Symbole : Fonction : configure les métriques afin qu'elles soient calculées et affichées en conséquence lorsque le Afficher les métriques par défaut la commande est exécutée. Appeler : Projet → Paramètres du projet menu, Analyse statique catégorie, Ouvrir la...", 
"body" : "Paramètres d'analyse statique : Métriques Symbole : Fonction : configure les métriques afin qu'elles soient calculées et affichées en conséquence lorsque le Afficher les métriques par défaut la commande est exécutée. Appeler : Projet → Paramètres du projet menu, Analyse statique catégorie, Ouvrir la boîte de dialogue de configuration lien Construire → Analyse statique → Paramètres menu Exigence : le CODESYS Static Analysis le paquet est installé. Un projet est ouvert. Pour plus d'informations, voir : Configuration et exécution d'une analyse statiqueMétrique Tous sélectionnables Métrique sont affichés dans la colonne. actif : La métrique est affichée pour chaque POU dans le Métriques standards voir suite à la Construire → Analyse statique → Afficher les métriques standard commander. : La métrique n'est pas affichée dans le Métriques standards voir suite à la Construire → Analyse statique → Afficher les métriques standard commander. Limite inférieure Valeur inférieure à partir de laquelle la métrique est affichée Limite supérieure Valeur supérieure à laquelle la métrique est affichée le Taille du code , Taille variable , Taille de la pile , et Appels les métriques sont rapportées uniquement pour les POU des bibliothèques qui sont intégrées dans le projet. Les violations des limites supérieures et inférieures des métriques activées peuvent être signalées comme des erreurs de construction au moyen d'une règle d'analyse statique SA0150 . " }, 
{ "title" : "Boîte de dialogue : Paramètres d'analyse statique : Symboles interdits ", 
"url" : "_san_dlg_settings_sa_forbidden_symbols.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Dialogues \/ Boîte de dialogue : Paramètres d'analyse statique : Symboles interdits ", 
"snippet" : "Symboles interdits Une fonction : Dans la boîte de dialogue, vous définissez les mots clés et les symboles qui ne doivent pas être utilisés dans le code du projet. Pour plus d'informations, consultez : Configuration et exécution d'une analyse statiqueAppeler : Projet → Paramètres du projet menu, Ana...", 
"body" : "Symboles interdits Une fonction : Dans la boîte de dialogue, vous définissez les mots clés et les symboles qui ne doivent pas être utilisés dans le code du projet. Pour plus d'informations, consultez : Configuration et exécution d'une analyse statiqueAppeler : Projet → Paramètres du projet menu, Analyse statique Catégorie, Ouvrir la boîte de dialogue de configuration lien Construire → Analyse statique → Paramètres menu Exigence : le CODESYS Static Analysis le paquet est installé. Un projet est ouvert. Ligne d'entrée Un double-clic sur la ligne ouvre l'éditeur de ligne permettant de spécifier un mot-clé ou un symbole. : L'assistant de saisie s'ouvre pour sélectionner le mot-clé ou le symbole. " }, 
{ "title" : "Boîte de dialogue : Options : Formateur automatique ", 
"url" : "_cds_dlg_options_smart_code.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Dialogues \/ Boîte de dialogue : Options : Formateur automatique ", 
"snippet" : "Formateur automatique Mode débogage Cette fonctionnalité est disponible uniquement lorsque votre CODESYS l'instance est démarrée en mode débogage. Pour ce faire, démarrez votre instance avec l'appel de ligne de commande suivant : codesys.exe --debug Symbole: Fonction : Le formatage automatique du co...", 
"body" : "Formateur automatique Mode débogage Cette fonctionnalité est disponible uniquement lorsque votre CODESYS l'instance est démarrée en mode débogage. Pour ce faire, démarrez votre instance avec l'appel de ligne de commande suivant : codesys.exe --debug Symbole: Fonction : Le formatage automatique du code CEI est configuré dans cette boîte de dialogue. Appel : Outils → Options menu, Formateur automatique catégorie " }, 
{ "title" : "Formateur automatique ", 
"url" : "_cds_dlg_options_smart_code.html#UUID-ed744990-e58a-afa4-07c6-a11c0254c4c0_section-idm4605775334425634132064038043", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Interface Utilisateur \/ Dialogues \/ Boîte de dialogue : Options : Formateur automatique \/ Formateur automatique ", 
"snippet" : "Général Déclaration et mise en œuvre Écraser les lignes vides true (défaut) : les lignes vides sont supprimées. false : Les lignes vides sont conservées. Interface Déclaration Aligner les types de variables true (défaut): Tous les types d'un bloc variable sont disposés de manière à commencer par la ...", 
"body" : "Général Déclaration et mise en œuvre Écraser les lignes vides true (défaut) : les lignes vides sont supprimées. false : Les lignes vides sont conservées. Interface Déclaration Aligner les types de variables true (défaut): Tous les types d'un bloc variable sont disposés de manière à commencer par la même profondeur de trait. false : Aligner les initialisations des variables true (défaut): Toutes les initialisations dans un bloc variable sont disposées de manière à commencer avec la même profondeur de ligne. false : Aligner les commentaires de fin de variable true (défaut): Tous les commentaires situés sur la même ligne que la déclaration de variable commencent à la même profondeur de ligne. false : Invocations Tous les appels sont formatés lorsque les valeurs maximales sont dépassées. Exemple: Max. nombre de paramètres avant le saut de ligne Le nombre de paramètres que peut contenir un appel monoligne est limité. Exemple : 4 (défaut) Max. longueur de caractère des paramètres avant le saut de ligne Le nombre de caractères dans le nom du paramètre est limité. Exemple : 300 (défaut) " }, 
{ "title" : "Référence : Programmation ", 
"url" : "_san_f_reference_programming.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Pragmas et attributs ", 
"url" : "_san_struct_reference_pragmas.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Pragmas et attributs ", 
"snippet" : "CODESYS Static Analysis fournit des pragmas et des attributs pour activer ou désactiver des règles individuelles ou des conventions de dénomination pour l'analyse de code statique. Condition : Les règles ou conventions sont activées ou définies dans les paramètres du projet. Les attributs sont insér...", 
"body" : "CODESYS Static Analysis fournit des pragmas et des attributs pour activer ou désactiver des règles individuelles ou des conventions de dénomination pour l'analyse de code statique. Condition : Les règles ou conventions sont activées ou définies dans les paramètres du projet. Les attributs sont insérés dans la partie déclaration d'un POU pour désactiver des règles spécifiques pour un objet de programmation entier. Les pragmas sont utilisés dans la partie implémentation d'un POU pour désactiver des règles spécifiques pour des lignes de code individuelles. Une exception est la règle 164, qui peut également être désactivée dans la partie déclaration. Les règles désactivées dans les paramètres du projet ne peuvent pas être activées au moyen de pragmas ou d'attributs. La règle SA0004 ne peut pas être désactivée au moyen d'un pragma ou d'un attribut. " }, 
{ "title" : "Pragma : analysis ", 
"url" : "_san_pragma_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Pragmas et attributs \/ Pragma : analysis ", 
"snippet" : "Ce pragma est utilisé pour désactiver les règles de code pour les lignes de code individuelles d'un POU afin qu'elles soient exclues du analyse statique . Vous désactivez les règles de code en spécifiant les numéros de règle avec un signe moins (\"-\"). Un signe plus (\"+\") ajouté au début active la rè...", 
"body" : "Ce pragma est utilisé pour désactiver les règles de code pour les lignes de code individuelles d'un POU afin qu'elles soient exclues du analyse statique . Vous désactivez les règles de code en spécifiant les numéros de règle avec un signe moins (\"-\"). Un signe plus (\"+\") ajouté au début active la règle. Vous pouvez spécifier n'importe quel nombre de règles dans le pragma. Emplacement d'insertion : Désactivation : Dans la partie implémentation, avec {analysis - ...} avant la première ligne de code où l'analyse de code est désactivée. Activation : Avec {analysis + ...} après la dernière ligne de la désactivation. Pour la règle 164, le pragma peut également être inséré dans la partie déclaration avant un commentaire. Syntaxe: Deaktivierung von Regeln:\n\n{analysis -<rule number> ( , -<further rule number> )* }\n* : optional none, one or more further rule numbers Aktivierung von Regeln:\n\nanalysis +<rule number> ( , +<further rule number> )* }\n* : none, one or more further rule numbers Exemple La règle 24 est désactivée pour deux lignes puis réactivée. Par conséquent, la règle 24 n'est pas vérifiée dans ces lignes de sorte que nTest:=DINT#99 est autorisé par exemple. {analysis -24}\nnTest := 99;\niVar := INT#2;\n{analysis +24} Désactivation de plusieurs règles : {analysis -10, -24, -18} " }, 
{ "title" : "Attribut : analysis ", 
"url" : "_san_attribute_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Pragmas et attributs \/ Attribut : analysis ", 
"snippet" : "L'attribut désactive des règles spécifiques pour un objet de programmation entier afin qu'elles soient exclues de la analyse statique . Vous désactivez les règles de code en spécifiant les numéros de règle avec un signe moins (\"-\"). Vous pouvez spécifier n'importe quel nombre de règles dans l'attrib...", 
"body" : "L'attribut désactive des règles spécifiques pour un objet de programmation entier afin qu'elles soient exclues de la analyse statique . Vous désactivez les règles de code en spécifiant les numéros de règle avec un signe moins (\"-\"). Vous pouvez spécifier n'importe quel nombre de règles dans l'attribut. Emplacement d'insertion : Dans la partie déclaration d'un POU, en première ligne. Syntaxe : {attribute 'analysis' := '-<rule number> ( , -<further rule number> )* '}\n* : none, one or more further rule numbers Exemple Les règles 33 et 31 sont désactivées pour toute la structure : {attribute 'analysis' := '-33, -31'}\nTYPE My_Structure :\nSTRUCT\n iLocal : INT;\n uiLocal : UINT;\n udiLocal : UDINT;\nEND_STRUCT\nEND_TYPE La règle 100 est désactivée pour le tableau : {attribute 'analysis' := '-100'}\nPROGRAM PLC_PRG\nVAR\n aBigData: ARRAY[1..10000] OF DWORD;\n aBigDATA_2: ARRAY[1..10000] OF DWORD;\nEND_VAR\n; " }, 
{ "title" : "Attribut : 'naming' ", 
"url" : "_san_attribute_naming.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Pragmas et attributs \/ Attribut : 'naming' ", 
"snippet" : "L'attribut marque les lignes de code qui sont exclues du analyse de la convention de nommage . Une off est affecté à l'attribut pragma avant la première ligne de code où l'analyse de code est désactivée. Une on est attribué après la dernière ligne. Quand un omit est attribué, seule la ligne de code ...", 
"body" : "L'attribut marque les lignes de code qui sont exclues du analyse de la convention de nommage . Une off est affecté à l'attribut pragma avant la première ligne de code où l'analyse de code est désactivée. Une on est attribué après la dernière ligne. Quand un omit est attribué, seule la ligne de code suivante est ignorée. Emplacement d'insertion : Désactivation : Dans la partie déclaration des POU et DUT, au-dessus des lignes concernées. Activation : sous les lignes concernées. Syntaxe : {attribute 'naming' := '<switch state>'}\n<switch state> : on | off | omit\non : naming is switched on\noff : naming is switched off\nomit : only next codeline is switched off Exemple Conventions de nommage définies : 1) Les noms de variables INT doivent être précédés de \"int\" comme préfixe d'identifiant, par exemple \"intVar1\". (2) Les noms de programmes doivent commencer par \"prog\". Pour le code présenté ci-dessous, l'analyse statique émet des messages uniquement pour les variables suivantes : cccVar , aVariable , et bVariable . VAR\n{attribute 'naming' := 'off'}\n iVarA : INT;\n iVarB : INT;\n{attribute 'naming' := 'on'}\n iVarC : INT;\nEND_VAR VAR\n ...\n{attribute 'naming' := 'omit'}\n iVarC : INT;\n...\nEND_VAR {attribute 'naming' := 'omit'}\nPROGRAM PLC_PRG\nVAR\n...\nEND_VAR {attribute 'naming' := 'off'}\nPROGRAM DoSomethingA\nVAR\n{attribute 'naming' := 'on'}\n iVarA : INT;\n iVarB : INT;\n …\nVAR_END " }, 
{ "title" : "Attribut : nameprefix ", 
"url" : "_san_attribute_nameprefix.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Pragmas et attributs \/ Attribut : nameprefix ", 
"snippet" : "nameprefix L'attribut définit un préfixe pour les variables d'un type de données structuré. Le préfixe doit être ajouté à l'identifiant des variables déclarées par ce type. le analyse statique vérifie cette convention de nommage. Emplacement d'insertion : Dans la ligne précédant la déclaration d'un ...", 
"body" : "nameprefix L'attribut définit un préfixe pour les variables d'un type de données structuré. Le préfixe doit être ajouté à l'identifiant des variables déclarées par ce type. le analyse statique vérifie cette convention de nommage. Emplacement d'insertion : Dans la ligne précédant la déclaration d'un type de données structuré Syntaxe : {attribute 'nameprefix' := '<prefix>'} Exemple Dans l'exemple suivant, Static Analysis émet un message pour pB car le nom de la variable ne commence pas par \"point\". {attribute 'nameprefix' := 'point'}\nTYPE DATAPOINT :\nSTRUCT\n iX: INT;\n iY: INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n pointA : DATAPOINT;\n pB : DATAPOINT;\nEND_VAR\npointA.iX := 1;\npointA.iY := 10;\npB.iX := 2;\npB.iY := 20; Message d'erreur après analyse statique : Nom de variable 'pB' non valide : préfixe 'point' attendu " }, 
{ "title" : "Attribut : analysis:report-multiple-instance-calls ", 
"url" : "_san_attribute_analysis_report_multiple_instance_calls.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Pragmas et attributs \/ Attribut : analysis:report-multiple-instance-calls ", 
"snippet" : "analysis:report-multiple-instance-calls L'attribut marque un bloc fonctionnel pour vérifier la règle règle 105 : Seuls les blocs fonctionnels avec cet attribut sont vérifiés si les instances de bloc fonctionnel sont appelées plus d'une fois. Lorsque la règle 105 est désactivée dans le paramètres du ...", 
"body" : "analysis:report-multiple-instance-calls L'attribut marque un bloc fonctionnel pour vérifier la règle règle 105 : Seuls les blocs fonctionnels avec cet attribut sont vérifiés si les instances de bloc fonctionnel sont appelées plus d'une fois. Lorsque la règle 105 est désactivée dans le paramètres du projet , l'attribut n'a aucun effet. Emplacement d'insertion : Première ligne dans la partie déclaration d'un bloc fonction. Syntaxe : {attribute 'analysis:report-multiple-instance-calls'} Exemple \/\/ {attribute 'analysis:report-multiple-instance-calls'} deactivated\nFUNCTION_BLOCK FB_DoA\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\n{attribute 'analysis:report-multiple-instance-calls'}\nFUNCTION_BLOCK FB_DoB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iB : INT;\nEND_VAR\niB := iB +1;\n\nPROGRAM PLC_PRG\nVAR\n fbA : FB_DoA;\n fbB : FB_DoB;\nND_VAR\n\nfbA();\nfbB(); \/\/ SA0105\nfbA();\nfbB(); \/\/ SA0105\n Sortie sous vue messages : SA0105 : Instance 'fbB' appelée plusieurs fois " }, 
{ "title" : "Des règles ", 
"url" : "_san_struct_reference_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0001 : Code inaccessible ", 
"url" : "_san_rule_sa0001.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0001 : Code inaccessible ", 
"snippet" : "Détecte les lignes de code qui ne sont pas exécutées, par exemple en raison d'un RETURN ou CONTINUE déclaration Justification : Le code inaccessible doit toujours être évité. le test indique souvent que le code de test existe toujours et qu'il doit être supprimé. Importance : Élevée Règle PLCopen : ...", 
"body" : "Détecte les lignes de code qui ne sont pas exécutées, par exemple en raison d'un RETURN ou CONTINUE déclaration Justification : Le code inaccessible doit toujours être évité. le test indique souvent que le code de test existe toujours et qu'il doit être supprimé. Importance : Élevée Règle PLCopen : CP2 Exemple PROGRAM PLC_PRG\nVAR\n xReturn_Before_End: BOOL;\n xContinue_In_Loop_FUN: BOOL;\n iCounter: INT;\nEND_VAR\n xContinue_In_Loop_FUN := FALSE;\nFOR iCounter := INT#0 TO INT#5 BY INT#1 DO\n CONTINUE;\n xContinue_In_Loop_FUN := FALSE;\nEND_FOR Sortie dans le messages voir: SA0001 : Code inaccessible détecté dans 'PLC_PRG' " }, 
{ "title" : "SA0002 : Objets vides ", 
"url" : "_san_rule_sa0002.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0002 : Objets vides ", 
"snippet" : "Détecte les POU, les GVL, les déclarations de type de données ou les interfaces qui ne contiennent aucun code Justification : Les objets vides doivent être évités. Ils sont souvent le signe qu'un objet n'a pas été complètement implémenté. Exception : dans certains cas, aucun code n'est spécifié dans...", 
"body" : "Détecte les POU, les GVL, les déclarations de type de données ou les interfaces qui ne contiennent aucun code Justification : Les objets vides doivent être évités. Ils sont souvent le signe qu'un objet n'a pas été complètement implémenté. Exception : dans certains cas, aucun code n'est spécifié dans le corps d'un bloc fonctionnel alors qu'il doit être utilisé uniquement par les interfaces. Dans d'autres cas, une méthode est créée uniquement parce qu'elle est requise par une interface sans qu'une implémentation sensée ne soit possible pour la méthode. Peu importe le cas, ce genre de situation doit être commenté. Importance : Moyenne " }, 
{ "title" : "SA0003 : Déclarations vides ", 
"url" : "_san_rule_sa0003.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0003 : Déclarations vides ", 
"snippet" : "Détecte les lignes de code contenant un point-virgule ( ; ) mais pas une déclaration Justification : Une instruction vide peut être le signe d'un code manquant. Remarque : Il existe de bonnes raisons d'utiliser des instructions vides. Par exemple, dans un CASE Dans cette déclaration, il peut être ju...", 
"body" : "Détecte les lignes de code contenant un point-virgule ( ; ) mais pas une déclaration Justification : Une instruction vide peut être le signe d'un code manquant. Remarque : Il existe de bonnes raisons d'utiliser des instructions vides. Par exemple, dans un CASE Dans cette déclaration, il peut être judicieux de programmer explicitement tous les cas, même ceux où il n'y a rien à faire. Quand ce genre de vide CASE Si l'instruction contient un commentaire, l'analyse statique ne génère pas de message d'erreur. Importance : Faible Exemple CASE value OF\n 1:\n DoSomething();\n 2:\n ;\n 3:\n DoSomethingElse();\nEND_CASE\n Sortie dans le messages voir: SA0003 : instructions vides CASE value OF\n 1:\n DoSomething();\n 2:\n ; \/\/nothing to do\n 3:\n DoSomethingElse();\nEND_CASE\n Sortie dans le messages voir: Aucune erreur SA " }, 
{ "title" : "SA0004 : accès en écriture multiple sur la sortie ", 
"url" : "_san_rule_sa0004.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0004 : accès en écriture multiple sur la sortie ", 
"snippet" : "Détecte les sorties écrites à plusieurs emplacements. Justification : La maintenabilité est dégradée lorsqu'une sortie est écrite à différents endroits dans le code. Ensuite, il est incertain quel accès en écriture est celui qui a réellement un effet sur le processus. La bonne pratique consiste à ca...", 
"body" : "Détecte les sorties écrites à plusieurs emplacements. Justification : La maintenabilité est dégradée lorsqu'une sortie est écrite à différents endroits dans le code. Ensuite, il est incertain quel accès en écriture est celui qui a réellement un effet sur le processus. La bonne pratique consiste à calculer les variables de sortie dans les variables auxiliaires et à attribuer la valeur calculée à un endroit à la fin du cycle. Importance : Élevée Règle PLCopen : CP12 Aucune erreur n'est émise lorsqu'une variable de sortie ( VAR_IN_OUT ) est écrit dans différentes branches de IF et CASE déclarations. Un pragma ne peut pas désactiver cette règle. Exemple VAR_GLOBAL\n g_xVar AT %QX0.0 : BOOL ;\n g_iTest AT %QW0 : INT ;\nEND_VAR PROGRAM PLC_PRG IF g_iCondition < INT#0 THEN\n g_xVar := TRUE;\n g_iTest := INT#12;\nEND_IF\n\nCASE g_iCondition OF\n INT#1:\n g_xVar := FALSE;\n INT#2:\n g_iTest := INT#11;\n ELSE\n g_xVar := TRUE;\n g_iTest := INT#9;\nEND_CASE\n Sortie dans le messages voir: SA0004 : Accès en écriture multiple sur la sortie '%QX0.0' SA0004 : Accès en écriture multiple sur la sortie '%QW0' " }, 
{ "title" : "SA0006 : Accès en écriture à partir de plusieurs tâches ", 
"url" : "_san_rule_sa0006.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0006 : Accès en écriture à partir de plusieurs tâches ", 
"snippet" : "Détecte les variables qui sont écrites par plusieurs tâches. Justification : Une variable écrite dans plusieurs tâches peut changer de valeur de manière inattendue. Cela peut conduire à des situations confuses. Les variables de chaîne (et sur certains systèmes 32 bits également les variables entière...", 
"body" : "Détecte les variables qui sont écrites par plusieurs tâches. Justification : Une variable écrite dans plusieurs tâches peut changer de valeur de manière inattendue. Cela peut conduire à des situations confuses. Les variables de chaîne (et sur certains systèmes 32 bits également les variables entières 64 bits) peuvent même atteindre un état incohérent si la variable est écrite simultanément dans deux tâches. Exception : Dans des cas particuliers, il peut être nécessaire pour plusieurs tâches d'écrire une variable. Par exemple, utilisez des sémaphores pour vous assurer que l'accès ne mène pas à un état incohérent. Importance : Élevée Règle PLCopen : CP10 Exemple VAR_GLOBAL\n g_iTemp1: INT;\nEND_VAR PROGRAM PLC_PRG \/\/ Controlled by MainTask\ng_iTemp1 := g_iTemp1 + INT#2;\n PROGRAM PLC_PRG_1 \/\/Controlled by SubTask\ng_iTemp1 := g_iTemp1 - INT#3; Sortie dans le messages voir: SA0006 : accès en écriture simultané à 'g_iTemp1' dans les tâches MainTask, SubTask " }, 
{ "title" : "SA0007 : Opérateur d'adresse sur les constantes ", 
"url" : "_san_rule_sa0007.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0007 : Opérateur d'adresse sur les constantes ", 
"snippet" : "Détecte les lignes de code où l'opérateur ADR est appliqué pour une constante Justification : L'utilisation d'un pointeur vers une variable constante remplace CONSTANT propriété de la variable. La variable peut être modifiée au moyen du pointeur sans aucune notification du compilateur. Exception : d...", 
"body" : "Détecte les lignes de code où l'opérateur ADR est appliqué pour une constante Justification : L'utilisation d'un pointeur vers une variable constante remplace CONSTANT propriété de la variable. La variable peut être modifiée au moyen du pointeur sans aucune notification du compilateur. Exception : dans de rares cas, il peut être utile de passer un pointeur vers une constante à une fonction. Cependant, vous devez vous assurer que cette fonction ne modifie pas la valeur transférée. Dans la mesure du possible, utilisez VAR_IN_OUT CONSTANT . Importance : Élevée Quand le Remplacer les constantes l'option est sélectionnée dans le Options du compilateur des paramètres du projet, l'opérateur d'adresse n'est pas autorisé pour les constantes scalaires (entier, BOOL , REAL ) et une erreur de compilation est émise. (Les chaînes, structures et tableaux constants ont toujours une adresse.) Exemple PROGRAM PLC_PRG\nVAR CONSTANT\n c_iValue : INT := INT#15;\nEND_VAR\nVAR\n poiValue : POINTER TO INT;\nEND_VAR\n poiValue := ADR(c_iValue); \/\/ SA0007 Sortie dans le messages voir: SA0007 : Adresse de la variable constante 'c_iValue' " }, 
{ "title" : "SA0008 : Vérifier les types de sous-gamme ", 
"url" : "_san_rule_sa0008.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0008 : Vérifier les types de sous-gamme ", 
"snippet" : "Détecte les violations hors plage des types de sous-plage. Les littéraux assignés sont déjà vérifiés par le compilateur. Lorsque des constantes sont affectées, les valeurs doivent être comprises dans la plage définie. Lorsque des variables sont affectées, les types de données doivent être identiques...", 
"body" : "Détecte les violations hors plage des types de sous-plage. Les littéraux assignés sont déjà vérifiés par le compilateur. Lorsque des constantes sont affectées, les valeurs doivent être comprises dans la plage définie. Lorsque des variables sont affectées, les types de données doivent être identiques. Justification : Si des types de sous-gamme sont utilisés, assurez-vous que cette sous-gamme n'est pas quittée. Le compilateur vérifie ces types de violations de sous-intervalle uniquement pour les affectations de constantes. Importance : Faible Le contrôle n'est pas effectué pour les objets CFC car la structure du code ne le permet pas. Exemple VAR_GLOBAL\n iVarGlob:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n iSubr1: INT (INT#1..INT#10);\n iSubr2: INT (INT#1..INT#1000);\n iCount: INT;\n by_SubType : BYTE (BYTE#0..BYTE#11);\n iVar : INT (-4095..4095);\nEND_VAR\n iSubr1 := nCount; \/\/ SA0008\niSubr1 := subr2; \/\/ SA0008\niSubr1 := gvl.iVarGlob; \/\/ SA0008\n\/\/byBYTE_SubType := BYTE#123; \/\/already detected by compiler, error \"Cannot convert type...\" Sortie dans le messages voir: SA0008 : La variable de sous-plage 'iSubr1' est peut-être hors de la plage autorisée " }, 
{ "title" : "SA0009 : valeurs de retour inutilisées ", 
"url" : "_san_rule_sa0009.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0009 : valeurs de retour inutilisées ", 
"snippet" : "Détecte les appels de fonction, de méthode et de propriété dans lesquels la valeur de retour n'est pas utilisée Justification : Lorsqu'une fonction ou une méthode renvoie une valeur de retour, vous devez également l'évaluer. La valeur de retour indique souvent si la fonction a été exécutée avec succ...", 
"body" : "Détecte les appels de fonction, de méthode et de propriété dans lesquels la valeur de retour n'est pas utilisée Justification : Lorsqu'une fonction ou une méthode renvoie une valeur de retour, vous devez également l'évaluer. La valeur de retour indique souvent si la fonction a été exécutée avec succès ou non. S'il n'y a pas d'évaluation, vous ne pourrez pas déterminer ultérieurement si la valeur de retour a été oubliée ou si elle n'est réellement pas nécessaire. Exception : Si une valeur de retour n'est pas pertinente pour l'appel, vous devez la documenter et omettre l'affectation. Les retours d’erreur ne doivent jamais être ignorés. Importance : Moyenne Règle PLCopen : CP7 \/ CP17 Exemple FUNCTION Return_BOOL : BOOL\nVAR_INPUT\nEND_VAR\nVAR\n    xTest : BOOL;\nEND_VAR xTest := FALSE;\nReturn_BOOL := xTest; PROGRAM PLC_PRG\nReturn_BOOL();  \/\/ SA0009\n Sortie dans le messages voir: SA0009 : ignorance de la valeur de retour de « Return_BOOL » " }, 
{ "title" : "SA0010 : Tableaux avec un seul composant ", 
"url" : "_san_rule_sa0010.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0010 : Tableaux avec un seul composant ", 
"snippet" : "Détecte les tableaux avec un seul élément Justification : Un tableau à un élément peut être remplacé par une variable de type de base. L'accès à cette variable est considérablement plus rapide que l'accès par index à la variable. Exception : La longueur d'un tableau est souvent déterminée par une co...", 
"body" : "Détecte les tableaux avec un seul élément Justification : Un tableau à un élément peut être remplacé par une variable de type de base. L'accès à cette variable est considérablement plus rapide que l'accès par index à la variable. Exception : La longueur d'un tableau est souvent déterminée par une constante et constitue un paramètre pour un programme. Le programme peut alors travailler avec des tableaux de différentes longueurs et n'a pas besoin d'être modifié si la longueur n'est que de 1. Ce type de situation doit être documenté en conséquence. Importance : Faible Exemple PROGRAM PLC_PRG\nVAR\n aoiEmpty : ARRAY [22..22] OF INT := [22];\n aorEmpty : ARRAY [2..2] OF REAL := [2.2];\n iVar : INT;\n rVAR : REAL;\nEND_VAR iVar := aoiEmpty[22];\nrVAR := aorEmpty[2];\n Sortie dans le messages voir: SA0010 : élément de tableau vide dans la variable 'aoiEmpty' SA0010 : élément de tableau vide dans la variable 'aorEmpty' " }, 
{ "title" : "SA0011: Déclaration inutile avec un seul membre ", 
"url" : "_san_rule_sa0011.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0011: Déclaration inutile avec un seul membre ", 
"snippet" : "Détecte les structures ou les énumérations avec un seul membre Justification : Aucune structure ou énumération comportant un seul membre ne doit être déclarée. De telles déclarations peuvent prêter à confusion pour les lecteurs. Une structure comportant un seul élément peut être remplacée par un typ...", 
"body" : "Détecte les structures ou les énumérations avec un seul membre Justification : Aucune structure ou énumération comportant un seul membre ne doit être déclarée. De telles déclarations peuvent prêter à confusion pour les lecteurs. Une structure comportant un seul élément peut être remplacée par un type alias. Une énumération comportant un seul élément peut être remplacée par une constante. Règle PLCopen : CP22 \/ CP24 Importance : Faible Exemple {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE SINGLE_ENUM :\n(\n\tOnlyOne := 1\n);\nEND_TYPE TYPE SINGLE_UNION :\nUNION\n\tlrValue : LREAL;\nEND_UNION\nEND_TYPE {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE SINGLE_ENUM :\n(\n\tOnlyOne := 1\n);\nEND_TYPE Sortie dans le messages voir: SA0011 : Déclaration inutile 'SINGLE_ENUM' : Struct\/Enum avec un seul membre ne doit pas être utilisé SA0011 : Déclaration inutile 'SINGLE_UNION' : Struct\/Enum avec un seul membre ne doit pas être utilisé SA0011 : Déclaration inutile 'SINGLE_STRUCT' : Struct\/Enum avec un seul membre ne doit pas être utilisé " }, 
{ "title" : "SA0012 : Variable pouvant être déclarée comme constante ", 
"url" : "_san_rule_sa0012.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0012 : Variable pouvant être déclarée comme constante ", 
"snippet" : "Détecte les variables qui ne sont pas accessibles avec l'autorisation d'écriture et qui pourraient donc être déclarées comme des constantes Justification : Si une variable est écrite uniquement au point de déclaration et est par ailleurs utilisée uniquement pour la lecture, alors l'analyse statique ...", 
"body" : "Détecte les variables qui ne sont pas accessibles avec l'autorisation d'écriture et qui pourraient donc être déclarées comme des constantes Justification : Si une variable est écrite uniquement au point de déclaration et est par ailleurs utilisée uniquement pour la lecture, alors l'analyse statique suppose que la variable ne doit pas non plus être modifiée. Tout d'abord, une déclaration en constante revient à vérifier que la variable n'est pas modifiée lors du changement de programme. Deuxièmement, la déclaration en tant que constante peut entraîner un code plus rapide. Si plusieurs applications existent dans un projet, seuls les objets sous l'application actuellement active sont affectés. S'il n'y a qu'une seule application, les objets du pool de POU commun sont également affectés. Importance : Faible Exemple PROGRAM PLC_PRG\nVAR\n iVar : INT := INT#17;\n iTest : INT;\nEND_VAR\n iTest := iTest + iVar; \/\/ SA0012: 'iVar' could be declared as constant Sortie dans le messages voir: SA0012 : La variable 'iVar' pourrait être déclarée comme constante " }, 
{ "title" : "SA0013 : Déclarations avec le même nom de variable ", 
"url" : "_san_rule_sa0013.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0013 : Déclarations avec le même nom de variable ", 
"snippet" : "Détecte les variables dont les noms sont déjà utilisés par d'autres variables (par exemple, les variables globales et locales portant le même nom). Les variables sont également détectées dont les noms de fonctions, d'actions, de méthodes ou de propriétés sont utilisés dans la même plage d'accès. Les...", 
"body" : "Détecte les variables dont les noms sont déjà utilisés par d'autres variables (par exemple, les variables globales et locales portant le même nom). Les variables sont également détectées dont les noms de fonctions, d'actions, de méthodes ou de propriétés sont utilisés dans la même plage d'accès. Les variables sont également détectées qui sont déclarées dans un GVL dans le Dispositifs vue ou dans la piscine des POU. Mais pour cela, le GVL du POU La vue doit être utilisée dans le programme d'application. Justification : Les mêmes noms peuvent prêter à confusion lors de la lecture du code et peuvent provoquer des erreurs si le mauvais objet est accédé par inadvertance. Nous vous recommandons d'utiliser des conventions de dénomination pour éviter ces situations. Règle PLCopen : N5 \/ N9 Importance : Moyenne Exemple VAR_GLOBAL\n xVar1 : BOOL;\n iVar3 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n xVar1 : BOOL; \/\/ SA0013\n iVar3 : INT; \/\/ SA0013\nEND_VAR\n xVar1 := NOT GVL.xVar1;\niVar3 := iVar3 + INT#2;\niVar3 := GVL.iVar3; Sortie dans le messages voir: SA0013 : La déclaration de 'iVar1' masque le symbole 'GVL.iVar1' SA0013 : La déclaration de 'xVar3' masque le symbole 'GVL.xVar3' Exemple Le FB_Pou Le bloc fonctionnel a le ACT action, le METH méthode et des variables locales portant les mêmes noms. FUNCTION_BLOCK FB_Pou\nVAR\n ACT : UINT; \/\/ SA0013\n METH : BYTE; \/\/ SA0013\nEND_VAR PROGRAM PLC_PRG\nVAR\n fbPou : FB_Pou;\nEND_VAR\n fbPou(); Sortie dans le messages voir: SA0013 : La déclaration de 'ACT' masque le symbole 'FB_Pou.ACT' SA0013 : La déclaration de 'METH' masque le symbole 'FB_Pou.METH' " }, 
{ "title" : "SA0014 : Affectation d'instances ", 
"url" : "_san_rule_sa0014.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0014 : Affectation d'instances ", 
"snippet" : "Détecte les affectations aux instances de bloc fonction. Dans le cas d'instances avec des pointeurs ou des variables de référence, ces affectations sont potentiellement risquées. Justification : Il s'agit d'un avertissement de performance. Lorsqu'une instance est affectée à une autre instance, tous ...", 
"body" : "Détecte les affectations aux instances de bloc fonction. Dans le cas d'instances avec des pointeurs ou des variables de référence, ces affectations sont potentiellement risquées. Justification : Il s'agit d'un avertissement de performance. Lorsqu'une instance est affectée à une autre instance, tous les éléments et sous-éléments sont copiés d'une instance à l'autre instance. Les pointeurs vers les données sont également copiés, mais pas leurs données référencées, de sorte que l'instance cible et l'instance source contiennent les mêmes données après l'affectation. Selon la taille des instances, ce type d'affectation peut durer longtemps. Par exemple, si une instance doit être transmise à une fonction pour traitement, il est beaucoup plus efficace de transmettre un pointeur vers l'instance. Si vous souhaitez copier sélectivement des valeurs d'une instance à une autre, une méthode de copie est utile : inst_First.Copy_From(inst_Second) Importance : Moyenne Exemple PROGRAM PLC_PRG\nVAR\n inst_First : My_FB;\n inst_Second : My_FB;\nEND_VAR\n inst_First();\ninst_Second := inst_First; \/\/ SA0014 Sortie dans le messages voir: SA0014 : Affectation des instances " }, 
{ "title" : "SA0015 : Accès aux données globales via FB_Init ", 
"url" : "_san_rule_sa0015.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0015 : Accès aux données globales via FB_Init ", 
"snippet" : "Détecte l'accès d'un bloc fonction à des variables globales au moyen de la méthode FB_Init . La valeur de cette variable dépend de l'ordre des initialisations. Justification : Selon l'emplacement de déclaration de l'instance de POU, une variable non initialisée peut être accessible en cas de violati...", 
"body" : "Détecte l'accès d'un bloc fonction à des variables globales au moyen de la méthode FB_Init . La valeur de cette variable dépend de l'ordre des initialisations. Justification : Selon l'emplacement de déclaration de l'instance de POU, une variable non initialisée peut être accessible en cas de violation de la règle. Importance : Élevée Exemple VAR_GLOBAL\n g_xTest1 : BOOL;\n g_iTest3 : INT;\nEND_VAR METHOD PUBLIC fb_init : BOOL\nVAR_INPUT\n (* If TRUE, the retain variables are initialized (warm start \/ cold start) *)\n bInitRetains : BOOL; \n (* If TRUE, the instance afterwards gets moved into the copy code (online change) *)\n bInCopyCode : BOOL; \nEND_VAR\n g_xTest1 := NOT g_xTest1; \/\/ SA0015\ng_iTest3 := g_iTest3 + INT#1; \/\/ SA0015 Sortie dans le messages voir: SA0015 : La méthode FB_Init du bloc fonctionnel 'POU' accède aux données globales " }, 
{ "title" : "SA0016 : Lacunes dans les structures ", 
"url" : "_san_rule_sa0016.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0016 : Lacunes dans les structures ", 
"snippet" : "Détecte les lacunes dans les structures ou les blocs fonctionnels qui sont causées par les exigences d'alignement du système cible actuellement défini. Si possible, vous devez supprimer les lacunes en regroupant les éléments de structure ou en les remplissant avec un élément factice. Si cela n'est p...", 
"body" : "Détecte les lacunes dans les structures ou les blocs fonctionnels qui sont causées par les exigences d'alignement du système cible actuellement défini. Si possible, vous devez supprimer les lacunes en regroupant les éléments de structure ou en les remplissant avec un élément factice. Si cela n'est pas possible, vous pouvez désactiver la règle pour les structures concernées à l'aide de la analysis pragmatique. Justification : En raison des différentes exigences d'alignement sur différentes plates-formes, il peut y avoir une disposition différente dans la mémoire pour ces types de structures. Ensuite, le code peut fonctionner différemment, selon la plate-forme. Importance : Faible Exemple TYPE Unpadded_Structure :\nSTRUCT\n xTest : BOOL;\n iTest : INT; \/\/ SA0016\n byTest : BYTE;\n wTest : WORD;\nEND_STRUCT\nEND_TYPE\n PROGRAM PLC_PRG\nVAR\n myStruct : Unpadded_Structure;\nEND_VAR\n myStruct.iTest := 0; Sortie dans le messages voir: SA0016 : La structure 'Unpadded_Structure' doit être complétée (pack-mode=8) " }, 
{ "title" : "SA0017 : Affectation inhabituelle à une variable de pointeur ", 
"url" : "_san_rule_sa0017.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0017 : Affectation inhabituelle à une variable de pointeur ", 
"snippet" : "Détecte les affectations à des pointeurs qui ne sont ni des adresses ( ADR opérateur, variables de pointeur) ni constantes 0 Justification : Si un pointeur se voit attribuer une valeur qui n'est pas une adresse valide, alors le déréférencement du pointeur conduit à une \"exception de violation d'accè...", 
"body" : "Détecte les affectations à des pointeurs qui ne sont ni des adresses ( ADR opérateur, variables de pointeur) ni constantes 0 Justification : Si un pointeur se voit attribuer une valeur qui n'est pas une adresse valide, alors le déréférencement du pointeur conduit à une \"exception de violation d'accès\". Importance : Élevée Exemple PROGRAM PLC_PRG\nVAR\n pInt : POINTER TO INT;\n dwAddress : DWORD;\nEND_VAR\n dwAddress := dwAddress + DWORD#1;\npInt := dwAddress; \/\/ SA0017 Sortie dans le messages voir: SA0017 : Affectation inhabituelle à une variable de pointeur " }, 
{ "title" : "SA0018 : Accès inhabituel aux bits ", 
"url" : "_san_rule_sa0018.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0018 : Accès inhabituel aux bits ", 
"snippet" : "Détecte l'accès aux bits aux variables signées. Cependant, la norme CEI 61131-3 autorise uniquement les opérations d'accès aux bits et de décalage de bits sur les champs de bits. Voir aussi les règles strictes SA0147 et SA0148 . Justification : Les types de données signés ne doivent pas être utilisé...", 
"body" : "Détecte l'accès aux bits aux variables signées. Cependant, la norme CEI 61131-3 autorise uniquement les opérations d'accès aux bits et de décalage de bits sur les champs de bits. Voir aussi les règles strictes SA0147 et SA0148 . Justification : Les types de données signés ne doivent pas être utilisés comme champs de bits et inversement. La norme CEI 61131-3 ne prévoit pas ce type d'accès, et vous devez donc vous conformer à cette règle lorsque vous écrivez du code portable. Importance : Moyenne Exception pour les énumérations de drapeaux : lorsqu'une énumération est déclarée comme drapeau au moyen de la {attribute 'flags'} l'attribut pragma, l'attribut SA0018 l'erreur n'est pas émise pour l'accès au bit avec le OR , AND ou NOT les opérateurs. Exemple PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n diTemp3 : DINT;\n uliTemp4 : ULINT;\n siTemp5 : SINT;\n usiTemp6 : USINT;\n byTemp2 : BYTE;\nEND_VAR\n iTemp1.3 := TRUE; \/\/SA0018\ndiTemp3.4 := TRUE; \/\/SA0018\nuliTemp4.18 := FALSE; \/\/no error because this is an unsigned data type\nsiTemp5.2 := FALSE; \/\/SA0018\nusiTemp6.3 := TRUE; \/\/no error because this is an unsigned data type\nbyTemp2.5 := FALSE; \/\/no error because the byte is a bitfield Sortie dans le messages voir: SA0018 : Accès aux bits inhabituel " }, 
{ "title" : "SA0020 : Affectation possible d'une valeur tronquée à la variable REAL ", 
"url" : "_san_rule_sa0020.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0020 : Affectation possible d'une valeur tronquée à la variable REAL ", 
"snippet" : "Détecte les opérations sur des variables entières pour lesquelles une valeur tronquée pourrait être affectée à un REAL variable de type de données Justification : L'analyse statique génère une erreur lorsque le résultat d'un calcul d'entier est affecté à un REAL ou LREAL variable. Le programmeur doi...", 
"body" : "Détecte les opérations sur des variables entières pour lesquelles une valeur tronquée pourrait être affectée à un REAL variable de type de données Justification : L'analyse statique génère une erreur lorsque le résultat d'un calcul d'entier est affecté à un REAL ou LREAL variable. Le programmeur doit être alerté d'une éventuelle interprétation incorrecte de ce type d'affectation : lrealvar := dintvar1 * dintvar2 . Étant donné que la plage de valeurs de LREAL est plus grand que celui de DINT , on pourrait supposer que le résultat du calcul serait de toute façon LREAL peut être affiché. Ce n'est pas le cas. Le processeur calcule le résultat de la multiplication sous la forme d'un entier puis refond le résultat LREAL . Un débordement dans le calcul de l'entier serait perdu. Si vous voulez éviter le problème, la facture doit déjà être aussi REAL - Chirurgie faite : lreal_var := TO_LREAL(dintvar1) * TO_LREAL(dintvar2) Importance : Élevée Exemple PROGRAM PLC_PRG\nVAR\n rX : LREAL;\n dI : DINT;\nEND_VAR\n rX := dI * dI \/\/ SA0020\nrX := TO_LREAL(dI) * TO_LREAL(dI) \/\/no message Sortie dans le messages voir: SA0020 : Eventuellement affectation d'une valeur tronquée à une variable REAL " }, 
{ "title" : "SA0021 : Transport de l'adresse d'une variable temporaire ", 
"url" : "_san_rule_sa0021.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0021 : Transport de l'adresse d'une variable temporaire ", 
"snippet" : "Détecte les affectations d'adresses de variables temporaires (sur la pile) à des variables non temporaires Justification : Les variables locales d'une fonction ou d'une méthode sont créées sur la pile et elles n'existent que pendant le traitement de la fonction ou de la méthode. Si un pointeur point...", 
"body" : "Détecte les affectations d'adresses de variables temporaires (sur la pile) à des variables non temporaires Justification : Les variables locales d'une fonction ou d'une méthode sont créées sur la pile et elles n'existent que pendant le traitement de la fonction ou de la méthode. Si un pointeur pointe vers ce type de variable après le traitement de la méthode ou de la fonction, vous pouvez utiliser ce pointeur pour accéder à une mémoire indéfinie ou pour accéder à une variable incorrecte dans une autre fonction. Cette situation doit être évitée à tout prix. Importance : Élevée Exemple FUNCTION TempVarInFUNC : DWORD\nVAR\n uiTemp : UINT;\nEND_VAR\n TempVarInFUNC := ADR(uiTemp); \/\/SA0021 PROGRAM PLC_PRG\nVAR\n dwTest : DWORD;\nEND_VAR dwTest := TempVarInFUNC(); Sortie dans le messages voir: SA0021 : Transport de l'adresse de la variable temporaire vers le symbole de portée externe " }, 
{ "title" : "SA0022 : (éventuellement) valeur de retour non attribuée ", 
"url" : "_san_rule_sa0022.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0022 : (éventuellement) valeur de retour non attribuée ", 
"snippet" : "Détecte toutes les fonctions et méthodes qui incluent un thread d'exécution sans affectation à la valeur de retour Justification : Une valeur de retour non affectée dans une fonction ou une méthode est une indication de code manquant. Même si la valeur de retour a toujours une valeur par défaut, il ...", 
"body" : "Détecte toutes les fonctions et méthodes qui incluent un thread d'exécution sans affectation à la valeur de retour Justification : Une valeur de retour non affectée dans une fonction ou une méthode est une indication de code manquant. Même si la valeur de retour a toujours une valeur par défaut, il est toujours utile de la réassigner explicitement pour éviter toute confusion. Importance : Moyenne Exemple FUNCTION FUN : DINT\nVAR_INPUT\n bTest : BOOL;\nEND_VAR\n IF bTest THEN\n RETURN;\nEND_IF\nFUN := 99; Sortie dans le messages voir: SA0022 : (éventuellement) valeur de retour non attribuée " }, 
{ "title" : "SA0023 : valeurs de retour complexes ", 
"url" : "_san_rule_sa0023.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0023 : valeurs de retour complexes ", 
"snippet" : "Détermine les valeurs de retour complexes qui ne peuvent pas être renvoyées avec une simple copie du registre du processeur. Cela inclut les structures, les tableaux et les valeurs de retour de type STRING (quelle que soit la taille de la mémoire utilisée). Justification : Il s'agit d'un avertisseme...", 
"body" : "Détermine les valeurs de retour complexes qui ne peuvent pas être renvoyées avec une simple copie du registre du processeur. Cela inclut les structures, les tableaux et les valeurs de retour de type STRING (quelle que soit la taille de la mémoire utilisée). Justification : Il s'agit d'un avertissement de performance. Si des valeurs importantes sont renvoyées à la suite d'une fonction, d'une méthode ou d'une propriété, le processeur les copie plusieurs fois lors de l'exécution du code. Cela peut entraîner des problèmes d’exécution et doit être évité autant que possible. Les performances peuvent être améliorées en transmettant une valeur structurée comme VAR_IN_OUT à une fonction ou une méthode et en le remplissant dans la fonction ou la méthode. Importance : Moyenne Exemple TYPE LargeStructure :\nSTRUCT\n a : LINT;\n b : BOOL;\nEND_STRUCT\nEND_TYPE\n FUNCTION Large_Return_Value_FUNC : LargeStructure \/\/ SA0023 Sortie dans le messages voir: SA0023 : valeurs de retour complexes " }, 
{ "title" : "SA0024 : Littéraux\/constantes non typés ", 
"url" : "_san_rule_sa0024.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0024 : Littéraux\/constantes non typés ", 
"snippet" : "Identifie les littéraux non typés qui font partie d'une opération Justification : Les littéraux non typés sont automatiquement saisis en fonction de leur utilisation. Dans certains cas, comme dw := ROL(DWORD#1, i); , cela peut conduire à des situations inattendues dans lesquelles il est préférable d...", 
"body" : "Identifie les littéraux non typés qui font partie d'une opération Justification : Les littéraux non typés sont automatiquement saisis en fonction de leur utilisation. Dans certains cas, comme dw := ROL(DWORD#1, i); , cela peut conduire à des situations inattendues dans lesquelles il est préférable d'utiliser un littéral typé afin de fournir une clarification unique. Importance : Faible Exemple PROGRAM PLC_PRG\nVAR\n iTemp1 : INT := 10; \/\/no part of operation\n diTemp2 : DINT;\n liTemp3 : LINT;\n rTemp4 : REAL;\n lrTemp5 : LREAL;\n END_VAR iTemp1 := iTemp1 + INT#34;\ndiTemp2 := diTemp2 + 23; \/\/ SA0024\nliTemp3 := liTemp3 + 124; \/\/ SA0024\nrTemp4 := rTemp4 + 1.1; \/\/ SA0024\nlrTemp5 := lrTemp5 + 3.4; \/\/ SA0024\n Sortie dans le messages voir: SA0024 : littéral non typé trouvé " }, 
{ "title" : "SA0025 : Constantes d'énumération non qualifiées ", 
"url" : "_san_rule_sa0025.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0025 : Constantes d'énumération non qualifiées ", 
"snippet" : "Détecte les constantes d'énumération pour lesquelles un nom qualifié ne précède pas l'énumération Justification : L'accès qualifié rend le code plus lisible et plus facile à maintenir. Sans forcer les noms de variables qualifiées, une énumération supplémentaire pourrait être insérée lors de l'extens...", 
"body" : "Détecte les constantes d'énumération pour lesquelles un nom qualifié ne précède pas l'énumération Justification : L'accès qualifié rend le code plus lisible et plus facile à maintenir. Sans forcer les noms de variables qualifiées, une énumération supplémentaire pourrait être insérée lors de l'extension du programme. Cette énumération contient une constante du même nom qu'une énumération existante (voir l'exemple ci-dessous : \"red\"). Cela entraînerait un accès ambigu à ce morceau de code. Dans tous les cas, nous recommandons de n'utiliser que des énumérations avec le pragma {attribute 'qualified-only'} . Importance : Moyenne Exemple TYPE COLOR :\n (red,\n green,\n blue);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n myColor : COLOR;\nEND_VAR\n myColor := COLOR.red; \/\/ OK\nmyColor := red; \/\/ SA0025 Sortie dans le messages voir: SA0025 : Constante d'énumération 'red' non qualifiée Pour plus d'informations, voir : Configuration et exécution de l'analyse statique " }, 
{ "title" : "SA0026 : Chaînes tronquées possibles ", 
"url" : "_san_rule_sa0026.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0026 : Chaînes tronquées possibles ", 
"snippet" : "Détecte les affectations de chaînes et les initialisations de chaînes qui n'utilisent pas une longueur de chaîne suffisante Justification : lorsque des chaînes de longueurs différentes sont attribuées, une chaîne peut être tronquée. Cela peut avoir des résultats inattendus. Importance : Moyenne Exem...", 
"body" : "Détecte les affectations de chaînes et les initialisations de chaînes qui n'utilisent pas une longueur de chaîne suffisante Justification : lorsque des chaînes de longueurs différentes sont attribuées, une chaîne peut être tronquée. Cela peut avoir des résultats inattendus. Importance : Moyenne Exemple PROGRAM PLC_PRG\nVAR\n strVar1 : STRING[10];\n strVar2 : STRING[6];\n strVar3 : STRING[6] := 'abcdefghi'; \/\/ SA0026\nEND_VAR\n strVar2 := strVar1; \/\/ SA0026 Sortie dans le messages voir: SA0026 : Troncation de 'abcdefghi' SA0026 : Troncation possible de la chaîne 'strVar1' Pour plus d'informations, voir : Configuration et exécution de l'analyse statique " }, 
{ "title" : "SA0027 : Utilisations multiples des identifiants ", 
"url" : "_san_rule_sa0027.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0027 : Utilisations multiples des identifiants ", 
"snippet" : "Détecte les utilisations multiples d'un nom\/identifiant pour une variable ou un objet (POU) dans le cadre d'un projet. Pour les énumérations, le nom qualifié est pris en compte. Justification : Les mêmes noms peuvent prêter à confusion lors de la lecture du code. Ils peuvent provoquer des erreurs en...", 
"body" : "Détecte les utilisations multiples d'un nom\/identifiant pour une variable ou un objet (POU) dans le cadre d'un projet. Pour les énumérations, le nom qualifié est pris en compte. Justification : Les mêmes noms peuvent prêter à confusion lors de la lecture du code. Ils peuvent provoquer des erreurs en cas d'accès accidentel au mauvais objet. Définissez et suivez les conventions de nommage pour éviter toute situation comme celle-ci. Les cas suivants sont détectés : Le nom d'une constante d'énumération est identique au nom d'une autre énumération dans l'application ou dans une bibliothèque liée. Le nom d'une variable est identique au nom d'un autre objet dans l'application ou dans une bibliothèque intégrée. Le nom d'une variable est identique au nom d'une constante d'énumération dans une énumération dans l'application ou dans une bibliothèque intégrée. Le nom d'un objet est identique au nom d'un autre objet dans l'application ou dans une bibliothèque intégrée. Importance : Moyenne Exemple TYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n color : INT;\nEND_VAR\n Sortie dans le messages voir: SA0027 : Le nom de variable 'color' dans 'PLC_PRG' est déjà utilisé pour un objet dans cette application Pour plus d'informations, voir : Configuration et exécution d'une analyse statique " }, 
{ "title" : "SA0028 : chevauchement des zones de mémoire ", 
"url" : "_san_rule_sa0028.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0028 : chevauchement des zones de mémoire ", 
"snippet" : "Détecte les lignes de code où deux ou plusieurs variables réservent la même mémoire. Justification : Lorsque deux variables réservent la même mémoire, le code peut se comporter avec des résultats inattendus. Cette situation doit être évitée à tout prix. Si vous ne pouvez pas éviter d'utiliser une va...", 
"body" : "Détecte les lignes de code où deux ou plusieurs variables réservent la même mémoire. Justification : Lorsque deux variables réservent la même mémoire, le code peut se comporter avec des résultats inattendus. Cette situation doit être évitée à tout prix. Si vous ne pouvez pas éviter d'utiliser une valeur dans différentes interprétations (par exemple, une fois comme DINT et une autre fois comme REAL ), alors vous devez définir un UNION . Vous pouvez également utiliser un pointeur pour accéder à une valeur d'un type différent sans que la valeur soit convertie. Importance : Élevée Exemple PROGRAM PLC_PRG\nVAR\n iVvar1 AT %QB21: INT;\n dwVar2 AT %QD5: DWORD;\nEND_VAR\n Sortie dans le messages voir: Les variables suivantes accèdent à la même mémoire : SA0028 : iVar1 À %QB21 SA0028 : dwVar2 À %QD5 Pour plus d'informations, voir : Configuration et exécution de l'analyse statique " }, 
{ "title" : "SA0029 : Notation en code différente de la déclaration ", 
"url" : "_san_rule_sa0029.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0029 : Notation en code différente de la déclaration ", 
"snippet" : "Détecte les emplacements de code où la notation d'un identifiant est différente de la notation dans sa déclaration Justification : La norme CEI 61131-3 définit les identifiants comme n'étant pas sensibles à la casse. Cela signifie qu'une variable déclarée comme \" varx \" peut également être utilisé c...", 
"body" : "Détecte les emplacements de code où la notation d'un identifiant est différente de la notation dans sa déclaration Justification : La norme CEI 61131-3 définit les identifiants comme n'étant pas sensibles à la casse. Cela signifie qu'une variable déclarée comme \" varx \" peut également être utilisé comme \" VaRx \" dans le code. Cependant, cela prête à confusion et est trompeur et doit être évité. Importance : Moyenne Exemple UNE PLC_PRG POU et un fnc (fonction) POU existe dans l'arborescence des appareils. PROGRAM PLC_PRG\nVAR\n iVar: INT;\n _123test_var_: INT;\nEND_VAR\n ivar := iVar + 1; \/\/ SA0029\n_123TEST_var_ := _123test_var_; \/\/ SA0029\nFnc(); \/\/ SA0029 Sortie dans le messages voir: SA0029 : La notation dans le code (ivar) doit être égale à la déclaration (iVar) SA0029 : La notation dans le code (_123TEST_var_) doit être égale à la déclaration (_123test_var_) SA0029 : La notation dans le code (Fnc) doit être égale à la déclaration (fnc) Pour plus d'informations, voir : Configuration et exécution d'une analyse statique " }, 
{ "title" : "Objets inutilisés ", 
"url" : "_san_list_unused_objects.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Objets inutilisés ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0031 : Signatures non utilisées ", 
"url" : "_san_rule_sa0031.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Objets inutilisés \/ SA0031 : Signatures non utilisées ", 
"snippet" : "Détecte les programmes, les blocs fonctionnels, les fonctions, les types de données, les interfaces, les méthodes, les propriétés et les actions qui ne sont pas appelées dans le code de programme compilé Justification : Les objets inutilisés augmentent inutilement la taille du projet et peuvent prêt...", 
"body" : "Détecte les programmes, les blocs fonctionnels, les fonctions, les types de données, les interfaces, les méthodes, les propriétés et les actions qui ne sont pas appelées dans le code de programme compilé Justification : Les objets inutilisés augmentent inutilement la taille du projet et peuvent prêter à confusion lors de la lecture du code. Importance : faible Règle PLCopen : CP2 Si plusieurs applications existent dans un projet, seuls les objets sous les applications actuellement actives sont affectés. S'il n'y a qu'une seule application, les objets du pool de POU sont également affectés. Voir également Configuration et exécution de l'analyse statique " }, 
{ "title" : "SA0032 : Constantes d'énumération inutilisées ", 
"url" : "_san_rule_sa0032.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Objets inutilisés \/ SA0032 : Constantes d'énumération inutilisées ", 
"snippet" : "Détecte les constantes d'énumération qui ne sont pas utilisées dans le code du programme compilé Justification : Les constantes d'énumération non utilisées augmentent inutilement la taille de la définition d'énumération et peuvent prêter à confusion lors de la lecture du programme. Règle PLCopen : C...", 
"body" : "Détecte les constantes d'énumération qui ne sont pas utilisées dans le code du programme compilé Justification : Les constantes d'énumération non utilisées augmentent inutilement la taille de la définition d'énumération et peuvent prêter à confusion lors de la lecture du programme. Règle PLCopen : CP24 Importance : Faible Si plusieurs applications existent dans un projet, seuls les objets sous les applications actuellement actives sont affectés. S'il n'y a qu'une seule application, les objets du pool de POU commun sont également affectés. Exemple TYPE My_Enum :\n(\n one := 1, \n two := 2\n);\nEND_TYPE\n Sortie dans le messages voir: SA0032 : constante d'énumération inutilisée 'one' SA0032 : constante d'énumération \"two\" inutilisée Pour plus d'informations, voir : Configuration et exécution d'une analyse statique " }, 
{ "title" : "SA0033 : variables inutilisées ", 
"url" : "_san_rule_sa0033.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Objets inutilisés \/ SA0033 : variables inutilisées ", 
"snippet" : "Détecte les variables déclarées mais non utilisées dans le code du programme compilé Justification : Les variables non utilisées rendent un programme moins lisible et moins maintenable. Les variables inutilisées remplissent inutilement la mémoire et gaspillent inutilement du temps d'exécution lors d...", 
"body" : "Détecte les variables déclarées mais non utilisées dans le code du programme compilé Justification : Les variables non utilisées rendent un programme moins lisible et moins maintenable. Les variables inutilisées remplissent inutilement la mémoire et gaspillent inutilement du temps d'exécution lors de l'initialisation. Importance : Moyenne Règle PLCopen : CP22 \/ CP24 Pour les variables GVL : si plusieurs applications existent dans un projet, seuls les objets situés sous l'application actuellement active sont pris en compte. S'il n'y a qu'une seule application, les objets du pool de POU commun sont également pris en compte. Exemple PROGRAM PLC_PRG\nVAR\n iCounter1 : INT;\n iCounter2 : INT; \/\/ SA0033\nEND_VAR\n iCounter1 := 100; Sortie dans le messages voir: SA0033 : Variable non utilisée « iCounter2 » Pour plus d'informations, voir : Configuration et exécution d'une analyse statique " }, 
{ "title" : "SA0035 : Variables d'entrée inutilisées ", 
"url" : "_san_rule_sa0035.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Objets inutilisés \/ SA0035 : Variables d'entrée inutilisées ", 
"snippet" : "Détecte les variables d'entrée qui ne sont utilisées par aucune instance de bloc fonction Justification : Les variables d'entrée non utilisées rendent un programme moins lisible et moins facile à gérer. Les variables inutilisées remplissent inutilement la mémoire et gaspillent inutilement du temps d...", 
"body" : "Détecte les variables d'entrée qui ne sont utilisées par aucune instance de bloc fonction Justification : Les variables d'entrée non utilisées rendent un programme moins lisible et moins facile à gérer. Les variables inutilisées remplissent inutilement la mémoire et gaspillent inutilement du temps d'exécution lors Une entrée est considérée comme utilisée uniquement si elle est activement référencée dans l'implémentation (ou les méthodes) de l'instance de bloc fonctionnel elle-même. Importance : Moyenne Règle PLCopen : CP24 Exemple FUNCTION_BLOCK FB_Afb\nVAR_INPUT\n iIn1: INT;\n iIn2: INT;\nEND_VAR\nVAR_OUTPUT\n iOut1: INT;\nEND_VAR iOut1 := iIn1; \/\/ iIn1 is used here PROGRAM PLC_PRG\nVAR\n fbAfb: FB_Afb;\nEND_VAR\n fbAfb(iIn2 := 99); \/\/ iIn2 is unused internally => error Sortie dans le messages voir: SA0035 : Entrée inutilisée 'iIn2' " }, 
{ "title" : "SA0036 : Variables de sortie inutilisées ", 
"url" : "_san_rule_sa0036.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Objets inutilisés \/ SA0036 : Variables de sortie inutilisées ", 
"snippet" : "Détermine les variables de sortie des fonctions et des blocs fonctionnels qui ne sont pas affectés dans la fonction ou le bloc fonctionnel concerné. Justification : Les variables non utilisées rendent un programme moins lisible et moins maintenable. Les variables inutilisées remplissent inutilement ...", 
"body" : "Détermine les variables de sortie des fonctions et des blocs fonctionnels qui ne sont pas affectés dans la fonction ou le bloc fonctionnel concerné. Justification : Les variables non utilisées rendent un programme moins lisible et moins maintenable. Les variables inutilisées remplissent inutilement la mémoire et gaspillent inutilement du temps d'exécution lors de l'initialisation. Importance : Moyenne Règle PLCopen : CP24 Exemple FUNCTION_BLOCK FB_Afb\nVAR_INPUT\n iIn1: INT;\n iIn2: INT;\nEND_VAR\nVAR_OUTPUT\n iOut1: INT;\n iOut2: INT;\nEND_VAR\n iOut1 := iIn1 + iIn2; Sortie dans le messages voir: SA0036 : Sortie inutilisée 'iOut1' " }, 
{ "title" : "SA0034 : Énumérations avec une affectation incorrecte ", 
"url" : "_san_rule_sa0034.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0034 : Énumérations avec une affectation incorrecte ", 
"snippet" : "Détecte les valeurs affectées à une variable d'énumération. Seules les constantes d'énumération définies d'une variable d'énumération peuvent être affectées. Justification : Une variable de type énumération ne doit avoir que les valeurs prévues, sinon le code qui utilise cette variable risque de ne ...", 
"body" : "Détecte les valeurs affectées à une variable d'énumération. Seules les constantes d'énumération définies d'une variable d'énumération peuvent être affectées. Justification : Une variable de type énumération ne doit avoir que les valeurs prévues, sinon le code qui utilise cette variable risque de ne pas fonctionner correctement. Nous recommandons de toujours utiliser les énumérations avec le pragma {attribute 'strict'} . Ensuite, le compilateur vérifie déjà la bonne utilisation des composants d'énumération. Importance : Élevée Exemple TYPE COLOR :\n(\n Red := 0,\n Green,\n Yellow\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n eColor1: COLOR;\nEND_VAR\n eColor1 := COLOR.Red;\neColor1 := 1; \/\/ SA0034 Sortie dans le messages voir: SA0034 : Utiliser la valeur d'énumération au lieu de 'INT#1' Pour plus d'informations, voir : Configuration et exécution d'une analyse statique " }, 
{ "title" : "SA0037 : Accès en écriture à la variable d'entrée ", 
"url" : "_san_rule_sa0037.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0037 : Accès en écriture à la variable d'entrée ", 
"snippet" : "Détecte les variables d'entrée ( VAR_INPUT ) auxquels on accède avec une autorisation d'écriture dans le POU Justification : Selon la norme CEI 61131-3, une variable d'entrée ne doit pas être modifiée au sein d'une POU. Ce type d'accès est également source d'erreurs et rend le code peu maintenable. ...", 
"body" : "Détecte les variables d'entrée ( VAR_INPUT ) auxquels on accède avec une autorisation d'écriture dans le POU Justification : Selon la norme CEI 61131-3, une variable d'entrée ne doit pas être modifiée au sein d'une POU. Ce type d'accès est également source d'erreurs et rend le code peu maintenable. Ceci indique qu'une variable est utilisée à la fois comme variable d'entrée et comme variable auxiliaire. Ce type de double usage doit être évité. Importance : Moyenne Exemple VAR_GLOBAL\n g_xGlob AT %QX0.0 : BOOL;\nEND_VAR PROGRAM PLC_PRG\nVAR_INPUT\n xVarIn1 : BOOL;\n xVarIn2 : BOOL;\nEND_VAR\nVAR\n iCondition : INT;\nEND_VAR\n iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n g_xGlob := xVarIn1;\n INT#2:\n g_xGlob := xVarIn2;\n ELSE\n g_xGlob := FALSE;\n xVarIn1 := FALSE; \/\/ SA0037\nEND_CASE Sortie dans le messages voir: SA0037 : Accès en écriture à la variable d'entrée 'xVarIn1' " }, 
{ "title" : "SA0038 : Accès en lecture à la variable de sortie ", 
"url" : "_san_rule_sa0038.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0038 : Accès en lecture à la variable de sortie ", 
"snippet" : "Détecte les variables de sortie ( VAR_OUTPUT ) auxquels on accède avec une autorisation de lecture dans le POU Justification : Selon la norme CEI 61131-3, il est interdit de lire une sortie au sein d'une POU. Ceci indique que la sortie n'est pas seulement utilisée comme sortie mais aussi comme varia...", 
"body" : "Détecte les variables de sortie ( VAR_OUTPUT ) auxquels on accède avec une autorisation de lecture dans le POU Justification : Selon la norme CEI 61131-3, il est interdit de lire une sortie au sein d'une POU. Ceci indique que la sortie n'est pas seulement utilisée comme sortie mais aussi comme variable temporaire pour les résultats intermédiaires. Ce type de double usage doit être évité. Importance : Faible Exemple VAR_GLOBAL\n g_xGlob AT %QX0.0 : BOOL ;\n g_iGlob AT %QW1 : INT ;\nEND_VAR PROGRAM PLC_PRG\nVAR_OUTPUT\n xVarOut1:BOOL;\n xVarOut2:INT;\n xVarOut3:INT;\nEND_VAR\nVAR\n iCondition : INT;\nEND_VAR iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n xVarOut1 := g_xGlob;\n xVarOut2 := g_iGlob;\n INT#2:\n xVarOut3 := xVarOut2; \/\/ SA0038\n ELSE\n xVarOut1 := FALSE;\n g_xGlob := xVarOut1; \/\/ SA0038\n xVarOut2 := INT#0;\n xVarOut3 := INT#-1;\nEND_CASE Sortie dans le messages voir: SA0038 : Accès en lecture à la variable de sortie 'xVarOUT2' SA0026 : SA0038 : Accès en lecture à la variable de sortie 'xVarOUT1' " }, 
{ "title" : "SA0040 : Possible division par zéro ", 
"url" : "_san_rule_sa0040.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0040 : Possible division par zéro ", 
"snippet" : "Détecte les emplacements de code où il y a une division possible par zéro Justification : Division par 0 entraîne une erreur. Une variable à diviser doit toujours être vérifiée en premier pour 0. Importance : Élevée Exemple VAR_GLOBAL g_iVar AT %QW1 : INT; END_VAR PROGRAM PLC_PRG VAR iCounter : INT;...", 
"body" : "Détecte les emplacements de code où il y a une division possible par zéro Justification : Division par 0 entraîne une erreur. Une variable à diviser doit toujours être vérifiée en premier pour 0. Importance : Élevée Exemple VAR_GLOBAL\n g_iVar AT %QW1 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n iCounter : INT;\n iSumme:INT;\n iMid:INT;\n iVal1:INT := INT#2;\n iVal2:INT;\n iVal3:INT := INT#3;\n iVal4:INT := INT#4;\n iVal5:INT;\nEND_VAR IF iVal2 <> 0 THEN\n iVal1 := iVal1\/iVal2; \/\/ no error\nEND_IF;\niMid := iSumme \/ iCounter; \/\/ SA0040\niCounter := iCounter + INT#1;\niSumme := g_iVar + iSumme;\nIF iMid < INT#100 THEN\n iVal1 := iVal1 \/ iVal2; \/\/ SA0040\nEND_IF Sortie dans le messages voir: SA0040 : Division possible par zéro SA0040 : Division possible par zéro " }, 
{ "title" : "SA0041 : détecter un éventuel code invariant de boucle ", 
"url" : "_san_rule_sa0041.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0041 : détecter un éventuel code invariant de boucle ", 
"snippet" : "Détecte les affectations dans les boucles qui calculent la même valeur pour chaque cycle de boucle. De telles lignes de code pourraient être insérées en dehors de la boucle. Justification : Il s'agit d'un avertissement de performance. Le code qui est exécuté dans une boucle, mais qui fait la même ch...", 
"body" : "Détecte les affectations dans les boucles qui calculent la même valeur pour chaque cycle de boucle. De telles lignes de code pourraient être insérées en dehors de la boucle. Justification : Il s'agit d'un avertissement de performance. Le code qui est exécuté dans une boucle, mais qui fait la même chose à chaque cycle de boucle, peut être exécuté en dehors de la boucle. Importance : Moyenne Exemple PROGRAM PLC_PRG\nVAR\n iCounter, iVar1, iVar2 : INT;\nEND_VAR FOR iCounter := 0 TO 10 DO\n iVar1 := 100; \/\/ SA0041\n iVar2 := iVar2 + iVar1;\nEND_FOR\n Sortie dans le messages voir: SAN0041 : Code invariant de boucle possible 'iVar1 := 100' " }, 
{ "title" : "SA0042 : Utilisation de différents chemins d'accès ", 
"url" : "_san_rule_sa0042.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0042 : Utilisation de différents chemins d'accès ", 
"snippet" : "Détecte l'utilisation de différents chemins d'accès pour la même variable Justification : Des accès différents à un même élément diminuent la lisibilité et la maintenabilité d'un programme. Nous recommandons l'utilisation régulière de {attribute 'qualified-only'} pour les bibliothèques, les listes d...", 
"body" : "Détecte l'utilisation de différents chemins d'accès pour la même variable Justification : Des accès différents à un même élément diminuent la lisibilité et la maintenabilité d'un programme. Nous recommandons l'utilisation régulière de {attribute 'qualified-only'} pour les bibliothèques, les listes de variables globales et les énumérations. Cela force un accès entièrement qualifié. Importance : faible Exemple VAR_GLOBAL\n iTemp:INT;\n instPOU:POU;\nEND_VAR FUNCTION_BLOCK POU\nVAR\n a:INT;\nEND_VAR\n a := INT#1; PROGRAM SA0042\nVAR\n ptiTemp:POINTER TO INT;\n sTemp:STRING;\nEND_VAR ptiTemp := ADR(iTemp);\n\nptiTemp^ := INT#1;\niTemp := INT#2; \/\/ SA0042 - direct access on variable\nGVL.iTemp := INT#3; \/\/ SA0042 - access on variable via GVL\n\nsTemp := CONCAT( 'ab', 'cd'); \/\/ SA0042 - direct access on function\nsTemp := Standard.CONCAT( 'ab', 'cd'); \/\/ SA0042 - access on function via Standard\n\ninstPOU(); \/\/ SA0042 - direct access on POU instance\nGVL.instPOU(); \/\/ SA0042 - access via GVL\n Sortie dans le messages voir: SA0042 : Différents chemins d'accès pour 'CONCAT' SA0042 : Différents chemins d'accès pour 'Standard.CONCAT' SA0042 : Différents chemins d'accès pour 'instPOU' SA0042 : Différents chemins d'accès pour 'GVL.instPOU' SA0042 : Différents chemins d'accès pour 'iTemp' SA0042 : Différents chemins d'accès pour 'GVL.iTemp' " }, 
{ "title" : "SA0043 : Utilisation d'une variable globale dans un seul POU ", 
"url" : "_san_rule_sa0043.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0043 : Utilisation d'une variable globale dans un seul POU ", 
"snippet" : "Détecte l'utilisation d'une variable globale dans un seul POU Justification : Une variable globale utilisée à un seul emplacement ne doit également être déclaré qu'à cet emplacement. Importance : Moyenne Règle PLCopen : CP26 Exemple VAR_GLOBAL g_xVar AT %QX0.0 : BOOL ; g_iTest AT %QW1 : INT ; g_wTes...", 
"body" : "Détecte l'utilisation d'une variable globale dans un seul POU Justification : Une variable globale utilisée à un seul emplacement ne doit également être déclaré qu'à cet emplacement. Importance : Moyenne Règle PLCopen : CP26 Exemple VAR_GLOBAL\n g_xVar AT %QX0.0 : BOOL ;\n g_iTest AT %QW1 : INT ;\n g_wTest AT %QW2 : WORD;\nEND_VAR PROGRAM prog1\nVAR\n iCondition : INT;\n bTemp : BOOL;\nEND_VAR\n iCondition := iCondition + INT#1;\nIF iCondition < INT#0 THEN\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\n ELSIF iCondition = INT#0 THEN\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\nELSE\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\n g_wTest := WORD#4; \/\/ g_WTest used also in prog2 -> OK\nEND_IF PROGRAM prog2\nVAR\n iCondition : INT;\nEND_VAR\n iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n g_iTest := WORD_TO_INT(g_wTest); \/\/ SA0043 - g_iTest only written in this POU\n INT#2:\n g_iTest := INT#2; \/\/ SA0043 - g_iTest only written in this POU\n ELSE\n g_iTest := INT#3; \/\/ SA0043 - g_iTest only written in this POU\nEND_CASE Sortie dans le messages voir: SA0043 : Variable globale 'g_xVar' utilisée uniquement dans 'prog1' SA0043 : Variable globale 'g_iTest' utilisée uniquement dans 'prog2' " }, 
{ "title" : "SA0044 : Déclarations avec référence à l'interface ", 
"url" : "_san_rule_sa0044.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0044 : Déclarations avec référence à l'interface ", 
"snippet" : "Détecte les déclarations avec REFERENCE TO interfaces et déclarations de VAR_IN_OUT variables avec interfaces (implémentées implicitement au moyen de REFERENCE TO ) Justification : Un type d'interface est toujours implicitement une référence à une instance d'un bloc fonction qui implémente cette int...", 
"body" : "Détecte les déclarations avec REFERENCE TO interfaces et déclarations de VAR_IN_OUT variables avec interfaces (implémentées implicitement au moyen de REFERENCE TO ) Justification : Un type d'interface est toujours implicitement une référence à une instance d'un bloc fonction qui implémente cette interface. Une référence à une interface est donc une référence à une référence et peut entraîner un comportement indésirable. Importance : Élevée Exemple ITF est une interface définie dans le projet. FUNCTION_BLOCK POU\nVAR_INPUT\n inst_itf2 : ITF;\nEND_VAR\nVAR_OUTPUT\n inst_itf3 : ITF;\nEND_VAR\nVAR_IN_OUT\n inst_itf4 : ITF; \/\/ SA0044\nEND_VAR\n PROGRAM PLC_PRG\nVAR\n inst : POU;\n itf_inst1 : ITF;\n itf_ref : REFERENCE TO ITF; \/\/ SA0044\nEND_VAR Sortie dans le messages voir: SA0044 : Référence à l'interface 'itf4_ref' SA0044 : Référence à l'interface 'itf_ref' " }, 
{ "title" : "Conversions ", 
"url" : "_san_conversion.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Conversions ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0019 : Conversions de pointeurs implicites ", 
"url" : "_san_rule_sa0019.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Conversions \/ SA0019 : Conversions de pointeurs implicites ", 
"snippet" : "Détecte les conversions de pointeur générées implicitement Justification : Dans CODESYS , les pointeurs ne sont pas strictement saisis et peuvent être attribués les uns aux autres de n'importe quelle manière. Ceci est souvent utilisé et n'est donc pas indiqué par le compilateur. Cependant, cela peut...", 
"body" : "Détecte les conversions de pointeur générées implicitement Justification : Dans CODESYS , les pointeurs ne sont pas strictement saisis et peuvent être attribués les uns aux autres de n'importe quelle manière. Ceci est souvent utilisé et n'est donc pas indiqué par le compilateur. Cependant, cela peut également entraîner un accès non autorisé et inattendu. Par exemple, si vous attribuez le type POINTER TO DWORD vers un pointeur avec le type POINTER TO BYTE , la mémoire peut être écrasée de manière indésirable. Par conséquent, vérifiez toujours cette règle et bloquez le message uniquement dans les cas où vous souhaitez intentionnellement accéder à une valeur d'un type différent. Conversions depuis et vers le POINTER TO BYTE les types de données ne sont pas vérifiés par la règle SA0019. Ils sont toujours autorisés. Les conversions de type de données implicites sont signalées avec un message différent. Importance : Élevée Règle PLCopen : CP25 Exception: BOOL <-> BIT Exemple PROGRAM PLC_PRG\nVAR\n pInt : POINTER TO INT;\n byteVar : BYTE;\nEND_VAR\n pInt := ADR(byteVar); Sortie dans le messages voir: SA0019 : Conversion implicite du pointeur vers 'POINTER TO BYTE' en pointeur vers 'POINTER TO INT' " }, 
{ "title" : "SA0130 : Conversions à expansion implicite ", 
"url" : "_san_rule_sa0130.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Conversions \/ SA0130 : Conversions à expansion implicite ", 
"snippet" : "Détecte les emplacements de code où les conversions de types de données plus petits vers des types de données plus grands sont implicitement effectuées lors d'opérations arithmétiques Justification : Le compilateur autorise toute affectation de types différents lorsque la plage de valeurs du type so...", 
"body" : "Détecte les emplacements de code où les conversions de types de données plus petits vers des types de données plus grands sont implicitement effectuées lors d'opérations arithmétiques Justification : Le compilateur autorise toute affectation de types différents lorsque la plage de valeurs du type source est entièrement contenue dans la plage de valeurs du type cible. Cependant, le compilateur effectuera une conversion dans le code le plus tard possible. Pour une mission de type lint := dint * dint , le compilateur effectue la conversion implicite uniquement après multiplication : lint := TO_LINT(dint * dint); Un débordement est donc tronqué. Si vous souhaitez éviter cela, vous pouvez déjà convertir les éléments : lint := TO_LINT(dint) * TO_LINT(dint); Par conséquent, il peut être utile de signaler les emplacements où le compilateur implémente des conversions implicites afin de vérifier si celles-ci correspondent exactement à ce qui est prévu. De plus, des conversions explicites peuvent être utilisées pour améliorer la portabilité vers d'autres systèmes lorsque ces systèmes ont des vérifications de type plus restrictives. Importance : Faible Exemple PROGRAM PLC_PRG\nVAR\n d : DINT;\n l : LINT;\n ui : UINT;\n uli : ULINT;\n usi : USINT;\n lw : LWORD;\n udi : UDINT;\n lr : LREAL;\n b : BYTE;\nEND_VAR\n (*The following lines could result in unwanted truncating by implicit conversions \nand should be reported with SA0130*) \nl := d * d;\nuli := usi * usi;\nlw := udi * udi;\nlr := b * b;\nd := ui * ui; Sortie dans le messages voir: SA0130 : Conversión á expansión implícita de tipo 'DINT' a tipo 'LINT' SA0130 : Conversión á expansión implícita de tipo 'DINT' a tipo 'LINT' SA0130 : Conversión á expansión implícita de tipo 'DINT' a tipo 'LINT' SA0130 : Conversión á expansión implícita de tipo 'DINT' a tipo 'LINT' SA0130 : Conversión á expansión implícita de tipo 'DINT' a tipo 'LINT' " }, 
{ "title" : "SA0133 : Conversions restrictives explicites ", 
"url" : "_san_rule_sa0133.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Conversions \/ SA0133 : Conversions restrictives explicites ", 
"snippet" : "Détecte les conversions explicites d'un type de données plus grand vers un type de données plus petit Justification : Un grand nombre de conversions de type peut indiquer que vous avez choisi les mauvais types de données pour les variables. Pour cette raison, il existe des directives de programmatio...", 
"body" : "Détecte les conversions explicites d'un type de données plus grand vers un type de données plus petit Justification : Un grand nombre de conversions de type peut indiquer que vous avez choisi les mauvais types de données pour les variables. Pour cette raison, il existe des directives de programmation qui exigent une justification explicite des conversions de types de données. Importance : faible Exemple PROGRAM SA0133\nVAR\n siVar:SINT;\n diVar:DINT;\n liVar:LINT;\n byVar:BYTE;\n uiVar:UINT;\n dwVar:DWORD;\n lwVar:LWORD;\n rVar:REAL;\n lrVar:LREAL;\nEND_VAR\n siVar := LINT_TO_SINT(liVar); \/\/ SA0133\nbyVar := DINT_TO_BYTE(diVar); \/\/ SA0133\nsiVar := DWORD_TO_SINT(dwVar); \/\/ SA0133\nuiVar := LREAL_TO_UINT(lrVar); \/\/ SA0133\nrVar := LWORD_TO_REAL(lwVar); \/\/ SA0133 Sortie dans le messages voir: SA0133 : Conversion restrictive explicite du type « LINT » au type « SINT » SA0133 : Conversion restrictive explicite du type « DINT » au type « BYTE » SA0133 : conversions restrictives explicites du type « DWORD » vers le type « SINT » SA0133 : Conversion restrictive explicite du type « LREAL » au type « UINT » SA0133 : conversion restrictive explicite du type « LWORD » vers le type « REAL » " }, 
{ "title" : "SA0134 : Conversions explicites signées\/non signées ", 
"url" : "_san_rule_sa0134.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Conversions \/ SA0134 : Conversions explicites signées\/non signées ", 
"snippet" : "Détecte les conversions explicites de types de données signés en types de données non signés et inversement Justification : L'utilisation excessive de conversions de types peut indiquer que des types de données incorrects pour les variables ont été sélectionnés. Pour cette raison, il existe des dire...", 
"body" : "Détecte les conversions explicites de types de données signés en types de données non signés et inversement Justification : L'utilisation excessive de conversions de types peut indiquer que des types de données incorrects pour les variables ont été sélectionnés. Pour cette raison, il existe des directives de programmation qui exigent une justification explicite des conversions de types de données. Importance : Faible Exemple PROGRAM PLC_PRG\nVAR\n byVar :BYTE;\n udiVar : UDINT;\n uliVar : ULINT;\n lwVar : LWORD;\n wVar : WORD;\n siVar : SINT;\n iVar : INT;\n diVar : DINT;\n liVar : LINT;\nEND_VAR\n liVar := ULINT_TO_LINT(uliVar);\nudiVar := DINT_TO_UDINT(diVar);\nsiVar := BYTE_TO_SINT(byVar);\nwVar := INT_TO_WORD(iVar);\nlwVar := SINT_TO_LWORD(siVar); Sortie dans le messages voir: SA0134 : Conversion explicite signée\/non signée du type « ULINT » vers le type « LINT » SA0134 : Conversion explicite signée\/non signée du type 'DINT' au type 'UDINT' SA0134 : Conversion explicite signée\/non signée du type 'BYTE' au type 'SINT' SA0134 : Conversion explicite signée\/non signée du type 'INT' au type 'WORD' SA0134 : Conversion explicite signée\/non signée du type 'SINT' au type 'LWORD' " }, 
{ "title" : "Utilisation des adresses directes ", 
"url" : "_san_use_direct_adresses.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Utilisation des adresses directes ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0005 : Adresses et types de données non valides ", 
"url" : "_san_rule_sa0005.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Utilisation des adresses directes \/ SA0005 : Adresses et types de données non valides ", 
"snippet" : "Détecte les adresses non valides et les spécifications de type de données. Préfixes de taille valides dans les adresses : X pour BOOL B pour les types de données à 1 octet, W pour les types de données à 2 octets et D pour les types de données à 4 octets. Justification : Les variables situées sur des...", 
"body" : "Détecte les adresses non valides et les spécifications de type de données. Préfixes de taille valides dans les adresses : X pour BOOL B pour les types de données à 1 octet, W pour les types de données à 2 octets et D pour les types de données à 4 octets. Justification : Les variables situées sur des adresses directes doivent de préférence être associées à une adresse correspondant à leur largeur de type de données. Cela peut être déroutant pour le lecteur du code, par exemple, si un DWORD est attribué à un BYTE adresse. Importance : Faible Exemple PROGRAM Check_Address_Type_PRG\nVAR\n iVar AT %QB0 : INT ; \/\/ OK e. g.: %QW0\n xTest AT %QW1 : BOOL ; \/\/ OK e. g.: %QX1.0\nEND_VAR iVar := iVar + INT#1;\nxTest := NOT xTest;\n Sortie dans le messages voir: SA0005 : Adresse invalide pour le type de données « iVar » Pour plus d'informations, voir : Configuration et exécution de l'analyse statique " }, 
{ "title" : "SA0047 : Accès à l'adresse directe ", 
"url" : "_san_rule_sa0047.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Utilisation des adresses directes \/ SA0047 : Accès à l'adresse directe ", 
"snippet" : "Détecte l'accès direct à l'adresse dans le code d'implémentation Justification : La programmation symbolique est toujours préférable. Une variable a un nom qui peut aussi avoir une signification. Une adresse ne peut pas indiquer à quoi elle sert. Importance : Élevée Règle PLCopen : N1 \/ CP1 Exemple ...", 
"body" : "Détecte l'accès direct à l'adresse dans le code d'implémentation Justification : La programmation symbolique est toujours préférable. Une variable a un nom qui peut aussi avoir une signification. Une adresse ne peut pas indiquer à quoi elle sert. Importance : Élevée Règle PLCopen : N1 \/ CP1 Exemple PROGRAM PLC_PRG\nVAR\n xVar : BOOL;\n byVar : BYTE;\nEND_VAR\n xVar := %IX0.0;\n%QX0.0 := xVar;\n%MX0.1 := xVar;\n%MB1 := byVar; Sortie dans le messages voir: SA0047 : Accès à l'adresse directe '%IX0.0' SA0026 : Accès à l'adresse directe '%QX0.0' SA0026 : Accès à l'adresse directe '%MX0.1' SA0026 : Accès à l'adresse directe '%MB1' " }, 
{ "title" : "SA0048 : Déclarations AT sur les adresses directes ", 
"url" : "_san_rule_sa0048.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Utilisation des adresses directes \/ SA0048 : Déclarations AT sur les adresses directes ", 
"snippet" : "Détecte AT déclarations sur les adresses directes L'utilisation d'adresses directes dans le code est problématique car l'adresse apparaît alors à plusieurs endroits : D’abord dans la configuration du contrôleur où est définie l’affectation d’un objet physique à une adresse Deuxième dans le programme...", 
"body" : "Détecte AT déclarations sur les adresses directes L'utilisation d'adresses directes dans le code est problématique car l'adresse apparaît alors à plusieurs endroits : D’abord dans la configuration du contrôleur où est définie l’affectation d’un objet physique à une adresse Deuxième dans le programme où les variables sont affectées à ces adresses. Si les adresses sont déplacées parce que la configuration est modifiée, vous devez alors réaffecter les variables aux adresses situées à un emplacement complètement différent dans le programme. Ceci est une cause d’erreur et entraîne une moins bonne lisibilité et maintenabilité du code. Il est donc préférable d'effectuer toutes les affectations dans le mappage E\/S de l'éditeur d'appareils. Importance : Élevée Règle PLCopen : N1 \/ CP1 Nous vous recommandons d'utiliser des adresses directes UNIQUEMENT dans le Mappage d'E\/S de l'éditeur d'appareils. Exemple PROGRAM PLC_PRG\nVAR\n xVar1 AT %IX0.0 : BOOL;\n byVar1 AT %IB1 : BYTE;\n xVar2 AT %QX0.0 : BOOL;\nEND_VAR\n Sortie dans le messages voir: SA0048 : La déclaration utilise l'adresse directe '%IX0.0' SA0048 : La déclaration utilise l'adresse directe '%IB1' SA0048 : La déclaration utilise l'adresse directe '%QX0.0' " }, 
{ "title" : "Règles pour les opérateurs ", 
"url" : "_san_rule_operators.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les opérateurs ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0051 : Opérations de comparaison sur les variables BOOL ", 
"url" : "_san_rule_sa0051.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les opérateurs \/ SA0051 : Opérations de comparaison sur les variables BOOL ", 
"snippet" : "Détecte les opérations de comparaison sur les variables de type BOOL Justification : CODESYS permet ce genre de comparaisons. Mais ils sont très inhabituels et peuvent prêter à confusion. La norme CEI 61131-3 ne prévoit pas ces comparaisons. En les évitant, vous augmentez la portabilité du code vers...", 
"body" : "Détecte les opérations de comparaison sur les variables de type BOOL Justification : CODESYS permet ce genre de comparaisons. Mais ils sont très inhabituels et peuvent prêter à confusion. La norme CEI 61131-3 ne prévoit pas ces comparaisons. En les évitant, vous augmentez la portabilité du code vers d'autres systèmes de développement. Importance : Moyenne Exemple PROGRAM PLC_PRG\nVAR\n xBool1, xBool2 : BOOL;\n xResult : BOOL;\nEND_VAR\n xResult := xBool1 > xBool2; \/\/ SA0051\nxBool1 := NOT xBool1; \/\/ OK!\nxBool2 := xBool2 XOR xBool1; \/\/ OK! Sortie dans le messages voir: SA0051 : Opérations de comparaison sur les variables BOOL " }, 
{ "title" : "SA0052 : Opération de changement de vitesse inhabituelle ", 
"url" : "_san_rule_sa0052.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les opérateurs \/ SA0052 : Opération de changement de vitesse inhabituelle ", 
"snippet" : "Détecte les opérations de décalage (décalage de bit) sur les variables signées. Dans le cas d'opérations de décalage sur des types de données de champ binaire ( Byte , DWORD , LWORD , WORD ), aucune erreur n'est signalée. Justification : CODESYS permet les opérations de décalage sur les types de don...", 
"body" : "Détecte les opérations de décalage (décalage de bit) sur les variables signées. Dans le cas d'opérations de décalage sur des types de données de champ binaire ( Byte , DWORD , LWORD , WORD ), aucune erreur n'est signalée. Justification : CODESYS permet les opérations de décalage sur les types de données signés. Cependant, ces opérations sont inhabituelles et peuvent prêter à confusion. La norme CEI 61131-3 ne prévoit pas ce type d'opérations. Il convient donc de les éviter afin d’augmenter la portabilité du code vers d’autres systèmes de développement. Importance : Moyenne Exemple PROGRAM PLC_PRG\nVAR\n iTemp : INT;\n dwTemp1 : DWORD;\n byTemp2 : BYTE;\n diTemp3 : DINT;\n siTemp4 : SINT;\n liTemp5 : LINT;\nEND_VAR\n \/\/the following lines each will cause an SA0052:\niTemp := SHL(iTemp, BYTE#2);\ndiTemp3 := SHR(diTemp3, BYTE#4);\nsiTemp4 := ROL(siTemp4, BYTE#2);\nliTemp5 := ROR(liTemp5, BYTE#2);\n\n\/\/no error SA0052 because DWORD and BYTE are bitfield datatypes:\ndwTemp1 := SHL(dwTemp1, BYTE#3);\nbyTemp2 := SHR(byTemp2, BYTE#1); Sortie dans le messages voir: SA0052 : Opération de changement de vitesse inhabituelle " }, 
{ "title" : "SA0053 : Décalage binaire trop important ", 
"url" : "_san_rule_sa0053.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les opérateurs \/ SA0053 : Décalage binaire trop important ", 
"snippet" : "Détecte si oui ou non la largeur du type de données de l'opérande a été dépassée dans le cas d'un décalage binaire (décalage binaire) des opérandes Justification : Si une opération de décalage dépasse la largeur du type de données, une constante 0 est généré. Si un décalage de rotation dépasse la la...", 
"body" : "Détecte si oui ou non la largeur du type de données de l'opérande a été dépassée dans le cas d'un décalage binaire (décalage binaire) des opérandes Justification : Si une opération de décalage dépasse la largeur du type de données, une constante 0 est généré. Si un décalage de rotation dépasse la largeur du type de données, il est difficile à lire et la valeur de rotation doit donc être tronquée. Importance : Élevée Exemple PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\n wTemp2 : WORD;\n dwTemp3 : DWORD;\n lwTemp4 : LWORD;\nEND_VAR\n byTemp1 := SHR(byTemp1, BYTE#25);\nwTemp2 := SHL(wTemp2, BYTE#45);\ndwTemp3 := ROR(dwTemp3, BYTE#78);\nlwTemp4 := ROL(lwTemp4, BYTE#111); Sortie dans le messages voir: SA0053 : Décalage au niveau du bit trop important " }, 
{ "title" : "SA0054 : Comparaisons REAL\/LREAL pour l'égalité\/l'inégalité ", 
"url" : "_san_rule_sa0054.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les opérateurs \/ SA0054 : Comparaisons REAL\/LREAL pour l'égalité\/l'inégalité ", 
"snippet" : "Détecte si les opérateurs de comparaison = (égalité) et <> (inégalité) comparer les opérandes de type REAL ou LREAL . Justification : REAL \/ LREAL les valeurs sont implémentées sous forme de nombres à virgule flottante conformément à la norme IEEE 754. Cette norme implique que des nombres décimaux s...", 
"body" : "Détecte si les opérateurs de comparaison = (égalité) et <> (inégalité) comparer les opérandes de type REAL ou LREAL . Justification : REAL \/ LREAL les valeurs sont implémentées sous forme de nombres à virgule flottante conformément à la norme IEEE 754. Cette norme implique que des nombres décimaux spécifiques, apparemment simples, ne peuvent pas être représentés avec précision. En conséquence, il peut y avoir différentes représentations selon LREAL pour le même nombre décimal. Considérez les lignes de code suivantes : lr11 := 1.1;\nlr33 := 3.3;\nlrVar1 := lr11 + lr11;\nlrVar2 := lr33 - lr11;\nbotest := lrVar1 = lrVar2; Dans ce cas, botest Retour FALSE , même si les variables lrVar1 et lrVar2 les deux renvoient la valeur de surveillance de « 2,2 ». Ce n'est pas une erreur du compilateur, mais une propriété des unités à virgule flottante de tous les processeurs conventionnels. Vous pouvez éviter cela en spécifiant une valeur minimale par laquelle les valeurs peuvent différer : botest := ABS(lrVar1 - lrVar2) < 0.1; Exception : Une comparaison avec 0.0 n’est pas rapporté par cette analyse. Pour le 0, il existe une représentation exacte dans la norme IEEE 754, et donc la comparaison fonctionne généralement comme prévu. Par conséquent, pour de meilleures performances, il est logique d’autoriser ici une comparaison directe. Importance : Élevée Règle PLCopen : CP54 Exemple PROGRAM PLC_PRG\nVAR\n rTest1 : REAL;\n rTest2 : REAL;\n lrTest3 : LREAL;\n lrTest4 : LREAL;\n xResult : BOOL;\nEND_VAR \/\/the following lines each will cause an SA0054:\nxResult := rTest1 = rTest1;\nxResult := rTest1 = rTest2;\nxResult := rTest1 <> rTest2;\nxResult := lrTest3 = lrTest3;\nxResult := lrTest3 = lrTest4;\nxResult := lrTest3 <> lrTest4;\n\/\/the following lines each will not cause an SA0054:\nxResult := rTest1 > rTest2;\nxResult := lrTest3 < lrTest4;\n Sortie dans le messages voir: SA0054 : Comparaisons de REAL\/LREAL pour l'égalité\/inégalité " }, 
{ "title" : "SA0055 : Comparaisons inutiles d'opérandes non signés ", 
"url" : "_san_rule_sa0055.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les opérateurs \/ SA0055 : Comparaisons inutiles d'opérandes non signés ", 
"snippet" : "Détecte les comparaisons inutiles avec des opérandes non signés. Un type de données non signé n'est jamais inférieur à zéro. Cela peut être utilisé comme vérification des signes. Justification : Une comparaison détectée avec ce contrôle donne un résultat constant et indique une erreur dans le code. ...", 
"body" : "Détecte les comparaisons inutiles avec des opérandes non signés. Un type de données non signé n'est jamais inférieur à zéro. Cela peut être utilisé comme vérification des signes. Justification : Une comparaison détectée avec ce contrôle donne un résultat constant et indique une erreur dans le code. Importance : Élevée Exemple PROGRAM PLC_PRG\nVAR\n byTest: BYTE;\nEND_VAR\n \/\/ SA0055\nWHILE byTest >= 0 DO\n byTest := byTest - 1;\nEND_WHILE Sortie dans le messages voir: SA0055 : Comparaisons inutiles d'opérandes non signés " }, 
{ "title" : "SA0056 : Constante hors plage valide ", 
"url" : "_san_rule_sa0056.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les opérateurs \/ SA0056 : Constante hors plage valide ", 
"snippet" : "Détecte les littéraux (constantes) en dehors de la plage valide de l'opérateur Justification : Le message est émis dans les cas où une valeur est comparée à une constante qui se trouve en dehors de la plage de cette valeur. Puis la comparaison revient constamment TRUE ou FALSE . Ceci est une indicat...", 
"body" : "Détecte les littéraux (constantes) en dehors de la plage valide de l'opérateur Justification : Le message est émis dans les cas où une valeur est comparée à une constante qui se trouve en dehors de la plage de cette valeur. Puis la comparaison revient constamment TRUE ou FALSE . Ceci est une indication d'une erreur de programmation. Importance : Élevée Exemple PROGRAM PLC_PRG\nVAR\n byTestVar: BYTE;\nEND_VAR\n WHILE byTestVar >= 260 DO\n byTestVar := byTestVar + 1;\nEND_WHILE Sortie dans le messages voir: SA0056 : Constante hors plage valide " }, 
{ "title" : "SA0057 : Perte possible de décimales ", 
"url" : "_san_rule_sa0057.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les opérateurs \/ SA0057 : Perte possible de décimales ", 
"snippet" : "Détecte les déclarations avec perte possible de décimales Justification : Un morceau de code du type suivant ( diTemp2 := 1 rTemp1 := TO_REAL(diTemp2 \/ DINT#2) ) peut entraîner une mauvaise interprétation. L'auteur ou le lecteur de cette ligne de code peut supposer que la division serait effectuée c...", 
"body" : "Détecte les déclarations avec perte possible de décimales Justification : Un morceau de code du type suivant ( diTemp2 := 1 rTemp1 := TO_REAL(diTemp2 \/ DINT#2) ) peut entraîner une mauvaise interprétation. L'auteur ou le lecteur de cette ligne de code peut supposer que la division serait effectuée comme un REAL opération, et dans ce cas le résultat serait REAL#0.5 . Cependant, ce n'est pas vrai. C'est une opération sur un nombre entier. Le résultat est exprimé en REAL et rTemp1 obtient la valeur REAL#0 . Pour éviter cela, utilisez un plâtre pour vous assurer que l'opération est effectuée comme un REAL opération: rTemp1 := TO_REAL(diTemp2) \/ REAL#2; Importance : Moyenne Exemple PROGRAM PLC_PRG\nVAR\n rTemp1 : REAL;\n diTemp2 : DINT;\n liTemp3 : LINT;\nEND_VAR diTemp2 := diTemp2 + DINT#11;\n\/\/ SA0057\nrTemp1 := DINT_TO_REAL(diTemp2 \/ DINT#3); \nrTemp1 := DINT_TO_REAL(diTemp2) \/ REAL#3.0;\nliTemp3 := liTemp3 + LINT#13;\n\/\/ SA0057\nrTemp1 := LINT_TO_REAL(liTemp3 \/ LINT#7);\nrTemp1 := LINT_TO_REAL(liTemp3) \/ REAL#7.0; Sortie dans le messages voir: SA0057 : Perte possible des décimales " }, 
{ "title" : "SA0058 : Opérations sur les variables d'énumération ", 
"url" : "_san_rule_sa0058.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les opérateurs \/ SA0058 : Opérations sur les variables d'énumération ", 
"snippet" : "Détecte les opérations sur les variables du type de données d'énumération. Les affectations sont autorisées. Justification : Les énumérations ne doivent pas être utilisées comme des valeurs entières ordinaires. Alternativement, un type de données alias pourrait être défini ou un type de sous-plage p...", 
"body" : "Détecte les opérations sur les variables du type de données d'énumération. Les affectations sont autorisées. Justification : Les énumérations ne doivent pas être utilisées comme des valeurs entières ordinaires. Alternativement, un type de données alias pourrait être défini ou un type de sous-plage pourrait être utilisé. Importance : Moyenne Exception : si une énumération est taguée avec le pragma {attribute 'strict'} , le compilateur signale déjà ce type d'opération. Si une énumération est déclarée comme flag par le pragma {attribute 'flags'} , aucune erreur n'est émise pour AND , OR , NOT , ou sur commande XOR opérations. Exemple TYPE My_Enum :\n(\n red := 1, blue := 2, green := 3, black := 4\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n abc : My_Enum;\nEND_VAR iTemp1 := iTemp1 + INT#1;\nabc := My_Enum.red; \/\/ OK\niTemp1 := My_Enum.black \/ My_Enum.blue; \/\/ SA0058\niTemp1 := My_Enum.green \/ My_Enum.red; \/\/ SA0058\n Sortie dans le messages voir: SA0058 : Opérations sur les variables d'énumération Exemple avec un pragma {attribut 'flags'} {attribute 'flags'} \/\/ declaring the enumeration as a \"flag\"\nTYPE Flags :\n(\n Unknown := 16#00000001,\n Stopped := 16#00000002,\n Running := 16#00000004\n) DWORD;\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n abc : Flags;\n batate : BYTE;\n dwFlags : DWORD;\n dwState : DWORD;\nEND_VAR \/\/ OK for the following\nIF (dwFlags AND Flags.Unknown) <> DWORD#0 THEN\n dwState := dwState AND Flags.Unknown;\n ELSIF (dwFlags OR Flags.Stopped) <> DWORD#0 THEN\n dwState := dwState OR Flags.Running;\nEND_IF " }, 
{ "title" : "SA0059 : Les opérations de comparaison renvoient toujours TRUE ou FAUX ", 
"url" : "_san_rule_sa0059.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les opérateurs \/ SA0059 : Les opérations de comparaison renvoient toujours TRUE ou FAUX ", 
"snippet" : "Détecte les comparaisons avec des littéraux dont le résultat est toujours TRUE ou FALSE , et peut déjà être traité lors de la compilation. Justification : Une opération qui rapporte systématiquement TRUE ou FALSE indique une erreur de programmation. Importance : Élevée Exemple PROGRAM PLC_PRG VAR by...", 
"body" : "Détecte les comparaisons avec des littéraux dont le résultat est toujours TRUE ou FALSE , et peut déjà être traité lors de la compilation. Justification : Une opération qui rapporte systématiquement TRUE ou FALSE indique une erreur de programmation. Importance : Élevée Exemple PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\nEND_VAR\n WHILE byTemp1 <= 255 DO\n byTemp1 := byTemp1 + 1;\nEND_WHILE Sortie dans le messages voir: SA0059 : L'opérateur relationnel '<=' est toujours évalué à 'TRUE'\n " }, 
{ "title" : "SA0060 : Zéro utilisé comme opérande invalide ", 
"url" : "_san_rule_sa0060.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les opérateurs \/ SA0060 : Zéro utilisé comme opérande invalide ", 
"snippet" : "Détecte les opérations où un opérande avec la valeur 0 provoque une opération invalide ou absurde Justification : Ce type d'expression peut indiquer une erreur de programmation. Dans tous les cas, cela gaspille inutilement du temps d'exécution. Importance : Moyenne Exemple PROGRAM PLC_PRG VAR byTemp...", 
"body" : "Détecte les opérations où un opérande avec la valeur 0 provoque une opération invalide ou absurde Justification : Ce type d'expression peut indiquer une erreur de programmation. Dans tous les cas, cela gaspille inutilement du temps d'exécution. Importance : Moyenne Exemple PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\n wTemp2 : WORD;\n dwTemp3 : DWORD;\nEND_VAR\n byTemp1 := byTemp1 + 0;\nwTemp2 := wTemp2 - WORD#0;\ndwTemp3 := dwTemp3 * DWORD#0; Sortie dans le messages voir: SA0060 : Zéro utilisé comme opérande invalide " }, 
{ "title" : "SA0061 : Opération inhabituelle sur le pointeur ", 
"url" : "_san_rule_sa0061.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les opérateurs \/ SA0061 : Opération inhabituelle sur le pointeur ", 
"snippet" : "Détecte les opérations sur des variables de type POINTER TO qui ne sont pas = (égalité), <> (inégalité), + (ajout), ou ADR . Dans CODESYS , l'arithmétique de pointeur est généralement autorisée et peut également être utilisée de manière appropriée. Par conséquent, l'ajout d'un pointeur avec une vale...", 
"body" : "Détecte les opérations sur des variables de type POINTER TO qui ne sont pas = (égalité), <> (inégalité), + (ajout), ou ADR . Dans CODESYS , l'arithmétique de pointeur est généralement autorisée et peut également être utilisée de manière appropriée. Par conséquent, l'ajout d'un pointeur avec une valeur entière est considéré comme une opération courante sur les pointeurs. Cela permet d'utiliser un pointeur pour traiter un tableau de longueur variable. Toutes les autres opérations (inhabituelles) avec des pointeurs sont signalées avec SA0061. Importance : Élevée Règle PLCopen : E2 \/ E3 Exemple PROGRAM PLC_PRG\nVAR\n piTemp : POINTER TO INT;\n iTemp : INT;\nEND_VAR\n iTemp := iTemp + INT#1;\npiTemp := ADR(iTemp);\npiTemp := piTemp * DWORD#5; \/\/ SA0061\npiTemp := piTemp \/ DWORD#2; \/\/ SA0061\npiTemp := piTemp MOD DWORD#3; \/\/ SA0061\npiTemp := piTemp + DWORD#1;\npiTemp := piTemp - DWORD#1; \/\/ SA0061 Sortie dans le messages voir: SA0061 : Fonctionnement inhabituel sur le pointeur " }, 
{ "title" : "SA0062 : L'expression est constante ", 
"url" : "_san_rule_sa0062.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les opérateurs \/ SA0062 : L'expression est constante ", 
"snippet" : "Détecte l'utilisation d'expressions qui ont toujours la même valeur au moment de l'exécution. Justification : Une expression complexe qui est calculée à plusieurs reprises et génère toujours la même valeur peut indiquer une erreur. Cela vaut en particulier si quelque chose d'autre était prévu. Dans ...", 
"body" : "Détecte l'utilisation d'expressions qui ont toujours la même valeur au moment de l'exécution. Justification : Une expression complexe qui est calculée à plusieurs reprises et génère toujours la même valeur peut indiquer une erreur. Cela vaut en particulier si quelque chose d'autre était prévu. Dans chaque cas, l'expression alourdit inutilement l'exécution du programme Importance : Moyenne Exemple PROGRAM PLC_PRG\nVAR\n value : INT;\n condition : BOOL;\nEND_VAR\n value := 8;\ncondition := value = 8 \/\/ Reports: Expression (value=8) is always TRUE Sortie dans le Messages vue : SA0062 : L'expression « (value=8) » est toujours VRAIE " }, 
{ "title" : "SA0063 : Opérations éventuellement non compatibles 16 bits ", 
"url" : "_san_rule_sa0063.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les opérateurs \/ SA0063 : Opérations éventuellement non compatibles 16 bits ", 
"snippet" : "Détecte les opérations 16 bits avec des résultats temporaires. Contexte : sur les systèmes 16 bits, les résultats temporaires 32 bits peuvent être tronqués. Exemple: (int+10) peut dépasser 16 bits. Justification : Dans le cas très rare où vous devez écrire du code qui doit s'exécuter sur un processe...", 
"body" : "Détecte les opérations 16 bits avec des résultats temporaires. Contexte : sur les systèmes 16 bits, les résultats temporaires 32 bits peuvent être tronqués. Exemple: (int+10) peut dépasser 16 bits. Justification : Dans le cas très rare où vous devez écrire du code qui doit s'exécuter sur un processeur 16 bits ainsi que sur un processeur 32 bits, ce message devrait aider à prévenir tout problème. Importance : Faible Exemple PROGRAM PLC_PRG\nVAR\n iVar : INT;\nEND_VAR\n iVar := (iVar + 10) \/ 2; Sortie dans le messages voir: SA0063 : Compatibilité pour 16 bits – Résultat intermédiaire tronqué possible " }, 
{ "title" : "SA0064 : Ajout de pointeur ", 
"url" : "_san_rule_sa0064.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les opérateurs \/ SA0064 : Ajout de pointeur ", 
"snippet" : "Détecte l'ajout de pointeurs Justification : Dans CODESYS , l'arithmétique des pointeurs est généralement autorisée et peut également être utilisée de manière appropriée. Mais cela représente aussi une source d’erreur. Par conséquent, il existe des règles de programmation qui interdisent généralemen...", 
"body" : "Détecte l'ajout de pointeurs Justification : Dans CODESYS , l'arithmétique des pointeurs est généralement autorisée et peut également être utilisée de manière appropriée. Mais cela représente aussi une source d’erreur. Par conséquent, il existe des règles de programmation qui interdisent généralement l’arithmétique des pointeurs. Ce test permet de vérifier une telle exigence. Importance : Moyenne Exemple PROGRAM PLC_PRG\nVAR\n iTest : INT;\n ariTest : ARRAY[0..10] OF INT;\n {attribute 'analysis':='-111'}\n piTest : POINTER TO INT;\n i : INT;\nEND_VAR\n piTest := ADR(ariTest[0]); \/\/ OK\npiTest^ := 0;\npiTest := ADR(ariTest) + SIZEOF(INT); \/\/ SA0064\npiTest^ := 1;\npiTest := ADR(ariTest) + 6; \/\/ SA0064\npiTest^ := 3;\npiTest := ADR(ariTest[10]);\nFOR i:=0 TO 10 DO\n piTest^ := i;\n piTest := piTest + 2; \/\/ SA0064\nEND_FOR Sortie dans le messages voir: SA0064 : Ajout de pointeur " }, 
{ "title" : "SA0065 : Ajout incorrect du pointeur à la taille de base ", 
"url" : "_san_rule_sa0065.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les opérateurs \/ SA0065 : Ajout incorrect du pointeur à la taille de base ", 
"snippet" : "Détecte les ajouts de pointeur pour lesquels la valeur à ajouter ne correspond pas à la taille de base du pointeur. Seuls les littéraux de la taille des données de base et leurs multiples peuvent être ajoutés sans erreur. Justification : Dans CODESYS (contrairement à C et C++), lors de l'ajout d'un ...", 
"body" : "Détecte les ajouts de pointeur pour lesquels la valeur à ajouter ne correspond pas à la taille de base du pointeur. Seuls les littéraux de la taille des données de base et leurs multiples peuvent être ajoutés sans erreur. Justification : Dans CODESYS (contrairement à C et C++), lors de l'ajout d'un pointeur avec une valeur entière, seule cette valeur entière est ajoutée en tant que nombre d'octets, et non la valeur entière multipliée par la taille de base. Exemple en ST pINT := ADR(array_of_int[0]);\npINT := pINT + 2; \/\/in CODESYS, pINT then points to array_of_int[1] Ce code fonctionnerait différemment en C : short* pShort\npShort = &(array_of_short[0])\npShort = pShort + 2; \/\/in C, pShort then points to array_of_short[2] Par conséquent, dans CODESYS , vous devez toujours ajouter un multiple de la taille de base du pointeur à un pointeur. Sinon, le pointeur peut pointer vers non aligné mémoire qui (selon le processeur) peut conduire à une exception d'alignement lors de l'accès à celle-ci. Importance : Élevée Exemple VAR\n pudiTest:POINTER TO UDINT;\n udiTest:UDINT;\n prTest:POINTER TO REAL;\n rTest:REAL;\nEND_VAR pudiTest := ADR(udiTest) + 4; \/\/ OK\npudiTest := ADR(udiTest) + ( 2 + 2 ); \/\/ OK\npudiTest := ADR(udiTest) + SIZEOF(UDINT); \/\/ OK\npudiTest := ADR(udiTest) + 3; \/\/ SA0065\npudiTest := ADR(udiTest) + 2*SIZEOF(UDINT); \/\/ OK\npudiTest := ADR(udiTest) + ( 3 + 2 ); \/\/ SA0065\nprTest := ADR(rTest);\nprTest := prTest + 4; \/\/ OK\nprTest := prTest + ( 2 + 2 ); \/\/ OK\nprTest := prTest + SIZEOF(REAL); \/\/ OK\nprTest := prTest + 1; \/\/ SA0065\nprTest := prTest + 2; \/\/ SA0065\nprTest := prTest + 3; \/\/ SA0065\nprTest := prTest + ( SIZEOF(REAL) - 1 ); \/\/ SA0065\nprTest := prTest + ( 1 + 4 ); \/\/ SA0065\n Sortie dans le messages voir: SA0065 : Ajout incorrect du pointeur à la taille de base " }, 
{ "title" : "SA0066 : Utilisations des résultats temporaires ", 
"url" : "_san_rule_sa0066.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les opérateurs \/ SA0066 : Utilisations des résultats temporaires ", 
"snippet" : "Détecte l'utilisation de résultats temporaires dans des instructions avec un type de données inférieur à la taille du registre. Dans ce cas, la conversion implicite peut conduire à des résultats indésirables. Justification : Pour des raisons de performances, CODESYS Static Analysis effectue des opér...", 
"body" : "Détecte l'utilisation de résultats temporaires dans des instructions avec un type de données inférieur à la taille du registre. Dans ce cas, la conversion implicite peut conduire à des résultats indésirables. Justification : Pour des raisons de performances, CODESYS Static Analysis effectue des opérations sur la largeur de registre du processeur. Les résultats intermédiaires ne sont pas tronqués. Cela peut conduire à des interprétations erronées, comme dans le cas suivant : Exemple usintTest := 0; xError := usintTest - 1 <> 255; Dans CODESYS , xError est TRUE dans ce cas parce que l'opération usintTest - 1 est généralement exécuté comme une opération 32 bits et le résultat n'est pas converti en taille d'octet. Alors la valeur 16#ffffffff (différent de 255) se trouve dans le registre. Pour éviter cela, vous devez convertir explicitement le résultat intermédiaire : xError := TO_USINT(usintTest - 1) <> 255; Si ce message est activé, de nombreux emplacements moins problématiques dans le code seront signalés. Bien qu'un problème ne puisse se produire que lorsque l'opération produit un débordement ou un débordement insuffisant dans le type de données, l'analyse statique ne peut pas différencier les emplacements individuels. Si vous incluez un transtypage explicite dans tous les emplacements signalés, le code sera beaucoup plus lent et moins lisible. Importance : Faible Exemple PROGRAM PLC_PRG\nVAR\n byTest:BYTE;\n liTest:LINT;\n xError:BOOL;\nEND_VAR \/\/type size smaller than register size;\nbyTest := 0;\nIF (byTest - 1) <> 255 THEN \/\/use of temporary result + implicit casting -> SA0066\n xError := TRUE;\nELSE\n xError := FALSE;\nEND_IF\n\n\/\/type size equal to or bigger than register size;\nliTest := 0;\nIF (liTest - 1) <> -1 THEN \/\/ use of temporary result and no implicit casting -> OK\n xError := TRUE;\nELSE\n xError := FALSE;\nEND_IF\n Sortie dans le messages voir: SA0066 : Utilisations de résultats temporaires (byTest - USINT #1) " }, 
{ "title" : "Règles pour les déclarations ", 
"url" : "_san_rule_instructions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les déclarations ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0072 : Utilisations non valides de la variable de compteur ", 
"url" : "_san_rule_sa0072.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les déclarations \/ SA0072 : Utilisations non valides de la variable de compteur ", 
"snippet" : "Détecte l'utilisation d'une variable compteur dans un FOR boucler Justification : Manipulation de la variable compteur dans un FOR une boucle peut facilement aboutir à une boucle infinie. Pour empêcher l'exécution de la boucle pour des valeurs spécifiques de la variable compteur, utilisez CONTINUE o...", 
"body" : "Détecte l'utilisation d'une variable compteur dans un FOR boucler Justification : Manipulation de la variable compteur dans un FOR une boucle peut facilement aboutir à une boucle infinie. Pour empêcher l'exécution de la boucle pour des valeurs spécifiques de la variable compteur, utilisez CONTINUE ou simplement un IF . Importance : Élevée Règle PLCopen : L12 Exemple PROGRAM PLC_PRG\nVAR_TEMP\n iIndex : INT;\nEND_VAR FOR iIndex := INT#0 TO INT#20 BY INT#1 DO\n iIndex := iIndex - INT#1;\nEND_FOR Sortie dans le messages voir: SA0072 : Utilisations non valides de la variable de compteur 'iIndex' " }, 
{ "title" : "SA0073 : Utilisations d'une variable de compteur inadéquate ", 
"url" : "_san_rule_sa0073.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les déclarations \/ SA0073 : Utilisations d'une variable de compteur inadéquate ", 
"snippet" : "Détecte l'utilisation de variables non temporaires dans FOR boucles. Justification : Il s'agit d'un avertissement de performance. Une variable de compteur est toujours initialisée chaque fois qu'un POU est appelé. Vous pouvez créer cette variable en tant que variable temporaire ( VAR_TEMP ). L'accès...", 
"body" : "Détecte l'utilisation de variables non temporaires dans FOR boucles. Justification : Il s'agit d'un avertissement de performance. Une variable de compteur est toujours initialisée chaque fois qu'un POU est appelé. Vous pouvez créer cette variable en tant que variable temporaire ( VAR_TEMP ). L'accès à celle-ci peut être plus rapide et la variable n'occupe pas de mémoire permanente. Importance : Moyenne Règle PLCopen : CP21 \/ L13 Exemple PROGRAM PLC_PRG\nVAR\n nIndex : INT;\n iVar : INT;\nEND_VAR FOR nIndex := INT#0 TO INT#20 BY INT#1 DO\n iVar := iVar + nIndex;\nEND_FOR\n Sortie sous vue messages : SA0073 : Variable du compteur ne correspondant pas " }, 
{ "title" : "SA0075 : ELSE manquant ", 
"url" : "_san_rule_sa0075.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les déclarations \/ SA0075 : ELSE manquant ", 
"snippet" : "Détecte CASE déclarations sans ELSE branche Justification : La programmation défensive nécessite l'inclusion d'un ELSE succursale dans chaque CASE déclaration. S'il n'y a rien à faire dans le ELSE branche, puis incluez un commentaire pour l'indiquer. Il est alors clair pour le lecteur du code que l'...", 
"body" : "Détecte CASE déclarations sans ELSE branche Justification : La programmation défensive nécessite l'inclusion d'un ELSE succursale dans chaque CASE déclaration. S'il n'y a rien à faire dans le ELSE branche, puis incluez un commentaire pour l'indiquer. Il est alors clair pour le lecteur du code que l'affaire n'a pas été simplement oubliée. Importance : faible Règle PLCopen : L17 For CASE instructions qui utilisent des énumérations avec attribut strict  et où toutes les constantes d'énumération sont utilisées dans le CASE est utilisée, aucun message d'erreur n'est émis. Exemple PROGRAM PLC_PRG\nVAR\n iVar : INT;\n xTemp : BOOL;\nEND_VAR iVar := iVar + INT#1;\nCASE iVar OF\n INT#1:\n xTemp := FALSE;\n INT#2:\n xTemp := TRUE;\nEND_CASE\n Sortie dans le messages voir: SA0075 : ELSE manquant dans l'instruction CASE " }, 
{ "title" : "SA0076 : Constante d'énumération manquante ", 
"url" : "_san_rule_sa0076.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les déclarations \/ SA0076 : Constante d'énumération manquante ", 
"snippet" : "Détermine si chaque constante d'énumération est utilisée ou non comme condition dans CASE déclarations et interrogé dans un CASE bifurquer. Justification : La programmation défensive nécessite le traitement de toutes les valeurs possibles d'une énumération. Si une action n'est pas requise pour une v...", 
"body" : "Détermine si chaque constante d'énumération est utilisée ou non comme condition dans CASE déclarations et interrogé dans un CASE bifurquer. Justification : La programmation défensive nécessite le traitement de toutes les valeurs possibles d'une énumération. Si une action n'est pas requise pour une valeur d'énumération particulière, vous devez ajouter un commentaire pour l'indiquer explicitement. Il est alors clair pour le lecteur du code que la valeur n'a pas simplement été oubliée. Importance : faible Exemple TYPE My_Enum :\n(\n red := 1, blue := 2, green := 3, black := 4\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iVar : My_Enum;\n xTemp : BOOL;\nEND_VAR iVar := My_Enum.black;\nCASE iVar OF\n My_Enum.red:\n xTemp := FALSE;\n My_Enum.blue, My_Enum.green:\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n Sortie dans le messages voir: SA0076 : constante d'énumération manquante \"noire\" dans l'instruction CASE " }, 
{ "title" : "SA0077 : Type d'énumération non concordant avec CASE expression ", 
"url" : "_san_rule_sa0077.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les déclarations \/ SA0077 : Type d'énumération non concordant avec CASE expression ", 
"snippet" : "Détecte les positions de code où une instruction CASE mélange des valeurs d'énumération avec des types non énumératifs. Justification : Le mélange de valeurs d'énumération et de valeurs entières dans les constructions CASE constitue une violation de la sécurité des types de données, réduit la lisibi...", 
"body" : "Détecte les positions de code où une instruction CASE mélange des valeurs d'énumération avec des types non énumératifs. Justification : Le mélange de valeurs d'énumération et de valeurs entières dans les constructions CASE constitue une violation de la sécurité des types de données, réduit la lisibilité du code et a un impact sur la maintenabilité. Les valeurs d'énumération garantissent la clarté sémantique. L'utilisation de valeurs entières brutes comporte le risque d'erreurs mineures et rend le code plus difficile à comprendre. Les modifications de type de données apportées aux énumérations peuvent également détruire des branches basées sur des entiers, ce qui Importance : Faible Exemple {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE DUT_MyEnum :\n(\n\tOne := 1, \n\tTwo := 2, \n\tThree := 3, \n\tFour := 4\n);\nEND_TYPE PROGRAM PRG_Case\nVAR\ndiVar : DINT;\nxTemp : BOOL;\n\neMyEnum : DUT_MyEnum;\nEND_VAR\n CASE diVar OF\n 1 :\n xTemp := FALSE;\n DUT_MyEnum.Two : \/\/ SA0077\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n\nCASE eMyEnum OF\n 1 : \/\/ SA0077\n xTemp := FALSE;\n DUT_MyEnum.Two:\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE Sortie dans le messages voir: SA0077 : Incompatibilités de type avec l'expression CASE " }, 
{ "title" : "SA0078 : Branches CASE manquantes ", 
"url" : "_san_rule_sa0078.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les déclarations \/ SA0078 : Branches CASE manquantes ", 
"snippet" : "Détecte CASE déclarations sans CASE succursales et un seul ELSE déclaration Justification : A CASE une instruction sans cas fait perdre du temps d’exécution et est difficile à lire. Importance : Moyenne Exemple PROGRAM PLC_PRG VAR iVar : INT; xTemp : BOOL; END_VAR iVar := iVar + INT#1; \/\/in the foll...", 
"body" : "Détecte CASE déclarations sans CASE succursales et un seul ELSE déclaration Justification : A CASE une instruction sans cas fait perdre du temps d’exécution et est difficile à lire. Importance : Moyenne Exemple PROGRAM PLC_PRG\nVAR\n iVar : INT;\n xTemp : BOOL;\nEND_VAR iVar := iVar + INT#1;\n\/\/in the following the case descriptions are missing:\nCASE iVar OF\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n Sortie dans le messages voir: SA0078 : Branches CASE manquantes " }, 
{ "title" : "SA0081 : La bordure supérieure n'est pas une constante ", 
"url" : "_san_rule_sa0081.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les déclarations \/ SA0081 : La bordure supérieure n'est pas une constante ", 
"snippet" : "Détecte le FOR instructions où la limite supérieure n'est pas définie avec une valeur constante Justification : Si la borne supérieure d'une boucle est une valeur variable, il n'est plus possible de voir à quelle fréquence une boucle est exécutée. Cela peut entraîner de graves problèmes lors de l'ex...", 
"body" : "Détecte le FOR instructions où la limite supérieure n'est pas définie avec une valeur constante Justification : Si la borne supérieure d'une boucle est une valeur variable, il n'est plus possible de voir à quelle fréquence une boucle est exécutée. Cela peut entraîner de graves problèmes lors de l'exécution. Le pire des cas est une boucle infinie. Importance : Élevée Exemple PROGRAM PLC_PRG\nVAR\n i:INT;\n iBorder1: INT := 10;\n iBorder2: INT := 10;\n iCounter: INT;\nEND_VAR\nVAR CONSTANT\n ciBorder:INT := 10;\nEND_VAR\n FOR i:=0 TO 10 DO \/\/OK\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO ciBorder DO \/\/ OK\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO iBorder1 DO \/\/ SA0081\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO iBorder2 DO \/\/ SA0081\n iCounter := i;\n IF iCounter = 10 THEN\n iBorder2 := 50;\n END_IF\nEND_FOR\n Sortie dans le messages voir: SA0081 : La bordure supérieure d'une boucle for doit être une valeur constante " }, 
{ "title" : "SA0090 : Instruction RETURN avant la fin de la fonction ", 
"url" : "_san_rule_sa0090.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Règles pour les déclarations \/ SA0090 : Instruction RETURN avant la fin de la fonction ", 
"snippet" : "Détecte les emplacements de code où le RETURN L'instruction n'est pas la dernière instruction d'une fonction, d'une méthode, d'une propriété ou d'un programme. Endroits où un RETURN existe au sein d'un IF branche sont également détectées. Justification : A RETURN dans le code entraîne une maintenabi...", 
"body" : "Détecte les emplacements de code où le RETURN L'instruction n'est pas la dernière instruction d'une fonction, d'une méthode, d'une propriété ou d'un programme. Endroits où un RETURN existe au sein d'un IF branche sont également détectées. Justification : A RETURN dans le code entraîne une maintenabilité, une testabilité et une lisibilité du code moins bonnes. UNE RETURN dans le code est facilement négligé. Avant chaque RETURN , on oublie souvent d'insérer du code qui doit toujours être exécuté à la sortie d'une fonction. Importance : Moyenne Règle PLCopen : CP14 Exemple FUNCTION SA0090: DINT\nVAR_INPUT\n bTest : BOOL;\nEND_VAR IF bTest THEN\n RETURN;\nEND_IF\nSA0090 := 99; Sortie dans les  messages voir : SA0090 : les POU doivent avoir un seul point de sortie " }, 
{ "title" : "SA0095 : Affectations sous conditions ", 
"url" : "_san_rule_sa0095.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0095 : Affectations sous conditions ", 
"snippet" : "Détecte les affectations dans des conditions de IF , CASE , ou REPEAT construit Justification : Une affectation (:=) et une comparaison (=) peuvent facilement être confondues. Par conséquent, une affectation dans une condition peut facilement être involontaire, et elle est donc signalée. Cela peut é...", 
"body" : "Détecte les affectations dans des conditions de IF , CASE , ou REPEAT construit Justification : Une affectation (:=) et une comparaison (=) peuvent facilement être confondues. Par conséquent, une affectation dans une condition peut facilement être involontaire, et elle est donc signalée. Cela peut également dérouter le lecteur du code. Importance : Élevée Exemple PROGRAM PLC_PRG\nVAR\n iCond1:INT := INT#1;\n iCond2:INT := INT#2;\n xCond:BOOL := FALSE;\n iVar : INT;\nEND_VAR IF INT_TO_BOOL(iCond1 := iCond2) THEN \/\/ SA0095\n iCond1 := INT#1;\n iCond2 := INT#2;\n ELSIF (iCond1 := 11) = 11 THEN \/\/ SA0095\n iCond1 := INT#1;\n iCond2 := INT#2;\nEND_IF\n\nIF xCond := TRUE THEN \/\/ SA0095\n xCond := FALSE;\nEND_IF\n\nIF (xCond := FALSE) OR (iCond1 := iCond2) = 12 THEN \/\/ SA0095\n xCond := FALSE;\n iCond1 := INT#1;\n iCond2 := INT#2;\nEND_IF\n\nIF (iVar := iVar + 1) = 120 THEN \/\/ SA0095 (can be valid, but is not reparable very well\n iVar := 0;\nEND_IF\n\nWHILE (xCond = TRUE) OR (iCond1 := iCond2) = 12 DO \/\/ SA0095\n xCond := FALSE;\nEND_WHILE\n\n\/\/Error: assignment in repeat loop\nREPEAT\n xCond := FALSE;\nUNTIL (xCond = TRUE) OR (iCond1 := iCond2) = 12 \/\/ SA0095\nEND_REPEAT Sortie dans le messages voir: SA0095 : Affectation en condition : '...' " }, 
{ "title" : "SA0100 : Variables supérieures à <n> octets ", 
"url" : "_san_rule_sa0100.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0100 : Variables supérieures à <n> octets ", 
"snippet" : "Détecte les variables qui utilisent plus de n octets, où n est défini par la configuration actuelle. Valeur par défaut : 1024 octets. La valeur peut être modifiée en double-cliquant sur la ligne. Justification : Certaines directives de programmation spécifient une taille maximale pour une seule vari...", 
"body" : "Détecte les variables qui utilisent plus de n octets, où n est défini par la configuration actuelle. Valeur par défaut : 1024 octets. La valeur peut être modifiée en double-cliquant sur la ligne. Justification : Certaines directives de programmation spécifient une taille maximale pour une seule variable. Cela peut être vérifié avec ceci. Importance : faible Exemple PROGRAM PLC_PRG\nVAR\n aobyTest : ARRAY [0..1024] OF BYTE;\nEND_VAR\n aobyTest[INT#0] := aobyTest[INT#0] + BYTE#1; Sortie dans le messages voir: SA0100 : Variable 'aobyTest' supérieure à 1024 octets " }, 
{ "title" : "SA0101 : Noms de longueur non valide ", 
"url" : "_san_rule_sa0101.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0101 : Noms de longueur non valide ", 
"snippet" : "Détecte les noms avec des longueurs non valides. Dans le Paramètres du projet , double-cliquez sur l'entrée de la règle pour ouvrir une boîte de dialogue dans laquelle vous pouvez définir la longueur du nom et définir toute exception. Justification : Certaines directives de programmation spécifient ...", 
"body" : "Détecte les noms avec des longueurs non valides. Dans le Paramètres du projet , double-cliquez sur l'entrée de la règle pour ouvrir une boîte de dialogue dans laquelle vous pouvez définir la longueur du nom et définir toute exception. Justification : Certaines directives de programmation spécifient une longueur minimale pour les noms de variables. Cette analyse peut être utilisée pour vérifier la conformité. Importance : faible Règle PLCopen : N6 Toutes les règles sont répertoriées dans le Paramètres Analyse statique : règles dialogue. Là, vous pouvez double-cliquer sur la règle 101 pour ouvrir la configuration spécifique à la règle. Ensuite, vous pouvez définir le nombre minimum et maximum de caractères et définir des exceptions dans le Longueur des noms dialogue. Exemple PROGRAM PLC1 \/\/ SA0101\nVAR\n iVar1 : INT; \/\/ SA0101\nEND_VAR\n Sortie dans le messages voir: SA0101 : Longueur du nom « PLC1 » non valide " }, 
{ "title" : "SA0102 : Accès aux variables programme\/fb depuis l'extérieur ", 
"url" : "_san_rule_sa0102.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0102 : Accès aux variables programme\/fb depuis l'extérieur ", 
"snippet" : "Détecte les accès externes aux variables locales des programmes ou des blocs fonctionnels. Justification: CODESYS permet un accès externe en lecture aux variables locales des programmes ou des blocs fonctionnels. Cela contredit le principe d'encapsulation des données (cacher les données) et n'est pa...", 
"body" : "Détecte les accès externes aux variables locales des programmes ou des blocs fonctionnels. Justification: CODESYS permet un accès externe en lecture aux variables locales des programmes ou des blocs fonctionnels. Cela contredit le principe d'encapsulation des données (cacher les données) et n'est pas conforme à la norme CEI 61131-3. Importance : Moyenne Exemple PROGRAM PLC_PRG\nVAR\n iCounter : INT;\n afb_Instance : AFB;\n bfb_Instance : BFB;\nEND_VAR iCounter := A_PRG.iLocal; \/\/ SA0102\niCounter := bfb_Instance.iLocal; \/\/ SA0102\nA_PRG(); FUNCTION_BLOCK AFB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iLocal: INT;\nEND_VAR METHOD METH : INT\nVAR_INPUT\nEND_VAR iLocal := iLocal + 1; FUNCTION_BLOCK BFB EXTENDS AFB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\nEND_VAR\nMETHOD METH : INT\nVAR_INPUT\nEND_VAR iLocal := iLocal + 1; PROGRAM A_PRG\nVAR\n iLocal: INT;\nEND_VAR iLocal := iLocal + 1;\n Sortie dans le messages voir: SA0102 : Accès au programme\/variable fb 'iLocal' depuis l'extérieur " }, 
{ "title" : "SA0103 : Accès simultané sur des données non atomiques ", 
"url" : "_san_rule_sa0103.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0103 : Accès simultané sur des données non atomiques ", 
"snippet" : "Détecte si oui ou non les variables non atomiques (par exemple, avec le type de données STRING , WSTRING , ARRAY , STRUCT , instances FB, types de données 64 bits) sont utilisés dans plusieurs tâches Justification : Lorsqu'il n'y a pas de synchronisation lors de l'accès, des valeurs incohérentes peu...", 
"body" : "Détecte si oui ou non les variables non atomiques (par exemple, avec le type de données STRING , WSTRING , ARRAY , STRUCT , instances FB, types de données 64 bits) sont utilisés dans plusieurs tâches Justification : Lorsqu'il n'y a pas de synchronisation lors de l'accès, des valeurs incohérentes peuvent être lues lors de la lecture dans une tâche et de l'écriture dans une autre tâche en même temps. Importance : Moyenne Pour certains types de données, en particulier les entiers 64 bits, cela dépend de la plate-forme si l'accès est atomique ou non. L'analyse statique signale un problème uniquement lorsque le contrôleur ne prend pas en charge l'accès atomique aux types de données entiers 64 bits. Cette règle ne s'applique pas dans les cas suivants : Si le système cible dispose d'une unité à virgule flottante (FPU), l'accès à plusieurs tâches pour LREAL la variable n'est pas détectée Si le système cible est un processeur 64 bits ou si le paramètre cible correspondant est défini pour le périphérique cible, la règle ne s'applique pas aux types de données 64 bits Exemple Le projet contient les deux programmes, PRG1 et PRG2 . Le programme PRG1 est utilisé par la tâche MainTask_1 appelé le programme PRG2 de la tâche MainTask_2 . VAR_GLOBAL\n lrTest : LREAL; \/\/ Since the target system has an FPU, SA0103 does apply.\n lint1 : LINT;\n sTest : STRING; \/\/ SA0103\n wsTest : WSTRING; \/\/ SA0103\nEND_VAR PROGRAM PRG1 GVL.lrTest := 5.0;\nGVL.sTest := 'welt';\nGVL.wsTest := \"welt\";\nGVL.lint1 := 99;\n PROGRAM PRG2 GVL.lrTest := 5.0;\nGVL.sTest := 'hallo';\nGVL.wsTest := \"hallo\";\nGVL.lint1 := 88; Sortie dans le messages voir: SA0103 : Accès simultané sur des données non atomiques 'sTest' SA0103 : Accès simultané aux données non atomiques 'wsTest' " }, 
{ "title" : "SA0105 : Appels d'instances multiples ", 
"url" : "_san_rule_sa0105.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0105 : Appels d'instances multiples ", 
"snippet" : "Détecte les instances de blocs fonctionnels appelés plusieurs fois. Pour cela, les blocs fonctionnels doivent être marqués du pragma suivant : {attribute 'analysis:report-multiple-instance-calls'} Justification : Certains blocs fonctionnels sont conçus de telle sorte qu'ils ne peuvent être appelés q...", 
"body" : "Détecte les instances de blocs fonctionnels appelés plusieurs fois. Pour cela, les blocs fonctionnels doivent être marqués du pragma suivant : {attribute 'analysis:report-multiple-instance-calls'} Justification : Certains blocs fonctionnels sont conçus de telle sorte qu'ils ne peuvent être appelés qu'une seule fois dans le cycle. Ce test vérifie si un appel est passé ou non à plusieurs endroits. Importance : Faible Règle PLCopen : CP16 \/ CP20 Exemple \/\/ {attribute 'analysis:report-multiple-instance-calls'} Deactivated\nFUNCTION_BLOCK FB_DoA\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\n iA := iA + 1; {attribute 'analysis:report-multiple-instance-calls'}\nFUNCTION_BLOCK FB_DoB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iB : INT;\nEND_VAR\n iB := iB + 1; PROGRAM PLC_PRG\nVAR\n fbA : FB_DoA;\n fbB : FB_DoB;\nEND_VAR fbA();\nfbB(); \/\/ SA0105\nfbA();\nfbB(); \/\/ SA0105\n Sortie dans le messages voir: SA0105 : Instance 'fbB' appelée plusieurs fois " }, 
{ "title" : "SA0106 : Appels de méthodes virtuelles dans FB_INIT ", 
"url" : "_san_rule_sa0106.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0106 : Appels de méthodes virtuelles dans FB_INIT ", 
"snippet" : "Détecte les appels de méthode dans le FB_Init méthode d'un bloc fonctionnel de base, qui sont écrasés par un bloc fonctionnel dérivé d'un bloc fonctionnel de base Justification : Dans ces cas, il se peut que les variables des méthodes écrasées ne soient pas initialisées dans le FB de base. Importanc...", 
"body" : "Détecte les appels de méthode dans le FB_Init méthode d'un bloc fonctionnel de base, qui sont écrasés par un bloc fonctionnel dérivé d'un bloc fonctionnel de base Justification : Dans ces cas, il se peut que les variables des méthodes écrasées ne soient pas initialisées dans le FB de base. Importance : Élevée Exemple Le bloc fonction FB_A comprend les méthodes FB_Init et Meth_MyInit . FB_Init appels Meth_MyInit pour l'initialisation. Le bloc fonction FB_B dérive de FB_A . PLC_PRG appels FB_B et utilise donc son mbMyDintB variable avant qu'elle ne soit initialisée. FB_B.Meth_MyInit écrase FB_A.Meth_MyInit . FUNCTION_BLOCK FB_A\nVAR\n mbMyDintA : DINT;\nEND_VAR FUNCTION_BLOCK FB_B EXTENDS FB_A\nVAR\n mbMyDintB : DINT;\nEND_VAR METHOD FB_Init : BOOL\nVAR_INPUT\n bInitRetains:BOOL;\n bInCopyCode:BOOL;\nEND_VAR\nVAR\n diDummy:DINT; \/\/SA0106\nEND_VAR\n mbMyDintA := 123;\ndiDummy := Meth_MyInit(); METHOD Meth_MyInit : DINT\nVAR_INPUT\nEND_VAR\n mbMyDintB := 123; \/\/access to member of FB_B PROGRAM PLC_PRG\nVAR\n g_BInst : FB_B;\n xVar : BOOL;\nEND_VAR\n\n xVar := g_BInst.fb_init(TRUE, TRUE);\n\/\/this instruction causes the following order of initializations:\n\/\/FB_A.fb_init\n\/\/FB_B.Meth_MyInit \/\/SA0106\n\/\/FB_B.fb_init\n\/\/FB_B.Meth_MyInit Sortie dans le messages voir: SA0106 : Appel de méthode virtuelle 'Meth_MyInit' dans FB_INIT " }, 
{ "title" : "SA0107 : Paramètres formels manquants ", 
"url" : "_san_rule_sa0107.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0107 : Paramètres formels manquants ", 
"snippet" : "Détecte si des paramètres formels sont manquants ou non Justification : Le code devient plus lisible lorsque des paramètres formels sont spécifiés dans l'appel. Importance : Faible Exemple FUNCTION FUNA : BOOL VAR_INPUT bDo : BOOL; bInit : BOOL; bManual : BOOL; END_VAR VAR iInit : INT; iLocal : INT;...", 
"body" : "Détecte si des paramètres formels sont manquants ou non Justification : Le code devient plus lisible lorsque des paramètres formels sont spécifiés dans l'appel. Importance : Faible Exemple FUNCTION FUNA : BOOL\nVAR_INPUT\n bDo : BOOL;\n bInit : BOOL;\n bManual : BOOL;\nEND_VAR\nVAR\n iInit : INT;\n iLocal : INT;\n iManual : INT;\nEND_VAR\n IF bInit = TRUE THEN\n iInit := iInit + 1;\nEND_IF\nIF bDo = TRUE THEN\n iLocal := iLocal + 1;\nEND_IF\nIF bManual = TRUE THEN\n iManual := iManual + 1;\nEND_IF\nFUNA := TRUE;\n PROGRAM PLC_PRG\nVAR\nEND_VAR\n FUNA(bInit := TRUE, bDo := TRUE, bManual := FALSE); \/\/ OK\nFUNA(TRUE, TRUE, bManual:= FALSE); \/\/ SA0107 Sortie dans le messages voir: SA0107 : Paramètre formel manquant pour l'entrée 'TRUE' " }, 
{ "title" : "Vérification des règles CEI strictes ", 
"url" : "_san_check_strict_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Vérification des règles CEI strictes ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0111 : Variables de pointeur ", 
"url" : "_san_rule_sa0111.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Vérification des règles CEI strictes \/ SA0111 : Variables de pointeur ", 
"snippet" : "Détecte les variables de type POINTER TO Justification : La norme CEI 61131-3 n'autorise pas les pointeurs. Importance : Faible Exemple VAR piTemp : POINTER TO INT; pbyTemp : POINTER TO BYTE; END_VAR Sortie dans le messages voir: SA0111 : Type de données POINTER non autorisé...", 
"body" : "Détecte les variables de type POINTER TO Justification : La norme CEI 61131-3 n'autorise pas les pointeurs. Importance : Faible Exemple VAR\n piTemp : POINTER TO INT;\n pbyTemp : POINTER TO BYTE;\nEND_VAR\n Sortie dans le messages voir: SA0111 : Type de données POINTER non autorisé " }, 
{ "title" : "SA0112 : Variables de référence ", 
"url" : "_san_rule_sa0112.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Vérification des règles CEI strictes \/ SA0112 : Variables de référence ", 
"snippet" : "Détecte les variables de type REFERENCE TO Justification : La norme CEI 61131-3 n'autorise pas les références. Importance : Faible Exemple VAR ref_int : REFERENCE TO INT; ref_dw : REFERENCE TO DWORD; END_VAR Sortie dans le messages voir: SA0112 : Type de données REFERENCE non autorisé...", 
"body" : "Détecte les variables de type REFERENCE TO Justification : La norme CEI 61131-3 n'autorise pas les références. Importance : Faible Exemple VAR\n ref_int : REFERENCE TO INT;\n ref_dw : REFERENCE TO DWORD;\nEND_VAR\n Sortie dans le messages voir: SA0112 : Type de données REFERENCE non autorisé " }, 
{ "title" : "SA0113 : Variables avec le type de données WSTRING ", 
"url" : "_san_rule_sa0113.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Vérification des règles CEI strictes \/ SA0113 : Variables avec le type de données WSTRING ", 
"snippet" : "Détermine les variables de type WSTRING . Raison : Tous les systèmes ne le prennent pas en charge WSTRING . Le code devient plus portable lorsque vous cliquez sur WSTRING renoncé. Importance : Faible Exemple VAR wstrTemp : WSTRING; END_VAR Sortie dans le messages voir: SA0113 : Type de données WSTRI...", 
"body" : "Détermine les variables de type WSTRING . Raison : Tous les systèmes ne le prennent pas en charge WSTRING . Le code devient plus portable lorsque vous cliquez sur WSTRING renoncé. Importance : Faible Exemple VAR\n wstrTemp : WSTRING;\nEND_VAR\n Sortie dans le messages voir: SA0113 : Type de données WSTRING non autorisé " }, 
{ "title" : "SA0114 : Variables avec le type de données LTIME ", 
"url" : "_san_rule_sa0114.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Vérification des règles CEI strictes \/ SA0114 : Variables avec le type de données LTIME ", 
"snippet" : "Détecte les variables de type LTIME Raison : Tous les systèmes ne le prennent pas en charge LTIME . Le code devient plus portable lorsque vous cliquez sur LTIME renoncé. Importance : Faible Exemple VAR ltVar : LTIME; \/\/ SA0114 END_VAR Sortie dans le messages voir: SA0114 : Type de données LTIME non ...", 
"body" : "Détecte les variables de type LTIME Raison : Tous les systèmes ne le prennent pas en charge LTIME . Le code devient plus portable lorsque vous cliquez sur LTIME renoncé. Importance : Faible Exemple VAR\n ltVar : LTIME; \/\/ SA0114\nEND_VAR\n Sortie dans le messages voir: SA0114 : Type de données LTIME non autorisé Pour plus d'informations, voir : attribut 'analysis:report-multiple-instance-calls' " }, 
{ "title" : "SA0115 : Déclarations avec le type de données UNION ", 
"url" : "_san_rule_sa0115.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Vérification des règles CEI strictes \/ SA0115 : Déclarations avec le type de données UNION ", 
"snippet" : "Récupère les déclarations d'un UNION -Type de données et déclarations de variables de type a UNION . Justification : La norme CEI 61131-3 n'inclut pas les syndicats. Le code est plus facilement portable sans unions. Importance : Faible Exemple TYPE A_UNION: UNION lrTemp : LREAL; liTemp : LINT; END_U...", 
"body" : "Récupère les déclarations d'un UNION -Type de données et déclarations de variables de type a UNION . Justification : La norme CEI 61131-3 n'inclut pas les syndicats. Le code est plus facilement portable sans unions. Importance : Faible Exemple TYPE A_UNION: \nUNION\n lrTemp : LREAL;\n liTemp : LINT;\nEND_UNION\nEND_TYPE PROGRAM PLC_PRG\nVAR\n aunionVar: A_UNION;\n liVar : LINT;\nEND_VAR aunionVar.lrTemp := 0.123E-12;\nliVar := aunionVar.liTemp; Sortie dans le messages voir: SA0115 : Unions interdites " }, 
{ "title" : "SA0117 : Variables avec le type de données BIT ", 
"url" : "_san_rule_sa0117.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Vérification des règles CEI strictes \/ SA0117 : Variables avec le type de données BIT ", 
"snippet" : "Détecte les déclarations de variables de type de données BIT (possible dans les définitions de structure) Justification : La norme CEI 61131-3 n'inclut pas le type de données BIT . Le code est plus facilement portable sans BIT . Importance : faible Exemple TYPE Struct1 : STRUCT bitVar : BIT; iVar : ...", 
"body" : "Détecte les déclarations de variables de type de données BIT (possible dans les définitions de structure) Justification : La norme CEI 61131-3 n'inclut pas le type de données BIT . Le code est plus facilement portable sans BIT . Importance : faible Exemple TYPE Struct1 :\nSTRUCT\n bitVar : BIT;\n iVar : INT;\n bVar : BOOL;\nEND_STRUCT\nEND_TYPE\n Sortie dans le messages voir: SA0117 : Variables avec le type de données BIT " }, 
{ "title" : "SA0119 : Fonctionnalité orientée objet ", 
"url" : "_san_rule_sa0119.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Vérification des règles CEI strictes \/ SA0119 : Fonctionnalité orientée objet ", 
"snippet" : "Détermine l'utilisation de fonctionnalités orientées objet telles que les déclarations de blocs fonctionnels EXTENDS et IMPLEMENTS , ou des déclarations de propriété et d'interface. Cette règle est utile lors de l'écriture de code à porter sur d'autres systèmes 61131-3. Raison : Tous les systèmes ne...", 
"body" : "Détermine l'utilisation de fonctionnalités orientées objet telles que les déclarations de blocs fonctionnels EXTENDS et IMPLEMENTS , ou des déclarations de propriété et d'interface. Cette règle est utile lors de l'écriture de code à porter sur d'autres systèmes 61131-3. Raison : Tous les systèmes ne prennent pas en charge la programmation orientée objet. Le code devient plus portable si vous n'utilisez pas l'orientation objet. Importance : faible Exemple \/\/Function block extended by another and implementing an interface:\nFUNCTION_BLOCK POU EXTENDS CTD IMPLEMENTS ITF \/\/SA0119\n;\n \/\/ Declaration parts of property methods assigned to a function block:\nPOU.Prop.Get \/\/SA0119 POU.Prop.Set \/\/SA0119 Sortie dans le messages voir: SA0119 : Fonctionnalités orientées objet non autorisées " }, 
{ "title" : "SA0120 : Appels de programme ", 
"url" : "_san_rule_sa0120.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Vérification des règles CEI strictes \/ SA0120 : Appels de programme ", 
"snippet" : "Détermine les appels de programme. Raison : Selon la norme CEI 61131-3, les programmes ne peuvent être appelés que dans la configuration de la tâche. Le code devient plus portable si vous n'appelez pas le programme ailleurs. Importance : Faible Exemple PROGRAM prog_control VAR END_VAR ; PROGRAM PLC_...", 
"body" : "Détermine les appels de programme. Raison : Selon la norme CEI 61131-3, les programmes ne peuvent être appelés que dans la configuration de la tâche. Le code devient plus portable si vous n'appelez pas le programme ailleurs. Importance : Faible Exemple PROGRAM prog_control\nVAR\nEND_VAR\n; PROGRAM PLC_PRG\nVAR\nEND_VAR\n prog_control(); Sortie dans le messages voir: SA0120 : Appel de programme à 'prg_control' non autorisé " }, 
{ "title" : "SA0121 : Déclarations VAR_EXTERNAL manquantes ", 
"url" : "_san_rule_sa0121.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Vérification des règles CEI strictes \/ SA0121 : Déclarations VAR_EXTERNAL manquantes ", 
"snippet" : "Détecte l'utilisation d'une variable globale dans les blocs fonction sans qu'elle y soit déclarée comme VAR_EXTERNAL Raison : Selon la norme CEI 61131-3, l'accès aux variables globales n'est possible que via une importation explicite à l'aide d'un VAR_EXTERNAL -Déclaration autorisée. Importance : Fa...", 
"body" : "Détecte l'utilisation d'une variable globale dans les blocs fonction sans qu'elle y soit déclarée comme VAR_EXTERNAL Raison : Selon la norme CEI 61131-3, l'accès aux variables globales n'est possible que via une importation explicite à l'aide d'un VAR_EXTERNAL -Déclaration autorisée. Importance : Faible Règle PLCopen : CP18 Exemple VAR_GLOBAL\n iGlob1 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n ivar : INT;\nEND_VAR\n ivar := iGlob1; \/\/ SA0121 Sortie dans le messages voir: SA0121 : Déclaration VAR_EXTERNAL requise pour la variable 'iGlob1' Exemple pour éviter les erreurs VAR_GLOBAL\n iGlob1:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n ivar:INT;\nEND_VAR\nVAR_EXTERNAL\n iGlob1:INT;\nEND_VAR\n ivar:=iGlob1; \/\/ OK " }, 
{ "title" : "SA0122 : Index de tableau défini en tant qu'expression ", 
"url" : "_san_rule_sa0122.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Vérification des règles CEI strictes \/ SA0122 : Index de tableau défini en tant qu'expression ", 
"snippet" : "Détecte l'utilisation d'expressions lors de la déclaration d'index de tableau. Raison : Tous les systèmes n'autorisent pas les expressions comme limites de tableau. Importance : faible Exemple PROGRAM PLC_PRG VAR CONSTANT c_iValue : INT := INT#15; END_VAR VAR arr : ARRAY [0..c_iValue + 1] OF INT; EN...", 
"body" : "Détecte l'utilisation d'expressions lors de la déclaration d'index de tableau. Raison : Tous les systèmes n'autorisent pas les expressions comme limites de tableau. Importance : faible Exemple PROGRAM PLC_PRG\nVAR CONSTANT\n c_iValue : INT := INT#15;\nEND_VAR\nVAR\n arr : ARRAY [0..c_iValue + 1] OF INT;\nEND_VAR\n Sortie dans le messages voir: SA0122 : Seules les constantes autorisées pour la définition du tableau 'arr' " }, 
{ "title" : "SA0123 : Utilisations de INI, ADR ou BITADR ", 
"url" : "_san_rule_sa0123.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Vérification des règles CEI strictes \/ SA0123 : Utilisations de INI, ADR ou BITADR ", 
"snippet" : "Détermine l'utilisation de la CODESYS Static Analysis -opérateurs spécifiques INI , ADR et BITADR . Raison: CODESYS -des opérateurs spécifiques empêchent la portabilité du code. Importance : Faible Exemple PROGRAM PLC_PRG VAR uiTemp : UINT; TempVarInFUNC : DWORD; END_VAR TempVarInFUNC := ADR(uiTemp)...", 
"body" : "Détermine l'utilisation de la CODESYS Static Analysis -opérateurs spécifiques INI , ADR et BITADR . Raison: CODESYS -des opérateurs spécifiques empêchent la portabilité du code. Importance : Faible Exemple PROGRAM PLC_PRG\nVAR\n uiTemp : UINT;\n TempVarInFUNC : DWORD;\nEND_VAR\n TempVarInFUNC := ADR(uiTemp); \/\/SA0123 Sortie dans le messages voir: SA0123 : Opérateur 'ADR' non autorisé " }, 
{ "title" : "SA0147 : Opération de déplacement inhabituelle - stricte ", 
"url" : "_san_rule_sa0147.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Vérification des règles CEI strictes \/ SA0147 : Opération de déplacement inhabituelle - stricte ", 
"snippet" : "Détermine les opérations de décalage de bits qui ne s'appliquent pas aux types de données de champ de bits ( BYTE , WORD , DWORD , LWORD ) respectivement. Raison : La norme CEI 61131-3 n'autorise l'accès binaire qu'aux types de données de champ binaire. la CODESYS Cependant, le compilateur autorise ...", 
"body" : "Détermine les opérations de décalage de bits qui ne s'appliquent pas aux types de données de champ de bits ( BYTE , WORD , DWORD , LWORD ) respectivement. Raison : La norme CEI 61131-3 n'autorise l'accès binaire qu'aux types de données de champ binaire. la CODESYS Cependant, le compilateur autorise également les opérations de décalage de bits avec des types de données non signés. Importance : faible Voir aussi la règle non stricte SA0018 . Exemple PROGRAM PLC_PRG\nVAR\n in_byte : BYTE := 16#45; \/\/ 2#01000101\n in_word : WORD := 16#0045; \/\/ 2#0000000001000101\n in_uint : UINT;\n in_dint : DINT;\n erg_byte : BYTE;\n erg_word : WORD;\n erg_uint : UINT;\n erg_dint : DINT;\n n: BYTE := 2;\nEND_VAR\n erg_byte := SHL(in_byte,n); \/\/ no error because BYTE is a bit field\nerg_word := SHL(in_word,n); \/\/ no error because WORD is a bit field\nerg_uint := SHL(in_uint,n); \/\/ SA0147\nerg_dint := SHL(in_dint,n); \/\/ SA0147 Sortie dans le messages voir: SA0147 : Opération de quart de travail inhabituelle – stricte " }, 
{ "title" : "SA0148 : Accès inhabituel aux bits - strict ", 
"url" : "_san_rule_sa0148.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Vérification des règles CEI strictes \/ SA0148 : Accès inhabituel aux bits - strict ", 
"snippet" : "Détermine les accès aux bits qui ne sont pas basés sur les types de données de champ de bits ( BYTE , WORD , DWORD , LWORD ) respectivement. La norme CEI 61131-3 n'autorise l'accès binaire qu'aux types de données de champ binaire. la CODESYS Cependant, le compilateur autorise également les accès bin...", 
"body" : "Détermine les accès aux bits qui ne sont pas basés sur les types de données de champ de bits ( BYTE , WORD , DWORD , LWORD ) respectivement. La norme CEI 61131-3 n'autorise l'accès binaire qu'aux types de données de champ binaire. la CODESYS Cependant, le compilateur autorise également les accès binaires aux types de données non signés. Importance : Faible Exemple PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n diTemp3 : DINT;\n uliTemp4 : ULINT;\n siTemp5 : SINT;\n usiTemp6 : USINT;\n byTemp2 : BYTE;\nEND_VAR\n iTemp1.3 := TRUE; \/\/ SA0148\ndiTemp3.4 := TRUE; \/\/ SA0148\nuliTemp4.18 := FALSE; \/\/ SA0148\nsiTemp5.2 := FALSE; \/\/ SA0148\nusiTemp6.3 := TRUE; \/\/ SA0148\nbyTemp2.5 := FALSE; \/\/ no error because BYTE is a bitfield Sortie dans le messages voir: SA0148 : Accès aux bits inhabituel – strict " }, 
{ "title" : "SA0118 : Initialisations sans constantes ", 
"url" : "_san_rule_sa0118.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Vérification des règles CEI strictes \/ SA0118 : Initialisations sans constantes ", 
"snippet" : "Trouve les initialiseurs qui n'assignent pas de constantes. Raison : Les initialisations doivent être aussi constantes que possible et ne pas faire référence à d'autres variables. En particulier, vous devez éviter les appels de fonction lors de l'initialisation, car cela peut conduire à l'accès à de...", 
"body" : "Trouve les initialiseurs qui n'assignent pas de constantes. Raison : Les initialisations doivent être aussi constantes que possible et ne pas faire référence à d'autres variables. En particulier, vous devez éviter les appels de fonction lors de l'initialisation, car cela peut conduire à l'accès à des données non initialisées. Importance : Moyenne Exemple PROGRAM PLC_PRG\nVAR\n dwTemp : DWORD := 22;\n dwTest : DWORD := dwTemp; \/\/ SA0118\n dwVar : DWORD := TempVarInFUNC(); \/\/ SA0118\nEND_VAR\n Sortie dans le messages voir: SA0118 : Initialisations n'utilisant pas de constantes " }, 
{ "title" : "SA0124 : Déréférencement de pointeur dans la partie déclaration ", 
"url" : "_san_rule_sa0124.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Vérification des règles CEI strictes \/ SA0124 : Déréférencement de pointeur dans la partie déclaration ", 
"snippet" : "Détermine les déréférences de pointeur utilisées pour l'initialisation dans la partie déclaration. Justification : Les pointeurs et les références ne doivent pas être utilisés pour les initialisations car cela peut conduire à des violations d'accès si le pointeur n'a pas été initialisé. Importance :...", 
"body" : "Détermine les déréférences de pointeur utilisées pour l'initialisation dans la partie déclaration. Justification : Les pointeurs et les références ne doivent pas être utilisés pour les initialisations car cela peut conduire à des violations d'accès si le pointeur n'a pas été initialisé. Importance : Moyenne Exemple TYPE TESTSTRUCT :\nSTRUCT\n xA : BOOL;\n xB : BOOL;\nEND_STRUCT\nEND_TYPE FUNCTION_BLOCK FB_Test\nVAR_INPUT\n pTeststruct : POINTER TO TESTSTRUCT;\nEND_VAR\nVAR\n xA : BOOL := pTeststruct^.xA; \/\/SA0124 \nEND_VAR\n\n xA := TRUE; PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\nEND_VAR\n fbTest(); Sortie dans le messages voir: SA0124 : Déréférences de pointeurs dans les déclarations " }, 
{ "title" : "SA0125 : Variables de référence dans les initialisations ", 
"url" : "_san_rule_sa0125.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Vérification des règles CEI strictes \/ SA0125 : Variables de référence dans les initialisations ", 
"snippet" : "Détermine les variables de référence utilisées pour l'initialisation dans la partie déclaration. Justification : Les pointeurs et les références ne doivent pas être utilisés pour les initialisations car cela peut conduire à des violations d'accès si le pointeur n'a pas été initialisé. Importance : M...", 
"body" : "Détermine les variables de référence utilisées pour l'initialisation dans la partie déclaration. Justification : Les pointeurs et les références ne doivent pas être utilisés pour les initialisations car cela peut conduire à des violations d'accès si le pointeur n'a pas été initialisé. Importance : Moyenne Exemple TYPE TESTSTRUCT :\nSTRUCT\n xA : BOOL;\n xB : BOOL;\nEND_STRUCT\nEND_TYPE FUNCTION_BLOCK FB_Test\nVAR_INPUT\n refTeststruct: REFERENCE TO TESTSTRUCT;\nEND_VAR\nVAR\n xA : BOOL := refTeststruct.xA; \/\/SA0125\nEND_VAR\n xA := TRUE; PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\nEND_VAR\n fbTest(); Sortie dans le messages voir: SA0125 : Référence utilisée en initialisation " }, 
{ "title" : "SA0140 : Déclarations commentées ", 
"url" : "_san_rule_sa0140.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0140 : Déclarations commentées ", 
"snippet" : "Trouve les déclarations commentées Justification : Le code est souvent commenté à des fins de débogage. Lorsqu'un tel commentaire est publié, il n'est plus clair si le code doit être supprimé ou s'il a simplement été commenté à des fins de débogage et accidentellement laissé sans commentaire. Import...", 
"body" : "Trouve les déclarations commentées Justification : Le code est souvent commenté à des fins de débogage. Lorsqu'un tel commentaire est publié, il n'est plus clair si le code doit être supprimé ou s'il a simplement été commenté à des fins de débogage et accidentellement laissé sans commentaire. Importance : Élevée Règle PLCopen : C4 Exemple PROGRAM PLC_PRG\nVAR\n iValue1: INT;\n iValue2: INT;\nEND_VAR\n iValue1 := 100;\niValue2 := 200;\n\/\/ iValue2 := 300; Sortie dans le messages voir: SA0140 : Instructions commentées : iValue2 := 300 " }, 
{ "title" : "Variables éventuellement non initialisées utilisées ", 
"url" : "_san_non_initialized_variables.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Variables éventuellement non initialisées utilisées ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0039 : Déférences possibles avec un pointeur nul ", 
"url" : "_san_rule_sa0039.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Variables éventuellement non initialisées utilisées \/ SA0039 : Déférences possibles avec un pointeur nul ", 
"snippet" : "Détermine les codes où un pointeur nul peut être déréférencé. Justification : Un pointeur doit être vérifié avant chaque déréférencement pour s'assurer qu'il n'est pas égal à zéro. Sinon, une violation d'accès peut se produire au moment de l'exécution. Importance : Élevée Exemple PROGRAM PLC_PRG VAR...", 
"body" : "Détermine les codes où un pointeur nul peut être déréférencé. Justification : Un pointeur doit être vérifié avant chaque déréférencement pour s'assurer qu'il n'est pas égal à zéro. Sinon, une violation d'accès peut se produire au moment de l'exécution. Importance : Élevée Exemple PROGRAM PLC_PRG\nVAR\n ptiVar1:POINTER TO INT;\n ptiVar2:POINTER TO INT;\n ptiVar3:POINTER TO INT;\n iVar:INT;\n iCount :INT;\n iCondition: INT;\nEND_VAR\n iCount := iCount + INT#1;\nptiVar1 := ADR(iVar);\nptiVar1^ := iCondition; \/\/ OK - valid reference\nptiVar2^ := iCondition; \/\/ SA0039 - null pointer dereferenciation\niVar := ptiVar3^; \/\/ SA0039 - null pointer dereferenciation Sortie dans le messages voir: SA0039 : Déférence possible du pointeur nul 'ptiVar2^' SA0039 : Déférence possible du pointeur nul 'ptiVar3^' " }, 
{ "title" : "SA0046 : Interface éventuellement non initialisée utilisée ", 
"url" : "_san_rule_sa0046.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Variables éventuellement non initialisées utilisées \/ SA0046 : Interface éventuellement non initialisée utilisée ", 
"snippet" : "Détecte l'utilisation d'interfaces qui n'ont pas été initialisées avant utilisation. Justification : Une référence d'interface doit être vérifiée pour <> 0 avant d'être utilisée. Sinon, une violation d'accès peut se produire lors de l'accès. Importance : Élevée Exemple \/\/Declaration of INTERFACE ITF...", 
"body" : "Détecte l'utilisation d'interfaces qui n'ont pas été initialisées avant utilisation. Justification : Une référence d'interface doit être vérifiée pour <> 0 avant d'être utilisée. Sinon, une violation d'accès peut se produire lors de l'accès. Importance : Élevée Exemple \/\/Declaration of INTERFACE ITF and assigned METH2:\nMETHOD METH2 : BOOL\nVAR_INPUT\n iInput2:INT;\nEND_VAR \/\/Declaration of INTERFACE Master_ITF1 and assigned METH:\nMETHOD METH : BOOL\nVAR_INPUT\n iInput:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n instPOU : POU;\n instITF : ITF;\n instMasterITF1 : Master_ITF1;\n instMasterITF2 : Master_ITF2;\n iDummy : INT;\n xDummy : BOOL;\n instNoInitITF : ITF;\n instNoInitITF2 : ITF;\n instNoInitMasterITF1 : Master_ITF1;\n instNoInitMasterITF2 : Master_ITF2;\nEND_VAR instITF := instPOU;\nxDummy := instITF.METH(iInput := iDummy); \/\/ OK\ninstMasterITF1 := instPOU;\nxDummy := instMasterITF1.METH(iInput := iDummy); \/\/ OK\n\nxDummy := instNoInitITF.METH(iInput := INT#1); \/\/ SA0046\nxDummy := instNoInitITF.METH2(iInput2 := INT#2); \/\/ SA0046\nxDummy := instNoInitMasterITF1.METH(iInput := INT#3); \/\/ SA0046\niDummy := instNoInitMasterITF2.Prop; \/\/ SA0046\n\nIF instNoInitITF <> 0 THEN\n instNoInitITF.Prop; \/\/ OK, because the interface can't be 0\nEND_IF Sortie dans le messages voir: SA0046 : Utilisation possible de l'interface non initialisée 'instNoInitITF' SA0046 : Utilisation possible de l'interface non initialisée 'instNoInitITF' SA0046 : Utilisation possible de l'interface non initialisée 'instNoInitMasterITF1' SA0046 : Utilisation possible de l'interface non initialisée 'instNoInitMasterITF2' " }, 
{ "title" : "SA0145 : Utilisation possible d'une référence non initialisée ", 
"url" : "_san_rule_sa0145.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ Variables éventuellement non initialisées utilisées \/ SA0145 : Utilisation possible d'une référence non initialisée ", 
"snippet" : "Récupère toutes les variables de référence utilisées qui ne peuvent pas être initialisées avant utilisation et non par l'opérateur __ISVALIDREF être vérifié. Cette règle est appliquée dans la partie implémentation des POU. Il y a une règle pour la déclaration SA0124 . Justification : La validité d'u...", 
"body" : "Récupère toutes les variables de référence utilisées qui ne peuvent pas être initialisées avant utilisation et non par l'opérateur __ISVALIDREF être vérifié. Cette règle est appliquée dans la partie implémentation des POU. Il y a une règle pour la déclaration SA0124 . Justification : La validité d'une référence doit être vérifiée avant l'accès, car une violation d'accès peut survenir lors de l'accès. Importance : Élevée Exemple PROGRAM PLC_PRG\nVAR_INPUT\n ref_iTest : REFERENCE TO INT;\nEND_VAR\n ref_iTest := 99; \/\/ SA0145\nIF __ISVALIDREF(ref_iTest) THEN\n ref_iTest := 88;\nEND_IF Sortie dans le messages voir: SA0145 : Utilisation possible de la référence 'ref_iTest' non initialisée " }, 
{ "title" : "SA0150 : Violation des limites inférieures ou supérieures des métriques ", 
"url" : "_san_rule_sa0150.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0150 : Violation des limites inférieures ou supérieures des métriques ", 
"snippet" : "Identifie les blocs de construction qui violent les métriques activées aux limites inférieures ou supérieures. Justification : Le code qui adhère à certaines métriques est plus facile à lire, plus facile à maintenir et plus facile à tester. Importance : Élevée Règle PLCopen : CP9 Exemple Situation i...", 
"body" : "Identifie les blocs de construction qui violent les métriques activées aux limites inférieures ou supérieures. Justification : Le code qui adhère à certaines métriques est plus facile à lire, plus facile à maintenir et plus facile à tester. Importance : Élevée Règle PLCopen : CP9 Exemple Situation initiale : La métrique nombre de vues est en dialogue Paramètres du projet → Analyse de code statique → Métriques activé. limite inférieure: 0 , Limite supérieure: 3 . bloc de construction Prog_1 cependant, il est appelé 5 fois. Lors de l'exécution de l'analyse statique, l'erreur SA0150 : Violation de métrique pour Prog_1. Score pour les vues métriques (5) > 2 dans la fenêtre de message dans la catégorie Traduire Publié. " }, 
{ "title" : "SA0160 : Appels récursifs ", 
"url" : "_san_rule_sa0160.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0160 : Appels récursifs ", 
"snippet" : "Détermine les appels récursifs dans les actions, les méthodes et les propriétés des blocs fonctionnels. Détecte également les récursions possibles via des appels de fonctions virtuelles et des appels d'interface. Raison : Les récursions conduisent à un comportement non déterministe et sont donc une ...", 
"body" : "Détermine les appels récursifs dans les actions, les méthodes et les propriétés des blocs fonctionnels. Détecte également les récursions possibles via des appels de fonctions virtuelles et des appels d'interface. Raison : Les récursions conduisent à un comportement non déterministe et sont donc une source d'erreur. Importance : Moyenne Règle PLCopen : CP13 Exemple Le bloc fonction FB_Test est la méthode suivante Call attribué: FUNCTION_BLOCK FB_Test\nVAR\n bParameter: BOOL;\nEND_VAR\n METHOD Call : BOOL\nVAR_INPUT\nEND_VAR\n Call := THIS^.Call(); \/\/SA0160 Le programme PLC_PRG appels FB_Test au: PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\n bValue : BOOL;\nEND_VAR\n bValue := fbTest.bParameter;\nfbTest.Call(); Sortie dans le messages voir: SA0160 : Appel récursif détecté : 'PLC_PRG' -> 'FB_Test.Call' -> 'FB_Test.Call' " }, 
{ "title" : "SA0161 : Structure non emballée dans une structure emballée ", 
"url" : "_san_rule_sa0161.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0161 : Structure non emballée dans une structure emballée ", 
"snippet" : "Détermine les structures non compressées utilisées dans les structures compressées. Justification : Le compilateur définit généralement une structure décompressée sur une adresse qui permet un accès aligné à tous les éléments de la structure. Si vous créez cette structure dans une structure compress...", 
"body" : "Détermine les structures non compressées utilisées dans les structures compressées. Justification : Le compilateur définit généralement une structure décompressée sur une adresse qui permet un accès aligné à tous les éléments de la structure. Si vous créez cette structure dans une structure compressée, l'accès aligné n'est plus possible. De plus, l'accès à un élément dans la structure décompressée peut conduire à une « exception de désalignement ». Importance : Élevée Exemple La structure structSingleDataRecord est compacté, mais contient les structures non compactées struct4Byte et struct9Byte . {attribute 'pack_mode' := '1'}\nTYPE structSingleDataRecord :\nSTRUCT\n str9ByteData: struct9Byte; (* 9 BYTE *)\n str4ByteData: struct4Byte; (* 4 BYTE *)\n udi1: UDINT;\n udi2: UDINT;\n udi3: UDINT;\n usi4: USINT;\nEND_STRUCT\nEND_TYPE (* 9 BYTE *)\nTYPE struct9Byte :\nSTRUCT\n usiRotorSlots: USINT; (* 1 BYTE *)\n uiMaxCurrent: UINT; (* 2 BYTE *)\n usiVelocity: USINT; (* 1 BYTE *)\n uiAcceleration: UINT; (* 2 BYTE *)\n uiDeceleration: UINT; (* 2 BYTE *)\n usiDirectionChange: USINT; (* 1 BYTE *)\nEND_STRUCT\nEND_TYPE TYPE struct4Byte :\nSTRUCT\n \/\/udiDummy : UDINT;\n rRealDummy : REAL;\nEND_STRUCT\nEND_TYPE Sortie dans le messages voir: SA0161 : Déclaration d'une structure décompressée 'struct9ByteData' à l'intérieur d'une structure compressée 'structSingleDataRecord' SA0161 : Déclaration d'une structure décompressée 'struct4ByteData' à l'intérieur d'une structure compressée 'structSingleDataRecord' " }, 
{ "title" : "SA0162 : Commentaires manquants ", 
"url" : "_san_rule_sa0162.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0162 : Commentaires manquants ", 
"snippet" : "Détermine les positions non commentées dans le programme. Justification : Des commentaires complets sont requis par de nombreuses directives de programmation et augmentent la lisibilité et la maintenabilité du code. Importance : faible Règle PLCopen : C2 Les commentaires sont requis à la déclaration...", 
"body" : "Détermine les positions non commentées dans le programme. Justification : Des commentaires complets sont requis par de nombreuses directives de programmation et augmentent la lisibilité et la maintenabilité du code. Importance : faible Règle PLCopen : C2 Les commentaires sont requis à la déclaration des variables. Les commentaires sont au-dessus ou à droite de celui-ci. la déclaration de programmes, de blocs fonctions ou de méthodes. Les commentaires sont au-dessus de la déclaration (dans la première ligne). Exemple PROGRAM PLC_PRG\nVAR\n iMaxValue: INT;\nEND_VAR\n Sortie dans le messages voir: SA0162 : Commentaire manquant pour 'PLC_PRG' SA0162 : commentaire manquant pour 'iMaxValue' " }, 
{ "title" : "SA0163 : Commentaires imbriqués ", 
"url" : "_san_rule_sa0163.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0163 : Commentaires imbriqués ", 
"snippet" : "Détecte les commentaires imbriqués. Justification : Les commentaires imbriqués sont difficiles à lire et doivent donc être évités. Importance : faible Règle PLCopen : C3 Exemple {attribute 'do-analysis'} (* That is (* nested comment 1 *) *) PROGRAM PLC_PRG VAR (* That is \/\/ nested comment 2 comment ...", 
"body" : "Détecte les commentaires imbriqués. Justification : Les commentaires imbriqués sont difficiles à lire et doivent donc être évités. Importance : faible Règle PLCopen : C3 Exemple {attribute 'do-analysis'}\n(* That is\n(* nested comment 1 *)\n*)\nPROGRAM PLC_PRG\nVAR\n(* That is\n\/\/ nested comment 2\ncomment *)\n iVal1: INT;\n iVal2: INT;\n\n(* That is\n(* nested comment 3 *) *)\n pVal3: POINTER TO DWORD;\n hugo: INT;\nEND_VAR\n (* That is\n\/\/ nested comment 4\ncomment *)\niVal1 := iVal1 + 1;\n(* That is\n(* nested comment 5 *)\n*)\n\n(* Not that one *) Sortie dans le messages voir: SA0163 : Commentaire imbriqué 'commentaire imbriqué 1' SA0163 : Commentaire imbriqué 'commentaire imbriqué 2' SA0163 : Commentaire imbriqué 'commentaire imbriqué 3' SA0163 : Commentaire imbriqué 'commentaire imbriqué 4' SA0163 : Commentaire imbriqué 'commentaire imbriqué 5' " }, 
{ "title" : "SA0164 : Commentaires multilignes ", 
"url" : "_san_rule_sa0164.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0164 : Commentaires multilignes ", 
"snippet" : "Recherche les commentaires sur plusieurs lignes commençant par (* comment *) sont encodés. Seuls les commentaires d'une seule ligne sont autorisés, commençant par \/\/ comment sont encodés. Justification : certaines directives de programmation interdisent les commentaires multilignes dans le code, car...", 
"body" : "Recherche les commentaires sur plusieurs lignes commençant par (* comment *) sont encodés. Seuls les commentaires d'une seule ligne sont autorisés, commençant par \/\/ comment sont encodés. Justification : certaines directives de programmation interdisent les commentaires multilignes dans le code, car le début et la fin d'un commentaire peuvent disparaître et la parenthèse de commentaire fermante peut être supprimée par une erreur. Vous pouvez vérifier cela avec le pragma analysis disable, également pour les commentaires dans la partie déclaration. Importance : faible Règle PLCopen : C5 Exemple {attribute 'do-analysis'}\n(*\n This is a multi-line comment \/\/ SA0164\n*)\nPROGRAM PLC_PRG\nVAR\n\/\/ This is a single line comment\n a: DINT;\nEND_VAR\n (* This is not a single line comment *) \/\/ SA0164\na := a + 1; Sortie dans le messages voir: SA0164 : Utiliser uniquement les commentaires sur une seule ligne " }, 
{ "title" : "SA0165 : Tâches appelant des POU autres que des programmes ", 
"url" : "_san_rule_sa0165.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0165 : Tâches appelant des POU autres que des programmes ", 
"snippet" : "Le contrôle identifie les tâches qui appellent des blocs fonctionnels ou des fonctions au lieu d'un programme. Raison : Cette règle fait partie des directives de codage PLCopen et la conformité est donc également incluse dans CODESYS vérifié. nous voyons dans CODESYS aucun problème concernant la coh...", 
"body" : "Le contrôle identifie les tâches qui appellent des blocs fonctionnels ou des fonctions au lieu d'un programme. Raison : Cette règle fait partie des directives de codage PLCopen et la conformité est donc également incluse dans CODESYS vérifié. nous voyons dans CODESYS aucun problème concernant la cohérence des données si les tâches appelaient d'autres POU que les programmes. Cependant, des problèmes peuvent survenir si le code doit être porté sur d'autres plates-formes. Importance : faible Règle PLCopen : CP16 Les tâches sont insérées sous la configuration des tâches. Les tâches configurent les POU appelées. Les POU doivent être du type programme être. Le mec module de fonction ou une fonction n'est pas autorisé. Exemple " }, 
{ "title" : "SA0166 : Nombre maximum de variables d'entrée\/sortie\/VAR_IN_OUT ", 
"url" : "_san_rule_sa0166.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0166 : Nombre maximum de variables d'entrée\/sortie\/VAR_IN_OUT ", 
"snippet" : "Le contrôle détermine si un nombre défini de variables d'entrée ( VAR_INPUT ), variables de sortie ( VAR_OUTPUT ) ou VAR_IN_OUT -variables dans un bloc est dépassé. Vous définissez le nombre maximum dans une boîte de dialogue dans le paramètres du projet lorsque vous double-cliquez sur la ligne avec...", 
"body" : "Le contrôle détermine si un nombre défini de variables d'entrée ( VAR_INPUT ), variables de sortie ( VAR_OUTPUT ) ou VAR_IN_OUT -variables dans un bloc est dépassé. Vous définissez le nombre maximum dans une boîte de dialogue dans le paramètres du projet lorsque vous double-cliquez sur la ligne avec la règle. Raison : Il s'agit de vérifier les directives de programmation individuelles. De nombreuses directives de programmation prévoient un nombre maximal de paramètres pour les blocs. Trop de paramètres rendent le code illisible et les blocs difficiles à tester. Importance : Moyenne Règle PLCopen : CP23 Exemple Vous avez dans les paramètres du projet à la règle 166 pour VAR_IN_OUT -Variables un nombre maximum de 1 Sont définis. FUNCTION_BLOCK FB1\nVAR_INPUT\n xIn : BOOL;\nEND_VAR\nVAR_IN_OUT\n xInOut1 : BOOL;\n xInOut2 : BOOL;\nEND_VAR\n Sortie dans le messages voir: SA0166 : Trop de variables VAR_IN_OUT dans le POU 'FB1' " }, 
{ "title" : "SA0167 : Instances de bloc fonction temporaires ", 
"url" : "_san_rule_sa0167.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0167 : Instances de bloc fonction temporaires ", 
"snippet" : "Le contrôle détermine les instances de bloc fonction qui sont déclarées en tant que variables temporaires. Cela affecte les instances qui sont dans une méthode ou dans une fonction ou comme VAR_TEMP sont déclarés, et qui sont donc réinitialisés à chaque cycle de traitement ou à chaque appel de bloc....", 
"body" : "Le contrôle détermine les instances de bloc fonction qui sont déclarées en tant que variables temporaires. Cela affecte les instances qui sont dans une méthode ou dans une fonction ou comme VAR_TEMP sont déclarés, et qui sont donc réinitialisés à chaque cycle de traitement ou à chaque appel de bloc. Justification: Les blocs fonctionnels ont un état qui est généralement conservé sur plusieurs cycles automate. Une instance sur la pile n'existe que pendant la durée de l'appel de fonction. Par conséquent, il est rarement judicieux de créer une instance en tant que variable temporaire. Deuxièmement, les instances de blocs fonctionnels sont souvent volumineuses et nécessitent beaucoup d’espace sur la pile (qui est généralement limitée aux contrôleurs). Troisièmement, l'initialisation et souvent aussi la planification d'un bloc fonctionnel peuvent prendre beaucoup de temps. Importance : Moyenne Exemple PROGRAM PLC_PRG\nVAR\nEND_VAR\nVAR_TEMP\n yafb: AFB;\nEND_VAR FUNCTION Fun : INT\nVAR_INPUT\nEND_VAR\nVAR\n funafb: AFB;\nEND_VAR\n METHOD METH : INT\nVAR_INPUT\nEND_VAR\nVAR\n methafb: AFB; \/\/ SA0167\nEND_VAR Sortie dans le messages voir: SA0167 : Instance de bloc fonction temporaire : 'methafb' " }, 
{ "title" : "SA0168 : Affectations inutiles ", 
"url" : "_san_rule_sa0168.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0168 : Affectations inutiles ", 
"snippet" : "Recherche les affectations aux variables qui n'ont aucun effet dans le code. Raison : Si des valeurs sont affectées à une variable plusieurs fois sans que la variable soit évaluée entre les affectations, les premières affectations n'affectent pas le programme. Importance : Faible Exemple PROGRAM PLC...", 
"body" : "Recherche les affectations aux variables qui n'ont aucun effet dans le code. Raison : Si des valeurs sont affectées à une variable plusieurs fois sans que la variable soit évaluée entre les affectations, les premières affectations n'affectent pas le programme. Importance : Faible Exemple PROGRAM PLC_PRG\nVAR\n dwVal1 : DWORD;\n dwVal2 : DWORD;\nEND_VAR\n \/\/ unnecessary assignment\ndwVal1 := 1; \nIF dwVal2 > 100 THEN\n dwVal2 := 0;\n dwVal2 := dwVal2 + 1;\nEND_IF\ndwVal1 := 2; Sortie dans le messages voir: SA0168 : La variable 'dwVal1' est affectée, mais sa valeur n'est jamais utilisée. " }, 
{ "title" : "SA0169 : Sorties ignorées ", 
"url" : "_san_rule_sa0169.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0169 : Sorties ignorées ", 
"snippet" : "Détermine les sorties des méthodes et des fonctions qui ne sont pas spécifiées lorsque la méthode ou la fonction est appelée. Justification : les sorties ignorées peuvent indiquer des erreurs non gérées ou des appels de fonction inutiles puisque les résultats ne sont pas utilisés. Importance : Moyen...", 
"body" : "Détermine les sorties des méthodes et des fonctions qui ne sont pas spécifiées lorsque la méthode ou la fonction est appelée. Justification : les sorties ignorées peuvent indiquer des erreurs non gérées ou des appels de fonction inutiles puisque les résultats ne sont pas utilisés. Importance : Moyenne Exemple FUNCTION Fun1\nVAR_INPUT\n bIn : BOOL;\nVAR_END\nVAR_OUTPUT\n bOut : BOOL;\nEND_VA\n ; PROGRAM PLC_PRG\nVAR\n bValue :BOOl;\nEND_VAR\n Fun1(bIn : TRUE);\n Sortie dans le messages voir: SA0169 : La sortie 'bOut' est ignorée lors de l'appel " }, 
{ "title" : "SA0170 : L'adresse d'une variable de sortie ne doit pas être utilisée ", 
"url" : "_san_rule_sa0170.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0170 : L'adresse d'une variable de sortie ne doit pas être utilisée ", 
"snippet" : "Détecte les emplacements de code où l'adresse d'une variable de sortie ( VAR_OUTPUT , VAR_IN_OUT ) d'un bloc fonctionnel est utilisé. Justification : Il n'est pas permis d'utiliser l'adresse d'une sortie d'un bloc fonction de la manière suivante : passant par ADR -Opérateur Au moyen de REF= Exceptio...", 
"body" : "Détecte les emplacements de code où l'adresse d'une variable de sortie ( VAR_OUTPUT , VAR_IN_OUT ) d'un bloc fonctionnel est utilisé. Justification : Il n'est pas permis d'utiliser l'adresse d'une sortie d'un bloc fonction de la manière suivante : passant par ADR -Opérateur Au moyen de REF= Exception : Aucune erreur n'est signalée si la sortie est utilisée dans le même bloc fonction. Importance : Moyenne Exemple Bloc fonctionnel FB1 a la VAR_OUTPUT variable iOutVal : INT; Les accès suivants dans un autre bloc génèrent l'erreur SA0170 : \/\/FB1_inst is of type FB1\naddr1 := ADR(FB1_inst.iOutVal); \/\/SA0170\nrefINT REF= FB1_inst.iOutVal; \/\/SA0179\n Accès ultérieur directement dans le bloc fonctionnel FB1 produit également l'erreur : \/\/other is a POINTER TO FB1\nptr := ADR(other^.iOutVal); \/\/SA0170 Les accès suivants directement dans le bloc fonction FB1 produire aucune erreur : \/\/iInputVal is a VAR_INPUT of FB1\niOutVal := iInputVal; \n\/\/ptr is a POINTER TO INT\nptr := ADR(THIS^.iOutVal); \nptr := ADR(iOutVal); Sortie dans le messages voir: SA0170 : Ne doit pas prendre l'adresse d'une variable de sortie " }, 
{ "title" : "SA0171 : Les énumérations doivent avoir l'attribut 'strict' ", 
"url" : "_san_rule_sa0171.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0171 : Les énumérations doivent avoir l'attribut 'strict' ", 
"snippet" : "Récupère les déclarations d'énumérations qui ne correspondent pas à l'attribut {attribute 'strict'} sont prévus. Raison : L'attribut {attribute 'strict'} génère des erreurs de compilation si le code enfreint les règles strictes de programmation d'énumération. Par défaut, lors de la création d'une no...", 
"body" : "Récupère les déclarations d'énumérations qui ne correspondent pas à l'attribut {attribute 'strict'} sont prévus. Raison : L'attribut {attribute 'strict'} génère des erreurs de compilation si le code enfreint les règles strictes de programmation d'énumération. Par défaut, lors de la création d'une nouvelle énumération, la déclaration est automatiquement créée avec l'attribut 'strict' Erreur. Pour plus d'informations, voir : Énumération des types de données Importance : Élevée Exemple TYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE Sortie dans le messages voir: SA0171 : L'énumération doit avoir l'attribut \"strict\" Aucune violation des règles de programmation : {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE " }, 
{ "title" : "SA0172 : Tentative possible d'accès en dehors des limites de la baie ", 
"url" : "_san_rule_sa0172.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0172 : Tentative possible d'accès en dehors des limites de la baie ", 
"snippet" : "Détecte l'accès possible à un index de tableau en dehors des limites du tableau. Souvent, la plage de l'indice de tableau est dépassée dans FOR boucles où la variable index est utilisée pour accéder à un index de tableau. Importance : Élevée Exemple PROGRAM Test VAR_TEMP iIndex: INT; arUSINT: Array[...", 
"body" : "Détecte l'accès possible à un index de tableau en dehors des limites du tableau. Souvent, la plage de l'indice de tableau est dépassée dans FOR boucles où la variable index est utilisée pour accéder à un index de tableau. Importance : Élevée Exemple PROGRAM Test\nVAR_TEMP\n iIndex: INT;\n arUSINT: Array[0..10] OF INT;\nEND_VAR\n FOR iIndex := INT#0 TO INT#50 DO\n arUSINT[iIndex] := 0;\nEND_FOR Sortie dans le messages voir: SA0172 : Tentative possible d'accès en dehors des limites de la baie " }, 
{ "title" : "SA0175 : Opération suspecte sur la chaîne ", 
"url" : "_san_rule_sa0175.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0175 : Opération suspecte sur la chaîne ", 
"snippet" : "N'activez pas toujours cette règle. Activez la règle uniquement lorsque cela est nécessaire pour trouver les emplacements dans le code qui doivent être vérifiés lors de la conversion au codage UTF-8. Vérifie si l'option de projet Encodage UTF-8 pour STRING peut être activé. C'est le cas lorsqu'aucun...", 
"body" : "N'activez pas toujours cette règle. Activez la règle uniquement lorsque cela est nécessaire pour trouver les emplacements dans le code qui doivent être vérifiés lors de la conversion au codage UTF-8. Vérifie si l'option de projet Encodage UTF-8 pour STRING peut être activé. C'est le cas lorsqu'aucun emplacement de code avec des opérations suspectes n'est trouvé. Lors du passage au codage UTF-8, les 127 premiers caractères correspondent au codage ASCII. Cependant, tous les autres caractères sont codés avec plus d'un octet. Cela peut entraîner un changement de comportement lors du traitement des chaînes. Par conséquent, un littéral de chaîne contenant des caractères non ASCII peut devenir plus long. Ou l'accès dans une chaîne par index peut accéder au mauvais élément. Enfin, même l'accès à un décalage d'octet non valide peut se produire. Lorsque la règle est active, tous les emplacements de code contenant l'une des constructions suivantes sont signalés : Indexer l'accès à une chaîne d'octets Exemple: str[2] Message: SA0175 : Énumération avec l'attribut 'strict' : Opération suspecte sur la chaîne : accès à l'index '<expression>' Accès d'adresse aux chaînes à un octet Exemple: ADR(str) Message: SA0175 : Énumération avec l'attribut 'strict' : Opération suspecte sur la chaîne : Accès possible à l'index '<expression>' Appel des fonctions de chaîne de la Standard bibliothèque, sauf en appelant le CONCAT et LEN les fonctions Message: SA0175 : Énumération avec l'attribut 'strict' : Opération suspecte sur la chaîne : Accès possible à l'index '<expression>' Littéral d'octet contenant des caractères non ASCII Exemples: str := '99€';\nstr :='Ä'; Message: SA0175 : Opération suspecte sur une chaîne : le littéral '<literal>' contient des caractères non-ASCII " }, 
{ "title" : "SA0180 : La plage d'index ne couvre pas l'intégralité du tableau ", 
"url" : "_san_rule_sa0180.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Des règles \/ SA0180 : La plage d'index ne couvre pas l'intégralité du tableau ", 
"snippet" : "Détecte les tableaux avec une plage d'index incomplètement couverte Les tableaux sont souvent gérés dans des boucles, où l'index de boucle indexe le tableau de manière à ce que tous les composants du tableau soient accédés sans interruption. Ceci est donné si l'index de boucle et l'index de tableau ...", 
"body" : "Détecte les tableaux avec une plage d'index incomplètement couverte Les tableaux sont souvent gérés dans des boucles, où l'index de boucle indexe le tableau de manière à ce que tous les composants du tableau soient accédés sans interruption. Ceci est donné si l'index de boucle et l'index de tableau sont les mêmes dans toutes les dimensions. Si la plage d'index ne couvre pas complètement le tableau, cela indique des composants non gérés dans le tableau. Importance : moyenne Exemple {attribute 'do-analysis'}\nPROGRAM PLC_PRG\nVAR\n a : INT;\n arWord : ARRAY [0..100] OF WORD;\nEND_VAR\n\/\/Implementation\nFOR a := INT#1 TO INT#100 BY 1 DO \/\/SA0180: Lower range is not reached\n\tarWord[a] := INT_TO_WORD(a);\nEND_FOR;\n;\n Sortie dans le messages voir: SA0180 : La plage d'index ne couvre pas l'ensemble du tableau " }, 
{ "title" : "Métrique ", 
"url" : "_san_reference_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique ", 
"snippet" : "Description détaillée des métriques fournies par CODESYS Static Analysis Le Taille du code , Taille variable , Taille de la pile , et Nombre d'appels les métriques ne sont signalées que pour les POU des bibliothèques intégrées au projet....", 
"body" : "Description détaillée des métriques fournies par CODESYS Static Analysis Le Taille du code , Taille variable , Taille de la pile , et Nombre d'appels les métriques ne sont signalées que pour les POU des bibliothèques intégrées au projet. " }, 
{ "title" : "Métrique : Taille du code (nombre d'octets) ", 
"url" : "_san_reference_metrics.html#UUID-35adc4d5-9253-44d6-f130-aab7171bff69", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : Taille du code (nombre d'octets) ", 
"snippet" : "Taille du code (nombre d'octets) Catégories : Informatif, Efficacité Nombre d'octets qu'un bloc fonctionnel contribue au code d'application Le numéro dépend également du générateur de code. Par exemple, le générateur de code pour les processeurs ARM génère généralement plus d'octets que le générateu...", 
"body" : "Taille du code (nombre d'octets) Catégories : Informatif, Efficacité Nombre d'octets qu'un bloc fonctionnel contribue au code d'application Le numéro dépend également du générateur de code. Par exemple, le générateur de code pour les processeurs ARM génère généralement plus d'octets que le générateur de code pour les processeurs x86. " }, 
{ "title" : "Métrique : Taille variable (nombre d'octets) ", 
"url" : "_san_reference_metrics.html#UUID-b07882e2-be28-fe1e-eb10-ed5defcf3c74", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : Taille variable (nombre d'octets) ", 
"snippet" : "Taille variable (nombre d'octets) Catégories : Informatif, Efficacité Taille de la mémoire statique utilisée par l'objet Pour les blocs fonction, il s'agit de la taille utilisée pour une instance du bloc fonction (qui peut inclure des espaces mémoire, en fonction de l'alignement de la mémoire). Pour...", 
"body" : "Taille variable (nombre d'octets) Catégories : Informatif, Efficacité Taille de la mémoire statique utilisée par l'objet Pour les blocs fonction, il s'agit de la taille utilisée pour une instance du bloc fonction (qui peut inclure des espaces mémoire, en fonction de l'alignement de la mémoire). Pour les programmes, les fonctions et les listes de variables globales, il s'agit de la somme de la taille de toutes les variables statiques. Exemple FUNCTION FUN1 : INT\nVAR_INPUT\n a,b : INT;\nEND_VAR\nVAR\n c,d : INT;\nEND_VAR\nVAR_STAT\n f,g,h : INT;\nEND_VAR La fonction possède 3 variables statiques de type INT (f , g , et h ), dont chacun nécessite 2 octets de mémoire. Par conséquent, FUN1 a une taille variable de 6 octets. " }, 
{ "title" : "Métrique : Taille de la pile (nombre d'octets) ", 
"url" : "_san_reference_metrics.html#UUID-52e032c0-e190-f5c0-344b-e6c04694a3ef", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : Taille de la pile (nombre d'octets) ", 
"snippet" : "Taille de la pile (nombre d'octets) Catégories : Informatif, Efficacité, Fiabilité Nombre d'octets nécessaires à l'appel d'une fonction ou d'un bloc fonctionnel Les variables d'entrée et les variables de sortie sont alignées sur la mémoire. Cela peut créer un écart entre ces variables et les variabl...", 
"body" : "Taille de la pile (nombre d'octets) Catégories : Informatif, Efficacité, Fiabilité Nombre d'octets nécessaires à l'appel d'une fonction ou d'un bloc fonctionnel Les variables d'entrée et les variables de sortie sont alignées sur la mémoire. Cela peut créer un écart entre ces variables et les variables locales. Cet écart est compté. Les valeurs de retour des fonctions appelées qui ne rentrent pas dans un registre sont placées sur la pile. La plus grande de ces valeurs détermine la mémoire supplémentaire allouée, qui compte également. Les fonctions ou blocs fonctionnels appelés dans les POU concernés ont leur propre cadre de pile. Par conséquent, la mémoire de ces appels ne compte pas. Selon le générateur de code utilisé, les résultats intermédiaires des calculs utilisent également la pile. Ces résultats ne sont pas comptabilisés. Exemple \/\/Declaration\nFUNCTION FUN1 : INT\nVAR_INPUT\n a,b : INT;\nEND_VAR\nVAR\n c,d,e : INT;\nEND_VAR\nVAR_STAT\n f,g,h : INT;\nEND_VAR\n\n\/\/Implementation\nc := b;\nd := a;\ne := a+b; Hypothèse : Pour le calcul, supposons un CODESYS Control Win qui utilise le générateur de code x86. L'exemple ci-dessus a une taille d'appelant de 8 octets : 4 octets pour les deux INT inputs et 4 octets pour la valeur de retour. L'appareil a un alignement de pile de 4 octets, de sorte qu'il y a un espace de 2 octets. La taille de l'appelant est de 8 octets : trois variables locales de 2 octets chacune plus l'espace de 2 octets pour l'alignement de la pile. En conséquence, la taille totale de la pile de FUN1 fait 16 octets. VAR_STAT n'est pas stocké sur la pile et n'augmente donc pas la taille de la pile d'un POU. " }, 
{ "title" : "Métrique : Nombre d'appels (Appels) ", 
"url" : "_san_reference_metrics.html#UUID-652fc3dc-10b7-711b-cea7-9b006e6249b5", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : Nombre d'appels (Appels) ", 
"snippet" : "Nombre d'appels (appels) Catégorie : Informatif Nombre d'appels du POU sous Unité de programme Exemple \/\/Declaration PLC_PRG PROGRAM PLC_PRG VAR myFB : FB1; END_VAR \/\/Implementation myFB(b := FALSE); \/\/Declaration FB1 FUNCTION_BLOCK FB1 VAR_INPUT b : BOOL; END_VAR VAR i : INT; END_VAR \/\/Implementati...", 
"body" : "Nombre d'appels (appels) Catégorie : Informatif Nombre d'appels du POU sous Unité de programme Exemple \/\/Declaration PLC_PRG\nPROGRAM PLC_PRG\nVAR\n myFB : FB1;\nEND_VAR\n\n\/\/Implementation\nmyFB(b := FALSE); \/\/Declaration FB1\nFUNCTION_BLOCK FB1\nVAR_INPUT\n b : BOOL;\nEND_VAR\nVAR\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH(i);\nIF b THEN\n METH(i*i);\nEND_IF\n \/\/Declaration FB1.METH\nMETHOD METH : BOOL\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH := i >= 42; Si PLC_PRG est appelé dans une tâche, alors cet appel est également compté. FB1 a exactement un appel (en PLC_PRG ). METH a deux appels, tous deux en FB1 . " }, 
{ "title" : "Métrique : Nombre d'appels depuis des tâches (Tâches) ", 
"url" : "_san_reference_metrics.html#UUID-3768e9b9-fdef-e8c5-d81a-3ab94c3eed82", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : Nombre d'appels depuis des tâches (Tâches) ", 
"snippet" : "Nombre d'appels de tâches (tâches) Catégories :  Maintenabilité, Fiabilité Nombre de tâches ( Tâches ) où le POU spécifié sous Unité de programme est appelé Dans le cas des blocs fonctionnels, le nombre de tâches est compté dans lequel le bloc fonctionnel lui-même ou n'importe quel bloc fonctionnel ...", 
"body" : "Nombre d'appels de tâches (tâches) Catégories :  Maintenabilité, Fiabilité Nombre de tâches ( Tâches ) où le POU spécifié sous Unité de programme est appelé Dans le cas des blocs fonctionnels, le nombre de tâches est compté dans lequel le bloc fonctionnel lui-même ou n'importe quel bloc fonctionnel dans l'arbre d'héritage du bloc fonctionnel est appelé. Pour les méthodes et les actions, le nombre de tâches dans lesquelles le bloc fonctionnel (parent) est appelé est affiché. Exemple FUNCTION_BLOCK FB\n\/\/... FUNCTION_BLOCK FB2 EXTENDS FB\n\/\/... FUNCTION_BLOCK FB3 EXTENDS FB2\n\/\/... Chaque bloc fonction est appelé individuellement PROGRAM . Chaque PROGRAM a sa propre tâche. Le Tâches appelées la métrique renvoie en 1 pour FB3 et 2 pour FB2 parce que les appels de FB3 et FB2 sont comptés. La métrique donne 3 pour FB parce que dans ce cas, les appels de FB3 , FB2 , et FB sont comptés. " }, 
{ "title" : "Métrique : Nombre de variables globales utilisées (globales) ", 
"url" : "_san_reference_metrics.html#UUID-04068c53-4046-0979-468b-866b1a155a8a", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : Nombre de variables globales utilisées (globales) ", 
"snippet" : "Nombre de variables globales utilisées (Globals) Catégories : Maintenabilité, Réutilisabilité Nombre de variables globales utilisées dans le POU sous Unité de programme Exemple \/\/GVL VAR_GLOBAL gvla : INT; gvlb : INT; gvlc : INT; END_VAR \/PRG declaration PROGRAM PRG VAR x : INT := GVL.gvlc; y : INT;...", 
"body" : "Nombre de variables globales utilisées (Globals) Catégories : Maintenabilité, Réutilisabilité Nombre de variables globales utilisées dans le POU sous Unité de programme Exemple \/\/GVL\nVAR_GLOBAL\n gvla : INT;\n gvlb : INT;\n gvlc : INT;\nEND_VAR \/PRG declaration\nPROGRAM PRG\nVAR\n x : INT := GVL.gvlc;\n y : INT;\nEND_VAR\n\n\/\/PRG implementation\nx := GVL.gvla;\ny := GVL.gvla*GVL.gvlb; Le PRG le programme utilise 3 variables de GVL : gvla , gvlb , et gvlc . " }, 
{ "title" : "Métrique : Nombre d'accès directs aux adresses (IO) ", 
"url" : "_san_reference_metrics.html#UUID-792a6162-1022-f930-dadb-104aa5a51709", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : Nombre d'accès directs aux adresses (IO) ", 
"snippet" : "Nombre d'accès à l'adresse directe (IO) Catégories :  Réutilisabilité, Maintenabilité Nombre d'accès à l'adresse directe ( IO ) dans la mise en œuvre de l'objet. Exemple \/\/Declaration PROGRAM PRG VAR xVar : BOOL:= %IX0.0; \/\/ +1 direct address access byVar : BYTE; END_VAR \/\/Implementation xVar := %IX...", 
"body" : "Nombre d'accès à l'adresse directe (IO) Catégories :  Réutilisabilité, Maintenabilité Nombre d'accès à l'adresse directe ( IO ) dans la mise en œuvre de l'objet. Exemple \/\/Declaration\nPROGRAM PRG\nVAR\n xVar : BOOL:= %IX0.0; \/\/ +1 direct address access\n byVar : BYTE;\nEND_VAR\n\n\/\/Implementation\nxVar := %IX0.0; \/\/ +1 direct address access\n%QX0.0 := xVar; \/\/ +1\n%MX0.1 := xVar; \/\/ +1\n%MB1 := byVar; \/\/ +1 L'exemple dispose de 5 accès directs aux adresses. " }, 
{ "title" : "Métrique : Nombre de variables locales (Locals) ", 
"url" : "_san_reference_metrics.html#UUID-f738f257-cf3a-1e7c-979e-1d6b4733c2d9", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : Nombre de variables locales (Locals) ", 
"snippet" : "Nombre de variables locales (Locales) Catégories : Informatif, Efficacité Nombre de variables déclarées dans le VAR zone du POU. Les variables héritées ne sont pas comptées. Exemple \/\/Declaration FUNCTION_BLOCK FB VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR i,j,k,l : INT; m,n,o : BOOL; END_VAR Dans le ...", 
"body" : "Nombre de variables locales (Locales) Catégories : Informatif, Efficacité Nombre de variables déclarées dans le VAR zone du POU. Les variables héritées ne sont pas comptées. Exemple \/\/Declaration\nFUNCTION_BLOCK FB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i,j,k,l : INT;\n m,n,o : BOOL;\nEND_VAR\n Dans le bloc fonction, 7 variables locales sont déclarées. " }, 
{ "title" : "Métrique : Nombre de variables d'entrée (entrées) ", 
"url" : "_san_reference_metrics.html#UUID-03e01655-9ac0-74f4-3fd7-cf22f23db4f6", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : Nombre de variables d'entrée (entrées) ", 
"snippet" : "Nombre de variables d'entrée (Entrées) Catégories :  Maintenabilité, Réutilisabilité Limite supérieure par défaut pour le SA0166 règle : 10 Nombre de variables déclarées dans VAR_INPUT de l’unité de programme. Les variables d'entrée héritées ne sont pas comptées. Exemples FUNCTION_BLOCK FB VAR_INPUT...", 
"body" : "Nombre de variables d'entrée (Entrées) Catégories :  Maintenabilité, Réutilisabilité Limite supérieure par défaut pour le SA0166 règle : 10 Nombre de variables déclarées dans VAR_INPUT de l’unité de programme. Les variables d'entrée héritées ne sont pas comptées. Exemples FUNCTION_BLOCK FB\nVAR_INPUT\n i : INT;\n r : REAL;\nEND_VAR\n Dans le bloc fonction, 2 variables d'entrée sont déclarées : i et r . METHOD METH : BOOL\nVAR_INPUT\n j : INT;\n l : LREAL;\nEND_VAR\n La méthode a 2 entrées : j et l " }, 
{ "title" : "Métrique : Nombre de variables de sortie (sorties) ", 
"url" : "_san_reference_metrics.html#UUID-7bba3bc6-748c-311d-7f8c-4878fdce9da0", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : Nombre de variables de sortie (sorties) ", 
"snippet" : "Nombre de variables de sortie (Sorties) Catégories :  Maintenabilité, Réutilisabilité Limite supérieure par défaut pour le SA0166 règle : 10 Nombre de variables dans VAR_OUTPUT de l'unité de programme Dans le cas des blocs fonction, il s'agit du nombre de variables de sortie personnalisées ( VAR_OUT...", 
"body" : "Nombre de variables de sortie (Sorties) Catégories :  Maintenabilité, Réutilisabilité Limite supérieure par défaut pour le SA0166 règle : 10 Nombre de variables dans VAR_OUTPUT de l'unité de programme Dans le cas des blocs fonction, il s'agit du nombre de variables de sortie personnalisées ( VAR_OUTPUT ). Dans le cas des méthodes et des fonctions, il s'agit du nombre de variables de sortie personnalisées plus une si elles ont une valeur de retour. La valeur de retour est également prise en compte. Les variables de sortie héritées ne sont pas comptées. Un nombre élevé de variables de sortie indique une violation du principe de responsabilité unique. Exemples FUNCTION_BLOCK FB\nVAR_OUTPUT\n i : INT; \/\/ +1 output\n r : REAL; \/\/ +1 output\nEND_VAR Le bloc fonction possède 2 variables de sortie : i et r METHOD METH : BOOL\nVAR_INPUT\n j : INT;\n l : LREAL;\nEND_VAR La méthode a 3 sorties : METH , j , et l METHOD METH1 \/\/ +0 outputs (no return type)\nVAR_OUTPUT\n ar : ARRAY[0..10] OF INT; \/\/ +1 output\n l : LREAL; \/\/ +1 output\nEND_VAR Le METH1 La méthode a 2 sorties : ar et i " }, 
{ "title" : "Métrique : NOS – Nombre d’instructions ", 
"url" : "_san_reference_metrics.html#UUID-82054fe5-816d-0c12-0afa-11dabf2c47b3", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : NOS – Nombre d’instructions ", 
"snippet" : "NOS – Nombre de déclarations Catégorie : Informatif Nombre d'instructions dans l'implémentation d'un bloc fonctionnel, d'une fonction ou d'une méthode Les instructions dans la déclaration, les instructions vides ou les pragmas ne sont pas comptés. Exemple \/\/Declaration: FUNCTION POU : BOOL VAR_INPUT...", 
"body" : "NOS – Nombre de déclarations Catégorie : Informatif Nombre d'instructions dans l'implémentation d'un bloc fonctionnel, d'une fonction ou d'une méthode Les instructions dans la déclaration, les instructions vides ou les pragmas ne sont pas comptés. Exemple \/\/Declaration:\nFUNCTION POU : BOOL\nVAR_INPUT\nEND_VAR\nVAR\n c : INT := 100; \/\/ statements in the declaration are not counted\nEND_VAR\nVAR_OUTPUT\n test : INT;\n i : INT;\nEND_VAR\n\n\/\/Implementation:\nIF TRUE THEN \/\/if statement: +1\n test := 0; \/\/ +1\nEND_IF\n\nWHILE test = 1 DO \/\/while statement: +1\n ; \/\/ empty statements do not add to the statement count\nEND_WHILE\n\nFOR c := 0 TO 10 BY 2 DO \/\/for statement: +1\n i := i+i; \/\/ +1\nEND_FOR\n\n{text 'simple text pragma'} \/\/pragmas are not counted\ntest := 2; \/\/+1 L'exemple comporte 6 instructions. " }, 
{ "title" : "Métrique : Pourcentage de commentaires ", 
"url" : "_san_reference_metrics.html#UUID-abd88d31-c33e-db93-0f69-bec1a38795f7", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : Pourcentage de commentaires ", 
"snippet" : "Pourcentage de commentaire Catégorie :  Maintenabilité Pourcentage de commentaires dans le code source Ce nombre est calculé selon la formule suivante : Pourcentage = 100 * <caractères dans les commentaires> \/ <somme des caractères dans le code source et des caractères dans les commentaires> Plusieu...", 
"body" : "Pourcentage de commentaire Catégorie :  Maintenabilité Pourcentage de commentaires dans le code source Ce nombre est calculé selon la formule suivante : Pourcentage = 100 * <caractères dans les commentaires> \/ <somme des caractères dans le code source et des caractères dans les commentaires> Plusieurs espaces consécutifs dans le code source sont comptés comme un seul espace, ce qui évite une pondération élevée du code source indenté. Pour les objets vides (pas de code source ni de commentaires), un pourcentage de 0 est renvoyé. Exemple Partie déclaration : FUNCTION_BLOCK FB \/\/comments in the declaration are counted, as well\nVAR_TEMP\n hugo : INT;\nEND_VAR Mise en œuvre: hugo := hugo + 1;\n\/\/Declaration: 40 letters non comment; 50 letters comment\n\/\/Implementation: 13 letters non comment; 152 letters comment\n\/\/ 100 * 202 \/ 255 -> 79% comments Le calcul du pourcentage 100 * 202 \/ 255 renvoie 79%. " }, 
{ "title" : "Métrique : Complexité (McCabe) ", 
"url" : "_san_reference_metrics.html#UUID-ea21160c-97be-30d4-7748-0adac68532a8", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : Complexité (McCabe) ", 
"snippet" : "Complexité (McCabe) Catégorie :  Testabilité Limite supérieure recommandée : 10 La complexité cyclomatique selon McCabe est une mesure de la lisibilité et de la testabilité du code source. Il est calculé en comptant le nombre de branches binaires dans le flux de contrôle du POU. Cependant, la comple...", 
"body" : "Complexité (McCabe) Catégorie :  Testabilité Limite supérieure recommandée : 10 La complexité cyclomatique selon McCabe est une mesure de la lisibilité et de la testabilité du code source. Il est calculé en comptant le nombre de branches binaires dans le flux de contrôle du POU. Cependant, la complexité cyclomatique pénalise le branchement élevé, car le branchement élevé augmente le nombre de cas de test requis pour une couverture de test élevée. Exemple: IF déclaration \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nIF b1 THEN \/\/ +1 for the THEN branch\n ;\n ELSIF b2 THEN \/\/ +1 for the THEN branch of the IF inside the else\n ;\nELSE \n IF b3 OR b4 THEN \/\/ +1 for the THEN branch\n ;\n END_IF\nEND_IF L'extrait de code a une complexité cyclomatique de 4. Exemple : CASE déclaration \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nCASE a OF\n 1:\t; \/\/ +1\n 2:\t; \/\/ +1\n 3,4,5:\t; \/\/ +1\nELSE \/\/ the ELSE statement does not increase the cyclomatic complexity\n ;\nEND_CASE L'extrait de code a une complexité cyclomatique de 4. Exemple : Instruction de boucle \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nWHILE b1 DO \/\/ +1 for the WHILE loop\n ;\nEND_WHILE\n\nREPEAT \/\/ +1 for the REPEAT loop\n ;\n UNTIL b2\nEND_REPEAT\n\nFOR a := 0 TO 100 BY 2 DO \/\/ +1 for the REPEAT loop\n ;\nEND_FOR L'extrait de code a une complexité cyclomatique de 4. Exemple : Autres déclarations Les déclarations suivantes augmentent également la complexité cyclomatique : \/\/Declaration\nFUNCTION FUN : STRING\nVAR_INPUT\n condition_return : BOOL;\n condition_jmp : BOOL;\nEND_VAR\nVAR\nEND_VAR\n\n\/\/Implementation\n\/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nJMP(condition_jmp) lbl; \/\/Conditional jumps increase the cyclomatic complexity by 1\n\nFUN := 'u';\nRETURN(condition_return); \/\/Conditional returns increase the cyclomatic complexity by 1, too\n\nlbl:\nFUN := 't';\n L'extrait de code a une complexité cyclomatique de 3. " }, 
{ "title" : "Métrique : complexité cognitive ", 
"url" : "_san_reference_metrics.html#UUID-cd064f18-bd35-1d86-1bd4-2ae3a8fe344f", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : complexité cognitive ", 
"snippet" : "Complexité cognitive Catégorie :  Maintenabilité Limite supérieure par défaut pour la règle SA0178 correspondante : 20 La complexité cognitive est une mesure de la lisibilité et de l'intelligibilité du code source introduite par Sonarsource™ en 2016. Cependant, elle pénalise une imbrication importan...", 
"body" : "Complexité cognitive Catégorie :  Maintenabilité Limite supérieure par défaut pour la règle SA0178 correspondante : 20 La complexité cognitive est une mesure de la lisibilité et de l'intelligibilité du code source introduite par Sonarsource™ en 2016. Cependant, elle pénalise une imbrication importante du flux de contrôle et des expressions booléennes complexes. La complexité cognitive est calculée uniquement pour les implémentations de textes structurés. Les exemples suivants montrent comment la complexité cognitive est calculée. Le Afficher la complexité cognitive pour l'éditeur actuel La commande peut être utilisée pour afficher en plus les incréments du texte structuré. Exemple : Flux de contrôle Les instructions qui manipulent le flux de contrôle augmentent la complexité cognitive de 1 IF TRUE THEN \/\/ +1 cognitive complexity\n ;\nEND_IF\n\nWHILE TRUE DO \/\/+1 cognitive complexity\n ;\nEND_WHILE\n\nFOR i := 0 TO 10 BY 1 DO \/\/+1 cognitive complexity\n ;\nEND_FOR\n\nREPEAT \/\/+1 cognitive complexity\n ;\nUNTIL TRUE\nEND_REPEAT L'extrait de code a une complexité cognitive de 4. Exemple : Imbrication du flux de contrôle Lors de l'imbrication du flux de contrôle, un incrément de 1 est ajouté pour chaque niveau d'imbrication. IF TRUE THEN \/\/+1 cognitive complexity\n WHILE TRUE DO \/\/+2 (+1 for the loop itself, +1 for the nesting inside the IF)\n FOR i := 0 TO 10 BY 1 DO \/\/+3 (+1 for the FOR loop itself, +2 for the nesting inside the WHILE and the IF)\n\t\t\t;\n END_FOR\n END_WHILE\n\n REPEAT \/\/+2 (+1 for the loop itself, +1 for the nesting inside the IF)\n ;\n UNTIL TRUE\n END_REPEAT\nEND_IF L'extrait de code a une complexité cognitive de 8. Exemple : Expression booléenne Les expressions booléennes jouant un rôle majeur dans la compréhension du code source, elles sont également prises en compte lors du calcul de la complexité cognitive. Comprendre les expressions booléennes associées au même opérateur booléen n'est pas aussi difficile que comprendre une expression booléenne contenant des opérateurs booléens alternés. Par conséquent, toute chaîne d’opérateurs booléens identiques dans une expression augmente la complexité cognitive. b := b1; \/\/+0: a simple expression, containing no operators, has no increment\n L'expression simple sans opérateur a un incrément de 0. b := b1 AND b2; \/\/+1: one chain of AND operators L'expression avec un AND le lien a un incrément de 1. b := b1 AND b2 AND b3; \/\/+1: one more AND, but the number of chains of operators does not change L'expression a un de plus AND . Mais comme il s'agit du même opérateur, le numéro de la chaîne formée avec des opérateurs identiques ne change pas. b := b1 AND b2 OR b3; \/\/+2: one chain of AND operators and one chain of OR operators L'expression a une chaîne de AND opérateurs et une chaîne de OR les opérateurs. Cela donne un incrément de 2. b := b1 AND b2 OR b3 AND b4 AND b5; \/\/+3 L'extrait de code a un incrément de 3. b := b1 AND NOT b2 AND b3; \/\/+1: the unary NOT operator is not considered in the cognitive complexity L'opérateur unaire NOT n’est pas considéré dans la complexité cognitive. Exemple : Autres instructions avec un incrément Le texte structuré contient des instructions et expressions supplémentaires qui modifient le flux de contrôle. Les énoncés suivants sont pénalisés par un accroissement de complexité cognitive : aNewLabel:\nx := MUX(i, a,b,c); \/\/+1 for MUX operator\ny := SEL(b, i,j); \/\/+1 for SEL operator\nJMP aNewLabel; \/\/+1 for JMP to label EXIT et RETURN les déclarations n’augmentent pas la complexité cognitive. " }, 
{ "title" : "Métrique : DIT – Profondeur de l’arbre d’héritage ", 
"url" : "_san_reference_metrics.html#UUID-c7e1c296-e321-f999-8ed7-9713ebdb50fc", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : DIT – Profondeur de l’arbre d’héritage ", 
"snippet" : "DIT – Profondeur de l’arbre d’héritage Catégorie :  Maintenabilité Nombre d'héritages jusqu'à ce qu'un bloc fonction soit atteint qui n'étend aucun autre bloc fonction Exemple FUNCTION_BLOCK MyBaseFB \/\/ ... FUNCTION_BLOCK AChildFB EXTENDS MyBaseFB \/\/ ... FUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB...", 
"body" : "DIT – Profondeur de l’arbre d’héritage Catégorie :  Maintenabilité Nombre d'héritages jusqu'à ce qu'un bloc fonction soit atteint qui n'étend aucun autre bloc fonction Exemple FUNCTION_BLOCK MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AChildFB EXTENDS MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB\n\/\/ ... MyBaseFB a un DIT de 0 car il s’agit lui-même d’un bloc fonction qui n’étend aucun autre bloc fonction. Pour AChildFB , le DIT est 1 car une étape est nécessaire pour arriver à MyBaseFB . AGrandChildFB a un DIT de 2 : une étape est nécessaire pour AChildFB et un autre à MyBaseFB . " }, 
{ "title" : "Métrique : NOC – Nombre d’enfants ", 
"url" : "_san_reference_metrics.html#UUID-04314eaf-28e7-40ea-0aa9-e7f46e79bfa0", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : NOC – Nombre d’enfants ", 
"snippet" : "CNP – Nombre d'enfants Catégories :  Réutilisabilité, Maintenabilité Nombre de blocs fonctionnels qui étendent le bloc fonctionnel de base donné. Les blocs fonctionnels qui étendent indirectement un bloc fonctionnel de base ne sont pas pris en compte. Exemple FUNCTION_BLOCK MyBaseFB \/\/ ... FUNCTION_...", 
"body" : "CNP – Nombre d'enfants Catégories :  Réutilisabilité, Maintenabilité Nombre de blocs fonctionnels qui étendent le bloc fonctionnel de base donné. Les blocs fonctionnels qui étendent indirectement un bloc fonctionnel de base ne sont pas pris en compte. Exemple FUNCTION_BLOCK MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AChildFB EXTENDS MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB\n\/\/ ... MyBaseFB n'a qu'un (1) objet enfant : AChildFB , qui à son tour a un objet enfant, AGrandChildFB . AGrandChildFB n'a pas d'objets enfants. " }, 
{ "title" : "Métriques : RFC – Réponse pour la classe ", 
"url" : "_san_reference_metrics.html#UUID-0fcfc138-e361-a392-6fbe-11240e7a6e2a", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métriques : RFC – Réponse pour la classe ", 
"snippet" : "Réponse pour la classe (RFC) Catégories :  Maintenabilité, Réutilisabilité Nombre de POU, méthodes ou actions différentes qui sont appelées et génèrent donc une réponse du POU spécifié sous Unité de programme Exemple \/\/Declaration FB1 FUNCTION_BLOCK FB1 VAR d,x,y : INT; END_VAR \/\/Implementation x :=...", 
"body" : "Réponse pour la classe (RFC) Catégories :  Maintenabilité, Réutilisabilité Nombre de POU, méthodes ou actions différentes qui sont appelées et génèrent donc une réponse du POU spécifié sous Unité de programme Exemple \/\/Declaration FB1\nFUNCTION_BLOCK FB1\nVAR\n d,x,y : INT;\nEND_VAR\n\n\/\/Implementation\nx := METH(d+10);\ny := FUN(42, 0.815); \/\/Declaration FB1.METH\nMETHOD METH : INT\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH := FUN(CUBE(i), 3.1415); \/\/Declaration CUBE\nFUNCTION CUBE : INT\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nCUBE := i*i*i; \/\/Declaration Function FUN\nFUNCTION FUN : INT\nVAR_INPUT\n a : INT;\n lr : LREAL;\nEND_VAR\n\n\/\/Implementation\nFUN := LREAL_TO_INT(lr*10)*a; Commençant par FUN et CUBE , ces fonctions ont un RFC de 0 car aucune d'entre elles n'appelle d'autres fonctions, blocs fonctionnels ou méthodes pour leurs calculs. FB1.METH les usages FUN et CUBE , ce qui donne un RFC de 2. Le bloc fonctionnel FB1 appelle lui-même METH et FUN , ce qui augmente son RFC de 2. Pour FB1, sa méthode METH doit également être prise en compte. METH utilise FUN et CUBE. FUN a déjà été ajouté à la RFC. Par conséquent, seule l’utilisation de CUBE dans METH augmente le RFC pour FB1 à 3 " }, 
{ "title" : "Métrique : CBO – Couplage entre objets ", 
"url" : "_san_reference_metrics.html#UUID-d98bd2a3-497b-920f-1f11-f4f38973066f", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : CBO – Couplage entre objets ", 
"snippet" : "CBO – Couplage entre objets Catégories :  Maintenabilité, Réutilisabilité Limite supérieure par défaut pour la règle SA0179 correspondante : 30 Nombre d'autres blocs fonctionnels instanciés et utilisés dans un bloc fonctionnel Un bloc fonctionnel avec un couplage élevé entre les objets est susceptib...", 
"body" : "CBO – Couplage entre objets Catégories :  Maintenabilité, Réutilisabilité Limite supérieure par défaut pour la règle SA0179 correspondante : 30 Nombre d'autres blocs fonctionnels instanciés et utilisés dans un bloc fonctionnel Un bloc fonctionnel avec un couplage élevé entre les objets est susceptible d'être impliqué dans de nombreuses tâches différentes et viole donc le principe de responsabilité unique. Exemple \/\/ Declaration\nFUNCTION_BLOCK FB_Child EXTENDS FB_Base objects \/\/ +0 for EXTENDS\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i_fb1 : FB1; \/\/ +1 instantiated here\n i_fb2 : FB2; \/\/ +1 instantiated here\nEND_VAR\n\n\/\/Implementation\ni_fb3(); \/\/ +0 instantiated in FB_Base, no increment for call L'extension d'un bloc fonction n'augmente pas le couplage entre objets. i_fb3 est instancié dans la mise en œuvre de FB_Base et transmis à FB_Child ( EXTENDS ). L'appel FB_Child n'augmente pas le couplage entre les objets. Le CBO de FB_Child est 2. " }, 
{ "title" : "Métrique : Complexité de référence (Elshof) ", 
"url" : "_san_reference_metrics.html#UUID-a43f74c1-523d-b649-00e5-788c653e5ea1", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : Complexité de référence (Elshof) ", 
"snippet" : "Complexité de référence (Elshof) Catégories :  Efficacité, Maintenabilité, Réutilisabilité Complexité du flux de données d'un POU La complexité du référencement est calculée selon la formule suivante : <nombre de variables utilisées> \/ <nombre d'accès aux variables> Seuls les accès aux variables dan...", 
"body" : "Complexité de référence (Elshof) Catégories :  Efficacité, Maintenabilité, Réutilisabilité Complexité du flux de données d'un POU La complexité du référencement est calculée selon la formule suivante : <nombre de variables utilisées> \/ <nombre d'accès aux variables> Seuls les accès aux variables dans la partie implémentation du POU sont pris en compte. Exemple \/\/Declaration\nPROGRAM PRG\nVAR\n i, j : INT;\n k : INT := GVL.m;\n b, c : BOOL;\n myFB : FB;\nEND_VAR\n\n\/\/Implementation\nmyFB(paramA := b); \/\/ +3 accesses (myFB, paramA and b)\ni := j; \/\/ +2 accesses (i and j)\nj := GVL.d; \/\/ +2 accesses (j and GVL.d) Référencement de la complexité dans les résultats de l'extrait de code : 6 nombre de variables utilisées \/ 7 nombre d'accès aux variables = 0,85 Prudence: c et k ne sont pas utilisées et ne comptent donc pas comme « variables utilisées ». La tâche k : INT := GVL.m n'est pas compté car il fait partie de la déclaration du programme. " }, 
{ "title" : "Métrique : Manque de cohésion des méthodes – LCOM ", 
"url" : "_san_reference_metrics.html#UUID-068c2765-4709-d4e2-80b6-d173998195a8", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : Manque de cohésion des méthodes – LCOM ", 
"snippet" : "Manque de cohésion des méthodes – LCOM Manque de cohésion des méthodes – LCOM Catégories :  Maintenabilité, Réutilisabilité La cohésion entre les blocs fonction, leurs actions, transitions et méthodes décrit s'ils accèdent ou non aux mêmes variables. Le manque de cohésion des méthodes décrit la forc...", 
"body" : "Manque de cohésion des méthodes – LCOM Manque de cohésion des méthodes – LCOM Catégories :  Maintenabilité, Réutilisabilité La cohésion entre les blocs fonction, leurs actions, transitions et méthodes décrit s'ils accèdent ou non aux mêmes variables. Le manque de cohésion des méthodes décrit la force avec laquelle les objets d’un bloc fonctionnel sont connectés les uns aux autres. Plus le manque de cohésion est faible, plus la connexion entre les objets est forte. Les blocs fonctionnels présentant un manque élevé de cohésion sont susceptibles d'être impliqués dans de nombreuses tâches différentes et violent donc le principe de responsabilité unique. La métrique est calculée selon la formule suivante : MAX(0, <nombre de paires d'objets sans cohésion> - <nombre de paires d'objets avec cohésion>) Exemple \/\/Declaration\nFUNCTION_BLOCK FB\nVAR_INPUT\n a : BOOL;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i,b : BOOL;\nEND_VAR\n\n\/\/Implementation\ni := 42;\n\/\/FB.ACT\ni:= 0; \/\/FB.METH Declaration\nMETHOD METH : BOOL\nVAR_INPUT\n\tc : BOOL;\nEND_VAR\n\n\/\/Implementation\nMETH := c;\ni := 1; \/\/FB.SecondMETH Declaration\nMETHOD SecondMETH : INT\nVAR_INPUT\nEND_VAR\n\n\/\/Implementation\nSecondMETH := SEL(c,3,4); Paires d'objets sans connexion (4 paires) : FB, FB.ACT FB , FB.METH FB.ACT , FB.SecondMETH FB.METH , FB.SecondMETH Paires d'objets avec connexion (2 paires) : FB , FB.SecondMETH (les deux utilisent c ) FB.ACT , FB.METH (les deux utilisent i ) Le tableau montre quelles variables relient quels objets du FB : Facebook FB.ACT FB.METH FB.SecondMETH FB.SecondMETH c 0 0 . FB.METH 0 i . . FB.ACT 0 . . . FB - . . . " }, 
{ "title" : "Métrique : Nombre de succursales SFC ", 
"url" : "_san_reference_metrics.html#UUID-d74f2703-e85d-ed16-b335-69a4dfd4a8bd", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : Nombre de succursales SFC ", 
"snippet" : "Nombre d'agences SFC Catégories :  Testabilité, Maintenabilité Nombre de branches alternatives et parallèles d'un POU du langage d'implémentation SFC (sequential function chart) Exemple L'extrait de code ci-dessus dans SFC comporte 4 branches : 3 branches alternatives et 1 branche parallèle....", 
"body" : "Nombre d'agences SFC Catégories :  Testabilité, Maintenabilité Nombre de branches alternatives et parallèles d'un POU du langage d'implémentation SFC (sequential function chart) Exemple L'extrait de code ci-dessus dans SFC comporte 4 branches : 3 branches alternatives et 1 branche parallèle. " }, 
{ "title" : "Métrique : Nombre d'étapes SFC ", 
"url" : "_san_reference_metrics.html#UUID-19d1353f-ebce-6c25-6214-7b3a97c92490", 
"breadcrumbs" : "CODESYS Static Analysis \/ Référence : Programmation \/ Métrique \/ Métrique : Nombre d'étapes SFC ", 
"snippet" : "Nombre d'étapes SFC Catégorie :  Maintenabilité Nombre d'étapes dans un POU dans SFC (diagramme de fonctions séquentielles) Seules les étapes contenues dans le POU programmé dans SFC sont comptées. Ne sont pas comptées les étapes qui se trouvent dans la mise en œuvre d'actions ou de transitions appe...", 
"body" : "Nombre d'étapes SFC Catégorie :  Maintenabilité Nombre d'étapes dans un POU dans SFC (diagramme de fonctions séquentielles) Seules les étapes contenues dans le POU programmé dans SFC sont comptées. Ne sont pas comptées les étapes qui se trouvent dans la mise en œuvre d'actions ou de transitions appelées dans les POU. Exemple L'extrait de code dans SFC comporte 10 étapes. " }
]
$(document).trigger('search.ready');
});