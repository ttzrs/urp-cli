$(document).ready(function () {indexDict['en-US'] = [{ "title" : "CODESYS Application Composer ", 
"url" : "_ac_start_page.html", 
"breadcrumbs" : "CODESYS Application Composer \/ CODESYS Application Composer ", 
"snippet" : "CODESYS Application Composer is software for efficiently creating application variants which consist of recurring function blocks. On the basis of modules, you create a machine application and parameterize it. The PLC program is automatically generated from this. Improves the reusability and quality...", 
"body" : "CODESYS Application Composer is software for efficiently creating application variants which consist of recurring function blocks. On the basis of modules, you create a machine application and parameterize it. The PLC program is automatically generated from this. Improves the reusability and quality of application parts Increased efficiency by means of automated generation of applications from predefined modules Particularly suitable for simplified project engineering of applications in the fields of Digital Factory or Industry 4.0 Digital Factory or Industry 4.0 applications can be planned more easily Ready for immediate use thanks to the supplied generators and the application concept Video clip: Building automation with the CODESYS Application Composer add-on Sample projects You can install and update the CODESYS Application Composer add-on in the CODESYS Installer . " }, 
{ "title" : "Overview ", 
"url" : "ac_application_composer_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Overview ", 
"snippet" : "The CODESYS Application Composer is used to create applications by using existing modules. The user composes, parameterizes, and connects the required modules to form a complete application. This configuration does not require knowledge of PLC programming and can therefore be done by technicians wit...", 
"body" : "The CODESYS Application Composer is used to create applications by using existing modules. The user composes, parameterizes, and connects the required modules to form a complete application. This configuration does not require knowledge of PLC programming and can therefore be done by technicians without programming experience. Internal generators create complete, well-structured IEC 61131-3 applications including the I\/O mapping and visualizations. The CODESYS Application Composer consists of two main components: Module editor, which can be used to compose the software modules developed with the module declaration editor Module declaration editor for developing modules Example CODESYS Application Composer module tree and visualization For more information about the module editor, see: Module EditorFor more information about the module declaration editor, see: Module Declaration Editor" }, 
{ "title" : "Module Editor ", 
"url" : "ac_module_editor_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor ", 
"snippet" : "Using the editors of the Application Composer, module instances of the module tree can be configured and parameterized. The available editors of the module instance open by means of double-clicking the object or the Edit Object command from the context menu: Deployment HMI Parameters I\/O Information...", 
"body" : "Using the editors of the Application Composer, module instances of the module tree can be configured and parameterized. The available editors of the module instance open by means of double-clicking the object or the Edit Object command from the context menu: Deployment HMI Parameters I\/O Information Other editors: Extension Module Editor Sequence Editor The Project Compare command can also be used for Application Composer module instances. " }, 
{ "title" : "Deployment ", 
"url" : "ac_toplevel.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Deployment ", 
"snippet" : "This dialog is only available for toplevel module instances and provides application and task settings. Dialog for toplevel settings Application : Entered as a generation target in the toplevel module instance. The button can be used to select an existing application or create a new application by s...", 
"body" : "This dialog is only available for toplevel module instances and provides application and task settings. Dialog for toplevel settings Application : Entered as a generation target in the toplevel module instance. The button can be used to select an existing application or create a new application by specifying a name. If the application is assigned to the POU pool, then I\/O mapping is not possible. In the case of decoupled modules which have a parent module, the parent application is suggested ( [Use parent application] ). Standard Tasks In this section there are up to three predefined tasks available – one task with high priority, one with medium priority and one with low priority. The name and the availability of the tasks are defined in the module itself and cannot be changed (in the dialog above: Fieldbus task and Standard task ). In addition to the predefined tasks, the user can create a new task by specifying a name if the \" CREATE_IF_MISSING \" flag is set in the module declaration. The parameter of the new task can be defined in the Standard generator settings . Module specific Tasks : This field displays information about module specific tasks. " }, 
{ "title" : "I\/O ", 
"url" : "ac_io.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ I\/O ", 
"snippet" : "This dialog provides information about the inputs and outputs of the module. Inputs and outputs describe the I\/O demand of the modules and can be connected to the following: Inputs and outputs of devices Inputs and outputs of other module instances ST expressions or constants (example: for simulatio...", 
"body" : "This dialog provides information about the inputs and outputs of the module. Inputs and outputs describe the I\/O demand of the modules and can be connected to the following: Inputs and outputs of devices Inputs and outputs of other module instances ST expressions or constants (example: for simulation purposes boolean module inputs can be connected to TRUE ) In online mode, the Online Value column is visible and the current value of the controller is displayed. I\/O overview of the module interface Clicking the Mapping field opens the I\/O mapping dialog: Dialog for I\/O mapping I\/O-Channel : Clicking the … button opens another dialog to map the input\/output to a device I\/O. ST-Expression : This option allows for mapping the input\/output to an ST expression. Clicking the button opens the Input Assistant to select a variable. Connect to Module-I\/O : This option can be used to map the input\/output to an I\/O which does not have any connection. Clicking the button opens the Input Assistant to select a module. No connection : No mapping of the input\/output. This option is similar to Missing connection , but it does not generate the warning message. Missing connection : This option is the default and generates a warning in the message view when generating the project. I\/Os which are connected automatically by the device generator are indicated by (AUTO) in the IN\/OUT column and are disabled. If the mapping is still changed manually, then a warning is displayed that this action will overwrite the automatic mapping. If an automatically generated connection is overwritten by a manual set connection, then this I\/O channel is not considered any longer in the device generator operations. " }, 
{ "title" : "HMI ", 
"url" : "ac_hmi.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ HMI ", 
"snippet" : "In this dialog, you define the page template and the module visualizations which should be embedded in the toplevel visualization. Create toplevel tab : Creates a tab in the top level of the visualization which leads directly to the visualization of this module instance. Hotkey : With the shortcut s...", 
"body" : "In this dialog, you define the page template and the module visualizations which should be embedded in the toplevel visualization. Create toplevel tab : Creates a tab in the top level of the visualization which leads directly to the visualization of this module instance. Hotkey : With the shortcut set here, you can switch directly to this visualization page. The default setting for the shortcut is defined in the module declaration in the std.Visu section. Page template : A template for the visualization of the module can be selected here which is used as a background for the visualization. The drop-down list provides a selection of all visualizations which are defined in the module declaration. The first visualization in the module declaration is selected by default. If no visualization defined, then \"None\" is displayed. Embed visualization : This function allows for embedding the visualization of the module instance in the next superordinate module ( Next ancestor ) or in any other visualization of the module instance. If it is defined in the module, then the %PAGE_VISU% placeholder can be selected. In this case, the created visualization screen generated for the module instance is embedded. Multiple entries can be defined. For information about creating visualization screens, see: Generating Visualization Screens " }, 
{ "title" : "Parameter ", 
"url" : "ac_parameter.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Parameter ", 
"snippet" : "This dialog shows all available parameters of the module instance which can be parameterized. The entries in Parameter , Type , Description , Min , and Max are informational purposes only. You can double-click the Value field to edit it. Parameter dialog of module instances The parameter values are ...", 
"body" : "This dialog shows all available parameters of the module instance which can be parameterized. The entries in Parameter , Type , Description , Min , and Max are informational purposes only. You can double-click the Value field to edit it. Parameter dialog of module instances The parameter values are displayed in bold fonts when they have been explicitly set; otherwise the fonts remain normal. Changed parameters can be reset to their default value by means of the Reset to Default command in the context menu. Parameters in red fonts have to be set by the user because otherwise an error is displayed when created. In online mode, the Online Value column is visible and the current value is displayed. If you change the value of the parameter in the Value column, then the value is also changed on the controller. Use the Use Online Values command to copy the current online value to the Value column and as a result to use it as the parameter value of the module instance in the module tree. In general, parameter values are displayed and edited in the syntax for IEC literals (example: parameter value of type TIME as t#7s35ms . After a parameter is changed, the Generate command has to be executed to create the project again. If you have changed any parameter values in the module instances in online mode, then you can use the Differing parameter values command to get a list of the changed parameters in the Messages view. Double-clicking this kind of message opens the parameter dialog for the affected module instance where the changed parameter values are indicated by a red frame. " }, 
{ "title" : "Information ", 
"url" : "ac_information.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Information ", 
"snippet" : "This information dialog displays details about the Icon , Name , Description , Source , Version , Provider , and Category of the module instance. As an option, multiple links can also be displayed. Clicking the links opens the respective application. The contents of the first URL are displayed on th...", 
"body" : "This information dialog displays details about the Icon , Name , Description , Source , Version , Provider , and Category of the module instance. As an option, multiple links can also be displayed. Clicking the links opens the respective application. The contents of the first URL are displayed on the right side. For the links to be displayed here, they have to be defined in the MetaData section of the module declaration. Trusted domains and sites are defined in the Application Composer options . If you click an URL which is not defined as \"trusted\", then a dialog opens in the right view. In this view, you can then add the URL to the trusted domains or sites. " }, 
{ "title" : "SourceTemplate ", 
"url" : "ac_copyfb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ SourceTemplate ", 
"snippet" : "This dialog defines which function blocks from the POU pool are copied to the application when the Generate command is executed. To copy funcion blocks, the  SourceTemplate-generator has to be enabled in the Generator Configuration . The dialog displays all function blocks which are defined in the S...", 
"body" : "This dialog defines which function blocks from the POU pool are copied to the application when the Generate command is executed. To copy funcion blocks, the  SourceTemplate-generator has to be enabled in the Generator Configuration . The dialog displays all function blocks which are defined in the SourceTemplate section of the module declaration. Source-FB : Identifier of the function blocks to be copied Is to copy : TRUE\/FALSE: The function block is copied or not copied. If the IsMandatory parameter is defined as TRUE in the module declaration, then the value cannot be changed here. Type of source FB : Name of the function block to be copied " }, 
{ "title" : "Editor: ExportDevices ", 
"url" : "ac_export_devices.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Editor: ExportDevices ", 
"snippet" : "With this editor, you can select a file which have been generated by a device export. This device is added to the device tree when the project is generated. This configuration option is required when devices with special properties are added and when the devices cannot be added by the device generat...", 
"body" : "With this editor, you can select a file which have been generated by a device export. This device is added to the device tree when the project is generated. This configuration option is required when devices with special properties are added and when the devices cannot be added by the device generator. Identifier : Identifier from the module declaration Exported File : Selection of all files which are defined in the module declaration If only one file is defined in the module declaration, then this file is not displayed here. Multiple ExportDevices can exist for each device. These are differentiated by their identifiers from the module declaration and displayed here. " }, 
{ "title" : "Dialog: Options: Composer ", 
"url" : "ac_options.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Dialog: Options: Composer ", 
"snippet" : "This subdialog of the CODESYS options dialog provides different tabs for the CODESYS Application Composer settings....", 
"body" : "This subdialog of the CODESYS options dialog provides different tabs for the CODESYS Application Composer settings. " }, 
{ "title" : "Tab: General ", 
"url" : "ac_options.html#UUID-f0422aff-2b78-70d6-5e11-24472852cab0_ce9930fe2eec0a8640e0080c1b5_id_71025f62d62f3d9cc0a8640e01589d60", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Dialog: Options: Composer \/ Tab: General ", 
"snippet" : "General Show toplevel selection before generation : You can click Composer → Generate to open a dialog for selecting the toplevel modules. You can reduce the time for generating the application by deselecting modules that do not change anymore. Editors Parameter editor type Display of the Parameters...", 
"body" : "General Show toplevel selection before generation : You can click Composer → Generate to open a dialog for selecting the toplevel modules. You can reduce the time for generating the application by deselecting modules that do not change anymore. Editors Parameter editor type Display of the Parameters on the Parameters tab (module editor). Tree view : The parameter groups are shown in the editor as a tree structure. Tab view : The parameter groups are shown in the editor as single tabs. Scan Automatic scan (saved with project) : The CODESYS Application Composer automatically searches for existing modules and module instances when a new library is inserted into the POU view. : The CODESYS Application Composer searches for existing modules and module instances only in the following cases: After opening the project After inserting a module instance in the module tree if a search was not performed Note: This setting is saved with the project. Trusted domains Trusted websites The URLs in this list can be displayed on the Information tab of the module editor. Requirement: The URL is defined in the section MetaData of the module declaration. " }, 
{ "title" : "Tab: Sequence Editor ", 
"url" : "ac_options.html#UUID-f0422aff-2b78-70d6-5e11-24472852cab0_ce9930fe2eec0a8640e0080c1b5_id_70cecd07d62f3d9fc0a8640e00b85eda", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Dialog: Options: Composer \/ Tab: Sequence Editor ", 
"snippet" : "General Show references Show parameters Show I\/O mapping Show instance names Show comment Show online variables : The respective element is shown in the step of the sequence editor . Display Step width : Width of the tab header (in pixels) Valid values: 25–500. Step distance (vert.) Distance between...", 
"body" : "General Show references Show parameters Show I\/O mapping Show instance names Show comment Show online variables : The respective element is shown in the step of the sequence editor . Display Step width : Width of the tab header (in pixels) Valid values: 25–500. Step distance (vert.) Distance between the sequence steps (in pixels) Valid values: 10–100 Std. connection A connection B connection Colors of the connecting lines between the sequence steps The colors of A connection and B connection are used after a branch step. Texts Parameters References I\/O channels Colors for displaying text, parameters, references, and I\/O channels Text font The button opens the default dialog for setting the font for text in the editor. Link font The button opens the default dialog for setting the font for labeling links. " }, 
{ "title" : "Sequence Editor ", 
"url" : "ac_sequenceeditor.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Sequence Editor ", 
"snippet" : "The sequence editor is a graphical editor which displays and edits the module tree in a flowchart. It allows to add and delete modules or to modify their properties. The editor also provides an online mode, which is meant to be used for tracking of active module-steps and module-breakpoints, so that...", 
"body" : "The sequence editor is a graphical editor which displays and edits the module tree in a flowchart. It allows to add and delete modules or to modify their properties. The editor also provides an online mode, which is meant to be used for tracking of active module-steps and module-breakpoints, so that it can be used for debugging. The sequence flow itself (execution and order of sequences) is not implemented by the editor. This is used only to display and edit the module tree. Any functionality or logic of the module steps must be implemented in the function blocks of the modules as IEC ( CODESYS ) program code Sequence Editor The editor is available for all modules with the definition Root in the section mse.Sequence of the module declaration. The content of the editor corresponds to the module tree. Each modification in the module tree will change the sequence editor and vice versa. Only module instances will be displayed which are inserted below a \" Root \" instance. Their displayed content is defined by the definitions in the section mse.Sequence of their module declaration. The appearance of the steps depends on the definition in the module declaration. Besides the definition Root there exist the following three definitions: Step: Parallel: Branch: " }, 
{ "title" : "Displayed data within the sequence box ", 
"url" : "ac_sequenceeditor.html#UUID-c7b42e58-c2ec-c00e-5692-55a5d60221bd_d125a077ca9f50ac0a8640e01732ee5_id_ad20551e9b6d77a9c0a865200163ff8b", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Sequence Editor \/ Displayed data within the sequence box ", 
"snippet" : "Within the box of each step the name of the module type and the name of the module instance (optional) and the defined icon will be displayed. The latter corresponds to the icon defined in the metadata of the module configuration . The parameter and I\/O channels of the module instance will also be d...", 
"body" : "Within the box of each step the name of the module type and the name of the module instance (optional) and the defined icon will be displayed. The latter corresponds to the icon defined in the metadata of the module configuration . The parameter and I\/O channels of the module instance will also be displayed, if defined so in the section mse.Sequence . The same holds for references, although two different types of references are distinguished: General references to module instances Jump references, which define a jump within the sequence. The referenced module instances will be displayed with their relative path in the module tree (example: ..\/..\/WaitTime ). The occurring ..\/ are written in a shortened notation (example: .\/..\/..\/ becomes 3x[..\/] ). A comment, which will be displayed separated by a line, can be added to each step. This is saved separately for each step (module instance). If the displayed text of the module names, parameters, IO channels or references does not fit in the given space within the step, the text will be wrapped to a second line. If required, the text will be cut. In this case, a … will be added. In summary, up to a maximum of four additional lists\/entries can be defined for a sequence step: Parameters: Parameter name + parameter value I\/O channels: Channel name + name of channel target References: Icon, path, and name of the referenced module instance For jump references: >> + icon, path and name of the references module instance Comments: Horizontal line + comment For more information about the sequence editor, see can be found in the help chapters Working in the Sequence Editor and Sequence Editor in Online Mode " }, 
{ "title" : "Working with the Sequence Editor ", 
"url" : "ac_sequenceeditor_edit.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Sequence Editor \/ Working with the Sequence Editor ", 
"snippet" : "When the mouse pointer is moved over a step, it is highlighted in gray. When the pointer is moved over the empty end of a connection, a gray triangle is displayed. The steps can be selected via clicking changing the color of selected step to red. The multiselection of steps is also possible. Steps c...", 
"body" : "When the mouse pointer is moved over a step, it is highlighted in gray. When the pointer is moved over the empty end of a connection, a gray triangle is displayed. The steps can be selected via clicking changing the color of selected step to red. The multiselection of steps is also possible. Steps can be moved by drag&drop. When the Ctrl key is also pressed, the steps are copied. Possible insert positions for moved or copied steps are marked with a red dotted line. Move elements by drag&drop When the mouse pointer is moved over a jump element whose target is available in the current sequence, the text field of the jump reference is also connected to the specified target step by a dashed line. The target is also marked with a dashed circle. Jump target of a jump reference Editing with I\/O channels A double click on the I\/O channel opens the I\/O mapping dialog, which is also used in the I\/O editor of module instances. For more information, see: I\/O " }, 
{ "title" : "Commands of the Sequence Editor ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_00bbee939046545bc0a8652000fd02ce", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Sequence Editor \/ Working with the Sequence Editor \/ Commands of the Sequence Editor ", 
"snippet" : "A right click on a sequence step or on the gray triangle (empty parallel step of branch) provides the context menu commands which are available on this position. In addition to the standard Cut , Copy , and Paste commands, the menu provides the following commands: Add Step after Any subsequent steps...", 
"body" : "A right click on a sequence step or on the gray triangle (empty parallel step of branch) provides the context menu commands which are available on this position. In addition to the standard Cut , Copy , and Paste commands, the menu provides the following commands: Add Step after Any subsequent steps are displayed in a list command. As a result, only steps and modules are added which would be suitable in the module slot at this location. Add Step after closed Subsequences This command can be used when subsequences of branches and parallel sequences need to be closed. The inserted step is added after the subsequences and not within them. It is only available for positions having closable subsequences. Add Comment Adds a comment to the selected step. Set jump reference This command is only available in the context menu of a jump element. The mouse can be used to draw a red line to the target step. The context menu of selected sequence elements can also be opened with the space bar . Context menu of a branch Consecutive steps are connected with arrows. For the branch element, different colors can be defined for the two branches. For more information, see: mse.Sequence. The colors are defined in the CODESYS options ( Sequence Editor ). " }, 
{ "title" : "Change the position on sequence steps ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_74415e1a90465440c0a865200120cb10", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Sequence Editor \/ Working with the Sequence Editor \/ Change the position on sequence steps ", 
"snippet" : "To change the position of a sequence element the element must be selected and dragged by use of the middle mouse key. The arrangement of the parameters within the step can also be changed. Change position of a sequence step As a result, only the position of the element can be moved in the editor – c...", 
"body" : "To change the position of a sequence element the element must be selected and dragged by use of the middle mouse key. The arrangement of the parameters within the step can also be changed. Change position of a sequence step As a result, only the position of the element can be moved in the editor – changing the position within a sequence and therefor the order is not possible. " }, 
{ "title" : "Change parameter \/ comments \/ instance name \/ I\/O channels ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_a585f36190465431c0a8652000ac8cda", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Sequence Editor \/ Working with the Sequence Editor \/ Change parameter \/ comments \/ instance name \/ I\/O channels ", 
"snippet" : "To change a parameter , it has to be double clicked. Depending on the data type of the variable the field can be edited or the variable value can be selected from a list box (example: TRUE or FALSE ). Comments or instance names can be also changed by double clicking....", 
"body" : "To change a parameter , it has to be double clicked. Depending on the data type of the variable the field can be edited or the variable value can be selected from a list box (example: TRUE or FALSE ). Comments or instance names can be also changed by double clicking. " }, 
{ "title" : "Editing of references ", 
"url" : "ac_sequenceeditor_edit.html#UUID-93579d47-8986-2afb-af61-1528a9dc3fde_e904af2c8c0a8640e004a5d36_id_939c29699046541bc0a865200038e978", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Sequence Editor \/ Working with the Sequence Editor \/ Editing of references ", 
"snippet" : "A reference can be edited by right clicking it. The context menu provides a list of references which can be inserted at this location. Set References In case of a jump reference, the context menu provides the Set Jump Reference command. Executing this command allows to set the jump target using the ...", 
"body" : "A reference can be edited by right clicking it. The context menu provides a list of references which can be inserted at this location. Set References In case of a jump reference, the context menu provides the Set Jump Reference command. Executing this command allows to set the jump target using the mouse. A dotted red line is drawn to the target, which can be set by clicking on it. An existing jump reference can be deleted with the Delete from the context menu. Set jump reference " }, 
{ "title" : "Sequence Editor in Online Mode ", 
"url" : "ac_sequenceeditor_onlinemode.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Sequence Editor \/ Sequence Editor in Online Mode ", 
"snippet" : "After the application logs in, the Sequence Editor switches to online mode. The appearance of the module steps in online mode is very similar to the offline mode. All steps are displayed, but they cannot be selected or modified as in offline mode. This mode also offers the possibility to display var...", 
"body" : "After the application logs in, the Sequence Editor switches to online mode. The appearance of the module steps in online mode is very similar to the offline mode. All steps are displayed, but they cannot be selected or modified as in offline mode. This mode also offers the possibility to display variable values within a step. Commands in online mode In online mode, the sequence editor offers two additional commands in the Composer menu: Active Breakpoints to next Step Center view to Breakpoints " }, 
{ "title" : "Active step ", 
"url" : "ac_sequenceeditor_onlinemode.html#UUID-2af85472-49e7-4d96-1c40-aacbe534fb38_cd6429848b1bdae2c0a8640e002e3857_id_e0ed25b7911507a5c0a8640e003e283b", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Sequence Editor \/ Sequence Editor in Online Mode \/ Active step ", 
"snippet" : "If properly declared in the module declaration , the active step will be displayed in yellow: Online mode – Active step...", 
"body" : "If properly declared in the module declaration , the active step will be displayed in yellow: Online mode – Active step " }, 
{ "title" : "Breakpoints ", 
"url" : "ac_sequenceeditor_onlinemode.html#UUID-2af85472-49e7-4d96-1c40-aacbe534fb38_cd6429848b1bdae2c0a8640e002e3857_id_e06ef3f19ba07a7bc0a8652001bdb8af", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Sequence Editor \/ Sequence Editor in Online Mode \/ Breakpoints ", 
"snippet" : "If properly declared in the module declaration, the editor allows you to set breakpoints. The breakpoint of a step can be set \/ reset by the Toggle Breakpoint command from the context menu of the step. An activated breakpoint is indicated by a red border. If the breakpoint is active (sequence stops ...", 
"body" : "If properly declared in the module declaration, the editor allows you to set breakpoints. The breakpoint of a step can be set \/ reset by the Toggle Breakpoint command from the context menu of the step. An activated breakpoint is indicated by a red border. If the breakpoint is active (sequence stops on breakpoint), the step will be displayed in red. Online mode – Breakpoints For more information, see: mse.Sequence" }, 
{ "title" : "Extension module editor ", 
"url" : "ac_editor_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Extension module editor ", 
"snippet" : "The editor of the extension modules serves to define extensions and provide the four Metadata , Parameter, I\/O, and HMI tabs. The editor can be opened with a double click on the function block in the POUs pool (in the directory according to the given name of the extension). Error Handling In case of...", 
"body" : "The editor of the extension modules serves to define extensions and provide the four Metadata , Parameter, I\/O, and HMI tabs. The editor can be opened with a double click on the function block in the POUs pool (in the directory according to the given name of the extension). Error Handling In case of fatal errors which prohibit a display of the editors, the error messages will be displayed on the Metadata page. The editor pages are disabled so that they cannot react to any input. An example for this kind of error is a missing module function block. " }, 
{ "title" : "Change events ", 
"url" : "ac_editor_extension_module.html#UUID-91f9cff1-6f9e-ea6b-b3cd-d65abac7523b_ef0072b48b6aa7c0a8640e00080c11_id_4681e6c5b4a5a074c0a8640e01e5e429", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Extension module editor \/ Change events ", 
"snippet" : "The content of the editors is updated automatically if the corresponding function block, text list, image pool or visualization changes. (The mentioned objects will be considered as \"corresponding\" if they are in the same folder as the extension module.)...", 
"body" : "The content of the editors is updated automatically if the corresponding function block, text list, image pool or visualization changes. (The mentioned objects will be considered as \"corresponding\" if they are in the same folder as the extension module.) " }, 
{ "title" : "Meta Data ", 
"url" : "ac_metadata_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Extension module editor \/ Meta Data ", 
"snippet" : "On this tab of the Extension module editor , the description and the category are displayed. The displayed texts (except for the category) are read from a text lists. The currently used language of the programming system is applied for this. If there is no text available in this language, the defaul...", 
"body" : "On this tab of the Extension module editor , the description and the category are displayed. The displayed texts (except for the category) are read from a text lists. The currently used language of the programming system is applied for this. If there is no text available in this language, the default text will be used. If there is no text entry at all no text will be displayed. Like the text list, the images are read from the image pool. Extension module dialog Metadata The buttons to the right of the displayed values open the corresponding line in the text list or image pool and as a result allow for changing the texts. If there is no text \/ image with the corresponding ID a new element with this ID will be created. " }, 
{ "title" : "Parameter ", 
"url" : "ac_parameters_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Extension module editor \/ Parameter ", 
"snippet" : "On the tab of the extension module editor , the parameters of the extension module are listed in a table. Extension module dialog: Parameter The Id , Variable , Type , and Default columns are read-only. In the Name and Description columns, you can click the corresponding line (when it is already sel...", 
"body" : "On the tab of the extension module editor , the parameters of the extension module are listed in a table. Extension module dialog: Parameter The Id , Variable , Type , and Default columns are read-only. In the Name and Description columns, you can click the corresponding line (when it is already selected) or the space bar to jump directly to the corresponding line of the respective text list. The displayed text is read from the text list using the language which is currently set for the programming system. If this language is missing in the text list, then the default text for the entry will be used. In the column Default the initialization value of the parameter will be displayed. This table supports multi-selection of entries and the standard handling with mouse and keyboard. All actions which change parameters can be undone or redone by means of the standard Undo and Redo commands. The Cut , Copy , and Paste functions are not supported. You can use the arrow buttons or the Alt + ↑ and Alt + ↓ shortcuts to move the selected parameter up or down to change the order. You can use the button with the X or the standard Del command to remove the selected parameters. Any errors or warnings for the parameters will be displayed at the bottom of the message list. If a message is selected, the corresponding parameter will be selected in the parameter list above. The button with the asterisk or the Alt + n shortcut (if the table has the focus) can be used to open the New Parameter dialog: Extension module dialog: New parameter In the upper part of the dialog a hierarchical table with all compatible variables of the function block is displayed. To activate the OK button a variable must be selected and a unique Id must be entered. If the Id is not unique, then a red exclamation mark with error text is added to it. In the fields Name and Description the standard text can be entered which will be stored in the associated text list. The texts for the individual languages then have to be added to the text list. A variable is displayed if it is an input variable of a function module or a local variable of a structure. A variable can be selected if it has primitive type. " }, 
{ "title" : "I\/O ", 
"url" : "ac_io_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Extension module editor \/ I\/O ", 
"snippet" : "This tab of the extension module editor and the dialog for creating new I\/Os behave similarly to the Parameters tab. Instead of the column Default the direction In\/Out of the input\/output is displayed. Extension module dialog: I\/O...", 
"body" : "This tab of the extension module editor and the dialog for creating new I\/Os behave similarly to the Parameters tab. Instead of the column Default the direction In\/Out of the input\/output is displayed. Extension module dialog: I\/O " }, 
{ "title" : "HMI ", 
"url" : "ac_hmi_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Extension module editor \/ HMI ", 
"snippet" : "This tab of the extension module editor allows for defining the page visualizations as well as the embedded visualizations . Both text fields allow the definition of multiple visualization names, separated by comma. Extension module dialog: HMI...", 
"body" : "This tab of the extension module editor allows for defining the page visualizations as well as the embedded visualizations . Both text fields allow the definition of multiple visualization names, separated by comma. Extension module dialog: HMI " }, 
{ "title" : "Visualization Screens ", 
"url" : "f_application_composer_visualization_pages.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Visualization Screens ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Toplevel templates ", 
"url" : "ac_toplevel_templates.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Visualization Screens \/ Toplevel templates ", 
"snippet" : "A toplevel template is a template for the start page of the generated visualization. It contains a frame as a placeholder for the user specific pages and tabs to switch to the different pages. Optionally there are buttons to navigate to the pages and a status and address line. The toplevel template ...", 
"body" : "A toplevel template is a template for the start page of the generated visualization. It contains a frame as a placeholder for the user specific pages and tabs to switch to the different pages. Optionally there are buttons to navigate to the pages and a status and address line. The toplevel template can be selected in the settings of the Visualization generator . The AC_ModuleBase library which is part of the standard installation of CODESYS Application Composer contains three toplevel templates: AC.GenVisu_Toplevel_Template , AC.Toplevel_Vertical_Template, and AC.Toplevel_3S_Vertical_Template . Standard toplevel templates Toplevel template: AC_Toplevel_3S_Vertical_Template Besides the prepared templates it is also possible to create user defined toplevel templates. Elements of toplevel templates (1): Navigation: Up \/ Back \/ Forward (2): Frame to display pages (3): Tab for direct navigation to toplevel pages (4): Status line (5): Address line: Instance path of the displayed modules instance The elements of the visualization template are identified by their element names. In the list below the name of the elements is written in brackets. Mandatory elements of the template [Frame] : Main frame which displays the visualization pages. For best results the scale type of the frame should be set to \"isotropic\". [Tab_Template_1] , [Tab_Template_2] : Two elements which are used for the look and arrangement of all tabs. Tab_Template_1 defines the position of the first tab and the appearance of all tabs. From the position of Tab_Template_2 the arrangement of the tabs (horizontal or vertical) and the gap between the tabs will be calculated. The alarm color will be set if the hierarchy of the displayed page is below the instance represented by the tab. If the element is a button, the button state variable will also be set. If the element is a frame the alarm color will not be used. Instead of this the switch frame variable will be set to \"1\", if the tab is selected (default 0). Optional elements of the template [Up] , [Back] , [Forward] : Elements for navigation which can be a button or a frame. The element type can be a button or a frame. In case of a frame, the frame must contain three visualizations which must be in the following order: Neutral, Pressed, Deactivated. [Address] : Text field which outputs the instance path of the displayed module instance. [Status] : Text field which displays the content of the global string variable ac.g_stVisuStatusBar from the library AC_ModuleBase. This variable can be used in own module implementations to display the state of a variable. All other elements are not especially handled by the visualization generator. For the generation, the template visualization copies and modifies the copy. The original is not changed. With the exception of the visualization elements mentioned above, the visualization generator tries not to change any elements which have been changed by hand. At the first visualization generation, the described visualization template is copied. This copy, as long as it is not deleted by the user, will only be modified in future generation runs and not recopied. This is done by treating a toplevel visualization of an earlier generator run as if it is a new visualization template (the original template is never be changed), although it is not copied. So, if there are additional tabs these tabs will be added to the already existing tabs. All other properties and elements will not be touched if possible so that buttons, tabs, etc., which have been added manually by the user will maintain their positions. Deleting e.g. navigation buttons results in a loss of them. To generate those, the toplevel visu has to be deleted and regenerated " }, 
{ "title" : "Alignment of the tabs ", 
"url" : "ac_toplevel_templates.html#UUID-b04a5efa-11da-0879-903b-e5e3a3f27499_ac_toplevel_templates0", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Visualization Screens \/ Toplevel templates \/ Alignment of the tabs ", 
"snippet" : "The tabs will be aligned horizontally from left to right or vertically top down. The relative position of the template element Tab_Template_1 and Tab_Template_2 defines the alignment: If the vertical distance of the elements is greater than the horizontal distance, the elements will be aligned horiz...", 
"body" : "The tabs will be aligned horizontally from left to right or vertically top down. The relative position of the template element Tab_Template_1 and Tab_Template_2 defines the alignment: If the vertical distance of the elements is greater than the horizontal distance, the elements will be aligned horizontally, otherwise vertically. In case of vertical alignment, all tabs get the same width, which is the minimum width that all tab names can be displayed. In the case of a horizontal alignment, each tab gets the minimum width which can display its name. In both cases the height of the tabs will be set to the height of the first template ( Tab_Template_1 ). For the placement, the first template is copied and adapted for each tab. The placement starts at the position of the first template – the distance between two tabs results from the horizontal or vertical distance between the two templates. This distance can also be negative, in which case the following tab overlaps the previous one and paints over it because it is further forward. In the case of vertical alignment, the generation is aborted with an error if there is not enough space downwards to accommodate all tabs. No second column of tabs is created. In case of horizontal alignment, a new row will be created if the next tab no longer fits horizontally in the visualization. If that happens for the first tab of a line, then the generation is aborted with an error. It can happen that there is not enough space for the tab. In the case of horizontal alignment, this happens when wrapping to a new line. When aligned vertically, it happens when the width of the tabs is greater than the space provided for them in the template. In these cases, an attempt is made to create more space. Due to this automatic alignment of the elements there are four possible cases to arrange the tabs: Horizontal alignment of tabs: All tabs must be completely above the frame Horizontal alignment of tabs: All tabs must be completely below the frame Vertical alignment of tabs: All tabs must be completely on the left side of the frame Vertical alignment of tabs: All tabs must be completely on the right side of the frame If the alignment of the tabs mismatch the restriction above an error message will be created. If there is not enough space for the tabs, then the frame is reduced accordingly. All elements between tabs and frame are moved. A position of an element is interpreted as \"between tabs and frame\" if it is not completely outside of the outer limit of the first tab template (see examples for horizontal arrangement below). The creation of the visualization will be aborted if the modification of the size of the frame would lead to negative values. Example for elements between tabs and frame Example for elements \"outside\" of tabs and frame " }, 
{ "title" : "Generating Visualization Screens ", 
"url" : "ac_generating_visualization_pages.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Visualization Screens \/ Generating Visualization Screens ", 
"snippet" : "For visualization screens in the Application Composer all elements of CODESYS V3 as well as the embedded visualization screens can be used. Furthermore visu elements (example: rectangle), which are marked as special placeholder, can be used: Navigation within the visualization The navigation within ...", 
"body" : "For visualization screens in the Application Composer all elements of CODESYS V3 as well as the embedded visualization screens can be used. Furthermore visu elements (example: rectangle), which are marked as special placeholder, can be used: Navigation within the visualization The navigation within the visualization can be done by use of the tabs or the Back , Up , and Forward navigation buttons. A mouse click on the tab elements switches directly to the corresponding visualization screens. The Back and Forward buttons can be used to navigate within the history of the displayed screens (similar to the navigation in Internet browsers). The Up button switches to the next higher level. " }, 
{ "title" : "Placeholder elements in visualization screens ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_1d3a1d9285970a30c0a8640e01de1c5b", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Visualization Screens \/ Generating Visualization Screens \/ Placeholder elements in visualization screens ", 
"snippet" : "Standard visualization elements (example: rectangles, images) can be used as placeholder elements. When generating the visualization the assigned embedded visualizations will be arranged on the placeholder position (position and size). Specification The definition of placeholder elements is done by ...", 
"body" : "Standard visualization elements (example: rectangles, images) can be used as placeholder elements. When generating the visualization the assigned embedded visualizations will be arranged on the placeholder position (position and size). Specification The definition of placeholder elements is done by the instance name of the element. The name of the element must be PLACEHOLDER_<SUBPATH> . Syntax of <SUBPATH> : <SUBPATH> ::= <SLOTREF> | <SLOTREF>:<SUBPATH> <SLOTREF> ::= <SLOTNAME> | <SLOTNAME>[<idx>] The <SLOTNAME> is the target name of a slot (upper or lower case is not relevant). <idx> is a zero based index which can only be used for multislots. It defines which submodule instance of the multislot shall be displayed. While reading the module definition the system checks if the placeholder names in the visualization screens are valid. If an element of the visualization screen starts with \" PLACEHOLDER_ \" (upper or lower case is not relevant), the <SUBPATH> must start with a valid slot reference. If an index is present, it must be compatible with the slot cardinality. All slot names of the path must be valid IEC identifiers. If there are several placeholder, all paths must be different. Furthermore the placeholder elements must not have empty area. If there exists no according module instance to the <SUBPATH> of a placeholder element, no visualization will be assigned to this element. No error message will be created. If there exists an according module instance to the <SUBPATH> of a placeholder element, this element will be embedded if it is defined as an embedded screen visualization for the current screen. The embedded visualizations will keep their original aspect ratio. The size will be adapted to the placeholder in the best possible way without sticking out beyond it. Example for placeholder elements Only submodule instances and their submodule instances can be embedded using placeholders It is not possible to embed visualizations from other branches of the module tree. " }, 
{ "title" : "Checking the toplevel template ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_335369a685ed9d34c0a8652001ab0576", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Visualization Screens \/ Generating Visualization Screens \/ Checking the toplevel template ", 
"snippet" : "The following checks are performed on the toplevel screen: If the visualization template does not exist or if there are inputs or outputs defined in its interface, an error will be displayed. If an obligatory element is missing, an error will be displayed. If an element of a toplevel template is def...", 
"body" : "The following checks are performed on the toplevel screen: If the visualization template does not exist or if there are inputs or outputs defined in its interface, an error will be displayed. If an obligatory element is missing, an error will be displayed. If an element of a toplevel template is defined but it has an empty area or the wrong element type, an error will be displayed. If the tab templates and the frame are overlapping, an error will be displayed. If the position of the second tab template is identical to the first template or if its position is on the left side or above the first template, an error will be displayed. In case of horizontal alignment of the tabs an error will be created if the tabs are not completely above or below the frame. In case of vertical alignment of the tabs an error will be created if the tabs are not completely on the right or the left side of the frame. " }, 
{ "title" : "Creating the visualization screens ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_85c3e6868b643da6c0a8640e01a0782b", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Visualization Screens \/ Generating Visualization Screens \/ Creating the visualization screens ", 
"snippet" : "All visualization screens will initially be created by the command Generate . With a second generator run only the changed parameters of the module tree will be updated. A created visualization screen contains a frame which defines the size of the visualization and which holds the corresponding visu...", 
"body" : "All visualization screens will initially be created by the command Generate . With a second generator run only the changed parameters of the module tree will be updated. A created visualization screen contains a frame which defines the size of the visualization and which holds the corresponding visualization of the module. This frame is in the background, all embedded visualizations will be arranged as follows: All embedded elements are identified persistently by the element ID. If an existing visualization screen is updated by a new generator run, the system searches for the according ID. If this element (ID) exists only the parameter changed in the module configuration will be updated. For example, the position remains unchanged, and the visualization\/frame switch and the visualization object used for the display can change. The embedded visualizations will be arranged on the screen from left to right and from top to the bottom. A matching placeholder element has a higher priority. Finally, both mechanisms are not used if the frame with the corresponding ElementID already exists during generation. In this case, the position remains unchanged. Visualization screens, which have been created in the last generator run, but do not exist in the current generator run, will be deleted. " }, 
{ "title" : "Order of embedding visualization elements ", 
"url" : "ac_generating_visualization_pages.html#UUID-86a0e9ba-9a01-969c-11fa-d6ce526cd42f_f0f82255648c0a8640e015efe04_id_b67bb7c98bca4d3bc0a8640e01a07a7d", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Visualization Screens \/ Generating Visualization Screens \/ Order of embedding visualization elements ", 
"snippet" : "In the first step all visualizations which are embedded by next Ancestor will be arranged. These elements will be inserted in the preorder of the module instances in the module tree. (First the first child, then all of its submodules, then the second child and so on) After that, all visualizations, ...", 
"body" : "In the first step all visualizations which are embedded by next Ancestor will be arranged. These elements will be inserted in the preorder of the module instances in the module tree. (First the first child, then all of its submodules, then the second child and so on) After that, all visualizations, which are embedded by the definition of the instance, will be inserted. This will also be done in the preorder of the module instances. " }, 
{ "title" : "Persistence Manager ", 
"url" : "ac_pm_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager ", 
"snippet" : "The Persistence Manager is a standard component of the Application Composer. It is used to manage persistent remanent data. It recognizes such variables by certain attributes in the variables declaration. So it is an alternative option to the VAR PERSISTENT mechanism of the standard programming syst...", 
"body" : "The Persistence Manager is a standard component of the Application Composer. It is used to manage persistent remanent data. It recognizes such variables by certain attributes in the variables declaration. So it is an alternative option to the VAR PERSISTENT mechanism of the standard programming system. which manages persistent variables in a special global variables list ( Persistent Variables ). This mechanism is designed for time performance and storage in a remanent memory area. In contrast, the Persistence Manager stores persistent values in an external file and therefore makes fewer demands on the memory resources of a controller. It makes possible to keep the values even when declarations have been modified and it allows external editing of the data. This extended functionality however is at the cost of performance. Depending on the controller the reading and especially the writing of a big amount of persistent variables may take a lot of time and can block the respective task very long. So it depends on the use case, which mechanism is recommended for establishing data persistence. For certain cases even the use of recipes can be the best solution. To help make a decision, see: Persistence The Persistence Manager is a toplevel module and can be added to the module tree by use of the command Add toplevel module instance . Below the Persistence Manager you can insert up to 64 channels. In the channels you can define persistence groups and configure their storage behavior by parameters. Each channel must get a submodule Data Storage , defining the format in which the persistent data are written to a file. Here you define the format in which the persistent data is stored in a file. This archive file is stored externally, by default in the installation directory of the controller. For runtime system versions >= 3.5.8.0 the location for the archive files is defined via the placeholder $ac_persistence$ . Already existing archives will be moved to this location, if they are found in the directory defined by the placeholder $PLCLogic$ . This directory was the default location in previous runtime system versions. For archives located in both places, a warning is issued to the runtime system log. Only one Persistence Manager per application can be added to the module tree. If the Persistence Manager is added to the POUs pool or if more than one Persistence manager is added to the application an error message will be created. Persistence Manager added to the module tree If the module tree or parameter of module instances have been changed a generator run must be executed. (Command: Generate) Differences to the \"VAR PERSISTENCE\" mechanism The persistent data are stored in an external file. The persistent data can be exchanged between projects. Persistent variables can be deleted from the application resp. added to the application without the loss of the remaining data. Data which has been created by the Persistence Manager can be modified with external editors. (Example: Notepad). See also: Persistence " }, 
{ "title" : "Persistence Manager Module ", 
"url" : "ac_pm_persistencemanager_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager \/ Persistence Manager Module ", 
"snippet" : "A double click on the Persistence Manager node in the module tree or the Edit object command opens the associated editors. Besides the standard editors of toplevel modules (see Overview ) the Persistence Manager provides the Persistence tab. HMI The Persistence Manager provides a visualization templ...", 
"body" : "A double click on the Persistence Manager node in the module tree or the Edit object command opens the associated editors. Besides the standard editors of toplevel modules (see Overview ) the Persistence Manager provides the Persistence tab. HMI The Persistence Manager provides a visualization template ( VISU_PersistenceManager ) which can be added to the visualization. Dialog for HMI settings This page provides statistic information about the reading and writing of variables: Visualization page for persistence data " }, 
{ "title" : "Persistence ", 
"url" : "ac_pm_persistencemanager_module.html#UUID-87fcb435-c65b-2e65-6037-f61974f5b1d7_e4fa0ddccaa0cf0c0a8640e01493625_id_2bd57d34d6d13475c0a8640e0192d4cf", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager \/ Persistence Manager Module \/ Persistence ", 
"snippet" : "Dialog: Persistence In the Persistence dialog one or more groups can be excluded from storage. To create a new group a unique name must be entered and added with the Add button. The Remove command allows to delete existing groups. Variables can be excluded from storage by use of the attribute ac_per...", 
"body" : "Dialog: Persistence In the Persistence dialog one or more groups can be excluded from storage. To create a new group a unique name must be entered and added with the Add button. The Remove command allows to delete existing groups. Variables can be excluded from storage by use of the attribute ac_persist_exclude . For more information, see: Attribute: ‚ac_persist_exclude‘ " }, 
{ "title" : "Persistence Channel ", 
"url" : "ac_pm_channel_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager \/ Persistence Channel ", 
"snippet" : "A persistence channel defines the storage settings for one or more groups of persistent variables. It can be added to a Persistence Manager node by use of the command Add submodule instance . Below a Persistence Manager node, up to 64 channels can be created. HMI, Information For details about these...", 
"body" : "A persistence channel defines the storage settings for one or more groups of persistent variables. It can be added to a Persistence Manager node by use of the command Add submodule instance . Below a Persistence Manager node, up to 64 channels can be created. HMI, Information For details about these dialogs, see the following: I\/O, HMI and Information. " }, 
{ "title" : "Persistence ", 
"url" : "ac_pm_channel_module.html#UUID-af8d821d-a61e-6db4-8c17-a9f12c86748c_dc660673ccac225bc0a8640e0116ede0_id_1c75f716cd06b00bc0a865200055fd43", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager \/ Persistence Channel \/ Persistence ", 
"snippet" : "Persistent groups In this dialog, one or more groups can be defined which are managed by this channel. By default, the instance name of the channel module instance is available in the list. To create a new group, a unique name must be entered and added with the Add button. Remove can be used to dele...", 
"body" : "Persistent groups In this dialog, one or more groups can be defined which are managed by this channel. By default, the instance name of the channel module instance is available in the list. To create a new group, a unique name must be entered and added with the Add button. Remove can be used to delete selected groups. Variables can be assigned to groups through the attribute ac_persist . For more information, see the following: Definition of Persistent Variables, Attribute 'ac.persist' Persisted Variables : This list shows all persistent variables assigned to one of the persistence groups listed above. " }, 
{ "title" : "Parameters ", 
"url" : "ac_pm_channel_module.html#UUID-af8d821d-a61e-6db4-8c17-a9f12c86748c_dc660673ccac225bc0a8640e0116ede0_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager \/ Persistence Channel \/ Parameters ", 
"snippet" : "The Parameters tab provides a list of options relating to the storage of variables: Parameters of persistent channels tPeriodicSaving : After this interval has elapsed, the variables are stored. Entering the value t#0s will switch off this periodic saving. xSaveOnChange : If this is set to TRUE, the...", 
"body" : "The Parameters tab provides a list of options relating to the storage of variables: Parameters of persistent channels tPeriodicSaving : After this interval has elapsed, the variables are stored. Entering the value t#0s will switch off this periodic saving. xSaveOnChange : If this is set to TRUE, the current value will be constantly compared with the last saved value, and if they are different, the current value will be stored. Persistence channels, which have set xSaveOnChange=FALSE , will be stored at a shutdown of the controller as well at a reset (warm, cold, origin). Moreover, periodic saving can take place. xReadVarsDuringInit : If this is set to TRUE , the persistent variable values will be read during the initialization of the application. Otherwise, they are loaded in the first application cycle. xCompressTags : If this is set to TRUE , the instance paths of the variables will be saved in a compressed format. For more information, see the following: Storage Format, Compressed Archives . xConsistentCopyInHighPrioTask : If this is set to TRUE , the variables are copied from the highest priority task and saved in the lower priority task. This option is used to avoid data inconsistencies when variables are changed in a high priority task. xConvertVarsWithDifferentType : If this is set to TRUE , the persistence channel will to try to convert the value read from the archive to the target data type (if the data type of the value is different from that of the target). If successful, the value from the archive will be accepted; if not, the value will be rejected. This function supports the following conversions: Data type in the archive Target data type Description any Integer any Integer only if the value is in the range covered by the current data type any Integer Real any Integer LReal all data types String Real LReal Real ANY_INT only if the archive value is an integer in the correct range LReal Real only if the value is in the range covered by a REAL LReal ANY_INT Only if the archive value is an integer in the correct range xIntegrityCheckBeforeReading : When the parameter is TRUE , the integrity of the database is checked and an integrity object is saved when the archive is closed. xSeparateArchivePerToplevelInstance : When this is set to TRUE , a separate archive is created for each toplevel instance. The name of such an archive is its own name (as configured in the DataStorage) followed by the name of the toplevel instance: <archive name>_<instance name> or as <archive name> for all instances which are not below a toplevel module instance (example: application variables). This option is disabled by default. If you modify the parameter afterwards ( TRUE <-> FALSE ), then the archive name will be changed and persistent variables might be lost. xMakeDataCRCConsistencyCheck : When this is set to TRUE , a CRC value is calculated at the beginning and end of the save operation. These two values must be the same to successfully complete the save operation. uiSavingRetriesIfCRCConsistencyCheckFails : Specifies the number of times to repeat the storage if xMakeDataCRCConsistencyCheck is set to TRUE and the CRC values do not match. xLogSaveTimeEnabled : When this is set to TRUE , the time needed for writing is logged. eAutomaticActionOnlineChange : Behavior, if and how the values of variables are stored during an online change. None : No storage Save : The values are saved. Thus also changes to the configuration are taken over into the persistence memory (for example adding or renaming variables). Load : The values are loaded from the persistence memory. Thus, possible initializations (by e.g. FB_INIT , IModule.Init , and module parameters) are overwritten by the persisted values. LoadAndSave : The values are loaded as well as written from the persistence memory. eAutomaticActionPlcStop : Determines whether the values of variables are stored during a reset. None : No storage Save : The values are saved. " }, 
{ "title" : "Module: Data Storage ", 
"url" : "ac_pm_storage_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager \/ Module: Data Storage ", 
"snippet" : "Data Storage The submodule Data Storage defines the storage format of a persistence channel . Choose one of the following storage formats: ASCIIFileStorage : Saving the values in ASCII format in a file. The ASCIIFileStorage format allows to open the archive file in a text editor and to modify the va...", 
"body" : "Data Storage The submodule Data Storage defines the storage format of a persistence channel . Choose one of the following storage formats: ASCIIFileStorage : Saving the values in ASCII format in a file. The ASCIIFileStorage format allows to open the archive file in a text editor and to modify the values. Comments can be added to ASCII file archive. These will be ignored when the file is read. BinaryFileStorage : Saving the values in binary format in a file. BinaryMemoryStorage :Saving the values in binary format to the \"RETAIN\" area of the compiler or the device concerned (example: to the NVRAM of such a device.) PersistentBinaryMemoryStorage : Saving the values in binary format to the \"Persistent\" area of the compiler or the device concerned (example: to the NVRAM of such a device.) Below the persistence channel insert a Data Storage module of the desired format. If necessary, modify the configuration in Parameter tab: Dialog: Information For details about this dialog, see the following: Information . " }, 
{ "title" : "Dialog: Parameters ", 
"url" : "ac_pm_storage_module.html#UUID-1d4190f0-4f49-535e-fe96-bf340f625ee5_aa44ae4cccad1068c0a8640e019d97f0_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager \/ Module: Data Storage \/ Dialog: Parameters ", 
"snippet" : "sArchiveName Name of the archive file By default the placeholder %CHANNEL_NAME% is defined. This placeholder will be replaced by the instance name of the superior persistence channel. The archive name must be unique, because all archive files get stored by default in the installation directory of th...", 
"body" : "sArchiveName Name of the archive file By default the placeholder %CHANNEL_NAME% is defined. This placeholder will be replaced by the instance name of the superior persistence channel. The archive name must be unique, because all archive files get stored by default in the installation directory of the controller. Note: The default storage location for archive files depends on the runtime system version. See: Persistence Manager Overview xDoubleStorage If activated ( TRUE ), the variables are stored alternately in two different archives ( sArchive1 , sArchive2 ). In case of a corrupted file (example: due to a shutdown of the controller during the storage of variables), the backup file will be used. When the file is opened the Persistence Manager checks the timestamp of both archives. In case of no damage the newer archive will be used, otherwise the other one. udiMaximumFileSize The maximum file size in bytes If 0 is defined, no limit is set or checked. So the file size can reach any size. bySeparator ASCII value for separator between variable name and value. udiMemDataSize Size of the memory in the \"RETAIN\" variable area, which is created for the module. The value is compared to the size of the data to be stored. If the value is definitely too small a compiler error is created. If it is possibly too small a warning is displayed in the message view. LineEnding Character which indicates the end of the line in the file " }, 
{ "title" : "Definition of Persistent Variables ", 
"url" : "ac_pm_definition_persistent_variables.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager \/ Definition of Persistent Variables ", 
"snippet" : "Single variables as well as structure instances and function block instances can be marked as \"persistent\" by the use of attributes. When an instance is marked, all members of VAR , VAR_INPUT , and VAR_OUTPUT will be stored persistently. In case that variables in a VAR PERSISTENT section are marked ...", 
"body" : "Single variables as well as structure instances and function block instances can be marked as \"persistent\" by the use of attributes. When an instance is marked, all members of VAR , VAR_INPUT , and VAR_OUTPUT will be stored persistently. In case that variables in a VAR PERSISTENT section are marked as \"persistent\", a warning will be created. Additionally there are attributes for defining a default storage group, as well as for excluding particular variables from the persistent storage of structures or function block instances. If the definition of persistent variables has been modified (adding, removing, renaming, changing data type) no new composer code generation (command Generate) must be executed. These changes will be updated in the Persistent Manager instances automatically during compilation. For information about the possible implicit conversions in case of a modified data type definition please, see: Parameter Attribute: 'ac_persist_exclude' The attribute 'ac_persist_exclude' is used to exclude a variable from the persistent storage, no matter if members in the structure or function block declaration are defined as \"persistent\". If there exist no persistent members in the declaration an error will be created during code generation. Example for exclusion of variables PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist_exclude'}\n fb1 : FB;\nEND_VAR " }, 
{ "title" : "Supported data types ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_beff9eaed151b190c0a8640e01016617", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager \/ Definition of Persistent Variables \/ Supported data types ", 
"snippet" : "Instances with the following data types cannot be stored persistently: BIT Pointer Interfaces Constants Arrays of non-persistent data types All other data types are supported. This includes enumerations, subrange data types, arrays of arrays and multidimensional arrays: ARRAY[0..9] OF ARRAY[5..6, 7....", 
"body" : "Instances with the following data types cannot be stored persistently: BIT Pointer Interfaces Constants Arrays of non-persistent data types All other data types are supported. This includes enumerations, subrange data types, arrays of arrays and multidimensional arrays: ARRAY[0..9] OF ARRAY[5..6, 7..8, 9..10] OF INT Data Type: UNION To save the instance of an union persistently, one of its fields must be marked as \"representative\". There are three possible ways: Exactly one field in the declaration of the union is marked with the attribute ac_persist_union_representant (without attribute value). This field then \"represents\" the union. Its value will be saved and loaded representatively for the complete union. Exact one field in the declaration of the union is marked with the attribute ac_persist – this defines the representative at the same time. The instance of the union is marked with the attribute ac_persist_union_set_representant including the attribute value. The attribute value describes the name of the union field which shall be used as representative. This attribute overwrites an existing ac_persist_union_representant attribute in the declaration of the union. Arrays of unions can also be marked and refer to the elements of the array. Examples 'ac_persist_union_representant' TYPE UnionWithRep :\nUNION\n di : DINT ;\n {attribute 'ac_persist_union_representant'}\n dw : DWORD ;\nEND_UNION\nEND_TYPE 'ac_persist' TYPE UnionWithPersist :\nUNION\n di : DINT ;\n {attribute 'ac_persist' := 'TestUnion'}\n dw : DWORD ;\nEND_UNION\nEND_TYPE 'ac_persist_union_set_representant‘ FUNCTION_BLOCK FBTestUnion\nVAR\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n u2 : UnionWithoutRep ;\nEND_VAR Array of union VAR\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n aElems ARRAY[0..7] OF SomeUnion ;\n\n {attribute 'ac_persist_union_set_representant' := 'dw'}\n aaElems ARRAY[0..7] OF ARRAY[0..1] OF SomeUnion ;\nEND_VAR For a representative to be valid, it has to fulfill the following rules: The representative must have the same size as the whole union. Otherwise the complete data would not be saved. The representative also must not have any padding areas (empty data areas created by the compiler to align the data in the storage). The decomposition of the representative in primitive data types must not contain instances of type REAL or LREAL or instance of type STRING or WSTRING . Furthermore the representative must consist of supported types (see above). For example the representative can be of type Structure – however, the structure itself must not contain Pointer. " }, 
{ "title" : "Attribute: 'ac_persist' ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_e844aaa8d151b192c0a8640e01722fe3", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager \/ Definition of Persistent Variables \/ Attribute: 'ac_persist' ", 
"snippet" : "The attribute ‘ ac_persist ‘ can be used for Variables Instances of structures Instances of function blocks Members of structures Members of function blocks {attribute 'ac_persist' [ := '<PERSISTENCE_GROUP>']} PERSISTENCE_GROUP is the name of the persistence group to which the declaration should be ...", 
"body" : "The attribute ‘ ac_persist ‘ can be used for Variables Instances of structures Instances of function blocks Members of structures Members of function blocks {attribute 'ac_persist' [ := '<PERSISTENCE_GROUP>']} PERSISTENCE_GROUP is the name of the persistence group to which the declaration should be assigned. It must be a valid IEC identifier. If no persistence group is named here, the assignment will be done according to attribute 'ac_persist_set_default_group' , which in this case must be defined. If a structure instance or a function block instance is marked as \"persistent\" and at least one member in the declaration is also marked as \"persistent\" an error message will be created. Example for a persistent instance The variable t is assigned to the persistence group PROCESS . All members will be stored persistently. PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist' := 'PROCESS'}\n t : TON;\nEND_VAR Example for a persistent members of a function block The member iNumIOs is assigned to the persistence group CONFIG . This member will be stored persistently for all instances of the function block (if not explicitly suppressed by the attribute 'ac_persist_exclude' ). FUNCTION_BLOCK FB\nVAR\n {attribute 'ac_persist' := 'CONFIG'}\n iNumIOs : INT := 0;\nEND_VAR " }, 
{ "title" : "Attribute: 'ac_persist_set_default_group' ", 
"url" : "ac_pm_definition_persistent_variables.html#UUID-f85f0c85-27c7-5dc8-30a0-28d56cebddd4_f1cc15fd1014ddac0a8640e002d258f_id_4130a661d151b192c0a8640e00b1a163", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager \/ Definition of Persistent Variables \/ Attribute: 'ac_persist_set_default_group' ", 
"snippet" : "If the group name is missing in the attribute 'ac_persist' , a default group must be defined in a function block instance or structure instance containing the respective variable directly or indirectly. This is possible with the attribute 'ac_persist_set_default_group' . The attribute also can be se...", 
"body" : "If the group name is missing in the attribute 'ac_persist' , a default group must be defined in a function block instance or structure instance containing the respective variable directly or indirectly. This is possible with the attribute 'ac_persist_set_default_group' . The attribute also can be set for a member of the function block. The innermost found definition of 'ac_persist_set_default_group' will be used as default group for the variable. It is not allowed to use 'ac_persist_set_default_group' together with 'ac_persist' or 'ac_persist_exclude' . In this case an error message will be created during code generation. Example for a default group FUNCTION_BLOCK FB_Util\nVAR\n {attribute 'ac_persist'} \/\/ no group\n \/\/'ac_persist_set_default_group‘ and 'ac_persist_exclude' not allowed here\n i : INT := 0;\nEND_VAR PROGRAM PLC_PRG\nVAR\n {attribute 'ac_persist_set_default_group' := 'PROCESS'}\n fbu1 : FB_Util;\n\n {attribute 'ac_persist_set_default_group'´ := 'CONFIG'}\n fbu2 : FB_Util;\nEND_VAR " }, 
{ "title" : "Data Storage ", 
"url" : "ac_pm_data_storage.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager \/ Data Storage ", 
"snippet" : "The storage of persistent variables can be triggered in various ways: Each persistence channel provides an application interface which can be used by the application to trigger a storage (see Data Access ). In the parameters of the persistence channel a time interval ( tPeriodicSaving ) can be defin...", 
"body" : "The storage of persistent variables can be triggered in various ways: Each persistence channel provides an application interface which can be used by the application to trigger a storage (see Data Access ). In the parameters of the persistence channel a time interval ( tPeriodicSaving ) can be defined for automatic storage. The persistence channel can be configured to store a variable whenever its value changes. For this the previous value and the current value are compared; if they are different the storage will be triggered. The different ways of storage can be used in parallel and they are not mutually exclusive. In case of a shutdown of the controller or after \"Reset\" (warm \/ cold \/ origin) the data is stored automatically if the parameter xSaveOnChange is not set. For more information, see also: Module: Data Storage " }, 
{ "title" : "Storage Format ", 
"url" : "ac_pm_storage_format.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager \/ Storage Format ", 
"snippet" : "There are two implementations of the interface IDataStorage available: ASCIIDataStorage and BinaryDataStorage . In both formats the first variable which is stored is the reserved variable ___xCompressTags of type BOOL . Its value determines if the instance paths are stored compressed. If an integrit...", 
"body" : "There are two implementations of the interface IDataStorage available: ASCIIDataStorage and BinaryDataStorage . In both formats the first variable which is stored is the reserved variable ___xCompressTags of type BOOL . Its value determines if the instance paths are stored compressed. If an integrity object is written, then it is written as the last variable named ___Integrity of type BOOL with value TRUE . All persistent variables except these reserved variables are stored in order and sorted by their full instance path. It does not matter if the instance paths compressed or not. If the data are modified by the user, he has to make sure that the right sort order will be maintained. Compressed archives The variable values are stored with path and name (in the path there is neither the application nor the device name) in a compact spelling to save resources and time. In any case (compressed or not) the instance paths must be sorted in order of the full instance path. This sort order is alphabetically, whereby array indices are sorted numerically. Examples Objects Compressed Format Fb1.fb2.fb3.a Fb1.fb2.fb3.a Fb1.fb2.fb3.b <b Fb1.fb2.d <<d Fb4 FB4 " }, 
{ "title" : "ASCII format ", 
"url" : "ac_pm_storage_format.html#UUID-fdd959e2-aa65-d5fc-5e9f-c1b6b7e12d4a_d165b0fbc0a8640e003c31fa_id_7b30973fd16738e7c0a8640e01455e29", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager \/ Storage Format \/ ASCII format ", 
"snippet" : "ASCIIDataStorage writes each instance path of the persistent variables (possibly in compressed format), the data type and the value as a string into the file. The name and the date are separated by a tab character (can be changed by parameter codbySeparator ). When the archive is read, a conversion ...", 
"body" : "ASCIIDataStorage writes each instance path of the persistent variables (possibly in compressed format), the data type and the value as a string into the file. The name and the date are separated by a tab character (can be changed by parameter codbySeparator ). When the archive is read, a conversion will be executed. Therefore the file can be modified externally. Lines must be separated by \"\\r\\n\" (Windows convention). Lines which starts with a semicolon will be ignored on reading - this line will not be added when the archive is written. Format of an ASCII file: {timestamp}\\r\\n\n{instance path}{bySeparator}{Typ}:{value}\\r\\n\n…\n{instance path}{bySeparator}{Typ}:{value}\\r\\n The time stamp determines the time when the storage was triggered. It is written as DATE_AND_TIME literal (example: DT#2012-01-11-15:11:09 ) Example of an ASCII file Treatment of REAL and LREAL variables: The values of variables are written as ST literals. REAL and LREAL values are treated differently, because the implementation of the conversion into and from decimal fractions without loss of accuracy. However to avoid any loss of accuracy and to maintain the readability and the possibility to modify the ASCII file, these values are stored in a hexadecimal format. The (inexact) decimal fraction is added behind the hexadecimal value as a comment. While reading the file, the hexadecimal format as well as the ST decimal format are supported. This allows the user to modify the decimal fraction. The hexadecimal format is defined as follows: F16#{Mantissa}H{Exp} | F16#NaN | F16#+Inf | F16#-Inf\n{Mantissa} ::= {HexNumeral}\n{Exp} ::= {HexNumeral}\n{HexNumeral} ::= [+-]?[1-9A-F][0-9A-F]* If m is the value of the mantissa and e the value of the exponent than the value of the number is m * 16^e . Example of a stored REAL value lr1 LREAL:F16#F0H-3 0.05859375 " }, 
{ "title" : "Binary format ", 
"url" : "ac_pm_storage_format.html#UUID-fdd959e2-aa65-d5fc-5e9f-c1b6b7e12d4a_d165b0fbc0a8640e003c31fa_id_602fd614d22a5f95c0a8640e0110d837", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager \/ Storage Format \/ Binary format ", 
"snippet" : "BinaryDataStorage saves the data in a binary format. The time stamp follows that (type DATE_AND_TIME ). After that the variables are listed....", 
"body" : "BinaryDataStorage saves the data in a binary format. The time stamp follows that (type DATE_AND_TIME ). After that the variables are listed. " }, 
{ "title" : "Data Access ", 
"url" : "ac_pm_data_access.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager \/ Data Access ", 
"snippet" : "The Persistence Manager provides up to 10 submodule instances of type PersistenceChannel. Each persistence channel provides a submodule instance of type DataStorage which is responsible for the data access. This instance implements the interface IDataStorage :...", 
"body" : "The Persistence Manager provides up to 10 submodule instances of type PersistenceChannel. Each persistence channel provides a submodule instance of type DataStorage which is responsible for the data access. This instance implements the interface IDataStorage : " }, 
{ "title" : "Diagnosis ", 
"url" : "ac_pm_diagnosis.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager \/ Diagnosis ", 
"snippet" : "Each persistence channel has a submodule which allows data access (interface IDataStorage ). The following outputs provide diagnostic information: Output Data Type Description xActionOngoing BOOL TRUE if the Persistence Manager reads or writes data udiDataMemSize UDINT Data size of the persistent da...", 
"body" : "Each persistence channel has a submodule which allows data access (interface IDataStorage ). The following outputs provide diagnostic information: Output Data Type Description xActionOngoing BOOL TRUE if the Persistence Manager reads or writes data udiDataMemSize UDINT Data size of the persistent data in bytes xReadingDone BOOL Reading of persistent data finished dtLastReading DT Date and time of the last reading uiNumberVarsNotOk UINT Number of variables which have not been read correctly uiNumberVarsOk UINT Number of variables which have been read correctly tTimeForReading TIME Time duration for reading dtLastSaving DT Date and time of the last reading tTimeForWriting TIME Time duration for writing uiWritingCycles UINT Number of storages till start of application The information about the number of variables read and about the success of the storage are also displayed in the PLC logger. PLC logging¶ " }, 
{ "title" : "Error Handling ", 
"url" : "ac_pm_error_handling.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Persistence Manager \/ Error Handling ", 
"snippet" : "Error numbers and the related strings are called or acknowledged by means of the standard module interfaces ( ClearErrors , FirstErrorNumber , GetFirstErrorMessage , LastErrorNumber , GetLastErrorMessage ). Error Number Description 100 List of persistent data has changed and does not match the initi...", 
"body" : "Error numbers and the related strings are called or acknowledged by means of the standard module interfaces ( ClearErrors , FirstErrorNumber , GetFirstErrorMessage , LastErrorNumber , GetLastErrorMessage ). Error Number Description 100 List of persistent data has changed and does not match the initial size 110 Memory (for comparison or consistent copy) can not be created. <ErrorCode SysMemAllocData> . Feature is switched off. 120 Data storage can not be created for the comparison storage. Feature is switched off. 130 Data storage not created for consistent copy 140 Persistent variable of type String has invalid size: <name of the variable> 150 Persistent variable is not of supported type: <name of the variable> 160 Database cannot be opened. Reading aborted: <detailed error description of the database object> 170 Database cannot be closed. Reading aborted: <detailed error description of the database object> 190 Database cannot be created. Saving aborted. <detailed error description of the database object> 200 Database cannot be opened. Saving aborted. <detailed error description of the database object> 210 Database cannot be closed. <detailed error description of the database object> 220 Error while writing of an entry: <detailed error description of the database object> 230 Error while reading the system time " }, 
{ "title" : "DataLog Manager ", 
"url" : "ac_dlm_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ DataLog Manager ", 
"snippet" : "The DataLog Manager is a standard component of the Application Composer. It serves for cyclic storage of variable values into a file. These variables are flagged with special attributes in the variable declaration. To make the module available you have to add the AC_DataLog library to the library ma...", 
"body" : "The DataLog Manager is a standard component of the Application Composer. It serves for cyclic storage of variable values into a file. These variables are flagged with special attributes in the variable declaration. To make the module available you have to add the AC_DataLog library to the library manager. Only one DataLog Manager per application can be added to the module tree. The DataLog Manager is a toplevel module and can be added to the module tree by use of the Add toplevel module instance command. Below the DataLog Managers you can insert up to 64 channels. In the channels you can define groups and configure their storage behavior by parameters. Each channel must get a submodule DataLog storage. Add DataLog Manager to the module tree If the module tree or parameter of module instances have been changed a generator run must be executed. (Command: Generate ). For this purpose the DataLog Generator in the Generator Configuration must be activated. " }, 
{ "title" : "Module: DataLog Manager ", 
"url" : "ac_dlm_datalogmanager_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ DataLog Manager \/ Module: DataLog Manager ", 
"snippet" : "DataLog Manager The DataLog Manager manages the data logging of variables. It can be added to the module tree below the upper most object . This is done by the Add Toplevel Instance command and the selection of the DataLogManager module. Only one DataLog Manager per application can be added. Dialog:...", 
"body" : "DataLog Manager The DataLog Manager manages the data logging of variables. It can be added to the module tree below the upper most object . This is done by the Add Toplevel Instance command and the selection of the DataLogManager module. Only one DataLog Manager per application can be added. Dialog: HMI The DataLog Manager provides a visualization template ( VISU_DataLogManager ) which can be added to the visualization. For more information, see: HMIIn online mode this page provides statistic information about the reading and writing of variables. " }, 
{ "title" : "Dialog: Data Logging ", 
"url" : "ac_dlm_datalogmanager_module.html#UUID-5158e4eb-39c1-2002-c9f6-d4d4a1d20765_f45d0fbcc9eecefdc0a8646307e5e8bf_id_2bd57d34d6d13475c0a8640e0192d4cf", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ DataLog Manager \/ Module: DataLog Manager \/ Dialog: Data Logging ", 
"snippet" : "In this dialog one or more groups can be excluded from storage. By default the DataLogManager group is created. Add Adding and removing of groups which are excluded from storage. Remove...", 
"body" : "In this dialog one or more groups can be excluded from storage. By default the DataLogManager group is created. Add Adding and removing of groups which are excluded from storage. Remove " }, 
{ "title" : "Module: DataLog Channel ", 
"url" : "ac_dlm_channel_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ DataLog Manager \/ Module: DataLog Channel ", 
"snippet" : "DataLog Channel The DataLog Channel module is used to define groups for the variable storage. The module can be added below the Datalog Manager node. This is done by the Add Submodule Instance command and the selection of the DataLogChannel module. Up to 64 DataLog channels can be added. Dialog: HMI...", 
"body" : "DataLog Channel The DataLog Channel module is used to define groups for the variable storage. The module can be added below the Datalog Manager node. This is done by the Add Submodule Instance command and the selection of the DataLogChannel module. Up to 64 DataLog channels can be added. Dialog: HMI, Information For details about these dialogs, see the help page HMI , and Information " }, 
{ "title" : "Dialog: Data Logging ", 
"url" : "ac_dlm_channel_module.html#UUID-e506780f-95c5-ee2b-f5d3-9586237393e3_a5d87b34c9f11a67c0a8646314ce243b_id_1c75f716cd06b00bc0a865200055fd43", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ DataLog Manager \/ Module: DataLog Channel \/ Dialog: Data Logging ", 
"snippet" : "In this dialog one or more groups can be defined which are managed by this channel. By default, the instance name of the channel module instance is available in the list. Groups logged by this channel New Definition of a group The entry is added to the list by use of the Add command. Use hashed inst...", 
"body" : "In this dialog one or more groups can be defined which are managed by this channel. By default, the instance name of the channel module instance is available in the list. Groups logged by this channel New Definition of a group The entry is added to the list by use of the Add command. Use hashed instance paths : The entry is not stored with the complete instance path but with the hash value of the string to save memory space. The assignment between hash and instance path is saved in a separate file. Remove Removes the selected group from the list Logged variables List of variables assigned to the lists These variables have the {attribute 'ac_datalog' := '<group name>'} attribute. Refresh Updates the list of logged variables Note: The list can only be updated if the DataLog Generator is activated. Variables can be assigned to the groups by the ac_datalog attribute. The ac_datalog_hysteresis attribute defines the hysteresis that have to be exceeded before a variable is logged. Example VAR\n {attribute 'ac_datalog' := 'DataLogChannel'}\n {attribute 'ac_datalog_hysteresis' := '0.745'}\n rLogVar : REAL;\nEND_VAR " }, 
{ "title" : "Dialog: Parameters ", 
"url" : "ac_dlm_channel_module.html#UUID-e506780f-95c5-ee2b-f5d3-9586237393e3_a5d87b34c9f11a67c0a8646314ce243b_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ DataLog Manager \/ Module: DataLog Channel \/ Dialog: Parameters ", 
"snippet" : "In this dialog, the parameters for the saving the DataLog variables are defined. Activate FALSE : Variables stored by this channel are not logged. Save in first cycle TRUE : All variables of this channel will be logged in the first cycle. Save Cyclic Data type TIME : All variables of this channel wi...", 
"body" : "In this dialog, the parameters for the saving the DataLog variables are defined. Activate FALSE : Variables stored by this channel are not logged. Save in first cycle TRUE : All variables of this channel will be logged in the first cycle. Save Cyclic Data type TIME : All variables of this channel will are stored cyclically. The value T#0s deactivates the logging. " }, 
{ "title" : "Module: DataLog Storage CSV ", 
"url" : "ac_dlm_storage_csv_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ DataLog Manager \/ Module: DataLog Storage CSV ", 
"snippet" : "DataLog Storage CSV The submodule DataLogStorage_CSV defines the storage format of a DataLog channel as CSV file. It can be added below a DataLog channel node. This is done by the Add Submodule Instance command and the selection of the DataLogStorage_CSV module. Dialog: Information For details about...", 
"body" : "DataLog Storage CSV The submodule DataLogStorage_CSV defines the storage format of a DataLog channel as CSV file. It can be added below a DataLog channel node. This is done by the Add Submodule Instance command and the selection of the DataLogStorage_CSV module. Dialog: Information For details about these dialogs, see the help page in Information . " }, 
{ "title" : "Dialog: Parameters ", 
"url" : "ac_dlm_storage_csv_module.html#UUID-77b82c47-16c6-5f2f-5d4f-34b67bccf3d3_d1edd6c9f1f1a7c0a864637755e4ae_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ DataLog Manager \/ Module: DataLog Storage CSV \/ Dialog: Parameters ", 
"snippet" : "Storage name Name of the storage file By default the placeholder %CHANNEL_NAME% is defined. This placeholder will be replaced by the instance name of the superior DataLog channel. The storage file name must be unique, since all storage files are stored in the same directory.by default. Optionally a ...", 
"body" : "Storage name Name of the storage file By default the placeholder %CHANNEL_NAME% is defined. This placeholder will be replaced by the instance name of the superior DataLog channel. The storage file name must be unique, since all storage files are stored in the same directory.by default. Optionally a placeholder %DATE% can be added for the date of storage. The resolution is defined in the parameter Format string for replacing %DATE% (see below). Example: With the name specification '%CHANNEL_NAME%_AT_%DATE%' , the following file name results for the DataLogChannel_1 channel: Application_DataLogChannel_1_AT_20191211_02-10-30.csv Separator : ASCII value for separator between variable name and value. Example: ',' Buffer size : Size of the internal buffer for temporary storage of the entries. Example: 2000 Buffer fill level Value in percentage. If the buffer is filled up to this value, the content of the buffer is written to the CSV file. Specifying 0 deactivates buffering. An entry in the file has the following form (with | as a separator): <TimeStamp>|<InstancePath\/Hash>|<Value>[|<TypeClass>] If the storage is executed with hashed paths the data type is not stored with every entry but only once in a separate file where the assignment hash ↔ instance path is stored. The entry in this file has the form: <InstancePath>|<TypeClass>|<Hash> In case of an online change the files are not deleted. The new entries are appended. In the hash file an online change is marked with a timestamp. Thus the assignment of hash ↔ instance path for entries before online change is still possible. During initialization after a download (no online change) the data and hash files are deleted. Enclosing characters Add enclosing characters TRUE : String entries will be stored with surroundings. Example: Variable value: File1 , file entry: -File1- . FALSE : String entries are stored without enclosing characters. Enclosing characters Characters used for enclosing. Example: '-' Format string for replacing %DATE% Date format used to replace the %DATE% which can be specified in parameter Storage Name (see above). Examples: 'yyyyMMdd' , 'yyyyMMdd_hh-mm-ss' LineEnding Character which indicates the end of the line in the file " }, 
{ "title" : "Module: DataLog Storage SQLite ", 
"url" : "ac_dlm_storage_sqlite_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ DataLog Manager \/ Module: DataLog Storage SQLite ", 
"snippet" : "DataLog Storage SQLite The submodule DataLogStorage_SQLite defines the storage format of a DataLog channel for a SQLite database. It can be added below a DataLog channel node. This is done by the Add Submodule Instance command and the selection of the DataLogStorage_SQLite module. Dialog: Informatio...", 
"body" : "DataLog Storage SQLite The submodule DataLogStorage_SQLite defines the storage format of a DataLog channel for a SQLite database. It can be added below a DataLog channel node. This is done by the Add Submodule Instance command and the selection of the DataLogStorage_SQLite module. Dialog: Information For details about this dialog, see: Information . " }, 
{ "title" : "Dialog: Parameters ", 
"url" : "ac_dlm_storage_sqlite_module.html#UUID-63e71af3-388f-498c-6553-5ab20ff603a1_accbd5f8d8b6d029c0a86463569e125f_id_c1a44917cd06b002c0a86520011dc409", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ DataLog Manager \/ Module: DataLog Storage SQLite \/ Dialog: Parameters ", 
"snippet" : "Storage name : Name of the archive file By default the placeholder %CHANNEL_NAME% is defined. This placeholder will be replaced by the instance name of the superior DataLog channel. The archive name must be unique, because all archive files get stored by default in the installation directory of the ...", 
"body" : "Storage name : Name of the archive file By default the placeholder %CHANNEL_NAME% is defined. This placeholder will be replaced by the instance name of the superior DataLog channel. The archive name must be unique, because all archive files get stored by default in the installation directory of the controller. All instances of this module of an application share this file. This file is initially created by one of the storage modules. The name of the file is always <ApplicationName>_DataLog.sqlite Maximum number of entries : The maximum number of entries for the database of this module instance. The value 0 deactivates the function. If the maximum number is exceeded, the table behaves like a ring buffer and the first entries will be overwritten. " }, 
{ "title" : "Definition of Logging Variables ", 
"url" : "ac_dlm_definition_logging_variables.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ DataLog Manager \/ Definition of Logging Variables ", 
"snippet" : "Variables are flagged for the data logging by attributes. ac_datalog [:= group name] : This attribute assigns the variable to a logging group. If the variable is a structured variable, all members which can be logged and which are not excluded will be logged. If no group name is set, each instance o...", 
"body" : "Variables are flagged for the data logging by attributes. ac_datalog [:= group name] : This attribute assigns the variable to a logging group. If the variable is a structured variable, all members which can be logged and which are not excluded will be logged. If no group name is set, each instance of the structured variable must be marked separately. ac_datalog_set_default_group : Sets the group of all members of an instance of a structured type which are not explicitly assigned to a group. ac_datalog_exclude : This attribute excludes a variable of a structured data type from data logging. ac_datalog_union_representant : This attribute defines a representative within an UNION, which is used for data logging. ac_datalog_hysteresis := ‘value‘ : This attribute sets the hysteresis. The value must be exceeded to log a variable. This attribute is only respected for numeric data types. If it is used for non-numeric data types, a warning will be displayed and the value will be ignored. You find an additional description and examples on the help page of the Persistence Manager attributes. " }, 
{ "title" : "Device Diagnosis Generator ", 
"url" : "ac_device_diagnose_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Device Diagnosis Generator ", 
"snippet" : "The device diagnosis module is a standard component of the Application Composer, which is included in the library AC_DeviceDiagnosis . The module is a toplevel module and can be added to the module tree by the command Add toplevel module instance . Device diagnosis module in the module tree With the...", 
"body" : "The device diagnosis module is a standard component of the Application Composer, which is included in the library AC_DeviceDiagnosis . The module is a toplevel module and can be added to the module tree by the command Add toplevel module instance . Device diagnosis module in the module tree With the help of the device diagnosis module, a visualization page is created, based on the existing device configuration, which depicts the PLC and the connected fieldbus devices in a tree structure. In this tree structure, the state of each component is displayed. If necessary, detailed information can be called up or the operating mode of single components changed. Generated visualization page for device diagnosis Device diagnosis in online mode In online-mode, the name of the device, the status and the error code are shown. The status of the devices is shown in a color scheme: Green: The device has the status \"Running\" Red: The device does not have the status \"Running\" Dialog for changing the status Clicking the device opens a window in which the device can be halted, ( Stop ), reset ( Reset ) or started ( Start) . When the dialog is opened for the first time, all functions are shown. Functions which are not supported by the hardware will be faded out upon first activation. " }, 
{ "title" : "Requirements ", 
"url" : "ac_device_diagnose_overview.html#UUID-fd01086a-c692-d615-c1cf-d5963632aa4b_ac778b834d585cc0a8640e01a520c3_id_be299b7583c984f0c0a86520016ce88a", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Device Diagnosis Generator \/ Requirements ", 
"snippet" : "The displayed diagnosis details come from the CAA-Device-Diagnose-FBs (device-FBs) which were created by the devices. To generate these components, the option Activate diagnosis for devices has to be set in the PLC settings. These FBs deliver not only the normal status information which is displayed...", 
"body" : "The displayed diagnosis details come from the CAA-Device-Diagnose-FBs (device-FBs) which were created by the devices. To generate these components, the option Activate diagnosis for devices has to be set in the PLC settings. These FBs deliver not only the normal status information which is displayed in the (above) overview, but also detailed information, which is shown in an additional display. If the option Activate diagnosis for devices has not been set before generation, the generation process is aborted and the option is set automatically, so that the next generation run creates the desired visualization. To generate this visualization page, the device diagnosis generator must be activated in the Generator configuration . " }, 
{ "title" : "Commands ", 
"url" : "core_applicationcomposer_composer_home.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands ", 
"snippet" : "The commands in the command category Composer are provided with the  CODESYS Application Composer . These commands mainly serve to add composer objects to the Module tree or to modify them. Furthermore there are functions to map the variables to the IO configuration and to build a CODESYS applicatio...", 
"body" : "The commands in the command category Composer are provided with the  CODESYS Application Composer . These commands mainly serve to add composer objects to the Module tree or to modify them. Furthermore there are functions to map the variables to the IO configuration and to build a CODESYS application. The availability of the commands depends on the selected object in the module tree: Only commands which are allowed at the current selected position will be selected. " }, 
{ "title" : "Application Composer Dedicated View ", 
"url" : "ac_dedicated_view.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Application Composer Dedicated View ", 
"snippet" : "The Application Composer provides an as easy as possible way to create entire applications and to run them. Dedicated to this simplicity aspects, CODESYS offers a reduced view of the user interface. This view can be started by selecting the profile \"CODESYS Composer Dedicated\" or by the correspondin...", 
"body" : "The Application Composer provides an as easy as possible way to create entire applications and to run them. Dedicated to this simplicity aspects, CODESYS offers a reduced view of the user interface. This view can be started by selecting the profile \"CODESYS Composer Dedicated\" or by the corresponding link in the CODESYS start menu entries. After that a reduced view of CODESYS , which only provides access to the absolutely necessary windows and commands needed to create a working application using the CODESYS Application Composer Application Composer is shown. Application Composer Dedicated View There are only windows for module tree, device tree and messages together with commands for online login\/logout\/run\/stop and Composer operations. Within the latter, two commands are strongly related to the \"Application Composer dedicated\" view: Generate, Compile and Login : Used to generate code, compile it and eventually login the device and start the application on the device. Add Module Library to Project : Used to add libraries to the Library Manager of the POU pool, which normally is not available in the \"Application Composer dedicated\" view. Any added library containing modules, makes the modules available to be added in the module tree. " }, 
{ "title" : "Module Tree ", 
"url" : "ac_module_tree.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Module Tree ", 
"snippet" : "In addition to the device tree and POU tree the Application Composer offers the module tree. This tree serves to create or modify an application by use of the predefined modules. The Application Composer Commands allow to add submodules to the module tree or to modify or delete them. The tree struct...", 
"body" : "In addition to the device tree and POU tree the Application Composer offers the module tree. This tree serves to create or modify an application by use of the predefined modules. The Application Composer Commands allow to add submodules to the module tree or to modify or delete them. The tree structure can be collapsed or expanded. Example of a module tree Depending on the selected object, compatible modules can be added to the tree. This can be done by use of the commands in the \"Composer\" menu or by use of the context menu. The icons of the elements are defined in the module declaration. " }, 
{ "title" : "Elements of the module tree ", 
"url" : "ac_module_tree.html#UUID-e2887a12-08dd-106a-0027-83341681c6bc_e38a4aaee73c0a8640e01c263f8_id_a88610fbb413e565c0a8640e00f61f5a", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Module Tree \/ Elements of the module tree ", 
"snippet" : "(1): Toplevel modules which defines application and task settings (2): Submodules (3): Instance references which reference submodules. Instance references do not have their own parameters or I\/Os. (4): Extensions which can be created without the Application Composer and which allow to make adjustmen...", 
"body" : "(1): Toplevel modules which defines application and task settings (2): Submodules (3): Instance references which reference submodules. Instance references do not have their own parameters or I\/Os. (4): Extensions which can be created without the Application Composer and which allow to make adjustments to the machine (5): Slot (single or multi slots) which can be obligatory or optional " }, 
{ "title" : "Display of the tree structure ", 
"url" : "ac_module_tree.html#UUID-e2887a12-08dd-106a-0027-83341681c6bc_e38a4aaee73c0a8640e01c263f8_id_8a0710cab44f1a9bc0a8640e00ddf9a1", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Module Tree \/ Display of the tree structure ", 
"snippet" : "The child nodes, which are shown under an expanded module instance will be displayed according the following rules, whereby the order of all occupied and unoccupied slots always corresponds to the declaration order of the module declaration: In the case that the module instance at this location is o...", 
"body" : "The child nodes, which are shown under an expanded module instance will be displayed according the following rules, whereby the order of all occupied and unoccupied slots always corresponds to the declaration order of the module declaration: In the case that the module instance at this location is only referenced, it does not have any children. All unoccupied slots are displayed, except the optional slots which are hidden explicitly. For slots the role name and the type are displayed. Occupied slots with cardinality 1 are not displayed (the connected submodule instances are displayed instead). The connected submodule instance visually replaces the slot. Optional and obligatory submodules are displayed in the module tree at the position of the slots. The role name is displayed in brackets after the module instance name. Submodule instances of a multi slot are displayed below the respective slot. The role name is displayed, because it is defined in the parent node. The following properties of the slots are indicated with additional icons: Optional slots Obligatory slots Multi slots References to submodule instances If a module instance is deleted, all references to this module instance will be marked with an error icon. If the type of a module instance is changed, all references to this module with wrong type will be marked with an error icon. Depending on the position in the module tree the Cut \/ Copy \/ Paste commands from the context menu can be used. The elements of the module tree can be moved via Drag&Drop. Pressing the Ctrl key during a Drag&Drop operation will copy the element. The elements of the module tree can also be exported and imported in CODESYS . " }, 
{ "title" : "Module Dialog ", 
"url" : "ac_module_dialog.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Module Dialog ", 
"snippet" : "By use of the commands Add toplevel instance , Add submodule instance , Reference instance , and Update module , a non-modal dialog opens. Depending on the position in the module tree all compatible modules will be displayed. With a double click on the module or with the button Add module resp. Add ...", 
"body" : "By use of the commands Add toplevel instance , Add submodule instance , Reference instance , and Update module , a non-modal dialog opens. Depending on the position in the module tree all compatible modules will be displayed. With a double click on the module or with the button Add module resp. Add submodule instance the selected module will be copied to the module tree. The button Add module ( or Reference module ) is only enabled if a compatible module is selected and if the selected slot in the module tree is not full. Furthermore a valid name (with valid IEC identifier) must be entered. The name of the object can only be defined for new module instances. In the dialog of the Update module command, the name cannot be changed. Only show compatible instances : This option filters, when activated, the displayed instances, so that only the compatible instances are shown. If it is deactivated all instances are shown, where the compatible instances are highlighted in bold. Application : The toplevel module instance is generated under this application. Click to select an existing application. Dialog to add module instances The dialog is non-modal. It allows the selection of other objects in the tree without having to close the dialog. The elements listed in the dialog as well as the possible actions are adjusted automatically. The behavior of this dialog is identical to the Add Device dialog. " }, 
{ "title" : "Command: Generate ", 
"url" : "ac_generate.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Generate ", 
"snippet" : "Generate Symbol: This command (category \"Composer\") starts a build process which automatically generates the CODESYS application from the module tree and the settings of the Generator configuration . Messages and errors will be displayed in the message view. All objects created by the standard gener...", 
"body" : "Generate Symbol: This command (category \"Composer\") starts a build process which automatically generates the CODESYS application from the module tree and the settings of the Generator configuration . Messages and errors will be displayed in the message view. All objects created by the standard generator (except task objects and applications) will be stored in the subfolder of the application resp. POU pool named AC_Std and AC_FBs . If a folder with the same name already exists, a unique name will be created by adding a suffix _0 . Generated function blocks All objects created by the Generate command are marked with a blue overlay icon. If the user tries to delete, move or modify one of these objects a dialog will open which tells that this action may cause compile problems. If the user continues the color of the overlay icon changes to red (see function block AC_PRG_RMP (PRG) in the screenshot above). If you use the Application Composer together with CODESYS SVN : All Composer generated objects are marked with an Ignore on Commit for SVN. Additionally SVN is switched to the offline mode to avoid SVN locks while the Built command is executed. Creation of the communication infrastructure Definition: In the following description the application A1 sends to application A2 (or A2 receives from A1) if the following conditions are met: A module instance which is assigned to application A1 references a module instance which is assigned to application A2 or vice versa. An output of a module instance which is assigned to A1 is connected to a module instance which is assigned to A2 by use of a direct module I\/O connection. All objects mentioned below will be created in the folder AC_RMP for each application created by the generator. A communication task will be created. (Cycle time and priority according to the settings of the generator configuration). In this task the proxy instances will be called and the mirrored module proxy FB variables will be read resp. written. For each application which sends to the current application, a (send) GVL will be created and the network settings will be defined. (Protocol \"UDP\", cyclic transmission, checksum, cycle time according to the settings, communication task). The \"list identifier\" which must be an integer value between 1 and 2^15-1 will be determined by random at the beginning of the generation and increased by 1 after each send GVL. This value is at least 128 and within the valid range. If there are module references between the applications a variable of type RMPExchangeData will be created in the GVL. The name of the variable contains the name of the source- and the target application. If a module instance defines variables in its proxy definition to be mirrored ( MirrorVar ) and is referenced from an other module instance, for each of this MirrorVars a variable will be created in the (send) GVL of the referenced module instance. Its name contains the instance path of the module instance and the TargetID of the corresponding \"MirrorVar\" definition. For each application A2, to which the current application sends, a (receive) NVL will be created and connected to the corresponding send GVL of A2 and the communication task. A function block of type RMPService will be instantiated in the GVL AC_RMP and initialized in the declaration (with attribute init_on_onlchange ). Two arrays of type RMPConnection will be created which refer to the created variables of type RMPExchangeData in the GVLs and NVLs. A program AC_PRG_RMP will be created which calls the function block of type RMPService . This program will be added to the communication task. Additionally the value of the mirrored variables (\"MirrorVars\") will be set and read in the AC_PRG_RMP program. This means that the proxy \"MirrorVars\" will be assigned to the corresponding variables of the (receive) GVL. Then the Main method of the proxy instance is called and finally the corresponding variables of the (sender) GVL of the \"MirrorVars\" module. This happens according to the send direction of module instances to proxies. " }, 
{ "title" : "Creation of function block instances by the standard generator ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_65e9c9d2b9a5b65fc0a8640e0003897d", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Generate \/ Creation of function block instances by the standard generator ", 
"snippet" : "For each module instance a function block will be created (in the folder AC_FBs ). This function block derives from the module function block. The function block contains input variables Submodule instances Arrays of configurable size Buffer variables of direct I\/O connections Arrays of multislots a...", 
"body" : "For each module instance a function block will be created (in the folder AC_FBs ). This function block derives from the module function block. The function block contains input variables Submodule instances Arrays of configurable size Buffer variables of direct I\/O connections Arrays of multislots and instance references The name of the respective array variable is created by the prefix AC_ARRAY_ followed by the variable name of the respective pointer variable. For arrays with variable index size (VarArrays) the name can be overwritten by the parameter VarArray.InstName . The implementation part of the function block contains the command SUPER^(); which calls the implementation part of the module function block. Example The module instance ModuleInstanceA is of type ModuleA and related function block ModuleA_FB . This instance has got a submodule instance of type ModuleB . The module instance ModuleInstanceA is of type ModuleA and related function block ModuleA_FB . This instance has got a submodule instance of type ModuleB . FUNCTION_BLOCK AC_ModuleInstanceA EXTENDS ModuleA_FB\n\nVAR_INPUT\n Inst_Sub1 : AC_ModuleInstanceB ;\nEND_VAR The name of the function block is created from the module instance path and the prefix AC_ . The name of the variable of the submodule instance is created from a prefix followed by the name of the respective submodule instance. Each function block is instantiated once, the FB instance of toplevel module directly in the GVL - the rest in the according function blocks of the father instances. For each referenced module instance which is located in another application, exactly one function block instance of the proxy FB will be created in one GVL of a referring module instance. The name of the proxy instance is AC_PROXY_<InstanceName> where <InstanceName> is the name of the target instance in the other application. Unique addresses are assigned to all module instances. The proxy FB instances are assigned by the addresses of the module instances in the remote application. The method IBaseInstance.Main of the proxy instances is called cyclically in the communication task. " }, 
{ "title" : "Creation of the application and task calls ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_c88cdc4bba310f0dc0a8640e0094f683", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Generate \/ Creation of the application and task calls ", 
"snippet" : "If a module is assigned to an application which does not exists, this application will be created. Creation of non-existing standard task TASK_MODULE_HIGH TASK_MODULE_MEDIUM TASK_MODULE_LOW The priority and the cycle time of the tasks is set according to the generator settings. Furthermore module sp...", 
"body" : "If a module is assigned to an application which does not exists, this application will be created. Creation of non-existing standard task TASK_MODULE_HIGH TASK_MODULE_MEDIUM TASK_MODULE_LOW The priority and the cycle time of the tasks is set according to the generator settings. Furthermore module specific tasks with the given settings will be created. Creation of one global variable list per toplevel. In this GVL, module instances which are located under the toplevel module instances of the same application will be created. The global variable list has the name defined in the module, or if it does not have a defined name, it will get the name GVL_MODULE . The GVL is located below the selected application or in the global POU tree. Creation of one GVL with the name GVL_ MODULE_TREE for each application. This list contains variables to manage the module tree. The GVL will be created in the folder AC_Std . Creation of initialization code which is called automatically on download and online change: The tree structure will be created. Parameter values will be set. References and submodule instances will be assigned. Arrays with variable size will be filled. Instance references will be set. On download only the parameters will be set which are not set to their default value. On online change all parameters will be set. The POUs will be created in the folder AC_Std . For each defined entry point a PROGRAM POU (language ST) will be created which contains the calls of the toplevel modules. The call of this new POU will be added below the task. In case of the standard task the POU names are: MODULE_CALL_<TASKNAME>_START MODULE_CALL_<TASKNAME>_END The POUs will be created in the folder AC_Std . For toplevel modules in the POUs pool the task calls will be created in all applications. " }, 
{ "title" : "Creation of the I\/O assignment ", 
"url" : "ac_generate.html#UUID-7c1a2cc8-d4fb-d1d0-006f-5498e85d0a7f_b3e0858019e065dbc0a8640e019b49d5_id_bf24656dba310f0fc0a8640e01fdf5a6", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Generate \/ Creation of the I\/O assignment ", 
"snippet" : "Depending on the type of the I\/O assignment the following actions will be performed: [I\/O channel]: In the corresponding device channel the instance name of I\/Os of the module instance will be added. [ST expression]: The assignments of the expressions to the inputs or of the outputs to the expressio...", 
"body" : "Depending on the type of the I\/O assignment the following actions will be performed: [I\/O channel]: In the corresponding device channel the instance name of I\/Os of the module instance will be added. [ST expression]: The assignments of the expressions to the inputs or of the outputs to the expressions will for all module instances below the same toplevel instance. If there are according assignments, for each toplevel instance a function named AC_Io_SetInputs_<instance name> or AC_Io_SetOutputs_<instance name> will be created. The task which defines inputs and outputs will be identified by the flag UPDATE-IOS in the module description. This task will be called \"I\/O task\" in the following description. The function for the inputs will be called in the I\/O task before the task method of the module instance is called. (If the I\/O task is a standard task, before the start method.) The function for the outputs will be called in the I\/O task after the task method of the module instance. (If the I\/O task is a standard task, after the end method.) [Direct connection to module I\/O, local]: A buffer variable of compatible type will be created in the function block of the instance of the input. The name of the buffer variable begins with the prefix AC_Io_Buffer_ . The buffer variables will be initialized to the current values of the connected outputs during the initialization of the application. The generator handles the input- and output assignments like a ST assignment to this buffer variable (see [ST expression]. [Direct connections to module I\/O, remote]: For each output which is connected to an input of a module instance from another application, a buffer variable with compatible type will be created in the corresponding send network GVL. The name of the buffer variable begins with prefix AC_RemoteIo_Buffer_ and will be built from the instance path and the variable path of the output. The buffer variables will be initialized with the initialization expression from the output variable, if it exists. If the value of this initialization expression is not contained in the precompile information (because the expression uses example: variables, functions and constants), an error is created. The generator handles the output assignment like an assignment to this buffer variable. The input assignment in the other application is handled like an assignment from the corresponding variable in the receiver NVL (see [ST expression]). Note: The synchronization between the task, in which the network variable shall be updated and the I\/O task of the module is not realized yet. Therefore it may be possible that values have been written incompletely while the I\/O task reads it. " }, 
{ "title" : "Command: Generator Configuration ", 
"url" : "ac_generator_configuration.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Generator Configuration ", 
"snippet" : "Generator Configuration This command (category \"Composer\") opens a dialog with all available generators. In this dialog, each single generator can be enabled or disabled. A click on the \"Tools\" icon opens a detailed dialog with specific settings on the currently selected and enabled generator....", 
"body" : "Generator Configuration This command (category \"Composer\") opens a dialog with all available generators. In this dialog, each single generator can be enabled or disabled. A click on the \"Tools\" icon opens a detailed dialog with specific settings on the currently selected and enabled generator. " }, 
{ "title" : "Device generator ", 
"url" : "ac_generator_configuration.html#UUID-808f4cf5-ae70-df89-d868-14922e672101", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Generator Configuration \/ Device generator ", 
"snippet" : "This generator tries to generate the necessary devices and connects them to the module IOs, if possible. In the current release of the Application Composer plug in, no configuration dialog is available for the device generator....", 
"body" : "This generator tries to generate the necessary devices and connects them to the module IOs, if possible. In the current release of the Application Composer plug in, no configuration dialog is available for the device generator. " }, 
{ "title" : "SourceTemplate generator ", 
"url" : "ac_generator_configuration.html#UUID-dcd74dd8-c2bf-daf3-03d2-c4b54ecf55a8", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Generator Configuration \/ SourceTemplate generator ", 
"snippet" : "This generator copies existing function blocks from the POUs pool to the application. The copied function blocks are added in the AC_SourceTemplate folder. In this folder the additional function AC_SourceTemplateInit is also added. This function block is used to initialize the copied function blocks...", 
"body" : "This generator copies existing function blocks from the POUs pool to the application. The copied function blocks are added in the AC_SourceTemplate folder. In this folder the additional function AC_SourceTemplateInit is also added. This function block is used to initialize the copied function blocks. Created function blocks can be edited and are not overwritten by a new generator run. Unused function blocks are renamed and moved to the UnusedSourceTemplate subfolder. Then the extension _unused is added. Requirement: The standard generator must be activated. " }, 
{ "title" : "Standard generator ", 
"url" : "ac_generator_configuration.html#UUID-a3c9c7e9-e567-6ffc-3f6c-ae4016d57a70", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Generator Configuration \/ Standard generator ", 
"snippet" : "Default task settings High priority task Definition of Priority and Interval of the user-defined tasks The user-defined tasks can be set in the editor of the toplevel modules (see Deployment). Medium priority task Low priority task Communication settings Enable RMP communication : The elements requi...", 
"body" : "Default task settings High priority task Definition of Priority and Interval of the user-defined tasks The user-defined tasks can be set in the editor of the toplevel modules (see Deployment). Medium priority task Low priority task Communication settings Enable RMP communication : The elements required for the RMP communication will be created. Task priority Priority of the RMP task Task interval Task interval of the RMP task Compiler pragmas GVLs Definition of compiler pragmas These pragmas will be inserted before the generated GVLs or function blocks. Function Blocks Symbol Configuration Create symbol configuration : The symbol configuration object will be added to the application. " }, 
{ "title" : "Persistence generator ", 
"url" : "ac_generator_configuration.html#UUID-e4484f57-2155-dad9-990f-264462e75e1e", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Generator Configuration \/ Persistence generator ", 
"snippet" : "The persistence generator reads the persistence configuration from the module tree and creates a persistence configuration object below each application that uses persistence. For more information, see also: Persistence ManagerAn application uses the application composer persistence feature if a Per...", 
"body" : "The persistence generator reads the persistence configuration from the module tree and creates a persistence configuration object below each application that uses persistence. For more information, see also: Persistence ManagerAn application uses the application composer persistence feature if a Persistence Manager instance is mapped to that application. " }, 
{ "title" : "DataLog generator ", 
"url" : "ac_generator_configuration.html#UUID-0a4d1c9e-c363-489e-e742-4b6d5c1afaa4", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Generator Configuration \/ DataLog generator ", 
"snippet" : "The DataLog generator creates a DataLog configuration object from the module tree configuration. This object will be added to the application to which the instance of the DataLog Manager is mapped. In the current release of the CODESYS Application Composer , no configuration dialog is available for ...", 
"body" : "The DataLog generator creates a DataLog configuration object from the module tree configuration. This object will be added to the application to which the instance of the DataLog Manager is mapped. In the current release of the CODESYS Application Composer , no configuration dialog is available for the DataLog generator. " }, 
{ "title" : "Trend generator ", 
"url" : "ac_generator_configuration.html#UUID-b0155d06-1fc0-2914-55ee-2233ae0d22ee", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Generator Configuration \/ Trend generator ", 
"snippet" : "The trend generator reads the trend definitions from the module descriptions and creates a trend configuration with associated visualizations. These visualizations will be embedded in existing visualizations....", 
"body" : "The trend generator reads the trend definitions from the module descriptions and creates a trend configuration with associated visualizations. These visualizations will be embedded in existing visualizations. " }, 
{ "title" : "Alarm Generator ", 
"url" : "ac_generator_configuration.html#UUID-62c4fd14-9eaa-46b5-f370-4e36a88614fe", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Generator Configuration \/ Alarm Generator ", 
"snippet" : "The alarm generator reads the alarm definitions from the module descriptions and creates or expands the associated components of the alarm management. Additionally, a visualization is created from a template. In this visualization an alarm table is inserted. The visualization will be added to the ot...", 
"body" : "The alarm generator reads the alarm definitions from the module descriptions and creates or expands the associated components of the alarm management. Additionally, a visualization is created from a template. In this visualization an alarm table is inserted. The visualization will be added to the other visualization templates of the visualization generator as toplevel visualization . Template Template for the visualization screen. Note: To use a visualization as template it must satisfy the following conditions: A rectangle with the name Placeholder_AlarmTable The variables bAckVisible , bAckSel , bHistory , and bFreezeScrlPos of type BOOL Alarm Storage Template Objects of type AlarmStorageTemplate , which are found in the current project and referenced libraries The selected template will be used for all generated alarm configurations. Create Toplevel Tab : A toplevel tab will be created for the created alarm visualization. The defined name will be displayed in the toplevel tab. " }, 
{ "title" : "Device diagnosis generator ", 
"url" : "ac_generator_configuration.html#UUID-eacb5fd7-1329-2790-9483-fe45edbe632a", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Generator Configuration \/ Device diagnosis generator ", 
"snippet" : "This generator creates visualization screens for the device diagnosis. In the settings, the visualization templates and the layout of the screens can be defined. Device Diagnosis Generator settings In the dialog, the templates for Base Visualization, PLC Template, Bus Template, Stack Template, Paren...", 
"body" : "This generator creates visualization screens for the device diagnosis. In the settings, the visualization templates and the layout of the screens can be defined. Device Diagnosis Generator settings In the dialog, the templates for Base Visualization, PLC Template, Bus Template, Stack Template, Parent Device Template, and Child Device Template can be defined. The combo boxes list all available visualization templates which match the respective template types. In the lower part of the dialog, the minimal size of the visualization screen and the space between the device diagnosis visualization elements can be defined. " }, 
{ "title" : "CFC program generator ", 
"url" : "ac_generator_configuration.html#UUID-fdaff0f3-814e-b71a-bcac-a2994393c9ed", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Generator Configuration \/ CFC program generator ", 
"snippet" : "The CFC generator is used to create CFC programs. Always regenerate all CFC pins : : Application Composer always tries to generate all function block I\/Os for module instance FB calls....", 
"body" : "The CFC generator is used to create CFC programs. Always regenerate all CFC pins : : Application Composer always tries to generate all function block I\/Os for module instance FB calls. " }, 
{ "title" : "Visualization generator ", 
"url" : "ac_generator_configuration.html#UUID-a364420f-f798-9fe6-3c1a-b98bc7c07391", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Generator Configuration \/ Visualization generator ", 
"snippet" : "This generator creates visualization screens for the CODESYS Application Composer from visualizations which are available in the CODESYS project. Toplevel Name : Enter a symbolic name for the visualization template (\"toplevel template\"). Template : The selection list offers all available (in the pro...", 
"body" : "This generator creates visualization screens for the CODESYS Application Composer from visualizations which are available in the CODESYS project. Toplevel Name : Enter a symbolic name for the visualization template (\"toplevel template\"). Template : The selection list offers all available (in the project and the loaded libraries) and compatible visualizations. If you select Default , the default template from library AC_Module will be used. If a template configured here in the dialog, is later removed from the project or library, it remains available in this dialog. TargetVisu , WebVisu : Activate the respective option, if the page template should be used for this display variant. Width: Width of the generated visualization in pixels (default value: 640, minimal 100, maximal 10000) Height: Height of the generated visualization in pixels (default value: 480, minimal 100, maximal 10000) Minimal ToplevelTab width : Minimum width for the generated toplevel tabs in pixels. If 0 is entered here, the setting is not taken into account. Maximal ToplevelTab width : Maximum width for the generated toplevel tabs in pixels. If 0 is entered here, the setting is not taken into account. For more information about toplevel templates, see: Toplevel templatesMaximum number of clients: Maximal number of parallel running clients (default 8, minimal 1, maximal 128). Ignore generated visus if SVN is available : If the project is stored in Subversion this option should be activated. : CODESYS makes sure that the generated visualizations are ignored in SVN. Otherwise problems might occur. Recreate visus when regenerating : : With each code generation, all visualizations are also regenerated and the existing visualizations are overwritten. This option should be selected if it is not desired that the module user makes changes to the generated visualizations after generation. However, if changes to the visualizations are still necessary after generation, the option should be deactivated. Then CODESYS tries to keep the subsequent changes also with the regenerations. Use instance name as default for toplevel tabs : : Instead of the complete instance path, only the instance name is displayed in the top level tab. If there is an error in the configuration, it is displayed with an error provider icon, and the OK button is disabled. " }, 
{ "title" : "Command: Scan ", 
"url" : "ac_scan.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Scan ", 
"snippet" : "Scan Symbol: This command (category \"Composer\") scans the whole project for module declarations. Normally this command is not needed because CODESYS scans the system automatically whenever it is needed (example: after installing a new library)....", 
"body" : "Scan Symbol: This command (category \"Composer\") scans the whole project for module declarations. Normally this command is not needed because CODESYS scans the system automatically whenever it is needed (example: after installing a new library). " }, 
{ "title" : "Command: Check and Scan all Pool Objects ", 
"url" : "_ac_cmd_check_and_scan_all_pool_objects.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Check and Scan all Pool Objects ", 
"snippet" : "Check and Scan all Pool Objects Function : When the command is called, the IEC code of a library is first checked and then this is searched for module declarations. The test run corresponds to the command LCheck all Pool Objects . The search corresponds to the command Scan. Call : Composer menu Requ...", 
"body" : "Check and Scan all Pool Objects Function : When the command is called, the IEC code of a library is first checked and then this is searched for module declarations. The test run corresponds to the command LCheck all Pool Objects . The search corresponds to the command Scan. Call : Composer menu Requirement : The command is visible only when a library project is open. " }, 
{ "title" : "Command: Map I\/Os ", 
"url" : "ac_map_channels_for_ioconfig.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Map I\/Os ", 
"snippet" : "Map I\/Os Symbol: This command (category \"Composer\") opens a dialog to define the mapping between modules and I\/O configuration. Dialog: I\/O Mapping On the left side of the dialog all inputs and outputs of the modules are displayed in a tree structure according the module tree . On the right side the...", 
"body" : "Map I\/Os Symbol: This command (category \"Composer\") opens a dialog to define the mapping between modules and I\/O configuration. Dialog: I\/O Mapping On the left side of the dialog all inputs and outputs of the modules are displayed in a tree structure according the module tree . On the right side there is the structure of the device tree. The connections of the toplevel modules to the applications is drawn according to the settings of the toplevel modules. This connection cannot be changed in this dialog. Inputs are displayed with a green connection and a green arrow - outputs are displayed in red. Open inputs or outputs (with no connection) are displayed with a dotted line. In case that a ST expression is mapped to the input resp. output, the connection will be displayed with a \"ST\". Connections between modules and devices are only possible from input to input or output to output. Furthermore, both connection have to have a compatible data type. Connections between modules are only possible from input to outputs and vice versa. Connections between devices are not possible. To create a connection the open input or output must be selected. A selected pin is displayed with a blue background. The inputs and outputs are connected by drag and drop. A valid or invalid connection target is indicated with different mouse pointers. Existing connections will be deleted if the input or output is occupied. If a device or module is collapsed, the connection will be drawn in black because possibly the data direction cannot be determined. If it is collapsed further (for example, the superordinate device), then the connections will also be hidden. This is done to improve the overview because the line thickness can be reduced in the middle area. If a connection on the left or right side is selected, the according device will be expanded if it is collapsed. Arrows show the data direction. A collapsed device shows both green and red arrows if the device uses inputs and outputs. Are there only inputs or outputs, the data direction is also displayed. In online mode the values of the parameters are displayed on the left side. The values cannot be changed in this view. With a double click on a module or device the respective object opens in the editor. Connections can also be set across application boundaries! If a module instance is mapped to the POU pool the connection lines are grayed out. In this situation no IO mappings can be created, but existing mappings can be deleted. Print : This command allows to print the I\/O mappings, which are set, in an overview style. " }, 
{ "title" : "Command: Wildcard Selection ", 
"url" : "ac_wildcard_selection.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Wildcard Selection ", 
"snippet" : "Wildcard Selection This command (category \"Composer\") opens the dialog Wildcard assignment . The upper part of the dialog shows the currently configured wildcards and the assigned device types. In the lower part of the dialog the Device Repository is represented, offering installed devices for selec...", 
"body" : "Wildcard Selection This command (category \"Composer\") opens the dialog Wildcard assignment . The upper part of the dialog shows the currently configured wildcards and the assigned device types. In the lower part of the dialog the Device Repository is represented, offering installed devices for selection. You can edit the assignments within the dialog. For this purpose the dialog also appears during the device generation, when wildcards cannot get assigned to device types automatically and manual assignment is needed. The assignment of the wildcards to device types is stored within the project. However you also can use a XML file for saving the assignments externally and reload them from there. File and path of this file are shown at the top of the dialog. Dialog: Wildcard assignment New : This command allows to create a new (empty) wildcard assignment XML file. Define file name and storage directory. Save : This command saves the currently defined wildcard device assignment explicitly to a manually chosen file. Apart from this, the assignments will be saved automatically in the currently specified file, when closing the dialog using the OK button. Load : This command allows to load an existing wildcard assignment file (XML). In the highlighted tree view, the Device ID (Module name) column shows the IDs of the devices of the device generator which use wildcards. The name of the module instance which brings this device is shown in brackets. In case of statically inserted device generator device (defined by the module declaration Identification and not Wildcard \/ FlexibleWildcard ) a standard node Static is created which contains all statically inserted devices. Static devices cannot be modified. The Relations columns shows the relationship between parent and child devices of the device generator. A bold line indicates a fixed relation, where a dashed line serves as a suggestion for a relationship. The suggestion is based on the definition of ParentID in the Device section. Wildcards can also be marked as empty by simply selecting them and pressing the Del key. For example such an empty wildcard could serve to alter proposed parent-child relationships. Assigned wildcards are displayed with a green background color; unassigned wildcard with a red background color. Only show compatibilities to first generation of possible parent devices : If this option is activated, the device assortment of the device repository view is further restricted to those devices, which are compatible children of only the first device parents. This is defined by the module configuration . If not activated, also device parents of 2nd, 3rd, …, nth generation are treated as possible parents, enlarging the shown device assortment of the device repository view. Rules for property assignment If a device or an IO channel or FB instance is selected on the left side all properties for this device or IO channel or FB instance which are already assigned will be marked with a checked box on the right side Devices on the left side without assigned properties for its IO channels or FB instances will be displayed with a red background, the concerning IO channel or FB instance will be displayed with a red background, respectively. Devices for which all I\/O channels and FB instances are assigned are highlighted in green, as are the known I\/O channels and FB instances. Assignment also includes not assigning a \"demanding\" property. The latter can be achieved for a complete device by double-clicking on a device node for the entire device with all its I\/O channels and FB instances. Properties on the right can be added to the \"offering\" properties of the device, I\/O channel, or FB instance selected on the left by checking the box. Any number of properties or none can be assigned to a device, I\/O channel or FB instance. If a \"demanding\" I\/O property is assigned to a device node, then this property is assigned to all child I\/O channel nodes of this device node, but not to the FB instances. Similarly, if a device is assigned a \"demanding\" InstRef property, then only the child FB instances of that device are assigned that property. Several devices, I\/O channels, or FB instances can be selected at the same time, to each of which the selected properties are then assigned, as is possible. \"Demanding\" properties on the right side which are at least offered by one device on the left side will be displayed with a green background. \"Demanding\" properties without matching offering properties on the left side will be displayed with a red background. " }, 
{ "title" : "Assigning wildcards ", 
"url" : "ac_wildcard_selection.html#UUID-ceaa9faa-d44c-71c5-eba0-b0e56ec22feb_e2fe68ddbc7dc0a8640e014c3c31_id_342a92346a13602cc0a8640e00a6970a", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Wildcard Selection \/ Assigning wildcards ", 
"snippet" : "There are two ways to assign a wildcard: In the upper part of the dialog, in the line of the wildcard to be assigned, click into the field in column Selected Devices . Then, in the Device Repository tree in the lower part of the dialog, double click on the desired device. In the Device Repository tr...", 
"body" : "There are two ways to assign a wildcard: In the upper part of the dialog, in the line of the wildcard to be assigned, click into the field in column Selected Devices . Then, in the Device Repository tree in the lower part of the dialog, double click on the desired device. In the Device Repository tree in the lower part of the dialog, select the desired device. Then, in the upper part of the dialog, in the line of the wildcard to be assigned, double click on the field in column Selected Devices . " }, 
{ "title" : "Device property assignment ", 
"url" : "ac_wildcard_selection.html#UUID-ceaa9faa-d44c-71c5-eba0-b0e56ec22feb_e2fe68ddbc7dc0a8640e014c3c31_id_4703909473b5f037c0a8640e01022fbe", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Wildcard Selection \/ Device property assignment ", 
"snippet" : "The command Device Property Assignment opens the respective dialog, which serves to assign offering properties to devices. Dialog: Device property assignment On the left side of the dialog lists all generated devices used in the project. The child nodes of these devices display all inputs, outputs (...", 
"body" : "The command Device Property Assignment opens the respective dialog, which serves to assign offering properties to devices. Dialog: Device property assignment On the left side of the dialog lists all generated devices used in the project. The child nodes of these devices display all inputs, outputs (not bold) and created function blocks (bold) of the according device type. The right side display lists all \"demanding\" properties, which are defined in module declarations of the used modules as demanding IOs. The child nodes of these \"demandings\" correspond to all module IOs which require their parent nodes demanding. The property assignment dialog is used to assign the properties of the right side to the devices and their IO channels. This assignments will be saved in a extra file next to the devices’ device description, which gets reference to the extra file. The dialog opens automatically during code generation if not all \"demanding\" properties of the module IOs are satisfied with at least one assignment to a device which offers these properties. " }, 
{ "title" : "Command: Remove I\/O Mappings ", 
"url" : "ac_remove_connections_to_ios.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Remove I\/O Mappings ", 
"snippet" : "Remove I\/O Mappings This command (category \"Composer\") removes I\/O mappings. The following subcommands are provided. All generated : Removes the automatically generated mappings. Manually added mappings remain. All : Removes all mappings - automatically generated mappings and manually added mappings...", 
"body" : "Remove I\/O Mappings This command (category \"Composer\") removes I\/O mappings. The following subcommands are provided. All generated : Removes the automatically generated mappings. Manually added mappings remain. All : Removes all mappings - automatically generated mappings and manually added mappings. All generated of Module Instance : If a module instance is selected in the module tree, this command can be executed. The command removes automatically generated mappings of this instance. Manually added mappings remain. All of Module Instance : If a module instance is selected in the module tree, this command can be executed. The command removes all mapping of this instance - automatically generated mappings and manually added mappings. " }, 
{ "title" : "Command: Add Toplevel Module Instance ", 
"url" : "ac_add_toplevel_module_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Add Toplevel Module Instance ", 
"snippet" : "Add Toplevel Module Instance This command (category \"Composer\") opens the Module dialog which offers all top level modules which can be added to the module tree. There is no limitation to the number of toplevel modules which can be added to an application....", 
"body" : "Add Toplevel Module Instance This command (category \"Composer\") opens the Module dialog which offers all top level modules which can be added to the module tree. There is no limitation to the number of toplevel modules which can be added to an application. " }, 
{ "title" : "Command: Add Submodule Instance ", 
"url" : "ac_add_submodule_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Add Submodule Instance ", 
"snippet" : "Add Submodule Instance This command (category \"Composer\") opens the Module dialog which offers all submodules which can be added to the selected position in the module tree. Submodules which offer mandatory reference slots allow to fill all unambiguous reference slots automatically. In this situatio...", 
"body" : "Add Submodule Instance This command (category \"Composer\") opens the Module dialog which offers all submodules which can be added to the selected position in the module tree. Submodules which offer mandatory reference slots allow to fill all unambiguous reference slots automatically. In this situation a dialog asks the user if the modules shall be referenced automatically or not. " }, 
{ "title" : "Command: Reference Module Instance ", 
"url" : "ac_reference_module_instance.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Reference Module Instance ", 
"snippet" : "Reference Module Instance This command (category \"Composer\") opens the Module dialog which offers all modules which can be referenced at the selected position in the module tree....", 
"body" : "Reference Module Instance This command (category \"Composer\") opens the Module dialog which offers all modules which can be referenced at the selected position in the module tree. " }, 
{ "title" : "Command: Show Module References View ", 
"url" : "ac_module_references_editor.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Show Module References View ", 
"snippet" : "Show Module References View This command (category \"Composer\") opens the Module reference view and provides an overview of the usage of module instances in the project. The command is available in the context menu if a module instance is selected in the module tree. The view is updated automatically...", 
"body" : "Show Module References View This command (category \"Composer\") opens the Module reference view and provides an overview of the usage of module instances in the project. The command is available in the context menu if a module instance is selected in the module tree. The view is updated automatically if another module instance is selected or if the references of the currently selected instance change. " }, 
{ "title" : "View: Module references ", 
"url" : "ac_module_references_editor.html#UUID-7a9e7bcf-5b4a-4286-24df-e6cd7795a03a_c2a0935773056bc0a86463423a2ab0_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Show Module References View \/ View: Module references ", 
"snippet" : "App \/ Reference Source The references are sorted by application. Role of the reference at its target Role of the reference at its target...", 
"body" : "App \/ Reference Source The references are sorted by application. Role of the reference at its target Role of the reference at its target " }, 
{ "title" : "Command: Update Module ", 
"url" : "ac_update_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Update Module ", 
"snippet" : "Update Module This command (category \"Composer\") opens the Module dialog . The module tree provides all modules which are compatible to the selected module instance in the module tree. The command allows to update a module instance to a new module type. This can also be a new version of the same mod...", 
"body" : "Update Module This command (category \"Composer\") opens the Module dialog . The module tree provides all modules which are compatible to the selected module instance in the module tree. The command allows to update a module instance to a new module type. This can also be a new version of the same module. When updating, the configured data of the instance will be maintained as far as possible: Parameter values which exists in the new versions will be adopted even if the current value is incompatible with the new parameter type. If a parameter value is not set explicitly in the instance, then the default value of the new module is used. I\/O mappings which exists in the new version and which have the same direction (input resp. output) as the assignment in the instance will be adopted. The assignment does not have to be of the same type as the new I\/O to be adopted. Task assignments which exists in both versions will be adopted. Subinstances or references of slots which have the same slot ID in the new module will be maintained with all subinstances and references. This applies even if the type of the subinstances or references does not match the new slot, or if the cardinality of the new slot does not allow all subinstances or references. Subinstances or references of slots which do not exist in the new module are inserted below a new slot named \"Orphaned Instances\" or \"Orphaned References\". These slots are identified by special identifiers which cannot occur in normal slots. If a slot with orphaned elements already exists, this slot will be used. Subinstances or references of slots which exist in the new module but now expect references (in case of subinstances) or subinstances (in case of references) will be handled as subinstances resp. references which slot is not available in the new module. Toplevel informations which exist in the instance will be deleted if there is an update to a module which is not toplevel. If no toplevel informations exists in the instance it will be created if the module is updated to a toplevel module. Instance data defined by extensions: The respective extensions determine which data will be kept and which will be deleted. It should adhere to the principle of obtaining as much data as possible. If the order of the slots in the new module has changed, then the order of the slots below the instance will also be adjusted accordingly. If the update would delete data (for example, parameter values, I\/O assignments, non-empty slots, or extended instance data), then a message will be displayed describing which objects will be deleted and allowing the user to cancel the update. The update of an instance can be undone with one single undo step in the module tree. " }, 
{ "title" : "Command: Update All Instances ", 
"url" : "ac_update_all_instances.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Update All Instances ", 
"snippet" : "Update All Instances This command (category \"Composer\") allows to update all module instances to new versions of the modules with one command. This command is not available in the context menu. The behavior of the command is according to the description of the Update module command, however an updat...", 
"body" : "Update All Instances This command (category \"Composer\") allows to update all module instances to new versions of the modules with one command. This command is not available in the context menu. The behavior of the command is according to the description of the Update module command, however an update to another module is not possible. " }, 
{ "title" : "Command: Hide Empty Optional Slots: All\/Selected Only ", 
"url" : "ac_hide_empty_optional_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Hide Empty Optional Slots: All\/Selected Only ", 
"snippet" : "Hide Empty Optional Slots: All\/Selected Only With these commands (category \"Composer\") you can hide the empty optional slots in the module tree. Depending on the current focus this refers to all submodules or just to the currently selected submodule. Mandatory slots cannot be hidden. Example for emp...", 
"body" : "Hide Empty Optional Slots: All\/Selected Only With these commands (category \"Composer\") you can hide the empty optional slots in the module tree. Depending on the current focus this refers to all submodules or just to the currently selected submodule. Mandatory slots cannot be hidden. Example for empty optional slots To display hidden slots please use the Show hidden slots – All\/Selected only command. " }, 
{ "title" : "Command: Show Hidden Slots: All\/Selected Only ", 
"url" : "ac_show_hidden_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Show Hidden Slots: All\/Selected Only ", 
"snippet" : "Show Hidden Slots: All\/Selected Only With these commands (category \"Composer\") in the module tree you can make visible again any slots, which had been hidden before. Depending on the current focus, this refers to all submodules or just to the currently selected submodule. For hiding slots see the Hi...", 
"body" : "Show Hidden Slots: All\/Selected Only With these commands (category \"Composer\") in the module tree you can make visible again any slots, which had been hidden before. Depending on the current focus, this refers to all submodules or just to the currently selected submodule. For hiding slots see the Hide Empty Optional Slots – All\/Selected Only command. " }, 
{ "title" : "Command: Go to Target ", 
"url" : "ac_go_to_target.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Go to Target ", 
"snippet" : "Go to Target This command (category \"Composer\") is only available if a module reference is selected in the module tree . If this command is executed the target of the reference will be selected in the module tree....", 
"body" : "Go to Target This command (category \"Composer\") is only available if a module reference is selected in the module tree . If this command is executed the target of the reference will be selected in the module tree. " }, 
{ "title" : "Command: Create Extension Module ", 
"url" : "_ac_cmd_create_extension_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Create Extension Module ", 
"snippet" : "Create Extension Module Symbol: The command creates an extension module for a submodule slot. It is only available if an empty module slot or a submodule is selected in the module tree. The command opens a dialog, where you define, whether the extension is to be created as a new module (\"No Variatio...", 
"body" : "Create Extension Module Symbol: The command creates an extension module for a submodule slot. It is only available if an empty module slot or a submodule is selected in the module tree. The command opens a dialog, where you define, whether the extension is to be created as a new module (\"No Variation\") or as a variation of an existing module or a module instance. For this purpose all modules suitable at the slot are offered in a drop-down list. There are two options: Derive Variation The extension module derives from the module or module instance selected in Variation of . The chosen module gets imported via IMPORTS to the extension module and the function block of the new module derives from the module template function block. Copy source for Variation A new extension module is created by copying the complete module declaration including the function block and the related visualizations from the module selected in Variation of (incl. source code). This is possible only if the module selected in Variation of is available in source code and not only as module of a compiled library. Extension modules serve to add any user specific modification or extension to the existing and predefined modules or module instances. After Closing the dialog with OK a new folder will be created in the POUs pool with the name of the extension module. In this folder the following objects will be created (where <name> is the name of the extension module): Standard case: A function block with the name <name> , extending the class \"Modules\" and implementing the required interface of the slot´s type. In this function block all methods and properties will be created, which exist in an implemented interface but which are not implemented in any base class. Variation case: Like in the standard case, a corresponding function block will be created. This function block derives from the chosen module template function block ( Derive Variation ) or is a copy of it ( Copy source for Variation ). An image pool and a text list (name IP_<name> or TL_<name> ). The image pool contains two icons with identifier Icon_16 and Icon_32 . The text list contains the entry Desc , which is filled with a <name> . There are no languages in the text list, only the column Standard . An empty visualization page Visu_M_<name> , which implements the required interface. If Copy variation from source is selected, the visualizations of the source module are copied instead. An extension module will be added to the module tree, which has neither parameters nor I\/Os. For the meta data the created images, texts and visualization elements will be used. The category is \"Extension\". If it is a \"derived\" variation the module template declaration is additionally imported via IMPORTS . If it is a \"copied\" variation the declaration of the module template is copied and adapted in a way that it uses the corresponding text lists and image pools of the extension module. " }, 
{ "title" : "Command: Create Missing Text List Entries ", 
"url" : "ac_create_missing_textlist_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Create Missing Text List Entries ", 
"snippet" : "Create Missing Text List Entries This command (category \"Composer\") creates automatically all text lists and text list entries which are references by a module declaration and which do not exist. The command is only available if a module declaration editor is opened with the focus on it and the obje...", 
"body" : "Create Missing Text List Entries This command (category \"Composer\") creates automatically all text lists and text list entries which are references by a module declaration and which do not exist. The command is only available if a module declaration editor is opened with the focus on it and the object exists in the primary project. The function only works if there is no syntax error. Text lists will be created under the same father object as the object in the editor. With new created entries only the \"default\" text will be filled (with the ID). " }, 
{ "title" : "Command: Generate Missing Entries in Image Pools ", 
"url" : "ac_create_missing_image_pool_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Generate Missing Entries in Image Pools ", 
"snippet" : "Generate Missing Entries in Image Pools The command generates an image pool of entries that are defined in a module description but do not yet exist in an image pool of the project. If the image pool does not exist yet, then the image pool is generated in the POUs view first. By default, the command...", 
"body" : "Generate Missing Entries in Image Pools The command generates an image pool of entries that are defined in a module description but do not yet exist in an image pool of the project. If the image pool does not exist yet, then the image pool is generated in the POUs view first. By default, the command is not available in the Composer menu. You use the Tools → Customize dialog to add it from the Composer command category to the Composer menu. The command is then visible in the Composer menu when a module is open and focused in the editor. " }, 
{ "title" : "Command: Move Up ", 
"url" : "ac_move_up.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Move Up ", 
"snippet" : "Move Up This command (category \"Composer\") can be used to change the position of modules in the module tree . This command is only available for multislots elements (module instances and references) and if the selected element is not the first element of the multislot....", 
"body" : "Move Up This command (category \"Composer\") can be used to change the position of modules in the module tree . This command is only available for multislots elements (module instances and references) and if the selected element is not the first element of the multislot. " }, 
{ "title" : "Command: Move Down ", 
"url" : "ac_move_down.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Move Down ", 
"snippet" : "Move Down This command (category \"Composer\") can be used to change the position of modules in the module tree . This command is only available for multislots elements (module instances and references) and if the selected element is not the last element of the multislot....", 
"body" : "Move Down This command (category \"Composer\") can be used to change the position of modules in the module tree . This command is only available for multislots elements (module instances and references) and if the selected element is not the last element of the multislot. " }, 
{ "title" : "Command: Check for unknown Entries ", 
"url" : "ac_check_for_unknown_entries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Check for unknown Entries ", 
"snippet" : "Check for unknown Entries This command (category \"Composer\") checks the module declarations for unknown section definitions. The subcommand All , which is always available, checks all module declarations of the project. If a module declaration is opened in the editor the additional subcommand In cur...", 
"body" : "Check for unknown Entries This command (category \"Composer\") checks the module declarations for unknown section definitions. The subcommand All , which is always available, checks all module declarations of the project. If a module declaration is opened in the editor the additional subcommand In current Editor checks the currently opened module declaration for unknown section definitions. " }, 
{ "title" : "Command: Generate, Compile and Login ", 
"url" : "ac_generate_compile_login.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Generate, Compile and Login ", 
"snippet" : "Generate, Compile and Login Symbol: This command (category \"Composer\") executes several commands with one mouse click. First the code is created and compiled. If possible the application is logged in to the controller and started....", 
"body" : "Generate, Compile and Login Symbol: This command (category \"Composer\") executes several commands with one mouse click. First the code is created and compiled. If possible the application is logged in to the controller and started. " }, 
{ "title" : "Command: Add Module Library to Project ", 
"url" : "ac_add_libraries_to_pou.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Add Module Library to Project ", 
"snippet" : "Add Module Library to Project Symbol: This command (category \"Composer\") opens a dialog with module containing libraries. With the OK button the selected libraries will be added to the Library Manager of the POU pool. If the standard Composer library AC_ModlueBase is missing, it is added also automa...", 
"body" : "Add Module Library to Project Symbol: This command (category \"Composer\") opens a dialog with module containing libraries. With the OK button the selected libraries will be added to the Library Manager of the POU pool. If the standard Composer library AC_ModlueBase is missing, it is added also automatically. Dialog to add Application Composer libraries The Dialog provides the button Open POU Library Manager which allows to open the Library Manager of the POUs pool also in Composer Dedicated view. " }, 
{ "title" : "Command: Active Breakpoints to Next Step ", 
"url" : "ac_active_breakpoints_to_next_step.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Active Breakpoints to Next Step ", 
"snippet" : "Active Breakpoints to Next Step This command (category \"Composer\") is only available in online mode and if the sequence has stopped on a breakpoint. It removes the currently active breakpoints and adds a new one to the following steps....", 
"body" : "Active Breakpoints to Next Step This command (category \"Composer\") is only available in online mode and if the sequence has stopped on a breakpoint. It removes the currently active breakpoints and adds a new one to the following steps. " }, 
{ "title" : "Command: Center View to Breakpoints ", 
"url" : "ac_center_view_to_breakpoints.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Center View to Breakpoints ", 
"snippet" : "Center View to Breakpoints This command (category \"Composer\") is only available in online mode and if the sequence has stopped on a breakpoint. It centers the view of the Sequence Editor to the currently active breakpoints....", 
"body" : "Center View to Breakpoints This command (category \"Composer\") is only available in online mode and if the sequence has stopped on a breakpoint. It centers the view of the Sequence Editor to the currently active breakpoints. " }, 
{ "title" : "Command: Creating Macro Modules ", 
"url" : "ac_create_macro_module.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Creating Macro Modules ", 
"snippet" : "Creating Macro Modules Symbol: This command (in the \"Composer\" category) opens a dialog for generating macro modules. To use this command, you need a valid license for creating module declarations . The command is available if you have selected a subtree in the module tree. You can use this command ...", 
"body" : "Creating Macro Modules Symbol: This command (in the \"Composer\" category) opens a dialog for generating macro modules. To use this command, you need a valid license for creating module declarations . The command is available if you have selected a subtree in the module tree. You can use this command to generate a macro module from the modules of the subtree. In this way you can define which slots, I\/Os, and parameters of the submodule are available in the new macro module. Meta Data Name This is the unique name for the macro module. Macro Description The description is created as text lists. Macro Category The category is used to subdivide the modules in the insertion dialog box for modules. Slots \/ IOs \/ Parameters Macro Module Subtree Tree view of all objects of the subtree The structure also shows all slots, I\/Os, and parameters of the respective submodule instance as child elements (bold font). Macro Module Slots This displays all slots, I\/Os, and parameters that the macro module type should include. These elements come straight from the tree view on the left. Macro Module IOs Macro-Module Parameters Add to macro This is active if you select a slot, I\/O, or parameter in the tree view on the left. You add the elements to the macro module by clicking this button. Remove from macro This is active if you select slots, I\/Os, or parameters from the tree view on the right. You remove the elements from the macro module by clicking this button. When you close the dialog by clicking OK , CODESYS Application Composer generates a module declaration, a text list, and an image pool for this macro module. The objects are stored in a folder with the macro name. You can now edit the generated objects with no restrictions and independent of generation. In this way, for example, you can exchange the macro icon in the image pool. " }, 
{ "title" : "Command: Sign all Modules ", 
"url" : "ac_sign_all_modules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Sign all Modules ", 
"snippet" : "Sign all Modules This command (category \"Composer\") allows the (renewed) sign of all modules of the POU pool. This command can be used to re-sign all modules in the POUs pool. Modules developed with a valid license are automatically signed. This command is intended for taking over existing unsigned ...", 
"body" : "Sign all Modules This command (category \"Composer\") allows the (renewed) sign of all modules of the POU pool. This command can be used to re-sign all modules in the POUs pool. Modules developed with a valid license are automatically signed. This command is intended for taking over existing unsigned modules of the Application Composer previous versions. " }, 
{ "title" : "Command: Goto Module FB ", 
"url" : "ac_goto_modul_fb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Goto Module FB ", 
"snippet" : "Goto Module FB The command (category \"Composer\") can be used to open the module’s function block or its methods in the editor. You have to select a module in the module tree to make this command available. In offline mode the declaration of the function block type or the function block method will b...", 
"body" : "Goto Module FB The command (category \"Composer\") can be used to open the module’s function block or its methods in the editor. You have to select a module in the module tree to make this command available. In offline mode the declaration of the function block type or the function block method will be opened in the editor. In online mode the function block instance or method of the module instance will be opened in the editor. " }, 
{ "title" : "Command: Differing Parameter Values ", 
"url" : "ac_differing_parameter_values.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Differing Parameter Values ", 
"snippet" : "Differing Parameter Values Use this command in online mode to check if any parameter values of module instances used in the module tree, have been modified in the module function block. In this case you will get a list of the modified parameters and of the concerned module instances in the Messages ...", 
"body" : "Differing Parameter Values Use this command in online mode to check if any parameter values of module instances used in the module tree, have been modified in the module function block. In this case you will get a list of the modified parameters and of the concerned module instances in the Messages view. A double-click on a message will open the parameter editor for the concerned module instance. There all parameters with different values in online mode and in the offline mode of the application, will be indicated by red-framed cells in the columns Value and Online value . " }, 
{ "title" : "Command: Reset Text of Top-Level Tabs ", 
"url" : "ac_reset_text_of_toplevel_tabs.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Reset Text of Top-Level Tabs ", 
"snippet" : "Reset Text of Top-Level Tabs Function : This command resets the texts to the default settings for the toplevel tabs that were defined in the module editors in the HMI tab. Clicking Composer → Reset text of toplevel tabs → All resets the texts of all toplevel tabs. Clicking Composer → Reset text of t...", 
"body" : "Reset Text of Top-Level Tabs Function : This command resets the texts to the default settings for the toplevel tabs that were defined in the module editors in the HMI tab. Clicking Composer → Reset text of toplevel tabs → All resets the texts of all toplevel tabs. Clicking Composer → Reset text of toplevel tabs → Selected only resets only the text of the selected module (in the Modules view). Click Composer → Create to update the application. Call : Composer menu Requirement : Modules with special configured text for the toplevel tabs are present in the Modules view. Example for a module The following steps describe how to set and reset the text for a toplevel tab. You project includes the Building module. Double-click the Building module in the Modules view. The module editor (module configurator) opens. Activate the option Create toplevel tab . Then an input field appears with the preset toplevel text Building . Specify the text City hall . Click Composer → Create . The module visualizations and the Toplevel visualization are created and stored in the Devices view. Double-click the Toplevel visualization in the Devices view. → Save the project. Double-click the Building module in the Modules view. The commands of the Composer menu are available. Select the Building module. Click Composer → Reset text of toplevel tabs → Selected only . The text is reset to the default setting Building in the module editor in the input field next to the Create toplevel tab option. Click Composer → Create . The module visualizations and the Toplevel visualization are updated and stored in the Devices view. Open the Toplevel visualization in the Devices view. → Example for a submodule The following steps describe how to set and reset the text for toplevel tabs within a module structure of modules and submodules. Your project includes the Building module and the Bathroom submodule. Double-click the Building module in the Modules view. The module editor (module configurator) opens. Activate the option Create toplevel tab . Then an input field appears with the preset toplevel text Building . Specify the text City hall . Double-click the Bathroom module in the Modules view. The module editor (module configurator) opens. Activate the option Create toplevel tab . Then an input field appears with the preset toplevel text Building.Bathroom . Specify the text WC . Click Composer → Create . The module visualizations and the Toplevel visualization are created and stored in the Devices view. Double-click the Toplevel visualization in the Devices view. → Save the project. Double-click the Building module in the Modules view. The commands of the Composer menu are available. Select the Building module. Click Composer → Reset text of toplevel tabs → All . Click Composer → Create . The module visualizations and the Toplevel visualization are updated and stored in the Devices view. Open the Toplevel visualization in the Devices view. → " }, 
{ "title" : "Command: Create Module from FB ", 
"url" : "ac_create_module_from_fb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Create Module from FB ", 
"snippet" : "Create Module from FB This command (Category \"Composer\") creates a module description from a function block. The following objects are created: Module description with the name <NameOfTheFB> Image pool with the name IP_<NameOfTheFB> Text list with the name TL_<NameOfTheFB> Interface with the name TL...", 
"body" : "Create Module from FB This command (Category \"Composer\") creates a module description from a function block. The following objects are created: Module description with the name <NameOfTheFB> Image pool with the name IP_<NameOfTheFB> Text list with the name TL_<NameOfTheFB> Interface with the name TL_<NameOfTheFB> I<NameOfTheFB>. This interface extends AC.IModule . The module description is created according to the following rules: All variables var_input constant are defined as module parameter. There the attributes parameterCategory , parameterMinValue , and parameterMaxValuehere can be used to set categories and minimal \/ maximal values. All numeric variables var_output are defined as module outputs. All numeric variables var_input are defined as module inputs, unless they are marked as part of a multi slot. All variables var_input of type Interface become single slots, if they are marked with the ac_single_slot attribute. To create a multi slot a pair of var_input is required, consisting of a Pointer to Interface and an integer variable. Both must be marked with the 'ac_multi_slot' := '<ID>' attribute, where the <ID> of the two must match. " }, 
{ "title" : "Command: Create Persistence Manager ", 
"url" : "ac_create_persistence_manager.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Create Persistence Manager ", 
"snippet" : "Create Persistence Manager This command (category \"Composer\") inserts a complete Persistence Manager with default settings into the module tree. Below the Persistence Manager a module Persistence Channel and below it a module Data Storage is inserted. The created structure can then be changed and ex...", 
"body" : "Create Persistence Manager This command (category \"Composer\") inserts a complete Persistence Manager with default settings into the module tree. Below the Persistence Manager a module Persistence Channel and below it a module Data Storage is inserted. The created structure can then be changed and extended as desired. This is done in the parameters of the module persistence channel and the module data storage . In the toplevel module instance of the Persistence Manager Module at least the target application must be set. Before the application is loaded on the controller, the command Generate must also be executed. The command additionally adds all required libraries to the library manager and activates the associated generators. " }, 
{ "title" : "Command: Create DataLog Manager ", 
"url" : "ac_create_datalog_manager.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Create DataLog Manager ", 
"snippet" : "Create DataLog Manager This command (category \"Composer\") inserts a complete DataLog Manager with default settings into the module tree. Below the DataLog Manager a module DataLog Channel and below it a module DataLog Storage is inserted. The created structure can then be changed and extended as des...", 
"body" : "Create DataLog Manager This command (category \"Composer\") inserts a complete DataLog Manager with default settings into the module tree. Below the DataLog Manager a module DataLog Channel and below it a module DataLog Storage is inserted. The created structure can then be changed and extended as desired. This is done in the parameters of the Module ‘DataLog Channel’ and the Module ‘DataLog Storage CSV’ . In the toplevel module instance of the DataLog Manager Module at least the target application must be set. Before the application is loaded on the controller, the command Generate must also be executed. The command additionally adds all required libraries to the library manager and activates the associated generators. " }, 
{ "title" : "Command: Get License Information ", 
"url" : "ac_cmd_get_license_information.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Commands \/ Command: Get License Information ", 
"snippet" : "Get License Information With this command (\"Composer\" category), CODESYS gets the number of module instances used in the module tree. The maximum allowed number of instances of the current license is also queried. The result is displayed in the Messages view. For more information, see ???...", 
"body" : "Get License Information With this command (\"Composer\" category), CODESYS gets the number of module instances used in the module tree. The maximum allowed number of instances of the current license is also queried. The result is displayed in the Messages view. For more information, see ???" }, 
{ "title" : "Tutorial ", 
"url" : "f_application_composer_example.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Tutorial ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Getting Started Examples ", 
"url" : "f_application_composer_first_steps.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Tutorial \/ Getting Started Examples ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Application Composer Example ", 
"url" : "ac_example_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Tutorial \/ Getting Started Examples \/ Application Composer Example ", 
"snippet" : "Based on a small project this example describes how to create modules for the Application Composer. Some URLs in this tutorial link to help pages which are part of the Application Composer. If you do not have installed this package these links will not work. The example module depict a room with a l...", 
"body" : "Based on a small project this example describes how to create modules for the Application Composer. Some URLs in this tutorial link to help pages which are part of the Application Composer. If you do not have installed this package these links will not work. The example module depict a room with a light and a switch. The switch can be used as tapper or dimmer. Pushing it longer will dim the light and pushing it shortly will toggle it. The speed for the dimmer function as well as the maximum value of the light can be defined by the user. When the switch is pushed longer than a specified time the dim function is activated. The output of the light is the brightness. There is a second light, a simpler one, which can only be switched on and off by a second switch. Sample project Step 0: Preliminaries " }, 
{ "title" : "Step 0: Preliminaries ", 
"url" : "ac_example_s0_preliminaries.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Tutorial \/ Getting Started Examples \/ Step 0: Preliminaries ", 
"snippet" : "First of all a new project has to be created. Therefore choose New Project from the File menu and save the new project. A Library Manager has to be added in the POUs view. Then the library AC_ModuleBase , which is part of the CODESYS Application Composer package, can be added to the library manager....", 
"body" : "First of all a new project has to be created. Therefore choose New Project from the File menu and save the new project. A Library Manager has to be added in the POUs view. Then the library AC_ModuleBase , which is part of the CODESYS Application Composer package, can be added to the library manager. Add library \"AC_ModulBase\" Step 1: Create Toplevel Module \"Room\" " }, 
{ "title" : "Step 1: Create Toplevel Module \"Room\" ", 
"url" : "ac_example_s1_create_toplevel_room.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Tutorial \/ Getting Started Examples \/ Step 1: Create Toplevel Module \"Room\" ", 
"snippet" : "Add a module declaration and a function block to the POUs pool. The function block is used for the implementation (function program) of the module. In this example, the module and function block are given the name Room . Moreover the function block has to extend the base type AC.Module , which is pa...", 
"body" : "Add a module declaration and a function block to the POUs pool. The function block is used for the implementation (function program) of the module. In this example, the module and function block are given the name Room . Moreover the function block has to extend the base type AC.Module , which is part of the AC_ModuleBase library and provides a broad range of properties and functionalities. Since we don’t want to change the latter, all properties and functions, which are created with the function block, can be deleted. Add function block and module The declaration starts with the keyword MODULE followed by the module name and IMPLEMENTED_BY and the name of the function block implementing the module, which is, for the case at hand, the function block Room. In this specific case, this is the Room function block. In most cases, the section MetaData is declared now. For detailed information about all parameters of all sections see the help pages in Module Declaration . Because Room is the toplevel module in our example, the next section declared is the Toplevel section. The latter allows to define a name for the global variable list ( GVL_name ) including the instances of the toplevel function blocks after generation. After that, at least one more task must be defined in the toplevel section. This is Standard_Task in this example, which is defined as a MEDIUM task and contains the flags CREATE_IF_MISSING and UPDATE_IOS . Declaration of module Room All Icons and Strings, which are used for the description- and icon-placeholders of the module (parameters Desc , Icon_16 and Icon_32 ) have to be referenced from text lists and image pools. Having said this, an appropriate text list TL and image pool IP , which include all the referenced icons and texts, must be created and added to the POUs pool. Creation of text list and image pool Step 2: Create Submodule \"Switch\" " }, 
{ "title" : "Step 2: Create Submodule \"Switch\" ", 
"url" : "ac_example_s2_create_sublevel_switch.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Tutorial \/ Getting Started Examples \/ Step 2: Create Submodule \"Switch\" ", 
"snippet" : "The next step is to declare a module for the switch of the room. Again, a module declaration and a function block must be created. Here, both are called Switch , where the declaration has to be implemented by the function block. The module declaration of Switch does not need a toplevel section, beca...", 
"body" : "The next step is to declare a module for the switch of the room. Again, a module declaration and a function block must be created. Here, both are called Switch , where the declaration has to be implemented by the function block. The module declaration of Switch does not need a toplevel section, because it will be added below the module Light (described later) in no toplevel position. As it is mandatory for all module implementing function blocks, the function block Switch has to extend AC.Module , too. For the case at hand, the function block also implements an interface ISwitch , which has to be created. This interface itself must implement the interface IModule , which is provided by the library AC_ModuleBase . However, the interface ISwitch remains \"empty\" – no properties or functions are declared. Further the switch needs an input signal (probably from an external source \/ physical switch) to indicate when it is tapped. This signal is declared in the IO section using the variable xIn of the function block which implements this module. Furthermore, a reference time is needed to distinguish the two functions of the switch: Pressing the switch for the time duration tTimer starts the dimming function - a shorter press only switches the light on or off. This variable tTimer (also being part of the module implementing function block) will be declared as a parameter of the module (section Parameters ), which eventually can be easily edited when using the module. Declaration of submodule Switch The referenced variables xIn and tTimer are both defined as Inputs of the function block Switch , where the parameter tTimer gets an initial default value of 500ms. So, when the user pushes the Switch longer than 500ms, the light will be dimmed. Declaration in the Switch function block Also the text lists and the image pool have to be extended to include the needed description texts of the input and the parameter. Entries in text list and image pool Step 3: Create Submodule \"Switch Simple\" " }, 
{ "title" : "Step 3: Create Submodule \"Switch Simple\" ", 
"url" : "ac_example_s3_create_sublevel_switchsimple.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Tutorial \/ Getting Started Examples \/ Step 3: Create Submodule \"Switch Simple\" ", 
"snippet" : "The second switch module, which we want to declare, is a simplified one with only two states: on and off. Therefore a module declaration and a function block have to be created, which are adapted from the \"Dim-Switch\" above. A new interface of type ISwitchSimple is used for the function block. Anoth...", 
"body" : "The second switch module, which we want to declare, is a simplified one with only two states: on and off. Therefore a module declaration and a function block have to be created, which are adapted from the \"Dim-Switch\" above. A new interface of type ISwitchSimple is used for the function block. Another difference is, that the variable xIn should be declared as BOOL variable and no parameter tTimer is needed at all. Step 4: Create Submodule \"Light\" " }, 
{ "title" : "Step 4: Create Submodule \"Light\" ", 
"url" : "ac_example_s4_create_sublevel_light.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Tutorial \/ Getting Started Examples \/ Step 4: Create Submodule \"Light\" ", 
"snippet" : "As it was done before for the Switch and the SwitchSimple , for the module Light , a module declaration Light , a function block Light and an interface ILight have to be created. The module shall be implemented by the function block, which itself shall implement the interface ILight . To be able to ...", 
"body" : "As it was done before for the Switch and the SwitchSimple , for the module Light , a module declaration Light , a function block Light and an interface ILight have to be created. The module shall be implemented by the function block, which itself shall implement the interface ILight . To be able to add the Light module below our Room module, the module declaration of Room has to be extended with a Slots section. In this section a subsection Slot_Multi has to be created, which is called Lights and will be able to hold modules of the type Light . The number of lights, which can or have to be added to a room is defined by the parameter Cardinality (in this case between 1 and 3 lights). Moreover two variables are declared: Variable ( pLights , which will hold the function block instances of the Light modules added to the room) and Var_Count ( uiNumberOfLights , which will be filled with the number of Light modules added to the room). Definition of section Slots The variables pLights and uiNumberOfLights have to be added to the function block of the module \"Lights\", where uiNumberOfLights is a UINT and pLights of type POINTER TO ILight With this definition, only modules whose function blocks also implement the ILight interface can be added to the Lights slot. Declaration in the Room function block The same slot concept that was used for the Room modules is now used for the Light module. As a result, the declaration of Light includes a slot with a Switch , which is why this slot is not a multi-slot, but a simple slot. Additional parameters of the Light module are the speed of the dimmer rSpeed and the maximum brightness uiMaxValue . Finally, an output must be defined which represents the brightness of the associated light. All parameters, slots and outputs must also be added as variables to the function block of the Light module. Declaration of module Light Declaration of the function block Light Text list and image pool Step 5: Create Submodule \"Light simple\" " }, 
{ "title" : "Step 5: Create Submodule \"Light simple\" ", 
"url" : "ac_example_s5_create_sublevel_lightsimple.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Tutorial \/ Getting Started Examples \/ Step 5: Create Submodule \"Light simple\" ", 
"snippet" : "The simple light, which is created now, will work together with a simple switch, but can be adapted from Light above, anyways. Therefore a new module declaration and function block LightSimple have to be created. Since the function block simply implements the interface ILight , it will be possible t...", 
"body" : "The simple light, which is created now, will work together with a simple switch, but can be adapted from Light above, anyways. Therefore a new module declaration and function block LightSimple have to be created. Since the function block simply implements the interface ILight , it will be possible to add lights of different types to a room, later on. The main difference to Light is, that the variable of the slot has to be of the type ISwitchSimple in order to avoid wrong switched to be put under a LightSimple module. Moreover the output of LightSimple shall be of type BOOL and is named xSwitchedOn . Step 6: Implementation " }, 
{ "title" : "Step 6: Implementation ", 
"url" : "ac_example_s6_implementation.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Tutorial \/ Getting Started Examples \/ Step 6: Implementation ", 
"snippet" : "Switches For the implementation of the functionality of the module Switch we use the method CallPrioMediumStart from Module by overriding it with our own implementation. We choose this function, because the module Room declared a MEDIUM task, which implies that the method CallPrioMediumStart of the ...", 
"body" : "Switches For the implementation of the functionality of the module Switch we use the method CallPrioMediumStart from Module by overriding it with our own implementation. We choose this function, because the module Room declared a MEDIUM task, which implies that the method CallPrioMediumStart of the function block Switch will be called each cycle of a medium task. The detailed information can be seen in example project itself. However, the main functionality of the switch is to differ between the tap and dim function. After pushing the switch, a timer will start with the given time from the user parameter. When the timer is finished and the switch not released the dim function is used, indicated by the variable xPushLong . The variable xPush is TRUE , if the switch is just tapped. For both xPushLong and xPush properties are added to both the function block Switch and the interface ISwitch , so that they can be used from the parent light function block. Light Again, the Light function block overrides the method CallPrioMediumStart . Depending on the input variables of the underlying switch, the light is dimmed to \"on\" or \"off\" or only toggled. For the dimmer, the speed value of the declared parameter rSpeed is used. After reaching the maximum or minimum dim value, the dimming is stopped. If the light is in a dimmed state and the switch is tapped, the light is switched on. (The detailed implementation is given in the corresponding example project.) Check the code After implementation, the declarations should be checked by use of the command Build . If no error is displayed the declarations is alright. Step 7: Compose Modules " }, 
{ "title" : "Step 7: Compose Modules ", 
"url" : "ac_example_s7_composing_modules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Tutorial \/ Getting Started Examples \/ Step 7: Compose Modules ", 
"snippet" : "After successful scanning the declarations, all modules are available for further use, so that an example application can be composed. Therefore the modules are added to the module tree of the project. For this the view Modules must be opened. In the first step the toplevel module Room has to be add...", 
"body" : "After successful scanning the declarations, all modules are available for further use, so that an example application can be composed. Therefore the modules are added to the module tree of the project. For this the view Modules must be opened. In the first step the toplevel module Room has to be added to the tree. Add toplevel module to module tree The Module dialog opens and offers all available toplevel modules. In this dialog, the corresponding icons are displayed which were defined in the image pool, as well as the texts from the text lists. Now the module \"Room\" can be selected and added to the module tree. Dialog: \"Add Module\" Now the editor of the toplevel module can be opened by double-clicking Room in the module tree. A target application for code generation must be selected on the Toplevel tab. The tasks which have been declared in the module declaration are displayed in the field Standard Tasks . Settings of the \"Room\" module Analogous to the steps above the submodule Light can be added to the module tree. Due to the multi slot definition in the declaration of the room, up to three lights can be added. The values for maxLightValue and Speed can be parameterized on the Parameters tab of the editor of the Light module. In the I\/O editor the output Brightness is mapped to a local variable uiBrightness for our example. Settings of the \"Light\" module Below the newly added Light , a module Switch must be added. In the instance editor of the Switch module, all parameters and I\/Os, which are defined in the module declaration, are available. For our example the local variable xPushSwitch is mapped to the input variable xIn . The output of the simple light is mapped to the local variable xSimpleOn . Settings of the \"Switch\" module In a last step of our example a LightSimple with a SwitchSimple are added to the module tree. The output of the simple light is mapped to the local variable xSimpleOn . The input of the simple switch xPushSimpleSwitch is mapped to the variable xPushSimpleSwitch. Example composition module tree At the end, the project has to be generate by use of the command Generate . After the download to a device the example can be tested by changing the value of xPushSwitch . For dimming the value of uiBrightness should increase slowly and by tapping, its value is directly set to 0 or to the maximum. Changing xPushSimpleSwitch directly switches the output of the corresponding light. Finally it has to be mentioned, that the last steps, of composing the modules can be done in any combination, without loosing the functionality of the generated code. " }, 
{ "title" : "Library: Mechatronics ", 
"url" : "ac_mechatronics_example.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Editor \/ Tutorial \/ Library: Mechatronics ", 
"snippet" : "The Mechatronics library is meant to be an example for a simple (and not complete) implementation of a mechatronic unit with sequential execution. It does not meet all the requirements that a complete mechatronic application might have. Rather, it is intended to be an entry point or basis for an app...", 
"body" : "The Mechatronics library is meant to be an example for a simple (and not complete) implementation of a mechatronic unit with sequential execution. It does not meet all the requirements that a complete mechatronic application might have. Rather, it is intended to be an entry point or basis for an application of this type. The essential core of the proposed mechatronics model bases on the following module structure: Application Composer example Mechatronics So any machine is assumed to possibly have several mechatronic subunits (example: each representing a gripper). Such a subunit again splits up into its actuators (equaling the mechanical unit itself, also its functional implementation or I\/O management) and a program manager. The program manager is intended to manage the different states of a mechatronic subunit, for example its Idle or Execute state. Eventually those states are represented by program sequences controlling the actuators or anything else needed for a proper execution. At this point, the various parts will be briefly described in detail. When using the library, in many cases it will be necessary to implement your own actuators, flow steps, or program sequences, which will also be explained here. Actuators : All modules which should be actuators must be implemented by a function block that in turn implements the IActuator interface. This interface has no methods or properties and is used only for module compatibility (see the IActuator documentation in the library). There are no restrictions or rules given for actuator implementations, so that the movement or activation of such an actuator has to be done separately. Normally this is done, by implementing a sequence step module, which can hold the proper actuators in a reference slot and thereby move the latter in the desired way (e.g. using additional interfaces). Sequence steps It is strongly recommended that you execute the implementation of flow steps as derived classes of the StepBase function block. This provides all necessary basic implementations of the IProgramSequenceStep interface. See the IActuator documentation in the library. When using the base class StepBase , it is then only necessary to implement the Execute method. The latter is then called cyclically by the program flow until the variable xDone of the base class is set to TRUE . Moreover, for proper functionality, the flag xActive should be set to TRUE as long as the step is active. However, the connection to actuators can be done in any which way, e.g. by the proposed reference slots (see 1.). Program sequence and program manager A program sequence is a submodule of a program manager, which represents a state. These states are managed in the form of an OMAC state machine. Its implementations again bases on a method \"Execute\" (for details see implementation in the library). However, the implementation of such a program flow by the user is not necessary in most cases. However, the way in which the behavior of the status machine is implemented in the program manager and thereby executes the program sequences shall be briefly described here: There are two types of states: acting states (ending with \"ing\") and waiting\/dual states (the rest). The waiting states are ended by external commands, whereas the acting states are automatically executed and ended. Available commands depend on the state in which the program manager is at the moment. A short overview is given in the OMAC state diagram: OMAC diagram Module: MovableBarrier The module MovableBarrier is implemented in the following way: The corresponding function block MovableBarrier implements the created interface IMovableBarrier . The latter interface defines methods for moving a barrier, whereas IMovableBarrier itself implements the interface IActuator , so that the module MovableBarrier is insertable as actuator in the module tree below a mechatronics unit: Implementation of module MovableBarrier However, this actuator \"MovableBarrier\" is moved by the sequence step module MoveBarrierForTime , which itself is implemented in the following way: Implementation of module MoveBarrierForTime The module implementing function block MoveBarrierForTime simply derives from the library-contained base function block AC_MEC.StepBase . By that the function block MoveBarrierForTime already implements the interface IProgramSequenceStep . Consequently the module MoveBarrierForTime is insertable as sequence step under a program sequence. The functional implementation of the function block MoveBarrierForTime is as follows: by defining a reference slot for the module MoveBarrierForTime , which can hold an actuator implementing the interface IMovableBarrier , one gets a connection to an existing \"MovableBarrier\" actuator. The movement of this actuator is finally done in the Execute function of the MoveBarrierForTime function block, which simply calls the method for (pictorially) moving the protective hood. This method is provided by the referenced actuator, which implements IMovableBarrier . Moreover the property Done and the variable xActive are coupled to a TON, so that repeatedly calls to the move functions of IMovableBarrier are done until a certain time (TON) is elapsed after which Done is set to TRUE and xActive to FALSE. The property Done is part of the interface IProgramSequenceStep and thereby tells the superordinate program sequence, that the next sequence step shall be executed. Apart from your own implementation of sequence steps, the AC_Mechatronics.library also provides some pre-implemented steps, which can be used for general, logical operations. For example this means a step BranchOnBool is provided, which has two sub sequences \/ branches of steps, which are executed based on the value of a BOOL variable. These substeps are executed depending on the value of a Boolean variable. Furthermore, the library AC_Mechatronics.library contains flow steps for parallel flows, conditional jumps or simple wait steps and many more tasks. " }, 
{ "title" : "Module Declaration Editor ", 
"url" : "ac_module_declaration_editor_overview.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor ", 
"snippet" : "A module typically represents a mechatronic component but can also be a pure software function. It contains all engineering aspects covered by CODESYS . A module has a function block, which implements the interface IModule from the library AC_ModuleBase . It also contains information about submodule...", 
"body" : "A module typically represents a mechatronic component but can also be a pure software function. It contains all engineering aspects covered by CODESYS . A module has a function block, which implements the interface IModule from the library AC_ModuleBase . It also contains information about submodules, parameterization, I\/O demand, task assignment and visualizations. Modules constitute the central concept of the CODESYS Application Composer . The CODESYS Application Composer also provides a template project, which can be selected in the New Project dialog. This template creates a project with a device, an application and a library manager in the POU pool. The latter contains the libraries AC_ModuleBase and AC_Persistence . The template, which is based on the project ComposerProject.project , can be modified if required. It is stored in the \"Templates\" subfolder of the CODESYS installation directory. A module can be created from an existing function block automatically. Thereby, as far as is possible, existing declarations are transferred to the module declaration. For details see the description of the Create Module from FB command. See Module Declaration for detailed information on how to develop modules. For Information about data exchange between different applications see IRMPService . " }, 
{ "title" : "Module Declaration ", 
"url" : "ac_module_declaration.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration ", 
"snippet" : "The declaration of modules is done with an own description language which is similar to the declaration of variables in structured text (ST) code. Sections of the module declaration Section: MetaData Section: Toplevel Section: IO Section: Parameters Section: Slots Section: Visu Section: Proxies Sect...", 
"body" : "The declaration of modules is done with an own description language which is similar to the declaration of variables in structured text (ST) code. Sections of the module declaration Section: MetaData Section: Toplevel Section: IO Section: Parameters Section: Slots Section: Visu Section: Proxies Section: VarArrays Section: Constraints Section: InstRefs Section: mse.Sequence Device Generatoralg.Alarm" }, 
{ "title" : "Format of the module declaration ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_48fab9ed86f6686ac0a8640e00dcb86d", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Format of the module declaration ", 
"snippet" : "A header of the form MODULE<name> begins the declaration. This is followed by a list of \"sections\". Each section is introduced by the keyword SEC (for \"section\") and a unique name. The keyword END_SEC closes the section. The contents of a section contain a list of entries consisting of further secti...", 
"body" : "A header of the form MODULE<name> begins the declaration. This is followed by a list of \"sections\". Each section is introduced by the keyword SEC (for \"section\") and a unique name. The keyword END_SEC closes the section. The contents of a section contain a list of entries consisting of further sections or so-called definitions. A definition consists of a name and an optional value and ends with a semicolon. Comments can be used as in ST code: \"\/\/\"\" for a single line comment and \"(*\" and \"*)\" for multiline comments. Whitespace (tabs and spaces) and newline\/linefeed can be used to separate the parts of a declaration. Otherwise they are ignored during further processing. As with ST code, case sensitivity makes no difference. The following example explains the elements of a module declaration 01 MODULE Persistence IMPLEMENTED_BY PersistenceFB\n02 SEC MetaData\n03 NAME := TL.ChannelName ;\n04 DESC := TL.ChannelDesc ;\n05 COLLECTION CATEGORY := ’Persistence’TL.Collection ;\n06 ICON_16 := IP.Channel16 ;\n07 ICON_32 := IP.Channel32 ;\n08 END_SEC\n09 SEC Toplevel\n10 SEC STANDARD_TASK : LOW\n11 NAME := LOW ;\n12 DESC := TL.TaskLow ;\n13 FLAGS := CREATE_IF_MISSING | READONLY ;\n14 END_SEC\n15 GVL_NAME := 'GVL_%InstanceName%' ;\n16 END_SEC In line 01 there is the definition of the module name \"Persistence\". IMPLEMENTED_BY defines the function block \"PersitenceFB\" which contains the logic of the module. This function block must derive from IModule . In line 02 the section MetaData begins and it ends with line 08. This section contains five definitions. The possibility of nested sections is shown in the section Toplevel (lines 09–16) which contains the subsection STANDARD_TASK (line 10). " }, 
{ "title" : "Syntax of the module declaration ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_819a1c8e627d0b32c0a8640e01623943", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Syntax of the module declaration ", 
"snippet" : "In this section the syntax and the allowed syntactic structure of a module declaration will be explained. In the following scanner tokens will be written in capitals (example: ID ). Non-terminals of the grammar will be written in curly brackets (example: {Entry} ). Lexical analysis (scanner) In the ...", 
"body" : "In this section the syntax and the allowed syntactic structure of a module declaration will be explained. In the following scanner tokens will be written in capitals (example: ID ). Non-terminals of the grammar will be written in curly brackets (example: {Entry} ). Lexical analysis (scanner) In the first step so-called tokens (or lexemes) will be created from the characters of the module declaration (example: keywords, constants, identifiers). Whitespace as well as newline\/linefeed characters separate tokens, but will be ignored otherwise. Comments will also be ignored for the further treatment of the declaration. (Comments can be written in a single line ( \/\/ \") or multiline comments ( (* and *) ) as in to ST language. Multiline comments can be nested. Basically a token has always a maximal length. For example a123 will be interpreted as an identifier and not as an identifier a followed by a literal 123 . The order of the tokens in the list below shows their priority. For example the input MODULE will be understood as keyword and not as identifier. List of all available tokens: Keywords: MODULE , SEC , END_SEC , IMPORTS , and IMPLEMENTED_BY OP: a non-empty sequence of the following characters: .:,%()[]{}<>|+-*\/@!?^°=\\~ Note: The comment markers \/\/ , (* , and *) have higher priority than operators. There can be no comment inside an operator no comment can be, example: +\/\/+ will, according to the rule of maximum length, interpreted as an operator and not as + followed by a comment. LIT: An IEC literal, as it is used in ST, example: 1.4 , tod#12:13:14 . This includes the boolean literals TRUE and FALSE (upper or lower case is not relevant). Note: Untyped literals with a negative sign ( -1 , -3.2 ) will be read as two tokens, that is as operator - followed by an untyped literal. Resulting from this untyped numeric literals can never be negative. Typed literals ( INT#-34 ) will always be interpreted as one token. ID: a valid IEC identifier ( [a-zA-Z_][a-zA-Z0-9_]* ), whereby two consecutive underlines are not allowed. This includes in contrast to ST also the keywords of ST (i.e.: FUNCTION , INT , EXTENDS , …) SEMICOLON: the character ; Syntax (parser) The syntax of the module declaration is defined by the following grammar. µ is an empty sequence. {MDecl} ::= MODULE {QID} {ImplSpec} {ImportsSpec} {MBody}\n{ImplSpec} ::= IMPLEMENTED_BY {QID} | µ\n{ImportsSpec} ::= IMPORTS {QID} | µ\n{MBody} ::= {SecList}\n{SecList} ::= {Modifiers} {Sec} {SecList} | µ\n{Sec} ::= SEC {QID} {SecTarget} {EntryList} END_SEC\n{SecTarget} ::= OP(\":\") {QID} | µ\n{Modifiers} ::= OP(\"[\") {ModifierList} OP(\"]\") | µ\n{ModifierList} ::= {QID} OP(\",\") {ModifierList} | {QID}\n{EntryList} ::= {Modifiers} {Entry} {EntryList}\n{Entry} ::= {Sec} | {Def}\n{Def} ::= {QID} OP(\":=\") {ValList} SEMICOLON |\n {QID} SEMICOLON\n{ValList} ::= {Val} {ValList} | {Val}\n{Val} ::= ID | LIT | OP\n{QID} ::= ID | ID OP(\".\") {QID} The list of definition values ( {ValList} ) must be completed with a semicolon. This simplifies the grammar and avoids ambiguities, because the semicolon cannot be part of a value ( {VAL} ), except within a string literal. The assignment operator ( := ) of definitions ( {Def} ) also serves to avoid ambiguities ( {QID} ) of definition names and values. Defined types for definitions Text: ID.ID (text list name and text list identifier) - see Localization of text list strings Image: ID.ID (image pool name and image pool identifier) ID (IEC identifier) QID (Qualified identifier): {QID} ::= ID | ID.ID CategoryPath ::= {StringLiteral} | {CategoryPath} Cardinality: [{MIN} .. {MAX}] | [ {MIN} .. INF [ {MIN} , and {MAX} are integer, non-negative literals. If {MAX} != INF , then {MIN} <= {MAX} has to apply. StringLiteral: A IEC string literal may contain line breaks. StdTaskFlags ::= {StdTaskFlag} | {StdTaskFlags} StdTaskFlag ::= NONE | CREATE_IF_MISSING | READONLY Literal: any IEC literal or QID (for Enum constants) DTBoolFlag: µ (empty sequence) | TRUE | FALSE SlotType: SUBMODULE | REFERENCE Pragmas: [ {PragmaList} ] {PragmaList} ::= {Pragma} | {Pragma} , {PragmaList} {Pragma} ::= { ( ID | {StringLiteral} | {OP2} )+ } {OP2} : every operator except {, }, [, ] and , . InstancePath: InstancePath ::= {IComp} | {IComp} . {IComp} mit {IComp} ::= ID {ArrayAccess}* und {ArrayAccess} ::= [ {IntList} ] und {IntList} ::= Int | Int , {IntList} TaskRef: Standard_Task. ( Low | Medium | High ) | Custom_Task.ID " }, 
{ "title" : "Instance paths ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_e00dd4f26a1882aec0a8652000c0a4ae", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Instance paths ", 
"snippet" : "At some positions in the module declaration instance paths can be defined to address a variable of a function block: For parameters, slots, I\/Os, arrays with variable size and instance references. An instance path is defined as a non empty sequence of components, separated by dots: C1.C2…CN . A comp...", 
"body" : "At some positions in the module declaration instance paths can be defined to address a variable of a function block: For parameters, slots, I\/Os, arrays with variable size and instance references. An instance path is defined as a non empty sequence of components, separated by dots: C1.C2…CN . A component must either be a IEC identifier or a component followed by an index expression [i1, …, iN] , where i1 to iN are integer values. Instance paths are always relative to the function block which implements the module logic. The first component of the instance path is a member ( VAR_INPUT or VAR_OUTPUT , depending on the use case) of the function block. In case of additional components in the instance path these components address the variable within the member. Otherwise the member itself is addressed. Instance paths can be restricted to input or output variables (example: for I\/Os). For structures these restrictions are not valid. These kind of instance paths are called input instance paths resp. output instance paths. " }, 
{ "title" : "Localization of text list strings ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_497561d55e22d540c0a8640e01561e3c", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Localization of text list strings ", 
"snippet" : "Texts in modules (example: description of module, name, description of parameter) can be displayed in different languages. These texts are managed in text lists. Specification for the language name: The name of the language is of format <LanguageCode>[-<Country\/Region>] (example: en-US , de-DE ). <L...", 
"body" : "Texts in modules (example: description of module, name, description of parameter) can be displayed in different languages. These texts are managed in text lists. Specification for the language name: The name of the language is of format <LanguageCode>[-<Country\/Region>] (example: en-US , de-DE ). <LanguageCode> is the name of the language according to ISO 639-1 (example: de or en ). <Country\/Region> is a country code according to ISO 3166. When retrieving a text list entry the system first looks up for the whole language name. If nothing is found it looks up for the <LanguageCode> . If this search also fails the default text will be used. Examples for language names in text lists Language Name of the language Chinese zh-CHS English en-US French fr-FR German de-DE Italian it-IT Japanese ja-JP Portuguese pt-PT Russian ru-RU Spanish es-ES " }, 
{ "title" : "Deriving module declarations ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_a596cccf5e22d542c0a8640e019ddff8", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Deriving module declarations ", 
"snippet" : "Analogously to the object oriented inheritance of a function block A from a function block B (\"EXTENDS\") there is the possibility of deriving module declarations by use of the IMPORTS keyword. The modifiers UPDATE and HIDE are treated specially. The following rules are used: The name of the imported...", 
"body" : "Analogously to the object oriented inheritance of a function block A from a function block B (\"EXTENDS\") there is the possibility of deriving module declarations by use of the IMPORTS keyword. The modifiers UPDATE and HIDE are treated specially. The following rules are used: The name of the imported module must be specified with namespace if this module is defined in a different library. Cyclic imports are not allowed, in particular a module must not import itself. (Example for a cyclic import: module M_1 imports module M_2, M_2 imports M_3, …, M_N imports M_1 again.) A derived module can be defined without the IMPLEMENTED_BY directive. In this case the function block of the base module will be used. If a derived module specifies a function block (by use of MPLEMENTED_BY ), this function block must derive from the function block of the base module or must be identical to it. A derived module inherits all sections of the base module. It can add new sections or modify existing sections. A section can be modified in the derived module by using the same name and target extended with the modifier UPDATE . In this case, its entries are changed. All missing definitions of the section in the derived module will be taken over from the base module. The modifier UPDATE and HIDE can only be used if the respective section (name and target) is defined in the basic module. Conversely a section, which is defined in the base module can only be used in the derived module if it has the HIDE or UPDATE modifier. If there is only the HIDE modifier in the section and not UPDATE , then no definitions are allowed. Some entries must be changed in the derived module (example: the description). Example: MODULE MBase IMPLEMENTED_BY FBBase\nSEC MetaData\n DESC := TL.Desc_Base ;\nEND_SEC\nSEC Parameters\n SEC Param : paramxIn\n Variable := xIn ;\n Name := TL.Param1_Name ;\n Desc := TL.Param1_Desc ;\n END_SEC\nEND_SEC\n\nMODULE MDerived IMPORTS MBase\n[UPDATE] SEC MetaData\n DESC := TL.Desc_Derived ;\nEND_SEC\n[UPDATE] SEC Parameters\n [UPDATE,HIDE] SEC Param : paramIn\n Variable := xIn ;\n DEFAULT := TRUE ;\n END_SEC\nEND_SEC In the example above the parameter paramIn of the module MBase is hidden in the derived module MDerived (by use of the HIDE modifier), and at the same time a new default value ( TRUE ) is set. " }, 
{ "title" : "Notes to the order of sections and definitions ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_87237560fda311e1967bf6fe1c17b04f", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Notes to the order of sections and definitions ", 
"snippet" : "The order of the sections directly after the module header is irrelevant. Within the sections the order may be very important. For example the order of the slot declarations defines the order of the modules in the module tree. The order of the definitions is always irrelevant. Rules for derived modu...", 
"body" : "The order of the sections directly after the module header is irrelevant. Within the sections the order may be very important. For example the order of the slot declarations defines the order of the modules in the module tree. The order of the definitions is always irrelevant. Rules for derived modules relating the order: The sections of the base modules are always defined before the sections of the module itself. If a section of the base module is changed by use of UPDATE or HIDE , its order is not affected. It is not possible for a derived module to change the order as defined in the base module. " }, 
{ "title" : "Auto-completion and \"list components\" ", 
"url" : "ac_module_declaration.html#UUID-9ead98f5-7e68-79f5-73d5-470735892e63_e7b6ee262492c0a8640e00bdeebc_id_23e0e10e3a0c71c9c0a8640e0040f55b", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Auto-completion and \"list components\" ", 
"snippet" : "When start typing in the module editor all available\/possible section definitions are shown in an \"list components\" menu. Only meaningful sections and definitions for the current position are shown. Even if some subsection entries have the same name as subsection entries of other sections, it will t...", 
"body" : "When start typing in the module editor all available\/possible section definitions are shown in an \"list components\" menu. Only meaningful sections and definitions for the current position are shown. Even if some subsection entries have the same name as subsection entries of other sections, it will try to display only the matching section definitions. If Return is pressed after completing the first line of a section, then the section will be completed with all necessary definitions\/sections and the END_SEC . After variable definitions input\/output variables are presented by \"list components\" definitions. Flags or predefined values are also presented in a \"list components\" selection, which shows the possible flags\/values. After definitions, which use text list entries or image pool entries (example: most times Desc := ), a \"list components\" menu including all available and visible text lists or image pools and their entries is presented. By pressing F2 , the corresponding input support can be opened. " }, 
{ "title" : "Initialization of Module Instances (Online Change) ", 
"url" : "ac_initialization_of_module_instances.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Initialization of Module Instances (Online Change) ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Initialization and reinitialization of module instances and proxy instances (online change) ", 
"url" : "ac_initialization_of_module_instances.html#UUID-d33dd918-6f7b-5e75-6686-b9d605273b58_index_2", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Initialization of Module Instances (Online Change) \/ Initialization and reinitialization of module instances and proxy instances (online change) ", 
"snippet" : "The method IBaseInstance.Init(bOnlineChange : BOOL) ) is called after a download or an online change for all toplevel module instances and for all proxy instances. The modules are responsible for calling all managed module instances, if necessary. Init is called as soon as all parameter values, mana...", 
"body" : "The method IBaseInstance.Init(bOnlineChange : BOOL) ) is called after a download or an online change for all toplevel module instances and for all proxy instances. The modules are responsible for calling all managed module instances, if necessary. Init is called as soon as all parameter values, managed and referenced module instances are set and the module instances have been mounted in the module tree, but before the tasks are started or continued. The standard implementation in function block Module calls all submodules. The methods IBaseInstance.OnBeforeOnlineChange and IBaseInstance.OnAfterOnlineChange are called before and after the structure of the module tree has been recreated and the parameter values have been changed. Furthermore the methods are called before and after all submodules and referenced modules have been reassigned, but before the tasks are (re-)started. In contrast to FB_Init , this method is called at every online change, regardless of whether FB_Exit has been called on the old instance before. " }, 
{ "title" : "Section: MetaData ", 
"url" : "ac_module_fb_sec_metadata.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: MetaData ", 
"snippet" : "MetaData The section MetaData contains the description, category and icons (with size 16x16 pixel and 32x32 pixel). SEC MetaData \/\/optional: yes, modifier: [UPDATE]] Desc := <description>; \/\/optional: no, type: text Category := <category name>; \/\/optional: no, type: CategoryPath Icon_16 := <icon16 n...", 
"body" : "MetaData The section MetaData contains the description, category and icons (with size 16x16 pixel and 32x32 pixel). SEC MetaData \/\/optional: yes, modifier: [UPDATE]]\n Desc := <description>; \/\/optional: no, type: text\n Category := <category name>; \/\/optional: no, type: CategoryPath\n Icon_16 := <icon16 name>; \/\/optional: no, type: image\n Icon_32 := <icon32 name>; \/\/optional: no, type: image\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: IDOrNothing\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n Links := ['<link1>','<link2>',...] \/\/optional: Yes, type: UriCollection\nEND_SEC Details regarding the syntax of definition types are described in the section Module Declaration . Specification: If the section MetaData is missing, this module will be used as base module which cannot be instantiated. Category defines a topic for modules belonging to the same subject. The character | creates a hierarchic structure of the elements in the \"Add module\" dialog. The characters | and newline or carriage return are not allowed in the structure names. Icon_16 defines the name of the icon with resolution 16 x 16 pixels. The images for the icons must be defined in an image pool. The icon Icon_16 is used for the module tree and the icon Icon_32 for the information dialog. Inst_Prefix defines the default prefix for the names of generated FB instances and submodule instances. Empty prefix ( Inst_Prefix := ) are also possible, which however may cause a intersection with other variable names of the function block. This presetting can be overwritten in the section Slot . If deriving from a module class with IMPORTS , the section MetaData must be updated if this section exists in the base module. To do this the section must be declared with the modifier UPDATE and the description must be redefined. Default_Inst_Name can be used to define a default name for module instances being children of this slot. Each module which is added will get this name by default using text list entry defined by \"Default_Inst_Name\". If there is a default name of a parent slot, this name is preferred to the one in the meta data of the module Links defines a list of links. The links are displayed in the module editor in the Information tab. The content of the first URL of link list is displayed in the Information tab. Example SEC MetaData\n Desc := TL.Desc_Drives ;\n Category := 'Mechatronics'|'Drives' ;\n Icon_16 := IP.Drive_Icon_16 ;\n Icon_32 := IP.Drive_Icon_32 ;\n Default_Inst_Name := IDrive ;\n Links := ['file:\/\/\/d:\\Document1.pdf', 'https:\/\/www.codesys.com', 'mailto:info@codesys.com'];\nEND_SEC Category := 'Mechatronics'|'Drives creates the following structure: " }, 
{ "title" : "Section: Toplevel ", 
"url" : "ac_module_fb_sec_toplevel.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: Toplevel ", 
"snippet" : "Toplevel Modules which are located at the first level of the module tree are called toplevel modules. In contrast to other modules they have methods which can be called directly from one or several tasks. Toplevel modules contain the section Toplevel . SEC Toplevel \/\/optional: yes, modifier: [UPDATE...", 
"body" : "Toplevel Modules which are located at the first level of the module tree are called toplevel modules. In contrast to other modules they have methods which can be called directly from one or several tasks. Toplevel modules contain the section Toplevel . SEC Toplevel \/\/optional: yes, modifier: [UPDATE]\n GVL_Name := <GVL name>; \/\/optional: yes, type: literal\n Default_Application := <default application>; \/\/optional: yes, type: QID\n Default_POUPool := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n SEC Standard_Task : <task name> \/\/optional: yes, modifier: [HIDE,UPDATE]\n Name := <task name>; \/\/optional: no, type: ID\n Desc := <task description>; \/\/(optional: no, type: Text)\n Flags:= <flag>; \/\/(optional: no, type: StdTaskFlags)\n END_SEC\n SEC Custom_Task : <task name> \/\/optional: yes, modifier: [UPDATE]\n Priority := <priority>; \/\/optional: no, type: Subrange(0 .. 31)\n Interval := <interval>; \/\/optional: no, type: TimeLiteral)\n Flags:= <flag>; \/\/optional: no, type: CustomTaskFlags)\n END_SEC\nEND_SEC Details regarding the syntax of definition types are described in the section Module Declaration . Specification: GVL_Name defines the name of the GVL in which the instance of the module and all its subinstances will be declared. The placeholder %Instancename% (Upper or lower case spelling is not relevant), will be replaced by the instance name of the module instance. The parameter Default_Application defines the application assignment for all instances of this module to a specific application. If a default application is defined the use of Default_POUPool is not possible. The parameter Default_POUPool defines the application assignment for all instances of this module to POU pool. If a default POU pool is defined the use of Default_Application is not possible. The parameter Pragmas contains a list of compiler pragmas, which will be inserted before the declaration of the FB instances of the module. The section Standard_Task defines the tasks from which calls will be executed. For this three standard tasks are available: LOW , MEDIUM , and HIGH . The definitions of Standard_Task are: Name : Default task name which will be defined as task assignment after creating the module instance. Desc : Identifier for the task call. This should be short and meaningful (example: I\/O task ). Flags : The following values can be combined with the | character: CREATE_IF_MISSING : The task will be created if it does not exists. READONLY : The task assignment is read only and the user cannot change it. UPDATE_IOS : The task is used to update I\/Os. Each I\/O can be overwritten by the UpdateInTask parameter in the IO section. NONE : No flag is set. Example SEC Standard_Task : MEDIUM\n Name := MainTask ;\n Desc := TL.TaskMedium_Desc ;\n Flags := READONLY | CREATE_IF_MISSING ;\nEND_SEC By use of the section Custom_Task a module can define one or more custom tasks. The target of the section must be the name of a method of the module function block. The method must not have arguments (neither INPUT , OUTPUT , nor INOUT ). Priority : Defines the task priority. Interval : Defines the task interval (constant of data type \"TIME\" or \"LTIME\"). Flags : The following values can be combined with the | character: SHARED : For compatibility reasons, this flag still exists, but is always implicitly assumed to be set. It basically would mean, that if a task with the properties specified in the Custom_Task section already exists, this task will be used. But because a new task will be created if there is no existing task with matching properties, this flag is rendered obsolete. The name of the created task is TASK_<ModuleInstanceName>_<MethodName> . UPDATE_IOS : The task will be used for updating the I\/Os, which are connected to ST expressions or directly to module I\/Os. NONE : No flag is set. There is no default implementation in the module class for the specified method. Example SEC Custom_Task : Method1\n Priority := 7 ;\n CycleTime := t#14ms ;\n Flags := NONE ;\nEND_SEC Exactly one standard or specific task has to have the UPDATE_IOS flag set. Some basic rules, how the tasks are generated shall be mentioned here: If standard tasks exist, which do not have the CREATE_IF_MISSING flag set, a task with the specified name and properties of the generator settings should exist. If the properties do not match the specified one a warning message is displayed. If standard tasks exist, which has the CREATE_IF_MISSING flag set, first a task with specified properties is generated. Now, whenever the generator settings for this task are changed, the task is adapted, without any warning message. Standard tasks of different types that reference the same task name are not allowed. In this case, an error is not issued. Depending on the configured standard the following methods are called at the beginning and at the end of the defined task for each toplevel instance: METHOD CallPrioHighStart: BOOL\nMETHOD CallPrioHighEnd: BOOL\nMETHOD CallPrioMediumStart: BOOL\nMETHOD CallPrioMediumEnd: BOOL\nMETHOD CallPrioLowStart: BOOL\nMETHOD CallPrioLowEnd: BOOL Each module is responsible to call its submodule instances. Submodule references must not be called. The default implementation in the FB Module calls the respective methods of all submodule instances in the order of their position in the module tree. The SUPER pointer offers access to the instance of the base function block. Therefore for example the call SUPER^.CallPrioHighStart() can be used to call the method Module.CallPrioHighStart() if the function block extends Module . This way, the implementation in Module will make sure that all submodules are called. " }, 
{ "title" : "Section: IO ", 
"url" : "ac_module_fb_sec_io.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: IO ", 
"snippet" : "IO The input and output definition can be done in this section. All defined inputs and outputs are available in the Map I\/Os . SEC IO \/\/optional: yes, modifier: [UPDATE] SEC Input : <input identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/optional: no, type: Instance...", 
"body" : "IO The input and output definition can be done in this section. All defined inputs and outputs are available in the Map I\/Os . SEC IO \/\/optional: yes, modifier: [UPDATE]\n SEC Input : <input identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Name := <name>; \/\/optional: no, type: text\n Desc := <description>; \/\/optional: no, type: text\n UpdateInTask := <task name>; \/\/optional: yes, type: TaskRef\n END_SEC\n SEC Output : <output identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Name := <name>; \/\/optional: no, type: text\n Desc := <description>; \/\/optional: no, type: text\n UpdateInTask := <task name>; \/\/optional: yes, type: TaskRef\n END_SEC\nEND_SEC For details on the syntax of the definition types see: description in Syntax of the module declaration . Specification: The parameter Variable defines the instance path of an input variable or output variable. All components of the path for inputs must be input variables (or local variables in structures). All components of the path for outputs also must be output variables (or local variables in structures). The variable must be primitive data type or enum data type. A variable can be parameter and input\/output at the same time. A variable must not be used by two different I\/Os. The target of an input or output section must uniquely identify the input or output. There is no case sensitivity. The parameter UpdateInTask determines the task for updating I\/Os. If this parameter is missing the task with the flag UPDATE_IOS will be used. For toplevel modules an error will be created if the task specified in UpdateInTask is not defined for the module. Example SEC Io\n SEC Input : uiTemperature\n Variable := uiTemperature ;\n Name := TL_WeatherStation.NAME_iTemperature ;\n Desc := TL_WeatherStation.DESC_iTemperature ;\n UpdateInTask := Standard_Task : Medium;\n END_SEC\n SEC Output : uiLigh\n Variable := uiLightnessSouth ;\n Name := TL_WeatherStation.NAME_uiLightnessSouth ;\n Desc := TL_WeatherStation.DESC_uiLightnessSouth ;\n UpdateInTask := Standard_Task : Medium;\n END_SEC\nEND_S " }, 
{ "title" : "Section: Parameters ", 
"url" : "ac_module_fb_sec_parameters.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: Parameters ", 
"snippet" : "Parameters In this section all parameters can be defined which must be available for a parameterization in the Parameters of the module instance. SEC Parameters \/\/optional: yes, modifier: [UPDATE] SEC Param : <parameter identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>;...", 
"body" : "Parameters In this section all parameters can be defined which must be available for a parameterization in the Parameters of the module instance. SEC Parameters \/\/optional: yes, modifier: [UPDATE]\n SEC Param : <parameter identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: yes, type: InstancePath\n VariableType := <data type> \/\/optional: yes, type: @JG???IEC-Typ\n Name := <parameter name>; \/\/optional: no, type: text\n Desc := <parameter description>; \/\/optional: no, type: text\n Group := <parameter group name> \/\/optional: yes, type: text\n MustBeSet := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n Default := <default value>; \/\/optional: yes, type: LiteralOrConstant\n Max := <max value>; \/\/Optional: yes, type: LiteralOrConstant\n Min := <min value>; \/\/Optional: yes, type: LiteralOrConstant\n END_SEC\nEND_SEC Details regarding the syntax of definition types are described in the section Module Declaration . Specification: The target of the section Param must identify the parameter uniquely. The definition Variable is an input instance path relative to the module function block. This variable will store the parameter value, its type defines the parameter type. If Variable is declared, the parameter VariableType does not have to be defined and will be ignored. The parameter VariableType defines the IEC type of the variable. If VariableType is declared but no real existing FB variable is given in the Variable definition, the Default definition must exist. This value must match the VariableType . The parameters Name and Desc are strings and must be defined in a text list. Module parameter can be basic types and enumerations but no instances of structures and arrays. Parameter variables must have Initialization values , which are defined in the declaration of the function block. The optional parameter Default allows to overwrite the initialization value. For the initialization expression and for the default value literals and constants of the correct type are allowed. This includes library parameters. The optional parameter Group allows to split the parameters in groups. Each group is then displayed as a separate tab in the module editor under Parameters . With the optional parameter MustBeSet the user can be forced to set a parameter in the module editor. If the parameter is not set, an error message appears. The definitions Min and Max allow to set limits for the parameter value. A check of these limits is only possible for variables of numeric type or times. All other variable types are not allowed and will produce an error. Example SEC Parameters\n SEC Param : InParam1\n Variable := xIn1;\n VariableTyp := BOOL;\n Name := TL.Input1_Name;\n Desc := TL.Input1_Desc;\n END_SEC\nEND_SEC The variable xIn1 must be defined in the declaration part of the function block: xIn1 : BOOL := FALSE ; " }, 
{ "title" : "Initialization values ", 
"url" : "ac_module_fb_sec_parameters.html#UUID-1cddf7ea-faa7-0b82-e29a-04e9f27653b0_ac_module_fb_sec_parameters0", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: Parameters \/ Initialization values ", 
"snippet" : "The initialization value is the value of a variable which is defined in the initialization. In simple variables of the FB this value is always on the right side of the variable declaration: iVar : INT := 17 ; \/\/ Initialisierungswert: 17 In case of definition of variables in structures the initializa...", 
"body" : "The initialization value is the value of a variable which is defined in the initialization. In simple variables of the FB this value is always on the right side of the variable declaration: iVar : INT := 17 ; \/\/ Initialisierungswert: 17 In case of definition of variables in structures the initialization of the structure is essential: TYPE s : STRUCT\n i1 : INT := 7 ;\n r1 : REAL := 5 ;\nEND_STRUCT END_TYPE Declaration in the module FB: structVar : s := (i1 := 2, r1 := 0.0) ; In this case the initialization value which defines the value of structVar.i1 is 2 (and not 7 ). In nested structures all initializations in the path from the module FB to the variable must be considered. The outermost initialization of the variable determines the value. " }, 
{ "title" : "Section: Slots ", 
"url" : "ac_module_fb_sec_slots.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: Slots ", 
"snippet" : "Slots This section defines the availability and the type of slots of modules in the module tree. Two different types of slots can be defined. Slot SEC Slots \/\/optional: yes, modifier: [UPDATE]] SEC Slot : <slot identifier> \/\/optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/option...", 
"body" : "Slots This section defines the availability and the type of slots of modules in the module tree. Two different types of slots can be defined. Slot SEC Slots \/\/optional: yes, modifier: [UPDATE]]\n SEC Slot : <slot identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Role := <role name>; \/\/optional: no, type: text\n Type := <slot type>; \/\/optional: no, type: SlotType\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: ID\n Optional := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n RegularExpressionParameterId := <RegEx param ID> \/\/optional: yes, type: text\n SEC Default_Allocation : \/\/optional: yes, modifier [UPDATE]\n Module_Name := <default module ID>; \/\/optional: yes, type: ID\n Instance_Name := <default name>; \/\/optional: yes, type: ID\n NotDeletable := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n SEC VisuEmbeddings \/\/optional: yes, modifier [UPDATE]\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <visu identigier> \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: ID\n Target := <target name>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: yes, type: ID\n TopLevelTap := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n SEC IOMappings \/\/optional: yes, modifier [UPDATE]\n SEC Mapping : <mapping identifier> \/\/optional: yes, modifier [UPDATE]\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, tye: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier [UPDATE]\n SEC Param : <param identifier> \/\/optional: yes, modifier [UPDATE]\n Value := <value>; \/\/optional: no, type: ID)\n END_SEC\n END_SEC\n END_SEC\n END_SEC\nEND_SEC Details regarding the syntax of definition types are described in the section Module Declaration . Specification: The section Slot defines a slot which allows 0 connection or 1 connection. The target of the section Slot must identify the parameter uniquely. As a result, there must not be two different slots (whether Slot or Slot_Multi ) that have the same target. (Upper\/lower case is irrelevant.) The definition Variable is an input instance path relative to the module function block. The instance path may refer in all its components only to input variables (for structure instances also local variables). The type of the addressed variable must be an interface or a FB type. Two different slots must not use the same variable. Role defines the role description of the slot. Type defines the slot type. The connection type can have the following values: SUBMODULE : Slot for submodule instances. REFERENCE : Slot for referenced submodule instances. DECOUPLED : Slot for \"decoupled\" module instances. See also: Section: Decoupled Inst_Prefix is a prefix which is used for the name of the generated FB variable. Empty prefix ( Inst_Prefix := ; ) is also possible, but may create conflicts with other variable names of the function block. May only be specified for SUBMODULE type slots. Optional defines if it is allowed to leave the slot open or if it must be connected. Default_Inst_Name can be used to define a default name for module instances being children of this slot. Each module which is added will get this name by default using text list entry defined by \"Default_Inst_Name\". The default name of the slot is preferred to the one of the modules meta data. Pragmas contains a list of compiler pragmas which are inserted before FB instances of the submodules. Pragmas may only be used for managed slots. RegularExpressionParameterId defines a parameter of type STRING\/WSTRING for this slot. The value of this parameter is interpreted as regular expression and it must match the name of the inserted submodule. The sections Slot.Default_Allocation and Slot_Multi.Default_Allocation allow to define default settings for slots with variable numbers of elements (Multi_Slots and Slots). For Slots.Multi_Slot they must be identified by unique targets whereas Slots.Slot has not target and can only have one Default_Allocation section. The instance will be added depending on its position within the section. The module name and instance name follows the definition of Slot.DefaultModule and Slot.DefaultName . If this definitions are not available the settings of Default_Allocation.Module_Name and Default_Allocation.Instance_Name will be used. It is recommended to use Default_Allocation.* for slots instead of DefaultModule and DefaultName which only exists for compatibility reasons. The settings of the default module instance can be defined in the subsections of Default_Allocation : Module_Name defines the name of the module of which an instance will be created automatically. If the module comes from a library, the module name must be qualified with namespace. The parameter is only allowed for slots of type SUBMODULE . Infinite calls are not allowed and will create an error message (example: declaration of module \"A\" contains default module \"B\"; declaration of module \"B\" contains default module \"A\"). Instance_Name must be specified whenever DefaultModule is specified, and never otherwise. It must be a valid IEC identifier which is used as the name of the default module instance. The name must not begin or end with an underline ( _ ). The default names of all slots of a declaration must be unique. (Case sensitivity makes no difference.) NotDeletable specifies whether or not the module can be deleted by the user. If TRUE , then the module cannot be deleted. An error message is displayed. If the parameter is FALSE or it is omitted, then the module can be deleted. VisuEmbeddings : If the Empty parameter is set to TRUE , then an empty list of embedded visus is created for this module instance. If the value is FALSE , then the desired list of embedded visualizations can be generated for the module instance via the listing of desired embedded visualizations in the Embedding subsection. Each Embedding section must define the name VisuName of the desired embedded visu for this purpose and can specify additional properties such as Target or LinkId of this embedded visu. PageVisu : In this section the PageVisu of the module instance can be chosen ( VisuName ). Furthermore it can be defined if this visu creates a TopLevelTap . The parameter TopLevelTap has to be given the values TRUE and FALSE . IOMappings : In the subsection Mapping the I\/O channels can be defined. The targets of the sections Mapping describe the target I\/O channel. The default can be set to NoMapping or to an STExpression . Parameters : In the subsection Param the value Value of each parameter which is defined in the target of the section can be defined. Slot_Multi By use of the section Slot_Multi a list of subinstances and references can be created. SEC Slots \/\/optional: yes, modifier: [UPDATE]]\n SEC Slot_Multi : <slot name> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable for count>; \/\/optional: no, type: InstancePath\n Role := <name role>; \/\/optional: no, type: text\n Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\n Type := <slot type>; \/\/optional: no, type: SlotType\n Inst_Prefix := <instance prefix>; \/\/optional: yes, type: ID\n Pragmas := <pragma list>; \/\/optional: yes, type: Pragmalist\n Default_Inst_Name := <instance name>; \/\/optional: yes, type: text\n RegularExpressionParameterId := <RegEx param ID> \/\/optional: yes, type: text\n SEC Default_Allocation : \/\/optional: yes, modifier [UPDATE]\n Module_Name := <default module ID>; \/\/optional: yes, type: ID\n Instance_Name := <default name>; \/\/optional: yes, type: ID\n NotDeletable := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n SEC VisuEmbeddings \/\/optional: yes, modifier [UPDATE]\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <visu identifier> \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: ID\n Target := <target name>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier [UPDATE]\n VisuName := <visu name>; \/\/optional: yes, type: ID\n TopLevelTap := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n SEC IOMappings \/\/optional: yes, modifier [UPDATE]\n SEC Mapping : <mapping identifier>; \/\/optional: yes, modifier [UPDATE]\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, tye: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier [UPDATE]\n SEC Param : <param identifier> \/\/optional: yes, modifier [UPDATE]\n Value := <value>; \/\/optional: no, type: ID)\n END_SEC\n END_SEC\n END_SEC\n END_SEC\nEND_SEC Additional specifications: Var_Count defines the input instance path of the module function block. This variable (of type Integer) will save the information about the number of instances connected to the slot. Cardinality defines the minimum and maximum number of instances. The Slot_Multi.Default_Allocation section can be used to define default allocations for slots with variable number of elements. They must be identified via unique targets. The instances are inserted in the order of the sections. For the module name and instance name, the specifications for Slot.DefaultModule or Slot.DefaultName apply. The number of default assignments must not exceed the upper digit. The variable addressed by a Slot_Multi section must be of type POINTER TO <INTERFACE> . Each input variable of type integer can be addressed by Var_Count only once. (This also includes InstRef_Multi.Var_Count and VarArray.Var_Count ). Example SEC Slot\n SEC Slot_Multi : subs\n Variable := pSubs;\n Var_Count := uiArraySize;\n Role := TL.Role;\n Cardinality := [2 .. 17];\n Type := SUBMODULE;\n RegularExpressionParameterId := Param_RegEx_Ref;\n SEC Default_Allocation : def1\n Module_Name := Sub1;\n Instance_Name := Submodule;\n END_SEC\n Name := TL.Input1_Name;\n Desc := TL.Input1_Desc;\n END_SEC\nEND_SEC Among other declarations the declaration part of the function block must contain: uiArraySize: UINT; pSubs: POINTER TO ITestModule . In the example, a slot is defined that holds at least 2, but at most 17 subinstances. An array will be created for the subinstances and pSubs points to it. When adding the instance the submodule with name Submodule of type Sub1 will be added automatically to the slot. " }, 
{ "title" : "Section: SourceTemplate ", 
"url" : "ac_module_fb_sec_copyfb.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: SourceTemplate ", 
"snippet" : "SourceTemplate The subsections of section SourceTemplate defines the function blocks to be copied into the project. In the module editor the here-defined function blocks get listed. There you can activate or deactivate the copying. See also SourceTemplate SEC std.SourceTemplate SEC SourceFB : <Ident...", 
"body" : "SourceTemplate The subsections of section SourceTemplate defines the function blocks to be copied into the project. In the module editor the here-defined function blocks get listed. There you can activate or deactivate the copying. See also SourceTemplate SEC std.SourceTemplate\n SEC SourceFB : <Identifier> \/\/ optional: no\n SourceType := <FunctionBlock>; \/\/ optional: no, type: InstancePath\n Variable := <variable name>; \/\/ optional: no, type: InstancePath\n Default := TRUE\/FALSE; \/\/ optional: yes, type: Bool Flag\n IsMandatory := TRUE\/FALSE; \/\/ optional: yes, type: Bool Flag\n FBVariable := <variable name>; \/\/ optional: yes, type: InstancePath\n DestinationType := <default name>; \/\/ optional: yes, Type: String\/Literal\n END_SEC\nEND_SEC Details regarding the syntax of definition types are described in the section Module Declaration . Specification: The Identifier is used in the module editor. It defines the name of the copied function block if DestinationType is not defined. SourceType defines the function block to be copied. Variable defines an input variable of the module function block. It must be a pointer to a basic class of the copied function or an interface, which is implemented by the function block to be copied. Default defines if the function block is copied by default for this module. If the definition is missing, TRUE is set. This option can be adjusted in the module editor. If IsMandatory is set to TRUE , the user cannot change the IsToCopy option in the module editor. FBVariable defines an input variable of the function block to be copied. The input variable is then instantiated with the module instance. The type of the input is a pointer to a basis type of the module FB or a pointer to the interface of the module FB. DestinationType defines a standard name for the copied function block. If the definition is missing the following naming convention is used: <Name of the module instance>_<Identifier>[_<consecutive number>]. The specified SourceTemplates are copied to the AC_SourceTemplate folder. They are instantiated and initialized by the assigned module FB. SourceTemplates, once created, can be edited and will not be overwritten by renewed generator runs. SourceTemplates, which are no longer required, get renamed (with the <_unused > suffix) and moved to the <UnusedSourceTemplates> folder. Example SEC std.SourceTemplate\n SEC SourceFB : ID_ConnectSwitches\n SourceType := ConnectSwitches;\n Variable := itfConnect;\n FBVariable := pBuilding;\n Default := TRUE;\n IsMandatory := FALSE;\n DestinationType := 'TypeInModuleDescription';\n END_SEC\nEND_SEC " }, 
{ "title" : "Section: Visu ", 
"url" : "ac_module_fb_sec_visu.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: Visu ", 
"snippet" : "Visu SEC Visu \/\/optional: yes, modifier: [UPDATE] Toplevel_Tab; \/\/optional: yes, type: bool Embedded := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList Embedded_Proxy := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList Page =: [<visu1>, <visu2>,...]; \/\/optional: yes, type: Vis...", 
"body" : "Visu SEC Visu \/\/optional: yes, modifier: [UPDATE]\n Toplevel_Tab; \/\/optional: yes, type: bool\n Embedded := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList\n Embedded_Proxy := [%PAGE_VISU%, <visu1>,...]; \/\/optional: yes, type: VisuList\n Page =: [<visu1>, <visu2>,...]; \/\/optional: yes, type: VisuList\n\n SEC DefaultEmbeddings \/\/optional: yes\n SEC Embedding : <visu identifier> \/\/optional: yes, modifier: [HIDE, UPDATE]\n VisuName := <visu name>; \/\/optional: no, type: literal\n Target := <target name>; \/\/optional: yes, type: literal\n ProxyVisuName := <visu name>; \/\/optional: yes, type: literal\n LinkId := <linkID>; \/\/optional: yes, type: literal\n END_SEC\n END_SEC\n\n SEC Toplevel_Tab_Hotkey \/\/optional: yes\n Hotkey := <keycode>; \/\/optional: no, type: literal\n Modifiers := <modifier>; \/\/optional: yes, modifier: [SHIFT, CONTROL, ALT]\n END_SEC\n\nEND_SEC Details regarding the syntax of definition types are described in the section Module Declaration . Specification: Toplevel_Tab defines if the check box Create top-level tab in the HMI editor is activated or deactivated by default. Page defines a list of available visualization objects for the module. Embedded defines a list of available visualization objects of the submodule that will be embedded in other visualization screens. Using the placeholder %PAGE_VISU% instead of the visualization name allows that generated visualization screens optionally can be embedded in other screens. Embedded_Proxy defines a list of available visualization objects of the module. The list is only used if a decoupled module is inserted in a decoupled slot and if it is not created below the controller of its father module instance (as a proxy). For modules, which import another module, the placeholder %NONE% can be used instead of the visualization name. This effects that the imported visualizations are hidden. This approach is possible for the list of visualization screens as well as for embedded (proxy-)visualization screens. Section: DefaultEmbeddings : This section serves for the specification of default embeddings, which then will appear as a pre-configuration on the HMI tab of a submodule (similar to section \"Default_Allocation\", see Section: Slots ). The desired default embeddings are to be described in subsections Embedding . Requirement: The specified visualization object and the proxy must be available in the list of possible embeddings for the module (see above: Embedded and Embedded_Proxy ). Section: Toplevel_Tab_Hotkey : This section defines a hotkey as default setting for the toplevel page. Keyboard shortcuts must not be used more than once. This setting can be adjusted in the module editor on the HMI tab. Example SEC Visu\n Toplevel_Tab ;\n Page := [VISU_CNC_Machine_1, VISU_CNC_Machine_2];\n Embedded := [%PAGE_VISU%];\n SEC DefaultEmbeddings\n SEC Embedding : No1\n VisuName := SubModule_Emb;\n Target := '..\/..\/TopLevel_2';\n END_SEC\n SEC Embedding : No2\n VisuName := SubModule_Emb_2;\n \/\/ProxyVisuName := SubModule_Emb_1;\n Target := '';\/\/ leave empty for next ancestor\n END_SEC\n END_SEC\n SEC Toplevel_Tab_Hotkey\n Hotkey := T;\n Modifiers := SHIFT | CONTROL;\n END_SEC\nEND_SEC The visualization name is the name of the respective visualization object (not case sensitive). The visualization object must be in the same hierarchical level as the module function block. Rules for the interface of visualization objects: All visualization objects and embedded visualization objects can have a VAR_IN_OUT variable with the name inst , which can be of the type of the module function block or of a base class. The variable name is not case sensitive. VAR_IN_OUT   inst : <MODULE_FB> ; END_VAR As an alternative to the option described here with VAR_IN_OUT, a VAR_INPUT variable can also be used. This variable must meet the following requirements: Name: inst Type: Interface which the module function block implements Embedded visualization objects can have two additional variables (the variable names are not case sensitive): VAR_INPUT paVisuFB : POINTER TO POINTER TO AC_Visu_Base ; iOwnFrameIndex : INT ; END_VAR These variables must be defined together; it is not allowed to define one without the other. These two variables give embedded visualizations the ability to switch the central frame in the top-level visualization. paVisuFB is an array of pointers on AC_Visu_Base instances . Use the global visualization variable CURRENTCLIENTID to access the correct instance of the current client. The frame switching is performed by an ST action of the form: paVisuFB[CURRENTCLIENTID]^.uiFrameIdx := iOwnFrameIndex ; iOwnFrameIndex is the index that the visualization image of the own module has in this toplevel frame. (If the own module does not define a visualization image this index is -1.) Apart from the variables mentioned above, no other VAR_INPUT, VAR_OUTPUT or VAR_INOUT variables are allowed. The AC_Visu_Base instances provide the additional function GetModuleFrameIndex . This function returns the index of the visualization screen (if present) in the top-level visualization for a module instance (see IModule in AC_Module_Base.library) . With this function, you can jump to any visualization screen in the module instance tree. To also enable the navigation within the code of a module, the environment of the module (see IModule in AC_Module_Base.library ) possesses a member, Environment.visus , which corresponds to the above-mentioned paVisuFB pointer. To be able to use the variable CURRENTCLIENTID , the library VisuGlobalClientManager (category \"Intern|Visu\") must be added to the project. The first visualization will be used as the default setting. " }, 
{ "title" : "Section: Trend ", 
"url" : "ac_module_fb_sec_trend.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: Trend ", 
"snippet" : "Trend SEC tre.Trend \/\/optional: yes, modifier: [UPDATE] SEC TrendRecording : <CFC trend identifier> \/\/optional: yes, modifier: [UPDATE] Task := <trend task> \/\/optional: yes, type: TimeLiteral CycleTime := <time value> \/\/optional: yes, type: TimeLiteral LimitType := <limit type> \/\/optional: yes, type...", 
"body" : "Trend SEC tre.Trend \/\/optional: yes, modifier: [UPDATE]\n SEC TrendRecording : <CFC trend identifier> \/\/optional: yes, modifier: [UPDATE]\n Task := <trend task> \/\/optional: yes, type: TimeLiteral\n CycleTime := <time value> \/\/optional: yes, type: TimeLiteral\n LimitType := <limit type> \/\/optional: yes, type: FileLimitType\n LimitMaximum := <max bytes> \/\/optional: yes, type: Literal\n RecordCondition \/\/optional: yes, type: InstanceAccess\n SEC Visu \/\/optional: yes, modifier: [UPDATE]\n VisuPlaceholder \/\/optional: yes, type: StringLiteral\n VisuTemplate := <visu template> \/\/optional: yes, type: StringLiteral\n Target := <path module instance \/\/optional: yes, type: StringLiteral\n END_SEC\n END_SEC\n\n SEC TrendVariable : <variable identifier> \/\/optional: yes, modifier: [UPDATE]\n Variable := <variable name> \/\/optional: yes, type: InstanceAccess\n TrendRecording := <recording name> \/\/optional: no, type: : Id)\n Description := <tooltip> \/\/optional: yes, type: TextRef\n Color := <graph color> \/\/optional: yes, type: Literal\n GraphType := <graph type> \/\/optional: yes, type: GraphType\n LineWidth := <width> \/\/optional: yes, type: Literal\n LineStyle := <line style> \/\/optional: yes, type: LineStyle\n SEC Warning : MIN\/MAX \/\/optional: yes, modifier: [UPDATE]\n Limit := <limit value> \/\/optional: no, type: Literal\n Color := <limit color> \/\/optional: yes, type: Literal\n END_SEC\n END_SEC\nEND_SEC Details regarding the syntax of definition types are described in the section Module Declaration . Specification: Task : Defines the task for the trend recording. If no task is defined, the task, automatically created by the visu trend will be used. CycleTime : Cycle time of the trend recording LimitType : Type of the limitation of the recorded trend. LimitMaximum : Maximum size of the trend recording in KB (only with LimitType ==FileLimit). RecordCondition : Recording condition. The referenced variable must be of type BOOL. VisuPlaceholder : Placeholder, replaced by the generated trend visualization. VisuTemplate : Template for the visu to be created. The template must have a placeholder Trend_Placeholder . It can hold controls with the following identifier: TrendLegend -> type: Legend TrendTimeRangeSelector -> type: Time Range Picker TrendDateRangeSelector -> Type: Date Range Picker Target : Relative path to the module instance, in which the visualization will be embedded. Variable : Variable to be recorded. TrendRecording : TrendRecording object the variable belongs to. Description : Text list entry, which will be displayed for the variable as tooltip. Color : Colors of the graph of the variable as ARGB color code GraphType : Type of the graph LineWithPoints : Lines with points Cross : Crosses StepWithPoints : Steps with points Point : Points Lines : Lines Step : Steps LinesWithCrosses : Lines with crosses \\\\ StepWithCrosses : Steps with crosses LineWidth : Width of the drawn line. Value range: 1 to 255. LineStyle : Line style Solid : Solid Dashed : Dashed Dotted : Dotted DashDotted : Dash dotted DashDotDotted : Dash dot dotted Warning : This subsection must have the target MAX or MIN . Depending on the target the overrun or underrun will trigger the warning. Limit : Begin of the critical range. Color : Color for the critical range as ARGB color code Example SEC tre.Trend\n SEC TrendRecording : TrendSensor\n SEC Visu\n VisuPlaceholder := 'TrendPlaceholder_TrendSensor';\n VisuTemplate := 'AC_Trend.GenTrend_VisuTemplate';\n END_SEC\n CycleTime := t#5s;\n LimitType := Records;\n LimitMaximum := 452;\n END_SEC\n SEC TrendVariable : Value\n Variable := value;\n TrendRecording := TrendSensor;\n Color := 16#FF00FF00;\n SEC Warning : MIN\n Limit := -5;\n Color := 16#FF101020;\n END_SEC\n GraphType := LinesWithCrosses;\n LineWidth := 3;\n END_SEC\nEND_SEC " }, 
{ "title" : "Section: Proxies ", 
"url" : "ac_module_fb_sec_proxies.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: Proxies ", 
"snippet" : "Proxies The section Proxies defines a function block which implements the proxy. A proxy serves for data exchange of modules of different application. The instance of the proxy FB represents the module instance in a remote application. SEC Proxies \/\/optional: yes, modifier: [UPDATE] SEC Proxy : <ide...", 
"body" : "Proxies The section Proxies defines a function block which implements the proxy. A proxy serves for data exchange of modules of different application. The instance of the proxy FB represents the module instance in a remote application. SEC Proxies \/\/optional: yes, modifier: [UPDATE]\n SEC Proxy : <identifier> \/\/optional: yes, modifier [UPDATE]\n FB := <FB name>; \/\/optional: no, type: QID\n SEC MirrorVar : <identifier> \/\/optional: yes, modifier [UPDATE])\n Variable := <variable name>; \/\/optional: no, type: VarPath\n END_SEC\n SEC ProxyParameter : <target> \/\/ optional: yes, modifier [UPDATE]\n Variable := <InstancePath>; \/\/ optional: no, type: VarPath\n END_SEC\n END_SEC\nEND_SEC Details regarding the syntax of definition types are described in the section Module Declaration . Specification: The function block must derive from IBaseInstance . The function block must have a method SetProxyIdentification with the following signature, which is not included in the Interface IBaseInstance : SetProxyIdentification(pbyName : POINTER TO BYTE, udiComAddr : UDINT, udiLocalComAddr : UDINT, pEnvironment : MEnv) The passed instance name and the set address must be returned from the properties InstanceName , ComAddress , and LocalComAddress . The function block must not derive from IModule . The section MirrorVar allows to mirror a variable of a module instances to its proxy instances. For this the instance path of the variable has to be declared in the definition Variable , which has to be stated in form of a relative (to the module instance FB) path. The following rules apply to the specified variable of the module instance FB: The variable has to be part of the module instance FB's Vars, Inputs or Outputs. It must be defined in the module FB as well as in the proxy FB It must be from the same type in both FBs It must have a primitive type; thus no pointers, interfaces or structs as a whole are allowed for mirroring, but only simple types (numeric, STRING, TIME, etc.) If the specified variables meet these conditions, they are automatically transferred as part of the RMP without the user having to worry about the transfer any further. The section ProxyParameter allows to define parameter for the proxy. The following points should be taken into account: The target of the ProxyParameter must correspond to a parameter target of the module The variable of the proxy module must match the type of the variable used for the module parameter. Only primitive types and enumerations are allowed The proxy parameters are set once to the value configured in the module instance during the initialization phase of the respective application. While the application is running, these variables are not mirrored in the proxies The name of the function block can be qualified with a namespace path. Example SEC Proxies\n SEC Proxy ProxyFB1\n FB := ProxyModule1;\n SEC MirrorVar : diInput\n Variable := diInput;\n END_SEC\n SEC ProxyParameter : InParam1\n Variable := TL.Input1_Name;\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "Section: VarArrays ", 
"url" : "ac_module_fb_sec_vararray.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: VarArrays ", 
"snippet" : "VarArrays The parameter VarArrays allows to create arrays with configurable size. SEC VarArrays \/\/optional: yes, modifier: [UPDATE]] SEC VarArray : <slot identifier> \/\/optional: yes, modifier [] Variable := <variable name>; \/\/optional: no, type: InstancePath Var_Count := <variable count>; \/\/optional...", 
"body" : "VarArrays The parameter VarArrays allows to create arrays with configurable size. SEC VarArrays \/\/optional: yes, modifier: [UPDATE]]\n SEC VarArray : <slot identifier> \/\/optional: yes, modifier []\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable count>; \/\/optional: no, type: InstancePath\n Inst_Name := <instance name>; \/\/optional: yes, type: StringLiteral\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n Var_Decl_Flags := <Flag1> | <Flag2> | ... ; \/\/optional: yes, type: Flags\n END_SEC\nEND_SEC Details regarding the syntax of definition types are described in the section Module Declaration . Specification: The definition Variable is an input instance path relative to the module function block. The data type is POINTER TO <ELEMTYPE> . <ELEMTYPE> can be any data type. The target of a section VarArray must identify the variable array uniquely. Var_Count defines the input instance path of an integer Variable of the module function block. To be available in the editor for configuration this variable must be defined as a parameter. Alternatively the variable Var_Count of Slot_Multi or InstRef_Multi can be used for defining this variable. Multiple VarArrays can use the same Var_Count variable. If the array size is 0, no array will be generated and the pointer of the array will be set to 0. Inst_Name defines the name of the created array variable. The placeholder %Instancename% and %VariablePath% (upper or lower case spelling is not relevant) will be replaced by the instance name of the module instance resp. the instance path of the pointer variable. Points will be replaced by underlines. If the definition is omitted the default value AC_ARRAY_%VariablePath% . is used. An error will be created if two different VarArrays of a module have the same Inst_Name , which does not include the placeholder %VariablePath% . Pragmas contains a list of compiler pragmas, which will be inserted before the generated array variable. Var_Decl_Flags can be used to specify the variable type of the created array. Possible flags are NONE , RETAIN , and PERSISTENT . These flags are added to the variable section VAR_INPUT , in which the array is created. (example: for the flag RETAIN , VAR_INPUT RETAIN ). Example SEC VAR_ARRAYS\n SEC VAR_ARRAY : NameList\n Variable := psNameList;\n Var_Count := uiArraySize;\n END_SEC\n ...\n SEC PARAM : ArraySize\n Variable := uiArraySize;\n Name := TL.ArraySize_Name;\n Desc := TL.ArraySize_Desc;\n END_SEC\nEND_SEC Among other declarations the declaration part of the function block must contain: uiArraySize: UINT := 7; psNameList: POINTER TO STRING; . " }, 
{ "title" : "Section: Constraints ", 
"url" : "ac_module_fb_sec_constraints.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: Constraints ", 
"snippet" : "Constraints This special section allows to check if each module instance is referenced at least once. SEC Constraints \/\/optional: yes, modifier: [UPDATE] Referenced_By := <interface name>; \/\/optional: yes, type: QID) Referenced_Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinali...", 
"body" : "Constraints This special section allows to check if each module instance is referenced at least once. SEC Constraints \/\/optional: yes, modifier: [UPDATE]\n Referenced_By := <interface name>; \/\/optional: yes, type: QID)\n Referenced_Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\nEND_SEC Details regarding the syntax of definition types are described in the section Module Declaration . Specification: The parameter Referenced_By serves to check if the module instances are referenced from other module instances. The value of ReferencedBy must be an interface that derives from IModule . If it doesn't matter what type the referencing instance is, IModule can be specified here. Referenced_Cardinality defines how often this module has to be referenced. If the number of references is not in this range, an error is produced on scan of the standard generator. Example SEC Constraints\n Referenced_By := ISpecificModule;\n Referenced_Cardinality := [1 .. 3];\nEND_SEC " }, 
{ "title" : "Section: InstRefs ", 
"url" : "ac_module_fb_sec_instrefs.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: InstRefs ", 
"snippet" : "InstRefs The section InstRefs defines references to FB instances or structure instances. SEC InstRefs \/\/optional: yes, modifier: [UPDATE] SEC InstRef : <identifier> \/\/target: yes, optional: yes, modifier [HIDE,UPDATE] Variable := <variable name>; \/\/optional: no, type: InstancePath Desc := <descripti...", 
"body" : "InstRefs The section InstRefs defines references to FB instances or structure instances. SEC InstRefs \/\/optional: yes, modifier: [UPDATE]\n SEC InstRef : <identifier> \/\/target: yes, optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Desc := <description>; \/\/optional: no, type: text\n Optional := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n END_SEC\n...\n SEC InstRef_Multi : <identifier> \/\/optional: yes, modifier [HIDE,UPDATE]\n Variable := <variable name>; \/\/optional: no, type: InstancePath\n Var_Count := <variable for count>; \/\/optional: no, type: InstancePath\n Desc := <description>; \/\/optional: no, type: text\n Cardinality := [<minimum> .. <maximum>]; \/\/optional: no, type: Cardinality\n END_SEC\nEND_SEC Details regarding the syntax of definition types are described in the section Module Declaration . Specification: Inst_Ref.Variable defines the input instance path of a variable of type POINTER TO <T> or of type <interface> . ( <T> is any structure or FB type) InstRef_Multi.Variable defines the input instance path of type POINTER TO POINTER TO <T> or of type POINTER TO <interface> . ( <T> is any structure or FB type) Two different InstRef or InstRef-Multi entries must not use the same variable. The target must uniquely identify the instance reference. This means that there must not exist two different instance reference declarations (section InstRef and InstRef_Multi ) with the same target (upper or lower case spelling is not relevant). The input integer variable defined by Var_Count can only be used once in all VarCounts of Slot_Multi or InstRef_Multi . Only integer variables defined by Var_Count of VarArray can be used in parallel to Var_Counts of Slot_Multi or InstRef_Multi . Example SEC InstRef_Multi : Elements\n Variable := piElems ;\n Var_Count := uiArraySize ;\n Desc := TL.Elems_Desc ;\n Cardinality := [1 .. 10] ;\nEND_SEC Among other declarations the declaration part of the function block must contain: uiArraySize : UINT; piElems : POINTER TO Interface; piElems points to a globally created, correctly initialized ARRAY[0..uiArraySize-1] OF interface or OF POINTER TO <T> , which points to the individual instances. As a result, the i-th object can be accessed by means of piElems[i] . " }, 
{ "title" : "Section: mse.Sequence ", 
"url" : "ac_module_fb_sec_sequence.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: mse.Sequence ", 
"snippet" : "mse.Sequence This section determines the definitions of the sequence editor. The section must be present in the module declaration, in order that the editor of the modules offers the additional tab Sequence Editor . SEC mse.Sequence \/\/optional: yes, modifier: [UPDATE] Root := TRUE\/FALSE; \/\/optional:...", 
"body" : "mse.Sequence This section determines the definitions of the sequence editor. The section must be present in the module declaration, in order that the editor of the modules offers the additional tab Sequence Editor . SEC mse.Sequence \/\/optional: yes, modifier: [UPDATE]\n Root := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Step := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Parallel := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n Branch := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n VisibleParams := [<visparam1>, <visparam2>,...]; \/\/optional: yes, type: ID-list\n VisibleIOs := [<visIO1>, <visIO2>,...]; \/\/optional: yes, type: ID-list\n VisibleRefs := [<visref1>, <visref2>,...]; \/\/optional: yes, type: ID-list\n AConnectionColor := [<itfname>]; \/\/optional: yes, type: ID-list\n BConnectionColor := [<itfname>]; \/\/optional: yes, type: ID-list\n OnlineActiveVar := <xActive>; \/\/optional: yes, type: ID\n OnlineBreakpointVar := <xBreakpoint>; \/\/optional: yes, type: ID\n OnlineBreakpointActiveVar := <xAvtiveBreakpoint>; \/\/optional: yes, type: ID\n OnlineWatchVars := [<variable1>, <variable2>,...]; \/\/optional: yes\nEND_SEC Details regarding the syntax of definition types are described in the section Module Declaration . Specification: Only one of the definitions Root , Step , Parallel , or Branch can be set to TRUE for a module. Depending on this definition, the module is represented in the sequence editor as one of the following sequence elements: Root: If the sequence is defined as Root , the editor of the module instance provides the additional tab Sequence Editor . For all other sequences no sequence editor is displayed. The width of the box can be changed in the options. Step: This element is similar to the Root element, but does not enable the additional tab Sequence Editor . The box is used to display and adjust certain properties of the module, which are defined in its mse.Sequence section. Parallel: A parallel sequence is displayed with a circle below the box. The box is used to display and adjust certain properties of the module, which are defined in its mse.Sequence section. Branch: A tilted square below the box indicates a branch. The box is used to display and adjust certain properties of the module, which are defined in its mse.Sequence section. VisibleParams defines the parameters that are available in the sequence element box. VisibleIOs defines the IOs that are available in the sequence element box. VisibleRefs defines the references that are available in the sequence element box. AConnectionColor : The connection lines between the module instances of the assigned slot are drawn in the color of the A connection . This can be set in the options of the sequence editor. BConnectionColor : The connection lines between the module instances of the assigned slot are drawn in the color of the B connection . This can be set in the options of the sequence editor. OnlineActiveVar : This parameter can be assigned a boolean variable, which must be declared in the appropriate function block or one of its basic function blocks. In online mode, if the variable is set to TRUE , the sequence step is shown in yellow. OnlineBreakpointVar : This parameter can be assigned a boolean variable, which must be declared in the according function block or one of its basic function blocks. In online mode the command Toggle Breakpoint from the context menu sets or resets a breakpoint. In addition, it sets the assigned variable to TRUE or FALSE If it is set to TRUE , the step in the sequence editor is shown with a red border. OnlineBreakpointActiveVar : This parameter can be assigned a boolean variable, which must be declared in the according function block or one of its basic function blocks. In online mode, if the variable is set to TRUE , the sequence step is shown in red. OnlineWatchVars : All variables (with simple data type) that are defined under VAR_INPUT , VAR_OUTPUT , VAR , or VAR_IN_OUT of the FB (or its basis FBs) can be used as variables here. Complex variable types (of the form FBInst.xVariable etc.) cannot be used. The variables should be entered in a comma-separated list. Example SEC mse.Sequence\n Branch;\n VisibleIOs := [xIn];\n AConnectionColor := [itfSequenceTrue];\n BConnectionColor := [itfSequenceFalse];\n OnlineActiveVar := xActive;\n OnlineBreakpointVar := xBreakpoint;\n OnlineBreakpointActiveVar := xBreakpointActive;\n OnlineWatchVars := [iPartTimeElapsed];\nEND_SEC " }, 
{ "title" : "Section: Decoupled ", 
"url" : "ac_module_fb_sec_decoupled.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: Decoupled ", 
"snippet" : "Decoupled This section defines \"decoupled modules\". These are modules with the properties of toplevel modules, but they can be inserted also as submodules into specific slots ( Type:= DECOUPLED ) of other modules. Modules cannot be \"toplevel\" and \"decoupled\" at the same time. \"Decoupled modules\" are...", 
"body" : "Decoupled This section defines \"decoupled modules\". These are modules with the properties of toplevel modules, but they can be inserted also as submodules into specific slots ( Type:= DECOUPLED ) of other modules. Modules cannot be \"toplevel\" and \"decoupled\" at the same time. \"Decoupled modules\" are generated using the section Decoupled in the module declaration. The section Decoupled is nearly identical to the section Toplevel ; however, only one of these sections is allowed in a module declaration. SEC Decoupled \/\/optional: yes, modifier: [UPDATE]\n GVL_Name := <GVL name>; \/\/optional: yes, type: literal\n Default_Application := <default application>; \/\/optional: yes, type: QID\n Default_POUPool := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n Pragmas := [<pragma1>, <pragma2>,...]; \/\/optional: yes, type: Pragmalist\n Toplevel_Insertable := <TRUE\/FALSE>; \/\/optional: yes, type: BoolFlag\n SEC Standard_Task : <task name> \/\/optional: yes, modifier: [HIDE,UPDATE]\n Name := <task name>; \/\/optional: no, type: ID\n Desc := <task description>; \/\/optional: no, type: Text)\n Flags:= <flag>; \/\/optional: no, type: StdTaskFlags)\n END_SEC\n SEC Custom_Task : <task name> \/\/optional: yes, modifier: [UPDATE]\n Priority := <priority>; \/\/optional: no, type: Subrange(0 .. 31)\n Interval := <interval>; \/\/optional: no, type: TimeLiteral)\n Flags:= <flag>; \/\/optional: no, type: CustomTaskFlags)\n END_SEC\nEND_SEC Details regarding the syntax of definition types are described in the chapter for module declaration. Specification: The specification of the section Decoupled corresponds to the description of the section Toplevel . In addition, the following parameters can be defined: Toplevel_Insertable defines whether a \"decoupled submodule\" can also be inserted toplevel like a toplevel module. Note: A \"decoupled module\" should define and implement a respective proxy. The proxy should implement the same interface as the \"decoupled module\". If the parent module instance lies under another controller as the \"decoupled\" module instance, then the \"decoupled\" module instance can still be inserted into this slot via its proxy. See also Module Declaration Section: Toplevel " }, 
{ "title" : "Section: MacroModule ", 
"url" : "ac_module_fb_sec_macromodule.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: MacroModule ", 
"snippet" : "MacroModule This section describes the parameters for the MacroModule. The section is created automatically when you generate a macro module. As an alternative, you can insert the section into a module declaration manually or edit an automatically generated section. SEC MacroModule \/\/optional: yes, ...", 
"body" : "MacroModule This section describes the parameters for the MacroModule. The section is created automatically when you generate a macro module. As an alternative, you can insert the section into a module declaration manually or edit an automatically generated section. SEC MacroModule \/\/optional: yes, modifier: None\n SEC Rootmodule : <identifier> \/\/optional: no, modifier: None\n SEC MacroParameter : <identifier> \/\/optional: yes, modifier: None\n Local_ParameterID := <parameter ID>; \/\/optional: no, type: ID\n New_Name := <parameter name>; \/\/optional: no, type: text\n New_Desc := <parameter description>; \/\/optional: no, type: text\n END_SEC\n SEC MacroIO : <identifier> \/\/optional: yes, modifier: None\n Local_IOID := <IO ID>; \/\/optional: no, type: ID\n New_Name := <IO name>; \/\/optional: yes, type: text\n New_Desc := <IO description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroSlot : <identifier> \/\/optional: yes, modifier: None\n Local_SlotID := <slot ID>; \/\/optional: no, type: ID\n New_Role := <role name>; \/\/optional: yes, type: text\n END_SEC\n SEC Default_Allocation \/\/optional: no, modifier: None\n Module_Name := <module name>; \/\/optional: no, type: QID\n SEC VisuEmbeddings \/\/optional: yes, modifier: None\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <identifier> \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: no, type: ID\n ProxyVisuName := <proxy visu ID>; \/\/optional: no, type: ID\n Target := <target ID>; \/\/optional: yes, type: ID\n LinkId := <linke ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: yes, type: ID\n TopLevelTab := <top level tab>; \/\/optional: yes, type: ID\/Bool\n END_SEC\n SEC IOMappings : <identifier> \/\/optional: no, modifier: None\n SEC Mapping : <identifier> \/\/optional: yes, modifier: None\n NoMapping := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression>; \/\/optional: yes, type: ID\/ST expression\n ModuleConnection := <module connection>; \/\/optional: yes, type: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters : <identifier> \/\/optional: yes, modifier: None\n SEC Param : <identifier> \/\/optional: yes, modifier: None\n Value := <value ID>; \/\/optional: no, type: ID\n END_SEC\n END_SEC\n END_SEC\n END_SEC\n SEC Submodule : <identifier> \/\/optional: yes, modifier: None\n Parent_Instance := <instance ID>; \/\/optional: no, type: ID\n Parent_Slot := <slot ID>; \/\/optional: no, type: ID\n SEC MacroParameter : <identifier> \/\/optional: yes, modifier: None\n Local_ParameterID := <parameter ID>; \/\/optional: no, type: ID\n New_Name := <parameter name>; \/\/optional: yes, type: text\n New_Desc := <parameter description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroIO : <identifier> \/\/optional: yes, modifier: None\n Local_IOID := <IO Id>; \/\/optional: no, type: ID\n New_Name := <IO name>; \/\/optional: yes, type: text\n New_Desc := <IO description>; \/\/optional: yes, type: text\n END_SEC\n SEC MacroSlot : <identifier> \/\/optional: yes, modifier: None\n Local_SlotID := <slot ID>; \/\/optional: no, type: ID\n New_Role := <role name>; \/\/optional: yes, type: text\n END_SEC\n SEC Default_Allocation \/\/optional: no, modifier: None\n Module_Name := <module name>; \/\/optional: no, type: QID\n Instance_Name := <instance name>; \/\/optional: no, type: ID\n SEC VisuEmbeddings \/\/optional: no, modifier: None\n Empty := TRUE\/FALSE; \/\/optional: yes, type: BoolFlag\n SEC Embedding : <identifier> \/\/optional: yes, modifier: None\n VisuName := <visu ID> \/\/optional: no, type: ID\n ProxyVisuName := <proxy visu ID> \/\/optional: no, type: ID\n Target := <target ID>; \/\/optional: yes, type: ID\n LinkId := <link ID>; \/\/optional: yes, type: ID\n END_SEC\n END_SEC\n SEC PageVisu \/\/optional: yes, modifier: None\n VisuName := <visu ID>; \/\/optional: yes, type: ID\n TopLevelTap := <top level tab>; \/\/optional: yes, type: ID\/Bool\n END_SEC\n SEC IOMappings : <identifier> \/\/optional: yes, modifier: None\n SEC Mapping : <identifier> \/\/optional: yes, modifier: None\n NoMapping := TRUE\/FALSE \/\/optional: yes, type: BoolFlag\n STExpression := <ST expression> \/\/optional: yes, type: ID\/ST expression\n ModuleConnection := <module connection> \/\/optional: yes, type: ID\/ST expression\n END_SEC\n END_SEC\n SEC Parameters \/\/optional: yes, modifier: None\n SEC Param : <identifier> \/\/optional: yes, modifier: None\n Value := <value>; \/\/optional: no, type: ID\n END_SEC\n END_SEC\n END_SEC\n END_SEC\n SEC Reference : <identifier> \/\/optional: yes, modifier: None\n Parent_Instance := <instance ID>; \/\/optional: no, type: ID\n Parent_Slot := <slot ID>; \/\/optional: no, type: ID\n Referenced_Instance := <instance ID>; \/\/optional: no, type: ID\n END_SEC\nEND_SEC Details regarding the syntax of definition types are described in the section Module Declaration . Specification: MacroModule : If this section is defined, then no other section is allowed to appear within the entire module declaration except the section MetaData . Each module declaration with this section is identified clearly as type MacroModule. Another section MacroModule is not allowed within a module declaration. Rootmodule : Indicates that the following subsections describe the root submodule, which should be 1) the root of this type MacroModule and 2) inserted as the top parent of all other submodule of the type MacroModule. Submodule : Indicates that the following subsections describe a submodule, which should be inserted under the root submodule in a subtree for the type MacroModule. MacroParameter : If this kind of subsection is used in a section Submodule or Root , then it can be indicated that a specific parameter of the defined submodule (or root) should itself occur as a parameter of the macro module. For this, the target of the section MacroParameter is used as a new parameter ID for the macro module parameter. The parameter of the given submodule (or root) is then defined by Local_ParameterID . In addition, textlist entries can be created using the definitions of New_Name and New_Desc . These entries are used for the name and description of the new macro module parameter instead of that of the submodule or root parameter. All defined targets of all sections MacroParameter within an entire macro module must be clear to ensure unique parameters IDs for all macro module parameters. MacroIO : If this kind of subsection is used in the section Submodule or Root , then it can be indicated that a specific I\/O of the defined submodule (or root) should itself occur as an I\/O of the macro module. For this, the target of the section MacroIO is used as a new I\/O ID for the macro module I\/O. The I\/O of the given submodule (or root) is then defined by Local_IOID . In addition, textlist entries can be created using the definitions of New_Name and New_Desc . These entries are used for the name and description of the new macro module I\/O instead of the submodule or root I\/O. All defined targets of all sections MacroIO within an entire macro module must be clear to ensure unique I\/O IDs for all macro module I\/Os. MacroSlot : If this subsection is used in the section Submodule or Root , then it can be indicated that a specific slot of the defined submodule (or root) should itself occur as a slot of the macro module. In this way, additional module instances can be inserted below this slot of the MacroModule instance. For this, the target of the section MacroSlot is used as a new slot ID for the macro module slot. The slot of the given submodule (or root) is then defined by Local_SlotID . In addition, a text list entry can be created using the definitions New_Role . This entry is used for the role of the new macro module slot instead of that of the submodule or root slot. All defined targets of all sections MacroSlot within an entire MacroModule must be clear to ensure unique slot IDs for all MacroModule slots. Parent_Instance : Defines an ID corresponding to a target ID of a section Rootmodule or Submodule of the encompassing section MacroModule . This definition exists only within the section Submodule . It defines the parent module instance below which the submodule should be inserted. This submodule is described by the respective section Submodule of the MacroModule. Moreover, the definition Parent_Slot is also required. Parent_Slot : Defines an ID corresponding to the slot ID located under the submodule type identified by Parent_Module . The submodule of the MacroModule type described by the section Submodule is inserted below this slot. Default_Allocation : This is identical to the section of the same name under the slot declarations ( Slot and Slot_Multi ). This section defines for both the \"root module\" and the \"submodule\" which kind of submodule of the MacroModule type should be inserted for which instance configuration. The only difference is that no Instance_Name can be defined for Default_Allocation under a section Rootmodule , but rather under sections Submodule . The reason for this is that the module instances inserted as \"root module\" receive their name from the MacroModule instance and therefore cannot be entered by \"default\". Reference : Shows that the following subsections describe a module reference. A reference is generated below the module instance Parent_Instance and the slot Parent_Slot , referencing the submodule Referenced_Instance . As the Parent_Instance , this referenced instance must originate from the set of the submodule of root module instances below the same section MacroModule . The module declaration of a MacroModule type must satisfy the following conditions: It shall not use IMPLEMENTED_BY or IMPORTS in its module declaration. It must include the section MetaData and MacroModule . Otherwise, additional sections must not be used. There has to be at least one Rootmodule section below the Macro_Module section. Moreover, there must not be a second Rootmodule section. For each submodule , both the Parent_Instance and the Parent_Slot must be defined within MacroModule . This must then be defined as Local_SlotID within MacroSlot of the Parent_Instance . " }, 
{ "title" : "Section: Device Generator ", 
"url" : "ac_module_fb_sec_devicegenerator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: Device Generator ", 
"snippet" : "Device Generator The section DeviceGenerator serves to define all settings related to the Device Generator. It contains the following subsections: Subsection: Device : Definitions to add devices to the device tree Subsection: Parameter : Definitions to add or modify parameters of devices Subsection:...", 
"body" : "Device Generator The section DeviceGenerator serves to define all settings related to the Device Generator. It contains the following subsections: Subsection: Device : Definitions to add devices to the device tree Subsection: Parameter : Definitions to add or modify parameters of devices Subsection: Connect: Definitions to connect module IOs to device IOs Subsection: Wildcards : Definitions to create \"Wildcard\" devices. Subsection: Demand : Definitions to define \"demanding\" properties. Subsection: InstRefMapping : Definition to connect created devices with module InstRefs. Details regarding the syntax of definition types are described in the section Module Declaration . " }, 
{ "title" : "Subsection: Device ", 
"url" : "ac_module_fb_sec_devicegenerator_device.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: Device Generator \/ Subsection: Device ", 
"snippet" : "The Device subsection defines devices to be added by the device generator. There are several types of generated devices that are defined with the different subsections Identification , Wildcard , and FlexibleWildcard . Syntax: SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC Device : <tar...", 
"body" : "The Device subsection defines devices to be added by the device generator. There are several types of generated devices that are defined with the different subsections Identification , Wildcard , and FlexibleWildcard . Syntax: SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC Device : <target ID> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n ParentSlotIndex := <slot number>; \/\/optional: yes, type: literal\/integer\n SEC Identification \/\/optional: yes, modifier: [UPDATE]\n Type := <type number>; \/\/optional: no, type: literal\/string\n ID := <ID mumber>; \/\/optional: no, type: literal\/string\n ModuleID := <module ID>; \/\/optional: yes, type: literal\/string\n Version := <version mumber>; \/\/optional: no, type: literal\/string\n SEC SetChildName \/\/optional: yes, modifier: [UPDATE]\n Value := <child name>; \/\/optional: no, type: literal\/string\n ChildIndex := <index number>; \/\/optional: no, type: literal\/string\n END_SEC\n END_SEC\n END_SEC\n SEC ExportDevice \/\/optional: yes, modifier: [UPDATE, HIDE]\n Files :=[<filename1>, <filename2>, ...]; \/\/optional: no, type: string\n END_SEC\nEND_SEC Specification: The Device section has a target ID that uniquely identifies it among the other generated devices of a module. This ID can be used to reference this device. This is mainly done in the definition Parent of other created devices or connected I\/Os. The Parent definition specifies the desired parent device under which the created device is to be mounted. The parent device can be identified not at all (definition is optional), by its ID or by a parameter. In detail, the parent device is then determined in the following way: If no Parent is defined at all, the first matching available parent is always used, and for an empty Parent definition only searches starting from the first parent module. If no device is defined in the direct parent module itself, the history of the parent modules is tracked until there is finally a device that matches or the toplevel module is reached. In this case, its application device is then used if possible. If, in addition, a device ID or a parameter is specified as a Parent , the history of the parent devices is scanned in the same way, whereby the devices of the output module itself are now also taken into account and a possible parent device must also have the corresponding ID. If, according to the rules described above, no possible parent device can be found, an error is output during the generation check. ParentSlotIndex : Specifies the index of the slot (number) of the parent device into which the device is inserted. This is helpful when plugging is required. The Identification subsection includes the unique description of a device to be added. This creates a unique reference to this Device type. The definitions Type , ID , ModuleID , and Version of the Identification section uniquely identify a device type of a specific version. For example, an EtherCAT Master has the following definition: Type := '64'; ID := '000 0001'; Version := '3.5.1.0'; If * is defined as the version, the latest version of the device is always used. If the ModuleID definition is not used, the system is searched for devices with a DeviceIdentification, otherwise it is searched for devices with a module identification. If the defined device does not exist in the device repository, a corresponding error message is already issued during the scan process. Subsection: SetChildName with the definitions for Value and ChildIndex These options allow you to specify the name which an automatically inserted device should have. If the same name is used more than one time, then the resulting name is made unique by appending an underscore and a number. Value : Desired name of the device ChildIndex : Index of the automatically inserted device to be renamed This section offers the possibility to fill the fields with the help of the Input Assistant. To do this, place the cursor at the end of the line after Identification and press Return . Afterwards, the Input Assistant opens and offers the available channels. After you choose a device, the corresponding parameters are transferred to the module declaration. Please note that this function is only available when the end of the sub-section ( END_SEC ) has not been entered yet. The definition Files contains a list of devices that will be added to the project. These devices were manually configured and exported to a library. Example SEC Device : Buskoppler2\n SEC Identification\n Type := '65';\n ID := '2_044C2C5200110000';\n Version := '*';\n END_SEC\nEND_SEC\nSEC Device : KlemmeDigitalOutput\n Parent := Buskoppler2;\n SEC Wildcard : KlemmeTyp\n Desc := TL.WildDesc;\n END_SEC\n SEC ExportDevices\n Files := [ExtFile.BK5120_1SDO, ExtFile.BK5120_2SDO];\n END_SEC\nEND_SEC Example with parameters SEC std.DeviceGenerator\n SEC Device : CANopen_Manager\n Parent := CurrentCAN;\n SEC FlexibleIdentification\n Type := '16';\n ID := '181016';\n Version := '*';\n Maximum := 1;\n END_SEC\n END_SEC\nEND_SEC\nSEC std.Parameters\n SEC Param : CurrentCAN\n Name := TL.CurrentCAN_Name;\n Desc := TL.CurrentCAN_Desc;\n VariableType := wSTRING;\n Default := 'CANBus_0';\n END_SEC\nEND_SEC Example of defining a device name SEC std.DeviceGenerator\n\tSEC Device : EcoVario\n\t Parent := CanManager;\n\t\tSEC Identification\n\t\t Type := '18';\n\t\t ID := '1619 0001';\n\t\t Version := '*';\n\t\t SEC SetChildName : ChildDevice\n\t\t\t Value := 'ChildName';\n\t\t\t ChildIndex := 0;\n\t\t END_SEC\n\t END_SEC\n END_SEC\n SEC Parameters : EcoVario\n\t SEC AddParameter : BoolParamAdd\n\t\t ParameterID := '150';\n\t\t ParameterName := 'BoolParam';\n\t \tParameterType := 'std:BOOL';\n\t\t ChildIndex := 0;\n\t END_SEC\n\t SEC SetParameter : BoolParamAdd\n\t\t ParameterID := '150';\n\t\t\tElemPath := '';\n\t\t\tValue := 'TRUE';\n\t\t\tChildIndex := 0;\n\t\tEND_SEC\n\t\tSEC SetParameter : bVirtual\n\t\t\tParameterID := '1040';\n\t\t\tElemPath := '';\n\t\t\tConnectorID := '0';\n\t\t\tValue := 'TRUE';\n\t\t\tChildIndex := 0;\n\t\tEND_SEC\n\tEND_SEC\n SEC InstRefMapping : Axis\n\t SEC Demand\n\t Desc := TL.DescAxis;\n\t\t\tProperties := [SM_DRIVE_CAN];\n\t\tEND_SEC\n\tEND_SEC\nEND_SEC\n " }, 
{ "title" : "Subsection: Connect ", 
"url" : "ac_module_fb_sec_devicegenerator_connect.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: Device Generator \/ Subsection: Connect ", 
"snippet" : "This subsection of the section IOMapping serves to connect module IOs with specified device IOs. This mapping is done without knowing the exact IO structure of the device. For direct connections, it is assumed that the module IO and the specified device IO are compatible SEC DeviceGenerator \/\/option...", 
"body" : "This subsection of the section IOMapping serves to connect module IOs with specified device IOs. This mapping is done without knowing the exact IO structure of the device. For direct connections, it is assumed that the module IO and the specified device IO are compatible SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC IOMapping : <mapping identifier> \/\/optional: yes, modifier: [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Connect \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ElemPath := <elempath name>; \/\/optional: no, type: literal\/string\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n END_SEC\n END_SEC\nEND_SEC Specification: The section IO has a target that corresponds to the target ID of the module IO that will be connected. The module that contains the specified device connection will be searched for this target ID. If no matching module IO can be found, an error message is issued during the scan. The optional definition Parent gives the ID of the device that will be searched for the specified device IO (ParameterID). Until it is found, the device’s module and the history of the parent devices will be searched consecutively. If an appropriate device cannot be found, an error message is issued during the generation check. The section Connect contains all definitions necessary to connect a module IO to a device IO. ParameterID defines the IO channel ParameterID of the device that will be connected to. An attempt is made to find this parameter in the devices specified by the module itself. If no device is specified, an attempt is made to find the parameter in the next possible parent device. Then the parameter is connected to the module I\/O. If none of the generated devices in the module hierarchy offers the specified parameter with this ParameterID , an error is issued. ElemPath defines the sub-element of the device parameter (I\/O channel) that will be connected to the module I\/O. It is also possible to specify paths, etc. The parameter ConnectorID optionally defines the connector of the device, whose HostParameterSet contains the ParameterID . If no ConnectorID is specified, the ParameterID is searched for under the DeviceParameterSet . This section offers the possibility to fill the fields with the help of the Input Assistant. To do this, place the cursor at the end of the line after Connect and press Return . Afterwards, the Input Assistant opens and offers the available channels. After you choose a channel, the corresponding parameters are transferred to the module declaration. Please note that this function is only available when the end of the sub-section ( END_SEC ) has not been entered yet. Example SEC IOMapping: xIn\n SEC Connect\n ParameterID := '33554434';\n ElemPath := '';\n ConnectorID := '1';\n END_SEC\nEND_SEC " }, 
{ "title" : "Subsection: Demand ", 
"url" : "ac_module_fb_sec_devicegenerator_demand.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: Device Generator \/ Subsection: Demand ", 
"snippet" : "This subsection of IOMapping allows the module IOs to specify properties (example: 24V and not 230V), which should be offered by the device IOs for proper connection. The demanded properties can be assigned as \"offering\" properties to the devices IOs during generation. The assignment is stored attac...", 
"body" : "This subsection of IOMapping allows the module IOs to specify properties (example: 24V and not 230V), which should be offered by the device IOs for proper connection. The demanded properties can be assigned as \"offering\" properties to the devices IOs during generation. The assignment is stored attached to the device description file. For the automatic IO-connection of the device generator, this means that each module IO with \"demanding\" properties will scan the generated devices or wildcards of its parent modules until the a device and IO channel is found, which \"offering\" properties meets the demands SEC IOMapping : <target> \/\/optional: yes, modifier: [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Demand \/\/optional: yes, modifier: [UPDATE]\n Desc := <description>; \/\/optional: no, type: text\n Properties := [<property1>,<property2>,...]; \/\/optional: no, type: IDList\n END_SEC\nEND_SEC Specification: The subsections Demand and Connect cannot be defined simultaneously. Desc defines a (localized) description of the required connection (in a text list). Properties defines a list of properties which describe the properties required by the module IO (example: [Input24V, Digital]) It is possible to define several properties which allow to qualify the module IOs (example: module IOs which required only \"Property1\" and module IOs which required \"Property1\", \"Property2\", etc.). Parent defines the Id of the device under which the channel should be connected. For \"demanding\" IOs, wildcard devices are also allowed as possible connection devices. SEC std.DeviceGenerator\n SEC IOMapping : xOn\n SEC Demand\n Desc := TL_Rooms.Role_RoomStandard_Lights;\n Properties := [V24Output];\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "Subsection: Wildcards ", 
"url" : "ac_module_fb_sec_devicegenerator_wildcard.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: Device Generator \/ Subsection: Wildcards ", 
"snippet" : "The Wildcard subsection is used to create wildcard devices for modules that are not yet known when the module is created. The devices should then be flexible to be specified by the user before or during generation. SEC Device : <target> \/\/optional: yes, modifier [UPDATE] Parent := <target ID>; \/\/opt...", 
"body" : "The Wildcard subsection is used to create wildcard devices for modules that are not yet known when the module is created. The devices should then be flexible to be specified by the user before or during generation. SEC Device : <target> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Wildcard : <target> \/\/optional: yes, modifier: [UPDATE]\n Desc := <description>; \/\/optional: no, type: text\n END_SEC\nEND_SEC Specification: The Identification , Wildcard , and FlexibleWildcard subsections cannot be used at the same time. The target of the section Wildcard determines the type of the wildcard device. Different modules can use wildcard devices of the same type (example: \"8inputs\"). All wildcard devices of the same type are assigned to the same device. Desc defines a (localized) description of the wildcard device (in a text list). Parent defines the desired parent device. Wildcard devices are also possible here, provided they are already assigned to devices. If the device set for the wildcard device is not a compatible parent device, an error is issued during generation. Example SEC Device : KlemmeAnalogOutput\n Parent := Buskoppler2;\n SEC Wildcard : KlemmeTyp\n Desc := TL.WildDesc;\n END_SEC\nEND_SEC " }, 
{ "title" : "Subsection: Parameter ", 
"url" : "ac_module_fb_sec_devicegenerator_parameter.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: Device Generator \/ Subsection: Parameter ", 
"snippet" : "The section Parameter with the subsections SetParameter and AddParameter serves to add or modify parameters of devices. This allows to generate specific settings of devices (example: cycle time). SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC Parameters : <parameter name> \/\/optional: ye...", 
"body" : "The section Parameter with the subsections SetParameter and AddParameter serves to add or modify parameters of devices. This allows to generate specific settings of devices (example: cycle time). SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC Parameters : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n SEC SetParameter : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ElemPath := <elempath name>; \/\/optional: no, type: literal\/string\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n Value := <value name>; \/\/optional: no, type: literal\/string\n ChildIndex := <device ID>;\n Download := <boolean value> \/\/ opional: yes, type: boolean\n END_SEC\n SEC AddParameter : <parameter name> \/\/optional: yes, modifier: [UPDATE]\n ParameterID := <parameterID name>; \/\/optional: no, type: literal\/string\n ParameterName := <parameter name>; \/\/optional: no, type: literal\/string\n ParameterType := <parameter type>; \/\/optional: no, type: literal\/string\n ChannelType := <channel type>; \/\/optional: yes, type: enum\n ConnectorID := <connector ID>; \/\/optional: yes, type: literal\/string\n ChildIndex := <device ID>;\n END_SEC\n END_SEC\nEND_SEC Specification: The Parameters section has a target, with which the DeviceID of the target device is defined, whose parameter should be edited. The target device will be searched first in the devices of the module and then in their parent history. Wildcard devices or other devices are also possible. It is assumed that this devices have the corresponding parameter or that the corresponding parameter can be added. If the scan cannot find the target device a warning will be displayed. The targets of the sections SetParameter and AddParameter define the Id of the respective section but have no further use. Specification for section SetParameter : ParameterID defines the ParameterID of the parameter of the device which will be modified. ElemPath specifies the exact element of the parameter which will be changed. The parameter ConnectorID optionally defines the connector of the device, whose HostParemeterSet contains the parameter Id. If no ConnectorID is specified, the ParameterID is searched for under the DeviceParameterSet. Value defines the value which will be assigned to the element of the specified parameter. This value must be compatible to the element type. The value can be an expression for example [paramID] + 2*MODULE_SLOT_INDEX There [paramID] defines a target ID of a parameter, so that [paramID] will be replaced by the parameter value. The MODULE_SLOT_INDEX keyword is replaced by the slot index that a module instance of the defined module type would have after insertion. If the parameter cannot be found in the target device, the generator check will create warnings. ChildIndex defines the subordinate device, under which the parameter is added or set. If this subordinate device with the specific index does not exist, then a warning is generated during the generation. Download : Optional entry. If this entry has the value FALSE , then the parameter will not be downloaded to the device. This makes sense to use, for example, to disable CheckVendorId for CAN devices, for example. Specification for section AddParameter : ParameterID defines the new ID of the parameter to be added. This must be unique among the other ParameterIDs of the target device. The parameter ConnectorID optionally defines the connector of the device, whose HostParemeterSet contains the parameter Id to be added. If no connector ID is defined the Parameter ID will be added in DeviceParameterSet. ParameterName defines the name of the parameter added to the target device. ParameterType defines the type of the parameter added to the target device. This type is named according to IEC type notation with type prefix. Therefore example: std:bool will create a boolean parameter. If the parameter cannot be added, the generator check will create warnings. ChannelType defines the type of the channel. Possible values are NONE , INPUT , OUTPUT , and OUTPUTREADONLY . ChildIndex defines the subordinate device, under which the parameter is added or set. If this subordinate device with the specific index does not exist, then a warning is generated during the generation. Both sections AddParameter and SetParameter can be used together to add a parameter to a device and to assign a value to it at the same time. Example SEC Parameters : Buskoppler1\n SEC AddParameter : ExpertSettings\n ParameterID := '805306368';\n ConnectorID := '1';\n ParameterName := 'ExpertSettings';\n ParameterType := 'std:int';\n ChannelType := OUTPUT;\n END_SEC\n SEC SetParameter : ExpertSettings\n ParameterID := '805306368';\n ElemPath := '';\n ConnectorID := '1';\n Value := dwParameterOffset + 2 * MODULE_SLOT_INDEX;\n END_SEC\n END_SEC " }, 
{ "title" : "Subsection: InstRefMapping ", 
"url" : "ac_module_fb_sec_devicegenerator_instrefmapping.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: Device Generator \/ Subsection: InstRefMapping ", 
"snippet" : "In the section InstRefMapping with the subsection Demand a module InstRef can be filled automatically with a FB instance created by a device. SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE] SEC InstRefMapping : <target ID> \/\/optional: yes, modifier [UPDATE] Parent := <target ID>; \/\/optional:...", 
"body" : "In the section InstRefMapping with the subsection Demand a module InstRef can be filled automatically with a FB instance created by a device. SEC DeviceGenerator \/\/optional: yes, modifier: [UPDATE]\n SEC InstRefMapping : <target ID> \/\/optional: yes, modifier [UPDATE]\n Parent := <target ID>; \/\/optional: yes, type: ID\n SEC Demand \/\/optional: yes, modifier: [UPDATE]\n Desc := <...>; \/\/optional: no, type: text\n Properties := <...>; \/\/optional: no, type: IDList\n END_SEC\n END_SEC\nEND_SEC Specification: The top section InstRefMapping is supplemented by an additional optional section Demand . The target of the top section InstRefMapping defines the ID of a module InstRef, which will be filled with the FB instance. Only single InstRefs (not InstRef_Multi) are supported, because only single FB instances of single devices can be created. Desc defines a localized description of the connection. Properties defines a list of properties which describe, for example, the FB types required by the module InstRef. More that on property can be defined so that the single module InstRefs are classified as with module IOs. Syntax [<Property1>, <Property2>,...] (example: [SoftMotionVirtualDrive, Property2] ). Parent defines the ID of the required device, which created FB instance shall be used to fill the module InstRefs. For demanding InstRefs wildcard devices as well as fix inserted devices are allowed. Example SEC std.InstRefs\n SEC InstRef : axisRef\n Variable := axis_ref;\n Desc := TL.axisref_Desc ;\n END_SEC\nEND_SEC\n\nSEC std.DeviceGenerator\n SEC Device : virtAxis\n SEC Identification\n Type := '1024';\n ID := 'FFFF 0001';\n Version := '*';\n END_SEC\n END_SEC\n SEC InstRefMapping : axisRef\n SEC Demand\n Desc := TL.axisref_Desc;\n Properties := [VirtualAxis];\n END_SEC\n END_SEC\nEND_SEC " }, 
{ "title" : "Rules for Generators ", 
"url" : "ac_module_fb_sec_devicegenerator_generating_rules.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Section: Device Generator \/ Rules for Generators ", 
"snippet" : "Rules for device generation Devices specified in top-level modules are hooked under the parent device that contains the generated application. No toplevel devices will be created. If no parent device ID is specified, the most recent matching parent device is used as the new parent object. This means...", 
"body" : "Rules for device generation Devices specified in top-level modules are hooked under the parent device that contains the generated application. No toplevel devices will be created. If no parent device ID is specified, the most recent matching parent device is used as the new parent object. This means that if a child module generates a device, this device will be added under one of the generated devices of the parent module if possible. If the direct parent module has no device at all or does not generate a device that fits under the child device, the devices of the parent–parent module are used, and so on. If there are no more generated parent devices, an attempt is made to generate into the toplevel device of the respective toplevel module. If more that one device is offered from a parent module object, the first compatible device will be used. See also: Subsection: DeviceThe name of the generated device is \"device ID + module name + device\". If this name is already used by a device an ascending number will be added. Already created devices will not be deleted by a new generation run; therefore manual adjustments of the settings will be maintained. Additional or modified parameters created by the module declaration will be assigned to the corresponding devices with each generation run. Like all objects created by the Application Composer additional devices will be marked in the device tree. If an attempt is made to modify or delete such a device, a warning will be displayed. This warning draws attention to the fact that any changes made to the device settings may be lost if, for example, the module structure is regenerated after being changed. Additional rules for device generation Child devices, which are automatically added under certain devices, are classified under the same module instance as their parent. That means, those child devices are treated as if they were defined in the module declaration, which, indeed, holds the definition of their parent device. The child devices are not created or deleted independently, but are only treated together with their parent devices. If a device brings along explicit connectors, during compatibility checks to other devices, the latters are treated as if they were implicit connectors. In other words, all connectors are used for testing the compatibility to other devices, so that finally only that connector (no matter if explicit or implicit) is used, which matches for the parent device and child device. Explicitly as connector parent object, implicitly as part of the device parent object. " }, 
{ "title" : "Alarm Generator ", 
"url" : "ac_alarmgenerator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Alarm Generator ", 
"snippet" : "The alarm generator provides the module developer with an easy way to equip existing modules with the alarm management available in CODESYS . In doing so, functionalities for the complete alarm management, as well as a corresponding visualization, are generated. The new module declaration ( alg.Alar...", 
"body" : "The alarm generator provides the module developer with an easy way to equip existing modules with the alarm management available in CODESYS . In doing so, functionalities for the complete alarm management, as well as a corresponding visualization, are generated. The new module declaration ( alg.Alarm) implements this feature. All definitions necessary for the alarm management are set in there. Creating the visualization Together with the alarm generation, an alarm visualization screen is created, which is a suggestion for an overview visualization (alarm table) of the alarms in the project. The template for this visualization is set in the alarm generator settings. If the visualization generator is active, the created or re-used visualization object is integrated as a tab in the top-level visualization. " }, 
{ "title" : "Alarm generation ", 
"url" : "ac_alarmgenerator.html#UUID-dd47c9b0-4cb3-6491-d721-bbb6aed14278_a4ecc0cda058afc0a8640e004fda36_id_4e1d8099cdf16f9cc0a8640e0073d212", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Alarm Generator \/ Alarm generation ", 
"snippet" : "Like all generators of the CODESYS Application Composer , this generator can be activated or deactivated in the Generator configuration . The generator performs the following steps: An alarm configuration object is searched for, so that it can be used for the next generation. If no alarm configurati...", 
"body" : "Like all generators of the CODESYS Application Composer , this generator can be activated or deactivated in the Generator configuration . The generator performs the following steps: An alarm configuration object is searched for, so that it can be used for the next generation. If no alarm configuration object exists, a new one is created. Under the alarm configuration object, an alarm storage object is searched for. If no alarm storage object exists, the alarm storage template is used. This template is defined in the alarm generator settings. If the option No Storage is selected no alarm storage template is used and the process is continued without alarm storage. If more than one template is found, an error message is displayed. Under the alarm configuration object is searched for alarm class objects that have the name defined in any module description under the definition alg.Alarm.SetAlarm.Class . If the corresponding alarm class objects are found, they will be used. If no corresponding alarm class is found, an attempt is made to create a new one. This requires that the alarm class template object of corresponding name exists as a template in the POU pool of the project or a referenced library, so that it can be used as an alarm class template. If no matching alarm class template object is available, an error is displayed. " }, 
{ "title" : "Section: alg.Alarm ", 
"url" : "ac_module_fb_sec_alarm.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Alarm Generator \/ Section: alg.Alarm ", 
"snippet" : "alg.Alarm The section SEC alg.Alarm describes a module alarm. A module alarm essentially corresponds to an alarm of the CODESYS alarm management that has been configured in an alarm group. However, a module alarm still contains module-specific additions. For more information, see the Module Declarat...", 
"body" : "alg.Alarm The section SEC alg.Alarm describes a module alarm. A module alarm essentially corresponds to an alarm of the CODESYS alarm management that has been configured in an alarm group. However, a module alarm still contains module-specific additions. For more information, see the Module Declaration chapter and Object: Alarm Group " }, 
{ "title" : "Specification ", 
"url" : "ac_module_fb_sec_alarm.html#UUID-e8936893-7db9-1fda-4737-bf3cf49fe064_aa4c0cec89085aac0a8640e01a3c6fe_id_355d83fb191b4801c0a864637767cb78", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Alarm Generator \/ Section: alg.Alarm \/ Specification ", 
"snippet" : "SEC alg.Alarm \/\/optional: yes, modifier: [UPDATE] SEC SetAlarm <alarm identifier> \/\/optional: yes, modifier [UPDATE] Class := <class name>; \/\/optional: no, type: ID Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry LatchVar1 := <LatchVariable1>; \/\/optional: yes, type: InstancePath Latc...", 
"body" : "SEC alg.Alarm \/\/optional: yes, modifier: [UPDATE]\n SEC SetAlarm <alarm identifier> \/\/optional: yes, modifier [UPDATE]\n Class := <class name>; \/\/optional: no, type: ID\n Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry\n LatchVar1 := <LatchVariable1>; \/\/optional: yes, type: InstancePath\n LatchVar2 := <LatchVariable2>; \/\/optional: yes, type: InstancePath\n Deactivation := <DeactivationVariable>; \/\/optional: yes, type: InstancePath\n PendingTime := <PendingTime>; \/\/optional: yes, type: LiteralOrConstant\n PendingTimeParameter := <string> \/\/optional: no, type: literal\/string\n HigherPrioAlarm := <HigherPrioAlarm_ID>; \/\/optional: yes, type: ID\n ModuleCalls := <ModuleCallFlags>; \/\/optional: yes, type: ModuleCallFlag\n SEC Messages : <alarm identifier> \/\/optional: yes, modifier: [UPDATE]\n Message := <TextlistEntry>; \/\/optional: no, type: TextListEntry\n Number := <ColumnNumber>; \/\/optional: no, type: Literal\n END_SEC\n SEC LatchVar <latch var identifier> \/\/optional: yes, modifier [UPDATE]\n LatchVar := <LatchVariable>; \/\/optional: no, type: InstancePath\n Number := <LatchVarNumber> \/\/optional: no, type: LiteralOrConstant\n END_SEC\n SEC UpperLimit \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n IncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n UpperExpression := <UpperExpression>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC LowerLimit \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n IncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n LowerExpression := <LowerExpression>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC InsideRange \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n AreaLow := <AreaLowValue>; \/\/optional: no, type: Literal\/String\n LowIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n HighIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n AreaHigh := <AreaHighValue>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC OutsideRange \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n AreaLow := <AreaLowValue>; \/\/optional: no, type: Literal\/String\n LowIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n HighIncludeBorder := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n AreaHigh := <AreaHighValue>; \/\/optional: no, type: Literal\/String\n Hyteresis := <HysteresisValue>; \/\/optional: yes, type: LiteralOrConstant\n END_SEC\n SEC Digital \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n Equal := TRUE\/FALSE; \/\/optional: no, type: FlagBool\n EqualsExpression := <Expression>; \/\/optional: no, type: Literal\/String\n END_SEC\n SEC Change \/\/optional: yes, modifier: [UPDATE]\n Expression := <Expression>; \/\/optional: no, type: Literal\/String\n END_SEC\n SEC Event \/\/optional: yes, modifier: [UPDATE]\n END_SEC\n END_SEC\nEND_SEC SEC SetAlarm The subsections of SetAlarm define all the properties that are necessary or possible for an alarm. The target of SetAlarm identifies the alarm from the other alarms in the module and is used to reference it (mainly in the definition HigherPrioAlarm ). Class Alarm class name, under which the alarm will be created. If this alarm class already exists in the application, the alarm will be created under this class. If this class does not exist, an alarm class template object is searched for, which must be present in the POUs view. If no appropriate alarm class template object is found, an error is issued when the module is scanned. Message ID (of the form TextListenName.TextListenEintragID ) of a text list entry for the alarm text The message referenced by the ID can contain the same placeholders as the text in an alarm configuration. For example placeholders such as LATCH1 or LATCH2 can be used If a specified text list entry cannot be found, a warning is issued during the scan. Corresponds to the Message setting in the Alarm Group object. LatchVar1 LatchVar2 Placeholder variables In the present case of module-specific alarms, variables can only be specified directly from the module function block (just like variables are specified in the module declaration for e.g. parameters) Corresponds to the settings Latch variable 1 \/ Latch variable 2 for placeholders <LATCH1> \/ <LATCH2> in the Alarm Group object. Deactivation Deactivation variable ( BOOL ). TRUE : Deactivates the defined alarm, where only module function block variables can be used. If the type of the variable that is entered is not BOOL , then an error is issued during the scan Corresponds to the Deactivation setting in the Alarm Group object. PendingTime Minimal pending time. Defines the amount of time before the alarm actually goes off after reaching its limits. Example: TIME#5S Corresponds to the setting Min. pending time in the Alarm Group object. PendingTimeParameter Parameter to set the minimum pending time The value which is assigned to the parameter is a string that can be interpreted as time. Or also as an expression which consists of module parameters and time literals. Example: TIME#5S 'NoVar' 'WithVar' 'WithVar - NoVar + TIME#5S' HigherPrioAlarm ID of the higher priority alarms To identify the alarm under which the present alarm should be classified, a target ID of a SetAlarm section is specified for the existing module alarms. To find the SetAlarm section with corresponding target ID, a hierarchical search is performed from the own module upwards in the parent module instances for matching IDs among the alarm declarations. If no corresponding parent alarm is found, an error is issued during the generator check Corresponds to the setting Higher prio. alarm in the Alarm Group object. ModuleCalls For module-specific alarm management, module FBs can offer specific interfaces that can be called if an module alarm occurs. The flags define in which cases this will happen. Available ModuleCallFlags : NONE : No calls will occur THIS : A call will occur for the alarms of the present module PARENTS : A call will occur to all parent modules of the present module ALL : A call will occur to all modules Module FBs that will be called by this flag must implement the IModuleAlarming interface. The call is performed by the ConsumeModuleAlarm function of this interface If the PARENTS flag was set for a toplevel module, a warning is displayed if a scan is executed (because this flags do not exist for toplevel modules). SEC Messages The subsection manage the same task as the Message parameter, but allows multiple messages for one alarm. For compatibility reasons the (old) parameter Message is still valid. The message can contain the same placeholders as the actual text in an alarm configuration. This means that also placeholders such as <LATCH1> and <LATCH2> can be used. If a specified text list entry cannot be found, a warning is issued during the scan. Messages : Alarm text in form of a text list entry (of the form TextListenName.TextListenEintragID ) Number : Column in the alarm table the message is displayed. SEC LatchVar Latch variables. Up to 10 latch variables can be defined in this section. If, in addition to this section, LatchVar1 or LatchVar2 is defined, the variable of this section will be used. LatchVar : Latch variable Number : Number to identify the latch variable. SEC UpperLimit SEC LowerLimit Alarm conditions for alarms that trigger if upper or lower boundaries are crossed. The section is allowed to occur only once below the SEC SetAlarm section. If this is not the case an error is issued during the scan. Expression : IEC expression or value that is tested. In expressions, local variables of the module FBs as well as global constants, can be used. IncludeBorder : TRUE corresponds to <= ( UpperLimit ) or >= ( LowerLimit ). FALSE corresponds to < ( UpperLimit ) or > ( LowerLimit ). UpperExpresssion , LowerExpresssion : IEC expression or value against which the Expression is tested. In expressions, local variables of the module FBs as well as global constants, can be used. Hysteresis : Alarm hysteresis in %. Corresponds to the settings Upper limit \/ Lower limit for the observation types in the Alarm group object. SEC InsideRange SEC OutsideRange Alarm conditions for alarms that trigger if an expression is in- or outside of a certain range of values. The section is allowed to occur only once below the SEC SetAlarm section. If this is not the case an error is issued during the scan. Hysteresis : Alarm hysteresis in % Expression : IEC expression or value that is tested. In expressions, local variables of the module FBs as well as global constants, can be used. AreaLow : Lower limits of the range (value or IEC expression). In expressions, local variables of the module FBs as well as global constants, can be used. LowIncludeBorder : This boolean flag determines whether the lower limit itself is included in the range of comparison (corresponds to <= ) HighIncludeBorder : This boolean flag determines whether the upper limit itself is included in the range of comparison (corresponds to >= ) AreaHigh : Upper limits of the range (value or IEC expression). In expressions, local variables of the module FBs as well as global constants, can be used. Corresponds to the settings Inside range \/ Outside range for the observation types in the Alarm group object. SEC Digital Alarm which is raised if two expressions are compared with one another. The section is allowed to occur only once below the SEC SetAlarm section. If this is not the case an error is issued during the scan. Expression : IEC expression or value that is tested. In expressions, local variables of the module FBs as well as global constants, can be used. Equal : TRUE \/ FALSE : Expression will be checked for equality\/inequality. EqualsExpression : IEC expression or value which is checked against Expression . In expressions, local variables of the module FBs as well as global constants, can be used. Corresponds to the observation type Digital in the Alarm Group object. SEC Change Alarm which is raised if an expression changes its value. The section is allowed to occur only once below the SEC SetAlarm section. If this is not the case an error is issued during the scan. Expression : IEC expression or value that is checked for changes. In expressions, local variables of the module FBs as well as global constants, can be used. Corresponds to the observation type Change in the Alarm Group object. SEC Event Determines that the current alarm section creates an event alarm. This alarm can be triggered by the function RaiseModuleEvent() from the AC_Alarming library. " }, 
{ "title" : "Example ", 
"url" : "ac_module_fb_sec_alarm.html#UUID-e8936893-7db9-1fda-4737-bf3cf49fe064_aa4c0cec89085aac0a8640e01a3c6fe_id_00a4549e191b4801c0a8646366566922", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ Alarm Generator \/ Section: alg.Alarm \/ Example ", 
"snippet" : "ValueRange SEC SetAlarm : ValueRange Class := Error; Message := TL.Alarm_Temperature; LatchVar1 := rAlarmValueLow; LatchVar2 := rAlarmValueHigh; ModuleCalls := THIS | PARENTS; SEC Messages : msg2 Message := TL.msg5_Message; Number := 5; END_SEC SEC OutsideRange Expression := 'rValue'; AreaLow := 'rA...", 
"body" : "ValueRange SEC SetAlarm : ValueRange\n Class := Error;\n Message := TL.Alarm_Temperature;\n LatchVar1 := rAlarmValueLow;\n LatchVar2 := rAlarmValueHigh;\n ModuleCalls := THIS | PARENTS;\n SEC Messages : msg2\n Message := TL.msg5_Message;\n Number := 5;\n END_SEC\n SEC OutsideRange\n Expression := 'rValue';\n AreaLow := 'rAlarmValueLow';\n LowIncludeBorder := TRUE;\n HighIncludeBorder := TRUE;\n AreaHigh := 'rAlarmValueHigh';\n END_SEC\nEND_SEC Section: PendingTime SEC alg.Alarm\n\tSEC SetAlarm : NoVar\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'NoVar';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\n\tSEC SetAlarm : WithVar\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'WithVar';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\n\tSEC SetAlarm : SimpleMath\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTimeParameter := 'WithVar - NoVar + TIME#5S';\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\t\n\tSEC SetAlarm : NoParam\n\t\tClass := AlarmClassTemplate;\n\t\tMessage := TL.NoVar_Message;\n\t\tPendingTime := TIME#5S;\n\t\tSEC Digital\n\t\t\tExpression := 'xAlarm';\n\t\t\tEqual := TRUE;\n\t\t\tEqualsExpression :='TRUE'; \n\t\tEND_SEC\n\tEND_SEC\nEND_SEC " }, 
{ "title" : "CFC Generator ", 
"url" : "ac_cfc_generator.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ CFC Generator ", 
"snippet" : "The CFC generator automatically creates CFC programs which can contain calls of module FB instances. Created CFC programs can be edited. The program changes persist after repeated generator runs....", 
"body" : "The CFC generator automatically creates CFC programs which can contain calls of module FB instances. Created CFC programs can be edited. The program changes persist after repeated generator runs. " }, 
{ "title" : "Section: CFCCreation ", 
"url" : "ac_module_fb_sec_cfccreation.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ CFC Generator \/ Section: CFCCreation ", 
"snippet" : "CFCCreation This section contains all subsections that are interpreted by the CFC generator. SEC cfc.CFCCreation SEC CreateCFCProgram : <CFC program identifier> \/\/optional: yes, modifier [UPDATE] StandardCallTask := <Task type>; \/\/optional: yes, type: ID CustomCallTask := <Task type>; \/\/optional: ye...", 
"body" : "CFCCreation This section contains all subsections that are interpreted by the CFC generator. SEC cfc.CFCCreation\n\n SEC CreateCFCProgram : <CFC program identifier> \/\/optional: yes, modifier [UPDATE]\n StandardCallTask := <Task type>; \/\/optional: yes, type: ID\n CustomCallTask := <Task type>; \/\/optional: yes, type: ID\n ParentFolder := <create folder ID; \/\/optional: yes, type: ID\n END_SEC\n\n SEC CreateCFCModuleCall \/\/optional: yes, modifier [UPDATE]\n PreferredCFCProgram := <CFC program> \/\/optional: yes; type: FB type\n END_SEC\n\n SEC CreateCFCIOCall : <CFC IO call ID> \/\/ optional: yes; modifier [UPDATE]\n FB := <FB name>; \/\/ optional: no; type: FB type\n PreferredCFCProgram := <CFC program> \/\/ optional: yes; type: FB type\n FBInstanceBaseName := AInput; \/\/ optional: yes; type: identifier\n END_SEC\n\n SEC CreateFolder : <folder ID> \/\/optional: yes, modifier [UPDATE]\n ParentFolder := <folder name>; \/\/optional: yes, type: ID\n END_SEC\n\nEND_SEC Details regarding the syntax of definition types are described in the section Module Declaration . " }, 
{ "title" : "Subsection: CreateCFCProgram ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_bddcc1eb1403f77cc0a8640e01907eda", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ CFC Generator \/ Section: CFCCreation \/ Subsection: CreateCFCProgram ", 
"snippet" : "If a module declaration contains a section cfc.CFCCreation including the subsection CreateCFCProgram , a CFC program will be created for the assigned module type. The CFC program will be inserted below the target application of the next higher toplevel\/decoupled parent module instance. The definitio...", 
"body" : "If a module declaration contains a section cfc.CFCCreation including the subsection CreateCFCProgram , a CFC program will be created for the assigned module type. The CFC program will be inserted below the target application of the next higher toplevel\/decoupled parent module instance. The definition CustomCallTask or StandardCallTask can be used to define the task that calls the CFC program to be created. Specification: The target of the section CreateCFCProgram identifies the CFC programs of this module type. Basically a module type can define and create several CFC programs for its module instance. A definition for StandardCallTask or CustomCallTask must exist, but only one definition is allowed. For StandardCallTask the three IDs LOW , MEDIUM , and HIGH are available to define the task of the next higher toplevel\/decoupled parent module instance. For CustomCallTask all target IDs are available that are used in the respective custom task of the next higher toplevel\/decoupled parent module instance. In ParentFolder the target ID of the CreateFolder section can be entered. Then the created CFC program is added in this sub subfolder ( CreateFolder ). " }, 
{ "title" : "Subsection: CreateCFCModuleCall ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_4225fb301403f77dc0a8640e01bbc228", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ CFC Generator \/ Section: CFCCreation \/ Subsection: CreateCFCModuleCall ", 
"snippet" : "If a module declaration contains a section cfc.CFCCreation including the subsection CreateCFCProgram , a call of the module instance FB will be created for the assigned module type in the CFC program of the next higher parent module instance. Specification: PreferredCFCProgram defines the CFC progra...", 
"body" : "If a module declaration contains a section cfc.CFCCreation including the subsection CreateCFCProgram , a call of the module instance FB will be created for the assigned module type in the CFC program of the next higher parent module instance. Specification: PreferredCFCProgram defines the CFC program to be used if several program are available. " }, 
{ "title" : "Subsection: CreateCFCIOCall ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_72ec1fc41403f77ec0a8640e00114156", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ CFC Generator \/ Section: CFCCreation \/ Subsection: CreateCFCIOCall ", 
"snippet" : "The section is used to mark I\/Os of a module type or module declaration. For these I\/Os FB instances of a defined type are created. Then calls of these FB instances are created within the CFC program. Specification: The target of the CreateCFCIOCall section defines the module I\/O ID for which a glob...", 
"body" : "The section is used to mark I\/Os of a module type or module declaration. For these I\/Os FB instances of a defined type are created. Then calls of these FB instances are created within the CFC program. Specification: The target of the CreateCFCIOCall section defines the module I\/O ID for which a global I\/O FB will be created. The created I\/O FB will be called in a CFC program. FB defines the type of function block which is globally instantiated and called for the I\/O FB mentioned above. PreferredCFCProgram defines the CFC program to be used if several program are available. FBInstanceBaseName defines a \"base name\" which is used for the naming of the created I\/O FBs. If the definition does not exist the name of the module instance is used for the base instance. " }, 
{ "title" : "Subsection: CreateFolder ", 
"url" : "ac_module_fb_sec_cfccreation.html#UUID-e1ccc9b7-d48a-58d9-1620-742b3b11db5f_bc752f8a136986eac0a8640e01af6ba3_id_a2dd1e181403f77ec0a8640e013c4468", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Module Declaration \/ CFC Generator \/ Section: CFCCreation \/ Subsection: CreateFolder ", 
"snippet" : "This section contains parameters to create subfolders below the AC_CFC_Programs folder. Corresponding to this a ParentFolder can be defined in the CreateCFCProgram section. CFC programs are then generated in the directory which is created by the CreateFolder section. Folders itself can define a Pare...", 
"body" : "This section contains parameters to create subfolders below the AC_CFC_Programs folder. Corresponding to this a ParentFolder can be defined in the CreateCFCProgram section. CFC programs are then generated in the directory which is created by the CreateFolder section. Folders itself can define a ParentFolder to specify further sub and sub-sub folders. Specification: In ParentFolder the target ID of the CreateFolder section can be entered. Then the created directory will be created in this subfolder ( CreateFolder ). Example SEC cfc.CFCCreation\n SEC CreateCFCProgram : Standard\n StandardCallTask := MEDIUM;\n ParentFolder := SubFolderUnderFolder;\n END_SEC\n SEC CreateFolder : SubFolderUnderFolder\n ParentFolder := SubFolder;\n END_SEC\nEND_SEC " }, 
{ "title" : "Library: AC_ModuleBase ", 
"url" : "ac_library.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Library: AC_ModuleBase ", 
"snippet" : "The module basic library AC_ModuleBase is part of the module concept of the CODESYS Application Composer . All modules which are developed to be available in the module tree configurator have to be derived from this basic library. Navigation to toplevel The function GetToplevelRange returns a range ...", 
"body" : "The module basic library AC_ModuleBase is part of the module concept of the CODESYS Application Composer . All modules which are developed to be available in the module tree configurator have to be derived from this basic library. Navigation to toplevel The function GetToplevelRange returns a range instance (type SiblingRange ) which provides access to all toplevel instances. The function GetToplevelInstance returns the toplevel module that is an ancestor of the given instance. " }, 
{ "title" : "Instance name ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_f44958df1c1aa580c0a8640e00033aeb", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Library: AC_ModuleBase \/ Instance name ", 
"snippet" : "The property InstanceName of the base class returns a string which contains the name of the module instance. Property in IInstanceBase : PROPERTY InstanceName : STRING(255) Return value: Instance name of the module instance Proxy instances return the instance name of the remote module instance....", 
"body" : "The property InstanceName of the base class returns a string which contains the name of the module instance. Property in IInstanceBase : PROPERTY InstanceName : STRING(255) Return value: Instance name of the module instance Proxy instances return the instance name of the remote module instance. " }, 
{ "title" : "Module info ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_a581c7b51c1aa580c0a8640e012cbe1e", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Library: AC_ModuleBase \/ Module info ", 
"snippet" : "PROPERTY ModuleInfo : POINTER TO ModuleInfo : This property returns a pointer to a ModuleInfo function block with method PROPERTY ModuleType : STRING(255) . PROPERTY ModuleType : STRING(255) : This property returns the module name which is qualified by the name space of the module library. (The name...", 
"body" : "PROPERTY ModuleInfo : POINTER TO ModuleInfo : This property returns a pointer to a ModuleInfo function block with method PROPERTY ModuleType : STRING(255) . PROPERTY ModuleType : STRING(255) : This property returns the module name which is qualified by the name space of the module library. (The name space is relative to the primary project.) " }, 
{ "title" : "Instance path ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_247de8bc1c1aa581c0a8640e00b26998", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Library: AC_ModuleBase \/ Instance path ", 
"snippet" : "The function GetInstancePath(IModule) returns the instance path of a module instance. The instance path is built by concatenating the instance names of all ancestors, starting from the toplevel module down to the given instance. The instance names are separated by dots. If the resulting instance nam...", 
"body" : "The function GetInstancePath(IModule) returns the instance path of a module instance. The instance path is built by concatenating the instance names of all ancestors, starting from the toplevel module down to the given instance. The instance names are separated by dots. If the resulting instance name is longer than 255 characters, an empty string is returned. PROPERTY InstancePath : STRING(255) " }, 
{ "title" : "Flat navigation ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_acbf32a81c1aa581c0a8640e0039f1c2", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Library: AC_ModuleBase \/ Flat navigation ", 
"snippet" : "The function GetPrevModule(IModule) and GetNextModule(IModule) allow to jump to the previous or to the next element (if the module tree is regarded as a flat list of module instances). The modules are returned in depth-first preorder of the module tree. Module references are skipped if there is no p...", 
"body" : "The function GetPrevModule(IModule) and GetNextModule(IModule) allow to jump to the previous or to the next element (if the module tree is regarded as a flat list of module instances). The modules are returned in depth-first preorder of the module tree. Module references are skipped if there is no previous or no next module. Alternatively the function block DepthFirstRange can be used which lists all instances starting at a specific instance. The function GetDepthFirstRange returns a range function block instance (of type DepthFirstRange ) which lists the complete tree, starting at a given instance. " }, 
{ "title" : "Hierarchically navigation ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_1e4f5ff21c1aa58ec0a8640e0059614e", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Library: AC_ModuleBase \/ Hierarchically navigation ", 
"snippet" : "The interface IModuleTree allows to navigate in the module tree. An object of this interface is provided to each module by use of a pointer to an instance of type MEnv . This pointer is passed to the function SetIdentification . Module references are skipped in the navigation. The order of child nod...", 
"body" : "The interface IModuleTree allows to navigate in the module tree. An object of this interface is provided to each module by use of a pointer to an instance of type MEnv . This pointer is passed to the function SetIdentification . Module references are skipped in the navigation. The order of child nodes corresponds to the order of the module instances in the module tree. GetParent(itfM : IModule) : IModule : IModule: Returns the parent instance of a given module instance. For toplevel module instances the return value is 0. GetFirstChild(itfM : IModule) : IModule : Returns the first child of a given module instance. For module instances without children the return value is 0 NextSibling(itfM : IModule) : IModule : Returns the next sibling of a module instance. For module instances with no further sibling it returns 0. It can be called for toplevel instances, too. PrevSibling(itfM : IModule) : IModule : Returns the previous sibling of a module instance. For module instances with no previous sibling it returns 0. It can be called for toplevel instances, too. GetFirstToplevelInstance() : IModule : Returns the first toplevel instance of the tree. It returns 0 if the tree is empty. " }, 
{ "title" : "Navigation to ancestors, siblings and children ", 
"url" : "ac_library.html#UUID-d0b6112a-29ac-8414-4402-e8a78ea4dd83_f23d9061bd122a1c0a8640e000dc800_id_f30cbdfc1c1aa58fc0a8640e0098179e", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Library: AC_ModuleBase \/ Navigation to ancestors, siblings and children ", 
"snippet" : "The function block AncestorRange allows to access all ancestors of an instance, starting at the instance itself. The function block SiblingRange allows to access all following siblings of an instance in the module tree, starting at the instance itself. The function GetChildRange returns a range elem...", 
"body" : "The function block AncestorRange allows to access all ancestors of an instance, starting at the instance itself. The function block SiblingRange allows to access all following siblings of an instance in the module tree, starting at the instance itself. The function GetChildRange returns a range element (type SiblingRange ) of all children of an instance. " }, 
{ "title" : "Reliable Message Protocol (RMP) ", 
"url" : "ac_reliable_message_protocol.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Library: AC_ModuleBase \/ Reliable Message Protocol (RMP) ", 
"snippet" : "The reliable message protocol is used to send messages from one module instance to another. This communication can be between applications. Therefore an instance of the RMP handler is created for each application. Specification of the addressing: Each partner owns a unique 32 bit ID, which consists ...", 
"body" : "The reliable message protocol is used to send messages from one module instance to another. This communication can be between applications. Therefore an instance of the RMP handler is created for each application. Specification of the addressing: Each partner owns a unique 32 bit ID, which consists of a high-word (bit 16–31) for the application ID and a low-word (bit 0–15) for the local ID. Each ID (32 bit) must be unique – the single words (low word or high word) of the ID can be used more than once. The ID of the application, which calls the instance must be defined in the high word of the instance. Naming conventions for variables: udi<xxx>ID : Complete ID of the module consisting of application ID and local module ID ui<xxx>AppID : Application ID (16 bit), high-word of the complete ID ui<xxx>ModuleID : Local module ID (16 bit), low-word of the complete ID " }, 
{ "title" : "IRMPService ", 
"url" : "ac_rmp_irmpservice.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Library: AC_ModuleBase \/ IRMPService ", 
"snippet" : "Methods and properties of the interface IRMPService . Property: LocalAppID PROPERTY LocalAppID : UINT (get) This property describes the address of the local application. (The high-word of the communication ID of module instances of this application.)...", 
"body" : "Methods and properties of the interface IRMPService . Property: LocalAppID PROPERTY LocalAppID : UINT (get) This property describes the address of the local application. (The high-word of the communication ID of module instances of this application.) " }, 
{ "title" : "Method: IsMessageSent ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_538e8d066de1851ec0a8652001725d6d", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Library: AC_ModuleBase \/ IRMPService \/ Method: IsMessageSent ", 
"snippet" : "METHOD IsMessageSent : BOOL VAR_INPUT uiHandle: UINT; END_VAR This method checks if a message that has been queued with QueueSendMessage has been sent and acknowledged. uiHandle is the handle returned by QueueSendMessage . For this check the use of the function block RMPSendMessage is recommended, b...", 
"body" : "METHOD IsMessageSent : BOOL\nVAR_INPUT\n uiHandle: UINT;\nEND_VAR This method checks if a message that has been queued with QueueSendMessage has been sent and acknowledged. uiHandle is the handle returned by QueueSendMessage . For this check the use of the function block RMPSendMessage is recommended, because it provides a standardized command interface. " }, 
{ "title" : "Method: QueueSendMessage ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_b6b7ed9d6de18513c0a8652000b31074", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Library: AC_ModuleBase \/ IRMPService \/ Method: QueueSendMessage ", 
"snippet" : "METHOD QueueSendMessage : UINT VAR_INPUT udiSenderID: UDINT; udiReceiverID: UDINT; tValidity: TIME; pmdData: POINTER TO ARRAY[0..63] OF BYTE; END_VAR This method adds a message to send into the send queue and returns a handle. This handle can be used to check if the transmission was successful. A re...", 
"body" : "METHOD QueueSendMessage : UINT\nVAR_INPUT\n udiSenderID: UDINT;\n udiReceiverID: UDINT;\n tValidity: TIME;\n pmdData: POINTER TO ARRAY[0..63] OF BYTE;\nEND_VAR This method adds a message to send into the send queue and returns a handle. This handle can be used to check if the transmission was successful. A return value of 16#FFFF indicates that the buffer is full and the message was not transmitted. A return value of 16#FFFE indicates that the receiver module is in the same application and that the transmission was successful. To add a message to the send queue the use of the function block RMPSendMessage is recommended, because it provides a standardized command interface. " }, 
{ "title" : "Method: Receive ", 
"url" : "ac_rmp_irmpservice.html#UUID-0e77e966-86fe-5bdb-3d26-2749e2ec97ec_a365890471832c0a8640e004eff37_id_385683a56de1850cc0a8652000d330da", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Library: AC_ModuleBase \/ IRMPService \/ Method: Receive ", 
"snippet" : "METHOD Receive : UDINT VAR_INPUT uiReceiverModuleID: UINT; pmd: POINTER TO ARRAY[0..63] OF BYTE; END_VAR This method is called by each module that is able to receive a message. It takes the oldest received message for uiReceiverID and acknowledges it. If a message is not available, then 16#FFFFFFFF ...", 
"body" : "METHOD Receive : UDINT\nVAR_INPUT\n uiReceiverModuleID: UINT;\n pmd: POINTER TO ARRAY[0..63] OF BYTE;\nEND_VAR This method is called by each module that is able to receive a message. It takes the oldest received message for uiReceiverID and acknowledges it. If a message is not available, then 16#FFFFFFFF is returned. It returns 16#FFFFFFFE if there is at least one message waiting for the receiver, if the oldest message is currently locked by a different task. In all other cases, the communication address of the sender is returned. " }, 
{ "title" : "RMPSendMessage ", 
"url" : "ac_rmp_sendmessage.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Library: AC_ModuleBase \/ RMPSendMessage ", 
"snippet" : "This function block serves to send messages to any module instance. The address of the instance must be known. The behavior of the variables xExecute , xDone , xBusy , and xError complies with the \"Guidelines for Library Design\". This document is part of the CODESYS standard installation....", 
"body" : "This function block serves to send messages to any module instance. The address of the instance must be known. The behavior of the variables xExecute , xDone , xBusy , and xError complies with the \"Guidelines for Library Design\". This document is part of the CODESYS standard installation. " }, 
{ "title" : "FUNCTION_BLOCK: RMPSendMessage ", 
"url" : "ac_rmp_sendmessage.html#UUID-2d1f2b05-610c-bf06-e2fe-18d7e3819bbc_ac_rmp_sendmessage0", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Library: AC_ModuleBase \/ RMPSendMessage \/ FUNCTION_BLOCK: RMPSendMessage ", 
"snippet" : "FUNCTION_BLOCK RMPSendMessage EXTENDS CBM.ETRIG VAR_IN_OUT mdData: ARRAY[0..63] OF BYTE; END_VAR VAR_INPUT itfrmp: IRMPService; xExecute: BOOL; udiReceiverID: UDINT; uiSenderModuleID: UINT; tValidity: TIME := t#1s; END_VAR VAR_OUTPUT xDone: BOOL; xBusy: BOOL; xError: BOOL; uiErrorID: UINT; END_VAR P...", 
"body" : "FUNCTION_BLOCK RMPSendMessage EXTENDS CBM.ETRIG\nVAR_IN_OUT\n mdData: ARRAY[0..63] OF BYTE;\nEND_VAR\nVAR_INPUT\n itfrmp: IRMPService;\n xExecute: BOOL;\n udiReceiverID: UDINT;\n uiSenderModuleID: UINT;\n tValidity: TIME := t#1s;\nEND_VAR\nVAR_OUTPUT\n xDone: BOOL;\n xBusy: BOOL;\n xError: BOOL;\n uiErrorID: UINT;\nEND_VAR Please note that the job of the function block is finished successfully as soon as the receipt of the message in the RMPService of the opposite side is confirmed. This does not necessarily mean that the message has reached the actual receiver module interface. In mdData , the data to send will be transferred. udiReceiverID defines the ID of the receiver. rmp defines the local RMPService instance. tValidity defines the validation period of the message. The following things are checked: The duration until the message is sent must not exceed tValidity (otherwise an error message will be created). The duration until the message is picked up by the receiver of the opposite side, must not exceed tValidity (otherwise the message will be deleted). The following errors may occur and will be returned in uiErrorID : Send buffer is full; it is recommended to send again at a later date. The message will not be deleted from the send buffer. Reasons can be a slow transfer, an interrupted connection or a full receive buffer on the opposite side. The application to which the message is sent is not connected to this application. In this case a transfer of the data is no possible. " }, 
{ "title" : "Debugging ", 
"url" : "ac_rmp_debugging.html", 
"breadcrumbs" : "CODESYS Application Composer \/ Module Declaration Editor \/ Library: AC_ModuleBase \/ Debugging ", 
"snippet" : "The global variable g_AC_RMP_xDiagLog can be used to enable the logging mechanism. This mechanism records all send events and receive events and it logs the creation and deletion of a message to a queue of the standard log. Furthermore, all unexpected events and errors are written to the standard lo...", 
"body" : "The global variable g_AC_RMP_xDiagLog can be used to enable the logging mechanism. This mechanism records all send events and receive events and it logs the creation and deletion of a message to a queue of the standard log. Furthermore, all unexpected events and errors are written to the standard log. " }
]
$(document).trigger('search.ready');
});