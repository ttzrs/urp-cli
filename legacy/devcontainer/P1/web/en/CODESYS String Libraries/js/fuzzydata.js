$(document).ready(function () {indexDict['en-US'] = [{ "title" : "CODESYS String Libraries ", 
"url" : "_strlib_start_page.html", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Introduction ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4664735744121633736389596078", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Introduction ", 
"snippet" : "The libraries in the CODESYS String Libraries package can be used to process strings which are UTF-8 encoded. The basis is the IString interface from the String Segments library. Using this interface, the strings can be passed to the respective functions by reference. For example, to create an IStri...", 
"body" : "The libraries in the CODESYS String Libraries package can be used to process strings which are UTF-8 encoded. The basis is the IString interface from the String Segments library. Using this interface, the strings can be passed to the respective functions by reference. For example, to create an IString instance, the GSB.UTF8String function block from the Generic String Base library is provided. The following libraries are supplied with the package: String Segments Base functions for IString instances String Segments Library Documentation String Builder Efficient management of UTF-8 encoded string segments String Builder Library Documentation String Conversions Conversion of strings of different encoding to\/from UTF-8 String Conversions Library Documentation String Functions Functions for processing UTF-8 encoded strings following the example of the conventional standard library. String Functions Library Documentation Unicode Support Functions for processing Unicode character categories. Unicode Support Functions Library Documentation UTF-16 Encoding Support Base function for handling UTF-16 encoded memory areas UTF-16 Encoding Support Library Documentation UTF-8 Encoding Support Base function for handling UTF-8 encoded memory areas UTF-8 Encoding Support Functions Library Documentation Generic String Base Function blocks for processing UTF-8 encoded strings which manage their memory statically via GENERIC CONSTANT . Generic String Base Functions Library Documentation " }, 
{ "title" : "Advantages of the new string libraries ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4563869800648033733012917566", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Advantages of the new string libraries ", 
"snippet" : "The new string libraries do not replace the old familiar string functions of the Standard and Standard64 libraries. Nevertheless, we recommend using the new string libraries for new projects. The new string libraries can also handle large strings efficiently. The length of the strings is almost unli...", 
"body" : "The new string libraries do not replace the old familiar string functions of the Standard and Standard64 libraries. Nevertheless, we recommend using the new string libraries for new projects. The new string libraries can also handle large strings efficiently. The length of the strings is almost unlimited. For this reason, the libraries are also suitable for editing large text files and web contents. Other advantages: UTF-8 is encoding which can represent the full range of characters according to UNICODE. UTF-8 is widely used on the Internet and is recommended by the World Wide Web Consortium (W3C). UTF-8 is compatible with legacy systems because of ASCII compatibility. UTF-8 provides a high level of interoperability. UTF-8 works to optimize memory. The new string libraries let you query a previously defined string via corresponding methods, just as you know it from other high-level languages. Example string method: Len() udiStringLen := myString.Len();\nif¬†udiStringLen =¬†22¬†THEN\n... As of CODESYS 3.5.18.0, you can set the compiler to interpret the contents of variables of type STRING as UTF-8 encoding. You select the UTF8 Encoding for STRING option in the Project Settings in the Compile options category. If you do not want to treat all STRING variables in a project as UTF-8 encoded, the you need to clear this option. After that, you can apply UTF-8 encoding to individual literals of the STRING type on a case-by-case basis. UTF-8 encoding for literals {attribute¬†'monitoring_encoding'¬†:=¬†'UTF-8'}\nsValue : STRING(140) := UTF8#'√êŒ± ·πß—Ç‚ÑØ‚ôÑ ·∏Ø·∏â‚Ñå Œ∑uŒ∑, i¬¢‚Ñå Œ±—è–º‚ÑØ“ë ùïã√∏“ë‚Äº ·π≤·æî‚Öæ ‚ô≠·∏ØŒ∑ ÔºÑ‚ò∫ ·∏±‚ÑìœÖ‚Ñä Œ±≈ÇÔºÑ œâ‚Öà‚ÑÆ ·∫ïœÖ‚àö‚óé“ë'; Thanks to the capabilities of UTF-8 encoding, you do not have to use the WSTRING data type in CODESYS to use an extended character set. UCS-2 encoding, which WSTRING is based on, may require more memory than a UTF-8 encoding, depending on the application. UCS-2 encoding always uses one WORD per character and can represent only the characters U+0000 to U+D800 and U+DFFF to U+FFFD . UTF-8 encoding requires between one and four bytes per character. As a result, all Unicode characters can be processed. With UTF-8 encoding, if you try to get a specific character using a specific index, then this will lead to unexpected results due to the variable length. Encoding of variable length {attribute 'monitoring_encoding' := 'UTF-8'}\nsValue : STRING(140) := UTF8#'√êŒ± ·πß—Ç‚ÑØ‚ôÑ ·∏Ø·∏â‚Ñå Œ∑uŒ∑, i¬¢‚Ñå Œ±—è–º‚ÑØ“ë ùïã√∏“ë‚Äº ·π≤·æî‚Öæ ‚ô≠·∏ØŒ∑ ÔºÑ‚ò∫ ·∏±‚ÑìœÖ‚Ñä Œ±≈ÇÔºÑ œâ‚Öà‚ÑÆ ·∫ïœÖ‚àö‚óé“ë';\n\nbyValue := sValue[13];¬†\/\/ The 'u' is NOT the 13th character in the string\nxOk := byValue <>¬†16#75; You need to determine the index of a character by iterating through the string. Iteration over UTF-8 encoded strings VAR\t\n {attribute 'monitoring_encoding' := 'UTF-8'}\n sValue : STRING(140) := UTF8#'√êŒ± ·πß—Ç‚ÑØ‚ôÑ ·∏Ø·∏â‚Ñå Œ∑uŒ∑, i¬¢‚Ñå Œ±—è–º‚ÑØ“ë ùïã√∏“ë‚Äº ·π≤·æî‚Öæ ‚ô≠·∏ØŒ∑ ÔºÑ‚ò∫ ·∏±‚ÑìœÖ‚Ñä Œ±≈ÇÔºÑ œâ‚Öà‚ÑÆ ·∫ïœÖ‚àö‚óé“ë';\n\n fbsValue : STR.UTF8Literal := (psValue:=ADR(sValue)); \n fbRange : STR.Range := (itfString:=fbsValue);\n diRune : STR.RUNE;\n udiIndex, udiLength : UDINT;\n xOk : BOOL;\nEND_VAR\n \nWHILE (diRune := fbRange.GetNextRune(udiLength=>udiLength)) <> 0 DO\n IF diRune = 16#75 (* 'u' *) THEN\n EXIT;\n END_IF\n udiIndex := udiIndex + udiLength;\nEND_WHILE\n \nxOk := sValue[udiIndex] = 16#75 (* 'u' *); " }, 
{ "title" : "Disadvantages of the established STRING functions ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4613761597678433733013344138", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Disadvantages of the established STRING functions ", 
"snippet" : "In the previously established STRING functions from the standard library, the parameters of type STRING are copied when they are passed to the functions. The return value is also copied to a variable with the assignment. Problems with the established STRING functions VAR sValue : STRING; END_VAR sVa...", 
"body" : "In the previously established STRING functions from the standard library, the parameters of type STRING are copied when they are passed to the functions. The return value is also copied to a variable with the assignment. Problems with the established STRING functions VAR\n sValue : STRING;\nEND_VAR\n \nsValue := CONCAT(CONCAT(CONCAT('Da steh ich nun,', ' ich armer Tor!'), ' Und bin so'), ' klug als wie zu vor');\n\/\/ -> Copy, LEN -> Copy, LEN -> Copy, LEN -> Copy, LEN\n\/\/ -> 2xCopy, LEN\n\/\/ -> 2xCopy, LEN\n\/\/ -> 2xCopy, LEN Before processing the parameters of type STRING in the respective functions, their lengths often have to be determined by iteration up to the terminating null character. For longer strings, these copy and iteration operations increase the processing time of the application. The length of the strings is limited to 255 characters for the application of these functions. " }, 
{ "title" : "Using the IString interface ", 
"url" : "_strlib_start_page.html#UUID-70ae778c-1f81-2848-ca6a-08b441de0865_section-idm4598276788502433733013693363", 
"breadcrumbs" : "CODESYS String Libraries \/ CODESYS String Libraries \/ Using the IString interface ", 
"snippet" : "The STR.IString interface was introduced to pass the data structure which manages the information about a string by reference. This is a major difference to the previously established STRING functions, which do not implement the STR.IString interface.¬† Furthermore, the size of a string (the respecti...", 
"body" : "The STR.IString interface was introduced to pass the data structure which manages the information about a string by reference. This is a major difference to the previously established STRING functions, which do not implement the STR.IString interface.¬† Furthermore, the size of a string (the respective memory for the UTF-8 encoded characters) may be in the numeric range UDINT 4 ‚â¶ udiSize ‚â¶ 16#FFFF_FF00 ). In the mentioned data structure, the following information is kept up-to-date and does not have to be recalculated each time before a processing step: Reference to the respective memory segment Current capacity (‚Üí GetSegment ) Length (‚Üí Len ) in bytes Number of characters (‚Üí RuneCount ) Properties of STR.IString VAR\n itfString : STR.IString;\n udiLength, udiSize, udiRuneCount : UDINT;\n pbySegment : POINTER TO BYTE;\n xValid : BOOL;\nEND_VAR\n \nudiLength := itfString.Len(); \/\/ Current length in byte\npbySegment := itfString.GetSegment(udiSize=>udiSize); \/\/ Address first byte, capacity of the segment in bytes\nudiRuneCount := STR.RuneCount(itfString); \/\/ Current number of \"characters\" in the segment\nxValid := itfString.IsValid(); \/\/ Indication that a valid UTF-8 encoding is present. Correlation: \"character\" and \"rune\" The term \"rune\" appears in the libraries and in the source code and means exactly the same as \"Unicode code point\", with an interesting addition. The libraries define the word \"rune\" as an alias for the type DINT . As a result, the user can clearly see when an integer value represents a code point. Moreover, what can be imagined as a character constant is called a runic constant. Example: The type and value of the expression WSTRING#\"‚åò\" is a rune with the integer value DINT#16#2318 . " }, 
{ "title" : "Information for Experts ", 
"url" : "_strlib_expert_information.html", 
"breadcrumbs" : "CODESYS String Libraries \/ Information for Experts ", 
"snippet" : "In CODESYS versions before 3.5.18.0, you do not have the possibility to use UTF-8 encoded variables of type STRING and the Generic String Base library. This is only possible in version 3.5.19.50 and higher. You can still use the other libraries from the CODESYS String Libraries package. However, the...", 
"body" : "In CODESYS versions before 3.5.18.0, you do not have the possibility to use UTF-8 encoded variables of type STRING and the Generic String Base library. This is only possible in version 3.5.19.50 and higher. You can still use the other libraries from the CODESYS String Libraries package. However, the handling of UTF-8 encoded memory areas (for example, of type ARRAY OF BYTE ) is somewhat more complicated there. BEFORE SP18 VAR\n abyValue : ARRAY[0..33] OF BYTE := [ \/\/ UTF-8 C√òD‚Ç¨≈°≈∏≈† √Ø√ü v√§r√ø √ß√¥√µl\n 16#43, 16#C3, 16#98, 16#44, 16#E2, 16#82, 16#AC, 16#C5, 16#A1, 16#C5, 16#B8,\n 16#C5, 16#A0, 16#20, 16#C3, 16#AF, 16#C3, 16#9F, 16#20, 16#76, 16#C3, 16#A4,\n 16#72, 16#C3, 16#BF, 16#20, 16#C3, 16#A7, 16#C3, 16#B4, 16#C3, 16#B5, 16#6C, 0\n ];\n myString : STR.UTF8Literal := (psValue:=ADR(abyValue));\nEND_VAR As soon as UTF-8-encoded variables of type STRING are available, the above example is simplified even more: VAR\n myString : STR.UTF8Literal := (psValue:=ADR(UTF8#'C√òD‚Ç¨≈°≈∏≈† √Ø√ü v√§r√ø √ß√¥√µl'));\nEND_VAR " }, 
{ "title" : "Conversion from STRING to IString ", 
"url" : "_strlib_expert_information.html#UUID-ab7f59ef-3fd1-9368-2073-8d15fffc313a_section-idm4670931916384033733014074571", 
"breadcrumbs" : "CODESYS String Libraries \/ Information for Experts \/ Conversion from STRING to IString ", 
"snippet" : "The data structure for managing the properties of a string segment is implemented by means of the STR._UTF8String function block. To do this, you need to allocate memory for an instance of this function block and for the string segment itself. A function block instance must be located in a memory ar...", 
"body" : "The data structure for managing the properties of a string segment is implemented by means of the STR._UTF8String function block. To do this, you need to allocate memory for an instance of this function block and for the string segment itself. A function block instance must be located in a memory area which is aligned to an __XWORD address . Conversion from String to IString VAR CONSTANT\n c_udiLength : UDINT := MAX(4, 512); \/\/ String segment capacity including terminal NULL\n c_udiXWORD : UDINT := SIZEOF(__XWORD);\n¬† ¬†¬†c_udiMaxIndex : UDINT := (SIZEOF(STR._UTF8String) + c_udiLength +¬† c_udiXWORD¬† -¬†1) \/ c_udiXWORD;\nEND_VAR\n \nVAR\n abyValue : ARRAY[0..33] OF BYTE := [ \/\/ UTF-8 C√òD‚Ç¨≈°≈∏≈† √Ø√ü v√§r√ø √ß√¥√µl\n 16#43, 16#C3, 16#98, 16#44, 16#E2, 16#82, 16#AC, 16#C5, 16#A1, 16#C5, 16#B8,\n 16#C5, 16#A0, 16#20, 16#C3, 16#AF, 16#C3, 16#9F, 16#20, 16#76, 16#C3, 16#A4,\n 16#72, 16#C3, 16#BF, 16#20, 16#C3, 16#A7, 16#C3, 16#B4, 16#C3, 16#B5, 16#6C, 0\n\t];\n axwMemory : ARRAY[0..c_udiMaxIndex] OF __XWORD;\n udiSize : UDINT;\n itfString : STR.IString := STR.CreateString(\n ADR(axwMemory), SIZEOF(axwMemory),\n ADR(abyValue),\n udiStrSize=>udiSize\n );\n xOk : BOOL;\nEND_VAR\n \nxOk := (\n udiSize >= 512 AND\n itfString.Len() = 33 AND\n STR.RuneCount(itfString) = 20 AND\n itfString.IsValid() AND\n NOT itfString.IsASCII()\n); With the help of the Generic String Base library, many of these requirements are taken into account by corresponding function blocks, and as a result relieving the user of many tasks. Above all, the correct reservation and alignment of the memory are encapsulated in the corresponding function blocks. " }, 
{ "title" : "Examples ", 
"url" : "_strlib_examples.html", 
"breadcrumbs" : "CODESYS String Libraries \/ Examples ", 
"snippet" : "The Generic String Base library is provided to make string processing as simple as possible. However, it uses the VAR_GENERIC CONSTANT compiler feature and can therefore only be used as of CODESYS V3.5 SP19 Patch 5....", 
"body" : "The Generic String Base library is provided to make string processing as simple as possible. However, it uses the VAR_GENERIC CONSTANT compiler feature and can therefore only be used as of CODESYS V3.5 SP19 Patch 5. " }, 
{ "title" : "Library: Generic String Base ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4598276773272033733014529891", 
"breadcrumbs" : "CODESYS String Libraries \/ Examples \/ Library: Generic String Base ", 
"snippet" : "Here an instance ( myString ) of a GSB.UTF8String with a capacity of 128 bytes is created and the string segment with the value of a STRING variable (Roman numeral 1968) is initialized. The methods of STR.IString are available. From STRING to IString VAR ¬† ¬†¬†myString : GSB.UTF8String<128> := (sValue...", 
"body" : "Here an instance ( myString ) of a GSB.UTF8String with a capacity of 128 bytes is created and the string segment with the value of a STRING variable (Roman numeral 1968) is initialized. The methods of STR.IString are available. From STRING to IString VAR\n¬† ¬†¬†myString : GSB.UTF8String<128> := (sValue := UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß');¬†\/\/ r√∂misch 1968¬†¬†¬†¬†\n psString : POINTER TO STRING;¬†¬†¬†¬†udiSize, udiLength : UDINT;¬† ¬†¬†xASCII, xOk : BOOL;\nEND_VAR\n \n psString := myString.GetSegment(udiSize=>udiSize, udiLength=>udiLength, xASCII=>xASCII);¬†\/\/ Conversion back to the STRING data type\n \nxOk := (\n myString.IsValid() AND \/\/ A valid UTF-8 encoding is present\n udiSize = 128 AND \/\/ The capacity of the string in bytes\n myString.Len() = 17 AND \/\/ The current length of the string in bytes\n STR.RuneCount(myString) = 6 \/\/ The current number of characters in the string\n); Function of the string builder VAR\n myString : GSB.UTF8String<20> := (sValue := UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß'); \/\/ roman 1968\n sValue : STRING := 'wurden in Mexico-Stadt die';\n wsValue : WSTRING := \"‚Ö©‚Ö®.\";\n diSpace : STR.RUNE := 32;\n myValue : GSB.UTF8String<128> := (sValue := UTF8#'—∫‚Ñì∆¥ŒºœÅ‚ò§·πß·∏â–ΩŒµŒ∑ $$œÅ—ó‚ÑÆ≈Ç‚ÑØ Œ±‚ô≠‚ÑäŒµ‚ÑåŒ± ü‚ä•‚ÑÆ·æî.');\n \n myBuilder : GSB.Builder<(*udiInitialCapacity*) 64, (*usiExtensionFactor*) 50> := (itfString:=myString);\n myResult : GSB.UTF8String<128>;\n \n {attribute 'monitoring_encoding' := 'UTF-8'}\n sResult : STRING(128) := UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß wurden in Mexico-Stadt die ‚Ö©‚Ö®. —∫‚Ñì∆¥ŒºœÅ‚ò§·πß·∏â–ΩŒµŒ∑ $$œÅ—ó‚ÑÆ≈Ç‚ÑØ Œ±‚ô≠‚ÑäŒµ‚ÑåŒ± ü‚ä•‚ÑÆ·æî.';\n \n psResult : POINTER TO STRING;\n udiLength : UDINT;\n xOk : BOOL;\nEND_VAR\n \nmyBuilder.WriteRune(diSpace);\nmyBuilder.WriteString(sValue);\nmyBuilder.WriteRune(diSpace);\nmyBuilder.WriteWString(wsValue);\nmyBuilder.WriteRune(diSpace);\nmyBuilder.WriteIString(myValue);\n \nudiLength := myBuilder.Len(); \/\/ The number of bytes occupied in the builder.\nmyBuilder.ToIString(myResult); \/\/ The individual parts of the string are copied together to myResult.\n \npsResult := myResult.GetSegment(); \nxOk := (psResult^ = sResult); \/\/ Both memory areas should have the same content. In the example above, an instance of the builder is created with an initial capacity of 64 bytes ( udiInitialCapacity ) and a dynamic factor of 50 ( usiExtensionFactor ). The string generated further above is still passed in the declaration, and as a result the builder is filled with this string ( UTF8#'ùïÑÔº£M‚Ñí‚úñ‚Öß' ). Using the usiExtensionFactor parameter, increases the builder by 50% when its current capacity is used up. Reading a file with the builder VAR\n sPath : STRING := 'myFilePath';\n hFile : RTS_IEC_HANDLE := RTS_INVALID_HANDLE;\n myBuilder : GSB.Builder<(*udiInitialCapacity*) 16#10000, (*usiExtensionFactor*) 50>;\n abyBuffer : ARRAY[0..4095] OF BYTE;\n pbyData : POINTER TO BYTE;\n udiSize : UDINT;\n udiCount : UDINT;\n eEncoding : SCV.ENCODING;\n eErrorID : SCV.ERROR;\n udiResult : RTS_IEC_RESULT;\nEND_VAR\n \nhFile := SysFileOpen(sPath, ACCESS_MODE.AM_READ, ADR(udiResult));\nIF udiResult <> ERRORS.ERR_OK THEN\n \/\/ handle error condition\n RETURN; \nEND_IF\n \nREPEAT \/\/ fake loop - We need the EXIT feature\n pbyData := ADR(abyBuffer);\n udiSize := TO_UDINT(SysFileRead(hFile, pbyData, XSIZEOF(abyBuffer), ADR(udiResult)));\n IF udiResult <> ERRORS.ERR_OK THEN\n \/\/ handle error condition\n EXIT; \n END_IF\n \n \/\/ Determination of the file encoding\n udiCount := SCV.DecodeBOM(pbyData, udiSize, eEncoding=>eEncoding, eErrorID=>eErrorID);\n IF eErrorID <> 0 THEN\n \/\/ handle error condition\n EXIT;\n END_IF\n \n pbyData := pbyData + udiCount;\n udiSize := udiSize - udiCount;\n \n WHILE udiSize > 0 DO\n \/\/ Convert file content to UTF-8 and copy to Builder-Content\n udiCount := myBuilder.WriteMemSegment(pbyData, udiSize, eEncoding, eErrorID=>eErrorID);\n IF eErrorID <> 0 THEN\n \/\/ handle error condition\n EXIT;\n END_IF\n pbyData := ADR(abyBuffer);\n udiSize := TO_UDINT(SysFileRead(hFile, pbyData, XSIZEOF(abyBuffer), ADR(udiResult)));\n IF udiResult <> ERRORS.ERR_OK THEN\n \/\/ handle error condition\n EXIT; \n END_IF\n END_WHILE\nUNTIL TRUE\nEND_REPEAT\n \nIF hFile <> RTS_INVALID_HANDLE THEN\n SysFileClose(hFile);\n hFile := RTS_INVALID_HANDLE;\n udiCount : UDINT;\nEND_IF Analysis of the contents of a builder instance VAR\n myRange : SBD.Range := (itfBuilder := myBuilder);\n diRune : STR.RUNE;\n eError : STR.ERROR;\nEND_VAR\n \nmyRange.Reset();\nWHILE (diRune := myRange.GetNextRune(eErrorID=>eErrorID)) <> 0 AND_THEN eErrorID = 0 DO\n IF UC.IsSpace(diRune) THEN\n \/\/ The characters in the builder which are considered as spaces according to UNICODE are counted.\n udiCount := udiCount + 1;\n END_IF\nEND_WHILE For passing UTF-8 encoded contents, no cache is needed for encoding conversion because the data is already UTF-8 encoded in the builder. Therefore, the contents of a segments of a builder can be sent directly, for example over a TCP\/IP connection. Transporting the UTF-8 encoded contents of a builder over the network VAR\n itfConnection : NBS.IConnection;\n pbySegment : POINTER TO BYTE;\n udiSize : UDINT;\n eError : NBS.ERROR;\nEND_VAR\n \n(* Provide an active itfConnection *)\n \npbySegment:= myBuilder.GetFirstSegment(udiSize=>udiSize, eErrorID=>eErrorID);\nWHILE pbySegment <> 0 AND eErrorID = 0 DO\n eError := itfConnection.Write(pbySegment, udiSize, udiCount=>udiCount);\n IF eError <> 0 OR udiCount <> udiSize THEN\n \/\/ Handle Error\n EXIT;\n END_IF\n pbySegment := myBuilder.GetNextSegment(pbySegment, udiSize=>udiSize, eErrorID=>eErrorID);\nEND_WHILE\n \n(* e.g. Close itfConnection *) " }, 
{ "title" : "Working with the StringPool and RangePool function blocks ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4670931838168033733015007444", 
"breadcrumbs" : "CODESYS String Libraries \/ Examples \/ Working with the StringPool and RangePool function blocks ", 
"snippet" : "The following code shows how to use of dynamic IString instances from a StringPool . A StringPool or a RangePool is well suited to be passed to subordinate parts of a program. Then these can create the corresponding instances from the respective pool as needed, work with them, and then return these ...", 
"body" : "The following code shows how to use of dynamic IString instances from a StringPool . A StringPool or a RangePool is well suited to be passed to subordinate parts of a program. Then these can create the corresponding instances from the respective pool as needed, work with them, and then return these instances to the pool. Working with StringPool and RangePool VAR\n myString : GSB.UTF8String<256> := (sValue:=UTF8#'Was du nicht willst, dass man dir tu‚Äô, das f√ºg auch keinem andern zu.');\n myRange : STR.Range := (itfString:=myString);\n \n myStringPool : GSB.StringPool<(*udiStringSize*) 30, (*udiInitialCapacity*) 25, (*usiExtensionFactor*) 0>;\n myRangePool : GSB.RangePool<GSB.RANGE_TYPE.ISTRING, (*udiInitialCapacity*) 10, (*usiExtensionFactor*) 0>;\n \n diRune : STR.RUNE;\n eErrorID : STR.ERROR;\n itfSubString : STR.IString;\n liStart, liEnd : LINT;\n udiCount : UDINT;\nEND_VAR\n \nmyRange.Reset();\n\/\/ Decompose myString into substrings and analyze them via a subroutine.\nWHILE (diRune:=myRange.GetNextRune(eErrorID=>eErrorID)) <> 0 AND eErrorID = 0 DO\n IF diRune = 16#2C (*,*) OR diRune = 16#2E (*.*) THEN\n itfSubString := myStringPool.GetString();\n IF itfSubString = 0 THEN\n (* Handle Error *)\n EXIT;\n END_IF\n myString.ToIString(itfSubString, liStart+1, liEnd, eErrorID=>eErrorID);\n IF eErrorID <> 0 THEN\n (* Handle Error *)\n EXIT;\n END_IF\n \/\/ Analyse the substring and use pool's\n \/\/ Will release itfSubString\n udiCount := Analyse(itfSubString, myStringPool, myRangePool);\n (* ... Handle Result ... *)\n IF diRune = 16#2E (*.*) THEN\n EXIT;\n END_IF\n diRune:=myRange.GetNextRune(eErrorID=>eErrorID);\n IF diRune = 16#20 (* space *) AND eErrorID = 0 THEN\n liEnd := liEnd + 1;\n ELSE\n myRange.UngetLastRune();\n END_IF\n liStart := liEnd + 1;\n END_IF\n liEnd := liEnd + 1;\nEND_WHILE " }, 
{ "title" : "Working with the character categories of Unicode ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4613758488403233733015299155", 
"breadcrumbs" : "CODESYS String Libraries \/ Examples \/ Working with the character categories of Unicode ", 
"snippet" : "The Unicode standard aims to digitally capture all characters worldwide and describe their properties. To do this, the characters are combined into groups (categories). In the Unicode library, there are functions which check a character regarding which category it belongs to. These functions return ...", 
"body" : "The Unicode standard aims to digitally capture all characters worldwide and describe their properties. To do this, the characters are combined into groups (categories). In the Unicode library, there are functions which check a character regarding which category it belongs to. These functions return TRUE if the passed character belongs to the respective category; otherwise FALSE is returned. Name Function IsControl Recognizes general control characters IsLetter Recognizes letters in the broader sense IsMark Recognizes combining characters, for example, diacritical characters IsDigit Recognizes decimal digits IsLower Recognizes lowercase letters IsNumber Recognizes digits and characters which apply to numbers IsGraphic Recognizes only printable characters (including different types of space characters) IsUpper Recognizes uppercase letters IsPunct Recognizes punctuation characters IsPrint Recognizes only printable characters (considers only 16#20 as space character) IsTitle Recognizes uppercase letters for headers IsSpace Detects spaces of different width, line breaks, etc. IsSymbol Recognizes symbols in a broader sense, for example, mathematical symbols and currency symbols. The contents of an IString or IBuilder instance can be analyzed \"character by character\" using a suitable function block of type Range . The functions from the Unicode library can be very useful for the analysis. Character analysis VAR\n myString : GSB.UTF8String<50> := (sValue:='Hello World!');\n myBuilder : GSB.Builder<100, 0> := (itfString:=myString);\n mySRange : STR.Range := (itfString:=myString);\n myBRange : SBD.Range := (itfBuilder:=myBuilder);\n diSRune, diBRune : STR.RUNE;\n eErrorID : STR.ERROR;\n udiCount : UDINT;\nEND_VAR\n \nWHILE (diSRune:=mySRange.GetNextRune(eErrorID=>eErrorID)) <> 0 AND eErrorID = 0 DO\n diBRune := myBRange.GetNextRune();\n IF diSRune <> diBRune THEN\n (* Solle nicht vorkommen *)\n END_IF\n IF UC.IsSpace(diSrune) THEN\n udiCount := udiCount + 1;\n END_IF\nEND_WHILE " }, 
{ "title" : "Conversion of characters ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4613761628716833733015669185", 
"breadcrumbs" : "CODESYS String Libraries \/ Examples \/ Conversion of characters ", 
"snippet" : "Convert letters to uppercase ( UC.ToUpper ) Convert letters to lowercase ( UC.ToLower ) Conversion VAR diRuneA, diRuneB : STR.RUNE; END_VAR diRuneA := 16#1F3; \/\/ U+01F3 = «Ö diRuneB := UC.ToUpper(diRuneA); \/\/ U+01F1 = «± diRuneA := UC.ToLower(diRuneB); \/\/ U+01F3 = «Ö diRuneB := UC.ToTitle(diRuneA); \/\/ ...", 
"body" : "Convert letters to uppercase ( UC.ToUpper ) Convert letters to lowercase ( UC.ToLower ) Conversion VAR\n diRuneA, diRuneB : STR.RUNE;\nEND_VAR\n \ndiRuneA := 16#1F3; \/\/ U+01F3 = «Ö\ndiRuneB := UC.ToUpper(diRuneA); \/\/ U+01F1 = «±\ndiRuneA := UC.ToLower(diRuneB); \/\/ U+01F3 = «Ö\ndiRuneB := UC.ToTitle(diRuneA); \/\/ U+01F2 = «≤ " }, 
{ "title" : "Comparison of strings ", 
"url" : "_strlib_examples.html#UUID-26308056-d568-3989-2c92-980baf41fda0_section-idm4563870076659233733015900115", 
"breadcrumbs" : "CODESYS String Libraries \/ Examples \/ Comparison of strings ", 
"snippet" : "Case-sensitive ( STR.Compare ) Not case-sensitive ( UC.EqualFold ) Comparison of strings VAR myFirstString : GSB.UTF8String<50> := (sValue:='test'); mySecondString : GSB.UTF8String<50> := (sValue:='Test'); myThirdString : GSB.UTF8String<50> := (sValue:='CoDeSys'); myFourthString : GSB.UTF8String<50>...", 
"body" : "Case-sensitive ( STR.Compare ) Not case-sensitive ( UC.EqualFold ) Comparison of strings VAR\n myFirstString : GSB.UTF8String<50> := (sValue:='test');\n mySecondString : GSB.UTF8String<50> := (sValue:='Test');\n \n myThirdString : GSB.UTF8String<50> := (sValue:='CoDeSys');\n myFourthString : GSB.UTF8String<50> := (sValue:='CODESYS');\n \n diResult : DINT;\n xEqual : BOOL;\nEND_VAR\n \n\/\/\/ Comparing two Strings lexicographically\n\/\/\/ diResult = 1 --> myFirstString > mySecondString\ndiResult := STR.Compare(myFirstString, mySecondString);\n \n\/\/\/ Unicode defined simple case folding\n\/\/\/ xEqual = TRUE --> myThirdString == myFourthString\nxEqual := UC.EqualFold(\n ADR(myThirdString.sValue), myThirdString.Len(),\n ADR(myFourthString.sValue), myFourthString.Len()\n); " }
]
$(document).trigger('search.ready');
});