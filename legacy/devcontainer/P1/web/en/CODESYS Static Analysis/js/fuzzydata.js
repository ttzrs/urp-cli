$(document).ready(function () {indexDict['en-US'] = [{ "title" : "CODESYS Static Analysis ", 
"url" : "_san_start_page.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ CODESYS Static Analysis ", 
"snippet" : "With CODESYS Static Analysis , a check of the IEC source code can be performed using defined rules, naming conventions, or metrics. As a result, indications of possible development problems are highlighted and errors can be identified and corrected before a field test. This can save a lot of time du...", 
"body" : "With CODESYS Static Analysis , a check of the IEC source code can be performed using defined rules, naming conventions, or metrics. As a result, indications of possible development problems are highlighted and errors can be identified and corrected before a field test. This can save a lot of time during application development and error checking. In CODESYS Static Analysis , more than 100 rules (some of which can be parameterized) are already implemented.These rule can be combined to create customized rule sets. In some rules, the rule sets defined in \"PLCopen Coding Guidelines\" are included. You can also define a naming convention for each possible data type, which is then checked for compliance. Furthermore, more than 20 metrics are available which, if calculated regularly, can analyze the underlying source code and provide indications of negative trends and deviations from quality targets. You can download the CODESYS Static Analysis from CODESYS Store International or CODESYS Store North America . There you will also find the data sheet for the product. The product is subject to licensing. Webinar CODESYS Static Analysis If CODESYS Static Analysis is installed but no license is activated, then a reduced interface with the functionality of Static Analysis Light is displayed. As an alternative to CODESYS Static Analysis , CODESYS Development System provides the Static Analysis Light add-on. The add-on is automatically part of CODESYS when no CODESYS Static Analysis is installed. " }, 
{ "title" : "Static Analysis Light ", 
"url" : "_san_start_page.html#UUID-cc139654-e7d3-fe83-903e-e33f8fd0a5ec_section-idm452529692233763389020840932", 
"breadcrumbs" : "CODESYS Static Analysis \/ CODESYS Static Analysis \/ Static Analysis Light ", 
"snippet" : "Static Analysis Light has a severely limited feature set and provides only 7 compilation checks. The product is freely available. You can enable compilation checks individually in the Project → Project Settings menu, in the Static Analysis Light category. For more information see: Project Settings: ...", 
"body" : "Static Analysis Light has a severely limited feature set and provides only 7 compilation checks. The product is freely available. You can enable compilation checks individually in the Project → Project Settings menu, in the Static Analysis Light category. For more information see: Project Settings: Static Analysis Light " }, 
{ "title" : "Overview ", 
"url" : "_san_overview.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Overview ", 
"snippet" : "Static analysis is performed in the current project only for the application code. Libraries and their source codes are not analyzed. CODESYS Static Analysis helps you during the implementation in order to write better and more readable code and to identify conflicting or unsupported program parts. ...", 
"body" : "Static analysis is performed in the current project only for the application code. Libraries and their source codes are not analyzed. CODESYS Static Analysis helps you during the implementation in order to write better and more readable code and to identify conflicting or unsupported program parts. In particular, potential sources of error are revealed. For example, locations are identified where test code is still contained. Or pointers are found which are not checked for 0 before dereferencing. Or (with the SA0119 rule) the locations are analyzed where object-orientation is used and ports to another development environment, which does not support the object orientation, thus making it impossible. As a reult, the portability of the code can be guaranteed. For errors which are reported by Static Analysis based on precompile information, there is support for an immediate error handling (\"Quickfix\"). This allows you to quickly find and fix the locations in the code which are reported during the analysis. To improve the readability of the source code, you can define naming conventions and check for compliance. Furthermore, to assess the quality of the code, you can view metrics determined from the source code. Examples include the McCabe metric as a measure of code testability, or cognitive complexity as a measure of source code readability and maintainability. The data flow analysis performed in the static analysis is based on the principle of constant propagation. With the Create → Perform Static Analysis menu command, you explicitly activate the static analysis. In the Settings dialog, you enable a static analysis which is automatically performed after each code compilation. You use pragma statements to exclude individual parts or blocks of code from the analysis. In the Rules dialog, you can find out which rules are configured, how they are activated, and when the checks run on the respective rule. There you activate the rules which are relevant for you. In the Naming Conventions dialog, you assign a prefix to each data type as it is then expected in the declarations. Deviations are reported. In the Static Analysis Settings: Metrics dialog, you activate the metrics relevant for you. With the Show Cognitive Complexity for Current Editor command, the determined increments are displayed line by line in the active editor. The Show Values of Constant Propagation for Current Editor command analyzes the data flow in the active editor in detail and displays it path by path. Depending on this, code improvements are possible. For more information, see: Rules, Metrics, and Pragmas and Attributes" }, 
{ "title" : "Configuring and Running Static Analysis ", 
"url" : "_san_configuring_and_running.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configuring and Running Static Analysis ", 
"snippet" : "Using a basic sample project below, you will find the most important steps and options for configuring and running a static analysis. Requirements: CODESYS Static Analysis is installed....", 
"body" : "Using a basic sample project below, you will find the most important steps and options for configuring and running a static analysis. Requirements: CODESYS Static Analysis is installed. " }, 
{ "title" : "Sample project ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-5b7b70fe166a598dc0a864631da88a82", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configuring and Running Static Analysis \/ Sample project ", 
"snippet" : "If you want to reproduce the example project, create a standard project and insert the POUs below the application in the device tree. Then configure the communication settings for the connection to your local CODESYS Control Win . FUNCTION_BLOCK fb1 VAR_INPUT iVar_fb1in1 : INT; ivar_fb1in2 : INT; rV...", 
"body" : "If you want to reproduce the example project, create a standard project and insert the POUs below the application in the device tree. Then configure the communication settings for the connection to your local CODESYS Control Win . FUNCTION_BLOCK fb1\nVAR_INPUT\n iVar_fb1in1 : INT;\n ivar_fb1in2 : INT;\n rVar_fb1in3 : REAL;\nEND_VAR\nVAR_OUTPUT\n iVar_fb1out:INT;\nEND_VAR\nVAR\n P_fSampleProperty : INT;\n rVar : REAL;\n PRO : BOOL;\nEND_VAR\n iVar_fb1out:=iVar_fb1in1 + 1; FUNCTION_BLOCK fb2\nVAR_INPUT\n iVar_fb2in:INT;\nEND_VAR\nVAR_OUTPUT\n iVar_fb2out:INT;\nEND_VAR\nVAR\nEND_VAR\n iVar_fb2out:=iVar_fb2in - 1; PROGRAM PLC_PRG\nVAR\n fb1_inst: fb1;\n fb2_inst: fb2;\nEND_VAR fb1_inst(iVar_fb1in1 := 99);\nfb2_inst(iVar_fb2in := 22);\nfb2_inst(iVar_fb2in := 1); " }, 
{ "title" : "Checking for compliance to rules ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-9641312f166a598dc0a864630126d291", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configuring and Running Static Analysis \/ Checking for compliance to rules ", 
"snippet" : "Click Build → Static Analysis → Settings . Switch to the Rules tab . A list is displayed containing all possible rule checks. They are organized in a tree structure by topical category. The \"rule number\" is added in brackets (example: Unused variables (33) in category Unused objects ). Click the che...", 
"body" : "Click Build → Static Analysis → Settings . Switch to the Rules tab . A list is displayed containing all possible rule checks. They are organized in a tree structure by topical category. The \"rule number\" is added in brackets (example: Unused variables (33) in category Unused objects ). Click the check box of the first line a few times ( Rules node). Clicking toggles the activation status. The check boxes in the entire tree have a red or orange check mark, or no check mark at all. In this way, activate all entries with a red check mark. This means that CODESYS Static Analysis should report any detected rule violations as errors. Click Build → Static Analysis → Run Static Analysis . Errors are reported in the message view. The message texts are tagged with a and begin with the error number \"SA<rule number>\". Double-click the message SA0033: Unused variables 'iVar_fb2out' . The focus moves to the declaration part of function block fb2 and the relevant variable is selected. The variable is declared, but not used. This is checked in Rule 33 ( Unused variables ). In the code, the relevant locations are underlined with a wavy line. To test the automatic execution of the analysis, click Build → Static Analysis → Settings . On the Settings tab, select the Perform static analysis automatically after compilation option. Click OK to exit the dialog. Click Online → Login . A dialog prompt indicates that compile errors exist. The errors reported by the code analysis are displayed again in the message view. Click Build → Static Analysis → Settings . Switch to the Rules tab. Now clear all of the rules in the dialog. In the Unused Objects category, explicitly activate Rule SA0035 ( Unused input variables (35) ) with an orange-colored check mark to report a \"warning\". See the tooltip for the rule text: This rule corresponds to the following PLCopen rules: CP24 ). Click OK to exit the dialog. Click Build → Generate Code . The analysis is performed automatically. In the message view, two errors are reported to the Static analysis messages category: § SA0035: Unused input 'iVar_fb1in2' § SA0035: Unused input 'iVar_fb1in3' Double-click the message and comment or remove the declaration. Perform the code analysis again. No error messages are displayed. " }, 
{ "title" : "Checking for compliance to defined naming conventions ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-d64b88b5166a598dc0a864632e22b38d", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configuring and Running Static Analysis \/ Checking for compliance to defined naming conventions ", 
"snippet" : "Click Build → Static Analysis → Settings . Switch to the Naming Conventions tab. You see a table in a tree structure that is divided into expandable categories of variables and program blocks. Expand the Prefixes for Variables – Prefixes for Types category, and in the Prefix column, specify I for IN...", 
"body" : "Click Build → Static Analysis → Settings . Switch to the Naming Conventions tab. You see a table in a tree structure that is divided into expandable categories of variables and program blocks. Expand the Prefixes for Variables – Prefixes for Types category, and in the Prefix column, specify I for INT (14) . Expand the Prefixes for POUs – Prefixes for POU Type category. In the Prefix column, specify the prog for PROGRAM (122) and fb for FUNCTIONBLOCK (103) . Select the First character after prefix should be an upper case letter option. Clear all other options. Click Build → Static Analysis → Run Static Analysis . Error messages: NC0102: Invalid name 'PLC_PRG': Expect prefix 'prog' because PLC_PRG does not have the required prefix First character after prefix should be uppercase: 'ivar_fb1in2' because ivar_fb1in2 : INT; is in fb1 . NC0014: Invalid variable name P_fSampleProperty: Expect prefix 'i' because this integer variable does not have the required prefix. " }, 
{ "title" : "Checking for forbidden symbols ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-7e83abe1166a598dc0a86463714e1dc5", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configuring and Running Static Analysis \/ Checking for forbidden symbols ", 
"snippet" : "Click Build → Static Analysis → Settings . Switch to the Forbidden Symbols tab . A line editor allows for specifying strings that should not to be used in the code. As an example, double-click the blank line and type in the invalid string PRO directly. Double-click the next blank line and click the ...", 
"body" : "Click Build → Static Analysis → Settings . Switch to the Forbidden Symbols tab . A line editor allows for specifying strings that should not to be used in the code. As an example, double-click the blank line and type in the invalid string PRO directly. Double-click the next blank line and click the button to open the Input Assistant. From Standard Types , select REAL . Click OK to exit the dialog. Click Build → Static Analysis → Run Static Analysis . The error messages Forbidden symbol 'REAL' and Forbidden symbol 'PRO' are displayed in the message view. Double-click the message text to jump to the relevant line of code. " }, 
{ "title" : "Displaying of metrics ", 
"url" : "_san_configuring_and_running.html#UUID-54bd5840-1ce4-2828-8fc4-9df69525c3e7_id_bbda0f56cc82c0a8646374210c71-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ Configuring and Running Static Analysis \/ Displaying of metrics ", 
"snippet" : "CODESYS Static Analysis performs selected tests on the code, and you can display the results in a view. Click Build → Static Analysis → Settings . Switch to the Metrics tab . The metrics that CODESYS Static Analysis applies to the code are listed in a table. For this example, activate the Number of ...", 
"body" : "CODESYS Static Analysis performs selected tests on the code, and you can display the results in a view. Click Build → Static Analysis → Settings . Switch to the Metrics tab . The metrics that CODESYS Static Analysis applies to the code are listed in a table. For this example, activate the Number of inputs variables metric and specify the permitted value range: lower limit 1 and upper limit 2 . Activate some more metrics, for example Code size and Number of calls . Click Build → Static Analysis → View Standard Metrics . The view includes a table with a line for each Program unit of the sample program. For each activated metric, there is a column showing the measured values. Values that are outside of the value range defined in the settings are highlighted in red. In the case of this specific example, this is at least the PLC_PRG\/Inputs field because the number of input variables in this POU is greater than the defined upper limit of 2 . " }, 
{ "title" : "Quickfix of Rule Violations in ST Code ", 
"url" : "_san_fix_errors_quickly.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Quickfix of Rule Violations in ST Code ", 
"snippet" : "In the Static Analysis Settings dialog, on the Rules tab, you can enable rules for ST code. The compliance of these rules is checked based on precompile information. No explicit call of the static analysis is necessary for detecting any such rule violations. Compliance with the rules is checked in t...", 
"body" : "In the Static Analysis Settings dialog, on the Rules tab, you can enable rules for ST code. The compliance of these rules is checked based on precompile information. No explicit call of the static analysis is necessary for detecting any such rule violations. Compliance with the rules is checked in the active ST editor during precompile and after a successful compile. When a rule violation occurs, it is displayed immediately in the ST editor by a wavy underline. Moreover, in the message view, error messages or warnings are listed in the Precompile view. For instructions, see: Checking for compliance to defined naming conventionsYou can find the Quickfix either in the ST editor by clicking the code with the wavy underline and then clicking the light bulb symbol , or in the message view by means of the button in the error message line. In each case, you are provided with the corresponding commands for handling the rule violation. For the Quickfix, the following commands are provided, each depending on the error: Ignore error\/warning The command is used to automatically insert pragmas or attributes into the code, which exclude a check of the corresponding rule for this line of code. Ignore error\/warning globally for <programming object name> The command is used to automatically insert an attribute at the beginning of the declaration part of the programming object. Then a check of the corresponding rule for this programming object is excluded. Command with a suggestion on how to change the ST code to avoid the rule violation (Quickfix). Example: SA0168: Remove assignment 'enum1 := 5' Switch off check The command is used to disable the check of the corresponding rule in the settings. You can undo the effects of calling any of the commands. To do this, first click in the Devices view (or POUs view). Then the Undo command is enabled. " }, 
{ "title" : "Enabling of rules ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-1cca77b1336bf579c0a8646302e5e6f3", 
"breadcrumbs" : "CODESYS Static Analysis \/ Quickfix of Rule Violations in ST Code \/ Enabling of rules ", 
"snippet" : "Click Build → Static Analysis → Settings . Switch to the Rules tab. A list is displayed containing all possible rule checks. They are organized in a tree structure by topical category. The \"rule number\" is added in brackets. You can filter the rules, sort them by options, or display them in a list. ...", 
"body" : "Click Build → Static Analysis → Settings . Switch to the Rules tab. A list is displayed containing all possible rule checks. They are organized in a tree structure by topical category. The \"rule number\" is added in brackets. You can filter the rules, sort them by options, or display them in a list. Click the Structured display filter ( symbol), and then select the Structured by Moment of Execution option. The rules that can also be checked during the precompile are listed below the Executed during precompile and after a successful compile node. These are the rules that are identified by a check mark in the Precompile column. In the column on the left, you can now enable the rule for the check. Click the check box in the line of rule (168) so that the state changes from \"red check mark\" to \"yellow check mark\" to \"no check mark\". A red check mark means that the rule violation is issued as an error message. A yellow check mark means that the rule violation is issued as a warning. No check mark means that the rule is not checked. The enabled rules are now checked. In the case of violation, they are marked in the code and displayed in the message view. " }, 
{ "title" : "Displaying rule violations in the message view ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-8f3e8ec3336bf579c0a86463654e2139", 
"breadcrumbs" : "CODESYS Static Analysis \/ Quickfix of Rule Violations in ST Code \/ Displaying rule violations in the message view ", 
"snippet" : "Click View → Messages . The message view opens. In the message view, in the list box, select the Precompile category. In this category, only the rule violations are displayed, which have been detected during precompile and after a successful compile, and which you can resolve with Quickfix. The butt...", 
"body" : "Click View → Messages . The message view opens. In the message view, in the list box, select the Precompile category. In this category, only the rule violations are displayed, which have been detected during precompile and after a successful compile, and which you can resolve with Quickfix. The button provides the respective commands for this. " }, 
{ "title" : "Performing a Quickfix ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-8a9adfb3336bf579c0a8646308d0b385", 
"breadcrumbs" : "CODESYS Static Analysis \/ Quickfix of Rule Violations in ST Code \/ Performing a Quickfix ", 
"snippet" : "In the settings, Rule 168 is enabled and a rule violation is displayed in the ST editor. Requirement: At least one line has a wavy underline in the ST code, and the respective SA number is displayed in the message view. Click the line of code with the wavy underline. The symbol is displayed. Click t...", 
"body" : "In the settings, Rule 168 is enabled and a rule violation is displayed in the ST editor. Requirement: At least one line has a wavy underline in the ST code, and the respective SA number is displayed in the message view. Click the line of code with the wavy underline. The symbol is displayed. Click the light bulb symbol. A window with menu commands for error handling opens. You want to fix the error. Therefore you click the command Assignment 'enum1 := GVL.CONST' . Now the line of code is changed automatically, as displayed in the command. The error is fixed. The third command includes a suggestion on how to fix the error by changing the code, depending on the rule violation. The same error handling is possible by clicking the button in the error message line of the message view. " }, 
{ "title" : "Disabling the rule check for one line of code ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-107e44f0336bf579c0a8646347e7d5cc", 
"breadcrumbs" : "CODESYS Static Analysis \/ Quickfix of Rule Violations in ST Code \/ Disabling the rule check for one line of code ", 
"snippet" : "In the settings, Rule 168 is enabled and a rule violation is displayed in the ST editor. Requirement: At least one line has a wavy underline in the ST code, and the respective SA number is displayed in the message view. Click the line of code with the wavy underline. The symbol is displayed. Click t...", 
"body" : "In the settings, Rule 168 is enabled and a rule violation is displayed in the ST editor. Requirement: At least one line has a wavy underline in the ST code, and the respective SA number is displayed in the message view. Click the line of code with the wavy underline. The symbol is displayed. Click the light bulb symbol. A window with menu commands for error handling opens. You do not want to fix the error. Therefore you click the command Ignore error\/warning . Now the line of code is automatically provided with pragmas. The pragmas are used to prevent the line for the affected rule from being checked. An error message or warning is not issued. The command to disable the rule check for the affected line of code is also available by means of the button in the error message line in the message view. " }, 
{ "title" : "Disabling the rule check for one programming object ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-6dee377f336bf579c0a8646357b65fa8", 
"breadcrumbs" : "CODESYS Static Analysis \/ Quickfix of Rule Violations in ST Code \/ Disabling the rule check for one programming object ", 
"snippet" : "In the settings, Rule 168 is enabled and a rule violation is displayed in the ST editor. Requirement: At least one line has a wavy underline in the ST code, and the respective SA number is displayed in the message view. Click the line of code with the wavy underline. The symbol is displayed. Click t...", 
"body" : "In the settings, Rule 168 is enabled and a rule violation is displayed in the ST editor. Requirement: At least one line has a wavy underline in the ST code, and the respective SA number is displayed in the message view. Click the line of code with the wavy underline. The symbol is displayed. Click the light bulb symbol. A window with menu commands for error handling opens. You do not want the programming object to be checked with the specified rule. Therefore you click the second command Ignore error\/warning globally for PLC_PRG . The declaration of the object is now automatically provided with an attribute. The attribute is used to prevent the affected rule from being checked for the object. An error message or warning is not issued. The command to ignore the message is also available by means of the button in the error message line in the message view. " }, 
{ "title" : "Disabling the rule check in general ", 
"url" : "_san_fix_errors_quickly.html#UUID-6fb65508-cb4d-9fda-932c-2a5792e10338_id_d01e550432cabcd4c0a86463077c9ec4-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ Quickfix of Rule Violations in ST Code \/ Disabling the rule check in general ", 
"snippet" : "In the settings, Rule 168 is enabled and a rule violation is displayed in the ST editor. Requirement: At least one line has a wavy underline in the ST code, and the respective SA number is displayed in the message view. Click the line of code with the wavy underline. The symbol is displayed. Click t...", 
"body" : "In the settings, Rule 168 is enabled and a rule violation is displayed in the ST editor. Requirement: At least one line has a wavy underline in the ST code, and the respective SA number is displayed in the message view. Click the line of code with the wavy underline. The symbol is displayed. Click the light bulb symbol. A window with menu commands for error handling opens. You do not want the displayed rule to be checked anymore. Therefore you click the fourth command Switch off check . The rule is disabled in the Static Analysis Settings. Click Build → Static Analysis → Settings . Switch to the Rules tab. Rule 168 is disabled. The command to globally disable the check is also available by means of the button in the error message line in the message view. " }, 
{ "title" : "Defining Naming Conventions ", 
"url" : "_san_define_naming_conventions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Defining Naming Conventions ", 
"snippet" : "In the Static Analysis Settings dialog, on the Naming Conventions tab, define the naming conventions that you will follow in your code. You define prefixes for the identifiers of your POUs, variables, and data types depending on their scopes and qualifiers. Then you can let the Static Analysis check...", 
"body" : "In the Static Analysis Settings dialog, on the Naming Conventions tab, define the naming conventions that you will follow in your code. You define prefixes for the identifiers of your POUs, variables, and data types depending on their scopes and qualifiers. Then you can let the Static Analysis check compliance of the naming conventions. For instructions, see: Checking for compliance to defined naming conventions" }, 
{ "title" : "Defining prefixes ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-291ced2808fb693bc0a8646323d0819d", 
"breadcrumbs" : "CODESYS Static Analysis \/ Defining Naming Conventions \/ Defining prefixes ", 
"snippet" : "In the Static Analysis Settings dialog, on the Naming Conventions tab, define the naming conventions in the input field of the Prefix column. Character literal Example: PRG_ in Prefixes for POUs , Prefixes for POU type , PROGRAM (102) Multiple literals per entry which are separated by a comma Syntax...", 
"body" : "In the Static Analysis Settings dialog, on the Naming Conventions tab, define the naming conventions in the input field of the Prefix column. Character literal Example: PRG_ in Prefixes for POUs , Prefixes for POU type , PROGRAM (102) Multiple literals per entry which are separated by a comma Syntax: <prefix> ( , <next prefix> )* Example: PRG_, PRG in Prefixes for POUs , Prefixes for POU type , PROGRAM (102) Regular expression RegEx which defines a set of prefixes Syntax: @ <expression> Examples: @x[a-dA-D] defines a prefix that begins with x , followed by exactly one character in the set a-dA-D @[A-Za-z][A-Za-z][A-Za-z][A-Za-z0-9] defines a prefix that consists of four characters: The first three characters are letters, and the fourth character can also be a number. " }, 
{ "title" : "Defining prefixes for combinable data types ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-e9a24404c19ad708c0a86463215af896", 
"breadcrumbs" : "CODESYS Static Analysis \/ Defining Naming Conventions \/ Defining prefixes for combinable data types ", 
"snippet" : "The following data types are based on standard data types, existing data types, or function blocks: Pointer: POINTER TO <basic type> Reference: REFERENCE TO <basic type> Array: ARRAY[ <lower index bound> .. <upper index bound> ] OF <basic type> These data types can be nested and mutually combined. W...", 
"body" : "The following data types are based on standard data types, existing data types, or function blocks: Pointer: POINTER TO <basic type> Reference: REFERENCE TO <basic type> Array: ARRAY[ <lower index bound> .. <upper index bound> ] OF <basic type> These data types can be nested and mutually combined. When the Recursive prefixes for combinable data types option is selected, Static Analysis expects recursively combined prefixes for variables of such combinable data types. The prefixes follow the declaration and correspond to the naming conventions defined for the basic data types. Example The following naming conventions have been set: i in Prefixes for variables , INT (26) p in Prefixes for variables , POINTER (26) ref in Prefixes for variables , REFERENCE (27) struct in Prefixes for variables , Structure (32) Recursive prefixes for combinable data types option: The following code violates naming conventions and is difficult to read. PROGRAM plc1\nVAR\n var1 : ARRAY[100..110] OF ARRAY[30..50] OF ARRAY[6..7] OF BOOL;\n var2 : ARRAY[1..3] OF INT;\n var3 : REFERENCE TO INT;\n iVar4 : INT;\n iVar5 : INT;\n var6 : ARRAY[1..3] OF INT := [11, 22, 33];\n var7 : POINTER TO ARRAY[1..3] OF INT;\n var8 : REFERENCE TO INT;\n var9 : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n var0 : ARRAY[0..3] OF S_POLYGONLINE; \/\/ S_POLYGONLINE is a already defined structure\nEND_VAR\n\niVar4 := iVar4 + 1;\nvar8 REF= iVar4;\nvar1[100][30][6] := TRUE;\nvar9.aiPoint1[1] := 99;\nvar7 := ADR(var6);\nvar6[2] := 44;\niVar5 := var7^[2];\nvar0[0] := var9; Static Analysis reports the following violations of naming conventions: NC0102: Invalid name 'plc1': Expected prefix 'PRG_' NC0014: Invalid variable name 'var0': Expected prefix 'astruct' NC0014: Invalid variable name 'var1': Expected prefix 'aaax' NC0014: Invalid variable name 'var2': Expected prefix 'ai' NC0014: Invalid variable name 'var3': Expected prefix 'refi' NC0014: Invalid variable name 'var6': Expected prefix 'ai' NC0014: Invalid variable name 'var7': Expected prefix 'pai' NC0014: Invalid variable name 'var8': Expected prefix 'refi' NC0014: Invalid variable name 'var9': Expected prefix 'struct' " }, 
{ "title" : "Defining prefixes for variables of an alias ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-9f66c39a945e11eab0a0b46479d263a5", 
"breadcrumbs" : "CODESYS Static Analysis \/ Defining Naming Conventions \/ Defining prefixes for variables of an alias ", 
"snippet" : "You can define prefixes for variables of data type Alias as a literal with the placeholder {datatype} . Then Static Analysis expects the prefix of the base data type instead of the placeholder. The Combine scope prefix with data type prefix option has no effect on the use of the prefix {datatype} . ...", 
"body" : "You can define prefixes for variables of data type Alias as a literal with the placeholder {datatype} . Then Static Analysis expects the prefix of the base data type instead of the placeholder. The Combine scope prefix with data type prefix option has no effect on the use of the prefix {datatype} . Example The following naming conventions have been set: s in Prefixes for variables , Prefixes for types , STRING()19 A_{datatype} in Prefixes for variables , Alias (33) Code TYPE A_MESSAGE : STRING[50]; \/\/ base data type is STRING\nEND_TYPE\n\nVAR\n A_sMessage_N1 : A_MESSAGE := 'Robot is running.';\n A_s_Message_N2 : A_MESSAGE := 'Robot has been finished.';\n As_Message_N3 : A_MESSAGE := 'Robot has been stopped.';\n AsMessage_N4 : A_MESSAGE := 'Error 3 has been occured.';\nEND_VAR Static Analysis reports the following violation of naming convention: NC0033: Invalid variable name 'As_Message_N3': Expected prefix 'A_s' NC0033: Invalid variable name 'AsMessage_N4': Expected prefix 'A_s' " }, 
{ "title" : "Defining prefixes for properties ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-e0cda739c19ad708c0a864636e955ca0", 
"breadcrumbs" : "CODESYS Static Analysis \/ Defining Naming Conventions \/ Defining prefixes for properties ", 
"snippet" : "You can define the prefix for POUs of data type PROPERTY as a literal with the placeholder {datatype} . Then Static Analysis expects the prefix of the return data type of the property instead of the placeholder. The Combine scope prefix with data type prefix option has no effect on the use of the pl...", 
"body" : "You can define the prefix for POUs of data type PROPERTY as a literal with the placeholder {datatype} . Then Static Analysis expects the prefix of the return data type of the property instead of the placeholder. The Combine scope prefix with data type prefix option has no effect on the use of the placeholder {datatype} . Example The following naming conventions have been set: fb in Prefixes for variables , Prefixes for types , Function block instance FB_ in Prefixes for POUs , Prefixes for POU type , FUNCTIONBLOCK (103) prop_{datatype} in Prefixes for POUs , Prefixes for POU type , PROPERTY (107) Code FUNCTION_BLOCK blocka \/\/ Invalid function block name\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\nPROPERTY PUBLIC vara : INT \/\/ Invalid property name, return data type is INT\nGet\n vara := iA;\nSet\niA := vara;\n\nPROGRAM plc1\nVAR\n var10 : blocka; \/\/ Invalid variable name of typ function block\n iVar11: INT;\nEND_VAR\n\nvar10();\nIF var10.vara > 500 THEN\n var10.vara := 0;\nEND_IF\niVar11 := var10.vara; Static Analysis reports the following violation of naming conventions: NC0102: Invalid name 'plc1': Expected prefix 'PRG_' NC0031: Invalid variable name 'var10': Expected prefix 'fb' NC0103: Invalid variable name ''blocka': Expected prefix 'FB_' NC0107: Invalid variable name 'blocka.vara': Expected prefix 'prop_i' Code according to naming conventions FUNCTION_BLOCK FB_A\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\nPROPERTY PUBLIC prop_iA : INT\nGet\n prop_iA := iA;\nSet\n iA := prop_iA;\n\nPROGRAM PRG_PLC1\nVAR\n fbA : FB_A;\n iVar11: INT;\nEND_VAR\n\nfbA();\nIF fbA.prop_iA > 500 THEN\n fbA.prop_iA := 0;\nEND_IF\niVar11 := fbA.prop_iA; " }, 
{ "title" : "Defining prefixes for structures ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-ed64228609104c08c0a864630c58c86b", 
"breadcrumbs" : "CODESYS Static Analysis \/ Defining Naming Conventions \/ Defining prefixes for structures ", 
"snippet" : "You can define a general prefix for structures in the project in Prefixes for DUTs , Structure (151) . You can also give a structure a special prefix. The special prefix then overrides the general prefix. The special prefix is defined in the data type declaration of the structure with the pragma {at...", 
"body" : "You can define a general prefix for structures in the project in Prefixes for DUTs , Structure (151) . You can also give a structure a special prefix. The special prefix then overrides the general prefix. The special prefix is defined in the data type declaration of the structure with the pragma {attribute 'nameprefix' := <special prefix> '} . Then start all variables of this structure with this prefix <special prefix> . Example The following naming conventions have been set: struct in Prefixes for variables , Structure (32) S_ in Prefixes for DUTs , Structure (151) Recursive prefixes for combinable data types : Code TYPE S_POLYGONLINE :\nSTRUCT\n aiStart : ARRAY[1..2] OF INT := [-99, -99];\n aiPoint1 : ARRAY[1..2] OF INT;\n aiPoint2 : ARRAY[1..2] OF INT;\n aiPoint3 : ARRAY[1..2] OF INT;\n aiPoint4 : ARRAY[1..2] OF INT;\n aiEnd : ARRAY[1..2] OF INT := [99, 99];\nEND_STRUCT\nEND_TYPE\n\n{attribute 'nameprefix' := 'penta'} \/\/ Pragma to define a special prefix\nTYPE S_PENTA EXTENDS S_POLYGONLINE :\nSTRUCT\n aiPoint5 : ARRAY[1..2] OF INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PRG_Compute\nVAR\n structPolygon : S_POLYGONLINE := (aiStart:=[1,1], aiPoint1:=[5,2], aiPoint2:=[7,3], aiPoint3:=[8,5], aiPoint4:=[5,7], aiEnd:=[1,1]);\n structPentagon : S_PENTAGON := (aiStart:=[0,0], aiPoint1:=[1,1], aiPoint2:=[2,2], aiPoint3:=[3,3], aiPoint4:=[4,4], aiPoint5:=[5,5]);\n structLine0 : S_PENTA;\n pentaLine1 : S_PENTA;\n iXPoint: INT;\n aPoint0: ARRAY [1..2] OF INT;\n aPoint1: ARRAY [1..2] OF INT;\nEND_VAR\n\niXPoint := structPolygon.aiPoint1[1];\naPoint0 := structLine0.aiEnd;\naiPoint1 := pentaLine1.aiEnd; Static Analysis reports the following violation of naming conventions: Invalid variable name 'structLine0': Expected prefix 'penta' " }, 
{ "title" : "Providing other CODESYS Static Analysis projects with naming conventions ", 
"url" : "_san_define_naming_conventions.html#UUID-67319b75-9246-2b41-6a74-cae29f722a98_id_c552d012079a62c6c0a8646337e947d3-id-9116651c166a598dc0a864633542af54", 
"breadcrumbs" : "CODESYS Static Analysis \/ Defining Naming Conventions \/ Providing other CODESYS Static Analysis projects with naming conventions ", 
"snippet" : "Save your naming conventions in a CSA file. You can load and use this file in other CODESYS Static Analysis projects. Saving to a file Click Build → Static Analysis → Settings . Click the Save button. A file selection dialog opens. There you can store the naming conventions in a file under any name ...", 
"body" : "Save your naming conventions in a CSA file. You can load and use this file in other CODESYS Static Analysis projects. Saving to a file Click Build → Static Analysis → Settings . Click the Save button. A file selection dialog opens. There you can store the naming conventions in a file under any name with the file extension CSA. Loading a file with naming conventions Click Build → Static Analysis → Settings . Click the Load button. The file selection dialog opens. Select one of the CSA files displayed below. " }, 
{ "title" : "Detecting Code Clones ", 
"url" : "_san_find_code_clone.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Detecting Code Clones ", 
"snippet" : "Requirements: CODESYS Static Analysis is installed. A CODESYS project is open. The project includes the same code block in at least two programming objects. Click  Build → Static Analysis → Detect Clones . The Clone detection results view opens. Click Results . The detected code clones are displayed...", 
"body" : "Requirements: CODESYS Static Analysis is installed. A CODESYS project is open. The project includes the same code block in at least two programming objects. Click  Build → Static Analysis → Detect Clones . The Clone detection results view opens. Click Results . The detected code clones are displayed as a tree view in a window. If, in addition to identical code clones, there are also code clones with deviations, then these child nodes are highlighted in color in the tree view. In the tree view, select two code clones of a child node and click the Show selected clones button. The two programming objects containing this duplicated code are opened in the editor and displayed in the upper part of the view. The identical code clones are highlighted in light yellow and the code clones with deviations, such as the variable names ivar3 and ivarx in this example, are highlighted in red. To create a function from the identical code clone of the programming object POU_1 , first double-click in the tree view on the row with the code clone of Object POU_1 . The programming object POU_1 opens in the editor, and in the implementation part the four rows are highlighted which contain the duplicated code. When you click the Extract function command in the context menu of the highlighted code block, the code block is extracted from POU_1 and a new method is created from it. The code block in the implementation part of POU_1 is replaced automatically by the call of the method. In the second programming object, you have to remove the code duplicate manually and replace the call of the method. In a later version, the functionality will be extended so that the duplicated code block is extracted automatically from both programming objects, and it can be replaced by the correct function call. " }, 
{ "title" : "Constant Propagation ", 
"url" : "_san_constant_propagation.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Constant Propagation ", 
"snippet" : "With the CODESYS Static Analysis version V5.0.0.0, the analysis of the code is based on constant propagation. The results of constant propagation are used for various checks. For example, it checks if pointers are not equal to 0, or if array indices are out of valid range. You can effectively suppor...", 
"body" : "With the CODESYS Static Analysis version V5.0.0.0, the analysis of the code is based on constant propagation. The results of constant propagation are used for various checks. For example, it checks if pointers are not equal to 0, or if array indices are out of valid range. You can effectively support static analysis just by knowing how this analysis works and what its limitations are. " }, 
{ "title" : "Constant propagation ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078132035233833484992758", 
"breadcrumbs" : "CODESYS Static Analysis \/ Constant Propagation \/ Constant propagation ", 
"snippet" : "Static analysis attempts to determine the value of a variable based on its usage. Example PROGRAM PLC_PRG \/\/Declaration VAR x: INT; bTest: BOOL; END_VAR \/\/Implementation x := 99; IF x < 100 THEN bTest := TRUE; END_IF In the implementation in line 1, the constant propagation records the value 99 for ...", 
"body" : "Static analysis attempts to determine the value of a variable based on its usage. Example PROGRAM PLC_PRG\n\/\/Declaration\nVAR\n x: INT;\n bTest: BOOL;\nEND_VAR \/\/Implementation\nx := 99;\nIF x < 100 THEN\n bTest := TRUE;\nEND_IF In the implementation in line 1, the constant propagation records the value 99 for the variable x to use this value for further analysis. The analysis then recognizes that the expression in the following IF -Statement constant TRUE is. " }, 
{ "title" : "Locally performed constant propagation ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4525765239721633833551650952", 
"breadcrumbs" : "CODESYS Static Analysis \/ Constant Propagation \/ Constant propagation \/ Locally performed constant propagation ", 
"snippet" : "A value is determined only locally in the function block. It is irrelevant how an input is passed. The results of function calls are also irrelevant. Example FUNCTION Func : BOOL \/\/Declaration VAR_INPUT bText : BOOL; END_VAR \/\/Implementation IF bTest THEN Func := OtherFunc(TRUE); END_IF Even if the ...", 
"body" : "A value is determined only locally in the function block. It is irrelevant how an input is passed. The results of function calls are also irrelevant. Example FUNCTION Func : BOOL\n\/\/Declaration\nVAR_INPUT\n bText : BOOL;\nEND_VAR \/\/Implementation\nIF bTest THEN\n Func := OtherFunc(TRUE);\nEND_IF Even if the parameter bTest is set to TRUE on every call, this has no effect on the constant propagation. Even if OtherFunc(TRUE) always returns TRUE , this has no effect on constant propagation. " }, 
{ "title" : "Only temporary variables have initial values. ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4505885763755233833526533567", 
"breadcrumbs" : "CODESYS Static Analysis \/ Constant Propagation \/ Constant propagation \/ Only temporary variables have initial values. ", 
"snippet" : "Static local variables in programs and function blocks have no assumed initial value. The variables keep their values from the last call and can therefore be \"anything\" in principle. Local variables in functions and temporary variables have an initial value on each call. The constant propagation cal...", 
"body" : "Static local variables in programs and function blocks have no assumed initial value. The variables keep their values from the last call and can therefore be \"anything\" in principle. Local variables in functions and temporary variables have an initial value on each call. The constant propagation calculates with this initial value. Example PROGRAM PLC_PRG\n\/\/Declaration\nVAR\n x: INT := 6;\n bTest: BOOL;\nEND_VAR\nVAR_TEMP\n y : INT := 8;\nEND_VAR bText := x < y; The variable y is executed every time PLC_PRG have the value 8. The variable x  , however, not necessarily. Therefore, constant propagation is only used for y assume a value, but not for x . It is recommended to declare variables which are always written first and then read as temporary variables. " }, 
{ "title" : "Constant propagation determines value ranges for numeric data types. ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078129465633833541363136", 
"breadcrumbs" : "CODESYS Static Analysis \/ Constant Propagation \/ Constant propagation \/ Constant propagation determines value ranges for numeric data types. ", 
"snippet" : "To reduce complexity, a range of values with upper and lower limits is determined for each variable. Example PROGRAM PLC_PRG VAR x: INT := 6; bTest: BOOL; y : INT; END_VAR \/\/Implementation IF bTest THEN x := 1; ELSSE x := 100; END_IF IF x = 77 THEN y := 13; END_IF Here the value range [1..100] is de...", 
"body" : "To reduce complexity, a range of values with upper and lower limits is determined for each variable. Example PROGRAM PLC_PRG\nVAR\n x: INT := 6;\n bTest: BOOL;\n y : INT; \nEND_VAR\n \/\/Implementation\nIF bTest THEN\n x := 1;\nELSSE\n x := 100;\nEND_IF\nIF x = 77 THEN\n y := 13;\nEND_IF Here the value range [1..100] is determined for the variable x . As a result, on line 7, the comparison x = 77 is not recognized as a constant expression because 77 is within the range of values. " }, 
{ "title" : "Recurring complex expressions are not recognized as the same variable. ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4581954142281633833566535545", 
"breadcrumbs" : "CODESYS Static Analysis \/ Constant Propagation \/ Constant propagation \/ Recurring complex expressions are not recognized as the same variable. ", 
"snippet" : "Complex expressions may not have a value assigned. If such expressions occur multiple times, then it is helpful to introduce an auxiliary variable. Example PROGRAM PLC_PRG VAR x: DINT; py : POINTER TO INT; y : INT; testArray : ARRAY [0..4] OF DINT; END_VAR \/\/Implementation IF py^ >= 0 AND py^<= 4 TH...", 
"body" : "Complex expressions may not have a value assigned. If such expressions occur multiple times, then it is helpful to introduce an auxiliary variable. Example PROGRAM PLC_PRG\nVAR\n x: DINT;\n py : POINTER TO INT;\n y : INT; \n testArray : ARRAY [0..4] OF DINT; \nEND_VAR\n \/\/Implementation\nIF py^ >= 0 AND py^<= 4 THEN\n x := testArray[py^];\nEND_IF\ny := py^;\nIF y <= 0 AND y <=4 THEN\n x := testArray[y];\nEND_IF On line 2, an error is issued for a possible access via pointer to a value, although the area pointed to by the pointer is checked. If the value is first copied into a local variable and its range is checked, then the constant propagation can determine the range of values for that variable and allows access into the array on line 7. " }, 
{ "title" : "Branching ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4597078204272033833577361725", 
"breadcrumbs" : "CODESYS Static Analysis \/ Constant Propagation \/ Constant propagation \/ Branching ", 
"snippet" : "For branching, individual branches are calculated separately. Value ranges from the individual ranges are then combined to form a new value range. Example \/\/Implementation IF func(TRUE) THEN x := 1; ELSE x := 10; END_IF IF func(FALSE) THEN y := x; ELSE Y := 2*x; END_IF On line 6, x has the range [1....", 
"body" : "For branching, individual branches are calculated separately. Value ranges from the individual ranges are then combined to form a new value range. Example \/\/Implementation\nIF func(TRUE) THEN\n x := 1;\nELSE \n x := 10;\nEND_IF\n\nIF func(FALSE) THEN\n y := x;\nELSE\n Y := 2*x;\nEND_IF On line 6, x has the range [1..10] . After line 11, y has the value range [1..20] ; this results from the union of the two value ranges [1..10] and [2..20] . " }, 
{ "title" : "Conditions ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4505886343398433833583258632", 
"breadcrumbs" : "CODESYS Static Analysis \/ Constant Propagation \/ Constant propagation \/ Conditions ", 
"snippet" : "Example Conditions can restrict the value range of a variable in a code block. Several conditions can be combined. Mutually exclusive conditions can also result in an empty value range. IF y > 0 AND y < 10 THEN x := y; ELSE x:= 0; END_IF IF x < 0 THEN i := 99; END_IF y has the value range [1..9] on ...", 
"body" : "Example Conditions can restrict the value range of a variable in a code block. Several conditions can be combined. Mutually exclusive conditions can also result in an empty value range. IF y > 0 AND y < 10 THEN\n x := y;\nELSE\n x:= 0;\nEND_IF\nIF x < 0 THEN\n i := 99;\nEND_IF y has the value range [1..9] on line 2. This results in the value range [0..9] for x on line 6. Combined with the condition x < 0 , this results in an empty set of possible values for x on line 8. The code is not accessible. The static analysis will report that the condition x < 0 always returns FALSE at this point. " }, 
{ "title" : "Looping ", 
"url" : "_san_constant_propagation.html#UUID-95c01336-46ae-5ad4-6a12-27530d2503c4_section-idm4649940201660833833593476437", 
"breadcrumbs" : "CODESYS Static Analysis \/ Constant Propagation \/ Constant propagation \/ Looping ", 
"snippet" : "Constant propagation will loop code until the values of the variables in the loop no longer change. It is assumed that a loop can be run any number of times. The values determined so far are combined with the previous values. Variables which are changed within the loop have a successively growing ra...", 
"body" : "Constant propagation will loop code until the values of the variables in the loop no longer change. It is assumed that a loop can be run any number of times. The values determined so far are combined with the previous values. Variables which are changed within the loop have a successively growing range. Here, the constant propagation does not take all possible values for ranges, but uses only limits which occur in the code and also the values 0, 1, 2, 3, and 10 because these are often relevant. Example The simplest way to describe the procedure is by example: PROGRAM PLC_PRG\nVAR\n x: DINT;\n i : DINT;\n y : DINT;\nEND_VAR \/\/Implementation\nx := 0;\ny := 0;\nFOR i := 0 TO 5 DO\n x := x + 1;\n y := i;\nEND_FOR The constant propagation knows the following about the loop: i , x , and y are 0 at the beginning of the first execution of the loop. The condition i <= 5 applies to the code in the loop. The condition i > 5 applies to the code after the loop. For the values of the variables in the loop, the constant propagation determines the following values: i x y [0..5] [0..MAXDINT] [0..5] In detail, the following intermediate steps are passed through: Pass i x y 1 0 [0..1] 0 i was initialized with 0; y always gets the same values as i. 2 [0..1] [0..2] [0..1] 6 [0..5] [0..6] [0..5] First, the range [0..6] is actually calculated for i . However, it is known that i < 5 is a condition. Therefore, the value for the code in the loop is limited to this value. 7 [0..5] [0..7] [0..5] 10 [0..5] [0..10] [0..5] x is incremented more and more. From 10 , however, the value is \"rounded up\" to MAXINT . 11 [0..5] [0..MAXDINT] [0..5] MAXDINT + 1 results in MAXDINT As of 11 From the 11th pass, the values in the loop will not change. The propagation is ended. Furthermore, i = 6 applies for the code following this loop. The range [0..6] is determined in the loop and this is combined with the condition i > 5 , which results in exactly the value 6. " }, 
{ "title" : "Reference: User Interface ", 
"url" : "_san_f_reference_user_interface.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Commands ", 
"url" : "_san_struct_reference_commands.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Commands ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Command: Extract function ", 
"url" : "_san_cmd_extract_function.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Commands \/ Command: Extract function ", 
"snippet" : "Extract function Function : The command opens the Extract Function Configuration dialog. The command extracts selected code from the ST editor and creates a new method or function containing this code. The affected code in the ST editor is replaced by a correct call. When code is extracted from a fu...", 
"body" : "Extract function Function : The command opens the Extract Function Configuration dialog. The command extracts selected code from the ST editor and creates a new method or function containing this code. The affected code in the ST editor is replaced by a correct call. When code is extracted from a function block or the child of a function block, a new method is created from the code. When code is extracted from a program or a function, a new function is created from the code. Note also in this context: Detecting Code ClonesCall : Context menu: Refactoring Requirements : When the selected code consists of one or more statements: The selected code does not contain any compile errors. The selected code is located in the implementation part of an ST POU. The selected code does not contain any exiting jumps Examples of exiting jumps include the following: Using RETURN to exit the enclosing function Using CONTINUE or EXIT to exit a loop enclosing the code You can undo the changes that the Extract function command made in your project by positioning the cursor in the device tree and clicking Edit → Undo . Extract Function Configuration Dialog Name Name of the recently created function or method The default name can be changed. Return value Determines the return value of a function if there are multiple output and\/or input\/output parameters Parameter Display of the available POUs Configuration whether the parameters are used as input, output, or input\/output variables : Input variables : Output variables : Input\/Output variables The changes made for Name , Return value , or Parameter are undone. Upper code window Recently created code of the call location Lower code window Recently created code of the function or method OK The displayed code changes are accepted in the ST POUs and the dialog is closed. Cancel The displayed code changes are rejected and the dialog is closed. " }, 
{ "title" : "Command: Invert IF Statement ", 
"url" : "_san_cmd_invert_if_statement.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Commands \/ Command: Invert IF Statement ", 
"snippet" : "Invert IF Statement Function : This command inverts the IF statement without changing the semantics of the IF statement. The condition is negated. The statements in the THEN and ELSE branches are swapped. All comments are retained. Call : Context menu under Refactoring command Requirement: The curso...", 
"body" : "Invert IF Statement Function : This command inverts the IF statement without changing the semantics of the IF statement. The condition is negated. The statements in the THEN and ELSE branches are swapped. All comments are retained. Call : Context menu under Refactoring command Requirement: The cursor is positioned anywhere within an IF statement. Rules for negation Expression Negated Expression Description < >= The comparison on \"less than\" becomes \"greater than\" and vice versa. <= > The comparison on \"less than or equal to\" becomes \"greater than\" and vice versa. = <> The comparison on \"equals\" becomes \"does not equal\" and vice versa. <expression1> AND <expression2> ( NOT <expression1> ) OR ( NOT <expression2> ) Negation according to De Morgan for AND operator <expression1> OR <expression2> (NOT <expression1> ) AND (NOT <expression2> ) Negation according to De Morgan for OR operator <expression> NOT <expression> Standard negation NOT <expression> <expression> No double NOT expression a (*comment*) = b a (*comment*) <> b Comments are retained. This applies especially for swapped operands Example PROGRAM Inversion1\nVAR\n xA, xB, xC : BOOL;\n iVar : INT;\nEND_VAR iVar := 0;\nIF NOT(xA AND xB AND xC) THEN\n\tiVar:= 1; (* IF 1 *)\nELSE\n\tiVar := iVar + 1; (* ELSE counter*)\nEND_IFiVar := 0;\n Code after calling the command with inverted logic with the same semantics: iVar := 0;\nIF (xA AND xB AND xC) THEN\n iVar := iVar + 1; (* ELSE counter*)\nELSE\n iVar:= 1; (* IF 1 *)\nEND_IF " }, 
{ "title" : "Command: Show Values of Constant Propagation for Current Editor ", 
"url" : "_san_cmd_show_values_of_constant_propagation_for_current_editor.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Commands \/ Command: Show Values of Constant Propagation for Current Editor ", 
"snippet" : "Show Values of Constant Propagation for Current Editor Symbol: Function : The command starts the static code analysis and calculates a measured value for the constant propagation of the code in the current editor. The dialog that opens visualizes the result. The analyzed code is listed and the deter...", 
"body" : "Show Values of Constant Propagation for Current Editor Symbol: Function : The command starts the static code analysis and calculates a measured value for the constant propagation of the code in the current editor. The dialog that opens visualizes the result. The analyzed code is listed and the determined measured values are displayed. Call : Build → Static Analysis menu Requirement : A programming object in the ST implementation language is open in the editor. For more information, see: Constant Propagation" }, 
{ "title" : "Dialog: Results of Constant Propagation ", 
"url" : "_san_cmd_show_values_of_constant_propagation_for_current_editor.html#UUID-948900c6-97a3-c88d-ff29-bca9a5de0d7b_section-idm4549177267643233866303721891", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Commands \/ Command: Show Values of Constant Propagation for Current Editor \/ Dialog: Results of Constant Propagation ", 
"snippet" : "Example...", 
"body" : "Example " }, 
{ "title" : "Command: Run Static Analysis ", 
"url" : "_san_cmd_run_static_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Commands \/ Command: Run Static Analysis ", 
"snippet" : "Run Static Analysis Symbol: Function : The command starts the static analysis for the active application and displays the metrics for all POUs in a table. Call : Build → Static Analysis menu During the code analysis, CODESYS Static Analysis generates code just like the Build → Generate Code command....", 
"body" : "Run Static Analysis Symbol: Function : The command starts the static analysis for the active application and displays the metrics for all POUs in a table. Call : Build → Static Analysis menu During the code analysis, CODESYS Static Analysis generates code just like the Build → Generate Code command. The results of the analysis are displayed as errors and warnings in the message view ( Build category). The numbers refer to the corresponding rules as they are defined in the project settings. The syntax for the displayed messages is SA<rule number>:<rule text> . " }, 
{ "title" : "Command: Settings ", 
"url" : "_san_cmd_settings.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Commands \/ Command: Settings ", 
"snippet" : "Settings Function : The command opens the Static Analysis Settings dialog. Call : Build → Static Analysis menu Requirement : The package CODESYS Static Analysis is installed. A project is open....", 
"body" : "Settings Function : The command opens the Static Analysis Settings dialog. Call : Build → Static Analysis menu Requirement : The package CODESYS Static Analysis is installed. A project is open. " }, 
{ "title" : "Command: View Standard Metrics ", 
"url" : "_san_cmd_view_standard_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Commands \/ Command: View Standard Metrics ", 
"snippet" : "View Standard Metrics Symbol: Function : The command starts the static code analysis for the active application. The default metrics for all programming blocks are then calculated and displayed in a table on the Standard Metrics tab. Call : Build → Static Analysis menu For more information, see: Dis...", 
"body" : "View Standard Metrics Symbol: Function : The command starts the static code analysis for the active application. The default metrics for all programming blocks are then calculated and displayed in a table on the Standard Metrics tab. Call : Build → Static Analysis menu For more information, see: Displaying of metricsMetrics" }, 
{ "title" : "Tab: Standard Metrics ", 
"url" : "_san_cmd_view_standard_metrics.html#UUID-c2310f81-c613-bf67-ba1e-4f10694a38a1_section-idm4622240725232033866114829692", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Commands \/ Command: View Standard Metrics \/ Tab: Standard Metrics ", 
"snippet" : "Example In the Static Analysis Settings: Metrics dialog, you can change the configuration of the metrics. You can disable calculation for a metric. And you can define limiting values for specific metrics. If a value is outside of the configured upper and lower limits, then the field in the table is ...", 
"body" : "Example In the Static Analysis Settings: Metrics dialog, you can change the configuration of the metrics. You can disable calculation for a metric. And you can define limiting values for specific metrics. If a value is outside of the configured upper and lower limits, then the field in the table is highlighted in red. The following commands are provided in the context menu of the table: Calculate Updates the values Copy Table Copies the table to the clipboard The separator is a tab. Print Table Opens the default dialog to set up the print job Export Table Exports the table to a CSV file The separator is a semicolon. Kiviat Diagram Requirement: At least three metrics are enabled which have been defined upper and lower limits. Represents the metrics for the selected function block as a radar chart This visualizes the quality of POU code with respect to a given standard. Each metric is depicted as an axis with its origin at the center (value 0) which radiates outward into three concentric ring zones. The inner ring zone represents the value range below the lower limit defined for the metric. The outer ring represents the value range above the upper limit. The axes of the metrics are distributed uniformly around the circle. The current values of the individual metrics on the axes are connected by a line. In the ideal case, the complete line is located in the middle zone. Configure Opens the table to select the desired metrics This corresponds to the table in the project settings. Open POU Opens the editor with the POU Example Example of a Kiviat diagram for five metrics The name of the metric is displayed at the end of the respective axis and the name of the POU is displayed in the upper right corner of the diagram. " }, 
{ "title" : "Command: Calculate and Export Standard Metrics ", 
"url" : "_san_calculate_and_export_standard_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Commands \/ Command: Calculate and Export Standard Metrics ", 
"snippet" : "Calculate and Export Standard Metrics Function: Calculates and exports the standard metrics directly without displaying the metrics table in the editor. Specify a suitable name for the CSV export file in the standard file dialog. Call: This command is not available in any menu by default. Alternativ...", 
"body" : "Calculate and Export Standard Metrics Function: Calculates and exports the standard metrics directly without displaying the metrics table in the editor. Specify a suitable name for the CSV export file in the standard file dialog. Call: This command is not available in any menu by default. Alternatively, you could also use the Show standard metrics command to display the metrics in the editor. Among other things, the editor provides the Export Table context command. Customizing the Menu Providing the command Click Tools → Customize . The Menu tab opens. First you need to define a menu position for the command. In this case, it makes sense to select an item under the Build → Static Analysis menu. Select the desired position and click the Add Command button. All commands are listed in the Add Command dialog. Select the Static Analysis category on the left side and then the desired command on the right side. Click OK to close the dialog. Then click OK again to close the Customize dialog. The Calculate and Export Standard Metrics command is now available in the Build → Static Analysis menu. " }, 
{ "title" : "Command: Detect clones ", 
"url" : "_san_cmd_find_clones.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Commands \/ Command: Detect clones ", 
"snippet" : "Detect clones Function : The command scans the program code of the open CODESYS project for copied code, and opens the Clone detection results view to display the detected cloned code blocks. In the process, only code blocks larger than a specific size are considered to be clones. Very small chunks ...", 
"body" : "Detect clones Function : The command scans the program code of the open CODESYS project for copied code, and opens the Clone detection results view to display the detected cloned code blocks. In the process, only code blocks larger than a specific size are considered to be clones. Very small chunks of code are not displayed as clones. In this context, also pay attention to Extract function and the Detecting Code Clones instructions. Call : Build → Static Analysis menu Static Analysis context menu Requirement : The CODESYS Static Analysis project is open. Two code positions are considered clones if they have the following properties: Same structural composition Variables have the same data type. Variable names may be different (exception: component access). However, an identifier that is contained multiple times in the code has to be in the same place in both code positions. Literals have the same data type. Literals may be different. A literal that occurs multiple times in the code has to occur at the same place in both code positions. Clone detection results View Summary Tab to display the search results Number of found cloned code sequences Number of statements compared Number of statements in cloned code Clone ratio : Specified as a percentage: Number of statements in cloned code \/ Number of statements compared Results The tab displays the code clones in a tree view and provides commands and filter options. The first occurrence of a duplicate from the set of duplicates is taken as the root node. The background color of the child nodes indicates whether the code is different or completely identical. The same colors mean the \"same code\". The contents of the tree view are sorted in descending order by the number of statements of the duplicated code. Commands and filters on the Results tab Subnodes\/Clone Number of subnodes (statements) in the code block If the number of subnodes is less than 20, then the code clone is not considered. Filter on Object Input field for an Object , by which the clone list is filtered Show selected clones Requirement: Two child nodes of the same parent node are selected. Both programming objects are displayed in the upper part of the view for comparison. In the process, the code duplicates are highlighted and differences (for example, different variable names) are highlighted in a different color. List of code clones Columns Description Subnodes\/Clone Object Position Double-clicking a child node opens the corresponding programming object, and the duplicated code block is selected there. " }, 
{ "title" : "Command: Show Cognitive Complexity for Current Editor ", 
"url" : "_san_cmd_show_cognitive_complexity_for_current_editor.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Commands \/ Command: Show Cognitive Complexity for Current Editor ", 
"snippet" : "Show Cognitive Complexity for Current Editor Symbol: Function : The command starts the static code analysis and calculates a measured value for the cognitive complexity of the code in the current editor. The dialog which opens visualizes the result and specifies the measured value sum in the title. ...", 
"body" : "Show Cognitive Complexity for Current Editor Symbol: Function : The command starts the static code analysis and calculates a measured value for the cognitive complexity of the code in the current editor. The dialog which opens visualizes the result and specifies the measured value sum in the title. The analyzed code is listed and displayed with the detected complexities. Call : Build → Static Analysis menu Requirement : A programming object in the ST implementation language is open in the editor. " }, 
{ "title" : "Dialog: Cognitive Complexity of <POU name>: <calculated measured value> ", 
"url" : "_san_cmd_show_cognitive_complexity_for_current_editor.html#UUID-315a7cbe-83be-ba91-4d86-234b9f3e6fc3_section-idm4549177267643233866303721891", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Commands \/ Command: Show Cognitive Complexity for Current Editor \/ Dialog: Cognitive Complexity of <POU name>: <calculated measured value> ", 
"snippet" : "Example...", 
"body" : "Example " }, 
{ "title" : "Command: Run Static Analysis and export to Sarif file ", 
"url" : "_san_cmd_run_and_export_to_sarif_file.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Commands \/ Command: Run Static Analysis and export to Sarif file ", 
"snippet" : "Run Static Analysis and export to Sarif file Symbol: Function : This command starts the static code analysis and saves the result in a SARIF file. Call : Build → Static Analysis menu A SARIF file (\" Static Analysis Results Interchange Format \") is a machine-readable JSON file with the file extension...", 
"body" : "Run Static Analysis and export to Sarif file Symbol: Function : This command starts the static code analysis and saves the result in a SARIF file. Call : Build → Static Analysis menu A SARIF file (\" Static Analysis Results Interchange Format \") is a machine-readable JSON file with the file extension \" *.sarif.json \" which is created by Static Analysis to store the results in a standardized format.  SARIF is an OASIS standard. This means that various tools and platforms can use it to exchange and process the analysis results. " }, 
{ "title" : "Command-line commands ", 
"url" : "_san_cmd_run_and_export_to_sarif_file.html#UUID-b1a6530c-4103-8c37-7a9e-f6ad763d2402_section-idm235003337576496", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Commands \/ Command: Run Static Analysis and export to Sarif file \/ Command-line commands ", 
"snippet" : "The command can also be executed automatically via CODESYS Scripting . The batch command [\"staticanalysis\", \"runandexportosarif\"] accepts the arguments below. Argument: --sariffile --sariffile=<path to output>; Specify the path where the resulting SARIF file should be written. If you do not specify ...", 
"body" : "The command can also be executed automatically via CODESYS Scripting . The batch command [\"staticanalysis\", \"runandexportosarif\"] accepts the arguments below. Argument: --sariffile --sariffile=<path to output>; Specify the path where the resulting SARIF file should be written. If you do not specify a path, then the file is saved in the folder of the current project. Argument: --rulesfile --rulesfile=<patch to CSA file>; Specify the path to a CSA file which should be used for the static analysis. If you do not specify a path, then the current configuration is used. Example of the call in a Python script system.commands[\"staticanalysis\", \"runandexportosarif\"].execute(\"--sariffile=result.sarif\", \"--rulesfile=rules.csa\") " }, 
{ "title" : "Command: Format ", 
"url" : "_san_cmd_format.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Commands \/ Command: Format ", 
"snippet" : "Format Debug mode This functionality is available only when your CODESYS instance is started in debug mode. To do this, start your instance with the following command line call: codesys.exe --debug Function : The command formats an ST object according to the rules configured in the CODESYS options i...", 
"body" : "Format Debug mode This functionality is available only when your CODESYS instance is started in debug mode. To do this, start your instance with the following command line call: codesys.exe --debug Function : The command formats an ST object according to the rules configured in the CODESYS options in order to improve the readability of the code. Call : Context menu under the Refactoring menu Requirement: An ST editor is open and the cursor is located within a declaration or an implementation. For more information, see: Auto Formatter" }, 
{ "title" : "Dialogs ", 
"url" : "_san_struct_reference_dialogs.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Dialogs ", 
"snippet" : "For the dialogs for the configuration of static code analysis, click Build → Static Analysis → Settings . Requirement: A CODESYS project has to be open....", 
"body" : "For the dialogs for the configuration of static code analysis, click Build → Static Analysis → Settings . Requirement: A CODESYS project has to be open. " }, 
{ "title" : "Dialog: Settings Static Analysis: Settings ", 
"url" : "_san_dlg_settings_static_analysis_settings.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Dialogs \/ Dialog: Settings Static Analysis: Settings ", 
"snippet" : "Settings Function : In the dialog, you select automatic static analysis , and save or load the project settings for static analysis as a CSA file. Project → Project Settings menu, Static Analysis category, Open configuration dialog link Build → Static analysis → Settings menu Requirement : The CODES...", 
"body" : "Settings Function : In the dialog, you select automatic static analysis , and save or load the project settings for static analysis as a CSA file. Project → Project Settings menu, Static Analysis category, Open configuration dialog link Build → Static analysis → Settings menu Requirement : The CODESYS Static Analysis package is installed. A project is open. Perform static analysis automatically : CODESYS Static Analysis performs the code check automatically at each code generation (for example, when the Build → Generate Code command is executed or before a download. : The code check is not performed automatically, but it can be performed explicitly by means of the Build → Static Analysis → Run Static Analysis command. Load Opens the Load Static Analysis Configuration dialog for selecting the project settings for the static analysis as a CSA file in the file system. When you click the Open button, the selected CSA file is loaded. Save Opens the Save Static Analysis Configuration dialog for saving all project settings in the Static Analysis category as a CSA file in the file system. " }, 
{ "title" : "Dialog: Static Analysis Settings: Rules ", 
"url" : "_san_dlg_settings_sa_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Dialogs \/ Dialog: Static Analysis Settings: Rules ", 
"snippet" : "Rules Function : In the dialog, you select the rules that are checked during the static analysis of the source code of a project. For more information, see: Configuring and Running Static AnalysisCall : Project → Project Settings menu, Static Analysis category, Open configuration dialog link Build →...", 
"body" : "Rules Function : In the dialog, you select the rules that are checked during the static analysis of the source code of a project. For more information, see: Configuring and Running Static AnalysisCall : Project → Project Settings menu, Static Analysis category, Open configuration dialog link Build → Static Analysis → Settings menu Requirement : The CODESYS Static Analysis package is installed. A project is open. This tab shows a tree structure of all rules that can be checked during static analysis. By default, every rule is activated, with the exception of SA0016, SA0024, SA0073, SA0101, SA0105, SA0106, SA0133, SA0134, SA0150, SA0162, and all \"strict IEC rules\". Each rule has a unique number. When the rule is checked and a violation is detected, the rule number and an error description are shown in the message view in the Build category in the following format: SA<rule number> , where \"SA\" stands for \"Static Analysis\" (example: \"SA003\" for rule 3). The list of available rules can be extended by specific plug-ins. Filter Input field for the strings to be searched for Rules are grouped by category. Structured by Importance : Sorting by Importance High , Importance Medium , and Importance Low Default : Default structuring of the rules in CODESYS Static Analysis : Rules are displayed as a flat list. By clicking on the corresponding column header, the list can be sorted by rule number, activation\/deactivation, rule-specific configuration, or importance. Some rules that are activated in the dialog can be deactivated temporarily in the application by applying a pragma . When you click the check box, the setting toggles between , , and . When you activate or deactivate a parent node, all child rules are also activated or deactivated, respectively. Columns Rules List of rules with rule number Rule check : The rule is not checked. : If the result of the check is positive, then an error ( ) for the static analysis is issued in the message view. : If the result of the check is positive, then a warning ( ) for the static analysis is issued in the message view. Precompile : Rules which can be checked during precompile are identified by a check mark ( ) in this column. This means that the rules are already checked when the code is entered. An immediate bugfix (Quickfix) is possible for these rules. You can execute an automatic, immediate error handling directly at the affected code positions. : Rules which are not marked are checked only after a successful compile. Rule specific configuration For some rules, you can double-click the field to open a rule-specific dialog to configure the rule. Importance : Importance of the rule: 3 red stars: High 2 orange stars: Medium 1 gray star: Low " }, 
{ "title" : "Dialog: Static Analysis Settings: Naming Conventions ", 
"url" : "_san_dlg_settings_sa_naming_conventions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Dialogs \/ Dialog: Static Analysis Settings: Naming Conventions ", 
"snippet" : "Naming Conventions Function : In the dialog, you define the prefixes for the data types and scopes of variables, as well as prefixes for POUs and user-defined data types (DUTs). Static Analysis checks compliance with the naming conventions. When a convention is not observed, the static analysis repo...", 
"body" : "Naming Conventions Function : In the dialog, you define the prefixes for the data types and scopes of variables, as well as prefixes for POUs and user-defined data types (DUTs). Static Analysis checks compliance with the naming conventions. When a convention is not observed, the static analysis reports an error message in the Messages view. For more information,see: Configuring and Running Static AnalysisCall : Project → Project Settings menu, Static Analysis category, Open configuration dialog link Build → Static analysis → Settings menu Requirement : The CODESYS Static Analysis package is installed. A project is open. The error messages are displayed in the following format: NC <prefix of convention number> : <message text> . NC stands for \"naming convention\". For example, the error message NC0102: Invalid name… means a violation of naming convention 102 for POUs of type PROGRAM . You can use the 'naming' pragma to deactivate naming conventions for individual identifiers . The identifiers can begin with anything, not necessarily with the prefix. Filter Input field for strings to be searched for Table with the naming conventions Names Nodes and elements for which a prefix can be defined. The number in parentheses after each element (for example, PROGRAM (102) ) is the prefix convention number that is reported in the case of noncompliance with a naming convention. Prefix Input field of the prefix Multiple prefixes can be specified by means of comma separation. Example: Prefix for POUs , PROGRAM (102) : prog, PRG_ Prefix for POUs , FUNCTION (103) : fun, FUN_ Regular expressions (RegEx) are also possible for prefixes. To do this, an @ has to be prepended. Example: The name has to begin with x and may contain one character from the scope a-dA-D : @x[a-dA-D] . For variables of type Alias and POUs of type Property , the prefix can be defined with the placeholder {datatype} . Prefixes for variables Organizational node for all variables for which a prefix can be defined dependent on data type or scope. Prefixes for POUs Organizational node for all POU types and method scopes for which a prefix can be defined Prefixes for DUTs Organizational node for the DUT data types (structure, enumeration, alias, or union) for which a prefix can be defined Prefixes for custom types Organizational node for special custom types (particularly those from libraries) You can extend the list with conventions: Click the blank space below it. In the Input Assistant dialog, specify the name of a custom type or select a custom type. To delete a convention, select it and press the Del key. Note: These conventions have priority over the prefixes which are defined with the attribute {attribute 'nameprefix' := '<prefix>'} . Options First character after prefix should be an upper case letter : Static analysis reports an error for a variable when the first character of the variable name after the defined prefix is not an uppercase letter. Combine scope prefix with data type prefix : As its namespace, a variable must have the defined prefix followed by the defined prefix for its data type. Example: The following prefixes are defined: g_ for VAR_GLOBAL , and r for the data type REAL . The code analysis reports errors for global REAL variables that do not have the prefix g_r . : If conventions for the namespace are specified for a variable, then these conventions are taken into account. As a result, any data type conventions are ignored. Example: The following prefixes are defined: g_ for VAR_GLOBAL , and r for the data type REAL . The code analysis reports exclusively errors for global REAL variables that do not have the prefix g_ . Recursive prefixes for combinable data types : Variables of combined data types have to have compound prefixes that follow the defined naming conventions. Example: ppiVariable : POINTER TO POINTER TO INT; The prefix p was defined for variables of data type POINTER , and the prefix I was defined for the data type INT . Static analysis reports errors for all variables of type POINTER TO POINTER TO INT which do not have the prefix ppi . refaiVar : REFERENCE TO ARRAY[1..3] OF INT; The prefix ref was defined for the data type REFERENCE TO , the prefix a for an array, and the prefix I for the data type INT . Static analysis reports errors for all variables of type REFERENCE TO ARRAY[1..3] OF INT which do not have the prefix refai . Example The following naming convention corresponds for the most part to the recommendations which are described in CODESYS for the \"identifiers\". Example The naming convention (1) refers to the standard POU TON . As a result, declarations of the special library POU are checked for the prefix \"ton_\". Click the blank space (2) to insert more naming conventions. " }, 
{ "title" : "Dialog: Static Analysis Settings: Metrics ", 
"url" : "_san_dlg_settings_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Dialogs \/ Dialog: Static Analysis Settings: Metrics ", 
"snippet" : "Static Analysis Settings: Metrics Symbol: Function : Configures the metrics so that they are calculated and displayed accordingly when the View Standard Metrics command is executed. Call : Project → Project Settings menu, Static Analysis category, Open configuration dialog link Build → Static Analys...", 
"body" : "Static Analysis Settings: Metrics Symbol: Function : Configures the metrics so that they are calculated and displayed accordingly when the View Standard Metrics command is executed. Call : Project → Project Settings menu, Static Analysis category, Open configuration dialog link Build → Static Analysis → Settings menu Requirement : The CODESYS Static Analysis package is installed. A project is open. For more information, see: Configuring and Running Static AnalysisMetric All selectable Metrics are displayed in the column. Active : The metric is displayed for each POU in the Standard Metrics view following the Build → Static Analysis → View Standard Metrics command. : The metric is not displayed in the Standard Metrics view following the Build → Static Analysis → View Standard Metrics command. Lower Limit Lower value from which the metric is displayed Upper Limit Upper value to which the metric is displayed The Code size , Variable size , Stack size , and Number of calls metrics are reported only for POUs from libraries which are integrated in the project. Violations of the upper and lower limits of the activated metrics can be reported as build errors by means of static analysis rule SA0150 . " }, 
{ "title" : "Dialog: Static Analysis Settings: Forbidden Symbols ", 
"url" : "_san_dlg_settings_sa_forbidden_symbols.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Dialogs \/ Dialog: Static Analysis Settings: Forbidden Symbols ", 
"snippet" : "Forbidden Symbols Function : In the dialog, you define the keywords and symbols that must not be used in the project code. For more information,see: Configuring and Running Static AnalysisCall : Project → Project Settings menu, Static Analysis category, Open configuration dialog link Build → Static ...", 
"body" : "Forbidden Symbols Function : In the dialog, you define the keywords and symbols that must not be used in the project code. For more information,see: Configuring and Running Static AnalysisCall : Project → Project Settings menu, Static Analysis category, Open configuration dialog link Build → Static analysis → Settings menu Requirement : The CODESYS Static Analysis package is installed. A project is open. Input line Double-clicking the line opens the line editor for specifying a keyword or symbol. : The Input Assistant opens for selecting the keyword or symbol. " }, 
{ "title" : "Dialog: Options: Auto Formatter ", 
"url" : "_cds_dlg_options_smart_code.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Dialogs \/ Dialog: Options: Auto Formatter ", 
"snippet" : "Auto Formatter Debug mode This functionality is available only when your CODESYS instance is started in debug mode. To do this, start your instance with the following command line call: codesys.exe --debug Symbol: Function : The automatic formatting of the IEC code is configured in this dialog. Call...", 
"body" : "Auto Formatter Debug mode This functionality is available only when your CODESYS instance is started in debug mode. To do this, start your instance with the following command line call: codesys.exe --debug Symbol: Function : The automatic formatting of the IEC code is configured in this dialog. Call : Tools → Options menu, Auto Formatter category " }, 
{ "title" : "Auto Formatter ", 
"url" : "_cds_dlg_options_smart_code.html#UUID-ed744990-e58a-afa4-07c6-a11c0254c4c0_section-idm4605775334425634132064038043", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: User Interface \/ Dialogs \/ Dialog: Options: Auto Formatter \/ Auto Formatter ", 
"snippet" : "General Declaration and implementation Squash empty lines true (default): Blank lines are removed. false : Blank lines are retained. Interface Declaration Align variable types true (default): All types in a variable block are arranged so that they start with the same line depth. false : Align variab...", 
"body" : "General Declaration and implementation Squash empty lines true (default): Blank lines are removed. false : Blank lines are retained. Interface Declaration Align variable types true (default): All types in a variable block are arranged so that they start with the same line depth. false : Align variable initializations true (default): All initializations in a variable block are arranged so that they start with the same line depth. false : Align variable trailing comments true (default): All comments which are located in the same line as the variable declaration start at the same line depth. false : Invocations All calls are formatted when the maximum values are exceeded.  Example: Max. number of parameters before line break The number of parameters which a single-line call can contain is limited. Example: 4 (default) Max. char length of parameters before line break The number of characters in the parameter name is limited. Example: 300 (default) " }, 
{ "title" : "Reference: Programming ", 
"url" : "_san_f_reference_programming.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Pragmas and Attributes ", 
"url" : "_san_struct_reference_pragmas.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Pragmas and Attributes ", 
"snippet" : "CODESYS Static Analysis provides pragmas and attributes for activating or deactivating individual rules or naming conventions for static code analysis. Requirement: The rules or conventions are activated or defined in the project settings. Attributes are inserted in the declaration part of a POU to ...", 
"body" : "CODESYS Static Analysis provides pragmas and attributes for activating or deactivating individual rules or naming conventions for static code analysis. Requirement: The rules or conventions are activated or defined in the project settings. Attributes are inserted in the declaration part of a POU to deactivate specific rules for an entire programming object. Pragmas are used in the implementation part of a POU to deactivate specific rules for individual lines of code. One exception is Rule 164, which can also be switched off in the declaration part. Rules that are deactivated in the project settings cannot be activated by means of pragmas or attributes. Rule SA0004 cannot be deactivated by means of a pragma or an attribute. " }, 
{ "title" : "Pragma: analysis ", 
"url" : "_san_pragma_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Pragmas and Attributes \/ Pragma: analysis ", 
"snippet" : "This pragma is used to deactivate the code rules for individual code lines of a POU so that they are excluded from the static analysis . You deactivate code rules by specifying the rule numbers with a prepended minus sign (\"-\"). A prepended plus sign (\"+\") activates the rule. You can specify any num...", 
"body" : "This pragma is used to deactivate the code rules for individual code lines of a POU so that they are excluded from the static analysis . You deactivate code rules by specifying the rule numbers with a prepended minus sign (\"-\"). A prepended plus sign (\"+\") activates the rule. You can specify any number of rules in the pragma. Insert location : Deactivation: In the implementation part, with {analysis - ...} before the first code line where the code analysis is deactivated. Activation: With {analysis + ...} after the last line of the deactivation. For Rule 164, the pragma can also be inserted in the declaration part before a comment. Syntax: Deaktivierung von Regeln:\n\n{analysis -<rule number> ( , -<further rule number> )* }\n* : optional none, one or more further rule numbers Aktivierung von Regeln:\n\nanalysis +<rule number> ( , +<further rule number> )* }\n* : none, one or more further rule numbers Example Rule 24 is deactivated for two lines and then reactivated. As a result, rule 24 is not checked in these lines so that nTest:=DINT#99 is allowed for example. {analysis -24}\nnTest := 99;\niVar := INT#2;\n{analysis +24} Deactivating multiple rules: {analysis -10, -24, -18} " }, 
{ "title" : "Attribute: analysis ", 
"url" : "_san_attribute_analysis.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Pragmas and Attributes \/ Attribute: analysis ", 
"snippet" : "The attribute deactivates specific rules for an entire programming object so that they are excluded from the static analysis . You deactivate the code rules by specifying the rule numbers with a prepended minus sign (\"-\"). You can specify any number of rules in the attribute. Insert location : In th...", 
"body" : "The attribute deactivates specific rules for an entire programming object so that they are excluded from the static analysis . You deactivate the code rules by specifying the rule numbers with a prepended minus sign (\"-\"). You can specify any number of rules in the attribute. Insert location : In the declaration part of a POU, in the first line. Syntax : {attribute 'analysis' := '-<rule number> ( , -<further rule number> )* '}\n* : none, one or more further rule numbers Example Rules 33 and 31 are deactivated for the entire structure: {attribute 'analysis' := '-33, -31'}\nTYPE My_Structure :\nSTRUCT\n iLocal : INT;\n uiLocal : UINT;\n udiLocal : UDINT;\nEND_STRUCT\nEND_TYPE Rule 100 is deactivated for the array: {attribute 'analysis' := '-100'}\nPROGRAM PLC_PRG\nVAR\n aBigData: ARRAY[1..10000] OF DWORD;\n aBigDATA_2: ARRAY[1..10000] OF DWORD;\nEND_VAR\n; " }, 
{ "title" : "Attribute: 'naming' ", 
"url" : "_san_attribute_naming.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Pragmas and Attributes \/ Attribute: 'naming' ", 
"snippet" : "The attribute marks the code lines that are excluded from the analysis of naming convention . An off is assigned to the pragma attribute before the first code line where the code analysis is deactivated. An on is assigned after the last line. When an omit is assigned, only the next code line is igno...", 
"body" : "The attribute marks the code lines that are excluded from the analysis of naming convention . An off is assigned to the pragma attribute before the first code line where the code analysis is deactivated. An on is assigned after the last line. When an omit is assigned, only the next code line is ignored. Insert location : Deactivation: In the declaration part of POUs and DUTs, above the affected lines. Activation: Below the affected lines. Syntax : {attribute 'naming' := '<switch state>'}\n<switch state> : on | off | omit\non : naming is switched on\noff : naming is switched off\nomit : only next codeline is switched off Example Defined naming conventions: 1) INT variable names must be prepended with \"int\" as the identifier prefix, for example \"intVar1\". (2) Program names have to begin with \"prog\". For the code presented below, the static analysis issues messages only for the following variables: cccVar , aVariable , and bVariable . VAR\n{attribute 'naming' := 'off'}\n iVarA : INT;\n iVarB : INT;\n{attribute 'naming' := 'on'}\n iVarC : INT;\nEND_VAR VAR\n ...\n{attribute 'naming' := 'omit'}\n iVarC : INT;\n...\nEND_VAR {attribute 'naming' := 'omit'}\nPROGRAM PLC_PRG\nVAR\n...\nEND_VAR {attribute 'naming' := 'off'}\nPROGRAM DoSomethingA\nVAR\n{attribute 'naming' := 'on'}\n iVarA : INT;\n iVarB : INT;\n …\nVAR_END " }, 
{ "title" : "Attribute: nameprefix ", 
"url" : "_san_attribute_nameprefix.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Pragmas and Attributes \/ Attribute: nameprefix ", 
"snippet" : "nameprefix The attribute defines a prefix for variables of a structured data type. The prefix must be prepended to the identifier of variables that are declared by this type. The static analysis checks this naming convention. Insert location : In the line before the declaration of a structured data ...", 
"body" : "nameprefix The attribute defines a prefix for variables of a structured data type. The prefix must be prepended to the identifier of variables that are declared by this type. The static analysis checks this naming convention. Insert location : In the line before the declaration of a structured data type Syntax : {attribute 'nameprefix' := '<prefix>'} Example In the following example, Static Analysis issues a message for pB because the variable name does not begin with \"point\". {attribute 'nameprefix' := 'point'}\nTYPE DATAPOINT :\nSTRUCT\n iX: INT;\n iY: INT;\nEND_STRUCT\nEND_TYPE\n\nPROGRAM PLC_PRG\nVAR\n pointA : DATAPOINT;\n pB : DATAPOINT;\nEND_VAR\npointA.iX := 1;\npointA.iY := 10;\npB.iX := 2;\npB.iY := 20; Error message after static analysis: Invalid variable name 'pB': Expected prefix 'point' " }, 
{ "title" : "Attribute: analysis:report-multiple-instance-calls ", 
"url" : "_san_attribute_analysis_report_multiple_instance_calls.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Pragmas and Attributes \/ Attribute: analysis:report-multiple-instance-calls ", 
"snippet" : "analysis:report-multiple-instance-calls The attribute marks a function block for checking for rule rule 105 : Only function blocks with this attribute are checked whether the function block instances are called more than one time. When rule 105 is deactivated in the project settings , the attribute ...", 
"body" : "analysis:report-multiple-instance-calls The attribute marks a function block for checking for rule rule 105 : Only function blocks with this attribute are checked whether the function block instances are called more than one time. When rule 105 is deactivated in the project settings , the attribute does not have any effect. Insert location : Top line in the declaration part of a function block. Syntax : {attribute 'analysis:report-multiple-instance-calls'} Example \/\/ {attribute 'analysis:report-multiple-instance-calls'} deactivated\nFUNCTION_BLOCK FB_DoA\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\niA := iA + 1;\n\n{attribute 'analysis:report-multiple-instance-calls'}\nFUNCTION_BLOCK FB_DoB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iB : INT;\nEND_VAR\niB := iB +1;\n\nPROGRAM PLC_PRG\nVAR\n fbA : FB_DoA;\n fbB : FB_DoB;\nND_VAR\n\nfbA();\nfbB(); \/\/ SA0105\nfbA();\nfbB(); \/\/ SA0105\n Output under view Messages : SA0105: Instance 'fbB' called several times " }, 
{ "title" : "Rules ", 
"url" : "_san_struct_reference_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0001: Unreachable code ", 
"url" : "_san_rule_sa0001.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0001: Unreachable code ", 
"snippet" : "Detects lines of code which are not executed, for example due to a RETURN or CONTINUE statement Justification: Unreachable code should always be avoided. The test often indicates that test code still exists which should be removed. Importance: High PLCopen rule: CP2 Example PROGRAM PLC_PRG VAR xRetu...", 
"body" : "Detects lines of code which are not executed, for example due to a RETURN or CONTINUE statement Justification: Unreachable code should always be avoided. The test often indicates that test code still exists which should be removed. Importance: High PLCopen rule: CP2 Example PROGRAM PLC_PRG\nVAR\n xReturn_Before_End: BOOL;\n xContinue_In_Loop_FUN: BOOL;\n iCounter: INT;\nEND_VAR\n xContinue_In_Loop_FUN := FALSE;\nFOR iCounter := INT#0 TO INT#5 BY INT#1 DO\n CONTINUE;\n xContinue_In_Loop_FUN := FALSE;\nEND_FOR Output in the Messages view: SA0001: Unreachable code detected in 'PLC_PRG' " }, 
{ "title" : "SA0002: Empty objects ", 
"url" : "_san_rule_sa0002.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0002: Empty objects ", 
"snippet" : "Detects POUs, GVLs, data type declarations, or interfaces that do not contain any code Justification: Empty objects should be avoided. They are often a sign that an object has not been implemented completely. Exception: In some cases, no code is specified in the body of a function block when it shou...", 
"body" : "Detects POUs, GVLs, data type declarations, or interfaces that do not contain any code Justification: Empty objects should be avoided. They are often a sign that an object has not been implemented completely. Exception: In some cases, no code is specified in the body of a function block when it should be used by interfaces only. In other cases, a method is created only because it is required by an interface without a sensible implementation being possible for the method. No matter the case, this kind of situation should be commented. Importance: Medium " }, 
{ "title" : "SA0003: Empty statements ", 
"url" : "_san_rule_sa0003.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0003: Empty statements ", 
"snippet" : "Detects lines of code that have a semicolon ( ; ) but not a statement Justification: An empty statement can be a sign for missing code. Note: There are good reasons for using empty statements. For example, in a CASE statement it can make sense to explicitly program out all cases, even those where th...", 
"body" : "Detects lines of code that have a semicolon ( ; ) but not a statement Justification: An empty statement can be a sign for missing code. Note: There are good reasons for using empty statements. For example, in a CASE statement it can make sense to explicitly program out all cases, even those where there is nothing to do. When this kind of empty CASE statement contains a comment, Static Analysis does not generate an error message. Importance: Low Example CASE value OF\n 1:\n DoSomething();\n 2:\n ;\n 3:\n DoSomethingElse();\nEND_CASE\n Output in the Messages view: SA0003: Empty statements CASE value OF\n 1:\n DoSomething();\n 2:\n ; \/\/nothing to do\n 3:\n DoSomethingElse();\nEND_CASE\n Output in the Messages view: No SA error " }, 
{ "title" : "SA0004: Multiple write access on output ", 
"url" : "_san_rule_sa0004.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0004: Multiple write access on output ", 
"snippet" : "Detects outputs which are written to more than one location. Justification: The maintainability is degraded when an output is written in different locations in the code. Then it is uncertain which write access is the one that actually has an effect in the process. Good practice is to calculate the o...", 
"body" : "Detects outputs which are written to more than one location. Justification: The maintainability is degraded when an output is written in different locations in the code. Then it is uncertain which write access is the one that actually has an effect in the process. Good practice is to calculate the output variables in auxiliary variables and assign the calculated value at one location at the end of the cycle. Importance: High PLCopen rule: CP12 An error is not issued when an output variable ( VAR_IN_OUT ) is written to in different branches of IF and CASE statements. A pragma cannot disable this rule. Example VAR_GLOBAL\n g_xVar AT %QX0.0 : BOOL ;\n g_iTest AT %QW0 : INT ;\nEND_VAR PROGRAM PLC_PRG IF g_iCondition < INT#0 THEN\n g_xVar := TRUE;\n g_iTest := INT#12;\nEND_IF\n\nCASE g_iCondition OF\n INT#1:\n g_xVar := FALSE;\n INT#2:\n g_iTest := INT#11;\n ELSE\n g_xVar := TRUE;\n g_iTest := INT#9;\nEND_CASE\n Output in the Messages view: SA0004: Multiple write access on output '%QX0.0' SA0004: Multiple write access on output '%QW0' " }, 
{ "title" : "SA0006: Write access from several tasks ", 
"url" : "_san_rule_sa0006.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0006: Write access from several tasks ", 
"snippet" : "Detects variables which are written to by more than one task. Justification: A variable which is written in multiple tasks may change its value unexpectedly. This can lead to confusing situations. String variables (and on some 32-bit systems also 64-bit integer variables) can even reach an inconsist...", 
"body" : "Detects variables which are written to by more than one task. Justification: A variable which is written in multiple tasks may change its value unexpectedly. This can lead to confusing situations. String variables (and on some 32-bit systems also 64-bit integer variables) can even reach an inconsistent state if the variable is written to two tasks simultaneously. Exception: In specific cases, it may be necessary for several tasks to write a variable. For example, use semaphores to make sure that access does not lead to an inconsistent state. Importance: High PLCopen rule: CP10 Example VAR_GLOBAL\n g_iTemp1: INT;\nEND_VAR PROGRAM PLC_PRG \/\/ Controlled by MainTask\ng_iTemp1 := g_iTemp1 + INT#2;\n PROGRAM PLC_PRG_1 \/\/Controlled by SubTask\ng_iTemp1 := g_iTemp1 - INT#3; Output in the Messages view: SA0006: Concurrent write access to 'g_iTemp1' in Tasks MainTask, SubTask " }, 
{ "title" : "SA0007: Address operator on constants ", 
"url" : "_san_rule_sa0007.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0007: Address operator on constants ", 
"snippet" : "Detects lines of code where the operator ADR is applied for a constant Justification: Using a pointer to a constant variables overrides the CONSTANT property of the variable. The variable can be changed by means of the pointer without any notification from the compiler. Exception: In rare cases, it ...", 
"body" : "Detects lines of code where the operator ADR is applied for a constant Justification: Using a pointer to a constant variables overrides the CONSTANT property of the variable. The variable can be changed by means of the pointer without any notification from the compiler. Exception: In rare cases, it might be useful to pass a pointer to a constant to a function. However, you need to make sure that this function does not change the transferred value. Whenever possible, use VAR_IN_OUT CONSTANT . Importance: High When the Replace constants option is selected in the Compiler Options of the project settings, the address operator is not permitted for scalar constants (integer, BOOL , REAL ) and a compile error is issued. (Constant strings, structures, and arrays always have an address.) Example PROGRAM PLC_PRG\nVAR CONSTANT\n c_iValue : INT := INT#15;\nEND_VAR\nVAR\n poiValue : POINTER TO INT;\nEND_VAR\n poiValue := ADR(c_iValue); \/\/ SA0007 Output in the Messages view: SA0007: Address to constant variable 'c_iValue' " }, 
{ "title" : "SA0008: Check subrange types ", 
"url" : "_san_rule_sa0008.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0008: Check subrange types ", 
"snippet" : "Detects out-of-range violations of subrange types. Assigned literals are already checked by the compiler. When constants are assigned, then the values must be within the defined range. When variables are assigned, then the data types must be identical. Justification: If subrange types are used, then...", 
"body" : "Detects out-of-range violations of subrange types. Assigned literals are already checked by the compiler. When constants are assigned, then the values must be within the defined range. When variables are assigned, then the data types must be identical. Justification: If subrange types are used, then make sure that this subrange is not exited. The compiler checks for these kinds of subrange violations only for assignments of constants. Importance: Low The check is not performed for CFC objects because the code structure does not allow it. Example VAR_GLOBAL\n iVarGlob:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n iSubr1: INT (INT#1..INT#10);\n iSubr2: INT (INT#1..INT#1000);\n iCount: INT;\n by_SubType : BYTE (BYTE#0..BYTE#11);\n iVar : INT (-4095..4095);\nEND_VAR\n iSubr1 := nCount; \/\/ SA0008\niSubr1 := subr2; \/\/ SA0008\niSubr1 := gvl.iVarGlob; \/\/ SA0008\n\/\/byBYTE_SubType := BYTE#123; \/\/already detected by compiler, error \"Cannot convert type...\" Output in the Messages view: SA0008: Subrange variable 'iSubr1' maybe out of allowed range " }, 
{ "title" : "SA0009: Unused return values ", 
"url" : "_san_rule_sa0009.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0009: Unused return values ", 
"snippet" : "Detects function, method and property calls in which the return value is not used Justification: When a function or method returns a return value, you should also evaluate it. The return value often indicates whether or not the function has been executed successfully. If there is no evaluation, then...", 
"body" : "Detects function, method and property calls in which the return value is not used Justification: When a function or method returns a return value, you should also evaluate it. The return value often indicates whether or not the function has been executed successfully. If there is no evaluation, then you will not be able to identify later whether the return value was forgotten or if it is actually not needed. Exception: If a return value is irrelevant for the call, then you should document this and omit the assignment. Error returns should never be ignored. Importance: Medium PLCopen rule: CP7 \/ CP17 Example FUNCTION Return_BOOL : BOOL\nVAR_INPUT\nEND_VAR\nVAR\n    xTest : BOOL;\nEND_VAR xTest := FALSE;\nReturn_BOOL := xTest; PROGRAM PLC_PRG\nReturn_BOOL();  \/\/ SA0009\n Output in the Messages view: SA0009: Ignoring return value of 'Return_BOOL' " }, 
{ "title" : "SA0010: Arrays with only one component ", 
"url" : "_san_rule_sa0010.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0010: Arrays with only one component ", 
"snippet" : "Detects arrays with only one element Justification: An array with one element can be replaced by a base-type variable. Access to this variable is considerably faster than access by index to the variable. Exception: The length of an array is often determined by a constant and is a parameter for a pro...", 
"body" : "Detects arrays with only one element Justification: An array with one element can be replaced by a base-type variable. Access to this variable is considerably faster than access by index to the variable. Exception: The length of an array is often determined by a constant and is a parameter for a program. Then the program can work with arrays of different lengths and does not have to be changed if the length is only 1. This kind of situation should be documented accordingly. Importance: Low Example PROGRAM PLC_PRG\nVAR\n aoiEmpty : ARRAY [22..22] OF INT := [22];\n aorEmpty : ARRAY [2..2] OF REAL := [2.2];\n iVar : INT;\n rVAR : REAL;\nEND_VAR iVar := aoiEmpty[22];\nrVAR := aorEmpty[2];\n Output in the Messages view: SA0010: Vacuous array element in variable 'aoiEmpty' SA0010: Vacuous array element in variable 'aorEmpty' " }, 
{ "title" : "SA0011: Useless declaration with only a single member ", 
"url" : "_san_rule_sa0011.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0011: Useless declaration with only a single member ", 
"snippet" : "Detects structures or enumerations with only a single member Justification: No structures or enumerations with only a single member should be declared. Such declarations can be confusing for readers. A structure with only one element can be replaced by an alias type. An enumeration with only one ele...", 
"body" : "Detects structures or enumerations with only a single member Justification: No structures or enumerations with only a single member should be declared. Such declarations can be confusing for readers. A structure with only one element can be replaced by an alias type. An enumeration with only one element can be replaced by an constant. PLCopen rule: CP22 \/ CP24 Importance: Low Example {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE SINGLE_ENUM :\n(\n\tOnlyOne := 1\n);\nEND_TYPE TYPE SINGLE_UNION :\nUNION\n\tlrValue : LREAL;\nEND_UNION\nEND_TYPE {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE SINGLE_ENUM :\n(\n\tOnlyOne := 1\n);\nEND_TYPE Output in the Messages view: SA0011: Useless declaration 'SINGLE_ENUM': Struct\/Enum with only a single member should not be used SA0011: Useless declaration 'SINGLE_UNION': Struct\/Enum with only a single member should not be used SA0011: Useless declaration 'SINGLE_STRUCT': Struct\/Enum with only a single member should not be used " }, 
{ "title" : "SA0012: Variable which could be declared as constants ", 
"url" : "_san_rule_sa0012.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0012: Variable which could be declared as constants ", 
"snippet" : "Detects variables which are not accessed with write permission and therefore could be declared as constants Justification: If a variable is written only at the declaration point and is otherwise used only for reading, then the static analysis assumes that the variable should also not to be changed. ...", 
"body" : "Detects variables which are not accessed with write permission and therefore could be declared as constants Justification: If a variable is written only at the declaration point and is otherwise used only for reading, then the static analysis assumes that the variable should also not to be changed. Firstly, a declaration as a constant results in checking that the variable is not changed when the program is changed. Secondly, the declaration as a constant may result in faster code. If multiple applications exist in one project, then only the objects below the currently active application are affected. If there is only one application, then the objects in the common POU pool are also affected. Importance: Low Example PROGRAM PLC_PRG\nVAR\n iVar : INT := INT#17;\n iTest : INT;\nEND_VAR\n iTest := iTest + iVar; \/\/ SA0012: 'iVar' could be declared as constant Output in the Messages view: SA0012: Variable 'iVar' could be declared as constant " }, 
{ "title" : "SA0013: Declarations with the same variable name ", 
"url" : "_san_rule_sa0013.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0013: Declarations with the same variable name ", 
"snippet" : "Detects variables with names which are already used by other variables (for example, global and local variables with the same name). Variables are also detected whose names of functions, actions, methods, or properties are used in the same access range. Variables are also detected which are declared...", 
"body" : "Detects variables with names which are already used by other variables (for example, global and local variables with the same name). Variables are also detected whose names of functions, actions, methods, or properties are used in the same access range. Variables are also detected which are declared in a GVL in the Devices view or in the POUs pool. For this, however, the GVL of the POUs view have to be used in the application program. Justification: The same names can be confusing when reading the code, and they can cause errors if the wrong object is accessed unintentionally. We recommend that you use naming conventions to avoid these situations. PLCopen rule: N5 \/ N9 Importance: Medium Example VAR_GLOBAL\n xVar1 : BOOL;\n iVar3 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n xVar1 : BOOL; \/\/ SA0013\n iVar3 : INT; \/\/ SA0013\nEND_VAR\n xVar1 := NOT GVL.xVar1;\niVar3 := iVar3 + INT#2;\niVar3 := GVL.iVar3; Output in the Messages view: SA0013: Declaration of 'iVar1' hides symbol 'GVL.iVar1' SA0013: Declaration of 'xVar3' hides symbol 'GVL.xVar3' Example The FB_Pou function block has the ACT action, the METH method, and local variables with the same names. FUNCTION_BLOCK FB_Pou\nVAR\n ACT : UINT; \/\/ SA0013\n METH : BYTE; \/\/ SA0013\nEND_VAR PROGRAM PLC_PRG\nVAR\n fbPou : FB_Pou;\nEND_VAR\n fbPou(); Output in the Messages view: SA0013: Declaration of 'ACT' hides symbol 'FB_Pou.ACT' SA0013: Declaration of 'METH' hides symbol 'FB_Pou.METH' " }, 
{ "title" : "SA0014: Assignment of instances ", 
"url" : "_san_rule_sa0014.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0014: Assignment of instances ", 
"snippet" : "Detects assignments to function block instances. In the case of instances with pointer or reference variables, these assignments are potentially risky. Justification: This is a performance warning. When an instance is assigned to another instance, all elements and subelements are copied from the one...", 
"body" : "Detects assignments to function block instances. In the case of instances with pointer or reference variables, these assignments are potentially risky. Justification: This is a performance warning. When an instance is assigned to another instance, all elements and subelements are copied from the one instance to the other instance. Pointers to data are also copied, but not their referenced data, so that the target instance and the source instance contain the same data after the assignment. Depending on the size of the instances, this kind of assignment could last a long time. For example, if an instance should be passed to a function for processing, then it is much more efficient to pass a pointer to the instance. If you want to selectively copy values from one instance to another, then a copy method is useful: inst_First.Copy_From(inst_Second) Importance: Medium Example PROGRAM PLC_PRG\nVAR\n inst_First : My_FB;\n inst_Second : My_FB;\nEND_VAR\n inst_First();\ninst_Second := inst_First; \/\/ SA0014 Output in the Messages view: SA0014: Assignment of instances " }, 
{ "title" : "SA0015: Access to global data via FB_Init ", 
"url" : "_san_rule_sa0015.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0015: Access to global data via FB_Init ", 
"snippet" : "Detects the access of a function block to global variables by means of the method FB_Init . The value of this variable depends on the order of initializations. Justification: Depending on the declaration location of the POU instance, an uninitialized variable could be accessed if the rule is violate...", 
"body" : "Detects the access of a function block to global variables by means of the method FB_Init . The value of this variable depends on the order of initializations. Justification: Depending on the declaration location of the POU instance, an uninitialized variable could be accessed if the rule is violated. Importance: High Example VAR_GLOBAL\n g_xTest1 : BOOL;\n g_iTest3 : INT;\nEND_VAR METHOD PUBLIC fb_init : BOOL\nVAR_INPUT\n (* If TRUE, the retain variables are initialized (warm start \/ cold start) *)\n bInitRetains : BOOL; \n (* If TRUE, the instance afterwards gets moved into the copy code (online change) *)\n bInCopyCode : BOOL; \nEND_VAR\n g_xTest1 := NOT g_xTest1; \/\/ SA0015\ng_iTest3 := g_iTest3 + INT#1; \/\/ SA0015 Output in the Messages view: SA0015: FB_Init method of function block 'POU' accesses global data " }, 
{ "title" : "SA0016: Gaps in structures ", 
"url" : "_san_rule_sa0016.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0016: Gaps in structures ", 
"snippet" : "Detects gaps in structures or function blocks which are caused by the alignment requirements of the currently set target system. If possible, you should remove the gaps by resorting the structure elements or filling them with a dummy element. If this is not possible, then you can deactivate the rule...", 
"body" : "Detects gaps in structures or function blocks which are caused by the alignment requirements of the currently set target system. If possible, you should remove the gaps by resorting the structure elements or filling them with a dummy element. If this is not possible, then you can deactivate the rule for the affected structures by means of the analysis pragma. Justification: Due to different alignment requirements on different platforms, there may be a different layout in the memory for these kinds of structures. Then the code can perform differently, depending on the platform. Importance: Low Example TYPE Unpadded_Structure :\nSTRUCT\n xTest : BOOL;\n iTest : INT; \/\/ SA0016\n byTest : BYTE;\n wTest : WORD;\nEND_STRUCT\nEND_TYPE\n PROGRAM PLC_PRG\nVAR\n myStruct : Unpadded_Structure;\nEND_VAR\n myStruct.iTest := 0; Output in the Messages view: SA0016: Structure 'Unpadded_Structure' must be padded (pack-mode=8) " }, 
{ "title" : "SA0017: Unusual assignment to pointer variable ", 
"url" : "_san_rule_sa0017.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0017: Unusual assignment to pointer variable ", 
"snippet" : "Detects assignments to pointers which are neither addresses ( ADR operator, pointer variables) nor constants 0 Justification: If a pointer is assigned a value which is not a valid address, then the dereferencing of the pointer leads to an \"Access Violation Exception\". Importance: High Example PROGRA...", 
"body" : "Detects assignments to pointers which are neither addresses ( ADR operator, pointer variables) nor constants 0 Justification: If a pointer is assigned a value which is not a valid address, then the dereferencing of the pointer leads to an \"Access Violation Exception\". Importance: High Example PROGRAM PLC_PRG\nVAR\n pInt : POINTER TO INT;\n dwAddress : DWORD;\nEND_VAR\n dwAddress := dwAddress + DWORD#1;\npInt := dwAddress; \/\/ SA0017 Output in the Messages view: SA0017: Unusual assignment to pointer variable " }, 
{ "title" : "SA0018: Unusual bit access ", 
"url" : "_san_rule_sa0018.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0018: Unusual bit access ", 
"snippet" : "Detects bit access to signed variables. However, the IEC 61131-3 standard permits only bit access and bit shift operations on bit fields. See also the strict rules SA0147 and SA0148 . Justification: Signed data types should not be used as bit fields and the other way around. The IEC 61131-3 standard...", 
"body" : "Detects bit access to signed variables. However, the IEC 61131-3 standard permits only bit access and bit shift operations on bit fields. See also the strict rules SA0147 and SA0148 . Justification: Signed data types should not be used as bit fields and the other way around. The IEC 61131-3 standard does not provide for this kind of access, and therefore you should comply with this rule when you write portable code. Importance: Medium Exception for flag enumerations: When an enumeration is declared as a flag by means of the {attribute 'flags'} pragma attribute, the SA0018 error is not issued for bit access with the OR , AND or NOT operators. Example PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n diTemp3 : DINT;\n uliTemp4 : ULINT;\n siTemp5 : SINT;\n usiTemp6 : USINT;\n byTemp2 : BYTE;\nEND_VAR\n iTemp1.3 := TRUE; \/\/SA0018\ndiTemp3.4 := TRUE; \/\/SA0018\nuliTemp4.18 := FALSE; \/\/no error because this is an unsigned data type\nsiTemp5.2 := FALSE; \/\/SA0018\nusiTemp6.3 := TRUE; \/\/no error because this is an unsigned data type\nbyTemp2.5 := FALSE; \/\/no error because the byte is a bitfield Output in the Messages view: SA0018: Unusual bit access " }, 
{ "title" : "SA0020: Possibly assignment of truncated value to REAL variable ", 
"url" : "_san_rule_sa0020.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0020: Possibly assignment of truncated value to REAL variable ", 
"snippet" : "Detects operations on integer variables for which a truncated value could be assigned to a REAL data type variable Justification: Static analysis issues an error when the result of an integer calculation is assigned to a REAL or LREAL variable. The programmer should be alerted to a possible incorrec...", 
"body" : "Detects operations on integer variables for which a truncated value could be assigned to a REAL data type variable Justification: Static analysis issues an error when the result of an integer calculation is assigned to a REAL or LREAL variable. The programmer should be alerted to a possible incorrect interpretation of this kind of assignment: lrealvar := dintvar1 * dintvar2 . Because the value range of LREAL is greater than that of DINT , one could assume that the result of the calculation could always be represented in LREAL . But that is not the case. The processor calculates the result of the multiplication as an integer and then casts the result to LREAL . An overflow in the integer calculation would be lost. To work around the problem, the calculation has to be done as a REAL operation: lreal_var := TO_LREAL(dintvar1) * TO_LREAL(dintvar2) . Importance: High Example PROGRAM PLC_PRG\nVAR\n rX : LREAL;\n dI : DINT;\nEND_VAR\n rX := dI * dI \/\/ SA0020\nrX := TO_LREAL(dI) * TO_LREAL(dI) \/\/no message Output in the Messages view: SA0020: Possibly assignment of truncated value to REAL variable " }, 
{ "title" : "SA0021: Transporting the address of a temporary variable ", 
"url" : "_san_rule_sa0021.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0021: Transporting the address of a temporary variable ", 
"snippet" : "Detects address assignments of temporary variables (on the stack) to non-temporary variables Justification: Local variables of a function or method are created on the stack and they exist only while the function or method is being processed. If a pointer points to this kind of variable after process...", 
"body" : "Detects address assignments of temporary variables (on the stack) to non-temporary variables Justification: Local variables of a function or method are created on the stack and they exist only while the function or method is being processed. If a pointer points to this kind of variable after processing the method or function, then you can use this pointer to access undefined memory, or to access an incorrect variable in another function. This situation should be avoided at all costs. Importance: High Example FUNCTION TempVarInFUNC : DWORD\nVAR\n uiTemp : UINT;\nEND_VAR\n TempVarInFUNC := ADR(uiTemp); \/\/SA0021 PROGRAM PLC_PRG\nVAR\n dwTest : DWORD;\nEND_VAR dwTest := TempVarInFUNC(); Output in the Messages view: SA0021: Transporting address of temporary variable to outer scope symbol " }, 
{ "title" : "SA0022: (Possibly) unassigned return value ", 
"url" : "_san_rule_sa0022.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0022: (Possibly) unassigned return value ", 
"snippet" : "Detects all functions and methods that include an execution thread without an assignment to the return value Justification: An unassigned return value in a function or method is an indication of missing code. Even if the return value always has a default value, it is always useful to assign it again...", 
"body" : "Detects all functions and methods that include an execution thread without an assignment to the return value Justification: An unassigned return value in a function or method is an indication of missing code. Even if the return value always has a default value, it is always useful to assign it again explicitly to avoid confusion. Importance: Medium Example FUNCTION FUN : DINT\nVAR_INPUT\n bTest : BOOL;\nEND_VAR\n IF bTest THEN\n RETURN;\nEND_IF\nFUN := 99; Output in the Messages view: SA0022: (Possibly) unassigned return value " }, 
{ "title" : "SA0023: Complex return values ", 
"url" : "_san_rule_sa0023.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0023: Complex return values ", 
"snippet" : "Determines complex return values that cannot be returned with a simple register copy of the processor. This includes structures, arrays, and return values of type STRING (regardless of the size of the used memory). Justification: This is a performance warning. If large values are returned as the res...", 
"body" : "Determines complex return values that cannot be returned with a simple register copy of the processor. This includes structures, arrays, and return values of type STRING (regardless of the size of the used memory). Justification: This is a performance warning. If large values are returned as the result of a function, method, or property, then the processor copies them multiple times when executing the code. This can lead to runtime problems and should be avoided whenever possible. Performance can be improved by passing a structured value as VAR_IN_OUT to a function or method and filling it in the function or method. Importance: Medium Example TYPE LargeStructure :\nSTRUCT\n a : LINT;\n b : BOOL;\nEND_STRUCT\nEND_TYPE\n FUNCTION Large_Return_Value_FUNC : LargeStructure \/\/ SA0023 Output in the Messages view: SA0023: Complex return values " }, 
{ "title" : "SA0024: Untyped literals\n\/ constants ", 
"url" : "_san_rule_sa0024.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0024: Untyped literals\n\/ constants ", 
"snippet" : "Identifies untyped literals which are part of an operation Justification: Untyped literals are automatically typed according to their usage. In some cases, such as dw := ROL(DWORD#1, i); , this can lead to unexpected situations where it is better to use a typed literal in order to provide a unique c...", 
"body" : "Identifies untyped literals which are part of an operation Justification: Untyped literals are automatically typed according to their usage. In some cases, such as dw := ROL(DWORD#1, i); , this can lead to unexpected situations where it is better to use a typed literal in order to provide a unique clarification. Importance: Low Example PROGRAM PLC_PRG\nVAR\n iTemp1 : INT := 10; \/\/no part of operation\n diTemp2 : DINT;\n liTemp3 : LINT;\n rTemp4 : REAL;\n lrTemp5 : LREAL;\n END_VAR iTemp1 := iTemp1 + INT#34;\ndiTemp2 := diTemp2 + 23; \/\/ SA0024\nliTemp3 := liTemp3 + 124; \/\/ SA0024\nrTemp4 := rTemp4 + 1.1; \/\/ SA0024\nlrTemp5 := lrTemp5 + 3.4; \/\/ SA0024\n Output in the Messages view: SA0024: Untyped literal found " }, 
{ "title" : "SA0025: Unqualified enumeration constants ", 
"url" : "_san_rule_sa0025.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0025: Unqualified enumeration constants ", 
"snippet" : "Detects enumeration constants for which a qualified name does not prepend the enumeration Justification: Qualified access makes the code more readable and easier to maintain. Without the forcing of qualified variable names, an additional enumeration could be inserted when the program is extended. Th...", 
"body" : "Detects enumeration constants for which a qualified name does not prepend the enumeration Justification: Qualified access makes the code more readable and easier to maintain. Without the forcing of qualified variable names, an additional enumeration could be inserted when the program is extended. This enumeration contains a constant with the same name as an existing enumeration (see the example below: \"red\"). This would result in ambiguous access to this piece of code. In every case, we recommend to use only enumerations with the pragma {attribute 'qualified-only'} . Importance: Medium Example TYPE COLOR :\n (red,\n green,\n blue);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n myColor : COLOR;\nEND_VAR\n myColor := COLOR.red; \/\/ OK\nmyColor := red; \/\/ SA0025 Output in the Messages view: SA0025: Enumeration constant 'red' not qualified For more information, see: Configuring and Running Static Analysis " }, 
{ "title" : "SA0026: Possible truncated strings ", 
"url" : "_san_rule_sa0026.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0026: Possible truncated strings ", 
"snippet" : "Detects string assignments and string initializations that do not use sufficient string length Justification: When strings of different lengths are assigned, a string could be truncated. This can have unexpected results. Importance: Medium Example PROGRAM PLC_PRG VAR strVar1 : STRING[10]; strVar2 : ...", 
"body" : "Detects string assignments and string initializations that do not use sufficient string length Justification: When strings of different lengths are assigned, a string could be truncated. This can have unexpected results. Importance: Medium Example PROGRAM PLC_PRG\nVAR\n strVar1 : STRING[10];\n strVar2 : STRING[6];\n strVar3 : STRING[6] := 'abcdefghi'; \/\/ SA0026\nEND_VAR\n strVar2 := strVar1; \/\/ SA0026 Output in the Messages view: SA0026: Truncation of 'abcdefghi' SA0026: Possible truncation of string 'strVar1' For more information, see: Configuring and Running Static Analysis " }, 
{ "title" : "SA0027: Multiple uses of identifiers ", 
"url" : "_san_rule_sa0027.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0027: Multiple uses of identifiers ", 
"snippet" : "Detects multiple uses of a name\/identifier for a variable or an object (POU) within the scope of a project. In the case of enumerations, the qualified name is taken into account. Justification: Same names can be confusing when reading the code. They can cause errors if the wrong object is accessed a...", 
"body" : "Detects multiple uses of a name\/identifier for a variable or an object (POU) within the scope of a project. In the case of enumerations, the qualified name is taken into account. Justification: Same names can be confusing when reading the code. They can cause errors if the wrong object is accessed accidentally. Define and follow naming conventions to avoid any situation like this. The following cases are detected: The name of an enumeration is identical to the name of another enumeration in the application or in an integrated library. The name of a variable is identical to the name of another object in the application or in an integrated library. The name of a variable is identical to the name of an enumeration constant in an enumeration in the application or in an integrated library. The name of an object is identical to the name of another object in the application or in an integrated library. Importance: Medium Example TYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n color : INT;\nEND_VAR\n Output in the Messages view: SA0027: Variable name 'color' in 'PLC_PRG' is already used for an object in this application For more information, see: Configuring and Running Static Analysis " }, 
{ "title" : "SA0028: Overlapping memory areas ", 
"url" : "_san_rule_sa0028.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0028: Overlapping memory areas ", 
"snippet" : "Detects the lines of code where two or more variables reserve the same memory. Justification: When two variables reserve the same memory, the code may behave with unexpected results. This situation should be avoided at all costs. If you cannot avoid using a value in different interpretations (for ex...", 
"body" : "Detects the lines of code where two or more variables reserve the same memory. Justification: When two variables reserve the same memory, the code may behave with unexpected results. This situation should be avoided at all costs. If you cannot avoid using a value in different interpretations (for example, one time as DINT and another time as REAL ), then you should define a UNION . You can also use a pointer to access a value with a different type without the value being converted. Importance: High Example PROGRAM PLC_PRG\nVAR\n iVvar1 AT %QB21: INT;\n dwVar2 AT %QD5: DWORD;\nEND_VAR\n Output in the Messages view: The following variables access the same memory: SA0028: iVar1 AT %QB21 SA0028: dwVar2 AT %QD5 For more information, see: Configuring and Running Static Analysis " }, 
{ "title" : "SA0029: Notation in code different to declaration ", 
"url" : "_san_rule_sa0029.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0029: Notation in code different to declaration ", 
"snippet" : "Detects the code locations where the notation of an identifier is different from the notation in its declaration Justification: The IEC 61131-3 standard defines identifiers as not case-sensitive. This means that a variable declared as \" varx \" can also be used as \" VaRx \" in the code. However, this ...", 
"body" : "Detects the code locations where the notation of an identifier is different from the notation in its declaration Justification: The IEC 61131-3 standard defines identifiers as not case-sensitive. This means that a variable declared as \" varx \" can also be used as \" VaRx \" in the code. However, this is confusing and misleading and should be avoided. Importance: Medium Example A PLC_PRG POU and a fnc (function) POU exist in the device tree. PROGRAM PLC_PRG\nVAR\n iVar: INT;\n _123test_var_: INT;\nEND_VAR\n ivar := iVar + 1; \/\/ SA0029\n_123TEST_var_ := _123test_var_; \/\/ SA0029\nFnc(); \/\/ SA0029 Output in the Messages view: SA0029: Notation in code (ivar) must equal declaration (iVar) SA0029: Notation in code (_123TEST_var_) must equal declaration (_123test_var_) SA0029: Notation in code (Fnc) must equal declaration (fnc) For more information, see: Configuring and Running Static Analysis " }, 
{ "title" : "Unused Objects ", 
"url" : "_san_list_unused_objects.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Unused Objects ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0031: Unused signatures ", 
"url" : "_san_rule_sa0031.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Unused Objects \/ SA0031: Unused signatures ", 
"snippet" : "Detects programs, function blocks, functions, data types, interfaces, methods, properties, and actions that are not called within the compiled program code Justification: Unused objects unnecessarily increase the size of the project and can be confusing when reading the code. Importance: Low PLCopen...", 
"body" : "Detects programs, function blocks, functions, data types, interfaces, methods, properties, and actions that are not called within the compiled program code Justification: Unused objects unnecessarily increase the size of the project and can be confusing when reading the code. Importance: Low PLCopen rule: CP2 If multiple applications exist in a project, then only the objects below the currently active applications are affected. If there is only one application, then the objects in the POU pool are also affected. See also Configuring and Running Static Analysis " }, 
{ "title" : "SA0032: Unused enumeration constants ", 
"url" : "_san_rule_sa0032.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Unused Objects \/ SA0032: Unused enumeration constants ", 
"snippet" : "Detects enumeration constants which are not used in the compiled program code Justification: Unused enumeration constants unnecessarily increase the size of the enumeration definition and can be confusing when reading the program. PLCopen rule: CP24 Importance: Low If multiple applications exist in ...", 
"body" : "Detects enumeration constants which are not used in the compiled program code Justification: Unused enumeration constants unnecessarily increase the size of the enumeration definition and can be confusing when reading the program. PLCopen rule: CP24 Importance: Low If multiple applications exist in a project, then only the objects below the currently active applications are affected. If there is only one application, then the objects in the common POU pool are also affected. Example TYPE My_Enum :\n(\n one := 1, \n two := 2\n);\nEND_TYPE\n Output in the Messages view: SA0032: Unused enumeration constant 'one' SA0032: Unused enumeration constant 'two' For more information, see: Configuring and Running Static Analysis " }, 
{ "title" : "SA0033: Unused variables ", 
"url" : "_san_rule_sa0033.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Unused Objects \/ SA0033: Unused variables ", 
"snippet" : "Detects variables which are declared but not used within the compiled program code Justification: Unused variables make a program less readable and maintainable. Unused variables unnecessarily fill memory and unnecessarily waste runtime during initialization. Importance: Medium PLCopen rule: CP22 \/ ...", 
"body" : "Detects variables which are declared but not used within the compiled program code Justification: Unused variables make a program less readable and maintainable. Unused variables unnecessarily fill memory and unnecessarily waste runtime during initialization. Importance: Medium PLCopen rule: CP22 \/ CP24 For GVL variables: If multiple applications exist in a project, then only the objects below the currently active application are considered. If there is only one application, then the objects in the common POU pool are also considered. Example PROGRAM PLC_PRG\nVAR\n iCounter1 : INT;\n iCounter2 : INT; \/\/ SA0033\nEND_VAR\n iCounter1 := 100; Output in the Messages view: SA0033: Unused variable 'iCounter2' For more information, see: Configuring and Running Static Analysis " }, 
{ "title" : "SA0035: Unused input variables ", 
"url" : "_san_rule_sa0035.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Unused Objects \/ SA0035: Unused input variables ", 
"snippet" : "Detects the input variables which are not used by any function block instance Justification: Unused input variables make a program less readable and maintainable. Unused variables unnecessarily fill memory and unnecessarily waste runtime during initialization. An input is considered to be used only ...", 
"body" : "Detects the input variables which are not used by any function block instance Justification: Unused input variables make a program less readable and maintainable. Unused variables unnecessarily fill memory and unnecessarily waste runtime during initialization. An input is considered to be used only if it is actively referenced within the implementation (or the methods) of the function block instance itself. Importance: Medium PLCopen rule: CP24 Example FUNCTION_BLOCK FB_Afb\nVAR_INPUT\n iIn1: INT;\n iIn2: INT;\nEND_VAR\nVAR_OUTPUT\n iOut1: INT;\nEND_VAR iOut1 := iIn1; \/\/ iIn1 is used here PROGRAM PLC_PRG\nVAR\n fbAfb: FB_Afb;\nEND_VAR\n fbAfb(iIn2 := 99); \/\/ iIn2 is unused internally => error Output in the Messages view: SA0035: Unused input 'iIn2' " }, 
{ "title" : "SA0036: Unused output variables ", 
"url" : "_san_rule_sa0036.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Unused Objects \/ SA0036: Unused output variables ", 
"snippet" : "Detects the output variables of functions and function blocks which are not assigned within the respective function or function block. Justification: Unused variables make a program less readable and maintainable. Unused variables unnecessarily fill memory and unnecessarily waste runtime during init...", 
"body" : "Detects the output variables of functions and function blocks which are not assigned within the respective function or function block. Justification: Unused variables make a program less readable and maintainable. Unused variables unnecessarily fill memory and unnecessarily waste runtime during initialization. Importance: Medium PLCopen rule: CP24 Example FUNCTION_BLOCK FB_Afb\nVAR_INPUT\n iIn1: INT;\n iIn2: INT;\nEND_VAR\nVAR_OUTPUT\n iOut1: INT;\n iOut2: INT;\nEND_VAR\n iOut1 := iIn1 + iIn2; Output in the Messages view: SA0036: Unused output 'iOut1' " }, 
{ "title" : "SA0034: Enumerations with incorrect assignment ", 
"url" : "_san_rule_sa0034.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0034: Enumerations with incorrect assignment ", 
"snippet" : "Detects values which are assigned to an enumeration variable. Only defined enumeration constants of an enumeration variable are permitted to be assigned. Justification: A variable of the enumeration type should have only the intended values, otherwise the code that uses this variable may not work co...", 
"body" : "Detects values which are assigned to an enumeration variable. Only defined enumeration constants of an enumeration variable are permitted to be assigned. Justification: A variable of the enumeration type should have only the intended values, otherwise the code that uses this variable may not work correctly. We recommend to always use enumerations with the pragma {attribute 'strict'} . Then the compiler already checks the correct use of the enumeration components. Importance: High Example TYPE COLOR :\n(\n Red := 0,\n Green,\n Yellow\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n eColor1: COLOR;\nEND_VAR\n eColor1 := COLOR.Red;\neColor1 := 1; \/\/ SA0034 Output in the Messages view: SA0034: Use enumeration value instead of 'INT#1' For more information, see: Configuring and Running Static Analysis " }, 
{ "title" : "SA0037: Write access to input variable ", 
"url" : "_san_rule_sa0037.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0037: Write access to input variable ", 
"snippet" : "Detects input variables ( VAR_INPUT ) which are accessed with write permission within the POU Justification: According to the IEC 61131-3 standard, an input variable must not be changed within a POU. This kind of access is also a cause for errors and makes the code poorly maintainable. This is an in...", 
"body" : "Detects input variables ( VAR_INPUT ) which are accessed with write permission within the POU Justification: According to the IEC 61131-3 standard, an input variable must not be changed within a POU. This kind of access is also a cause for errors and makes the code poorly maintainable. This is an indication that a variable is used as both an input variable and an auxiliary variable. This kind of dual use should be avoided. Importance: Medium Example VAR_GLOBAL\n g_xGlob AT %QX0.0 : BOOL;\nEND_VAR PROGRAM PLC_PRG\nVAR_INPUT\n xVarIn1 : BOOL;\n xVarIn2 : BOOL;\nEND_VAR\nVAR\n iCondition : INT;\nEND_VAR\n iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n g_xGlob := xVarIn1;\n INT#2:\n g_xGlob := xVarIn2;\n ELSE\n g_xGlob := FALSE;\n xVarIn1 := FALSE; \/\/ SA0037\nEND_CASE Output in the Messages view: SA0037: Write access to input variable 'xVarIn1' " }, 
{ "title" : "SA0038: Read access to output variable ", 
"url" : "_san_rule_sa0038.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0038: Read access to output variable ", 
"snippet" : "Detects output variables ( VAR_OUTPUT ) which are accessed with read permission within the POU Justification: According to the IEC 61131-3 standard, it is prohibited to read an output within a POU. This is an indication that the output is not only used as an output but also as a temporary variable f...", 
"body" : "Detects output variables ( VAR_OUTPUT ) which are accessed with read permission within the POU Justification: According to the IEC 61131-3 standard, it is prohibited to read an output within a POU. This is an indication that the output is not only used as an output but also as a temporary variable for intermediate results. This kind of dual use should be avoided. Importance: Low Example VAR_GLOBAL\n g_xGlob AT %QX0.0 : BOOL ;\n g_iGlob AT %QW1 : INT ;\nEND_VAR PROGRAM PLC_PRG\nVAR_OUTPUT\n xVarOut1:BOOL;\n xVarOut2:INT;\n xVarOut3:INT;\nEND_VAR\nVAR\n iCondition : INT;\nEND_VAR iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n xVarOut1 := g_xGlob;\n xVarOut2 := g_iGlob;\n INT#2:\n xVarOut3 := xVarOut2; \/\/ SA0038\n ELSE\n xVarOut1 := FALSE;\n g_xGlob := xVarOut1; \/\/ SA0038\n xVarOut2 := INT#0;\n xVarOut3 := INT#-1;\nEND_CASE Output in the Messages view: SA0038: Read access to output variable 'xVarOUT2' SA0026: SA0038: Read access to output variable 'xVarOUT1' " }, 
{ "title" : "SA0040: Possible division by zero ", 
"url" : "_san_rule_sa0040.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0040: Possible division by zero ", 
"snippet" : "Detects code locations where there is possible division by zero Justification: Division by 0 results in an error. A variable to be divided should always be checked for 0 first. Importance: High Example VAR_GLOBAL g_iVar AT %QW1 : INT; END_VAR PROGRAM PLC_PRG VAR iCounter : INT; iSumme:INT; iMid:INT;...", 
"body" : "Detects code locations where there is possible division by zero Justification: Division by 0 results in an error. A variable to be divided should always be checked for 0 first. Importance: High Example VAR_GLOBAL\n g_iVar AT %QW1 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n iCounter : INT;\n iSumme:INT;\n iMid:INT;\n iVal1:INT := INT#2;\n iVal2:INT;\n iVal3:INT := INT#3;\n iVal4:INT := INT#4;\n iVal5:INT;\nEND_VAR IF iVal2 <> 0 THEN\n iVal1 := iVal1\/iVal2; \/\/ no error\nEND_IF;\niMid := iSumme \/ iCounter; \/\/ SA0040\niCounter := iCounter + INT#1;\niSumme := g_iVar + iSumme;\nIF iMid < INT#100 THEN\n iVal1 := iVal1 \/ iVal2; \/\/ SA0040\nEND_IF Output in the Messages view: SA0040: Possible division by zero SA0040: Possible division by zero " }, 
{ "title" : "SA0041: Detect possible loop invariant code ", 
"url" : "_san_rule_sa0041.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0041: Detect possible loop invariant code ", 
"snippet" : "Detects assignments in loops that calculate the same value for each loop cycle. Such lines of code could be inserted outside of the loop. Justification: This is a performance warning. Code which is executed in a loop, but does the same thing in each loop cycle, can be executed outside of the loop. I...", 
"body" : "Detects assignments in loops that calculate the same value for each loop cycle. Such lines of code could be inserted outside of the loop. Justification: This is a performance warning. Code which is executed in a loop, but does the same thing in each loop cycle, can be executed outside of the loop. Importance: Medium Example PROGRAM PLC_PRG\nVAR\n iCounter, iVar1, iVar2 : INT;\nEND_VAR FOR iCounter := 0 TO 10 DO\n iVar1 := 100; \/\/ SA0041\n iVar2 := iVar2 + iVar1;\nEND_FOR\n Output in the Messages view: SAN0041: Possible loop invariant code 'iVar1 := 100' " }, 
{ "title" : "SA0042: Usage of different access paths ", 
"url" : "_san_rule_sa0042.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0042: Usage of different access paths ", 
"snippet" : "Detects the usage of different access paths for the same variable Justification: Different access to the same element decreases the readability and maintainability of a program. We recommend the consistent usage of {attribute 'qualified-only'} for libraries, global variable lists, and enumerations. ...", 
"body" : "Detects the usage of different access paths for the same variable Justification: Different access to the same element decreases the readability and maintainability of a program. We recommend the consistent usage of {attribute 'qualified-only'} for libraries, global variable lists, and enumerations. This forces a fully qualified access. Importance: Low Example VAR_GLOBAL\n iTemp:INT;\n instPOU:POU;\nEND_VAR FUNCTION_BLOCK POU\nVAR\n a:INT;\nEND_VAR\n a := INT#1; PROGRAM SA0042\nVAR\n ptiTemp:POINTER TO INT;\n sTemp:STRING;\nEND_VAR ptiTemp := ADR(iTemp);\n\nptiTemp^ := INT#1;\niTemp := INT#2; \/\/ SA0042 - direct access on variable\nGVL.iTemp := INT#3; \/\/ SA0042 - access on variable via GVL\n\nsTemp := CONCAT( 'ab', 'cd'); \/\/ SA0042 - direct access on function\nsTemp := Standard.CONCAT( 'ab', 'cd'); \/\/ SA0042 - access on function via Standard\n\ninstPOU(); \/\/ SA0042 - direct access on POU instance\nGVL.instPOU(); \/\/ SA0042 - access via GVL\n Output in the Messages view: SA0042: Different access paths for 'CONCAT' SA0042: Different access paths for 'Standard.CONCAT' SA0042: Different access paths for 'instPOU' SA0042: Different access paths for 'GVL.instPOU' SA0042: Different access paths for 'iTemp' SA0042: Different access paths for 'GVL.iTemp' " }, 
{ "title" : "SA0043: Use of a global variable in only one POU ", 
"url" : "_san_rule_sa0043.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0043: Use of a global variable in only one POU ", 
"snippet" : "Detects the use of a global variable in only a single POU Justification: A global variable which is used in only one location should also only be declared at this location. Importance: Medium PLCopen rule: CP26 Example VAR_GLOBAL g_xVar AT %QX0.0 : BOOL ; g_iTest AT %QW1 : INT ; g_wTest AT %QW2 : WO...", 
"body" : "Detects the use of a global variable in only a single POU Justification: A global variable which is used in only one location should also only be declared at this location. Importance: Medium PLCopen rule: CP26 Example VAR_GLOBAL\n g_xVar AT %QX0.0 : BOOL ;\n g_iTest AT %QW1 : INT ;\n g_wTest AT %QW2 : WORD;\nEND_VAR PROGRAM prog1\nVAR\n iCondition : INT;\n bTemp : BOOL;\nEND_VAR\n iCondition := iCondition + INT#1;\nIF iCondition < INT#0 THEN\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\n ELSIF iCondition = INT#0 THEN\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\nELSE\n bTemp := g_xVar; \/\/ SA0043 - g_xVar only read in this POU\n g_wTest := WORD#4; \/\/ g_WTest used also in prog2 -> OK\nEND_IF PROGRAM prog2\nVAR\n iCondition : INT;\nEND_VAR\n iCondition := iCondition + INT#1;\nCASE iCondition OF\n INT#1:\n g_iTest := WORD_TO_INT(g_wTest); \/\/ SA0043 - g_iTest only written in this POU\n INT#2:\n g_iTest := INT#2; \/\/ SA0043 - g_iTest only written in this POU\n ELSE\n g_iTest := INT#3; \/\/ SA0043 - g_iTest only written in this POU\nEND_CASE Output in the Messages view: SA0043: Global variable 'g_xVar' only used in 'prog1' SA0043: Global variable 'g_iTest' only used in 'prog2' " }, 
{ "title" : "SA0044: Declarations with reference to interface ", 
"url" : "_san_rule_sa0044.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0044: Declarations with reference to interface ", 
"snippet" : "Detects declarations with REFERENCE TO interfaces and declarations of VAR_IN_OUT variables with interfaces (implicitly implemented by means of REFERENCE TO ) Justification: An interface type is always implicitly a reference to an instance of a function block that implements this interface. A referen...", 
"body" : "Detects declarations with REFERENCE TO interfaces and declarations of VAR_IN_OUT variables with interfaces (implicitly implemented by means of REFERENCE TO ) Justification: An interface type is always implicitly a reference to an instance of a function block that implements this interface. A reference to an interface is therefore a reference to a reference and can result in unwanted behavior. Importance: High Example ITF is an interface which is defined in the project. FUNCTION_BLOCK POU\nVAR_INPUT\n inst_itf2 : ITF;\nEND_VAR\nVAR_OUTPUT\n inst_itf3 : ITF;\nEND_VAR\nVAR_IN_OUT\n inst_itf4 : ITF; \/\/ SA0044\nEND_VAR\n PROGRAM PLC_PRG\nVAR\n inst : POU;\n itf_inst1 : ITF;\n itf_ref : REFERENCE TO ITF; \/\/ SA0044\nEND_VAR Output in the Messages view: SA0044: Reference to interface 'itf4_ref' SA0044: Reference to interface 'itf_ref' " }, 
{ "title" : "Conversions ", 
"url" : "_san_conversion.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Conversions ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0019: Implicit pointer conversions ", 
"url" : "_san_rule_sa0019.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Conversions \/ SA0019: Implicit pointer conversions ", 
"snippet" : "Detects implicitly generated pointer conversions Justification: In CODESYS , pointers are not strictly typed and they can be assigned to each other in any way. This is often used and therefore not reported by the compiler. However, it can also lead to unauthorized and unexpected access. For example,...", 
"body" : "Detects implicitly generated pointer conversions Justification: In CODESYS , pointers are not strictly typed and they can be assigned to each other in any way. This is often used and therefore not reported by the compiler. However, it can also lead to unauthorized and unexpected access. For example, if you assign the type POINTER TO DWORD to a pointer with the type POINTER TO BYTE , memory can be overwritten in an unwanted way. Therefore, always check this rule and block the message only in cases where you intentionally want to access a value with a different type. Conversions to and from the POINTER TO BYTE data type are not checked by the SA0019 rule. They are always allowed. Implicit data type conversions are reported with a different message. Importance: High PLCopen rule: CP25 Exception: BOOL <-> BIT Example PROGRAM PLC_PRG\nVAR\n pInt : POINTER TO INT;\n byteVar : BYTE;\nEND_VAR\n pInt := ADR(byteVar); Output in the Messages view: SA0019: Implicit conversion from pointer to 'POINTER TO BYTE' to pointer to 'POINTER TO INT' " }, 
{ "title" : "SA0130: Implicit expanding conversions ", 
"url" : "_san_rule_sa0130.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Conversions \/ SA0130: Implicit expanding conversions ", 
"snippet" : "Detects code locations where conversions from smaller to larger data types are implicitly performed during arithmetic operations Justification: The compiler permits any assignments of different types when the value range of the source type is completely contained within the value range of the target...", 
"body" : "Detects code locations where conversions from smaller to larger data types are implicitly performed during arithmetic operations Justification: The compiler permits any assignments of different types when the value range of the source type is completely contained within the value range of the target type. However, the compiler will build a conversion into the code as late as possible. For an assignment of type lint := dint * dint , the compiler performs the implicit conversion only after multiplication: lint := TO_LINT(dint * dint); An overflow is therefore truncated. If you want to prevent this, then you can already convert the elements: lint := TO_LINT(dint) * TO_LINT(dint); Therefore, it may be useful to report locations where the compiler implements implicit conversions in order to check whether these are exactly what is intended. Furthermore, explicit conversions can be used to improve portability to other systems when those systems have more restrictive type checks. Importance: Low Example PROGRAM PLC_PRG\nVAR\n d : DINT;\n l : LINT;\n ui : UINT;\n uli : ULINT;\n usi : USINT;\n lw : LWORD;\n udi : UDINT;\n lr : LREAL;\n b : BYTE;\nEND_VAR\n (*The following lines could result in unwanted truncating by implicit conversions \nand should be reported with SA0130*) \nl := d * d;\nuli := usi * usi;\nlw := udi * udi;\nlr := b * b;\nd := ui * ui; Output in the Messages view: SA0130: Implicit expanding conversion from type 'DINT' to type 'LINT' SA0130: Implicit expanding conversion from type 'USINT' to type 'ULINT' SA0130: Implicit expanding conversion from type 'UDINT' to type 'LWORD' SA0130: Implicit expanding conversion from type 'USINT' to type 'LREAL' SA0130: Implicit expanding conversion from type 'UINT' to type 'DINT' " }, 
{ "title" : "SA0133: Explicit narrowing conversions ", 
"url" : "_san_rule_sa0133.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Conversions \/ SA0133: Explicit narrowing conversions ", 
"snippet" : "Detects explicit conversions from a larger data type to a smaller data type Justification: A large number of type conversions may indicate that you have chosen the wrong data types for variables. For this reason, there are programming guidelines that require an explicit justification for data type c...", 
"body" : "Detects explicit conversions from a larger data type to a smaller data type Justification: A large number of type conversions may indicate that you have chosen the wrong data types for variables. For this reason, there are programming guidelines that require an explicit justification for data type conversions. Importance: Low Example PROGRAM SA0133\nVAR\n siVar:SINT;\n diVar:DINT;\n liVar:LINT;\n byVar:BYTE;\n uiVar:UINT;\n dwVar:DWORD;\n lwVar:LWORD;\n rVar:REAL;\n lrVar:LREAL;\nEND_VAR\n siVar := LINT_TO_SINT(liVar); \/\/ SA0133\nbyVar := DINT_TO_BYTE(diVar); \/\/ SA0133\nsiVar := DWORD_TO_SINT(dwVar); \/\/ SA0133\nuiVar := LREAL_TO_UINT(lrVar); \/\/ SA0133\nrVar := LWORD_TO_REAL(lwVar); \/\/ SA0133 Output in the Messages view: SA0133: Explicit narrowing conversion from type 'LINT' to type 'SINT' SA0133: Explicit narrowing conversion from type 'DINT' to type 'BYTE' SA0133: Explicit narrowing conversions from type 'DWORD' to type 'SINT' SA0133: Explicit narrowing conversion from type 'LREAL' to type 'UINT' SA0133: Explicit narrowing conversion from type 'LWORD' to type 'REAL' " }, 
{ "title" : "SA0134: Explicit signed\/unsigned conversions ", 
"url" : "_san_rule_sa0134.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Conversions \/ SA0134: Explicit signed\/unsigned conversions ", 
"snippet" : "Detects explicit conversions from signed data types to unsigned data types and the other way around Justification: Excessive use of type conversions may indicate that wrong data types for variables have been selected. For this reason, there are programming guidelines that require an explicit justifi...", 
"body" : "Detects explicit conversions from signed data types to unsigned data types and the other way around Justification: Excessive use of type conversions may indicate that wrong data types for variables have been selected. For this reason, there are programming guidelines that require an explicit justification for data type conversions. Importance: Low Example PROGRAM PLC_PRG\nVAR\n byVar :BYTE;\n udiVar : UDINT;\n uliVar : ULINT;\n lwVar : LWORD;\n wVar : WORD;\n siVar : SINT;\n iVar : INT;\n diVar : DINT;\n liVar : LINT;\nEND_VAR\n liVar := ULINT_TO_LINT(uliVar);\nudiVar := DINT_TO_UDINT(diVar);\nsiVar := BYTE_TO_SINT(byVar);\nwVar := INT_TO_WORD(iVar);\nlwVar := SINT_TO_LWORD(siVar); Output in the Messages view: SA0134: Explicit signed\/unsigned conversion from type 'ULINT' to type 'LINT' SA0134: Explicit signed\/unsigned conversion from type from type 'DINT' to type 'UDINT' SA0134: Explicit signed\/unsigned conversion from type from type 'BYTE' to type 'SINT' SA0134: Explicit signed\/unsigned conversion from type from type 'INT' to type 'WORD' SA0134: Explicit signed\/unsigned conversion from type from type 'SINT' to type 'LWORD' " }, 
{ "title" : "Use of Direct Addresses ", 
"url" : "_san_use_direct_adresses.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Use of Direct Addresses ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0005: Invalid addresses and data types ", 
"url" : "_san_rule_sa0005.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Use of Direct Addresses \/ SA0005: Invalid addresses and data types ", 
"snippet" : "Detects invalid addresses and data type specifications. Valid size prefixes in addresses: X for BOOL B for 1-byte data types, W for 2-byte data types, and D for 4-byte data types. Justification: Variables located on direct addresses should preferably be associated with an address that corresponds to...", 
"body" : "Detects invalid addresses and data type specifications. Valid size prefixes in addresses: X for BOOL B for 1-byte data types, W for 2-byte data types, and D for 4-byte data types. Justification: Variables located on direct addresses should preferably be associated with an address that corresponds to their data type width. It can be confusing for the reader of the code, for example, if a DWORD is assigned to a BYTE address. Importance: Low Example PROGRAM Check_Address_Type_PRG\nVAR\n iVar AT %QB0 : INT ; \/\/ OK e. g.: %QW0\n xTest AT %QW1 : BOOL ; \/\/ OK e. g.: %QX1.0\nEND_VAR iVar := iVar + INT#1;\nxTest := NOT xTest;\n Output in the Messages view: SA0005: Invalid address for data type 'iVar' For more information, see: Configuring and Running Static Analysis " }, 
{ "title" : "SA0047: Accesses to direct address ", 
"url" : "_san_rule_sa0047.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Use of Direct Addresses \/ SA0047: Accesses to direct address ", 
"snippet" : "Detects direct address access in the implementation code Justification: Symbolic programming is always preferable. A variable has a name that can also have a meaning. An address cannot indicate what it is used for. Importance: High PLCopen rule: N1 \/ CP1 Example PROGRAM PLC_PRG VAR xVar : BOOL; byVa...", 
"body" : "Detects direct address access in the implementation code Justification: Symbolic programming is always preferable. A variable has a name that can also have a meaning. An address cannot indicate what it is used for. Importance: High PLCopen rule: N1 \/ CP1 Example PROGRAM PLC_PRG\nVAR\n xVar : BOOL;\n byVar : BYTE;\nEND_VAR\n xVar := %IX0.0;\n%QX0.0 := xVar;\n%MX0.1 := xVar;\n%MB1 := byVar; Output in the Messages view: SA0047: Accesses to direct address '%IX0.0' SA0026: Accesses to direct address '%QX0.0' SA0026: Accesses to direct address '%MX0.1' SA0026: Accesses to direct address '%MB1' " }, 
{ "title" : "SA0048: AT-declarations on direct addresses ", 
"url" : "_san_rule_sa0048.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Use of Direct Addresses \/ SA0048: AT-declarations on direct addresses ", 
"snippet" : "Detects AT declarations on direct addresses The use of direct addresses in the code is problematic because the address then appears in multiple locations: First in the controller configuration where the assignment of a physical object to an address is defined Second in the program where variables ar...", 
"body" : "Detects AT declarations on direct addresses The use of direct addresses in the code is problematic because the address then appears in multiple locations: First in the controller configuration where the assignment of a physical object to an address is defined Second in the program where variables are assigned to these addresses. If the addresses are relocated because the configuration is changed, then you need to reassign variables to addresses at a completely different location in the program. This is a cause of error and results in poorer readability and maintainability of the code. Therefore, it is best to perform all assignments in the I\/O mapping of the device editor. Importance: High PLCopen rule: N1 \/ CP1 We recommend that you use direct addresses ONLY in the I\/O Mapping tab of the device editor. Example PROGRAM PLC_PRG\nVAR\n xVar1 AT %IX0.0 : BOOL;\n byVar1 AT %IB1 : BYTE;\n xVar2 AT %QX0.0 : BOOL;\nEND_VAR\n Output in the Messages view: SA0048: Declaration uses direct address '%IX0.0' SA0048: Declaration uses direct address '%IB1' SA0048: Declaration uses direct address '%QX0.0' " }, 
{ "title" : "Rules for Operators ", 
"url" : "_san_rule_operators.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Operators ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0051: Comparison operations on BOOL variables ", 
"url" : "_san_rule_sa0051.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Operators \/ SA0051: Comparison operations on BOOL variables ", 
"snippet" : "Detects comparison operations on variables of type BOOL Justification: CODESYS allows these kinds of comparisons. But they are very unusual and can be confusing. The IEC 61131-3 standard does not provide for these comparisons. By avoiding them, you increase the portability of the code to other devel...", 
"body" : "Detects comparison operations on variables of type BOOL Justification: CODESYS allows these kinds of comparisons. But they are very unusual and can be confusing. The IEC 61131-3 standard does not provide for these comparisons. By avoiding them, you increase the portability of the code to other development systems. Importance: Medium Example PROGRAM PLC_PRG\nVAR\n xBool1, xBool2 : BOOL;\n xResult : BOOL;\nEND_VAR\n xResult := xBool1 > xBool2; \/\/ SA0051\nxBool1 := NOT xBool1; \/\/ OK!\nxBool2 := xBool2 XOR xBool1; \/\/ OK! Output in the Messages view: SA0051: Comparison operations on BOOL variables " }, 
{ "title" : "SA0052: Unusual shift operation ", 
"url" : "_san_rule_sa0052.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Operators \/ SA0052: Unusual shift operation ", 
"snippet" : "Detects shift operations (bit shift) on signed variables. In the case of shift operations on bit field data types ( Byte , DWORD , LWORD , WORD ), an error is not reported. Justification: CODESYS permits shift operations on signed data types. However, these operations are unusual and can be confusin...", 
"body" : "Detects shift operations (bit shift) on signed variables. In the case of shift operations on bit field data types ( Byte , DWORD , LWORD , WORD ), an error is not reported. Justification: CODESYS permits shift operations on signed data types. However, these operations are unusual and can be confusing. The IEC 61131-3 standard does not provide for these kinds of operations. Therefore, they should be avoided in order to increase the portability of the code to other development systems. Importance: Medium Example PROGRAM PLC_PRG\nVAR\n iTemp : INT;\n dwTemp1 : DWORD;\n byTemp2 : BYTE;\n diTemp3 : DINT;\n siTemp4 : SINT;\n liTemp5 : LINT;\nEND_VAR\n \/\/the following lines each will cause an SA0052:\niTemp := SHL(iTemp, BYTE#2);\ndiTemp3 := SHR(diTemp3, BYTE#4);\nsiTemp4 := ROL(siTemp4, BYTE#2);\nliTemp5 := ROR(liTemp5, BYTE#2);\n\n\/\/no error SA0052 because DWORD and BYTE are bitfield datatypes:\ndwTemp1 := SHL(dwTemp1, BYTE#3);\nbyTemp2 := SHR(byTemp2, BYTE#1); Output in the Messages view: SA0052: Unusual shift operation " }, 
{ "title" : "SA0053: Too big bitwise shift ", 
"url" : "_san_rule_sa0053.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Operators \/ SA0053: Too big bitwise shift ", 
"snippet" : "Detects whether or not the data type width of the operand has been exceeded in the case of a bitwise shift (bit shift) of operands Justification: If a shift operation exceeds the data type width, then a constant 0 is generated. If a rotation shift exceeds the data type width, then it is difficult to...", 
"body" : "Detects whether or not the data type width of the operand has been exceeded in the case of a bitwise shift (bit shift) of operands Justification: If a shift operation exceeds the data type width, then a constant 0 is generated. If a rotation shift exceeds the data type width, then it is difficult to read. Therefore, the rotation value should be shortened. Importance: High Example PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\n wTemp2 : WORD;\n dwTemp3 : DWORD;\n lwTemp4 : LWORD;\nEND_VAR\n byTemp1 := SHR(byTemp1, BYTE#25);\nwTemp2 := SHL(wTemp2, BYTE#45);\ndwTemp3 := ROR(dwTemp3, BYTE#78);\nlwTemp4 := ROL(lwTemp4, BYTE#111); Output in the Messages view: SA0053: Too big bitwise shift " }, 
{ "title" : "SA0054: Comparisons of REAL\/LREAL for equality \/ inequality ", 
"url" : "_san_rule_sa0054.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Operators \/ SA0054: Comparisons of REAL\/LREAL for equality \/ inequality ", 
"snippet" : "Detects whether or not the comparison operators = (equality) and <> (inequality) compare the operands of type REAL or LREAL . Justification: REAL \/ LREAL values are implemented as floating-point numbers according to the IEEE 754 standard. This standard implies that specific, apparently simple decima...", 
"body" : "Detects whether or not the comparison operators = (equality) and <> (inequality) compare the operands of type REAL or LREAL . Justification: REAL \/ LREAL values are implemented as floating-point numbers according to the IEEE 754 standard. This standard implies that specific, apparently simple decimal numbers cannot be represented with precision. As a result, there may be different representations as LREAL for the same decimal number. Consider the following lines of code: lr11 := 1.1;\nlr33 := 3.3;\nlrVar1 := lr11 + lr11;\nlrVar2 := lr33 - lr11;\nbotest := lrVar1 = lrVar2; In this case, botest returns FALSE , even if the variables lrVar1 and lrVar2 both return the monitoring value of \"2.2\". This is not an error of the compiler, but a property of the floating point units of all conventional processors. You can avoid this by specifying a minimum value by which the values may differ: botest := ABS(lrVar1 - lrVar2) < 0.1; Exception: A comparison with 0.0 is not reported by this analysis. For the 0, there is an exact representation in the IEEE 754 standard, and therefore the comparison functions usually as expected. Therefore, for better performance, it makes sense to permit a direct comparison here. Importance: High PLCopen rule: CP54 Example PROGRAM PLC_PRG\nVAR\n rTest1 : REAL;\n rTest2 : REAL;\n lrTest3 : LREAL;\n lrTest4 : LREAL;\n xResult : BOOL;\nEND_VAR \/\/the following lines each will cause an SA0054:\nxResult := rTest1 = rTest1;\nxResult := rTest1 = rTest2;\nxResult := rTest1 <> rTest2;\nxResult := lrTest3 = lrTest3;\nxResult := lrTest3 = lrTest4;\nxResult := lrTest3 <> lrTest4;\n\/\/the following lines each will not cause an SA0054:\nxResult := rTest1 > rTest2;\nxResult := lrTest3 < lrTest4;\n Output in the Messages view: SA0054: Comparisons of REAL\/LREAL for equality \/ inequality " }, 
{ "title" : "SA0055: Unnecessary comparisons of unsigned operands ", 
"url" : "_san_rule_sa0055.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Operators \/ SA0055: Unnecessary comparisons of unsigned operands ", 
"snippet" : "Detects unnecessary comparisons with unsigned operands. An unsigned data type is never less than zero. This can be used as a sign check. Justification: A comparison detected with this check yields a constant result and is an indication of an error in the code. Importance: High Example PROGRAM PLC_PR...", 
"body" : "Detects unnecessary comparisons with unsigned operands. An unsigned data type is never less than zero. This can be used as a sign check. Justification: A comparison detected with this check yields a constant result and is an indication of an error in the code. Importance: High Example PROGRAM PLC_PRG\nVAR\n byTest: BYTE;\nEND_VAR\n \/\/ SA0055\nWHILE byTest >= 0 DO\n byTest := byTest - 1;\nEND_WHILE Output in the Messages view: SA0055: Unnecessary comparisons of unsigned operands " }, 
{ "title" : "SA0056: Constant out of valid range ", 
"url" : "_san_rule_sa0056.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Operators \/ SA0056: Constant out of valid range ", 
"snippet" : "Detects literals (constants) outside of the valid range of the operator Justification: The message is issued in cases when a value is compared with a constant which is outside of the range of this value. Then the comparison constantly returns TRUE or FALSE . This is an indication of a programming er...", 
"body" : "Detects literals (constants) outside of the valid range of the operator Justification: The message is issued in cases when a value is compared with a constant which is outside of the range of this value. Then the comparison constantly returns TRUE or FALSE . This is an indication of a programming error. Importance: High Example PROGRAM PLC_PRG\nVAR\n byTestVar: BYTE;\nEND_VAR\n WHILE byTestVar >= 260 DO\n byTestVar := byTestVar + 1;\nEND_WHILE Output in the Messages view: SA0056: Constant out of valid range " }, 
{ "title" : "SA0057: Possible loss of decimal places ", 
"url" : "_san_rule_sa0057.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Operators \/ SA0057: Possible loss of decimal places ", 
"snippet" : "Detects statements with possible loss of decimal places Justification: A piece of code of the following type ( diTemp2 := 1 rTemp1 := TO_REAL(diTemp2 \/ DINT#2) ) can cause a misinterpretation. The author or reader of this line of code can assume that the division would be performed as a REAL operati...", 
"body" : "Detects statements with possible loss of decimal places Justification: A piece of code of the following type ( diTemp2 := 1 rTemp1 := TO_REAL(diTemp2 \/ DINT#2) ) can cause a misinterpretation. The author or reader of this line of code can assume that the division would be performed as a REAL operation, and in this case the result would be REAL#0.5 . However, this is not true. It is an integer operation. The result is cast to REAL and rTemp1 gets the value REAL#0 . To avoid this, use a cast to make sure that the operation is performed as a REAL operation: rTemp1 := TO_REAL(diTemp2) \/ REAL#2; Importance: Medium Example PROGRAM PLC_PRG\nVAR\n rTemp1 : REAL;\n diTemp2 : DINT;\n liTemp3 : LINT;\nEND_VAR diTemp2 := diTemp2 + DINT#11;\n\/\/ SA0057\nrTemp1 := DINT_TO_REAL(diTemp2 \/ DINT#3); \nrTemp1 := DINT_TO_REAL(diTemp2) \/ REAL#3.0;\nliTemp3 := liTemp3 + LINT#13;\n\/\/ SA0057\nrTemp1 := LINT_TO_REAL(liTemp3 \/ LINT#7);\nrTemp1 := LINT_TO_REAL(liTemp3) \/ REAL#7.0; Output in the Messages view: SA0057: Possible loss of decimal places " }, 
{ "title" : "SA0058: Operations on enumeration variables ", 
"url" : "_san_rule_sa0058.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Operators \/ SA0058: Operations on enumeration variables ", 
"snippet" : "Detects operations on variables of the enumeration data type Assignments are permitted. Justification: Enumerations should not be used as ordinary integer values. Alternatively, an alias data type could be defined or a subrange type could be used. Importance: Medium Exception: If an enumeration is t...", 
"body" : "Detects operations on variables of the enumeration data type Assignments are permitted. Justification: Enumerations should not be used as ordinary integer values. Alternatively, an alias data type could be defined or a subrange type could be used. Importance: Medium Exception: If an enumeration is tagged with the pragma {attribute 'strict'} , then the compiler already reports this kind of operation. If an enumeration is declared as a flag by the pragma {attribute 'flags'} , then an error is not issued for AND , OR , NOT , or oder XOR operations. Example TYPE My_Enum :\n(\n red := 1, blue := 2, green := 3, black := 4\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n abc : My_Enum;\nEND_VAR iTemp1 := iTemp1 + INT#1;\nabc := My_Enum.red; \/\/ OK\niTemp1 := My_Enum.black \/ My_Enum.blue; \/\/ SA0058\niTemp1 := My_Enum.green \/ My_Enum.red; \/\/ SA0058\n Output in the Messages view: SA0058: Operations on enumeration variables Example with a pragma {attribute 'flags'} {attribute 'flags'} \/\/ declaring the enumeration as a \"flag\"\nTYPE Flags :\n(\n Unknown := 16#00000001,\n Stopped := 16#00000002,\n Running := 16#00000004\n) DWORD;\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n abc : Flags;\n batate : BYTE;\n dwFlags : DWORD;\n dwState : DWORD;\nEND_VAR \/\/ OK for the following\nIF (dwFlags AND Flags.Unknown) <> DWORD#0 THEN\n dwState := dwState AND Flags.Unknown;\n ELSIF (dwFlags OR Flags.Stopped) <> DWORD#0 THEN\n dwState := dwState OR Flags.Running;\nEND_IF " }, 
{ "title" : "SA0059: Comparison operations always returning TRUE or FALSE ", 
"url" : "_san_rule_sa0059.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Operators \/ SA0059: Comparison operations always returning TRUE or FALSE ", 
"snippet" : "Detects comparisons with literals whose result is always TRUE or FALSE , and can already be processed during at the compile. Justification: An operation that consistently yields TRUE or FALSE is an indication of a programming error. Importance: High Example PROGRAM PLC_PRG VAR byTemp1 : BYTE; END_VA...", 
"body" : "Detects comparisons with literals whose result is always TRUE or FALSE , and can already be processed during at the compile. Justification: An operation that consistently yields TRUE or FALSE is an indication of a programming error. Importance: High Example PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\nEND_VAR\n WHILE byTemp1 <= 255 DO\n byTemp1 := byTemp1 + 1;\nEND_WHILE Output in the Messages view: SA0059: Relational operator '<=' always evaluates to 'TRUE'\n " }, 
{ "title" : "SA0060: Zero used as invalid operand ", 
"url" : "_san_rule_sa0060.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Operators \/ SA0060: Zero used as invalid operand ", 
"snippet" : "Detects operations where an operand with the value 0 causes an invalid or a nonsense operation Justification: This kind of expression could be an indication of a programming error. In any case, it unnecessarily wastes runtime. Importance: Medium Example PROGRAM PLC_PRG VAR byTemp1 : BYTE; wTemp2 : W...", 
"body" : "Detects operations where an operand with the value 0 causes an invalid or a nonsense operation Justification: This kind of expression could be an indication of a programming error. In any case, it unnecessarily wastes runtime. Importance: Medium Example PROGRAM PLC_PRG\nVAR\n byTemp1 : BYTE;\n wTemp2 : WORD;\n dwTemp3 : DWORD;\nEND_VAR\n byTemp1 := byTemp1 + 0;\nwTemp2 := wTemp2 - WORD#0;\ndwTemp3 := dwTemp3 * DWORD#0; Output in the Messages view: SA0060: Zero used as invalid operand " }, 
{ "title" : "SA0061: Unusual operation on pointer ", 
"url" : "_san_rule_sa0061.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Operators \/ SA0061: Unusual operation on pointer ", 
"snippet" : "Detects operations one variables of type POINTER TO which are not = (equality), <> (inequality), + (addition), or ADR . In CODESYS , pointer arithmetic is generally permitted and can also be used appropriately. Therefore, the addition of a pointer with an integer value is considered a common operati...", 
"body" : "Detects operations one variables of type POINTER TO which are not = (equality), <> (inequality), + (addition), or ADR . In CODESYS , pointer arithmetic is generally permitted and can also be used appropriately. Therefore, the addition of a pointer with an integer value is considered a common operation on pointers. This makes it possible to use a pointer to process an array of variable length. All other (unusual) operations with pointers are reported with SA0061. Importance: High PLCopen rule: E2 \/ E3 Example PROGRAM PLC_PRG\nVAR\n piTemp : POINTER TO INT;\n iTemp : INT;\nEND_VAR\n iTemp := iTemp + INT#1;\npiTemp := ADR(iTemp);\npiTemp := piTemp * DWORD#5; \/\/ SA0061\npiTemp := piTemp \/ DWORD#2; \/\/ SA0061\npiTemp := piTemp MOD DWORD#3; \/\/ SA0061\npiTemp := piTemp + DWORD#1;\npiTemp := piTemp - DWORD#1; \/\/ SA0061 Output in the Messages view: SA0061: Unusual operation on pointer " }, 
{ "title" : "SA0062: Expression is constant ", 
"url" : "_san_rule_sa0062.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Operators \/ SA0062: Expression is constant ", 
"snippet" : "Detects the usage of expressions which always have the same value at runtime. Justification: A complex expression which is calculated repeatedly and always generates the same value may indicate an error. This applies in particular if something else was intended. In each case, the expression unnecess...", 
"body" : "Detects the usage of expressions which always have the same value at runtime. Justification: A complex expression which is calculated repeatedly and always generates the same value may indicate an error. This applies in particular if something else was intended. In each case, the expression unnecessarily burdens the runtime of the program. Importance: Medium Example PROGRAM PLC_PRG\nVAR\n value : INT;\n condition : BOOL;\nEND_VAR\n value := 8;\ncondition := value = 8 \/\/ Reports: Expression (value=8) is always TRUE Output in the Messages view: SA0062: Expression '(value=8)' is always TRUE " }, 
{ "title" : "SA0063: Possibly not 16-bit-compatible operations ", 
"url" : "_san_rule_sa0063.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Operators \/ SA0063: Possibly not 16-bit-compatible operations ", 
"snippet" : "Detects 16-bit operations with temporary results. Background: On 16-bit systems, 32-bit temporary results can be truncated. Example: (int+10) can exceed 16 bits. Justification: In the very rare case that code has to be written which should run on a 16-bit processor as well as on a 32-bit processor, ...", 
"body" : "Detects 16-bit operations with temporary results. Background: On 16-bit systems, 32-bit temporary results can be truncated. Example: (int+10) can exceed 16 bits. Justification: In the very rare case that code has to be written which should run on a 16-bit processor as well as on a 32-bit processor, this message should help to prevent any problems. Importance: Low Example PROGRAM PLC_PRG\nVAR\n iVar : INT;\nEND_VAR\n iVar := (iVar + 10) \/ 2; Output in the Messages view: SA0063: Compatibility for 16 Bit – Possible truncated intermediate result " }, 
{ "title" : "SA0064: Addition of pointer ", 
"url" : "_san_rule_sa0064.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Operators \/ SA0064: Addition of pointer ", 
"snippet" : "Detects the addition of pointers Justification: In CODESYS , pointer arithmetic is generally permitted and can also be used appropriately. However, it also represents a source of error. Therefore, programming rules exist that generally prohibit pointer arithmetic. This test can check such a requirem...", 
"body" : "Detects the addition of pointers Justification: In CODESYS , pointer arithmetic is generally permitted and can also be used appropriately. However, it also represents a source of error. Therefore, programming rules exist that generally prohibit pointer arithmetic. This test can check such a requirement. Importance: Medium Example PROGRAM PLC_PRG\nVAR\n iTest : INT;\n ariTest : ARRAY[0..10] OF INT;\n {attribute 'analysis':='-111'}\n piTest : POINTER TO INT;\n i : INT;\nEND_VAR\n piTest := ADR(ariTest[0]); \/\/ OK\npiTest^ := 0;\npiTest := ADR(ariTest) + SIZEOF(INT); \/\/ SA0064\npiTest^ := 1;\npiTest := ADR(ariTest) + 6; \/\/ SA0064\npiTest^ := 3;\npiTest := ADR(ariTest[10]);\nFOR i:=0 TO 10 DO\n piTest^ := i;\n piTest := piTest + 2; \/\/ SA0064\nEND_FOR Output in the Messages view: SA0064: Addition of pointer " }, 
{ "title" : "SA0065: Incorrect pointer addition to base size ", 
"url" : "_san_rule_sa0065.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Operators \/ SA0065: Incorrect pointer addition to base size ", 
"snippet" : "Detects pointer additions for which the value to be added does not match the base size of the pointer. Only literals of the base data size and multiples thereof can be added without error. Justification: In CODESYS (in contrast to C and C++), when adding a pointer with an integer value, only this in...", 
"body" : "Detects pointer additions for which the value to be added does not match the base size of the pointer. Only literals of the base data size and multiples thereof can be added without error. Justification: In CODESYS (in contrast to C and C++), when adding a pointer with an integer value, only this integer value is added as the number of bytes, and not the integer value multiplied by the base size. Example in ST pINT := ADR(array_of_int[0]);\npINT := pINT + 2; \/\/in CODESYS, pINT then points to array_of_int[1] This code would function differently in C: short* pShort\npShort = &(array_of_short[0])\npShort = pShort + 2; \/\/in C, pShort then points to array_of_short[2] Therefore, in CODESYS , you should always add a multiple of the base size of the pointer to a pointer. Otherwise, the pointer may point to not aligned memory which (depending on the processor) can lead to an alignment exception when accessing it. Importance: High Example VAR\n pudiTest:POINTER TO UDINT;\n udiTest:UDINT;\n prTest:POINTER TO REAL;\n rTest:REAL;\nEND_VAR pudiTest := ADR(udiTest) + 4; \/\/ OK\npudiTest := ADR(udiTest) + ( 2 + 2 ); \/\/ OK\npudiTest := ADR(udiTest) + SIZEOF(UDINT); \/\/ OK\npudiTest := ADR(udiTest) + 3; \/\/ SA0065\npudiTest := ADR(udiTest) + 2*SIZEOF(UDINT); \/\/ OK\npudiTest := ADR(udiTest) + ( 3 + 2 ); \/\/ SA0065\nprTest := ADR(rTest);\nprTest := prTest + 4; \/\/ OK\nprTest := prTest + ( 2 + 2 ); \/\/ OK\nprTest := prTest + SIZEOF(REAL); \/\/ OK\nprTest := prTest + 1; \/\/ SA0065\nprTest := prTest + 2; \/\/ SA0065\nprTest := prTest + 3; \/\/ SA0065\nprTest := prTest + ( SIZEOF(REAL) - 1 ); \/\/ SA0065\nprTest := prTest + ( 1 + 4 ); \/\/ SA0065\n Output in the Messages view: SA0065: Incorrect pointer addition to base size " }, 
{ "title" : "SA0066: Uses of temporary results ", 
"url" : "_san_rule_sa0066.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Operators \/ SA0066: Uses of temporary results ", 
"snippet" : "Detects the use of temporary results in statements with a data type which is less than the register size. In this case, the implicit cast may lead to undesirable results. Justification: For performance reasons, CODESYS Static Analysis performs operations on the register width of the processor. Inter...", 
"body" : "Detects the use of temporary results in statements with a data type which is less than the register size. In this case, the implicit cast may lead to undesirable results. Justification: For performance reasons, CODESYS Static Analysis performs operations on the register width of the processor. Intermediate results are not truncated. This can lead to misinterpretations, as in the following case: Example usintTest := 0; xError := usintTest - 1 <> 255; In CODESYS , xError is TRUE in this case because the operation usintTest - 1 is typically executed as a 32-bit operation and the result is not cast to the byte size. Then the value 16#ffffffff (not equal to 255) is located in the register. To avoid this, you need to cast the intermediate result explicitly: xError := TO_USINT(usintTest - 1) <> 255; If this message is activated, then many less problematic locations in the code will be reported. Although a problem can only occur when the operation produces an overflow or underflow in the data type, the static analysis cannot differentiate between the individual locations. If you include an explicit typecast in all reported locations, then the code will be much slower and less readable. Importance: Low Example PROGRAM PLC_PRG\nVAR\n byTest:BYTE;\n liTest:LINT;\n xError:BOOL;\nEND_VAR \/\/type size smaller than register size;\nbyTest := 0;\nIF (byTest - 1) <> 255 THEN \/\/use of temporary result + implicit casting -> SA0066\n xError := TRUE;\nELSE\n xError := FALSE;\nEND_IF\n\n\/\/type size equal to or bigger than register size;\nliTest := 0;\nIF (liTest - 1) <> -1 THEN \/\/ use of temporary result and no implicit casting -> OK\n xError := TRUE;\nELSE\n xError := FALSE;\nEND_IF\n Output in the Messages view: SA0066: Uses of temporary results (byTest - USINT #1) " }, 
{ "title" : "Rules for Statements ", 
"url" : "_san_rule_instructions.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Statements ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0072: Invalid uses of counter variable ", 
"url" : "_san_rule_sa0072.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Statements \/ SA0072: Invalid uses of counter variable ", 
"snippet" : "Detects the use of a counter variable in a FOR loop Justification: Manipulation of the counter variable in a FOR loop can easily result in an infinite loop. To prevent the execution of the loop for specific values of the counter variable, use CONTINUE or simply an IF . Importance: High PLCopen rule:...", 
"body" : "Detects the use of a counter variable in a FOR loop Justification: Manipulation of the counter variable in a FOR loop can easily result in an infinite loop. To prevent the execution of the loop for specific values of the counter variable, use CONTINUE or simply an IF . Importance: High PLCopen rule: L12 Example PROGRAM PLC_PRG\nVAR_TEMP\n iIndex : INT;\nEND_VAR FOR iIndex := INT#0 TO INT#20 BY INT#1 DO\n iIndex := iIndex - INT#1;\nEND_FOR Output in the Messages view: SA0072: Invalid uses of counter variable 'iIndex' " }, 
{ "title" : "SA0073: Uses of inadequate counter variable ", 
"url" : "_san_rule_sa0073.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Statements \/ SA0073: Uses of inadequate counter variable ", 
"snippet" : "Detects the use of non-temporary variables in FOR loops. Justification: This is a performance warning. A counter variable is always initialized each time a POU is called. You can create this variable as a temporary variable ( VAR_TEMP ). Access to it may be faster and the variable does not take up a...", 
"body" : "Detects the use of non-temporary variables in FOR loops. Justification: This is a performance warning. A counter variable is always initialized each time a POU is called. You can create this variable as a temporary variable ( VAR_TEMP ). Access to it may be faster and the variable does not take up any permanent memory. Importance: Medium PLCopen rule: CP21 \/ L13 Example PROGRAM PLC_PRG\nVAR\n nIndex : INT;\n iVar : INT;\nEND_VAR FOR nIndex := INT#0 TO INT#20 BY INT#1 DO\n iVar := iVar + nIndex;\nEND_FOR\n Output under view Messages : SA0073: Counter variable not matching " }, 
{ "title" : "SA0075: Missing ELSE ", 
"url" : "_san_rule_sa0075.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Statements \/ SA0075: Missing ELSE ", 
"snippet" : "Detects CASE statements without an ELSE branch Justification: Defensive programming requires the inclusion of an ELSE branch in every CASE statement. If there is nothing to do in the ELSE branch, then include a comment to indicate this. It is then clear to the reader of the code that the case was no...", 
"body" : "Detects CASE statements without an ELSE branch Justification: Defensive programming requires the inclusion of an ELSE branch in every CASE statement. If there is nothing to do in the ELSE branch, then include a comment to indicate this. It is then clear to the reader of the code that the case was not simply forgotten. Importance: Low PLCopen rule: L17 For CASE  statements which use enumerations with attribute  strict  and where all enumerations constants are used in the  CASE  statement is used, no error message is issued. Example PROGRAM PLC_PRG\nVAR\n iVar : INT;\n xTemp : BOOL;\nEND_VAR iVar := iVar + INT#1;\nCASE iVar OF\n INT#1:\n xTemp := FALSE;\n INT#2:\n xTemp := TRUE;\nEND_CASE\n Output in the  Messages view: SA0075: Missing ELSE in CASE statement " }, 
{ "title" : "SA0076: Missing enumeration constant ", 
"url" : "_san_rule_sa0076.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Statements \/ SA0076: Missing enumeration constant ", 
"snippet" : "Determines whether or not each enumeration constant is used as a condition in CASE statements and queried in a CASE branch. Justification: Defensive programming requires the processing of all possible values of an enumeration. If an action is not required for a particular enumeration value, then you...", 
"body" : "Determines whether or not each enumeration constant is used as a condition in CASE statements and queried in a CASE branch. Justification: Defensive programming requires the processing of all possible values of an enumeration. If an action is not required for a particular enumeration value, then you should add a comment to indicate this explicitly. It is then clear to the reader of the code that the value was not simply forgotten. Importance: Low Example TYPE My_Enum :\n(\n red := 1, blue := 2, green := 3, black := 4\n);\nEND_TYPE PROGRAM PLC_PRG\nVAR\n iVar : My_Enum;\n xTemp : BOOL;\nEND_VAR iVar := My_Enum.black;\nCASE iVar OF\n My_Enum.red:\n xTemp := FALSE;\n My_Enum.blue, My_Enum.green:\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n Output in the Messages view: SA0076: Missing enumeration constant 'black' in CASE statement " }, 
{ "title" : "SA0077: Enumeration type mismatch with CASE expression ", 
"url" : "_san_rule_sa0077.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Statements \/ SA0077: Enumeration type mismatch with CASE expression ", 
"snippet" : "Detects code positions where a CASE statement mixes enumeration values with non-enumeration types. Justification: Mixing enumeration values and integer values in CASE constructs violates data type safety, reduces the readability of the code, and impacts maintainability. Enumeration values ensure sem...", 
"body" : "Detects code positions where a CASE statement mixes enumeration values with non-enumeration types. Justification: Mixing enumeration values and integer values in CASE constructs violates data type safety, reduces the readability of the code, and impacts maintainability. Enumeration values ensure semantic clarity. Using of raw integer values carries the risk of minor errors and makes the code more difficult to understand. Data type changes to enumerations can also destroy integer-based branches which may go unnoticed. Importance: Low Example {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE DUT_MyEnum :\n(\n\tOne := 1, \n\tTwo := 2, \n\tThree := 3, \n\tFour := 4\n);\nEND_TYPE PROGRAM PRG_Case\nVAR\ndiVar : DINT;\nxTemp : BOOL;\n\neMyEnum : DUT_MyEnum;\nEND_VAR\n CASE diVar OF\n 1 :\n xTemp := FALSE;\n DUT_MyEnum.Two : \/\/ SA0077\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n\nCASE eMyEnum OF\n 1 : \/\/ SA0077\n xTemp := FALSE;\n DUT_MyEnum.Two:\n xTemp := TRUE;\n ELSE\n xTemp := NOT xTemp;\nEND_CASE Output in the Messages view: SA0077: Enum type mismatch with CASE expression " }, 
{ "title" : "SA0078: Missing CASE branches ", 
"url" : "_san_rule_sa0078.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Statements \/ SA0078: Missing CASE branches ", 
"snippet" : "Detects CASE statements without CASE branches and only one ELSE statement Justification: A CASE statement without cases wastes execution time and it is difficult to read. Importance: Medium Example PROGRAM PLC_PRG VAR iVar : INT; xTemp : BOOL; END_VAR iVar := iVar + INT#1; \/\/in the following the cas...", 
"body" : "Detects CASE statements without CASE branches and only one ELSE statement Justification: A CASE statement without cases wastes execution time and it is difficult to read. Importance: Medium Example PROGRAM PLC_PRG\nVAR\n iVar : INT;\n xTemp : BOOL;\nEND_VAR iVar := iVar + INT#1;\n\/\/in the following the case descriptions are missing:\nCASE iVar OF\n ELSE\n xTemp := NOT xTemp;\nEND_CASE\n Output in the Messages view: SA0078: Missing CASE branches " }, 
{ "title" : "SA0081: Upper border is not a constant ", 
"url" : "_san_rule_sa0081.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Statements \/ SA0081: Upper border is not a constant ", 
"snippet" : "Detects the FOR statements where the upper bound is not defined with a constant value Justification: If the upper bound of a loop is a variable value, then it is no longer possible to see how often a loop is executed. This can result in serious problems at runtime. The worst case is an infinite loop...", 
"body" : "Detects the FOR statements where the upper bound is not defined with a constant value Justification: If the upper bound of a loop is a variable value, then it is no longer possible to see how often a loop is executed. This can result in serious problems at runtime. The worst case is an infinite loop. Importance: High Example PROGRAM PLC_PRG\nVAR\n i:INT;\n iBorder1: INT := 10;\n iBorder2: INT := 10;\n iCounter: INT;\nEND_VAR\nVAR CONSTANT\n ciBorder:INT := 10;\nEND_VAR\n FOR i:=0 TO 10 DO \/\/OK\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO ciBorder DO \/\/ OK\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO iBorder1 DO \/\/ SA0081\n iCounter := i;\nEND_FOR\n\nFOR i:=0 TO iBorder2 DO \/\/ SA0081\n iCounter := i;\n IF iCounter = 10 THEN\n iBorder2 := 50;\n END_IF\nEND_FOR\n Output in the Messages view: SA0081: Upper border of a for loop must be a constant value " }, 
{ "title" : "SA0090: POUs shall have a single point of exit ", 
"url" : "_san_rule_sa0090.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Rules for Statements \/ SA0090: POUs shall have a single point of exit ", 
"snippet" : "Detects code locations where the RETURN statement is not the last statement in a function, method, property, or program. Locations where a RETURN exists within an IF branch are also detected. Justification: A RETURN in the code results in worse maintainability, testability, and readability of the co...", 
"body" : "Detects code locations where the RETURN statement is not the last statement in a function, method, property, or program. Locations where a RETURN exists within an IF branch are also detected. Justification: A RETURN in the code results in worse maintainability, testability, and readability of the code. A RETURN in the code is easily overlooked. Before each RETURN , it is often forgotten to insert code that should always be executed when exiting a function. Importance: Medium PLCopen rule: CP14 Example FUNCTION SA0090: DINT\nVAR_INPUT\n bTest : BOOL;\nEND_VAR IF bTest THEN\n RETURN;\nEND_IF\nSA0090 := 99; Output in the Messages view: SA0090: POUs shall have a single point of exit " }, 
{ "title" : "SA0095: Assignments in conditions ", 
"url" : "_san_rule_sa0095.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0095: Assignments in conditions ", 
"snippet" : "Detects assignments in conditions of IF , CASE , or REPEAT constructs Justification: An assignment (:=) and a comparison (=) can easily be mistaken. As a result, an assignment in a condition can easily be unintentional, and it is therefore reported. This can also confuse the reader of the code. Impo...", 
"body" : "Detects assignments in conditions of IF , CASE , or REPEAT constructs Justification: An assignment (:=) and a comparison (=) can easily be mistaken. As a result, an assignment in a condition can easily be unintentional, and it is therefore reported. This can also confuse the reader of the code. Importance: High Example PROGRAM PLC_PRG\nVAR\n iCond1:INT := INT#1;\n iCond2:INT := INT#2;\n xCond:BOOL := FALSE;\n iVar : INT;\nEND_VAR IF INT_TO_BOOL(iCond1 := iCond2) THEN \/\/ SA0095\n iCond1 := INT#1;\n iCond2 := INT#2;\n ELSIF (iCond1 := 11) = 11 THEN \/\/ SA0095\n iCond1 := INT#1;\n iCond2 := INT#2;\nEND_IF\n\nIF xCond := TRUE THEN \/\/ SA0095\n xCond := FALSE;\nEND_IF\n\nIF (xCond := FALSE) OR (iCond1 := iCond2) = 12 THEN \/\/ SA0095\n xCond := FALSE;\n iCond1 := INT#1;\n iCond2 := INT#2;\nEND_IF\n\nIF (iVar := iVar + 1) = 120 THEN \/\/ SA0095 (can be valid, but is not reparable very well\n iVar := 0;\nEND_IF\n\nWHILE (xCond = TRUE) OR (iCond1 := iCond2) = 12 DO \/\/ SA0095\n xCond := FALSE;\nEND_WHILE\n\n\/\/Error: assignment in repeat loop\nREPEAT\n xCond := FALSE;\nUNTIL (xCond = TRUE) OR (iCond1 := iCond2) = 12 \/\/ SA0095\nEND_REPEAT Output in the Messages view: SA0095: Assignment in condition: '...' " }, 
{ "title" : "SA0100: Variables greater than <n> bytes ", 
"url" : "_san_rule_sa0100.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0100: Variables greater than <n> bytes ", 
"snippet" : "Detects variables that use more than n bytes, where n is defined by the current configuration. Default value: 1024 bytes. The value can be changed by double-clicking the line. Justification: Some programming guidelines specify a maximum size for a single variable. This can be checked with this. Impo...", 
"body" : "Detects variables that use more than n bytes, where n is defined by the current configuration. Default value: 1024 bytes. The value can be changed by double-clicking the line. Justification: Some programming guidelines specify a maximum size for a single variable. This can be checked with this. Importance: Low Example PROGRAM PLC_PRG\nVAR\n aobyTest : ARRAY [0..1024] OF BYTE;\nEND_VAR\n aobyTest[INT#0] := aobyTest[INT#0] + BYTE#1; Output in the Messages view: SA0100: Variable 'aobyTest' greater than 1024 bytes " }, 
{ "title" : "SA0101: Names with invalid length ", 
"url" : "_san_rule_sa0101.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0101: Names with invalid length ", 
"snippet" : "Detects names with invalid length. Justification: Some programming guidelines specify a minimum length for variable names. This analysis can be used to check compliance. Importance: Low PLCopen rule: N6 All rules are listed in the Settings Static Analysis: Rules dialog. There you can double-click Ru...", 
"body" : "Detects names with invalid length. Justification: Some programming guidelines specify a minimum length for variable names. This analysis can be used to check compliance. Importance: Low PLCopen rule: N6 All rules are listed in the Settings Static Analysis: Rules dialog. There you can double-click Rule 101 to open the rule-specific configuration. Then you can define the minimum and maximum number of characters and set exceptions to them in the Length of Names dialog. Example PROGRAM PLC1 \/\/ SA0101\nVAR\n iVar1 : INT; \/\/ SA0101\nEND_VAR\n Output in the Messages view: SA0101: Invalid length of name 'PLC1' " }, 
{ "title" : "SA0102: Access to program\/fb variables from the outside ", 
"url" : "_san_rule_sa0102.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0102: Access to program\/fb variables from the outside ", 
"snippet" : "Detects external access to local variables of programs or function blocks. Justification: CODESYS permits external read access to local variables of programs or function blocks. This contradicts the principle of data encapsulation (hiding data) and does not comply with the IEC 61131-3 standard. Impo...", 
"body" : "Detects external access to local variables of programs or function blocks. Justification: CODESYS permits external read access to local variables of programs or function blocks. This contradicts the principle of data encapsulation (hiding data) and does not comply with the IEC 61131-3 standard. Importance: Medium Example PROGRAM PLC_PRG\nVAR\n iCounter : INT;\n afb_Instance : AFB;\n bfb_Instance : BFB;\nEND_VAR iCounter := A_PRG.iLocal; \/\/ SA0102\niCounter := bfb_Instance.iLocal; \/\/ SA0102\nA_PRG(); FUNCTION_BLOCK AFB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iLocal: INT;\nEND_VAR METHOD METH : INT\nVAR_INPUT\nEND_VAR iLocal := iLocal + 1; FUNCTION_BLOCK BFB EXTENDS AFB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\nEND_VAR\nMETHOD METH : INT\nVAR_INPUT\nEND_VAR iLocal := iLocal + 1; PROGRAM A_PRG\nVAR\n iLocal: INT;\nEND_VAR iLocal := iLocal + 1;\n Output in the Messages view: SA0102: Access to program\/fb variable 'iLocal' from the outside " }, 
{ "title" : "SA0103: Concurrent access on not atomic data ", 
"url" : "_san_rule_sa0103.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0103: Concurrent access on not atomic data ", 
"snippet" : "Detects whether or not non-atomic variables (for example, with data type STRING , WSTRING , ARRAY , STRUCT , FB instances, 64-bit data types) are used in more than one task Justification: When there is no synchronization during access, inconsistent values can be read when reading in one task and wri...", 
"body" : "Detects whether or not non-atomic variables (for example, with data type STRING , WSTRING , ARRAY , STRUCT , FB instances, 64-bit data types) are used in more than one task Justification: When there is no synchronization during access, inconsistent values can be read when reading in one task and writing in another task at the same time. Importance: Medium For some data types, especially 64-bit integers, it depends on the platform whether or not access is atomic. Static analysis reports a problem only when the controller does not support atomic access to 64-bit integer data types. This rule does not apply in the following cases: If the target system has a floating point unit (FPU), then access of multiple tasks to LREAL variables is not detected If the target system is a 64-bit processor or the corresponding target setting is set for the target device, then the rule does not apply to 64-bit data types Example The project contains both programs, PRG1 and PRG2 . The program PRG1 is called by the task MainTask_1 . The program PRG2 is called by the task MainTask_2 . VAR_GLOBAL\n lrTest : LREAL; \/\/ Since the target system has an FPU, SA0103 does apply.\n lint1 : LINT;\n sTest : STRING; \/\/ SA0103\n wsTest : WSTRING; \/\/ SA0103\nEND_VAR PROGRAM PRG1 GVL.lrTest := 5.0;\nGVL.sTest := 'welt';\nGVL.wsTest := \"welt\";\nGVL.lint1 := 99;\n PROGRAM PRG2 GVL.lrTest := 5.0;\nGVL.sTest := 'hallo';\nGVL.wsTest := \"hallo\";\nGVL.lint1 := 88; Output in the Messages view: SA0103: Concurrent access on not atomic data 'sTest' SA0103: Concurrent access on not atomic data 'wsTest' " }, 
{ "title" : "SA0105: Multiple instance calls ", 
"url" : "_san_rule_sa0105.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0105: Multiple instance calls ", 
"snippet" : "Detects the instances of function blocks which are called multiple times. For this purpose, the function blocks have to be marked with the following pragma: {attribute 'analysis:report-multiple-instance-calls'} Justification: Some function blocks are designed in such as way that they can be called o...", 
"body" : "Detects the instances of function blocks which are called multiple times. For this purpose, the function blocks have to be marked with the following pragma: {attribute 'analysis:report-multiple-instance-calls'} Justification: Some function blocks are designed in such as way that they can be called only one time in the cycle. This test checks whether or not a call is made in multiple locations. Importance: Low PLCopen rule: CP16 \/ CP20 Example \/\/ {attribute 'analysis:report-multiple-instance-calls'} Deactivated\nFUNCTION_BLOCK FB_DoA\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iA : INT;\nEND_VAR\n iA := iA + 1; {attribute 'analysis:report-multiple-instance-calls'}\nFUNCTION_BLOCK FB_DoB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n iB : INT;\nEND_VAR\n iB := iB + 1; PROGRAM PLC_PRG\nVAR\n fbA : FB_DoA;\n fbB : FB_DoB;\nEND_VAR fbA();\nfbB(); \/\/ SA0105\nfbA();\nfbB(); \/\/ SA0105\n Output in the Messages view: SA0105: Instance 'fbB' called more than once " }, 
{ "title" : "SA0106: Virtual method calls in FB_INIT ", 
"url" : "_san_rule_sa0106.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0106: Virtual method calls in FB_INIT ", 
"snippet" : "Detects method calls in the FB_Init method of a base function block, which are overwritten by a function block derived from a base function block Justification: In these cases, it could be that the variables in the overwritten methods are not initialized in the base FB. Importance: High Example The ...", 
"body" : "Detects method calls in the FB_Init method of a base function block, which are overwritten by a function block derived from a base function block Justification: In these cases, it could be that the variables in the overwritten methods are not initialized in the base FB. Importance: High Example The function block FB_A includes the methods FB_Init and Meth_MyInit . FB_Init calls Meth_MyInit for initialization. The function block FB_B is derived from FB_A . PLC_PRG calls FB_B and therefore uses its mbMyDintB variable before it has been initialized. FB_B.Meth_MyInit overwrites FB_A.Meth_MyInit . FUNCTION_BLOCK FB_A\nVAR\n mbMyDintA : DINT;\nEND_VAR FUNCTION_BLOCK FB_B EXTENDS FB_A\nVAR\n mbMyDintB : DINT;\nEND_VAR METHOD FB_Init : BOOL\nVAR_INPUT\n bInitRetains:BOOL;\n bInCopyCode:BOOL;\nEND_VAR\nVAR\n diDummy:DINT; \/\/SA0106\nEND_VAR\n mbMyDintA := 123;\ndiDummy := Meth_MyInit(); METHOD Meth_MyInit : DINT\nVAR_INPUT\nEND_VAR\n mbMyDintB := 123; \/\/access to member of FB_B PROGRAM PLC_PRG\nVAR\n g_BInst : FB_B;\n xVar : BOOL;\nEND_VAR\n\n xVar := g_BInst.fb_init(TRUE, TRUE);\n\/\/this instruction causes the following order of initializations:\n\/\/FB_A.fb_init\n\/\/FB_B.Meth_MyInit \/\/SA0106\n\/\/FB_B.fb_init\n\/\/FB_B.Meth_MyInit Output in the Messages view: SA0106: Virtual method call 'Meth_MyInit' in FB_INIT " }, 
{ "title" : "SA0107: Missing formal parameters ", 
"url" : "_san_rule_sa0107.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0107: Missing formal parameters ", 
"snippet" : "Detects whether or not formal parameters are missing Justification: Code becomes more readable when formal parameters are specified in the call. Importance: Low Example FUNCTION FUNA : BOOL VAR_INPUT bDo : BOOL; bInit : BOOL; bManual : BOOL; END_VAR VAR iInit : INT; iLocal : INT; iManual : INT; END_...", 
"body" : "Detects whether or not formal parameters are missing Justification: Code becomes more readable when formal parameters are specified in the call. Importance: Low Example FUNCTION FUNA : BOOL\nVAR_INPUT\n bDo : BOOL;\n bInit : BOOL;\n bManual : BOOL;\nEND_VAR\nVAR\n iInit : INT;\n iLocal : INT;\n iManual : INT;\nEND_VAR\n IF bInit = TRUE THEN\n iInit := iInit + 1;\nEND_IF\nIF bDo = TRUE THEN\n iLocal := iLocal + 1;\nEND_IF\nIF bManual = TRUE THEN\n iManual := iManual + 1;\nEND_IF\nFUNA := TRUE;\n PROGRAM PLC_PRG\nVAR\nEND_VAR\n FUNA(bInit := TRUE, bDo := TRUE, bManual := FALSE); \/\/ OK\nFUNA(TRUE, TRUE, bManual:= FALSE); \/\/ SA0107 Output in the Messages view: SA0107: Missing formal parameter for input 'TRUE' " }, 
{ "title" : "Checking Strict IEC Rules ", 
"url" : "_san_check_strict_rules.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Checking Strict IEC Rules ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0111: Pointer variables ", 
"url" : "_san_rule_sa0111.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Checking Strict IEC Rules \/ SA0111: Pointer variables ", 
"snippet" : "Detects variables of type POINTER TO Justification: The IEC 61131-3 standard does not permit pointers. Importance: Low Example VAR piTemp : POINTER TO INT; pbyTemp : POINTER TO BYTE; END_VAR Output in the Messages view: SA0111: Data type POINTER not allowed...", 
"body" : "Detects variables of type POINTER TO Justification: The IEC 61131-3 standard does not permit pointers. Importance: Low Example VAR\n piTemp : POINTER TO INT;\n pbyTemp : POINTER TO BYTE;\nEND_VAR\n Output in the Messages view: SA0111: Data type POINTER not allowed " }, 
{ "title" : "SA0112: Reference variables ", 
"url" : "_san_rule_sa0112.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Checking Strict IEC Rules \/ SA0112: Reference variables ", 
"snippet" : "Detects variables of type REFERENCE TO Justification: The IEC 61131-3 standard does not permit references. Importance: Low Example VAR ref_int : REFERENCE TO INT; ref_dw : REFERENCE TO DWORD; END_VAR Output in the Messages view: SA0112: Data type REFERENCE not allowed...", 
"body" : "Detects variables of type REFERENCE TO Justification: The IEC 61131-3 standard does not permit references. Importance: Low Example VAR\n ref_int : REFERENCE TO INT;\n ref_dw : REFERENCE TO DWORD;\nEND_VAR\n Output in the Messages view: SA0112: Data type REFERENCE not allowed " }, 
{ "title" : "SA0113: Variables with data type WSTRING ", 
"url" : "_san_rule_sa0113.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Checking Strict IEC Rules \/ SA0113: Variables with data type WSTRING ", 
"snippet" : "Determines variables of type WSTRING . Justification: Not all systems support WSTRING . The code is more easily portable without WSTRING . Importance: Low Example VAR wstrTemp : WSTRING; END_VAR Output in the Messages view: SA0113: Data type WSTRING not allowed...", 
"body" : "Determines variables of type WSTRING . Justification: Not all systems support WSTRING . The code is more easily portable without WSTRING . Importance: Low Example VAR\n wstrTemp : WSTRING;\nEND_VAR\n Output in the Messages view: SA0113: Data type WSTRING not allowed " }, 
{ "title" : "SA0114: Variables with data type LTIME ", 
"url" : "_san_rule_sa0114.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Checking Strict IEC Rules \/ SA0114: Variables with data type LTIME ", 
"snippet" : "Detects variables of type LTIME Justification: Not all systems support LTIME The code is more easily portable without LTIME . Importance: Low Example VAR ltVar : LTIME; \/\/ SA0114 END_VAR Output in the Messages view: SA0114: Data type LTIME not allowed For more information, see: Attribute: 'analysis:...", 
"body" : "Detects variables of type LTIME Justification: Not all systems support LTIME The code is more easily portable without LTIME . Importance: Low Example VAR\n ltVar : LTIME; \/\/ SA0114\nEND_VAR\n Output in the Messages view: SA0114: Data type LTIME not allowed For more information, see: Attribute: 'analysis:report-multiple-instance-calls' " }, 
{ "title" : "SA0115: Variables with data type UNION ", 
"url" : "_san_rule_sa0115.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Checking Strict IEC Rules \/ SA0115: Variables with data type UNION ", 
"snippet" : "Detects declarations of a UNION data type and variable declarations of the UNION type Justification: The IEC 61131-3 standard does not include unions. The code is more easily portable without unions. Importance: Low Example TYPE A_UNION: UNION lrTemp : LREAL; liTemp : LINT; END_UNION END_TYPE PROGRA...", 
"body" : "Detects declarations of a UNION data type and variable declarations of the UNION type Justification: The IEC 61131-3 standard does not include unions. The code is more easily portable without unions. Importance: Low Example TYPE A_UNION: \nUNION\n lrTemp : LREAL;\n liTemp : LINT;\nEND_UNION\nEND_TYPE PROGRAM PLC_PRG\nVAR\n aunionVar: A_UNION;\n liVar : LINT;\nEND_VAR aunionVar.lrTemp := 0.123E-12;\nliVar := aunionVar.liTemp; Output in the Messages view: SA0115: Unions not allowed " }, 
{ "title" : "SA0117: Variables with data type BIT ", 
"url" : "_san_rule_sa0117.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Checking Strict IEC Rules \/ SA0117: Variables with data type BIT ", 
"snippet" : "Detects variable declarations of data type BIT (possible within structure definitions) Justification: The IEC 61131-3 standard does not include the data type BIT . The code is more easily portable without BIT . Importance: Low Example TYPE Struct1 : STRUCT bitVar : BIT; iVar : INT; bVar : BOOL; END_...", 
"body" : "Detects variable declarations of data type BIT (possible within structure definitions) Justification: The IEC 61131-3 standard does not include the data type BIT . The code is more easily portable without BIT . Importance: Low Example TYPE Struct1 :\nSTRUCT\n bitVar : BIT;\n iVar : INT;\n bVar : BOOL;\nEND_STRUCT\nEND_TYPE\n Output in the Messages view: SA0117: Variables with data type BIT " }, 
{ "title" : "SA0119:Object-oriented features ", 
"url" : "_san_rule_sa0119.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Checking Strict IEC Rules \/ SA0119:Object-oriented features ", 
"snippet" : "Detects the use of object-oriented features, such as function block declarations with EXTENDS and IMPLEMENTS , or property and interface declarations. This rule is useful when you write code which is intended to be ported to other IEC 61131-3-compliant systems. Justification: Not all systems support...", 
"body" : "Detects the use of object-oriented features, such as function block declarations with EXTENDS and IMPLEMENTS , or property and interface declarations. This rule is useful when you write code which is intended to be ported to other IEC 61131-3-compliant systems. Justification: Not all systems support object-oriented programming. The code is more easily portable without object-orientation. Importance: Low Example \/\/Function block extended by another and implementing an interface:\nFUNCTION_BLOCK POU EXTENDS CTD IMPLEMENTS ITF \/\/SA0119\n;\n \/\/ Declaration parts of property methods assigned to a function block:\nPOU.Prop.Get \/\/SA0119 POU.Prop.Set \/\/SA0119 Output in the Messages view: SA0119: Object-oriented features not allowed " }, 
{ "title" : "SA0120: Program calls ", 
"url" : "_san_rule_sa0120.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Checking Strict IEC Rules \/ SA0120: Program calls ", 
"snippet" : "Detects program calls Justification: According to the IEC 61131-3 standard, programs can be called in the task configuration only. The code is more easily portable when you do not call programs from other locations. Importance: Low Example PROGRAM prog_control VAR END_VAR ; PROGRAM PLC_PRG VAR END_V...", 
"body" : "Detects program calls Justification: According to the IEC 61131-3 standard, programs can be called in the task configuration only. The code is more easily portable when you do not call programs from other locations. Importance: Low Example PROGRAM prog_control\nVAR\nEND_VAR\n; PROGRAM PLC_PRG\nVAR\nEND_VAR\n prog_control(); Output in the Messages view: SA0120: Program call to 'prg_control' not allowed " }, 
{ "title" : "SA0121: Missing VAR_EXTERNAL declarations ", 
"url" : "_san_rule_sa0121.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Checking Strict IEC Rules \/ SA0121: Missing VAR_EXTERNAL declarations ", 
"snippet" : "Detects the use of a global variable in function blocks without them being declared there as VAR_EXTERNAL Justification: According to the IEC 61131-3 standard, access to global variables is permitted only by an explicit import by means of a VAR_EXTERNAL declaration. Importance: Low PLCopen rule: CP1...", 
"body" : "Detects the use of a global variable in function blocks without them being declared there as VAR_EXTERNAL Justification: According to the IEC 61131-3 standard, access to global variables is permitted only by an explicit import by means of a VAR_EXTERNAL declaration. Importance: Low PLCopen rule: CP18 Example VAR_GLOBAL\n iGlob1 : INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n ivar : INT;\nEND_VAR\n ivar := iGlob1; \/\/ SA0121 Output in the Messages view: SA0121: VAR_EXTERNAL declaration required for variable 'iGlob1' Example for error avoidance VAR_GLOBAL\n iGlob1:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n ivar:INT;\nEND_VAR\nVAR_EXTERNAL\n iGlob1:INT;\nEND_VAR\n ivar:=iGlob1; \/\/ OK " }, 
{ "title" : "SA0122: Array index defined as expression ", 
"url" : "_san_rule_sa0122.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Checking Strict IEC Rules \/ SA0122: Array index defined as expression ", 
"snippet" : "Detects the use of expressions in the declaration of array indexes Justification: Not all systems permit expressions as array limits. Importance: Low Example PROGRAM PLC_PRG VAR CONSTANT c_iValue : INT := INT#15; END_VAR VAR arr : ARRAY [0..c_iValue + 1] OF INT; END_VAR Output in the Messages view: ...", 
"body" : "Detects the use of expressions in the declaration of array indexes Justification: Not all systems permit expressions as array limits. Importance: Low Example PROGRAM PLC_PRG\nVAR CONSTANT\n c_iValue : INT := INT#15;\nEND_VAR\nVAR\n arr : ARRAY [0..c_iValue + 1] OF INT;\nEND_VAR\n Output in the Messages view: SA0122: Only constants allowed for array definition 'arr' " }, 
{ "title" : "SA0123: Usages of INI, ADR or BITADR ", 
"url" : "_san_rule_sa0123.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Checking Strict IEC Rules \/ SA0123: Usages of INI, ADR or BITADR ", 
"snippet" : "Detects the use of the CODESYS Static Analysis -specific operators INI , ADR , and BITADR . Justification: CODESYS -specific operators prevent the portability of code. Importance: Low Example PROGRAM PLC_PRG VAR uiTemp : UINT; TempVarInFUNC : DWORD; END_VAR TempVarInFUNC := ADR(uiTemp); \/\/SA0123 Out...", 
"body" : "Detects the use of the CODESYS Static Analysis -specific operators INI , ADR , and BITADR . Justification: CODESYS -specific operators prevent the portability of code. Importance: Low Example PROGRAM PLC_PRG\nVAR\n uiTemp : UINT;\n TempVarInFUNC : DWORD;\nEND_VAR\n TempVarInFUNC := ADR(uiTemp); \/\/SA0123 Output in the Messages view: SA0123: Operator 'ADR' not allowed " }, 
{ "title" : "SA0147: Unusual shift operation – strict ", 
"url" : "_san_rule_sa0147.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Checking Strict IEC Rules \/ SA0147: Unusual shift operation – strict ", 
"snippet" : "Detects bit shift operations which are not made to bit field data types ( BYTE , WORD , DWORD , LWORD ) Justification: The IEC 61131-3 standard permits bit access only to bit field data types. However, the CODESYS compiler also permits bit shift operations with unsigned data types. Importance: Low S...", 
"body" : "Detects bit shift operations which are not made to bit field data types ( BYTE , WORD , DWORD , LWORD ) Justification: The IEC 61131-3 standard permits bit access only to bit field data types. However, the CODESYS compiler also permits bit shift operations with unsigned data types. Importance: Low See also the strict rule SA0018 . Example PROGRAM PLC_PRG\nVAR\n in_byte : BYTE := 16#45; \/\/ 2#01000101\n in_word : WORD := 16#0045; \/\/ 2#0000000001000101\n in_uint : UINT;\n in_dint : DINT;\n erg_byte : BYTE;\n erg_word : WORD;\n erg_uint : UINT;\n erg_dint : DINT;\n n: BYTE := 2;\nEND_VAR\n erg_byte := SHL(in_byte,n); \/\/ no error because BYTE is a bit field\nerg_word := SHL(in_word,n); \/\/ no error because WORD is a bit field\nerg_uint := SHL(in_uint,n); \/\/ SA0147\nerg_dint := SHL(in_dint,n); \/\/ SA0147 Output in the Messages view: SA0147: Unusual shift operation – strict " }, 
{ "title" : "SA0148: Unusual bit access – strict ", 
"url" : "_san_rule_sa0148.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Checking Strict IEC Rules \/ SA0148: Unusual bit access – strict ", 
"snippet" : "Detects bit access which is not made to bit field data types ( BYTE , WORD , DWORD , and LWORD ). The IEC 61131-3 standard permits only bit access to bit field data types. However, the CODESYS compiler also permits bit access to unsigned data types. Importance: Low Example PROGRAM PLC_PRG VAR iTemp1...", 
"body" : "Detects bit access which is not made to bit field data types ( BYTE , WORD , DWORD , and LWORD ). The IEC 61131-3 standard permits only bit access to bit field data types. However, the CODESYS compiler also permits bit access to unsigned data types. Importance: Low Example PROGRAM PLC_PRG\nVAR\n iTemp1 : INT;\n diTemp3 : DINT;\n uliTemp4 : ULINT;\n siTemp5 : SINT;\n usiTemp6 : USINT;\n byTemp2 : BYTE;\nEND_VAR\n iTemp1.3 := TRUE; \/\/ SA0148\ndiTemp3.4 := TRUE; \/\/ SA0148\nuliTemp4.18 := FALSE; \/\/ SA0148\nsiTemp5.2 := FALSE; \/\/ SA0148\nusiTemp6.3 := TRUE; \/\/ SA0148\nbyTemp2.5 := FALSE; \/\/ no error because BYTE is a bitfield Output in the Messages view: SA0148: Unusual bit access – strict " }, 
{ "title" : "SA0118: Initialisations not using constants ", 
"url" : "_san_rule_sa0118.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Checking Strict IEC Rules \/ SA0118: Initialisations not using constants ", 
"snippet" : "Detects initializations that do not assign constants Justification: Initializations should be constant if possible and should not refer to other variables. In particular, you should avoid function calls during initialization because this can allow access to uninitialized data. Importance: Medium Exa...", 
"body" : "Detects initializations that do not assign constants Justification: Initializations should be constant if possible and should not refer to other variables. In particular, you should avoid function calls during initialization because this can allow access to uninitialized data. Importance: Medium Example PROGRAM PLC_PRG\nVAR\n dwTemp : DWORD := 22;\n dwTest : DWORD := dwTemp; \/\/ SA0118\n dwVar : DWORD := TempVarInFUNC(); \/\/ SA0118\nEND_VAR\n Output in the Messages view: SA0118: Initialisations not using constants " }, 
{ "title" : "SA0124: Pointer dereferences in declarations ", 
"url" : "_san_rule_sa0124.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Checking Strict IEC Rules \/ SA0124: Pointer dereferences in declarations ", 
"snippet" : "Detects pointer dereferences which are used for initialization in the declaration part Justification: Pointers and references should not be used for initializations because this can lead to access violations if the pointer has not been initialized. Importance: Medium Example TYPE TESTSTRUCT : STRUCT...", 
"body" : "Detects pointer dereferences which are used for initialization in the declaration part Justification: Pointers and references should not be used for initializations because this can lead to access violations if the pointer has not been initialized. Importance: Medium Example TYPE TESTSTRUCT :\nSTRUCT\n xA : BOOL;\n xB : BOOL;\nEND_STRUCT\nEND_TYPE FUNCTION_BLOCK FB_Test\nVAR_INPUT\n pTeststruct : POINTER TO TESTSTRUCT;\nEND_VAR\nVAR\n xA : BOOL := pTeststruct^.xA; \/\/SA0124 \nEND_VAR\n\n xA := TRUE; PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\nEND_VAR\n fbTest(); Output in the Messages view: SA0124: Pointer dereferences in declarations " }, 
{ "title" : "SA0125: References in initializations ", 
"url" : "_san_rule_sa0125.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Checking Strict IEC Rules \/ SA0125: References in initializations ", 
"snippet" : "Detects reference variables which are used for initialization in the declaration part Justification: Pointers and references should not be used for initializations because this can lead to access violations if the pointer has not been initialized. Importance: Medium Example TYPE TESTSTRUCT : STRUCT ...", 
"body" : "Detects reference variables which are used for initialization in the declaration part Justification: Pointers and references should not be used for initializations because this can lead to access violations if the pointer has not been initialized. Importance: Medium Example TYPE TESTSTRUCT :\nSTRUCT\n xA : BOOL;\n xB : BOOL;\nEND_STRUCT\nEND_TYPE FUNCTION_BLOCK FB_Test\nVAR_INPUT\n refTeststruct: REFERENCE TO TESTSTRUCT;\nEND_VAR\nVAR\n xA : BOOL := refTeststruct.xA; \/\/SA0125\nEND_VAR\n xA := TRUE; PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\nEND_VAR\n fbTest(); Output in the Messages view: SA0125: Reference used in initialisation " }, 
{ "title" : "SA0140: Statements commented out ", 
"url" : "_san_rule_sa0140.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0140: Statements commented out ", 
"snippet" : "Detects commented-out statements Justification: Code is often commented out for debugging purposes. When this kind of comment is released, it is not always clear at a later time whether the code should be deleted, or whether it has been commented out for debugging purposes and unintentionally not un...", 
"body" : "Detects commented-out statements Justification: Code is often commented out for debugging purposes. When this kind of comment is released, it is not always clear at a later time whether the code should be deleted, or whether it has been commented out for debugging purposes and unintentionally not uncommented. Importance: High PLCopen rule: C4 Example PROGRAM PLC_PRG\nVAR\n iValue1: INT;\n iValue2: INT;\nEND_VAR\n iValue1 := 100;\niValue2 := 200;\n\/\/ iValue2 := 300; Output in the Messages view: SA0140: Statements commented out: iValue2 := 300 " }, 
{ "title" : "Possible Use of Uninitialized Variables ", 
"url" : "_san_non_initialized_variables.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Possible Use of Uninitialized Variables ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SA0039: Possible null-pointer deferences ", 
"url" : "_san_rule_sa0039.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Possible Use of Uninitialized Variables \/ SA0039: Possible null-pointer deferences ", 
"snippet" : "Detects code locations where a null pointer is possibly dereferenced Justification: A pointer should be checked before each dereferencing to make sure it is not equal to zero. Otherwise an access violation may occur at runtime. Importance: High Example PROGRAM PLC_PRG VAR ptiVar1:POINTER TO INT; pti...", 
"body" : "Detects code locations where a null pointer is possibly dereferenced Justification: A pointer should be checked before each dereferencing to make sure it is not equal to zero. Otherwise an access violation may occur at runtime. Importance: High Example PROGRAM PLC_PRG\nVAR\n ptiVar1:POINTER TO INT;\n ptiVar2:POINTER TO INT;\n ptiVar3:POINTER TO INT;\n iVar:INT;\n iCount :INT;\n iCondition: INT;\nEND_VAR\n iCount := iCount + INT#1;\nptiVar1 := ADR(iVar);\nptiVar1^ := iCondition; \/\/ OK - valid reference\nptiVar2^ := iCondition; \/\/ SA0039 - null pointer dereferenciation\niVar := ptiVar3^; \/\/ SA0039 - null pointer dereferenciation Output in the Messages view: SA0039: Possible null-pointer deference 'ptiVar2^' SA0039: Possible null-pointer deference 'ptiVar3^' " }, 
{ "title" : "SA0046: Possible use of not initialised interface ", 
"url" : "_san_rule_sa0046.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Possible Use of Uninitialized Variables \/ SA0046: Possible use of not initialised interface ", 
"snippet" : "Detects the use of interfaces that were not initialized before being used Justification: An interface reference should be checked for <> 0 before it is used. Otherwise an access violation may occur during access. Importance: High Example \/\/Declaration of INTERFACE ITF and assigned METH2: METHOD METH...", 
"body" : "Detects the use of interfaces that were not initialized before being used Justification: An interface reference should be checked for <> 0 before it is used. Otherwise an access violation may occur during access. Importance: High Example \/\/Declaration of INTERFACE ITF and assigned METH2:\nMETHOD METH2 : BOOL\nVAR_INPUT\n iInput2:INT;\nEND_VAR \/\/Declaration of INTERFACE Master_ITF1 and assigned METH:\nMETHOD METH : BOOL\nVAR_INPUT\n iInput:INT;\nEND_VAR PROGRAM PLC_PRG\nVAR\n instPOU : POU;\n instITF : ITF;\n instMasterITF1 : Master_ITF1;\n instMasterITF2 : Master_ITF2;\n iDummy : INT;\n xDummy : BOOL;\n instNoInitITF : ITF;\n instNoInitITF2 : ITF;\n instNoInitMasterITF1 : Master_ITF1;\n instNoInitMasterITF2 : Master_ITF2;\nEND_VAR instITF := instPOU;\nxDummy := instITF.METH(iInput := iDummy); \/\/ OK\ninstMasterITF1 := instPOU;\nxDummy := instMasterITF1.METH(iInput := iDummy); \/\/ OK\n\nxDummy := instNoInitITF.METH(iInput := INT#1); \/\/ SA0046\nxDummy := instNoInitITF.METH2(iInput2 := INT#2); \/\/ SA0046\nxDummy := instNoInitMasterITF1.METH(iInput := INT#3); \/\/ SA0046\niDummy := instNoInitMasterITF2.Prop; \/\/ SA0046\n\nIF instNoInitITF <> 0 THEN\n instNoInitITF.Prop; \/\/ OK, because the interface can't be 0\nEND_IF Output in the Messages view: SA0046: Possible use of not initialised interface 'instNoInitITF' SA0046: Possible use of not initialised interface 'instNoInitITF' SA0046: Possible use of not initialised interface 'instNoInitMasterITF1' SA0046: Possible use of not initialised interface 'instNoInitMasterITF2' " }, 
{ "title" : "SA0145: Possible use of not initialised reference ", 
"url" : "_san_rule_sa0145.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ Possible Use of Uninitialized Variables \/ SA0145: Possible use of not initialised reference ", 
"snippet" : "Detects any reference variables that may not be initialized before use and are not checked by the operator __ISVALIDREF . This rule is applied in the implementation part of POUs. For the declaration, there is rule SA0124 . Justification: A reference should be checked for its validity before access b...", 
"body" : "Detects any reference variables that may not be initialized before use and are not checked by the operator __ISVALIDREF . This rule is applied in the implementation part of POUs. For the declaration, there is rule SA0124 . Justification: A reference should be checked for its validity before access because an access violation may occur during access. Importance: High Example PROGRAM PLC_PRG\nVAR_INPUT\n ref_iTest : REFERENCE TO INT;\nEND_VAR\n ref_iTest := 99; \/\/ SA0145\nIF __ISVALIDREF(ref_iTest) THEN\n ref_iTest := 88;\nEND_IF Output in the Messages view: SA0145: Possible use of not initialised reference 'ref_iTest' " }, 
{ "title" : "SA0150: Violations of lower or upper limits or the metrics ", 
"url" : "_san_rule_sa0150.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0150: Violations of lower or upper limits or the metrics ", 
"snippet" : "Detects the POUs that violate the activated metrics at the lower or upper limits Justification: Code that complies with certain metrics is easier to read, easier to maintain, and easier to test. Importance: High PLCopen rule: CP9 Example Initial situation: The Number of calls metric is selected in P...", 
"body" : "Detects the POUs that violate the activated metrics at the lower or upper limits Justification: Code that complies with certain metrics is easier to read, easier to maintain, and easier to test. Importance: High PLCopen rule: CP9 Example Initial situation: The Number of calls metric is selected in Project Settings → Static Analysis → Metrics . Lower limit: 0 ; upper limit: 3 . Prog_1 is called five times. When running the static analysis, the SA0150: Metric violation for Prog_1. Report for metric calls (5) > 2 error is issued in the message view, in the Build category. " }, 
{ "title" : "SA0160: Recursive calls ", 
"url" : "_san_rule_sa0160.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0160: Recursive calls ", 
"snippet" : "Detects recursive calls in actions, methods, and properties of function blocks. Also detects possible recursions from virtual function calls and interface calls. Justification: Recursions lead to non-deterministic behavior and are therefore a source of errors. Importance: Medium PLCopen rule: CP13 E...", 
"body" : "Detects recursive calls in actions, methods, and properties of function blocks. Also detects possible recursions from virtual function calls and interface calls. Justification: Recursions lead to non-deterministic behavior and are therefore a source of errors. Importance: Medium PLCopen rule: CP13 Example The following method Call is assigned to the function block FB_Test : FUNCTION_BLOCK FB_Test\nVAR\n bParameter: BOOL;\nEND_VAR\n METHOD Call : BOOL\nVAR_INPUT\nEND_VAR\n Call := THIS^.Call(); \/\/SA0160 The program PLC_PRG calls FB_Test : PROGRAM PLC_PRG\nVAR\n fbTest : FB_Test;\n bValue : BOOL;\nEND_VAR\n bValue := fbTest.bParameter;\nfbTest.Call(); Output in the Messages view: SA0160: Recursive call detected: 'PLC_PRG' -> 'FB_Test.Call' -> 'FB_Test.Call' " }, 
{ "title" : "SA0161: Unpacked structure in packed structure ", 
"url" : "_san_rule_sa0161.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0161: Unpacked structure in packed structure ", 
"snippet" : "Detects unpacked structures which are used in packed structures Justification: The compiler typically sets an unpacked structure to an address which allows an aligned access to all elements within the structure. If you create this structure in a packed structure, then aligned access is no longer pos...", 
"body" : "Detects unpacked structures which are used in packed structures Justification: The compiler typically sets an unpacked structure to an address which allows an aligned access to all elements within the structure. If you create this structure in a packed structure, then aligned access is no longer possible. Furthermore, access to an element in the unpacked structure can lead to a \"misalignment exception\". Importance: High Example The structure structSingleDataRecord is packed, but it contains the unpacked structures struct4Byte and struct9Byte . {attribute 'pack_mode' := '1'}\nTYPE structSingleDataRecord :\nSTRUCT\n str9ByteData: struct9Byte; (* 9 BYTE *)\n str4ByteData: struct4Byte; (* 4 BYTE *)\n udi1: UDINT;\n udi2: UDINT;\n udi3: UDINT;\n usi4: USINT;\nEND_STRUCT\nEND_TYPE (* 9 BYTE *)\nTYPE struct9Byte :\nSTRUCT\n usiRotorSlots: USINT; (* 1 BYTE *)\n uiMaxCurrent: UINT; (* 2 BYTE *)\n usiVelocity: USINT; (* 1 BYTE *)\n uiAcceleration: UINT; (* 2 BYTE *)\n uiDeceleration: UINT; (* 2 BYTE *)\n usiDirectionChange: USINT; (* 1 BYTE *)\nEND_STRUCT\nEND_TYPE TYPE struct4Byte :\nSTRUCT\n \/\/udiDummy : UDINT;\n rRealDummy : REAL;\nEND_STRUCT\nEND_TYPE Output in the Messages view: SA0161: Declaration of an unpacked struct 'struct9ByteData' inside a packed struct 'structSingleDataRecord' SA0161: Declaration of an unpacked struct 'struct4ByteData' inside a packed struct 'structSingleDataRecord' " }, 
{ "title" : "SA0162: Missing comments ", 
"url" : "_san_rule_sa0162.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0162: Missing comments ", 
"snippet" : "Detects uncommented locations in the program Justification: Complete commenting is required by many programming guidelines, and it increases the readability and maintainability of the code. Importance: Low PLCopen rule: C2 Comments are required in the following cases: For the declaration of variable...", 
"body" : "Detects uncommented locations in the program Justification: Complete commenting is required by many programming guidelines, and it increases the readability and maintainability of the code. Importance: Low PLCopen rule: C2 Comments are required in the following cases: For the declaration of variables. The comments are located above or to the right. For the declaration of programs, function blocks, or methods. The comments are located above the declaration (in the first line). Example PROGRAM PLC_PRG\nVAR\n iMaxValue: INT;\nEND_VAR\n Output in the Messages view: SA0162: Missing comment for 'PLC_PRG' SA0162: Missing comment for 'iMaxValue' " }, 
{ "title" : "SA0163: Nested comments ", 
"url" : "_san_rule_sa0163.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0163: Nested comments ", 
"snippet" : "Detects nested comments Justification: Nested comments should be avoided because they are difficult to read. Importance: Low PLCopen rule: C3 Example {attribute 'do-analysis'} (* That is (* nested comment 1 *) *) PROGRAM PLC_PRG VAR (* That is \/\/ nested comment 2 comment *) iVal1: INT; iVal2: INT; (...", 
"body" : "Detects nested comments Justification: Nested comments should be avoided because they are difficult to read. Importance: Low PLCopen rule: C3 Example {attribute 'do-analysis'}\n(* That is\n(* nested comment 1 *)\n*)\nPROGRAM PLC_PRG\nVAR\n(* That is\n\/\/ nested comment 2\ncomment *)\n iVal1: INT;\n iVal2: INT;\n\n(* That is\n(* nested comment 3 *) *)\n pVal3: POINTER TO DWORD;\n hugo: INT;\nEND_VAR\n (* That is\n\/\/ nested comment 4\ncomment *)\niVal1 := iVal1 + 1;\n(* That is\n(* nested comment 5 *)\n*)\n\n(* Not that one *) Output in the Messages view: SA0163: Nested comment 'nested comment 1' SA0163: Nested comment 'nested comment 2' SA0163: Nested comment 'nested comment 3' SA0163: Nested comment 'nested comment 4' SA0163: Nested comment 'nested comment 5' " }, 
{ "title" : "SA0164: Multiline comments ", 
"url" : "_san_rule_sa0164.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0164: Multiline comments ", 
"snippet" : "Detects multiline comments which are coded as (* comment *) . Only single-line comments which are coded as \/\/ comment are permitted. Justification: Some programming guidelines prohibit multiline comments in code because the beginning and end of a comment could get lost and the closing comment bracke...", 
"body" : "Detects multiline comments which are coded as (* comment *) . Only single-line comments which are coded as \/\/ comment are permitted. Justification: Some programming guidelines prohibit multiline comments in code because the beginning and end of a comment could get lost and the closing comment bracket could be deleted by accident. You can deactivate this check by means of the pragma analysis , also for comments in the declaration part. Importance: Low PLCopen rule: C5 Example {attribute 'do-analysis'}\n(*\n This is a multi-line comment \/\/ SA0164\n*)\nPROGRAM PLC_PRG\nVAR\n\/\/ This is a single line comment\n a: DINT;\nEND_VAR\n (* This is not a single line comment *) \/\/ SA0164\na := a + 1; Output in the Messages view: SA0164: Use single line comments only " }, 
{ "title" : "SA0165: Tasks calling other POUs than programs ", 
"url" : "_san_rule_sa0165.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0165: Tasks calling other POUs than programs ", 
"snippet" : "Detects tasks that call function blocks or functions instead of a program Justification: This rule is part of the PLCopen Coding Guidelines. Therefore, compliance is also checked in CODESYS . We do not see any problems with data consistency in CODESYS if tasks would call POUs other than programs. Ho...", 
"body" : "Detects tasks that call function blocks or functions instead of a program Justification: This rule is part of the PLCopen Coding Guidelines. Therefore, compliance is also checked in CODESYS . We do not see any problems with data consistency in CODESYS if tasks would call POUs other than programs. However, problems can occur if the code is to be ported to other platforms. Importance: Low PLCopen rule: CP16 Tasks are inserted below the task configuration. The POUs to be called are configured in the tasks. The POUs must be the Program type. The Function block and Function types are not permitted. Example " }, 
{ "title" : "SA0166: Max. number of input\/output\/in-out variables... ", 
"url" : "_san_rule_sa0166.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0166: Max. number of input\/output\/in-out variables... ", 
"snippet" : "Detects whether or not a defined number of input variables ( VAR_INPUT ), output variables ( VAR_OUTPUT ) or VAR_IN_OUT variables is exceeded in a POU. In the Project Settings , double-click the rule entry to open a dialog where you define the maximum number. Justification: This is about checking in...", 
"body" : "Detects whether or not a defined number of input variables ( VAR_INPUT ), output variables ( VAR_OUTPUT ) or VAR_IN_OUT variables is exceeded in a POU. In the Project Settings , double-click the rule entry to open a dialog where you define the maximum number. Justification: This is about checking individual programming guidelines. Many programming guidelines provide for a maximum number of POU parameters. Too many parameters make the code unreadable and the POUs difficult to test. Importance: Medium PLCopen rule: CP23 Example In the project settings, for Rule 166, you have defined a maximum number of 1 for VAR_IN_OUT variables. FUNCTION_BLOCK FB1\nVAR_INPUT\n xIn : BOOL;\nEND_VAR\nVAR_IN_OUT\n xInOut1 : BOOL;\n xInOut2 : BOOL;\nEND_VAR\n Output in the Messages view: SA0166: Too many VAR_IN_OUT variables in POU 'FB1' " }, 
{ "title" : "SA0167: Temporary function block instances ", 
"url" : "_san_rule_sa0167.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0167: Temporary function block instances ", 
"snippet" : "The check detects function block instances which are declared as temporary variables. This affects instances which are declared in a method or function or as VAR_TEMP , and therefore are reinitialized in each processing cycle or for each POU call. Justification: Function blocks have a state that is ...", 
"body" : "The check detects function block instances which are declared as temporary variables. This affects instances which are declared in a method or function or as VAR_TEMP , and therefore are reinitialized in each processing cycle or for each POU call. Justification: Function blocks have a state that is usually maintained over multiple PLC cycles. An instance on the stack exists only for the duration of the function call. Therefore, it rarely makes sense to create an instance as a temporary variable. Secondly, function block instances are often large and need a lot of space on the stack (which is usually restricted to controllers). Thirdly, the initialization and often also the scheduling of a function block can take a long time. Importance: Medium Example PROGRAM PLC_PRG\nVAR\nEND_VAR\nVAR_TEMP\n yafb: AFB;\nEND_VAR FUNCTION Fun : INT\nVAR_INPUT\nEND_VAR\nVAR\n funafb: AFB;\nEND_VAR\n METHOD METH : INT\nVAR_INPUT\nEND_VAR\nVAR\n methafb: AFB; \/\/ SA0167\nEND_VAR Output in the Messages view: SA0167: Temporary function block instance: 'methafb' " }, 
{ "title" : "SA0168: Unnecessary Assignments ", 
"url" : "_san_rule_sa0168.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0168: Unnecessary Assignments ", 
"snippet" : "Detects assignments to variables which do not have any effect in the code. Justification: When values are assigned to a variable multiple times without the variable being evaluated between assignments, the first assignments do not have any effect on the program. Importance: Low Example PROGRAM PLC_P...", 
"body" : "Detects assignments to variables which do not have any effect in the code. Justification: When values are assigned to a variable multiple times without the variable being evaluated between assignments, the first assignments do not have any effect on the program. Importance: Low Example PROGRAM PLC_PRG\nVAR\n dwVal1 : DWORD;\n dwVal2 : DWORD;\nEND_VAR\n \/\/ unnecessary assignment\ndwVal1 := 1; \nIF dwVal2 > 100 THEN\n dwVal2 := 0;\n dwVal2 := dwVal2 + 1;\nEND_IF\ndwVal1 := 2; Output in the Messages view: SA0168: The variable 'dwVal1' is assigned, but its value is never used. " }, 
{ "title" : "SA0169: Ignored outputs ", 
"url" : "_san_rule_sa0169.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0169: Ignored outputs ", 
"snippet" : "Detects the outputs of methods and functions which are not specified when calling the method or function. Justification: Ignored outputs can be a notice about an unhandled error or meaningless function calls because results are not used. Importance: Medium Example FUNCTION Fun1 VAR_INPUT bIn : BOOL;...", 
"body" : "Detects the outputs of methods and functions which are not specified when calling the method or function. Justification: Ignored outputs can be a notice about an unhandled error or meaningless function calls because results are not used. Importance: Medium Example FUNCTION Fun1\nVAR_INPUT\n bIn : BOOL;\nVAR_END\nVAR_OUTPUT\n bOut : BOOL;\nEND_VA\n ; PROGRAM PLC_PRG\nVAR\n bValue :BOOl;\nEND_VAR\n Fun1(bIn : TRUE);\n Output in the Messages view: SA0169: The output 'bOut' is ignored when called " }, 
{ "title" : "SA0170: Address of an output variable should not be used ", 
"url" : "_san_rule_sa0170.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0170: Address of an output variable should not be used ", 
"snippet" : "Detects the code locations where the address of an output variable ( VAR_OUTPUT , VAR_IN_OUT ) of a function block is used. Justification: It is not allowed to use the address of a function block output in the following way: By means of the ADR operator By means of REF= Exception: No error is report...", 
"body" : "Detects the code locations where the address of an output variable ( VAR_OUTPUT , VAR_IN_OUT ) of a function block is used. Justification: It is not allowed to use the address of a function block output in the following way: By means of the ADR operator By means of REF= Exception: No error is reported if the output variable is used within the same function block. Importance: Medium Example Function block FB1 has the VAR_OUTPUT variable iOutVal : INT; The following access in another POU generates Error SA0170: \/\/FB1_inst is of type FB1\naddr1 := ADR(FB1_inst.iOutVal); \/\/SA0170\nrefINT REF= FB1_inst.iOutVal; \/\/SA0179\n The following access directly within the FB1 function block also generates the error: \/\/other is a POINTER TO FB1\nptr := ADR(other^.iOutVal); \/\/SA0170 The following access directly within the FB1 function block does not generate errors: \/\/iInputVal is a VAR_INPUT of FB1\niOutVal := iInputVal; \n\/\/ptr is a POINTER TO INT\nptr := ADR(THIS^.iOutVal); \nptr := ADR(iOutVal); Output in the Messages view: SA0170: Should not take on the address of an output variable " }, 
{ "title" : "SA0171: Enumeration should have the 'strict' attribute ", 
"url" : "_san_rule_sa0171.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0171: Enumeration should have the 'strict' attribute ", 
"snippet" : "Detects declarations of enumerations which are not provided with the {attribute 'strict'} attribute. Justification: The {attribute 'strict'} attribute causes compiler errors to be issued if the code violates strict programming rules for enumerations. By default, when a new enumeration is created, th...", 
"body" : "Detects declarations of enumerations which are not provided with the {attribute 'strict'} attribute. Justification: The {attribute 'strict'} attribute causes compiler errors to be issued if the code violates strict programming rules for enumerations. By default, when a new enumeration is created, the declaration is automatically assigned the 'strict' attribute. For more information, see: Data Type: Enumeration Importance: High Example TYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE Output in the Messages view: SA0171: Enumeration should have the 'strict' attribute No violation of programming rules: {attribute 'qualified_only'}\n{attribute 'strict'}\nTYPE COLOR :\n(\n red,\n green,\n blue\n);\nEND_TYPE " }, 
{ "title" : "SA0172: Possible attempt to access outside the bounds of the array ", 
"url" : "_san_rule_sa0172.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0172: Possible attempt to access outside the bounds of the array ", 
"snippet" : "Detects possible access to an array index outside the bounds of the array. Often the range of the array index is exceeded in FOR loops where the index variable is used to access an array index. Importance: High Example PROGRAM Test VAR_TEMP iIndex: INT; arUSINT: Array[0..10] OF INT; END_VAR FOR iInd...", 
"body" : "Detects possible access to an array index outside the bounds of the array. Often the range of the array index is exceeded in FOR loops where the index variable is used to access an array index. Importance: High Example PROGRAM Test\nVAR_TEMP\n iIndex: INT;\n arUSINT: Array[0..10] OF INT;\nEND_VAR\n FOR iIndex := INT#0 TO INT#50 DO\n arUSINT[iIndex] := 0;\nEND_FOR Output in the Messages view: SA0172: Possible attempt to access outside the bounds of the array " }, 
{ "title" : "SA0175: Suspicious operation on string ", 
"url" : "_san_rule_sa0175.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0175: Suspicious operation on string ", 
"snippet" : "Do not always enable this rule. Enable the rule only when necessary to find the locations in the code which should be checked when converting to UTF-8 encoding. Checks if the project option UTF-8 Encoding for STRING can be enabled. This is the case when no code locations with suspicious operations a...", 
"body" : "Do not always enable this rule. Enable the rule only when necessary to find the locations in the code which should be checked when converting to UTF-8 encoding. Checks if the project option UTF-8 Encoding for STRING can be enabled. This is the case when no code locations with suspicious operations are found. When switching to UTF-8 encoding, the first 127 characters correspond to ASCII encoding. However, all other characters are encoded with more than one byte. This can cause a change in behavior when processing strings. As a result, a string literal containing non-ASCII characters may become longer. Or access in a string by index can access the wrong element. Finally, even access to an invalid byte offset can occur. When the rule is active, all code locations containing any of the following constructs are reported: Index access to a byte string Example: str[2] Message: SA0175: Enumeration with attribute 'strict': Suspicious operation on string: index access '<expression>' Address access to single-byte strings Example: ADR(str) Message: SA0175:Enumeration with attribute 'strict': Suspicious operation on string: Possible index access '<expression>' Call of string functions of the Standard library, except when calling the CONCAT and LEN functions Message: SA0175:Enumeration with attribute 'strict': Suspicious operation on string: Possible index access '<expression>' Byte literal containing non-ASCII characters Examples: str := '99€';\nstr :='Ä'; Message: SA0175: Suspicious operation on string: Literal '<literal>' contains non-ASCII characters " }, 
{ "title" : "SA0180: Index range does not cover the whole array ", 
"url" : "_san_rule_sa0180.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Rules \/ SA0180: Index range does not cover the whole array ", 
"snippet" : "Detects arrays with incompletely covered index range Arrays are often handled in loops, where the loop index indexes the array so that all components of the array are jumped to without gaps. This is given if the loop index and the array index are the same in all dimensions. If the index range does n...", 
"body" : "Detects arrays with incompletely covered index range Arrays are often handled in loops, where the loop index indexes the array so that all components of the array are jumped to without gaps. This is given if the loop index and the array index are the same in all dimensions. If the index range does not completely cover the array, then this indicates unhandled components in the array. Importance: Medium Example {attribute 'do-analysis'}\nPROGRAM PLC_PRG\nVAR\n a : INT;\n arWord : ARRAY [0..100] OF WORD;\nEND_VAR\n\/\/Implementation\nFOR a := INT#1 TO INT#100 BY 1 DO \/\/SA0180: Lower range is not reached\n\tarWord[a] := INT_TO_WORD(a);\nEND_FOR;\n;\n Output in the Messages view: SA0180: Index range doesn't cover the whole array " }, 
{ "title" : "Metrics ", 
"url" : "_san_reference_metrics.html", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics ", 
"snippet" : "Detailed description of metrics provided by CODESYS Static Analysis The Code size , Variable size , Stack size , and Number of calls metrics are reported only for POUs from libraries which are integrated in the project....", 
"body" : "Detailed description of metrics provided by CODESYS Static Analysis The Code size , Variable size , Stack size , and Number of calls metrics are reported only for POUs from libraries which are integrated in the project. " }, 
{ "title" : "Metric: Code size (number of bytes) ", 
"url" : "_san_reference_metrics.html#UUID-35adc4d5-9253-44d6-f130-aab7171bff69", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: Code size (number of bytes) ", 
"snippet" : "Code size (number of bytes) Categories: Informative, Efficiency Number of bytes which a function block contributes to the application code The number also depends on the code generator. For example, the code generator for ARM processors generally generates more bytes than the code generator for x86 ...", 
"body" : "Code size (number of bytes) Categories: Informative, Efficiency Number of bytes which a function block contributes to the application code The number also depends on the code generator. For example, the code generator for ARM processors generally generates more bytes than the code generator for x86 processors. " }, 
{ "title" : "Metric: Variable size (number of bytes) ", 
"url" : "_san_reference_metrics.html#UUID-b07882e2-be28-fe1e-eb10-ed5defcf3c74", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: Variable size (number of bytes) ", 
"snippet" : "Variable size (number of bytes) Categories : Informative, Efficiency Size of the static memory which is used by the object For function blocks, this is the size which is used for an instance of the function block (which may include memory gaps, depending on the memory alignment). For programs, funct...", 
"body" : "Variable size (number of bytes) Categories : Informative, Efficiency Size of the static memory which is used by the object For function blocks, this is the size which is used for an instance of the function block (which may include memory gaps, depending on the memory alignment). For programs, functions, and global variable lists, this is the sum of the size of all static variables. Example FUNCTION FUN1 : INT\nVAR_INPUT\n a,b : INT;\nEND_VAR\nVAR\n c,d : INT;\nEND_VAR\nVAR_STAT\n f,g,h : INT;\nEND_VAR The function has 3 static variables of type INT (f , g , and h ), each of which requires 2 bytes of memory. As a result, FUN1 has a variable size of 6 bytes. " }, 
{ "title" : "Metric: Stack size (number of bytes) ", 
"url" : "_san_reference_metrics.html#UUID-52e032c0-e190-f5c0-344b-e6c04694a3ef", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: Stack size (number of bytes) ", 
"snippet" : "Stack size (number of bytes) Categories : Informative, Efficiency, Reliability Number of bytes which are required for calling a function or a function block Input variables and output variables are aligned to the memory. This can create a gap between these variables and the local variables. This gap...", 
"body" : "Stack size (number of bytes) Categories : Informative, Efficiency, Reliability Number of bytes which are required for calling a function or a function block Input variables and output variables are aligned to the memory. This can create a gap between these variables and the local variables. This gap is counted. Return values of called functions which do not fit into a register, are pushed onto the stack. The largest of these values determines the additional allocated memory, which also counts. Functions or function blocks which are called within the POUs under consideration have their own stack frame. Therefore, the memory for such calls does not count. Depending on the code generator used, intermediate results of calculations also use the stack. These results are not counted. Example \/\/Declaration\nFUNCTION FUN1 : INT\nVAR_INPUT\n a,b : INT;\nEND_VAR\nVAR\n c,d,e : INT;\nEND_VAR\nVAR_STAT\n f,g,h : INT;\nEND_VAR\n\n\/\/Implementation\nc := b;\nd := a;\ne := a+b; Assumption: For the calculation, assume a CODESYS Control Win which uses the x86 code generator. The above example has a caller size of 8 bytes: 4 bytes for the two INT inputs and 4 bytes for the return value. The device has a stack alignment of 4 bytes, so that there is a gap of 2 bytes. The caller size is 8 bytes: three local variables with 2 bytes each plus the 2 byte gap for stack alignment. As a result, the total stack size of FUN1 is 16 bytes. VAR_STAT is not stored on the stack and therefore does not increase the stack size of a POU. " }, 
{ "title" : "Metric: Number of calls (Calls) ", 
"url" : "_san_reference_metrics.html#UUID-652fc3dc-10b7-711b-cea7-9b006e6249b5", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: Number of calls (Calls) ", 
"snippet" : "Number of calls (calls) Category : Informative Number of calls of the POU under Program unit Example \/\/Declaration PLC_PRG PROGRAM PLC_PRG VAR myFB : FB1; END_VAR \/\/Implementation myFB(b := FALSE); \/\/Declaration FB1 FUNCTION_BLOCK FB1 VAR_INPUT b : BOOL; END_VAR VAR i : INT; END_VAR \/\/Implementation...", 
"body" : "Number of calls (calls) Category : Informative Number of calls of the POU under Program unit Example \/\/Declaration PLC_PRG\nPROGRAM PLC_PRG\nVAR\n myFB : FB1;\nEND_VAR\n\n\/\/Implementation\nmyFB(b := FALSE); \/\/Declaration FB1\nFUNCTION_BLOCK FB1\nVAR_INPUT\n b : BOOL;\nEND_VAR\nVAR\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH(i);\nIF b THEN\n METH(i*i);\nEND_IF\n \/\/Declaration FB1.METH\nMETHOD METH : BOOL\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH := i >= 42; If PLC_PRG is called in a task, then this call is also counted. FB1 has exactly one call (in PLC_PRG ). METH has two calls, both in FB1 . " }, 
{ "title" : "Metric: Number of calls from tasks (Tasks) ", 
"url" : "_san_reference_metrics.html#UUID-3768e9b9-fdef-e8c5-d81a-3ab94c3eed82", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: Number of calls from tasks (Tasks) ", 
"snippet" : "Number of calls from tasks (tasks) Categories : Maintainability, Reliability Number of tasks ( Tasks ) where the POU specified under Program unit is called In the case of function blocks, the number of tasks is counted, in which the function block itself or any function block in the inheritance tree...", 
"body" : "Number of calls from tasks (tasks) Categories : Maintainability, Reliability Number of tasks ( Tasks ) where the POU specified under Program unit is called In the case of function blocks, the number of tasks is counted, in which the function block itself or any function block in the inheritance tree of the function block is called. In the case of methods and actions, the number of tasks is displayed, in which the (parent) function block is called. Example FUNCTION_BLOCK FB\n\/\/... FUNCTION_BLOCK FB2 EXTENDS FB\n\/\/... FUNCTION_BLOCK FB3 EXTENDS FB2\n\/\/... Each function block is called in its own PROGRAM . Each PROGRAM has its own task. The Called in tasks metric returns in 1 for FB3 and 2 for FB2 because the calls from FB3 and FB2 are counted. The metric results in 3 for FB because in this case the calls from FB3 , FB2 , and FB are counted. " }, 
{ "title" : "Metric: Number of global variables used (Globals) ", 
"url" : "_san_reference_metrics.html#UUID-04068c53-4046-0979-468b-866b1a155a8a", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: Number of global variables used (Globals) ", 
"snippet" : "Number of global variables used (Globals) Categories : Maintainability, Reusability Number of used global variables in the POU under Program unit Example \/\/GVL VAR_GLOBAL gvla : INT; gvlb : INT; gvlc : INT; END_VAR \/PRG declaration PROGRAM PRG VAR x : INT := GVL.gvlc; y : INT; END_VAR \/\/PRG implemen...", 
"body" : "Number of global variables used (Globals) Categories : Maintainability, Reusability Number of used global variables in the POU under Program unit Example \/\/GVL\nVAR_GLOBAL\n gvla : INT;\n gvlb : INT;\n gvlc : INT;\nEND_VAR \/PRG declaration\nPROGRAM PRG\nVAR\n x : INT := GVL.gvlc;\n y : INT;\nEND_VAR\n\n\/\/PRG implementation\nx := GVL.gvla;\ny := GVL.gvla*GVL.gvlb; The PRG program uses 3 variables from GVL : gvla , gvlb , and gvlc . " }, 
{ "title" : "Metric: Number of direct address accesses (IOs) ", 
"url" : "_san_reference_metrics.html#UUID-792a6162-1022-f930-dadb-104aa5a51709", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: Number of direct address accesses (IOs) ", 
"snippet" : "Number of direct address accesses (IOs) Categories : Reusability, Maintainability Number of direct address accesses ( IOs ) in the implementation of the object. Example \/\/Declaration PROGRAM PRG VAR xVar : BOOL:= %IX0.0; \/\/ +1 direct address access byVar : BYTE; END_VAR \/\/Implementation xVar := %IX0...", 
"body" : "Number of direct address accesses (IOs) Categories : Reusability, Maintainability Number of direct address accesses ( IOs ) in the implementation of the object. Example \/\/Declaration\nPROGRAM PRG\nVAR\n xVar : BOOL:= %IX0.0; \/\/ +1 direct address access\n byVar : BYTE;\nEND_VAR\n\n\/\/Implementation\nxVar := %IX0.0; \/\/ +1 direct address access\n%QX0.0 := xVar; \/\/ +1\n%MX0.1 := xVar; \/\/ +1\n%MB1 := byVar; \/\/ +1 The example has 5 direct address accesses. " }, 
{ "title" : "Metric: Number of local variables (Locals) ", 
"url" : "_san_reference_metrics.html#UUID-f738f257-cf3a-1e7c-979e-1d6b4733c2d9", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: Number of local variables (Locals) ", 
"snippet" : "Number of local variables (Locals) Categories : Informative, Efficiency Number of variables declared in the VAR area of the POU. Inherited variables are not counted. Example \/\/Declaration FUNCTION_BLOCK FB VAR_INPUT END_VAR VAR_OUTPUT END_VAR VAR i,j,k,l : INT; m,n,o : BOOL; END_VAR In the function ...", 
"body" : "Number of local variables (Locals) Categories : Informative, Efficiency Number of variables declared in the VAR area of the POU. Inherited variables are not counted. Example \/\/Declaration\nFUNCTION_BLOCK FB\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i,j,k,l : INT;\n m,n,o : BOOL;\nEND_VAR\n In the function block, 7 local variables are declared. " }, 
{ "title" : "Metric: Number of input variables (Inputs) ", 
"url" : "_san_reference_metrics.html#UUID-03e01655-9ac0-74f4-3fd7-cf22f23db4f6", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: Number of input variables (Inputs) ", 
"snippet" : "Number of input variables (Inputs) Categories : Maintainability, Reusability Default upper limit for the corresponding SA0166 rule: 10 Number of variables declared in VAR_INPUT of the program unit. Inherited input variables are not counted. Examples FUNCTION_BLOCK FB VAR_INPUT i : INT; r : REAL; END...", 
"body" : "Number of input variables (Inputs) Categories : Maintainability, Reusability Default upper limit for the corresponding SA0166 rule: 10 Number of variables declared in VAR_INPUT of the program unit. Inherited input variables are not counted. Examples FUNCTION_BLOCK FB\nVAR_INPUT\n i : INT;\n r : REAL;\nEND_VAR\n In the function block, 2 input variables are declared: i and r . METHOD METH : BOOL\nVAR_INPUT\n j : INT;\n l : LREAL;\nEND_VAR\n The method has 2 inputs: j and l " }, 
{ "title" : "Metric: Number of output variables (Outputs) ", 
"url" : "_san_reference_metrics.html#UUID-7bba3bc6-748c-311d-7f8c-4878fdce9da0", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: Number of output variables (Outputs) ", 
"snippet" : "Number of output variables (Outputs) Categories : Maintainability, Reusability Default upper limit for the corresponding SA0166 rule: 10 Number of variables in VAR_OUTPUT of the program unit In the case of function blocks, this is the number of custom output variables ( VAR_OUTPUT ). In the case of ...", 
"body" : "Number of output variables (Outputs) Categories : Maintainability, Reusability Default upper limit for the corresponding SA0166 rule: 10 Number of variables in VAR_OUTPUT of the program unit In the case of function blocks, this is the number of custom output variables ( VAR_OUTPUT ). In the case of methods and functions, this is the number of custom output variables plus one if they have a return value. The return value is also counted. Inherited output variables are not counted. A high number of output variables is an indication of a violation of the principle of unique responsibility. Examples FUNCTION_BLOCK FB\nVAR_OUTPUT\n i : INT; \/\/ +1 output\n r : REAL; \/\/ +1 output\nEND_VAR The function block has 2 output variables: i and r METHOD METH : BOOL\nVAR_INPUT\n j : INT;\n l : LREAL;\nEND_VAR The method has 3 outputs: METH , j , and l METHOD METH1 \/\/ +0 outputs (no return type)\nVAR_OUTPUT\n ar : ARRAY[0..10] OF INT; \/\/ +1 output\n l : LREAL; \/\/ +1 output\nEND_VAR The METH1 method has 2 outputs: ar and i " }, 
{ "title" : "Metric: NOS – Number Of Statements ", 
"url" : "_san_reference_metrics.html#UUID-82054fe5-816d-0c12-0afa-11dabf2c47b3", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: NOS – Number Of Statements ", 
"snippet" : "NOS – Number Of Statements Category : Informative Number of statements in the implementation of a function block, function, or method Statements in the declaration, empty statements, or pragmas are not counted. Example \/\/Declaration: FUNCTION POU : BOOL VAR_INPUT END_VAR VAR c : INT := 100; \/\/ state...", 
"body" : "NOS – Number Of Statements Category : Informative Number of statements in the implementation of a function block, function, or method Statements in the declaration, empty statements, or pragmas are not counted. Example \/\/Declaration:\nFUNCTION POU : BOOL\nVAR_INPUT\nEND_VAR\nVAR\n c : INT := 100; \/\/ statements in the declaration are not counted\nEND_VAR\nVAR_OUTPUT\n test : INT;\n i : INT;\nEND_VAR\n\n\/\/Implementation:\nIF TRUE THEN \/\/if statement: +1\n test := 0; \/\/ +1\nEND_IF\n\nWHILE test = 1 DO \/\/while statement: +1\n ; \/\/ empty statements do not add to the statement count\nEND_WHILE\n\nFOR c := 0 TO 10 BY 2 DO \/\/for statement: +1\n i := i+i; \/\/ +1\nEND_FOR\n\n{text 'simple text pragma'} \/\/pragmas are not counted\ntest := 2; \/\/+1 The example has 6 statements. " }, 
{ "title" : "Metric: Percentage of comment ", 
"url" : "_san_reference_metrics.html#UUID-abd88d31-c33e-db93-0f69-bec1a38795f7", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: Percentage of comment ", 
"snippet" : "Percentage of comment Category : Maintainability Percentage of comments in source code This number is calculated according to the following formula: Percentage = 100 * <characters in comments> \/ <sum of characters in source code and characters in comments> Multiple consecutive spaces in the source c...", 
"body" : "Percentage of comment Category : Maintainability Percentage of comments in source code This number is calculated according to the following formula: Percentage = 100 * <characters in comments> \/ <sum of characters in source code and characters in comments> Multiple consecutive spaces in the source code are counted as one space, which prevents high weighting of indented source code. For empty objects (no source code and no comments), a percentage of 0 is returned. Example Declaration part: FUNCTION_BLOCK FB \/\/comments in the declaration are counted, as well\nVAR_TEMP\n hugo : INT;\nEND_VAR Implementation: hugo := hugo + 1;\n\/\/Declaration: 40 letters non comment; 50 letters comment\n\/\/Implementation: 13 letters non comment; 152 letters comment\n\/\/ 100 * 202 \/ 255 -> 79% comments The calculation of the percentage 100 * 202 \/ 255 returns 79%. " }, 
{ "title" : "Metric: Complexity (McCabe) ", 
"url" : "_san_reference_metrics.html#UUID-ea21160c-97be-30d4-7748-0adac68532a8", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: Complexity (McCabe) ", 
"snippet" : "Complexity (McCabe) Category : Testability Recommended upper limit: 10 The cyclomatic complexity according to McCabe is a measure of the readability and testability of source code. It is calculated by counting the number of binary branches in the control flow of the POU. However, cyclomatic complexi...", 
"body" : "Complexity (McCabe) Category : Testability Recommended upper limit: 10 The cyclomatic complexity according to McCabe is a measure of the readability and testability of source code. It is calculated by counting the number of binary branches in the control flow of the POU. However, cyclomatic complexity penalizes high branching because high branching increases the number of test cases required for high test coverage. Example: IF statement \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nIF b1 THEN \/\/ +1 for the THEN branch\n ;\n ELSIF b2 THEN \/\/ +1 for the THEN branch of the IF inside the else\n ;\nELSE \n IF b3 OR b4 THEN \/\/ +1 for the THEN branch\n ;\n END_IF\nEND_IF The code snippet has a cyclomatic complexity of 4. Example: CASE statement \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nCASE a OF\n 1:\t; \/\/ +1\n 2:\t; \/\/ +1\n 3,4,5:\t; \/\/ +1\nELSE \/\/ the ELSE statement does not increase the cyclomatic complexity\n ;\nEND_CASE The code snippet has a cyclomatic complexity of 4. Example: Loop statement \/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nWHILE b1 DO \/\/ +1 for the WHILE loop\n ;\nEND_WHILE\n\nREPEAT \/\/ +1 for the REPEAT loop\n ;\n UNTIL b2\nEND_REPEAT\n\nFOR a := 0 TO 100 BY 2 DO \/\/ +1 for the REPEAT loop\n ;\nEND_FOR The code snippet has a cyclomatic complexity of 4. Example: Other statements The following statements also increase the cyclomatic complexity: \/\/Declaration\nFUNCTION FUN : STRING\nVAR_INPUT\n condition_return : BOOL;\n condition_jmp : BOOL;\nEND_VAR\nVAR\nEND_VAR\n\n\/\/Implementation\n\/\/ every POU has an initial cyclomatic complexity of 1, since it has at least 1 branch\nJMP(condition_jmp) lbl; \/\/Conditional jumps increase the cyclomatic complexity by 1\n\nFUN := 'u';\nRETURN(condition_return); \/\/Conditional returns increase the cyclomatic complexity by 1, too\n\nlbl:\nFUN := 't';\n The code snippet has a cyclomatic complexity of 3. " }, 
{ "title" : "Metric: Cognitive Complexity ", 
"url" : "_san_reference_metrics.html#UUID-cd064f18-bd35-1d86-1bd4-2ae3a8fe344f", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: Cognitive Complexity ", 
"snippet" : "Cognitive Complexity Category : Maintainability Default upper limit for the corresponding SA0178 rule: 20 Cognitive complexity is a measure of the readability and understandability of source code as introduced by Sonarsource™ in 2016. However, it penalizes heavy nesting of the control flow and compl...", 
"body" : "Cognitive Complexity Category : Maintainability Default upper limit for the corresponding SA0178 rule: 20 Cognitive complexity is a measure of the readability and understandability of source code as introduced by Sonarsource™ in 2016. However, it penalizes heavy nesting of the control flow and complex Boolean expressions. Cognitive complexity is calculated only for structured text implementations. The following examples show how cognitive complexity is calculated. The Show Cognitive Complexity for Current Editor command can be used to additionally display the increments for structured text. Example: Control flow Statements which manipulate control flow increase the cognitive complexity by 1 IF TRUE THEN \/\/ +1 cognitive complexity\n ;\nEND_IF\n\nWHILE TRUE DO \/\/+1 cognitive complexity\n ;\nEND_WHILE\n\nFOR i := 0 TO 10 BY 1 DO \/\/+1 cognitive complexity\n ;\nEND_FOR\n\nREPEAT \/\/+1 cognitive complexity\n ;\nUNTIL TRUE\nEND_REPEAT The code snippet has a cognitive complexity of 4. Example: Nesting of the control flow When nesting the control flow, an increment of 1 is added for each level of nesting. IF TRUE THEN \/\/+1 cognitive complexity\n WHILE TRUE DO \/\/+2 (+1 for the loop itself, +1 for the nesting inside the IF)\n FOR i := 0 TO 10 BY 1 DO \/\/+3 (+1 for the FOR loop itself, +2 for the nesting inside the WHILE and the IF)\n\t\t\t;\n END_FOR\n END_WHILE\n\n REPEAT \/\/+2 (+1 for the loop itself, +1 for the nesting inside the IF)\n ;\n UNTIL TRUE\n END_REPEAT\nEND_IF The code snippet has a cognitive complexity of 8. Example: Boolean expression Because Boolean expressions play a major role in understanding source code, they are also taken into account when calculating cognitive complexity. Understanding Boolean expressions which are associated with the same Boolean operator is not as difficult as understanding a Boolean expression which contains alternating Boolean operators. Therefore, any chain of identical Boolean operators in an expression increases cognitive complexity. b := b1; \/\/+0: a simple expression, containing no operators, has no increment\n The simple expression without an operator has an increment of 0. b := b1 AND b2; \/\/+1: one chain of AND operators The expression with an AND link has an increment of 1. b := b1 AND b2 AND b3; \/\/+1: one more AND, but the number of chains of operators does not change The expression has one more AND . But since it is the same operator, the number of the chain formed with identical operators does not change. b := b1 AND b2 OR b3; \/\/+2: one chain of AND operators and one chain of OR operators The expression has a chain of AND operators and a chain of OR operators. This results in an increment of 2. b := b1 AND b2 OR b3 AND b4 AND b5; \/\/+3 The code snippet has an increment of 3. b := b1 AND NOT b2 AND b3; \/\/+1: the unary NOT operator is not considered in the cognitive complexity The unary operator NOT is not considered in cognitive complexity. Example: Other statements with an increment Structured text has additional statements and expressions which change the control flow. The following statements are penalized with an increment of cognitive complexity: aNewLabel:\nx := MUX(i, a,b,c); \/\/+1 for MUX operator\ny := SEL(b, i,j); \/\/+1 for SEL operator\nJMP aNewLabel; \/\/+1 for JMP to label EXIT and RETURN statements do not increase cognitive complexity. " }, 
{ "title" : "Metric: DIT – Depth of Inheritance Tree ", 
"url" : "_san_reference_metrics.html#UUID-c7e1c296-e321-f999-8ed7-9713ebdb50fc", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: DIT – Depth of Inheritance Tree ", 
"snippet" : "DIT – Depth of Inheritance Tree Category : Maintainability Number of inheritances until a function block is reached which does not extend any other function block Example FUNCTION_BLOCK MyBaseFB \/\/ ... FUNCTION_BLOCK AChildFB EXTENDS MyBaseFB \/\/ ... FUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB \/\/ ....", 
"body" : "DIT – Depth of Inheritance Tree Category : Maintainability Number of inheritances until a function block is reached which does not extend any other function block Example FUNCTION_BLOCK MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AChildFB EXTENDS MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB\n\/\/ ... MyBaseFB has a DIT of 0 because it is itself a function block which does not extend any other function block. For AChildFB , the DIT is 1 because one step is required to get to MyBaseFB . AGrandChildFB has a DIT of 2: One step is needed to AChildFB and another to MyBaseFB . " }, 
{ "title" : "Metric: NOC – Number Of Children ", 
"url" : "_san_reference_metrics.html#UUID-04314eaf-28e7-40ea-0aa9-e7f46e79bfa0", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: NOC – Number Of Children ", 
"snippet" : "NOC – Number Of Children Categories : Reusability, Maintainability Number of function blocks which extend the given basic function block. Function blocks which indirectly extend a basic function block are not counted. Example FUNCTION_BLOCK MyBaseFB \/\/ ... FUNCTION_BLOCK AChildFB EXTENDS MyBaseFB \/\/...", 
"body" : "NOC – Number Of Children Categories : Reusability, Maintainability Number of function blocks which extend the given basic function block. Function blocks which indirectly extend a basic function block are not counted. Example FUNCTION_BLOCK MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AChildFB EXTENDS MyBaseFB\n\/\/ ...\nFUNCTION_BLOCK AGrandChildFB EXTENDS AChildFB\n\/\/ ... MyBaseFB has only one (1) child object: AChildFB , which in turn has the one child object, AGrandChildFB . AGrandChildFB has no child objects. " }, 
{ "title" : "Metrics: RFC – Response For class ", 
"url" : "_san_reference_metrics.html#UUID-0fcfc138-e361-a392-6fbe-11240e7a6e2a", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metrics: RFC – Response For class ", 
"snippet" : "Response For Class (RFC) Categories : Maintainability, Reusability Number of different POUs, methods, or actions which are called and therefore generate a response of the POU specified under Program unit Example \/\/Declaration FB1 FUNCTION_BLOCK FB1 VAR d,x,y : INT; END_VAR \/\/Implementation x := METH...", 
"body" : "Response For Class (RFC) Categories : Maintainability, Reusability Number of different POUs, methods, or actions which are called and therefore generate a response of the POU specified under Program unit Example \/\/Declaration FB1\nFUNCTION_BLOCK FB1\nVAR\n d,x,y : INT;\nEND_VAR\n\n\/\/Implementation\nx := METH(d+10);\ny := FUN(42, 0.815); \/\/Declaration FB1.METH\nMETHOD METH : INT\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nMETH := FUN(CUBE(i), 3.1415); \/\/Declaration CUBE\nFUNCTION CUBE : INT\nVAR_INPUT\n i : INT;\nEND_VAR\n\n\/\/Implementation\nCUBE := i*i*i; \/\/Declaration Function FUN\nFUNCTION FUN : INT\nVAR_INPUT\n a : INT;\n lr : LREAL;\nEND_VAR\n\n\/\/Implementation\nFUN := LREAL_TO_INT(lr*10)*a; Starting with FUN and CUBE , these functions have an RFC of 0 because none of them call other functions, function blocks, or methods for their calculations. FB1.METH uses FUN and CUBE , which results in an RFC of 2. The function block FB1 itself calls METH and FUN , which increases its RFC by 2. For FB1, its METH method also has to be taken into account. METH uses FUN and CUBE. FUN has already been added to the RFC. Therefore, only the use of CUBE in METH increases the RFC for FB1 to 3 " }, 
{ "title" : "Metric: CBO – Coupling Between Objects ", 
"url" : "_san_reference_metrics.html#UUID-d98bd2a3-497b-920f-1f11-f4f38973066f", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: CBO – Coupling Between Objects ", 
"snippet" : "CBO – Coupling Between Objects Categories : Maintainability, Reusability Default upper limit for the corresponding SA0179 rule: 30 Number of other function blocks which are instantiated and used in a function block A function block with a high coupling between objects is likely to be involved in man...", 
"body" : "CBO – Coupling Between Objects Categories : Maintainability, Reusability Default upper limit for the corresponding SA0179 rule: 30 Number of other function blocks which are instantiated and used in a function block A function block with a high coupling between objects is likely to be involved in many different tasks and therefore violates the principle of unique responsibility. Example \/\/ Declaration\nFUNCTION_BLOCK FB_Child EXTENDS FB_Base objects \/\/ +0 for EXTENDS\nVAR_INPUT\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i_fb1 : FB1; \/\/ +1 instantiated here\n i_fb2 : FB2; \/\/ +1 instantiated here\nEND_VAR\n\n\/\/Implementation\ni_fb3(); \/\/ +0 instantiated in FB_Base, no increment for call The extension of a function block does not increase the coupling between objects. i_fb3 is instantiated in the implementation of FB_Base and passed on to FB_Child ( EXTENDS ). The call in FB_Child does not increase the coupling between the objects. The CBO of FB_Child is 2. " }, 
{ "title" : "Metric: Complexity of reference (Elshof) ", 
"url" : "_san_reference_metrics.html#UUID-a43f74c1-523d-b649-00e5-788c653e5ea1", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: Complexity of reference (Elshof) ", 
"snippet" : "Complexity of reference (Elshof) Categories : Efficiency, Maintainability, Reusability Complexity of the data flow of a POU The referencing complexity is calculated according to the following formula: <number of variables used> \/ <number of variable accesses> Only variable accesses in the implementa...", 
"body" : "Complexity of reference (Elshof) Categories : Efficiency, Maintainability, Reusability Complexity of the data flow of a POU The referencing complexity is calculated according to the following formula: <number of variables used> \/ <number of variable accesses> Only variable accesses in the implementation part of the POU are considered. Example \/\/Declaration\nPROGRAM PRG\nVAR\n i, j : INT;\n k : INT := GVL.m;\n b, c : BOOL;\n myFB : FB;\nEND_VAR\n\n\/\/Implementation\nmyFB(paramA := b); \/\/ +3 accesses (myFB, paramA and b)\ni := j; \/\/ +2 accesses (i and j)\nj := GVL.d; \/\/ +2 accesses (j and GVL.d) Referencing complexity in the code snippet results: 6 number of variables used \/ 7 number of variable accesses = 0.85 Caution: c and k are not used and therefore do not count as \"variables used\". The assignment k : INT := GVL.m is not counted because it is part of the declaration of the program. " }, 
{ "title" : "Metric: Lack of Cohesion Of Methods – LCOM ", 
"url" : "_san_reference_metrics.html#UUID-068c2765-4709-d4e2-80b6-d173998195a8", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: Lack of Cohesion Of Methods – LCOM ", 
"snippet" : "Lack of Cohesion Of Methods – LCOM Lack of Cohesion Of Methods – LCOM Categories : Maintainability, Reusability The cohesion between function blocks, their actions, transitions, and methods describes whether or not they access the same variables. The lack of cohesion of methods describes how strongl...", 
"body" : "Lack of Cohesion Of Methods – LCOM Lack of Cohesion Of Methods – LCOM Categories : Maintainability, Reusability The cohesion between function blocks, their actions, transitions, and methods describes whether or not they access the same variables. The lack of cohesion of methods describes how strongly the objects of a function block are connected to each other. The lower the lack of cohesion, the stronger the connection between the objects. Function blocks with a high lack of cohesion are likely to be involved in many different tasks and therefore violate the principle of unique responsibility. The metric is calculated according to the following formula: MAX(0, <number of object pairs without cohesion> - <number of object pairs with cohesion>) Example \/\/Declaration\nFUNCTION_BLOCK FB\nVAR_INPUT\n a : BOOL;\nEND_VAR\nVAR_OUTPUT\nEND_VAR\nVAR\n i,b : BOOL;\nEND_VAR\n\n\/\/Implementation\ni := 42;\n\/\/FB.ACT\ni:= 0; \/\/FB.METH Declaration\nMETHOD METH : BOOL\nVAR_INPUT\n\tc : BOOL;\nEND_VAR\n\n\/\/Implementation\nMETH := c;\ni := 1; \/\/FB.SecondMETH Declaration\nMETHOD SecondMETH : INT\nVAR_INPUT\nEND_VAR\n\n\/\/Implementation\nSecondMETH := SEL(c,3,4); Object pairs without connection (4 pairs): FB, FB.ACT FB , FB.METH FB.ACT , FB.SecondMETH FB.METH , FB.SecondMETH Object pairs with connection (2 pairs): FB , FB.SecondMETH (both use c ) FB.ACT , FB.METH (both use i ) The table shows which variables connect which objects of the FB: FB FB.ACT FB.METH FB.SecondMETH FB.SecondMETH c 0 0 . FB.METH 0 i . . FB.ACT 0 . . . FB - . . . " }, 
{ "title" : "Metric: Number of SFC branches ", 
"url" : "_san_reference_metrics.html#UUID-d74f2703-e85d-ed16-b335-69a4dfd4a8bd", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: Number of SFC branches ", 
"snippet" : "Number of SFC branches Categories : Testability, Maintainability Number of alternative and parallel branches of a POU of the SFC (sequential function chart) implementation language Example The above code snippet in SFC has 4 branches: 3 alternative branches and 1 parallel branch...", 
"body" : "Number of SFC branches Categories : Testability, Maintainability Number of alternative and parallel branches of a POU of the SFC (sequential function chart) implementation language Example The above code snippet in SFC has 4 branches: 3 alternative branches and 1 parallel branch " }, 
{ "title" : "Metric: Number of SFC steps ", 
"url" : "_san_reference_metrics.html#UUID-19d1353f-ebce-6c25-6214-7b3a97c92490", 
"breadcrumbs" : "CODESYS Static Analysis \/ Reference: Programming \/ Metrics \/ Metric: Number of SFC steps ", 
"snippet" : "Number of SFC steps Category : Maintainability Number of steps in a POU in SFC (sequential function chart) Only the steps are counted which are contained in the POU programmed in SFC. Steps are not counted which are in the implementations of actions or transitions called in POUs. Example The code sn...", 
"body" : "Number of SFC steps Category : Maintainability Number of steps in a POU in SFC (sequential function chart) Only the steps are counted which are contained in the POU programmed in SFC. Steps are not counted which are in the implementations of actions or transitions called in POUs. Example The code snippet in SFC has 10 steps. " }
]
$(document).trigger('search.ready');
});