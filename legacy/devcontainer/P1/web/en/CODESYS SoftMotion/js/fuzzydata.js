$(document).ready(function () {indexDict['en-US'] = [{ "title" : "CODESYS SoftMotion ", 
"url" : "_sm_start_page.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion ", 
"snippet" : "With CODESYS SoftMotion , you can create PLC movements efficiently. This ranges from simple single-axis movements or cams to complex movements in multiple dimensions. In particular, applications that include flow control and process control in addition to motion functionality are within the applicat...", 
"body" : "With CODESYS SoftMotion , you can create PLC movements efficiently. This ranges from simple single-axis movements or cams to complex movements in multiple dimensions. In particular, applications that include flow control and process control in addition to motion functionality are within the application scope of the CODESYS SoftMotion . You can download the CODESYS SoftMotion from CODESYS Store International or CODESYS Store North America . There you will also find the data sheet for the product. See also CODESYS SoftMotion in the CODESYS Forum " }, 
{ "title" : "Licensing ", 
"url" : "_sm_licensing.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Licensing ", 
"snippet" : "In addition to the general licensed software metrics , metrics are defined for CODESYS SoftMotion which are checked during download. The SoftMotion metrics are calculated during compile and the current value is displayed in the editor only afterwards. The determined values refer to one application. ...", 
"body" : "In addition to the general licensed software metrics , metrics are defined for CODESYS SoftMotion which are checked during download. The SoftMotion metrics are calculated during compile and the current value is displayed in the editor only afterwards. The determined values refer to one application. When multiple applications exist, the values of the individual applications are added up. Group Metric Determined Value Number of axes Real axes The value of the metric is defined by the larger value of used real axes and virtual axes. Example: With 3 real axes and 4 virtual axes, the value in the application = 4. Virtual axes Number of axis groups and CNC interpolators Axis groups The value of the metric is defined by the sum of axis groups and CNC interpolators. Example: With 2 axis groups and 2 CNC interpolators, the value in the application = 4. CNC interpolators " }, 
{ "title" : "Components of CODESYS SoftMotion ", 
"url" : "_sm_components.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Components of CODESYS SoftMotion ", 
"snippet" : "CODESYS SoftMotion is a software package which is used as a development and runtime environment for motion control. It is outlined as follows: Drive configuration : The drive configuration provides an editor for you to set the structure and configuration of the drive hardware by means of the CODESYS...", 
"body" : "CODESYS SoftMotion is a software package which is used as a development and runtime environment for motion control. It is outlined as follows: Drive configuration : The drive configuration provides an editor for you to set the structure and configuration of the drive hardware by means of the CODESYS user interface. At this time, an instance of an IEC function block is created to represent the drive. This function block communicates automatically with the drives without additional effort from the IEC programmer. It is responsible for transmitting the updated data. To control the drives, the IEC program can address a drive by means of the function blocks of the SoftMotion libraries. Alternatively, you could also develop your own function blocks for this purpose. The set values (for position, velocity, acceleration, etc.) are written cyclically by these function blocks. Note: The CODESYS SoftMotion Light product is part of the standard installation of CODESYS . It provides the capability of commanding the axes. In this way, CODESYS defines only the target position only and waits for the response from the axis controller. The axis controller is responsible for the motion planning. A coordinated movement of multiple axes by CODESYS is not possible. Cam editor : In the cam editor, you can describe a cam graphically or by means of tables. CODESYS generates from this a global instance of a data structure which describes the cam. This is passed to the application where the applicable POUs can access it. CNC editor : In the CNC editor, you can generate multidimensional movements. You can create the CNC path with a text editor (according to DIN 66025) or with a graphical editor. As an alternative to the text editor, you can also work in a simplified tabular view. Axis group configuration : An axis group defines the relationships between multiple mechanically dependent axes which collectively position and orient a tool or tool plate in the space. With the configurator, you select and configure the kinematics to be used. Moreover, you can assign the SoftMotion axes. The SM3_Basic library is a basic library for all SoftMotion applications. Specifically, it contains the following: PLCopen function blocks according to the PLCopen standard With these function blocks, you can control single-axis movements or master\/slave movements of two axes (electric cam, electric gear boxes). Additional FBs that are not covered by PLCopen functionalities Help functions: For example for handling files or for error messages The SM3_CNC library is based on the SM3_Basic library. In addition to the function blocks for kinematic transformations, it provides all POUs which are required to generate, execute, and display CNC motion. It also provides function blocks for path preprocessing and path reconstruction. The SM3_Robotics library contains function blocks according to PLCopen Part 4 for robotics and additional function blocks. The included SM3_Transformations library contains the supported kinematic transformations. The Drive interface is part of the SM3_Basic library and is responsible for communication between the IEC program and the drives. For the supported drives, CODESYS SoftMotion provides libraries which implement this drive interface. See also the descriptions of the application examples. " }, 
{ "title" : "Using CODESYS RTE V3 and CODESYS WIN V3 Controllers ", 
"url" : "_sm_rtev3_winv3.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ Using CODESYS RTE V3 and CODESYS WIN V3 Controllers ", 
"snippet" : "In CODESYS Development System SP20 and higher, the SoftMotion controllers CODESYS SoftMotion RTE V3 and CODESYS SoftMotion Win V3 are no longer available. The standard CODESYS Control RTE V3 and CODESYS Control Win V3 controllers are now used. The Command: Enable command is used to convert the stand...", 
"body" : "In CODESYS Development System SP20 and higher, the SoftMotion controllers CODESYS SoftMotion RTE V3 and CODESYS SoftMotion Win V3 are no longer available. The standard CODESYS Control RTE V3 and CODESYS Control Win V3 controllers are now used. The Command: Enable command is used to convert the standard controller into a SoftMotion controller. " }, 
{ "title" : "SoftMotion with Multicore Processors ", 
"url" : "_sm_multicore_hint.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ SoftMotion with Multicore Processors ", 
"snippet" : "By distributing the motion tasks over multiple processor cores, more axes or axis groups can be actuated by SoftMotion . As a result, computation-intensive tasks, such as CNC path preprocessing or robotics path planning for CP movements, can be swapped out to another processor core. Then there is mo...", 
"body" : "By distributing the motion tasks over multiple processor cores, more axes or axis groups can be actuated by SoftMotion . As a result, computation-intensive tasks, such as CNC path preprocessing or robotics path planning for CP movements, can be swapped out to another processor core. Then there is more time for other tasks in the bus task. The fact that the computing power of the single-core controller is insufficient is demonstrated in the case of robotics by the unexplainable decrease in path speed. System requirements SM V4.5.1.0 or higher Compiler V3.5.12.0 or higher Multicore-compatible runtime system Application Robotics and CNC: Set the planning and bus tasks to different processor cores When using different bus systems, set the individual bus tasks to different processor cores When using multiple tasks and multiple processor cores, take note of the following: The function blocks in the CNC planning task are permitted to get a new rising edge at the Execute input only in specific states of the interpolator ( iStatus output). This also applies to single-core: IPO_UNKNOWN IPO_WAIT IPO_FINISHED IPO_INIT (for the first start only, not for restart) The bus tasks of interdependent axes (axis group, cam, and CNC kinematics) have to run on the same processor core. " }, 
{ "title" : "CODESYS SoftMotion Drives ", 
"url" : "_sm_f_drive_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "SoftMotion Drive Configuration ", 
"url" : "_sm_f_drive_configuration.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion Drive Configuration ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Overview ", 
"url" : "_sm_overview_drive_configuration.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion Drive Configuration \/ Overview ", 
"snippet" : "The SoftMotion drive interface is a standardized interface that you use for linking, configuring, and addressing the drive hardware within an IEC program. By mapping different hardware to one interface, you can exchange drives easily and reuse IEC programs. The interface couples the drives to the I\/...", 
"body" : "The SoftMotion drive interface is a standardized interface that you use for linking, configuring, and addressing the drive hardware within an IEC program. By mapping different hardware to one interface, you can exchange drives easily and reuse IEC programs. The interface couples the drives to the I\/O mapping and is responsible for updating and transmitting the required motion data to the drive control. The drive interface consists of the following components: Device description of the SoftMotion devices to their representation in the device tree Libraries which are referenced in the device description that extend or overload the basic function blocks of AXIS_REF_SM3 according to the requirements of the specific drive types Libraries which contain the function blocks for acyclic reading and writing of data to wrap standard functions for the fieldbus driver If you use a SoftMotion PLC, such as CODESYS SoftMotion Win , then the base libraries are automatically linked in the Library Manager. These kinds of controllers provide a SoftMotion General Axis Pool . This is where you can insert free drive units. " }, 
{ "title" : "Coupled Drive Units ", 
"url" : "_sm_inserting_connected_drive_devices.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion Drive Configuration \/ Coupled Drive Units ", 
"snippet" : "Coupled drives belong to a device which represents the drive within the fieldbus topology. The symbols of these drives have a small mark indicating the corresponding fieldbus type. For example, every standard servo drive is connected to the controller by a fieldbus. When using drives, CODESYS SoftMo...", 
"body" : "Coupled drives belong to a device which represents the drive within the fieldbus topology. The symbols of these drives have a small mark indicating the corresponding fieldbus type. For example, every standard servo drive is connected to the controller by a fieldbus. When using drives, CODESYS SoftMotion provides specific device descriptions for the fieldbus master (\"_SoftMotion\" suffix). These have optimized basic parameters for the drive. For drives which are used with CODESYS SoftMotion , modulo handling must be deactivated in the drive. Modulo handling is performed by CODESYS SoftMotion in the controller. If applicable, the maximum travel range should be set to the full 32 bits. Adding a coupled drive device (EtherCAT) Requirement: A SoftMotion-compatible controller is inserted into the project. In the device tree, select the SoftMotion controller. In the context menu, click Add Device . In the Add Device dialog, select the Fieldbuses → EtherCAT → Master → EtherCAT Master SoftMotion device. Click the Add Device button. The device is added to the device tree. The Add Device dialog remains open. Select the device which you just added to the device tree. In the Add Device dialog, select a SoftMotion slave ( Fieldbuses → EtherCAT → Slave → <SoftMotion drive> ). Click the Add Device button. The device is added to the device tree. Double-clicking the device opens the corresponding device editor. " }, 
{ "title" : "Encoder Axis ", 
"url" : "_sm_encoder_drive_devices.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion Drive Configuration \/ Encoder Axis ", 
"snippet" : "Encoder axes are used to convert encoder values to a SoftMotion axis which can be used as a master axis for MC_CamIn , MC_GearIn , and other Master\/Slave function blocks. Encoder axes can represent additional encoders from drive units. In this case, they are configured as special encoder axes under ...", 
"body" : "Encoder axes are used to convert encoder values to a SoftMotion axis which can be used as a master axis for MC_CamIn , MC_GearIn , and other Master\/Slave function blocks. Encoder axes can represent additional encoders from drive units. In this case, they are configured as special encoder axes under fieldbus devices in the device tree. Alternatively, free encoders in the General Axis Pool could also use analog inputs as encoder axes. For more information, see: Free EncoderProperties Similar to logical axes, encoder axes are \"read-only\". They only provide the position and velocity values. No movements can be commanded on them. The axis state of encoder axes is always standstill . This is the state of PLCopen for Motion Control Part 1 which matches best. According to the statechart, this state means that the axis is ready and there is no error. Moreover, none of the movements commanded by the PLC is active on the axis. Note that before CODESYS SoftMotion version 4.18.0.0 the encoder axes were in the state power_off . However, when MC_Power was called for them, they were in a state standstill . The zero position of the encoder axis can be offset with MC_SetPosition . Master\/Slave function blocks always use the actual values of the encoder axis. A logical axis below the encoder axis can be used for dead-time compensation. When using encoder axes, it is not necessary to call MC_Power , and it makes no difference to the behavior of the encoder axis for CODESYS SoftMotion version 4.18.0.0 and higher. " }, 
{ "title" : "Inserting Free Drive Units ", 
"url" : "_sm_f_free_drive_devices.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion Drive Configuration \/ Inserting Free Drive Units ", 
"snippet" : "Free drive units are not permanently coupled with other devices in the device tree. They are inserted in the device tree below SoftMotion General Drive Pool ....", 
"body" : "Free drive units are not permanently coupled with other devices in the device tree. They are inserted in the device tree below SoftMotion General Drive Pool . " }, 
{ "title" : "Drive Control 'Drive_PosControl' ", 
"url" : "_sm_drive_controller_drive_poscontrol.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion Drive Configuration \/ Inserting Free Drive Units \/ Drive Control 'Drive_PosControl' ", 
"snippet" : "With the Drive_PosControl drive control, you can let the position control of an axis of CODESYS continue to run. The requirement is a device that is controlled by the set velocity and returns its current position. For example, this can be a velocity-controlled device (frequency converter) with posit...", 
"body" : "With the Drive_PosControl drive control, you can let the position control of an axis of CODESYS continue to run. The requirement is a device that is controlled by the set velocity and returns its current position. For example, this can be a velocity-controlled device (frequency converter) with position feedback. Adding a drive control Requirement: A SoftMotion controller is inserted into the project. In the device tree, select SoftMotion General Axis Pool . In the context menu, click Add Device . In the Add Device dialog, select the SoftMotion drives → position controlled drives → SMC_Drive_PosControl device. Click the Add Device button. The device is added to the device tree. Double-clicking the device opens the corresponding device editor. For more information, see: Tab: General" }, 
{ "title" : "Logical Drive ", 
"url" : "_sm_drive_controller_logical_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion Drive Configuration \/ Inserting Free Drive Units \/ Logical Drive ", 
"snippet" : "You can add a logical drive to any kind of drive unit. The axis of the logical drive mirrors the motion of their master axis while it represents a standalone instance. This allows for the execution of the following instructions on it without affecting the master axis. MC_SetPosition : Setting the po...", 
"body" : "You can add a logical drive to any kind of drive unit. The axis of the logical drive mirrors the motion of their master axis while it represents a standalone instance. This allows for the execution of the following instructions on it without affecting the master axis. MC_SetPosition : Setting the position to a defined value (example: 0) MC_TouchProbe : Saving the current axis position of a trigger signal MC_AbortTrigger : Deactivating a sensor which was previously activated with MC_TouchProbe One application would be a conveyor belt which runs through several processing stations. The position of the component is detected by means of an external signal (for example, a light barrier) and the axis is set to a defined position (touch probe function). The logical drive provides the capability of filtering the signal. Therefore, the logical drive can also be used with an encoder that delivers a noise signal. Adding a logical drive Requirement: A SoftMotion controller is inserted into the project. Select a drive unit in the device tree. In the context menu, click Add Device . In the Add Device dialog, select the SoftMotion drives → virtual drives → SM_Drive_Logical device. Click the Add Device button. The device is added to the device tree. Double-clicking the device opens the corresponding device editor. " }, 
{ "title" : "Virtual Drive ", 
"url" : "_sm_drive_controller_virtual_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion Drive Configuration \/ Inserting Free Drive Units \/ Virtual Drive ", 
"snippet" : "Virtual drives are simulated drives in software. With this, you can test your programs without connected hardware or implement extended functionalities. These kinds of functions include, for example, the control of the override of axis motion and the manual Cartesian method of a robot in a space. Fo...", 
"body" : "Virtual drives are simulated drives in software. With this, you can test your programs without connected hardware or implement extended functionalities. These kinds of functions include, for example, the control of the override of axis motion and the manual Cartesian method of a robot in a space. For more information, see the following: Controlling a Cam Drive with a Virtual Time AxisVirtual drives simulate a physical drive by using the set positions of the previous cycles to calculate the actual values of position, velocity, and acceleration at the start of a cycle. Functions which require a physical drive, such as a MC_TouchProbe in the drive or the use of SMC_SetControllerMode , are not supported. Adding a virtual drive Requirement: A SoftMotion controller is inserted into the project. In the device tree, select SoftMotion General Axis Pool . In the context menu, click Add Device . In the Add Device dialog, select the SoftMotion drives → virtual drives → SM_Drive_Virtual device. Click the Add Device button. The device is added to the device tree. Double-clicking the device opens the corresponding device editor. " }, 
{ "title" : "Free Encoder ", 
"url" : "_sm_drive_controller_free_encoder.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion Drive Configuration \/ Inserting Free Drive Units \/ Free Encoder ", 
"snippet" : "Use the Free encoder for integrating an encoder which is not coupled permanently to I\/Os or hardware. Adding a free encoder In the device tree, select SoftMotion General Axis Pool . In the context menu, click Add Device . In the Add Device dialog, select the SoftMotion drives → Free Encoders → SMC_F...", 
"body" : "Use the Free encoder for integrating an encoder which is not coupled permanently to I\/Os or hardware. Adding a free encoder In the device tree, select SoftMotion General Axis Pool . In the context menu, click Add Device . In the Add Device dialog, select the SoftMotion drives → Free Encoders → SMC_FreeeEncoder device. Click the Add Device button. The device is added to the device tree. Open the encoder in the Editor . Adapt the settings to the hardware and set the bit width and scaling. Assign the input value of the encoder to the <FREE_ENCODER_AXIS>.diEncoderPosition variable. This is possible either as IEC code or by mapping the memory of the input data. During the initialization of the fieldbus, this input may yield invalid values. You can use the bDelayActivation input to disable the evaluation of the input until a valid value is available. Now you can use the encoder like a drive. For more information, see: Encoder Axis" }, 
{ "title" : "Creating Axes Programmatically ", 
"url" : "_sm_programmatic_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ SoftMotion Drive Configuration \/ Inserting Free Drive Units \/ Creating Axes Programmatically ", 
"snippet" : "The following free drive units can also be created programmatically: Axes SMC_VIRTUAL_AXIS Creates a virtual axis without having to add it to the device tree For more information, see the following: Virtual DriveSMC_Logical_Axis Creates a logical axis without having to add it to the device tree. For...", 
"body" : "The following free drive units can also be created programmatically: Axes SMC_VIRTUAL_AXIS Creates a virtual axis without having to add it to the device tree For more information, see the following: Virtual DriveSMC_Logical_Axis Creates a logical axis without having to add it to the device tree. For more information, see the following: Logical DriveSMC_FreeEncoder Creates an encoder axis without having to add it to the device tree For more information, see the following: Free Encoder" }, 
{ "title" : "Supported Drives ", 
"url" : "_sm_drives_supported_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Supported Drives ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Supported drives: EtherCAT ", 
"url" : "_sm_drives_supported_drives_ethercat.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Supported Drives \/ Supported drives: EtherCAT ", 
"snippet" : "EtherCAT Beckhoff EL2521 Beckhoff EL5101 Beckhoff EL72x1 Beckhoff EL7031 Beckhoff EL7037 Beckhoff EL7041 Beckhoff EL7047 Beckhoff EP7041 Bonfiglioli iBMD Bosch Rexroth IndraDrive CoE Bosch Rexroth ctrlX DRIVE CoE Bosch Rexroth ctrlX DRIVE SoE CMZ BD CMZ LBD CMZ SBD Control Techniques Digitax Control...", 
"body" : "EtherCAT Beckhoff EL2521 Beckhoff EL5101 Beckhoff EL72x1 Beckhoff EL7031 Beckhoff EL7037 Beckhoff EL7041 Beckhoff EL7047 Beckhoff EP7041 Bonfiglioli iBMD Bosch Rexroth IndraDrive CoE Bosch Rexroth ctrlX DRIVE CoE Bosch Rexroth ctrlX DRIVE SoE CMZ BD CMZ LBD CMZ SBD Control Techniques Digitax Control Techniques Mentor Control Techniques Unidrive M Copley Accelnet Danfoss ISD 520 Delta ASDA A2 Delta ASDA A3 Delta ASDA B3 Delta R1-EC5621 Festo CMMP EtherCAT Generic CiA 402 driver: see Configuration of the Generic CiA402 AxisGenerischer SoE Treiber (auch für mehrachsige Antriebe) Hitachi ADV series Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB H6 KEBA KeDrive D3 Kollmorgen AKD Kollmorgen AKD-N\/C Kollmorgen MKD-N\/C Kollmorgen AKD2G Kollmorgen KED Metronix ARS 2000-Serie Mitsubishi Melservo MR-J5 Mitsubishi Melservo MR-JET Omron G5 Panasonic MINAS A5B Panasonic MINAS A6B Panasonic MINAS A6 MultiDrive Parker compax3 Parker SBC Parker PSD Sanyo Denki RS2 Schneider Electric Lexium32 Schneider Electric Lexium32i Servotronix CDHD Stäubli uniVAL Stöber Posidrive Stöber SD6 Stöber SI6\/SC6 WEG SCA06 Yaskawa Sigma7 series " }, 
{ "title" : "Supported drives: CAN ", 
"url" : "_sm_drives_supported_drives_can.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Supported Drives \/ Supported drives: CAN ", 
"snippet" : "CAN Bonfiglioli iBMD CMZ BD CMZ SD CMZ LBD CMZ SBD Festo EMCA Festo CMMP Generic CiA 402 driver: see Configuration of the Generic CiA402 AxisInfranor cd1-k Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB Stepless Technology Maxon EPOS4 Metronix ARS 2000-Serie Nanotec PD4C Schneider Elect...", 
"body" : "CAN Bonfiglioli iBMD CMZ BD CMZ SD CMZ LBD CMZ SBD Festo EMCA Festo CMMP Generic CiA 402 driver: see Configuration of the Generic CiA402 AxisInfranor cd1-k Infranor XtrapulsPac JAT Ecovario KEB IT Motor B KEB F5 KEB Stepless Technology Maxon EPOS4 Metronix ARS 2000-Serie Nanotec PD4C Schneider Electric Lexium05 Schneider Electric Lexium23 Schneider Electric Lexium28 Schneider Electric Lexium32 Schneider Electric Lexium32i Schneider Electric SD-3 " }, 
{ "title" : "Use Cases ", 
"url" : "_sm_f_use_cases_drive_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Use Cases ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Standard Use Cases ", 
"url" : "_sm_special_use_cases.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Use Cases \/ Standard Use Cases ", 
"snippet" : "The SM3_Basic library contains superordinate function blocks which do not interact with the drive over the standard set\/actual value interface. These function blocks provide commands or change the settings of the drive by reading or writing the parameters of the instance of AXIS_REF_SM3 ....", 
"body" : "The SM3_Basic library contains superordinate function blocks which do not interact with the drive over the standard set\/actual value interface. These function blocks provide commands or change the settings of the drive by reading or writing the parameters of the instance of AXIS_REF_SM3 . " }, 
{ "title" : "Reinitializing a drive ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_0e9f93f91e8d4c6dc0a8640e01d50c94", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Use Cases \/ Standard Use Cases \/ Reinitializing a drive ", 
"snippet" : "If you changed the drive parameters at runtime, then you need to reinitialize the drive. Example: Change the scaling factor or the modulo period of rotary drives. By calling the SMC3_ReinitDrive function block with a rising edge at the Execute input, the wCommuncationState parameter of the drive is ...", 
"body" : "If you changed the drive parameters at runtime, then you need to reinitialize the drive. Example: Change the scaling factor or the modulo period of rotary drives. By calling the SMC3_ReinitDrive function block with a rising edge at the Execute input, the wCommuncationState parameter of the drive is reset and the complete start process of the drive is repeated. The reinitialization has to wait until the axis reaches the required state SMC_COMSTATE_BASE_COM_INITIALIZATION or higher. Otherwise the error will output SMC_RAG_ERROR_AXIS_NOT_INITIALIZED . If the communication of a subordinate fieldbus is interrupted, then explicit reinitialization is no longer necessary for CODESYS SoftMotion version 4.18.0.0 and higher. The axis is automatically reinitialized as soon as fieldbus communication is restored. Before version 4.18.0.0: After the communication of the fieldbus was interrupted, an explicit call of SMC3_ReinitDrive was necessary (error with SMC_DI_GENERAL_COMMUNICATION_ERROR ) as soon as the fieldbus communication has been restored. The old behavior can be restored by setting the AutoRestart input of the SMC_AxisChangeSettings function block to SMC_AXIS_AUTORESTART_MODE.OFF . " }, 
{ "title" : "Switching a drive on and off ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_bd45abb41e8d4c6dc0a8640e01589872", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Use Cases \/ Standard Use Cases \/ Switching a drive on and off ", 
"snippet" : "The bRegulatorOn and bDriveStart parameters of the AXIS_REF_SM3 function block control the power level and deceleration of a drive. Access is made by means of the MC_Power function block. To release the output stage, you need to set the bRegulatorOn parameter of the MC_Power function block. The driv...", 
"body" : "The bRegulatorOn and bDriveStart parameters of the AXIS_REF_SM3 function block control the power level and deceleration of a drive. Access is made by means of the MC_Power function block. To release the output stage, you need to set the bRegulatorOn parameter of the MC_Power function block. The drive reports the current status of this process via the bRegulatorRealState output. If it is supported by the drive, a bRegulatorOn reset during the movement will immediately deactivate the torque. In this case, the function block reports an error and sets the axes to the errorstop state. The bDriveStart variable determines whether or not the drive is permitted to move. The current state of this parameter is located in bDriveStartRealState . If it is supported by the drive, a bDriveStart parameter reset decelerates the drive with the configured ramp (\"QuickStop\") during the motion. After that, the drive halts at the reached position as long as set in bRegulatorOn . The axis remains in the stopping state as long as the \"QuickStop\" mechanism is active ( bDriveStart input = FALSE). If the drive has been moved by a function block before, then now it will display CommandAborted . This does not apply to the MC_Stop function block which reports an error and sets the axes to the errorstop state. " }, 
{ "title" : "Handling mechanical brakes ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_6670a1571e8d4c6ec0a8640e01f5eecb", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Use Cases \/ Standard Use Cases \/ Handling mechanical brakes ", 
"snippet" : "If it is supported by the drive, the eBrakeControl variable can be set or reset by means of the SMC3_BrakeControl function block. Three different modes are possible. SMC3_BrakeSetState SMC_BRAKE_AUTO : The state of the brake is controlled by the drive. SMC_BRAKE_OPEN : The brake is open. SMC_BRAKE_C...", 
"body" : "If it is supported by the drive, the eBrakeControl variable can be set or reset by means of the SMC3_BrakeControl function block. Three different modes are possible. SMC3_BrakeSetState SMC_BRAKE_AUTO : The state of the brake is controlled by the drive. SMC_BRAKE_OPEN : The brake is open. SMC_BRAKE_CLOSE : The brake is closed. The bBrakeClosedRealState variable reports the current status of the brake. From the point of view of SoftMotion , the control, as well as the state of the mechanical brake, does not depend on the state of the drive or the running motion. " }, 
{ "title" : "Changing the controller mode ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_959f85271e8d4c6ec0a8640e01ed4fcb", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Use Cases \/ Standard Use Cases \/ Changing the controller mode ", 
"snippet" : "With the SMC_SetControllerMode function block, you can switch between the different controller modes. The byControllerMode and byRealControllerMode parameters from AXIS_REF_SM3 represent the desired mode and the current mode of the controller. Possible values SMC_nocontrol SoftMotion does not send c...", 
"body" : "With the SMC_SetControllerMode function block, you can switch between the different controller modes. The byControllerMode and byRealControllerMode parameters from AXIS_REF_SM3 represent the desired mode and the current mode of the controller. Possible values SMC_nocontrol SoftMotion does not send cyclic data to the drive. This makes it possible to control the drive in other ways. SMC_torque Torque\/force control SMC_velocity Velocity control SMC_position , Position control After writing the byControllerMode variables, the current mode is checked until it matches the desired controller mode. The function block calculates the set values until the new mode is confirmed by the drive. As soon as the drive confirms the new mode, the bDone output is set and SMC_SetControllerMode no longer writes the set values. This must be done using other function blocks. Example: The bDone output is connected to the Execute input of a function block, such as MC_MoveVelocity , MC_MoveAbsolute , or MC_Halt . Otherwise the axis stops immediately after the mode is changed. Note that the dead time is used to calculate the set position. For more information, see the following: Actual Values, Set Values, and Dead Time. " }, 
{ "title" : "Homing (drive-controlled) ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_e16dcbe7307c3eec0a8646309bf8f8a_id_7fa66d251e8d4c6fc0a8640e00782f3b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Use Cases \/ Standard Use Cases \/ Homing (drive-controlled) ", 
"snippet" : "In SoftMotion , there are two ways to reference a drive: Referencing by a controller in the PLC: This referencing is performed by calling the SMC_Homing function block. The reference signal has to be part of the I\/O mapping of the control unit. At the time of referencing, the drive remains in contro...", 
"body" : "In SoftMotion , there are two ways to reference a drive: Referencing by a controller in the PLC: This referencing is performed by calling the SMC_Homing function block. The reference signal has to be part of the I\/O mapping of the control unit. At the time of referencing, the drive remains in control mode \"position control\". In general, this method is not particularly accurate because detecting the position (when the reference switch is activated) is based on the current positions obtained by the drive. As a result, the accuracy is limited by the communication cycle. Referencing by a controller in the drive: The reference switch is wired to the drive. Its position is detected faster and with higher accuracy. During the drive-controlled reference path, the drive is in another control mode, in which the drive is controlled by internal processes and does not follow the set values of the control unit. When the reference path ends, the drive is reset to its original control mode. The MC_Home function block starts the drive-controlled reference path by setting fReference and bStartReference . In addition, the state of AXIS_REF_SM3 ( wState ) is set to homing . When the drive passes to the reference path (meaning that it no longer follows the values specified by the control unit), the drive sets the parameter to TRUE . To display the end of the reference path, the driver sets the values of bStartReference and bStartReferenceRealState to FALSE . " }, 
{ "title" : "Latching ", 
"url" : "_sm_special_use_cases.html#UUID-aeb56271-7bec-ad25-90af-3a38260a2232_id_index_14", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Use Cases \/ Standard Use Cases \/ Latching ", 
"snippet" : "You can detect the position of an axis in many ways, depending on the drive functions which the drive supports: The drive detects the axis position itself (integrated or by switching on an external sensor). Because the actual position is transferred by the drive itself, the transfer time of the sign...", 
"body" : "You can detect the position of an axis in many ways, depending on the drive functions which the drive supports: The drive detects the axis position itself (integrated or by switching on an external sensor). Because the actual position is transferred by the drive itself, the transfer time of the signal is minimal and precise. The current position of the axis is determined independently of the drive and transferred to the controller via an input. Occurring latency of the controller input and the application cycle make this method less precise. When the position of the drive itself is transferred, it is processed directly in the application typically by the respective driver depending on the manufacturer. To determine the position of this kind of axis, you can use the MC_TouchProbe function block. It allows for the recording of the axis position to a configurable trigger and within a position window. If the position is not transferred by the drive, then it has to be passed to the device driver of the drive, for example for control. For more information, see the following: Position Control on the Controller with SM_Drive_PosControl" }, 
{ "title" : "Persisting an Axis Position ", 
"url" : "_sm_storing_axis_position_persistently.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Use Cases \/ Persisting an Axis Position ", 
"snippet" : "An axis which has an absolute encoder can save a position so that it retains its previous position after restarting the controller. Homing is not required. The SMC3_PersistPosition and SMC3_PersistPositionLogical function blocks provide the functionality for the save operation. The necessary data is...", 
"body" : "An axis which has an absolute encoder can save a position so that it retains its previous position after restarting the controller. Homing is not required. The SMC3_PersistPosition and SMC3_PersistPositionLogical function blocks provide the functionality for the save operation. The necessary data is saved in SMC3_PersistPosition_Data and SMC3_PersistPositionLogical_Data . The bPositionStored output indicates whether the contents of PersistentData have changed. This occurs at different times depending on the type of persistence. The value range persisted by the encoder must be configured at the SMC_PersistPosition.maxPersistedValue input. For multi-turn encoders, the value is set to 16#FFFFFFFFFF . For a 12-bit single-turn encoder, for example, the value is set to 2^12 = 4096. For more information, see: Data Persistence The instance is made persistent by means of a declaration as VAR_PERSISTENT or the Persistence Manager of the Application Composer. Persisting the axis position of a logical axis Requirement: The axis is logical. Use the SMC3_PersistPositionLogical function block to make the position of the logical axis persistent. This works only if the position of the superordinate physical axis was made persistent. The position of a virtual axis cannot be made persistent by means of these FBs. Create an instance of the SMC3_PersistPositionLogical function block for the axis. ppl: SM3_BASIC.SMC3_PersistPositionLogical; Instantiate a persistent data structure of the SMC3_PersistPositionLogical_Data type. ppl_Data: SMC3_PersistPositionLogical_Data; Extend the program of the motion task so that a call of the SMC3_PersistPositionLogical instance is implemented and the persistent data of type SMC3_PersistPositionLogical_Data is passed to it. " }, 
{ "title" : "Persisting the axis position of a multi-turn absolute encoder with a physical axis ", 
"url" : "_sm_storing_axis_position_persistently.html#UUID-71a9dfd2-c008-608a-c739-86d0c80e041d_id_f83d9cd75f3d951cc0a8640e00a495cd_id_49c53944c3ac11e3ae6789f982afc4cc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Use Cases \/ Persisting an Axis Position \/ Persisting the axis position of a multi-turn absolute encoder with a physical axis ", 
"snippet" : "Requirement: The axis has a multi-turn absolute encoder. Use the SMC3_PersistPosition function block to make the position of the physical axis persistent. The respective program runs in the motion task. Create an instance of the SMC3_PersistPosition function block for the axis. pp: SM3_BASIC.SMC3_Pe...", 
"body" : "Requirement: The axis has a multi-turn absolute encoder. Use the SMC3_PersistPosition function block to make the position of the physical axis persistent. The respective program runs in the motion task. Create an instance of the SMC3_PersistPosition function block for the axis. pp: SM3_BASIC.SMC3_PersistPosition; Instantiate a persistent data structure of the SMC3_PersistPosition_Data type. pp_Data: SM3_BASIC.SMC3_PersistPosition_Data1; Extend the program of the motion task so that a call of the SMC3_PersistPosition instance is implemented there. Call implemented in CFC: The function block is called in cycles with the motion task. The SMC3_PersistPosition instance performs the restoring of the saved position during the startup operation. In normal operation, the function block saves the actual position in the respective data structure. " }, 
{ "title" : "Persisting the axis position of single-turn absolute encoder with physical axis ", 
"url" : "_sm_storing_axis_position_persistently.html#UUID-71a9dfd2-c008-608a-c739-86d0c80e041d_id_f83d9cd75f3d951cc0a8640e00a495cd_id_a4cc9967c3ac11e3ae6789f982afc4cc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Use Cases \/ Persisting an Axis Position \/ Persisting the axis position of single-turn absolute encoder with physical axis ", 
"snippet" : "Requirement: The physical axis has a single-turn absolute encoder. Use the SMC3_PersistPosition function block to make the position of the axis persistent. The respective program runs in the motion task. The position is displayed correctly only if the axis has not traveled any distance or only a sho...", 
"body" : "Requirement: The physical axis has a single-turn absolute encoder. Use the SMC3_PersistPosition function block to make the position of the axis persistent. The respective program runs in the motion task. The position is displayed correctly only if the axis has not traveled any distance or only a short distance (maximum of half of the single-turn distance) between switching off and on the controller. For example, you can use a mechanical brake to do this. If the axis makes a large movement when the controller is switched off, then it receives an incorrect position. It is not possible to check by means of the FB. Create an instance of the SMC3_PersistPosition function block for the axis. ppst_X: SM3_BASIC.SMC3_PersistPositionSinglturn; Instantiate a persistent data structure of the SMC3_PersistPosition_Data type. ppst_Data_X: SMC3_PersistPositionSingleturn_Data; Extend the program of the motion task so that a call of the SMC3_PersistPosition instance is implemented and the persistent data structure of the SMC_PersistPosition_Data type is passed to it. " }, 
{ "title" : "Initial Position Detection of a Modulo Axis ", 
"url" : "_sm_initial_positioning_of_a_rotary_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Use Cases \/ Initial Position Detection of a Modulo Axis ", 
"snippet" : "The actual position of a drive or encoder is transmitted as DWORD to the controller. For a modulo axis, the period P is defined in increments by the modulo value and the scaling. The period P specifies the exact number of increments in a rotation. This means that the positional values X, X+1*P, X+2*...", 
"body" : "The actual position of a drive or encoder is transmitted as DWORD to the controller. For a modulo axis, the period P is defined in increments by the modulo value and the scaling. The period P specifies the exact number of increments in a rotation. This means that the positional values X, X+1*P, X+2*P, etc. describe the same physical position. The position X+n*P exceeds the limit of DWORD when n is large enough. This happens at position 0x1 00 00 00 00. Then the leading place is cut and the value begins at 0 . If P is not a factor of 0x1 00 00 00 00 , then position X no longer describes the same physical position before and after the interruption. If the gear ratios are set so that the period is not a factor of 0x1 0000 0000 , then the position of an axis of rotation can be moved after activation. Example The axis starts at position 0x0 . It is at 0°. One period is 360°. The scaling is selected so that this corresponds to 3600000 = 0x36 EE80 increments. After 1193 rotations, the axis stops at 0xFFFD 7280=1193*3600000 . After another complete rotation, the axis reaches the position 0x10034 6100 . At the interruption, the leading 1 is cut and the position 0x34 6100 is formed. If you move the axis back to position 0x0 , then the axis stops at position 16.7296°. Therefore, the position 0x0 corresponds to the position 0°, 16.7296°, etc., depending on the actual interruption. If you have selected the scaling so that the above effect can occur, and if homing is not possible or required at the start of the program, then you can recover the position before the last deactivation by means of the SMC3_PersistPosition function block. You use an absolute value encoder here. " }, 
{ "title" : "CiA402 Axes ", 
"url" : "_sm_cia402_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ CiA402 Axes ", 
"snippet" : "For more information, see SoftMotion...", 
"body" : "For more information, see SoftMotion" }, 
{ "title" : "Configuration of the Generic CiA402 Axis ", 
"url" : "_sm_drives_generic_cia402_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ CiA402 Axes \/ Configuration of the Generic CiA402 Axis ", 
"snippet" : "CODESYS SoftMotion provides drivers for various drives. If no specific driver is available for the CiA402 drive which you are using, then you can use the generic CiA402 axis. However, the compatibility and behavior of the generic axis depend largely on the CiA402 implementation in the respective dri...", 
"body" : "CODESYS SoftMotion provides drivers for various drives. If no specific driver is available for the CiA402 drive which you are using, then you can use the generic CiA402 axis. However, the compatibility and behavior of the generic axis depend largely on the CiA402 implementation in the respective drive. In practice, it has been shown that different manufacturers interpret the CiA402 standard differently – particularly with regard to error handling and support for limit switches. Therefore, it cannot be guaranteed that the generic CiA402 axis will always function correctly or completely with a particular drive. The generic CiA402 driver supports up to 8 axes in case the device description of the drive does not specify a number. Otherwise, the number of axes defined in the device description is supported. CANopen : The number of possible axes depends on the profiles of the logical devices in the EDS file ( 1000H object and 67FFH + X * 800H , where X = number of logical devices). For more details, see the CANopen CiA301 standard. EtherCAT : The number of possible axes depends on the defined CiA402 channels (CoE DS402Channels) in the ESI file. An adaptation of the EDS or ESI file needs to be done by the device manufacturer. " }, 
{ "title" : "Objects used when commissioning ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e06c925bc32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ CiA402 Axes \/ Configuration of the Generic CiA402 Axis \/ Objects used when commissioning ", 
"snippet" : "When commissioning, the following objects are accessed if they are supported by the device. Object Read\/Write Access (M)andatory (O)ptional Comment 0x1000:0 Read M The lower value has to be 402. Otherwise cancel. 0x1018:1 Read O 0x1018:2 Read O 0x1018:3 Read O 0x1018:4 Read O 0x6502:0 Read O 0x605A:...", 
"body" : "When commissioning, the following objects are accessed if they are supported by the device. Object Read\/Write Access (M)andatory (O)ptional Comment 0x1000:0 Read M The lower value has to be 402. Otherwise cancel. 0x1018:1 Read O 0x1018:2 Read O 0x1018:3 Read O 0x1018:4 Read O 0x6502:0 Read O 0x605A:0 Read O 0x60C2:1 Write If parameter Set60C2 = TRUE 0x60C2:2 Write If parameter Set60C2 = TRUE 0x6076:0 Read O " }, 
{ "title" : "Objects used during operation ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e7dfc492c32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ CiA402 Axes \/ Configuration of the Generic CiA402 Axis \/ Objects used during operation ", 
"snippet" : "The following objects are used during operation depending on the functions used: 0x603F:00 , 0x6040:00 , 0x6041:00 , 0x6060:00 , 0x6061:00 , 0x6062:00 , 0x6064:00 , 0x606B:00 , 0x606C:00 , 0x6074:00 , 0x6077:00 , 0x6078:00 , 0x607C:00 , 0x60B1:00 , 0x60B2:00, 0x60B8:00 0x60B9:00 , 0x60BA:00 , 0x60BB...", 
"body" : "The following objects are used during operation depending on the functions used: 0x603F:00 , 0x6040:00 , 0x6041:00 , 0x6060:00 , 0x6061:00 , 0x6062:00 , 0x6064:00 , 0x606B:00 , 0x606C:00 , 0x6074:00 , 0x6077:00 , 0x6078:00 , 0x607C:00 , 0x60B1:00 , 0x60B2:00, 0x60B8:00 0x60B9:00 , 0x60BA:00 , 0x60BB:00 , 0x60BC:00 , 0x60BD:00 , 0x60F4:00 . " }, 
{ "title" : "Advanced configuration ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_id_b66508a241e498bc0a8640e012ea61c_id_e7e012b4c32711e4aab5c98632e59a25", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ CiA402 Axes \/ Configuration of the Generic CiA402 Axis \/ Advanced configuration ", 
"snippet" : "You need to select the Show generic device configuration views option in the Options: Device editor dialog so that the tab with the parameters is displayed. You can use the following parameters to fine-tune the flow of the CiA402 state machine. CiA402 Parameter Description _readVelocityFactor_6096 T...", 
"body" : "You need to select the Show generic device configuration views option in the Options: Device editor dialog so that the tab with the parameters is displayed. You can use the following parameters to fine-tune the flow of the CiA402 state machine. CiA402 Parameter Description _readVelocityFactor_6096 TRUE : The velocity factor (object 6096 ) is read and used to convert the velocity units. FALSE : The velocity factor is not read. The velocity unit is assumed to be increments per second. _bImmediateDisabling TRUE : When bRegulator is reset to FALSE , switches the status of the drive from Operation enabled directly to Switch on disabled . FALSE : Switches the status via \"Switched on\" and \"Ready to switch on\", giving the drive the chance to execute a quickstop and handle the brake properly. Note: If this option is set to FALSE , then the states for which immediate disabling is switched off can be fine-tuned with the bit mask _dwStatesImmediateDisabling . _bForbidReenableDuringDisabling Only relevant when _bImmediateDisabling = FALSE . TRUE : The drive is disabled step-by-step until the drive signals to be in Ready to switch on before a new enable command is processed. dwStatesImmediateDisabling Only relevant when _bImmediateDisabling = FALSE . Bit mask of the states for which immediate disabling is turned on. Bit 0: Normal Operation Bit 1: Quickstop Bit 2: External Quickstop Bit 3: Homing Example: Assuming _bImmediateDisabling = FALSE , the value 2#0110 means that the immediate disabling is turned off only for the states \"Normal Operation\" and \"Homing\". For states “Quickstop\" and \"External Quickstop\", immediate disabling is turned on. _uiPreHomingWait Number of cycles which the state machine waits in state PRE_HOMING before starting the homing process by setting bit 4 of the control word. _uiPostHomingWait Number of cycles which the state machine stays in HOMING_DONE before switching back to \"Normal Operation\". _uiHomingMinCycles Number of cycles at the beginning of HOMING , where the done bits (bit 10\/12 of the status word) are ignored. _uiWaitCyclesForStateSwitch Number of cycles which the system waits until the drive has executed a state change command. If the drive fails, then the system will switch back to SWITCH_ON_DISABLED . _bPreHomingWaitBit12Clear TRUE : Wait in PRE_HOMING until bit 12 of the status word has been cleared by the drive before starting homing (before setting bit 4 of the control word). Note that in any case, the state machine stays in PRE_HOMING for at least _uiPreHomingCycles . _bCheckBit10PostHoming TRUE : Switch to HOMING_DONE if bit 12 and bit 10 of the status word are both TRUE (as specified in CiA-402). FALSE : Ignore bit 10; only use bit 12. _bCheckOpMode TRUE : Check if 0x6061 shows the value set in 0x6060 when enabling the axis. FALSE : Omit this check and enable immediately after setting the operation mode. _abyControllerMode This ARRAY[0..7] OF BYTE contains the operation modes (object 0x6060 ) which correspond with AXIS_REF_SM3.byOperationMode . (index 0,3 = position; index 1 = velocity; index 2 = torque) _bCheckBit12InPositionMode TRUE : AxisIsReadyForMotion checks bit 12 in CSP or IP. FALSE : AxisIsReadyForMotion does not check bit 12. _bDoHaltWhenStopInterruptsHome TRUE : When MC_Stop interrupts, abort homing with bit 8 of the control word. FALSE : Do not set bit 8, but directly switch the operation mode. _bCheckBit13InHomingMode TRUE : In HOMING_ACTIVE , wStatusWord.13 = TRUE leads to errorstop and (depending on _bDoHaltWhenStopInterruptsHome ) wControlWord.8 := TRUE . _bSetControlBit4InCSP TRUE : Set bit 4 of status word also in CSP mode. Some drives require this, although it is non-standard. _uiHomingWaitListeningBits101213 In state HOMING_ACTIVE , do not listen to bits 10, 12, and 13 during this number of cycles from setting bit 4. (Some drives take some time to reset these bits). _bRegulatorOnRequiresVoltageEnabled Whether bit 4 of the status word (voltage enabled) needs to be TRUE so that bRegulatorRealState = TRUE (default value: FALSE ). _bDriveStartRequiresOperationEnabled Whether bit 2 of the status word (operation enabled) needs to be TRUE so that bDriveStartRealState = TRUE (default value: TRUE ). _modeOfOperation_Torque The ModeOfOperation to be used for controller mode torque . Must behave like the cyclic sync torque mode. _modeOfOperation_Velocity The ModeOfOperation to be used for controller mode velocity . Must behave like the cyclic sync velocity mode. _modeOfOperation_Position The ModeOfOperation to be used for controller mode position . Must behave like the cyclic sync position mode. _bStayInSwitchOnDisabled FALSE : An automatic transition from SWITCH_ON_DISABLED to READY_TO_SWITCH_ON is performed, if either MC_Power.bDriveStart is TRUE or the quick stop option code ( object 0x605A:00 ) is > 4. TRUE: The transition from SWITCH_ON_DISABLED to READY_TO_SWITCH_ON is only done if MC_Power.bRegulatorOn is TRUE . " }, 
{ "title" : "Touch Probe ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_section-idm235087437140543", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ CiA402 Axes \/ Configuration of the Generic CiA402 Axis \/ Touch Probe ", 
"snippet" : "The MC_TouchProbe function block requires a TRIGGER_REF as an input. TRIGGER_REF.iTriggerNumber has the following meaning for the generic CiA402 axis: TRIGGER_REF.iTriggerNumber Meaning 0 Touch probe 1, positive edge 1 Touch probe 1, negative edge 2 Touch probe 2, positive edge 3 Touch probe 2, nega...", 
"body" : "The MC_TouchProbe function block requires a TRIGGER_REF as an input. TRIGGER_REF.iTriggerNumber has the following meaning for the generic CiA402 axis: TRIGGER_REF.iTriggerNumber Meaning 0 Touch probe 1, positive edge 1 Touch probe 1, negative edge 2 Touch probe 2, positive edge 3 Touch probe 2, negative edge " }, 
{ "title" : "Error diagnosis: The drive cannot be switched on via MC_Power ", 
"url" : "_sm_drives_generic_cia402_axis.html#UUID-8699194a-e34b-85e6-bb2e-a82ccf0b58cd_section-idm235087440495495", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ CiA402 Axes \/ Configuration of the Generic CiA402 Axis \/ Error diagnosis: The drive cannot be switched on via MC_Power ", 
"snippet" : "The generic axis expects the following bits in the status word in order to return MC_Power.Status = TRUE : Bit 0 (ready to switch on) Bit 1 (switched on) Bit 2 (operation enabled) Bit 5 (quick stop) Bit 12 However, Bit 12 is not set by every drive. If the drive does not set the bit, then the _bCheck...", 
"body" : "The generic axis expects the following bits in the status word in order to return MC_Power.Status = TRUE : Bit 0 (ready to switch on) Bit 1 (switched on) Bit 2 (operation enabled) Bit 5 (quick stop) Bit 12 However, Bit 12 is not set by every drive. If the drive does not set the bit, then the _bCheckBit12InPositionMode parameter of the generic axis can be set to FALSE . " }, 
{ "title" : "Touch Probe ", 
"url" : "_sm_touch_probe.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ CiA402 Axes \/ Touch Probe ", 
"snippet" : "Drives with a CiA402 profile sometimes support the selection of the touch probe source. It is not possible to set the source via the MC_TouchProbe function block. By default, the digital input belonging to the touch probe is used. Changing the source: Manual writing of the touch probe object 0x60B8 ...", 
"body" : "Drives with a CiA402 profile sometimes support the selection of the touch probe source. It is not possible to set the source via the MC_TouchProbe function block. By default, the digital input belonging to the touch probe is used. Changing the source: Manual writing of the touch probe object 0x60B8 To do this, you need to call the MC_WriteParameter function block with ParameterNumber = 10184 . This corresponds to the CiA 402 object 0x60B8 . If the output MC_WriteParameter.Done = TRUE , then you can command the MC_TouchProbe function block as usual. Only the bits from object 0x60B8 are set which can be defined by MC_TouchProbe (indicated by ). The remaining bits retain the value from Step 1 (indicated by ): Bits of object 0x60B8 Touch Probe 2 Touch Probe 1 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 Note about object 0x60D0 In the touch probe object 0x60B8 , you can specify the source so that it is resolved via the object 0x60D0 . This corresponds to the bit combination 10 b for bits 3 , 2 or 11 , 10 of object 0x60B8 . In this case, you need to write the object 0x60D0 before executing MC_TouchProbe . To do this, you need to use the MC_WriteParameter function block, in which the ParameterNumber is calculated using the SMC_ParameterNumber_CoE function. " }, 
{ "title" : "Actual Values, Set Values, and Dead Time ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Actual Values, Set Values, and Dead Time ", 
"snippet" : "This page answers the question of when the actual values and set values are received and sent, and how they are related to the dead time. For the sake of simplicity, we focus on the position, but the same applies to other values such as the velocity or torque. We also focus on EtherCAT. The behavior...", 
"body" : "This page answers the question of when the actual values and set values are received and sent, and how they are related to the dead time. For the sake of simplicity, we focus on the position, but the same applies to other values such as the velocity or torque. We also focus on EtherCAT. The behavior is similar for other fieldbuses. (Note that we assume the default and recommended configuration with FrameAtTaskStart = TRUE .) " }, 
{ "title" : "When are the actual values received? ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054861776368", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Actual Values, Set Values, and Dead Time \/ When are the actual values received? ", 
"snippet" : "The actual position ( <DriveA>.fActPosition ) is received at the beginning of the current bus task cycle. It is the actual position of the drive at the time of the previous EtherCAT SYNC event. In bus task cycle i, the EtherCAT frame which was sent in the previous bus task cycle i-1 is received. Thi...", 
"body" : "The actual position ( <DriveA>.fActPosition ) is received at the beginning of the current bus task cycle. It is the actual position of the drive at the time of the previous EtherCAT SYNC event. In bus task cycle i, the EtherCAT frame which was sent in the previous bus task cycle i-1 is received. This frame contains the actual position which has been latched by the drive at SYNC event i-2. " }, 
{ "title" : "When are the set values sent? ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862001312", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Actual Values, Set Values, and Dead Time \/ When are the set values sent? ", 
"snippet" : "The set values which are computed in the current bus task cycle i are sent to the drive in the following bus task cycle i+1 and applied by the drive at SYNC event i+1. See the diagram above....", 
"body" : "The set values which are computed in the current bus task cycle i are sent to the drive in the following bus task cycle i+1 and applied by the drive at SYNC event i+1. See the diagram above. " }, 
{ "title" : "What is the dead time, how is it estimated, and how is it used? ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862210917", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Actual Values, Set Values, and Dead Time \/ What is the dead time, how is it estimated, and how is it used? ", 
"snippet" : "As a general rule, the dead time is important whenever it is necessary to perform an action exactly when the drive reaches a position. The dead time is also important to exactly determine the drive position at a given time. Examples include applying glue with high velocity, or performing a touch pro...", 
"body" : "As a general rule, the dead time is important whenever it is necessary to perform an action exactly when the drive reaches a position. The dead time is also important to exactly determine the drive position at a given time. Examples include applying glue with high velocity, or performing a touch probe in the PLC with high precision digital inputs connected to the PLC. " }, 
{ "title" : "Definition of the dead time ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054862962511", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Actual Values, Set Values, and Dead Time \/ What is the dead time, how is it estimated, and how is it used? \/ Definition of the dead time ", 
"snippet" : "The dead time is the time it takes for the drive to actually reach the set position sent by the PLC. That means it is the time lag between the fActPosition and the fSetPosition , at the beginning of the current bus task cycle. The dead time can be configured in the general drive editor ( Tab: Genera...", 
"body" : "The dead time is the time it takes for the drive to actually reach the set position sent by the PLC. That means it is the time lag between the fActPosition and the fSetPosition , at the beginning of the current bus task cycle. The dead time can be configured in the general drive editor ( Tab: General) or using the MC_WriteParameter function block with the parameter number 1070 ( fSetActTimeLagCycles ). The dead time is the sum the following times: The time it takes to send the set position to the drive The time the drive controller needs to reach the set position The time it takes to receive the actual position from the drive " }, 
{ "title" : "Estimation of the dead time ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054864599382", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Actual Values, Set Values, and Dead Time \/ What is the dead time, how is it estimated, and how is it used? \/ Estimation of the dead time ", 
"snippet" : "The dead time can be estimated using the SMC_EstimateDeadTime function block. The drive should be moved with constant velocity, and the median or average of several dead-time measurements should be used. Alternatively, the dead time can be estimated using the trace editor. For more information, see ...", 
"body" : "The dead time can be estimated using the SMC_EstimateDeadTime function block. The drive should be moved with constant velocity, and the median or average of several dead-time measurements should be used. Alternatively, the dead time can be estimated using the trace editor. For more information, see the following: Determining the dead time of the system" }, 
{ "title" : "Use of the dead time ", 
"url" : "_sm_actualvalues_setvalues_deadtime.html#UUID-7e2319fc-191f-3422-38d6-8f261a4989a4_section-idm235054865995483", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Actual Values, Set Values, and Dead Time \/ What is the dead time, how is it estimated, and how is it used? \/ Use of the dead time ", 
"snippet" : "The dead time is used in the following functionality. If you are using any of these functions and need high precision, make sure to determine and configure the dead time. When switching controller mode to controller mode SMC_position For more information, see the following: Standard Use CasesIn cont...", 
"body" : "The dead time is used in the following functionality. If you are using any of these functions and need high precision, make sure to determine and configure the dead time. When switching controller mode to controller mode SMC_position For more information, see the following: Standard Use CasesIn controller mode SMC_velocity to compute the set position from the actual position and the set velocity In controller mode SMC_torque to compute the set position from the actual position and the actual velocity If software position lag monitoring is turned on In the SMC_GetTravelTime function block if the input ValueSource has the value MC_SOURCE.ACT In the SMC_DigitalCamSwitch_HighPrecision function block if the input ValueSource has the value MC_SOURCE.ACT In the SMC_ETC_InterpolateAxisPosition function block (PLC based touch probe) " }, 
{ "title" : "Examples ", 
"url" : "_sm_drives_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Examples ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Position Control on the Controller with SM_Drive_PosControl ", 
"url" : "_sm_example_poscontrol.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Examples \/ Position Control on the Controller with SM_Drive_PosControl ", 
"snippet" : "See the PosControl.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . In most cases, a servo control takes over the position control of the drive, as well as the power control and rotational speed control. However, there are use cases in which the ...", 
"body" : "See the PosControl.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . In most cases, a servo control takes over the position control of the drive, as well as the power control and rotational speed control. However, there are use cases in which the controller takes over the position control of the axis. This example demonstrates how a speed-controlled device (for example, frequency converter with position feedback) is position-controlled by CODESYS SoftMotion . The requirement is a device that is controlled by the set velocity and returns its current position. In this example, a 10V analog output terminal EL4031 is used with a signal that is used as a speed setpoint for a frequency converter. An encoder terminal EL5101 is used for position feedback. " }, 
{ "title" : "Control of the axis position by means of SM_Drive_PosControl ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_7bfb9b9f2d9ce618c0a8646335ff28dd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Examples \/ Position Control on the Controller with SM_Drive_PosControl \/ Control of the axis position by means of SM_Drive_PosControl ", 
"snippet" : "Add a position-controlled axis of type SM_Drive_PosControl below SoftMotion General Axis Pool in the device tree. Add the terminals for the analog terminal (EL4031) and the encoder (EL5101) to the device tree. Device tree: The device descriptions of the fieldbus devices have to be downloaded and ins...", 
"body" : "Add a position-controlled axis of type SM_Drive_PosControl below SoftMotion General Axis Pool in the device tree. Add the terminals for the analog terminal (EL4031) and the encoder (EL5101) to the device tree. Device tree: The device descriptions of the fieldbus devices have to be downloaded and installed from the manufacturer. Open the SM_Drive_PosControl device in the editor and specify the general parameter Modulo with value 360.0 on the General tab. Click the Scaling\/Mapping tab. The number of increments per motor turn is taken from the data sheet of the encoder. In this example, 4096 increments (1) are one motor turn. Because you are working with angular degrees in the application, you specify the value 360 (2) for units in application . Settings: Switch to the SoftMotion Drive: Position Control Loop tab and specify the following parameters: D 2.0 The dead time determines the number of cycles that the received actual position (encoder) is phase-shifted to the set position of the axis. The dead time depends on the applied components and has to be determined by trial and error. Kp 0.0 The constant of proportionality is the factor by which the position error (the deviation between set and actual position) is multiplied to be added later to the set velocity. Now set this value to 0 . You will determine the value experimentally at a later time. Bit width: 16 The bit width of the actual value is received depending on the used components and can be set as 16, 24, or 32-bit values. Set the value to 16 because the used components yield the position as UINT . max Leave the position error monitoring switch off. You can switch it back on again if necessary. Select the check box and specify a maximum permitted lag. If this value is exceeded during operation, then the axis goes into an error state. δ\/δt The parameter has the value 1 and should be changed only in very special cases. It defines the relationship between the set velocity and the derivation of the position. The value range is 0 to 1: 0 : Only the numerical derivative of fSetPosition is used. 1 : Only fSetVelocity is used. Control loop: Now you set the velocity values that are sent to the actuator. For this purpose, you need to know the maximum velocity in application units and the corresponding raw value of the transferred data. In this example, the maximum velocity is achieved by the output of the value 16#7FFF , which corresponds to a velocity of 10 turns per second. This also corresponds to 3600 degrees per second according to the settings. Settings: " }, 
{ "title" : "Mapping of variables to inputs and outputs ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_869c8e3e2852db2ec0a8640e00c42e8b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Examples \/ Position Control on the Controller with SM_Drive_PosControl \/ Mapping of variables to inputs and outputs ", 
"snippet" : "Map the variables with the axis data to the I\/O modules. The available cyclic data of the axis are located in the data structures in and out . You can establish this connection in the device editor of the input and output device either programmatically or directly. Connect the output (set speed) to ...", 
"body" : "Map the variables with the axis data to the I\/O modules. The available cyclic data of the axis are located in the data structures in and out . You can establish this connection in the device editor of the input and output device either programmatically or directly. Connect the output (set speed) to the EL4031 device. Open the device in the editor and click the EtherCAT I\/O Mapping tab. Assign the variable out.iSetVelocity of the axis to the output. In the case of a 32-bit output, out.diSetVelocity is used. Mapping: Proceed in the same way with the position input. Open the EL5101 device in the editor and set the position input value to in.wActPosition . For a 32-bit input, set the value to in.dwActPosition . Mapping: In order for control enable, quickstop, and limit switch to operate, the corresponding inputs of SMC_PosControlInput have to be defined by the values of the drive. The outputs of SMC_PosControlOutput have to be transmitted to the drive (see description below). If the drive does not support quickstop, for example, then SM_Drive_PosControl.in.bDriveStartRealState := TRUE has to be set and SM_Drive_PosControl.out.bDriveStart can be ignored. In this example, bDriveStartRealState and bRegulatorRealState have to be set in the application. SM_Drive_PosControl.in.bDriveStartRealState := TRUE;\nSM_Drive_PosControl.in.bRegulatorRealState := TRUE; " }, 
{ "title" : "Determining the dead time of the system ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_section-idm43260109050006", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Examples \/ Position Control on the Controller with SM_Drive_PosControl \/ Determining the dead time of the system ", 
"snippet" : "Now set online mode with the axis and set the control parameters. Note that the axis may move out of control. Therefore you need to take corresponding safety precautions. Then try to operate the axis without position control. fKp is already set to 0.0 and the scaling settings are verified. Switch th...", 
"body" : "Now set online mode with the axis and set the control parameters. Note that the axis may move out of control. Therefore you need to take corresponding safety precautions. Then try to operate the axis without position control. fKp is already set to 0.0 and the scaling settings are verified. Switch the axis to MC_Power and start MC_MoveVelocity . The axis now moves at the programmed velocity of 1 U\/s. In case of deviations, you will have to correct the scaling accordingly. End the movement, for example with MC_MoveRelative , and start the trace function. Determine the dead time of the system by measuring the time difference between the set position and the actual position. In MC_MoveRelative , set the maximum velocity and a large acceleration. Start the sampling trace with MC_MoveRelative . Now determine the time difference between the start movement of the set position and the first reaction of the actual position. Trace: To determine the dead time D , divide this time difference by the cycle time (D = time difference \/ cycle time). On the SoftMotion Drive: Position Control tab, specify this value in control loop at D . Now try to determine the correct setting for fKp . To do this, change the value of the variable <drive>.controller.fKp in a watch list. Set fKp to a small number (e.g., 0.0001) and increase the value step by step. Check the behavior for each change with the sampling trace. As soon as you detect fluctuations, the upper limit has been reached. Now decrease the value of fKp by about 10% and specify it on the SoftMotion Drive: Position Control tab in the control loop at Kp . Now you can use the axis. " }, 
{ "title" : "Function Block: SMC_PosControlInput ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_666f8939fd0b11e3b1f5b5a0173eacdc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Examples \/ Position Control on the Controller with SM_Drive_PosControl \/ Function Block: SMC_PosControlInput ", 
"snippet" : "Library: SM3_Drive_PosControl Inputs (VAR_INPUT) Name Data Type Initial Value Description bLimitPos BOOL Limit switch in positive direction (for finite axes only) Since SoftMotion version 4.12.0.0, the limit switch monitoring is enabled by default. For older versions, this has to be enabled manually...", 
"body" : "Library: SM3_Drive_PosControl Inputs (VAR_INPUT) Name Data Type Initial Value Description bLimitPos BOOL Limit switch in positive direction (for finite axes only) Since SoftMotion version 4.12.0.0, the limit switch monitoring is enabled by default. For older versions, this has to be enabled manually by setting bHWLimitEnable to TRUE . This is typically done by writing the corresponding parameter number 1206 by means of MC_WriteBoolParameter . TRUE : Limit switch not actuated FALSE : Limit switch actuated bLimitNeg BOOL Limit switch in negative direction TRUE : Limit switch not actuated FALSE : Limit switch actuated wActPosition WORD Current position (actual position) as 16-bit value dwActPosition DWORD Current position (actual position) as 32-bit value bExternalError BOOL External error bRegulatorRealState BOOL TRUE : Axis being controlled bDriveStartRealState BOOL FALSE : Axis in Quick Stop dwEncoderCounterModulo DWORD 0 bDelayActivation BOOL TRUE : As long as bDelayActivation is TRUE , SM3_Drive_PosControl does not switch to the communication state 100 . Use case: The value is held at TRUE until the applied encoder yields valid positional values. " }, 
{ "title" : "Function Block: SMC_PosControlOutput ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_60809817bdae11e9b2a8cd92ec450e2f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Examples \/ Position Control on the Controller with SM_Drive_PosControl \/ Function Block: SMC_PosControlOutput ", 
"snippet" : "Library: SM3_Drive_PosControl Outputs (VAR_OUTPUT) Name Data Type Initial Value Description bRegulatorOnIn BOOL TRUE : The axis should be controlled. bDriveStart BOOL FALSE : The axis should execute a quickstop. diSetVelocity DINT Set velocity iSetVelocity INT Set velocity...", 
"body" : "Library: SM3_Drive_PosControl Outputs (VAR_OUTPUT) Name Data Type Initial Value Description bRegulatorOnIn BOOL TRUE : The axis should be controlled. bDriveStart BOOL FALSE : The axis should execute a quickstop. diSetVelocity DINT Set velocity iSetVelocity INT Set velocity " }, 
{ "title" : "Function Block: SMC_SetPosControlParams ", 
"url" : "_sm_example_poscontrol.html#UUID-3147ecb8-636d-2293-9136-f7f839d5e7e2_id_b626da777eec0a86463551095b7_id_6080e639bdae11e9b2a8cd92ec450e2f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ Examples \/ Position Control on the Controller with SM_Drive_PosControl \/ Function Block: SMC_SetPosControlParams ", 
"snippet" : "Library: SM3_Drive_PosControl Changes the parameters of an SM3_Drive_PosControl axis Inputs (VAR_INPUT) Name Data Type Initial Value Description Axis AXIS_REF_POSCONTROL Axis reference bExecute BOOL TRUE : Activates the execution of the function block fKp LREAL -1 Proportional gain for lag A value l...", 
"body" : "Library: SM3_Drive_PosControl Changes the parameters of an SM3_Drive_PosControl axis Inputs (VAR_INPUT) Name Data Type Initial Value Description Axis AXIS_REF_POSCONTROL Axis reference bExecute BOOL TRUE : Activates the execution of the function block fKp LREAL -1 Proportional gain for lag A value less than 0 is ignored. fPartVelPilotControl LREAL -1 Factor for the velocity control with fSetPosition 0: No velocity pilot control; 1: Direct output of fSetVelocity . A value less than 0 is ignored. fDeadTime LREAL -1 Time lag in cycles between fSetPosition and fActPositioin This value must not be 0. A value less than 0 is ignored. fMaxPositionDiff LREAL -1 Maximum position lag 0 deactivates the check of the maximum position lag. A value less than 0 is ignored. Outputs (VAR_OUTPUT) Name Data Type Initial Value Description bDone BOOL The execution of the function block has been ended. bError BOOL TRUE : An error has occurred in the function block. ErrorID SMC_ERROR Error identification Example The parameters of the axis drive SM_Drive_PosControl are set. PROGRAM PLC_PRG\nVAR\n fbSetPosControlParams : SMC_SetPosControlParams;\nEND_VAR\n\nfbSetPosControlParams.fKp := 1;\nfbSetPosControlParams.fPartVelPilotControl :=0;\nfbSetPosControlParams.fDeadTime :=0.1;\nfbSetPosControlParams.fMaxPositionDiff :=1;\n\nfbSetPosControlParams(Axis:= SM_Drive_PosControl, bExecute:= TRUE); " }, 
{ "title" : "User Interface ", 
"url" : "_sm_drives_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ User Interface ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Command: Add SoftMotion CiA402 Axis ", 
"url" : "_sm_cmd_add_softmotion_cia402_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ User Interface \/ Command: Add SoftMotion CiA402 Axis ", 
"snippet" : "SoftMotion CiA402 Axis Function : The command adds a general SoftMotion CiA402 axis below a fieldbus slave in the device tree. Call : Project menu; context menu of a device object in the device tree Requirement : In the device tree, a device is selected which supports this drive. Examples: EtherCAT ...", 
"body" : "SoftMotion CiA402 Axis Function : The command adds a general SoftMotion CiA402 axis below a fieldbus slave in the device tree. Call : Project menu; context menu of a device object in the device tree Requirement : In the device tree, a device is selected which supports this drive. Examples: EtherCAT slave or CAN slave The ESI file of the drive contains the entry that it is a CiA402 axis ( ProfileNo 402 ). The command inserts a generic CiA402 axis. For more information, see the following: Configuration of the Generic CiA402 Axis " }, 
{ "title" : "Command: Add SoftMotion Sercos Axis ", 
"url" : "_sm_cmd_add_softmotion_sercos_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ User Interface \/ Command: Add SoftMotion Sercos Axis ", 
"snippet" : "Add SoftMotion Sercos Axis Function : The command adds a general SoftMotion Sercos axis below a Sercos Module. Call : Project menu; context menu of the Sercos Slave Requirement : An appropriate Sercos slave is selected in the device tree. Sercos axes are no longer supported for SoftMotion Version 4....", 
"body" : "Add SoftMotion Sercos Axis Function : The command adds a general SoftMotion Sercos axis below a Sercos Module. Call : Project menu; context menu of the Sercos Slave Requirement : An appropriate Sercos slave is selected in the device tree. Sercos axes are no longer supported for SoftMotion Version 4.17.0.0 and higher. This command is used in order for any servo drive to work with CODESYS SoftMotion . The drive only has to support the Sercos standard. CODESYS uses a standard driver for communicating with the device. The way in which the drive works or not with the device depends on the implementation in the device itself. Therefore, there is no guarantee how the driver works or not with the device. The generic Sercos driver supports multi-axis devices up to eight axes. " }, 
{ "title" : "Command: Add SoftMotion SoE Axis ", 
"url" : "_sm_cmd_add_softmotion_soe_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ User Interface \/ Command: Add SoftMotion SoE Axis ", 
"snippet" : "Add SoftMotion SoE Axis Function : The command adds a general SoftMotion SoE axis below an EtherCAT Slave. Call : Project menu; context menu of the slave Requirement : An appropriate EtherCAT slave is selected in the device tree. This command is used in order for any servo drive to work with CODESYS...", 
"body" : "Add SoftMotion SoE Axis Function : The command adds a general SoftMotion SoE axis below an EtherCAT Slave. Call : Project menu; context menu of the slave Requirement : An appropriate EtherCAT slave is selected in the device tree. This command is used in order for any servo drive to work with CODESYS SoftMotion . The servo drive only has to support the SoE standard. CODESYS uses a standard driver for communicating with the device. The way in which the drive works or not with the device depends on the implementation in the device itself. Therefore, there is no guarantee how the driver works or not with the device. The generic SoE driver supports multi-axis devices up to eight axes. " }, 
{ "title" : "SoftMotion Drives ", 
"url" : "_sm_f_reference_object_sm_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ User Interface \/ SoftMotion Drives ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Tab: General ", 
"url" : "_sm_edt_drive_general.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ User Interface \/ SoftMotion Drives \/ Tab: General ", 
"snippet" : "Axis type and settings Axis type Virtual mode : The drive is replaced by a simulation which is similar to a virtual drive unit. When there is a coupled drive, this does not have any effect on the fieldbus device. They function as usual without sending or receiving messages to or from a physical devi...", 
"body" : "Axis type and settings Axis type Virtual mode : The drive is replaced by a simulation which is similar to a virtual drive unit. When there is a coupled drive, this does not have any effect on the fieldbus device. They function as usual without sending or receiving messages to or from a physical device. Note: You can also set and reset a virtual mode of a drive in IEC code by means of the SMC3_ReinitDrive function block. Modulo : The drive turns endlessly without limiting the travel range (example: belt drive). Modulo value [u] : Value of one cycle (modulo period) The value is saved in the fPositionPeriod parameter of the AXIS_REF_SM3 function block. Note: If you select the Modulo drive type, then the product fPositionPeriod * dwRatioTechUnitsDenom has to be an integer. Finite : The drive has a fixed workspace (example: one linear drive). Software limits Activated : Position values are restricted by the lower limit Negative and an upper limit Positive . Negative : Input field for the negative limiting value Positive : Input field for the positive limiting value Motor type Rotary : The settings in Scaling apply to rotary motors. Linear : The settings in Scaling apply to linear motors. (Simplified configuration without gears and motor turns) Velocity ramp type Defines the velocity profile for motion-generating single-axis and master\/slave modules: Note: The ramp types Sin² and Quadratic (smooth) are not supported for the robotics. Trapezoid : Trapezoidal velocity profile (with constant acceleration in each segment) Sin² : A velocity profile as defined by the sin² function (with constant acceleration curve). Quadratic : Acceleration profile in trapezoidal form with jerk limitation Quadratic (smooth) : Like Quadratic but generates a jerk profile without jumps. Identification ID Integer identifier. Should be unique for each drive. For example, this identifier is used in the PLC log in order to identify the drive when an error occurs. Dead time Cycles The dead time in cycles between the fActPosition and the fSetPosition at the beginning of this cycle Dynamic limits The limiting values from PLCopen Part 4 POUs are taken into consideration. Moreover, they are used by library POUs with the name SMC_ControlAxisBy* for detecting jumps. Velocity [u\/s] Limiting value of velocity, acceleration, deceleration, and jerk Acceleration [u\/s²] Deceleration [u\/s²] Jerk [u\/s³] Monitoring and error reaction Software limits Activated : Position values are restricted by the lower limit Negative and an upper limit Positive . Negative : Input field for the negative limiting value Positive : Input field for the positive limiting value Software error reaction Causes of a software error Reaching a software limit switch Exceeding the maximum allowed software lag For finite axes: Too many 32-bit overflows MC_Power.bRegulatorOn = FALSE during an active movement (error: SMC_FB_ACTIVE_AXIS_DISABLED ) Motion function block with Busy=TRUE not called (error: SMC_FB_WASNT_CALLED_DURING_MOTION ) For the software error reaction, the Deceleration , the Max. Distance , and the deceleration of the dynamic limits are taken into account. A deceleration is also calculated from the maximum distance. The highest of these deceleration values is used for the error ramp. Deceleration [u\/s²] : Deceleration for the error ramp Max. distance [u] Optional The drive has to have reached a standstill within this distance after an error has occurred. Position lag monitoring System response to a detected lag. A lag is detected when the difference between the set position and the compensated actual position exceeds the lag limit. The extrapolated actual position is calculated in the following formula: extrapolated actual position := actual position + actual velocity * cycle time * Axis.fSetActTimeLagCycles This value is the actual position of the axis compensated by the dead time. Note: If you are monitoring the lag, then you should determine and enter the dead time. For a description, see the following chapter: Actual Values, Set Values, and Dead Time. Note: Lag monitoring is not available for virtual drives. Deactivated No response Lag monitoring is deactivated. Disable drive The bRegulatorOn bit is forced to FALSE (compare with MC_Power input) which first forces the deceleration of the drive and then the deactivation of the drive (depending on the drive implementation). Do quickstop The bDriveStart bit is forced to FALSE (compare with MC_Power input) which forces the drive to perform a quickstop. Stay enabled The drive remains switched on, but all running movements are stopped abruptly. Lag limit : Lag monitoring in the controller Independent monitoring can also exist in the drive, but it is not configured in this dialog. Online Requirement: The PLC is in online mode. Variable table List of drive variables with variable name, Set value and Current value Status Display of the current status of the SoftMotion drive Communication Settings Display of the current communication status Error Axis error FB error uiDriveInterfaceError strDriveInterfaceError For more information, see the following: Determining the dead time of the systemExample The following images demonstrate the effect of the different ramp types. The position is drawn in green, the velocity in blue, and the acceleration in red. Trapezoid The velocity is partially linear and continuous, whereas the partially constant acceleration indicates jumps. Sin² The breaks in the velocity profile are smoothened (by using the sin² function instead of lines) to reduce the jumps in acceleration. The user cannot limit the jerk for this ramp type. The set maximum jerk has an effect only if the acceleration does not equal zero at the beginning of the movement and the interrupted deceleration and acceleration ramp cannot be continued seamlessly. Then, taking the jerk limit into account, the acceleration is decreased to zero before the current movement is started. As compared to the trapezoidal velocity profile, the deceleration takes more time in this case. Quadratic The acceleration is partially linear and continuous and the jerk has jumps. The velocity consists of quadratic and linear segments. Quadratic (smooth) The linear acceleration ramps of the quadratic ramp type are replaced by a \"smooth\" function with a slope value is zero at the beginning and end. As a result, the jerk is also continuous. Note: If a movement is interrupted, then jumps in the jerk can result. For more information, see the following: Interruption of Movements" }, 
{ "title" : "Tab: Scaling\/Mapping ", 
"url" : "_sm_edt_drive_scaling_mapping.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ User Interface \/ SoftMotion Drives \/ Tab: Scaling\/Mapping ", 
"snippet" : "On this tab, you can define the relationship between technical units (for example, millimeters or degrees) and the drive units (increments). Depending on the device description, the setting options are displayed simplified (parameter bHiresMode = TRUE ), and\/or scaling for linear motors may also be ...", 
"body" : "On this tab, you can define the relationship between technical units (for example, millimeters or degrees) and the drive units (increments). Depending on the device description, the setting options are displayed simplified (parameter bHiresMode = TRUE ), and\/or scaling for linear motors may also be possible (parameter IsLinearMotor = TRUE ). If necessary, you can also influence the mapping of cyclically transmitted drive objects to IEC variables. Scaling Invert direction : The direction of rotation is reversed. The motor gets the specified values with opposite signs. Precision (decimal digits) Requirement: The device description specifies a simplified configuration dialog (parameter bHiresMode = TRUE ). In this case, the hidden settings get the default value of 1 . Number of decimal places for the user units of the increments to be scaled and transferred. For example, 3 corresponds to a precision of 10 3 . increments <=> motor turns Number of increments that correspond to a given number of motor turns. You can see the parameter on the Configuration tab of the device editor. motor turns <=> gear output turns Number of motor turns that correspond to a given number of gear output turns. gear output turns <=> units in application Number of gear output turns that correspond to a unit in the application. Example of a comprehensive configuration In the sample configuration, a drive that has 3600 increments for a motor turn is scaled so that the technical units of the application are straight angular degrees. Mapping Note: These parameters are not available for Drive_PosControl. Automatic mapping : IEC parameters that affect the drive are automatically mapped to the corresponding inputs and outputs of the device. After deactivation of the option, the mapping can be edited manually. To do this, change the address or type of the inputs and outputs to the displayed parameter list that was created according to the device description file. " }, 
{ "title" : "Tab: Commissioning ", 
"url" : "_sm_edt_drive_commisioning.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ User Interface \/ SoftMotion Drives \/ Tab: Commissioning ", 
"snippet" : "You can move the drive by means of buttons on this page. The drive may make unexpected movements. Take all necessary safety precautions. This tab is used for testing purposes when commissioning physical drives. It is available only if the Online Configuration Mode is enabled. In this mode, the devel...", 
"body" : "You can move the drive by means of buttons on this page. The drive may make unexpected movements. Take all necessary safety precautions. This tab is used for testing purposes when commissioning physical drives. It is available only if the Online Configuration Mode is enabled. In this mode, the development system is connected to the device; however, an application does not have to be downloaded. Online Requirement: The PLC is in online mode. Variable table List of drive variables with variable name, Set value and Current value Status Display of the current status of the SoftMotion drive Communication Settings Display of the current communication status Error Axis error FB error uiDriveInterfaceError strDriveInterfaceError " }, 
{ "title" : "Operating elements ", 
"url" : "_sm_edt_drive_commisioning.html#UUID-44ff80c7-7f0e-b818-51b8-af95752bbbbd_id_b3c83ad0f91194c0a8646325634a44_id_063bbc9a58bd11e68fa9d28177272265", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ User Interface \/ SoftMotion Drives \/ Tab: Commissioning \/ Operating elements ", 
"snippet" : "Operating elements Power The drive is supplied with power (compare with MC_Power ). Error reset Resets the drive following an error (compare with MC_Reset ). Start homing The drive executes homing with the set parameters in the drive (compare with MC_Home ). Jogging By means of the < and > switches,...", 
"body" : "Operating elements Power The drive is supplied with power (compare with MC_Power ). Error reset Resets the drive following an error (compare with MC_Reset ). Start homing The drive executes homing with the set parameters in the drive (compare with MC_Home ). Jogging By means of the < and > switches, the drive can be moved forwards and backwards according to the specified values for Distance , Velocity , Acceleration , Deceleration , and Jerk (compare with MC_Inch ). Read&Write For the specified drive parameter, the current Value is read from the PLC and displayed. In Prepared Value , you can specify a new value and write to the parameter in the drive by means of the small button (compare with MC_ReadParameter , MC_WriteParameter ). " }, 
{ "title" : "Tab: SoftMotion Drive – Position Control ", 
"url" : "_sm_edt_drive_poscontrol_position_control_loop.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ User Interface \/ SoftMotion Drives \/ Tab: SoftMotion Drive – Position Control ", 
"snippet" : "On this tab, you set the parameters for the position control. Please also note the example  Position Control on the Controller with SM_Drive_PosControl. Position control loop fSetPosition Set position value D The dead time determines the number of cycles that the received actual position (encoder) i...", 
"body" : "On this tab, you set the parameters for the position control. Please also note the example  Position Control on the Controller with SM_Drive_PosControl. Position control loop fSetPosition Set position value D The dead time determines the number of cycles that the received actual position (encoder) is phase-shifted to the set position of the axis. The dead time depends on the applied components and has to be determined by trial and error. For more information, see: Determining the dead time of the systemfActPosition Actual position value Bit width The bit width of the actual value is received depending on the used components and can be set as 16, 24, or 32-bit values. Max : Position error monitoring is activated. Input of the maximum permitted lag If this value is exceeded during operation, then the axis goes into an error state. Kp The constant of proportionality is the factor by which the position error (the deviation between set and actual position) is multiplied to be added later to the set velocity. fSetVelocity Set velocity value Scaling of velocity output fActPosition and velocity output have opposite directions : If the velocity output and the current position have an opposing direction, then this is corrected by activating the option. Application [t.u.\/s] Minimum and maximum velocity value (in application units) for example 3600 rotations per second. Output value Minimum and maximum output value that is sent to the actuator (e.g. 16#7FFF). " }, 
{ "title" : "Tab: Logical Axes ", 
"url" : "_sm_edt_drive_logical_general.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ User Interface \/ SoftMotion Drives \/ Tab: Logical Axes ", 
"snippet" : "Axis type Modulo : The drive turns endlessly without limiting the traversing range (example: belt drive). Modulo settings Modulo value : Value of one cycle The value is saved in the fPositionPeriod parameter of the AXIS_REF_SM3 function block. Note: If you select the Modulo drive type, then the prod...", 
"body" : "Axis type Modulo : The drive turns endlessly without limiting the traversing range (example: belt drive). Modulo settings Modulo value : Value of one cycle The value is saved in the fPositionPeriod parameter of the AXIS_REF_SM3 function block. Note: If you select the Modulo drive type, then the product fPositionPeriod * dwRatioTechUnitsDenom has to be an integer. Finite : The drive has a fixed work area (example: one linear drive). Negative : Input field for the negative limiting value Positive : Input field for the positive limiting value Master reference value Set : The set value of the master is used as the input for the logical axis and the dead-time compensation. Actual : The actual value of the master is used as the input for the logical axis and the dead-time compensation. Time offset Time offset relative to the master values Number of cycles The set values have to be extrapolated in this time span Input data filters With the filters, it is possible to smooth the position and velocity values of an encoder using a PT1 filter. Position Number of cycles used as the time constant of the PT1 filter. Value range: [0..999.9] Value 0: No filtering is performed (raw values are returned). The filtered return value is a combination of a PT1 filtered position signal and an additional position extrapolation using the velocity signal. The extrapolation itself also uses a PT1 filter to mitigate noise and automatically selects an appropriate time constant: If only set values should get filtered or the axis sends the velocity signal, then the time constant of the extrapolation PT1 is the same as for the position PT1 filter. Otherwise, an heuristic approach is used: T Extrapolate = (T Pos + T Dead ) * T Pos \/ T Cycle T Extrapolate : Time constant from the PT1 extrapolation filter T Pos : Time constant from the PT1 position filter T Cycle : Cycle time T Dead : Dead time compensation, using the time shift relative to the master values of the logical axis n Shift and the cycle time T Cycle : T Dead = n Shift * T Cycle Velocity Number of cycles used as the time constant of the PT1 filter. Value range: [0..999.9] Value 0: No filtering is performed (raw values are returned). The filtered return value is a combination of a PT1 filtered velocity signal and an additional velocity extrapolation using the acceleration signal. Note that the extrapolation is used only if the axis sends a velocity signal or if set points should be filtered. The extrapolation itself also uses a PT1 filter to mitigate noise and automatically selects an appropriate time constant: T Extrapolate = (T Vel + T Dead ) * T Vel \/ T Cycle with T Extrapolate : Time constant from the PT1 extrapolation filter T Vel : Time constant from the PT1 velocity filter T Cycle : Cycle time T Dead : Dead time compensation, using the time shift relative to the master values of the logical axis n Shift and the cycle time T Cycle : T Dead = n Shift * T Cycle Velocity signal of the logical axis ( fActVelocity ): Case 1: Master reference value = Set fSetVelocity of the master axis is used as a raw value for the velocity signal of the logical axis. Case 2: Master reference value = Actual and no velocity signal from the master axis. The numerical derivative of the filtered position of the logical axis ( fActPosition ) is used as a raw value for the velocity signal of the logical axis. Case 3: Master reference value = Actual and a velocity signal from the master axis. The velocity signal is used as a raw value for the velocity signal of the logical axis. Velocity filtering is performed on this raw signal. This means that if it is configured with the default value usiFilterDepthVelocity = 0 , then this signal is passed unchanged to fActVelocity . In case 2, it would also be possible to use the numerical derivative of the unfiltered position ( fActPosition of the master axis). The filtered position has been selected because in this case the fActVelocity of the logical axis matches the fActPosition in the default configuration without velocity filtering. For the velocity, the extrapolation of the filter delay is performed only in cases 1 and 3. In case 2, this would not be numerically stable or this would require too much filtering of the acceleration to be meaningful. Acceleration of the logical axis ( fActAcceleration ) Case 1: Master reference value = Set fSetAcceleration  of the master axis is used for the acceleration signal of the logical axis. Case 2: Master reference value = Actual and a velocity signal from the master axis. The numerical derivative of the filtered velocity of the logical axis ( fActVelocity ) is used for the acceleration signal of the logical axis. Case 3: Master reference value = Actual and no velocity signal from the master axis. The value 0 is used for the acceleration signal of the logical axis because differentiating a noisy position two times leads to unusable results. Jerk of the logical axis ( fActJerk ) The jerk of the logical axis ( fActJerk ) is either Case 1: Master reference value = Set fSetJerk of the master axis is used for the jerk signal of the logical axis. Case 2: Master reference value = Actual The value 0 is used for the jerk signal of the logical axis because differentiating a noisy position signal three times leads to unusable results. No dead time compensation is performed for the acceleration and jerk signal. All set values (position, velocity, acceleration, and jerk) of the logical axis correspond to the actual values. Write values Writes the values of Input data filters and Time offset on the PLC. Identification ID Unique ID of the logical axis Online Requirement: The PLC is in online mode. Variable table List of drive variables with variable name, Set value and Current value Status Display of the current status of the SoftMotion drive Communication Settings Display of the current communication status Error Axis error FB error uiDriveInterfaceError strDriveInterfaceError " }, 
{ "title" : "Tab: Encoder ", 
"url" : "_sm_edt_drive_free_encoder_general.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Drives \/ User Interface \/ SoftMotion Drives \/ Tab: Encoder ", 
"snippet" : "General encoder settings Modulo In a modulo drive, this option has to be activated and a Modulo value specified. : The drive turns endlessly without limiting the traversing range (example: belt drive). The Modulo settings window is displayed: Modulo value : Input field for the modulo value The value...", 
"body" : "General encoder settings Modulo In a modulo drive, this option has to be activated and a Modulo value specified. : The drive turns endlessly without limiting the traversing range (example: belt drive). The Modulo settings window is displayed: Modulo value : Input field for the modulo value The value is saved in the fPositionPeriod parameter of the AXIS_REF_SM3 function block. Note: If you select the Modulo drive type, then the product fPositionPeriod * dwRatioTechUnitsDenom has to be an integer. Finite : The drive is limited. Bit width List box for an appropriate bit width Scaling Definition of the conversion of the integer positional values that are sent by the device; in increments and technical units that are used in an IEC application. Invert direction : The encoder receives the specified values with inversed signs and therefore rotates in the opposite direction of rotation. increments < = > encoder rotations Number of increments which correspond to the number of complete encoder rotations encoder rotations <=> units in application Number of encoder turns which correspond to units in application Online Requirement: The PLC is in online mode. Variable table List of drive variables with variable name, Set value and Current value Status Display of the current status of the SoftMotion drive Communication Settings Display of the current communication status Error Axis error FB error uiDriveInterfaceError strDriveInterfaceError " }, 
{ "title" : "CODESYS Softmotion Basic ", 
"url" : "_sm_basic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Overview ", 
"url" : "_sm_overview_basic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Overview ", 
"snippet" : "CODESYS Softmotion Basic provides an interface for function blocks for motion control of individual axes. This interface is based on the PLCopen specification \"Function blocks for motion control Part 1 V2.0\". Trajectory planning is done in the CODESYS controller. The range of functions extends from ...", 
"body" : "CODESYS Softmotion Basic provides an interface for function blocks for motion control of individual axes. This interface is based on the PLCopen specification \"Function blocks for motion control Part 1 V2.0\". Trajectory planning is done in the CODESYS controller. The range of functions extends from the movement to a target position or velocity, to superimposing two movements and synchronized movements, to via virtual gears and cams. Motion commands can be buffered and aborted with cycle precision, as well as decelerated or halted and resumed via override. " }, 
{ "title" : "Getting Started with CODESYS Softmotion Basic ", 
"url" : "_sm_basic_first_steps.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Getting Started with CODESYS Softmotion Basic ", 
"snippet" : "To program a movement with CODESYS Softmotion Basic , at least one axis needs to be configured in the device tree. This includes setting the axis type ( modulo or finite ), the velocity ramp type, the software limit switches, and the error reaction. An overview of the supported movement types can be...", 
"body" : "To program a movement with CODESYS Softmotion Basic , at least one axis needs to be configured in the device tree. This includes setting the axis type ( modulo or finite ), the velocity ramp type, the software limit switches, and the error reaction. An overview of the supported movement types can be found in the Single-Axis Movements chapter. For information about how to program a single-axis movement, see the Controlling the Movement of Single Axes chapter. For more information about the basic use of cams, see the Controlling a Cam Drive with a Virtual Time Axis chapter. For information about buffering, blending, and superimposing movements, see the Commanding Multiple Movements section. For more information, see: Overview of CamsChapter: Switching Between CamsCreation of a cam online from the application: Data structures of camsChapter: Dynamic Adaptation with MC_SetOverride" }, 
{ "title" : "Administrative Function Blocks ", 
"url" : "_sm_administrative_fbs.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Administrative Function Blocks ", 
"snippet" : "Administrative function blocks are used to query information or change specific settings. However, they never trigger a movement. A physical drive (referred to as a drive from here on) is represented in CODESYS SoftMotion by the software object AXIS_REF_SM3 (referred to as an axis from here on). Dep...", 
"body" : "Administrative function blocks are used to query information or change specific settings. However, they never trigger a movement. A physical drive (referred to as a drive from here on) is represented in CODESYS SoftMotion by the software object AXIS_REF_SM3 (referred to as an axis from here on). Depending on the administrative function block being used, execution takes place either on the drive, on the axis, or on both. Function Blocks MC_Power Controls the power stage of the drive MC_Reset Resets axis errors and drive errors MC_SetPosition Shifts the coordinate system of the axis to any value; for example, this can be helpful for referencing. SMC3_BrakeControl Controls the mechanical brake when the drive supports this function SMC3_BrakeStatus Reads the current status of the mechanical brake SMC_ChangeDynamicLimits Sets the dynamic limits (velocity, acceleration, deceleration, jerk, and torque) of an axis For more information, see the following: Dynamic limits in Tab: GeneralSMC_ChangeAxisScalingLinear Changes the scaling of a linear axis SMC_ChangeAxisScalingRotary Changes the scaling of a rotary axis SMC_SetForecast Sets the Forecast of an axis SMC_GetForecast Returns the set forecast of the axis SMC_GetTravelTime Returns the time when the axis reaches a specific position. This is especially helpful when combined with Forecast. SMC_SetAdditionalConversionFactors Sets additional factors for the conversion. For example, the factor for torques can be used to take a gearbox into consideration. SMC_SetControllerMode Sets a different operating mode for the axis when the drive supports this function SMC_SetMovementType Sets the movement type of a virtual axis to limited or modulo For more information, see the following: Tab: General. SMC_SetRampType Sets the velocity ramp type of an axis For more information, see the following: Velocity ramp type in the Tab: General chapter SMC_SetSoftwareLimits Sets position limits for limited axes and the corresponding reaction in case of error For more information, see the following: Software limit switches and Software error reaction in the Tab: General chapter MC_TouchProbe Returns the drive position when a defined trigger event is raised MC_AbortTrigger Aborts functions which use trigger events (example: MC_TouchProbe ) SMC_ReadFBError Returns the oldest entry from the function block error memory of the axis. This information can be used for display in a visualization, for example. SMC_ClearFBError Deletes the oldest entry from the function block error memory of the axis. SMC_ReadSetPosition Returns the set position of the axis SMC_ReadSetValues Returns the set position, set velocity, set acceleration, and set jerk. When Forecast is enabled, data can also be queried in the future. For more information, see the following: SMC_SetForecast MC_ReadActualPosition Returns the actual position of the drive MC_ReadActualVelocity Returns the actual velocity of the drive MC_ReadActualTorque Returns the actual torque or the actual force of the drive MC_ReadAxisError Reads the error from the drive MC_ReadStatus Reads the current status of the axis SMC_CheckAxisCommunication Returns the communication state of the axis SMC_CheckLimits Checks whether the current set values exceed the set dynamic limits of the axis For more information, see the following: SMC_ChangeDynamicLimits and Dynamic limits in Tab: GeneralSMC_GetTrackingError Returns the lag of the axis (difference between the set position of the axis and the actual position of the drive) SMC_InPosition Returns whether the lag is within a configurable range SMC_MeasureDistance Returns the distance traveled by the axis since the block was started. This is especially helpful for modulo axes. MC_ReadBoolParameter Reads a Boolean value from the axis or drive MC_ReadParameter Reads a value from the axis or drive MC_WriteBoolParameter Writes a Boolean value to the axis or drive MC_WriteParameter Writes a value to the axis or drive Diagnostic Function Blocks SMC_AxisDiagnosticLog Writes the set values and actual values (position, velocity, and acceleration) of the axis and drive cyclically to a file. This can be helpful for the diagnosis of errors and movement sequences in other tools. SMC_GetMaxSetVelocity Records the maximum value of the set velocity of the axis. This function block can be helpful for diagnostic purposes. SMC_GetMaxSetAccDec Records the maximum value of the set acceleration of the axis. This function block can be helpful for diagnostic purposes. Persist SMC3_PersistPosition Persists the position of an axis with absolute encoder For more information about \"Persist\", see the following: Persisting an Axis PositionSMC3_PersistPositionLogical Persists the position of a logical axis For more information about logical axes, see the following: Logical Drive" }, 
{ "title" : "Single-Axis Movements ", 
"url" : "_sm_basic_single_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Single-Axis Movements ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Overview ", 
"url" : "_sm_overview_single_axis_movement.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Single-Axis Movements \/ Overview ", 
"snippet" : "CODESYS SoftMotion distinguishes between movements which only act on a single axis and movements in which two axes are synchronized (for example, via electronic cams or virtual gears). The latter is described on the Synchronous Movements of Two Axes help page. Basically, the motion blocks which act ...", 
"body" : "CODESYS SoftMotion distinguishes between movements which only act on a single axis and movements in which two axes are synchronized (for example, via electronic cams or virtual gears). The latter is described on the Synchronous Movements of Two Axes help page. Basically, the motion blocks which act only on a single axis can be subdivided into the following categories: Motion Blocks Function Block Description MC_MoveAbsolute Executes a movement to the specified position MC_MoveRelative Executes a movement by the specified distance relative to the current position MC_MoveAdditive Executes a movement by the specified distance relative to the last commanded target position of another movement (for example, from MC_MoveAbsolute ) MC_MoveSuperimposed Executes a movement by the specified relative distance in addition to another active movement (for example, from MC_MoveAbsolute ). The active movement is not aborted. MC_MoveVelocity Executes a continuously running movement at the specified velocity SMC_MoveContinuousAbsolute Executes a movement to the specified position. In this case, the target position is reached at a defined velocity which is maintained afterwards. SMC_MoveContinuousRelative Executes a movement by the specified distance relative to the current position. In this case, the target position is reached at a defined velocity which is maintained afterwards. MC_Jog Executes a continuously running movement at the specified velocity as long as the axis should move forwards or backwards SMC_Inch Executes a movement by the specified distance relative to the current position as long as the axis should move forwards or backwards Halting of movements Function Block Description MC_Halt Executes a controlled stop, interrupts any active movement, and brings the axis to a standstill. MC_Halt is intended for normal operating conditions because the stop can be interrupted by new movements. In addition, operation can be resumed more easily after a stop because the axis remains in an operational state. MC_Stop Executes a controlled stop, interrupts any active movement, and brings the axis to a standstill. MC_Stop is intended for emergency situations because the stop cannot be interrupted by new movements. After the stop has been made, the axis is in a stop state so that no new movements are accepted. New movements are only possible again after the stop has been completed and the Execute input is set to FALSE . MC_HaltSuperImposed Executes a controlled stop of SuperImposed movements. The underlying movement is not aborted in the process Homing Function Block Description MC_Home Starts a homing of the axis controlled by the drive. The operation and its parameters depend on the drive and the manufacturer. SMC_Homing Starts a homing of the axis controlled by the controller MC_SetPosition Does not move the axis, but only shifts the zero point. In this way, the block can be used for referencing, for example. Moreover, the block can also be called during an active movement. Special movements Function Block Description SMC_FollowPosition Writes the set position of the axis. This can be used to pass your own calculated trajectories to the axis. SMC_FollowVelocity Writes the set velocity of the axis. This can be used to pass your own calculated trajectories to the axis. SMC_FollowPositionVelocity Writes the set position and velocity of the axis. This can be used to pass your own calculated trajectories to the axis. SMC_FollowSetValues Selectively writes the set position, velocity, acceleration, jerk, and\/or the set target torque of the axis. This can be used to pass your own calculated trajectories to the axis. SMC_SetTorque Writes the set torque of the axis. Depending on the operating mode of the axis, the value is used either for torque feed forward control or as the torque which the axis is supposed to apply. " }, 
{ "title" : "Interruption of Movements ", 
"url" : "_sm_interrupt_single_axis_movement.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Single-Axis Movements \/ Interruption of Movements ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Interruption of single-axis movements ", 
"url" : "_sm_interrupt_single_axis_movement.html#UUID-1984849b-9835-f096-d6a5-a51b59ed2387_section-idm234855926060424", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Single-Axis Movements \/ Interruption of Movements \/ Interruption of single-axis movements ", 
"snippet" : "Single-axis movements, such as MC_MoveAbsolute , can be interrupted at any time by other movements. This can be a movement to a different position or a change in maximum velocity, acceleration, or jerk with the same type of movement and to the same position. The interruption is implemented in such a...", 
"body" : "Single-axis movements, such as MC_MoveAbsolute , can be interrupted at any time by other movements. This can be a movement to a different position or a change in maximum velocity, acceleration, or jerk with the same type of movement and to the same position. The interruption is implemented in such a way that there is no jump in velocity. For all quadratic ramp types, there is also no jump in the acceleration. In specific cases, a reversal of the axis is unavoidable due to the aborted movement: If the new target position of an MC_MoveAbsolute exists before the end of the current deceleration distance If a smaller maximum deceleration and\/or a smaller maximum jerk is used for the aborted movement, which in turn extends the deceleration distance beyond the target position If SMC_MoveContinuousAbsolute or SMC_MoveContinuousRelative is used with an EndVelocity which cannot be reached from the current axis state without reversal When the ramp types sin² and quadratic (smooth) are used, a reversal can occur during interruption even if it does not appear to be necessary. (That is, even if the reasons listed above do not apply. See explanations below.) Then the new target position could be overtraveled, although it is not located before the old target position. This might happen even if the maximum deceleration and the maximum jerk are not changed (or even increased) and the final velocity is not changed compared to the aborted movement. In this case, the following rules apply: For trapezoid and quadratic ramp types, there is never any overtraveling. For the sin² ramp type, there is no overtraveling when the new target position and the limiting values for acceleration and deceleration are equal to the old values. In all other cases, there may be overtraveling with sin² and quadratic (smooth) ramp types. Explanation for the sin² ramp type: The aborted movement starts with a new sin² velocity ramp, which means that the acceleration starts at 0 and gradually increases or decreases. If the axis has an acceleration not equal to 0 at the time of aborting, then the acceleration jumps to 0 at the start of the sin² velocity ramp. This can lead to overtraveling because increasing or decreasing the acceleration takes time. Explanation for the quadratic (smoothed) ramp type: The same explanation applies as for sin² , but for the jerk instead of the acceleration. Note about override Based on the above explanations, using MC_SetOverride with the sin² and quadratic (smoothed) ramp type is not recommended " }, 
{ "title" : "Interruption during the deceleration phase ", 
"url" : "_sm_interrupt_single_axis_movement.html#UUID-1984849b-9835-f096-d6a5-a51b59ed2387_id_fbc677d73098ed1c0a86463411e7edd_id_b5d8fdf3fc0362bfc0a8658d00b6a52e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Single-Axis Movements \/ Interruption of Movements \/ Interruption during the deceleration phase ", 
"snippet" : "Single-axis movements, such as MC_MoveAbsolute , can be interrupted at any time by other movements. This can be a movement to another position or a change of velocity or acceleration. Basically, the movement is interrupted by another one in such a way that there is no jump in the velocity. For all r...", 
"body" : "Single-axis movements, such as MC_MoveAbsolute , can be interrupted at any time by other movements. This can be a movement to another position or a change of velocity or acceleration. Basically, the movement is interrupted by another one in such a way that there is no jump in the velocity. For all ramp types (except trapezoid ), there is also no jump in the acceleration. When the ramp types sin² and quadratic (smooth) are used, a reversal can occur during interruption and does not appear necessary at first (see explanation). Then the new target position is overtraveled, although it is not located before the old target position. This can occur in the following situations: If a smaller maximum deceleration value is set for the canceling movement than before In this case, the available deceleration distance to the new target position is possibly too short (for all ramp types). Accordingly, for quadratic and quadratic (smooth) ramp types when a lower maximum value is set for jerk However, if these maximum values remain unchanged (or increase), then the following rules apply: For trapezoid and quadratic ramp types, there is never any overtraveling. For the sin² ramp type, there is no overtraveling when the new target position and the limiting values for acceleration and deceleration are equal to the old values. In all other cases, there may be overtraveling with sin² and quadratic (smooth) ramp types. " }, 
{ "title" : "Synchronous Movements of Two Axes ", 
"url" : "_sm_basic_synch_movements_2_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Overview ", 
"url" : "_sm_overview_synch_movements_2_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Overview ", 
"snippet" : "This section provides an overview of movements for which one axis is moved synchronously with another axis (depending on time or position. Cams: Depending on a drive (master), another drive (slave) should execute any kind of defined movements. For more information, see: CamsSynchronization of two ax...", 
"body" : "This section provides an overview of movements for which one axis is moved synchronously with another axis (depending on time or position. Cams: Depending on a drive (master), another drive (slave) should execute any kind of defined movements. For more information, see: CamsSynchronization of two axes with a defined transmission ratio using MC_GearIn , MC_GearOut , and MC_GearInPos . For more information about these functions, see the documentation for the respective function block. Phase offset between a master and slave axis using MC_Phasing . For more information about this function, see the documentation of the function block. Compensation of backlash between mechanical components (for example, in a gearbox) using SMC_BacklashCompensation . For more information about this function, see the documentation of the function block. " }, 
{ "title" : "Cams ", 
"url" : "_sm_f_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Overview ", 
"url" : "_sm_overview_synch_movements_2_axis_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Overview ", 
"snippet" : "The SoftMotion cam is integrated in the user interface of CODESYS . In the cam editor, cams and tappets can be implemented graphically or by means of tables. As soon as code is generated for the corresponding application, global data structures (\"Cam Data\") are created which the IEC program can acce...", 
"body" : "The SoftMotion cam is integrated in the user interface of CODESYS . In the cam editor, cams and tappets can be implemented graphically or by means of tables. As soon as code is generated for the corresponding application, global data structures (\"Cam Data\") are created which the IEC program can access. For this purpose, the SM3_Basic is also automatically linked into the project when inserting a SoftMotion drive. For more information, see: Definition of a and How to create a cam" }, 
{ "title" : "Definition of a SoftMotion Cam ", 
"url" : "_sm_cam_definition_softmotion_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Definition of a SoftMotion Cam ", 
"snippet" : "A cam describes the functional dependency of one drive (slave) on another drive (master). The relationship is described by a continuous function (or curve) that maps a defined range of master values to slave values. To be more precise: After dividing the master axis into suitable segments, the graph...", 
"body" : "A cam describes the functional dependency of one drive (slave) on another drive (master). The relationship is described by a continuous function (or curve) that maps a defined range of master values to slave values. To be more precise: After dividing the master axis into suitable segments, the graph of these functions can be represented on each of these intervals by a line or a 5th degree polynomial. Example The master values are applied to the horizontal axis and the slave values to the vertical axis in the cam graph. In the example, the master values are between 0 and 360. This range is divided into three intervals: (1) First interval: [0, 140] (2) Second interval: [140, 280] (3) Third interval: [280, 360] The function (graph) is linear in the first and third intervals and its graph is displayed as a line. As a result, its first derivative (slope) is constant and all higher derivatives are 0. In the second interval, the graph is described by a 5th degree polynomial. Therefore, its first derivative is a 4th degree polynomial, its second derivative (curvature) is a 3rd degree polynomial, and its third derivative is a 2nd degree polynomial, etc. When the function describes the movement of the slave depending on the position of the master, its first derivative corresponds to the velocity of the slave and the second derivative to its acceleration. When you keep this physical interpretation in mind, it is obvious that the mapping has to be continuous. This means that its graph is not allowed to have any jumps. In particular, the continuity also has to be fulfilled at each point where two intervals meet. Furthermore, the continuity in general is also required by the first and second derivative. (In fact, these three continuity conditions at the start and end points of an interval determine the coefficients of the 5th degree polynomial inserted between two straight segments. Moreover, you may add tappets (binary switches) to the cam at any position. In this way, you can create cam tables which contain tappets only. The slave position is then set to zero over the entire master value range. " }, 
{ "title" : "Overview of Defined Segment Types ", 
"url" : "_sm_overview_segment_types.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Overview of Defined Segment Types ", 
"snippet" : "CODESYS SoftMotion provides various segment types for cams. Depending on the compile format , only some of the segment types are supported: XYVA: Line and Poly5 only. Segments: All segment types are supported. Segment Type Parameters Curve Poly7 Boundary conditions Master position Slave position Sla...", 
"body" : "CODESYS SoftMotion provides various segment types for cams. Depending on the compile format , only some of the segment types are supported: XYVA: Line and Poly5 only. Segments: All segment types are supported. Segment Type Parameters Curve Poly7 Boundary conditions Master position Slave position Slave velocity Slave acceleration Slave jerk Poly5 Boundary conditions Master position Slave position Slave velocity Slave acceleration ModifiedSine Boundary conditions Master position Slave position Slave velocity Segment parameters Either inflection point parameter λ (0≤λ≤1) Or acceleration parameter C a * (maximum deceleration) Line Boundary conditions Master position Slave position InclinedSine Boundary conditions Master position Slave position The selection of the segment type depends on the application because each type has special dynamic properties. There are various applicable segment types depending on the movement task (for example, dwell – constant velocity). The following table provides an overview: Dwell (v=0, a=0) Constant velocity (v­­≠0, a=0) Reversal (v=0, a≠0) Movement (v≠0, a≠0) Dwell (v=0, a=0) Line Poly5\/7 InclinedSine ModifiedSine Poly5\/7 ModifiedSine Poly5\/7 Poly5\/7 Constant velocity (v≠0, a=0) Poly5\/7 ModifiedSine Line Poly5\/7 ModifiedSine Poly5\/7 Poly5\/7 Reversal (v=0, a≠0) Poly5\/7 Poly5\/7 Poly5\/7 Poly5\/7 Movement (v≠0, a≠0) Poly5\/7 Poly5\/7 Poly5\/7 Poly5\/7 " }, 
{ "title" : "Structure of the Cam Editor ", 
"url" : "_sm_cam_editor_layout.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Structure of the Cam Editor ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Overview ", 
"url" : "_sm_overview_synch_movements_2_axis_cam_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Structure of the Cam Editor \/ Overview ", 
"snippet" : "Open the cam editor by double-clicking the Cam object in the device tree. The editor consists of the following tabs: Tab: Cam tab: In this editor, you use a graphical editor to create a cam path. Here, you can display and modify the slave position, slave velocity, slave acceleration, and slave jerk....", 
"body" : "Open the cam editor by double-clicking the Cam object in the device tree. The editor consists of the following tabs: Tab: Cam tab: In this editor, you use a graphical editor to create a cam path. Here, you can display and modify the slave position, slave velocity, slave acceleration, and slave jerk. In the graphical editor, you recognize very quickly when you program a movement with high acceleration. Cam table tab: In this editor, the base points are presented in a table. Here, you can specify the exact positions and velocities. Tappets tab: In this editor, you program the tappets (switch points) in a diagram. This display provides a very good overview of the sequential order of the tappets. Tappet table tab: In this editor, the switch points are presented in a table. Here, you can specify the exact switch points. The tabs are split into an editor, as well as a Toolbox view and Properties view. Program example for using the cam editor " }, 
{ "title" : "Tab: Cam ", 
"url" : "_sm_obj_cam_table_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Structure of the Cam Editor \/ Tab: Cam ", 
"snippet" : "In this graphical editor, the cam graphs are defined. At any time, you can switch between the graphical editor and the alternative tabular editor ( Tab: Cam Table). The curves of four graphs are displayed in the editor: Slave position (black) Slave velocity (blue) Slave acceleration (green) Slave je...", 
"body" : "In this graphical editor, the cam graphs are defined. At any time, you can switch between the graphical editor and the alternative tabular editor ( Tab: Cam Table). The curves of four graphs are displayed in the editor: Slave position (black) Slave velocity (blue) Slave acceleration (green) Slave jerk (yellow) The horizontal axis of all four coordinate systems shows the range of the master values ([0,360]). The vertical axis in the position diagram shows the value range that is defined in the cam properties. The vertical axis of velocity, acceleration, and jerk is scaled automatically. A new inserted cam is assigned with default values. It consists of four points that subdivide the graph into three sections: [0,120], [120,240], and [240,360]. Each of the interval parts of the cam graphs is type Poly5 (5th degree polynomial). You can modify all curves. As velocity, acceleration, and jerk are derived curves, changes to one graph causes changes to the other graphs. You change the height of the diagram by moving the horizontal separation bars. View: Toolbox Select Select a line in the table by using this tool. Selected points are deleted by pressing the Del key. Add point Add new points with this tool. Click the insertion point in the diagram. The graph is then adapted automatically so that its curve runs through the new inserted point. View: Properties X X-position of the slave axis Y Y-position of the slave axis V Velocity of the slave axis A Acceleration of the slave axis J Jerk of the slave axis For more information, see: Dialog: Properties – Cam and How to create a cam" }, 
{ "title" : "Tab: Cam Table ", 
"url" : "_sm_obj_cam_table_cam_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Structure of the Cam Editor \/ Tab: Cam Table ", 
"snippet" : "As an alternative to the graphical editor, you can also define the cam graphs In the cam table ( Cam tab). You can switch between the tabular editor and the graphical editor at any time. The first line of the table always contains the start position of the master (and the related slave values) and t...", 
"body" : "As an alternative to the graphical editor, you can also define the cam graphs In the cam table ( Cam tab). You can switch between the tabular editor and the graphical editor at any time. The first line of the table always contains the start position of the master (and the related slave values) and the last line is always the end position. The lines in-between alternately define segments and points. Inserts a new line Deletes the selected segment X X-position of the slave axis Y Y-position of the slave axis V Velocity of the slave axis A Acceleration of the slave axis J Jerk of the slave axis Segment type Line : Line Poly5 : 5th degree polynomial Poly7 : 7th degree polynomial InclinedSine : Inclined sine line ModifiedSine : Modified sine line Lambda Inflection point parameters for the modified sine line Acceleration parameters Maximum delay parameters for the modified sine line The following values result from the values of the respective segment. They cannot be modified. min(Position) Minimum value of the slave position max(Position) Maximum value of the slave position max(Velocity) Maximum value of the velocity of the slave, based on the master axis max(Acceleration) Maximum value of the acceleration of the slave, based on the master axis View: Toolbox Select Select a line in the table by using this tool. Selected points are deleted by pressing the Del key. For more information, see: Dialog: Properties – Cam and How to create a cam" }, 
{ "title" : "Tab: Tappets ", 
"url" : "_sm_obj_cam_table_tappets.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Structure of the Cam Editor \/ Tab: Tappets ", 
"snippet" : "In this graphical editor, the tappet paths are defined. A tappet path defines one or more tappets depending on the master position. At the upper edge of the editor window, a horizontal axis approaches the range of the master positions. The individual tappet paths follow below. At any time, you can s...", 
"body" : "In this graphical editor, the tappet paths are defined. A tappet path defines one or more tappets depending on the master position. At the upper edge of the editor window, a horizontal axis approaches the range of the master positions. The individual tappet paths follow below. At any time, you can switch between the graphical editor and the alternative tabular editor ( Tab: Tappet Table). \"Track ID\" of the tappet path All tappets of a tappet path refer to the same tappet switch (a variable of type BOOL). View: Toolbox Select Use this tool to select the tappets. You can drag the selected tappets to another position. You can modify the switch on\/off attribute of a tappet by clicking the relevant end of the crossed line. Delete the selected tappet by pressing the Del key. Add new tappets with this tool. Click the insertion point in the path. View: Properties The tappet is assigned to a result, if it is passed from the position of the master axis in the positive (increasing master values) or negative direction. X Position of the tappet Positive pass Switch on\/off attribute No action Switch to ON Switch to OFF Invert Negative pass Switch on\/off attribute No action Switch to ON Switch to OFF Invert Table of the possible combinations of tappet attributes Tappet Symbol Positive pass Negative pass No action No action Switch to ON No action Switch to OFF No action No action Switch to ON No action Switch to OFF Switch to ON Switch to OFF Switch to ON Switch to OFF Switch to OFF Switch to ON Switch to OFF Switch to OFF Invert No action No action Invert Switch to ON Invert Invert Switch to ON Invert Switch to OFF Switch to OFF Invert Invert Invert For more information, see: How to define switch points" }, 
{ "title" : "Tab: Tappet Table ", 
"url" : "_sm_obj_cam_table_tappet_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Structure of the Cam Editor \/ Tab: Tappet Table ", 
"snippet" : "In this tabular table, you can also configure the tappet paths as an alternative to the graphical editor ( Tab: Tappets). A tappet path defines one or more tappets depending on the master position. In the table, the lines with the definitions of the respective tappets are listed below each line that...", 
"body" : "In this tabular table, you can also configure the tappet paths as an alternative to the graphical editor ( Tab: Tappets). A tappet path defines one or more tappets depending on the master position. In the table, the lines with the definitions of the respective tappets are listed below each line that defines a tappet path. You can switch between the tabular editor and the graphical editor at any time. Inserts a new tappet Deletes the tappet Track ID ID of the tappet path All tappets of a tappet path refer to the same tappet switch (a variable of type BOOL). X Position of the tappet Positive pass Switch on\/off attribute No action Switch to ON Switch to OFF Invert Negative pass Switch on\/off attribute No action Switch to ON Switch to OFF Invert View: Properties The tappet is assigned to a result, if it is passed from the position of the master axis in the positive (increasing master values) or negative direction. X Position of the tappet Positive pass Switch on\/off attribute No action Switch to ON Switch to OFF Invert Negative pass Switch on\/off attribute No action Switch to ON Switch to OFF Invert For more information, see: How to define switch points" }, 
{ "title" : "How to create a cam ", 
"url" : "_sm_cam_creating_a_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ How to create a cam ", 
"snippet" : "The steps for creating a cam are explained by means of a sample application that describes a rotary table with eight slots (45° division). Inside, there is a component that is fused ultrasonically. The welding tool is fed in by a linear drive after the rotary table has turned. After welding, the lin...", 
"body" : "The steps for creating a cam are explained by means of a sample application that describes a rotary table with eight slots (45° division). Inside, there is a component that is fused ultrasonically. The welding tool is fed in by a linear drive after the rotary table has turned. After welding, the linear axis returns and the rotary table continues turning. Work steps Rotary table turns 45° (duration: 400 ms). The welding head is moved down by a vertical axis of 250 mm (duration: 200 ms). Start welding (duration: 1200 ms). The welding head is moved up by a vertical axis of 250 mm (duration: 200 ms). A cycle time of 2000 ms results from total times. The application is implemented by means of a virtual master axis that runs continuously (modulo). The end value of the axis is projected according to the cycle time of 2000 ms. The rotary table is achieved as a cam (modulo; end value: 45°). The vertical axis is also achieved as a cam (restricted; end value: 300 mm). The welding process is controlled by a tappet. Setting the properties of the cam Select the Rotary table cam in the device tree. Click Properties in the View menu or in the context menu. Select the Cam tab. Specify the following values: Master start position : 0 Master end position : 2000 Slave start position : 0 Slave end position : 45 Smooth transition : (disabled) Click OK to exit the dialog. Confirm the dialog for changing the cam object. Change the values for the Vertical axis cam in the same way: Master start position : 0 Master end position : 2000 Slave start position : 0 Slave end position : 300 Smooth transition : (enabled) Click OK to exit the dialog. Confirm the dialog for changing the cam object. " }, 
{ "title" : "Adding a cam to the device tree ", 
"url" : "_sm_cam_creating_a_cam.html#UUID-7c227a8f-47be-4a95-ca96-f0cd1d78635d_id_edb85f246cc9d9f4c0a8646368ed3bd6_id_fa86c256038b2152c0a864632d864483", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ How to create a cam \/ Adding a cam to the device tree ", 
"snippet" : "Requirement: A SoftMotion controller is selected. In the device tree, select the Application object. Click Project → Add Object → Cam Table . Specify the name Rotary table for the cam and click OK . The object is inserted into the device tree. The cam editor opens. Insert another cam named Vertical ...", 
"body" : "Requirement: A SoftMotion controller is selected. In the device tree, select the Application object. Click Project → Add Object → Cam Table . Specify the name Rotary table for the cam and click OK . The object is inserted into the device tree. The cam editor opens. Insert another cam named Vertical axis . " }, 
{ "title" : "How to change the cam path ", 
"url" : "_sm_cam_changing_the_course.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ How to change the cam path ", 
"snippet" : "These instructions use the example from the How to create a cam chapter to demonstrate how to change a cam....", 
"body" : "These instructions use the example from the How to create a cam chapter to demonstrate how to change a cam. " }, 
{ "title" : "Changing the path with the graphical editor ", 
"url" : "_sm_cam_changing_the_course.html#UUID-709e6439-f0d2-35ec-865b-a7484c34883c_id_c04b066ccb6844c0a8646367ecded3_id_0e7e8ac72c554f26c0a86463347ccca5", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ How to change the cam path \/ Changing the path with the graphical editor ", 
"snippet" : "Open the Rotary table cam in the editor. The Cam tab is visible. Select the point at 120 and delete it by pressing the delete key ( Del ). Also delete the point at 240. Select the Add point tool from the Toolbox view. The mouse pointer turns into cross hairs when you move it into the editor. Click n...", 
"body" : "Open the Rotary table cam in the editor. The Cam tab is visible. Select the point at 120 and delete it by pressing the delete key ( Del ). Also delete the point at 240. Select the Add point tool from the Toolbox view. The mouse pointer turns into cross hairs when you move it into the editor. Click near Master position 400 and Slave position 45 in the upper graphs (slave position). The curve of the slave position is changed. The curves of velocity, acceleration, and jerk also change. Select the new inserted point by clicking it. Drag the point to another position. The curve of the slave position is adjusted accordingly. Change the X and Y properties to the exact values of 400 and 45, respectively. In the same way, change the X-value to 45 of the point at master position 2000. Select the Select tool from the Toolbox view. Select the second curve element (between 400 and 2000). Change the Segment type property to Line . Check the curve in the graphical editor. Representation: " }, 
{ "title" : "Changing the path with a cam table ", 
"url" : "_sm_cam_changing_the_course.html#UUID-709e6439-f0d2-35ec-865b-a7484c34883c_id_c04b066ccb6844c0a8646367ecded3_id_a888a2ff556a11e6abf6d2d0503b3e46", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ How to change the cam path \/ Changing the path with a cam table ", 
"snippet" : "Open the Vertical axis cam in the editor. The Cam tab is visible. Select the Cam table tab. Click the symbol to delete the point at 120. Also delete the point at 240. Click the symbol. A new point and a new segment are inserted at (1000\/150). Add two more points. Change the values X \/ Y of the follo...", 
"body" : "Open the Vertical axis cam in the editor. The Cam tab is visible. Select the Cam table tab. Click the symbol to delete the point at 120. Also delete the point at 240. Click the symbol. A new point and a new segment are inserted at (1000\/150). Add two more points. Change the values X \/ Y of the following points: Point 1: 0 \/ 0 Point 2: 400 \/ 0 Point 3: 600 \/ 250 Point 4: 1800 \/ 250 Point 5: 2000 \/ 0 The curve of the slave position is changed. The curves of velocity, acceleration, and jerk also change. In the cam table, change the Segment type of the first and third segments to Line . Check the curve in the graphical editor. Representation: In practice, the curves of the different cams are defined frequently as overlapping in order to save on cycle time. In the example above, the vertical axis could already begin the movement while the rotary table is still in motion (for example, at X: 350). " }, 
{ "title" : "How to define switch points ", 
"url" : "_sm_cam_defining_tappets.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ How to define switch points ", 
"snippet" : "Use switch points to trigger events depending on the master position. For example, this can be the setting of an output or the calling of a function block. These instructions use the example from the How to create a cam chapter to demonstrate how to define switch points. In this example, the tappet ...", 
"body" : "Use switch points to trigger events depending on the master position. For example, this can be the setting of an output or the calling of a function block. These instructions use the example from the How to create a cam chapter to demonstrate how to define switch points. In this example, the tappet starts and stops the welding process. Open the Vertical axis cam in the editor. The Cam tab is visible. Select the Tab: Tappets. In the Toolbox view, select the Add tappet tool. The mouse pointer turns into cross hairs when you move it into the editor. Click below the master position near position 600. A tappet is inserted to the tappet path 1. Select the tappet. Change the values of the tappet in the \"Properties\" view. X : 600 Positiver pass : Switch ON Negative pass : No action Insert another tappet to tappet path 1 at X: 1800. X : 1800 Positiver pass : Switch OFF Negative pass : No action Check the result. You can also change the values for Positive pass and Negative pass by clicking the respective end of the crosshairs. Note that you can also set the switch points on the Tappet table tab. This editor provides you with the same options, but in tabular form. " }, 
{ "title" : "Creating Cams Programmatically ", 
"url" : "_sm_basic_cam_programmatic_creation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Creating Cams Programmatically ", 
"snippet" : "As of CODESYS SoftMotion version 4.17.0.0, the CamBuilder function block provides an interface for creating cams programmatically directly in the IEC application. For more information, see the example: Creating Cams Programmatically...", 
"body" : "As of CODESYS SoftMotion version 4.17.0.0, the CamBuilder function block provides an interface for creating cams programmatically directly in the IEC application. For more information, see the example: Creating Cams Programmatically" }, 
{ "title" : "Using the CamBuilder function block (as of SM 4.17.0.0) ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm4552813176932834337885510319", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Creating Cams Programmatically \/ Using the CamBuilder function block (as of SM 4.17.0.0) ", 
"snippet" : "The following cam is created by default when a cam object is created in the device tree: The cam consists of three fifth-degree polynomials with the following four boundary values: X Y V A 0 0 0 0 120 120 1 0 240 240 1 0 360 360 0 0 To create this cam programmatically, an instance of the CamBuilder ...", 
"body" : "The following cam is created by default when a cam object is created in the device tree: The cam consists of three fifth-degree polynomials with the following four boundary values: X Y V A 0 0 0 0 120 120 1 0 240 240 1 0 360 360 0 0 To create this cam programmatically, an instance of the CamBuilder function block is first declared: VAR\n camBuilder : SMCB.CamBuilder;\nEND_VAR In the implementation part, the CamBuilder instance first has to be initialized. Three segments of type Poly5 can then be added using the Append method: camBuilder.Init();\n \ncamBuilder.Append(\n SMCB.Poly5(\n\tSMCB.BoundImplicit(),\n\tSMCB.Bound(120, 120, 1)));\ncamBuilder.Append(\n SMCB.Poly5(\n\tSMCB.BoundImplicit(),\n\tSMCB.Bound(240, 240, 1)));\ncamBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.Bound(360, 360))); The polynomials are defined via the left and right boundary conditions. In the example, the BoundImplicit function is always used for the left boundary. As a result, the right boundary condition of the previous segment is applied. If the BoundImplicit function is used as the left boundary for the first segment, then it starts at zero: in this example, with Poly5 segment at (X, Y, V, A) = (0, 0, 0, 0). When the MC_CamTableSelect and MC_CamIn function blocks are used, the cam defined in the CamBuilder function block finally has to be converted into an MC_CamRef . There are two ways to do this, depending on where the CamBuilder is called: Calling the CamBuilder in the bus task: First, the declaration part must be extended by the corresponding instances: VAR\n    ...\n    camRef : MC_CAM_REF;\n    aCamSegments : ARRAY[1..3] OF SMC_CAM_SEGMENT;\nEND_VAR Then the function block instance MC_CAM_REF is initialized and written using the Write method of the CamBuilder function block. SMCB.InitCamRef(camRef, ADR(aCamSegments), XSIZEOF(aCamSegments));\ncamBuilder.Write(camRef); Calling the CamBuilder in another task (multitask, multicore): First, a multitask\/multicore-safe instance of the cam is created in a GVL, which is accessed by both the bus task and the CamBuilder task. VAR_GLOBAL\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\nEND_VAR Then the creation of the cam in the other task is started from the bus task. To determine in the bus task when the new cam was written in the other task, the program remembers the CamId in STATE_INIT_ONLINE_TABLE_MULTITASK before the cam is created. Then the creation of the cam is started in the other task in the STATE_START_CREATE_ONLINE_TABLE_MULTITASK state. Then, the created cam is read in the STATE_READ_ONLINE_TABLE_MULTITASK state. PROGRAM BUS_TASK\nVAR\n    state : UDINT;\n    error : SMC_ERROR;\n    camIdBeforeCreate : UDINT;\n    camSegments: ARRAY[0..99] OF SMC_CAM_SEGMENT;\n    camRef: MC_CAM_REF;\nEND_VAR\nVAR CONSTANT\n    STATE_INIT_ONLINE_TABLE_MULTITASK : UDINT := 0;\n    STATE_START_CREATE_ONLINE_TABLE_MULTITASK : UDINT := 10;\n    STATE_READ_ONLINE_TABLE_MULTITASK : UDINT := 20;\n    STATE_ERROR : UDINT := 1000;\nEND_VAR\n\n\nCASE state OF\nSTATE_INIT_ONLINE_TABLE_MULTITASK:\n    camIdBeforeCreate := GVL.safeCam.CamId;\n\n    state := STATE_START_CREATE_ONLINE_TABLE_MULTITASK;\n\nSTATE_START_CREATE_ONLINE_TABLE_MULTITASK:\n    CamBuilderTask.BuildCam := TRUE;\n\n    state := STATE_READ_ONLINE_TABLE_MULTITASK;\n\nSTATE_READ_ONLINE_TABLE_MULTITASK:\n    IF CamBuilderTask.Error THEN\n        error := CamBuilderTask.ErrorId;\n        state := state + STATE_ERROR;\n    ELSIF GVL.safeCam.CamId <> camIdBeforeCreate THEN\n        error := GVL.safeCam.GetCopy(\n            camRef:= camRef,\n            pCamSegments:= ADR(camSegments),\n            arraySize:= XSIZEOF(camSegments));\n\n        IF error = SMC_NO_ERROR THEN\n            state := state + 10;\n        ELSE\n            state := state + STATE_ERROR;\n        END_IF\n    END_IF\nEND_CASE In the CamBuilder task, the multitask\/multicore-safe cam is written by calling CamBuilder.WriteMulticoreSafe() : PROGRAM CamBuilderTask\nVAR_INPUT\n    BuildCam : BOOL;\nEND_VAR\nVAR_OUTPUT\n    Error : BOOL;\n    ErrorId : SMC_ERROR;\nEND_VAR\nVAR\n    camBuilder : SMCB.CamBuilder;\nEND_VAR\n\nIF BuildCam THEN\n    BuildCam := FALSE;\n\n    camBuilder.Init();\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(120, 120, 1)));\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(240, 240, 1)));\n    camBuilder.Append(SMCB.Poly5(SMCB.BoundImplicit(), SMCB.Bound(360, 360)));\n     \n Error := camBuilder.IsErrorPending(errorID=> ErrorId);\n\n    IF NOT Error THEN\n        ErrorId := camBuilder.WriteMulticoreSafe(GVL.safeCam);\n        Error := ErrorId <> SMC_NO_ERROR;\n    END_IF\nEND_IF " }, 
{ "title" : "Implicit and explicit boundary conditions ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433930557874", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Creating Cams Programmatically \/ Using the CamBuilder function block (as of SM 4.17.0.0) \/ Implicit and explicit boundary conditions ", 
"snippet" : "An implicit boundary condition defined with BoundImplicit makes sure that the transition to the adjacent segment is as smooth as possible. To do this, the boundary condition of the adjacent segment needs to be explicitly defined using the Bound method. So if the left boundary condition of a segment ...", 
"body" : "An implicit boundary condition defined with BoundImplicit makes sure that the transition to the adjacent segment is as smooth as possible. To do this, the boundary condition of the adjacent segment needs to be explicitly defined using the Bound method. So if the left boundary condition of a segment is implicit, then the right boundary condition of the previous segment has to be explicit. Conversely, if the right boundary condition is implicit, then the left boundary condition of the subsequent segment has to be explicit. The most common use case is presumably that only the right boundary conditions of the segments are explicitly specified, as in the example above. Due to the implicit left boundary conditions, the segment transitions are automatically as smooth as possible and there are no gaps in the definition area. The following example is a simple case where it is helpful to deviate from this approach: The slave axis should travel at a constant velocity from position 20 to 100: camBuilder.Append(\n SMCB.Line(\n SMCB.Bound(20, 20),\n SMCB.Bound(100, 100))); Before and after this, a Poly5 segment is used for acceleration and deceleration: camBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.BoundImplicit()));\ncamBuilder.Append(\n SMCB.Line(\n SMCB.Bound(20, 20),\n SMCB.Bound(100, 100)));\ncamBuilder.Append(\n SMCB.Poly5(\n SMCB.BoundImplicit(),\n SMCB.Bound(120, 120, 0))); The cam defined in this way has unwanted acceleration and deceleration phases in the Poly5 segments (velocity in blue): To avoid this, it is sufficient to adjust the master position in the segment of type Line (for example, that of the left boundary from 20 to 30 and that of the right boundary from 100 to 90): ...\ncamBuilder.Append(\n SMCB.Line(\n SMCB.Bound(30, 20),\n SMCB.Bound(90, 100)));\n... It is not necessary to adjust the segments of type Poly5 because they are automatically added to the line segment as smoothly as possible due to the boundary conditions defined using the BoundImplicit function. " }, 
{ "title" : "Error Handling ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433930649954", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Creating Cams Programmatically \/ Using the CamBuilder function block (as of SM 4.17.0.0) \/ Error Handling ", 
"snippet" : "The Append method of the CamBuilder function block returns TRUE when a segment has been successfully added, and returns FALSE if an error has occurred. After an error, no more segments can be added and the CamBuilder function block has to be reinitialized using the Init method. The cause of the erro...", 
"body" : "The Append method of the CamBuilder function block returns TRUE when a segment has been successfully added, and returns FALSE if an error has occurred. After an error, no more segments can be added and the CamBuilder function block has to be reinitialized using the Init method. The cause of the error can be determined using the IsErrorPending method: camBuilder.IsErrorPending(errorId=> errorId); " }, 
{ "title" : "Manual creation of the data structure MC_CAM_REF (before SM 4.17.0.0) ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm4565212026644834337937734299", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Creating Cams Programmatically \/ Manual creation of the data structure MC_CAM_REF (before SM 4.17.0.0) ", 
"snippet" : "It is recommended to use the SM3_CamBuilder library as of CODESYS SoftMotion 4.17.0.0....", 
"body" : "It is recommended to use the SM3_CamBuilder library as of CODESYS SoftMotion 4.17.0.0. " }, 
{ "title" : "Data structures of cams ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793858538", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Creating Cams Programmatically \/ Manual creation of the data structure MC_CAM_REF (before SM 4.17.0.0) \/ Data structures of cams ", 
"snippet" : "On project compile, the created cam data is converted internally into a global variable list. By clicking Display generated code in the cam editor, you can display the automatically created global variables. Each cam is represented by the data structure MC_CAM_REF . You can access this data structur...", 
"body" : "On project compile, the created cam data is converted internally into a global variable list. By clicking Display generated code in the cam editor, you can display the automatically created global variables. Each cam is represented by the data structure MC_CAM_REF . You can access this data structure by means of the IEC program or by preprocessing functions and function blocks. It is available by the SM3_Basic library. A function block that describes a cam can also be generated or populated by the IEC program at runtime. Example Definition of the data structure: TYPE mySMC_CAMTable_LREAL_10000_2 :\nSTRUCT\n Table: ARRAY[0..9999] OF ARRAY[0..1] OF LREAL;\n (* set all scaling definitions to 0 and 1\n result: all values of the table are not scaled *)\n fEditorMasterMin: REAL := 0;\n fEditorMasterMax: REAL := 1;\n fEditorSlaveMin: REAL := 0;\n fEditorSlaveMax: REAL := 1;\n fTableMasterMin: REAL := 0;\n fTableMasterMax: REAL := 1;\n fTableSlaveMin: REAL := 0;\n fTableSlaveMax: REAL := 1;\nEND_STRUCT\nEND_TYPE Instantiating the data structure: Cam: MC_CAM_REF;\nCam_PointArray : mySMC_CAMTable_LREAL_10000_2; Calculating the cam: Cam.byType:=2;\nCam.byVarType:=6;\nCam.nTappets:=0;\nCam.strCAMName:='myCAM';\nCam.pce:= ADR(CAM_PointArray);\nFOR i:=0 TO 9999 DO\n (* example cam: master 0..360, slave 0..100,\n constant velocity *)\n Cam_PointArray.Table[i][0]:=UDINT_TO_LREAL(I)\/10000 * 360; (* X *)\n Cam_PointArray.Table[i][1]:=UDINT_TO_LREAL(I)\/10000 * 100; (* Y *)\nEND_FOR\nCam.nElements:=10000\nCam.xStart:=0.0;\nCam.xEnd:=360.0; " }, 
{ "title" : "Manually generated cams ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793936406", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Creating Cams Programmatically \/ Manual creation of the data structure MC_CAM_REF (before SM 4.17.0.0) \/ Manually generated cams ", 
"snippet" : "A cam can be created in an IEC program without using the cam editor. Example Declaration: VAR i: INT; CAM: MC_CAM_REF := ( byType:=2, (* non-equidistant *) byVarType:=2, (* UINT *) nElements:=128, xStart:=0, xEnd:=360); Table: SMC_CAMTable_UINT_128_2 := ( fEditorMasterMin := 0, fEditorMasterMax := 3...", 
"body" : "A cam can be created in an IEC program without using the cam editor. Example Declaration: VAR\ni: INT;\nCAM: MC_CAM_REF := (\n byType:=2, (* non-equidistant *)\n byVarType:=2, (* UINT *)\n nElements:=128,\n xStart:=0,\n xEnd:=360);\nTable: SMC_CAMTable_UINT_128_2 := (\n fEditorMasterMin := 0, fEditorMasterMax := 360,\n fTableMasterMin := 0, fTableMasterMax := 6000,\n fEditorSlaveMin := 0, fEditorSlaveMax := 360,\n fTableSlaveMin := 0, fTableSlaveMax := 6000);\nEND_VAR Implementation: (* Create cam disk (example straight line); unambiguous *)\nFOR i:=0 TO 127 DO\n Table.Table[i][0] := Table.Table[i][1] := REAL_TO_UINT(i \/ 127.0 * 6000);\nEND_FOR\n(* Link pointer; must be done in every cycle! *)\nCAM.pce := ADR(Table); This generated cam can be specified in the MC_CamTableSelect function block and its output used again for MC_CamIn . " }, 
{ "title" : "Compiling cam definitions ", 
"url" : "_sm_basic_cam_programmatic_creation.html#UUID-327725b5-7947-997b-3347-a113293bee19_section-idm43433793975398", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Creating Cams Programmatically \/ Manual creation of the data structure MC_CAM_REF (before SM 4.17.0.0) \/ Compiling cam definitions ", 
"snippet" : "At compile time, variables of type MC_CAM_REF are created for a cam. They include a description of each segment of the cam. Data structures of this kind are passed to the MC_CamTableSelect function block. The structure is part of the SM3_Basic library....", 
"body" : "At compile time, variables of type MC_CAM_REF are created for a cam. They include a description of each segment of the cam. Data structures of this kind are passed to the MC_CamTableSelect function block. The structure is part of the SM3_Basic library. " }, 
{ "title" : "Switching Between Cams ", 
"url" : "_sm_cam_switch_between_cams.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Switching Between Cams ", 
"snippet" : "In principle, you can switch between different cams at any time. However, you should consider some points: In the cam editor, the position of the slave is defined uniquely as the function value of the cam function. This function is defined in the master value range and can be expressed as follows: S...", 
"body" : "In principle, you can switch between different cams at any time. However, you should consider some points: In the cam editor, the position of the slave is defined uniquely as the function value of the cam function. This function is defined in the master value range and can be expressed as follows: SlavePosition = CAM( MasterPosition ) Because the current position of the master drive usually deviates from the master value range, you need to scale the master position in the definition range of the cam function in order to represent a valid argument: SlavePosition = CAM( MasterScale*MasterPosition + MasterOffset ) In a similar way, you need to scale the function value (the slave position) if the start of the cam in the mode Absolute would lead to a jump: SlavePosition = SlaveScale*CAM( MasterPosition ) + SlaveOffset You may have to apply both scaling values, which results in the following: Slaveposition = SlaveScale*CAM( MasterScale*Masterposition + MasterOffset ) + SlaveOffset The appropriate values for scaling and offset parameters can vary from period to period. Switching between cams can be done in three ways: Start the second cam via a second instance of MC_CamIn with BufferMode = MC_BUFFER_MODE.Buffered , StartMode = relative , MasterAbsolute = FALSE , and SlaveAbsolute = FALSE . As of CODESYS SoftMotion version 4.17.0.0 Start of the new cam by assigning MC_CamIn.CamTableID to the new cam (no restart of the MC_CamIn function block required). This variant is recommended if the following points apply to your use case: All of the following cams should be executed relatively with MasterAbsolute = FALSE or SlaveAbsolute = FALSE . The new cam should start exactly at the end of the previous one. No other parameters are changed (example: SlaveOffset ). The jump, which is explained in the following example for periodic cams and SlaveAbsolute = FALSE , does not apply to this variant because the next cam is placed exactly at the end positions of the previous cam. The new cam is placed exactly at the end of the previous cam only if the switch to the new cam is done in the same cycle when the previous cam reports EndOfProfile = TRUE . Start of the new cam by restarting the MC_CamIn function block. This variant is recommended if parameters have to be changed for the correct function of the new cam (for example, SlaveOffset from the following example). The restrictions of the following example apply. Example In the following example, it switches from CAM1 to CAM2 : CAM1 consists of a 5th order polynomial followed by two line segments. CAM2 consists of two line segments followed by one 5th order polynomial. When switching between both cams, you should consider the following: To prevent jumps, the values of velocity and acceleration at the end point of the first cam should agree with the values at the starting point of the second cam. In the example, this condition is fulfilled because the same velocity (=1) and acceleration (=0) is assigned to the end point of CAM1 and the starting point of CAM2 . You can start the second cam in Relative mode when you have defined the start position of the slave as 0. However, the first cam has to be running in non-periodic mode. Otherwise, if CAM1 were periodic, then the Relative setting would result in a jump. The magnification shows the transition from CAM1 to CAM2 . The blue lines mark the evaluations of the cam functions at the master positions x1 and x2 . Now, we will look at the unfavorable case of periodic : MasterAbsolute := TRUE; SlaveAbsolute := FALSE; CAM(x1, CAM1, PERIODIC:=TRUE); The call starts an evaluation of the cam at the master position x1 , which is less than the end position of the master of CAM1 . Then CAM1 is evaluated by default and yields point 1 as the position for the slave. CAM(x2, CAM1, PERIODIC:=TRUE); For the following call of the module, the master position x2 is outside of the master value range of CAM1 , whose limit is marked by the green dashed line and agrees with the horizontal axis of the point 3p . Therefore, the EndOfProfile is set. Because CAM1 was started in periodic mode, its restart occurs at the end of the value range, which finally yields the point 2p as the result of the module call. CAM(EXECUTE:=FALSE); Switch to the new cam CAM(x2, CAM2, PERIODIC:=TRUE); Second evaluation at master position x2 . This time, the new CAM2 is evaluated. After CAM2 is started in Relative mode, the current slave position ( 2p ) is added as offset to the image of the cam function of CAM2 . This moves the starting point of its graph to the point 3p and its evaluation at the master position x2 yields the point 4p , and therefore an unfavorable jump. Select the non-periodic mode in order to prevent jumps: MasterAbsolute := TRUE; SlaveAbsolute := FALSE; CAM(x1, CAM1, PERIODIC:=FALSE); The call starts an evaluation of the cam at the master position x1 , which is less than the end position of the master of CAM1 . Then CAM1 is evaluated by default and yields point 1 as the position for the slave. CAM(x2, CAM1, PERIODIC:=FALSE); For the following call of the module, the master position x2 is outside of the master value range of CAM1 , whose limit is marked by the green dashed line and agrees with the horizontal axis of the point 3n . Therefore, the EndOfProfile is set.  Because CAM1 was started in non-periodic mode, slave position ( 2n ) assigned to master position x2 is identical to the position of the slave upon reaching the end of the value range of CAM1 ( 3n ). CAM(EXECUTE:=FALSE); Switch to new cam. CAM(x2, CAM2, PERIODIC:=FALSE); Second evaluation at master position x2 . This time, the new CAM2 is evaluated. After CAM2 is started in Relative mode, the current slave position ( 2n ) is added as offset to the image of the cam function of CAM2 . This moves the starting point of its graph to the point 3n and its evaluation at the master position x2 yields the point 4n , which is on the specific line through the points 1 and 3n . To start the cam in Absolute mode, you need to make sure that the slave is in an appropriate start position. If the value range of the master agrees with the period of the slave, then switching between cams does not have any complications, regardless of whether the cams are periodic or not. In the example above, you can start CAM2 in Absolute mode when the periods of the master and slave agree with the master value range of CAM2 (each is 360°). If not, for example when the period of the slave is 270° (indicated by the light blue line), then the Absolute option is not permitted without taking additional actions. In this case, the slave is at 90° when switching from CAM1 to CAM2 . Starting CAM2 in Absolute mode causes a jump to 0° (indicated by a gray line). However, the jump can be prevented by setting the slave offset to the appropriate value of 90°. " }, 
{ "title" : "Periodic Cams ", 
"url" : "_sm_basic_periodic_cams.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Periodic Cams ", 
"snippet" : "A cam can be run repeatedly when the Periodic input of the MC_CamTableSelect function block is set to TRUE . Then the cam is restarted automatically after reaching the end position. If this input is FALSE , then the EndOfProfile output variable of the MC_CamIn function block is set to TRUE when the ...", 
"body" : "A cam can be run repeatedly when the Periodic input of the MC_CamTableSelect function block is set to TRUE . Then the cam is restarted automatically after reaching the end position. If this input is FALSE , then the EndOfProfile output variable of the MC_CamIn function block is set to TRUE when the end position of the master is reached. The slave pauses at its current position. Note that the cam activity does not stop after leaving the master value range. When the master drive re-enters the master value range, the slave drive follows the cam plate again. Behavior in the case of Slave.EndPosition <> Slave.StartPosition : The function block MC_CamIn calculates an internal offset at the end of a period. In the subsequent period, the cam is shifted by this offset so that it continues at the current position of the slave and consequently prevents jumps. For a periodic cam, you can activate the Smooth transition option in the cam properties. This is used for preventing jumps from occurring when transitioning from one period to another. Then the slave has the same velocity and acceleration at the end position as at the start position. The period and feed are measured in the units of slave scaling. Even if you do not select the Smooth transition option, the cam can be operated continuously. In this case, your task is to make sure the consistency of the transitions are satisfied to a sufficient degree. " }, 
{ "title" : "Visualization Element: Online Cam Editor ", 
"url" : "_sm_cam_visu_elem_online_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Visualization Element: Online Cam Editor ", 
"snippet" : "The online cam editor is a visualization template that displays a cam in the visualization. With this element, you can modify the cam in online mode. The visualization element is made available in a visualization template ( SMC_VISU_CamEditor ) of the SM3_Basic_Visu library. You find it in the visua...", 
"body" : "The online cam editor is a visualization template that displays a cam in the visualization. With this element, you can modify the cam in online mode. The visualization element is made available in a visualization template ( SMC_VISU_CamEditor ) of the SM3_Basic_Visu library. You find it in the visualization editor in the Toolbox view in the SM3_Basic_Visu tag. The SMC_Visu_CamEditor is inserted into the visualization via a frame. For more information about this visualization element, see: Visualization Element: Frame . In addition to the properties of the frame element, this template contains the following properties: Property Description safeCam Reference to the cam to be edited showPosition Boolean variable for toggling the display of the position curve on and off showVelocity Boolean variable for toggling the display of the velocity curve on and off showAcceleration Boolean variable for toggling the display of the acceleration curve on and off showJerk Boolean variable for toggling the display of the jerk curve on and off showSelectedSegment Boolean variable for toggling the highlighting of the selected segment on and off The cam to be edited is transferred via an instance of the SMCB.CAM_REF_MULTICORE_SAFE function block. PROGRAM PLC_PRG\nVAR\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\nEND_VAR " }, 
{ "title" : "Cam editor in online mode ", 
"url" : "_sm_cam_visu_elem_online_cam.html#UUID-2e587bbc-4adf-7494-0ee4-e771bd15b571_id_ba4cc02c6ccda90bc0a864637badf4e0_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Visualization Element: Online Cam Editor \/ Cam editor in online mode ", 
"snippet" : "In online mode, the individual segments of the cam can be selected in the graph. The segment editor on the right-hand side can be used to add and delete segments, as well as to adapt the boundary conditions of the selected segment. (1) Load Cam Loads the configured cam into the editor (2) Save Cam S...", 
"body" : "In online mode, the individual segments of the cam can be selected in the graph. The segment editor on the right-hand side can be used to add and delete segments, as well as to adapt the boundary conditions of the selected segment. (1) Load Cam Loads the configured cam into the editor (2) Save Cam Saves the edited cam (3) Status bar Displays status messages (4) Segment selection A segment can be selected using the arrows. The segment type can be changed via the list box. (5) Master position The master position on the left and right edge of the segment (6) Slave position The slave position on the left and right edge of the segment. (7) Slave velocity The slave velocity on the left and right edge of the segment. Not editable for all segment types. (8) Slave acceleration The slave acceleration on the left and right edge of the segment. Not editable for all segment types. (9) Slave jerk The slave jerk on the left and right edge of the segment. Not editable for all segment types. (10) Lambda parameter Lambda parameter for the modified sine line. (11) Split Divides the selected segment into two segments. (12) Delete Deletes the selected segment. " }, 
{ "title" : "Using a created cam in the application ", 
"url" : "_sm_cam_visu_elem_online_cam.html#UUID-2e587bbc-4adf-7494-0ee4-e771bd15b571_section-idm234870310600632", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Synchronous Movements of Two Axes \/ Cams \/ Visualization Element: Online Cam Editor \/ Using a created cam in the application ", 
"snippet" : "You can use the cam created with the SMC_Visu_CamEditor visualization element in the application by calling the GetCopy method of the CAM_REF_MULTICORE_SAFE instance. PROGRAM PLC_PRG VAR     safeCam : SMCB.CAM_REF_MULTICORE_SAFE;     camRef : MC_CAM_REF;     camSegments : ARRAY[0..99] OF SMC_CAM_SEG...", 
"body" : "You can use the cam created with the SMC_Visu_CamEditor visualization element in the application by calling the GetCopy method of the CAM_REF_MULTICORE_SAFE instance. PROGRAM PLC_PRG\nVAR\n    safeCam : SMCB.CAM_REF_MULTICORE_SAFE;\n    camRef : MC_CAM_REF;\n    camSegments : ARRAY[0..99] OF SMC_CAM_SEGMENT;\n    error : SMC_ERROR;\nEND_VAR\n\nIF safeCam.CamId <> oldCamId THEN\n     error :=\n         safeCam.GetCopy(\n            camRef:= camRef,\n            pCamSegments:= ADR(camSegments),\n            arraySize:= XSIZEOF(camSegments));\n\n oldCamId := safeCam.CamId;\nEND_IF The program first checks whether a new cam has been created ( CamId <> oldCamID ). If so, then a copy of this cam is created using the GetCopy method. If the call returns SMC_NO_ERROR , then the camRef instance of the MC_CAM_REF function block can be used with the SoftMotion cam function blocks MC_CamTableSelect and MC_CamIn . The GetCopy call is task-safe and therefore does not have to be made from the Visu task. " }, 
{ "title" : "Commanding Multiple Movements ", 
"url" : "_sm_basic_mulitple_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commanding Multiple Movements ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Overview ", 
"url" : "_sm_overview_mulitple_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commanding Multiple Movements \/ Overview ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "BufferMode ", 
"url" : "_sm_overview_mulitple_movements.html#UUID-2f590113-2f84-eead-4ae8-73304891aaa0_section-idm43431844820766", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commanding Multiple Movements \/ Overview \/ BufferMode ", 
"snippet" : "Some function blocks have a BufferMode input which is used to control the chronological order of movements. The buffer mode defines whether the function block works in non-buffered mode (\"Aborting\", standard behavior) or in buffered mode (\"Buffered\"). The difference between these two modes is the ti...", 
"body" : "Some function blocks have a BufferMode input which is used to control the chronological order of movements. The buffer mode defines whether the function block works in non-buffered mode (\"Aborting\", standard behavior) or in buffered mode (\"Buffered\"). The difference between these two modes is the time when they begin their actions: \"Non-buffered Mode\": The movement command is effective immediately, even if this interrupts another movement. The buffer of the commanded movements is deleted. \"Buffered Mode\": The movement command waits until the current function block sets its output Done (or InPosition , or InVelocity , etc.). The buffer modes are also used to define how the velocity curve should look at the transition of the movements. The BufferMode input is an ENUM of type MC_BUFFER_MODE. Aborting Default mode without buffering. The function block starts immediately and aborts an active movement. The command takes immediate effect on the axis. Buffered The function block starts as soon as the last commanded movement is finished. No blending takes place here. The new movement starts at the velocity that the previous movement has when the end condition is reached ( Done , InVelocity , InEndVelocity , InGear , InSync , EndOfProfile , etc.). If the previous movement was MC_MoveAbsolute or MC_MoveRelative , then the new movement starts at standstill. BlendingLow The function block starts as soon as the last commanded movement is finished. The axis does not stop between movements, but passes through the end position of the first movement at the lower velocity of the two movement commands. BlendingPrevious The function block starts as soon as the last commanded movement is finished. The axis does not stop between movements, but passes through the end position of the first movement at the velocity of the first movement command. BlendingNext The function block starts as soon as the last commanded movement is finished. The axis does not stop between movements, but passes through the end position of the first movement at the velocity of the second movement command. BlendingHigh The function block starts as soon as the last commanded movement is finished. The axis does not stop between movements, but passes through the end position of the first movement at the higher velocity of the two movement commands. " }, 
{ "title" : "Supported Function Blocks ", 
"url" : "_sm_overview_mulitple_movements.html#UUID-2f590113-2f84-eead-4ae8-73304891aaa0_section-idm43431844838676", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commanding Multiple Movements \/ Overview \/ BufferMode \/ Supported Function Blocks ", 
"snippet" : "All function blocks that can be specified as buffered\/blending commands have the following inputs and outputs: BufferMode input ( MC_BUFFER_MODE type) Active output: ( BOOL type) A command is accepted when the function block switches to the state Busy after a new movement has been commanded. Functio...", 
"body" : "All function blocks that can be specified as buffered\/blending commands have the following inputs and outputs: BufferMode input ( MC_BUFFER_MODE type) Active output: ( BOOL type) A command is accepted when the function block switches to the state Busy after a new movement has been commanded. Function Block Can be Defined as a Buffered\/Blending Command Can be Followed by a Buffered\/Blending Command Relevant Signal for Activating the Next Buffered\/Blending FB MC_Power No No MC_Home No No MC_Stop No No MC_Halt No No MC_MoveAbsolute MC_MoveRelative Yes Yes Done MC_MoveAdditive No Yes ( Buffered only) Done MC_MoveSuperImposed MC_HaltSuperImposed No No For more information, see: Behavior of MC_MoveSuperImposed and MC_HaltSuperImposedMC_MoveVelocity Yes Yes ( Buffered only) InVelocity SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative No Yes ( Buffered only) InEndVelocity MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile No Yes ( Buffered only) Done MC_CamIn Yes (only Buffered and BlendingPrevious ) Yes, also if periodic (only Buffered ) EndOfProfile MC_CamOut No Yes ( Buffered only) Done MC_GearIn Yes ( BlendingPrevious only) Yes ( Buffered only) InGear MC_GearOut No Yes ( Buffered only) Done MC_GearInPos Yes ( BlendingPrevious only) Yes ( Buffered only) InSync SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues No No SMC_SetTorque No No MC_Phasing No No MC_Jog SMC_Inch No No These function blocks should not be used when movements are commanded with buffer mode Buffered or Blending* . Jogging and the commanded movements could interrupt each other. SMC_BacklashCompensation No No SMC_TrackAxis No No SMC_TrackSetValues No No Note for MC_GearInPos and MC_GearIn : The behavior of other buffer modes as BlendingPrevious is difficult to establish. The main problem is that the velocity of these function blocks can change at any time depending on the master axis. Because blending works best when the blending speed is known as early as possible, only BlendingPrevious is supported. In the case of BlendingPrevious , the direction of the master axis can also change at any time. This means that the direction that the slave axis should have for MC_GearInPos is known only when the blending is complete. However, we need a direction for the blending movement right when the blending begins. This is why the first movement defines both the blending velocity and the direction, regardless of the direction defined by the subsequent MC_GearIn(Pos) . " }, 
{ "title" : "Behavior in the Case of Buffered Movements ", 
"url" : "_sm_buffermode_buffered_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commanding Multiple Movements \/ Behavior in the Case of Buffered Movements ", 
"snippet" : "When a buffered movement is commanded after MC_MoveAbsolute or MC_MoveRelative , the buffered movement is active in the same cycle where the previous movement reports Done and reaches the velocity 0. However, the interpolation of the buffered movement does not start until the next cycle, so that the...", 
"body" : "When a buffered movement is commanded after MC_MoveAbsolute or MC_MoveRelative , the buffered movement is active in the same cycle where the previous movement reports Done and reaches the velocity 0. However, the interpolation of the buffered movement does not start until the next cycle, so that the velocity of the axis at the end of the cycle is equal to 0. When a buffered movement is commanded after MC_CamIn , the buffered movement is active in the same cycle where the previous movement reports EndOfProfile . The interpolation of the buffered movement begins immediately in this cycle. " }, 
{ "title" : "Behavior in the Case of Blending ", 
"url" : "_sm_buffermode_blending.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commanding Multiple Movements \/ Behavior in the Case of Blending ", 
"snippet" : "A basic property of the blending behavior of CODESYS SoftMotion is that the axis moves along the same positions during blending as during a buffered movement. The only difference is the velocity along these positions. This is obvious for simple cases. See the following example for this: There are ca...", 
"body" : "A basic property of the blending behavior of CODESYS SoftMotion is that the axis moves along the same positions during blending as during a buffered movement. The only difference is the velocity along these positions. This is obvious for simple cases. See the following example for this: There are cases in which the property of traversing the same positions by the axis independently of the buffer mode influences the effective blending velocity between the two movements. This is the case, for example, if the above example is modified so that the maximum velocity of the second movement is so high that it cannot be reached at the blending position. According to the rules described in PLCopen, the blending velocity should be 500 u\/s. However, to achieve this velocity at position 100 u, the axis would have to reverse, move in the negative direction to a position less than 0 u, and then accelerate to 500 u\/s. Instead, in such cases the effective blending velocity is limited to the maximum velocity that can be achieved without reversal and position overshoot. In this example, the maximum velocity is 447 u\/s. The following rules for the effective blending velocity result from the property that the buffer mode does not change the driven positions: If the blending velocity cannot be reached without position overshoot, then the effective blending velocity is the next possible velocity that can be reached without overshoot (see example above). Note: The effective blending velocity can be higher or lower than the blending velocity. If the direction at the beginning of the second movement is opposite to the direction of the first movement, then the effective blending velocity is set to 0. This prevents the position from overshooting in the direction of the first movement beyond its target position. If the path of the second movement is too short to allow deceleration from the blending velocity to standstill, then the effective blending velocity is adjusted. It is set to the maximum velocity that allows for safe braking to a standstill on the path of the second movement. In the case of modulo axes, the effect of the input Direction of MC_MoveAbsolute is not affected by blending to a second movement. This means that the target position of the first movement is always in the same modulo period, regardless of whether or not a blending movement follows. In the case of modulo axes and a second movement of type MC_MoveAbsolute , the blending velocity does not affect the modulo period of the target position of the second movement when Direction = fastest is used. This means that the same target period is selected regardless of whether the second movement is commanded with Buffered or Blending . " }, 
{ "title" : "Acceleration, deceleration, and jerk during blending ", 
"url" : "_sm_buffermode_blending.html#UUID-60273b62-3ad5-7014-3fa9-e2fa61f7a008_section-idm235068399508112", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commanding Multiple Movements \/ Behavior in the Case of Blending \/ Acceleration, deceleration, and jerk during blending ", 
"snippet" : "The buffer mode ( BlendingLow \/ BlendingHigh \/ BlendingPrevious \/ BlendingNext ) of the second movement determines the velocity at which the start position of the movement is reached. In contrast, the maximum acceleration, deceleration, and maximum jerk during blending are always the values of the f...", 
"body" : "The buffer mode ( BlendingLow \/ BlendingHigh \/ BlendingPrevious \/ BlendingNext ) of the second movement determines the velocity at which the start position of the movement is reached. In contrast, the maximum acceleration, deceleration, and maximum jerk during blending are always the values of the first movement. The reason for this is that the target position of the first movement may be exceeded if, for example, the maximum delay of the second movement is less than that of the first and the lesser delay is used. " }, 
{ "title" : "Buffering\/Blending from Continuous or Synchronized Movement ", 
"url" : "_sm_buffermode_continuous_motion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commanding Multiple Movements \/ Buffering\/Blending from Continuous or Synchronized Movement ", 
"snippet" : "According to PLCopen, the blending buffer mode determines the velocity at the end of the first movement. In some cases, the velocity is already entirely determined by the first movement. This is the case when the first movement is of one of the following types: Continuous movement ( MC_MoveVelocity ...", 
"body" : "According to PLCopen, the blending buffer mode determines the velocity at the end of the first movement. In some cases, the velocity is already entirely determined by the first movement. This is the case when the first movement is of one of the following types: Continuous movement ( MC_MoveVelocity , SMC_MoveContinuousRelative , or SMC_MoveContinuousAbsolute ) Synchronized movement ( MC_CamIn , MC_GearIn , or MC_GearInPos ) In these cases, CODESYS SoftMotion supports only the Buffered and Aborting buffer modes. Using one of the blending buffer modes causes an FB error ( SMC_BLENDING_NOT_SUPPORTED_BY_PREVIOUS_MOVEMENT) . When the subsequent buffered command becomes active, the output CommandAborted is set to TRUE for a previous movement command. In addition, the \"Inxxx\" outputs (for example, InVelocity for MC_MoveVelocity or InGear for MC_GearIn ) and the output Busy are set for one cycle. This is in contrast to PLCopen, Section 2.4.1, in which CommandAborted and \"Inxxx\" as well as Busy are mutually exclusive. " }, 
{ "title" : "Execution Order of Movement Function Blocks ", 
"url" : "_sm_buffermode_execution_order.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commanding Multiple Movements \/ Execution Order of Movement Function Blocks ", 
"snippet" : "When buffered movements or blending movements are commanded, the function block instance that commands the subsequent movement must not be executed earlier than the function block instance that commanded the previous movement. If this order is violated, then the new error SMC_FB_WASNT_CALLED_DURING_...", 
"body" : "When buffered movements or blending movements are commanded, the function block instance that commands the subsequent movement must not be executed earlier than the function block instance that commanded the previous movement. If this order is violated, then the new error SMC_FB_WASNT_CALLED_DURING_MOTION is reported and the axis switches to the state Errorstop . Example movement1();\nmovement2(); Correct execution order Execution of movement1() Execution of movement2() as soon as movement1() is active Invalid execution order Execution of movement2() Execution of movement1() as soon as movement2() is active This results in the SMC_MOVING_WITHOUT_ACTIVE_MOVEMENT error. " }, 
{ "title" : "Using One Function Block Instance to Control Multiple Movements ", 
"url" : "_sm_buffermode_one_fb.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commanding Multiple Movements \/ Using One Function Block Instance to Control Multiple Movements ", 
"snippet" : "A single function block instance (for example, from MC_MoveAbsolute ) cannot be used to control multiple buffered\/blending movements as long as it is Busy . When a function block instance is Busy , the command for a new buffered or blended movement with this instance results in the error SMC_MORE_TH...", 
"body" : "A single function block instance (for example, from MC_MoveAbsolute ) cannot be used to control multiple buffered\/blending movements as long as it is Busy . When a function block instance is Busy , the command for a new buffered or blended movement with this instance results in the error SMC_MORE_THAN_ONE_MOVEMENT_PER_INSTANCE . To command multiple buffered or blended movements of the same type in a short order, multiple function module instances are required. " }, 
{ "title" : "Behavior in Case of Error ", 
"url" : "_sm_basic_behavior_error.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commanding Multiple Movements \/ Behavior in Case of Error ", 
"snippet" : "If an axis error occurs (for example, the axis switches to the state Errorstop ), the active movement will report an error along with all other accepted movements. If an FB error occurs in the function block of an active movement, then all movements accepted later also report an error. This is in co...", 
"body" : "If an axis error occurs (for example, the axis switches to the state Errorstop ), the active movement will report an error along with all other accepted movements. If an FB error occurs in the function block of an active movement, then all movements accepted later also report an error. This is in contrast to PLCopen, Section 2.2.2, in which subsequent commands will continue then execution after an FB error. " }, 
{ "title" : "Behavior of MC_MoveSuperImposed and MC_HaltSuperImposed ", 
"url" : "_sm_buffermode_movesuperimposed.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commanding Multiple Movements \/ Behavior of MC_MoveSuperImposed and MC_HaltSuperImposed ", 
"snippet" : "If MC_MoveSuperImposed or MC_HaltSuperImposed is active and the underlying movement is aborted, then MC_MoveSuperImposed \/ MC_HaltSuperImposed is also aborted. If the underlying movement is not aborted, but rather another movement is commanded with the Buffered mode or one of the modes of the blendi...", 
"body" : "If MC_MoveSuperImposed or MC_HaltSuperImposed is active and the underlying movement is aborted, then MC_MoveSuperImposed \/ MC_HaltSuperImposed is also aborted. If the underlying movement is not aborted, but rather another movement is commanded with the Buffered mode or one of the modes of the blending buffer mode, then the behavior is as follows: MC_MoveSuperimposed \/ MC_HaltSuperImposed is not aborted when the blending begins or the new movement is active. Instead, MC_MoveSuperimposed \/ MC_HaltSuperImposed is continued in the background until it is done. " }, 
{ "title" : "As of CODESYS SoftMotion version 4.17.0.0 ", 
"url" : "_sm_buffermode_movesuperimposed.html#UUID-55e334a2-da44-00d6-2f2a-9f3f03732605_section-idm234439539337338", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commanding Multiple Movements \/ Behavior of MC_MoveSuperImposed and MC_HaltSuperImposed \/ As of CODESYS SoftMotion version 4.17.0.0 ", 
"snippet" : "When an MC_MoveAbsolute configured with a buffered mode or a blending mode is commanded, the resulting end position is the sum of the position configured at MC_MoveAbsolute and the distance configured at MC_MoveSuperImposed \/ MC_HaltSuperImposed . It is irrelevant whether or not MC_MoveSuperImposed ...", 
"body" : "When an MC_MoveAbsolute configured with a buffered mode or a blending mode is commanded, the resulting end position is the sum of the position configured at MC_MoveAbsolute and the distance configured at MC_MoveSuperImposed \/ MC_HaltSuperImposed . It is irrelevant whether or not MC_MoveSuperImposed \/ MC_HaltSuperImposed is still active. The SuperImposed distance is retained even after the SuperImposed movement has been completed. The SuperImposed distance is reset as soon as an aborting movement is commanded. " }, 
{ "title" : "Before CODESYS SoftMotion version 4.17.0.0 ", 
"url" : "_sm_buffermode_movesuperimposed.html#UUID-55e334a2-da44-00d6-2f2a-9f3f03732605_section-idm234439540497353", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Commanding Multiple Movements \/ Behavior of MC_MoveSuperImposed and MC_HaltSuperImposed \/ Before CODESYS SoftMotion version 4.17.0.0 ", 
"snippet" : "If an MC_MoveAbsolute assigned with buffered mode or a blending mode is commanded while an MC_MoveSuperImposed \/ MC_HaltSuperImposed is active, then the resulting end position depends on the status of MC_MoveSuperImposed \/ MC_HaltSuperImposed at the time when the MC_MoveAbsolute is active. If MC_Mov...", 
"body" : "If an MC_MoveAbsolute assigned with buffered mode or a blending mode is commanded while an MC_MoveSuperImposed \/ MC_HaltSuperImposed is active, then the resulting end position depends on the status of MC_MoveSuperImposed \/ MC_HaltSuperImposed at the time when the MC_MoveAbsolute is active. If MC_MoveSuperImposed \/ MC_HaltSuperImposed is still active at this time, then the resulting end position is the sum for the position of MC_MoveAbsolute and the distance of MC_MoveSuperImposed \/ MC_HaltSuperImposed . On the other hand, if MC_MoveSuperImposed \/ MC_HaltSuperImposed is no longer active at this time, then the resulting end position is the position of MC_MoveAbsolute without the distance of MC_MoveSuperImposed \/ MC_HaltSuperImposed . In a similar way, the resulting velocity of MC_MoveVelocity depends on the status of MC_MoveSuperImposed \/ MC_HaltSuperImposed when MC_MoveVelocity is active. The curve below shows an MC_MoveSuperImposed ( sup function block) parallel to three absolute movements with blending buffer mode BlendingHigh . The first and second movements are commanded with a velocity of 100 u\/s with the ma0 and ma1 function blocks. The ma2 function block commands the third movement with a velocity of 120 u\/s. The first target position is 10 u, the second is 25 u, and the third is 40 u. The velocity of the superimposed movement is 20, and the distance is 10. The resulting position is 50 u: the position of the last absolute movement plus the distance of MC_MoveSuperimposed . " }, 
{ "title" : "Digital Switch Points ", 
"url" : "_sm_digital_switches.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Digital Switch Points ", 
"snippet" : "CODESYS SoftMotion provides various options for creating digital switch points. This section provides an overview of the respective advantages and disadvantages....", 
"body" : "CODESYS SoftMotion provides various options for creating digital switch points. This section provides an overview of the respective advantages and disadvantages. " }, 
{ "title" : "Application example ", 
"url" : "_sm_digital_switches.html#UUID-5c8c3ded-d3b5-7c4d-2e37-1277ff2bb5f0_section-idm235063632666072", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Digital Switch Points \/ Application example ", 
"snippet" : "Digital switch points are required, for example, to switch on a glue gun depending on the axis position. In the following example, the glue gun should apply adhesive to a product from position 90 to position 120. A glue gun has a delay between switching on and applying glue. The same applies to swit...", 
"body" : "Digital switch points are required, for example, to switch on a glue gun depending on the axis position. In the following example, the glue gun should apply adhesive to a product from position 90 to position 120. A glue gun has a delay between switching on and applying glue. The same applies to switching off. An on\/off compensation is therefore required so that the glue gun is switched on 50 ms before position 90 and switched off 50 ms before position 120. " }, 
{ "title" : "Overview of function blocks ", 
"url" : "_sm_digital_switches.html#UUID-5c8c3ded-d3b5-7c4d-2e37-1277ff2bb5f0_section-idm235063632773598", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Digital Switch Points \/ Overview of function blocks ", 
"snippet" : "Function Block Multiple switch points On\/Off Compensation Forecast High Precision (time resolution higher than cycle time) Data Basis Note SMC_DigitalCamSwitch_HighPrecision 1 2 Set position or actual position Useful when higher time precision is required. In addition to this function block, a high-...", 
"body" : "Function Block Multiple switch points On\/Off Compensation Forecast High Precision (time resolution higher than cycle time) Data Basis Note SMC_DigitalCamSwitch_HighPrecision 1 2 Set position or actual position Useful when higher time precision is required. In addition to this function block, a high-precision digital output card is required for high-precision operation. This combination makes it possible to switch outputs with high time precision even at higher cycle times. For more information about using the function block, see the following: example Using MC_DigitalCamSwitch_HighPrecision. SMC_GetTravelTime 2 Set position or actual position Useful if a separate version of the DigitalCamSwitch function block should to be implemented (for example, because additional functions are required). MC_DigitalCamSwitch 3 Set position or actual position Useful if a cycle-precise time resolution is sufficient. SMC_GetTappetValue Set position or actual position These function blocks are retained for reasons of compatibility only. For current and future projects, the other more advanced function blocks should be used. SMC_CamRegister Set position or actual position 1 Exact. The data from the forecast is used. 2 The forecast must be set by means of the SMC_SetForecast function block. For more information about the forecast, see the following: Forecast. 3 Only by extrapolation " }, 
{ "title" : "Dynamic Adaptation with MC_SetOverride ", 
"url" : "_sm_adjust_dynamics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dynamic Adaptation with MC_SetOverride ", 
"snippet" : "The dynamics (velocity, acceleration, and jerk) of the active and future movements can be adapted by using MC_SetOverride . An adaptation of the dynamics always means a reduction as compared to the originally commanded movement (factors greater than 1 are not permitted). This allows machine operator...", 
"body" : "The dynamics (velocity, acceleration, and jerk) of the active and future movements can be adapted by using MC_SetOverride . An adaptation of the dynamics always means a reduction as compared to the originally commanded movement (factors greater than 1 are not permitted). This allows machine operators to temporarily stop a movement ( VelFactor = 0 ) or execute it with reduced dynamic values, for example to check new movement sequences. The adaptation of the dynamics with MC_SetOverride and the resulting adaptation of the trajectory take effect directly in the same cycle. The requirement for this is that MC_SetOverride is called before the active movement function block. For more information, see also the example Velocity Override for SoftMotion Axes. " }, 
{ "title" : "Supported function blocks ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4626631011382434026679825113", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dynamic Adaptation with MC_SetOverride \/ Supported function blocks ", 
"snippet" : "Function Block Support: MC_SetOverride Comment MC_Stop -- MC_Stop is an emergency stop which should always be executed as quickly as possible. Therefore, the dynamic factors of MC_SetOverride do not have any effect on the movement. MC_Halt ✓ The velocity factor has no effect. MC_MoveAbsolute MC_Move...", 
"body" : "Function Block Support: MC_SetOverride Comment MC_Stop -- MC_Stop is an emergency stop which should always be executed as quickly as possible. Therefore, the dynamic factors of MC_SetOverride do not have any effect on the movement. MC_Halt ✓ The velocity factor has no effect. MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative ✓ MC_Jog SMC_Inch ✓ SMC_Homing ✓ SMC_ControlAxisByPos SMC_ControlAxisByPosVel SMC_ControlAxisByVel O The dynamic factors have an effect only if the bAvoidGaps function is activated and a jump has been detected. The factors of MC_SetOverride take into account both the stop and the subsequent absolute movement to close the gap. MC_Home -- The homing is executed independently by the drive so that the dynamic factors of MC_SetOverride have no effect. MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile -- We recommend using MC_CamIn instead of these function blocks. MC_CamIn O The dynamic factors no longer have an effect as soon as the movement is synchronized ( MC_CamIn.InSync = TRUE ). MC_CamOut -- MC_CamOut does not have adjustable dynamic limits and should maintain the current velocity. The dynamic factors of MC_SetOverride therefore do not have an effect. MC_GearIn O The dynamic factors no longer have an effect as soon as the movement is synchronized ( MC_GearIn.InGear = TRUE ). During ramping, only the acceleration and jerk factors are considered. Changes to the velocity factor (especially VelFactor=0 ) are ignored. MC_GearInPos -- In contrast to MC_GearIn , it does not have a configurable ramping movement. Therefore, the dynamic factors of MC_SetOverride do not have an effect. SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues -- These function blocks write the set values of the axis (for example, fSetPosition ). These values should not be modified. Therefore, the dynamic factors of MC_SetOverride do not have an effect. MC_Phasing O The dynamic factors no longer have an effect as soon as the movement is synchronized ( MC_Phasing.Done = TRUE ). During ramping, only the acceleration and jerk factors are considered. Changes to the velocity factor (especially VelFactor=0 ) are ignored. SMC_BacklashCompensation -- The dynamic factors do not have an effect on synchronized movements. Therefore, this function block ignores the dynamic factors of MC_SetOverride . " }, 
{ "title" : "Exceeding the target position or target velocity by changing the dynamic factors ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4552469374918434026680028303", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dynamic Adaptation with MC_SetOverride \/ Exceeding the target position or target velocity by changing the dynamic factors ", 
"snippet" : "If the acceleration factor and\/or the jerk factor is reduced during an active movement, then the target position or target velocity may be temporarily exceeded. This can lead to damage to the machine. With SMC_MoveContinuousAbsolute and SMC_MoveContinuousRelative , a change of the velocity factor ca...", 
"body" : "If the acceleration factor and\/or the jerk factor is reduced during an active movement, then the target position or target velocity may be temporarily exceeded. This can lead to damage to the machine. With SMC_MoveContinuousAbsolute and SMC_MoveContinuousRelative , a change of the velocity factor can also lead to the limits being exceeded or to a reversal. More details can be found in the documentation of the two function blocks. " }, 
{ "title" : "Effect of the velocity profile on the use of MC_SetOverride ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm4552469646968034026680341439", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dynamic Adaptation with MC_SetOverride \/ Effect of the velocity profile on the use of MC_SetOverride ", 
"snippet" : "It is generally recommended to use MC_SetOverride together with a trapezoidal or quadratic velocity profile of the axes. Quadratic-smoothed and sin² velocity profiles do not respond well to restarting or interrupting the movement in certain cases (see Interruption of Movements). Because a change to ...", 
"body" : "It is generally recommended to use MC_SetOverride together with a trapezoidal or quadratic velocity profile of the axes. Quadratic-smoothed and sin² velocity profiles do not respond well to restarting or interrupting the movement in certain cases (see Interruption of Movements). Because a change to the override is equivalent to a restart of the movement with changed limits, it is also possible for the commanded limits to be exceeded when using these velocity profiles in combination with MC_SetOverride . " }, 
{ "title" : "Effect of MC_SetOverride on coordinated movements with an axis group ", 
"url" : "_sm_adjust_dynamics.html#UUID-746e0525-a6a4-f544-ea75-cb1eed348dd7_section-idm456655390848963402668059106", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Dynamic Adaptation with MC_SetOverride \/ Effect of MC_SetOverride on coordinated movements with an axis group ", 
"snippet" : "Coordinated movements with an axis group (for example, MC_MoveLinearAbsolute ) consider the overrides set with MC_SetOverride for each axis during movement planning. Conversely, MC_GroupSetOverride overwrites the overrides of each axis of the axis group....", 
"body" : "Coordinated movements with an axis group (for example, MC_MoveLinearAbsolute ) consider the overrides set with MC_SetOverride for each axis during movement planning. Conversely, MC_GroupSetOverride overwrites the overrides of each axis of the axis group. " }, 
{ "title" : "Forecast ", 
"url" : "_sm_basic_forecast.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Forecast ", 
"snippet" : "The forecast function can be used to query information about the future movement of an axis. An important application of forecast is to determine the time until a position is reached (similar to trigger functionality). Another application is to determine the position and velocity which an axis will ...", 
"body" : "The forecast function can be used to query information about the future movement of an axis. An important application of forecast is to determine the time until a position is reached (similar to trigger functionality). Another application is to determine the position and velocity which an axis will have at a given time. In this way, dead times can be compensated when actuators are switched on, for example when an gluing nozzle is switched on. It can also be used to precisely control actuators with dead time, such as controlling the gluing output based on the axis velocity 100 ms in the future To implement these applications, you can use the SMC_GetTravelTime and SMC_ReadSetValues function blocks after you have configured the forecast duration with SMC_SetForecast . For an example of usage, see: Forecast for Single-Axis Movements" }, 
{ "title" : "Movement function blocks with forecast functionality ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm2344331274012", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Forecast \/ Movement function blocks with forecast functionality ", 
"snippet" : "The following overview shows which function blocks support the forecast function. Function Block Forecast MC_Home -- MC_Stop ✓ MC_Halt ✓ MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed MC_HaltSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelati...", 
"body" : "The following overview shows which function blocks support the forecast function. Function Block Forecast MC_Home -- MC_Stop ✓ MC_Halt ✓ MC_MoveAbsolute MC_MoveRelative ✓ MC_MoveAdditive ✓ MC_MoveSuperimposed MC_HaltSuperimposed ✓ MC_MoveVelocity ✓ SMC_MoveContinuousAbsolute SMC_MoveContinuousRelative ✓ MC_PositionProfile MC_VelocityProfile MC_AccelerationProfile -- MC_CamIn ✓ MC_CamOut ✓ MC_GearIn ✓ MC_GearOut ✓ MC_GearInPos ✓ SMC_FollowPosition SMC_FollowVelocity SMC_FollowPositionVelocity SMC_FollowSetValues -- SMC_SetTorque -- MC_Phasing ✓ MC_Jog SMC_Inch ✓ SMC_BacklashCompensation ✓ " }, 
{ "title" : "Enabling the forecast function ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433129890703", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Forecast \/ Enabling the forecast function ", 
"snippet" : "The forecast function is disabled by default. This means that SMC_ReadSetValues returns valid values only for a TimeOffset between 0 s (start of the current task cycle) and the task interval (end of the current task cycle), and SMC_GetTravelTime returns a valid time only for positions which are reac...", 
"body" : "The forecast function is disabled by default. This means that SMC_ReadSetValues returns valid values only for a TimeOffset between 0 s (start of the current task cycle) and the task interval (end of the current task cycle), and SMC_GetTravelTime returns a valid time only for positions which are reached in this cycle. The SMC_SetForecast function block is used to configure the required forecast duration and the SMC_GetForecast function block is used to read. Notes: The forecast duration can be changed at any time. Avoid an unnecessarily long forecast duration because the forecast calculation consumes computing time. Select the smallest value which is sufficient for your application. If you use master\/slave function blocks (such as MC_CamIn ), then the forecast must be enabled for both the master axis and the slave axis. " }, 
{ "title" : "Call order ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130424909", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Forecast \/ Call order ", 
"snippet" : "In order for the forecast function to yield the best possible results, it is important to make sure that the master\/slave function blocks are called in the correct order. This applies to MC_CamIn , MC_GearIn , MC_GearInPos , MC_Phasing , SMC_BacklashCompensation , and SMC_TrackAxis . The movement fu...", 
"body" : "In order for the forecast function to yield the best possible results, it is important to make sure that the master\/slave function blocks are called in the correct order. This applies to MC_CamIn , MC_GearIn , MC_GearInPos , MC_Phasing , SMC_BacklashCompensation , and SMC_TrackAxis . The movement function block of the master axis should be called before the master\/slave function block. Even without forecast, the trajectory is better when the call order is correct. When the order is wrong, the slave movement is delayed by one cycle. For MC_SetOverride , this function block should also be called before the movement function blocks of the axis. By changing the override, the movement of the axis is changed in the same task cycle. As a result, values which were previously determined based on the forecast lose their validity. They are determined again the next time SMC_GetTravelTime or SMC_ReadSetValues is called. " }, 
{ "title" : "Buffer modes ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130652478", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Forecast \/ Buffer modes ", 
"snippet" : "The forecast function is not limited to a single movement. It also extends to all subsequent movements which are commanded with a blending or buffered buffer mode. When an aborting movement is executed on an axis, it changes the movement of the axis in this task cycle. As a result, values which were...", 
"body" : "The forecast function is not limited to a single movement. It also extends to all subsequent movements which are commanded with a blending or buffered buffer mode. When an aborting movement is executed on an axis, it changes the movement of the axis in this task cycle. As a result, values which were previously determined based on the forecast lose their validity. They are determined again the next time SMC_GetTravelTime or SMC_ReadSetValues is called. " }, 
{ "title" : "Effective forecast \/ restrictions ", 
"url" : "_sm_basic_forecast.html#UUID-21da9f46-debe-e1a5-e5b7-8964c6301468_section-idm234433130869747", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Forecast \/ Effective forecast \/ restrictions ", 
"snippet" : "Ideally, the effective available forecast duration is equal to the configured forecast duration. However, there are some factors which can lead to the effective forecast being shorter than the configured forecast. When a master\/slave movement is executed, the effective forecast of the slave is the m...", 
"body" : "Ideally, the effective available forecast duration is equal to the configured forecast duration. However, there are some factors which can lead to the effective forecast being shorter than the configured forecast. When a master\/slave movement is executed, the effective forecast of the slave is the minimum of the effective forecast of the master and the configured forecast of the slave. For logical axes and encoder axes, the effective forecast is always 0. If the active movement function block does not support the forecast function, then the effective forecast is also 0. In all other cases, the effective forecast is the same as the configured forecast. " }, 
{ "title" : "Diagnosis ", 
"url" : "_sm_basic_error_diagnosis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Diagnosis ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Common Errors ", 
"url" : "_sm_basic_common_errors.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Diagnosis \/ Common Errors ", 
"snippet" : "This page describes common errors when using CODESYS Softmotion Basic , their causes, and possible actions to take to correct the error. For a list of all possible errors with a brief description, see the library documentation: SMC_ERROR Error Code Description and Causes Actions SMC_DI_AXIS_ERROR Th...", 
"body" : "This page describes common errors when using CODESYS Softmotion Basic , their causes, and possible actions to take to correct the error. For a list of all possible errors with a brief description, see the library documentation: SMC_ERROR Error Code Description and Causes Actions SMC_DI_AXIS_ERROR The drive has reported an error. Possible causes: Position lag Limit switch Overload (I²t error) Check which error the drive is reporting. The error can be read from the display of the drive (if available) or by fetching with the MC_ReadAxisError function block. SMC_AXIS_ERROR_DURING_MOTION The drive has reported an error. During a movement, the active motion block returns this error. See the actions for the error SMC_DI_AXIS_ERROR . SMC_FB_WASNT_CALLED_DURING_MOTION The function block which controls the active movement has not been called in the current cycle. Possible causes: The call order for buffered movements or blending movements is incorrect. The function block instance of the subsequent movement must not be called earlier than the function block instance which commanded the previous movement. In SoftMotion version 4.15.0.0 and higher, the log message for this error contains the instance path to the affected function block. In the application, check for the reason why the function block was not called cyclically. Fix the call so that it is done cyclically (at least as long as the block is in use). SMC_BLOCKING_MC_STOP_WASNT_CALLED During an active stop, the associated function block MC_Stop was not called in the current cycle. See the actions for the error SMC_FB_WASNT_CALLED_DURING_MOTION . SMC_AXIS_NOT_READY_FOR_MOTION The axis is not ready for use and cannot execute the desired movement. Possible causes: The axis is not in an operational state for the respective movement (for example, power_off or errorstop ). The axis is in an error state and all buffered movements return this error. The axis is in the stopping state (during an active MC_Stop ) and a new aborting movement is commanded. Check the state of the axis: Is the axis in an operational state by MC_Power ? Is the axis in the errorstop state? If so, then identify the axis error and correct it. Does the axis state match the commanded movement? For example, MC_CamOut can be commanded only when the axis is in the state of the synchronized movement. SMC_FB_CALLED_FROM_WRONG_TASK The SoftMotion block was called from a task which does not correspond to the bus task of the axis. Because the SoftMotion blocks change values in the axis, inconsistent states can occur if calls are made from tasks other than the bus task. This can lead to undefined errors, which is prevented by this error. Check the log: The affected axis and block instance are logged. Remove the call from the incorrect task. SMC_DI_FIELDBUS_LOST_SYNCRONICITY Occurs when using EtherCAT with distributed clocks if the frame from the controller to the drive has not been received on time (within the defined time window (\"SyncWindow\") or has not been received at all. Possible causes: Real-time problems: The task jitter is too high. The task priority of the EtherCAT task is too low. Other fieldbuses (for example, Modbus ) or lengthy operations in addition to the control tasks (for example, file access) in the EtherCAT task Modbus is executed in another task, but the I\/O channels it uses are also referenced in the EtherCAT task. Especially with Linux operating systems, the configuration of the system (for example, IRQ priorities) Communication problem with the EtherCAT slave: Connection interrupted, problems with electromagnetic compatibility (EMC), etc. Check for the cause of the behavior. The following functions can help you with this: The Status page of the EtherCAT Master Analysis of the cycle and jitter times of the EtherCAT task in the Task configuration Possible actions for real-time problems: Optimize the real time. To do this, follow the instructions in Performance Optimization . Increase the cycle time of the EtherCAT task. Increase DCInSyncWindow of the EtherCAT Master. See: IoDrvEtherCAT.DCInSyncWindow (PROP) Enable FrameAtTaskStart for the EtherCAT Master. See: IoDrvEtherCAT.FrameAtTaskStart (PROP) If the drive can handle the synchronization problems, then the synchronization check can be disabled by means of SMC_Set_ETC_DCSyncSupervision . SMC_DI_SWLIMITS_EXCEEDED The axis moves in the direction of the positive or negative software limit switch and will exceed it with the current dynamics. The error also triggers before the actual limit switch position because the required deceleration distance is also included in the calculation. Check whether or not the movement is desired in this position range. If necessary, adjust the negative and\/or positive software limit switch position. See Tab: GeneralSMC_DI_HWLIMITS_EXCEEDED The positive or negative hardware limit switch has triggered and the axis moves in the direction of this limit switch. Check the commanded position of the movement. This should not exceed the positions of the hardware limit switches. If the movement is OK, then check the signals of the hardware limit switches. SMC_MOVING_WITHOUT_ACTIVE_MOVEMENT There is no active movement, but the set velocity is not equal to zero and the axis is in an operating state in which the set values are followed. Possible causes: When using MC_PositionProfile , MC_VelocityProfile , or MC_AccelerationProfile , the axis must come to a standstill at the end of this movement or a subsequent movement must be commanded in the same cycle. Otherwise this error is returned. Check the cause of the problem: Incorrect call order for buffered and blending movements: Adjust the call order. For more information, see the section Execution Order of Movement Function Blocks. MC_PositionProfile , MC_VelocityProfile , or MC_AccelerationProfile is used and no standstill is reached at the end: Adjust the profile accordingly so that standstill is reached at the end. Or instead use Cams, which cover a similar use case to these function blocks, but are more flexible and easier to use. " }, 
{ "title" : "Performance ", 
"url" : "_sm_diagnosis_performance.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Diagnosis \/ Performance ", 
"snippet" : "POUs which use the AXIS_REF_SM3 function block always check whether or not they are called from the bus cycle task. This check can be disabled for time-critical applications by means of the compiler define SM3_DISABLE_TASK_CHECKS ....", 
"body" : "POUs which use the AXIS_REF_SM3 function block always check whether or not they are called from the bus cycle task. This check can be disabled for time-critical applications by means of the compiler define SM3_DISABLE_TASK_CHECKS . " }, 
{ "title" : "Examples ", 
"url" : "_sm_basic_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Single-Axis Movements ", 
"url" : "_sm_basic_examples_single_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Single-Axis Movements ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Controlling the Movement of Single Axes ", 
"url" : "_sm_example_single_axis_motion_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Single-Axis Movements \/ Controlling the Movement of Single Axes ", 
"snippet" : "See the PLCopenSingle.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how to control a drive by means of PLCopen standardized function blocks. Insert a virtual drive named Drive in the device tree below SoftMotion General Axis...", 
"body" : "See the PLCopenSingle.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how to control a drive by means of PLCopen standardized function blocks. Insert a virtual drive named Drive in the device tree below SoftMotion General Axis Pool . Create a MOTION_PRG program in ST. PROGRAM MOTION_PRG\nVAR\n iStatus: INT;\n Power: MC_Power;\n MoveAbsolute: MC_MoveAbsolute;\n p:REAL:=100;\nEND_VAR\n\nCASE iStatus OF\n\n\/\/ initialization of the axis\n0:\n Power(Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE, Axis:=Drive);\n IF Power.Status THEN\n iStatus := iStatus + 1;\n END_IF\n\n\/\/ Move the axis to position p by use of the MC_MoveAbsolute function block\n1:\n MoveAbsolute(Execute:=TRUE, Position:= p, Velocity:=100, Acceleration:=100, Deceleration:=100, Axis:=Drive);\n IF MoveAbsolute.Done THEN\n MoveAbsolute(Execute:=FALSE, Axis:=Drive);\n iStatus := iStatus + 1;\n END_IF\n\n\/\/ Move the axis back to position 0 by use of the MC_MoveAbsolute function block:\n2:\n MoveAbsolute(Execute:=TRUE, Position:= 0, Velocity:=100, Acceleration:=100, Deceleration:=100, Axis:=Drive);\n IF MoveAbsolute.Done THEN\n MoveAbsolute(Execute:=FALSE, Axis:=Drive);\n iStatus := 1;\n END_IF Add the call of the MOTION_PRG program to the task MainTask . Device tree: Download the project to the controller and start it. Open the Drive virtual axis in the editor. In the Online part of the General tab, you see the axis motion. " }, 
{ "title" : "Controlling the Movement of Single Axes in CFC with a Visualization Template ", 
"url" : "_sm_example_single_axis_visu_template.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Single-Axis Movements \/ Controlling the Movement of Single Axes in CFC with a Visualization Template ", 
"snippet" : "See the PLCopenSingle2.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . Any of the other IEC implementation languages can also be used instead of ST, for example CFC here. This language demonstrates the start and interrupt mechanism of the functi...", 
"body" : "See the PLCopenSingle2.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . Any of the other IEC implementation languages can also be used instead of ST, for example CFC here. This language demonstrates the start and interrupt mechanism of the function blocks. In addition, the different start modes for the MC_MoveAbsolute function block can be tested for rotatory axes. Insert a virtual drive named Drive in the device tree below SoftMotion General Axis Pool . Double-click the object to open its editor. Change the parameters to a rotary drive with a period of 360°. Axis type : Modulo Modulo value [u] : 360.0 Create a MOTION_PRG program in CFC. Insert the function blocks MC_Power , MC_MoveAbsolute , and MC_MoveVelocity . It is generally recommended to initialize the function block inputs. Then you do not have to specify the values again and again later when starting this test application. PROGRAM MOTION_PRG\nVAR\n mcp: MC_Power := (Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n mcmv: MC_MoveVelocity :=(Velocity:=100, Acceleration:=100, Deceleration:=100, Direction:=positive);\n mcma: MC_MoveAbsolute := (Position:=180, Velocity:=100, Acceleration:=100, Deceleration:=100, Direction:=positive);\nEND_VAR CFC: Add the call of the MOTION_PRG program to the task MainTask . Add a Visualization object to the application. Position the visualization templates VISU_NEW_MC_MoveAbsolute , VISU_NEW_MC_MoveVelocity , VISU_NEW_MC_Power , and RotDrive in the visualization editor. Link these to the function block instances of MOTION_PRG . Visualization: Build the project and download it to the PLC. Start the project. Open the visualization in the editor. Click the Enable input (MC_Power) and then the Execute input (MC_Move_Absolute). The drive rotates. Open the Drive virtual axis in the editor. In the Online part of the General tab, you see the axis motion. Experiment with the parameters of these function blocks. Change the parameters and observe the behavior. " }, 
{ "title" : "Forecast for Single-Axis Movements ", 
"url" : "_sm_basic_example_forecast.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Single-Axis Movements \/ Forecast for Single-Axis Movements ", 
"snippet" : "The BasicMotion_Forecast.project sample project is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how to define a forecast for an axis in order to get information about the state of the axis in the future. In the example, an absolute moveme...", 
"body" : "The BasicMotion_Forecast.project sample project is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how to define a forecast for an axis in order to get information about the state of the axis in the future. In the example, an absolute movement is executed on an axis to position 10. By setting a forecast of 300 ms on the axis, you can find out in advance in the application when and with what dynamics the axis will move through position 8. For more information all about the forecast for axes, see: Forecast" }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_basic_example_forecast.html#UUID-0813b57c-b654-1961-50ef-d370b88506f6_section-idm43442768266588", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Single-Axis Movements \/ Forecast for Single-Axis Movements \/ Structure of the application ", 
"snippet" : "The application consists of a PLC_PRG program and a Trace . PLC_PRG The virtual axis is switched on in the STATE_POWER_DRIVE state. Then the SMC_SetForecast function block is used to define a forecast of 300 ms for the axis in the STATE_SET_FORECAST state. The SMC_GetForecast function block can be u...", 
"body" : "The application consists of a PLC_PRG program and a Trace . PLC_PRG The virtual axis is switched on in the STATE_POWER_DRIVE state. Then the SMC_SetForecast function block is used to define a forecast of 300 ms for the axis in the STATE_SET_FORECAST state. The SMC_GetForecast function block can be used to read the set forecast for the axis. In the STATE_MOVE_TO_POSITION state, an absolute movement to position 10 is executed. The SMC_GetTravelTime function block is also started. The function block is used to read the time when the axis will reach position 8. The SMC_ReadSetValues function block is used to determine the dynamics at position 8. A time offset can be passed to this function block where the dynamics of the axis should be read. In our case, we pass the duration which the axis needs to reach position 8. Trace You can use the trace to track the movement of the virtual axis. The current position, velocity, and acceleration of the axis are recorded. The duration up to position 8 and the dynamics of the axis at this position are also displayed. Note that the duration of SMC_GetTravelTime is specified relative to the start of the cycle. The set values of the axis correspond to those at the end of the cycle. " }, 
{ "title" : "Commissioning ", 
"url" : "_sm_basic_example_forecast.html#UUID-0813b57c-b654-1961-50ef-d370b88506f6_section-idm43442768283734", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Single-Axis Movements \/ Forecast for Single-Axis Movements \/ Commissioning ", 
"snippet" : "Build the application and download it to a controller. Start the trace and the application. In the trace, you can track the movement of the virtual axis. Pay attention to the duration up to position 8 and the dynamics at position 8....", 
"body" : "Build the application and download it to a controller. Start the trace and the application. In the trace, you can track the movement of the virtual axis. Pay attention to the duration up to position 8 and the dynamics at position 8. " }, 
{ "title" : "Synchronous Movements of Two Axes ", 
"url" : "_sm_basic_synch_movements_2_axis_example.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Synchronous Movements of Two Axes ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Electronic Gears, Phase Offset, and Compensation of Gear Backlash ", 
"url" : "_sm_basic_example_synchronized_motion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Synchronous Movements of Two Axes \/ Electronic Gears, Phase Offset, and Compensation of Gear Backlash ", 
"snippet" : "See the BasicMotion_SynchronizedMotion.project example in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how to use an electronic gearbox in combination with a phase offset and gear backlash compensation....", 
"body" : "See the BasicMotion_SynchronizedMotion.project example in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how to use an electronic gearbox in combination with a phase offset and gear backlash compensation. " }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_basic_example_synchronized_motion.html#UUID-5f979be9-50d7-427c-01e2-01bc4a0e21cb_section-idm4538843986680034227085857199", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Synchronous Movements of Two Axes \/ Electronic Gears, Phase Offset, and Compensation of Gear Backlash \/ Structure of the application ", 
"snippet" : "The application consists of a simple state machine in the PLC_PRG program and a trace which you can use to easily track the functionality of the function blocks. Enable the axes with MC_Power . (STATE_POWER ) Start the synchronous movements and move the master axis continuously between position 0 an...", 
"body" : "The application consists of a simple state machine in the PLC_PRG program and a trace which you can use to easily track the functionality of the function blocks. Enable the axes with MC_Power . (STATE_POWER ) Start the synchronous movements and move the master axis continuously between position 0 and position 100 ( STATE_COMMAND_POS_0 and STATE_COMMAND_POS_1 ). " }, 
{ "title" : "Usage ", 
"url" : "_sm_basic_example_synchronized_motion.html#UUID-5f979be9-50d7-427c-01e2-01bc4a0e21cb_section-idm4561564117984034227086974585", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Synchronous Movements of Two Axes \/ Electronic Gears, Phase Offset, and Compensation of Gear Backlash \/ Usage ", 
"snippet" : "The master axis (black in the trace diagram) moves continuously back and forth between position 0 and position 100 at a maximum velocity of 50 units per second. An electronic gearbox ( MC_GearIn ) with a gear ratio of 2:3 converts the master movement to the Slave0 axis (green in the trace diagram). ...", 
"body" : "The master axis (black in the trace diagram) moves continuously back and forth between position 0 and position 100 at a maximum velocity of 50 units per second. An electronic gearbox ( MC_GearIn ) with a gear ratio of 2:3 converts the master movement to the Slave0 axis (green in the trace diagram). The maximum velocity resulting from the gears is 75 units per second. Then, a phase offset ( MC_Phasing ) of 30 units is applied to the Slave1 axis (orange in the trace diagram). The velocity is identical to the Slave0 axis, except for the ramp-in phase. Finally, gear backlash compensation is used to bring the movement to the Drive axis (blue in the trace diagram). An unrealistically high value of 5 units is set for the gear backlash for demonstrative purposes. The diagram shows a compensating movement at the start of the movement and at each reversal of the direction of movement. " }, 
{ "title" : "GearInPos (Flying Saw) ", 
"url" : "_sm_basic_example_gearinpos.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Synchronous Movements of Two Axes \/ GearInPos (Flying Saw) ", 
"snippet" : "See the BasicMotion_GearInPos.project example in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how to use MC_GearInPos to implement a flying saw. For this project, we recommend installing CODESYS Depictor , which can display the application as a 3D a...", 
"body" : "See the BasicMotion_GearInPos.project example in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how to use MC_GearInPos to implement a flying saw. For this project, we recommend installing CODESYS Depictor , which can display the application as a 3D animation. (The unlicensed free version is enough to do this.) " }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm4565133330038434227193133829", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Synchronous Movements of Two Axes \/ GearInPos (Flying Saw) \/ Structure of the application ", 
"snippet" : "The application consists of a state machine in the PLC_PRG program, a 3D representation (Scene, DepictorCalculation program), a simple workpiece simulation ( SimulateWorkpiece program), and a trace which you can use to easily comprehend the effect of the function blocks. The flow in PLC_PRG is as fo...", 
"body" : "The application consists of a state machine in the PLC_PRG program, a 3D representation (Scene, DepictorCalculation program), a simple workpiece simulation ( SimulateWorkpiece program), and a trace which you can use to easily comprehend the effect of the function blocks. The flow in PLC_PRG is as follows: Enable the axes with MC_Power . ( STATE_POWER ) Wait until the light barrier detects a workpiece. ( STATE_WAIT_FOR_WORKPIECE ) As soon as the light barrier detects a workpiece, the slave which transports the saw parallel to the conveyor belt is synchronized with the workpiece on the conveyor belt (controlled by the Master axis). ( STATE_WAIT_FOR_SYNC ) When synchronization is reached, the saw is moved forwards and backwards once perpendicularly to the workpiece. ( STATE_MOVE_TOOL_0\/1 ) Move the slave to the rest position and start the process again at 2. ( STATE_MOVE_TO_REST ) " }, 
{ "title" : "Coordinate systems and dimensions ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm4627667581768034227193767932", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Synchronous Movements of Two Axes \/ GearInPos (Flying Saw) \/ Coordinate systems and dimensions ", 
"snippet" : "The origin of the coordinate system is at the center of the conveyor belt, the Z-axis points upwards, and the X-axis points in the direction of movement of the conveyor belt. From the conveyor belt, the Y-axis points away from the saw. The dimensions of the conveyor belt and workpiece, the position ...", 
"body" : "The origin of the coordinate system is at the center of the conveyor belt, the Z-axis points upwards, and the X-axis points in the direction of movement of the conveyor belt. From the conveyor belt, the Y-axis points away from the saw. The dimensions of the conveyor belt and workpiece, the position of the light barrier, and the position where the saw runs synchronously with the workpiece are stored as constants in the GVL Const . " }, 
{ "title" : "Usage ", 
"url" : "_sm_basic_example_gearinpos.html#UUID-7427e778-9606-41ce-e6fc-dd7dd1d30101_section-idm458752582335683422719410462", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Synchronous Movements of Two Axes \/ GearInPos (Flying Saw) \/ Usage ", 
"snippet" : "Start the application. In the Scene Depictor object and in the trace, you can see how the synchronization between the master (workpiece on the conveyor belt) and the slave (saw) is performed....", 
"body" : "Start the application. In the Scene Depictor object and in the trace, you can see how the synchronization between the master (workpiece on the conveyor belt) and the slave (saw) is performed. " }, 
{ "title" : "Cams ", 
"url" : "_sm_basic_examples_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Cams ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Alternating Cams ", 
"url" : "_sm_example_changing_cams.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Cams \/ Alternating Cams ", 
"snippet" : "See the PLCopenMultiCAM.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example demonstrates how a cam movement can be created with two alternating cams. The program is implemented in ST and executes the same actions as the \"Cam Drive Contr...", 
"body" : "See the PLCopenMultiCAM.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example demonstrates how a cam movement can be created with two alternating cams. The program is implemented in ST and executes the same actions as the \"Cam Drive Control using a Virtual Time Axis\" example. At the end of the first cam, the MC_CamIn function block sets the EndOfProfile output. In this way, the other curve table is assigned to MC_CamTableSelect and MC_CamIn is restarted. " }, 
{ "title" : "Controlling a Cam Drive with a Virtual Time Axis ", 
"url" : "_sm_example_drive_control_virtual_time_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Cams \/ Controlling a Cam Drive with a Virtual Time Axis ", 
"snippet" : "See the PLCopenMulti.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example demonstrates how to implement a periodic cam on a linear drive. The example also shows how to use the tappet function. Insert a cam named Example in the device tre...", 
"body" : "See the PLCopenMulti.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example demonstrates how to implement a periodic cam on a linear drive. The example also shows how to use the tappet function. Insert a cam named Example in the device tree below Application . Open the cam in the editor. Define a tappet on the Tappet tab. X : 8.0 Positive pass : Invert Negative pass : Invert Insert a virtual drive named Drive in the device tree below SoftMotion General Axis Pool . For this axis, select the axis type Modulo with a modulo value of 360 . Insert another virtual drive named Virtual . For this axis, select the Modulo axis type with a modulo value of 10 . Create a MOTION_PRG program in CFC. PROGRAM MOTION_PRG\nVAR\n power1, power2: MC_Power;\n TableSelect: MC_CamTableSelect;\n CamIn: MC_CamIn;\n Tappet: SMC_GetTappetValue;\n MoveVirtual: MC_MoveVelocity;\nEND_VAR Insert a box element and assign the variable power1 to it. The box element is used for switching on the Drive . Configure the inputs as follows: Axis : Drive Enable : TRUE bRegulatorOn : TRUE bDriveStart TRUE Insert a box element and assign the variable power2 to it. The box element is used for switching on the Virtual drive. Configure the inputs as follows: Axis : Virtual Enable : TRUE bRegulatorOn : TRUE bDriveStart TRUE Insert a box element and assign the variable MoveVirtual to it. The box element is used for moving the virtual master. Configure the inputs as follows: Axis : Virtual Execute : power2.Status Velocity : 2 Acceleration 10 Deceleration 10 Direction positive Insert a box element and assign the variable TableSelect to it. The box element is used for selecting a cam. Configure the inputs as follows: Master : Virtual Slave : Drive CamTable : Example Execute TRUE Periodic TRUE MasterAbsolute TRUE SlaveAbsolute TRUE Insert a box element and assign the variable CamIn to it. The box element implements the selected cam plate. Configure the inputs as follows: Master : Virtual Slave : Drive Execute power1.Status MasterOffset : 0 SlaveOffset : 0 MasterScaling : 1 SlaveScaling : 1 StartMode : absolute CamTableID : TableSelect.CamTableID VelocityDiff : 1 Acceleration : 1 Deceleration : 1 TappetHysteresis : 1 Insert a box element and assign the variable Tappet to it. The box element checks the setting of the cam switch. Configure the inputs as follows: Tappets : CamIn.Tappets iID : 1 bInitValue FALSE bSetInitValueAtReset : FALSE The tappet is defined as an inverting tappet. For this reason, its value is changed every 10 seconds. The sample project provides a visualization for checking the individual function blocks and the position of the axes. Add the call of the MOTION_PRG program to the task MainTask . Download the project to the controller and start it. For more information, see: MC_Power MC_CamTableSelect MC_CamIn SMC_GetTappetValue MC_MoveVelocity " }, 
{ "title" : "Creating Cams Programmatically ", 
"url" : "_sm_basic_example_cam_programmatic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Cams \/ Creating Cams Programmatically ", 
"snippet" : "The BasicMotion_CreateCamTableOnline.project sample project is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The example shows how you can use IEC code to create and use a cam. The following points are covered here: A cam created in the cam editor is created...", 
"body" : "The BasicMotion_CreateCamTableOnline.project sample project is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The example shows how you can use IEC code to create and use a cam. The following points are covered here: A cam created in the cam editor is created again using IEC code. In one case, the cam disk is generated in the bus task. In the other case, the cam disk is generated in a separate task. Then, all three cams are run with the same master axis and different slave axes. The movement of the three slaves is identical. The cam generated in the IEC code is displayed in the visualization. For more information about the programmatic creation of cams, see: Creating Cams Programmatically" }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_basic_example_cam_programmatic.html#UUID-ea402455-f321-1e3f-0d8c-522b4772732e_section-idm4538843986680034227085857199", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Cams \/ Creating Cams Programmatically \/ Structure of the application ", 
"snippet" : "The application consists of the following components: CamOffline The cam created in the cam editor which should be created again using IEC code. PLC_PRG The program consists of a simple state machine and, logically, three parts. In the first and second parts, a cam is created in IEC code. In the thi...", 
"body" : "The application consists of the following components: CamOffline The cam created in the cam editor which should be created again using IEC code. PLC_PRG The program consists of a simple state machine and, logically, three parts. In the first and second parts, a cam is created in IEC code. In the third part, the previously created cams and an identical cam created offline are run. Part 1: In the first state STATE_CREATE_ONLINE_TABLE , a cam is created in IEC code. The SMCB.CamBuilder function block from the SM3_CamBuilder library is used for this purpose. Three segments are added: a Poly5 element followed by a Line element and another Poly5 element. The Builder generates a CamOnline cam from this. From this point on, the cam is created in IEC code and can be used in the same way as the CamOffline cam created offline in the cam editor. Part 2: In the STATE_INIT_ONLINE_TABLE_MULTITASK , STATE_START_CREATE_ONLINE_TABLE_MULTITASK , and STATE_READ_ONLINE_TABLE_MULTITASK states, the creation of the cam is started in another task and then it is read. Part 3: In the STATE_POWER_DRIVES state, the virtual axes for the master and the three slave axes are initialized. The cams are then selected using MC_CamTableSelect in the STATE_SELECT_TABLE state and executed in the final STATE_MOVEMENT state. The master axis is moved using MC_MoveVelocity and is used as the master for the three cams. MultitaskCamBuilder A program which generates a cam as described in Part 1 of PLC_PRG . The only difference here is that a multitask\/multicore-safe variant of the cam is used. GVL The multitask\/multicore-safe variant of the cam is instantiated here. Visualization The visualization contains the SMC_Visu_CamDisplayer element for displaying cams. The cam generated in Part 1 of PLC_PRG is displayed. CamDisplayerSettings Additional elements for displaying the cam in Visualization Trace You can use the trace to track the movement of the virtual axes. The current position of the master is recorded, as well as the position, velocity, and acceleration of the three slave axes. " }, 
{ "title" : "Commissioning ", 
"url" : "_sm_basic_example_cam_programmatic.html#UUID-ea402455-f321-1e3f-0d8c-522b4772732e_section-idm4561564117984034227086974585", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Cams \/ Creating Cams Programmatically \/ Commissioning ", 
"snippet" : "Build the application and download it to a controller. Start the trace and the application. Observe the sampling trace. Display of the generated cam in the visualization...", 
"body" : "Build the application and download it to a controller. Start the trace and the application. Observe the sampling trace. Display of the generated cam in the visualization " }, 
{ "title" : "Using MC_DigitalCamSwitch_HighPrecision ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Cams \/ Using MC_DigitalCamSwitch_HighPrecision ", 
"snippet" : "The example BasicMotion_DigitalCamSwitch_HighPrecision.project is located in the installation directory CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how to use the outputs of SMC_DigitalCamSwitch_HighPrecision to control digital outputs with high time resolution. The EL2258 and ...", 
"body" : "The example BasicMotion_DigitalCamSwitch_HighPrecision.project is located in the installation directory CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how to use the outputs of SMC_DigitalCamSwitch_HighPrecision to control digital outputs with high time resolution. The EL2258 and EL2252 terminals from Beckhoff are used as an example. The device descriptions from Beckhoff are not included in the example. You can download these directly from the vendor and install them in the device repository. To run the example, you need an EK1100 bus coupler, an EL2258 terminal, and an EL2252 terminal. This example was developed and tested according to Revision 0017 of EL2258 and Revision 0020 of EL2252. It serves only as an example. We do not guarantee the correctness. The source code must be tested before use. If necessary, it must be modified to other revisions of the terminals. " }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856510750361", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Cams \/ Using MC_DigitalCamSwitch_HighPrecision \/ Structure of the application ", 
"snippet" : "The application consists of a Main program, the DigitalCamSwitch_EL2258 and DigitalCamSwitch_EL2252 function blocks, and an EK1100 bus coupler with the EL2258 and EL2252 output terminals. The DigitalCamSwitch_EL2258 and DigitalCamSwitch_EL2252 function blocks are the essential parts of the example. ...", 
"body" : "The application consists of a Main program, the DigitalCamSwitch_EL2258 and DigitalCamSwitch_EL2252 function blocks, and an EK1100 bus coupler with the EL2258 and EL2252 output terminals. The DigitalCamSwitch_EL2258 and DigitalCamSwitch_EL2252 function blocks are the essential parts of the example. They show how to use the Events output of SMC_DigitalCamSwitch_HighPrecision to program digital outputs. The function blocks should be understood as examples which can be adapted to other hardware. " }, 
{ "title" : "DigitalCamSwitch_EL2258 ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856513787236", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Cams \/ Using MC_DigitalCamSwitch_HighPrecision \/ Structure of the application \/ DigitalCamSwitch_EL2258 ", 
"snippet" : "The function block works as follows: The function block is initialized on a rising edge at the Enable input. In the STATE_INIT_0 and STATE_INIT_1 states, the OutputBufferReset signals of the EL2258 terminal are written and the aLastEventIds array is initialized. The ID of the last processed event fo...", 
"body" : "The function block works as follows: The function block is initialized on a rising edge at the Enable input. In the STATE_INIT_0 and STATE_INIT_1 states, the OutputBufferReset signals of the EL2258 terminal are written and the aLastEventIds array is initialized. The ID of the last processed event for each track is saved in this array. This prevents an event from being transferred to the terminal multiple times. Once initialized ( STATE_ACTIVE ), all tracks are processed in turn, and the following logic is performed for each track: Check whether the EL2258 terminal has already accepted the last commanded events ( ChannelsIn[channel].OutputOrderFeedback = ChannelsOut[channel].OutputOrderCounter ). Loop through all events of the track. Only those events whose ToggleEventId is greater than the last ID processed are considered further. (Query EventId_GreaterThan(event^.ToggleEventId, aLastEventIds[channel]) ) See section: \"Note on the event order\". Convert the Duration of the event into an EtherCAT timestamp and corresponding write of the ChannelsOut[channel].OutputEventState and ChannelsOut[channel].OutputEventTime outputs. Abort the processing after a maximum of 5 events. Notify the terminal that new events exists if at least one event has been found ( ChannelsOut[channel].OutputOrderCounter := ChannelsOut[channel].OutputOrderCounter + 1 ). Note on the event order The events are returned by the SMC_DigitalCamSwitch_HighPrecision function block for each track in an array. The SwitchNumber and a ToggleEventId are returned for each event. This ToggleEventId is unique and ascending for each track. For more information, see: SMC_CAMSWITCH_TOGGLE_EVENT . In the example, the aLastEventIds[trackNo] array stores for each track which ToggleEventId was last transferred to the terminal in a previous function block call. Because the ToggleEventIds are in ascending order, the next call will know exactly which events still need to be transferred. Two details still need to be considered: Because it is not known at which ToggleEventId the events start, a valid flag is saved in the EventId data type in addition to the ID. For the EventId_GreaterThan comparison, this valid flag is taken into account accordingly. The ToggleEventIds have the 32-bit data type UDINT and can therefore, in principle, overflow with a respectively long runtime or high switching frequency. The value then goes from 2^32-1 back to 0. The comparison function EventId_GreaterThan also takes 32-bit overflows into account. PDO Mapping EL2258 The ChannelsOut and ChannelsIn outputs of the DigitalCamSwitch_EL2258 function block are connected to the respective I\/O channels of the EL2258 terminal. The following image shows the mappings for Channel 1. Channel 2 is similar; only when accessing ChannelsOut and ChannelsIn the index is 2, not 1. " }, 
{ "title" : "DigitalCamSwitch_EL2252 ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234861434780928", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Cams \/ Using MC_DigitalCamSwitch_HighPrecision \/ Structure of the application \/ DigitalCamSwitch_EL2252 ", 
"snippet" : "The basic principle is identical to DigitalCamSwitch_EL2258 . The difference is in how the signals are written because the EL2252 terminal can program only one active event. First, the function block is initialized in STATE_INIT . Then STATE_CHECK_FOR_EVENT checks whether events from the SMC_Digital...", 
"body" : "The basic principle is identical to DigitalCamSwitch_EL2258 . The difference is in how the signals are written because the EL2252 terminal can program only one active event. First, the function block is initialized in STATE_INIT . Then STATE_CHECK_FOR_EVENT checks whether events from the SMC_DigitalCamSwitch_HighPrecision function block are pending. If an event is available, then the event must be programmed within two cycles: The outputs and the EtherCAT timestamp are written in the first cycle. The Activate output is set to 0. In the second cycle, the Activate output is set to 3 in STATE_ACTIVATE_EVENT_IN_EL2252 . This activates the event in the terminal. In STATE_WAIT_UNTIL_THE_INPUTS_MATCH_THE_OUTPUTS , the system then waits until the event has been executed. The signals from the Feedback input of the terminal are used for this. PDO Mapping EL2252 " }, 
{ "title" : "Main ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234861434889277", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Cams \/ Using MC_DigitalCamSwitch_HighPrecision \/ Structure of the application \/ Main ", 
"snippet" : "In the main program, four switches are configured (two on each track). The tracks also have different on\/off compensations ( OnComp , OffComp ): The program includes the necessary function block calls to activate a forecast for the axis and to move it constantly at 180°\/s (*), as well as for SMC_Dig...", 
"body" : "In the main program, four switches are configured (two on each track). The tracks also have different on\/off compensations ( OnComp , OffComp ): The program includes the necessary function block calls to activate a forecast for the axis and to move it constantly at 180°\/s (*), as well as for SMC_DigitalCamSwitch_HighPrecision , DigitalCamSwitch_EL2258 , and DigitalCamSwitch_EL2252 . Before starting the movement, the fieldbus must be fully powered up. Otherwise the events cannot be transmitted to the terminal. (*) Constant movement was chosen to keep the example simple and clear. However, the SMC_DigitalCamSwitch_HighPrecision function block works with all types of movements. For example, it also provides exact timestamps during an acceleration phase or with cams. " }, 
{ "title" : "Commissioning ", 
"url" : "_sm_usage_mc_digitalcamswitch_highprecision.html#UUID-37d48f4d-7bd9-5b97-19f3-a0006eb84421_section-idm234856511865803", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Cams \/ Using MC_DigitalCamSwitch_HighPrecision \/ Commissioning ", 
"snippet" : "Build the application and download it to a controller. Start the application....", 
"body" : "Build the application and download it to a controller. Start the application. " }, 
{ "title" : "Exporting and Importing Cams ", 
"url" : "_sm_example_cams_export_import.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Cams \/ Exporting and Importing Cams ", 
"snippet" : "The BasicMotion_CamExportAndImport.project sample project is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The example shows how to export and import a cam....", 
"body" : "The BasicMotion_CamExportAndImport.project sample project is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The example shows how to export and import a cam. " }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_example_cams_export_import.html#UUID-a44eacc8-df29-93b8-408e-06aec7d8a9f5_section-idm235085906313629", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Cams \/ Exporting and Importing Cams \/ Structure of the application ", 
"snippet" : "The application consists of the PLC_PRG program and a CamEditor cam. PLC_PRG The program consists of a simple state machine where a cam is created in IEC code in the STATE_CREATE_CAM state. For more information, see the following: Creating Cams Programmatically. Then this cam is exported in the STAT...", 
"body" : "The application consists of the PLC_PRG program and a CamEditor cam. PLC_PRG The program consists of a simple state machine where a cam is created in IEC code in the STATE_CREATE_CAM state. For more information, see the following: Creating Cams Programmatically. Then this cam is exported in the STATE_EXPORT_CAM state using the SMC_WriteCAM function block and then imported in the STATE_START_IMPORT_CAM state using the SMC_ReadCAM function block. CamEditor The cam does not have any meaning at first because it is not used in the application. The exported cam from PLC_PRG can be imported into the cam editor. This is a manual step which is described in the following section. " }, 
{ "title" : "Commissioning ", 
"url" : "_sm_example_cams_export_import.html#UUID-a44eacc8-df29-93b8-408e-06aec7d8a9f5_section-idm23508590648994", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Cams \/ Exporting and Importing Cams \/ Commissioning ", 
"snippet" : "Build the application and download it to a controller. Start the application. The PLC_PRG program generates the cam and exports it to the PlcLogic directory of the controller. You can also display and edit the exported cam in the cam editor. To do this, open the CamEditor cam and import the cam usin...", 
"body" : "Build the application and download it to a controller. Start the application. The PLC_PRG program generates the cam and exports it to the PlcLogic directory of the controller. You can also display and edit the exported cam in the cam editor. To do this, open the CamEditor cam and import the cam using the Read Cam Online File command. After you have made changes, you can export the modified cam using the Write Cam Online File command. This cam can be read into the IEC code with the SMC_ReadCAM function block and used in the application. " }, 
{ "title" : "Velocity Override for SoftMotion Axes ", 
"url" : "_sm_example_override.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Velocity Override for SoftMotion Axes ", 
"snippet" : "The BasicMotion_Override.project sample project described here is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how to define a velocity override for a SoftMotion axis. For more information about override, see: Dynamic Adaptation with MC_S...", 
"body" : "The BasicMotion_Override.project sample project described here is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how to define a velocity override for a SoftMotion axis. For more information about override, see: Dynamic Adaptation with MC_SetOverride" }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_example_override.html#UUID-ba001b0a-d3fc-8a58-4f4f-ec6aee022bd0_section-idm4552520462032034028650702932", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Velocity Override for SoftMotion Axes \/ Structure of the application ", 
"snippet" : "The application consists of a PLC_PRG program and a Trace . PLC_PRG The program consists of a simple state machine. In the first state STATE_POWER , the virtual axis Drive is initialized. In the second state STATE_COMMAND_MOVEMENT , a velocity override of 0.5 is set so that the movements of the axis...", 
"body" : "The application consists of a PLC_PRG program and a Trace . PLC_PRG The program consists of a simple state machine. In the first state STATE_POWER , the virtual axis Drive is initialized. In the second state STATE_COMMAND_MOVEMENT , a velocity override of 0.5 is set so that the movements of the axis are executed only at half velocity. A movement is then executed using MC_MoveAbsolute to position 10. A maximum velocity of 20 units\/s is specified in the function block. Due to the velocity override which is set in the virtual axis, the movement is executed at a maximum velocity of 10 units\/s. As soon as half of the movement is completed at position 5, the velocity override is reduced to 0.25 in the STATE_CHANGE_OVERRIDE state. The axis decelerates to 5 units\/s and performs the rest of the movement at this velocity. The active override factors (velocity, acceleration, and jerk) of the virtual axis are also read in the program. The SMC_GetOverride function block is used for this. Trace The trace can be used to track the movement of the virtual axis. The currently specified position, the velocity, and the acceleration of the axis and the active velocity override are recorded. " }, 
{ "title" : "Commissioning ", 
"url" : "_sm_example_override.html#UUID-ba001b0a-d3fc-8a58-4f4f-ec6aee022bd0_section-idm4563439233780834028650966211", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Velocity Override for SoftMotion Axes \/ Commissioning ", 
"snippet" : "Build the application and download it to a controller. Start the trace and the application. In the trace, you can track the movement of the virtual axis....", 
"body" : "Build the application and download it to a controller. Start the trace and the application. In the trace, you can track the movement of the virtual axis. " }, 
{ "title" : "Distance-Based Ramping ", 
"url" : "_sm_axis_based_ramp_in.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Distance-Based Ramping ", 
"snippet" : "The BasicMotion_CamIn_StartModes.project sample project described here is located in the installation directory of CODESYS under the ..\\CODESYS SoftMotion\\Examples directory. This example shows how to use the StartMode input of the MC_CamIn function block. This input is used to configure how the sla...", 
"body" : "The BasicMotion_CamIn_StartModes.project sample project described here is located in the installation directory of CODESYS under the ..\\CODESYS SoftMotion\\Examples directory. This example shows how to use the StartMode input of the MC_CamIn function block. This input is used to configure how the slave axis is synchronized with the master axis when MC_CamIn is started. Basically, there are three possible ways: The slave axis immediately follows the trajectory specified by the cam and the master axis. Depending on the start status of the slave axis, this can lead to a jump in position, velocity, and\/or acceleration of the slave axis. StartMode : absolute , relative The slave axis synchronizes as quickly as possible while maintaining the predefined velocity, acceleration, deceleration, and jerk limits.  StartMode : ramp_in , ramp_in_pos , ramp_in_neg A master position is specified in the cam where the slave axis should follow the trajectory as specified by the cam and the master axis. Synchronization takes place over a configurable distance from the master axis. StartMode : ramp_in_dist For more information about the MC_CamIn function block, see: MC_CamIn (FB) " }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_axis_based_ramp_in.html#UUID-08122319-fcc2-39b9-d37e-80454ce1f88b_section-idm4561064201451234280796827706", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Distance-Based Ramping \/ Structure of the application ", 
"snippet" : "The application consists of a PLC_PRG program and a Trace. Moreover, there are four virtual axes: the master axis Master and the three slave axes SlaveAbsolute , SlaveRampIn , and SlaveRampInDist . And there is the cam Cam . In the PLC_PRG program, three instances of MC_CamIn are executed with the S...", 
"body" : "The application consists of a PLC_PRG program and a Trace. Moreover, there are four virtual axes: the master axis Master and the three slave axes SlaveAbsolute , SlaveRampIn , and SlaveRampInDist . And there is the cam Cam . In the PLC_PRG program, three instances of MC_CamIn are executed with the StartMode input set differently: ciSlaveAbsolute with StartMode = absolute ciSlaveRampIn with StartMode = ramp_in ciSlaveRampInDist with StartMode = ramp_in_dist The function block instances control the corresponding virtual axes SlaveAbsolute , SlaveRampIn , and SlaveRampInDist . The master axis is moved at a constant velocity using an MC_MoveVelocity instance. The trajectories of the three slave axes and the Active and InSync outputs of the MC_CamIn instances can be tracked in the trace. All MC_CamIn instances are started when the master axis exceeds position 40: The SlaveAbsolute axis immediately jumps to the set values defined from the cam. The corresponding MC_CamIn instance is immediately Active and InSync . The SlaveRampIn axis synchronizes while maintaining the commanded dynamic limits. The corresponding MC_CamIn instance is immediately Active . From master position ~114 , the slave axis follows the trajectory specified by the cam and the master axis and the MC_CamIn instance reports InSync . The SlaveRampInDist axis first remains stationary until the master axis has approached the MasterSyncPosition of 120 up to the MasterStartDistance of 60 configured on the MC_CamIn instance . Then synchronization begins and the MC_CamIn instance reports Active . When the master axis reaches the MasterSyncPosition of 120 , the slave axis follows the trajectory specified by the cam and the master axis and the MC_CamIn instance reports InSync . " }, 
{ "title" : "Commissioning ", 
"url" : "_sm_axis_based_ramp_in.html#UUID-08122319-fcc2-39b9-d37e-80454ce1f88b_section-idm4602846053456034280814845985", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ Examples \/ Distance-Based Ramping \/ Commissioning ", 
"snippet" : "Build the application and download it to a controller. Start the trace and the application. In the trace, you can track the movement of the virtual axes....", 
"body" : "Build the application and download it to a controller. Start the trace and the application. In the trace, you can track the movement of the virtual axes. " }, 
{ "title" : "User Interface ", 
"url" : "_sm_basic_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ User Interface ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Cam ", 
"url" : "_sm_basic_user_interface_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ User Interface \/ Cam ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Dialog: Properties – Cam ", 
"url" : "_sm_dlg_properties_cam.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ User Interface \/ Cam \/ Dialog: Properties – Cam ", 
"snippet" : "Function : Use this dialog to define the global variables of the cam. Dimensions Master start\/end position The start and end positions of the master define the range of the master values and therefore the scale of the horizontal axis of the cam. The default settings are given in angular degrees with...", 
"body" : "Function : Use this dialog to define the global variables of the cam. Dimensions Master start\/end position The start and end positions of the master define the range of the master values and therefore the scale of the horizontal axis of the cam. The default settings are given in angular degrees with 0 and 360 as limiting values. Slave start\/end position The associated slave positions are determined by the graph type that is defined for the cam. However, the segment depicted by the curves (this is also the scale of the vertical axis) can be defined by the start and end positions of the slave that are given here. Period These settings affect the work in the cam editor and cam table. Depending on these parameters, the slave starting point is adjusted automatically when the end point is changed, as well as the other way around. This adjustment optimizes the period transition to be as smooth and jerk-free as possible. Smooth transition : The values for position, velocity, and acceleration are adjusted automatically. Slave period Indicates when the slave period is repeated mechanically. Then the slave position at the start and end of the master period may deviate by one integer multiple of this value. This value is effective only if the Smooth transition check box is selected. Continuity Requirements Activation of these options for the continuity of the curve does not have any effect when editing the cam. However, it does prompt a continuity check, which reports any violations to the message view ( CAM category). It is not possible to edit jumps in the position curve. The default setting also requires the continuity of velocity and acceleration. You can clear these options, for example in the special case of a curve that consists of only linear segments. However, this can lead to breaks in the position curve. By default, the jerk (4th derivative) is not tested for jumps. Position : The curve is checked for jumps. Velocity Acceleration Jerk Compile Format When compiling, MC_CAM_REF structure variables are generated. A cam is described according to the following options: polynomial (XYVA) Polynomial description of the individual points, consisting of master position, slave position, slave velocity, and slave acceleration. one dimensional point array 1D table of slave positions two dimensional point array 2D table of composite master\/slave positions Elements Number of elements for the 1- or 2-dimensional point arrays. This array has already been created in SM3_Basic for the standard cases 128 and 256 . If you type in another value, then you need to create the structure in your application. See the following example for this. Segments Standard compile format; supports all segment types Example of an array with 720 elements TYPE SMC_CAMTable_LREAL_720_2 :\nSTRUCT\n Table: ARRAY[0..719] OF ARRAY[0..1] OF LREAL;\n fEditorMasterMin, fEditorMasterMax: REAL;\n fEditorSlaveMin, fEditorSlaveMax: REAL;\n fTableMasterMin, fTableMasterMax: REAL;\n fTableSlaveMin, fTableSlaveMax: REAL;\nEND_STRUCT\nEND_TYPE For more information, see: How to create a cam" }, 
{ "title" : "Command: Display Generated Code ", 
"url" : "_sm_cmd_cam_display_generated_code.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ User Interface \/ Cam \/ Command: Display Generated Code ", 
"snippet" : "Display Generated Code Function : The command opens the Generated Code dialog where the IEC initialization code of the represented cam is displayed. Call : Cam menu Requirement : The cam editor is open and displays a cam. No generated code is displayed for the Segments compile format. The generated ...", 
"body" : "Display Generated Code Function : The command opens the Generated Code dialog where the IEC initialization code of the represented cam is displayed. Call : Cam menu Requirement : The cam editor is open and displays a cam. No generated code is displayed for the Segments compile format. The generated code is no longer necessary because the CamBuilder API can be used to programmatically generate cams in a better way. Dialog: Generated Code Example: IEC initialization code {attribute 'linkalways'}\n\nVAR_GLOBAL\nCam_A: ARRAY[0..3] OF SMC_CAMXYVA := [\n (dX := 0, dY := 0, dV := 0, dA := 0),\n (dX := 120, dY := 120, dV := 1, dA := 0),\n (dX := 240, dY := 240, dV := 1, dA := 0),\n (dX := 360, dY := 360, dV := 0, dA := 0)];\nCam: MC_CAM_REF := (nElements := 4, byType := 3, xStart := 0, xEnd := 360, nTappets := 0, strCAMName := 'Cam', pce := ADR(Cam_A), xPartofLM := TRUE);\nEND_VAR " }, 
{ "title" : "Command: Read Cam Data from ASCII Table ", 
"url" : "_sm_cmd_cam_read_data_from_ascii_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ User Interface \/ Cam \/ Command: Read Cam Data from ASCII Table ", 
"snippet" : "Read Cam Data from ASCII Table Function : The command reads an ASCII file. Call : Cam menu Requirement : The cam editor is open. When being read, the file data is interpreted as the X\/Y-values of a cam. The Number of points dialog opens so that you can decrease the number of interpolation points. Th...", 
"body" : "Read Cam Data from ASCII Table Function : The command reads an ASCII file. Call : Cam menu Requirement : The cam editor is open. When being read, the file data is interpreted as the X\/Y-values of a cam. The Number of points dialog opens so that you can decrease the number of interpolation points. Then the determined points are interpolated to a cam and displayed in the editor. The Write Cam Data to ASCII Table commands creates an appropriate TXT file. " }, 
{ "title" : "Dialog: Number of Points ", 
"url" : "_sm_cmd_cam_read_data_from_ascii_table.html#UUID-dc22ffbd-b76b-ca74-a92b-235fbf0143cb_id_d53fe1240e8dd1c0a8640e0032565c_id_b03dff25496d07f6c0a8646340c5ba9e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ User Interface \/ Cam \/ Command: Read Cam Data from ASCII Table \/ Dialog: Number of Points ", 
"snippet" : "Number of Points Number of points used for interpolation. Preset: According to the number of X\/Y-values that are stored in the read file. Example: 256 You can decrease the preset value in order to determine the cam with fewer interpolation points. When determining the interpolation points, their X-v...", 
"body" : "Number of Points Number of points used for interpolation. Preset: According to the number of X\/Y-values that are stored in the read file. Example: 256 You can decrease the preset value in order to determine the cam with fewer interpolation points. When determining the interpolation points, their X-values are distributed equidistantly. As the cam is interpolated using a 5th degree polynomial, a larger number of interpolation points may cause oscillations. " }, 
{ "title" : "Command: Write Cam Data to ASCII Table ", 
"url" : "_sm_cmd_cam_write_data_into_ascii_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ User Interface \/ Cam \/ Command: Write Cam Data to ASCII Table ", 
"snippet" : "Write Cam Data to ASCII Table Function : The command creates an ASCII file ( TXT extension) on the development system. A specified number of X\/Y-values of the active cam is saved in this file. A default dialog opens first and then the Number of points dialog. Call : Cam menu Requirement : The cam ed...", 
"body" : "Write Cam Data to ASCII Table Function : The command creates an ASCII file ( TXT extension) on the development system. A specified number of X\/Y-values of the active cam is saved in this file. A default dialog opens first and then the Number of points dialog. Call : Cam menu Requirement : The cam editor is open and displays a cam. " }, 
{ "title" : "Dialog: Number of Points ", 
"url" : "_sm_cmd_cam_write_data_into_ascii_table.html#UUID-b84e5af8-679e-916c-e8a6-2358c4cccb5c_id_c2bdaa8241199e2c0a8640e018c7af7_id_b03dff25496d07f6c0a8646340c5ba9e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ User Interface \/ Cam \/ Command: Write Cam Data to ASCII Table \/ Dialog: Number of Points ", 
"snippet" : "The ASCII table does not contain any information about cams. Number of Points Number of X\/Y-values that are saved in the file and represented in the curve shape. For this purpose, the X-curve is split equidistantly and the respective Y-value is determined....", 
"body" : "The ASCII table does not contain any information about cams. Number of Points Number of X\/Y-values that are saved in the file and represented in the curve shape. For this purpose, the X-curve is split equidistantly and the respective Y-value is determined. " }, 
{ "title" : "Command: Read Cam Online File ", 
"url" : "_sm_cmd_cam_read_online_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ User Interface \/ Cam \/ Command: Read Cam Online File ", 
"snippet" : "Read Cam Online File Function : The command reads an external file with cam data. The file extension is CAM . The cam is displayed in the cam editor. Call : Cam menu Requirement : The cam editor is open. The Write Cam Online File command creates an appropriate file in CAM format....", 
"body" : "Read Cam Online File Function : The command reads an external file with cam data. The file extension is CAM . The cam is displayed in the cam editor. Call : Cam menu Requirement : The cam editor is open. The Write Cam Online File command creates an appropriate file in CAM format. " }, 
{ "title" : "Command: Write Cam Online File ", 
"url" : "_sm_cmd_cam_write_online_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS Softmotion Basic \/ User Interface \/ Cam \/ Command: Write Cam Online File ", 
"snippet" : "Write Cam Online File Function : The command creates a file ( CAM extension). The file contains the data of the cam that is active in the editor. Call : Cam menu Requirement : The cam editor is open and displays a cam. The cam data is composed of a cam description and the positions and types of cams...", 
"body" : "Write Cam Online File Function : The command creates a file ( CAM extension). The file contains the data of the cam that is active in the editor. Call : Cam menu Requirement : The cam editor is open and displays a cam. The cam data is composed of a cam description and the positions and types of cams. A CAM file can be read to the editor by means of the Read cam online file command. In addition, an instance of the SMC_ReadCAM function block can read the file in order to load a cam table into the application at runtime. For more information, see: Data structures of cams" }, 
{ "title" : "CODESYS SoftMotion CNC ", 
"url" : "_sm_f_cnc.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Editor ", 
"url" : "_sm_f_cnc_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Overview ", 
"url" : "_sm_overview_cnc_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Overview ", 
"snippet" : "In the CNC editor, you implement complex multidimensional motion in the tabular editor or text editor according to the CNC language of DIN 66025. In addition, the editor provides the following: Graphical editor for showing the path Toolbox for the graphical editor View with properties of the selecte...", 
"body" : "In the CNC editor, you implement complex multidimensional motion in the tabular editor or text editor according to the CNC language of DIN 66025. In addition, the editor provides the following: Graphical editor for showing the path Toolbox for the graphical editor View with properties of the selected path element " }, 
{ "title" : "CNC Editor Fundamentals ", 
"url" : "_sm_cnc_edt_basics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ CNC Editor Fundamentals ", 
"snippet" : "With DIN 66025, you can create up to 9-dimensional paths. Three of these dimensions are not interpolated linearly. In X\/Y\/Z, you can program lines, arcs, ellipses, parabolas, and splines. Another eight additional axes are provided. Of these, five are interpolated linearly (P\/Q\/U\/V\/W) and three with ...", 
"body" : "With DIN 66025, you can create up to 9-dimensional paths. Three of these dimensions are not interpolated linearly. In X\/Y\/Z, you can program lines, arcs, ellipses, parabolas, and splines. Another eight additional axes are provided. Of these, five are interpolated linearly (P\/Q\/U\/V\/W) and three with a 3rd degree polynomial (A\/B\/C). For each motion block in the CNC program, the interpolator computes the traverse path. At the same time, the interpolator computes the shape of the path, velocity, acceleration, and jerk according to the specified interpolation. For each programmed path, CODESYS creates a global data structure automatically with the CNC data that can be used in an IEC program. There are different options for this purpose: SMC_CNC_REF : The CNC program is saved as an array of G code words that are processed at application runtime by means of SMC_NCInterpreter . The result is the CNC path described as a sequence of GEOINFO structure objects. By means of path preprocessing modules from the SM3_CNC library (example: tool radius correction), these objects can be edited, interpolated, transformed, and transferred from the drive interface to the hardware for communication. SMC_OUTQUEUE : The CNC program is written to a data structure as a list of GEOINFO structure objects with the name SMC_OUTQUEUE , and it can then be input directly into the interpolator. As a result, in contrast to SMC_CNC_REF , the interpreter function block and the path preprocessing function blocks do not have to be called. However, the program cannot be changed at runtime and no variables in G code can be used in this mode. FILE : Then the CNC program is saved as an ASCII file in the file system of the controller and read and implemented step by step. This method is appropriate especially for large programs that cannot be stored entirely in the memory. It is also appropriate for programs that were generated by the user after compiling the controller application. " }, 
{ "title" : "Structure of the CNC editor ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_43423fe2e9a24fa0c0a864632228473f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ CNC Editor Fundamentals \/ Structure of the CNC editor ", 
"snippet" : "The CNC editor consists of the following components: Main editor: The text editor shows the DIN 66025 program, or the tabular editor shows the CNC path. Graphical editor: The graphical view of the path is shown here. Properties view of the CNC elements Toolbox view: Contains tools for selecting and ...", 
"body" : "The CNC editor consists of the following components: Main editor: The text editor shows the DIN 66025 program, or the tabular editor shows the CNC path. Graphical editor: The graphical view of the path is shown here. Properties view of the CNC elements Toolbox view: Contains tools for selecting and inserting path elements When you press the F6 key, the focus toggles between the main editor and the graphical editor. If a path element is selected in the graphical editor, then the respective motion block or line is selected implicitly in the text editor or tabular editor. Likewise, an element selected in the tabular editor or text editor is also selected in the graphical editor. Changes in the graphical editor are applied in the text editor or tabular editor, and the other way around. Application-wide CNC settings are applied and saved in the CNC Settings object. Object-specific CNC settings are applied and saved in the Properties dialog of the CNC object. " }, 
{ "title" : "SoftMotion software components of the CNC editor ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_92f7df24e9a24fa0c0a864630c4c4560", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ CNC Editor Fundamentals \/ SoftMotion software components of the CNC editor ", 
"snippet" : "(1) CNC editor (2) IEC program (3) Parameter (4) Interpreter (5) GeoInfo (6) Path preprocessing (7) Interpolator (8) Path points (9) Cartesian coordinates (10) Direct kinematics (11) Machine-specific transformation (12) Inverse kinematics (13) Axis position (14) Drive interface...", 
"body" : "(1) CNC editor (2) IEC program (3) Parameter (4) Interpreter (5) GeoInfo (6) Path preprocessing (7) Interpolator (8) Path points (9) Cartesian coordinates (10) Direct kinematics (11) Machine-specific transformation (12) Inverse kinematics (13) Axis position (14) Drive interface " }, 
{ "title" : "Compiling CNC objects ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_c0635f14eddc9007c0a8646316c80481", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ CNC Editor Fundamentals \/ Compiling CNC objects ", 
"snippet" : "The Compile mode is selected when adding a new CNC object, and if necessary it can be changed in the Properties dialog ( CNC tab of the CNC object). Depending on the Compile mode , a SMC_OutQueue function block, SMC_CNC_REF function block, or an ASCII file with the programmed CNC path is created at ...", 
"body" : "The Compile mode is selected when adding a new CNC object, and if necessary it can be changed in the Properties dialog ( CNC tab of the CNC object). Depending on the Compile mode , a SMC_OutQueue function block, SMC_CNC_REF function block, or an ASCII file with the programmed CNC path is created at compile time. If the Exclude from build option is selected in the Properties dialog on the Build tab of the CNC object, then no IEC data is generated. In compile mode File , no data is downloaded to the controller. " }, 
{ "title" : "Opening a CoDeSys V2.3 Projects ", 
"url" : "_sm_cnc_edt_basics.html#UUID-f2f5f035-2553-0f0d-22c1-6c707a14c14f_id_ce62e89e2e60c0a864631012dfca_id_88cb0aeee9a24fa0c0a864634f00b359", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ CNC Editor Fundamentals \/ Opening a CoDeSys V2.3 Projects ", 
"snippet" : "When you open a CoDeSys V2.3 project in CODESYS , a converter is provided to execute the following functions as long as a SoftMotion controller is used: Every CNC program is converted into a CNC object with the same name and implementation type DIN 66025. The compile mode, the queue size, and the st...", 
"body" : "When you open a CoDeSys V2.3 project in CODESYS , a converter is provided to execute the following functions as long as a SoftMotion controller is used: Every CNC program is converted into a CNC object with the same name and implementation type DIN 66025. The compile mode, the queue size, and the start position of the converted program are also applied as the status of the step suppression. If the Exclude from build option is selected in the CNC program of the CoDeSys V2.3 project, then this option is accepted. The CNC settings object is generated automatically. All CNC objects are listed below a SoftMotion-capable application. " }, 
{ "title" : "Creating a CNC Program ", 
"url" : "_sm_cnc_creating_cnc_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Creating a CNC Program ", 
"snippet" : "Select an application in the device tree. Click Project → Add Object → CNC Program . Specify a name in the Add CNC program dialog and select an Implementation from the list box: DIN 66025 : To create your program in the text editor Table : To create your program in the tabular editor Select a Compil...", 
"body" : "Select an application in the device tree. Click Project → Add Object → CNC Program . Specify a name in the Add CNC program dialog and select an Implementation from the list box: DIN 66025 : To create your program in the text editor Table : To create your program in the tabular editor Select a Compile mode to determine behavior when compiling: SMC_OutQueue : An SMC_OutQueue data structure is generated on compile. You are granted global access by means of g_CNCQueueManager (SMC_OutQueue). SMC_CNC_REF : Program variables are generated on compile. You are granted global access by means of g_CNCProgManager (SMC-CNC_REF) in an IEC program. FILE : A file generated by G code is downloaded and updated at each login. The PLC can download this file by means of function blocks. You can change the Implementation and Compile mode later in the Properties dialog ( CNC tab of the CNC program). Click Add . The CNC object is inserted into the device tree and opened in the editor. " }, 
{ "title" : "Programming a Path according to DIN 66025 ", 
"url" : "_sm_cnc_programming_din_66025.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Programming a Path according to DIN 66025 ", 
"snippet" : "SoftMotion supports parts of the CNC language DIN 66025 which allows for the programming of geometric paths in the editor of a CNC object. The DIN 66025 editor of the CNC object (also: CNC text editor) is provided for programming in the DIN 66025 CNC language. Requirement: A CNC program object is op...", 
"body" : "SoftMotion supports parts of the CNC language DIN 66025 which allows for the programming of geometric paths in the editor of a CNC object. The DIN 66025 editor of the CNC object (also: CNC text editor) is provided for programming in the DIN 66025 CNC language. Requirement: A CNC program object is open with DIN 66025 implementation. Set the cursor in the blank line. Enter the G code blocks line by line in the editor. When you have entered a block (example: N10 G01 X100 Y100 E100 F100 E-200 ), the path element is shown immediately in the graphical editor. This is where you can use the operating field to change the view and the view direction on the different axes. If you select the path element in the graphical editor, then its properties are shown in the Properties view. For more information, see: DIN 66025 Fundamentals" }, 
{ "title" : "Programming a Path in the Tabular Editor ", 
"url" : "_sm_cnc_programming_table_editor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Programming a Path in the Tabular Editor ", 
"snippet" : "Requirement: A CNC program object is created with the Table implementation, and the object is open in the tabular editor ....", 
"body" : "Requirement: A CNC program object is created with the Table implementation, and the object is open in the tabular editor . " }, 
{ "title" : "Inserting elements ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f56fa52f4ccd11e69d4cb2db330b91fd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Programming a Path in the Tabular Editor \/ Inserting elements ", 
"snippet" : "Double-click the Empty cell in the Type column. Select an element from the list box and press the Enter key. If it is the first element in the table, then the fields are populated with the initial values of the element. Otherwise, the element receives the values from the element of the previous line...", 
"body" : "Double-click the Empty cell in the Type column. Select an element from the list box and press the Enter key. If it is the first element in the table, then the fields are populated with the initial values of the element. Otherwise, the element receives the values from the element of the previous line. All other fields remain shaded in gray and the element is shown in the graphical editor. The last line of the table is a blank line with the type Empty . To add another element, you can also click the Insert element command in the context menu of a table entry. " }, 
{ "title" : "Changing a table entry ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f568c7504ccd11e69d4cb2db330b91fd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Programming a Path in the Tabular Editor \/ Changing a table entry ", 
"snippet" : "Double-click a table entry of an element. The field is editable or there is a symbol for a list box. The element is marked in red in the graphical editor. Change the value of the table entry. The change is shown in the graphical editor. If you click the command Apply value to all elements in the con...", 
"body" : "Double-click a table entry of an element. The field is editable or there is a symbol for a list box. The element is marked in red in the graphical editor. Change the value of the table entry. The change is shown in the graphical editor. If you click the command Apply value to all elements in the context menu of the table entry, then the current value is applied in all other entries of the same column. Requirement: The value can be used for the respective element type. The line number cannot be edited. " }, 
{ "title" : "Deleting an element ", 
"url" : "_sm_cnc_programming_table_editor.html#UUID-e58d7f63-65d2-b177-a613-2d9fe29a2b1c_id_b9f3fe2bfcb119f8c0a864637d0c7413_id_f0684d0502561eafc0a864633d0e8542", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ Programming a Path in the Tabular Editor \/ Deleting an element ", 
"snippet" : "Select a line of the table and click the command Remove element in the context menu. The last line of the table with the type Empty cannot be deleted....", 
"body" : "Select a line of the table and click the command Remove element in the context menu. The last line of the table with the type Empty cannot be deleted. " }, 
{ "title" : "CNC Data Structures and Global Access ", 
"url" : "_sm_cnc_data_structure_global_access.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ CNC Data Structures and Global Access ", 
"snippet" : "The CNC objects available in the project are compiled in function blocks of type SMC_OUTQUEUE or SMC_CNC_REF . (This does not happen when the compile method FILE is used.) When the project is compiled, the created CNC data is managed internally in the SMC_CNC_Data function blocks. For compile mode S...", 
"body" : "The CNC objects available in the project are compiled in function blocks of type SMC_OUTQUEUE or SMC_CNC_REF . (This does not happen when the compile method FILE is used.) When the project is compiled, the created CNC data is managed internally in the SMC_CNC_Data function blocks. For compile mode SMC_OutQueue , each CNC element is represented by a SMC_OUTQUEUE function block. For compile mode SMC_CNC_REF , a CNC element is represented by SMC_CNC_REF . While the IEC program is processed, the function blocks are instantiated and populated with values that can be processed in IEC programs. All of these POUs are contained in SM3_CNC . " }, 
{ "title" : "Global access to CNC data ", 
"url" : "_sm_cnc_data_structure_global_access.html#UUID-aaee586d-72f4-405c-8bb5-b4b2cb32f52d_id_cb8536efda52bb5c0a8646375871841_id_4fd460ed02599820c0a864633ab223de", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Editor \/ CNC Data Structures and Global Access \/ Global access to CNC data ", 
"snippet" : "During initialization, the type and number of generated objects are ascertained from the CNC program. All of these objects are listed together in an global data structure that is declared implicitly. Objects of type SMC_OUTQUEUE are listed in the global data object g_CNCQueueManager with the propert...", 
"body" : "During initialization, the type and number of generated objects are ascertained from the CNC program. All of these objects are listed together in an global data structure that is declared implicitly. Objects of type SMC_OUTQUEUE are listed in the global data object g_CNCQueueManager with the property Count and the method GetOutQueue(int n) . Objects of type SMC_CNC_REF are listed in the global data object g_CNCProgManager with the property Count and the method GetProgram(int n) . The user can now access it in an IEC program. Example Access to data objects of the structure SMC_OUTQUEUE PROGRAM CNCManageQueue\nVAR\n pCNC_OutQueue : POINTER TO SMC_OUTQUEUE;\n n: INT;\n i: INT;\nEND_VAR\n\nn := g_CNCQueueManager.Count;\nFOR i:= 0 to n-1 DO\n pCNC_OutQueue := g_CNCQueueManager.GetOutQueue(I);\n (* calculate pCNC_OutQueue *)\nEND_FOR Access to data objects of the structure SMC_CNC_REF PROGRAM CNCManageRef\nVAR\n pCNC_Ref: POINTER TO SMC_CNC_REF;\n n: INT;\nEND_VAR\n\nn := g_CNCProgManager.Count;\nFOR i:= 0 to n-1 DO\n pCNC_Ref := g_CNCProgManager.GetProgram(I);\n (* calculate pCNC_Ref *)\nEND_FOR " }, 
{ "title" : "Kinematic Transformations ", 
"url" : "_sm_f_cnc_kinematic_transformations.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Forward and Inverse Transformation ", 
"url" : "_sm_cnc_forward_backward_transformation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ Forward and Inverse Transformation ", 
"snippet" : "CODESYS SoftMotion provides function blocks for the mathematical forward and inverse transformation for many popular kinematics. For each kinematic design, two function blocks are available for the transformation. The POU named SMC_TRAFO_<kinematics> calculates the axis position from the position in...", 
"body" : "CODESYS SoftMotion provides function blocks for the mathematical forward and inverse transformation for many popular kinematics. For each kinematic design, two function blocks are available for the transformation. The POU named SMC_TRAFO_<kinematics> calculates the axis position from the position in space (inverse transformation). The POU named SMC_TRAFOF_<kinematics> calculates the position in space from the axis position (forward transformation). You can quickly and easily link the instances of the forward transformation POUs to visualization templates in order to visualize the kinematics. SMC_TRAFOV_ Some of the inverse transformations also use path velocity and path direction to calculate the axis velocities. The names of these transformation POUs begin with SMC_TRAFOV_ instead of SMC_TRAFO_ . These POUs get the path tangent ( v ) and path velocity ( dVel ) as additional inputs from the interpolator. They also return the set velocities ( dvx\/dvy\/dvz ) in addition to the set positions. The advantage is that the lag in the drive can be minimized by input control of the velocity, provided the drive supports this method. To transfer the set velocities to the drive, you should use SMC_ControlAxisByPosVel instead of SMC_ControlAxisByPos in this case. For more information, see: SMC_ControlAxisByPos (FB) , SMC_ControlAxisByVel (FB) , and SMC_ControlAxisByPosVel (FB) " }, 
{ "title" : "5-Axis Transformation ", 
"url" : "_sm_trafo_pou_five_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ 5-Axis Transformation ", 
"snippet" : "With the 5-axis transformation, you can control kinematics that consist of three linear spatial axes (X, Y, Z) and a tool head. The tool head consists of two axes that hold the tool. A tool axis rotates about the Z axis, and the tool tilts the others according to the following scheme. Parameter: Len...", 
"body" : "With the 5-axis transformation, you can control kinematics that consist of three linear spatial axes (X, Y, Z) and a tool head. The tool head consists of two axes that hold the tool. A tool axis rotates about the Z axis, and the tool tilts the others according to the following scheme. Parameter: Length of dTool = Distance from the processing point (tool tip = TCP) to the rotary axis inclination. Control of the 5-axis transformation by five positional values: X\/Y\/Z-position of the processing point (TCP) that is included in pi.dX, pi.dY, pi.dZ . Unit: Position units of the axes. Orientation of the tool by spherical coordinates (inclination and azimuth) that are included in pi.dB and pi.dC . Unit: Angular degrees. Zero position The processing point (TCP) is located at the position ( 0\/0\/-dTool ). The tool extends in the direction of the negative Z axis. The rotary axis inclination is positioned in such a way that rotating in the positive direction would move the tool in the direction of the positive X axis. Example For the movement N30, the inclination axis that first points in the X direction is rotated and it remains tilted in the negative X direction at the end of the movement. N0 PB360 PC360 (set axis B and C in modulo mode 360)\nN10 F10 FB100 FC100 (velocity in X\/Y\/Z: 10, in B and C 100)\nN20 G0 X0 Y0 Z0 C0 B30 (start position)\nN30 G1 X20 B-30 (target position) For more information, see: SMC_TRAFO_5Axes (FB) and SMC_TRAFOF_5Axes (FB) " }, 
{ "title" : "Gantry System ", 
"url" : "_sm_trafo_pou_gantry_system.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ Gantry System ", 
"snippet" : "Gantry systems consist of two or three linear axes that are arranged at right angles. As transformations do not have to be executed in gantry systems, the respective modules for inverse and forward transformations add only one offset to the X, Y, and Z axis in two or three dimensions. For more infor...", 
"body" : "Gantry systems consist of two or three linear axes that are arranged at right angles. As transformations do not have to be executed in gantry systems, the respective modules for inverse and forward transformations add only one offset to the X, Y, and Z axis in two or three dimensions. For more information, see: MC_TRAFO_Gantry2 (FB) SMC_TRAFOF_Gantry2 (FB) SMC_TRAFO_Gantry3 (FB) SMC_TRAFOF_Gantry3 (FB) " }, 
{ "title" : "Gantry System with Axes of Orientation ", 
"url" : "_sm_trafo_pou_gantry_cutter.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ Gantry System with Axes of Orientation ", 
"snippet" : "A \"gantry cutter\" is a gantry system with a rotary axis that is equipped with a cutting tool. The configuration of a gantry system with a rotary axis is similar to that of a simple gantry system. However, these systems also have a rotary axis where the vertical cutting unit is attached. When you use...", 
"body" : "A \"gantry cutter\" is a gantry system with a rotary axis that is equipped with a cutting tool. The configuration of a gantry system with a rotary axis is similar to that of a simple gantry system. However, these systems also have a rotary axis where the vertical cutting unit is attached. When you use a gantry system with a rotary axis, you have to use the SMC_TRAFO<n>_GantryCutter<n> POUs instead of SMC_TRAFO<n>_Gantry<n> . Then the rotary axis is controlled in such as way that it is oriented along the current path tangent. The gantry cutter POUs have the following additional inputs: DriveR : Rotary axis that has to be used with a period of 360° dOffsetR : Offset of the rotary axis iDirectionR : Direction of rotation For more information, see: SMC_TRAFO_GantryCutter2 (FB) SMC_TRAFOF_GantryCutter2 (FB) SMC_TRAFO_GantryCutter3 (FB) SMC_TRAFOF_GantryCutter3 (FB) The POUs for inverse transformation also have to include the vector of the current path tangent (v) that is an output of the interpolator. For more information, see: SMC_TRAFOV_GantryCutter2 (FB) and SMC_TRAFOV_GantryCutter3 (FB) " }, 
{ "title" : "Gantry System with Tool Offset ", 
"url" : "_sm_trafo_pou_gantry_system_tool.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ Gantry System with Tool Offset ", 
"snippet" : "If the axis of the tool has an offset and does not coincide with the Z-axis of the gantry system, then the contact point of the tool does not agree with the X\/Y\/Z-position of the gantry system. If the Z axis cannot be rotated, then the resulting offset of the X and Y coordinates is constant and can ...", 
"body" : "If the axis of the tool has an offset and does not coincide with the Z-axis of the gantry system, then the contact point of the tool does not agree with the X\/Y\/Z-position of the gantry system. If the Z axis cannot be rotated, then the resulting offset of the X and Y coordinates is constant and can be used directly for the standard gantry transformation. If the tool is rotated by the C axis (about Z), then the offset is not constant, but depends on the position of the C axis. In this case, one of two POUs can be selected, depending on the form of the tool: SMC_TRAFO_Gantry2Tool1 and SMC_TRAFOF_Gantry2Tool1 The tool points along the X axis rotated by dAlpha and has a length of dToolA . SMC_TRAFO_Gantry2Tool2 and SMC_TRAFOF_Gantry2Tool2 The tool is partially in the direction of the X axis rotated by dAlpha (length: dToolA ) and partially in the direction of the rotated Y axis (length: dToolB ). In the figure of the following example, the laser is attached with an offset in both the X direction and Y direction. Instead of executing this one-dimensional transformation, the path can also be modulated with a tool offset. At this time, the tool approaches a straight line. The SMC_ToolCorr or SMC_ToolRadiusCorr function blocks are used for this. The difference between these two methods is the velocity of the tool point. If the modulation is used from SMC_ToolCorr , then the velocity of the rotational point is controlled according to the presets in the CNC program (F, E). The velocity of the tool point can fluctuate. If the one-dimensional transformation is used, then the velocity of the tool point is determined by the CNC program. To calculate the orientation of the tool, the SMC_CalcDirectionFromVector POU is used. " }, 
{ "title" : "H-Gantry with Stationary Axes ", 
"url" : "_sm_trafo_pou_h_gantry_stationary_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ H-Gantry with Stationary Axes ", 
"snippet" : "The kinematic configuration is similar to the gantry system, but the axes (drives) are firmly mounted. They move the tool holder by means of a belt. Transformation by means of the SMC_TRAFO_GantryH2 and SMC_TRAFOF_GantryH2 POUs require the following axis configurations. Other configurations can be p...", 
"body" : "The kinematic configuration is similar to the gantry system, but the axes (drives) are firmly mounted. They move the tool holder by means of a belt. Transformation by means of the SMC_TRAFO_GantryH2 and SMC_TRAFOF_GantryH2 POUs require the following axis configurations. Other configurations can be performed by exchanging x and y: This transformation requires a special homing: Both axes have to be moved at the same velocity. If movement should be in the X direction, then drives A and B have to be moved, while they have to moved with reverse velocity for strictly an X-movement. For an X movement only, they have to be moved with an opposing velocity. If the homing is found, then the X and Y values calculated from the forward transformation POU are used as the offset ( dOffsetX and dOffsetY ). " }, 
{ "title" : "T-Gantry with Stationary Axes ", 
"url" : "_sm_trafo_pou_t_gantry_statinary_drives.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ T-Gantry with Stationary Axes ", 
"snippet" : "This kinematic system is similar to H-gantry systems. The drives here are also mounted stationary and the tool holder is moved by means of a belt. The transformations that are executed by the SMC_TRAFO_GantryT2 and SMC_TRAFOF_GantryT2 POUs are designed for the following drive constellations: Note th...", 
"body" : "This kinematic system is similar to H-gantry systems. The drives here are also mounted stationary and the tool holder is moved by means of a belt. The transformations that are executed by the SMC_TRAFO_GantryT2 and SMC_TRAFOF_GantryT2 POUs are designed for the following drive constellations: Note that special homing is necessary for this transformation. If you execute a movement in the X direction, then you have to move the A and B drives at the same velocity. If you execute strictly a Y movement, then the drives have to rotate in opposite directions. If the drive finds the homing position, then the X and Y values calculated from the forward transformation POU are used as the offset ( dOffsetX and dOffsetY ). The SMC_TRAFO_GantryT2_O and SMC_TRAFOF_GantryT2_O function blocks execute the same calculation with the following constellation: " }, 
{ "title" : "Polar System ", 
"url" : "_sm_trafo_pou_polar_system.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ Polar System ", 
"snippet" : "Polar systems consist of a rotational axis (direction) and a linear axis (distance). The origin and the direction of the linear axis can be changed by means of the offsets dPhi and dR . For more information, see: SMC_TRAFO_Polar (FB) and SMC_TRAFOF_Polar (FB)...", 
"body" : "Polar systems consist of a rotational axis (direction) and a linear axis (distance). The origin and the direction of the linear axis can be changed by means of the offsets dPhi and dR . For more information, see: SMC_TRAFO_Polar (FB) and SMC_TRAFOF_Polar (FB) " }, 
{ "title" : "2-Jointed SCARA System ", 
"url" : "_sm_trafo_pou_two_jointed_scara.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ 2-Jointed SCARA System ", 
"snippet" : "The Selective Compliance Assembly Robot Arm (SCARA) is a special type of industrial robot that is similar to a human arm. A SCARA system has two axes and two degrees of freedom. The movement is restricted to the X\/Y plane. For more information, see: SMC_TRAFO_Scara2 (FB) and SMC_TRAFOF_Scara2 (FB)...", 
"body" : "The Selective Compliance Assembly Robot Arm (SCARA) is a special type of industrial robot that is similar to a human arm. A SCARA system has two axes and two degrees of freedom. The movement is restricted to the X\/Y plane. For more information, see: SMC_TRAFO_Scara2 (FB) and SMC_TRAFOF_Scara2 (FB) " }, 
{ "title" : "3-Jointed SCARA System ", 
"url" : "_sm_trafo_pou_three_jointed_scara.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ 3-Jointed SCARA System ", 
"snippet" : "The 3-jointed SCARA system has a third axis which allows movement at a constant direction. As in 2-jointed systems, the movement is restricted to the X\/Y plane. For more information, see: SMC_TRAFO_Scara3 (FB) and SMC_TRAFOF_Scara3 (FB)...", 
"body" : "The 3-jointed SCARA system has a third axis which allows movement at a constant direction. As in 2-jointed systems, the movement is restricted to the X\/Y plane. For more information, see: SMC_TRAFO_Scara3 (FB) and SMC_TRAFOF_Scara3 (FB) " }, 
{ "title" : "Parallel Kinematics ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ Parallel Kinematics ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Tripod with linear axes ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_b6b32d1fbe665307c0a8640e00033022", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ Parallel Kinematics \/ Tripod with linear axes ", 
"snippet" : "This system has three linear drives that are in a defined angle to each other. The drives consist of 3 rails with traversing slides. The tool plate is connected to the traversing slides by connecting rods of the same length. A paired set of connecting rods holds the tool plate parallel to the floor ...", 
"body" : "This system has three linear drives that are in a defined angle to each other. The drives consist of 3 rails with traversing slides. The tool plate is connected to the traversing slides by connecting rods of the same length. A paired set of connecting rods holds the tool plate parallel to the floor in the same orientation. The kinematics can move the tool plate in three dimensions. The forward and inverse transformation of these kinematics is calculated in the SMC_Trafo_Tripod_Lin and SMC_TrafoF_Tripod_Lin POUs. The axis angle of the tripod is defined by the angle between the rail and the vertical axis ( dAxisAngle ). Mechanical requirements and coordinate system The lengths of the 3 axes are identical. The lengths of the connecting rods are identical. The distance between the pairs of connecting rods to each other is identical for all pairs. The axis angle between drive rails and the vertical axis is identical for all three drives. The angle allowance is between 0° and 90°. The axis defines the movement of the point between the connecting rod joints on the sliders. The XYZ coordinate system is right-handed. The X and Y vectors are horizontal and Z points up. The origin is defined so that the intersections of the three movement axes with the XY plane (graphics below: points A) is on a circle at position [0,0,0]. Parameterization of the SMC_TrafoF_Tripod_Lin function block Name Description dInnerRadius Distance from the center of the tool plate to the gripping points of the connecting rods dOuterRadius Point A is the intersection of the axis with the XY plane. dLength Length of the connecting rods dDistance Distance between the two connecting rods in one pair dRotationOffset Point A of the first axis defines the X-axis by default. The offset is used to rotate the entire structure about the Z-axis. In this case, point A is no longer on the X-axis. dOffsetA The offset is used to set the positional value of the axis to its default setting of zero. dOffsetB dOffsetC You will find information about other parameters in the library description. " }, 
{ "title" : "Tripod with vertical axes ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_74ba1833be665308c0a8640e019694c6", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ Parallel Kinematics \/ Tripod with vertical axes ", 
"snippet" : "This system is a special variant of the kinematic design described above and has the same mechanical requirements. The angle dAxisAngle between the guide rails and the vertical axis is 0° and the guide rails are parallel to the vertical axis. The forward and inverse transformation of these kinematic...", 
"body" : "This system is a special variant of the kinematic design described above and has the same mechanical requirements. The angle dAxisAngle between the guide rails and the vertical axis is 0° and the guide rails are parallel to the vertical axis. The forward and inverse transformation of these kinematics is calculated in the SMC_Trafo_Tripod_Lin and SMC_TrafoF_Tripod_Lin function blocks. The axis angle of the tripod is defined by the angle between the rail and the vertical axis ( dAxisAngle ). Parameterization of the SMC_TrafoF_Tripod_Lin function block Name Description dInnerRadius The parameter defines the radius of the circle that is described by the six gripping points of the connecting rods to the tool plate. dOuterRadius dLength Length of the connecting rods dDistance Distance of the pairs of connecting rods to each other dRotationOffset Point A of the first axis defines the X-axis by default. The offset is used to rotate the entire structure about the Z-axis. In this case, point A is no longer on the X-axis. dOffsetA The offset is used to set the positional value of the axis to its default setting of zero. dOffsetB dOffsetC You will find information about other parameters in the library description. " }, 
{ "title" : "Tripod with rotary axes ", 
"url" : "_sm_trafo_pou_parallel_kinematics.html#UUID-0195fe6b-986f-4e3a-bf34-7f17f411a757_id_e92c64b3085109c0a86463665a72e6_id_30491f2ca003ef70c0a864631e92f50c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ Parallel Kinematics \/ Tripod with rotary axes ", 
"snippet" : "For tripods, the kinematics are implemented by 3 rotary drives that are connected to the tool plate by arms and connecting rods. The origin of the coordinate system is the location of the center of the tool plate when all 3 arms are in a horizontal position. The forward and inverse transformation of...", 
"body" : "For tripods, the kinematics are implemented by 3 rotary drives that are connected to the tool plate by arms and connecting rods. The origin of the coordinate system is the location of the center of the tool plate when all 3 arms are in a horizontal position. The forward and inverse transformation of these kinematics is calculated in the SMC_TRAFO_Tripod_Arm and SMC_TRAFOF_Tripod_Arm function blocks. Mechanical requirements and coordinate system The lengths of the three axes are identical. The lengths of the connecting rods are identical. The distance between the pairs of connecting rods to each other is identical for all pairs. Parameterization of the SMC_TrafoF_Tripod_Arm function block Name Description dArmLength1 dArmLength2 dArm1Radius The parameter defines the radius of the circle that is established by the 3 points P of the drives. dStewartRadius The parameter defines the radius of the circle that is described by the 6 gripping points of the connecting rods to the tool plate. dDistance Distance between the two connecting rods in one pair dOffsetA dOffsetB dOffsetC You will find information about other parameters in the library description. The image shows the zero position of all axes. (The three upper arms are horizontal.) The MCS is shown at the tool plate. The arrows on the A0, A1, and A2 axes show the direction of rotation of the drives according to the right-hand rule. Machine Coordinate System (MCS) Origin Defined in the midpoint of the tool plate when all 3 upper arms (those that are connected directly with A0, A1, or A2) are in a horizontal position X From the origin, points away from the first motor (A0), parallel to the upper arm segment of the first arm Y Determined by X and Z so that the MCS is right-handed Z Orthogonal to the tool plate Points from the tool plate in the direction of the motors The respective transformations are executed by the following POUs SMC_TRAFO_Tripod_Arm and SMC_TRAFOF_Tripod_Arm : Example: 3S tripod Transformation settings tta:\nSMC_TRAFO_Tripod_Arm := (dArmLength1:=200, dArmLength2:=300, dArm1Radius:=112, dStewartRadius:=53,dDistance:=41,dMaxAngleBallJoint:=60);\nttaf:\nSMC_TRAFOF_Tripod_Arm := (dArmLength1:=200, dArmLength2:=300, dArm1Radius:=112, dStewartRadius:=53,dDistance:=41); " }, 
{ "title" : "4-Axis Palletizer Kinematics ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ 4-Axis Palletizer Kinematics ", 
"snippet" : "The 4-axis palletizer kinematics is a general robot type that is used frequently for palletizing tasks. The kinematics are provided with four controlled rotary axes (marked in red) and a fifth mechanical rotary axis (marked in gray). The SMC_Trafo_4AxisPalletizer and SMC_TrafoF_4AxisPalletizer POUs ...", 
"body" : "The 4-axis palletizer kinematics is a general robot type that is used frequently for palletizing tasks. The kinematics are provided with four controlled rotary axes (marked in red) and a fifth mechanical rotary axis (marked in gray). The SMC_Trafo_4AxisPalletizer and SMC_TrafoF_4AxisPalletizer POUs implement its forward and inverse transformation. The Cartesian coordinate system is the basis for the palletizer. The Z axis points downwards perpendicularly and the X axis \"forwards\", which means in the direction that the arm points in the zero direction of the axes. The origin of the Cartesian coordinate system is the intersection of the joint axis 1 and the underside of the robot. Objects The data structure SMC_TrafoConfig_4AxisPalletizer and the SMC_Trafo_4AxisPalletizer and SMC_TrafoF_4AxisPalletizer function blocks are linked to the library SM3_Transformation . For a description of the parameters, search for these objects in the Library Manager. " }, 
{ "title" : "Definition of axes ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_945c0811df409256c0a8657d0066458b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ 4-Axis Palletizer Kinematics \/ Definition of axes ", 
"snippet" : "The following image shows the rotational direction of the four axes. The black arrows run along the joint axis. The rotational direction is determined according to the right-hand rule: If the thumb of the right hand points downwards along the arrow, then the positive rotational direction is in the d...", 
"body" : "The following image shows the rotational direction of the four axes. The black arrows run along the joint axis. The rotational direction is determined according to the right-hand rule: If the thumb of the right hand points downwards along the arrow, then the positive rotational direction is in the direction of the slightly curved finger. For example, when viewed from above, the positive direction of rotation of axis 0 is clockwise, while axes 1 and 2 tilt \"forwards\" for positive rotation. The kinematics are provided with four controlled rotary axes (see red colored axes a0, a1, a2, a3) and a fifth mechanical rotary axis (see gray colored axis M). Value ranges of the axes: Axis 0: ]-180°, 180°[ Axis 1: [-90°, 90°] Axis 2: [-180°, 90[ Axis M: Mechanical rotary axis. No restriction Axis 3: Unrestricted; the range can also be greater than 360° " }, 
{ "title" : "Zero position and dimensions ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_e7016982df408f59c0a8657d017550b3", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ 4-Axis Palletizer Kinematics \/ Zero position and dimensions ", 
"snippet" : "The image shows the kinematics in zero position of all axes. In the zero position, the axes of the tool coordinate system run parallel to those of the machine coordinate system. Specify the indicated dimensions in the configuration structure SMC_TrafoConfig_4AxisPalletizer Also specify all a_i with ...", 
"body" : "The image shows the kinematics in zero position of all axes. In the zero position, the axes of the tool coordinate system run parallel to those of the machine coordinate system. Specify the indicated dimensions in the configuration structure SMC_TrafoConfig_4AxisPalletizer Also specify all a_i with positive signs and all d_i with negative signs. The names of the parameters are according to the Denavit-Hartenberg convention. Denavit–Hartenberg transformation of joints Joint offset (sigma_i) Joint distance (d_i) Arm element length (a_i) Torsion (alpha_i) 1 0° d_1 a_1 90° 2 -90° 0 a_2 0° 3 90° 0 a_3 0° 4 0° 0 a_4 90° 5 0° d_5 0 180° " }, 
{ "title" : "Programming in G-code ", 
"url" : "_sm_trafo_pou_four_axis_palatizer.html#UUID-291183b0-59ad-ce26-d4ec-a3ce270180d1_id_c5fd4d68b30885f2c0a864633f0dadc5_id_67269b93df408f35c0a8657d0178e964", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ 4-Axis Palletizer Kinematics \/ Programming in G-code ", 
"snippet" : "The position of the gripper is controlled with X, Y, and Z. The rotation of the gripper on the vertical is controlled by the additional axis C. The angles are specified in degrees....", 
"body" : "The position of the gripper is controlled with X, Y, and Z. The rotation of the gripper on the vertical is controlled by the additional axis C. The angles are specified in degrees. " }, 
{ "title" : "6-Axis Articulated Robot ", 
"url" : "_sm_trafo_pou_six_dof_robot.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ 6-Axis Articulated Robot ", 
"snippet" : "Transformation of an articulated arm robot with six rotary axes and six degrees of freedom (DoF). The three orientation axes of the robot arm intersect at one point: the joint center. The SMC_Trafo_ArticulatedRobot_6DOF and SMC_TrafoF_ArticulatedRobot_6DOF function blocks implement forward and inver...", 
"body" : "Transformation of an articulated arm robot with six rotary axes and six degrees of freedom (DoF). The three orientation axes of the robot arm intersect at one point: the joint center. The SMC_Trafo_ArticulatedRobot_6DOF and SMC_TrafoF_ArticulatedRobot_6DOF function blocks implement forward and inverse transformations of an articulated arm robot with six rotational axes. In the image, the Cartesian coordinate system is marked below at axis 0. The z-axis points downwards and the x-axis points forwards in the direction of the tool center point (TCP). The origin of the Cartesian coordinate system is the intersection axis 0 and the underside of the robot. Transformation objects The data structure SMC_TrafoConfig_ArticulatedRobot_6DOF and the SMC_Trafo_ArticulatedRobot_6DOF and SMC_TrafoF_ArticulatedRobot_6DOF function blocks are linked to SM3_CNC . " }, 
{ "title" : "Definition of axes ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_7e060a95379b6b55c0a8640e01f01d63", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ 6-Axis Articulated Robot \/ Definition of axes ", 
"snippet" : "The rotary axes are identified by black arrows. The positive direction of rotation is given by the right-hand rule. For example, when axis 0 is turned in positive direction, the robot rotates clockwise when viewed from above. The axes are restricted to the following ranges: Axes 0, 1, 3, and 4: ]-18...", 
"body" : "The rotary axes are identified by black arrows. The positive direction of rotation is given by the right-hand rule. For example, when axis 0 is turned in positive direction, the robot rotates clockwise when viewed from above. The axes are restricted to the following ranges: Axes 0, 1, 3, and 4: ]-180°, 180°[ Axis 2: [-90°, 180°] Axis 5: Unrestricted; the range may be greater than 360°. " }, 
{ "title" : "Homing position and dimensions ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_e7016982df408f59c0a8657d017550b3", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ 6-Axis Articulated Robot \/ Homing position and dimensions ", 
"snippet" : "The image on the left shows the homing position of the kinematics, which is the position where all axes are in their zero position. Specify the indicated dimensions in the configuration structure SMC_TrafoConfig_ArticulatedRobot_6DOF . The names and signs of the parameters are in accordance with the...", 
"body" : "The image on the left shows the homing position of the kinematics, which is the position where all axes are in their zero position. Specify the indicated dimensions in the configuration structure SMC_TrafoConfig_ArticulatedRobot_6DOF . The names and signs of the parameters are in accordance with the Denavit–Hartenberg convention. The image on the right shows the additional Denavit–Hartenberg parameter d3 . Note: a1, a3, d4, and d6 have to be >= 0 a2 has to be > 0 (> g_fSMC_CNC_EPS ) d1 has to be <= 0 Denavit–Hartenberg transformation of joints Joint Offset (sigma_i) Lever Offset (d_i) Lever Length (a_i) Lever Rotation (alpha_i) 1 0° d1 a_1 -90° 2 90° 0 a_2 0° 3 0° d3 a_3 90° 4 0° d4 0 90° 5 0° 0 0 -90° 6 0° d6 0 0° " }, 
{ "title" : "Programming ", 
"url" : "_sm_trafo_pou_six_dof_robot.html#UUID-5451338b-a728-5c42-0f62-d9735b01d032_id_b18ea4b1b308acfdc0a8646358edc019_id_9cf41a3c6a5fb376c0a8640e005461c1", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ 6-Axis Articulated Robot \/ Programming ", 
"snippet" : "The position of the tool center is controlled with X, Y, and Z. The units of X, Y, and Z are the same as used for the parameters a_i and d_i (for example: mm). The orientation is controlled in degrees with A (yaw), B (pitch), and C (roll)....", 
"body" : "The position of the tool center is controlled with X, Y, and Z. The units of X, Y, and Z are the same as used for the parameters a_i and d_i (for example: mm). The orientation is controlled in degrees with A (yaw), B (pitch), and C (roll). " }, 
{ "title" : "Wrapper for kinematic transformation function blocks from the SM3_Transformation library ", 
"url" : "_sm_wrapper_kinematic_fbs.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Kinematic Transformations \/ Wrapper for kinematic transformation function blocks from the SM3_Transformation library ", 
"snippet" : "The SMC_Trafo_Wrapper and SMC_TrafoF_Wrapper function blocks allow you to use the kinematics in the SM3_Transformation library for CNC applications. For more information about the kinematics of the SM3_Transformation library, see the following: KinematicsIt is possible to use any transformation whic...", 
"body" : "The SMC_Trafo_Wrapper and SMC_TrafoF_Wrapper function blocks allow you to use the kinematics in the SM3_Transformation library for CNC applications. For more information about the kinematics of the SM3_Transformation library, see the following: KinematicsIt is possible to use any transformation which implements the MC_KIN_REF_SM3 interface. Additionally, combinations of \"position kinematics\" and \"orientation kinematics\" are possible. For more information, see the following: Combination of Position and Orientation Kinematics" }, 
{ "title" : "CNC Language in DIN 66025 ", 
"url" : "_sm_struct_reference_programming_din66025.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "DIN 66025 Fundamentals ", 
"url" : "_sm_cnc_din66025_basics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ DIN 66025 Fundamentals ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Structure of a DIN 66025 program ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_c348b29fedfe7b9ec0a86463427bc61d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ DIN 66025 Fundamentals \/ Structure of a DIN 66025 program ", 
"snippet" : "The DIN 66025 program consists of individual motion blocks. The block number is located at the beginning of each block. ['%' <Programmname>] <Satz>{<Satz>} The blocks can be structured as follows: N<block number> G<expression> <G-code words> N<block number> <G-code words> (the G<expression> of the p...", 
"body" : "The DIN 66025 program consists of individual motion blocks. The block number is located at the beginning of each block. ['%' <Programmname>]\n<Satz>{<Satz>} The blocks can be structured as follows: N<block number> G<expression> <G-code words> N<block number> <G-code words> (the G<expression> of the previous block apply) N<block number> M<expression> <G-code words> N<block number> <subroutine name> ( <ActualParamList> ) Additional block structures for subroutines: SUBPROGRAM <Name> {<FormalParamList>} <RESTORE_OPT> N<block number> RETURN END_SUBPROGRAM Example Path from two lines and an arc, followed by a subroutine call % MyProgram\nN10 G01 X100 Y100 E100 F100 E-200\nN20 G01 Z40 F20\nN30 G03 X-100 R200 F100\nN40 SubPrg{5} " }, 
{ "title" : "Syntax ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_section-idm4580346248046432600861986014", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ DIN 66025 Fundamentals \/ Syntax ", 
"snippet" : "['%' <program name>] Header optional Starts with %, followed by the program name separated by a Space or Tab <block> The block is processed word by word from right to left. \/ Step Suppression If a block starts with \/ and the CNC ➔ Step Suppression command is selected, then the block is not executed....", 
"body" : "['%' <program name>] Header optional Starts with %, followed by the program name separated by a Space or Tab <block> The block is processed word by word from right to left. \/ Step Suppression If a block starts with \/ and the CNC ➔ Step Suppression command is selected, then the block is not executed. N<block number> The block number is used as a marker for defining jump targets. Example: N01 G<expression> Travel Command If no travel command is specified in a block, then the travel command in the previous block is supplemented automatically. Uppercase and lowercase is ignored. Leading zeros are ignored. Therefore, G01 = g1 applies Corresponds to a path element or path object Example: G1 (linear), G2 (arc) The velocity at which the path objects are interpolated; in principle corresponds to the set path velocity, path acceleration, and path deceleration. The interpolator makes sure that these limiting values are not exceeded. <G-code word> Uppercase and lowercase is ignored. G-code word Consists of an address (e.g. E ) and an expression (e.g. 100 ; together E100 ) Uppercase and lowercase is ignored. Leading zeros are ignored. Writes the number of the word to a variable The letter of the word is the variable name. The travel command accesses this. All numbers can be floating point values. This does not apply to the G<expression> travel command, M<expression> M function, and H<expression> switch point. The words of a block are separated by a space or tab . <expression> See: Expressions() Comment The characters between the parentheses are interpreted as a comment. Note: Comments can be redefined by means of the bParenthesesAsComments input ( FB SMC_ReadNCFile2 ) . Interpolation between two consecutive blocks The velocity when transitioning two adjacent objects is determined by the following rules: If one of the two objects is a positioning of G0 , then the transition velocity = 0. If the angle between the tangents of both path elements at the transition is greater than the angle tolerance, then the transition velocity = 0. Otherwise, the transition velocity is the least specified velocity of both path elements. As a rule, the travel command is responsible for an interpolation of the target position of the last travel command to the target position, which was specified by the current travel command, to be performed. The first travel command starts at the position that was defined in the decoder or CNC editor. If this position is not defined, then the starting point is X=0, Y=0, Z=0. " }, 
{ "title" : "Travel commands and corresponding path elements ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_48e0dea1edfe7b9ec0a8646321fb969d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ DIN 66025 Fundamentals \/ Travel commands and corresponding path elements ", 
"snippet" : "Travel Command Description Path Element G0 Direct movement without tool operation; linear motion PositioningG1 Linear movement with tool operation Linear MotionG2 Circular segment or circle, clockwise ArcG3 Circular segment or circle, counterclockwise ArcG4 Dwell Time Dwell TimeG5 Point of a 2D card...", 
"body" : "Travel Command Description Path Element G0 Direct movement without tool operation; linear motion PositioningG1 Linear movement with tool operation Linear MotionG2 Circular segment or circle, clockwise ArcG3 Circular segment or circle, counterclockwise ArcG4 Dwell Time Dwell TimeG5 Point of a 2D cardinal spline SplineG6 Parabola ParabolaG8 Elliptical arc or ellipse, clockwise EllipseG9 Elliptical arc or ellipse, counterclockwise EllipseG10 Point of a 3D cardinal spline SplineG15 Switch to 2D 3D ModeG16 Switch to 3D by activating 3D mode with the normal I\/J\/K vector to the plane 3D ModeG17 Switch to 3D by activating 3D mode in the X\/Y plane 3D ModeG18 Switch to 3D by activating 3D mode in the Z\/X plane 3D ModeG19 Switch to 3D by activating 3D mode in the Y\/Z plane 3D ModeG20 Conditional jump to L , if K <> 0 JumpG31 Probing function (clear remaining distance) with decoding stop Probing function (clear remaining distance)G36 Write value D to variable O Changing the Values of VariablesG37 Increment variable O by value D Changing the Values of VariablesG38 Activate the extended preprocessing function Activating the Extended Preprocessing FunctionG39 Deactivate the extended preprocessing Function Activating the Extended Preprocessing FunctionG40 End of tool radius correction PreprocessingG41 Start of tool radius correction, left of travel direction PreprocessingG42 Start of tool radius correction, right of travel direction PreprocessingG43 Starts the tool length correction PreprocessingG50 End of corner rounding\/smoothing PreprocessingG51 Start of corner smoothing PreprocessingG52 Start of corner rounding PreprocessingG53 Ends the coordinate transformation and resets the decoder coordinate system to the original position (= machine coordinate system) Shifting, Rotating, and Scaling the Coordinate SystemG54 Absolute transformation of the coordinates Shifting, Rotating, and Scaling the Coordinate SystemG55 Relative transformation of the coordinates Shifting, Rotating, and Scaling the Coordinate SystemG56 Sets the current orientation, position, and scaling of the DCS is set as a reference point Shifting, Rotating, and Scaling the Coordinate SystemG60 End of loop suppression PreprocessingG61 Start of loop suppression PreprocessingG70 End of smoothing additional axes See: SMC_SmoothAddAxes PreprocessingG71 Start of smoothing additional axes See: SMC_SmoothAddAxes PreprocessingG75 Timing synchronization with the interpolator Timing Synchronization with InterpolatorG90 The coordinates ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) are interpreted as absolute values. (This is the default setting.) ModesG91 The coordinates ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) are interpreted as values relative to the current position. ModesG92 Positioning by jump PositioningG98 The axis midpoints ( I \/ J \/ K ) are interpreted as absolute values. ModesG99 The axis midpoints ( I \/ J \/ K ) are interpreted as values relative to the start position. (This is the default setting.) Modes" }, 
{ "title" : "G-code word recognition ", 
"url" : "_sm_cnc_din66025_basics.html#UUID-ce2497d4-16cf-5757-3bbd-65862258aeb2_id_f25e64ed9f2f1bc0a86463147c4f6e_id_591ac87c61b577fcc0a8640e0070747c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ DIN 66025 Fundamentals \/ G-code word recognition ", 
"snippet" : "A Target position of the additional spline axis For a coordinate transformation in the decoder coordinates system, the word contains an angle. B C D Tool radius for correction G40 - G42 Tool distance for corner rounding G50 - G51 Variable value G36 \/ G37 E Maximum path acceleration\/deceleration in [...", 
"body" : "A Target position of the additional spline axis For a coordinate transformation in the decoder coordinates system, the word contains an angle. B C D Tool radius for correction G40 - G42 Tool distance for corner rounding G50 - G51 Variable value G36 \/ G37 E Maximum path acceleration\/deceleration in [u\/sec 2 ]. Value > 0: acceleration; value < 0: deceleration EF Path acceleration\/deceleration for G0 motion E<axis> Individual acceleration\/deceleration (>0\/<0) of the specified <axis> additional axis Additional axes are A , B , C , P , Q , U , V , W , and also Z in 2D mode. If this G-code is used, then the path processing block SMC_ExtendedVelocityChecks has to be used for limiting the velocity. F Velocity (in [u\/sec]): \"Feed\" FF Velocity for G0 movements F<axis> Individual velocity of specified additional axis <axis> Additional axes are A , B , C , P , Q , U , V , W , and also Z in 2D mode. If this G-code is used, then the path processing block SMC_ExtendedVelocityChecks has to be used for limiting the velocity. G Path condition H Switch Point (H Function) Positive: Switch on Negative: Switch off I X-coordinate of the circle\/ellipse midpoint for G02 \/ G03 \/ G08 \/ G09 X-coordinate of the vertex of the parabola for G06 Normal vector (X) for the 3D plane function Parameters for activating extended preprocessing functions for G38 \/ G39 Scaling in the X-direction for G54 \/ G55 \/ G56 Tool offset in the X-direction for G43 J Y-coordinate of the circle\/ellipse midpoint for G02 \/ G03 \/ G08 \/ G09 Y-coordinate of the vertex of the parabola for G06 Normal vector (Y) for the 3D plane function Parameters for activating extended preprocessing functions for G38 \/ G39 Scaling in the Y-direction for G54 \/ G55 \/ G56 Tool offset in the Y-direction for G43 K Direction of the primary ellipse axis; mathematically: 0° = O, 90° = N, and so on. Jump condition for G20 dT1 parameter value for M function Z-coordinate of the circle midpoint for G02 \/ G03 in 3D mode Normal vector (Z) for the 3D plane function Parameters for activating extended preprocessing functions for G38 \/ G39 Scaling in the Z-direction for G54 \/ G55 \/ G56 Tool offset in the Z-direction for G43 L Absolute switch position for H function, measured from the start of the path element (if position > 0) or measured from the end of the path element (if position < 0). Jump target for G20 dT2 parameter value for M function Number of the additional axis for G70 and G71 M Additional option for machinery; also M function O Relative switch point position with value range [0..1] for H function Variable value G36 \/ G37 . Data structure for the parameters for an M function P Target position of the additional linear axis P P<axis><period> Configuration of the modulo axes If Period=0 applies (example: PA0 ), then the behavior of the axis is linear. PROBE Activates the probing function (clear remaining distance) for the movement Q Target position of the additional linear axis Q R Circle radius alternative to I, J with G02 \/ G03 Length ratio of the elliptical secondary\/primary axis in the value range of [0..1] with G08 \/ G09 S S profile for linear axes Positive: Switch on Negative: Switch off Axis 3 : Z, if Z is in 2D mode 7 : P 8 : Q 9 : U 10 : V 11 : W T Command-specific parameter U Target position of the additional linear axis U V Target position of the additional linear axis V W Target position of the additional linear axis W X X-coordinate of the target position Y Y-coordinate of the target position Z Z-coordinate of the target position " }, 
{ "title" : "3D Mode ", 
"url" : "_sm_cnc_din66025_3dmode.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ 3D Mode ", 
"snippet" : "G code : G15 , G16 , G17 , G18 , G19 G Code Description G15 Switches to 2D mode. Valid for all other elements G16 Activates the 3D plane function in the normal plane with normal vector I\/J\/K and switches to 3D mode Valid for all other elements G17 Activates the 3D plane function in the X\/Y-plane and...", 
"body" : "G code : G15 , G16 , G17 , G18 , G19 G Code Description G15 Switches to 2D mode. Valid for all other elements G16 Activates the 3D plane function in the normal plane with normal vector I\/J\/K and switches to 3D mode Valid for all other elements G17 Activates the 3D plane function in the X\/Y-plane and switches to 3D mode Valid for all other elements G18 Activates the 3D plane function in the X\/Z-plane. Switches to 3D mode Valid for all other elements G19 Activates the 3D plane function in the Y\/Z-plane. Switches to 3D mode Valid for all other elements Three-dimensional path elements are used in 3D mode. In 3D space, you can set points and connect with 3D splines. You can also insert arcs in any spatial plane. In contrast to 2.5D path elements that use X\/Y-coordinates only, the path velocity and acceleration refers to movement in the X\/Y\/Z-coordinates. The Z-axis is treated the same as the X-axis and Y-axis. Therefore, every movement can be implemented in the Z-direction. 3D Mode The mode does not support ellipses, parabolas, and 2D splines. An error message is issued. SMC_CheckVelocities checks the Z-component SMC_ToolCorr and SMC_AvoidLoop generate errors Primary differences between 2.5D and 3D Primary differences between 2.5D and 3D Velocity and acceleration (F\/E): In 3D: Defines the velocity and acceleration of the path. In 2.5D: Defines the velocity and acceleration of the projection of the path on the X\/Y-plane. Splines 3D: With a jerk-free, smoothed Z-component (G10) 2.5D: In Z-direction not smoothed (G5) Arc 3D: Can be defined in every possible plane in space (G2\/G3 with G16\/G17\/G18\/G19) 2.5D: Restricted to the X\/Y-plane (G2\/G3) Example Velocity comparison of 3D and 2.5D N0 G1 X1 Z100 F1 3D requires the motion for approximately 100 seconds, because the length of the object contains the Z-component. Length = (1 2 + 100 2 ) 1\/2 At a velocity of 1, approximately 100 seconds are required. The velocity of the Z-component is approximately 1. In 2.5D, the motion requires approximately 1 second for the calculation or the length = 1. The velocity in the Z-direction is approximately 100. " }, 
{ "title" : "Activating the Extended Preprocessing Function ", 
"url" : "_sm_cnc_din66025_activating_extended_preprocessor_functions.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Activating the Extended Preprocessing Function ", 
"snippet" : "G code : G38 , G39 Function : These commands activate and deactivate the extended preprocessing function. Syntax G38 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> G39 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> G Code Word Description <bit> Value between 0 and 31. The assignment of bit...", 
"body" : "G code : G38 , G39 Function : These commands activate and deactivate the extended preprocessing function. Syntax G38 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value>\nG39 O<Bit> I<Param1Value> J<Param2Value> K<Param3Value> G Code Word Description <bit> Value between 0 and 31. The assignment of bits to functions is left to the developer. Some function blocks, such as SMC_SmoothMerge or SMC_SmoothBSpline , have an input wFeatureBit (initial value 0) that defines the bit to be used. The bit is saved in the variable SMC_GeoInfo.dwFeatureFlags . <Param1Value> Any value. The values are saved in the array SMC_GeoInfo.aAdditionalParams : ARRAY[0..MAX_ADDITIONAL_PARAMS-1] OF LREAL . <Param1Value> <Param1Value> " }, 
{ "title" : "Shifting, Rotating, and Scaling the Coordinate System ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Shifting, Rotating, and Scaling the Coordinate System ", 
"snippet" : "G code : G53 , G54 , G55 , G56 Function : The G code commands G54 , G55 , and G56 shift, rotate, and scale the decoder coordinate system which is used internally by the interpreter function block SMC_NCInterpreter . The coordinate transformations are calculated for all path elements during the execu...", 
"body" : "G code : G53 , G54 , G55 , G56 Function : The G code commands G54 , G55 , and G56 shift, rotate, and scale the decoder coordinate system which is used internally by the interpreter function block SMC_NCInterpreter . The coordinate transformations are calculated for all path elements during the execution of the SMC_NCInterpreter function block instance. The G code command G53 resets the decoder coordinate system to the original position, orientation, and scaling (corresponding to the machine coordinate system). You shift and rotate the decoder coordinate system in order to reuse the G code of the same path elements that differ only by position, orientation, or scaling. Rotating and scaling the decoder coordinate system only works in the online interpreter (not in the CNC editor). " }, 
{ "title" : "MCS and DCS coordinate systems ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_f644d63d98ef7863c0a864636e4c0bd6", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Shifting, Rotating, and Scaling the Coordinate System \/ MCS and DCS coordinate systems ", 
"snippet" : "The machine coordinate system (MCS) is defined by the applied kinematics which determine its position and orientation. The decoder coordinate system (DCS) is managed by the interpreter ( SMC_NCInterpreter function block instance). All coordinate information for motion commands are interpreted in thi...", 
"body" : "The machine coordinate system (MCS) is defined by the applied kinematics which determine its position and orientation. The decoder coordinate system (DCS) is managed by the interpreter ( SMC_NCInterpreter function block instance). All coordinate information for motion commands are interpreted in this coordinate system. This affects the target position of a movement ( X\/Y\/Z ), as well as an arc midpoint ( I\/J\/K ) or a plane that is set with G15\/G16\/G17\/G18\/G19 . The DCS is programmed with the commands G53\/G54\/G55\/G56 . You can rotate, shift, and scale the DCS with respect to the machine coordinate system, and therefore adapt the position, orientation, and scaling in the G code file any number of times. You program the path elements relative to the DCS. For example, this can be an advantage for the same path elements in different positions and orientations. The following image shows a shift (left) and a shift with rotation (right). The interpreter gets the information from its eOriConv input about whether A\/B\/C are treated as additional axes or as orientation values. The coordinates of the path elements are transformed accordingly. Therefore, the interpreter function block manages an active coordinate system. Initially, if the DCS is neither shifted, nor rotated, nor scaled, then the DCS corresponds to the MCS. The start and target positions and the plane for arcs are specified in the generated GeoInfo objects always relative to the MCS. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ADDAXES No orientation convention is specified. The contents of the G code word A\/B\/C is interpreted as an shift value. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ZYZ The orientation convention is the standard Y convention (Z, Y', Z''). The contents of the G code word A\/B\/C is interpreted as an angle value. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ZYX The orientation convention is the yaw-pitch-roll convention (Z, Y', X''). The contents of the G code word A\/B\/C is interpreted as an angle value. SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.XYZ The orientation convention is the XYZ convention (X, Y', Z''). The contents of the G code word A\/B\/C is interpreted as an angle value. " }, 
{ "title" : "Commands G53, G54, G55, G56 ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_02170a739e1947dec0a864637ea0fc00", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Shifting, Rotating, and Scaling the Coordinate System \/ Commands G53, G54, G55, G56 ", 
"snippet" : "G Code Description G53 Resets the decoder coordinate system The DCS is reset to the same position and orientation as the MCS. G54 Absolute shift, rotation, and scaling of the DCS The values refer to the MCS. If an orientation convention is not specified ( SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENT...", 
"body" : "G Code Description G53 Resets the decoder coordinate system The DCS is reset to the same position and orientation as the MCS. G54 Absolute shift, rotation, and scaling of the DCS The values refer to the MCS. If an orientation convention is not specified ( SMC_NCInterpreter.eOriConf = SMC_ORI_CONVENTION.ADDAXES ), then the command results in a shift only along the axes X\/Y\/Z\/A\/B\/C and on all additional linear axes P\/Q\/U\/V\/W. Therefore, a shift can also be programmed along the A\/B\/C axes. If an orientation convention is specified, then the command results in a shift also along the axes X\/Y\/Z and along the additional linear axes P\/Q\/U\/V\/W. In addition, the coordinate axes are rotated. Then the orientation convention provides the rotation order and the G code words A\/B\/C give the angles of rotation in degrees. Note: The decoder can perform directional rotations in a range from -180° to +180°. If you specify an angle outside this range, then the decoder converts the value so that it is within the executable range. Only then does the decoder rotate the coordinate axes. For example, a rotation of -10° is performed for an angle of 350°. G55 Relative shift, rotation, and scaling of the DCS to its current position and orientation Therefore the values are relative to the current DCS origin and interpreted in the direction of the current coordinate axes of the DCS. An additional shift\/rotation is added with respect to the machine coordinate system. If an orientation convention is not specified, then the command results in a relative shift only along the axes X\/Y\/Z\/A\/B\/C and on all additional linear axes P\/Q\/U\/V\/W. Therefore, a shift can also be programmed along the A\/B\/C axes. If an orientation convention is specified, then the command results in a relative shift also along the axes X\/Y\/Z and along the additional linear axes P\/Q\/U\/V\/W. But above all, the coordinate axes are rotated further. Then the orientation convention provides the rotation order and the G code words A\/B\/C give the angles of rotation. G56 Resets the reference point of the decoder coordinate system The current orientation, position, and scaling of the DCS is set as a reference. Hint: If the reference point is X0 Y0 Z0 A0 B0 C0, then the DCS is set identically to the current position and orientation. Syntax G53\nG54 X Y Z A B C I J K P Q U V W\nG55 X Y Z A B C I J K P Q U V W\nG56 X Y Z A B C I J K P Q U V W G Code Word Description X Y Z Value around which the decoder coordinate system is shifted A B C If the input is eOriConf = SMC_ORI_CONVENTION.ADDAXES at SMC_NCInterpreter , then the value is given in units how far the respective additional axis is shifted. Therefore, the parameter defines the shift for each axis of the decoder coordinate system with respect to the machine coordinate system. If the eOriConf input is SMC_ORI_CONVENTION.ZYZ , SMC_ORI_CONVENTION.ZYX , or SMC_ORI_CONVENTION.XYZ at SMC_NCInterpreter , then an orientation convention is provided. In this case, the values given here are automatically interpreted as degrees and determine by how much the axes of the decoder coordinate system are rotated with respect to the machine coordinate system. Therefore, you define the rotation of the main axes according to the orientation convention. Note: When programming the DCS rotation, the angles of rotation should always be specified in A\/B\/C for all three axes. A missing angle of rotation causes an error when decoding ( SMC_DEC_DCS_NOT_ALL_OF_ABC_GIVEN ). I Scaling in direction X Example: 10 for extending by a factor of 10 J Scaling in direction Y Example: 10 for extending by a factor of 10 K Scaling in direction Z Example: 10 for extending by a factor of 10 P Q U V W Value around which the additional axis of the decoder coordinate system is shifted " }, 
{ "title" : "Shifting the DCS ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_4557d91f9e1947dec0a864630016f87d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Shifting, Rotating, and Scaling the Coordinate System \/ Shifting the DCS ", 
"snippet" : "Set the eOriConv input of the SMC_NCInterpreter function block instance to SMC_ORI_CONVENTION.ADDAXES . The DCS can be shifted. A rotation is not possible. Program the CNC path. First, specify the position shift of the DCS. Example: G54 X10 Y10 Z10 A30 B30 C30 The X\/Y\/Z\/A\/B\/C axes of the DCS are shi...", 
"body" : "Set the eOriConv input of the SMC_NCInterpreter function block instance to SMC_ORI_CONVENTION.ADDAXES . The DCS can be shifted. A rotation is not possible. Program the CNC path. First, specify the position shift of the DCS. Example: G54 X10 Y10 Z10 A30 B30 C30 The X\/Y\/Z\/A\/B\/C axes of the DCS are shifted. Example Absolute offset N10 G0 X100 Y100 F100\nN20 G54 X50 Y50 (Offset auf 50\/50)\nN30 G1 X0 Y0 (Fahrt nach 50\/50)\nN40 G54 X100 Y100 (Offset auf 100\/100)\nN50 G1 X0 Y0 (Fahrt nach 100\/100)\nN60 G53 (Offset auf 0)\nN70 G1 X0 Y0 (Fahrt nach 0\/0) Current position as offset N0 G0 X100 Y100 F100\nN10 G56 X0 Y0 (Aktuelle Position 100\/100 wird 0\/0)\nN20 G1 X10 (Fahrt nach 110\/100)\nN30 G56 X20 Y0 (Aktuelle Position 110\/100 wird 20\/0)\nN40 G1 X0 (Fahrt nach 90\/100) Adapt offset by value N0 G54 X10 Y20 Z30 U7 (Offset: X=10, Y=20, Z=30, U=7)\nN10 G55 X-10 U7 (Offset: X=0, Y=20, Z=30, U=14) Same path elements in two positions N05 G17\nN10 G54 X10 Y10 Z10\nN20 G01 X6.574 Y-10 Z-1.961 I8.287 J-0.000\nN30 G02 X-0.480 Y-10 Z0.008 I-3.527 J4.988E-05\nN040 G02 X3.418 Y-9.806 Z4.482 I1.949 J0.097\nN50 G55 X10 Y10 Z10\nN60 G01 X6.574 Y-10 Z-1.961 I8.287 J-0.000\nN70 G02 X-0.480 Y-10 Z0.008 I-3.527 J4.988E-05\nN80 G02 X3.418 Y-9.806 Z4.482 I1.949 J0.097 " }, 
{ "title" : "Shifting and rotating the DCS ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_df6926f62eedd311c0a8646378b457e7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Shifting, Rotating, and Scaling the Coordinate System \/ Shifting and rotating the DCS ", 
"snippet" : "Set the eOriConv input of the SMC_NCInterpreter function block instance to the desired orientation convention (for example, SMC_ORI_CONVENTION.ZYZ ). The orientation convention and the rotation order of the X\/Y\/Z axes of the DCS are programmed. For SMC_ORI_CONVENTION.ZYZ , the rotation order is ZY'Z...", 
"body" : "Set the eOriConv input of the SMC_NCInterpreter function block instance to the desired orientation convention (for example, SMC_ORI_CONVENTION.ZYZ ). The orientation convention and the rotation order of the X\/Y\/Z axes of the DCS are programmed. For SMC_ORI_CONVENTION.ZYZ , the rotation order is ZY'Z'' and corresponds to the standard Y-convention. Note: As long as the eOriConv input contains an orientation convention and not the value SMC_ORI_CONVENTION.ADDAXES , the values of the words A\/B\/C are interpreted as angle values for the rotation for the G code commands G54\/G55\/G56 . Program the CNC path. First, specify the position shift and rotation of the DCS. Example: G54 X10 Y10 Z10 A30 B30 C30 The values of the words A\/B\/C provide the direction of rotation and the angle in degrees. The coordinate system is rotated accordingly. The values of the words X\/Y\/Z define the shift. Note: When programming the DCS rotation, the angles of rotation should always be specified in A\/B\/C for all three axes. A missing angle of rotation causes an error when decoding ( SMC_DEC_DCS_NOT_ALL_OF_ABC_GIVEN ). If the eOriConv input of the SMC_NCInterpreter function block instance contains the value SMC_ORI_CONVENTION.ADDAXES , then rotating the DCS is not possible. The values in G54\/G55\/G56 are interpreted as additional spline axis values. Shifting is possible. Examples The orientation convention was defined in the examples as the standard Y-convention ( eOriConv = SMC_ORI_CONVENTION.ZYZ ). In general for G54 : X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W provides an absolute value in the MCS. G55 : X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W provides a relative value in the DCS. G56 : X\/Y\/Z\/A\/B\/C\/P\/Q\/V\/W provides an absolute new value in the DCS. Absolute orientation with G54 N01 G54 X10 A30 B0 C0 G54 results in a shift and rotation. The position and orientation are provided absolute to the MCS. Relative orientation with G55 N01 G54 X10 A30 B0 C0 (Bezieht sich auf MCS)\nN02 G55 Y10 A0 B30 C0 (Bezieht sich auf das in 01 definierte DCS) G54 results in a shift of 10 units in the X-direction and a 30° rotation about the Z-axis absolute to the MCS. In block 02, the DCS is shifted an additional 10 units in the direction of the rotated Y-axis and then rotated an additional 30° about the rotated Y-axis. Therefore, the transformation in block 02 is relative to the transformation in block 01. Referencing with respect to the current orientation with G56 N01 G01 X10 A10 B90 C10 (Orientierung ist A=10°, B=90°, C=10°)\nN02 G56 A0 B0 C0 (DCS wird auf X=10, A=10°, B=90°, C=10° gesetzt) G56 results in the current orientation of the DCS (programmed in block 01 in the example) to be set as a reference. Example: Arc N0 G17\nN0 G54 A0 B90 C0 The selected circular plane is interpreted relative to the DCS. In the example, the X\/Y-plane is selected with G17 and then the DCS is rotated 90° about the Y-axis. Then the selected plane in the DCS is the X\/Y-plane as before. This corresponds to that of the X\/Z-plane in the MCS. With G17 , the X\/Y-plane is selected. Then the DCS is rotated by 90°. This results in the X\/Y-plane being activated in the DCS as before. This corresponds to the X\/Y-plane in the MCS. In 2.5D mode ( G15 ), rotation is permitted about the Z-axis only. Rotation about another axis causes an error which is issued by the decoder ( SMC_DEC_DCS_2D_NOT_IN_XY_PLANE ). Therefore, the X\/Y-plane of the MCS always remains set in 2.5D mode. " }, 
{ "title" : "Scaling the coordinate system ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_52b3763cadb811e79ffc84f8a2d3d270", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Shifting, Rotating, and Scaling the Coordinate System \/ Scaling the coordinate system ", 
"snippet" : "If a rotation is programmed after an unequal scaling, then clipping can occur. In this case, the SMC_DEC_ROTATION_AFFECTS_SCALING error is not issued. All three scaling factors have to be specified or none at all. Absolute scaling Syntax: G54 I<i> J<j> K<k> A coordinate system can be stretched or co...", 
"body" : "If a rotation is programmed after an unequal scaling, then clipping can occur. In this case, the SMC_DEC_ROTATION_AFFECTS_SCALING error is not issued. All three scaling factors have to be specified or none at all. Absolute scaling Syntax: G54 I<i> J<j> K<k> A coordinate system can be stretched or compressed in the three spatial directions X\/Y\/Z independently of each other. You can specify a factor for each direction. Specify the scaling factor for X in I, Y in J, and Z in K. A scaling factor > 1 extends. A scaling factor < 1 compresses. Extending by 10x: N01 G01 X10\nN02 G54 A90 B0 C0 I10 J1 K1\nN03 G01 X10 Y20\nN04 G01 X5 Y10 All target points are extended by 10x in the direction of the rotated X-axis. The following code generates the same path: N01 G01 X10\nN02 G01 X-20 Y100\nN03 G01 X-10 Y50. If neither I nor J nor K are specified, then the previously set value remains unchanged: N01 G54 I10 J1 K1\nN02 G54 X1\nN03 G01 X10 The same path is achieved with the following code: N01 G01 X101 Relative scaling Syntax: G55 I<i> J<j> K<k> A scaling factor > 1 extends. A scaling factor < 1 compresses. The scaling factors are multiplied. Extending by 100x: N01 G54 I10 J1 K1\nN02 G55 I10 J1 K1\nN03 G01 X10 Y20\nN04 G01 X5 Y10 The following code results in the same scaling: N01 G55 I100 J1 K1 Circular scaling The scaling of an arc is valid only if the element is still an arc (not an ellipse) after the scaling. Valid paths result: When all three scaling factors are the same value When the circular plane is one of the primary planes of the DCS and the corresponding two scale factors are the same values " }, 
{ "title" : "Mirroring the coordinate system ", 
"url" : "_sm_cnc_din66025_coordinate_shift.html#UUID-a991c0f8-3de2-8e31-ac04-262b1aa641d9_id_cc60cf1134782194c0a8640e008fa6f3_id_adba25b098ef7863c0a8646324d700b4", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Shifting, Rotating, and Scaling the Coordinate System \/ Mirroring the coordinate system ", 
"snippet" : "An absolute scaling with negative scaling factors in I , J , or K results in mirroring of the current coordinate system. Negative scale factor G54 A30 B0 C0 I-1 J1 K1...", 
"body" : "An absolute scaling with negative scaling factors in I , J , or K results in mirroring of the current coordinate system. Negative scale factor G54 A30 B0 C0 I-1 J1 K1 " }, 
{ "title" : "Modes ", 
"url" : "_sm_cnc_din66025_modi.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Modes ", 
"snippet" : "Function : These commands determine whether the coordinates and axis midpoints are interpreted as absolute values or relative coordinates. G Code Description G90 The coordinates ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) are interpreted as absolute values. (This is the default setting.) G91 The c...", 
"body" : "Function : These commands determine whether the coordinates and axis midpoints are interpreted as absolute values or relative coordinates. G Code Description G90 The coordinates ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) are interpreted as absolute values. (This is the default setting.) G91 The coordinates ( X \/ Y \/ Z \/ A \/ B \/ C \/ P \/ Q \/ U \/ V \/ W ) are interpreted as values relative to the current position. G98 The axis midpoints ( I \/ J \/ K ) are interpreted as absolute values. G99 The axis midpoints ( I \/ J \/ K ) are interpreted as values relative to the start position. (This is the default setting.) Syntax G90\nG91\nG98\nG99 Examples Coordinate value as absolute value The interpolator moves to 10\/10 and then to 100\/10. The coordinates are interpreted as absolute values. N0 G90\nN10 G1 X10 Y10 F100 (Startposition)\nN20 G1 X100 (Nächste Position) Coordinate value as relative value The interpolator moves to 10\/10 and then to 110\/10. The coordinates are interpreted as relative values. N0 G91\nN10 G1 X10 Y10 F100\nN20 G1 X100 Coordinate value as absolute value in I\/J\/K The midpoint of the semicircle is at 150\/0. The coordinates are interpreted as absolute values. N00 G98\nN10 G92 X100 Y0 (Startposition)\nN20 G2 X200 Y0 I150 J0 F100 Coordinate value as relative value in I\/J\/K The midpoint of the semicircle is at 150\/0. The coordinates are interpreted as relative values. N00 G99\nN10 G92 X100 Y0 (Startposition)\nN20 G2 X200 Y0 I50 J0 F100 For more information, see: Configuring Single Additional Axes as Modulo Axes (PA\/PB\/…)" }, 
{ "title" : "Dwell Time ", 
"url" : "_sm_cnc_din66025_delay.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Dwell Time ", 
"snippet" : "G code : G4 Function : The command causes the interpolator to remain at the current position for a specific time. Example Dwell time N0 G4 T1 The interpolator pauses for one second....", 
"body" : "G code : G4 Function : The command causes the interpolator to remain at the current position for a specific time. Example Dwell time N0 G4 T1 The interpolator pauses for one second. " }, 
{ "title" : "Switch Point (H Function) ", 
"url" : "_sm_cnc_din66025_hfunction.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Switch Point (H Function) ", 
"snippet" : "Function : The switch point functionality or H function activates binary, path-dependent switches. A maximum number of three switch points ( MAX_SWITCHES ) can be processed for each path element. Syntax [G-Befehl] H O\/L First, the switch point number H<number> is defined, and then the position of th...", 
"body" : "Function : The switch point functionality or H function activates binary, path-dependent switches. A maximum number of three switch points ( MAX_SWITCHES ) can be processed for each path element. Syntax [G-Befehl] H O\/L First, the switch point number H<number> is defined, and then the position of the switch point in the path element is defined as either absolute (L<position> word) or relative (O<position> word). G Code Word Description H{-}<number> Number of the H function If the H number is positive, then the respective switch function is switched on. If the H number is negative, then the switch function is switched off. The H number is non-zero and in the range of -32768 to 32767. O<position> Relative position [0…1] in the path element 0: Start of the element 1: End L<position> L>0: Distance to the starting point L<0: Distance to the end point Graphical representation In the graphical editor, you can use the mouse to move the switch points along the path. When the mouse is moved over the H function, a tooltip is displayed with the H number of the H function. Effect on the SMC_Interpolator function block The interpolator sends the last switched H number to the iLastSwitch output. iLastSwitch is positive when the H function is switched on. The dwSwitches output is a bit mask. Bit number i indicates whether or not the H function (i+1) is currently set. If the H number is between 1 and 32, then the corresponding bit is set in the interpolator dwSwitches output. A negative value between -1 and -32 resets the bit. The iLastSwitch output has the number of the last run switch point, even if the value is outside the range of -32 to 32. Examples Switching off switch point 2 with position relative to the element Switch point 2 is switched off at position X=40\/Y=25 after the first quarter of the element. N90 G1 X20 Y20\nN100 G1 X100 Y40 H-2 O0.25 Switching on and off switch point 2 with position relative to start and end point Switch point 2 is switched on at position X=40, which is 20 units after the starting point of the path element. Switch point 2 is switched off at position X=90, which is 10 units before the end point. N90 G1 X20\nN100 G1 X100 H2 L20 H-2 L-10 " }, 
{ "title" : "M Function ", 
"url" : "_sm_cnc_din66025_mfunction.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ M Function ", 
"snippet" : "Function : M functions or additional functions start actions during the interpolation of G code. The interpolator decelerates to velocity 0, sends the number of the queued M function to the output wM , and waits for the confirmation in bAcknM before accelerating again. In contrast with the switch po...", 
"body" : "Function : M functions or additional functions start actions during the interpolation of G code. The interpolator decelerates to velocity 0, sends the number of the queued M function to the output wM , and waits for the confirmation in bAcknM before accelerating again. In contrast with the switch point, the program remains at the current position until the M function is confirmed by setting the input at the interpolator. If SMC_PreAcknowledgeM is executed, then the function block confirms the M function early. If the function block is executed on time, then the interpolator does not halt and the program continues as if the M instruction was not present. An M function is implemented by the application and not defined by the system. Syntax M K L O G Code Word Description M Number of the M function, M > 0 Note: The numbers 65533–65535 are reserved for internal functions. K Numeric parameter ( LREAL ) L Numeric parameter ( LREAL ) O References with O$var$ a variable of type SMC_M_PARAMETERS that contains other parameters. In the application, the parameter values of the variables are read at runtime by means of the function SMC_GetMParameters . Moreover, all parameters are evaluated at the time of decoding and saved in the data structure SMC_GEOINFO of the buffer SMC_OUTQUEUE . As a rule, this happens at a time before executing the M function at the interpolator. So that the variable can be found by the used function block (for example SMC_ReadNCFile2 ) while decoding, it has to be added to its SMC_VARLIST with the type SMC_VARTYPE.SMC_TYPE_USERDEF . Examples M with parameter The M function 10 starts. For the program execution of N90, the system waits until the confirmation is available. N90 M10 K100.7 M with additional parameter The M function 10 starts. The user-defined data structure g_myMParams (data type SMC_M_PARAMETER ) is referenced with O$var$ . g_myMParams contains additional parameters. The values of K, L, and the parameters from g_myMParams can be read at the time of the path stop of the M function. The is done by calling an instance of the function block SMC_GetMParameters . N150 M13 O$g_myMParams$ " }, 
{ "title" : "Timing Synchronization with Interpolator ", 
"url" : "_sm_cnc_din66025_time_synchronisation_with_interpolator.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Timing Synchronization with Interpolator ", 
"snippet" : "G code : G75 Function : The command prevents the function block of the decoder from processing G code until the interpolator has traveled through all previous objects. When the interpolator reaches G75 , all queues are empty and the NCDecoder and all preprocessing function blocks continue running. T...", 
"body" : "G code : G75 Function : The command prevents the function block of the decoder from processing G code until the interpolator has traveled through all previous objects. When the interpolator reaches G75 , all queues are empty and the NCDecoder and all preprocessing function blocks continue running. This function is useful for using variables. The decoder replaces the variables when the corresponding line is processed. However, the execution by the interpolator happens after a specified time according to the queue mechanism. You can use G75 for waiting and synchronizing the evaluation of the variables and the subsequent processing by the interpolator. Syntax G75 Example N10 G1 X100\nN20 G75\nN30 G1 Y$g_y$ The variable g_y is available with the element G1 and is not detected beforehand. If G75 is not inserted, then the NCDecoder processes line 30 immediately before the value is detected. G75 does not have any effect on the CNC editor or the paths that the CNC editor generates as SMC_OutQueue . " }, 
{ "title" : "Jump ", 
"url" : "_sm_cnc_din66025_jump.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Jump ", 
"snippet" : "G code : G20 Function : The command executes a conditional jump. Syntax G20 L K G Code Word Description L Jump target: Defined line number (example: L20 ) Jump Label The jump is defined by a question mark and an index (example: L?4 ). The command for the jump target itself is identified by an exclam...", 
"body" : "G code : G20 Function : The command executes a conditional jump. Syntax G20 L K G Code Word Description L Jump target: Defined line number (example: L20 ) Jump Label The jump is defined by a question mark and an index (example: L?4 ). The command for the jump target itself is identified by an exclamation mark and the corresponding index (example: L!4 ). The jump target can be attached to any G code command. This jump is used for automatically generated CNC programs when the target line is unknown. Jumps with unknown targets to jump labels work in the online decoder only (not in the CNC editor). Requirement: The line with the jump label has to be located after the line with the jump command. \"Jumping back\" is not possible. If the \"target line\" is not defined, then commands following the jump command are not executed. K Condition If K <> 0, then the jump is executed. If K is not defined, then an internal decoder variable is used. The value of the internal decoder variable can be defined with the Changing the Values of Variables command. The default value of this internal variable is -1 . Example: Execute jump until internal counter = 0 Ten lines are linked together by the relative mode. This results in a line movement to 100\/100. N00 G36 D10 (set counter to 10)\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN30 G37 D-1 (decrement counter)\nN40 G20 L20 (jump, if counter != 0) Example: Evaluate jump condition at time of decoding Requirement: The behavior of the variable bvar is programmed in the application. If the X-axis exceeds the position 15, then bvar FALSE is set. ( bVar is initially set to TRUE .) In the first program cycle, the X position is 10 and the program jumps to line 20. The loop is continually run because the evaluation of the condition takes place at the time of decoding and the interpolator was not started yet or is busy with the processing of objects at the beginning of the buffer. This condition fulfilled and the decoder jumps out of the loop only after enough objects are generated that the buffer is full and the interpolator begins processing. In the second run, the X-axis is not yet at position 20. The condition is not fulfilled and bVar was not set to FALSE in the IEC code. N0 G92 X0 Y0\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN30 G20 L20 K$bvar$ (jump, if counter != 0) Example: Insert timing synchronization G75 executes a timing synchronization of the interpolator. G75 pauses the decoder processing until the interpolator and the mechanics reach the respective position. N0 G92 X0 Y0\nN10 G91 (relative mode)\nN20 G01 X10 Y10 F100 (movement by distance 10\/10)\nN25 G75\nN30 G20 L20 K$x$ (jump, if counter != 0) For more information, see: Timing Synchronization with InterpolatorExample: Jump to jump label Note: Jumps to jump labels work in the online decoder only (not in the CNC editor). N0 G16 F100 E100 E-100\nN10 G20 L?4 \/\/unconditional jump to the unknown target with index 4\nN15 G20 L60\nN20 G1 X1\nN30 G1 X1 L!5 \/\/resolution unknown jump target with index 5\nN40 G1 Z1 L!4 \/\/resolution unknown jump target with index 4\nN50 G20 L15\nN55 G1 Y1\nN60 G0 X0 Y0 Z0 " }, 
{ "title" : "Arc ", 
"url" : "_sm_cnc_din66025_arc.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Arc ", 
"snippet" : "G code : G2 , G3 Function : The command interpolates an arc from the current position along a circular path to the target position. G2 moves clockwise and G3 moves counterclockwise. The arc is defined as follows: Radius method Target coordinate + radius: Target coordinates are defined in X\/Y\/Z. The ...", 
"body" : "G code : G2 , G3 Function : The command interpolates an arc from the current position along a circular path to the target position. G2 moves clockwise and G3 moves counterclockwise. The arc is defined as follows: Radius method Target coordinate + radius: Target coordinates are defined in X\/Y\/Z. The curve is defined by radius R. Midpoint method Target coordinate + midpoint coordinate: Target coordinates are defined in X\/Y\/Z. The curve is defined by the midpoint coordinate I\/J\/K. The midpoint coordinate is located on the perpendicular bisectors of the start and end points. If this is not the case, then the midpoint coordinate is corrected automatically. The deviation must not be greater than 10%. Opening angle method Opening angle + midpoint coordinate: Opening angle defined in T and midpoint coordinates in I\/J\/K. The target position is calculated automatically. Inconsistent parameters lead to a line being traveled instead of a circle. Examples: If the radius is less than half of the distance between the start and target, then the deviation cannot be corrected. This is also the case if the defined midpoint to the start and target position has a different distance. Syntax G2 X Y Z R A B C P Q U V W F E H L\/O D S\nG2 X Y Z I J K A B C P Q U V W F E H L\/O D S\nG2 I J K T A B C P Q U V W F E H L\/O D S\nG3 X Y Z R A B C P Q U V W F E H L\/O D S\nG3 X Y Z I J K A B C P Q U V W F E H L\/O D S\nG3 I J K T A B C P Q U V W F E H L\/O D S G Code Word Description X Y Z Target positions of the Cartesian axes R Circle radius I J K Circle midpoint coordinates T Opening angle (in degrees) A B C P Q U V W Target positions of the additional axes F E Path velocity, path acceleration\/deceleration H L\/O Switch point D Tool radius S S profile Graphical representation : An arc is represented by black end points. The end points can be moved when you select the element. Arc in 3D mode In 3D mode, the system defines the arcs by the interpolation plane that is defined by means of G15-G19. Example One semicircle in the X\/Z-plane and one semicircle in the X\/Y-plane N10 G1 X100 Y100\nN15 G18\nN20 G2 X200 R50\nN25 G17\nN30 G3 X100 R50 " }, 
{ "title" : "Radius method ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_535707857cba3404c0a86463692656db", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Arc \/ Radius method ", 
"snippet" : "You can use the radius method for generating an arc < 180°. The radius method is valid for two arcs. One is smaller than a semicircle and one is larger than a semicircle. The system always uses the smaller arc. Example Semicircle N10 G1 X100 Y100 F100 N20 G2 X200 Y100 R50 Use the midpoint method wit...", 
"body" : "You can use the radius method for generating an arc < 180°. The radius method is valid for two arcs. One is smaller than a semicircle and one is larger than a semicircle. The system always uses the smaller arc. Example Semicircle N10 G1 X100 Y100 F100\nN20 G2 X200 Y100 R50 Use the midpoint method with I\/J\/K for generating an arc with an opening angle greater than 180°. The radius method is unique, except in the case that the start and end points of the circle are identical. This defines either a null circle or a full circle. In this case, the system inserts a full circle. " }, 
{ "title" : "Midpoint method ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_7dc8851b7cba3404c0a864637c8195be", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Arc \/ Midpoint method ", 
"snippet" : "If you use the midpoint method, then you distinguish whether the coordinates I\/J\/K are relative or absolute. If I , J , and K are not specified correctly, then an arc is not possible and the system replaces it with a line. If it is correct, then the distance between the midpoint and the start or end...", 
"body" : "If you use the midpoint method, then you distinguish whether the coordinates I\/J\/K are relative or absolute. If I , J , and K are not specified correctly, then an arc is not possible and the system replaces it with a line. If it is correct, then the distance between the midpoint and the start or end point is identical. Examples Same semicircle as in the radius method; specified by means of relative midpoint N10 G1 X100 Y100 F100\nN15 G99\nN20 G2 X200 Y100 I50 J0 Same semicircle as in the radius method; specified by means of absolute midpoint N10 G1 X100 Y100 F100\nN15 G98\nN20 G2 X200 Y100 I150 J100 " }, 
{ "title" : "Opening angle method ", 
"url" : "_sm_cnc_din66025_arc.html#UUID-4db933f4-f28b-e82e-6def-34ec6902ab6f_id_bcb4a4f346debb3c0a8640e004fd71d_id_955d99e37cba3404c0a864634d5c784c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Arc \/ Opening angle method ", 
"snippet" : "If you define the circle by the opening angle T, then a maximum of three full circles are permitted (T ≤ 1080). The opening angle method is appropriate for an arc > 180°. Examples Same semicircle as in the radius method; specified by means of opening angle N10 G1 X100 Y100 N15 G99 N20 G2 I50 J0 T180...", 
"body" : "If you define the circle by the opening angle T, then a maximum of three full circles are permitted (T ≤ 1080). The opening angle method is appropriate for an arc > 180°. Examples Same semicircle as in the radius method; specified by means of opening angle N10 G1 X100 Y100\nN15 G99\nN20 G2 I50 J0 T180 Helix (two full circles) N10 G1 X100 Y100\nN15 G99\nN20 G2 I50 J0 T720 " }, 
{ "title" : "Ellipse ", 
"url" : "_sm_cnc_din66025_ellipse.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Ellipse ", 
"snippet" : "G code : G8 , G9 Function : The command specifies an ellipse arc through the target coordinates X\/Y, the ellipse midpoint I\/J, the ellipse main axis directions K, and the length ratio R between the primary and secondary axes. Syntax G8 X Y Z R I J K A B C P Q U V W F E H L\/O D S G9 X Y Z R I J K A B...", 
"body" : "G code : G8 , G9 Function : The command specifies an ellipse arc through the target coordinates X\/Y, the ellipse midpoint I\/J, the ellipse main axis directions K, and the length ratio R between the primary and secondary axes. Syntax G8 X Y Z R I J K A B C P Q U V W F E H L\/O D S\nG9 X Y Z R I J K A B C P Q U V W F E H L\/O D S G Code Word Description X Y Z Target positions of the Cartesian axes R Length ratio R between primary and secondary axes. Range: 0 < R <= 1 R is used only if the ellipse arc is not defined uniquely by the end points, midpoint, and slope of the primary axis. This is the case when both end points have the same distance to the primary axis. Then, both end points have to have the same distance to the secondary axis. Otherwise, there is no ellipse through these points and the system replaces the ellipse with a line. I J Midpoint K Direction of the ellipse primary axis (in degrees) 0: In the direction of the X-axis 90: In the direction of the Y-axis -90: In the opposite direction of the Y-axis A B C P Q U V W Target positions of the additional axes F E Path velocity, path acceleration\/deceleration H L\/O Switch point D Tool radius S S profile The ellipse is a 2.5D object. This means that the ellipse always belongs in the X\/Y-plane. Ellipses in other planes are not supported. Example N10 G0 X100 Y100 F100\nN15 G98\nN20 G8 X200 Y100 I150 J100 K45 R0.5 " }, 
{ "title" : "Linear Motion ", 
"url" : "_sm_cnc_din66025_line.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Linear Motion ", 
"snippet" : "G code : G1 Function : This positioning command executes a line interpolation. The line interpolation moves the interpolation point from the current position to the defined target coordinates on a line. All axes arrive there at the same time. The target coordinates (X\/Y\/Z) have to be defined for the...", 
"body" : "G code : G1 Function : This positioning command executes a line interpolation. The line interpolation moves the interpolation point from the current position to the defined target coordinates on a line. All axes arrive there at the same time. The target coordinates (X\/Y\/Z) have to be defined for the description of the lines. In addition to motion in space, you can specify target positions for the additional axes A\/B\/C\/P\/Q\/U\/V\/W which are reached at the same time with the Cartesian target coordinates. Two consecutive identical positions always result in a movement stop at this position. The stop also occurs when the subsequent path connects steadily and could be traveled without stopping. Syntax G1 X Y Z A B C P Q U V W F E H L\/O D S G Code Word Description X Y Z Target positions of the Cartesian axes A B C P Q U V W Target positions of the additional axes F E Path velocity, path acceleration\/deceleration H L\/O Switch point D Tool radius S S profile Examples Linear interpolation The tool is positioned at the start position 0\/0\/0 (preset) and then travels in a straight line to the target position 1\/2\/3 at velocity 1, acceleration 10, and deceleration 20. At the same time, the orientation axis A is traveled at 180 degrees: N010 G01 X1 Y2 Z3 A180 F1 E10 E-20 Start position Start position 50\/50\/50, linear interpolation from 50\/50\/50 to 64\/30\/0 with feed 100 N000 G92 X50 Y50 Z50 F100\nN010 G01 X64 Y30 Z0 " }, 
{ "title" : "Parabola ", 
"url" : "_sm_cnc_din66025_parabel.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Parabola ", 
"snippet" : "G code : G6 Function : The command interpolates a parabola which is defined by the coordinates of the end point X\/Y\/Z and the vertex I\/J. The vertex is the point where the tangent of the element is parallel to the connecting line of the start and end point. A parabola is a 2.5D object that is always...", 
"body" : "G code : G6 Function : The command interpolates a parabola which is defined by the coordinates of the end point X\/Y\/Z and the vertex I\/J. The vertex is the point where the tangent of the element is parallel to the connecting line of the start and end point. A parabola is a 2.5D object that is always in the X\/Y-plane. Parabolas on other planes are not supported. Syntax G6 X Y Z I J A B C P Q U V W F E H L\/O D S G Code Word Description X Y Z Target positions of the Cartesian axes I J Vertex of the parabola A B C P Q U V W Target positions of the additional axes F E Path velocity, path acceleration\/deceleration H L\/O H function D Tool radius S S profile Example N010 G00 X100 Y200 Z0 F100\nN020 G98\nN030 G06 X-100 Y200 Z00 I0 J0 " }, 
{ "title" : "Positioning ", 
"url" : "_sm_cnc_din66025_positioning.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Positioning ", 
"snippet" : "G code : G0 , G92 Function : These commands position the tool. G0 commands a rapid positioning on a straight line to the defined position (normally without tool operation). G92 immediately sets the position. The result is that a jump is also executed on the axes. If SMC_ControlAxisByPos.bAvoidGaps:=...", 
"body" : "G code : G0 , G92 Function : These commands position the tool. G0 commands a rapid positioning on a straight line to the defined position (normally without tool operation). G92 immediately sets the position. The result is that a jump is also executed on the axes. If SMC_ControlAxisByPos.bAvoidGaps:=TRUE is set, then a jump is not executed. Instead, all axes are traveled individually to the target position in the shortest distance. G92 can be inserted at the beginning of the path in order to set the start position. In a series of G92 commands, the last one is executed first. The previous ones are skipped. If a G1 block with identical coordinates is inserted, then the jump is executed for one cycle. This is an advantage if the path between the positions of the jump commands is not important, but the set position should be traveled as fast as possible. The SMC_ControlAxisByPos* POUs detect a jump to the specified values, pause the interpolator, and interpolate each axis individually as fast as possible. Two consecutive identical positions always result in a movement stop at this position. The stop also occurs when the subsequent path connects smoothly and could be traveled without stopping. For more information, see library documentation on Direct Axis Control Syntax G0 X Y Z A B C P Q U V W F FF E EF H L\/O S\nG92 X Y Z A B C P Q U V W H L\/O G Code Word Description X Y Z Target positions of the Cartesian axes A B C P Q U V W Target positions of the additional axes E Path acceleration\/deceleration EF Path acceleration\/deceleration only for G0 motion. If is set EF <> 0, then the value that is defined in E is not taken into consideration for G0 movements. F Path velocity FF Velocity that is used only for G0 movements. If is set FF <> 0, then the value that is defined in F is not taken into consideration for G0 movements. H L\/O H function S S profile Graphical representation In the graphical editor, G0 commands are represented by a green line. G92 commands are not represented directly. They simply move the starting point of the subsequent element. Positioning commands can be inserted only in the CNC text editor or in the tabular editor. They can be moved in the graphical editor. Examples Positioning with linear interpolation with defined feed N0 G92 X10 Y10 Sets the start position at 10\/10\nN10 G1 X20 F10 Linear interpolation to 20\/10 with feed 10\nN20 G0 Y20 F100 Linear positioning to 20\/20 with feed 100 Different positioning modes N0 G92 X100 Y100 F100 Sets the position at 100\/100\nN10 G1 X100 Y100 Saves the output of this position for one cycle\nN20 G92 X50 Y100 Sets the position suddenly to 50\/100 Positioning with defined path velocity N1 G0 X1000 Y0 FF1000 EF10000 EF-10000 Positioning with velocity 1000\nN2 G1 Y100 F100 E100 E-100 Interpolating positioning with velocity 100\nN3 G0 X0 Y0 Positioning with velocity 1000\nN4 G0 X1000 FF0 EF0 Positioning with velocity 100 because FF and FE are reset; thus the values in F and E are used. " }, 
{ "title" : "Spline ", 
"url" : "_sm_cnc_din66025_spline.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Spline ", 
"snippet" : "G code : G5 , G10 Function : The command interpolates the path element with a spline so that the transitions from the previous path element and to the next path element merge into each other without any breaks. At the same time, the spline segment from the system is calculated so that the end tangen...", 
"body" : "G code : G5 , G10 Function : The command interpolates the path element with a spline so that the transitions from the previous path element and to the next path element merge into each other without any breaks. At the same time, the spline segment from the system is calculated so that the end tangent of the previous path element agree with the start tangent of the spline. Likewise, the end tangent of the spline agree with the subsequent path element. Function : The command creates a spline segment for the given position. The transitions from the previous path element and to the following path element are continuously in position and tangent. Syntax G5 X Y Z A B C P Q U V W F E H L\/O D S\nG10 X Y Z A B C P Q U V W F E H L\/O D S G Code Word Description X Y Z Target positions of the Cartesian axes A B C P Q U V W Target positions of the additional axes F E Path velocity, path acceleration\/deceleration H L\/O Switch point D Tool radius S S profile Multiple consecutive spline segments are connected as follows: Start tangent If a path element with tool operation exists (example: G1, G2, G3, G8, G9), then the end tangent of the path element is used as the start tangent for the spline. If no path element is available with tool operation (e.g. G0, G92, M), then the connecting line between the starting point and the first spline point is used as a start tangent. Tangent in the middle of the spline Adjacent points are connected. The tangent of the point is parallel to this connecting line (green line). End tangent If a path element with tool operation exists (example: G1, G2, G3, G8, G9), then the start tangent of the path element is used as the end tangent for the spline. If no path element is available with tool operation (for example, G0, G92, M), then the connecting line between the end point and the first spline point is used as an end tangent. Examples Staircase profile with splines rounded N0 G0 X0 Y0 Z0 F100 (Startposition)\nN10 G5 X20 Y0\nN20 G5 X20 Y20\nN30 G5 X40 Y20\nN40 G5 X40 Y40 Profile rounded with double spline N0 G0 X0 Y0 F100 (Startposition)\nN5 G1 X5 Y0\nN10 G5 X20 Y0\nN20 G5 X20 Y20\nN21 G5 X20 Y20\nN30 G5 X40 Y20\nN40 G5 X40 Y40\nN45 G1 X0 Y40 The spline point for X20 Y20 exists two times. In this way, the spline is interrupted and restarted. This is determined by the definition method of the tangent at this point. The start and end points are defined by the start tangents of the preceding and subsequent line segment. " }, 
{ "title" : "Preprocessing ", 
"url" : "_sm_cnc_din66025_preprocessor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Preprocessing ", 
"snippet" : "G-Code : G40 , G41 , G42 , G43 , G50 , G51 , G52 , G60 , G61 , G70 , G71 Function : The commands activate preprocessing modules, such as SMC_SmoothPath , SMC_RoundPath , SMC_AvoidLoop , SMC_ToolCorr , SMC_ToolLengthCorr , and SMC_ToolRadiusCorr . If the Show preprocessed path option is selected, the...", 
"body" : "G-Code : G40 , G41 , G42 , G43 , G50 , G51 , G52 , G60 , G61 , G70 , G71 Function : The commands activate preprocessing modules, such as SMC_SmoothPath , SMC_RoundPath , SMC_AvoidLoop , SMC_ToolCorr , SMC_ToolLengthCorr , and SMC_ToolRadiusCorr . If the Show preprocessed path option is selected, then the edited path is visible in the graphical editor. Syntax G40\nG41 D\nG42 D\nG50\nG51 D\nG52 D\nG60\nG61 G Code Word Description D Tool radius or overlay radius for G51\/G52 . For versions before 4.18.0.0: The angle rounding\/smoothing ( G51\/G52 ) and tool radius correction ( G41\/G42 ) can influence each other because both preprocesses interpret each D word in the G code. For example, if a tool radius correction with radius=1 is active when an angle rounding starts with D=5, then as a result the tool radius correction also uses a radius of 5. For version 4.18.0.0 and higher: Angle rounding\/smoothing ( G51\/G52 ) and tool radius correction ( G41\/G42 ) can be used simultaneously without affecting each other. The following behavior applies for this. For tool radius correction ( G41\/G42 ): By default, the 'Tool' radius used by SMC_ToolRadiusCorr is 0. If a D word is specified after the G words G41\/G42 , then the 'Tool' radius is adjusted and taken into account by the function blocks. When no value is specified, the currently set 'Tool' radius is used. For angle rounding\/smoothing ( G51\/G52 ): By default, the 'Smooth' radius used by SMC_Round\/SmoothPath is 0. If a D word is specified after any G word (except G36\/G37\/G40\/G41\/G42 ) or on its own (for example, N00 D5 ), then this affects the current 'Smooth' radius and is taken into account by the SMC_Round\/SmoothPath function blocks. Commands for tool correction G Code Description G40 End of tool radius correction G41 Start of tool radius correction to the left of the workpiece G42 Start of tool radius correction to the right of the workpiece G43 Starts the tool length correction The tool offset to be corrected is specified with the I, J, K parameters (for X, Y, Z ). The tool length correction is deactivated by setting the parameters to zero. After activation or deactivation, ramping in or out is performed. For more details, see: SMC_ToolLengthCorr Note: The length of the tool must not change during an active tool radius correction because a jump in the path can result. The tool length correction (G43) works in the online decoder only (not in the CNC editor). Commands for angle rounding and angle smoothing G Code Description G50 End of angle rounding and smoothing G51 Start of angle smoothing by means of SMC_SmoothPath G52 Start of angle rounding by means of SMC_RoundPath G70 End of smoothing of additional axes by means of SMC_SmoothAddAxes G71 Start of smoothing of additional axes by means of SMC_SmoothAddAxes Commands for loop suppression G Code Description G60 End of function for loop suppression G61 Start of function for loop suppression by means of SMC_AvoidLoop Example: Angle smoothing N0 G51 D10 F100\nN10 G01 X$g_x$ Y0 F50 E30 E-30\nN20 G01 X0 Y$g_y$\nN30 G01 X0 Y0\nN40 G50 " }, 
{ "title" : "Additional Spline Axes A, B, C ", 
"url" : "_sm_cnc_din66025_additional_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Additional Spline Axes A, B, C ", 
"snippet" : "G code word : A , B , C Function : Use A , B , and C to define the target positions for additional spline axes. These axes are similar to P , Q , U , V , and W . While P , Q , U , and V are interpolated linearly, A , B , and C are interpolated with a 3rd degree polynomial. Using A , B , or C exclude...", 
"body" : "G code word : A , B , C Function : Use A , B , and C to define the target positions for additional spline axes. These axes are similar to P , Q , U , V , and W . While P , Q , U , and V are interpolated linearly, A , B , and C are interpolated with a 3rd degree polynomial. Using A , B , or C excludes the use of the additional axes U , V , and W because U , V , and W define the gradient. The axes A , B , or C can be selected with bits 3, 4, or 5 at the wAxis input of SMC_LimitDynamics or wAddAxis of SMC_CheckForLimits . The SMC_SmoothPath , SMC_SmoothMerge , SMC_SmoothBSpline , and SMC_RecomputeABCSlopes function blocks automatically determine the slope of the additional axes. This means that the definition of U , V , or W is not necessary. Example 1 G Code N10 G0 X0 A0 P0 F10 E30 E-30\nN20 G1 X100 A100 P100 The linear additional axis P is interpolated linearly to the traveled path. Accordingly, its time profile returns that of the path velocity. The additional spline axis A is interpolated as a polynomial function. Example 2 Using the spline function is necessary, especially if a path with constant tangent transitions is used, which the interpolator does not have to decelerate to velocity 0: G Code N10 G0 X0 A0 P0 F10 E30 E-30\nN20 G1 X50 A40 P40\nN30 G1 X100 A100 P100 In the linear case, you see a jump in the velocity, because 40 units of the additional axis run on 50 path units in the first part, and 60 units of the additional axis run on 50 path units in the second part. Because the path velocity is defined only according to the path in Cartesian space (X Y Z), a constant velocity in X results in a velocity jump in P: The spline axis displays the following profile: Example 3 The slope of the axes A, B, and C at the end position can be defined by the U, V, and W word. The unit of the slope is the path unit of the additional axis per path unit in the space. G Code N10 G0 X0 A0 F10 E30 E-30\nN20 G1 X100 A100 U1.5\nN30 G1 X200 A200 U0 The user-programmed slope (U=2) of the A axis applies because this program contains a continuous transition between N20 and N30 . Therefore, for X=100 the position of the A axis increases two times as fast as the path length. " }, 
{ "title" : "Smoothing of Additional Axis Motion using Multiple Objects ", 
"url" : "_sm_cnc_din66025_smooth_additional_axis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Smoothing of Additional Axis Motion using Multiple Objects ", 
"snippet" : "G code : G70 , G71 Function : G71 starts and G70 ends the smoothing of motion on the additional axis that is given in L and travels over multiple objects. Syntax G70 L4 G71 L4 G Code Word Additional Axis L4 A L5 B L6 C L7 P L8 Q L9 U L10 V L11 W...", 
"body" : "G code : G70 , G71 Function : G71 starts and G70 ends the smoothing of motion on the additional axis that is given in L and travels over multiple objects. Syntax G70 L4\nG71 L4 G Code Word Additional Axis L4 A L5 B L6 C L7 P L8 Q L9 U L10 V L11 W " }, 
{ "title" : "Configuring Single Additional Axes as Modulo Axes (PA\/PB\/…) ", 
"url" : "_sm_cnc_din66025_define_additional_axis_modulo.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Configuring Single Additional Axes as Modulo Axes (PA\/PB\/…) ", 
"snippet" : "Function: For the axes A, B, C, P, Q, U, V, and W, a modulo period can be specified by setting the words PA , PB , PC , etc. By default, PA , PB , etc. have the value 0, which means that the axis is linear. If an additional axis is configured as a modulo axis, then the shortest distance is always in...", 
"body" : "Function: For the axes A, B, C, P, Q, U, V, and W, a modulo period can be specified by setting the words PA , PB , PC , etc. By default, PA , PB , etc. have the value 0, which means that the axis is linear. If an additional axis is configured as a modulo axis, then the shortest distance is always interpolated from the start position to the target position. For a modulo period of 360, travel is from the start position 270 to the target position 45 as follows: in the positive direction (past 360) by 135 units altogether and not in the negative direction by 225 units, as for a linear time line. The position output of the interpolator can be outside of the interval [0..period limit[. (For example, 400 instead of 40 for a modulo period of 360.) The position is moved into the modulo range by following POUs, such as SMC_ControlAxisByPos , or SMC_FollowPosition . Example Rotary control of an axis by modulo mode In block 30, axis A is moved in the positive direction by 90° from 270° to 360°=0°. N10 PA360 (A axis has a period of 360 degree)\nN20 G92 A270 (Set the position of A axis to 270)\nN30 G1 A0 " }, 
{ "title" : "Using Variables ", 
"url" : "_sm_cnc_din66025_usage_of_variables.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Using Variables ", 
"snippet" : "Syntax $<Variablenname>$ Valid IEC base types for variables and expressions: INT , SINT , USINT , UINT , DINT , UDINT , BYTE , WORD , DWORD , REAL , and LREAL . Exceptions include the O parameter for M functions (which expects a variable of type SMC_M_PARAMETERS ) and G36\/G37 (where string variables...", 
"body" : "Syntax $<Variablenname>$ Valid IEC base types for variables and expressions: INT , SINT , USINT , UINT , DINT , UDINT , BYTE , WORD , DWORD , REAL , and LREAL . Exceptions include the O parameter for M functions (which expects a variable of type SMC_M_PARAMETERS ) and G36\/G37 (where string variables are also permitted). Variables or expressions can be defined for all words, except N words (block numbers). IEC expressions and variables are replaced by their current values only in the online decoder POU. This happens when the line is decoded, which is some time before the element is processed in the interpolator. The value of a variable in offline mode is changed in the Offline Values of Variables dialog. You open the dialog by means of the CNC → Set Variable command or the Variables button in the properties of the CNC object. Using a global variable in offline mode Declare the variables in the global variable list. Use the variables in the CNC editor in at least one location. Execute the CNC → Set Variable command. The Offline Values of Variables dialog opens. Specify the desired values in the table. Example VAR_GLOBAL\n rVal_x1: REAL:=100;\n rVal_y1: REAL:=50;\nEND_VAR\n\n\/\/ CNC-Editor\nN0 G01 X$rVal_x1$ Y0 F50 E30 E-30\nN10 G01 X0 Y$rVal_y1$\nN20 G01 X0 Y0 Behavior in online mode When the decoder POU processes the program online as a program variable with SMC_CNC_REF , variables can be used. The variables are replaced at the time when the decoder processes the respective line. Using variables in G code programs that are read online requires additional preparation with SMC_VARLIST . If the CNC program is compiled as SMC_OUTQUEUE , then the variable mechanism does not work. This is because the path is generated offline and passed as an unchangeable data structure of the application. In this case, the editor replaces the variable with its offline value for display in offline mode. For more information, see: CNC Data Structures and Global Access" }, 
{ "title" : "Changing the Values of Variables ", 
"url" : "_sm_cnc_din66025_change_variable_values.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Changing the Values of Variables ", 
"snippet" : "G code : G36 , G37 Function : The commands change the value of a variable. G36 writes the specified value to a variable. G37 increments the variable by the specified value. O$var$ defines the variable that is edited. D defines the value that is written for G36 or added for G37 . The command is used,...", 
"body" : "G code : G36 , G37 Function : The commands change the value of a variable. G36 writes the specified value to a variable. G37 increments the variable by the specified value. O$var$ defines the variable that is edited. D defines the value that is written for G36 or added for G37 . The command is used, for example, for a loop counter required for conditional jumps. Syntax G36 O D\nG37 O D G Code Word for G36 Description O Variable that is written. If O is not defined, then an internal decoder variable is used. The default value of this internal variable is -1 . The internal variable can be used in the Jump command. D New variable value G Code Word for G37 O Variable that is incremented. If O is not defined, then an internal decoder variable is used. D Increment Example Programing the counter (if the path is processed online) The g_i global variable is set to 5. N1000 G36 O$g_i$ D5 Lines 1010 and 1020 are traveled five times. N1000 G36 O$g_i$ D5\nN1010 G1 X100 F100 E100 E-100\nN1020 G1 X0\nN1030 G37 O$g_i$ D-1\nN1040 G20 L1010 K$g_i$ The mechanism functions only if the path is processed online, because only then can variables be used. This mechanism does not work in the CNC editor. Programming the counter for offline mode To work with the editor offline, specify no variable by means of O . Then an implicit decoder variable of type INT is used. However, only one variable is available. You cannot program any nested jumps or loops. Using string variables You can use a string variable in the O word in G code. Moreover, a string value may be assigned and inserted to this variable by means of the command G36 and G37 . Example N10 G36 O$strTest$ D'Name' The strTest variable gets the Name value. N20 G37 O$strTest$ D'=Test' The value =Test is added to the variable strTest . If string variables are used in the CNC program, and if the CNC program (in the IEC program) is read by means of the SMC_ReadNCFile function block, then buffers for the strings have to be reserved in the IEC program. Otherwise, the error SMV_RNCF_NO_STRINGBUFFER occurs. The SMC_StringBuffer function block is available for this purpose. Every string of the CNC program requires its own space in the function block instance of SMC_StringBuffer , even if the same string occurs multiple times. The following declaration can buffer 32 strings, for example: sb: SMC_StringBuffer(uiBufferSize := 32); The the function block instance sb is passed as a pointer to the pStringBuffer input of the SMC_ReadNCFile instance. " }, 
{ "title" : "Subprograms ", 
"url" : "_sm_cnc_din66025_subprograms.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Subprograms ", 
"snippet" : "Function : Call of a subprogram Frequently recurring tasks, such as pocket milling, hole drilling, and tool changing, can be swapped out to G code subprograms and called from there. During a call, parameters can be passed to the subprogram. The data types BOOL , LREAL , and STRING are permitted for ...", 
"body" : "Function : Call of a subprogram Frequently recurring tasks, such as pocket milling, hole drilling, and tool changing, can be swapped out to G code subprograms and called from there. During a call, parameters can be passed to the subprogram. The data types BOOL , LREAL , and STRING are permitted for this purpose. If you use subprograms, then you need to use the function blocks SMC_ReadNCFile2 and SMC_NCInterpreter instead of SMC_ReadNCFile and SMC_NCDecoder . Subprograms work in the online decoder only (not in the CNC editor). Each subprogram is stored in a separate file. These files are saved in one or more subdirectories on the controller. The file names have to be written in lowercase, have the file extension .cnc , and correspond to the name of the subprogram. Example: Subprogram name \"Drill\" -> file name drill.cnc . Note that the file name of the subprogram has to be written in lowercase. The SMC_ReadNCFile2 POU has an input aSubProgramDirs : ARRAY[0..4] OF STRING(174) . Up to five subdirectories can be specified beyond this. They are scanned in the given order. If there are subprograms with the same name in multiple directories, then the subprogram is found that has the directory with the lowest index in the array. The subprogram name is converted to lowercase. Example aSubProgramDirs = ['subprograms\/user', 'subprograms\/system', ''] The subprogram DrillA1 is scanned first in the file subprograms\/user\/drilla1.cnc . If this file does not exist, then the search continues in subprograms\/system\/drilla1.cnc . It is possible to call subprograms indirectly by means of a variable (more precisely, by means of an expression of type STRING ).  The expression (and therefore also any lookup of variables) is evaluated – generally in the case when using variables in the G code – at the time of the preprocessing when the interpreter reaches the line. In this case, the type checking of the arguments is done only when the interpreter has reached the line and not already during parsing, as is the case with static calls. Subprograms cannot be created offline in the CNC editor. Maximum nesting depth of subprogram calls Before version 4.18.0.0: The maximum nesting depth of subprogram calls is limited to 14. Version 4.18.0.0 and higher: The nesting depth is now limited only by the memory. The maximum value can be changed using the library parameter SMC_CNC_LibParams.MAX_SUBPROGRAM_NESTING_DEPTH . " }, 
{ "title" : "Syntax for the call ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_f644d63d98ef7863c0a864636e4c0bd6", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Subprograms \/ Syntax for the call ", 
"snippet" : "Subprogram calls are special blocks in the G code that consist of a block number and a call only. No additional words are permitted. Moreover, there is a dynamic call in which the name of the subprogram is still unknown when parsing and is prepared (for example, by an IEC variable). N<SentenceNo> <N...", 
"body" : "Subprogram calls are special blocks in the G code that consist of a block number and a call only. No additional words are permitted. Moreover, there is a dynamic call in which the name of the subprogram is still unknown when parsing and is prepared (for example, by an IEC variable). N<SentenceNo> <Name> <BracketOpen> <ActualParamList> <BracketClosed>\nN<SentenceNo> DYNCALL <BracketOpen> <SubNameExp> [, <ActualParamListNotEmpty] <BracketClosed>\n\n<SubNameExp> : An expression with exactly one value of type STRING\n<ActualParamList> ::= Empty | <ActualParamListNotEmpty>\n<ActualParamListNotEmpty> ::= <ActualParamValue> | <ActualParamValue>, <ActualParamListNotEmpty> <Name> Valid IEC identifier with minimum 3 and maximum 80 characters. It has to correspond to the file name (without extension) where the subprogram is defined. Uppercase or lowercase does not matter for subprogram names. The characters [a-zA-Z0-9_] are permitted. The following keywords are invalid as names: SUBPROGRAM, RETURN, END_SUBPROGRAM, RESTORE_MODES, BOOL, LREAL, STRING, LET, DYNCALL, IF, ELSE, END_IF, CASE, END_CASE, FOR,END_FOR, WHILE, END_WHILE, REPEAT, UNTIL, END_REPEAT . <ActualParamList> There has to be exactly the same number of parameter values specified as the subprogram defines (see \"Syntax for the declaration\"). The type of each parameter value has to agree with the declaration. <BracketOpen>\/<BracketClosed> For reasons of compatibility, braces are used instead of parentheses in default settings for SMC_ReadNCFile2 and subprogram calls and declarations. Parentheses are valid in G code for comments. The function block SMC_ReadNCFile2 has a mode ( bParenthesesAsComments input) where parentheses are not comments. Instead, multiline comments are opened with (* and closed with *) . In this new mode, both braces and parentheses can be used for subprogram calls and declarations. <ActualParamValue> Variable, literal, or any expressions Example N10 SUB1()\nN20 DRILL(10.0)\nN30 SUB2(5, \"Text\", 2.5)\nN40 G36 O#SUBNAME D'DRILL' % Indirect call via local variable\nN40 DYNCALL(#SUBNAME, 2) % equivalent to N40 DRILL(2)\nN50 DYNCALL($SUBNAME$, 2, 4) % Indirect call via IEC variable " }, 
{ "title" : "Syntax for the declaration ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_02170a739e1947dec0a864637ea0fc00", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Subprograms \/ Syntax for the declaration ", 
"snippet" : "A subprogram has to be saved in a separate file. The first line (neither empty nor a comment line) has to contain the declaration of the subprogram. The following syntax applies: SUBPROGRAM <Name> <BracketOpen> <FormalParamList> <BracketClosed> <RESTORE_OPT> <Inhalt Unterprogramm> END_SUBPROGRAM <Fo...", 
"body" : "A subprogram has to be saved in a separate file. The first line (neither empty nor a comment line) has to contain the declaration of the subprogram. The following syntax applies: SUBPROGRAM <Name> <BracketOpen> <FormalParamList> <BracketClosed> <RESTORE_OPT>\n<Inhalt Unterprogramm>\nEND_SUBPROGRAM\n\n<FormalParamList> ::= Empty | <FormalParamListNotEmpty>\n<FormalParamListNoEmpty> ::= <FormalParam> | <FormalParam> , <FormalParamListNotEmpty>\n<FormalParam> ::= <ParamName> : <ParamType>\n<ParamName> ::= #[a-zA-Z0-9_]+\n\n<ParamType> ::= LREAL | BOOL | STRING ; String with a maximum length of 255 bytes\n<RESTORE_OPT> ::= RESTORE_MODES <ParamName> The length of the name may be a maximum of 80 characters (not including the prefix # ). RESTORE_MODES If this keyword is specified, then the following modal states are restored when returning to the calling program (set to the value that it had at the call): Active G code Relative\/Absolute mode (G90\/G91, G98\/G99) Circular plane and 2D\/3D mode Decoder coordinate system (including scaling) Feed rates (path and additional axes), rapid traverse rate, maximum accelerations and decelerations (path and additional axes) Feature flags and general parameters (G38) Tool radius (D word) Tool offsets (G43) S profile (S word) The following modal states are not restored: Current position of the decoder\/interpreter as well as the current cardinal spline state The position includes the entire structure SMC_POSINFO (i.e., X, Y, Z, the orientation, and all additional axes). State (on\/off) of the path preprocessing POUs (G40-G43, G50-G52, G60-G61, G70-G71) Modulo setting of the additional axes (PA, PB, …) Note: Regardless of this keyword, the implicit counter variables (G36, G37) are restored when returning from the subprogram to the calling program. Examples SUBPROGRAM SUB1() ; no formal parameters\nSUBPROGRAM DRILL(#depth : LREAL)\nSUBPROGRAM SUB2(#a : LREAL, #b : STRING, #c : LREAL)\nSUBPROGRAM SRM1() RESTORE_MODES " }, 
{ "title" : "Syntax for the return ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_4557d91f9e1947dec0a864630016f87d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Subprograms \/ Syntax for the return ", 
"snippet" : "The return is done either at the end of the subprogram text (before the END_SUBPROGRAM ) or explicitly with the following syntax: N<block number> RETURN ....", 
"body" : "The return is done either at the end of the subprogram text (before the END_SUBPROGRAM ) or explicitly with the following syntax: N<block number> RETURN . " }, 
{ "title" : "Using the formal parameters in the subprogram ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_ba614a0b6544562fc0a864631e9ee966", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Subprograms \/ Using the formal parameters in the subprogram ", 
"snippet" : "The values of the formal parameters can be accessed in the subprogram by #<ParamName> . The number of formal parameters is limited to 21. Example SUBPROGRAM SUB(#Param1 : LREAL) N10 G01 X#Param1...", 
"body" : "The values of the formal parameters can be accessed in the subprogram by #<ParamName> . The number of formal parameters is limited to 21. Example SUBPROGRAM SUB(#Param1 : LREAL)\nN10 G01 X#Param1 " }, 
{ "title" : "Display of the call stack ", 
"url" : "_sm_cnc_din66025_subprograms.html#UUID-5ae0ee38-9a73-3522-df9d-a1bf2b7d9e30_id_b957684a5e22cbc0a8646330c23703_id_1c910ecf4b371465c0a86463522d8482", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Subprograms \/ Display of the call stack ", 
"snippet" : "The interpreter ( SMC_NCInterpreter ) has an output that contains the 10 top active programs\/subprograms: aActivePrograms : ARRAY[0..9] OF STRING . The first entry ( aActivePrograms[0] ) is the currently interpreted program\/subprogram. The second entry ( aActivePrograms[1] ) is the calling program\/s...", 
"body" : "The interpreter ( SMC_NCInterpreter ) has an output that contains the 10 top active programs\/subprograms: aActivePrograms : ARRAY[0..9] OF STRING . The first entry ( aActivePrograms[0] ) is the currently interpreted program\/subprogram. The second entry ( aActivePrograms[1] ) is the calling program\/subprogram and so on. If there is no calling program, then the corresponding string is empty. The call stack can also be displayed at interpolation time. The SMC_DisplayNCCallstack POU shows the active programs\/subprograms in the same format as the interpreter, only later (namely when the movement is run). In doing so, the interpreter output CallstackInfo (SMC_NCCallstackInfo) and the interpolator are passed to it as VAR_IN_OUT variables. SMC_NCCallstackInfo stores all call stack changes, including the corresponding SMC_GeoInfo object number, in a ring buffer. At this time, this restricts the number of storable call stack changes between the interpretation time and the interpolation time to 128. Because the ring buffer does not meet multitasking criteria, SMC_DisplayNCCallstack has to be called from the interpreter task. The sample program CNC Example 07: Using Expressions and Subprograms shows an example of the display of the call stack at interpolation time. " }, 
{ "title" : "Expressions ", 
"url" : "_sm_cnc_din66025_expressions.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Expressions ", 
"snippet" : "Function : In version 4.4.0.0 and higher, it is possible to use mathematical, Boolean, and string expressions. The SMC_ReadNCFile2 and SMC_NCInterpreter function blocks have to be used for this (instead of SMC_ReadNCFile and SMC_NCDecoder ). Expressions work in the online decoder only (not in the CN...", 
"body" : "Function : In version 4.4.0.0 and higher, it is possible to use mathematical, Boolean, and string expressions. The SMC_ReadNCFile2 and SMC_NCInterpreter function blocks have to be used for this (instead of SMC_ReadNCFile and SMC_NCDecoder ). Expressions work in the online decoder only (not in the CNC editor). In principle, expressions can be used in G-code in two positions: As values of G words (one G word consists of an address and a value, for example \"G1\") As transfer parameters for subprogram calls " }, 
{ "title" : "Syntax – General ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_42546a9cc18a4349c0a86463750fefea", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Expressions \/ Syntax – General ", 
"snippet" : "An expression can consist of the following elements: Numeric and string literals Global and local variables Infix operators and functions Commas and brackets In the same way, parentheses (if not used for identifying comments) and braces can be used for structuring of expressions. This means that the...", 
"body" : "An expression can consist of the following elements: Numeric and string literals Global and local variables Infix operators and functions Commas and brackets In the same way, parentheses (if not used for identifying comments) and braces can be used for structuring of expressions. This means that the expression (1 + 2} * 3 is permitted. The SMC_ReadNCFile2 function block has a new mode ( bParenthesesAsComments input) where parentheses are not comments. Instead, multiline comments are opened and closed with \"(*\" and \"*)\", respectively. In this new mode, both braces and parentheses can be used for expressions. A space after the G address is required only if SMC_ReadNCFile2 would not recognize it as an independent token (example: X abs{-2} instead of Xabs{-2}. ). In contrast with ST, single-position functions do not necessarily have to be called with parentheses (example: sin 3 ). When parsing, each partial expression is assigned one of the three types: BOOL, LREAL, or STRING. Accordingly, each Infix operator and each function expects a specific sequence of argument types for which noncompliance (wrong type, too few, or too many arguments) returns an error. Restrictions: Block numbers have to be numeric literals. For strictly technical reasons, jump labels ( x in L!x ) must not contain any local variables. For more information, see: Jump, Using Variables" }, 
{ "title" : "Examples ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_5b6258e8c18a4349c0a864632640e903", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Expressions \/ Examples ", 
"snippet" : "N01 G36 O$var$ D concat{'prefix_', concat{$var$, '_suffix'}} N02 G1 X$var$ + sin{pi + 3 * #locvar} N03 G20 L0 K NOT {myfun{$var$, expt{2, #locvar}} XOR myfun{0, 0}}...", 
"body" : "N01 G36 O$var$ D concat{'prefix_', concat{$var$, '_suffix'}}\nN02 G1 X$var$ + sin{pi + 3 * #locvar}\nN03 G20 L0 K NOT {myfun{$var$, expt{2, #locvar}} XOR myfun{0, 0}} " }, 
{ "title" : "Supported operators and functions ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_da2d0ac5c18a4349c0a864637cb30dc8", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Expressions \/ Supported operators and functions ", 
"snippet" : "Infix operators Character Type Arguments Precedence MOD LREAL LREAL , LREAL 14 * LREAL LREAL , LREAL 13 \/ LREAL LREAL , LREAL 13 + LREAL LREAL , LREAL 12 - LREAL LREAL , LREAL 12 = BOOL BOOL , BOOL 10 = BOOL LREAL , LREAL 10 = BOOL STRING , STRING 10 <> BOOL BOOL , BOOL 10 <> BOOL LREAL , LREAL 10 <...", 
"body" : "Infix operators Character Type Arguments Precedence MOD LREAL LREAL , LREAL 14 * LREAL LREAL , LREAL 13 \/ LREAL LREAL , LREAL 13 + LREAL LREAL , LREAL 12 - LREAL LREAL , LREAL 12 = BOOL BOOL , BOOL 10 = BOOL LREAL , LREAL 10 = BOOL STRING , STRING 10 <> BOOL BOOL , BOOL 10 <> BOOL LREAL , LREAL 10 <> BOOL STRING , STRING 10 > BOOL LREAL , LREAL 10 < BOOL LREAL , LREAL 10 >= BOOL LREAL , LREAL 10 <= BOOL LREAL , LREAL 10 AND BOOL BOOL , BOOL 6 XOR BOOL BOOL , BOOL 5 OR BOOL BOOL , BOOL 4 Functions Character Type Arguments - LREAL LREAL ABS LREAL LREAL MAX LREAL LREAL , LREAL MIN LREAL LREAL , LREAL NOT BOOL BOOL TRUE BOOL FALSE BOOL SIN LREAL LREAL COS LREAL LREAL TAN LREAL LREAL ASIN LREAL LREAL ACOS LREAL LREAL ATAN LREAL LREAL EXP LREAL LREAL LN LREAL LREAL SQRT LREAL LREAL EXPT LREAL LREAL , LREAL FLOOR LREAL LREAL CEIL LREAL LREAL PI LREAL LEN LREAL STRING CONCAT STRING STRING , STRING " }, 
{ "title" : "Defining your own functions ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_fca8916cc18a4349c0a8646350db2bd3", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Expressions \/ Defining your own functions ", 
"snippet" : "It is possible to add your own functions or overwrite an existing implementation. (When parsing the G-code, functions are searched for first in the user functions.) The SMC_NC_IFunction interface must be implemented and a global instance of the corresponding POU must be transferred to SMC_ReadNCFile...", 
"body" : "It is possible to add your own functions or overwrite an existing implementation. (When parsing the G-code, functions are searched for first in the user functions.) The SMC_NC_IFunction interface must be implemented and a global instance of the corresponding POU must be transferred to SMC_ReadNCFile2 or SMC_ReadNCFromStream via the structure SMC_NC_GFunctionTable . The enumeration SMC_GVar_Type is used for the return type and argument types. The entry contained there T_OTHER can be used as a placeholder for a type. When parsing, the system checks that all arguments that correspond to a T_OTHER in the signature have the same type. The type does not matter. For more information, see: User-Specific G-Code Functions" }, 
{ "title" : "Error Handling ", 
"url" : "_sm_cnc_din66025_expressions.html#UUID-529e4767-90a0-7da3-e83d-4c92afe67be4_id_ceb6aac17a59d3c0a864632c338cae_id_1c910ecf4b371465c0a86463522d8482", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Expressions \/ Error Handling ", 
"snippet" : "When possible, the exact position of the defective token and its length are issued in syntax errors. The error position is listed in SMC_ReadNCFile2.errorPos ....", 
"body" : "When possible, the exact position of the defective token and its length are issued in syntax errors. The error position is listed in SMC_ReadNCFile2.errorPos . " }, 
{ "title" : "Local variables ", 
"url" : "_sm_cnc_din66025_local_variables.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Local variables ", 
"snippet" : "Each G code file can declare local variables. For main programs, the declarations have to be inserted at the very beginning; for subprograms, directly after the subprogram declaration. Local variables are visible only in the program or subprogram where they are declared. (No dynamic scope) Local var...", 
"body" : "Each G code file can declare local variables. For main programs, the declarations have to be inserted at the very beginning; for subprograms, directly after the subprogram declaration. Local variables are visible only in the program or subprogram where they are declared. (No dynamic scope) Local variables work in the online decoder only (not in the CNC editor). Number of local variables Before version 4.18.0.0: The number of local variables is restricted to 21 per subprogram and in the main program. Version 4.18.0.0 and higher: The number of local variables is limited only by the memory. The maximum value can be changed using the library parameter SMC_CNC_LibParams.MAX_SUBPROGRAM_PARAMS . For more information, see: Library Parameters Syntax for the declaration The syntax is similar to the syntax used to declare subprogram parameters. One variable can be declared per block. The block does not start with an N-word. The variable can be provided with an optional initial value when it is declared. Otherwise, it is assigned a default value depending on the data type ( LREAL: 0, BOOL: FALSE, STRING: ‘‘ ). Syntax of the declaration: LET <FormalParam> [:= <InitialValue>] . <FormalParam> ::= <ParamName> : <ParamType>\n<ParamName> ::= #[a-zA-Z0-9_]+\n\n<ParamType> ::= LREAL | BOOL | STRING ; String mit maximaler Länge von 255 Bytes <InitialValue> : Expression that has a value and a type that matches the variable. The expression may also use local variables (and in subprograms the parameters of the subprogram), but only those declared above in the program code. Examples • LET #x : LREAL (* Variable #x, Typ LREAL, Initialwert 0 *)\n• LET #y : LREAL := #x + 1 (* Variable #y, Typ LREAL, Initialwert #x+1 = 1 *)\n• LET #b : BOOL := #x >= #y (* Variable #b, Typ BOOL, Initialwert FALSE *) As with subprogram parameters, local variables are not case-sensitive. (Both #x and #X indicate the same variable.) The names of all local variables declared in a program\/subprogram have to be different. They have to differ from the names of the formal parameters of the subprogram. Local variables can be used in G code like parameters of subprograms. Examples • N10 G01 X#x Y#y\n• N20 G20 L10 K#b " }, 
{ "title" : "Probing function (clear remaining distance) ", 
"url" : "_sm_probe_movement.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ CNC Language in DIN 66025 \/ Probing function (clear remaining distance) ", 
"snippet" : "G-Code : G31 \/ Any movement command together with the PROBE word Function : The probing function (clear remaining distance) is a special movement which is aborted as soon as a signal ( PROBE ) is pending. The rest of the G-code continues from the position where the movement was aborted, not from the...", 
"body" : "G-Code : G31 \/ Any movement command together with the PROBE word Function : The probing function (clear remaining distance) is a special movement which is aborted as soon as a signal ( PROBE ) is pending. The rest of the G-code continues from the position where the movement was aborted, not from the programmed end position of the movement. The the probing function (clear remaining distance) causes an implicit decoding stop before the next movement (similar to G75 ). Decoding of the G-code will continue only after the signal has been received. Typical use cases include measuring a tool length (moving into a switch) or moving onto a block. The probing function (clear remaining distance) can be activated for any number of movements, such as straight lines and circular arcs. For this, only the PROBE word has to be added to the G-code. G31 is a linear movement with the probing function (clear remaining distance), with the default probe number 1. This default can be overridden with a PROBE word. Each movement may have at most one PROBE word. H-functions (triggers) are not supported for movements with the probing function (clear remaining distance). Path preprocessing such as corner smoothing, tool radius correction, etc. is not supported for movements with the probing function (clear remaining distance). The probe number must be positive. If no probe signal is received during the processing of a movement with the probing function (clear remaining distance), then the interpolation stops at the end of the movement with an error. The interpolator first needs to be stopped when a probe signal is received. One of the inputs bSlow_Stop , bQuick_Stop , or bEmergency_Stop can be used for this purpose. As soon as the interpolation has stopped, the probing function (clear remaining distance) can be acknowledged. For this purpose, a rising edge is applied to the SMC_Interpolator.bAcknProbe input. Syntax G31 X Y Z A B C P Q U V W F E S PROBE\nG1\/2\/3\/8\/9 X Y Z A B C P Q U V W F E S PROBE G-Code Word Description X Y Z Target positions of the Cartesian axes A B C P Q U V W Target positions of the additional axes F E Path velocity, path acceleration\/deceleration S S profile PROBE The probe number must be positive. Examples Linear movement Linear motion with the probing function (clear remaining distance) and default probe number 1 N010 G31 X100 Circular movement Circular movement with the probing function (clear remaining distance) and probe number 7 N010 G02 X100 R50 PROBE 7 For more information, see the example: CNC Example 16: Probing function (clear remaining distance) (G31)" }, 
{ "title" : "Path Preprocessing and Queue Sizes ", 
"url" : "_sm_preprocessing_queuesize.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Path Preprocessing and Queue Sizes ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Pipelining of G-code processing ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103127844091", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Path Preprocessing and Queue Sizes \/ Pipelining of G-code processing ", 
"snippet" : "When G-code is read from a file, it is often impractical to read and process the entire file before starting machining. For some applications, G-code files can have a few hundred thousand or even millions of lines. Reading all at once would take a long time and also require a lot of memory. Instead,...", 
"body" : "When G-code is read from a file, it is often impractical to read and process the entire file before starting machining. For some applications, G-code files can have a few hundred thousand or even millions of lines. Reading all at once would take a long time and also require a lot of memory. Instead, the G-code is read line by line, but only a small fraction (a few hundred lines) is kept in memory at each point in time. This part is kept in queues, i.e. in data structures which work according to the \"first in, first out\" principle: The producing function block adds elements to the queue. The consuming function block reads and removes elements in the same order they were inserted. The diagram shows the flow of the G-code through the system. First, G-code is read from a file, then converted into so called GeoInfo elements by the interpreter. These elements are processed by the path preprocessing function blocks and finally interpolated. The parts marked by \"GeoInfo\" represent the queues. If more than one path preprocessor (such as SMC_SmoothPath , SMC_ToolRadiusCorr , or SMC_AvoidLoop ) is used, then they are also connected by queues. " }, 
{ "title" : "Recommended queue sizes ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103128036484", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Path Preprocessing and Queue Sizes \/ Recommended queue sizes ", 
"snippet" : "As a rule of thumb, for most queues a size of 16 elements is suitable. The last queue before the SMC_Interpolator function block (that is usually the queue of the path preprocessing function block before SMC_CheckVelocities ) should have a higher queue size – 100 elements is a good starting point fo...", 
"body" : "As a rule of thumb, for most queues a size of 16 elements is suitable. The last queue before the SMC_Interpolator function block (that is usually the queue of the path preprocessing function block before SMC_CheckVelocities ) should have a higher queue size – 100 elements is a good starting point for most applications. To understand these rules and to know when to deviate from them, we look at the effects of the queue sizes: Latency of processing: the larger the queues, the longer it will take to fill them up initially. The SMC_Interpolator function block waits until the last queue is filled before starting with interpolation. For the latency, the total queue size (sum of all queue sizes) is relevant. Lookahead of the interpolator: the size of the last queue before the SMC_Interpolator determines the lookahead of the interpolation. When computing a trajectory, the interpolator can only plan until the end of the lookahead. If the lookahead is too small, then the interpolator might not be able to reach the full path velocity. Depending on the path velocity and length of the elements, 100 elements is a good starting point, but for high velocities and\/or short elements, a larger queue size might be necessary. Effect on particular function blocks : Function blocks such as SMC_AvoidLoop or SMC_SmoothMerge require a certain size of the incoming queue to work effectively. For example, to detect a loop in the G-Code, this loop must fit into the queue before SMC_AvoidLoop . Check the documentation of the function blocks in your path processing pipeline for details. " }, 
{ "title" : "Calling the processing function blocks ", 
"url" : "_sm_preprocessing_queuesize.html#UUID-133a7de9-e589-fa12-c404-4fed94b2d9cd_section-idm235103128219711", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Path Preprocessing and Queue Sizes \/ Calling the processing function blocks ", 
"snippet" : "As mentioned above, interpolation starts only after all queues are filled up. This causes an initial latency when starting machining. Besides reducing the total queue size, there is an additional way to reduce this latency. The path preprocessing function blocks are usually called in a cyclic backgr...", 
"body" : "As mentioned above, interpolation starts only after all queues are filled up. This causes an initial latency when starting machining. Besides reducing the total queue size, there is an additional way to reduce this latency. The path preprocessing function blocks are usually called in a cyclic background task, as shown in the examples such as CNC Example 03: Performing Path Preprocessing Online. To reduce latency, the program calling SMC_ReadNCFile2 , SMC_NCInterpreter , and the path preprocessors can be called in a loop. Depending on the application and task priorities, it may be sufficient to execute the program multiple times per task call (e.g. 100 times) or to terminate the loop after a certain time span (e.g. 5 ms). " }, 
{ "title" : "Examples ", 
"url" : "_sm_cnc_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "CNC Example 01: Generating OutQueue Directly ", 
"url" : "_sm_example_cnc_1.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 01: Generating OutQueue Directly ", 
"snippet" : "See the CNC01_direct.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows a CNC program with two axes. Four positions are approached in the X\/Y-plane with a defined velocity and acceleration. The program sets two path switch points...", 
"body" : "See the CNC01_direct.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows a CNC program with two axes. Four positions are approached in the X\/Y-plane with a defined velocity and acceleration. The program sets two path switch points on the path. The program is written directly into a data structure by using the SMC_OutQueue compile mode. Commissioning Compile and start the created program. The program executes the CNC motion as soon as the Execute input of the interpolator has been set. After the program has run completely, you can apply a new rising edge to restart it. Note the function of the path switches that are also displayed in the visualization of the interpolation function block. " }, 
{ "title" : "Creating an NC program in the CNC editor ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_0decf30fe1170213c0a864632e7a1fa2", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 01: Generating OutQueue Directly \/ Creating an NC program in the CNC editor ", 
"snippet" : "Create a CNCdirect project with a SoftMotion controller. Insert a CNC program object named Example . Select the Implementation Din66025 and the Compile mode SMC_OutQueue . Specify the following motion blocks: CNC editor:...", 
"body" : "Create a CNCdirect project with a SoftMotion controller. Insert a CNC program object named Example . Select the Implementation Din66025 and the Compile mode SMC_OutQueue . Specify the following motion blocks: CNC editor: " }, 
{ "title" : "Creating a drive interface and PLC configuration ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_502a86c7e1170213c0a864631de910a9", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 01: Generating OutQueue Directly \/ Creating a drive interface and PLC configuration ", 
"snippet" : "Define a drive structure with two linear drives as follows: Insert two virtual drives X_Drive and Y_Drive below the SoftMotion general axis pool . Set the Axis type parameter to Finite (1). Configuration editor:...", 
"body" : "Define a drive structure with two linear drives as follows: Insert two virtual drives X_Drive and Y_Drive below the SoftMotion general axis pool . Set the Axis type parameter to Finite (1). Configuration editor: " }, 
{ "title" : "Creating an IEC program ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_2840ecebe1170213c0a8646360b1cd08", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 01: Generating OutQueue Directly \/ Creating an IEC program ", 
"snippet" : "Add a new CFC program Ipo to the application and configure a cyclic task with an interval of 3 ms. Activate the drive with the MC_Power function block. POUs: Insert the SMC_Interpolator POU. The function block converts a path defined by GEOINFO objects into discrete path points. The function block r...", 
"body" : "Add a new CFC program Ipo to the application and configure a cyclic task with an interval of 3 ms. Activate the drive with the MC_Power function block. POUs: Insert the SMC_Interpolator POU. The function block converts a path defined by GEOINFO objects into discrete path points. The function block receives the address of the created CNC program at the input poqDataIn . Then the IEC task cycle time has to be written to the input dwIpoTime . You can specify these as constant values at the input dwIpoTime or you can use the variable dwCycle of the axis group structure from the PLC configuration. The advantage of this is that the correct time is automatically used as the interpolator input when you change the task cycle time. POU: In this example, a gantry system will be controlled. For this purpose, insert an instance of the inverse and forward transformation function blocks from the SM_Trafo library. The forward transformation function block contains the drives as inputs. The inverse transformation function block has to contain the set position of the interpolator. The forward transformation in the example is required for the visualization only. Function block instance: The outputs of the function block (the axis coordinates) have to be written to the drives. This is done with the SMC_ControlAxisByPos function block. Because the application does not guarantee that the outputs of the interpolator are constant (e.g. the path ends at a point other than where it began), activate the gap avoidance ( bAvoidGaps , fGapVelocity , fGapAcceleration , and fGapDeceleration ). Then connect the StopIpo output to the bEmergency_Stop input of the interpolator and connect interpolator output iStatus to the respective inputs of the axis control function blocks. Above all, pay attention to the correct order of function blocks when programming with CFC. CFC: " }, 
{ "title" : "Creating an operating interface and a testing interface ", 
"url" : "_sm_example_cnc_1.html#UUID-999a60a9-40b2-7bec-6d26-4e8ced4c28de_id_f71f06e6db79b58c0a8646363a3619f_id_af479c23e1170213c0a8646355fa8e27", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 01: Generating OutQueue Directly \/ Creating an operating interface and a testing interface ", 
"snippet" : "Link two visualization objects to a new visualization: the template of the interpolator and the template of the transformation. You need to use placeholders to link these to the respective function block instances (here: Ipo.smci and Ipo.trafof )....", 
"body" : "Link two visualization objects to a new visualization: the template of the interpolator and the template of the transformation. You need to use placeholders to link these to the respective function block instances (here: Ipo.smci and Ipo.trafof ). " }, 
{ "title" : "CNC Example 02: Online Decoding with Variables ", 
"url" : "_sm_example_cnc_2.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 02: Online Decoding with Variables ", 
"snippet" : "See the CNC02_online.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The example shows how to use variables to decode a CNC program. Commissioning Compile and start the created program. The program executes the CNC motion as soon as the Execute ...", 
"body" : "See the CNC02_online.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The example shows how to use variables to decode a CNC program. Commissioning Compile and start the created program. The program executes the CNC motion as soon as the Execute input of the decoder and interpolator has been set. If you change the values of the global variables, then they are used when the decoder is restarted and the path is adapted accordingly. Monitor the function of the Append input of the decoder as well. " }, 
{ "title" : "Creating an NC program in the CNC editor ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_4c86ec04e529c0bcc0a864636a6ae1dc", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 02: Online Decoding with Variables \/ Creating an NC program in the CNC editor ", 
"snippet" : "Create a CNCOnline program with a SoftMotion controller. Create a global variable list and declare two variables. VAR_GLOBAL g_x: REAL:=100; g_y:REAL:=50; END_VAR Insert a CNC program object named Example . Select the Implementation Din66025 and the Compile mode SMC_CNC_REF . This mode is required b...", 
"body" : "Create a CNCOnline program with a SoftMotion controller. Create a global variable list and declare two variables. VAR_GLOBAL\n g_x: REAL:=100;\n g_y:REAL:=50;\nEND_VAR Insert a CNC program object named Example . Select the Implementation Din66025 and the Compile mode SMC_CNC_REF . This mode is required because you use variables in your program. Specify the following motion blocks: CNC editor: " }, 
{ "title" : "Creating a drive interface and PLC configuration ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_7e9d1704e529c0bcc0a8646343b60bbd", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 02: Online Decoding with Variables \/ Creating a drive interface and PLC configuration ", 
"snippet" : "Define a drive structure (e.g. CNCdirect )....", 
"body" : "Define a drive structure (e.g. CNCdirect ). " }, 
{ "title" : "Creating an IEC program ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_3989abe9e529c0bcc0a864630f20ee19", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 02: Online Decoding with Variables \/ Creating an IEC program ", 
"snippet" : "Add a POU (CFC) named Path to the application. The decoding of the NC program for OUTQUEUE and the velocity check take place in the Path program. Calling SMC_CheckVelocities is required. CFC: Add a POU (CFC) named Ipo to the application. This program is almost identical to the CNCdirect sample proje...", 
"body" : "Add a POU (CFC) named Path to the application. The decoding of the NC program for OUTQUEUE and the velocity check take place in the Path program. Calling SMC_CheckVelocities is required. CFC: Add a POU (CFC) named Ipo to the application. This program is almost identical to the CNCdirect sample project. However, the data input of the interpolator does not correspond to the CNC program names ( ADR(Example) ), but to the OutQueue output of the path preprocessing function blocks ( checkVel.poqDataOut ). " }, 
{ "title" : "Creating a task for path preprocessing ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_3014d45de529c0bcc0a86463617895a7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 02: Online Decoding with Variables \/ Creating a task for path preprocessing ", 
"snippet" : "Because you have selected the compile mode SMC_CNC_REF , you have to perform decoding and path preprocessing in the IEC program. This calculation is time consuming. It does not have to be executed in the interpolator cycle because one path object is generated per decoder call, and this object is typ...", 
"body" : "Because you have selected the compile mode SMC_CNC_REF , you have to perform decoding and path preprocessing in the IEC program. This calculation is time consuming. It does not have to be executed in the interpolator cycle because one path object is generated per decoder call, and this object is typically used for many interpolator calls. You should swap out this operation to a task with low priority and less frequent calls. Create a PathTask task. Define the following parameters: Priority : 10 Interval : T#30ms Add the Path POU to the task. \"PathTask\" task Underlying mechanism: In the slow task, approximately one GEOINFO object is generated per cycle at first. This object is stored in the OUTQUEUE structure of the decoder function block. If the OUTQUEUE is full, then the function blocks of the slow task pause until the OUTQUEUE is not full anymore. This happens as soon as the fast task processes the first GEOINFO object and deletes it from the OUTQUEUE. Then the function blocks of the slow task become active again and fill the OUTQUEUE structure. In the fast task, a path point from the OUTQUEUE structure, which the DataIn input points to, is calculated and processed in each cycle. Because a GEOINFO object generally consists of multiple path points, it takes a few cycles until the first GEOINFO object is processed and deleted automatically by the interpolator. As the processing of a GEOINFO object lasts several cycles as opposed to it creation, the slow task can be called less frequently than the fast task. However, the task times have to be selected so that enough GEOINFO objects are always stored in the last OUTQUEUE of the slow task, thus preventing the occurrence of any data underrun. This happens when there are no more GEOINFO objects available to the interpolator from DataIn, and the path end has not been reached yet. In this case, the interpolator slows down and stops until new data elements are available again. " }, 
{ "title" : "Creating an operating interface and a testing interface ", 
"url" : "_sm_example_cnc_2.html#UUID-85e965ea-e3ed-4746-d969-7425048261d5_id_efbe42396db8244bc0a86463505d5197_id_af479c23e1170213c0a8646355fa8e27", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 02: Online Decoding with Variables \/ Creating an operating interface and a testing interface ", 
"snippet" : "The visualization corresponds to the CNCdirect.project sample project. Add additional templates to the new function blocks ( SMC_NCDecoder and SMC_CheckVelocities ). Create a display also for the global variables g_x and g_y so that you can check their function later when commissioning....", 
"body" : "The visualization corresponds to the CNCdirect.project sample project. Add additional templates to the new function blocks ( SMC_NCDecoder and SMC_CheckVelocities ). Create a display also for the global variables g_x and g_y so that you can check their function later when commissioning. " }, 
{ "title" : "CNC Example 03: Performing Path Preprocessing Online ", 
"url" : "_sm_example_cnc_3.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 03: Performing Path Preprocessing Online ", 
"snippet" : "See the CNC03_prepro.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The example shows how path preprocessing can be performed online on the PLC. Extend the CNC02_online project with one path preprocessor. Then the angles of the movement of the ...", 
"body" : "See the CNC03_prepro.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The example shows how path preprocessing can be performed online on the PLC. Extend the CNC02_online project with one path preprocessor. Then the angles of the movement of the CNConline project are rounded by means of splines. This is done with the SMC_SmoothPath function block. Extend the CNC program: Append the previous program with the elements G51\/G50 . Click CNC → Show preprocessed path so that the splines created by path preprocessing are displayed in the editor, as in the screenshot below. Display: Without using variables, you could compile the program in this form as a queue and enter it directly into the interpolator. However, as variables are available, you have to perform decoding and angle smoothing yourself. Declare a new function block of type SMC_SmoothPath . Call it after the decoder. Set the data input of the interpolator function block as usual to the poqDataOut output of the CheckVelocities function block. A new buffer has to be declared for the input SMC_SmoothPath.pbyBufferOutQueue . CFC: Commissioning Compile and start the created program. In contrast with the previous program, this program no longer stops at the angles of the NC program because the angles of the path have been made free of kinks by means of the path preprocessing. " }, 
{ "title" : "CNC Example 04: Programming CNC using the Tabular Editor ", 
"url" : "_sm_example_cnc_4.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 04: Programming CNC using the Tabular Editor ", 
"snippet" : "See the CNC04_table.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . In this project, the functionality of the CNC03_prepro.project sample project is programmed with the tabular editor. In contrast with CNC03_prepro.project , no IEC variables are...", 
"body" : "See the CNC04_table.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . In this project, the functionality of the CNC03_prepro.project sample project is programmed with the tabular editor. In contrast with CNC03_prepro.project , no IEC variables are used in this project. Instead, it is calculated with fixed values. Otherwise, the functionality is identical. " }, 
{ "title" : "CNC Example 05: Creating CNC from a File ", 
"url" : "_sm_example_cnc_5.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 05: Creating CNC from a File ", 
"snippet" : "See the CNC05_File.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . With this sample project, you can understand how a G code program is read from an ASCII file that is stored on the PLC. Using this kind of file makes sense when the G code progra...", 
"body" : "See the CNC05_File.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . With this sample project, you can understand how a G code program is read from an ASCII file that is stored on the PLC. Using this kind of file makes sense when the G code program is very large. The function of the project is similar to the CNC02_online.project sample project. However, the G code program is read from an ASCII file. No variables are used and the processing order is comparable to the one in the CNC02_online.project sample project. The following differences can be determined: Additional virtual drive (z-axis) Function block smoothpath not required G code read from file Preprocessing online (see CNC02_online.project ) " }, 
{ "title" : "CNC Example 06: Using Path3D with SoftMotion CNC ", 
"url" : "_sm_example_cnc_6.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 06: Using Path3D with SoftMotion CNC ", 
"snippet" : "See the CNC06_File_3DPath.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example extends the previous example CNC05_File . It demonstrates a possible application of the Path3D visualization element with CODESYS SoftMotion CNC. Extending th...", 
"body" : "See the CNC06_File_3DPath.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example extends the previous example CNC05_File . It demonstrates a possible application of the Path3D visualization element with CODESYS SoftMotion CNC. Extending the program CNC_File to CNC_File_Path3D Open the Library Manager and add the SM3_CNC_Visu library. Create an instance of SMC_PathCopierFile in CNC_PreparePath and call it at the beginning of the path processing ( iState=0 ). Programming: In the Visualization visualization, replace the previously used graphical display of the position with the Path3D element. Change the properties of the Path3D element: Path description → Path data (VisuStruct3DTrack) : CNC_prepare_path.pcf.vs3dt Insert the Frame visualization element. Reference the ControlPanel visualization from the VisuElem3DPath library. This element is used for controlling the camera position of the element. In the declaration of the CNC_PreparePath program, create an instance of VisuStruct3DControl ( VisuElem3DPath library): vc: VisuStruct3DControl; . This instance forms the data interface between the Path3D element and the camera control panel. Change the properties of the Path3D element: Camera control → Control data structure (VisuStruct3DControl) : CNC_PreparePath.vc Change the properties of the ControlPanel element: References → VisuElem3DPath.ControlPanel → vc : CNC_PreparePath.vc Compile, download, and start the application. The Path3D element shows the path. You can control the camera position from the panel. Add an instance of the SMC_PositionTracker function block in the CNC program. Create a memory for tracing the current track (the last traveled positions). pt: SMC_PositionTracker; pointbuffer_pt: ARRAY [0..1000] OF VisuStruct3DPathPoint; Insert a call of the instance: SMC_PositionTracker into the Interpolation action CFC: Link the path data to the Path3D element. Change the properties of the Path3D element: Path description → Path data (VisuStruct3DTrack) : CNC.pt.vs3dt Go online and start the application. The Path3D element displays the last interpolated path also to the path. Configure other properties of Path3D . For example, configure the processed path elements to be displayed in gray: Highlight → Highlight color : Gray Sample project: \"3D Path Generator\" " }, 
{ "title" : "CNC Example 07: Using Expressions and Subprograms ", 
"url" : "_sm_example_cnc_7.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 07: Using Expressions and Subprograms ", 
"snippet" : "See the CNC07_Subprogram.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example demonstrates how to call a  subprogram from a CNC file as well as use expressions in CNC motion instructions. In the CNC program, the drives are first switched...", 
"body" : "See the CNC07_Subprogram.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example demonstrates how to call a  subprogram from a CNC file as well as use expressions in CNC motion instructions. In the CNC program, the drives are first switched on, as in the other examples. The CNC_PreparePath program uses the SMC_ReadNCFile2 function block for reading the CNC file. SMC_ReadNCFile2 creates the SMC_ReadNCFile POU and extends it with support for subprograms and expressions. The CNC program CNC2Main.cnc is converted by means of the SMC_NCInterpreter function block. SMC_NCInterpreter creates the SMC_NCDecoder POU and extends it with support for subroutines and expressions. The project contains two CNC programs: the main program CNC2Main.cnc and the subprogram CNC2.cnc . The main program passes the value 25 in the #RADIUS parameter to the subprogram. In the subprogram, the expression X#RADIUS*2 is used for calculating the circular path. Main program N0 G01 X$g_x$ Y0 F50 E30 E-30\nN10 G01 X0 Y$g_y$\nN20 CNC2{25}\nN30 G01 X0 Y-200 Subprogram SUBPROGRAM CNC2{#RADIUS : LREAL}\nN010 G91\nN020 G02 X#RADIUS*2 Y0 R#RADIUS Z2.5 F100 E-100 E100\nN030 G02 X-#RADIUS*2 Y0 R#RADIUS Z7.5\nEND_SUBPROGRAM " }, 
{ "title" : "CNC Example 08: Use of Additional Axes ", 
"url" : "_sm_example_external_axes_usage.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 08: Use of Additional Axes ", 
"snippet" : "See the CNC08_AdditionalAxes.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example extends the CNC01_direct.projekt  project which is described in  CNC Example 01: Generating OutQueue Directly. It demonstrates how to use additional axes. ...", 
"body" : "See the CNC08_AdditionalAxes.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example extends the CNC01_direct.projekt  project which is described in  CNC Example 01: Generating OutQueue Directly. It demonstrates how to use additional axes. As in CNC Example 01, four positions are approached in the X\/Y-plane with a defined velocity and acceleration. Furthermore, the additional axis A is run during each movement. The program sets two path switch points on the path. " }, 
{ "title" : "Editing a CNC program in the editor ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4510557821784033079793683298", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 08: Use of Additional Axes \/ Editing a CNC program in the editor ", 
"snippet" : "Open the CNC01_direct.project project from the installation directory of CODESYS . In the project, open the CNC program Example . Add positions for the additional axis A to the travel commands: CNC editor N0 G01 X82.9 Y 8.9 A20 F50 E30 E-30 N10 G02 X84.9 Y84.6 A40 R100 H12 L10 N20 G01 X 6.6 Y25.7 A6...", 
"body" : "Open the CNC01_direct.project project from the installation directory of CODESYS . In the project, open the CNC program Example . Add positions for the additional axis A to the travel commands: CNC editor N0 G01 X82.9 Y 8.9 A20 F50 E30 E-30\nN10 G02 X84.9 Y84.6 A40 R100 H12 L10\nN20 G01 X 6.6 Y25.7 A60 H-1 O0.8\nN30 G03 X54.6 Y49.7 A80 R100 " }, 
{ "title" : "Creating a drive interface and PLC configuration ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4590758202758433079807306962", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 08: Use of Additional Axes \/ Creating a drive interface and PLC configuration ", 
"snippet" : "Insert an additional virtual drive A_Drive below the SoftMotion general axis pool . Set the parameters as follows:...", 
"body" : "Insert an additional virtual drive A_Drive below the SoftMotion general axis pool . Set the parameters as follows: " }, 
{ "title" : "Editing an IEC program ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4590758311412833079809057524", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 08: Use of Additional Axes \/ Editing an IEC program ", 
"snippet" : "Open the CFC program Ipo . Activate the previously added drive A_Drive with the MC_Power function block. In this example, a simple orientation axis ( A_Drive ) should be controlled with the additional axis A. For this reason, no more transformation modules are necessary. The set position of the inte...", 
"body" : "Open the CFC program Ipo . Activate the previously added drive A_Drive with the MC_Power function block. In this example, a simple orientation axis ( A_Drive ) should be controlled with the additional axis A. For this reason, no more transformation modules are necessary. The set position of the interpolator corresponds directly to the set position of the drive and is applied via the SMC_POSINFO selector with the SMC_ControlAxisByPos function block. The application does not guarantee that the outputs of the interpolator are continuous. For example, the position of the additional axis ends at a different point than it begins. Therefore, you should activate the gap avoidance ( bAvoidGaps , fGapVelocity , fGapAcceleration , and fGapDeceleration ). Then connect the bStopIpo output to the bEmergency_Stop input of the interpolator and connect interpolator output iStatus to the respective inputs of the axis control function blocks. Above all, pay attention to the correct order of function blocks when programming with CFC. " }, 
{ "title" : "Commissioning ", 
"url" : "_sm_example_external_axes_usage.html#UUID-41430b20-92eb-29d9-0a2f-b048af9eaac4_section-idm4584880865328033079813143466", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 08: Use of Additional Axes \/ Commissioning ", 
"snippet" : "Compile and start the created program. The program executes the CNC motion as soon as the Execute input of the interpolator has been set. After the program has run completely, you can apply a new rising edge to restart it. During the execution of the CNC program, note the position of the additional ...", 
"body" : "Compile and start the created program. The program executes the CNC motion as soon as the Execute input of the interpolator has been set. After the program has run completely, you can apply a new rising edge to restart it. During the execution of the CNC program, note the position of the additional axis A ( piSetPosition.dA ) which is shown in the visualization of the interpolation POU. " }, 
{ "title" : "CNC Example 09: Using Tool Length Correction ", 
"url" : "_sm_example_tool_correction_usage.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 09: Using Tool Length Correction ", 
"snippet" : "See the CNC09_ToolLengthCorr.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example demonstrates how to use the SMC_ToolLengthCorr POU to compensate the length of a tool. For more information about the topic of tool length correction, see:...", 
"body" : "See the CNC09_ToolLengthCorr.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example demonstrates how to use the SMC_ToolLengthCorr POU to compensate the length of a tool. For more information about the topic of tool length correction, see: Preprocessing" }, 
{ "title" : "Application ", 
"url" : "_sm_example_tool_correction_usage.html#UUID-1d022e7a-4834-0535-1cca-7cab7ecde5dd_section-idm458488080921763308005489139", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 09: Using Tool Length Correction \/ Application ", 
"snippet" : "For the example, a Gantry3 kinematic is used together with an added orientation axis ( AxisA ) which can rotate about the Z axis. A tool with a length of 2 units in the Z direction is in turn attached to the orientation axis. A simple CNC program should be run. This is stored in the project as an ex...", 
"body" : "For the example, a Gantry3 kinematic is used together with an added orientation axis ( AxisA ) which can rotate about the Z axis. A tool with a length of 2 units in the Z direction is in turn attached to the orientation axis. A simple CNC program should be run. This is stored in the project as an external CNC.cnc file and can be opened with a text editor. In the CNC program, the tool length correction is first activated by means of G code G43 . The I , J , and K parameters correspond to the offset in the X, Y, and Z directions for this. Next, three points are traveled to in the XY plane. During the movement to the last point, the additional axis A is also rotated by 90 degrees. N000 G43 I0 J0 K2 (Activate tool length correction with tool offset X=0 Y=0 Z=2)\nN010 G01 X10 F10 E100 E-100\nN020 G03 Y10 R5N030 G01 X0 A90 The application consists of multiple parts. In the CNC_PreparePath program, the CNC program CNC.cnc is imported as a file from the controller and preprocessed. In the CNC program, the drives are first switched on, as in the other examples. Then the interpolation of the previously read CNC program is performed. In each cycle, the interpolator outputs a set position (piSetPosition ) and the current offset of the tool (adToolLength ). The SMC_ToolLengthCorr POU requires this information to compensate the specified tool length. The compensated position is then transformed and finally passed to the axes by means of the SMC_ControlAxisByPos POUs. The program is almost identical to the other examples. Only the SMC_ToolLengthCorr POU has been inserted after the interpolator and before the transformation in order to process the set position output by the interpolator. " }, 
{ "title" : "Commissioning ", 
"url" : "_sm_example_tool_correction_usage.html#UUID-1d022e7a-4834-0535-1cca-7cab7ecde5dd_section-idm4590758219934433080059282556", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 09: Using Tool Length Correction \/ Commissioning ", 
"snippet" : "Compile and start the created program. The program executes the CNC movement as soon as the CNC_PreparePath.xStart input has been set. You can click the Start button to set this variable in the application or in the visualization. After the program has run completely, you can apply a new rising edge...", 
"body" : "Compile and start the created program. The program executes the CNC movement as soon as the CNC_PreparePath.xStart input has been set. You can click the Start button to set this variable in the application or in the visualization. After the program has run completely, you can apply a new rising edge to restart it. During the execution of the CNC program, note the outputs of the interpolator ( piSetPosition , adToolLength ) and the compensated position ( piOut ) of the SMC_ToolLengthCorr POU. Note: The rotation of AxisA during the last movement of the CNC program has no (additional) effect on the compensated Cartesian position in this example because the tool has only an offset in Z direction. If you add a component to the offset of the tool (in the CNC file, on the controller in the application folder) in X and Y direction, then the rotation of AxisA during the last movement will have an additional effect on the compensated position. " }, 
{ "title" : "Reading the State of the Interpolator ", 
"url" : "_sm_example_state_interpolator.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ Reading the State of the Interpolator ", 
"snippet" : "See the CNC13_ReadInterpolatorState.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The sample project shows how to read the state of the CNC interpolator. The state is used to display the position of the machine in both machine and decoder coor...", 
"body" : "See the CNC13_ReadInterpolatorState.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The sample project shows how to read the state of the CNC interpolator. The state is used to display the position of the machine in both machine and decoder coordinates. " }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_example_state_interpolator.html#UUID-7d495950-6d6e-d3d4-336b-0d7c83f08247_section-id235234546899564", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ Reading the State of the Interpolator \/ Structure of the application ", 
"snippet" : "The structure is typical for CNC applications. The G-code is read in the background task. The interpolation is performed in the bus task. During the interpolation, the SMC_ReadAdditionalIpoState function block called. As soon as the interpolation begins, the Valid output is TRUE . The position of th...", 
"body" : "The structure is typical for CNC applications. The G-code is read in the background task. The interpolation is performed in the bus task. During the interpolation, the SMC_ReadAdditionalIpoState function block called. As soon as the interpolation begins, the Valid output is TRUE . The position of the interpolator, which is always output in the machine coordinate system (MCS), is then converted using the current decoder coordinate system (DCS) and output in the visualization. SMC_V3_Set(pos_MCS, ipo.piSetPosition.dX, ipo.piSetPosition.dY, ipo.piSetPosition.dZ);\n\nreadState(\n    Enable:= TRUE,\n    ipo:= ipo);\n\nIF readState.Valid THEN\n    SMC_PosInfo_Trf_Inverse(\n        piOut:= piMCS_to_DCS,\n        piIn:= readState.State.DCS,\n        eOriConv:= readState.State.OriConv);\n\n SMC_PosInfo_Trf_Apply(\n        vDst:= pos_DCS,\n        piTrf:= piMCS_to_DCS,\n        vSrc:= pos_MCS,\n        eOriConv:= readState.State.OriConv);\nEND_IF For more information about the decoder coordinate system, see the following: Shifting, Rotating, and Scaling the Coordinate System. " }, 
{ "title" : "Commissioning ", 
"url" : "_sm_example_state_interpolator.html#UUID-7d495950-6d6e-d3d4-336b-0d7c83f08247_section-id235234714771807", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ Reading the State of the Interpolator \/ Commissioning ", 
"snippet" : "Build the application and download it to a controller. Open the visualization. Start the application and press the Start button of the visualization. You can track the movement of the X and Y coordinates in MCS and DCS....", 
"body" : "Build the application and download it to a controller. Open the visualization. Start the application and press the Start button of the visualization. You can track the movement of the X and Y coordinates in MCS and DCS. " }, 
{ "title" : "Implementation of a Path-Preprocessing Function Block ", 
"url" : "_sm_example_cnc14_path_preprocessing.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ Implementation of a Path-Preprocessing Function Block ", 
"snippet" : "See the CNC14_PathPreprocessing.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The sample project shows how to implement a new path-preprocessing function block. Path preprocessing is generally used to modify the path which is read from the G-c...", 
"body" : "See the CNC14_PathPreprocessing.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The sample project shows how to implement a new path-preprocessing function block. Path preprocessing is generally used to modify the path which is read from the G-code. This allows functions such as tool radius correction or corner smoothing to be implemented. However, it is also possible to integrate specific functions for a particular machine or application as a path-preprocessing function block. For more information about path preprocessing, see the following: Path Preprocessing and Queue Sizes. For an example of how to use a path-preprocessing function block, see the following: CNC Example 03: Performing Path Preprocessing Online. " }, 
{ "title" : "Limiting the tangent change ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234576416031", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ Implementation of a Path-Preprocessing Function Block \/ Limiting the tangent change ", 
"snippet" : "The example shows a 2D cutting application. A knife should be used to cut along a path defined by G-code. The SMC_TRAFO_GantryCutter2 transformation is used to determine the angle of the knife based on the current tangent of the path. The challenge is that the knife must not rotate too quickly, othe...", 
"body" : "The example shows a 2D cutting application. A knife should be used to cut along a path defined by G-code. The SMC_TRAFO_GantryCutter2 transformation is used to determine the angle of the knife based on the current tangent of the path. The challenge is that the knife must not rotate too quickly, otherwise the cut will not be clean. The limitation of the angular velocity of the knife is solved in the sample project by means of the newly created path-preprocessing function block LimitTangentVelocity . It changes the feed rate on the path so that the change velocity of the tangent does not exceed a configurable maximum value. The G-code is a simple rectangle with smoothed corners. The trace shows the result of the execution: The velocity of the C-axis, which corresponds to the rotational velocity of the knife, is displayed in orange. It is limited to 45°\/s as specified. " }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234546899564", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ Implementation of a Path-Preprocessing Function Block \/ Structure of the application ", 
"snippet" : "The structure is typical for CNC applications. The G-code is read in the background task, and path preprocessing also takes place here. The interpolation is performed in the bus task. The LimitTangentVelocity function block shows the necessary steps and states for a path-preprocessing function block...", 
"body" : "The structure is typical for CNC applications. The G-code is read in the background task, and path preprocessing also takes place here. The interpolation is performed in the bus task. The LimitTangentVelocity function block shows the necessary steps and states for a path-preprocessing function block. The basic principle is that the function block reads, processes, and then writes path elements (type SMC_GEOINFO ) from the input queue ( poqDataIn ) to the output queue ( poqDataOut ). The elements are removed from the input queue. The logic for changing the feed rate is located in lines 102–138. The auxiliary function ComputeMaxCurvature calculates the maximum curvature which may occur on a given path element. \/\/ Our velocity limitation comes here. This modifies an element from the\n\/\/ input queue and copies the modified element to the output queue.\n\/\/ Finally, the element is removed from the input queue\n\nm_geo := pgeo^; \/\/ Copy the element\n \/\/ Note: the feature flags set in the G-Code with G38\/G39 can be queried\n \/\/ by reading pgo^.dwFeatureFlags, like this:\n IF (SHR(m_geo.dwFeatureFlags, featureFlag) AND 1) = 1 THEN\n     \/\/ feature is turned on\n\n     ok := ComputeMaxCurvature(m_geo, kappa=> kappa_max);\n     IF NOT ok THEN\n         \/\/ Curvature cannot be computed\n         m_state := STATE_ERROR;\n         ErrorID := SMC_INVALID_PARAMETER;\n         OnExit();\n         RETURN;\n     END_IF\n\n     \/\/ Compute maximum allowed path velocity based on maximum curvature\n     \/\/ and maximum allowed angular velocity\n     IF kappa_max = 0 THEN\n         \/\/ No curvature, no limitation necessary\n         vel := m_geo.dVel;\n     ELSE\n         vel := m_maxAngularVelocity_rad \/ kappa_max;\n     END_IF\n\n     IF velMin < 0 OR vel < velMin THEN\n         velMin := vel;\n     END_IF\n\n     \/\/ Set new maximum velocity for the element\n     m_geo.dVel := MIN(m_geo.dVel, vel);\n ELSE\n     \/\/ feature is turned off\n END_IF " }, 
{ "title" : "Commissioning ", 
"url" : "_sm_example_cnc14_path_preprocessing.html#UUID-193c355a-b220-a40a-a2fc-263cc3e6da61_section-id235234584108811", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ Implementation of a Path-Preprocessing Function Block \/ Commissioning ", 
"snippet" : "Build the application and download it to a controller. Start the application. Open the trace and download it to the controller. Write the value TRUE to the variables Path.bExecute and PLC_PRG.bStart . You can track the processing of the G-code in the trace....", 
"body" : "Build the application and download it to a controller. Start the application. Open the trace and download it to the controller. Write the value TRUE to the variables Path.bExecute and PLC_PRG.bStart . You can track the processing of the G-code in the trace. " }, 
{ "title" : "Preprocessing of Large G-Code Files ", 
"url" : "_sm_example_large_c_code.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ Preprocessing of Large G-Code Files ", 
"snippet" : "The CNC15_LargeGCode.project sample project is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The sample project shows how to process large G-code files. Because very large files are especially common as output from CAD\/CAM systems, this case is shown as an e...", 
"body" : "The CNC15_LargeGCode.project sample project is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The sample project shows how to process large G-code files. Because very large files are especially common as output from CAD\/CAM systems, this case is shown as an example. CAD\/CAM systems often generate G-code files with several hundred thousand lines. These consist of very short linear segments ( G1 ), typically in the range of 100 micrometers to one millimeter. These short linear segments trace the contour of the workpiece. They do not form a smooth path. The tangent usually jumps between the linear segments. The example shows how to read these large files efficiently with constant memory requirements and how to achieve a smooth velocity curve on a path which consists of so many short linear segments. The original contour of the workpiece is reconstructed while preprocessing the G-code. " }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231424931037", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ Preprocessing of Large G-Code Files \/ Structure of the application ", 
"snippet" : "The structure is typical for CNC applications. The G-code is read in the background task ( PathTask ), and path preprocessing also takes place here. The interpolation is performed in the bus task ( MainTask )....", 
"body" : "The structure is typical for CNC applications. The G-code is read in the background task ( PathTask ), and path preprocessing also takes place here. The interpolation is performed in the bus task ( MainTask ). " }, 
{ "title" : "Reading large files ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425324995", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ Preprocessing of Large G-Code Files \/ Reading large files ", 
"snippet" : "In order to keep the latency at the beginning of the G-code processing short, a loop is used in the background task.  For simplicity, a counter is used for the abort condition. Depending on the application, G-code, and PLC performance, other abort conditions such as a timer may be useful. The loop w...", 
"body" : "In order to keep the latency at the beginning of the G-code processing short, a loop is used in the background task.  For simplicity, a counter is used for the abort condition. Depending on the application, G-code, and PLC performance, other abort conditions such as a timer may be useful. The loop will end before reaching this abort condition when the path queue is full. \/\/ Set this value depending on your other tasks, PLC performance, and G-Code\ncounter := 25;\n\nWHILE counter > 0 AND\n      (poqDataOut = 0 OR_ELSE (NOT poqDataOut^.bFull AND NOT poqDataOut^.bEndOfList))\nDO\n     <Read G-Code and process it>\n\n     counter := counter - 1;\nEND_WHILE By means of pipelining in the preprocessing , even very large G-code files can be read with small, constant memory requirements. The queue sizes are chosen to be large enough to allow the respective function blocks sufficient forecast. The output queue of SMC_NCInterpreter is also the input queue of SMC_SmoothMerge . A total of 128+3 elements are reserved for the output queue. 3 is a reserve of the SMC_OutQueue and 128 remain for use as a forecast for SMC_SmoothMerge . SMC_SmoothMerge combines a maximum of 128 short linear segments into one spline. The output queue of SMC_SmoothMerge is also the input queue of SMC_SmoothPath . SMC_SmoothPath requires at least 2 elements, plus a reserve of 3 elements, as a forecast. If M-functions are located between two smoothed elements, then more elements are required according to the number of M-functions. The output queue of SMC_SmoothMerge is also the input queue of SMC_Interpolator . A forecast of 100 elements is suitable for most applications. For more information, see the following: Path Preprocessing and Queue Sizes. \/\/\/ Buffer of the interpreter, lookahead for SMC_SmoothMerge\naBufIp : ARRAY[0..130] OF SMC_GeoInfo;\n\/\/\/ Buffer of SMC_SmoothMerge\naBufSmm : ARRAY[0..15] OF SMC_GeoInfo;\n\/\/\/ Buffer of SMC_SmoothPath, lookahead for SMC_Interpolator\naBufSmp : ARRAY[0..99] OF SMC_GeoInfo; " }, 
{ "title" : "Preprocessing of linear segments ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425764624", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ Preprocessing of Large G-Code Files \/ Preprocessing of linear segments ", 
"snippet" : "The SMC_SmoothMerge function block ensures a smooth velocity curve on the many, very short linear segments. It combines as many consecutive linear segments as possible into one spline, while maintaining specified tolerances. In this example, a maximum deviation of 0.1 mm in X and Y is allowed ( PARA...", 
"body" : "The SMC_SmoothMerge function block ensures a smooth velocity curve on the many, very short linear segments. It combines as many consecutive linear segments as possible into one spline, while maintaining specified tolerances. In this example, a maximum deviation of 0.1 mm in X and Y is allowed ( PARAMETERS.piMaxDifference ). The figures show the step-by-step processing: Reading the short linear segments Combining multiple linear segments into splines using SMC_SmoothMerge . Smoothing between the splines with SMC_SmoothPath because, as seen above, the splines do not connect tangentially to each other. " }, 
{ "title" : "Commissioning ", 
"url" : "_sm_example_large_c_code.html#UUID-561e87b6-dea7-0abb-de49-58a2020bc129_section-id235231425998344", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ Preprocessing of Large G-Code Files \/ Commissioning ", 
"snippet" : "Build the application and download it to a controller. Open the trace and download it to the controller. Start the application. You can track the processing of the G-code....", 
"body" : "Build the application and download it to a controller. Open the trace and download it to the controller. Start the application. You can track the processing of the G-code. " }, 
{ "title" : "CNC Example 16: Probing function (clear remaining distance) (G31) ", 
"url" : "_sm_example_cnc_16.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 16: Probing function (clear remaining distance) (G31) ", 
"snippet" : "See the CNC16_G31.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The sample project shows how to use the probing function (clear remaining distance). In the example, the machine moves in the X direction until a light barrier is reached at X=50 ...", 
"body" : "See the CNC16_G31.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The sample project shows how to use the probing function (clear remaining distance). In the example, the machine moves in the X direction until a light barrier is reached at X=50 . As soon as the light barrier has been reached, the machine has to stop. The remaining G-Code has to be processed starting from this position. " }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_example_cnc_16.html#UUID-78892014-10dd-8256-9708-05f2d78a2884_section-id235224424924168", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 16: Probing function (clear remaining distance) (G31) \/ Structure of the application ", 
"snippet" : "The structure is typical for CNC applications. The G-code is read in the background task ( PathTask ). Path preprocessing is also done in this task. The interpolation is performed in the bus task ( MainTask ). The following G-code is used. In block N10 , a rapid positioning is made to X = 20 . Then,...", 
"body" : "The structure is typical for CNC applications. The G-code is read in the background task ( PathTask ). Path preprocessing is also done in this task. The interpolation is performed in the bus task ( MainTask ). The following G-code is used. In block N10 , a rapid positioning is made to X = 20 . Then, with G31 (probing function: clear remaining path) , a movement is made to X = 100 . Finally, in block N30 , a linear movement is made to X = 20, Y = 50 . N10 G0 X20 F100 E1000 E-1000\nN20 G31 X100\nN30 G1 X20 Y50 The interaction between the interpolator and the interpreter is particularly important for the probing function (clear remaining path). The interpreter decodes the G-code and generates a straight line from X=20 to X=100 for block N20 . Then it stops decoding. The interpolator performs the linear movement and simultaneously outputs the probe number as output udiActProbe . For the G31, the sample number is always 1. In the application, the interpolator is stopped with bQuick_Stop as soon as the drive travels beyond position X=50 . (This simulates the light barrier.) In the bus task, the SMC_SetInterpreterStartPosition function block is used to continuously copy the current position of the machine. In the PathTask , the start position is assigned to the input SMC_NCInterpreter.piStartPosition : inter(\n    sentences:= read.sentences,\n    bExecute:= read.bExecute,\n    nSizeOutQueue:= SIZEOF(bufIpo),\n    pbyBufferOutQueue:= ADR(bufIpo),\n    piStartPosition:= Main.setStart.StartPos); As soon as the interpolator is stopped, the bAcknProbe input is used to acknowledge the G31 command. In a real application, it should also be checked at this point that the axes have actually reached the stop position. The SMC_InPosition function block can be used to do this. This causes the interpreter to resume decoding, but with the updated start position so that the following block N30 is started from position X=55.5 . The following diagram illustrates these steps. The numbers in brackets refer to the corresponding steps in the process outlined above. " }, 
{ "title" : "Commissioning ", 
"url" : "_sm_example_cnc_16.html#UUID-78892014-10dd-8256-9708-05f2d78a2884_section-id235224425037675", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 16: Probing function (clear remaining distance) (G31) \/ Commissioning ", 
"snippet" : "Build the application and download it to a controller. Open the trace and download it to the controller. Start the application and open the visualization....", 
"body" : "Build the application and download it to a controller. Open the trace and download it to the controller. Start the application and open the visualization. " }, 
{ "title" : "CNC Example 17: Read G-Code from Strings ", 
"url" : "_sm_example_cnc_17.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 17: Read G-Code from Strings ", 
"snippet" : "See the CNC17_ReadGCodeFromStrings.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The sample project shows how to use SMC_StringStream2 to read G-code from a string. This example can be seen as a starting point and used to read G-code from othe...", 
"body" : "See the CNC17_ReadGCodeFromStrings.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The sample project shows how to use SMC_StringStream2 to read G-code from a string. This example can be seen as a starting point and used to read G-code from other sources, for example via network communication (sockets). In this case, a function block needs to be implemented which implements the SMC_ITextStream interface and reads the text (for example, from a socket). This is similar to how SMC_StringStream2 implements this interface to read the G-code from a string. " }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_example_cnc_17.html#UUID-7c947453-e422-10bd-3720-9f55e7b54f9f_section-id235224424924168", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 17: Read G-Code from Strings \/ Structure of the application ", 
"snippet" : "The structure is typical for CNC applications. The G-code is read in the background task ( PathTask ), and path preprocessing also takes place here. The interpolation is performed in the bus task. In the Path program, the SMC_ReadNCFromStream function block is used to read the G-code. For technical ...", 
"body" : "The structure is typical for CNC applications. The G-code is read in the background task ( PathTask ), and path preprocessing also takes place here. The interpolation is performed in the bus task. In the Path program, the SMC_ReadNCFromStream function block is used to read the G-code. For technical reasons, not only a stream of type SMC_StringStream2 is passed to this function block, but also an array whose size depends on the parameter SMC_CNC_LibParams.MAX_SUBPROGRAM_NESTING_DEPTH . The first stream in the array is used for the main program, while the other streams are used for possible subprogram calls. At the beginning, the main program is loaded into the first stream of the array: \/\/ Load G-Code into first stream\naStringStream[0].Init(sProgramName) ;\naStringStream[0].AppendData(sGCode) ;\naStringStream[0].SetEndOfData() ; Then everything is prepared for reading the usual G-code programs. The example also shows how subprogram calls can be supported. To do this, it is necessary to create a function block which implements the SMC_INCLookup interface. This function block is responsible for returning the G-code of a subprogram when it is read by SMC_ReadNCFromStream . The Lookup method receives the name of the subprogram and initializes an incoming stream with the G-code: METHOD LookUp : SMC_ERROR\nVAR_IN_OUT CONSTANT\n    programName : STRING;\nEND_VAR\nVAR_INPUT\n    stream : SMC_ITextStream;\nEND_VAR\nVAR\n    i : UDINT ;\n    pStringStream : POINTER TO SMC_StringStream2 ;\nEND_VAR This example searches through an array of subprograms. The array is defined in the Path program as VAR_INPUT : \/\/ The table of subprograms.\n aSubs : ARRAY[0..0] OF SubProgram := [\n            (stName := 'SUB1',\n             stContent := '\nSUBPROGRAM SUB1{#p1 : LREAL, #p2 : LREAL, #p3 : LREAL}\nN10 G1 X#p1\nN20 G1 X#p2\nN30 G1 X#p3\nEND_SUBPROGRAM')\n        ] ; In Lookup , the array is iterated through until a subprogram with a matching name is found: i := 0 ;\nWHILE i < nNumSPs DO\n IF psp[i].stName = programName THEN\n IF NOT __QUERYPOINTER(stream, pStringStream) OR_ELSE\n pStringStream = 0\n THEN\n \/\/ A stream of the wrong type has been passed by SMC_ReadNCFromStream.\n LookUp := SMC_CNC_INTERNAL_ERROR ;\n ELSE\n pStringStream^.Init(sName := psp[i].stName) ;\n LookUp := pStringStream^.AppendData(psp[i].stContent) ;\n pStringStream^.SetEndOfData() ;\n END_IF\n RETURN ;\n END_IF\n\n i := i + 1 ;\nEND_WHILE\n \n\/\/ No subprogram with name programName has been found in the array psp.\nLookUp := SMC_RNCF_SUBPROGRAM_FILE_NOT_FOUND ; " }, 
{ "title" : "Commissioning ", 
"url" : "_sm_example_cnc_17.html#UUID-7c947453-e422-10bd-3720-9f55e7b54f9f_section-id235224425037675", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 17: Read G-Code from Strings \/ Commissioning ", 
"snippet" : "Build the application and download it to a controller. Open the visualization. Press Start to start the G-code processing....", 
"body" : "Build the application and download it to a controller. Open the visualization. Press Start to start the G-code processing. " }, 
{ "title" : "CNC Example 10: Programming Dynamic CNC Paths ", 
"url" : "_sm_example_dynamic_path.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ CNC Example 10: Programming Dynamic CNC Paths ", 
"snippet" : "See the CNC10_DynamicPath.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how a CNC path can be created directly in the application at runtime – not fed with G code from a CNC program object or a file. When this kind of conven...", 
"body" : "See the CNC10_DynamicPath.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how a CNC path can be created directly in the application at runtime – not fed with G code from a CNC program object or a file. When this kind of conventional CNC program is compiled, the path data is stored in a SMC_CNC_Data data structure type. This internal data is then compiled in specific global data structures depending on the compile mode ( SMC_CNC_REF or SMC_OutQueue ). In compile mode SMC_CNC_REF , the data is stored in an array of SMC_GEOINFO elements. The array in the application code is usually passed to the function block instance SMC_NCDecoder . At runtime, the data is decoded there and stored in a global data structure of type SMC_OUTQUEUE . Then path preprocessing function blocks can be called. In compile mode SMC_OutQueue , a global data structure ( SMC_OUTQUEUE ) is generated directly . This data structure in the application code is passed to the interpolator ( SMC_Interpolator FB instance). The function block SMC_NCDecoder is not called. In compile mode FILE , the data is stored in a file. The data is stored as an array of elements of type SMC_GEOINFO and correspond to the data that is generated in compile mode SMC_CNC_REF . Instead of programming the CNC path, you can program an application code that instantiates a data structure of type SMC_OUTQUEUE at runtime and assigns its values. You program a CNC path that is generated dynamically at runtime. You can pass the data structure to other function block instances (for example to the path preprocessing function blocks or to the function block SMC_Interpolator ). Programming The CNCDynamicPath sample project is located in the installation directory of CODESYS . The sample project was developed from the CNConline project. It includes the Path program instead of the graphically programmed Example path. A data structure of type SMC_OUTQUEUE is generated dynamically. Declaration: Declare a data structure of type SMC_OUTQUEUE . The data structure contains the CNC path data and is populated dynamically. Example: QUEUE Allocate memory for the path with the required amount to SMC_GEOINFO elements. Example: BUF Declare a variable of type SMC_GEOINFO with an initial step. Example: GEO Implementation: An array element of data type SMC_GEOINFO corresponds to a path element in the CNC code. The following steps have to be performed for each element in order to add the element to the SMC_OUTQUEUE : Every array element has a start position that corresponds to the end position of the previous array element. Example: GEO.piStartPos.dX := 0; or GEO.piStartPos := GEO.piDestPos; Determine a movement type for each array element. Example: GEO.iMoveType := CCLW; or GEO.iMoveType := LIN; Set the parameters of the movement type. This is not required for all movement types. Example: For an arc (movement type: CCLW), setting the following positions is required: geoinfo_A[i].dP1 := 200; geoinfo_A[i].dP2 := 100; geoinfo_A[i].dP3 := 50; geoinfo_A[i].dT1 := 0; geoinfo_A[i].dT2 := 90; Insert the calculation of the end position. SMC_CalcEndPnt(ADR(GEO)); Insert the calculation of the object length. SMC_CalcLengthGeo(ADR(GEO)); Save the object in QUEUE : SMC_AppendObj(POQ:=ADR(QUEUE), PGI:=ADR(GEO)); When the path is created completely, the end markers have to be set: QUEUE.bEndOfList := TRUE; Then, when a path preprocessing function block is called, it is required to set the start or end bit for InternMark . Example CNC path with two path elements In this example, the arrays are not defined with the X\/Y-positions. If this should be an example with two path elements as described, then these arrays would have to have two elements each. For example, derived from the sample project: xp:ARRAY[1..2] OF REAL:= [100,50]; yp:ARRAY[1..2] OF REAL:= [0,100]; PROGRAM Path\nVAR\n iState : INT;\n QUEUE : SMC_OUTQUEUE;\n BUF : ARRAY[0..49] OF SMC_GEOINFO;\n \/\/ Memory allocation\n GEO : SMC_GEOINFO:=(dT1:=0, dT2:=1, dToolRadius:=0, dVel:=100, dVel_End:=100, dAccel:=200, dDecel:=500, iObj_Nr:=0);\n \/\/ Initial path element\n n : INT := 0;\n QUEUE.nSize := SIZEOF(BUF);\nEND_VAR\n\nCASE iState OF\n0:\n QUEUE.pbyBuffer := ADR(BUF[0]);\n \/\/ Initialize QUEUE\n SMC_SetQueueCapacity(ADR(QUEUE), SIZEOF(BUF));\n iState := iState + 1;\n\n1:\n \/\/ Fill QUEUE\n WHILE NOT QUEUE.bFull DO\n \/\/ When QUEUE is full, wait until it has been processed by the following FBs\n n := n + 1;\n GEO.iSourceLine_No := n;\n GEO.piStartPos := GEO.piDestPos;\n \/\/ Copying last destination\n GEO.iMoveType := LIN;\n \/\/ Generating linear movement\n GEO.iObjNo := GEO.iObjNo + 1;\n \/\/ Calculating number\n GEO.piDestPos.dX := xp[n];\n \/\/ Generatint position\n GEO.piDestPos.dY := yp[n];\n SMC_CalcLengthGeo(pg := ADR(GEO));\n \/\/ Calculating length of object with the help of the standard function\n SMC_AppendObj(poq:=ADR(QUEUE), pgi:=ADR(GEO));\n \/\/ Appending object to QUEUE\n IF n = SIZEOF(xp)\/SIZEOF(xp[1]) THEN\n \/\/ All target positions processed\n QUEUE.bEndOfList := TRUE;\n n := 0;\n iState := 2;\n EXIT;\n END_IF\n END_WHILE\n\n2:\n \/\/Done\n ;\nEND_CASE\n\nCheckVel(bExecute:=TRUE , poqDataIn:=ADR(queue)); \/\/ Preprocessing If the SMC_OUTQUEUE data structure is populated with SMC_GEOINFO data and the data structure element was set to bFULL = TRUE , then we do not recommend a further assignment of SMC_GEOINFO data. In this case, the creation of the path is interrupted at runtime until the first element of the SMC_OUTQUEUE data structure is processed in the interpolator. Only then is another element inserted. Avoid this interruption by allocating enough memory. See variable BUF . If the data structure SMC_OUTQUEUE is refilled after the first execution, then the interpolator and all preprocessing function blocks (example: SMC_CheckVelocities ) have to be restarted by a rising edge at Execute . " }, 
{ "title" : "Using Block Search ", 
"url" : "_sm_example_using_block_search.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ Using Block Search ", 
"snippet" : "A block search allows for interpolation to continue after an interruption. The stop position is traveled first and the path is traveled unchanged from this position. For this, the program that performs the interpolation and the program that performs the path preprocessing has to be extended. Example...", 
"body" : "A block search allows for interpolation to continue after an interruption. The stop position is traveled first and the path is traveled unchanged from this position. For this, the program that performs the interpolation and the program that performs the path preprocessing has to be extended. Example An interrupted milling head stops the travel. After being repaired, the path can be continued with block search. Extend the application by Function block instance in the interpolation task that saves the preprocessing position Function block instance in the path task that shortens a path element For more information, see: SMC_BlockSearchSavePos, SMC_BlockSearchPos, and SMC_BlockSearch Using block search An instance of the SMC_BlockSearch function block has to be called in the same task as the remaining path preprocessing, typically directly before the SMC_CheckVelocities function block. If a rising edge exists at bExecute , then a block search is performed. After starting, the saved position is traveled and the path is traveled unchanged from this position. Declare an instance of the SMC_BlockSearch function block in the program that the path preprocessing performs. bs: SMC_BlockSearch; Implement the triggering of the bExecute input of the SMC_BlockSearch instance. The position saved previously with the SMC_BlockSearchSavePos function block has to be passed as the epos input of the SMC_BlockSearch function block. Example: Block search in path preprocessing PROGRAM CNC_PreparePath\n...\nVAR\n bs: SMC_BlockSearch;\nEND_VAR\n...\nbs(\n ePos:=CNC.bssp.ePos ,\n bExecute:=rncf.bExecuteDecoder ,\n bAbort:= ,\n bAppend:= ,\n poqDataIn:=ncd.poqDataOut ,\n bStartFromSavedPos:=CNC.bssp.bPositionStored ,\n nSizeOutQueue:=SIZEOF(agiBufBlockSearch) ,\n pbyBufferOutQueue:=ADR(agiBufBlockSearch) ,\n bDone=> ,\n bBusy=> ,\n bError=> ,\n wErrorID=> ,\n poqDataOut=> ); The bStartFromSavedPos input can also be activated with a control variable. The control variable can be activated after a cancellation in order to continue again at the last saved position. " }, 
{ "title" : "Saving the preprocessing position ", 
"url" : "_sm_example_using_block_search.html#UUID-c7e93ecd-388f-baf1-4162-0ba994d84585_id_defc89f86dbffeecc0a86463490ce87e_id_04188a3f3bea4adbc0a8640e000b4984", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ Using Block Search \/ Saving the preprocessing position ", 
"snippet" : "You can use the SMC_BlockSearchSavePos function block for saving the current position on command. At this time, the instance of the function block has to run in the task of the interpolator. The interpolator program in the example is named \"CNC\". Declare an instance of the SMC_BlockSearchSavePos fun...", 
"body" : "You can use the SMC_BlockSearchSavePos function block for saving the current position on command. At this time, the instance of the function block has to run in the task of the interpolator. The interpolator program in the example is named \"CNC\". Declare an instance of the SMC_BlockSearchSavePos function block in the program that the interpolation performs. bssp: SMC_BlockSearchSavePos; Connect the ipo input of the SMC_BlockSearchSavePos instance to the interpolator instance. Connect the bExecute input to a control variable that is set in the application when the CNC program is canceled (for example if the bAbort input of the SMC_Interpolator instance was set). The position stored at the ePos output is used as follows for the block search by means of SMC_BlockSearc . After interruption, bExecute has to be reset with a rising edge. Example Part of the program that performs the interpolation with the instance of the SMC_BlockSearchSavePos function block in CFC. " }, 
{ "title" : "ReadNCFile2 with Token Modifier ", 
"url" : "_sm_example_readncfile2_token_modifier.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ ReadNCFile2 with Token Modifier ", 
"snippet" : "The CNC12_TokenModifier.project sample project is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how to modify the G-code during import in order to convert the unit of path velocity (F-word) from mm\/min to mm\/s. This is done by inserting th...", 
"body" : "The CNC12_TokenModifier.project sample project is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how to modify the G-code during import in order to convert the unit of path velocity (F-word) from mm\/min to mm\/s. This is done by inserting the G-code 1\/60.0 * before the velocity value while the G-code for the F-word is read. F6000 then becomes F 1\/60.0 * 6000 , which is later processed by the SMC_NCInterpreter function block to F100 . In simple cases, you could skip the multiplication by 1\/60 and simply adjust the value (for example, from 6000 to 100 ). However, multiplication is more general because it also works when variables are used. F $SPEED$ becomes F 1\/60.0 * $SPEED$ . " }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869818233271", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ ReadNCFile2 with Token Modifier \/ Structure of the application ", 
"snippet" : "As usual for CNC applications, the application consists of path processing ( CNC_PreparePath program) and interpolation ( CNC program). Because the interpolation is not different from the other examples, it will not be discussed further here. Path processing is called cyclically every 20 ms in the l...", 
"body" : "As usual for CNC applications, the application consists of path processing ( CNC_PreparePath program) and interpolation ( CNC program). Because the interpolation is not different from the other examples, it will not be discussed further here. Path processing is called cyclically every 20 ms in the low-priority PathTask . The interpolation is called cyclically every 4 ms in the high-priority MotionTask . The background task VISU_TASK is defined for the visualization. You can start processing the G-code in the visualization. The G-code and the movement of the machine (3D gantry) are displayed on the right side of the visualization. " }, 
{ "title" : "The G-code ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869818432406", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ ReadNCFile2 with Token Modifier \/ The G-code ", 
"snippet" : "CNC_PathSpeed N10 G01 X1000 F6000 N20 Y1000 In this G-code, the path velocity in block N10 is set with F6000 to 6000 mm\/min. However, the CNC function blocks expect the path velocity in mm\/s. Two linear movements are commanded, first to X=1000 and then to X=1000, Y=1000 ....", 
"body" : "CNC_PathSpeed N10 G01 X1000 F6000\nN20 Y1000 In this G-code, the path velocity in block N10 is set with F6000 to 6000 mm\/min. However, the CNC function blocks expect the path velocity in mm\/s. Two linear movements are commanded, first to X=1000 and then to X=1000, Y=1000 . " }, 
{ "title" : "Token processing ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869819460923", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ ReadNCFile2 with Token Modifier \/ Token processing ", 
"snippet" : "The SMC_ReadNCFile2 and SMC_ReadNCFromStream function blocks provide the capability of performing your own transformations when the G-code is read. Here we are using with the SMC_ITokenModifier interface, which is passed via the aTokenModifier input. This interface works on \"tokens\". These are the b...", 
"body" : "The SMC_ReadNCFile2 and SMC_ReadNCFromStream function blocks provide the capability of performing your own transformations when the G-code is read. Here we are using with the SMC_ITokenModifier interface, which is passed via the aTokenModifier input. This interface works on \"tokens\". These are the basic parts of the G-code into which the G-code text is subdivided when the processing is started. Example N50 G36 O$plc_variable$ D'TextTest' X-1 (Comment) This G-code is subdivided as follows: Text SMC_TOKENTYPE SMC_TOKENVALUE N identifer stValue = 'N' 50 number fValue = 50.0 G identifer stValue = 'G' 36 number fValue = 36.0 O identifer stValue = 'O' $plc_variable$ variable stValue = 'plc_variable' D identifer stValue = 'D' 'TextTest' strLiteral stValue = 'TextTest' X identifer stValue = 'X' - operator stValue = '-' 1 number fValue = 1.0 Information which is not required for further processing (for example, whitespace characters, line breaks, and comments) does not appear in the list of tokens. When the SMC_ITokenModifier interface is implemented, the list of tokens can be adapted by adding new tokens, deleting tokens, and changing the values of tokens. The interface defines two methods: Start : Initialization of the function block. The internal state is reset. Call : Call of this method while the G-code is being processed. Tokens can be read and removed from the input queue and added to the output queue. " }, 
{ "title" : "Implementation ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869819739016", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ ReadNCFile2 with Token Modifier \/ Implementation ", 
"snippet" : "The processing flow in PLC_PRG is as follows: All tokens are moved from the input queue to the output queue. If an F-word is detected, then two new tokens, 1\/60 and * , are added after the token for \"F\" and before the token for the velocity value. The Call method contains the logic to process the to...", 
"body" : "The processing flow in PLC_PRG is as follows: All tokens are moved from the input queue to the output queue. If an F-word is detected, then two new tokens, 1\/60 and * , are added after the token for \"F\" and before the token for the velocity value. The Call method contains the logic to process the tokens. It is helpful to first move the tokens from the input queue ( tokensIn ) to a temporary queue ( m_tmpQueue ), process them there, and then move them to the output queue ( tokensOut ). The temporary queue is not absolutely necessary to adapt the path velocity, but it simplifies the program structure in more complicated cases. Method: Call At first, the system waits in the STATE_RUNNING state until processing can start (when tokens are available in the input queue and there is still space in the output queue). IF NOT SMC_NC_CanProcessTokens(tokensIn, tokensOut) THEN\n    \/\/ Wait until processing can proceed\n    RETURN;\nEND_IF Then a token is moved from the input queue to the temporary queue. IF m_tmpQueue.IsEmpty() THEN\n    \/\/ Move the next token from the in-queue to the tmp-queue.\n  pt := tokensIn.GetFromStart(0);\n    m_tmpQueue.Append(pt^);\n    tokensIn.RemoveFirst();\nEND_IF The actual processing is done in the ConvertSpeed method. IF NOT m_tmpQueue.IsEmpty() THEN\n    \/\/ The actual processing is done here\n    ConvertSpeed();\nEND_IF At the end of the method, a token is moved from the temporary queue to the output queue. Method: ConvertSpeed The first token from the temporary queue is checked. If an identifier with the value F is found, then two additional tokens are added: the number 1\/60.0 and the operator * . (The size of the temporary queue is selected in such a way that two more tokens fit into the queue in addition to the one token from the input queue). tk := m_tmpQueue.GetFromStart(0)^;\n\nIF tk.tokenType = SMC_TokenType.identifier THEN\n tk.GetString(pbyString => pby, iSize => iSize);\n \/\/ 70 = ASCII code for F (path velocity)\n IF iSize = 1 AND pby^ = 70 THEN\n \/\/ Insert the number 1\/60\n SMC_Token_InitNumber(\n tk:= tkNumber,\n value:= 1\/60.0,\n srcPos:= tk.srcPos);\n m_tmpQueue.Append(tkNumber);\n\n \/\/ Insert operator '*' for multiplication\n SMC_Token_InitOperator(\n tk:= tkOperator,\n value:= '*',\n srcPos:= tk.srcPos);\n m_tmpQueue.Append(tkOperator);\n END_IF\nEND_IF " }, 
{ "title" : "Commissioning ", 
"url" : "_sm_example_readncfile2_token_modifier.html#UUID-52e6a657-25dc-03f3-159d-8e2009adc54a_section-idm234869820021001", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ ReadNCFile2 with Token Modifier \/ Commissioning ", 
"snippet" : "Build the application and download it to a controller. Start the application, switch to the visualization, and press Start ....", 
"body" : "Build the application and download it to a controller. Start the application, switch to the visualization, and press Start . " }, 
{ "title" : "User-Specific G-Code Functions ", 
"url" : "_sm_custom_g_code_functions.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ User-Specific G-Code Functions ", 
"snippet" : "The CNC11_CustomFunctions.project sample project is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how to create your own functions for use in expressions in G-code. For more information about expressions and functions in G-code, see: Expre...", 
"body" : "The CNC11_CustomFunctions.project sample project is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how to create your own functions for use in expressions in G-code. For more information about expressions and functions in G-code, see: Expressions. There you will find a list of all operators and functions supported by default. The example defines the SEL operator from IEC 61131-3 so that it can also be used in G-code. " }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867931475267", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ User-Specific G-Code Functions \/ Structure of the application ", 
"snippet" : "As usual for CNC applications, the application consists of path processing ( CNC_PreparePath program) and interpolation ( CNC program). Because the interpolation does not differ from the other examples, the topic will not be discussed further here. Path processing is called cyclically every 20 ms in...", 
"body" : "As usual for CNC applications, the application consists of path processing ( CNC_PreparePath program) and interpolation ( CNC program). Because the interpolation does not differ from the other examples, the topic will not be discussed further here. Path processing is called cyclically every 20 ms in the low-priority PathTask . The interpolation is called cyclically every 4 ms in the high-priority MotionTask . The background task VISU_TASK is defined for the visualization. In the visualization, you can start processing the G-code and set the value of the variable $LONGLINE$ . The G-code and the movement of the machine (3D gantry) are displayed on the right side of the visualization. " }, 
{ "title" : "The G-code ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867932695176", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ User-Specific G-Code Functions \/ The G-code ", 
"snippet" : "CNC LET #WIDTH : LREAL N10 G36 O#WIDTH D SEL($LONGLINE$, 40, 110) N20 F50 E100 E-100 N30 G01 X#WIDTH Y#WIDTH Z#WIDTH\/2 N40 Y-#WIDTH N50 X-#WIDTH Z-#WIDTH\/2 N60 Y#WIDTH N70 X0 Y0 Z0 Line 1: Declaration of the local variable #WIDTH of type LREAL . Line 2, Block N10: Assignment of the value of SEL($LON...", 
"body" : "CNC LET #WIDTH : LREAL\nN10 G36 O#WIDTH D SEL($LONGLINE$, 40, 110)\nN20 F50 E100 E-100\nN30 G01 X#WIDTH Y#WIDTH Z#WIDTH\/2\nN40 Y-#WIDTH\nN50 X-#WIDTH Z-#WIDTH\/2\nN60 Y#WIDTH\nN70 X0 Y0 Z0 Line 1: Declaration of the local variable #WIDTH of type LREAL . Line 2, Block N10: Assignment of the value of SEL($LONGLINE$, 40, 110) to the variable #WIDTH . If the value of the PLC variable $LONGLINE$ is TRUE , then the value of the expression is 110; otherwise it is 40. In the following lines, a rectangle with additional movement in the Z-direction is traversed; the length of one side of the rectangle is 2*#WIDTH . " }, 
{ "title" : "Implementation of the SEL function ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867935164437", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ User-Specific G-Code Functions \/ Implementation of the SEL function ", 
"snippet" : "To create a user-defined function, you need to write a function block which implements the SMC_NC_IFunction interface. For more information, see: SMC_NC_IFunction . The interface defines two methods: GetSignature . The return type, the count, and the types of the arguments of the function are return...", 
"body" : "To create a user-defined function, you need to write a function block which implements the SMC_NC_IFunction interface. For more information, see: SMC_NC_IFunction . The interface defines two methods: GetSignature . The return type, the count, and the types of the arguments of the function are returned here. In this example, the SEL function returns a value of type T_OTHER and has 3 arguments of type T_BOOL , T_OTHER , and T_OTHER . T_OTHER stands for any type (either T_BOOL , T_LREAL , or T_STRING ]. All 3 occurrences of T_OTHER must have the same type. METHOD GetSignature\nVAR_OUTPUT\n    resultType : SMC_GVar_Type;\n    nNumArguments : UDINT;\n    pType : POINTER TO SMC_GVar_Type;\nEND_VAR\nVAR    argTypes : ARRAY[0..2] OF SMC_GVar_Type :=\n        [SMC_GVar_Type.T_BOOL,\n         SMC_GVar_Type.T_OTHER,\n         SMC_GVar_Type.T_OTHER];\nEND_VAR\n\nresultType := SMC_GVAR_Type.T_OTHER;\nnNumArguments := 3;\npType := ADR(argTypes); Call : This method is called when the G-code is being processed. The arguments are passed via the pa input. The expression pa[0].argValue.bValue is used to access the Boolean value of the first argument. Depending on the type of the second argument pa[1].argType , the result is the return value result.argType and the branching into a CASE statement. METHOD Call\nVAR_IN_OUT\n    result : SMC_NC_GArgument;\nEND_VAR\nVAR_INPUT\n    pa : POINTER TO SMC_NC_GArgument;\nEND_VA\nRVAR_OUTPUT\n    eError : SMC_ERROR;\nEND_VAR\nVAR\n    g : BOOL;\nEND_VAR\n\ng := pa[0].argValue.bValue;\n\nresult.argType := pa[1].argType;\n\nCASE result.argType OF\nSMC_GVAR_Type.T_BOOL:\n    result.argValue.bValue := SEL(g, pa[1].argValue.bValue, pa[2].argValue.bValue);\n\nSMC_GVAR_Type.T_STRING:\n    result.argValue.sValue := SEL(g, pa[1].argValue.sValue, pa[2].argValue.sValue);\n\nSMC_GVAR_Type.T_LREAL:\n    result.argValue.fValue := SEL(g, pa[1].argValue.fValue, pa[2].argValue.fValue);\n\nELSE\n    eError := SMC_INVALID_PARAMETER;\nEND_CASE " }, 
{ "title" : "Configuration of SMC_ReadNCFile2 ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867956933133", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ User-Specific G-Code Functions \/ Configuration of SMC_ReadNCFile2 ", 
"snippet" : "An instance of the CNC_Sel function block is created in the GVL_CNCFunctions global variable list. An array aCNCFunctions of length 1 is initialized with the name and instance of the function block. This array is then linked in the table funTable of type SMC_NC_GFunctionTable . aCNCFunctions : ARRAY...", 
"body" : "An instance of the CNC_Sel function block is created in the GVL_CNCFunctions global variable list. An array aCNCFunctions of length 1 is initialized with the name and instance of the function block. This array is then linked in the table funTable of type SMC_NC_GFunctionTable . aCNCFunctions : ARRAY[0..0] OF SMC_NC_GFunction :=\n    [(stName:= 'SEL', iFunc:= GVL_CNCFunctions.g_Sel)];\n\nfunTable : SMC_NC_GFunctionTable :=\n    (numFunctions:= 1,     pFunction:= ADR(aCNCFunctions)) ; Finally, this table is passed to the SMC_ReadNCFile2 function block: rncf2 : SMC_ReadNCFile2 := (bParenthesesAsComments:= FALSE);\n\n[...]\n\nrncf2(\n    bExecute:= TRUE,\n    sFileName:= sFileName,\n    pCustomFunTable:= ADR(funTable),\n    pvl:= ADR(varList)); " }, 
{ "title" : "Commissioning ", 
"url" : "_sm_custom_g_code_functions.html#UUID-af28ec51-43ef-5ef3-666a-22cc5993bd83_section-idm234867960408693", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ Examples \/ User-Specific G-Code Functions \/ Configuration of SMC_ReadNCFile2 \/ Commissioning ", 
"snippet" : "Build the application and download it to a controller. Start the application, switch to the visualization, and press Start . You can use the Longline radio button to set the value of the variable $LONGLINE$ in the G-code to TRUE or FALSE ....", 
"body" : "Build the application and download it to a controller. Start the application, switch to the visualization, and press Start . You can use the Longline radio button to set the value of the variable $LONGLINE$ in the G-code to TRUE or FALSE . " }, 
{ "title" : "User Interface ", 
"url" : "_sm_cnc_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Command: Analyze Dynamics ", 
"url" : "_sm_cmd_cnc_analyze_dynamics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Analyze Dynamics ", 
"snippet" : "Analyze Dynamics Function : The command starts a dynamics analysis of the CNC path active in the editor. At the same time, the dimensions for position, velocity, acceleration, and jerk of the CNC path are determined depending on the time, and they are displayed in the time charts of the Dynamics Ana...", 
"body" : "Analyze Dynamics Function : The command starts a dynamics analysis of the CNC path active in the editor. At the same time, the dimensions for position, velocity, acceleration, and jerk of the CNC path are determined depending on the time, and they are displayed in the time charts of the Dynamics Analysis dialog. Call : CNC menu Requirement : A CNC path is open in the editor. In order to perform a dynamics analysis of the CNC path, there must not be any errors in the calculation of their path preprocessing. For more information, see: Show preprocessed Path" }, 
{ "title" : "Dialog: Dynamics Analysis ", 
"url" : "_sm_cmd_cnc_analyze_dynamics.html#UUID-172573a8-7bc5-69ee-931b-3074ace95453_id_f14ff69a244133a5c0a8640e0144954d_id_72da7ed158aa22a9c0a864637a09d164", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Analyze Dynamics \/ Dialog: Dynamics Analysis ", 
"snippet" : "The settings in the dialog are used exclusively for displaying the dynamics analysis and have no effect on the CNC program or CNC settings. In the dynamics analysis, the time curves for the dimensions of position, velocity, acceleration, and jerk are determined for the entire path that is traveled. ...", 
"body" : "The settings in the dialog are used exclusively for displaying the dynamics analysis and have no effect on the CNC program or CNC settings. In the dynamics analysis, the time curves for the dimensions of position, velocity, acceleration, and jerk are determined for the entire path that is traveled. The time charts are shown in the dialog on the same time axis. The settings of the dialog are used (preset or saved). Position chart Position curve of the selected axis (black) Red circle; indicates the beginning of a path element The tooltip of the marker provides information about the line numbers in the respective G code or in the table. Velocity chart Velocity curve of the selected axis (blue) Acceleration chart Acceleration curve of the selected axis (green) Jerk chart Jerk curve of the selected axis (orange) The settings are saved when closed and used the next time the dialog is opened. For example, the zoom factor make only part of the curve visible. Zooms into one part of the time curves Alternative: Ctrl + + Ctrl + Mouse Wheel Zooms out of time curves Alternative: Ctrl + - Ctrl + Mouse Wheel Zooms into the time curves so that the entire CNC paths are displayed Axis Selection of axes: X , Y , Z , A , B , C , A1(P) , A2(Q) , A3 (U) , A4(V) , A5(W) , A6 , or Path Preset: X axis Path axis: Display of path position, path velocity, path acceleration, and path jerk Cycle time [µs] Value for the dwIpoTime input of the SMC_Interpolator function block Preset: Value Cycle time [µs] in object CNC settings (tab Preinterpolation ) Velocity mode Value for the iVelMode input of the SMC_Interpolator function block Trapezoid Trapezoidal velocity profile Sigmoid Like Trapezoid , but rising or falling edges are replaced by sin² functions of the same surface. In this velocity mode, the limiting value is exceeded by approximately a factor of π\/2. Sigmoid limited Like Sigmoid , but the duration for interpolating the path is the same length as in the velocity mode Trapezoid . Default Quadratic Acceleration profile in trapezoidal form with jerk limitation The jerk reaches a maximum value in Maximum jerk [u\/s³] . This results in a quadratic velocity profile. The position profile consists of third-degree polynomials. The result is that the velocity profile consists of parabolas, the acceleration consists of linear segments, and the jerk consists of horizontal line segments. Maximum jerk [u\/s³] Jerk limitation " }, 
{ "title" : "Command: Import from DXF File ", 
"url" : "_sm_cmd_cnc_dxf_import.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Import from DXF File ", 
"snippet" : "Import from DXF File Function : The command opens the default dialog. After selecting the file, the Import DXF file dialog opens for configuring the import of a DXF file into the CNC editor. Call : CNC menu Requirement : A CNC object is open in the editor. Restrictions of the DXF standard at file im...", 
"body" : "Import from DXF File Function : The command opens the default dialog. After selecting the file, the Import DXF file dialog opens for configuring the import of a DXF file into the CNC editor. Call : CNC menu Requirement : A CNC object is open in the editor. Restrictions of the DXF standard at file import SPLINE elements are not imported exactly. Only the control points are read and positioned by these cardinal splines. External references are not supported. (These are references to other DXF files in a BLOCK element.) Ellipses are supported only insofar as they exist in the X\/Y-plane. Arcs (element ARC ) and circles (element CIRCLE ) are supported only when the scaling is equal in all spatial axes (parameters 41, 42, and 43 of the element INSERT ). This also affects the elements POLYLINE and LWPOLYLINE which include arcs (parameter bulge not equal to 0 ). Block references (element INSERT ) are supported only when the scaling matrix is not a mirror. (The product of the scaling factors has to be positive.) Area elements, polygon meshes, and polyface meshes are not supported. Solid elements ( SOLID , …) are also not supported. The elements MLINE (multiline), RAY , XLINE , and LEADER (leader line) are not supported. The elements TEXT , MTEXT , and DIMENSION are not supported. Line width, color, and style are ignored, as well as information about element visibility. Binary DXF files (file extension DXB ) are not supported. Unsupported elements are ignored (implicitly) at import. " }, 
{ "title" : "Dialog: Import DXF File ", 
"url" : "_sm_cmd_cnc_dxf_import.html#UUID-ceb47740-324e-76a2-abd9-2d1fa27e1a26_id_fde6e1824400e36c0a8640e013dba7a_id_754451675df6e481c0a8646326153262", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Import from DXF File \/ Dialog: Import DXF File ", 
"snippet" : "Layers All layers of the technical drawing; determined from the data in the DXF file : The layer will be imported. Maximum gap size Distance between the end points of the geometric elements until where the points are seen as interconnected. Determined from the data in the DXF file. Example: 0.001 Pr...", 
"body" : "Layers All layers of the technical drawing; determined from the data in the DXF file : The layer will be imported. Maximum gap size Distance between the end points of the geometric elements until where the points are seen as interconnected. Determined from the data in the DXF file. Example: 0.001 Preview on CNC path The data of the selected DXF file is displayed in the way that they are imported into the CNC editor. The layer selected for viewing is also taken into consideration. Example: View To switch the layer that is considered in the preview window. x\/y-plane; selected for viewing x\/z-plane y\/z-plane Button ' Import ' The data is loaded into the CNC editor and the existing CNC program is replaced. The block numbers are assigned automatically. The CNC object retains its name. " }, 
{ "title" : "Command: CNC Info ", 
"url" : "_sm_cmd_cnc_info.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: CNC Info ", 
"snippet" : "CNC Info Function : The command opens the CNC information about program <name> dialog. Call : CNC menu Context menu of an object (type CNC program ) Requirement : A CNC program is open in the editor. Dialog: Generated Code The dialog shows the IEC initialization code of the active CNC program, depen...", 
"body" : "CNC Info Function : The command opens the CNC information about program <name> dialog. Call : CNC menu Context menu of an object (type CNC program ) Requirement : A CNC program is open in the editor. Dialog: Generated Code The dialog shows the IEC initialization code of the active CNC program, depending on the compile mode for the function block SMC_OutQueue or SMC_CNC_REF . Example: IEC initialization code {attribute 'linkalways'}\nVAR_GLOBAL\n {attribute 'init_on_onlchange'}\n {attribute 'init_on_onlchange'}\n Example : SMC_CNC_REF := (nElements := 22, strProgramName := 'Example', piStartPosition := (iFrameNo:=0, wAuxData:=7, wSProfile:=0, dX:=0, dY:=0, dZ:=0, dA:=0, dB:=0, dC:=0, dA1:=0, dA2:=0, dA3:=0, dA4:=0, dA5:=0, dA6:=0), pgc := ADR(Example_D), xPartofLM := TRUE);\n {attribute 'blobinit'}\n {attribute 'init_on_onlchange'}\n Example_D : ARRAY[0..21] OF SMC_GCODE_WORD := [\n {p 35184372088832 }\n (byLetter := 78, fValue:=0, diValue:=0),\n {p 35184372088832 }\n (byLetter := 70, fValue:=0, diValue:=0),\n {p 35184372088832 }\n (byLetter := 69, fValue:=100, diValue:=100),\n {p 35184372088832 }\n (byLetter := 69, fValue:=-100, diValue:=-100),\n {p 35184372088832 }\n (byLetter := 128, fValue:=1, diValue:=1),\n {p 36283883716609 }\n (byLetter := 78, fValue:=0, diValue:=0),\n {p 36835250143233 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 38486665068545 }\n (byLetter := 88, pAdr := ADR(g_x), byVarType := ANY_TO_BYTE(__TYPEOF(g_x) + 32)),\n {p 36291399909377 }\n (byLetter := 89, fValue:=0, diValue:=0),\n {p 36842766336001 }\n (byLetter := 70, fValue:=50, diValue:=50),\n {p 36844913819649 }\n (byLetter := 69, fValue:=30, diValue:=30),\n {p 37396817117185 }\n (byLetter := 69, fValue:=-30, diValue:=-30),\n {p 35184372088832 }\n (byLetter := 128, fValue:=2, diValue:=2),\n {p 36833639530498 }\n (byLetter := 78, fValue:=10, diValue:=10),\n {p 36835787014146 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 36288178683906 }\n (byLetter := 88, fValue:=0, diValue:=0),\n {p 38488812552194 }\n (byLetter := 89, pAdr := ADR(g_y), byVarType := ANY_TO_BYTE(__TYPEOF(g_y) + 32)),\n {p 35184372088832 }\n (byLetter := 128, fValue:=3, diValue:=3),\n {p 36833639530499 }\n (byLetter := 78, fValue:=20, diValue:=20),\n {p 36835787014147 }\n (byLetter := 71, fValue:=1, diValue:=1),\n {p 36288178683907 }\n (byLetter := 88, fValue:=0, diValue:=0),\n {p 36289789296643 }\n (byLetter := 89, fValue:=0, diValue:=0)];\nEND_VAR " }, 
{ "title" : "Dialog: CNC Information of <name> Program ", 
"url" : "_sm_cmd_cnc_info.html#UUID-ad8caf78-e0cf-3500-0750-16c2eb5fabe7_id_dc9afe4124423d69c0a8640e01f781e8_id_fc2c1e2959841990c0a864630e5a26e5", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: CNC Info \/ Dialog: CNC Information of <name> Program ", 
"snippet" : "The dialog provides information about the specified CNC program. Program name Example: Workpiece_1 Version of function blocks Example: 4.2.0.0 Number of lines Example: 5 Number of objects Example: 3 Path length [units] Example: 261.803398874992 Duration [s] Time (in seconds) for traveling the prepro...", 
"body" : "The dialog provides information about the specified CNC program. Program name Example: Workpiece_1 Version of function blocks Example: 4.2.0.0 Number of lines Example: 5 Number of objects Example: 3 Path length [units] Example: 261.803398874992 Duration [s] Time (in seconds) for traveling the preprocessed path Example: 10.158 Requirement: Path preprocessing without errors and successfully generated interpolation points Show generated code The Generated Code dialog opens. Requirement: The program contains no errors. " }, 
{ "title" : "Command: Load Program from ASCII File ", 
"url" : "_sm_cmd_cnc_load_program_from_ascii_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Load Program from ASCII File ", 
"snippet" : "Load Program from ASCII File Function : The command loads an ASCII file with CNC program data into the CNC editor. The CNC object retains its name. Call : CNC menu Requirement : A CNC object is open in the editor. The command opens the default dialog for searching the file system. The filter has to ...", 
"body" : "Load Program from ASCII File Function : The command loads an ASCII file with CNC program data into the CNC editor. The CNC object retains its name. Call : CNC menu Requirement : A CNC object is open in the editor. The command opens the default dialog for searching the file system. The filter has to be set to CNC, GCODE, or TXT. The selected file is loaded into the active CNC editor. Any existing CNC program is overwritten (after another query). " }, 
{ "title" : "Command: Move Program ", 
"url" : "_sm_cmd_cnc_move_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Move Program ", 
"snippet" : "Move Program Function : The command opens the Translation vector dialog for configuring a movement of the CNC path. Call : CNC menu Requirement : A CNC path is open in the editor....", 
"body" : "Move Program Function : The command opens the Translation vector dialog for configuring a movement of the CNC path. Call : CNC menu Requirement : A CNC path is open in the editor. " }, 
{ "title" : "Constraint ", 
"url" : "_sm_cmd_cnc_move_program.html#UUID-67135dbc-74ff-3167-05ff-7a200cb0af34_id_f409bfb22439d072c0a8640e01561fb2_id_e69692297289ca8ec0a864631a178469", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Move Program \/ Constraint ", 
"snippet" : "Moving the CNC path is possible under the following conditions: No usage of axis A, B, or C of variables...", 
"body" : "Moving the CNC path is possible under the following conditions: No usage of axis A, B, or C of variables " }, 
{ "title" : "Dialog: Translation Vector ", 
"url" : "_sm_cmd_cnc_move_program.html#UUID-67135dbc-74ff-3167-05ff-7a200cb0af34_id_f409bfb22439d072c0a8640e01561fb2_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Move Program \/ Dialog: Translation Vector ", 
"snippet" : "Translation vector in coordinates for all axes X Default: 1.0000000 Y Z P Q U V W OK This moves the CNC path. In addition, a G0 command (relative positioning command) is inserted with the coordinates of the translation vector in the CNC program before the first positioning command. The positioning c...", 
"body" : "Translation vector in coordinates for all axes X Default: 1.0000000 Y Z P Q U V W OK This moves the CNC path. In addition, a G0 command (relative positioning command) is inserted with the coordinates of the translation vector in the CNC program before the first positioning command. The positioning commands are G1, G2, G3, G5, G6, G8, G9, G10, G11, and G92. If G54, G55, or G56 commands shift the coordinate system in the CNC program, then the arguments are adapted in these commands. The blocks up to G53 no dot require any further adaptation. If a G56 command is the first positioning command, then only that command is adapted. The block numbers are assigned automatically. " }, 
{ "title" : "Command: Renumber CNC Program ", 
"url" : "_sm_cmd_cnc_renumber_cnc_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Renumber CNC Program ", 
"snippet" : "Renumber CNC Program Symbol: Function : The command refreshes the numbering of program lines in the CNC program. Call : CNC menu Requirement : A CNC path is open in the editor. The numbers start at 0 and are incremented by 10. Each block without a block number receives a number. L code in G20 blocks...", 
"body" : "Renumber CNC Program Symbol: Function : The command refreshes the numbering of program lines in the CNC program. Call : CNC menu Requirement : A CNC path is open in the editor. The numbers start at 0 and are incremented by 10. Each block without a block number receives a number. L code in G20 blocks is corrected. " }, 
{ "title" : "Command: Invert Direction ", 
"url" : "_sm_cmd_cnc_reverse_direction.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Invert Direction ", 
"snippet" : "Invert Direction Function : The command reverses the CNC program and sets the path elements in reverse order. The block numbers of the CNC program are also reset automatically. Call : CNC menu Requirement : A CNC path is open in the editor. Constraint Reversing the CNC path is possible under the fol...", 
"body" : "Invert Direction Function : The command reverses the CNC program and sets the path elements in reverse order. The block numbers of the CNC program are also reset automatically. Call : CNC menu Requirement : A CNC path is open in the editor. Constraint Reversing the CNC path is possible under the following conditions: If preprocessing was selected for the CNC program, then the G41\/G42 blocks are processed in the reverse program: G41 becomes G42 and G42 becomes G41. The direction of the correction is also reversed. If the CNC program contains arcs that are defined with an opening angle (parameter K for 2D elements or parameter T for 3D elements), then the command does not generate exact reversed arcs. If the CNC path was programmed by the following means, then reversing is not possible. No reversing when Using axis A, B, or C Using Variables Calling step suppression " }, 
{ "title" : "Command: Rotate Program ", 
"url" : "_sm_cmd_cnc_rotate_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Rotate Program ", 
"snippet" : "Rotate Program Function : The command opens the Rotation parameters dialog where the rotation of the CNC path is configured. Call : CNC menu Requirement : A CNC path is open in the editor....", 
"body" : "Rotate Program Function : The command opens the Rotation parameters dialog where the rotation of the CNC path is configured. Call : CNC menu Requirement : A CNC path is open in the editor. " }, 
{ "title" : "Constraint ", 
"url" : "_sm_cmd_cnc_rotate_program.html#UUID-b9a9e82f-9e38-05fb-3bf2-345a94e26b09_id_b540ec0a8640e01ab500e_id_45841f775e56fd50c0a864632eb28d67", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Rotate Program \/ Constraint ", 
"snippet" : "Rotating the CNC path is possible under the following conditions: No usage of axis A, B, or C of variables...", 
"body" : "Rotating the CNC path is possible under the following conditions: No usage of axis A, B, or C of variables " }, 
{ "title" : "Dialog: Rotation Parameters ", 
"url" : "_sm_cmd_cnc_rotate_program.html#UUID-b9a9e82f-9e38-05fb-3bf2-345a94e26b09_id_b540ec0a8640e01ab500e_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Rotate Program \/ Dialog: Rotation Parameters ", 
"snippet" : "Angle (degrees) Angle of rotation (in degrees) about the Rotary axis . Example: Given Rotation about the Z-axis The X-axis points to the right, and the Y-axis points downwards. The viewing direction is against the rotary axis (right-hand rule). For a negative value, rotation is performed clockwise. ...", 
"body" : "Angle (degrees) Angle of rotation (in degrees) about the Rotary axis . Example: Given Rotation about the Z-axis The X-axis points to the right, and the Y-axis points downwards. The viewing direction is against the rotary axis (right-hand rule). For a negative value, rotation is performed clockwise. For a positive value, rotation is performed counterclockwise. Axis of rotation Selecting a rotary axis is possible only if the elements of the CNC path are all 3D elements. No selection if the CNC path of one of the following elements includes: G5 spline Parabola Ellipse 2D arc The rotary axis is defined by the parameters X , Y , and Z . Default: X : 0, Y : 0, Z : 1 --> rotation about the Z-axis X Default: 0.00000 Y Default: 0.00000 Z Default: 1.00000 OK The rotation is executed. The block numbers are assigned automatically. " }, 
{ "title" : "Command: Scale Program ", 
"url" : "_sm_cmd_cnc_scale_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Scale Program ", 
"snippet" : "Scale Program Function : The command opens the Scale program dialog where the scaling of the CNC path is configured. Call : CNC menu Requirement : A CNC path is open in the editor....", 
"body" : "Scale Program Function : The command opens the Scale program dialog where the scaling of the CNC path is configured. Call : CNC menu Requirement : A CNC path is open in the editor. " }, 
{ "title" : "Constraint ", 
"url" : "_sm_cmd_cnc_scale_program.html#UUID-d8f93f90-76cd-f349-684b-7ab5ca0dd141_id_fc67fe112446a403c0a8640e01ee1047_id_1320e28c7289c9f2c0a864633d064770", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Scale Program \/ Constraint ", 
"snippet" : "Scaling the CNC path is possible under the following conditions: No usage of axis A, B, or C of variables...", 
"body" : "Scaling the CNC path is possible under the following conditions: No usage of axis A, B, or C of variables " }, 
{ "title" : "Dialog: Scale Program ", 
"url" : "_sm_cmd_cnc_scale_program.html#UUID-d8f93f90-76cd-f349-684b-7ab5ca0dd141_id_fc67fe112446a403c0a8640e01ee1047_id_de9e4bb65e56fd50c0a8646304176b42", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Scale Program \/ Dialog: Scale Program ", 
"snippet" : "Scaling factor Default: 0.001 Condition: Scaling factor >= 1e-3 For a scaling factor > 1, it is upscaled. Axes : The axis is scaled. D (tool radius) : The tool radius D is scaled. OK The scaling is performed. The block numbers are assigned automatically....", 
"body" : "Scaling factor Default: 0.001 Condition: Scaling factor >= 1e-3 For a scaling factor > 1, it is upscaled. Axes : The axis is scaled. D (tool radius) : The tool radius D is scaled. OK The scaling is performed. The block numbers are assigned automatically. " }, 
{ "title" : "Command: Scroll Path View ", 
"url" : "_sm_cmd_cnc_scroll_path_view.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Scroll Path View ", 
"snippet" : "Scroll Path View Function : The command activates and deactivates the scrolling of the CNC path. Call : CNC menu Requirement : A CNC path is open in the editor. If scrolling is activated, then the view of the CNC path is scrolled and zoomed in the graphical editor so that a path element that is sele...", 
"body" : "Scroll Path View Function : The command activates and deactivates the scrolling of the CNC path. Call : CNC menu Requirement : A CNC path is open in the editor. If scrolling is activated, then the view of the CNC path is scrolled and zoomed in the graphical editor so that a path element that is selected in the CNC program is completely visible. " }, 
{ "title" : "Command: Set Variables ", 
"url" : "_sm_cmd_cnc_set_offline_variables.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Set Variables ", 
"snippet" : "Set Variables Function : The command opens the Offline values of variables dialog. The variables of the CNC program can be defined here for offline mode. Call : CNC menu Requirement : A CNC path is open in the editor....", 
"body" : "Set Variables Function : The command opens the Offline values of variables dialog. The variables of the CNC program can be defined here for offline mode. Call : CNC menu Requirement : A CNC path is open in the editor. " }, 
{ "title" : "Dialog: Offline Values of Variables ", 
"url" : "_sm_cmd_cnc_set_offline_variables.html#UUID-101f0c28-cef6-51dc-ec33-33b8d27ee9c8_id_c97aba1d244400ffc0a8640e01a5ad6c_id_d54502d95df6e2f6c0a8646351ba116d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Set Variables \/ Dialog: Offline Values of Variables ", 
"snippet" : "Variable Variable of the CNC program Example: G_X If the variable is shown in gray italics, then it is not being used in the CNC program. Value Configured offline value Example: 100 Set to online values The values are overwritten with the values that are currently assigned in the application. Requir...", 
"body" : "Variable Variable of the CNC program Example: G_X If the variable is shown in gray italics, then it is not being used in the CNC program. Value Configured offline value Example: 100 Set to online values The values are overwritten with the values that are currently assigned in the application. Requirement: The command is available it the application is running and the CNC editor is in online mode. Then it is possible to load the online values. OK If the values are valid, then they are applied in the CNC program and the path of the editor is refreshed. " }, 
{ "title" : "Command: Show End Points ", 
"url" : "_sm_cmd_cnc_show_end_points.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Show End Points ", 
"snippet" : "Show End Points Function : The command activates and deactivates the display of the CNC path points. Call : CNC menu Requirement : A CNC path is open in the editor. If the display is activated, then all path elements are provided with end points....", 
"body" : "Show End Points Function : The command activates and deactivates the display of the CNC path points. Call : CNC menu Requirement : A CNC path is open in the editor. If the display is activated, then all path elements are provided with end points. " }, 
{ "title" : "Command: Show Grid ", 
"url" : "_sm_cmd_cnc_show_grid.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Show Grid ", 
"snippet" : "Show Grid Symbol: Function : The command activates and deactivates the display of a grid in the graphical editor. Call : CNC menu Requirement : A CNC path is open in the editor. The zoom factor determines the spacing of the grid lines. Expanding the path determines the grid size....", 
"body" : "Show Grid Symbol: Function : The command activates and deactivates the display of a grid in the graphical editor. Call : CNC menu Requirement : A CNC path is open in the editor. The zoom factor determines the spacing of the grid lines. Expanding the path determines the grid size. " }, 
{ "title" : "Command: Show Interpolation Points ", 
"url" : "_sm_cmd_cnc_show_interpolation_points.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Show Interpolation Points ", 
"snippet" : "Show Interpolation Points Symbol: Function : The command activates and deactivates the display of interpolation points. Call : CNC menu Requirement : A CNC path is open in the editor. If the display of interpolation points is activated, then the CNC path is displayed with interpolation points. The c...", 
"body" : "Show Interpolation Points Symbol: Function : The command activates and deactivates the display of interpolation points. Call : CNC menu Requirement : A CNC path is open in the editor. If the display of interpolation points is activated, then the CNC path is displayed with interpolation points. The cycle time, which is set in the dialog of the CNC settings on the Preinterpolation tab is used to determine the interpolation points. In addition, this function determines whether or not a CNC path is displayed with preprocessing in the editor. " }, 
{ "title" : "Display in the graphical editor ", 
"url" : "_sm_cmd_cnc_show_interpolation_points.html#UUID-043dd64e-e07a-5e2b-2f1d-fc2a843ef4b7_id_be380e1242fa185c0a8640e005adee9_id_d6d5fcd172c9c53cc0a864633c37464d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Show Interpolation Points \/ Display in the graphical editor ", 
"snippet" : "An interpolation point is displayed with a line perpendicular to the direction of motion. The length of the line is proportional to the current path velocity. This makes it possible for a rough estimate of the behavior of the velocity. Larger distance and long line High velocity Smaller distance and...", 
"body" : "An interpolation point is displayed with a line perpendicular to the direction of motion. The length of the line is proportional to the current path velocity. This makes it possible for a rough estimate of the behavior of the velocity. Larger distance and long line High velocity Smaller distance and short line Low velocity Red The interpolator is decelerated. Green The interpolator is accelerated. Gray The interpolator has a constant velocity. " }, 
{ "title" : "Command: Step Suppression ", 
"url" : "_sm_cmd_cnc_step_suppression.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Step Suppression ", 
"snippet" : "Step Suppression Symbol: Function : The command activates and deactivates the step suppression. Call : CNC menu Requirement : A CNC path is open in the editor. The CNC program is implemented as DIN66025. If step suppression is activated, then blocks in the CNC program that begin with \/ are ignored. ...", 
"body" : "Step Suppression Symbol: Function : The command activates and deactivates the step suppression. Call : CNC menu Requirement : A CNC path is open in the editor. The CNC program is implemented as DIN66025. If step suppression is activated, then blocks in the CNC program that begin with \/ are ignored. If the CNC program is implemented as a table, then the command is not available. " }, 
{ "title" : "Command: Write Program to ASCII File ", 
"url" : "_sm_cmd_cnc_write_program_to_ascii_file.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Write Program to ASCII File ", 
"snippet" : "Write Program to ASCII File Function : The command opens the default dialog for saving a file to the file system. The CNC program can be saved as an ASCII file. Call : CNC menu Requirement : A CNC path is open in the editor. Name Default: Name of the CNC object Example: cncSpiral_A File type File ex...", 
"body" : "Write Program to ASCII File Function : The command opens the default dialog for saving a file to the file system. The CNC program can be saved as an ASCII file. Call : CNC menu Requirement : A CNC path is open in the editor. Name Default: Name of the CNC object Example: cncSpiral_A File type File extension: TXT , GCODE , CNC " }, 
{ "title" : "Command: Show preprocessed Path ", 
"url" : "_sm_cmd_cnc_show_preprocessed_path.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Command: Show preprocessed Path ", 
"snippet" : "Show preprocessed Path Symbol: Function : The command activates and deactivates the display of the CNC path with preprocessing. Call : CNC menu Requirement : A CNC path is open in the editor. If the display is active, then the path is displayed with preprocessing and the original path is displayed i...", 
"body" : "Show preprocessed Path Symbol: Function : The command activates and deactivates the display of the CNC path with preprocessing. Call : CNC menu Requirement : A CNC path is open in the editor. If the display is active, then the path is displayed with preprocessing and the original path is displayed in light gray in the background. The preprocessing is configured in the CNC settings dialog ( Path preprocessing tab). The preprocessing configured there is displayed. Then you can simulate the effect of the different function blocks (in series) on the preprocessing. The command does not have any effect on code generation. Even if an SMC_OutQueue file structure is generated when compiling the CNC program, the command does not have any effect on the contents of the file. The preprocessing is always taken into consideration when compiling. " }, 
{ "title" : "Object: CNC Program ", 
"url" : "_sm_f_reference_object_cnc_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Object: CNC Program ", 
"snippet" : "CNC Program...", 
"body" : "CNC Program " }, 
{ "title" : "Overview ", 
"url" : "_sm_f_reference_object_cnc_program-1561724.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Object: CNC Program \/ Overview ", 
"snippet" : "CODESYS provides the capability of creating CNC programs in two different editors: The editor for DIN 66025 and the tabular editor. Both editors display a graphical view of the programmed path. Although programming can be exchanged between the editors, this can lead to information losses. The indivi...", 
"body" : "CODESYS provides the capability of creating CNC programs in two different editors: The editor for DIN 66025 and the tabular editor. Both editors display a graphical view of the programmed path. Although programming can be exchanged between the editors, this can lead to information losses. The individual editors provide different handling of elements. Element Editor for DIN 66025 Tabular Editor Positioning X X Line X X Arc X X Ellipse X X Spline X X Rapid positioning X X M Function X X Parabola X Using Variables X Jump X Coordinate shift X Step Suppression X Dwell Time X Timing Synchronization with Interpolator X For more information, see: Tabular Editor and Editor for DIN 66025" }, 
{ "title" : "Tabular Editor ", 
"url" : "_sm_obj_cnc_program_table.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Object: CNC Program \/ Tabular Editor ", 
"snippet" : "In the tabular editor, the path commands are listed in a table. On the Tabular Editor tab, in the CNC Settings , you can customize the columns of this table. The CNC Settings are located as an object in the device tree. By default, the properties of the selected path element are displayed on the rig...", 
"body" : "In the tabular editor, the path commands are listed in a table. On the Tabular Editor tab, in the CNC Settings , you can customize the columns of this table. The CNC Settings are located as an object in the device tree. By default, the properties of the selected path element are displayed on the right side of the table. These cannot be edited there. When you select a line, the respective motion path is drawn in the graphical editor. The element type determines which specific properties of a path element can be changed. Non-editable parameters are shaded out. Pressing the F6 key toggles the focus to the graphical editor and back. For an overview of the elements supported by this editor, see the CNC Program chapter. For more information, see: Programming a Path in the Tabular Editor and Graphical Editor" }, 
{ "title" : "Editor for DIN 66025 ", 
"url" : "_sm_obj_cnc_program_din66025.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Object: CNC Program \/ Editor for DIN 66025 ", 
"snippet" : "In this editor, you specify the path elements as a CNC program according to DIN 66025 . By default, the properties of the selected path element are displayed on the right side. However, they cannot be modified there. When you select a line, the respective motion path is drawn in the graphical editor...", 
"body" : "In this editor, you specify the path elements as a CNC program according to DIN 66025 . By default, the properties of the selected path element are displayed on the right side. However, they cannot be modified there. When you select a line, the respective motion path is drawn in the graphical editor. Pressing the F6 key toggles the focus to the graphical editor and back. For an overview of the elements supported by this editor, see the CNC Program chapter. Note that references of global variables are evaluated in the decoder module when the interpreter is processing the blocks. This can happen a few cycles in advance before the object travels. For more information, see: Programming a Path according to DIN 66025 and CNC Settings" }, 
{ "title" : "Graphical Editor ", 
"url" : "_sm_obj_cnc_program_graphical.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Object: CNC Program \/ Graphical Editor ", 
"snippet" : "The graphical editor is located in the lower part of the CNC tabular editor and the editor for DIN 66025. The editor is used to display the programmed CNC program. The editor provides tools for modifying and extending the path. Structure of the editor (1): Tabular editor or editor according to DIN 6...", 
"body" : "The graphical editor is located in the lower part of the CNC tabular editor and the editor for DIN 66025. The editor is used to display the programmed CNC program. The editor provides tools for modifying and extending the path. Structure of the editor (1): Tabular editor or editor according to DIN 66025 (2): Property view: Shows the properties of the selected path element (3): Graphical editor (4): Control panel: Elements for controlling the camera position and viewing direction (5): Tools for modifying the path Notes about working with the graphical editor The selected path element is displayed in red. The positioning commands (G0) and switch point functions are displayed in green. If the end point of an element is movable, then it is displayed as a small black outlined circle. The start and end tangents are displayed in gray. The current position of the selected path element is displayed in the status bar. Note the CNC menu commands for scaling and moving the entire path. Note the sample programs included in the installation of CODESYS SoftMotion . " }, 
{ "title" : "Tools ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_0ffa6b2d9c1625bec0a8646341693b76", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Object: CNC Program \/ Graphical Editor \/ Tools ", 
"snippet" : "You can use tools to modify and extend motion paths in the graphical editor. The changes are visible simultaneously in the text editor and tabular editor. Select : This tool selects a point or a path element. The element is then displayed in red with a blue starting point. The mouse pointer in the g...", 
"body" : "You can use tools to modify and extend motion paths in the graphical editor. The changes are visible simultaneously in the text editor and tabular editor. Select : This tool selects a point or a path element. The element is then displayed in red with a blue starting point. The mouse pointer in the graphical editor changes into a pointer. Line : Adds or inserts a new line. The mouse pointer in the graphical editor changes into a cross. Insert circle (clockwise) : Adds or inserts a new arc (clockwise). The mouse pointer in the graphical editor changes into a cross. Insert circle (counterclockwise) : Adds or inserts a new arc (counterclockwise). The mouse pointer in the graphical editor changes into a cross. Spline : Adds or inserts a new spline point. The mouse pointer in the graphical editor changes into a cross. " }, 
{ "title" : "Camera position and viewing direction ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_05ff18059c1625bec0a864634ba4f71d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Object: CNC Program \/ Graphical Editor \/ Camera position and viewing direction ", 
"snippet" : "You can use the mouse to modify the position and camera perspective on the program path in any way. Left mouse button pressed + mouse movement: Moves the camera position along the axes in the display plane. Right mouse button pressed + mouse movement: Rotates the view on the CNC program. Ctrl + Mous...", 
"body" : "You can use the mouse to modify the position and camera perspective on the program path in any way. Left mouse button pressed + mouse movement: Moves the camera position along the axes in the display plane. Right mouse button pressed + mouse movement: Rotates the view on the CNC program. Ctrl + Mouse wheel : Changes the zoom factor. " }, 
{ "title" : "Operating panel for display control ", 
"url" : "_sm_obj_cnc_program_graphical.html#UUID-1e183ac7-1088-1574-2350-b5e8ac517c15_id_c9b99bbebc09c0a8646342d4b20b_id_4693d34dba46042bc0a864633b130501", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Object: CNC Program \/ Graphical Editor \/ Operating panel for display control ", 
"snippet" : "In the upper left corner of the graphical editor, an operating panel provides various commands for changing the view of the path. The path is not modified in the process. Instead, only the camera position and camera perspective are changed. You can collapse the control panel by clicking the black ar...", 
"body" : "In the upper left corner of the graphical editor, an operating panel provides various commands for changing the view of the path. The path is not modified in the process. Instead, only the camera position and camera perspective are changed. You can collapse the control panel by clicking the black arrow in order to maximize the size of the editor workspace. Clicking again expands the control panel. The control panel provides the following commands for setting the orientation, position, and zoom. Zoom in Zoom out Change the camera pitch (clockwise) Change the camera pitch (counterclockwise) Change the camera yaw (clockwise) Change the camera yaw (counterclockwise) Rotate the camera (clockwise) Rotate the camera (counterclockwise) Move camera upwards Move camera to the left Move camera to the right Move camera downwards Set the direction of view to the negative z-axis and rescale Set the direction of view to the x-axis and rescale Set the direction of view to the y-axis and rescale " }, 
{ "title" : "Dialog: CNC properties ", 
"url" : "_sm_dlg_cnc_program_properties.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Object: CNC Program \/ Dialog: CNC properties ", 
"snippet" : "Symbol: Function : The dialog provides parameters for the CNC Program object. Call : View → Properties command; context menu of the object Requirement : The CNC object is selected in the device tree. Application-wide CNC settings are saved in the CNC Settings object....", 
"body" : "Symbol: Function : The dialog provides parameters for the CNC Program object. Call : View → Properties command; context menu of the object Requirement : The CNC object is selected in the device tree. Application-wide CNC settings are saved in the CNC Settings object. " }, 
{ "title" : "Tab: General ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_e398c87e5062d26bc0a86520014051d1", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Object: CNC Program \/ Dialog: CNC properties \/ Tab: General ", 
"snippet" : "Change the name of the CNC object....", 
"body" : "Change the name of the CNC object. " }, 
{ "title" : "Tab: Access Control ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_6f1287e45062d25bc0a865200009f33d", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Object: CNC Program \/ Dialog: CNC properties \/ Tab: Access Control ", 
"snippet" : "Here you specify the permissions of the user groups. For more information, see: Properties – Access Control...", 
"body" : "Here you specify the permissions of the user groups. For more information, see: Properties – Access Control " }, 
{ "title" : "Tab: Build ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_18be1ff163875181c0a865ca014256df", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Object: CNC Program \/ Dialog: CNC properties \/ Tab: Build ", 
"snippet" : "Activate the option to exclude the CNC object from the build. Then IEC data is not generated. However, it is possible to save the G code as an ASCII file. For reading this kind of file at runtime, you can use the function blocks from the SM3_CNC library. For more information, see: Properties – Acces...", 
"body" : "Activate the option to exclude the CNC object from the build. Then IEC data is not generated. However, it is possible to save the G code as an ASCII file. For reading this kind of file at runtime, you can use the function blocks from the SM3_CNC library. For more information, see: Properties – Access Control " }, 
{ "title" : "Tab: CNC ", 
"url" : "_sm_dlg_cnc_program_properties.html#UUID-6f92e38a-39c8-0caa-b821-76b78b126203_id_a1d2906d9c2e4d16c0a8646340e065e2_id_98733dd8635a8e3dc0a8640e011b6259", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Object: CNC Program \/ Dialog: CNC properties \/ Tab: CNC ", 
"snippet" : "Implementation Din66025 : The motion path is defined in the CNC language DIN 66025. Table : The motion path is defined by means of the parameterization of a table. Compile mode Behavior on compile SMC_OutQueue : An SMC_OutQueue data structure is generated on compile. You are granted global access by...", 
"body" : "Implementation Din66025 : The motion path is defined in the CNC language DIN 66025. Table : The motion path is defined by means of the parameterization of a table. Compile mode Behavior on compile SMC_OutQueue : An SMC_OutQueue data structure is generated on compile. You are granted global access by means of g_CNCQueueManager . SMC_CNC_REF : Program variables are generated on compile. You are granted global access by means of g_CNCProgManager . File : A file generated by G code is downloaded and updated at each login. The PLC can download this file by means of function blocks. The G code files are updated each time at each login to the application. This meas that the files on the PLC are overwritten at each login. File name Requirement: Compile mode is set to File . Default: $ObjectName$.cnc . This default value is a placeholder which is replaced by the object name of the CNC object (effective file name) at login. Only the characters [a-zA-Z0-9$_.] are permitted in a file name. The field for the file name must not be blank or start or end with a dot. Moreover, a dot does not have to be part of the path in the file name. Queue size [elements] Default: 100 The size setting does not affect the size of the generated SMC_OutQueue data structure (when this mode is selected). The size of SMC_OutQueue is determined only by the number of path objects. However, the parameter sets the buffer size of the preprocessing FBs (for example, SMC_NCDecoder , SMC_RoundPath ) which are used internally and define the size of the lookahead buffer. Default values Velocity (F) [u\/s] This value is used when the value of the velocity (in the \"F\" word) is not set in the CNC program. In path units per second. Value range: [0, 1e9]. Default: 0 Acceleration (E+) [u\/s²] This value is used when the value of the acceleration (in the \"E\" word with a positive value) is not set. In path units per second squared. Value range: ]0, 1e9]. Default: 100 Deceleration (E-) [u\/s²] This value is used when the value of the deceleration (in the \"E\" word with a negative value) is not set. In path units per second squared. Value range: ]0, 1e9]. Default: 100 Default values for fast forward (G0) Velocity (FF) [u\/s] This value is used if the velocity for rapid positioning (\"FF\" word) is not set in the CNC program. In path units per second. Value range: [0, 1e9]. Default: 0 Acceleration (EF+) [u\/s²] This value is used if the acceleration for rapid positioning (\"EF+\" word with a positive value) is not set. In path units per second squared. Value range: [0, 1e9]. Default: 0 Deceleration (EF-) [u\/s²] This value is used if the deceleration for rapid positioning (\"EF-\" word with a negative value) is not set. In path units per second squared. Value range: [0, 1e9]. Default: 0 3D-Mode Requirement: Implementation Din66025 , translation mode CNC_REF , and OUTQueue : 3D mode is the default value. Offline values of variables Variables : If offline values are defined, then the Offline Values of Variables dialog opens. In this dialog, variables are displayed which can also be edited. Start position Default: 0 Precision The accuracy of the path in technical units. This value specifies the accuracy of the positions which are read from the G code. For example, if the G code is specified with 3 decimal places, then the accuracy should be set to 0.001 units. The accuracy must not be negative. This value is used, for example, by path preprocessing such as SMC_ToolRadiusCorr and SMC_AvoidLoop . " }, 
{ "title" : "Object: CNC Settings ", 
"url" : "_sm_obj_cnc_settings.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Object: CNC Settings ", 
"snippet" : "CNC Settings Symbol: The settings in this object are valid for all CNC objects of the application. The object is added to the device tree of the application or it is generated automatically when a CNC object is added to the application. The object may exist only one time per application and cannot b...", 
"body" : "CNC Settings Symbol: The settings in this object are valid for all CNC objects of the application. The object is added to the device tree of the application or it is generated automatically when a CNC object is added to the application. The object may exist only one time per application and cannot be renamed. In the editor of the object, settings can be specified for the path preprocessing modules, preinterpolation, and CNC tabular editor. You can delete the CNC settings object only if no CNC object exists below the application. Settings that are valid only for a specific CNC program are saved in the Settings dialog of the CNC program. " }, 
{ "title" : "Tab: Path preprocessors ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_id_e55a0b19a1678229c0a8646353e40d98_id_de809dbaa55775c9c0a8646311985883", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Object: CNC Settings \/ Tab: Path preprocessors ", 
"snippet" : "On this tab, the path preprocessing is programmed by selecting the function blocks. Available function blocks List of all available function blocks Active function block instances List of the selected function block instances The position in the list defines the processing order and can be changed. ...", 
"body" : "On this tab, the path preprocessing is programmed by selecting the function blocks. Available function blocks List of all available function blocks Active function block instances List of the selected function block instances The position in the list defines the processing order and can be changed. A function block can be instantiated in the list multiple times. Parameters Opens the Parameter editor for <selected active function block instance> dialog Alternative: Double-click an active function block instance Adds an instance of the function block to the Active function block instances that is selected in Active function block instances Deletes the selected function block instance Function block instances of function blocks, which are displayed in light-gray italics, cannot be deleted. Moves the selected active function block instance upwards by one line Alternative: Press Shift + Arrow up Moves the selected active function block instance downwards by one line Alternative: Press Shift + Arrow down Parameter editor for <selected active function block instance> Dialog The dialog is used for displaying and changing the inputs of the selected instance. Not all inputs are visible. Spalte1 Name of the parameter of the selected active function block instance Spalte2 List box for setting the value Spalte3 Description of the parameter " }, 
{ "title" : "Tab: Preinterpolation ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_id_e55a0b19a1678229c0a8646353e40d98_id_9a258724a55775c9c0a8646350128da9", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Object: CNC Settings \/ Tab: Preinterpolation ", 
"snippet" : "Cycle time µs Interpolation time Initial value: 20000 Velocity mode Trapezoid : Velocity profile with trapezoidal shape Sigmoidal : Velocity profile like the trapezoidal profile but with sin² functions that replace the linear velocity ramp Sigmoid limited : Velocity profile like the sigmoidal profil...", 
"body" : "Cycle time µs Interpolation time Initial value: 20000 Velocity mode Trapezoid : Velocity profile with trapezoidal shape Sigmoidal : Velocity profile like the trapezoidal profile but with sin² functions that replace the linear velocity ramp Sigmoid limited : Velocity profile like the sigmoidal profile but with consideration of the limits for acceleration and deceleration Quadratic : Acceleration profile with trapezoidal shape with jerk limitation as defined in Maximum jerk . The resulting quadratic velocity profile is also recognized as an S curve. Quadratic (smooth) : Works like Quadratic mode but generates a jerk profile without jumps. Maximum jerk [u\/s³] Limitation of the absolute value of the jerk Used for quadratic velocity profile only The interpolation time and cycle time of the respective task, in which the interpolator is called, has to match for identical behavior of the CNC editor and online application. " }, 
{ "title" : "Tab: Tabular Editor ", 
"url" : "_sm_obj_cnc_settings.html#UUID-d9a82079-5340-fa0d-d359-dbb07184282a_section-idm43260108321858", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion CNC \/ User Interface \/ Object: CNC Settings \/ Tab: Tabular Editor ", 
"snippet" : "The columns of the tabular editor and its order are defined on this tab. Table columns List of all available attributes : The attribute is visible in the tabular editor. The order in this list determines the line order in the tabular editor. Moves the selected attribute upwards by one line Moves the...", 
"body" : "The columns of the tabular editor and its order are defined on this tab. Table columns List of all available attributes : The attribute is visible in the tabular editor. The order in this list determines the line order in the tabular editor. Moves the selected attribute upwards by one line Moves the selected attribute downwards by one line " }, 
{ "title" : "CODESYS SoftMotion Robotics ", 
"url" : "_sm_f_robotics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Overview ", 
"url" : "_sm_overview_robotics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Overview ", 
"snippet" : "CODESYS SoftMotion Robotics provides a function block interface for motion control of robots, which is based on the PLCopen specification \"Function blocks for motion control Part 4\". Complex movement sequences can be composed of simple point-to-point or continuous path movements, such as straight li...", 
"body" : "CODESYS SoftMotion Robotics provides a function block interface for motion control of robots, which is based on the PLCopen specification \"Function blocks for motion control Part 4\". Complex movement sequences can be composed of simple point-to-point or continuous path movements, such as straight lines or circular arcs. Configurable blending is possible between the individual movements (for example, based on distance or velocity). Velocity, acceleration, and jerk limits, both of the individual axes and on the path, are taken into account. Trajectory planning is done online on the CODESYS controller, parallel to the execution of the movement. New movements can be added at processing time and without stopping the robot. The scope of delivery includes kinematic models for different standard robots, from simple gantries, to delta and SCARA robots and typical six-axis industrial robots. Custom kinematic models for special machines can be linked in the form of an IEC 61131-3 function block. Similarly, dynamic models can be used via an interface to limit the occurring forces and torques and enable the torque feed forward control. Other function blocks are used to easily implement typical use cases. This includes synchronization with moving coordinate systems, interrupting and resuming movements, or controlling high-precision digital outputs via triggers. " }, 
{ "title" : "Getting Started ", 
"url" : "_sm_robotics_first_steps.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Getting Started ", 
"snippet" : "To program the axis movements for a robot, you first need to create an axis group below the application in your project. For more information about this, see: How to Create an Axis Group. You configure the created axis group with the desired kinematics. You insert real or virtual axes below the devi...", 
"body" : "To program the axis movements for a robot, you first need to create an axis group below the application in your project. For more information about this, see: How to Create an Axis Group. You configure the created axis group with the desired kinematics. You insert real or virtual axes below the device and link these axes to the axis group. For more information, see the help pages in Kinematics: Axis Group StatesCombination of Position and Orientation KinematicsRotary Joints and Modulo AxesRotary Axes with a Value Range over 360°How to create a program for the axis control after creating and configuring the axes is shown here as an example: How to Create a Program for Controlling the Axis GroupFor information about how to implement the various motion control demands, see the additional help pages in Motion Control . Buffering and Blending of MovementsJogging of Axis GroupsInterruption and Continuation of MovementsSynchronization with a Moving Coordinate SystemConfiguring a Tool OffsetBackground information for understanding how specific movements are performed can be found here: Orientation Interpolation for CP MovementsFor advanced users: Torque Limitation and Torque Feed Forward ControlCreating Custom Kinematics" }, 
{ "title" : "Axis Group ", 
"url" : "_sm_robotics_axis_group.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Axis Group ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "How to Create an Axis Group ", 
"url" : "_sm_creating_an_axis_group.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Axis Group \/ How to Create an Axis Group ", 
"snippet" : "Adding objects to the device tree The following steps describe how to create and configure an axis group. Create a new standard project with CODESYS Control . For the POU PLC_PRG , select the CFC implementation language. In the device tree, open the context menu of the Device object and select the E...", 
"body" : "Adding objects to the device tree The following steps describe how to create and configure an axis group. Create a new standard project with CODESYS Control . For the POU PLC_PRG , select the CFC implementation language. In the device tree, open the context menu of the Device object and select the Enable SoftMotion command. A SoftMotion General Axis Pool object is inserted below the Device . In the device tree, select SoftMotion General Axis Pool . In the context menu, click Add Device . The Add Device dialog opens. Select the SM_Drive_Virtual device. Specify the name of the device as \"DriveX\". In the same way, insert two more drives named \"DriveY\" and \"DriveZ\" . In the device tree, open the context menu of the Application object and click Projekt → Add Object → Axis Group . Insert the object with the specified name AxisGroup . The Axis group object is inserted below the application. The axis group configurator opens. In the configuration editor, click the Select kinematics button. The Select kinematics dialog opens with a list of all available kinematic configurations and their descriptions. Select the TRAFO.Kin_Gantry3 kinematic configuration. The configuration editor for the selected kinematic configuration opens. In the Mapping to axes parameter group, map the axes to the drives used in the project. To do this, specify the value DriveX in the X input field, the value DriveY in the Y input field, and the value DriveZ in the Z input field. You can also use the Input Assistant to select the drive or drag it from the device tree into the input field. For more information, see: Axis Group Editor" }, 
{ "title" : "Axis Group Editor ", 
"url" : "_sm_obj_axis_group.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Axis Group \/ Axis Group Editor ", 
"snippet" : "Symbol: In the editor of the Axis group object, select the type of basic kinematics and orientation kinematics. Orientation kinematics can be selected only when it is supported by the basic kinematics. In addition, you map the axes of the kinematics to the drives in your project. Kinematics Select k...", 
"body" : "Symbol: In the editor of the Axis group object, select the type of basic kinematics and orientation kinematics. Orientation kinematics can be selected only when it is supported by the basic kinematics. In addition, you map the axes of the kinematics to the drives in your project. Kinematics Select kinematics Change kinematics Opens a list of all kinematics which are supported by CODESYS When you select a type of kinematics, a short description is shown in the frame to the right of the list. After you select a type of kinematics, you can modify the respective parameters in the editor. Orientation kinematics Select kinematics Change kinematics Opens a list of all orientation kinematics that are supported by CODESYS When you select a type of kinematics, a short description is shown in the frame to the right of the list. After you select a type of kinematics, you can modify the respective parameters in the editor. Axis mapping Depending on the selected kinematics, you map the axes of the kinematics to the drives in your project. Additional axes Add Axis Adds a configuration field for an additional axis. The drive from the project is entered in this configuration field. Tasks Bus cycle task Bus cycle task of the axes, if axes are already mapped The setting cannot be changed here. Planning task Task for the planning of CP tasks A planning task is created automatically when the first axis group is inserted. A watchdog should not be configured because the execution time may fluctuate considerably. For more information, see the following: Configuration of the Planning TaskIf you delete this task, then an error is issued to the message view. To create a new task, click Project → Create planning task . For more information, see the following: How to Create an Axis Group" }, 
{ "title" : "Axis Group States ", 
"url" : "_sm_robotics_state_machine.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Axis Group \/ Axis Group States ", 
"snippet" : "The image below shows the possible states for axis groups and the transitions between the states. The errors of individual axes always direct the axis group to the GroupErrorStop state. If the axis group switches to GroupMoving , then all axes are switched to SynchronizedMotion . If the axis group s...", 
"body" : "The image below shows the possible states for axis groups and the transitions between the states. The errors of individual axes always direct the axis group to the GroupErrorStop state. If the axis group switches to GroupMoving , then all axes are switched to SynchronizedMotion . If the axis group switches from GroupMoving to GroupStandby , then all axes are switched to standstill . If the axis group switches from GroupMoving to GroupErrorStop , then all axes are switched to GroupErrorStop . If the axis group is in GroupStandby , then the individual axes are not necessarily all in standstill because they can be controlled by means of single-axis motion function blocks such as MC_Jog . If motion is terminated with an error, then all buffered subsequent movements are aborted with CommandAborted . As long as the axis group follows a dynamic coordinate system, it will stay in GroupMoving . The axis group is in GroupMoving if and only if the group is moved in a coordinated manner (by one of the motion blocks from Part 4). Switching from GroupMoving to GroupStandby is done one cycle after the last position change. " }, 
{ "title" : "Configuration of the Planning Task ", 
"url" : "_sm_configuration_planning_task.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Axis Group \/ Configuration of the Planning Task ", 
"snippet" : "The movement planning of the axis group is done in a separate task which is automatically created with the name \"SoftMotion_PlanningTask\" when an axis group is inserted. By default, this planning task runs on the same processor core as the bus task. On multicore systems, it is advisable to locate th...", 
"body" : "The movement planning of the axis group is done in a separate task which is automatically created with the name \"SoftMotion_PlanningTask\" when an axis group is inserted. By default, this planning task runs on the same processor core as the bus task. On multicore systems, it is advisable to locate them on a separate core. Depending on whether or not the planning task runs on its own core, it needs to be configured differently. Single core If the planning task runs on the same core as the bus task, then it should be configured as a freewheeling task with low real-time priority. This is the case by default. The planning task is automatically created as a freewheeling task with priority 15. Multicore On multicore systems, the planning task should run on a separate core with the highest priority (0). The task type should be set to cyclical and the task interval to a low value (for example, 2 ms). With these settings, the planning task will frequently exceed its task interval. This is to be expected and is not a problem. The task settings are selected to make sure that the planning task is called again immediately after a run. In this way, the dedicated core is used as much as possible for movement planning. For more information about task configuration, see: Task Configuration Object: Task Configuration Object: Task " }, 
{ "title" : "Kinematics ", 
"url" : "_sm_robotics_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Kinematics ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Overview ", 
"url" : "_sm_overview_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Kinematics \/ Overview ", 
"snippet" : "One of the most important tasks in robotics is moving a tool (for example, a tool plate or a welding gun) along a predefined path. To do this, CODESYS SoftMotion Robotics calculates how the individual joints of the robot need to move so that the tip of the tool – the Tool Center Point (TCP) – follow...", 
"body" : "One of the most important tasks in robotics is moving a tool (for example, a tool plate or a welding gun) along a predefined path. To do this, CODESYS SoftMotion Robotics calculates how the individual joints of the robot need to move so that the tip of the tool – the Tool Center Point (TCP) – follows the commanded path with the desired orientation. Kinematics or kinematic transformation is fundamental to this calculation. It implements the conversion from joint positions to TCP position and TCP orientation, and vice versa. The calculation rule differs depending on the type of robot being used. CODESYS SoftMotion Robotics includes configurable kinematics for numerous standard robots. For more information, see: Kinematics Included in The kinematics are divided into positioning and orientation kinematics which can be combined. For more information, see: Combination of Position and Orientation KinematicsA tool offset can be configured which can be changed at runtime. For more information, see: Configuring a Tool OffsetEndlessly rotating modulo axes are supported for rotary joints. For more information, see: Rotary Joints and Modulo AxesFor special robot types whose calculation rule cannot be mapped by one of the supplied kinematics, you can implement your own kinematics in the form of a function block. For more information, see: Creating Custom Kinematics" }, 
{ "title" : "Kinematics Included in CODESYS SoftMotion ", 
"url" : "_sm_robotics_cds_sm_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Kinematics \/ Kinematics Included in CODESYS SoftMotion ", 
"snippet" : "Gantry systems Name Representation Can be linked with orientation kinematics Additional Information Gantry2 ✓ Kin_Gantry2 (FB) Gantry3 ✓ Kin_Gantry3 (FB) HGantry2 ✓ Kin_HGantry2 (FB) HGantry3 ✓ Kin_HGantry3 (FB) TGantry2 ✓ Kin_TGantry2 (FB) 5-axis gantry -- Kin_5Axes (FB) SCARA systems Name Represen...", 
"body" : "Gantry systems Name Representation Can be linked with orientation kinematics Additional Information Gantry2 ✓ Kin_Gantry2 (FB) Gantry3 ✓ Kin_Gantry3 (FB) HGantry2 ✓ Kin_HGantry2 (FB) HGantry3 ✓ Kin_HGantry3 (FB) TGantry2 ✓ Kin_TGantry2 (FB) 5-axis gantry -- Kin_5Axes (FB) SCARA systems Name Representation Can be linked with orientation kinematics Additional Information Polar ✓ Kin_Polar (FB) Polar with Z-axis ✓ Kin_Polar_Z (FB) Scara2 with Z-axis ✓ Kin_Scara2_Z (FB) Scara3 with Z-axis -- Kin_Scara3_Z (FB) Articulated robots Name Representation Can be linked with orientation kinematics Additional Information Articulated robot with 3 rotary axes ✓ Kin_Pos_RRR (FB) 4-axis palletizer -- Kin_4AxesPalletizer (FB) 6-axis articulated robot -- Kin_ArticulatedRobot_6DOF (FB) Parallel systems Name Representation Can be linked with orientation kinematics Additional Information Bipod with rotary axes ✓ Kin_Bipod_Rotary (FB) Tripod with rotary axes ✓ Kin_Tripod_Rotary (FB) Tripod with linear axes ✓ Kin_Tripod_Linear (FB) Orientation kinematics Name Representation Additional Information C-axis Kin_CAxis (FB) C-axis with tool Kin_CAxis_Tool (FB) Tool Kin_Tool (FB) Wrist2 Kin_Wrist2 (FB) Wrist3 Kin_Wrist3 (FB) " }, 
{ "title" : "Combination of Position and Orientation Kinematics ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Kinematics \/ Combination of Position and Orientation Kinematics ", 
"snippet" : "With the axis group configurator, you can combine position kinematics and orientation kinematics. As a result, a large number of robots can be configured with a small number of kinematics. Examples of position kinematics include gantries ( Kin_Gantry3 ) and tripods ( Kin_Tripod_Lin , Kin_Tripod_Rota...", 
"body" : "With the axis group configurator, you can combine position kinematics and orientation kinematics. As a result, a large number of robots can be configured with a small number of kinematics. Examples of position kinematics include gantries ( Kin_Gantry3 ) and tripods ( Kin_Tripod_Lin , Kin_Tripod_Rotary ). These kinematics can travel to any point or position, but cannot perform any number of orientations. The front coordinate system of a position kinematic system is referred to as a flange coordinate system. It defines the place where orientation kinematics are attached (figure on left). Examples of orientation kinematics are Kin_CAxis , Kin_Wrist2 , and Kin_Wrist3 . These kinematics can result in a desired orientation of the TCP, but cannot reach any position (see figure on the right). By combining both position kinematics and orientation kinematics, it is possible to travel any number of positions in the desired orientation, or the other way around. Remarks about customized kinematics Users who want to create their own position or orientation kinematics have to implement the following additional interfaces in their kinematics function blocks: For position kinematics: The interface ISMPositionKinematics2 with the methods AxesToOrientation and GetOrientationImage . AxesToOrientation is an \"abbreviated\" forward transformation that calculates the orientation of the flange coordinate system from the axis values. It is necessary only for reasons of efficiency. For example, nothing has to be calculated with a gantry, but rather a constant orientation can be returned. GetOrientationImage returns how the orientation of the flange coordinate system can change. This method is necessary only for checking whether orientation kinematics are compatible with the position kinematics. For orientation kinematics: The interface ISMToolKinematics2 with the methods GetPositionFromOrientation2 and IsCompatibleWithPosKin . GetPositionFromOrientation2 calculates the vector between the flange coordinate system and TCP from the desired orientation (in MCS). This calculation is necessary for the inverse transformation of the combined kinematics. The IsCompatibleWithPosKin method checks whether the orientation kinematics are compatible with the position kinematics. " }, 
{ "title" : "Invalid combinations ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html#UUID-ccacfa9e-092b-a9a9-875d-01e9182027a1_id_dd90bf9efee04f9c0a8646352f64466_id_718d71abf014b14bc0a864635271f262", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Kinematics \/ Combination of Position and Orientation Kinematics \/ Invalid combinations ", 
"snippet" : "Not every combination of position kinematics and orientation kinematics is possible because sometimes a unique inverse transformation cannot be determined. One example is a SCARA with two articulate joints as position kinematics and Kin_CAxis_Tool as orientation kinematics with a tool offset that is...", 
"body" : "Not every combination of position kinematics and orientation kinematics is possible because sometimes a unique inverse transformation cannot be determined. One example is a SCARA with two articulate joints as position kinematics and Kin_CAxis_Tool as orientation kinematics with a tool offset that is not 0 in the X- or Y-coordinate. The orientation of the flange coordinate system of the SCARA is not constant. It is rotated about the Z-axis relative to the 0 position. For the calculation of the inverse transformation, this rotation is not yet known, which makes it impossible to clearly determine the axis angles in this case. Whether a combination is possible can be checked at runtime, as it depends on the parameterization of the kinematics. In this case, the error SMC_TRAFO_INVALID_COUPLING is issued. " }, 
{ "title" : "Behavior when programming \"impossible\" orientations ", 
"url" : "_sm_robotics_combining_position_and_tool_kinematics.html#UUID-ccacfa9e-092b-a9a9-875d-01e9182027a1_id_dd90bf9efee04f9c0a8646352f64466_id_5ba01e61f014b14bc0a86463044fcdf7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Kinematics \/ Combination of Position and Orientation Kinematics \/ Behavior when programming \"impossible\" orientations ", 
"snippet" : "In practice, it is often useful to be able to program orientations that are not available for the kinematics. As a simple example, consider a SCARA robot with a tool having one degree of freedom (rotation about the Z-axis). In principle, this robot can accept only orientations in which the tool poin...", 
"body" : "In practice, it is often useful to be able to program orientations that are not available for the kinematics. As a simple example, consider a SCARA robot with a tool having one degree of freedom (rotation about the Z-axis). In principle, this robot can accept only orientations in which the tool points vertically downwards. When positions should be traveled on a workpiece, it will be easily tilted from the X\/Y-plane. The user teaches the workpiece and then programs the positions and orientations relative to the workpiece. The tilting of the workpiece results in orientations in which the tool direction is slightly tilted from the vertical. How do we deal with such an impossible and unreachable orientation? A drastic measure would be to report a workspace violation. However, as the example shows, this would make programming tedious. Therefore, the orientation kinematics ( Kin_CAxis_Tool in this example) are implemented in such a way that they assume the nearest achievable orientation. In this example this means that the commanded orientation is tilted in such a way that the tool stands upright and this orientation is accepted. The behavior can be reduced to the following rules (provided the position kinematics can position in all three spatial directions): The position is always approached exactly (otherwise an error is reported). The orientation is \"projected\" to the nearest accessible one if it cannot be reached. When projecting the orientation, the tool direction has priority. The difficulties described here arise because the orientation kinematics do not have the three degrees of freedom to achieve all desired orientations. This is the case with Kin_Wrist2 and Kin_CAxis , but not with Kin_Wrist3 . Additional difficulties arise when the position kinematics also do not have all spatial degrees of freedom. (This does not occur often in practice.) One example is the combination of Kin_Gantry2 , a gantry that can be positioned in X\/Y only, and with Kin_Wrist2 , a tool with only two degrees of freedom. In this case, there are impossible orientations as well as impossible positions, because the Z-coordinate is already defined by the tool length and the position of the orientation axis. Therefore, we recommend that you do not use these kinds of combinations, but to program only attainable positions. " }, 
{ "title" : "Kinematic Configurations ", 
"url" : "_sm_configure_kinematics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Kinematics \/ Kinematic Configurations ", 
"snippet" : "A kinematic configuration describes the layout of the axes in an axis group to one another. Depending on the kinematics, several configurations are possible for the same TCP position. For example, two possible configurations are shown for SCARA 2. The axis group has an active configuration that does...", 
"body" : "A kinematic configuration describes the layout of the axes in an axis group to one another. Depending on the kinematics, several configurations are possible for the same TCP position. For example, two possible configurations are shown for SCARA 2. The axis group has an active configuration that does not necessarily have to correspond to the current axis positions. If a movement is commanded, then the target position may be converted into axis coordinates. The configuration that is active at the time of commanding is used. This active configuration can be set with the function block SMC_SetKinConfiguration . During initialization and each time the kinematics are changed, the axis group applies the standard configuration. All kinematics with a configuration has a standard configuration. A CP movement between two configurations is not possible. In this case, the positioning has to be done by means of a PTP movement. The current configuration can be determined with the function block MC_GroupReadActualPosition . " }, 
{ "title" : "Setting the configuration for one kinematic design ", 
"url" : "_sm_configure_kinematics.html#UUID-a0dd90bd-a3ae-b4c7-c573-b244e5ca8497_id_fd441540121e3a8c0a8646325f17a66_id_b2318eb4acf011e79acc88930c5b16a7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Kinematics \/ Kinematic Configurations \/ Setting the configuration for one kinematic design ", 
"snippet" : "Every kinematic design with a configuration has its own POU for calculating the configuration data. The name of this function block corresponds to the name of the kinematics plus the postfix _config . The POU converts the different configurations into the data type ConfigData . This data type is pas...", 
"body" : "Every kinematic design with a configuration has its own POU for calculating the configuration data. The name of this function block corresponds to the name of the kinematics plus the postfix _config . The POU converts the different configurations into the data type ConfigData . This data type is passed to the function block SMC_SetKinConfiguration . Example: Setting a configuration for a SCARA 2 kinematic design Call the function block Kin_Scara2_Z_Config from the library SM3_Transformation . Input xElbowRight = TRUE The function block yields the configuration data of type ConfigData . Call the function block SMC_SetKinConfiguration from the library SM3_Robotics . Write the input ConfigData with the previously determined configuration data. Set the active configuration of the SCARA 2. VAR\n config: TRAFO.Kin_Scara2_Z_Config;\n skc: SMC_SetKinConfiguration;\nEND_VAR\n\nconfig(xElbowRight := TRUE);\nskc(AxisGroup := Scara2, Execute := TRUE, ConfigData := config.Config); " }, 
{ "title" : "Handling of coupled kinematics ", 
"url" : "_sm_configure_kinematics.html#UUID-a0dd90bd-a3ae-b4c7-c573-b244e5ca8497_id_fd441540121e3a8c0a8646325f17a66_id_b22c1067acf011e79acc88930c5b16a7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Kinematics \/ Kinematic Configurations \/ Handling of coupled kinematics ", 
"snippet" : "Coupled kinematics exist when position kinematics and orientation kinematics are used simultaneously. This results in the \"coupled\" configuration from both configurations by calling Kin_Coupled_Config from the library SM3_Transformation . The configuration of the position kinematics and the orientat...", 
"body" : "Coupled kinematics exist when position kinematics and orientation kinematics are used simultaneously. This results in the \"coupled\" configuration from both configurations by calling Kin_Coupled_Config from the library SM3_Transformation . The configuration of the position kinematics and the orientation kinematics are provided to the function block at the inputs. For more information, see: Rotary Axes with a Value Range over 360°" }, 
{ "title" : "Configuring a Tool Offset ", 
"url" : "_sm_configure_tool_offset.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Kinematics \/ Configuring a Tool Offset ", 
"snippet" : "You can set the offset between the flange coordinate system of the kinematics (XYZ) and the TCP coordinate system of the kinematics (X'Y'Z') by means of configuring a tool offset. This tool offset acts on all subsequent movements. TCP: Tool Center Point The tool offset is specified by a shift v=(x,y...", 
"body" : "You can set the offset between the flange coordinate system of the kinematics (XYZ) and the TCP coordinate system of the kinematics (X'Y'Z') by means of configuring a tool offset. This tool offset acts on all subsequent movements. TCP: Tool Center Point The tool offset is specified by a shift v=(x,y,z) and a rotation r=(A,B,C) in ZYZ Euler angles. Shift and rotation are expressed relative to the flange coordinate system of the kinematics. When you configure a tool offset, it can be incompatible with the current kinematics. As a result, a tool offset can cause the kinematics to be incapable of achieving orientations. In this situation, an error is issued and the tool offset is ignored. For example, you can configure a tool offset in the Z-direction for the kinematics Kin_Scara2_Z . On the other hand, an offset with parts in the X- or Y-direction results in an error. When kinematics have these kinds of restrictions, they are described with the kinematics . " }, 
{ "title" : "Function block: SMC_GroupSetTool ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_348cb75b4119d4bfc0a864631ca28fed", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Kinematics \/ Configuring a Tool Offset \/ Function block: SMC_GroupSetTool ", 
"snippet" : "The function block configures the tool offset specified at the input ToolOffset (type MC_COORD_REF ) for an axis group. However, as long as the axis group is in the state GroupDisabled or GroupErrorStop , no tool offset can be configured. If the tool is not compatible with the current kinematics, th...", 
"body" : "The function block configures the tool offset specified at the input ToolOffset (type MC_COORD_REF ) for an axis group. However, as long as the axis group is in the state GroupDisabled or GroupErrorStop , no tool offset can be configured. If the tool is not compatible with the current kinematics, then the POU issues the error SMC_AXIS_GROUP_TOOL_OFFSET_INCOMPATIBLE_WITH_KINEMATICS . This error is also issued if the interface ISMKinematicsWithOrientationImage has not been implemented for the kinematics description. " }, 
{ "title" : "Function block: SMC_GroupReadTool ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_c1689be51d4132b4c0a864637c06bdff", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Kinematics \/ Configuring a Tool Offset \/ Function block: SMC_GroupReadTool ", 
"snippet" : "This function block reads the tool offset: output ToolOffset (type MC_COORD_REF ). In this process, the ReadMode input determines whether the tool of the active movement, the last commanded movement, or the tool currently set in the axis group should be read....", 
"body" : "This function block reads the tool offset: output ToolOffset (type MC_COORD_REF ). In this process, the ReadMode input determines whether the tool of the active movement, the last commanded movement, or the tool currently set in the axis group should be read. " }, 
{ "title" : "Compatible kinematics ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_ff04bb6d41a8190bc0a864635e26fe13", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Kinematics \/ Configuring a Tool Offset \/ Compatible kinematics ", 
"snippet" : "Not all kinematics support every tool offset. The following list shows which tools are suitable for which kinematics. Kinematics Compatible Tool SCARA 2 kinematics Kin_Scara2_Z Tools with position offset in the Z-direction and offset in the orientation SCARA 3 kinematics Kin_Scara3_Z All tools Polar...", 
"body" : "Not all kinematics support every tool offset. The following list shows which tools are suitable for which kinematics. Kinematics Compatible Tool SCARA 2 kinematics Kin_Scara2_Z Tools with position offset in the Z-direction and offset in the orientation SCARA 3 kinematics Kin_Scara3_Z All tools Polar kinematics Kin_Polar , Kin_Polar_Z Tools with position offset in the Z-direction and offset in the orientation 3-axis articulated robot Kin_Pos_RRR Tools with an offset in the orientation 6-axis articulated robot Kin_ArticulatedRobot_6DOF All tools 4-axis palletizer Kin_4AxisPalletizer All tools Bipod Kin_Bipod_Rotary All tools 5-axis gantry Kin_5Axes All tools Gantry systems All tools H-gantry system All tools T-gantry system All tools Rotary or linear tripod All tools If a kinematic system does not have 3 degrees of freedom for the orientation, then it may be the case that not every tool offset is compatible. " }, 
{ "title" : "For custom kinematics ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_6c7b39581d4132b4c0a8646366a3228c", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Kinematics \/ Configuring a Tool Offset \/ For custom kinematics ", 
"snippet" : "In order to use your custom kinematics with a tool offset, you need to implement the ISMKinematicsWithOrientationImage interface. To add a tool offset for your custom position kinematics, you first have to implement the interface ISMPositionKinematics2 ....", 
"body" : "In order to use your custom kinematics with a tool offset, you need to implement the ISMKinematicsWithOrientationImage interface. To add a tool offset for your custom position kinematics, you first have to implement the interface ISMPositionKinematics2 . " }, 
{ "title" : "Interface: ISMKinematicsWithOrientationImage ", 
"url" : "_sm_configure_tool_offset.html#UUID-64443edd-1453-647d-5aab-878669ab1b01_id_b1a422ee4051fa81c0a8646333efa065_id_592ee99f1d4132b4c0a864637bd8a061", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Kinematics \/ Configuring a Tool Offset \/ Interface: ISMKinematicsWithOrientationImage ", 
"snippet" : "The kinematic interface provides the method GetFlangeOrientationImage with the variable mR_Flange of data type SMC_Matrix3 , which contains the commanded orientation of the flange. As a consequence, the method returns possible resulting orientations oriInfo as data type OrientationSpace . Behavior o...", 
"body" : "The kinematic interface provides the method GetFlangeOrientationImage with the variable mR_Flange of data type SMC_Matrix3 , which contains the commanded orientation of the flange. As a consequence, the method returns possible resulting orientations oriInfo as data type OrientationSpace . Behavior of the interface In particular, when the orientation of the flange in the commanded orientation is known, dof = zero is returned and mOriZero is set to the known orientation. If the orientation R of the flange is only partially known in the form R*vU = vRot (where vU and vRot are known unit vectors), then dof = one is returned. mOriZero is set to an orientation in the reachable space. Otherwise, dof = three is returned. A specified tool offset is compatible with kinematics if the flange position can be calculated uniquely while taking the calculated orientation into account. This is always the case when the calculated orientation can be achieved by the kinematics. The tool offset may be incompatible only if not all orientations can be reached. Moreover, if the method GetFlangeOrientationImage returns dof = zero , then every tool offset is compatible. If the method returns dof = one , then only the tool position offset v_off parallel to the unit vector vU is compatible. In this case, R*v_off = R*vU*x = vRot*x does not depend on the unknown parts of the orientation matrix R . This also includes a tool offset with v_off = 0 (where x = 0). If dof = three is returned, then only position shifts without an offset in x\/y\/z are compatible. Implementation notes Implement the interface ISMOrientationKinematicsWithOriImage2 for orientation kinematics. Then a tool offset can be used for coupling the orientation kinematics with position kinematics. The interface has the method GetOrientationImage2 with the variable VAR_IN_OUT CONSTANT mR_Flange of data type SMC_Matrix3 , which contains the commanded orientation of the flange. The method returns csTool and oriinfo with the data type OrientationSpace in the base coordinate system of the orientation kinematics. Moreover, the method returns in bActive whether the degrees of freedom from orinfo are active ( TRUE ) or passive ( FALSE ). Example of active degrees of freedom: Kin_CAxis . The rotation about the z-axis is controlled by the orientation kinematics axis. Example of passive degrees of freedom: Kin_Wrist2 . The remaining degree of freedom is the rotation of X\/Y about the Z-axis, which points in the direction programmed by the user. When both the last commanded movement and the new movement are CP movements (both movements linear or rotary) during a tool change, the buffer mode of the subsequent movement is changed from Blending or Aborting to Buffered . If you configure a new tool offset after MC_GroupInterrupt and before MC_GroupContinue , then the old tool offset is used for the interrupted movements. The new tool offset is used only for movements that are commanded afterwards. When the kinematics are changed ( MC_SetKinTransform ), the tool offset is reset (no shift, no rotation). " }, 
{ "title" : "Rotary Joints and Modulo Axes ", 
"url" : "_sm_robotics_rotary_joints_modulo_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Kinematics \/ Rotary Joints and Modulo Axes ", 
"snippet" : "Modulo axes within axis groups are supported as of SoftMotion 4.12.0.0. Modulo axes are only allowed for rotary joints of kinematics. These are rotary joints for which SMKinematicWithInfo.GetAxisProperties returns the value props.eType = Axis_Type.Rotary . If a modulo axis is used for a linear joint...", 
"body" : "Modulo axes within axis groups are supported as of SoftMotion 4.12.0.0. Modulo axes are only allowed for rotary joints of kinematics. These are rotary joints for which SMKinematicWithInfo.GetAxisProperties returns the value props.eType = Axis_Type.Rotary . If a modulo axis is used for a linear joint or for a kinematic which does not implement ISMKinematicWithInfo , then MC_GroupEnable returns the SMC_MODULO_AXIS_FOR_NON_ROTARY_JOINT error. If a modulo axis is used and the kinematics limit the range of a rotary joint, then MC_GroupEnable returns the SMC_MODULO_AXIS_FOR_LIMITED_ROTARY_JOINT error. Modulo axes are supported only if the modulo period is 360°. The reason for this is that axes connected to rotary joints have to be configured is such a way that one technical unit [u] corresponds to one angular degree [°]. One period has to correspond to one full rotation. If a modulo axis with a period other than 360° is used, then MC_GroupEnable returns the SMC_MODULO_AXIS_PERIOD_NOT_360 error. As of version 4.12.0.0, SoftMotion supports only the shortest mode ( MC_DIRECTION ). This means that the distance and direction of a modulo axis are selected is such a way that they are as close as possible to the start position of the axis. For example, if the orientation axis is at a2 = 30° at the beginning of the movement and at a2 = 290° at the target position, then the position a2 = 290° – 360° = –70° is selected and the axis moves 100° in the negative direction instead of moving 260° in the positive direction. " }, 
{ "title" : "Creating Custom Kinematics ", 
"url" : "_sm_kinematic_transformations.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Kinematics \/ Creating Custom Kinematics ", 
"snippet" : "The open source tool wkhtmltopdf is required to generate the documentation for the kinematics from the comments in the function block. However, this component is no longer included in the setup of CODESYS version 3.5 SP15 and higher. You can download the DLL from https:\/\/wkhtmltopdf.org\/downloads.ht...", 
"body" : "The open source tool wkhtmltopdf is required to generate the documentation for the kinematics from the comments in the function block. However, this component is no longer included in the setup of CODESYS version 3.5 SP15 and higher. You can download the DLL from https:\/\/wkhtmltopdf.org\/downloads.html . Create a directory named DocScripting\\3.5.xx.x\\bin in the installation directory of CODESYS and save the file wkhtmltox.dll there. Caution: Since wkhtmltox.dll no longer supports images by default in Version 0.12.6 and higher, you need to use Version 0.12.5 or lower. When an instance of a kinematic transformation of an axis group is used, the inputs of the instance must not be changed anymore. To change the parameterization of the kinematic transformation, you need to use the configuration if possible, or create multiple instances. When you create custom kinematics, you need to observe the following: Kinematics are described by special function blocks which can be stored in libraries or in the POUs view of the project. For CODESYS to list the kinematics in the configurator, the associated function blocks have to implement the MC_KIN_REF_SM3 interface (part of SM3_Transformation.library ). You can define kinematics as a combination of two other kinematics. Kinematics with the possibility of attaching tool plates or tools also have to implement the ISMPositionKinematics2 interface. Kinematics that specify a tool plate or tool have to implement the ISMToolKinematics2 interface. If you implement only ISMPositionKinematics \/ ISMToolKinematics instead of ISMPositionKinematics2 \/ ISMToolKinematics2 , then \"unavailable\" orientations could be processed incorrectly. When you also implement the interface ISMPositionKinematics_Offset , you can use the orientation mode Axis . When the POU has the sm_kin_libdoc attribute, the comment specified in the function block is used in the configurator as a description of the kinematics. \"Restructured Text\" formatting is used for this. Note, however, that links are not supported. Design-related parameters, such as arm lengths and angles, are created as VAR_INPUT variables of the function block. You should comment the parameters because the comment serves as a description in the configurator. If the parameters are a numeric type and their value range is restricted, then they must be provided with the sm_kin_param_range attribute. The syntax of the value range is [a .. b] for closed intervals and ]a .. b[ for open intervals. The combined forms ]a .. b] and [a .. b[ are also possible. For this purpose, a and b have to be appropriate literals for the parameter type. The special values +inf and -inf are possible for open interval limits. Examples: [0 .. 1] , [1 .. +inf[ , ]-inf .. -5] . Parameters can by any numeric type or BOOL . Parameters should have an initial value that is used as the default value. You can specify the unit of the parameter with the optional attribute sm_kin_param_unit (example: \"rad\", \"°\", \"deg\"). You should use the unit \"u\" for lengths and distances. The application and the scaling of the drives determine whether these units are \"mm\", \"cm\", or \"m\". If there is no library documentation available for the function block, then the comment of the FB element is displayed at the respective positions as a fallback option. The language configured in CODESYS is the displayed language for the LibDoc documentation. If a localization is not available in this language, then the default language of the library is used. The axis names of the kinematics are defined by the FB attribute sm_kin_axes . The value of the attribute is a list of axis names (example: \"A1, A2, A3\"). An optional icon is specified with the FB attribute sm_kin_icon . The value is specified in the form <image pool>.<identifier> . The image pool is specified relative to the function block. If you create a custom kinematics function block with revolute joints (for example, Kin_Scara3_Z_Config ), then you should use the period concept for theses axes and implement the ISMKinPeriodHandling interface. For rotary axes, only the inverse kinematic transformation ( CartesianToAxes ) is responsible for the calculation of the angle. Then CODESYS SoftMotion automatically shifts this angle to the correct period. For example, if the transformation calculates an angle in the range ]-180°, 180°], then CODESYS SoftMotion shifts this angle to the range [0°, 360°[, provided that the software boundaries of the drive are 0° .. 360°. Moreover, you should implement the ISMKinematicsWithConfiguration3 interface. This is the only way to make sure that the kinematics for CP movements work without any problems. In the case of coupled kinematics with an irregular layout of position and orientation kinematics, you should implement the ISMCoupledKinematics3 interface. In this way, the system can detect whether or not an axis for position or orientation kinematics belongs with the respective axis number. Note: You should implement the ISMKinematicWithConfigurations2.CPConnectible method in such a way that the period settings are ignored on comparison. Then CPConnectible returns the value TRUE , even if the period setting is different. All inverse transformations have an input of type CONFIGDATA that contains a byte array with information about the configuration of the kinematics. The forward transformations have a corresponding output. Kinematics with a configuration have to implement the ISMKinematicWithConfigurations interface. These kinematics each include a function block that has to implement the ISMConfigurationData interface (function for the serialization of the configuration data). The name of this function block has to be the same name as kinematics plus the postfix _config . You can use this FB for modifying the configuration in the application (by means of the function block SMC_SetKinConfiguration block). However, kinematics should not hold any instance of the corresponding FB. For step-by-step instructions, see the Custom Kinematics chapter. " }, 
{ "title" : "Coordinate Systems ", 
"url" : "_sm_coordinate_systems.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Coordinate Systems ", 
"snippet" : "CODESYS SoftMotion Robotics provides different coordinate systems in which movements can be commanded. Axis Coordinate System (ACS) Tool Coordinate System (TCS) World Coordinate System (WCS) Machine Coordinate System (MCS) Product Coordinate System (PCS_1, PCS_2) Coordinate System Description Axis C...", 
"body" : "CODESYS SoftMotion Robotics provides different coordinate systems in which movements can be commanded. Axis Coordinate System (ACS) Tool Coordinate System (TCS) World Coordinate System (WCS) Machine Coordinate System (MCS) Product Coordinate System (PCS_1, PCS_2) Coordinate System Description Axis Coordinate System (ACS) The axis coordinate system defines a coordinate system in axis space where each axis of the robot spans one dimension. As a result, a position can be specified for each axis of the robot. Tool Coordinate System (TCS) The tool coordinate system is a Cartesian coordinate system which lies on the tool center point (TCP) of the kinematics. Its position and orientation depend on the position of the robot. World Coordinate System (WCS) The world coordinate system is a static Cartesian coordinate system and forms the basis for all subsequent coordinate systems. These are defined relative to the world coordinate system. Machine Coordinate System (MCS) The machine coordinate system is a static Cartesian coordinate system. The position and orientation of the MCS relative to the physical robot are defined by the kinematics. The MC_SetCoordinateTransform function block can be used to shift the coordinate system relative to the world coordinate system (WCS). Product Coordinate System (PCS_1, PCS_2) The product coordinate systems are Cartesian coordinate systems which can be defined by the user. They are expressed relative to the world coordinate system (WCS) and can be either static or dynamic. Static The MC_SetCoordinateTransform function block can be used to move the coordinate systems relative to the world coordinate system (WCS). Dynamic The following function blocks can be used to define dynamic coordinate systems: MC_SetDynCoordTransform SMC_SetDynCoordTransformEx MC_TrackConveyorBelt MC_TrackRotaryTable " }, 
{ "title" : "Initial position and orientation of the coordinate systems ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056579261585", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Coordinate Systems \/ Initial position and orientation of the coordinate systems ", 
"snippet" : "The kinematics of the robot determine the initial position and orientation of the coordinate systems. This is described in the documentation of the kinematics. The kinematics define the following: Position and orientation of the machine coordinate system (MCS) relative to the physical robot Position...", 
"body" : "The kinematics of the robot determine the initial position and orientation of the coordinate systems. This is described in the documentation of the kinematics. The kinematics define the following: Position and orientation of the machine coordinate system (MCS) relative to the physical robot Position and orientation of the tool center point (TCP) relative to the MCS and therefore the tool coordinate system (TCS) Zero position of the robot as well as the directions of rotation or movement of the individual axes The world coordinate system (WCS) and the product coordinate systems (PCS_1, PCS_2) are not initially shifted and are identical to the machine coordinate system. " }, 
{ "title" : "Multiple robots and workpieces ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056581220108", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Coordinate Systems \/ Multiple robots and workpieces ", 
"snippet" : "The position and orientation of the coordinate systems are defined for each robot. When multiple robots are working together, it can be useful to define the world coordinate system (WCS) as a common base coordinate system. Based on this coordinate system, the machine coordinate systems (MCS) and pro...", 
"body" : "The position and orientation of the coordinate systems are defined for each robot. When multiple robots are working together, it can be useful to define the world coordinate system (WCS) as a common base coordinate system. Based on this coordinate system, the machine coordinate systems (MCS) and product coordinate systems (PCS_1, PCS_2) of the individual robots can be shifted. " }, 
{ "title" : "Example ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056581719182", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Coordinate Systems \/ Example ", 
"snippet" : "Example using a robot with two rotary joints ( a0 and a1 )...", 
"body" : "Example using a robot with two rotary joints ( a0 and a1 ) " }, 
{ "title" : "Kinematics ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056582142746", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Coordinate Systems \/ Example \/ Kinematics ", 
"snippet" : "The kinematics define the zero position of the robot (as shown below). The origin of the machine coordinate system lies on the axis of rotation of axis a0 . The X-axis points in the direction of the first link when the position of the first axis a0 is 0 . The Y-axis points in the direction of the fi...", 
"body" : "The kinematics define the zero position of the robot (as shown below). The origin of the machine coordinate system lies on the axis of rotation of axis a0 . The X-axis points in the direction of the first link when the position of the first axis a0 is 0 . The Y-axis points in the direction of the first link when the position of the first axis a0 is +90° . Counterclockwise rotation corresponds to the positive direction of rotation. The tool center point (TCP) lies at the end of the second link of the robot (as shown below) and forms the origin of the TCS. The TCS is aligned in such a way that the X-axis runs along the second link. " }, 
{ "title" : "Axis Coordinate System (ACS) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056582875889", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Coordinate Systems \/ Example \/ Axis Coordinate System (ACS) ", 
"snippet" : "The kinematics have specified the zero position of the robot and the direction of rotation of the individual axes. Because the robot consists of two axes a0 and a1 , we can specify the positions of axes a0 and a1 in the ACS. In the first image, we specify the position ( a0:= 0, a1:= 0 ). This corres...", 
"body" : "The kinematics have specified the zero position of the robot and the direction of rotation of the individual axes. Because the robot consists of two axes a0 and a1 , we can specify the positions of axes a0 and a1 in the ACS. In the first image, we specify the position ( a0:= 0, a1:= 0 ). This corresponds to the zero position of the robot. In the second image, we specify the position ( a0:= 90, a1:= 0 ). Starting from the zero position, the first axis a0 is rotated 90° in the positive direction of rotation. The second axis a1 remains in the zero position. In the third image, we specify the position ( a0:= 90, a1:= -90 ). Starting from the zero position, the first axis a0 is rotated 90° in the positive direction of rotation (as in the second image). In addition, the second axis a1 is rotated 90° in the negative direction of rotation. " }, 
{ "title" : "Tool Coordinate System (TCS) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056583569251", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Coordinate Systems \/ Example \/ Tool Coordinate System (TCS) ", 
"snippet" : "The kinematics define the position and orientation of the TCP and TCS. Depending on how we move the robot, the position and orientation of the TCS also changes....", 
"body" : "The kinematics define the position and orientation of the TCP and TCS. Depending on how we move the robot, the position and orientation of the TCS also changes. " }, 
{ "title" : "World Coordinate System (WCS), Machine Coordinate System (MCS), and Product Coordinate System (PCS_1, PCS_2) ", 
"url" : "_sm_coordinate_systems.html#UUID-6d6bd6ec-d41e-0ba0-0e3f-cad2eb361a46_section-idm235056584038831", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Coordinate Systems \/ Example \/ World Coordinate System (WCS), Machine Coordinate System (MCS), and Product Coordinate System (PCS_1, PCS_2) ", 
"snippet" : "In a production hall, two robots stand to the left and right of a conveyor belt. The robots should process products on the conveyor belt. We define a common world coordinate system and place it in the top left-hand corner of our production hall. Starting from this coordinate system, we determine the...", 
"body" : "In a production hall, two robots stand to the left and right of a conveyor belt. The robots should process products on the conveyor belt. We define a common world coordinate system and place it in the top left-hand corner of our production hall. Starting from this coordinate system, we determine the distance and rotation to the machine coordinate systems and the product and shift the coordinate systems accordingly. In the example, all coordinate systems are aligned in the same way so that we only need to shift the coordinate systems. The machine coordinate system of the left robot is shifted in the Y-direction, the machine coordinate system of the right robot is shifted in the X-direction, and the product coordinate system is shifted in both the X-direction and Y-direction. " }, 
{ "title" : "Motion Control ", 
"url" : "_sm_f_motion_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Overview ", 
"url" : "_sm_overview_robotics_motion_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Overview ", 
"snippet" : "This chapter describes the basic types of movement in robotics: Jogging SMC_GroupJog2 PTP movements (Point to Point) MC_MoveDirectAbsolute MC_MoveDirectRelative CP movements (Continuous Path) MC_MoveLinearAbsolute MC_MoveLinearRelative MC_MoveCircularAbsolute MC_MoveCircularRelative Wait SMC_GroupWa...", 
"body" : "This chapter describes the basic types of movement in robotics: Jogging SMC_GroupJog2 PTP movements (Point to Point) MC_MoveDirectAbsolute MC_MoveDirectRelative CP movements (Continuous Path) MC_MoveLinearAbsolute MC_MoveLinearRelative MC_MoveCircularAbsolute MC_MoveCircularRelative Wait SMC_GroupWait Stop (see Stopping on the Path with MC_GroupHalt or MC_GroupStop and Interruption and Continuation of Movements) MC_GroupHalt MC_GroupStop MC_GroupInterrupt Moreover, all important topics related to movements are also explained: Buffering and Blending of MovementsSynchronization with a Moving Coordinate SystemSynchronization of External Axes, Torque Feed Forward ControlAdditional AxesDiagnosis in case of slow or jerky movements" }, 
{ "title" : "How to Create a Program for Controlling the Axis Group ", 
"url" : "_sm_creating_an_axis_group_program.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ How to Create a Program for Controlling the Axis Group ", 
"snippet" : "The following instructions describe how to create a program for controlling an axis group. Requirement : A project has been created with an axis group, as specified in the How to Create an Axis Group chapter. The program for controlling an axis group is created in the PLC_PRG POU with CFC as the imp...", 
"body" : "The following instructions describe how to create a program for controlling an axis group. Requirement : A project has been created with an axis group, as specified in the How to Create an Axis Group chapter. The program for controlling an axis group is created in the PLC_PRG POU with CFC as the implementation language. Open the PLC_PRG program in the editor. Drag the Box element to the editor. Map the function block SMC_GroupPower to the box. Configure the function block according to the following image. Explanation: The function block activates all drives of the axis group. The output Status indicates successful controller enable. Create a function block of type MC_GroupEnable . This function block transfers control of the linked axes to the AxisGroup axis group. Connect the Status output of the SMC_GroupPower function block to the Execute input of the MC_GroupEnable function block. Explanation: When all axis controllers are powered ( Status = TRUE ), control of the axes is transferred to the axis group. The Done output reports the success of the command. Insert a MC_MoveDirectAbsolute function block for running the drive. Connect the Done output of the MC_GroupEnable function block to the Execute input of the MC_MoveDirectAbsolute function block. Extend the program as follows: Explanation: The MC_MoveDirectAbsolute function block commands a PTP motion of the AxisGroup axis group. In the example, the kinematics are moved to the position (X = 10, Y= 20, Z = 30). This value is mapped to the Position input via the SMC_POS_REF structure. The position is specified in the machine coordinate system (MCS). The coordinate system is selected by means of the CoordSystem input. Starting the program If the program has been created completely and it can be compiled without errors, then you can transfer it to the controller. Start the CODESYS Control Win runtime system ( CODESYSControlService.exe program in the \"...\\GatewayPLC\" directory). In the Communication Settings , set the connection path to your controller. Click Online → Login . Download the project to the controller. Click Debug → Start . In the editor, open the AxisGroup object. The positions of the axes are displayed. Click Debug → Start . The positions of the axes change. " }, 
{ "title" : "Jogging of Axis Groups ", 
"url" : "_sm_cartesian_jogging.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Jogging of Axis Groups ", 
"snippet" : "You can use the SMC_GroupJog2 function block to move an axis group in space. The SMC_GroupJog2 function block has two Boolean inputs for each coordinate. One input is for traversing forward along this coordinate, and one input is for traversing backward. The Boolean inputs for the different coordina...", 
"body" : "You can use the SMC_GroupJog2 function block to move an axis group in space. The SMC_GroupJog2 function block has two Boolean inputs for each coordinate. One input is for traversing forward along this coordinate, and one input is for traversing backward. The Boolean inputs for the different coordinates for SMC_GroupJog2 can be interpreted in different ways. For example, in Cartesian coordinates, machine coordinates, axis coordinates, or tool coordinates, depending on the coordinate system which is set. With a special input ABC_as_ACS: BOOL , both X\/Y\/Z and the axes of the tool kinematics can be jogged simultaneously in Cartesian coordinates and axis coordinates. \"Mixed\" jogging is supported only when the kinematics are coupled and the position kinematics implement the interface ISMPositionKinematics_Offset . (Otherwise the function block yields an error.) In jogging mode, A rotates the TCP about the X-axis of the configured coordinate system (MCS, WCS, PCS, or TCS). B and C rotate the TCP about the Y- and Z-axis in the same coordinate system. However, this applies only when ABC_as_ACS = FALSE . Cartesian jogging starts when the SMC_GroupJog2 function block receives a rising edge and sets the Busy output. Cartesian jogging causes the interruption of active coordinated movements or movements of the axes of the kinematics. Cartesian jogging ends when the jogging is interrupted by a movement (coordinated or on the axes of the kinematics) or when the position is outside of the workspace. When jogging, the axis limits are always maintained to the axes of the kinematics. For more information, see: Jogging a Robot" }, 
{ "title" : "PTP Movements ", 
"url" : "_sm_robotics_path_invariant_ptp_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ PTP Movements ", 
"snippet" : "For PTP movements, the path in space depends on the kinematics and only the start and destination points are fixed. The movement is fully synchronous so that the acceleration, constant motion, and deceleration phase for all axes begins and ends at the same time. PTP movements are always path-invaria...", 
"body" : "For PTP movements, the path in space depends on the kinematics and only the start and destination points are fixed. The movement is fully synchronous so that the acceleration, constant motion, and deceleration phase for all axes begins and ends at the same time. PTP movements are always path-invariant and therefore the following characteristics apply: The path is independent of the override. The path is independent of all dynamics limits of the axes (limits for velocity, acceleration, deceleration, and jerk). The only exception is for determining the cutoff points in TMStartVelocity mode. In TMCornerDistance mode, the path is independent of the blending type ( BlendingHigh \/ Low \/ Previous \/ Next ). The path is not departed on halt or stop ( MC_GroupHalt \/ MC_GroupStop ). The path is not departed on interrupt or continue ( MC_GroupInterrupt \/ MC_GroupContinue ). " }, 
{ "title" : "CP Movements ", 
"url" : "_sm_robotics_cp_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ CP Movements ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Overview ", 
"url" : "_sm_overview_robotics_motion_control_cp.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ CP Movements \/ Overview ", 
"snippet" : "CP movements (Continuous Path) are given by their geometric path. In the case of robotics, these are linear segments ( MC_MoveLinearAbsolute and MC_MoveLinearRelative ) and circular segments ( MC_MoveCircularAbsolute and MC_MoveCircularRelative ). A maximum path velocity, a maximum path acceleration...", 
"body" : "CP movements (Continuous Path) are given by their geometric path. In the case of robotics, these are linear segments ( MC_MoveLinearAbsolute and MC_MoveLinearRelative ) and circular segments ( MC_MoveCircularAbsolute and MC_MoveCircularRelative ). A maximum path velocity, a maximum path acceleration, and a maximum path jerk can be specified for CP movements. If blending is done between two CP movements, and if both movements lie in a common plane, then this plane is not left during the blending. For example, two consecutive straight line segments always lie in one plane. The geometry of the path does not yet determine how the orientation of the TCP is transferred from the start orientation to the target orientation. This is explained in the Orientation Interpolation for CP Movements section. CP movements always start and end in the same configuration of the robot. It is not possible to change the configuration with CP movements because the robot would move through a singular position. Movement through a singular position can lead to unlimited axis velocities. You can use PTP Movements to switch between configurations. " }, 
{ "title" : "Orientation Interpolation for CP Movements ", 
"url" : "_sm_robotics_orientation_interpolation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ CP Movements \/ Orientation Interpolation for CP Movements ", 
"snippet" : "In the case of CP movements such as MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute , or MC_MoveCircularRelative , any target orientation of the tool can be specified by means of the target position of the movement. The consequence is that the orientation of the tool is conve...", 
"body" : "In the case of CP movements such as MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute , or MC_MoveCircularRelative , any target orientation of the tool can be specified by means of the target position of the movement. The consequence is that the orientation of the tool is converted to the target orientation during the path movement with the tip of the tool traveling on the path. For the orientation interpolation, it does not make any difference in which coordinate system the target orientation was given, either in axis coordinates (ACS) or machine coordinates (MCS). The following image shows a linear interpolation with the simultaneous orientation interpolation. The red arrow indicates the direction of the tool at the start and end points. The dashed red line indicates how the tool is positioned at some locations during interpolation. The function blocks mentioned above for path movements have the OrientationMode input. This input defines how the start orientation is passed to the target orientation. Great circle interpolation ( SMC_Orientation_Mode.GreatCircle ) This is a default setting. With this setting, the start orientation is also passed to the target orientation in the shortest distance. The shortest distance means that the tool is rotated in the target orientation so that the traveled angle of the rotation is minimized. Axis orientation interpolation ( SMC_Orientation_Mode.Axis ) Example 1: Great circle interpolation Consider a gantry having a C-axis with a value range of -360° to 360°. The start orientation is C=179°, and the target orientation is C=-175°. The great circle interpolation moves the C-axis of the ZYZ Euler angle (A,B,C) proportionally to the traveled distance on the path from 179° in the positive direction past 180° to 185°, which corresponds to -175°. In this case, it travels a total angle of 6°. Example 2: Axis orientation interpolation Consider again the gantry having a C-axis with a value range of -180° to 180°. The start orientation is C=179°, and the target orientation is C=-175°. The axis interpolation moves the C-axis of the gantry proportionally to the traveled distance on the path from 179° in the negative direction past 0° to -175°, traveling a total angle of 354°. (If the great circle interpolation was used in this example, then an error would have occurred, because the workspace of the C axis would have been exceeded.) These two types of interpolation differ in some important characteristics. In great circle interpolation, the change in the orientation of the tool can be predicted. In the axis interpolation, it is difficult to predict the change in orientation, because the orientation axes can affect the orientation differently depending on the position. The axis orientation interpolation shares this characteristic with PTP movements. (However, this does not mean that it is difficult to predict the path in space for axis orientation interpolation. The path is the same for both types of orientation interpolation, and the TCP always travels the defined contour exactly.) With great circle interpolation, singularities in the orientation kinematics cannot be traveled. This is easily possible with axis interpolation. In great circle interpolation, violations to the axis limits of the orientation axes can result, as mentioned in the second example. When commanding, it is therefore required to make sure that no axis limits are violated when traveling to the target orientation with the shortest rotation. With axis interpolation, it is possible to rotate more than 360°. If an orientation axis has a workspace of more than 360°, then you can travel to position 540°, for example, instead of to position 180°. This corresponds to the same orientation of the tool. With great circle interpolation, this is not possible. The shortest rotation to the target orientation always corresponds to a total angle of 180° at most. The axis orientation interpolation requires coupled kinematics that consist of position and tool kinematics. The position part has to implement the interface ISMPositionKinematics_Offset2 . If the kinematics do not have any rotary axes and they implement the interface ISMPositionKinematics , then the selected orientation mode ( SMC_Orientation_Mode ) is ignored. Singularities in axis orientation interpolation With axis orientation interpolation, a path movement can take place through the singularities of the orientation kinematics, which can make the programming significantly easier. The singularities of the position kinematics change for this purpose. In the case of large circular interpolation, Scara3_Z has a singularity if the flange point (A3) is located on the straight line defined by the first arm part (if the second joint angle is 0°). For axis orientation interpolation, the singularities of the position kinematics change so that the TCP takes on the role that the flange point (A3) has otherwise. This singularity occurs when the TCP (not the flange point) is located on the straight line defined by the first arm part. When commanding a movement with axis orientation interpolation, it is checked whether or not this changed singularity is located between the start and target positions of the movement. If so, then the movement is not accepted and an error is issued. For 6-axis articulated arm robots, the situation is comparable to Scara3_Z, but two singularities are possible. The first occurs when the TCP is located on the straight line through A2 and A3. The second occurs when the TCP is located on the line through A1. The commanding also checks here that no singularity is traveled through. It can happen that the configuration of Scara3 (or the 6-axis articulated arm robot) changes when traveling with axis orientation interpolation. However, at the end of the movement the same configuration that the robot had at the starting point is always applied. " }, 
{ "title" : "Additional Axes ", 
"url" : "_sm_additional_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Additional Axes ", 
"snippet" : "Additional axes are axes which are part of the axis group but not part of the kinematics. They can be moved synchronously with the coordinated movement of the kinematics. The additional axes and the kinematics' axes start moving and reach their target position at the same time. Additional axis movem...", 
"body" : "Additional axes are axes which are part of the axis group but not part of the kinematics. They can be moved synchronously with the coordinated movement of the kinematics. The additional axes and the kinematics' axes start moving and reach their target position at the same time. Additional axis movements are buffered and blended together with coordinated movements. The same applies to pure additional axis movements, without any movement of the kinematics. " }, 
{ "title" : "Differences compared to single-axis movements ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062102818545", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Additional Axes \/ Differences compared to single-axis movements ", 
"snippet" : "The main difference compared to single-axis movements which are commanded with function blocks such as MC_MoveAbsolute or MC_MoveRelative is the synchronization of the movement. If synchronization is not important, then it could make sense to command the axes with single-axis function blocks because...", 
"body" : "The main difference compared to single-axis movements which are commanded with function blocks such as MC_MoveAbsolute or MC_MoveRelative is the synchronization of the movement. If synchronization is not important, then it could make sense to command the axes with single-axis function blocks because then the axes might be moved more quickly. Another difference is that additional axes are managed together with the axis group. They are enabled with SMC_GroupPower and errors can be reset together with MC_GroupReset . It should be noted that a single-axis error of an additional axis will lead to an axis group error. " }, 
{ "title" : "Commanding additional axis movements ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062103093337", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Additional Axes \/ Commanding additional axis movements ", 
"snippet" : "When commanding additional axis movements, you can always choose between absolute and relative movements, regardless of whether the main movement of the axis group is absolute or relative. For example, a relative additional axis movement can be commanded synchronously with an MC_MoveLinearAbsolute c...", 
"body" : "When commanding additional axis movements, you can always choose between absolute and relative movements, regardless of whether the main movement of the axis group is absolute or relative. For example, a relative additional axis movement can be commanded synchronously with an MC_MoveLinearAbsolute command. Additional axis movements are commanded via the AdditionalAxes input of the motion function blocks for the axis group. For example, an absolute PTP movement with a relative additional axis movement can be commanded as follows: If only the additional axes should be moved, then a coordinated movement of length 0 (for example, MC_MoveDirectRelative with distance 0 ) can be commanded together with an additional axis movement. " }, 
{ "title" : "Notes ", 
"url" : "_sm_additional_axes.html#UUID-25d97eef-abb9-89f9-289f-9830ecb23125_section-idm235062106608843", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Additional Axes \/ Notes ", 
"snippet" : "Modulo axes are also supported as additional axes. They are always operated in shortest mode for absolute additional axis movements. For more information, see the following: MC_DirectionMC_Direction The maximum number of additional axes is limited by the library parameter MAX_NUM_ADDITIONAL_AXES fro...", 
"body" : "Modulo axes are also supported as additional axes. They are always operated in shortest mode for absolute additional axis movements. For more information, see the following: MC_DirectionMC_Direction The maximum number of additional axes is limited by the library parameter MAX_NUM_ADDITIONAL_AXES from the SM3_CPKernelDefaults library. This parameter can be changed in the Library Manager. For an example on how to use additional axes, see the following: Using Additional Axes in Robotics" }, 
{ "title" : "Tolerances for Path Accuracy ", 
"url" : "_sm_path_accuracy_tolerances.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Tolerances for Path Accuracy ", 
"snippet" : "Tolerances for path accuracy can be set for axis groups. In the event of an unexpected movement of a dynamic coordinate system, these tolerances allow an axis group to catch up with this coordinate system instead of stopping with error SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED , SMC_AXIS_GROUP_MAX_POSITI...", 
"body" : "Tolerances for path accuracy can be set for axis groups. In the event of an unexpected movement of a dynamic coordinate system, these tolerances allow an axis group to catch up with this coordinate system instead of stopping with error SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED , SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED , or SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED . " }, 
{ "title" : "Overview ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4560250800668834033944790208", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Tolerances for Path Accuracy \/ Overview ", 
"snippet" : "Why are tolerances necessary for path accuracy? Ideally, the axis group should follow the path exactly. However, if a dynamic coordinate system is used (for example, an object on a belt or rotary table, or a coordinate system specified by another axis group), then in some cases it is not possible to...", 
"body" : "Why are tolerances necessary for path accuracy? Ideally, the axis group should follow the path exactly. However, if a dynamic coordinate system is used (for example, an object on a belt or rotary table, or a coordinate system specified by another axis group), then in some cases it is not possible to follow the path. Example: A robot should place a part on a conveyor belt. The belt moves at a constant velocity, but just before the robot reaches the position to place the part, the belt accelerates unexpectedly. In this situation, the trajectory for placing the part has already been calculated, but with the assumption that the belt continues to move at a constant velocity. Therefore, the remaining movement may now lead to a violation of the maximum acceleration of one of the axes of the robot. In situations like this, the tolerances are important. They allow the axis group to deviate from the path within the specified limits and catch up with the coordinate system again. The path accuracy is controlled by a filter. The filter receives the planned trajectory ( q_ref ) and the last calculated target positions ( q_set ) as input. The output of the filter are the target positions ( q_set ), which are transferred to the drives. If q_ref violates one of the axis limits, then the filter leaves the path and follows the planned trajectory as closely as possible without violating an axis limit. As long as the lag between q_set and q_ref is within the tolerances, no error is output. The tolerances for the path accuracy consist of several values: Maximum lag of the TCP in technical units (default value: 1 u ) Maximum orientation error of the TCP in angular degrees (default value: 1 deg ) Maximum allowed lag of each axis in technical units of the axis (default value: infinity) " }, 
{ "title" : "Effect on administrative function blocks ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4579672191731234033944887183", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Tolerances for Path Accuracy \/ Effect on administrative function blocks ", 
"snippet" : "The values for position, velocity, acceleration, and jerk which are returned by the SMC_GroupReadSetPosition , SMC_GroupReadSetVelocity , SMC_GroupReadSetAcceleration , and SMC_GroupReadSetJerk function blocks are calculated based on the planned trajectory ( q_ref ). Therefore, they do not contain t...", 
"body" : "The values for position, velocity, acceleration, and jerk which are returned by the SMC_GroupReadSetPosition , SMC_GroupReadSetVelocity , SMC_GroupReadSetAcceleration , and SMC_GroupReadSetJerk function blocks are calculated based on the planned trajectory ( q_ref ). Therefore, they do not contain the contribution of the filter. On the other hand, the actual values of position, velocity, and jerk – which are returned by the MC_GroupReadActualPosition , MC_GroupReadActualVelocity , and MC_GroupReadActualAcceleration function blocks – are calculated based on the actual position of the drives of the axis group. Therefore, they also contain the contribution of the filter. The path dynamics which are returned by SMC_GroupReadPathDynamics with Source = MC_SOURCE.SET is based on the planned trajectory ( q_ref ) and is therefore not influenced by the filter. (For other values of the Source input, the contribution of the filter is included) Triggers always refer to the planned trajectory ( q_ref ). The time which is returned by MC_GroupReadTrigger is the time when the planned trajectory reaches the trigger. When the filter is active ( q_ref<>q_set ), the axis group does not usually reach the position and\/or time of the trigger exactly. Note: A movement reports Done only when both the planned trajectory ( q_ref ) has reached the end of the movement and the filter is not (or no longer) active (i.e. a possible lag has been eliminated). Then the set position ( q_set ) corresponds to the target position of the movement. " }, 
{ "title" : "Setting the tolerances and monitoring of the path deviation ", 
"url" : "_sm_path_accuracy_tolerances.html#UUID-281f0e90-7f1f-437b-2162-1931aa62fd8d_section-idm4575205545955234033945121691", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Tolerances for Path Accuracy \/ Setting the tolerances and monitoring of the path deviation ", 
"snippet" : "The tolerances can be set using the SMC_GroupSetPathTolerance function block. The status of the filter and the current lag between the planned trajectory q_ref and the set values q_set of the axis group can be monitored with the InSync , PositionLag , and OrientationLag outputs of MC_GroupReadStatus...", 
"body" : "The tolerances can be set using the SMC_GroupSetPathTolerance function block. The status of the filter and the current lag between the planned trajectory q_ref and the set values q_set of the axis group can be monitored with the InSync , PositionLag , and OrientationLag outputs of MC_GroupReadStatus . InSync = TRUE means that q_ref = q_set and that the filter is not active. InSync = FALSE means that q_ref<>q_set and that the filter is active. " }, 
{ "title" : "Buffering and Blending of Movements ", 
"url" : "_sm_robotics_blending.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Buffering and Blending of Movements ", 
"snippet" : "Movement commands can be buffered with CODESYS SoftMotion . For each commanded movement, it can be specified how the movement is buffered and how the blending should be performed from the preceding movement to the new movement. The commanded path is adjusted by rounding the corners so that the path ...", 
"body" : "Movement commands can be buffered with CODESYS SoftMotion . For each commanded movement, it can be specified how the movement is buffered and how the blending should be performed from the preceding movement to the new movement. The commanded path is adjusted by rounding the corners so that the path can be traveled without stopping. Whether or not a movement is buffered, and how it is done, can be configured by means of the BufferMode input of the movement block (for example, MC_MoveDirectAbsolute or MC_MoveCircularRelative ). For more information, see the following: MC_Buffer_MODE . The TransitionMode and TransitionParameter inputs determine how corners are rounded. For more information, see the following: MC_TRANSITION_MODE . For more information about movements, see the following: Function Blocks for Movements In blending modes, the TransitionMode must not be equal to TMNone . Blending between two movements starts at the earliest halfway through the first movement and ends at the latest halfway through the second movement. If the first movement has already been planned too far, then blending may no longer be possible with the set parameters. Then the blending area is reduced or blending is not possible anymore. In order to guarantee a successful blending, both movements should be commanded in the same cycle. " }, 
{ "title" : "Path dynamics when blending ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-idm43523137701146", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Buffering and Blending of Movements \/ Path dynamics when blending ", 
"snippet" : "If blending is performed between CP movements (between linear and circular segments), then it should be noted that the maximum path acceleration and the maximum path jerk may be exceeded during the blending. The shorter the blending range is, the more prominent this effect will be. However, the limi...", 
"body" : "If blending is performed between CP movements (between linear and circular segments), then it should be noted that the maximum path acceleration and the maximum path jerk may be exceeded during the blending. The shorter the blending range is, the more prominent this effect will be. However, the limits of the axes (the maximum axis acceleration and the maximum axis jerk) are always maintained. Therefore, if the maximum path acceleration is low and the maximum axis acceleration is high, then accelerations which are too high can occur when blending. This can be counteracted by means of the AccFactor input of the motion blocks, for example, by reducing the maximum axis acceleration for a movement. " }, 
{ "title" : "Features of TMStartVelocity ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-id235231378653745", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Buffering and Blending of Movements \/ Features of TMStartVelocity ", 
"snippet" : "The calculation of the blending points is based on an idealized velocity curve, which can deviate from the actual velocity curve. At this time, a deceleration ramp is simulated on the original path towards the blending point and an acceleration ramp and away from the blending point. The minimum from...", 
"body" : "The calculation of the blending points is based on an idealized velocity curve, which can deviate from the actual velocity curve. At this time, a deceleration ramp is simulated on the original path towards the blending point and an acceleration ramp and away from the blending point. The minimum from both the programmed path velocity and the estimated maximum path velocity resulting from the axis limits is used as the target velocity. In addition, when blending between straight lines, the angle between them is taken into account. A minimum curvature radius for the blending element results from the desired path velocity and the estimated dynamics limits. The points A' and B' result in turn from this radius and the angle between the straight lines. If the movements are slowed down during the blending process despite a set factor of 1, then increasing the factor may help. " }, 
{ "title" : "Example ", 
"url" : "_sm_robotics_blending.html#UUID-0f3bcd54-8acb-9726-543e-2e05b6ddc469_section-id235231380207819", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Buffering and Blending of Movements \/ Example ", 
"snippet" : "In a small example application, a workpiece is supposed to be picked up. The robot should first move above the workpiece and then downwards to pick it up. To reach the workpiece as fast as possible, travel between the two movements should not be stopped, but blended. Blending into the second movemen...", 
"body" : "In a small example application, a workpiece is supposed to be picked up. The robot should first move above the workpiece and then downwards to pick it up. To reach the workpiece as fast as possible, travel between the two movements should not be stopped, but blended. Blending into the second movement should begin ten units before the end of the first movement is reached. In order to meet the requirements, two movements must be commanded. The first movement ( moveAbove ) over the workpiece and the second movement ( moveDown ) downwards towards the workpiece. For the second movement, it must be defined how the movement should be buffered and blended. As shown in the following image, BlendingHigh is selected for the BufferMode . This defines that the movement should be buffered after the first movement and then blended. In addition, for the TransitionMode , TMCornerDistance is defined with a distance of 10 units to smoothly blend the first movement into the second movement. In order to set the two inputs TransitionMode and TransitionParameter appropriately, the SMC_CornerDistance function block is used. " }, 
{ "title" : "Waiting Between Movements ", 
"url" : "_sm_robotics_wait.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Waiting Between Movements ", 
"snippet" : "SoftMotion Robotics provides the capability of waiting for a specific time between two movements. This may be necessary, for example, when a robot is supposed to grip a workpiece at the target position of a movement before starting the next movement. Similarly to movements, the wait time is commande...", 
"body" : "SoftMotion Robotics provides the capability of waiting for a specific time between two movements. This may be necessary, for example, when a robot is supposed to grip a workpiece at the target position of a movement before starting the next movement. Similarly to movements, the wait time is commanded via the SMC_GroupWait function block. For more information about this function block, see: SMC_GroupWait . " }, 
{ "title" : "Stopping on the Path with MC_GroupHalt or MC_GroupStop ", 
"url" : "_sm_robotics_halt_stop.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Stopping on the Path with MC_GroupHalt or MC_GroupStop ", 
"snippet" : "The MC_GroupHalt and MC_GroupStop function blocks allow for stopping on the path, taking into account configurable deceleration and jerk limits. Stopping begins immediately. The deceleration and jerk limits for stopping can differ from those of the active movement and can be larger as well as smalle...", 
"body" : "The MC_GroupHalt and MC_GroupStop function blocks allow for stopping on the path, taking into account configurable deceleration and jerk limits. Stopping begins immediately. The deceleration and jerk limits for stopping can differ from those of the active movement and can be larger as well as smaller. They are maintained as long as the path is not left. In the middle of the path, for example, a smooth stop with low deceleration is possible. At the end of the path, however, deceleration is at least strong enough to prevent any traveling beyond the end. Difference between MC_GroupHalt and MC_GroupStop The main difference between MC_GroupHalt and MC_GroupStop is that an MC_GroupStop cannot be aborted and that subsequent movements are accepted only after the Execute input has been reset. An MC_GroupStop prevents the axis group from moving. Differentiation from MC_GroupInterrupt In contrast to MC_GroupHalt and MC_GroupStop , an MC_GroupInterrupt starts with a short delay and has no configurable deceleration and jerk limits. Instead, the limits of the active movement are used. After an MC_GroupInterrupt , the interrupted movement can be resumed with MC_GroupContinue . With the help of SMC_GroupSaveContinueData , this is also possible with MC_GroupHalt and MC_GroupStop . For more information, see: Interruption and Continuation of Movements. Behavior with movements in moving coordinate systems For movements in moving coordinate systems (for example, when the robot moves relative to a conveyor belt), an MC_GroupHalt or MC_GroupStop results in an absolute stop. Therefore, it is not stopped relative to the moving coordinate system. The axis group remains on the path which it would have traversed in the machine coordinate system (MCS) if no MC_GroupHalt or MC_GroupStop had been commanded. " }, 
{ "title" : "Movement Planning ", 
"url" : "_sm_robotics_factor_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Movement Planning ", 
"snippet" : "When a movement is commanded, for example with MC_MoveLinearAbsolute , the resulting velocity of the robot depends on the following factors: The maximum velocity, acceleration, and jerk configured for each axis of the axis group. (configured in the axis configuration). The upper bounds define for ea...", 
"body" : "When a movement is commanded, for example with MC_MoveLinearAbsolute , the resulting velocity of the robot depends on the following factors: The maximum velocity, acceleration, and jerk configured for each axis of the axis group. (configured in the axis configuration). The upper bounds define for each axis how fast it is allowed to move. The other limits which are explained below can only reduce the effective limits. They cannot increase them beyond these bounds. The maximum velocity, acceleration, and jerk which are provided as inputs to the movement function block. These upper bounds define how fast the TCP can move along the path. They apply in addition to the limits of the individual axes. The current override (see MC_GroupSetOverride ) and the ancillary limits for an axis group For a description of how all these limits are combined to compute the effective path and axis limits, see the help for SMC_GroupSetAncillaryAxisLimits , SMC_GroupSetAncillaryPathLimits , and SMC_GroupSetAxisLimitFactors . The programmed path of the robot For example, when blending between movements results in a very small curvature radius, the robot has to move slowly in order not to exceed the axis limits. Together, these factors determine the effective maximum velocity on the path. However, there is one more factor that can limit the achievable velocity: the performance of the PLC. If the performance is not sufficient for planning the movement, then the robot moves at a slower velocity. If, due to performance reasons, the planning algorithm cannot verify that it is safe to accelerate, then it will move at a slower velocity instead. For more information, see: Performance" }, 
{ "title" : "Interruption and Continuation of Movements ", 
"url" : "_sm_robotics_stop_continue_movements.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Interruption and Continuation of Movements ", 
"snippet" : "While an axis group is in motion, the movement can be stopped. This can be an intentional stop ( MC_GroupHalt , MC_GroupStop ), or a pause on the path ( MC_GroupInterrupt ), or a halt due to an error. In all cases, CODESYS SoftMotion provides function blocks to move the axis group back to the planne...", 
"body" : "While an axis group is in motion, the movement can be stopped. This can be an intentional stop ( MC_GroupHalt , MC_GroupStop ), or a pause on the path ( MC_GroupInterrupt ), or a halt due to an error. In all cases, CODESYS SoftMotion provides function blocks to move the axis group back to the planned path and continue it. Stopping a movement due to an error If a movement is stopped in motion due to an error, then the individual axes of an axis group are halted individually and switched to the error state. In the process, the TCP leaves the planned path. Now you can acknowledge the error, reset the axis group, and move to the position where the error was detected. Afterwards, you can instruct the axis group to continue the previously planned movements. You use the SMC_GroupEnableResumeAfterError function block to enable the function to resume the programmed movements after an error. The function block has to be called cyclically in the bus cycle task. Only one instance of this function block may be called per axis group. If the axis group detects an error and switches to the state Errorstop , then it saves the already accepted movements and the necessary status information in a variable of type SMC_AXIS_GROUP_CONTINUE_DATA . Then this variable contains the \"continue data\" and is passed as an input of SMC_GroupEnableResumeAfterError . This allows you to resume the movements later using MC_GroupContinue . If the errors are caused by the commanded movements (for example, workspace violations or an invalid arc radius), then they cannot be resolved in this way. These errors will occur again after the movement continues. The mechanism is intended more for single-axis errors and other external events that force the axis group into the error stop. MC_GroupContinue requires the axis group to be at a specific position when continuing the movement. In case of resuming after an error, this position is the current position at the time the error was detected. You can use the SMC_GroupGetContinuePosition function block to get this position. If an axis group error does not allow the continuation of the movement (such as an internal error when writing the continue data), then MC_GroupContinue and SMC_GroupGetContinuePosition return the new error ID SMC_AXIS_GROUP_CONTINUE_DATA_NOT_WRITTEN . If an MC_GroupStop is active when the error occurs, then MC_GroupStop is also reactivated when the movement continues. The axis group has already been stopped, and the MC_GroupStop has deleted all pending movements so that no movement occurs. When an axis group error occurs, the function block instance of the active movement issues the error (outputs Active and Busy switch to FALSE , and output Error switches to TRUE ). The function block instances of buffered or blended movements, which have not become active yet, also issue an error. After restarting, all of these function block instances are reset to Busy \/ Active and their outputs reset to Error \/ CommandAborted . " }, 
{ "title" : "Stopping a movement by pausing ", 
"url" : "_sm_robotics_stop_continue_movements.html#UUID-5b8e7899-940c-fb66-b17a-ee1b74aa00fd_id_d17b9abed7a5b50cc0a864636890315c_id_74b10b31cbbdb856c0a8646354735c5f", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Interruption and Continuation of Movements \/ Stopping a movement by pausing ", 
"snippet" : "You can use the MC_GroupInterrupt and MC_GroupInterruptAt function blocks to interrupt the execution of the commanded movements. For MC_GroupInterrupt , an immediate stop is executed. For MC_GroupInterruptAt , a stop is executed at a specific position. Then the movement can be resumed later with MC_...", 
"body" : "You can use the MC_GroupInterrupt and MC_GroupInterruptAt function blocks to interrupt the execution of the commanded movements. For MC_GroupInterrupt , an immediate stop is executed. For MC_GroupInterruptAt , a stop is executed at a specific position. Then the movement can be resumed later with MC_GroupContinue . The function block MC_GroupInterruptAt provides the input SMC_GroupInterruptPositionMvtRel . This specifies an interrupt position relative to a movement. The movement is referenced by its SMC_Movement_Id . The position within the movement is defined by a value (real) between 0 and 1, where 0 is the beginning of the movement and 1 is the end. A position between the points B and A is interpreted exactly as if there were no blending. A position between P start and B or between A and P dest is projected on the blending path. Error handling for MC_GroupInterruptAt When the specified movement ID is unknown, the function block returns an error. The running movement is not interrupted. If the current dynamic state of the axis group does not allow reaching the standstill before the specified interrupt position, then SMC_GroupInterruptAt behaves exactly like MC_GroupInterrupt : the interruption is executed immediately and the axis group reaches the standstill somewhere behind the commanded interrupt position. All other errors are handled exactly like for MC_GroupInterrupt . Limitations of MC_GroupInterruptAt An interrupt at a specific position can be aborted with another movement as long as the process of stopping at the interrupt position has not started yet. Only one interrupt can be commanded at a specific position at the same time. If an interrupt has been commanded, then it has to be either completed or aborted so that another interrupt can be accepted. When you execute MC_GroupInterrupt or MC_GroupInterruptAt , a path-invariant stop is executed at first, similar to an MC_GroupHalt . Then the state of the axis group (\"continue data\") is stored in a variable transferred by the user (type SMC_AXIS_GROUP_CONTINUE_DATA ). Now the axis group is in the state GroupStandby and can be used normally. A typical example would be that the axis group is jogged. Later, you can use MC_GroupContinue to continue the interrupted execution. To do this, transfer the saved \"continue data\". For this to work without errors, the position of the axis group has to match the position it had after execution of MC_GroupInterrupt . (See SMC_GroupGetContinuePosition .) When a tracking movement has been interrupted (meaning a movement that was commanded relative to a dynamic coordinate system), MC_GroupInterrupt does not stop absolutely (like MC_GroupHalt ), but relatively to the dynamic coordinate system. For example, if a workpiece is tracked on a rotary table, MC_GroupInterrupt halts with respect to the workpiece. The axis group continues to follow the workpiece. The continue data has to get updated with SMC_GroupUpdateContinueData if the kinematic has rotary axes with multiple periods. Afterwards, the movement can be continued with MC_GroupContinue . The variable of type SMC_AXIS_GROUP_CONTINUE_DATA must not be stored persistently or changed during an online change. Using the function block SMC_GroupWait , you can wait on the path between two movements for a programmable time. " }, 
{ "title" : "Movement stop via MC_GroupHalt or MC_GroupStop ", 
"url" : "_sm_robotics_stop_continue_movements.html#UUID-5b8e7899-940c-fb66-b17a-ee1b74aa00fd_id_d17b9abed7a5b50cc0a864636890315c_id_28e8e9a71ed1fa93c0a8646375852228", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Interruption and Continuation of Movements \/ Movement stop via MC_GroupHalt or MC_GroupStop ", 
"snippet" : "After a movement stop triggered by MC_GroupHalt or MC_GroupStop , the movement of the axis group can be continued by using SMC_GroupSaveContinueData and MC_GroupContinue without any loss of information. This POU saves the current status, the current position, and all commanded movements. As a result...", 
"body" : "After a movement stop triggered by MC_GroupHalt or MC_GroupStop , the movement of the axis group can be continued by using SMC_GroupSaveContinueData and MC_GroupContinue without any loss of information. This POU saves the current status, the current position, and all commanded movements. As a result, the movement can be continued later from exactly this position. Behavior before version 4.12.0.0: The SMC_GroupSaveContinueData function block has to be called in the same cycle where MC_GroupHalt or MC_GroupStop is called. At this time, you need to make sure that SMC_GroupSaveContinueData is called before MC_GroupHalt or MC_GroupStop . Otherwise, the aborted movements will be removed from the queue. Behavior as of version 4.12.0.0: The SMC_GroupSaveContinueData function block can be called at any time up to the first movement after calling MC_GroupHalt or MC_GroupStop . The continuation position is the current axis group position at the time of the first call of the function block. The saved path consists of all movements which have been accepted before the halt\/stop command. To be able to continue the path at the position where the axis group stopped due to MC_GroupHalt or MC_GroupStop , SMC_GroupSaveContinueData should be called in the cycle where MC_GroupHalt or MC_GroupStop sets the Done signal. Only one instance of SMC_GroupSaveContinueData may be called per axis group. Saving the current status before the halt\/stop command may take several cycles, but it is guaranteed that the status information in the first cycle will be saved before any interrupted movements. SMC_GroupSaveContinueData can be called at any time to save the current state, not only in connection with calling MC_GroupHalt or MC_GroupStop . " }, 
{ "title" : "Interaction with Single-Axis Movements ", 
"url" : "_sm_additional_axes_single_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Interaction with Single-Axis Movements ", 
"snippet" : "Each axis of an axis group (including any additional axes) can also be moved with single-axis movements. This does not require the axis to be removed from the axis group. The following rules are used: If the axis group is in the GroupStandby state when a single-axis movement is commanded on one of i...", 
"body" : "Each axis of an axis group (including any additional axes) can also be moved with single-axis movements. This does not require the axis to be removed from the axis group. The following rules are used: If the axis group is in the GroupStandby state when a single-axis movement is commanded on one of its axes, then the axis group remains in this state. For more information, see the following: Axis Group StatesIf the axis group is in the GroupMoving state when a single-axis movement is commanded on one of its axes, then the axis group switches to the GroupError state. The error SMC_AXIS_GROUP_INTERRUPTED_BY_SINGLE_AXIS is reported and all other axes are stopped. If a movement is commanded on the axis group while a single-axis movement is active on at least one of its axes, then the axis group goes into the GroupError state. " }, 
{ "title" : "Synchronization with a Moving Coordinate System ", 
"url" : "_sm_robotics_dynamic_tracking.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Synchronization with a Moving Coordinate System ", 
"snippet" : "The integrated tracking function allows programming of motions relative to a moving coordinate system. A typical use case is picking up a product from a conveyor belt and placing it on a different conveyor belt. After defining a dynamic coordinate system for each belt, the user can simply provide ta...", 
"body" : "The integrated tracking function allows programming of motions relative to a moving coordinate system. A typical use case is picking up a product from a conveyor belt and placing it on a different conveyor belt. After defining a dynamic coordinate system for each belt, the user can simply provide target positions for movements that are relative to these coordinate system. CODESYS SoftMotion takes care of superposing the commanded movement of the axis group and the movement of the belt. A typical tracking motion consists of three phases: Tracking in: Moving from another coordinate system into the dynamic coordinate system. After the target position has been reached, the axis group will follow the motion of the dynamic coordinate system. Tracking movement: Moving to a different position inside the same dynamic coordinate system. The commanded movement and the motion of the dynamic coordinate system will be superposed. Tracking out: Moving from the dynamic coordinate system to a different coordinate system. After the target position has been reached, the motion of the axis group will no longer be influenced by the motion of the dynamic coordinate system. " }, 
{ "title" : "Defining a dynamic coordinate system ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4599737357387233382157942652", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Synchronization with a Moving Coordinate System \/ Defining a dynamic coordinate system ", 
"snippet" : "The first step of implementing a dynamic tracking application is defining a dynamic coordinate system. CODESYS SoftMotion provides four function blocks for defining dynamic coordinate systems: MC_TrackConveyorBelt : An easy-to-use function block for the common use case of tracking a conveyor belt. A...", 
"body" : "The first step of implementing a dynamic tracking application is defining a dynamic coordinate system. CODESYS SoftMotion provides four function blocks for defining dynamic coordinate systems: MC_TrackConveyorBelt : An easy-to-use function block for the common use case of tracking a conveyor belt. A reference to the actual belt is provided via the ConveyorBelt input, which expects a SoftMotion axis of type AXIS_REF_SM3 . MC_TrackRotaryTable : An easy-to-use function block for the common use case of tracking a rotary table. A reference to the actual rotary table is provided via the RotaryTable input, which expects a SoftMotion axis of type AXIS_REF_SM3 . MC_SetDynCoordTransform : The function block works similar to MC_TrackConveyorBelt and MC_TrackRotaryTable , but, instead of being controlled by a single axis, is controlled by a full axis group. This allows implementing a dynamic coordinate systems with up to six degrees of freedom. SMC_SetDynCoordTransformEx : The function block allows implementing a completely custom dynamic coordinate system. Each of the four function blocks has a CoordSystem input that essentially allows giving the coordinate system a name, either PCS_1 or PCS_2 . When commanding a movement, the coordinate system is referenced by this name. " }, 
{ "title" : "Commanding a movement to a position in a dynamic coordinate system ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4620464078688033382158385681", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Synchronization with a Moving Coordinate System \/ Commanding a movement to a position in a dynamic coordinate system ", 
"snippet" : "After having defined a dynamic coordinate system, commanding a movement to a position in this coordinate system is easy. Each movement function block, for example MC_MoveLinearAbsolute , has a CoordSystem input. This input has to be set to the name ( PCS_1 or PCS_2 ) given to the dynamic coordinate ...", 
"body" : "After having defined a dynamic coordinate system, commanding a movement to a position in this coordinate system is easy. Each movement function block, for example MC_MoveLinearAbsolute , has a CoordSystem input. This input has to be set to the name ( PCS_1 or PCS_2 ) given to the dynamic coordinate system. The Position input can then be set to the desired position relative to the origin of the dynamic coordinate system. Executing the movement function block will lead to a movement to the position inside the moving coordinate system. Once the target position has been reached, the axis group will follow the dynamic coordinate system while staying at this relative position. " }, 
{ "title" : "The \"InUse\" output of dynamic coordinate system function blocks ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4663886345662433382158689616", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Synchronization with a Moving Coordinate System \/ The \"InUse\" output of dynamic coordinate system function blocks ", 
"snippet" : "Each dynamic coordinate system function block ( MC_TrackConveyorBelt , MC_TrackRotaryTable , MC_SetDynCoordTransform , and SMC_SetDynCoordTransformEx ) has an InUse output. Restarting a function block while the coordinate system is still in use is not allowed and will result in the error SMC_AXIS_GR...", 
"body" : "Each dynamic coordinate system function block ( MC_TrackConveyorBelt , MC_TrackRotaryTable , MC_SetDynCoordTransform , and SMC_SetDynCoordTransformEx ) has an InUse output. Restarting a function block while the coordinate system is still in use is not allowed and will result in the error SMC_AXIS_GROUP_PCS_STILL_IN_USE . A dynamic coordinate system will become in use as soon as a movement to a position in the coordinate system is commanded. It will remain in use until a target position in a different coordinate system has been reached. " }, 
{ "title" : "Axis limits for tracking movements ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4557758355867233382158929251", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Synchronization with a Moving Coordinate System \/ Axis limits for tracking movements ", 
"snippet" : "The axis limits have to account for both the motion of the coordinate system as well as the commanded movement relative to the coordinate system. If high axis dynamics are required in order to follow the coordinate system, the movement relative to the coordinate system might be slow or not possible ...", 
"body" : "The axis limits have to account for both the motion of the coordinate system as well as the commanded movement relative to the coordinate system. If high axis dynamics are required in order to follow the coordinate system, the movement relative to the coordinate system might be slow or not possible at all. If the axis group is close to a singularity of the kinematics, this can even happen with a relatively slow moving coordinate system. For more information, see: Tab: General" }, 
{ "title" : "Path dynamics of CP movements while tracking ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm466388653271043338215917861", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Synchronization with a Moving Coordinate System \/ Path dynamics of CP movements while tracking ", 
"snippet" : "Special consideration has to be given to the path dynamics of CP movements. This includes the Velocity , Acceleration , Deceleration , and Jerk inputs of MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute , and MC_MoveCircularRelative . If start and target position are in the sa...", 
"body" : "Special consideration has to be given to the path dynamics of CP movements. This includes the Velocity , Acceleration , Deceleration , and Jerk inputs of MC_MoveLinearAbsolute , MC_MoveLinearRelative , MC_MoveCircularAbsolute , and MC_MoveCircularRelative . If start and target position are in the same dynamic coordinate system, the path dynamics will be relative to this coordinate system. However, if start and end position are in different coordinate systems the path dynamics are blended from dynamics relative to the first coordinate system to dynamics relative to the second coordinate system. It is important that the path dynamics are set higher than the absolute value of the difference in dynamics between the two coordinate systems. In particular, when moving from a static to a dynamic coordinate system, the path dynamics should be set higher than the absolute value of the dynamics of the coordinate system. The path velocity cannot be monitored with SMC_GroupReadPathDynamics when moving between coordinate systems (tracking in, out or between different dynamic coordinate systems). SMC_GroupReadPathDynamics calculates the path dynamics relative to a specified coordinate system. In the case of tracking in or out or moving between dynamic coordinate systems, this is a movement that depends on two coordinate systems (start and destination coordinate systems differ). As a result, the SMC_GroupReadPathDynamics function block is not suitable to calculate the path dynamics for these cases. " }, 
{ "title" : "Avoid the errors SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED, SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED, or SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED. ", 
"url" : "_sm_robotics_dynamic_tracking.html#UUID-8bce564d-cdd4-e83b-737b-4a9187722f07_section-idm4558812953211233382159412375", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Synchronization with a Moving Coordinate System \/ Avoid the errors SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED, SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED, or SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED. ", 
"snippet" : "The errors SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED , SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED , or SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED are reported if it is not possible to follow the commanded path without violating the configured axis limits or path dynamics. If this error occurs, it should f...", 
"body" : "The errors SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED , SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED , or SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED are reported if it is not possible to follow the commanded path without violating the configured axis limits or path dynamics. If this error occurs, it should first be checked whether the axis limits and path dynamics are configured according to the previous two sections. The path deviation can be monitored with the outputs PositionLag and OrientationLag of the MC_GroupReadStatus function block. Possible solutions are as follows: Increase the axis limits. Increase the path dynamics of CP movements when tracking into a dynamic coordinate system. Reduce the dynamics of the coordinate system. Avoid movements close to a singularity of the kinematics, for example by repositioning the robot. If the dynamic coordinate system is controlled by the output of a noisy encoder, then it might help to filter the encoder signal using a Logical Axis. For more information, see: Tab: Logical Axes. An acceptable tolerance for the position and orientation lag can be configured using the SMC_GroupSetPathTolerance function block. " }, 
{ "title" : "Rotary Axes with a Value Range over 360° ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Rotary Axes with a Value Range over 360° ", 
"snippet" : "Behavior in the case of CP movements During a CP movement ( MC_MoveLinearAbsolute \/ MC_MoveLinearRelative , MC_MoveCircularAbsolute \/ MC_MoveCircularRelative ), rotary axes are always traversed in automatic mode (Period 0). The period of the axis is always selected so that there is no jump in the ax...", 
"body" : "Behavior in the case of CP movements During a CP movement ( MC_MoveLinearAbsolute \/ MC_MoveLinearRelative , MC_MoveCircularAbsolute \/ MC_MoveCircularRelative ), rotary axes are always traversed in automatic mode (Period 0). The period of the axis is always selected so that there is no jump in the axis. It is possible that at the end of the CP movement, the commanded axis value would not be reached, but that the axis would arrive in a different period due to the automatic selection of the period. This means that the commanded position cannot be reached with the selected movement type. This conflict is detected before reaching the target position, and the axis group is halted and an error is issued. Example: You use a SCARA robot with three rotary axes A1, A2, and A3. A3 has a value range from -360° to +360°. You teach two positions in axis coordinates. Position1 = (A1 = 0°, A2 = 90°, A3 = 170°), Position2 = (A1 = 10°, A2 = 90°, A3 = -170°). Then you command a linear movement ( MC_MoveLinear\/MC_MoveAbsolute) ) with the orientation mode GreatCircle . This combination of commanding in ACS and great circle orientation interpolation creates a conflict. In order to follow the orientation interpolation, axis A3 would have to move from 170° in positive direction to 190°. Therefore, it cannot reach the required target position (-170°). Comment: In the case of CP movements, the period of the rotary axis is determined by the selected interpolation type. This also means that the target position of the axis depends on the path on which the target point is approached. It is therefore possible, for example, that by blending between two movements an axis arrives in a different period than would have been the case with buffered movements. For more information, see: Orientation Interpolation for CP Movements" }, 
{ "title" : "Introduction ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html#UUID-12fb3c35-3bac-219e-b53a-31166417b16d_id_da342072b79533ffc0a864635077a64a_id_48a1e2bdb79a4093c0a864631bc39e2b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Rotary Axes with a Value Range over 360° \/ Introduction ", 
"snippet" : "Robots often have rotary axes with a value range over 360°. For example, the last axis (orientation axis A3) of a SCARA robot can often travel more than one rotation, from about -540° to 540°. This means that the same position and orientation can be approached in multiple ways. Considering SCARA for...", 
"body" : "Robots often have rotary axes with a value range over 360°. For example, the last axis (orientation axis A3) of a SCARA robot can often travel more than one rotation, from about -540° to 540°. This means that the same position and orientation can be approached in multiple ways. Considering SCARA for example, the orientation and position of the tool is identical, regardless of whether the last axis is at -170° or at 190° (= -170° + 360°). As a result, the conversion of Cartesian position and orientation to axis values (the kinematic inverse transformation) is not unique, but has several solutions. This can be used, for example, in Pick&Place applications to save time by moving from 170° to 190° and not to -170°. Note: The movement of the SCARA orientation axis can quickly become a limiting factor for the cycle time in these applications. " }, 
{ "title" : "Resolution of ambiguity ", 
"url" : "_sm_robotics_rotation_axis_range_bigger_360.html#UUID-12fb3c35-3bac-219e-b53a-31166417b16d_id_da342072b79533ffc0a864635077a64a_id_e9620f70b79a4093c0a86463477a7031", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Rotary Axes with a Value Range over 360° \/ Resolution of ambiguity ", 
"snippet" : "If the points to be traversed are commanded in the axis coordinate system (ACS), then it is clear for each axis what value it will take in the target point. On the other hand, in Cartesian commanding (X\/Y\/Z-position and orientation in A\/B\/C) this ambiguity exists for rotary axes. The configuration o...", 
"body" : "If the points to be traversed are commanded in the axis coordinate system (ACS), then it is clear for each axis what value it will take in the target point. On the other hand, in Cartesian commanding (X\/Y\/Z-position and orientation in A\/B\/C) this ambiguity exists for rotary axes. The configuration of kinematics is used for resolving this ambiguity. With SCARA robots, the configuration already includes the setting whether the SCARA should approach a point with ElbowRight or ElbowLeft . In addition, the SCARA configuration also includes the setting nPeriodA3 , which can be used to determine how the ambiguity for axis A3 should be resolved. For this purpose, the entire value range is divided into periods of the maximum length of 360°: Period -1 from -540° to -180° Period 1 from -180° to 180° Period 2 from 180° to 540° (For a larger value range of the axis, there are correspondingly more possible periods.) There is also a special value. If nPeriodA3 := 0 is set, then an automatic resolution of ambiguity is activated. For PTP movements, this means that the period is selected so that the distance between the start and target positions for axis 4 is as small as possible. (The behavior with CP movements is described below.) It is therefore possible to control the resolution of the ambiguity of a rotary axis by setting the kinematic configuration accordingly (see SMC_SetKinConfiguration ). Kinematics that support this functionality implement the interface SMKinematicWithConfigurations3 . The SMC_GroupReadSetPosition , MC_GroupReadActualPosition , and SMC_GroupTargetPosition function blocks always output the configuration with the activated automatic resolution of the periods. The current configuration with explicitly set periods can be read out by reading the position in the ACS and then converting it to the MCS by means of SMC_GroupConvertPosition . The returned configuration has explicitly set periods. For more information, see: Kinematic Configurations" }, 
{ "title" : "Synchronization of External Axes, Torque Feed Forward Control ", 
"url" : "_sm_robotics_external_axis_torque_control.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Synchronization of External Axes, Torque Feed Forward Control ", 
"snippet" : "The axis values of the axes of an axis group are normally calculated at the end of the cycle after the application code programmed by the user has been run through. However, for certain applications it is necessary for these values to be available sooner in order to use them in the application code....", 
"body" : "The axis values of the axes of an axis group are normally calculated at the end of the cycle after the application code programmed by the user has been run through. However, for certain applications it is necessary for these values to be available sooner in order to use them in the application code. The SMC_GroupUpdate function block makes sure that the values of all axes which are part of an axis group are updated immediately. One use case for SMC_GroupUpdate is the synchronization of axes which are not part of the axis group. An example would be a second drive for the X-axis in the case of an XY gantry. Before CODESYS SoftMotion version 4.13.0.0: An additional use case for the SMC_GroupUpdate function block is torque feed forward control. The axis values calculated in the current cycle can be used to calculate the suitable set torques using a dynamic model of the robot. In CODESYS SoftMotion version 4.13.0.0 and higher: If a dynamic model has been assigned to the axis group using SMC_GroupSetDynamics , then the set torques are automatically calculated cyclically and can be used for torque feed forward control. The use of SMC_GroupUpdate is no longer necessary for this use case. For more information, see: Torque Limitation and Torque Feed Forward Control" }, 
{ "title" : "Triggers ", 
"url" : "_sm_digital_switches-1517880.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Triggers ", 
"snippet" : "Triggers are used to perform an action when the axis group reaches a defined position on the path. For example, a glue dispenser can be turned on when reaching the gluing position. Triggers also support time shifts so that the action can be performed at a precise time before or after the position is...", 
"body" : "Triggers are used to perform an action when the axis group reaches a defined position on the path. For example, a glue dispenser can be turned on when reaching the gluing position. Triggers also support time shifts so that the action can be performed at a precise time before or after the position is reached. This can be used, for example, to compensate the dead time of a glue dispenser. For this purpose, CODESYS SoftMotion provides the capability of configuring triggers to movements and then continuously reading out the remaining time until the position is reached. When using triggers, pay attention to the following: The time until a trigger is reached can be retrieved only when the axis group has approached the trigger up to the time of a configurable forecast. How this forecast is configured and which impacts the settings have is explained in the Configuring the application to use triggers section. The trajectory is not changed by the use of triggers. In particular, the trajectory is not slowed down in order to comply with the configured forecast. If, for example, the position of a trigger at the beginning of a movement is already reached after 0.01 seconds, then even a higher forecast cannot achieve that a notification is provided about reaching the point more than 0.01 seconds beforehand. For more information, see the examples Trigger Example 1: Simple Example and Trigger Example 2: Gluing Process. " }, 
{ "title" : "Configuring the application to use triggers ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4612456003211233798533752147", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Triggers \/ Configuring the application to use triggers ", 
"snippet" : "Configuration of the forecast duration The forecast duration determines how far in the future the planning is done. This is set by the fPlanningForecastDuration parameter of the SMC_TuneCPKernel function block. How this parameter should be set depends on the requirements of the application. There ar...", 
"body" : "Configuration of the forecast duration The forecast duration determines how far in the future the planning is done. This is set by the fPlanningForecastDuration parameter of the SMC_TuneCPKernel function block. How this parameter should be set depends on the requirements of the application. There are two principally contradictory requirements: Longest possible forecast duration Lowest possible latency. The latency when starting a movement increases because the forecast has to be established first. The size of this additional latency basically depends on the performance of the controller used and is generally much lower than the configured forecast. Moreover, the latency of the axis group to react to aborting movements and interrupts increases by the configured forecast. The forecast does not have any impact on MC_GroupHalt and MC_GroupStop . Both function blocks always act immediately and independently of the configured forecast. The fPlanningForecastDuration parameter of the SMC_TuneCPKernel function block should therefore be set as high as necessary but as low as possible. If a forecast is not required, then the parameter can be left at the default value of 0. The actual available forecast can differ from the configured one for various reasons, for example, if the end of the last movement is already almost reached. The current available forecast can be monitored by means of the CurrentPlanningForecast output of MC_GroupReadStatus . Configuration of the maximum number of triggers per movement As delivered, CODESYS SoftMotion supports up to 8 triggers per movement. If this number is not enough, then the MAX_NUM_TRIGGERS_PER_MOVEMENT parameter can be changed as a library parameter. This is possible with the Library Manager and the respective editor for the library parameters . For using library parameters, a CODESYS version >= SP19 is recommended. " }, 
{ "title" : "Commanding and evaluating triggers ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4620348699414433798534144567", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Triggers \/ Commanding and evaluating triggers ", 
"snippet" : "Two function blocks are available for commanding triggers: SMC_GroupPrepareTrigger and SMC_GroupReadTrigger . Triggers are assigned to a movement. Each individual trigger has to be prepared using the SMC_GroupPrepareTrigger function block. The position can be specified relative, absolute, or as an i...", 
"body" : "Two function blocks are available for commanding triggers: SMC_GroupPrepareTrigger and SMC_GroupReadTrigger . Triggers are assigned to a movement. Each individual trigger has to be prepared using the SMC_GroupPrepareTrigger function block. The position can be specified relative, absolute, or as an intersection with a plane (see SMC_TriggerPositionType ). The call order of SMC_GroupPrepareTrigger and the respective movement is of particular importance because the prepared triggers are assigned to the next movement commanded in the same cycle. Therefore, in every application you need to pay attention to the following: SMC_GroupPrepareTrigger always has to be called before the movement function block. Triggers and the respective movement always have to be commanded in the same cycle. If no movement is started in the cycle, then the prepared triggers are discarded and the CommandAborted output of the SMC_GroupPrepareTrigger function blocks is set. When the trigger is assigned to a movement, information about a trigger can be retrieved using SMC_GroupReadTrigger . As soon as the trigger is within the available forecast duration, the status changes to SMC_TRIGGER_STATUS.Active and the time until the trigger is reached can be read out. The time always refers to the start time of the current cycle. Depending on when the trigger should be triggered (before, during, or after the position is reached), the desired action can be executed in the application in a suitable cycle. Triggers cannot be aborted when they have been assigned to a movement. Instead, they can simply be ignored. If a movement is aborted by a second movement with MC_BUFFER_MODE.Aborting , then the triggers assigned to the first movement also disappear. " }, 
{ "title" : "Triggers for movements with blending ", 
"url" : "_sm_digital_switches-1517880.html#UUID-db9a0a5e-7480-9a21-cdb7-63f97b786d0c_section-idm4612455902227233798534431018", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Motion Control \/ Triggers \/ Triggers for movements with blending ", 
"snippet" : "For movements with Buffering and Blending of Movements, the triggers are projected onto the blending path. The following image qualitatively shows a case in which a movement from P1 to P2 as well as a subsequent movement were each commanded with blending. Blending to the first movement ends at point...", 
"body" : "For movements with Buffering and Blending of Movements, the triggers are projected onto the blending path. The following image qualitatively shows a case in which a movement from P1 to P2 as well as a subsequent movement were each commanded with blending. Blending to the first movement ends at point B, and blending to the subsequent movement starts at point A. The blue trigger is located between P1 and B. It gets projected onto the back half of the first blending movement (highlighted by the blue line). In the same way, the red trigger, located between A and P2, is projected onto the front half of the second blending movement (highlighted by the red line). The green trigger is outside of the blending areas and is not shifted. When blending with triggers, there is a special feature concerning the status of the movement and the respective triggers. The command function block for moving from P1 to P2 reports Done as soon as point A is reached. However, the red trigger associated with this movement remains active until the position on the blending element to which it was projected is reached. " }, 
{ "title" : "Torque Limitation and Torque Feed Forward Control ", 
"url" : "_sm_torque_limitation.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Torque Limitation and Torque Feed Forward Control ", 
"snippet" : "The torque limitation of CODESYS SoftMotion makes sure that specified limits of the torques or forces of the drives from being exceeded during coordinated movements. These limits of torques and forces are respected in addition to the existing limits for the velocity, acceleration, and jerk of the dr...", 
"body" : "The torque limitation of CODESYS SoftMotion makes sure that specified limits of the torques or forces of the drives from being exceeded during coordinated movements. These limits of torques and forces are respected in addition to the existing limits for the velocity, acceleration, and jerk of the drives. The requirement for this is a dynamic model for the applied kinematics in the form of a function block which implements the ISMDynamics interface from the SM3_Dynamics library. Basically, a AxesStateToTorque method is needed, which calculates the required torques for a given state of the axes (for their position, velocity, and acceleration). Besides the torque limitation, a dynamic model allows for the calculation of set torques for a torque feed forward control. You can find an application example in the chapter Dynamic Robot Model. " }, 
{ "title" : "Use cases ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4597660278291233422349551383", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Torque Limitation and Torque Feed Forward Control \/ Use cases ", 
"snippet" : "In many kinematics, especially serial kinematics, there is a coupling of multiple joints or all joints. A simple example of this is the double pendulum with drives in the joints as shown below: Use case 1 Use case 2 The drive in the first joint performs a 90° rotation; the second joint should not mo...", 
"body" : "In many kinematics, especially serial kinematics, there is a coupling of multiple joints or all joints. A simple example of this is the double pendulum with drives in the joints as shown below: Use case 1 Use case 2 The drive in the first joint performs a 90° rotation; the second joint should not move (use case 1). Assuming a passive second joint, it is easy to imagine that the second limb of the double pendulum will rotate to the left due to its inertia. To prevent this rotation, the drive in the second joint has to generate a torque to the right. Therefore, the movement of the first drive requires a reaction from the second drive. Coupling in the opposite direction exists, for example, in the case where the first drive should move at constant velocity while the second drive retracts the second limb of the double pendulum (use case 2). This reduces the inertia matrices of the double pendulum with respect to the first joint. To obtain the angular momentum (the product of the inertia matrices and the angular velocity), the angular velocity of the first joint needs to be increased. To hold the angular velocity constant, the angular momentum needs to be decreased by changing the torque of the first drive against its direction of rotation. Therefore, the movement of the second drive requires a reaction from the first drive. Without a dynamic model, only the set position, the set velocity, and the set acceleration can be sent to the drive. In the first case, a constant set position is defined for the second drive, regardless of whether or not the first joint is moving. The control unit in the second drive needs to be able to deal with the fact that a torque has to be generated in one case and not in another case for the same set values. The behavior is similar in the second case. Here, the same constant set velocity is specified to the first drive, regardless of whether or not the second joint is moving. Here too, the control unit in the drive needs to deal with the fact that different torques have to be generated for the same set values. With a dynamic model, the set torques can be calculated and sent to the drives. There they can be used as a feed forward dimension for the control units. As a result, the control unit receives additional information which allows for an improvement of the control quality. The torque limitation allows for more precise adherence to the limits of the drive. In many cases, it is not the limitation of the velocity or acceleration of the drive that is decisive, but the limitation of the torques. The advantages of torque limitation become clear from the example of the double pendulum as described above when the following movements are compared: a movement of the first drive with the second limb retracted and a movement of the first drive with the second limb extended. In the retracted state, the inertia matrices with respect to the first joint are less than in the extended state. For the same movement (the same velocity and acceleration curves of the drive), a greater torque is therefore required in the extended state than in the retracted state. Without a dynamic model, the velocity and acceleration limits need to be set so that the torque limits are adhered to in both states. This can cause the first drive to move at a lower velocity or acceleration in the retracted state than would be necessary to adhere to the torque limits of the drive. With a dynamic model, the torque limits can be configured, taken into account when planning the movement, and therefore fully utilized in both states. A slightly more complex example is the first case as described above, where the first drive is moving and the second drive should hold its position. The required torque in the second drive in order to hold its position depends on the movement of the first drive. If the first drive accelerates too sharply, then in principle the torque limit of the second drive may be violated. Without a dynamic model, this can only be prevented by configuring the acceleration limits of the first drive accordingly. With a dynamic model, the configured torque limit of the second drive can be taken into account when planning the movement and the acceleration of the first drive can be limited. In the case of more complex movements or kinematics, the coupling effects described here come together with even more coupling effects. A dynamic model allows these couplings to be taken into account, resulting in better set value specifications and better adherence to the limits of the drives. " }, 
{ "title" : "Configuration of the dynamic model ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4510933957710433418427140333", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Torque Limitation and Torque Feed Forward Control \/ Configuration of the dynamic model ", 
"snippet" : "An existing dynamic model in the form of a function block which implements the ISMDynamics interface can be assigned to an axis group by means of the SMC_GroupSetDynamics function block. Besides the dynamic model, the function block also has to be used to configure the direction and magnitude of the...", 
"body" : "An existing dynamic model in the form of a function block which implements the ISMDynamics interface can be assigned to an axis group by means of the SMC_GroupSetDynamics function block. Besides the dynamic model, the function block also has to be used to configure the direction and magnitude of the gravitational acceleration in the form of a vector in the machine coordinate system. " }, 
{ "title" : "Consideration of loads ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552490173838433418429772624", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Torque Limitation and Torque Feed Forward Control \/ Consideration of loads ", 
"snippet" : "Additional loads (for example, gripped objects or attached tools) can be taken into account by means of the SMC_GroupSetLoad function block and changed at runtime. The ExecutionMode input of the function block can be used to define when a load change should take effect (for example, immediately or o...", 
"body" : "Additional loads (for example, gripped objects or attached tools) can be taken into account by means of the SMC_GroupSetLoad function block and changed at runtime. The ExecutionMode input of the function block can be used to define when a load change should take effect (for example, immediately or only after the current movement has been completed). Continuation with MC_GroupContinue : When continuing, every movement which is stored in the continue data keeps the load with which it was originally commanded. Any movement which is commanded after the continuation uses the last set load. " }, 
{ "title" : "Consideration of a gearbox ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552678559262433422353734728", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Torque Limitation and Torque Feed Forward Control \/ Consideration of a gearbox ", 
"snippet" : "The set torques are calculated for the gearbox output and are not automatically converted to the drive. The SMC_SetAdditionalConversionFactors function block can be used to configure an additional conversion factor for the torque for each axis. The gearbox can also be taken into account in this way....", 
"body" : "The set torques are calculated for the gearbox output and are not automatically converted to the drive. The SMC_SetAdditionalConversionFactors function block can be used to configure an additional conversion factor for the torque for each axis. The gearbox can also be taken into account in this way. " }, 
{ "title" : "Units ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4597662777713633422354433707", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Torque Limitation and Torque Feed Forward Control \/ Units ", 
"snippet" : "Forces and torques and their limits are basically specified in the application in newtons (N) or newton meters (Nm). Before set forces or set torques are sent to the drives, a rescaling may be done. For this, the CiA 402 standard requires, for example, that set torques are sent to the drive in thous...", 
"body" : "Forces and torques and their limits are basically specified in the application in newtons (N) or newton meters (Nm). Before set forces or set torques are sent to the drives, a rescaling may be done. For this, the CiA 402 standard requires, for example, that set torques are sent to the drive in thousandths of the rated torque (in mNm). The unit for lengths is user-specific in SoftMotion. Because forces and torques are defined as a fixed unit (N or Nm), a conversion factor from a user-specific length unit to meters has to be configured (unless meters are used as length unit). This can be done with the SMC_GroupSetUnits function block. " }, 
{ "title" : "Torque limitation in moving coordinate systems ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4552049322772833422354993274", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Torque Limitation and Torque Feed Forward Control \/ Torque limitation in moving coordinate systems ", 
"snippet" : "If the axis group moves in a movable coordinate system, then the torque limits can be respected only when the axis group can follow the movable coordinate system exactly. If this is not possible and tolerances for the deviation are configured by means of SMC_GroupSetPathTolerance , then torque limit...", 
"body" : "If the axis group moves in a movable coordinate system, then the torque limits can be respected only when the axis group can follow the movable coordinate system exactly. If this is not possible and tolerances for the deviation are configured by means of SMC_GroupSetPathTolerance , then torque limits may be exceeded when trying to compensate the deviation. If an error occurs because the deviations are outside the tolerances, then the axis group stops. During this stop, the torque limits may also be exceeded. The set torques are calculated in each case and sent to the drives. " }, 
{ "title" : "Torque limitation in case of error ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4612699285196833422355410226", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Torque Limitation and Torque Feed Forward Control \/ Torque limitation in case of error ", 
"snippet" : "If an error is detected during the planning (for example, that a commanded movement will violate the workspace), then the axis group stops on the previously commanded path. In doing so, the torque limits are adhered to. If it is not possible to stop on the path (for example, because a drive reports ...", 
"body" : "If an error is detected during the planning (for example, that a commanded movement will violate the workspace), then the axis group stops on the previously commanded path. In doing so, the torque limits are adhered to. If it is not possible to stop on the path (for example, because a drive reports an error), then also the torque limits cannot be adhered to. " }, 
{ "title" : "Differences when using single-axis movements and coordinated movements ", 
"url" : "_sm_torque_limitation.html#UUID-3414897c-bc9f-19eb-07c5-a3031b03d6a8_section-idm4483062104566433422355806924", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Torque Limitation and Torque Feed Forward Control \/ Differences when using single-axis movements and coordinated movements ", 
"snippet" : "Basically, set torques are calculated for all axes which are part of an axis group with a dynamic model. This applies both at standstill and when the axis is traversed by means of single-axis movements (for example, MC_MoveAbsolute ) or the entire axis group is traversed by means of coordinated move...", 
"body" : "Basically, set torques are calculated for all axes which are part of an axis group with a dynamic model. This applies both at standstill and when the axis is traversed by means of single-axis movements (for example, MC_MoveAbsolute ) or the entire axis group is traversed by means of coordinated movements (for example, MC_MoveDirectAbsolute ). The torque limitation is active only for coordinated movements. The reason for this is that the necessary torques of an axis, as described above, depend on the position and movement of some or all of the other axes in the axis group. Therefore, a limitation of torque is possible only when all axes of the axis group can be moved as coordinated movements. An exception is the SMC_GroupJog functions block. This function block does not support torque limitation. It is recommended to use SMC_GroupJog2 instead. " }, 
{ "title" : "Diagnosis ", 
"url" : "_sm_robotics_diagnosis.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnosis ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Common Errors ", 
"url" : "_sm_robotics_errors.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnosis \/ Common Errors ", 
"snippet" : "This page describes common axis group errors, their causes, and possible actions to take to correct the error. For a list of all possible errors with a brief description, see the help page for SMC_ERROR (ENUM) . Error Code Explanation and Causes Actions SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED SMC_AXIS_...", 
"body" : "This page describes common axis group errors, their causes, and possible actions to take to correct the error. For a list of all possible errors with a brief description, see the help page for SMC_ERROR (ENUM) . Error Code Explanation and Causes Actions SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED The axis group cannot follow the commanded path without violating an axis limit (velocity, acceleration, or jerk). This error often occurs during tracking if the dynamic coordinate system moves unexpectedly. The error can also occur when the path passes close to a singular position of the robot. Singular positions occur between different configurations (for example, with the SCARA robot when the arm is fully extended). See Avoid the errors SMC_AXIS_GROUP_MAX_AXIS_LAG_EXCEEDED, SMC_AXIS_GROUP_MAX_POSITION_LAG_EXCEEDED, or SMC_AXIS_GROUP_MAX_ORIENTATION_LAG_EXCEEDED.If no dynamic coordinate system is used, then make sure that the path of the robot does not pass close to a singular position. SMC_CP_QUEUE_UNDERRUN The trajectory (velocity profile) of the axis group could not be calculated fast enough, and as a result the axis group has to abort the movement. Possible causes: Performance problems. The controller in use does not provide sufficient performance, or too much is calculated in a high-priority task. Unfavorable task settings: The calculation of the trajectory is displaced by other tasks. Computation-intensive commands. For example, it may require more computing time if a blending movement is interrupted by an aborting movement and this is then interrupted again by an aborting movement. The use of tracking (dynamic coordinate systems) also requires more computing time. The execution of SMC_GroupSaveContinueData during a movement and the use of many simultaneously active triggers can also increase the required computing time. Check whether or not the task settings for the planning task of the axis group have been selected correctly and, if possible, relocate this task to a separate and dedicated CPU core. For more information, see: Configuration of the Planning TaskOn the Monitoring tab of task configuration 1 check if a high-priority task requires a lot of computing time and, if possible, move performance-intensive calculations to a low-priority task. Use SMC_TuneCPKernel to increase the planning interval. For more information, see: Diagnosis in case of slow or jerky movementsNote: You can use the performance counters of SMC_GroupReadPlanningStatistics to determine the effect of these actions. For more information, see: Diagnosis in case of slow or jerky movementsSMC_TRAFO_INVALID_CONSTELLATION SMC_AXIS_POSITION_EXCEEDS_POSLIMITS SMC_AXIS_INVERSE_TRAFO_EXCEEDING_POSLIMITS The path is completely or partially outside of the workspace of the robot. Possible causes: The start or end point of a movement is outside of the workspace. Depending on the robot type, part of the movement of a CP movement may be outside of the workspace. A circular segment with a radius which is too large can lie within the workspace at the beginning and end, while the middle section leaves the workspace. When using tracking (dynamic coordinate systems), it is possible that a position which has previously been located within the workspace will leave the workspace over time due to the movement of the coordinate system. Note: When the error is reported, the axis group is not necessarily close to the problematic position. It is possible that the error is found and reported during the calculation of the trajectory and relates to a path segment which is still a long distance from the current position. Check the commanded movements and make sure that they are completely within the workspace. When using tracking: Use suitable limits to make sure that the axis group does not move out of the workspace over time. In Pick&Place with conveyor belts, for example, it is common practice to define a safe region where parts can still be picked up from the conveyor belt. After a part has left this region, the axis group should no longer move to the part. SMC_CP_CONFIGS_DIFFER SMC_CP_AXIS_ORIENTATION_IPO_CONFIG_DIFFERS The start and target positions of a CP movement are located in different configurations. The handling of configurations is explained in the Kinematic Configurations chapter. When using OrientationMode Axis , see the Orientation Interpolation for CP Movements chapter for details about configuring the orientation part of the robot. Possible actions: Make sure that the start and end positions of CP movements are located the same configuration. If necessary, use the SMC_SetKinConfiguration function block to set the configuration of the robot at the beginning (after MC_GroupEnable ). Use PTP movements to switch between configurations if desired. " }, 
{ "title" : "Performance ", 
"url" : "_sm_robotics_performance.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnosis \/ Performance ", 
"snippet" : "The planning of movements is done in a separate task because the computation is CPU-intensive. This separate task is referred to as the planning task and it runs in parallel with the bus task. If the performance of the PLC is not sufficient to plan the path in the planning task in time for the bus t...", 
"body" : "The planning of movements is done in a separate task because the computation is CPU-intensive. This separate task is referred to as the planning task and it runs in parallel with the bus task. If the performance of the PLC is not sufficient to plan the path in the planning task in time for the bus task, then these are performance problems. Performance problems in movement planning can lead to the SMC_CP_QUEUE_UNDERRUN error, but they can also lead to a movement which is jerky or slower than expected. For information about the SMC_CP_QUEUE_UNDERRUN error, see the Common Errors chapter. The diagnosis of performance-related problems with movements is described below. " }, 
{ "title" : "Diagnosis in case of slow or jerky movements ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm4597696111868834242456592379", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnosis \/ Performance \/ Diagnosis in case of slow or jerky movements ", 
"snippet" : "If there are no performance problems, then each movement is planned in such a way that at least one of the effective limits is reached during the entire movement. As an example, consider a simple two-dimensional gantry with two axes X and Y and a PTP movement from position (0,0) to (10,-10). The max...", 
"body" : "If there are no performance problems, then each movement is planned in such a way that at least one of the effective limits is reached during the entire movement. As an example, consider a simple two-dimensional gantry with two axes X and Y and a PTP movement from position (0,0) to (10,-10). The maximum axis velocity is 20, the maximum axis acceleration is 100, and the maximum axis jerk is 1000. The expected movement looks like this: Acceleration is first established with a maximum jerk until the acceleration limit value of 100 is reached. After a short phase of constant acceleration, the acceleration is reduced again with a maximum jerk so that the velocity limit value of 20 is reached with acceleration 0. After a phase of constant velocity, deceleration takes place so that the target position is reached with velocity and acceleration 0. There are two possible reasons why the real movement deviates from this ideal curve: The planned movement does not correspond to the ideal curve due to performance problems in the planning task. The planned movement corresponds to the ideal curve, but the robot does not execute it as expected. " }, 
{ "title" : "Case 1: Performance problems of the planning task ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433006527711", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnosis \/ Performance \/ Diagnosis in case of slow or jerky movements \/ Case 1: Performance problems of the planning task ", 
"snippet" : "If there are problems with the performance during the planning, then the movement might look like this instead: This is because the movement is planned in the planning task in parallel to execution in the bus task. On average, the planning task needs to provide as much trajectory as the bus task req...", 
"body" : "If there are problems with the performance during the planning, then the movement might look like this instead: This is because the movement is planned in the planning task in parallel to execution in the bus task. On average, the planning task needs to provide as much trajectory as the bus task requires. If the performance is not sufficient for this, then the movement is slowed down. This leads to the wavy velocity curve. The first and most important tool for diagnosing such problems is the trace. In addition to the fSetPosition , fSetVelocity , and fSetAcceleration variables for each axis, the numTimeBudgetExceeded and numSlowDownLowIpoQueue outputs of the SMC_GroupReadPlanningStatistics function block should also be recorded. If these counters increase continuously, then there is a performance problem. Similarly to the fSetPosition , fSetVelocity , and fSetAcceleration variables, there is also the fSetJerk variable for the jerk. It should be noted that the jerk is not the average jerk which is applied during the bus task cycle (as often expected), but rather the instantaneous jerk at the end of the cycle. Therefore, FSetJerk has only limited significance for diagnosing performance problems. " }, 
{ "title" : "Ways to improve the movement ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm43443300985204", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnosis \/ Performance \/ Diagnosis in case of slow or jerky movements \/ Case 1: Performance problems of the planning task \/ Ways to improve the movement ", 
"snippet" : "The following list contains steps to handle performance problems: Adjustment of the limit values for velocity, acceleration, and jerk: The longer it takes to decelerate from the current velocity to standstill, the greater the computing power required A high effective limit value for velocity and low...", 
"body" : "The following list contains steps to handle performance problems: Adjustment of the limit values for velocity, acceleration, and jerk: The longer it takes to decelerate from the current velocity to standstill, the greater the computing power required A high effective limit value for velocity and low effective limit values for acceleration and jerk are therefore more likely to lead to performance problems. In particular, the limit values for acceleration and jerk should therefore not be set unnecessarily low Increase the priority of the planning task or decrease the priority of the other tasks if they are blocking the planning task. The planning task should have the second highest priority after the bus task. Assign the planning task to a dedicated core if multiple CPU cores are available (see Configuration of the Planning Task). Use SMC_TuneCPKernel to increase the value of the fPlanningInterval and\/or fSyncBufferDuration planning parameters. The fPlanningInterval parameter specifies the maximum planning increment (in seconds). The cycle time of the planning task should not permanently exceed this value. A higher value reduces the computing power, but can also cause the set limit values for velocity, acceleration, and jerk not to be not fully utilized. From a starting value of 0.016 seconds (the default value since CODESYS SoftMotion version 4.6.0.0), the value should be gradually increased until the performance is acceptable. The fSyncBufferDuration parameter specifies the size of the buffer between the planning and bus task. The peak cycle times of the planning task must not exceed this value. A higher value can compensate for peaks in the cycle time of the planning task. At the same time, however, this also increases the latency for the execution of interrupts and aborting movements. " }, 
{ "title" : "Case 2: Robot does not follow the planned movement as expected ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433008452776", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnosis \/ Performance \/ Diagnosis in case of slow or jerky movements \/ Case 2: Robot does not follow the planned movement as expected ", 
"snippet" : "If the robot does not follow the planned movement as expected, then this may be due to the following reasons: Insufficient real-time capability of the controller Control loop problems of the drives On a non-real-time-capable controller such as the CODESYS Control Win , or a Linux-based controller wi...", 
"body" : "If the robot does not follow the planned movement as expected, then this may be due to the following reasons: Insufficient real-time capability of the controller Control loop problems of the drives On a non-real-time-capable controller such as the CODESYS Control Win , or a Linux-based controller without a real-time patch of the underlying Linux system, too slow or jerky movements can occur even with sufficient performance. This happens if the bus task is not executed on time in the configured time frame. " }, 
{ "title" : "Ways to improve the movement ", 
"url" : "_sm_robotics_performance.html#UUID-c0b27340-dcfd-2832-74fd-4abb5f5d4243_section-idm234433012326085", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnosis \/ Performance \/ Diagnosis in case of slow or jerky movements \/ Case 2: Robot does not follow the planned movement as expected \/ Ways to improve the movement ", 
"snippet" : "On the \"Monitoring\" tab of the task configuration 1 , check if the task jitter of the bus task 2 is too high. This may be the case either because the bus task is being displaced by a task with the same or higher priority, or because the controller is not sufficiently real-time capable. If the jitter...", 
"body" : "On the \"Monitoring\" tab of the task configuration 1 , check if the task jitter of the bus task 2 is too high. This may be the case either because the bus task is being displaced by a task with the same or higher priority, or because the controller is not sufficiently real-time capable. If the jitter is too high and you have already made sure that the bus task has the highest priority, then the real-time capability of the controller is not sufficient. In this case, use a controller with better real-time properties. If there are control loop problems in the drive, then you should adjust the control loop parameters. The torque feed forward control can also improve the control loop performace. For more information, see: Torque Limitation and Torque Feed Forward Control1 : It is advisable to reset the measured values of the task monitoring in the context menu because the first PLC cycle after starting the application often has an increased duration and increased jitter. 2 : Jitter values up to approx. 20 us are very good, and values up to approx. 100 us are good. Depending on the used drives, operation with higher jitter values may also work. Jitter values which reach the order of magnitude of the task interval of the bus task can result in the error pattern described above. " }, 
{ "title" : "Logging Information ", 
"url" : "_sm_information_logging.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Diagnosis \/ Logging Information ", 
"snippet" : "The SMC_GroupEventLogging function block was introduced with SoftMotion version 4.18.0.0. The function block can be used to enable log messages for an axis group. As soon as log messages are enabled, the axis group writes actions which it performs to the Log of the device. In this way, the events of...", 
"body" : "The SMC_GroupEventLogging function block was introduced with SoftMotion version 4.18.0.0. The function block can be used to enable log messages for an axis group. As soon as log messages are enabled, the axis group writes actions which it performs to the Log of the device. In this way, the events of the axis group can be tracked chronologically. This can be useful when investigating problems and unexpected behavior of the axis group. Assign names to your movements, loads, tools, etc. in order to get informative log messages. In CODESYS SoftMotion version 4.18.0.0 and higher, some command function blocks (such as MC_MoveLinearAbsolute , SMC_GroupSetTool and MC_SetCoordinateTransform ) have been provided with a new Name input. Logging can have a negative impact on performance and must therefore be enabled via the SMC_GroupEventLogging function block. In CODESYS SoftMotion version 4.18.0.0, messages are logged which relate to the path of the axis group. Category Action Description Additional Information Movement Movement starts The axis group has started the interpolation of a movement. OverviewMovement ends The axis group has completed the interpolation of a movement. Blending starts The axis group has started blending from the active movement to the next movement. Blending ends The axis group has completed blending and continues the interpolation on the next movement. Aborting starts The axis group has aborted the current movement and is blending to the aborting movement. Aborting ends The axis group has completed blending and continues the interpolation on the aborting movement. Waiting starts The axis group waits at the current position. Waiting ends The axis group has finished waiting. Halt\/stop starts The axis group has started to perform a halt\/stop on the path. Halt\/stop ends The axis group has performed the halt\/stop on the path. Tool Tool attached The axis group uses a new tool. Configuring a Tool OffsetLoad Load attached The axis group uses a new load. Torque Limitation and Torque Feed Forward ControlOverride Axis or path override changed The axis or path override has changed and has been applied by the axis group. MC_GroupSetOverride (FB) Path accuracy Path departed The axis group has departed the commanded path in order to avoid violating the axis limits. The axis group tries to reach the commanded path again. Tolerances for Path AccuracyPath reached again The axis group has reached the commanded path again. Interrupt–Continue Interrupt starts The axis group has started to execute an interrupt. Interruption and Continuation of MovementsInterrupt ends The axis group has executed the interrupt and saved the Continue data. Continue starts The axis group has read Continue data and starts to continue it. " }, 
{ "title" : "Examples ", 
"url" : "_sm_robotics_examples.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Jogging a Robot ", 
"url" : "_sm_robotics_jogging.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Jogging a Robot ", 
"snippet" : "See the Robotics_Jogging.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how to jog an axis group with the SMC_GroupJog2 POU. It is recommended to install the CODESYS Depictor for this example (the free demo version is suffici...", 
"body" : "See the Robotics_Jogging.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how to jog an axis group with the SMC_GroupJog2 POU. It is recommended to install the CODESYS Depictor for this example (the free demo version is sufficient). Alternatively, you could also remove the corresponding code parts from the example in order to use the example without Depictor. " }, 
{ "title" : "Application ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4584875037158433080105006434", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Jogging a Robot \/ Application ", 
"snippet" : "In order to demonstrate the most general case possible, the example has the following functions: Use of a robot with singularities (6-axis articulated robot). The example shows that you can move the robot through singularities in ACS and then continue jogging in a Cartesian way in a different config...", 
"body" : "In order to demonstrate the most general case possible, the example has the following functions: Use of a robot with singularities (6-axis articulated robot). The example shows that you can move the robot through singularities in ACS and then continue jogging in a Cartesian way in a different configuration. Shifting and rotation of the machine coordinate system (MCS) of the robot with respect to the world coordinate system (WCS). In this way, you can see how jogging differs in MCS and WCS. Configuration of a tool shifted and rotated with respect to the flange (F). In the figure below, you can see the tool and the shifting and rotation of the TCS with respect to the flange (F). An linear additional axis Add0 and a rotary additional axis Add1 . " }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4576391101379233081218831739", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Jogging a Robot \/ Structure of the application ", 
"snippet" : "Main program The main program PLC_PRG consists of a state machine, which Activates the axis group (state 0) Configures the tool (state 5) Configures the MCS (state 6) Starts the jogging (state 10) In state 20, jogging errors are handled and movement commands are accepted ( Move to Position switch in...", 
"body" : "Main program The main program PLC_PRG consists of a state machine, which Activates the axis group (state 0) Configures the tool (state 5) Configures the MCS (state 6) Starts the jogging (state 10) In state 20, jogging errors are handled and movement commands are accepted ( Move to Position switch in the visualization). The other states are used to perform the movement (60, 70) and to handle and acknowledge errors (900, 1000). According to the state machine, all robotics POUs and the GroupJog2 program are called cyclically and some calculations are done for the 3D display in Depictor. GroupJog2 program This program contains a state machine with the following steps: In state 10, the inputs of SMC_GroupJog2 are set and the configuration of the robot axes is read (SMC_GroupReadActualPosition). This configuration is done in state 20 in the axis group (SMC_SetKinConfiguration). In state 30, the system reacts to errors during jogging, as well as to changes in the settings of jogging (for example, to a changed coordinate system). If there is a change, then the system switches back to state 10. State 50 is entered on a falling edge of the Enable input. Jogging is stopped by MC_GroupHalt. " }, 
{ "title" : "Commissioning ", 
"url" : "_sm_robotics_jogging.html#UUID-bdb13fff-2907-67ad-ba57-f165eccd1e65_section-idm4584880854092833081221538291", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Jogging a Robot \/ Commissioning ", 
"snippet" : "Compile and start the created program. You can use the visualization to run the robot. You can define all relevant settings for jogging (for example, in which coordinate system is jogged and at which velocity). If you have installed the CODESYS Depictor , then it is recommended that you place the wi...", 
"body" : "Compile and start the created program. You can use the visualization to run the robot. You can define all relevant settings for jogging (for example, in which coordinate system is jogged and at which velocity). If you have installed the CODESYS Depictor , then it is recommended that you place the window with the Depictor ( Scene POU) next to the visualization window. The Depictor represents the TCS (Tool Coordinate System) at the front of the robot. Moreover, the current axis of rotation of the TCS is displayed in purple. This is useful to check the different types of orientation change (for example, test the ABC_as_ACS option and the TCS coordinate system). " }, 
{ "title" : "Interruption and Continuation of Movements ", 
"url" : "_sm_robotics_example_stop_continue.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Interruption and Continuation of Movements ", 
"snippet" : "The Robotics_Interrupt_Continue.project sample project described here is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how commanded movements can be interrupted with the SMC_GroupInterrupt function block and resumed at a later time with t...", 
"body" : "The Robotics_Interrupt_Continue.project sample project described here is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . This example shows how commanded movements can be interrupted with the SMC_GroupInterrupt function block and resumed at a later time with the SMC_GroupContinue function block. The axis group can perform any movement between interruption and continuation. " }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_robotics_example_stop_continue.html#UUID-0303b007-363c-c1b9-a999-ee926c8f8deb_section-idm4519127872464034232302809299", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Interruption and Continuation of Movements \/ Structure of the application ", 
"snippet" : "The application consists of a simple state machine in the PLC_PRG program and a trace to easily track the state transitions. First, the axes and axis group are enabled. ( STATE_POWER_ON ) Then, two movements, moveLinearA and moveLinearB , are commanded with blending. ( STATE_START_MOVING ) As soon a...", 
"body" : "The application consists of a simple state machine in the PLC_PRG program and a trace to easily track the state transitions. First, the axes and axis group are enabled. ( STATE_POWER_ON ) Then, two movements, moveLinearA and moveLinearB , are commanded with blending. ( STATE_START_MOVING ) As soon as the second movement is active (when blending begins), the movement is interrupted. The cause could be, for example, that a tool defect has been detected. (STATE_INTERRUPT ) A relative PTP movement is performed in the positive Z-direction, for example, to replace the tool after the defect. (STATE_INTERMEDIATE_MOVEMENT ) Before resuming, the system returns to the position where the original movement was interrupted. ( STATE_GET_CONTINUE_POS \/ STATE_MOVE_TO_CONTINUE_POS ) The original movement is resumed. (STATE_CONTINUE) " }, 
{ "title" : "Usage ", 
"url" : "_sm_robotics_example_stop_continue.html#UUID-0303b007-363c-c1b9-a999-ee926c8f8deb_section-idm4586020725065634232302901331", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Interruption and Continuation of Movements \/ Usage ", 
"snippet" : "Compile the created program and log in. To track the different states, you can download the trace to the controller. Start the application....", 
"body" : "Compile the created program and log in. To track the different states, you can download the trace to the controller. Start the application. " }, 
{ "title" : "Programming a Robot with Pick&Place ", 
"url" : "_sm_example_robotics.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Programming a Robot with Pick&Place ", 
"snippet" : "See the Robotics_PickAndPlace.project and Robotics_PickAndPlace_without_Depictor.project sample projects in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The Robotics_PickAndPlace.project project requires the installation of the CODESYS Depictor package. This project v...", 
"body" : "See the Robotics_PickAndPlace.project and Robotics_PickAndPlace_without_Depictor.project sample projects in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . The Robotics_PickAndPlace.project project requires the installation of the CODESYS Depictor package. This project visualizes the kinematics in a 3D animation. The project Robotics_PickAndPlace_without_Depictor.project shows a simplified form of the sequence in a visualization screen. This chapter covers only the objects which are relevant for SoftMotion . The example consists of a tripod, a rotary table, and a conveyor. The kinematics pick up a ring that is located on the rotary table. When picking up, the tool plate of the kinematics move synchronously with the rotary table. Then the ring is placed on a cone that is located on a conveyor belt. When placing, the kinematics move synchronously with the conveyor belt. Two buttons are located on the visualization screen for controlling the sequence. When you press the Auto button, the rings are set down automatically. Otherwise, the Play button appears for you to place the ring. Function Blocks: MC_TrackConveyorBelt and MC_TrackRotaryTable The MC_TrackRotaryTable function block, which is called in the Ring function block, is used for determining the PCS_1 partial coordinate system. This coordinate system is set when a ring is placed on the rotary table. The origin of the rotary table coordinate system RotaryTableOrigin is the midpoint of the rotary table. The Z-axis is the axis of rotation of the rotary table. The PCS_1 is rotated about the Z-axis of the rotary table coordinate system as a function of the input variable RotaryTable . Because the axis group moves in PCS_1, it follows the rotation of the table. The behavior is similar to the MC_TrackConveyorBelt function block, which is called in the Cone function block. In this case, the PCS ( PCS_2 ) follows the X-axis of the coordinate system ConveyorBeltOrigin . " }, 
{ "title" : "Structure\nof the project ", 
"url" : "_sm_example_robotics.html#UUID-39569b76-aa01-d4da-f1dd-395ea28c5771_id_e806d396dc0abefc0a864632a6f2305_id_9645ebb75a1273b0c0a8640e01c9af58", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Programming a Robot with Pick&Place \/ Structure\nof the project ", 
"snippet" : "CODESYS SoftMotion Controller Axis group Tripod : The axis group defines the kinematics and the mapping to the individual axes Tripod1 , Tripod2 , and Tripod3 . DepictorCalculations (PRG) , Environment (PRG) , Ring (FB) : Programs for controlling the complete sequence and visualization. These POUs a...", 
"body" : "CODESYS SoftMotion Controller Axis group Tripod : The axis group defines the kinematics and the mapping to the individual axes Tripod1 , Tripod2 , and Tripod3 . DepictorCalculations (PRG) , Environment (PRG) , Ring (FB) : Programs for controlling the complete sequence and visualization. These POUs are not relevant for understanding PLCopen blocks, except the definition of the product coordinate system (PCS_1 and PCS_2). Robot (PRG) : Program for controlling the movement sequences. A detailed description is located in the next paragraph. Visualization : Animated visualization for clarifying the sequence. Tripod1 , Tripod2 , Tripode3 : Linear axes of the tripod. DriveRotaryTable : Axis for the rotary table. DriveConveyorBelt : Axis for the conveyor belt. " }, 
{ "title" : "Structure of the Robot (PRG) sequential program ", 
"url" : "_sm_example_robotics.html#UUID-39569b76-aa01-d4da-f1dd-395ea28c5771_id_e806d396dc0abefc0a864632a6f2305_id_d2b72ec95a1273b5c0a8640e012cc527", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Programming a Robot with Pick&Place \/ Structure of the Robot (PRG) sequential program ", 
"snippet" : "The Robot (PRG) program is run in cycles. At this time, the individual steps are performed depending on the state . At the end of a program, the calls of all used function blocks are ready for motion commanding. The single axes of the tripod are activated (function blocks pwA1 , pwA2 , and pwA3 of t...", 
"body" : "The Robot (PRG) program is run in cycles. At this time, the individual steps are performed depending on the state . At the end of a program, the calls of all used function blocks are ready for motion commanding. The single axes of the tripod are activated (function blocks pwA1 , pwA2 , and pwA3 of type MC_Power ). CASE 0 : Wait for the participating axes to be operational. CASE 10 : Sets homing positions; in physical applications, homing is performed at this position (function blocks spA1 , spA2 , and spA3 of type MC_SetPosition ). CASE 20 : Placement of the machine coordinate system in the world coordinate system (function block setCoord of type MC_SetCoordinateTransform ). CASE 30 : Enable the axis group (function block enable of type MC_GroupEnable . Wait for a response that the axis group has applied all values. CASE 40 to CASE 130 : Pick&Place application: All movements are commanded possibly with a multiple instances MC_MoveDirectAbsolute , MC_MoveDirectRelative , and MC_MoveLinear which are called in cycles. A rising edge at the Execute input of these POUs in each status leads to issuing a new motion command in which the output bCommandAccepted indicates the success of the process. A typical chain of commands results from interrogating this output before the next motion command. " }, 
{ "title" : "Dynamic Robot Model ", 
"url" : "_sm_dynamic_robot_model.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Dynamic Robot Model ", 
"snippet" : "See the Robotics_DynamicModel.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . In order to limit the axis torques\/forces during a movement, a dynamic model is required which calculates these values from the current axis state (position, velocity,...", 
"body" : "See the Robotics_DynamicModel.project sample project in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . In order to limit the axis torques\/forces during a movement, a dynamic model is required which calculates these values from the current axis state (position, velocity, and acceleration). This example includes the following parts: Part 1 shows how to use an existing dynamic model in an application and the results of some sample movements. Part 2 shows how to create a dynamic model for a SCARA robot based on an algorithm which is presented in the book \"Modern Robotics\" by K. M. Lynch and F. C. Park. " }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4640407923376033369958289569", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Dynamic Robot Model \/ Structure of the application ", 
"snippet" : "Part 1: Using a dynamic model in an application The code for this part is located in the TorqueLimitationDemo folder. PLC_PRG is the main program, which includes a state machine that triggers test movements. The movements can be monitored using the Trace . Part 2: Creating a dynamic robot model The ...", 
"body" : "Part 1: Using a dynamic model in an application The code for this part is located in the TorqueLimitationDemo folder. PLC_PRG is the main program, which includes a state machine that triggers test movements. The movements can be monitored using the Trace . Part 2: Creating a dynamic robot model The code for the dynamic model is located in the DynModel folder. DynModel_Scara2_Z is the dynamic model of the SCARA robot. DynModel_Tests runs all tests of Test_DynModel_Scara2_Z to check for common mistakes. The dynamic model is based on a SCARA robot with two revolute joints and one prismatic Z-axis. A figure of the robot with the required dimensions and coordinate systems for the dynamic model is shown below: Dimension in Figure Corresponding Variable Name in the Sample Project in the Function Block DynModel_Scara2_Z h0 baseHeight h1 armOneHeight h2 armTwoHeight h3 zAxisLength h4 zAxisOffset l1 armOneLength l1 armTwoLength " }, 
{ "title" : "Part 1: Using a dynamic model in an application ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4592064830952033369979173999", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Dynamic Robot Model \/ Part 1: Using a dynamic model in an application ", 
"snippet" : "Using a dynamic model in an application requires a model which implements the ISMDynamics interface of the SM3_Dynamics library. The dynamic model from Part 2: Creating a dynamic robot model is used for this demonstration. The model can be assigned to an axis group using SMC_GroupSetDynamics . This ...", 
"body" : "Using a dynamic model in an application requires a model which implements the ISMDynamics interface of the SM3_Dynamics library. The dynamic model from Part 2: Creating a dynamic robot model is used for this demonstration. The model can be assigned to an axis group using SMC_GroupSetDynamics . This step requires setting up the gravitational acceleration with respect to the MCS. Because the SCARA in this example is mounted on the floor, the gravitational acceleration points in the positive z0 direction. The gravitational acceleration has to be specified in user units u\/s². Because all lengths in this example have been defined in the user unit m, also the gravitational acceleration has to be specified in m\/s². SMC_ChangeDynamicLimits can be used to adjust the limits of each axis. Note that the axis group has to be enabled again using MC_GroupEnable in order to activate the new dynamic limits. If additional masses are added to the TCP (for example, a tool or an object which is picked up by the robot), then SMC_GroupSetLoad can be used to define the load. The PLC_PRG program contains all of the above components and executes two test movements: Movement 1 Movement 2 Straight arm movement from (a0=0°, a1=0°, a2=0 m) to (a0=90°, a1=0°, a2=0,02 m): Angled arm movement from (a0=0°, a1=-120°, a2=0 m) to (a0=90°, a1=-120°, a2=0,02 m): Each movement is executed three consecutive times with the following boundary conditions: The torque limit of all axes is infinite (unlimited). The torque limit of Arm 2 is set to a lower value than the maximum reached torque during unlimited movement. The value was arbitrarily set to 2 Nm . The torque limit of Arm 2 is still 2 Nm , and additionally a load has been applied at the TCP ( mLoad=3 kg , lLoad=0.2 m ): The inertia calculation for the load has been simplified by using thin rods: The movements can be monitored in the trace. Movement 1 has the following results: Even though Arm 2 does not move during Movement 1, the movement of Arm 1 results in a torque for Arm 2 during acceleration\/deceleration. The calculated torque is sent to the drive and can potentially improve the controller loop in controller mode SMC_velocity or SMC_position . This is also called torque feed forward control. The second pass with limited torque shows that the torque limit of Arm 2 leads to a slower movement of Arm 1. And that even if Arm 2 does not move. Without the dynamic model, the acceleration and deceleration of Arm 1 would have to be reduced manually for this movement in order to prevent excessive mechanical stress on Arm 2. The third run with a load slows down the movement of Arm 1 even more in order to not violate the torque limit of Arm 2. The advantages of using a dynamic model are obvious. To prevent excessive mechanical stress without dynamic model: Either the dynamic limits for every movement would have to be set depending on the current state of the robot. Or the dynamic limits of all axes would have to be decreased in such a way that all potential movements will not lead to excessive mechanical stress on any axis. The first method is a complex task and it can be difficult to calculate reasonable limits, while the second method results in movements which are not as fast as possible most of the time. These drawbacks no longer exist with a dynamic model because the robot always moves as fast as possible while still respecting the mechanical limits of each axis. These advantages are illustrated by the results of Movement 2: Due to the angled Arm 2, the resulting torque of Arm 2 is considerably lower than with Movement 1. Therefore, all three runs are never limited by the axis torque. If one had used adjusted dynamic limits based on Movement 1 (reduced acceleration and deceleration in order to not violate the torque limit of Arm 2), then this movement would have been slower than necessary. " }, 
{ "title" : "Part 2: Creating a dynamic robot model ", 
"url" : "_sm_dynamic_robot_model.html#UUID-21347f71-cabb-badd-d9a0-0c3a2412973c_section-idm4583105024958433369980945572", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Dynamic Robot Model \/ Part 2: Creating a dynamic robot model ", 
"snippet" : "The model which is created in this example is based on an algorithm for open-chain robots as presented in the book \"Modern Robotics\" by K. M. Lynch and F. C. Park (see Chapter 8 \"Dynamics of Open Chains\"). The explanation of this algorithm is beyond the scope of this example. Instead, the example fo...", 
"body" : "The model which is created in this example is based on an algorithm for open-chain robots as presented in the book \"Modern Robotics\" by K. M. Lynch and F. C. Park (see Chapter 8 \"Dynamics of Open Chains\"). The explanation of this algorithm is beyond the scope of this example. Instead, the example focuses on how to define the input values of the algorithm. Simplifications To make this example more understandable, some simplifications have been made: The arm lengths l1 and l2 (distance between the axes of rotation) are used as their respective total arm length. The center of mass is always located in the geometric center of each link. The spatial inertia matrices of the arms and the Z-axis are calculated for thin rods. Dynamic model requirements In order to use the dynamic model in a SoftMotion application, this model has to implement the ISMDynamics interface of the SM3_Dynamics library. The zero position, coordinate systems, and the positive direction of rotation of the dynamic model can theoretically deviate from the kinematic model. However, these differences have to be taken into consideration, and to simplify the dynamic model, it is therefore recommended to use the definitions of the kinematic model. Because the dynamic model must compute torque values in Nm and forces in N, it has to convert the user unit u for lengths to SI units m. The conversion factor can be set by SMC_GroupSetUnits and is included in the addParams input of ISMDynamics.AxesStateToTorque . This example uses only m for lengths and can therefore ignore the conversion factor. Specification of the geometric and dynamic data of the model The IEC implementation of the algorithm presented in the book \"Modern Robotics\" by K. M. Lynch and F. C. Park (see Chapter 8 \"Dynamics of Open Chains\") requires the following input values: The center of mass position of each link when the robot is in the home position. The position is specified in the coordinate system of the previous link (the first link is specified relative to the base coordinate system). The spatial inertia matrix and mass of each link, expressed in the respective link frame. The screw axis of each joint, expressed in the base frame. Center of mass positions The frames with the center of mass position of each link are as follows: Link Frame Arm 1 The center of mass of Arm 1, expressed in the base coordinate system x 0 , y 0 , z 0 : Note that there is a rotation of 180° around the x0-axis. Arm 2 The center of mass of Arm 2, expressed in the coordinate system of Arm 1: Z-axis The center of mass of the Z-axis expressed in the coordinate system of Arm 2: Tool Center Point (TCP) One additional frame to handle an arbitrary load at the TCP (for example, by a tool, a product, or a combination of both), expressed in the coordinate system of the Z-axis: Spatial inertia matrices The spatial inertia values have to be expressed in the respective link frame. Since the frames are defined at the center of mass, the spatial inertia can be represented by a 3x3 rotational inertia matrix and the mass of the body. With the simplification of using thin rods for the joints, the components of the rotational inertia matrix are as follows: Link Components of the rotational inertia matrix Arm 1, Arm 2 Arm 1 and Arm 2 with their corresponding mass m1 and m2 , and length l1 and l2 : Z-axis Screw axes The screw axes of all joints have to be expressed relative to the base coordinate system x 0 , y 0 , z 0 . Link Screw Axis Arm 1 Imagine a turntable which rotates around Joint 1 in the positive direction with an angular velocity of 1 rad\/s. Expressed in the base coordinate system, this is a positive rotation around the z 0 -axis according to the right-hand rule: Because the axis of rotation of Arm 1 is equal to the center of the base coordinate system, the linear velocity is zero: Arm 2 Imagine again a turntable which rotates around Joint 2 in the positive direction with an angular velocity of 1 rad\/s. This case is displayed below as a top view of Arm 1: As for Arm 1, the angular velocity is: The figure shows the resulting linear velocity v 2,y , which points in negative y 0 direction and is equal to v 2,y =-ω 2,z * l 1 . Z-axis The Z-axis is a prismatic axis for which the following rules apply: The angular velocity vector ω is zero. The linear velocity vector is a unit vector in the direction of positive translation. This leads to the following vectors, expressed in the base coordinate system x 0 , y 0 , z 0 : Tests The dynamic model can now be tested because all model parameters are defined. This section includes some basic tests of the model. Checking the screw axes A screw axis S with angular velocity ω and linear velocity v can be expressed as an element of se(3) : A forward transformation T can be executed with the screw axes S , an end effector frame M for the zero position of the robot, and the joint angle θ of each joint: The sample project already includes a function which solves this equation (see SMC_OpenChainKinematics_SolveForward ). For more details, see the book \"Modern Robotics\" by K. M. Lynch and F. C. Park. Using the forward transformation equation, one can now run a test with known axis positions and check if the transformation leads to the expected result. Checking the torque calculation at standstill To check the center of mass position frames, you can manually calculate the resulting axis torque in standstill for given axis positions and compare them to the computed values by the model. Because this example is based on a SCARA robot mounted on the floor, all axis positions in standstill will lead to the same torques or forces of the drives: Joint Resulting Torque\/Force Arm 1 Because Arm 1 is a revolute axis, the result is a torque: M1=0 Nm . Arm 2 Because Arm 2 is a revolute axis, the result is a torque: M2=0 Nm . Z-axis Because the Z-axis is a prismatic axis, the result is a force: F3=m3*g N with gravitational acceleration g . " }, 
{ "title" : "Custom Kinematics ", 
"url" : "_sm_example_custom_robotics_kinematic.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Custom Kinematics ", 
"snippet" : "See the CustomKinematics_Implementation.project sample project and the CustomKinematics.library library in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples. This example describes how to create a library with a custom kinematic transformation ( Gantry3C ) and how to use thi...", 
"body" : "See the CustomKinematics_Implementation.project sample project and the CustomKinematics.library library in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples. This example describes how to create a library with a custom kinematic transformation ( Gantry3C ) and how to use this library in a project to control the robot. The Gantry3C kinematic transformation consists of 3 linear axes (X, Y, and Z) which carry a tool head. The tool head consists of an extra axis which carries a mounted tool. The tool head can be rotated around the Z-axis. " }, 
{ "title" : "1. Create a new library project. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_3b0657d06b6990f1c0a8646379b25f1e", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Custom Kinematics \/ 1. Create a new library project. ", 
"snippet" : "Create a new project with the Empty library template....", 
"body" : "Create a new project with the Empty library template. " }, 
{ "title" : "2. Add a Library Manager. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_0125d98b6b6990f1c0a8646339c29917", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Custom Kinematics \/ 2. Add a Library Manager. ", 
"snippet" : "Add a Library Manager to the POUs view. Add the SM3_Transformation , SM3_Math , and SM3_Error libraries to the Library Manager....", 
"body" : "Add a Library Manager to the POUs view. Add the SM3_Transformation , SM3_Math , and SM3_Error libraries to the Library Manager. " }, 
{ "title" : "3. Create the Gantry3C function block. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_b156dbec6b6990f1c0a86463322b661a", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Custom Kinematics \/ 3. Create the Gantry3C function block. ", 
"snippet" : "This function block implements the interfaces MC_KIN_REF_SM3 and ISMKinematicsWithInfo2 from the library SM3_Transformation . You can define an offset as input for each axis. This offset is subtracted before the forward transformation and added after the inverse transformation. Example of Gantry3C w...", 
"body" : "This function block implements the interfaces MC_KIN_REF_SM3 and ISMKinematicsWithInfo2 from the library SM3_Transformation . You can define an offset as input for each axis. This offset is subtracted before the forward transformation and added after the inverse transformation. Example of Gantry3C with two decoupled kinematics and KinCoupled : FUNCTION_BLOCK Custom_Kin_Gantry3 IMPLEMENTS ISMPositionKinematics\nFUNCTION_BLOCK Custom_Kin_CAxis IMPLEMENTS ISMOrientationKinematics\n\nFUNCTION_BLOCK Custom_Kin_Gantry3C EXTENDS Kin_Coupled Provide the function blocks Custom_Kin_Gantry3 and Custom_Kin_CAxis as inputs for the Kin_Coupled function block during initialization. Now Custom_Kin_Gantry3C becomes a coupled kinematics combining the position and orientation kinematics. " }, 
{ "title" : "4. Implement the methods of the MC_KIN_REF_SM3 interface and the NumAxes4 property. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_f0953a666b6990f1c0a864632a54ddd5", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Custom Kinematics \/ 4. Implement the methods of the MC_KIN_REF_SM3 interface and the NumAxes4 property. ", 
"snippet" : "AxesToCartesian : Forward kinematics: Calculation of the position and orientation from the axis values. CartesianToAxes : Inverse kinematics: Calculation of the axis values from position and orientation. NumAxes : Number of axes of the kinematics...", 
"body" : "AxesToCartesian : Forward kinematics: Calculation of the position and orientation from the axis values. CartesianToAxes : Inverse kinematics: Calculation of the axis values from position and orientation. NumAxes : Number of axes of the kinematics " }, 
{ "title" : "5. Implement the methods of the ISMKinematicsWithInfo2 and ISMKinematicsWithInfo interfaces. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_cd5f17f76b6990f1c0a86463705dcfa1", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Custom Kinematics \/ 5. Implement the methods of the ISMKinematicsWithInfo2 and ISMKinematicsWithInfo interfaces. ", 
"snippet" : "GetAxisProperties : Properties, such as type of axis. The limits for each axis can be defined. GetKinematicsName : Name of the kinematics IsSingularity : Can be ignored for this kinematics...", 
"body" : "GetAxisProperties : Properties, such as type of axis. The limits for each axis can be defined. GetKinematicsName : Name of the kinematics IsSingularity : Can be ignored for this kinematics " }, 
{ "title" : "6. Specify the project information. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_2f5ca72b6b6990f1c0a864634f9c8dd7", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Custom Kinematics \/ 6. Specify the project information. ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "7. Check the library for compiler errors. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_24eaad936b6990f1c0a864633896924b", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Custom Kinematics \/ 7. Check the library for compiler errors. ", 
"snippet" : "To check the library, click Build → Check all Pool Objects ....", 
"body" : "To check the library, click Build → Check all Pool Objects . " }, 
{ "title" : "8. Create the description in the axis group configurator. ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_51fd948a6c11885ac0a8646354b16b84", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Custom Kinematics \/ 8. Create the description in the axis group configurator. ", 
"snippet" : "To create the description, you first need to install the CODESYS Library Documentation Support add-on. This add-on contains the libdoc.exe program which is required in the following instructions. The add-on can be installed via the CODESYS Installer . When the POU has the attribute sm_kin_libdoc , t...", 
"body" : "To create the description, you first need to install the CODESYS Library Documentation Support add-on. This add-on contains the libdoc.exe program which is required in the following instructions. The add-on can be installed via the CODESYS Installer . When the POU has the attribute sm_kin_libdoc , the comment specified in the function block is used in the axis group configurator as a description of the kinematics. Restructured text formatting is used for this. To generate the description of the kinematics from the function block comments in the axis group editor, follow these steps: Include the attribute sm_kin_libdoc as shown in the image above. Include the required project properties DocFormat and DocLanguages (in the project information dialog) related to the library documentation. Result: Make sure that the installation directory of CODESYS contains the libdoc.exe executable file (directory: ...\\DocScripting\\3.5.xx.0 \\). Download the 32-bit wkhtmltox converter with version 0.12.5 or lower from https:\/\/wkhtmltopdf.org\/downloads.html . Extract the wkhtmltox.dll file and copy it to ...\\DocScripting\\3.5.xx.0\\bin in the CODESYS installation directory. Since wkhtmltox.dll no longer supports images by default in Version 0.12.6 and higher, you need to use Version 0.12.5 or lower. Create the system variable LIBDOC_CODESYS in Windows. Set the value to the file path of CODESYS.exe . Make sure to specify the path name and the profile name in double quotation marks. Result: Save, close, and reopen the library project. Click the File → Save Project as Compiled Library command. The compiled library will be installed to the project which uses this kinematics. " }, 
{ "title" : "Using the library in a project (CustomKinematics_Implementation.project) ", 
"url" : "_sm_example_custom_robotics_kinematic.html#UUID-d687401d-476b-23de-45d1-f0700ce2274d_id_a80f1b6b2f6136c0a8646352eee4c5_id_3c747e2a6b6990f1c0a864637a72fb84", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Custom Kinematics \/ Using the library in a project (CustomKinematics_Implementation.project) ", 
"snippet" : "The project demonstrates how to use and control the kinematics created in the previous section by jogging or commanding a movement. Create a CODESYS standard project with the CODESYS SoftMotion Win controller. Open the Library Manager and install the library CustomKinematics.compiled-library (create...", 
"body" : "The project demonstrates how to use and control the kinematics created in the previous section by jogging or commanding a movement. Create a CODESYS standard project with the CODESYS SoftMotion Win controller. Open the Library Manager and install the library CustomKinematics.compiled-library (created in the previous section) containing the kinematics Gantry3C. Add the library to the Library Manager. Add an axis group object and select the KinCustom.Gantry3C kinematics. Result: Add 4 virtual axes to the SoftMotion General Axis Pool axis pool in the device tree. (DriveX, Y, Z, and C) Open the axis group configurator. In the Mapping to Axes section, map the axes to their respective fields. Result: The program Prg_Visu is the main program that controls the axis group. When the application is started, Prg_Visu powers up the axis group and enables it. Moreover, it calls all necessary function blocks to control the axis group (jogging, linear and PTP movements). All of these movements can be controlled from the attached visualization. Result: Function block: Jog : This FB combines jogging in axis space as well as in Cartesian space. It uses two instances of SMC_GroupJog2 . One is for axis space and the other is for Cartesian space. This function block can be used with the visualization templates V_RobotPosition_axes and V_RobotPosition_cart_Jog to jog any kinematics in Cartesian and axis space. Result: FB SMC_TRAFOF_Gantry3C : This function block transforms the input axis values of a Gantry3C kinematics to its respective TCP values. In addition, the axis values are normalized so that they can be used with the visualization template TRAFOF_Gantry3C_YZ to visualize the movements of the kinematics. Result: Compile and run the application. Open the visualization. You can jog the robot in axis space as well as in Cartesian space. There are also visualization templates to command a linear or a PTP movement. Result: The example described here discusses the positioning and orientation axes in a common function block. Many kinematics can comprise two decoupled partial kinematics: one positioning kinematic (delta, gantry, etc.) and one orientation kinematics (tools like C-axis, Wrist2, Wrist3, etc.). Both kinematics are connected to each other at the \"flange point\", the TCP of the positioning kinematics. The orientation kinematics is characterized by the fact that it is able to calculate the vector from the flange point to the TCP of the coupled kinematics. The calculation is done using only the orientation of this TCP (meaning that it is independent of the positioning kinematics or independent of the orientation of the flange point). The positioning kinematics in turn has to be able to determine its axis positions from only the position of the flange point. It must not depend on the orientation of the flange point. In this case, you can resort to interfaces such as ISMPositionKinematics or ISMOrientationKinematics . To implement these interfaces, define one function block to implement ISMPositionKinematics and another function block to implement ISMOrientationKinematics . Finally, define a function block that extends the function block Kin_Coupled (from SM3_Transformation ) with the previously defined function blocks as inputs. For more information, see the following: Creating Custom Kinematics" }, 
{ "title" : "Using Depictor to Visualize Axis Groups ", 
"url" : "_sm_example_axis_group_depictor.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Using Depictor to Visualize Axis Groups ", 
"snippet" : "For this project, you also need the CODESYS Depictor add-on with a valid license. The SoftMotion application consists of four rotary drives configured as an axis group. The first three axes move the TCP in the X\/Y-plane, and the fourth axis in the Z-plane. The example demonstrates how you can use De...", 
"body" : "For this project, you also need the CODESYS Depictor add-on with a valid license. The SoftMotion application consists of four rotary drives configured as an axis group. The first three axes move the TCP in the X\/Y-plane, and the fourth axis in the Z-plane. The example demonstrates how you can use Depictor with the Kin_Scara3_Z kinematic configuration. You can also customize the same procedure for other kinematic configurations. Starting and testing the program You can modify the axis values in the visualization of the project. If you comment out the active movement command ( MoveAbs... , ...) in the program PLC_PRG and remove the comments of the second movement command, then you can modify the Cartesian coordinates. Build the project and download it to the PLC. Open the editor of the Depictor object in your project. Switch to the visualization and modify the axis values or the Cartesian values. Observe the movement of the SCARA robot in Depictor. " }, 
{ "title" : "Creating the standard project ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a87f67372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Using Depictor to Visualize Axis Groups \/ Creating the standard project ", 
"snippet" : "Create a standard project with the CODESYS SoftMotion Win controller and the ST programming language. Add a Library Manager in the POUs view. Open the Library Manager and add the libraries SM3_Depictor and DepictorBase ....", 
"body" : "Create a standard project with the CODESYS SoftMotion Win controller and the ST programming language. Add a Library Manager in the POUs view. Open the Library Manager and add the libraries SM3_Depictor and DepictorBase . " }, 
{ "title" : "Adding and parameterizing the axes ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a65c81372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Using Depictor to Visualize Axis Groups \/ Adding and parameterizing the axes ", 
"snippet" : "Insert four virtual axes below the object SoftMotion General Axis Pool and name the axes as Drive1...Drive4. Parameterize the axes Drive1, Drive2, Drive3, and Drive4 as axis type finite with software limit switches from -180 degrees to 180 degrees. Configuration editor: For more information, see: Vi...", 
"body" : "Insert four virtual axes below the object SoftMotion General Axis Pool and name the axes as Drive1...Drive4. Parameterize the axes Drive1, Drive2, Drive3, and Drive4 as axis type finite with software limit switches from -180 degrees to 180 degrees. Configuration editor: For more information, see: Virtual Drive" }, 
{ "title" : "Configuring the axis groups ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a5e750372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Using Depictor to Visualize Axis Groups \/ Configuring the axis groups ", 
"snippet" : "Add a \"KinScara\" axis group below the application. To do this, click Project → Add Object → Axis Group . In the configurator, click Select kinematics . Select the TRAFO.Kin_Scara3_Z kinematics. Define the parameters as follows: dArmLength1 , dArmLength2 , dArmLength3 : 500 dOffsetA1 , dOffsetA2 , dO...", 
"body" : "Add a \"KinScara\" axis group below the application. To do this, click Project → Add Object → Axis Group . In the configurator, click Select kinematics . Select the TRAFO.Kin_Scara3_Z kinematics. Define the parameters as follows: dArmLength1 , dArmLength2 , dArmLength3 : 500 dOffsetA1 , dOffsetA2 , dOffsetA3 , dOffsetZ : 0 Order the axes as follows: A1 : Drive1 A2 : Drive2 A3 : Drive3 Z : Drive4 Note: You can drag the axes directly into the input field. For more information, see: Kinematics" }, 
{ "title" : "Creating the controller program ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_26c321018be5c522c0a864636ae45467", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Using Depictor to Visualize Axis Groups \/ Creating the controller program ", 
"snippet" : "In the PLC_PRG program, declare instances of the MC_Power function block for all drives. Create an istate variable for the statechart. VAR Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 : MC_Power; istate: INT; END_VAR Define a statechart in the implementation. CASE istate OF 0: 1: 2: END_CA...", 
"body" : "In the PLC_PRG program, declare instances of the MC_Power function block for all drives. Create an istate variable for the statechart. VAR\n Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 : MC_Power;\n istate: INT;\nEND_VAR Define a statechart in the implementation. CASE istate OF\n 0:\n 1:\n 2:\nEND_CASE Activate all drives in state 0 . 0:\n Power_Drive1(Axis:=Drive1, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive2(Axis:=Drive2, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive3(Axis:=Drive3, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive4(Axis:=Drive4, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n IF Power_Drive1.Status AND Power_Drive2.Status AND Power_Drive3.Status AND Power_Drive4.Status THEN\n istate:=istate+1;\n END_IF When the axes are activated, enable the axis group (switch from \"deactivated\" to \"standby\"). VAR\n GroupEnable:MC_GroupEnable;\nEND_VAR\n\n1:\n GroupEnable(AxisGroup:=KinScara, Execute:=TRUE);\n IF GroupEnable.Done THEN\n istate:=istate+1;\n END_IF Declare and initialize a variable to save the set value in machine coordinates. Declare two instances of type SMC_POS_REF to represent the TCP in Cartesian and axis coordinates. VAR\n Frame: MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & orientation of the TCP\n Pos_Cart: SMC_POS_REF; \/\/ This variable represents the position of the TCP in cartesian coordinates coordinates\n Pos_Axis: SMC_POS_REF := (a := axispos);\/\/ This variable represents the position of the TCP in Axis coordinates\nEND_VAR\nVAR CONSTANT\n axispos: TRAFO.AXISPOS_REF := (a0 := 0, a1 := 100, a2:=60);\nEND_VAR\n\n2:\n Pos_Cart.c:= Frame; \/\/ To represent the TCP in cartesian coordinates; Declare an instance of MC_MoveDirectAbsolute to move the SCARA robot to the specified coordinates. VAR\n MoveAbs:MC_MoveDirectAbsolute; \/\/ Moves the TCP to the defined coordinates\nEND_VAR\n\n2:\n MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Axis,CoordSystem:=SMC_COORD_SYSTEM.ACS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined Axis coordinates\n \/\/MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Cart,CoordSystem:=SMC_COORD_SYSTEM.MCS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined cartesian coordinates\n\n IF MoveAbs.Done THEN\n MoveAbs(AxisGroup:=KinScara, Execute:=FALSE); \/\/ Waits for the next new coordinates\n istate:=2;\n END_IF Declare a variable of type SMC_GroupReadSetPosition to read the current value of the robot in Cartesian coordinates and axis coordinates. VAR\n Car_pos, Axis_pos :SMC_GroupReadSetPosition; \/\/to read the current axis values\nEND_VAR\n\n2:\n Car_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.MCS, Enable:=TRUE); \/\/ to read the current position in cartesian coordinates\n Axis_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.ACS, Enable:=TRUE); \/\/ to read the current axis values " }, 
{ "title" : "The entire PLC_PRG program ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a5721f372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Using Depictor to Visualize Axis Groups \/ The entire PLC_PRG program ", 
"snippet" : "Compare your program and add the missing program parts. Declaration PROGRAM PLC_PRG VAR Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 :MC_Power; istate: INT; GroupEnable:MC_GroupEnable; Frame:MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & orientation of th...", 
"body" : "Compare your program and add the missing program parts. Declaration PROGRAM PLC_PRG\nVAR\n Power_Drive1, Power_Drive2, Power_Drive3, Power_Drive4 :MC_Power;\n istate: INT;\n\n GroupEnable:MC_GroupEnable;\n\n Frame:MC_COORD_REF:=(X:=-120, Y:=-25); \/\/ This variable stores the cartesian position & orientation of the TCP\n Pos_Cart:SMC_POS_REF; \/\/ This variable represents the position of the TCP in cartesian coordinates coordinates\n Pos_Axis:SMC_POS_REF := (a := axispos);\/\/ This variable represents the position of the TCP in Axis coordinates\n\n MoveAbs:MC_MoveDirectAbsolute; \/\/ Moves the TCP to the defined coordinates (PTP)\n\n Car_pos,Axis_pos :SMC_GroupReadSetPosition; \/\/to read the current position of the TCP in Cartesian and Axis Coordinates and display it on the visu\n\n scara_Config:trafo.Kin_Scara3_Z_Config; \/\/ To set the configuration of the SCARA_3_Z\n kin_Config:SMC_SetKinConfiguration; \/\/ To set the defined configuration of SCARA_3_Z to the axis group used\n nPeriod:DINT:=0; \/\/ SCARA_3_Z Period\n Xelbow:BOOL:=TRUE;\n\nEND_VAR\nVAR CONSTANT\n axispos : TRAFO.AXISPOS_REF := (a0 := 0, a1 := 100, a2:=60);\nEND_VAR Implementation CASE istate OF\n\n0:\n Power_Drive1(Axis:=Drive1, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive2(Axis:=Drive2, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive3(Axis:=Drive3, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n Power_Drive4(Axis:=Drive4, Enable:=TRUE, bRegulatorOn:=TRUE, bDriveStart:=TRUE);\n\n IF Power_Drive1.Status AND Power_Drive2.Status AND Power_Drive3.Status AND Power_Drive4.Status THEN\n istate:=istate+1;\n END_IF\n\n1:\n GroupEnable(AxisGroup:=KinScara, Execute:=TRUE);\n\n IF GroupEnable.Done THEN\n istate:=istate+1;\n END_IF\n\n2:\n scara_Config(xElbowRight:=Xelbow, nPeriodA3:=nPeriod);\n kin_Config(AxisGroup:=KinScara,ConfigData:=scara_Config.Config, Execute:=TRUE);\n Pos_Cart.c:=Frame; \/\/ To represent the TCP in cartesian coordinates\n\n Car_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.MCS, Enable:=TRUE); \/\/ read the current position in cartesian coordinates\n Axis_pos(AxisGroup:=KinScara, CoordSystem:=SM3_Robotics.SMC_COORD_SYSTEM.ACS, Enable:=TRUE); \/\/ read the current position in Axis coordinates\n\n MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Axis,CoordSystem:=SMC_COORD_SYSTEM.ACS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined axis coordinates\n \/\/MoveAbs(AxisGroup:=KinScara, Execute:=TRUE, Position:=Pos_Cart,CoordSystem:=SMC_COORD_SYSTEM.MCS, BufferMode:=MC_BUFFER_MODE.Aborting,); \/\/move to the defined cartesian coordinates\n\n IF MoveAbs.Done THEN\n MoveAbs(AxisGroup:=KinScara, Execute:=FALSE); \/\/ Waits for the next new coordinates\n istate:=2;\n END_IF\nEND_CASE " }, 
{ "title" : "Creating a Depictor program ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_8f044cf9373811e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Using Depictor to Visualize Axis Groups \/ Creating a Depictor program ", 
"snippet" : "Add a new \"Depic\" POU of \"Program\" type below the application. To do this, click Project → Add Object → POU . Declare a variable of type SM3_Depictor.SMC_R_Scara3_Z_Data . Declare a variable LrSize of type LREAL and initialize the variable with the value of 100. VAR ScaraTrafo : SM3_Depictor.SMC_R_S...", 
"body" : "Add a new \"Depic\" POU of \"Program\" type below the application. To do this, click Project → Add Object → POU . Declare a variable of type SM3_Depictor.SMC_R_Scara3_Z_Data . Declare a variable LrSize of type LREAL and initialize the variable with the value of 100. VAR\n ScaraTrafo : SM3_Depictor.SMC_R_Scara3_Z_Data;\n LrSize:LREAL:=100;\nEND_VAR Insert a call to the function block in the implementation. ScaraTrafo(AxisGroup:=KinScara, trf:=KinScara.trafo); Add the \"Depic\" POU to the MainTask . " }, 
{ "title" : "Configuring Depictor ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a523fe372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Using Depictor to Visualize Axis Groups \/ Configuring Depictor ", 
"snippet" : "Add a \"Depictor\" object below the application. To do this, click Project → Add Object → Depictor . Double-click the object. Select the Pose element in the Depictor tree. Click Depictor → Add element . The Box element is added below the pose. Select the Depictor Ref. option in the properties of the e...", 
"body" : "Add a \"Depictor\" object below the application. To do this, click Project → Add Object → Depictor . Double-click the object. Select the Pose element in the Depictor tree. Click Depictor → Add element . The Box element is added below the pose. Select the Depictor Ref. option in the properties of the element. Click the button. Select the SMC_R_Depictor_Scara3_Z object from the SM3_Depictor library. Define the interface variables as follows: fb : Depic.ScaraTrafo lrZ_ : Drive1.fSetPosition lrZmin : 10 lrZmax : -50 lrSize : Depic.LrSize xShowPlane : 0 " }, 
{ "title" : "Creating visualizations ", 
"url" : "_sm_example_axis_group_depictor.html#UUID-adaebd9c-7fec-018f-197b-06c51ee69c23_id_cada68ad5b70ec0a8646377cce8dd_id_e6a460ad372511e89a02e282cd8cf073", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Using Depictor to Visualize Axis Groups \/ Creating visualizations ", 
"snippet" : "Create a visualization screen in which the Cartesian coordinates and the axis coordinates can be displayed and modified. Add a \"Visualization\" object below the application. To do this, click Project → Add Object → Visualization . Open the visualization in the editor. Insert a Rectangle visualization...", 
"body" : "Create a visualization screen in which the Cartesian coordinates and the axis coordinates can be displayed and modified. Add a \"Visualization\" object below the application. To do this, click Project → Add Object → Visualization . Open the visualization in the editor. Insert a Rectangle visualization element (1). Change the properties of the element. Texts → Text : %s Text variables → Text variable : PLC_PRG.Car_pos.Position.c.X Input configuration → OnMouseDown → Write Variable Input type : VisuDialogs.Numpad Use another variable : PLC_PRG.Frame.X Insert the other Box visualization elements. Change the properties of elements (2) and (3). Texts → Text : %s Text variables → Text variable : PLC_PRG.Car_pos.Position.c.Y or PLC_PRG.Car_pos.Position.c.Z Input configuration → OnMouseDown → Write Variable Input type : VisuDialogs.Numpad Use another variable : PLC_PRG.Frame.Y and PLC_PRG.Frame.Z Change the properties of elements (4), (5), and (6). Texts → Text : %s Text variables → Text variable : PLC_PRG.Frame.A or PLC_PRG.Frame.B or PLC_PRG.Frame.C Change the properties of elements (7), (8), (9), and (10). Texts → Text : %s Text variables → Text variable : PLC_PRG.Axis_pos.Position.a.a0 or PLC_PRG.Axis_pos.Position.a.a1 or PLC_PRG.Axis_pos.Position.a.a2 or PLC_PRG.Axis_pos.Position.a.a3 Input configuration → OnMouseDown → Write Variable Input type : VisuDialogs.Numpad Use another variable : PLC_PRG.Pos_Axis.a.a0 and PLC_PRG.Pos_Axis.a.a1 and PLC_PRG.Pos_Axis.a.a2 and PLC_PRG.Pos_Axis.a.a3 Label the visualization elements with the Label element. " }, 
{ "title" : "Trigger Example 1: Simple Example ", 
"url" : "_sm_example_digital_switches1.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Trigger Example 1: Simple Example ", 
"snippet" : "The Robotics_Trigger.project sample project described here is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . Triggers are used to find out exactly when an axis group reaches a specific point on the commanded path. This information can be used, for example, to...", 
"body" : "The Robotics_Trigger.project sample project described here is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . Triggers are used to find out exactly when an axis group reaches a specific point on the commanded path. This information can be used, for example, to switch a tool on or off at exactly the right time. This example shows how a single trigger is commanded on a movement and then read out cyclically. Based on this, the Trigger Example 2: Gluing Process project shows a realistic sample application. " }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_example_digital_switches1.html#UUID-69fc12d0-622f-ba4d-33ec-32604b337f95_section-idm4609369968113633803655575311", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Trigger Example 1: Simple Example \/ Structure of the application ", 
"snippet" : "The application consists of two programs: a Main_PRG running in the bus task and a Planning_PRG running in the axis group planning task. In addition, there is also a trace. Main_PRG : The Main_PRG program contains the main state machine of the application. The first two states are used to initialize...", 
"body" : "The application consists of two programs: a Main_PRG running in the bus task and a Planning_PRG running in the axis group planning task. In addition, there is also a trace. Main_PRG : The Main_PRG program contains the main state machine of the application. The first two states are used to initialize and switch on the drives and the axis group. In the STATE_COMMAND_MOVEMENT_WITH_TRIGGER state, a trigger is first prepared using an instance from the SMC_GroupPrepareTrigger function block. The position is specified relatively with a value of 0.6. As a result, the trigger is placed at the point where 60% of the assigned movement is completed. The prepared trigger is assigned to the next commanded movement. In this example, a linear movement to position (X=20, Y=10) is commanded by an MC_MoveLinearAbsolute . prepTrigger.PositionType := SMC_TriggerPositionType.MvtRelative;\nprepTrigger.Position.MvtPosition := 0.6;\nprepTrigger(AxisGroup:= AxisGroup, Execute:= TRUE);\n \nmoveLinear(AxisGroup:= AxisGroup, Execute:= prepTrigger.Prepared); In the next state STATE_ENABLE_READ_TRIGGER , an instance of SMC_GroupReadTrigger is started in order to read the state of the commanded trigger. The link to the trigger is established by means of the TriggerId returned by SMC_GroupPrepareTrigger . readTrigger.TriggerId := prepTrigger.TriggerId;\nreadTrigger.Enable := TRUE; In the STATE_CHECK_TRIGGER state, the status of the trigger is finally checked cyclically. As soon as SMC_GroupReadTrigger reports Active as the status, the duration until the trigger is reached can be read. The duration always refers to the start of the current cycle. Therefore, the trigger is reached in the current cycle if the duration is less than the cycle time (in this example, 0.004 s): IF readTrigger.TriggerInfo.status = SMC_TRIGGER_STATUS.Active THEN\n IF readTrigger.TriggerInfo.triggerTime <= 0.004 THEN\n triggerFired := TRUE;\n ...\n END_IF\nEND_IF Planning_PRG In the Planning_PRG program, the forecast duration of the planning is configured by means of the SMC_TuneCPKernel function block. The SMC_GroupReadTrigger function block can output when a trigger is reached forecast duration. In the example, the forecast duration is set to 0.1 s. Therefore, the status of the SMC_GroupReadTrigger function block changes to Active 0.1 s before the axis group reaches the trigger and outputs a valid duration from then on. tuneCpKernel(AxisGroup:= axisGroup, Execute:= TRUE, fPlanningForecastDuration:= 0.1); Trace The trace can be used to track the behavior of the SMC_GroupReadTrigger function block. In the first diagram, you can see that a movement is executed from (X=0, Y=0) to (X=20, Y=10). The trigger is located at the relative position 0.6 on the movement, i.e. at (X=12, Y=6). The second diagram shows the value of the triggerTime output from SMC_GroupReadTrigger . The value jumps to 0.1s because the forecast duration of the planning is 0.1s, and then drops linearly until the value 0 is reached at the position (X=12, Y=6). The third diagram shows the value of the triggerFired variable which is set in the STATE_CHECK_TRIGGER state of Main_PRG as soon as the axis group is less than 0.004 s away from the trigger. " }, 
{ "title" : "Trigger Example 2: Gluing Process ", 
"url" : "_sm_example_digital_switches2.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Trigger Example 2: Gluing Process ", 
"snippet" : "The Robotics_Trigger_Advanced.project sample project described here is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . Triggers can be used to perform actions at specific positions on the path, such as switching a gluing nozzle on and off. This example include...", 
"body" : "The Robotics_Trigger_Advanced.project sample project described here is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . Triggers can be used to perform actions at specific positions on the path, such as switching a gluing nozzle on and off. This example includes the following components: The configuration of a guaranteed forecast of the trajectory by the fPlanningForecastDuration parameter from the SMC_TuneCPKernel function block. The commanding of different triggers. Here, all three available methods for defining the path position are used (see SMC_TriggerPositionType ). The use of triggers with time shift. The sample application contains the TriggerWithTimeShift function block, which can react to reaching the path position with a time offset (earlier and later). These components are shown in a sample application for a gluing process. The movement displayed in red in the following image is executed (with blending). Triggers have been defined at the positions marked in green: Position 1: Switch on the gluing device 0.05 s before reaching the position. Position 1: Switch on the UV lamp when the position is reached. Position 2: Fill the glue supply container when the position is reached. Position 3: Switch off the gluing device and stop filling the glue supply container 0.05 s before reaching the position. Position 3: Switch off the UV lamp 1.5 s after reaching the position " }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4589008317470433803801762921", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Trigger Example 2: Gluing Process \/ Structure of the application ", 
"snippet" : "The application consists of the following parts. GlueApplication : This program contains the sample application which shows how to use of triggers for a gluing process. Planning_PRG : In this program, a forecast of the trajectory is configured. TriggerWithTimeShift : This function block contains the...", 
"body" : "The application consists of the following parts. GlueApplication : This program contains the sample application which shows how to use of triggers for a gluing process. Planning_PRG : In this program, a forecast of the trajectory is configured. TriggerWithTimeShift : This function block contains the logic for triggers with a time shift and is used in the GlueApplication sample program. Trace : The trace shows the dynamics of the axes and also the outputs of the GlueApplication program which are switched by the triggers. " }, 
{ "title" : "Configuration of a forecast ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4570491496867233803803206327", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Trigger Example 2: Gluing Process \/ Configuration of a forecast ", 
"snippet" : "If you want to react early before a trigger is reached, for example 0.05 s before, then the fPlanningForecastDuration parameter from the SMC_ SMC_TuneCPKernel function block has to be set to at least 0.05 s. Because the parameter has a direct impact on the latency, its value should not be larger tha...", 
"body" : "If you want to react early before a trigger is reached, for example 0.05 s before, then the fPlanningForecastDuration parameter from the SMC_ SMC_TuneCPKernel function block has to be set to at least 0.05 s. Because the parameter has a direct impact on the latency, its value should not be larger than necessary (see the documentation of fPlanningForecastDuration ). Note that SMC_TuneCPKernel has to be called in the SoftMotion planning task. For this reason, the configuration is not executed in the main program GlueApplication , but in the Planning_PRG program. In this sample application, the evaluation of the trigger is required at the earliest 0.05 s before a position is reached. For this reason, the parameter fPlanningForecastDuration =0.05 is set in the Planning_PRG program. " }, 
{ "title" : "Function block: TriggerWithTimeShift ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4609369977958433803803968971", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Trigger Example 2: Gluing Process \/ Function block: TriggerWithTimeShift ", 
"snippet" : "The TriggerWithTimeShift function block provides a simplified interface for using triggers. In addition, a time shift can be defined so that the trigger can react before a position (positive value) as well as after a position (negative value) is reached. Depending on the time precision required in a...", 
"body" : "The TriggerWithTimeShift function block provides a simplified interface for using triggers. In addition, a time shift can be defined so that the trigger can react before a position (positive value) as well as after a position (negative value) is reached. Depending on the time precision required in an application, the reaction to reaching a trigger can be as follows: Required time precision >= bus task cycle: In this case, the TriggerWithTimeShift.TriggerReachedThisCycle output can be used. Required time precision < bus task cycle: In this case, the exact remaining time TriggerWithTimeShift.TriggerTime until the trigger is reached can be used. Internally, TriggerWithTimeShift uses the SMC_GroupPrepareTrigger and SMC_GroupReadTrigger function blocks. " }, 
{ "title" : "Commanding triggers ", 
"url" : "_sm_example_digital_switches2.html#UUID-d1f4984c-fc16-5e4e-ab95-835627c512c7_section-idm4608844104630433803805051855", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Trigger Example 2: Gluing Process \/ Commanding triggers ", 
"snippet" : "In the GlueApplication program, the movements and triggers are commanded. The call order is particularly important for triggers because the triggers prepared using SMC_GroupPrepareTrigger are assigned to the next movement commanded in the same cycle. Therefore, in every application you need to pay a...", 
"body" : "In the GlueApplication program, the movements and triggers are commanded. The call order is particularly important for triggers because the triggers prepared using SMC_GroupPrepareTrigger are assigned to the next movement commanded in the same cycle. Therefore, in every application you need to pay attention to the following: Function blocks for commanding triggers are always called before the movement function blocks. Triggers and the respective movement are always commanded in the same cycle. The triggers use all types from SMC_TriggerPositionType : The triggers at Position 1 use the definition of a relative distance ( SMC_TriggerPositionType.MvtRelative ) and as Position 0.5. Because the respective movement has a distance of 10, the triggers are located at X=5. The trigger at Position 2 uses the definition of a distance in user units u ( SMC_TriggerPositionType.MvtDistance ) and as Position 5. As a result, the trigger is also located at X=5. The triggers at Position 3 use the intersection with a plane ( SMC_TriggerPositionType.PlaneIntersection ). The plane has been defined so that the triggers are located at X=5. GlueApplication has the EnableGlue , EnableUVLamp , and RefillGlueStorage outputs. These are switched at the appropriate triggers in GlueApplication.EvaluateTriggers() . The movement and state of these outputs can be monitored and evaluated in the trace. " }, 
{ "title" : "Using Additional Axes in Robotics ", 
"url" : "_sm_example_additional_axes.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Using Additional Axes in Robotics ", 
"snippet" : "The Robotics_AdditionalAxes.project sample project shows how additional axes are configured and used in robotics. Additional axes are axes which are moved synchronously with coordinated movements of the robot. The project is located in the installation directory of CODESYS under ..\\CODESYS SoftMotio...", 
"body" : "The Robotics_AdditionalAxes.project sample project shows how additional axes are configured and used in robotics. Additional axes are axes which are moved synchronously with coordinated movements of the robot. The project is located in the installation directory of CODESYS under ..\\CODESYS SoftMotion\\Examples . " }, 
{ "title" : "Structure of the application ", 
"url" : "_sm_example_additional_axes.html#UUID-c2402508-ef5a-d02d-ee68-db3b85c8530d_section-idm235063293414778", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Using Additional Axes in Robotics \/ Structure of the application ", 
"snippet" : "The axis group is configured in the AxisGroup object. A SCARA robot with 3 axes (two rotary axes and one linear Z-axis) is used. Two additional axes have also been added below Additional Axes and linked to the two axes DriveAdd1 and DriveAdd2 . The PLC_PRG program contains a simple state machine for...", 
"body" : "The axis group is configured in the AxisGroup object. A SCARA robot with 3 axes (two rotary axes and one linear Z-axis) is used. Two additional axes have also been added below Additional Axes and linked to the two axes DriveAdd1 and DriveAdd2 . The PLC_PRG program contains a simple state machine for the program flow. First the axis group is enabled in state 0 , and then a PTP movement to position (X=50, Y=50) is performed. This is then blended into a linear movement to position (X=50, Y=-50) . For the first robot movement, a relative additional axis movement with distance (10, 20) is commanded. For the second robot movement, the distance of the additional axis is (-10, -20) . The MC_GroupReadActualPosition and MC_GroupReadActualVelocity function blocks are used to read the position and velocity of the kinematics and of the additional axes. " }, 
{ "title" : "Commissioning ", 
"url" : "_sm_example_additional_axes.html#UUID-c2402508-ef5a-d02d-ee68-db3b85c8530d_section-idm235063296617065", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ Examples \/ Using Additional Axes in Robotics \/ Commissioning ", 
"snippet" : "Build the application and download it to a controller. Open the trace and download it to the controller. Start the application. You can track the movement of the X and Y coordinates and the two additional axes in the trace....", 
"body" : "Build the application and download it to a controller. Open the trace and download it to the controller. Start the application. You can track the movement of the X and Y coordinates and the two additional axes in the trace. " }, 
{ "title" : "User Interface ", 
"url" : "_sm_robotics_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ User Interface ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Command: Create Planning Task ", 
"url" : "_sm_cmd_create_planning_task.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ User Interface \/ Command: Create Planning Task ", 
"snippet" : "Function : The command creates a planning task automatically. This task is needed for the planning of CP movements (for example, move linear or move circular). Call : Project menu; context menu of the axis group Requirement : The command is available only if no planning task is configured for the ax...", 
"body" : "Function : The command creates a planning task automatically. This task is needed for the planning of CP movements (for example, move linear or move circular). Call : Project menu; context menu of the axis group Requirement : The command is available only if no planning task is configured for the axis group. " }, 
{ "title" : "Axis Group Editor ", 
"url" : "_sm_obj_axis_group-1018069.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ CODESYS SoftMotion Robotics \/ User Interface \/ Axis Group Editor ", 
"snippet" : "Symbol: In the editor of the Axis group object, select the type of basic kinematics and orientation kinematics. Orientation kinematics can be selected only when it is supported by the basic kinematics. In addition, you map the axes of the kinematics to the drives in your project. Kinematics Select k...", 
"body" : "Symbol: In the editor of the Axis group object, select the type of basic kinematics and orientation kinematics. Orientation kinematics can be selected only when it is supported by the basic kinematics. In addition, you map the axes of the kinematics to the drives in your project. Kinematics Select kinematics Change kinematics Opens a list of all kinematics which are supported by CODESYS When you select a type of kinematics, a short description is shown in the frame to the right of the list. After you select a type of kinematics, you can modify the respective parameters in the editor. Orientation kinematics Select kinematics Change kinematics Opens a list of all orientation kinematics that are supported by CODESYS When you select a type of kinematics, a short description is shown in the frame to the right of the list. After you select a type of kinematics, you can modify the respective parameters in the editor. Axis mapping Depending on the selected kinematics, you map the axes of the kinematics to the drives in your project. Additional axes Add Axis Adds a configuration field for an additional axis. The drive from the project is entered in this configuration field. Tasks Bus cycle task Bus cycle task of the axes, if axes are already mapped The setting cannot be changed here. Planning task Task for the planning of CP tasks A planning task is created automatically when the first axis group is inserted. A watchdog should not be configured because the execution time may fluctuate considerably. For more information, see the following: Configuration of the Planning TaskIf you delete this task, then an error is issued to the message view. To create a new task, click Project → Create planning task . For more information, see the following: How to Create an Axis Group" }, 
{ "title" : "User Interface ", 
"url" : "_sm_user_interface.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ User Interface ", 
"snippet" : "...", 
"body" : "" }, 
{ "title" : "Command: Enable SoftMotion ", 
"url" : "_sm_cmd_enable_softmotion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ User Interface \/ Command: Enable SoftMotion ", 
"snippet" : "Function : The command enables the components of SoftMotion for the selected controller and makes it possible to use the controller as a motion controller. Call : Project menu; context menu of a selected device in the device tree Requirement : For the selected controller, SoftMotion is not enabled. ...", 
"body" : "Function : The command enables the components of SoftMotion for the selected controller and makes it possible to use the controller as a motion controller. Call : Project menu; context menu of a selected device in the device tree Requirement : For the selected controller, SoftMotion is not enabled. The command causes the SoftMotion General Axis Pool device to be added below the controller configuration as long as the object is still missing. There is at most one SoftMotion General Axis Pool per PLC device. Moreover, the SoftMotion libraries (with prefix SM3_ ) are added to the Library Manager. As a result, you can use the SoftMotion functionality on all conventional PLCs and, for example, call the SoftMotion function blocks even without a license at least in demo mode. Automatic activation If your device is disabled for SoftMotion and you added any SoftMotion object below the device, then the Enable SoftMotion command is immediately executed implicitly. A SoftMotion object is a cam object, a CNC object, an axis group object, or any SoftMotion axis. Device update from a SoftMotion PLC to a standard PLC If SoftMotion has been enabled and devices have been configured below SoftMotion General Axis Pool , then you can update your device to a standard PLC anyway. This is because these devices remain available even after the update. For example, you can update from CODESYS SoftMotion RTE to CODESYS Control RTE without any losses. " }, 
{ "title" : "Command: Disable SoftMotion ", 
"url" : "_sm_cmd_disable_softmotion.html", 
"breadcrumbs" : "CODESYS SoftMotion \/ User Interface \/ Command: Disable SoftMotion ", 
"snippet" : "Function : The command disables the components of SoftMotion . Call : Project menu; context menu of a selected device in the device tree Requirement : For the selected controller, SoftMotion was enabled by means of the command. SoftMotion cannot be disabled for controllers which are intended to supp...", 
"body" : "Function : The command disables the components of SoftMotion . Call : Project menu; context menu of a selected device in the device tree Requirement : For the selected controller, SoftMotion was enabled by means of the command. SoftMotion cannot be disabled for controllers which are intended to support SoftMotion (example: CODESYS SoftMotion Win ). The command causes the SoftMotion General Axis Pool device to be removed from below the controller configuration. Moreover, the SoftMotion libraries (with prefix SM3_ ) are removed from the Library Manager. You can no longer use the SoftMotion functionality. " }
]
$(document).trigger('search.ready');
});